
.\dist\FreeRTOS\production\tcpip_iperf_10base_t1s_freertos.X.production.elf:     file format elf32-littlearm


Disassembly of section .config_00804000:

00804000 <__config_00804000>:
  804000:	39 12 00 3c                                         9..<

Disassembly of section .config_00804008:

00804008 <__config_00804008>:
  804008:	ff ff ff ff                                         ....

Disassembly of section .config_00804004:

00804004 <__config_00804004>:
  804004:	80 00 a8 2a                                         ...*

Disassembly of section .vectors:

00000000 <exception_table>:
   0:	f0 ff 03 20 9d 89 01 00 c7 67 01 00 17 6c 01 00     ... .....g...l..
  10:	87 77 01 00 13 7a 01 00 e7 80 01 00 00 00 00 00     .w...z..........
	...
  2c:	d1 05 02 00 ef 72 01 00 00 00 00 00 21 b3 01 00     .....r......!...
  3c:	81 fa 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .....X...X...X..
  4c:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
  5c:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
  6c:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
  7c:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
  8c:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
  9c:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
  ac:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
  bc:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
  cc:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
  dc:	8b 58 01 00 8b 58 01 00 8b 58 01 00 00 00 00 00     .X...X...X......
	...
  f4:	8b 58 01 00 b1 10 01 00 b1 10 01 00 b1 10 01 00     .X..............
 104:	b1 10 01 00 15 01 01 00 15 01 01 00 15 01 01 00     ................
 114:	15 01 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .....X...X...X..
 124:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
 134:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
 144:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
 154:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
 164:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
 174:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
 184:	8b 58 01 00 8b 58 01 00 8b 58 01 00 b9 f0 01 00     .X...X...X......
 194:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
 1a4:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
 1b4:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
 1c4:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
 1d4:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
 1e4:	8b 58 01 00 8b 58 01 00 d1 f9 01 00 8b 58 01 00     .X...X.......X..
 1f4:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
 204:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
 214:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
 224:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
 234:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
 244:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..
 254:	8b 58 01 00 8b 58 01 00 8b 58 01 00 8b 58 01 00     .X...X...X...X..

Disassembly of section .text:

00000264 <_init>:
 264:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 266:	bf00      	nop
 268:	bcf8      	pop	{r3, r4, r5, r6, r7}
 26a:	bc08      	pop	{r3}
 26c:	469e      	mov	lr, r3
 26e:	4770      	bx	lr

00000270 <__init_array_start>:
 270:	0001d919 	.word	0x0001d919

00000274 <_fini>:
 274:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 276:	bf00      	nop
 278:	bcf8      	pop	{r3, r4, r5, r6, r7}
 27a:	bc08      	pop	{r3}
 27c:	469e      	mov	lr, r3
 27e:	4770      	bx	lr

00000280 <__fini_array_start>:
 280:	0001d8f5 	.word	0x0001d8f5

Disassembly of section .rodata%180:

0000028c <.rodata%180>:
     28c:	67617355 	.word	0x67617355
     290:	6d203a65 	.word	0x6d203a65
     294:	6e696361 	.word	0x6e696361
     298:	0d206f66 	.word	0x0d206f66
     29c:	0000000a 	.word	0x0000000a
     2a0:	203a7845 	.word	0x203a7845
     2a4:	6963616d 	.word	0x6963616d
     2a8:	206f666e 	.word	0x206f666e
     2ac:	00000a0d 	.word	0x00000a0d
     2b0:	65746e49 	.word	0x65746e49
     2b4:	63616672 	.word	0x63616672
     2b8:	25203a65 	.word	0x25203a65
     2bc:	72442073 	.word	0x72442073
     2c0:	72657669 	.word	0x72657669
     2c4:	61745320 	.word	0x61745320
     2c8:	74736974 	.word	0x74736974
     2cc:	0d736369 	.word	0x0d736369
     2d0:	0000000a 	.word	0x0000000a
     2d4:	52200a0d 	.word	0x52200a0d
     2d8:	69656365 	.word	0x69656365
     2dc:	53206576 	.word	0x53206576
     2e0:	69746174 	.word	0x69746174
     2e4:	63697473 	.word	0x63697473
     2e8:	000a0d73 	.word	0x000a0d73
     2ec:	526e2009 	.word	0x526e2009
     2f0:	506b4f78 	.word	0x506b4f78
     2f4:	656b6361 	.word	0x656b6361
     2f8:	203a7374 	.word	0x203a7374
     2fc:	0a0d6425 	.word	0x0a0d6425
     300:	526e2009 	.word	0x526e2009
     304:	6e655078 	.word	0x6e655078
     308:	66754264 	.word	0x66754264
     30c:	73726566 	.word	0x73726566
     310:	6425203a 	.word	0x6425203a
     314:	20090a0d 	.word	0x20090a0d
     318:	5378526e 	.word	0x5378526e
     31c:	64656863 	.word	0x64656863
     320:	66667542 	.word	0x66667542
     324:	3a737265 	.word	0x3a737265
     328:	0d642520 	.word	0x0d642520
     32c:	0000000a 	.word	0x0000000a
     330:	526e2009 	.word	0x526e2009
     334:	72724578 	.word	0x72724578
     338:	6150726f 	.word	0x6150726f
     33c:	74656b63 	.word	0x74656b63
     340:	25203a73 	.word	0x25203a73
     344:	090a0d64 	.word	0x090a0d64
     348:	78526e20 	.word	0x78526e20
     34c:	67617246 	.word	0x67617246
     350:	746e656d 	.word	0x746e656d
     354:	6f727245 	.word	0x6f727245
     358:	203a7372 	.word	0x203a7372
     35c:	0a0d6425 	.word	0x0a0d6425
     360:	526e2009 	.word	0x526e2009
     364:	66754278 	.word	0x66754278
     368:	746f4e66 	.word	0x746f4e66
     36c:	69617641 	.word	0x69617641
     370:	6c62616c 	.word	0x6c62616c
     374:	25203a65 	.word	0x25203a65
     378:	000a0d64 	.word	0x000a0d64
     37c:	54200a0d 	.word	0x54200a0d
     380:	736e6172 	.word	0x736e6172
     384:	2074696d 	.word	0x2074696d
     388:	74617453 	.word	0x74617453
     38c:	69747369 	.word	0x69747369
     390:	0a0d7363 	.word	0x0a0d7363
     394:	00000000 	.word	0x00000000
     398:	546e2009 	.word	0x546e2009
     39c:	506b4f78 	.word	0x506b4f78
     3a0:	656b6361 	.word	0x656b6361
     3a4:	203a7374 	.word	0x203a7374
     3a8:	0a0d6425 	.word	0x0a0d6425
     3ac:	546e2009 	.word	0x546e2009
     3b0:	6e655078 	.word	0x6e655078
     3b4:	66754264 	.word	0x66754264
     3b8:	73726566 	.word	0x73726566
     3bc:	6425203a 	.word	0x6425203a
     3c0:	20090a0d 	.word	0x20090a0d
     3c4:	4578546e 	.word	0x4578546e
     3c8:	726f7272 	.word	0x726f7272
     3cc:	6b636150 	.word	0x6b636150
     3d0:	3a737465 	.word	0x3a737465
     3d4:	0d642520 	.word	0x0d642520
     3d8:	6e20090a 	.word	0x6e20090a
     3dc:	75517854 	.word	0x75517854
     3e0:	46657565 	.word	0x46657565
     3e4:	3a6c6c75 	.word	0x3a6c6c75
     3e8:	0d642520 	.word	0x0d642520
     3ec:	000a0d0a 	.word	0x000a0d0a
     3f0:	746f6e09 	.word	0x746f6e09
     3f4:	70757320 	.word	0x70757320
     3f8:	74726f70 	.word	0x74726f70
     3fc:	0a0d6465 	.word	0x0a0d6465
     400:	00000000 	.word	0x00000000
     404:	65746e49 	.word	0x65746e49
     408:	63616672 	.word	0x63616672
     40c:	25203a65 	.word	0x25203a65
     410:	61482073 	.word	0x61482073
     414:	61776472 	.word	0x61776472
     418:	52206572 	.word	0x52206572
     41c:	73696765 	.word	0x73696765
     420:	20726574 	.word	0x20726574
     424:	74617453 	.word	0x74617453
     428:	0a0d7375 	.word	0x0a0d7375
     42c:	00000000 	.word	0x00000000
     430:	73252009 	.word	0x73252009
     434:	7830203a 	.word	0x7830203a
     438:	0a0d7825 	.word	0x0a0d7825
     43c:	00000000 	.word	0x00000000
     440:	61736964 	.word	0x61736964
     444:	64656c62 	.word	0x64656c62
     448:	00000000 	.word	0x00000000
     44c:	61736964 	.word	0x61736964
     450:	00656c62 	.word	0x00656c62
     454:	62616e65 	.word	0x62616e65
     458:	0064656c 	.word	0x0064656c
     45c:	62616e65 	.word	0x62616e65
     460:	0000656c 	.word	0x0000656c
     464:	67617355 	.word	0x67617355
     468:	25203a65 	.word	0x25203a65
     46c:	693c2073 	.word	0x693c2073
     470:	7265746e 	.word	0x7265746e
     474:	65636166 	.word	0x65636166
     478:	6f3c203e 	.word	0x6f3c203e
     47c:	666f2f6e 	.word	0x666f2f6e
     480:	0d203e66 	.word	0x0d203e66
     484:	0000000a 	.word	0x0000000a
     488:	203a7845 	.word	0x203a7845
     48c:	50207325 	.word	0x50207325
     490:	32334349 	.word	0x32334349
     494:	20544e49 	.word	0x20544e49
     498:	0d206e6f 	.word	0x0d206e6f
     49c:	0000000a 	.word	0x0000000a
     4a0:	6e6b6e55 	.word	0x6e6b6e55
     4a4:	206e776f 	.word	0x206e776f
     4a8:	65746e69 	.word	0x65746e69
     4ac:	63616672 	.word	0x63616672
     4b0:	000a0d65 	.word	0x000a0d65
     4b4:	00006e6f 	.word	0x00006e6f
     4b8:	0066666f 	.word	0x0066666f
     4bc:	6e6b6e55 	.word	0x6e6b6e55
     4c0:	206e776f 	.word	0x206e776f
     4c4:	6974706f 	.word	0x6974706f
     4c8:	0a0d6e6f 	.word	0x0a0d6e6f
     4cc:	00000000 	.word	0x00000000
     4d0:	25207325 	.word	0x25207325
     4d4:	000a0d73 	.word	0x000a0d73
     4d8:	6c696146 	.word	0x6c696146
     4dc:	74206465 	.word	0x74206465
     4e0:	7325206f 	.word	0x7325206f
     4e4:	0d732520 	.word	0x0d732520
     4e8:	0000000a 	.word	0x0000000a
     4ec:	6e6b6e55 	.word	0x6e6b6e55
     4f0:	206e776f 	.word	0x206e776f
     4f4:	76726573 	.word	0x76726573
     4f8:	20656369 	.word	0x20656369
     4fc:	0a0d7325 	.word	0x0a0d7325
     500:	00000000 	.word	0x00000000
     504:	656e6f6e 	.word	0x656e6f6e
     508:	00000000 	.word	0x00000000
     50c:	00001774 	.word	0x00001774
     510:	00000001 	.word	0x00000001
     514:	00001290 	.word	0x00001290
     518:	00000002 	.word	0x00000002
     51c:	000004b4 	.word	0x000004b4
     520:	00000003 	.word	0x00000003
     524:	000004b8 	.word	0x000004b8
     528:	00000003 	.word	0x00000003
     52c:	00001778 	.word	0x00001778
     530:	00000004 	.word	0x00000004
     534:	67617355 	.word	0x67617355
     538:	64203a65 	.word	0x64203a65
     53c:	2063736e 	.word	0x2063736e
     540:	6c65643c 	.word	0x6c65643c
     544:	666e692f 	.word	0x666e692f
     548:	6e6f2f6f 	.word	0x6e6f2f6f
     54c:	66666f2f 	.word	0x66666f2f
     550:	6f6f6c2f 	.word	0x6f6f6c2f
     554:	3e70756b 	.word	0x3e70756b
     558:	000a0d20 	.word	0x000a0d20
     55c:	67617355 	.word	0x67617355
     560:	25203a65 	.word	0x25203a65
     564:	6f3c2073 	.word	0x6f3c2073
     568:	666f2f6e 	.word	0x666f2f6e
     56c:	3c203e66 	.word	0x3c203e66
     570:	65746e69 	.word	0x65746e69
     574:	63616672 	.word	0x63616672
     578:	3c203e65 	.word	0x3c203e65
     57c:	69727473 	.word	0x69727473
     580:	702f7463 	.word	0x702f7463
     584:	3e666572 	.word	0x3e666572
     588:	6c633c2f 	.word	0x6c633c2f
     58c:	3e726165 	.word	0x3e726165
     590:	000a0d20 	.word	0x000a0d20
     594:	203a7845 	.word	0x203a7845
     598:	6f207325 	.word	0x6f207325
     59c:	7465206e 	.word	0x7465206e
     5a0:	0a0d3068 	.word	0x0a0d3068
     5a4:	00000000 	.word	0x00000000
     5a8:	69727473 	.word	0x69727473
     5ac:	00007463 	.word	0x00007463
     5b0:	66657270 	.word	0x66657270
     5b4:	00000000 	.word	0x00000000
     5b8:	61656c63 	.word	0x61656c63
     5bc:	00000072 	.word	0x00000072
     5c0:	67617355 	.word	0x67617355
     5c4:	64203a65 	.word	0x64203a65
     5c8:	2063736e 	.word	0x2063736e
     5cc:	6b6f6f6c 	.word	0x6b6f6f6c
     5d0:	3c207075 	.word	0x3c207075
     5d4:	65707974 	.word	0x65707974
     5d8:	683c203e 	.word	0x683c203e
     5dc:	4e74736f 	.word	0x4e74736f
     5e0:	3e656d61 	.word	0x3e656d61
     5e4:	000a0d20 	.word	0x000a0d20
     5e8:	706c6548 	.word	0x706c6548
     5ec:	683c203a 	.word	0x683c203a
     5f0:	4e74736f 	.word	0x4e74736f
     5f4:	3e656d61 	.word	0x3e656d61
     5f8:	4c525528 	.word	0x4c525528
     5fc:	202d2029 	.word	0x202d2029
     600:	6b6f6f6c 	.word	0x6b6f6f6c
     604:	20707520 	.word	0x20707520
     608:	20726f66 	.word	0x20726f66
     60c:	74736f68 	.word	0x74736f68
     610:	656d616e 	.word	0x656d616e
     614:	00000a0d 	.word	0x00000a0d
     618:	706c6548 	.word	0x706c6548
     61c:	743c203a 	.word	0x743c203a
     620:	3e657079 	.word	0x3e657079
     624:	61203a20 	.word	0x61203a20
     628:	20726f20 	.word	0x20726f20
     62c:	6f662041 	.word	0x6f662041
     630:	50492072 	.word	0x50492072
     634:	61203476 	.word	0x61203476
     638:	65726464 	.word	0x65726464
     63c:	6c207373 	.word	0x6c207373
     640:	756b6f6f 	.word	0x756b6f6f
     644:	000a0d70 	.word	0x000a0d70
     648:	706c6548 	.word	0x706c6548
     64c:	743c203a 	.word	0x743c203a
     650:	3e657079 	.word	0x3e657079
     654:	61203a20 	.word	0x61203a20
     658:	20616161 	.word	0x20616161
     65c:	4120726f 	.word	0x4120726f
     660:	20414141 	.word	0x20414141
     664:	20726f66 	.word	0x20726f66
     668:	36765049 	.word	0x36765049
     66c:	64646120 	.word	0x64646120
     670:	73736572 	.word	0x73736572
     674:	6f6f6c20 	.word	0x6f6f6c20
     678:	0d70756b 	.word	0x0d70756b
     67c:	0000000a 	.word	0x0000000a
     680:	706c6548 	.word	0x706c6548
     684:	743c203a 	.word	0x743c203a
     688:	3e657079 	.word	0x3e657079
     68c:	61203a20 	.word	0x61203a20
     690:	6620796e 	.word	0x6620796e
     694:	6220726f 	.word	0x6220726f
     698:	2068746f 	.word	0x2068746f
     69c:	34765049 	.word	0x34765049
     6a0:	646e6120 	.word	0x646e6120
     6a4:	76504920 	.word	0x76504920
     6a8:	64612036 	.word	0x64612036
     6ac:	73657264 	.word	0x73657264
     6b0:	6f6c2073 	.word	0x6f6c2073
     6b4:	70756b6f 	.word	0x70756b6f
     6b8:	00000a0d 	.word	0x00000a0d
     6bc:	63736e64 	.word	0x63736e64
     6c0:	6f6f6c20 	.word	0x6f6f6c20
     6c4:	3a70756b 	.word	0x3a70756b
     6c8:	6d6f6320 	.word	0x6d6f6320
     6cc:	646e616d 	.word	0x646e616d
     6d0:	206e6920 	.word	0x206e6920
     6d4:	676f7270 	.word	0x676f7270
     6d8:	73736572 	.word	0x73736572
     6dc:	6552202e 	.word	0x6552202e
     6e0:	20797274 	.word	0x20797274
     6e4:	6574616c 	.word	0x6574616c
     6e8:	0a0d2e72 	.word	0x0a0d2e72
     6ec:	00000000 	.word	0x00000000
     6f0:	00000041 	.word	0x00000041
     6f4:	00000061 	.word	0x00000061
     6f8:	41414141 	.word	0x41414141
     6fc:	00000000 	.word	0x00000000
     700:	61616161 	.word	0x61616161
     704:	00000000 	.word	0x00000000
     708:	00594e41 	.word	0x00594e41
     70c:	00796e61 	.word	0x00796e61
     710:	63736e64 	.word	0x63736e64
     714:	6f6f6c20 	.word	0x6f6f6c20
     718:	3a70756b 	.word	0x3a70756b
     71c:	73255b20 	.word	0x73255b20
     720:	6f4c205d 	.word	0x6f4c205d
     724:	70756b6f 	.word	0x70756b6f
     728:	70795420 	.word	0x70795420
     72c:	6f6e2065 	.word	0x6f6e2065
     730:	75732074 	.word	0x75732074
     734:	726f7070 	.word	0x726f7070
     738:	2e646574 	.word	0x2e646574
     73c:	00000a0d 	.word	0x00000a0d
     740:	63736e64 	.word	0x63736e64
     744:	6f6f6c20 	.word	0x6f6f6c20
     748:	3a70756b 	.word	0x3a70756b
     74c:	736f4820 	.word	0x736f4820
     750:	616e2074 	.word	0x616e2074
     754:	7420656d 	.word	0x7420656d
     758:	6c206f6f 	.word	0x6c206f6f
     75c:	2e676e6f 	.word	0x2e676e6f
     760:	74655220 	.word	0x74655220
     764:	0d2e7972 	.word	0x0d2e7972
     768:	0000000a 	.word	0x0000000a
     76c:	63736e64 	.word	0x63736e64
     770:	6f6f6c20 	.word	0x6f6f6c20
     774:	3a70756b 	.word	0x3a70756b
     778:	73657220 	.word	0x73657220
     77c:	69766c6f 	.word	0x69766c6f
     780:	6820676e 	.word	0x6820676e
     784:	3a74736f 	.word	0x3a74736f
     788:	20732520 	.word	0x20732520
     78c:	20726f66 	.word	0x20726f66
     790:	65707974 	.word	0x65707974
     794:	2073253a 	.word	0x2073253a
     798:	00000a0d 	.word	0x00000a0d
     79c:	67617355 	.word	0x67617355
     7a0:	64203a65 	.word	0x64203a65
     7a4:	2063736e 	.word	0x2063736e
     7a8:	206c6564 	.word	0x206c6564
     7ac:	736f683c 	.word	0x736f683c
     7b0:	6d614e74 	.word	0x6d614e74
     7b4:	617c3e65 	.word	0x617c3e65
     7b8:	0d206c6c 	.word	0x0d206c6c
     7bc:	0000000a 	.word	0x0000000a
     7c0:	706c6548 	.word	0x706c6548
     7c4:	683c203a 	.word	0x683c203a
     7c8:	4e74736f 	.word	0x4e74736f
     7cc:	3e656d61 	.word	0x3e656d61
     7d0:	4c525528 	.word	0x4c525528
     7d4:	202d2029 	.word	0x202d2029
     7d8:	6f6d6552 	.word	0x6f6d6552
     7dc:	74206576 	.word	0x74206576
     7e0:	65206568 	.word	0x65206568
     7e4:	7972746e 	.word	0x7972746e
     7e8:	20666920 	.word	0x20666920
     7ec:	73697865 	.word	0x73697865
     7f0:	0d207374 	.word	0x0d207374
     7f4:	0000000a 	.word	0x0000000a
     7f8:	706c6548 	.word	0x706c6548
     7fc:	6c61203a 	.word	0x6c61203a
     800:	202d206c 	.word	0x202d206c
     804:	6f6d6552 	.word	0x6f6d6552
     808:	61206576 	.word	0x61206576
     80c:	74206c6c 	.word	0x74206c6c
     810:	72206568 	.word	0x72206568
     814:	6c6f7365 	.word	0x6c6f7365
     818:	20646576 	.word	0x20646576
     81c:	72746e65 	.word	0x72746e65
     820:	0a0d2079 	.word	0x0a0d2079
     824:	00000000 	.word	0x00000000
     828:	006c6c61 	.word	0x006c6c61
     82c:	5d73255b 	.word	0x5d73255b
     830:	746f6e20 	.word	0x746f6e20
     834:	72617020 	.word	0x72617020
     838:	666f2074 	.word	0x666f2074
     83c:	65687420 	.word	0x65687420
     840:	534e4420 	.word	0x534e4420
     844:	63614320 	.word	0x63614320
     848:	65206568 	.word	0x65206568
     84c:	7972746e 	.word	0x7972746e
     850:	000a0d20 	.word	0x000a0d20
     854:	6f636e49 	.word	0x6f636e49
     858:	656c706d 	.word	0x656c706d
     85c:	63206574 	.word	0x63206574
     860:	616d6d6f 	.word	0x616d6d6f
     864:	0d20646e 	.word	0x0d20646e
     868:	0000000a 	.word	0x0000000a
     86c:	67617355 	.word	0x67617355
     870:	64203a65 	.word	0x64203a65
     874:	2063736e 	.word	0x2063736e
     878:	6f666e69 	.word	0x6f666e69
     87c:	000a0d20 	.word	0x000a0d20
     880:	706c6548 	.word	0x706c6548
     884:	6964203a 	.word	0x6964203a
     888:	616c7073 	.word	0x616c7073
     88c:	68742079 	.word	0x68742079
     890:	4e442065 	.word	0x4e442065
     894:	61632053 	.word	0x61632053
     898:	20656863 	.word	0x20656863
     89c:	72746e65 	.word	0x72746e65
     8a0:	65642079 	.word	0x65642079
     8a4:	6c696174 	.word	0x6c696174
     8a8:	0a0d2073 	.word	0x0a0d2073
     8ac:	00000000 	.word	0x00000000
     8b0:	20534e44 	.word	0x20534e44
     8b4:	65696c43 	.word	0x65696c43
     8b8:	6920746e 	.word	0x6920746e
     8bc:	6f642073 	.word	0x6f642073
     8c0:	0d216e77 	.word	0x0d216e77
     8c4:	0000000a 	.word	0x0000000a
     8c8:	20534e44 	.word	0x20534e44
     8cc:	65696c43 	.word	0x65696c43
     8d0:	4920746e 	.word	0x4920746e
     8d4:	202d2046 	.word	0x202d2046
     8d8:	69727453 	.word	0x69727453
     8dc:	203a7463 	.word	0x203a7463
     8e0:	202c7325 	.word	0x202c7325
     8e4:	66657250 	.word	0x66657250
     8e8:	65727265 	.word	0x65727265
     8ec:	25203a64 	.word	0x25203a64
     8f0:	000a0d73 	.word	0x000a0d73
     8f4:	20534e44 	.word	0x20534e44
     8f8:	65696c43 	.word	0x65696c43
     8fc:	2d20746e 	.word	0x2d20746e
     900:	6d697420 	.word	0x6d697420
     904:	25203a65 	.word	0x25203a65
     908:	70202c64 	.word	0x70202c64
     90c:	69646e65 	.word	0x69646e65
     910:	203a676e 	.word	0x203a676e
     914:	202c6425 	.word	0x202c6425
     918:	72727563 	.word	0x72727563
     91c:	3a746e65 	.word	0x3a746e65
     920:	2c642520 	.word	0x2c642520
     924:	746f7420 	.word	0x746f7420
     928:	203a6c61 	.word	0x203a6c61
     92c:	0a0d6425 	.word	0x0a0d6425
     930:	00000000 	.word	0x00000000
     934:	74736f48 	.word	0x74736f48
     938:	656d616e 	.word	0x656d616e
     93c:	25203d20 	.word	0x25203d20
     940:	0a0d2073 	.word	0x0a0d2073
     944:	656d6954 	.word	0x656d6954
     948:	2074756f 	.word	0x2074756f
     94c:	6425203d 	.word	0x6425203d
     950:	000a0d20 	.word	0x000a0d20
     954:	34765049 	.word	0x34765049
     958:	73253d20 	.word	0x73253d20
     95c:	00000a0d 	.word	0x00000a0d
     960:	36765049 	.word	0x36765049
     964:	25203d20 	.word	0x25203d20
     968:	000a0d73 	.word	0x000a0d73
     96c:	2d2d2d2d 	.word	0x2d2d2d2d
     970:	2d2d2d2d 	.word	0x2d2d2d2d
     974:	2d2d2d2d 	.word	0x2d2d2d2d
     978:	2d2d2d2d 	.word	0x2d2d2d2d
     97c:	2d2d2d2d 	.word	0x2d2d2d2d
     980:	2d2d2d2d 	.word	0x2d2d2d2d
     984:	2d2d2d2d 	.word	0x2d2d2d2d
     988:	2d2d2d2d 	.word	0x2d2d2d2d
     98c:	2d2d2d2d 	.word	0x2d2d2d2d
     990:	2d2d2d2d 	.word	0x2d2d2d2d
     994:	2d2d2d2d 	.word	0x2d2d2d2d
     998:	2d2d2d2d 	.word	0x2d2d2d2d
     99c:	2d2d2d2d 	.word	0x2d2d2d2d
     9a0:	00000a0d 	.word	0x00000a0d
     9a4:	44206f4e 	.word	0x44206f4e
     9a8:	4320534e 	.word	0x4320534e
     9ac:	6e65696c 	.word	0x6e65696c
     9b0:	61432074 	.word	0x61432074
     9b4:	20656863 	.word	0x20656863
     9b8:	72746e65 	.word	0x72746e65
     9bc:	20736569 	.word	0x20736569
     9c0:	00000a0d 	.word	0x00000a0d
     9c4:	61766e49 	.word	0x61766e49
     9c8:	2064696c 	.word	0x2064696c
     9cc:	75706e49 	.word	0x75706e49
     9d0:	6f432074 	.word	0x6f432074
     9d4:	6e616d6d 	.word	0x6e616d6d
     9d8:	5b3a2064 	.word	0x5b3a2064
     9dc:	20732520 	.word	0x20732520
     9e0:	0a0d205d 	.word	0x0a0d205d
     9e4:	00000000 	.word	0x00000000
     9e8:	676e6950 	.word	0x676e6950
     9ec:	6f64203a 	.word	0x6f64203a
     9f0:	202e656e 	.word	0x202e656e
     9f4:	746e6553 	.word	0x746e6553
     9f8:	20642520 	.word	0x20642520
     9fc:	75716572 	.word	0x75716572
     a00:	73747365 	.word	0x73747365
     a04:	6572202c 	.word	0x6572202c
     a08:	76696563 	.word	0x76696563
     a0c:	25206465 	.word	0x25206465
     a10:	65722064 	.word	0x65722064
     a14:	65696c70 	.word	0x65696c70
     a18:	0a0d2e73 	.word	0x0a0d2e73
     a1c:	00000000 	.word	0x00000000
     a20:	676e6950 	.word	0x676e6950
     a24:	61735520 	.word	0x61735520
     a28:	203a6567 	.word	0x203a6567
     a2c:	676e6970 	.word	0x676e6970
     a30:	74733c20 	.word	0x74733c20
     a34:	2f3e706f 	.word	0x2f3e706f
     a38:	6d616e3c 	.word	0x6d616e3c
     a3c:	64612f65 	.word	0x64612f65
     a40:	73657264 	.word	0x73657264
     a44:	3c203e73 	.word	0x3c203e73
     a48:	6e692069 	.word	0x6e692069
     a4c:	66726574 	.word	0x66726574
     a50:	3e656361 	.word	0x3e656361
     a54:	206e3c20 	.word	0x206e3c20
     a58:	6e69506e 	.word	0x6e69506e
     a5c:	203e7367 	.word	0x203e7367
     a60:	6d20743c 	.word	0x6d20743c
     a64:	72655073 	.word	0x72655073
     a68:	3e646f69 	.word	0x3e646f69
     a6c:	20733c20 	.word	0x20733c20
     a70:	657a6973 	.word	0x657a6973
     a74:	000a0d3e 	.word	0x000a0d3e
     a78:	706f7473 	.word	0x706f7473
     a7c:	00000000 	.word	0x00000000
     a80:	676e6950 	.word	0x676e6950
     a84:	6f63203a 	.word	0x6f63203a
     a88:	6e616d6d 	.word	0x6e616d6d
     a8c:	6e692064 	.word	0x6e692064
     a90:	6f727020 	.word	0x6f727020
     a94:	73657267 	.word	0x73657267
     a98:	52202e73 	.word	0x52202e73
     a9c:	79727465 	.word	0x79727465
     aa0:	74616c20 	.word	0x74616c20
     aa4:	0d2e7265 	.word	0x0d2e7265
     aa8:	0000000a 	.word	0x0000000a
     aac:	676e6950 	.word	0x676e6950
     ab0:	6f48203a 	.word	0x6f48203a
     ab4:	6e207473 	.word	0x6e207473
     ab8:	20656d61 	.word	0x20656d61
     abc:	206f6f74 	.word	0x206f6f74
     ac0:	676e6f6c 	.word	0x676e6f6c
     ac4:	6552202e 	.word	0x6552202e
     ac8:	2e797274 	.word	0x2e797274
     acc:	00000a0d 	.word	0x00000a0d
     ad0:	00000069 	.word	0x00000069
     ad4:	0000006e 	.word	0x0000006e
     ad8:	00000074 	.word	0x00000074
     adc:	00000073 	.word	0x00000073
     ae0:	676e6950 	.word	0x676e6950
     ae4:	6144203a 	.word	0x6144203a
     ae8:	73206174 	.word	0x73206174
     aec:	20657a69 	.word	0x20657a69
     af0:	206f6f74 	.word	0x206f6f74
     af4:	2e676962 	.word	0x2e676962
     af8:	78614d20 	.word	0x78614d20
     afc:	6425203a 	.word	0x6425203a
     b00:	6552202e 	.word	0x6552202e
     b04:	0d797274 	.word	0x0d797274
     b08:	0000000a 	.word	0x0000000a
     b0c:	676e6950 	.word	0x676e6950
     b10:	6e55203a 	.word	0x6e55203a
     b14:	776f6e6b 	.word	0x776f6e6b
     b18:	6170206e 	.word	0x6170206e
     b1c:	656d6172 	.word	0x656d6172
     b20:	0d726574 	.word	0x0d726574
     b24:	0000000a 	.word	0x0000000a
     b28:	676e6950 	.word	0x676e6950
     b2c:	6572203a 	.word	0x6572203a
     b30:	766c6f73 	.word	0x766c6f73
     b34:	20676e69 	.word	0x20676e69
     b38:	74736f68 	.word	0x74736f68
     b3c:	7325203a 	.word	0x7325203a
     b40:	00000a0d 	.word	0x00000a0d
     b44:	6e6b6e55 	.word	0x6e6b6e55
     b48:	206e776f 	.word	0x206e776f
     b4c:	70616568 	.word	0x70616568
     b50:	70797420 	.word	0x70797420
     b54:	55202e65 	.word	0x55202e65
     b58:	203a6573 	.word	0x203a6573
     b5c:	202c315b 	.word	0x202c315b
     b60:	0d5d6425 	.word	0x0d5d6425
     b64:	0000000a 	.word	0x0000000a
     b68:	68206f4e 	.word	0x68206f4e
     b6c:	20706165 	.word	0x20706165
     b70:	6f666e69 	.word	0x6f666e69
     b74:	69786520 	.word	0x69786520
     b78:	20737473 	.word	0x20737473
     b7c:	20726f66 	.word	0x20726f66
     b80:	65707974 	.word	0x65707974
     b84:	7325203a 	.word	0x7325203a
     b88:	000a0d21 	.word	0x000a0d21
     b8c:	70616548 	.word	0x70616548
     b90:	70797420 	.word	0x70797420
     b94:	25203a65 	.word	0x25203a65
     b98:	49202e73 	.word	0x49202e73
     b9c:	6974696e 	.word	0x6974696e
     ba0:	63206c61 	.word	0x63206c61
     ba4:	74616572 	.word	0x74616572
     ba8:	68206465 	.word	0x68206465
     bac:	20706165 	.word	0x20706165
     bb0:	657a6973 	.word	0x657a6973
     bb4:	6425203a 	.word	0x6425203a
     bb8:	74794220 	.word	0x74794220
     bbc:	0a0d7365 	.word	0x0a0d7365
     bc0:	00000000 	.word	0x00000000
     bc4:	6f6c6c41 	.word	0x6f6c6c41
     bc8:	6c626163 	.word	0x6c626163
     bcc:	6c622065 	.word	0x6c622065
     bd0:	206b636f 	.word	0x206b636f
     bd4:	70616568 	.word	0x70616568
     bd8:	7a697320 	.word	0x7a697320
     bdc:	25203a65 	.word	0x25203a65
     be0:	79422064 	.word	0x79422064
     be4:	0d736574 	.word	0x0d736574
     be8:	0000000a 	.word	0x0000000a
     bec:	206c6c41 	.word	0x206c6c41
     bf0:	69617661 	.word	0x69617661
     bf4:	6c62616c 	.word	0x6c62616c
     bf8:	65682065 	.word	0x65682065
     bfc:	73207061 	.word	0x73207061
     c00:	3a657a69 	.word	0x3a657a69
     c04:	20642520 	.word	0x20642520
     c08:	65747942 	.word	0x65747942
     c0c:	68202c73 	.word	0x68202c73
     c10:	20686769 	.word	0x20686769
     c14:	65746177 	.word	0x65746177
     c18:	72616d72 	.word	0x72616d72
     c1c:	25203a6b 	.word	0x25203a6b
     c20:	000a0d64 	.word	0x000a0d64
     c24:	7473614c 	.word	0x7473614c
     c28:	61656820 	.word	0x61656820
     c2c:	72652070 	.word	0x72652070
     c30:	3a726f72 	.word	0x3a726f72
     c34:	25783020 	.word	0x25783020
     c38:	000a0d78 	.word	0x000a0d78
     c3c:	54206f4e 	.word	0x54206f4e
     c40:	65636172 	.word	0x65636172
     c44:	666e6920 	.word	0x666e6920
     c48:	7865206f 	.word	0x7865206f
     c4c:	73747369 	.word	0x73747369
     c50:	000a0d2e 	.word	0x000a0d2e
     c54:	63617453 	.word	0x63617453
     c58:	7075206b 	.word	0x7075206b
     c5c:	69616620 	.word	0x69616620
     c60:	0d64656c 	.word	0x0d64656c
     c64:	0000000a 	.word	0x0000000a
     c68:	63617453 	.word	0x63617453
     c6c:	7075206b 	.word	0x7075206b
     c70:	63757320 	.word	0x63757320
     c74:	64656563 	.word	0x64656563
     c78:	0a0d6465 	.word	0x0a0d6465
     c7c:	00000000 	.word	0x00000000
     c80:	67617355 	.word	0x67617355
     c84:	73203a65 	.word	0x73203a65
     c88:	6b636174 	.word	0x6b636174
     c8c:	70753c20 	.word	0x70753c20
     c90:	776f642f 	.word	0x776f642f
     c94:	3c203e6e 	.word	0x3c203e6e
     c98:	73657270 	.word	0x73657270
     c9c:	65767265 	.word	0x65767265
     ca0:	000a0d3e 	.word	0x000a0d3e
     ca4:	203a7845 	.word	0x203a7845
     ca8:	63617473 	.word	0x63617473
     cac:	6f64206b 	.word	0x6f64206b
     cb0:	70206e77 	.word	0x70206e77
     cb4:	65736572 	.word	0x65736572
     cb8:	0d657672 	.word	0x0d657672
     cbc:	0000000a 	.word	0x0000000a
     cc0:	00007075 	.word	0x00007075
     cc4:	63617453 	.word	0x63617453
     cc8:	6c61206b 	.word	0x6c61206b
     ccc:	64616572 	.word	0x64616572
     cd0:	70752079 	.word	0x70752079
     cd4:	000a0d21 	.word	0x000a0d21
     cd8:	6e727554 	.word	0x6e727554
     cdc:	61745320 	.word	0x61745320
     ce0:	64206b63 	.word	0x64206b63
     ce4:	206e776f 	.word	0x206e776f
     ce8:	20646e61 	.word	0x20646e61
     cec:	6e656874 	.word	0x6e656874
     cf0:	21707520 	.word	0x21707520
     cf4:	00000a0d 	.word	0x00000a0d
     cf8:	74736552 	.word	0x74736552
     cfc:	69747261 	.word	0x69747261
     d00:	7420676e 	.word	0x7420676e
     d04:	73206568 	.word	0x73206568
     d08:	6b636174 	.word	0x6b636174
     d0c:	74697720 	.word	0x74697720
     d10:	64252068 	.word	0x64252068
     d14:	746e6920 	.word	0x746e6920
     d18:	61667265 	.word	0x61667265
     d1c:	73286563 	.word	0x73286563
     d20:	000a0d29 	.word	0x000a0d29
     d24:	6e776f64 	.word	0x6e776f64
     d28:	00000000 	.word	0x00000000
     d2c:	63617453 	.word	0x63617453
     d30:	6f64206b 	.word	0x6f64206b
     d34:	203a6e77 	.word	0x203a6e77
     d38:	6e6e6163 	.word	0x6e6e6163
     d3c:	6720746f 	.word	0x6720746f
     d40:	61207465 	.word	0x61207465
     d44:	61747320 	.word	0x61747320
     d48:	68206b63 	.word	0x68206b63
     d4c:	6c646e61 	.word	0x6c646e61
     d50:	000a0d65 	.word	0x000a0d65
     d54:	63617453 	.word	0x63617453
     d58:	6f64206b 	.word	0x6f64206b
     d5c:	73206e77 	.word	0x73206e77
     d60:	65636375 	.word	0x65636375
     d64:	64656465 	.word	0x64656465
     d68:	00000a0d 	.word	0x00000a0d
     d6c:	67617355 	.word	0x67617355
     d70:	69203a65 	.word	0x69203a65
     d74:	693c2066 	.word	0x693c2066
     d78:	7265746e 	.word	0x7265746e
     d7c:	65636166 	.word	0x65636166
     d80:	643c203e 	.word	0x643c203e
     d84:	2f6e776f 	.word	0x2f6e776f
     d88:	203e7075 	.word	0x203e7075
     d8c:	00000a0d 	.word	0x00000a0d
     d90:	203a7845 	.word	0x203a7845
     d94:	50206669 	.word	0x50206669
     d98:	32334349 	.word	0x32334349
     d9c:	20544e49 	.word	0x20544e49
     da0:	6e776f64 	.word	0x6e776f64
     da4:	000a0d20 	.word	0x000a0d20
     da8:	6e6b6e55 	.word	0x6e6b6e55
     dac:	206e776f 	.word	0x206e776f
     db0:	65746e69 	.word	0x65746e69
     db4:	63616672 	.word	0x63616672
     db8:	70732065 	.word	0x70732065
     dbc:	66696365 	.word	0x66696365
     dc0:	20646569 	.word	0x20646569
     dc4:	00000a0d 	.word	0x00000a0d
     dc8:	73696854 	.word	0x73696854
     dcc:	746e6920 	.word	0x746e6920
     dd0:	61667265 	.word	0x61667265
     dd4:	61206563 	.word	0x61206563
     dd8:	6165726c 	.word	0x6165726c
     ddc:	75207964 	.word	0x75207964
     de0:	000a0d70 	.word	0x000a0d70
     de4:	7265704f 	.word	0x7265704f
     de8:	6f697461 	.word	0x6f697461
     dec:	6166206e 	.word	0x6166206e
     df0:	64656c69 	.word	0x64656c69
     df4:	6f4e202e 	.word	0x6f4e202e
     df8:	6e6f6320 	.word	0x6e6f6320
     dfc:	75676966 	.word	0x75676966
     e00:	69746172 	.word	0x69746172
     e04:	0a0d6e6f 	.word	0x0a0d6e6f
     e08:	00000000 	.word	0x00000000
     e0c:	6c6c7566 	.word	0x6c6c7566
     e10:	00000000 	.word	0x00000000
     e14:	73696854 	.word	0x73696854
     e18:	746e6920 	.word	0x746e6920
     e1c:	61667265 	.word	0x61667265
     e20:	61206563 	.word	0x61206563
     e24:	6165726c 	.word	0x6165726c
     e28:	64207964 	.word	0x64207964
     e2c:	0d6e776f 	.word	0x0d6e776f
     e30:	0000000a 	.word	0x0000000a
     e34:	6e6f7257 	.word	0x6e6f7257
     e38:	61702067 	.word	0x61702067
     e3c:	656d6172 	.word	0x656d6172
     e40:	20726574 	.word	0x20726574
     e44:	63657073 	.word	0x63657073
     e48:	65696669 	.word	0x65696669
     e4c:	0a0d2064 	.word	0x0a0d2064
     e50:	00000000 	.word	0x00000000
     e54:	7265704f 	.word	0x7265704f
     e58:	6f697461 	.word	0x6f697461
     e5c:	7573206e 	.word	0x7573206e
     e60:	73656363 	.word	0x73656363
     e64:	6c756673 	.word	0x6c756673
     e68:	000a0d21 	.word	0x000a0d21
     e6c:	7265704f 	.word	0x7265704f
     e70:	6f697461 	.word	0x6f697461
     e74:	6166206e 	.word	0x6166206e
     e78:	64656c69 	.word	0x64656c69
     e7c:	000a0d21 	.word	0x000a0d21
     e80:	67617355 	.word	0x67617355
     e84:	73203a65 	.word	0x73203a65
     e88:	616d7465 	.word	0x616d7465
     e8c:	693c2063 	.word	0x693c2063
     e90:	7265746e 	.word	0x7265746e
     e94:	65636166 	.word	0x65636166
     e98:	783c203e 	.word	0x783c203e
     e9c:	783a783a 	.word	0x783a783a
     ea0:	783a783a 	.word	0x783a783a
     ea4:	203e783a 	.word	0x203e783a
     ea8:	00000a0d 	.word	0x00000a0d
     eac:	203a7845 	.word	0x203a7845
     eb0:	6d746573 	.word	0x6d746573
     eb4:	50206361 	.word	0x50206361
     eb8:	32334349 	.word	0x32334349
     ebc:	20544e49 	.word	0x20544e49
     ec0:	623a6161 	.word	0x623a6161
     ec4:	63633a62 	.word	0x63633a62
     ec8:	3a64643a 	.word	0x3a64643a
     ecc:	663a6565 	.word	0x663a6565
     ed0:	0a0d2066 	.word	0x0a0d2066
     ed4:	00000000 	.word	0x00000000
     ed8:	76677261 	.word	0x76677261
     edc:	3a5d325b 	.word	0x3a5d325b
     ee0:	0d732520 	.word	0x0d732520
     ee4:	0000000a 	.word	0x0000000a
     ee8:	61766e49 	.word	0x61766e49
     eec:	2064696c 	.word	0x2064696c
     ef0:	2043414d 	.word	0x2043414d
     ef4:	72646461 	.word	0x72646461
     ef8:	20737365 	.word	0x20737365
     efc:	69727473 	.word	0x69727473
     f00:	0d20676e 	.word	0x0d20676e
     f04:	0000000a 	.word	0x0000000a
     f08:	20746553 	.word	0x20746553
     f0c:	2043414d 	.word	0x2043414d
     f10:	72646461 	.word	0x72646461
     f14:	20737365 	.word	0x20737365
     f18:	6c696166 	.word	0x6c696166
     f1c:	0a0d6465 	.word	0x0a0d6465
     f20:	00000000 	.word	0x00000000
     f24:	20746553 	.word	0x20746553
     f28:	534f4942 	.word	0x534f4942
     f2c:	6d614e20 	.word	0x6d614e20
     f30:	4b4f2065 	.word	0x4b4f2065
     f34:	00000a0d 	.word	0x00000a0d
     f38:	20746553 	.word	0x20746553
     f3c:	534f4942 	.word	0x534f4942
     f40:	6d614e20 	.word	0x6d614e20
     f44:	61662065 	.word	0x61662065
     f48:	64656c69 	.word	0x64656c69
     f4c:	00000a0d 	.word	0x00000a0d
     f50:	67617355 	.word	0x67617355
     f54:	73203a65 	.word	0x73203a65
     f58:	69627465 	.word	0x69627465
     f5c:	3c20736f 	.word	0x3c20736f
     f60:	65746e69 	.word	0x65746e69
     f64:	63616672 	.word	0x63616672
     f68:	3c203e65 	.word	0x3c203e65
     f6c:	2e782e78 	.word	0x2e782e78
     f70:	3e782e78 	.word	0x3e782e78
     f74:	000a0d20 	.word	0x000a0d20
     f78:	203a7845 	.word	0x203a7845
     f7c:	62746573 	.word	0x62746573
     f80:	20736f69 	.word	0x20736f69
     f84:	33434950 	.word	0x33434950
     f88:	544e4932 	.word	0x544e4932
     f8c:	48434d20 	.word	0x48434d20
     f90:	414f4250 	.word	0x414f4250
     f94:	325f4452 	.word	0x325f4452
     f98:	0a0d2039 	.word	0x0a0d2039
     f9c:	00000000 	.word	0x00000000
     fa0:	20746553 	.word	0x20746553
     fa4:	65746167 	.word	0x65746167
     fa8:	20796177 	.word	0x20796177
     fac:	72646461 	.word	0x72646461
     fb0:	20737365 	.word	0x20737365
     fb4:	0a0d4b4f 	.word	0x0a0d4b4f
     fb8:	00000000 	.word	0x00000000
     fbc:	20746553 	.word	0x20746553
     fc0:	65746167 	.word	0x65746167
     fc4:	20796177 	.word	0x20796177
     fc8:	72646461 	.word	0x72646461
     fcc:	20737365 	.word	0x20737365
     fd0:	6c696166 	.word	0x6c696166
     fd4:	0a0d6465 	.word	0x0a0d6465
     fd8:	00000000 	.word	0x00000000
     fdc:	67617355 	.word	0x67617355
     fe0:	73203a65 	.word	0x73203a65
     fe4:	77677465 	.word	0x77677465
     fe8:	6e693c20 	.word	0x6e693c20
     fec:	66726574 	.word	0x66726574
     ff0:	3e656361 	.word	0x3e656361
     ff4:	70693c20 	.word	0x70693c20
     ff8:	362f3476 	.word	0x362f3476
     ffc:	64646120 	.word	0x64646120
    1000:	73736572 	.word	0x73736572
    1004:	763c203e 	.word	0x763c203e
    1008:	64696c61 	.word	0x64696c61
    100c:	656d6954 	.word	0x656d6954
    1010:	0a0d203e 	.word	0x0a0d203e
    1014:	00000000 	.word	0x00000000
    1018:	203a7845 	.word	0x203a7845
    101c:	67746573 	.word	0x67746573
    1020:	49502077 	.word	0x49502077
    1024:	49323343 	.word	0x49323343
    1028:	3120544e 	.word	0x3120544e
    102c:	312e3239 	.word	0x312e3239
    1030:	302e3836 	.word	0x302e3836
    1034:	0d20312e 	.word	0x0d20312e
    1038:	0000000a 	.word	0x0000000a
    103c:	61766e49 	.word	0x61766e49
    1040:	2064696c 	.word	0x2064696c
    1044:	61205049 	.word	0x61205049
    1048:	65726464 	.word	0x65726464
    104c:	73207373 	.word	0x73207373
    1050:	6e697274 	.word	0x6e697274
    1054:	0a0d2067 	.word	0x0a0d2067
    1058:	00000000 	.word	0x00000000
    105c:	20746553 	.word	0x20746553
    1060:	61207069 	.word	0x61207069
    1064:	65726464 	.word	0x65726464
    1068:	4f207373 	.word	0x4f207373
    106c:	000a0d4b 	.word	0x000a0d4b
    1070:	20746553 	.word	0x20746553
    1074:	61207069 	.word	0x61207069
    1078:	65726464 	.word	0x65726464
    107c:	66207373 	.word	0x66207373
    1080:	656c6961 	.word	0x656c6961
    1084:	000a0d64 	.word	0x000a0d64
    1088:	67617355 	.word	0x67617355
    108c:	73203a65 	.word	0x73203a65
    1090:	70697465 	.word	0x70697465
    1094:	6e693c20 	.word	0x6e693c20
    1098:	66726574 	.word	0x66726574
    109c:	3e656361 	.word	0x3e656361
    10a0:	70693c20 	.word	0x70693c20
    10a4:	362f3476 	.word	0x362f3476
    10a8:	64646120 	.word	0x64646120
    10ac:	73736572 	.word	0x73736572
    10b0:	693c203e 	.word	0x693c203e
    10b4:	6d347670 	.word	0x6d347670
    10b8:	2f6b7361 	.word	0x2f6b7361
    10bc:	36767069 	.word	0x36767069
    10c0:	65727020 	.word	0x65727020
    10c4:	20786966 	.word	0x20786966
    10c8:	3e6e656c 	.word	0x3e6e656c
    10cc:	00000a0d 	.word	0x00000a0d
    10d0:	203a7845 	.word	0x203a7845
    10d4:	69746573 	.word	0x69746573
    10d8:	49502070 	.word	0x49502070
    10dc:	49323343 	.word	0x49323343
    10e0:	3120544e 	.word	0x3120544e
    10e4:	312e3239 	.word	0x312e3239
    10e8:	302e3836 	.word	0x302e3836
    10ec:	3220382e 	.word	0x3220382e
    10f0:	322e3535 	.word	0x322e3535
    10f4:	322e3535 	.word	0x322e3535
    10f8:	302e3535 	.word	0x302e3535
    10fc:	000a0d20 	.word	0x000a0d20
    1100:	73206f4e 	.word	0x73206f4e
    1104:	20686375 	.word	0x20686375
    1108:	65746e69 	.word	0x65746e69
    110c:	63616672 	.word	0x63616672
    1110:	73692065 	.word	0x73692065
    1114:	0d707520 	.word	0x0d707520
    1118:	0000000a 	.word	0x0000000a
    111c:	61206e41 	.word	0x61206e41
    1120:	65726464 	.word	0x65726464
    1124:	73207373 	.word	0x73207373
    1128:	69767265 	.word	0x69767265
    112c:	69206563 	.word	0x69206563
    1130:	6c612073 	.word	0x6c612073
    1134:	64616572 	.word	0x64616572
    1138:	75722079 	.word	0x75722079
    113c:	6e696e6e 	.word	0x6e696e6e
    1140:	53202e67 	.word	0x53202e67
    1144:	20706f74 	.word	0x20706f74
    1148:	50434844 	.word	0x50434844
    114c:	435a202c 	.word	0x435a202c
    1150:	202c4c4c 	.word	0x202c4c4c
    1154:	2e637465 	.word	0x2e637465
    1158:	72696620 	.word	0x72696620
    115c:	0a0d7473 	.word	0x0a0d7473
    1160:	00000000 	.word	0x00000000
    1164:	61766e49 	.word	0x61766e49
    1168:	2064696c 	.word	0x2064696c
    116c:	6d205049 	.word	0x6d205049
    1170:	206b7361 	.word	0x206b7361
    1174:	69727473 	.word	0x69727473
    1178:	0d20676e 	.word	0x0d20676e
    117c:	0000000a 	.word	0x0000000a
    1180:	63637573 	.word	0x63637573
    1184:	00737365 	.word	0x00737365
    1188:	6c696166 	.word	0x6c696166
    118c:	00006465 	.word	0x00006465
    1190:	67617355 	.word	0x67617355
    1194:	73203a65 	.word	0x73203a65
    1198:	6e647465 	.word	0x6e647465
    119c:	2f312073 	.word	0x2f312073
    11a0:	693c2032 	.word	0x693c2032
    11a4:	7265746e 	.word	0x7265746e
    11a8:	65636166 	.word	0x65636166
    11ac:	783c203e 	.word	0x783c203e
    11b0:	782e782e 	.word	0x782e782e
    11b4:	203e782e 	.word	0x203e782e
    11b8:	00000a0d 	.word	0x00000a0d
    11bc:	203a7845 	.word	0x203a7845
    11c0:	64746573 	.word	0x64746573
    11c4:	3120736e 	.word	0x3120736e
    11c8:	68746520 	.word	0x68746520
    11cc:	35322030 	.word	0x35322030
    11d0:	35322e35 	.word	0x35322e35
    11d4:	35322e35 	.word	0x35322e35
    11d8:	20302e35 	.word	0x20302e35
    11dc:	00000a0d 	.word	0x00000a0d
    11e0:	6e6b6e55 	.word	0x6e6b6e55
    11e4:	206e776f 	.word	0x206e776f
    11e8:	20534e44 	.word	0x20534e44
    11ec:	65646e69 	.word	0x65646e69
    11f0:	000a0d78 	.word	0x000a0d78
    11f4:	20746553 	.word	0x20746553
    11f8:	20534e44 	.word	0x20534e44
    11fc:	61206425 	.word	0x61206425
    1200:	65726464 	.word	0x65726464
    1204:	25207373 	.word	0x25207373
    1208:	000a0d73 	.word	0x000a0d73
    120c:	20746f6e 	.word	0x20746f6e
    1210:	65766967 	.word	0x65766967
    1214:	0000006e 	.word	0x0000006e
    1218:	656e6f4e 	.word	0x656e6f4e
    121c:	00000000 	.word	0x00000000
    1220:	6c696166 	.word	0x6c696166
    1224:	00000000 	.word	0x00000000
    1228:	67617355 	.word	0x67617355
    122c:	25203a65 	.word	0x25203a65
    1230:	693c2073 	.word	0x693c2073
    1234:	7265746e 	.word	0x7265746e
    1238:	65636166 	.word	0x65636166
    123c:	6f3c203e 	.word	0x6f3c203e
    1240:	666f2f6e 	.word	0x666f2f6e
    1244:	65722f66 	.word	0x65722f66
    1248:	2f77656e 	.word	0x2f77656e
    124c:	75716572 	.word	0x75716572
    1250:	2f747365 	.word	0x2f747365
    1254:	6f666e69 	.word	0x6f666e69
    1258:	0a0d203e 	.word	0x0a0d203e
    125c:	00000000 	.word	0x00000000
    1260:	656e6572 	.word	0x656e6572
    1264:	00000077 	.word	0x00000077
    1268:	75716572 	.word	0x75716572
    126c:	00747365 	.word	0x00747365
    1270:	75716552 	.word	0x75716552
    1274:	20747365 	.word	0x20747365
    1278:	6465656e 	.word	0x6465656e
    127c:	6e612073 	.word	0x6e612073
    1280:	20504920 	.word	0x20504920
    1284:	72646461 	.word	0x72646461
    1288:	0d737365 	.word	0x0d737365
    128c:	0000000a 	.word	0x0000000a
    1290:	6f666e69 	.word	0x6f666e69
    1294:	00000000 	.word	0x00000000
    1298:	50434844 	.word	0x50434844
    129c:	61747320 	.word	0x61747320
    12a0:	3a737574 	.word	0x3a737574
    12a4:	20642520 	.word	0x20642520
    12a8:	64252028 	.word	0x64252028
    12ac:	203d3d20 	.word	0x203d3d20
    12b0:	6e756f42 	.word	0x6e756f42
    12b4:	202c2964 	.word	0x202c2964
    12b8:	656d6974 	.word	0x656d6974
    12bc:	6425203a 	.word	0x6425203a
    12c0:	00000a0d 	.word	0x00000a0d
    12c4:	50434844 	.word	0x50434844
    12c8:	61656c20 	.word	0x61656c20
    12cc:	73206573 	.word	0x73206573
    12d0:	74726174 	.word	0x74726174
    12d4:	6425203a 	.word	0x6425203a
    12d8:	7564202c 	.word	0x7564202c
    12dc:	69746172 	.word	0x69746172
    12e0:	203a6e6f 	.word	0x203a6e6f
    12e4:	0d736425 	.word	0x0d736425
    12e8:	0000000a 	.word	0x0000000a
    12ec:	50434844 	.word	0x50434844
    12f0:	6e657220 	.word	0x6e657220
    12f4:	74207765 	.word	0x74207765
    12f8:	3a656d69 	.word	0x3a656d69
    12fc:	2c642520 	.word	0x2c642520
    1300:	62657220 	.word	0x62657220
    1304:	20646e69 	.word	0x20646e69
    1308:	656d6974 	.word	0x656d6974
    130c:	6425203a 	.word	0x6425203a
    1310:	00000a0d 	.word	0x00000a0d
    1314:	50434844 	.word	0x50434844
    1318:	64646120 	.word	0x64646120
    131c:	73736572 	.word	0x73736572
    1320:	7325203a 	.word	0x7325203a
    1324:	00000a0d 	.word	0x00000a0d
    1328:	50434844 	.word	0x50434844
    132c:	72657320 	.word	0x72657320
    1330:	3a726576 	.word	0x3a726576
    1334:	0d732520 	.word	0x0d732520
    1338:	0000000a 	.word	0x0000000a
    133c:	50434844 	.word	0x50434844
    1340:	6f6f6220 	.word	0x6f6f6220
    1344:	616e2074 	.word	0x616e2074
    1348:	203a656d 	.word	0x203a656d
    134c:	0a0d7325 	.word	0x0a0d7325
    1350:	00000000 	.word	0x00000000
    1354:	50434844 	.word	0x50434844
    1358:	6d695420 	.word	0x6d695420
    135c:	65732065 	.word	0x65732065
    1360:	72657672 	.word	0x72657672
    1364:	25203a73 	.word	0x25203a73
    1368:	25202c64 	.word	0x25202c64
    136c:	000a0d73 	.word	0x000a0d73
    1370:	50434844 	.word	0x50434844
    1374:	50544e20 	.word	0x50544e20
    1378:	72657320 	.word	0x72657320
    137c:	73726576 	.word	0x73726576
    1380:	6425203a 	.word	0x6425203a
    1384:	7325202c 	.word	0x7325202c
    1388:	00000a0d 	.word	0x00000a0d
    138c:	50434844 	.word	0x50434844
    1390:	6166203a 	.word	0x6166203a
    1394:	64656c69 	.word	0x64656c69
    1398:	206f7420 	.word	0x206f7420
    139c:	20746567 	.word	0x20746567
    13a0:	6f666e69 	.word	0x6f666e69
    13a4:	00000a0d 	.word	0x00000a0d
    13a8:	25207325 	.word	0x25207325
    13ac:	73252073 	.word	0x73252073
    13b0:	00000a0d 	.word	0x00000a0d
    13b4:	63637573 	.word	0x63637573
    13b8:	66737365 	.word	0x66737365
    13bc:	00006c75 	.word	0x00006c75
    13c0:	6c696166 	.word	0x6c696166
    13c4:	00216465 	.word	0x00216465
    13c8:	00746573 	.word	0x00746573
    13cc:	00746567 	.word	0x00746567
    13d0:	61666544 	.word	0x61666544
    13d4:	20746c75 	.word	0x20746c75
    13d8:	65746e69 	.word	0x65746e69
    13dc:	63616672 	.word	0x63616672
    13e0:	65732065 	.word	0x65732065
    13e4:	73252074 	.word	0x73252074
    13e8:	00000a0d 	.word	0x00000a0d
    13ec:	61666544 	.word	0x61666544
    13f0:	20746c75 	.word	0x20746c75
    13f4:	65746e69 	.word	0x65746e69
    13f8:	63616672 	.word	0x63616672
    13fc:	73692065 	.word	0x73692065
    1400:	7325203a 	.word	0x7325203a
    1404:	00000a0d 	.word	0x00000a0d
    1408:	67617355 	.word	0x67617355
    140c:	64203a65 	.word	0x64203a65
    1410:	656e6665 	.word	0x656e6665
    1414:	65732074 	.word	0x65732074
    1418:	65672f74 	.word	0x65672f74
    141c:	693c2074 	.word	0x693c2074
    1420:	7265746e 	.word	0x7265746e
    1424:	65636166 	.word	0x65636166
    1428:	000a0d3e 	.word	0x000a0d3e
    142c:	203a7845 	.word	0x203a7845
    1430:	6e666564 	.word	0x6e666564
    1434:	73207465 	.word	0x73207465
    1438:	65207465 	.word	0x65207465
    143c:	0d306874 	.word	0x0d306874
    1440:	0000000a 	.word	0x0000000a
    1444:	00005055 	.word	0x00005055
    1448:	4e574f44 	.word	0x4e574f44
    144c:	00000000 	.word	0x00000000
    1450:	64616552 	.word	0x64616552
    1454:	00000079 	.word	0x00000079
    1458:	20746f4e 	.word	0x20746f4e
    145c:	64616552 	.word	0x64616552
    1460:	00000079 	.word	0x00000079
    1464:	67617355 	.word	0x67617355
    1468:	6e203a65 	.word	0x6e203a65
    146c:	6e697465 	.word	0x6e697465
    1470:	0a0d6f66 	.word	0x0a0d6f66
    1474:	00000000 	.word	0x00000000
    1478:	203a7845 	.word	0x203a7845
    147c:	6974656e 	.word	0x6974656e
    1480:	0d6f666e 	.word	0x0d6f666e
    1484:	0000000a 	.word	0x0000000a
    1488:	2d2d2d2d 	.word	0x2d2d2d2d
    148c:	2d2d2d2d 	.word	0x2d2d2d2d
    1490:	49202d2d 	.word	0x49202d2d
    1494:	7265746e 	.word	0x7265746e
    1498:	65636166 	.word	0x65636166
    149c:	73253c20 	.word	0x73253c20
    14a0:	3e73252f 	.word	0x3e73252f
    14a4:	2d2d2d20 	.word	0x2d2d2d20
    14a8:	2d2d2d2d 	.word	0x2d2d2d2d
    14ac:	202d2d2d 	.word	0x202d2d2d
    14b0:	00000a0d 	.word	0x00000a0d
    14b4:	65746e49 	.word	0x65746e49
    14b8:	63616672 	.word	0x63616672
    14bc:	73692065 	.word	0x73692065
    14c0:	776f6420 	.word	0x776f6420
    14c4:	000a0d6e 	.word	0x000a0d6e
    14c8:	74736f48 	.word	0x74736f48
    14cc:	6d614e20 	.word	0x6d614e20
    14d0:	25203a65 	.word	0x25203a65
    14d4:	202d2073 	.word	0x202d2073
    14d8:	534e424e 	.word	0x534e424e
    14dc:	73696420 	.word	0x73696420
    14e0:	656c6261 	.word	0x656c6261
    14e4:	0a0d2064 	.word	0x0a0d2064
    14e8:	00000000 	.word	0x00000000
    14ec:	34765049 	.word	0x34765049
    14f0:	64644120 	.word	0x64644120
    14f4:	73736572 	.word	0x73736572
    14f8:	7325203a 	.word	0x7325203a
    14fc:	00000a0d 	.word	0x00000a0d
    1500:	6b73614d 	.word	0x6b73614d
    1504:	7325203a 	.word	0x7325203a
    1508:	00000a0d 	.word	0x00000a0d
    150c:	65746147 	.word	0x65746147
    1510:	3a796177 	.word	0x3a796177
    1514:	0d732520 	.word	0x0d732520
    1518:	0000000a 	.word	0x0000000a
    151c:	31534e44 	.word	0x31534e44
    1520:	7325203a 	.word	0x7325203a
    1524:	00000a0d 	.word	0x00000a0d
    1528:	32534e44 	.word	0x32534e44
    152c:	7325203a 	.word	0x7325203a
    1530:	00000a0d 	.word	0x00000a0d
    1534:	2043414d 	.word	0x2043414d
    1538:	72646441 	.word	0x72646441
    153c:	3a737365 	.word	0x3a737365
    1540:	0d732520 	.word	0x0d732520
    1544:	0000000a 	.word	0x0000000a
    1548:	70636864 	.word	0x70636864
    154c:	20736920 	.word	0x20736920
    1550:	0a0d7325 	.word	0x0a0d7325
    1554:	00000000 	.word	0x00000000
    1558:	6b6e694c 	.word	0x6b6e694c
    155c:	20736920 	.word	0x20736920
    1560:	0a0d7325 	.word	0x0a0d7325
    1564:	00000000 	.word	0x00000000
    1568:	74617453 	.word	0x74617453
    156c:	203a7375 	.word	0x203a7375
    1570:	0a0d7325 	.word	0x0a0d7325
    1574:	00000000 	.word	0x00000000
    1578:	61666564 	.word	0x61666564
    157c:	20746c75 	.word	0x20746c75
    1580:	61205049 	.word	0x61205049
    1584:	65726464 	.word	0x65726464
    1588:	00007373 	.word	0x00007373
    158c:	69207325 	.word	0x69207325
    1590:	4e4f2073 	.word	0x4e4f2073
    1594:	00000a0d 	.word	0x00000a0d
    1598:	70636864 	.word	0x70636864
    159c:	00000000 	.word	0x00000000
    15a0:	676e6950 	.word	0x676e6950
    15a4:	7277203a 	.word	0x7277203a
    15a8:	20676e6f 	.word	0x20676e6f
    15ac:	6c706572 	.word	0x6c706572
    15b0:	65722079 	.word	0x65722079
    15b4:	76696563 	.word	0x76696563
    15b8:	202e6465 	.word	0x202e6465
    15bc:	6b73614d 	.word	0x6b73614d
    15c0:	7830203a 	.word	0x7830203a
    15c4:	0d783225 	.word	0x0d783225
    15c8:	0000000a 	.word	0x0000000a
    15cc:	676e6950 	.word	0x676e6950
    15d0:	6572203a 	.word	0x6572203a
    15d4:	5b796c70 	.word	0x5b796c70
    15d8:	205d6425 	.word	0x205d6425
    15dc:	6d6f7266 	.word	0x6d6f7266
    15e0:	3a732520 	.word	0x3a732520
    15e4:	6d697420 	.word	0x6d697420
    15e8:	203d2065 	.word	0x203d2065
    15ec:	736d6425 	.word	0x736d6425
    15f0:	00000a0d 	.word	0x00000a0d
    15f4:	676e6950 	.word	0x676e6950
    15f8:	4e44203a 	.word	0x4e44203a
    15fc:	61662053 	.word	0x61662053
    1600:	72756c69 	.word	0x72756c69
    1604:	6f662065 	.word	0x6f662065
    1608:	73252072 	.word	0x73252072
    160c:	00000a0d 	.word	0x00000a0d
    1610:	20534e44 	.word	0x20534e44
    1614:	6b6f6f4c 	.word	0x6b6f6f4c
    1618:	203a7075 	.word	0x203a7075
    161c:	20534e44 	.word	0x20534e44
    1620:	6c696166 	.word	0x6c696166
    1624:	20657275 	.word	0x20657275
    1628:	20726f66 	.word	0x20726f66
    162c:	202c7325 	.word	0x202c7325
    1630:	3a727265 	.word	0x3a727265
    1634:	0d642520 	.word	0x0d642520
    1638:	0000000a 	.word	0x0000000a
    163c:	20534e44 	.word	0x20534e44
    1640:	6b6f6f4c 	.word	0x6b6f6f4c
    1644:	203a7075 	.word	0x203a7075
    1648:	75716572 	.word	0x75716572
    164c:	20747365 	.word	0x20747365
    1650:	656d6974 	.word	0x656d6974
    1654:	2e74756f 	.word	0x2e74756f
    1658:	00000a0d 	.word	0x00000a0d
    165c:	6b6f6f4c 	.word	0x6b6f6f4c
    1660:	41207075 	.word	0x41207075
    1664:	6577736e 	.word	0x6577736e
    1668:	0a0d3a72 	.word	0x0a0d3a72
    166c:	2d2d2d2d 	.word	0x2d2d2d2d
    1670:	2d2d2d2d 	.word	0x2d2d2d2d
    1674:	2d2d2d2d 	.word	0x2d2d2d2d
    1678:	2d2d2d2d 	.word	0x2d2d2d2d
    167c:	2d2d2d2d 	.word	0x2d2d2d2d
    1680:	0a0d2d2d 	.word	0x0a0d2d2d
    1684:	00000000 	.word	0x00000000
    1688:	4c206f4e 	.word	0x4c206f4e
    168c:	756b6f6f 	.word	0x756b6f6f
    1690:	6e652070 	.word	0x6e652070
    1694:	20797274 	.word	0x20797274
    1698:	20726f66 	.word	0x20726f66
    169c:	5d73255b 	.word	0x5d73255b
    16a0:	00000a0d 	.word	0x00000a0d
    16a4:	5d73255b 	.word	0x5d73255b
    16a8:	49204120 	.word	0x49204120
    16ac:	20347650 	.word	0x20347650
    16b0:	72646441 	.word	0x72646441
    16b4:	20737365 	.word	0x20737365
    16b8:	6425203a 	.word	0x6425203a
    16bc:	2e64252e 	.word	0x2e64252e
    16c0:	252e6425 	.word	0x252e6425
    16c4:	000a0d64 	.word	0x000a0d64
    16c8:	5d73255b 	.word	0x5d73255b
    16cc:	41414120 	.word	0x41414120
    16d0:	50492041 	.word	0x50492041
    16d4:	41203676 	.word	0x41203676
    16d8:	65726464 	.word	0x65726464
    16dc:	3a207373 	.word	0x3a207373
    16e0:	0a0d7325 	.word	0x0a0d7325
    16e4:	00000000 	.word	0x00000000
    16e8:	7473203a 	.word	0x7473203a
    16ec:	206b6361 	.word	0x206b6361
    16f0:	6d6d6f63 	.word	0x6d6d6f63
    16f4:	73646e61 	.word	0x73646e61
    16f8:	00000000 	.word	0x00000000
    16fc:	69706374 	.word	0x69706374
    1700:	00000070 	.word	0x00000070
    1704:	6c696146 	.word	0x6c696146
    1708:	74206465 	.word	0x74206465
    170c:	7263206f 	.word	0x7263206f
    1710:	65746165 	.word	0x65746165
    1714:	50435420 	.word	0x50435420
    1718:	43205049 	.word	0x43205049
    171c:	616d6d6f 	.word	0x616d6d6f
    1720:	0d73646e 	.word	0x0d73646e
    1724:	0000000a 	.word	0x0000000a
    1728:	49504354 	.word	0x49504354
    172c:	6f632050 	.word	0x6f632050
    1730:	6e616d6d 	.word	0x6e616d6d
    1734:	74207364 	.word	0x74207364
    1738:	206b7361 	.word	0x206b7361
    173c:	69676572 	.word	0x69676572
    1740:	61727473 	.word	0x61727473
    1744:	6e6f6974 	.word	0x6e6f6974
    1748:	69616620 	.word	0x69616620
    174c:	0d64656c 	.word	0x0d64656c
    1750:	0000000a 	.word	0x0000000a
    1754:	65746e69 	.word	0x65746e69
    1758:	6c616e72 	.word	0x6c616e72
    175c:	00000000 	.word	0x00000000
    1760:	6c6f6f70 	.word	0x6c6f6f70
    1764:	00000000 	.word	0x00000000
    1768:	65747865 	.word	0x65747865
    176c:	6c616e72 	.word	0x6c616e72
    1770:	00000000 	.word	0x00000000
    1774:	006c6564 	.word	0x006c6564
    1778:	6b6f6f6c 	.word	0x6b6f6f6c
    177c:	00007075 	.word	0x00007075
    1780:	6974656e 	.word	0x6974656e
    1784:	006f666e 	.word	0x006f666e
    1788:	6547203a 	.word	0x6547203a
    178c:	656e2074 	.word	0x656e2074
    1790:	726f7774 	.word	0x726f7774
    1794:	6e69206b 	.word	0x6e69206b
    1798:	6d726f66 	.word	0x6d726f66
    179c:	6f697461 	.word	0x6f697461
    17a0:	0000006e 	.word	0x0000006e
    17a4:	6e666564 	.word	0x6e666564
    17a8:	00007465 	.word	0x00007465
    17ac:	6553203a 	.word	0x6553203a
    17b0:	65472f74 	.word	0x65472f74
    17b4:	65642074 	.word	0x65642074
    17b8:	6c756166 	.word	0x6c756166
    17bc:	6e692074 	.word	0x6e692074
    17c0:	66726574 	.word	0x66726574
    17c4:	00656361 	.word	0x00656361
    17c8:	4844203a 	.word	0x4844203a
    17cc:	63205043 	.word	0x63205043
    17d0:	6e65696c 	.word	0x6e65696c
    17d4:	6f632074 	.word	0x6f632074
    17d8:	6e616d6d 	.word	0x6e616d6d
    17dc:	00007364 	.word	0x00007364
    17e0:	70636864 	.word	0x70636864
    17e4:	00000073 	.word	0x00000073
    17e8:	7554203a 	.word	0x7554203a
    17ec:	44206e72 	.word	0x44206e72
    17f0:	20504348 	.word	0x20504348
    17f4:	76726573 	.word	0x76726573
    17f8:	6f207265 	.word	0x6f207265
    17fc:	666f2f6e 	.word	0x666f2f6e
    1800:	00000066 	.word	0x00000066
    1804:	6c6c637a 	.word	0x6c6c637a
    1808:	00000000 	.word	0x00000000
    180c:	7554203a 	.word	0x7554203a
    1810:	5a206e72 	.word	0x5a206e72
    1814:	204c4c43 	.word	0x204c4c43
    1818:	6f2f6e6f 	.word	0x6f2f6e6f
    181c:	00006666 	.word	0x00006666
    1820:	64746573 	.word	0x64746573
    1824:	0000736e 	.word	0x0000736e
    1828:	6553203a 	.word	0x6553203a
    182c:	4e442074 	.word	0x4e442074
    1830:	64612053 	.word	0x64612053
    1834:	73657264 	.word	0x73657264
    1838:	00000073 	.word	0x00000073
    183c:	69746573 	.word	0x69746573
    1840:	00000070 	.word	0x00000070
    1844:	6553203a 	.word	0x6553203a
    1848:	50492074 	.word	0x50492074
    184c:	64646120 	.word	0x64646120
    1850:	73736572 	.word	0x73736572
    1854:	646e6120 	.word	0x646e6120
    1858:	73616d20 	.word	0x73616d20
    185c:	0000006b 	.word	0x0000006b
    1860:	67746573 	.word	0x67746573
    1864:	00000077 	.word	0x00000077
    1868:	6553203a 	.word	0x6553203a
    186c:	61472074 	.word	0x61472074
    1870:	61776574 	.word	0x61776574
    1874:	64612079 	.word	0x64612079
    1878:	73657264 	.word	0x73657264
    187c:	00000073 	.word	0x00000073
    1880:	62746573 	.word	0x62746573
    1884:	00736f69 	.word	0x00736f69
    1888:	6553203a 	.word	0x6553203a
    188c:	6f682074 	.word	0x6f682074
    1890:	73277473 	.word	0x73277473
    1894:	74654e20 	.word	0x74654e20
    1898:	534f4942 	.word	0x534f4942
    189c:	6d616e20 	.word	0x6d616e20
    18a0:	00000065 	.word	0x00000065
    18a4:	6d746573 	.word	0x6d746573
    18a8:	00006361 	.word	0x00006361
    18ac:	6553203a 	.word	0x6553203a
    18b0:	414d2074 	.word	0x414d2074
    18b4:	64612043 	.word	0x64612043
    18b8:	73657264 	.word	0x73657264
    18bc:	00000073 	.word	0x00000073
    18c0:	00006669 	.word	0x00006669
    18c4:	7242203a 	.word	0x7242203a
    18c8:	20676e69 	.word	0x20676e69
    18cc:	69206e61 	.word	0x69206e61
    18d0:	7265746e 	.word	0x7265746e
    18d4:	65636166 	.word	0x65636166
    18d8:	2f707520 	.word	0x2f707520
    18dc:	6e776f64 	.word	0x6e776f64
    18e0:	00000000 	.word	0x00000000
    18e4:	63617473 	.word	0x63617473
    18e8:	0000006b 	.word	0x0000006b
    18ec:	7453203a 	.word	0x7453203a
    18f0:	206b6361 	.word	0x206b6361
    18f4:	6e727574 	.word	0x6e727574
    18f8:	2f6e6f20 	.word	0x2f6e6f20
    18fc:	0066666f 	.word	0x0066666f
    1900:	70616568 	.word	0x70616568
    1904:	6f666e69 	.word	0x6f666e69
    1908:	00000000 	.word	0x00000000
    190c:	6843203a 	.word	0x6843203a
    1910:	206b6365 	.word	0x206b6365
    1914:	70616568 	.word	0x70616568
    1918:	61747320 	.word	0x61747320
    191c:	00737574 	.word	0x00737574
    1920:	676e6970 	.word	0x676e6970
    1924:	00000000 	.word	0x00000000
    1928:	6950203a 	.word	0x6950203a
    192c:	6120676e 	.word	0x6120676e
    1930:	5049206e 	.word	0x5049206e
    1934:	64646120 	.word	0x64646120
    1938:	73736572 	.word	0x73736572
    193c:	00000000 	.word	0x00000000
    1940:	63736e64 	.word	0x63736e64
    1944:	00000000 	.word	0x00000000
    1948:	4e44203a 	.word	0x4e44203a
    194c:	6c632053 	.word	0x6c632053
    1950:	746e6569 	.word	0x746e6569
    1954:	6d6f6320 	.word	0x6d6f6320
    1958:	646e616d 	.word	0x646e616d
    195c:	00000073 	.word	0x00000073
    1960:	6963616d 	.word	0x6963616d
    1964:	006f666e 	.word	0x006f666e
    1968:	6843203a 	.word	0x6843203a
    196c:	206b6365 	.word	0x206b6365
    1970:	2043414d 	.word	0x2043414d
    1974:	74617473 	.word	0x74617473
    1978:	69747369 	.word	0x69747369
    197c:	7363      	.short	0x7363
	...

Disassembly of section .text.TCPIP_TCP_Task%181:

00001980 <TCPIP_TCP_Task>:
    return hTCP;		

}

void  TCPIP_TCP_Task(void)
{
    1980:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1984:	b091      	sub	sp, #68	; 0x44
    if((sigPend & (TCPIP_MODULE_SIGNAL_INTERFACE_CHANGE)) != 0)
    { // interface address change occurred
        _TCPAbortSockets(ifMask, TCPIP_TCP_SIGNAL_IF_CHANGE); 
    }
#else
    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    1986:	210f      	movs	r1, #15
    1988:	200a      	movs	r0, #10
    198a:	f01c fc1f 	bl	1e1cc <_TCPIPStackModuleSignalGet>
    198e:	9003      	str	r0, [sp, #12]
#endif  // (_TCPIP_STACK_INTERFACE_CHANGE_SIGNALING != 0)

    if((sigPend & TCPIP_MODULE_SIGNAL_RX_PENDING) != 0)
    1990:	f010 0f01 	tst.w	r0, #1
    1994:	f040 852b 	bne.w	23ee <__ext_attr_.config_00804000+0x3ea>
    { //  RX signal occurred
        TCPIP_TCP_Process();
    }

    if((sigPend & TCPIP_MODULE_SIGNAL_TMO) != 0)
    1998:	9b03      	ldr	r3, [sp, #12]
    199a:	f013 0f02 	tst.w	r3, #2
    199e:	f040 854a 	bne.w	2436 <__ext_attr_.config_00804000+0x432>
    { // regular TMO occurred
        TCPIP_TCP_Tick();
    }
}
    19a2:	b011      	add	sp, #68	; 0x44
    19a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 */
static __inline__ const IPV4_ADDR* TCPIP_IPV4_PacketGetSourceAddress(TCPIP_MAC_PACKET* pPkt);

static __inline__ const IPV4_ADDR* __attribute__((always_inline)) TCPIP_IPV4_PacketGetSourceAddress(TCPIP_MAC_PACKET* pPkt)
{
    return &((IPV4_HEADER*)pPkt->pNetLayer)->SourceAddress;
    19a8:	f8d9 7018 	ldr.w	r7, [r9, #24]
    return &((IPV4_HEADER*)pPkt->pNetLayer)->DestAddress;
    19ac:	f107 0310 	add.w	r3, r7, #16
    19b0:	9307      	str	r3, [sp, #28]

    pPktSrcAdd = TCPIP_IPV4_PacketGetSourceAddress(pRxPkt);
    pPktDstAdd = TCPIP_IPV4_PacketGetDestAddress(pRxPkt);

    // Calculate IP pseudoheader checksum.
    pseudoHdr.SourceAddress.Val = pPktSrcAdd->Val;
    19b2:	68fb      	ldr	r3, [r7, #12]
    19b4:	930d      	str	r3, [sp, #52]	; 0x34
    pseudoHdr.DestAddress.Val = pPktDstAdd->Val;
    19b6:	693b      	ldr	r3, [r7, #16]
    19b8:	930e      	str	r3, [sp, #56]	; 0x38
    pseudoHdr.Zero	= 0;
    19ba:	2200      	movs	r2, #0
    19bc:	f88d 203c 	strb.w	r2, [sp, #60]	; 0x3c
    pseudoHdr.Protocol = IP_PROT_TCP;
    19c0:	2306      	movs	r3, #6
    19c2:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
    return (((hLong & 0x000000ff) << 24) | ((hLong & 0x0000ff00) << 8) | ((hLong & 0x00ff0000) >> 8) | ((hLong & 0xff000000) >> 24));
}

static inline uint16_t __attribute__((always_inline)) TCPIP_Helper_htons(uint16_t hShort)
{
       return (((hShort) << 8) | ((hShort) >> 8));
    19c6:	0a2b      	lsrs	r3, r5, #8
    19c8:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    pseudoHdr.Length = TCPIP_Helper_ntohs(tcpTotLength);
    19cc:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e

    calcChkSum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)&pseudoHdr, sizeof(pseudoHdr), 0);
    19d0:	210c      	movs	r1, #12
    19d2:	a80d      	add	r0, sp, #52	; 0x34
    19d4:	f018 fe0a 	bl	1a5ec <TCPIP_Helper_CalcIPChecksum>
    19d8:	43c3      	mvns	r3, r0
    19da:	b29b      	uxth	r3, r3
    // Note: pseudoHdr length is multiple of 4!
    if((pRxPkt->pktFlags & TCPIP_MAC_PKT_FLAG_SPLIT) != 0)
    19dc:	f8b9 2022 	ldrh.w	r2, [r9, #34]	; 0x22
    19e0:	f012 0f04 	tst.w	r2, #4
    19e4:	d033      	beq.n	1a4e <TCPIP_TCP_Task+0xce>
    {
        calcChkSum = TCPIP_Helper_PacketChecksum(pRxPkt, (uint8_t*)pTCPHdr, tcpTotLength, calcChkSum);
    19e6:	462a      	mov	r2, r5
    19e8:	4641      	mov	r1, r8
    19ea:	4648      	mov	r0, r9
    19ec:	f017 fc16 	bl	1921c <TCPIP_Helper_PacketChecksum>
    19f0:	9004      	str	r0, [sp, #16]
    else
    {
        calcChkSum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pTCPHdr, tcpTotLength, calcChkSum);
    }

    if(calcChkSum != 0)
    19f2:	9b04      	ldr	r3, [sp, #16]
    19f4:	2b00      	cmp	r3, #0
    19f6:	f040 8663 	bne.w	26c0 <__ext_attr_.config_00804000+0x6bc>
    {   // discard packet
        return TCPIP_MAC_PKT_ACK_CHKSUM_ERR;
    }


	_TcpSwapHeader(pTCPHdr);
    19fa:	4640      	mov	r0, r8
    19fc:	f019 f95a 	bl	1acb4 <_TcpSwapHeader>
    TCPIP_TCP_CheckRxPkt(pTCPHdr);

	// Skip over options to retrieve data bytes
	optionsSize = (pTCPHdr->DataOffset.Val << 2) - sizeof(*pTCPHdr);
    1a00:	f898 b00c 	ldrb.w	fp, [r8, #12]
    1a04:	ea4f 1b1b 	mov.w	fp, fp, lsr #4
    1a08:	ea4f 038b 	mov.w	r3, fp, lsl #2
    1a0c:	9306      	str	r3, [sp, #24]
	TCP_SOCKET hTCP;
	uint16_t hash;
    TCB_STUB* pSkt, *partialSkt;
    TCPIP_NET_IF* pPktIf;

    TCP_HEADER* h = (TCP_HEADER*)pRxPkt->pTransportLayer;
    1a0e:	f8d9 b01c 	ldr.w	fp, [r9, #28]
    pPktIf = (TCPIP_NET_IF*)pRxPkt->pktIf;

	// Prevent connections on invalid port 0
	if(h->DestPort == 0)
    1a12:	f8bb 2002 	ldrh.w	r2, [fp, #2]
    1a16:	2a00      	cmp	r2, #0
    1a18:	f000 8655 	beq.w	26c6 <__ext_attr_.config_00804000+0x6c2>
            break;  // OK
#endif  // defined (TCPIP_STACK_USE_IPV6)

#if defined (TCPIP_STACK_USE_IPV4)
        case IP_ADDRESS_TYPE_IPV4:
            hash = (((IPV4_ADDR *)remoteIP)->w[1] + ((IPV4_ADDR *)remoteIP)->w[0] + h->SourcePort) ^ h->DestPort;
    1a1c:	89fe      	ldrh	r6, [r7, #14]
    1a1e:	89bb      	ldrh	r3, [r7, #12]
    1a20:	441e      	add	r6, r3
    1a22:	f8bb 3000 	ldrh.w	r3, [fp]
    1a26:	441e      	add	r6, r3
    1a28:	4056      	eors	r6, r2
    1a2a:	b2b6      	uxth	r6, r6
            return 0;  // shouldn't happen
    }

	// Loop through all sockets looking for a socket that is expecting this 
	// packet or can handle it.
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    1a2c:	4bcc      	ldr	r3, [pc, #816]	; (1d60 <TCPIP_TCP_Task+0x3e0>)
    1a2e:	f8d3 c000 	ldr.w	ip, [r3]
    1a32:	f1bc 0f00 	cmp.w	ip, #0
    1a36:	f000 8649 	beq.w	26cc <__ext_attr_.config_00804000+0x6c8>
    pPktIf = (TCPIP_NET_IF*)pRxPkt->pktIf;
    1a3a:	f8d9 e028 	ldr.w	lr, [r9, #40]	; 0x28
    {
        pSkt = TCBStubs[hTCP];
    1a3e:	4bc9      	ldr	r3, [pc, #804]	; (1d64 <TCPIP_TCP_Task+0x3e4>)
    1a40:	681b      	ldr	r3, [r3, #0]
    1a42:	9305      	str	r3, [sp, #20]
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    1a44:	2300      	movs	r3, #0
	partialSkt = 0;
    1a46:	469a      	mov	sl, r3
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    1a48:	4619      	mov	r1, r3
    1a4a:	4610      	mov	r0, r2
    1a4c:	e00f      	b.n	1a6e <TCPIP_TCP_Task+0xee>
        calcChkSum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pTCPHdr, tcpTotLength, calcChkSum);
    1a4e:	461a      	mov	r2, r3
    1a50:	4629      	mov	r1, r5
    1a52:	4640      	mov	r0, r8
    1a54:	f018 fdca 	bl	1a5ec <TCPIP_Helper_CalcIPChecksum>
    1a58:	9004      	str	r0, [sp, #16]
    1a5a:	e7ca      	b.n	19f2 <TCPIP_TCP_Task+0x72>
            bool found = false;

            if(pSkt->smState == TCPIP_TCP_STATE_LISTEN)
            {
                // For listening ports, check if this is the correct port
                if(pSkt->remoteHash == h->DestPort && partialSkt == 0)
    1a5c:	f8b4 206a 	ldrh.w	r2, [r4, #106]	; 0x6a
    1a60:	4282      	cmp	r2, r0
    1a62:	d02f      	beq.n	1ac4 <TCPIP_TCP_Task+0x144>
    1a64:	3301      	adds	r3, #1
    1a66:	b21b      	sxth	r3, r3
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    1a68:	4619      	mov	r1, r3
    1a6a:	4563      	cmp	r3, ip
    1a6c:	d22f      	bcs.n	1ace <TCPIP_TCP_Task+0x14e>
        pSkt = TCBStubs[hTCP];
    1a6e:	9a05      	ldr	r2, [sp, #20]
    1a70:	f852 4021 	ldr.w	r4, [r2, r1, lsl #2]
        if(pSkt == 0 || pSkt->smState == TCPIP_TCP_STATE_CLIENT_WAIT_CONNECT)
    1a74:	2c00      	cmp	r4, #0
    1a76:	d0f5      	beq.n	1a64 <TCPIP_TCP_Task+0xe4>
    1a78:	f894 206e 	ldrb.w	r2, [r4, #110]	; 0x6e
    1a7c:	2a0b      	cmp	r2, #11
    1a7e:	d0f1      	beq.n	1a64 <TCPIP_TCP_Task+0xe4>
        if( (pSkt->addType == IP_ADDRESS_TYPE_ANY || pSkt->addType == addressType) &&
    1a80:	f894 106f 	ldrb.w	r1, [r4, #111]	; 0x6f
    1a84:	2901      	cmp	r1, #1
    1a86:	d8ed      	bhi.n	1a64 <TCPIP_TCP_Task+0xe4>
                (pSkt->pSktNet == 0 || pSkt->pSktNet == pPktIf) )
    1a88:	6c21      	ldr	r1, [r4, #64]	; 0x40
        if( (pSkt->addType == IP_ADDRESS_TYPE_ANY || pSkt->addType == addressType) &&
    1a8a:	b109      	cbz	r1, 1a90 <TCPIP_TCP_Task+0x110>
                (pSkt->pSktNet == 0 || pSkt->pSktNet == pPktIf) )
    1a8c:	458e      	cmp	lr, r1
    1a8e:	d1e9      	bne.n	1a64 <TCPIP_TCP_Task+0xe4>
            if(pSkt->smState == TCPIP_TCP_STATE_LISTEN)
    1a90:	2a00      	cmp	r2, #0
    1a92:	d0e3      	beq.n	1a5c <TCPIP_TCP_Task+0xdc>
                {
                    partialSkt = pSkt;
                }
                continue;
            }
            else if(pSkt->remoteHash != hash)
    1a94:	f8b4 206a 	ldrh.w	r2, [r4, #106]	; 0x6a
    1a98:	42b2      	cmp	r2, r6
    1a9a:	d1e3      	bne.n	1a64 <TCPIP_TCP_Task+0xe4>
            {// Ignore if the hash doesn't match
                continue;
            }

            while(	h->DestPort == pSkt->localPort && h->SourcePort == pSkt->remotePort )  
    1a9c:	f8db 1000 	ldr.w	r1, [fp]
    1aa0:	6da2      	ldr	r2, [r4, #88]	; 0x58
    1aa2:	4291      	cmp	r1, r2
    1aa4:	d1de      	bne.n	1a64 <TCPIP_TCP_Task+0xe4>
#endif  // defined (TCPIP_STACK_USE_IPV6)

#if defined (TCPIP_STACK_USE_IPV4)
                if (addressType == IP_ADDRESS_TYPE_IPV4)
                {
                    if (pSkt->destAddress.Val == ((IPV4_ADDR *)remoteIP)->Val)
    1aa6:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    1aa8:	68fa      	ldr	r2, [r7, #12]
    1aaa:	4291      	cmp	r1, r2
    1aac:	d1da      	bne.n	1a64 <TCPIP_TCP_Task+0xe4>
                break;
            }

            if(found)
            { 
                pSkt->addType = addressType;
    1aae:	2101      	movs	r1, #1
    1ab0:	f884 106f 	strb.w	r1, [r4, #111]	; 0x6f
    pSkt->pSktNet = pNet;
    1ab4:	f8c4 e040 	str.w	lr, [r4, #64]	; 0x40
    _TCPSetSourceAddress(pSkt, pSkt->addType, srcAddress);
    1ab8:	9a07      	ldr	r2, [sp, #28]
    1aba:	4620      	mov	r0, r4
    1abc:	f01c ff5d 	bl	1e97a <_TCPSetSourceAddress>
        pSkt = TCBStubs[hTCP];
    1ac0:	46a2      	mov	sl, r4
    1ac2:	e021      	b.n	1b08 <TCPIP_TCP_Task+0x188>
    1ac4:	f1ba 0f00 	cmp.w	sl, #0
    1ac8:	bf08      	it	eq
    1aca:	46a2      	moveq	sl, r4
    1acc:	e7ca      	b.n	1a64 <TCPIP_TCP_Task+0xe4>

	// If there is a partial match, then a listening socket is currently 
	// available.  Set up the extended TCB with the info needed 
	// to establish a connection and return this socket to the 
	// caller.
	while(partialSkt != 0)
    1ace:	f1ba 0f00 	cmp.w	sl, #0
    1ad2:	d07f      	beq.n	1bd4 <TCPIP_TCP_Task+0x254>
#endif  // defined (TCPIP_STACK_USE_IPV6)

#if defined (TCPIP_STACK_USE_IPV4)
            case IP_ADDRESS_TYPE_IPV4:
                // IPv4 lazy allocation
                pSkt->destAddress.Val = ((IPV4_ADDR *)remoteIP)->Val;
    1ad4:	68fb      	ldr	r3, [r7, #12]
    1ad6:	f8ca 3038 	str.w	r3, [sl, #56]	; 0x38
            default:    // shouldn't happen
                break;
        }

        // success; bind it
        pSkt->addType = addressType;
    1ada:	2101      	movs	r1, #1
    1adc:	f88a 106f 	strb.w	r1, [sl, #111]	; 0x6f
    pSkt->pSktNet = pNet;
    1ae0:	f8ca e040 	str.w	lr, [sl, #64]	; 0x40
    _TCPSetSourceAddress(pSkt, pSkt->addType, srcAddress);
    1ae4:	9a07      	ldr	r2, [sp, #28]
    1ae6:	4650      	mov	r0, sl
    1ae8:	f01c ff47 	bl	1e97a <_TCPSetSourceAddress>
        _TcpSocketBind(pSkt, pPktIf, (IP_MULTI_ADDRESS*)localIP);
        pSkt->remoteHash = hash;
    1aec:	f8aa 606a 	strh.w	r6, [sl, #106]	; 0x6a
        pSkt->remotePort = h->SourcePort;
    1af0:	f8bb 3000 	ldrh.w	r3, [fp]
    1af4:	f8aa 3058 	strh.w	r3, [sl, #88]	; 0x58
        pSkt->localPort = h->DestPort;
    1af8:	f8bb 3002 	ldrh.w	r3, [fp, #2]
    1afc:	f8aa 305a 	strh.w	r3, [sl, #90]	; 0x5a
        pSkt->txUnackedTail	= pSkt->txStart;
    1b00:	f8da 3000 	ldr.w	r3, [sl]
    1b04:	f8ca 3010 	str.w	r3, [sl, #16]
        pRxPkt->pDSeg->segLen -=  optionsSize + sizeof(*pTCPHdr);    
    1b08:	f8d9 2010 	ldr.w	r2, [r9, #16]
    1b0c:	8993      	ldrh	r3, [r2, #12]
    1b0e:	9906      	ldr	r1, [sp, #24]
    1b10:	1a5b      	subs	r3, r3, r1
    1b12:	8193      	strh	r3, [r2, #12]
    uint16_t nCopiedBytes;
    uint8_t* newRxHead;


     
    localHeaderFlags = h->Flags.byte;
    1b14:	f898 400d 	ldrb.w	r4, [r8, #13]
    localAckNumber = h->AckNumber;
    1b18:	f8d8 7008 	ldr.w	r7, [r8, #8]
    localSeqNumber = h->SeqNumber;
    1b1c:	f8d8 6004 	ldr.w	r6, [r8, #4]

    // We received a packet, reset the keep alive timer and count
    if(pSkt->Flags.keepAlive)
    1b20:	f89a 3037 	ldrb.w	r3, [sl, #55]	; 0x37
    1b24:	f013 0f40 	tst.w	r3, #64	; 0x40
    1b28:	d158      	bne.n	1bdc <TCPIP_TCP_Task+0x25c>
        {
            pSkt->eventTime = SYS_TMR_TickCountGet() + (pSkt->keepAliveTmo * SYS_TMR_TickCounterFrequencyGet())/1000;
        }
    }

    pSkt->flags.ackSent = 0;   // clear the ACK already sent
    1b2a:	f89a 306d 	ldrb.w	r3, [sl, #109]	; 0x6d
    1b2e:	f36f 0300 	bfc	r3, #0, #1
    1b32:	f88a 306d 	strb.w	r3, [sl, #109]	; 0x6d

    // Handle TCPIP_TCP_STATE_LISTEN and TCPIP_TCP_STATE_SYN_SENT states
    // Both of these states will return, so code following this 
    // state machine need not check explicitly for these two 
    // states.
    switch(pSkt->smState)
    1b36:	f89a 306e 	ldrb.w	r3, [sl, #110]	; 0x6e
    1b3a:	2b00      	cmp	r3, #0
    1b3c:	d069      	beq.n	1c12 <TCPIP_TCP_Task+0x292>
    1b3e:	2b01      	cmp	r3, #1
    1b40:	f000 80b6 	beq.w	1cb0 <TCPIP_TCP_Task+0x330>
        _TcpHandleSeg(pSkt, pTCPHdr, tcpTotLength - optionsSize - sizeof(*pTCPHdr), pRxPkt, &sktEvent);
    1b44:	3514      	adds	r5, #20
    1b46:	9a06      	ldr	r2, [sp, #24]
    1b48:	eba5 0b02 	sub.w	fp, r5, r2
    1b4c:	fa1f fb8b 	uxth.w	fp, fp
    1b50:	f1ab 0214 	sub.w	r2, fp, #20
    1b54:	b292      	uxth	r2, r2
    1b56:	9206      	str	r2, [sp, #24]

    //
    // First: check the sequence number
    //
    wSegmentLength = len = tcpLen;
    if(localHeaderFlags & FIN)
    1b58:	f014 0201 	ands.w	r2, r4, #1
    1b5c:	9207      	str	r2, [sp, #28]
    {
        wSegmentLength++;
    1b5e:	bf1a      	itte	ne
    1b60:	f1ab 0b13 	subne.w	fp, fp, #19
    1b64:	fa1f f28b 	uxthne.w	r2, fp
    wSegmentLength = len = tcpLen;
    1b68:	9a06      	ldreq	r2, [sp, #24]
    1b6a:	9205      	str	r2, [sp, #20]
    }
    if(localHeaderFlags & SYN)
    1b6c:	f014 0f02 	tst.w	r4, #2
    1b70:	d003      	beq.n	1b7a <TCPIP_TCP_Task+0x1fa>
    {
        wSegmentLength++;
    1b72:	9a05      	ldr	r2, [sp, #20]
    1b74:	3201      	adds	r2, #1
    1b76:	b292      	uxth	r2, r2
    1b78:	9205      	str	r2, [sp, #20]
    }

    // Calculate the RX FIFO space
    if(pSkt->rxHead >= pSkt->rxTail)
    1b7a:	f8da 501c 	ldr.w	r5, [sl, #28]
    1b7e:	f8da 2020 	ldr.w	r2, [sl, #32]
    1b82:	4295      	cmp	r5, r2
    1b84:	f0c0 80e5 	bcc.w	1d52 <TCPIP_TCP_Task+0x3d2>
    {
        wFreeSpace = (pSkt->rxEnd - pSkt->rxStart) - (pSkt->rxHead - pSkt->rxTail);
    1b88:	f8da 1018 	ldr.w	r1, [sl, #24]
    1b8c:	f8da 0014 	ldr.w	r0, [sl, #20]
    1b90:	1a09      	subs	r1, r1, r0
    1b92:	eba5 0b02 	sub.w	fp, r5, r2
    1b96:	eba1 0b0b 	sub.w	fp, r1, fp
    1b9a:	fa1f fb8b 	uxth.w	fp, fp
    {
        wFreeSpace = pSkt->rxTail - pSkt->rxHead - 1;
    }

    // Calculate the number of bytes ahead of our head pointer this segment skips
    lMissingBytes = localSeqNumber - pSkt->RemoteSEQ;
    1b9e:	f8da 2050 	ldr.w	r2, [sl, #80]	; 0x50
    1ba2:	1ab5      	subs	r5, r6, r2
    wMissingBytes = lMissingBytes; 

    // Run TCP acceptability tests to verify that this packet has a valid sequence number
    bSegmentAcceptable = false;
    if(wSegmentLength)
    1ba4:	9a05      	ldr	r2, [sp, #20]
    1ba6:	2a00      	cmp	r2, #0
    1ba8:	f000 80f0 	beq.w	1d8c <TCPIP_TCP_Task+0x40c>
    {
        // Check to see if we have free space, and if so, if any of the data falls within the freespace
        if(wFreeSpace)
    1bac:	f1bb 0f00 	cmp.w	fp, #0
    1bb0:	f000 80e2 	beq.w	1d78 <TCPIP_TCP_Task+0x3f8>
        {
            // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
            if((lMissingBytes >= 0) && (wFreeSpace > (uint32_t)lMissingBytes))
    1bb4:	2d00      	cmp	r5, #0
    1bb6:	f2c0 80d9 	blt.w	1d6c <TCPIP_TCP_Task+0x3ec>
    1bba:	455d      	cmp	r5, fp
    1bbc:	f0c0 80eb 	bcc.w	1d96 <TCPIP_TCP_Task+0x416>
                bSegmentAcceptable = true;
            }
            else
            {
                // RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND
                if((lMissingBytes + (int32_t)wSegmentLength > 0) && (lMissingBytes <= (int32_t)(wFreeSpace - wSegmentLength)))
    1bc0:	9a05      	ldr	r2, [sp, #20]
    1bc2:	ebab 0202 	sub.w	r2, fp, r2
                {
                    bSegmentAcceptable = true;
                }
            }

            if((lMissingBytes < (int32_t)wFreeSpace) && (wMissingBytes + (int32_t)wSegmentLength > 0))
    1bc6:	45ab      	cmp	fp, r5
    1bc8:	f300 80e5 	bgt.w	1d96 <TCPIP_TCP_Task+0x416>
                bSegmentAcceptable = true;
            }
        }
    }

    if(!bSegmentAcceptable)
    1bcc:	4295      	cmp	r5, r2
    1bce:	f340 80e2 	ble.w	1d96 <TCPIP_TCP_Task+0x416>
    1bd2:	e0d1      	b.n	1d78 <TCPIP_TCP_Task+0x3f8>
            ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    1bd4:	f06f 010e 	mvn.w	r1, #14
    1bd8:	f000 bc05 	b.w	23e6 <__ext_attr_.config_00804000+0x3e2>
        pSkt->keepAliveCount = 0;
    1bdc:	2300      	movs	r3, #0
    1bde:	f88a 3071 	strb.w	r3, [sl, #113]	; 0x71
        if(!pSkt->Flags.bTimerEnabled)
    1be2:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    1be6:	f013 0f02 	tst.w	r3, #2
    1bea:	d19e      	bne.n	1b2a <TCPIP_TCP_Task+0x1aa>
            pSkt->eventTime = SYS_TMR_TickCountGet() + (pSkt->keepAliveTmo * SYS_TMR_TickCounterFrequencyGet())/1000;
    1bec:	f01e fa7e 	bl	200ec <SYS_TMR_TickCountGet>
    1bf0:	4683      	mov	fp, r0
    1bf2:	f8ba 3068 	ldrh.w	r3, [sl, #104]	; 0x68
    1bf6:	9305      	str	r3, [sp, #20]
    1bf8:	f01e faa0 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
    1bfc:	9b05      	ldr	r3, [sp, #20]
    1bfe:	fb00 f003 	mul.w	r0, r0, r3
    1c02:	4b59      	ldr	r3, [pc, #356]	; (1d68 <TCPIP_TCP_Task+0x3e8>)
    1c04:	fba3 3000 	umull	r3, r0, r3, r0
    1c08:	eb0b 1090 	add.w	r0, fp, r0, lsr #6
    1c0c:	f8ca 0024 	str.w	r0, [sl, #36]	; 0x24
    1c10:	e78b      	b.n	1b2a <TCPIP_TCP_Task+0x1aa>
            if(localHeaderFlags & RST)
    1c12:	f014 0f04 	tst.w	r4, #4
    1c16:	d135      	bne.n	1c84 <TCPIP_TCP_Task+0x304>
            if(localHeaderFlags & ACK)
    1c18:	f014 0f10 	tst.w	r4, #16
    1c1c:	d137      	bne.n	1c8e <TCPIP_TCP_Task+0x30e>
            if(localHeaderFlags & SYN)
    1c1e:	f014 0f02 	tst.w	r4, #2
    1c22:	d040      	beq.n	1ca6 <TCPIP_TCP_Task+0x326>
                pSkt->RemoteSEQ = localSeqNumber + 1;
    1c24:	3601      	adds	r6, #1
    1c26:	f8ca 6050 	str.w	r6, [sl, #80]	; 0x50
                pSkt->wRemoteMSS = _GetMaxSegSizeOption(h);
    1c2a:	4640      	mov	r0, r8
    1c2c:	f014 fd6e 	bl	1670c <_GetMaxSegSizeOption>
    1c30:	f8aa 0062 	strh.w	r0, [sl, #98]	; 0x62
                _TCPSetHalfFlushFlag(pSkt);
    1c34:	4650      	mov	r0, sl
    1c36:	f01c f93d 	bl	1deb4 <_TCPSetHalfFlushFlag>
                _TcpSend(pSkt, SYN | ACK, SENDTCP_RESET_TIMERS);
    1c3a:	2201      	movs	r2, #1
    1c3c:	2112      	movs	r1, #18
    1c3e:	4650      	mov	r0, sl
    1c40:	f005 fff0 	bl	7c24 <_TcpSend>
    pSkt->smState = newState;
    1c44:	2302      	movs	r3, #2
    1c46:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    1c4a:	2000      	movs	r0, #0
    1c4c:	f01f fcb6 	bl	215bc <OSAL_CRIT_Enter>
    *pSigHandler = pSkt->sigHandler;
    1c50:	f8da 5074 	ldr.w	r5, [sl, #116]	; 0x74
    *pSigParam = pSkt->sigParam;
    1c54:	f8da 6078 	ldr.w	r6, [sl, #120]	; 0x78
    uint16_t sigMask = pSkt->sigMask;
    1c58:	f8ba 4072 	ldrh.w	r4, [sl, #114]	; 0x72
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
    1c5c:	4601      	mov	r1, r0
    1c5e:	2000      	movs	r0, #0
    1c60:	f01f fddb 	bl	2181a <OSAL_CRIT_Leave>
        if((sktEvent &= sigMask) != 0)
    1c64:	9b04      	ldr	r3, [sp, #16]
    1c66:	ea14 0203 	ands.w	r2, r4, r3
    1c6a:	f000 8532 	beq.w	26d2 <__ext_attr_.config_00804000+0x6ce>
            if(sigHandler != 0)
    1c6e:	2d00      	cmp	r5, #0
    1c70:	f000 8531 	beq.w	26d6 <__ext_attr_.config_00804000+0x6d2>
                (*sigHandler)(pSkt->sktIx, pRxPkt->pktIf, sktEvent, sigParam);
    1c74:	4633      	mov	r3, r6
    1c76:	f8d9 1028 	ldr.w	r1, [r9, #40]	; 0x28
    1c7a:	f9ba 0034 	ldrsh.w	r0, [sl, #52]	; 0x34
    1c7e:	47a8      	blx	r5
        ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    1c80:	2102      	movs	r1, #2
    1c82:	e3b0      	b.n	23e6 <__ext_attr_.config_00804000+0x3e2>
                _TcpCloseSocket(pSkt, 0);	// Unbind remote IP address/port info
    1c84:	2100      	movs	r1, #0
    1c86:	4650      	mov	r0, sl
    1c88:	f00f f8a0 	bl	10dcc <_TcpCloseSocket>
                return;
    1c8c:	e7dd      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                pSkt->MySEQ = localAckNumber;
    1c8e:	f8ca 704c 	str.w	r7, [sl, #76]	; 0x4c
                _TcpSend(pSkt, RST, 0);
    1c92:	2200      	movs	r2, #0
    1c94:	2104      	movs	r1, #4
    1c96:	4650      	mov	r0, sl
    1c98:	f005 ffc4 	bl	7c24 <_TcpSend>
                _TcpCloseSocket(pSkt, 0);	// Unbind remote IP address/port info
    1c9c:	2100      	movs	r1, #0
    1c9e:	4650      	mov	r0, sl
    1ca0:	f00f f894 	bl	10dcc <_TcpCloseSocket>
                return;
    1ca4:	e7d1      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                _TcpCloseSocket(pSkt, 0);	// Unbind remote IP address/port info
    1ca6:	2100      	movs	r1, #0
    1ca8:	4650      	mov	r0, sl
    1caa:	f00f f88f 	bl	10dcc <_TcpCloseSocket>
    1cae:	e7cc      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
            if(localHeaderFlags & RST)
    1cb0:	f014 0f04 	tst.w	r4, #4
    1cb4:	d1c9      	bne.n	1c4a <TCPIP_TCP_Task+0x2ca>
            if(localHeaderFlags & ACK)
    1cb6:	f014 0f10 	tst.w	r4, #16
    1cba:	f000 850e 	beq.w	26da <__ext_attr_.config_00804000+0x6d6>
                if(localAckNumber != pSkt->MySEQ)
    1cbe:	f8da 504c 	ldr.w	r5, [sl, #76]	; 0x4c
    1cc2:	42af      	cmp	r7, r5
    1cc4:	d12a      	bne.n	1d1c <TCPIP_TCP_Task+0x39c>
            if(localHeaderFlags & SYN)
    1cc6:	f014 0f02 	tst.w	r4, #2
    1cca:	d0be      	beq.n	1c4a <TCPIP_TCP_Task+0x2ca>
                pSkt->RemoteSEQ = localSeqNumber + 1;
    1ccc:	3601      	adds	r6, #1
    1cce:	f8ca 6050 	str.w	r6, [sl, #80]	; 0x50
                pSkt->remoteWindow = pSkt->maxRemoteWindow = h->Window;
    1cd2:	f8b8 300e 	ldrh.w	r3, [r8, #14]
    1cd6:	f8aa 3066 	strh.w	r3, [sl, #102]	; 0x66
    1cda:	f8aa 305c 	strh.w	r3, [sl, #92]	; 0x5c
                pSkt->wRemoteMSS = _GetMaxSegSizeOption(h);
    1cde:	4640      	mov	r0, r8
    1ce0:	f014 fd14 	bl	1670c <_GetMaxSegSizeOption>
    1ce4:	f8aa 0062 	strh.w	r0, [sl, #98]	; 0x62
                _TCPSetHalfFlushFlag(pSkt);
    1ce8:	4650      	mov	r0, sl
    1cea:	f01c f8e3 	bl	1deb4 <_TCPSetHalfFlushFlag>
                    _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
    1cee:	2201      	movs	r2, #1
    1cf0:	2110      	movs	r1, #16
    1cf2:	4650      	mov	r0, sl
    1cf4:	f005 ff96 	bl	7c24 <_TcpSend>
    pSkt->smState = newState;
    1cf8:	2303      	movs	r3, #3
    1cfa:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
                    if(pSkt->Flags.keepAlive)
    1cfe:	f89a 3037 	ldrb.w	r3, [sl, #55]	; 0x37
    1d02:	f013 0f40 	tst.w	r3, #64	; 0x40
    1d06:	d113      	bne.n	1d30 <TCPIP_TCP_Task+0x3b0>
                    pSkt->Flags.bTimerEnabled = 0;
    1d08:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    1d0c:	f36f 0341 	bfc	r3, #1, #1
    1d10:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36
                    *pSktEvent |= TCPIP_TCP_SIGNAL_ESTABLISHED;
    1d14:	f44f 7380 	mov.w	r3, #256	; 0x100
    1d18:	9304      	str	r3, [sp, #16]
    1d1a:	e796      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                    pSkt->MySEQ = localAckNumber;	// Set SEQ = SEG.ACK
    1d1c:	f8ca 704c 	str.w	r7, [sl, #76]	; 0x4c
                    _TcpSend(pSkt, RST, SENDTCP_RESET_TIMERS);		// Send the RST
    1d20:	2201      	movs	r2, #1
    1d22:	2104      	movs	r1, #4
    1d24:	4650      	mov	r0, sl
    1d26:	f005 ff7d 	bl	7c24 <_TcpSend>
                    pSkt->MySEQ = localSeqNumber;	// Restore original SEQ number
    1d2a:	f8ca 504c 	str.w	r5, [sl, #76]	; 0x4c
                    return;
    1d2e:	e78c      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                        pSkt->eventTime = SYS_TMR_TickCountGet() + (pSkt->keepAliveTmo * SYS_TMR_TickCounterFrequencyGet())/1000;
    1d30:	f01e f9dc 	bl	200ec <SYS_TMR_TickCountGet>
    1d34:	4605      	mov	r5, r0
    1d36:	f8ba 4068 	ldrh.w	r4, [sl, #104]	; 0x68
    1d3a:	f01e f9ff 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
    1d3e:	fb00 f304 	mul.w	r3, r0, r4
    1d42:	4a09      	ldr	r2, [pc, #36]	; (1d68 <TCPIP_TCP_Task+0x3e8>)
    1d44:	fba2 2303 	umull	r2, r3, r2, r3
    1d48:	eb05 1393 	add.w	r3, r5, r3, lsr #6
    1d4c:	f8ca 3024 	str.w	r3, [sl, #36]	; 0x24
    1d50:	e7da      	b.n	1d08 <TCPIP_TCP_Task+0x388>
        wFreeSpace = pSkt->rxTail - pSkt->rxHead - 1;
    1d52:	eba2 0b05 	sub.w	fp, r2, r5
    1d56:	f10b 3bff 	add.w	fp, fp, #4294967295
    1d5a:	fa1f fb8b 	uxth.w	fp, fp
    1d5e:	e71e      	b.n	1b9e <TCPIP_TCP_Task+0x21e>
    1d60:	2000e390 	.word	0x2000e390
    1d64:	2000e38c 	.word	0x2000e38c
    1d68:	10624dd3 	.word	0x10624dd3
                if((lMissingBytes + (int32_t)wSegmentLength > 0) && (lMissingBytes <= (int32_t)(wFreeSpace - wSegmentLength)))
    1d6c:	9905      	ldr	r1, [sp, #20]
    1d6e:	460a      	mov	r2, r1
    1d70:	1869      	adds	r1, r5, r1
    1d72:	2900      	cmp	r1, #0
    1d74:	f73f af25 	bgt.w	1bc2 <TCPIP_TCP_Task+0x242>
    {
        // Unacceptable segment, drop it and respond appropriately
        if(!(localHeaderFlags & RST)) 
    1d78:	f014 0f04 	tst.w	r4, #4
    1d7c:	f47f af65 	bne.w	1c4a <TCPIP_TCP_Task+0x2ca>
        {
            _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
    1d80:	2201      	movs	r2, #1
    1d82:	2110      	movs	r1, #16
    1d84:	4650      	mov	r0, sl
    1d86:	f005 ff4d 	bl	7c24 <_TcpSend>
    1d8a:	e75e      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
        if(lMissingBytes == 0)
    1d8c:	b11d      	cbz	r5, 1d96 <TCPIP_TCP_Task+0x416>
            if((lMissingBytes >= 0) && ((int32_t)wFreeSpace > lMissingBytes))
    1d8e:	2d00      	cmp	r5, #0
    1d90:	dbf2      	blt.n	1d78 <TCPIP_TCP_Task+0x3f8>
    1d92:	455d      	cmp	r5, fp
    1d94:	daf0      	bge.n	1d78 <TCPIP_TCP_Task+0x3f8>
    //
    // Fourth: check the SYN bit
    //
    // Note, that since the third step is not implemented, we can 
    // combine this second and fourth step into a single operation.
    if(localHeaderFlags & (RST | SYN))
    1d96:	f014 0f06 	tst.w	r4, #6
    1d9a:	d111      	bne.n	1dc0 <TCPIP_TCP_Task+0x440>
    // Feature not supported.  Let's process this segment.

    //
    // Fifth: check the ACK bit
    //
    if(!(localHeaderFlags & ACK))
    1d9c:	f014 0f10 	tst.w	r4, #16
    1da0:	f43f af53 	beq.w	1c4a <TCPIP_TCP_Task+0x2ca>
    {
        TCPIP_NDP_NborReachConfirm (pSkt->pSktNet, TCPIP_IPV6_DestAddressGet(pSkt->pV6Pkt));
    }
#endif  // defined (TCPIP_STACK_USE_IPV6)

    switch(pSkt->smState)
    1da4:	3b02      	subs	r3, #2
    1da6:	2b07      	cmp	r3, #7
    1da8:	f200 80fe 	bhi.w	1fa8 <TCPIP_TCP_Task+0x628>
    1dac:	e8df f013 	tbh	[pc, r3, lsl #1]
    1db0:	00240019 	.word	0x00240019
    1db4:	00240024 	.word	0x00240024
    1db8:	00fc0024 	.word	0x00fc0024
    1dbc:	01f90024 	.word	0x01f90024
        if(localHeaderFlags & RST)
    1dc0:	f014 0f04 	tst.w	r4, #4
    1dc4:	d008      	beq.n	1dd8 <TCPIP_TCP_Task+0x458>
            pSkt->Flags.bSocketReset = 1;
    1dc6:	f89a 3037 	ldrb.w	r3, [sl, #55]	; 0x37
    1dca:	f043 0302 	orr.w	r3, r3, #2
    1dce:	f88a 3037 	strb.w	r3, [sl, #55]	; 0x37
            *pSktEvent |= TCPIP_TCP_SIGNAL_RX_RST;
    1dd2:	f44f 6300 	mov.w	r3, #2048	; 0x800
    1dd6:	9304      	str	r3, [sp, #16]
        _TcpCloseSocket(pSkt, 0);
    1dd8:	2100      	movs	r1, #0
    1dda:	4650      	mov	r0, sl
    1ddc:	f00e fff6 	bl	10dcc <_TcpCloseSocket>
        return;
    1de0:	e733      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
    {
        case TCPIP_TCP_STATE_SYN_RECEIVED:
            if(localAckNumber != pSkt->MySEQ)
    1de2:	f8da 304c 	ldr.w	r3, [sl, #76]	; 0x4c
    1de6:	9308      	str	r3, [sp, #32]
    1de8:	429f      	cmp	r7, r3
    1dea:	d120      	bne.n	1e2e <TCPIP_TCP_Task+0x4ae>
    pSkt->smState = newState;
    1dec:	2303      	movs	r3, #3
    1dee:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
                _TcpSend(pSkt, RST, SENDTCP_RESET_TIMERS);		// Send the RST
                pSkt->MySEQ = localSeqNumber;	// Restore original SEQ number
                return;
            }
            _TcpSocketSetState(pSkt, TCPIP_TCP_STATE_ESTABLISHED);
            *pSktEvent |= TCPIP_TCP_SIGNAL_ESTABLISHED;
    1df2:	f44f 7380 	mov.w	r3, #256	; 0x100
    1df6:	9304      	str	r3, [sp, #16]
        case TCPIP_TCP_STATE_FIN_WAIT_1:
        case TCPIP_TCP_STATE_FIN_WAIT_2:
        case TCPIP_TCP_STATE_CLOSE_WAIT:
        case TCPIP_TCP_STATE_CLOSING:
            // Calculate what the highest possible SEQ number in our TX FIFO is
            wTemp = pSkt->txHead - pSkt->txUnackedTail;
    1df8:	f8da c008 	ldr.w	ip, [sl, #8]
    1dfc:	f8da 3010 	ldr.w	r3, [sl, #16]
            if((int32_t)wTemp < 0)
    1e00:	ebbc 0003 	subs.w	r0, ip, r3
    1e04:	d41e      	bmi.n	1e44 <TCPIP_TCP_Task+0x4c4>
            {
                wTemp += pSkt->txEnd - pSkt->txStart;
            }
            dwTemp = pSkt->MySEQ + wTemp;
    1e06:	f8da 104c 	ldr.w	r1, [sl, #76]	; 0x4c

            // Drop the packet if it ACKs something we haven't sent
            dwTemp = localAckNumber - dwTemp;
    1e0a:	1a7a      	subs	r2, r7, r1
    1e0c:	1a12      	subs	r2, r2, r0
            if((int32_t)dwTemp > 0)
    1e0e:	2a00      	cmp	r2, #0
    1e10:	dd28      	ble.n	1e64 <TCPIP_TCP_Task+0x4e4>
            {   // acknowledged more than we've sent??
                if(!pSkt->flags.bFINSent || pSkt->flags.seqInc || dwTemp != 1)
    1e12:	f8ba 006c 	ldrh.w	r0, [sl, #108]	; 0x6c
    1e16:	f400 7001 	and.w	r0, r0, #516	; 0x204
    1e1a:	2804      	cmp	r0, #4
    1e1c:	d101      	bne.n	1e22 <TCPIP_TCP_Task+0x4a2>
    1e1e:	2a01      	cmp	r2, #1
    1e20:	d017      	beq.n	1e52 <TCPIP_TCP_Task+0x4d2>
                {
                    _TcpSend(pSkt, ACK, 0);
    1e22:	2200      	movs	r2, #0
    1e24:	2110      	movs	r1, #16
    1e26:	4650      	mov	r0, sl
    1e28:	f005 fefc 	bl	7c24 <_TcpSend>
                    return;
    1e2c:	e70d      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                pSkt->MySEQ = localAckNumber;	// Set SEQ = SEG.ACK
    1e2e:	f8ca 704c 	str.w	r7, [sl, #76]	; 0x4c
                _TcpSend(pSkt, RST, SENDTCP_RESET_TIMERS);		// Send the RST
    1e32:	2201      	movs	r2, #1
    1e34:	2104      	movs	r1, #4
    1e36:	4650      	mov	r0, sl
    1e38:	f005 fef4 	bl	7c24 <_TcpSend>
                pSkt->MySEQ = localSeqNumber;	// Restore original SEQ number
    1e3c:	9b08      	ldr	r3, [sp, #32]
    1e3e:	f8ca 304c 	str.w	r3, [sl, #76]	; 0x4c
                return;
    1e42:	e702      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                wTemp += pSkt->txEnd - pSkt->txStart;
    1e44:	f8da 1004 	ldr.w	r1, [sl, #4]
    1e48:	f8da 2000 	ldr.w	r2, [sl]
    1e4c:	1a89      	subs	r1, r1, r2
    1e4e:	4408      	add	r0, r1
    1e50:	e7d9      	b.n	1e06 <TCPIP_TCP_Task+0x486>
                }
                else
                {
                    pSkt->MySEQ++;      // since we didn't count the FIN
    1e52:	3101      	adds	r1, #1
    1e54:	f8ca 104c 	str.w	r1, [sl, #76]	; 0x4c
                    pSkt->flags.seqInc = 1;
    1e58:	f89a 206d 	ldrb.w	r2, [sl, #109]	; 0x6d
    1e5c:	f042 0202 	orr.w	r2, r2, #2
    1e60:	f88a 206d 	strb.w	r2, [sl, #109]	; 0x6d
                }
            }

            // Throw away all ACKnowledged TX data:
            // Calculate what the last acknowledged sequence number was (ignoring any FINs we sent)
            dwTemp = pSkt->MySEQ - (uint32_t)(pSkt->txUnackedTail - pSkt->txTail);
    1e64:	f8da 204c 	ldr.w	r2, [sl, #76]	; 0x4c
    1e68:	9209      	str	r2, [sp, #36]	; 0x24
    1e6a:	f8da 100c 	ldr.w	r1, [sl, #12]
    1e6e:	9108      	str	r1, [sp, #32]
    1e70:	eba3 0e01 	sub.w	lr, r3, r1
            if(pSkt->txUnackedTail < pSkt->txTail)
    1e74:	428b      	cmp	r3, r1
    1e76:	d22f      	bcs.n	1ed8 <TCPIP_TCP_Task+0x558>
            {
                dwTemp -= pSkt->txEnd - pSkt->txStart;
    1e78:	f8da 0004 	ldr.w	r0, [sl, #4]
    1e7c:	f8da 1000 	ldr.w	r1, [sl]
    1e80:	1a41      	subs	r1, r0, r1
            }

            // Calcluate how many bytes were ACKed with this packet
            dwTemp = localAckNumber - dwTemp;
    1e82:	1ab8      	subs	r0, r7, r2
    1e84:	4470      	add	r0, lr
    1e86:	4408      	add	r0, r1
            if(((int32_t)(dwTemp) > 0) && (dwTemp <= pSkt->txEnd - pSkt->txStart))
    1e88:	2800      	cmp	r0, #0
    1e8a:	dd38      	ble.n	1efe <TCPIP_TCP_Task+0x57e>
    1e8c:	f8da 2004 	ldr.w	r2, [sl, #4]
    1e90:	920a      	str	r2, [sp, #40]	; 0x28
    1e92:	f8da 1000 	ldr.w	r1, [sl]
    1e96:	1a52      	subs	r2, r2, r1
    1e98:	920b      	str	r2, [sp, #44]	; 0x2c
    1e9a:	4290      	cmp	r0, r2
    1e9c:	d82c      	bhi.n	1ef8 <TCPIP_TCP_Task+0x578>
            {
                pSkt->flags.bRXNoneACKed1 = 0;
    1e9e:	f89a 106c 	ldrb.w	r1, [sl, #108]	; 0x6c
                pSkt->flags.bRXNoneACKed2 = 0;
    1ea2:	f001 01ef 	and.w	r1, r1, #239	; 0xef
    1ea6:	f36f 1145 	bfc	r1, #5, #1
    1eaa:	f88a 106c 	strb.w	r1, [sl, #108]	; 0x6c
                pSkt->Flags.bHalfFullFlush = false;
    1eae:	f89a 1036 	ldrb.w	r1, [sl, #54]	; 0x36
    1eb2:	f36f 1145 	bfc	r1, #5, #1
    1eb6:	f88a 1036 	strb.w	r1, [sl, #54]	; 0x36

                // Bytes ACKed, free up the TX FIFO space
                ptrTemp = pSkt->txTail;
                pSkt->txTail += dwTemp;
    1eba:	9a08      	ldr	r2, [sp, #32]
    1ebc:	4402      	add	r2, r0
    1ebe:	f8ca 200c 	str.w	r2, [sl, #12]
                        pSkt->txUnackedTail = pSkt->txTail;
                    }
                }
                else
                {
                    ptrTemp = pSkt->txUnackedTail + (pSkt->txEnd - pSkt->txStart);
    1ec2:	990b      	ldr	r1, [sp, #44]	; 0x2c
    1ec4:	440b      	add	r3, r1
                    if(ptrTemp < pSkt->txTail)
    1ec6:	4293      	cmp	r3, r2
    1ec8:	f0c0 80ff 	bcc.w	20ca <__ext_attr_.config_00804000+0xc6>
                    {
                        pSkt->MySEQ += pSkt->txTail - ptrTemp;
                        pSkt->txUnackedTail = pSkt->txTail;
                    }
                }
                if(pSkt->txTail >= pSkt->txEnd)
    1ecc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1ece:	429a      	cmp	r2, r3
    1ed0:	f0c0 8455 	bcc.w	277e <__ext_attr_.config_00804000+0x77a>
    1ed4:	f000 bc4f 	b.w	2776 <__ext_attr_.config_00804000+0x772>
            dwTemp = localAckNumber - dwTemp;
    1ed8:	9909      	ldr	r1, [sp, #36]	; 0x24
    1eda:	1a78      	subs	r0, r7, r1
    1edc:	4470      	add	r0, lr
            if(((int32_t)(dwTemp) > 0) && (dwTemp <= pSkt->txEnd - pSkt->txStart))
    1ede:	2800      	cmp	r0, #0
    1ee0:	dd0a      	ble.n	1ef8 <TCPIP_TCP_Task+0x578>
    1ee2:	f8da 1004 	ldr.w	r1, [sl, #4]
    1ee6:	460a      	mov	r2, r1
    1ee8:	910a      	str	r1, [sp, #40]	; 0x28
    1eea:	f8da 1000 	ldr.w	r1, [sl]
    1eee:	1a52      	subs	r2, r2, r1
    1ef0:	920b      	str	r2, [sp, #44]	; 0x2c
    1ef2:	4290      	cmp	r0, r2
    1ef4:	f240 8420 	bls.w	2738 <__ext_attr_.config_00804000+0x734>
                }
            }
            else
            {   // no acknowledge
                // See if we have outstanding TX data that is waiting for an ACK
                if(pSkt->txTail != pSkt->txUnackedTail)
    1ef8:	9a08      	ldr	r2, [sp, #32]
    1efa:	4293      	cmp	r3, r2
    1efc:	d02c      	beq.n	1f58 <TCPIP_TCP_Task+0x5d8>
                {
                    if(pSkt->flags.bRXNoneACKed1)
    1efe:	f89a 106c 	ldrb.w	r1, [sl, #108]	; 0x6c
    1f02:	f011 0f10 	tst.w	r1, #16
    1f06:	d021      	beq.n	1f4c <TCPIP_TCP_Task+0x5cc>
                    {
                        if(pSkt->flags.bRXNoneACKed2)
    1f08:	f011 0f20 	tst.w	r1, #32
    1f0c:	d018      	beq.n	1f40 <TCPIP_TCP_Task+0x5c0>
            dwTemp = pSkt->MySEQ - (uint32_t)(pSkt->txUnackedTail - pSkt->txTail);
    1f0e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    1f10:	eba2 010e 	sub.w	r1, r2, lr
                        {
                            // Set up to perform a fast retransmission
                            // Roll back unacknowledged TX tail pointer to cause retransmit to occur
                            pSkt->MySEQ -= (pSkt->txUnackedTail - pSkt->txTail);
    1f14:	f8ca 104c 	str.w	r1, [sl, #76]	; 0x4c
                            if(pSkt->txUnackedTail < pSkt->txTail)
    1f18:	9a08      	ldr	r2, [sp, #32]
    1f1a:	4293      	cmp	r3, r2
    1f1c:	d207      	bcs.n	1f2e <TCPIP_TCP_Task+0x5ae>
                            {
                                pSkt->MySEQ -= (pSkt->txEnd - pSkt->txStart);
    1f1e:	f8da 3004 	ldr.w	r3, [sl, #4]
    1f22:	f8da 0000 	ldr.w	r0, [sl]
    1f26:	1a1b      	subs	r3, r3, r0
    1f28:	1acb      	subs	r3, r1, r3
    1f2a:	f8ca 304c 	str.w	r3, [sl, #76]	; 0x4c
                            }
                            pSkt->txUnackedTail = pSkt->txTail;
    1f2e:	9b08      	ldr	r3, [sp, #32]
    1f30:	f8ca 3010 	str.w	r3, [sl, #16]
                            pSkt->Flags.bTXASAPWithoutTimerReset = 1;
    1f34:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    1f38:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    1f3c:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36
                        }
                        pSkt->flags.bRXNoneACKed2 = 1;
    1f40:	f89a 306c 	ldrb.w	r3, [sl, #108]	; 0x6c
    1f44:	f043 0320 	orr.w	r3, r3, #32
    1f48:	f88a 306c 	strb.w	r3, [sl, #108]	; 0x6c
                    }
                    pSkt->flags.bRXNoneACKed1 = 1;
    1f4c:	f89a 306c 	ldrb.w	r3, [sl, #108]	; 0x6c
    1f50:	f043 0310 	orr.w	r3, r3, #16
    1f54:	f88a 306c 	strb.w	r3, [sl, #108]	; 0x6c
                }
            }

            // No need to keep our retransmit timer going if we have nothing that needs ACKing anymore
            if(pSkt->txTail == pSkt->txHead)
    1f58:	f8da 300c 	ldr.w	r3, [sl, #12]
    1f5c:	459c      	cmp	ip, r3
    1f5e:	f000 80bc 	beq.w	20da <__ext_attr_.config_00804000+0xd6>
                    }
                }
            }

            // update the max window
            if(h->Window > pSkt->maxRemoteWindow)
    1f62:	f8b8 300e 	ldrh.w	r3, [r8, #14]
    1f66:	f8ba 2066 	ldrh.w	r2, [sl, #102]	; 0x66
    1f6a:	429a      	cmp	r2, r3
            {
                pSkt->maxRemoteWindow = h->Window;
    1f6c:	bf38      	it	cc
    1f6e:	f8aa 3066 	strhcc.w	r3, [sl, #102]	; 0x66
            }
            // The window size advertised in this packet is adjusted to account 
            // for any bytes that we have transmitted but haven't been ACKed yet 
            // by this segment.
            wNewWindow = h->Window - ((uint16_t)(pSkt->MySEQ - localAckNumber));
    1f72:	f8da 204c 	ldr.w	r2, [sl, #76]	; 0x4c
    1f76:	f8b8 300e 	ldrh.w	r3, [r8, #14]
    1f7a:	443b      	add	r3, r7
    1f7c:	1a9b      	subs	r3, r3, r2
    1f7e:	b29b      	uxth	r3, r3

            // Update the local stored copy of the RemoteWindow.
            // If previously we had a zero window, and now we don't, then 
            // immediately send whatever was pending.
            if((pSkt->remoteWindow == 0u) && wNewWindow)
    1f80:	f8ba 105c 	ldrh.w	r1, [sl, #92]	; 0x5c
    1f84:	b931      	cbnz	r1, 1f94 <TCPIP_TCP_Task+0x614>
    1f86:	b12b      	cbz	r3, 1f94 <TCPIP_TCP_Task+0x614>
            {
                pSkt->Flags.bTXASAP = 1;
    1f88:	f89a 1036 	ldrb.w	r1, [sl, #54]	; 0x36
    1f8c:	f041 0140 	orr.w	r1, r1, #64	; 0x40
    1f90:	f88a 1036 	strb.w	r1, [sl, #54]	; 0x36
            }
            pSkt->remoteWindow = wNewWindow;
    1f94:	f8aa 305c 	strh.w	r3, [sl, #92]	; 0x5c

            // A couple of states must do all of the TCPIP_TCP_STATE_ESTABLISHED stuff, but also a little more
            if(pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1)
    1f98:	f89a 306e 	ldrb.w	r3, [sl, #110]	; 0x6e
    1f9c:	2b04      	cmp	r3, #4
    1f9e:	f000 80d7 	beq.w	2150 <__ext_attr_.config_00804000+0x14c>
                    // doesn't send us a FIN in a timely manner.
                    pSkt->closeWaitTime = SYS_TMR_TickCountGet() + (TCPIP_TCP_FIN_WAIT_2_TIMEOUT * SYS_TMR_TickCounterFrequencyGet())/1000;
                    _TcpSocketSetState(pSkt, TCPIP_TCP_STATE_FIN_WAIT_2);
                }
            }
            else if(pSkt->smState == TCPIP_TCP_STATE_CLOSING)
    1fa2:	2b06      	cmp	r3, #6
    1fa4:	f000 80f5 	beq.w	2192 <__ext_attr_.config_00804000+0x18e>
    //
    // Sixth: Check the URG bit
    //
    // Urgent packets are not supported in this stack, so we
    // will throw them away instead
    if(localHeaderFlags & URG)
    1fa8:	f014 0f20 	tst.w	r4, #32
    1fac:	f47f ae4d 	bne.w	1c4a <TCPIP_TCP_Task+0x2ca>

    //
    // Seventh: Process the segment text
    //
    // Throw data away if in a state that doesn't accept data
    if(pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT || pSkt->smState == TCPIP_TCP_STATE_CLOSING || pSkt->smState == TCPIP_TCP_STATE_LAST_ACK)
    1fb0:	f89a 206e 	ldrb.w	r2, [sl, #110]	; 0x6e
    1fb4:	f1a2 0308 	sub.w	r3, r2, #8
    1fb8:	b2db      	uxtb	r3, r3
    1fba:	2b01      	cmp	r3, #1
    1fbc:	f67f ae45 	bls.w	1c4a <TCPIP_TCP_Task+0x2ca>
    1fc0:	2a06      	cmp	r2, #6
    1fc2:	f43f ae42 	beq.w	1c4a <TCPIP_TCP_Task+0x2ca>
    {
        return;
    }

    // Copy any valid segment data into our RX FIFO, if any
    if(len)
    1fc6:	9a06      	ldr	r2, [sp, #24]
    1fc8:	2a00      	cmp	r2, #0
    1fca:	d03d      	beq.n	2048 <__ext_attr_.config_00804000+0x44>
    {
        // See if there are bytes we must skip
        // wMissingBytes == 0: this new data is in sync with what we expect
        // wMissingBytes  < 0: this packet contains old data that needs to be skipped
        if(wMissingBytes <= 0)
    1fcc:	2d00      	cmp	r5, #0
    1fce:	f340 80f3 	ble.w	21b8 <__ext_attr_.config_00804000+0x1b4>
        } 
        else if(wMissingBytes > 0)
        {   // wMissingBytes  > 0: this packet contains ahead data
            // This packet is out of order or we lost a packet, see if we can generate a hole to accomodate it
            // Truncate packets that would overflow our TCP RX FIFO
            if(len + wMissingBytes > wFreeSpace)
    1fd2:	9b06      	ldr	r3, [sp, #24]
    1fd4:	442b      	add	r3, r5
    1fd6:	455b      	cmp	r3, fp
    1fd8:	dd04      	ble.n	1fe4 <TCPIP_TCP_Task+0x664>
            {
                len = wFreeSpace - wMissingBytes;
    1fda:	ebab 0b05 	sub.w	fp, fp, r5
    1fde:	fa1f f38b 	uxth.w	r3, fp
    1fe2:	9306      	str	r3, [sp, #24]
            }

            // Position packet read pointer to start of useful data area.
            pSegSrc = (uint8_t*)h + (h->DataOffset.Val << 2);
    1fe4:	f898 300c 	ldrb.w	r3, [r8, #12]
    1fe8:	091b      	lsrs	r3, r3, #4
    1fea:	eb08 0383 	add.w	r3, r8, r3, lsl #2
    1fee:	930c      	str	r3, [sp, #48]	; 0x30

            // See if we need a two part copy (spans rxEnd->rxStart)
            if(pSkt->rxHead + wMissingBytes + len > pSkt->rxEnd)
    1ff0:	f8da 101c 	ldr.w	r1, [sl, #28]
    1ff4:	f8da 3018 	ldr.w	r3, [sl, #24]
    1ff8:	9a06      	ldr	r2, [sp, #24]
    1ffa:	442a      	add	r2, r5
    1ffc:	440a      	add	r2, r1
    1ffe:	4293      	cmp	r3, r2
    2000:	f080 8169 	bcs.w	22d6 <__ext_attr_.config_00804000+0x2d2>
            {
                // Calculate number of data bytes to copy before wraparound
                wTemp = pSkt->rxEnd - pSkt->rxHead + 1 - wMissingBytes;
    2004:	1a5a      	subs	r2, r3, r1
    2006:	3201      	adds	r2, #1
                if((int32_t)wTemp >= 0)
    2008:	1b52      	subs	r2, r2, r5
    200a:	f100 8156 	bmi.w	22ba <__ext_attr_.config_00804000+0x2b6>
                {
                    nCopiedBytes = TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxHead + wMissingBytes, &pSegSrc, wTemp, true);
    200e:	fa1f f882 	uxth.w	r8, r2
    2012:	2401      	movs	r4, #1
    2014:	9400      	str	r4, [sp, #0]
    2016:	4643      	mov	r3, r8
    2018:	a80c      	add	r0, sp, #48	; 0x30
    201a:	4602      	mov	r2, r0
    201c:	4429      	add	r1, r5
    201e:	4648      	mov	r0, r9
    2020:	f017 fe5e 	bl	19ce0 <TCPIP_Helper_PacketCopy>
    2024:	4683      	mov	fp, r0
                    nCopiedBytes += TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxStart, &pSegSrc, len - wTemp, true);
    2026:	9a06      	ldr	r2, [sp, #24]
    2028:	eba2 0308 	sub.w	r3, r2, r8
    202c:	9400      	str	r4, [sp, #0]
    202e:	b29b      	uxth	r3, r3
    2030:	aa0c      	add	r2, sp, #48	; 0x30
    2032:	f8da 1014 	ldr.w	r1, [sl, #20]
    2036:	4648      	mov	r0, r9
    2038:	f017 fe52 	bl	19ce0 <TCPIP_Helper_PacketCopy>
    203c:	4458      	add	r0, fp
    203e:	b280      	uxth	r0, r0
            else
            {
                nCopiedBytes = TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxHead + wMissingBytes, &pSegSrc, len, true);
            }

            if(nCopiedBytes == len)
    2040:	9b06      	ldr	r3, [sp, #24]
    2042:	4283      	cmp	r3, r0
    2044:	f000 8150 	beq.w	22e8 <__ext_attr_.config_00804000+0x2e4>
    // Send back an ACK of the data (+SYN | FIN) we just received, 
    // if any.  To minimize bandwidth waste, we are implementing 
    // the delayed acknowledgement algorithm here, only sending 
    // back an immediate ACK if this is the second segment received.  
    // Otherwise, a 200ms timer will cause the ACK to be transmitted.
    if(wSegmentLength)
    2048:	9b05      	ldr	r3, [sp, #20]
    204a:	b1cb      	cbz	r3, 2080 <__ext_attr_.config_00804000+0x7c>
        // For non-established sockets, delete all data in 
        // the RX buffer immediately after receiving it.
        // That'll ensure that the RX window is nonzero and 
        // the remote node will be able to send a FIN response, 
        // which needs an RX window of at least 1.
        if(pSkt->smState != TCPIP_TCP_STATE_ESTABLISHED && pSkt->smState != TCPIP_TCP_STATE_FIN_WAIT_1 && pSkt->smState != TCPIP_TCP_STATE_FIN_WAIT_2)
    204c:	f89a 306e 	ldrb.w	r3, [sl, #110]	; 0x6e
    2050:	3b03      	subs	r3, #3
    2052:	b2db      	uxtb	r3, r3
    2054:	2b02      	cmp	r3, #2
        {
            pSkt->rxTail = pSkt->rxHead;
    2056:	bf84      	itt	hi
    2058:	f8da 301c 	ldrhi.w	r3, [sl, #28]
    205c:	f8ca 3020 	strhi.w	r3, [sl, #32]
        }

        if(pSkt->Flags.bOneSegmentReceived)
    2060:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    2064:	f013 0f10 	tst.w	r3, #16
    2068:	f040 816d 	bne.w	2346 <__ext_attr_.config_00804000+0x342>
            _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
            // bOneSegmentReceived is cleared in _TcpSend(pSkt, ), so no need here
        }
        else
        {
            pSkt->Flags.bOneSegmentReceived = true;	
    206c:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    2070:	f043 0310 	orr.w	r3, r3, #16
    2074:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36

            // Do not send an ACK immediately back.  Instead, we will 
            // perform delayed acknowledgements.  To do this, we will 
            // just start a timer
            if(!pSkt->Flags.bDelayedACKTimerEnabled)
    2078:	f013 0f08 	tst.w	r3, #8
    207c:	f000 8169 	beq.w	2352 <__ext_attr_.config_00804000+0x34e>
    }

    //
    // Eighth: check the FIN bit
    //
    if(localHeaderFlags & FIN)
    2080:	9b07      	ldr	r3, [sp, #28]
    2082:	2b00      	cmp	r3, #0
    2084:	f43f ade1 	beq.w	1c4a <TCPIP_TCP_Task+0x2ca>
    {
        // Note: Since we don't have a good means of storing "FIN bytes" 
        // in our TCP RX FIFO, we must ensure that FINs are processed 
        // in-order.
        if(pSkt->RemoteSEQ + 1 == localSeqNumber + (uint32_t)wSegmentLength)
    2088:	f8da 3050 	ldr.w	r3, [sl, #80]	; 0x50
    208c:	3301      	adds	r3, #1
    208e:	9a05      	ldr	r2, [sp, #20]
    2090:	4432      	add	r2, r6
    2092:	4293      	cmp	r3, r2
    2094:	f47f add9 	bne.w	1c4a <TCPIP_TCP_Task+0x2ca>
        {
            // FINs are treated as one byte of data for ACK sequencing
            pSkt->RemoteSEQ++;
    2098:	f8ca 3050 	str.w	r3, [sl, #80]	; 0x50

            *pSktEvent |= TCPIP_TCP_SIGNAL_RX_FIN;
    209c:	9b04      	ldr	r3, [sp, #16]
    209e:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
    20a2:	b293      	uxth	r3, r2
    20a4:	9304      	str	r3, [sp, #16]
            pSkt->Flags.bRxFin = 1;
    20a6:	f89a 3037 	ldrb.w	r3, [sl, #55]	; 0x37
    20aa:	f043 0304 	orr.w	r3, r3, #4
    20ae:	f88a 3037 	strb.w	r3, [sl, #55]	; 0x37
            switch(pSkt->smState)
    20b2:	f89a 306e 	ldrb.w	r3, [sl, #110]	; 0x6e
    20b6:	3b02      	subs	r3, #2
    20b8:	2b03      	cmp	r3, #3
    20ba:	f200 8178 	bhi.w	23ae <__ext_attr_.config_00804000+0x3aa>
    20be:	e8df f013 	tbh	[pc, r3, lsl #1]
    20c2:	015d      	.short	0x015d
    20c4:	016f0166 	.word	0x016f0166
    20c8:	0186      	.short	0x0186
                        pSkt->MySEQ += pSkt->txTail - ptrTemp;
    20ca:	1ad3      	subs	r3, r2, r3
    20cc:	9909      	ldr	r1, [sp, #36]	; 0x24
    20ce:	440b      	add	r3, r1
    20d0:	f8ca 304c 	str.w	r3, [sl, #76]	; 0x4c
                        pSkt->txUnackedTail = pSkt->txTail;
    20d4:	f8ca 2010 	str.w	r2, [sl, #16]
    20d8:	e34a      	b.n	2770 <__ext_attr_.config_00804000+0x76c>
                if(pSkt->Flags.bTXFIN == 0u)
    20da:	f89a 3037 	ldrb.w	r3, [sl, #55]	; 0x37
    20de:	f013 0f01 	tst.w	r3, #1
    20e2:	d11d      	bne.n	2120 <__ext_attr_.config_00804000+0x11c>
                    if(pSkt->Flags.keepAlive)
    20e4:	f013 0f40 	tst.w	r3, #64	; 0x40
    20e8:	d106      	bne.n	20f8 <__ext_attr_.config_00804000+0xf4>
                    pSkt->Flags.bTimerEnabled = 0;
    20ea:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    20ee:	f36f 0341 	bfc	r3, #1, #1
    20f2:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36
    20f6:	e734      	b.n	1f62 <TCPIP_TCP_Task+0x5e2>
                        pSkt->eventTime = SYS_TMR_TickCountGet() + (pSkt->keepAliveTmo * SYS_TMR_TickCounterFrequencyGet())/1000;
    20f8:	f01d fff8 	bl	200ec <SYS_TMR_TickCountGet>
    20fc:	9008      	str	r0, [sp, #32]
    20fe:	f8ba 3068 	ldrh.w	r3, [sl, #104]	; 0x68
    2102:	9309      	str	r3, [sp, #36]	; 0x24
    2104:	f01e f81a 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
    2108:	9b09      	ldr	r3, [sp, #36]	; 0x24
    210a:	fb00 f303 	mul.w	r3, r0, r3
    210e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    2112:	fbb3 f3f2 	udiv	r3, r3, r2
    2116:	9a08      	ldr	r2, [sp, #32]
    2118:	4413      	add	r3, r2
    211a:	f8ca 3024 	str.w	r3, [sl, #36]	; 0x24
    211e:	e7e4      	b.n	20ea <__ext_attr_.config_00804000+0xe6>
                    if((pSkt->MySEQ == localAckNumber) && pSkt->flags.bFINSent)
    2120:	f8da 304c 	ldr.w	r3, [sl, #76]	; 0x4c
    2124:	429f      	cmp	r7, r3
    2126:	f47f af1c 	bne.w	1f62 <TCPIP_TCP_Task+0x5e2>
    212a:	f89a 306c 	ldrb.w	r3, [sl, #108]	; 0x6c
    212e:	f013 0f04 	tst.w	r3, #4
    2132:	f43f af16 	beq.w	1f62 <TCPIP_TCP_Task+0x5e2>
                        pSkt->Flags.bTimerEnabled = 0;
    2136:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    213a:	f36f 0341 	bfc	r3, #1, #1
    213e:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36
                        pSkt->Flags.bTXFIN = 0;
    2142:	f89a 3037 	ldrb.w	r3, [sl, #55]	; 0x37
    2146:	f36f 0300 	bfc	r3, #0, #1
    214a:	f88a 3037 	strb.w	r3, [sl, #55]	; 0x37
    214e:	e708      	b.n	1f62 <TCPIP_TCP_Task+0x5e2>
                if((pSkt->MySEQ == localAckNumber) && pSkt->flags.bFINSent)
    2150:	4297      	cmp	r7, r2
    2152:	d004      	beq.n	215e <__ext_attr_.config_00804000+0x15a>
    if(localHeaderFlags & URG)
    2154:	f014 0f20 	tst.w	r4, #32
    2158:	f43f af35 	beq.w	1fc6 <TCPIP_TCP_Task+0x646>
    215c:	e575      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                if((pSkt->MySEQ == localAckNumber) && pSkt->flags.bFINSent)
    215e:	f89a 306c 	ldrb.w	r3, [sl, #108]	; 0x6c
    2162:	f013 0f04 	tst.w	r3, #4
    2166:	d0f5      	beq.n	2154 <__ext_attr_.config_00804000+0x150>
                    pSkt->closeWaitTime = SYS_TMR_TickCountGet() + (TCPIP_TCP_FIN_WAIT_2_TIMEOUT * SYS_TMR_TickCounterFrequencyGet())/1000;
    2168:	f01d ffc0 	bl	200ec <SYS_TMR_TickCountGet>
    216c:	9008      	str	r0, [sp, #32]
    216e:	f01d ffe5 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
    2172:	f241 3388 	movw	r3, #5000	; 0x1388
    2176:	fb03 f300 	mul.w	r3, r3, r0
    217a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    217e:	fbb3 f3f2 	udiv	r3, r3, r2
    2182:	9a08      	ldr	r2, [sp, #32]
    2184:	4413      	add	r3, r2
    2186:	f8ca 3030 	str.w	r3, [sl, #48]	; 0x30
    pSkt->smState = newState;
    218a:	2305      	movs	r3, #5
    218c:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
    2190:	e7e0      	b.n	2154 <__ext_attr_.config_00804000+0x150>
                if(pSkt->MySEQ == localAckNumber)
    2192:	4297      	cmp	r7, r2
    2194:	f47f ad59 	bne.w	1c4a <TCPIP_TCP_Task+0x2ca>
                    _TcpCloseSocket(pSkt, 0);
    2198:	2100      	movs	r1, #0
    219a:	4650      	mov	r0, sl
    219c:	f00e fe16 	bl	10dcc <_TcpCloseSocket>
    21a0:	e553      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
            if(pSkt->MySEQ + 1 == localAckNumber)
    21a2:	f8da 304c 	ldr.w	r3, [sl, #76]	; 0x4c
    21a6:	3301      	adds	r3, #1
    21a8:	429f      	cmp	r7, r3
    21aa:	f47f ad4e 	bne.w	1c4a <TCPIP_TCP_Task+0x2ca>
                _TcpCloseSocket(pSkt, 0);
    21ae:	2100      	movs	r1, #0
    21b0:	4650      	mov	r0, sl
    21b2:	f00e fe0b 	bl	10dcc <_TcpCloseSocket>
    21b6:	e548      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
            pSegSrc = (uint8_t*)h + ((h->DataOffset.Val << 2) - wMissingBytes);
    21b8:	f898 300c 	ldrb.w	r3, [r8, #12]
    21bc:	091b      	lsrs	r3, r3, #4
    21be:	ebc5 0383 	rsb	r3, r5, r3, lsl #2
    21c2:	4443      	add	r3, r8
    21c4:	930c      	str	r3, [sp, #48]	; 0x30
            len += wMissingBytes;		
    21c6:	442a      	add	r2, r5
    21c8:	b293      	uxth	r3, r2
            if(len > wFreeSpace)
    21ca:	459b      	cmp	fp, r3
    21cc:	bf28      	it	cs
    21ce:	469b      	movcs	fp, r3
            if(pSkt->rxHead + len > pSkt->rxEnd)
    21d0:	f8da 101c 	ldr.w	r1, [sl, #28]
    21d4:	f8da 3018 	ldr.w	r3, [sl, #24]
    21d8:	eb01 020b 	add.w	r2, r1, fp
    21dc:	4293      	cmp	r3, r2
    21de:	d25c      	bcs.n	229a <__ext_attr_.config_00804000+0x296>
                wTemp = pSkt->rxEnd - pSkt->rxHead + 1;
    21e0:	1a5b      	subs	r3, r3, r1
    21e2:	f103 0801 	add.w	r8, r3, #1
                nCopiedBytes = TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxHead, &pSegSrc, wTemp, true);
    21e6:	fa1f f588 	uxth.w	r5, r8
    21ea:	2401      	movs	r4, #1
    21ec:	9400      	str	r4, [sp, #0]
    21ee:	462b      	mov	r3, r5
    21f0:	aa0c      	add	r2, sp, #48	; 0x30
    21f2:	4648      	mov	r0, r9
    21f4:	f017 fd74 	bl	19ce0 <TCPIP_Helper_PacketCopy>
    21f8:	9006      	str	r0, [sp, #24]
                nCopiedBytes += TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxStart, &pSegSrc, len - wTemp, true);
    21fa:	ebab 0305 	sub.w	r3, fp, r5
    21fe:	9400      	str	r4, [sp, #0]
    2200:	b29b      	uxth	r3, r3
    2202:	aa0c      	add	r2, sp, #48	; 0x30
    2204:	f8da 1014 	ldr.w	r1, [sl, #20]
    2208:	4648      	mov	r0, r9
    220a:	f017 fd69 	bl	19ce0 <TCPIP_Helper_PacketCopy>
    220e:	9b06      	ldr	r3, [sp, #24]
    2210:	4403      	add	r3, r0
    2212:	b298      	uxth	r0, r3
                newRxHead = pSkt->rxStart + (len - wTemp);
    2214:	ebab 0308 	sub.w	r3, fp, r8
    2218:	f8da 2014 	ldr.w	r2, [sl, #20]
    221c:	4413      	add	r3, r2
            if(nCopiedBytes == len)
    221e:	4558      	cmp	r0, fp
    2220:	f47f af12 	bne.w	2048 <__ext_attr_.config_00804000+0x44>
                pSkt->RemoteSEQ += (uint32_t)len;
    2224:	f8da 1050 	ldr.w	r1, [sl, #80]	; 0x50
    2228:	4459      	add	r1, fp
    222a:	f8ca 1050 	str.w	r1, [sl, #80]	; 0x50
                pSkt->rxHead = newRxHead;
    222e:	f8ca 301c 	str.w	r3, [sl, #28]
                if(pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1 || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2)
    2232:	f89a 206e 	ldrb.w	r2, [sl, #110]	; 0x6e
    2236:	3a03      	subs	r2, #3
    2238:	b2d2      	uxtb	r2, r2
    223a:	2a02      	cmp	r2, #2
    223c:	d804      	bhi.n	2248 <__ext_attr_.config_00804000+0x244>
                    *pSktEvent |= TCPIP_TCP_SIGNAL_RX_DATA;
    223e:	9a04      	ldr	r2, [sp, #16]
    2240:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    2244:	b292      	uxth	r2, r2
    2246:	9204      	str	r2, [sp, #16]
                if(pSkt->sHoleSize != -1)
    2248:	f8da 2054 	ldr.w	r2, [sl, #84]	; 0x54
    224c:	f1b2 3fff 	cmp.w	r2, #4294967295
    2250:	f43f aefa 	beq.w	2048 <__ext_attr_.config_00804000+0x44>
                    pSkt->sHoleSize -= len;
    2254:	eba2 0b0b 	sub.w	fp, r2, fp
    2258:	f8ca b054 	str.w	fp, [sl, #84]	; 0x54
                    wTemp = pSkt->wFutureDataSize + pSkt->sHoleSize;
    225c:	f8ba 2060 	ldrh.w	r2, [sl, #96]	; 0x60
                    if((int32_t)wTemp < 0)
    2260:	eb12 020b 	adds.w	r2, r2, fp
    2264:	d424      	bmi.n	22b0 <__ext_attr_.config_00804000+0x2ac>
                    else if(pSkt->sHoleSize <= 0)
    2266:	f1bb 0f00 	cmp.w	fp, #0
    226a:	f73f aeed 	bgt.w	2048 <__ext_attr_.config_00804000+0x44>
                        pSkt->RemoteSEQ += wTemp;
    226e:	4411      	add	r1, r2
    2270:	f8ca 1050 	str.w	r1, [sl, #80]	; 0x50
                        pSkt->rxHead += wTemp;
    2274:	4413      	add	r3, r2
    2276:	f8ca 301c 	str.w	r3, [sl, #28]
                        if(pSkt->rxHead > pSkt->rxEnd)
    227a:	f8da 2018 	ldr.w	r2, [sl, #24]
    227e:	4293      	cmp	r3, r2
    2280:	d906      	bls.n	2290 <__ext_attr_.config_00804000+0x28c>
                            pSkt->rxHead -= pSkt->rxEnd - pSkt->rxStart + 1;							
    2282:	f8da 1014 	ldr.w	r1, [sl, #20]
    2286:	1a52      	subs	r2, r2, r1
    2288:	43d2      	mvns	r2, r2
    228a:	4413      	add	r3, r2
    228c:	f8ca 301c 	str.w	r3, [sl, #28]
                        pSkt->sHoleSize = -1;
    2290:	f04f 33ff 	mov.w	r3, #4294967295
    2294:	f8ca 3054 	str.w	r3, [sl, #84]	; 0x54
    2298:	e6d6      	b.n	2048 <__ext_attr_.config_00804000+0x44>
                nCopiedBytes = TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxHead, &pSegSrc, len, true);
    229a:	2301      	movs	r3, #1
    229c:	9300      	str	r3, [sp, #0]
    229e:	465b      	mov	r3, fp
    22a0:	aa0c      	add	r2, sp, #48	; 0x30
    22a2:	4648      	mov	r0, r9
    22a4:	f017 fd1c 	bl	19ce0 <TCPIP_Helper_PacketCopy>
                newRxHead = pSkt->rxHead + len;
    22a8:	f8da 301c 	ldr.w	r3, [sl, #28]
    22ac:	445b      	add	r3, fp
    22ae:	e7b6      	b.n	221e <__ext_attr_.config_00804000+0x21a>
                        pSkt->sHoleSize = -1;
    22b0:	f04f 33ff 	mov.w	r3, #4294967295
    22b4:	f8ca 3054 	str.w	r3, [sl, #84]	; 0x54
    22b8:	e6c6      	b.n	2048 <__ext_attr_.config_00804000+0x44>
                    nCopiedBytes = TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxHead + wMissingBytes - (pSkt->rxEnd - pSkt->rxStart + 1), &pSegSrc, len, true);
    22ba:	1e68      	subs	r0, r5, #1
    22bc:	f8da 2014 	ldr.w	r2, [sl, #20]
    22c0:	1a9b      	subs	r3, r3, r2
    22c2:	1ac0      	subs	r0, r0, r3
    22c4:	2301      	movs	r3, #1
    22c6:	9300      	str	r3, [sp, #0]
    22c8:	9b06      	ldr	r3, [sp, #24]
    22ca:	aa0c      	add	r2, sp, #48	; 0x30
    22cc:	4401      	add	r1, r0
    22ce:	4648      	mov	r0, r9
    22d0:	f017 fd06 	bl	19ce0 <TCPIP_Helper_PacketCopy>
    22d4:	e6b4      	b.n	2040 <__ext_attr_.config_00804000+0x3c>
                nCopiedBytes = TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxHead + wMissingBytes, &pSegSrc, len, true);
    22d6:	2301      	movs	r3, #1
    22d8:	9300      	str	r3, [sp, #0]
    22da:	9b06      	ldr	r3, [sp, #24]
    22dc:	aa0c      	add	r2, sp, #48	; 0x30
    22de:	4429      	add	r1, r5
    22e0:	4648      	mov	r0, r9
    22e2:	f017 fcfd 	bl	19ce0 <TCPIP_Helper_PacketCopy>
    22e6:	e6ab      	b.n	2040 <__ext_attr_.config_00804000+0x3c>
                if(pSkt->sHoleSize == -1)
    22e8:	f8da 3054 	ldr.w	r3, [sl, #84]	; 0x54
    22ec:	f1b3 3fff 	cmp.w	r3, #4294967295
    22f0:	d013      	beq.n	231a <__ext_attr_.config_00804000+0x316>
                    if(wMissingBytes < (uint32_t)pSkt->sHoleSize)
    22f2:	429d      	cmp	r5, r3
    22f4:	d217      	bcs.n	2326 <__ext_attr_.config_00804000+0x322>
                        if((wMissingBytes + len > (uint32_t)pSkt->sHoleSize + pSkt->wFutureDataSize) || (wMissingBytes + len < (uint32_t)pSkt->sHoleSize))
    22f6:	9a06      	ldr	r2, [sp, #24]
    22f8:	1951      	adds	r1, r2, r5
    22fa:	f8ba 2060 	ldrh.w	r2, [sl, #96]	; 0x60
    22fe:	18d0      	adds	r0, r2, r3
    2300:	4281      	cmp	r1, r0
    2302:	d804      	bhi.n	230e <__ext_attr_.config_00804000+0x30a>
    2304:	428b      	cmp	r3, r1
    2306:	d802      	bhi.n	230e <__ext_attr_.config_00804000+0x30a>
                            pSkt->wFutureDataSize = (uint32_t)pSkt->sHoleSize + pSkt->wFutureDataSize - wMissingBytes;
    2308:	1b43      	subs	r3, r0, r5
    230a:	b29b      	uxth	r3, r3
    230c:	9306      	str	r3, [sp, #24]
    230e:	9b06      	ldr	r3, [sp, #24]
    2310:	f8aa 3060 	strh.w	r3, [sl, #96]	; 0x60
                        pSkt->sHoleSize = wMissingBytes;
    2314:	f8ca 5054 	str.w	r5, [sl, #84]	; 0x54
    2318:	e696      	b.n	2048 <__ext_attr_.config_00804000+0x44>
                    pSkt->sHoleSize = wMissingBytes;
    231a:	f8ca 5054 	str.w	r5, [sl, #84]	; 0x54
                    pSkt->wFutureDataSize = len;
    231e:	9b06      	ldr	r3, [sp, #24]
    2320:	f8aa 3060 	strh.w	r3, [sl, #96]	; 0x60
    2324:	e690      	b.n	2048 <__ext_attr_.config_00804000+0x44>
                    else if(wMissingBytes + len > (uint32_t)pSkt->sHoleSize + pSkt->wFutureDataSize)
    2326:	f8ba 2060 	ldrh.w	r2, [sl, #96]	; 0x60
    232a:	441a      	add	r2, r3
    232c:	9806      	ldr	r0, [sp, #24]
    232e:	1941      	adds	r1, r0, r5
    2330:	4291      	cmp	r1, r2
    2332:	f67f ae89 	bls.w	2048 <__ext_attr_.config_00804000+0x44>
                        if(wMissingBytes <= (uint32_t)pSkt->sHoleSize + pSkt->wFutureDataSize)
    2336:	4295      	cmp	r5, r2
    2338:	f63f ae86 	bhi.w	2048 <__ext_attr_.config_00804000+0x44>
                            pSkt->wFutureDataSize += wMissingBytes + len - (uint32_t)pSkt->sHoleSize - pSkt->wFutureDataSize;
    233c:	1aeb      	subs	r3, r5, r3
    233e:	4418      	add	r0, r3
    2340:	f8aa 0060 	strh.w	r0, [sl, #96]	; 0x60
    2344:	e680      	b.n	2048 <__ext_attr_.config_00804000+0x44>
            _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
    2346:	2201      	movs	r2, #1
    2348:	2110      	movs	r1, #16
    234a:	4650      	mov	r0, sl
    234c:	f005 fc6a 	bl	7c24 <_TcpSend>
    2350:	e696      	b.n	2080 <__ext_attr_.config_00804000+0x7c>
                pSkt->Flags.bDelayedACKTimerEnabled = 1;
    2352:	b2db      	uxtb	r3, r3
    2354:	f043 0308 	orr.w	r3, r3, #8
    2358:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36
                pSkt->delayedACKTime = SYS_TMR_TickCountGet() + (TCPIP_TCP_DELAYED_ACK_TIMEOUT * SYS_TMR_TickCounterFrequencyGet())/1000;
    235c:	f01d fec6 	bl	200ec <SYS_TMR_TickCountGet>
    2360:	4604      	mov	r4, r0
    2362:	f01d feeb 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
    2366:	2364      	movs	r3, #100	; 0x64
    2368:	fb03 f300 	mul.w	r3, r3, r0
    236c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    2370:	fbb3 f3f2 	udiv	r3, r3, r2
    2374:	441c      	add	r4, r3
    2376:	f8ca 402c 	str.w	r4, [sl, #44]	; 0x2c
    237a:	e681      	b.n	2080 <__ext_attr_.config_00804000+0x7c>
    pSkt->smState = newState;
    237c:	2309      	movs	r3, #9
    237e:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
                    // to explicitly close a socket that never really 
                    // got opened fully in the first place, so just 
                    // transmit a FIN automatically and jump to 
                    // TCPIP_TCP_STATE_LAST_ACK
                    _TcpSocketSetState(pSkt, TCPIP_TCP_STATE_LAST_ACK);
                    _TcpSend(pSkt, FIN | ACK, SENDTCP_RESET_TIMERS);
    2382:	2201      	movs	r2, #1
    2384:	2111      	movs	r1, #17
    2386:	4650      	mov	r0, sl
    2388:	f005 fc4c 	bl	7c24 <_TcpSend>
                    return;
    238c:	e45d      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
    pSkt->smState = newState;
    238e:	2308      	movs	r3, #8
    2390:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
                    // remote node sends a FIN, a timer is started so 
                    // that the socket will eventually be closed automatically
                    pSkt->closeWaitTime = SYS_TMR_TickCountGet() + (TCPIP_TCP_CLOSE_WAIT_TIMEOUT * SYS_TMR_TickCounterFrequencyGet())/1000;
#endif  // (TCPIP_TCP_CLOSE_WAIT_TIMEOUT != 0)

                    if(pSkt->flags.ackSent)
    2394:	f89a 306d 	ldrb.w	r3, [sl, #109]	; 0x6d
    2398:	f013 0f01 	tst.w	r3, #1
    239c:	d007      	beq.n	23ae <__ext_attr_.config_00804000+0x3aa>
    239e:	e454      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                    }

                    break;

                case TCPIP_TCP_STATE_FIN_WAIT_1:
                    if(pSkt->MySEQ == localAckNumber)
    23a0:	f8da 304c 	ldr.w	r3, [sl, #76]	; 0x4c
    23a4:	429f      	cmp	r7, r3
    23a6:	d008      	beq.n	23ba <__ext_attr_.config_00804000+0x3b6>
    pSkt->smState = newState;
    23a8:	2306      	movs	r3, #6
    23aa:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
                default:    // case TCPIP_TCP_STATE_TIME_WAIT: reacknowledge
                    break;
            }

            // Acknowledge receipt of FIN
            _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
    23ae:	2201      	movs	r2, #1
    23b0:	2110      	movs	r1, #16
    23b2:	4650      	mov	r0, sl
    23b4:	f005 fc36 	bl	7c24 <_TcpSend>
    23b8:	e447      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                        _TcpSend(pSkt, ACK, 0);
    23ba:	2200      	movs	r2, #0
    23bc:	2110      	movs	r1, #16
    23be:	4650      	mov	r0, sl
    23c0:	f005 fc30 	bl	7c24 <_TcpSend>
                        _TcpCloseSocket(pSkt, 0);
    23c4:	2100      	movs	r1, #0
    23c6:	4650      	mov	r0, sl
    23c8:	f00e fd00 	bl	10dcc <_TcpCloseSocket>
                        return;
    23cc:	e43d      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                    _TcpSend(pSkt, ACK, 0);
    23ce:	2200      	movs	r2, #0
    23d0:	2110      	movs	r1, #16
    23d2:	4650      	mov	r0, sl
    23d4:	f005 fc26 	bl	7c24 <_TcpSend>
                    _TcpCloseSocket(pSkt, 0);
    23d8:	2100      	movs	r1, #0
    23da:	4650      	mov	r0, sl
    23dc:	f00e fcf6 	bl	10dcc <_TcpCloseSocket>
                    return;
    23e0:	e433      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    23e2:	f06f 010d 	mvn.w	r1, #13
            TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
    23e6:	220a      	movs	r2, #10
    23e8:	4648      	mov	r0, r9
    23ea:	f01b fc03 	bl	1dbf4 <_TCPIP_PKT_PacketAcknowledge>
    while((pRxPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
    23ee:	200a      	movs	r0, #10
    23f0:	f01d faac 	bl	1f94c <_TCPIPStackModuleRxExtract>
    23f4:	4681      	mov	r9, r0
    23f6:	2800      	cmp	r0, #0
    23f8:	f43f aace 	beq.w	1998 <TCPIP_TCP_Task+0x18>
        uint16_t tcpTotLength = pRxPkt->totTransportLen;
    23fc:	f8b9 5020 	ldrh.w	r5, [r9, #32]
        if(tcpTotLength < sizeof(TCP_HEADER))
    2400:	2d13      	cmp	r5, #19
    2402:	d9ee      	bls.n	23e2 <__ext_attr_.config_00804000+0x3de>
        TCP_HEADER* pHdr = (TCP_HEADER*)pRxPkt->pTransportLayer;
    2404:	f8d9 801c 	ldr.w	r8, [r9, #28]
        uint8_t optionsField = pHdr->DataOffset.Val;
    2408:	f898 300c 	ldrb.w	r3, [r8, #12]
    240c:	091b      	lsrs	r3, r3, #4
        if(optionsField < TCP_DATA_OFFSET_VAL_MIN)
    240e:	2b04      	cmp	r3, #4
    2410:	d90b      	bls.n	242a <__ext_attr_.config_00804000+0x426>
        if(tcpTotLength < optionsField << 2)
    2412:	ebb5 0f83 	cmp.w	r5, r3, lsl #2
    2416:	db0b      	blt.n	2430 <__ext_attr_.config_00804000+0x42c>
            else if((pRxPkt->pktFlags & TCPIP_MAC_PKT_FLAG_NET_TYPE) == TCPIP_MAC_PKT_FLAG_IPV4) 
    2418:	f8b9 3022 	ldrh.w	r3, [r9, #34]	; 0x22
    241c:	f413 7f00 	tst.w	r3, #512	; 0x200
    2420:	f43f aac2 	beq.w	19a8 <TCPIP_TCP_Task+0x28>
        ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    2424:	f06f 010e 	mvn.w	r1, #14
    2428:	e7dd      	b.n	23e6 <__ext_attr_.config_00804000+0x3e2>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    242a:	f06f 010d 	mvn.w	r1, #13
    242e:	e7da      	b.n	23e6 <__ext_attr_.config_00804000+0x3e2>
    2430:	f06f 010d 	mvn.w	r1, #13
    2434:	e7d7      	b.n	23e6 <__ext_attr_.config_00804000+0x3e2>
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    2436:	4bbd      	ldr	r3, [pc, #756]	; (272c <__ext_attr_.config_00804000+0x728>)
    2438:	681b      	ldr	r3, [r3, #0]
    243a:	2b00      	cmp	r3, #0
    243c:	f43f aab1 	beq.w	19a2 <TCPIP_TCP_Task+0x22>
    2440:	2500      	movs	r5, #0
    2442:	462b      	mov	r3, r5
        pSkt = TCBStubs[hTCP];
    2444:	f8df 92e8 	ldr.w	r9, [pc, #744]	; 2730 <__ext_attr_.config_00804000+0x72c>
                        pSkt->retryInterval = ((TCPIP_TCP_START_TIMEOUT_VAL * SYS_TMR_TickCounterFrequencyGet())/1000) << (TCPIP_TCP_MAX_RETRIES-1);
    2448:	f8df a2e8 	ldr.w	sl, [pc, #744]	; 2734 <__ext_attr_.config_00804000+0x730>
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    244c:	f8df 82dc 	ldr.w	r8, [pc, #732]	; 272c <__ext_attr_.config_00804000+0x728>
    2450:	e0de      	b.n	2610 <__ext_attr_.config_00804000+0x60c>
                if((int32_t)(SYS_TMR_TickCountGet() - pSkt->eventTime2) >= 0)
    2452:	f01d fe4b 	bl	200ec <SYS_TMR_TickCountGet>
    2456:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2458:	1ac0      	subs	r0, r0, r3
                    vFlags = ACK;
    245a:	2800      	cmp	r0, #0
    245c:	bfa8      	it	ge
    245e:	2610      	movge	r6, #16
    2460:	e0ed      	b.n	263e <__ext_attr_.config_00804000+0x63a>
                if((int32_t)(SYS_TMR_TickCountGet() - pSkt->delayedACKTime) >= 0)
    2462:	f01d fe43 	bl	200ec <SYS_TMR_TickCountGet>
    2466:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2468:	1ac0      	subs	r0, r0, r3
    246a:	2800      	cmp	r0, #0
    246c:	f2c0 80ed 	blt.w	264a <__ext_attr_.config_00804000+0x646>
            if(pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2)
    2470:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
    2474:	2b05      	cmp	r3, #5
    2476:	f000 8199 	beq.w	27ac <__ext_attr_.config_00804000+0x7a8>
                    vFlags = ACK;
    247a:	2610      	movs	r6, #16
                _TcpSend(pSkt, vFlags, bRetransmit ? 0 : SENDTCP_RESET_TIMERS);
    247c:	f087 0201 	eor.w	r2, r7, #1
    2480:	4631      	mov	r1, r6
    2482:	4620      	mov	r0, r4
    2484:	f005 fbce 	bl	7c24 <_TcpSend>
    2488:	e0e7      	b.n	265a <__ext_attr_.config_00804000+0x656>
                if((int32_t)(SYS_TMR_TickCountGet() - pSkt->closeWaitTime) >= 0)
    248a:	f01d fe2f 	bl	200ec <SYS_TMR_TickCountGet>
    248e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    2490:	1ac0      	subs	r0, r0, r3
    2492:	2800      	cmp	r0, #0
    2494:	f2c0 80de 	blt.w	2654 <__ext_attr_.config_00804000+0x650>
                    _TcpSend(pSkt, RST | ACK, SENDTCP_RESET_TIMERS);
    2498:	2201      	movs	r2, #1
    249a:	2114      	movs	r1, #20
    249c:	4620      	mov	r0, r4
    249e:	f005 fbc1 	bl	7c24 <_TcpSend>
                    _TcpCloseSocket(pSkt, 0);
    24a2:	2100      	movs	r1, #0
    24a4:	4620      	mov	r0, r4
    24a6:	f00e fc91 	bl	10dcc <_TcpCloseSocket>
                    continue;
    24aa:	e0a9      	b.n	2600 <__ext_attr_.config_00804000+0x5fc>
                            vFlags = pSkt->Flags.bServer;
    24ac:	f894 6036 	ldrb.w	r6, [r4, #54]	; 0x36
    24b0:	f006 0601 	and.w	r6, r6, #1
                            _TcpDisconnect(pSkt, true);
    24b4:	2101      	movs	r1, #1
    24b6:	4620      	mov	r0, r4
    24b8:	f014 fe1a 	bl	170f0 <_TcpDisconnect>
                            pSkt->Flags.bServer = 1;    // force client socket non-closing
    24bc:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    24c0:	f043 0301 	orr.w	r3, r3, #1
    24c4:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
                            _TcpAbort(pSkt, _TCP_ABORT_FLAG_REGULAR, TCPIP_TCP_SIGNAL_KEEP_ALIVE_TMO);
    24c8:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    24cc:	2100      	movs	r1, #0
    24ce:	4620      	mov	r0, r4
    24d0:	f019 ffa0 	bl	1c414 <_TcpAbort>
                            if(!vFlags)
    24d4:	2e00      	cmp	r6, #0
    24d6:	f040 8093 	bne.w	2600 <__ext_attr_.config_00804000+0x5fc>
                                pSkt->Flags.bServer = 0;    // restore the client socket
    24da:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    24de:	f36f 0300 	bfc	r3, #0, #1
    24e2:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
    pSkt->smState = newState;
    24e6:	230a      	movs	r3, #10
    24e8:	f884 306e 	strb.w	r3, [r4, #110]	; 0x6e
    24ec:	e088      	b.n	2600 <__ext_attr_.config_00804000+0x5fc>
            if((int32_t)(SYS_TMR_TickCountGet() - pSkt->eventTime) < 0 )
    24ee:	f01d fdfd 	bl	200ec <SYS_TMR_TickCountGet>
    24f2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    24f4:	1ac0      	subs	r0, r0, r3
    24f6:	2800      	cmp	r0, #0
    24f8:	f2c0 8082 	blt.w	2600 <__ext_attr_.config_00804000+0x5fc>
            switch(pSkt->smState)
    24fc:	f894 106e 	ldrb.w	r1, [r4, #110]	; 0x6e
    2500:	1e4b      	subs	r3, r1, #1
    2502:	2b08      	cmp	r3, #8
    2504:	d87a      	bhi.n	25fc <__ext_attr_.config_00804000+0x5f8>
    2506:	e8df f003 	tbb	[pc, r3]
    250a:	4205      	.short	0x4205
    250c:	69796156 	.word	0x69796156
    2510:	7979      	.short	0x7979
    2512:	71          	.byte	0x71
    2513:	00          	.byte	0x00
                    if(pSkt->retryCount >= (TCPIP_TCP_MAX_RETRIES - 1))
    2514:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    2518:	2b03      	cmp	r3, #3
    251a:	d828      	bhi.n	256e <__ext_attr_.config_00804000+0x56a>
                    vFlags = SYN;
    251c:	2102      	movs	r1, #2
            bCloseSocket = false;
    251e:	2600      	movs	r6, #0
                    pSkt->retryCount++;
    2520:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    2524:	3301      	adds	r3, #1
    2526:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
                    pSkt->retryInterval <<= 1;
    252a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    252c:	005b      	lsls	r3, r3, #1
    252e:	64a3      	str	r3, [r4, #72]	; 0x48
                    w = pSkt->txUnackedTail - pSkt->txTail;
    2530:	6920      	ldr	r0, [r4, #16]
    2532:	68e2      	ldr	r2, [r4, #12]
    2534:	1a83      	subs	r3, r0, r2
    2536:	b29b      	uxth	r3, r3
                    if(pSkt->txUnackedTail < pSkt->txTail)
    2538:	4290      	cmp	r0, r2
    253a:	d204      	bcs.n	2546 <__ext_attr_.config_00804000+0x542>
                        w += pSkt->txEnd - pSkt->txStart;
    253c:	6860      	ldr	r0, [r4, #4]
    253e:	6827      	ldr	r7, [r4, #0]
    2540:	1bc0      	subs	r0, r0, r7
    2542:	4403      	add	r3, r0
    2544:	b29b      	uxth	r3, r3
                    pSkt->MySEQ -= w;
    2546:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    2548:	1ac0      	subs	r0, r0, r3
    254a:	64e0      	str	r0, [r4, #76]	; 0x4c
                    pSkt->remoteWindow += w;
    254c:	f8b4 005c 	ldrh.w	r0, [r4, #92]	; 0x5c
    2550:	4403      	add	r3, r0
    2552:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
                    pSkt->txUnackedTail = pSkt->txTail;		
    2556:	6122      	str	r2, [r4, #16]
                    _TcpSend(pSkt, vFlags, 0);
    2558:	2200      	movs	r2, #0
    255a:	4620      	mov	r0, r4
    255c:	f005 fb62 	bl	7c24 <_TcpSend>
            if(bCloseSocket)
    2560:	2e00      	cmp	r6, #0
    2562:	d04d      	beq.n	2600 <__ext_attr_.config_00804000+0x5fc>
                _TcpCloseSocket(pSkt, 0);
    2564:	2100      	movs	r1, #0
    2566:	4620      	mov	r0, r4
    2568:	f00e fc30 	bl	10dcc <_TcpCloseSocket>
    256c:	e048      	b.n	2600 <__ext_attr_.config_00804000+0x5fc>
                        pSkt->retryCount = TCPIP_TCP_MAX_RETRIES - 1;
    256e:	2304      	movs	r3, #4
    2570:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
                        pSkt->retryInterval = ((TCPIP_TCP_START_TIMEOUT_VAL * SYS_TMR_TickCounterFrequencyGet())/1000) << (TCPIP_TCP_MAX_RETRIES-1);
    2574:	f01d fde2 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
    2578:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    257c:	fb03 f300 	mul.w	r3, r3, r0
    2580:	fbaa 2303 	umull	r2, r3, sl, r3
    2584:	099b      	lsrs	r3, r3, #6
    2586:	011b      	lsls	r3, r3, #4
    2588:	64a3      	str	r3, [r4, #72]	; 0x48
                    vFlags = SYN;
    258a:	2102      	movs	r1, #2
    258c:	e7c7      	b.n	251e <__ext_attr_.config_00804000+0x51a>
                    if(pSkt->retryCount < TCPIP_TCP_MAX_SYN_RETRIES)
    258e:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    2592:	2b02      	cmp	r3, #2
    2594:	f240 80c0 	bls.w	2718 <__ext_attr_.config_00804000+0x714>
                        if(pSkt->Flags.bServer)
    2598:	f894 6036 	ldrb.w	r6, [r4, #54]	; 0x36
            bCloseSocket = false;
    259c:	f006 0301 	and.w	r3, r6, #1
    25a0:	461e      	mov	r6, r3
    25a2:	2b00      	cmp	r3, #0
    25a4:	bf18      	it	ne
    25a6:	2114      	movne	r1, #20
                if(bRetransmit)
    25a8:	2f00      	cmp	r7, #0
    25aa:	d1b9      	bne.n	2520 <__ext_attr_.config_00804000+0x51c>
                    _TcpSend(pSkt, vFlags, SENDTCP_RESET_TIMERS);
    25ac:	2201      	movs	r2, #1
    25ae:	4620      	mov	r0, r4
    25b0:	f005 fb38 	bl	7c24 <_TcpSend>
    25b4:	e7d4      	b.n	2560 <__ext_attr_.config_00804000+0x55c>
                    if(pSkt->retryCount < TCPIP_TCP_MAX_RETRIES)
    25b6:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    25ba:	2b04      	cmp	r3, #4
    25bc:	f240 80ae 	bls.w	271c <__ext_attr_.config_00804000+0x718>
    pSkt->smState = newState;
    25c0:	2304      	movs	r3, #4
    25c2:	f884 306e 	strb.w	r3, [r4, #110]	; 0x6e
                        vFlags = FIN | ACK;
    25c6:	2111      	movs	r1, #17
            bCloseSocket = false;
    25c8:	2600      	movs	r6, #0
    25ca:	e7ed      	b.n	25a8 <__ext_attr_.config_00804000+0x5a4>
                    if(pSkt->retryCount < TCPIP_TCP_MAX_RETRIES)
    25cc:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    25d0:	2b04      	cmp	r3, #4
    25d2:	f240 80a5 	bls.w	2720 <__ext_attr_.config_00804000+0x71c>
                        vFlags = RST | ACK;
    25d6:	2114      	movs	r1, #20
                        bCloseSocket = true;
    25d8:	2601      	movs	r6, #1
    25da:	e7e5      	b.n	25a8 <__ext_attr_.config_00804000+0x5a4>
                    if(pSkt->retryCount < TCPIP_TCP_MAX_RETRIES)
    25dc:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    25e0:	2b04      	cmp	r3, #4
    25e2:	f240 809f 	bls.w	2724 <__ext_attr_.config_00804000+0x720>
                        vFlags = RST | ACK;
    25e6:	2114      	movs	r1, #20
                        bCloseSocket = true;
    25e8:	2601      	movs	r6, #1
    25ea:	e7dd      	b.n	25a8 <__ext_attr_.config_00804000+0x5a4>
                    if(pSkt->retryCount < TCPIP_TCP_MAX_RETRIES)
    25ec:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    25f0:	2b04      	cmp	r3, #4
    25f2:	f240 8099 	bls.w	2728 <__ext_attr_.config_00804000+0x724>
                        vFlags = RST | ACK;
    25f6:	2114      	movs	r1, #20
                        bCloseSocket = true;
    25f8:	2601      	movs	r6, #1
    25fa:	e7d5      	b.n	25a8 <__ext_attr_.config_00804000+0x5a4>
            if(vFlags)
    25fc:	2e00      	cmp	r6, #0
    25fe:	d15c      	bne.n	26ba <__ext_attr_.config_00804000+0x6b6>
    2600:	3501      	adds	r5, #1
    2602:	b22d      	sxth	r5, r5
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    2604:	462b      	mov	r3, r5
    2606:	f8d8 2000 	ldr.w	r2, [r8]
    260a:	4295      	cmp	r5, r2
    260c:	f4bf a9c9 	bcs.w	19a2 <TCPIP_TCP_Task+0x22>
        pSkt = TCBStubs[hTCP];
    2610:	f8d9 2000 	ldr.w	r2, [r9]
    2614:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
        if(pSkt != 0 && pSkt->smState != TCPIP_TCP_STATE_CLIENT_WAIT_CONNECT)
    2618:	2c00      	cmp	r4, #0
    261a:	d0f1      	beq.n	2600 <__ext_attr_.config_00804000+0x5fc>
    261c:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
    2620:	2b0b      	cmp	r3, #11
    2622:	d0ed      	beq.n	2600 <__ext_attr_.config_00804000+0x5fc>
            if(pSkt->Flags.bTXASAP || pSkt->Flags.bTXASAPWithoutTimerReset)
    2624:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    2628:	f013 06c0 	ands.w	r6, r3, #192	; 0xc0
                bRetransmit = pSkt->Flags.bTXASAPWithoutTimerReset;
    262c:	bf1d      	ittte	ne
    262e:	461f      	movne	r7, r3
    2630:	09df      	lsrne	r7, r3, #7
                vFlags = ACK;
    2632:	2610      	movne	r6, #16
            bRetransmit = false;
    2634:	2700      	moveq	r7, #0
            if(pSkt->Flags.bTimer2Enabled)
    2636:	f013 0f04 	tst.w	r3, #4
    263a:	f47f af0a 	bne.w	2452 <__ext_attr_.config_00804000+0x44e>
            if(pSkt->Flags.bDelayedACKTimerEnabled)
    263e:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    2642:	f013 0f08 	tst.w	r3, #8
    2646:	f47f af0c 	bne.w	2462 <__ext_attr_.config_00804000+0x45e>
            if(pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2)
    264a:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
    264e:	2b05      	cmp	r3, #5
    2650:	f43f af1b 	beq.w	248a <__ext_attr_.config_00804000+0x486>
            if(vFlags)
    2654:	2e00      	cmp	r6, #0
    2656:	f47f af11 	bne.w	247c <__ext_attr_.config_00804000+0x478>
            if(!pSkt->Flags.bTimerEnabled)
    265a:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    265e:	f013 0f02 	tst.w	r3, #2
    2662:	f47f af44 	bne.w	24ee <__ext_attr_.config_00804000+0x4ea>
                if(pSkt->Flags.keepAlive)
    2666:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
    266a:	f013 0f40 	tst.w	r3, #64	; 0x40
    266e:	d0c7      	beq.n	2600 <__ext_attr_.config_00804000+0x5fc>
                    if(pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED)
    2670:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
    2674:	2b03      	cmp	r3, #3
    2676:	d1c3      	bne.n	2600 <__ext_attr_.config_00804000+0x5fc>
                        if((int32_t)(SYS_TMR_TickCountGet() - pSkt->eventTime) < 0)
    2678:	f01d fd38 	bl	200ec <SYS_TMR_TickCountGet>
    267c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    267e:	1ac0      	subs	r0, r0, r3
    2680:	2800      	cmp	r0, #0
    2682:	dbbd      	blt.n	2600 <__ext_attr_.config_00804000+0x5fc>
                        if(pSkt->keepAliveCount == pSkt->keepAliveLim)
    2684:	f894 2071 	ldrb.w	r2, [r4, #113]	; 0x71
    2688:	f894 307c 	ldrb.w	r3, [r4, #124]	; 0x7c
    268c:	429a      	cmp	r2, r3
    268e:	f43f af0d 	beq.w	24ac <__ext_attr_.config_00804000+0x4a8>
                        _TcpSend(pSkt, ACK, SENDTCP_KEEP_ALIVE);
    2692:	2202      	movs	r2, #2
    2694:	2110      	movs	r1, #16
    2696:	4620      	mov	r0, r4
    2698:	f005 fac4 	bl	7c24 <_TcpSend>
                        pSkt->eventTime = SYS_TMR_TickCountGet() + (pSkt->keepAliveTmo * SYS_TMR_TickCounterFrequencyGet())/1000;
    269c:	f01d fd26 	bl	200ec <SYS_TMR_TickCountGet>
    26a0:	4607      	mov	r7, r0
    26a2:	f8b4 6068 	ldrh.w	r6, [r4, #104]	; 0x68
    26a6:	f01d fd49 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
    26aa:	fb00 f006 	mul.w	r0, r0, r6
    26ae:	fbaa 3000 	umull	r3, r0, sl, r0
    26b2:	eb07 1090 	add.w	r0, r7, r0, lsr #6
    26b6:	6260      	str	r0, [r4, #36]	; 0x24
    26b8:	e7a2      	b.n	2600 <__ext_attr_.config_00804000+0x5fc>
            if(vFlags)
    26ba:	4631      	mov	r1, r6
            bCloseSocket = false;
    26bc:	2600      	movs	r6, #0
    26be:	e773      	b.n	25a8 <__ext_attr_.config_00804000+0x5a4>
        return TCPIP_MAC_PKT_ACK_CHKSUM_ERR;
    26c0:	f06f 0109 	mvn.w	r1, #9
    26c4:	e68f      	b.n	23e6 <__ext_attr_.config_00804000+0x3e2>
            ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    26c6:	f06f 010e 	mvn.w	r1, #14
    26ca:	e68c      	b.n	23e6 <__ext_attr_.config_00804000+0x3e2>
    26cc:	f06f 010e 	mvn.w	r1, #14
    26d0:	e689      	b.n	23e6 <__ext_attr_.config_00804000+0x3e2>
        ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    26d2:	2102      	movs	r1, #2
    26d4:	e687      	b.n	23e6 <__ext_attr_.config_00804000+0x3e2>
    26d6:	2102      	movs	r1, #2
        if(ackRes != TCPIP_MAC_PKT_ACK_NONE)
    26d8:	e685      	b.n	23e6 <__ext_attr_.config_00804000+0x3e2>
            if(localHeaderFlags & SYN)
    26da:	f014 0f02 	tst.w	r4, #2
    26de:	f43f aab4 	beq.w	1c4a <TCPIP_TCP_Task+0x2ca>
                pSkt->RemoteSEQ = localSeqNumber + 1;
    26e2:	3601      	adds	r6, #1
    26e4:	f8ca 6050 	str.w	r6, [sl, #80]	; 0x50
                pSkt->remoteWindow = pSkt->maxRemoteWindow = h->Window;
    26e8:	f8b8 300e 	ldrh.w	r3, [r8, #14]
    26ec:	f8aa 3066 	strh.w	r3, [sl, #102]	; 0x66
    26f0:	f8aa 305c 	strh.w	r3, [sl, #92]	; 0x5c
                pSkt->wRemoteMSS = _GetMaxSegSizeOption(h);
    26f4:	4640      	mov	r0, r8
    26f6:	f014 f809 	bl	1670c <_GetMaxSegSizeOption>
    26fa:	f8aa 0062 	strh.w	r0, [sl, #98]	; 0x62
                _TCPSetHalfFlushFlag(pSkt);
    26fe:	4650      	mov	r0, sl
    2700:	f01b fbd8 	bl	1deb4 <_TCPSetHalfFlushFlag>
                    _TcpSend(pSkt, SYN | ACK, SENDTCP_RESET_TIMERS);
    2704:	2201      	movs	r2, #1
    2706:	2112      	movs	r1, #18
    2708:	4650      	mov	r0, sl
    270a:	f005 fa8b 	bl	7c24 <_TcpSend>
    pSkt->smState = newState;
    270e:	2302      	movs	r3, #2
    2710:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
    2714:	f7ff ba99 	b.w	1c4a <TCPIP_TCP_Task+0x2ca>
                        vFlags = SYN | ACK;
    2718:	2112      	movs	r1, #18
    271a:	e700      	b.n	251e <__ext_attr_.config_00804000+0x51a>
                        vFlags = ACK;
    271c:	2110      	movs	r1, #16
    271e:	e6fe      	b.n	251e <__ext_attr_.config_00804000+0x51a>
                        vFlags = FIN | ACK;
    2720:	2111      	movs	r1, #17
    2722:	e6fc      	b.n	251e <__ext_attr_.config_00804000+0x51a>
                        vFlags = ACK;
    2724:	2110      	movs	r1, #16
    2726:	e6fa      	b.n	251e <__ext_attr_.config_00804000+0x51a>
                        vFlags = FIN | ACK;
    2728:	2111      	movs	r1, #17
    272a:	e6f8      	b.n	251e <__ext_attr_.config_00804000+0x51a>
    272c:	2000e390 	.word	0x2000e390
    2730:	2000e38c 	.word	0x2000e38c
    2734:	10624dd3 	.word	0x10624dd3
                pSkt->flags.bRXNoneACKed1 = 0;
    2738:	f89a 106c 	ldrb.w	r1, [sl, #108]	; 0x6c
                pSkt->flags.bRXNoneACKed2 = 0;
    273c:	f001 01ef 	and.w	r1, r1, #239	; 0xef
    2740:	f36f 1145 	bfc	r1, #5, #1
    2744:	f88a 106c 	strb.w	r1, [sl, #108]	; 0x6c
                pSkt->Flags.bHalfFullFlush = false;
    2748:	f89a 1036 	ldrb.w	r1, [sl, #54]	; 0x36
    274c:	f36f 1145 	bfc	r1, #5, #1
    2750:	f88a 1036 	strb.w	r1, [sl, #54]	; 0x36
                pSkt->txTail += dwTemp;
    2754:	9a08      	ldr	r2, [sp, #32]
    2756:	4402      	add	r2, r0
    2758:	f8ca 200c 	str.w	r2, [sl, #12]
                    if(pSkt->txUnackedTail < pSkt->txTail)
    275c:	4293      	cmp	r3, r2
    275e:	f4bf abb5 	bcs.w	1ecc <TCPIP_TCP_Task+0x54c>
                        pSkt->MySEQ += pSkt->txTail - pSkt->txUnackedTail;
    2762:	1ad3      	subs	r3, r2, r3
    2764:	9909      	ldr	r1, [sp, #36]	; 0x24
    2766:	440b      	add	r3, r1
    2768:	f8ca 304c 	str.w	r3, [sl, #76]	; 0x4c
                        pSkt->txUnackedTail = pSkt->txTail;
    276c:	f8ca 2010 	str.w	r2, [sl, #16]
                if(pSkt->txTail >= pSkt->txEnd)
    2770:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    2772:	4293      	cmp	r3, r2
    2774:	d80c      	bhi.n	2790 <__ext_attr_.config_00804000+0x78c>
                    pSkt->txTail -= pSkt->txEnd - pSkt->txStart;
    2776:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    2778:	1ad2      	subs	r2, r2, r3
    277a:	f8ca 200c 	str.w	r2, [sl, #12]
                if(pSkt->txUnackedTail >= pSkt->txEnd)
    277e:	f8da 3010 	ldr.w	r3, [sl, #16]
    2782:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    2784:	429a      	cmp	r2, r3
    2786:	d803      	bhi.n	2790 <__ext_attr_.config_00804000+0x78c>
                    pSkt->txUnackedTail -= pSkt->txEnd - pSkt->txStart;
    2788:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    278a:	1a9b      	subs	r3, r3, r2
    278c:	f8ca 3010 	str.w	r3, [sl, #16]
                if(pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT)
    2790:	f89a 306e 	ldrb.w	r3, [sl, #110]	; 0x6e
    2794:	2b03      	cmp	r3, #3
    2796:	d002      	beq.n	279e <__ext_attr_.config_00804000+0x79a>
    2798:	2b08      	cmp	r3, #8
    279a:	f47f abdd 	bne.w	1f58 <TCPIP_TCP_Task+0x5d8>
                    *pSktEvent |= TCPIP_TCP_SIGNAL_TX_SPACE; 
    279e:	9b04      	ldr	r3, [sp, #16]
    27a0:	f043 0204 	orr.w	r2, r3, #4
    27a4:	b293      	uxth	r3, r2
    27a6:	9304      	str	r3, [sp, #16]
    27a8:	f7ff bbd6 	b.w	1f58 <TCPIP_TCP_Task+0x5d8>
                if((int32_t)(SYS_TMR_TickCountGet() - pSkt->closeWaitTime) >= 0)
    27ac:	f01d fc9e 	bl	200ec <SYS_TMR_TickCountGet>
    27b0:	6b23      	ldr	r3, [r4, #48]	; 0x30
    27b2:	1ac0      	subs	r0, r0, r3
    27b4:	2800      	cmp	r0, #0
    27b6:	f6bf ae6f 	bge.w	2498 <__ext_attr_.config_00804000+0x494>
                    vFlags = ACK;
    27ba:	2610      	movs	r6, #16
    27bc:	e65e      	b.n	247c <__ext_attr_.config_00804000+0x478>
    27be:	bf00      	nop

Disassembly of section .text.TCPIP_IPERF_Task%182:

000027c0 <TCPIP_IPERF_Task>:

}
#endif  // (TCPIP_STACK_DOWN_OPERATION != 0)

void TCPIP_IPERF_Task(void)
{
    27c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    27c4:	ed2d 8b02 	vpush	{d8}
    27c8:	b09b      	sub	sp, #108	; 0x6c
    TCPIP_MODULE_SIGNAL sigPend;

    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    27ca:	210f      	movs	r1, #15
    27cc:	2020      	movs	r0, #32
    27ce:	f01b fcfd 	bl	1e1cc <_TCPIPStackModuleSignalGet>

    if(sigPend != 0)
    27d2:	2800      	cmp	r0, #0
    27d4:	f000 8688 	beq.w	34e8 <TCPIP_IPERF_Task+0xd28>
    {
		int i = 0;
		// ASYNC or RX signals occurred
	    tIperfState* pIState;	
        for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
    27d8:	4b82      	ldr	r3, [pc, #520]	; (29e4 <TCPIP_IPERF_Task+0x224>)
    27da:	681b      	ldr	r3, [r3, #0]
    27dc:	2b00      	cmp	r3, #0
    27de:	f340 8683 	ble.w	34e8 <TCPIP_IPERF_Task+0xd28>
    27e2:	4c81      	ldr	r4, [pc, #516]	; (29e8 <TCPIP_IPERF_Task+0x228>)
    27e4:	2600      	movs	r6, #0
    uint16_t chunk;
    uint16_t remainingTxData;
    uint16_t txData = 0;

    /* Fill the buffer with ASCII char U */
    memset( g_bfr, 0x55, MAX_BUFFER);
    27e6:	4f81      	ldr	r7, [pc, #516]	; (29ec <TCPIP_IPERF_Task+0x22c>)
            (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: TCP Client connection timeout\r\n");
    27e8:	f8df 8210 	ldr.w	r8, [pc, #528]	; 29fc <TCPIP_IPERF_Task+0x23c>

      /* get the remainder of the ticks using modulus */
      tmp2 = ((pIState->stopTime - pIState->startTime) % tickFreq);

      /* normalize  to uSecs */
      tmp2 =  tmp2 * 1000 / tickFreq; /* Convert to mSec */
    27ec:	ed9f 8a80 	vldr	s16, [pc, #512]	; 29f0 <TCPIP_IPERF_Task+0x230>
      }

      // never decrease pktId (e.g. if we get an out-of-order packet)
      if ( pIState->pktId == pIState->lastPktId )
      {
         (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Recv duplicated pkt\r\n");
    27f0:	f208 739c 	addw	r3, r8, #1948	; 0x79c
    27f4:	9305      	str	r3, [sp, #20]
    27f6:	e3a3      	b.n	2f40 <TCPIP_IPERF_Task+0x780>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    27f8:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    27fc:	685d      	ldr	r5, [r3, #4]
    if ( !pIState->mServerMode )
    27fe:	f894 20d1 	ldrb.w	r2, [r4, #209]	; 0xd1
    2802:	b332      	cbz	r2, 2852 <TCPIP_IPERF_Task+0x92>
    switch ( pIState->mProtocol )
    2804:	7c22      	ldrb	r2, [r4, #16]
    2806:	2a01      	cmp	r2, #1
    2808:	d045      	beq.n	2896 <TCPIP_IPERF_Task+0xd6>
    280a:	2a02      	cmp	r2, #2
    280c:	d165      	bne.n	28da <TCPIP_IPERF_Task+0x11a>
        if ( (pIState->tcpServerSock == INVALID_SOCKET) &&
    280e:	f9b4 3038 	ldrsh.w	r3, [r4, #56]	; 0x38
    2812:	f1b3 3fff 	cmp.w	r3, #4294967295
    2816:	d027      	beq.n	2868 <TCPIP_IPERF_Task+0xa8>
        TCPIP_TCP_SignalHandlerRegister(pIState->tcpServerSock, TCPIP_TCP_SIGNAL_RX_DATA, _IperfTCPRxSignalHandler, 0);
    2818:	2300      	movs	r3, #0
    281a:	4a76      	ldr	r2, [pc, #472]	; (29f4 <TCPIP_IPERF_Task+0x234>)
    281c:	f44f 7100 	mov.w	r1, #512	; 0x200
    2820:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2824:	f01a fe8e 	bl	1d544 <TCPIP_TCP_SignalHandlerRegister>
        if(!TCPIP_TCP_OptionsSet(pIState->tcpServerSock, TCP_OPTION_RX_BUFF, (void*)pIState->rxBuffSize))
    2828:	f8d4 20bc 	ldr.w	r2, [r4, #188]	; 0xbc
    282c:	2102      	movs	r1, #2
    282e:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2832:	f011 fbaa 	bl	13f8a <TCPIP_TCP_OptionsSet>
    2836:	b938      	cbnz	r0, 2848 <TCPIP_IPERF_Task+0x88>
            (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Set of RX buffer size failed\r\n");
    2838:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    283c:	681b      	ldr	r3, [r3, #0]
    283e:	681b      	ldr	r3, [r3, #0]
    2840:	f208 61ec 	addw	r1, r8, #1772	; 0x6ec
    2844:	4628      	mov	r0, r5
    2846:	4798      	blx	r3
        IperfSetState(pIState, IPERF_TCP_RX_LISTEN_STATE);
    2848:	2106      	movs	r1, #6
    284a:	4620      	mov	r0, r4
    284c:	f019 fc14 	bl	1c078 <IperfSetState>
        break;
    2850:	e36f      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Unsupported Configuration\r\n");
    2852:	681b      	ldr	r3, [r3, #0]
    2854:	681b      	ldr	r3, [r3, #0]
    2856:	f208 61a4 	addw	r1, r8, #1700	; 0x6a4
    285a:	4628      	mov	r0, r5
    285c:	4798      	blx	r3
        IperfSetState(pIState, IPERF_STANDBY_STATE);
    285e:	2101      	movs	r1, #1
    2860:	4620      	mov	r0, r4
    2862:	f019 fc09 	bl	1c078 <IperfSetState>
        return;
    2866:	e364      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
            (pIState->tcpServerSock = TCPIP_TCP_ServerOpen(IP_ADDRESS_TYPE_IPV4, pIState->mServerPort, (IP_MULTI_ADDRESS*)&pIState->localAddr)) == INVALID_SOCKET )
    2868:	f104 0280 	add.w	r2, r4, #128	; 0x80
    286c:	8a61      	ldrh	r1, [r4, #18]
    286e:	2001      	movs	r0, #1
    2870:	f014 fde6 	bl	17440 <TCPIP_TCP_ServerOpen>
    2874:	8720      	strh	r0, [r4, #56]	; 0x38
        if ( (pIState->tcpServerSock == INVALID_SOCKET) &&
    2876:	f1b0 3fff 	cmp.w	r0, #4294967295
    287a:	d1cd      	bne.n	2818 <TCPIP_IPERF_Task+0x58>
            (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Create TCP socket failed\r\n");
    287c:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2880:	681b      	ldr	r3, [r3, #0]
    2882:	681b      	ldr	r3, [r3, #0]
    2884:	f508 61d9 	add.w	r1, r8, #1736	; 0x6c8
    2888:	4628      	mov	r0, r5
    288a:	4798      	blx	r3
            IperfSetState(pIState, IPERF_STANDBY_STATE);
    288c:	2101      	movs	r1, #1
    288e:	4620      	mov	r0, r4
    2890:	f019 fbf2 	bl	1c078 <IperfSetState>
            return;
    2894:	e34d      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        if ( (pIState->udpSock = TCPIP_UDP_ServerOpen(IP_ADDRESS_TYPE_IPV4, pIState->mServerPort, (IP_MULTI_ADDRESS*)&pIState->localAddr)) == INVALID_UDP_SOCKET )
    2896:	f104 0280 	add.w	r2, r4, #128	; 0x80
    289a:	8a61      	ldrh	r1, [r4, #18]
    289c:	2001      	movs	r0, #1
    289e:	f01f fc4c 	bl	2213a <TCPIP_UDP_ServerOpen>
    28a2:	87a0      	strh	r0, [r4, #60]	; 0x3c
    28a4:	f1b0 3fff 	cmp.w	r0, #4294967295
    28a8:	d00a      	beq.n	28c0 <TCPIP_IPERF_Task+0x100>
        TCPIP_UDP_SignalHandlerRegister(pIState->udpSock, TCPIP_UDP_SIGNAL_RX_DATA, _IperfUDPRxSignalHandler, 0);
    28aa:	2300      	movs	r3, #0
    28ac:	4a52      	ldr	r2, [pc, #328]	; (29f8 <TCPIP_IPERF_Task+0x238>)
    28ae:	f44f 7180 	mov.w	r1, #256	; 0x100
    28b2:	f01a fdbe 	bl	1d432 <TCPIP_UDP_SignalHandlerRegister>
        IperfSetState(pIState, IPERF_UDP_RX_STATE);
    28b6:	2103      	movs	r1, #3
    28b8:	4620      	mov	r0, r4
    28ba:	f019 fbdd 	bl	1c078 <IperfSetState>
        break;
    28be:	e338      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
            (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Create UDP socket failed\r\n");
    28c0:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    28c4:	681b      	ldr	r3, [r3, #0]
    28c6:	681b      	ldr	r3, [r3, #0]
    28c8:	f208 7114 	addw	r1, r8, #1812	; 0x714
    28cc:	4628      	mov	r0, r5
    28ce:	4798      	blx	r3
             IperfSetState(pIState, IPERF_STANDBY_STATE);
    28d0:	2101      	movs	r1, #1
    28d2:	4620      	mov	r0, r4
    28d4:	f019 fbd0 	bl	1c078 <IperfSetState>
            return;
    28d8:	e32b      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Protocol error\r\n");
    28da:	681b      	ldr	r3, [r3, #0]
    28dc:	681b      	ldr	r3, [r3, #0]
    28de:	f508 61e7 	add.w	r1, r8, #1848	; 0x738
    28e2:	4628      	mov	r0, r5
    28e4:	4798      	blx	r3
        IperfSetState(pIState, IPERF_STANDBY_STATE);
    28e6:	2101      	movs	r1, #1
    28e8:	4620      	mov	r0, r4
    28ea:	f019 fbc5 	bl	1c078 <IperfSetState>
        return;
    28ee:	e320      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    28f0:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    28f4:	f8d3 b004 	ldr.w	fp, [r3, #4]
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: instance %d session started ...\r\n", pIState - gIperfState);
    28f8:	4b3b      	ldr	r3, [pc, #236]	; (29e8 <TCPIP_IPERF_Task+0x228>)
    28fa:	1ae3      	subs	r3, r4, r3
    28fc:	10db      	asrs	r3, r3, #3
    28fe:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
    2902:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    2906:	ebc3 2343 	rsb	r3, r3, r3, lsl #9
    290a:	eb03 4383 	add.w	r3, r3, r3, lsl #18
    290e:	f1c3 0a00 	rsb	sl, r3, #0
    2912:	e086      	b.n	2a22 <TCPIP_IPERF_Task+0x262>
          (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: UDP Get Array Failed\r\n");
    2914:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2918:	681b      	ldr	r3, [r3, #0]
    291a:	681b      	ldr	r3, [r3, #0]
    291c:	f508 61ea 	add.w	r1, r8, #1872	; 0x750
    2920:	4658      	mov	r0, fp
    2922:	4798      	blx	r3
          IperfSetState(pIState, IPERF_UDP_RX_DRAIN_STATE);
    2924:	2104      	movs	r1, #4
    2926:	4620      	mov	r0, r4
    2928:	f019 fba6 	bl	1c078 <IperfSetState>
          return;
    292c:	e301      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
          TCPIP_UDP_Discard(pIState->udpSock);
    292e:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2932:	f01d ff6a 	bl	2080a <TCPIP_UDP_Discard>
          return;
    2936:	e2fc      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
       pIState->pktCount++;
    2938:	3301      	adds	r3, #1
    293a:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      pIState->totalLen += length;
    293e:	4628      	mov	r0, r5
    2940:	f008 fd24 	bl	b38c <__aeabi_i2d>
    2944:	4602      	mov	r2, r0
    2946:	460b      	mov	r3, r1
    2948:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    294c:	f008 fbd2 	bl	b0f4 <__adddf3>
    2950:	e9c4 0108 	strd	r0, r1, [r4, #32]
      if ( pIState->pktId < 0 )
    2954:	f1b9 0f00 	cmp.w	r9, #0
    2958:	db1a      	blt.n	2990 <TCPIP_IPERF_Task+0x1d0>
      if ( pIState->pktId != pIState->lastPktId+1 )
    295a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    295c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    295e:	1c51      	adds	r1, r2, #1
    2960:	428b      	cmp	r3, r1
    2962:	d030      	beq.n	29c6 <TCPIP_IPERF_Task+0x206>
         if ( pIState->pktId < pIState->lastPktId+1 )
    2964:	4293      	cmp	r3, r2
    2966:	dc22      	bgt.n	29ae <TCPIP_IPERF_Task+0x1ee>
            pIState->outofOrder++;
    2968:	6b61      	ldr	r1, [r4, #52]	; 0x34
    296a:	f101 0101 	add.w	r1, r1, #1
    296e:	6361      	str	r1, [r4, #52]	; 0x34
      if ( pIState->pktId == pIState->lastPktId )
    2970:	d02b      	beq.n	29ca <TCPIP_IPERF_Task+0x20a>
    2972:	e022      	b.n	29ba <TCPIP_IPERF_Task+0x1fa>
             (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf: - First pkt id = %ld (should be 0)\r\n",
    2974:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2978:	681b      	ldr	r3, [r3, #0]
    297a:	685b      	ldr	r3, [r3, #4]
    297c:	f508 61ee 	add.w	r1, r8, #1904	; 0x770
    2980:	4658      	mov	r0, fp
    2982:	4798      	blx	r3
             pIState->errorCount	+= 	pIState->pktId - 1;
    2984:	6b23      	ldr	r3, [r4, #48]	; 0x30
    2986:	3b01      	subs	r3, #1
    2988:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    298a:	4413      	add	r3, r2
    298c:	6323      	str	r3, [r4, #48]	; 0x30
    298e:	e083      	b.n	2a98 <TCPIP_IPERF_Task+0x2d8>
         pIState->pktId = - pIState->pktId;
    2990:	f1c9 0300 	rsb	r3, r9, #0
    2994:	62a3      	str	r3, [r4, #40]	; 0x28
         pIState->stopTime = SYS_TMR_TickCountGet();
    2996:	f01d fba9 	bl	200ec <SYS_TMR_TickCountGet>
    299a:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
        pIState->nAttempts = 0;
    299e:	2300      	movs	r3, #0
    29a0:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
        IperfSetState(pIState, IPERF_UDP_RX_DRAIN_STATE);
    29a4:	2104      	movs	r1, #4
    29a6:	4620      	mov	r0, r4
    29a8:	f019 fb66 	bl	1c078 <IperfSetState>
    29ac:	e7d5      	b.n	295a <TCPIP_IPERF_Task+0x19a>
            pIState->errorCount += pIState->pktId - (pIState->lastPktId+1);
    29ae:	1a5b      	subs	r3, r3, r1
    29b0:	6b22      	ldr	r2, [r4, #48]	; 0x30
    29b2:	4413      	add	r3, r2
    29b4:	6323      	str	r3, [r4, #48]	; 0x30
      }

      if ( pIState->pktId > pIState->lastPktId )
    29b6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      {
         pIState->lastPktId = pIState->pktId;
    29b8:	62e3      	str	r3, [r4, #44]	; 0x2c
      }

      /* read the remaining datagram payload - the full payload */
      /* a UdpDiscard would be disingenuous, because it would not reflect the bandwidth at L7 */
      length -=  sizeof(tIperfPktInfo);
    29ba:	3d0c      	subs	r5, #12
    29bc:	b2ad      	uxth	r5, r5
      while ( length > 0 )
    29be:	b385      	cbz	r5, 2a22 <TCPIP_IPERF_Task+0x262>
         if ( length <  (uint16_t)MAX_BUFFER )
            chunk = length;
         else
            chunk = MAX_BUFFER;

         TCPIP_UDP_ArrayGet(pIState->udpSock, (uint8_t*)g_bfr, chunk);
    29c0:	f04f 0934 	mov.w	r9, #52	; 0x34
    29c4:	e025      	b.n	2a12 <TCPIP_IPERF_Task+0x252>
      if ( pIState->pktId == pIState->lastPktId )
    29c6:	4293      	cmp	r3, r2
    29c8:	d106      	bne.n	29d8 <TCPIP_IPERF_Task+0x218>
         (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Recv duplicated pkt\r\n");
    29ca:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    29ce:	681b      	ldr	r3, [r3, #0]
    29d0:	681b      	ldr	r3, [r3, #0]
    29d2:	9905      	ldr	r1, [sp, #20]
    29d4:	4658      	mov	r0, fp
    29d6:	4798      	blx	r3
      if ( pIState->pktId > pIState->lastPktId )
    29d8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    29da:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    29dc:	4293      	cmp	r3, r2
    29de:	ddec      	ble.n	29ba <TCPIP_IPERF_Task+0x1fa>
    29e0:	e7ea      	b.n	29b8 <TCPIP_IPERF_Task+0x1f8>
    29e2:	bf00      	nop
    29e4:	2000e3f0 	.word	0x2000e3f0
    29e8:	2000d9b0 	.word	0x2000d9b0
    29ec:	2000e068 	.word	0x2000e068
    29f0:	447a0000 	.word	0x447a0000
    29f4:	00021797 	.word	0x00021797
    29f8:	00021781 	.word	0x00021781
    29fc:	000057b4 	.word	0x000057b4
         TCPIP_UDP_ArrayGet(pIState->udpSock, (uint8_t*)g_bfr, chunk);
    2a00:	464a      	mov	r2, r9
    2a02:	4639      	mov	r1, r7
    2a04:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2a08:	f012 fc4e 	bl	152a8 <TCPIP_UDP_ArrayGet>
         length -= chunk;
    2a0c:	3d34      	subs	r5, #52	; 0x34
    2a0e:	b2ad      	uxth	r5, r5
      while ( length > 0 )
    2a10:	b13d      	cbz	r5, 2a22 <TCPIP_IPERF_Task+0x262>
         if ( length <  (uint16_t)MAX_BUFFER )
    2a12:	2d33      	cmp	r5, #51	; 0x33
    2a14:	d8f4      	bhi.n	2a00 <TCPIP_IPERF_Task+0x240>
         TCPIP_UDP_ArrayGet(pIState->udpSock, (uint8_t*)g_bfr, chunk);
    2a16:	462a      	mov	r2, r5
    2a18:	4639      	mov	r1, r7
    2a1a:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2a1e:	f012 fc43 	bl	152a8 <TCPIP_UDP_ArrayGet>
    while( (length = TCPIP_UDP_GetIsReady(pIState->udpSock)) >= (uint16_t)(sizeof(tIperfPktInfo)) )
    2a22:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2a26:	f01d fb25 	bl	20074 <TCPIP_UDP_GetIsReady>
    2a2a:	4605      	mov	r5, r0
    2a2c:	280b      	cmp	r0, #11
    2a2e:	f240 8082 	bls.w	2b36 <TCPIP_IPERF_Task+0x376>
       if ( TCPIP_UDP_ArrayGet(pIState->udpSock, (uint8_t*)g_bfr, sizeof(tIperfPktInfo)) != sizeof(tIperfPktInfo) )
    2a32:	220c      	movs	r2, #12
    2a34:	4639      	mov	r1, r7
    2a36:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2a3a:	f012 fc35 	bl	152a8 <TCPIP_UDP_ArrayGet>
    2a3e:	280c      	cmp	r0, #12
    2a40:	f47f af68 	bne.w	2914 <TCPIP_IPERF_Task+0x154>
       pIState->pktId = TCPIP_Helper_htonl(pPktInfo->id);
    2a44:	683b      	ldr	r3, [r7, #0]
    return (((hLong & 0x000000ff) << 24) | ((hLong & 0x0000ff00) << 8) | ((hLong & 0x00ff0000) >> 8) | ((hLong & 0xff000000) >> 24));
    2a46:	ea4f 6913 	mov.w	r9, r3, lsr #24
    2a4a:	ea49 6903 	orr.w	r9, r9, r3, lsl #24
    2a4e:	021a      	lsls	r2, r3, #8
    2a50:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
    2a54:	ea49 0902 	orr.w	r9, r9, r2
    2a58:	0a1b      	lsrs	r3, r3, #8
    2a5a:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2a5e:	ea49 0903 	orr.w	r9, r9, r3
    2a62:	f8c4 9028 	str.w	r9, [r4, #40]	; 0x28
       if ( (pIState->pktCount == (uint32_t)0) && (pIState->pktId < (long)0) )
    2a66:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    2a6a:	2b00      	cmp	r3, #0
    2a6c:	f47f af64 	bne.w	2938 <TCPIP_IPERF_Task+0x178>
    2a70:	f1b9 0f00 	cmp.w	r9, #0
    2a74:	f6ff af5b 	blt.w	292e <TCPIP_IPERF_Task+0x16e>
       pIState->pktCount++;
    2a78:	2301      	movs	r3, #1
    2a7a:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: instance %d session started ...\r\n", pIState - gIperfState);
    2a7e:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2a82:	681b      	ldr	r3, [r3, #0]
    2a84:	685b      	ldr	r3, [r3, #4]
    2a86:	4652      	mov	r2, sl
    2a88:	f208 71d4 	addw	r1, r8, #2004	; 0x7d4
    2a8c:	4658      	mov	r0, fp
    2a8e:	4798      	blx	r3
          if ( pIState->pktId != 0 )
    2a90:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    2a92:	2a00      	cmp	r2, #0
    2a94:	f47f af6e 	bne.w	2974 <TCPIP_IPERF_Task+0x1b4>
          pIState->lastPktId = pIState->pktId;
    2a98:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2a9a:	62e3      	str	r3, [r4, #44]	; 0x2c
		  TCPIP_UDP_SocketInfoGet(pIState->udpSock, &UdpSkt);
    2a9c:	a906      	add	r1, sp, #24
    2a9e:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2aa2:	f018 fc07 	bl	1b2b4 <TCPIP_UDP_SocketInfoGet>
          lclIpAddr.Val = TCPIP_STACK_NetAddress(TCPIP_UDP_SocketNetGet(pIState->udpSock));
    2aa6:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2aaa:	f01f f87f 	bl	21bac <TCPIP_UDP_SocketNetGet>
    2aae:	f01e f94c 	bl	20d4a <TCPIP_STACK_NetAddress>
          remIpAddr.Val = UdpSkt.remoteIPaddress.v4Add.Val;
    2ab2:	9d07      	ldr	r5, [sp, #28]
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Local  %u.%u.%u.%u port %u connected with\r\n",
    2ab4:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2ab8:	681b      	ldr	r3, [r3, #0]
    2aba:	8a62      	ldrh	r2, [r4, #18]
    2abc:	9202      	str	r2, [sp, #8]
    2abe:	0e02      	lsrs	r2, r0, #24
    2ac0:	9201      	str	r2, [sp, #4]
    2ac2:	f3c0 4207 	ubfx	r2, r0, #16, #8
    2ac6:	9200      	str	r2, [sp, #0]
    2ac8:	f8d3 9004 	ldr.w	r9, [r3, #4]
    2acc:	f3c0 2307 	ubfx	r3, r0, #8, #8
    2ad0:	b2c2      	uxtb	r2, r0
    2ad2:	f508 61b1 	add.w	r1, r8, #1416	; 0x588
    2ad6:	4658      	mov	r0, fp
    2ad8:	47c8      	blx	r9
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Remote %u.%u.%u.%u port %u\r\n",      
    2ada:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2ade:	681b      	ldr	r3, [r3, #0]
    2ae0:	f8bd 205c 	ldrh.w	r2, [sp, #92]	; 0x5c
    2ae4:	9202      	str	r2, [sp, #8]
    2ae6:	0e2a      	lsrs	r2, r5, #24
    2ae8:	9201      	str	r2, [sp, #4]
    2aea:	f3c5 4207 	ubfx	r2, r5, #16, #8
    2aee:	9200      	str	r2, [sp, #0]
    2af0:	f8d3 9004 	ldr.w	r9, [r3, #4]
    2af4:	f3c5 2307 	ubfx	r3, r5, #8, #8
    2af8:	b2ea      	uxtb	r2, r5
    2afa:	f208 51bc 	addw	r1, r8, #1468	; 0x5bc
    2afe:	4658      	mov	r0, fp
    2b00:	47c8      	blx	r9
          pIState->remoteSide.remoteIPaddress.v4Add.Val = remIpAddr.Val;
    2b02:	6465      	str	r5, [r4, #68]	; 0x44
          pIState->remoteSide.remotePort =  UdpSkt.remotePort;
    2b04:	f8bd 305c 	ldrh.w	r3, [sp, #92]	; 0x5c
    2b08:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
          pIState->startTime = SYS_TMR_TickCountGet();
    2b0c:	f01d faee 	bl	200ec <SYS_TMR_TickCountGet>
    2b10:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
          pIState->lastCheckTime = 	pIState->startTime;
    2b14:	f8c4 00a8 	str.w	r0, [r4, #168]	; 0xa8
          pIState->lastCheckPktId = pIState->pktId;
    2b18:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2b1a:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
          pIState->lastCheckPktCount = pIState->pktCount;
    2b1e:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    2b22:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
          pIState->lastCheckErrorCount = pIState->errorCount;
    2b26:	6b23      	ldr	r3, [r4, #48]	; 0x30
    2b28:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
          TCPIP_UDP_Discard(pIState->udpSock);
    2b2c:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2b30:	f01d fe6b 	bl	2080a <TCPIP_UDP_Discard>
          continue;
    2b34:	e775      	b.n	2a22 <TCPIP_IPERF_Task+0x262>
      }


    }  /* end got a datagram */

    if ( (pIState->pktCount != (uint32_t)0) &&
    2b36:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    2b3a:	b94b      	cbnz	r3, 2b50 <TCPIP_IPERF_Task+0x390>
        {
          ReportBW_Jitter_Loss(pIState, INTERVAL_REPORT);
        }
    }

    if ( pIState->stopRequested == true )
    2b3c:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
    2b40:	2b01      	cmp	r3, #1
    2b42:	f040 81f6 	bne.w	2f32 <TCPIP_IPERF_Task+0x772>
    {
        IperfSetState(pIState, IPERF_UDP_RX_DRAIN_STATE);
    2b46:	2104      	movs	r1, #4
    2b48:	4620      	mov	r0, r4
    2b4a:	f019 fa95 	bl	1c078 <IperfSetState>
        return;
    2b4e:	e1f0      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
         ((int32_t)(SYS_TMR_TickCountGet() - pIState->lastCheckTime) > pIState->mInterval) )
    2b50:	f01d facc 	bl	200ec <SYS_TMR_TickCountGet>
    2b54:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
    2b58:	1ac3      	subs	r3, r0, r3
    if ( (pIState->pktCount != (uint32_t)0) &&
    2b5a:	6822      	ldr	r2, [r4, #0]
    2b5c:	4293      	cmp	r3, r2
    2b5e:	d9ed      	bls.n	2b3c <TCPIP_IPERF_Task+0x37c>
        if ( pIState->pktCount == pIState->lastCheckPktCount )
    2b60:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
    2b64:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
    2b68:	429a      	cmp	r2, r3
    2b6a:	d113      	bne.n	2b94 <TCPIP_IPERF_Task+0x3d4>
          (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Rx timed out\r\n");
    2b6c:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2b70:	681b      	ldr	r3, [r3, #0]
    2b72:	681b      	ldr	r3, [r3, #0]
    2b74:	f208 71bc 	addw	r1, r8, #1980	; 0x7bc
    2b78:	4658      	mov	r0, fp
    2b7a:	4798      	blx	r3
          pIState->stopTime = SYS_TMR_TickCountGet();
    2b7c:	f01d fab6 	bl	200ec <SYS_TMR_TickCountGet>
    2b80:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
          pIState->nAttempts = 0;
    2b84:	2300      	movs	r3, #0
    2b86:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
          IperfSetState(pIState, IPERF_UDP_RX_DRAIN_STATE);
    2b8a:	2104      	movs	r1, #4
    2b8c:	4620      	mov	r0, r4
    2b8e:	f019 fa73 	bl	1c078 <IperfSetState>
    2b92:	e7d3      	b.n	2b3c <TCPIP_IPERF_Task+0x37c>
          ReportBW_Jitter_Loss(pIState, INTERVAL_REPORT);
    2b94:	2100      	movs	r1, #0
    2b96:	4620      	mov	r0, r4
    2b98:	f00a fbdc 	bl	d354 <ReportBW_Jitter_Loss>
    2b9c:	e7ce      	b.n	2b3c <TCPIP_IPERF_Task+0x37c>
    if( TCPIP_UDP_GetIsReady(pIState->udpSock) > (uint8_t)0 )
    2b9e:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2ba2:	f01d fa67 	bl	20074 <TCPIP_UDP_GetIsReady>
    2ba6:	b938      	cbnz	r0, 2bb8 <TCPIP_IPERF_Task+0x3f8>
   if ( pIState->stopRequested )
    2ba8:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
    2bac:	b14b      	cbz	r3, 2bc2 <TCPIP_IPERF_Task+0x402>
       IperfSetState(pIState, IPERF_RX_DONE_STATE);
    2bae:	2109      	movs	r1, #9
    2bb0:	4620      	mov	r0, r4
    2bb2:	f019 fa61 	bl	1c078 <IperfSetState>
    2bb6:	e1bc      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
         TCPIP_UDP_Discard(pIState->udpSock);
    2bb8:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2bbc:	f01d fe25 	bl	2080a <TCPIP_UDP_Discard>
         return;
    2bc0:	e1b7      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
       IperfSetState(pIState, IPERF_UDP_RX_DONE_STATE);
    2bc2:	2105      	movs	r1, #5
    2bc4:	4620      	mov	r0, r4
    2bc6:	f019 fa57 	bl	1c078 <IperfSetState>
    2bca:	e1b2      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    if ( pIState->statusReported == 0u )
    2bcc:	f894 30cd 	ldrb.w	r3, [r4, #205]	; 0xcd
    2bd0:	2b00      	cmp	r3, #0
    2bd2:	f000 80b5 	beq.w	2d40 <TCPIP_IPERF_Task+0x580>
    if (  TCPIP_UDP_GetIsReady(pIState->udpSock)  )
    2bd6:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2bda:	f01d fa4b 	bl	20074 <TCPIP_UDP_GetIsReady>
    2bde:	2800      	cmp	r0, #0
    2be0:	f040 80b6 	bne.w	2d50 <TCPIP_IPERF_Task+0x590>
    if ( pIState->nAttempts++ > 10u )
    2be4:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
    2be8:	1c5a      	adds	r2, r3, #1
    2bea:	f884 20cc 	strb.w	r2, [r4, #204]	; 0xcc
    2bee:	2b0a      	cmp	r3, #10
    2bf0:	f200 80b3 	bhi.w	2d5a <TCPIP_IPERF_Task+0x59a>
    if ( TCPIP_UDP_TxPutIsReady(pIState->udpSock, 128 ) > 0u )
    2bf4:	2180      	movs	r1, #128	; 0x80
    2bf6:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2bfa:	f01f fac8 	bl	2218e <TCPIP_UDP_TxPutIsReady>
    2bfe:	2800      	cmp	r0, #0
    2c00:	f000 8197 	beq.w	2f32 <TCPIP_IPERF_Task+0x772>
      pPktInfo->id = TCPIP_Helper_htonl( -pIState->lastPktId );
    2c04:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2c06:	425b      	negs	r3, r3
    2c08:	0e1a      	lsrs	r2, r3, #24
    2c0a:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    2c0e:	0219      	lsls	r1, r3, #8
    2c10:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    2c14:	430a      	orrs	r2, r1
    2c16:	0a1b      	lsrs	r3, r3, #8
    2c18:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2c1c:	4313      	orrs	r3, r2
    2c1e:	603b      	str	r3, [r7, #0]
      pPktInfo->tv_sec = 0;
    2c20:	2500      	movs	r5, #0
    2c22:	607d      	str	r5, [r7, #4]
      pPktInfo->tv_usec = 0;
    2c24:	60bd      	str	r5, [r7, #8]
      pServer_hdr->flags = TCPIP_Helper_htonl(HEADER_VERSION1);
    2c26:	2380      	movs	r3, #128	; 0x80
    2c28:	60fb      	str	r3, [r7, #12]
      pServer_hdr->total_len1 = 0;
    2c2a:	613d      	str	r5, [r7, #16]
      pServer_hdr->total_len2 = TCPIP_Helper_htonl( (uint32_t) pIState->totalLen);
    2c2c:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    2c30:	f01b f8e0 	bl	1ddf4 <__aeabi_d2uiz>
    2c34:	0e02      	lsrs	r2, r0, #24
    2c36:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    2c3a:	0203      	lsls	r3, r0, #8
    2c3c:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    2c40:	431a      	orrs	r2, r3
    2c42:	0a03      	lsrs	r3, r0, #8
    2c44:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2c48:	4313      	orrs	r3, r2
    2c4a:	617b      	str	r3, [r7, #20]
      uint32_t tickFreq = SYS_TMR_TickCounterFrequencyGet(); 
    2c4c:	f01d fa76 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
      pServer_hdr->stop_sec =  TCPIP_Helper_htonl( (uint32_t) (pIState->stopTime - pIState->startTime) / tickFreq);
    2c50:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
    2c54:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    2c58:	1ac9      	subs	r1, r1, r3
    2c5a:	fbb1 f3f0 	udiv	r3, r1, r0
    2c5e:	0e1a      	lsrs	r2, r3, #24
    2c60:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    2c64:	ea4f 2c03 	mov.w	ip, r3, lsl #8
    2c68:	f40c 0c7f 	and.w	ip, ip, #16711680	; 0xff0000
    2c6c:	ea42 020c 	orr.w	r2, r2, ip
    2c70:	ea4f 2c13 	mov.w	ip, r3, lsr #8
    2c74:	f40c 4c7f 	and.w	ip, ip, #65280	; 0xff00
    2c78:	ea42 020c 	orr.w	r2, r2, ip
    2c7c:	61ba      	str	r2, [r7, #24]
      tmp2 = ((pIState->stopTime - pIState->startTime) % tickFreq);
    2c7e:	fb00 1313 	mls	r3, r0, r3, r1
    2c82:	ee07 3a10 	vmov	s14, r3
    2c86:	eeb8 7a47 	vcvt.f32.u32	s14, s14
      tmp2 =  tmp2 * 1000 / tickFreq; /* Convert to mSec */
    2c8a:	ee27 7a08 	vmul.f32	s14, s14, s16
    2c8e:	ee07 0a90 	vmov	s15, r0
    2c92:	eef8 6a67 	vcvt.f32.u32	s13, s15
    2c96:	eec7 7a26 	vdiv.f32	s15, s14, s13
      tmp2 *= 1000;   /* 1000 uSecs per mSec */
    2c9a:	ee67 7a88 	vmul.f32	s15, s15, s16
      pServer_hdr->stop_usec = TCPIP_Helper_htonl( (uint32_t) tmp2 );
    2c9e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    2ca2:	ee17 3a90 	vmov	r3, s15
    2ca6:	0e1a      	lsrs	r2, r3, #24
    2ca8:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    2cac:	0219      	lsls	r1, r3, #8
    2cae:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    2cb2:	430a      	orrs	r2, r1
    2cb4:	0a1b      	lsrs	r3, r3, #8
    2cb6:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2cba:	4313      	orrs	r3, r2
    2cbc:	61fb      	str	r3, [r7, #28]
      pServer_hdr->error_cnt = TCPIP_Helper_htonl( (uint32_t)  pIState->errorCount);;
    2cbe:	6b23      	ldr	r3, [r4, #48]	; 0x30
    2cc0:	0e1a      	lsrs	r2, r3, #24
    2cc2:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    2cc6:	0219      	lsls	r1, r3, #8
    2cc8:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    2ccc:	430a      	orrs	r2, r1
    2cce:	0a1b      	lsrs	r3, r3, #8
    2cd0:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2cd4:	4313      	orrs	r3, r2
    2cd6:	623b      	str	r3, [r7, #32]
      pServer_hdr->outorder_cnt = TCPIP_Helper_htonl( (uint32_t) pIState->outofOrder);
    2cd8:	6b63      	ldr	r3, [r4, #52]	; 0x34
    2cda:	0e1a      	lsrs	r2, r3, #24
    2cdc:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    2ce0:	0219      	lsls	r1, r3, #8
    2ce2:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    2ce6:	430a      	orrs	r2, r1
    2ce8:	0a1b      	lsrs	r3, r3, #8
    2cea:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2cee:	4313      	orrs	r3, r2
    2cf0:	627b      	str	r3, [r7, #36]	; 0x24
      pServer_hdr->datagrams = TCPIP_Helper_htonl( (uint32_t) pIState->lastPktId);
    2cf2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2cf4:	0e1a      	lsrs	r2, r3, #24
    2cf6:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    2cfa:	0219      	lsls	r1, r3, #8
    2cfc:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    2d00:	430a      	orrs	r2, r1
    2d02:	0a1b      	lsrs	r3, r3, #8
    2d04:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2d08:	4313      	orrs	r3, r2
    2d0a:	62bb      	str	r3, [r7, #40]	; 0x28
      pServer_hdr->jitter1 = 0;
    2d0c:	62fd      	str	r5, [r7, #44]	; 0x2c
      pServer_hdr->jitter2 = 0;
    2d0e:	633d      	str	r5, [r7, #48]	; 0x30
      TCPIP_UDP_ArrayPut(pIState->udpSock, (uint8_t*)g_bfr, MAX_BUFFER);
    2d10:	2234      	movs	r2, #52	; 0x34
    2d12:	4639      	mov	r1, r7
    2d14:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2d18:	f019 ff9f 	bl	1cc5a <TCPIP_UDP_ArrayPut>
      memset(tmpBuffer, 0, sizeof(tmpBuffer));
    2d1c:	f04f 094c 	mov.w	r9, #76	; 0x4c
    2d20:	464a      	mov	r2, r9
    2d22:	4629      	mov	r1, r5
    2d24:	a806      	add	r0, sp, #24
    2d26:	f01e ffb1 	bl	21c8c <memset>
      TCPIP_UDP_ArrayPut(pIState->udpSock, tmpBuffer, sizeof(tmpBuffer));
    2d2a:	464a      	mov	r2, r9
    2d2c:	a906      	add	r1, sp, #24
    2d2e:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2d32:	f019 ff92 	bl	1cc5a <TCPIP_UDP_ArrayPut>
      TCPIP_UDP_Flush(pIState->udpSock );
    2d36:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2d3a:	f00b f9d5 	bl	e0e8 <TCPIP_UDP_Flush>
    2d3e:	e0f8      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        ReportBW_Jitter_Loss(pIState, SESSION_REPORT);
    2d40:	2102      	movs	r1, #2
    2d42:	4620      	mov	r0, r4
    2d44:	f00a fb06 	bl	d354 <ReportBW_Jitter_Loss>
        pIState->statusReported = 1;
    2d48:	2301      	movs	r3, #1
    2d4a:	f884 30cd 	strb.w	r3, [r4, #205]	; 0xcd
    2d4e:	e742      	b.n	2bd6 <TCPIP_IPERF_Task+0x416>
        TCPIP_UDP_Discard(pIState->udpSock);
    2d50:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2d54:	f01d fd59 	bl	2080a <TCPIP_UDP_Discard>
        return;
    2d58:	e0eb      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        IperfSetState(pIState, IPERF_RX_DONE_STATE);
    2d5a:	2109      	movs	r1, #9
    2d5c:	4620      	mov	r0, r4
    2d5e:	f019 f98b 	bl	1c078 <IperfSetState>
        return;
    2d62:	e0e6      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
   if ( pIState->stopRequested == true )
    2d64:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
    2d68:	2b01      	cmp	r3, #1
    2d6a:	d024      	beq.n	2db6 <TCPIP_IPERF_Task+0x5f6>
   if( TCPIP_TCP_IsConnected(pIState->tcpServerSock) )
    2d6c:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2d70:	f01d fa84 	bl	2027c <TCPIP_TCP_IsConnected>
    2d74:	2800      	cmp	r0, #0
    2d76:	f000 80dc 	beq.w	2f32 <TCPIP_IPERF_Task+0x772>
	  TCPIP_TCP_SocketInfoGet( pIState->tcpServerSock, &tcpSocketInfo);
    2d7a:	a906      	add	r1, sp, #24
    2d7c:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2d80:	f016 fe44 	bl	19a0c <TCPIP_TCP_SocketInfoGet>
      memcpy ( (void *) &pIState->remoteSide, &tcpSocketInfo, sizeof ( TCP_SOCKET_INFO) );
    2d84:	f104 0c40 	add.w	ip, r4, #64	; 0x40
    2d88:	ad06      	add	r5, sp, #24
    2d8a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2d8c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2d90:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2d92:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2d96:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2d98:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2d9c:	e895 0003 	ldmia.w	r5, {r0, r1}
    2da0:	e88c 0003 	stmia.w	ip, {r0, r1}
      IperfSetState(pIState, IPERF_TCP_RX_STATE);
    2da4:	2107      	movs	r1, #7
    2da6:	4620      	mov	r0, r4
    2da8:	f019 f966 	bl	1c078 <IperfSetState>
      TCPIP_TCP_WasReset(pIState->tcpServerSock);
    2dac:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2db0:	f01c ff2b 	bl	1fc0a <TCPIP_TCP_WasReset>
    2db4:	e0bd      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        IperfSetState(pIState, IPERF_RX_DONE_STATE);
    2db6:	2109      	movs	r1, #9
    2db8:	4620      	mov	r0, r4
    2dba:	f019 f95d 	bl	1c078 <IperfSetState>
        return;
    2dbe:	e0b8      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    2dc0:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2dc4:	f8d3 9004 	ldr.w	r9, [r3, #4]
    if( (length = TCPIP_TCP_GetIsReady(pIState->tcpServerSock)) == 0 )
    2dc8:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2dcc:	f01e fe43 	bl	21a56 <TCPIP_TCP_GetIsReady>
    2dd0:	4605      	mov	r5, r0
    2dd2:	2800      	cmp	r0, #0
    2dd4:	d066      	beq.n	2ea4 <TCPIP_IPERF_Task+0x6e4>
       if ( pIState->pktId == 0)
    2dd6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2dd8:	2b00      	cmp	r3, #0
    2dda:	d14c      	bne.n	2e76 <TCPIP_IPERF_Task+0x6b6>
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: instance %d session started ...\r\n", pIState - gIperfState);
    2ddc:	4bc7      	ldr	r3, [pc, #796]	; (30fc <TCPIP_IPERF_Task+0x93c>)
    2dde:	1ae3      	subs	r3, r4, r3
    2de0:	10db      	asrs	r3, r3, #3
    2de2:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
    2de6:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    2dea:	ebc3 2343 	rsb	r3, r3, r3, lsl #9
    2dee:	eb03 4383 	add.w	r3, r3, r3, lsl #18
    2df2:	f8d4 20c4 	ldr.w	r2, [r4, #196]	; 0xc4
    2df6:	6812      	ldr	r2, [r2, #0]
    2df8:	f8d2 a004 	ldr.w	sl, [r2, #4]
    2dfc:	425a      	negs	r2, r3
    2dfe:	f208 71d4 	addw	r1, r8, #2004	; 0x7d4
    2e02:	4648      	mov	r0, r9
    2e04:	47d0      	blx	sl
          pIState->startTime = SYS_TMR_TickCountGet();
    2e06:	f01d f971 	bl	200ec <SYS_TMR_TickCountGet>
    2e0a:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
          pIState->lastCheckTime = 	pIState->startTime;
    2e0e:	f8c4 00a8 	str.w	r0, [r4, #168]	; 0xa8
          pIState->lastCheckPktId = pIState->pktId;
    2e12:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2e14:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
          lclAddress.Val = TCPIP_STACK_NetAddress(TCPIP_TCP_SocketNetGet(pIState->tcpServerSock));
    2e18:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2e1c:	f01e fe9e 	bl	21b5c <TCPIP_TCP_SocketNetGet>
    2e20:	f01d ff93 	bl	20d4a <TCPIP_STACK_NetAddress>
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Local  %u.%u.%u.%u port %u connected with\r\n",
    2e24:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2e28:	681b      	ldr	r3, [r3, #0]
    2e2a:	8a62      	ldrh	r2, [r4, #18]
    2e2c:	9202      	str	r2, [sp, #8]
    2e2e:	0e02      	lsrs	r2, r0, #24
    2e30:	9201      	str	r2, [sp, #4]
    2e32:	f3c0 4207 	ubfx	r2, r0, #16, #8
    2e36:	9200      	str	r2, [sp, #0]
    2e38:	f8d3 a004 	ldr.w	sl, [r3, #4]
    2e3c:	f3c0 2307 	ubfx	r3, r0, #8, #8
    2e40:	b2c2      	uxtb	r2, r0
    2e42:	f508 61b1 	add.w	r1, r8, #1416	; 0x588
    2e46:	4648      	mov	r0, r9
    2e48:	47d0      	blx	sl
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Remote %u.%u.%u.%u port %u\r\n",
    2e4a:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2e4e:	681b      	ldr	r3, [r3, #0]
    2e50:	f8b4 2064 	ldrh.w	r2, [r4, #100]	; 0x64
    2e54:	9202      	str	r2, [sp, #8]
    2e56:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
    2e5a:	9201      	str	r2, [sp, #4]
    2e5c:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
    2e60:	9200      	str	r2, [sp, #0]
    2e62:	f8d3 a004 	ldr.w	sl, [r3, #4]
    2e66:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    2e6a:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
    2e6e:	f208 51bc 	addw	r1, r8, #1468	; 0x5bc
    2e72:	4648      	mov	r0, r9
    2e74:	47d0      	blx	sl
       pIState->pktId++;
    2e76:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2e78:	3301      	adds	r3, #1
    2e7a:	62a3      	str	r3, [r4, #40]	; 0x28
       pIState->pktCount++;
    2e7c:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
    2e80:	3201      	adds	r2, #1
    2e82:	f8c4 2094 	str.w	r2, [r4, #148]	; 0x94
       pIState->lastPktId = pIState->pktId;
    2e86:	62e3      	str	r3, [r4, #44]	; 0x2c
       pIState->totalLen += length;
    2e88:	4628      	mov	r0, r5
    2e8a:	f008 fa7f 	bl	b38c <__aeabi_i2d>
    2e8e:	4602      	mov	r2, r0
    2e90:	460b      	mov	r3, r1
    2e92:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    2e96:	f008 f92d 	bl	b0f4 <__adddf3>
    2e9a:	e9c4 0108 	strd	r0, r1, [r4, #32]
          TCPIP_TCP_ArrayGet( pIState->tcpServerSock, (uint8_t*)g_bfr, chunk);
    2e9e:	f04f 0934 	mov.w	r9, #52	; 0x34
    2ea2:	e01b      	b.n	2edc <TCPIP_IPERF_Task+0x71c>
      if ( TCPIP_TCP_WasReset(pIState->tcpServerSock) || TCPIP_TCP_WasDisconnected(pIState->tcpServerSock)  )
    2ea4:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2ea8:	f01c feaf 	bl	1fc0a <TCPIP_TCP_WasReset>
    2eac:	b920      	cbnz	r0, 2eb8 <TCPIP_IPERF_Task+0x6f8>
    2eae:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2eb2:	f01e fc5a 	bl	2176a <TCPIP_TCP_WasDisconnected>
    2eb6:	b1c8      	cbz	r0, 2eec <TCPIP_IPERF_Task+0x72c>
          pIState->stopTime = SYS_TMR_TickCountGet();
    2eb8:	f01d f918 	bl	200ec <SYS_TMR_TickCountGet>
    2ebc:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
          IperfSetState(pIState, IPERF_TCP_RX_DONE_STATE);
    2ec0:	2108      	movs	r1, #8
    2ec2:	4620      	mov	r0, r4
    2ec4:	f019 f8d8 	bl	1c078 <IperfSetState>
          return;
    2ec8:	e033      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
          TCPIP_TCP_ArrayGet( pIState->tcpServerSock, (uint8_t*)g_bfr, chunk);
    2eca:	464a      	mov	r2, r9
    2ecc:	4639      	mov	r1, r7
    2ece:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2ed2:	f012 fd41 	bl	15958 <TCPIP_TCP_ArrayGet>
          length -= chunk;
    2ed6:	3d34      	subs	r5, #52	; 0x34
    2ed8:	b2ad      	uxth	r5, r5
       while ( length > 0 )
    2eda:	b13d      	cbz	r5, 2eec <TCPIP_IPERF_Task+0x72c>
          if ( length <  (uint16_t)MAX_BUFFER )
    2edc:	2d33      	cmp	r5, #51	; 0x33
    2ede:	d8f4      	bhi.n	2eca <TCPIP_IPERF_Task+0x70a>
          TCPIP_TCP_ArrayGet( pIState->tcpServerSock, (uint8_t*)g_bfr, chunk);
    2ee0:	462a      	mov	r2, r5
    2ee2:	4639      	mov	r1, r7
    2ee4:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2ee8:	f012 fd36 	bl	15958 <TCPIP_TCP_ArrayGet>
    if ((pIState->pktId != (long)0) &&
    2eec:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2eee:	b963      	cbnz	r3, 2f0a <TCPIP_IPERF_Task+0x74a>
    if ( pIState->stopRequested == true )
    2ef0:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
    2ef4:	2b01      	cmp	r3, #1
    2ef6:	d11c      	bne.n	2f32 <TCPIP_IPERF_Task+0x772>
       IperfSetState(pIState, IPERF_TCP_RX_DONE_STATE);
    2ef8:	2108      	movs	r1, #8
    2efa:	4620      	mov	r0, r4
    2efc:	f019 f8bc 	bl	1c078 <IperfSetState>
       pIState->stopTime = SYS_TMR_TickCountGet();
    2f00:	f01d f8f4 	bl	200ec <SYS_TMR_TickCountGet>
    2f04:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
       return;
    2f08:	e013      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
       ((int32_t)(SYS_TMR_TickCountGet() - pIState->lastCheckTime) > pIState->mInterval) )
    2f0a:	f01d f8ef 	bl	200ec <SYS_TMR_TickCountGet>
    2f0e:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
    2f12:	1ac3      	subs	r3, r0, r3
    if ((pIState->pktId != (long)0) &&
    2f14:	6822      	ldr	r2, [r4, #0]
    2f16:	4293      	cmp	r3, r2
    2f18:	d9ea      	bls.n	2ef0 <TCPIP_IPERF_Task+0x730>
         ReportBW_Jitter_Loss(pIState, INTERVAL_REPORT);
    2f1a:	2100      	movs	r1, #0
    2f1c:	4620      	mov	r0, r4
    2f1e:	f00a fa19 	bl	d354 <ReportBW_Jitter_Loss>
    2f22:	e7e5      	b.n	2ef0 <TCPIP_IPERF_Task+0x730>
    if ( pIState->statusReported == 0u )
    2f24:	f894 30cd 	ldrb.w	r3, [r4, #205]	; 0xcd
    2f28:	b3c3      	cbz	r3, 2f9c <TCPIP_IPERF_Task+0x7dc>
    IperfSetState(pIState, IPERF_RX_DONE_STATE);
    2f2a:	2109      	movs	r1, #9
    2f2c:	4620      	mov	r0, r4
    2f2e:	f019 f8a3 	bl	1c078 <IperfSetState>
        for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
    2f32:	3601      	adds	r6, #1
    2f34:	34d8      	adds	r4, #216	; 0xd8
    2f36:	4b72      	ldr	r3, [pc, #456]	; (3100 <TCPIP_IPERF_Task+0x940>)
    2f38:	681b      	ldr	r3, [r3, #0]
    2f3a:	42b3      	cmp	r3, r6
    2f3c:	f340 82d4 	ble.w	34e8 <TCPIP_IPERF_Task+0xd28>
	if (pIState->state == IPERF_STANDBY_STATE)
    2f40:	f894 30ce 	ldrb.w	r3, [r4, #206]	; 0xce
    2f44:	2b01      	cmp	r3, #1
    2f46:	d0f4      	beq.n	2f32 <TCPIP_IPERF_Task+0x772>
    switch ( pIState->state )
    2f48:	3b02      	subs	r3, #2
    2f4a:	2b10      	cmp	r3, #16
    2f4c:	f200 82b1 	bhi.w	34b2 <TCPIP_IPERF_Task+0xcf2>
    2f50:	a201      	add	r2, pc, #4	; (adr r2, 2f58 <TCPIP_IPERF_Task+0x798>)
    2f52:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    2f56:	bf00      	nop
    2f58:	000027f9 	.word	0x000027f9
    2f5c:	000028f1 	.word	0x000028f1
    2f60:	00002b9f 	.word	0x00002b9f
    2f64:	00002bcd 	.word	0x00002bcd
    2f68:	00002d65 	.word	0x00002d65
    2f6c:	00002dc1 	.word	0x00002dc1
    2f70:	00002f25 	.word	0x00002f25
    2f74:	00002fad 	.word	0x00002fad
    2f78:	00003051 	.word	0x00003051
    2f7c:	0000306f 	.word	0x0000306f
    2f80:	00003233 	.word	0x00003233
    2f84:	00003317 	.word	0x00003317
    2f88:	0000339f 	.word	0x0000339f
    2f8c:	0000348d 	.word	0x0000348d
    2f90:	00003143 	.word	0x00003143
    2f94:	000033ff 	.word	0x000033ff
    2f98:	000034a3 	.word	0x000034a3
        ReportBW_Jitter_Loss(pIState, SESSION_REPORT);
    2f9c:	2102      	movs	r1, #2
    2f9e:	4620      	mov	r0, r4
    2fa0:	f00a f9d8 	bl	d354 <ReportBW_Jitter_Loss>
        pIState->statusReported = 1;
    2fa4:	2301      	movs	r3, #1
    2fa6:	f884 30cd 	strb.w	r3, [r4, #205]	; 0xcd
    2faa:	e7be      	b.n	2f2a <TCPIP_IPERF_Task+0x76a>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    2fac:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2fb0:	685d      	ldr	r5, [r3, #4]
   switch( pIState->mProtocol)
    2fb2:	7c23      	ldrb	r3, [r4, #16]
    2fb4:	2b01      	cmp	r3, #1
    2fb6:	d02c      	beq.n	3012 <TCPIP_IPERF_Task+0x852>
    2fb8:	2b02      	cmp	r3, #2
    2fba:	d02f      	beq.n	301c <TCPIP_IPERF_Task+0x85c>
    (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf instance %d: Rx done. Socket closed.\r\n", pIState - gIperfState);
    2fbc:	4b4f      	ldr	r3, [pc, #316]	; (30fc <TCPIP_IPERF_Task+0x93c>)
    2fbe:	1ae3      	subs	r3, r4, r3
    2fc0:	10db      	asrs	r3, r3, #3
    2fc2:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
    2fc6:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    2fca:	ebc3 2343 	rsb	r3, r3, r3, lsl #9
    2fce:	eb03 4383 	add.w	r3, r3, r3, lsl #18
    2fd2:	f1c3 0900 	rsb	r9, r3, #0
    2fd6:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2fda:	681b      	ldr	r3, [r3, #0]
    2fdc:	685b      	ldr	r3, [r3, #4]
    2fde:	464a      	mov	r2, r9
    2fe0:	f508 6100 	add.w	r1, r8, #2048	; 0x800
    2fe4:	4628      	mov	r0, r5
    2fe6:	4798      	blx	r3
    ResetIperfCounters(pIState);
    2fe8:	4620      	mov	r0, r4
    2fea:	f019 fd07 	bl	1c9fc <ResetIperfCounters>
    if ((pIState->mServerMode == true) 	&&
    2fee:	f894 30d1 	ldrb.w	r3, [r4, #209]	; 0xd1
    2ff2:	2b01      	cmp	r3, #1
    2ff4:	d01a      	beq.n	302c <TCPIP_IPERF_Task+0x86c>
        (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf instance %d: completed.\r\n", pIState - gIperfState);
    2ff6:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2ffa:	681b      	ldr	r3, [r3, #0]
    2ffc:	685b      	ldr	r3, [r3, #4]
    2ffe:	464a      	mov	r2, r9
    3000:	f608 0164 	addw	r1, r8, #2148	; 0x864
    3004:	4628      	mov	r0, r5
    3006:	4798      	blx	r3
        IperfSetState(pIState, IPERF_STANDBY_STATE);
    3008:	2101      	movs	r1, #1
    300a:	4620      	mov	r0, r4
    300c:	f019 f834 	bl	1c078 <IperfSetState>
    3010:	e78f      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
           TCPIP_UDP_Close(  pIState->udpSock );
    3012:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    3016:	f01c f987 	bl	1f328 <TCPIP_UDP_Close>
           break;
    301a:	e7cf      	b.n	2fbc <TCPIP_IPERF_Task+0x7fc>
           TCPIP_TCP_Close( pIState->tcpServerSock );
    301c:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    3020:	f01b f85b 	bl	1e0da <TCPIP_TCP_Close>
           pIState->tcpServerSock = INVALID_SOCKET;
    3024:	f64f 73ff 	movw	r3, #65535	; 0xffff
    3028:	8723      	strh	r3, [r4, #56]	; 0x38
           break;
    302a:	e7c7      	b.n	2fbc <TCPIP_IPERF_Task+0x7fc>
    if ((pIState->mServerMode == true) 	&&
    302c:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
    3030:	2b00      	cmp	r3, #0
    3032:	d1e0      	bne.n	2ff6 <TCPIP_IPERF_Task+0x836>
        (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf instance %d: Ready for the next session.\r\n", pIState - gIperfState);
    3034:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    3038:	681b      	ldr	r3, [r3, #0]
    303a:	685b      	ldr	r3, [r3, #4]
    303c:	464a      	mov	r2, r9
    303e:	f508 6103 	add.w	r1, r8, #2096	; 0x830
    3042:	4628      	mov	r0, r5
    3044:	4798      	blx	r3
        IperfSetState(pIState, IPERF_RX_START_STATE);
    3046:	2102      	movs	r1, #2
    3048:	4620      	mov	r0, r4
    304a:	f019 f815 	bl	1c078 <IperfSetState>
    304e:	e770      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
   TCPIP_ARP_Resolve(pIState->pNetIf, &pIState->remoteSide.remoteIPaddress.v4Add);
    3050:	f104 0144 	add.w	r1, r4, #68	; 0x44
    3054:	f8d4 00c8 	ldr.w	r0, [r4, #200]	; 0xc8
    3058:	f01a f95f 	bl	1d31a <TCPIP_ARP_Resolve>
   IperfSetState(pIState, IPERF_TX_ARP_RESOLVE_STATE);
    305c:	210b      	movs	r1, #11
    305e:	4620      	mov	r0, r4
    3060:	f019 f80a 	bl	1c078 <IperfSetState>
   pIState->timer = SYS_TMR_TickCountGet();
    3064:	f01d f842 	bl	200ec <SYS_TMR_TickCountGet>
    3068:	f8c4 00ac 	str.w	r0, [r4, #172]	; 0xac
    306c:	e761      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    306e:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    3072:	685d      	ldr	r5, [r3, #4]
  if ( pIState->stopRequested == true )
    3074:	f894 20cf 	ldrb.w	r2, [r4, #207]	; 0xcf
    3078:	2a01      	cmp	r2, #1
    307a:	d011      	beq.n	30a0 <TCPIP_IPERF_Task+0x8e0>
  if(!(TCPIP_Helper_IsMcastAddress(&pIState->remoteSide.remoteIPaddress.v4Add)))
    307c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    3080:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    3084:	2be0      	cmp	r3, #224	; 0xe0
    3086:	d116      	bne.n	30b6 <TCPIP_IPERF_Task+0x8f6>
  if ( pIState->mProtocol == UDP_PROTOCOL )
    3088:	7c23      	ldrb	r3, [r4, #16]
    308a:	2b01      	cmp	r3, #1
    308c:	d054      	beq.n	3138 <TCPIP_IPERF_Task+0x978>
  if ( pIState->mProtocol == TCP_PROTOCOL )
    308e:	7c23      	ldrb	r3, [r4, #16]
    3090:	2b02      	cmp	r3, #2
    3092:	f47f af4e 	bne.w	2f32 <TCPIP_IPERF_Task+0x772>
     IperfSetState(pIState, IPERF_TCP_TX_OPEN_STATE);
    3096:	210c      	movs	r1, #12
    3098:	4620      	mov	r0, r4
    309a:	f018 ffed 	bl	1c078 <IperfSetState>
    309e:	e748      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
     (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: client session closed.\r\n");
    30a0:	681b      	ldr	r3, [r3, #0]
    30a2:	681b      	ldr	r3, [r3, #0]
    30a4:	f608 0184 	addw	r1, r8, #2180	; 0x884
    30a8:	4628      	mov	r0, r5
    30aa:	4798      	blx	r3
     IperfSetState(pIState, IPERF_STANDBY_STATE);
    30ac:	2101      	movs	r1, #1
    30ae:	4620      	mov	r0, r4
    30b0:	f018 ffe2 	bl	1c078 <IperfSetState>
     return;
    30b4:	e73d      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    if(!TCPIP_ARP_IsResolved(pIState->pNetIf, &pIState->remoteSide.remoteIPaddress.v4Add, &pIState->remoteMACAddr))
    30b6:	f104 0278 	add.w	r2, r4, #120	; 0x78
    30ba:	f104 0144 	add.w	r1, r4, #68	; 0x44
    30be:	f8d4 00c8 	ldr.w	r0, [r4, #200]	; 0xc8
    30c2:	f015 fa6f 	bl	185a4 <TCPIP_ARP_IsResolved>
    30c6:	b1e8      	cbz	r0, 3104 <TCPIP_IPERF_Task+0x944>
    (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - RemoteNode MAC: %x %x %x %x %x %x\r\n",
    30c8:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    30cc:	681b      	ldr	r3, [r3, #0]
    30ce:	f894 207d 	ldrb.w	r2, [r4, #125]	; 0x7d
    30d2:	9203      	str	r2, [sp, #12]
    30d4:	f894 207c 	ldrb.w	r2, [r4, #124]	; 0x7c
    30d8:	9202      	str	r2, [sp, #8]
    30da:	f894 207b 	ldrb.w	r2, [r4, #123]	; 0x7b
    30de:	9201      	str	r2, [sp, #4]
    30e0:	f894 207a 	ldrb.w	r2, [r4, #122]	; 0x7a
    30e4:	9200      	str	r2, [sp, #0]
    30e6:	f8d3 9004 	ldr.w	r9, [r3, #4]
    30ea:	f894 3079 	ldrb.w	r3, [r4, #121]	; 0x79
    30ee:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
    30f2:	f608 01e4 	addw	r1, r8, #2276	; 0x8e4
    30f6:	4628      	mov	r0, r5
    30f8:	47c8      	blx	r9
    30fa:	e7c5      	b.n	3088 <TCPIP_IPERF_Task+0x8c8>
    30fc:	2000d9b0 	.word	0x2000d9b0
    3100:	2000e3f0 	.word	0x2000e3f0
        if( SYS_TMR_TickCountGet() - pIState->timer > 5 * SYS_TMR_TickCounterFrequencyGet() )
    3104:	f01c fff2 	bl	200ec <SYS_TMR_TickCountGet>
    3108:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
    310c:	eba0 0903 	sub.w	r9, r0, r3
    3110:	f01d f814 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
    3114:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    3118:	4581      	cmp	r9, r0
    311a:	f67f af0a 	bls.w	2f32 <TCPIP_IPERF_Task+0x772>
            (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: ARP unable to resolve the MAC address of remote side.\r\n");
    311e:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    3122:	681b      	ldr	r3, [r3, #0]
    3124:	681b      	ldr	r3, [r3, #0]
    3126:	f608 01a4 	addw	r1, r8, #2212	; 0x8a4
    312a:	4628      	mov	r0, r5
    312c:	4798      	blx	r3
            pIState->timer = SYS_TMR_TickCountGet();
    312e:	f01c ffdd 	bl	200ec <SYS_TMR_TickCountGet>
    3132:	f8c4 00ac 	str.w	r0, [r4, #172]	; 0xac
    3136:	e6fc      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
     IperfSetState(pIState, IPERF_UDP_TX_OPEN_STATE);
    3138:	2110      	movs	r1, #16
    313a:	4620      	mov	r0, r4
    313c:	f018 ff9c 	bl	1c078 <IperfSetState>
    3140:	e7a5      	b.n	308e <TCPIP_IPERF_Task+0x8ce>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    3142:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    3146:	685d      	ldr	r5, [r3, #4]
    if ( (pIState->udpSock = TCPIP_UDP_ClientOpen(IP_ADDRESS_TYPE_IPV4, pIState->mServerPort, (IP_MULTI_ADDRESS*)&pIState->remoteSide.remoteIPaddress.v4Add)) == INVALID_UDP_SOCKET )
    3148:	f104 0244 	add.w	r2, r4, #68	; 0x44
    314c:	8a61      	ldrh	r1, [r4, #18]
    314e:	2001      	movs	r0, #1
    3150:	f01e fff8 	bl	22144 <TCPIP_UDP_ClientOpen>
    3154:	87a0      	strh	r0, [r4, #60]	; 0x3c
    3156:	f1b0 3fff 	cmp.w	r0, #4294967295
    315a:	d05d      	beq.n	3218 <TCPIP_IPERF_Task+0xa58>
    TCPIP_UDP_SignalHandlerRegister(pIState->udpSock, TCPIP_UDP_SIGNAL_RX_DATA, _IperfUDPRxSignalHandler, 0);
    315c:	2300      	movs	r3, #0
    315e:	4ac9      	ldr	r2, [pc, #804]	; (3484 <TCPIP_IPERF_Task+0xcc4>)
    3160:	f44f 7180 	mov.w	r1, #256	; 0x100
    3164:	f01a f965 	bl	1d432 <TCPIP_UDP_SignalHandlerRegister>
    if(!TCPIP_UDP_OptionsSet(pIState->udpSock, UDP_OPTION_TX_BUFF, (void*)pIState->mDatagramSize))
    3168:	68e2      	ldr	r2, [r4, #12]
    316a:	2105      	movs	r1, #5
    316c:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    3170:	f00b fbde 	bl	e930 <TCPIP_UDP_OptionsSet>
    3174:	b938      	cbnz	r0, 3186 <TCPIP_IPERF_Task+0x9c6>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Set of TX buffer size failed\r\n");
    3176:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    317a:	681b      	ldr	r3, [r3, #0]
    317c:	681b      	ldr	r3, [r3, #0]
    317e:	f508 6111 	add.w	r1, r8, #2320	; 0x910
    3182:	4628      	mov	r0, r5
    3184:	4798      	blx	r3
    if(!TCPIP_UDP_OptionsSet(pIState->udpSock, UDP_OPTION_TX_QUEUE_LIMIT, (void*)TCPIP_IPERF_TX_QUEUE_LIMIT))
    3186:	2202      	movs	r2, #2
    3188:	2106      	movs	r1, #6
    318a:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    318e:	f00b fbcf 	bl	e930 <TCPIP_UDP_OptionsSet>
    3192:	b938      	cbnz	r0, 31a4 <TCPIP_IPERF_Task+0x9e4>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Set of TX queuing limit failed\r\n");
    3194:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    3198:	681b      	ldr	r3, [r3, #0]
    319a:	681b      	ldr	r3, [r3, #0]
    319c:	f608 1138 	addw	r1, r8, #2360	; 0x938
    31a0:	4628      	mov	r0, r5
    31a2:	4798      	blx	r3
    TCPIP_UDP_SocketNetSet(pIState->udpSock, pIState->pNetIf);
    31a4:	f8d4 10c8 	ldr.w	r1, [r4, #200]	; 0xc8
    31a8:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    31ac:	f01a fd62 	bl	1dc74 <TCPIP_UDP_SocketNetSet>
	TCPIP_UDP_SocketInfoGet(pIState->udpSock, &UdpSkt);
    31b0:	a906      	add	r1, sp, #24
    31b2:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    31b6:	f018 f87d 	bl	1b2b4 <TCPIP_UDP_SocketInfoGet>
    pIState->localPort = UdpSkt.localPort;
    31ba:	f8bd 305e 	ldrh.w	r3, [sp, #94]	; 0x5e
    31be:	f8a4 307e 	strh.w	r3, [r4, #126]	; 0x7e
    (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "---------------------------------------------------------\r\n");
    31c2:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    31c6:	681b      	ldr	r3, [r3, #0]
    31c8:	681b      	ldr	r3, [r3, #0]
    31ca:	f508 7167 	add.w	r1, r8, #924	; 0x39c
    31ce:	4628      	mov	r0, r5
    31d0:	4798      	blx	r3
    (pIState->pCmdIO->pCmdApi->print)(cmdIoParam,  "iperf: Client connecting to %u.%u.%u.%u, UDP port %u\r\n",
    31d2:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    31d6:	681b      	ldr	r3, [r3, #0]
    31d8:	8a62      	ldrh	r2, [r4, #18]
    31da:	9202      	str	r2, [sp, #8]
    31dc:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
    31e0:	9201      	str	r2, [sp, #4]
    31e2:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
    31e6:	9200      	str	r2, [sp, #0]
    31e8:	f8d3 9004 	ldr.w	r9, [r3, #4]
    31ec:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    31f0:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
    31f4:	f508 6116 	add.w	r1, r8, #2400	; 0x960
    31f8:	4628      	mov	r0, r5
    31fa:	47c8      	blx	r9
    IperfSetState(pIState, IPERF_UDP_TX_DATAGRAM_STATE);
    31fc:	2111      	movs	r1, #17
    31fe:	4620      	mov	r0, r4
    3200:	f018 ff3a 	bl	1c078 <IperfSetState>
    pIState->startTime = SYS_TMR_TickCountGet();
    3204:	f01c ff72 	bl	200ec <SYS_TMR_TickCountGet>
    3208:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
    pIState->nextTxTime = pIState->startTime + pIState->mPktPeriod;
    320c:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
    3210:	4403      	add	r3, r0
    3212:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
    3216:	e68c      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Create UDP socket failed\r\n");
    3218:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    321c:	681b      	ldr	r3, [r3, #0]
    321e:	681b      	ldr	r3, [r3, #0]
    3220:	f208 7114 	addw	r1, r8, #1812	; 0x714
    3224:	4628      	mov	r0, r5
    3226:	4798      	blx	r3
        IperfSetState(pIState, IPERF_STANDBY_STATE);
    3228:	2101      	movs	r1, #1
    322a:	4620      	mov	r0, r4
    322c:	f018 ff24 	bl	1c078 <IperfSetState>
        return;
    3230:	e67f      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    3232:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    3236:	685d      	ldr	r5, [r3, #4]
   if  ( (pIState->tcpClientSock = TCPIP_TCP_ClientOpen(IP_ADDRESS_TYPE_IPV4, pIState->mServerPort, 0)) == INVALID_SOCKET )
    3238:	2200      	movs	r2, #0
    323a:	8a61      	ldrh	r1, [r4, #18]
    323c:	2001      	movs	r0, #1
    323e:	f01e f818 	bl	21272 <TCPIP_TCP_ClientOpen>
    3242:	8760      	strh	r0, [r4, #58]	; 0x3a
    3244:	f1b0 3fff 	cmp.w	r0, #4294967295
    3248:	d04f      	beq.n	32ea <TCPIP_IPERF_Task+0xb2a>
   TCPIP_TCP_SignalHandlerRegister(pIState->tcpClientSock, TCPIP_TCP_SIGNAL_RX_DATA, _IperfTCPRxSignalHandler, 0);
    324a:	2300      	movs	r3, #0
    324c:	4a8e      	ldr	r2, [pc, #568]	; (3488 <TCPIP_IPERF_Task+0xcc8>)
    324e:	f44f 7100 	mov.w	r1, #512	; 0x200
    3252:	f01a f977 	bl	1d544 <TCPIP_TCP_SignalHandlerRegister>
   if(pIState->localAddr.Val != 0)
    3256:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
    325a:	2b00      	cmp	r3, #0
    325c:	d152      	bne.n	3304 <TCPIP_IPERF_Task+0xb44>
   TCPIP_TCP_RemoteBind(pIState->tcpClientSock, IP_ADDRESS_TYPE_IPV4, 0,  (IP_MULTI_ADDRESS*)&pIState->remoteSide.remoteIPaddress);
    325e:	f104 0344 	add.w	r3, r4, #68	; 0x44
    3262:	2200      	movs	r2, #0
    3264:	2101      	movs	r1, #1
    3266:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    326a:	f019 f8fc 	bl	1c466 <TCPIP_TCP_RemoteBind>
    pIState->localPort = TCPIP_IPERF_TCP_LOCAL_PORT_START_NUMBER;
    326e:	f44f 6380 	mov.w	r3, #1024	; 0x400
    3272:	f8a4 307e 	strh.w	r3, [r4, #126]	; 0x7e
    (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "---------------------------------------------------------\r\n");
    3276:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    327a:	681b      	ldr	r3, [r3, #0]
    327c:	681b      	ldr	r3, [r3, #0]
    327e:	f508 7167 	add.w	r1, r8, #924	; 0x39c
    3282:	4628      	mov	r0, r5
    3284:	4798      	blx	r3
    (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf: Client connecting to %u.%u.%u.%u, TCP port %u\r\n",
    3286:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    328a:	681b      	ldr	r3, [r3, #0]
    328c:	8a62      	ldrh	r2, [r4, #18]
    328e:	9202      	str	r2, [sp, #8]
    3290:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
    3294:	9201      	str	r2, [sp, #4]
    3296:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
    329a:	9200      	str	r2, [sp, #0]
    329c:	f8d3 9004 	ldr.w	r9, [r3, #4]
    32a0:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    32a4:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
    32a8:	f608 1198 	addw	r1, r8, #2456	; 0x998
    32ac:	4628      	mov	r0, r5
    32ae:	47c8      	blx	r9
    IperfSetState(pIState, IPERF_TCP_TX_CONNECT_STATE);
    32b0:	210d      	movs	r1, #13
    32b2:	4620      	mov	r0, r4
    32b4:	f018 fee0 	bl	1c078 <IperfSetState>
    if(!TCPIP_TCP_OptionsSet(pIState->tcpClientSock, TCP_OPTION_TX_BUFF, (void*)pIState->txBuffSize))
    32b8:	f8d4 20b8 	ldr.w	r2, [r4, #184]	; 0xb8
    32bc:	2103      	movs	r1, #3
    32be:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    32c2:	f010 fe62 	bl	13f8a <TCPIP_TCP_OptionsSet>
    32c6:	b938      	cbnz	r0, 32d8 <TCPIP_IPERF_Task+0xb18>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Set of TX buffer size failed\r\n");
    32c8:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    32cc:	681b      	ldr	r3, [r3, #0]
    32ce:	681b      	ldr	r3, [r3, #0]
    32d0:	f508 6111 	add.w	r1, r8, #2320	; 0x910
    32d4:	4628      	mov	r0, r5
    32d6:	4798      	blx	r3
    TCPIP_TCP_Connect(pIState->tcpClientSock);
    32d8:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    32dc:	f01c f971 	bl	1f5c2 <TCPIP_TCP_Connect>
    pIState->timer = SYS_TMR_TickCountGet();
    32e0:	f01c ff04 	bl	200ec <SYS_TMR_TickCountGet>
    32e4:	f8c4 00ac 	str.w	r0, [r4, #172]	; 0xac
    32e8:	e623      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Create TCP socket failed\r\n");
    32ea:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    32ee:	681b      	ldr	r3, [r3, #0]
    32f0:	681b      	ldr	r3, [r3, #0]
    32f2:	f508 61d9 	add.w	r1, r8, #1736	; 0x6c8
    32f6:	4628      	mov	r0, r5
    32f8:	4798      	blx	r3
        IperfSetState(pIState, IPERF_STANDBY_STATE);
    32fa:	2101      	movs	r1, #1
    32fc:	4620      	mov	r0, r4
    32fe:	f018 febb 	bl	1c078 <IperfSetState>
        return;
    3302:	e616      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
       TCPIP_TCP_Bind(pIState->tcpClientSock, IP_ADDRESS_TYPE_IPV4, pIState->mServerPort, (IP_MULTI_ADDRESS*)&pIState->localAddr);
    3304:	f104 0380 	add.w	r3, r4, #128	; 0x80
    3308:	8a62      	ldrh	r2, [r4, #18]
    330a:	2101      	movs	r1, #1
    330c:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    3310:	f012 fea6 	bl	16060 <TCPIP_TCP_Bind>
    3314:	e7a3      	b.n	325e <TCPIP_IPERF_Task+0xa9e>
    if ( pIState->stopRequested == true )
    3316:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
    331a:	2b01      	cmp	r3, #1
    331c:	d01a      	beq.n	3354 <TCPIP_IPERF_Task+0xb94>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    331e:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    3322:	f8d3 9004 	ldr.w	r9, [r3, #4]
    if( !TCPIP_TCP_IsConnected(pIState->tcpClientSock) )
    3326:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    332a:	f01c ffa7 	bl	2027c <TCPIP_TCP_IsConnected>
    332e:	b1b0      	cbz	r0, 335e <TCPIP_IPERF_Task+0xb9e>
    TCPIP_TCP_WasReset(pIState->tcpClientSock);
    3330:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    3334:	f01c fc69 	bl	1fc0a <TCPIP_TCP_WasReset>
    pIState->startTime = SYS_TMR_TickCountGet();
    3338:	f01c fed8 	bl	200ec <SYS_TMR_TickCountGet>
    333c:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
    pIState->nextTxTime = pIState->startTime + pIState->mPktPeriod;
    3340:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
    3344:	4403      	add	r3, r0
    3346:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
    IperfSetState(pIState, IPERF_TCP_TX_SEGMENT_STATE);
    334a:	210e      	movs	r1, #14
    334c:	4620      	mov	r0, r4
    334e:	f018 fe93 	bl	1c078 <IperfSetState>
    3352:	e5ee      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        IperfSetState(pIState, IPERF_TCP_TX_DONE_STATE);
    3354:	210f      	movs	r1, #15
    3356:	4620      	mov	r0, r4
    3358:	f018 fe8e 	bl	1c078 <IperfSetState>
        return;
    335c:	e5e9      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        if(SYS_TMR_TickCountGet()- pIState->timer > 5*SYS_TMR_TickCounterFrequencyGet())
    335e:	f01c fec5 	bl	200ec <SYS_TMR_TickCountGet>
    3362:	f8d4 50ac 	ldr.w	r5, [r4, #172]	; 0xac
    3366:	1b45      	subs	r5, r0, r5
    3368:	f01c fee8 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
    336c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    3370:	4285      	cmp	r5, r0
    3372:	f67f adde 	bls.w	2f32 <TCPIP_IPERF_Task+0x772>
            TCPIP_TCP_Close(pIState->tcpClientSock);
    3376:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    337a:	f01a feae 	bl	1e0da <TCPIP_TCP_Close>
            pIState->tcpClientSock = INVALID_SOCKET;
    337e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    3382:	8763      	strh	r3, [r4, #58]	; 0x3a
            (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: TCP Client connection timeout\r\n");
    3384:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    3388:	681b      	ldr	r3, [r3, #0]
    338a:	681b      	ldr	r3, [r3, #0]
    338c:	f508 611d 	add.w	r1, r8, #2512	; 0x9d0
    3390:	4648      	mov	r0, r9
    3392:	4798      	blx	r3
            IperfSetState(pIState, IPERF_TCP_TX_DONE_STATE);
    3394:	210f      	movs	r1, #15
    3396:	4620      	mov	r0, r4
    3398:	f018 fe6e 	bl	1c078 <IperfSetState>
    339c:	e5c9      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    tIperfTxResult txRes = GenericTxStart(pIState);
    339e:	4620      	mov	r0, r4
    33a0:	f007 fafc 	bl	a99c <GenericTxStart>
    if(txRes == IPERF_TX_OK)
    33a4:	2801      	cmp	r0, #1
    33a6:	d00b      	beq.n	33c0 <TCPIP_IPERF_Task+0xc00>
    else if(txRes == IPERF_TX_FAIL)
    33a8:	2802      	cmp	r0, #2
    33aa:	f47f adc2 	bne.w	2f32 <TCPIP_IPERF_Task+0x772>
        IperfSetState(pIState, IPERF_TCP_TX_DONE_STATE);
    33ae:	210f      	movs	r1, #15
    33b0:	4620      	mov	r0, r4
    33b2:	f018 fe61 	bl	1c078 <IperfSetState>
        pIState->stopTime = SYS_TMR_TickCountGet();
    33b6:	f01c fe99 	bl	200ec <SYS_TMR_TickCountGet>
    33ba:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    33be:	e5b8      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
  memset( g_bfr, 0x54, MAX_BUFFER);
    33c0:	2234      	movs	r2, #52	; 0x34
    33c2:	2154      	movs	r1, #84	; 0x54
    33c4:	4638      	mov	r0, r7
    33c6:	f01e fc61 	bl	21c8c <memset>
  while( pIState->remainingTxData > 0u )
    33ca:	f8b4 30b0 	ldrh.w	r3, [r4, #176]	; 0xb0
    33ce:	b173      	cbz	r3, 33ee <TCPIP_IPERF_Task+0xc2e>
      chunk = pIState->remainingTxData;
    33d0:	2b33      	cmp	r3, #51	; 0x33
    33d2:	bf94      	ite	ls
    33d4:	461d      	movls	r5, r3
    33d6:	2534      	movhi	r5, #52	; 0x34
    pIState->remainingTxData -= chunk;
    33d8:	1b5b      	subs	r3, r3, r5
    33da:	f8a4 30b0 	strh.w	r3, [r4, #176]	; 0xb0
    if ( TCPIP_TCP_ArrayPut( pIState->tcpClientSock, (uint8_t *) g_bfr, chunk) != chunk )
    33de:	462a      	mov	r2, r5
    33e0:	4639      	mov	r1, r7
    33e2:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    33e6:	f00d fdab 	bl	10f40 <TCPIP_TCP_ArrayPut>
    33ea:	4285      	cmp	r5, r0
    33ec:	d0ed      	beq.n	33ca <TCPIP_IPERF_Task+0xc0a>
       TCPIP_TCP_Flush(pIState->tcpClientSock);
    33ee:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    33f2:	f01c ff56 	bl	202a2 <TCPIP_TCP_Flush>
       GenericTxEnd(pIState);
    33f6:	4620      	mov	r0, r4
    33f8:	f00c f950 	bl	f69c <GenericTxEnd>
    33fc:	e599      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    TCPIP_UDP_OptionsSet(pIState->udpSock, UDP_OPTION_TOS, (void*)(unsigned int)pIState->mTypeOfService);   
    33fe:	7d22      	ldrb	r2, [r4, #20]
    3400:	210b      	movs	r1, #11
    3402:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    3406:	f00b fa93 	bl	e930 <TCPIP_UDP_OptionsSet>
    tIperfTxResult txRes = GenericTxStart(pIState);
    340a:	4620      	mov	r0, r4
    340c:	f007 fac6 	bl	a99c <GenericTxStart>
    if ( txRes == IPERF_TX_OK )
    3410:	2801      	cmp	r0, #1
    3412:	d00b      	beq.n	342c <TCPIP_IPERF_Task+0xc6c>
    else if(txRes == IPERF_TX_FAIL)
    3414:	2802      	cmp	r0, #2
    3416:	f47f ad8c 	bne.w	2f32 <TCPIP_IPERF_Task+0x772>
        IperfSetState(pIState, IPERF_UDP_TX_DONE_STATE);
    341a:	2112      	movs	r1, #18
    341c:	4620      	mov	r0, r4
    341e:	f018 fe2b 	bl	1c078 <IperfSetState>
        pIState->stopTime = SYS_TMR_TickCountGet();
    3422:	f01c fe63 	bl	200ec <SYS_TMR_TickCountGet>
    3426:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    342a:	e582      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    memset( g_bfr, 0x55, MAX_BUFFER);
    342c:	2234      	movs	r2, #52	; 0x34
    342e:	2155      	movs	r1, #85	; 0x55
    3430:	4638      	mov	r0, r7
    3432:	f01e fc2b 	bl	21c8c <memset>
    remainingTxData = pIState->remainingTxData;
    3436:	f8b4 50b0 	ldrh.w	r5, [r4, #176]	; 0xb0
    while( remainingTxData > 0u )
    343a:	b1bd      	cbz	r5, 346c <TCPIP_IPERF_Task+0xcac>
    uint16_t txData = 0;
    343c:	f04f 0900 	mov.w	r9, #0
        if (  TCPIP_UDP_ArrayPut(pIState->udpSock, (uint8_t *) g_bfr, chunk) != chunk )
    3440:	f04f 0a34 	mov.w	sl, #52	; 0x34
    3444:	e001      	b.n	344a <TCPIP_IPERF_Task+0xc8a>
    while( remainingTxData > 0u )
    3446:	2d00      	cmp	r5, #0
    3448:	d041      	beq.n	34ce <TCPIP_IPERF_Task+0xd0e>
        if ( remainingTxData < MAX_BUFFER )
    344a:	2d33      	cmp	r5, #51	; 0x33
    344c:	d936      	bls.n	34bc <TCPIP_IPERF_Task+0xcfc>
        remainingTxData -= chunk;
    344e:	3d34      	subs	r5, #52	; 0x34
    3450:	b2ad      	uxth	r5, r5
        txData += chunk;
    3452:	f109 0934 	add.w	r9, r9, #52	; 0x34
    3456:	fa1f f989 	uxth.w	r9, r9
        if (  TCPIP_UDP_ArrayPut(pIState->udpSock, (uint8_t *) g_bfr, chunk) != chunk )
    345a:	4652      	mov	r2, sl
    345c:	4639      	mov	r1, r7
    345e:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    3462:	f019 fbfa 	bl	1cc5a <TCPIP_UDP_ArrayPut>
    3466:	2834      	cmp	r0, #52	; 0x34
    3468:	d0ed      	beq.n	3446 <TCPIP_IPERF_Task+0xc86>
    346a:	e030      	b.n	34ce <TCPIP_IPERF_Task+0xd0e>
    uint16_t txData = 0;
    346c:	46a9      	mov	r9, r5
    346e:	e02e      	b.n	34ce <TCPIP_IPERF_Task+0xd0e>
           pIState->remainingTxData -= txData;
    3470:	f8b4 30b0 	ldrh.w	r3, [r4, #176]	; 0xb0
    3474:	eba3 0909 	sub.w	r9, r3, r9
    3478:	f8a4 90b0 	strh.w	r9, [r4, #176]	; 0xb0
           GenericTxEnd(pIState);
    347c:	4620      	mov	r0, r4
    347e:	f00c f90d 	bl	f69c <GenericTxEnd>
    3482:	e556      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    3484:	00021781 	.word	0x00021781
    3488:	00021797 	.word	0x00021797
    GenericTxDone(pIState);
    348c:	4620      	mov	r0, r4
    348e:	f016 fdff 	bl	1a090 <GenericTxDone>
    TCPIP_TCP_Close(pIState->tcpClientSock);
    3492:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    3496:	f01a fe20 	bl	1e0da <TCPIP_TCP_Close>
    pIState->tcpClientSock = INVALID_SOCKET;
    349a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    349e:	8763      	strh	r3, [r4, #58]	; 0x3a
    34a0:	e547      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    GenericTxDone(pIState);
    34a2:	4620      	mov	r0, r4
    34a4:	f016 fdf4 	bl	1a090 <GenericTxDone>
    TCPIP_UDP_Close(pIState->udpSock );
    34a8:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    34ac:	f01b ff3c 	bl	1f328 <TCPIP_UDP_Close>
    34b0:	e53f      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
			IperfSetState(pIState, IPERF_STANDBY_STATE);
    34b2:	2101      	movs	r1, #1
    34b4:	4620      	mov	r0, r4
    34b6:	f018 fddf 	bl	1c078 <IperfSetState>
			break;
    34ba:	e53a      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        txData += chunk;
    34bc:	44a9      	add	r9, r5
    34be:	fa1f f989 	uxth.w	r9, r9
        if (  TCPIP_UDP_ArrayPut(pIState->udpSock, (uint8_t *) g_bfr, chunk) != chunk )
    34c2:	462a      	mov	r2, r5
    34c4:	4639      	mov	r1, r7
    34c6:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    34ca:	f019 fbc6 	bl	1cc5a <TCPIP_UDP_ArrayPut>
       if(TCPIP_UDP_Flush(pIState->udpSock) == 0)
    34ce:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    34d2:	f00a fe09 	bl	e0e8 <TCPIP_UDP_Flush>
    34d6:	2800      	cmp	r0, #0
    34d8:	d1ca      	bne.n	3470 <TCPIP_IPERF_Task+0xcb0>
           TCPIP_UDP_TxOffsetSet(pIState->udpSock, 0, 0);
    34da:	2200      	movs	r2, #0
    34dc:	4611      	mov	r1, r2
    34de:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    34e2:	f01a fd44 	bl	1df6e <TCPIP_UDP_TxOffsetSet>
    34e6:	e524      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
}
    34e8:	b01b      	add	sp, #108	; 0x6c
    34ea:	ecbd 8b02 	vpop	{d8}
    34ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    34f2:	bf00      	nop

Disassembly of section .rodata.sysfont_glyphs%183:

000034f4 <sysfont_glyphs>:
	...
    3518:	0000 0030 0030 0030 0030 0030 0030 0030     ..0.0.0.0.0.0.0.
    3528:	0000 0030 0030 0000 0000 0000 0000 0000     ..0.0...........
    3538:	0000 006c 006c 006c 006c 0000 0000 0000     ..l.l.l.l.......
	...
    355c:	0048 0048 00fc 0048 0048 0048 00fc 0048     H.H...H.H.H...H.
    356c:	0048 0000 0000 0000 0000 0000 0000 0010     H...............
    357c:	0010 003c 0040 0030 0008 0004 0078 0010     ..<.@.0.....x...
    358c:	0010 0000 0000 0000 0000 0000 0000 0000     ................
    359c:	007c 00a4 00a8 0048 0010 0014 002a 004a     |.....H.....*.J.
    35ac:	0044 0000 0000 0000 0000 0000 0000 0070     D.............p.
    35bc:	0088 0088 0088 0070 0088 008a 008a 008c     ......p.........
    35cc:	0070 0000 0000 0000 0000 0000 0000 0010     p...............
    35dc:	0010 0010 0000 0000 0000 0000 0000 0000     ................
	...
    35f8:	0008 0010 0010 0020 0020 0020 0020 0020     ...... . . . . .
    3608:	0020 0010 0010 0008 0000 0000 0000 0000      ...............
    3618:	0020 0010 0010 0008 0008 0008 0008 0008      ...............
    3628:	0008 0010 0010 0020 0000 0000 0000 0000     ...... .........
    3638:	0000 0028 0010 007c 0010 0028 0000 0000     ..(...|...(.....
	...
    3660:	0010 0010 0010 00fe 0010 0010 0010 0000     ................
	...
    3688:	0000 0018 0018 0030 0020 0000 0000 0000     ......0. .......
	...
    36a4:	0000 00fe 0000 0000 0000 0000 0000 0000     ................
	...
    36c8:	0000 0018 0018 0000 0000 0000 0000 0000     ................
    36d8:	0000 0000 0004 0008 0008 0010 0010 0020     .............. .
    36e8:	0020 0040 0040 0000 0000 0000 0000 0000      .@.@...........
    36f8:	0000 0078 0084 0084 008c 0094 00a4 00c4     ..x.............
    3708:	0084 0084 0078 0000 0000 0000 0000 0000     ....x...........
    3718:	0000 0010 0030 0050 0010 0010 0010 0010     ....0.P.........
    3728:	0010 0010 007c 0000 0000 0000 0000 0000     ....|...........
    3738:	0000 0070 0088 0008 0008 0010 0010 0020     ..p........... .
    3748:	0020 0040 00fc 0000 0000 0000 0000 0000      .@.............
    3758:	0000 0070 0088 0008 0008 0030 0008 0008     ..p.......0.....
    3768:	0008 0088 0070 0000 0000 0000 0000 0000     ....p...........
    3778:	0000 0008 0018 0028 0028 0048 0088 0088     ......(.(.H.....
    3788:	00fc 0008 0008 0000 0000 0000 0000 0000     ................
    3798:	0000 007c 0080 0080 00b8 00c4 0004 0004     ..|.............
    37a8:	0004 0084 0078 0000 0000 0000 0000 0000     ....x...........
    37b8:	0000 0038 0040 0080 0080 00b0 00c8 0084     ..8.@...........
    37c8:	0084 0048 0030 0000 0000 0000 0000 0000     ..H.0...........
    37d8:	0000 00fc 0004 0004 0008 0008 0010 0010     ................
    37e8:	0020 0020 0040 0000 0000 0000 0000 0000      . .@...........
    37f8:	0000 0078 0084 0084 0084 0078 0084 0084     ..x.......x.....
    3808:	0084 0084 0078 0000 0000 0000 0000 0000     ....x...........
    3818:	0000 0078 0084 0084 0084 008c 0074 0004     ..x.........t...
    3828:	0008 0010 00e0 0000 0000 0000 0000 0000     ................
	...
    3840:	0000 0030 0030 0000 0000 0030 0030 0000     ..0.0.....0.0...
	...
    3860:	0000 0060 0060 0000 0000 0060 0060 00c0     ..`.`.....`.`...
    3870:	0080 0000 0000 0000 0000 0000 0000 0000     ................
    3880:	0004 0018 0060 0080 0060 0018 0004 0000     ....`...`.......
	...
    38a0:	0000 007e 0000 0000 007e 0000 0000 0000     ..~.....~.......
	...
    38c0:	0040 0030 000c 0002 000c 0030 0040 0000     @.0.......0.@...
	...
    38d8:	0000 0070 0088 0008 0008 0010 0020 0020     ..p......... . .
    38e8:	0000 0020 0020 0000 0000 0000 0000 0000     .. . ...........
    38f8:	0000 0000 0000 003c 0042 00ba 00aa 00aa     ......<.B.......
    3908:	00aa 00bc 0040 003c 0000 0000 0000 0000     ....@.<.........
    3918:	0000 0010 0010 0028 0028 0028 0044 007c     ......(.(.(.D.|.
    3928:	0044 0082 0082 0000 0000 0000 0000 0000     D...............
    3938:	0000 00f0 0088 0088 0088 00f0 0088 0088     ................
    3948:	0088 0088 00f0 0000 0000 0000 0000 0000     ................
    3958:	0000 0038 0044 0080 0080 0080 0080 0080     ..8.D...........
    3968:	0080 0044 0038 0000 0000 0000 0000 0000     ..D.8...........
    3978:	0000 00f0 0088 0084 0084 0084 0084 0084     ................
    3988:	0084 0088 00f0 0000 0000 0000 0000 0000     ................
    3998:	0000 007c 0040 0040 0040 0078 0040 0040     ..|.@.@.@.x.@.@.
    39a8:	0040 0040 007c 0000 0000 0000 0000 0000     @.@.|...........
    39b8:	0000 007c 0040 0040 0040 0040 0078 0040     ..|.@.@.@.@.x.@.
    39c8:	0040 0040 0040 0000 0000 0000 0000 0000     @.@.@...........
    39d8:	0000 0038 0044 0080 0080 0080 009c 0084     ..8.D...........
    39e8:	0084 0044 003c 0000 0000 0000 0000 0000     ..D.<...........
    39f8:	0000 0084 0084 0084 0084 00fc 0084 0084     ................
    3a08:	0084 0084 0084 0000 0000 0000 0000 0000     ................
    3a18:	0000 007c 0010 0010 0010 0010 0010 0010     ..|.............
    3a28:	0010 0010 007c 0000 0000 0000 0000 0000     ....|...........
    3a38:	0000 00f8 0008 0008 0008 0008 0008 0008     ................
    3a48:	0008 0010 00e0 0000 0000 0000 0000 0000     ................
    3a58:	0000 0084 0084 0088 0090 00a0 00d0 0088     ................
    3a68:	0088 0084 0084 0000 0000 0000 0000 0000     ................
    3a78:	0000 0080 0080 0080 0080 0080 0080 0080     ................
    3a88:	0080 0080 00fc 0000 0000 0000 0000 0000     ................
    3a98:	0000 0084 0084 00cc 00cc 00b4 00b4 0084     ................
    3aa8:	0084 0084 0084 0000 0000 0000 0000 0000     ................
    3ab8:	0000 0084 00c4 00c4 00a4 00a4 0094 0094     ................
    3ac8:	008c 008c 0084 0000 0000 0000 0000 0000     ................
    3ad8:	0000 0030 0048 0084 0084 0084 0084 0084     ..0.H...........
    3ae8:	0084 0048 0030 0000 0000 0000 0000 0000     ..H.0...........
    3af8:	0000 00f0 0088 0084 0084 0084 0088 00f0     ................
    3b08:	0080 0080 0080 0000 0000 0000 0000 0000     ................
    3b18:	0000 0030 0048 0084 0084 0084 0084 0084     ..0.H...........
    3b28:	0084 0048 0030 0020 001c 0000 0000 0000     ..H.0. .........
    3b38:	0000 00f0 0088 0084 0084 0088 00f0 0090     ................
    3b48:	0088 0084 0084 0000 0000 0000 0000 0000     ................
    3b58:	0000 0078 0084 0080 0040 0030 0008 0004     ..x.....@.0.....
    3b68:	0004 0084 0078 0000 0000 0000 0000 0000     ....x...........
    3b78:	0000 00fe 0010 0010 0010 0010 0010 0010     ................
    3b88:	0010 0010 0010 0000 0000 0000 0000 0000     ................
    3b98:	0000 0084 0084 0084 0084 0084 0084 0084     ................
    3ba8:	0084 0084 0078 0000 0000 0000 0000 0000     ....x...........
    3bb8:	0000 0082 0082 0044 0044 0044 0044 0028     ......D.D.D.D.(.
    3bc8:	0028 0028 0010 0000 0000 0000 0000 0000     (.(.............
    3bd8:	0000 0084 0084 0084 0084 00b4 00b4 00b4     ................
    3be8:	0078 0048 0048 0000 0000 0000 0000 0000     x.H.H...........
    3bf8:	0000 0082 0044 0044 0028 0010 0010 0028     ....D.D.(.....(.
    3c08:	0044 0044 0082 0000 0000 0000 0000 0000     D.D.............
    3c18:	0000 0082 0044 0044 0028 0028 0028 0010     ....D.D.(.(.(...
    3c28:	0010 0010 0010 0000 0000 0000 0000 0000     ................
    3c38:	0000 00fc 0004 0008 0008 0010 0010 0020     .............. .
    3c48:	0040 0040 00fe 0000 0000 0000 0000 0000     @.@.............
    3c58:	00e0 0080 0080 0080 0080 0080 0080 0080     ................
    3c68:	0080 0080 0080 00e0 0000 0000 0000 0000     ................
    3c78:	0000 0040 0040 0020 0020 0010 0010 0008     ..@.@. . .......
    3c88:	0008 0004 0004 0000 0000 0000 0000 0000     ................
    3c98:	00e0 0020 0020 0020 0020 0020 0020 0020     .. . . . . . . .
    3ca8:	0020 0020 0020 00e0 0000 0000 0000 0000      . . ...........
    3cb8:	0000 0010 0028 0044 0000 0000 0000 0000     ....(.D.........
	...
    3cec:	007c 0000 0000 0000 0000 0000 0000 0020     |............. .
    3cfc:	0010 0008 0000 0000 0000 0000 0000 0000     ................
	...
    3d20:	0078 0004 0004 007c 0084 008c 0076 0000     x.....|.....v...
	...
    3d38:	0080 0080 0080 0080 00b8 00c4 0084 0084     ................
    3d48:	0084 0088 00f0 0000 0000 0000 0000 0000     ................
	...
    3d60:	007c 0080 0080 0080 0080 0080 007c 0000     |...........|...
	...
    3d78:	0002 0002 0002 0002 003e 0042 0082 0082     ........>.B.....
    3d88:	0082 0042 003e 0000 0000 0000 0000 0000     ..B.>...........
	...
    3da0:	007c 0082 0082 00fe 0080 0080 007e 0000     |...........~...
	...
    3db8:	0000 001c 0020 0020 00fc 0020 0020 0020     .... . ... . . .
    3dc8:	0020 0020 00fc 0000 0000 0000 0000 0000      . .............
	...
    3de0:	007c 0084 0084 0084 0084 008c 0074 0004     |...........t...
    3df0:	0044 0038 0000 0000 0080 0080 0080 0080     D.8.............
    3e00:	00b8 00c4 0084 0084 0084 0084 0084 0000     ................
	...
    3e18:	0000 0010 0000 0000 0070 0010 0010 0010     ........p.......
    3e28:	0010 0010 007c 0000 0000 0000 0000 0000     ....|...........
    3e38:	0000 0008 0000 0000 0078 0008 0008 0008     ........x.......
    3e48:	0008 0008 0008 0008 0010 00e0 0000 0000     ................
    3e58:	0080 0080 0080 0080 0088 0090 00a0 00e0     ................
    3e68:	0090 0088 0084 0000 0000 0000 0000 0000     ................
    3e78:	0000 00f0 0010 0010 0010 0010 0010 0010     ................
    3e88:	0010 0010 00fe 0000 0000 0000 0000 0000     ................
	...
    3ea0:	00ac 00d4 0094 0094 0094 0094 0094 0000     ................
	...
    3ec0:	00b8 00c4 0084 0084 0084 0084 0084 0000     ................
	...
    3ee0:	0078 0084 0084 0084 0084 0084 0078 0000     x...........x...
	...
    3f00:	00b8 00c4 0084 0084 0084 0084 00f8 0080     ................
    3f10:	0080 0080 0000 0000 0000 0000 0000 0000     ................
    3f20:	007c 0084 0084 0084 0084 0084 007c 0004     |...........|...
    3f30:	0004 0004 0000 0000 0000 0000 0000 0000     ................
    3f40:	00cc 0030 0020 0020 0020 0020 00f8 0000     ..0. . . . .....
	...
    3f60:	007c 0080 0080 0078 0004 0004 00f8 0000     |.....x.........
	...
    3f7c:	0000 0020 00fc 0020 0020 0020 0020 0020     .. ... . . . . .
    3f8c:	001c 0000 0000 0000 0000 0000 0000 0000     ................
    3f9c:	0000 0000 0088 0088 0088 0088 0088 0088     ................
    3fac:	0074 0000 0000 0000 0000 0000 0000 0000     t...............
    3fbc:	0000 0000 0082 0044 0044 0028 0028 0010     ......D.D.(.(...
    3fcc:	0010 0000 0000 0000 0000 0000 0000 0000     ................
    3fdc:	0000 0000 0084 0084 00b4 00b4 0048 0048     ............H.H.
    3fec:	0048 0000 0000 0000 0000 0000 0000 0000     H...............
    3ffc:	0000 0000 0044 0028 0028 0010 0028 0044     ....D.(.(...(.D.
    400c:	0044 0000 0000 0000 0000 0000 0000 0000     D...............
    401c:	0000 0000 0082 0044 0044 0028 0028 0028     ......D.D.(.(.(.
    402c:	0010 0010 0020 0020 0000 0000 0000 0000     .... . .........
    403c:	0000 0000 00fc 0004 0008 0010 0020 0040     ............ .@.
    404c:	00fc 0000 0000 0000 0000 0000 0008 0010     ................
    405c:	0010 0008 0008 0010 0010 0008 0008 0010     ................
    406c:	0010 0008 0000 0000 0000 0000 0010 0010     ................
    407c:	0010 0010 0010 0000 0000 0010 0010 0010     ................
    408c:	0010 0010 0000 0000 0000 0000 0020 0010     ............ ...
    409c:	0010 0020 0020 0010 0010 0020 0020 0010     .. . ..... . ...
    40ac:	0010 0020 0000 0000                         .. .....

Disassembly of section .dinit%184:

000040b4 <.dinit>:
    40b4:	2000e1b0 	.word	0x2000e1b0
    40b8:	0000001c 	.word	0x0000001c
    40bc:	00000000 	.word	0x00000000
    40c0:	2000de18 	.word	0x2000de18
    40c4:	00000068 	.word	0x00000068
    40c8:	00000000 	.word	0x00000000
    40cc:	2000dd14 	.word	0x2000dd14
    40d0:	00000004 	.word	0x00000004
    40d4:	00000000 	.word	0x00000000
    40d8:	2000d8b8 	.word	0x2000d8b8
    40dc:	000000f8 	.word	0x000000f8
    40e0:	00000001 	.word	0x00000001
    40e4:	0001bd6c 	.word	0x0001bd6c
	...
    41dc:	2000e18f 	.word	0x2000e18f
    41e0:	00000001 	.word	0x00000001
    41e4:	00000001 	.word	0x00000001
    41e8:	000000ff 	.word	0x000000ff
    41ec:	2000e370 	.word	0x2000e370
    41f0:	00000004 	.word	0x00000004
    41f4:	00000000 	.word	0x00000000
    41f8:	2000dd18 	.word	0x2000dd18
    41fc:	00000080 	.word	0x00000080
    4200:	00000000 	.word	0x00000000
    4204:	2000e4f8 	.word	0x2000e4f8
    4208:	00000002 	.word	0x00000002
    420c:	00000001 	.word	0x00000001
    4210:	00000054 	.word	0x00000054
    4214:	2000dbf0 	.word	0x2000dbf0
    4218:	00000094 	.word	0x00000094
    421c:	00000000 	.word	0x00000000
    4220:	2000e1cc 	.word	0x2000e1cc
    4224:	00000018 	.word	0x00000018
    4228:	00000000 	.word	0x00000000
    422c:	2000e374 	.word	0x2000e374
    4230:	00000004 	.word	0x00000004
    4234:	00000000 	.word	0x00000000
    4238:	2000e378 	.word	0x2000e378
    423c:	00000004 	.word	0x00000004
    4240:	00000000 	.word	0x00000000
    4244:	2000e37c 	.word	0x2000e37c
    4248:	00000004 	.word	0x00000004
    424c:	00000000 	.word	0x00000000
    4250:	2000e380 	.word	0x2000e380
    4254:	00000004 	.word	0x00000004
    4258:	00000000 	.word	0x00000000
    425c:	2000e214 	.word	0x2000e214
    4260:	00000014 	.word	0x00000014
    4264:	00000000 	.word	0x00000000
    4268:	2000e384 	.word	0x2000e384
    426c:	00000004 	.word	0x00000004
    4270:	00000000 	.word	0x00000000
    4274:	2000e388 	.word	0x2000e388
    4278:	00000004 	.word	0x00000004
    427c:	00000000 	.word	0x00000000
    4280:	2000e38c 	.word	0x2000e38c
    4284:	00000004 	.word	0x00000004
    4288:	00000000 	.word	0x00000000
    428c:	2000e390 	.word	0x2000e390
    4290:	00000004 	.word	0x00000004
    4294:	00000000 	.word	0x00000000
    4298:	2000e316 	.word	0x2000e316
    429c:	00000002 	.word	0x00000002
    42a0:	00000000 	.word	0x00000000
    42a4:	2000e4f6 	.word	0x2000e4f6
    42a8:	00000002 	.word	0x00000002
    42ac:	00000000 	.word	0x00000000
    42b0:	2000e394 	.word	0x2000e394
    42b4:	00000004 	.word	0x00000004
    42b8:	00000000 	.word	0x00000000
    42bc:	2000e398 	.word	0x2000e398
    42c0:	00000004 	.word	0x00000004
    42c4:	00000000 	.word	0x00000000
    42c8:	2000e39c 	.word	0x2000e39c
    42cc:	00000004 	.word	0x00000004
    42d0:	00000000 	.word	0x00000000
    42d4:	2000e3a0 	.word	0x2000e3a0
    42d8:	00000004 	.word	0x00000004
    42dc:	00000000 	.word	0x00000000
    42e0:	2000e3a4 	.word	0x2000e3a4
    42e4:	00000004 	.word	0x00000004
    42e8:	00000000 	.word	0x00000000
    42ec:	2000dfa4 	.word	0x2000dfa4
    42f0:	0000004c 	.word	0x0000004c
    42f4:	00000000 	.word	0x00000000
    42f8:	2000e368 	.word	0x2000e368
    42fc:	00000006 	.word	0x00000006
    4300:	00000001 	.word	0x00000001
    4304:	ffffffff 	.word	0xffffffff
    4308:	0000ffff 	.word	0x0000ffff
    430c:	2000e1e4 	.word	0x2000e1e4
    4310:	00000018 	.word	0x00000018
    4314:	00000000 	.word	0x00000000
    4318:	2000e3a8 	.word	0x2000e3a8
    431c:	00000004 	.word	0x00000004
    4320:	00000000 	.word	0x00000000
    4324:	2000e3ac 	.word	0x2000e3ac
    4328:	00000004 	.word	0x00000004
    432c:	00000000 	.word	0x00000000
    4330:	2000e3b0 	.word	0x2000e3b0
    4334:	00000004 	.word	0x00000004
    4338:	00000000 	.word	0x00000000
    433c:	2000e170 	.word	0x2000e170
    4340:	0000001f 	.word	0x0000001f
    4344:	00000000 	.word	0x00000000
    4348:	2000e3b4 	.word	0x2000e3b4
    434c:	00000004 	.word	0x00000004
    4350:	00000000 	.word	0x00000000
    4354:	2000e3b8 	.word	0x2000e3b8
    4358:	00000004 	.word	0x00000004
    435c:	00000000 	.word	0x00000000
    4360:	2000e4fa 	.word	0x2000e4fa
    4364:	00000002 	.word	0x00000002
    4368:	00000000 	.word	0x00000000
    436c:	2000e3bc 	.word	0x2000e3bc
    4370:	00000004 	.word	0x00000004
    4374:	00000000 	.word	0x00000000
    4378:	2000ca04 	.word	0x2000ca04
    437c:	000007d0 	.word	0x000007d0
    4380:	00000000 	.word	0x00000000
    4384:	2000e3c0 	.word	0x2000e3c0
    4388:	00000004 	.word	0x00000004
    438c:	00000000 	.word	0x00000000
    4390:	2000e3c4 	.word	0x2000e3c4
    4394:	00000004 	.word	0x00000004
    4398:	00000000 	.word	0x00000000
    439c:	2000e3c8 	.word	0x2000e3c8
    43a0:	00000004 	.word	0x00000004
    43a4:	00000000 	.word	0x00000000
    43a8:	2000e3cc 	.word	0x2000e3cc
    43ac:	00000004 	.word	0x00000004
    43b0:	00000000 	.word	0x00000000
    43b4:	2000e4fc 	.word	0x2000e4fc
    43b8:	00000002 	.word	0x00000002
    43bc:	00000000 	.word	0x00000000
    43c0:	2000e3d0 	.word	0x2000e3d0
    43c4:	00000004 	.word	0x00000004
    43c8:	00000000 	.word	0x00000000
    43cc:	2000e3d4 	.word	0x2000e3d4
    43d0:	00000004 	.word	0x00000004
    43d4:	00000000 	.word	0x00000000
    43d8:	2000e304 	.word	0x2000e304
    43dc:	00000011 	.word	0x00000011
    43e0:	00000000 	.word	0x00000000
    43e4:	2000e190 	.word	0x2000e190
    43e8:	0000001f 	.word	0x0000001f
    43ec:	00000000 	.word	0x00000000
    43f0:	2000e3d8 	.word	0x2000e3d8
    43f4:	00000004 	.word	0x00000004
    43f8:	00000000 	.word	0x00000000
    43fc:	2000e3dc 	.word	0x2000e3dc
    4400:	00000004 	.word	0x00000004
    4404:	00000000 	.word	0x00000000
    4408:	2000e3e0 	.word	0x2000e3e0
    440c:	00000004 	.word	0x00000004
    4410:	00000000 	.word	0x00000000
    4414:	2000e3e4 	.word	0x2000e3e4
    4418:	00000004 	.word	0x00000004
    441c:	00000000 	.word	0x00000000
    4420:	2000e1af 	.word	0x2000e1af
    4424:	00000001 	.word	0x00000001
    4428:	00000000 	.word	0x00000000
    442c:	2000e315 	.word	0x2000e315
    4430:	00000001 	.word	0x00000001
    4434:	00000001 	.word	0x00000001
    4438:	00000001 	.word	0x00000001
    443c:	2000e3e8 	.word	0x2000e3e8
    4440:	00000004 	.word	0x00000004
    4444:	00000001 	.word	0x00000001
    4448:	00000064 	.word	0x00000064
    444c:	2000d9b0 	.word	0x2000d9b0
    4450:	000000d8 	.word	0x000000d8
    4454:	00000000 	.word	0x00000000
    4458:	2000e068 	.word	0x2000e068
    445c:	00000034 	.word	0x00000034
    4460:	00000000 	.word	0x00000000
    4464:	2000e3ec 	.word	0x2000e3ec
    4468:	00000004 	.word	0x00000004
    446c:	00000000 	.word	0x00000000
    4470:	2000e4f5 	.word	0x2000e4f5
    4474:	00000001 	.word	0x00000001
    4478:	00000000 	.word	0x00000000
    447c:	2000e3f0 	.word	0x2000e3f0
    4480:	00000004 	.word	0x00000004
    4484:	00000000 	.word	0x00000000
    4488:	2000e3f4 	.word	0x2000e3f4
    448c:	00000004 	.word	0x00000004
    4490:	00000000 	.word	0x00000000
    4494:	2000e3f8 	.word	0x2000e3f8
    4498:	00000004 	.word	0x00000004
    449c:	00000000 	.word	0x00000000
    44a0:	2000e3fc 	.word	0x2000e3fc
    44a4:	00000004 	.word	0x00000004
    44a8:	00000000 	.word	0x00000000
    44ac:	2000e328 	.word	0x2000e328
    44b0:	0000000c 	.word	0x0000000c
    44b4:	00000000 	.word	0x00000000
    44b8:	2000e228 	.word	0x2000e228
    44bc:	00000014 	.word	0x00000014
    44c0:	00000000 	.word	0x00000000
    44c4:	2000e50c 	.word	0x2000e50c
    44c8:	00000001 	.word	0x00000001
    44cc:	00000000 	.word	0x00000000
    44d0:	2000e4fe 	.word	0x2000e4fe
    44d4:	00000002 	.word	0x00000002
    44d8:	00000000 	.word	0x00000000
    44dc:	2000e500 	.word	0x2000e500
    44e0:	00000002 	.word	0x00000002
    44e4:	00000000 	.word	0x00000000
    44e8:	2000e400 	.word	0x2000e400
    44ec:	00000004 	.word	0x00000004
    44f0:	00000000 	.word	0x00000000
    44f4:	2000e23c 	.word	0x2000e23c
    44f8:	00000014 	.word	0x00000014
    44fc:	00000000 	.word	0x00000000
    4500:	2000e404 	.word	0x2000e404
    4504:	00000004 	.word	0x00000004
    4508:	00000000 	.word	0x00000000
    450c:	2000e408 	.word	0x2000e408
    4510:	00000004 	.word	0x00000004
    4514:	00000000 	.word	0x00000000
    4518:	2000e502 	.word	0x2000e502
    451c:	00000002 	.word	0x00000002
    4520:	00000000 	.word	0x00000000
    4524:	2000e504 	.word	0x2000e504
    4528:	00000002 	.word	0x00000002
    452c:	00000000 	.word	0x00000000
    4530:	2000e40c 	.word	0x2000e40c
    4534:	00000004 	.word	0x00000004
    4538:	00000000 	.word	0x00000000
    453c:	2000e410 	.word	0x2000e410
    4540:	00000004 	.word	0x00000004
    4544:	00000000 	.word	0x00000000
    4548:	2000e414 	.word	0x2000e414
    454c:	00000004 	.word	0x00000004
    4550:	00000000 	.word	0x00000000
    4554:	2000e250 	.word	0x2000e250
    4558:	00000014 	.word	0x00000014
    455c:	00000000 	.word	0x00000000
    4560:	2000e418 	.word	0x2000e418
    4564:	00000004 	.word	0x00000004
    4568:	00000000 	.word	0x00000000
    456c:	2000e506 	.word	0x2000e506
    4570:	00000002 	.word	0x00000002
    4574:	00000000 	.word	0x00000000
    4578:	2000e41c 	.word	0x2000e41c
    457c:	00000004 	.word	0x00000004
    4580:	00000000 	.word	0x00000000
    4584:	2000e420 	.word	0x2000e420
    4588:	00000004 	.word	0x00000004
    458c:	00000000 	.word	0x00000000
    4590:	2000e0c8 	.word	0x2000e0c8
    4594:	00000028 	.word	0x00000028
    4598:	00000000 	.word	0x00000000
    459c:	2000e424 	.word	0x2000e424
    45a0:	00000004 	.word	0x00000004
    45a4:	00000000 	.word	0x00000000
    45a8:	2000dc84 	.word	0x2000dc84
    45ac:	00000090 	.word	0x00000090
    45b0:	00000000 	.word	0x00000000
    45b4:	2000d1d4 	.word	0x2000d1d4
    45b8:	00000270 	.word	0x00000270
    45bc:	00000000 	.word	0x00000000
    45c0:	2000e428 	.word	0x2000e428
    45c4:	00000004 	.word	0x00000004
    45c8:	00000000 	.word	0x00000000
    45cc:	2000e42c 	.word	0x2000e42c
    45d0:	00000004 	.word	0x00000004
    45d4:	00000000 	.word	0x00000000
    45d8:	2000e430 	.word	0x2000e430
    45dc:	00000004 	.word	0x00000004
    45e0:	00000000 	.word	0x00000000
    45e4:	2000e434 	.word	0x2000e434
    45e8:	00000004 	.word	0x00000004
    45ec:	00000000 	.word	0x00000000
    45f0:	2000e438 	.word	0x2000e438
    45f4:	00000004 	.word	0x00000004
    45f8:	00000000 	.word	0x00000000
    45fc:	2000e43c 	.word	0x2000e43c
    4600:	00000004 	.word	0x00000004
    4604:	00000000 	.word	0x00000000
    4608:	2000e440 	.word	0x2000e440
    460c:	00000004 	.word	0x00000004
    4610:	00000000 	.word	0x00000000
    4614:	2000e318 	.word	0x2000e318
    4618:	00000010 	.word	0x00000010
    461c:	00000000 	.word	0x00000000
    4620:	2000e1fc 	.word	0x2000e1fc
    4624:	00000018 	.word	0x00000018
    4628:	00000000 	.word	0x00000000
    462c:	2000e0f0 	.word	0x2000e0f0
    4630:	00000020 	.word	0x00000020
    4634:	00000000 	.word	0x00000000
    4638:	2000e444 	.word	0x2000e444
    463c:	00000004 	.word	0x00000004
    4640:	00000000 	.word	0x00000000
    4644:	2000e50d 	.word	0x2000e50d
    4648:	00000001 	.word	0x00000001
    464c:	00000000 	.word	0x00000000
    4650:	2000e448 	.word	0x2000e448
    4654:	00000004 	.word	0x00000004
    4658:	00000000 	.word	0x00000000
    465c:	2000e44c 	.word	0x2000e44c
    4660:	00000004 	.word	0x00000004
    4664:	00000001 	.word	0x00000001
    4668:	ffffffff 	.word	0xffffffff
    466c:	2000e450 	.word	0x2000e450
    4670:	00000004 	.word	0x00000004
    4674:	00000000 	.word	0x00000000
    4678:	2000e454 	.word	0x2000e454
    467c:	00000004 	.word	0x00000004
    4680:	00000000 	.word	0x00000000
    4684:	2000e458 	.word	0x2000e458
    4688:	00000004 	.word	0x00000004
    468c:	00000000 	.word	0x00000000
    4690:	2000e45c 	.word	0x2000e45c
    4694:	00000004 	.word	0x00000004
    4698:	00000000 	.word	0x00000000
    469c:	2000e508 	.word	0x2000e508
    46a0:	00000002 	.word	0x00000002
    46a4:	00000000 	.word	0x00000000
    46a8:	2000e460 	.word	0x2000e460
    46ac:	00000004 	.word	0x00000004
    46b0:	00000000 	.word	0x00000000
    46b4:	2000e464 	.word	0x2000e464
    46b8:	00000004 	.word	0x00000004
    46bc:	00000000 	.word	0x00000000
    46c0:	2000e468 	.word	0x2000e468
    46c4:	00000004 	.word	0x00000004
    46c8:	00000000 	.word	0x00000000
    46cc:	2000a004 	.word	0x2000a004
    46d0:	00001000 	.word	0x00001000
    46d4:	00000000 	.word	0x00000000
    46d8:	2000b004 	.word	0x2000b004
    46dc:	00001000 	.word	0x00001000
    46e0:	00000000 	.word	0x00000000
    46e4:	2000dff0 	.word	0x2000dff0
    46e8:	00000040 	.word	0x00000040
    46ec:	00000000 	.word	0x00000000
    46f0:	2000e358 	.word	0x2000e358
    46f4:	00000008 	.word	0x00000008
    46f8:	00000000 	.word	0x00000000
    46fc:	2000e46c 	.word	0x2000e46c
    4700:	00000004 	.word	0x00000004
    4704:	00000000 	.word	0x00000000
    4708:	2000dd98 	.word	0x2000dd98
    470c:	00000080 	.word	0x00000080
    4710:	00000000 	.word	0x00000000
    4714:	2000e360 	.word	0x2000e360
    4718:	00000008 	.word	0x00000008
    471c:	00000000 	.word	0x00000000
    4720:	2000c004 	.word	0x2000c004
    4724:	00000a00 	.word	0x00000a00
    4728:	00000000 	.word	0x00000000
    472c:	2000e470 	.word	0x2000e470
    4730:	00000004 	.word	0x00000004
    4734:	00000000 	.word	0x00000000
    4738:	2000e334 	.word	0x2000e334
    473c:	0000000c 	.word	0x0000000c
    4740:	00000000 	.word	0x00000000
    4744:	2000e340 	.word	0x2000e340
    4748:	0000000c 	.word	0x0000000c
    474c:	00000000 	.word	0x00000000
    4750:	2000da88 	.word	0x2000da88
    4754:	000000c8 	.word	0x000000c8
    4758:	00000000 	.word	0x00000000
    475c:	2000e474 	.word	0x2000e474
    4760:	00000004 	.word	0x00000004
    4764:	00000000 	.word	0x00000000
    4768:	2000e50e 	.word	0x2000e50e
    476c:	00000001 	.word	0x00000001
    4770:	00000000 	.word	0x00000000
    4774:	2000e50f 	.word	0x2000e50f
    4778:	00000001 	.word	0x00000001
    477c:	00000000 	.word	0x00000000
    4780:	2000e478 	.word	0x2000e478
    4784:	00000004 	.word	0x00000004
    4788:	00000000 	.word	0x00000000
    478c:	2000e030 	.word	0x2000e030
    4790:	00000038 	.word	0x00000038
    4794:	00000000 	.word	0x00000000
    4798:	2000db50 	.word	0x2000db50
    479c:	000000a0 	.word	0x000000a0
    47a0:	00000000 	.word	0x00000000
    47a4:	2000e50a 	.word	0x2000e50a
    47a8:	00000002 	.word	0x00000002
    47ac:	00000001 	.word	0x00000001
    47b0:	00000001 	.word	0x00000001
    47b4:	2000e47c 	.word	0x2000e47c
    47b8:	00000004 	.word	0x00000004
    47bc:	00000000 	.word	0x00000000
    47c0:	2000e480 	.word	0x2000e480
    47c4:	00000004 	.word	0x00000004
    47c8:	00000000 	.word	0x00000000
    47cc:	2000e484 	.word	0x2000e484
    47d0:	00000004 	.word	0x00000004
    47d4:	00000000 	.word	0x00000000
    47d8:	2000d7b0 	.word	0x2000d7b0
    47dc:	00000108 	.word	0x00000108
    47e0:	00000000 	.word	0x00000000
    47e4:	2000e488 	.word	0x2000e488
    47e8:	00000004 	.word	0x00000004
    47ec:	00000000 	.word	0x00000000
    47f0:	2000e48c 	.word	0x2000e48c
    47f4:	00000004 	.word	0x00000004
    47f8:	00000000 	.word	0x00000000
    47fc:	2000e264 	.word	0x2000e264
    4800:	00000014 	.word	0x00000014
    4804:	00000000 	.word	0x00000000
    4808:	2000e278 	.word	0x2000e278
    480c:	00000014 	.word	0x00000014
    4810:	00000001 	.word	0x00000001
    4814:	00000101 	.word	0x00000101
    4818:	00021c6d 	.word	0x00021c6d
    481c:	00021c5d 	.word	0x00021c5d
    4820:	00021c7d 	.word	0x00021c7d
    4824:	00009952 	.word	0x00009952
    4828:	2000e490 	.word	0x2000e490
    482c:	00000004 	.word	0x00000004
    4830:	00000001 	.word	0x00000001
    4834:	aaaaaaaa 	.word	0xaaaaaaaa
    4838:	2000e494 	.word	0x2000e494
    483c:	00000004 	.word	0x00000004
    4840:	00000000 	.word	0x00000000
    4844:	20000004 	.word	0x20000004
    4848:	0000a000 	.word	0x0000a000
    484c:	00000000 	.word	0x00000000
    4850:	2000e498 	.word	0x2000e498
    4854:	00000004 	.word	0x00000004
    4858:	00000000 	.word	0x00000000
    485c:	2000e49c 	.word	0x2000e49c
    4860:	00000004 	.word	0x00000004
    4864:	00000000 	.word	0x00000000
    4868:	2000e4a0 	.word	0x2000e4a0
    486c:	00000004 	.word	0x00000004
    4870:	00000000 	.word	0x00000000
    4874:	2000e4a4 	.word	0x2000e4a4
    4878:	00000004 	.word	0x00000004
    487c:	00000000 	.word	0x00000000
    4880:	2000de80 	.word	0x2000de80
    4884:	00000064 	.word	0x00000064
    4888:	00000000 	.word	0x00000000
    488c:	2000e4a8 	.word	0x2000e4a8
    4890:	00000004 	.word	0x00000004
    4894:	00000000 	.word	0x00000000
    4898:	2000e4ac 	.word	0x2000e4ac
    489c:	00000004 	.word	0x00000004
    48a0:	00000000 	.word	0x00000000
    48a4:	2000e4b0 	.word	0x2000e4b0
    48a8:	00000004 	.word	0x00000004
    48ac:	00000000 	.word	0x00000000
    48b0:	2000e4b4 	.word	0x2000e4b4
    48b4:	00000004 	.word	0x00000004
    48b8:	00000000 	.word	0x00000000
    48bc:	2000e4b8 	.word	0x2000e4b8
    48c0:	00000004 	.word	0x00000004
    48c4:	00000000 	.word	0x00000000
    48c8:	2000e28c 	.word	0x2000e28c
    48cc:	00000014 	.word	0x00000014
    48d0:	00000000 	.word	0x00000000
    48d4:	2000e2a0 	.word	0x2000e2a0
    48d8:	00000014 	.word	0x00000014
    48dc:	00000000 	.word	0x00000000
    48e0:	2000e4bc 	.word	0x2000e4bc
    48e4:	00000004 	.word	0x00000004
    48e8:	00000000 	.word	0x00000000
    48ec:	2000e4c0 	.word	0x2000e4c0
    48f0:	00000004 	.word	0x00000004
    48f4:	00000000 	.word	0x00000000
    48f8:	2000e4c4 	.word	0x2000e4c4
    48fc:	00000004 	.word	0x00000004
    4900:	00000000 	.word	0x00000000
    4904:	2000e4c8 	.word	0x2000e4c8
    4908:	00000004 	.word	0x00000004
    490c:	00000000 	.word	0x00000000
    4910:	2000e2b4 	.word	0x2000e2b4
    4914:	00000014 	.word	0x00000014
    4918:	00000000 	.word	0x00000000
    491c:	2000e4cc 	.word	0x2000e4cc
    4920:	00000004 	.word	0x00000004
    4924:	00000000 	.word	0x00000000
    4928:	2000e2c8 	.word	0x2000e2c8
    492c:	00000014 	.word	0x00000014
    4930:	00000000 	.word	0x00000000
    4934:	2000e2dc 	.word	0x2000e2dc
    4938:	00000014 	.word	0x00000014
    493c:	00000000 	.word	0x00000000
    4940:	2000e4d0 	.word	0x2000e4d0
    4944:	00000004 	.word	0x00000004
    4948:	00000000 	.word	0x00000000
    494c:	2000e4d4 	.word	0x2000e4d4
    4950:	00000004 	.word	0x00000004
    4954:	00000000 	.word	0x00000000
    4958:	2000dee4 	.word	0x2000dee4
    495c:	00000060 	.word	0x00000060
    4960:	00000000 	.word	0x00000000
    4964:	2000e4f4 	.word	0x2000e4f4
    4968:	00000001 	.word	0x00000001
    496c:	00000000 	.word	0x00000000
    4970:	2000e2f0 	.word	0x2000e2f0
    4974:	00000014 	.word	0x00000014
    4978:	00000000 	.word	0x00000000
    497c:	2000e36e 	.word	0x2000e36e
    4980:	00000002 	.word	0x00000002
    4984:	00000000 	.word	0x00000000
    4988:	2000e4d8 	.word	0x2000e4d8
    498c:	00000004 	.word	0x00000004
    4990:	00000000 	.word	0x00000000
    4994:	2000e510 	.word	0x2000e510
    4998:	00000001 	.word	0x00000001
    499c:	00000000 	.word	0x00000000
    49a0:	2000e09c 	.word	0x2000e09c
    49a4:	0000002c 	.word	0x0000002c
    49a8:	00000000 	.word	0x00000000
    49ac:	2000e4dc 	.word	0x2000e4dc
    49b0:	00000004 	.word	0x00000004
    49b4:	00000000 	.word	0x00000000
    49b8:	2000d444 	.word	0x2000d444
    49bc:	00000200 	.word	0x00000200
    49c0:	00000000 	.word	0x00000000
    49c4:	2000e34c 	.word	0x2000e34c
    49c8:	0000000c 	.word	0x0000000c
    49cc:	00000001 	.word	0x00000001
    49d0:	00000000 	.word	0x00000000
    49d4:	000034f4 	.word	0x000034f4
    49d8:	7d20100a 	.word	0x7d20100a
    49dc:	2000e4e0 	.word	0x2000e4e0
    49e0:	00000004 	.word	0x00000004
    49e4:	00000000 	.word	0x00000000
    49e8:	2000e4e4 	.word	0x2000e4e4
    49ec:	00000004 	.word	0x00000004
    49f0:	00000001 	.word	0x00000001
    49f4:	2000df44 	.word	0x2000df44
    49f8:	2000df44 	.word	0x2000df44
    49fc:	00000060 	.word	0x00000060
    4a00:	00000001 	.word	0x00000001
    4a04:	00000000 	.word	0x00000000
    4a08:	2000e130 	.word	0x2000e130
    4a0c:	2000e150 	.word	0x2000e150
    4a10:	2000e110 	.word	0x2000e110
	...
    4a64:	2000e4e8 	.word	0x2000e4e8
    4a68:	00000004 	.word	0x00000004
    4a6c:	00000000 	.word	0x00000000
    4a70:	2000e4ec 	.word	0x2000e4ec
    4a74:	00000004 	.word	0x00000004
    4a78:	00000000 	.word	0x00000000
    4a7c:	2000e110 	.word	0x2000e110
    4a80:	00000020 	.word	0x00000020
    4a84:	00000000 	.word	0x00000000
    4a88:	2000e130 	.word	0x2000e130
    4a8c:	00000020 	.word	0x00000020
    4a90:	00000000 	.word	0x00000000
    4a94:	2000e150 	.word	0x2000e150
    4a98:	00000020 	.word	0x00000020
    4a9c:	00000000 	.word	0x00000000
    4aa0:	2000d644 	.word	0x2000d644
    4aa4:	0000016c 	.word	0x0000016c
    4aa8:	00000001 	.word	0x00000001
    4aac:	00000043 	.word	0x00000043
	...
    4acc:	00000043 	.word	0x00000043
	...
    4aec:	00000043 	.word	0x00000043
	...
    4b0c:	00000043 	.word	0x00000043
	...
    4b2c:	00000043 	.word	0x00000043
	...
    4b4c:	00000043 	.word	0x00000043
	...
    4b6c:	00000043 	.word	0x00000043
	...
    4b8c:	00021391 	.word	0x00021391
    4b90:	000206a9 	.word	0x000206a9
    4b94:	00000000 	.word	0x00000000
    4b98:	00014194 	.word	0x00014194
    4b9c:	000220dd 	.word	0x000220dd
    4ba0:	000220dc 	.word	0x000220dc
    4ba4:	000220dc 	.word	0x000220dc
    4ba8:	000220dc 	.word	0x000220dc
    4bac:	000220dc 	.word	0x000220dc
    4bb0:	000220dc 	.word	0x000220dc
    4bb4:	000220dc 	.word	0x000220dc
    4bb8:	000220dc 	.word	0x000220dc
    4bbc:	000220dc 	.word	0x000220dc
    4bc0:	000220dc 	.word	0x000220dc
    4bc4:	ffffffff 	.word	0xffffffff
    4bc8:	ffffffff 	.word	0xffffffff
    4bcc:	ffffffff 	.word	0xffffffff
    4bd0:	0000ffff 	.word	0x0000ffff
    4bd4:	53410001 	.word	0x53410001
    4bd8:	00494943 	.word	0x00494943
	...
    4bf4:	53410000 	.word	0x53410000
    4bf8:	00494943 	.word	0x00494943
	...
    4c18:	20000000 	.word	0x20000000
    4c1c:	00000004 	.word	0x00000004
    4c20:	00000000 	.word	0x00000000
    4c24:	2000e4f0 	.word	0x2000e4f0
    4c28:	00000004 	.word	0x00000004
	...
    4c38:	22222222 	.word	0x22222222
    4c3c:	22222222 	.word	0x22222222
    4c40:	22222222 	.word	0x22222222

Disassembly of section .text._dtoa_r%185:

00004c48 <_dtoa_r>:
    4c48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4c4c:	ec55 4b10 	vmov	r4, r5, d0
    4c50:	b099      	sub	sp, #100	; 0x64
    4c52:	6a47      	ldr	r7, [r0, #36]	; 0x24
    4c54:	9108      	str	r1, [sp, #32]
    4c56:	4683      	mov	fp, r0
    4c58:	920d      	str	r2, [sp, #52]	; 0x34
    4c5a:	9314      	str	r3, [sp, #80]	; 0x50
    4c5c:	9e22      	ldr	r6, [sp, #136]	; 0x88
    4c5e:	e9cd 4504 	strd	r4, r5, [sp, #16]
    4c62:	b947      	cbnz	r7, 4c76 <_dtoa_r+0x2e>
    4c64:	2010      	movs	r0, #16
    4c66:	f01d f801 	bl	21c6c <malloc>
    4c6a:	e9c0 7701 	strd	r7, r7, [r0, #4]
    4c6e:	f8cb 0024 	str.w	r0, [fp, #36]	; 0x24
    4c72:	6007      	str	r7, [r0, #0]
    4c74:	60c7      	str	r7, [r0, #12]
    4c76:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
    4c7a:	6819      	ldr	r1, [r3, #0]
    4c7c:	b159      	cbz	r1, 4c96 <_dtoa_r+0x4e>
    4c7e:	685a      	ldr	r2, [r3, #4]
    4c80:	604a      	str	r2, [r1, #4]
    4c82:	2301      	movs	r3, #1
    4c84:	4093      	lsls	r3, r2
    4c86:	608b      	str	r3, [r1, #8]
    4c88:	4658      	mov	r0, fp
    4c8a:	f01a fdae 	bl	1f7ea <_Bfree>
    4c8e:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
    4c92:	2200      	movs	r2, #0
    4c94:	601a      	str	r2, [r3, #0]
    4c96:	2d00      	cmp	r5, #0
    4c98:	bfbf      	itttt	lt
    4c9a:	2301      	movlt	r3, #1
    4c9c:	6033      	strlt	r3, [r6, #0]
    4c9e:	f025 4300 	biclt.w	r3, r5, #2147483648	; 0x80000000
    4ca2:	9305      	strlt	r3, [sp, #20]
    4ca4:	bfa4      	itt	ge
    4ca6:	2300      	movge	r3, #0
    4ca8:	6033      	strge	r3, [r6, #0]
    4caa:	9c05      	ldr	r4, [sp, #20]
    4cac:	4bb2      	ldr	r3, [pc, #712]	; (4f78 <_dtoa_r+0x330>)
    4cae:	43a3      	bics	r3, r4
    4cb0:	d11a      	bne.n	4ce8 <_dtoa_r+0xa0>
    4cb2:	9a14      	ldr	r2, [sp, #80]	; 0x50
    4cb4:	f242 730f 	movw	r3, #9999	; 0x270f
    4cb8:	6013      	str	r3, [r2, #0]
    4cba:	9b04      	ldr	r3, [sp, #16]
    4cbc:	f3c4 0413 	ubfx	r4, r4, #0, #20
    4cc0:	4323      	orrs	r3, r4
    4cc2:	f000 854f 	beq.w	5764 <_dtoa_r+0xb1c>
    4cc6:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    4cc8:	b953      	cbnz	r3, 4ce0 <_dtoa_r+0x98>
    4cca:	4bac      	ldr	r3, [pc, #688]	; (4f7c <_dtoa_r+0x334>)
    4ccc:	e023      	b.n	4d16 <_dtoa_r+0xce>
    4cce:	4bac      	ldr	r3, [pc, #688]	; (4f80 <_dtoa_r+0x338>)
    4cd0:	9301      	str	r3, [sp, #4]
    4cd2:	3308      	adds	r3, #8
    4cd4:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    4cd6:	6013      	str	r3, [r2, #0]
    4cd8:	9801      	ldr	r0, [sp, #4]
    4cda:	b019      	add	sp, #100	; 0x64
    4cdc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4ce0:	4ba6      	ldr	r3, [pc, #664]	; (4f7c <_dtoa_r+0x334>)
    4ce2:	9301      	str	r3, [sp, #4]
    4ce4:	3303      	adds	r3, #3
    4ce6:	e7f5      	b.n	4cd4 <_dtoa_r+0x8c>
    4ce8:	ed9d 7b04 	vldr	d7, [sp, #16]
    4cec:	2200      	movs	r2, #0
    4cee:	2300      	movs	r3, #0
    4cf0:	ec51 0b17 	vmov	r0, r1, d7
    4cf4:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
    4cf8:	f00e ff84 	bl	13c04 <__aeabi_dcmpeq>
    4cfc:	4607      	mov	r7, r0
    4cfe:	b160      	cbz	r0, 4d1a <_dtoa_r+0xd2>
    4d00:	9a14      	ldr	r2, [sp, #80]	; 0x50
    4d02:	2301      	movs	r3, #1
    4d04:	6013      	str	r3, [r2, #0]
    4d06:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    4d08:	2b00      	cmp	r3, #0
    4d0a:	f000 8528 	beq.w	575e <_dtoa_r+0xb16>
    4d0e:	4b9d      	ldr	r3, [pc, #628]	; (4f84 <_dtoa_r+0x33c>)
    4d10:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    4d12:	6013      	str	r3, [r2, #0]
    4d14:	3b01      	subs	r3, #1
    4d16:	9301      	str	r3, [sp, #4]
    4d18:	e7de      	b.n	4cd8 <_dtoa_r+0x90>
    4d1a:	aa16      	add	r2, sp, #88	; 0x58
    4d1c:	a917      	add	r1, sp, #92	; 0x5c
    4d1e:	ed9d 0b0e 	vldr	d0, [sp, #56]	; 0x38
    4d22:	4658      	mov	r0, fp
    4d24:	f013 f80b 	bl	17d3e <__d2b>
    4d28:	f3c4 560a 	ubfx	r6, r4, #20, #11
    4d2c:	4680      	mov	r8, r0
    4d2e:	2e00      	cmp	r6, #0
    4d30:	d07f      	beq.n	4e32 <_dtoa_r+0x1ea>
    4d32:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    4d34:	9715      	str	r7, [sp, #84]	; 0x54
    4d36:	f3c3 0313 	ubfx	r3, r3, #0, #20
    4d3a:	e9dd 450e 	ldrd	r4, r5, [sp, #56]	; 0x38
    4d3e:	f043 557f 	orr.w	r5, r3, #1069547520	; 0x3fc00000
    4d42:	f445 1540 	orr.w	r5, r5, #3145728	; 0x300000
    4d46:	f2a6 36ff 	subw	r6, r6, #1023	; 0x3ff
    4d4a:	2200      	movs	r2, #0
    4d4c:	4b8e      	ldr	r3, [pc, #568]	; (4f88 <_dtoa_r+0x340>)
    4d4e:	4620      	mov	r0, r4
    4d50:	4629      	mov	r1, r5
    4d52:	f006 f9cd 	bl	b0f0 <__aeabi_dsub>
    4d56:	a382      	add	r3, pc, #520	; (adr r3, 4f60 <_dtoa_r+0x318>)
    4d58:	e9d3 2300 	ldrd	r2, r3, [r3]
    4d5c:	f005 f828 	bl	9db0 <__aeabi_dmul>
    4d60:	a381      	add	r3, pc, #516	; (adr r3, 4f68 <_dtoa_r+0x320>)
    4d62:	e9d3 2300 	ldrd	r2, r3, [r3]
    4d66:	f006 f9c5 	bl	b0f4 <__adddf3>
    4d6a:	4604      	mov	r4, r0
    4d6c:	4630      	mov	r0, r6
    4d6e:	460d      	mov	r5, r1
    4d70:	f006 fb0c 	bl	b38c <__aeabi_i2d>
    4d74:	a37e      	add	r3, pc, #504	; (adr r3, 4f70 <_dtoa_r+0x328>)
    4d76:	e9d3 2300 	ldrd	r2, r3, [r3]
    4d7a:	f005 f819 	bl	9db0 <__aeabi_dmul>
    4d7e:	4602      	mov	r2, r0
    4d80:	460b      	mov	r3, r1
    4d82:	4620      	mov	r0, r4
    4d84:	4629      	mov	r1, r5
    4d86:	f006 f9b5 	bl	b0f4 <__adddf3>
    4d8a:	4604      	mov	r4, r0
    4d8c:	460d      	mov	r5, r1
    4d8e:	f017 fd25 	bl	1c7dc <__aeabi_d2iz>
    4d92:	2200      	movs	r2, #0
    4d94:	4682      	mov	sl, r0
    4d96:	2300      	movs	r3, #0
    4d98:	4620      	mov	r0, r4
    4d9a:	4629      	mov	r1, r5
    4d9c:	f00e ff3c 	bl	13c18 <__aeabi_dcmplt>
    4da0:	b148      	cbz	r0, 4db6 <_dtoa_r+0x16e>
    4da2:	4650      	mov	r0, sl
    4da4:	f006 faf2 	bl	b38c <__aeabi_i2d>
    4da8:	4622      	mov	r2, r4
    4daa:	462b      	mov	r3, r5
    4dac:	f00e ff2a 	bl	13c04 <__aeabi_dcmpeq>
    4db0:	b908      	cbnz	r0, 4db6 <_dtoa_r+0x16e>
    4db2:	f10a 3aff 	add.w	sl, sl, #4294967295
    4db6:	f1ba 0f16 	cmp.w	sl, #22
    4dba:	d859      	bhi.n	4e70 <_dtoa_r+0x228>
    4dbc:	4b73      	ldr	r3, [pc, #460]	; (4f8c <_dtoa_r+0x344>)
    4dbe:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
    4dc2:	e9d3 2300 	ldrd	r2, r3, [r3]
    4dc6:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
    4dca:	f00e ff25 	bl	13c18 <__aeabi_dcmplt>
    4dce:	2800      	cmp	r0, #0
    4dd0:	d050      	beq.n	4e74 <_dtoa_r+0x22c>
    4dd2:	f10a 3aff 	add.w	sl, sl, #4294967295
    4dd6:	2300      	movs	r3, #0
    4dd8:	9311      	str	r3, [sp, #68]	; 0x44
    4dda:	9b16      	ldr	r3, [sp, #88]	; 0x58
    4ddc:	1b9e      	subs	r6, r3, r6
    4dde:	1e73      	subs	r3, r6, #1
    4de0:	9307      	str	r3, [sp, #28]
    4de2:	bf45      	ittet	mi
    4de4:	f1c6 0301 	rsbmi	r3, r6, #1
    4de8:	9306      	strmi	r3, [sp, #24]
    4dea:	2300      	movpl	r3, #0
    4dec:	2300      	movmi	r3, #0
    4dee:	bf4c      	ite	mi
    4df0:	9307      	strmi	r3, [sp, #28]
    4df2:	9306      	strpl	r3, [sp, #24]
    4df4:	f1ba 0f00 	cmp.w	sl, #0
    4df8:	db3e      	blt.n	4e78 <_dtoa_r+0x230>
    4dfa:	9b07      	ldr	r3, [sp, #28]
    4dfc:	f8cd a040 	str.w	sl, [sp, #64]	; 0x40
    4e00:	4453      	add	r3, sl
    4e02:	9307      	str	r3, [sp, #28]
    4e04:	2300      	movs	r3, #0
    4e06:	9309      	str	r3, [sp, #36]	; 0x24
    4e08:	9b08      	ldr	r3, [sp, #32]
    4e0a:	2b09      	cmp	r3, #9
    4e0c:	f200 808e 	bhi.w	4f2c <_dtoa_r+0x2e4>
    4e10:	2b05      	cmp	r3, #5
    4e12:	bfc4      	itt	gt
    4e14:	3b04      	subgt	r3, #4
    4e16:	9308      	strgt	r3, [sp, #32]
    4e18:	9b08      	ldr	r3, [sp, #32]
    4e1a:	f1a3 0302 	sub.w	r3, r3, #2
    4e1e:	bfcc      	ite	gt
    4e20:	2400      	movgt	r4, #0
    4e22:	2401      	movle	r4, #1
    4e24:	2b03      	cmp	r3, #3
    4e26:	f200 808c 	bhi.w	4f42 <_dtoa_r+0x2fa>
    4e2a:	e8df f003 	tbb	[pc, r3]
    4e2e:	712f      	.short	0x712f
    4e30:	7d6f      	.short	0x7d6f
    4e32:	e9dd 6316 	ldrd	r6, r3, [sp, #88]	; 0x58
    4e36:	441e      	add	r6, r3
    4e38:	f206 4032 	addw	r0, r6, #1074	; 0x432
    4e3c:	2820      	cmp	r0, #32
    4e3e:	dd11      	ble.n	4e64 <_dtoa_r+0x21c>
    4e40:	f1c0 0040 	rsb	r0, r0, #64	; 0x40
    4e44:	9b04      	ldr	r3, [sp, #16]
    4e46:	4084      	lsls	r4, r0
    4e48:	f206 4012 	addw	r0, r6, #1042	; 0x412
    4e4c:	fa23 f000 	lsr.w	r0, r3, r0
    4e50:	4320      	orrs	r0, r4
    4e52:	f006 fa8b 	bl	b36c <__aeabi_ui2d>
    4e56:	2301      	movs	r3, #1
    4e58:	4604      	mov	r4, r0
    4e5a:	f1a1 75f8 	sub.w	r5, r1, #32505856	; 0x1f00000
    4e5e:	3e01      	subs	r6, #1
    4e60:	9315      	str	r3, [sp, #84]	; 0x54
    4e62:	e772      	b.n	4d4a <_dtoa_r+0x102>
    4e64:	9b04      	ldr	r3, [sp, #16]
    4e66:	f1c0 0020 	rsb	r0, r0, #32
    4e6a:	fa03 f000 	lsl.w	r0, r3, r0
    4e6e:	e7f0      	b.n	4e52 <_dtoa_r+0x20a>
    4e70:	2301      	movs	r3, #1
    4e72:	e7b1      	b.n	4dd8 <_dtoa_r+0x190>
    4e74:	9011      	str	r0, [sp, #68]	; 0x44
    4e76:	e7b0      	b.n	4dda <_dtoa_r+0x192>
    4e78:	9b06      	ldr	r3, [sp, #24]
    4e7a:	eba3 030a 	sub.w	r3, r3, sl
    4e7e:	9306      	str	r3, [sp, #24]
    4e80:	f1ca 0300 	rsb	r3, sl, #0
    4e84:	9309      	str	r3, [sp, #36]	; 0x24
    4e86:	2300      	movs	r3, #0
    4e88:	9310      	str	r3, [sp, #64]	; 0x40
    4e8a:	e7bd      	b.n	4e08 <_dtoa_r+0x1c0>
    4e8c:	2300      	movs	r3, #0
    4e8e:	930c      	str	r3, [sp, #48]	; 0x30
    4e90:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    4e92:	2b00      	cmp	r3, #0
    4e94:	dc59      	bgt.n	4f4a <_dtoa_r+0x302>
    4e96:	2301      	movs	r3, #1
    4e98:	9302      	str	r3, [sp, #8]
    4e9a:	4699      	mov	r9, r3
    4e9c:	930d      	str	r3, [sp, #52]	; 0x34
    4e9e:	f8db 5024 	ldr.w	r5, [fp, #36]	; 0x24
    4ea2:	2200      	movs	r2, #0
    4ea4:	606a      	str	r2, [r5, #4]
    4ea6:	2204      	movs	r2, #4
    4ea8:	f102 0014 	add.w	r0, r2, #20
    4eac:	4298      	cmp	r0, r3
    4eae:	6869      	ldr	r1, [r5, #4]
    4eb0:	d94f      	bls.n	4f52 <_dtoa_r+0x30a>
    4eb2:	4658      	mov	r0, fp
    4eb4:	f016 f89e 	bl	1aff4 <_Balloc>
    4eb8:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
    4ebc:	6028      	str	r0, [r5, #0]
    4ebe:	681b      	ldr	r3, [r3, #0]
    4ec0:	9301      	str	r3, [sp, #4]
    4ec2:	f1b9 0f0e 	cmp.w	r9, #14
    4ec6:	f200 80e6 	bhi.w	5096 <_dtoa_r+0x44e>
    4eca:	2c00      	cmp	r4, #0
    4ecc:	f000 80e3 	beq.w	5096 <_dtoa_r+0x44e>
    4ed0:	f1ba 0f00 	cmp.w	sl, #0
    4ed4:	dd78      	ble.n	4fc8 <_dtoa_r+0x380>
    4ed6:	4a2d      	ldr	r2, [pc, #180]	; (4f8c <_dtoa_r+0x344>)
    4ed8:	f00a 030f 	and.w	r3, sl, #15
    4edc:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    4ee0:	ed93 7b00 	vldr	d7, [r3]
    4ee4:	ea4f 142a 	mov.w	r4, sl, asr #4
    4ee8:	06e2      	lsls	r2, r4, #27
    4eea:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
    4eee:	d569      	bpl.n	4fc4 <_dtoa_r+0x37c>
    4ef0:	4b27      	ldr	r3, [pc, #156]	; (4f90 <_dtoa_r+0x348>)
    4ef2:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
    4ef6:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
    4efa:	f005 f883 	bl	a004 <__aeabi_ddiv>
    4efe:	e9cd 0104 	strd	r0, r1, [sp, #16]
    4f02:	f004 040f 	and.w	r4, r4, #15
    4f06:	2603      	movs	r6, #3
    4f08:	4d21      	ldr	r5, [pc, #132]	; (4f90 <_dtoa_r+0x348>)
    4f0a:	e050      	b.n	4fae <_dtoa_r+0x366>
    4f0c:	2301      	movs	r3, #1
    4f0e:	e7be      	b.n	4e8e <_dtoa_r+0x246>
    4f10:	2300      	movs	r3, #0
    4f12:	930c      	str	r3, [sp, #48]	; 0x30
    4f14:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    4f16:	4453      	add	r3, sl
    4f18:	f103 0901 	add.w	r9, r3, #1
    4f1c:	9302      	str	r3, [sp, #8]
    4f1e:	464b      	mov	r3, r9
    4f20:	2b01      	cmp	r3, #1
    4f22:	bfb8      	it	lt
    4f24:	2301      	movlt	r3, #1
    4f26:	e7ba      	b.n	4e9e <_dtoa_r+0x256>
    4f28:	2301      	movs	r3, #1
    4f2a:	e7f2      	b.n	4f12 <_dtoa_r+0x2ca>
    4f2c:	2300      	movs	r3, #0
    4f2e:	2401      	movs	r4, #1
    4f30:	9308      	str	r3, [sp, #32]
    4f32:	940c      	str	r4, [sp, #48]	; 0x30
    4f34:	3b01      	subs	r3, #1
    4f36:	2200      	movs	r2, #0
    4f38:	9302      	str	r3, [sp, #8]
    4f3a:	4699      	mov	r9, r3
    4f3c:	920d      	str	r2, [sp, #52]	; 0x34
    4f3e:	2312      	movs	r3, #18
    4f40:	e7ad      	b.n	4e9e <_dtoa_r+0x256>
    4f42:	2301      	movs	r3, #1
    4f44:	930c      	str	r3, [sp, #48]	; 0x30
    4f46:	3b02      	subs	r3, #2
    4f48:	e7f5      	b.n	4f36 <_dtoa_r+0x2ee>
    4f4a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    4f4c:	9302      	str	r3, [sp, #8]
    4f4e:	4699      	mov	r9, r3
    4f50:	e7a5      	b.n	4e9e <_dtoa_r+0x256>
    4f52:	3101      	adds	r1, #1
    4f54:	6069      	str	r1, [r5, #4]
    4f56:	0052      	lsls	r2, r2, #1
    4f58:	e7a6      	b.n	4ea8 <_dtoa_r+0x260>
    4f5a:	bf00      	nop
    4f5c:	f3af 8000 	nop.w
    4f60:	636f4361 	.word	0x636f4361
    4f64:	3fd287a7 	.word	0x3fd287a7
    4f68:	8b60c8b3 	.word	0x8b60c8b3
    4f6c:	3fc68a28 	.word	0x3fc68a28
    4f70:	509f79fb 	.word	0x509f79fb
    4f74:	3fd34413 	.word	0x3fd34413
    4f78:	7ff00000 	.word	0x7ff00000
    4f7c:	00021ce5 	.word	0x00021ce5
    4f80:	00021cdc 	.word	0x00021cdc
    4f84:	00021cea 	.word	0x00021cea
    4f88:	3ff80000 	.word	0x3ff80000
    4f8c:	00015e10 	.word	0x00015e10
    4f90:	000201e0 	.word	0x000201e0
    4f94:	07e3      	lsls	r3, r4, #31
    4f96:	d508      	bpl.n	4faa <_dtoa_r+0x362>
    4f98:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    4f9c:	e9d5 2300 	ldrd	r2, r3, [r5]
    4fa0:	f004 ff06 	bl	9db0 <__aeabi_dmul>
    4fa4:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
    4fa8:	3601      	adds	r6, #1
    4faa:	1064      	asrs	r4, r4, #1
    4fac:	3508      	adds	r5, #8
    4fae:	2c00      	cmp	r4, #0
    4fb0:	d1f0      	bne.n	4f94 <_dtoa_r+0x34c>
    4fb2:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
    4fb6:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    4fba:	f005 f823 	bl	a004 <__aeabi_ddiv>
    4fbe:	e9cd 0104 	strd	r0, r1, [sp, #16]
    4fc2:	e01a      	b.n	4ffa <_dtoa_r+0x3b2>
    4fc4:	2602      	movs	r6, #2
    4fc6:	e79f      	b.n	4f08 <_dtoa_r+0x2c0>
    4fc8:	f000 809f 	beq.w	510a <_dtoa_r+0x4c2>
    4fcc:	f1ca 0400 	rsb	r4, sl, #0
    4fd0:	4b9f      	ldr	r3, [pc, #636]	; (5250 <_dtoa_r+0x608>)
    4fd2:	4da0      	ldr	r5, [pc, #640]	; (5254 <_dtoa_r+0x60c>)
    4fd4:	f004 020f 	and.w	r2, r4, #15
    4fd8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    4fdc:	e9d3 2300 	ldrd	r2, r3, [r3]
    4fe0:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
    4fe4:	f004 fee4 	bl	9db0 <__aeabi_dmul>
    4fe8:	e9cd 0104 	strd	r0, r1, [sp, #16]
    4fec:	1124      	asrs	r4, r4, #4
    4fee:	2300      	movs	r3, #0
    4ff0:	2602      	movs	r6, #2
    4ff2:	2c00      	cmp	r4, #0
    4ff4:	d17e      	bne.n	50f4 <_dtoa_r+0x4ac>
    4ff6:	2b00      	cmp	r3, #0
    4ff8:	d1e1      	bne.n	4fbe <_dtoa_r+0x376>
    4ffa:	9b11      	ldr	r3, [sp, #68]	; 0x44
    4ffc:	2b00      	cmp	r3, #0
    4ffe:	f000 8086 	beq.w	510e <_dtoa_r+0x4c6>
    5002:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
    5006:	2200      	movs	r2, #0
    5008:	4b93      	ldr	r3, [pc, #588]	; (5258 <_dtoa_r+0x610>)
    500a:	4620      	mov	r0, r4
    500c:	4629      	mov	r1, r5
    500e:	f00e fe03 	bl	13c18 <__aeabi_dcmplt>
    5012:	2800      	cmp	r0, #0
    5014:	d07b      	beq.n	510e <_dtoa_r+0x4c6>
    5016:	f1b9 0f00 	cmp.w	r9, #0
    501a:	d078      	beq.n	510e <_dtoa_r+0x4c6>
    501c:	9b02      	ldr	r3, [sp, #8]
    501e:	2b00      	cmp	r3, #0
    5020:	dd35      	ble.n	508e <_dtoa_r+0x446>
    5022:	f10a 33ff 	add.w	r3, sl, #4294967295
    5026:	930a      	str	r3, [sp, #40]	; 0x28
    5028:	4620      	mov	r0, r4
    502a:	2200      	movs	r2, #0
    502c:	4b8b      	ldr	r3, [pc, #556]	; (525c <_dtoa_r+0x614>)
    502e:	4629      	mov	r1, r5
    5030:	f004 febe 	bl	9db0 <__aeabi_dmul>
    5034:	e9cd 0104 	strd	r0, r1, [sp, #16]
    5038:	9c02      	ldr	r4, [sp, #8]
    503a:	3601      	adds	r6, #1
    503c:	4630      	mov	r0, r6
    503e:	f006 f9a5 	bl	b38c <__aeabi_i2d>
    5042:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    5046:	f004 feb3 	bl	9db0 <__aeabi_dmul>
    504a:	2200      	movs	r2, #0
    504c:	4b84      	ldr	r3, [pc, #528]	; (5260 <_dtoa_r+0x618>)
    504e:	f006 f851 	bl	b0f4 <__adddf3>
    5052:	4606      	mov	r6, r0
    5054:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
    5058:	2c00      	cmp	r4, #0
    505a:	d15c      	bne.n	5116 <_dtoa_r+0x4ce>
    505c:	2200      	movs	r2, #0
    505e:	4b81      	ldr	r3, [pc, #516]	; (5264 <_dtoa_r+0x61c>)
    5060:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    5064:	f006 f844 	bl	b0f0 <__aeabi_dsub>
    5068:	4632      	mov	r2, r6
    506a:	463b      	mov	r3, r7
    506c:	e9cd 0104 	strd	r0, r1, [sp, #16]
    5070:	f00e fdf0 	bl	13c54 <__aeabi_dcmpgt>
    5074:	2800      	cmp	r0, #0
    5076:	f040 8289 	bne.w	558c <_dtoa_r+0x944>
    507a:	4632      	mov	r2, r6
    507c:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
    5080:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    5084:	f00e fdc8 	bl	13c18 <__aeabi_dcmplt>
    5088:	2800      	cmp	r0, #0
    508a:	f040 827d 	bne.w	5588 <_dtoa_r+0x940>
    508e:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
    5092:	e9cd 3404 	strd	r3, r4, [sp, #16]
    5096:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    5098:	2b00      	cmp	r3, #0
    509a:	f2c0 814f 	blt.w	533c <_dtoa_r+0x6f4>
    509e:	f1ba 0f0e 	cmp.w	sl, #14
    50a2:	f300 814b 	bgt.w	533c <_dtoa_r+0x6f4>
    50a6:	4b6a      	ldr	r3, [pc, #424]	; (5250 <_dtoa_r+0x608>)
    50a8:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
    50ac:	ed93 7b00 	vldr	d7, [r3]
    50b0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    50b2:	2b00      	cmp	r3, #0
    50b4:	ed8d 7b02 	vstr	d7, [sp, #8]
    50b8:	f280 80d8 	bge.w	526c <_dtoa_r+0x624>
    50bc:	f1b9 0f00 	cmp.w	r9, #0
    50c0:	f300 80d4 	bgt.w	526c <_dtoa_r+0x624>
    50c4:	f040 825f 	bne.w	5586 <_dtoa_r+0x93e>
    50c8:	2200      	movs	r2, #0
    50ca:	4b66      	ldr	r3, [pc, #408]	; (5264 <_dtoa_r+0x61c>)
    50cc:	ec51 0b17 	vmov	r0, r1, d7
    50d0:	f004 fe6e 	bl	9db0 <__aeabi_dmul>
    50d4:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    50d8:	f00e fdb2 	bl	13c40 <__aeabi_dcmpge>
    50dc:	464c      	mov	r4, r9
    50de:	464e      	mov	r6, r9
    50e0:	2800      	cmp	r0, #0
    50e2:	f040 8238 	bne.w	5556 <_dtoa_r+0x90e>
    50e6:	9d01      	ldr	r5, [sp, #4]
    50e8:	2331      	movs	r3, #49	; 0x31
    50ea:	f805 3b01 	strb.w	r3, [r5], #1
    50ee:	f10a 0a01 	add.w	sl, sl, #1
    50f2:	e234      	b.n	555e <_dtoa_r+0x916>
    50f4:	07e7      	lsls	r7, r4, #31
    50f6:	d505      	bpl.n	5104 <_dtoa_r+0x4bc>
    50f8:	e9d5 2300 	ldrd	r2, r3, [r5]
    50fc:	f004 fe58 	bl	9db0 <__aeabi_dmul>
    5100:	3601      	adds	r6, #1
    5102:	2301      	movs	r3, #1
    5104:	1064      	asrs	r4, r4, #1
    5106:	3508      	adds	r5, #8
    5108:	e773      	b.n	4ff2 <_dtoa_r+0x3aa>
    510a:	2602      	movs	r6, #2
    510c:	e775      	b.n	4ffa <_dtoa_r+0x3b2>
    510e:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
    5112:	464c      	mov	r4, r9
    5114:	e792      	b.n	503c <_dtoa_r+0x3f4>
    5116:	4b4e      	ldr	r3, [pc, #312]	; (5250 <_dtoa_r+0x608>)
    5118:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
    511c:	e953 0102 	ldrd	r0, r1, [r3, #-8]
    5120:	9b01      	ldr	r3, [sp, #4]
    5122:	441c      	add	r4, r3
    5124:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5126:	2b00      	cmp	r3, #0
    5128:	d046      	beq.n	51b8 <_dtoa_r+0x570>
    512a:	4602      	mov	r2, r0
    512c:	460b      	mov	r3, r1
    512e:	2000      	movs	r0, #0
    5130:	494d      	ldr	r1, [pc, #308]	; (5268 <_dtoa_r+0x620>)
    5132:	f004 ff67 	bl	a004 <__aeabi_ddiv>
    5136:	4632      	mov	r2, r6
    5138:	463b      	mov	r3, r7
    513a:	f005 ffd9 	bl	b0f0 <__aeabi_dsub>
    513e:	9d01      	ldr	r5, [sp, #4]
    5140:	4606      	mov	r6, r0
    5142:	460f      	mov	r7, r1
    5144:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    5148:	f017 fb48 	bl	1c7dc <__aeabi_d2iz>
    514c:	9012      	str	r0, [sp, #72]	; 0x48
    514e:	f006 f91d 	bl	b38c <__aeabi_i2d>
    5152:	4602      	mov	r2, r0
    5154:	460b      	mov	r3, r1
    5156:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    515a:	f005 ffc9 	bl	b0f0 <__aeabi_dsub>
    515e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    5160:	3330      	adds	r3, #48	; 0x30
    5162:	f805 3b01 	strb.w	r3, [r5], #1
    5166:	4632      	mov	r2, r6
    5168:	463b      	mov	r3, r7
    516a:	e9cd 0104 	strd	r0, r1, [sp, #16]
    516e:	f00e fd53 	bl	13c18 <__aeabi_dcmplt>
    5172:	2800      	cmp	r0, #0
    5174:	d160      	bne.n	5238 <_dtoa_r+0x5f0>
    5176:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    517a:	2000      	movs	r0, #0
    517c:	4936      	ldr	r1, [pc, #216]	; (5258 <_dtoa_r+0x610>)
    517e:	f005 ffb7 	bl	b0f0 <__aeabi_dsub>
    5182:	4632      	mov	r2, r6
    5184:	463b      	mov	r3, r7
    5186:	f00e fd47 	bl	13c18 <__aeabi_dcmplt>
    518a:	2800      	cmp	r0, #0
    518c:	f040 80b4 	bne.w	52f8 <_dtoa_r+0x6b0>
    5190:	42a5      	cmp	r5, r4
    5192:	f43f af7c 	beq.w	508e <_dtoa_r+0x446>
    5196:	2200      	movs	r2, #0
    5198:	4b30      	ldr	r3, [pc, #192]	; (525c <_dtoa_r+0x614>)
    519a:	4630      	mov	r0, r6
    519c:	4639      	mov	r1, r7
    519e:	f004 fe07 	bl	9db0 <__aeabi_dmul>
    51a2:	2200      	movs	r2, #0
    51a4:	4606      	mov	r6, r0
    51a6:	460f      	mov	r7, r1
    51a8:	4b2c      	ldr	r3, [pc, #176]	; (525c <_dtoa_r+0x614>)
    51aa:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    51ae:	f004 fdff 	bl	9db0 <__aeabi_dmul>
    51b2:	e9cd 0104 	strd	r0, r1, [sp, #16]
    51b6:	e7c5      	b.n	5144 <_dtoa_r+0x4fc>
    51b8:	4632      	mov	r2, r6
    51ba:	463b      	mov	r3, r7
    51bc:	f004 fdf8 	bl	9db0 <__aeabi_dmul>
    51c0:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
    51c4:	9e01      	ldr	r6, [sp, #4]
    51c6:	4625      	mov	r5, r4
    51c8:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    51cc:	f017 fb06 	bl	1c7dc <__aeabi_d2iz>
    51d0:	4607      	mov	r7, r0
    51d2:	f006 f8db 	bl	b38c <__aeabi_i2d>
    51d6:	3730      	adds	r7, #48	; 0x30
    51d8:	4602      	mov	r2, r0
    51da:	460b      	mov	r3, r1
    51dc:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    51e0:	f005 ff86 	bl	b0f0 <__aeabi_dsub>
    51e4:	f806 7b01 	strb.w	r7, [r6], #1
    51e8:	42a6      	cmp	r6, r4
    51ea:	e9cd 0104 	strd	r0, r1, [sp, #16]
    51ee:	f04f 0200 	mov.w	r2, #0
    51f2:	d126      	bne.n	5242 <_dtoa_r+0x5fa>
    51f4:	4b1c      	ldr	r3, [pc, #112]	; (5268 <_dtoa_r+0x620>)
    51f6:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
    51fa:	f005 ff7b 	bl	b0f4 <__adddf3>
    51fe:	4602      	mov	r2, r0
    5200:	460b      	mov	r3, r1
    5202:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    5206:	f00e fd25 	bl	13c54 <__aeabi_dcmpgt>
    520a:	2800      	cmp	r0, #0
    520c:	d174      	bne.n	52f8 <_dtoa_r+0x6b0>
    520e:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
    5212:	2000      	movs	r0, #0
    5214:	4914      	ldr	r1, [pc, #80]	; (5268 <_dtoa_r+0x620>)
    5216:	f005 ff6b 	bl	b0f0 <__aeabi_dsub>
    521a:	4602      	mov	r2, r0
    521c:	460b      	mov	r3, r1
    521e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    5222:	f00e fcf9 	bl	13c18 <__aeabi_dcmplt>
    5226:	2800      	cmp	r0, #0
    5228:	f43f af31 	beq.w	508e <_dtoa_r+0x446>
    522c:	f815 3c01 	ldrb.w	r3, [r5, #-1]
    5230:	2b30      	cmp	r3, #48	; 0x30
    5232:	f105 32ff 	add.w	r2, r5, #4294967295
    5236:	d002      	beq.n	523e <_dtoa_r+0x5f6>
    5238:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
    523c:	e04a      	b.n	52d4 <_dtoa_r+0x68c>
    523e:	4615      	mov	r5, r2
    5240:	e7f4      	b.n	522c <_dtoa_r+0x5e4>
    5242:	4b06      	ldr	r3, [pc, #24]	; (525c <_dtoa_r+0x614>)
    5244:	f004 fdb4 	bl	9db0 <__aeabi_dmul>
    5248:	e9cd 0104 	strd	r0, r1, [sp, #16]
    524c:	e7bc      	b.n	51c8 <_dtoa_r+0x580>
    524e:	bf00      	nop
    5250:	00015e10 	.word	0x00015e10
    5254:	000201e0 	.word	0x000201e0
    5258:	3ff00000 	.word	0x3ff00000
    525c:	40240000 	.word	0x40240000
    5260:	401c0000 	.word	0x401c0000
    5264:	40140000 	.word	0x40140000
    5268:	3fe00000 	.word	0x3fe00000
    526c:	e9dd 6704 	ldrd	r6, r7, [sp, #16]
    5270:	9d01      	ldr	r5, [sp, #4]
    5272:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    5276:	4630      	mov	r0, r6
    5278:	4639      	mov	r1, r7
    527a:	f004 fec3 	bl	a004 <__aeabi_ddiv>
    527e:	f017 faad 	bl	1c7dc <__aeabi_d2iz>
    5282:	4604      	mov	r4, r0
    5284:	f006 f882 	bl	b38c <__aeabi_i2d>
    5288:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    528c:	f004 fd90 	bl	9db0 <__aeabi_dmul>
    5290:	4602      	mov	r2, r0
    5292:	460b      	mov	r3, r1
    5294:	4630      	mov	r0, r6
    5296:	4639      	mov	r1, r7
    5298:	f104 0630 	add.w	r6, r4, #48	; 0x30
    529c:	f005 ff28 	bl	b0f0 <__aeabi_dsub>
    52a0:	f805 6b01 	strb.w	r6, [r5], #1
    52a4:	9e01      	ldr	r6, [sp, #4]
    52a6:	1bae      	subs	r6, r5, r6
    52a8:	45b1      	cmp	r9, r6
    52aa:	4602      	mov	r2, r0
    52ac:	460b      	mov	r3, r1
    52ae:	d138      	bne.n	5322 <_dtoa_r+0x6da>
    52b0:	f005 ff20 	bl	b0f4 <__adddf3>
    52b4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    52b8:	4606      	mov	r6, r0
    52ba:	460f      	mov	r7, r1
    52bc:	f00e fcca 	bl	13c54 <__aeabi_dcmpgt>
    52c0:	b9c0      	cbnz	r0, 52f4 <_dtoa_r+0x6ac>
    52c2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    52c6:	4630      	mov	r0, r6
    52c8:	4639      	mov	r1, r7
    52ca:	f00e fc9b 	bl	13c04 <__aeabi_dcmpeq>
    52ce:	b108      	cbz	r0, 52d4 <_dtoa_r+0x68c>
    52d0:	07e1      	lsls	r1, r4, #31
    52d2:	d40f      	bmi.n	52f4 <_dtoa_r+0x6ac>
    52d4:	4641      	mov	r1, r8
    52d6:	4658      	mov	r0, fp
    52d8:	f01a fa87 	bl	1f7ea <_Bfree>
    52dc:	2300      	movs	r3, #0
    52de:	9a14      	ldr	r2, [sp, #80]	; 0x50
    52e0:	702b      	strb	r3, [r5, #0]
    52e2:	f10a 0301 	add.w	r3, sl, #1
    52e6:	6013      	str	r3, [r2, #0]
    52e8:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    52ea:	2b00      	cmp	r3, #0
    52ec:	f43f acf4 	beq.w	4cd8 <_dtoa_r+0x90>
    52f0:	601d      	str	r5, [r3, #0]
    52f2:	e4f1      	b.n	4cd8 <_dtoa_r+0x90>
    52f4:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
    52f8:	f815 2c01 	ldrb.w	r2, [r5, #-1]
    52fc:	2a39      	cmp	r2, #57	; 0x39
    52fe:	f105 33ff 	add.w	r3, r5, #4294967295
    5302:	d108      	bne.n	5316 <_dtoa_r+0x6ce>
    5304:	9a01      	ldr	r2, [sp, #4]
    5306:	429a      	cmp	r2, r3
    5308:	d109      	bne.n	531e <_dtoa_r+0x6d6>
    530a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    530c:	9901      	ldr	r1, [sp, #4]
    530e:	3201      	adds	r2, #1
    5310:	920a      	str	r2, [sp, #40]	; 0x28
    5312:	2230      	movs	r2, #48	; 0x30
    5314:	700a      	strb	r2, [r1, #0]
    5316:	781a      	ldrb	r2, [r3, #0]
    5318:	3201      	adds	r2, #1
    531a:	701a      	strb	r2, [r3, #0]
    531c:	e78c      	b.n	5238 <_dtoa_r+0x5f0>
    531e:	461d      	mov	r5, r3
    5320:	e7ea      	b.n	52f8 <_dtoa_r+0x6b0>
    5322:	2200      	movs	r2, #0
    5324:	4b9b      	ldr	r3, [pc, #620]	; (5594 <_dtoa_r+0x94c>)
    5326:	f004 fd43 	bl	9db0 <__aeabi_dmul>
    532a:	2200      	movs	r2, #0
    532c:	2300      	movs	r3, #0
    532e:	4606      	mov	r6, r0
    5330:	460f      	mov	r7, r1
    5332:	f00e fc67 	bl	13c04 <__aeabi_dcmpeq>
    5336:	2800      	cmp	r0, #0
    5338:	d09b      	beq.n	5272 <_dtoa_r+0x62a>
    533a:	e7cb      	b.n	52d4 <_dtoa_r+0x68c>
    533c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    533e:	2a00      	cmp	r2, #0
    5340:	f000 80cb 	beq.w	54da <_dtoa_r+0x892>
    5344:	9a08      	ldr	r2, [sp, #32]
    5346:	2a01      	cmp	r2, #1
    5348:	f300 80ae 	bgt.w	54a8 <_dtoa_r+0x860>
    534c:	9a15      	ldr	r2, [sp, #84]	; 0x54
    534e:	2a00      	cmp	r2, #0
    5350:	f000 80a6 	beq.w	54a0 <_dtoa_r+0x858>
    5354:	f203 4333 	addw	r3, r3, #1075	; 0x433
    5358:	9c09      	ldr	r4, [sp, #36]	; 0x24
    535a:	9d06      	ldr	r5, [sp, #24]
    535c:	9a06      	ldr	r2, [sp, #24]
    535e:	441a      	add	r2, r3
    5360:	9206      	str	r2, [sp, #24]
    5362:	9a07      	ldr	r2, [sp, #28]
    5364:	2101      	movs	r1, #1
    5366:	441a      	add	r2, r3
    5368:	4658      	mov	r0, fp
    536a:	9207      	str	r2, [sp, #28]
    536c:	f01c fbc4 	bl	21af8 <__i2b>
    5370:	4606      	mov	r6, r0
    5372:	2d00      	cmp	r5, #0
    5374:	dd0c      	ble.n	5390 <_dtoa_r+0x748>
    5376:	9b07      	ldr	r3, [sp, #28]
    5378:	2b00      	cmp	r3, #0
    537a:	dd09      	ble.n	5390 <_dtoa_r+0x748>
    537c:	42ab      	cmp	r3, r5
    537e:	9a06      	ldr	r2, [sp, #24]
    5380:	bfa8      	it	ge
    5382:	462b      	movge	r3, r5
    5384:	1ad2      	subs	r2, r2, r3
    5386:	9206      	str	r2, [sp, #24]
    5388:	9a07      	ldr	r2, [sp, #28]
    538a:	1aed      	subs	r5, r5, r3
    538c:	1ad3      	subs	r3, r2, r3
    538e:	9307      	str	r3, [sp, #28]
    5390:	9b09      	ldr	r3, [sp, #36]	; 0x24
    5392:	b1f3      	cbz	r3, 53d2 <_dtoa_r+0x78a>
    5394:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5396:	2b00      	cmp	r3, #0
    5398:	f000 80a3 	beq.w	54e2 <_dtoa_r+0x89a>
    539c:	2c00      	cmp	r4, #0
    539e:	dd10      	ble.n	53c2 <_dtoa_r+0x77a>
    53a0:	4631      	mov	r1, r6
    53a2:	4622      	mov	r2, r4
    53a4:	4658      	mov	r0, fp
    53a6:	f012 fe03 	bl	17fb0 <__pow5mult>
    53aa:	4642      	mov	r2, r8
    53ac:	4601      	mov	r1, r0
    53ae:	4606      	mov	r6, r0
    53b0:	4658      	mov	r0, fp
    53b2:	f00d fa35 	bl	12820 <__multiply>
    53b6:	4641      	mov	r1, r8
    53b8:	4607      	mov	r7, r0
    53ba:	4658      	mov	r0, fp
    53bc:	f01a fa15 	bl	1f7ea <_Bfree>
    53c0:	46b8      	mov	r8, r7
    53c2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    53c4:	1b1a      	subs	r2, r3, r4
    53c6:	d004      	beq.n	53d2 <_dtoa_r+0x78a>
    53c8:	4641      	mov	r1, r8
    53ca:	4658      	mov	r0, fp
    53cc:	f012 fdf0 	bl	17fb0 <__pow5mult>
    53d0:	4680      	mov	r8, r0
    53d2:	2101      	movs	r1, #1
    53d4:	4658      	mov	r0, fp
    53d6:	f01c fb8f 	bl	21af8 <__i2b>
    53da:	9b10      	ldr	r3, [sp, #64]	; 0x40
    53dc:	2b00      	cmp	r3, #0
    53de:	4604      	mov	r4, r0
    53e0:	f340 8081 	ble.w	54e6 <_dtoa_r+0x89e>
    53e4:	461a      	mov	r2, r3
    53e6:	4601      	mov	r1, r0
    53e8:	4658      	mov	r0, fp
    53ea:	f012 fde1 	bl	17fb0 <__pow5mult>
    53ee:	9b08      	ldr	r3, [sp, #32]
    53f0:	2b01      	cmp	r3, #1
    53f2:	4604      	mov	r4, r0
    53f4:	dd7a      	ble.n	54ec <_dtoa_r+0x8a4>
    53f6:	2700      	movs	r7, #0
    53f8:	6923      	ldr	r3, [r4, #16]
    53fa:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    53fe:	6918      	ldr	r0, [r3, #16]
    5400:	f018 fd18 	bl	1de34 <__hi0bits>
    5404:	f1c0 0020 	rsb	r0, r0, #32
    5408:	9b07      	ldr	r3, [sp, #28]
    540a:	4418      	add	r0, r3
    540c:	f010 001f 	ands.w	r0, r0, #31
    5410:	f000 8088 	beq.w	5524 <_dtoa_r+0x8dc>
    5414:	f1c0 0320 	rsb	r3, r0, #32
    5418:	2b04      	cmp	r3, #4
    541a:	f340 8081 	ble.w	5520 <_dtoa_r+0x8d8>
    541e:	f1c0 001c 	rsb	r0, r0, #28
    5422:	9b06      	ldr	r3, [sp, #24]
    5424:	4403      	add	r3, r0
    5426:	9306      	str	r3, [sp, #24]
    5428:	9b07      	ldr	r3, [sp, #28]
    542a:	4403      	add	r3, r0
    542c:	4405      	add	r5, r0
    542e:	9307      	str	r3, [sp, #28]
    5430:	9b06      	ldr	r3, [sp, #24]
    5432:	2b00      	cmp	r3, #0
    5434:	dd05      	ble.n	5442 <_dtoa_r+0x7fa>
    5436:	4641      	mov	r1, r8
    5438:	461a      	mov	r2, r3
    543a:	4658      	mov	r0, fp
    543c:	f012 f950 	bl	176e0 <__lshift>
    5440:	4680      	mov	r8, r0
    5442:	9b07      	ldr	r3, [sp, #28]
    5444:	2b00      	cmp	r3, #0
    5446:	dd05      	ble.n	5454 <_dtoa_r+0x80c>
    5448:	4621      	mov	r1, r4
    544a:	461a      	mov	r2, r3
    544c:	4658      	mov	r0, fp
    544e:	f012 f947 	bl	176e0 <__lshift>
    5452:	4604      	mov	r4, r0
    5454:	9b11      	ldr	r3, [sp, #68]	; 0x44
    5456:	2b00      	cmp	r3, #0
    5458:	d066      	beq.n	5528 <_dtoa_r+0x8e0>
    545a:	4621      	mov	r1, r4
    545c:	4640      	mov	r0, r8
    545e:	f019 fd33 	bl	1eec8 <__mcmp>
    5462:	2800      	cmp	r0, #0
    5464:	da60      	bge.n	5528 <_dtoa_r+0x8e0>
    5466:	2300      	movs	r3, #0
    5468:	4641      	mov	r1, r8
    546a:	220a      	movs	r2, #10
    546c:	4658      	mov	r0, fp
    546e:	f014 f996 	bl	1979e <__multadd>
    5472:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5474:	f10a 3aff 	add.w	sl, sl, #4294967295
    5478:	4680      	mov	r8, r0
    547a:	2b00      	cmp	r3, #0
    547c:	f000 8179 	beq.w	5772 <_dtoa_r+0xb2a>
    5480:	2300      	movs	r3, #0
    5482:	4631      	mov	r1, r6
    5484:	220a      	movs	r2, #10
    5486:	4658      	mov	r0, fp
    5488:	f014 f989 	bl	1979e <__multadd>
    548c:	9b02      	ldr	r3, [sp, #8]
    548e:	2b00      	cmp	r3, #0
    5490:	4606      	mov	r6, r0
    5492:	f300 8089 	bgt.w	55a8 <_dtoa_r+0x960>
    5496:	9b08      	ldr	r3, [sp, #32]
    5498:	2b02      	cmp	r3, #2
    549a:	f340 8085 	ble.w	55a8 <_dtoa_r+0x960>
    549e:	e04b      	b.n	5538 <_dtoa_r+0x8f0>
    54a0:	9b16      	ldr	r3, [sp, #88]	; 0x58
    54a2:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
    54a6:	e757      	b.n	5358 <_dtoa_r+0x710>
    54a8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    54aa:	f109 34ff 	add.w	r4, r9, #4294967295
    54ae:	42a3      	cmp	r3, r4
    54b0:	bfbf      	itttt	lt
    54b2:	9b09      	ldrlt	r3, [sp, #36]	; 0x24
    54b4:	9409      	strlt	r4, [sp, #36]	; 0x24
    54b6:	1ae2      	sublt	r2, r4, r3
    54b8:	9b10      	ldrlt	r3, [sp, #64]	; 0x40
    54ba:	bfbb      	ittet	lt
    54bc:	189b      	addlt	r3, r3, r2
    54be:	9310      	strlt	r3, [sp, #64]	; 0x40
    54c0:	1b1c      	subge	r4, r3, r4
    54c2:	2400      	movlt	r4, #0
    54c4:	f1b9 0f00 	cmp.w	r9, #0
    54c8:	bfb5      	itete	lt
    54ca:	9b06      	ldrlt	r3, [sp, #24]
    54cc:	9d06      	ldrge	r5, [sp, #24]
    54ce:	eba3 0509 	sublt.w	r5, r3, r9
    54d2:	464b      	movge	r3, r9
    54d4:	bfb8      	it	lt
    54d6:	2300      	movlt	r3, #0
    54d8:	e740      	b.n	535c <_dtoa_r+0x714>
    54da:	9c09      	ldr	r4, [sp, #36]	; 0x24
    54dc:	9d06      	ldr	r5, [sp, #24]
    54de:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    54e0:	e747      	b.n	5372 <_dtoa_r+0x72a>
    54e2:	9a09      	ldr	r2, [sp, #36]	; 0x24
    54e4:	e770      	b.n	53c8 <_dtoa_r+0x780>
    54e6:	9b08      	ldr	r3, [sp, #32]
    54e8:	2b01      	cmp	r3, #1
    54ea:	dc15      	bgt.n	5518 <_dtoa_r+0x8d0>
    54ec:	9b04      	ldr	r3, [sp, #16]
    54ee:	b99b      	cbnz	r3, 5518 <_dtoa_r+0x8d0>
    54f0:	9b05      	ldr	r3, [sp, #20]
    54f2:	f3c3 0213 	ubfx	r2, r3, #0, #20
    54f6:	b98a      	cbnz	r2, 551c <_dtoa_r+0x8d4>
    54f8:	4f27      	ldr	r7, [pc, #156]	; (5598 <_dtoa_r+0x950>)
    54fa:	401f      	ands	r7, r3
    54fc:	b137      	cbz	r7, 550c <_dtoa_r+0x8c4>
    54fe:	9b06      	ldr	r3, [sp, #24]
    5500:	3301      	adds	r3, #1
    5502:	9306      	str	r3, [sp, #24]
    5504:	9b07      	ldr	r3, [sp, #28]
    5506:	3301      	adds	r3, #1
    5508:	9307      	str	r3, [sp, #28]
    550a:	2701      	movs	r7, #1
    550c:	9b10      	ldr	r3, [sp, #64]	; 0x40
    550e:	2b00      	cmp	r3, #0
    5510:	f47f af72 	bne.w	53f8 <_dtoa_r+0x7b0>
    5514:	2001      	movs	r0, #1
    5516:	e777      	b.n	5408 <_dtoa_r+0x7c0>
    5518:	2700      	movs	r7, #0
    551a:	e7f7      	b.n	550c <_dtoa_r+0x8c4>
    551c:	9f04      	ldr	r7, [sp, #16]
    551e:	e7f5      	b.n	550c <_dtoa_r+0x8c4>
    5520:	d086      	beq.n	5430 <_dtoa_r+0x7e8>
    5522:	4618      	mov	r0, r3
    5524:	301c      	adds	r0, #28
    5526:	e77c      	b.n	5422 <_dtoa_r+0x7da>
    5528:	f1b9 0f00 	cmp.w	r9, #0
    552c:	dc36      	bgt.n	559c <_dtoa_r+0x954>
    552e:	9b08      	ldr	r3, [sp, #32]
    5530:	2b02      	cmp	r3, #2
    5532:	dd33      	ble.n	559c <_dtoa_r+0x954>
    5534:	f8cd 9008 	str.w	r9, [sp, #8]
    5538:	9b02      	ldr	r3, [sp, #8]
    553a:	b963      	cbnz	r3, 5556 <_dtoa_r+0x90e>
    553c:	4621      	mov	r1, r4
    553e:	2205      	movs	r2, #5
    5540:	4658      	mov	r0, fp
    5542:	f014 f92c 	bl	1979e <__multadd>
    5546:	4601      	mov	r1, r0
    5548:	4604      	mov	r4, r0
    554a:	4640      	mov	r0, r8
    554c:	f019 fcbc 	bl	1eec8 <__mcmp>
    5550:	2800      	cmp	r0, #0
    5552:	f73f adc8 	bgt.w	50e6 <_dtoa_r+0x49e>
    5556:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    5558:	9d01      	ldr	r5, [sp, #4]
    555a:	ea6f 0a03 	mvn.w	sl, r3
    555e:	2700      	movs	r7, #0
    5560:	4621      	mov	r1, r4
    5562:	4658      	mov	r0, fp
    5564:	f01a f941 	bl	1f7ea <_Bfree>
    5568:	2e00      	cmp	r6, #0
    556a:	f43f aeb3 	beq.w	52d4 <_dtoa_r+0x68c>
    556e:	b12f      	cbz	r7, 557c <_dtoa_r+0x934>
    5570:	42b7      	cmp	r7, r6
    5572:	d003      	beq.n	557c <_dtoa_r+0x934>
    5574:	4639      	mov	r1, r7
    5576:	4658      	mov	r0, fp
    5578:	f01a f937 	bl	1f7ea <_Bfree>
    557c:	4631      	mov	r1, r6
    557e:	4658      	mov	r0, fp
    5580:	f01a f933 	bl	1f7ea <_Bfree>
    5584:	e6a6      	b.n	52d4 <_dtoa_r+0x68c>
    5586:	2400      	movs	r4, #0
    5588:	4626      	mov	r6, r4
    558a:	e7e4      	b.n	5556 <_dtoa_r+0x90e>
    558c:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
    5590:	4626      	mov	r6, r4
    5592:	e5a8      	b.n	50e6 <_dtoa_r+0x49e>
    5594:	40240000 	.word	0x40240000
    5598:	7ff00000 	.word	0x7ff00000
    559c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    559e:	f8cd 9008 	str.w	r9, [sp, #8]
    55a2:	2b00      	cmp	r3, #0
    55a4:	f000 80ec 	beq.w	5780 <_dtoa_r+0xb38>
    55a8:	2d00      	cmp	r5, #0
    55aa:	dd05      	ble.n	55b8 <_dtoa_r+0x970>
    55ac:	4631      	mov	r1, r6
    55ae:	462a      	mov	r2, r5
    55b0:	4658      	mov	r0, fp
    55b2:	f012 f895 	bl	176e0 <__lshift>
    55b6:	4606      	mov	r6, r0
    55b8:	2f00      	cmp	r7, #0
    55ba:	d056      	beq.n	566a <_dtoa_r+0xa22>
    55bc:	6871      	ldr	r1, [r6, #4]
    55be:	4658      	mov	r0, fp
    55c0:	f015 fd18 	bl	1aff4 <_Balloc>
    55c4:	6932      	ldr	r2, [r6, #16]
    55c6:	3202      	adds	r2, #2
    55c8:	4605      	mov	r5, r0
    55ca:	0092      	lsls	r2, r2, #2
    55cc:	f106 010c 	add.w	r1, r6, #12
    55d0:	300c      	adds	r0, #12
    55d2:	f01b fdd5 	bl	21180 <memcpy>
    55d6:	2201      	movs	r2, #1
    55d8:	4629      	mov	r1, r5
    55da:	4658      	mov	r0, fp
    55dc:	f012 f880 	bl	176e0 <__lshift>
    55e0:	9b01      	ldr	r3, [sp, #4]
    55e2:	f103 0901 	add.w	r9, r3, #1
    55e6:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
    55ea:	4413      	add	r3, r2
    55ec:	9309      	str	r3, [sp, #36]	; 0x24
    55ee:	9b04      	ldr	r3, [sp, #16]
    55f0:	f003 0301 	and.w	r3, r3, #1
    55f4:	4637      	mov	r7, r6
    55f6:	9307      	str	r3, [sp, #28]
    55f8:	4606      	mov	r6, r0
    55fa:	f109 33ff 	add.w	r3, r9, #4294967295
    55fe:	4621      	mov	r1, r4
    5600:	4640      	mov	r0, r8
    5602:	9302      	str	r3, [sp, #8]
    5604:	f00d f9a4 	bl	12950 <quorem>
    5608:	4603      	mov	r3, r0
    560a:	3330      	adds	r3, #48	; 0x30
    560c:	9004      	str	r0, [sp, #16]
    560e:	4639      	mov	r1, r7
    5610:	4640      	mov	r0, r8
    5612:	930a      	str	r3, [sp, #40]	; 0x28
    5614:	f019 fc58 	bl	1eec8 <__mcmp>
    5618:	4632      	mov	r2, r6
    561a:	9006      	str	r0, [sp, #24]
    561c:	4621      	mov	r1, r4
    561e:	4658      	mov	r0, fp
    5620:	f010 fb92 	bl	15d48 <__mdiff>
    5624:	68c2      	ldr	r2, [r0, #12]
    5626:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    5628:	4605      	mov	r5, r0
    562a:	bb02      	cbnz	r2, 566e <_dtoa_r+0xa26>
    562c:	4601      	mov	r1, r0
    562e:	4640      	mov	r0, r8
    5630:	f019 fc4a 	bl	1eec8 <__mcmp>
    5634:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    5636:	4602      	mov	r2, r0
    5638:	4629      	mov	r1, r5
    563a:	4658      	mov	r0, fp
    563c:	920c      	str	r2, [sp, #48]	; 0x30
    563e:	930a      	str	r3, [sp, #40]	; 0x28
    5640:	f01a f8d3 	bl	1f7ea <_Bfree>
    5644:	9b08      	ldr	r3, [sp, #32]
    5646:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    5648:	ea43 0102 	orr.w	r1, r3, r2
    564c:	9b07      	ldr	r3, [sp, #28]
    564e:	430b      	orrs	r3, r1
    5650:	464d      	mov	r5, r9
    5652:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    5654:	d10d      	bne.n	5672 <_dtoa_r+0xa2a>
    5656:	2b39      	cmp	r3, #57	; 0x39
    5658:	d027      	beq.n	56aa <_dtoa_r+0xa62>
    565a:	9a06      	ldr	r2, [sp, #24]
    565c:	2a00      	cmp	r2, #0
    565e:	dd01      	ble.n	5664 <_dtoa_r+0xa1c>
    5660:	9b04      	ldr	r3, [sp, #16]
    5662:	3331      	adds	r3, #49	; 0x31
    5664:	9a02      	ldr	r2, [sp, #8]
    5666:	7013      	strb	r3, [r2, #0]
    5668:	e77a      	b.n	5560 <_dtoa_r+0x918>
    566a:	4630      	mov	r0, r6
    566c:	e7b8      	b.n	55e0 <_dtoa_r+0x998>
    566e:	2201      	movs	r2, #1
    5670:	e7e2      	b.n	5638 <_dtoa_r+0x9f0>
    5672:	9906      	ldr	r1, [sp, #24]
    5674:	2900      	cmp	r1, #0
    5676:	db04      	blt.n	5682 <_dtoa_r+0xa3a>
    5678:	9808      	ldr	r0, [sp, #32]
    567a:	4301      	orrs	r1, r0
    567c:	9807      	ldr	r0, [sp, #28]
    567e:	4301      	orrs	r1, r0
    5680:	d11e      	bne.n	56c0 <_dtoa_r+0xa78>
    5682:	2a00      	cmp	r2, #0
    5684:	ddee      	ble.n	5664 <_dtoa_r+0xa1c>
    5686:	4641      	mov	r1, r8
    5688:	2201      	movs	r2, #1
    568a:	4658      	mov	r0, fp
    568c:	9306      	str	r3, [sp, #24]
    568e:	f012 f827 	bl	176e0 <__lshift>
    5692:	4621      	mov	r1, r4
    5694:	4680      	mov	r8, r0
    5696:	f019 fc17 	bl	1eec8 <__mcmp>
    569a:	2800      	cmp	r0, #0
    569c:	9b06      	ldr	r3, [sp, #24]
    569e:	dc02      	bgt.n	56a6 <_dtoa_r+0xa5e>
    56a0:	d1e0      	bne.n	5664 <_dtoa_r+0xa1c>
    56a2:	07da      	lsls	r2, r3, #31
    56a4:	d5de      	bpl.n	5664 <_dtoa_r+0xa1c>
    56a6:	2b39      	cmp	r3, #57	; 0x39
    56a8:	d1da      	bne.n	5660 <_dtoa_r+0xa18>
    56aa:	9a02      	ldr	r2, [sp, #8]
    56ac:	2339      	movs	r3, #57	; 0x39
    56ae:	7013      	strb	r3, [r2, #0]
    56b0:	f815 3c01 	ldrb.w	r3, [r5, #-1]
    56b4:	2b39      	cmp	r3, #57	; 0x39
    56b6:	f105 32ff 	add.w	r2, r5, #4294967295
    56ba:	d046      	beq.n	574a <_dtoa_r+0xb02>
    56bc:	3301      	adds	r3, #1
    56be:	e7d2      	b.n	5666 <_dtoa_r+0xa1e>
    56c0:	2a00      	cmp	r2, #0
    56c2:	dd03      	ble.n	56cc <_dtoa_r+0xa84>
    56c4:	2b39      	cmp	r3, #57	; 0x39
    56c6:	d0f0      	beq.n	56aa <_dtoa_r+0xa62>
    56c8:	3301      	adds	r3, #1
    56ca:	e7cb      	b.n	5664 <_dtoa_r+0xa1c>
    56cc:	9a09      	ldr	r2, [sp, #36]	; 0x24
    56ce:	f809 3c01 	strb.w	r3, [r9, #-1]
    56d2:	4591      	cmp	r9, r2
    56d4:	d020      	beq.n	5718 <_dtoa_r+0xad0>
    56d6:	4641      	mov	r1, r8
    56d8:	2300      	movs	r3, #0
    56da:	220a      	movs	r2, #10
    56dc:	4658      	mov	r0, fp
    56de:	f014 f85e 	bl	1979e <__multadd>
    56e2:	42b7      	cmp	r7, r6
    56e4:	4680      	mov	r8, r0
    56e6:	f04f 0300 	mov.w	r3, #0
    56ea:	f04f 020a 	mov.w	r2, #10
    56ee:	4639      	mov	r1, r7
    56f0:	4658      	mov	r0, fp
    56f2:	d106      	bne.n	5702 <_dtoa_r+0xaba>
    56f4:	f014 f853 	bl	1979e <__multadd>
    56f8:	4607      	mov	r7, r0
    56fa:	4606      	mov	r6, r0
    56fc:	f109 0901 	add.w	r9, r9, #1
    5700:	e77b      	b.n	55fa <_dtoa_r+0x9b2>
    5702:	f014 f84c 	bl	1979e <__multadd>
    5706:	2300      	movs	r3, #0
    5708:	4607      	mov	r7, r0
    570a:	220a      	movs	r2, #10
    570c:	4631      	mov	r1, r6
    570e:	4658      	mov	r0, fp
    5710:	f014 f845 	bl	1979e <__multadd>
    5714:	e7f1      	b.n	56fa <_dtoa_r+0xab2>
    5716:	2700      	movs	r7, #0
    5718:	4641      	mov	r1, r8
    571a:	2201      	movs	r2, #1
    571c:	4658      	mov	r0, fp
    571e:	9302      	str	r3, [sp, #8]
    5720:	f011 ffde 	bl	176e0 <__lshift>
    5724:	4621      	mov	r1, r4
    5726:	4680      	mov	r8, r0
    5728:	f019 fbce 	bl	1eec8 <__mcmp>
    572c:	2800      	cmp	r0, #0
    572e:	dcbf      	bgt.n	56b0 <_dtoa_r+0xa68>
    5730:	d102      	bne.n	5738 <_dtoa_r+0xaf0>
    5732:	9b02      	ldr	r3, [sp, #8]
    5734:	07db      	lsls	r3, r3, #31
    5736:	d4bb      	bmi.n	56b0 <_dtoa_r+0xa68>
    5738:	f815 3c01 	ldrb.w	r3, [r5, #-1]
    573c:	2b30      	cmp	r3, #48	; 0x30
    573e:	f105 32ff 	add.w	r2, r5, #4294967295
    5742:	f47f af0d 	bne.w	5560 <_dtoa_r+0x918>
    5746:	4615      	mov	r5, r2
    5748:	e7f6      	b.n	5738 <_dtoa_r+0xaf0>
    574a:	9b01      	ldr	r3, [sp, #4]
    574c:	4293      	cmp	r3, r2
    574e:	d104      	bne.n	575a <_dtoa_r+0xb12>
    5750:	f10a 0a01 	add.w	sl, sl, #1
    5754:	2331      	movs	r3, #49	; 0x31
    5756:	9a01      	ldr	r2, [sp, #4]
    5758:	e785      	b.n	5666 <_dtoa_r+0xa1e>
    575a:	4615      	mov	r5, r2
    575c:	e7a8      	b.n	56b0 <_dtoa_r+0xa68>
    575e:	4b13      	ldr	r3, [pc, #76]	; (57ac <_dtoa_r+0xb64>)
    5760:	f7ff bad9 	b.w	4d16 <_dtoa_r+0xce>
    5764:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    5766:	2b00      	cmp	r3, #0
    5768:	f47f aab1 	bne.w	4cce <_dtoa_r+0x86>
    576c:	4b10      	ldr	r3, [pc, #64]	; (57b0 <_dtoa_r+0xb68>)
    576e:	f7ff bad2 	b.w	4d16 <_dtoa_r+0xce>
    5772:	9b02      	ldr	r3, [sp, #8]
    5774:	2b00      	cmp	r3, #0
    5776:	dc03      	bgt.n	5780 <_dtoa_r+0xb38>
    5778:	9b08      	ldr	r3, [sp, #32]
    577a:	2b02      	cmp	r3, #2
    577c:	f73f aedc 	bgt.w	5538 <_dtoa_r+0x8f0>
    5780:	9d01      	ldr	r5, [sp, #4]
    5782:	4621      	mov	r1, r4
    5784:	4640      	mov	r0, r8
    5786:	f00d f8e3 	bl	12950 <quorem>
    578a:	f100 0330 	add.w	r3, r0, #48	; 0x30
    578e:	f805 3b01 	strb.w	r3, [r5], #1
    5792:	9a01      	ldr	r2, [sp, #4]
    5794:	9902      	ldr	r1, [sp, #8]
    5796:	1aaa      	subs	r2, r5, r2
    5798:	4291      	cmp	r1, r2
    579a:	ddbc      	ble.n	5716 <_dtoa_r+0xace>
    579c:	4641      	mov	r1, r8
    579e:	2300      	movs	r3, #0
    57a0:	220a      	movs	r2, #10
    57a2:	4658      	mov	r0, fp
    57a4:	f013 fffb 	bl	1979e <__multadd>
    57a8:	4680      	mov	r8, r0
    57aa:	e7ea      	b.n	5782 <_dtoa_r+0xb3a>
    57ac:	00021ce9 	.word	0x00021ce9
    57b0:	00021cdc 	.word	0x00021cdc

Disassembly of section .rodata%186:

000057b4 <.rodata%186>:
    57b4:	67617355 	.word	0x67617355
    57b8:	69203a65 	.word	0x69203a65
    57bc:	66726570 	.word	0x66726570
    57c0:	2d3c2073 	.word	0x2d3c2073
    57c4:	73207874 	.word	0x73207874
    57c8:	3e657a69 	.word	0x3e657a69
    57cc:	722d3c20 	.word	0x722d3c20
    57d0:	69732078 	.word	0x69732078
    57d4:	203e657a 	.word	0x203e657a
    57d8:	20692d3c 	.word	0x20692d3c
    57dc:	65646e69 	.word	0x65646e69
    57e0:	0a0d3e78 	.word	0x0a0d3e78
    57e4:	00000000 	.word	0x00000000
    57e8:	0078742d 	.word	0x0078742d
    57ec:	0078722d 	.word	0x0078722d
    57f0:	0000692d 	.word	0x0000692d
    57f4:	6e692d2d 	.word	0x6e692d2d
    57f8:	00786564 	.word	0x00786564
    57fc:	72657069 	.word	0x72657069
    5800:	203a6966 	.word	0x203a6966
    5804:	6e6b6e55 	.word	0x6e6b6e55
    5808:	206e776f 	.word	0x206e776f
    580c:	61726170 	.word	0x61726170
    5810:	6574656d 	.word	0x6574656d
    5814:	000a0d72 	.word	0x000a0d72
    5818:	70690a0d 	.word	0x70690a0d
    581c:	3a667265 	.word	0x3a667265
    5820:	766e4920 	.word	0x766e4920
    5824:	64696c61 	.word	0x64696c61
    5828:	73657320 	.word	0x73657320
    582c:	6e6f6973 	.word	0x6e6f6973
    5830:	6d756e20 	.word	0x6d756e20
    5834:	2e726562 	.word	0x2e726562
    5838:	6e694d20 	.word	0x6e694d20
    583c:	2c30203a 	.word	0x2c30203a
    5840:	78614d20 	.word	0x78614d20
    5844:	6425203a 	.word	0x6425203a
    5848:	00000a0d 	.word	0x00000a0d
    584c:	72657069 	.word	0x72657069
    5850:	203a7366 	.word	0x203a7366
    5854:	203c2030 	.word	0x203c2030
    5858:	657a6973 	.word	0x657a6973
    585c:	36203c20 	.word	0x36203c20
    5860:	36333535 	.word	0x36333535
    5864:	00000a0d 	.word	0x00000a0d
    5868:	72657069 	.word	0x72657069
    586c:	203a7366 	.word	0x203a7366
    5870:	202c4b4f 	.word	0x202c4b4f
    5874:	20746573 	.word	0x20746573
    5878:	74736e69 	.word	0x74736e69
    587c:	65636e61 	.word	0x65636e61
    5880:	20642520 	.word	0x20642520
    5884:	73207872 	.word	0x73207872
    5888:	20657a69 	.word	0x20657a69
    588c:	25206f74 	.word	0x25206f74
    5890:	000a0d64 	.word	0x000a0d64
    5894:	72657069 	.word	0x72657069
    5898:	203a7366 	.word	0x203a7366
    589c:	202c4b4f 	.word	0x202c4b4f
    58a0:	20746573 	.word	0x20746573
    58a4:	74736e69 	.word	0x74736e69
    58a8:	65636e61 	.word	0x65636e61
    58ac:	20642520 	.word	0x20642520
    58b0:	73207874 	.word	0x73207874
    58b4:	20657a69 	.word	0x20657a69
    58b8:	25206f74 	.word	0x25206f74
    58bc:	000a0d64 	.word	0x000a0d64
    58c0:	72657069 	.word	0x72657069
    58c4:	203a6b66 	.word	0x203a6b66
    58c8:	6e697355 	.word	0x6e697355
    58cc:	6e692067 	.word	0x6e692067
    58d0:	20786564 	.word	0x20786564
    58d4:	000a0d30 	.word	0x000a0d30
    58d8:	70690a0d 	.word	0x70690a0d
    58dc:	20667265 	.word	0x20667265
    58e0:	73736573 	.word	0x73736573
    58e4:	3a6e6f69 	.word	0x3a6e6f69
    58e8:	746f6e20 	.word	0x746f6e20
    58ec:	61747320 	.word	0x61747320
    58f0:	64657472 	.word	0x64657472
    58f4:	000a0d21 	.word	0x000a0d21
    58f8:	70690a0d 	.word	0x70690a0d
    58fc:	3a667265 	.word	0x3a667265
    5900:	79727420 	.word	0x79727420
    5904:	20676e69 	.word	0x20676e69
    5908:	73206f74 	.word	0x73206f74
    590c:	20706f74 	.word	0x20706f74
    5910:	72657069 	.word	0x72657069
    5914:	6e692066 	.word	0x6e692066
    5918:	6e617473 	.word	0x6e617473
    591c:	25206563 	.word	0x25206563
    5920:	2e2e2e64 	.word	0x2e2e2e64
    5924:	00000a0d 	.word	0x00000a0d
    5928:	67617355 	.word	0x67617355
    592c:	69203a65 	.word	0x69203a65
    5930:	66726570 	.word	0x66726570
    5934:	2d3c206b 	.word	0x2d3c206b
    5938:	6e692069 	.word	0x6e692069
    593c:	3e786564 	.word	0x3e786564
    5940:	00000a0d 	.word	0x00000a0d
    5944:	0000612d 	.word	0x0000612d
    5948:	72657069 	.word	0x72657069
    594c:	203a6966 	.word	0x203a6966
    5950:	20657375 	.word	0x20657375
    5954:	61762061 	.word	0x61762061
    5958:	2064696c 	.word	0x2064696c
    595c:	61205049 	.word	0x61205049
    5960:	65726464 	.word	0x65726464
    5964:	0d217373 	.word	0x0d217373
    5968:	0000000a 	.word	0x0000000a
    596c:	67617355 	.word	0x67617355
    5970:	69203a65 	.word	0x69203a65
    5974:	66726570 	.word	0x66726570
    5978:	612d2069 	.word	0x612d2069
    597c:	64646120 	.word	0x64646120
    5980:	73736572 	.word	0x73736572
    5984:	692d3c20 	.word	0x692d3c20
    5988:	646e6920 	.word	0x646e6920
    598c:	0d3e7865 	.word	0x0d3e7865
    5990:	0000000a 	.word	0x0000000a
    5994:	70690a0d 	.word	0x70690a0d
    5998:	69667265 	.word	0x69667265
    599c:	6163203a 	.word	0x6163203a
    59a0:	746f6e6e 	.word	0x746f6e6e
    59a4:	61686320 	.word	0x61686320
    59a8:	2065676e 	.word	0x2065676e
    59ac:	20656874 	.word	0x20656874
    59b0:	61207069 	.word	0x61207069
    59b4:	65726464 	.word	0x65726464
    59b8:	77207373 	.word	0x77207373
    59bc:	656c6968 	.word	0x656c6968
    59c0:	73657320 	.word	0x73657320
    59c4:	6e6f6973 	.word	0x6e6f6973
    59c8:	6425203a 	.word	0x6425203a
    59cc:	6e757220 	.word	0x6e757220
    59d0:	676e696e 	.word	0x676e696e
    59d4:	000a0d21 	.word	0x000a0d21
    59d8:	72657069 	.word	0x72657069
    59dc:	203a6966 	.word	0x203a6966
    59e0:	202c4b4f 	.word	0x202c4b4f
    59e4:	20746573 	.word	0x20746573
    59e8:	20656874 	.word	0x20656874
    59ec:	61205049 	.word	0x61205049
    59f0:	65726464 	.word	0x65726464
    59f4:	74207373 	.word	0x74207373
    59f8:	6e69206f 	.word	0x6e69206f
    59fc:	6e617473 	.word	0x6e617473
    5a00:	203a6563 	.word	0x203a6563
    5a04:	0a0d6425 	.word	0x0a0d6425
    5a08:	00000000 	.word	0x00000000
    5a0c:	0000732d 	.word	0x0000732d
    5a10:	65732d2d 	.word	0x65732d2d
    5a14:	72657672 	.word	0x72657672
    5a18:	00000000 	.word	0x00000000
    5a1c:	0000752d 	.word	0x0000752d
    5a20:	64752d2d 	.word	0x64752d2d
    5a24:	00000070 	.word	0x00000070
    5a28:	0000622d 	.word	0x0000622d
    5a2c:	61622d2d 	.word	0x61622d2d
    5a30:	6977646e 	.word	0x6977646e
    5a34:	00687464 	.word	0x00687464
    5a38:	0000004d 	.word	0x0000004d
    5a3c:	0000004b 	.word	0x0000004b
    5a40:	7669470a 	.word	0x7669470a
    5a44:	69206e65 	.word	0x69206e65
    5a48:	5742206e 	.word	0x5742206e
    5a4c:	6c25203a 	.word	0x6c25203a
    5a50:	6c252b75 	.word	0x6c252b75
    5a54:	6c253d75 	.word	0x6c253d75
    5a58:	00000075 	.word	0x00000075
    5a5c:	0000782d 	.word	0x0000782d
    5a60:	6d782d2d 	.word	0x6d782d2d
    5a64:	61727469 	.word	0x61727469
    5a68:	00006574 	.word	0x00006574
    5a6c:	0000632d 	.word	0x0000632d
    5a70:	6c632d2d 	.word	0x6c632d2d
    5a74:	746e6569 	.word	0x746e6569
    5a78:	00000000 	.word	0x00000000
    5a7c:	0000742d 	.word	0x0000742d
    5a80:	69742d2d 	.word	0x69742d2d
    5a84:	0000656d 	.word	0x0000656d
    5a88:	00006e2d 	.word	0x00006e2d
    5a8c:	756e2d2d 	.word	0x756e2d2d
    5a90:	0000006d 	.word	0x0000006d
    5a94:	0000532d 	.word	0x0000532d
    5a98:	6f742d2d 	.word	0x6f742d2d
    5a9c:	00000073 	.word	0x00000073
    5aa0:	7669470a 	.word	0x7669470a
    5aa4:	54206e65 	.word	0x54206e65
    5aa8:	7620534f 	.word	0x7620534f
    5aac:	65756c61 	.word	0x65756c61
    5ab0:	20736920 	.word	0x20736920
    5ab4:	202c6425 	.word	0x202c6425
    5ab8:	7079546d 	.word	0x7079546d
    5abc:	53664f65 	.word	0x53664f65
    5ac0:	69767265 	.word	0x69767265
    5ac4:	253a6563 	.word	0x253a6563
    5ac8:	00000064 	.word	0x00000064
    5acc:	00004d2d 	.word	0x00004d2d
    5ad0:	736d2d2d 	.word	0x736d2d2d
    5ad4:	00000073 	.word	0x00000073
    5ad8:	6e692d2d 	.word	0x6e692d2d
    5adc:	76726574 	.word	0x76726574
    5ae0:	00006c61 	.word	0x00006c61
    5ae4:	0000702d 	.word	0x0000702d
    5ae8:	6f702d2d 	.word	0x6f702d2d
    5aec:	00007472 	.word	0x00007472
    5af0:	00006c2d 	.word	0x00006c2d
    5af4:	656c2d2d 	.word	0x656c2d2d
    5af8:	0000006e 	.word	0x0000006e
    5afc:	72657069 	.word	0x72657069
    5b00:	54203a66 	.word	0x54203a66
    5b04:	6d206568 	.word	0x6d206568
    5b08:	6d696e69 	.word	0x6d696e69
    5b0c:	64206d75 	.word	0x64206d75
    5b10:	67617461 	.word	0x67617461
    5b14:	206d6172 	.word	0x206d6172
    5b18:	657a6973 	.word	0x657a6973
    5b1c:	20736920 	.word	0x20736920
    5b20:	0a0d6425 	.word	0x0a0d6425
    5b24:	00000000 	.word	0x00000000
    5b28:	72657069 	.word	0x72657069
    5b2c:	55203a66 	.word	0x55203a66
    5b30:	676e6973 	.word	0x676e6973
    5b34:	65687420 	.word	0x65687420
    5b38:	66656420 	.word	0x66656420
    5b3c:	746c7561 	.word	0x746c7561
    5b40:	746e6920 	.word	0x746e6920
    5b44:	61667265 	.word	0x61667265
    5b48:	0d216563 	.word	0x0d216563
    5b4c:	0000000a 	.word	0x0000000a
    5b50:	2d2d2d2d 	.word	0x2d2d2d2d
    5b54:	2d2d2d2d 	.word	0x2d2d2d2d
    5b58:	2d2d2d2d 	.word	0x2d2d2d2d
    5b5c:	2d2d2d2d 	.word	0x2d2d2d2d
    5b60:	2d2d2d2d 	.word	0x2d2d2d2d
    5b64:	2d2d2d2d 	.word	0x2d2d2d2d
    5b68:	2d2d2d2d 	.word	0x2d2d2d2d
    5b6c:	2d2d2d2d 	.word	0x2d2d2d2d
    5b70:	2d2d2d2d 	.word	0x2d2d2d2d
    5b74:	2d2d2d2d 	.word	0x2d2d2d2d
    5b78:	2d2d2d2d 	.word	0x2d2d2d2d
    5b7c:	2d2d2d2d 	.word	0x2d2d2d2d
    5b80:	2d2d2d2d 	.word	0x2d2d2d2d
    5b84:	2d2d2d2d 	.word	0x2d2d2d2d
    5b88:	000a0d2d 	.word	0x000a0d2d
    5b8c:	72657069 	.word	0x72657069
    5b90:	53203a66 	.word	0x53203a66
    5b94:	65767265 	.word	0x65767265
    5b98:	696c2072 	.word	0x696c2072
    5b9c:	6e657473 	.word	0x6e657473
    5ba0:	20676e69 	.word	0x20676e69
    5ba4:	00206e6f 	.word	0x00206e6f
    5ba8:	00504455 	.word	0x00504455
    5bac:	00504354 	.word	0x00504354
    5bb0:	726f7020 	.word	0x726f7020
    5bb4:	64252074 	.word	0x64252074
    5bb8:	00000a0d 	.word	0x00000a0d
    5bbc:	70690a0d 	.word	0x70690a0d
    5bc0:	3a667265 	.word	0x3a667265
    5bc4:	6c6c4120 	.word	0x6c6c4120
    5bc8:	736e6920 	.word	0x736e6920
    5bcc:	636e6174 	.word	0x636e6174
    5bd0:	62207365 	.word	0x62207365
    5bd4:	2e797375 	.word	0x2e797375
    5bd8:	74655220 	.word	0x74655220
    5bdc:	6c207972 	.word	0x6c207972
    5be0:	72657461 	.word	0x72657461
    5be4:	000a0d21 	.word	0x000a0d21
    5be8:	70690a0d 	.word	0x70690a0d
    5bec:	3a667265 	.word	0x3a667265
    5bf0:	61745320 	.word	0x61745320
    5bf4:	6e697472 	.word	0x6e697472
    5bf8:	65732067 	.word	0x65732067
    5bfc:	6f697373 	.word	0x6f697373
    5c00:	6e69206e 	.word	0x6e69206e
    5c04:	6e617473 	.word	0x6e617473
    5c08:	25206563 	.word	0x25206563
    5c0c:	000a0d64 	.word	0x000a0d64
    5c10:	20202020 	.word	0x20202020
    5c14:	255b202d 	.word	0x255b202d
    5c18:	2d756c32 	.word	0x2d756c32
    5c1c:	6c322520 	.word	0x6c322520
    5c20:	65732075 	.word	0x65732075
    5c24:	25205d63 	.word	0x25205d63
    5c28:	2f756c33 	.word	0x2f756c33
    5c2c:	6c332520 	.word	0x6c332520
    5c30:	25282075 	.word	0x25282075
    5c34:	25756c32 	.word	0x25756c32
    5c38:	20202925 	.word	0x20202925
    5c3c:	34252020 	.word	0x34252020
    5c40:	4b20756c 	.word	0x4b20756c
    5c44:	0d737062 	.word	0x0d737062
    5c48:	0000000a 	.word	0x0000000a
    5c4c:	20202020 	.word	0x20202020
    5c50:	305b202d 	.word	0x305b202d
    5c54:	202d302e 	.word	0x202d302e
    5c58:	2e756c25 	.word	0x2e756c25
    5c5c:	20756c25 	.word	0x20756c25
    5c60:	5d636573 	.word	0x5d636573
    5c64:	6c332520 	.word	0x6c332520
    5c68:	25202f75 	.word	0x25202f75
    5c6c:	20756c33 	.word	0x20756c33
    5c70:	6c322528 	.word	0x6c322528
    5c74:	29252575 	.word	0x29252575
    5c78:	20202020 	.word	0x20202020
    5c7c:	756c3425 	.word	0x756c3425
    5c80:	70624b20 	.word	0x70624b20
    5c84:	000a0d73 	.word	0x000a0d73
    5c88:	72657069 	.word	0x72657069
    5c8c:	69203a66 	.word	0x69203a66
    5c90:	6174736e 	.word	0x6174736e
    5c94:	2065636e 	.word	0x2065636e
    5c98:	63206425 	.word	0x63206425
    5c9c:	6c706d6f 	.word	0x6c706d6f
    5ca0:	64657465 	.word	0x64657465
    5ca4:	2e2e2e20 	.word	0x2e2e2e20
    5ca8:	00000000 	.word	0x00000000
    5cac:	72657069 	.word	0x72657069
    5cb0:	6e692066 	.word	0x6e692066
    5cb4:	6e617473 	.word	0x6e617473
    5cb8:	25206563 	.word	0x25206563
    5cbc:	54203a64 	.word	0x54203a64
    5cc0:	6f642078 	.word	0x6f642078
    5cc4:	202e656e 	.word	0x202e656e
    5cc8:	6b636f53 	.word	0x6b636f53
    5ccc:	63207465 	.word	0x63207465
    5cd0:	65736f6c 	.word	0x65736f6c
    5cd4:	0a0d2e64 	.word	0x0a0d2e64
    5cd8:	00000000 	.word	0x00000000
    5cdc:	72657069 	.word	0x72657069
    5ce0:	69203a66 	.word	0x69203a66
    5ce4:	6174736e 	.word	0x6174736e
    5ce8:	2065636e 	.word	0x2065636e
    5cec:	63206425 	.word	0x63206425
    5cf0:	6c706d6f 	.word	0x6c706d6f
    5cf4:	64657465 	.word	0x64657465
    5cf8:	000a0d2e 	.word	0x000a0d2e
    5cfc:	72657069 	.word	0x72657069
    5d00:	53203a66 	.word	0x53203a66
    5d04:	656b636f 	.word	0x656b636f
    5d08:	65732074 	.word	0x65732074
    5d0c:	6620646e 	.word	0x6620646e
    5d10:	656c6961 	.word	0x656c6961
    5d14:	000a0d64 	.word	0x000a0d64
    5d18:	70690a0d 	.word	0x70690a0d
    5d1c:	3a667265 	.word	0x3a667265
    5d20:	736e6920 	.word	0x736e6920
    5d24:	636e6174 	.word	0x636e6174
    5d28:	64252065 	.word	0x64252065
    5d2c:	61747320 	.word	0x61747320
    5d30:	64657472 	.word	0x64657472
    5d34:	2e2e2e20 	.word	0x2e2e2e20
    5d38:	00000a0d 	.word	0x00000a0d
    5d3c:	20202020 	.word	0x20202020
    5d40:	6f4c202d 	.word	0x6f4c202d
    5d44:	206c6163 	.word	0x206c6163
    5d48:	2e752520 	.word	0x2e752520
    5d4c:	252e7525 	.word	0x252e7525
    5d50:	75252e75 	.word	0x75252e75
    5d54:	726f7020 	.word	0x726f7020
    5d58:	75252074 	.word	0x75252074
    5d5c:	6e6f6320 	.word	0x6e6f6320
    5d60:	7463656e 	.word	0x7463656e
    5d64:	77206465 	.word	0x77206465
    5d68:	0d687469 	.word	0x0d687469
    5d6c:	0000000a 	.word	0x0000000a
    5d70:	20202020 	.word	0x20202020
    5d74:	6552202d 	.word	0x6552202d
    5d78:	65746f6d 	.word	0x65746f6d
    5d7c:	2e752520 	.word	0x2e752520
    5d80:	252e7525 	.word	0x252e7525
    5d84:	75252e75 	.word	0x75252e75
    5d88:	726f7020 	.word	0x726f7020
    5d8c:	75252074 	.word	0x75252074
    5d90:	00000a0d 	.word	0x00000a0d
    5d94:	20202020 	.word	0x20202020
    5d98:	6154202d 	.word	0x6154202d
    5d9c:	74656772 	.word	0x74656772
    5da0:	74617220 	.word	0x74617220
    5da4:	203d2065 	.word	0x203d2065
    5da8:	20646c25 	.word	0x20646c25
    5dac:	2c737062 	.word	0x2c737062
    5db0:	72657020 	.word	0x72657020
    5db4:	20646f69 	.word	0x20646f69
    5db8:	6c25203d 	.word	0x6c25203d
    5dbc:	736d2064 	.word	0x736d2064
    5dc0:	00000a0d 	.word	0x00000a0d
    5dc4:	20202020 	.word	0x20202020
    5dc8:	2d2d2d2d 	.word	0x2d2d2d2d
    5dcc:	2d2d2d2d 	.word	0x2d2d2d2d
    5dd0:	2d2d2d2d 	.word	0x2d2d2d2d
    5dd4:	2d2d2d2d 	.word	0x2d2d2d2d
    5dd8:	2d2d2d2d 	.word	0x2d2d2d2d
    5ddc:	2d2d2d2d 	.word	0x2d2d2d2d
    5de0:	2d2d2d2d 	.word	0x2d2d2d2d
    5de4:	2d2d2d2d 	.word	0x2d2d2d2d
    5de8:	2d2d2d2d 	.word	0x2d2d2d2d
    5dec:	2d2d2d2d 	.word	0x2d2d2d2d
    5df0:	000a0d2d 	.word	0x000a0d2d
    5df4:	70690a0d 	.word	0x70690a0d
    5df8:	3a667265 	.word	0x3a667265
    5dfc:	72615720 	.word	0x72615720
    5e00:	676e696e 	.word	0x676e696e
    5e04:	4354202c 	.word	0x4354202c
    5e08:	65732050 	.word	0x65732050
    5e0c:	72657672 	.word	0x72657672
    5e10:	73696420 	.word	0x73696420
    5e14:	6e6e6f63 	.word	0x6e6e6f63
    5e18:	20746365 	.word	0x20746365
    5e1c:	65746564 	.word	0x65746564
    5e20:	64657463 	.word	0x64657463
    5e24:	00000a0d 	.word	0x00000a0d
    5e28:	72657069 	.word	0x72657069
    5e2c:	46203a66 	.word	0x46203a66
    5e30:	656c6961 	.word	0x656c6961
    5e34:	6f742064 	.word	0x6f742064
    5e38:	74656720 	.word	0x74656720
    5e3c:	20642520 	.word	0x20642520
    5e40:	65747962 	.word	0x65747962
    5e44:	6f732073 	.word	0x6f732073
    5e48:	74656b63 	.word	0x74656b63
    5e4c:	20585420 	.word	0x20585420
    5e50:	63617073 	.word	0x63617073
    5e54:	000a0d65 	.word	0x000a0d65
    5e58:	72657069 	.word	0x72657069
    5e5c:	55203a66 	.word	0x55203a66
    5e60:	7075736e 	.word	0x7075736e
    5e64:	74726f70 	.word	0x74726f70
    5e68:	43206465 	.word	0x43206465
    5e6c:	69666e6f 	.word	0x69666e6f
    5e70:	61727567 	.word	0x61727567
    5e74:	6e6f6974 	.word	0x6e6f6974
    5e78:	00000a0d 	.word	0x00000a0d
    5e7c:	72657069 	.word	0x72657069
    5e80:	43203a66 	.word	0x43203a66
    5e84:	74616572 	.word	0x74616572
    5e88:	43542065 	.word	0x43542065
    5e8c:	6f732050 	.word	0x6f732050
    5e90:	74656b63 	.word	0x74656b63
    5e94:	69616620 	.word	0x69616620
    5e98:	0d64656c 	.word	0x0d64656c
    5e9c:	0000000a 	.word	0x0000000a
    5ea0:	72657069 	.word	0x72657069
    5ea4:	53203a66 	.word	0x53203a66
    5ea8:	6f207465 	.word	0x6f207465
    5eac:	58522066 	.word	0x58522066
    5eb0:	66756220 	.word	0x66756220
    5eb4:	20726566 	.word	0x20726566
    5eb8:	657a6973 	.word	0x657a6973
    5ebc:	69616620 	.word	0x69616620
    5ec0:	0d64656c 	.word	0x0d64656c
    5ec4:	0000000a 	.word	0x0000000a
    5ec8:	72657069 	.word	0x72657069
    5ecc:	43203a66 	.word	0x43203a66
    5ed0:	74616572 	.word	0x74616572
    5ed4:	44552065 	.word	0x44552065
    5ed8:	6f732050 	.word	0x6f732050
    5edc:	74656b63 	.word	0x74656b63
    5ee0:	69616620 	.word	0x69616620
    5ee4:	0d64656c 	.word	0x0d64656c
    5ee8:	0000000a 	.word	0x0000000a
    5eec:	72657069 	.word	0x72657069
    5ef0:	50203a66 	.word	0x50203a66
    5ef4:	6f746f72 	.word	0x6f746f72
    5ef8:	206c6f63 	.word	0x206c6f63
    5efc:	6f727265 	.word	0x6f727265
    5f00:	000a0d72 	.word	0x000a0d72
    5f04:	72657069 	.word	0x72657069
    5f08:	55203a66 	.word	0x55203a66
    5f0c:	47205044 	.word	0x47205044
    5f10:	41207465 	.word	0x41207465
    5f14:	79617272 	.word	0x79617272
    5f18:	69614620 	.word	0x69614620
    5f1c:	0d64656c 	.word	0x0d64656c
    5f20:	0000000a 	.word	0x0000000a
    5f24:	72657069 	.word	0x72657069
    5f28:	2d203a66 	.word	0x2d203a66
    5f2c:	72694620 	.word	0x72694620
    5f30:	70207473 	.word	0x70207473
    5f34:	6920746b 	.word	0x6920746b
    5f38:	203d2064 	.word	0x203d2064
    5f3c:	20646c25 	.word	0x20646c25
    5f40:	6f687328 	.word	0x6f687328
    5f44:	20646c75 	.word	0x20646c75
    5f48:	30206562 	.word	0x30206562
    5f4c:	000a0d29 	.word	0x000a0d29
    5f50:	72657069 	.word	0x72657069
    5f54:	52203a66 	.word	0x52203a66
    5f58:	20766365 	.word	0x20766365
    5f5c:	6c707564 	.word	0x6c707564
    5f60:	74616369 	.word	0x74616369
    5f64:	70206465 	.word	0x70206465
    5f68:	0a0d746b 	.word	0x0a0d746b
    5f6c:	00000000 	.word	0x00000000
    5f70:	72657069 	.word	0x72657069
    5f74:	52203a66 	.word	0x52203a66
    5f78:	69742078 	.word	0x69742078
    5f7c:	2064656d 	.word	0x2064656d
    5f80:	0d74756f 	.word	0x0d74756f
    5f84:	0000000a 	.word	0x0000000a
    5f88:	70690a0d 	.word	0x70690a0d
    5f8c:	3a667265 	.word	0x3a667265
    5f90:	736e6920 	.word	0x736e6920
    5f94:	636e6174 	.word	0x636e6174
    5f98:	64252065 	.word	0x64252065
    5f9c:	73657320 	.word	0x73657320
    5fa0:	6e6f6973 	.word	0x6e6f6973
    5fa4:	61747320 	.word	0x61747320
    5fa8:	64657472 	.word	0x64657472
    5fac:	2e2e2e20 	.word	0x2e2e2e20
    5fb0:	00000a0d 	.word	0x00000a0d
    5fb4:	70690a0d 	.word	0x70690a0d
    5fb8:	20667265 	.word	0x20667265
    5fbc:	74736e69 	.word	0x74736e69
    5fc0:	65636e61 	.word	0x65636e61
    5fc4:	3a642520 	.word	0x3a642520
    5fc8:	20785220 	.word	0x20785220
    5fcc:	656e6f64 	.word	0x656e6f64
    5fd0:	6f53202e 	.word	0x6f53202e
    5fd4:	74656b63 	.word	0x74656b63
    5fd8:	6f6c6320 	.word	0x6f6c6320
    5fdc:	2e646573 	.word	0x2e646573
    5fe0:	00000a0d 	.word	0x00000a0d
    5fe4:	72657069 	.word	0x72657069
    5fe8:	6e692066 	.word	0x6e692066
    5fec:	6e617473 	.word	0x6e617473
    5ff0:	25206563 	.word	0x25206563
    5ff4:	52203a64 	.word	0x52203a64
    5ff8:	79646165 	.word	0x79646165
    5ffc:	726f6620 	.word	0x726f6620
    6000:	65687420 	.word	0x65687420
    6004:	78656e20 	.word	0x78656e20
    6008:	65732074 	.word	0x65732074
    600c:	6f697373 	.word	0x6f697373
    6010:	0a0d2e6e 	.word	0x0a0d2e6e
    6014:	00000000 	.word	0x00000000
    6018:	72657069 	.word	0x72657069
    601c:	6e692066 	.word	0x6e692066
    6020:	6e617473 	.word	0x6e617473
    6024:	25206563 	.word	0x25206563
    6028:	63203a64 	.word	0x63203a64
    602c:	6c706d6f 	.word	0x6c706d6f
    6030:	64657465 	.word	0x64657465
    6034:	000a0d2e 	.word	0x000a0d2e
    6038:	72657069 	.word	0x72657069
    603c:	63203a66 	.word	0x63203a66
    6040:	6e65696c 	.word	0x6e65696c
    6044:	65732074 	.word	0x65732074
    6048:	6f697373 	.word	0x6f697373
    604c:	6c63206e 	.word	0x6c63206e
    6050:	6465736f 	.word	0x6465736f
    6054:	000a0d2e 	.word	0x000a0d2e
    6058:	72657069 	.word	0x72657069
    605c:	41203a66 	.word	0x41203a66
    6060:	75205052 	.word	0x75205052
    6064:	6c62616e 	.word	0x6c62616e
    6068:	6f742065 	.word	0x6f742065
    606c:	73657220 	.word	0x73657220
    6070:	65766c6f 	.word	0x65766c6f
    6074:	65687420 	.word	0x65687420
    6078:	43414d20 	.word	0x43414d20
    607c:	64646120 	.word	0x64646120
    6080:	73736572 	.word	0x73736572
    6084:	20666f20 	.word	0x20666f20
    6088:	6f6d6572 	.word	0x6f6d6572
    608c:	73206574 	.word	0x73206574
    6090:	2e656469 	.word	0x2e656469
    6094:	00000a0d 	.word	0x00000a0d
    6098:	20202020 	.word	0x20202020
    609c:	6552202d 	.word	0x6552202d
    60a0:	65746f6d 	.word	0x65746f6d
    60a4:	65646f4e 	.word	0x65646f4e
    60a8:	43414d20 	.word	0x43414d20
    60ac:	7825203a 	.word	0x7825203a
    60b0:	20782520 	.word	0x20782520
    60b4:	25207825 	.word	0x25207825
    60b8:	78252078 	.word	0x78252078
    60bc:	0d782520 	.word	0x0d782520
    60c0:	0000000a 	.word	0x0000000a
    60c4:	72657069 	.word	0x72657069
    60c8:	53203a66 	.word	0x53203a66
    60cc:	6f207465 	.word	0x6f207465
    60d0:	58542066 	.word	0x58542066
    60d4:	66756220 	.word	0x66756220
    60d8:	20726566 	.word	0x20726566
    60dc:	657a6973 	.word	0x657a6973
    60e0:	69616620 	.word	0x69616620
    60e4:	0d64656c 	.word	0x0d64656c
    60e8:	0000000a 	.word	0x0000000a
    60ec:	72657069 	.word	0x72657069
    60f0:	53203a66 	.word	0x53203a66
    60f4:	6f207465 	.word	0x6f207465
    60f8:	58542066 	.word	0x58542066
    60fc:	65757120 	.word	0x65757120
    6100:	676e6975 	.word	0x676e6975
    6104:	6d696c20 	.word	0x6d696c20
    6108:	66207469 	.word	0x66207469
    610c:	656c6961 	.word	0x656c6961
    6110:	000a0d64 	.word	0x000a0d64
    6114:	72657069 	.word	0x72657069
    6118:	43203a66 	.word	0x43203a66
    611c:	6e65696c 	.word	0x6e65696c
    6120:	6f632074 	.word	0x6f632074
    6124:	63656e6e 	.word	0x63656e6e
    6128:	676e6974 	.word	0x676e6974
    612c:	206f7420 	.word	0x206f7420
    6130:	252e7525 	.word	0x252e7525
    6134:	75252e75 	.word	0x75252e75
    6138:	2c75252e 	.word	0x2c75252e
    613c:	50445520 	.word	0x50445520
    6140:	726f7020 	.word	0x726f7020
    6144:	75252074 	.word	0x75252074
    6148:	00000a0d 	.word	0x00000a0d
    614c:	72657069 	.word	0x72657069
    6150:	43203a66 	.word	0x43203a66
    6154:	6e65696c 	.word	0x6e65696c
    6158:	6f632074 	.word	0x6f632074
    615c:	63656e6e 	.word	0x63656e6e
    6160:	676e6974 	.word	0x676e6974
    6164:	206f7420 	.word	0x206f7420
    6168:	252e7525 	.word	0x252e7525
    616c:	75252e75 	.word	0x75252e75
    6170:	2c75252e 	.word	0x2c75252e
    6174:	50435420 	.word	0x50435420
    6178:	726f7020 	.word	0x726f7020
    617c:	75252074 	.word	0x75252074
    6180:	00000a0d 	.word	0x00000a0d
    6184:	72657069 	.word	0x72657069
    6188:	54203a66 	.word	0x54203a66
    618c:	43205043 	.word	0x43205043
    6190:	6e65696c 	.word	0x6e65696c
    6194:	6f632074 	.word	0x6f632074
    6198:	63656e6e 	.word	0x63656e6e
    619c:	6e6f6974 	.word	0x6e6f6974
    61a0:	6d697420 	.word	0x6d697420
    61a4:	74756f65 	.word	0x74756f65
    61a8:	00000a0d 	.word	0x00000a0d
    61ac:	7069203a 	.word	0x7069203a
    61b0:	20667265 	.word	0x20667265
    61b4:	6d6d6f63 	.word	0x6d6d6f63
    61b8:	73646e61 	.word	0x73646e61
    61bc:	00000000 	.word	0x00000000
    61c0:	72657069 	.word	0x72657069
    61c4:	00000066 	.word	0x00000066
    61c8:	3c20203a 	.word	0x3c20203a
    61cc:	72657069 	.word	0x72657069
    61d0:	73203e66 	.word	0x73203e66
    61d4:	74726174 	.word	0x74726174
    61d8:	646d6320 	.word	0x646d6320
    61dc:	00000000 	.word	0x00000000
    61e0:	72657069 	.word	0x72657069
    61e4:	00006b66 	.word	0x00006b66
    61e8:	693c203a 	.word	0x693c203a
    61ec:	66726570 	.word	0x66726570
    61f0:	6b203e6b 	.word	0x6b203e6b
    61f4:	206c6c69 	.word	0x206c6c69
    61f8:	00646d63 	.word	0x00646d63
    61fc:	72657069 	.word	0x72657069
    6200:	00006966 	.word	0x00006966
    6204:	693c203a 	.word	0x693c203a
    6208:	66726570 	.word	0x66726570
    620c:	64612069 	.word	0x64612069
    6210:	73657264 	.word	0x73657264
    6214:	20203e73 	.word	0x20203e73
    6218:	65746e69 	.word	0x65746e69
    621c:	63616672 	.word	0x63616672
    6220:	6d632065 	.word	0x6d632065
    6224:	00000064 	.word	0x00000064
    6228:	72657069 	.word	0x72657069
    622c:	00007366 	.word	0x00007366
    6230:	693c203a 	.word	0x693c203a
    6234:	66726570 	.word	0x66726570
    6238:	78742073 	.word	0x78742073
    623c:	2078722f 	.word	0x2078722f
    6240:	657a6973 	.word	0x657a6973
    6244:	7874203e 	.word	0x7874203e
    6248:	2078722f 	.word	0x2078722f
    624c:	657a6973 	.word	0x657a6973
    6250:	646d6320 	.word	0x646d6320
    6254:	00          	.byte	0x00
    6255:	00          	.byte	0x00
    6256:	bf00      	nop

Disassembly of section .rodata.macPIC32CHwRegDcpt%187:

00006258 <macPIC32CHwRegDcpt>:
    6258:	7854 4220 7479 2065 6f43 6e75 2d74 6f6c     Tx Byte Count-lo
    6268:	6577 2072 3233 6962 7374 5428 4f78 4c54     wer 32bits(TxOTL
    6278:	294f 0000 1d75 0002 7854 4220 7479 2065     O)..u...Tx Byte 
    6288:	6f43 6e75 2d74 7075 6570 2072 3631 6962     Count-upper 16bi
    6298:	7374 5428 4f78 4854 2949 0000 1d81 0002     ts(TxOTHI)......
    62a8:	7854 4620 6172 656d 2073 2f77 206f 7265     Tx Frames w/o er
    62b8:	6f72 2872 7854 5446 4e43 2954 0000 0000     ror(TxFTCNT)....
    62c8:	0000 0000 1d8d 0002 7854 4220 6f72 6461     ........Tx Broad
    62d8:	6163 7473 4620 6172 656d 2873 7854 4342     cast Frames(TxBC
    62e8:	5446 0029 0000 0000 0000 0000 1d99 0002     FT).............
    62f8:	7854 4d20 6c75 6974 6163 7473 4620 6172     Tx Multicast Fra
    6308:	656d 2873 7854 464d 2954 0000 0000 0000     mes(TxMFT)......
    6318:	0000 0000 1da5 0002 7854 5020 7561 6573     ........Tx Pause
    6328:	4620 6172 656d 2873 7854 4650 2954 0000      Frames(TxPFT)..
	...
    6344:	1db1 0002 7854 3620 2d34 7962 6574 4620     ....Tx 64-byte F
    6354:	6172 656d 2873 7854 4642 3654 2934 0000     rames(TxBFT64)..
	...
    636c:	1dbd 0002 7854 3620 2d35 3231 2037 7962     ....Tx 65-127 by
    637c:	6574 4620 6172 656d 2873 4254 5446 3231     te Frames(TBFT12
    638c:	2937 0000 0000 0000 1dc9 0002 7854 3120     7)..........Tx 1
    639c:	3832 322d 3535 6220 7479 2065 7246 6d61     28-255 byte Fram
    63ac:	7365 5428 4642 3254 3535 0029 0000 0000     es(TBFT255).....
    63bc:	1dd5 0002 7854 3220 3635 352d 3131 6220     ....Tx 256-511 b
    63cc:	7479 2065 7246 6d61 7365 5428 4642 3554     yte Frames(TBFT5
    63dc:	3131 0029 0000 0000 1de1 0002 7854 3520     11).........Tx 5
    63ec:	3231 312d 3230 2033 7962 6574 4620 6172     12-1023 byte Fra
    63fc:	656d 2873 4254 5446 3031 3332 0029 0000     mes(TBFT1023)...
    640c:	1ded 0002 7854 3120 3230 2d34 3531 3831     ....Tx 1024-1518
    641c:	6220 7479 2065 7246 6d61 7365 5428 4642      byte Frames(TBF
    642c:	3154 3135 2938 0000 1df9 0002 7854 4620     T1518)......Tx F
    643c:	6172 656d 2073 3d3e 3120 3135 2038 7962     rames >= 1518 by
    644c:	6574 4728 4254 3146 3135 2938 0000 0000     te(GTBF1518)....
    645c:	1e05 0002 7854 5520 646e 7265 7572 206e     ....Tx Underrun 
    646c:	7246 6d61 7365 6e20 746f 5420 6558 2864     Frames not TXed(
    647c:	7854 5554 2952 0000 1e11 0002 7854 5320     TxTUR)......Tx S
    648c:	6e69 6c67 2065 6f43 6c6c 7369 6f69 206e     ingle Collision 
    649c:	7246 6d61 7365 5428 5378 4643 0029 0000     Frames(TxSCF)...
    64ac:	1e1d 0002 7854 3220 312d 2035 6f43 6c6c     ....Tx 2-15 Coll
    64bc:	7369 6f69 206e 7246 6d61 7365 5428 4d78     ision Frames(TxM
    64cc:	4643 0029 0000 0000 1e29 0002 7854 3120     CF).....)...Tx 1
    64dc:	2036 6f43 6c6c 7369 6f69 206e 7246 6d61     6 Collision Fram
    64ec:	7365 5428 4578 4343 544e 0029 0000 0000     es(TxECCNT).....
    64fc:	1e35 0002 7854 6c20 7461 2065 6f43 6c6c     5...Tx late Coll
    650c:	7369 6f69 206e 7246 6d61 7365 5428 4c78     ision Frames(TxL
    651c:	4343 544e 0029 0000 1e41 0002 7854 4420     CCNT)...A...Tx D
    652c:	6665 7265 6572 2064 7246 6d61 7365 5428     eferred Frames(T
    653c:	4478 4654 0029 0000 0000 0000 0000 0000     xDTF)...........
    654c:	1e4d 0002 7854 4320 7261 6972 7265 5320     M...Tx Carrier S
    655c:	6e65 6573 6520 7272 726f 4620 6172 656d     ense error Frame
    656c:	2873 7854 5343 2945 1e59 0002 7852 4220     s(TxCSE)Y...Rx B
    657c:	7479 2065 6f43 6e75 2d74 6f6c 6577 2072     yte Count-lower 
    658c:	3233 6962 7374 5228 4f78 4c52 294f 0000     32bits(RxORLO)..
    659c:	1e65 0002 7852 4220 7479 2065 6f43 6e75     e...Rx Byte Coun
    65ac:	2d74 7075 6570 2072 3631 6962 7374 5228     t-upper 16bits(R
    65bc:	4f78 4852 2949 0000 1e71 0002 7852 4620     xORHI)..q...Rx F
    65cc:	6172 656d 2073 2f77 206f 7265 6f72 2872     rames w/o error(
    65dc:	7852 5246 4e43 2954 0000 0000 0000 0000     RxFRCNT)........
    65ec:	1e7d 0002 7852 4220 6f72 6461 6163 7473     }...Rx Broadcast
    65fc:	4620 6172 656d 2873 7852 4342 5246 0029      Frames(RxBCFR).
	...
    6614:	1e89 0002 7852 4d20 6c75 6974 6163 7473     ....Rx Multicast
    6624:	4620 6172 656d 2073 5228 4d78 5246 0029      Frames (RxMFR).
	...
    663c:	1e95 0002 7852 5020 7561 6573 4620 6172     ....Rx Pause Fra
    664c:	656d 2873 7852 4650 2952 0000 0000 0000     mes(RxPFR)......
	...
    6664:	1ea1 0002 7852 3620 2d34 7962 6574 4620     ....Rx 64-byte F
    6674:	6172 656d 2873 7852 4642 3652 2934 0000     rames(RxBFR64)..
	...
    668c:	1ead 0002 7852 3620 2d35 3231 2037 7962     ....Rx 65-127 by
    669c:	6574 4620 6172 656d 2873 4254 5246 3231     te Frames(TBFR12
    66ac:	2937 0000 0000 0000 1eb9 0002 7852 3120     7)..........Rx 1
    66bc:	3832 322d 3535 6220 7479 2065 7246 6d61     28-255 byte Fram
    66cc:	7365 5428 4642 3252 3535 0029 0000 0000     es(TBFR255).....
    66dc:	1ec5 0002 7852 3220 3635 352d 3131 6220     ....Rx 256-511 b
    66ec:	7479 2065 7246 6d61 7365 5428 4642 3552     yte Frames(TBFR5
    66fc:	3131 0029 0000 0000 1ed1 0002 7852 3520     11).........Rx 5
    670c:	3231 312d 3230 2033 7962 6574 4620 6172     12-1023 byte Fra
    671c:	656d 2873 4254 5246 3031 3332 0029 0000     mes(TBFR1023)...
    672c:	1edd 0002 7852 3120 3230 2d34 3531 3831     ....Rx 1024-1518
    673c:	6220 7479 2065 7246 6d61 7365 5428 4642      byte Frames(TBF
    674c:	3152 3135 2938 0000 1ee9 0002 7852 4620     R1518)......Rx F
    675c:	6172 656d 2073 3d3e 3120 3135 2039 7962     rames >= 1519 by
    676c:	6574 2873 4d54 4258 5246 0029 0000 0000     tes(TMXBFR).....
    677c:	1ef5 0002 7852 4620 6172 656d 2073 203c     ....Rx Frames < 
    678c:	3436 6220 7479 7365 5228 5578 5246 0029     64 bytes(RxUFR).
	...
    67a4:	1f01 0002 7852 4620 6172 656d 2073 203e     ....Rx Frames > 
    67b4:	3531 3831 6220 7479 7365 5228 4f78 5246     1518 bytes(RxOFR
    67c4:	0029 0000 0000 0000 1f0d 0002 7852 6520     )...........Rx e
    67d4:	7272 726f 4620 6172 656d 2073 203e 3531     rror Frames > 15
    67e4:	3831 6220 7479 7365 5228 4a78 2952 0000     18 bytes(RxJR)..
    67f4:	1f19 0002 7852 4320 4352 6520 7272 726f     ....Rx CRC error
    6804:	4620 6172 656d 2873 7852 4346 4553 0029      Frames(RxFCSE).
	...
    681c:	1f25 0002 7852 4c20 6e65 7467 2068 6966     %...Rx Length fi
    682c:	6c65 2064 7265 6f72 2072 7246 6d61 7365     eld error Frames
    683c:	5228 4c78 4646 2945 1f31 0002 7852 7320     (RxLFFE)1...Rx s
    684c:	6d79 6f62 206c 7265 6f72 2072 7246 6d61     ymbol error Fram
    685c:	7365 5228 5278 4553 0029 0000 0000 0000     es(RxRSE).......
    686c:	1f3d 0002 7852 6120 696c 6e67 656d 746e     =...Rx alignment
    687c:	6520 7272 726f 4620 6172 656d 2873 7852      error Frames(Rx
    688c:	4541 0029 0000 0000 1f49 0002 7852 5220     AE).....I...Rx R
    689c:	7365 756f 6372 2065 7245 6f72 2072 5228     esource Error (R
    68ac:	5278 4552 0029 0000 0000 0000 0000 0000     xRRE)...........
    68bc:	1f55 0002 7852 6f20 6576 7272 6e75 6520     U...Rx overrun e
    68cc:	7272 726f 4620 6172 656d 2873 7852 4f52     rror Frames(RxRO
    68dc:	2945 0000 0000 0000 1f61 0002 7852 4920     E)......a...Rx I
    68ec:	4850 7264 4320 6b68 7573 206d 7265 6f72     PHdr Chksum erro
    68fc:	2072 7246 6d61 7365 5228 4978 4348 2945     r Frames(RxIHCE)
    690c:	1f6d 0002 7852 5420 5043 4320 6b68 7573     m...Rx TCP Chksu
    691c:	206d 7265 6f72 2072 7246 6d61 7365 5228     m error Frames(R
    692c:	5478 4543 0029 0000 1f79 0002 7852 5520     xTCE)...y...Rx U
    693c:	5044 4320 6b68 7573 206d 7265 6f72 2072     DP Chksum error 
    694c:	7246 6d61 7365 5228 5578 4543 0029 0000     Frames(RxUCE)...
    695c:	1f85 0002                                   ....

Disassembly of section .text.Transform%188:

00006960 <Transform>:

#define MD5STEP(f, w, x, y, z, data, s) \
        w = rotlFixed(w + f(x, y, z) + data, s) + x

static int Transform(wc_Md5* md5, const byte* data)
{
    6960:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6964:	b08d      	sub	sp, #52	; 0x34
    word32* buffer = (word32*)data;
    /* Copy context->state[] to working vars  */
    word32 a = md5->digest[0];
    word32 b = md5->digest[1];
    6966:	f8d0 a050 	ldr.w	sl, [r0, #80]	; 0x50
    word32 c = md5->digest[2];
    word32 d = md5->digest[3];

    MD5STEP(F1, a, b, c, d, buffer[0]  + 0xd76aa478,  7);
    696a:	680a      	ldr	r2, [r1, #0]
    696c:	6d43      	ldr	r3, [r0, #84]	; 0x54
    696e:	6d84      	ldr	r4, [r0, #88]	; 0x58
    6970:	ea83 0e04 	eor.w	lr, r3, r4
    6974:	ea0e 0e0a 	and.w	lr, lr, sl
    6978:	ea8e 0e04 	eor.w	lr, lr, r4
    697c:	4bd8      	ldr	r3, [pc, #864]	; (6ce0 <Transform+0x380>)
    697e:	6cc4      	ldr	r4, [r0, #76]	; 0x4c
    6980:	4423      	add	r3, r4
    6982:	920a      	str	r2, [sp, #40]	; 0x28
    6984:	4413      	add	r3, r2
    6986:	449e      	add	lr, r3
    6988:	eb0a 6e7e 	add.w	lr, sl, lr, ror #25
    MD5STEP(F1, d, a, b, c, buffer[1]  + 0xe8c7b756, 12);
    698c:	684e      	ldr	r6, [r1, #4]
    698e:	6d43      	ldr	r3, [r0, #84]	; 0x54
    6990:	ea8a 0703 	eor.w	r7, sl, r3
    6994:	ea07 070e 	and.w	r7, r7, lr
    6998:	405f      	eors	r7, r3
    699a:	4bd2      	ldr	r3, [pc, #840]	; (6ce4 <Transform+0x384>)
    699c:	6d85      	ldr	r5, [r0, #88]	; 0x58
    699e:	442b      	add	r3, r5
    69a0:	9600      	str	r6, [sp, #0]
    69a2:	4433      	add	r3, r6
    69a4:	441f      	add	r7, r3
    69a6:	eb0e 5737 	add.w	r7, lr, r7, ror #20
    MD5STEP(F1, c, d, a, b, buffer[2]  + 0x242070db, 17);
    69aa:	688b      	ldr	r3, [r1, #8]
    69ac:	461a      	mov	r2, r3
    69ae:	ea8a 050e 	eor.w	r5, sl, lr
    69b2:	403d      	ands	r5, r7
    69b4:	ea85 050a 	eor.w	r5, r5, sl
    69b8:	4bcb      	ldr	r3, [pc, #812]	; (6ce8 <Transform+0x388>)
    69ba:	6d44      	ldr	r4, [r0, #84]	; 0x54
    69bc:	4423      	add	r3, r4
    69be:	9201      	str	r2, [sp, #4]
    69c0:	4413      	add	r3, r2
    69c2:	441d      	add	r5, r3
    69c4:	eb07 35f5 	add.w	r5, r7, r5, ror #15
    MD5STEP(F1, b, c, d, a, buffer[3]  + 0xc1bdceee, 22);
    69c8:	68cb      	ldr	r3, [r1, #12]
    69ca:	461c      	mov	r4, r3
    69cc:	ea8e 0607 	eor.w	r6, lr, r7
    69d0:	402e      	ands	r6, r5
    69d2:	ea86 060e 	eor.w	r6, r6, lr
    69d6:	4bc5      	ldr	r3, [pc, #788]	; (6cec <Transform+0x38c>)
    69d8:	4453      	add	r3, sl
    69da:	9402      	str	r4, [sp, #8]
    69dc:	4423      	add	r3, r4
    69de:	441e      	add	r6, r3
    69e0:	eb05 26b6 	add.w	r6, r5, r6, ror #10
    MD5STEP(F1, a, b, c, d, buffer[4]  + 0xf57c0faf,  7);
    69e4:	690b      	ldr	r3, [r1, #16]
    69e6:	461c      	mov	r4, r3
    69e8:	ea87 0305 	eor.w	r3, r7, r5
    69ec:	4033      	ands	r3, r6
    69ee:	407b      	eors	r3, r7
    69f0:	4abf      	ldr	r2, [pc, #764]	; (6cf0 <Transform+0x390>)
    69f2:	9403      	str	r4, [sp, #12]
    69f4:	4422      	add	r2, r4
    69f6:	4496      	add	lr, r2
    69f8:	4473      	add	r3, lr
    69fa:	eb06 6973 	add.w	r9, r6, r3, ror #25
    MD5STEP(F1, d, a, b, c, buffer[5]  + 0x4787c62a, 12);
    69fe:	694a      	ldr	r2, [r1, #20]
    6a00:	4613      	mov	r3, r2
    6a02:	ea85 0406 	eor.w	r4, r5, r6
    6a06:	ea04 0409 	and.w	r4, r4, r9
    6a0a:	406c      	eors	r4, r5
    6a0c:	4ab9      	ldr	r2, [pc, #740]	; (6cf4 <Transform+0x394>)
    6a0e:	9304      	str	r3, [sp, #16]
    6a10:	441a      	add	r2, r3
    6a12:	4417      	add	r7, r2
    6a14:	443c      	add	r4, r7
    6a16:	eb09 5434 	add.w	r4, r9, r4, ror #20
    MD5STEP(F1, c, d, a, b, buffer[6]  + 0xa8304613, 17);
    6a1a:	698b      	ldr	r3, [r1, #24]
    6a1c:	ea86 0209 	eor.w	r2, r6, r9
    6a20:	4022      	ands	r2, r4
    6a22:	4072      	eors	r2, r6
    6a24:	4fb4      	ldr	r7, [pc, #720]	; (6cf8 <Transform+0x398>)
    6a26:	9305      	str	r3, [sp, #20]
    6a28:	441f      	add	r7, r3
    6a2a:	443d      	add	r5, r7
    6a2c:	442a      	add	r2, r5
    6a2e:	eb04 32f2 	add.w	r2, r4, r2, ror #15
    MD5STEP(F1, b, c, d, a, buffer[7]  + 0xfd469501, 22);
    6a32:	69cf      	ldr	r7, [r1, #28]
    6a34:	ea89 0804 	eor.w	r8, r9, r4
    6a38:	ea08 0802 	and.w	r8, r8, r2
    6a3c:	ea88 0809 	eor.w	r8, r8, r9
    6a40:	4dae      	ldr	r5, [pc, #696]	; (6cfc <Transform+0x39c>)
    6a42:	9706      	str	r7, [sp, #24]
    6a44:	443d      	add	r5, r7
    6a46:	442e      	add	r6, r5
    6a48:	44b0      	add	r8, r6
    6a4a:	eb02 28b8 	add.w	r8, r2, r8, ror #10
    MD5STEP(F1, a, b, c, d, buffer[8]  + 0x698098d8,  7);
    6a4e:	6a0f      	ldr	r7, [r1, #32]
    6a50:	ea84 0c02 	eor.w	ip, r4, r2
    6a54:	ea0c 0c08 	and.w	ip, ip, r8
    6a58:	ea8c 0c04 	eor.w	ip, ip, r4
    6a5c:	4da8      	ldr	r5, [pc, #672]	; (6d00 <Transform+0x3a0>)
    6a5e:	9707      	str	r7, [sp, #28]
    6a60:	443d      	add	r5, r7
    6a62:	eb09 0305 	add.w	r3, r9, r5
    6a66:	449c      	add	ip, r3
    6a68:	eb08 6c7c 	add.w	ip, r8, ip, ror #25
    MD5STEP(F1, d, a, b, c, buffer[9]  + 0x8b44f7af, 12);
    6a6c:	6a4d      	ldr	r5, [r1, #36]	; 0x24
    6a6e:	ea82 0908 	eor.w	r9, r2, r8
    6a72:	ea09 090c 	and.w	r9, r9, ip
    6a76:	ea89 0902 	eor.w	r9, r9, r2
    6a7a:	4ba2      	ldr	r3, [pc, #648]	; (6d04 <Transform+0x3a4>)
    6a7c:	9508      	str	r5, [sp, #32]
    6a7e:	442b      	add	r3, r5
    6a80:	441c      	add	r4, r3
    6a82:	44a1      	add	r9, r4
    6a84:	eb0c 5939 	add.w	r9, ip, r9, ror #20
    MD5STEP(F1, c, d, a, b, buffer[10] + 0xffff5bb1, 17);
    6a88:	6a8b      	ldr	r3, [r1, #40]	; 0x28
    6a8a:	ea88 0e0c 	eor.w	lr, r8, ip
    6a8e:	ea0e 0e09 	and.w	lr, lr, r9
    6a92:	ea8e 0e08 	eor.w	lr, lr, r8
    6a96:	9309      	str	r3, [sp, #36]	; 0x24
    6a98:	f5a3 4324 	sub.w	r3, r3, #41984	; 0xa400
    6a9c:	3b4f      	subs	r3, #79	; 0x4f
    6a9e:	441a      	add	r2, r3
    6aa0:	4496      	add	lr, r2
    6aa2:	eb09 3efe 	add.w	lr, r9, lr, ror #15
    MD5STEP(F1, b, c, d, a, buffer[11] + 0x895cd7be, 22);
    6aa6:	6aca      	ldr	r2, [r1, #44]	; 0x2c
    6aa8:	4616      	mov	r6, r2
    6aaa:	ea8c 0509 	eor.w	r5, ip, r9
    6aae:	ea05 050e 	and.w	r5, r5, lr
    6ab2:	ea85 050c 	eor.w	r5, r5, ip
    6ab6:	4b94      	ldr	r3, [pc, #592]	; (6d08 <Transform+0x3a8>)
    6ab8:	4413      	add	r3, r2
    6aba:	4498      	add	r8, r3
    6abc:	4445      	add	r5, r8
    6abe:	eb0e 25b5 	add.w	r5, lr, r5, ror #10
    MD5STEP(F1, a, b, c, d, buffer[12] + 0x6b901122,  7);
    6ac2:	f8d1 8030 	ldr.w	r8, [r1, #48]	; 0x30
    6ac6:	ea89 070e 	eor.w	r7, r9, lr
    6aca:	402f      	ands	r7, r5
    6acc:	ea87 0709 	eor.w	r7, r7, r9
    6ad0:	4b8e      	ldr	r3, [pc, #568]	; (6d0c <Transform+0x3ac>)
    6ad2:	4443      	add	r3, r8
    6ad4:	449c      	add	ip, r3
    6ad6:	4467      	add	r7, ip
    6ad8:	eb05 6777 	add.w	r7, r5, r7, ror #25
    MD5STEP(F1, d, a, b, c, buffer[13] + 0xfd987193, 12);
    6adc:	f8d1 c034 	ldr.w	ip, [r1, #52]	; 0x34
    6ae0:	ea8e 0305 	eor.w	r3, lr, r5
    6ae4:	403b      	ands	r3, r7
    6ae6:	ea83 030e 	eor.w	r3, r3, lr
    6aea:	4a89      	ldr	r2, [pc, #548]	; (6d10 <Transform+0x3b0>)
    6aec:	4462      	add	r2, ip
    6aee:	4491      	add	r9, r2
    6af0:	444b      	add	r3, r9
    6af2:	eb07 5333 	add.w	r3, r7, r3, ror #20
    MD5STEP(F1, c, d, a, b, buffer[14] + 0xa679438e, 17);
    6af6:	f8d1 9038 	ldr.w	r9, [r1, #56]	; 0x38
    6afa:	ea85 0407 	eor.w	r4, r5, r7
    6afe:	401c      	ands	r4, r3
    6b00:	406c      	eors	r4, r5
    6b02:	4a84      	ldr	r2, [pc, #528]	; (6d14 <Transform+0x3b4>)
    6b04:	444a      	add	r2, r9
    6b06:	4496      	add	lr, r2
    6b08:	4474      	add	r4, lr
    6b0a:	eb03 34f4 	add.w	r4, r3, r4, ror #15
    MD5STEP(F1, b, c, d, a, buffer[15] + 0x49b40821, 22);
    6b0e:	f8d1 e03c 	ldr.w	lr, [r1, #60]	; 0x3c
    6b12:	ea87 0203 	eor.w	r2, r7, r3
    6b16:	4022      	ands	r2, r4
    6b18:	407a      	eors	r2, r7
    6b1a:	497f      	ldr	r1, [pc, #508]	; (6d18 <Transform+0x3b8>)
    6b1c:	4471      	add	r1, lr
    6b1e:	440d      	add	r5, r1
    6b20:	442a      	add	r2, r5
    6b22:	eb04 22b2 	add.w	r2, r4, r2, ror #10

    MD5STEP(F2, a, b, c, d, buffer[1]  + 0xf61e2562,  5);
    6b26:	ea84 0b02 	eor.w	fp, r4, r2
    6b2a:	ea0b 0b03 	and.w	fp, fp, r3
    6b2e:	ea8b 0b04 	eor.w	fp, fp, r4
    6b32:	497a      	ldr	r1, [pc, #488]	; (6d1c <Transform+0x3bc>)
    6b34:	9d00      	ldr	r5, [sp, #0]
    6b36:	4429      	add	r1, r5
    6b38:	440f      	add	r7, r1
    6b3a:	44bb      	add	fp, r7
    6b3c:	eb02 6bfb 	add.w	fp, r2, fp, ror #27
    MD5STEP(F2, d, a, b, c, buffer[6]  + 0xc040b340,  9);
    6b40:	ea82 070b 	eor.w	r7, r2, fp
    6b44:	4027      	ands	r7, r4
    6b46:	4057      	eors	r7, r2
    6b48:	4975      	ldr	r1, [pc, #468]	; (6d20 <Transform+0x3c0>)
    6b4a:	9d05      	ldr	r5, [sp, #20]
    6b4c:	4429      	add	r1, r5
    6b4e:	440b      	add	r3, r1
    6b50:	441f      	add	r7, r3
    6b52:	eb0b 57f7 	add.w	r7, fp, r7, ror #23
    MD5STEP(F2, c, d, a, b, buffer[11] + 0x265e5a51, 14);
    6b56:	ea8b 0307 	eor.w	r3, fp, r7
    6b5a:	4013      	ands	r3, r2
    6b5c:	ea83 030b 	eor.w	r3, r3, fp
    6b60:	4970      	ldr	r1, [pc, #448]	; (6d24 <Transform+0x3c4>)
    6b62:	960b      	str	r6, [sp, #44]	; 0x2c
    6b64:	4431      	add	r1, r6
    6b66:	440c      	add	r4, r1
    6b68:	4423      	add	r3, r4
    6b6a:	eb07 43b3 	add.w	r3, r7, r3, ror #18
    MD5STEP(F2, b, c, d, a, buffer[0]  + 0xe9b6c7aa, 20);
    6b6e:	ea87 0503 	eor.w	r5, r7, r3
    6b72:	ea05 050b 	and.w	r5, r5, fp
    6b76:	407d      	eors	r5, r7
    6b78:	496b      	ldr	r1, [pc, #428]	; (6d28 <Transform+0x3c8>)
    6b7a:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    6b7c:	4421      	add	r1, r4
    6b7e:	440a      	add	r2, r1
    6b80:	4415      	add	r5, r2
    6b82:	eb03 3535 	add.w	r5, r3, r5, ror #12
    MD5STEP(F2, a, b, c, d, buffer[5]  + 0xd62f105d,  5);
    6b86:	ea83 0205 	eor.w	r2, r3, r5
    6b8a:	403a      	ands	r2, r7
    6b8c:	405a      	eors	r2, r3
    6b8e:	4967      	ldr	r1, [pc, #412]	; (6d2c <Transform+0x3cc>)
    6b90:	9e04      	ldr	r6, [sp, #16]
    6b92:	4431      	add	r1, r6
    6b94:	448b      	add	fp, r1
    6b96:	445a      	add	r2, fp
    6b98:	eb05 62f2 	add.w	r2, r5, r2, ror #27
    MD5STEP(F2, d, a, b, c, buffer[10] + 0x02441453,  9);
    6b9c:	ea85 0102 	eor.w	r1, r5, r2
    6ba0:	4019      	ands	r1, r3
    6ba2:	4069      	eors	r1, r5
    6ba4:	4c62      	ldr	r4, [pc, #392]	; (6d30 <Transform+0x3d0>)
    6ba6:	9e09      	ldr	r6, [sp, #36]	; 0x24
    6ba8:	4434      	add	r4, r6
    6baa:	4427      	add	r7, r4
    6bac:	4439      	add	r1, r7
    6bae:	eb02 51f1 	add.w	r1, r2, r1, ror #23
    MD5STEP(F2, c, d, a, b, buffer[15] + 0xd8a1e681, 14);
    6bb2:	ea82 0401 	eor.w	r4, r2, r1
    6bb6:	402c      	ands	r4, r5
    6bb8:	4054      	eors	r4, r2
    6bba:	4f5e      	ldr	r7, [pc, #376]	; (6d34 <Transform+0x3d4>)
    6bbc:	4477      	add	r7, lr
    6bbe:	443b      	add	r3, r7
    6bc0:	441c      	add	r4, r3
    6bc2:	eb01 44b4 	add.w	r4, r1, r4, ror #18
    MD5STEP(F2, b, c, d, a, buffer[4]  + 0xe7d3fbc8, 20);
    6bc6:	ea81 0304 	eor.w	r3, r1, r4
    6bca:	4013      	ands	r3, r2
    6bcc:	404b      	eors	r3, r1
    6bce:	4f5a      	ldr	r7, [pc, #360]	; (6d38 <Transform+0x3d8>)
    6bd0:	9e03      	ldr	r6, [sp, #12]
    6bd2:	4437      	add	r7, r6
    6bd4:	443d      	add	r5, r7
    6bd6:	442b      	add	r3, r5
    6bd8:	eb04 3333 	add.w	r3, r4, r3, ror #12
    MD5STEP(F2, a, b, c, d, buffer[9]  + 0x21e1cde6,  5);
    6bdc:	ea84 0b03 	eor.w	fp, r4, r3
    6be0:	ea0b 0b01 	and.w	fp, fp, r1
    6be4:	ea8b 0b04 	eor.w	fp, fp, r4
    6be8:	4d54      	ldr	r5, [pc, #336]	; (6d3c <Transform+0x3dc>)
    6bea:	9e08      	ldr	r6, [sp, #32]
    6bec:	4435      	add	r5, r6
    6bee:	442a      	add	r2, r5
    6bf0:	4493      	add	fp, r2
    6bf2:	eb03 6bfb 	add.w	fp, r3, fp, ror #27
    MD5STEP(F2, d, a, b, c, buffer[14] + 0xc33707d6,  9);
    6bf6:	ea83 070b 	eor.w	r7, r3, fp
    6bfa:	4027      	ands	r7, r4
    6bfc:	405f      	eors	r7, r3
    6bfe:	4a50      	ldr	r2, [pc, #320]	; (6d40 <Transform+0x3e0>)
    6c00:	444a      	add	r2, r9
    6c02:	4411      	add	r1, r2
    6c04:	440f      	add	r7, r1
    6c06:	eb0b 57f7 	add.w	r7, fp, r7, ror #23
    MD5STEP(F2, c, d, a, b, buffer[3]  + 0xf4d50d87, 14);
    6c0a:	ea8b 0507 	eor.w	r5, fp, r7
    6c0e:	401d      	ands	r5, r3
    6c10:	ea85 050b 	eor.w	r5, r5, fp
    6c14:	4a4b      	ldr	r2, [pc, #300]	; (6d44 <Transform+0x3e4>)
    6c16:	9902      	ldr	r1, [sp, #8]
    6c18:	440a      	add	r2, r1
    6c1a:	4414      	add	r4, r2
    6c1c:	4425      	add	r5, r4
    6c1e:	eb07 45b5 	add.w	r5, r7, r5, ror #18
    MD5STEP(F2, b, c, d, a, buffer[8]  + 0x455a14ed, 20);
    6c22:	ea87 0205 	eor.w	r2, r7, r5
    6c26:	ea02 020b 	and.w	r2, r2, fp
    6c2a:	407a      	eors	r2, r7
    6c2c:	4946      	ldr	r1, [pc, #280]	; (6d48 <Transform+0x3e8>)
    6c2e:	9e07      	ldr	r6, [sp, #28]
    6c30:	4431      	add	r1, r6
    6c32:	440b      	add	r3, r1
    6c34:	441a      	add	r2, r3
    6c36:	eb05 3232 	add.w	r2, r5, r2, ror #12
    MD5STEP(F2, a, b, c, d, buffer[13] + 0xa9e3e905,  5);
    6c3a:	ea85 0302 	eor.w	r3, r5, r2
    6c3e:	403b      	ands	r3, r7
    6c40:	406b      	eors	r3, r5
    6c42:	4942      	ldr	r1, [pc, #264]	; (6d4c <Transform+0x3ec>)
    6c44:	4461      	add	r1, ip
    6c46:	448b      	add	fp, r1
    6c48:	445b      	add	r3, fp
    6c4a:	eb02 63f3 	add.w	r3, r2, r3, ror #27
    MD5STEP(F2, d, a, b, c, buffer[2]  + 0xfcefa3f8,  9);
    6c4e:	ea82 0103 	eor.w	r1, r2, r3
    6c52:	4029      	ands	r1, r5
    6c54:	4051      	eors	r1, r2
    6c56:	4c3e      	ldr	r4, [pc, #248]	; (6d50 <Transform+0x3f0>)
    6c58:	9e01      	ldr	r6, [sp, #4]
    6c5a:	4434      	add	r4, r6
    6c5c:	4427      	add	r7, r4
    6c5e:	4439      	add	r1, r7
    6c60:	eb03 51f1 	add.w	r1, r3, r1, ror #23
    MD5STEP(F2, c, d, a, b, buffer[7]  + 0x676f02d9, 14);
    6c64:	ea83 0401 	eor.w	r4, r3, r1
    6c68:	4014      	ands	r4, r2
    6c6a:	405c      	eors	r4, r3
    6c6c:	4f39      	ldr	r7, [pc, #228]	; (6d54 <Transform+0x3f4>)
    6c6e:	9e06      	ldr	r6, [sp, #24]
    6c70:	4437      	add	r7, r6
    6c72:	443d      	add	r5, r7
    6c74:	442c      	add	r4, r5
    6c76:	eb01 44b4 	add.w	r4, r1, r4, ror #18
    MD5STEP(F2, b, c, d, a, buffer[12] + 0x8d2a4c8a, 20);
    6c7a:	ea81 0b04 	eor.w	fp, r1, r4
    6c7e:	ea0b 0503 	and.w	r5, fp, r3
    6c82:	404d      	eors	r5, r1
    6c84:	4f34      	ldr	r7, [pc, #208]	; (6d58 <Transform+0x3f8>)
    6c86:	4447      	add	r7, r8
    6c88:	443a      	add	r2, r7
    6c8a:	4415      	add	r5, r2
    6c8c:	eb04 3535 	add.w	r5, r4, r5, ror #12

    MD5STEP(F3, a, b, c, d, buffer[5]  + 0xfffa3942,  4);
    6c90:	9f04      	ldr	r7, [sp, #16]
    6c92:	f5a7 22b8 	sub.w	r2, r7, #376832	; 0x5c000
    6c96:	f2a2 62be 	subw	r2, r2, #1726	; 0x6be
    6c9a:	4413      	add	r3, r2
    6c9c:	ea8b 0b05 	eor.w	fp, fp, r5
    6ca0:	445b      	add	r3, fp
    6ca2:	eb05 7333 	add.w	r3, r5, r3, ror #28
    MD5STEP(F3, d, a, b, c, buffer[8]  + 0x8771f681, 11);
    6ca6:	ea84 0205 	eor.w	r2, r4, r5
    6caa:	405a      	eors	r2, r3
    6cac:	4f2b      	ldr	r7, [pc, #172]	; (6d5c <Transform+0x3fc>)
    6cae:	9e07      	ldr	r6, [sp, #28]
    6cb0:	4437      	add	r7, r6
    6cb2:	4439      	add	r1, r7
    6cb4:	4411      	add	r1, r2
    6cb6:	eb03 5171 	add.w	r1, r3, r1, ror #21
    MD5STEP(F3, c, d, a, b, buffer[11] + 0x6d9d6122, 16);
    6cba:	ea85 0b03 	eor.w	fp, r5, r3
    6cbe:	ea8b 0b01 	eor.w	fp, fp, r1
    6cc2:	4a27      	ldr	r2, [pc, #156]	; (6d60 <Transform+0x400>)
    6cc4:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    6cc6:	443a      	add	r2, r7
    6cc8:	4414      	add	r4, r2
    6cca:	445c      	add	r4, fp
    6ccc:	eb01 4434 	add.w	r4, r1, r4, ror #16
    MD5STEP(F3, b, c, d, a, buffer[14] + 0xfde5380c, 23);
    6cd0:	ea83 0701 	eor.w	r7, r3, r1
    6cd4:	4067      	eors	r7, r4
    6cd6:	4a23      	ldr	r2, [pc, #140]	; (6d64 <Transform+0x404>)
    6cd8:	444a      	add	r2, r9
    6cda:	4415      	add	r5, r2
    6cdc:	442f      	add	r7, r5
    6cde:	e043      	b.n	6d68 <Transform+0x408>
    6ce0:	d76aa478 	.word	0xd76aa478
    6ce4:	e8c7b756 	.word	0xe8c7b756
    6ce8:	242070db 	.word	0x242070db
    6cec:	c1bdceee 	.word	0xc1bdceee
    6cf0:	f57c0faf 	.word	0xf57c0faf
    6cf4:	4787c62a 	.word	0x4787c62a
    6cf8:	a8304613 	.word	0xa8304613
    6cfc:	fd469501 	.word	0xfd469501
    6d00:	698098d8 	.word	0x698098d8
    6d04:	8b44f7af 	.word	0x8b44f7af
    6d08:	895cd7be 	.word	0x895cd7be
    6d0c:	6b901122 	.word	0x6b901122
    6d10:	fd987193 	.word	0xfd987193
    6d14:	a679438e 	.word	0xa679438e
    6d18:	49b40821 	.word	0x49b40821
    6d1c:	f61e2562 	.word	0xf61e2562
    6d20:	c040b340 	.word	0xc040b340
    6d24:	265e5a51 	.word	0x265e5a51
    6d28:	e9b6c7aa 	.word	0xe9b6c7aa
    6d2c:	d62f105d 	.word	0xd62f105d
    6d30:	02441453 	.word	0x02441453
    6d34:	d8a1e681 	.word	0xd8a1e681
    6d38:	e7d3fbc8 	.word	0xe7d3fbc8
    6d3c:	21e1cde6 	.word	0x21e1cde6
    6d40:	c33707d6 	.word	0xc33707d6
    6d44:	f4d50d87 	.word	0xf4d50d87
    6d48:	455a14ed 	.word	0x455a14ed
    6d4c:	a9e3e905 	.word	0xa9e3e905
    6d50:	fcefa3f8 	.word	0xfcefa3f8
    6d54:	676f02d9 	.word	0x676f02d9
    6d58:	8d2a4c8a 	.word	0x8d2a4c8a
    6d5c:	8771f681 	.word	0x8771f681
    6d60:	6d9d6122 	.word	0x6d9d6122
    6d64:	fde5380c 	.word	0xfde5380c
    6d68:	eb04 2777 	add.w	r7, r4, r7, ror #9
    MD5STEP(F3, a, b, c, d, buffer[1]  + 0xa4beea44,  4);
    6d6c:	ea81 0204 	eor.w	r2, r1, r4
    6d70:	407a      	eors	r2, r7
    6d72:	4d94      	ldr	r5, [pc, #592]	; (6fc4 <Transform+0x664>)
    6d74:	9e00      	ldr	r6, [sp, #0]
    6d76:	4435      	add	r5, r6
    6d78:	442b      	add	r3, r5
    6d7a:	4413      	add	r3, r2
    6d7c:	eb07 7333 	add.w	r3, r7, r3, ror #28
    MD5STEP(F3, d, a, b, c, buffer[4]  + 0x4bdecfa9, 11);
    6d80:	ea84 0207 	eor.w	r2, r4, r7
    6d84:	405a      	eors	r2, r3
    6d86:	4d90      	ldr	r5, [pc, #576]	; (6fc8 <Transform+0x668>)
    6d88:	9e03      	ldr	r6, [sp, #12]
    6d8a:	4435      	add	r5, r6
    6d8c:	4429      	add	r1, r5
    6d8e:	4411      	add	r1, r2
    6d90:	eb03 5171 	add.w	r1, r3, r1, ror #21
    MD5STEP(F3, c, d, a, b, buffer[7]  + 0xf6bb4b60, 16);
    6d94:	ea87 0b03 	eor.w	fp, r7, r3
    6d98:	ea8b 0b01 	eor.w	fp, fp, r1
    6d9c:	4a8b      	ldr	r2, [pc, #556]	; (6fcc <Transform+0x66c>)
    6d9e:	9d06      	ldr	r5, [sp, #24]
    6da0:	442a      	add	r2, r5
    6da2:	4414      	add	r4, r2
    6da4:	44a3      	add	fp, r4
    6da6:	eb01 4b3b 	add.w	fp, r1, fp, ror #16
    MD5STEP(F3, b, c, d, a, buffer[10] + 0xbebfbc70, 23);
    6daa:	ea83 0201 	eor.w	r2, r3, r1
    6dae:	ea82 020b 	eor.w	r2, r2, fp
    6db2:	4c87      	ldr	r4, [pc, #540]	; (6fd0 <Transform+0x670>)
    6db4:	9d09      	ldr	r5, [sp, #36]	; 0x24
    6db6:	442c      	add	r4, r5
    6db8:	4427      	add	r7, r4
    6dba:	443a      	add	r2, r7
    6dbc:	eb0b 2272 	add.w	r2, fp, r2, ror #9
    MD5STEP(F3, a, b, c, d, buffer[13] + 0x289b7ec6,  4);
    6dc0:	ea81 040b 	eor.w	r4, r1, fp
    6dc4:	4054      	eors	r4, r2
    6dc6:	4d83      	ldr	r5, [pc, #524]	; (6fd4 <Transform+0x674>)
    6dc8:	4465      	add	r5, ip
    6dca:	442b      	add	r3, r5
    6dcc:	4423      	add	r3, r4
    6dce:	eb02 7333 	add.w	r3, r2, r3, ror #28
    MD5STEP(F3, d, a, b, c, buffer[0]  + 0xeaa127fa, 11);
    6dd2:	ea8b 0702 	eor.w	r7, fp, r2
    6dd6:	405f      	eors	r7, r3
    6dd8:	4c7f      	ldr	r4, [pc, #508]	; (6fd8 <Transform+0x678>)
    6dda:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    6ddc:	4434      	add	r4, r6
    6dde:	4421      	add	r1, r4
    6de0:	440f      	add	r7, r1
    6de2:	eb03 5777 	add.w	r7, r3, r7, ror #21
    MD5STEP(F3, c, d, a, b, buffer[3]  + 0xd4ef3085, 16);
    6de6:	ea82 0503 	eor.w	r5, r2, r3
    6dea:	407d      	eors	r5, r7
    6dec:	497b      	ldr	r1, [pc, #492]	; (6fdc <Transform+0x67c>)
    6dee:	9c02      	ldr	r4, [sp, #8]
    6df0:	4421      	add	r1, r4
    6df2:	448b      	add	fp, r1
    6df4:	445d      	add	r5, fp
    6df6:	eb07 4535 	add.w	r5, r7, r5, ror #16
    MD5STEP(F3, b, c, d, a, buffer[6]  + 0x04881d05, 23);
    6dfa:	ea83 0b07 	eor.w	fp, r3, r7
    6dfe:	ea8b 0b05 	eor.w	fp, fp, r5
    6e02:	4977      	ldr	r1, [pc, #476]	; (6fe0 <Transform+0x680>)
    6e04:	9c05      	ldr	r4, [sp, #20]
    6e06:	4421      	add	r1, r4
    6e08:	440a      	add	r2, r1
    6e0a:	4493      	add	fp, r2
    6e0c:	eb05 2b7b 	add.w	fp, r5, fp, ror #9
    MD5STEP(F3, a, b, c, d, buffer[9]  + 0xd9d4d039,  4);
    6e10:	ea87 0405 	eor.w	r4, r7, r5
    6e14:	ea84 040b 	eor.w	r4, r4, fp
    6e18:	4a72      	ldr	r2, [pc, #456]	; (6fe4 <Transform+0x684>)
    6e1a:	9908      	ldr	r1, [sp, #32]
    6e1c:	440a      	add	r2, r1
    6e1e:	4413      	add	r3, r2
    6e20:	441c      	add	r4, r3
    6e22:	eb0b 7434 	add.w	r4, fp, r4, ror #28
    MD5STEP(F3, d, a, b, c, buffer[12] + 0xe6db99e5, 11);
    6e26:	ea85 010b 	eor.w	r1, r5, fp
    6e2a:	4061      	eors	r1, r4
    6e2c:	4b6e      	ldr	r3, [pc, #440]	; (6fe8 <Transform+0x688>)
    6e2e:	4443      	add	r3, r8
    6e30:	441f      	add	r7, r3
    6e32:	4439      	add	r1, r7
    6e34:	eb04 5171 	add.w	r1, r4, r1, ror #21
    MD5STEP(F3, c, d, a, b, buffer[15] + 0x1fa27cf8, 16);
    6e38:	ea8b 0304 	eor.w	r3, fp, r4
    6e3c:	404b      	eors	r3, r1
    6e3e:	4a6b      	ldr	r2, [pc, #428]	; (6fec <Transform+0x68c>)
    6e40:	4472      	add	r2, lr
    6e42:	4415      	add	r5, r2
    6e44:	441d      	add	r5, r3
    6e46:	eb01 4535 	add.w	r5, r1, r5, ror #16
    MD5STEP(F3, b, c, d, a, buffer[2]  + 0xc4ac5665, 23);
    6e4a:	ea84 0201 	eor.w	r2, r4, r1
    6e4e:	406a      	eors	r2, r5
    6e50:	4b67      	ldr	r3, [pc, #412]	; (6ff0 <Transform+0x690>)
    6e52:	9f01      	ldr	r7, [sp, #4]
    6e54:	443b      	add	r3, r7
    6e56:	449b      	add	fp, r3
    6e58:	445a      	add	r2, fp
    6e5a:	eb05 2272 	add.w	r2, r5, r2, ror #9

    MD5STEP(F4, a, b, c, d, buffer[0]  + 0xf4292244,  6);
    6e5e:	ea62 0301 	orn	r3, r2, r1
    6e62:	406b      	eors	r3, r5
    6e64:	4f63      	ldr	r7, [pc, #396]	; (6ff4 <Transform+0x694>)
    6e66:	4437      	add	r7, r6
    6e68:	443c      	add	r4, r7
    6e6a:	4423      	add	r3, r4
    6e6c:	eb02 63b3 	add.w	r3, r2, r3, ror #26
    MD5STEP(F4, d, a, b, c, buffer[7]  + 0x432aff97, 10);
    6e70:	ea63 0b05 	orn	fp, r3, r5
    6e74:	ea8b 0b02 	eor.w	fp, fp, r2
    6e78:	4c5f      	ldr	r4, [pc, #380]	; (6ff8 <Transform+0x698>)
    6e7a:	9f06      	ldr	r7, [sp, #24]
    6e7c:	443c      	add	r4, r7
    6e7e:	4421      	add	r1, r4
    6e80:	448b      	add	fp, r1
    6e82:	eb03 5bbb 	add.w	fp, r3, fp, ror #22
    MD5STEP(F4, c, d, a, b, buffer[14] + 0xab9423a7, 15);
    6e86:	ea6b 0702 	orn	r7, fp, r2
    6e8a:	405f      	eors	r7, r3
    6e8c:	495b      	ldr	r1, [pc, #364]	; (6ffc <Transform+0x69c>)
    6e8e:	4449      	add	r1, r9
    6e90:	440d      	add	r5, r1
    6e92:	442f      	add	r7, r5
    6e94:	eb0b 4777 	add.w	r7, fp, r7, ror #17
    MD5STEP(F4, b, c, d, a, buffer[5]  + 0xfc93a039, 21);
    6e98:	ea67 0403 	orn	r4, r7, r3
    6e9c:	ea84 040b 	eor.w	r4, r4, fp
    6ea0:	4957      	ldr	r1, [pc, #348]	; (7000 <Transform+0x6a0>)
    6ea2:	9d04      	ldr	r5, [sp, #16]
    6ea4:	4429      	add	r1, r5
    6ea6:	440a      	add	r2, r1
    6ea8:	4414      	add	r4, r2
    6eaa:	eb07 24f4 	add.w	r4, r7, r4, ror #11
    MD5STEP(F4, a, b, c, d, buffer[12] + 0x655b59c3,  6);
    6eae:	ea64 050b 	orn	r5, r4, fp
    6eb2:	407d      	eors	r5, r7
    6eb4:	4a53      	ldr	r2, [pc, #332]	; (7004 <Transform+0x6a4>)
    6eb6:	4442      	add	r2, r8
    6eb8:	4413      	add	r3, r2
    6eba:	441d      	add	r5, r3
    6ebc:	eb04 65b5 	add.w	r5, r4, r5, ror #26
    MD5STEP(F4, d, a, b, c, buffer[3]  + 0x8f0ccc92, 10);
    6ec0:	ea65 0807 	orn	r8, r5, r7
    6ec4:	ea88 0804 	eor.w	r8, r8, r4
    6ec8:	4b4f      	ldr	r3, [pc, #316]	; (7008 <Transform+0x6a8>)
    6eca:	9902      	ldr	r1, [sp, #8]
    6ecc:	440b      	add	r3, r1
    6ece:	449b      	add	fp, r3
    6ed0:	44d8      	add	r8, fp
    6ed2:	eb05 58b8 	add.w	r8, r5, r8, ror #22
    MD5STEP(F4, c, d, a, b, buffer[10] + 0xffeff47d, 15);
    6ed6:	ea68 0304 	orn	r3, r8, r4
    6eda:	406b      	eors	r3, r5
    6edc:	9a09      	ldr	r2, [sp, #36]	; 0x24
    6ede:	f5a2 1680 	sub.w	r6, r2, #1048576	; 0x100000
    6ee2:	f6a6 3683 	subw	r6, r6, #2947	; 0xb83
    6ee6:	443e      	add	r6, r7
    6ee8:	4433      	add	r3, r6
    6eea:	eb08 4373 	add.w	r3, r8, r3, ror #17
    MD5STEP(F4, b, c, d, a, buffer[1]  + 0x85845dd1, 21);
    6eee:	ea63 0905 	orn	r9, r3, r5
    6ef2:	ea89 0908 	eor.w	r9, r9, r8
    6ef6:	4945      	ldr	r1, [pc, #276]	; (700c <Transform+0x6ac>)
    6ef8:	9e00      	ldr	r6, [sp, #0]
    6efa:	4431      	add	r1, r6
    6efc:	440c      	add	r4, r1
    6efe:	44a1      	add	r9, r4
    6f00:	eb03 29f9 	add.w	r9, r3, r9, ror #11
    MD5STEP(F4, a, b, c, d, buffer[8]  + 0x6fa87e4f,  6);
    6f04:	ea69 0608 	orn	r6, r9, r8
    6f08:	405e      	eors	r6, r3
    6f0a:	4a41      	ldr	r2, [pc, #260]	; (7010 <Transform+0x6b0>)
    6f0c:	9907      	ldr	r1, [sp, #28]
    6f0e:	440a      	add	r2, r1
    6f10:	4415      	add	r5, r2
    6f12:	442e      	add	r6, r5
    6f14:	eb09 66b6 	add.w	r6, r9, r6, ror #26
    MD5STEP(F4, d, a, b, c, buffer[15] + 0xfe2ce6e0, 10);
    6f18:	ea66 0103 	orn	r1, r6, r3
    6f1c:	ea81 0109 	eor.w	r1, r1, r9
    6f20:	4a3c      	ldr	r2, [pc, #240]	; (7014 <Transform+0x6b4>)
    6f22:	4472      	add	r2, lr
    6f24:	4490      	add	r8, r2
    6f26:	4441      	add	r1, r8
    6f28:	eb06 51b1 	add.w	r1, r6, r1, ror #22
    MD5STEP(F4, c, d, a, b, buffer[6]  + 0xa3014314, 15);
    6f2c:	ea61 0409 	orn	r4, r1, r9
    6f30:	4074      	eors	r4, r6
    6f32:	4a39      	ldr	r2, [pc, #228]	; (7018 <Transform+0x6b8>)
    6f34:	9d05      	ldr	r5, [sp, #20]
    6f36:	442a      	add	r2, r5
    6f38:	4413      	add	r3, r2
    6f3a:	441c      	add	r4, r3
    6f3c:	eb01 4474 	add.w	r4, r1, r4, ror #17
    MD5STEP(F4, b, c, d, a, buffer[13] + 0x4e0811a1, 21);
    6f40:	ea64 0506 	orn	r5, r4, r6
    6f44:	404d      	eors	r5, r1
    6f46:	4b35      	ldr	r3, [pc, #212]	; (701c <Transform+0x6bc>)
    6f48:	4463      	add	r3, ip
    6f4a:	4499      	add	r9, r3
    6f4c:	444d      	add	r5, r9
    6f4e:	eb04 25f5 	add.w	r5, r4, r5, ror #11
    MD5STEP(F4, a, b, c, d, buffer[4]  + 0xf7537e82,  6);
    6f52:	ea65 0701 	orn	r7, r5, r1
    6f56:	4067      	eors	r7, r4
    6f58:	4a31      	ldr	r2, [pc, #196]	; (7020 <Transform+0x6c0>)
    6f5a:	9b03      	ldr	r3, [sp, #12]
    6f5c:	441a      	add	r2, r3
    6f5e:	4416      	add	r6, r2
    6f60:	4437      	add	r7, r6
    6f62:	eb05 67b7 	add.w	r7, r5, r7, ror #26
    MD5STEP(F4, d, a, b, c, buffer[11] + 0xbd3af235, 10);
    6f66:	ea67 0304 	orn	r3, r7, r4
    6f6a:	406b      	eors	r3, r5
    6f6c:	4a2d      	ldr	r2, [pc, #180]	; (7024 <Transform+0x6c4>)
    6f6e:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    6f70:	4432      	add	r2, r6
    6f72:	4411      	add	r1, r2
    6f74:	4419      	add	r1, r3
    6f76:	eb07 51b1 	add.w	r1, r7, r1, ror #22
    MD5STEP(F4, c, d, a, b, buffer[2]  + 0x2ad7d2bb, 15);
    6f7a:	ea61 0605 	orn	r6, r1, r5
    6f7e:	407e      	eors	r6, r7
    6f80:	4a29      	ldr	r2, [pc, #164]	; (7028 <Transform+0x6c8>)
    6f82:	9b01      	ldr	r3, [sp, #4]
    6f84:	441a      	add	r2, r3
    6f86:	4414      	add	r4, r2
    6f88:	4434      	add	r4, r6
    6f8a:	eb01 4474 	add.w	r4, r1, r4, ror #17
    MD5STEP(F4, b, c, d, a, buffer[9]  + 0xeb86d391, 21);

    /* Add the working vars back into digest state[]  */
    md5->digest[0] += a;
    6f8e:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    6f90:	443b      	add	r3, r7
    6f92:	64c3      	str	r3, [r0, #76]	; 0x4c
    MD5STEP(F4, b, c, d, a, buffer[9]  + 0xeb86d391, 21);
    6f94:	ea64 0707 	orn	r7, r4, r7
    6f98:	404f      	eors	r7, r1
    6f9a:	4b24      	ldr	r3, [pc, #144]	; (702c <Transform+0x6cc>)
    6f9c:	9a08      	ldr	r2, [sp, #32]
    6f9e:	4413      	add	r3, r2
    6fa0:	441d      	add	r5, r3
    6fa2:	442f      	add	r7, r5
    md5->digest[1] += b;
    6fa4:	eb0a 0504 	add.w	r5, sl, r4
    6fa8:	eb05 25f7 	add.w	r5, r5, r7, ror #11
    6fac:	6505      	str	r5, [r0, #80]	; 0x50
    md5->digest[2] += c;
    6fae:	6d43      	ldr	r3, [r0, #84]	; 0x54
    6fb0:	441c      	add	r4, r3
    6fb2:	6544      	str	r4, [r0, #84]	; 0x54
    md5->digest[3] += d;
    6fb4:	6d83      	ldr	r3, [r0, #88]	; 0x58
    6fb6:	4419      	add	r1, r3
    6fb8:	6581      	str	r1, [r0, #88]	; 0x58

    return 0;
}
    6fba:	2000      	movs	r0, #0
    6fbc:	b00d      	add	sp, #52	; 0x34
    6fbe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6fc2:	bf00      	nop
    6fc4:	a4beea44 	.word	0xa4beea44
    6fc8:	4bdecfa9 	.word	0x4bdecfa9
    6fcc:	f6bb4b60 	.word	0xf6bb4b60
    6fd0:	bebfbc70 	.word	0xbebfbc70
    6fd4:	289b7ec6 	.word	0x289b7ec6
    6fd8:	eaa127fa 	.word	0xeaa127fa
    6fdc:	d4ef3085 	.word	0xd4ef3085
    6fe0:	04881d05 	.word	0x04881d05
    6fe4:	d9d4d039 	.word	0xd9d4d039
    6fe8:	e6db99e5 	.word	0xe6db99e5
    6fec:	1fa27cf8 	.word	0x1fa27cf8
    6ff0:	c4ac5665 	.word	0xc4ac5665
    6ff4:	f4292244 	.word	0xf4292244
    6ff8:	432aff97 	.word	0x432aff97
    6ffc:	ab9423a7 	.word	0xab9423a7
    7000:	fc93a039 	.word	0xfc93a039
    7004:	655b59c3 	.word	0x655b59c3
    7008:	8f0ccc92 	.word	0x8f0ccc92
    700c:	85845dd1 	.word	0x85845dd1
    7010:	6fa87e4f 	.word	0x6fa87e4f
    7014:	fe2ce6e0 	.word	0xfe2ce6e0
    7018:	a3014314 	.word	0xa3014314
    701c:	4e0811a1 	.word	0x4e0811a1
    7020:	f7537e82 	.word	0xf7537e82
    7024:	bd3af235 	.word	0xbd3af235
    7028:	2ad7d2bb 	.word	0x2ad7d2bb
    702c:	eb86d391 	.word	0xeb86d391

Disassembly of section .text.TCPIP_STACK_Task%189:

00007030 <TCPIP_STACK_Task>:
#if defined(TCPIP_STACK_USE_EVENT_NOTIFICATION) && (TCPIP_STACK_USER_NOTIFICATION != 0)
    TCPIP_EVENT         tcpipEvent;
    TCPIP_EVENT_LIST_NODE* tNode;
#endif  // defined(TCPIP_STACK_USE_EVENT_NOTIFICATION) && (TCPIP_STACK_USER_NOTIFICATION != 0)   

    if(object != (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data)
    7030:	4bb2      	ldr	r3, [pc, #712]	; (72fc <TCPIP_STACK_Task+0x2cc>)
    7032:	4283      	cmp	r3, r0
    7034:	f040 82f9 	bne.w	762a <TCPIP_STACK_Task+0x5fa>
    {   // invalid handle/nothing to do
        return;
    }

    if(tcpip_stack_status != SYS_STATUS_BUSY && tcpip_stack_status != SYS_STATUS_READY)
    7038:	4bb1      	ldr	r3, [pc, #708]	; (7300 <TCPIP_STACK_Task+0x2d0>)
    703a:	f993 2000 	ldrsb.w	r2, [r3]
    703e:	1e53      	subs	r3, r2, #1
    7040:	b2db      	uxtb	r3, r3
    7042:	2b01      	cmp	r3, #1
    7044:	f200 82f1 	bhi.w	762a <TCPIP_STACK_Task+0x5fa>
{
    7048:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    704c:	b084      	sub	sp, #16
    {   // some error state
        return;
    }

    if(tcpipNetIf == 0)
    704e:	4bad      	ldr	r3, [pc, #692]	; (7304 <TCPIP_STACK_Task+0x2d4>)
    7050:	681b      	ldr	r3, [r3, #0]
    7052:	b163      	cbz	r3, 706e <TCPIP_STACK_Task+0x3e>
    int             aliasIx;
    TCPIP_NET_IF   *pAliasIf;
#endif  // (_TCPIP_STACK_ALIAS_INTERFACE_SUPPORT)

    // check that we've created the needed timer
    if(tcpip_stack_status == SYS_STATUS_BUSY && tcpip_stack_tickH == SYS_TMR_HANDLE_INVALID)
    7054:	2a01      	cmp	r2, #1
    7056:	d01b      	beq.n	7090 <TCPIP_STACK_Task+0x60>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Initialization SYS TMR failed: %d - Aborting! \r\n", tmrStat);
            return false;
        }
    }

    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    7058:	4baa      	ldr	r3, [pc, #680]	; (7304 <TCPIP_STACK_Task+0x2d4>)
    705a:	681c      	ldr	r4, [r3, #0]
    705c:	4ba7      	ldr	r3, [pc, #668]	; (72fc <TCPIP_STACK_Task+0x2cc>)
    705e:	681b      	ldr	r3, [r3, #0]
    7060:	2b00      	cmp	r3, #0
    7062:	f340 82d4 	ble.w	760e <TCPIP_STACK_Task+0x5de>
    7066:	2500      	movs	r5, #0
                    pNetIf->Flags.bMacInitDone = true;
                }
                else if(macStat == SYS_STATUS_READY)
                {   // get the MAC address and MAC processing flags
                    // set the default MTU; MAC driver will override if needed
                    TCPIP_MAC_PARAMETERS macParams = {{{0}}};
    7068:	462f      	mov	r7, r5
                    TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pNetIf, TCPIP_STACK_ACTION_IF_DOWN, TCPIP_MAC_POWER_DOWN);
    706a:	4ea4      	ldr	r6, [pc, #656]	; (72fc <TCPIP_STACK_Task+0x2cc>)
    706c:	e072      	b.n	7154 <TCPIP_STACK_Task+0x124>
        _TCPIP_InitCallback(tcpip_stack_init_cb);
    706e:	4ba6      	ldr	r3, [pc, #664]	; (7308 <TCPIP_STACK_Task+0x2d8>)
    int cRes = (*cback)(&pInit);
    7070:	681b      	ldr	r3, [r3, #0]
    7072:	4668      	mov	r0, sp
    7074:	4798      	blx	r3
    if(cRes > 0)
    7076:	2800      	cmp	r0, #0
    7078:	f300 82b4 	bgt.w	75e4 <TCPIP_STACK_Task+0x5b4>
    if (cRes == 0 && pInit != 0)
    707c:	b920      	cbnz	r0, 7088 <TCPIP_STACK_Task+0x58>
    707e:	9800      	ldr	r0, [sp, #0]
    7080:	b110      	cbz	r0, 7088 <TCPIP_STACK_Task+0x58>
        _TCPIP_DoInitialize(pInit);
    7082:	f002 fa71 	bl	9568 <_TCPIP_DoInitialize>
    7086:	e2ad      	b.n	75e4 <TCPIP_STACK_Task+0x5b4>
        tcpip_stack_status = SYS_STATUS_UNINITIALIZED;
    7088:	4b9d      	ldr	r3, [pc, #628]	; (7300 <TCPIP_STACK_Task+0x2d0>)
    708a:	2200      	movs	r2, #0
    708c:	701a      	strb	r2, [r3, #0]
    708e:	e2a9      	b.n	75e4 <TCPIP_STACK_Task+0x5b4>
    if(tcpip_stack_status == SYS_STATUS_BUSY && tcpip_stack_tickH == SYS_TMR_HANDLE_INVALID)
    7090:	4b9e      	ldr	r3, [pc, #632]	; (730c <TCPIP_STACK_Task+0x2dc>)
    7092:	681b      	ldr	r3, [r3, #0]
    7094:	f1b3 3fff 	cmp.w	r3, #4294967295
    7098:	d1de      	bne.n	7058 <TCPIP_STACK_Task+0x28>
    tcpip_stack_tickH = SYS_TMR_CallbackPeriodic(TCPIP_STACK_TICK_RATE, 0, _TCPIP_STACK_TickHandler);
    709a:	4a9d      	ldr	r2, [pc, #628]	; (7310 <TCPIP_STACK_Task+0x2e0>)
    709c:	2100      	movs	r1, #0
    709e:	2005      	movs	r0, #5
    70a0:	f01a f828 	bl	210f4 <SYS_TMR_CallbackPeriodic>
    70a4:	4b99      	ldr	r3, [pc, #612]	; (730c <TCPIP_STACK_Task+0x2dc>)
    70a6:	6018      	str	r0, [r3, #0]
    if(tcpip_stack_tickH != SYS_TMR_HANDLE_INVALID)
    70a8:	f1b0 3fff 	cmp.w	r0, #4294967295
    70ac:	d025      	beq.n	70fa <TCPIP_STACK_Task+0xca>
        uint32_t sysRes = SYS_TMR_TickCounterFrequencyGet();
    70ae:	f019 f845 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
        uint32_t rateMs = ((sysRes * TCPIP_STACK_TICK_RATE) + 999 )/1000;    // round up
    70b2:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    70b6:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
    70ba:	4a96      	ldr	r2, [pc, #600]	; (7314 <TCPIP_STACK_Task+0x2e4>)
    70bc:	fba2 2303 	umull	r2, r3, r2, r3
    70c0:	099b      	lsrs	r3, r3, #6
        stackTaskRate = (rateMs * 1000) / sysRes;
    70c2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    70c6:	fb02 f303 	mul.w	r3, r2, r3
    70ca:	fbb3 f3f0 	udiv	r3, r3, r0
    70ce:	4a92      	ldr	r2, [pc, #584]	; (7318 <TCPIP_STACK_Task+0x2e8>)
    70d0:	6013      	str	r3, [r2, #0]
    for(modIx = TCPIP_MODULE_LAYER1; modIx < sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL)/sizeof(*TCPIP_STACK_MODULE_SIGNAL_TBL); modIx++, pSigEntry++)
    70d2:	2502      	movs	r5, #2
    pSigEntry = TCPIP_STACK_MODULE_SIGNAL_TBL + TCPIP_MODULE_LAYER1;
    70d4:	4c91      	ldr	r4, [pc, #580]	; (731c <TCPIP_STACK_Task+0x2ec>)
    70d6:	e003      	b.n	70e0 <TCPIP_STACK_Task+0xb0>
    for(modIx = TCPIP_MODULE_LAYER1; modIx < sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL)/sizeof(*TCPIP_STACK_MODULE_SIGNAL_TBL); modIx++, pSigEntry++)
    70d8:	3501      	adds	r5, #1
    70da:	3410      	adds	r4, #16
    70dc:	2d27      	cmp	r5, #39	; 0x27
    70de:	d0bb      	beq.n	7058 <TCPIP_STACK_Task+0x28>
        if(pSigEntry->signalHandler != 0 && pSigEntry->asyncTmo != 0)
    70e0:	6823      	ldr	r3, [r4, #0]
    70e2:	2b00      	cmp	r3, #0
    70e4:	d0f8      	beq.n	70d8 <TCPIP_STACK_Task+0xa8>
    70e6:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
    70ea:	2a00      	cmp	r2, #0
    70ec:	d0f4      	beq.n	70d8 <TCPIP_STACK_Task+0xa8>
            if(!_TCPIPStackSignalHandlerSetParams((TCPIP_STACK_MODULE)modIx, pSigEntry, pSigEntry->asyncTmo))
    70ee:	4621      	mov	r1, r4
    70f0:	b2a8      	uxth	r0, r5
    70f2:	f018 ff83 	bl	1fffc <_TCPIPStackSignalHandlerSetParams>
    70f6:	2800      	cmp	r0, #0
    70f8:	d1ee      	bne.n	70d8 <TCPIP_STACK_Task+0xa8>
        SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Tick registration failed: %d\r\n", TCPIP_STACK_TICK_RATE);
    70fa:	f01a ffa9 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
    70fe:	b988      	cbnz	r0, 7124 <TCPIP_STACK_Task+0xf4>
            TCPIP_STACK_KillStack();
    7100:	f00f f9ea 	bl	164d8 <TCPIP_STACK_KillStack>
            tcpip_stack_status = SYS_STATUS_ERROR;
    7104:	4b7e      	ldr	r3, [pc, #504]	; (7300 <TCPIP_STACK_Task+0x2d0>)
    7106:	22ff      	movs	r2, #255	; 0xff
    7108:	701a      	strb	r2, [r3, #0]
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Initialization SYS TMR failed: %d - Aborting! \r\n", tmrStat);
    710a:	f01a ffa1 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
    710e:	2800      	cmp	r0, #0
    7110:	f000 8268 	beq.w	75e4 <TCPIP_STACK_Task+0x5b4>
    7114:	f01a ff96 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
    7118:	f04f 32ff 	mov.w	r2, #4294967295
    711c:	4980      	ldr	r1, [pc, #512]	; (7320 <TCPIP_STACK_Task+0x2f0>)
    711e:	f013 fcbd 	bl	1aa9c <SYS_CONSOLE_Print>
    7122:	e25f      	b.n	75e4 <TCPIP_STACK_Task+0x5b4>
        SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Tick registration failed: %d\r\n", TCPIP_STACK_TICK_RATE);
    7124:	f01a ff8e 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
    7128:	2205      	movs	r2, #5
    712a:	497e      	ldr	r1, [pc, #504]	; (7324 <TCPIP_STACK_Task+0x2f4>)
    712c:	f013 fcb6 	bl	1aa9c <SYS_CONSOLE_Print>
    7130:	e7e6      	b.n	7100 <TCPIP_STACK_Task+0xd0>
                    TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pNetIf, TCPIP_STACK_ACTION_IF_DOWN, TCPIP_MAC_POWER_DOWN);
    7132:	2303      	movs	r3, #3
    7134:	2204      	movs	r2, #4
    7136:	4621      	mov	r1, r4
    7138:	4630      	mov	r0, r6
    713a:	f014 f889 	bl	1b250 <TCPIP_STACK_BringNetDown>
                    pNetIf->Flags.bMacInitDone = true;
    713e:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    7142:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    7146:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    714a:	3501      	adds	r5, #1
    714c:	346c      	adds	r4, #108	; 0x6c
    714e:	6833      	ldr	r3, [r6, #0]
    7150:	429d      	cmp	r5, r3
    7152:	da42      	bge.n	71da <TCPIP_STACK_Task+0x1aa>
        if(pNetIf->macObjHandle != 0 && _TCPIPStackNetIsPrimary(pNetIf))
    7154:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    7156:	2800      	cmp	r0, #0
    7158:	d0f7      	beq.n	714a <TCPIP_STACK_Task+0x11a>
            (*pNetIf->pMacObj->TCPIP_MAC_Tasks)(pNetIf->macObjHandle);
    715a:	6c63      	ldr	r3, [r4, #68]	; 0x44
    715c:	699b      	ldr	r3, [r3, #24]
    715e:	4798      	blx	r3
            if(pNetIf->Flags.bMacInitialize)
    7160:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    7164:	f013 0f40 	tst.w	r3, #64	; 0x40
    7168:	d0ef      	beq.n	714a <TCPIP_STACK_Task+0x11a>
                SYS_STATUS macStat = (*pNetIf->pMacObj->TCPIP_MAC_Status)(pNetIf->macObjHandle);
    716a:	6c63      	ldr	r3, [r4, #68]	; 0x44
    716c:	695b      	ldr	r3, [r3, #20]
    716e:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    7170:	4798      	blx	r3
                if(macStat < 0)
    7172:	2800      	cmp	r0, #0
    7174:	dbdd      	blt.n	7132 <TCPIP_STACK_Task+0x102>
                else if(macStat == SYS_STATUS_READY)
    7176:	2802      	cmp	r0, #2
    7178:	d1e7      	bne.n	714a <TCPIP_STACK_Task+0x11a>
                    TCPIP_MAC_PARAMETERS macParams = {{{0}}};
    717a:	9700      	str	r7, [sp, #0]
    717c:	9701      	str	r7, [sp, #4]
    717e:	9702      	str	r7, [sp, #8]
    7180:	9703      	str	r7, [sp, #12]
                    macParams.linkMtu = TCPIP_MAC_LINK_MTU_DEFAULT; 
    7182:	f240 53dc 	movw	r3, #1500	; 0x5dc
    7186:	f8ad 300a 	strh.w	r3, [sp, #10]
                    (*pNetIf->pMacObj->TCPIP_MAC_ParametersGet)(pNetIf->hIfMac, &macParams);
    718a:	6c63      	ldr	r3, [r4, #68]	; 0x44
    718c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    718e:	4669      	mov	r1, sp
    7190:	6d20      	ldr	r0, [r4, #80]	; 0x50
    7192:	4798      	blx	r3
                    memcpy(pNetIf->netMACAddr.v, macParams.ifPhyAddress.v, sizeof(pNetIf->netMACAddr));
    7194:	9800      	ldr	r0, [sp, #0]
    7196:	63e0      	str	r0, [r4, #60]	; 0x3c
    7198:	f8bd 3004 	ldrh.w	r3, [sp, #4]
    719c:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
                    pNetIf->Flags.bMacProcessOnEvent = macParams.processFlags != TCPIP_MAC_PROCESS_FLAG_NONE;
    71a0:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    71a4:	3300      	adds	r3, #0
    71a6:	bf18      	it	ne
    71a8:	2301      	movne	r3, #1
    71aa:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
    71ae:	f363 1245 	bfi	r2, r3, #5, #1
    71b2:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
                    pNetIf->linkMtu = macParams.linkMtu;
    71b6:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    71ba:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
                    // enable this interface
                    pNetIf->Flags.bInterfaceEnabled = true;
    71be:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
    71c2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    71c6:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
                    pNetIf->Flags.bMacInitialize = false;
    71ca:	b2d3      	uxtb	r3, r2
                    pNetIf->Flags.bMacInitDone = true;
    71cc:	f003 03bf 	and.w	r3, r3, #191	; 0xbf
    71d0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    71d4:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    71d8:	e7b7      	b.n	714a <TCPIP_STACK_Task+0x11a>
            }
        }
    }

    // check we're getting out of Initialize procedure
    if(tcpip_stack_status == SYS_STATUS_BUSY)
    71da:	4a49      	ldr	r2, [pc, #292]	; (7300 <TCPIP_STACK_Task+0x2d0>)
    71dc:	f992 2000 	ldrsb.w	r2, [r2]
    71e0:	2a01      	cmp	r2, #1
    71e2:	d027      	beq.n	7234 <TCPIP_STACK_Task+0x204>
    _TCPIP_SelectDefaultNet(0);
    71e4:	2000      	movs	r0, #0
    71e6:	f014 fa83 	bl	1b6f0 <_TCPIP_SelectDefaultNet>

// returns true if the stack needs processing time because of events
static bool TCPIP_STACK_CheckEventsPending(void)
{
#if defined(TCPIP_STACK_USE_EVENT_NOTIFICATION)
    return (newTcpipTickAvlbl != 0 || totTcpipEventsCnt != 0);
    71ea:	4b4f      	ldr	r3, [pc, #316]	; (7328 <TCPIP_STACK_Task+0x2f8>)
    71ec:	681b      	ldr	r3, [r3, #0]
    71ee:	b933      	cbnz	r3, 71fe <TCPIP_STACK_Task+0x1ce>
    71f0:	4b4e      	ldr	r3, [pc, #312]	; (732c <TCPIP_STACK_Task+0x2fc>)
    71f2:	681a      	ldr	r2, [r3, #0]
    if(eventPending == 0 && stackAsyncSignalCount == 0)
    71f4:	4b4e      	ldr	r3, [pc, #312]	; (7330 <TCPIP_STACK_Task+0x300>)
    71f6:	681b      	ldr	r3, [r3, #0]
    71f8:	4313      	orrs	r3, r2
    71fa:	f000 81f3 	beq.w	75e4 <TCPIP_STACK_Task+0x5b4>
    if(newTcpipTickAvlbl != 0)
    71fe:	4b4a      	ldr	r3, [pc, #296]	; (7328 <TCPIP_STACK_Task+0x2f8>)
    7200:	681b      	ldr	r3, [r3, #0]
    7202:	2b00      	cmp	r3, #0
    7204:	d16c      	bne.n	72e0 <TCPIP_STACK_Task+0x2b0>
        wasTickEvent = false;
    7206:	2600      	movs	r6, #0
    if( totTcpipEventsCnt)
    7208:	4b48      	ldr	r3, [pc, #288]	; (732c <TCPIP_STACK_Task+0x2fc>)
    720a:	681b      	ldr	r3, [r3, #0]
    720c:	2b00      	cmp	r3, #0
    720e:	f000 8166 	beq.w	74de <TCPIP_STACK_Task+0x4ae>
        totTcpipEventsCnt = 0;
    7212:	4b46      	ldr	r3, [pc, #280]	; (732c <TCPIP_STACK_Task+0x2fc>)
    7214:	2200      	movs	r2, #0
    7216:	601a      	str	r2, [r3, #0]
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    7218:	4b3a      	ldr	r3, [pc, #232]	; (7304 <TCPIP_STACK_Task+0x2d4>)
    721a:	681c      	ldr	r4, [r3, #0]
    721c:	4b37      	ldr	r3, [pc, #220]	; (72fc <TCPIP_STACK_Task+0x2cc>)
    721e:	681b      	ldr	r3, [r3, #0]
    7220:	4293      	cmp	r3, r2
    7222:	f340 80fc 	ble.w	741e <TCPIP_STACK_Task+0x3ee>
    7226:	4690      	mov	r8, r2
    return OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
    7228:	2701      	movs	r7, #1
                newTcpipStackEventCnt++;
    722a:	f8df a10c 	ldr.w	sl, [pc, #268]	; 7338 <TCPIP_STACK_Task+0x308>
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    722e:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 72fc <TCPIP_STACK_Task+0x2cc>
    7232:	e0c7      	b.n	73c4 <TCPIP_STACK_Task+0x394>
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    7234:	4a33      	ldr	r2, [pc, #204]	; (7304 <TCPIP_STACK_Task+0x2d4>)
    7236:	6816      	ldr	r6, [r2, #0]
    7238:	2b00      	cmp	r3, #0
    723a:	f340 81ee 	ble.w	761a <TCPIP_STACK_Task+0x5ea>
    723e:	4631      	mov	r1, r6
        uint32_t    ifUpMask = 0;   // masks of interfaces that are up;
    7240:	2500      	movs	r5, #0
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    7242:	462a      	mov	r2, r5
                ifUpMask |= (1 << netIx);
    7244:	2701      	movs	r7, #1
    7246:	e006      	b.n	7256 <TCPIP_STACK_Task+0x226>
    7248:	fa07 f002 	lsl.w	r0, r7, r2
    724c:	4305      	orrs	r5, r0
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    724e:	3201      	adds	r2, #1
    7250:	316c      	adds	r1, #108	; 0x6c
    7252:	4293      	cmp	r3, r2
    7254:	d012      	beq.n	727c <TCPIP_STACK_Task+0x24c>
            if(pPriIf->Flags.powerMode == TCPIP_MAC_POWER_FULL)
    7256:	f891 0043 	ldrb.w	r0, [r1, #67]	; 0x43
    725a:	f000 040c 	and.w	r4, r0, #12
    725e:	2c04      	cmp	r4, #4
    7260:	d1f2      	bne.n	7248 <TCPIP_STACK_Task+0x218>
                if(pPriIf->Flags.bMacInitDone == 0)
    7262:	f010 0f80 	tst.w	r0, #128	; 0x80
    7266:	f000 81bd 	beq.w	75e4 <TCPIP_STACK_Task+0x5b4>
                else if(pPriIf->Flags.bInterfaceEnabled != 0)
    726a:	f891 0042 	ldrb.w	r0, [r1, #66]	; 0x42
    726e:	f010 0f40 	tst.w	r0, #64	; 0x40
    7272:	d0ec      	beq.n	724e <TCPIP_STACK_Task+0x21e>
                    ifUpMask |= (1 << netIx);
    7274:	fa07 f002 	lsl.w	r0, r7, r2
    7278:	4305      	orrs	r5, r0
    727a:	e7e8      	b.n	724e <TCPIP_STACK_Task+0x21e>
        if(ifUpMask == ((1 << netIx) - 1))
    727c:	2201      	movs	r2, #1
    727e:	fa02 f303 	lsl.w	r3, r2, r3
    7282:	3b01      	subs	r3, #1
    7284:	42ab      	cmp	r3, r5
    7286:	f000 81c8 	beq.w	761a <TCPIP_STACK_Task+0x5ea>
            for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    728a:	4b1c      	ldr	r3, [pc, #112]	; (72fc <TCPIP_STACK_Task+0x2cc>)
    728c:	681b      	ldr	r3, [r3, #0]
    728e:	2b00      	cmp	r3, #0
    7290:	dd17      	ble.n	72c2 <TCPIP_STACK_Task+0x292>
    7292:	2400      	movs	r4, #0
                if(pNetIf->Flags.bInterfaceEnabled || pNetIf->Flags.bMacInitialize)
    7294:	f244 0840 	movw	r8, #16448	; 0x4040
                    TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pNetIf, TCPIP_STACK_ACTION_IF_DOWN, TCPIP_MAC_POWER_DOWN);
    7298:	4f18      	ldr	r7, [pc, #96]	; (72fc <TCPIP_STACK_Task+0x2cc>)
    729a:	f04f 0903 	mov.w	r9, #3
    729e:	e004      	b.n	72aa <TCPIP_STACK_Task+0x27a>
            for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    72a0:	3401      	adds	r4, #1
    72a2:	366c      	adds	r6, #108	; 0x6c
    72a4:	683b      	ldr	r3, [r7, #0]
    72a6:	429c      	cmp	r4, r3
    72a8:	da0b      	bge.n	72c2 <TCPIP_STACK_Task+0x292>
                if(pNetIf->Flags.bInterfaceEnabled || pNetIf->Flags.bMacInitialize)
    72aa:	f8b6 3042 	ldrh.w	r3, [r6, #66]	; 0x42
    72ae:	ea18 0f03 	tst.w	r8, r3
    72b2:	d0f5      	beq.n	72a0 <TCPIP_STACK_Task+0x270>
                    TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pNetIf, TCPIP_STACK_ACTION_IF_DOWN, TCPIP_MAC_POWER_DOWN);
    72b4:	464b      	mov	r3, r9
    72b6:	2204      	movs	r2, #4
    72b8:	4631      	mov	r1, r6
    72ba:	4638      	mov	r0, r7
    72bc:	f013 ffc8 	bl	1b250 <TCPIP_STACK_BringNetDown>
    72c0:	e7ee      	b.n	72a0 <TCPIP_STACK_Task+0x270>
            tcpip_stack_status = SYS_STATUS_ERROR;
    72c2:	4b0f      	ldr	r3, [pc, #60]	; (7300 <TCPIP_STACK_Task+0x2d0>)
    72c4:	22ff      	movs	r2, #255	; 0xff
    72c6:	701a      	strb	r2, [r3, #0]
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Initialization failed: 0x%x - Aborting! \r\n", ifUpMask);
    72c8:	f01a fec2 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
    72cc:	2800      	cmp	r0, #0
    72ce:	f000 8189 	beq.w	75e4 <TCPIP_STACK_Task+0x5b4>
    72d2:	f01a feb7 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
    72d6:	462a      	mov	r2, r5
    72d8:	4916      	ldr	r1, [pc, #88]	; (7334 <TCPIP_STACK_Task+0x304>)
    72da:	f013 fbdf 	bl	1aa9c <SYS_CONSOLE_Print>
    72de:	e181      	b.n	75e4 <TCPIP_STACK_Task+0x5b4>
    newTcpipTickAvlbl = 0;
    72e0:	4b11      	ldr	r3, [pc, #68]	; (7328 <TCPIP_STACK_Task+0x2f8>)
    72e2:	2200      	movs	r2, #0
    72e4:	601a      	str	r2, [r3, #0]
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    72e6:	4b07      	ldr	r3, [pc, #28]	; (7304 <TCPIP_STACK_Task+0x2d4>)
    72e8:	681c      	ldr	r4, [r3, #0]
    72ea:	4b04      	ldr	r3, [pc, #16]	; (72fc <TCPIP_STACK_Task+0x2cc>)
    72ec:	681b      	ldr	r3, [r3, #0]
    72ee:	4293      	cmp	r3, r2
    72f0:	f340 8182 	ble.w	75f8 <TCPIP_STACK_Task+0x5c8>
    72f4:	4615      	mov	r5, r2
    72f6:	4e01      	ldr	r6, [pc, #4]	; (72fc <TCPIP_STACK_Task+0x2cc>)
    72f8:	e025      	b.n	7346 <TCPIP_STACK_Task+0x316>
    72fa:	bf00      	nop
    72fc:	2000e0f0 	.word	0x2000e0f0
    7300:	2000e50d 	.word	0x2000e50d
    7304:	2000e440 	.word	0x2000e440
    7308:	2000e444 	.word	0x2000e444
    730c:	2000e44c 	.word	0x2000e44c
    7310:	0001ff0d 	.word	0x0001ff0d
    7314:	10624dd3 	.word	0x10624dd3
    7318:	2000e438 	.word	0x2000e438
    731c:	2000d1f4 	.word	0x2000d1f4
    7320:	000094a0 	.word	0x000094a0
    7324:	00009470 	.word	0x00009470
    7328:	2000e430 	.word	0x2000e430
    732c:	2000e448 	.word	0x2000e448
    7330:	2000e434 	.word	0x2000e434
    7334:	00009510 	.word	0x00009510
    7338:	2000e42c 	.word	0x2000e42c
    733c:	3501      	adds	r5, #1
    733e:	346c      	adds	r4, #108	; 0x6c
    7340:	6833      	ldr	r3, [r6, #0]
    7342:	429d      	cmp	r5, r3
    7344:	da19      	bge.n	737a <TCPIP_STACK_Task+0x34a>
        if(pNetIf->Flags.bInterfaceEnabled)
    7346:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
    734a:	f013 0f40 	tst.w	r3, #64	; 0x40
    734e:	d0f5      	beq.n	733c <TCPIP_STACK_Task+0x30c>
            linkCurr = (*pNetIf->pMacObj->TCPIP_MAC_LinkCheck)(pNetIf->hIfMac);     // check link status
    7350:	6c63      	ldr	r3, [r4, #68]	; 0x44
    7352:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    7354:	6d20      	ldr	r0, [r4, #80]	; 0x50
    7356:	4798      	blx	r3
            linkPrev = pNetIf->exFlags.linkPrev != 0;
    7358:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
            if(linkPrev != linkCurr)
    735c:	f003 0301 	and.w	r3, r3, #1
    7360:	4298      	cmp	r0, r3
    7362:	d0eb      	beq.n	733c <TCPIP_STACK_Task+0x30c>
                pNetIf->exFlags.connEvent = 1;
    7364:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
                pNetIf->exFlags.connEventType = linkCurr ? 1 : 0 ;
    7368:	f043 0302 	orr.w	r3, r3, #2
    736c:	f360 0382 	bfi	r3, r0, #2, #1
                pNetIf->exFlags.linkPrev = linkCurr;
    7370:	f360 0300 	bfi	r3, r0, #0, #1
    7374:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
    7378:	e7e0      	b.n	733c <TCPIP_STACK_Task+0x30c>
        wasTickEvent = true;
    737a:	2601      	movs	r6, #1
    737c:	e744      	b.n	7208 <TCPIP_STACK_Task+0x1d8>
    737e:	2601      	movs	r6, #1
    7380:	e747      	b.n	7212 <TCPIP_STACK_Task+0x1e2>
    while((pRxPkt = (*pNetIf->pMacObj->TCPIP_MAC_PacketRx)(pNetIf->hIfMac, 0, 0)) != 0)
    7382:	2500      	movs	r5, #0
    7384:	e004      	b.n	7390 <TCPIP_STACK_Task+0x360>
    pRxPkt->pktIf = pNetIf;
    7386:	628c      	str	r4, [r1, #40]	; 0x28
    _TCPIPStackModuleRxInsert(TCPIP_MODULE_MANAGER, pRxPkt, 0);
    7388:	462a      	mov	r2, r5
    738a:	4638      	mov	r0, r7
    738c:	f016 f962 	bl	1d654 <_TCPIPStackModuleRxInsert>
    while((pRxPkt = (*pNetIf->pMacObj->TCPIP_MAC_PacketRx)(pNetIf->hIfMac, 0, 0)) != 0)
    7390:	6c63      	ldr	r3, [r4, #68]	; 0x44
    7392:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    7394:	462a      	mov	r2, r5
    7396:	4629      	mov	r1, r5
    7398:	6d20      	ldr	r0, [r4, #80]	; 0x50
    739a:	4798      	blx	r3
    739c:	4601      	mov	r1, r0
    739e:	2800      	cmp	r0, #0
    73a0:	d1f1      	bne.n	7386 <TCPIP_STACK_Task+0x356>
                newTcpipStackEventCnt++;
    73a2:	f8da 3000 	ldr.w	r3, [sl]
    73a6:	3301      	adds	r3, #1
    73a8:	f8ca 3000 	str.w	r3, [sl]
    73ac:	e031      	b.n	7412 <TCPIP_STACK_Task+0x3e2>
                (*pNetIf->pMacObj->TCPIP_MAC_Process)(pNetIf->hIfMac);
    73ae:	6c63      	ldr	r3, [r4, #68]	; 0x44
    73b0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    73b2:	6d20      	ldr	r0, [r4, #80]	; 0x50
    73b4:	4798      	blx	r3
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    73b6:	f108 0801 	add.w	r8, r8, #1
    73ba:	346c      	adds	r4, #108	; 0x6c
    73bc:	f8d9 3000 	ldr.w	r3, [r9]
    73c0:	4543      	cmp	r3, r8
    73c2:	dd2c      	ble.n	741e <TCPIP_STACK_Task+0x3ee>
            if (!pNetIf->Flags.bInterfaceEnabled || !_TCPIPStackNetIsPrimary(pNetIf))
    73c4:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
    73c8:	f013 0f40 	tst.w	r3, #64	; 0x40
    73cc:	d0f3      	beq.n	73b6 <TCPIP_STACK_Task+0x386>
            activeEvents =  pNetIf->activeEvents;
    73ce:	f8b4 505a 	ldrh.w	r5, [r4, #90]	; 0x5a
            activeEvents |= (*pNetIf->pMacObj->TCPIP_MAC_EventPendingGet)(pNetIf->hIfMac);
    73d2:	6c63      	ldr	r3, [r4, #68]	; 0x44
    73d4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    73d6:	6d20      	ldr	r0, [r4, #80]	; 0x50
    73d8:	4798      	blx	r3
    73da:	4305      	orrs	r5, r0
    73dc:	b2ad      	uxth	r5, r5
    return OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
    73de:	4638      	mov	r0, r7
    73e0:	f01a f8ec 	bl	215bc <OSAL_CRIT_Enter>
    pNetIf->activeEvents &= ~event;
    73e4:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
    73e8:	ea23 0305 	bic.w	r3, r3, r5
    73ec:	f8a4 305a 	strh.w	r3, [r4, #90]	; 0x5a
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, suspLevel);
    73f0:	4601      	mov	r1, r0
    73f2:	4638      	mov	r0, r7
    73f4:	f01a fa11 	bl	2181a <OSAL_CRIT_Leave>
            pNetIf->currEvents |= activeEvents;     // store all the processed events
    73f8:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
    73fc:	432b      	orrs	r3, r5
    73fe:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
            (*pNetIf->pMacObj->TCPIP_MAC_EventAcknowledge)(pNetIf->hIfMac, activeEvents);
    7402:	6c63      	ldr	r3, [r4, #68]	; 0x44
    7404:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    7406:	4629      	mov	r1, r5
    7408:	6d20      	ldr	r0, [r4, #80]	; 0x50
    740a:	4798      	blx	r3
            if((activeEvents & (TCPIP_STACK_MAC_ACTIVE_RX_EVENTS)) != 0)
    740c:	f015 0f16 	tst.w	r5, #22
    7410:	d1b7      	bne.n	7382 <TCPIP_STACK_Task+0x352>
            if(pNetIf->Flags.bMacProcessOnEvent != 0)
    7412:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    7416:	f013 0f20 	tst.w	r3, #32
    741a:	d0cc      	beq.n	73b6 <TCPIP_STACK_Task+0x386>
    741c:	e7c7      	b.n	73ae <TCPIP_STACK_Task+0x37e>
    uint32_t                    procFrameMask = 0;
    741e:	2500      	movs	r5, #0
    while((pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(pPktQueue)))
    7420:	4c82      	ldr	r4, [pc, #520]	; (762c <TCPIP_STACK_Task+0x5fc>)
        pFrameEntry = TCPIP_FRAME_PROCESS_TBL;
    7422:	4f83      	ldr	r7, [pc, #524]	; (7630 <TCPIP_STACK_Task+0x600>)
        for(frameIx = 0; frameIx < sizeof(TCPIP_FRAME_PROCESS_TBL) / sizeof(*TCPIP_FRAME_PROCESS_TBL); frameIx++, pFrameEntry++)
    7424:	f107 0806 	add.w	r8, r7, #6
    while((pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(pPktQueue)))
    7428:	4620      	mov	r0, r4
    742a:	f019 fd75 	bl	20f18 <TCPIP_Helper_SingleListHeadRemove>
    742e:	4684      	mov	ip, r0
    7430:	2800      	cmp	r0, #0
    7432:	d048      	beq.n	74c6 <TCPIP_STACK_Task+0x496>
        frameType = TCPIP_Helper_ntohs(pMacHdr->Type);
    7434:	f8dc 3014 	ldr.w	r3, [ip, #20]
    7438:	899a      	ldrh	r2, [r3, #12]
       return (((hShort) << 8) | ((hShort) >> 8));
    743a:	0a13      	lsrs	r3, r2, #8
    743c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    7440:	b29b      	uxth	r3, r3
            if(pFrameEntry->frameType == frameType)
    7442:	f640 0206 	movw	r2, #2054	; 0x806
    7446:	4293      	cmp	r3, r2
    7448:	d016      	beq.n	7478 <TCPIP_STACK_Task+0x448>
    744a:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
    744e:	d00a      	beq.n	7466 <TCPIP_STACK_Task+0x436>
    7450:	f64f 72ff 	movw	r2, #65535	; 0xffff
    7454:	4293      	cmp	r3, r2
    7456:	d00a      	beq.n	746e <TCPIP_STACK_Task+0x43e>
            TCPIP_PKT_PacketAcknowledge(pRxPkt, TCPIP_MAC_PKT_ACK_TYPE_ERR); 
    7458:	2201      	movs	r2, #1
    745a:	f06f 010c 	mvn.w	r1, #12
    745e:	4660      	mov	r0, ip
    7460:	f016 fbc8 	bl	1dbf4 <_TCPIP_PKT_PacketAcknowledge>
    7464:	e7e0      	b.n	7428 <TCPIP_STACK_Task+0x3f8>
        for(frameIx = 0; frameIx < sizeof(TCPIP_FRAME_PROCESS_TBL) / sizeof(*TCPIP_FRAME_PROCESS_TBL); frameIx++, pFrameEntry++)
    7466:	46c1      	mov	r9, r8
    7468:	f04f 0a01 	mov.w	sl, #1
    746c:	e007      	b.n	747e <TCPIP_STACK_Task+0x44e>
    746e:	f107 090c 	add.w	r9, r7, #12
    7472:	f04f 0a02 	mov.w	sl, #2
    7476:	e002      	b.n	747e <TCPIP_STACK_Task+0x44e>
    7478:	f04f 0a00 	mov.w	sl, #0
        pFrameEntry = TCPIP_FRAME_PROCESS_TBL;
    747c:	46b9      	mov	r9, r7
                pRxPkt->pktFlags &= ~TCPIP_MAC_PKT_FLAG_TYPE_MASK;
    747e:	f8bc 3022 	ldrh.w	r3, [ip, #34]	; 0x22
    7482:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
    7486:	b29b      	uxth	r3, r3
    7488:	f8ac 3022 	strh.w	r3, [ip, #34]	; 0x22
                pRxPkt->pktFlags |= pFrameEntry->pktTypeFlags;
    748c:	f8b9 2002 	ldrh.w	r2, [r9, #2]
    7490:	4313      	orrs	r3, r2
    7492:	f8ac 3022 	strh.w	r3, [ip, #34]	; 0x22
                _TCPIPStackModuleRxInsert(pFrameEntry->moduleId, pRxPkt, 0);
    7496:	2200      	movs	r2, #0
    7498:	4661      	mov	r1, ip
    749a:	f8b9 0004 	ldrh.w	r0, [r9, #4]
    749e:	f016 f8d9 	bl	1d654 <_TCPIPStackModuleRxInsert>
                    if((procFrameMask & (1 << frameIx)) == 0)
    74a2:	2301      	movs	r3, #1
    74a4:	fa03 fa0a 	lsl.w	sl, r3, sl
    74a8:	ea1a 0f05 	tst.w	sl, r5
    74ac:	d1bc      	bne.n	7428 <TCPIP_STACK_Task+0x3f8>
                        procFrameMask |= 1 << frameIx;
    74ae:	ea45 050a 	orr.w	r5, r5, sl
    return TCPIP_STACK_MODULE_SIGNAL_TBL + modId;
    74b2:	f8b9 0004 	ldrh.w	r0, [r9, #4]
    _TCPIPSignalEntrySetNotify(_TCPIPModuleToSignalEntry(modId), signals, 0);
    74b6:	2200      	movs	r2, #0
    74b8:	4619      	mov	r1, r3
    74ba:	4b5e      	ldr	r3, [pc, #376]	; (7634 <TCPIP_STACK_Task+0x604>)
    74bc:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    74c0:	f018 fd38 	bl	1ff34 <_TCPIPSignalEntrySetNotify>
    74c4:	e7b0      	b.n	7428 <TCPIP_STACK_Task+0x3f8>
    tmoMask = clrMask & TCPIP_MODULE_SIGNAL_TMO;
    rxMask = clrMask & TCPIP_MODULE_SIGNAL_RX_PENDING;


    // protect against ISRs (MAC + TMR) and other threads too!
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
    74c6:	2001      	movs	r0, #1
    74c8:	f01a f878 	bl	215bc <OSAL_CRIT_Enter>
    {
        pTmoEntry->signalVal &= (uint16_t)(~TCPIP_MODULE_SIGNAL_TMO);
    }
    if(rxMask)
    {
        pMgrEntry->signalVal &= (uint16_t)(~TCPIP_MODULE_SIGNAL_RX_PENDING);
    74cc:	4a59      	ldr	r2, [pc, #356]	; (7634 <TCPIP_STACK_Task+0x604>)
    74ce:	8b13      	ldrh	r3, [r2, #24]
    74d0:	f023 0301 	bic.w	r3, r3, #1
    74d4:	8313      	strh	r3, [r2, #24]
    }
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, critSect);
    74d6:	4601      	mov	r1, r0
    74d8:	2001      	movs	r0, #1
    74da:	f01a f99e 	bl	2181a <OSAL_CRIT_Leave>
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    74de:	4b56      	ldr	r3, [pc, #344]	; (7638 <TCPIP_STACK_Task+0x608>)
    74e0:	681c      	ldr	r4, [r3, #0]
    74e2:	4b56      	ldr	r3, [pc, #344]	; (763c <TCPIP_STACK_Task+0x60c>)
    74e4:	681b      	ldr	r3, [r3, #0]
    74e6:	2b00      	cmp	r3, #0
    74e8:	dd35      	ble.n	7556 <TCPIP_STACK_Task+0x526>
    74ea:	2500      	movs	r5, #0
        if((activeEvents & TCPIP_MAC_EV_RXTX_ERRORS) != 0)
    74ec:	f240 6886 	movw	r8, #1670	; 0x686
    newTcpipErrorEventCnt++;
    74f0:	f8df 9168 	ldr.w	r9, [pc, #360]	; 765c <TCPIP_STACK_Task+0x62c>
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    74f4:	4f51      	ldr	r7, [pc, #324]	; (763c <TCPIP_STACK_Task+0x60c>)
    74f6:	e00c      	b.n	7512 <TCPIP_STACK_Task+0x4e2>
        if(pNetIf->exFlags.connEvent != 0)
    74f8:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
    74fc:	f012 0f02 	tst.w	r2, #2
    7500:	d117      	bne.n	7532 <TCPIP_STACK_Task+0x502>
        pNetIf->currEvents = 0;
    7502:	2300      	movs	r3, #0
    7504:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    7508:	3501      	adds	r5, #1
    750a:	346c      	adds	r4, #108	; 0x6c
    750c:	683b      	ldr	r3, [r7, #0]
    750e:	42ab      	cmp	r3, r5
    7510:	dd21      	ble.n	7556 <TCPIP_STACK_Task+0x526>
        if (!pNetIf->Flags.bInterfaceEnabled || !_TCPIPStackNetIsPrimary(pNetIf))
    7512:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
    7516:	f013 0f40 	tst.w	r3, #64	; 0x40
    751a:	d0f5      	beq.n	7508 <TCPIP_STACK_Task+0x4d8>
        activeEvents = pNetIf->currEvents;
    751c:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
        if((activeEvents & TCPIP_MAC_EV_RXTX_ERRORS) != 0)
    7520:	ea13 0f08 	tst.w	r3, r8
    7524:	d0e8      	beq.n	74f8 <TCPIP_STACK_Task+0x4c8>
    newTcpipErrorEventCnt++;
    7526:	f8d9 2000 	ldr.w	r2, [r9]
    752a:	3201      	adds	r2, #1
    752c:	f8c9 2000 	str.w	r2, [r9]
    7530:	e7e2      	b.n	74f8 <TCPIP_STACK_Task+0x4c8>
            activeEvents |= pNetIf->exFlags.connEventType ? TCPIP_MAC_EV_CONN_ESTABLISHED : TCPIP_MAC_EV_CONN_LOST;
    7532:	f012 0f04 	tst.w	r2, #4
    7536:	bf14      	ite	ne
    7538:	f44f 6100 	movne.w	r1, #2048	; 0x800
    753c:	f44f 5180 	moveq.w	r1, #4096	; 0x1000
            pNetIf->exFlags.connEvent = 0;
    7540:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
    7544:	f36f 0241 	bfc	r2, #1, #1
    7548:	f884 2060 	strb.w	r2, [r4, #96]	; 0x60
                    (*TCPIP_STACK_CONN_EVENT_TBL[modIx])(pAliasIf, activeEvents);
    754c:	4319      	orrs	r1, r3
    754e:	4620      	mov	r0, r4
    7550:	f012 fdd8 	bl	1a104 <TCPIP_DHCP_ConnectionHandler>
    7554:	e7d5      	b.n	7502 <TCPIP_STACK_Task+0x4d2>
    if(wasTickEvent)
    7556:	2e00      	cmp	r6, #0
    7558:	d153      	bne.n	7602 <TCPIP_STACK_Task+0x5d2>
    755a:	4b36      	ldr	r3, [pc, #216]	; (7634 <TCPIP_STACK_Task+0x604>)
    755c:	f103 0430 	add.w	r4, r3, #48	; 0x30
    7560:	f503 7820 	add.w	r8, r3, #640	; 0x280
        critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    7564:	2600      	movs	r6, #0
    7566:	e029      	b.n	75bc <TCPIP_STACK_Task+0x58c>
            continue;
        }

        if((pSigEntry->currTmo -= stackTaskRate) <= 0)
        {   // timeout: send a signal to this module
            pSigEntry->currTmo += pSigEntry->asyncTmo;
    7568:	4413      	add	r3, r2
    756a:	81a3      	strh	r3, [r4, #12]
            _TCPIPSignalEntrySetNotify(pSigEntry, TCPIP_MODULE_SIGNAL_TMO, 0); 
    756c:	463a      	mov	r2, r7
    756e:	2102      	movs	r1, #2
    7570:	4620      	mov	r0, r4
    7572:	f018 fcdf 	bl	1ff34 <_TCPIPSignalEntrySetNotify>
    for(ix = TCPIP_MODULE_LAYER1; ix < sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL)/sizeof(*TCPIP_STACK_MODULE_SIGNAL_TBL); ix++, pSigEntry++)
    7576:	3410      	adds	r4, #16
    7578:	42ac      	cmp	r4, r5
    757a:	d00f      	beq.n	759c <TCPIP_STACK_Task+0x56c>
        if(pSigEntry->signalHandler == 0 || pSigEntry->asyncTmo == 0)
    757c:	6823      	ldr	r3, [r4, #0]
    757e:	2b00      	cmp	r3, #0
    7580:	d0f9      	beq.n	7576 <TCPIP_STACK_Task+0x546>
    7582:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
    7586:	2a00      	cmp	r2, #0
    7588:	d0f5      	beq.n	7576 <TCPIP_STACK_Task+0x546>
        if((pSigEntry->currTmo -= stackTaskRate) <= 0)
    758a:	6831      	ldr	r1, [r6, #0]
    758c:	89a3      	ldrh	r3, [r4, #12]
    758e:	1a5b      	subs	r3, r3, r1
    7590:	b29b      	uxth	r3, r3
    7592:	b219      	sxth	r1, r3
    7594:	2900      	cmp	r1, #0
    7596:	dde7      	ble.n	7568 <TCPIP_STACK_Task+0x538>
    7598:	81a1      	strh	r1, [r4, #12]
    759a:	e7ec      	b.n	7576 <TCPIP_STACK_Task+0x546>
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
    759c:	2001      	movs	r0, #1
    759e:	f01a f80d 	bl	215bc <OSAL_CRIT_Enter>
        pTmoEntry->signalVal &= (uint16_t)(~TCPIP_MODULE_SIGNAL_TMO);
    75a2:	4a24      	ldr	r2, [pc, #144]	; (7634 <TCPIP_STACK_Task+0x604>)
    75a4:	8913      	ldrh	r3, [r2, #8]
    75a6:	f023 0302 	bic.w	r3, r3, #2
    75aa:	8113      	strh	r3, [r2, #8]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, critSect);
    75ac:	4601      	mov	r1, r0
    75ae:	2001      	movs	r0, #1
    75b0:	f01a f933 	bl	2181a <OSAL_CRIT_Leave>
    return mgrSignal;
    75b4:	e7d1      	b.n	755a <TCPIP_STACK_Task+0x52a>
    75b6:	3410      	adds	r4, #16
    for(modIx = TCPIP_MODULE_LAYER1; modIx < sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL)/sizeof(*TCPIP_STACK_MODULE_SIGNAL_TBL); modIx++, pSigEntry++)
    75b8:	4544      	cmp	r4, r8
    75ba:	d010      	beq.n	75de <TCPIP_STACK_Task+0x5ae>
        critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    75bc:	4630      	mov	r0, r6
    75be:	f019 fffd 	bl	215bc <OSAL_CRIT_Enter>
        signalHandler = pSigEntry->signalHandler;
    75c2:	f854 5c10 	ldr.w	r5, [r4, #-16]
        signalVal = pSigEntry->signalVal;
    75c6:	f834 7c08 	ldrh.w	r7, [r4, #-8]
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
    75ca:	4601      	mov	r1, r0
    75cc:	4630      	mov	r0, r6
    75ce:	f01a f924 	bl	2181a <OSAL_CRIT_Leave>
        if(signalHandler == 0 || signalVal == 0)
    75d2:	2d00      	cmp	r5, #0
    75d4:	d0ef      	beq.n	75b6 <TCPIP_STACK_Task+0x586>
    75d6:	2f00      	cmp	r7, #0
    75d8:	d0ed      	beq.n	75b6 <TCPIP_STACK_Task+0x586>
        (*signalHandler)();
    75da:	47a8      	blx	r5
    75dc:	e7eb      	b.n	75b6 <TCPIP_STACK_Task+0x586>
    if(stackAsyncSignalCount != 0)
    75de:	4b18      	ldr	r3, [pc, #96]	; (7640 <TCPIP_STACK_Task+0x610>)
    75e0:	681b      	ldr	r3, [r3, #0]
    75e2:	b913      	cbnz	r3, 75ea <TCPIP_STACK_Task+0x5ba>
}
    75e4:	b004      	add	sp, #16
    75e6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        _TCPIPSignalEntryNotify(_TCPIPModuleToSignalEntry(TCPIP_MODULE_MANAGER), TCPIP_MODULE_SIGNAL_ASYNC, 0);
    75ea:	2200      	movs	r2, #0
    75ec:	f44f 7180 	mov.w	r1, #256	; 0x100
    75f0:	4814      	ldr	r0, [pc, #80]	; (7644 <TCPIP_STACK_Task+0x614>)
    75f2:	f019 fcad 	bl	20f50 <_TCPIPSignalEntryNotify>
    75f6:	e7f5      	b.n	75e4 <TCPIP_STACK_Task+0x5b4>
    if( totTcpipEventsCnt)
    75f8:	4b13      	ldr	r3, [pc, #76]	; (7648 <TCPIP_STACK_Task+0x618>)
    75fa:	681b      	ldr	r3, [r3, #0]
    75fc:	2b00      	cmp	r3, #0
    75fe:	f47f aebe 	bne.w	737e <TCPIP_STACK_Task+0x34e>
    pSigEntry = TCPIP_STACK_MODULE_SIGNAL_TBL + TCPIP_MODULE_LAYER1;
    7602:	4c12      	ldr	r4, [pc, #72]	; (764c <TCPIP_STACK_Task+0x61c>)
        if((pSigEntry->currTmo -= stackTaskRate) <= 0)
    7604:	4e12      	ldr	r6, [pc, #72]	; (7650 <TCPIP_STACK_Task+0x620>)
            _TCPIPSignalEntrySetNotify(pSigEntry, TCPIP_MODULE_SIGNAL_TMO, 0); 
    7606:	2700      	movs	r7, #0
    for(ix = TCPIP_MODULE_LAYER1; ix < sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL)/sizeof(*TCPIP_STACK_MODULE_SIGNAL_TBL); ix++, pSigEntry++)
    7608:	f504 7514 	add.w	r5, r4, #592	; 0x250
    760c:	e7b6      	b.n	757c <TCPIP_STACK_Task+0x54c>
    if(tcpip_stack_status == SYS_STATUS_BUSY)
    760e:	4b11      	ldr	r3, [pc, #68]	; (7654 <TCPIP_STACK_Task+0x624>)
    7610:	f993 3000 	ldrsb.w	r3, [r3]
    7614:	2b01      	cmp	r3, #1
    7616:	f47f ade5 	bne.w	71e4 <TCPIP_STACK_Task+0x1b4>
            tcpip_stack_status = SYS_STATUS_READY;
    761a:	4b0e      	ldr	r3, [pc, #56]	; (7654 <TCPIP_STACK_Task+0x624>)
    761c:	2202      	movs	r2, #2
    761e:	701a      	strb	r2, [r3, #0]
            SYS_CONSOLE_MESSAGE(TCPIP_STACK_HDR_MESSAGE "Initialization Ended - success \r\n");
    7620:	490d      	ldr	r1, [pc, #52]	; (7658 <TCPIP_STACK_Task+0x628>)
    7622:	2000      	movs	r0, #0
    7624:	f017 fee0 	bl	1f3e8 <SYS_CONSOLE_Message>
    7628:	e5dc      	b.n	71e4 <TCPIP_STACK_Task+0x1b4>
    762a:	4770      	bx	lr
    762c:	2000dc90 	.word	0x2000dc90
    7630:	000215a4 	.word	0x000215a4
    7634:	2000d1d4 	.word	0x2000d1d4
    7638:	2000e440 	.word	0x2000e440
    763c:	2000e0f0 	.word	0x2000e0f0
    7640:	2000e434 	.word	0x2000e434
    7644:	2000d1e4 	.word	0x2000d1e4
    7648:	2000e448 	.word	0x2000e448
    764c:	2000d1f4 	.word	0x2000d1f4
    7650:	2000e438 	.word	0x2000e438
    7654:	2000e50d 	.word	0x2000e50d
    7658:	000094e0 	.word	0x000094e0
    765c:	2000e428 	.word	0x2000e428

Disassembly of section .text.CommandIperfStart%190:

00007660 <CommandIperfStart>:
	}
	return 0;
}

static void CommandIperfStart(SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char** argv)
{
    7660:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7664:	b08d      	sub	sp, #52	; 0x34
    7666:	4682      	mov	sl, r0
    7668:	468b      	mov	fp, r1
    uint32_t tickFreq;
    uint32_t values[4], bw=0;
    
    float pktRate;
    uint16_t payloadSize = 0, asciTos;
    const void* cmdIoParam = pCmdIO->cmdIoParam;
    766a:	6843      	ldr	r3, [r0, #4]
    766c:	9302      	str	r3, [sp, #8]
    for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
    766e:	4bae      	ldr	r3, [pc, #696]	; (7928 <CommandIperfStart+0x2c8>)
    7670:	6819      	ldr	r1, [r3, #0]
    7672:	2900      	cmp	r1, #0
    7674:	f340 82ba 	ble.w	7bec <CommandIperfStart+0x58c>
    7678:	4691      	mov	r9, r2
		if(pIState->state == (uint8_t)IPERF_STANDBY_STATE)
    767a:	4bac      	ldr	r3, [pc, #688]	; (792c <CommandIperfStart+0x2cc>)
    767c:	f893 30ce 	ldrb.w	r3, [r3, #206]	; 0xce
    7680:	2b01      	cmp	r3, #1
    7682:	f000 82ba 	beq.w	7bfa <CommandIperfStart+0x59a>
    for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
    7686:	2300      	movs	r3, #0
    7688:	4da8      	ldr	r5, [pc, #672]	; (792c <CommandIperfStart+0x2cc>)
    768a:	3301      	adds	r3, #1
    768c:	35d8      	adds	r5, #216	; 0xd8
    768e:	428b      	cmp	r3, r1
    7690:	f000 82ac 	beq.w	7bec <CommandIperfStart+0x58c>
		if(pIState->state == (uint8_t)IPERF_STANDBY_STATE)
    7694:	f895 20ce 	ldrb.w	r2, [r5, #206]	; 0xce
    7698:	2a01      	cmp	r2, #1
    769a:	d1f6      	bne.n	768a <CommandIperfStart+0x2a>
    {
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "\r\niperf: All instances busy. Retry later!\r\n");
        return;
    }

    (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: Starting session instance %d\r\n", pIState - gIperfState);
    769c:	4ba3      	ldr	r3, [pc, #652]	; (792c <CommandIperfStart+0x2cc>)
    769e:	1aeb      	subs	r3, r5, r3
    76a0:	10db      	asrs	r3, r3, #3
    76a2:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
    76a6:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    76aa:	ebc3 2343 	rsb	r3, r3, r3, lsl #9
    76ae:	eb03 4383 	add.w	r3, r3, r3, lsl #18
    76b2:	f8da 2000 	ldr.w	r2, [sl]
    76b6:	6854      	ldr	r4, [r2, #4]
    76b8:	425a      	negs	r2, r3
    76ba:	499d      	ldr	r1, [pc, #628]	; (7930 <CommandIperfStart+0x2d0>)
    76bc:	9802      	ldr	r0, [sp, #8]
    76be:	47a0      	blx	r4

	// preparation for new iperf test
    pIState->mServerMode = false;
    76c0:	2400      	movs	r4, #0
    76c2:	f885 40d1 	strb.w	r4, [r5, #209]	; 0xd1
#if defined(TCPIP_STACK_USE_TCP)
    pIState->mProtocol = TCP_PROTOCOL;   			// default is TCP mode.
    76c6:	2302      	movs	r3, #2
    76c8:	742b      	strb	r3, [r5, #16]
#else
    pIState->mProtocol = UDP_PROTOCOL;
#endif  // defined(TCPIP_STACK_USE_TCP)
    pIState->stopRequested = false;
    76ca:	f885 40cf 	strb.w	r4, [r5, #207]	; 0xcf

    pIState->mServerPort = TCPIP_IPERF_SERVER_PORT;		// -p. default: server port 5001
    76ce:	f241 3389 	movw	r3, #5001	; 0x1389
    76d2:	826b      	strh	r3, [r5, #18]

    pIState->mTxRate = ((uint32_t) TCPIP_IPERF_TX_BW_LIMIT*1000)*((uint32_t) 1000);		// -b or -x. Target tx rate.
    76d4:	4b97      	ldr	r3, [pc, #604]	; (7934 <CommandIperfStart+0x2d4>)
    76d6:	61ab      	str	r3, [r5, #24]
    // KS: default tx rate for iperf is actually 1Mbps.

    tickFreq = SYS_TMR_TickCounterFrequencyGet(); 
    76d8:	f018 fd30 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
    76dc:	9004      	str	r0, [sp, #16]
    pIState->mAmount = 0;			// -n: default 0.
    76de:	606c      	str	r4, [r5, #4]
    pIState->mDuration = ((uint32_t) 10)*(tickFreq); // -t: default 10 sec.
    76e0:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    76e4:	005b      	lsls	r3, r3, #1
    76e6:	60ab      	str	r3, [r5, #8]
    pIState->mInterval =  tickFreq; 	// -i: default 1 sec.
    76e8:	6028      	str	r0, [r5, #0]

    pIState->mTypeOfService = 0;       //-S, --tos (Type Of Service): default 0: BestEffort
    76ea:	752c      	strb	r4, [r5, #20]
    // remember the console we've been invoked from
    pIState->pCmdIO = pCmdIO;
    76ec:	f8c5 a0c4 	str.w	sl, [r5, #196]	; 0xc4

    
    // Initialize statistics

    ResetIperfCounters(pIState);
    76f0:	4628      	mov	r0, r5
    76f2:	f015 f983 	bl	1c9fc <ResetIperfCounters>

    for (i = 1; i < argc; i++)
    76f6:	f1bb 0f01 	cmp.w	fp, #1
    76fa:	f340 81e1 	ble.w	7ac0 <CommandIperfStart+0x460>
    76fe:	2401      	movs	r4, #1
    {
        if ((memcmp(argv[i], "-s", 2) == 0) || (memcmp(argv[i], "--server", 5) == 0) )
    7700:	4e8d      	ldr	r6, [pc, #564]	; (7938 <CommandIperfStart+0x2d8>)
                 mpf2 = mpf2/10;
    7702:	f8cd a00c 	str.w	sl, [sp, #12]
    7706:	e007      	b.n	7718 <CommandIperfStart+0xb8>
        {
            // Function as an iperf server.

            pIState->mServerMode = true;
    7708:	2301      	movs	r3, #1
    770a:	f885 30d1 	strb.w	r3, [r5, #209]	; 0xd1
    for (i = 1; i < argc; i++)
    770e:	3401      	adds	r4, #1
    7710:	b2e4      	uxtb	r4, r4
    7712:	455c      	cmp	r4, fp
    7714:	f280 81d2 	bge.w	7abc <CommandIperfStart+0x45c>
        if ((memcmp(argv[i], "-s", 2) == 0) || (memcmp(argv[i], "--server", 5) == 0) )
    7718:	f859 7024 	ldr.w	r7, [r9, r4, lsl #2]
    771c:	2202      	movs	r2, #2
    771e:	4987      	ldr	r1, [pc, #540]	; (793c <CommandIperfStart+0x2dc>)
    7720:	4638      	mov	r0, r7
    7722:	f019 fd1f 	bl	21164 <memcmp>
    7726:	2800      	cmp	r0, #0
    7728:	d0ee      	beq.n	7708 <CommandIperfStart+0xa8>
    772a:	2205      	movs	r2, #5
    772c:	f506 7117 	add.w	r1, r6, #604	; 0x25c
    7730:	4638      	mov	r0, r7
    7732:	f019 fd17 	bl	21164 <memcmp>
    7736:	2800      	cmp	r0, #0
    7738:	d0e6      	beq.n	7708 <CommandIperfStart+0xa8>
        }
#if defined(TCPIP_STACK_USE_UDP)
        else if ((memcmp(argv[i], "-u", 2) == 0) || (memcmp(argv[i], "--udp", 5) == 0) )
    773a:	2202      	movs	r2, #2
    773c:	f506 711a 	add.w	r1, r6, #616	; 0x268
    7740:	4638      	mov	r0, r7
    7742:	f019 fd0f 	bl	21164 <memcmp>
    7746:	b130      	cbz	r0, 7756 <CommandIperfStart+0xf6>
    7748:	2205      	movs	r2, #5
    774a:	f506 711b 	add.w	r1, r6, #620	; 0x26c
    774e:	4638      	mov	r0, r7
    7750:	f019 fd08 	bl	21164 <memcmp>
    7754:	b910      	cbnz	r0, 775c <CommandIperfStart+0xfc>
        {
            // iperf UDP mode.
            pIState->mProtocol = UDP_PROTOCOL;
    7756:	2301      	movs	r3, #1
    7758:	742b      	strb	r3, [r5, #16]
    775a:	e7d8      	b.n	770e <CommandIperfStart+0xae>
        }
        else if ((memcmp(argv[i], "-b", 2) == 0) || (memcmp(argv[i], "--bandwidth", 5) == 0) )
    775c:	2202      	movs	r2, #2
    775e:	f506 711d 	add.w	r1, r6, #628	; 0x274
    7762:	4638      	mov	r0, r7
    7764:	f019 fcfe 	bl	21164 <memcmp>
    7768:	b138      	cbz	r0, 777a <CommandIperfStart+0x11a>
    776a:	2205      	movs	r2, #5
    776c:	f506 711e 	add.w	r1, r6, #632	; 0x278
    7770:	4638      	mov	r0, r7
    7772:	f019 fcf7 	bl	21164 <memcmp>
    7776:	2800      	cmp	r0, #0
    7778:	d15d      	bne.n	7836 <CommandIperfStart+0x1d6>
        {
            // iperf UDP mode.
            pIState->mProtocol = UDP_PROTOCOL;
    777a:	2301      	movs	r3, #1
    777c:	742b      	strb	r3, [r5, #16]

            // Next argument should be the target rate, in bps.
            i++;
    777e:	441c      	add	r4, r3
    7780:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
    7782:	f859 8024 	ldr.w	r8, [r9, r4, lsl #2]
            len = strlen(ptr);
    7786:	4640      	mov	r0, r8
    7788:	f01a fa90 	bl	21cac <strlen>
            
            if((strcmp((ptr+(len-1)),"M")==0) || (strcmp((ptr+(len-1)),"K")==0))
    778c:	b2c7      	uxtb	r7, r0
    778e:	f107 3aff 	add.w	sl, r7, #4294967295
    7792:	44c2      	add	sl, r8
    7794:	f506 7121 	add.w	r1, r6, #644	; 0x284
    7798:	4650      	mov	r0, sl
    779a:	f01a f93f 	bl	21a1c <strcmp>
    779e:	b1a8      	cbz	r0, 77cc <CommandIperfStart+0x16c>
    77a0:	f506 7122 	add.w	r1, r6, #648	; 0x288
    77a4:	4650      	mov	r0, sl
    77a6:	f01a f939 	bl	21a1c <strcmp>
    77aa:	2800      	cmp	r0, #0
    77ac:	d13c      	bne.n	7828 <CommandIperfStart+0x1c8>
        mpf1 = 100 * 10;
    77ae:	f44f 7a7a 	mov.w	sl, #1000	; 0x3e8
        for(j=0;j<len-1;j++)
    77b2:	f107 3eff 	add.w	lr, r7, #4294967295
    77b6:	f1be 0f00 	cmp.w	lr, #0
    77ba:	dd32      	ble.n	7822 <CommandIperfStart+0x1c2>
    uint32_t bw1=0, bw2=0,  mpf1=0, mpf2 = 1000000;
    77bc:	f04f 0c00 	mov.w	ip, #0
    77c0:	4662      	mov	r2, ip
    uint8_t j, len, decimal=1;
    77c2:	2701      	movs	r7, #1
        for(j=0;j<len-1;j++)
    77c4:	4663      	mov	r3, ip
                decimal = 0;
    77c6:	9405      	str	r4, [sp, #20]
    77c8:	4654      	mov	r4, sl
    77ca:	e1f8      	b.n	7bbe <CommandIperfStart+0x55e>
    if(strcmp((ptr+(len-1)),"K")==0)
    77cc:	f506 7122 	add.w	r1, r6, #648	; 0x288
    77d0:	4650      	mov	r0, sl
    77d2:	f01a f923 	bl	21a1c <strcmp>
    77d6:	2800      	cmp	r0, #0
        mpf1 = 1000 * 1000;
    77d8:	4b59      	ldr	r3, [pc, #356]	; (7940 <CommandIperfStart+0x2e0>)
    77da:	bf0c      	ite	eq
    77dc:	f44f 7a7a 	moveq.w	sl, #1000	; 0x3e8
    77e0:	469a      	movne	sl, r3
    77e2:	e7e6      	b.n	77b2 <CommandIperfStart+0x152>
                bw1 = bw1*10 + *(ptr+j) - '0';
    77e4:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    77e8:	eb00 0242 	add.w	r2, r0, r2, lsl #1
    77ec:	3a30      	subs	r2, #48	; 0x30
    77ee:	e1f0      	b.n	7bd2 <CommandIperfStart+0x572>
    77f0:	4623      	mov	r3, r4
    77f2:	9c05      	ldr	r4, [sp, #20]
        bw2 = bw2 * mpf2;
    77f4:	fb03 f30c 	mul.w	r3, r3, ip
        if(bw1 < mpf1)
    77f8:	4552      	cmp	r2, sl
    77fa:	d201      	bcs.n	7800 <CommandIperfStart+0x1a0>
            bw1 = bw1 * mpf1;
    77fc:	fb0a f202 	mul.w	r2, sl, r2
        values[0] = bw1;
    7800:	9208      	str	r2, [sp, #32]
        values[1] = bw2;
    7802:	9309      	str	r3, [sp, #36]	; 0x24
        (*pCmdIO->pCmdApi->print)(pCmdIO->cmdIoParam, "\nGiven in BW: %lu+%lu=%lu",bw1,bw2,bw1+bw2);
    7804:	9903      	ldr	r1, [sp, #12]
    7806:	6809      	ldr	r1, [r1, #0]
    7808:	1898      	adds	r0, r3, r2
    780a:	9000      	str	r0, [sp, #0]
    780c:	684f      	ldr	r7, [r1, #4]
    780e:	f506 7123 	add.w	r1, r6, #652	; 0x28c
    7812:	9803      	ldr	r0, [sp, #12]
    7814:	6840      	ldr	r0, [r0, #4]
    7816:	47b8      	blx	r7
            {  
                bw_conversion(pCmdIO, ptr, values);
                bw = values[0]+values[1];
    7818:	9b08      	ldr	r3, [sp, #32]
    781a:	9a09      	ldr	r2, [sp, #36]	; 0x24
    781c:	4413      	add	r3, r2
                ascii_to_u32s(ptr, values, 1);
                bw = values[0];
            }

            //(*pCmdIO->pCmdApi->print)(cmdIoParam, "\nGiven BW:%d",bw);            
            pIState->mTxRate = bw;
    781e:	61ab      	str	r3, [r5, #24]
    7820:	e775      	b.n	770e <CommandIperfStart+0xae>
    uint32_t bw1=0, bw2=0,  mpf1=0, mpf2 = 1000000;
    7822:	2200      	movs	r2, #0
        bw2 = bw2 * mpf2;
    7824:	4613      	mov	r3, r2
    7826:	e7e9      	b.n	77fc <CommandIperfStart+0x19c>
                ascii_to_u32s(ptr, values, 1);
    7828:	2201      	movs	r2, #1
    782a:	a908      	add	r1, sp, #32
    782c:	4640      	mov	r0, r8
    782e:	f010 ff03 	bl	18638 <ascii_to_u32s>
                bw = values[0];
    7832:	9b08      	ldr	r3, [sp, #32]
    7834:	e7f3      	b.n	781e <CommandIperfStart+0x1be>
        }
#endif  // defined(TCPIP_STACK_USE_UDP)
#if defined(TCPIP_STACK_USE_TCP)
        else if ((memcmp(argv[i], "-x", 2) == 0) || (memcmp(argv[i], "--xmitrate", 5) == 0) )
    7836:	2202      	movs	r2, #2
    7838:	f506 712a 	add.w	r1, r6, #680	; 0x2a8
    783c:	4638      	mov	r0, r7
    783e:	f019 fc91 	bl	21164 <memcmp>
    7842:	b130      	cbz	r0, 7852 <CommandIperfStart+0x1f2>
    7844:	2205      	movs	r2, #5
    7846:	f506 712b 	add.w	r1, r6, #684	; 0x2ac
    784a:	4638      	mov	r0, r7
    784c:	f019 fc8a 	bl	21164 <memcmp>
    7850:	b950      	cbnz	r0, 7868 <CommandIperfStart+0x208>
        {
            // NON-STANDARD IPERF OPTION. Set the max TCP tx rate.
            // Next argument should be the target rate, in bps.
            i++;
    7852:	3401      	adds	r4, #1
    7854:	b2e4      	uxtb	r4, r4
            ptr = argv[i];

            ascii_to_u32s(ptr, values, 1);
    7856:	2201      	movs	r2, #1
    7858:	a908      	add	r1, sp, #32
    785a:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    785e:	f010 feeb 	bl	18638 <ascii_to_u32s>

            pIState->mTxRate = values[0];
    7862:	9b08      	ldr	r3, [sp, #32]
    7864:	61ab      	str	r3, [r5, #24]
    7866:	e752      	b.n	770e <CommandIperfStart+0xae>
        }
#endif  // defined(TCPIP_STACK_USE_TCP)
        else if ((memcmp(argv[i], "-c", 2) == 0) || (memcmp(argv[i], "--client", 5) == 0) )
    7868:	2202      	movs	r2, #2
    786a:	f506 712e 	add.w	r1, r6, #696	; 0x2b8
    786e:	4638      	mov	r0, r7
    7870:	f019 fc78 	bl	21164 <memcmp>
    7874:	b130      	cbz	r0, 7884 <CommandIperfStart+0x224>
    7876:	2205      	movs	r2, #5
    7878:	f506 712f 	add.w	r1, r6, #700	; 0x2bc
    787c:	4638      	mov	r0, r7
    787e:	f019 fc71 	bl	21164 <memcmp>
    7882:	b9b8      	cbnz	r0, 78b4 <CommandIperfStart+0x254>
        {
            // Function as an iperf client.
            pIState->mServerMode = false;
    7884:	2300      	movs	r3, #0
    7886:	f885 30d1 	strb.w	r3, [r5, #209]	; 0xd1

            // Next argument should be the server IP, such as "192.168.1.100".
            i++;
    788a:	3401      	adds	r4, #1
    788c:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
            ascii_to_u32s(ptr, values, 4);
    788e:	2204      	movs	r2, #4
    7890:	a908      	add	r1, sp, #32
    7892:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    7896:	f010 fecf 	bl	18638 <ascii_to_u32s>

            pIState->remoteSide.remoteIPaddress.v4Add.v[0] = values[0];
    789a:	9b08      	ldr	r3, [sp, #32]
    789c:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
            pIState->remoteSide.remoteIPaddress.v4Add.v[1] = values[1];
    78a0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    78a2:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
            pIState->remoteSide.remoteIPaddress.v4Add.v[2] = values[2];
    78a6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    78a8:	f885 3046 	strb.w	r3, [r5, #70]	; 0x46
            pIState->remoteSide.remoteIPaddress.v4Add.v[3] = values[3]; 
    78ac:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    78ae:	f885 3047 	strb.w	r3, [r5, #71]	; 0x47
    78b2:	e72c      	b.n	770e <CommandIperfStart+0xae>
        }
        else if ((memcmp(argv[i], "-t", 2) == 0) || (memcmp(argv[i], "--time", 5) == 0) )
    78b4:	2202      	movs	r2, #2
    78b6:	f506 7132 	add.w	r1, r6, #712	; 0x2c8
    78ba:	4638      	mov	r0, r7
    78bc:	f019 fc52 	bl	21164 <memcmp>
    78c0:	b130      	cbz	r0, 78d0 <CommandIperfStart+0x270>
    78c2:	2205      	movs	r2, #5
    78c4:	f506 7133 	add.w	r1, r6, #716	; 0x2cc
    78c8:	4638      	mov	r0, r7
    78ca:	f019 fc4b 	bl	21164 <memcmp>
    78ce:	b978      	cbnz	r0, 78f0 <CommandIperfStart+0x290>
        {
            // Next argument should be the (client tx) duration, in seconds.
            i++;
    78d0:	3401      	adds	r4, #1
    78d2:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
            ascii_to_u32s(ptr, values, 1);
    78d4:	2201      	movs	r2, #1
    78d6:	a908      	add	r1, sp, #32
    78d8:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    78dc:	f010 feac 	bl	18638 <ascii_to_u32s>

            pIState->mDuration = values[0] * tickFreq;
    78e0:	9b08      	ldr	r3, [sp, #32]
    78e2:	9a04      	ldr	r2, [sp, #16]
    78e4:	fb02 f303 	mul.w	r3, r2, r3
    78e8:	60ab      	str	r3, [r5, #8]
            pIState->mAmount = 0;
    78ea:	2300      	movs	r3, #0
    78ec:	606b      	str	r3, [r5, #4]
    78ee:	e70e      	b.n	770e <CommandIperfStart+0xae>
        }
        else if ((memcmp(argv[i], "-n", 2) == 0) || (memcmp(argv[i], "--num", 5) == 0) )
    78f0:	2202      	movs	r2, #2
    78f2:	f506 7135 	add.w	r1, r6, #724	; 0x2d4
    78f6:	4638      	mov	r0, r7
    78f8:	f019 fc34 	bl	21164 <memcmp>
    78fc:	b130      	cbz	r0, 790c <CommandIperfStart+0x2ac>
    78fe:	2205      	movs	r2, #5
    7900:	f506 7136 	add.w	r1, r6, #728	; 0x2d8
    7904:	4638      	mov	r0, r7
    7906:	f019 fc2d 	bl	21164 <memcmp>
    790a:	b9d8      	cbnz	r0, 7944 <CommandIperfStart+0x2e4>
        {
            // Next argument should be the (client tx) size, in bytes.
            i++;
    790c:	3401      	adds	r4, #1
    790e:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
            ascii_to_u32s(ptr, values, 1);
    7910:	2201      	movs	r2, #1
    7912:	a908      	add	r1, sp, #32
    7914:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    7918:	f010 fe8e 	bl	18638 <ascii_to_u32s>

            pIState->mAmount = values[0];
    791c:	9b08      	ldr	r3, [sp, #32]
    791e:	606b      	str	r3, [r5, #4]
            pIState->mDuration = 0;
    7920:	2300      	movs	r3, #0
    7922:	60ab      	str	r3, [r5, #8]
    7924:	e6f3      	b.n	770e <CommandIperfStart+0xae>
    7926:	bf00      	nop
    7928:	2000e3f0 	.word	0x2000e3f0
    792c:	2000d9b0 	.word	0x2000d9b0
    7930:	00005be8 	.word	0x00005be8
    7934:	00989680 	.word	0x00989680
    7938:	000057b4 	.word	0x000057b4
    793c:	00005a0c 	.word	0x00005a0c
    7940:	000f4240 	.word	0x000f4240
        }
        else if ((memcmp(argv[i], "-S", 2) == 0) || (memcmp(argv[i], "--tos", 5) == 0) )
    7944:	2202      	movs	r2, #2
    7946:	f506 7138 	add.w	r1, r6, #736	; 0x2e0
    794a:	4638      	mov	r0, r7
    794c:	f019 fc0a 	bl	21164 <memcmp>
    7950:	b138      	cbz	r0, 7962 <CommandIperfStart+0x302>
    7952:	2205      	movs	r2, #5
    7954:	f506 7139 	add.w	r1, r6, #740	; 0x2e4
    7958:	4638      	mov	r0, r7
    795a:	f019 fc03 	bl	21164 <memcmp>
    795e:	2800      	cmp	r0, #0
    7960:	d137      	bne.n	79d2 <CommandIperfStart+0x372>
        {
            // Next argument should be the (client tx) TOS
            i++;
    7962:	3401      	adds	r4, #1
    7964:	b2e4      	uxtb	r4, r4
            if(argv[i][1] == 'x')
    7966:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    796a:	7843      	ldrb	r3, [r0, #1]
    796c:	2b78      	cmp	r3, #120	; 0x78
    796e:	d018      	beq.n	79a2 <CommandIperfStart+0x342>
                tos = hexatob(asciTos);
            }
            else
            {
                ptr = argv[i];
                ascii_to_u32s(ptr, values, 1);
    7970:	2201      	movs	r2, #1
    7972:	a908      	add	r1, sp, #32
    7974:	f010 fe60 	bl	18638 <ascii_to_u32s>
                tos = values[0];                
    7978:	f89d 0020 	ldrb.w	r0, [sp, #32]
            }

            switch(tos)
    797c:	4602      	mov	r2, r0
    797e:	2820      	cmp	r0, #32
    7980:	d021      	beq.n	79c6 <CommandIperfStart+0x366>
    7982:	d919      	bls.n	79b8 <CommandIperfStart+0x358>
    7984:	28a0      	cmp	r0, #160	; 0xa0
    7986:	d01b      	beq.n	79c0 <CommandIperfStart+0x360>
    7988:	28c0      	cmp	r0, #192	; 0xc0
    798a:	d11f      	bne.n	79cc <CommandIperfStart+0x36c>
            {
                case IPERF_TOS_VO:
                    pIState->mTypeOfService = TCPIP_IPV4_THROUGHPUT_HIGH;                  
    798c:	2310      	movs	r3, #16
    798e:	752b      	strb	r3, [r5, #20]
                    break;
                 default:   
                    pIState->mTypeOfService = TCPIP_IPV4_TOS_DEFAULT;                                                          
            }

            (*pCmdIO->pCmdApi->print)(cmdIoParam, "\nGiven TOS value is %d, mTypeOfService:%d",tos,pIState->mTypeOfService);
    7990:	9b03      	ldr	r3, [sp, #12]
    7992:	681b      	ldr	r3, [r3, #0]
    7994:	685f      	ldr	r7, [r3, #4]
    7996:	7d2b      	ldrb	r3, [r5, #20]
    7998:	f506 713b 	add.w	r1, r6, #748	; 0x2ec
    799c:	9802      	ldr	r0, [sp, #8]
    799e:	47b8      	blx	r7
    79a0:	e6b5      	b.n	770e <CommandIperfStart+0xae>
                ((uint8_t*)&asciTos)[1] = argv[i][2];
    79a2:	7883      	ldrb	r3, [r0, #2]
    79a4:	f88d 301f 	strb.w	r3, [sp, #31]
                ((uint8_t*)&asciTos)[0] = argv[i][3];                    
    79a8:	78c3      	ldrb	r3, [r0, #3]
    79aa:	f88d 301e 	strb.w	r3, [sp, #30]
                tos = hexatob(asciTos);
    79ae:	f8bd 001e 	ldrh.w	r0, [sp, #30]
    79b2:	f016 fb74 	bl	1e09e <hexatob>
    79b6:	e7e1      	b.n	797c <CommandIperfStart+0x31c>
            switch(tos)
    79b8:	b940      	cbnz	r0, 79cc <CommandIperfStart+0x36c>
                    pIState->mTypeOfService = TCPIP_IPV4_TOS_DEFAULT;                                      
    79ba:	2300      	movs	r3, #0
    79bc:	752b      	strb	r3, [r5, #20]
                    break;
    79be:	e7e7      	b.n	7990 <CommandIperfStart+0x330>
                    pIState->mTypeOfService = TCPIP_IPV4_RELIABILITY_HIGH;                                      
    79c0:	2320      	movs	r3, #32
    79c2:	752b      	strb	r3, [r5, #20]
                    break;
    79c4:	e7e4      	b.n	7990 <CommandIperfStart+0x330>
                    pIState->mTypeOfService = TCPIP_IPV4_DELAY_LOW;                                      
    79c6:	2308      	movs	r3, #8
    79c8:	752b      	strb	r3, [r5, #20]
                    break;
    79ca:	e7e1      	b.n	7990 <CommandIperfStart+0x330>
                    pIState->mTypeOfService = TCPIP_IPV4_TOS_DEFAULT;                                                          
    79cc:	2300      	movs	r3, #0
    79ce:	752b      	strb	r3, [r5, #20]
    79d0:	e7de      	b.n	7990 <CommandIperfStart+0x330>
            
        }
        
#if defined(TCPIP_STACK_USE_TCP)
        else if ((memcmp(argv[i], "-M", 2) == 0) ||
    79d2:	2202      	movs	r2, #2
    79d4:	f506 7146 	add.w	r1, r6, #792	; 0x318
    79d8:	4638      	mov	r0, r7
    79da:	f019 fbc3 	bl	21164 <memcmp>
    79de:	b130      	cbz	r0, 79ee <CommandIperfStart+0x38e>
                (memcmp(argv[i], "--mss", 5) == 0) )
    79e0:	2205      	movs	r2, #5
    79e2:	f506 7147 	add.w	r1, r6, #796	; 0x31c
    79e6:	4638      	mov	r0, r7
    79e8:	f019 fbbc 	bl	21164 <memcmp>
        else if ((memcmp(argv[i], "-M", 2) == 0) ||
    79ec:	b958      	cbnz	r0, 7a06 <CommandIperfStart+0x3a6>
        {
            // Next argument should be the (client tcp tx) MSS size, in bytes.

            i++;
    79ee:	3401      	adds	r4, #1
    79f0:	b2e4      	uxtb	r4, r4
            ptr = argv[i];

            ascii_to_u32s(ptr, values, 1);
    79f2:	2201      	movs	r2, #1
    79f4:	a908      	add	r1, sp, #32
    79f6:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    79fa:	f010 fe1d 	bl	18638 <ascii_to_u32s>

            pIState->mMSS = values[0];
    79fe:	9b08      	ldr	r3, [sp, #32]
    7a00:	f8a5 30d2 	strh.w	r3, [r5, #210]	; 0xd2
    7a04:	e683      	b.n	770e <CommandIperfStart+0xae>
        }
#endif  // defined(TCPIP_STACK_USE_TCP)

        else if ((memcmp(argv[i], "-i", 2) == 0) || (memcmp(argv[i], "--interval", 5) == 0) )
    7a06:	2202      	movs	r2, #2
    7a08:	f106 013c 	add.w	r1, r6, #60	; 0x3c
    7a0c:	4638      	mov	r0, r7
    7a0e:	f019 fba9 	bl	21164 <memcmp>
    7a12:	b130      	cbz	r0, 7a22 <CommandIperfStart+0x3c2>
    7a14:	2205      	movs	r2, #5
    7a16:	f506 7149 	add.w	r1, r6, #804	; 0x324
    7a1a:	4638      	mov	r0, r7
    7a1c:	f019 fba2 	bl	21164 <memcmp>
    7a20:	b968      	cbnz	r0, 7a3e <CommandIperfStart+0x3de>
        {
            // Next argument should be the report interval, in seconds.
            i++;
    7a22:	3401      	adds	r4, #1
    7a24:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
            ascii_to_u32s(ptr, values, 1);
    7a26:	2201      	movs	r2, #1
    7a28:	a908      	add	r1, sp, #32
    7a2a:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    7a2e:	f010 fe03 	bl	18638 <ascii_to_u32s>

            pIState->mInterval = values[0] * tickFreq; // Convert to msec
    7a32:	9b08      	ldr	r3, [sp, #32]
    7a34:	9a04      	ldr	r2, [sp, #16]
    7a36:	fb02 f303 	mul.w	r3, r2, r3
    7a3a:	602b      	str	r3, [r5, #0]
    7a3c:	e667      	b.n	770e <CommandIperfStart+0xae>
        }
        else if ((memcmp(argv[i], "-p", 2) == 0) || (memcmp(argv[i], "--port", 6) == 0) )
    7a3e:	2202      	movs	r2, #2
    7a40:	f506 714c 	add.w	r1, r6, #816	; 0x330
    7a44:	4638      	mov	r0, r7
    7a46:	f019 fb8d 	bl	21164 <memcmp>
    7a4a:	b130      	cbz	r0, 7a5a <CommandIperfStart+0x3fa>
    7a4c:	2206      	movs	r2, #6
    7a4e:	f506 714d 	add.w	r1, r6, #820	; 0x334
    7a52:	4638      	mov	r0, r7
    7a54:	f019 fb86 	bl	21164 <memcmp>
    7a58:	b950      	cbnz	r0, 7a70 <CommandIperfStart+0x410>
        {
            // Next argument should be the port number.
            i++;
    7a5a:	3401      	adds	r4, #1
    7a5c:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
            ascii_to_u32s(ptr, values, 1);
    7a5e:	2201      	movs	r2, #1
    7a60:	a908      	add	r1, sp, #32
    7a62:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    7a66:	f010 fde7 	bl	18638 <ascii_to_u32s>

		    pIState->mServerPort = values[0];		// -p. default: server port 5001
    7a6a:	9b08      	ldr	r3, [sp, #32]
    7a6c:	826b      	strh	r3, [r5, #18]
    7a6e:	e64e      	b.n	770e <CommandIperfStart+0xae>
        }
#if defined(TCPIP_STACK_USE_UDP)
        else if ((memcmp(argv[i], "-l", 2) == 0) || (memcmp(argv[i], "--len", 5) == 0) )
    7a70:	2202      	movs	r2, #2
    7a72:	f506 714f 	add.w	r1, r6, #828	; 0x33c
    7a76:	4638      	mov	r0, r7
    7a78:	f019 fb74 	bl	21164 <memcmp>
    7a7c:	b140      	cbz	r0, 7a90 <CommandIperfStart+0x430>
    7a7e:	2205      	movs	r2, #5
    7a80:	f506 7150 	add.w	r1, r6, #832	; 0x340
    7a84:	4638      	mov	r0, r7
    7a86:	f019 fb6d 	bl	21164 <memcmp>
    7a8a:	2800      	cmp	r0, #0
    7a8c:	f47f ae3f 	bne.w	770e <CommandIperfStart+0xae>
        {
            // Next argument should be the buffer length, in bytes.
            // This is used as the UDP datagram size.
            i++;
    7a90:	3401      	adds	r4, #1
    7a92:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
            ascii_to_u32s(ptr, values, 1);
    7a94:	2201      	movs	r2, #1
    7a96:	a908      	add	r1, sp, #32
    7a98:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    7a9c:	f010 fdcc 	bl	18638 <ascii_to_u32s>

            if ( values[0] <  MAX_BUFFER  )
    7aa0:	9b08      	ldr	r3, [sp, #32]
    7aa2:	2b33      	cmp	r3, #51	; 0x33
    7aa4:	d901      	bls.n	7aaa <CommandIperfStart+0x44a>
            {
               (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf: The minimum datagram size is %d\r\n", (int)MAX_BUFFER);
               return;
            }

            pIState->mDatagramSize = values[0];
    7aa6:	60eb      	str	r3, [r5, #12]
    7aa8:	e631      	b.n	770e <CommandIperfStart+0xae>
               (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf: The minimum datagram size is %d\r\n", (int)MAX_BUFFER);
    7aaa:	f8d5 30c4 	ldr.w	r3, [r5, #196]	; 0xc4
    7aae:	681b      	ldr	r3, [r3, #0]
    7ab0:	685b      	ldr	r3, [r3, #4]
    7ab2:	2234      	movs	r2, #52	; 0x34
    7ab4:	4952      	ldr	r1, [pc, #328]	; (7c00 <CommandIperfStart+0x5a0>)
    7ab6:	9802      	ldr	r0, [sp, #8]
    7ab8:	4798      	blx	r3
               return;
    7aba:	e006      	b.n	7aca <CommandIperfStart+0x46a>
    7abc:	f8dd a00c 	ldr.w	sl, [sp, #12]
        }
#endif  // defined(TCPIP_STACK_USE_UDP)
    }

    switch (pIState->mServerMode)
    7ac0:	f895 30d1 	ldrb.w	r3, [r5, #209]	; 0xd1
    7ac4:	b123      	cbz	r3, 7ad0 <CommandIperfStart+0x470>
    7ac6:	2b01      	cmp	r3, #1
    7ac8:	d03d      	beq.n	7b46 <CommandIperfStart+0x4e6>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, " port %d\r\n", pIState->mServerPort);
            IperfSetState(pIState, IPERF_RX_START_STATE);
            break;
    }
    
}
    7aca:	b00d      	add	sp, #52	; 0x34
    7acc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if((pIState->pNetIf = TCPIP_STACK_IPAddToNet(&pIState->localAddr, false)) == 0)
    7ad0:	2100      	movs	r1, #0
    7ad2:	f105 0080 	add.w	r0, r5, #128	; 0x80
    7ad6:	f018 fd1d 	bl	20514 <TCPIP_STACK_IPAddToNet>
    7ada:	f8c5 00c8 	str.w	r0, [r5, #200]	; 0xc8
    7ade:	b310      	cbz	r0, 7b26 <CommandIperfStart+0x4c6>
            if(pIState->mProtocol == TCP_PROTOCOL)
    7ae0:	7c2b      	ldrb	r3, [r5, #16]
    7ae2:	2b02      	cmp	r3, #2
    7ae4:	d02a      	beq.n	7b3c <CommandIperfStart+0x4dc>
            if(pIState->mProtocol == UDP_PROTOCOL)
    7ae6:	2b01      	cmp	r3, #1
                payloadSize = 	pIState->mDatagramSize;
    7ae8:	bf06      	itte	eq
    7aea:	89ab      	ldrheq	r3, [r5, #12]
    7aec:	ee07 3a10 	vmoveq	s14, r3
    uint16_t payloadSize = 0, asciTos;
    7af0:	ed9f 7a44 	vldrne	s14, [pc, #272]	; 7c04 <CommandIperfStart+0x5a4>
            pIState->mPktPeriod =  (uint32_t) ( (float) tickFreq / pktRate );
    7af4:	eddd 7a04 	vldr	s15, [sp, #16]
    7af8:	eeb8 6a67 	vcvt.f32.u32	s12, s15
            pktRate =  (float) (pIState->mTxRate / 8) / (float) payloadSize;
    7afc:	69ab      	ldr	r3, [r5, #24]
    7afe:	08db      	lsrs	r3, r3, #3
    7b00:	ee07 3a90 	vmov	s15, r3
    7b04:	eef8 7a67 	vcvt.f32.u32	s15, s15
    7b08:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    7b0c:	eec7 6a87 	vdiv.f32	s13, s15, s14
            pIState->mPktPeriod =  (uint32_t) ( (float) tickFreq / pktRate );
    7b10:	eec6 7a26 	vdiv.f32	s15, s12, s13
    7b14:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    7b18:	edc5 7a21 	vstr	s15, [r5, #132]	; 0x84
            IperfSetState(pIState, IPERF_TX_START_STATE);
    7b1c:	210a      	movs	r1, #10
    7b1e:	4628      	mov	r0, r5
    7b20:	f014 faaa 	bl	1c078 <IperfSetState>
            break;
    7b24:	e7d1      	b.n	7aca <CommandIperfStart+0x46a>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Using the default interface!\r\n");
    7b26:	f8da 3000 	ldr.w	r3, [sl]
    7b2a:	681b      	ldr	r3, [r3, #0]
    7b2c:	4936      	ldr	r1, [pc, #216]	; (7c08 <CommandIperfStart+0x5a8>)
    7b2e:	9802      	ldr	r0, [sp, #8]
    7b30:	4798      	blx	r3
                pIState->pNetIf = TCPIP_STACK_NetDefaultGet();
    7b32:	f01a fa69 	bl	22008 <TCPIP_STACK_NetDefaultGet>
    7b36:	f8c5 00c8 	str.w	r0, [r5, #200]	; 0xc8
    7b3a:	e7d1      	b.n	7ae0 <CommandIperfStart+0x480>
                payloadSize = 	pIState->mMSS;
    7b3c:	f8b5 30d2 	ldrh.w	r3, [r5, #210]	; 0xd2
    7b40:	ee07 3a10 	vmov	s14, r3
            if(pIState->mProtocol == UDP_PROTOCOL)
    7b44:	e7d6      	b.n	7af4 <CommandIperfStart+0x494>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "---------------------------------------------------------\r\n");
    7b46:	4c31      	ldr	r4, [pc, #196]	; (7c0c <CommandIperfStart+0x5ac>)
    7b48:	f8da 3000 	ldr.w	r3, [sl]
    7b4c:	681b      	ldr	r3, [r3, #0]
    7b4e:	f504 7167 	add.w	r1, r4, #924	; 0x39c
    7b52:	9e02      	ldr	r6, [sp, #8]
    7b54:	4630      	mov	r0, r6
    7b56:	4798      	blx	r3
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Server listening on ");
    7b58:	f8da 3000 	ldr.w	r3, [sl]
    7b5c:	681b      	ldr	r3, [r3, #0]
    7b5e:	f504 7176 	add.w	r1, r4, #984	; 0x3d8
    7b62:	4630      	mov	r0, r6
    7b64:	4798      	blx	r3
            if (pIState->mProtocol == UDP_PROTOCOL)
    7b66:	7c2b      	ldrb	r3, [r5, #16]
    7b68:	2b01      	cmp	r3, #1
    7b6a:	d00f      	beq.n	7b8c <CommandIperfStart+0x52c>
            if (pIState->mProtocol == TCP_PROTOCOL)
    7b6c:	7c2b      	ldrb	r3, [r5, #16]
    7b6e:	2b02      	cmp	r3, #2
    7b70:	d014      	beq.n	7b9c <CommandIperfStart+0x53c>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, " port %d\r\n", pIState->mServerPort);
    7b72:	f8d5 30c4 	ldr.w	r3, [r5, #196]	; 0xc4
    7b76:	681b      	ldr	r3, [r3, #0]
    7b78:	685b      	ldr	r3, [r3, #4]
    7b7a:	8a6a      	ldrh	r2, [r5, #18]
    7b7c:	4924      	ldr	r1, [pc, #144]	; (7c10 <CommandIperfStart+0x5b0>)
    7b7e:	9802      	ldr	r0, [sp, #8]
    7b80:	4798      	blx	r3
            IperfSetState(pIState, IPERF_RX_START_STATE);
    7b82:	2102      	movs	r1, #2
    7b84:	4628      	mov	r0, r5
    7b86:	f014 fa77 	bl	1c078 <IperfSetState>
            break;
    7b8a:	e79e      	b.n	7aca <CommandIperfStart+0x46a>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, (const char *)"UDP");
    7b8c:	f8da 3000 	ldr.w	r3, [sl]
    7b90:	681b      	ldr	r3, [r3, #0]
    7b92:	f504 717d 	add.w	r1, r4, #1012	; 0x3f4
    7b96:	9802      	ldr	r0, [sp, #8]
    7b98:	4798      	blx	r3
    7b9a:	e7e7      	b.n	7b6c <CommandIperfStart+0x50c>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, (const char *)"TCP");
    7b9c:	f8da 3000 	ldr.w	r3, [sl]
    7ba0:	681b      	ldr	r3, [r3, #0]
    7ba2:	491c      	ldr	r1, [pc, #112]	; (7c14 <CommandIperfStart+0x5b4>)
    7ba4:	9802      	ldr	r0, [sp, #8]
    7ba6:	4798      	blx	r3
    7ba8:	e7e3      	b.n	7b72 <CommandIperfStart+0x512>
            if(*(ptr+j) == (int8_t)'.')
    7baa:	282e      	cmp	r0, #46	; 0x2e
    7bac:	d102      	bne.n	7bb4 <CommandIperfStart+0x554>
                bw1 = bw1 * mpf1;
    7bae:	fb0a f202 	mul.w	r2, sl, r2
                decimal = 0;
    7bb2:	2700      	movs	r7, #0
        for(j=0;j<len-1;j++)
    7bb4:	3301      	adds	r3, #1
    7bb6:	b2db      	uxtb	r3, r3
    7bb8:	4573      	cmp	r3, lr
    7bba:	f6bf ae19 	bge.w	77f0 <CommandIperfStart+0x190>
            if ( (*(ptr+j) <= (int8_t)'9') && (*(ptr+j) >= (int8_t)'0') && (decimal == 1) )
    7bbe:	f818 0003 	ldrb.w	r0, [r8, r3]
    7bc2:	f1a0 0130 	sub.w	r1, r0, #48	; 0x30
    7bc6:	b2c9      	uxtb	r1, r1
    7bc8:	2909      	cmp	r1, #9
    7bca:	d8ee      	bhi.n	7baa <CommandIperfStart+0x54a>
    7bcc:	2f00      	cmp	r7, #0
    7bce:	f47f ae09 	bne.w	77e4 <CommandIperfStart+0x184>
            if ( (*(ptr+j) <= (int8_t)'9') && (*(ptr+j) >= (int8_t)'0') && (decimal == 0) )
    7bd2:	2f00      	cmp	r7, #0
    7bd4:	d1ee      	bne.n	7bb4 <CommandIperfStart+0x554>
                 bw2 = bw2*10 + *(ptr+j) - '0';
    7bd6:	eb0c 0c8c 	add.w	ip, ip, ip, lsl #2
    7bda:	eb00 004c 	add.w	r0, r0, ip, lsl #1
    7bde:	f1a0 0c30 	sub.w	ip, r0, #48	; 0x30
                 mpf2 = mpf2/10;
    7be2:	490d      	ldr	r1, [pc, #52]	; (7c18 <CommandIperfStart+0x5b8>)
    7be4:	fba1 0104 	umull	r0, r1, r1, r4
    7be8:	08cc      	lsrs	r4, r1, #3
    7bea:	e7e3      	b.n	7bb4 <CommandIperfStart+0x554>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "\r\niperf: All instances busy. Retry later!\r\n");
    7bec:	f8da 3000 	ldr.w	r3, [sl]
    7bf0:	681b      	ldr	r3, [r3, #0]
    7bf2:	490a      	ldr	r1, [pc, #40]	; (7c1c <CommandIperfStart+0x5bc>)
    7bf4:	9802      	ldr	r0, [sp, #8]
    7bf6:	4798      	blx	r3
        return;
    7bf8:	e767      	b.n	7aca <CommandIperfStart+0x46a>
    for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
    7bfa:	4d09      	ldr	r5, [pc, #36]	; (7c20 <CommandIperfStart+0x5c0>)
    7bfc:	e54e      	b.n	769c <CommandIperfStart+0x3c>
    7bfe:	bf00      	nop
    7c00:	00005afc 	.word	0x00005afc
    7c04:	00000000 	.word	0x00000000
    7c08:	00005b28 	.word	0x00005b28
    7c0c:	000057b4 	.word	0x000057b4
    7c10:	00005bb0 	.word	0x00005bb0
    7c14:	00005bac 	.word	0x00005bac
    7c18:	cccccccd 	.word	0xcccccccd
    7c1c:	00005bbc 	.word	0x00005bbc
    7c20:	2000d9b0 	.word	0x2000d9b0

Disassembly of section .text._TcpSend%191:

00007c24 <_TcpSend>:
    switch(pSkt->addType)
    7c24:	f890 306f 	ldrb.w	r3, [r0, #111]	; 0x6f
    7c28:	2b01      	cmp	r3, #1
    7c2a:	f040 828d 	bne.w	8148 <_TcpSend+0x524>
{
    7c2e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7c32:	b087      	sub	sp, #28
    7c34:	4604      	mov	r4, r0
    7c36:	460f      	mov	r7, r1
    7c38:	4692      	mov	sl, r2
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    7c3a:	2000      	movs	r0, #0
    7c3c:	f019 fcbe 	bl	215bc <OSAL_CRIT_Enter>
    if(pSkt->pV4Pkt != 0)
    7c40:	6c62      	ldr	r2, [r4, #68]	; 0x44
    7c42:	2a00      	cmp	r2, #0
    7c44:	f000 8292 	beq.w	816c <_TcpSend+0x548>
        if((pSkt->pV4Pkt->macPkt.pktFlags & TCPIP_MAC_PKT_FLAG_QUEUED) == 0)
    7c48:	8c53      	ldrh	r3, [r2, #34]	; 0x22
    7c4a:	f013 0f08 	tst.w	r3, #8
    7c4e:	f040 828d 	bne.w	816c <_TcpSend+0x548>
            pSkt->pV4Pkt->macPkt.pktFlags |= TCPIP_MAC_PKT_FLAG_QUEUED;
    7c52:	f043 0308 	orr.w	r3, r3, #8
    7c56:	8453      	strh	r3, [r2, #34]	; 0x22
            pktValid = (TCP_V4_PACKET*)pSkt->pV4Pkt;
    7c58:	6c66      	ldr	r6, [r4, #68]	; 0x44
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
    7c5a:	4601      	mov	r1, r0
    7c5c:	2000      	movs	r0, #0
    7c5e:	f019 fddc 	bl	2181a <OSAL_CRIT_Leave>
    if(!oldPkt)
    7c62:	2e00      	cmp	r6, #0
    7c64:	f000 8286 	beq.w	8174 <_TcpSend+0x550>
    pSeg->segLen = pSeg->segSize = 0;
    7c68:	2300      	movs	r3, #0
    7c6a:	f8a6 3052 	strh.w	r3, [r6, #82]	; 0x52
    7c6e:	f8a6 3050 	strh.w	r3, [r6, #80]	; 0x50
    pSeg->next = 0;
    7c72:	6473      	str	r3, [r6, #68]	; 0x44
    pSeg->segLen = pSeg->segSize = 0;
    7c74:	f8a6 306a 	strh.w	r3, [r6, #106]	; 0x6a
    7c78:	f8a6 3068 	strh.w	r3, [r6, #104]	; 0x68
    pSeg->next = 0;
    7c7c:	65f3      	str	r3, [r6, #92]	; 0x5c
    pTcpPkt->v4Pkt.macPkt.pDSeg->next = 0;    // unlink to the 1st data seg; leave header only
    7c7e:	6932      	ldr	r2, [r6, #16]
    7c80:	6013      	str	r3, [r2, #0]
    pTcpPkt->v4Pkt.macPkt.pDSeg->segLen = 0;  // clear the payload
    7c82:	6932      	ldr	r2, [r6, #16]
    7c84:	8193      	strh	r3, [r2, #12]
        if(vTCPFlags & FIN)
    7c86:	f017 0f01 	tst.w	r7, #1
    7c8a:	d007      	beq.n	7c9c <_TcpSend+0x78>
            pSkt->Flags.bTXFIN = 1;
    7c8c:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
    7c90:	f043 0301 	orr.w	r3, r3, #1
    7c94:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37
            vTCPFlags &= ~FIN;
    7c98:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
        pSkt->Flags.bTimer2Enabled = 0;
    7c9c:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
        pSkt->Flags.bHalfFullFlush = 0;
    7ca0:	f003 0323 	and.w	r3, r3, #35	; 0x23
    7ca4:	f36f 1345 	bfc	r3, #5, #1
    7ca8:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
        if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
    7cac:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    7cb0:	2b01      	cmp	r3, #1
            header = (TCP_HEADER*)((TCP_V4_PACKET*)pSendPkt)->v4Pkt.macPkt.pTransportLayer;
    7cb2:	bf0c      	ite	eq
    7cb4:	69f5      	ldreq	r5, [r6, #28]
    TCP_HEADER *    header = 0;
    7cb6:	2500      	movne	r5, #0
        header->DataOffset.Val = 0;
    7cb8:	7b2b      	ldrb	r3, [r5, #12]
    7cba:	f36f 1307 	bfc	r3, #4, #4
    7cbe:	732b      	strb	r3, [r5, #12]
        if(vTCPFlags & (SYN | RST))
    7cc0:	f017 0f06 	tst.w	r7, #6
    7cc4:	d049      	beq.n	7d5a <_TcpSend+0x136>
            if(vTCPFlags & SYN)
    7cc6:	f017 0f02 	tst.w	r7, #2
    7cca:	f000 8100 	beq.w	7ece <_TcpSend+0x2aa>
                options.Kind = TCP_OPTIONS_MAX_SEG_SIZE;
    7cce:	2302      	movs	r3, #2
    7cd0:	f88d 3014 	strb.w	r3, [sp, #20]
                options.Length = 0x04;
    7cd4:	2304      	movs	r3, #4
    7cd6:	f88d 3015 	strb.w	r3, [sp, #21]
                if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
    7cda:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    7cde:	2b01      	cmp	r3, #1
    7ce0:	d01b      	beq.n	7d1a <_TcpSend+0xf6>
    uint16_t 		mss = 0;
    7ce2:	2000      	movs	r0, #0
                options.MaxSegSize.Val = (((mss)&0x00FF)<<8) | (((mss)&0xFF00)>>8);
    7ce4:	0a03      	lsrs	r3, r0, #8
    7ce6:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
    7cea:	f8ad 3016 	strh.w	r3, [sp, #22]
                pSkt->localMSS = mss;
    7cee:	f8a4 0064 	strh.w	r0, [r4, #100]	; 0x64
                header->DataOffset.Val   += sizeof(options) >> 2;
    7cf2:	7b2b      	ldrb	r3, [r5, #12]
    7cf4:	f3c3 1203 	ubfx	r2, r3, #4, #4
    7cf8:	3201      	adds	r2, #1
    7cfa:	f362 1307 	bfi	r3, r2, #4, #4
    7cfe:	732b      	strb	r3, [r5, #12]
                if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
    7d00:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    7d04:	2b01      	cmp	r3, #1
                    memcpy(header + 1, &options, sizeof(options));
    7d06:	bf04      	itt	eq
    7d08:	9b05      	ldreq	r3, [sp, #20]
    7d0a:	616b      	streq	r3, [r5, #20]
                if(pSkt->MySEQ == 0)
    7d0c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    7d0e:	b1eb      	cbz	r3, 7d4c <_TcpSend+0x128>
    loadLen = (uint16_t)len;  // save the TCP payload size
    7d10:	f04f 0800 	mov.w	r8, #0
    7d14:	e0dd      	b.n	7ed2 <_TcpSend+0x2ae>
                pSkt->pTxPkt = pPkt;
    7d16:	6466      	str	r6, [r4, #68]	; 0x44
    7d18:	e249      	b.n	81ae <_TcpSend+0x58a>
                    if(pSkt->pSktNet == 0)
    7d1a:	6c23      	ldr	r3, [r4, #64]	; 0x40
    7d1c:	b12b      	cbz	r3, 7d2a <_TcpSend+0x106>
                    mss = TCPIP_IPV4_MaxDatagramDataSizeGet(pSkt->pSktNet) - sizeof(TCP_HEADER);
    7d1e:	6c20      	ldr	r0, [r4, #64]	; 0x40
    7d20:	f019 f8d0 	bl	20ec4 <TCPIP_IPV4_MaxDatagramDataSizeGet>
    7d24:	3814      	subs	r0, #20
    7d26:	b280      	uxth	r0, r0
    7d28:	e7dc      	b.n	7ce4 <_TcpSend+0xc0>
                        if(!_TcpSocketSetSourceInterface(pSkt))
    7d2a:	4620      	mov	r0, r4
    7d2c:	f015 fd7f 	bl	1d82e <_TcpSocketSetSourceInterface>
    7d30:	2800      	cmp	r0, #0
    7d32:	d1f4      	bne.n	7d1e <_TcpSend+0xfa>
                            sendRes = _TCP_SEND_NO_IF;
    7d34:	f06f 0003 	mvn.w	r0, #3
    if(sendRes != _TCP_SEND_OK && pSkt->addType == IP_ADDRESS_TYPE_IPV4)
    7d38:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    7d3c:	2b01      	cmp	r3, #1
    7d3e:	f040 8179 	bne.w	8034 <_TcpSend+0x410>
        ((TCP_V4_PACKET*)pSendPkt)->v4Pkt.macPkt.pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED ;
    7d42:	8c73      	ldrh	r3, [r6, #34]	; 0x22
    7d44:	f023 0308 	bic.w	r3, r3, #8
    7d48:	8473      	strh	r3, [r6, #34]	; 0x22
    if(sendRes == _TCP_SEND_OK && (vTCPFlags & RST) != 0 )
    7d4a:	e173      	b.n	8034 <_TcpSend+0x410>
                    pSkt->MySEQ = _TCP_SktSetSequenceNo(pSkt);
    7d4c:	4620      	mov	r0, r4
    7d4e:	f00f fb23 	bl	17398 <_TCP_SktSetSequenceNo>
    7d52:	64e0      	str	r0, [r4, #76]	; 0x4c
    loadLen = (uint16_t)len;  // save the TCP payload size
    7d54:	f04f 0800 	mov.w	r8, #0
    7d58:	e0bb      	b.n	7ed2 <_TcpSend+0x2ae>
            maxPayload = pSkt->wRemoteMSS;
    7d5a:	f8b4 b062 	ldrh.w	fp, [r4, #98]	; 0x62
            if(pSkt->txHead == pSkt->txUnackedTail)
    7d5e:	68a2      	ldr	r2, [r4, #8]
    7d60:	6923      	ldr	r3, [r4, #16]
    7d62:	429a      	cmp	r2, r3
    7d64:	f000 81fa 	beq.w	815c <_TcpSend+0x538>
                if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
    7d68:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    7d6c:	2b01      	cmp	r3, #1
    7d6e:	d039      	beq.n	7de4 <_TcpSend+0x1c0>
                    if(pSkt->localMSS < maxPayload)
    7d70:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    7d74:	459b      	cmp	fp, r3
    7d76:	bf28      	it	cs
    7d78:	469b      	movcs	fp, r3
                if(pSkt->txHead > pSkt->txUnackedTail)
    7d7a:	68a3      	ldr	r3, [r4, #8]
    7d7c:	6921      	ldr	r1, [r4, #16]
    7d7e:	428b      	cmp	r3, r1
    7d80:	d948      	bls.n	7e14 <_TcpSend+0x1f0>
                    len = pSkt->txHead - pSkt->txUnackedTail;
    7d82:	1a5b      	subs	r3, r3, r1
                    if(len > pSkt->remoteWindow)
    7d84:	f8b4 905c 	ldrh.w	r9, [r4, #92]	; 0x5c
    7d88:	4599      	cmp	r9, r3
    7d8a:	bf28      	it	cs
    7d8c:	4699      	movcs	r9, r3
                    if(len > maxPayload)
    7d8e:	45cb      	cmp	fp, r9
    7d90:	d206      	bcs.n	7da0 <_TcpSend+0x17c>
                        pSkt->Flags.bTXASAPWithoutTimerReset = 1;
    7d92:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    7d96:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    7d9a:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
                        len = maxPayload;
    7d9e:	46d9      	mov	r9, fp
}


static void _TCP_PayloadSet(TCB_STUB * pSkt, void* pPkt, uint8_t* payload1, uint16_t len1, uint8_t* payload2, uint16_t len2)
{
    switch(pSkt->addType)
    7da0:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    7da4:	2b01      	cmp	r3, #1
    7da6:	d022      	beq.n	7dee <_TcpSend+0x1ca>
                    pSkt->txUnackedTail += len;
    7da8:	6923      	ldr	r3, [r4, #16]
    7daa:	444b      	add	r3, r9
    7dac:	6123      	str	r3, [r4, #16]
            if(pSkt->Flags.bTXFIN)
    7dae:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
    7db2:	f013 0f01 	tst.w	r3, #1
    7db6:	d007      	beq.n	7dc8 <_TcpSend+0x1a4>
                if((len != pSkt->remoteWindow) && (len != maxPayload))
    7db8:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
    7dbc:	454b      	cmp	r3, r9
    7dbe:	d003      	beq.n	7dc8 <_TcpSend+0x1a4>
    7dc0:	45cb      	cmp	fp, r9
                    vTCPFlags |= FIN;
    7dc2:	bf18      	it	ne
    7dc4:	f047 0701 	orrne.w	r7, r7, #1
    loadLen = (uint16_t)len;  // save the TCP payload size
    7dc8:	fa1f f889 	uxth.w	r8, r9
        if(len || (vTCPFlags & (SYN | FIN)))
    7dcc:	f1b9 0f00 	cmp.w	r9, #0
    7dd0:	d07f      	beq.n	7ed2 <_TcpSend+0x2ae>
            pSkt->remoteWindow -= len;
    7dd2:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
    7dd6:	eba3 0308 	sub.w	r3, r3, r8
    7dda:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
                vTCPFlags |= PSH;
    7dde:	f047 0708 	orr.w	r7, r7, #8
    7de2:	e07b      	b.n	7edc <_TcpSend+0x2b8>
                    isFragmSupported = TCPIP_IPV4_IsFragmentationEnabled();
    7de4:	f01a fa2f 	bl	22246 <TCPIP_IPV4_IsFragmentationEnabled>
                if(!isFragmSupported)
    7de8:	2800      	cmp	r0, #0
    7dea:	d1c6      	bne.n	7d7a <_TcpSend+0x156>
    7dec:	e7c0      	b.n	7d70 <_TcpSend+0x14c>
        pSeg0->next = 0;
    7dee:	2300      	movs	r3, #0
    7df0:	6473      	str	r3, [r6, #68]	; 0x44
    if(pBuff1)
    7df2:	b159      	cbz	r1, 7e0c <_TcpSend+0x1e8>
                    _TCP_PayloadSet(pSkt, pSendPkt, pSkt->txUnackedTail, len, 0, 0);
    7df4:	fa1f f389 	uxth.w	r3, r9
        pSeg0->segLen = pSeg0->segSize = bSize1;
    7df8:	f8a6 3052 	strh.w	r3, [r6, #82]	; 0x52
    7dfc:	f8a6 3050 	strh.w	r3, [r6, #80]	; 0x50
        pSeg0->segLoad = pBuff1;
    7e00:	64f1      	str	r1, [r6, #76]	; 0x4c
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = pSeg0;  // link to the 1st data seg to be transmitted
    7e02:	6933      	ldr	r3, [r6, #16]
    TCPIP_MAC_DATA_SEGMENT* pSeg0 = pTcpPkt->tcpSeg + 0;
    7e04:	f106 0244 	add.w	r2, r6, #68	; 0x44
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = pSeg0;  // link to the 1st data seg to be transmitted
    7e08:	601a      	str	r2, [r3, #0]
    7e0a:	e7cd      	b.n	7da8 <_TcpSend+0x184>
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = 0;  // link to the 1st data seg to be transmitted
    7e0c:	6933      	ldr	r3, [r6, #16]
    7e0e:	2200      	movs	r2, #0
    7e10:	601a      	str	r2, [r3, #0]
    7e12:	e7c9      	b.n	7da8 <_TcpSend+0x184>
                    lenEnd = pSkt->txEnd - pSkt->txUnackedTail;
    7e14:	6862      	ldr	r2, [r4, #4]
    7e16:	1a52      	subs	r2, r2, r1
                    len = lenEnd + pSkt->txHead - pSkt->txStart;
    7e18:	6820      	ldr	r0, [r4, #0]
    7e1a:	4413      	add	r3, r2
    7e1c:	1a1b      	subs	r3, r3, r0
                    if(len > pSkt->remoteWindow)
    7e1e:	f8b4 905c 	ldrh.w	r9, [r4, #92]	; 0x5c
    7e22:	4599      	cmp	r9, r3
    7e24:	bf28      	it	cs
    7e26:	4699      	movcs	r9, r3
                    if(len > maxPayload)
    7e28:	45cb      	cmp	fp, r9
    7e2a:	d206      	bcs.n	7e3a <_TcpSend+0x216>
                        pSkt->Flags.bTXASAPWithoutTimerReset = 1;
    7e2c:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    7e30:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    7e34:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
                        len = maxPayload;
    7e38:	46d9      	mov	r9, fp
                    if (lenEnd > len)
    7e3a:	4613      	mov	r3, r2
    7e3c:	454a      	cmp	r2, r9
    7e3e:	bf28      	it	cs
    7e40:	464b      	movcs	r3, r9
                    if(lenStart)
    7e42:	ebb9 0203 	subs.w	r2, r9, r3
    7e46:	d02c      	beq.n	7ea2 <_TcpSend+0x27e>
    switch(pSkt->addType)
    7e48:	f894 c06f 	ldrb.w	ip, [r4, #111]	; 0x6f
    7e4c:	f1bc 0f01 	cmp.w	ip, #1
    7e50:	d00a      	beq.n	7e68 <_TcpSend+0x244>
                    pSkt->txUnackedTail += len;
    7e52:	6923      	ldr	r3, [r4, #16]
    7e54:	444b      	add	r3, r9
    7e56:	6123      	str	r3, [r4, #16]
                    if(pSkt->txUnackedTail >= pSkt->txEnd)
    7e58:	6862      	ldr	r2, [r4, #4]
    7e5a:	4293      	cmp	r3, r2
    7e5c:	d3a7      	bcc.n	7dae <_TcpSend+0x18a>
                        pSkt->txUnackedTail -= pSkt->txEnd-pSkt->txStart;
    7e5e:	6821      	ldr	r1, [r4, #0]
    7e60:	1a52      	subs	r2, r2, r1
    7e62:	1a9b      	subs	r3, r3, r2
    7e64:	6123      	str	r3, [r4, #16]
    7e66:	e7a2      	b.n	7dae <_TcpSend+0x18a>
    if(pBuff2)
    7e68:	b1a0      	cbz	r0, 7e94 <_TcpSend+0x270>
                        _TCP_PayloadSet(pSkt, pSendPkt, pSkt->txUnackedTail, lenEnd, pSkt->txStart, lenStart);
    7e6a:	b292      	uxth	r2, r2
        pSeg1->segLen = pSeg1->segSize = bSize2;
    7e6c:	f8a6 206a 	strh.w	r2, [r6, #106]	; 0x6a
    7e70:	f8a6 2068 	strh.w	r2, [r6, #104]	; 0x68
        pSeg1->segLoad = pBuff2;
    7e74:	6670      	str	r0, [r6, #100]	; 0x64
    TCPIP_MAC_DATA_SEGMENT* pSeg1 = pTcpPkt->tcpSeg + 1;
    7e76:	f106 025c 	add.w	r2, r6, #92	; 0x5c
        pSeg0->next = pSeg1;
    7e7a:	6472      	str	r2, [r6, #68]	; 0x44
    if(pBuff1)
    7e7c:	b169      	cbz	r1, 7e9a <_TcpSend+0x276>
                        _TCP_PayloadSet(pSkt, pSendPkt, pSkt->txUnackedTail, lenEnd, pSkt->txStart, lenStart);
    7e7e:	b29b      	uxth	r3, r3
        pSeg0->segLen = pSeg0->segSize = bSize1;
    7e80:	f8a6 3052 	strh.w	r3, [r6, #82]	; 0x52
    7e84:	f8a6 3050 	strh.w	r3, [r6, #80]	; 0x50
        pSeg0->segLoad = pBuff1;
    7e88:	64f1      	str	r1, [r6, #76]	; 0x4c
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = pSeg0;  // link to the 1st data seg to be transmitted
    7e8a:	6933      	ldr	r3, [r6, #16]
    TCPIP_MAC_DATA_SEGMENT* pSeg0 = pTcpPkt->tcpSeg + 0;
    7e8c:	f106 0244 	add.w	r2, r6, #68	; 0x44
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = pSeg0;  // link to the 1st data seg to be transmitted
    7e90:	601a      	str	r2, [r3, #0]
    7e92:	e7de      	b.n	7e52 <_TcpSend+0x22e>
        pSeg0->next = 0;
    7e94:	2200      	movs	r2, #0
    7e96:	6472      	str	r2, [r6, #68]	; 0x44
    7e98:	e7f0      	b.n	7e7c <_TcpSend+0x258>
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = 0;  // link to the 1st data seg to be transmitted
    7e9a:	6933      	ldr	r3, [r6, #16]
    7e9c:	2200      	movs	r2, #0
    7e9e:	601a      	str	r2, [r3, #0]
    7ea0:	e7d7      	b.n	7e52 <_TcpSend+0x22e>
    switch(pSkt->addType)
    7ea2:	f894 206f 	ldrb.w	r2, [r4, #111]	; 0x6f
    7ea6:	2a01      	cmp	r2, #1
    7ea8:	d1d3      	bne.n	7e52 <_TcpSend+0x22e>
        pSeg0->next = 0;
    7eaa:	2200      	movs	r2, #0
    7eac:	6472      	str	r2, [r6, #68]	; 0x44
    if(pBuff1)
    7eae:	b151      	cbz	r1, 7ec6 <_TcpSend+0x2a2>
                        _TCP_PayloadSet(pSkt, pSendPkt, pSkt->txUnackedTail, lenEnd, 0, 0);
    7eb0:	b29b      	uxth	r3, r3
        pSeg0->segLen = pSeg0->segSize = bSize1;
    7eb2:	f8a6 3052 	strh.w	r3, [r6, #82]	; 0x52
    7eb6:	f8a6 3050 	strh.w	r3, [r6, #80]	; 0x50
        pSeg0->segLoad = pBuff1;
    7eba:	64f1      	str	r1, [r6, #76]	; 0x4c
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = pSeg0;  // link to the 1st data seg to be transmitted
    7ebc:	6933      	ldr	r3, [r6, #16]
    TCPIP_MAC_DATA_SEGMENT* pSeg0 = pTcpPkt->tcpSeg + 0;
    7ebe:	f106 0244 	add.w	r2, r6, #68	; 0x44
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = pSeg0;  // link to the 1st data seg to be transmitted
    7ec2:	601a      	str	r2, [r3, #0]
    7ec4:	e7c5      	b.n	7e52 <_TcpSend+0x22e>
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = 0;  // link to the 1st data seg to be transmitted
    7ec6:	6933      	ldr	r3, [r6, #16]
    7ec8:	2200      	movs	r2, #0
    7eca:	601a      	str	r2, [r3, #0]
    7ecc:	e7c1      	b.n	7e52 <_TcpSend+0x22e>
    loadLen = (uint16_t)len;  // save the TCP payload size
    7ece:	f04f 0800 	mov.w	r8, #0
        if(len || (vTCPFlags & (SYN | FIN)))
    7ed2:	f017 0f03 	tst.w	r7, #3
    7ed6:	d046      	beq.n	7f66 <_TcpSend+0x342>
    7ed8:	f04f 0900 	mov.w	r9, #0
            if(vSendFlags & SENDTCP_RESET_TIMERS)
    7edc:	f01a 0f01 	tst.w	sl, #1
    7ee0:	d132      	bne.n	7f48 <_TcpSend+0x324>
            pSkt->eventTime = SYS_TMR_TickCountGet() + pSkt->retryInterval;
    7ee2:	f018 f903 	bl	200ec <SYS_TMR_TickCountGet>
    7ee6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    7ee8:	4418      	add	r0, r3
    7eea:	6260      	str	r0, [r4, #36]	; 0x24
            pSkt->Flags.bTimerEnabled = 1;
    7eec:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    7ef0:	f043 0302 	orr.w	r3, r3, #2
    7ef4:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
        header->SourcePort			= pSkt->localPort;
    7ef8:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
    7efc:	802b      	strh	r3, [r5, #0]
        header->DestPort			= pSkt->remotePort;
    7efe:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
    7f02:	806b      	strh	r3, [r5, #2]
        header->SeqNumber			= pSkt->MySEQ;
    7f04:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    7f06:	606b      	str	r3, [r5, #4]
        header->AckNumber			= pSkt->RemoteSEQ;
    7f08:	6d23      	ldr	r3, [r4, #80]	; 0x50
    7f0a:	60ab      	str	r3, [r5, #8]
        header->DataOffset.Reserved3	= 0;
    7f0c:	7b2b      	ldrb	r3, [r5, #12]
    7f0e:	f36f 0303 	bfc	r3, #0, #4
    7f12:	732b      	strb	r3, [r5, #12]
        header->Flags.byte			= vTCPFlags;
    7f14:	736f      	strb	r7, [r5, #13]
        header->UrgentPointer       = 0;
    7f16:	2300      	movs	r3, #0
    7f18:	826b      	strh	r3, [r5, #18]
        header->Checksum            = 0;
    7f1a:	822b      	strh	r3, [r5, #16]
        pSkt->MySEQ += (uint32_t)len;
    7f1c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    7f1e:	444b      	add	r3, r9
    7f20:	64e3      	str	r3, [r4, #76]	; 0x4c
        if(vTCPFlags & SYN)
    7f22:	f017 0f02 	tst.w	r7, #2
    7f26:	d054      	beq.n	7fd2 <_TcpSend+0x3ae>
            if(!(vTCPFlags & ACK))
    7f28:	f017 0f10 	tst.w	r7, #16
                header->AckNumber = 0;
    7f2c:	bf04      	itt	eq
    7f2e:	2300      	moveq	r3, #0
    7f30:	60ab      	streq	r3, [r5, #8]
            if(pSkt->flags.bSYNSent)
    7f32:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
    7f36:	f013 0f08 	tst.w	r3, #8
    7f3a:	d03e      	beq.n	7fba <_TcpSend+0x396>
                header->SeqNumber--;
    7f3c:	686b      	ldr	r3, [r5, #4]
    7f3e:	3b01      	subs	r3, #1
    7f40:	606b      	str	r3, [r5, #4]
            hdrLen = sizeof(options);
    7f42:	f04f 0904 	mov.w	r9, #4
    7f46:	e046      	b.n	7fd6 <_TcpSend+0x3b2>
                pSkt->retryCount = 0;
    7f48:	2300      	movs	r3, #0
    7f4a:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
                pSkt->retryInterval = (TCPIP_TCP_START_TIMEOUT_VAL * SYS_TMR_TickCounterFrequencyGet())/1000;
    7f4e:	f018 f8f5 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
    7f52:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    7f56:	fb03 f300 	mul.w	r3, r3, r0
    7f5a:	489c      	ldr	r0, [pc, #624]	; (81cc <_TcpSend+0x5a8>)
    7f5c:	fba0 2303 	umull	r2, r3, r0, r3
    7f60:	099b      	lsrs	r3, r3, #6
    7f62:	64a3      	str	r3, [r4, #72]	; 0x48
    7f64:	e7bd      	b.n	7ee2 <_TcpSend+0x2be>
        else if(vSendFlags & SENDTCP_KEEP_ALIVE)
    7f66:	f01a 0f02 	tst.w	sl, #2
    7f6a:	d00a      	beq.n	7f82 <_TcpSend+0x35e>
            pSkt->keepAliveCount++;
    7f6c:	f894 3071 	ldrb.w	r3, [r4, #113]	; 0x71
    7f70:	3301      	adds	r3, #1
    7f72:	f884 3071 	strb.w	r3, [r4, #113]	; 0x71
            pSkt->MySEQ -= 1;
    7f76:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    7f78:	3b01      	subs	r3, #1
    7f7a:	64e3      	str	r3, [r4, #76]	; 0x4c
            len = 1;
    7f7c:	f04f 0901 	mov.w	r9, #1
    7f80:	e7ba      	b.n	7ef8 <_TcpSend+0x2d4>
        else if(pSkt->Flags.bTimerEnabled) 
    7f82:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    7f86:	f013 0f02 	tst.w	r3, #2
    7f8a:	d013      	beq.n	7fb4 <_TcpSend+0x390>
            if(!(vSendFlags & SENDTCP_RESET_TIMERS))
    7f8c:	f01a 0f01 	tst.w	sl, #1
    7f90:	d108      	bne.n	7fa4 <_TcpSend+0x380>
                if(pSkt->retryCount)
    7f92:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    7f96:	b12b      	cbz	r3, 7fa4 <_TcpSend+0x380>
                    pSkt->retryCount--;
    7f98:	3b01      	subs	r3, #1
    7f9a:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
                    pSkt->retryInterval >>= 1;
    7f9e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    7fa0:	085b      	lsrs	r3, r3, #1
    7fa2:	64a3      	str	r3, [r4, #72]	; 0x48
            pSkt->eventTime = SYS_TMR_TickCountGet() + pSkt->retryInterval;
    7fa4:	f018 f8a2 	bl	200ec <SYS_TMR_TickCountGet>
    7fa8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    7faa:	4418      	add	r0, r3
    7fac:	6260      	str	r0, [r4, #36]	; 0x24
    7fae:	f04f 0900 	mov.w	r9, #0
    7fb2:	e7a1      	b.n	7ef8 <_TcpSend+0x2d4>
    7fb4:	f04f 0900 	mov.w	r9, #0
    7fb8:	e79e      	b.n	7ef8 <_TcpSend+0x2d4>
                pSkt->MySEQ++;
    7fba:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    7fbc:	3301      	adds	r3, #1
    7fbe:	64e3      	str	r3, [r4, #76]	; 0x4c
                pSkt->flags.bSYNSent = 1;
    7fc0:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
    7fc4:	f043 0308 	orr.w	r3, r3, #8
    7fc8:	f884 306c 	strb.w	r3, [r4, #108]	; 0x6c
            hdrLen = sizeof(options);
    7fcc:	f04f 0904 	mov.w	r9, #4
    7fd0:	e001      	b.n	7fd6 <_TcpSend+0x3b2>
            hdrLen = 0;
    7fd2:	f04f 0900 	mov.w	r9, #0
        if(vTCPFlags & FIN)
    7fd6:	f017 0f01 	tst.w	r7, #1
    7fda:	d005      	beq.n	7fe8 <_TcpSend+0x3c4>
            pSkt->flags.bFINSent = 1;   // do not advance the seq no for FIN!
    7fdc:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
    7fe0:	f043 0304 	orr.w	r3, r3, #4
    7fe4:	f884 306c 	strb.w	r3, [r4, #108]	; 0x6c
        if(vTCPFlags & ACK)
    7fe8:	f017 0f10 	tst.w	r7, #16
    7fec:	d005      	beq.n	7ffa <_TcpSend+0x3d6>
            pSkt->flags.ackSent = 1;   // store the ACK already sent
    7fee:	f894 306d 	ldrb.w	r3, [r4, #109]	; 0x6d
    7ff2:	f043 0301 	orr.w	r3, r3, #1
    7ff6:	f884 306d 	strb.w	r3, [r4, #109]	; 0x6d
        if(pSkt->rxHead >= pSkt->rxTail)
    7ffa:	69e3      	ldr	r3, [r4, #28]
    7ffc:	6a22      	ldr	r2, [r4, #32]
    7ffe:	4293      	cmp	r3, r2
    8000:	d31b      	bcc.n	803a <_TcpSend+0x416>
            header->Window = (pSkt->rxEnd - pSkt->rxStart) - (pSkt->rxHead - pSkt->rxTail);
    8002:	69a1      	ldr	r1, [r4, #24]
    8004:	6960      	ldr	r0, [r4, #20]
    8006:	1a09      	subs	r1, r1, r0
    8008:	1a9b      	subs	r3, r3, r2
    800a:	1acb      	subs	r3, r1, r3
    800c:	b29b      	uxth	r3, r3
    800e:	81eb      	strh	r3, [r5, #14]
        pSkt->localWindow = header->Window; // store the last advertised window
    8010:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
        _TcpSwapHeader(header);
    8014:	4628      	mov	r0, r5
    8016:	f012 fe4d 	bl	1acb4 <_TcpSwapHeader>
        header->DataOffset.Val   += sizeof(TCP_HEADER) >> 2;
    801a:	7b2b      	ldrb	r3, [r5, #12]
    801c:	f3c3 1203 	ubfx	r2, r3, #4, #4
    8020:	3205      	adds	r2, #5
    8022:	f362 1307 	bfi	r3, r2, #4, #4
    8026:	732b      	strb	r3, [r5, #12]
}


static bool _TCP_Flush(TCB_STUB * pSkt, void* pPkt, uint16_t hdrLen, uint16_t loadLen)
{
    switch(pSkt->addType)
    8028:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    802c:	2b01      	cmp	r3, #1
    802e:	d008      	beq.n	8042 <_TcpSend+0x41e>
        sendRes = _TCP_Flush (pSkt, pSendPkt, hdrLen, loadLen) ? _TCP_SEND_OK : _TCP_SEND_IP_FAIL;
    8030:	f04f 30ff 	mov.w	r0, #4294967295
}
    8034:	b007      	add	sp, #28
    8036:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            header->Window = pSkt->rxTail - pSkt->rxHead - 1;
    803a:	1ad3      	subs	r3, r2, r3
    803c:	3b01      	subs	r3, #1
    803e:	b29b      	uxth	r3, r3
    8040:	e7e5      	b.n	800e <_TcpSend+0x3ea>
    if(pSkt->destAddress.Val == 0)
    8042:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    8044:	b913      	cbnz	r3, 804c <_TcpSend+0x428>
        sendRes = _TCP_Flush (pSkt, pSendPkt, hdrLen, loadLen) ? _TCP_SEND_OK : _TCP_SEND_IP_FAIL;
    8046:	f04f 30ff 	mov.w	r0, #4294967295
    804a:	e675      	b.n	7d38 <_TcpSend+0x114>
    if(!_TcpSocketSetSourceInterface(pSkt))
    804c:	4620      	mov	r0, r4
    804e:	f015 fbee 	bl	1d82e <_TcpSocketSetSourceInterface>
    8052:	2800      	cmp	r0, #0
    8054:	d0f7      	beq.n	8046 <_TcpSend+0x422>
        hdrLen += sizeof(TCP_HEADER);
    8056:	f109 0914 	add.w	r9, r9, #20
    pv4Pkt->srcAddress.Val = pSkt->srcAddress.Val;
    805a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    805c:	6373      	str	r3, [r6, #52]	; 0x34
    pv4Pkt->destAddress.Val = pSkt->destAddress.Val;
    805e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    8060:	63b3      	str	r3, [r6, #56]	; 0x38
    pv4Pkt->netIfH = pSkt->pSktNet;
    8062:	6c23      	ldr	r3, [r4, #64]	; 0x40
    8064:	63f3      	str	r3, [r6, #60]	; 0x3c
    pv4Pkt->macPkt.pDSeg->segLen += hdrLen;
    8066:	6932      	ldr	r2, [r6, #16]
    8068:	8993      	ldrh	r3, [r2, #12]
    806a:	444b      	add	r3, r9
    806c:	8193      	strh	r3, [r2, #12]
    pseudoHdr.SourceAddress.Val = pv4Pkt->srcAddress.Val;
    806e:	6b73      	ldr	r3, [r6, #52]	; 0x34
    8070:	9302      	str	r3, [sp, #8]
    pseudoHdr.DestAddress.Val = pv4Pkt->destAddress.Val;
    8072:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    8074:	9303      	str	r3, [sp, #12]
    pseudoHdr.Zero = 0;
    8076:	2200      	movs	r2, #0
    8078:	f88d 2010 	strb.w	r2, [sp, #16]
    pseudoHdr.Protocol = IP_PROT_TCP;
    807c:	2306      	movs	r3, #6
    807e:	f88d 3011 	strb.w	r3, [sp, #17]
    pseudoHdr.Length = TCPIP_Helper_htons(hdrLen + loadLen);
    8082:	eb09 0508 	add.w	r5, r9, r8
    8086:	b2ad      	uxth	r5, r5
    8088:	0a2b      	lsrs	r3, r5, #8
    808a:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    808e:	f8ad 3012 	strh.w	r3, [sp, #18]
    checksum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)&pseudoHdr, sizeof(pseudoHdr), 0);
    8092:	210c      	movs	r1, #12
    8094:	a802      	add	r0, sp, #8
    8096:	f012 faa9 	bl	1a5ec <TCPIP_Helper_CalcIPChecksum>
    pTCPHdr = (TCP_HEADER*)pv4Pkt->macPkt.pTransportLayer;
    809a:	f8d6 a01c 	ldr.w	sl, [r6, #28]
    checksum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)&pseudoHdr, sizeof(pseudoHdr), 0);
    809e:	43c2      	mvns	r2, r0
    checksum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)pTCPHdr, hdrLen, checksum);
    80a0:	b292      	uxth	r2, r2
    80a2:	4649      	mov	r1, r9
    80a4:	4650      	mov	r0, sl
    80a6:	f012 faa1 	bl	1a5ec <TCPIP_Helper_CalcIPChecksum>
    80aa:	43c3      	mvns	r3, r0
    80ac:	b29b      	uxth	r3, r3
    if(loadLen)
    80ae:	f1b8 0f00 	cmp.w	r8, #0
    80b2:	d125      	bne.n	8100 <_TcpSend+0x4dc>
        pv4Pkt->macPkt.pDSeg->segFlags &= ~TCPIP_MAC_SEG_FLAG_USER_PAYLOAD;
    80b4:	6931      	ldr	r1, [r6, #16]
    80b6:	8a0a      	ldrh	r2, [r1, #16]
    80b8:	f022 0208 	bic.w	r2, r2, #8
    80bc:	820a      	strh	r2, [r1, #16]
    pTCPHdr->Checksum = ~checksum;
    80be:	43db      	mvns	r3, r3
    80c0:	f8aa 3010 	strh.w	r3, [sl, #16]
    pktParams.ttl = pSkt->ttl;
    80c4:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
    80c8:	f88d 3005 	strb.w	r3, [sp, #5]
    pktParams.tosFlags = pSkt->tos;
    80cc:	f894 307f 	ldrb.w	r3, [r4, #127]	; 0x7f
    80d0:	f88d 3004 	strb.w	r3, [sp, #4]
    pktParams.df = 0;
    80d4:	f04f 0800 	mov.w	r8, #0
    80d8:	f88d 8006 	strb.w	r8, [sp, #6]
    TCPIP_IPV4_PacketFormatTx(pv4Pkt, IP_PROT_TCP, hdrLen + loadLen, &pktParams);
    80dc:	ab01      	add	r3, sp, #4
    80de:	462a      	mov	r2, r5
    80e0:	2106      	movs	r1, #6
    80e2:	4630      	mov	r0, r6
    80e4:	f00b f95c 	bl	133a0 <TCPIP_IPV4_PacketFormatTx>
    pv4Pkt->macPkt.next = 0;    // single packet
    80e8:	f8c6 8000 	str.w	r8, [r6]
    if(TCPIP_IPV4_PacketTransmit(pv4Pkt))
    80ec:	4630      	mov	r0, r6
    80ee:	f019 ff6d 	bl	21fcc <TCPIP_IPV4_PacketTransmit>
    if(sendRes != _TCP_SEND_OK && pSkt->addType == IP_ADDRESS_TYPE_IPV4)
    80f2:	2800      	cmp	r0, #0
    80f4:	d0a7      	beq.n	8046 <_TcpSend+0x422>
    if(sendRes == _TCP_SEND_OK && (vTCPFlags & RST) != 0 )
    80f6:	f017 0f04 	tst.w	r7, #4
    80fa:	d10e      	bne.n	811a <_TcpSend+0x4f6>
    80fc:	2000      	movs	r0, #0
    80fe:	e799      	b.n	8034 <_TcpSend+0x410>
        pv4Pkt->macPkt.pDSeg->segFlags |= TCPIP_MAC_SEG_FLAG_USER_PAYLOAD;
    8100:	6931      	ldr	r1, [r6, #16]
    8102:	8a0a      	ldrh	r2, [r1, #16]
    8104:	f042 0208 	orr.w	r2, r2, #8
    8108:	820a      	strh	r2, [r1, #16]
        checksum = ~TCPIP_Helper_PacketChecksum(&pv4Pkt->macPkt, ((TCP_V4_PACKET*)pv4Pkt)->tcpSeg[0].segLoad, loadLen, checksum);
    810a:	4642      	mov	r2, r8
    810c:	6cf1      	ldr	r1, [r6, #76]	; 0x4c
    810e:	4630      	mov	r0, r6
    8110:	f011 f884 	bl	1921c <TCPIP_Helper_PacketChecksum>
    8114:	43c3      	mvns	r3, r0
    8116:	b29b      	uxth	r3, r3
    8118:	e7d1      	b.n	80be <_TcpSend+0x49a>
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    811a:	2000      	movs	r0, #0
    811c:	f019 fa4e 	bl	215bc <OSAL_CRIT_Enter>
    *pSigHandler = pSkt->sigHandler;
    8120:	6f65      	ldr	r5, [r4, #116]	; 0x74
    *pSigParam = pSkt->sigParam;
    8122:	6fa7      	ldr	r7, [r4, #120]	; 0x78
    uint16_t sigMask = pSkt->sigMask;
    8124:	f8b4 6072 	ldrh.w	r6, [r4, #114]	; 0x72
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
    8128:	4601      	mov	r1, r0
    812a:	2000      	movs	r0, #0
    812c:	f019 fb75 	bl	2181a <OSAL_CRIT_Leave>
        if(sigHandler != 0 && (sigMask & TCPIP_TCP_SIGNAL_TX_RST) != 0)
    8130:	b185      	cbz	r5, 8154 <_TcpSend+0x530>
    8132:	f016 0f08 	tst.w	r6, #8
    8136:	d00f      	beq.n	8158 <_TcpSend+0x534>
            (*sigHandler)(pSkt->sktIx, pSkt->pSktNet, TCPIP_TCP_SIGNAL_TX_RST, sigParam);
    8138:	463b      	mov	r3, r7
    813a:	2208      	movs	r2, #8
    813c:	6c21      	ldr	r1, [r4, #64]	; 0x40
    813e:	f9b4 0034 	ldrsh.w	r0, [r4, #52]	; 0x34
    8142:	47a8      	blx	r5
    8144:	2000      	movs	r0, #0
    8146:	e775      	b.n	8034 <_TcpSend+0x410>
            return _TCP_SEND_NO_PKT; 
    8148:	f06f 0001 	mvn.w	r0, #1
}
    814c:	4770      	bx	lr
        return _TCP_SEND_NO_MEMORY;
    814e:	f06f 0002 	mvn.w	r0, #2
    8152:	e76f      	b.n	8034 <_TcpSend+0x410>
    8154:	2000      	movs	r0, #0
    8156:	e76d      	b.n	8034 <_TcpSend+0x410>
    8158:	2000      	movs	r0, #0
    815a:	e76b      	b.n	8034 <_TcpSend+0x410>
            if(pSkt->Flags.bTXFIN)
    815c:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
    8160:	f013 0f01 	tst.w	r3, #1
    8164:	d128      	bne.n	81b8 <_TcpSend+0x594>
    loadLen = (uint16_t)len;  // save the TCP payload size
    8166:	f04f 0800 	mov.w	r8, #0
    816a:	e6b2      	b.n	7ed2 <_TcpSend+0x2ae>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
    816c:	4601      	mov	r1, r0
    816e:	2000      	movs	r0, #0
    8170:	f019 fb53 	bl	2181a <OSAL_CRIT_Leave>
    pv4Pkt = (TCP_V4_PACKET*)TCPIP_PKT_SocketAlloc(sizeof(TCP_V4_PACKET), sizeof(TCP_HEADER), sizeof(TCP_OPTIONS), allocFlags);
    8174:	f242 0306 	movw	r3, #8198	; 0x2006
    8178:	2204      	movs	r2, #4
    817a:	2114      	movs	r1, #20
    817c:	2074      	movs	r0, #116	; 0x74
    817e:	f017 fbfb 	bl	1f978 <_TCPIP_PKT_SocketAlloc>
    if(pv4Pkt)
    8182:	4606      	mov	r6, r0
    8184:	2800      	cmp	r0, #0
    8186:	d0e2      	beq.n	814e <_TcpSend+0x52a>
// will be automatically freed by this function.
void            TCPIP_PKT_PacketFree(TCPIP_MAC_PACKET* pPkt);

static __inline__ void __attribute__((always_inline)) TCPIP_PKT_PacketAcknowledgeSet(TCPIP_MAC_PACKET* pPkt, TCPIP_MAC_PACKET_ACK_FUNC ackFunc, const void* ackParam)
{
    pPkt->ackFunc = ackFunc;
    8188:	4b11      	ldr	r3, [pc, #68]	; (81d0 <_TcpSend+0x5ac>)
    818a:	6083      	str	r3, [r0, #8]
    pPkt->ackParam = ackParam;
    818c:	60c4      	str	r4, [r0, #12]
        pv4Pkt->tcpSeg[0].segFlags = pv4Pkt->tcpSeg[1].segFlags = TCPIP_MAC_SEG_FLAG_STATIC; // embedded in packet itself
    818e:	2301      	movs	r3, #1
    8190:	f8a0 306c 	strh.w	r3, [r0, #108]	; 0x6c
    8194:	f8a0 3054 	strh.w	r3, [r0, #84]	; 0x54
            pPkt->v4Pkt.macPkt.pktFlags |= TCPIP_MAC_PKT_FLAG_QUEUED;
    8198:	8c43      	ldrh	r3, [r0, #34]	; 0x22
    819a:	f043 0308 	orr.w	r3, r3, #8
    819e:	8443      	strh	r3, [r0, #34]	; 0x22
            OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    81a0:	2000      	movs	r0, #0
    81a2:	f019 fa0b 	bl	215bc <OSAL_CRIT_Enter>
            if(pSkt->pV4Pkt == 0)
    81a6:	6c63      	ldr	r3, [r4, #68]	; 0x44
    81a8:	2b00      	cmp	r3, #0
    81aa:	f43f adb4 	beq.w	7d16 <_TcpSend+0xf2>
            OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
    81ae:	4601      	mov	r1, r0
    81b0:	2000      	movs	r0, #0
    81b2:	f019 fb32 	bl	2181a <OSAL_CRIT_Leave>
    81b6:	e566      	b.n	7c86 <_TcpSend+0x62>
                if((len != pSkt->remoteWindow) && (len != maxPayload))
    81b8:	f8b4 805c 	ldrh.w	r8, [r4, #92]	; 0x5c
    81bc:	f1b8 0f00 	cmp.w	r8, #0
    81c0:	f43f ae87 	beq.w	7ed2 <_TcpSend+0x2ae>
                len = 0;
    81c4:	f04f 0900 	mov.w	r9, #0
    81c8:	e5fa      	b.n	7dc0 <_TcpSend+0x19c>
    81ca:	bf00      	nop
    81cc:	10624dd3 	.word	0x10624dd3
    81d0:	00013c69 	.word	0x00013c69

Disassembly of section .text._printf_float%192:

000081d4 <_printf_float>:
    81d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    81d8:	b08d      	sub	sp, #52	; 0x34
    81da:	460c      	mov	r4, r1
    81dc:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
    81e0:	4693      	mov	fp, r2
    81e2:	461f      	mov	r7, r3
    81e4:	4606      	mov	r6, r0
    81e6:	f01a f80f 	bl	22208 <_localeconv_r>
    81ea:	6803      	ldr	r3, [r0, #0]
    81ec:	9305      	str	r3, [sp, #20]
    81ee:	4618      	mov	r0, r3
    81f0:	f019 fd5c 	bl	21cac <strlen>
    81f4:	f8d8 3000 	ldr.w	r3, [r8]
    81f8:	9006      	str	r0, [sp, #24]
    81fa:	3307      	adds	r3, #7
    81fc:	f023 0307 	bic.w	r3, r3, #7
    8200:	f103 0208 	add.w	r2, r3, #8
    8204:	f894 a018 	ldrb.w	sl, [r4, #24]
    8208:	6825      	ldr	r5, [r4, #0]
    820a:	f8c8 2000 	str.w	r2, [r8]
    820e:	e9d3 2300 	ldrd	r2, r3, [r3]
    8212:	e9c4 2312 	strd	r2, r3, [r4, #72]	; 0x48
    8216:	ed94 7b12 	vldr	d7, [r4, #72]	; 0x48
    821a:	ed8d 7b02 	vstr	d7, [sp, #8]
    821e:	e9dd 8302 	ldrd	r8, r3, [sp, #8]
    8222:	f023 4900 	bic.w	r9, r3, #2147483648	; 0x80000000
    8226:	f04f 32ff 	mov.w	r2, #4294967295
    822a:	4ba2      	ldr	r3, [pc, #648]	; (84b4 <_printf_float+0x2e0>)
    822c:	4640      	mov	r0, r8
    822e:	4649      	mov	r1, r9
    8230:	f017 fcc0 	bl	1fbb4 <__aeabi_dcmpun>
    8234:	bb70      	cbnz	r0, 8294 <_printf_float+0xc0>
    8236:	f04f 32ff 	mov.w	r2, #4294967295
    823a:	4b9e      	ldr	r3, [pc, #632]	; (84b4 <_printf_float+0x2e0>)
    823c:	4640      	mov	r0, r8
    823e:	4649      	mov	r1, r9
    8240:	f00b fcf4 	bl	13c2c <__aeabi_dcmple>
    8244:	bb30      	cbnz	r0, 8294 <_printf_float+0xc0>
    8246:	2200      	movs	r2, #0
    8248:	2300      	movs	r3, #0
    824a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    824e:	f00b fce3 	bl	13c18 <__aeabi_dcmplt>
    8252:	b110      	cbz	r0, 825a <_printf_float+0x86>
    8254:	232d      	movs	r3, #45	; 0x2d
    8256:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    825a:	4b97      	ldr	r3, [pc, #604]	; (84b8 <_printf_float+0x2e4>)
    825c:	1d1a      	adds	r2, r3, #4
    825e:	f025 0504 	bic.w	r5, r5, #4
    8262:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
    8266:	bf94      	ite	ls
    8268:	4699      	movls	r9, r3
    826a:	4691      	movhi	r9, r2
    826c:	6025      	str	r5, [r4, #0]
    826e:	2303      	movs	r3, #3
    8270:	2500      	movs	r5, #0
    8272:	6123      	str	r3, [r4, #16]
    8274:	46a8      	mov	r8, r5
    8276:	9700      	str	r7, [sp, #0]
    8278:	465b      	mov	r3, fp
    827a:	aa0a      	add	r2, sp, #40	; 0x28
    827c:	4621      	mov	r1, r4
    827e:	4630      	mov	r0, r6
    8280:	f00c fe42 	bl	14f08 <_printf_common>
    8284:	3001      	adds	r0, #1
    8286:	f040 8109 	bne.w	849c <_printf_float+0x2c8>
    828a:	f04f 30ff 	mov.w	r0, #4294967295
    828e:	b00d      	add	sp, #52	; 0x34
    8290:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8294:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    8298:	4610      	mov	r0, r2
    829a:	4619      	mov	r1, r3
    829c:	f017 fc8a 	bl	1fbb4 <__aeabi_dcmpun>
    82a0:	b138      	cbz	r0, 82b2 <_printf_float+0xde>
    82a2:	9b03      	ldr	r3, [sp, #12]
    82a4:	2b00      	cmp	r3, #0
    82a6:	bfbc      	itt	lt
    82a8:	232d      	movlt	r3, #45	; 0x2d
    82aa:	f884 3043 	strblt.w	r3, [r4, #67]	; 0x43
    82ae:	4b83      	ldr	r3, [pc, #524]	; (84bc <_printf_float+0x2e8>)
    82b0:	e7d4      	b.n	825c <_printf_float+0x88>
    82b2:	6863      	ldr	r3, [r4, #4]
    82b4:	1c59      	adds	r1, r3, #1
    82b6:	f00a 08df 	and.w	r8, sl, #223	; 0xdf
    82ba:	d11c      	bne.n	82f6 <_printf_float+0x122>
    82bc:	2306      	movs	r3, #6
    82be:	6063      	str	r3, [r4, #4]
    82c0:	f445 6380 	orr.w	r3, r5, #1024	; 0x400
    82c4:	6023      	str	r3, [r4, #0]
    82c6:	6863      	ldr	r3, [r4, #4]
    82c8:	9304      	str	r3, [sp, #16]
    82ca:	9b03      	ldr	r3, [sp, #12]
    82cc:	2b00      	cmp	r3, #0
    82ce:	da19      	bge.n	8304 <_printf_float+0x130>
    82d0:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
    82d4:	f081 4300 	eor.w	r3, r1, #2147483648	; 0x80000000
    82d8:	e9cd 2302 	strd	r2, r3, [sp, #8]
    82dc:	232d      	movs	r3, #45	; 0x2d
    82de:	f1b8 0f46 	cmp.w	r8, #70	; 0x46
    82e2:	9307      	str	r3, [sp, #28]
    82e4:	d010      	beq.n	8308 <_printf_float+0x134>
    82e6:	f1b8 0f45 	cmp.w	r8, #69	; 0x45
    82ea:	d102      	bne.n	82f2 <_printf_float+0x11e>
    82ec:	9b04      	ldr	r3, [sp, #16]
    82ee:	3301      	adds	r3, #1
    82f0:	9304      	str	r3, [sp, #16]
    82f2:	2102      	movs	r1, #2
    82f4:	e009      	b.n	830a <_printf_float+0x136>
    82f6:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
    82fa:	d1e1      	bne.n	82c0 <_printf_float+0xec>
    82fc:	2b00      	cmp	r3, #0
    82fe:	d1df      	bne.n	82c0 <_printf_float+0xec>
    8300:	2301      	movs	r3, #1
    8302:	e7dc      	b.n	82be <_printf_float+0xea>
    8304:	2300      	movs	r3, #0
    8306:	e7ea      	b.n	82de <_printf_float+0x10a>
    8308:	2103      	movs	r1, #3
    830a:	ab0a      	add	r3, sp, #40	; 0x28
    830c:	9301      	str	r3, [sp, #4]
    830e:	ab09      	add	r3, sp, #36	; 0x24
    8310:	9300      	str	r3, [sp, #0]
    8312:	9a04      	ldr	r2, [sp, #16]
    8314:	ab08      	add	r3, sp, #32
    8316:	ed9d 0b02 	vldr	d0, [sp, #8]
    831a:	4630      	mov	r0, r6
    831c:	f7fc fc94 	bl	4c48 <_dtoa_r>
    8320:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
    8324:	4681      	mov	r9, r0
    8326:	d150      	bne.n	83ca <_printf_float+0x1f6>
    8328:	07ea      	lsls	r2, r5, #31
    832a:	d44e      	bmi.n	83ca <_printf_float+0x1f6>
    832c:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    832e:	9a08      	ldr	r2, [sp, #32]
    8330:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
    8334:	eba5 0509 	sub.w	r5, r5, r9
    8338:	d171      	bne.n	841e <_printf_float+0x24a>
    833a:	1cd3      	adds	r3, r2, #3
    833c:	db03      	blt.n	8346 <_printf_float+0x172>
    833e:	6863      	ldr	r3, [r4, #4]
    8340:	4293      	cmp	r3, r2
    8342:	f280 809a 	bge.w	847a <_printf_float+0x2a6>
    8346:	f1aa 0a02 	sub.w	sl, sl, #2
    834a:	fa5f fa8a 	uxtb.w	sl, sl
    834e:	1e53      	subs	r3, r2, #1
    8350:	2b00      	cmp	r3, #0
    8352:	9308      	str	r3, [sp, #32]
    8354:	bfb6      	itet	lt
    8356:	f1c2 0301 	rsblt	r3, r2, #1
    835a:	222b      	movge	r2, #43	; 0x2b
    835c:	222d      	movlt	r2, #45	; 0x2d
    835e:	2b09      	cmp	r3, #9
    8360:	f104 0850 	add.w	r8, r4, #80	; 0x50
    8364:	f884 a050 	strb.w	sl, [r4, #80]	; 0x50
    8368:	f884 2051 	strb.w	r2, [r4, #81]	; 0x51
    836c:	dd74      	ble.n	8458 <_printf_float+0x284>
    836e:	f10d 022f 	add.w	r2, sp, #47	; 0x2f
    8372:	f04f 0e0a 	mov.w	lr, #10
    8376:	fb93 f1fe 	sdiv	r1, r3, lr
    837a:	fb0e 3011 	mls	r0, lr, r1, r3
    837e:	3030      	adds	r0, #48	; 0x30
    8380:	2b63      	cmp	r3, #99	; 0x63
    8382:	f102 3cff 	add.w	ip, r2, #4294967295
    8386:	f802 0c01 	strb.w	r0, [r2, #-1]
    838a:	dc5d      	bgt.n	8448 <_printf_float+0x274>
    838c:	3130      	adds	r1, #48	; 0x30
    838e:	3a02      	subs	r2, #2
    8390:	f80c 1c01 	strb.w	r1, [ip, #-1]
    8394:	f104 0352 	add.w	r3, r4, #82	; 0x52
    8398:	f10d 002f 	add.w	r0, sp, #47	; 0x2f
    839c:	4282      	cmp	r2, r0
    839e:	4619      	mov	r1, r3
    83a0:	d355      	bcc.n	844e <_printf_float+0x27a>
    83a2:	eba1 0808 	sub.w	r8, r1, r8
    83a6:	eb05 0308 	add.w	r3, r5, r8
    83aa:	2d01      	cmp	r5, #1
    83ac:	6123      	str	r3, [r4, #16]
    83ae:	dc02      	bgt.n	83b6 <_printf_float+0x1e2>
    83b0:	6822      	ldr	r2, [r4, #0]
    83b2:	07d0      	lsls	r0, r2, #31
    83b4:	d501      	bpl.n	83ba <_printf_float+0x1e6>
    83b6:	3301      	adds	r3, #1
    83b8:	6123      	str	r3, [r4, #16]
    83ba:	9b07      	ldr	r3, [sp, #28]
    83bc:	2b00      	cmp	r3, #0
    83be:	f43f af5a 	beq.w	8276 <_printf_float+0xa2>
    83c2:	232d      	movs	r3, #45	; 0x2d
    83c4:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    83c8:	e755      	b.n	8276 <_printf_float+0xa2>
    83ca:	9b04      	ldr	r3, [sp, #16]
    83cc:	f1b8 0f46 	cmp.w	r8, #70	; 0x46
    83d0:	eb09 0503 	add.w	r5, r9, r3
    83d4:	d110      	bne.n	83f8 <_printf_float+0x224>
    83d6:	f899 3000 	ldrb.w	r3, [r9]
    83da:	2b30      	cmp	r3, #48	; 0x30
    83dc:	d10a      	bne.n	83f4 <_printf_float+0x220>
    83de:	2200      	movs	r2, #0
    83e0:	2300      	movs	r3, #0
    83e2:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    83e6:	f00b fc0d 	bl	13c04 <__aeabi_dcmpeq>
    83ea:	b918      	cbnz	r0, 83f4 <_printf_float+0x220>
    83ec:	9b04      	ldr	r3, [sp, #16]
    83ee:	f1c3 0301 	rsb	r3, r3, #1
    83f2:	9308      	str	r3, [sp, #32]
    83f4:	9b08      	ldr	r3, [sp, #32]
    83f6:	441d      	add	r5, r3
    83f8:	2200      	movs	r2, #0
    83fa:	2300      	movs	r3, #0
    83fc:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    8400:	f00b fc00 	bl	13c04 <__aeabi_dcmpeq>
    8404:	b100      	cbz	r0, 8408 <_printf_float+0x234>
    8406:	950a      	str	r5, [sp, #40]	; 0x28
    8408:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    840a:	429d      	cmp	r5, r3
    840c:	d98e      	bls.n	832c <_printf_float+0x158>
    840e:	2230      	movs	r2, #48	; 0x30
    8410:	1c59      	adds	r1, r3, #1
    8412:	910a      	str	r1, [sp, #40]	; 0x28
    8414:	701a      	strb	r2, [r3, #0]
    8416:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8418:	429d      	cmp	r5, r3
    841a:	d8f9      	bhi.n	8410 <_printf_float+0x23c>
    841c:	e786      	b.n	832c <_printf_float+0x158>
    841e:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
    8422:	d994      	bls.n	834e <_printf_float+0x17a>
    8424:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
    8428:	d129      	bne.n	847e <_printf_float+0x2aa>
    842a:	2a00      	cmp	r2, #0
    842c:	6863      	ldr	r3, [r4, #4]
    842e:	dd1c      	ble.n	846a <_printf_float+0x296>
    8430:	6122      	str	r2, [r4, #16]
    8432:	b913      	cbnz	r3, 843a <_printf_float+0x266>
    8434:	6821      	ldr	r1, [r4, #0]
    8436:	07c9      	lsls	r1, r1, #31
    8438:	d502      	bpl.n	8440 <_printf_float+0x26c>
    843a:	3301      	adds	r3, #1
    843c:	4413      	add	r3, r2
    843e:	6123      	str	r3, [r4, #16]
    8440:	65a2      	str	r2, [r4, #88]	; 0x58
    8442:	f04f 0800 	mov.w	r8, #0
    8446:	e7b8      	b.n	83ba <_printf_float+0x1e6>
    8448:	4662      	mov	r2, ip
    844a:	460b      	mov	r3, r1
    844c:	e793      	b.n	8376 <_printf_float+0x1a2>
    844e:	f812 1b01 	ldrb.w	r1, [r2], #1
    8452:	f803 1b01 	strb.w	r1, [r3], #1
    8456:	e7a1      	b.n	839c <_printf_float+0x1c8>
    8458:	2230      	movs	r2, #48	; 0x30
    845a:	4413      	add	r3, r2
    845c:	f884 2052 	strb.w	r2, [r4, #82]	; 0x52
    8460:	f104 0154 	add.w	r1, r4, #84	; 0x54
    8464:	f884 3053 	strb.w	r3, [r4, #83]	; 0x53
    8468:	e79b      	b.n	83a2 <_printf_float+0x1ce>
    846a:	b913      	cbnz	r3, 8472 <_printf_float+0x29e>
    846c:	6821      	ldr	r1, [r4, #0]
    846e:	07c8      	lsls	r0, r1, #31
    8470:	d501      	bpl.n	8476 <_printf_float+0x2a2>
    8472:	3302      	adds	r3, #2
    8474:	e7e3      	b.n	843e <_printf_float+0x26a>
    8476:	2301      	movs	r3, #1
    8478:	e7e1      	b.n	843e <_printf_float+0x26a>
    847a:	f04f 0a67 	mov.w	sl, #103	; 0x67
    847e:	42aa      	cmp	r2, r5
    8480:	db05      	blt.n	848e <_printf_float+0x2ba>
    8482:	6823      	ldr	r3, [r4, #0]
    8484:	6122      	str	r2, [r4, #16]
    8486:	07d9      	lsls	r1, r3, #31
    8488:	d5da      	bpl.n	8440 <_printf_float+0x26c>
    848a:	1c53      	adds	r3, r2, #1
    848c:	e7d7      	b.n	843e <_printf_float+0x26a>
    848e:	2a00      	cmp	r2, #0
    8490:	bfd4      	ite	le
    8492:	f1c2 0302 	rsble	r3, r2, #2
    8496:	2301      	movgt	r3, #1
    8498:	442b      	add	r3, r5
    849a:	e7d0      	b.n	843e <_printf_float+0x26a>
    849c:	6823      	ldr	r3, [r4, #0]
    849e:	055a      	lsls	r2, r3, #21
    84a0:	d40e      	bmi.n	84c0 <_printf_float+0x2ec>
    84a2:	6923      	ldr	r3, [r4, #16]
    84a4:	464a      	mov	r2, r9
    84a6:	4659      	mov	r1, fp
    84a8:	4630      	mov	r0, r6
    84aa:	47b8      	blx	r7
    84ac:	3001      	adds	r0, #1
    84ae:	d12f      	bne.n	8510 <_printf_float+0x33c>
    84b0:	e6eb      	b.n	828a <_printf_float+0xb6>
    84b2:	bf00      	nop
    84b4:	7fefffff 	.word	0x7fefffff
    84b8:	00021ae6 	.word	0x00021ae6
    84bc:	00021aee 	.word	0x00021aee
    84c0:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
    84c4:	f240 80c9 	bls.w	865a <_printf_float+0x486>
    84c8:	2200      	movs	r2, #0
    84ca:	2300      	movs	r3, #0
    84cc:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
    84d0:	f00b fb98 	bl	13c04 <__aeabi_dcmpeq>
    84d4:	b388      	cbz	r0, 853a <_printf_float+0x366>
    84d6:	2301      	movs	r3, #1
    84d8:	4a88      	ldr	r2, [pc, #544]	; (86fc <_printf_float+0x528>)
    84da:	4659      	mov	r1, fp
    84dc:	4630      	mov	r0, r6
    84de:	47b8      	blx	r7
    84e0:	3001      	adds	r0, #1
    84e2:	f43f aed2 	beq.w	828a <_printf_float+0xb6>
    84e6:	9b08      	ldr	r3, [sp, #32]
    84e8:	42ab      	cmp	r3, r5
    84ea:	db02      	blt.n	84f2 <_printf_float+0x31e>
    84ec:	6823      	ldr	r3, [r4, #0]
    84ee:	07d8      	lsls	r0, r3, #31
    84f0:	d50e      	bpl.n	8510 <_printf_float+0x33c>
    84f2:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
    84f6:	4659      	mov	r1, fp
    84f8:	4630      	mov	r0, r6
    84fa:	47b8      	blx	r7
    84fc:	3001      	adds	r0, #1
    84fe:	f43f aec4 	beq.w	828a <_printf_float+0xb6>
    8502:	f04f 0800 	mov.w	r8, #0
    8506:	3d01      	subs	r5, #1
    8508:	f104 091a 	add.w	r9, r4, #26
    850c:	4545      	cmp	r5, r8
    850e:	dc09      	bgt.n	8524 <_printf_float+0x350>
    8510:	6823      	ldr	r3, [r4, #0]
    8512:	079d      	lsls	r5, r3, #30
    8514:	f100 80ed 	bmi.w	86f2 <_printf_float+0x51e>
    8518:	68e0      	ldr	r0, [r4, #12]
    851a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    851c:	4298      	cmp	r0, r3
    851e:	bfb8      	it	lt
    8520:	4618      	movlt	r0, r3
    8522:	e6b4      	b.n	828e <_printf_float+0xba>
    8524:	2301      	movs	r3, #1
    8526:	464a      	mov	r2, r9
    8528:	4659      	mov	r1, fp
    852a:	4630      	mov	r0, r6
    852c:	47b8      	blx	r7
    852e:	3001      	adds	r0, #1
    8530:	f43f aeab 	beq.w	828a <_printf_float+0xb6>
    8534:	f108 0801 	add.w	r8, r8, #1
    8538:	e7e8      	b.n	850c <_printf_float+0x338>
    853a:	9b08      	ldr	r3, [sp, #32]
    853c:	2b00      	cmp	r3, #0
    853e:	dc2a      	bgt.n	8596 <_printf_float+0x3c2>
    8540:	2301      	movs	r3, #1
    8542:	4a6e      	ldr	r2, [pc, #440]	; (86fc <_printf_float+0x528>)
    8544:	4659      	mov	r1, fp
    8546:	4630      	mov	r0, r6
    8548:	47b8      	blx	r7
    854a:	3001      	adds	r0, #1
    854c:	f43f ae9d 	beq.w	828a <_printf_float+0xb6>
    8550:	9b08      	ldr	r3, [sp, #32]
    8552:	432b      	orrs	r3, r5
    8554:	d102      	bne.n	855c <_printf_float+0x388>
    8556:	6823      	ldr	r3, [r4, #0]
    8558:	07d9      	lsls	r1, r3, #31
    855a:	d5d9      	bpl.n	8510 <_printf_float+0x33c>
    855c:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
    8560:	4659      	mov	r1, fp
    8562:	4630      	mov	r0, r6
    8564:	47b8      	blx	r7
    8566:	3001      	adds	r0, #1
    8568:	f43f ae8f 	beq.w	828a <_printf_float+0xb6>
    856c:	f04f 0800 	mov.w	r8, #0
    8570:	f104 0a1a 	add.w	sl, r4, #26
    8574:	9b08      	ldr	r3, [sp, #32]
    8576:	425b      	negs	r3, r3
    8578:	4543      	cmp	r3, r8
    857a:	dc01      	bgt.n	8580 <_printf_float+0x3ac>
    857c:	462b      	mov	r3, r5
    857e:	e791      	b.n	84a4 <_printf_float+0x2d0>
    8580:	2301      	movs	r3, #1
    8582:	4652      	mov	r2, sl
    8584:	4659      	mov	r1, fp
    8586:	4630      	mov	r0, r6
    8588:	47b8      	blx	r7
    858a:	3001      	adds	r0, #1
    858c:	f43f ae7d 	beq.w	828a <_printf_float+0xb6>
    8590:	f108 0801 	add.w	r8, r8, #1
    8594:	e7ee      	b.n	8574 <_printf_float+0x3a0>
    8596:	6da3      	ldr	r3, [r4, #88]	; 0x58
    8598:	42ab      	cmp	r3, r5
    859a:	bfa8      	it	ge
    859c:	462b      	movge	r3, r5
    859e:	2b00      	cmp	r3, #0
    85a0:	4698      	mov	r8, r3
    85a2:	dd06      	ble.n	85b2 <_printf_float+0x3de>
    85a4:	464a      	mov	r2, r9
    85a6:	4659      	mov	r1, fp
    85a8:	4630      	mov	r0, r6
    85aa:	47b8      	blx	r7
    85ac:	3001      	adds	r0, #1
    85ae:	f43f ae6c 	beq.w	828a <_printf_float+0xb6>
    85b2:	2300      	movs	r3, #0
    85b4:	9302      	str	r3, [sp, #8]
    85b6:	f104 031a 	add.w	r3, r4, #26
    85ba:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
    85be:	9304      	str	r3, [sp, #16]
    85c0:	e00a      	b.n	85d8 <_printf_float+0x404>
    85c2:	2301      	movs	r3, #1
    85c4:	9a04      	ldr	r2, [sp, #16]
    85c6:	4659      	mov	r1, fp
    85c8:	4630      	mov	r0, r6
    85ca:	47b8      	blx	r7
    85cc:	3001      	adds	r0, #1
    85ce:	f43f ae5c 	beq.w	828a <_printf_float+0xb6>
    85d2:	9b02      	ldr	r3, [sp, #8]
    85d4:	3301      	adds	r3, #1
    85d6:	9302      	str	r3, [sp, #8]
    85d8:	f8d4 a058 	ldr.w	sl, [r4, #88]	; 0x58
    85dc:	9a02      	ldr	r2, [sp, #8]
    85de:	ebaa 0308 	sub.w	r3, sl, r8
    85e2:	4293      	cmp	r3, r2
    85e4:	dced      	bgt.n	85c2 <_printf_float+0x3ee>
    85e6:	9b08      	ldr	r3, [sp, #32]
    85e8:	42ab      	cmp	r3, r5
    85ea:	db1a      	blt.n	8622 <_printf_float+0x44e>
    85ec:	6823      	ldr	r3, [r4, #0]
    85ee:	07da      	lsls	r2, r3, #31
    85f0:	d417      	bmi.n	8622 <_printf_float+0x44e>
    85f2:	9b08      	ldr	r3, [sp, #32]
    85f4:	459a      	cmp	sl, r3
    85f6:	db1c      	blt.n	8632 <_printf_float+0x45e>
    85f8:	eba5 080a 	sub.w	r8, r5, sl
    85fc:	f1b8 0f00 	cmp.w	r8, #0
    8600:	dd08      	ble.n	8614 <_printf_float+0x440>
    8602:	4643      	mov	r3, r8
    8604:	eb09 020a 	add.w	r2, r9, sl
    8608:	4659      	mov	r1, fp
    860a:	4630      	mov	r0, r6
    860c:	47b8      	blx	r7
    860e:	3001      	adds	r0, #1
    8610:	f43f ae3b 	beq.w	828a <_printf_float+0xb6>
    8614:	f04f 0900 	mov.w	r9, #0
    8618:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
    861c:	f104 0a1a 	add.w	sl, r4, #26
    8620:	e014      	b.n	864c <_printf_float+0x478>
    8622:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
    8626:	4659      	mov	r1, fp
    8628:	4630      	mov	r0, r6
    862a:	47b8      	blx	r7
    862c:	3001      	adds	r0, #1
    862e:	d1e0      	bne.n	85f2 <_printf_float+0x41e>
    8630:	e62b      	b.n	828a <_printf_float+0xb6>
    8632:	eba5 0803 	sub.w	r8, r5, r3
    8636:	e7e1      	b.n	85fc <_printf_float+0x428>
    8638:	2301      	movs	r3, #1
    863a:	4652      	mov	r2, sl
    863c:	4659      	mov	r1, fp
    863e:	4630      	mov	r0, r6
    8640:	47b8      	blx	r7
    8642:	3001      	adds	r0, #1
    8644:	f43f ae21 	beq.w	828a <_printf_float+0xb6>
    8648:	f109 0901 	add.w	r9, r9, #1
    864c:	9b08      	ldr	r3, [sp, #32]
    864e:	1aeb      	subs	r3, r5, r3
    8650:	eba3 0308 	sub.w	r3, r3, r8
    8654:	454b      	cmp	r3, r9
    8656:	dcef      	bgt.n	8638 <_printf_float+0x464>
    8658:	e75a      	b.n	8510 <_printf_float+0x33c>
    865a:	2d01      	cmp	r5, #1
    865c:	dc01      	bgt.n	8662 <_printf_float+0x48e>
    865e:	07db      	lsls	r3, r3, #31
    8660:	d535      	bpl.n	86ce <_printf_float+0x4fa>
    8662:	2301      	movs	r3, #1
    8664:	464a      	mov	r2, r9
    8666:	4659      	mov	r1, fp
    8668:	4630      	mov	r0, r6
    866a:	47b8      	blx	r7
    866c:	3001      	adds	r0, #1
    866e:	f43f ae0c 	beq.w	828a <_printf_float+0xb6>
    8672:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
    8676:	4659      	mov	r1, fp
    8678:	4630      	mov	r0, r6
    867a:	47b8      	blx	r7
    867c:	3001      	adds	r0, #1
    867e:	f43f ae04 	beq.w	828a <_printf_float+0xb6>
    8682:	2200      	movs	r2, #0
    8684:	2300      	movs	r3, #0
    8686:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
    868a:	3d01      	subs	r5, #1
    868c:	f00b faba 	bl	13c04 <__aeabi_dcmpeq>
    8690:	b9c0      	cbnz	r0, 86c4 <_printf_float+0x4f0>
    8692:	462b      	mov	r3, r5
    8694:	f109 0201 	add.w	r2, r9, #1
    8698:	4659      	mov	r1, fp
    869a:	4630      	mov	r0, r6
    869c:	47b8      	blx	r7
    869e:	3001      	adds	r0, #1
    86a0:	d10c      	bne.n	86bc <_printf_float+0x4e8>
    86a2:	e5f2      	b.n	828a <_printf_float+0xb6>
    86a4:	2301      	movs	r3, #1
    86a6:	4652      	mov	r2, sl
    86a8:	4659      	mov	r1, fp
    86aa:	4630      	mov	r0, r6
    86ac:	47b8      	blx	r7
    86ae:	3001      	adds	r0, #1
    86b0:	f43f adeb 	beq.w	828a <_printf_float+0xb6>
    86b4:	f109 0901 	add.w	r9, r9, #1
    86b8:	454d      	cmp	r5, r9
    86ba:	dcf3      	bgt.n	86a4 <_printf_float+0x4d0>
    86bc:	4643      	mov	r3, r8
    86be:	f104 0250 	add.w	r2, r4, #80	; 0x50
    86c2:	e6f0      	b.n	84a6 <_printf_float+0x2d2>
    86c4:	f04f 0900 	mov.w	r9, #0
    86c8:	f104 0a1a 	add.w	sl, r4, #26
    86cc:	e7f4      	b.n	86b8 <_printf_float+0x4e4>
    86ce:	2301      	movs	r3, #1
    86d0:	464a      	mov	r2, r9
    86d2:	e7e1      	b.n	8698 <_printf_float+0x4c4>
    86d4:	2301      	movs	r3, #1
    86d6:	4642      	mov	r2, r8
    86d8:	4659      	mov	r1, fp
    86da:	4630      	mov	r0, r6
    86dc:	47b8      	blx	r7
    86de:	3001      	adds	r0, #1
    86e0:	f43f add3 	beq.w	828a <_printf_float+0xb6>
    86e4:	3501      	adds	r5, #1
    86e6:	68e3      	ldr	r3, [r4, #12]
    86e8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    86ea:	1a9b      	subs	r3, r3, r2
    86ec:	42ab      	cmp	r3, r5
    86ee:	dcf1      	bgt.n	86d4 <_printf_float+0x500>
    86f0:	e712      	b.n	8518 <_printf_float+0x344>
    86f2:	2500      	movs	r5, #0
    86f4:	f104 0819 	add.w	r8, r4, #25
    86f8:	e7f5      	b.n	86e6 <_printf_float+0x512>
    86fa:	bf00      	nop
    86fc:	00021af6 	.word	0x00021af6

Disassembly of section .text._Command_DNS_Service%193:

00008700 <_Command_DNS_Service>:
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Failed to %s %s\r\n", msgFail, argv[0]);
    }
    return true;
}
static int _Command_DNS_Service(SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char** argv)
{
    8700:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8704:	b0c3      	sub	sp, #268	; 0x10c
    8706:	4605      	mov	r5, r0
    8708:	4688      	mov	r8, r1
    870a:	4691      	mov	r9, r2
    uint8_t             *hostName;
    const void* cmdIoParam = pCmdIO->cmdIoParam;
    870c:	6846      	ldr	r6, [r0, #4]
    TCPIP_DNS_RESULT res;
    DNS_SERVICE_COMD_TYPE val=DNS_SERVICE_COMD_NONE;
    DNSS_COMMAND_MAP dnssComnd[]=
    870e:	ac38      	add	r4, sp, #224	; 0xe0
    8710:	4fa0      	ldr	r7, [pc, #640]	; (8994 <_Command_DNS_Service+0x294>)
    8712:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    8714:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    8716:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    8718:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    871a:	e897 0003 	ldmia.w	r7, {r0, r1}
    871e:	e884 0003 	stmia.w	r4, {r0, r1}
                {"off",         DNS_SERVICE_COMD_ENABLE_INTF},
                {"lookup",      DNS_SERVICE_COMD_LOOKUP},
            };
    int i=0;

    if (argc < 2) {
    8722:	f1b8 0f01 	cmp.w	r8, #1
    8726:	dd16      	ble.n	8756 <_Command_DNS_Service+0x56>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: dnsc <del/info/on/off/lookup> \r\n");
        return false;
    }
    for(i=0;i<(sizeof(dnssComnd)/sizeof(DNSS_COMMAND_MAP));i++)
    {
        if(strcmp(argv[1],dnssComnd[i].command) ==0)
    8728:	f8d9 a004 	ldr.w	sl, [r9, #4]
    for(i=0;i<(sizeof(dnssComnd)/sizeof(DNSS_COMMAND_MAP));i++)
    872c:	2700      	movs	r7, #0
        if(strcmp(argv[1],dnssComnd[i].command) ==0)
    872e:	f10d 0be0 	add.w	fp, sp, #224	; 0xe0
    8732:	f85b 1037 	ldr.w	r1, [fp, r7, lsl #3]
    8736:	4650      	mov	r0, sl
    8738:	f019 f970 	bl	21a1c <strcmp>
    873c:	4604      	mov	r4, r0
    873e:	b1a8      	cbz	r0, 876c <_Command_DNS_Service+0x6c>
    for(i=0;i<(sizeof(dnssComnd)/sizeof(DNSS_COMMAND_MAP));i++)
    8740:	3701      	adds	r7, #1
    8742:	2f05      	cmp	r7, #5
    8744:	d1f5      	bne.n	8732 <_Command_DNS_Service+0x32>
            break;
        case DNS_SERVICE_COMD_INFO:
            _Command_ShowDNSResolvedInfo(pCmdIO,argc,argv);
            break;
        default:
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Invalid Input Command :[ %s ] \r\n", argv[1]);
    8746:	682b      	ldr	r3, [r5, #0]
    8748:	685b      	ldr	r3, [r3, #4]
    874a:	4652      	mov	r2, sl
    874c:	4992      	ldr	r1, [pc, #584]	; (8998 <_Command_DNS_Service+0x298>)
    874e:	4630      	mov	r0, r6
    8750:	4798      	blx	r3
            return false;
    8752:	2400      	movs	r4, #0
    8754:	e006      	b.n	8764 <_Command_DNS_Service+0x64>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: dnsc <del/info/on/off/lookup> \r\n");
    8756:	682b      	ldr	r3, [r5, #0]
    8758:	681b      	ldr	r3, [r3, #0]
    875a:	f107 0108 	add.w	r1, r7, #8
    875e:	4630      	mov	r0, r6
    8760:	4798      	blx	r3
        return false;
    8762:	2400      	movs	r4, #0
    }
    return true;
}
    8764:	4620      	mov	r0, r4
    8766:	b043      	add	sp, #268	; 0x10c
    8768:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            val = dnssComnd[i].val;
    876c:	ab42      	add	r3, sp, #264	; 0x108
    876e:	eb03 07c7 	add.w	r7, r3, r7, lsl #3
    switch(val)
    8772:	f817 3c24 	ldrb.w	r3, [r7, #-36]
    8776:	3b01      	subs	r3, #1
    8778:	2b03      	cmp	r3, #3
    877a:	d8e4      	bhi.n	8746 <_Command_DNS_Service+0x46>
    877c:	e8df f013 	tbh	[pc, r3, lsl #1]
    8780:	016a00f3 	.word	0x016a00f3
    8784:	00680004 	.word	0x00680004
    if (argc < 3)
    8788:	f1b8 0f02 	cmp.w	r8, #2
    878c:	dc12      	bgt.n	87b4 <_Command_DNS_Service+0xb4>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Usage: %s <on/off> <interface> <strict/pref>/<clear> \r\n", argv[0]);
    878e:	4c83      	ldr	r4, [pc, #524]	; (899c <_Command_DNS_Service+0x29c>)
    8790:	682b      	ldr	r3, [r5, #0]
    8792:	685b      	ldr	r3, [r3, #4]
    8794:	f8d9 2000 	ldr.w	r2, [r9]
    8798:	f504 7134 	add.w	r1, r4, #720	; 0x2d0
    879c:	4630      	mov	r0, r6
    879e:	4798      	blx	r3
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Ex: %s on eth0\r\n", argv[0]);
    87a0:	682b      	ldr	r3, [r5, #0]
    87a2:	685b      	ldr	r3, [r3, #4]
    87a4:	f8d9 2000 	ldr.w	r2, [r9]
    87a8:	f504 7142 	add.w	r1, r4, #776	; 0x308
    87ac:	4630      	mov	r0, r6
    87ae:	4798      	blx	r3
    return true;
    87b0:	2401      	movs	r4, #1
    87b2:	e7d7      	b.n	8764 <_Command_DNS_Service+0x64>
    netH = TCPIP_STACK_NetHandleGet(argv[2]);
    87b4:	f8d9 0008 	ldr.w	r0, [r9, #8]
    87b8:	f015 f9fc 	bl	1dbb4 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
    87bc:	4607      	mov	r7, r0
    87be:	b1e8      	cbz	r0, 87fc <_Command_DNS_Service+0xfc>
    if (memcmp(argv[1], "on", 2) == 0)
    87c0:	f8d9 4004 	ldr.w	r4, [r9, #4]
    87c4:	2202      	movs	r2, #2
    87c6:	4976      	ldr	r1, [pc, #472]	; (89a0 <_Command_DNS_Service+0x2a0>)
    87c8:	4620      	mov	r0, r4
    87ca:	f018 fccb 	bl	21164 <memcmp>
    87ce:	b9e0      	cbnz	r0, 880a <_Command_DNS_Service+0x10a>
        if(argc > 3)
    87d0:	f1b8 0f03 	cmp.w	r8, #3
    87d4:	f340 81ed 	ble.w	8bb2 <_Command_DNS_Service+0x4b2>
            if(strcmp(argv[3], "strict") == 0)
    87d8:	f8d9 400c 	ldr.w	r4, [r9, #12]
    87dc:	4971      	ldr	r1, [pc, #452]	; (89a4 <_Command_DNS_Service+0x2a4>)
    87de:	4620      	mov	r0, r4
    87e0:	f019 f91c 	bl	21a1c <strcmp>
    87e4:	2800      	cmp	r0, #0
    87e6:	f000 81f9 	beq.w	8bdc <_Command_DNS_Service+0x4dc>
            else if(strcmp(argv[3], "pref") == 0)
    87ea:	496f      	ldr	r1, [pc, #444]	; (89a8 <_Command_DNS_Service+0x2a8>)
    87ec:	4620      	mov	r0, r4
    87ee:	f019 f915 	bl	21a1c <strcmp>
    87f2:	2800      	cmp	r0, #0
                enableFlags = TCPIP_DNS_ENABLE_PREFERRED;
    87f4:	bf14      	ite	ne
    87f6:	2100      	movne	r1, #0
    87f8:	2102      	moveq	r1, #2
    87fa:	e1db      	b.n	8bb4 <_Command_DNS_Service+0x4b4>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface\r\n");
    87fc:	682b      	ldr	r3, [r5, #0]
    87fe:	681b      	ldr	r3, [r3, #0]
    8800:	496a      	ldr	r1, [pc, #424]	; (89ac <_Command_DNS_Service+0x2ac>)
    8802:	4630      	mov	r0, r6
    8804:	4798      	blx	r3
    return true;
    8806:	2401      	movs	r4, #1
    8808:	e7ac      	b.n	8764 <_Command_DNS_Service+0x64>
    else if (memcmp(argv[1], "off", 2) == 0)
    880a:	2202      	movs	r2, #2
    880c:	4968      	ldr	r1, [pc, #416]	; (89b0 <_Command_DNS_Service+0x2b0>)
    880e:	4620      	mov	r0, r4
    8810:	f018 fca8 	bl	21164 <memcmp>
    8814:	b960      	cbnz	r0, 8830 <_Command_DNS_Service+0x130>
        if(argc > 3)
    8816:	f1b8 0f03 	cmp.w	r8, #3
    881a:	f340 81e1 	ble.w	8be0 <_Command_DNS_Service+0x4e0>
            if(strcmp(argv[3], "clear") == 0)
    881e:	4965      	ldr	r1, [pc, #404]	; (89b4 <_Command_DNS_Service+0x2b4>)
    8820:	f8d9 000c 	ldr.w	r0, [r9, #12]
    8824:	f019 f8fa 	bl	21a1c <strcmp>
    8828:	fab0 f180 	clz	r1, r0
    882c:	0949      	lsrs	r1, r1, #5
    882e:	e1d8      	b.n	8be2 <_Command_DNS_Service+0x4e2>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown option\r\n");
    8830:	682b      	ldr	r3, [r5, #0]
    8832:	681b      	ldr	r3, [r3, #0]
    8834:	4960      	ldr	r1, [pc, #384]	; (89b8 <_Command_DNS_Service+0x2b8>)
    8836:	4630      	mov	r0, r6
    8838:	4798      	blx	r3
    return true;
    883a:	2401      	movs	r4, #1
    883c:	e792      	b.n	8764 <_Command_DNS_Service+0x64>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Failed to %s %s\r\n", msgFail, argv[0]);
    883e:	682b      	ldr	r3, [r5, #0]
    8840:	685c      	ldr	r4, [r3, #4]
    8842:	f8d9 3000 	ldr.w	r3, [r9]
    8846:	495d      	ldr	r1, [pc, #372]	; (89bc <_Command_DNS_Service+0x2bc>)
    8848:	4630      	mov	r0, r6
    884a:	47a0      	blx	r4
    return true;
    884c:	2401      	movs	r4, #1
    884e:	e789      	b.n	8764 <_Command_DNS_Service+0x64>
            if (argc != 4) {
    8850:	f1b8 0f04 	cmp.w	r8, #4
    8854:	d01f      	beq.n	8896 <_Command_DNS_Service+0x196>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: dnsc lookup <type> <hostName> \r\n");
    8856:	4f51      	ldr	r7, [pc, #324]	; (899c <_Command_DNS_Service+0x29c>)
    8858:	682b      	ldr	r3, [r5, #0]
    885a:	681b      	ldr	r3, [r3, #0]
    885c:	f507 714d 	add.w	r1, r7, #820	; 0x334
    8860:	4630      	mov	r0, r6
    8862:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: <hostName>(URL) - look up for hostname\r\n");
    8864:	682b      	ldr	r3, [r5, #0]
    8866:	681b      	ldr	r3, [r3, #0]
    8868:	f507 7157 	add.w	r1, r7, #860	; 0x35c
    886c:	4630      	mov	r0, r6
    886e:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: <type> : a or A for IPv4 address lookup\r\n");
    8870:	682b      	ldr	r3, [r5, #0]
    8872:	681b      	ldr	r3, [r3, #0]
    8874:	f507 7163 	add.w	r1, r7, #908	; 0x38c
    8878:	4630      	mov	r0, r6
    887a:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: <type> : aaaa or AAAA for IPv6 address lookup\r\n");
    887c:	682b      	ldr	r3, [r5, #0]
    887e:	681b      	ldr	r3, [r3, #0]
    8880:	f507 716f 	add.w	r1, r7, #956	; 0x3bc
    8884:	4630      	mov	r0, r6
    8886:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: <type> : any for both IPv4 and IPv6 address lookup\r\n");
    8888:	682b      	ldr	r3, [r5, #0]
    888a:	681b      	ldr	r3, [r3, #0]
    888c:	f507 717d 	add.w	r1, r7, #1012	; 0x3f4
    8890:	4630      	mov	r0, r6
    8892:	4798      	blx	r3
                return false;
    8894:	e766      	b.n	8764 <_Command_DNS_Service+0x64>


static int _Command_DNSLookUP(SYS_CMD_DEVICE_NODE* pCmdIO, char** argv)
{
    if(tcpipCmdStat != TCPIP_CMD_STAT_IDLE)
    8896:	4b4a      	ldr	r3, [pc, #296]	; (89c0 <_Command_DNS_Service+0x2c0>)
    8898:	781b      	ldrb	r3, [r3, #0]
    889a:	b9e3      	cbnz	r3, 88d6 <_Command_DNS_Service+0x1d6>
    {
        (*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, "dnsc lookup: command in progress. Retry later.\r\n");
        return true;
    }

    if((strcmp(argv[2], "A") == 0) || (strcmp(argv[2], "a") == 0))
    889c:	f8d9 4008 	ldr.w	r4, [r9, #8]
    88a0:	4948      	ldr	r1, [pc, #288]	; (89c4 <_Command_DNS_Service+0x2c4>)
    88a2:	4620      	mov	r0, r4
    88a4:	f019 f8ba 	bl	21a1c <strcmp>
    88a8:	b120      	cbz	r0, 88b4 <_Command_DNS_Service+0x1b4>
    88aa:	4947      	ldr	r1, [pc, #284]	; (89c8 <_Command_DNS_Service+0x2c8>)
    88ac:	4620      	mov	r0, r4
    88ae:	f019 f8b5 	bl	21a1c <strcmp>
    88b2:	b9b8      	cbnz	r0, 88e4 <_Command_DNS_Service+0x1e4>
    {
        dnsType=TCPIP_DNS_TYPE_A;
    88b4:	4b45      	ldr	r3, [pc, #276]	; (89cc <_Command_DNS_Service+0x2cc>)
    88b6:	2201      	movs	r2, #1
    88b8:	701a      	strb	r2, [r3, #0]
    {
        (*pCmdIO->pCmdApi->print)(pCmdIO->cmdIoParam, "dnsc lookup: [%s] Lookup Type not supported.\r\n",argv[2]);
        return true;
    }

    if(strlen(argv[3]) > sizeof(dnslookupTargetHost) - 1)
    88ba:	f8d9 400c 	ldr.w	r4, [r9, #12]
    88be:	4620      	mov	r0, r4
    88c0:	f019 f9f4 	bl	21cac <strlen>
    88c4:	281e      	cmp	r0, #30
    88c6:	d931      	bls.n	892c <_Command_DNS_Service+0x22c>
    {
        (*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, "dnsc lookup: Host name too long. Retry.\r\n");
    88c8:	682b      	ldr	r3, [r5, #0]
    88ca:	681b      	ldr	r3, [r3, #0]
    88cc:	4940      	ldr	r1, [pc, #256]	; (89d0 <_Command_DNS_Service+0x2d0>)
    88ce:	4630      	mov	r0, r6
    88d0:	4798      	blx	r3
    return true;
    88d2:	2401      	movs	r4, #1
    88d4:	e746      	b.n	8764 <_Command_DNS_Service+0x64>
        (*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, "dnsc lookup: command in progress. Retry later.\r\n");
    88d6:	682b      	ldr	r3, [r5, #0]
    88d8:	681b      	ldr	r3, [r3, #0]
    88da:	493e      	ldr	r1, [pc, #248]	; (89d4 <_Command_DNS_Service+0x2d4>)
    88dc:	4630      	mov	r0, r6
    88de:	4798      	blx	r3
    return true;
    88e0:	2401      	movs	r4, #1
    88e2:	e73f      	b.n	8764 <_Command_DNS_Service+0x64>
    else if((strcmp(argv[2], "AAAA") == 0) || (strcmp(argv[2], "aaaa") == 0))
    88e4:	493c      	ldr	r1, [pc, #240]	; (89d8 <_Command_DNS_Service+0x2d8>)
    88e6:	4620      	mov	r0, r4
    88e8:	f019 f898 	bl	21a1c <strcmp>
    88ec:	b120      	cbz	r0, 88f8 <_Command_DNS_Service+0x1f8>
    88ee:	493b      	ldr	r1, [pc, #236]	; (89dc <_Command_DNS_Service+0x2dc>)
    88f0:	4620      	mov	r0, r4
    88f2:	f019 f893 	bl	21a1c <strcmp>
    88f6:	b918      	cbnz	r0, 8900 <_Command_DNS_Service+0x200>
        dnsType=TCPIP_DNS_TYPE_AAAA;
    88f8:	4b34      	ldr	r3, [pc, #208]	; (89cc <_Command_DNS_Service+0x2cc>)
    88fa:	221c      	movs	r2, #28
    88fc:	701a      	strb	r2, [r3, #0]
    88fe:	e7dc      	b.n	88ba <_Command_DNS_Service+0x1ba>
    else if((strcmp(argv[2], "ANY") == 0) || (strcmp(argv[2], "any") == 0))
    8900:	4937      	ldr	r1, [pc, #220]	; (89e0 <_Command_DNS_Service+0x2e0>)
    8902:	4620      	mov	r0, r4
    8904:	f019 f88a 	bl	21a1c <strcmp>
    8908:	b120      	cbz	r0, 8914 <_Command_DNS_Service+0x214>
    890a:	4936      	ldr	r1, [pc, #216]	; (89e4 <_Command_DNS_Service+0x2e4>)
    890c:	4620      	mov	r0, r4
    890e:	f019 f885 	bl	21a1c <strcmp>
    8912:	b918      	cbnz	r0, 891c <_Command_DNS_Service+0x21c>
        dnsType=TCPIP_DNS_TYPE_ANY;
    8914:	4b2d      	ldr	r3, [pc, #180]	; (89cc <_Command_DNS_Service+0x2cc>)
    8916:	22ff      	movs	r2, #255	; 0xff
    8918:	701a      	strb	r2, [r3, #0]
    891a:	e7ce      	b.n	88ba <_Command_DNS_Service+0x1ba>
        (*pCmdIO->pCmdApi->print)(pCmdIO->cmdIoParam, "dnsc lookup: [%s] Lookup Type not supported.\r\n",argv[2]);
    891c:	682b      	ldr	r3, [r5, #0]
    891e:	685b      	ldr	r3, [r3, #4]
    8920:	4622      	mov	r2, r4
    8922:	4931      	ldr	r1, [pc, #196]	; (89e8 <_Command_DNS_Service+0x2e8>)
    8924:	4630      	mov	r0, r6
    8926:	4798      	blx	r3
    return true;
    8928:	2401      	movs	r4, #1
    892a:	e71b      	b.n	8764 <_Command_DNS_Service+0x64>
        return true;
    }
    strcpy(dnslookupTargetHost, argv[3]);
    892c:	4e2f      	ldr	r6, [pc, #188]	; (89ec <_Command_DNS_Service+0x2ec>)
    892e:	4621      	mov	r1, r4
    8930:	4630      	mov	r0, r6
    8932:	f019 f9b3 	bl	21c9c <strcpy>

    dnsLookupCmdIoParam = pCmdIO->cmdIoParam;
    8936:	686a      	ldr	r2, [r5, #4]
    8938:	4b2d      	ldr	r3, [pc, #180]	; (89f0 <_Command_DNS_Service+0x2f0>)
    893a:	601a      	str	r2, [r3, #0]
    (*pCmdIO->pCmdApi->print)(pCmdIO, "dnsc lookup: resolving host: %s for type:%s \r\n", dnslookupTargetHost,argv[2]);
    893c:	682b      	ldr	r3, [r5, #0]
    893e:	685c      	ldr	r4, [r3, #4]
    8940:	f8d9 3008 	ldr.w	r3, [r9, #8]
    8944:	4632      	mov	r2, r6
    8946:	492b      	ldr	r1, [pc, #172]	; (89f4 <_Command_DNS_Service+0x2f4>)
    8948:	4628      	mov	r0, r5
    894a:	47a0      	blx	r4
    tcpipCmdStat = TCPIP_DNS_LOOKUP_CMD_GET;
    894c:	4b1c      	ldr	r3, [pc, #112]	; (89c0 <_Command_DNS_Service+0x2c0>)
    894e:	2208      	movs	r2, #8
    8950:	701a      	strb	r2, [r3, #0]
    pTcpipCmdDevice = pCmdIO;
    8952:	4b29      	ldr	r3, [pc, #164]	; (89f8 <_Command_DNS_Service+0x2f8>)
    8954:	601d      	str	r5, [r3, #0]
    _TCPIPStackSignalHandlerSetParams(TCPIP_THIS_MODULE_ID, tcpipCmdSignalHandle, TCPIP_DNS_CLIENT_TASK_PROCESS_RATE);
    8956:	22c8      	movs	r2, #200	; 0xc8
    8958:	4b28      	ldr	r3, [pc, #160]	; (89fc <_Command_DNS_Service+0x2fc>)
    895a:	6819      	ldr	r1, [r3, #0]
    895c:	201f      	movs	r0, #31
    895e:	f017 fb4d 	bl	1fffc <_TCPIPStackSignalHandlerSetParams>
    return true;
    8962:	2401      	movs	r4, #1
    8964:	e6fe      	b.n	8764 <_Command_DNS_Service+0x64>
            if (argc != 3) {
    8966:	f1b8 0f03 	cmp.w	r8, #3
    896a:	d049      	beq.n	8a00 <_Command_DNS_Service+0x300>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: dnsc del <hostName>|all \r\n");
    896c:	4f0b      	ldr	r7, [pc, #44]	; (899c <_Command_DNS_Service+0x29c>)
    896e:	682b      	ldr	r3, [r5, #0]
    8970:	681b      	ldr	r3, [r3, #0]
    8972:	f507 61a2 	add.w	r1, r7, #1296	; 0x510
    8976:	4630      	mov	r0, r6
    8978:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: <hostName>(URL) - Remove the entry if exists \r\n");
    897a:	682b      	ldr	r3, [r5, #0]
    897c:	681b      	ldr	r3, [r3, #0]
    897e:	f207 5134 	addw	r1, r7, #1332	; 0x534
    8982:	4630      	mov	r0, r6
    8984:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: all - Remove all the resolved entry \r\n");
    8986:	682b      	ldr	r3, [r5, #0]
    8988:	681b      	ldr	r3, [r3, #0]
    898a:	f207 516c 	addw	r1, r7, #1388	; 0x56c
    898e:	4630      	mov	r0, r6
    8990:	4798      	blx	r3
                return false;
    8992:	e6e7      	b.n	8764 <_Command_DNS_Service+0x64>
    8994:	0000050c 	.word	0x0000050c
    8998:	000009c4 	.word	0x000009c4
    899c:	0000028c 	.word	0x0000028c
    89a0:	000004b4 	.word	0x000004b4
    89a4:	000005a8 	.word	0x000005a8
    89a8:	000005b0 	.word	0x000005b0
    89ac:	000004a0 	.word	0x000004a0
    89b0:	000004b8 	.word	0x000004b8
    89b4:	000005b8 	.word	0x000005b8
    89b8:	000004bc 	.word	0x000004bc
    89bc:	000004d8 	.word	0x000004d8
    89c0:	2000e1af 	.word	0x2000e1af
    89c4:	000006f0 	.word	0x000006f0
    89c8:	000006f4 	.word	0x000006f4
    89cc:	2000e315 	.word	0x2000e315
    89d0:	00000740 	.word	0x00000740
    89d4:	000006bc 	.word	0x000006bc
    89d8:	000006f8 	.word	0x000006f8
    89dc:	00000700 	.word	0x00000700
    89e0:	00000708 	.word	0x00000708
    89e4:	0000070c 	.word	0x0000070c
    89e8:	00000710 	.word	0x00000710
    89ec:	2000e170 	.word	0x2000e170
    89f0:	2000e3b0 	.word	0x2000e3b0
    89f4:	0000076c 	.word	0x0000076c
    89f8:	2000e3e0 	.word	0x2000e3e0
    89fc:	2000e3e4 	.word	0x2000e3e4
            hostName = (uint8_t*)argv[2];
    8a00:	f8d9 7008 	ldr.w	r7, [r9, #8]
            if (hostName == 0)
    8a04:	b14f      	cbz	r7, 8a1a <_Command_DNS_Service+0x31a>
            if(strcmp((char*)hostName,(char*)"all")==0)
    8a06:	497b      	ldr	r1, [pc, #492]	; (8bf4 <_Command_DNS_Service+0x4f4>)
    8a08:	4638      	mov	r0, r7
    8a0a:	f019 f807 	bl	21a1c <strcmp>
    8a0e:	4680      	mov	r8, r0
    8a10:	b948      	cbnz	r0, 8a26 <_Command_DNS_Service+0x326>
                TCPIP_DNS_RemoveAll();
    8a12:	f013 fc03 	bl	1c21c <TCPIP_DNS_RemoveAll>
                    return false;
    8a16:	4644      	mov	r4, r8
    8a18:	e6a4      	b.n	8764 <_Command_DNS_Service+0x64>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown option\r\n");
    8a1a:	682b      	ldr	r3, [r5, #0]
    8a1c:	681b      	ldr	r3, [r3, #0]
    8a1e:	4976      	ldr	r1, [pc, #472]	; (8bf8 <_Command_DNS_Service+0x4f8>)
    8a20:	4630      	mov	r0, r6
    8a22:	4798      	blx	r3
                return false;
    8a24:	e69e      	b.n	8764 <_Command_DNS_Service+0x64>
                res = TCPIP_DNS_RemoveEntry((const char*)hostName);
    8a26:	4638      	mov	r0, r7
    8a28:	f015 f884 	bl	1db34 <TCPIP_DNS_RemoveEntry>
            switch(res)
    8a2c:	f110 0f06 	cmn.w	r0, #6
    8a30:	d00a      	beq.n	8a48 <_Command_DNS_Service+0x348>
    8a32:	f1b0 3fff 	cmp.w	r0, #4294967295
    8a36:	f47f ae95 	bne.w	8764 <_Command_DNS_Service+0x64>
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "[%s] not part of the DNS Cache entry \r\n",hostName);
    8a3a:	682b      	ldr	r3, [r5, #0]
    8a3c:	685b      	ldr	r3, [r3, #4]
    8a3e:	463a      	mov	r2, r7
    8a40:	496e      	ldr	r1, [pc, #440]	; (8bfc <_Command_DNS_Service+0x4fc>)
    8a42:	4630      	mov	r0, r6
    8a44:	4798      	blx	r3
                    return false;
    8a46:	e68d      	b.n	8764 <_Command_DNS_Service+0x64>
                    (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Incomplete command \r\n");
    8a48:	682b      	ldr	r3, [r5, #0]
    8a4a:	681b      	ldr	r3, [r3, #0]
    8a4c:	496c      	ldr	r1, [pc, #432]	; (8c00 <_Command_DNS_Service+0x500>)
    8a4e:	4630      	mov	r0, r6
    8a50:	4798      	blx	r3
                    return false;
    8a52:	e687      	b.n	8764 <_Command_DNS_Service+0x64>
    bool entryPresent= false;
    IPV6_ADDR   ipv6Addr[TCPIP_DNS_CLIENT_CACHE_PER_IPV6_ADDRESS];
    char        addrPrintBuff[44];
    const char* strictName, *prefName;

    if (argc != 2) {
    8a54:	f1b8 0f02 	cmp.w	r8, #2
    8a58:	d00e      	beq.n	8a78 <_Command_DNS_Service+0x378>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: dnsc info \r\n");
    8a5a:	4c6a      	ldr	r4, [pc, #424]	; (8c04 <_Command_DNS_Service+0x504>)
    8a5c:	682b      	ldr	r3, [r5, #0]
    8a5e:	681b      	ldr	r3, [r3, #0]
    8a60:	f504 61bc 	add.w	r1, r4, #1504	; 0x5e0
    8a64:	4630      	mov	r0, r6
    8a66:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: display the DNS cache entry details \r\n");
    8a68:	682b      	ldr	r3, [r5, #0]
    8a6a:	681b      	ldr	r3, [r3, #0]
    8a6c:	f204 51f4 	addw	r1, r4, #1524	; 0x5f4
    8a70:	4630      	mov	r0, r6
    8a72:	4798      	blx	r3
    return true;
    8a74:	2401      	movs	r4, #1
    8a76:	e675      	b.n	8764 <_Command_DNS_Service+0x64>
        return false;
    }


    dnsQuery.hostName = hostName;
    8a78:	ab27      	add	r3, sp, #156	; 0x9c
    8a7a:	931b      	str	r3, [sp, #108]	; 0x6c
    dnsQuery.nameLen = sizeof(hostName);
    8a7c:	2341      	movs	r3, #65	; 0x41
    8a7e:	931c      	str	r3, [sp, #112]	; 0x70
    dnsQuery.ipv4Entry = ipv4Addr;
    8a80:	ab0b      	add	r3, sp, #44	; 0x2c
    8a82:	931d      	str	r3, [sp, #116]	; 0x74
    dnsQuery.nIPv4Entries = sizeof(ipv4Addr) / sizeof(*ipv4Addr);
    8a84:	2305      	movs	r3, #5
    8a86:	931e      	str	r3, [sp, #120]	; 0x78

    dnsQuery.ipv6Entry = ipv6Addr;
    8a88:	ab02      	add	r3, sp, #8
    8a8a:	931f      	str	r3, [sp, #124]	; 0x7c
    dnsQuery.nIPv6Entries = sizeof(ipv6Addr) / sizeof(*ipv6Addr);
    8a8c:	2301      	movs	r3, #1
    8a8e:	9320      	str	r3, [sp, #128]	; 0x80

    res = TCPIP_DNS_ClientInfoGet(&clientInfo);
    8a90:	a806      	add	r0, sp, #24
    8a92:	f015 fe77 	bl	1e784 <TCPIP_DNS_ClientInfoGet>
    if(res != TCPIP_DNS_RES_OK)
    8a96:	b128      	cbz	r0, 8aa4 <_Command_DNS_Service+0x3a4>
    {
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "DNS Client is down!\r\n");
    8a98:	682b      	ldr	r3, [r5, #0]
    8a9a:	681b      	ldr	r3, [r3, #0]
    8a9c:	495a      	ldr	r1, [pc, #360]	; (8c08 <_Command_DNS_Service+0x508>)
    8a9e:	4630      	mov	r0, r6
    8aa0:	4798      	blx	r3
        return false;
    8aa2:	e7e7      	b.n	8a74 <_Command_DNS_Service+0x374>
    }

    strictName = TCPIP_STACK_NetNameGet(clientInfo.strictNet);
    8aa4:	9806      	ldr	r0, [sp, #24]
    8aa6:	f019 fb3e 	bl	22126 <TCPIP_STACK_NetNameGet>
    if(strictName == 0)
    {
        strictName = "none";
    8aaa:	2800      	cmp	r0, #0
    8aac:	4f57      	ldr	r7, [pc, #348]	; (8c0c <_Command_DNS_Service+0x50c>)
    8aae:	bf18      	it	ne
    8ab0:	4607      	movne	r7, r0
    }
    prefName = TCPIP_STACK_NetNameGet(clientInfo.prefNet);
    8ab2:	9807      	ldr	r0, [sp, #28]
    8ab4:	f019 fb37 	bl	22126 <TCPIP_STACK_NetNameGet>
    if(prefName == 0)
    {
        prefName = "none";
    8ab8:	2800      	cmp	r0, #0
    8aba:	4b54      	ldr	r3, [pc, #336]	; (8c0c <_Command_DNS_Service+0x50c>)
    8abc:	bf18      	it	ne
    8abe:	4603      	movne	r3, r0
    }

    (*pCmdIO->pCmdApi->print)(cmdIoParam, "DNS Client IF - Strict: %s, Preferred: %s\r\n", strictName, prefName);
    8ac0:	f8df 8140 	ldr.w	r8, [pc, #320]	; 8c04 <_Command_DNS_Service+0x504>
    8ac4:	682a      	ldr	r2, [r5, #0]
    8ac6:	f8d2 9004 	ldr.w	r9, [r2, #4]
    8aca:	463a      	mov	r2, r7
    8acc:	f208 613c 	addw	r1, r8, #1596	; 0x63c
    8ad0:	4630      	mov	r0, r6
    8ad2:	47c8      	blx	r9
    (*pCmdIO->pCmdApi->print)(cmdIoParam, "DNS Client - time: %d, pending: %d, current: %d, total: %d\r\n", clientInfo.dnsTime, clientInfo.pendingEntries, clientInfo.currentEntries, clientInfo.totalEntries);
    8ad4:	682b      	ldr	r3, [r5, #0]
    8ad6:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
    8ada:	9201      	str	r2, [sp, #4]
    8adc:	f8bd 2026 	ldrh.w	r2, [sp, #38]	; 0x26
    8ae0:	9200      	str	r2, [sp, #0]
    8ae2:	685f      	ldr	r7, [r3, #4]
    8ae4:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    8ae8:	9a08      	ldr	r2, [sp, #32]
    8aea:	f508 61cd 	add.w	r1, r8, #1640	; 0x668
    8aee:	4630      	mov	r0, r6
    8af0:	47b8      	blx	r7

    index = 0;
    8af2:	46a0      	mov	r8, r4
    bool entryPresent= false;
    8af4:	2700      	movs	r7, #0
    {
        res = TCPIP_DNS_EntryQuery(&dnsQuery, index);
        if(res == TCPIP_DNS_RES_OK)
        {
            entryPresent = true;
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Hostname = %s \r\nTimeout = %d \r\n", hostName, dnsQuery.ttlTime);
    8af6:	f8df 910c 	ldr.w	r9, [pc, #268]	; 8c04 <_Command_DNS_Service+0x504>
    8afa:	f509 6bd5 	add.w	fp, r9, #1704	; 0x6a8
        res = TCPIP_DNS_EntryQuery(&dnsQuery, index);
    8afe:	4641      	mov	r1, r8
    8b00:	a81b      	add	r0, sp, #108	; 0x6c
    8b02:	f008 ff07 	bl	11914 <TCPIP_DNS_EntryQuery>
        if(res == TCPIP_DNS_RES_OK)
    8b06:	2800      	cmp	r0, #0
    8b08:	d144      	bne.n	8b94 <_Command_DNS_Service+0x494>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Hostname = %s \r\nTimeout = %d \r\n", hostName, dnsQuery.ttlTime);
    8b0a:	682b      	ldr	r3, [r5, #0]
    8b0c:	685f      	ldr	r7, [r3, #4]
    8b0e:	9b22      	ldr	r3, [sp, #136]	; 0x88
    8b10:	aa27      	add	r2, sp, #156	; 0x9c
    8b12:	4659      	mov	r1, fp
    8b14:	4630      	mov	r0, r6
    8b16:	47b8      	blx	r7
            if(dnsQuery.nIPv4ValidEntries > 0)
    8b18:	9b25      	ldr	r3, [sp, #148]	; 0x94
    8b1a:	2b00      	cmp	r3, #0
    8b1c:	dc0d      	bgt.n	8b3a <_Command_DNS_Service+0x43a>
                {                    
                    TCPIP_Helper_IPAddressToString(dnsQuery.ipv4Entry + ix, addrPrintBuff, sizeof(addrPrintBuff)); 
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv4 =%s\r\n", addrPrintBuff);
                }
            }
            if(dnsQuery.nIPv6Entries > 0)
    8b1e:	9b20      	ldr	r3, [sp, #128]	; 0x80
    8b20:	2b00      	cmp	r3, #0
    8b22:	dc1f      	bgt.n	8b64 <_Command_DNS_Service+0x464>
                {
                    TCPIP_Helper_IPv6AddressToString(dnsQuery.ipv6Entry + ix, addrPrintBuff, sizeof(addrPrintBuff));                   
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv6 = %s\r\n",addrPrintBuff);
                }
            }
            (*pCmdIO->pCmdApi->print)(cmdIoParam,"----------------------------------------------------\r\n",0);
    8b24:	682b      	ldr	r3, [r5, #0]
    8b26:	685b      	ldr	r3, [r3, #4]
    8b28:	2200      	movs	r2, #0
    8b2a:	f509 61dc 	add.w	r1, r9, #1760	; 0x6e0
    8b2e:	4630      	mov	r0, r6
    8b30:	4798      	blx	r3
            entryPresent = true;
    8b32:	2701      	movs	r7, #1
        }
        if(res == TCPIP_DNS_RES_OK || res == TCPIP_DNS_RES_PENDING || res == TCPIP_DNS_RES_EMPTY_IX_ENTRY)
        {
            index++;
    8b34:	f108 0801 	add.w	r8, r8, #1
            continue;
    8b38:	e7e1      	b.n	8afe <_Command_DNS_Service+0x3fe>
                for(ix = 0; ix < dnsQuery.nIPv4ValidEntries; ix++)
    8b3a:	4627      	mov	r7, r4
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv4 =%s\r\n", addrPrintBuff);
    8b3c:	f509 6ad9 	add.w	sl, r9, #1736	; 0x6c8
                    TCPIP_Helper_IPAddressToString(dnsQuery.ipv4Entry + ix, addrPrintBuff, sizeof(addrPrintBuff)); 
    8b40:	222c      	movs	r2, #44	; 0x2c
    8b42:	a910      	add	r1, sp, #64	; 0x40
    8b44:	981d      	ldr	r0, [sp, #116]	; 0x74
    8b46:	eb00 0087 	add.w	r0, r0, r7, lsl #2
    8b4a:	f013 ffa3 	bl	1ca94 <TCPIP_Helper_IPAddressToString>
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv4 =%s\r\n", addrPrintBuff);
    8b4e:	682b      	ldr	r3, [r5, #0]
    8b50:	685b      	ldr	r3, [r3, #4]
    8b52:	aa10      	add	r2, sp, #64	; 0x40
    8b54:	4651      	mov	r1, sl
    8b56:	4630      	mov	r0, r6
    8b58:	4798      	blx	r3
                for(ix = 0; ix < dnsQuery.nIPv4ValidEntries; ix++)
    8b5a:	3701      	adds	r7, #1
    8b5c:	9b25      	ldr	r3, [sp, #148]	; 0x94
    8b5e:	429f      	cmp	r7, r3
    8b60:	dbee      	blt.n	8b40 <_Command_DNS_Service+0x440>
    8b62:	e7dc      	b.n	8b1e <_Command_DNS_Service+0x41e>
                for(ix = 0; ix < dnsQuery.nIPv6ValidEntries; ix++)
    8b64:	9b26      	ldr	r3, [sp, #152]	; 0x98
    8b66:	2b00      	cmp	r3, #0
    8b68:	dddc      	ble.n	8b24 <_Command_DNS_Service+0x424>
    8b6a:	4627      	mov	r7, r4
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv6 = %s\r\n",addrPrintBuff);
    8b6c:	f209 6ad4 	addw	sl, r9, #1748	; 0x6d4
                    TCPIP_Helper_IPv6AddressToString(dnsQuery.ipv6Entry + ix, addrPrintBuff, sizeof(addrPrintBuff));                   
    8b70:	222c      	movs	r2, #44	; 0x2c
    8b72:	a910      	add	r1, sp, #64	; 0x40
    8b74:	981f      	ldr	r0, [sp, #124]	; 0x7c
    8b76:	eb00 1007 	add.w	r0, r0, r7, lsl #4
    8b7a:	f00e fea8 	bl	178ce <TCPIP_Helper_IPv6AddressToString>
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv6 = %s\r\n",addrPrintBuff);
    8b7e:	682b      	ldr	r3, [r5, #0]
    8b80:	685b      	ldr	r3, [r3, #4]
    8b82:	aa10      	add	r2, sp, #64	; 0x40
    8b84:	4651      	mov	r1, sl
    8b86:	4630      	mov	r0, r6
    8b88:	4798      	blx	r3
                for(ix = 0; ix < dnsQuery.nIPv6ValidEntries; ix++)
    8b8a:	3701      	adds	r7, #1
    8b8c:	9b26      	ldr	r3, [sp, #152]	; 0x98
    8b8e:	429f      	cmp	r7, r3
    8b90:	dbee      	blt.n	8b70 <_Command_DNS_Service+0x470>
    8b92:	e7c7      	b.n	8b24 <_Command_DNS_Service+0x424>
        if(res == TCPIP_DNS_RES_OK || res == TCPIP_DNS_RES_PENDING || res == TCPIP_DNS_RES_EMPTY_IX_ENTRY)
    8b94:	b2c2      	uxtb	r2, r0
    8b96:	2a01      	cmp	r2, #1
    8b98:	d9cc      	bls.n	8b34 <_Command_DNS_Service+0x434>
    8b9a:	f110 0f04 	cmn.w	r0, #4
    8b9e:	d0c9      	beq.n	8b34 <_Command_DNS_Service+0x434>
        }

        // some error
        if(entryPresent == false)
    8ba0:	2f00      	cmp	r7, #0
    8ba2:	f47f af67 	bne.w	8a74 <_Command_DNS_Service+0x374>
        {
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "No DNS Client Cache entries \r\n");
    8ba6:	682b      	ldr	r3, [r5, #0]
    8ba8:	681b      	ldr	r3, [r3, #0]
    8baa:	4919      	ldr	r1, [pc, #100]	; (8c10 <_Command_DNS_Service+0x510>)
    8bac:	4630      	mov	r0, r6
    8bae:	4798      	blx	r3
    8bb0:	e760      	b.n	8a74 <_Command_DNS_Service+0x374>
    TCPIP_DNS_ENABLE_FLAGS enableFlags = TCPIP_DNS_ENABLE_DEFAULT;
    8bb2:	2100      	movs	r1, #0
        addRes = TCPIP_DNS_Enable(netH, enableFlags);
    8bb4:	4638      	mov	r0, r7
    8bb6:	f019 fa21 	bl	21ffc <TCPIP_DNS_Enable>
        msgFail = "enable";
    8bba:	4b12      	ldr	r3, [pc, #72]	; (8c04 <_Command_DNS_Service+0x504>)
    8bbc:	f503 72e8 	add.w	r2, r3, #464	; 0x1d0
        msgOK   = "enabled";
    8bc0:	f503 73e4 	add.w	r3, r3, #456	; 0x1c8
    if(addRes)
    8bc4:	2800      	cmp	r0, #0
    8bc6:	f43f ae3a 	beq.w	883e <_Command_DNS_Service+0x13e>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "%s %s\r\n", argv[0], msgOK);
    8bca:	682a      	ldr	r2, [r5, #0]
    8bcc:	6854      	ldr	r4, [r2, #4]
    8bce:	f8d9 2000 	ldr.w	r2, [r9]
    8bd2:	4910      	ldr	r1, [pc, #64]	; (8c14 <_Command_DNS_Service+0x514>)
    8bd4:	4630      	mov	r0, r6
    8bd6:	47a0      	blx	r4
    return true;
    8bd8:	2401      	movs	r4, #1
    8bda:	e5c3      	b.n	8764 <_Command_DNS_Service+0x64>
                enableFlags = TCPIP_DNS_ENABLE_STRICT;
    8bdc:	2101      	movs	r1, #1
    8bde:	e7e9      	b.n	8bb4 <_Command_DNS_Service+0x4b4>
    bool             clearCache = false;
    8be0:	2100      	movs	r1, #0
        addRes = TCPIP_DNS_Disable(netH, clearCache);
    8be2:	4638      	mov	r0, r7
    8be4:	f011 feb8 	bl	1a958 <TCPIP_DNS_Disable>
        msgFail = "disable";
    8be8:	4b06      	ldr	r3, [pc, #24]	; (8c04 <_Command_DNS_Service+0x504>)
    8bea:	f503 72e0 	add.w	r2, r3, #448	; 0x1c0
        msgOK   = "disabled";
    8bee:	f503 73da 	add.w	r3, r3, #436	; 0x1b4
    8bf2:	e7e7      	b.n	8bc4 <_Command_DNS_Service+0x4c4>
    8bf4:	00000828 	.word	0x00000828
    8bf8:	000004bc 	.word	0x000004bc
    8bfc:	0000082c 	.word	0x0000082c
    8c00:	00000854 	.word	0x00000854
    8c04:	0000028c 	.word	0x0000028c
    8c08:	000008b0 	.word	0x000008b0
    8c0c:	00000504 	.word	0x00000504
    8c10:	000009a4 	.word	0x000009a4
    8c14:	000004d0 	.word	0x000004d0

Disassembly of section .text.TCPIP_DHCP_Task%194:

00008c18 <TCPIP_DHCP_Task>:
    return false;
}


void TCPIP_DHCP_Task(void)
{
    8c18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8c1c:	b087      	sub	sp, #28
    TCPIP_MODULE_SIGNAL sigPend;
    bool                isTmo = false;

    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    8c1e:	210f      	movs	r1, #15
    8c20:	200c      	movs	r0, #12
    8c22:	f015 fad3 	bl	1e1cc <_TCPIPStackModuleSignalGet>

    if((sigPend & TCPIP_MODULE_SIGNAL_TMO) != 0)
    8c26:	f010 0f02 	tst.w	r0, #2
    8c2a:	f040 822c 	bne.w	9086 <TCPIP_DHCP_Task+0x46e>
    { // regular TMO occurred
        isTmo = true;
    }

    if(isTmo || (sigPend & TCPIP_MODULE_SIGNAL_RX_PENDING) != 0)
    8c2e:	f010 0f01 	tst.w	r0, #1
    8c32:	f000 8225 	beq.w	9080 <TCPIP_DHCP_Task+0x468>
    if(isTmo)
    {   // update DHCP time keeping
        _DHCPSecondCountSet();
    }

    nNets = TCPIP_STACK_NumberOfNetworksGet();
    8c36:	f019 f9ed 	bl	22014 <TCPIP_STACK_NumberOfNetworksGet>
    for(netIx = 0; netIx < nNets; netIx++) 
    8c3a:	f1b0 0900 	subs.w	r9, r0, #0
    8c3e:	f340 821a 	ble.w	9076 <TCPIP_DHCP_Task+0x45e>
    8c42:	2500      	movs	r5, #0
        if(!TCPIP_STACK_NetworkIsUp(pNetIf))
        {   // inactive interface
            continue;
        }

        pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf); 
    8c44:	f8df a3e8 	ldr.w	sl, [pc, #1000]	; 9030 <TCPIP_DHCP_Task+0x418>
    8c48:	f04f 0b5c 	mov.w	fp, #92	; 0x5c
    8c4c:	e13d      	b.n	8eca <TCPIP_DHCP_Task+0x2b2>
    {   // don't have a current lease
        if(pClient->flags.bReportFail && pClient->tOpStart != 0)
        {
            if((_DHCPSecondCountGet() - pClient->tOpStart) >= pClient->tOpFailTmo)
            {   // initialization time out
                TCPIP_STACK_AddressServiceEvent(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_DHCPC, TCPIP_STACK_ADDRESS_SERVICE_EVENT_RUN_FAIL);
    8c4e:	2201      	movs	r2, #1
    8c50:	4611      	mov	r1, r2
    8c52:	4630      	mov	r0, r6
    8c54:	f014 fcdc 	bl	1d610 <TCPIP_STACK_AddressServiceEvent>
                _DHCPDbgAddServiceEvent(pClient, TCPIP_STACK_ADDRESS_SERVICE_EVENT_RUN_FAIL, "init tmo");
                pClient->flags.bReportFail = 0;   // reported
    8c58:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
    8c5c:	f36f 1345 	bfc	r3, #5, #1
    8c60:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    8c64:	e15d      	b.n	8f22 <TCPIP_DHCP_Task+0x30a>
                if(!TCPIP_STACK_NetworkIsLinked(pNetIf))
    8c66:	4630      	mov	r0, r6
    8c68:	f018 f87e 	bl	20d68 <TCPIP_STACK_NetworkIsLinked>
    8c6c:	2800      	cmp	r0, #0
    8c6e:	f000 8128 	beq.w	8ec2 <TCPIP_DHCP_Task+0x2aa>
                if(pClient->dhcpOp == TCPIP_DHCP_OPER_INIT_REBOOT)
    8c72:	f8b4 3054 	ldrh.w	r3, [r4, #84]	; 0x54
    8c76:	2b02      	cmp	r3, #2
    8c78:	d00d      	beq.n	8c96 <TCPIP_DHCP_Task+0x7e>
                else if(pClient->dhcpOp == TCPIP_DHCP_OPER_RENEW)
    8c7a:	2b03      	cmp	r3, #3
    pClient->smState = newState;
    8c7c:	bf0c      	ite	eq
    8c7e:	2309      	moveq	r3, #9
    8c80:	2302      	movne	r3, #2
    8c82:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    if(pClient->dhcpFilterHandle != 0)
    8c86:	6ca0      	ldr	r0, [r4, #72]	; 0x48
    8c88:	2800      	cmp	r0, #0
    8c8a:	f000 811a 	beq.w	8ec2 <TCPIP_DHCP_Task+0x2aa>
        Ipv4FilterSetActive(pClient->dhcpFilterHandle, active);
    8c8e:	2101      	movs	r1, #1
    8c90:	f012 fc3e 	bl	1b510 <Ipv4FilterSetActive>
    8c94:	e115      	b.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
    pClient->smState = newState;
    8c96:	2304      	movs	r3, #4
    8c98:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    8c9c:	e7f3      	b.n	8c86 <TCPIP_DHCP_Task+0x6e>
                _DHCPSetLeaseTimeParams(pClient, 0);
    8c9e:	2100      	movs	r1, #0
    8ca0:	4620      	mov	r0, r4
    8ca2:	f010 f863 	bl	18d6c <_DHCPSetLeaseTimeParams>
                pClient->validValues.val = 0x00;
    8ca6:	2200      	movs	r2, #0
    8ca8:	f884 2059 	strb.w	r2, [r4, #89]	; 0x59
                pClient->flags.bIsBound = false;	
    8cac:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
                pClient->flags.bOfferReceived = false;
    8cb0:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    8cb4:	f362 0382 	bfi	r3, r2, #2, #1
    8cb8:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
                pClient->serverAddress.Val = 0;
    8cbc:	62a2      	str	r2, [r4, #40]	; 0x28
                if(!_DHCPSend(pClient, pNetIf, TCPIP_DHCP_DISCOVER_MESSAGE, TCPIP_DHCP_FLAG_SEND_ZERO_ADD | TCPIP_DHCP_FLAG_SEND_BCAST))
    8cbe:	2303      	movs	r3, #3
    8cc0:	2201      	movs	r2, #1
    8cc2:	4631      	mov	r1, r6
    8cc4:	4620      	mov	r0, r4
    8cc6:	f006 ff97 	bl	fbf8 <_DHCPSend>
    8cca:	2800      	cmp	r0, #0
    8ccc:	f000 80f9 	beq.w	8ec2 <TCPIP_DHCP_Task+0x2aa>
                _DHCPNotifyClients(pNetIf, DHCP_EVENT_DISCOVER);
    8cd0:	2101      	movs	r1, #1
    8cd2:	4630      	mov	r0, r6
    8cd4:	f015 fa3e 	bl	1e154 <_DHCPNotifyClients>
                _DHCPSetTimeout(pClient);
    8cd8:	4620      	mov	r0, r4
    8cda:	f016 fce5 	bl	1f6a8 <_DHCPSetTimeout>
    pClient->smState = newState;
    8cde:	2303      	movs	r3, #3
    8ce0:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    8ce4:	e0ed      	b.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
                recvMsg = _DHCPProcessReceiveData(pClient, pNetIf);
    8ce6:	4631      	mov	r1, r6
    8ce8:	4620      	mov	r0, r4
    8cea:	f00e fd4d 	bl	17788 <_DHCPProcessReceiveData>
                if(recvMsg == TCPIP_DHCP_TIMEOUT_MESSAGE)
    8cee:	280a      	cmp	r0, #10
    8cf0:	d02a      	beq.n	8d48 <TCPIP_DHCP_Task+0x130>
                else if(recvMsg != TCPIP_DHCP_UNKNOWN_MESSAGE)
    8cf2:	2800      	cmp	r0, #0
    8cf4:	f000 80e5 	beq.w	8ec2 <TCPIP_DHCP_Task+0x2aa>
                    pClient->flags.bDHCPServerDetected = true;
    8cf8:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
    8cfc:	f043 0308 	orr.w	r3, r3, #8
    8d00:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
                if(recvMsg != TCPIP_DHCP_OFFER_MESSAGE)
    8d04:	2802      	cmp	r0, #2
    8d06:	f040 80dc 	bne.w	8ec2 <TCPIP_DHCP_Task+0x2aa>
    pClient->smState = newState;
    8d0a:	2304      	movs	r3, #4
    8d0c:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
                if(!_DHCPSend(pClient, pNetIf, TCPIP_DHCP_REQUEST_MESSAGE, (pClient->dhcpOp == TCPIP_DHCP_OPER_INIT_REBOOT) ? TCPIP_DHCP_FLAG_SEND_BCAST : TCPIP_DHCP_FLAG_SEND_ZERO_ADD | TCPIP_DHCP_FLAG_SEND_BCAST))
    8d10:	f8b4 3054 	ldrh.w	r3, [r4, #84]	; 0x54
    8d14:	2b02      	cmp	r3, #2
    8d16:	9b01      	ldr	r3, [sp, #4]
    8d18:	bf18      	it	ne
    8d1a:	2303      	movne	r3, #3
    8d1c:	2203      	movs	r2, #3
    8d1e:	4631      	mov	r1, r6
    8d20:	4620      	mov	r0, r4
    8d22:	f006 ff69 	bl	fbf8 <_DHCPSend>
    8d26:	2800      	cmp	r0, #0
    8d28:	f000 80cb 	beq.w	8ec2 <TCPIP_DHCP_Task+0x2aa>
                pClient->tRequest = _DHCPSecondCountGet();
    8d2c:	4bbf      	ldr	r3, [pc, #764]	; (902c <TCPIP_DHCP_Task+0x414>)
    8d2e:	681b      	ldr	r3, [r3, #0]
    8d30:	60a3      	str	r3, [r4, #8]
                _DHCPNotifyClients(pNetIf, DHCP_EVENT_REQUEST);
    8d32:	2102      	movs	r1, #2
    8d34:	4630      	mov	r0, r6
    8d36:	f015 fa0d 	bl	1e154 <_DHCPNotifyClients>
                _DHCPSetTimeout(pClient);
    8d3a:	4620      	mov	r0, r4
    8d3c:	f016 fcb4 	bl	1f6a8 <_DHCPSetTimeout>
    pClient->smState = newState;
    8d40:	2305      	movs	r3, #5
    8d42:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    8d46:	e0bc      	b.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
                    if((SYS_TMR_TickCountGet() - pClient->startWait) >= pClient->waitTicks)
    8d48:	f017 f9d0 	bl	200ec <SYS_TMR_TickCountGet>
    8d4c:	6863      	ldr	r3, [r4, #4]
    8d4e:	1ac3      	subs	r3, r0, r3
    8d50:	f858 2007 	ldr.w	r2, [r8, r7]
    8d54:	4293      	cmp	r3, r2
    8d56:	f0c0 80b4 	bcc.w	8ec2 <TCPIP_DHCP_Task+0x2aa>
                        _DHCPSetRunFail(pClient, TCPIP_DHCP_SEND_DISCOVERY, true);  
    8d5a:	2201      	movs	r2, #1
    8d5c:	2102      	movs	r1, #2
    8d5e:	4620      	mov	r0, r4
    8d60:	f013 fe72 	bl	1ca48 <_DHCPSetRunFail>
                        _DHCPNotifyClients(pNetIf, DHCP_EVENT_TIMEOUT);
    8d64:	2107      	movs	r1, #7
    8d66:	4630      	mov	r0, r6
    8d68:	f015 f9f4 	bl	1e154 <_DHCPNotifyClients>
    8d6c:	e0a9      	b.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
                if(_DHCPProcessReceiveData(pClient, pNetIf) == TCPIP_DHCP_TIMEOUT_MESSAGE)
    8d6e:	4631      	mov	r1, r6
    8d70:	4620      	mov	r0, r4
    8d72:	f00e fd09 	bl	17788 <_DHCPProcessReceiveData>
    8d76:	280a      	cmp	r0, #10
    8d78:	f040 80a3 	bne.w	8ec2 <TCPIP_DHCP_Task+0x2aa>
                    if((SYS_TMR_TickCountGet() - pClient->startWait) >= pClient->waitTicks)
    8d7c:	f017 f9b6 	bl	200ec <SYS_TMR_TickCountGet>
    8d80:	6863      	ldr	r3, [r4, #4]
    8d82:	1ac3      	subs	r3, r0, r3
    8d84:	f858 2007 	ldr.w	r2, [r8, r7]
    8d88:	4293      	cmp	r3, r2
    8d8a:	f0c0 809a 	bcc.w	8ec2 <TCPIP_DHCP_Task+0x2aa>
                        _DHCPSetRunFail(pClient, TCPIP_DHCP_SEND_DISCOVERY, true);
    8d8e:	2201      	movs	r2, #1
    8d90:	2102      	movs	r1, #2
    8d92:	4620      	mov	r0, r4
    8d94:	f013 fe58 	bl	1ca48 <_DHCPSetRunFail>
                        _DHCPNotifyClients(pNetIf, DHCP_EVENT_TIMEOUT);
    8d98:	2107      	movs	r1, #7
    8d9a:	4630      	mov	r0, r6
    8d9c:	f015 f9da 	bl	1e154 <_DHCPNotifyClients>
    8da0:	e08f      	b.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
                    arpCheck.Val = pClient->dhcpIPAddress.Val;
    8da2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    8da4:	9302      	str	r3, [sp, #8]
                    if(TCPIP_ARP_IsResolved(pNetIf, &arpCheck, 0))
    8da6:	2200      	movs	r2, #0
    8da8:	a902      	add	r1, sp, #8
    8daa:	4630      	mov	r0, r6
    8dac:	f00f fbfa 	bl	185a4 <TCPIP_ARP_IsResolved>
    8db0:	2800      	cmp	r0, #0
    8db2:	f040 8177 	bne.w	90a4 <TCPIP_DHCP_Task+0x48c>
                    else if((_DHCPSecondCountGet() - pClient->startWait) >= pClient->tLeaseCheck)
    8db6:	4b9d      	ldr	r3, [pc, #628]	; (902c <TCPIP_DHCP_Task+0x414>)
    8db8:	681b      	ldr	r3, [r3, #0]
    8dba:	6862      	ldr	r2, [r4, #4]
    8dbc:	1a9b      	subs	r3, r3, r2
    8dbe:	f8b4 2052 	ldrh.w	r2, [r4, #82]	; 0x52
    8dc2:	4293      	cmp	r3, r2
    8dc4:	d37d      	bcc.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
    oldNetIp.Val = TCPIP_STACK_NetAddressGet(pNetIf);
    8dc6:	4630      	mov	r0, r6
    8dc8:	f018 fbd4 	bl	21574 <TCPIP_STACK_NetAddressGet>
    8dcc:	9003      	str	r0, [sp, #12]
    oldNetMask.Val = TCPIP_STACK_NetMaskGet(pNetIf);
    8dce:	4630      	mov	r0, r6
    8dd0:	f018 fbdc 	bl	2158c <TCPIP_STACK_NetMaskGet>
    8dd4:	9004      	str	r0, [sp, #16]
    _TCPIPStackSetConfigAddress(pNetIf, &pClient->dhcpIPAddress, &pClient->dhcpMask, false);
    8dd6:	f104 072c 	add.w	r7, r4, #44	; 0x2c
    8dda:	2300      	movs	r3, #0
    8ddc:	f104 0234 	add.w	r2, r4, #52	; 0x34
    8de0:	4639      	mov	r1, r7
    8de2:	4630      	mov	r0, r6
    8de4:	f015 fdff 	bl	1e9e6 <_TCPIPStackSetConfigAddress>
    if(pClient->validValues.Gateway)
    8de8:	f894 3059 	ldrb.w	r3, [r4, #89]	; 0x59
    8dec:	f013 0f02 	tst.w	r3, #2
    8df0:	d136      	bne.n	8e60 <TCPIP_DHCP_Task+0x248>
    if(pNetIf->Flags.bIsDNSServerAuto != 0)
    8df2:	f896 3042 	ldrb.w	r3, [r6, #66]	; 0x42
    8df6:	f013 0f20 	tst.w	r3, #32
    8dfa:	d011      	beq.n	8e20 <TCPIP_DHCP_Task+0x208>
        if(pClient->validValues.DNS)
    8dfc:	f894 3059 	ldrb.w	r3, [r4, #89]	; 0x59
    8e00:	f013 0f08 	tst.w	r3, #8
    8e04:	d132      	bne.n	8e6c <TCPIP_DHCP_Task+0x254>
        if(pClient->validValues.DNS2)
    8e06:	f894 3059 	ldrb.w	r3, [r4, #89]	; 0x59
    8e0a:	f013 0f10 	tst.w	r3, #16
            TCPIP_STACK_SecondaryDNSAddressSet(pNetIf, &pClient->dhcpDNS2);
    8e0e:	bf11      	iteee	ne
    8e10:	f104 013c 	addne.w	r1, r4, #60	; 0x3c
            IPV4_ADDR zeroAdd = {0};
    8e14:	2300      	moveq	r3, #0
    8e16:	9305      	streq	r3, [sp, #20]
            TCPIP_STACK_SecondaryDNSAddressSet(pNetIf, &zeroAdd);
    8e18:	a905      	addeq	r1, sp, #20
    8e1a:	4630      	mov	r0, r6
    8e1c:	f019 f9a7 	bl	2216e <TCPIP_STACK_SecondaryDNSAddressSet>
    TCPIP_STACK_AddressServiceEvent(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_DHCPC, TCPIP_STACK_ADDRESS_SERVICE_EVENT_RUN_RESTORE); 
    8e20:	2204      	movs	r2, #4
    8e22:	2101      	movs	r1, #1
    8e24:	4630      	mov	r0, r6
    8e26:	f014 fbf3 	bl	1d610 <TCPIP_STACK_AddressServiceEvent>
    TCPIP_ARP_Probe(pNetIf, &pClient->dhcpIPAddress, &pClient->dhcpIPAddress, ARP_OPERATION_RESP | ARP_OPERATION_CONFIGURE | ARP_OPERATION_PROBE_ONLY);
    8e2a:	f245 0302 	movw	r3, #20482	; 0x5002
    8e2e:	463a      	mov	r2, r7
    8e30:	4639      	mov	r1, r7
    8e32:	4630      	mov	r0, r6
    8e34:	f012 fda6 	bl	1b984 <TCPIP_ARP_Probe>
    if((pClient->dhcpIPAddress.Val & pClient->dhcpMask.Val) != (oldNetIp.Val & oldNetMask.Val))
    8e38:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    8e3a:	6b62      	ldr	r2, [r4, #52]	; 0x34
    8e3c:	401a      	ands	r2, r3
    8e3e:	9b03      	ldr	r3, [sp, #12]
    8e40:	9904      	ldr	r1, [sp, #16]
    8e42:	400b      	ands	r3, r1
    8e44:	429a      	cmp	r2, r3
    8e46:	d117      	bne.n	8e78 <TCPIP_DHCP_Task+0x260>
    _DHCPSetBoundState(pClient);
    8e48:	4620      	mov	r0, r4
    8e4a:	f014 fe33 	bl	1dab4 <_DHCPSetBoundState>
    _DHCPNotifyClients(pNetIf, DHCP_EVENT_BOUND);
    8e4e:	2108      	movs	r1, #8
    8e50:	4630      	mov	r0, r6
    8e52:	f015 f97f 	bl	1e154 <_DHCPNotifyClients>
                        TCPIP_ARP_EntryRemove(pNetIf,  &arpCheck);
    8e56:	a902      	add	r1, sp, #8
    8e58:	4630      	mov	r0, r6
    8e5a:	f011 f8df 	bl	1a01c <TCPIP_ARP_EntryRemove>
                break;
    8e5e:	e030      	b.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
        TCPIP_STACK_GatewayAddressSet(pNetIf, &pClient->dhcpGateway);
    8e60:	f104 0130 	add.w	r1, r4, #48	; 0x30
    8e64:	4630      	mov	r0, r6
    8e66:	f019 f97a 	bl	2215e <TCPIP_STACK_GatewayAddressSet>
    8e6a:	e7c2      	b.n	8df2 <TCPIP_DHCP_Task+0x1da>
            TCPIP_STACK_PrimaryDNSAddressSet(pNetIf, &pClient->dhcpDNS);
    8e6c:	f104 0138 	add.w	r1, r4, #56	; 0x38
    8e70:	4630      	mov	r0, r6
    8e72:	f019 f978 	bl	22166 <TCPIP_STACK_PrimaryDNSAddressSet>
    8e76:	e7c6      	b.n	8e06 <TCPIP_DHCP_Task+0x1ee>
        TCPIP_ARP_EntryRemoveNet(pNetIf, &oldNetIp, &oldNetMask, ARP_ENTRY_TYPE_ANY);
    8e78:	2304      	movs	r3, #4
    8e7a:	aa04      	add	r2, sp, #16
    8e7c:	a903      	add	r1, sp, #12
    8e7e:	4630      	mov	r0, r6
    8e80:	f00b fd78 	bl	14974 <TCPIP_ARP_EntryRemoveNet>
    8e84:	e7e0      	b.n	8e48 <TCPIP_DHCP_Task+0x230>
                if((_DHCPSecondCountGet() - pClient->startWait) >= TCPIP_DHCP_WAIT_FAIL_CHECK_TMO)
    8e86:	4b69      	ldr	r3, [pc, #420]	; (902c <TCPIP_DHCP_Task+0x414>)
    8e88:	681b      	ldr	r3, [r3, #0]
    8e8a:	6862      	ldr	r2, [r4, #4]
    8e8c:	1a9b      	subs	r3, r3, r2
    8e8e:	2b09      	cmp	r3, #9
    8e90:	d917      	bls.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
                    _DHCPSetRunFail(pClient, TCPIP_DHCP_SEND_DISCOVERY, false);
    8e92:	2200      	movs	r2, #0
    8e94:	2102      	movs	r1, #2
    8e96:	4620      	mov	r0, r4
    8e98:	f013 fdd6 	bl	1ca48 <_DHCPSetRunFail>
    8e9c:	e011      	b.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
                if((_DHCPSecondCountGet() - pClient->tRequest) < pClient->t1Seconds)
    8e9e:	4b63      	ldr	r3, [pc, #396]	; (902c <TCPIP_DHCP_Task+0x414>)
    8ea0:	681b      	ldr	r3, [r3, #0]
    8ea2:	68a2      	ldr	r2, [r4, #8]
    8ea4:	1a9b      	subs	r3, r3, r2
    8ea6:	6922      	ldr	r2, [r4, #16]
    8ea8:	4293      	cmp	r3, r2
    8eaa:	d30a      	bcc.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
    pClient->smState = newState;
    8eac:	2309      	movs	r3, #9
    8eae:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
                if(!_DHCPSend(pClient, pNetIf, TCPIP_DHCP_REQUEST_RENEW_MESSAGE, 0))
    8eb2:	2300      	movs	r3, #0
    8eb4:	2209      	movs	r2, #9
    8eb6:	4631      	mov	r1, r6
    8eb8:	4620      	mov	r0, r4
    8eba:	f006 fe9d 	bl	fbf8 <_DHCPSend>
    8ebe:	2800      	cmp	r0, #0
    8ec0:	d150      	bne.n	8f64 <TCPIP_DHCP_Task+0x34c>
    for(netIx = 0; netIx < nNets; netIx++) 
    8ec2:	3501      	adds	r5, #1
    8ec4:	45a9      	cmp	r9, r5
    8ec6:	f000 80d6 	beq.w	9076 <TCPIP_DHCP_Task+0x45e>
        pNetIf = (TCPIP_NET_IF*)TCPIP_STACK_IndexToNet (netIx);
    8eca:	4628      	mov	r0, r5
    8ecc:	f017 f846 	bl	1ff5c <TCPIP_STACK_IndexToNet>
TCPIP_NET_IF*  TCPIP_Stack_UserHandleToNet(TCPIP_NET_HANDLE hNet);


static __inline__ bool  __attribute__((always_inline)) TCPIP_STACK_NetworkIsUp(TCPIP_NET_IF* pNetIf)
{
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
    8ed0:	4606      	mov	r6, r0
    8ed2:	2800      	cmp	r0, #0
    8ed4:	d0f5      	beq.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
    8ed6:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
    8eda:	f013 0f40 	tst.w	r3, #64	; 0x40
    8ede:	d0f0      	beq.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
        pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf); 
    8ee0:	f8da 8000 	ldr.w	r8, [sl]
    8ee4:	f018 ff1e 	bl	21d24 <TCPIP_STACK_NetIxGet>
    8ee8:	fb0b f700 	mul.w	r7, fp, r0
    8eec:	eb08 0407 	add.w	r4, r8, r7
        if(pClient->flags.bDHCPEnabled == false)
    8ef0:	f894 2058 	ldrb.w	r2, [r4, #88]	; 0x58
    8ef4:	f012 0301 	ands.w	r3, r2, #1
    8ef8:	9301      	str	r3, [sp, #4]
    8efa:	d0e2      	beq.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
    if(pClient->smState > TCPIP_DHCP_WAIT_LINK && pClient->smState < TCPIP_DHCP_BOUND)
    8efc:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
    8f00:	3b02      	subs	r3, #2
    8f02:	b29b      	uxth	r3, r3
    8f04:	2b05      	cmp	r3, #5
    8f06:	d80c      	bhi.n	8f22 <TCPIP_DHCP_Task+0x30a>
        if(pClient->flags.bReportFail && pClient->tOpStart != 0)
    8f08:	f012 0f20 	tst.w	r2, #32
    8f0c:	d009      	beq.n	8f22 <TCPIP_DHCP_Task+0x30a>
    8f0e:	6a23      	ldr	r3, [r4, #32]
    8f10:	b13b      	cbz	r3, 8f22 <TCPIP_DHCP_Task+0x30a>
            if((_DHCPSecondCountGet() - pClient->tOpStart) >= pClient->tOpFailTmo)
    8f12:	4a46      	ldr	r2, [pc, #280]	; (902c <TCPIP_DHCP_Task+0x414>)
    8f14:	6812      	ldr	r2, [r2, #0]
    8f16:	1ad3      	subs	r3, r2, r3
    8f18:	f8b4 2050 	ldrh.w	r2, [r4, #80]	; 0x50
    8f1c:	4293      	cmp	r3, r2
    8f1e:	f4bf ae96 	bcs.w	8c4e <TCPIP_DHCP_Task+0x36>
        switch(pClient->smState)
    8f22:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
    8f26:	3b01      	subs	r3, #1
    8f28:	2b0b      	cmp	r3, #11
    8f2a:	d8ca      	bhi.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
    8f2c:	a201      	add	r2, pc, #4	; (adr r2, 8f34 <TCPIP_DHCP_Task+0x31c>)
    8f2e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    8f32:	bf00      	nop
    8f34:	00008c67 	.word	0x00008c67
    8f38:	00008c9f 	.word	0x00008c9f
    8f3c:	00008ce7 	.word	0x00008ce7
    8f40:	00008d11 	.word	0x00008d11
    8f44:	00008d6f 	.word	0x00008d6f
    8f48:	00008da3 	.word	0x00008da3
    8f4c:	00008e87 	.word	0x00008e87
    8f50:	00008e9f 	.word	0x00008e9f
    8f54:	00008eb3 	.word	0x00008eb3
    8f58:	00008fa5 	.word	0x00008fa5
    8f5c:	00008fdb 	.word	0x00008fdb
    8f60:	00009035 	.word	0x00009035
                pClient->tRenewRequest = _DHCPSecondCountGet();
    8f64:	4b31      	ldr	r3, [pc, #196]	; (902c <TCPIP_DHCP_Task+0x414>)
    8f66:	681b      	ldr	r3, [r3, #0]
    8f68:	60e3      	str	r3, [r4, #12]
                _DHCPNotifyClients(pNetIf, DHCP_EVENT_REQUEST_RENEW);
    8f6a:	2109      	movs	r1, #9
    8f6c:	4630      	mov	r0, r6
    8f6e:	f015 f8f1 	bl	1e154 <_DHCPNotifyClients>
                pClient->flags.bOfferReceived = false;
    8f72:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
    8f76:	f36f 0382 	bfc	r3, #2, #1
    8f7a:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
                pClient->t3Seconds = ((pClient->t2Seconds - pClient->t1Seconds) - (pClient->tRenewRequest - pClient->tRequest)) >> 1;
    8f7e:	6963      	ldr	r3, [r4, #20]
    8f80:	68a2      	ldr	r2, [r4, #8]
    8f82:	4413      	add	r3, r2
    8f84:	6922      	ldr	r2, [r4, #16]
    8f86:	1a9b      	subs	r3, r3, r2
    8f88:	68e2      	ldr	r2, [r4, #12]
    8f8a:	1a9b      	subs	r3, r3, r2
    8f8c:	085b      	lsrs	r3, r3, #1
                if( pClient->t3Seconds < TCPIP_DHCP_RENEW_RETRY_TIMEOUT)
    8f8e:	2b3b      	cmp	r3, #59	; 0x3b
                    pClient->t3Seconds = TCPIP_DHCP_RENEW_RETRY_TIMEOUT;
    8f90:	bf98      	it	ls
    8f92:	233c      	movls	r3, #60	; 0x3c
    8f94:	61e3      	str	r3, [r4, #28]
                pClient->startWait = _DHCPSecondCountGet();
    8f96:	4b25      	ldr	r3, [pc, #148]	; (902c <TCPIP_DHCP_Task+0x414>)
    8f98:	681b      	ldr	r3, [r3, #0]
    8f9a:	6063      	str	r3, [r4, #4]
    pClient->smState = newState;
    8f9c:	230a      	movs	r3, #10
    8f9e:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    8fa2:	e78e      	b.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
                if(_DHCPProcessReceiveData(pClient, pNetIf) == TCPIP_DHCP_TIMEOUT_MESSAGE)
    8fa4:	4631      	mov	r1, r6
    8fa6:	4620      	mov	r0, r4
    8fa8:	f00e fbee 	bl	17788 <_DHCPProcessReceiveData>
    8fac:	280a      	cmp	r0, #10
    8fae:	d188      	bne.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
    return dhcpSecondCount;
    8fb0:	4b1e      	ldr	r3, [pc, #120]	; (902c <TCPIP_DHCP_Task+0x414>)
    8fb2:	681a      	ldr	r2, [r3, #0]
                    if((_DHCPSecondCountGet() - pClient->tRequest) >= pClient->t2Seconds)
    8fb4:	68a3      	ldr	r3, [r4, #8]
    8fb6:	1ad3      	subs	r3, r2, r3
    8fb8:	6961      	ldr	r1, [r4, #20]
    8fba:	428b      	cmp	r3, r1
    8fbc:	d303      	bcc.n	8fc6 <TCPIP_DHCP_Task+0x3ae>
    pClient->smState = newState;
    8fbe:	230b      	movs	r3, #11
    8fc0:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    8fc4:	e77d      	b.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
                    else if((_DHCPSecondCountGet() - pClient->startWait) >= pClient->t3Seconds)
    8fc6:	6863      	ldr	r3, [r4, #4]
    8fc8:	1ad2      	subs	r2, r2, r3
    8fca:	69e3      	ldr	r3, [r4, #28]
    8fcc:	429a      	cmp	r2, r3
    8fce:	f4ff af78 	bcc.w	8ec2 <TCPIP_DHCP_Task+0x2aa>
    pClient->smState = newState;
    8fd2:	2309      	movs	r3, #9
    8fd4:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    8fd8:	e773      	b.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
                if(!_DHCPSend(pClient, pNetIf, TCPIP_DHCP_REQUEST_RENEW_MESSAGE, TCPIP_DHCP_FLAG_SEND_BCAST))
    8fda:	2301      	movs	r3, #1
    8fdc:	2209      	movs	r2, #9
    8fde:	4631      	mov	r1, r6
    8fe0:	4620      	mov	r0, r4
    8fe2:	f006 fe09 	bl	fbf8 <_DHCPSend>
    8fe6:	2800      	cmp	r0, #0
    8fe8:	f43f af6b 	beq.w	8ec2 <TCPIP_DHCP_Task+0x2aa>
                pClient->tRenewRequest = _DHCPSecondCountGet();
    8fec:	4b0f      	ldr	r3, [pc, #60]	; (902c <TCPIP_DHCP_Task+0x414>)
    8fee:	681b      	ldr	r3, [r3, #0]
    8ff0:	60e3      	str	r3, [r4, #12]
                _DHCPNotifyClients(pNetIf, DHCP_EVENT_REQUEST_REBIND);
    8ff2:	210a      	movs	r1, #10
    8ff4:	4630      	mov	r0, r6
    8ff6:	f015 f8ad 	bl	1e154 <_DHCPNotifyClients>
                pClient->flags.bOfferReceived = false;
    8ffa:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
    8ffe:	f36f 0382 	bfc	r3, #2, #1
    9002:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
                pClient->t3Seconds = ((pClient->tExpSeconds - pClient->t2Seconds) - (pClient->tRenewRequest - pClient->tRequest)) >> 1;
    9006:	69a3      	ldr	r3, [r4, #24]
    9008:	68a2      	ldr	r2, [r4, #8]
    900a:	4413      	add	r3, r2
    900c:	6962      	ldr	r2, [r4, #20]
    900e:	1a9b      	subs	r3, r3, r2
    9010:	68e2      	ldr	r2, [r4, #12]
    9012:	1a9b      	subs	r3, r3, r2
    9014:	085b      	lsrs	r3, r3, #1
                if( pClient->t3Seconds < TCPIP_DHCP_REBIND_RETRY_TIMEOUT)
    9016:	2b3b      	cmp	r3, #59	; 0x3b
                    pClient->t3Seconds = TCPIP_DHCP_REBIND_RETRY_TIMEOUT;
    9018:	bf98      	it	ls
    901a:	233c      	movls	r3, #60	; 0x3c
    901c:	61e3      	str	r3, [r4, #28]
                pClient->startWait = _DHCPSecondCountGet();
    901e:	4b03      	ldr	r3, [pc, #12]	; (902c <TCPIP_DHCP_Task+0x414>)
    9020:	681b      	ldr	r3, [r3, #0]
    9022:	6063      	str	r3, [r4, #4]
    pClient->smState = newState;
    9024:	230c      	movs	r3, #12
    9026:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    902a:	e74a      	b.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
    902c:	2000e418 	.word	0x2000e418
    9030:	2000e408 	.word	0x2000e408
                if(_DHCPProcessReceiveData(pClient, pNetIf) == TCPIP_DHCP_TIMEOUT_MESSAGE)
    9034:	4631      	mov	r1, r6
    9036:	4620      	mov	r0, r4
    9038:	f00e fba6 	bl	17788 <_DHCPProcessReceiveData>
    903c:	280a      	cmp	r0, #10
    903e:	f47f af40 	bne.w	8ec2 <TCPIP_DHCP_Task+0x2aa>
    return dhcpSecondCount;
    9042:	4b23      	ldr	r3, [pc, #140]	; (90d0 <TCPIP_DHCP_Task+0x4b8>)
    9044:	681b      	ldr	r3, [r3, #0]
                    if((_DHCPSecondCountGet() - pClient->tRequest) >= pClient->tExpSeconds)
    9046:	68a2      	ldr	r2, [r4, #8]
    9048:	1a9a      	subs	r2, r3, r2
    904a:	69a1      	ldr	r1, [r4, #24]
    904c:	428a      	cmp	r2, r1
    904e:	d208      	bcs.n	9062 <TCPIP_DHCP_Task+0x44a>
                    else if((_DHCPSecondCountGet() - pClient->startWait) >= pClient->t3Seconds)
    9050:	6862      	ldr	r2, [r4, #4]
    9052:	1a9b      	subs	r3, r3, r2
    9054:	69e2      	ldr	r2, [r4, #28]
    9056:	4293      	cmp	r3, r2
    pClient->smState = newState;
    9058:	bf24      	itt	cs
    905a:	230b      	movcs	r3, #11
    905c:	f8a4 3056 	strhcs.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    9060:	e72f      	b.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
                        _DHCPSetRunFail(pClient, TCPIP_DHCP_SEND_DISCOVERY, false);
    9062:	2200      	movs	r2, #0
    9064:	2102      	movs	r1, #2
    9066:	4620      	mov	r0, r4
    9068:	f013 fcee 	bl	1ca48 <_DHCPSetRunFail>
                        _DHCPNotifyClients(pNetIf, DHCP_EVENT_TIMEOUT);
    906c:	2107      	movs	r1, #7
    906e:	4630      	mov	r0, r6
    9070:	f015 f870 	bl	1e154 <_DHCPNotifyClients>
    9074:	e725      	b.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
    TCPIP_UDP_Discard(dhcpClientSocket);
    9076:	4b17      	ldr	r3, [pc, #92]	; (90d4 <TCPIP_DHCP_Task+0x4bc>)
    9078:	f9b3 0000 	ldrsh.w	r0, [r3]
    907c:	f017 fbc5 	bl	2080a <TCPIP_UDP_Discard>
}
    9080:	b007      	add	sp, #28
    9082:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    None.
*/

static __inline__ uint64_t __attribute__((always_inline)) SYS_TMR_SystemCountGet(void)
{
	return SYS_TIME_Counter64Get();
    9086:	f015 f973 	bl	1e370 <SYS_TIME_Counter64Get>
    908a:	4604      	mov	r4, r0
    908c:	460d      	mov	r5, r1
	return SYS_TIME_FrequencyGet();
    908e:	f018 ffe5 	bl	2205c <SYS_TIME_FrequencyGet>
    dhcpSecondCount = SYS_TMR_SystemCountGet() / SYS_TMR_SystemCountFrequencyGet(); 
    9092:	4602      	mov	r2, r0
    9094:	2300      	movs	r3, #0
    9096:	4620      	mov	r0, r4
    9098:	4629      	mov	r1, r5
    909a:	f016 fa35 	bl	1f508 <__aeabi_uldivmod>
    909e:	4b0c      	ldr	r3, [pc, #48]	; (90d0 <TCPIP_DHCP_Task+0x4b8>)
    90a0:	6018      	str	r0, [r3, #0]
    90a2:	e5c8      	b.n	8c36 <TCPIP_DHCP_Task+0x1e>
                        TCPIP_ARP_EntryRemove(pNetIf,  &arpCheck);
    90a4:	a902      	add	r1, sp, #8
    90a6:	4630      	mov	r0, r6
    90a8:	f010 ffb8 	bl	1a01c <TCPIP_ARP_EntryRemove>
                        _DHCPSend(pClient, pNetIf, TCPIP_DHCP_DECLINE_MESSAGE, TCPIP_DHCP_FLAG_SEND_ZERO_ADD | TCPIP_DHCP_FLAG_SEND_BCAST);
    90ac:	2303      	movs	r3, #3
    90ae:	2204      	movs	r2, #4
    90b0:	4631      	mov	r1, r6
    90b2:	4620      	mov	r0, r4
    90b4:	f006 fda0 	bl	fbf8 <_DHCPSend>
    pClient->smState = newState;
    90b8:	2307      	movs	r3, #7
    90ba:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
                        pClient->startWait = _DHCPSecondCountGet();
    90be:	4b04      	ldr	r3, [pc, #16]	; (90d0 <TCPIP_DHCP_Task+0x4b8>)
    90c0:	681b      	ldr	r3, [r3, #0]
    90c2:	6063      	str	r3, [r4, #4]
                        _DHCPNotifyClients(pNetIf, DHCP_EVENT_DECLINE);
    90c4:	2105      	movs	r1, #5
    90c6:	4630      	mov	r0, r6
    90c8:	f015 f844 	bl	1e154 <_DHCPNotifyClients>
    90cc:	e6f9      	b.n	8ec2 <TCPIP_DHCP_Task+0x2aa>
    90ce:	bf00      	nop
    90d0:	2000e418 	.word	0x2000e418
    90d4:	2000e504 	.word	0x2000e504

Disassembly of section .rodata%195:

000090d8 <.rodata%195>:
    90d8:	2f504354 	.word	0x2f504354
    90dc:	53205049 	.word	0x53205049
    90e0:	6b636174 	.word	0x6b636174
    90e4:	7325203a 	.word	0x7325203a
    90e8:	43414d20 	.word	0x43414d20
    90ec:	696e6920 	.word	0x696e6920
    90f0:	6c616974 	.word	0x6c616974
    90f4:	74617a69 	.word	0x74617a69
    90f8:	206e6f69 	.word	0x206e6f69
    90fc:	6c696166 	.word	0x6c696166
    9100:	0a0d6465 	.word	0x0a0d6465
    9104:	00000000 	.word	0x00000000
    9108:	2f504354 	.word	0x2f504354
    910c:	53205049 	.word	0x53205049
    9110:	6b636174 	.word	0x6b636174
    9114:	7325203a 	.word	0x7325203a
    9118:	43414d20 	.word	0x43414d20
    911c:	65704f20 	.word	0x65704f20
    9120:	6166206e 	.word	0x6166206e
    9124:	64656c69 	.word	0x64656c69
    9128:	00000a0d 	.word	0x00000a0d
    912c:	2f504354 	.word	0x2f504354
    9130:	53205049 	.word	0x53205049
    9134:	6b636174 	.word	0x6b636174
    9138:	6f4d203a 	.word	0x6f4d203a
    913c:	656c7564 	.word	0x656c7564
    9140:	3a6f6e20 	.word	0x3a6f6e20
    9144:	20642520 	.word	0x20642520
    9148:	74696e49 	.word	0x74696e49
    914c:	696c6169 	.word	0x696c6169
    9150:	6974617a 	.word	0x6974617a
    9154:	66206e6f 	.word	0x66206e6f
    9158:	656c6961 	.word	0x656c6961
    915c:	000a0d64 	.word	0x000a0d64
    9160:	2f504354 	.word	0x2f504354
    9164:	53205049 	.word	0x53205049
    9168:	6b636174 	.word	0x6b636174
    916c:	7325203a 	.word	0x7325203a
    9170:	43414d20 	.word	0x43414d20
    9174:	65766520 	.word	0x65766520
    9178:	6e20746e 	.word	0x6e20746e
    917c:	6669746f 	.word	0x6669746f
    9180:	74616369 	.word	0x74616369
    9184:	206e6f69 	.word	0x206e6f69
    9188:	74746573 	.word	0x74746573
    918c:	20676e69 	.word	0x20676e69
    9190:	6c696166 	.word	0x6c696166
    9194:	0a0d6465 	.word	0x0a0d6465
    9198:	00000000 	.word	0x00000000
    919c:	2f504354 	.word	0x2f504354
    91a0:	53205049 	.word	0x53205049
    91a4:	6b636174 	.word	0x6b636174
    91a8:	6548203a 	.word	0x6548203a
    91ac:	44207061 	.word	0x44207061
    91b0:	74656c65 	.word	0x74656c65
    91b4:	61662065 	.word	0x61662065
    91b8:	0d216c69 	.word	0x0d216c69
    91bc:	0000000a 	.word	0x0000000a
    91c0:	2f504354 	.word	0x2f504354
    91c4:	53205049 	.word	0x53205049
    91c8:	6b636174 	.word	0x6b636174
    91cc:	6548203a 	.word	0x6548203a
    91d0:	63207061 	.word	0x63207061
    91d4:	74616572 	.word	0x74616572
    91d8:	206e6f69 	.word	0x206e6f69
    91dc:	6c696166 	.word	0x6c696166
    91e0:	202c6465 	.word	0x202c6465
    91e4:	65707974 	.word	0x65707974
    91e8:	6425203a 	.word	0x6425203a
    91ec:	00000a0d 	.word	0x00000a0d
    91f0:	2f504354 	.word	0x2f504354
    91f4:	53205049 	.word	0x53205049
    91f8:	6b636174 	.word	0x6b636174
    91fc:	654e203a 	.word	0x654e203a
    9200:	726f7774 	.word	0x726f7774
    9204:	6f63206b 	.word	0x6f63206b
    9208:	6769666e 	.word	0x6769666e
    920c:	74617275 	.word	0x74617275
    9210:	206e6f69 	.word	0x206e6f69
    9214:	6f6c6c61 	.word	0x6f6c6c61
    9218:	69746163 	.word	0x69746163
    921c:	66206e6f 	.word	0x66206e6f
    9220:	656c6961 	.word	0x656c6961
    9224:	25203a64 	.word	0x25203a64
    9228:	0a0d756c 	.word	0x0a0d756c
    922c:	00000000 	.word	0x00000000
    9230:	2f504354 	.word	0x2f504354
    9234:	53205049 	.word	0x53205049
    9238:	6b636174 	.word	0x6b636174
    923c:	6150203a 	.word	0x6150203a
    9240:	74656b63 	.word	0x74656b63
    9244:	696e6920 	.word	0x696e6920
    9248:	6c616974 	.word	0x6c616974
    924c:	74617a69 	.word	0x74617a69
    9250:	206e6f69 	.word	0x206e6f69
    9254:	6c696166 	.word	0x6c696166
    9258:	203a6465 	.word	0x203a6465
    925c:	78257830 	.word	0x78257830
    9260:	00000a0d 	.word	0x00000a0d
    9264:	2f504354 	.word	0x2f504354
    9268:	53205049 	.word	0x53205049
    926c:	6b636174 	.word	0x6b636174
    9270:	6544203a 	.word	0x6544203a
    9274:	6c756166 	.word	0x6c756166
    9278:	6c462074 	.word	0x6c462074
    927c:	20687361 	.word	0x20687361
    9280:	7774654e 	.word	0x7774654e
    9284:	206b726f 	.word	0x206b726f
    9288:	666e6f63 	.word	0x666e6f63
    928c:	72756769 	.word	0x72756769
    9290:	6f697461 	.word	0x6f697461
    9294:	6f6c206e 	.word	0x6f6c206e
    9298:	66206461 	.word	0x66206461
    929c:	656c6961 	.word	0x656c6961
    92a0:	64252064 	.word	0x64252064
    92a4:	00000a0d 	.word	0x00000a0d
    92a8:	2f504354 	.word	0x2f504354
    92ac:	53205049 	.word	0x53205049
    92b0:	6b636174 	.word	0x6b636174
    92b4:	654e203a 	.word	0x654e203a
    92b8:	726f7774 	.word	0x726f7774
    92bc:	6f63206b 	.word	0x6f63206b
    92c0:	6769666e 	.word	0x6769666e
    92c4:	74617275 	.word	0x74617275
    92c8:	206e6f69 	.word	0x206e6f69
    92cc:	74696e69 	.word	0x74696e69
    92d0:	696c6169 	.word	0x696c6169
    92d4:	6974617a 	.word	0x6974617a
    92d8:	66206e6f 	.word	0x66206e6f
    92dc:	656c6961 	.word	0x656c6961
    92e0:	25203a64 	.word	0x25203a64
    92e4:	000a0d64 	.word	0x000a0d64
    92e8:	2f504354 	.word	0x2f504354
    92ec:	53205049 	.word	0x53205049
    92f0:	6b636174 	.word	0x6b636174
    92f4:	654e203a 	.word	0x654e203a
    92f8:	726f7774 	.word	0x726f7774
    92fc:	6f63206b 	.word	0x6f63206b
    9300:	6769666e 	.word	0x6769666e
    9304:	74617275 	.word	0x74617275
    9308:	3a6e6f69 	.word	0x3a6e6f69
    930c:	696c4120 	.word	0x696c4120
    9310:	73657361 	.word	0x73657361
    9314:	746f6e20 	.word	0x746f6e20
    9318:	70757320 	.word	0x70757320
    931c:	74726f70 	.word	0x74726f70
    9320:	203a6465 	.word	0x203a6465
    9324:	0a0d6425 	.word	0x0a0d6425
    9328:	00000000 	.word	0x00000000
    932c:	2f504354 	.word	0x2f504354
    9330:	53205049 	.word	0x53205049
    9334:	6b636174 	.word	0x6b636174
    9338:	654e203a 	.word	0x654e203a
    933c:	726f7774 	.word	0x726f7774
    9340:	6f63206b 	.word	0x6f63206b
    9344:	6769666e 	.word	0x6769666e
    9348:	74617275 	.word	0x74617275
    934c:	3a6e6f69 	.word	0x3a6e6f69
    9350:	766e6920 	.word	0x766e6920
    9354:	64696c61 	.word	0x64696c61
    9358:	20504920 	.word	0x20504920
    935c:	72646461 	.word	0x72646461
    9360:	3a737365 	.word	0x3a737365
    9364:	25783020 	.word	0x25783020
    9368:	0a0d7838 	.word	0x0a0d7838
    936c:	00000000 	.word	0x00000000
    9370:	64257325 	.word	0x64257325
    9374:	00000000 	.word	0x00000000
    9378:	2f504354 	.word	0x2f504354
    937c:	53205049 	.word	0x53205049
    9380:	6b636174 	.word	0x6b636174
    9384:	6f50203a 	.word	0x6f50203a
    9388:	20726577 	.word	0x20726577
    938c:	65646f4d 	.word	0x65646f4d
    9390:	696e6920 	.word	0x696e6920
    9394:	6c616974 	.word	0x6c616974
    9398:	74617a69 	.word	0x74617a69
    939c:	206e6f69 	.word	0x206e6f69
    93a0:	6c696166 	.word	0x6c696166
    93a4:	6425203a 	.word	0x6425203a
    93a8:	00000a0d 	.word	0x00000a0d
    93ac:	2f504354 	.word	0x2f504354
    93b0:	53205049 	.word	0x53205049
    93b4:	6b636174 	.word	0x6b636174
    93b8:	7944203a 	.word	0x7944203a
    93bc:	696d616e 	.word	0x696d616e
    93c0:	656d2063 	.word	0x656d2063
    93c4:	79726f6d 	.word	0x79726f6d
    93c8:	20736920 	.word	0x20736920
    93cc:	3a776f6c 	.word	0x3a776f6c
    93d0:	756c2520 	.word	0x756c2520
    93d4:	00000a0d 	.word	0x00000a0d
    93d8:	2f504354 	.word	0x2f504354
    93dc:	53205049 	.word	0x53205049
    93e0:	6b636174 	.word	0x6b636174
    93e4:	6e49203a 	.word	0x6e49203a
    93e8:	61697469 	.word	0x61697469
    93ec:	617a696c 	.word	0x617a696c
    93f0:	6e6f6974 	.word	0x6e6f6974
    93f4:	69616620 	.word	0x69616620
    93f8:	2064656c 	.word	0x2064656c
    93fc:	2d206425 	.word	0x2d206425
    9400:	6f624120 	.word	0x6f624120
    9404:	6e697472 	.word	0x6e697472
    9408:	0d202167 	.word	0x0d202167
    940c:	0000000a 	.word	0x0000000a
    9410:	2f504354 	.word	0x2f504354
    9414:	53205049 	.word	0x53205049
    9418:	6b636174 	.word	0x6b636174
    941c:	6e49203a 	.word	0x6e49203a
    9420:	61697469 	.word	0x61697469
    9424:	617a696c 	.word	0x617a696c
    9428:	6e6f6974 	.word	0x6e6f6974
    942c:	61745320 	.word	0x61745320
    9430:	64657472 	.word	0x64657472
    9434:	000a0d20 	.word	0x000a0d20
    9438:	2f504354 	.word	0x2f504354
    943c:	53205049 	.word	0x53205049
    9440:	6b636174 	.word	0x6b636174
    9444:	654e203a 	.word	0x654e203a
    9448:	726f7774 	.word	0x726f7774
    944c:	6f63206b 	.word	0x6f63206b
    9450:	6769666e 	.word	0x6769666e
    9454:	74617275 	.word	0x74617275
    9458:	206e6f69 	.word	0x206e6f69
    945c:	64616f6c 	.word	0x64616f6c
    9460:	69616620 	.word	0x69616620
    9464:	3a64656c 	.word	0x3a64656c
    9468:	0d642520 	.word	0x0d642520
    946c:	0000000a 	.word	0x0000000a
    9470:	2f504354 	.word	0x2f504354
    9474:	53205049 	.word	0x53205049
    9478:	6b636174 	.word	0x6b636174
    947c:	6954203a 	.word	0x6954203a
    9480:	72206b63 	.word	0x72206b63
    9484:	73696765 	.word	0x73696765
    9488:	74617274 	.word	0x74617274
    948c:	206e6f69 	.word	0x206e6f69
    9490:	6c696166 	.word	0x6c696166
    9494:	203a6465 	.word	0x203a6465
    9498:	0a0d6425 	.word	0x0a0d6425
    949c:	00000000 	.word	0x00000000
    94a0:	2f504354 	.word	0x2f504354
    94a4:	53205049 	.word	0x53205049
    94a8:	6b636174 	.word	0x6b636174
    94ac:	6e49203a 	.word	0x6e49203a
    94b0:	61697469 	.word	0x61697469
    94b4:	617a696c 	.word	0x617a696c
    94b8:	6e6f6974 	.word	0x6e6f6974
    94bc:	53595320 	.word	0x53595320
    94c0:	524d5420 	.word	0x524d5420
    94c4:	69616620 	.word	0x69616620
    94c8:	3a64656c 	.word	0x3a64656c
    94cc:	20642520 	.word	0x20642520
    94d0:	6241202d 	.word	0x6241202d
    94d4:	6974726f 	.word	0x6974726f
    94d8:	2021676e 	.word	0x2021676e
    94dc:	00000a0d 	.word	0x00000a0d
    94e0:	2f504354 	.word	0x2f504354
    94e4:	53205049 	.word	0x53205049
    94e8:	6b636174 	.word	0x6b636174
    94ec:	6e49203a 	.word	0x6e49203a
    94f0:	61697469 	.word	0x61697469
    94f4:	617a696c 	.word	0x617a696c
    94f8:	6e6f6974 	.word	0x6e6f6974
    94fc:	646e4520 	.word	0x646e4520
    9500:	2d206465 	.word	0x2d206465
    9504:	63757320 	.word	0x63757320
    9508:	73736563 	.word	0x73736563
    950c:	000a0d20 	.word	0x000a0d20
    9510:	2f504354 	.word	0x2f504354
    9514:	53205049 	.word	0x53205049
    9518:	6b636174 	.word	0x6b636174
    951c:	6e49203a 	.word	0x6e49203a
    9520:	61697469 	.word	0x61697469
    9524:	617a696c 	.word	0x617a696c
    9528:	6e6f6974 	.word	0x6e6f6974
    952c:	69616620 	.word	0x69616620
    9530:	3a64656c 	.word	0x3a64656c
    9534:	25783020 	.word	0x25783020
    9538:	202d2078 	.word	0x202d2078
    953c:	726f6241 	.word	0x726f6241
    9540:	676e6974 	.word	0x676e6974
    9544:	0a0d2021 	.word	0x0a0d2021
    9548:	00000000 	.word	0x00000000
    954c:	30312e38 	.word	0x30312e38
    9550:	48202d20 	.word	0x48202d20
    9554:	00000033 	.word	0x00000033
    9558:	006b6e75 	.word	0x006b6e75
    955c:	00687465 	.word	0x00687465
    9560:	6e616c77 	.word	0x6e616c77
    9564:	00          	.byte	0x00
    9565:	00          	.byte	0x00
    9566:	bf00      	nop

Disassembly of section .text._TCPIP_DoInitialize%196:

00009568 <_TCPIP_DoInitialize>:
{
    9568:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    956c:	b08b      	sub	sp, #44	; 0x2c
    nNets = init->nNets;
    956e:	6884      	ldr	r4, [r0, #8]
    if(nNets == 0 || pUsrConfig == 0 || pUsrConfig->pMacObject == 0 || pModConfig == 0 || nModules == 0)
    9570:	2c00      	cmp	r4, #0
    9572:	f000 81c3 	beq.w	98fc <_TCPIP_DoInitialize+0x394>
    pUsrConfig = init->pNetConf;
    9576:	6845      	ldr	r5, [r0, #4]
    if(nNets == 0 || pUsrConfig == 0 || pUsrConfig->pMacObject == 0 || pModConfig == 0 || nModules == 0)
    9578:	2d00      	cmp	r5, #0
    957a:	f000 81c5 	beq.w	9908 <_TCPIP_DoInitialize+0x3a0>
    957e:	6aab      	ldr	r3, [r5, #40]	; 0x28
    9580:	2b00      	cmp	r3, #0
    9582:	f000 81c4 	beq.w	990e <_TCPIP_DoInitialize+0x3a6>
    pModConfig = init->pModConfig;
    9586:	f8d0 900c 	ldr.w	r9, [r0, #12]
    if(nNets == 0 || pUsrConfig == 0 || pUsrConfig->pMacObject == 0 || pModConfig == 0 || nModules == 0)
    958a:	f1b9 0f00 	cmp.w	r9, #0
    958e:	f000 81c1 	beq.w	9914 <_TCPIP_DoInitialize+0x3ac>
    nModules = init->nModules;
    9592:	f8d0 b010 	ldr.w	fp, [r0, #16]
    if(nNets == 0 || pUsrConfig == 0 || pUsrConfig->pMacObject == 0 || pModConfig == 0 || nModules == 0)
    9596:	f1bb 0f00 	cmp.w	fp, #0
    959a:	f000 81be 	beq.w	991a <_TCPIP_DoInitialize+0x3b2>
    tcpip_init_data = *init;
    959e:	4fb3      	ldr	r7, [pc, #716]	; (986c <_TCPIP_DoInitialize+0x304>)
    95a0:	4606      	mov	r6, r0
    95a2:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    95a4:	c70f      	stmia	r7!, {r0, r1, r2, r3}
    95a6:	e896 0003 	ldmia.w	r6, {r0, r1}
    95aa:	e887 0003 	stmia.w	r7, {r0, r1}
        if(pModConfig->moduleId == moduleId)
    95ae:	f8b9 3000 	ldrh.w	r3, [r9]
    95b2:	2b01      	cmp	r3, #1
    95b4:	f000 81c8 	beq.w	9948 <_TCPIP_DoInitialize+0x3e0>
    95b8:	f1ab 0202 	sub.w	r2, fp, #2
    95bc:	464b      	mov	r3, r9
        pModConfig++;
    95be:	3308      	adds	r3, #8
    while(nModules--)
    95c0:	f1b2 3fff 	cmp.w	r2, #4294967295
    95c4:	d03f      	beq.n	9646 <_TCPIP_DoInitialize+0xde>
        if(pModConfig->moduleId == moduleId)
    95c6:	3a01      	subs	r2, #1
    95c8:	8819      	ldrh	r1, [r3, #0]
    95ca:	2901      	cmp	r1, #1
    95cc:	d1f7      	bne.n	95be <_TCPIP_DoInitialize+0x56>
        heapData = (pHeapConfig != 0) ? (const TCPIP_STACK_HEAP_CONFIG*)pHeapConfig->configData : 0;
    95ce:	f8d3 a004 	ldr.w	sl, [r3, #4]
        if( heapData == 0 || heapData->malloc_fnc == 0 || heapData->calloc_fnc == 0 || heapData->free_fnc == 0)
    95d2:	f1ba 0f00 	cmp.w	sl, #0
    95d6:	d038      	beq.n	964a <_TCPIP_DoInitialize+0xe2>
    95d8:	f8da 3004 	ldr.w	r3, [sl, #4]
    95dc:	2b00      	cmp	r3, #0
    95de:	d034      	beq.n	964a <_TCPIP_DoInitialize+0xe2>
    95e0:	f8da 3008 	ldr.w	r3, [sl, #8]
    95e4:	2b00      	cmp	r3, #0
    95e6:	d030      	beq.n	964a <_TCPIP_DoInitialize+0xe2>
    95e8:	f8da 300c 	ldr.w	r3, [sl, #12]
    95ec:	b36b      	cbz	r3, 964a <_TCPIP_DoInitialize+0xe2>
            heapH = TCPIP_HEAP_Create(heapData, 0);
    95ee:	2100      	movs	r1, #0
    95f0:	4650      	mov	r0, sl
    95f2:	f018 f987 	bl	21904 <TCPIP_HEAP_Create>
    95f6:	9005      	str	r0, [sp, #20]
        if((tcpip_stack_ctrl_data.memH = heapH) == 0)
    95f8:	4b9d      	ldr	r3, [pc, #628]	; (9870 <_TCPIP_DoInitialize+0x308>)
    95fa:	60d8      	str	r0, [r3, #12]
    95fc:	2800      	cmp	r0, #0
    95fe:	f000 81a8 	beq.w	9952 <_TCPIP_DoInitialize+0x3ea>
        tcpip_stack_ctrl_data.heapType = heapData->heapType;
    9602:	f89a 2000 	ldrb.w	r2, [sl]
    9606:	4b9a      	ldr	r3, [pc, #616]	; (9870 <_TCPIP_DoInitialize+0x308>)
    9608:	741a      	strb	r2, [r3, #16]
// out of line version
void*   TCPIP_HEAP_MallocOutline(TCPIP_STACK_HEAP_HANDLE heapH, size_t nBytes);

static __inline__ void* __attribute__((always_inline)) TCPIP_HEAP_CallocInline(TCPIP_STACK_HEAP_HANDLE h, size_t nElems, size_t elemSize)
{
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Calloc)(h, nElems, elemSize);
    960a:	9805      	ldr	r0, [sp, #20]
    960c:	6883      	ldr	r3, [r0, #8]
    960e:	226c      	movs	r2, #108	; 0x6c
    9610:	4621      	mov	r1, r4
    9612:	4798      	blx	r3
        tcpipNetIf = (TCPIP_NET_IF*)TCPIP_HEAP_Calloc(heapH, nNets, sizeof(TCPIP_NET_IF)); // allocate for each network interface
    9614:	4b97      	ldr	r3, [pc, #604]	; (9874 <_TCPIP_DoInitialize+0x30c>)
    9616:	6018      	str	r0, [r3, #0]
        if(tcpipNetIf == 0)
    9618:	b368      	cbz	r0, 9676 <_TCPIP_DoInitialize+0x10e>
        if(TCPIP_PKT_Initialize(heapH, pUsrConfig, nNets) == false)
    961a:	4622      	mov	r2, r4
    961c:	4629      	mov	r1, r5
    961e:	9805      	ldr	r0, [sp, #20]
    9620:	f015 fe6a 	bl	1f2f8 <TCPIP_PKT_Initialize>
    9624:	9003      	str	r0, [sp, #12]
    9626:	2800      	cmp	r0, #0
    9628:	d13c      	bne.n	96a4 <_TCPIP_DoInitialize+0x13c>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Packet initialization failed: 0x%x\r\n", (uint32_t)heapH);
    962a:	f018 fd11 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
    962e:	bb88      	cbnz	r0, 9694 <_TCPIP_DoInitialize+0x12c>
            initFail = 3;
    9630:	2403      	movs	r4, #3
    SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Initialization failed %d - Aborting! \r\n", initFail);
    9632:	f018 fd0d 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
    9636:	2800      	cmp	r0, #0
    9638:	f040 8159 	bne.w	98ee <_TCPIP_DoInitialize+0x386>
    TCPIP_STACK_KillStack();
    963c:	f00c ff4c 	bl	164d8 <TCPIP_STACK_KillStack>
    return false;
    9640:	2300      	movs	r3, #0
    9642:	9303      	str	r3, [sp, #12]
    9644:	e15c      	b.n	9900 <_TCPIP_DoInitialize+0x398>
        heapData = (pHeapConfig != 0) ? (const TCPIP_STACK_HEAP_CONFIG*)pHeapConfig->configData : 0;
    9646:	f04f 0a00 	mov.w	sl, #0
        if((tcpip_stack_ctrl_data.memH = heapH) == 0)
    964a:	4b89      	ldr	r3, [pc, #548]	; (9870 <_TCPIP_DoInitialize+0x308>)
    964c:	2200      	movs	r2, #0
    964e:	60da      	str	r2, [r3, #12]
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Heap creation failed, type: %d\r\n", heapData ? heapData->heapType : TCPIP_STACK_HEAP_TYPE_NONE);
    9650:	f018 fcfe 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
    9654:	b908      	cbnz	r0, 965a <_TCPIP_DoInitialize+0xf2>
            initFail = 1;
    9656:	2401      	movs	r4, #1
    9658:	e7eb      	b.n	9632 <_TCPIP_DoInitialize+0xca>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Heap creation failed, type: %d\r\n", heapData ? heapData->heapType : TCPIP_STACK_HEAP_TYPE_NONE);
    965a:	f018 fcf3 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
    965e:	f1ba 0f00 	cmp.w	sl, #0
    9662:	d006      	beq.n	9672 <_TCPIP_DoInitialize+0x10a>
    9664:	f89a 2000 	ldrb.w	r2, [sl]
    9668:	4983      	ldr	r1, [pc, #524]	; (9878 <_TCPIP_DoInitialize+0x310>)
    966a:	f011 fa17 	bl	1aa9c <SYS_CONSOLE_Print>
            initFail = 1;
    966e:	2401      	movs	r4, #1
    9670:	e7df      	b.n	9632 <_TCPIP_DoInitialize+0xca>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Heap creation failed, type: %d\r\n", heapData ? heapData->heapType : TCPIP_STACK_HEAP_TYPE_NONE);
    9672:	2200      	movs	r2, #0
    9674:	e7f8      	b.n	9668 <_TCPIP_DoInitialize+0x100>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration allocation failed: %lu\r\n", nNets * sizeof(TCPIP_NET_IF));
    9676:	f018 fceb 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
    967a:	b908      	cbnz	r0, 9680 <_TCPIP_DoInitialize+0x118>
            initFail = 2;
    967c:	2402      	movs	r4, #2
    967e:	e7d8      	b.n	9632 <_TCPIP_DoInitialize+0xca>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration allocation failed: %lu\r\n", nNets * sizeof(TCPIP_NET_IF));
    9680:	f018 fce0 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
    9684:	226c      	movs	r2, #108	; 0x6c
    9686:	fb02 f204 	mul.w	r2, r2, r4
    968a:	497c      	ldr	r1, [pc, #496]	; (987c <_TCPIP_DoInitialize+0x314>)
    968c:	f011 fa06 	bl	1aa9c <SYS_CONSOLE_Print>
            initFail = 2;
    9690:	2402      	movs	r4, #2
    9692:	e7ce      	b.n	9632 <_TCPIP_DoInitialize+0xca>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Packet initialization failed: 0x%x\r\n", (uint32_t)heapH);
    9694:	f018 fcd6 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
    9698:	9a05      	ldr	r2, [sp, #20]
    969a:	4979      	ldr	r1, [pc, #484]	; (9880 <_TCPIP_DoInitialize+0x318>)
    969c:	f011 f9fe 	bl	1aa9c <SYS_CONSOLE_Print>
            initFail = 3;
    96a0:	2403      	movs	r4, #3
    96a2:	e7c6      	b.n	9632 <_TCPIP_DoInitialize+0xca>
        tcpip_stack_ctrl_data.nIfs = nNets;
    96a4:	4b72      	ldr	r3, [pc, #456]	; (9870 <_TCPIP_DoInitialize+0x308>)
    96a6:	601c      	str	r4, [r3, #0]
        tcpip_stack_ctrl_data.nModules = nModules;
    96a8:	f8c3 b008 	str.w	fp, [r3, #8]
    for(ix =0, pConfigIf = tcpipNetIf; ix < nNets; ix++, pConfigIf++, pUsrConfig++)
    96ac:	4b71      	ldr	r3, [pc, #452]	; (9874 <_TCPIP_DoInitialize+0x30c>)
    96ae:	681e      	ldr	r6, [r3, #0]
    96b0:	2c00      	cmp	r4, #0
    96b2:	f340 8154 	ble.w	995e <_TCPIP_DoInitialize+0x3f6>
    96b6:	462f      	mov	r7, r5
    96b8:	f04f 0800 	mov.w	r8, #0
        if(!_LoadNetworkConfig(pUsrConfig, pConfigIf, false))
    96bc:	2200      	movs	r2, #0
    96be:	4631      	mov	r1, r6
    96c0:	4638      	mov	r0, r7
    96c2:	f008 fe49 	bl	12358 <_LoadNetworkConfig>
    96c6:	b328      	cbz	r0, 9714 <_TCPIP_DoInitialize+0x1ac>
    for(ix =0, pConfigIf = tcpipNetIf; ix < nNets; ix++, pConfigIf++, pUsrConfig++)
    96c8:	f108 0801 	add.w	r8, r8, #1
    96cc:	366c      	adds	r6, #108	; 0x6c
    96ce:	3738      	adds	r7, #56	; 0x38
    96d0:	4544      	cmp	r4, r8
    96d2:	d1f3      	bne.n	96bc <_TCPIP_DoInitialize+0x154>
        for(netIx = 0, pIf = tcpipNetIf; netIx < nNets; netIx++, pIf++)
    96d4:	4a67      	ldr	r2, [pc, #412]	; (9874 <_TCPIP_DoInitialize+0x30c>)
    96d6:	f8d2 e000 	ldr.w	lr, [r2]
    96da:	4a65      	ldr	r2, [pc, #404]	; (9870 <_TCPIP_DoInitialize+0x308>)
    96dc:	6856      	ldr	r6, [r2, #4]
    96de:	46f4      	mov	ip, lr
    96e0:	2100      	movs	r1, #0
                    tcpip_stack_ctrl_data.nAliases++;
    96e2:	4680      	mov	r8, r0
    96e4:	4670      	mov	r0, lr
    96e6:	468e      	mov	lr, r1
            pPriMac = pIf->pMacObj;
    96e8:	f8dc 7044 	ldr.w	r7, [ip, #68]	; 0x44
            for(ix = netIx + 1, pScanIf = pIf + 1; ix < nNets; ix++, pScanIf++)
    96ec:	f10e 0e01 	add.w	lr, lr, #1
    96f0:	f10c 0c6c 	add.w	ip, ip, #108	; 0x6c
    96f4:	4574      	cmp	r4, lr
    96f6:	d024      	beq.n	9742 <_TCPIP_DoInitialize+0x1da>
    96f8:	4662      	mov	r2, ip
    96fa:	4673      	mov	r3, lr
    96fc:	9004      	str	r0, [sp, #16]
                if(pScanIf->pMacObj == pPriMac)
    96fe:	6c50      	ldr	r0, [r2, #68]	; 0x44
    9700:	42b8      	cmp	r0, r7
                    tcpip_stack_ctrl_data.nAliases++;
    9702:	bf04      	itt	eq
    9704:	3601      	addeq	r6, #1
    9706:	4641      	moveq	r1, r8
            for(ix = netIx + 1, pScanIf = pIf + 1; ix < nNets; ix++, pScanIf++)
    9708:	3301      	adds	r3, #1
    970a:	326c      	adds	r2, #108	; 0x6c
    970c:	429c      	cmp	r4, r3
    970e:	d1f6      	bne.n	96fe <_TCPIP_DoInitialize+0x196>
    9710:	9804      	ldr	r0, [sp, #16]
    9712:	e7e9      	b.n	96e8 <_TCPIP_DoInitialize+0x180>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Default Flash Network configuration load failed %d\r\n", ix);
    9714:	f018 fc9c 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
    9718:	b920      	cbnz	r0, 9724 <_TCPIP_DoInitialize+0x1bc>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration initialization failed: %d\r\n", nNets);
    971a:	f018 fc99 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
    971e:	b940      	cbnz	r0, 9732 <_TCPIP_DoInitialize+0x1ca>
            initFail = 4;   // failed the initialization
    9720:	2404      	movs	r4, #4
    9722:	e786      	b.n	9632 <_TCPIP_DoInitialize+0xca>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Default Flash Network configuration load failed %d\r\n", ix);
    9724:	f018 fc8e 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
    9728:	4642      	mov	r2, r8
    972a:	4956      	ldr	r1, [pc, #344]	; (9884 <_TCPIP_DoInitialize+0x31c>)
    972c:	f011 f9b6 	bl	1aa9c <SYS_CONSOLE_Print>
    9730:	e7f3      	b.n	971a <_TCPIP_DoInitialize+0x1b2>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration initialization failed: %d\r\n", nNets);
    9732:	f018 fc87 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
    9736:	4622      	mov	r2, r4
    9738:	4953      	ldr	r1, [pc, #332]	; (9888 <_TCPIP_DoInitialize+0x320>)
    973a:	f011 f9af 	bl	1aa9c <SYS_CONSOLE_Print>
            initFail = 4;   // failed the initialization
    973e:	2404      	movs	r4, #4
    9740:	e777      	b.n	9632 <_TCPIP_DoInitialize+0xca>
    9742:	4686      	mov	lr, r0
    9744:	b109      	cbz	r1, 974a <_TCPIP_DoInitialize+0x1e2>
    9746:	4b4a      	ldr	r3, [pc, #296]	; (9870 <_TCPIP_DoInitialize+0x308>)
    9748:	605e      	str	r6, [r3, #4]
        if(tcpip_stack_ctrl_data.nAliases != 0)
    974a:	4b49      	ldr	r3, [pc, #292]	; (9870 <_TCPIP_DoInitialize+0x308>)
    974c:	685b      	ldr	r3, [r3, #4]
    974e:	2b00      	cmp	r3, #0
    9750:	f040 810d 	bne.w	996e <_TCPIP_DoInitialize+0x406>
    9754:	f10e 006c 	add.w	r0, lr, #108	; 0x6c
    9758:	2701      	movs	r7, #1
    975a:	e00c      	b.n	9776 <_TCPIP_DoInitialize+0x20e>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration: Aliases not supported: %d\r\n", tcpip_stack_ctrl_data.nAliases);
    975c:	f018 fc72 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
    9760:	4b43      	ldr	r3, [pc, #268]	; (9870 <_TCPIP_DoInitialize+0x308>)
    9762:	685a      	ldr	r2, [r3, #4]
    9764:	4949      	ldr	r1, [pc, #292]	; (988c <_TCPIP_DoInitialize+0x324>)
    9766:	f011 f999 	bl	1aa9c <SYS_CONSOLE_Print>
            initFail = 5;
    976a:	2405      	movs	r4, #5
    976c:	e761      	b.n	9632 <_TCPIP_DoInitialize+0xca>
        for(netIx = 0, pIf = tcpipNetIf; netIx < nNets && !initFail; netIx++, pIf++)
    976e:	42bc      	cmp	r4, r7
    9770:	dd20      	ble.n	97b4 <_TCPIP_DoInitialize+0x24c>
    9772:	3701      	adds	r7, #1
    9774:	306c      	adds	r0, #108	; 0x6c
            if((dupIpAddr.Val = pIf->DefaultIPAddr.Val) != 0)
    9776:	4603      	mov	r3, r0
    9778:	f850 1c54 	ldr.w	r1, [r0, #-84]
    977c:	2900      	cmp	r1, #0
    977e:	d0f6      	beq.n	976e <_TCPIP_DoInitialize+0x206>
                for(ix = netIx + 1, pScanIf = pIf + 1; ix < nNets; ix++, pScanIf++)
    9780:	463a      	mov	r2, r7
    9782:	42bc      	cmp	r4, r7
    9784:	dd16      	ble.n	97b4 <_TCPIP_DoInitialize+0x24c>
                    if(pScanIf->DefaultIPAddr.Val == dupIpAddr.Val)
    9786:	6986      	ldr	r6, [r0, #24]
    9788:	42b1      	cmp	r1, r6
    978a:	d006      	beq.n	979a <_TCPIP_DoInitialize+0x232>
                for(ix = netIx + 1, pScanIf = pIf + 1; ix < nNets; ix++, pScanIf++)
    978c:	3201      	adds	r2, #1
    978e:	336c      	adds	r3, #108	; 0x6c
    9790:	4294      	cmp	r4, r2
    9792:	d0ee      	beq.n	9772 <_TCPIP_DoInitialize+0x20a>
                    if(pScanIf->DefaultIPAddr.Val == dupIpAddr.Val)
    9794:	699e      	ldr	r6, [r3, #24]
    9796:	42b1      	cmp	r1, r6
    9798:	d1f8      	bne.n	978c <_TCPIP_DoInitialize+0x224>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration: invalid IP address: 0x%8x\r\n", dupIpAddr.Val);
    979a:	f018 fc59 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
    979e:	b908      	cbnz	r0, 97a4 <_TCPIP_DoInitialize+0x23c>
    97a0:	2406      	movs	r4, #6
    97a2:	e746      	b.n	9632 <_TCPIP_DoInitialize+0xca>
    97a4:	f018 fc4e 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
    97a8:	4632      	mov	r2, r6
    97aa:	4939      	ldr	r1, [pc, #228]	; (9890 <_TCPIP_DoInitialize+0x328>)
    97ac:	f011 f976 	bl	1aa9c <SYS_CONSOLE_Print>
    97b0:	2406      	movs	r4, #6
    97b2:	e73e      	b.n	9632 <_TCPIP_DoInitialize+0xca>
        tcpipDefIf.defaultNet = 0;
    97b4:	2300      	movs	r3, #0
    97b6:	4a37      	ldr	r2, [pc, #220]	; (9894 <_TCPIP_DoInitialize+0x32c>)
    97b8:	6013      	str	r3, [r2, #0]
    memset(ifNumber, 0, sizeof(ifNumber));
    97ba:	9307      	str	r3, [sp, #28]
    97bc:	9308      	str	r3, [sp, #32]
    97be:	9309      	str	r3, [sp, #36]	; 0x24
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    97c0:	4b2b      	ldr	r3, [pc, #172]	; (9870 <_TCPIP_DoInitialize+0x308>)
    97c2:	681b      	ldr	r3, [r3, #0]
    97c4:	2b00      	cmp	r3, #0
    97c6:	dd24      	ble.n	9812 <_TCPIP_DoInitialize+0x2aa>
    97c8:	f10e 0662 	add.w	r6, lr, #98	; 0x62
    97cc:	f04f 0800 	mov.w	r8, #0
    97d0:	f8cd a010 	str.w	sl, [sp, #16]
        pNetIf->netIfIx = netIx;
    97d4:	f826 8c0a 	strh.w	r8, [r6, #-10]
            const char* ifName = TCPIP_STACK_IF_ALIAS_NAME_TBL[macType]; 
    97d8:	79f3      	ldrb	r3, [r6, #7]
            snprintf(pNetIf->ifName, sizeof(pNetIf->ifName), "%s%d", ifName, ifNumber[macType]);
    97da:	aa0a      	add	r2, sp, #40	; 0x28
    97dc:	eb02 0a83 	add.w	sl, r2, r3, lsl #2
    97e0:	f85a 7c0c 	ldr.w	r7, [sl, #-12]
    97e4:	9700      	str	r7, [sp, #0]
    97e6:	4a2c      	ldr	r2, [pc, #176]	; (9898 <_TCPIP_DoInitialize+0x330>)
    97e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    97ec:	4a2b      	ldr	r2, [pc, #172]	; (989c <_TCPIP_DoInitialize+0x334>)
    97ee:	2107      	movs	r1, #7
    97f0:	4630      	mov	r0, r6
    97f2:	f011 f9bf 	bl	1ab74 <sniprintf>
            pNetIf->ifName[sizeof(pNetIf->ifName) - 1] = 0;
    97f6:	2300      	movs	r3, #0
    97f8:	71b3      	strb	r3, [r6, #6]
            ifNumber[macType]++;
    97fa:	3701      	adds	r7, #1
    97fc:	f84a 7c0c 	str.w	r7, [sl, #-12]
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    9800:	f108 0801 	add.w	r8, r8, #1
    9804:	366c      	adds	r6, #108	; 0x6c
    9806:	4b1a      	ldr	r3, [pc, #104]	; (9870 <_TCPIP_DoInitialize+0x308>)
    9808:	681b      	ldr	r3, [r3, #0]
    980a:	4598      	cmp	r8, r3
    980c:	dbe2      	blt.n	97d4 <_TCPIP_DoInitialize+0x26c>
    980e:	f8dd a010 	ldr.w	sl, [sp, #16]
        memset(TCPIP_STACK_MODULE_SIGNAL_TBL, 0x0, sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL));
    9812:	f44f 721c 	mov.w	r2, #624	; 0x270
    9816:	2100      	movs	r1, #0
    9818:	4821      	ldr	r0, [pc, #132]	; (98a0 <_TCPIP_DoInitialize+0x338>)
    981a:	f018 fa37 	bl	21c8c <memset>
        stackAsyncSignalCount = 0;
    981e:	4b21      	ldr	r3, [pc, #132]	; (98a4 <_TCPIP_DoInitialize+0x33c>)
    9820:	2200      	movs	r2, #0
    9822:	601a      	str	r2, [r3, #0]
        tcpip_heap_config = *heapData; 
    9824:	4e20      	ldr	r6, [pc, #128]	; (98a8 <_TCPIP_DoInitialize+0x340>)
    9826:	e89a 000f 	ldmia.w	sl, {r0, r1, r2, r3}
    982a:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
        for(ix = 0; ix < sizeof(TCPIP_MODULES_QUEUE_TBL)/sizeof(*TCPIP_MODULES_QUEUE_TBL); ix++)
    982e:	4e1f      	ldr	r6, [pc, #124]	; (98ac <_TCPIP_DoInitialize+0x344>)
    9830:	f106 0790 	add.w	r7, r6, #144	; 0x90
            TCPIP_Helper_SingleListInitialize(TCPIP_MODULES_QUEUE_TBL + ix);
    9834:	4630      	mov	r0, r6
    9836:	f018 fc71 	bl	2211c <TCPIP_Helper_SingleListInitialize>
    983a:	360c      	adds	r6, #12
        for(ix = 0; ix < sizeof(TCPIP_MODULES_QUEUE_TBL)/sizeof(*TCPIP_MODULES_QUEUE_TBL); ix++)
    983c:	42be      	cmp	r6, r7
    983e:	d1f9      	bne.n	9834 <_TCPIP_DoInitialize+0x2cc>
        tcpip_stack_ctrl_data.stackAction = TCPIP_STACK_ACTION_INIT;
    9840:	4b0b      	ldr	r3, [pc, #44]	; (9870 <_TCPIP_DoInitialize+0x308>)
    9842:	2200      	movs	r2, #0
    9844:	771a      	strb	r2, [r3, #28]
        for(netIx = 0, pIf = tcpipNetIf; netIx < nNets; netIx++, pIf++, pUsrConfig++)
    9846:	4b0b      	ldr	r3, [pc, #44]	; (9874 <_TCPIP_DoInitialize+0x30c>)
    9848:	f8d3 a000 	ldr.w	sl, [r3]
    984c:	4294      	cmp	r4, r2
    984e:	dd69      	ble.n	9924 <_TCPIP_DoInitialize+0x3bc>
    9850:	4617      	mov	r7, r2
            tcpip_stack_ctrl_data.powerMode = powerMode;
    9852:	4e07      	ldr	r6, [pc, #28]	; (9870 <_TCPIP_DoInitialize+0x308>)
    9854:	46a0      	mov	r8, r4
    9856:	4654      	mov	r4, sl
    9858:	e03b      	b.n	98d2 <_TCPIP_DoInitialize+0x36a>
                SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Power Mode initialization fail: %d\r\n", powerMode);
    985a:	f018 fbf3 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
    985e:	4642      	mov	r2, r8
    9860:	4913      	ldr	r1, [pc, #76]	; (98b0 <_TCPIP_DoInitialize+0x348>)
    9862:	f011 f91b 	bl	1aa9c <SYS_CONSOLE_Print>
                initFail = 7;
    9866:	2407      	movs	r4, #7
    9868:	e6e3      	b.n	9632 <_TCPIP_DoInitialize+0xca>
    986a:	bf00      	nop
    986c:	2000e1fc 	.word	0x2000e1fc
    9870:	2000e0f0 	.word	0x2000e0f0
    9874:	2000e440 	.word	0x2000e440
    9878:	000091c0 	.word	0x000091c0
    987c:	000091f0 	.word	0x000091f0
    9880:	00009230 	.word	0x00009230
    9884:	00009264 	.word	0x00009264
    9888:	000092a8 	.word	0x000092a8
    988c:	000092e8 	.word	0x000092e8
    9890:	0000932c 	.word	0x0000932c
    9894:	2000e43c 	.word	0x2000e43c
    9898:	00022020 	.word	0x00022020
    989c:	00009370 	.word	0x00009370
    98a0:	2000d1d4 	.word	0x2000d1d4
    98a4:	2000e434 	.word	0x2000e434
    98a8:	2000e318 	.word	0x2000e318
    98ac:	2000dc84 	.word	0x2000dc84
    98b0:	00009378 	.word	0x00009378
            tcpip_stack_ctrl_data.powerMode = powerMode;
    98b4:	7770      	strb	r0, [r6, #29]
            tcpip_stack_ctrl_data.pNetIf = pIf;
    98b6:	6174      	str	r4, [r6, #20]
            tcpip_stack_ctrl_data.netIx = netIx;
    98b8:	61b7      	str	r7, [r6, #24]
            if(!TCPIP_STACK_BringNetUp(&tcpip_stack_ctrl_data, pUsrConfig, pModConfig, nModules))
    98ba:	465b      	mov	r3, fp
    98bc:	464a      	mov	r2, r9
    98be:	4629      	mov	r1, r5
    98c0:	4630      	mov	r0, r6
    98c2:	f004 f8c5 	bl	da50 <TCPIP_STACK_BringNetUp>
    98c6:	b358      	cbz	r0, 9920 <_TCPIP_DoInitialize+0x3b8>
        for(netIx = 0, pIf = tcpipNetIf; netIx < nNets; netIx++, pIf++, pUsrConfig++)
    98c8:	3701      	adds	r7, #1
    98ca:	346c      	adds	r4, #108	; 0x6c
    98cc:	3538      	adds	r5, #56	; 0x38
    98ce:	45b8      	cmp	r8, r7
    98d0:	d028      	beq.n	9924 <_TCPIP_DoInitialize+0x3bc>
            powerMode = TCPIP_Helper_StringToPowerMode(pUsrConfig->powerMode);
    98d2:	6a28      	ldr	r0, [r5, #32]
    98d4:	f015 fcb0 	bl	1f238 <TCPIP_Helper_StringToPowerMode>
            if(powerMode != TCPIP_MAC_POWER_FULL && powerMode != TCPIP_MAC_POWER_DOWN)
    98d8:	f000 03fd 	and.w	r3, r0, #253	; 0xfd
    98dc:	2b01      	cmp	r3, #1
    98de:	d0e9      	beq.n	98b4 <_TCPIP_DoInitialize+0x34c>
    98e0:	4680      	mov	r8, r0
                SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Power Mode initialization fail: %d\r\n", powerMode);
    98e2:	f018 fbb5 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
    98e6:	2800      	cmp	r0, #0
    98e8:	d1b7      	bne.n	985a <_TCPIP_DoInitialize+0x2f2>
                initFail = 7;
    98ea:	2407      	movs	r4, #7
    98ec:	e6a1      	b.n	9632 <_TCPIP_DoInitialize+0xca>
    SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Initialization failed %d - Aborting! \r\n", initFail);
    98ee:	f018 fba9 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
    98f2:	4622      	mov	r2, r4
    98f4:	4921      	ldr	r1, [pc, #132]	; (997c <_TCPIP_DoInitialize+0x414>)
    98f6:	f011 f8d1 	bl	1aa9c <SYS_CONSOLE_Print>
    98fa:	e69f      	b.n	963c <_TCPIP_DoInitialize+0xd4>
        return false;
    98fc:	2300      	movs	r3, #0
    98fe:	9303      	str	r3, [sp, #12]
}
    9900:	9803      	ldr	r0, [sp, #12]
    9902:	b00b      	add	sp, #44	; 0x2c
    9904:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return false;
    9908:	2300      	movs	r3, #0
    990a:	9303      	str	r3, [sp, #12]
    990c:	e7f8      	b.n	9900 <_TCPIP_DoInitialize+0x398>
    990e:	2300      	movs	r3, #0
    9910:	9303      	str	r3, [sp, #12]
    9912:	e7f5      	b.n	9900 <_TCPIP_DoInitialize+0x398>
    9914:	2300      	movs	r3, #0
    9916:	9303      	str	r3, [sp, #12]
    9918:	e7f2      	b.n	9900 <_TCPIP_DoInitialize+0x398>
    991a:	2300      	movs	r3, #0
    991c:	9303      	str	r3, [sp, #12]
    991e:	e7ef      	b.n	9900 <_TCPIP_DoInitialize+0x398>
                initFail = 8;
    9920:	2408      	movs	r4, #8
    if(!initFail)
    9922:	e686      	b.n	9632 <_TCPIP_DoInitialize+0xca>
}
#define TCPIP_HEAP_MaxSize(h) TCPIP_HEAP_MaxSizeInline(h)

static __inline__ size_t __attribute__((always_inline)) TCPIP_HEAP_FreeSizeInline(TCPIP_STACK_HEAP_HANDLE h)
{
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_FreeSize)(h);
    9924:	9805      	ldr	r0, [sp, #20]
    9926:	6983      	ldr	r3, [r0, #24]
    9928:	4798      	blx	r3
    992a:	4604      	mov	r4, r0
        if(heapLeft < TCPIP_STACK_DRAM_RUN_LIMIT)
    992c:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
    9930:	d2e6      	bcs.n	9900 <_TCPIP_DoInitialize+0x398>
            SYS_ERROR_PRINT(SYS_ERROR_WARNING, TCPIP_STACK_HDR_MESSAGE "Dynamic memory is low: %lu\r\n", heapLeft);
    9932:	f018 fb8d 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
    9936:	2801      	cmp	r0, #1
    9938:	d9e2      	bls.n	9900 <_TCPIP_DoInitialize+0x398>
    993a:	f018 fb83 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
    993e:	4622      	mov	r2, r4
    9940:	490f      	ldr	r1, [pc, #60]	; (9980 <_TCPIP_DoInitialize+0x418>)
    9942:	f011 f8ab 	bl	1aa9c <SYS_CONSOLE_Print>
    9946:	e7db      	b.n	9900 <_TCPIP_DoInitialize+0x398>
        if(pModConfig->moduleId == moduleId)
    9948:	464b      	mov	r3, r9
    994a:	e640      	b.n	95ce <_TCPIP_DoInitialize+0x66>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Heap creation failed, type: %d\r\n", heapData ? heapData->heapType : TCPIP_STACK_HEAP_TYPE_NONE);
    994c:	f018 fb7a 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
    9950:	e688      	b.n	9664 <_TCPIP_DoInitialize+0xfc>
    9952:	f018 fb7d 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
    9956:	2800      	cmp	r0, #0
    9958:	d1f8      	bne.n	994c <_TCPIP_DoInitialize+0x3e4>
            initFail = 1;
    995a:	2401      	movs	r4, #1
    995c:	e669      	b.n	9632 <_TCPIP_DoInitialize+0xca>
        for(netIx = 0, pIf = tcpipNetIf; netIx < nNets; netIx++, pIf++)
    995e:	4b09      	ldr	r3, [pc, #36]	; (9984 <_TCPIP_DoInitialize+0x41c>)
    9960:	f8d3 e000 	ldr.w	lr, [r3]
        if(tcpip_stack_ctrl_data.nAliases != 0)
    9964:	4b08      	ldr	r3, [pc, #32]	; (9988 <_TCPIP_DoInitialize+0x420>)
    9966:	685b      	ldr	r3, [r3, #4]
    9968:	2b00      	cmp	r3, #0
    996a:	f43f af23 	beq.w	97b4 <_TCPIP_DoInitialize+0x24c>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration: Aliases not supported: %d\r\n", tcpip_stack_ctrl_data.nAliases);
    996e:	f018 fb6f 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
    9972:	2800      	cmp	r0, #0
    9974:	f47f aef2 	bne.w	975c <_TCPIP_DoInitialize+0x1f4>
            initFail = 5;
    9978:	2405      	movs	r4, #5
    997a:	e65a      	b.n	9632 <_TCPIP_DoInitialize+0xca>
    997c:	000093d8 	.word	0x000093d8
    9980:	000093ac 	.word	0x000093ac
    9984:	2000e440 	.word	0x2000e440
    9988:	2000e0f0 	.word	0x2000e0f0

Disassembly of section .text.SYS_CMD_Tasks%197:

0000998c <SYS_CMD_Tasks>:

}

// Maintains the Command Processor System Service's internal state machine.
bool SYS_CMD_Tasks(void)
{
    998c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9990:	b0a3      	sub	sp, #140	; 0x8c
    SYS_CMD_IO_DCPT* pCmdIO;
    for(pCmdIO = cmdIODevList.head; pCmdIO != 0; pCmdIO = pCmdIO->next)
    9992:	4bb4      	ldr	r3, [pc, #720]	; (9c64 <SYS_CMD_Tasks+0x2d8>)
    9994:	f8d3 b000 	ldr.w	fp, [r3]
    9998:	f1bb 0f00 	cmp.w	fp, #0
    999c:	f000 81f9 	beq.w	9d92 <SYS_CMD_Tasks+0x406>
        if(pCmdIO->seqChars == VT100_DETECT_SEQ_SIZE)
        {   // detect the exact escape sequence
            pCmdIO->seqBuff[pCmdIO->seqChars] = 0;
            pKeyDcpt = keySeqTbl;
            pFoundSeq = 0;
            for(ix = 0; ix < sizeof(keySeqTbl) / sizeof(*keySeqTbl); ix++, pKeyDcpt++)
    99a0:	465e      	mov	r6, fp
    99a2:	e0be      	b.n	9b22 <SYS_CMD_Tasks+0x196>
            pCmdIO->seqBuff[pCmdIO->seqChars] = 0;
    99a4:	2300      	movs	r3, #0
    99a6:	7573      	strb	r3, [r6, #21]
            pKeyDcpt = keySeqTbl;
    99a8:	4daf      	ldr	r5, [pc, #700]	; (9c68 <SYS_CMD_Tasks+0x2dc>)
            {
                if(strncmp(pCmdIO->seqBuff, pKeyDcpt->keyCode, VT100_DETECT_SEQ_SIZE) == 0)
    99aa:	f106 0812 	add.w	r8, r6, #18
    99ae:	2703      	movs	r7, #3
    99b0:	463a      	mov	r2, r7
    99b2:	6829      	ldr	r1, [r5, #0]
    99b4:	4640      	mov	r0, r8
    99b6:	f016 fe65 	bl	20684 <strncmp>
    99ba:	2800      	cmp	r0, #0
    99bc:	f000 81e7 	beq.w	9d8e <SYS_CMD_Tasks+0x402>
            for(ix = 0; ix < sizeof(keySeqTbl) / sizeof(*keySeqTbl); ix++, pKeyDcpt++)
    99c0:	350c      	adds	r5, #12
    99c2:	4baa      	ldr	r3, [pc, #680]	; (9c6c <SYS_CMD_Tasks+0x2e0>)
    99c4:	429d      	cmp	r5, r3
    99c6:	d1f3      	bne.n	99b0 <SYS_CMD_Tasks+0x24>
                }
            }

            if(pFoundSeq == 0)
            {   // unknown escape sequence
                pCmdIO->seqChars = 0;
    99c8:	2300      	movs	r3, #0
    99ca:	8233      	strh	r3, [r6, #16]
                return;
    99cc:	e0a5      	b.n	9b1a <SYS_CMD_Tasks+0x18e>
        }

        return;

    }
    else if((newCh == '\r') || (newCh == '\n'))
    99ce:	280d      	cmp	r0, #13
    99d0:	d03a      	beq.n	9a48 <SYS_CMD_Tasks+0xbc>
    99d2:	280a      	cmp	r0, #10
    99d4:	d038      	beq.n	9a48 <SYS_CMD_Tasks+0xbc>
        pCmdIO->cmdPnt = pCmdIO->cmdEnd = pCmdIO->cmdBuff;

        ParseCmdBuffer(pCmdIO);
        (*pCmdApi->msg)(cmdIoParam, _promptStr);
    }
    else if(newCh == '\b')
    99d6:	2808      	cmp	r0, #8
    99d8:	f000 8166 	beq.w	9ca8 <SYS_CMD_Tasks+0x31c>
                (*pCmdApi->msg)(cmdIoParam, "\b\x1b[K");
                pCmdIO->cmdPnt--; pCmdIO->cmdEnd--;
            }
        }
    }
    else if(newCh == 0x7f)
    99dc:	287f      	cmp	r0, #127	; 0x7f
    99de:	f000 819a 	beq.w	9d16 <SYS_CMD_Tasks+0x38a>
            *pCmdIO->cmdEnd = '\0';
            sprintf(pCmdIO->ctrlBuff, "\x1b[K%s\x1b[%dD", pCmdIO->cmdPnt, len);
            (*pCmdApi->msg)(cmdIoParam, pCmdIO->ctrlBuff);
        }
    }
    else if(newCh == 0x1b)
    99e2:	281b      	cmp	r0, #27
    99e4:	f000 81ba 	beq.w	9d5c <SYS_CMD_Tasks+0x3d0>
    {   // start escape sequence... wait for complete sequence
        pCmdIO->seqBuff[0] = newCh;
        pCmdIO->seqChars = 1;
    }
    else if(pCmdIO->cmdEnd - pCmdIO->cmdBuff < sizeof(pCmdIO->cmdBuff) - 1)
    99e8:	69f2      	ldr	r2, [r6, #28]
    99ea:	f106 0520 	add.w	r5, r6, #32
    99ee:	1b53      	subs	r3, r2, r5
    99f0:	2b4f      	cmp	r3, #79	; 0x4f
    99f2:	f200 81bc 	bhi.w	9d6e <SYS_CMD_Tasks+0x3e2>
    {   // valid char; insert and echo it back
        int n_chars = pCmdIO->cmdEnd - pCmdIO->cmdPnt;  // existent chars
    99f6:	69b3      	ldr	r3, [r6, #24]
        if(n_chars != 0)
    99f8:	1ad3      	subs	r3, r2, r3
    99fa:	f000 81b4 	beq.w	9d66 <SYS_CMD_Tasks+0x3da>
        {   // move the existing chars to the right, for insertion...
            char* pSrc = pCmdIO->cmdEnd - 1;
            char* pDst = pCmdIO->cmdEnd;
            for(ix = 0; ix < n_chars; ix++)
    99fe:	2b00      	cmp	r3, #0
    9a00:	dd05      	ble.n	9a0e <SYS_CMD_Tasks+0x82>
    9a02:	1ad0      	subs	r0, r2, r3
            {
                *pDst-- = *pSrc--;
    9a04:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
    9a08:	7051      	strb	r1, [r2, #1]
            for(ix = 0; ix < n_chars; ix++)
    9a0a:	4282      	cmp	r2, r0
    9a0c:	d1fa      	bne.n	9a04 <SYS_CMD_Tasks+0x78>
            }
            pCmdIO->cmdEnd++;
    9a0e:	69f2      	ldr	r2, [r6, #28]
    9a10:	1c51      	adds	r1, r2, #1
    9a12:	61f1      	str	r1, [r6, #28]
            *pCmdIO->cmdEnd = '\0';
    9a14:	2100      	movs	r1, #0
    9a16:	7051      	strb	r1, [r2, #1]
            sprintf(pCmdIO->ctrlBuff + 1, "%s\x1b[%dD", pCmdIO->cmdPnt + 1, n_chars);
    9a18:	69b2      	ldr	r2, [r6, #24]
    9a1a:	3201      	adds	r2, #1
    9a1c:	4994      	ldr	r1, [pc, #592]	; (9c70 <SYS_CMD_Tasks+0x2e4>)
    9a1e:	f106 0072 	add.w	r0, r6, #114	; 0x72
    9a22:	f013 fec1 	bl	1d7a8 <siprintf>
        }
        else
        {
            pCmdIO->ctrlBuff[1] = 0;
        }
        pCmdIO->ctrlBuff[0] = newCh;
    9a26:	4631      	mov	r1, r6
    9a28:	f801 4f71 	strb.w	r4, [r1, #113]!

        (*pCmdApi->msg)(cmdIoParam, pCmdIO->ctrlBuff);
    9a2c:	f8da 3000 	ldr.w	r3, [sl]
    9a30:	4648      	mov	r0, r9
    9a32:	4798      	blx	r3
        *pCmdIO->cmdPnt++ = newCh;
    9a34:	69b3      	ldr	r3, [r6, #24]
    9a36:	1c5a      	adds	r2, r3, #1
    9a38:	61b2      	str	r2, [r6, #24]
    9a3a:	701c      	strb	r4, [r3, #0]
    return pN;
}

static void CmdAdjustPointers(SYS_CMD_IO_DCPT* pCmdIO)
{
    if(pCmdIO->cmdPnt > pCmdIO->cmdEnd)
    9a3c:	69b3      	ldr	r3, [r6, #24]
    9a3e:	69f2      	ldr	r2, [r6, #28]
    9a40:	4293      	cmp	r3, r2
    9a42:	d96a      	bls.n	9b1a <SYS_CMD_Tasks+0x18e>
    {
        pCmdIO->cmdEnd = pCmdIO->cmdPnt;
    9a44:	61f3      	str	r3, [r6, #28]
    9a46:	e068      	b.n	9b1a <SYS_CMD_Tasks+0x18e>
        if(pCmdIO->cmdEnd ==  pCmdIO->cmdBuff)
    9a48:	f106 0320 	add.w	r3, r6, #32
    9a4c:	461a      	mov	r2, r3
    9a4e:	9302      	str	r3, [sp, #8]
    9a50:	69f3      	ldr	r3, [r6, #28]
    9a52:	4293      	cmp	r3, r2
    9a54:	d01a      	beq.n	9a8c <SYS_CMD_Tasks+0x100>
        (*pCmdApi->msg)(cmdIoParam, LINE_TERM);
    9a56:	f8da 3000 	ldr.w	r3, [sl]
    9a5a:	4986      	ldr	r1, [pc, #536]	; (9c74 <SYS_CMD_Tasks+0x2e8>)
    9a5c:	4648      	mov	r0, r9
    9a5e:	4798      	blx	r3
        *pCmdIO->cmdEnd = 0;
    9a60:	69f3      	ldr	r3, [r6, #28]
    9a62:	2500      	movs	r5, #0
    9a64:	701d      	strb	r5, [r3, #0]
        pCmdIO->cmdPnt = pCmdIO->cmdEnd = pCmdIO->cmdBuff;
    9a66:	9c02      	ldr	r4, [sp, #8]
    9a68:	61f4      	str	r4, [r6, #28]
    9a6a:	61b4      	str	r4, [r6, #24]
    char *argv[MAX_CMD_ARGS] = {0};
    9a6c:	2220      	movs	r2, #32
    9a6e:	4629      	mov	r1, r5
    9a70:	a805      	add	r0, sp, #20
    9a72:	f018 f90b 	bl	21c8c <memset>
    const void* cmdIoParam = pCmdIO->devNode.cmdIoParam;
    9a76:	6873      	ldr	r3, [r6, #4]
    9a78:	9303      	str	r3, [sp, #12]
    strncpy(saveCmd, pCmdIO->cmdBuff, sizeof(saveCmd));     // make a copy of the command
    9a7a:	2251      	movs	r2, #81	; 0x51
    9a7c:	4621      	mov	r1, r4
    9a7e:	a80d      	add	r0, sp, #52	; 0x34
    9a80:	f016 fc81 	bl	20386 <strncpy>
    9a84:	ac0d      	add	r4, sp, #52	; 0x34
            *qStart = 0;
    9a86:	46ab      	mov	fp, r5
            str = 0;
    9a88:	9501      	str	r5, [sp, #4]
    9a8a:	e01e      	b.n	9aca <SYS_CMD_Tasks+0x13e>
            (*pCmdApi->msg)(cmdIoParam, LINE_TERM _promptStr);
    9a8c:	f8da 3000 	ldr.w	r3, [sl]
    9a90:	4979      	ldr	r1, [pc, #484]	; (9c78 <SYS_CMD_Tasks+0x2ec>)
    9a92:	4648      	mov	r0, r9
    9a94:	4798      	blx	r3
            return;
    9a96:	e040      	b.n	9b1a <SYS_CMD_Tasks+0x18e>
        if(qStart == 0)
    9a98:	b397      	cbz	r7, 9b00 <SYS_CMD_Tasks+0x174>
        qStart++;
    9a9a:	3701      	adds	r7, #1
        qEnd = strchr(qStart, '"');
    9a9c:	2122      	movs	r1, #34	; 0x22
    9a9e:	4638      	mov	r0, r7
    9aa0:	f017 fc69 	bl	21376 <strchr>
        if(qEnd == 0 || qEnd - qStart == 0)
    9aa4:	4604      	mov	r4, r0
    9aa6:	2800      	cmp	r0, #0
    9aa8:	f000 80f8 	beq.w	9c9c <SYS_CMD_Tasks+0x310>
    9aac:	4287      	cmp	r7, r0
    9aae:	f000 80f5 	beq.w	9c9c <SYS_CMD_Tasks+0x310>
        *qEnd = 0;
    9ab2:	f880 b000 	strb.w	fp, [r0]
        if(nArgs < argvSize)
    9ab6:	2d07      	cmp	r5, #7
    9ab8:	d804      	bhi.n	9ac4 <SYS_CMD_Tasks+0x138>
            argv[nArgs] = qStart;
    9aba:	ab22      	add	r3, sp, #136	; 0x88
    9abc:	eb03 0385 	add.w	r3, r3, r5, lsl #2
    9ac0:	f843 7c74 	str.w	r7, [r3, #-116]
        nArgs++;
    9ac4:	3501      	adds	r5, #1
    while(str)
    9ac6:	3401      	adds	r4, #1
    9ac8:	d01a      	beq.n	9b00 <SYS_CMD_Tasks+0x174>
        qStart = strchr(str, '"');
    9aca:	2122      	movs	r1, #34	; 0x22
    9acc:	4620      	mov	r0, r4
    9ace:	f017 fc52 	bl	21376 <strchr>
        if(qStart != 0)
    9ad2:	4607      	mov	r7, r0
    9ad4:	b108      	cbz	r0, 9ada <SYS_CMD_Tasks+0x14e>
            *qStart = 0;
    9ad6:	f880 b000 	strb.w	fp, [r0]
    9ada:	ab05      	add	r3, sp, #20
    9adc:	eb03 0885 	add.w	r8, r3, r5, lsl #2
    9ae0:	4620      	mov	r0, r4
        while((pTkn = strtok(str, " \t,")) != 0)
    9ae2:	4966      	ldr	r1, [pc, #408]	; (9c7c <SYS_CMD_Tasks+0x2f0>)
    9ae4:	f012 fc42 	bl	1c36c <strtok>
    9ae8:	4603      	mov	r3, r0
    9aea:	2800      	cmp	r0, #0
    9aec:	d0d4      	beq.n	9a98 <SYS_CMD_Tasks+0x10c>
            if(nArgs < argvSize)
    9aee:	2d07      	cmp	r5, #7
                argv[nArgs] = pTkn;
    9af0:	bf98      	it	ls
    9af2:	f8c8 3000 	strls.w	r3, [r8]
            nArgs++;
    9af6:	3501      	adds	r5, #1
    9af8:	f108 0804 	add.w	r8, r8, #4
            str = 0;
    9afc:	9801      	ldr	r0, [sp, #4]
    9afe:	e7f0      	b.n	9ae2 <SYS_CMD_Tasks+0x156>
    if(argc > MAX_CMD_ARGS)
    9b00:	2d08      	cmp	r5, #8
    9b02:	dd3d      	ble.n	9b80 <SYS_CMD_Tasks+0x1f4>
        (*pCmdIO->devNode.pCmdApi->print)(cmdIoParam, "\n\r Too many arguments. Maximum args supported: %d!\r\n", MAX_CMD_ARGS);
    9b04:	6833      	ldr	r3, [r6, #0]
    9b06:	685b      	ldr	r3, [r3, #4]
    9b08:	2208      	movs	r2, #8
    9b0a:	495d      	ldr	r1, [pc, #372]	; (9c80 <SYS_CMD_Tasks+0x2f4>)
    9b0c:	9803      	ldr	r0, [sp, #12]
    9b0e:	4798      	blx	r3
        (*pCmdApi->msg)(cmdIoParam, _promptStr);
    9b10:	f8da 3000 	ldr.w	r3, [sl]
    9b14:	495b      	ldr	r1, [pc, #364]	; (9c84 <SYS_CMD_Tasks+0x2f8>)
    9b16:	4648      	mov	r0, r9
    9b18:	4798      	blx	r3
    for(pCmdIO = cmdIODevList.head; pCmdIO != 0; pCmdIO = pCmdIO->next)
    9b1a:	68b6      	ldr	r6, [r6, #8]
    9b1c:	2e00      	cmp	r6, #0
    9b1e:	f000 8138 	beq.w	9d92 <SYS_CMD_Tasks+0x406>
    const SYS_CMD_API* pCmdApi = pCmdIO->devNode.pCmdApi;
    9b22:	f8d6 a000 	ldr.w	sl, [r6]
    const void* cmdIoParam = pCmdIO->devNode.cmdIoParam;
    9b26:	f8d6 9004 	ldr.w	r9, [r6, #4]
    if(!(*pCmdApi->isRdy)(cmdIoParam))
    9b2a:	f8da 300c 	ldr.w	r3, [sl, #12]
    9b2e:	4648      	mov	r0, r9
    9b30:	4798      	blx	r3
    9b32:	2800      	cmp	r0, #0
    9b34:	d0f1      	beq.n	9b1a <SYS_CMD_Tasks+0x18e>
    newCh = (*pCmdApi->getc)(cmdIoParam); /* Read data from console. */
    9b36:	f8da 3010 	ldr.w	r3, [sl, #16]
    9b3a:	4648      	mov	r0, r9
    9b3c:	4798      	blx	r3
    9b3e:	4604      	mov	r4, r0
    if(pCmdIO->seqChars != 0)
    9b40:	f9b6 3010 	ldrsh.w	r3, [r6, #16]
    9b44:	2b00      	cmp	r3, #0
    9b46:	f43f af42 	beq.w	99ce <SYS_CMD_Tasks+0x42>
        pCmdIO->seqBuff[pCmdIO->seqChars] = newCh;
    9b4a:	18f2      	adds	r2, r6, r3
    9b4c:	7490      	strb	r0, [r2, #18]
        pCmdIO->seqChars++;
    9b4e:	3301      	adds	r3, #1
    9b50:	b21c      	sxth	r4, r3
    9b52:	8234      	strh	r4, [r6, #16]
        if(pCmdIO->seqChars == VT100_DETECT_SEQ_SIZE)
    9b54:	2c03      	cmp	r4, #3
    9b56:	f43f af25 	beq.w	99a4 <SYS_CMD_Tasks+0x18>
        if(pCmdIO->seqChars >= VT100_DETECT_SEQ_SIZE && pCmdIO->seqChars == pCmdIO->pSeqDcpt->keySize)
    9b5a:	2c02      	cmp	r4, #2
    9b5c:	dddd      	ble.n	9b1a <SYS_CMD_Tasks+0x18e>
    9b5e:	68f5      	ldr	r5, [r6, #12]
    9b60:	68ab      	ldr	r3, [r5, #8]
    9b62:	429c      	cmp	r4, r3
    9b64:	d1d9      	bne.n	9b1a <SYS_CMD_Tasks+0x18e>
            if(strcmp(pCmdIO->seqBuff, pCmdIO->pSeqDcpt->keyCode) == 0)
    9b66:	6829      	ldr	r1, [r5, #0]
    9b68:	f106 0012 	add.w	r0, r6, #18
    9b6c:	f017 ff56 	bl	21a1c <strcmp>
    9b70:	b918      	cbnz	r0, 9b7a <SYS_CMD_Tasks+0x1ee>
                (*pCmdIO->pSeqDcpt->keyFnc)(pCmdIO, pCmdIO->pSeqDcpt);
    9b72:	686b      	ldr	r3, [r5, #4]
    9b74:	4629      	mov	r1, r5
    9b76:	4630      	mov	r0, r6
    9b78:	4798      	blx	r3
            pCmdIO->seqChars = 0;
    9b7a:	2300      	movs	r3, #0
    9b7c:	8233      	strh	r3, [r6, #16]
            return;
    9b7e:	e7cc      	b.n	9b1a <SYS_CMD_Tasks+0x18e>
    else if(argc == 0)
    9b80:	b92d      	cbnz	r5, 9b8e <SYS_CMD_Tasks+0x202>
        (*pCmdIO->devNode.pCmdApi->msg)(cmdIoParam, " *** Command Processor: Please type in a command***" LINE_TERM);
    9b82:	6833      	ldr	r3, [r6, #0]
    9b84:	681b      	ldr	r3, [r3, #0]
    9b86:	4940      	ldr	r1, [pc, #256]	; (9c88 <SYS_CMD_Tasks+0x2fc>)
    9b88:	9803      	ldr	r0, [sp, #12]
    9b8a:	4798      	blx	r3
    9b8c:	e7c0      	b.n	9b10 <SYS_CMD_Tasks+0x184>
        if(argc > 0)
    9b8e:	2d00      	cmp	r5, #0
    9b90:	f340 8084 	ble.w	9c9c <SYS_CMD_Tasks+0x310>
    if(pL->head == pL->tail)
    9b94:	f8d6 30cc 	ldr.w	r3, [r6, #204]	; 0xcc
    9b98:	f8d6 40d0 	ldr.w	r4, [r6, #208]	; 0xd0
    9b9c:	42a3      	cmp	r3, r4
    9b9e:	d02e      	beq.n	9bfe <SYS_CMD_Tasks+0x272>
        pL->tail = pN->prev;
    9ba0:	6862      	ldr	r2, [r4, #4]
    9ba2:	f8c6 20d0 	str.w	r2, [r6, #208]	; 0xd0
        pL->tail->next = pL->head;
    9ba6:	6013      	str	r3, [r2, #0]
        pL->head->prev = pL->tail;
    9ba8:	f8d6 30cc 	ldr.w	r3, [r6, #204]	; 0xcc
    9bac:	f8d6 20d0 	ldr.w	r2, [r6, #208]	; 0xd0
    9bb0:	605a      	str	r2, [r3, #4]
            strncpy(pN->cmdBuff, pCmdIO->cmdBuff, sizeof(saveCmd)); // Need save non-parsed string
    9bb2:	2251      	movs	r2, #81	; 0x51
    9bb4:	9902      	ldr	r1, [sp, #8]
    9bb6:	f104 0008 	add.w	r0, r4, #8
    9bba:	f016 fbe4 	bl	20386 <strncpy>
    if(pL->head == 0)
    9bbe:	f8d6 30cc 	ldr.w	r3, [r6, #204]	; 0xcc
    9bc2:	b31b      	cbz	r3, 9c0c <SYS_CMD_Tasks+0x280>
        pN->next = pL->head;
    9bc4:	6023      	str	r3, [r4, #0]
        pN->prev = pL->tail;
    9bc6:	f8d6 30d0 	ldr.w	r3, [r6, #208]	; 0xd0
    9bca:	6063      	str	r3, [r4, #4]
        pL->tail->next = pN;
    9bcc:	601c      	str	r4, [r3, #0]
        pL->head->prev = pN;
    9bce:	f8d6 30cc 	ldr.w	r3, [r6, #204]	; 0xcc
    9bd2:	605c      	str	r4, [r3, #4]
        pL->head = pN;
    9bd4:	f8c6 40cc 	str.w	r4, [r6, #204]	; 0xcc
            pCmdIO->currHistN = 0;
    9bd8:	2300      	movs	r3, #0
    9bda:	f8c6 30d4 	str.w	r3, [r6, #212]	; 0xd4
                if(!strcmp(argv[0], pDcpt->cmdStr))
    9bde:	9b05      	ldr	r3, [sp, #20]
    9be0:	9301      	str	r3, [sp, #4]
            for(ix = 0, pDcpt = _builtinCmdTbl; ix < sizeof(_builtinCmdTbl)/sizeof(*_builtinCmdTbl); ix++, pDcpt++)
    9be2:	4c2a      	ldr	r4, [pc, #168]	; (9c8c <SYS_CMD_Tasks+0x300>)
                if(!strcmp(argv[0], pDcpt->cmdStr))
    9be4:	6821      	ldr	r1, [r4, #0]
    9be6:	9801      	ldr	r0, [sp, #4]
    9be8:	f017 ff18 	bl	21a1c <strcmp>
    9bec:	b1a8      	cbz	r0, 9c1a <SYS_CMD_Tasks+0x28e>
            for(ix = 0, pDcpt = _builtinCmdTbl; ix < sizeof(_builtinCmdTbl)/sizeof(*_builtinCmdTbl); ix++, pDcpt++)
    9bee:	340c      	adds	r4, #12
    9bf0:	4b27      	ldr	r3, [pc, #156]	; (9c90 <SYS_CMD_Tasks+0x304>)
    9bf2:	429c      	cmp	r4, r3
    9bf4:	d1f6      	bne.n	9be4 <SYS_CMD_Tasks+0x258>
    9bf6:	f8df b0a0 	ldr.w	fp, [pc, #160]	; 9c98 <SYS_CMD_Tasks+0x30c>
    9bfa:	46a8      	mov	r8, r5
    9bfc:	e01e      	b.n	9c3c <SYS_CMD_Tasks+0x2b0>
        pL->head = pL->tail = 0;
    9bfe:	2200      	movs	r2, #0
    9c00:	f8c6 20d0 	str.w	r2, [r6, #208]	; 0xd0
    9c04:	f8c6 20cc 	str.w	r2, [r6, #204]	; 0xcc
        pN = pL->head;
    9c08:	461c      	mov	r4, r3
    9c0a:	e7d2      	b.n	9bb2 <SYS_CMD_Tasks+0x226>
        pL->head = pL->tail = pN;
    9c0c:	f8c6 40d0 	str.w	r4, [r6, #208]	; 0xd0
    9c10:	f8c6 40cc 	str.w	r4, [r6, #204]	; 0xcc
        pN->next = pN->prev = pN;
    9c14:	6064      	str	r4, [r4, #4]
    9c16:	6024      	str	r4, [r4, #0]
    9c18:	e7de      	b.n	9bd8 <SYS_CMD_Tasks+0x24c>
                    (*pDcpt->cmdFnc)(&pCmdIO->devNode, argc, argv);     // call command handler
    9c1a:	6863      	ldr	r3, [r4, #4]
    9c1c:	aa05      	add	r2, sp, #20
    9c1e:	4629      	mov	r1, r5
    9c20:	4630      	mov	r0, r6
    9c22:	4798      	blx	r3
                    return;
    9c24:	e774      	b.n	9b10 <SYS_CMD_Tasks+0x184>
                        (*pDcpt->cmdFnc)(&pCmdIO->devNode, argc, argv);
    9c26:	6863      	ldr	r3, [r4, #4]
    9c28:	aa05      	add	r2, sp, #20
    9c2a:	4641      	mov	r1, r8
    9c2c:	4630      	mov	r0, r6
    9c2e:	4798      	blx	r3
                        return;
    9c30:	e76e      	b.n	9b10 <SYS_CMD_Tasks+0x184>
    9c32:	f10b 0b10 	add.w	fp, fp, #16
            for (grp_ix=0; grp_ix < MAX_CMD_GROUP; grp_ix++)
    9c36:	4b17      	ldr	r3, [pc, #92]	; (9c94 <SYS_CMD_Tasks+0x308>)
    9c38:	459b      	cmp	fp, r3
    9c3a:	d02f      	beq.n	9c9c <SYS_CMD_Tasks+0x310>
                if (_usrCmdTbl[grp_ix].pCmd == 0)
    9c3c:	f8db 4004 	ldr.w	r4, [fp, #4]
    9c40:	2c00      	cmp	r4, #0
    9c42:	d0f6      	beq.n	9c32 <SYS_CMD_Tasks+0x2a6>
                for(ix = 0, pDcpt = _usrCmdTbl[grp_ix].pCmd; ix < _usrCmdTbl[grp_ix].nCmds; ix++, pDcpt++)
    9c44:	f8db 5000 	ldr.w	r5, [fp]
    9c48:	2d00      	cmp	r5, #0
    9c4a:	ddf2      	ble.n	9c32 <SYS_CMD_Tasks+0x2a6>
    9c4c:	2700      	movs	r7, #0
                    if(!strcmp(argv[0], pDcpt->cmdStr))
    9c4e:	6821      	ldr	r1, [r4, #0]
    9c50:	9801      	ldr	r0, [sp, #4]
    9c52:	f017 fee3 	bl	21a1c <strcmp>
    9c56:	2800      	cmp	r0, #0
    9c58:	d0e5      	beq.n	9c26 <SYS_CMD_Tasks+0x29a>
                for(ix = 0, pDcpt = _usrCmdTbl[grp_ix].pCmd; ix < _usrCmdTbl[grp_ix].nCmds; ix++, pDcpt++)
    9c5a:	3701      	adds	r7, #1
    9c5c:	340c      	adds	r4, #12
    9c5e:	42af      	cmp	r7, r5
    9c60:	d1f5      	bne.n	9c4e <SYS_CMD_Tasks+0x2c2>
    9c62:	e7e6      	b.n	9c32 <SYS_CMD_Tasks+0x2a6>
    9c64:	2000e360 	.word	0x2000e360
    9c68:	0001d008 	.word	0x0001d008
    9c6c:	0001d050 	.word	0x0001d050
    9c70:	0000d2ac 	.word	0x0000d2ac
    9c74:	0000d15c 	.word	0x0000d15c
    9c78:	0000d0f0 	.word	0x0000d0f0
    9c7c:	0000d1e4 	.word	0x0000d1e4
    9c80:	0000d1e8 	.word	0x0000d1e8
    9c84:	0000d288 	.word	0x0000d288
    9c88:	0000d220 	.word	0x0000d220
    9c8c:	0002055c 	.word	0x0002055c
    9c90:	00020580 	.word	0x00020580
    9c94:	2000de18 	.word	0x2000de18
    9c98:	2000dd98 	.word	0x2000dd98
        (*pCmdIO->devNode.pCmdApi->msg)(cmdIoParam, " *** Command Processor: unknown command. ***\r\n");
    9c9c:	6833      	ldr	r3, [r6, #0]
    9c9e:	681b      	ldr	r3, [r3, #0]
    9ca0:	493e      	ldr	r1, [pc, #248]	; (9d9c <SYS_CMD_Tasks+0x410>)
    9ca2:	9803      	ldr	r0, [sp, #12]
    9ca4:	4798      	blx	r3
    9ca6:	e733      	b.n	9b10 <SYS_CMD_Tasks+0x184>
        if(pCmdIO->cmdPnt > pCmdIO->cmdBuff)
    9ca8:	69b1      	ldr	r1, [r6, #24]
    9caa:	f106 0320 	add.w	r3, r6, #32
    9cae:	4299      	cmp	r1, r3
    9cb0:	f67f af33 	bls.w	9b1a <SYS_CMD_Tasks+0x18e>
            if(pCmdIO->cmdEnd > pCmdIO->cmdPnt)
    9cb4:	69f3      	ldr	r3, [r6, #28]
    9cb6:	4299      	cmp	r1, r3
    9cb8:	d221      	bcs.n	9cfe <SYS_CMD_Tasks+0x372>
                char* pDst = pCmdIO->cmdPnt - 1;
    9cba:	1e4a      	subs	r2, r1, #1
                len = pCmdIO->cmdEnd - pSrc;
    9cbc:	1a5b      	subs	r3, r3, r1
                for(ix = 0; ix < len; ix++)
    9cbe:	2b00      	cmp	r3, #0
    9cc0:	dd07      	ble.n	9cd2 <SYS_CMD_Tasks+0x346>
    9cc2:	1e58      	subs	r0, r3, #1
    9cc4:	4401      	add	r1, r0
                    *pDst++ = *pSrc++;
    9cc6:	f812 0f01 	ldrb.w	r0, [r2, #1]!
    9cca:	f802 0c01 	strb.w	r0, [r2, #-1]
                for(ix = 0; ix < len; ix++)
    9cce:	428a      	cmp	r2, r1
    9cd0:	d1f9      	bne.n	9cc6 <SYS_CMD_Tasks+0x33a>
                pCmdIO->cmdPnt--; pCmdIO->cmdEnd--;
    9cd2:	69b2      	ldr	r2, [r6, #24]
    9cd4:	3a01      	subs	r2, #1
    9cd6:	61b2      	str	r2, [r6, #24]
    9cd8:	69f2      	ldr	r2, [r6, #28]
    9cda:	1e51      	subs	r1, r2, #1
    9cdc:	61f1      	str	r1, [r6, #28]
                *pCmdIO->cmdEnd = '\0';
    9cde:	2100      	movs	r1, #0
    9ce0:	f802 1c01 	strb.w	r1, [r2, #-1]
                sprintf(pCmdIO->ctrlBuff, "\b\x1b[K%s\x1b[%dD", pCmdIO->cmdPnt, len);
    9ce4:	f106 0471 	add.w	r4, r6, #113	; 0x71
    9ce8:	69b2      	ldr	r2, [r6, #24]
    9cea:	492d      	ldr	r1, [pc, #180]	; (9da0 <SYS_CMD_Tasks+0x414>)
    9cec:	4620      	mov	r0, r4
    9cee:	f013 fd5b 	bl	1d7a8 <siprintf>
                (*pCmdApi->msg)(cmdIoParam, pCmdIO->ctrlBuff);
    9cf2:	f8da 3000 	ldr.w	r3, [sl]
    9cf6:	4621      	mov	r1, r4
    9cf8:	4648      	mov	r0, r9
    9cfa:	4798      	blx	r3
    9cfc:	e70d      	b.n	9b1a <SYS_CMD_Tasks+0x18e>
                (*pCmdApi->msg)(cmdIoParam, "\b\x1b[K");
    9cfe:	f8da 3000 	ldr.w	r3, [sl]
    9d02:	4928      	ldr	r1, [pc, #160]	; (9da4 <SYS_CMD_Tasks+0x418>)
    9d04:	4648      	mov	r0, r9
    9d06:	4798      	blx	r3
                pCmdIO->cmdPnt--; pCmdIO->cmdEnd--;
    9d08:	69b3      	ldr	r3, [r6, #24]
    9d0a:	3b01      	subs	r3, #1
    9d0c:	61b3      	str	r3, [r6, #24]
    9d0e:	69f3      	ldr	r3, [r6, #28]
    9d10:	3b01      	subs	r3, #1
    9d12:	61f3      	str	r3, [r6, #28]
    9d14:	e701      	b.n	9b1a <SYS_CMD_Tasks+0x18e>
        if(pCmdIO->cmdEnd > pCmdIO->cmdPnt)
    9d16:	69f3      	ldr	r3, [r6, #28]
    9d18:	69b2      	ldr	r2, [r6, #24]
    9d1a:	4293      	cmp	r3, r2
    9d1c:	f67f aefd 	bls.w	9b1a <SYS_CMD_Tasks+0x18e>
            char* pSrc = pCmdIO->cmdPnt + 1;
    9d20:	1c51      	adds	r1, r2, #1
            len = pCmdIO->cmdEnd - pSrc;
    9d22:	1a5b      	subs	r3, r3, r1
            for(ix = 0; ix < len; ix++)
    9d24:	2b00      	cmp	r3, #0
    9d26:	dd06      	ble.n	9d36 <SYS_CMD_Tasks+0x3aa>
    9d28:	18d0      	adds	r0, r2, r3
                *pDst++ = *pSrc++;
    9d2a:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    9d2e:	f802 1c01 	strb.w	r1, [r2, #-1]
            for(ix = 0; ix < len; ix++)
    9d32:	4282      	cmp	r2, r0
    9d34:	d1f9      	bne.n	9d2a <SYS_CMD_Tasks+0x39e>
            pCmdIO->cmdEnd--;
    9d36:	69f2      	ldr	r2, [r6, #28]
    9d38:	1e51      	subs	r1, r2, #1
    9d3a:	61f1      	str	r1, [r6, #28]
            *pCmdIO->cmdEnd = '\0';
    9d3c:	2100      	movs	r1, #0
    9d3e:	f802 1c01 	strb.w	r1, [r2, #-1]
            sprintf(pCmdIO->ctrlBuff, "\x1b[K%s\x1b[%dD", pCmdIO->cmdPnt, len);
    9d42:	f106 0471 	add.w	r4, r6, #113	; 0x71
    9d46:	69b2      	ldr	r2, [r6, #24]
    9d48:	4917      	ldr	r1, [pc, #92]	; (9da8 <SYS_CMD_Tasks+0x41c>)
    9d4a:	4620      	mov	r0, r4
    9d4c:	f013 fd2c 	bl	1d7a8 <siprintf>
            (*pCmdApi->msg)(cmdIoParam, pCmdIO->ctrlBuff);
    9d50:	f8da 3000 	ldr.w	r3, [sl]
    9d54:	4621      	mov	r1, r4
    9d56:	4648      	mov	r0, r9
    9d58:	4798      	blx	r3
    9d5a:	e6de      	b.n	9b1a <SYS_CMD_Tasks+0x18e>
        pCmdIO->seqBuff[0] = newCh;
    9d5c:	231b      	movs	r3, #27
    9d5e:	74b3      	strb	r3, [r6, #18]
        pCmdIO->seqChars = 1;
    9d60:	2301      	movs	r3, #1
    9d62:	8233      	strh	r3, [r6, #16]
    9d64:	e6d9      	b.n	9b1a <SYS_CMD_Tasks+0x18e>
            pCmdIO->ctrlBuff[1] = 0;
    9d66:	2300      	movs	r3, #0
    9d68:	f886 3072 	strb.w	r3, [r6, #114]	; 0x72
    9d6c:	e65b      	b.n	9a26 <SYS_CMD_Tasks+0x9a>
        (*pCmdApi->msg)(cmdIoParam, " *** Command Processor buffer exceeded. Retry. ***" LINE_TERM);
    9d6e:	4c0f      	ldr	r4, [pc, #60]	; (9dac <SYS_CMD_Tasks+0x420>)
    9d70:	f8da 3000 	ldr.w	r3, [sl]
    9d74:	f504 71e6 	add.w	r1, r4, #460	; 0x1cc
    9d78:	4648      	mov	r0, r9
    9d7a:	4798      	blx	r3
        pCmdIO->cmdPnt = pCmdIO->cmdEnd = pCmdIO->cmdBuff;
    9d7c:	61f5      	str	r5, [r6, #28]
    9d7e:	61b5      	str	r5, [r6, #24]
        (*pCmdApi->msg)(cmdIoParam, _promptStr);
    9d80:	f8da 3000 	ldr.w	r3, [sl]
    9d84:	f504 71d0 	add.w	r1, r4, #416	; 0x1a0
    9d88:	4648      	mov	r0, r9
    9d8a:	4798      	blx	r3
    9d8c:	e6c5      	b.n	9b1a <SYS_CMD_Tasks+0x18e>
            pCmdIO->pSeqDcpt = pFoundSeq;
    9d8e:	60f5      	str	r5, [r6, #12]
        if(pCmdIO->seqChars >= VT100_DETECT_SEQ_SIZE && pCmdIO->seqChars == pCmdIO->pSeqDcpt->keySize)
    9d90:	e6e5      	b.n	9b5e <SYS_CMD_Tasks+0x1d2>
}
    9d92:	2001      	movs	r0, #1
    9d94:	b023      	add	sp, #140	; 0x8c
    9d96:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9d9a:	bf00      	nop
    9d9c:	0000d258 	.word	0x0000d258
    9da0:	0000d28c 	.word	0x0000d28c
    9da4:	0000d298 	.word	0x0000d298
    9da8:	0000d2a0 	.word	0x0000d2a0
    9dac:	0000d0e8 	.word	0x0000d0e8

Disassembly of section .text%198:

00009db0 <__aeabi_dmul>:
    9db0:	b570      	push	{r4, r5, r6, lr}
    9db2:	f04f 0cff 	mov.w	ip, #255	; 0xff
    9db6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    9dba:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    9dbe:	bf1d      	ittte	ne
    9dc0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    9dc4:	ea94 0f0c 	teqne	r4, ip
    9dc8:	ea95 0f0c 	teqne	r5, ip
    9dcc:	f000 f8de 	bleq	9f8c <__aeabi_dmul+0x1dc>
    9dd0:	442c      	add	r4, r5
    9dd2:	ea81 0603 	eor.w	r6, r1, r3
    9dd6:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
    9dda:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
    9dde:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
    9de2:	bf18      	it	ne
    9de4:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
    9de8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    9dec:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    9df0:	d038      	beq.n	9e64 <__aeabi_dmul+0xb4>
    9df2:	fba0 ce02 	umull	ip, lr, r0, r2
    9df6:	f04f 0500 	mov.w	r5, #0
    9dfa:	fbe1 e502 	umlal	lr, r5, r1, r2
    9dfe:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
    9e02:	fbe0 e503 	umlal	lr, r5, r0, r3
    9e06:	f04f 0600 	mov.w	r6, #0
    9e0a:	fbe1 5603 	umlal	r5, r6, r1, r3
    9e0e:	f09c 0f00 	teq	ip, #0
    9e12:	bf18      	it	ne
    9e14:	f04e 0e01 	orrne.w	lr, lr, #1
    9e18:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
    9e1c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
    9e20:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
    9e24:	d204      	bcs.n	9e30 <__aeabi_dmul+0x80>
    9e26:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
    9e2a:	416d      	adcs	r5, r5
    9e2c:	eb46 0606 	adc.w	r6, r6, r6
    9e30:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
    9e34:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
    9e38:	ea4f 20c5 	mov.w	r0, r5, lsl #11
    9e3c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
    9e40:	ea4f 2ece 	mov.w	lr, lr, lsl #11
    9e44:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    9e48:	bf88      	it	hi
    9e4a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    9e4e:	d81e      	bhi.n	9e8e <__aeabi_dmul+0xde>
    9e50:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
    9e54:	bf08      	it	eq
    9e56:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
    9e5a:	f150 0000 	adcs.w	r0, r0, #0
    9e5e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    9e62:	bd70      	pop	{r4, r5, r6, pc}
    9e64:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
    9e68:	ea46 0101 	orr.w	r1, r6, r1
    9e6c:	ea40 0002 	orr.w	r0, r0, r2
    9e70:	ea81 0103 	eor.w	r1, r1, r3
    9e74:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
    9e78:	bfc2      	ittt	gt
    9e7a:	ebd4 050c 	rsbsgt	r5, r4, ip
    9e7e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    9e82:	bd70      	popgt	{r4, r5, r6, pc}
    9e84:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    9e88:	f04f 0e00 	mov.w	lr, #0
    9e8c:	3c01      	subs	r4, #1
    9e8e:	f300 80ab 	bgt.w	9fe8 <__aeabi_dmul+0x238>
    9e92:	f114 0f36 	cmn.w	r4, #54	; 0x36
    9e96:	bfde      	ittt	le
    9e98:	2000      	movle	r0, #0
    9e9a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
    9e9e:	bd70      	pople	{r4, r5, r6, pc}
    9ea0:	f1c4 0400 	rsb	r4, r4, #0
    9ea4:	3c20      	subs	r4, #32
    9ea6:	da35      	bge.n	9f14 <__aeabi_dmul+0x164>
    9ea8:	340c      	adds	r4, #12
    9eaa:	dc1b      	bgt.n	9ee4 <__aeabi_dmul+0x134>
    9eac:	f104 0414 	add.w	r4, r4, #20
    9eb0:	f1c4 0520 	rsb	r5, r4, #32
    9eb4:	fa00 f305 	lsl.w	r3, r0, r5
    9eb8:	fa20 f004 	lsr.w	r0, r0, r4
    9ebc:	fa01 f205 	lsl.w	r2, r1, r5
    9ec0:	ea40 0002 	orr.w	r0, r0, r2
    9ec4:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
    9ec8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    9ecc:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    9ed0:	fa21 f604 	lsr.w	r6, r1, r4
    9ed4:	eb42 0106 	adc.w	r1, r2, r6
    9ed8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    9edc:	bf08      	it	eq
    9ede:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    9ee2:	bd70      	pop	{r4, r5, r6, pc}
    9ee4:	f1c4 040c 	rsb	r4, r4, #12
    9ee8:	f1c4 0520 	rsb	r5, r4, #32
    9eec:	fa00 f304 	lsl.w	r3, r0, r4
    9ef0:	fa20 f005 	lsr.w	r0, r0, r5
    9ef4:	fa01 f204 	lsl.w	r2, r1, r4
    9ef8:	ea40 0002 	orr.w	r0, r0, r2
    9efc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    9f00:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    9f04:	f141 0100 	adc.w	r1, r1, #0
    9f08:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    9f0c:	bf08      	it	eq
    9f0e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    9f12:	bd70      	pop	{r4, r5, r6, pc}
    9f14:	f1c4 0520 	rsb	r5, r4, #32
    9f18:	fa00 f205 	lsl.w	r2, r0, r5
    9f1c:	ea4e 0e02 	orr.w	lr, lr, r2
    9f20:	fa20 f304 	lsr.w	r3, r0, r4
    9f24:	fa01 f205 	lsl.w	r2, r1, r5
    9f28:	ea43 0302 	orr.w	r3, r3, r2
    9f2c:	fa21 f004 	lsr.w	r0, r1, r4
    9f30:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    9f34:	fa21 f204 	lsr.w	r2, r1, r4
    9f38:	ea20 0002 	bic.w	r0, r0, r2
    9f3c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
    9f40:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    9f44:	bf08      	it	eq
    9f46:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    9f4a:	bd70      	pop	{r4, r5, r6, pc}
    9f4c:	f094 0f00 	teq	r4, #0
    9f50:	d10f      	bne.n	9f72 <__aeabi_dmul+0x1c2>
    9f52:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
    9f56:	0040      	lsls	r0, r0, #1
    9f58:	eb41 0101 	adc.w	r1, r1, r1
    9f5c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    9f60:	bf08      	it	eq
    9f62:	3c01      	subeq	r4, #1
    9f64:	d0f7      	beq.n	9f56 <__aeabi_dmul+0x1a6>
    9f66:	ea41 0106 	orr.w	r1, r1, r6
    9f6a:	f095 0f00 	teq	r5, #0
    9f6e:	bf18      	it	ne
    9f70:	4770      	bxne	lr
    9f72:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
    9f76:	0052      	lsls	r2, r2, #1
    9f78:	eb43 0303 	adc.w	r3, r3, r3
    9f7c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    9f80:	bf08      	it	eq
    9f82:	3d01      	subeq	r5, #1
    9f84:	d0f7      	beq.n	9f76 <__aeabi_dmul+0x1c6>
    9f86:	ea43 0306 	orr.w	r3, r3, r6
    9f8a:	4770      	bx	lr
    9f8c:	ea94 0f0c 	teq	r4, ip
    9f90:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    9f94:	bf18      	it	ne
    9f96:	ea95 0f0c 	teqne	r5, ip
    9f9a:	d00c      	beq.n	9fb6 <__aeabi_dmul+0x206>
    9f9c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    9fa0:	bf18      	it	ne
    9fa2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    9fa6:	d1d1      	bne.n	9f4c <__aeabi_dmul+0x19c>
    9fa8:	ea81 0103 	eor.w	r1, r1, r3
    9fac:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    9fb0:	f04f 0000 	mov.w	r0, #0
    9fb4:	bd70      	pop	{r4, r5, r6, pc}
    9fb6:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    9fba:	bf06      	itte	eq
    9fbc:	4610      	moveq	r0, r2
    9fbe:	4619      	moveq	r1, r3
    9fc0:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    9fc4:	d019      	beq.n	9ffa <__aeabi_dmul+0x24a>
    9fc6:	ea94 0f0c 	teq	r4, ip
    9fca:	d102      	bne.n	9fd2 <__aeabi_dmul+0x222>
    9fcc:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
    9fd0:	d113      	bne.n	9ffa <__aeabi_dmul+0x24a>
    9fd2:	ea95 0f0c 	teq	r5, ip
    9fd6:	d105      	bne.n	9fe4 <__aeabi_dmul+0x234>
    9fd8:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
    9fdc:	bf1c      	itt	ne
    9fde:	4610      	movne	r0, r2
    9fe0:	4619      	movne	r1, r3
    9fe2:	d10a      	bne.n	9ffa <__aeabi_dmul+0x24a>
    9fe4:	ea81 0103 	eor.w	r1, r1, r3
    9fe8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    9fec:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    9ff0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    9ff4:	f04f 0000 	mov.w	r0, #0
    9ff8:	bd70      	pop	{r4, r5, r6, pc}
    9ffa:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    9ffe:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
    a002:	bd70      	pop	{r4, r5, r6, pc}

0000a004 <__aeabi_ddiv>:
    a004:	b570      	push	{r4, r5, r6, lr}
    a006:	f04f 0cff 	mov.w	ip, #255	; 0xff
    a00a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    a00e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    a012:	bf1d      	ittte	ne
    a014:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    a018:	ea94 0f0c 	teqne	r4, ip
    a01c:	ea95 0f0c 	teqne	r5, ip
    a020:	f000 f8a7 	bleq	a172 <__aeabi_ddiv+0x16e>
    a024:	eba4 0405 	sub.w	r4, r4, r5
    a028:	ea81 0e03 	eor.w	lr, r1, r3
    a02c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    a030:	ea4f 3101 	mov.w	r1, r1, lsl #12
    a034:	f000 8088 	beq.w	a148 <__aeabi_ddiv+0x144>
    a038:	ea4f 3303 	mov.w	r3, r3, lsl #12
    a03c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
    a040:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
    a044:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    a048:	ea4f 2202 	mov.w	r2, r2, lsl #8
    a04c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
    a050:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
    a054:	ea4f 2600 	mov.w	r6, r0, lsl #8
    a058:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
    a05c:	429d      	cmp	r5, r3
    a05e:	bf08      	it	eq
    a060:	4296      	cmpeq	r6, r2
    a062:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
    a066:	f504 7440 	add.w	r4, r4, #768	; 0x300
    a06a:	d202      	bcs.n	a072 <__aeabi_ddiv+0x6e>
    a06c:	085b      	lsrs	r3, r3, #1
    a06e:	ea4f 0232 	mov.w	r2, r2, rrx
    a072:	1ab6      	subs	r6, r6, r2
    a074:	eb65 0503 	sbc.w	r5, r5, r3
    a078:	085b      	lsrs	r3, r3, #1
    a07a:	ea4f 0232 	mov.w	r2, r2, rrx
    a07e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    a082:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
    a086:	ebb6 0e02 	subs.w	lr, r6, r2
    a08a:	eb75 0e03 	sbcs.w	lr, r5, r3
    a08e:	bf22      	ittt	cs
    a090:	1ab6      	subcs	r6, r6, r2
    a092:	4675      	movcs	r5, lr
    a094:	ea40 000c 	orrcs.w	r0, r0, ip
    a098:	085b      	lsrs	r3, r3, #1
    a09a:	ea4f 0232 	mov.w	r2, r2, rrx
    a09e:	ebb6 0e02 	subs.w	lr, r6, r2
    a0a2:	eb75 0e03 	sbcs.w	lr, r5, r3
    a0a6:	bf22      	ittt	cs
    a0a8:	1ab6      	subcs	r6, r6, r2
    a0aa:	4675      	movcs	r5, lr
    a0ac:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    a0b0:	085b      	lsrs	r3, r3, #1
    a0b2:	ea4f 0232 	mov.w	r2, r2, rrx
    a0b6:	ebb6 0e02 	subs.w	lr, r6, r2
    a0ba:	eb75 0e03 	sbcs.w	lr, r5, r3
    a0be:	bf22      	ittt	cs
    a0c0:	1ab6      	subcs	r6, r6, r2
    a0c2:	4675      	movcs	r5, lr
    a0c4:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    a0c8:	085b      	lsrs	r3, r3, #1
    a0ca:	ea4f 0232 	mov.w	r2, r2, rrx
    a0ce:	ebb6 0e02 	subs.w	lr, r6, r2
    a0d2:	eb75 0e03 	sbcs.w	lr, r5, r3
    a0d6:	bf22      	ittt	cs
    a0d8:	1ab6      	subcs	r6, r6, r2
    a0da:	4675      	movcs	r5, lr
    a0dc:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    a0e0:	ea55 0e06 	orrs.w	lr, r5, r6
    a0e4:	d018      	beq.n	a118 <__aeabi_ddiv+0x114>
    a0e6:	ea4f 1505 	mov.w	r5, r5, lsl #4
    a0ea:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
    a0ee:	ea4f 1606 	mov.w	r6, r6, lsl #4
    a0f2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    a0f6:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
    a0fa:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    a0fe:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
    a102:	d1c0      	bne.n	a086 <__aeabi_ddiv+0x82>
    a104:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    a108:	d10b      	bne.n	a122 <__aeabi_ddiv+0x11e>
    a10a:	ea41 0100 	orr.w	r1, r1, r0
    a10e:	f04f 0000 	mov.w	r0, #0
    a112:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
    a116:	e7b6      	b.n	a086 <__aeabi_ddiv+0x82>
    a118:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    a11c:	bf04      	itt	eq
    a11e:	4301      	orreq	r1, r0
    a120:	2000      	moveq	r0, #0
    a122:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    a126:	bf88      	it	hi
    a128:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    a12c:	f63f aeaf 	bhi.w	9e8e <__aeabi_dmul+0xde>
    a130:	ebb5 0c03 	subs.w	ip, r5, r3
    a134:	bf04      	itt	eq
    a136:	ebb6 0c02 	subseq.w	ip, r6, r2
    a13a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    a13e:	f150 0000 	adcs.w	r0, r0, #0
    a142:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    a146:	bd70      	pop	{r4, r5, r6, pc}
    a148:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
    a14c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
    a150:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
    a154:	bfc2      	ittt	gt
    a156:	ebd4 050c 	rsbsgt	r5, r4, ip
    a15a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    a15e:	bd70      	popgt	{r4, r5, r6, pc}
    a160:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    a164:	f04f 0e00 	mov.w	lr, #0
    a168:	3c01      	subs	r4, #1
    a16a:	e690      	b.n	9e8e <__aeabi_dmul+0xde>
    a16c:	ea45 0e06 	orr.w	lr, r5, r6
    a170:	e68d      	b.n	9e8e <__aeabi_dmul+0xde>
    a172:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    a176:	ea94 0f0c 	teq	r4, ip
    a17a:	bf08      	it	eq
    a17c:	ea95 0f0c 	teqeq	r5, ip
    a180:	f43f af3b 	beq.w	9ffa <__aeabi_dmul+0x24a>
    a184:	ea94 0f0c 	teq	r4, ip
    a188:	d10a      	bne.n	a1a0 <__aeabi_ddiv+0x19c>
    a18a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    a18e:	f47f af34 	bne.w	9ffa <__aeabi_dmul+0x24a>
    a192:	ea95 0f0c 	teq	r5, ip
    a196:	f47f af25 	bne.w	9fe4 <__aeabi_dmul+0x234>
    a19a:	4610      	mov	r0, r2
    a19c:	4619      	mov	r1, r3
    a19e:	e72c      	b.n	9ffa <__aeabi_dmul+0x24a>
    a1a0:	ea95 0f0c 	teq	r5, ip
    a1a4:	d106      	bne.n	a1b4 <__aeabi_ddiv+0x1b0>
    a1a6:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    a1aa:	f43f aefd 	beq.w	9fa8 <__aeabi_dmul+0x1f8>
    a1ae:	4610      	mov	r0, r2
    a1b0:	4619      	mov	r1, r3
    a1b2:	e722      	b.n	9ffa <__aeabi_dmul+0x24a>
    a1b4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    a1b8:	bf18      	it	ne
    a1ba:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    a1be:	f47f aec5 	bne.w	9f4c <__aeabi_dmul+0x19c>
    a1c2:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
    a1c6:	f47f af0d 	bne.w	9fe4 <__aeabi_dmul+0x234>
    a1ca:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
    a1ce:	f47f aeeb 	bne.w	9fa8 <__aeabi_dmul+0x1f8>
    a1d2:	e712      	b.n	9ffa <__aeabi_dmul+0x24a>

Disassembly of section .text._DNS_ProcessPacket%199:

0000a1d4 <_DNS_ProcessPacket>:

// process a DNS packet
// returns true if info updated
// false if no entry was completed
static bool _DNS_ProcessPacket(TCPIP_DNS_DCPT* pDnsDcpt)
{
    a1d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a1d8:	f5ad 7d29 	sub.w	sp, sp, #676	; 0x2a4
    a1dc:	9004      	str	r0, [sp, #16]
    TCPIP_DNS_DBG_EVENT_TYPE evDbgType = TCPIP_DNS_DBG_EVENT_NONE;
    TCPIP_DNS_RR_PROCESS    procRR;


    // Get DNS Reply packet
    dnsPacketSize = TCPIP_UDP_ArrayGet(pDnsDcpt->dnsSocket, dnsRxBuffer, sizeof(dnsRxBuffer));
    a1de:	ae22      	add	r6, sp, #136	; 0x88
    a1e0:	f44f 7200 	mov.w	r2, #512	; 0x200
    a1e4:	4631      	mov	r1, r6
    a1e6:	f9b0 0024 	ldrsh.w	r0, [r0, #36]	; 0x24
    a1ea:	f00b f85d 	bl	152a8 <TCPIP_UDP_ArrayGet>
    rxData->head = rxData->rdPtr = buffer;
    a1ee:	96a3      	str	r6, [sp, #652]	; 0x28c
    a1f0:	96a2      	str	r6, [sp, #648]	; 0x288
    rxData->endPtr = buffer + bufferSize;
    a1f2:	4406      	add	r6, r0
    a1f4:	96a4      	str	r6, [sp, #656]	; 0x290

    _DNSInitRxData(&dnsRxData, dnsRxBuffer, dnsPacketSize);

    // Retrieve the DNS header and de-big-endian it
    if(!_DNSGetData(&dnsRxData, &DNSHeader, sizeof(DNSHeader)))
    a1f6:	220c      	movs	r2, #12
    a1f8:	a9a5      	add	r1, sp, #660	; 0x294
    a1fa:	a8a2      	add	r0, sp, #648	; 0x288
    a1fc:	f014 fcaa 	bl	1eb54 <_DNSGetData>
    a200:	9001      	str	r0, [sp, #4]
    a202:	b920      	cbnz	r0, a20e <_DNS_ProcessPacket+0x3a>
    {
        _DNS_DbgEvent(pDnsDcpt, dnsHE, evDbgType);
    }

    return !procFail;
}
    a204:	9801      	ldr	r0, [sp, #4]
    a206:	f50d 7d29 	add.w	sp, sp, #676	; 0x2a4
    a20a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    p->TransactionID.Val = TCPIP_Helper_htons(p->TransactionID.Val);
    a20e:	f8bd 2294 	ldrh.w	r2, [sp, #660]	; 0x294
    a212:	0a13      	lsrs	r3, r2, #8
    a214:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    a218:	f8ad 3294 	strh.w	r3, [sp, #660]	; 0x294
    p->Flags.Val = TCPIP_Helper_htons(p->Flags.Val);
    a21c:	f8bd 2296 	ldrh.w	r2, [sp, #662]	; 0x296
    a220:	0a13      	lsrs	r3, r2, #8
    a222:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    a226:	b21b      	sxth	r3, r3
    a228:	f8ad 3296 	strh.w	r3, [sp, #662]	; 0x296
    p->AdditionalRecords.Val = TCPIP_Helper_htons(p->AdditionalRecords.Val);
    a22c:	f8bd 129e 	ldrh.w	r1, [sp, #670]	; 0x29e
    a230:	0a0a      	lsrs	r2, r1, #8
    a232:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    a236:	f8ad 229e 	strh.w	r2, [sp, #670]	; 0x29e
    p->Answers.Val = TCPIP_Helper_htons(p->Answers.Val);
    a23a:	f8bd 129a 	ldrh.w	r1, [sp, #666]	; 0x29a
    a23e:	0a0a      	lsrs	r2, r1, #8
    a240:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    a244:	f8ad 229a 	strh.w	r2, [sp, #666]	; 0x29a
    p->AuthoritativeRecords.Val = TCPIP_Helper_htons(p->AuthoritativeRecords.Val);
    a248:	f8bd 129c 	ldrh.w	r1, [sp, #668]	; 0x29c
    a24c:	0a0a      	lsrs	r2, r1, #8
    a24e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    a252:	f8ad 229c 	strh.w	r2, [sp, #668]	; 0x29c
    p->Questions.Val = TCPIP_Helper_htons(p->Questions.Val);
    a256:	f8bd 1298 	ldrh.w	r1, [sp, #664]	; 0x298
    a25a:	0a0a      	lsrs	r2, r1, #8
    a25c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    a260:	f8ad 2298 	strh.w	r2, [sp, #664]	; 0x298
        if((DNSHeader.Flags.v[0] & 0x03) != 0)
    a264:	f013 0f03 	tst.w	r3, #3
    a268:	d13c      	bne.n	a2e4 <_DNS_ProcessPacket+0x110>
    procRR.dnsHE = 0;
    a26a:	f04f 0b00 	mov.w	fp, #0
        for(ix = TCPIP_DNS_RR_TYPE_QUESTION; ix < TCPIP_DNS_RR_TYPES; ix++) 
    a26e:	f8cd b00c 	str.w	fp, [sp, #12]
                nameLen++;
            }
        }
        if(discardLen != 0)
        {
            if(!_DNSGetData(xtractBuff, 0, discardLen))
    a272:	f8cd b000 	str.w	fp, [sp]
    a276:	9607      	str	r6, [sp, #28]
    a278:	e116      	b.n	a4a8 <_DNS_ProcessPacket+0x2d4>
           nRR = pProc->dnsHeader->Questions.Val;
    a27a:	f8bd 3298 	ldrh.w	r3, [sp, #664]	; 0x298
    a27e:	9305      	str	r3, [sp, #20]
    while(nRR--)
    a280:	b93b      	cbnz	r3, a292 <_DNS_ProcessPacket+0xbe>
    a282:	e02f      	b.n	a2e4 <_DNS_ProcessPacket+0x110>
           nRR = pProc->dnsHeader->Answers.Val;
    a284:	f8bd 329a 	ldrh.w	r3, [sp, #666]	; 0x29a
    a288:	9305      	str	r3, [sp, #20]
    while(nRR--)
    a28a:	9b05      	ldr	r3, [sp, #20]
    a28c:	2b00      	cmp	r3, #0
    a28e:	f000 8106 	beq.w	a49e <_DNS_ProcessPacket+0x2ca>
        for(ix = TCPIP_DNS_RR_TYPE_QUESTION; ix < TCPIP_DNS_RR_TYPES; ix++) 
    a292:	f04f 0900 	mov.w	r9, #0
        *wPtr = 0;
    a296:	f04f 0300 	mov.w	r3, #0
    a29a:	f88d 301b 	strb.w	r3, [sp, #27]
    a29e:	e167      	b.n	a570 <_DNS_ProcessPacket+0x39c>
           nRR = pProc->dnsHeader->AuthoritativeRecords.Val;
    a2a0:	f8bd 329c 	ldrh.w	r3, [sp, #668]	; 0x29c
    a2a4:	9305      	str	r3, [sp, #20]
           break;
    a2a6:	e7f0      	b.n	a28a <_DNS_ProcessPacket+0xb6>
           nRR = pProc->dnsHeader->AdditionalRecords.Val;
    a2a8:	f8bd 329e 	ldrh.w	r3, [sp, #670]	; 0x29e
    a2ac:	9305      	str	r3, [sp, #20]
           break;
    a2ae:	e7ec      	b.n	a28a <_DNS_ProcessPacket+0xb6>
            xtractBuff = &pktBuff;
    a2b0:	f10d 0834 	add.w	r8, sp, #52	; 0x34
    a2b4:	e022      	b.n	a2fc <_DNS_ProcessPacket+0x128>
            labelOffset = (uint16_t)(labelLen & 0x3f) << 8;
    a2b6:	022d      	lsls	r5, r5, #8
    a2b8:	f405 557c 	and.w	r5, r5, #16128	; 0x3f00
            if(!_DNSGetData(xtractBuff, &offset, sizeof(offset)))
    a2bc:	2201      	movs	r2, #1
    a2be:	a90a      	add	r1, sp, #40	; 0x28
    a2c0:	4640      	mov	r0, r8
    a2c2:	f014 fc47 	bl	1eb54 <_DNSGetData>
    a2c6:	b168      	cbz	r0, a2e4 <_DNS_ProcessPacket+0x110>
            labelOffset += offset; 
    a2c8:	f89d 2028 	ldrb.w	r2, [sp, #40]	; 0x28
    rxData->head = rxData->rdPtr = buffer;
    a2cc:	ab22      	add	r3, sp, #136	; 0x88
    a2ce:	930e      	str	r3, [sp, #56]	; 0x38
    a2d0:	930d      	str	r3, [sp, #52]	; 0x34
    rxData->endPtr = buffer + bufferSize;
    a2d2:	9b07      	ldr	r3, [sp, #28]
    a2d4:	930f      	str	r3, [sp, #60]	; 0x3c
            if(!_DNSGetData(xtractBuff, 0, labelOffset))
    a2d6:	442a      	add	r2, r5
    a2d8:	9900      	ldr	r1, [sp, #0]
    a2da:	a80d      	add	r0, sp, #52	; 0x34
    a2dc:	f014 fc3a 	bl	1eb54 <_DNSGetData>
    a2e0:	2800      	cmp	r0, #0
    a2e2:	d1e5      	bne.n	a2b0 <_DNS_ProcessPacket+0xdc>
    return !procFail;
    a2e4:	9b01      	ldr	r3, [sp, #4]
    a2e6:	f083 0301 	eor.w	r3, r3, #1
    a2ea:	b2db      	uxtb	r3, r3
    a2ec:	9301      	str	r3, [sp, #4]
    a2ee:	e789      	b.n	a204 <_DNS_ProcessPacket+0x30>
                discardLen = labelLen - avlblLen;
    a2f0:	1aed      	subs	r5, r5, r3
                copyLen = avlblLen;
    a2f2:	461e      	mov	r6, r3
        if(copyLen != 0)
    a2f4:	b9d3      	cbnz	r3, a32c <_DNS_ProcessPacket+0x158>
        if(discardLen != 0)
    a2f6:	bb4d      	cbnz	r5, a34c <_DNS_ProcessPacket+0x178>
                nameFail = true;
                break;
            }
        }

        nameLen += copyLen + discardLen;
    a2f8:	4435      	add	r5, r6
    a2fa:	442f      	add	r7, r5
        if(!_DNSGetData(xtractBuff, &labelLen, sizeof(labelLen)))
    a2fc:	2201      	movs	r2, #1
    a2fe:	f10d 0127 	add.w	r1, sp, #39	; 0x27
    a302:	4640      	mov	r0, r8
    a304:	f014 fc26 	bl	1eb54 <_DNSGetData>
    a308:	2800      	cmp	r0, #0
    a30a:	d0eb      	beq.n	a2e4 <_DNS_ProcessPacket+0x110>
        if(labelLen == 0)
    a30c:	f89d 5027 	ldrb.w	r5, [sp, #39]	; 0x27
    a310:	2d00      	cmp	r5, #0
    a312:	f000 8136 	beq.w	a582 <_DNS_ProcessPacket+0x3ae>
        if((labelLen & 0xc0) == 0xc0)
    a316:	462e      	mov	r6, r5
    a318:	f005 03c0 	and.w	r3, r5, #192	; 0xc0
    a31c:	2bc0      	cmp	r3, #192	; 0xc0
    a31e:	d0ca      	beq.n	a2b6 <_DNS_ProcessPacket+0xe2>
        if(wPtr != 0)
    a320:	b1bc      	cbz	r4, a352 <_DNS_ProcessPacket+0x17e>
            avlblLen = ePtr - wPtr;
    a322:	ab21      	add	r3, sp, #132	; 0x84
    a324:	1b1b      	subs	r3, r3, r4
            if(labelLen > avlblLen)
    a326:	429d      	cmp	r5, r3
    a328:	dce2      	bgt.n	a2f0 <_DNS_ProcessPacket+0x11c>
                discardLen = 0;
    a32a:	9d00      	ldr	r5, [sp, #0]
            if(!_DNSGetData(xtractBuff, wPtr, copyLen))
    a32c:	4632      	mov	r2, r6
    a32e:	4621      	mov	r1, r4
    a330:	4640      	mov	r0, r8
    a332:	f014 fc0f 	bl	1eb54 <_DNSGetData>
    a336:	2800      	cmp	r0, #0
    a338:	d0d4      	beq.n	a2e4 <_DNS_ProcessPacket+0x110>
            wPtr += copyLen;
    a33a:	4434      	add	r4, r6
            if(wPtr < ePtr)
    a33c:	ab21      	add	r3, sp, #132	; 0x84
    a33e:	429c      	cmp	r4, r3
    a340:	d2d9      	bcs.n	a2f6 <_DNS_ProcessPacket+0x122>
                *wPtr++ = '.';
    a342:	232e      	movs	r3, #46	; 0x2e
    a344:	f804 3b01 	strb.w	r3, [r4], #1
                nameLen++;
    a348:	3701      	adds	r7, #1
    a34a:	e7d4      	b.n	a2f6 <_DNS_ProcessPacket+0x122>
        if(discardLen != 0)
    a34c:	9602      	str	r6, [sp, #8]
    a34e:	462e      	mov	r6, r5
    a350:	e001      	b.n	a356 <_DNS_ProcessPacket+0x182>
            copyLen = 0;
    a352:	9b00      	ldr	r3, [sp, #0]
    a354:	9302      	str	r3, [sp, #8]
            if(!_DNSGetData(xtractBuff, 0, discardLen))
    a356:	4632      	mov	r2, r6
    a358:	9900      	ldr	r1, [sp, #0]
    a35a:	4640      	mov	r0, r8
    a35c:	f014 fbfa 	bl	1eb54 <_DNSGetData>
    a360:	2800      	cmp	r0, #0
    a362:	d0bf      	beq.n	a2e4 <_DNS_ProcessPacket+0x110>
    a364:	4635      	mov	r5, r6
    a366:	9e02      	ldr	r6, [sp, #8]
    a368:	e7c6      	b.n	a2f8 <_DNS_ProcessPacket+0x124>

    if(wPtr != 0)
    {
        if(wPtr != nameBuff && *(wPtr - 1) == '.')
        {
            wPtr--; // remove the last '.' 
    a36a:	3c01      	subs	r4, #1
            nameLen--;
    a36c:	3f01      	subs	r7, #1
    a36e:	e112      	b.n	a596 <_DNS_ProcessPacket+0x3c2>
        if(wPtr != nameBuff && *(wPtr - 1) == '.')
    a370:	ac11      	add	r4, sp, #68	; 0x44
    a372:	e110      	b.n	a596 <_DNS_ProcessPacket+0x3c2>
            return pDnsHE;
    a374:	469b      	mov	fp, r3
    a376:	e0ea      	b.n	a54e <_DNS_ProcessPacket+0x37a>
    if(!_DNSGetData(dnsRxData, (uint8_t *)&DNSAnswerHeader, sizeof(TCPIP_DNS_ANSWER_HEADER)))
    a378:	220a      	movs	r2, #10
    a37a:	a90a      	add	r1, sp, #40	; 0x28
    a37c:	a8a2      	add	r0, sp, #648	; 0x288
    a37e:	f014 fbe9 	bl	1eb54 <_DNSGetData>
    a382:	2800      	cmp	r0, #0
    a384:	d0ae      	beq.n	a2e4 <_DNS_ProcessPacket+0x110>
    p->ResponseClass.Val = TCPIP_Helper_htons(p->ResponseClass.Val);
    a386:	f8bd 302a 	ldrh.w	r3, [sp, #42]	; 0x2a
    a38a:	0a18      	lsrs	r0, r3, #8
    a38c:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
    a390:	b280      	uxth	r0, r0
    a392:	f8ad 002a 	strh.w	r0, [sp, #42]	; 0x2a
    p->ResponseLen.Val = TCPIP_Helper_htons(p->ResponseLen.Val);
    a396:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
    a39a:	0a1a      	lsrs	r2, r3, #8
    a39c:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
    a3a0:	b292      	uxth	r2, r2
    a3a2:	f8ad 2030 	strh.w	r2, [sp, #48]	; 0x30
    p->ResponseTTL.Val = TCPIP_Helper_htonl(p->ResponseTTL.Val);
    a3a6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    return (((hLong & 0x000000ff) << 24) | ((hLong & 0x0000ff00) << 8) | ((hLong & 0x00ff0000) >> 8) | ((hLong & 0xff000000) >> 24));
    a3a8:	0e19      	lsrs	r1, r3, #24
    a3aa:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
    a3ae:	021c      	lsls	r4, r3, #8
    a3b0:	f404 047f 	and.w	r4, r4, #16711680	; 0xff0000
    a3b4:	4321      	orrs	r1, r4
    a3b6:	0a1b      	lsrs	r3, r3, #8
    a3b8:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    a3bc:	430b      	orrs	r3, r1
    a3be:	930b      	str	r3, [sp, #44]	; 0x2c
    p->ResponseType.Val = TCPIP_Helper_htons(p->ResponseType.Val);
    a3c0:	f8bd 1028 	ldrh.w	r1, [sp, #40]	; 0x28
       return (((hShort) << 8) | ((hShort) >> 8));
    a3c4:	0a0b      	lsrs	r3, r1, #8
    a3c6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    a3ca:	b29b      	uxth	r3, r3
    a3cc:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
    while( dnsHE != 0 && (DNSAnswerHeader.ResponseClass.Val == 1)) // Internet class
    a3d0:	f1bb 0f00 	cmp.w	fp, #0
    a3d4:	d001      	beq.n	a3da <_DNS_ProcessPacket+0x206>
    a3d6:	2801      	cmp	r0, #1
    a3d8:	d007      	beq.n	a3ea <_DNS_ProcessPacket+0x216>
        if(!_DNSGetData(dnsRxData, 0, DNSAnswerHeader.ResponseLen.Val))
    a3da:	9900      	ldr	r1, [sp, #0]
    a3dc:	a8a2      	add	r0, sp, #648	; 0x288
    a3de:	f014 fbb9 	bl	1eb54 <_DNSGetData>
            if(entryUpdate == false)
    a3e2:	2800      	cmp	r0, #0
    a3e4:	f040 80bf 	bne.w	a566 <_DNS_ProcessPacket+0x392>
    a3e8:	e77c      	b.n	a2e4 <_DNS_ProcessPacket+0x110>
        if (DNSAnswerHeader.ResponseType.Val == TCPIP_DNS_TYPE_A && DNSAnswerHeader.ResponseLen.Val == 4)
    a3ea:	2b01      	cmp	r3, #1
    a3ec:	d02f      	beq.n	a44e <_DNS_ProcessPacket+0x27a>
        if (DNSAnswerHeader.ResponseType.Val == TCPIP_DNS_TYPE_AAAA && DNSAnswerHeader.ResponseLen.Val == 16)
    a3ee:	2b1c      	cmp	r3, #28
    a3f0:	d1f3      	bne.n	a3da <_DNS_ProcessPacket+0x206>
    a3f2:	2a10      	cmp	r2, #16
    a3f4:	d1f1      	bne.n	a3da <_DNS_ProcessPacket+0x206>
            if((dnsHE->recordMask & TCPIP_DNS_ADDRESS_REC_IPV6) == 0 || (dnsHE->nIPv6Entries >= pDnsDcpt->nIPv6Entries))
    a3f6:	f89b 302a 	ldrb.w	r3, [fp, #42]	; 0x2a
    a3fa:	f013 0f02 	tst.w	r3, #2
    a3fe:	d0ec      	beq.n	a3da <_DNS_ProcessPacket+0x206>
    a400:	f89b 1027 	ldrb.w	r1, [fp, #39]	; 0x27
    a404:	9b04      	ldr	r3, [sp, #16]
    a406:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
    a408:	4299      	cmp	r1, r3
    a40a:	d2e6      	bcs.n	a3da <_DNS_ProcessPacket+0x206>
            if(!_DNSGetData(dnsRxData, ipAddr.v6Add.v, sizeof (IPV6_ADDR)))
    a40c:	a90d      	add	r1, sp, #52	; 0x34
    a40e:	a8a2      	add	r0, sp, #648	; 0x288
    a410:	f014 fba0 	bl	1eb54 <_DNSGetData>
    a414:	2800      	cmp	r0, #0
    a416:	f43f af65 	beq.w	a2e4 <_DNS_ProcessPacket+0x110>
            memcpy( &dnsHE->pip6Address[dnsHE->nIPv6Entries], ipAddr.v6Add.v, sizeof(IPV6_ADDR));
    a41a:	f89b 5027 	ldrb.w	r5, [fp, #39]	; 0x27
    a41e:	012d      	lsls	r5, r5, #4
    a420:	f8db 7014 	ldr.w	r7, [fp, #20]
    a424:	197e      	adds	r6, r7, r5
    a426:	ac0d      	add	r4, sp, #52	; 0x34
    a428:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    a42a:	5178      	str	r0, [r7, r5]
    a42c:	6071      	str	r1, [r6, #4]
    a42e:	60b2      	str	r2, [r6, #8]
    a430:	60f3      	str	r3, [r6, #12]
            if((DNSAnswerHeader.ResponseTTL.Val < dnsHE->ipTTL.Val) || (dnsHE->ipTTL.Val == 0))
    a432:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a434:	f8db 2018 	ldr.w	r2, [fp, #24]
    a438:	4293      	cmp	r3, r2
    a43a:	d300      	bcc.n	a43e <_DNS_ProcessPacket+0x26a>
    a43c:	b90a      	cbnz	r2, a442 <_DNS_ProcessPacket+0x26e>
                dnsHE->ipTTL.Val = DNSAnswerHeader.ResponseTTL.Val;
    a43e:	f8cb 3018 	str.w	r3, [fp, #24]
            dnsHE->nIPv6Entries++;
    a442:	f89b 3027 	ldrb.w	r3, [fp, #39]	; 0x27
    a446:	3301      	adds	r3, #1
    a448:	f88b 3027 	strb.w	r3, [fp, #39]	; 0x27
    if(discardData)
    a44c:	e08b      	b.n	a566 <_DNS_ProcessPacket+0x392>
        if (DNSAnswerHeader.ResponseType.Val == TCPIP_DNS_TYPE_A && DNSAnswerHeader.ResponseLen.Val == 4)
    a44e:	2a04      	cmp	r2, #4
    a450:	d1c3      	bne.n	a3da <_DNS_ProcessPacket+0x206>
            if(dnsHE->nIPv4Entries >= pDnsDcpt->nIPv4Entries)
    a452:	f89b 1026 	ldrb.w	r1, [fp, #38]	; 0x26
    a456:	9b04      	ldr	r3, [sp, #16]
    a458:	8c1b      	ldrh	r3, [r3, #32]
    a45a:	4299      	cmp	r1, r3
    a45c:	d2bd      	bcs.n	a3da <_DNS_ProcessPacket+0x206>
            if(!_DNSGetData(dnsRxData, ipAddr.v4Add.v, sizeof(IPV4_ADDR)))
    a45e:	a90d      	add	r1, sp, #52	; 0x34
    a460:	a8a2      	add	r0, sp, #648	; 0x288
    a462:	f014 fb77 	bl	1eb54 <_DNSGetData>
    a466:	2800      	cmp	r0, #0
    a468:	f43f af3c 	beq.w	a2e4 <_DNS_ProcessPacket+0x110>
            dnsHE->pip4Address[dnsHE->nIPv4Entries].Val = ipAddr.v4Add.Val;
    a46c:	990d      	ldr	r1, [sp, #52]	; 0x34
    a46e:	f89b 2026 	ldrb.w	r2, [fp, #38]	; 0x26
    a472:	f8db 3010 	ldr.w	r3, [fp, #16]
    a476:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            if((DNSAnswerHeader.ResponseTTL.Val < dnsHE->ipTTL.Val) || (dnsHE->ipTTL.Val == 0))
    a47a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a47c:	f8db 2018 	ldr.w	r2, [fp, #24]
    a480:	4293      	cmp	r3, r2
    a482:	d300      	bcc.n	a486 <_DNS_ProcessPacket+0x2b2>
    a484:	b90a      	cbnz	r2, a48a <_DNS_ProcessPacket+0x2b6>
                dnsHE->ipTTL.Val = DNSAnswerHeader.ResponseTTL.Val;
    a486:	f8cb 3018 	str.w	r3, [fp, #24]
            dnsHE->nIPv4Entries++;
    a48a:	f89b 3026 	ldrb.w	r3, [fp, #38]	; 0x26
    a48e:	3301      	adds	r3, #1
    a490:	f88b 3026 	strb.w	r3, [fp, #38]	; 0x26
    if(discardData)
    a494:	e067      	b.n	a566 <_DNS_ProcessPacket+0x392>
        if(rrType == TCPIP_DNS_RR_TYPE_QUESTION)
    a496:	f1ba 0f00 	cmp.w	sl, #0
    a49a:	f43f af23 	beq.w	a2e4 <_DNS_ProcessPacket+0x110>
        for(ix = TCPIP_DNS_RR_TYPE_QUESTION; ix < TCPIP_DNS_RR_TYPES; ix++) 
    a49e:	9b03      	ldr	r3, [sp, #12]
    a4a0:	3301      	adds	r3, #1
    a4a2:	9303      	str	r3, [sp, #12]
    a4a4:	2b04      	cmp	r3, #4
    a4a6:	d00f      	beq.n	a4c8 <_DNS_ProcessPacket+0x2f4>
            _DNS_ProcessRR(pDnsDcpt, &procRR, (TCPIP_DNS_RR_TYPE)ix);
    a4a8:	f89d a00c 	ldrb.w	sl, [sp, #12]
    switch(rrType)
    a4ac:	f1ba 0f03 	cmp.w	sl, #3
    a4b0:	d8f1      	bhi.n	a496 <_DNS_ProcessPacket+0x2c2>
    a4b2:	a301      	add	r3, pc, #4	; (adr r3, a4b8 <_DNS_ProcessPacket+0x2e4>)
    a4b4:	f853 f02a 	ldr.w	pc, [r3, sl, lsl #2]
    a4b8:	0000a27b 	.word	0x0000a27b
    a4bc:	0000a285 	.word	0x0000a285
    a4c0:	0000a2a1 	.word	0x0000a2a1
    a4c4:	0000a2a9 	.word	0x0000a2a9
        if(dnsHE != 0 && (dnsHE->nIPv4Entries > 0 || dnsHE->nIPv6Entries > 0))
    a4c8:	f1bb 0f00 	cmp.w	fp, #0
    a4cc:	f43f af0a 	beq.w	a2e4 <_DNS_ProcessPacket+0x110>
    a4d0:	f8bb 3026 	ldrh.w	r3, [fp, #38]	; 0x26
    a4d4:	2b00      	cmp	r3, #0
    a4d6:	f43f af05 	beq.w	a2e4 <_DNS_ProcessPacket+0x110>
    dnsHE->hEntry.flags.value &= ~TCPIP_DNS_FLAG_ENTRY_TIMEOUT;
    a4da:	f8bb 3000 	ldrh.w	r3, [fp]
    a4de:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    dnsHE->hEntry.flags.value |= TCPIP_DNS_FLAG_ENTRY_COMPLETE;
    a4e2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    a4e6:	f8ab 3000 	strh.w	r3, [fp]
    dnsHE->recordMask = TCPIP_DNS_ADDRESS_REC_NONE;
    a4ea:	2300      	movs	r3, #0
    a4ec:	f88b 302a 	strb.w	r3, [fp, #42]	; 0x2a
    if(dnsHE->nIPv4Entries != 0)
    a4f0:	f89b 3026 	ldrb.w	r3, [fp, #38]	; 0x26
    a4f4:	b113      	cbz	r3, a4fc <_DNS_ProcessPacket+0x328>
        dnsHE->recordMask |= TCPIP_DNS_ADDRESS_REC_IPV4;
    a4f6:	2301      	movs	r3, #1
    a4f8:	f88b 302a 	strb.w	r3, [fp, #42]	; 0x2a
    if(dnsHE->nIPv6Entries != 0)
    a4fc:	f89b 3027 	ldrb.w	r3, [fp, #39]	; 0x27
    a500:	b12b      	cbz	r3, a50e <_DNS_ProcessPacket+0x33a>
        dnsHE->recordMask |= TCPIP_DNS_ADDRESS_REC_IPV6;
    a502:	f89b 302a 	ldrb.w	r3, [fp, #42]	; 0x2a
    a506:	f043 0302 	orr.w	r3, r3, #2
    a50a:	f88b 302a 	strb.w	r3, [fp, #42]	; 0x2a
    if(dnsHE->ipTTL.Val == 0)
    a50e:	f8db 3018 	ldr.w	r3, [fp, #24]
    a512:	b91b      	cbnz	r3, a51c <_DNS_ProcessPacket+0x348>
        dnsHE->ipTTL.Val = TCPIP_DNS_CLIENT_CACHE_DEFAULT_TTL_VAL;
    a514:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
    a518:	f8cb 3018 	str.w	r3, [fp, #24]
    dnsHE->tRetry = dnsHE->tInsert = pDnsDcpt->dnsTime; 
    a51c:	9a04      	ldr	r2, [sp, #16]
    a51e:	69d3      	ldr	r3, [r2, #28]
    a520:	f8cb 3008 	str.w	r3, [fp, #8]
    a524:	f8cb 300c 	str.w	r3, [fp, #12]
    pDnsDcpt->unsolvedEntries--;
    a528:	8cd3      	ldrh	r3, [r2, #38]	; 0x26
    a52a:	3b01      	subs	r3, #1
    a52c:	84d3      	strh	r3, [r2, #38]	; 0x26
        procFail = false;
    a52e:	2300      	movs	r3, #0
    a530:	9301      	str	r3, [sp, #4]
    a532:	e6d7      	b.n	a2e4 <_DNS_ProcessPacket+0x110>
            if((dnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) != 0)
    a534:	8802      	ldrh	r2, [r0, #0]
    a536:	f012 0f80 	tst.w	r2, #128	; 0x80
    a53a:	f47f aed3 	bne.w	a2e4 <_DNS_ProcessPacket+0x110>
            if(pProc->dnsHE == 0)
    a53e:	f1bb 0f00 	cmp.w	fp, #0
    a542:	f43f af17 	beq.w	a374 <_DNS_ProcessPacket+0x1a0>
            else if(pProc->dnsHE != dnsHE)
    a546:	459b      	cmp	fp, r3
    a548:	f47f aecc 	bne.w	a2e4 <_DNS_ProcessPacket+0x110>
            return pDnsHE;
    a54c:	469b      	mov	fp, r3
        if(rrType == TCPIP_DNS_RR_TYPE_QUESTION)
    a54e:	f1ba 0f00 	cmp.w	sl, #0
    a552:	f47f af11 	bne.w	a378 <_DNS_ProcessPacket+0x1a4>
            if(!_DNSGetData(pProc->dnsRxData, 0, 4))
    a556:	2204      	movs	r2, #4
    a558:	9900      	ldr	r1, [sp, #0]
    a55a:	a8a2      	add	r0, sp, #648	; 0x288
    a55c:	f014 fafa 	bl	1eb54 <_DNSGetData>
    a560:	2800      	cmp	r0, #0
    a562:	f43f aebf 	beq.w	a2e4 <_DNS_ProcessPacket+0x110>
        nRecords++;
    a566:	f109 0901 	add.w	r9, r9, #1
    while(nRR--)
    a56a:	9b05      	ldr	r3, [sp, #20]
    a56c:	4599      	cmp	r9, r3
    a56e:	d096      	beq.n	a49e <_DNS_ProcessPacket+0x2ca>
        *wPtr = 0;
    a570:	f89d 301b 	ldrb.w	r3, [sp, #27]
    a574:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
    TCPIP_DNS_RX_DATA* xtractBuff = pProc->dnsRxData;
    a578:	f50d 7822 	add.w	r8, sp, #648	; 0x288
        *wPtr = 0;
    a57c:	ac11      	add	r4, sp, #68	; 0x44
    nameLen = 0;
    a57e:	2700      	movs	r7, #0
    a580:	e6bc      	b.n	a2fc <_DNS_ProcessPacket+0x128>
    if(wPtr != 0)
    a582:	b15c      	cbz	r4, a59c <_DNS_ProcessPacket+0x3c8>
        if(wPtr != nameBuff && *(wPtr - 1) == '.')
    a584:	ab11      	add	r3, sp, #68	; 0x44
    a586:	429c      	cmp	r4, r3
    a588:	f43f aef2 	beq.w	a370 <_DNS_ProcessPacket+0x19c>
    a58c:	f814 3c01 	ldrb.w	r3, [r4, #-1]
    a590:	2b2e      	cmp	r3, #46	; 0x2e
    a592:	f43f aeea 	beq.w	a36a <_DNS_ProcessPacket+0x196>
        }

        *wPtr = 0;  // end the nameBuff properly
    a596:	f04f 0300 	mov.w	r3, #0
    a59a:	7023      	strb	r3, [r4, #0]
        if(nameLen <= 0)
    a59c:	2f00      	cmp	r7, #0
    a59e:	f77f aea1 	ble.w	a2e4 <_DNS_ProcessPacket+0x110>
        dnsHE = _DNSHashEntryFromTransactionId(pDnsDcpt, nameBuffer, pProc->dnsHeader->TransactionID.Val);
    a5a2:	f8bd 4294 	ldrh.w	r4, [sp, #660]	; 0x294
    pDnsHE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryLookup(pDnsDcpt->hashDcpt, hostName);
    a5a6:	a911      	add	r1, sp, #68	; 0x44
    a5a8:	9b04      	ldr	r3, [sp, #16]
    a5aa:	6818      	ldr	r0, [r3, #0]
    a5ac:	f010 fbea 	bl	1ad84 <TCPIP_OAHASH_EntryLookup>
    if(pDnsHE != 0)
    a5b0:	4603      	mov	r3, r0
    a5b2:	b110      	cbz	r0, a5ba <_DNS_ProcessPacket+0x3e6>
        if(pDnsHE->transactionId.Val == transactionId)
    a5b4:	8c82      	ldrh	r2, [r0, #36]	; 0x24
    a5b6:	42a2      	cmp	r2, r4
    a5b8:	d0bc      	beq.n	a534 <_DNS_ProcessPacket+0x360>
            if(pProc->dnsHE != 0)
    a5ba:	f1bb 0f00 	cmp.w	fp, #0
    a5be:	d0c6      	beq.n	a54e <_DNS_ProcessPacket+0x37a>
            if((dnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) != 0)
    a5c0:	f8bb 3000 	ldrh.w	r3, [fp]
    a5c4:	f013 0f80 	tst.w	r3, #128	; 0x80
    a5c8:	d0c1      	beq.n	a54e <_DNS_ProcessPacket+0x37a>
    a5ca:	e68b      	b.n	a2e4 <_DNS_ProcessPacket+0x110>

Disassembly of section .text.TCPIP_COMMAND_Task%200:

0000a5cc <TCPIP_COMMAND_Task>:
}

#endif  // defined(_TCPIP_COMMAND_PING4) || defined(_TCPIP_COMMAND_PING6)

void TCPIP_COMMAND_Task(void)
{
    a5cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a5d0:	b095      	sub	sp, #84	; 0x54
    TCPIP_MODULE_SIGNAL sigPend;

    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    a5d2:	210f      	movs	r1, #15
    a5d4:	201f      	movs	r0, #31
    a5d6:	f013 fdf9 	bl	1e1cc <_TCPIPStackModuleSignalGet>

    if((sigPend & TCPIP_MODULE_SIGNAL_TMO) != 0)
    a5da:	f010 0f02 	tst.w	r0, #2
    a5de:	d00d      	beq.n	a5fc <TCPIP_COMMAND_Task+0x30>
    { // regular TMO occurred

#if  defined(_TCPIP_COMMAND_PING4) || defined(_TCPIP_COMMAND_PING6)
        if(TCPIP_CMD_STAT_PING_START <= tcpipCmdStat && tcpipCmdStat <= TCPIP_CMD_STAT_PING_STOP)
    a5e0:	4b93      	ldr	r3, [pc, #588]	; (a830 <TCPIP_COMMAND_Task+0x264>)
    a5e2:	781a      	ldrb	r2, [r3, #0]
    a5e4:	1e53      	subs	r3, r2, #1
    a5e6:	b2db      	uxtb	r3, r3
    a5e8:	2b06      	cmp	r3, #6
    a5ea:	d90a      	bls.n	a602 <TCPIP_COMMAND_Task+0x36>
            TCPIPCmdPingTask();
        }
#endif  // defined(_TCPIP_COMMAND_PING4) || defined(_TCPIP_COMMAND_PING6)

#if defined(TCPIP_STACK_USE_DNS)
        if(TCPIP_CMD_STAT_DNS_START <= tcpipCmdStat && tcpipCmdStat <= TCPIP_CMD_STAT_DNS_STOP)
    a5ec:	4b90      	ldr	r3, [pc, #576]	; (a830 <TCPIP_COMMAND_Task+0x264>)
    a5ee:	781a      	ldrb	r2, [r3, #0]
    a5f0:	f1a2 0308 	sub.w	r3, r2, #8
    a5f4:	b2db      	uxtb	r3, r3
    a5f6:	2b01      	cmp	r3, #1
    a5f8:	f240 80c7 	bls.w	a78a <TCPIP_COMMAND_Task+0x1be>
        {
            TCPIPCmdMiimTask();
        }
#endif  // defined(_TCPIP_COMMANDS_MIIM)
    }
}
    a5fc:	b015      	add	sp, #84	; 0x54
    a5fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    switch(tcpipCmdStat)
    a602:	3a01      	subs	r2, #1
    a604:	2a03      	cmp	r2, #3
    a606:	d840      	bhi.n	a68a <TCPIP_COMMAND_Task+0xbe>
    a608:	e8df f002 	tbb	[pc, r2]
    a60c:	39331702 	.word	0x39331702
            dnsRes = TCPIP_DNS_Resolve(icmpTargetHost, TCPIP_DNS_TYPE_A);
    a610:	2101      	movs	r1, #1
    a612:	4888      	ldr	r0, [pc, #544]	; (a834 <TCPIP_COMMAND_Task+0x268>)
    a614:	f017 fd78 	bl	22108 <TCPIP_DNS_Resolve>
            if(dnsRes != TCPIP_DNS_RES_OK && dnsRes != TCPIP_DNS_RES_PENDING && dnsRes != TCPIP_DNS_RES_NAME_IS_IPADDRESS)
    a618:	b2c0      	uxtb	r0, r0
    a61a:	2802      	cmp	r0, #2
    a61c:	d909      	bls.n	a632 <TCPIP_COMMAND_Task+0x66>
                (*pTcpipCmdDevice->pCmdApi->print)(icmpCmdIoParam, "Ping: DNS failure for %s\r\n", icmpTargetHost);
    a61e:	4b86      	ldr	r3, [pc, #536]	; (a838 <TCPIP_COMMAND_Task+0x26c>)
    a620:	681b      	ldr	r3, [r3, #0]
    a622:	681b      	ldr	r3, [r3, #0]
    a624:	685b      	ldr	r3, [r3, #4]
    a626:	4a83      	ldr	r2, [pc, #524]	; (a834 <TCPIP_COMMAND_Task+0x268>)
    a628:	4984      	ldr	r1, [pc, #528]	; (a83c <TCPIP_COMMAND_Task+0x270>)
    a62a:	4885      	ldr	r0, [pc, #532]	; (a840 <TCPIP_COMMAND_Task+0x274>)
    a62c:	6800      	ldr	r0, [r0, #0]
    a62e:	4798      	blx	r3
    if(killIcmp)
    a630:	e02b      	b.n	a68a <TCPIP_COMMAND_Task+0xbe>
            tcpipCmdStat = TCPIP_PING_CMD_DNS_WAIT;
    a632:	4b7f      	ldr	r3, [pc, #508]	; (a830 <TCPIP_COMMAND_Task+0x264>)
    a634:	2202      	movs	r2, #2
    a636:	701a      	strb	r2, [r3, #0]
    if(killIcmp)
    a638:	e7d8      	b.n	a5ec <TCPIP_COMMAND_Task+0x20>
            dnsRes = TCPIP_DNS_IsNameResolved(icmpTargetHost, &icmpTargetAddr, 0);
    a63a:	2200      	movs	r2, #0
    a63c:	4981      	ldr	r1, [pc, #516]	; (a844 <TCPIP_COMMAND_Task+0x278>)
    a63e:	487d      	ldr	r0, [pc, #500]	; (a834 <TCPIP_COMMAND_Task+0x268>)
    a640:	f017 fd67 	bl	22112 <TCPIP_DNS_IsNameResolved>
            if(dnsRes == TCPIP_DNS_RES_PENDING)
    a644:	2801      	cmp	r0, #1
    a646:	d0d1      	beq.n	a5ec <TCPIP_COMMAND_Task+0x20>
            else if(dnsRes < 0 )
    a648:	2800      	cmp	r0, #0
    a64a:	da09      	bge.n	a660 <TCPIP_COMMAND_Task+0x94>
                (*pTcpipCmdDevice->pCmdApi->print)(icmpCmdIoParam, "Ping: DNS failure for %s\r\n", icmpTargetHost);
    a64c:	4b7a      	ldr	r3, [pc, #488]	; (a838 <TCPIP_COMMAND_Task+0x26c>)
    a64e:	681b      	ldr	r3, [r3, #0]
    a650:	681b      	ldr	r3, [r3, #0]
    a652:	685b      	ldr	r3, [r3, #4]
    a654:	4a77      	ldr	r2, [pc, #476]	; (a834 <TCPIP_COMMAND_Task+0x268>)
    a656:	4979      	ldr	r1, [pc, #484]	; (a83c <TCPIP_COMMAND_Task+0x270>)
    a658:	4879      	ldr	r0, [pc, #484]	; (a840 <TCPIP_COMMAND_Task+0x274>)
    a65a:	6800      	ldr	r0, [r0, #0]
    a65c:	4798      	blx	r3
    if(killIcmp)
    a65e:	e014      	b.n	a68a <TCPIP_COMMAND_Task+0xbe>
            TCPIP_Helper_IPAddressToString(&icmpTargetAddr, icmpTargetAddrStr, sizeof(icmpTargetAddrStr));
    a660:	2211      	movs	r2, #17
    a662:	4979      	ldr	r1, [pc, #484]	; (a848 <TCPIP_COMMAND_Task+0x27c>)
    a664:	4877      	ldr	r0, [pc, #476]	; (a844 <TCPIP_COMMAND_Task+0x278>)
    a666:	f012 fa15 	bl	1ca94 <TCPIP_Helper_IPAddressToString>
            tcpipCmdStat = TCPIP_PING_CMD_START_PING;            
    a66a:	4b71      	ldr	r3, [pc, #452]	; (a830 <TCPIP_COMMAND_Task+0x264>)
    a66c:	2203      	movs	r2, #3
    a66e:	701a      	strb	r2, [r3, #0]
    if(killIcmp)
    a670:	e7bc      	b.n	a5ec <TCPIP_COMMAND_Task+0x20>
            icmpStartTick = 0;  // try to start as quickly as possible
    a672:	4b76      	ldr	r3, [pc, #472]	; (a84c <TCPIP_COMMAND_Task+0x280>)
    a674:	2200      	movs	r2, #0
    a676:	601a      	str	r2, [r3, #0]
            tcpipCmdStat = TCPIP_PING_CMD_DO_PING;            
    a678:	4b6d      	ldr	r3, [pc, #436]	; (a830 <TCPIP_COMMAND_Task+0x264>)
    a67a:	2204      	movs	r2, #4
    a67c:	701a      	strb	r2, [r3, #0]
            if(icmpReqCount == icmpReqNo)
    a67e:	4b74      	ldr	r3, [pc, #464]	; (a850 <TCPIP_COMMAND_Task+0x284>)
    a680:	681a      	ldr	r2, [r3, #0]
    a682:	4b74      	ldr	r3, [pc, #464]	; (a854 <TCPIP_COMMAND_Task+0x288>)
    a684:	681b      	ldr	r3, [r3, #0]
    a686:	429a      	cmp	r2, r3
    a688:	d106      	bne.n	a698 <TCPIP_COMMAND_Task+0xcc>
        _PingStop(pTcpipCmdDevice, icmpCmdIoParam);
    a68a:	4b6d      	ldr	r3, [pc, #436]	; (a840 <TCPIP_COMMAND_Task+0x274>)
    a68c:	6819      	ldr	r1, [r3, #0]
    a68e:	4b6a      	ldr	r3, [pc, #424]	; (a838 <TCPIP_COMMAND_Task+0x26c>)
    a690:	6818      	ldr	r0, [r3, #0]
    a692:	f010 ff0d 	bl	1b4b0 <_PingStop>
    a696:	e7a9      	b.n	a5ec <TCPIP_COMMAND_Task+0x20>
            if(SYS_TMR_TickCountGet() - icmpStartTick > (SYS_TMR_TickCounterFrequencyGet() * icmpReqDelay) / 1000)
    a698:	f015 fd28 	bl	200ec <SYS_TMR_TickCountGet>
    a69c:	4b6b      	ldr	r3, [pc, #428]	; (a84c <TCPIP_COMMAND_Task+0x280>)
    a69e:	681c      	ldr	r4, [r3, #0]
    a6a0:	1b04      	subs	r4, r0, r4
    a6a2:	f015 fd4b 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
    a6a6:	4b6c      	ldr	r3, [pc, #432]	; (a858 <TCPIP_COMMAND_Task+0x28c>)
    a6a8:	681b      	ldr	r3, [r3, #0]
    a6aa:	fb03 f300 	mul.w	r3, r3, r0
    a6ae:	486b      	ldr	r0, [pc, #428]	; (a85c <TCPIP_COMMAND_Task+0x290>)
    a6b0:	fba0 2303 	umull	r2, r3, r0, r3
    a6b4:	ebb4 1f93 	cmp.w	r4, r3, lsr #6
    a6b8:	d943      	bls.n	a742 <TCPIP_COMMAND_Task+0x176>
                cancelReq = icmpReqCount != icmpAckRecv && icmpReqHandle != 0;    // cancel if there is another one ongoing
    a6ba:	4b65      	ldr	r3, [pc, #404]	; (a850 <TCPIP_COMMAND_Task+0x284>)
    a6bc:	681a      	ldr	r2, [r3, #0]
    a6be:	4b68      	ldr	r3, [pc, #416]	; (a860 <TCPIP_COMMAND_Task+0x294>)
    a6c0:	681b      	ldr	r3, [r3, #0]
    a6c2:	429a      	cmp	r2, r3
    a6c4:	d03b      	beq.n	a73e <TCPIP_COMMAND_Task+0x172>
    a6c6:	4b67      	ldr	r3, [pc, #412]	; (a864 <TCPIP_COMMAND_Task+0x298>)
    a6c8:	681b      	ldr	r3, [r3, #0]
    a6ca:	3300      	adds	r3, #0
    a6cc:	bf18      	it	ne
    a6ce:	2301      	movne	r3, #1
            if(cancelReq)
    a6d0:	2b00      	cmp	r3, #0
    a6d2:	d155      	bne.n	a780 <TCPIP_COMMAND_Task+0x1b4>
            echoRequest.netH = icmpNetH;
    a6d4:	4b64      	ldr	r3, [pc, #400]	; (a868 <TCPIP_COMMAND_Task+0x29c>)
    a6d6:	681b      	ldr	r3, [r3, #0]
    a6d8:	9309      	str	r3, [sp, #36]	; 0x24
            echoRequest.targetAddr = icmpTargetAddr;
    a6da:	4b5a      	ldr	r3, [pc, #360]	; (a844 <TCPIP_COMMAND_Task+0x278>)
    a6dc:	681b      	ldr	r3, [r3, #0]
    a6de:	930a      	str	r3, [sp, #40]	; 0x28
            echoRequest.sequenceNumber = ++icmpSequenceNo;
    a6e0:	4a62      	ldr	r2, [pc, #392]	; (a86c <TCPIP_COMMAND_Task+0x2a0>)
    a6e2:	8813      	ldrh	r3, [r2, #0]
    a6e4:	3301      	adds	r3, #1
    a6e6:	b29b      	uxth	r3, r3
    a6e8:	8013      	strh	r3, [r2, #0]
    a6ea:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
            echoRequest.identifier = icmpIdentifier;
    a6ee:	4b60      	ldr	r3, [pc, #384]	; (a870 <TCPIP_COMMAND_Task+0x2a4>)
    a6f0:	881b      	ldrh	r3, [r3, #0]
    a6f2:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
            echoRequest.pData = icmpPingBuff;
    a6f6:	4b5f      	ldr	r3, [pc, #380]	; (a874 <TCPIP_COMMAND_Task+0x2a8>)
    a6f8:	930c      	str	r3, [sp, #48]	; 0x30
            echoRequest.dataSize = icmpPingSize;
    a6fa:	4b5f      	ldr	r3, [pc, #380]	; (a878 <TCPIP_COMMAND_Task+0x2ac>)
    a6fc:	681b      	ldr	r3, [r3, #0]
    a6fe:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
            echoRequest.callback = CommandPingHandler;
    a702:	4a5e      	ldr	r2, [pc, #376]	; (a87c <TCPIP_COMMAND_Task+0x2b0>)
    a704:	920e      	str	r2, [sp, #56]	; 0x38
                for(ix = 0; ix < icmpPingSize; ix++)
    a706:	2b00      	cmp	r3, #0
    a708:	dd0a      	ble.n	a720 <TCPIP_COMMAND_Task+0x154>
    a70a:	2400      	movs	r4, #0
                uint8_t* pBuff = icmpPingBuff;
    a70c:	4d59      	ldr	r5, [pc, #356]	; (a874 <TCPIP_COMMAND_Task+0x2a8>)
                for(ix = 0; ix < icmpPingSize; ix++)
    a70e:	4e5a      	ldr	r6, [pc, #360]	; (a878 <TCPIP_COMMAND_Task+0x2ac>)
    srand(seed);
}

static __inline__ uint32_t __attribute__((always_inline)) SYS_RANDOM_PseudoGet( void )
{
    return (uint32_t)rand();
    a710:	f010 fc3c 	bl	1af8c <rand>
                    *pBuff++ = SYS_RANDOM_PseudoGet();
    a714:	f805 0b01 	strb.w	r0, [r5], #1
                for(ix = 0; ix < icmpPingSize; ix++)
    a718:	3401      	adds	r4, #1
    a71a:	6833      	ldr	r3, [r6, #0]
    a71c:	429c      	cmp	r4, r3
    a71e:	dbf7      	blt.n	a710 <TCPIP_COMMAND_Task+0x144>
            echoRes = TCPIP_ICMP_EchoRequest (&echoRequest, &icmpReqHandle);
    a720:	4950      	ldr	r1, [pc, #320]	; (a864 <TCPIP_COMMAND_Task+0x298>)
    a722:	a809      	add	r0, sp, #36	; 0x24
    a724:	f009 feb8 	bl	14498 <TCPIP_ICMP_EchoRequest>
            if(echoRes >= 0 )
    a728:	2800      	cmp	r0, #0
    a72a:	dbae      	blt.n	a68a <TCPIP_COMMAND_Task+0xbe>
                icmpStartTick = SYS_TMR_TickCountGet();
    a72c:	f015 fcde 	bl	200ec <SYS_TMR_TickCountGet>
    a730:	4b46      	ldr	r3, [pc, #280]	; (a84c <TCPIP_COMMAND_Task+0x280>)
    a732:	6018      	str	r0, [r3, #0]
                icmpReqCount++;
    a734:	4a46      	ldr	r2, [pc, #280]	; (a850 <TCPIP_COMMAND_Task+0x284>)
    a736:	6813      	ldr	r3, [r2, #0]
    a738:	3301      	adds	r3, #1
    a73a:	6013      	str	r3, [r2, #0]
    if(killIcmp)
    a73c:	e756      	b.n	a5ec <TCPIP_COMMAND_Task+0x20>
                cancelReq = icmpReqCount != icmpAckRecv && icmpReqHandle != 0;    // cancel if there is another one ongoing
    a73e:	2300      	movs	r3, #0
                newReq = true;
    a740:	e7c6      	b.n	a6d0 <TCPIP_COMMAND_Task+0x104>
            else if(icmpReqCount != icmpAckRecv)
    a742:	4b43      	ldr	r3, [pc, #268]	; (a850 <TCPIP_COMMAND_Task+0x284>)
    a744:	681a      	ldr	r2, [r3, #0]
    a746:	4b46      	ldr	r3, [pc, #280]	; (a860 <TCPIP_COMMAND_Task+0x294>)
    a748:	681b      	ldr	r3, [r3, #0]
    a74a:	429a      	cmp	r2, r3
    a74c:	f43f af4e 	beq.w	a5ec <TCPIP_COMMAND_Task+0x20>
                if(SYS_TMR_TickCountGet() - icmpStartTick > (SYS_TMR_TickCounterFrequencyGet() * TCPIP_STACK_COMMANDS_ICMP_ECHO_TIMEOUT) / 1000)
    a750:	f015 fccc 	bl	200ec <SYS_TMR_TickCountGet>
    a754:	4b3d      	ldr	r3, [pc, #244]	; (a84c <TCPIP_COMMAND_Task+0x280>)
    a756:	681c      	ldr	r4, [r3, #0]
    a758:	1b04      	subs	r4, r0, r4
    a75a:	f015 fcef 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
    a75e:	f241 3388 	movw	r3, #5000	; 0x1388
    a762:	fb03 f300 	mul.w	r3, r3, r0
    a766:	4a3d      	ldr	r2, [pc, #244]	; (a85c <TCPIP_COMMAND_Task+0x290>)
    a768:	fba2 2303 	umull	r2, r3, r2, r3
    a76c:	ebb4 1f93 	cmp.w	r4, r3, lsr #6
    a770:	f67f af3c 	bls.w	a5ec <TCPIP_COMMAND_Task+0x20>
                    cancelReq = icmpReqHandle != 0;    // cancel if there is another one ongoing
    a774:	4b3b      	ldr	r3, [pc, #236]	; (a864 <TCPIP_COMMAND_Task+0x298>)
    a776:	681b      	ldr	r3, [r3, #0]
    a778:	3300      	adds	r3, #0
    a77a:	bf18      	it	ne
    a77c:	2301      	movne	r3, #1
                    newReq = true;
    a77e:	e7a7      	b.n	a6d0 <TCPIP_COMMAND_Task+0x104>
                TCPIP_ICMP_EchoRequestCancel(icmpReqHandle);
    a780:	4b38      	ldr	r3, [pc, #224]	; (a864 <TCPIP_COMMAND_Task+0x298>)
    a782:	6818      	ldr	r0, [r3, #0]
    a784:	f015 fe5a 	bl	2043c <TCPIP_ICMP_EchoRequestCancel>
    a788:	e7a4      	b.n	a6d4 <TCPIP_COMMAND_Task+0x108>
    switch(tcpipCmdStat)
    a78a:	2a08      	cmp	r2, #8
    a78c:	d01f      	beq.n	a7ce <TCPIP_COMMAND_Task+0x202>
    a78e:	2a09      	cmp	r2, #9
    a790:	f47f af34 	bne.w	a5fc <TCPIP_COMMAND_Task+0x30>
            dnsRes = TCPIP_DNS_IsResolved(dnslookupTargetHost, 0, IP_ADDRESS_TYPE_ANY);
    a794:	2200      	movs	r2, #0
    a796:	4611      	mov	r1, r2
    a798:	4839      	ldr	r0, [pc, #228]	; (a880 <TCPIP_COMMAND_Task+0x2b4>)
    a79a:	f016 fd84 	bl	212a6 <TCPIP_DNS_IsResolved>
    a79e:	4605      	mov	r5, r0
            timeout = (SYS_TMR_TickCountGet() - dnsLookUpStartTick)/SYS_TMR_TickCounterFrequencyGet();
    a7a0:	f015 fca4 	bl	200ec <SYS_TMR_TickCountGet>
    a7a4:	4b37      	ldr	r3, [pc, #220]	; (a884 <TCPIP_COMMAND_Task+0x2b8>)
    a7a6:	681c      	ldr	r4, [r3, #0]
    a7a8:	1b04      	subs	r4, r0, r4
    a7aa:	f015 fcc7 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
    a7ae:	fbb4 f0f0 	udiv	r0, r4, r0
            if(timeout >= (TCPIP_DNS_CLIENT_SERVER_TMO/2))
    a7b2:	281d      	cmp	r0, #29
    a7b4:	d929      	bls.n	a80a <TCPIP_COMMAND_Task+0x23e>
                (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "DNS Lookup: request timeout.\r\n");
    a7b6:	4b20      	ldr	r3, [pc, #128]	; (a838 <TCPIP_COMMAND_Task+0x26c>)
    a7b8:	681b      	ldr	r3, [r3, #0]
    a7ba:	681b      	ldr	r3, [r3, #0]
    a7bc:	685b      	ldr	r3, [r3, #4]
    a7be:	4932      	ldr	r1, [pc, #200]	; (a888 <TCPIP_COMMAND_Task+0x2bc>)
    a7c0:	4a32      	ldr	r2, [pc, #200]	; (a88c <TCPIP_COMMAND_Task+0x2c0>)
    a7c2:	6810      	ldr	r0, [r2, #0]
    a7c4:	4798      	blx	r3
                tcpipCmdStat = TCPIP_CMD_STAT_IDLE;
    a7c6:	4b1a      	ldr	r3, [pc, #104]	; (a830 <TCPIP_COMMAND_Task+0x264>)
    a7c8:	2200      	movs	r2, #0
    a7ca:	701a      	strb	r2, [r3, #0]
                break;
    a7cc:	e716      	b.n	a5fc <TCPIP_COMMAND_Task+0x30>
            dnsRes = TCPIP_DNS_Resolve(dnslookupTargetHost, dnsType);
    a7ce:	4b30      	ldr	r3, [pc, #192]	; (a890 <TCPIP_COMMAND_Task+0x2c4>)
    a7d0:	7819      	ldrb	r1, [r3, #0]
    a7d2:	482b      	ldr	r0, [pc, #172]	; (a880 <TCPIP_COMMAND_Task+0x2b4>)
    a7d4:	f017 fc98 	bl	22108 <TCPIP_DNS_Resolve>
            if(dnsRes != TCPIP_DNS_RES_OK && dnsRes != TCPIP_DNS_RES_PENDING && dnsRes != TCPIP_DNS_RES_NAME_IS_IPADDRESS)
    a7d8:	b2c3      	uxtb	r3, r0
    a7da:	2b02      	cmp	r3, #2
    a7dc:	d90d      	bls.n	a7fa <TCPIP_COMMAND_Task+0x22e>
                (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "DNS Lookup: DNS failure for %s, err: %d\r\n", dnslookupTargetHost, dnsRes);
    a7de:	4b16      	ldr	r3, [pc, #88]	; (a838 <TCPIP_COMMAND_Task+0x26c>)
    a7e0:	681b      	ldr	r3, [r3, #0]
    a7e2:	681b      	ldr	r3, [r3, #0]
    a7e4:	685c      	ldr	r4, [r3, #4]
    a7e6:	4603      	mov	r3, r0
    a7e8:	4a25      	ldr	r2, [pc, #148]	; (a880 <TCPIP_COMMAND_Task+0x2b4>)
    a7ea:	492a      	ldr	r1, [pc, #168]	; (a894 <TCPIP_COMMAND_Task+0x2c8>)
    a7ec:	4827      	ldr	r0, [pc, #156]	; (a88c <TCPIP_COMMAND_Task+0x2c0>)
    a7ee:	6800      	ldr	r0, [r0, #0]
    a7f0:	47a0      	blx	r4
                tcpipCmdStat = TCPIP_CMD_STAT_IDLE;
    a7f2:	4b0f      	ldr	r3, [pc, #60]	; (a830 <TCPIP_COMMAND_Task+0x264>)
    a7f4:	2200      	movs	r2, #0
    a7f6:	701a      	strb	r2, [r3, #0]
                break;
    a7f8:	e700      	b.n	a5fc <TCPIP_COMMAND_Task+0x30>
            tcpipCmdStat = TCPIP_DNS_LOOKUP_CMD_WAIT;
    a7fa:	4b0d      	ldr	r3, [pc, #52]	; (a830 <TCPIP_COMMAND_Task+0x264>)
    a7fc:	2209      	movs	r2, #9
    a7fe:	701a      	strb	r2, [r3, #0]
            dnsLookUpStartTick = SYS_TMR_TickCountGet();
    a800:	f015 fc74 	bl	200ec <SYS_TMR_TickCountGet>
    a804:	4b1f      	ldr	r3, [pc, #124]	; (a884 <TCPIP_COMMAND_Task+0x2b8>)
    a806:	6018      	str	r0, [r3, #0]
            break;
    a808:	e6f8      	b.n	a5fc <TCPIP_COMMAND_Task+0x30>
            if(dnsRes == TCPIP_DNS_RES_PENDING)
    a80a:	2d01      	cmp	r5, #1
    a80c:	f43f aef6 	beq.w	a5fc <TCPIP_COMMAND_Task+0x30>
            else if(dnsRes < 0 )
    a810:	2d00      	cmp	r5, #0
    a812:	da41      	bge.n	a898 <TCPIP_COMMAND_Task+0x2cc>
                (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "DNS Lookup: DNS failure for %s, err: %d\r\n", dnslookupTargetHost, dnsRes);
    a814:	4b08      	ldr	r3, [pc, #32]	; (a838 <TCPIP_COMMAND_Task+0x26c>)
    a816:	681b      	ldr	r3, [r3, #0]
    a818:	681b      	ldr	r3, [r3, #0]
    a81a:	685c      	ldr	r4, [r3, #4]
    a81c:	462b      	mov	r3, r5
    a81e:	4a18      	ldr	r2, [pc, #96]	; (a880 <TCPIP_COMMAND_Task+0x2b4>)
    a820:	491c      	ldr	r1, [pc, #112]	; (a894 <TCPIP_COMMAND_Task+0x2c8>)
    a822:	481a      	ldr	r0, [pc, #104]	; (a88c <TCPIP_COMMAND_Task+0x2c0>)
    a824:	6800      	ldr	r0, [r0, #0]
    a826:	47a0      	blx	r4
                tcpipCmdStat = TCPIP_CMD_STAT_IDLE;
    a828:	4b01      	ldr	r3, [pc, #4]	; (a830 <TCPIP_COMMAND_Task+0x264>)
    a82a:	2200      	movs	r2, #0
    a82c:	701a      	strb	r2, [r3, #0]
                break;
    a82e:	e6e5      	b.n	a5fc <TCPIP_COMMAND_Task+0x30>
    a830:	2000e1af 	.word	0x2000e1af
    a834:	2000e190 	.word	0x2000e190
    a838:	2000e3e0 	.word	0x2000e3e0
    a83c:	000015f4 	.word	0x000015f4
    a840:	2000e3b8 	.word	0x2000e3b8
    a844:	2000e3d4 	.word	0x2000e3d4
    a848:	2000e304 	.word	0x2000e304
    a84c:	2000e3d0 	.word	0x2000e3d0
    a850:	2000e3c0 	.word	0x2000e3c0
    a854:	2000e3cc 	.word	0x2000e3cc
    a858:	2000e3c4 	.word	0x2000e3c4
    a85c:	10624dd3 	.word	0x10624dd3
    a860:	2000e3b4 	.word	0x2000e3b4
    a864:	2000e3c8 	.word	0x2000e3c8
    a868:	2000e3bc 	.word	0x2000e3bc
    a86c:	2000e4fc 	.word	0x2000e4fc
    a870:	2000e4fa 	.word	0x2000e4fa
    a874:	2000ca04 	.word	0x2000ca04
    a878:	2000e3e8 	.word	0x2000e3e8
    a87c:	00013a49 	.word	0x00013a49
    a880:	2000e170 	.word	0x2000e170
    a884:	2000e3ac 	.word	0x2000e3ac
    a888:	0000163c 	.word	0x0000163c
    a88c:	2000e3b0 	.word	0x2000e3b0
    a890:	2000e315 	.word	0x2000e315
    a894:	00001610 	.word	0x00001610
            _TCPIPStackSignalHandlerSetParams(TCPIP_THIS_MODULE_ID, tcpipCmdSignalHandle, 0);
    a898:	2200      	movs	r2, #0
    a89a:	4b38      	ldr	r3, [pc, #224]	; (a97c <TCPIP_COMMAND_Task+0x3b0>)
    a89c:	6819      	ldr	r1, [r3, #0]
    a89e:	201f      	movs	r0, #31
    a8a0:	f015 fbac 	bl	1fffc <_TCPIPStackSignalHandlerSetParams>
            tcpipCmdStat = TCPIP_CMD_STAT_IDLE;
    a8a4:	4b36      	ldr	r3, [pc, #216]	; (a980 <TCPIP_COMMAND_Task+0x3b4>)
    a8a6:	2200      	movs	r2, #0
    a8a8:	701a      	strb	r2, [r3, #0]
            (*pTcpipCmdDevice->pCmdApi->msg)(dnsLookupCmdIoParam, "Lookup Answer:\r\n----------------------\r\n");
    a8aa:	4b36      	ldr	r3, [pc, #216]	; (a984 <TCPIP_COMMAND_Task+0x3b8>)
    a8ac:	681b      	ldr	r3, [r3, #0]
    a8ae:	681b      	ldr	r3, [r3, #0]
    a8b0:	681b      	ldr	r3, [r3, #0]
    a8b2:	4935      	ldr	r1, [pc, #212]	; (a988 <TCPIP_COMMAND_Task+0x3bc>)
    a8b4:	4a35      	ldr	r2, [pc, #212]	; (a98c <TCPIP_COMMAND_Task+0x3c0>)
    a8b6:	6810      	ldr	r0, [r2, #0]
    a8b8:	4798      	blx	r3
            nIPv4Entries = TCPIP_DNS_GetIPAddressesNumber(dnslookupTargetHost,IP_ADDRESS_TYPE_IPV4);
    a8ba:	4c35      	ldr	r4, [pc, #212]	; (a990 <TCPIP_COMMAND_Task+0x3c4>)
    a8bc:	2101      	movs	r1, #1
    a8be:	4620      	mov	r0, r4
    a8c0:	f010 fee6 	bl	1b690 <TCPIP_DNS_GetIPAddressesNumber>
    a8c4:	4680      	mov	r8, r0
            nIPv6Entries = TCPIP_DNS_GetIPAddressesNumber(dnslookupTargetHost,IP_ADDRESS_TYPE_IPV6);
    a8c6:	2102      	movs	r1, #2
    a8c8:	4620      	mov	r0, r4
    a8ca:	f010 fee1 	bl	1b690 <TCPIP_DNS_GetIPAddressesNumber>
    a8ce:	4681      	mov	r9, r0
            if((nIPv4Entries == 0) && (nIPv6Entries == 0))
    a8d0:	ea58 0300 	orrs.w	r3, r8, r0
    a8d4:	d109      	bne.n	a8ea <TCPIP_COMMAND_Task+0x31e>
                (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "No Lookup entry for [%s]\r\n",dnslookupTargetHost);
    a8d6:	4b2b      	ldr	r3, [pc, #172]	; (a984 <TCPIP_COMMAND_Task+0x3b8>)
    a8d8:	681b      	ldr	r3, [r3, #0]
    a8da:	681b      	ldr	r3, [r3, #0]
    a8dc:	685b      	ldr	r3, [r3, #4]
    a8de:	4622      	mov	r2, r4
    a8e0:	492c      	ldr	r1, [pc, #176]	; (a994 <TCPIP_COMMAND_Task+0x3c8>)
    a8e2:	482a      	ldr	r0, [pc, #168]	; (a98c <TCPIP_COMMAND_Task+0x3c0>)
    a8e4:	6800      	ldr	r0, [r0, #0]
    a8e6:	4798      	blx	r3
                break;
    a8e8:	e688      	b.n	a5fc <TCPIP_COMMAND_Task+0x30>
            if((nIPv4Entries == 0) && (nIPv6Entries == 0))
    a8ea:	2400      	movs	r4, #0
    a8ec:	4625      	mov	r5, r4
                    TCPIP_DNS_GetIPv6Addresses(dnslookupTargetHost, ipv6Index, &ip6Address, 1);
    a8ee:	4e28      	ldr	r6, [pc, #160]	; (a990 <TCPIP_COMMAND_Task+0x3c4>)
                    (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "[%s] AAAA IPv6 Address :%s\r\n",dnslookupTargetHost,addrBuf);
    a8f0:	f8df b0a4 	ldr.w	fp, [pc, #164]	; a998 <TCPIP_COMMAND_Task+0x3cc>
    a8f4:	f50b 7a51 	add.w	sl, fp, #836	; 0x344
    a8f8:	e01c      	b.n	a934 <TCPIP_COMMAND_Task+0x368>
                    TCPIP_DNS_GetIPv4Addresses(dnslookupTargetHost, ipv4Index, &ip4Address, 1);
    a8fa:	2301      	movs	r3, #1
    a8fc:	aa04      	add	r2, sp, #16
    a8fe:	4629      	mov	r1, r5
    a900:	4630      	mov	r0, r6
    a902:	f017 f93b 	bl	21b7c <TCPIP_DNS_GetIPv4Addresses>
                    (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "[%s] A IPv4 Address : %d.%d.%d.%d\r\n",dnslookupTargetHost,ip4Address.v[0],
    a906:	4b1f      	ldr	r3, [pc, #124]	; (a984 <TCPIP_COMMAND_Task+0x3b8>)
    a908:	681b      	ldr	r3, [r3, #0]
    a90a:	681b      	ldr	r3, [r3, #0]
    a90c:	f89d 2013 	ldrb.w	r2, [sp, #19]
    a910:	9202      	str	r2, [sp, #8]
    a912:	f89d 2012 	ldrb.w	r2, [sp, #18]
    a916:	9201      	str	r2, [sp, #4]
    a918:	f89d 2011 	ldrb.w	r2, [sp, #17]
    a91c:	9200      	str	r2, [sp, #0]
    a91e:	685f      	ldr	r7, [r3, #4]
    a920:	f89d 3010 	ldrb.w	r3, [sp, #16]
    a924:	4632      	mov	r2, r6
    a926:	f50b 7148 	add.w	r1, fp, #800	; 0x320
    a92a:	4818      	ldr	r0, [pc, #96]	; (a98c <TCPIP_COMMAND_Task+0x3c0>)
    a92c:	6800      	ldr	r0, [r0, #0]
    a92e:	47b8      	blx	r7
                    ipv4Index++;
    a930:	3501      	adds	r5, #1
    a932:	b2ed      	uxtb	r5, r5
                if(ipv4Index<nIPv4Entries)
    a934:	45a8      	cmp	r8, r5
    a936:	dce0      	bgt.n	a8fa <TCPIP_COMMAND_Task+0x32e>
                else if(ipv6Index<nIPv6Entries)
    a938:	45a1      	cmp	r9, r4
    a93a:	f77f ae5f 	ble.w	a5fc <TCPIP_COMMAND_Task+0x30>
                    TCPIP_DNS_GetIPv6Addresses(dnslookupTargetHost, ipv6Index, &ip6Address, 1);
    a93e:	2301      	movs	r3, #1
    a940:	aa05      	add	r2, sp, #20
    a942:	4621      	mov	r1, r4
    a944:	4630      	mov	r0, r6
    a946:	f017 f921 	bl	21b8c <TCPIP_DNS_GetIPv6Addresses>
                    memset(addrBuf,0,sizeof(addrBuf));
    a94a:	272c      	movs	r7, #44	; 0x2c
    a94c:	463a      	mov	r2, r7
    a94e:	2100      	movs	r1, #0
    a950:	a809      	add	r0, sp, #36	; 0x24
    a952:	f017 f99b 	bl	21c8c <memset>
                    TCPIP_Helper_IPv6AddressToString(&ip6Address,(char*)addrBuf,sizeof(addrBuf));
    a956:	463a      	mov	r2, r7
    a958:	a909      	add	r1, sp, #36	; 0x24
    a95a:	a805      	add	r0, sp, #20
    a95c:	f00c ffb7 	bl	178ce <TCPIP_Helper_IPv6AddressToString>
                    (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "[%s] AAAA IPv6 Address :%s\r\n",dnslookupTargetHost,addrBuf);
    a960:	4b08      	ldr	r3, [pc, #32]	; (a984 <TCPIP_COMMAND_Task+0x3b8>)
    a962:	681b      	ldr	r3, [r3, #0]
    a964:	681b      	ldr	r3, [r3, #0]
    a966:	685f      	ldr	r7, [r3, #4]
    a968:	ab09      	add	r3, sp, #36	; 0x24
    a96a:	4632      	mov	r2, r6
    a96c:	4651      	mov	r1, sl
    a96e:	4807      	ldr	r0, [pc, #28]	; (a98c <TCPIP_COMMAND_Task+0x3c0>)
    a970:	6800      	ldr	r0, [r0, #0]
    a972:	47b8      	blx	r7
                    ipv6Index++;
    a974:	3401      	adds	r4, #1
    a976:	b2e4      	uxtb	r4, r4
    a978:	e7dc      	b.n	a934 <TCPIP_COMMAND_Task+0x368>
    a97a:	bf00      	nop
    a97c:	2000e3e4 	.word	0x2000e3e4
    a980:	2000e1af 	.word	0x2000e1af
    a984:	2000e3e0 	.word	0x2000e3e0
    a988:	0000165c 	.word	0x0000165c
    a98c:	2000e3b0 	.word	0x2000e3b0
    a990:	2000e170 	.word	0x2000e170
    a994:	00001688 	.word	0x00001688
    a998:	00001384 	.word	0x00001384

Disassembly of section .text.GenericTxStart%201:

0000a99c <GenericTxStart>:
{
    a99c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a9a0:	4604      	mov	r4, r0
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;    
    a9a2:	f8d0 30c4 	ldr.w	r3, [r0, #196]	; 0xc4
    a9a6:	685f      	ldr	r7, [r3, #4]
    currentTime = SYS_TMR_TickCountGet();
    a9a8:	f015 fba0 	bl	200ec <SYS_TMR_TickCountGet>
   	if ( currentTime < (pIState->nextTxTime - TCPIP_IPERF_TIMING_ERROR_MARGIN))
    a9ac:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
    a9b0:	4283      	cmp	r3, r0
    a9b2:	f200 81c0 	bhi.w	ad36 <GenericTxStart+0x39a>
    a9b6:	4605      	mov	r5, r0
    iperfKilled = pIState->stopRequested;
    a9b8:	f894 60cf 	ldrb.w	r6, [r4, #207]	; 0xcf
    if ((iperfKilled == true) ||
    a9bc:	b98e      	cbnz	r6, a9e2 <GenericTxStart+0x46>
            ((pIState->mDuration != 0u) &&
    a9be:	68a3      	ldr	r3, [r4, #8]
    if ((iperfKilled == true) ||
    a9c0:	b123      	cbz	r3, a9cc <GenericTxStart+0x30>
             (currentTime > (pIState->startTime + pIState->mDuration))) ||
    a9c2:	f8d4 2088 	ldr.w	r2, [r4, #136]	; 0x88
    a9c6:	4413      	add	r3, r2
            ((pIState->mDuration != 0u) &&
    a9c8:	4283      	cmp	r3, r0
    a9ca:	d30a      	bcc.n	a9e2 <GenericTxStart+0x46>
            ((pIState->mAmount != 0u) &&
    a9cc:	6860      	ldr	r0, [r4, #4]
             (currentTime > (pIState->startTime + pIState->mDuration))) ||
    a9ce:	b158      	cbz	r0, a9e8 <GenericTxStart+0x4c>
             (pIState->totalLen > pIState->mAmount)))
    a9d0:	f000 fccc 	bl	b36c <__aeabi_ui2d>
            ((pIState->mAmount != 0u) &&
    a9d4:	4602      	mov	r2, r0
    a9d6:	460b      	mov	r3, r1
    a9d8:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    a9dc:	f009 f93a 	bl	13c54 <__aeabi_dcmpgt>
    a9e0:	b110      	cbz	r0, a9e8 <GenericTxStart+0x4c>
        pIState->isLastTransmit = true;
    a9e2:	2301      	movs	r3, #1
    a9e4:	f884 30d0 	strb.w	r3, [r4, #208]	; 0xd0
    if ( pIState->pktId == 0 )
    a9e8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    a9ea:	b973      	cbnz	r3, aa0a <GenericTxStart+0x6e>
        pIState->startTime = currentTime;
    a9ec:	f8c4 5088 	str.w	r5, [r4, #136]	; 0x88
        pIState->lastCheckTime = 	pIState->startTime;
    a9f0:	f8c4 50a8 	str.w	r5, [r4, #168]	; 0xa8
        pIState->lastCheckPktId = pIState->pktId;
    a9f4:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
        pIState->lastCheckPktCount = pIState->pktCount;
    a9f8:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
    a9fc:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
        pIState->lastCheckErrorCount = pIState->errorCount;
    aa00:	6b22      	ldr	r2, [r4, #48]	; 0x30
    aa02:	f8c4 20a0 	str.w	r2, [r4, #160]	; 0xa0
        pIState->nAttempts = 0;
    aa06:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
    pIState->nextTxTime = currentTime + pIState->mPktPeriod;
    aa0a:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
    aa0e:	441d      	add	r5, r3
    aa10:	f8c4 5090 	str.w	r5, [r4, #144]	; 0x90
    switch(pIState->mProtocol)
    aa14:	7c23      	ldrb	r3, [r4, #16]
    aa16:	2b01      	cmp	r3, #1
    aa18:	d02a      	beq.n	aa70 <GenericTxStart+0xd4>
    aa1a:	2b02      	cmp	r3, #2
    aa1c:	f040 80b9 	bne.w	ab92 <GenericTxStart+0x1f6>
            if( TCPIP_TCP_GetIsReady(pIState->tcpClientSock) > 0u )
    aa20:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    aa24:	f017 f817 	bl	21a56 <TCPIP_TCP_GetIsReady>
    aa28:	b9e0      	cbnz	r0, aa64 <GenericTxStart+0xc8>
            if ( TCPIP_TCP_WasReset(pIState->tcpClientSock) )
    aa2a:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    aa2e:	f015 f8ec 	bl	1fc0a <TCPIP_TCP_WasReset>
    aa32:	b148      	cbz	r0, aa48 <GenericTxStart+0xac>
                (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "\r\niperf: Warning, TCP server disconnect detected\r\n");
    aa34:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    aa38:	681b      	ldr	r3, [r3, #0]
    aa3a:	681b      	ldr	r3, [r3, #0]
    aa3c:	49c2      	ldr	r1, [pc, #776]	; (ad48 <GenericTxStart+0x3ac>)
    aa3e:	4638      	mov	r0, r7
    aa40:	4798      	blx	r3
                pIState->stopRequested = 1;
    aa42:	2301      	movs	r3, #1
    aa44:	f884 30cf 	strb.w	r3, [r4, #207]	; 0xcf
            if  (( TCPIP_TCP_PutIsReady(pIState->tcpClientSock) <= pIState->mMSS ) && (!iperfKilled))
    aa48:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    aa4c:	f016 fc1e 	bl	2128c <TCPIP_TCP_PutIsReady>
    aa50:	f8b4 30d2 	ldrh.w	r3, [r4, #210]	; 0xd2
    aa54:	4283      	cmp	r3, r0
    aa56:	f0c0 809c 	bcc.w	ab92 <GenericTxStart+0x1f6>
    aa5a:	2e00      	cmp	r6, #0
    aa5c:	f040 8099 	bne.w	ab92 <GenericTxStart+0x1f6>
                return IPERF_TX_WAIT;
    aa60:	4635      	mov	r5, r6
    aa62:	e169      	b.n	ad38 <GenericTxStart+0x39c>
                TCPIP_TCP_Discard(pIState->tcpClientSock);
    aa64:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    aa68:	f015 fc2e 	bl	202c8 <TCPIP_TCP_Discard>
                return IPERF_TX_WAIT;
    aa6c:	2500      	movs	r5, #0
    aa6e:	e163      	b.n	ad38 <GenericTxStart+0x39c>
            if( TCPIP_UDP_GetIsReady(pIState->udpSock) > 0u )
    aa70:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    aa74:	f015 fafe 	bl	20074 <TCPIP_UDP_GetIsReady>
    aa78:	b938      	cbnz	r0, aa8a <GenericTxStart+0xee>
            for(i = 0, mpIState = gIperfState; i < nIperfSessions; i++, mpIState++)
    aa7a:	4bb4      	ldr	r3, [pc, #720]	; (ad4c <GenericTxStart+0x3b0>)
    aa7c:	6818      	ldr	r0, [r3, #0]
    aa7e:	2800      	cmp	r0, #0
    aa80:	dd49      	ble.n	ab16 <GenericTxStart+0x17a>
    aa82:	2300      	movs	r3, #0
    aa84:	49b2      	ldr	r1, [pc, #712]	; (ad50 <GenericTxStart+0x3b4>)
                if(mpIState->waitCount == 3) mpIState->waitCount = 0;
    aa86:	469c      	mov	ip, r3
    aa88:	e027      	b.n	aada <GenericTxStart+0x13e>
                TCPIP_UDP_Discard(pIState->udpSock);
    aa8a:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    aa8e:	f015 febc 	bl	2080a <TCPIP_UDP_Discard>
                return IPERF_TX_WAIT;
    aa92:	2500      	movs	r5, #0
    aa94:	e150      	b.n	ad38 <GenericTxStart+0x39c>
                        if(mpIState->mTypeOfService == TCPIP_IPV4_RELIABILITY_HIGH || mpIState->mTypeOfService == TCPIP_IPV4_THROUGHPUT_HIGH || mpIState->mTypeOfService == TCPIP_IPV4_TOS_DEFAULT)
    aa96:	7d0d      	ldrb	r5, [r1, #20]
    aa98:	2d20      	cmp	r5, #32
    aa9a:	d002      	beq.n	aaa2 <GenericTxStart+0x106>
    aa9c:	f015 0fef 	tst.w	r5, #239	; 0xef
    aaa0:	d116      	bne.n	aad0 <GenericTxStart+0x134>
                            if(mpIState->sockWaitToSend)
    aaa2:	f891 50d4 	ldrb.w	r5, [r1, #212]	; 0xd4
    aaa6:	b19d      	cbz	r5, aad0 <GenericTxStart+0x134>
                                mpIState->waitCount += 1;
    aaa8:	3201      	adds	r2, #1
    aaaa:	f881 20d5 	strb.w	r2, [r1, #213]	; 0xd5
                                return IPERF_TX_WAIT;
    aaae:	2500      	movs	r5, #0
    aab0:	e142      	b.n	ad38 <GenericTxStart+0x39c>
                        if(mpIState->mTypeOfService == TCPIP_IPV4_THROUGHPUT_HIGH)
    aab2:	7d0d      	ldrb	r5, [r1, #20]
    aab4:	2d10      	cmp	r5, #16
    aab6:	d10b      	bne.n	aad0 <GenericTxStart+0x134>
                            if(mpIState->sockWaitToSend)
    aab8:	f891 50d4 	ldrb.w	r5, [r1, #212]	; 0xd4
    aabc:	b145      	cbz	r5, aad0 <GenericTxStart+0x134>
                                mpIState->waitCount += 1;
    aabe:	3201      	adds	r2, #1
    aac0:	f881 20d5 	strb.w	r2, [r1, #213]	; 0xd5
                                return IPERF_TX_WAIT;
    aac4:	2500      	movs	r5, #0
    aac6:	e137      	b.n	ad38 <GenericTxStart+0x39c>
                if(mpIState->waitCount == 3) mpIState->waitCount = 0;
    aac8:	2a03      	cmp	r2, #3
    aaca:	bf08      	it	eq
    aacc:	f881 c0d5 	strbeq.w	ip, [r1, #213]	; 0xd5
            for(i = 0, mpIState = gIperfState; i < nIperfSessions; i++, mpIState++)
    aad0:	3301      	adds	r3, #1
    aad2:	b2db      	uxtb	r3, r3
    aad4:	31d8      	adds	r1, #216	; 0xd8
    aad6:	4283      	cmp	r3, r0
    aad8:	da1d      	bge.n	ab16 <GenericTxStart+0x17a>
    	        if(mpIState == pIState) continue;
    aada:	428c      	cmp	r4, r1
    aadc:	d0f8      	beq.n	aad0 <GenericTxStart+0x134>
                if(mpIState->waitCount < 3)    
    aade:	f891 20d5 	ldrb.w	r2, [r1, #213]	; 0xd5
    aae2:	2a02      	cmp	r2, #2
    aae4:	d8f0      	bhi.n	aac8 <GenericTxStart+0x12c>
                switch(pIState->mTypeOfService)
    aae6:	7d25      	ldrb	r5, [r4, #20]
    aae8:	2d08      	cmp	r5, #8
    aaea:	d0d4      	beq.n	aa96 <GenericTxStart+0xfa>
    aaec:	2d20      	cmp	r5, #32
    aaee:	d0e0      	beq.n	aab2 <GenericTxStart+0x116>
    aaf0:	2d00      	cmp	r5, #0
    aaf2:	d1e9      	bne.n	aac8 <GenericTxStart+0x12c>
                        if(mpIState->mTypeOfService == TCPIP_IPV4_RELIABILITY_HIGH || mpIState->mTypeOfService == TCPIP_IPV4_THROUGHPUT_HIGH )
    aaf4:	f891 e014 	ldrb.w	lr, [r1, #20]
    aaf8:	f1be 0f20 	cmp.w	lr, #32
    aafc:	d002      	beq.n	ab04 <GenericTxStart+0x168>
    aafe:	f1be 0f10 	cmp.w	lr, #16
    ab02:	d1e5      	bne.n	aad0 <GenericTxStart+0x134>
                            if(mpIState->sockWaitToSend)
    ab04:	f891 e0d4 	ldrb.w	lr, [r1, #212]	; 0xd4
    ab08:	f1be 0f00 	cmp.w	lr, #0
    ab0c:	d0e0      	beq.n	aad0 <GenericTxStart+0x134>
                                mpIState->waitCount += 1;
    ab0e:	3201      	adds	r2, #1
    ab10:	f881 20d5 	strb.w	r2, [r1, #213]	; 0xd5
                                return IPERF_TX_WAIT;
    ab14:	e110      	b.n	ad38 <GenericTxStart+0x39c>
            if ( TCPIP_UDP_TxPutIsReady(pIState->udpSock, pIState->mDatagramSize) < pIState->mDatagramSize )
    ab16:	89a1      	ldrh	r1, [r4, #12]
    ab18:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    ab1c:	f017 fb37 	bl	2218e <TCPIP_UDP_TxPutIsReady>
    ab20:	68e3      	ldr	r3, [r4, #12]
    ab22:	4298      	cmp	r0, r3
    ab24:	d22d      	bcs.n	ab82 <GenericTxStart+0x1e6>
                pIState->sockWaitToSend += 1;
    ab26:	f894 30d4 	ldrb.w	r3, [r4, #212]	; 0xd4
    ab2a:	3301      	adds	r3, #1
    ab2c:	f884 30d4 	strb.w	r3, [r4, #212]	; 0xd4
                if(pIState->txWaitTick == 0)
    ab30:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
    ab34:	b143      	cbz	r3, ab48 <GenericTxStart+0x1ac>
                else if((int32_t)(SYS_TMR_TickCountGet() - pIState->txWaitTick) < 0)
    ab36:	f015 fad9 	bl	200ec <SYS_TMR_TickCountGet>
    ab3a:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
    ab3e:	1ac3      	subs	r3, r0, r3
    ab40:	2b00      	cmp	r3, #0
    ab42:	da14      	bge.n	ab6e <GenericTxStart+0x1d2>
					return IPERF_TX_WAIT;
    ab44:	2500      	movs	r5, #0
    ab46:	e0f7      	b.n	ad38 <GenericTxStart+0x39c>
                    pIState->txWaitTick = SYS_TMR_TickCountGet() + ((TCPIP_IPERF_TX_WAIT_TMO * SYS_TMR_TickCounterFrequencyGet()) + 999)/1000;
    ab48:	f015 fad0 	bl	200ec <SYS_TMR_TickCountGet>
    ab4c:	4605      	mov	r5, r0
    ab4e:	f015 faf5 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
    ab52:	2364      	movs	r3, #100	; 0x64
    ab54:	fb03 f300 	mul.w	r3, r3, r0
    ab58:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
    ab5c:	4a7d      	ldr	r2, [pc, #500]	; (ad54 <GenericTxStart+0x3b8>)
    ab5e:	fba2 2303 	umull	r2, r3, r2, r3
    ab62:	eb05 1393 	add.w	r3, r5, r3, lsr #6
    ab66:	f8c4 30b4 	str.w	r3, [r4, #180]	; 0xb4
                    return IPERF_TX_WAIT;
    ab6a:	2500      	movs	r5, #0
    ab6c:	e0e4      	b.n	ad38 <GenericTxStart+0x39c>
                (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf: Failed to get %d bytes socket TX space\r\n", pIState->mDatagramSize);
    ab6e:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    ab72:	681b      	ldr	r3, [r3, #0]
    ab74:	685b      	ldr	r3, [r3, #4]
    ab76:	68e2      	ldr	r2, [r4, #12]
    ab78:	4977      	ldr	r1, [pc, #476]	; (ad58 <GenericTxStart+0x3bc>)
    ab7a:	4638      	mov	r0, r7
    ab7c:	4798      	blx	r3
                return IPERF_TX_FAIL;
    ab7e:	2502      	movs	r5, #2
    ab80:	e0da      	b.n	ad38 <GenericTxStart+0x39c>
                pIState->txWaitTick = 0;
    ab82:	2300      	movs	r3, #0
    ab84:	f8c4 30b4 	str.w	r3, [r4, #180]	; 0xb4
                pIState->sockWaitToSend -= 1;                
    ab88:	f894 30d4 	ldrb.w	r3, [r4, #212]	; 0xd4
    ab8c:	3b01      	subs	r3, #1
    ab8e:	f884 30d4 	strb.w	r3, [r4, #212]	; 0xd4
    GenericTxHeaderPreparation(pIState, g_bfr, pIState->isLastTransmit);
    ab92:	f894 10d0 	ldrb.w	r1, [r4, #208]	; 0xd0
    switch ( pIState->mProtocol )
    ab96:	7c23      	ldrb	r3, [r4, #16]
    ab98:	2b01      	cmp	r3, #1
    ab9a:	f000 808b 	beq.w	acb4 <GenericTxStart+0x318>
    ab9e:	2b02      	cmp	r3, #2
    aba0:	f000 808c 	beq.w	acbc <GenericTxStart+0x320>
    tClientHdr *pClientHdr = NULL;
    aba4:	2300      	movs	r3, #0
    tIperfPktInfo *pPktInfo = NULL;
    aba6:	461d      	mov	r5, r3
    pClientHdr->flags = TCPIP_Helper_htonl( (uint32_t) 0);
    aba8:	2000      	movs	r0, #0
    abaa:	6018      	str	r0, [r3, #0]
    pClientHdr->numThreads = TCPIP_Helper_htonl((uint32_t) 1);
    abac:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    abb0:	605a      	str	r2, [r3, #4]
    pClientHdr->mPort = TCPIP_Helper_htonl((uint32_t) pIState->mServerPort);
    abb2:	f8b4 c012 	ldrh.w	ip, [r4, #18]
    return (((hLong & 0x000000ff) << 24) | ((hLong & 0x0000ff00) << 8) | ((hLong & 0x00ff0000) >> 8) | ((hLong & 0xff000000) >> 24));
    abb6:	ea4f 220c 	mov.w	r2, ip, lsl #8
    abba:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
    abbe:	ea42 620c 	orr.w	r2, r2, ip, lsl #24
    abc2:	609a      	str	r2, [r3, #8]
    pClientHdr->bufferlen = TCPIP_Helper_htonl( (uint32_t) 0);
    abc4:	60d8      	str	r0, [r3, #12]
    pClientHdr->mWinBand = TCPIP_Helper_htonl(pIState->mTxRate);
    abc6:	69a2      	ldr	r2, [r4, #24]
    abc8:	0e10      	lsrs	r0, r2, #24
    abca:	ea40 6002 	orr.w	r0, r0, r2, lsl #24
    abce:	ea4f 2c02 	mov.w	ip, r2, lsl #8
    abd2:	f40c 0c7f 	and.w	ip, ip, #16711680	; 0xff0000
    abd6:	ea40 000c 	orr.w	r0, r0, ip
    abda:	0a12      	lsrs	r2, r2, #8
    abdc:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
    abe0:	4302      	orrs	r2, r0
    abe2:	611a      	str	r2, [r3, #16]
    if ( pIState->mAmount != 0u )
    abe4:	6860      	ldr	r0, [r4, #4]
    abe6:	2800      	cmp	r0, #0
    abe8:	d06c      	beq.n	acc4 <GenericTxStart+0x328>
    abea:	0e02      	lsrs	r2, r0, #24
    abec:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    abf0:	ea4f 2c00 	mov.w	ip, r0, lsl #8
    abf4:	f40c 0c7f 	and.w	ip, ip, #16711680	; 0xff0000
    abf8:	ea42 020c 	orr.w	r2, r2, ip
    abfc:	0a00      	lsrs	r0, r0, #8
    abfe:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
    ac02:	4302      	orrs	r2, r0
    ac04:	615a      	str	r2, [r3, #20]
    if ( isTheLastTransmit == true )
    ac06:	2900      	cmp	r1, #0
    ac08:	d070      	beq.n	acec <GenericTxStart+0x350>
        pPktInfo->id = - ( (long) (pIState->pktId - pIState->nAttempts) );
    ac0a:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
    ac0e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    ac10:	1a9b      	subs	r3, r3, r2
    ac12:	0e1a      	lsrs	r2, r3, #24
    ac14:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    ac18:	0219      	lsls	r1, r3, #8
    ac1a:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    ac1e:	430a      	orrs	r2, r1
    ac20:	0a1b      	lsrs	r3, r3, #8
    ac22:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    ac26:	4313      	orrs	r3, r2
    pPktInfo->id = TCPIP_Helper_htonl(pPktInfo->id);
    ac28:	602b      	str	r3, [r5, #0]
    currentTime = SYS_TMR_TickCountGet();
    ac2a:	f015 fa5f 	bl	200ec <SYS_TMR_TickCountGet>
    ac2e:	4680      	mov	r8, r0
    uint32_t tickFreq = SYS_TMR_TickCounterFrequencyGet(); 
    ac30:	f015 fa84 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
    pPktInfo->tv_sec = TCPIP_Helper_htonl(currentTime / tickFreq);
    ac34:	fbb8 f3f0 	udiv	r3, r8, r0
    ac38:	0e1a      	lsrs	r2, r3, #24
    ac3a:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    ac3e:	0219      	lsls	r1, r3, #8
    ac40:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    ac44:	430a      	orrs	r2, r1
    ac46:	0a1b      	lsrs	r3, r3, #8
    ac48:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    ac4c:	4313      	orrs	r3, r2
    ac4e:	606b      	str	r3, [r5, #4]
    tmp2 = ((pIState->stopTime - pIState->startTime) % tickFreq);
    ac50:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
    ac54:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    ac58:	1ad3      	subs	r3, r2, r3
    ac5a:	fbb3 f2f0 	udiv	r2, r3, r0
    ac5e:	fb00 3212 	mls	r2, r0, r2, r3
    tmp2 =  tmp2 * 1000 / tickFreq; /* Convert to mSec */
    ac62:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    ac66:	fb03 f202 	mul.w	r2, r3, r2
    ac6a:	fbb2 f0f0 	udiv	r0, r2, r0
    tmp2 *= 1000;   /* 1000 uSecs per mSec */
    ac6e:	fb03 f000 	mul.w	r0, r3, r0
    ac72:	0e03      	lsrs	r3, r0, #24
    ac74:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
    ac78:	0202      	lsls	r2, r0, #8
    ac7a:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
    ac7e:	4313      	orrs	r3, r2
    ac80:	0a00      	lsrs	r0, r0, #8
    ac82:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
    ac86:	4318      	orrs	r0, r3
    pPktInfo->tv_usec = TCPIP_Helper_htonl( tmp2 );
    ac88:	60a8      	str	r0, [r5, #8]
    switch( pIState->mProtocol)
    ac8a:	7c25      	ldrb	r5, [r4, #16]
    ac8c:	2d01      	cmp	r5, #1
    ac8e:	d03a      	beq.n	ad06 <GenericTxStart+0x36a>
    ac90:	2d02      	cmp	r5, #2
    ac92:	d154      	bne.n	ad3e <GenericTxStart+0x3a2>
            pIState->remainingTxData = (pIState->mMSS - MAX_BUFFER);
    ac94:	f8b4 30d2 	ldrh.w	r3, [r4, #210]	; 0xd2
    ac98:	3b34      	subs	r3, #52	; 0x34
    ac9a:	f8a4 30b0 	strh.w	r3, [r4, #176]	; 0xb0
            if (( TCPIP_TCP_ArrayPut(pIState->tcpClientSock, (uint8_t*) g_bfr, MAX_BUFFER) != MAX_BUFFER ) && (!iperfKilled))
    ac9e:	2234      	movs	r2, #52	; 0x34
    aca0:	492e      	ldr	r1, [pc, #184]	; (ad5c <GenericTxStart+0x3c0>)
    aca2:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    aca6:	f006 f94b 	bl	10f40 <TCPIP_TCP_ArrayPut>
    acaa:	2834      	cmp	r0, #52	; 0x34
    acac:	d049      	beq.n	ad42 <GenericTxStart+0x3a6>
    acae:	b1fe      	cbz	r6, acf0 <GenericTxStart+0x354>
    return IPERF_TX_OK;
    acb0:	2501      	movs	r5, #1
    acb2:	e041      	b.n	ad38 <GenericTxStart+0x39c>
            pClientHdr = (tClientHdr *) (pPktInfo + 1);
    acb4:	4d29      	ldr	r5, [pc, #164]	; (ad5c <GenericTxStart+0x3c0>)
    acb6:	f105 030c 	add.w	r3, r5, #12
    acba:	e775      	b.n	aba8 <GenericTxStart+0x20c>
            pClientHdr = (tClientHdr *) pData;
    acbc:	4b27      	ldr	r3, [pc, #156]	; (ad5c <GenericTxStart+0x3c0>)
            pPktInfo = (tIperfPktInfo *) (pClientHdr + 1);
    acbe:	f103 0518 	add.w	r5, r3, #24
    acc2:	e771      	b.n	aba8 <GenericTxStart+0x20c>
        pClientHdr->mAmount = TCPIP_Helper_htonl( - (long) (pIState->mDuration/10) );
    acc4:	68a2      	ldr	r2, [r4, #8]
    acc6:	4826      	ldr	r0, [pc, #152]	; (ad60 <GenericTxStart+0x3c4>)
    acc8:	fba0 2002 	umull	r2, r0, r0, r2
    accc:	08c0      	lsrs	r0, r0, #3
    acce:	4240      	negs	r0, r0
    acd0:	0e02      	lsrs	r2, r0, #24
    acd2:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    acd6:	ea4f 2c00 	mov.w	ip, r0, lsl #8
    acda:	f40c 0c7f 	and.w	ip, ip, #16711680	; 0xff0000
    acde:	ea42 020c 	orr.w	r2, r2, ip
    ace2:	0a00      	lsrs	r0, r0, #8
    ace4:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
    ace8:	4302      	orrs	r2, r0
    acea:	e78b      	b.n	ac04 <GenericTxStart+0x268>
        pPktInfo->id = pIState->pktId;
    acec:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    acee:	e790      	b.n	ac12 <GenericTxStart+0x276>
                (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Socket send failed\r\n");
    acf0:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    acf4:	681b      	ldr	r3, [r3, #0]
    acf6:	681b      	ldr	r3, [r3, #0]
    acf8:	491a      	ldr	r1, [pc, #104]	; (ad64 <GenericTxStart+0x3c8>)
    acfa:	4638      	mov	r0, r7
    acfc:	4798      	blx	r3
                pIState->errorCount++;
    acfe:	6b23      	ldr	r3, [r4, #48]	; 0x30
    ad00:	3301      	adds	r3, #1
    ad02:	6323      	str	r3, [r4, #48]	; 0x30
                return IPERF_TX_FAIL;
    ad04:	e018      	b.n	ad38 <GenericTxStart+0x39c>
            pIState->remainingTxData = (pIState->mDatagramSize - MAX_BUFFER);
    ad06:	68e3      	ldr	r3, [r4, #12]
    ad08:	3b34      	subs	r3, #52	; 0x34
    ad0a:	f8a4 30b0 	strh.w	r3, [r4, #176]	; 0xb0
            if ( TCPIP_UDP_ArrayPut(pIState->udpSock, g_bfr, MAX_BUFFER) != MAX_BUFFER )
    ad0e:	2234      	movs	r2, #52	; 0x34
    ad10:	4912      	ldr	r1, [pc, #72]	; (ad5c <GenericTxStart+0x3c0>)
    ad12:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    ad16:	f011 ffa0 	bl	1cc5a <TCPIP_UDP_ArrayPut>
    ad1a:	2834      	cmp	r0, #52	; 0x34
    ad1c:	d00c      	beq.n	ad38 <GenericTxStart+0x39c>
                (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Socket send failed\r\n");
    ad1e:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    ad22:	681b      	ldr	r3, [r3, #0]
    ad24:	681b      	ldr	r3, [r3, #0]
    ad26:	490f      	ldr	r1, [pc, #60]	; (ad64 <GenericTxStart+0x3c8>)
    ad28:	4638      	mov	r0, r7
    ad2a:	4798      	blx	r3
                pIState->errorCount++;
    ad2c:	6b23      	ldr	r3, [r4, #48]	; 0x30
    ad2e:	3301      	adds	r3, #1
    ad30:	6323      	str	r3, [r4, #48]	; 0x30
                return IPERF_TX_FAIL;
    ad32:	2502      	movs	r5, #2
    ad34:	e000      	b.n	ad38 <GenericTxStart+0x39c>
       	return IPERF_TX_WAIT;
    ad36:	2500      	movs	r5, #0
}
    ad38:	4628      	mov	r0, r5
    ad3a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return IPERF_TX_OK;
    ad3e:	2501      	movs	r5, #1
    ad40:	e7fa      	b.n	ad38 <GenericTxStart+0x39c>
    ad42:	2501      	movs	r5, #1
    ad44:	e7f8      	b.n	ad38 <GenericTxStart+0x39c>
    ad46:	bf00      	nop
    ad48:	00005df4 	.word	0x00005df4
    ad4c:	2000e3f0 	.word	0x2000e3f0
    ad50:	2000d9b0 	.word	0x2000d9b0
    ad54:	10624dd3 	.word	0x10624dd3
    ad58:	00005e28 	.word	0x00005e28
    ad5c:	2000e068 	.word	0x2000e068
    ad60:	cccccccd 	.word	0xcccccccd
    ad64:	00005cfc 	.word	0x00005cfc

Disassembly of section .text.DRV_PIC32CGMAC_LibRxGetPacket%202:

0000ad68 <DRV_PIC32CGMAC_LibRxGetPacket>:
/****************************************************************************
 * Function: DRV_PIC32CGMAC_LibRxGetPacket
 * Summary: extract  RX packet from the RX descriptor
 *****************************************************************************/
DRV_PIC32CGMAC_RESULT DRV_PIC32CGMAC_LibRxGetPacket(DRV_GMAC_DRIVER * pMACDrv, TCPIP_MAC_PACKET** pRxPkt, int* pnBuffs, DRV_GMAC_RXDCPT_STATUS* pRxStat, GMAC_QUE_LIST queueIdx)  
{	
    ad68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ad6c:	b08b      	sub	sp, #44	; 0x2c
    ad6e:	f89d 4050 	ldrb.w	r4, [sp, #80]	; 0x50
    ad72:	9402      	str	r4, [sp, #8]
 * Summary: Check if 'Buffer Not Available' set by GMAC; if set, clear the BNA status bit
 * Return : True if BNA is set; False for no BNA status
 *****************************************************************************/
static bool _IsBufferNotAvailable(DRV_GMAC_DRIVER * pMACDrv)
{
    if(GMAC_REGS->GMAC_RSR & GMAC_RSR_BNA_Msk ) //Check for BNA error due to shortage of Rx Buffers
    ad74:	4cac      	ldr	r4, [pc, #688]	; (b028 <DRV_PIC32CGMAC_LibRxGetPacket+0x2c0>)
    ad76:	6a24      	ldr	r4, [r4, #32]
    ad78:	f014 0f01 	tst.w	r4, #1
    ad7c:	d028      	beq.n	add0 <DRV_PIC32CGMAC_LibRxGetPacket+0x68>
    {       
		//Clear GMAC 'Buffer Not Available' Flag			
		GMAC_REGS->GMAC_RSR = GMAC_RSR_BNA_Msk ;             
    ad7e:	2401      	movs	r4, #1
    ad80:	4da9      	ldr	r5, [pc, #676]	; (b028 <DRV_PIC32CGMAC_LibRxGetPacket+0x2c0>)
    ad82:	622c      	str	r4, [r5, #32]
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    ad84:	f3bf 8f5f 	dmb	sy
		__DMB();  
		return true;
    ad88:	9404      	str	r4, [sp, #16]
	if(!pRxPkt)
    ad8a:	2900      	cmp	r1, #0
    ad8c:	f000 815a 	beq.w	b044 <DRV_PIC32CGMAC_LibRxGetPacket+0x2dc>
    ad90:	9308      	str	r3, [sp, #32]
    ad92:	9207      	str	r2, [sp, #28]
    ad94:	9106      	str	r1, [sp, #24]
    ad96:	4606      	mov	r6, r0
 * end rx descriptor indexes of valid rx data packet  
 * Return : frame search status
 *****************************************************************************/
static GMAC_RXFRAME_STATE _SearchRxPacket(DRV_GMAC_DRIVER * pMACDrv,DRV_PIC32CGMAC_RX_FRAME_INFO *rx_frame_state, GMAC_QUE_LIST queueIdx)  
{
    DRV_PIC32CGMAC_HW_RXDCPT *pRxDesc = pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc;
    ad98:	9a02      	ldr	r2, [sp, #8]
    ad9a:	4691      	mov	r9, r2
    ad9c:	232c      	movs	r3, #44	; 0x2c
    ad9e:	fb03 0302 	mla	r3, r3, r2, r0
    ada2:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
    ada6:	9105      	str	r1, [sp, #20]
    TCPIP_MAC_PACKET* pRxPkt;
    GMAC_RXFRAME_STATE frameState = GMAC_RX_NO_FRAME_STATE;
    uint16_t search_count = 0;
	uint16_t nRxDscCnt =  pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxDescCnt;
    ada8:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
    adac:	eb00 0242 	add.w	r2, r0, r2, lsl #1
    adb0:	f8b2 70be 	ldrh.w	r7, [r2, #190]	; 0xbe
	uint16_t nRxDescIndex = pMACDrv->sGmacData.gmac_queue[queueIdx].nRxDescIndex;		
    adb4:	f8b3 40b0 	ldrh.w	r4, [r3, #176]	; 0xb0
	uint16_t rx_index;
	uint16_t nRx_buffer;	
	
	//search the descriptors for valid data frame; search maximum of descriptor count
	while ( search_count < nRxDscCnt)
    adb8:	2f00      	cmp	r7, #0
    adba:	f000 8145 	beq.w	b048 <DRV_PIC32CGMAC_LibRxGetPacket+0x2e0>
	DRV_PIC32CGMAC_RX_FRAME_INFO rx_frame_state = {0,0,0};
    adbe:	2300      	movs	r3, #0
    adc0:	9301      	str	r3, [sp, #4]
    adc2:	9303      	str	r3, [sp, #12]
    uint16_t search_count = 0;
    adc4:	4698      	mov	r8, r3
    GMAC_RXFRAME_STATE frameState = GMAC_RX_NO_FRAME_STATE;
    adc6:	461d      	mov	r5, r3
                
				//clear all the descriptors before the error				
				while(nRx_buffer--)
				{                  
                    //Get Rx Packet assigned to Rx Descriptor with error
                    pRxPkt = pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[rx_index];
    adc8:	232c      	movs	r3, #44	; 0x2c
    adca:	fb03 0909 	mla	r9, r3, r9, r0
    adce:	e078      	b.n	aec2 <DRV_PIC32CGMAC_LibRxGetPacket+0x15a>
		return false; 
    add0:	2400      	movs	r4, #0
    add2:	9404      	str	r4, [sp, #16]
    add4:	e7d9      	b.n	ad8a <DRV_PIC32CGMAC_LibRxGetPacket+0x22>
                    if(GMAC_RX_SOF_BIT == ((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_status.val) & GMAC_RX_SOF_BIT))
    add6:	6859      	ldr	r1, [r3, #4]
    add8:	f411 4f80 	tst.w	r1, #16384	; 0x4000
    addc:	d108      	bne.n	adf0 <DRV_PIC32CGMAC_LibRxGetPacket+0x88>
                        rx_frame_state->buffer_count++; 
    adde:	9901      	ldr	r1, [sp, #4]
    ade0:	3101      	adds	r1, #1
    ade2:	b289      	uxth	r1, r1
    ade4:	9101      	str	r1, [sp, #4]
                        if(GMAC_RX_EOF_BIT == ((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_status.val) & GMAC_RX_EOF_BIT))
    ade6:	685b      	ldr	r3, [r3, #4]
    ade8:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    adec:	d05a      	beq.n	aea4 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
    adee:	e13d      	b.n	b06c <DRV_PIC32CGMAC_LibRxGetPacket+0x304>
                        rx_index =  fixed_mod(((rx_frame_state->startIndex) + (rx_frame_state->buffer_count) -1),nRxDscCnt);	
    adf0:	9b03      	ldr	r3, [sp, #12]
    adf2:	9a01      	ldr	r2, [sp, #4]
    adf4:	189d      	adds	r5, r3, r2
    adf6:	1e6b      	subs	r3, r5, #1
 * If both operands are non-negative then the remainder is non-negative;
 * if not, the sign of the remainder is implementation-defined 74).
 */
__STATIC_INLINE int fixed_mod(int a, int b)
{
	int rem = a % b;
    adf8:	fb93 f5f7 	sdiv	r5, r3, r7
    adfc:	fb07 3515 	mls	r5, r7, r5, r3

	while (rem < 0)
    ae00:	2d00      	cmp	r5, #0
		rem += b;
    ae02:	bfb8      	it	lt
    ae04:	19ed      	addlt	r5, r5, r7
    ae06:	b2ad      	uxth	r5, r5
                        nRx_buffer = rx_frame_state->buffer_count;
    ae08:	f8dd a004 	ldr.w	sl, [sp, #4]
    ae0c:	e001      	b.n	ae12 <DRV_PIC32CGMAC_LibRxGetPacket+0xaa>
                            GCIRC_DEC(rx_index, nRxDscCnt); 
    ae0e:	3d01      	subs	r5, #1
    ae10:	b2ad      	uxth	r5, r5
                        while(nRx_buffer--)
    ae12:	f10a 3aff 	add.w	sl, sl, #4294967295
    ae16:	fa1f fa8a 	uxth.w	sl, sl
    ae1a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    ae1e:	459a      	cmp	sl, r3
    ae20:	d025      	beq.n	ae6e <DRV_PIC32CGMAC_LibRxGetPacket+0x106>
                            pRxPkt = pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[rx_index];
    ae22:	46ab      	mov	fp, r5
    ae24:	f8d9 308c 	ldr.w	r3, [r9, #140]	; 0x8c
    ae28:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
                            (pRxPkt->ackFunc)(pRxPkt, pRxPkt->ackParam);
    ae2c:	6883      	ldr	r3, [r0, #8]
    ae2e:	68c1      	ldr	r1, [r0, #12]
    ae30:	4798      	blx	r3
                            pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[rx_index] = 0; 
    ae32:	f8d9 308c 	ldr.w	r3, [r9, #140]	; 0x8c
    ae36:	2200      	movs	r2, #0
    ae38:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
	if(pMACDrv->sGmacData._synchF != 0)
    ae3c:	6b33      	ldr	r3, [r6, #48]	; 0x30
    ae3e:	b11b      	cbz	r3, ae48 <DRV_PIC32CGMAC_LibRxGetPacket+0xe0>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
    ae40:	2105      	movs	r1, #5
    ae42:	f106 005c 	add.w	r0, r6, #92	; 0x5c
    ae46:	4798      	blx	r3
                            pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc[rx_index].rx_desc_buffaddr.val &= ~GMAC_RX_ADDRESS_MASK; 
    ae48:	f8d9 2090 	ldr.w	r2, [r9, #144]	; 0x90
    ae4c:	f852 303b 	ldr.w	r3, [r2, fp, lsl #3]
    ae50:	f003 0303 	and.w	r3, r3, #3
    ae54:	f842 303b 	str.w	r3, [r2, fp, lsl #3]
	if(pMACDrv->sGmacData._synchF != 0)
    ae58:	6b33      	ldr	r3, [r6, #48]	; 0x30
    ae5a:	b11b      	cbz	r3, ae64 <DRV_PIC32CGMAC_LibRxGetPacket+0xfc>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_LEAVE);
    ae5c:	2106      	movs	r1, #6
    ae5e:	f106 005c 	add.w	r0, r6, #92	; 0x5c
    ae62:	4798      	blx	r3
                            GCIRC_DEC(rx_index, nRxDscCnt); 
    ae64:	2d00      	cmp	r5, #0
    ae66:	d1d2      	bne.n	ae0e <DRV_PIC32CGMAC_LibRxGetPacket+0xa6>
    ae68:	1e7d      	subs	r5, r7, #1
    ae6a:	b2ad      	uxth	r5, r5
    ae6c:	e7d1      	b.n	ae12 <DRV_PIC32CGMAC_LibRxGetPacket+0xaa>
                        DRV_PIC32CGMAC_LibRxBuffersAppend(pMACDrv, queueIdx, (rx_frame_state->startIndex), (rx_frame_state->buffer_count));
    ae6e:	9b01      	ldr	r3, [sp, #4]
    ae70:	9a03      	ldr	r2, [sp, #12]
    ae72:	9902      	ldr	r1, [sp, #8]
    ae74:	4630      	mov	r0, r6
    ae76:	f008 f973 	bl	13160 <DRV_PIC32CGMAC_LibRxBuffersAppend>
                        search_count--; 
    ae7a:	f108 38ff 	add.w	r8, r8, #4294967295
    ae7e:	fa1f f888 	uxth.w	r8, r8
                        GCIRC_DEC(nRxDescIndex, nRxDscCnt); 
    ae82:	b91c      	cbnz	r4, ae8c <DRV_PIC32CGMAC_LibRxGetPacket+0x124>
    ae84:	1e7c      	subs	r4, r7, #1
    ae86:	b2a4      	uxth	r4, r4
                        frameState = GMAC_RX_NO_FRAME_STATE;
    ae88:	2500      	movs	r5, #0
    ae8a:	e00b      	b.n	aea4 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
                        GCIRC_DEC(nRxDescIndex, nRxDscCnt); 
    ae8c:	3c01      	subs	r4, #1
    ae8e:	b2a4      	uxth	r4, r4
                        frameState = GMAC_RX_NO_FRAME_STATE;
    ae90:	2500      	movs	r5, #0
    ae92:	e007      	b.n	aea4 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
                DRV_PIC32CGMAC_LibRxBuffersAppend(pMACDrv, queueIdx, nRxDescIndex, 1);
    ae94:	2301      	movs	r3, #1
    ae96:	4622      	mov	r2, r4
    ae98:	9902      	ldr	r1, [sp, #8]
    ae9a:	4630      	mov	r0, r6
    ae9c:	f008 f960 	bl	13160 <DRV_PIC32CGMAC_LibRxBuffersAppend>
    aea0:	e000      	b.n	aea4 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
			if(frameState == GMAC_RX_SOF_DETECTED_STATE)
    aea2:	bb6d      	cbnz	r5, af00 <DRV_PIC32CGMAC_LibRxGetPacket+0x198>
				GCIRC_DEC(nRxDescIndex, nRxDscCnt); 		
			}
		}
		
        // increment rx index and continue search
		GCIRC_INC(nRxDescIndex, nRxDscCnt);
    aea4:	3401      	adds	r4, #1
    aea6:	b2a4      	uxth	r4, r4
    aea8:	42a7      	cmp	r7, r4
    aeaa:	bf98      	it	ls
    aeac:	2400      	movls	r4, #0
        // when search count exceeded number of rx descriptors, exit the search
		if ((search_count++) >  nRxDscCnt)
    aeae:	f108 0301 	add.w	r3, r8, #1
    aeb2:	b29b      	uxth	r3, r3
    aeb4:	4547      	cmp	r7, r8
    aeb6:	f0c0 80c7 	bcc.w	b048 <DRV_PIC32CGMAC_LibRxGetPacket+0x2e0>
	while ( search_count < nRxDscCnt)
    aeba:	429f      	cmp	r7, r3
    aebc:	f240 80c4 	bls.w	b048 <DRV_PIC32CGMAC_LibRxGetPacket+0x2e0>
		if ((search_count++) >  nRxDscCnt)
    aec0:	4698      	mov	r8, r3
		if ((((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_buffaddr.val) & GMAC_RX_OWNERSHIP_BIT) == GMAC_RX_OWNERSHIP_BIT))
    aec2:	00e2      	lsls	r2, r4, #3
    aec4:	9805      	ldr	r0, [sp, #20]
    aec6:	1883      	adds	r3, r0, r2
    aec8:	f850 1034 	ldr.w	r1, [r0, r4, lsl #3]
    aecc:	f011 0f01 	tst.w	r1, #1
    aed0:	d0e7      	beq.n	aea2 <DRV_PIC32CGMAC_LibRxGetPacket+0x13a>
            if(((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_buffaddr.val) & GMAC_RX_ADDRESS_MASK) != (uint32_t)0)
    aed2:	f850 1034 	ldr.w	r1, [r0, r4, lsl #3]
    aed6:	f031 0103 	bics.w	r1, r1, #3
    aeda:	d0db      	beq.n	ae94 <DRV_PIC32CGMAC_LibRxGetPacket+0x12c>
                if(frameState == GMAC_RX_NO_FRAME_STATE)
    aedc:	2d00      	cmp	r5, #0
    aede:	f47f af7a 	bne.w	add6 <DRV_PIC32CGMAC_LibRxGetPacket+0x6e>
                    if(GMAC_RX_SOF_BIT == ((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_status.val) & GMAC_RX_SOF_BIT))
    aee2:	6859      	ldr	r1, [r3, #4]
    aee4:	f411 4f80 	tst.w	r1, #16384	; 0x4000
    aee8:	d0dc      	beq.n	aea4 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
                        if(GMAC_RX_EOF_BIT == ((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_status.val) & GMAC_RX_EOF_BIT))
    aeea:	685b      	ldr	r3, [r3, #4]
    aeec:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    aef0:	f040 80b9 	bne.w	b066 <DRV_PIC32CGMAC_LibRxGetPacket+0x2fe>
    aef4:	9403      	str	r4, [sp, #12]
                        rx_frame_state->buffer_count = 1; 
    aef6:	2301      	movs	r3, #1
    aef8:	9301      	str	r3, [sp, #4]
                        search_count = 1;  
    aefa:	4698      	mov	r8, r3
                        frameState = GMAC_RX_SOF_DETECTED_STATE;
    aefc:	461d      	mov	r5, r3
    aefe:	e7d1      	b.n	aea4 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
				rx_index = fixed_mod(((rx_frame_state->startIndex) + (rx_frame_state->buffer_count) -1),nRxDscCnt);	
    af00:	9b03      	ldr	r3, [sp, #12]
    af02:	9a01      	ldr	r2, [sp, #4]
    af04:	189d      	adds	r5, r3, r2
    af06:	1e6b      	subs	r3, r5, #1
	int rem = a % b;
    af08:	fb93 f5f7 	sdiv	r5, r3, r7
    af0c:	fb07 3515 	mls	r5, r7, r5, r3
	while (rem < 0)
    af10:	2d00      	cmp	r5, #0
		rem += b;
    af12:	bfb8      	it	lt
    af14:	19ed      	addlt	r5, r5, r7
    af16:	b2ad      	uxth	r5, r5
				nRx_buffer = rx_frame_state->buffer_count;
    af18:	f8dd a004 	ldr.w	sl, [sp, #4]
    af1c:	e001      	b.n	af22 <DRV_PIC32CGMAC_LibRxGetPacket+0x1ba>
                    GCIRC_DEC(rx_index, nRxDscCnt);
    af1e:	3d01      	subs	r5, #1
    af20:	b2ad      	uxth	r5, r5
				while(nRx_buffer--)
    af22:	f10a 3aff 	add.w	sl, sl, #4294967295
    af26:	fa1f fa8a 	uxth.w	sl, sl
    af2a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    af2e:	459a      	cmp	sl, r3
    af30:	d025      	beq.n	af7e <DRV_PIC32CGMAC_LibRxGetPacket+0x216>
                    pRxPkt = pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[rx_index];
    af32:	46ab      	mov	fp, r5
    af34:	f8d9 308c 	ldr.w	r3, [r9, #140]	; 0x8c
    af38:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
                    (pRxPkt->ackFunc)(pRxPkt, pRxPkt->ackParam);	
    af3c:	6883      	ldr	r3, [r0, #8]
    af3e:	68c1      	ldr	r1, [r0, #12]
    af40:	4798      	blx	r3
					pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[rx_index] = 0;
    af42:	f8d9 308c 	ldr.w	r3, [r9, #140]	; 0x8c
    af46:	2200      	movs	r2, #0
    af48:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
	if(pMACDrv->sGmacData._synchF != 0)
    af4c:	6b33      	ldr	r3, [r6, #48]	; 0x30
    af4e:	b11b      	cbz	r3, af58 <DRV_PIC32CGMAC_LibRxGetPacket+0x1f0>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
    af50:	2105      	movs	r1, #5
    af52:	f106 005c 	add.w	r0, r6, #92	; 0x5c
    af56:	4798      	blx	r3
					pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc[rx_index].rx_desc_buffaddr.val &= ~GMAC_RX_ADDRESS_MASK; 
    af58:	f8d9 2090 	ldr.w	r2, [r9, #144]	; 0x90
    af5c:	f852 303b 	ldr.w	r3, [r2, fp, lsl #3]
    af60:	f003 0303 	and.w	r3, r3, #3
    af64:	f842 303b 	str.w	r3, [r2, fp, lsl #3]
	if(pMACDrv->sGmacData._synchF != 0)
    af68:	6b33      	ldr	r3, [r6, #48]	; 0x30
    af6a:	b11b      	cbz	r3, af74 <DRV_PIC32CGMAC_LibRxGetPacket+0x20c>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_LEAVE);
    af6c:	2106      	movs	r1, #6
    af6e:	f106 005c 	add.w	r0, r6, #92	; 0x5c
    af72:	4798      	blx	r3
                    GCIRC_DEC(rx_index, nRxDscCnt);
    af74:	2d00      	cmp	r5, #0
    af76:	d1d2      	bne.n	af1e <DRV_PIC32CGMAC_LibRxGetPacket+0x1b6>
    af78:	1e7d      	subs	r5, r7, #1
    af7a:	b2ad      	uxth	r5, r5
    af7c:	e7d1      	b.n	af22 <DRV_PIC32CGMAC_LibRxGetPacket+0x1ba>
				DRV_PIC32CGMAC_LibRxBuffersAppend(pMACDrv, queueIdx, (rx_frame_state->startIndex), (rx_frame_state->buffer_count));
    af7e:	9b01      	ldr	r3, [sp, #4]
    af80:	9a03      	ldr	r2, [sp, #12]
    af82:	9902      	ldr	r1, [sp, #8]
    af84:	4630      	mov	r0, r6
    af86:	f008 f8eb 	bl	13160 <DRV_PIC32CGMAC_LibRxBuffersAppend>
                search_count--; 
    af8a:	f108 38ff 	add.w	r8, r8, #4294967295
    af8e:	fa1f f888 	uxth.w	r8, r8
				GCIRC_DEC(nRxDescIndex, nRxDscCnt); 		
    af92:	b91c      	cbnz	r4, af9c <DRV_PIC32CGMAC_LibRxGetPacket+0x234>
    af94:	1e7c      	subs	r4, r7, #1
    af96:	b2a4      	uxth	r4, r4
				frameState = GMAC_RX_NO_FRAME_STATE;
    af98:	2500      	movs	r5, #0
    af9a:	e783      	b.n	aea4 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
				GCIRC_DEC(nRxDescIndex, nRxDscCnt); 		
    af9c:	3c01      	subs	r4, #1
    af9e:	b2a4      	uxth	r4, r4
				frameState = GMAC_RX_NO_FRAME_STATE;
    afa0:	2500      	movs	r5, #0
    afa2:	e77f      	b.n	aea4 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
	pDseg = (*pRxPkt)->pDSeg; 
	
	if(nRx_buffer)
    {
		//process all the packet buffers
		while(nRx_buffer--) 
    afa4:	3d01      	subs	r5, #1
    afa6:	b2ad      	uxth	r5, r5
    afa8:	f64f 73ff 	movw	r3, #65535	; 0xffff
    afac:	429d      	cmp	r5, r3
    afae:	d03d      	beq.n	b02c <DRV_PIC32CGMAC_LibRxGetPacket+0x2c4>
		{
            // Segment length based on received frame length and Rx buffer size
			(*pRxPkt)->pDSeg->segLen = (frameSize >= gmac_queue_config.rxBufferSize) ?
    afb0:	f8da 3000 	ldr.w	r3, [sl]
    afb4:	691b      	ldr	r3, [r3, #16]
												gmac_queue_config.rxBufferSize :frameSize;
    afb6:	4642      	mov	r2, r8
    afb8:	45b8      	cmp	r8, r7
    afba:	bf28      	it	cs
    afbc:	463a      	movcs	r2, r7
			(*pRxPkt)->pDSeg->segLen = (frameSize >= gmac_queue_config.rxBufferSize) ?
    afbe:	819a      	strh	r2, [r3, #12]
													
			(*pRxPkt)->pDSeg->segSize = gmac_queue_config.rxBufferSize;
    afc0:	f8da 3000 	ldr.w	r3, [sl]
    afc4:	691b      	ldr	r3, [r3, #16]
    afc6:	f8a3 800e 	strh.w	r8, [r3, #14]
			
			// RX frame bigger than GMAC RX buffer?
			if(frameSize >= gmac_queue_config.rxBufferSize)
    afca:	45b8      	cmp	r8, r7
            {
                //more Rx buffers used for Rx packet
				frameSize = frameSize - gmac_queue_config.rxBufferSize;
    afcc:	bf94      	ite	ls
    afce:	eba7 0708 	subls.w	r7, r7, r8
            }
			else
            {   // last Rx buffer of Rx Packet
				frameSize = 0;		
    afd2:	2700      	movhi	r7, #0
            }
			
			//release the rx packets from GMAC queue
			gmac_queue.pRxPckt[rx_index] = 0; 
    afd4:	9405      	str	r4, [sp, #20]
    afd6:	2300      	movs	r3, #0
    afd8:	f849 3024 	str.w	r3, [r9, r4, lsl #2]
	if(pMACDrv->sGmacData._synchF != 0)
    afdc:	6b33      	ldr	r3, [r6, #48]	; 0x30
    afde:	b113      	cbz	r3, afe6 <DRV_PIC32CGMAC_LibRxGetPacket+0x27e>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
    afe0:	2105      	movs	r1, #5
    afe2:	9807      	ldr	r0, [sp, #28]
    afe4:	4798      	blx	r3
			
			_DRV_GMAC_RxLock(pMACDrv);
			//clear the buffer address bit-fields
			gmac_queue.pRxDesc[rx_index].rx_desc_buffaddr.val &= ~GMAC_RX_ADDRESS_MASK; 
    afe6:	9a05      	ldr	r2, [sp, #20]
    afe8:	f85b 3032 	ldr.w	r3, [fp, r2, lsl #3]
    afec:	f003 0303 	and.w	r3, r3, #3
    aff0:	f84b 3032 	str.w	r3, [fp, r2, lsl #3]
	if(pMACDrv->sGmacData._synchF != 0)
    aff4:	6b33      	ldr	r3, [r6, #48]	; 0x30
    aff6:	b113      	cbz	r3, affe <DRV_PIC32CGMAC_LibRxGetPacket+0x296>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_LEAVE);
    aff8:	2106      	movs	r1, #6
    affa:	9807      	ldr	r0, [sp, #28]
    affc:	4798      	blx	r3
			_DRV_GMAC_RxUnlock(pMACDrv);

			//more Rx buffers needed for Rx packet
			if(frameSize)
    affe:	2f00      	cmp	r7, #0
    b000:	d0d0      	beq.n	afa4 <DRV_PIC32CGMAC_LibRxGetPacket+0x23c>
			{
				GCIRC_INC(rx_index, gmac_queue_config.nRxDescCnt);
    b002:	3401      	adds	r4, #1
    b004:	b2a4      	uxth	r4, r4
    b006:	9b08      	ldr	r3, [sp, #32]
    b008:	42a3      	cmp	r3, r4
    b00a:	bf98      	it	ls
    b00c:	2400      	movls	r4, #0
				
				(*pRxPkt)->pDSeg->next = gmac_queue.pRxPckt[rx_index]->pDSeg;
    b00e:	f8da 3000 	ldr.w	r3, [sl]
    b012:	691b      	ldr	r3, [r3, #16]
    b014:	f859 2024 	ldr.w	r2, [r9, r4, lsl #2]
    b018:	6912      	ldr	r2, [r2, #16]
    b01a:	601a      	str	r2, [r3, #0]
				(*pRxPkt)->pDSeg = (*pRxPkt)->pDSeg->next;	
    b01c:	f8da 3000 	ldr.w	r3, [sl]
    b020:	691a      	ldr	r2, [r3, #16]
    b022:	6812      	ldr	r2, [r2, #0]
    b024:	611a      	str	r2, [r3, #16]
    b026:	e7bd      	b.n	afa4 <DRV_PIC32CGMAC_LibRxGetPacket+0x23c>
    b028:	42000800 	.word	0x42000800
			}			
			
		}
			
		// restore to first data segment
		(*pRxPkt)->pDSeg = (TCPIP_MAC_DATA_SEGMENT*)pDseg; 
    b02c:	9b06      	ldr	r3, [sp, #24]
    b02e:	681b      	ldr	r3, [r3, #0]
    b030:	9a09      	ldr	r2, [sp, #36]	; 0x24
    b032:	611a      	str	r2, [r3, #16]
		
		//allocate new packets in place of used buffers
		DRV_PIC32CGMAC_LibRxBuffersAppend(pMACDrv, queueIdx, rx_frame_state->startIndex, rx_frame_state->buffer_count); 
    b034:	9b01      	ldr	r3, [sp, #4]
    b036:	9a03      	ldr	r2, [sp, #12]
    b038:	9902      	ldr	r1, [sp, #8]
    b03a:	4630      	mov	r0, r6
    b03c:	f008 f890 	bl	13160 <DRV_PIC32CGMAC_LibRxBuffersAppend>
		res = DRV_PIC32CGMAC_RES_OK;
    b040:	2000      	movs	r0, #0
    b042:	e008      	b.n	b056 <DRV_PIC32CGMAC_LibRxGetPacket+0x2ee>
		return res;
    b044:	2001      	movs	r0, #1
    b046:	e00b      	b.n	b060 <DRV_PIC32CGMAC_LibRxGetPacket+0x2f8>
	pMACDrv->sGmacData.gmac_queue[queueIdx].nRxDescIndex = nRxDescIndex;	
    b048:	202c      	movs	r0, #44	; 0x2c
    b04a:	9b02      	ldr	r3, [sp, #8]
    b04c:	fb00 6603 	mla	r6, r0, r3, r6
    b050:	f8a6 40b0 	strh.w	r4, [r6, #176]	; 0xb0
    DRV_PIC32CGMAC_RESULT   res = DRV_PIC32CGMAC_RES_NO_PACKET;
    b054:	2001      	movs	r0, #1
    if(bna_flag == true)
    b056:	9b04      	ldr	r3, [sp, #16]
    b058:	b113      	cbz	r3, b060 <DRV_PIC32CGMAC_LibRxGetPacket+0x2f8>
        GMAC_REGS->GMAC_RSR = GMAC_RSR_BNA_Msk ; 
    b05a:	4b22      	ldr	r3, [pc, #136]	; (b0e4 <DRV_PIC32CGMAC_LibRxGetPacket+0x37c>)
    b05c:	2201      	movs	r2, #1
    b05e:	621a      	str	r2, [r3, #32]
} //DRV_PIC32CGMAC_LibRxGetPacket
    b060:	b00b      	add	sp, #44	; 0x2c
    b062:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                        if(GMAC_RX_EOF_BIT == ((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_status.val) & GMAC_RX_EOF_BIT))
    b066:	9403      	str	r4, [sp, #12]
                        rx_frame_state->buffer_count = 1; 
    b068:	2301      	movs	r3, #1
    b06a:	9301      	str	r3, [sp, #4]
	pMACDrv->sGmacData.gmac_queue[queueIdx].nRxDescIndex = nRxDescIndex;	
    b06c:	232c      	movs	r3, #44	; 0x2c
    b06e:	9d02      	ldr	r5, [sp, #8]
    b070:	fb03 6105 	mla	r1, r3, r5, r6
    b074:	f8a1 40b0 	strh.w	r4, [r1, #176]	; 0xb0
		*pRxStat = (pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc[rx_frame_state.endIndex].rx_desc_status);		
    b078:	f8d1 0090 	ldr.w	r0, [r1, #144]	; 0x90
    b07c:	4410      	add	r0, r2
    b07e:	6840      	ldr	r0, [r0, #4]
    b080:	9c08      	ldr	r4, [sp, #32]
    b082:	6020      	str	r0, [r4, #0]
		*pnBuffs = rx_frame_state.buffer_count;		
    b084:	9807      	ldr	r0, [sp, #28]
    b086:	9c01      	ldr	r4, [sp, #4]
    b088:	6004      	str	r4, [r0, #0]
    DRV_PIC32CGMAC_HW_RXDCPT *pRxDesc = pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc;
    b08a:	f8d1 1090 	ldr.w	r1, [r1, #144]	; 0x90
    DRV_GMAC_QUEUE gmac_queue = pMACDrv->sGmacData.gmac_queue[queueIdx];
    b08e:	fb03 f305 	mul.w	r3, r3, r5
    b092:	338c      	adds	r3, #140	; 0x8c
    b094:	18f0      	adds	r0, r6, r3
    b096:	f856 a003 	ldr.w	sl, [r6, r3]
    b09a:	f8d0 b004 	ldr.w	fp, [r0, #4]
    TCPIP_MODULE_GMAC_QUEUE_CONFIG gmac_queue_config = pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx];
    b09e:	eb05 03c5 	add.w	r3, r5, r5, lsl #3
    b0a2:	005b      	lsls	r3, r3, #1
    b0a4:	33be      	adds	r3, #190	; 0xbe
    b0a6:	18f0      	adds	r0, r6, r3
    b0a8:	5af3      	ldrh	r3, [r6, r3]
    b0aa:	9308      	str	r3, [sp, #32]
    b0ac:	f8b0 800e 	ldrh.w	r8, [r0, #14]
	*pRxPkt = gmac_queue.pRxPckt[rx_frame_state->startIndex]; 
    b0b0:	9b03      	ldr	r3, [sp, #12]
    b0b2:	f85a 3023 	ldr.w	r3, [sl, r3, lsl #2]
    b0b6:	9806      	ldr	r0, [sp, #24]
    b0b8:	6003      	str	r3, [r0, #0]
	frameSize = (pRxDesc[rx_frame_state->endIndex].rx_desc_status.val & GMAC_LENGTH_FRAME); 
    b0ba:	440a      	add	r2, r1
    b0bc:	6857      	ldr	r7, [r2, #4]
	if(nRx_buffer)
    b0be:	b90c      	cbnz	r4, b0c4 <DRV_PIC32CGMAC_LibRxGetPacket+0x35c>
	}
	else
    {
        res = DRV_PIC32CGMAC_RES_NO_PACKET;
    b0c0:	2001      	movs	r0, #1
    b0c2:	e7c8      	b.n	b056 <DRV_PIC32CGMAC_LibRxGetPacket+0x2ee>
	frameSize = (pRxDesc[rx_frame_state->endIndex].rx_desc_status.val & GMAC_LENGTH_FRAME); 
    b0c4:	f3c7 070d 	ubfx	r7, r7, #0, #14
	pDseg = (*pRxPkt)->pDSeg; 
    b0c8:	691b      	ldr	r3, [r3, #16]
    b0ca:	9309      	str	r3, [sp, #36]	; 0x24
		while(nRx_buffer--) 
    b0cc:	9b01      	ldr	r3, [sp, #4]
    b0ce:	1e5d      	subs	r5, r3, #1
    b0d0:	b2ad      	uxth	r5, r5
    b0d2:	9c03      	ldr	r4, [sp, #12]
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
    b0d4:	f106 035c 	add.w	r3, r6, #92	; 0x5c
    b0d8:	9307      	str	r3, [sp, #28]
    b0da:	46d1      	mov	r9, sl
    b0dc:	f8dd a018 	ldr.w	sl, [sp, #24]
    b0e0:	e766      	b.n	afb0 <DRV_PIC32CGMAC_LibRxGetPacket+0x248>
    b0e2:	bf00      	nop
    b0e4:	42000800 	.word	0x42000800

Disassembly of section .text%203:

0000b0e8 <__aeabi_drsub>:
    b0e8:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
    b0ec:	e002      	b.n	b0f4 <__adddf3>
    b0ee:	bf00      	nop

0000b0f0 <__aeabi_dsub>:
    b0f0:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0000b0f4 <__adddf3>:
    b0f4:	b530      	push	{r4, r5, lr}
    b0f6:	ea4f 0441 	mov.w	r4, r1, lsl #1
    b0fa:	ea4f 0543 	mov.w	r5, r3, lsl #1
    b0fe:	ea94 0f05 	teq	r4, r5
    b102:	bf08      	it	eq
    b104:	ea90 0f02 	teqeq	r0, r2
    b108:	bf1f      	itttt	ne
    b10a:	ea54 0c00 	orrsne.w	ip, r4, r0
    b10e:	ea55 0c02 	orrsne.w	ip, r5, r2
    b112:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
    b116:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    b11a:	f000 80e2 	beq.w	b2e2 <__adddf3+0x1ee>
    b11e:	ea4f 5454 	mov.w	r4, r4, lsr #21
    b122:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
    b126:	bfb8      	it	lt
    b128:	426d      	neglt	r5, r5
    b12a:	dd0c      	ble.n	b146 <__adddf3+0x52>
    b12c:	442c      	add	r4, r5
    b12e:	ea80 0202 	eor.w	r2, r0, r2
    b132:	ea81 0303 	eor.w	r3, r1, r3
    b136:	ea82 0000 	eor.w	r0, r2, r0
    b13a:	ea83 0101 	eor.w	r1, r3, r1
    b13e:	ea80 0202 	eor.w	r2, r0, r2
    b142:	ea81 0303 	eor.w	r3, r1, r3
    b146:	2d36      	cmp	r5, #54	; 0x36
    b148:	bf88      	it	hi
    b14a:	bd30      	pophi	{r4, r5, pc}
    b14c:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    b150:	ea4f 3101 	mov.w	r1, r1, lsl #12
    b154:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
    b158:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
    b15c:	d002      	beq.n	b164 <__adddf3+0x70>
    b15e:	4240      	negs	r0, r0
    b160:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    b164:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
    b168:	ea4f 3303 	mov.w	r3, r3, lsl #12
    b16c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
    b170:	d002      	beq.n	b178 <__adddf3+0x84>
    b172:	4252      	negs	r2, r2
    b174:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    b178:	ea94 0f05 	teq	r4, r5
    b17c:	f000 80a7 	beq.w	b2ce <__adddf3+0x1da>
    b180:	f1a4 0401 	sub.w	r4, r4, #1
    b184:	f1d5 0e20 	rsbs	lr, r5, #32
    b188:	db0d      	blt.n	b1a6 <__adddf3+0xb2>
    b18a:	fa02 fc0e 	lsl.w	ip, r2, lr
    b18e:	fa22 f205 	lsr.w	r2, r2, r5
    b192:	1880      	adds	r0, r0, r2
    b194:	f141 0100 	adc.w	r1, r1, #0
    b198:	fa03 f20e 	lsl.w	r2, r3, lr
    b19c:	1880      	adds	r0, r0, r2
    b19e:	fa43 f305 	asr.w	r3, r3, r5
    b1a2:	4159      	adcs	r1, r3
    b1a4:	e00e      	b.n	b1c4 <__adddf3+0xd0>
    b1a6:	f1a5 0520 	sub.w	r5, r5, #32
    b1aa:	f10e 0e20 	add.w	lr, lr, #32
    b1ae:	2a01      	cmp	r2, #1
    b1b0:	fa03 fc0e 	lsl.w	ip, r3, lr
    b1b4:	bf28      	it	cs
    b1b6:	f04c 0c02 	orrcs.w	ip, ip, #2
    b1ba:	fa43 f305 	asr.w	r3, r3, r5
    b1be:	18c0      	adds	r0, r0, r3
    b1c0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
    b1c4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    b1c8:	d507      	bpl.n	b1da <__adddf3+0xe6>
    b1ca:	f04f 0e00 	mov.w	lr, #0
    b1ce:	f1dc 0c00 	rsbs	ip, ip, #0
    b1d2:	eb7e 0000 	sbcs.w	r0, lr, r0
    b1d6:	eb6e 0101 	sbc.w	r1, lr, r1
    b1da:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    b1de:	d31b      	bcc.n	b218 <__adddf3+0x124>
    b1e0:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    b1e4:	d30c      	bcc.n	b200 <__adddf3+0x10c>
    b1e6:	0849      	lsrs	r1, r1, #1
    b1e8:	ea5f 0030 	movs.w	r0, r0, rrx
    b1ec:	ea4f 0c3c 	mov.w	ip, ip, rrx
    b1f0:	f104 0401 	add.w	r4, r4, #1
    b1f4:	ea4f 5244 	mov.w	r2, r4, lsl #21
    b1f8:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
    b1fc:	f080 809a 	bcs.w	b334 <__adddf3+0x240>
    b200:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    b204:	bf08      	it	eq
    b206:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    b20a:	f150 0000 	adcs.w	r0, r0, #0
    b20e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    b212:	ea41 0105 	orr.w	r1, r1, r5
    b216:	bd30      	pop	{r4, r5, pc}
    b218:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
    b21c:	4140      	adcs	r0, r0
    b21e:	eb41 0101 	adc.w	r1, r1, r1
    b222:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    b226:	f1a4 0401 	sub.w	r4, r4, #1
    b22a:	d1e9      	bne.n	b200 <__adddf3+0x10c>
    b22c:	f091 0f00 	teq	r1, #0
    b230:	bf04      	itt	eq
    b232:	4601      	moveq	r1, r0
    b234:	2000      	moveq	r0, #0
    b236:	fab1 f381 	clz	r3, r1
    b23a:	bf08      	it	eq
    b23c:	3320      	addeq	r3, #32
    b23e:	f1a3 030b 	sub.w	r3, r3, #11
    b242:	f1b3 0220 	subs.w	r2, r3, #32
    b246:	da0c      	bge.n	b262 <__adddf3+0x16e>
    b248:	320c      	adds	r2, #12
    b24a:	dd08      	ble.n	b25e <__adddf3+0x16a>
    b24c:	f102 0c14 	add.w	ip, r2, #20
    b250:	f1c2 020c 	rsb	r2, r2, #12
    b254:	fa01 f00c 	lsl.w	r0, r1, ip
    b258:	fa21 f102 	lsr.w	r1, r1, r2
    b25c:	e00c      	b.n	b278 <__adddf3+0x184>
    b25e:	f102 0214 	add.w	r2, r2, #20
    b262:	bfd8      	it	le
    b264:	f1c2 0c20 	rsble	ip, r2, #32
    b268:	fa01 f102 	lsl.w	r1, r1, r2
    b26c:	fa20 fc0c 	lsr.w	ip, r0, ip
    b270:	bfdc      	itt	le
    b272:	ea41 010c 	orrle.w	r1, r1, ip
    b276:	4090      	lslle	r0, r2
    b278:	1ae4      	subs	r4, r4, r3
    b27a:	bfa2      	ittt	ge
    b27c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
    b280:	4329      	orrge	r1, r5
    b282:	bd30      	popge	{r4, r5, pc}
    b284:	ea6f 0404 	mvn.w	r4, r4
    b288:	3c1f      	subs	r4, #31
    b28a:	da1c      	bge.n	b2c6 <__adddf3+0x1d2>
    b28c:	340c      	adds	r4, #12
    b28e:	dc0e      	bgt.n	b2ae <__adddf3+0x1ba>
    b290:	f104 0414 	add.w	r4, r4, #20
    b294:	f1c4 0220 	rsb	r2, r4, #32
    b298:	fa20 f004 	lsr.w	r0, r0, r4
    b29c:	fa01 f302 	lsl.w	r3, r1, r2
    b2a0:	ea40 0003 	orr.w	r0, r0, r3
    b2a4:	fa21 f304 	lsr.w	r3, r1, r4
    b2a8:	ea45 0103 	orr.w	r1, r5, r3
    b2ac:	bd30      	pop	{r4, r5, pc}
    b2ae:	f1c4 040c 	rsb	r4, r4, #12
    b2b2:	f1c4 0220 	rsb	r2, r4, #32
    b2b6:	fa20 f002 	lsr.w	r0, r0, r2
    b2ba:	fa01 f304 	lsl.w	r3, r1, r4
    b2be:	ea40 0003 	orr.w	r0, r0, r3
    b2c2:	4629      	mov	r1, r5
    b2c4:	bd30      	pop	{r4, r5, pc}
    b2c6:	fa21 f004 	lsr.w	r0, r1, r4
    b2ca:	4629      	mov	r1, r5
    b2cc:	bd30      	pop	{r4, r5, pc}
    b2ce:	f094 0f00 	teq	r4, #0
    b2d2:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
    b2d6:	bf06      	itte	eq
    b2d8:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
    b2dc:	3401      	addeq	r4, #1
    b2de:	3d01      	subne	r5, #1
    b2e0:	e74e      	b.n	b180 <__adddf3+0x8c>
    b2e2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    b2e6:	bf18      	it	ne
    b2e8:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    b2ec:	d029      	beq.n	b342 <__adddf3+0x24e>
    b2ee:	ea94 0f05 	teq	r4, r5
    b2f2:	bf08      	it	eq
    b2f4:	ea90 0f02 	teqeq	r0, r2
    b2f8:	d005      	beq.n	b306 <__adddf3+0x212>
    b2fa:	ea54 0c00 	orrs.w	ip, r4, r0
    b2fe:	bf04      	itt	eq
    b300:	4619      	moveq	r1, r3
    b302:	4610      	moveq	r0, r2
    b304:	bd30      	pop	{r4, r5, pc}
    b306:	ea91 0f03 	teq	r1, r3
    b30a:	bf1e      	ittt	ne
    b30c:	2100      	movne	r1, #0
    b30e:	2000      	movne	r0, #0
    b310:	bd30      	popne	{r4, r5, pc}
    b312:	ea5f 5c54 	movs.w	ip, r4, lsr #21
    b316:	d105      	bne.n	b324 <__adddf3+0x230>
    b318:	0040      	lsls	r0, r0, #1
    b31a:	4149      	adcs	r1, r1
    b31c:	bf28      	it	cs
    b31e:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
    b322:	bd30      	pop	{r4, r5, pc}
    b324:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
    b328:	bf3c      	itt	cc
    b32a:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
    b32e:	bd30      	popcc	{r4, r5, pc}
    b330:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    b334:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
    b338:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    b33c:	f04f 0000 	mov.w	r0, #0
    b340:	bd30      	pop	{r4, r5, pc}
    b342:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    b346:	bf1a      	itte	ne
    b348:	4619      	movne	r1, r3
    b34a:	4610      	movne	r0, r2
    b34c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
    b350:	bf1c      	itt	ne
    b352:	460b      	movne	r3, r1
    b354:	4602      	movne	r2, r0
    b356:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    b35a:	bf06      	itte	eq
    b35c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
    b360:	ea91 0f03 	teqeq	r1, r3
    b364:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
    b368:	bd30      	pop	{r4, r5, pc}
    b36a:	bf00      	nop

0000b36c <__aeabi_ui2d>:
    b36c:	f090 0f00 	teq	r0, #0
    b370:	bf04      	itt	eq
    b372:	2100      	moveq	r1, #0
    b374:	4770      	bxeq	lr
    b376:	b530      	push	{r4, r5, lr}
    b378:	f44f 6480 	mov.w	r4, #1024	; 0x400
    b37c:	f104 0432 	add.w	r4, r4, #50	; 0x32
    b380:	f04f 0500 	mov.w	r5, #0
    b384:	f04f 0100 	mov.w	r1, #0
    b388:	e750      	b.n	b22c <__adddf3+0x138>
    b38a:	bf00      	nop

0000b38c <__aeabi_i2d>:
    b38c:	f090 0f00 	teq	r0, #0
    b390:	bf04      	itt	eq
    b392:	2100      	moveq	r1, #0
    b394:	4770      	bxeq	lr
    b396:	b530      	push	{r4, r5, lr}
    b398:	f44f 6480 	mov.w	r4, #1024	; 0x400
    b39c:	f104 0432 	add.w	r4, r4, #50	; 0x32
    b3a0:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
    b3a4:	bf48      	it	mi
    b3a6:	4240      	negmi	r0, r0
    b3a8:	f04f 0100 	mov.w	r1, #0
    b3ac:	e73e      	b.n	b22c <__adddf3+0x138>
    b3ae:	bf00      	nop

0000b3b0 <__aeabi_f2d>:
    b3b0:	0042      	lsls	r2, r0, #1
    b3b2:	ea4f 01e2 	mov.w	r1, r2, asr #3
    b3b6:	ea4f 0131 	mov.w	r1, r1, rrx
    b3ba:	ea4f 7002 	mov.w	r0, r2, lsl #28
    b3be:	bf1f      	itttt	ne
    b3c0:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
    b3c4:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    b3c8:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
    b3cc:	4770      	bxne	lr
    b3ce:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
    b3d2:	bf08      	it	eq
    b3d4:	4770      	bxeq	lr
    b3d6:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
    b3da:	bf04      	itt	eq
    b3dc:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
    b3e0:	4770      	bxeq	lr
    b3e2:	b530      	push	{r4, r5, lr}
    b3e4:	f44f 7460 	mov.w	r4, #896	; 0x380
    b3e8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    b3ec:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    b3f0:	e71c      	b.n	b22c <__adddf3+0x138>
    b3f2:	bf00      	nop

0000b3f4 <__aeabi_ul2d>:
    b3f4:	ea50 0201 	orrs.w	r2, r0, r1
    b3f8:	bf08      	it	eq
    b3fa:	4770      	bxeq	lr
    b3fc:	b530      	push	{r4, r5, lr}
    b3fe:	f04f 0500 	mov.w	r5, #0
    b402:	e00a      	b.n	b41a <__aeabi_l2d+0x16>

0000b404 <__aeabi_l2d>:
    b404:	ea50 0201 	orrs.w	r2, r0, r1
    b408:	bf08      	it	eq
    b40a:	4770      	bxeq	lr
    b40c:	b530      	push	{r4, r5, lr}
    b40e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
    b412:	d502      	bpl.n	b41a <__aeabi_l2d+0x16>
    b414:	4240      	negs	r0, r0
    b416:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    b41a:	f44f 6480 	mov.w	r4, #1024	; 0x400
    b41e:	f104 0432 	add.w	r4, r4, #50	; 0x32
    b422:	ea5f 5c91 	movs.w	ip, r1, lsr #22
    b426:	f43f aed8 	beq.w	b1da <__adddf3+0xe6>
    b42a:	f04f 0203 	mov.w	r2, #3
    b42e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    b432:	bf18      	it	ne
    b434:	3203      	addne	r2, #3
    b436:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    b43a:	bf18      	it	ne
    b43c:	3203      	addne	r2, #3
    b43e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
    b442:	f1c2 0320 	rsb	r3, r2, #32
    b446:	fa00 fc03 	lsl.w	ip, r0, r3
    b44a:	fa20 f002 	lsr.w	r0, r0, r2
    b44e:	fa01 fe03 	lsl.w	lr, r1, r3
    b452:	ea40 000e 	orr.w	r0, r0, lr
    b456:	fa21 f102 	lsr.w	r1, r1, r2
    b45a:	4414      	add	r4, r2
    b45c:	e6bd      	b.n	b1da <__adddf3+0xe6>
    b45e:	bf00      	nop

Disassembly of section .text.TCPIP_Helper_StringToIPv6Address%204:

0000b460 <TCPIP_Helper_StringToIPv6Address>:
  Return Values:
  	true - an IP address was successfully decoded
  	false - no IP address could be found, or the format was incorrect
  ***************************************************************************/
bool TCPIP_Helper_StringToIPv6Address(const char * addStr, IPV6_ADDR * addr)
{
    b460:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b464:	b099      	sub	sp, #100	; 0x64
    char * endPtr;
    char*  str;
    IPV6_ADDR   convAddr;
    char   str_buff[64 + 1];     // enough space for longest address: 1111:2222:3333:4444:5555:6666:192.250.250.250

    if(addr)
    b466:	460d      	mov	r5, r1
    b468:	b121      	cbz	r1, b474 <TCPIP_Helper_StringToIPv6Address+0x14>
    {
        memset(addr, 0, sizeof(*addr));
    b46a:	2300      	movs	r3, #0
    b46c:	600b      	str	r3, [r1, #0]
    b46e:	604b      	str	r3, [r1, #4]
    b470:	608b      	str	r3, [r1, #8]
    b472:	60cb      	str	r3, [r1, #12]
    }

    if(addStr == 0 || (len = strlen(addStr)) == 0)
    b474:	2800      	cmp	r0, #0
    b476:	f000 812f 	beq.w	b6d8 <TCPIP_Helper_StringToIPv6Address+0x278>
    b47a:	4604      	mov	r4, r0
    b47c:	f016 fc16 	bl	21cac <strlen>
    b480:	4603      	mov	r3, r0
    b482:	b918      	cbnz	r0, b48c <TCPIP_Helper_StringToIPv6Address+0x2c>
    {
        return true;
    b484:	2001      	movs	r0, #1
    {
        memcpy(addr, convAddr.v, sizeof(*addr));
    }

    return true;
}
    b486:	b019      	add	sp, #100	; 0x64
    b488:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memset(convAddr.v, 0, sizeof(convAddr));
    b48c:	2200      	movs	r2, #0
    b48e:	9211      	str	r2, [sp, #68]	; 0x44
    b490:	9212      	str	r2, [sp, #72]	; 0x48
    b492:	9213      	str	r2, [sp, #76]	; 0x4c
    b494:	9214      	str	r2, [sp, #80]	; 0x50
    while(isspace(*addStr))
    b496:	7821      	ldrb	r1, [r4, #0]
    b498:	4abf      	ldr	r2, [pc, #764]	; (b798 <TCPIP_Helper_StringToIPv6Address+0x338>)
    b49a:	5c8a      	ldrb	r2, [r1, r2]
    b49c:	f012 0f08 	tst.w	r2, #8
    b4a0:	d024      	beq.n	b4ec <TCPIP_Helper_StringToIPv6Address+0x8c>
    b4a2:	1c62      	adds	r2, r4, #1
    b4a4:	4420      	add	r0, r4
    b4a6:	4ebc      	ldr	r6, [pc, #752]	; (b798 <TCPIP_Helper_StringToIPv6Address+0x338>)
        addStr++;
    b4a8:	4611      	mov	r1, r2
        len--;
    b4aa:	1a83      	subs	r3, r0, r2
    b4ac:	3201      	adds	r2, #1
    while(isspace(*addStr))
    b4ae:	780c      	ldrb	r4, [r1, #0]
    b4b0:	5da4      	ldrb	r4, [r4, r6]
    b4b2:	f014 0f08 	tst.w	r4, #8
    b4b6:	d1f7      	bne.n	b4a8 <TCPIP_Helper_StringToIPv6Address+0x48>
    while(isspace(*(addStr + len - 1)))
    b4b8:	461a      	mov	r2, r3
    b4ba:	1e5f      	subs	r7, r3, #1
    b4bc:	19c8      	adds	r0, r1, r7
    b4be:	5dce      	ldrb	r6, [r1, r7]
    b4c0:	4cb5      	ldr	r4, [pc, #724]	; (b798 <TCPIP_Helper_StringToIPv6Address+0x338>)
    b4c2:	5d34      	ldrb	r4, [r6, r4]
    b4c4:	f014 0f08 	tst.w	r4, #8
    b4c8:	d012      	beq.n	b4f0 <TCPIP_Helper_StringToIPv6Address+0x90>
    b4ca:	f8df c2cc 	ldr.w	ip, [pc, #716]	; b798 <TCPIP_Helper_StringToIPv6Address+0x338>
        len--;
    b4ce:	1e5e      	subs	r6, r3, #1
    b4d0:	4632      	mov	r2, r6
    while(isspace(*(addStr + len - 1)))
    b4d2:	1e9f      	subs	r7, r3, #2
        len--;
    b4d4:	4633      	mov	r3, r6
    while(isspace(*(addStr + len - 1)))
    b4d6:	f810 4d01 	ldrb.w	r4, [r0, #-1]!
    b4da:	f814 400c 	ldrb.w	r4, [r4, ip]
    b4de:	f014 0f08 	tst.w	r4, #8
    b4e2:	d1f4      	bne.n	b4ce <TCPIP_Helper_StringToIPv6Address+0x6e>
    if(len > sizeof(str_buff) - 1)
    b4e4:	2a40      	cmp	r2, #64	; 0x40
    b4e6:	d905      	bls.n	b4f4 <TCPIP_Helper_StringToIPv6Address+0x94>
        return false;
    b4e8:	2000      	movs	r0, #0
    b4ea:	e7cc      	b.n	b486 <TCPIP_Helper_StringToIPv6Address+0x26>
    while(isspace(*addStr))
    b4ec:	4621      	mov	r1, r4
    b4ee:	e7e3      	b.n	b4b8 <TCPIP_Helper_StringToIPv6Address+0x58>
    while(isspace(*(addStr + len - 1)))
    b4f0:	461e      	mov	r6, r3
    b4f2:	e7f7      	b.n	b4e4 <TCPIP_Helper_StringToIPv6Address+0x84>
    strncpy(str_buff, addStr, len);
    b4f4:	4668      	mov	r0, sp
    b4f6:	f014 ff46 	bl	20386 <strncpy>
    str_buff[len] = 0;
    b4fa:	2200      	movs	r2, #0
    b4fc:	ab18      	add	r3, sp, #96	; 0x60
    b4fe:	4433      	add	r3, r6
    b500:	f803 2c60 	strb.w	r2, [r3, #-96]
    if (*str == '[')
    b504:	f89d 3000 	ldrb.w	r3, [sp]
    b508:	2b5b      	cmp	r3, #91	; 0x5b
    b50a:	f000 8086 	beq.w	b61a <TCPIP_Helper_StringToIPv6Address+0x1ba>
    str = str_buff;
    b50e:	466c      	mov	r4, sp
    while(isspace(*str))
    b510:	7822      	ldrb	r2, [r4, #0]
    b512:	4ba1      	ldr	r3, [pc, #644]	; (b798 <TCPIP_Helper_StringToIPv6Address+0x338>)
    b514:	5cd3      	ldrb	r3, [r2, r3]
    b516:	f013 0f08 	tst.w	r3, #8
    b51a:	d00a      	beq.n	b532 <TCPIP_Helper_StringToIPv6Address+0xd2>
    b51c:	1c63      	adds	r3, r4, #1
    b51e:	19a1      	adds	r1, r4, r6
    b520:	489d      	ldr	r0, [pc, #628]	; (b798 <TCPIP_Helper_StringToIPv6Address+0x338>)
        str++;
    b522:	461c      	mov	r4, r3
        len--;
    b524:	1ace      	subs	r6, r1, r3
    b526:	3301      	adds	r3, #1
    while(isspace(*str))
    b528:	7822      	ldrb	r2, [r4, #0]
    b52a:	5c12      	ldrb	r2, [r2, r0]
    b52c:	f012 0f08 	tst.w	r2, #8
    b530:	d1f7      	bne.n	b522 <TCPIP_Helper_StringToIPv6Address+0xc2>
    endPtr = str + len;
    b532:	4426      	add	r6, r4
    b534:	9615      	str	r6, [sp, #84]	; 0x54
    while(isspace(*(endPtr - 1)))
    b536:	f816 2c01 	ldrb.w	r2, [r6, #-1]
    b53a:	4b97      	ldr	r3, [pc, #604]	; (b798 <TCPIP_Helper_StringToIPv6Address+0x338>)
    b53c:	5cd3      	ldrb	r3, [r2, r3]
    b53e:	f013 0f08 	tst.w	r3, #8
    b542:	d009      	beq.n	b558 <TCPIP_Helper_StringToIPv6Address+0xf8>
    b544:	1e73      	subs	r3, r6, #1
    b546:	4994      	ldr	r1, [pc, #592]	; (b798 <TCPIP_Helper_StringToIPv6Address+0x338>)
        endPtr--;
    b548:	461e      	mov	r6, r3
    b54a:	9315      	str	r3, [sp, #84]	; 0x54
    while(isspace(*(endPtr - 1)))
    b54c:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
    b550:	5c52      	ldrb	r2, [r2, r1]
    b552:	f012 0f08 	tst.w	r2, #8
    b556:	d1f7      	bne.n	b548 <TCPIP_Helper_StringToIPv6Address+0xe8>
    *endPtr = 0;
    b558:	2300      	movs	r3, #0
    b55a:	7033      	strb	r3, [r6, #0]
    if(*str == ':')
    b55c:	7823      	ldrb	r3, [r4, #0]
    b55e:	2b3a      	cmp	r3, #58	; 0x3a
    b560:	d065      	beq.n	b62e <TCPIP_Helper_StringToIPv6Address+0x1ce>
    uint8_t shiftIndex = 0xFF;
    b562:	27ff      	movs	r7, #255	; 0xff
    if(!isxdigit(*str))
    b564:	7826      	ldrb	r6, [r4, #0]
    b566:	4b8c      	ldr	r3, [pc, #560]	; (b798 <TCPIP_Helper_StringToIPv6Address+0x338>)
    b568:	5cf3      	ldrb	r3, [r6, r3]
    b56a:	f013 0f44 	tst.w	r3, #68	; 0x44
    b56e:	f000 80b9 	beq.w	b6e4 <TCPIP_Helper_StringToIPv6Address+0x284>
    i = *str++;
    b572:	3401      	adds	r4, #1
    while (i != ':' && i != 0u && i != '.' && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
    b574:	2e3a      	cmp	r6, #58	; 0x3a
    b576:	d074      	beq.n	b662 <TCPIP_Helper_StringToIPv6Address+0x202>
    b578:	f016 02df 	ands.w	r2, r6, #223	; 0xdf
    b57c:	d072      	beq.n	b664 <TCPIP_Helper_StringToIPv6Address+0x204>
    b57e:	f1a6 032e 	sub.w	r3, r6, #46	; 0x2e
    b582:	b2db      	uxtb	r3, r3
    b584:	2b01      	cmp	r3, #1
    b586:	f240 80a3 	bls.w	b6d0 <TCPIP_Helper_StringToIPv6Address+0x270>
    b58a:	2e0d      	cmp	r6, #13
    b58c:	f000 80a2 	beq.w	b6d4 <TCPIP_Helper_StringToIPv6Address+0x274>
    b590:	f1a6 0309 	sub.w	r3, r6, #9
    b594:	b2db      	uxtb	r3, r3
    b596:	2b01      	cmp	r3, #1
    b598:	bf98      	it	ls
    b59a:	2200      	movls	r2, #0
    b59c:	d962      	bls.n	b664 <TCPIP_Helper_StringToIPv6Address+0x204>
    currentWord = 0;
    b59e:	f04f 0900 	mov.w	r9, #0
    int conv_base = 16;
    b5a2:	f04f 0b10 	mov.w	fp, #16
        subString[j] = 0;
    b5a6:	46ca      	mov	sl, r9
        while (i != ':' && i != 0u && i != '.' && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
    b5a8:	2e3a      	cmp	r6, #58	; 0x3a
    b5aa:	f000 8100 	beq.w	b7ae <TCPIP_Helper_StringToIPv6Address+0x34e>
    b5ae:	2e00      	cmp	r6, #0
    b5b0:	f000 80a6 	beq.w	b700 <TCPIP_Helper_StringToIPv6Address+0x2a0>
    b5b4:	2e2e      	cmp	r6, #46	; 0x2e
    b5b6:	f000 80f1 	beq.w	b79c <TCPIP_Helper_StringToIPv6Address+0x33c>
    b5ba:	2e2f      	cmp	r6, #47	; 0x2f
    b5bc:	f000 80e1 	beq.w	b782 <TCPIP_Helper_StringToIPv6Address+0x322>
    b5c0:	2e0d      	cmp	r6, #13
    b5c2:	f000 80e0 	beq.w	b786 <TCPIP_Helper_StringToIPv6Address+0x326>
    b5c6:	2e0a      	cmp	r6, #10
    b5c8:	f000 80df 	beq.w	b78a <TCPIP_Helper_StringToIPv6Address+0x32a>
    b5cc:	2e20      	cmp	r6, #32
    b5ce:	f000 80de 	beq.w	b78e <TCPIP_Helper_StringToIPv6Address+0x32e>
    b5d2:	2e09      	cmp	r6, #9
    b5d4:	f000 80dd 	beq.w	b792 <TCPIP_Helper_StringToIPv6Address+0x332>
    b5d8:	aa16      	add	r2, sp, #88	; 0x58
    b5da:	2301      	movs	r3, #1
            subString[j++] = i;
    b5dc:	fa5f f883 	uxtb.w	r8, r3
    b5e0:	f802 6b01 	strb.w	r6, [r2], #1
            i = *str++;
    b5e4:	f814 6b01 	ldrb.w	r6, [r4], #1
        while (i != ':' && i != 0u && i != '.' && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
    b5e8:	2e3a      	cmp	r6, #58	; 0x3a
    b5ea:	f000 80e1 	beq.w	b7b0 <TCPIP_Helper_StringToIPv6Address+0x350>
    b5ee:	2e00      	cmp	r6, #0
    b5f0:	f000 8087 	beq.w	b702 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    b5f4:	2e2e      	cmp	r6, #46	; 0x2e
    b5f6:	f000 80d2 	beq.w	b79e <TCPIP_Helper_StringToIPv6Address+0x33e>
    b5fa:	2e2f      	cmp	r6, #47	; 0x2f
    b5fc:	f000 8081 	beq.w	b702 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    b600:	2e0d      	cmp	r6, #13
    b602:	d07e      	beq.n	b702 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    b604:	2e0a      	cmp	r6, #10
    b606:	d07c      	beq.n	b702 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    b608:	2e20      	cmp	r6, #32
    b60a:	d07a      	beq.n	b702 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    b60c:	2e09      	cmp	r6, #9
    b60e:	d078      	beq.n	b702 <TCPIP_Helper_StringToIPv6Address+0x2a2>
            if (j == 4)
    b610:	3301      	adds	r3, #1
    b612:	2b05      	cmp	r3, #5
    b614:	d1e2      	bne.n	b5dc <TCPIP_Helper_StringToIPv6Address+0x17c>
                return false;
    b616:	2000      	movs	r0, #0
    b618:	e735      	b.n	b486 <TCPIP_Helper_StringToIPv6Address+0x26>
        if(str[len - 1] != ']')
    b61a:	f81d 3007 	ldrb.w	r3, [sp, r7]
    b61e:	2b5d      	cmp	r3, #93	; 0x5d
    b620:	d15c      	bne.n	b6dc <TCPIP_Helper_StringToIPv6Address+0x27c>
        str[len - 1] = 0;   // delete trailing ]
    b622:	f80d 2007 	strb.w	r2, [sp, r7]
        len--;
    b626:	3e02      	subs	r6, #2
        str++;  // skip leading [
    b628:	f10d 0401 	add.w	r4, sp, #1
    b62c:	e770      	b.n	b510 <TCPIP_Helper_StringToIPv6Address+0xb0>
        if(*++str != ':')
    b62e:	7863      	ldrb	r3, [r4, #1]
    b630:	2b3a      	cmp	r3, #58	; 0x3a
    b632:	d155      	bne.n	b6e0 <TCPIP_Helper_StringToIPv6Address+0x280>
        str++;
    b634:	3402      	adds	r4, #2
        shiftIndex = 0;
    b636:	2700      	movs	r7, #0
    b638:	e794      	b.n	b564 <TCPIP_Helper_StringToIPv6Address+0x104>
            if (*str == ':')
    b63a:	7823      	ldrb	r3, [r4, #0]
    b63c:	2b3a      	cmp	r3, #58	; 0x3a
    b63e:	d002      	beq.n	b646 <TCPIP_Helper_StringToIPv6Address+0x1e6>
        i = *str++;
    b640:	f814 6b01 	ldrb.w	r6, [r4], #1
    b644:	e088      	b.n	b758 <TCPIP_Helper_StringToIPv6Address+0x2f8>
                if (shiftIndex == 0xFF)
    b646:	2fff      	cmp	r7, #255	; 0xff
    b648:	d150      	bne.n	b6ec <TCPIP_Helper_StringToIPv6Address+0x28c>
                i = *str++;
    b64a:	3401      	adds	r4, #1
        convAddr.w[currentWord++] = TCPIP_Helper_htons(convertedValue);
    b64c:	4617      	mov	r7, r2
    b64e:	e07e      	b.n	b74e <TCPIP_Helper_StringToIPv6Address+0x2ee>
    if(currentWord > 8 || (currentWord < 8 && shiftIndex == 0xff))
    b650:	2a08      	cmp	r2, #8
    b652:	d901      	bls.n	b658 <TCPIP_Helper_StringToIPv6Address+0x1f8>
        return false;
    b654:	2000      	movs	r0, #0
    b656:	e716      	b.n	b486 <TCPIP_Helper_StringToIPv6Address+0x26>
    if(currentWord > 8 || (currentWord < 8 && shiftIndex == 0xff))
    b658:	2a07      	cmp	r2, #7
    b65a:	d903      	bls.n	b664 <TCPIP_Helper_StringToIPv6Address+0x204>
    if (shiftIndex != 0xFF)
    b65c:	2fff      	cmp	r7, #255	; 0xff
    b65e:	d02e      	beq.n	b6be <TCPIP_Helper_StringToIPv6Address+0x25e>
    b660:	e002      	b.n	b668 <TCPIP_Helper_StringToIPv6Address+0x208>
    while (i != ':' && i != 0u && i != '.' && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
    b662:	2200      	movs	r2, #0
    if(currentWord > 8 || (currentWord < 8 && shiftIndex == 0xff))
    b664:	2fff      	cmp	r7, #255	; 0xff
    b666:	d045      	beq.n	b6f4 <TCPIP_Helper_StringToIPv6Address+0x294>
        for (i = 7, j = currentWord - 1; (int8_t)j >= (int8_t)shiftIndex; i--, j--)
    b668:	1e53      	subs	r3, r2, #1
    b66a:	b2db      	uxtb	r3, r3
    b66c:	b27c      	sxtb	r4, r7
    b66e:	b259      	sxtb	r1, r3
    b670:	42a1      	cmp	r1, r4
    b672:	db13      	blt.n	b69c <TCPIP_Helper_StringToIPv6Address+0x23c>
            convAddr.w[i] = convAddr.w[j];
    b674:	f1c2 0608 	rsb	r6, r2, #8
    b678:	a918      	add	r1, sp, #96	; 0x60
    b67a:	eb01 0143 	add.w	r1, r1, r3, lsl #1
    b67e:	f831 0c1c 	ldrh.w	r0, [r1, #-28]
    b682:	1999      	adds	r1, r3, r6
    b684:	b2c9      	uxtb	r1, r1
    b686:	f10d 0c60 	add.w	ip, sp, #96	; 0x60
    b68a:	eb0c 0141 	add.w	r1, ip, r1, lsl #1
    b68e:	f821 0c1c 	strh.w	r0, [r1, #-28]
        for (i = 7, j = currentWord - 1; (int8_t)j >= (int8_t)shiftIndex; i--, j--)
    b692:	3b01      	subs	r3, #1
    b694:	b2db      	uxtb	r3, r3
    b696:	b259      	sxtb	r1, r3
    b698:	428c      	cmp	r4, r1
    b69a:	dded      	ble.n	b678 <TCPIP_Helper_StringToIPv6Address+0x218>
        for (i = shiftIndex; i <= 7 - (currentWord - shiftIndex); i++)
    b69c:	4639      	mov	r1, r7
    b69e:	1bd3      	subs	r3, r2, r7
    b6a0:	f1c3 0307 	rsb	r3, r3, #7
    b6a4:	429f      	cmp	r7, r3
    b6a6:	dc0a      	bgt.n	b6be <TCPIP_Helper_StringToIPv6Address+0x25e>
            convAddr.w[i] = 0x0000;
    b6a8:	2200      	movs	r2, #0
    b6aa:	a818      	add	r0, sp, #96	; 0x60
    b6ac:	eb00 0141 	add.w	r1, r0, r1, lsl #1
    b6b0:	f821 2c1c 	strh.w	r2, [r1, #-28]
        for (i = shiftIndex; i <= 7 - (currentWord - shiftIndex); i++)
    b6b4:	3701      	adds	r7, #1
    b6b6:	b2ff      	uxtb	r7, r7
    b6b8:	4639      	mov	r1, r7
    b6ba:	429f      	cmp	r7, r3
    b6bc:	ddf5      	ble.n	b6aa <TCPIP_Helper_StringToIPv6Address+0x24a>
    if(addr)
    b6be:	b1dd      	cbz	r5, b6f8 <TCPIP_Helper_StringToIPv6Address+0x298>
        memcpy(addr, convAddr.v, sizeof(*addr));
    b6c0:	ac11      	add	r4, sp, #68	; 0x44
    b6c2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    b6c4:	6028      	str	r0, [r5, #0]
    b6c6:	6069      	str	r1, [r5, #4]
    b6c8:	60aa      	str	r2, [r5, #8]
    b6ca:	60eb      	str	r3, [r5, #12]
    return true;
    b6cc:	2001      	movs	r0, #1
    b6ce:	e6da      	b.n	b486 <TCPIP_Helper_StringToIPv6Address+0x26>
    while (i != ':' && i != 0u && i != '.' && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
    b6d0:	2200      	movs	r2, #0
    b6d2:	e7c7      	b.n	b664 <TCPIP_Helper_StringToIPv6Address+0x204>
    b6d4:	2200      	movs	r2, #0
    b6d6:	e7c5      	b.n	b664 <TCPIP_Helper_StringToIPv6Address+0x204>
        return true;
    b6d8:	2001      	movs	r0, #1
    b6da:	e6d4      	b.n	b486 <TCPIP_Helper_StringToIPv6Address+0x26>
            return false;
    b6dc:	2000      	movs	r0, #0
    b6de:	e6d2      	b.n	b486 <TCPIP_Helper_StringToIPv6Address+0x26>
            return false;
    b6e0:	2000      	movs	r0, #0
    b6e2:	e6d0      	b.n	b486 <TCPIP_Helper_StringToIPv6Address+0x26>
        return false;
    b6e4:	2000      	movs	r0, #0
    b6e6:	e6ce      	b.n	b486 <TCPIP_Helper_StringToIPv6Address+0x26>
            return false;
    b6e8:	2000      	movs	r0, #0
    b6ea:	e6cc      	b.n	b486 <TCPIP_Helper_StringToIPv6Address+0x26>
                    return false;
    b6ec:	2000      	movs	r0, #0
    b6ee:	e6ca      	b.n	b486 <TCPIP_Helper_StringToIPv6Address+0x26>
            return false;
    b6f0:	2000      	movs	r0, #0
    b6f2:	e6c8      	b.n	b486 <TCPIP_Helper_StringToIPv6Address+0x26>
        return false;
    b6f4:	2000      	movs	r0, #0
    b6f6:	e6c6      	b.n	b486 <TCPIP_Helper_StringToIPv6Address+0x26>
    return true;
    b6f8:	2001      	movs	r0, #1
    b6fa:	e6c4      	b.n	b486 <TCPIP_Helper_StringToIPv6Address+0x26>
            return false;
    b6fc:	2000      	movs	r0, #0
    b6fe:	e6c2      	b.n	b486 <TCPIP_Helper_StringToIPv6Address+0x26>
        j = 0;
    b700:	46b0      	mov	r8, r6
        subString[j] = 0;
    b702:	ab18      	add	r3, sp, #96	; 0x60
    b704:	4443      	add	r3, r8
    b706:	f803 ac08 	strb.w	sl, [r3, #-8]
        convertedValue = (uint16_t)strtol((const char *)subString, &endPtr, conv_base);
    b70a:	465a      	mov	r2, fp
    b70c:	a915      	add	r1, sp, #84	; 0x54
    b70e:	a816      	add	r0, sp, #88	; 0x58
    b710:	f016 f98e 	bl	21a30 <strtol>
    b714:	b281      	uxth	r1, r0
        if(convertedValue == 0 && endPtr != (char*)subString + j)
    b716:	b921      	cbnz	r1, b722 <TCPIP_Helper_StringToIPv6Address+0x2c2>
    b718:	ab16      	add	r3, sp, #88	; 0x58
    b71a:	4498      	add	r8, r3
    b71c:	9b15      	ldr	r3, [sp, #84]	; 0x54
    b71e:	4543      	cmp	r3, r8
    b720:	d1e2      	bne.n	b6e8 <TCPIP_Helper_StringToIPv6Address+0x288>
        convAddr.w[currentWord++] = TCPIP_Helper_htons(convertedValue);
    b722:	f109 0201 	add.w	r2, r9, #1
    b726:	b2d2      	uxtb	r2, r2
    b728:	ab18      	add	r3, sp, #96	; 0x60
    b72a:	eb03 0949 	add.w	r9, r3, r9, lsl #1
       return (((hShort) << 8) | ((hShort) >> 8));
    b72e:	0203      	lsls	r3, r0, #8
    b730:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    b734:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    b738:	ea43 2311 	orr.w	r3, r3, r1, lsr #8
    b73c:	f829 3c1c 	strh.w	r3, [r9, #-28]
        if(i == 0)
    b740:	2e00      	cmp	r6, #0
    b742:	d085      	beq.n	b650 <TCPIP_Helper_StringToIPv6Address+0x1f0>
        if (i == ':')
    b744:	2e3a      	cmp	r6, #58	; 0x3a
    b746:	f43f af78 	beq.w	b63a <TCPIP_Helper_StringToIPv6Address+0x1da>
        if (i == ',')
    b74a:	2e2c      	cmp	r6, #44	; 0x2c
    b74c:	d0d0      	beq.n	b6f0 <TCPIP_Helper_StringToIPv6Address+0x290>
        i = *str++;
    b74e:	f814 6b01 	ldrb.w	r6, [r4], #1
    while (i != ':' && i != 0u && i != '.' && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
    b752:	2e3a      	cmp	r6, #58	; 0x3a
    b754:	f43f af7c 	beq.w	b650 <TCPIP_Helper_StringToIPv6Address+0x1f0>
    b758:	f016 0fdf 	tst.w	r6, #223	; 0xdf
    b75c:	f43f af78 	beq.w	b650 <TCPIP_Helper_StringToIPv6Address+0x1f0>
    b760:	f1a6 032e 	sub.w	r3, r6, #46	; 0x2e
    b764:	b2db      	uxtb	r3, r3
    b766:	2b01      	cmp	r3, #1
    b768:	f67f af72 	bls.w	b650 <TCPIP_Helper_StringToIPv6Address+0x1f0>
    b76c:	2e0d      	cmp	r6, #13
    b76e:	f43f af6f 	beq.w	b650 <TCPIP_Helper_StringToIPv6Address+0x1f0>
    b772:	f1a6 0309 	sub.w	r3, r6, #9
    b776:	b2db      	uxtb	r3, r3
    b778:	2b01      	cmp	r3, #1
    b77a:	f67f af69 	bls.w	b650 <TCPIP_Helper_StringToIPv6Address+0x1f0>
        convAddr.w[currentWord++] = TCPIP_Helper_htons(convertedValue);
    b77e:	4691      	mov	r9, r2
    b780:	e712      	b.n	b5a8 <TCPIP_Helper_StringToIPv6Address+0x148>
        j = 0;
    b782:	46d0      	mov	r8, sl
    b784:	e7bd      	b.n	b702 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    b786:	46d0      	mov	r8, sl
    b788:	e7bb      	b.n	b702 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    b78a:	46d0      	mov	r8, sl
    b78c:	e7b9      	b.n	b702 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    b78e:	46d0      	mov	r8, sl
    b790:	e7b7      	b.n	b702 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    b792:	46d0      	mov	r8, sl
    b794:	e7b5      	b.n	b702 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    b796:	bf00      	nop
    b798:	00014195 	.word	0x00014195
    b79c:	46d0      	mov	r8, sl
        subString[j] = 0;
    b79e:	ab18      	add	r3, sp, #96	; 0x60
    b7a0:	4443      	add	r3, r8
    b7a2:	f803 ac08 	strb.w	sl, [r3, #-8]
    b7a6:	262e      	movs	r6, #46	; 0x2e
            conv_base = 10;
    b7a8:	f04f 0b0a 	mov.w	fp, #10
    b7ac:	e7ad      	b.n	b70a <TCPIP_Helper_StringToIPv6Address+0x2aa>
        j = 0;
    b7ae:	46d0      	mov	r8, sl
        subString[j] = 0;
    b7b0:	ab18      	add	r3, sp, #96	; 0x60
    b7b2:	4443      	add	r3, r8
    b7b4:	f803 ac08 	strb.w	sl, [r3, #-8]
        else if(i == ':' && conv_base == 10)
    b7b8:	f1bb 0f0a 	cmp.w	fp, #10
    b7bc:	d09e      	beq.n	b6fc <TCPIP_Helper_StringToIPv6Address+0x29c>
    b7be:	263a      	movs	r6, #58	; 0x3a
    b7c0:	e7a3      	b.n	b70a <TCPIP_Helper_StringToIPv6Address+0x2aa>
    b7c2:	bf00      	nop

Disassembly of section .text.Transform_Sha256%205:

0000b7c4 <Transform_Sha256>:
         t1 = Sigma0(a(j)) + Maj(a(j), b(j), c(j)); \
         d(j) += t0; \
         h(j)  = t0 + t1

    static int Transform_Sha256(wc_Sha256* sha256, const byte* data)
    {
    b7c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b7c8:	b0cb      	sub	sp, #300	; 0x12c
    #else
        word32 W[WC_SHA256_BLOCK_SIZE];
    #endif

        /* Copy context->state[] to working vars */
        for (i = 0; i < 8; i++)
    b7ca:	f1a0 0a04 	sub.w	sl, r0, #4
    b7ce:	aa41      	add	r2, sp, #260	; 0x104
    b7d0:	9200      	str	r2, [sp, #0]
    b7d2:	f100 041c 	add.w	r4, r0, #28
    b7d6:	9401      	str	r4, [sp, #4]
    {
    b7d8:	4653      	mov	r3, sl
            S[i] = sha256->digest[i];
    b7da:	f853 0f04 	ldr.w	r0, [r3, #4]!
    b7de:	f842 0f04 	str.w	r0, [r2, #4]!
        for (i = 0; i < 8; i++)
    b7e2:	42a3      	cmp	r3, r4
    b7e4:	d1f9      	bne.n	b7da <Transform_Sha256+0x16>
    b7e6:	3904      	subs	r1, #4
    b7e8:	f10d 0908 	add.w	r9, sp, #8
    b7ec:	a812      	add	r0, sp, #72	; 0x48
    b7ee:	464b      	mov	r3, r9

        for (i = 0; i < 16; i++)
            W[i] = *((word32*)&data[i*sizeof(word32)]);
    b7f0:	f851 2f04 	ldr.w	r2, [r1, #4]!
    b7f4:	f843 2b04 	str.w	r2, [r3], #4
        for (i = 0; i < 16; i++)
    b7f8:	4283      	cmp	r3, r0
    b7fa:	d1f9      	bne.n	b7f0 <Transform_Sha256+0x2c>
    b7fc:	f109 00c0 	add.w	r0, r9, #192	; 0xc0
    b800:	464a      	mov	r2, r9

        for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
            W[i] = Gamma1(W[i-2]) + W[i-7] + Gamma0(W[i-15]) + W[i-16];
    b802:	4615      	mov	r5, r2
    b804:	6b91      	ldr	r1, [r2, #56]	; 0x38
    b806:	f852 4f04 	ldr.w	r4, [r2, #4]!
    }

/* This routine performs a right circular arithmetic shift of <x> by <y> value. */
    WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
    {
        return (x >> y) | (x << (sizeof(y) * 8 - y));
    b80a:	ea4f 43f1 	mov.w	r3, r1, ror #19
    b80e:	ea83 4371 	eor.w	r3, r3, r1, ror #17
    b812:	ea83 2391 	eor.w	r3, r3, r1, lsr #10
    b816:	6a69      	ldr	r1, [r5, #36]	; 0x24
    b818:	682d      	ldr	r5, [r5, #0]
    b81a:	4429      	add	r1, r5
    b81c:	440b      	add	r3, r1
    b81e:	ea4f 41b4 	mov.w	r1, r4, ror #18
    b822:	ea81 11f4 	eor.w	r1, r1, r4, ror #7
    b826:	ea81 01d4 	eor.w	r1, r1, r4, lsr #3
    b82a:	440b      	add	r3, r1
    b82c:	63d3      	str	r3, [r2, #60]	; 0x3c
        for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
    b82e:	4282      	cmp	r2, r0
    b830:	d1e7      	bne.n	b802 <Transform_Sha256+0x3e>
    b832:	f8dd e124 	ldr.w	lr, [sp, #292]	; 0x124
    b836:	9a45      	ldr	r2, [sp, #276]	; 0x114
    b838:	f8dd c120 	ldr.w	ip, [sp, #288]	; 0x120
    b83c:	9944      	ldr	r1, [sp, #272]	; 0x110
    b83e:	9f47      	ldr	r7, [sp, #284]	; 0x11c
    b840:	9843      	ldr	r0, [sp, #268]	; 0x10c
    b842:	9b46      	ldr	r3, [sp, #280]	; 0x118
    b844:	9c42      	ldr	r4, [sp, #264]	; 0x108
    b846:	f8df 8284 	ldr.w	r8, [pc, #644]	; bacc <Transform_Sha256+0x308>
    b84a:	46d3      	mov	fp, sl
    b84c:	46ca      	mov	sl, r9
    b84e:	46c1      	mov	r9, r8
    b850:	ea4f 25f3 	mov.w	r5, r3, ror #11
            }
        }
    #else
        /* partially loop unrolled */
        for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
            RND(0); RND(1); RND(2); RND(3);
    b854:	ea85 15b3 	eor.w	r5, r5, r3, ror #6
    b858:	ea85 6873 	eor.w	r8, r5, r3, ror #25
    b85c:	f8d9 5000 	ldr.w	r5, [r9]
    b860:	f8da 6000 	ldr.w	r6, [sl]
    b864:	4435      	add	r5, r6
    b866:	4445      	add	r5, r8
    b868:	ea8c 0607 	eor.w	r6, ip, r7
    b86c:	401e      	ands	r6, r3
    b86e:	ea86 060c 	eor.w	r6, r6, ip
    b872:	4435      	add	r5, r6
    b874:	44ae      	add	lr, r5
    b876:	4472      	add	r2, lr
    b878:	ea4f 3574 	mov.w	r5, r4, ror #13
    b87c:	ea85 05b4 	eor.w	r5, r5, r4, ror #2
    b880:	ea85 55b4 	eor.w	r5, r5, r4, ror #22
    b884:	ea44 0600 	orr.w	r6, r4, r0
    b888:	400e      	ands	r6, r1
    b88a:	ea04 0800 	and.w	r8, r4, r0
    b88e:	ea46 0608 	orr.w	r6, r6, r8
    b892:	4435      	add	r5, r6
    b894:	44ae      	add	lr, r5
    b896:	f8d9 5004 	ldr.w	r5, [r9, #4]
    b89a:	f8da 6004 	ldr.w	r6, [sl, #4]
    b89e:	4435      	add	r5, r6
    b8a0:	4465      	add	r5, ip
    b8a2:	ea83 0c07 	eor.w	ip, r3, r7
    b8a6:	ea0c 0c02 	and.w	ip, ip, r2
    b8aa:	ea8c 0c07 	eor.w	ip, ip, r7
    b8ae:	4465      	add	r5, ip
    b8b0:	ea4f 2cf2 	mov.w	ip, r2, ror #11
    b8b4:	ea8c 1cb2 	eor.w	ip, ip, r2, ror #6
    b8b8:	ea8c 6c72 	eor.w	ip, ip, r2, ror #25
    b8bc:	4465      	add	r5, ip
    b8be:	eb01 0c05 	add.w	ip, r1, r5
    b8c2:	ea4f 317e 	mov.w	r1, lr, ror #13
    b8c6:	ea81 01be 	eor.w	r1, r1, lr, ror #2
    b8ca:	ea81 51be 	eor.w	r1, r1, lr, ror #22
    b8ce:	ea4e 0604 	orr.w	r6, lr, r4
    b8d2:	4006      	ands	r6, r0
    b8d4:	ea0e 0804 	and.w	r8, lr, r4
    b8d8:	ea46 0608 	orr.w	r6, r6, r8
    b8dc:	4431      	add	r1, r6
    b8de:	4429      	add	r1, r5
    b8e0:	f8d9 5008 	ldr.w	r5, [r9, #8]
    b8e4:	f8da 6008 	ldr.w	r6, [sl, #8]
    b8e8:	4435      	add	r5, r6
    b8ea:	442f      	add	r7, r5
    b8ec:	ea83 0502 	eor.w	r5, r3, r2
    b8f0:	ea05 050c 	and.w	r5, r5, ip
    b8f4:	405d      	eors	r5, r3
    b8f6:	442f      	add	r7, r5
    b8f8:	ea4f 25fc 	mov.w	r5, ip, ror #11
    b8fc:	ea85 15bc 	eor.w	r5, r5, ip, ror #6
    b900:	ea85 657c 	eor.w	r5, r5, ip, ror #25
    b904:	442f      	add	r7, r5
    b906:	eb00 0807 	add.w	r8, r0, r7
    b90a:	ea4f 3071 	mov.w	r0, r1, ror #13
    b90e:	ea80 00b1 	eor.w	r0, r0, r1, ror #2
    b912:	ea80 50b1 	eor.w	r0, r0, r1, ror #22
    b916:	ea4e 0501 	orr.w	r5, lr, r1
    b91a:	4025      	ands	r5, r4
    b91c:	ea0e 0601 	and.w	r6, lr, r1
    b920:	4335      	orrs	r5, r6
    b922:	4428      	add	r0, r5
    b924:	4438      	add	r0, r7
    b926:	f8d9 500c 	ldr.w	r5, [r9, #12]
    b92a:	f8da 600c 	ldr.w	r6, [sl, #12]
    b92e:	4435      	add	r5, r6
    b930:	442b      	add	r3, r5
    b932:	ea82 050c 	eor.w	r5, r2, ip
    b936:	ea05 0508 	and.w	r5, r5, r8
    b93a:	4055      	eors	r5, r2
    b93c:	442b      	add	r3, r5
    b93e:	ea4f 25f8 	mov.w	r5, r8, ror #11
    b942:	ea85 15b8 	eor.w	r5, r5, r8, ror #6
    b946:	ea85 6578 	eor.w	r5, r5, r8, ror #25
    b94a:	441d      	add	r5, r3
    b94c:	1966      	adds	r6, r4, r5
    b94e:	ea4f 3370 	mov.w	r3, r0, ror #13
    b952:	ea83 03b0 	eor.w	r3, r3, r0, ror #2
    b956:	ea83 53b0 	eor.w	r3, r3, r0, ror #22
    b95a:	ea41 0400 	orr.w	r4, r1, r0
    b95e:	ea04 040e 	and.w	r4, r4, lr
    b962:	ea01 0700 	and.w	r7, r1, r0
    b966:	433c      	orrs	r4, r7
    b968:	4423      	add	r3, r4
    b96a:	442b      	add	r3, r5
            RND(4); RND(5); RND(6); RND(7);
    b96c:	f8d9 4010 	ldr.w	r4, [r9, #16]
    b970:	f8da 5010 	ldr.w	r5, [sl, #16]
    b974:	442c      	add	r4, r5
    b976:	4422      	add	r2, r4
    b978:	ea8c 0408 	eor.w	r4, ip, r8
    b97c:	4034      	ands	r4, r6
    b97e:	ea84 040c 	eor.w	r4, r4, ip
    b982:	4422      	add	r2, r4
    b984:	ea4f 24f6 	mov.w	r4, r6, ror #11
    b988:	ea84 14b6 	eor.w	r4, r4, r6, ror #6
    b98c:	ea84 6476 	eor.w	r4, r4, r6, ror #25
    b990:	4414      	add	r4, r2
    b992:	44a6      	add	lr, r4
    b994:	ea4f 3273 	mov.w	r2, r3, ror #13
    b998:	ea82 02b3 	eor.w	r2, r2, r3, ror #2
    b99c:	ea82 52b3 	eor.w	r2, r2, r3, ror #22
    b9a0:	ea40 0503 	orr.w	r5, r0, r3
    b9a4:	400d      	ands	r5, r1
    b9a6:	ea00 0703 	and.w	r7, r0, r3
    b9aa:	433d      	orrs	r5, r7
    b9ac:	442a      	add	r2, r5
    b9ae:	4422      	add	r2, r4
    b9b0:	f8d9 4014 	ldr.w	r4, [r9, #20]
    b9b4:	f8da 5014 	ldr.w	r5, [sl, #20]
    b9b8:	442c      	add	r4, r5
    b9ba:	4464      	add	r4, ip
    b9bc:	ea88 0c06 	eor.w	ip, r8, r6
    b9c0:	ea0c 0c0e 	and.w	ip, ip, lr
    b9c4:	ea8c 0c08 	eor.w	ip, ip, r8
    b9c8:	4464      	add	r4, ip
    b9ca:	ea4f 2cfe 	mov.w	ip, lr, ror #11
    b9ce:	ea8c 1cbe 	eor.w	ip, ip, lr, ror #6
    b9d2:	ea8c 6c7e 	eor.w	ip, ip, lr, ror #25
    b9d6:	4464      	add	r4, ip
    b9d8:	eb01 0c04 	add.w	ip, r1, r4
    b9dc:	ea4f 3172 	mov.w	r1, r2, ror #13
    b9e0:	ea81 01b2 	eor.w	r1, r1, r2, ror #2
    b9e4:	ea81 51b2 	eor.w	r1, r1, r2, ror #22
    b9e8:	ea43 0502 	orr.w	r5, r3, r2
    b9ec:	4005      	ands	r5, r0
    b9ee:	ea03 0702 	and.w	r7, r3, r2
    b9f2:	433d      	orrs	r5, r7
    b9f4:	4429      	add	r1, r5
    b9f6:	4421      	add	r1, r4
    b9f8:	f8d9 4018 	ldr.w	r4, [r9, #24]
    b9fc:	f8da 5018 	ldr.w	r5, [sl, #24]
    ba00:	442c      	add	r4, r5
    ba02:	44a0      	add	r8, r4
    ba04:	ea86 040e 	eor.w	r4, r6, lr
    ba08:	ea04 040c 	and.w	r4, r4, ip
    ba0c:	4074      	eors	r4, r6
    ba0e:	44a0      	add	r8, r4
    ba10:	ea4f 24fc 	mov.w	r4, ip, ror #11
    ba14:	ea84 14bc 	eor.w	r4, r4, ip, ror #6
    ba18:	ea84 647c 	eor.w	r4, r4, ip, ror #25
    ba1c:	44a0      	add	r8, r4
    ba1e:	eb00 0708 	add.w	r7, r0, r8
    ba22:	ea4f 3071 	mov.w	r0, r1, ror #13
    ba26:	ea80 00b1 	eor.w	r0, r0, r1, ror #2
    ba2a:	ea80 50b1 	eor.w	r0, r0, r1, ror #22
    ba2e:	ea42 0401 	orr.w	r4, r2, r1
    ba32:	401c      	ands	r4, r3
    ba34:	ea02 0501 	and.w	r5, r2, r1
    ba38:	432c      	orrs	r4, r5
    ba3a:	4420      	add	r0, r4
    ba3c:	4440      	add	r0, r8
    ba3e:	f8d9 401c 	ldr.w	r4, [r9, #28]
    ba42:	f8da 501c 	ldr.w	r5, [sl, #28]
    ba46:	442c      	add	r4, r5
    ba48:	4434      	add	r4, r6
    ba4a:	ea8e 060c 	eor.w	r6, lr, ip
    ba4e:	403e      	ands	r6, r7
    ba50:	ea86 060e 	eor.w	r6, r6, lr
    ba54:	4434      	add	r4, r6
    ba56:	ea4f 26f7 	mov.w	r6, r7, ror #11
    ba5a:	ea86 16b7 	eor.w	r6, r6, r7, ror #6
    ba5e:	ea86 6677 	eor.w	r6, r6, r7, ror #25
    ba62:	4426      	add	r6, r4
    ba64:	4433      	add	r3, r6
    ba66:	ea4f 3470 	mov.w	r4, r0, ror #13
    ba6a:	ea84 04b0 	eor.w	r4, r4, r0, ror #2
    ba6e:	ea84 54b0 	eor.w	r4, r4, r0, ror #22
    ba72:	ea41 0500 	orr.w	r5, r1, r0
    ba76:	4015      	ands	r5, r2
    ba78:	ea01 0800 	and.w	r8, r1, r0
    ba7c:	ea45 0508 	orr.w	r5, r5, r8
    ba80:	442c      	add	r4, r5
    ba82:	4434      	add	r4, r6
    ba84:	f109 0920 	add.w	r9, r9, #32
    ba88:	f10a 0a20 	add.w	sl, sl, #32
        for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
    ba8c:	4d0e      	ldr	r5, [pc, #56]	; (bac8 <Transform_Sha256+0x304>)
    ba8e:	45a9      	cmp	r9, r5
    ba90:	f47f aede 	bne.w	b850 <Transform_Sha256+0x8c>
    ba94:	46da      	mov	sl, fp
    ba96:	f8cd e124 	str.w	lr, [sp, #292]	; 0x124
    ba9a:	9346      	str	r3, [sp, #280]	; 0x118
    ba9c:	f8cd c120 	str.w	ip, [sp, #288]	; 0x120
    baa0:	9747      	str	r7, [sp, #284]	; 0x11c
    baa2:	9442      	str	r4, [sp, #264]	; 0x108
    baa4:	9043      	str	r0, [sp, #268]	; 0x10c
    baa6:	9144      	str	r1, [sp, #272]	; 0x110
    baa8:	9245      	str	r2, [sp, #276]	; 0x114
    baaa:	9a00      	ldr	r2, [sp, #0]
    baac:	9801      	ldr	r0, [sp, #4]
        }
    #endif /* USE_SLOW_SHA256 */

        /* Add the working vars back into digest state[] */
        for (i = 0; i < 8; i++) {
            sha256->digest[i] += S[i];
    baae:	f85a 3f04 	ldr.w	r3, [sl, #4]!
    bab2:	f852 1f04 	ldr.w	r1, [r2, #4]!
    bab6:	440b      	add	r3, r1
    bab8:	f8ca 3000 	str.w	r3, [sl]
        for (i = 0; i < 8; i++) {
    babc:	4582      	cmp	sl, r0
    babe:	d1f6      	bne.n	baae <Transform_Sha256+0x2ea>

    #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SMALL_STACK_CACHE)
        XFREE(W, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    #endif
        return 0;
    }
    bac0:	2000      	movs	r0, #0
    bac2:	b04b      	add	sp, #300	; 0x12c
    bac4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bac8:	00014398 	.word	0x00014398
    bacc:	00014298 	.word	0x00014298

Disassembly of section .text.DRV_GMAC_Initialize%206:

0000bad0 <DRV_GMAC_Initialize>:
 *                  It should be called to be able to schedule any MAC transmit or receive operation.
 *
 * Note:            Only one client per MAC supported. 
 *****************************************************************************/
SYS_MODULE_OBJ DRV_GMAC_Initialize(const SYS_MODULE_INDEX index, const SYS_MODULE_INIT * const init)
{
    bad0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    bad4:	b084      	sub	sp, #16
    if(macIx >= 0 && macIx < sizeof(_gmac_drv_dcpt)/sizeof(*_gmac_drv_dcpt))
    bad6:	f241 0350 	movw	r3, #4176	; 0x1050
    bada:	4298      	cmp	r0, r3
    badc:	f040 8142 	bne.w	bd64 <DRV_GMAC_Initialize+0x294>
		return SYS_MODULE_OBJ_INVALID;      // no such type supported
	}
   
    pMACDrv = _gmac_drv_dcpt + macIx;

	if(pMACDrv->sGmacData._macFlags._init != 0)
    bae0:	4bb9      	ldr	r3, [pc, #740]	; (bdc8 <DRV_GMAC_Initialize+0x2f8>)
    bae2:	7d9b      	ldrb	r3, [r3, #22]
    bae4:	f013 0f01 	tst.w	r3, #1
    bae8:	f040 8131 	bne.w	bd4e <DRV_GMAC_Initialize+0x27e>
	{   // already initialized	
		return (SYS_MODULE_OBJ)pMACDrv;
	}
	    	
	if(pMACDrv->sGmacData._macFlags._open != 0)
    baec:	f013 0602 	ands.w	r6, r3, #2
    baf0:	f040 813b 	bne.w	bd6a <DRV_GMAC_Initialize+0x29a>
	const TCPIP_MAC_MODULE_CTRL* const macControl = ((TCPIP_MAC_INIT*)init)->macControl;	
    baf4:	684f      	ldr	r7, [r1, #4]
	{
		return SYS_MODULE_OBJ_INVALID;     // have a client connected
	}

	if(macControl->memH == 0)
    baf6:	68fb      	ldr	r3, [r7, #12]
    baf8:	2b00      	cmp	r3, #0
    bafa:	f000 8139 	beq.w	bd70 <DRV_GMAC_Initialize+0x2a0>
    const TCPIP_MODULE_MAC_PIC32C_CONFIG* initData = (const TCPIP_MODULE_MAC_PIC32C_CONFIG*)((TCPIP_MAC_INIT*)init)->moduleData;
    bafe:	688c      	ldr	r4, [r1, #8]
	{
		return SYS_MODULE_OBJ_INVALID;     // not possible without dynamic memory!
	}

	if(initData == 0)
    bb00:	2c00      	cmp	r4, #0
    bb02:	f000 8138 	beq.w	bd76 <DRV_GMAC_Initialize+0x2a6>
	{
		return SYS_MODULE_OBJ_INVALID;     // not possible without init data!
	}

	if(initData->pPhyBase == 0 || initData->pPhyInit == 0)
    bb06:	6a23      	ldr	r3, [r4, #32]
    bb08:	2b00      	cmp	r3, #0
    bb0a:	f000 8137 	beq.w	bd7c <DRV_GMAC_Initialize+0x2ac>
    bb0e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    bb10:	2b00      	cmp	r3, #0
    bb12:	f000 8136 	beq.w	bd82 <DRV_GMAC_Initialize+0x2b2>
	{
		return SYS_MODULE_OBJ_INVALID;     // not possible without a PHY!
	}
	
	// init the MAC object
    memset(&pMACDrv->sGmacData, 0x0, sizeof(pMACDrv->sGmacData)); 
    bb16:	4dac      	ldr	r5, [pc, #688]	; (bdc8 <DRV_GMAC_Initialize+0x2f8>)
    bb18:	22e4      	movs	r2, #228	; 0xe4
    bb1a:	2100      	movs	r1, #0
    bb1c:	f105 0014 	add.w	r0, r5, #20
    bb20:	f016 f8b4 	bl	21c8c <memset>
    pMACDrv->sGmacData.hPhyClient = DRV_HANDLE_INVALID;
    bb24:	f04f 33ff 	mov.w	r3, #4294967295
    bb28:	612b      	str	r3, [r5, #16]
    pMACDrv->sGmacData.hPhySysObject = SYS_MODULE_OBJ_INVALID;
    bb2a:	60eb      	str	r3, [r5, #12]
    pMACDrv->sGmacData.sysStat = SYS_STATUS_UNINITIALIZED;
    bb2c:	2300      	movs	r3, #0
    bb2e:	752b      	strb	r3, [r5, #20]
	
    pMACDrv->sGmacData._macIx = macIx;
    bb30:	606b      	str	r3, [r5, #4]
    pMACDrv->sGmacData._phyIx = macIx;    // use the same index for the associated PHY
    bb32:	60ab      	str	r3, [r5, #8]
    pMACDrv->sGmacData._macFlags._linkPrev = 0;	
    bb34:	f04f 0200 	mov.w	r2, #0
    bb38:	f363 1204 	bfi	r2, r3, #4, #1
    bb3c:	75aa      	strb	r2, [r5, #22]

    // update interrupt source for GMAC priority queues
	DRV_PIC32CGMAC_LibSetInterruptSrc(pMACDrv);
    bb3e:	4628      	mov	r0, r5
    bb40:	f016 f804 	bl	21b4c <DRV_PIC32CGMAC_LibSetInterruptSrc>
    // use initialization data
    pMACDrv->sGmacData._AllocH = macControl->memH;
    bb44:	68fb      	ldr	r3, [r7, #12]
    bb46:	61ab      	str	r3, [r5, #24]
    pMACDrv->sGmacData._callocF = macControl->callocF;
    bb48:	687b      	ldr	r3, [r7, #4]
    bb4a:	61eb      	str	r3, [r5, #28]
    pMACDrv->sGmacData._freeF = macControl->freeF;
    bb4c:	68bb      	ldr	r3, [r7, #8]
    bb4e:	622b      	str	r3, [r5, #32]
    pMACDrv->sGmacData._dcptOffset = macControl->gapDcptOffset;
    bb50:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
    bb54:	f8a5 30ec 	strh.w	r3, [r5, #236]	; 0xec


    pMACDrv->sGmacData.pktAllocF = macControl->pktAllocF;
    bb58:	693b      	ldr	r3, [r7, #16]
    bb5a:	626b      	str	r3, [r5, #36]	; 0x24
    pMACDrv->sGmacData.pktFreeF = macControl->pktFreeF;
    bb5c:	697b      	ldr	r3, [r7, #20]
    bb5e:	62ab      	str	r3, [r5, #40]	; 0x28
    pMACDrv->sGmacData.pktAckF = macControl->pktAckF;
    bb60:	69bb      	ldr	r3, [r7, #24]
    bb62:	62eb      	str	r3, [r5, #44]	; 0x2c

    pMACDrv->sGmacData._synchF = macControl->synchF;
    bb64:	69fb      	ldr	r3, [r7, #28]
    bb66:	632b      	str	r3, [r5, #48]	; 0x30
	
    pMACDrv->sGmacData._controlFlags = macControl->controlFlags;
    bb68:	8efb      	ldrh	r3, [r7, #54]	; 0x36
    bb6a:	f8a5 30f4 	strh.w	r3, [r5, #244]	; 0xf4
    pMACDrv->sGmacData._dataOffset = (macControl->controlFlags & TCPIP_MAC_CONTROL_PAYLOAD_OFFSET_2) == 0 ? 0 : 2;
    bb6e:	f013 0f01 	tst.w	r3, #1
    bb72:	bf18      	it	ne
    bb74:	2602      	movne	r6, #2
    bb76:	f885 60f6 	strb.w	r6, [r5, #246]	; 0xf6
    pMACDrv->sGmacData._dataOffsetMask = (macControl->controlFlags & TCPIP_MAC_CONTROL_PAYLOAD_OFFSET_2) != 0 ? 0xfffffffc : 0xffffffff;
    bb7a:	8efb      	ldrh	r3, [r7, #54]	; 0x36
    bb7c:	f013 0f01 	tst.w	r3, #1
    bb80:	bf14      	ite	ne
    bb82:	f06f 0303 	mvnne.w	r3, #3
    bb86:	f04f 33ff 	moveq.w	r3, #4294967295
    bb8a:	462e      	mov	r6, r5
    bb8c:	f8c5 30f0 	str.w	r3, [r5, #240]	; 0xf0
    pMACDrv->sGmacData._txDiscard = false;
    bb90:	2300      	movs	r3, #0
    bb92:	f885 30f7 	strb.w	r3, [r5, #247]	; 0xf7
	// copy the configuration data
	pMACDrv->sGmacData.gmacConfig = *initData;	
    bb96:	35b8      	adds	r5, #184	; 0xb8
    bb98:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    bb9a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    bb9c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    bb9e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    bba0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    bba2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    bba4:	6823      	ldr	r3, [r4, #0]
    bba6:	602b      	str	r3, [r5, #0]
	
    DRV_GMAC_LibDescriptorsPoolAdd (pMACDrv, DRV_GMAC_DCPT_TYPE_RX);
    bba8:	2101      	movs	r1, #1
    bbaa:	4630      	mov	r0, r6
    bbac:	f014 ff50 	bl	20a50 <DRV_GMAC_LibDescriptorsPoolAdd>
    DRV_GMAC_LibDescriptorsPoolAdd (pMACDrv, DRV_GMAC_DCPT_TYPE_TX);
    bbb0:	2102      	movs	r1, #2
    bbb2:	4630      	mov	r0, r6
    bbb4:	f014 ff4c 	bl	20a50 <DRV_GMAC_LibDescriptorsPoolAdd>
    
	for(queueIdx = GMAC_QUE_0; queueIdx < DRV_GMAC_NUMBER_OF_QUEUES; queueIdx++)
	{
		if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt < DRV_GMAC_MIN_TX_DESCRIPTORS)
    bbb8:	f8b6 30c8 	ldrh.w	r3, [r6, #200]	; 0xc8
    bbbc:	2b00      	cmp	r3, #0
    bbbe:	f000 80e3 	beq.w	bd88 <DRV_GMAC_Initialize+0x2b8>
		{
			return SYS_MODULE_OBJ_INVALID; //return invalid than setting min dscp count
		}
        
        uint16_t rxBufferSize = pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].rxBufferSize;
    bbc2:	f8b6 30cc 	ldrh.w	r3, [r6, #204]	; 0xcc

		if(rxBufferSize < DRV_GMAC_MIN_RX_SIZE)
    bbc6:	2b3f      	cmp	r3, #63	; 0x3f
    bbc8:	f240 80e1 	bls.w	bd8e <DRV_GMAC_Initialize+0x2be>
        if(rxBufferSize > TCPIP_GMAC_RX_MAX_FRAME)
        {   // no need to exceed the max allowed RX frame
            rxBufferSize = TCPIP_GMAC_RX_MAX_FRAME;
        }
        // GMAC RX buffer size needs to be multiple of 64
        rxBufferSize = ((rxBufferSize + 63) / 64) * 64;
    bbcc:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
    bbd0:	bf28      	it	cs
    bbd2:	f44f 63c0 	movcs.w	r3, #1536	; 0x600
    bbd6:	333f      	adds	r3, #63	; 0x3f
        pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].rxBufferSize = rxBufferSize;
    bbd8:	487b      	ldr	r0, [pc, #492]	; (bdc8 <DRV_GMAC_Initialize+0x2f8>)
        rxBufferSize = ((rxBufferSize + 63) / 64) * 64;
    bbda:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
        pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].rxBufferSize = rxBufferSize;
    bbde:	f8a0 30cc 	strh.w	r3, [r0, #204]	; 0xcc
	}
	
    if(!DRV_PIC32CGMAC_LibSetPriorityToQueueNum(pMACDrv))
    bbe2:	f016 f883 	bl	21cec <DRV_PIC32CGMAC_LibSetPriorityToQueueNum>
    bbe6:	2800      	cmp	r0, #0
    bbe8:	f000 80d7 	beq.w	bd9a <DRV_GMAC_Initialize+0x2ca>
    {
        return SYS_MODULE_OBJ_INVALID; //return invalid
    }
        
	//set the MAC address received from system config
	memcpy((pMACDrv->sGmacData.gmacConfig.macAddress.v), (macControl->ifPhyAddress.v),sizeof(macControl->ifPhyAddress));	
    bbec:	4b76      	ldr	r3, [pc, #472]	; (bdc8 <DRV_GMAC_Initialize+0x2f8>)
    bbee:	463a      	mov	r2, r7
    bbf0:	f852 0f38 	ldr.w	r0, [r2, #56]!
    bbf4:	f8c3 00b8 	str.w	r0, [r3, #184]	; 0xb8
    bbf8:	8892      	ldrh	r2, [r2, #4]
    bbfa:	f8a3 20bc 	strh.w	r2, [r3, #188]	; 0xbc
	return (pMACDrv->sGmacData._synchF == 0) ? true : (*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_CREATE);
    bbfe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    bc00:	b12b      	cbz	r3, bc0e <DRV_GMAC_Initialize+0x13e>
    bc02:	2101      	movs	r1, #1
    bc04:	4871      	ldr	r0, [pc, #452]	; (bdcc <DRV_GMAC_Initialize+0x2fc>)
    bc06:	4798      	blx	r3
    bc08:	2800      	cmp	r0, #0
    bc0a:	f000 80c3 	beq.w	bd94 <DRV_GMAC_Initialize+0x2c4>
	while(1)
	{
		uint32_t rxfilter= 0;

		// start the initialization sequence
		DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, NULL);
    bc0e:	4c6e      	ldr	r4, [pc, #440]	; (bdc8 <DRV_GMAC_Initialize+0x2f8>)
    bc10:	2200      	movs	r2, #0
    bc12:	213f      	movs	r1, #63	; 0x3f
    bc14:	4620      	mov	r0, r4
    bc16:	f014 fbed 	bl	203f4 <DRV_PIC32CGMAC_LibSysInt_Disable>
	const DRV_ETHPHY_OBJECT_BASE* pPhyBase;	
	int phyIx = pMACDrv->sGmacData._phyIx;
	TCPIP_MAC_RES   initRes;
	DRV_ETHPHY_RESULT   phyInitRes;	

	pPhyBase =  pMACDrv->sGmacData.gmacConfig.pPhyBase; 
    bc1a:	f8d4 50d8 	ldr.w	r5, [r4, #216]	; 0xd8

	hPhySysObject = pPhyBase->DRV_ETHPHY_Initialize(phyIx,  (SYS_MODULE_INIT *)pMACDrv->sGmacData.gmacConfig.pPhyInit);
    bc1e:	8926      	ldrh	r6, [r4, #8]
    bc20:	682b      	ldr	r3, [r5, #0]
    bc22:	f8d4 10dc 	ldr.w	r1, [r4, #220]	; 0xdc
    bc26:	4630      	mov	r0, r6
    bc28:	4798      	blx	r3
	if ( hPhySysObject == SYS_MODULE_OBJ_INVALID )
    bc2a:	f1b0 3fff 	cmp.w	r0, #4294967295
    bc2e:	f000 8093 	beq.w	bd58 <DRV_GMAC_Initialize+0x288>
	{
		initRes = TCPIP_MAC_RES_PHY_INIT_FAIL;
		return initRes;
	}

	pMACDrv->sGmacData.hPhySysObject = hPhySysObject;
    bc32:	60e0      	str	r0, [r4, #12]
	hPhyClient = pPhyBase->DRV_ETHPHY_Open(phyIx, DRV_IO_INTENT_READWRITE);
    bc34:	696b      	ldr	r3, [r5, #20]
    bc36:	2103      	movs	r1, #3
    bc38:	4630      	mov	r0, r6
    bc3a:	4798      	blx	r3
	if ( DRV_HANDLE_INVALID == hPhyClient )
    bc3c:	f1b0 3fff 	cmp.w	r0, #4294967295
    bc40:	f000 808a 	beq.w	bd58 <DRV_GMAC_Initialize+0x288>
	{
		initRes = TCPIP_MAC_RES_PHY_INIT_FAIL;
		return initRes;
	}
	
	pMACDrv->sGmacData.hPhyClient = hPhyClient;
    bc44:	4622      	mov	r2, r4
    bc46:	6120      	str	r0, [r4, #16]
	phySetup.phyAddress = pMACDrv->sGmacData.gmacConfig.pPhyInit->phyAddress;
    bc48:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
    bc4c:	8919      	ldrh	r1, [r3, #8]
    bc4e:	9100      	str	r1, [sp, #0]
	phySetup.openFlags = pMACDrv->sGmacData.gmacConfig.ethFlags;
    bc50:	f8b4 10d2 	ldrh.w	r1, [r4, #210]	; 0xd2
    bc54:	f8ad 1004 	strh.w	r1, [sp, #4]
	phySetup.configFlags = pMACDrv->sGmacData.gmacConfig.pPhyInit->phyFlags;
    bc58:	7a99      	ldrb	r1, [r3, #10]
    bc5a:	f88d 1006 	strb.w	r1, [sp, #6]
	phySetup.macPauseType = DRV_GMAC_PAUSE_CPBL_MASK;
    bc5e:	210f      	movs	r1, #15
    bc60:	f88d 1007 	strb.w	r1, [sp, #7]
	phySetup.resetFunction = pMACDrv->sGmacData.gmacConfig.pPhyInit->resetFunction;
    bc64:	691b      	ldr	r3, [r3, #16]
    bc66:	9302      	str	r3, [sp, #8]
		
	phyInitRes = pPhyBase->DRV_ETHPHY_Setup(hPhyClient, &phySetup, &pMACDrv->sGmacData._linkResFlags);
    bc68:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    bc6a:	3234      	adds	r2, #52	; 0x34
    bc6c:	4669      	mov	r1, sp
    bc6e:	4798      	blx	r3
	
	if(phyInitRes < 0)
    bc70:	2800      	cmp	r0, #0
    bc72:	db71      	blt.n	bd58 <DRV_GMAC_Initialize+0x288>
		DRV_PIC32CGMAC_LibInit(pMACDrv);
    bc74:	4c54      	ldr	r4, [pc, #336]	; (bdc8 <DRV_GMAC_Initialize+0x2f8>)
    bc76:	4620      	mov	r0, r4
    bc78:	f00d fe0e 	bl	19898 <DRV_PIC32CGMAC_LibInit>
            hash.hash_value = -1; //Set 64-bit Hash value to all 1s, to receive all multi-cast
    bc7c:	f04f 32ff 	mov.w	r2, #4294967295
    bc80:	f04f 33ff 	mov.w	r3, #4294967295
    bc84:	e9cd 2300 	strd	r2, r3, [sp]
            hash.calculate_hash = false; // No hash calculation; directly set hash register
    bc88:	2300      	movs	r3, #0
    bc8a:	f88d 300c 	strb.w	r3, [sp, #12]
            DRV_PIC32CGMAC_LibRxFilterHash_Calculate(pMACDrv, &hash);
    bc8e:	4669      	mov	r1, sp
    bc90:	4620      	mov	r0, r4
    bc92:	f004 f967 	bl	ff64 <DRV_PIC32CGMAC_LibRxFilterHash_Calculate>
		rxfilter = (uint32_t)(GMAC_REGS->GMAC_NCFGR) & (~GMAC_FILT_ALL_FILTERS); 
    bc96:	4a4e      	ldr	r2, [pc, #312]	; (bdd0 <DRV_GMAC_Initialize+0x300>)
    bc98:	6853      	ldr	r3, [r2, #4]
    bc9a:	f023 5310 	bic.w	r3, r3, #603979776	; 0x24000000
    bc9e:	f423 73fc 	bic.w	r3, r3, #504	; 0x1f8
		GMAC_REGS->GMAC_NCFGR  = (rxfilter|gmacRxFilt) ;
    bca2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    bca6:	6053      	str	r3, [r2, #4]
        if(DRV_PIC32CGMAC_LibRxQueFilterInit(pMACDrv) != DRV_PIC32CGMAC_RES_OK)
    bca8:	4620      	mov	r0, r4
    bcaa:	f016 fac8 	bl	2223e <DRV_PIC32CGMAC_LibRxQueFilterInit>
    bcae:	2800      	cmp	r0, #0
    bcb0:	d152      	bne.n	bd58 <DRV_GMAC_Initialize+0x288>
		if(DRV_PIC32CGMAC_LibRxInit(pMACDrv) != DRV_PIC32CGMAC_RES_OK)
    bcb2:	4845      	ldr	r0, [pc, #276]	; (bdc8 <DRV_GMAC_Initialize+0x2f8>)
    bcb4:	f009 ff1c 	bl	15af0 <DRV_PIC32CGMAC_LibRxInit>
    bcb8:	2800      	cmp	r0, #0
    bcba:	d14d      	bne.n	bd58 <DRV_GMAC_Initialize+0x288>
		if(DRV_PIC32CGMAC_LibTxInit(pMACDrv) != DRV_PIC32CGMAC_RES_OK)
    bcbc:	4842      	ldr	r0, [pc, #264]	; (bdc8 <DRV_GMAC_Initialize+0x2f8>)
    bcbe:	f00d ff1f 	bl	19b00 <DRV_PIC32CGMAC_LibTxInit>
    bcc2:	2800      	cmp	r0, #0
    bcc4:	d148      	bne.n	bd58 <DRV_GMAC_Initialize+0x288>
            if(DRV_PIC32CGMAC_LibInitTransfer(pMACDrv,queueIdx) != DRV_PIC32CGMAC_RES_OK)
    bcc6:	2100      	movs	r1, #0
    bcc8:	483f      	ldr	r0, [pc, #252]	; (bdc8 <DRV_GMAC_Initialize+0x2f8>)
    bcca:	f00c fc21 	bl	18510 <DRV_PIC32CGMAC_LibInitTransfer>
    bcce:	4606      	mov	r6, r0
    bcd0:	2800      	cmp	r0, #0
    bcd2:	d165      	bne.n	bda0 <DRV_GMAC_Initialize+0x2d0>
        DRV_PIC32CGMAC_LibSysIntStatus_Clear(pMACDrv, GMAC_ALL_QUE_MASK);
    bcd4:	4d3c      	ldr	r5, [pc, #240]	; (bdc8 <DRV_GMAC_Initialize+0x2f8>)
    bcd6:	213f      	movs	r1, #63	; 0x3f
    bcd8:	4628      	mov	r0, r5
    bcda:	f014 f84f 	bl	1fd7c <DRV_PIC32CGMAC_LibSysIntStatus_Clear>
        DRV_PIC32CGMAC_LibSysInt_Enable(pMACDrv, GMAC_ALL_QUE_MASK);
    bcde:	213f      	movs	r1, #63	; 0x3f
    bce0:	4628      	mov	r0, r5
    bce2:	f014 f85f 	bl	1fda4 <DRV_PIC32CGMAC_LibSysInt_Enable>
		DRV_PIC32CGMAC_LibTransferEnable(pMACDrv); //enable Transmit and Receive of GMAC
    bce6:	4628      	mov	r0, r5
    bce8:	f014 fea2 	bl	20a30 <DRV_PIC32CGMAC_LibTransferEnable>
        if(DRV_GMAC_EventInit((DRV_HANDLE)pMACDrv, macControl->eventF, macControl->eventParam) != TCPIP_MAC_RES_OK)
    bcec:	462c      	mov	r4, r5
	if(_hEventMac == hMac)
    bcee:	4b39      	ldr	r3, [pc, #228]	; (bdd4 <DRV_GMAC_Initialize+0x304>)
    bcf0:	681b      	ldr	r3, [r3, #0]
    bcf2:	42ab      	cmp	r3, r5
    bcf4:	d01c      	beq.n	bd30 <DRV_GMAC_Initialize+0x260>
	else if(_hEventMac != 0)
    bcf6:	bb7b      	cbnz	r3, bd58 <DRV_GMAC_Initialize+0x288>
        if(DRV_GMAC_EventInit((DRV_HANDLE)pMACDrv, macControl->eventF, macControl->eventParam) != TCPIP_MAC_RES_OK)
    bcf8:	f8d7 8020 	ldr.w	r8, [r7, #32]
    bcfc:	6a7f      	ldr	r7, [r7, #36]	; 0x24
    DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, NULL);
    bcfe:	4d32      	ldr	r5, [pc, #200]	; (bdc8 <DRV_GMAC_Initialize+0x2f8>)
    bd00:	2200      	movs	r2, #0
    bd02:	213f      	movs	r1, #63	; 0x3f
    bd04:	4628      	mov	r0, r5
    bd06:	f014 fb75 	bl	203f4 <DRV_PIC32CGMAC_LibSysInt_Disable>
    DRV_PIC32CGMAC_LibSysIntStatus_Clear(pMACDrv, GMAC_ALL_QUE_MASK);
    bd0a:	213f      	movs	r1, #63	; 0x3f
    bd0c:	4628      	mov	r0, r5
    bd0e:	f014 f835 	bl	1fd7c <DRV_PIC32CGMAC_LibSysIntStatus_Clear>
	pDcpt->_TcpEnabledEvents = pDcpt->_TcpPendingEvents = TCPIP_MAC_EV_NONE;
    bd12:	2300      	movs	r3, #0
    bd14:	f8a5 304e 	strh.w	r3, [r5, #78]	; 0x4e
    bd18:	f8a5 304c 	strh.w	r3, [r5, #76]	; 0x4c
	pDcpt->_EthEnabledEvents = pDcpt->_EthPendingEvents = 0;
    bd1c:	f8a5 3052 	strh.w	r3, [r5, #82]	; 0x52
    bd20:	f8a5 3050 	strh.w	r3, [r5, #80]	; 0x50
	pDcpt->_TcpNotifyFnc = eventF;
    bd24:	f8c5 8054 	str.w	r8, [r5, #84]	; 0x54
	pDcpt->_TcpNotifyParam = eventParam;
    bd28:	65af      	str	r7, [r5, #88]	; 0x58
	_hEventMac = hMac;
    bd2a:	4b2a      	ldr	r3, [pc, #168]	; (bdd4 <DRV_GMAC_Initialize+0x304>)
    bd2c:	601c      	str	r4, [r3, #0]
	if(initRes != TCPIP_MAC_RES_OK)
    bd2e:	b99e      	cbnz	r6, bd58 <DRV_GMAC_Initialize+0x288>
	pMACDrv->sGmacData._macFlags._init = 1;	
    bd30:	4b25      	ldr	r3, [pc, #148]	; (bdc8 <DRV_GMAC_Initialize+0x2f8>)
    bd32:	7d9a      	ldrb	r2, [r3, #22]
    bd34:	f042 0201 	orr.w	r2, r2, #1
    bd38:	759a      	strb	r2, [r3, #22]
	pMACDrv->sGmacData.sysStat = SYS_STATUS_BUSY;
    bd3a:	2201      	movs	r2, #1
    bd3c:	751a      	strb	r2, [r3, #20]
    pMACDrv->sGmacData._rxStat.nRxErrorPackets = 0;
    bd3e:	2200      	movs	r2, #0
    bd40:	671a      	str	r2, [r3, #112]	; 0x70
    pMACDrv->sGmacData._rxStat.nRxFragmentErrors = -1;
    bd42:	f04f 31ff 	mov.w	r1, #4294967295
    bd46:	6759      	str	r1, [r3, #116]	; 0x74
    pMACDrv->sGmacData._rxStat.nRxPendBuffers = 0;
    bd48:	669a      	str	r2, [r3, #104]	; 0x68
    pMACDrv->sGmacData._rxStat.nRxSchedBuffers = 0;
    bd4a:	66da      	str	r2, [r3, #108]	; 0x6c
	return (SYS_MODULE_OBJ)pMACDrv;
    bd4c:	e000      	b.n	bd50 <DRV_GMAC_Initialize+0x280>
		return (SYS_MODULE_OBJ)pMACDrv;
    bd4e:	4c1e      	ldr	r4, [pc, #120]	; (bdc8 <DRV_GMAC_Initialize+0x2f8>)
}
    bd50:	4620      	mov	r0, r4
    bd52:	b004      	add	sp, #16
    bd54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		_MACDeinit(pMACDrv);
    bd58:	481b      	ldr	r0, [pc, #108]	; (bdc8 <DRV_GMAC_Initialize+0x2f8>)
    bd5a:	f006 f9c1 	bl	120e0 <_MACDeinit>
		return SYS_MODULE_OBJ_INVALID;
    bd5e:	f04f 34ff 	mov.w	r4, #4294967295
    bd62:	e7f5      	b.n	bd50 <DRV_GMAC_Initialize+0x280>
		return SYS_MODULE_OBJ_INVALID;      // no such type supported
    bd64:	f04f 34ff 	mov.w	r4, #4294967295
    bd68:	e7f2      	b.n	bd50 <DRV_GMAC_Initialize+0x280>
		return SYS_MODULE_OBJ_INVALID;     // have a client connected
    bd6a:	f04f 34ff 	mov.w	r4, #4294967295
    bd6e:	e7ef      	b.n	bd50 <DRV_GMAC_Initialize+0x280>
		return SYS_MODULE_OBJ_INVALID;     // not possible without dynamic memory!
    bd70:	f04f 34ff 	mov.w	r4, #4294967295
    bd74:	e7ec      	b.n	bd50 <DRV_GMAC_Initialize+0x280>
		return SYS_MODULE_OBJ_INVALID;     // not possible without init data!
    bd76:	f04f 34ff 	mov.w	r4, #4294967295
    bd7a:	e7e9      	b.n	bd50 <DRV_GMAC_Initialize+0x280>
		return SYS_MODULE_OBJ_INVALID;     // not possible without a PHY!
    bd7c:	f04f 34ff 	mov.w	r4, #4294967295
    bd80:	e7e6      	b.n	bd50 <DRV_GMAC_Initialize+0x280>
    bd82:	f04f 34ff 	mov.w	r4, #4294967295
    bd86:	e7e3      	b.n	bd50 <DRV_GMAC_Initialize+0x280>
			return SYS_MODULE_OBJ_INVALID; //return invalid than setting min dscp count
    bd88:	f04f 34ff 	mov.w	r4, #4294967295
    bd8c:	e7e0      	b.n	bd50 <DRV_GMAC_Initialize+0x280>
			return SYS_MODULE_OBJ_INVALID; //return invalid than setting min Rx buffer size
    bd8e:	f04f 34ff 	mov.w	r4, #4294967295
    bd92:	e7dd      	b.n	bd50 <DRV_GMAC_Initialize+0x280>
        return SYS_MODULE_OBJ_INVALID;     // failed to create synch lock
    bd94:	f04f 34ff 	mov.w	r4, #4294967295
    bd98:	e7da      	b.n	bd50 <DRV_GMAC_Initialize+0x280>
        return SYS_MODULE_OBJ_INVALID; //return invalid
    bd9a:	f04f 34ff 	mov.w	r4, #4294967295
    bd9e:	e7d7      	b.n	bd50 <DRV_GMAC_Initialize+0x280>
        DRV_PIC32CGMAC_LibSysIntStatus_Clear(pMACDrv, GMAC_ALL_QUE_MASK);
    bda0:	4d09      	ldr	r5, [pc, #36]	; (bdc8 <DRV_GMAC_Initialize+0x2f8>)
    bda2:	213f      	movs	r1, #63	; 0x3f
    bda4:	4628      	mov	r0, r5
    bda6:	f013 ffe9 	bl	1fd7c <DRV_PIC32CGMAC_LibSysIntStatus_Clear>
        DRV_PIC32CGMAC_LibSysInt_Enable(pMACDrv, GMAC_ALL_QUE_MASK);
    bdaa:	213f      	movs	r1, #63	; 0x3f
    bdac:	4628      	mov	r0, r5
    bdae:	f013 fff9 	bl	1fda4 <DRV_PIC32CGMAC_LibSysInt_Enable>
		DRV_PIC32CGMAC_LibTransferEnable(pMACDrv); //enable Transmit and Receive of GMAC
    bdb2:	4628      	mov	r0, r5
    bdb4:	f014 fe3c 	bl	20a30 <DRV_PIC32CGMAC_LibTransferEnable>
        if(DRV_GMAC_EventInit((DRV_HANDLE)pMACDrv, macControl->eventF, macControl->eventParam) != TCPIP_MAC_RES_OK)
    bdb8:	462c      	mov	r4, r5
	if(_hEventMac == hMac)
    bdba:	4b06      	ldr	r3, [pc, #24]	; (bdd4 <DRV_GMAC_Initialize+0x304>)
    bdbc:	681b      	ldr	r3, [r3, #0]
    bdbe:	42ab      	cmp	r3, r5
    bdc0:	d0ca      	beq.n	bd58 <DRV_GMAC_Initialize+0x288>
                initRes = TCPIP_MAC_RES_INIT_FAIL;
    bdc2:	f06f 0602 	mvn.w	r6, #2
    bdc6:	e796      	b.n	bcf6 <DRV_GMAC_Initialize+0x226>
    bdc8:	2000d8b8 	.word	0x2000d8b8
    bdcc:	2000d918 	.word	0x2000d918
    bdd0:	42000800 	.word	0x42000800
    bdd4:	2000dd14 	.word	0x2000dd14

Disassembly of section .text.TCPIP_TCP_FifoSizeAdjust%207:

0000bdd8 <TCPIP_TCP_FifoSizeAdjust>:
{
    bdd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bddc:	b085      	sub	sp, #20
    if((vFlags & (TCP_ADJUST_TX_ONLY | TCP_ADJUST_RX_ONLY)) == (TCP_ADJUST_TX_ONLY | TCP_ADJUST_RX_ONLY))
    bdde:	f003 0430 	and.w	r4, r3, #48	; 0x30
    bde2:	2c30      	cmp	r4, #48	; 0x30
    bde4:	f000 80d2 	beq.w	bf8c <TCPIP_TCP_FifoSizeAdjust+0x1b4>
    bde8:	461f      	mov	r7, r3
    bdea:	4615      	mov	r5, r2
    bdec:	460e      	mov	r6, r1
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
    bdee:	f014 f815 	bl	1fe1c <_TcpSocketChk>
    if(pSkt == 0)
    bdf2:	4604      	mov	r4, r0
    bdf4:	2800      	cmp	r0, #0
    bdf6:	f000 80cb 	beq.w	bf90 <TCPIP_TCP_FifoSizeAdjust+0x1b8>
    if(wMinTXSize < TCP_MIN_TX_BUFF_SIZE)
    bdfa:	2d19      	cmp	r5, #25
    bdfc:	bf38      	it	cc
    bdfe:	2519      	movcc	r5, #25
    oldTxSize = pSkt->txEnd - pSkt->txStart -1;
    be00:	6843      	ldr	r3, [r0, #4]
    be02:	6802      	ldr	r2, [r0, #0]
    be04:	1a9b      	subs	r3, r3, r2
    be06:	3b01      	subs	r3, #1
    be08:	b29b      	uxth	r3, r3
    oldRxSize = pSkt->rxEnd - pSkt->rxStart;
    be0a:	6982      	ldr	r2, [r0, #24]
    be0c:	6941      	ldr	r1, [r0, #20]
    be0e:	1a52      	subs	r2, r2, r1
    be10:	fa1f f982 	uxth.w	r9, r2
    if((vFlags & TCP_ADJUST_TX_ONLY) != 0)
    be14:	f017 0f10 	tst.w	r7, #16
    be18:	d121      	bne.n	be5e <TCPIP_TCP_FifoSizeAdjust+0x86>
    be1a:	2e19      	cmp	r6, #25
    be1c:	bf38      	it	cc
    be1e:	2619      	movcc	r6, #25
    else if((vFlags & TCP_ADJUST_RX_ONLY) != 0)
    be20:	f017 0f20 	tst.w	r7, #32
    be24:	d121      	bne.n	be6a <TCPIP_TCP_FifoSizeAdjust+0x92>
    else if(oldTxSize + oldRxSize > wMinRXSize + wMinTXSize)
    be26:	fa13 f282 	uxtah	r2, r3, r2
    be2a:	1971      	adds	r1, r6, r5
    be2c:	428a      	cmp	r2, r1
    be2e:	dd17      	ble.n	be60 <TCPIP_TCP_FifoSizeAdjust+0x88>
        uint16_t leftSpace = (oldTxSize + oldRxSize) - (wMinRXSize + wMinTXSize);
    be30:	eba9 0201 	sub.w	r2, r9, r1
    be34:	441a      	add	r2, r3
    be36:	b292      	uxth	r2, r2
        if((vFlags & equalMask) == 0 || (vFlags & equalMask) == equalMask)
    be38:	f017 0103 	ands.w	r1, r7, #3
    be3c:	d008      	beq.n	be50 <TCPIP_TCP_FifoSizeAdjust+0x78>
    be3e:	2903      	cmp	r1, #3
    be40:	d006      	beq.n	be50 <TCPIP_TCP_FifoSizeAdjust+0x78>
        else if((vFlags & equalMask) == TCP_ADJUST_GIVE_REST_TO_TX)
    be42:	2902      	cmp	r1, #2
            wMinTXSize += leftSpace;
    be44:	bf07      	ittee	eq
    be46:	18ad      	addeq	r5, r5, r2
    be48:	b2ad      	uxtheq	r5, r5
            wMinRXSize += leftSpace;
    be4a:	18b6      	addne	r6, r6, r2
    be4c:	b2b6      	uxthne	r6, r6
    be4e:	e007      	b.n	be60 <TCPIP_TCP_FifoSizeAdjust+0x88>
            wMinRXSize += (leftSpace + 1) >> 1;
    be50:	3201      	adds	r2, #1
    be52:	0852      	lsrs	r2, r2, #1
    be54:	4416      	add	r6, r2
    be56:	b2b6      	uxth	r6, r6
            wMinTXSize += (leftSpace +1) >> 1;
    be58:	4415      	add	r5, r2
    be5a:	b2ad      	uxth	r5, r5
    be5c:	e000      	b.n	be60 <TCPIP_TCP_FifoSizeAdjust+0x88>
        wMinRXSize = oldRxSize;
    be5e:	464e      	mov	r6, r9
    if(wMinTXSize >= oldTxSize)
    be60:	429d      	cmp	r5, r3
    be62:	d203      	bcs.n	be6c <TCPIP_TCP_FifoSizeAdjust+0x94>
        diffChange = oldTxSize - wMinTXSize;
    be64:	1b5b      	subs	r3, r3, r5
    be66:	b29b      	uxth	r3, r3
    be68:	e002      	b.n	be70 <TCPIP_TCP_FifoSizeAdjust+0x98>
        wMinTXSize = oldTxSize;
    be6a:	461d      	mov	r5, r3
        diffChange = wMinTXSize - oldTxSize;
    be6c:	1aeb      	subs	r3, r5, r3
    be6e:	b29b      	uxth	r3, r3
    if(diffChange >= TCP_MIN_BUFF_CHANGE)
    be70:	2b1f      	cmp	r3, #31
    be72:	d908      	bls.n	be86 <TCPIP_TCP_FifoSizeAdjust+0xae>
        newTxBuff = (uint8_t*)TCPIP_HEAP_Malloc(tcpHeapH, wMinTXSize + 1);
    be74:	4b93      	ldr	r3, [pc, #588]	; (c0c4 <TCPIP_TCP_FifoSizeAdjust+0x2ec>)
    be76:	6818      	ldr	r0, [r3, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
    be78:	6843      	ldr	r3, [r0, #4]
    be7a:	1c69      	adds	r1, r5, #1
    be7c:	4798      	blx	r3
        if(newTxBuff == 0)
    be7e:	4680      	mov	r8, r0
    be80:	b918      	cbnz	r0, be8a <TCPIP_TCP_FifoSizeAdjust+0xb2>
            return false;
    be82:	2000      	movs	r0, #0
    be84:	e0b9      	b.n	bffa <TCPIP_TCP_FifoSizeAdjust+0x222>
        newTxBuff = 0;
    be86:	f04f 0800 	mov.w	r8, #0
    if(wMinRXSize >= oldRxSize)
    be8a:	45b1      	cmp	r9, r6
        diffChange = wMinRXSize - oldRxSize;
    be8c:	bf94      	ite	ls
    be8e:	eba6 0909 	subls.w	r9, r6, r9
        diffChange = oldRxSize - wMinRXSize;
    be92:	eba9 0906 	subhi.w	r9, r9, r6
    be96:	fa1f f989 	uxth.w	r9, r9
    if(diffChange >= TCP_MIN_BUFF_CHANGE)
    be9a:	f1b9 0f1f 	cmp.w	r9, #31
    be9e:	d90d      	bls.n	bebc <TCPIP_TCP_FifoSizeAdjust+0xe4>
        newRxBuff = (uint8_t*)TCPIP_HEAP_Malloc(tcpHeapH, wMinRXSize + 1);
    bea0:	4b88      	ldr	r3, [pc, #544]	; (c0c4 <TCPIP_TCP_FifoSizeAdjust+0x2ec>)
    bea2:	6818      	ldr	r0, [r3, #0]
    bea4:	6843      	ldr	r3, [r0, #4]
    bea6:	1c71      	adds	r1, r6, #1
    bea8:	4798      	blx	r3
        if(newRxBuff == 0)
    beaa:	4682      	mov	sl, r0
    beac:	b940      	cbnz	r0, bec0 <TCPIP_TCP_FifoSizeAdjust+0xe8>
            TCPIP_HEAP_Free(tcpHeapH, newTxBuff);
    beae:	4b85      	ldr	r3, [pc, #532]	; (c0c4 <TCPIP_TCP_FifoSizeAdjust+0x2ec>)
    beb0:	6818      	ldr	r0, [r3, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
    beb2:	68c3      	ldr	r3, [r0, #12]
    beb4:	4641      	mov	r1, r8
    beb6:	4798      	blx	r3
            return false;
    beb8:	2000      	movs	r0, #0
    beba:	e09e      	b.n	bffa <TCPIP_TCP_FifoSizeAdjust+0x222>
        newRxBuff = 0;
    bebc:	f04f 0a00 	mov.w	sl, #0
    while(newTxBuff != 0)
    bec0:	f1b8 0f00 	cmp.w	r8, #0
    bec4:	f000 80aa 	beq.w	c01c <TCPIP_TCP_FifoSizeAdjust+0x244>
        if((vFlags & TCP_ADJUST_PRESERVE_TX) != 0)
    bec8:	f017 0f08 	tst.w	r7, #8
    becc:	f000 80b7 	beq.w	c03e <TCPIP_TCP_FifoSizeAdjust+0x266>
            txHead = pSkt->txHead;
    bed0:	68a3      	ldr	r3, [r4, #8]
            if(txHead < pSkt->txTail)
    bed2:	68e1      	ldr	r1, [r4, #12]
    bed4:	4299      	cmp	r1, r3
    bed6:	d925      	bls.n	bf24 <TCPIP_TCP_FifoSizeAdjust+0x14c>
                pendTxEnd = pSkt->txEnd - pSkt->txTail;
    bed8:	6862      	ldr	r2, [r4, #4]
    beda:	1a52      	subs	r2, r2, r1
    bedc:	b292      	uxth	r2, r2
    bede:	9201      	str	r2, [sp, #4]
                pendTxBeg = txHead - pSkt->txStart;
    bee0:	f8d4 b000 	ldr.w	fp, [r4]
    bee4:	eba3 090b 	sub.w	r9, r3, fp
    bee8:	fa1f f989 	uxth.w	r9, r9
            if((pendTxEnd + pendTxBeg) != 0)
    beec:	9a01      	ldr	r2, [sp, #4]
    beee:	eb12 0309 	adds.w	r3, r2, r9
    bef2:	f000 80e1 	beq.w	c0b8 <TCPIP_TCP_FifoSizeAdjust+0x2e0>
                if(pendTxEnd + pendTxBeg > wMinTXSize)
    bef6:	42ab      	cmp	r3, r5
    bef8:	f300 8085 	bgt.w	c006 <TCPIP_TCP_FifoSizeAdjust+0x22e>
                if(pendTxEnd)
    befc:	b9ea      	cbnz	r2, bf3a <TCPIP_TCP_FifoSizeAdjust+0x162>
                if(pendTxBeg)
    befe:	f1b9 0f00 	cmp.w	r9, #0
    bf02:	d11e      	bne.n	bf42 <TCPIP_TCP_FifoSizeAdjust+0x16a>
                txUnackOffs = pSkt->txUnackedTail - pSkt->txTail;
    bf04:	6922      	ldr	r2, [r4, #16]
    bf06:	68e3      	ldr	r3, [r4, #12]
    bf08:	eba2 0b03 	sub.w	fp, r2, r3
    bf0c:	fa1f fb8b 	uxth.w	fp, fp
                if(pSkt->txUnackedTail < pSkt->txTail)
    bf10:	429a      	cmp	r2, r3
    bf12:	f080 8099 	bcs.w	c048 <TCPIP_TCP_FifoSizeAdjust+0x270>
                    txUnackOffs += pSkt->txEnd - pSkt->txStart;
    bf16:	6863      	ldr	r3, [r4, #4]
    bf18:	6822      	ldr	r2, [r4, #0]
    bf1a:	1a9b      	subs	r3, r3, r2
    bf1c:	449b      	add	fp, r3
    bf1e:	fa1f fb8b 	uxth.w	fp, fp
    bf22:	e091      	b.n	c048 <TCPIP_TCP_FifoSizeAdjust+0x270>
            else if(txHead > pSkt->txTail)
    bf24:	4299      	cmp	r1, r3
    bf26:	f080 80c1 	bcs.w	c0ac <TCPIP_TCP_FifoSizeAdjust+0x2d4>
                pendTxBeg = txHead - pSkt->txTail;
    bf2a:	eba3 0901 	sub.w	r9, r3, r1
    bf2e:	fa1f f989 	uxth.w	r9, r9
                srcOffs = pSkt->txTail;
    bf32:	468b      	mov	fp, r1
                pendTxEnd = 0;
    bf34:	2300      	movs	r3, #0
    bf36:	9301      	str	r3, [sp, #4]
    bf38:	e7d8      	b.n	beec <TCPIP_TCP_FifoSizeAdjust+0x114>
                    memcpy(newTxBuff, pSkt->txTail, pendTxEnd);
    bf3a:	4640      	mov	r0, r8
    bf3c:	f015 f920 	bl	21180 <memcpy>
    bf40:	e7dd      	b.n	befe <TCPIP_TCP_FifoSizeAdjust+0x126>
                    memcpy(newTxBuff + pendTxEnd,  srcOffs, pendTxBeg);
    bf42:	464a      	mov	r2, r9
    bf44:	4659      	mov	r1, fp
    bf46:	9b01      	ldr	r3, [sp, #4]
    bf48:	eb08 0003 	add.w	r0, r8, r3
    bf4c:	f015 f918 	bl	21180 <memcpy>
    bf50:	e7d8      	b.n	bf04 <TCPIP_TCP_FifoSizeAdjust+0x12c>
    txUnackOffs = 0;
    bf52:	f04f 0b00 	mov.w	fp, #0
    pendTxEnd = pendTxBeg = 0;
    bf56:	46d9      	mov	r9, fp
    bf58:	f8cd b004 	str.w	fp, [sp, #4]
    bf5c:	e077      	b.n	c04e <TCPIP_TCP_FifoSizeAdjust+0x276>
            else if(rxHead < pSkt->rxTail)
    bf5e:	42b9      	cmp	r1, r7
    bf60:	d94e      	bls.n	c000 <TCPIP_TCP_FifoSizeAdjust+0x228>
                avlblRxEnd = pSkt->rxEnd + 1 - pSkt->rxTail;
    bf62:	69a3      	ldr	r3, [r4, #24]
    bf64:	3301      	adds	r3, #1
    bf66:	1a5b      	subs	r3, r3, r1
    bf68:	b29b      	uxth	r3, r3
    bf6a:	9302      	str	r3, [sp, #8]
                avlblRxBeg = rxHead - pSkt->rxStart;
    bf6c:	6963      	ldr	r3, [r4, #20]
    bf6e:	9303      	str	r3, [sp, #12]
    bf70:	1aff      	subs	r7, r7, r3
    bf72:	b2bf      	uxth	r7, r7
                srcOffs = pSkt->rxStart;
    bf74:	e087      	b.n	c086 <TCPIP_TCP_FifoSizeAdjust+0x2ae>
                    memcpy(newRxBuff, pSkt->rxTail, avlblRxEnd);
    bf76:	4650      	mov	r0, sl
    bf78:	f015 f902 	bl	21180 <memcpy>
    bf7c:	e08b      	b.n	c096 <TCPIP_TCP_FifoSizeAdjust+0x2be>
            _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
    bf7e:	2201      	movs	r2, #1
    bf80:	2110      	movs	r1, #16
    bf82:	4620      	mov	r0, r4
    bf84:	f7fb fe4e 	bl	7c24 <_TcpSend>
    return true;
    bf88:	2001      	movs	r0, #1
    bf8a:	e036      	b.n	bffa <TCPIP_TCP_FifoSizeAdjust+0x222>
        return false;
    bf8c:	2000      	movs	r0, #0
    bf8e:	e034      	b.n	bffa <TCPIP_TCP_FifoSizeAdjust+0x222>
        return false;
    bf90:	2000      	movs	r0, #0
    bf92:	e032      	b.n	bffa <TCPIP_TCP_FifoSizeAdjust+0x222>
    avlblRxEnd = avlblRxBeg = 0;
    bf94:	2700      	movs	r7, #0
    bf96:	9702      	str	r7, [sp, #8]
    if(newTxBuff)
    bf98:	f1b8 0f00 	cmp.w	r8, #0
    bf9c:	d04a      	beq.n	c034 <TCPIP_TCP_FifoSizeAdjust+0x25c>
        TCPIP_HEAP_Free(tcpHeapH, (void*)pSkt->txStart);
    bf9e:	4b49      	ldr	r3, [pc, #292]	; (c0c4 <TCPIP_TCP_FifoSizeAdjust+0x2ec>)
    bfa0:	6818      	ldr	r0, [r3, #0]
    bfa2:	68c3      	ldr	r3, [r0, #12]
    bfa4:	6821      	ldr	r1, [r4, #0]
    bfa6:	4798      	blx	r3
        pSkt->txStart =  newTxBuff;
    bfa8:	f8c4 8000 	str.w	r8, [r4]
        pSkt->txEnd = newTxBuff + wMinTXSize + 1;
    bfac:	3501      	adds	r5, #1
    bfae:	4445      	add	r5, r8
    bfb0:	6065      	str	r5, [r4, #4]
        pSkt->txTail = pSkt->txStart;
    bfb2:	f8c4 800c 	str.w	r8, [r4, #12]
        pSkt->txHead = pSkt->txStart + (pendTxEnd + pendTxBeg);
    bfb6:	9b01      	ldr	r3, [sp, #4]
    bfb8:	444b      	add	r3, r9
    bfba:	4443      	add	r3, r8
    bfbc:	60a3      	str	r3, [r4, #8]
        pSkt->txUnackedTail = pSkt->txTail + txUnackOffs;
    bfbe:	eb08 030b 	add.w	r3, r8, fp
    bfc2:	6123      	str	r3, [r4, #16]
        _TCPSetHalfFlushFlag(pSkt);
    bfc4:	4620      	mov	r0, r4
    bfc6:	f011 ff75 	bl	1deb4 <_TCPSetHalfFlushFlag>
    if(newRxBuff)
    bfca:	f1ba 0f00 	cmp.w	sl, #0
    bfce:	d00f      	beq.n	bff0 <TCPIP_TCP_FifoSizeAdjust+0x218>
        TCPIP_HEAP_Free(tcpHeapH, (void*)pSkt->rxStart);
    bfd0:	4b3c      	ldr	r3, [pc, #240]	; (c0c4 <TCPIP_TCP_FifoSizeAdjust+0x2ec>)
    bfd2:	6818      	ldr	r0, [r3, #0]
    bfd4:	68c3      	ldr	r3, [r0, #12]
    bfd6:	6961      	ldr	r1, [r4, #20]
    bfd8:	4798      	blx	r3
        pSkt->rxStart = newRxBuff;
    bfda:	f8c4 a014 	str.w	sl, [r4, #20]
        pSkt->rxEnd = newRxBuff + wMinRXSize;
    bfde:	4456      	add	r6, sl
    bfe0:	61a6      	str	r6, [r4, #24]
        pSkt->rxTail = pSkt->rxStart;
    bfe2:	f8c4 a020 	str.w	sl, [r4, #32]
        pSkt->rxHead = pSkt->rxStart + (avlblRxEnd + avlblRxBeg);
    bfe6:	9b02      	ldr	r3, [sp, #8]
    bfe8:	443b      	add	r3, r7
    bfea:	461f      	mov	r7, r3
    bfec:	4457      	add	r7, sl
    bfee:	61e7      	str	r7, [r4, #28]
        if(pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED)
    bff0:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
    bff4:	2b03      	cmp	r3, #3
    bff6:	d0c2      	beq.n	bf7e <TCPIP_TCP_FifoSizeAdjust+0x1a6>
    return true;
    bff8:	2001      	movs	r0, #1
}
    bffa:	b005      	add	sp, #20
    bffc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    avlblRxEnd = avlblRxBeg = 0;
    c000:	2700      	movs	r7, #0
    c002:	9702      	str	r7, [sp, #8]
    c004:	e7c8      	b.n	bf98 <TCPIP_TCP_FifoSizeAdjust+0x1c0>
        TCPIP_HEAP_Free(tcpHeapH, newRxBuff);
    c006:	4c2f      	ldr	r4, [pc, #188]	; (c0c4 <TCPIP_TCP_FifoSizeAdjust+0x2ec>)
    c008:	6820      	ldr	r0, [r4, #0]
    c00a:	68c3      	ldr	r3, [r0, #12]
    c00c:	4651      	mov	r1, sl
    c00e:	4798      	blx	r3
        TCPIP_HEAP_Free(tcpHeapH, newTxBuff);
    c010:	6820      	ldr	r0, [r4, #0]
    c012:	68c3      	ldr	r3, [r0, #12]
    c014:	4641      	mov	r1, r8
    c016:	4798      	blx	r3
        return false;
    c018:	2000      	movs	r0, #0
    c01a:	e7ee      	b.n	bffa <TCPIP_TCP_FifoSizeAdjust+0x222>
    while(adjustFail != true && newRxBuff != 0)
    c01c:	f1ba 0f00 	cmp.w	sl, #0
    c020:	d197      	bne.n	bf52 <TCPIP_TCP_FifoSizeAdjust+0x17a>
    txUnackOffs = 0;
    c022:	f04f 0b00 	mov.w	fp, #0
    pendTxEnd = pendTxBeg = 0;
    c026:	46d9      	mov	r9, fp
    c028:	f8cd b004 	str.w	fp, [sp, #4]
    avlblRxEnd = avlblRxBeg = 0;
    c02c:	465f      	mov	r7, fp
    c02e:	f8cd b008 	str.w	fp, [sp, #8]
    c032:	e7b1      	b.n	bf98 <TCPIP_TCP_FifoSizeAdjust+0x1c0>
    if(newRxBuff)
    c034:	f1ba 0f00 	cmp.w	sl, #0
    c038:	d1ca      	bne.n	bfd0 <TCPIP_TCP_FifoSizeAdjust+0x1f8>
    return true;
    c03a:	2001      	movs	r0, #1
    c03c:	e7dd      	b.n	bffa <TCPIP_TCP_FifoSizeAdjust+0x222>
    txUnackOffs = 0;
    c03e:	f04f 0b00 	mov.w	fp, #0
    pendTxEnd = pendTxBeg = 0;
    c042:	46d9      	mov	r9, fp
    c044:	f8cd b004 	str.w	fp, [sp, #4]
    while(adjustFail != true && newRxBuff != 0)
    c048:	f1ba 0f00 	cmp.w	sl, #0
    c04c:	d037      	beq.n	c0be <TCPIP_TCP_FifoSizeAdjust+0x2e6>
        if((vFlags & TCP_ADJUST_PRESERVE_RX) != 0)
    c04e:	f017 0f04 	tst.w	r7, #4
    c052:	d09f      	beq.n	bf94 <TCPIP_TCP_FifoSizeAdjust+0x1bc>
            rxHead = pSkt->rxHead;
    c054:	69e7      	ldr	r7, [r4, #28]
            if(pSkt->sHoleSize != -1)
    c056:	6d63      	ldr	r3, [r4, #84]	; 0x54
    c058:	f1b3 3fff 	cmp.w	r3, #4294967295
    c05c:	d00a      	beq.n	c074 <TCPIP_TCP_FifoSizeAdjust+0x29c>
                rxHead += pSkt->sHoleSize + pSkt->wFutureDataSize;
    c05e:	f8b4 2060 	ldrh.w	r2, [r4, #96]	; 0x60
    c062:	4413      	add	r3, r2
    c064:	441f      	add	r7, r3
                if(rxHead > pSkt->rxEnd)
    c066:	69a3      	ldr	r3, [r4, #24]
    c068:	42bb      	cmp	r3, r7
    c06a:	d203      	bcs.n	c074 <TCPIP_TCP_FifoSizeAdjust+0x29c>
                    rxHead -= pSkt->rxEnd - pSkt->rxStart + 1;
    c06c:	6962      	ldr	r2, [r4, #20]
    c06e:	1a9b      	subs	r3, r3, r2
    c070:	43db      	mvns	r3, r3
    c072:	441f      	add	r7, r3
            if(rxHead > pSkt->rxTail)
    c074:	6a21      	ldr	r1, [r4, #32]
    c076:	42b9      	cmp	r1, r7
    c078:	f4bf af71 	bcs.w	bf5e <TCPIP_TCP_FifoSizeAdjust+0x186>
                avlblRxBeg = rxHead - pSkt->rxTail;
    c07c:	1a7f      	subs	r7, r7, r1
    c07e:	b2bf      	uxth	r7, r7
                srcOffs = pSkt->rxTail;
    c080:	9103      	str	r1, [sp, #12]
                avlblRxEnd = 0;
    c082:	2300      	movs	r3, #0
    c084:	9302      	str	r3, [sp, #8]
            if((avlblRxEnd + avlblRxBeg) != 0)
    c086:	9a02      	ldr	r2, [sp, #8]
    c088:	19d3      	adds	r3, r2, r7
    c08a:	d085      	beq.n	bf98 <TCPIP_TCP_FifoSizeAdjust+0x1c0>
                if(avlblRxEnd + avlblRxBeg > wMinRXSize)
    c08c:	42b3      	cmp	r3, r6
    c08e:	dcba      	bgt.n	c006 <TCPIP_TCP_FifoSizeAdjust+0x22e>
                if(avlblRxEnd)
    c090:	2a00      	cmp	r2, #0
    c092:	f47f af70 	bne.w	bf76 <TCPIP_TCP_FifoSizeAdjust+0x19e>
                if(avlblRxBeg)
    c096:	2f00      	cmp	r7, #0
    c098:	f43f af7e 	beq.w	bf98 <TCPIP_TCP_FifoSizeAdjust+0x1c0>
                    memcpy(newRxBuff + avlblRxEnd, srcOffs, avlblRxBeg);
    c09c:	463a      	mov	r2, r7
    c09e:	9903      	ldr	r1, [sp, #12]
    c0a0:	9b02      	ldr	r3, [sp, #8]
    c0a2:	eb0a 0003 	add.w	r0, sl, r3
    c0a6:	f015 f86b 	bl	21180 <memcpy>
    c0aa:	e775      	b.n	bf98 <TCPIP_TCP_FifoSizeAdjust+0x1c0>
    txUnackOffs = 0;
    c0ac:	f04f 0b00 	mov.w	fp, #0
    pendTxEnd = pendTxBeg = 0;
    c0b0:	46d9      	mov	r9, fp
    c0b2:	f8cd b004 	str.w	fp, [sp, #4]
    c0b6:	e7c7      	b.n	c048 <TCPIP_TCP_FifoSizeAdjust+0x270>
    txUnackOffs = 0;
    c0b8:	f04f 0b00 	mov.w	fp, #0
    c0bc:	e7c4      	b.n	c048 <TCPIP_TCP_FifoSizeAdjust+0x270>
    avlblRxEnd = avlblRxBeg = 0;
    c0be:	2700      	movs	r7, #0
    c0c0:	9702      	str	r7, [sp, #8]
    c0c2:	e76c      	b.n	bf9e <TCPIP_TCP_FifoSizeAdjust+0x1c6>
    c0c4:	2000e394 	.word	0x2000e394

Disassembly of section .text.Hash_DRBG_Generate%208:

0000c0c8 <Hash_DRBG_Generate>:
    }
}

/* Returns: DRBG_SUCCESS, DRBG_NEED_RESEED, or DRBG_FAILURE */
static int Hash_DRBG_Generate(DRBG_internal* drbg, byte* out, word32 outSz)
{
    c0c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c0cc:	b0d7      	sub	sp, #348	; 0x15c
    wc_Sha256 sha[1];
#endif
    byte type;
    word32 reseedCtr;

    if (drbg->reseedCtr == RESEED_INTERVAL) {
    c0ce:	f8d0 b000 	ldr.w	fp, [r0]
    c0d2:	4bb0      	ldr	r3, [pc, #704]	; (c394 <Hash_DRBG_Generate+0x2cc>)
    c0d4:	459b      	cmp	fp, r3
    c0d6:	f000 813c 	beq.w	c352 <Hash_DRBG_Generate+0x28a>
    c0da:	4604      	mov	r4, r0
    c0dc:	460f      	mov	r7, r1
    c0de:	4690      	mov	r8, r2
        if (digest == NULL)
            return MEMORY_E;
    #else
        byte digest[WC_SHA256_DIGEST_SIZE];
    #endif
        type = drbgGenerateH;
    c0e0:	2303      	movs	r3, #3
    c0e2:	f88d 30db 	strb.w	r3, [sp, #219]	; 0xdb
        reseedCtr = drbg->reseedCtr;
    c0e6:	f8cd b0d4 	str.w	fp, [sp, #212]	; 0xd4
    if (outSz == 0) outSz = 1;
    c0ea:	2a00      	cmp	r2, #0
    c0ec:	f000 8135 	beq.w	c35a <Hash_DRBG_Generate+0x292>
    len = (outSz / OUTPUT_BLOCK_LEN) + ((outSz % OUTPUT_BLOCK_LEN) ? 1 : 0);
    c0f0:	f012 091f 	ands.w	r9, r2, #31
    c0f4:	bf18      	it	ne
    c0f6:	f04f 0901 	movne.w	r9, #1
    c0fa:	eb09 1952 	add.w	r9, r9, r2, lsr #5
    XMEMCPY(data, V, sizeof(data));
    c0fe:	f100 0508 	add.w	r5, r0, #8
    c102:	f10d 0c20 	add.w	ip, sp, #32
    c106:	f100 0e38 	add.w	lr, r0, #56	; 0x38
    c10a:	4666      	mov	r6, ip
    c10c:	6828      	ldr	r0, [r5, #0]
    c10e:	6869      	ldr	r1, [r5, #4]
    c110:	68aa      	ldr	r2, [r5, #8]
    c112:	68eb      	ldr	r3, [r5, #12]
    c114:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    c116:	3510      	adds	r5, #16
    c118:	46b4      	mov	ip, r6
    c11a:	4575      	cmp	r5, lr
    c11c:	d1f5      	bne.n	c10a <Hash_DRBG_Generate+0x42>
    c11e:	6828      	ldr	r0, [r5, #0]
    c120:	6030      	str	r0, [r6, #0]
    c122:	88aa      	ldrh	r2, [r5, #4]
    c124:	79ab      	ldrb	r3, [r5, #6]
    c126:	80b2      	strh	r2, [r6, #4]
    c128:	71b3      	strb	r3, [r6, #6]
    for (i = 0; i < len; i++) {
    c12a:	f1b9 0f00 	cmp.w	r9, #0
    c12e:	f300 812d 	bgt.w	c38c <Hash_DRBG_Generate+0x2c4>
    int ret = DRBG_FAILURE;
    c132:	2501      	movs	r5, #1
    c134:	e036      	b.n	c1a4 <Hash_DRBG_Generate+0xdc>
            ret = wc_Sha256Update(sha, data, sizeof(data));
    c136:	2237      	movs	r2, #55	; 0x37
    c138:	4651      	mov	r1, sl
    c13a:	a816      	add	r0, sp, #88	; 0x58
    c13c:	f005 fe8e 	bl	11e5c <wc_Sha256Update>
        if (ret == 0)
    c140:	4605      	mov	r5, r0
    c142:	bb60      	cbnz	r0, c19e <Hash_DRBG_Generate+0xd6>
            ret = wc_Sha256Final(sha, digest);
    c144:	4669      	mov	r1, sp
    c146:	a816      	add	r0, sp, #88	; 0x58
    c148:	f004 fcba 	bl	10ac0 <wc_Sha256Final>
    c14c:	4605      	mov	r5, r0
        wc_Sha256Free(sha);
    c14e:	a816      	add	r0, sp, #88	; 0x58
    c150:	f00f ff67 	bl	1c022 <wc_Sha256Free>
        if (ret == 0) {
    c154:	bb35      	cbnz	r5, c1a4 <Hash_DRBG_Generate+0xdc>
            XMEMCPY(&checkBlock, digest, sizeof(word32));
    c156:	9b00      	ldr	r3, [sp, #0]
            if (drbg->reseedCtr > 1 && checkBlock == drbg->lastBlock) {
    c158:	6822      	ldr	r2, [r4, #0]
    c15a:	2a01      	cmp	r2, #1
    c15c:	d902      	bls.n	c164 <Hash_DRBG_Generate+0x9c>
    c15e:	6862      	ldr	r2, [r4, #4]
    c160:	4293      	cmp	r3, r2
    c162:	d03b      	beq.n	c1dc <Hash_DRBG_Generate+0x114>
                drbg->matchCount = 0;
    c164:	2200      	movs	r2, #0
    c166:	f884 2080 	strb.w	r2, [r4, #128]	; 0x80
                drbg->lastBlock = checkBlock;
    c16a:	6063      	str	r3, [r4, #4]
            if (out != NULL && outSz != 0) {
    c16c:	b167      	cbz	r7, c188 <Hash_DRBG_Generate+0xc0>
    c16e:	f1b8 0f00 	cmp.w	r8, #0
    c172:	d009      	beq.n	c188 <Hash_DRBG_Generate+0xc0>
                if (outSz >= OUTPUT_BLOCK_LEN) {
    c174:	f1b8 0f1f 	cmp.w	r8, #31
    c178:	d83f      	bhi.n	c1fa <Hash_DRBG_Generate+0x132>
                    XMEMCPY(out, digest, outSz);
    c17a:	4642      	mov	r2, r8
    c17c:	4669      	mov	r1, sp
    c17e:	4638      	mov	r0, r7
    c180:	f014 fffe 	bl	21180 <memcpy>
                    outSz = 0;
    c184:	f04f 0800 	mov.w	r8, #0
    for (i = 0; i < len; i++) {
    c188:	3601      	adds	r6, #1
    c18a:	454e      	cmp	r6, r9
    c18c:	da0a      	bge.n	c1a4 <Hash_DRBG_Generate+0xdc>
        ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
    c18e:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
    c190:	6fa1      	ldr	r1, [r4, #120]	; 0x78
    c192:	a816      	add	r0, sp, #88	; 0x58
    c194:	f00f f928 	bl	1b3e8 <wc_InitSha256_ex>
        if (ret == 0)
    c198:	4605      	mov	r5, r0
    c19a:	2800      	cmp	r0, #0
    c19c:	d0cb      	beq.n	c136 <Hash_DRBG_Generate+0x6e>
        wc_Sha256Free(sha);
    c19e:	a816      	add	r0, sp, #88	; 0x58
    c1a0:	f00f ff3f 	bl	1c022 <wc_Sha256Free>
#ifndef WOLFSSL_NO_FORCE_ZERO
/* This routine fills the first len bytes of the memory area pointed by mem
   with zeros. It ensures compiler optimizations doesn't skip it  */
WC_STATIC WC_INLINE void ForceZero(const void* mem, word32 len)
{
    volatile byte* z = (volatile byte*)mem;
    c1a4:	aa08      	add	r2, sp, #32
    for (w = (volatile word64*)z; len >= sizeof(*w); len -= sizeof(*w))
        *w++ = 0;
    z = (volatile byte*)w;
#endif

    while (len--) *z++ = 0;
    c1a6:	2000      	movs	r0, #0
    c1a8:	f10d 0157 	add.w	r1, sp, #87	; 0x57
    c1ac:	4613      	mov	r3, r2
    c1ae:	f803 0b01 	strb.w	r0, [r3], #1
    c1b2:	461a      	mov	r2, r3
    c1b4:	428b      	cmp	r3, r1
    c1b6:	d1f9      	bne.n	c1ac <Hash_DRBG_Generate+0xe4>

        ret = Hash_gen(drbg, out, outSz, drbg->V);
        if (ret == DRBG_SUCCESS) {
    c1b8:	2d00      	cmp	r5, #0
    c1ba:	d043      	beq.n	c244 <Hash_DRBG_Generate+0x17c>
    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
    c1bc:	2501      	movs	r5, #1
    volatile byte* z = (volatile byte*)mem;
    c1be:	aa16      	add	r2, sp, #88	; 0x58
    while (len--) *z++ = 0;
    c1c0:	2000      	movs	r0, #0
    c1c2:	a91e      	add	r1, sp, #120	; 0x78
    c1c4:	4613      	mov	r3, r2
    c1c6:	f803 0b01 	strb.w	r0, [r3], #1
    c1ca:	461a      	mov	r2, r3
    c1cc:	428b      	cmp	r3, r1
    c1ce:	d1f9      	bne.n	c1c4 <Hash_DRBG_Generate+0xfc>
    #ifdef WC_ASYNC_ENABLE_SHA256
        FREE_VAR(digest, drbg->heap);
    #endif
    }

    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
    c1d0:	1c28      	adds	r0, r5, #0
    c1d2:	bf18      	it	ne
    c1d4:	2001      	movne	r0, #1
}
    c1d6:	b057      	add	sp, #348	; 0x15c
    c1d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if (drbg->matchCount == 1) {
    c1dc:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
    c1e0:	2b01      	cmp	r3, #1
    c1e2:	f000 80b8 	beq.w	c356 <Hash_DRBG_Generate+0x28e>
                    if (i == (len-1)) {
    c1e6:	f109 33ff 	add.w	r3, r9, #4294967295
    c1ea:	42b3      	cmp	r3, r6
                        len++;
    c1ec:	bf08      	it	eq
    c1ee:	f109 0901 	addeq.w	r9, r9, #1
                    drbg->matchCount = 1;
    c1f2:	2301      	movs	r3, #1
    c1f4:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
    c1f8:	e7b8      	b.n	c16c <Hash_DRBG_Generate+0xa4>
                    XMEMCPY(out, digest, OUTPUT_BLOCK_LEN);
    c1fa:	46ec      	mov	ip, sp
    c1fc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    c200:	6038      	str	r0, [r7, #0]
    c202:	6079      	str	r1, [r7, #4]
    c204:	60ba      	str	r2, [r7, #8]
    c206:	60fb      	str	r3, [r7, #12]
    c208:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    c20c:	6138      	str	r0, [r7, #16]
    c20e:	6179      	str	r1, [r7, #20]
    c210:	61ba      	str	r2, [r7, #24]
    c212:	61fb      	str	r3, [r7, #28]
                    outSz -= OUTPUT_BLOCK_LEN;
    c214:	f1a8 0820 	sub.w	r8, r8, #32
                    out += OUTPUT_BLOCK_LEN;
    c218:	3720      	adds	r7, #32
        data[i]++;
    c21a:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    c21e:	3301      	adds	r3, #1
    c220:	b2db      	uxtb	r3, r3
    c222:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36
        if (data[i] != 0) break;
    c226:	2b00      	cmp	r3, #0
    c228:	d1ae      	bne.n	c188 <Hash_DRBG_Generate+0xc0>
    c22a:	f10d 0256 	add.w	r2, sp, #86	; 0x56
    c22e:	4651      	mov	r1, sl
        data[i]++;
    c230:	f812 3d01 	ldrb.w	r3, [r2, #-1]!
    c234:	3301      	adds	r3, #1
    c236:	b2db      	uxtb	r3, r3
    c238:	7013      	strb	r3, [r2, #0]
        if (data[i] != 0) break;
    c23a:	2b00      	cmp	r3, #0
    c23c:	d1a4      	bne.n	c188 <Hash_DRBG_Generate+0xc0>
    for (i = dataSz - 1; i >= 0; i--)
    c23e:	428a      	cmp	r2, r1
    c240:	d1f6      	bne.n	c230 <Hash_DRBG_Generate+0x168>
    c242:	e7a1      	b.n	c188 <Hash_DRBG_Generate+0xc0>
            ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
    c244:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
    c246:	6fa1      	ldr	r1, [r4, #120]	; 0x78
    c248:	a837      	add	r0, sp, #220	; 0xdc
    c24a:	f00f f8cd 	bl	1b3e8 <wc_InitSha256_ex>
            if (ret == 0)
    c24e:	4605      	mov	r5, r0
    c250:	b130      	cbz	r0, c260 <Hash_DRBG_Generate+0x198>
            wc_Sha256Free(sha);
    c252:	a837      	add	r0, sp, #220	; 0xdc
    c254:	f00f fee5 	bl	1c022 <wc_Sha256Free>
            drbg->reseedCtr++;
    c258:	6823      	ldr	r3, [r4, #0]
    c25a:	3301      	adds	r3, #1
    c25c:	6023      	str	r3, [r4, #0]
    c25e:	e7ae      	b.n	c1be <Hash_DRBG_Generate+0xf6>
                ret = wc_Sha256Update(sha, &type, sizeof(type));
    c260:	2201      	movs	r2, #1
    c262:	f10d 01db 	add.w	r1, sp, #219	; 0xdb
    c266:	a837      	add	r0, sp, #220	; 0xdc
    c268:	f005 fdf8 	bl	11e5c <wc_Sha256Update>
            if (ret == 0)
    c26c:	4605      	mov	r5, r0
    c26e:	2800      	cmp	r0, #0
    c270:	d1ef      	bne.n	c252 <Hash_DRBG_Generate+0x18a>
                ret = wc_Sha256Update(sha, drbg->V, sizeof(drbg->V));
    c272:	2237      	movs	r2, #55	; 0x37
    c274:	f104 0108 	add.w	r1, r4, #8
    c278:	a837      	add	r0, sp, #220	; 0xdc
    c27a:	f005 fdef 	bl	11e5c <wc_Sha256Update>
            if (ret == 0)
    c27e:	4605      	mov	r5, r0
    c280:	2800      	cmp	r0, #0
    c282:	d1e6      	bne.n	c252 <Hash_DRBG_Generate+0x18a>
                ret = wc_Sha256Final(sha, digest);
    c284:	a916      	add	r1, sp, #88	; 0x58
    c286:	a837      	add	r0, sp, #220	; 0xdc
    c288:	f004 fc1a 	bl	10ac0 <wc_Sha256Final>
    c28c:	4605      	mov	r5, r0
            wc_Sha256Free(sha);
    c28e:	a837      	add	r0, sp, #220	; 0xdc
    c290:	f00f fec7 	bl	1c022 <wc_Sha256Free>
            if (ret == 0) {
    c294:	2d00      	cmp	r5, #0
    c296:	d1df      	bne.n	c258 <Hash_DRBG_Generate+0x190>
    c298:	f104 023f 	add.w	r2, r4, #63	; 0x3f
    c29c:	f10d 0777 	add.w	r7, sp, #119	; 0x77
    c2a0:	f10d 0e58 	add.w	lr, sp, #88	; 0x58
    c2a4:	4616      	mov	r6, r2
    word16 carry = 0;
    c2a6:	2100      	movs	r1, #0
    c2a8:	e000      	b.n	c2ac <Hash_DRBG_Generate+0x1e4>
        for (sIdx = sLen - 1, dIdx = dLen - 1; sIdx >= 0; dIdx--, sIdx--) {
    c2aa:	4607      	mov	r7, r0
            carry += (word16)d[dIdx] + (word16)s[sIdx];
    c2ac:	4638      	mov	r0, r7
    c2ae:	f816 3d01 	ldrb.w	r3, [r6, #-1]!
    c2b2:	f810 c901 	ldrb.w	ip, [r0], #-1
    c2b6:	4463      	add	r3, ip
    c2b8:	440b      	add	r3, r1
            d[dIdx] = (byte)carry;
    c2ba:	7033      	strb	r3, [r6, #0]
            carry >>= 8;
    c2bc:	f3c3 210f 	ubfx	r1, r3, #8, #16
        for (sIdx = sLen - 1, dIdx = dLen - 1; sIdx >= 0; dIdx--, sIdx--) {
    c2c0:	4577      	cmp	r7, lr
    c2c2:	d1f2      	bne.n	c2aa <Hash_DRBG_Generate+0x1e2>
        for (; carry != 0 && dIdx >= 0; dIdx--) {
    c2c4:	b161      	cbz	r1, c2e0 <Hash_DRBG_Generate+0x218>
    c2c6:	f104 001f 	add.w	r0, r4, #31
    c2ca:	f104 0608 	add.w	r6, r4, #8
            carry += (word16)d[dIdx];
    c2ce:	f810 3d01 	ldrb.w	r3, [r0, #-1]!
    c2d2:	440b      	add	r3, r1
    c2d4:	b29b      	uxth	r3, r3
            d[dIdx] = (byte)carry;
    c2d6:	7003      	strb	r3, [r0, #0]
        for (; carry != 0 && dIdx >= 0; dIdx--) {
    c2d8:	0a19      	lsrs	r1, r3, #8
    c2da:	d001      	beq.n	c2e0 <Hash_DRBG_Generate+0x218>
    c2dc:	42b0      	cmp	r0, r6
    c2de:	d1f6      	bne.n	c2ce <Hash_DRBG_Generate+0x206>
        for (sIdx = sLen - 1, dIdx = dLen - 1; sIdx >= 0; dIdx--, sIdx--) {
    c2e0:	f104 0008 	add.w	r0, r4, #8
    c2e4:	4611      	mov	r1, r2
    word16 carry = 0;
    c2e6:	2300      	movs	r3, #0
            carry += (word16)d[dIdx] + (word16)s[sIdx];
    c2e8:	f811 6c01 	ldrb.w	r6, [r1, #-1]
    c2ec:	f891 7036 	ldrb.w	r7, [r1, #54]	; 0x36
    c2f0:	443e      	add	r6, r7
    c2f2:	4433      	add	r3, r6
            d[dIdx] = (byte)carry;
    c2f4:	f801 3d01 	strb.w	r3, [r1, #-1]!
            carry >>= 8;
    c2f8:	f3c3 230f 	ubfx	r3, r3, #8, #16
        for (sIdx = sLen - 1, dIdx = dLen - 1; sIdx >= 0; dIdx--, sIdx--) {
    c2fc:	4281      	cmp	r1, r0
    c2fe:	d1f3      	bne.n	c2e8 <Hash_DRBG_Generate+0x220>
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
    c300:	ea4f 231b 	mov.w	r3, fp, lsr #8
    c304:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
    c308:	ea4f 210b 	mov.w	r1, fp, lsl #8
    c30c:	f001 21ff 	and.w	r1, r1, #4278255360	; 0xff00ff00
    c310:	430b      	orrs	r3, r1
        return (x << y) | (x >> (sizeof(y) * 8 - y));
    c312:	ea4f 4333 	mov.w	r3, r3, ror #16
                reseedCtr = ByteReverseWord32(reseedCtr);
    c316:	9335      	str	r3, [sp, #212]	; 0xd4
        for (sIdx = sLen - 1, dIdx = dLen - 1; sIdx >= 0; dIdx--, sIdx--) {
    c318:	ae36      	add	r6, sp, #216	; 0xd8
    c31a:	f104 0c3b 	add.w	ip, r4, #59	; 0x3b
    word16 carry = 0;
    c31e:	2300      	movs	r3, #0
            carry += (word16)d[dIdx] + (word16)s[sIdx];
    c320:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
    c324:	f816 7d01 	ldrb.w	r7, [r6, #-1]!
    c328:	4439      	add	r1, r7
    c32a:	440b      	add	r3, r1
            d[dIdx] = (byte)carry;
    c32c:	7013      	strb	r3, [r2, #0]
            carry >>= 8;
    c32e:	f3c3 230f 	ubfx	r3, r3, #8, #16
        for (sIdx = sLen - 1, dIdx = dLen - 1; sIdx >= 0; dIdx--, sIdx--) {
    c332:	4594      	cmp	ip, r2
    c334:	d1f4      	bne.n	c320 <Hash_DRBG_Generate+0x258>
        for (; carry != 0 && dIdx >= 0; dIdx--) {
    c336:	2b00      	cmp	r3, #0
    c338:	d08e      	beq.n	c258 <Hash_DRBG_Generate+0x190>
    c33a:	f104 023b 	add.w	r2, r4, #59	; 0x3b
            carry += (word16)d[dIdx];
    c33e:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
    c342:	440b      	add	r3, r1
    c344:	b29b      	uxth	r3, r3
            d[dIdx] = (byte)carry;
    c346:	7013      	strb	r3, [r2, #0]
        for (; carry != 0 && dIdx >= 0; dIdx--) {
    c348:	0a1b      	lsrs	r3, r3, #8
    c34a:	d085      	beq.n	c258 <Hash_DRBG_Generate+0x190>
    c34c:	4282      	cmp	r2, r0
    c34e:	d1f6      	bne.n	c33e <Hash_DRBG_Generate+0x276>
    c350:	e782      	b.n	c258 <Hash_DRBG_Generate+0x190>
        return DRBG_NEED_RESEED;
    c352:	2002      	movs	r0, #2
    c354:	e73f      	b.n	c1d6 <Hash_DRBG_Generate+0x10e>
                    return DRBG_CONT_FAILURE;
    c356:	2503      	movs	r5, #3
    c358:	e731      	b.n	c1be <Hash_DRBG_Generate+0xf6>
    XMEMCPY(data, V, sizeof(data));
    c35a:	f100 0508 	add.w	r5, r0, #8
    c35e:	f10d 0c20 	add.w	ip, sp, #32
    c362:	f100 0e38 	add.w	lr, r0, #56	; 0x38
    c366:	4666      	mov	r6, ip
    c368:	6828      	ldr	r0, [r5, #0]
    c36a:	6869      	ldr	r1, [r5, #4]
    c36c:	68aa      	ldr	r2, [r5, #8]
    c36e:	68eb      	ldr	r3, [r5, #12]
    c370:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    c372:	3510      	adds	r5, #16
    c374:	46b4      	mov	ip, r6
    c376:	4575      	cmp	r5, lr
    c378:	d1f5      	bne.n	c366 <Hash_DRBG_Generate+0x29e>
    c37a:	6828      	ldr	r0, [r5, #0]
    c37c:	6030      	str	r0, [r6, #0]
    c37e:	88aa      	ldrh	r2, [r5, #4]
    c380:	79ab      	ldrb	r3, [r5, #6]
    c382:	80b2      	strh	r2, [r6, #4]
    c384:	71b3      	strb	r3, [r6, #6]
    if (outSz == 0) outSz = 1;
    c386:	f04f 0801 	mov.w	r8, #1
    len = (outSz / OUTPUT_BLOCK_LEN) + ((outSz % OUTPUT_BLOCK_LEN) ? 1 : 0);
    c38a:	46c1      	mov	r9, r8
    c38c:	2600      	movs	r6, #0
            ret = wc_Sha256Update(sha, data, sizeof(data));
    c38e:	f10d 0a20 	add.w	sl, sp, #32
    c392:	e6fc      	b.n	c18e <Hash_DRBG_Generate+0xc6>
    c394:	000f4240 	.word	0x000f4240

Disassembly of section .text%209:

0000c398 <__udivmoddi4>:
    c398:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    c39c:	9e08      	ldr	r6, [sp, #32]
    c39e:	4604      	mov	r4, r0
    c3a0:	4688      	mov	r8, r1
    c3a2:	2b00      	cmp	r3, #0
    c3a4:	f040 8085 	bne.w	c4b2 <__udivmoddi4+0x11a>
    c3a8:	428a      	cmp	r2, r1
    c3aa:	4615      	mov	r5, r2
    c3ac:	d948      	bls.n	c440 <__udivmoddi4+0xa8>
    c3ae:	fab2 f282 	clz	r2, r2
    c3b2:	b14a      	cbz	r2, c3c8 <__udivmoddi4+0x30>
    c3b4:	f1c2 0720 	rsb	r7, r2, #32
    c3b8:	fa01 f302 	lsl.w	r3, r1, r2
    c3bc:	fa20 f707 	lsr.w	r7, r0, r7
    c3c0:	4095      	lsls	r5, r2
    c3c2:	ea47 0803 	orr.w	r8, r7, r3
    c3c6:	4094      	lsls	r4, r2
    c3c8:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    c3cc:	0c23      	lsrs	r3, r4, #16
    c3ce:	fbb8 f7fe 	udiv	r7, r8, lr
    c3d2:	fa1f fc85 	uxth.w	ip, r5
    c3d6:	fb0e 8817 	mls	r8, lr, r7, r8
    c3da:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
    c3de:	fb07 f10c 	mul.w	r1, r7, ip
    c3e2:	4299      	cmp	r1, r3
    c3e4:	d909      	bls.n	c3fa <__udivmoddi4+0x62>
    c3e6:	18eb      	adds	r3, r5, r3
    c3e8:	f107 30ff 	add.w	r0, r7, #4294967295
    c3ec:	f080 80e3 	bcs.w	c5b6 <__udivmoddi4+0x21e>
    c3f0:	4299      	cmp	r1, r3
    c3f2:	f240 80e0 	bls.w	c5b6 <__udivmoddi4+0x21e>
    c3f6:	3f02      	subs	r7, #2
    c3f8:	442b      	add	r3, r5
    c3fa:	1a5b      	subs	r3, r3, r1
    c3fc:	b2a4      	uxth	r4, r4
    c3fe:	fbb3 f0fe 	udiv	r0, r3, lr
    c402:	fb0e 3310 	mls	r3, lr, r0, r3
    c406:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
    c40a:	fb00 fc0c 	mul.w	ip, r0, ip
    c40e:	45a4      	cmp	ip, r4
    c410:	d909      	bls.n	c426 <__udivmoddi4+0x8e>
    c412:	192c      	adds	r4, r5, r4
    c414:	f100 33ff 	add.w	r3, r0, #4294967295
    c418:	f080 80cb 	bcs.w	c5b2 <__udivmoddi4+0x21a>
    c41c:	45a4      	cmp	ip, r4
    c41e:	f240 80c8 	bls.w	c5b2 <__udivmoddi4+0x21a>
    c422:	3802      	subs	r0, #2
    c424:	442c      	add	r4, r5
    c426:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
    c42a:	eba4 040c 	sub.w	r4, r4, ip
    c42e:	2700      	movs	r7, #0
    c430:	b11e      	cbz	r6, c43a <__udivmoddi4+0xa2>
    c432:	40d4      	lsrs	r4, r2
    c434:	2300      	movs	r3, #0
    c436:	e9c6 4300 	strd	r4, r3, [r6]
    c43a:	4639      	mov	r1, r7
    c43c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    c440:	2a00      	cmp	r2, #0
    c442:	d053      	beq.n	c4ec <__udivmoddi4+0x154>
    c444:	fab2 f282 	clz	r2, r2
    c448:	2a00      	cmp	r2, #0
    c44a:	f040 80b6 	bne.w	c5ba <__udivmoddi4+0x222>
    c44e:	1b49      	subs	r1, r1, r5
    c450:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    c454:	fa1f f885 	uxth.w	r8, r5
    c458:	2701      	movs	r7, #1
    c45a:	fbb1 fcfe 	udiv	ip, r1, lr
    c45e:	0c23      	lsrs	r3, r4, #16
    c460:	fb0e 111c 	mls	r1, lr, ip, r1
    c464:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    c468:	fb08 f10c 	mul.w	r1, r8, ip
    c46c:	4299      	cmp	r1, r3
    c46e:	d907      	bls.n	c480 <__udivmoddi4+0xe8>
    c470:	18eb      	adds	r3, r5, r3
    c472:	f10c 30ff 	add.w	r0, ip, #4294967295
    c476:	d202      	bcs.n	c47e <__udivmoddi4+0xe6>
    c478:	4299      	cmp	r1, r3
    c47a:	f200 80ec 	bhi.w	c656 <__udivmoddi4+0x2be>
    c47e:	4684      	mov	ip, r0
    c480:	1a59      	subs	r1, r3, r1
    c482:	b2a3      	uxth	r3, r4
    c484:	fbb1 f0fe 	udiv	r0, r1, lr
    c488:	fb0e 1410 	mls	r4, lr, r0, r1
    c48c:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
    c490:	fb08 f800 	mul.w	r8, r8, r0
    c494:	45a0      	cmp	r8, r4
    c496:	d907      	bls.n	c4a8 <__udivmoddi4+0x110>
    c498:	192c      	adds	r4, r5, r4
    c49a:	f100 33ff 	add.w	r3, r0, #4294967295
    c49e:	d202      	bcs.n	c4a6 <__udivmoddi4+0x10e>
    c4a0:	45a0      	cmp	r8, r4
    c4a2:	f200 80dc 	bhi.w	c65e <__udivmoddi4+0x2c6>
    c4a6:	4618      	mov	r0, r3
    c4a8:	eba4 0408 	sub.w	r4, r4, r8
    c4ac:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
    c4b0:	e7be      	b.n	c430 <__udivmoddi4+0x98>
    c4b2:	428b      	cmp	r3, r1
    c4b4:	d908      	bls.n	c4c8 <__udivmoddi4+0x130>
    c4b6:	2e00      	cmp	r6, #0
    c4b8:	d078      	beq.n	c5ac <__udivmoddi4+0x214>
    c4ba:	2700      	movs	r7, #0
    c4bc:	e9c6 0100 	strd	r0, r1, [r6]
    c4c0:	4638      	mov	r0, r7
    c4c2:	4639      	mov	r1, r7
    c4c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    c4c8:	fab3 f783 	clz	r7, r3
    c4cc:	b97f      	cbnz	r7, c4ee <__udivmoddi4+0x156>
    c4ce:	428b      	cmp	r3, r1
    c4d0:	d302      	bcc.n	c4d8 <__udivmoddi4+0x140>
    c4d2:	4282      	cmp	r2, r0
    c4d4:	f200 80bd 	bhi.w	c652 <__udivmoddi4+0x2ba>
    c4d8:	1a84      	subs	r4, r0, r2
    c4da:	eb61 0303 	sbc.w	r3, r1, r3
    c4de:	2001      	movs	r0, #1
    c4e0:	4698      	mov	r8, r3
    c4e2:	2e00      	cmp	r6, #0
    c4e4:	d0a9      	beq.n	c43a <__udivmoddi4+0xa2>
    c4e6:	e9c6 4800 	strd	r4, r8, [r6]
    c4ea:	e7a6      	b.n	c43a <__udivmoddi4+0xa2>
    c4ec:	deff      	udf	#255	; 0xff
    c4ee:	f1c7 0520 	rsb	r5, r7, #32
    c4f2:	40bb      	lsls	r3, r7
    c4f4:	fa22 fc05 	lsr.w	ip, r2, r5
    c4f8:	ea4c 0c03 	orr.w	ip, ip, r3
    c4fc:	fa01 f407 	lsl.w	r4, r1, r7
    c500:	fa20 f805 	lsr.w	r8, r0, r5
    c504:	fa21 f305 	lsr.w	r3, r1, r5
    c508:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
    c50c:	ea48 0404 	orr.w	r4, r8, r4
    c510:	fbb3 f9fe 	udiv	r9, r3, lr
    c514:	0c21      	lsrs	r1, r4, #16
    c516:	fb0e 3319 	mls	r3, lr, r9, r3
    c51a:	fa1f f88c 	uxth.w	r8, ip
    c51e:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
    c522:	fb09 fa08 	mul.w	sl, r9, r8
    c526:	459a      	cmp	sl, r3
    c528:	fa02 f207 	lsl.w	r2, r2, r7
    c52c:	fa00 f107 	lsl.w	r1, r0, r7
    c530:	d90b      	bls.n	c54a <__udivmoddi4+0x1b2>
    c532:	eb1c 0303 	adds.w	r3, ip, r3
    c536:	f109 30ff 	add.w	r0, r9, #4294967295
    c53a:	f080 8088 	bcs.w	c64e <__udivmoddi4+0x2b6>
    c53e:	459a      	cmp	sl, r3
    c540:	f240 8085 	bls.w	c64e <__udivmoddi4+0x2b6>
    c544:	f1a9 0902 	sub.w	r9, r9, #2
    c548:	4463      	add	r3, ip
    c54a:	eba3 030a 	sub.w	r3, r3, sl
    c54e:	b2a4      	uxth	r4, r4
    c550:	fbb3 f0fe 	udiv	r0, r3, lr
    c554:	fb0e 3310 	mls	r3, lr, r0, r3
    c558:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
    c55c:	fb00 f808 	mul.w	r8, r0, r8
    c560:	45a0      	cmp	r8, r4
    c562:	d908      	bls.n	c576 <__udivmoddi4+0x1de>
    c564:	eb1c 0404 	adds.w	r4, ip, r4
    c568:	f100 33ff 	add.w	r3, r0, #4294967295
    c56c:	d26b      	bcs.n	c646 <__udivmoddi4+0x2ae>
    c56e:	45a0      	cmp	r8, r4
    c570:	d969      	bls.n	c646 <__udivmoddi4+0x2ae>
    c572:	3802      	subs	r0, #2
    c574:	4464      	add	r4, ip
    c576:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
    c57a:	eba4 0408 	sub.w	r4, r4, r8
    c57e:	fba0 8902 	umull	r8, r9, r0, r2
    c582:	454c      	cmp	r4, r9
    c584:	46c6      	mov	lr, r8
    c586:	464b      	mov	r3, r9
    c588:	d354      	bcc.n	c634 <__udivmoddi4+0x29c>
    c58a:	d051      	beq.n	c630 <__udivmoddi4+0x298>
    c58c:	2e00      	cmp	r6, #0
    c58e:	d069      	beq.n	c664 <__udivmoddi4+0x2cc>
    c590:	ebb1 020e 	subs.w	r2, r1, lr
    c594:	eb64 0403 	sbc.w	r4, r4, r3
    c598:	fa04 f505 	lsl.w	r5, r4, r5
    c59c:	fa22 f307 	lsr.w	r3, r2, r7
    c5a0:	40fc      	lsrs	r4, r7
    c5a2:	431d      	orrs	r5, r3
    c5a4:	e9c6 5400 	strd	r5, r4, [r6]
    c5a8:	2700      	movs	r7, #0
    c5aa:	e746      	b.n	c43a <__udivmoddi4+0xa2>
    c5ac:	4637      	mov	r7, r6
    c5ae:	4630      	mov	r0, r6
    c5b0:	e743      	b.n	c43a <__udivmoddi4+0xa2>
    c5b2:	4618      	mov	r0, r3
    c5b4:	e737      	b.n	c426 <__udivmoddi4+0x8e>
    c5b6:	4607      	mov	r7, r0
    c5b8:	e71f      	b.n	c3fa <__udivmoddi4+0x62>
    c5ba:	f1c2 0320 	rsb	r3, r2, #32
    c5be:	fa20 f703 	lsr.w	r7, r0, r3
    c5c2:	4095      	lsls	r5, r2
    c5c4:	fa01 f002 	lsl.w	r0, r1, r2
    c5c8:	fa21 f303 	lsr.w	r3, r1, r3
    c5cc:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    c5d0:	4338      	orrs	r0, r7
    c5d2:	0c01      	lsrs	r1, r0, #16
    c5d4:	fbb3 f7fe 	udiv	r7, r3, lr
    c5d8:	fa1f f885 	uxth.w	r8, r5
    c5dc:	fb0e 3317 	mls	r3, lr, r7, r3
    c5e0:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    c5e4:	fb07 f308 	mul.w	r3, r7, r8
    c5e8:	428b      	cmp	r3, r1
    c5ea:	fa04 f402 	lsl.w	r4, r4, r2
    c5ee:	d907      	bls.n	c600 <__udivmoddi4+0x268>
    c5f0:	1869      	adds	r1, r5, r1
    c5f2:	f107 3cff 	add.w	ip, r7, #4294967295
    c5f6:	d228      	bcs.n	c64a <__udivmoddi4+0x2b2>
    c5f8:	428b      	cmp	r3, r1
    c5fa:	d926      	bls.n	c64a <__udivmoddi4+0x2b2>
    c5fc:	3f02      	subs	r7, #2
    c5fe:	4429      	add	r1, r5
    c600:	1acb      	subs	r3, r1, r3
    c602:	b281      	uxth	r1, r0
    c604:	fbb3 f0fe 	udiv	r0, r3, lr
    c608:	fb0e 3310 	mls	r3, lr, r0, r3
    c60c:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    c610:	fb00 f308 	mul.w	r3, r0, r8
    c614:	428b      	cmp	r3, r1
    c616:	d907      	bls.n	c628 <__udivmoddi4+0x290>
    c618:	1869      	adds	r1, r5, r1
    c61a:	f100 3cff 	add.w	ip, r0, #4294967295
    c61e:	d210      	bcs.n	c642 <__udivmoddi4+0x2aa>
    c620:	428b      	cmp	r3, r1
    c622:	d90e      	bls.n	c642 <__udivmoddi4+0x2aa>
    c624:	3802      	subs	r0, #2
    c626:	4429      	add	r1, r5
    c628:	1ac9      	subs	r1, r1, r3
    c62a:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
    c62e:	e714      	b.n	c45a <__udivmoddi4+0xc2>
    c630:	4541      	cmp	r1, r8
    c632:	d2ab      	bcs.n	c58c <__udivmoddi4+0x1f4>
    c634:	ebb8 0e02 	subs.w	lr, r8, r2
    c638:	eb69 020c 	sbc.w	r2, r9, ip
    c63c:	3801      	subs	r0, #1
    c63e:	4613      	mov	r3, r2
    c640:	e7a4      	b.n	c58c <__udivmoddi4+0x1f4>
    c642:	4660      	mov	r0, ip
    c644:	e7f0      	b.n	c628 <__udivmoddi4+0x290>
    c646:	4618      	mov	r0, r3
    c648:	e795      	b.n	c576 <__udivmoddi4+0x1de>
    c64a:	4667      	mov	r7, ip
    c64c:	e7d8      	b.n	c600 <__udivmoddi4+0x268>
    c64e:	4681      	mov	r9, r0
    c650:	e77b      	b.n	c54a <__udivmoddi4+0x1b2>
    c652:	4638      	mov	r0, r7
    c654:	e745      	b.n	c4e2 <__udivmoddi4+0x14a>
    c656:	f1ac 0c02 	sub.w	ip, ip, #2
    c65a:	442b      	add	r3, r5
    c65c:	e710      	b.n	c480 <__udivmoddi4+0xe8>
    c65e:	3802      	subs	r0, #2
    c660:	442c      	add	r4, r5
    c662:	e721      	b.n	c4a8 <__udivmoddi4+0x110>
    c664:	4637      	mov	r7, r6
    c666:	e6e8      	b.n	c43a <__udivmoddi4+0xa2>

Disassembly of section .text._TCP_Open%210:

0000c668 <_TCP_Open>:
{
    c668:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c66c:	b083      	sub	sp, #12
    c66e:	4680      	mov	r8, r0
    c670:	468a      	mov	sl, r1
    c672:	9200      	str	r2, [sp, #0]
    c674:	9301      	str	r3, [sp, #4]
    if(opType == TCP_OPEN_CLIENT)
    c676:	2901      	cmp	r1, #1
    c678:	d000      	beq.n	c67c <_TCP_Open+0x14>
    if(localPort == 0)
    c67a:	bb02      	cbnz	r2, c6be <_TCP_Open+0x56>
        localPort = _TCP_EphemeralPortAllocate();
    c67c:	f012 f84a 	bl	1e714 <_TCP_EphemeralPortAllocate>
        if(localPort  == 0)
    c680:	4683      	mov	fp, r0
    c682:	2800      	cmp	r0, #0
    c684:	f000 8124 	beq.w	c8d0 <_TCP_Open+0x268>
    if (OSAL_SEM_Pend(&tcpSemaphore, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
    c688:	f64f 71ff 	movw	r1, #65535	; 0xffff
    c68c:	489f      	ldr	r0, [pc, #636]	; (c90c <_TCP_Open+0x2a4>)
    c68e:	f014 fb89 	bl	20da4 <OSAL_SEM_Pend>
    for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    c692:	4b9f      	ldr	r3, [pc, #636]	; (c910 <_TCP_Open+0x2a8>)
    c694:	681a      	ldr	r2, [r3, #0]
    c696:	2a00      	cmp	r2, #0
    c698:	f000 80cc 	beq.w	c834 <_TCP_Open+0x1cc>
        pSkt = TCBStubs[hTCP];
    c69c:	4b9d      	ldr	r3, [pc, #628]	; (c914 <_TCP_Open+0x2ac>)
    c69e:	6819      	ldr	r1, [r3, #0]
    c6a0:	680b      	ldr	r3, [r1, #0]
        if(pSkt == 0)
    c6a2:	2b00      	cmp	r3, #0
    c6a4:	f000 8117 	beq.w	c8d6 <_TCP_Open+0x26e>
    for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    c6a8:	2400      	movs	r4, #0
    c6aa:	3401      	adds	r4, #1
    c6ac:	b224      	sxth	r4, r4
    c6ae:	4626      	mov	r6, r4
    c6b0:	4294      	cmp	r4, r2
    c6b2:	d209      	bcs.n	c6c8 <_TCP_Open+0x60>
        pSkt = TCBStubs[hTCP];
    c6b4:	f851 3024 	ldr.w	r3, [r1, r4, lsl #2]
        if(pSkt == 0)
    c6b8:	2b00      	cmp	r3, #0
    c6ba:	d1f6      	bne.n	c6aa <_TCP_Open+0x42>
    c6bc:	e007      	b.n	c6ce <_TCP_Open+0x66>
        localPort = port;
    c6be:	f8dd b000 	ldr.w	fp, [sp]
        remotePort = 0;
    c6c2:	2300      	movs	r3, #0
    c6c4:	9300      	str	r3, [sp, #0]
    c6c6:	e7df      	b.n	c688 <_TCP_Open+0x20>
    if(pSkt != 0)
    c6c8:	2b00      	cmp	r3, #0
    c6ca:	f040 80b3 	bne.w	c834 <_TCP_Open+0x1cc>
    pSkt = (TCB_STUB*)TCPIP_HEAP_Calloc(tcpHeapH, 1, sizeof(*pSkt));
    c6ce:	f8df 9250 	ldr.w	r9, [pc, #592]	; c920 <_TCP_Open+0x2b8>
    c6d2:	f8d9 0000 	ldr.w	r0, [r9]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Calloc)(h, nElems, elemSize);
    c6d6:	6883      	ldr	r3, [r0, #8]
    c6d8:	2280      	movs	r2, #128	; 0x80
    c6da:	2101      	movs	r1, #1
    c6dc:	4798      	blx	r3
    c6de:	4605      	mov	r5, r0
    txBuff = (uint8_t*)TCPIP_HEAP_Malloc(tcpHeapH, tcpDefTxSize + 1);
    c6e0:	f8d9 0000 	ldr.w	r0, [r9]
    c6e4:	4b8c      	ldr	r3, [pc, #560]	; (c918 <_TCP_Open+0x2b0>)
    c6e6:	8819      	ldrh	r1, [r3, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
    c6e8:	6843      	ldr	r3, [r0, #4]
    c6ea:	3101      	adds	r1, #1
    c6ec:	4798      	blx	r3
    c6ee:	4607      	mov	r7, r0
    rxBuff = (uint8_t*)TCPIP_HEAP_Malloc(tcpHeapH, tcpDefRxSize + 1);
    c6f0:	f8d9 0000 	ldr.w	r0, [r9]
    c6f4:	4b89      	ldr	r3, [pc, #548]	; (c91c <_TCP_Open+0x2b4>)
    c6f6:	8819      	ldrh	r1, [r3, #0]
    c6f8:	6843      	ldr	r3, [r0, #4]
    c6fa:	3101      	adds	r1, #1
    c6fc:	4798      	blx	r3
    if(pSkt == 0 || txBuff == 0 || rxBuff == 0)
    c6fe:	2d00      	cmp	r5, #0
    c700:	f000 809e 	beq.w	c840 <_TCP_Open+0x1d8>
    c704:	2f00      	cmp	r7, #0
    c706:	f000 809b 	beq.w	c840 <_TCP_Open+0x1d8>
    c70a:	2800      	cmp	r0, #0
    c70c:	f000 8098 	beq.w	c840 <_TCP_Open+0x1d8>
    _TcpSocketInitialize(pSkt, hTCP, txBuff, tcpDefTxSize, rxBuff, tcpDefRxSize);
    c710:	4b81      	ldr	r3, [pc, #516]	; (c918 <_TCP_Open+0x2b0>)
    c712:	881b      	ldrh	r3, [r3, #0]
    c714:	4a81      	ldr	r2, [pc, #516]	; (c91c <_TCP_Open+0x2b4>)
    c716:	8811      	ldrh	r1, [r2, #0]
    pSkt->sktIx = hTCP;     // hTCP is the index of this socket!
    c718:	86ac      	strh	r4, [r5, #52]	; 0x34
    pSkt->txStart	= txBuff;
    c71a:	602f      	str	r7, [r5, #0]
    pSkt->txEnd	    = txBuff + txBuffSize + 1;
    c71c:	3301      	adds	r3, #1
    c71e:	441f      	add	r7, r3
    c720:	606f      	str	r7, [r5, #4]
    pSkt->rxStart	= rxBuff;
    c722:	6168      	str	r0, [r5, #20]
    pSkt->rxEnd		= rxBuff + rxBuffSize;
    c724:	4408      	add	r0, r1
    c726:	61a8      	str	r0, [r5, #24]
    pSkt->wRemoteMSS = TCP_MIN_DEFAULT_MTU;
    c728:	f44f 7306 	mov.w	r3, #536	; 0x218
    c72c:	f8a5 3062 	strh.w	r3, [r5, #98]	; 0x62
    TCBStubs[hTCP] = pSkt;  // store it
    c730:	4b78      	ldr	r3, [pc, #480]	; (c914 <_TCP_Open+0x2ac>)
    c732:	681b      	ldr	r3, [r3, #0]
    c734:	f843 5026 	str.w	r5, [r3, r6, lsl #2]
    if (OSAL_SEM_Post(&tcpSemaphore) != OSAL_RESULT_TRUE)
    c738:	4874      	ldr	r0, [pc, #464]	; (c90c <_TCP_Open+0x2a4>)
    c73a:	f014 ff4b 	bl	215d4 <OSAL_SEM_Post>
	pSkt->remoteHash = pSkt->localPort;
    c73e:	f8b5 305a 	ldrh.w	r3, [r5, #90]	; 0x5a
    c742:	f8a5 306a 	strh.w	r3, [r5, #106]	; 0x6a
	pSkt->txHead = pSkt->txStart;
    c746:	682b      	ldr	r3, [r5, #0]
    c748:	60ab      	str	r3, [r5, #8]
	pSkt->txTail = pSkt->txStart;
    c74a:	60eb      	str	r3, [r5, #12]
	pSkt->txUnackedTail = pSkt->txStart;
    c74c:	612b      	str	r3, [r5, #16]
	pSkt->rxHead = pSkt->rxStart;
    c74e:	696b      	ldr	r3, [r5, #20]
    c750:	61eb      	str	r3, [r5, #28]
	pSkt->rxTail = pSkt->rxStart;
    c752:	622b      	str	r3, [r5, #32]
	pSkt->Flags.bTimerEnabled = 0;
    c754:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
	pSkt->Flags.bTXASAPWithoutTimerReset = 0;
    c758:	f003 0381 	and.w	r3, r3, #129	; 0x81
    c75c:	f36f 13c7 	bfc	r3, #7, #1
    c760:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
	pSkt->Flags.bTXFIN = 0;
    c764:	f895 3037 	ldrb.w	r3, [r5, #55]	; 0x37
	pSkt->Flags.bSocketReset = 1;
    c768:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	pSkt->Flags.bRxFin = 0;
    c76c:	f043 0302 	orr.w	r3, r3, #2
    c770:	f36f 0382 	bfc	r3, #2, #1
    c774:	f885 3037 	strb.w	r3, [r5, #55]	; 0x37
	pSkt->flags.bFINSent = 0;
    c778:	f895 306c 	ldrb.w	r3, [r5, #108]	; 0x6c
    pSkt->flags.seqInc = 0;
    c77c:	f895 206d 	ldrb.w	r2, [r5, #109]	; 0x6d
    c780:	f36f 0241 	bfc	r2, #1, #1
    c784:	f885 206d 	strb.w	r2, [r5, #109]	; 0x6d
	pSkt->flags.bRXNoneACKed2 = 0;
    c788:	f003 03e3 	and.w	r3, r3, #227	; 0xe3
    c78c:	f36f 1345 	bfc	r3, #5, #1
    c790:	f885 306c 	strb.w	r3, [r5, #108]	; 0x6c
    pSkt->MySEQ = 0;
    c794:	2100      	movs	r1, #0
    c796:	64e9      	str	r1, [r5, #76]	; 0x4c
	pSkt->sHoleSize = -1;
    c798:	f04f 30ff 	mov.w	r0, #4294967295
    c79c:	6568      	str	r0, [r5, #84]	; 0x54
	pSkt->remoteWindow = 1;
    c79e:	2001      	movs	r0, #1
    c7a0:	f8a5 005c 	strh.w	r0, [r5, #92]	; 0x5c
    pSkt->maxRemoteWindow = 1;
    c7a4:	f8a5 0066 	strh.w	r0, [r5, #102]	; 0x66
    pSkt->remotePort = 0;
    c7a8:	f8a5 1058 	strh.w	r1, [r5, #88]	; 0x58
    pSkt->destAddress.Val = 0;
    c7ac:	63a9      	str	r1, [r5, #56]	; 0x38
	pSkt->keepAliveCount = 0;
    c7ae:	f885 1071 	strb.w	r1, [r5, #113]	; 0x71
    pSkt->addType = (IP_ADDRESS_TYPE)pSkt->flags.openAddType;
    c7b2:	f003 0303 	and.w	r3, r3, #3
    c7b6:	f885 306f 	strb.w	r3, [r5, #111]	; 0x6f
    if(pSkt->flags.openBindIf == 0)
    c7ba:	b2d2      	uxtb	r2, r2
    c7bc:	f012 0f20 	tst.w	r2, #32
        pSkt->pSktNet = 0;
    c7c0:	bf04      	itt	eq
    c7c2:	460b      	moveq	r3, r1
    c7c4:	6429      	streq	r1, [r5, #64]	; 0x40
    if(pSkt->flags.openBindAdd == 0)
    c7c6:	f012 0f40 	tst.w	r2, #64	; 0x40
        pSkt->srcAddress.Val = 0;
    c7ca:	bf04      	itt	eq
    c7cc:	2300      	moveq	r3, #0
    c7ce:	63eb      	streq	r3, [r5, #60]	; 0x3c
    pSkt->dbgFlags.val = 0;
    c7d0:	2300      	movs	r3, #0
    c7d2:	f885 307d 	strb.w	r3, [r5, #125]	; 0x7d
    pSkt->addType = addType;
    c7d6:	f885 806f 	strb.w	r8, [r5, #111]	; 0x6f
    switch(addType)
    c7da:	f1b8 0f01 	cmp.w	r8, #1
    c7de:	d043      	beq.n	c868 <_TCP_Open+0x200>
            pSkt->pTxPkt = 0;   // default for IP_ADDRESS_TYPE_ANY
    c7e0:	2300      	movs	r3, #0
    c7e2:	646b      	str	r3, [r5, #68]	; 0x44
    if (pSkt->pTxPkt == 0 && pSkt->addType != IP_ADDRESS_TYPE_ANY)
    c7e4:	f895 306f 	ldrb.w	r3, [r5, #111]	; 0x6f
    c7e8:	2b00      	cmp	r3, #0
    c7ea:	d16b      	bne.n	c8c4 <_TCP_Open+0x25c>
    pSkt->flags.openAddType = addType;
    c7ec:	f895 306c 	ldrb.w	r3, [r5, #108]	; 0x6c
    c7f0:	f368 0301 	bfi	r3, r8, #0, #2
    c7f4:	f885 306c 	strb.w	r3, [r5, #108]	; 0x6c
    if(opType == TCP_OPEN_SERVER)
    c7f8:	f1ba 0f00 	cmp.w	sl, #0
    c7fc:	d051      	beq.n	c8a2 <_TCP_Open+0x23a>
        pSkt->localPort = localPort;
    c7fe:	f8a5 b05a 	strh.w	fp, [r5, #90]	; 0x5a
        pSkt->remotePort = remotePort;
    c802:	9b00      	ldr	r3, [sp, #0]
    c804:	f8a5 3058 	strh.w	r3, [r5, #88]	; 0x58
        pSkt->eventTime = SYS_TMR_TickCountGet();
    c808:	f013 fc70 	bl	200ec <SYS_TMR_TickCountGet>
    c80c:	6268      	str	r0, [r5, #36]	; 0x24
        pSkt->Flags.bTimerEnabled = 1;
    c80e:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
    c812:	f043 0302 	orr.w	r3, r3, #2
    c816:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
        switch(addType)
    c81a:	f1b8 0f01 	cmp.w	r8, #1
    c81e:	d06b      	beq.n	c8f8 <_TCP_Open+0x290>
        _TcpSocketSetState(pSkt, (_TcpClientSocketConnect(pSkt) >= 0) ? TCPIP_TCP_STATE_SYN_SENT : TCPIP_TCP_STATE_CLIENT_WAIT_CONNECT);
    c820:	4628      	mov	r0, r5
    c822:	f00f f881 	bl	1b928 <_TcpClientSocketConnect>
    c826:	2800      	cmp	r0, #0
    c828:	bfac      	ite	ge
    c82a:	2301      	movge	r3, #1
    c82c:	230b      	movlt	r3, #11
    pSkt->smState = newState;
    c82e:	f885 306e 	strb.w	r3, [r5, #110]	; 0x6e
    c832:	e043      	b.n	c8bc <_TCP_Open+0x254>
        if (OSAL_SEM_Post(&tcpSemaphore) != OSAL_RESULT_TRUE)
    c834:	4835      	ldr	r0, [pc, #212]	; (c90c <_TCP_Open+0x2a4>)
    c836:	f014 fecd 	bl	215d4 <OSAL_SEM_Post>
        return INVALID_SOCKET;
    c83a:	f04f 34ff 	mov.w	r4, #4294967295
    c83e:	e03d      	b.n	c8bc <_TCP_Open+0x254>
        TCPIP_HEAP_Free(tcpHeapH, rxBuff);
    c840:	4c37      	ldr	r4, [pc, #220]	; (c920 <_TCP_Open+0x2b8>)
    c842:	6823      	ldr	r3, [r4, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
    c844:	68da      	ldr	r2, [r3, #12]
    c846:	4601      	mov	r1, r0
    c848:	4618      	mov	r0, r3
    c84a:	4790      	blx	r2
        TCPIP_HEAP_Free(tcpHeapH, txBuff);
    c84c:	6820      	ldr	r0, [r4, #0]
    c84e:	68c3      	ldr	r3, [r0, #12]
    c850:	4639      	mov	r1, r7
    c852:	4798      	blx	r3
        TCPIP_HEAP_Free(tcpHeapH, pSkt);
    c854:	6820      	ldr	r0, [r4, #0]
    c856:	68c3      	ldr	r3, [r0, #12]
    c858:	4629      	mov	r1, r5
    c85a:	4798      	blx	r3
        if (OSAL_SEM_Post(&tcpSemaphore) != OSAL_RESULT_TRUE)
    c85c:	482b      	ldr	r0, [pc, #172]	; (c90c <_TCP_Open+0x2a4>)
    c85e:	f014 feb9 	bl	215d4 <OSAL_SEM_Post>
        return INVALID_SOCKET;
    c862:	f04f 34ff 	mov.w	r4, #4294967295
    c866:	e029      	b.n	c8bc <_TCP_Open+0x254>
    pv4Pkt = (TCP_V4_PACKET*)TCPIP_PKT_SocketAlloc(sizeof(TCP_V4_PACKET), sizeof(TCP_HEADER), sizeof(TCP_OPTIONS), allocFlags);
    c868:	f242 0306 	movw	r3, #8198	; 0x2006
    c86c:	2204      	movs	r2, #4
    c86e:	2114      	movs	r1, #20
    c870:	2074      	movs	r0, #116	; 0x74
    c872:	f013 f881 	bl	1f978 <_TCPIP_PKT_SocketAlloc>
    if(pv4Pkt)
    c876:	2800      	cmp	r0, #0
    c878:	d046      	beq.n	c908 <_TCP_Open+0x2a0>
    pPkt->ackFunc = ackFunc;
    c87a:	4a2a      	ldr	r2, [pc, #168]	; (c924 <_TCP_Open+0x2bc>)
    c87c:	6082      	str	r2, [r0, #8]
    pPkt->ackParam = ackParam;
    c87e:	60c5      	str	r5, [r0, #12]
        pv4Pkt->tcpSeg[0].segFlags = pv4Pkt->tcpSeg[1].segFlags = TCPIP_MAC_SEG_FLAG_STATIC; // embedded in packet itself
    c880:	2201      	movs	r2, #1
    c882:	f8a0 206c 	strh.w	r2, [r0, #108]	; 0x6c
    c886:	f8a0 2054 	strh.w	r2, [r0, #84]	; 0x54
            pSkt->pTxPkt = _TcpAllocateTxPacket (pSkt, IP_ADDRESS_TYPE_IPV4);
    c88a:	6468      	str	r0, [r5, #68]	; 0x44
    if (pSkt->pTxPkt == 0 && pSkt->addType != IP_ADDRESS_TYPE_ANY)
    c88c:	2800      	cmp	r0, #0
    c88e:	d0a9      	beq.n	c7e4 <_TCP_Open+0x17c>
    pSkt->flags.openAddType = addType;
    c890:	f895 306c 	ldrb.w	r3, [r5, #108]	; 0x6c
    c894:	f368 0301 	bfi	r3, r8, #0, #2
    c898:	f885 306c 	strb.w	r3, [r5, #108]	; 0x6c
    if(opType == TCP_OPEN_SERVER)
    c89c:	f1ba 0f00 	cmp.w	sl, #0
    c8a0:	d11c      	bne.n	c8dc <_TCP_Open+0x274>
        pSkt->localPort = localPort;
    c8a2:	f8a5 b05a 	strh.w	fp, [r5, #90]	; 0x5a
        pSkt->Flags.bServer = true;
    c8a6:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
    c8aa:	f043 0301 	orr.w	r3, r3, #1
    c8ae:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
    pSkt->smState = newState;
    c8b2:	2300      	movs	r3, #0
    c8b4:	f885 306e 	strb.w	r3, [r5, #110]	; 0x6e
        pSkt->remoteHash = localPort;
    c8b8:	f8a5 b06a 	strh.w	fp, [r5, #106]	; 0x6a
}
    c8bc:	4620      	mov	r0, r4
    c8be:	b003      	add	sp, #12
    c8c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        _TcpSocketKill(pSkt);
    c8c4:	4628      	mov	r0, r5
    c8c6:	f010 f873 	bl	1c9b0 <_TcpSocketKill>
        return INVALID_SOCKET;
    c8ca:	f04f 34ff 	mov.w	r4, #4294967295
    c8ce:	e7f5      	b.n	c8bc <_TCP_Open+0x254>
            return INVALID_SOCKET;
    c8d0:	f04f 34ff 	mov.w	r4, #4294967295
    c8d4:	e7f2      	b.n	c8bc <_TCP_Open+0x254>
    for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    c8d6:	2400      	movs	r4, #0
    c8d8:	4626      	mov	r6, r4
    if(pSkt != 0)
    c8da:	e6f8      	b.n	c6ce <_TCP_Open+0x66>
        pSkt->localPort = localPort;
    c8dc:	f8a5 b05a 	strh.w	fp, [r5, #90]	; 0x5a
        pSkt->remotePort = remotePort;
    c8e0:	9b00      	ldr	r3, [sp, #0]
    c8e2:	f8a5 3058 	strh.w	r3, [r5, #88]	; 0x58
        pSkt->eventTime = SYS_TMR_TickCountGet();
    c8e6:	f013 fc01 	bl	200ec <SYS_TMR_TickCountGet>
    c8ea:	6268      	str	r0, [r5, #36]	; 0x24
        pSkt->Flags.bTimerEnabled = 1;
    c8ec:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
    c8f0:	f043 0302 	orr.w	r3, r3, #2
    c8f4:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
                if(hostAddress != 0 && hostAddress->v4Add.Val != 0)
    c8f8:	9b01      	ldr	r3, [sp, #4]
    c8fa:	2b00      	cmp	r3, #0
    c8fc:	d090      	beq.n	c820 <_TCP_Open+0x1b8>
    c8fe:	681b      	ldr	r3, [r3, #0]
    c900:	2b00      	cmp	r3, #0
    c902:	d08d      	beq.n	c820 <_TCP_Open+0x1b8>
                    pSkt->destAddress.Val = hostAddress->v4Add.Val;
    c904:	63ab      	str	r3, [r5, #56]	; 0x38
    c906:	e78b      	b.n	c820 <_TCP_Open+0x1b8>
            pSkt->pTxPkt = _TcpAllocateTxPacket (pSkt, IP_ADDRESS_TYPE_IPV4);
    c908:	6468      	str	r0, [r5, #68]	; 0x44
    if (pSkt->pTxPkt == 0 && pSkt->addType != IP_ADDRESS_TYPE_ANY)
    c90a:	e76b      	b.n	c7e4 <_TCP_Open+0x17c>
    c90c:	2000e3a0 	.word	0x2000e3a0
    c910:	2000e390 	.word	0x2000e390
    c914:	2000e38c 	.word	0x2000e38c
    c918:	2000e4f6 	.word	0x2000e4f6
    c91c:	2000e316 	.word	0x2000e316
    c920:	2000e394 	.word	0x2000e394
    c924:	00013c69 	.word	0x00013c69

Disassembly of section .text.TCPIP_ARP_Task%211:

0000c928 <TCPIP_ARP_Task>:

// called after service needed reported
// maintain the queues, processes, etc.

void TCPIP_ARP_Task(void)
{
    c928:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c92c:	b087      	sub	sp, #28
               TCPIP_ARP_Probe(pIf, &pIf->netIPAddr, &pIf->netIPAddr, ARP_OPERATION_RESP | ARP_OPERATION_CONFIGURE | ARP_OPERATION_PROBE_ONLY);
           }
        }
    }
#else
    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    c92e:	210f      	movs	r1, #15
    c930:	2002      	movs	r0, #2
    c932:	f011 fc4b 	bl	1e1cc <_TCPIPStackModuleSignalGet>
    c936:	4606      	mov	r6, r0
#endif  // (_TCPIP_STACK_INTERFACE_CHANGE_SIGNALING != 0)
    
    if((sigPend & TCPIP_MODULE_SIGNAL_RX_PENDING) != 0)
    c938:	f010 0f01 	tst.w	r0, #1
    c93c:	d106      	bne.n	c94c <TCPIP_ARP_Task+0x24>
    { //  RX signal occurred
        TCPIP_ARP_Process();
    }

    if((sigPend & TCPIP_MODULE_SIGNAL_TMO) != 0)
    c93e:	f016 0f02 	tst.w	r6, #2
    c942:	f040 8085 	bne.w	ca50 <TCPIP_ARP_Task+0x128>
    { // regular TMO occurred
        TCPIP_ARP_Timeout();
    }

}
    c946:	b007      	add	sp, #28
    c948:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    IPV4_ADDR targetAdd;
    IPV4_ADDR   algnSenderIpAddr;


    // extract queued ARP packets
    while((pPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
    c94c:	2702      	movs	r7, #2
        // Validate the ARP packet
        if ( pArpPkt->HardwareType != HW_ETHERNET     ||
                pArpPkt->MACAddrLen != sizeof(TCPIP_MAC_ADDR)  ||
                pArpPkt->ProtocolLen != sizeof(IPV4_ADDR) )
        {
            ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    c94e:	f06f 090d 	mvn.w	r9, #13
    c952:	e009      	b.n	c968 <TCPIP_ARP_Task+0x40>
                pArpPkt->MACAddrLen != sizeof(TCPIP_MAC_ADDR)  ||
    c954:	88a2      	ldrh	r2, [r4, #4]
    c956:	f240 4306 	movw	r3, #1030	; 0x406
    c95a:	429a      	cmp	r2, r3
    c95c:	d013      	beq.n	c986 <TCPIP_ARP_Task+0x5e>
            ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    c95e:	4649      	mov	r1, r9

        if(arpReqRes != ARP_RES_OK)
        {
        }

        TCPIP_PKT_PacketAcknowledge(pPkt, ackRes); 
    c960:	463a      	mov	r2, r7
    c962:	4628      	mov	r0, r5
    c964:	f011 f946 	bl	1dbf4 <_TCPIP_PKT_PacketAcknowledge>
    while((pPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
    c968:	4638      	mov	r0, r7
    c96a:	f012 ffef 	bl	1f94c <_TCPIPStackModuleRxExtract>
    c96e:	4605      	mov	r5, r0
    c970:	2800      	cmp	r0, #0
    c972:	d0e4      	beq.n	c93e <TCPIP_ARP_Task+0x16>
        pArpPkt = (ARP_PACKET*)pPkt->pNetLayer;
    c974:	69ac      	ldr	r4, [r5, #24]
        _SwapARPPacket(pArpPkt);
    c976:	4620      	mov	r0, r4
    c978:	f014 f87a 	bl	20a70 <_SwapARPPacket>
        if ( pArpPkt->HardwareType != HW_ETHERNET     ||
    c97c:	8823      	ldrh	r3, [r4, #0]
    c97e:	2b01      	cmp	r3, #1
    c980:	d0e8      	beq.n	c954 <TCPIP_ARP_Task+0x2c>
            ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    c982:	4649      	mov	r1, r9
    c984:	e7ec      	b.n	c960 <TCPIP_ARP_Task+0x38>
            targetAdd.Val = pArpPkt->TargetIPAddr.Val;
    c986:	f8d4 a018 	ldr.w	sl, [r4, #24]
            pPkt->pktIf = pInIf = _TCPIPStackMapAliasInterface((TCPIP_NET_IF*)pPkt->pktIf, &targetAdd);
    c98a:	f8d5 8028 	ldr.w	r8, [r5, #40]	; 0x28
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
    c98e:	4b93      	ldr	r3, [pc, #588]	; (cbdc <TCPIP_ARP_Task+0x2b4>)
    c990:	f8d3 b004 	ldr.w	fp, [r3, #4]
    c994:	4640      	mov	r0, r8
    c996:	f015 f9c5 	bl	21d24 <TCPIP_STACK_NetIxGet>
            algnSenderIpAddr.Val = pArpPkt->SenderIPAddr.Val;
    c99a:	f8d4 300e 	ldr.w	r3, [r4, #14]
    c99e:	9305      	str	r3, [sp, #20]
            hE = TCPIP_OAHASH_EntryLookup(pArpDcpt->hashDcpt, &algnSenderIpAddr.Val);
    c9a0:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
    c9a4:	a905      	add	r1, sp, #20
    c9a6:	f85b 0030 	ldr.w	r0, [fp, r0, lsl #3]
    c9aa:	f00e f9eb 	bl	1ad84 <TCPIP_OAHASH_EntryLookup>
            if(hE != 0)
    c9ae:	4683      	mov	fp, r0
    c9b0:	b128      	cbz	r0, c9be <TCPIP_ARP_Task+0x96>
                _ARPUpdateEntry(pInIf, (ARP_HASH_ENTRY*)hE, &pArpPkt->SenderMACAddr);
    c9b2:	f104 0208 	add.w	r2, r4, #8
    c9b6:	4601      	mov	r1, r0
    c9b8:	4640      	mov	r0, r8
    c9ba:	f00d faf5 	bl	19fa8 <_ARPUpdateEntry>
            if(targetAdd.Val == pInIf->netIPAddr.Val)
    c9be:	f8d8 3004 	ldr.w	r3, [r8, #4]
    c9c2:	459a      	cmp	sl, r3
    c9c4:	d03d      	beq.n	ca42 <TCPIP_ARP_Task+0x11a>
            ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    c9c6:	4639      	mov	r1, r7
    c9c8:	e7ca      	b.n	c960 <TCPIP_ARP_Task+0x38>
                if(hE == 0)
    c9ca:	f1bb 0f00 	cmp.w	fp, #0
    c9ce:	d004      	beq.n	c9da <TCPIP_ARP_Task+0xb2>
                if(pArpPkt->Operation == ARP_OPERATION_REQ)
    c9d0:	88e3      	ldrh	r3, [r4, #6]
    c9d2:	2b01      	cmp	r3, #1
    c9d4:	d026      	beq.n	ca24 <TCPIP_ARP_Task+0xfc>
            ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    c9d6:	4639      	mov	r1, r7
    c9d8:	e7c2      	b.n	c960 <TCPIP_ARP_Task+0x38>
                    arpReqRes = _ARPAddCompleteEntry(pInIf, &algnSenderIpAddr, &pArpPkt->SenderMACAddr);
    c9da:	f104 0308 	add.w	r3, r4, #8
    c9de:	9302      	str	r3, [sp, #8]
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
    c9e0:	497e      	ldr	r1, [pc, #504]	; (cbdc <TCPIP_ARP_Task+0x2b4>)
    c9e2:	f8d1 a004 	ldr.w	sl, [r1, #4]
    c9e6:	4640      	mov	r0, r8
    c9e8:	f015 f99c 	bl	21d24 <TCPIP_STACK_NetIxGet>
    c9ec:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
    c9f0:	eb0a 0bc0 	add.w	fp, sl, r0, lsl #3
    hE = TCPIP_OAHASH_EntryLookupOrInsert(pArpDcpt->hashDcpt, pIPAddr);
    c9f4:	a905      	add	r1, sp, #20
    c9f6:	f85a 0030 	ldr.w	r0, [sl, r0, lsl #3]
    c9fa:	f00e fbf7 	bl	1b1ec <TCPIP_OAHASH_EntryLookupOrInsert>
    if(hE == 0)
    c9fe:	2800      	cmp	r0, #0
    ca00:	d0e6      	beq.n	c9d0 <TCPIP_ARP_Task+0xa8>
    if(arpHE->hEntry.flags.newEntry != 0)
    ca02:	7803      	ldrb	r3, [r0, #0]
    ca04:	f013 0f02 	tst.w	r3, #2
    ca08:	d006      	beq.n	ca18 <TCPIP_ARP_Task+0xf0>
        _ARPSetEntry(arpHE, ARP_FLAG_ENTRY_COMPLETE, hwAdd, &pArpDcpt->completeList);
    ca0a:	f10b 0318 	add.w	r3, fp, #24
    ca0e:	9a02      	ldr	r2, [sp, #8]
    ca10:	2180      	movs	r1, #128	; 0x80
    ca12:	f012 f851 	bl	1eab8 <_ARPSetEntry>
    ca16:	e7db      	b.n	c9d0 <TCPIP_ARP_Task+0xa8>
        _ARPUpdateEntry(pIf, arpHE, hwAdd);
    ca18:	9a02      	ldr	r2, [sp, #8]
    ca1a:	4601      	mov	r1, r0
    ca1c:	4640      	mov	r0, r8
    ca1e:	f00d fac3 	bl	19fa8 <_ARPUpdateEntry>
    ca22:	e7d5      	b.n	c9d0 <TCPIP_ARP_Task+0xa8>
                    if(!_ARPSendIfPkt(pInIf, ARP_OPERATION_RESP, (uint32_t)pTgtIf->netIPAddr.Val, (uint32_t)pArpPkt->SenderIPAddr.Val, &pArpPkt->SenderMACAddr, &pTgtIf->netMACAddr))
    ca24:	f8d4 300e 	ldr.w	r3, [r4, #14]
    ca28:	f8d8 2004 	ldr.w	r2, [r8, #4]
    ca2c:	f108 013c 	add.w	r1, r8, #60	; 0x3c
    ca30:	9101      	str	r1, [sp, #4]
    ca32:	3408      	adds	r4, #8
    ca34:	9400      	str	r4, [sp, #0]
    ca36:	4639      	mov	r1, r7
    ca38:	4640      	mov	r0, r8
    ca3a:	f00a f8ed 	bl	16c18 <_ARPSendIfPkt>
            ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    ca3e:	4639      	mov	r1, r7
    ca40:	e78e      	b.n	c960 <TCPIP_ARP_Task+0x38>
// helper to check if an address service is running
TCPIP_STACK_ADDRESS_SERVICE_TYPE _TCPIPStackAddressServiceIsRunning(TCPIP_NET_IF* pNetIf);

static __inline__ bool __attribute__((always_inline)) _TCPIPStackIsConfig(TCPIP_NET_IF* pNetIf)
{
    return pNetIf->Flags.bInConfig != 0;
    ca42:	f898 3043 	ldrb.w	r3, [r8, #67]	; 0x43
            while( pTgtIf != 0 && !_TCPIPStackIsConfig(pTgtIf))
    ca46:	f013 0f10 	tst.w	r3, #16
    ca4a:	d0be      	beq.n	c9ca <TCPIP_ARP_Task+0xa2>
            ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    ca4c:	4639      	mov	r1, r7
    ca4e:	e787      	b.n	c960 <TCPIP_ARP_Task+0x38>
    arpMod.timeMs += TCPIP_ARP_TASK_PROCESS_RATE;
    ca50:	4c62      	ldr	r4, [pc, #392]	; (cbdc <TCPIP_ARP_Task+0x2b4>)
    ca52:	69a3      	ldr	r3, [r4, #24]
    ca54:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
    ca58:	61a3      	str	r3, [r4, #24]
    arpMod.timeSeconds = arpMod.timeMs / 1000;
    ca5a:	4a61      	ldr	r2, [pc, #388]	; (cbe0 <TCPIP_ARP_Task+0x2b8>)
    ca5c:	fba2 2303 	umull	r2, r3, r2, r3
    ca60:	099b      	lsrs	r3, r3, #6
    ca62:	6163      	str	r3, [r4, #20]
    nArpIfs = TCPIP_STACK_NumberOfNetworksGet();
    ca64:	f015 fad6 	bl	22014 <TCPIP_STACK_NumberOfNetworksGet>
    pArpDcpt = arpMod.arpCacheDcpt;
    ca68:	6867      	ldr	r7, [r4, #4]
    for(netIx = 0; netIx < nArpIfs; netIx++)
    ca6a:	1e03      	subs	r3, r0, #0
    ca6c:	9303      	str	r3, [sp, #12]
    ca6e:	f77f af6a 	ble.w	c946 <TCPIP_ARP_Task+0x1e>
    ca72:	f107 0648 	add.w	r6, r7, #72	; 0x48
    ca76:	3718      	adds	r7, #24
    ca78:	f04f 0b00 	mov.w	fp, #0
    ca7c:	e05c      	b.n	cb38 <TCPIP_ARP_Task+0x210>
                    _ARPSendIfPkt(pIf, ARP_OPERATION_REQ, (uint32_t)pIf->netIPAddr.Val, pE->ipAddress.Val, &arpBcastAdd, 0);
    ca7e:	686b      	ldr	r3, [r5, #4]
    ca80:	9802      	ldr	r0, [sp, #8]
    ca82:	6842      	ldr	r2, [r0, #4]
    ca84:	f8cd a004 	str.w	sl, [sp, #4]
    ca88:	4956      	ldr	r1, [pc, #344]	; (cbe4 <TCPIP_ARP_Task+0x2bc>)
    ca8a:	9100      	str	r1, [sp, #0]
    ca8c:	2101      	movs	r1, #1
    ca8e:	f00a f8c3 	bl	16c18 <_ARPSendIfPkt>
                    pE->nRetries++;
    ca92:	8a6b      	ldrh	r3, [r5, #18]
    ca94:	3301      	adds	r3, #1
    ca96:	826b      	strh	r3, [r5, #18]
        for(pN = pArpDcpt->incompleteList.list.head; pN != 0; pN = pN->next)
    ca98:	682d      	ldr	r5, [r5, #0]
    ca9a:	b1d5      	cbz	r5, cad2 <TCPIP_ARP_Task+0x1aa>
            if((pE->hEntry.flags.value & ARP_FLAG_ENTRY_GRATUITOUS) != 0)
    ca9c:	f835 1c04 	ldrh.w	r1, [r5, #-4]
    caa0:	f411 7f00 	tst.w	r1, #512	; 0x200
                maxRetries = arpMod.entryGratRetries;
    caa4:	bf14      	ite	ne
    caa6:	f8b4 3046 	ldrhne.w	r3, [r4, #70]	; 0x46
                maxRetries = arpMod.entryRetries;
    caaa:	f8b4 3044 	ldrheq.w	r3, [r4, #68]	; 0x44
            if( pE->nRetries < maxRetries && (arpMod.timeSeconds - pE->tInsert) >= pE->nRetries * arpMod.entryRetryTmo)
    caae:	8a68      	ldrh	r0, [r5, #18]
    cab0:	4298      	cmp	r0, r3
    cab2:	d2f1      	bcs.n	ca98 <TCPIP_ARP_Task+0x170>
    cab4:	6962      	ldr	r2, [r4, #20]
    cab6:	68ab      	ldr	r3, [r5, #8]
    cab8:	1ad2      	subs	r2, r2, r3
    caba:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    cabc:	fb03 f300 	mul.w	r3, r3, r0
    cac0:	429a      	cmp	r2, r3
    cac2:	d3e9      	bcc.n	ca98 <TCPIP_ARP_Task+0x170>
                if(isConfig == false || (pE->hEntry.flags.value & ARP_FLAG_ENTRY_CONFIGURE) != 0 )
    cac4:	f1b9 0f00 	cmp.w	r9, #0
    cac8:	d0d9      	beq.n	ca7e <TCPIP_ARP_Task+0x156>
    caca:	f411 7f80 	tst.w	r1, #256	; 0x100
    cace:	d0e3      	beq.n	ca98 <TCPIP_ARP_Task+0x170>
    cad0:	e7d5      	b.n	ca7e <TCPIP_ARP_Task+0x156>
        while( (pN = pArpDcpt->completeList.list.head) != 0)
    cad2:	f858 5c30 	ldr.w	r5, [r8, #-48]
    cad6:	b305      	cbz	r5, cb1a <TCPIP_ARP_Task+0x1f2>
            if( (arpMod.timeSeconds - pE->tInsert) >= arpMod.entrySolvedTmo)
    cad8:	6963      	ldr	r3, [r4, #20]
    cada:	68aa      	ldr	r2, [r5, #8]
    cadc:	1a9b      	subs	r3, r3, r2
    cade:	6b62      	ldr	r2, [r4, #52]	; 0x34
    cae0:	4293      	cmp	r3, r2
    cae2:	d31a      	bcc.n	cb1a <TCPIP_ARP_Task+0x1f2>
                _ARPNotifyClients(pIf, &pE->ipAddress, 0, ARP_EVENT_REMOVED_EXPIRED);
    cae4:	f06f 0a02 	mvn.w	sl, #2
    cae8:	f04f 0900 	mov.w	r9, #0
                TCPIP_OAHASH_EntryRemove(pArpDcpt->hashDcpt, &pE->hEntry);
    caec:	1f29      	subs	r1, r5, #4
    caee:	f858 0c48 	ldr.w	r0, [r8, #-72]
    caf2:	f014 fd0f 	bl	21514 <TCPIP_OAHASH_EntryRemove>
                TCPIP_Helper_ProtectedSingleListHeadRemove(&pArpDcpt->completeList);
    caf6:	4638      	mov	r0, r7
    caf8:	f012 fefc 	bl	1f8f4 <TCPIP_Helper_ProtectedSingleListHeadRemove>
                _ARPNotifyClients(pIf, &pE->ipAddress, 0, ARP_EVENT_REMOVED_EXPIRED);
    cafc:	4653      	mov	r3, sl
    cafe:	464a      	mov	r2, r9
    cb00:	1d29      	adds	r1, r5, #4
    cb02:	9802      	ldr	r0, [sp, #8]
    cb04:	f00f fa8e 	bl	1c024 <_ARPNotifyClients>
        while( (pN = pArpDcpt->completeList.list.head) != 0)
    cb08:	f858 5c30 	ldr.w	r5, [r8, #-48]
    cb0c:	b12d      	cbz	r5, cb1a <TCPIP_ARP_Task+0x1f2>
            if( (arpMod.timeSeconds - pE->tInsert) >= arpMod.entrySolvedTmo)
    cb0e:	6963      	ldr	r3, [r4, #20]
    cb10:	68aa      	ldr	r2, [r5, #8]
    cb12:	1a9b      	subs	r3, r3, r2
    cb14:	6b62      	ldr	r2, [r4, #52]	; 0x34
    cb16:	4293      	cmp	r3, r2
    cb18:	d2e8      	bcs.n	caec <TCPIP_ARP_Task+0x1c4>
        if(pArpDcpt->hashDcpt->fullSlots >= pArpDcpt->purgeThres)
    cb1a:	f858 3c48 	ldr.w	r3, [r8, #-72]
    cb1e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    cb20:	f858 3c08 	ldr.w	r3, [r8, #-8]
    cb24:	429a      	cmp	r2, r3
    cb26:	d23a      	bcs.n	cb9e <TCPIP_ARP_Task+0x276>
    for(netIx = 0; netIx < nArpIfs; netIx++)
    cb28:	f10b 0b01 	add.w	fp, fp, #1
    cb2c:	3648      	adds	r6, #72	; 0x48
    cb2e:	3748      	adds	r7, #72	; 0x48
    cb30:	9b03      	ldr	r3, [sp, #12]
    cb32:	455b      	cmp	r3, fp
    cb34:	f43f af07 	beq.w	c946 <TCPIP_ARP_Task+0x1e>
        pIf = (TCPIP_NET_IF*)TCPIP_STACK_IndexToNet(netIx);
    cb38:	4658      	mov	r0, fp
    cb3a:	f013 fa0f 	bl	1ff5c <TCPIP_STACK_IndexToNet>
    cb3e:	9002      	str	r0, [sp, #8]
TCPIP_NET_IF* _TCPIPStackMapAliasInterface(TCPIP_NET_IF* pNetIf, const IPV4_ADDR* pDestAddress);

#else
static __inline__ bool  __attribute__((always_inline)) _TCPIPStackNetIsPrimary(TCPIP_NET_IF* pNetIf)
{
    return true;
    cb40:	46b0      	mov	r8, r6
        while( (pN = pArpDcpt->incompleteList.list.head) != 0)
    cb42:	f856 5c1c 	ldr.w	r5, [r6, #-28]
    cb46:	2d00      	cmp	r5, #0
    cb48:	d0c3      	beq.n	cad2 <TCPIP_ARP_Task+0x1aa>
            if( (arpMod.timeSeconds - pE->tInsert) >= arpMod.entryPendingTmo)
    cb4a:	6963      	ldr	r3, [r4, #20]
    cb4c:	68aa      	ldr	r2, [r5, #8]
    cb4e:	1a9b      	subs	r3, r3, r2
    cb50:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    cb52:	4293      	cmp	r3, r2
    cb54:	d31b      	bcc.n	cb8e <TCPIP_ARP_Task+0x266>
                TCPIP_Helper_ProtectedSingleListHeadRemove(&pArpDcpt->incompleteList);
    cb56:	f107 0a14 	add.w	sl, r7, #20
                _ARPNotifyClients(pIf, &pE->ipAddress, 0, ARP_EVENT_REMOVED_TMO);
    cb5a:	f04f 39ff 	mov.w	r9, #4294967295
                TCPIP_OAHASH_EntryRemove(pArpDcpt->hashDcpt, &pE->hEntry);
    cb5e:	1f29      	subs	r1, r5, #4
    cb60:	f858 0c48 	ldr.w	r0, [r8, #-72]
    cb64:	f014 fcd6 	bl	21514 <TCPIP_OAHASH_EntryRemove>
                TCPIP_Helper_ProtectedSingleListHeadRemove(&pArpDcpt->incompleteList);
    cb68:	4650      	mov	r0, sl
    cb6a:	f012 fec3 	bl	1f8f4 <TCPIP_Helper_ProtectedSingleListHeadRemove>
                _ARPNotifyClients(pIf, &pE->ipAddress, 0, ARP_EVENT_REMOVED_TMO);
    cb6e:	464b      	mov	r3, r9
    cb70:	2200      	movs	r2, #0
    cb72:	1d29      	adds	r1, r5, #4
    cb74:	9802      	ldr	r0, [sp, #8]
    cb76:	f00f fa55 	bl	1c024 <_ARPNotifyClients>
        while( (pN = pArpDcpt->incompleteList.list.head) != 0)
    cb7a:	f858 5c1c 	ldr.w	r5, [r8, #-28]
    cb7e:	2d00      	cmp	r5, #0
    cb80:	d0a7      	beq.n	cad2 <TCPIP_ARP_Task+0x1aa>
            if( (arpMod.timeSeconds - pE->tInsert) >= arpMod.entryPendingTmo)
    cb82:	6963      	ldr	r3, [r4, #20]
    cb84:	68aa      	ldr	r2, [r5, #8]
    cb86:	1a9b      	subs	r3, r3, r2
    cb88:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    cb8a:	4293      	cmp	r3, r2
    cb8c:	d2e7      	bcs.n	cb5e <TCPIP_ARP_Task+0x236>
    return pNetIf->Flags.bInConfig != 0;
    cb8e:	9b02      	ldr	r3, [sp, #8]
    cb90:	f893 9043 	ldrb.w	r9, [r3, #67]	; 0x43
    cb94:	f009 0910 	and.w	r9, r9, #16
                    _ARPSendIfPkt(pIf, ARP_OPERATION_REQ, (uint32_t)pIf->netIPAddr.Val, pE->ipAddress.Val, &arpBcastAdd, 0);
    cb98:	f04f 0a00 	mov.w	sl, #0
    cb9c:	e77e      	b.n	ca9c <TCPIP_ARP_Task+0x174>
            for(purgeIx = 0; purgeIx < pArpDcpt->purgeQuanta; purgeIx++)
    cb9e:	f858 3c04 	ldr.w	r3, [r8, #-4]
    cba2:	2b00      	cmp	r3, #0
    cba4:	d0c0      	beq.n	cb28 <TCPIP_ARP_Task+0x200>
    cba6:	2500      	movs	r5, #0
                    _ARPNotifyClients(pIf, &pE->ipAddress, 0, ARP_EVENT_REMOVED_PURGED);
    cba8:	f06f 0a03 	mvn.w	sl, #3
                pN = TCPIP_Helper_ProtectedSingleListHeadRemove(&pArpDcpt->completeList);
    cbac:	4638      	mov	r0, r7
    cbae:	f012 fea1 	bl	1f8f4 <TCPIP_Helper_ProtectedSingleListHeadRemove>
                if(pN)
    cbb2:	4681      	mov	r9, r0
    cbb4:	2800      	cmp	r0, #0
    cbb6:	d0b7      	beq.n	cb28 <TCPIP_ARP_Task+0x200>
                    TCPIP_OAHASH_EntryRemove(pArpDcpt->hashDcpt, &pE->hEntry);
    cbb8:	1f01      	subs	r1, r0, #4
    cbba:	f858 0c48 	ldr.w	r0, [r8, #-72]
    cbbe:	f014 fca9 	bl	21514 <TCPIP_OAHASH_EntryRemove>
                    _ARPNotifyClients(pIf, &pE->ipAddress, 0, ARP_EVENT_REMOVED_PURGED);
    cbc2:	4653      	mov	r3, sl
    cbc4:	2200      	movs	r2, #0
    cbc6:	f109 0104 	add.w	r1, r9, #4
    cbca:	9802      	ldr	r0, [sp, #8]
    cbcc:	f00f fa2a 	bl	1c024 <_ARPNotifyClients>
            for(purgeIx = 0; purgeIx < pArpDcpt->purgeQuanta; purgeIx++)
    cbd0:	3501      	adds	r5, #1
    cbd2:	f858 3c04 	ldr.w	r3, [r8, #-4]
    cbd6:	429d      	cmp	r5, r3
    cbd8:	d3e8      	bcc.n	cbac <TCPIP_ARP_Task+0x284>
    cbda:	e7a5      	b.n	cb28 <TCPIP_ARP_Task+0x200>
    cbdc:	2000dfa4 	.word	0x2000dfa4
    cbe0:	10624dd3 	.word	0x10624dd3
    cbe4:	2000e368 	.word	0x2000e368

Disassembly of section .text._DNS_Send_Query%212:

0000cbe8 <_DNS_Send_Query>:
{
    cbe8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cbec:	b089      	sub	sp, #36	; 0x24
    cbee:	4680      	mov	r8, r0
    cbf0:	460c      	mov	r4, r1
    UDP_SOCKET          dnsSocket = pDnsDcpt->dnsSocket;
    cbf2:	f9b0 6024 	ldrsh.w	r6, [r0, #36]	; 0x24
    pDnsHE->hEntry.flags.value &= ~TCPIP_DNS_FLAG_ENTRY_COMPLETE;
    cbf6:	880b      	ldrh	r3, [r1, #0]
    cbf8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    cbfc:	800b      	strh	r3, [r1, #0]
        int oldServerIx = pDnsHE->currServerIx; // store the previously used DNS server index
    cbfe:	f891 5029 	ldrb.w	r5, [r1, #41]	; 0x29
        TCPIP_NET_IF* oldIf = pDnsHE->currNet;
    cc02:	f8d1 901c 	ldr.w	r9, [r1, #28]
    if(pDnsDcpt->strictNet != 0)
    cc06:	6840      	ldr	r0, [r0, #4]
    cc08:	2800      	cmp	r0, #0
    cc0a:	d065      	beq.n	ccd8 <_DNS_Send_Query+0xf0>
        return _DNS_ValidateIf(pDnsDcpt->strictNet, pDnsHE, true);
    cc0c:	2201      	movs	r2, #1
    cc0e:	f00c fac4 	bl	1919a <_DNS_ValidateIf>
        if(!_DNS_SelectIntf(pDnsDcpt, pDnsHE))
    cc12:	2800      	cmp	r0, #0
    cc14:	d05e      	beq.n	ccd4 <_DNS_Send_Query+0xec>
        if(oldIf == 0)
    cc16:	f1b9 0f00 	cmp.w	r9, #0
    cc1a:	f000 80af 	beq.w	cd7c <_DNS_Send_Query+0x194>
        if(pDnsHE->currServerIx != oldServerIx || pDnsHE->currNet != oldIf )
    cc1e:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
    cc22:	42ab      	cmp	r3, r5
    cc24:	f000 80b2 	beq.w	cd8c <_DNS_Send_Query+0x1a4>
            IPV4_ADDR oldDns = oldIf->dnsServer[oldServerIx];
    cc28:	3504      	adds	r5, #4
    cc2a:	f859 3025 	ldr.w	r3, [r9, r5, lsl #2]
    cc2e:	9300      	str	r3, [sp, #0]
            if(oldDns.Val != 0)
    cc30:	2b00      	cmp	r3, #0
    cc32:	f040 80b0 	bne.w	cd96 <_DNS_Send_Query+0x1ae>
        if(!TCPIP_UDP_PutIsReady(dnsSocket))
    cc36:	4630      	mov	r0, r6
    cc38:	f00f fe6d 	bl	1c916 <TCPIP_UDP_PutIsReady>
    cc3c:	2800      	cmp	r0, #0
    cc3e:	f000 80af 	beq.w	cda0 <_DNS_Send_Query+0x1b8>
        TCPIP_UDP_TxOffsetSet(dnsSocket, 0, false);    
    cc42:	2200      	movs	r2, #0
    cc44:	4611      	mov	r1, r2
    cc46:	4630      	mov	r0, r6
    cc48:	f011 f991 	bl	1df6e <TCPIP_UDP_TxOffsetSet>
        wrPtr = TCPIP_UDP_TxPointerGet(dnsSocket);
    cc4c:	4630      	mov	r0, r6
    cc4e:	f014 fb78 	bl	21342 <TCPIP_UDP_TxPointerGet>
        if(wrPtr == 0)
    cc52:	4607      	mov	r7, r0
    cc54:	2800      	cmp	r0, #0
    cc56:	f000 80a6 	beq.w	cda6 <_DNS_Send_Query+0x1be>
        TCPIP_UDP_Bind(dnsSocket, IP_ADDRESS_TYPE_IPV4, 0, (IP_MULTI_ADDRESS*)&pDnsHE->currNet->netIPAddr);
    cc5a:	69e3      	ldr	r3, [r4, #28]
    cc5c:	3304      	adds	r3, #4
    cc5e:	2200      	movs	r2, #0
    cc60:	2101      	movs	r1, #1
    cc62:	4630      	mov	r0, r6
    cc64:	f006 f8c8 	bl	12df8 <TCPIP_UDP_Bind>
        dnsServerAdd.Val = pDnsHE->currNet->dnsServer[pDnsHE->currServerIx].Val;
    cc68:	69e2      	ldr	r2, [r4, #28]
    cc6a:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
    cc6e:	3304      	adds	r3, #4
    cc70:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    cc74:	9304      	str	r3, [sp, #16]
        TCPIP_UDP_DestinationIPAddressSet(dnsSocket, pDnsDcpt->ipAddressType, (IP_MULTI_ADDRESS*)&dnsServerAdd);
    cc76:	aa04      	add	r2, sp, #16
    cc78:	f898 1018 	ldrb.w	r1, [r8, #24]
    cc7c:	4630      	mov	r0, r6
    cc7e:	f010 f811 	bl	1cca4 <TCPIP_UDP_DestinationIPAddressSet>
        TCPIP_UDP_DestinationPortSet(dnsSocket, TCPIP_DNS_SERVER_PORT);
    cc82:	2135      	movs	r1, #53	; 0x35
    cc84:	4630      	mov	r0, r6
    cc86:	f013 ff73 	bl	20b70 <TCPIP_UDP_DestinationPortSet>
    cc8a:	f00e f97f 	bl	1af8c <rand>
        pDnsHE->transactionId.Val = (uint16_t)SYS_RANDOM_PseudoGet();
    cc8e:	b283      	uxth	r3, r0
    cc90:	84a3      	strh	r3, [r4, #36]	; 0x24
    cc92:	0200      	lsls	r0, r0, #8
    cc94:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    cc98:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
    cc9c:	ea40 2013 	orr.w	r0, r0, r3, lsr #8
        DNSPutHeader.TransactionID.Val = TCPIP_Helper_htons(pDnsHE->transactionId.Val);
    cca0:	f8ad 0014 	strh.w	r0, [sp, #20]
        DNSPutHeader.Flags.Val = TCPIP_Helper_htons(0x0100); // Standard query with recursion
    cca4:	2301      	movs	r3, #1
    cca6:	f8ad 3016 	strh.w	r3, [sp, #22]
        DNSPutHeader.Questions.Val = TCPIP_Helper_htons(0x0001); // questions
    ccaa:	f44f 7380 	mov.w	r3, #256	; 0x100
    ccae:	f8ad 3018 	strh.w	r3, [sp, #24]
        DNSPutHeader.Answers.Val = DNSPutHeader.AuthoritativeRecords.Val = DNSPutHeader.AdditionalRecords.Val = 0;
    ccb2:	2300      	movs	r3, #0
    ccb4:	f8ad 301e 	strh.w	r3, [sp, #30]
    ccb8:	f8ad 301c 	strh.w	r3, [sp, #28]
    ccbc:	f8ad 301a 	strh.w	r3, [sp, #26]
        memcpy(wrPtr, &DNSPutHeader, sizeof(TCPIP_DNS_HEADER));
    ccc0:	ab05      	add	r3, sp, #20
    ccc2:	cb07      	ldmia	r3!, {r0, r1, r2}
    ccc4:	6038      	str	r0, [r7, #0]
    ccc6:	6079      	str	r1, [r7, #4]
    ccc8:	60ba      	str	r2, [r7, #8]
        wrPtr += sizeof(TCPIP_DNS_HEADER);
    ccca:	f107 050c 	add.w	r5, r7, #12
        _DNSPutString(&wrPtr, pDnsHE->pHostName);
    ccce:	6a21      	ldr	r1, [r4, #32]
    rightPtr = string;
    ccd0:	4688      	mov	r8, r1
    ccd2:	e0b8      	b.n	ce46 <_DNS_Send_Query+0x25e>
            res = TCPIP_DNS_RES_NO_INTERFACE;
    ccd4:	3807      	subs	r0, #7
    ccd6:	e09a      	b.n	ce0e <_DNS_Send_Query+0x226>
    memset(dnsSelectIfs, 0, sizeof(dnsSelectIfs));
    ccd8:	2300      	movs	r3, #0
    ccda:	9300      	str	r3, [sp, #0]
    ccdc:	9301      	str	r3, [sp, #4]
    ccde:	9302      	str	r3, [sp, #8]
    cce0:	9303      	str	r3, [sp, #12]
    _DNS_AddSelectionIf(pDnsDcpt->prefNet, dnsSelectIfs, sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs));
    cce2:	2204      	movs	r2, #4
    cce4:	4669      	mov	r1, sp
    cce6:	f8d8 0008 	ldr.w	r0, [r8, #8]
    ccea:	f00e f817 	bl	1ad1c <_DNS_AddSelectionIf>
    _DNS_AddSelectionIf(pDnsHE->currNet, dnsSelectIfs, sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs));
    ccee:	2204      	movs	r2, #4
    ccf0:	4669      	mov	r1, sp
    ccf2:	69e0      	ldr	r0, [r4, #28]
    ccf4:	f00e f812 	bl	1ad1c <_DNS_AddSelectionIf>
    _DNS_AddSelectionIf((TCPIP_NET_IF*)TCPIP_STACK_NetDefaultGet(), dnsSelectIfs, sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs));
    ccf8:	f015 f986 	bl	22008 <TCPIP_STACK_NetDefaultGet>
    ccfc:	2204      	movs	r2, #4
    ccfe:	4669      	mov	r1, sp
    cd00:	f00e f80c 	bl	1ad1c <_DNS_AddSelectionIf>
    nIfs = TCPIP_STACK_NumberOfNetworksGet();
    cd04:	f015 f986 	bl	22014 <TCPIP_STACK_NumberOfNetworksGet>
    for(ix = 0; ix < nIfs; ix++)
    cd08:	f1b0 0a00 	subs.w	sl, r0, #0
    cd0c:	dd0d      	ble.n	cd2a <_DNS_Send_Query+0x142>
    cd0e:	2700      	movs	r7, #0
       if(!_DNS_AddSelectionIf((TCPIP_NET_IF*)TCPIP_STACK_IndexToNet(ix), dnsSelectIfs, sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs)))
    cd10:	f04f 0b04 	mov.w	fp, #4
    cd14:	4638      	mov	r0, r7
    cd16:	f013 f921 	bl	1ff5c <TCPIP_STACK_IndexToNet>
    cd1a:	465a      	mov	r2, fp
    cd1c:	4669      	mov	r1, sp
    cd1e:	f00d fffd 	bl	1ad1c <_DNS_AddSelectionIf>
    cd22:	b110      	cbz	r0, cd2a <_DNS_Send_Query+0x142>
    for(ix = 0; ix < nIfs; ix++)
    cd24:	3701      	adds	r7, #1
    cd26:	45ba      	cmp	sl, r7
    cd28:	d1f4      	bne.n	cd14 <_DNS_Send_Query+0x12c>
    for(ix = 0; ix < sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs); ix++)
    cd2a:	46eb      	mov	fp, sp
    cd2c:	a904      	add	r1, sp, #16
    for(ix = 0; ix < nIfs; ix++)
    cd2e:	465b      	mov	r3, fp
    nIfs = 0;
    cd30:	f04f 0a00 	mov.w	sl, #0
    cd34:	e001      	b.n	cd3a <_DNS_Send_Query+0x152>
    for(ix = 0; ix < sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs); ix++)
    cd36:	428b      	cmp	r3, r1
    cd38:	d006      	beq.n	cd48 <_DNS_Send_Query+0x160>
        if(dnsSelectIfs[ix] != 0)
    cd3a:	f853 2b04 	ldr.w	r2, [r3], #4
    cd3e:	2a00      	cmp	r2, #0
    cd40:	d0f9      	beq.n	cd36 <_DNS_Send_Query+0x14e>
            nIfs++;
    cd42:	f10a 0a01 	add.w	sl, sl, #1
    cd46:	e7f6      	b.n	cd36 <_DNS_Send_Query+0x14e>
    for(ix = 0; ix < sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs); ix++)
    cd48:	2700      	movs	r7, #0
            if(_DNS_ValidateIf(pDnsIf, pDnsHE, (ix == nIfs - 1)))
    cd4a:	f10a 3aff 	add.w	sl, sl, #4294967295
    cd4e:	e002      	b.n	cd56 <_DNS_Send_Query+0x16e>
    for(ix = 0; ix < sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs); ix++)
    cd50:	3701      	adds	r7, #1
    cd52:	2f04      	cmp	r7, #4
    cd54:	d00d      	beq.n	cd72 <_DNS_Send_Query+0x18a>
        if((pDnsIf = dnsSelectIfs[ix]) != 0)
    cd56:	f85b 0b04 	ldr.w	r0, [fp], #4
    cd5a:	2800      	cmp	r0, #0
    cd5c:	d0f8      	beq.n	cd50 <_DNS_Send_Query+0x168>
            if(_DNS_ValidateIf(pDnsIf, pDnsHE, (ix == nIfs - 1)))
    cd5e:	45ba      	cmp	sl, r7
    cd60:	bf14      	ite	ne
    cd62:	2200      	movne	r2, #0
    cd64:	2201      	moveq	r2, #1
    cd66:	4621      	mov	r1, r4
    cd68:	f00c fa17 	bl	1919a <_DNS_ValidateIf>
    cd6c:	2800      	cmp	r0, #0
    cd6e:	d0ef      	beq.n	cd50 <_DNS_Send_Query+0x168>
    cd70:	e751      	b.n	cc16 <_DNS_Send_Query+0x2e>
    pDnsHE->currNet = 0;    // make sure next time we start with a fresh interface
    cd72:	2300      	movs	r3, #0
    cd74:	61e3      	str	r3, [r4, #28]
            res = TCPIP_DNS_RES_NO_INTERFACE;
    cd76:	f06f 0006 	mvn.w	r0, #6
    cd7a:	e048      	b.n	ce0e <_DNS_Send_Query+0x226>
            oldIf = pDnsHE->currNet; 
    cd7c:	f8d4 901c 	ldr.w	r9, [r4, #28]
        if(pDnsHE->currServerIx != oldServerIx || pDnsHE->currNet != oldIf )
    cd80:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
    cd84:	42ab      	cmp	r3, r5
    cd86:	f47f af4f 	bne.w	cc28 <_DNS_Send_Query+0x40>
    cd8a:	e754      	b.n	cc36 <_DNS_Send_Query+0x4e>
    cd8c:	69e3      	ldr	r3, [r4, #28]
    cd8e:	454b      	cmp	r3, r9
    cd90:	f47f af4a 	bne.w	cc28 <_DNS_Send_Query+0x40>
    cd94:	e74f      	b.n	cc36 <_DNS_Send_Query+0x4e>
                TCPIP_ARP_EntryRemove(oldIf, &oldDns);
    cd96:	4669      	mov	r1, sp
    cd98:	4648      	mov	r0, r9
    cd9a:	f00d f93f 	bl	1a01c <TCPIP_ARP_EntryRemove>
                _DNS_DbgArpFlush(oldIf, oldServerIx, pDnsHE->currNet, pDnsHE->currServerIx, &oldDns);
    cd9e:	e74a      	b.n	cc36 <_DNS_Send_Query+0x4e>
            res = TCPIP_DNS_RES_SOCKET_ERROR;
    cda0:	f06f 0009 	mvn.w	r0, #9
    cda4:	e033      	b.n	ce0e <_DNS_Send_Query+0x226>
            res = TCPIP_DNS_RES_SOCKET_ERROR;
    cda6:	f06f 0009 	mvn.w	r0, #9
    cdaa:	e030      	b.n	ce0e <_DNS_Send_Query+0x226>
        len = rightPtr - string - 1;
    cdac:	eba8 0801 	sub.w	r8, r8, r1
    cdb0:	f108 38ff 	add.w	r8, r8, #4294967295
        *pPutDnsStr++ = (uint8_t)len;
    cdb4:	f805 8b01 	strb.w	r8, [r5], #1
        memcpy(pPutDnsStr, string, len);
    cdb8:	4642      	mov	r2, r8
    cdba:	4628      	mov	r0, r5
    cdbc:	f014 f9e0 	bl	21180 <memcpy>
        pPutDnsStr = pPutDnsStr + len;
    cdc0:	eb05 0008 	add.w	r0, r5, r8
        if(i == 0 || i == '/' || i == ',' || i == '>')
    cdc4:	e00b      	b.n	cdde <_DNS_Send_Query+0x1f6>
        len = rightPtr - string - 1;
    cdc6:	eba8 0801 	sub.w	r8, r8, r1
    cdca:	f108 38ff 	add.w	r8, r8, #4294967295
        *pPutDnsStr++ = (uint8_t)len;
    cdce:	f805 8b01 	strb.w	r8, [r5], #1
        memcpy(pPutDnsStr, string, len);
    cdd2:	4642      	mov	r2, r8
    cdd4:	4628      	mov	r0, r5
    cdd6:	f014 f9d3 	bl	21180 <memcpy>
        pPutDnsStr = pPutDnsStr + len;
    cdda:	eb05 0008 	add.w	r0, r5, r8
    *pPutDnsStr++ = 0;
    cdde:	2200      	movs	r2, #0
    cde0:	7002      	strb	r2, [r0, #0]
        *wrPtr++ = 0x00;
    cde2:	7042      	strb	r2, [r0, #1]
        *wrPtr++ = pDnsHE->resolve_type;
    cde4:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
    cde8:	7083      	strb	r3, [r0, #2]
        *wrPtr++ = 0x00;
    cdea:	70c2      	strb	r2, [r0, #3]
        *wrPtr++ = 0x01; // 0x0001
    cdec:	2301      	movs	r3, #1
    cdee:	7103      	strb	r3, [r0, #4]
    cdf0:	1d44      	adds	r4, r0, #5
        sktPayload = (uint16_t)(wrPtr - startPtr);
    cdf2:	1be4      	subs	r4, r4, r7
    cdf4:	b2a4      	uxth	r4, r4
        TCPIP_UDP_TxOffsetSet(dnsSocket, sktPayload, false);
    cdf6:	4621      	mov	r1, r4
    cdf8:	4630      	mov	r0, r6
    cdfa:	f011 f8b8 	bl	1df6e <TCPIP_UDP_TxOffsetSet>
        if(TCPIP_UDP_Flush(dnsSocket) != sktPayload)
    cdfe:	4630      	mov	r0, r6
    ce00:	f001 f972 	bl	e0e8 <TCPIP_UDP_Flush>
            res = TCPIP_DNS_RES_PENDING;
    ce04:	42a0      	cmp	r0, r4
    ce06:	bf14      	ite	ne
    ce08:	f06f 0009 	mvnne.w	r0, #9
    ce0c:	2001      	moveq	r0, #1
}
    ce0e:	b009      	add	sp, #36	; 0x24
    ce10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        len = rightPtr - string - 1;
    ce14:	eba8 0801 	sub.w	r8, r8, r1
    ce18:	f108 38ff 	add.w	r8, r8, #4294967295
        *pPutDnsStr++ = (uint8_t)len;
    ce1c:	f805 8b01 	strb.w	r8, [r5], #1
        memcpy(pPutDnsStr, string, len);
    ce20:	4642      	mov	r2, r8
    ce22:	4628      	mov	r0, r5
    ce24:	f014 f9ac 	bl	21180 <memcpy>
        pPutDnsStr = pPutDnsStr + len;
    ce28:	eb05 0008 	add.w	r0, r5, r8
        if(i == 0 || i == '/' || i == ',' || i == '>')
    ce2c:	e7d7      	b.n	cdde <_DNS_Send_Query+0x1f6>
        len = rightPtr - string - 1;
    ce2e:	eba8 0901 	sub.w	r9, r8, r1
    ce32:	f109 39ff 	add.w	r9, r9, #4294967295
        *pPutDnsStr++ = (uint8_t)len;
    ce36:	f805 9b01 	strb.w	r9, [r5], #1
        memcpy(pPutDnsStr, string, len);
    ce3a:	464a      	mov	r2, r9
    ce3c:	4628      	mov	r0, r5
    ce3e:	f014 f99f 	bl	21180 <memcpy>
        pPutDnsStr = pPutDnsStr + len;
    ce42:	444d      	add	r5, r9
            i = *rightPtr++;
    ce44:	4641      	mov	r1, r8
    ce46:	f818 3b01 	ldrb.w	r3, [r8], #1
        }while((i != 0) && (i != '.') && (i != '/') && (i != ',') && (i != '>'));
    ce4a:	2b00      	cmp	r3, #0
    ce4c:	d0bb      	beq.n	cdc6 <_DNS_Send_Query+0x1de>
    ce4e:	2b2e      	cmp	r3, #46	; 0x2e
    ce50:	d0ed      	beq.n	ce2e <_DNS_Send_Query+0x246>
    ce52:	2b2f      	cmp	r3, #47	; 0x2f
    ce54:	d0de      	beq.n	ce14 <_DNS_Send_Query+0x22c>
    ce56:	2b2c      	cmp	r3, #44	; 0x2c
    ce58:	d0a8      	beq.n	cdac <_DNS_Send_Query+0x1c4>
    ce5a:	2b3e      	cmp	r3, #62	; 0x3e
    ce5c:	d1f3      	bne.n	ce46 <_DNS_Send_Query+0x25e>
        len = rightPtr - string - 1;
    ce5e:	eba8 0801 	sub.w	r8, r8, r1
    ce62:	f108 38ff 	add.w	r8, r8, #4294967295
        *pPutDnsStr++ = (uint8_t)len;
    ce66:	f805 8b01 	strb.w	r8, [r5], #1
        memcpy(pPutDnsStr, string, len);
    ce6a:	4642      	mov	r2, r8
    ce6c:	4628      	mov	r0, r5
    ce6e:	f014 f987 	bl	21180 <memcpy>
        pPutDnsStr = pPutDnsStr + len;
    ce72:	eb05 0008 	add.w	r0, r5, r8
        if(i == 0 || i == '/' || i == ',' || i == '>')
    ce76:	e7b2      	b.n	cdde <_DNS_Send_Query+0x1f6>

Disassembly of section .text._CommandDhcpOptions%213:

0000ce78 <_CommandDhcpOptions>:
{
    ce78:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ce7c:	b096      	sub	sp, #88	; 0x58
    ce7e:	4604      	mov	r4, r0
    ce80:	4615      	mov	r5, r2
    const void* cmdIoParam = pCmdIO->cmdIoParam;
    ce82:	6846      	ldr	r6, [r0, #4]
    if (argc < 3)
    ce84:	2902      	cmp	r1, #2
    ce86:	dc13      	bgt.n	ceb0 <_CommandDhcpOptions+0x38>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Usage: %s <interface> <on/off/renew/request/info> \r\n", argv[0]);
    ce88:	4f83      	ldr	r7, [pc, #524]	; (d098 <_CommandDhcpOptions+0x220>)
    ce8a:	6803      	ldr	r3, [r0, #0]
    ce8c:	685b      	ldr	r3, [r3, #4]
    ce8e:	6812      	ldr	r2, [r2, #0]
    ce90:	f607 719c 	addw	r1, r7, #3996	; 0xf9c
    ce94:	4630      	mov	r0, r6
    ce96:	4798      	blx	r3
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Ex: %s PIC32INT on \r\n", argv[0]);
    ce98:	6823      	ldr	r3, [r4, #0]
    ce9a:	685b      	ldr	r3, [r3, #4]
    ce9c:	682a      	ldr	r2, [r5, #0]
    ce9e:	f507 71fe 	add.w	r1, r7, #508	; 0x1fc
    cea2:	4630      	mov	r0, r6
    cea4:	4798      	blx	r3
        return false;
    cea6:	2700      	movs	r7, #0
}
    cea8:	4638      	mov	r0, r7
    ceaa:	b016      	add	sp, #88	; 0x58
    ceac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ceb0:	4688      	mov	r8, r1
    reqIpAddr.Val = 0;
    ceb2:	2300      	movs	r3, #0
    ceb4:	9315      	str	r3, [sp, #84]	; 0x54
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
    ceb6:	6850      	ldr	r0, [r2, #4]
    ceb8:	f010 fe7c 	bl	1dbb4 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
    cebc:	4682      	mov	sl, r0
    cebe:	b328      	cbz	r0, cf0c <_CommandDhcpOptions+0x94>
    if (strcmp(argv[2], "on") == 0)
    cec0:	f8d5 9008 	ldr.w	r9, [r5, #8]
    cec4:	4975      	ldr	r1, [pc, #468]	; (d09c <_CommandDhcpOptions+0x224>)
    cec6:	4648      	mov	r0, r9
    cec8:	f014 fda8 	bl	21a1c <strcmp>
    cecc:	2800      	cmp	r0, #0
    cece:	f000 80c2 	beq.w	d056 <_CommandDhcpOptions+0x1de>
    else if (strcmp(argv[2], "off") == 0)
    ced2:	4973      	ldr	r1, [pc, #460]	; (d0a0 <_CommandDhcpOptions+0x228>)
    ced4:	4648      	mov	r0, r9
    ced6:	f014 fda1 	bl	21a1c <strcmp>
    ceda:	2800      	cmp	r0, #0
    cedc:	f000 80d7 	beq.w	d08e <_CommandDhcpOptions+0x216>
    else if (strcmp(argv[2], "renew") == 0)
    cee0:	4970      	ldr	r1, [pc, #448]	; (d0a4 <_CommandDhcpOptions+0x22c>)
    cee2:	4648      	mov	r0, r9
    cee4:	f014 fd9a 	bl	21a1c <strcmp>
    cee8:	2800      	cmp	r0, #0
    ceea:	f000 80cc 	beq.w	d086 <_CommandDhcpOptions+0x20e>
    else if (strcmp(argv[2], "request") == 0)
    ceee:	496e      	ldr	r1, [pc, #440]	; (d0a8 <_CommandDhcpOptions+0x230>)
    cef0:	4648      	mov	r0, r9
    cef2:	f014 fd93 	bl	21a1c <strcmp>
    cef6:	4607      	mov	r7, r0
    cef8:	b9e0      	cbnz	r0, cf34 <_CommandDhcpOptions+0xbc>
        if(argc < 4)
    cefa:	f1b8 0f03 	cmp.w	r8, #3
    cefe:	dc0c      	bgt.n	cf1a <_CommandDhcpOptions+0xa2>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Request needs an IP address\r\n");
    cf00:	6823      	ldr	r3, [r4, #0]
    cf02:	681b      	ldr	r3, [r3, #0]
    cf04:	4969      	ldr	r1, [pc, #420]	; (d0ac <_CommandDhcpOptions+0x234>)
    cf06:	4630      	mov	r0, r6
    cf08:	4798      	blx	r3
            return false;
    cf0a:	e7cd      	b.n	cea8 <_CommandDhcpOptions+0x30>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface\r\n");
    cf0c:	6823      	ldr	r3, [r4, #0]
    cf0e:	681b      	ldr	r3, [r3, #0]
    cf10:	4967      	ldr	r1, [pc, #412]	; (d0b0 <_CommandDhcpOptions+0x238>)
    cf12:	4630      	mov	r0, r6
    cf14:	4798      	blx	r3
        return false;
    cf16:	2700      	movs	r7, #0
    cf18:	e7c6      	b.n	cea8 <_CommandDhcpOptions+0x30>
        if (!TCPIP_Helper_StringToIPAddress(argv[3], &reqIpAddr))
    cf1a:	a915      	add	r1, sp, #84	; 0x54
    cf1c:	68e8      	ldr	r0, [r5, #12]
    cf1e:	f006 facf 	bl	134c0 <TCPIP_Helper_StringToIPAddress>
    cf22:	2800      	cmp	r0, #0
    cf24:	f040 80aa 	bne.w	d07c <_CommandDhcpOptions+0x204>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Invalid IP address string \r\n");
    cf28:	6823      	ldr	r3, [r4, #0]
    cf2a:	681b      	ldr	r3, [r3, #0]
    cf2c:	4961      	ldr	r1, [pc, #388]	; (d0b4 <_CommandDhcpOptions+0x23c>)
    cf2e:	4630      	mov	r0, r6
    cf30:	4798      	blx	r3
            return false;
    cf32:	e7b9      	b.n	cea8 <_CommandDhcpOptions+0x30>
    else if (strcmp(argv[2], "info") == 0)
    cf34:	4960      	ldr	r1, [pc, #384]	; (d0b8 <_CommandDhcpOptions+0x240>)
    cf36:	4648      	mov	r0, r9
    cf38:	f014 fd70 	bl	21a1c <strcmp>
    cf3c:	4607      	mov	r7, r0
    cf3e:	b130      	cbz	r0, cf4e <_CommandDhcpOptions+0xd6>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown option\r\n");
    cf40:	6823      	ldr	r3, [r4, #0]
    cf42:	681b      	ldr	r3, [r3, #0]
    cf44:	495d      	ldr	r1, [pc, #372]	; (d0bc <_CommandDhcpOptions+0x244>)
    cf46:	4630      	mov	r0, r6
    cf48:	4798      	blx	r3
        return false;
    cf4a:	2700      	movs	r7, #0
    cf4c:	e7ac      	b.n	cea8 <_CommandDhcpOptions+0x30>
        if(TCPIP_DHCP_InfoGet(netH, &dhcpInfo))
    cf4e:	a908      	add	r1, sp, #32
    cf50:	4650      	mov	r0, sl
    cf52:	f00b f9f9 	bl	18348 <TCPIP_DHCP_InfoGet>
    cf56:	2800      	cmp	r0, #0
    cf58:	d077      	beq.n	d04a <_CommandDhcpOptions+0x1d2>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP status: %d ( %d == Bound), time: %d\r\n", dhcpInfo.status, TCPIP_DHCP_BOUND, dhcpInfo.dhcpTime);
    cf5a:	6823      	ldr	r3, [r4, #0]
    cf5c:	9a09      	ldr	r2, [sp, #36]	; 0x24
    cf5e:	9200      	str	r2, [sp, #0]
    cf60:	685d      	ldr	r5, [r3, #4]
    cf62:	2308      	movs	r3, #8
    cf64:	f89d 2020 	ldrb.w	r2, [sp, #32]
    cf68:	4955      	ldr	r1, [pc, #340]	; (d0c0 <_CommandDhcpOptions+0x248>)
    cf6a:	4630      	mov	r0, r6
    cf6c:	47a8      	blx	r5
            if(dhcpInfo.status >= TCPIP_DHCP_BOUND)
    cf6e:	f89d 3020 	ldrb.w	r3, [sp, #32]
    cf72:	2b07      	cmp	r3, #7
    cf74:	d998      	bls.n	cea8 <_CommandDhcpOptions+0x30>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP lease start: %d, duration: %ds\r\n", dhcpInfo.leaseStartTime, dhcpInfo.leaseDuration);
    cf76:	4d53      	ldr	r5, [pc, #332]	; (d0c4 <_CommandDhcpOptions+0x24c>)
    cf78:	6823      	ldr	r3, [r4, #0]
    cf7a:	f8d3 8004 	ldr.w	r8, [r3, #4]
    cf7e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    cf80:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    cf82:	f1a5 01c0 	sub.w	r1, r5, #192	; 0xc0
    cf86:	4630      	mov	r0, r6
    cf88:	47c0      	blx	r8
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP renew time: %d, rebind time: %d\r\n", dhcpInfo.renewTime, dhcpInfo.rebindTime);
    cf8a:	6823      	ldr	r3, [r4, #0]
    cf8c:	f8d3 8004 	ldr.w	r8, [r3, #4]
    cf90:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    cf92:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    cf94:	f1a5 0198 	sub.w	r1, r5, #152	; 0x98
    cf98:	4630      	mov	r0, r6
    cf9a:	47c0      	blx	r8
                TCPIP_Helper_IPAddressToString(&dhcpInfo.dhcpAddress, addBuff, sizeof(addBuff));
    cf9c:	2214      	movs	r2, #20
    cf9e:	a903      	add	r1, sp, #12
    cfa0:	a80e      	add	r0, sp, #56	; 0x38
    cfa2:	f00f fd77 	bl	1ca94 <TCPIP_Helper_IPAddressToString>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP address: %s\r\n", addBuff);
    cfa6:	6823      	ldr	r3, [r4, #0]
    cfa8:	685b      	ldr	r3, [r3, #4]
    cfaa:	aa03      	add	r2, sp, #12
    cfac:	f1a5 0170 	sub.w	r1, r5, #112	; 0x70
    cfb0:	4630      	mov	r0, r6
    cfb2:	4798      	blx	r3
                TCPIP_Helper_IPAddressToString(&dhcpInfo.serverAddress, addBuff, sizeof(addBuff));
    cfb4:	2214      	movs	r2, #20
    cfb6:	a903      	add	r1, sp, #12
    cfb8:	a810      	add	r0, sp, #64	; 0x40
    cfba:	f00f fd6b 	bl	1ca94 <TCPIP_Helper_IPAddressToString>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP server: %s\r\n", addBuff);
    cfbe:	6823      	ldr	r3, [r4, #0]
    cfc0:	685b      	ldr	r3, [r3, #4]
    cfc2:	aa03      	add	r2, sp, #12
    cfc4:	f1a5 015c 	sub.w	r1, r5, #92	; 0x5c
    cfc8:	4630      	mov	r0, r6
    cfca:	4798      	blx	r3
                if(dhcpInfo.bootFileName == 0 || strlen(dhcpInfo.bootFileName) == 0)
    cfcc:	9a11      	ldr	r2, [sp, #68]	; 0x44
    cfce:	b18a      	cbz	r2, cff4 <_CommandDhcpOptions+0x17c>
    cfd0:	7813      	ldrb	r3, [r2, #0]
                    bootName = "not given";
    cfd2:	2b00      	cmp	r3, #0
    cfd4:	4b3c      	ldr	r3, [pc, #240]	; (d0c8 <_CommandDhcpOptions+0x250>)
    cfd6:	bf08      	it	eq
    cfd8:	461a      	moveq	r2, r3
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP boot name: %s\r\n", bootName);
    cfda:	6823      	ldr	r3, [r4, #0]
    cfdc:	685b      	ldr	r3, [r3, #4]
    cfde:	493b      	ldr	r1, [pc, #236]	; (d0cc <_CommandDhcpOptions+0x254>)
    cfe0:	4630      	mov	r0, r6
    cfe2:	4798      	blx	r3
                if(dhcpInfo.timeServersNo)
    cfe4:	f89d 3048 	ldrb.w	r3, [sp, #72]	; 0x48
    cfe8:	b933      	cbnz	r3, cff8 <_CommandDhcpOptions+0x180>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP Time servers: %d, %s\r\n", dhcpInfo.timeServersNo, dhcpInfo.timeServersNo ? addBuff: "None");
    cfea:	6823      	ldr	r3, [r4, #0]
    cfec:	685d      	ldr	r5, [r3, #4]
    cfee:	463a      	mov	r2, r7
    cff0:	4b37      	ldr	r3, [pc, #220]	; (d0d0 <_CommandDhcpOptions+0x258>)
    cff2:	e00c      	b.n	d00e <_CommandDhcpOptions+0x196>
                    bootName = "not given";
    cff4:	4a34      	ldr	r2, [pc, #208]	; (d0c8 <_CommandDhcpOptions+0x250>)
    cff6:	e7f0      	b.n	cfda <_CommandDhcpOptions+0x162>
                    TCPIP_Helper_IPAddressToString(dhcpInfo.timeServers, addBuff, sizeof(addBuff));
    cff8:	2214      	movs	r2, #20
    cffa:	a903      	add	r1, sp, #12
    cffc:	9813      	ldr	r0, [sp, #76]	; 0x4c
    cffe:	f00f fd49 	bl	1ca94 <TCPIP_Helper_IPAddressToString>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP Time servers: %d, %s\r\n", dhcpInfo.timeServersNo, dhcpInfo.timeServersNo ? addBuff: "None");
    d002:	6823      	ldr	r3, [r4, #0]
    d004:	685d      	ldr	r5, [r3, #4]
    d006:	f89d 2048 	ldrb.w	r2, [sp, #72]	; 0x48
    d00a:	ab03      	add	r3, sp, #12
    d00c:	b152      	cbz	r2, d024 <_CommandDhcpOptions+0x1ac>
    d00e:	4931      	ldr	r1, [pc, #196]	; (d0d4 <_CommandDhcpOptions+0x25c>)
    d010:	4630      	mov	r0, r6
    d012:	47a8      	blx	r5
                if(dhcpInfo.ntpServersNo)
    d014:	f89d 3049 	ldrb.w	r3, [sp, #73]	; 0x49
    d018:	b933      	cbnz	r3, d028 <_CommandDhcpOptions+0x1b0>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP NTP servers: %d, %s\r\n", dhcpInfo.ntpServersNo, dhcpInfo.ntpServersNo ? addBuff :  "None");
    d01a:	6823      	ldr	r3, [r4, #0]
    d01c:	685c      	ldr	r4, [r3, #4]
    d01e:	463a      	mov	r2, r7
    d020:	4b2b      	ldr	r3, [pc, #172]	; (d0d0 <_CommandDhcpOptions+0x258>)
    d022:	e00c      	b.n	d03e <_CommandDhcpOptions+0x1c6>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP Time servers: %d, %s\r\n", dhcpInfo.timeServersNo, dhcpInfo.timeServersNo ? addBuff: "None");
    d024:	4b2a      	ldr	r3, [pc, #168]	; (d0d0 <_CommandDhcpOptions+0x258>)
    d026:	e7f2      	b.n	d00e <_CommandDhcpOptions+0x196>
                    TCPIP_Helper_IPAddressToString(dhcpInfo.ntpServers, addBuff, sizeof(addBuff));
    d028:	2214      	movs	r2, #20
    d02a:	a903      	add	r1, sp, #12
    d02c:	9814      	ldr	r0, [sp, #80]	; 0x50
    d02e:	f00f fd31 	bl	1ca94 <TCPIP_Helper_IPAddressToString>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP NTP servers: %d, %s\r\n", dhcpInfo.ntpServersNo, dhcpInfo.ntpServersNo ? addBuff :  "None");
    d032:	6823      	ldr	r3, [r4, #0]
    d034:	685c      	ldr	r4, [r3, #4]
    d036:	f89d 2049 	ldrb.w	r2, [sp, #73]	; 0x49
    d03a:	ab03      	add	r3, sp, #12
    d03c:	b11a      	cbz	r2, d046 <_CommandDhcpOptions+0x1ce>
    d03e:	4926      	ldr	r1, [pc, #152]	; (d0d8 <_CommandDhcpOptions+0x260>)
    d040:	4630      	mov	r0, r6
    d042:	47a0      	blx	r4
    d044:	e730      	b.n	cea8 <_CommandDhcpOptions+0x30>
    d046:	4b22      	ldr	r3, [pc, #136]	; (d0d0 <_CommandDhcpOptions+0x258>)
    d048:	e7f9      	b.n	d03e <_CommandDhcpOptions+0x1c6>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "DHCP: failed to get info\r\n");
    d04a:	6823      	ldr	r3, [r4, #0]
    d04c:	681b      	ldr	r3, [r3, #0]
    d04e:	4923      	ldr	r1, [pc, #140]	; (d0dc <_CommandDhcpOptions+0x264>)
    d050:	4630      	mov	r0, r6
    d052:	4798      	blx	r3
        return false;
    d054:	e728      	b.n	cea8 <_CommandDhcpOptions+0x30>
            dhcpRes = TCPIP_DHCP_Enable(netH);
    d056:	4650      	mov	r0, sl
    d058:	f00e fcc2 	bl	1b9e0 <TCPIP_DHCP_Enable>
    (*pCmdIO->pCmdApi->print)(cmdIoParam, "%s %s %s\r\n", argv[0], argv[2], dhcpRes ? "success" : "fail");
    d05c:	6823      	ldr	r3, [r4, #0]
    d05e:	685c      	ldr	r4, [r3, #4]
    d060:	682a      	ldr	r2, [r5, #0]
    d062:	68ab      	ldr	r3, [r5, #8]
    d064:	2800      	cmp	r0, #0
    d066:	491e      	ldr	r1, [pc, #120]	; (d0e0 <_CommandDhcpOptions+0x268>)
    d068:	f101 00a0 	add.w	r0, r1, #160	; 0xa0
    d06c:	bf08      	it	eq
    d06e:	4601      	moveq	r1, r0
    d070:	9100      	str	r1, [sp, #0]
    d072:	491c      	ldr	r1, [pc, #112]	; (d0e4 <_CommandDhcpOptions+0x26c>)
    d074:	4630      	mov	r0, r6
    d076:	47a0      	blx	r4
    return true;
    d078:	2701      	movs	r7, #1
    d07a:	e715      	b.n	cea8 <_CommandDhcpOptions+0x30>
            dhcpRes = TCPIP_DHCP_Request(netH, reqIpAddr);
    d07c:	9915      	ldr	r1, [sp, #84]	; 0x54
    d07e:	4650      	mov	r0, sl
    d080:	f00b f916 	bl	182b0 <TCPIP_DHCP_Request>
            break;
    d084:	e7ea      	b.n	d05c <_CommandDhcpOptions+0x1e4>
            dhcpRes = TCPIP_DHCP_Renew(netH);
    d086:	4650      	mov	r0, sl
    d088:	f00f fae0 	bl	1c64c <TCPIP_DHCP_Renew>
            break;
    d08c:	e7e6      	b.n	d05c <_CommandDhcpOptions+0x1e4>
            dhcpRes = TCPIP_DHCP_Disable(netH);
    d08e:	4650      	mov	r0, sl
    d090:	f00e fa9e 	bl	1b5d0 <TCPIP_DHCP_Disable>
            break;
    d094:	e7e2      	b.n	d05c <_CommandDhcpOptions+0x1e4>
    d096:	bf00      	nop
    d098:	0000028c 	.word	0x0000028c
    d09c:	000004b4 	.word	0x000004b4
    d0a0:	000004b8 	.word	0x000004b8
    d0a4:	00001260 	.word	0x00001260
    d0a8:	00001268 	.word	0x00001268
    d0ac:	00001270 	.word	0x00001270
    d0b0:	000004a0 	.word	0x000004a0
    d0b4:	0000103c 	.word	0x0000103c
    d0b8:	00001290 	.word	0x00001290
    d0bc:	000004bc 	.word	0x000004bc
    d0c0:	00001298 	.word	0x00001298
    d0c4:	00001384 	.word	0x00001384
    d0c8:	0000120c 	.word	0x0000120c
    d0cc:	0000133c 	.word	0x0000133c
    d0d0:	00001218 	.word	0x00001218
    d0d4:	00001354 	.word	0x00001354
    d0d8:	00001370 	.word	0x00001370
    d0dc:	0000138c 	.word	0x0000138c
    d0e0:	00001180 	.word	0x00001180
    d0e4:	000013a8 	.word	0x000013a8

Disassembly of section .rodata%214:

0000d0e8 <.rodata%214>:
    d0e8:	00082008 	.word	0x00082008
    d0ec:	00000008 	.word	0x00000008
    d0f0:	003e0a0d 	.word	0x003e0a0d
    d0f4:	2d2d0a0d 	.word	0x2d2d0a0d
    d0f8:	2d2d2d2d 	.word	0x2d2d2d2d
    d0fc:	7553202d 	.word	0x7553202d
    d100:	726f7070 	.word	0x726f7070
    d104:	20646574 	.word	0x20646574
    d108:	6d6d6f63 	.word	0x6d6d6f63
    d10c:	20646e61 	.word	0x20646e61
    d110:	756f7267 	.word	0x756f7267
    d114:	2d207370 	.word	0x2d207370
    d118:	2d2d2d2d 	.word	0x2d2d2d2d
    d11c:	0000002d 	.word	0x0000002d
    d120:	2a200a0d 	.word	0x2a200a0d
    d124:	00202a2a 	.word	0x00202a2a
    d128:	2a2a2a20 	.word	0x2a2a2a20
    d12c:	00000000 	.word	0x00000000
    d130:	2d2d0a0d 	.word	0x2d2d0a0d
    d134:	2d2d2d2d 	.word	0x2d2d2d2d
    d138:	2d2d2d2d 	.word	0x2d2d2d2d
    d13c:	69754220 	.word	0x69754220
    d140:	6920746c 	.word	0x6920746c
    d144:	6f63206e 	.word	0x6f63206e
    d148:	6e616d6d 	.word	0x6e616d6d
    d14c:	2d207364 	.word	0x2d207364
    d150:	2d2d2d2d 	.word	0x2d2d2d2d
    d154:	2d2d2d2d 	.word	0x2d2d2d2d
    d158:	0000002d 	.word	0x0000002d
    d15c:	00000a0d 	.word	0x00000a0d
    d160:	6e550a0d 	.word	0x6e550a0d
    d164:	776f6e6b 	.word	0x776f6e6b
    d168:	6f63206e 	.word	0x6f63206e
    d16c:	6e616d6d 	.word	0x6e616d6d
    d170:	72672064 	.word	0x72672064
    d174:	2e70756f 	.word	0x2e70756f
    d178:	79725420 	.word	0x79725420
    d17c:	6c656820 	.word	0x6c656820
    d180:	000a0d70 	.word	0x000a0d70
    d184:	64255b1b 	.word	0x64255b1b
    d188:	00000043 	.word	0x00000043
    d18c:	64255b1b 	.word	0x64255b1b
    d190:	00000044 	.word	0x00000044
    d194:	2a200a0d 	.word	0x2a200a0d
    d198:	51202a2a 	.word	0x51202a2a
    d19c:	74746975 	.word	0x74746975
    d1a0:	20676e69 	.word	0x20676e69
    d1a4:	20656874 	.word	0x20656874
    d1a8:	6d6d6f43 	.word	0x6d6d6f43
    d1ac:	20646e61 	.word	0x20646e61
    d1b0:	636f7250 	.word	0x636f7250
    d1b4:	6f737365 	.word	0x6f737365
    d1b8:	42202e72 	.word	0x42202e72
    d1bc:	2a206579 	.word	0x2a206579
    d1c0:	0a0d2a2a 	.word	0x0a0d2a2a
    d1c4:	00000000 	.word	0x00000000
    d1c8:	2a200a0d 	.word	0x2a200a0d
    d1cc:	53202a2a 	.word	0x53202a2a
    d1d0:	65747379 	.word	0x65747379
    d1d4:	6552206d 	.word	0x6552206d
    d1d8:	746f6f62 	.word	0x746f6f62
    d1dc:	2a2a2a20 	.word	0x2a2a2a20
    d1e0:	00000a0d 	.word	0x00000a0d
    d1e4:	002c0920 	.word	0x002c0920
    d1e8:	54200d0a 	.word	0x54200d0a
    d1ec:	6d206f6f 	.word	0x6d206f6f
    d1f0:	20796e61 	.word	0x20796e61
    d1f4:	75677261 	.word	0x75677261
    d1f8:	746e656d 	.word	0x746e656d
    d1fc:	4d202e73 	.word	0x4d202e73
    d200:	6d697861 	.word	0x6d697861
    d204:	61206d75 	.word	0x61206d75
    d208:	20736772 	.word	0x20736772
    d20c:	70707573 	.word	0x70707573
    d210:	6574726f 	.word	0x6574726f
    d214:	25203a64 	.word	0x25203a64
    d218:	0a0d2164 	.word	0x0a0d2164
    d21c:	00000000 	.word	0x00000000
    d220:	2a2a2a20 	.word	0x2a2a2a20
    d224:	6d6f4320 	.word	0x6d6f4320
    d228:	646e616d 	.word	0x646e616d
    d22c:	6f725020 	.word	0x6f725020
    d230:	73736563 	.word	0x73736563
    d234:	203a726f 	.word	0x203a726f
    d238:	61656c50 	.word	0x61656c50
    d23c:	74206573 	.word	0x74206573
    d240:	20657079 	.word	0x20657079
    d244:	61206e69 	.word	0x61206e69
    d248:	6d6f6320 	.word	0x6d6f6320
    d24c:	646e616d 	.word	0x646e616d
    d250:	0d2a2a2a 	.word	0x0d2a2a2a
    d254:	0000000a 	.word	0x0000000a
    d258:	2a2a2a20 	.word	0x2a2a2a20
    d25c:	6d6f4320 	.word	0x6d6f4320
    d260:	646e616d 	.word	0x646e616d
    d264:	6f725020 	.word	0x6f725020
    d268:	73736563 	.word	0x73736563
    d26c:	203a726f 	.word	0x203a726f
    d270:	6e6b6e75 	.word	0x6e6b6e75
    d274:	206e776f 	.word	0x206e776f
    d278:	6d6d6f63 	.word	0x6d6d6f63
    d27c:	2e646e61 	.word	0x2e646e61
    d280:	2a2a2a20 	.word	0x2a2a2a20
    d284:	00000a0d 	.word	0x00000a0d
    d288:	0000003e 	.word	0x0000003e
    d28c:	4b5b1b08 	.word	0x4b5b1b08
    d290:	5b1b7325 	.word	0x5b1b7325
    d294:	00446425 	.word	0x00446425
    d298:	4b5b1b08 	.word	0x4b5b1b08
    d29c:	00000000 	.word	0x00000000
    d2a0:	254b5b1b 	.word	0x254b5b1b
    d2a4:	255b1b73 	.word	0x255b1b73
    d2a8:	00004464 	.word	0x00004464
    d2ac:	5b1b7325 	.word	0x5b1b7325
    d2b0:	00446425 	.word	0x00446425
    d2b4:	2a2a2a20 	.word	0x2a2a2a20
    d2b8:	6d6f4320 	.word	0x6d6f4320
    d2bc:	646e616d 	.word	0x646e616d
    d2c0:	6f725020 	.word	0x6f725020
    d2c4:	73736563 	.word	0x73736563
    d2c8:	6220726f 	.word	0x6220726f
    d2cc:	65666675 	.word	0x65666675
    d2d0:	78652072 	.word	0x78652072
    d2d4:	64656563 	.word	0x64656563
    d2d8:	202e6465 	.word	0x202e6465
    d2dc:	72746552 	.word	0x72746552
    d2e0:	2a202e79 	.word	0x2a202e79
    d2e4:	0a0d2a2a 	.word	0x0a0d2a2a
    d2e8:	00000000 	.word	0x00000000
    d2ec:	65736572 	.word	0x65736572
    d2f0:	00000074 	.word	0x00000074
    d2f4:	6552203a 	.word	0x6552203a
    d2f8:	20746573 	.word	0x20746573
    d2fc:	74736f68 	.word	0x74736f68
    d300:	00000000 	.word	0x00000000
    d304:	00000071 	.word	0x00000071
    d308:	7571203a 	.word	0x7571203a
    d30c:	63207469 	.word	0x63207469
    d310:	616d6d6f 	.word	0x616d6d6f
    d314:	7020646e 	.word	0x7020646e
    d318:	65636f72 	.word	0x65636f72
    d31c:	726f7373 	.word	0x726f7373
    d320:	00000000 	.word	0x00000000
    d324:	706c6568 	.word	0x706c6568
    d328:	00000000 	.word	0x00000000
    d32c:	6568203a 	.word	0x6568203a
    d330:	0000706c 	.word	0x0000706c
    d334:	00415b1b 	.word	0x00415b1b
    d338:	00425b1b 	.word	0x00425b1b
    d33c:	00435b1b 	.word	0x00435b1b
    d340:	00445b1b 	.word	0x00445b1b
    d344:	7e315b1b 	.word	0x7e315b1b
    d348:	00000000 	.word	0x00000000
    d34c:	7e345b1b 	.word	0x7e345b1b
    d350:	00          	.byte	0x00
    d351:	00          	.byte	0x00
    d352:	bf00      	nop

Disassembly of section .text.ReportBW_Jitter_Loss%215:

0000d354 <ReportBW_Jitter_Loss>:
{
    d354:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d358:	b089      	sub	sp, #36	; 0x24
    d35a:	4604      	mov	r4, r0
    d35c:	460d      	mov	r5, r1
    uint32_t tickFreq = SYS_TMR_TickCounterFrequencyGet(); 
    d35e:	f012 feed 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
    d362:	4681      	mov	r9, r0
    currentTime = SYS_TMR_TickCountGet();
    d364:	f012 fec2 	bl	200ec <SYS_TMR_TickCountGet>
    d368:	4606      	mov	r6, r0
    cmdIoParam = pIState->pCmdIO->cmdIoParam;
    d36a:	f8d4 70c4 	ldr.w	r7, [r4, #196]	; 0xc4
    d36e:	687b      	ldr	r3, [r7, #4]
    d370:	9305      	str	r3, [sp, #20]
    switch ( reportType )
    d372:	2d00      	cmp	r5, #0
    d374:	f000 8091 	beq.w	d49a <ReportBW_Jitter_Loss+0x146>
    d378:	2d02      	cmp	r5, #2
    d37a:	d864      	bhi.n	d446 <ReportBW_Jitter_Loss+0xf2>
           nDropped = pIState->errorCount;
    d37c:	f8d4 a030 	ldr.w	sl, [r4, #48]	; 0x30
           if (pIState->state == (uint8_t)IPERF_UDP_TX_DONE_STATE)
    d380:	f894 30ce 	ldrb.w	r3, [r4, #206]	; 0xce
    d384:	2b12      	cmp	r3, #18
               nAttempted = pIState->lastPktId + nDropped;
    d386:	bf06      	itte	eq
    d388:	6ae3      	ldreq	r3, [r4, #44]	; 0x2c
    d38a:	eb0a 0803 	addeq.w	r8, sl, r3
                nAttempted = pIState->lastPktId;
    d38e:	f8d4 802c 	ldrne.w	r8, [r4, #44]	; 0x2c
			msec = (uint32_t)(((double) (pIState->stopTime - pIState->startTime)) / (((double)(tickFreq))/1000));
    d392:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
    d396:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    d39a:	1ac0      	subs	r0, r0, r3
    d39c:	f7fd ffe6 	bl	b36c <__aeabi_ui2d>
    d3a0:	e9cd 0106 	strd	r0, r1, [sp, #24]
    d3a4:	4648      	mov	r0, r9
    d3a6:	f7fd ffe1 	bl	b36c <__aeabi_ui2d>
    d3aa:	2200      	movs	r2, #0
    d3ac:	4b77      	ldr	r3, [pc, #476]	; (d58c <ReportBW_Jitter_Loss+0x238>)
    d3ae:	f7fc fe29 	bl	a004 <__aeabi_ddiv>
    d3b2:	4602      	mov	r2, r0
    d3b4:	460b      	mov	r3, r1
    d3b6:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    d3ba:	f7fc fe23 	bl	a004 <__aeabi_ddiv>
    d3be:	f010 fd19 	bl	1ddf4 <__aeabi_d2uiz>
			if ( msec == 0u )
    d3c2:	4681      	mov	r9, r0
    d3c4:	2800      	cmp	r0, #0
    d3c6:	f000 80dc 	beq.w	d582 <ReportBW_Jitter_Loss+0x22e>
   				kbps = (pIState->totalLen * ((double) 8)) / msec;
    d3ca:	2200      	movs	r2, #0
    d3cc:	4b70      	ldr	r3, [pc, #448]	; (d590 <ReportBW_Jitter_Loss+0x23c>)
    d3ce:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    d3d2:	f7fc fced 	bl	9db0 <__aeabi_dmul>
    d3d6:	e9cd 0106 	strd	r0, r1, [sp, #24]
    d3da:	4648      	mov	r0, r9
    d3dc:	f7fd ffc6 	bl	b36c <__aeabi_ui2d>
    d3e0:	4602      	mov	r2, r0
    d3e2:	460b      	mov	r3, r1
    d3e4:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    d3e8:	f7fc fe0c 	bl	a004 <__aeabi_ddiv>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [0.0- %lu.%lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    d3ec:	683b      	ldr	r3, [r7, #0]
    d3ee:	f8d3 b004 	ldr.w	fp, [r3, #4]
    d3f2:	4f68      	ldr	r7, [pc, #416]	; (d594 <ReportBW_Jitter_Loss+0x240>)
    d3f4:	fba7 3709 	umull	r3, r7, r7, r9
    d3f8:	09bf      	lsrs	r7, r7, #6
                             (unsigned long)((msec%1000)/100),
    d3fa:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    d3fe:	fb03 9917 	mls	r9, r3, r7, r9
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [0.0- %lu.%lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    d402:	4b65      	ldr	r3, [pc, #404]	; (d598 <ReportBW_Jitter_Loss+0x244>)
    d404:	fba3 3909 	umull	r3, r9, r3, r9
    d408:	ea4f 1359 	mov.w	r3, r9, lsr #5
    d40c:	9306      	str	r3, [sp, #24]
    d40e:	f1b8 0f00 	cmp.w	r8, #0
    d412:	f000 80b9 	beq.w	d588 <ReportBW_Jitter_Loss+0x234>
                             (nAttempted == 0u) ? 0 : ((unsigned long)nDropped*100/(unsigned long)nAttempted),
    d416:	f04f 0964 	mov.w	r9, #100	; 0x64
    d41a:	fb09 f90a 	mul.w	r9, r9, sl
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [0.0- %lu.%lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    d41e:	fbb9 f9f8 	udiv	r9, r9, r8
                             (unsigned long) (kbps + ((double) 0.5)));
    d422:	2200      	movs	r2, #0
    d424:	4b5d      	ldr	r3, [pc, #372]	; (d59c <ReportBW_Jitter_Loss+0x248>)
    d426:	f7fd fe65 	bl	b0f4 <__adddf3>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [0.0- %lu.%lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    d42a:	f010 fce3 	bl	1ddf4 <__aeabi_d2uiz>
    d42e:	9003      	str	r0, [sp, #12]
    d430:	f8cd 9008 	str.w	r9, [sp, #8]
    d434:	f8cd 8004 	str.w	r8, [sp, #4]
    d438:	f8cd a000 	str.w	sl, [sp]
    d43c:	9b06      	ldr	r3, [sp, #24]
    d43e:	463a      	mov	r2, r7
    d440:	4957      	ldr	r1, [pc, #348]	; (d5a0 <ReportBW_Jitter_Loss+0x24c>)
    d442:	9805      	ldr	r0, [sp, #20]
    d444:	47d8      	blx	fp
    if ( reportType == 	SESSION_REPORT )
    d446:	2d02      	cmp	r5, #2
    d448:	d112      	bne.n	d470 <ReportBW_Jitter_Loss+0x11c>
      (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf: instance %d completed ...", pIState - gIperfState);
    d44a:	4a56      	ldr	r2, [pc, #344]	; (d5a4 <ReportBW_Jitter_Loss+0x250>)
    d44c:	1aa2      	subs	r2, r4, r2
    d44e:	10d2      	asrs	r2, r2, #3
    d450:	eb02 03c2 	add.w	r3, r2, r2, lsl #3
    d454:	eb02 0243 	add.w	r2, r2, r3, lsl #1
    d458:	ebc2 2242 	rsb	r2, r2, r2, lsl #9
    d45c:	eb02 4282 	add.w	r2, r2, r2, lsl #18
    d460:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    d464:	681b      	ldr	r3, [r3, #0]
    d466:	685b      	ldr	r3, [r3, #4]
    d468:	4252      	negs	r2, r2
    d46a:	494f      	ldr	r1, [pc, #316]	; (d5a8 <ReportBW_Jitter_Loss+0x254>)
    d46c:	9805      	ldr	r0, [sp, #20]
    d46e:	4798      	blx	r3
    pIState->lastCheckPktId = pIState->pktId;
    d470:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    d472:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
    pIState->lastCheckErrorCount = pIState->errorCount;
    d476:	6b23      	ldr	r3, [r4, #48]	; 0x30
    d478:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
    pIState->lastCheckPktCount = pIState->pktCount;
    d47c:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    d480:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
    pIState->lastCheckTime = currentTime;
    d484:	f8c4 60a8 	str.w	r6, [r4, #168]	; 0xa8
    pIState->lastCheckTotalLen = (uint32_t)pIState->totalLen;
    d488:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    d48c:	f010 fcb2 	bl	1ddf4 <__aeabi_d2uiz>
    d490:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4
}
    d494:	b009      	add	sp, #36	; 0x24
    d496:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            nDropped = pIState->errorCount - pIState->lastCheckErrorCount;
    d49a:	6b22      	ldr	r2, [r4, #48]	; 0x30
    d49c:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    d4a0:	eba2 0b03 	sub.w	fp, r2, r3
            sec = (currentTime- pIState->lastCheckTime) / tickFreq;
    d4a4:	f8d4 50a8 	ldr.w	r5, [r4, #168]	; 0xa8
			msec = (uint32_t)(((double) (currentTime - pIState->lastCheckTime)) / (((double)(tickFreq))/1000));
    d4a8:	1b40      	subs	r0, r0, r5
    d4aa:	f7fd ff5f 	bl	b36c <__aeabi_ui2d>
    d4ae:	e9cd 0106 	strd	r0, r1, [sp, #24]
    d4b2:	4648      	mov	r0, r9
    d4b4:	f7fd ff5a 	bl	b36c <__aeabi_ui2d>
    d4b8:	2200      	movs	r2, #0
    d4ba:	4b34      	ldr	r3, [pc, #208]	; (d58c <ReportBW_Jitter_Loss+0x238>)
    d4bc:	f7fc fda2 	bl	a004 <__aeabi_ddiv>
    d4c0:	4602      	mov	r2, r0
    d4c2:	460b      	mov	r3, r1
    d4c4:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    d4c8:	f7fc fd9c 	bl	a004 <__aeabi_ddiv>
    d4cc:	f010 fc92 	bl	1ddf4 <__aeabi_d2uiz>
    d4d0:	4682      	mov	sl, r0
            if ( pIState->state == (uint8_t)IPERF_UDP_TX_DONE_STATE )
    d4d2:	f894 30ce 	ldrb.w	r3, [r4, #206]	; 0xce
    d4d6:	2b12      	cmp	r3, #18
    d4d8:	d047      	beq.n	d56a <ReportBW_Jitter_Loss+0x216>
                nAttempted = pIState->pktId - pIState->lastCheckPktId;
    d4da:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    d4dc:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
    d4e0:	eba2 0803 	sub.w	r8, r2, r3
			if ( msec == 0u )
    d4e4:	f1ba 0f00 	cmp.w	sl, #0
    d4e8:	d046      	beq.n	d578 <ReportBW_Jitter_Loss+0x224>
				kbps = ((pIState->totalLen - pIState->lastCheckTotalLen)*((double) 8)) / msec;
    d4ea:	f8d4 00a4 	ldr.w	r0, [r4, #164]	; 0xa4
    d4ee:	f7fd ff3d 	bl	b36c <__aeabi_ui2d>
    d4f2:	4602      	mov	r2, r0
    d4f4:	460b      	mov	r3, r1
    d4f6:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    d4fa:	f7fd fdf9 	bl	b0f0 <__aeabi_dsub>
    d4fe:	2200      	movs	r2, #0
    d500:	4b23      	ldr	r3, [pc, #140]	; (d590 <ReportBW_Jitter_Loss+0x23c>)
    d502:	f7fc fc55 	bl	9db0 <__aeabi_dmul>
    d506:	e9cd 0106 	strd	r0, r1, [sp, #24]
    d50a:	4650      	mov	r0, sl
    d50c:	f7fd ff2e 	bl	b36c <__aeabi_ui2d>
    d510:	4602      	mov	r2, r0
    d512:	460b      	mov	r3, r1
    d514:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    d518:	f7fc fd74 	bl	a004 <__aeabi_ddiv>
            sec = (pIState->lastCheckTime - pIState->startTime) / tickFreq;
    d51c:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    d520:	1aed      	subs	r5, r5, r3
    d522:	fbb5 f5f9 	udiv	r5, r5, r9
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [%2lu- %2lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    d526:	683b      	ldr	r3, [r7, #0]
    d528:	685f      	ldr	r7, [r3, #4]
                      (unsigned long)sec + ( (unsigned long) (pIState->mInterval / tickFreq) ),
    d52a:	6823      	ldr	r3, [r4, #0]
    d52c:	fbb3 f9f9 	udiv	r9, r3, r9
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [%2lu- %2lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    d530:	44a9      	add	r9, r5
    d532:	f1b8 0f00 	cmp.w	r8, #0
    d536:	d022      	beq.n	d57e <ReportBW_Jitter_Loss+0x22a>
                      (nAttempted == 0u) ? 0 : ((unsigned long)nDropped*100/(unsigned long)nAttempted),
    d538:	f04f 0a64 	mov.w	sl, #100	; 0x64
    d53c:	fb0a fa0b 	mul.w	sl, sl, fp
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [%2lu- %2lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    d540:	fbba faf8 	udiv	sl, sl, r8
                      (unsigned long) (kbps + ((double) 0.5)));
    d544:	2200      	movs	r2, #0
    d546:	4b15      	ldr	r3, [pc, #84]	; (d59c <ReportBW_Jitter_Loss+0x248>)
    d548:	f7fd fdd4 	bl	b0f4 <__adddf3>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [%2lu- %2lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    d54c:	f010 fc52 	bl	1ddf4 <__aeabi_d2uiz>
    d550:	9003      	str	r0, [sp, #12]
    d552:	f8cd a008 	str.w	sl, [sp, #8]
    d556:	f8cd 8004 	str.w	r8, [sp, #4]
    d55a:	f8cd b000 	str.w	fp, [sp]
    d55e:	464b      	mov	r3, r9
    d560:	462a      	mov	r2, r5
    d562:	4912      	ldr	r1, [pc, #72]	; (d5ac <ReportBW_Jitter_Loss+0x258>)
    d564:	9805      	ldr	r0, [sp, #20]
    d566:	47b8      	blx	r7
    if ( reportType == 	SESSION_REPORT )
    d568:	e782      	b.n	d470 <ReportBW_Jitter_Loss+0x11c>
               nAttempted = (pIState->lastPktId - pIState->lastCheckPktId) + nDropped;
    d56a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    d56c:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
    d570:	1a9b      	subs	r3, r3, r2
    d572:	eb03 080b 	add.w	r8, r3, fp
    d576:	e7b5      	b.n	d4e4 <ReportBW_Jitter_Loss+0x190>
                kbps = 0;
    d578:	2000      	movs	r0, #0
    d57a:	2100      	movs	r1, #0
    d57c:	e7ce      	b.n	d51c <ReportBW_Jitter_Loss+0x1c8>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [%2lu- %2lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    d57e:	46c2      	mov	sl, r8
    d580:	e7e0      	b.n	d544 <ReportBW_Jitter_Loss+0x1f0>
                kbps = 0;
    d582:	2000      	movs	r0, #0
    d584:	2100      	movs	r1, #0
    d586:	e731      	b.n	d3ec <ReportBW_Jitter_Loss+0x98>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [0.0- %lu.%lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    d588:	46c1      	mov	r9, r8
    d58a:	e74a      	b.n	d422 <ReportBW_Jitter_Loss+0xce>
    d58c:	408f4000 	.word	0x408f4000
    d590:	40200000 	.word	0x40200000
    d594:	10624dd3 	.word	0x10624dd3
    d598:	51eb851f 	.word	0x51eb851f
    d59c:	3fe00000 	.word	0x3fe00000
    d5a0:	00005c4c 	.word	0x00005c4c
    d5a4:	2000d9b0 	.word	0x2000d9b0
    d5a8:	00005c88 	.word	0x00005c88
    d5ac:	00005c10 	.word	0x00005c10

Disassembly of section .text._CommandPing%216:

0000d5b0 <_CommandPing>:
{
    d5b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d5b4:	b083      	sub	sp, #12
    const void* cmdIoParam = pCmdIO->cmdIoParam;
    d5b6:	f8d0 b004 	ldr.w	fp, [r0, #4]
    if (argc < 2)
    d5ba:	2901      	cmp	r1, #1
    d5bc:	dd12      	ble.n	d5e4 <_CommandPing+0x34>
    d5be:	4682      	mov	sl, r0
    d5c0:	460f      	mov	r7, r1
    d5c2:	4614      	mov	r4, r2
    if(strcmp(argv[1], "stop") == 0)
    d5c4:	6856      	ldr	r6, [r2, #4]
    d5c6:	4978      	ldr	r1, [pc, #480]	; (d7a8 <_CommandPing+0x1f8>)
    d5c8:	4630      	mov	r0, r6
    d5ca:	f014 fa27 	bl	21a1c <strcmp>
    d5ce:	b190      	cbz	r0, d5f6 <_CommandPing+0x46>
    if(tcpipCmdStat != TCPIP_CMD_STAT_IDLE)
    d5d0:	4b76      	ldr	r3, [pc, #472]	; (d7ac <_CommandPing+0x1fc>)
    d5d2:	781b      	ldrb	r3, [r3, #0]
    d5d4:	b1c3      	cbz	r3, d608 <_CommandPing+0x58>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ping: command in progress. Retry later.\r\n");
    d5d6:	f8da 3000 	ldr.w	r3, [sl]
    d5da:	681b      	ldr	r3, [r3, #0]
    d5dc:	4974      	ldr	r1, [pc, #464]	; (d7b0 <_CommandPing+0x200>)
    d5de:	4658      	mov	r0, fp
    d5e0:	4798      	blx	r3
        return true;
    d5e2:	e004      	b.n	d5ee <_CommandPing+0x3e>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ping Usage: ping <stop>/<name/address> <i interface> <n nPings> <t msPeriod> <s size>\r\n");
    d5e4:	6803      	ldr	r3, [r0, #0]
    d5e6:	681b      	ldr	r3, [r3, #0]
    d5e8:	4972      	ldr	r1, [pc, #456]	; (d7b4 <_CommandPing+0x204>)
    d5ea:	4658      	mov	r0, fp
    d5ec:	4798      	blx	r3
}
    d5ee:	2001      	movs	r0, #1
    d5f0:	b003      	add	sp, #12
    d5f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(tcpipCmdStat != TCPIP_CMD_STAT_IDLE)
    d5f6:	4b6d      	ldr	r3, [pc, #436]	; (d7ac <_CommandPing+0x1fc>)
    d5f8:	781b      	ldrb	r3, [r3, #0]
    d5fa:	2b00      	cmp	r3, #0
    d5fc:	d0f7      	beq.n	d5ee <_CommandPing+0x3e>
            _PingStop(pCmdIO, cmdIoParam);
    d5fe:	4659      	mov	r1, fp
    d600:	4650      	mov	r0, sl
    d602:	f00d ff55 	bl	1b4b0 <_PingStop>
    d606:	e7f2      	b.n	d5ee <_CommandPing+0x3e>
    if(TCPIP_Helper_StringToIPAddress(argv[1], &icmpTargetAddr))
    d608:	496b      	ldr	r1, [pc, #428]	; (d7b8 <_CommandPing+0x208>)
    d60a:	4630      	mov	r0, r6
    d60c:	f005 ff58 	bl	134c0 <TCPIP_Helper_StringToIPAddress>
    d610:	b960      	cbnz	r0, d62c <_CommandPing+0x7c>
        if(strlen(argv[1]) > sizeof(icmpTargetHost) - 1)
    d612:	6866      	ldr	r6, [r4, #4]
    d614:	4630      	mov	r0, r6
    d616:	f014 fb49 	bl	21cac <strlen>
    d61a:	281e      	cmp	r0, #30
    d61c:	d922      	bls.n	d664 <_CommandPing+0xb4>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ping: Host name too long. Retry.\r\n");
    d61e:	f8da 3000 	ldr.w	r3, [sl]
    d622:	681b      	ldr	r3, [r3, #0]
    d624:	4965      	ldr	r1, [pc, #404]	; (d7bc <_CommandPing+0x20c>)
    d626:	4658      	mov	r0, fp
    d628:	4798      	blx	r3
            return true;
    d62a:	e7e0      	b.n	d5ee <_CommandPing+0x3e>
        strncpy(icmpTargetAddrStr, argv[1], sizeof(icmpTargetAddrStr) - 1);
    d62c:	4e64      	ldr	r6, [pc, #400]	; (d7c0 <_CommandPing+0x210>)
    d62e:	2210      	movs	r2, #16
    d630:	6861      	ldr	r1, [r4, #4]
    d632:	4630      	mov	r0, r6
    d634:	f012 fea7 	bl	20386 <strncpy>
        icmpTargetAddrStr[sizeof(icmpTargetAddrStr) - 1] = 0;
    d638:	2300      	movs	r3, #0
    d63a:	7433      	strb	r3, [r6, #16]
        icmpTargetHost[0] = '\0';
    d63c:	4a61      	ldr	r2, [pc, #388]	; (d7c4 <_CommandPing+0x214>)
    d63e:	7013      	strb	r3, [r2, #0]
    icmpReqNo = 0;
    d640:	4a61      	ldr	r2, [pc, #388]	; (d7c8 <_CommandPing+0x218>)
    d642:	6013      	str	r3, [r2, #0]
    icmpReqDelay = 0;
    d644:	4a61      	ldr	r2, [pc, #388]	; (d7cc <_CommandPing+0x21c>)
    d646:	6013      	str	r3, [r2, #0]
    while(currIx + 1 < argc)
    d648:	2f03      	cmp	r7, #3
    d64a:	f340 80a8 	ble.w	d79e <_CommandPing+0x1ee>
        newCmdStat = TCPIP_PING_CMD_START_PING;
    d64e:	2303      	movs	r3, #3
    d650:	9301      	str	r3, [sp, #4]
    d652:	3f04      	subs	r7, #4
    d654:	f027 0701 	bic.w	r7, r7, #1
    d658:	3704      	adds	r7, #4
    currIx = 2;
    d65a:	2602      	movs	r6, #2
        if(strcmp(param, "i") == 0)
    d65c:	f8df 91a0 	ldr.w	r9, [pc, #416]	; d800 <_CommandPing+0x250>
            icmpReqDelay = atoi(paramVal);
    d660:	46b8      	mov	r8, r7
    d662:	e018      	b.n	d696 <_CommandPing+0xe6>
        strcpy(icmpTargetHost, argv[1]);
    d664:	4631      	mov	r1, r6
    d666:	4857      	ldr	r0, [pc, #348]	; (d7c4 <_CommandPing+0x214>)
    d668:	f014 fb18 	bl	21c9c <strcpy>
    icmpReqNo = 0;
    d66c:	2300      	movs	r3, #0
    d66e:	4a56      	ldr	r2, [pc, #344]	; (d7c8 <_CommandPing+0x218>)
    d670:	6013      	str	r3, [r2, #0]
    icmpReqDelay = 0;
    d672:	4a56      	ldr	r2, [pc, #344]	; (d7cc <_CommandPing+0x21c>)
    d674:	6013      	str	r3, [r2, #0]
    while(currIx + 1 < argc)
    d676:	2f03      	cmp	r7, #3
    d678:	f340 8086 	ble.w	d788 <_CommandPing+0x1d8>
        newCmdStat = TCPIP_PING_CMD_DNS_GET;
    d67c:	2301      	movs	r3, #1
    d67e:	9301      	str	r3, [sp, #4]
    d680:	e7e7      	b.n	d652 <_CommandPing+0xa2>
            if((icmpNetH = TCPIP_STACK_NetHandleGet(paramVal)) == 0)
    d682:	4638      	mov	r0, r7
    d684:	f010 fa96 	bl	1dbb4 <TCPIP_STACK_NetHandleGet>
    d688:	4b51      	ldr	r3, [pc, #324]	; (d7d0 <_CommandPing+0x220>)
    d68a:	6018      	str	r0, [r3, #0]
    d68c:	b328      	cbz	r0, d6da <_CommandPing+0x12a>
        currIx += 2;
    d68e:	3602      	adds	r6, #2
    d690:	3408      	adds	r4, #8
    while(currIx + 1 < argc)
    d692:	4546      	cmp	r6, r8
    d694:	d044      	beq.n	d720 <_CommandPing+0x170>
        char* param = argv[currIx];
    d696:	68a5      	ldr	r5, [r4, #8]
        char* paramVal = argv[currIx + 1];
    d698:	68e7      	ldr	r7, [r4, #12]
        if(strcmp(param, "i") == 0)
    d69a:	494e      	ldr	r1, [pc, #312]	; (d7d4 <_CommandPing+0x224>)
    d69c:	4628      	mov	r0, r5
    d69e:	f014 f9bd 	bl	21a1c <strcmp>
    d6a2:	2800      	cmp	r0, #0
    d6a4:	d0ed      	beq.n	d682 <_CommandPing+0xd2>
        else if(strcmp(param, "n") == 0)
    d6a6:	f609 0148 	addw	r1, r9, #2120	; 0x848
    d6aa:	4628      	mov	r0, r5
    d6ac:	f014 f9b6 	bl	21a1c <strcmp>
    d6b0:	b1c0      	cbz	r0, d6e4 <_CommandPing+0x134>
        else if(strcmp(param, "t") == 0)
    d6b2:	f609 014c 	addw	r1, r9, #2124	; 0x84c
    d6b6:	4628      	mov	r0, r5
    d6b8:	f014 f9b0 	bl	21a1c <strcmp>
    d6bc:	b1c0      	cbz	r0, d6f0 <_CommandPing+0x140>
        else if(strcmp(param, "s") == 0)
    d6be:	f509 6105 	add.w	r1, r9, #2128	; 0x850
    d6c2:	4628      	mov	r0, r5
    d6c4:	f014 f9aa 	bl	21a1c <strcmp>
    d6c8:	b1c0      	cbz	r0, d6fc <_CommandPing+0x14c>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ping: Unknown parameter\r\n");
    d6ca:	f8da 3000 	ldr.w	r3, [sl]
    d6ce:	681b      	ldr	r3, [r3, #0]
    d6d0:	f509 6108 	add.w	r1, r9, #2176	; 0x880
    d6d4:	4658      	mov	r0, fp
    d6d6:	4798      	blx	r3
    d6d8:	e7d9      	b.n	d68e <_CommandPing+0xde>
                icmpNetH = TCPIP_STACK_NetDefaultGet();
    d6da:	f014 fc95 	bl	22008 <TCPIP_STACK_NetDefaultGet>
    d6de:	4b3c      	ldr	r3, [pc, #240]	; (d7d0 <_CommandPing+0x220>)
    d6e0:	6018      	str	r0, [r3, #0]
    d6e2:	e7d4      	b.n	d68e <_CommandPing+0xde>
            icmpReqNo = atoi(paramVal);
    d6e4:	4638      	mov	r0, r7
    d6e6:	f014 fd8b 	bl	22200 <atoi>
    d6ea:	4b37      	ldr	r3, [pc, #220]	; (d7c8 <_CommandPing+0x218>)
    d6ec:	6018      	str	r0, [r3, #0]
    d6ee:	e7ce      	b.n	d68e <_CommandPing+0xde>
            icmpReqDelay = atoi(paramVal);
    d6f0:	4638      	mov	r0, r7
    d6f2:	f014 fd85 	bl	22200 <atoi>
    d6f6:	4b35      	ldr	r3, [pc, #212]	; (d7cc <_CommandPing+0x21c>)
    d6f8:	6018      	str	r0, [r3, #0]
    d6fa:	e7c8      	b.n	d68e <_CommandPing+0xde>
            int pingSize = atoi(paramVal);
    d6fc:	4638      	mov	r0, r7
    d6fe:	f014 fd7f 	bl	22200 <atoi>
            if(pingSize <= sizeof(icmpPingBuff))
    d702:	f5b0 6ffa 	cmp.w	r0, #2000	; 0x7d0
    d706:	d802      	bhi.n	d70e <_CommandPing+0x15e>
                icmpPingSize = pingSize;
    d708:	4b33      	ldr	r3, [pc, #204]	; (d7d8 <_CommandPing+0x228>)
    d70a:	6018      	str	r0, [r3, #0]
    d70c:	e7bf      	b.n	d68e <_CommandPing+0xde>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "Ping: Data size too big. Max: %d. Retry\r\n", sizeof(icmpPingBuff));
    d70e:	f8da 3000 	ldr.w	r3, [sl]
    d712:	685b      	ldr	r3, [r3, #4]
    d714:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
    d718:	4930      	ldr	r1, [pc, #192]	; (d7dc <_CommandPing+0x22c>)
    d71a:	4658      	mov	r0, fp
    d71c:	4798      	blx	r3
                return true;
    d71e:	e766      	b.n	d5ee <_CommandPing+0x3e>
    tcpipCmdStat = newCmdStat;
    d720:	4b22      	ldr	r3, [pc, #136]	; (d7ac <_CommandPing+0x1fc>)
    d722:	9a01      	ldr	r2, [sp, #4]
    d724:	701a      	strb	r2, [r3, #0]
    if(tcpipCmdStat == TCPIP_PING_CMD_DNS_GET)
    d726:	2a01      	cmp	r2, #1
    d728:	d031      	beq.n	d78e <_CommandPing+0x1de>
    d72a:	f00d fc2f 	bl	1af8c <rand>
    icmpSequenceNo = SYS_RANDOM_PseudoGet();
    d72e:	4b2c      	ldr	r3, [pc, #176]	; (d7e0 <_CommandPing+0x230>)
    d730:	8018      	strh	r0, [r3, #0]
    d732:	f00d fc2b 	bl	1af8c <rand>
    icmpIdentifier = SYS_RANDOM_PseudoGet();
    d736:	4b2b      	ldr	r3, [pc, #172]	; (d7e4 <_CommandPing+0x234>)
    d738:	8018      	strh	r0, [r3, #0]
    if(icmpReqNo == 0)
    d73a:	4b23      	ldr	r3, [pc, #140]	; (d7c8 <_CommandPing+0x218>)
    d73c:	681b      	ldr	r3, [r3, #0]
    d73e:	b913      	cbnz	r3, d746 <_CommandPing+0x196>
        icmpReqNo = TCPIP_STACK_COMMANDS_ICMP_ECHO_REQUESTS;
    d740:	4b21      	ldr	r3, [pc, #132]	; (d7c8 <_CommandPing+0x218>)
    d742:	2204      	movs	r2, #4
    d744:	601a      	str	r2, [r3, #0]
    if(icmpReqDelay == 0)
    d746:	4b21      	ldr	r3, [pc, #132]	; (d7cc <_CommandPing+0x21c>)
    d748:	681b      	ldr	r3, [r3, #0]
    d74a:	b9bb      	cbnz	r3, d77c <_CommandPing+0x1cc>
        icmpReqDelay = TCPIP_STACK_COMMANDS_ICMP_ECHO_REQUEST_DELAY;
    d74c:	4b1f      	ldr	r3, [pc, #124]	; (d7cc <_CommandPing+0x21c>)
    d74e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    d752:	601a      	str	r2, [r3, #0]
    pTcpipCmdDevice = pCmdIO;
    d754:	4b24      	ldr	r3, [pc, #144]	; (d7e8 <_CommandPing+0x238>)
    d756:	f8c3 a000 	str.w	sl, [r3]
    icmpCmdIoParam = cmdIoParam; 
    d75a:	4b24      	ldr	r3, [pc, #144]	; (d7ec <_CommandPing+0x23c>)
    d75c:	f8c3 b000 	str.w	fp, [r3]
    icmpAckRecv = 0;
    d760:	2300      	movs	r3, #0
    d762:	4a23      	ldr	r2, [pc, #140]	; (d7f0 <_CommandPing+0x240>)
    d764:	6013      	str	r3, [r2, #0]
    icmpReqCount = 0;
    d766:	4a23      	ldr	r2, [pc, #140]	; (d7f4 <_CommandPing+0x244>)
    d768:	6013      	str	r3, [r2, #0]
    _TCPIPStackSignalHandlerSetParams(TCPIP_THIS_MODULE_ID, tcpipCmdSignalHandle, icmpReqDelay);
    d76a:	4b18      	ldr	r3, [pc, #96]	; (d7cc <_CommandPing+0x21c>)
    d76c:	f9b3 2000 	ldrsh.w	r2, [r3]
    d770:	4b21      	ldr	r3, [pc, #132]	; (d7f8 <_CommandPing+0x248>)
    d772:	6819      	ldr	r1, [r3, #0]
    d774:	201f      	movs	r0, #31
    d776:	f012 fc41 	bl	1fffc <_TCPIPStackSignalHandlerSetParams>
    return true;
    d77a:	e738      	b.n	d5ee <_CommandPing+0x3e>
    if(icmpReqDelay < TCPIP_COMMAND_ICMP_ECHO_REQUEST_MIN_DELAY)
    d77c:	2b04      	cmp	r3, #4
    d77e:	dce9      	bgt.n	d754 <_CommandPing+0x1a4>
        icmpReqDelay = TCPIP_COMMAND_ICMP_ECHO_REQUEST_MIN_DELAY;
    d780:	4b12      	ldr	r3, [pc, #72]	; (d7cc <_CommandPing+0x21c>)
    d782:	2205      	movs	r2, #5
    d784:	601a      	str	r2, [r3, #0]
    d786:	e7e5      	b.n	d754 <_CommandPing+0x1a4>
    tcpipCmdStat = newCmdStat;
    d788:	4b08      	ldr	r3, [pc, #32]	; (d7ac <_CommandPing+0x1fc>)
    d78a:	2201      	movs	r2, #1
    d78c:	701a      	strb	r2, [r3, #0]
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Ping: resolving host: %s\r\n", icmpTargetHost);
    d78e:	f8da 3000 	ldr.w	r3, [sl]
    d792:	685b      	ldr	r3, [r3, #4]
    d794:	4a0b      	ldr	r2, [pc, #44]	; (d7c4 <_CommandPing+0x214>)
    d796:	4919      	ldr	r1, [pc, #100]	; (d7fc <_CommandPing+0x24c>)
    d798:	4658      	mov	r0, fp
    d79a:	4798      	blx	r3
    d79c:	e7c5      	b.n	d72a <_CommandPing+0x17a>
    tcpipCmdStat = newCmdStat;
    d79e:	4b03      	ldr	r3, [pc, #12]	; (d7ac <_CommandPing+0x1fc>)
    d7a0:	2203      	movs	r2, #3
    d7a2:	701a      	strb	r2, [r3, #0]
    if(tcpipCmdStat == TCPIP_PING_CMD_DNS_GET)
    d7a4:	e7c1      	b.n	d72a <_CommandPing+0x17a>
    d7a6:	bf00      	nop
    d7a8:	00000a78 	.word	0x00000a78
    d7ac:	2000e1af 	.word	0x2000e1af
    d7b0:	00000a80 	.word	0x00000a80
    d7b4:	00000a20 	.word	0x00000a20
    d7b8:	2000e3d4 	.word	0x2000e3d4
    d7bc:	00000aac 	.word	0x00000aac
    d7c0:	2000e304 	.word	0x2000e304
    d7c4:	2000e190 	.word	0x2000e190
    d7c8:	2000e3cc 	.word	0x2000e3cc
    d7cc:	2000e3c4 	.word	0x2000e3c4
    d7d0:	2000e3bc 	.word	0x2000e3bc
    d7d4:	00000ad0 	.word	0x00000ad0
    d7d8:	2000e3e8 	.word	0x2000e3e8
    d7dc:	00000ae0 	.word	0x00000ae0
    d7e0:	2000e4fc 	.word	0x2000e4fc
    d7e4:	2000e4fa 	.word	0x2000e4fa
    d7e8:	2000e3e0 	.word	0x2000e3e0
    d7ec:	2000e3b8 	.word	0x2000e3b8
    d7f0:	2000e3b4 	.word	0x2000e3b4
    d7f4:	2000e3c0 	.word	0x2000e3c0
    d7f8:	2000e3e4 	.word	0x2000e3e4
    d7fc:	00000b28 	.word	0x00000b28
    d800:	0000028c 	.word	0x0000028c

Disassembly of section .text.TCPIP_UDP_Task%217:

0000d804 <TCPIP_UDP_Task>:
    return TCPIP_PKT_SocketAlloc(pktSize, sizeof(UDP_HEADER), txBuffSize, allocFlags);
}
#endif // defined (TCPIP_STACK_USE_IPV4) || (TCPIP_UDP_USE_POOL_BUFFERS != 0)

void TCPIP_UDP_Task(void)
{
    d804:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d808:	b08b      	sub	sp, #44	; 0x2c
    if((sigPend & (TCPIP_MODULE_SIGNAL_INTERFACE_CHANGE)) != 0)
    { // interface address change occurred
        _UDPAbortSockets(netMask, TCPIP_UDP_SIGNAL_IF_CHANGE); 
    }
#else
    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    d80a:	210f      	movs	r1, #15
    d80c:	2009      	movs	r0, #9
    d80e:	f010 fcdd 	bl	1e1cc <_TCPIPStackModuleSignalGet>
#endif  // (_TCPIP_STACK_INTERFACE_CHANGE_SIGNALING != 0)

    if((sigPend & TCPIP_MODULE_SIGNAL_RX_PENDING) != 0)
    d812:	f010 0f01 	tst.w	r0, #1
    d816:	d102      	bne.n	d81e <TCPIP_UDP_Task+0x1a>
    { //  RX signal occurred
        TCPIP_UDP_Process();
    }

}
    d818:	b00b      	add	sp, #44	; 0x2c
    d81a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    // and (IPv4 only for now)
    // 5. packet source address matches the socket expected source address or looseRemAddress flag is set
    

    pPktIf = (TCPIP_NET_IF*)pRxPkt->pktIf;
    for(sktIx = 0; sktIx < nUdpSockets; sktIx++)
    d81e:	f8df b22c 	ldr.w	fp, [pc, #556]	; da4c <TCPIP_UDP_Task+0x248>
    d822:	e096      	b.n	d952 <TCPIP_UDP_Task+0x14e>
    pUDPHdr = (UDP_HEADER*)pRxPkt->pTransportLayer;
    d824:	f8d9 801c 	ldr.w	r8, [r9, #28]
    udpTotLength = TCPIP_Helper_ntohs(pUDPHdr->Length);
    d828:	f8b8 2004 	ldrh.w	r2, [r8, #4]
    d82c:	0a14      	lsrs	r4, r2, #8
    d82e:	ea44 2402 	orr.w	r4, r4, r2, lsl #8
    d832:	b2a4      	uxth	r4, r4
    if(udpTotLength != pRxPkt->totTransportLen)
    d834:	42a3      	cmp	r3, r4
    d836:	f040 80a0 	bne.w	d97a <TCPIP_UDP_Task+0x176>
    return &((IPV4_HEADER*)pPkt->pNetLayer)->SourceAddress;
    d83a:	f8d9 2018 	ldr.w	r2, [r9, #24]
    d83e:	9205      	str	r2, [sp, #20]
	if((pUDPHdr->Checksum != 0))
    d840:	f8b8 3006 	ldrh.w	r3, [r8, #6]
    d844:	b30b      	cbz	r3, d88a <TCPIP_UDP_Task+0x86>
	    pseudoHdr.SourceAddress.Val = pPktSrcAdd->Val;
    d846:	68d3      	ldr	r3, [r2, #12]
    d848:	9307      	str	r3, [sp, #28]
	    pseudoHdr.DestAddress.Val = pPktDstAdd->Val;
    d84a:	6913      	ldr	r3, [r2, #16]
    d84c:	9308      	str	r3, [sp, #32]
	    pseudoHdr.Zero	= 0;
    d84e:	2200      	movs	r2, #0
    d850:	f88d 2024 	strb.w	r2, [sp, #36]	; 0x24
	    pseudoHdr.Protocol = IP_PROT_UDP;
    d854:	2311      	movs	r3, #17
    d856:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
	    pseudoHdr.Length = pUDPHdr->Length;
    d85a:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    d85e:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
	    calcChkSum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)&pseudoHdr, sizeof(pseudoHdr), 0);
    d862:	210c      	movs	r1, #12
    d864:	a807      	add	r0, sp, #28
    d866:	f00c fec1 	bl	1a5ec <TCPIP_Helper_CalcIPChecksum>
    d86a:	43c0      	mvns	r0, r0
    d86c:	b283      	uxth	r3, r0
        if((pRxPkt->pktFlags & TCPIP_MAC_PKT_FLAG_SPLIT) != 0)
    d86e:	f8b9 2022 	ldrh.w	r2, [r9, #34]	; 0x22
    d872:	f012 0f04 	tst.w	r2, #4
    d876:	d023      	beq.n	d8c0 <TCPIP_UDP_Task+0xbc>
            calcChkSum = TCPIP_Helper_PacketChecksum(pRxPkt, (uint8_t*)pUDPHdr, udpTotLength, calcChkSum);
    d878:	4622      	mov	r2, r4
    d87a:	4641      	mov	r1, r8
    d87c:	4648      	mov	r0, r9
    d87e:	f00b fccd 	bl	1921c <TCPIP_Helper_PacketChecksum>
            return TCPIP_MAC_PKT_ACK_CHKSUM_ERR;
    d882:	f06f 0109 	mvn.w	r1, #9
        if(calcChkSum != 0)
    d886:	2800      	cmp	r0, #0
    d888:	d15f      	bne.n	d94a <TCPIP_UDP_Task+0x146>
    pUDPHdr->SourcePort = TCPIP_Helper_ntohs(pUDPHdr->SourcePort);
    d88a:	f8b8 2000 	ldrh.w	r2, [r8]
    d88e:	0a13      	lsrs	r3, r2, #8
    d890:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    d894:	f8a8 3000 	strh.w	r3, [r8]
    pUDPHdr->DestinationPort = TCPIP_Helper_ntohs(pUDPHdr->DestinationPort);
    d898:	f8b8 2002 	ldrh.w	r2, [r8, #2]
    d89c:	0a13      	lsrs	r3, r2, #8
    d89e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    d8a2:	f8a8 3002 	strh.w	r3, [r8, #2]
    pUDPHdr->Length = udpTotLength - sizeof(UDP_HEADER);    
    d8a6:	3c08      	subs	r4, #8
    d8a8:	f8a8 4004 	strh.w	r4, [r8, #4]
    pPktIf = (TCPIP_NET_IF*)pRxPkt->pktIf;
    d8ac:	f8d9 3028 	ldr.w	r3, [r9, #40]	; 0x28
    d8b0:	9304      	str	r3, [sp, #16]
    for(sktIx = 0; sktIx < nUdpSockets; sktIx++)
    d8b2:	f8db 3000 	ldr.w	r3, [fp]
    d8b6:	2b00      	cmp	r3, #0
    d8b8:	dd6a      	ble.n	d990 <TCPIP_UDP_Task+0x18c>
    d8ba:	f04f 0a00 	mov.w	sl, #0
    d8be:	e073      	b.n	d9a8 <TCPIP_UDP_Task+0x1a4>
            calcChkSum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pUDPHdr, udpTotLength, calcChkSum);
    d8c0:	461a      	mov	r2, r3
    d8c2:	4621      	mov	r1, r4
    d8c4:	4640      	mov	r0, r8
    d8c6:	f00c fe91 	bl	1a5ec <TCPIP_Helper_CalcIPChecksum>
    d8ca:	e7da      	b.n	d882 <TCPIP_UDP_Task+0x7e>
        if(_localPort != h->DestinationPort)
        {   // cannot handle this port
            continue;
        }
       
        exactMatch = looseMatch = 0;
    d8cc:	2200      	movs	r2, #0

        // 2. packet address type
        if(_addType == addressType)
        {
            exactMatch = TCPIP_UDP_PKT_MATCH_IP_TYPE;
    d8ce:	2301      	movs	r3, #1
    d8d0:	e097      	b.n	da02 <TCPIP_UDP_Task+0x1fe>
        }

        // 3. packet source port
        if(_remotePort == h->SourcePort)
        {
            exactMatch |= TCPIP_UDP_PKT_MATCH_SRC_PORT;
    d8d2:	f043 0302 	orr.w	r3, r3, #2
    d8d6:	e09f      	b.n	da18 <TCPIP_UDP_Task+0x214>
#if defined (TCPIP_STACK_USE_IPV4)
        if(addressType == IP_ADDRESS_TYPE_IPV4)
        {
            if(_pSktNet == pPktIf)
            {
                exactMatch |= TCPIP_UDP_PKT_MATCH_NET;
    d8d8:	f043 0304 	orr.w	r3, r3, #4
    d8dc:	e0a6      	b.n	da2c <TCPIP_UDP_Task+0x228>
        {
            if(_pktSrcAddress.Val == 0 || _flags.looseRemAddress != 0)
            {
                looseMatch |= TCPIP_UDP_PKT_MACTH_SRC_ADD;
            }
            else if(_pktSrcAddress.Val == TCPIP_IPV4_PacketGetSourceAddress(pRxPkt)->Val)
    d8de:	f8d9 1018 	ldr.w	r1, [r9, #24]
    d8e2:	68c9      	ldr	r1, [r1, #12]
    d8e4:	9801      	ldr	r0, [sp, #4]
    d8e6:	4288      	cmp	r0, r1
    d8e8:	d158      	bne.n	d99c <TCPIP_UDP_Task+0x198>
            {
                exactMatch |= TCPIP_UDP_PKT_MACTH_SRC_ADD;
    d8ea:	f043 0308 	orr.w	r3, r3, #8
            exactMatch |= TCPIP_UDP_PKT_MACTH_SRC_ADD;
        }
#endif // defined(TCPIP_STACK_USE_IPV6)

        // finally check the match we got
        if(exactMatch == TCPIP_UDP_PKT_MACTH_MASK)
    d8ee:	2b0f      	cmp	r3, #15
    d8f0:	f040 80a4 	bne.w	da3c <TCPIP_UDP_Task+0x238>
        if(pSkt->extFlags.mcastOnly != 0)
    d8f4:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
    d8f8:	f013 0f40 	tst.w	r3, #64	; 0x40
    d8fc:	d005      	beq.n	d90a <TCPIP_UDP_Task+0x106>
            if(!TCPIP_Helper_IsMcastAddress(pPktDstAdd))
    d8fe:	9b05      	ldr	r3, [sp, #20]
    d900:	7c1b      	ldrb	r3, [r3, #16]
    d902:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    d906:	2be0      	cmp	r3, #224	; 0xe0
    d908:	d13a      	bne.n	d980 <TCPIP_UDP_Task+0x17c>
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    d90a:	2000      	movs	r0, #0
    d90c:	f013 fe56 	bl	215bc <OSAL_CRIT_Enter>
    d910:	4606      	mov	r6, r0
    TCPIP_Helper_SingleListTailAdd(&pSkt->rxQueue, (SGL_LIST_NODE*)pNode);
    d912:	4649      	mov	r1, r9
    d914:	f104 0044 	add.w	r0, r4, #68	; 0x44
    d918:	f013 fcd2 	bl	212c0 <TCPIP_Helper_SingleListTailAdd>
    if((pSkt->sigMask & TCPIP_UDP_SIGNAL_RX_DATA) != 0)
    d91c:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
    d920:	f413 7f80 	tst.w	r3, #256	; 0x100
    d924:	d02f      	beq.n	d986 <TCPIP_UDP_Task+0x182>
        sigHandler = pSkt->sigHandler;
    d926:	6d25      	ldr	r5, [r4, #80]	; 0x50
        *pSigParam = pSkt->sigParam;
    d928:	6d67      	ldr	r7, [r4, #84]	; 0x54
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
    d92a:	4631      	mov	r1, r6
    d92c:	2000      	movs	r0, #0
    d92e:	f013 ff74 	bl	2181a <OSAL_CRIT_Leave>
        if(sigHandler)
    d932:	b175      	cbz	r5, d952 <TCPIP_UDP_Task+0x14e>
            (*sigHandler)(pSkt->sktIx, pRxPkt->pktIf, TCPIP_UDP_SIGNAL_RX_DATA, sigParam);
    d934:	463b      	mov	r3, r7
    d936:	f44f 7280 	mov.w	r2, #256	; 0x100
    d93a:	f8d9 1028 	ldr.w	r1, [r9, #40]	; 0x28
    d93e:	f9b4 0012 	ldrsh.w	r0, [r4, #18]
    d942:	47a8      	blx	r5
    d944:	e005      	b.n	d952 <TCPIP_UDP_Task+0x14e>
            ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    d946:	f06f 010d 	mvn.w	r1, #13
    TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
    d94a:	2209      	movs	r2, #9
    d94c:	4648      	mov	r0, r9
    d94e:	f010 f951 	bl	1dbf4 <_TCPIP_PKT_PacketAcknowledge>
    while((pRxPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
    d952:	2009      	movs	r0, #9
    d954:	f011 fffa 	bl	1f94c <_TCPIPStackModuleRxExtract>
    d958:	4681      	mov	r9, r0
    d95a:	2800      	cmp	r0, #0
    d95c:	f43f af5c 	beq.w	d818 <TCPIP_UDP_Task+0x14>
        if(pRxPkt->totTransportLen < sizeof(UDP_HEADER))
    d960:	f8b9 3020 	ldrh.w	r3, [r9, #32]
    d964:	2b07      	cmp	r3, #7
    d966:	d9ee      	bls.n	d946 <TCPIP_UDP_Task+0x142>
        else if((pRxPkt->pktFlags & TCPIP_MAC_PKT_FLAG_NET_TYPE) == TCPIP_MAC_PKT_FLAG_IPV4) 
    d968:	f8b9 2022 	ldrh.w	r2, [r9, #34]	; 0x22
    d96c:	f412 7f00 	tst.w	r2, #512	; 0x200
    d970:	f43f af58 	beq.w	d824 <TCPIP_UDP_Task+0x20>
        ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    d974:	f06f 010e 	mvn.w	r1, #14
    d978:	e7e7      	b.n	d94a <TCPIP_UDP_Task+0x146>
        return TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    d97a:	f06f 010d 	mvn.w	r1, #13
    d97e:	e7e4      	b.n	d94a <TCPIP_UDP_Task+0x146>
                ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    d980:	f06f 010e 	mvn.w	r1, #14
        if(ackRes != TCPIP_MAC_PKT_ACK_NONE)
    d984:	e7e1      	b.n	d94a <TCPIP_UDP_Task+0x146>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
    d986:	4631      	mov	r1, r6
    d988:	2000      	movs	r0, #0
    d98a:	f013 ff46 	bl	2181a <OSAL_CRIT_Leave>
        if(sigHandler)
    d98e:	e7e0      	b.n	d952 <TCPIP_UDP_Task+0x14e>
            ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    d990:	f06f 010e 	mvn.w	r1, #14
    d994:	e7d9      	b.n	d94a <TCPIP_UDP_Task+0x146>
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critStatus);
    d996:	2000      	movs	r0, #0
    d998:	f013 ff3f 	bl	2181a <OSAL_CRIT_Leave>
    for(sktIx = 0; sktIx < nUdpSockets; sktIx++)
    d99c:	f10a 0a01 	add.w	sl, sl, #1
    d9a0:	f8db 3000 	ldr.w	r3, [fp]
    d9a4:	459a      	cmp	sl, r3
    d9a6:	daf3      	bge.n	d990 <TCPIP_UDP_Task+0x18c>
        critStatus = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    d9a8:	2000      	movs	r0, #0
    d9aa:	f013 fe07 	bl	215bc <OSAL_CRIT_Enter>
    d9ae:	4601      	mov	r1, r0
            pSkt = UDPSocketDcpt[sktIx];
    d9b0:	4b25      	ldr	r3, [pc, #148]	; (da48 <TCPIP_UDP_Task+0x244>)
    d9b2:	681b      	ldr	r3, [r3, #0]
    d9b4:	f853 402a 	ldr.w	r4, [r3, sl, lsl #2]
            if(pSkt == 0) 
    d9b8:	2c00      	cmp	r4, #0
    d9ba:	d0ec      	beq.n	d996 <TCPIP_UDP_Task+0x192>
    return (pSkt->extFlags.rxEnable == 0);
    d9bc:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
            if(_RxSktIsLocked(pSkt)) 
    d9c0:	f013 0f02 	tst.w	r3, #2
    d9c4:	d0e7      	beq.n	d996 <TCPIP_UDP_Task+0x192>
            if(TCPIP_Helper_SingleListCount(&pSkt->rxQueue) >= pSkt->rxQueueLimit)
    d9c6:	f894 305a 	ldrb.w	r3, [r4, #90]	; 0x5a
    d9ca:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
    d9cc:	429a      	cmp	r2, r3
    d9ce:	dae2      	bge.n	d996 <TCPIP_UDP_Task+0x192>
            _localPort = pSkt->localPort;
    d9d0:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    d9d2:	9302      	str	r3, [sp, #8]
            _addType = pSkt->addType;
    d9d4:	8fa6      	ldrh	r6, [r4, #60]	; 0x3c
            _remotePort = pSkt->remotePort;
    d9d6:	8d20      	ldrh	r0, [r4, #40]	; 0x28
    d9d8:	9003      	str	r0, [sp, #12]
            _flags.Val = pSkt->flags.Val;
    d9da:	f8b4 5040 	ldrh.w	r5, [r4, #64]	; 0x40
            _pSktNet = pSkt->pSktNet;
    d9de:	6a67      	ldr	r7, [r4, #36]	; 0x24
            _pktSrcAddress.Val = pSkt->pktSrcAddress.Val;
    d9e0:	69e0      	ldr	r0, [r4, #28]
    d9e2:	9001      	str	r0, [sp, #4]
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critStatus);
    d9e4:	2000      	movs	r0, #0
    d9e6:	f013 ff18 	bl	2181a <OSAL_CRIT_Leave>
        if(_localPort != h->DestinationPort)
    d9ea:	f8b8 3002 	ldrh.w	r3, [r8, #2]
    d9ee:	9a02      	ldr	r2, [sp, #8]
    d9f0:	4293      	cmp	r3, r2
    d9f2:	d1d3      	bne.n	d99c <TCPIP_UDP_Task+0x198>
        if(_addType == addressType)
    d9f4:	2e01      	cmp	r6, #1
    d9f6:	f43f af69 	beq.w	d8cc <TCPIP_UDP_Task+0xc8>
        else if(_addType == IP_ADDRESS_TYPE_ANY)
    d9fa:	2e00      	cmp	r6, #0
    d9fc:	d1ce      	bne.n	d99c <TCPIP_UDP_Task+0x198>
            looseMatch = TCPIP_UDP_PKT_MATCH_IP_TYPE;
    d9fe:	2201      	movs	r2, #1
        exactMatch = looseMatch = 0;
    da00:	2300      	movs	r3, #0
        if(_remotePort == h->SourcePort)
    da02:	f8b8 1000 	ldrh.w	r1, [r8]
    da06:	9803      	ldr	r0, [sp, #12]
    da08:	4281      	cmp	r1, r0
    da0a:	f43f af62 	beq.w	d8d2 <TCPIP_UDP_Task+0xce>
        else if(_flags.looseRemPort != 0)
    da0e:	f015 0f04 	tst.w	r5, #4
            looseMatch |= TCPIP_UDP_PKT_MATCH_SRC_PORT;
    da12:	bf18      	it	ne
    da14:	f042 0202 	orrne.w	r2, r2, #2
            if(_pSktNet == pPktIf)
    da18:	9904      	ldr	r1, [sp, #16]
    da1a:	42b9      	cmp	r1, r7
    da1c:	f43f af5c 	beq.w	d8d8 <TCPIP_UDP_Task+0xd4>
            else if(_pSktNet == 0 || _flags.looseNetIf != 0)
    da20:	b117      	cbz	r7, da28 <TCPIP_UDP_Task+0x224>
    da22:	f015 0f08 	tst.w	r5, #8
    da26:	d001      	beq.n	da2c <TCPIP_UDP_Task+0x228>
                looseMatch |= TCPIP_UDP_PKT_MATCH_NET;
    da28:	f042 0204 	orr.w	r2, r2, #4
            if(_pktSrcAddress.Val == 0 || _flags.looseRemAddress != 0)
    da2c:	9901      	ldr	r1, [sp, #4]
    da2e:	b119      	cbz	r1, da38 <TCPIP_UDP_Task+0x234>
    da30:	f015 0f10 	tst.w	r5, #16
    da34:	f43f af53 	beq.w	d8de <TCPIP_UDP_Task+0xda>
                looseMatch |= TCPIP_UDP_PKT_MACTH_SRC_ADD;
    da38:	f042 0208 	orr.w	r2, r2, #8
        {   // perfect match
            return pSkt;
        }
        else if( (looseMatch | exactMatch) == TCPIP_UDP_PKT_MACTH_MASK )
    da3c:	4313      	orrs	r3, r2
    da3e:	2b0f      	cmp	r3, #15
    da40:	d1ac      	bne.n	d99c <TCPIP_UDP_Task+0x198>
                    }
                }
            }
#endif  // defined (TCPIP_STACK_USE_IPV6)
            
            pSkt->addType = addressType;
    da42:	2301      	movs	r3, #1
    da44:	87a3      	strh	r3, [r4, #60]	; 0x3c
        if(pSkt == 0)
    da46:	e755      	b.n	d8f4 <TCPIP_UDP_Task+0xf0>
    da48:	2000e454 	.word	0x2000e454
    da4c:	2000e458 	.word	0x2000e458

Disassembly of section .text.TCPIP_STACK_BringNetUp%218:

0000da50 <TCPIP_STACK_BringNetUp>:
{
    da50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    da54:	b095      	sub	sp, #84	; 0x54
    da56:	4606      	mov	r6, r0
    da58:	461f      	mov	r7, r3
    pNetIf = stackCtrlData->pNetIf;
    da5a:	f8d0 8014 	ldr.w	r8, [r0, #20]
    pNetIf->netIfIx = stackCtrlData->netIx;
    da5e:	6983      	ldr	r3, [r0, #24]
    da60:	f8a8 3058 	strh.w	r3, [r8, #88]	; 0x58
    pNetIf->Flags.powerMode = stackCtrlData->powerMode;
    da64:	f898 3043 	ldrb.w	r3, [r8, #67]	; 0x43
    da68:	7f41      	ldrb	r1, [r0, #29]
    da6a:	f361 0383 	bfi	r3, r1, #2, #2
    da6e:	f888 3043 	strb.w	r3, [r8, #67]	; 0x43
    pMacObj = pNetIf->pMacObj;
    da72:	f8d8 4044 	ldr.w	r4, [r8, #68]	; 0x44
            macConfig = pNetIf->pMacConfig;
    da76:	f8d8 9054 	ldr.w	r9, [r8, #84]	; 0x54
            if (pModConfig != 0)
    da7a:	4615      	mov	r5, r2
    da7c:	b19a      	cbz	r2, daa6 <TCPIP_STACK_BringNetUp+0x56>
                pConfig = _TCPIP_STACK_FindModuleData(pMacObj->macId, pModConfig, nModules);
    da7e:	8820      	ldrh	r0, [r4, #0]
    while(nModules--)
    da80:	b18f      	cbz	r7, daa6 <TCPIP_STACK_BringNetUp+0x56>
        if(pModConfig->moduleId == moduleId)
    da82:	8813      	ldrh	r3, [r2, #0]
    da84:	4283      	cmp	r3, r0
    da86:	f000 80e4 	beq.w	dc52 <TCPIP_STACK_BringNetUp+0x202>
    da8a:	1eba      	subs	r2, r7, #2
    da8c:	462b      	mov	r3, r5
        pModConfig++;
    da8e:	3308      	adds	r3, #8
    while(nModules--)
    da90:	f1b2 3fff 	cmp.w	r2, #4294967295
    da94:	d007      	beq.n	daa6 <TCPIP_STACK_BringNetUp+0x56>
        if(pModConfig->moduleId == moduleId)
    da96:	3a01      	subs	r2, #1
    da98:	8819      	ldrh	r1, [r3, #0]
    da9a:	4281      	cmp	r1, r0
    da9c:	d1f7      	bne.n	da8e <TCPIP_STACK_BringNetUp+0x3e>
                    pNetIf->pMacConfig = macConfig = pConfig->configData;
    da9e:	f8d3 9004 	ldr.w	r9, [r3, #4]
    daa2:	f8c8 9054 	str.w	r9, [r8, #84]	; 0x54
            if(stackCtrlData->powerMode == TCPIP_MAC_POWER_FULL)
    daa6:	7f73      	ldrb	r3, [r6, #29]
    daa8:	2b01      	cmp	r3, #1
    daaa:	d004      	beq.n	dab6 <TCPIP_STACK_BringNetUp+0x66>
        if(pModConfig->moduleId == moduleId)
    daac:	4c6a      	ldr	r4, [pc, #424]	; (dc58 <TCPIP_STACK_BringNetUp+0x208>)
            configData = 0;
    daae:	46aa      	mov	sl, r5
        for(modIx = 0; modIx < sizeof(TCPIP_STACK_MODULE_ENTRY_TBL)/sizeof(*TCPIP_STACK_MODULE_ENTRY_TBL); modIx++)
    dab0:	f104 096c 	add.w	r9, r4, #108	; 0x6c
    dab4:	e0ba      	b.n	dc2c <TCPIP_STACK_BringNetUp+0x1dc>
    TCPIP_NET_IF* pNetIf = stackCtrlData->pNetIf;
    dab6:	f8d6 b014 	ldr.w	fp, [r6, #20]
    memset(pMacCtrl, 0, sizeof(*pMacCtrl));
    daba:	f04f 0a00 	mov.w	sl, #0
    dabe:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
    dac2:	f8cd a040 	str.w	sl, [sp, #64]	; 0x40
    dac6:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
    daca:	f8cd a048 	str.w	sl, [sp, #72]	; 0x48
    dace:	f8cd a04c 	str.w	sl, [sp, #76]	; 0x4c
    pMacCtrl->nIfs = stackCtrlData->nIfs;
    dad2:	6833      	ldr	r3, [r6, #0]
    dad4:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
    pMacCtrl->mallocF = TCPIP_HEAP_MallocOutline;
    dad8:	4b60      	ldr	r3, [pc, #384]	; (dc5c <TCPIP_STACK_BringNetUp+0x20c>)
    dada:	9304      	str	r3, [sp, #16]
    pMacCtrl->callocF = TCPIP_HEAP_CallocOutline;
    dadc:	4b60      	ldr	r3, [pc, #384]	; (dc60 <TCPIP_STACK_BringNetUp+0x210>)
    dade:	9305      	str	r3, [sp, #20]
    pMacCtrl->freeF = TCPIP_HEAP_FreeOutline;
    dae0:	4b60      	ldr	r3, [pc, #384]	; (dc64 <TCPIP_STACK_BringNetUp+0x214>)
    dae2:	9306      	str	r3, [sp, #24]
    pMacCtrl->memH = stackCtrlData->memH;
    dae4:	68f3      	ldr	r3, [r6, #12]
    dae6:	9307      	str	r3, [sp, #28]
    pMacCtrl->pktAllocF = (TCPIP_MAC_PKT_AllocF)_TCPIP_PKT_ALLOC_FNC;
    dae8:	4b5f      	ldr	r3, [pc, #380]	; (dc68 <TCPIP_STACK_BringNetUp+0x218>)
    daea:	9308      	str	r3, [sp, #32]
    pMacCtrl->pktFreeF = (TCPIP_MAC_PKT_FreeF)_TCPIP_PKT_FREE_FNC;
    daec:	4b5f      	ldr	r3, [pc, #380]	; (dc6c <TCPIP_STACK_BringNetUp+0x21c>)
    daee:	9309      	str	r3, [sp, #36]	; 0x24
    pMacCtrl->pktAckF = (TCPIP_MAC_PKT_AckF)_TCPIP_PKT_ACK_FNC;
    daf0:	4b5f      	ldr	r3, [pc, #380]	; (dc70 <TCPIP_STACK_BringNetUp+0x220>)
    daf2:	930a      	str	r3, [sp, #40]	; 0x28
    pMacCtrl->synchF = _TCPIP_StackSyncFunction;
    daf4:	4b5f      	ldr	r3, [pc, #380]	; (dc74 <TCPIP_STACK_BringNetUp+0x224>)
    daf6:	930b      	str	r3, [sp, #44]	; 0x2c
    pMacCtrl->eventF = _TCPIP_MacEventCB;
    daf8:	4b5f      	ldr	r3, [pc, #380]	; (dc78 <TCPIP_STACK_BringNetUp+0x228>)
    dafa:	930c      	str	r3, [sp, #48]	; 0x30
    pMacCtrl->eventParam = pNetIf;
    dafc:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
    pMacCtrl->netIx = stackCtrlData->netIx;
    db00:	69b3      	ldr	r3, [r6, #24]
    db02:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
    pMacCtrl->gapDcptOffset = TCPIP_PKT_GapDcptOffset();
    db06:	f014 fb91 	bl	2222c <TCPIP_PKT_GapDcptOffset>
    db0a:	f8ad 0040 	strh.w	r0, [sp, #64]	; 0x40
    pMacCtrl->gapDcptSize = TCPIP_PKT_GapDcptSize();
    db0e:	f014 fba3 	bl	22258 <TCPIP_PKT_GapDcptSize>
    db12:	f8ad 0042 	strh.w	r0, [sp, #66]	; 0x42
    pMacCtrl->macAction = TCPIP_STACK_StackToMacAction(stackCtrlData->stackAction);
    db16:	7f33      	ldrb	r3, [r6, #28]
    db18:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
    pMacCtrl->powerMode = stackCtrlData->powerMode;
    db1c:	7f73      	ldrb	r3, [r6, #29]
    db1e:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45
    pMacCtrl->controlFlags = TCPIP_MAC_CONTROL_PAYLOAD_OFFSET_2;
    db22:	2301      	movs	r3, #1
    db24:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
    memcpy(pMacCtrl->ifPhyAddress.v, pNetIf->netMACAddr.v, sizeof(pMacCtrl->ifPhyAddress));
    db28:	465b      	mov	r3, fp
    db2a:	f853 0f3c 	ldr.w	r0, [r3, #60]!
    db2e:	9012      	str	r0, [sp, #72]	; 0x48
    db30:	889b      	ldrh	r3, [r3, #4]
    db32:	f8ad 304c 	strh.w	r3, [sp, #76]	; 0x4c
                TCPIP_MAC_INIT macInit =
    db36:	f88d a004 	strb.w	sl, [sp, #4]
    db3a:	ab04      	add	r3, sp, #16
    db3c:	9302      	str	r3, [sp, #8]
    db3e:	f8cd 900c 	str.w	r9, [sp, #12]
                pNetIf->macObjHandle = (*pMacObj->TCPIP_MAC_Initialize)(pMacObj->macId, &macInit.moduleInit);
    db42:	68a3      	ldr	r3, [r4, #8]
    db44:	a901      	add	r1, sp, #4
    db46:	8820      	ldrh	r0, [r4, #0]
    db48:	4798      	blx	r3
    db4a:	f8c8 004c 	str.w	r0, [r8, #76]	; 0x4c
                if( pNetIf->macObjHandle == SYS_MODULE_OBJ_INVALID)
    db4e:	f1b0 3fff 	cmp.w	r0, #4294967295
    db52:	d017      	beq.n	db84 <TCPIP_STACK_BringNetUp+0x134>
                pNetIf->hIfMac = (*pMacObj->TCPIP_MAC_Open)(pMacObj->macId, DRV_IO_INTENT_READWRITE);
    db54:	69e3      	ldr	r3, [r4, #28]
    db56:	2103      	movs	r1, #3
    db58:	8820      	ldrh	r0, [r4, #0]
    db5a:	4798      	blx	r3
    db5c:	f8c8 0050 	str.w	r0, [r8, #80]	; 0x50
                if(pNetIf->hIfMac == DRV_HANDLE_INVALID)
    db60:	f1b0 3fff 	cmp.w	r0, #4294967295
    db64:	d1a2      	bne.n	daac <TCPIP_STACK_BringNetUp+0x5c>
                    pNetIf->hIfMac = 0;
    db66:	2300      	movs	r3, #0
    db68:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
                    pNetIf->macObjHandle = 0;
    db6c:	f8c8 304c 	str.w	r3, [r8, #76]	; 0x4c
                    SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "%s MAC Open failed\r\n", pMacObj->macName);
    db70:	f014 fa6e 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
    db74:	b158      	cbz	r0, db8e <TCPIP_STACK_BringNetUp+0x13e>
    db76:	f014 fa65 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
    db7a:	6862      	ldr	r2, [r4, #4]
    db7c:	493f      	ldr	r1, [pc, #252]	; (dc7c <TCPIP_STACK_BringNetUp+0x22c>)
    db7e:	f00c ff8d 	bl	1aa9c <SYS_CONSOLE_Print>
    db82:	e004      	b.n	db8e <TCPIP_STACK_BringNetUp+0x13e>
                    pNetIf->macObjHandle = 0;
    db84:	f8c8 a04c 	str.w	sl, [r8, #76]	; 0x4c
                    SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "%s MAC initialization failed\r\n", pMacObj->macName);
    db88:	f014 fa62 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
    db8c:	b908      	cbnz	r0, db92 <TCPIP_STACK_BringNetUp+0x142>
        return false;
    db8e:	2400      	movs	r4, #0
    db90:	e03e      	b.n	dc10 <TCPIP_STACK_BringNetUp+0x1c0>
                    SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "%s MAC initialization failed\r\n", pMacObj->macName);
    db92:	f014 fa57 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
    db96:	6862      	ldr	r2, [r4, #4]
    db98:	4939      	ldr	r1, [pc, #228]	; (dc80 <TCPIP_STACK_BringNetUp+0x230>)
    db9a:	f00c ff7f 	bl	1aa9c <SYS_CONSOLE_Print>
    db9e:	e7f6      	b.n	db8e <TCPIP_STACK_BringNetUp+0x13e>
            configData = 0;
    dba0:	2100      	movs	r1, #0
    dba2:	e03b      	b.n	dc1c <TCPIP_STACK_BringNetUp+0x1cc>
    dba4:	4651      	mov	r1, sl
    dba6:	e039      	b.n	dc1c <TCPIP_STACK_BringNetUp+0x1cc>
    dba8:	2100      	movs	r1, #0
    dbaa:	e037      	b.n	dc1c <TCPIP_STACK_BringNetUp+0x1cc>
                SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Module no: %d Initialization failed\r\n", pEntry->moduleId);
    dbac:	f014 fa50 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
    dbb0:	b908      	cbnz	r0, dbb6 <TCPIP_STACK_BringNetUp+0x166>
                netUpFail = 1;
    dbb2:	2401      	movs	r4, #1
    dbb4:	e02a      	b.n	dc0c <TCPIP_STACK_BringNetUp+0x1bc>
                SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Module no: %d Initialization failed\r\n", pEntry->moduleId);
    dbb6:	f014 fa45 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
    dbba:	8822      	ldrh	r2, [r4, #0]
    dbbc:	4931      	ldr	r1, [pc, #196]	; (dc84 <TCPIP_STACK_BringNetUp+0x234>)
    dbbe:	f00c ff6d 	bl	1aa9c <SYS_CONSOLE_Print>
                netUpFail = 1;
    dbc2:	2401      	movs	r4, #1
    dbc4:	e022      	b.n	dc0c <TCPIP_STACK_BringNetUp+0x1bc>
        if(!netUpFail && pNetIf->hIfMac != 0)
    dbc6:	f8d8 0050 	ldr.w	r0, [r8, #80]	; 0x50
    dbca:	b1f0      	cbz	r0, dc0a <TCPIP_STACK_BringNetUp+0x1ba>
                if(!(*pNetIf->pMacObj->TCPIP_MAC_EventMaskSet)(pNetIf->hIfMac, TCPIP_STACK_MAC_ALL_EVENTS, true))
    dbcc:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
    dbd0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    dbd2:	2201      	movs	r2, #1
    dbd4:	f240 7196 	movw	r1, #1942	; 0x796
    dbd8:	4798      	blx	r3
    dbda:	4604      	mov	r4, r0
    dbdc:	b148      	cbz	r0, dbf2 <TCPIP_STACK_BringNetUp+0x1a2>
            pNetIf->Flags.bMacInitialize = true;
    dbde:	f898 3043 	ldrb.w	r3, [r8, #67]	; 0x43
            pNetIf->Flags.bMacInitDone = false;
    dbe2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    dbe6:	f36f 13c7 	bfc	r3, #7, #1
    dbea:	f888 3043 	strb.w	r3, [r8, #67]	; 0x43
    netUpFail = false;
    dbee:	2400      	movs	r4, #0
    dbf0:	e00c      	b.n	dc0c <TCPIP_STACK_BringNetUp+0x1bc>
                    SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "%s MAC event notification setting failed\r\n", pNetIf->pMacObj->macName);
    dbf2:	f014 fa2d 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
    dbf6:	b158      	cbz	r0, dc10 <TCPIP_STACK_BringNetUp+0x1c0>
    dbf8:	f014 fa24 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
    dbfc:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
    dc00:	685a      	ldr	r2, [r3, #4]
    dc02:	4921      	ldr	r1, [pc, #132]	; (dc88 <TCPIP_STACK_BringNetUp+0x238>)
    dc04:	f00c ff4a 	bl	1aa9c <SYS_CONSOLE_Print>
    dc08:	e002      	b.n	dc10 <TCPIP_STACK_BringNetUp+0x1c0>
    netUpFail = false;
    dc0a:	2400      	movs	r4, #0
    if(netUpFail)
    dc0c:	f084 0401 	eor.w	r4, r4, #1
}
    dc10:	4620      	mov	r0, r4
    dc12:	b015      	add	sp, #84	; 0x54
    dc14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(pModConfig->moduleId == moduleId)
    dc18:	462b      	mov	r3, r5
                    configData = pConfig->configData;
    dc1a:	6859      	ldr	r1, [r3, #4]
            if(!pEntry->initFunc(stackCtrlData, configData))
    dc1c:	6863      	ldr	r3, [r4, #4]
    dc1e:	4630      	mov	r0, r6
    dc20:	4798      	blx	r3
    dc22:	2800      	cmp	r0, #0
    dc24:	d0c2      	beq.n	dbac <TCPIP_STACK_BringNetUp+0x15c>
            pEntry++;
    dc26:	340c      	adds	r4, #12
        for(modIx = 0; modIx < sizeof(TCPIP_STACK_MODULE_ENTRY_TBL)/sizeof(*TCPIP_STACK_MODULE_ENTRY_TBL); modIx++)
    dc28:	454c      	cmp	r4, r9
    dc2a:	d0cc      	beq.n	dbc6 <TCPIP_STACK_BringNetUp+0x176>
            if (pModConfig != 0)
    dc2c:	2d00      	cmp	r5, #0
    dc2e:	d0b9      	beq.n	dba4 <TCPIP_STACK_BringNetUp+0x154>
                pConfig = _TCPIP_STACK_FindModuleData(pEntry->moduleId, pModConfig, nModules);
    dc30:	8821      	ldrh	r1, [r4, #0]
    while(nModules--)
    dc32:	2f00      	cmp	r7, #0
    dc34:	d0b8      	beq.n	dba8 <TCPIP_STACK_BringNetUp+0x158>
        if(pModConfig->moduleId == moduleId)
    dc36:	882b      	ldrh	r3, [r5, #0]
    dc38:	428b      	cmp	r3, r1
    dc3a:	d0ed      	beq.n	dc18 <TCPIP_STACK_BringNetUp+0x1c8>
    dc3c:	1eba      	subs	r2, r7, #2
    dc3e:	462b      	mov	r3, r5
        pModConfig++;
    dc40:	3308      	adds	r3, #8
    while(nModules--)
    dc42:	f1b2 3fff 	cmp.w	r2, #4294967295
    dc46:	d0ab      	beq.n	dba0 <TCPIP_STACK_BringNetUp+0x150>
        if(pModConfig->moduleId == moduleId)
    dc48:	3a01      	subs	r2, #1
    dc4a:	8818      	ldrh	r0, [r3, #0]
    dc4c:	4288      	cmp	r0, r1
    dc4e:	d1f7      	bne.n	dc40 <TCPIP_STACK_BringNetUp+0x1f0>
    dc50:	e7e3      	b.n	dc1a <TCPIP_STACK_BringNetUp+0x1ca>
    dc52:	4613      	mov	r3, r2
    dc54:	e723      	b.n	da9e <TCPIP_STACK_BringNetUp+0x4e>
    dc56:	bf00      	nop
    dc58:	0001a9c4 	.word	0x0001a9c4
    dc5c:	000205c9 	.word	0x000205c9
    dc60:	0002214f 	.word	0x0002214f
    dc64:	00022157 	.word	0x00022157
    dc68:	00019095 	.word	0x00019095
    dc6c:	0001e209 	.word	0x0001e209
    dc70:	0001dbf5 	.word	0x0001dbf5
    dc74:	0001a347 	.word	0x0001a347
    dc78:	0001cae1 	.word	0x0001cae1
    dc7c:	00009108 	.word	0x00009108
    dc80:	000090d8 	.word	0x000090d8
    dc84:	0000912c 	.word	0x0000912c
    dc88:	00009160 	.word	0x00009160

Disassembly of section .text.TCPIP_IPV4_Task%219:

0000dc8c <TCPIP_IPV4_Task>:
    TCPIP_Helper_ProtectedSingleListUnlock(&ipv4ArpQueue);

}

void  TCPIP_IPV4_Task(void)
{
    dc8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    dc90:	b087      	sub	sp, #28
    TCPIP_MODULE_SIGNAL sigPend;

    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    dc92:	210f      	movs	r1, #15
    dc94:	2003      	movs	r0, #3
    dc96:	f010 fa99 	bl	1e1cc <_TCPIPStackModuleSignalGet>

    if((sigPend & TCPIP_MODULE_SIGNAL_RX_PENDING) != 0)
    dc9a:	f010 0f01 	tst.w	r0, #1
    dc9e:	d102      	bne.n	dca6 <TCPIP_IPV4_Task+0x1a>
    { // regular TMO occurred
        TCPIP_IPV4_Timeout();
    }
#endif  // (_TCPIP_IPV4_FRAGMENTATION != 0)

}
    dca0:	b007      	add	sp, #28
    dca2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    uint32_t cnt1, cnt2;

    // get a consistent reading
    do
    {
        cnt1 = ipv4ActFilterCount;
    dca6:	f8df 8214 	ldr.w	r8, [pc, #532]	; debc <TCPIP_IPV4_Task+0x230>
  Remarks:
    None
*/
static __inline__ void __attribute__((always_inline)) TCPIP_Notification_Lock(PROTECTED_SINGLE_LIST* notifyList)
{
    TCPIP_Helper_ProtectedSingleListLock(notifyList);
    dcaa:	4f81      	ldr	r7, [pc, #516]	; (deb0 <TCPIP_IPV4_Task+0x224>)
        return TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    dcac:	f06f 090e 	mvn.w	r9, #14
    dcb0:	e0b8      	b.n	de24 <TCPIP_IPV4_Task+0x198>
            payloadLen = TCPIP_PKT_PayloadLen(pRxPkt);
    dcb2:	4628      	mov	r0, r5
    dcb4:	f013 f867 	bl	20d86 <TCPIP_PKT_PayloadLen>
            if(totalLength > payloadLen)
    dcb8:	4582      	cmp	sl, r0
    dcba:	f200 80df 	bhi.w	de7c <TCPIP_IPV4_Task+0x1f0>
            pNetIf = _TCPIPStackMapAliasInterface((TCPIP_NET_IF*)pRxPkt->pktIf, &pHeader->DestAddress);
    dcbe:	f8d5 a028 	ldr.w	sl, [r5, #40]	; 0x28
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
    dcc2:	f1ba 0f00 	cmp.w	sl, #0
    dcc6:	f000 80e8 	beq.w	de9a <TCPIP_IPV4_Task+0x20e>
    dcca:	f89a 3042 	ldrb.w	r3, [sl, #66]	; 0x42
    dcce:	f013 0f40 	tst.w	r3, #64	; 0x40
    dcd2:	d102      	bne.n	dcda <TCPIP_IPV4_Task+0x4e>
                ackRes = TCPIP_MAC_PKT_ACK_IP_REJECT_ERR;
    dcd4:	f06f 0112 	mvn.w	r1, #18
    dcd8:	e0a0      	b.n	de1c <TCPIP_IPV4_Task+0x190>
    return (pIpAdd->Val == 0xFFFFFFFF) ||  (pIpAdd->Val == (pNetIf->netIPAddr.Val | ~pNetIf->netMask.Val));
    dcda:	68f3      	ldr	r3, [r6, #12]
    dcdc:	f1b3 3fff 	cmp.w	r3, #4294967295
    dce0:	f000 80cf 	beq.w	de82 <TCPIP_IPV4_Task+0x1f6>
    dce4:	f8da 1008 	ldr.w	r1, [sl, #8]
    dce8:	f8da 2004 	ldr.w	r2, [sl, #4]
    dcec:	ea62 0201 	orn	r2, r2, r1
            if(_TCPIPStack_IsBcastAddress(pNetIf, &pHeader->SourceAddress))
    dcf0:	4293      	cmp	r3, r2
    dcf2:	f000 80c9 	beq.w	de88 <TCPIP_IPV4_Task+0x1fc>
            if(pHeader->DestAddress.Val == 0)
    dcf6:	6933      	ldr	r3, [r6, #16]
    dcf8:	b913      	cbnz	r3, dd00 <TCPIP_IPV4_Task+0x74>
                ackRes = TCPIP_MAC_PKT_ACK_DEST_ERR;
    dcfa:	f06f 010b 	mvn.w	r1, #11
    dcfe:	e08d      	b.n	de1c <TCPIP_IPV4_Task+0x190>
            headerChecksum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pHeader, headerLen, 0);
    dd00:	2200      	movs	r2, #0
    dd02:	4659      	mov	r1, fp
    dd04:	4630      	mov	r0, r6
    dd06:	f00c fc71 	bl	1a5ec <TCPIP_Helper_CalcIPChecksum>
            if(headerChecksum)
    dd0a:	2800      	cmp	r0, #0
    dd0c:	f040 80bf 	bne.w	de8e <TCPIP_IPV4_Task+0x202>
            cIpv4Hdr = *pHeader;
    dd10:	f10d 0c04 	add.w	ip, sp, #4
    dd14:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    dd16:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    dd1a:	6833      	ldr	r3, [r6, #0]
    dd1c:	f8cc 3000 	str.w	r3, [ip]
            pCHeader->FragmentInfo.val = TCPIP_Helper_ntohs(pCHeader->FragmentInfo.val);
    dd20:	f8bd 200a 	ldrh.w	r2, [sp, #10]
    dd24:	0a13      	lsrs	r3, r2, #8
    dd26:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
            if(pCHeader->FragmentInfo.MF != 0 || pCHeader->FragmentInfo.fragOffset != 0)
    dd2a:	f3c3 030d 	ubfx	r3, r3, #0, #14
    dd2e:	2b00      	cmp	r3, #0
    dd30:	f040 80b0 	bne.w	de94 <TCPIP_IPV4_Task+0x208>
    return ((pIf->netIPAddr.Val ^ pIpAddress->Val) & pIf->netMask.Val) == 0;
    dd34:	f8da 0004 	ldr.w	r0, [sl, #4]
    dd38:	9b05      	ldr	r3, [sp, #20]
    dd3a:	f8da 2008 	ldr.w	r2, [sl, #8]
            if(_TCPIPStackHostPartAddress(pNetIf, pktDestIP) == 0)
    dd3e:	ea00 0102 	and.w	r1, r0, r2
    dd42:	428b      	cmp	r3, r1
    dd44:	d01a      	beq.n	dd7c <TCPIP_IPV4_Task+0xf0>
        currFilter = ipv4FilterType;
    dd46:	495b      	ldr	r1, [pc, #364]	; (deb4 <TCPIP_IPV4_Task+0x228>)
    dd48:	7809      	ldrb	r1, [r1, #0]
    return (pIpAdd->Val == 0xFFFFFFFF) ||  (pIpAdd->Val == (pNetIf->netIPAddr.Val | ~pNetIf->netMask.Val));
    dd4a:	f1b3 3fff 	cmp.w	r3, #4294967295
    dd4e:	d012      	beq.n	dd76 <TCPIP_IPV4_Task+0xea>
    dd50:	ea60 0202 	orn	r2, r0, r2
        if(_TCPIPStack_IsBcastAddress(pNetIf, pktDestIP))
    dd54:	4293      	cmp	r3, r2
    dd56:	d00e      	beq.n	dd76 <TCPIP_IPV4_Task+0xea>
        if(TCPIP_Helper_IsMcastAddress(pktDestIP))
    dd58:	f89d 2014 	ldrb.w	r2, [sp, #20]
    dd5c:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
    dd60:	2ae0      	cmp	r2, #224	; 0xe0
    dd62:	d015      	beq.n	dd90 <TCPIP_IPV4_Task+0x104>
    return (pIpAdd->Val == 0x0100007f || pNetIf->netIPAddr.Val == pIpAdd->Val);
    dd64:	4a54      	ldr	r2, [pc, #336]	; (deb8 <TCPIP_IPV4_Task+0x22c>)
    dd66:	4293      	cmp	r3, r2
    dd68:	d001      	beq.n	dd6e <TCPIP_IPV4_Task+0xe2>
        if(TCPIP_STACK_AddressIsOfNet(pNetIf, pktDestIP))
    dd6a:	4298      	cmp	r0, r3
    dd6c:	d106      	bne.n	dd7c <TCPIP_IPV4_Task+0xf0>
            procType = ((currFilter & TCPIP_IPV4_FILTER_UNICAST) == 0) ? (IPV4_PKT_DEST_HOST | IPV4_PKT_TYPE_UNICAST) : (IPV4_PKT_TYPE_UNICAST);
    dd6e:	f011 0f01 	tst.w	r1, #1
    dd72:	d103      	bne.n	dd7c <TCPIP_IPV4_Task+0xf0>
    dd74:	e00f      	b.n	dd96 <TCPIP_IPV4_Task+0x10a>
            procType = ((currFilter & TCPIP_IPV4_FILTER_BROADCAST) == 0) ? (IPV4_PKT_DEST_HOST | IPV4_PKT_TYPE_BCAST) : (IPV4_PKT_TYPE_BCAST);
    dd76:	f011 0f02 	tst.w	r1, #2
    dd7a:	d00c      	beq.n	dd96 <TCPIP_IPV4_Task+0x10a>
        cnt1 = ipv4ActFilterCount;
    dd7c:	f8d8 2000 	ldr.w	r2, [r8]
        cnt2 = ipv4ActFilterCount;
    dd80:	f8d8 3000 	ldr.w	r3, [r8]
    }while(cnt1 != cnt2);
    dd84:	429a      	cmp	r2, r3
    dd86:	d1f9      	bne.n	dd7c <TCPIP_IPV4_Task+0xf0>


    _IPv4FiltCountDbg("verify");
    if(cnt1 != 0)
    dd88:	bb53      	cbnz	r3, dde0 <TCPIP_IPV4_Task+0x154>
                ackRes = TCPIP_MAC_PKT_ACK_IP_REJECT_ERR;
    dd8a:	f06f 0112 	mvn.w	r1, #18
    dd8e:	e045      	b.n	de1c <TCPIP_IPV4_Task+0x190>
            procType = ((currFilter & TCPIP_IPV4_FILTER_MULTICAST) == 0) ? (IPV4_PKT_DEST_HOST | IPV4_PKT_TYPE_MCAST) : (IPV4_PKT_TYPE_MCAST);
    dd90:	f011 0f04 	tst.w	r1, #4
    dd94:	d1f2      	bne.n	dd7c <TCPIP_IPV4_Task+0xf0>
    pHeader = (IPV4_HEADER*)pRxPkt->pNetLayer;
    dd96:	69a9      	ldr	r1, [r5, #24]
    headerLen = pHeader->IHL << 2;
    dd98:	780b      	ldrb	r3, [r1, #0]
    dd9a:	009b      	lsls	r3, r3, #2
    dd9c:	f003 033c 	and.w	r3, r3, #60	; 0x3c
    pRxPkt->pTransportLayer = pRxPkt->pNetLayer + headerLen;
    dda0:	18ca      	adds	r2, r1, r3
    dda2:	61ea      	str	r2, [r5, #28]
    pRxPkt->pDSeg->segLen -= headerLen;
    dda4:	6928      	ldr	r0, [r5, #16]
    dda6:	b29b      	uxth	r3, r3
    dda8:	8982      	ldrh	r2, [r0, #12]
    ddaa:	1ad2      	subs	r2, r2, r3
    ddac:	8182      	strh	r2, [r0, #12]
    pHeader->TotalLength = TCPIP_Helper_ntohs(pHeader->TotalLength);
    ddae:	8848      	ldrh	r0, [r1, #2]
    ddb0:	0a02      	lsrs	r2, r0, #8
    ddb2:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
    ddb6:	b292      	uxth	r2, r2
    ddb8:	804a      	strh	r2, [r1, #2]
    pRxPkt->totTransportLen = pHeader->TotalLength - headerLen;
    ddba:	1ad3      	subs	r3, r2, r3
    ddbc:	842b      	strh	r3, [r5, #32]
    pHeader->FragmentInfo.val = TCPIP_Helper_ntohs(pHeader->FragmentInfo.val);
    ddbe:	88ca      	ldrh	r2, [r1, #6]
    ddc0:	0a13      	lsrs	r3, r2, #8
    ddc2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    ddc6:	b29b      	uxth	r3, r3
    ddc8:	80cb      	strh	r3, [r1, #6]
    isFragment = pHeader->FragmentInfo.MF != 0 || pHeader->FragmentInfo.fragOffset != 0;
    ddca:	f3c3 030d 	ubfx	r3, r3, #0, #14
    switch(pHeader->Protocol)
    ddce:	7a4a      	ldrb	r2, [r1, #9]
    ddd0:	2a06      	cmp	r2, #6
    ddd2:	d065      	beq.n	dea0 <TCPIP_IPV4_Task+0x214>
    ddd4:	2a11      	cmp	r2, #17
    ddd6:	d065      	beq.n	dea4 <TCPIP_IPV4_Task+0x218>
    ddd8:	2a01      	cmp	r2, #1
    ddda:	d016      	beq.n	de0a <TCPIP_IPV4_Task+0x17e>
        return TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    dddc:	4649      	mov	r1, r9
    ddde:	e01d      	b.n	de1c <TCPIP_IPV4_Task+0x190>
    dde0:	4638      	mov	r0, r7
    dde2:	f012 fe65 	bl	20ab0 <TCPIP_Helper_ProtectedSingleListLock>
    {   // active filters
        TCPIP_Notification_Lock(&ipv4PacketFilters);
        for(fNode = (IPV4_FILTER_LIST_NODE*)ipv4PacketFilters.list.head; fNode != 0; fNode = fNode->next)
    dde6:	683e      	ldr	r6, [r7, #0]
    dde8:	e000      	b.n	ddec <TCPIP_IPV4_Task+0x160>
    ddea:	6836      	ldr	r6, [r6, #0]
    ddec:	2e00      	cmp	r6, #0
    ddee:	d05b      	beq.n	dea8 <TCPIP_IPV4_Task+0x21c>
        {
            if(fNode->active != 0)
    ddf0:	7a33      	ldrb	r3, [r6, #8]
    ddf2:	2b00      	cmp	r3, #0
    ddf4:	d0f9      	beq.n	ddea <TCPIP_IPV4_Task+0x15e>
            {
                if((*fNode->handler)(pRxPkt, hdrlen))
    ddf6:	6873      	ldr	r3, [r6, #4]
    ddf8:	4621      	mov	r1, r4
    ddfa:	4628      	mov	r0, r5
    ddfc:	4798      	blx	r3
    ddfe:	2800      	cmp	r0, #0
    de00:	d0f3      	beq.n	ddea <TCPIP_IPV4_Task+0x15e>
  Remarks:
    None
*/
static __inline__ void __attribute__((always_inline)) TCPIP_Notification_Unlock(PROTECTED_SINGLE_LIST* notifyList)
{
    TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
    de02:	4638      	mov	r0, r7
    de04:	f013 f896 	bl	20f34 <TCPIP_Helper_ProtectedSingleListUnlock>
            }
        }
        TCPIP_Notification_Unlock(&ipv4PacketFilters);
    }
        
    return pktOk;
    de08:	e7c5      	b.n	dd96 <TCPIP_IPV4_Task+0x10a>
            destId = TCPIP_MODULE_ICMP;
    de0a:	2006      	movs	r0, #6
    if(!isFragment)
    de0c:	b953      	cbnz	r3, de24 <TCPIP_IPV4_Task+0x198>
        _TCPIPStackModuleRxInsert(destId, pRxPkt, true);
    de0e:	2201      	movs	r2, #1
    de10:	4629      	mov	r1, r5
    de12:	f00f fc1f 	bl	1d654 <_TCPIPStackModuleRxInsert>
    de16:	e005      	b.n	de24 <TCPIP_IPV4_Task+0x198>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    de18:	f06f 010d 	mvn.w	r1, #13
            TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes); 
    de1c:	2203      	movs	r2, #3
    de1e:	4628      	mov	r0, r5
    de20:	f00f fee8 	bl	1dbf4 <_TCPIP_PKT_PacketAcknowledge>
    while((pRxPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
    de24:	2003      	movs	r0, #3
    de26:	f011 fd91 	bl	1f94c <_TCPIPStackModuleRxExtract>
    de2a:	4605      	mov	r5, r0
    de2c:	2800      	cmp	r0, #0
    de2e:	f43f af37 	beq.w	dca0 <TCPIP_IPV4_Task+0x14>
            pHeader = (IPV4_HEADER*)pRxPkt->pNetLayer;
    de32:	69ae      	ldr	r6, [r5, #24]
            if((pHeader->Version) != IPv4_VERSION)
    de34:	7833      	ldrb	r3, [r6, #0]
    de36:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    de3a:	2b40      	cmp	r3, #64	; 0x40
    de3c:	d1ec      	bne.n	de18 <TCPIP_IPV4_Task+0x18c>
            headerLen = pHeader->IHL << 2;
    de3e:	7834      	ldrb	r4, [r6, #0]
    de40:	00a4      	lsls	r4, r4, #2
    de42:	f004 043c 	and.w	r4, r4, #60	; 0x3c
            if(headerLen < sizeof(IPV4_HEADER) || (uint16_t)headerLen > pRxPkt->pDSeg->segLen)
    de46:	2c13      	cmp	r4, #19
    de48:	d912      	bls.n	de70 <TCPIP_IPV4_Task+0x1e4>
    de4a:	fa1f fb84 	uxth.w	fp, r4
    de4e:	692b      	ldr	r3, [r5, #16]
    de50:	899b      	ldrh	r3, [r3, #12]
    de52:	455b      	cmp	r3, fp
    de54:	d30f      	bcc.n	de76 <TCPIP_IPV4_Task+0x1ea>
            totalLength = TCPIP_Helper_ntohs(pHeader->TotalLength);
    de56:	8873      	ldrh	r3, [r6, #2]
    de58:	ea4f 2a13 	mov.w	sl, r3, lsr #8
    de5c:	ea4a 2a03 	orr.w	sl, sl, r3, lsl #8
    de60:	fa1f fa8a 	uxth.w	sl, sl
            if(totalLength < (uint16_t)headerLen)
    de64:	45d3      	cmp	fp, sl
    de66:	f67f af24 	bls.w	dcb2 <TCPIP_IPV4_Task+0x26>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    de6a:	f06f 010d 	mvn.w	r1, #13
    de6e:	e7d5      	b.n	de1c <TCPIP_IPV4_Task+0x190>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    de70:	f06f 010d 	mvn.w	r1, #13
    de74:	e7d2      	b.n	de1c <TCPIP_IPV4_Task+0x190>
    de76:	f06f 010d 	mvn.w	r1, #13
    de7a:	e7cf      	b.n	de1c <TCPIP_IPV4_Task+0x190>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    de7c:	f06f 010d 	mvn.w	r1, #13
    de80:	e7cc      	b.n	de1c <TCPIP_IPV4_Task+0x190>
                ackRes = TCPIP_MAC_PKT_ACK_SOURCE_ERR;
    de82:	f06f 010a 	mvn.w	r1, #10
    de86:	e7c9      	b.n	de1c <TCPIP_IPV4_Task+0x190>
    de88:	f06f 010a 	mvn.w	r1, #10
    de8c:	e7c6      	b.n	de1c <TCPIP_IPV4_Task+0x190>
                ackRes = TCPIP_MAC_PKT_ACK_CHKSUM_ERR;
    de8e:	f06f 0109 	mvn.w	r1, #9
    de92:	e7c3      	b.n	de1c <TCPIP_IPV4_Task+0x190>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    de94:	f06f 010d 	mvn.w	r1, #13
    de98:	e7c0      	b.n	de1c <TCPIP_IPV4_Task+0x190>
                ackRes = TCPIP_MAC_PKT_ACK_IP_REJECT_ERR;
    de9a:	f06f 0112 	mvn.w	r1, #18
        if(ackRes != TCPIP_MAC_PKT_ACK_NONE)
    de9e:	e7bd      	b.n	de1c <TCPIP_IPV4_Task+0x190>
            destId = TCPIP_MODULE_TCP;
    dea0:	200a      	movs	r0, #10
    dea2:	e7b3      	b.n	de0c <TCPIP_IPV4_Task+0x180>
            destId = TCPIP_MODULE_UDP;
    dea4:	2009      	movs	r0, #9
    if(destId == TCPIP_MODULE_NONE)
    dea6:	e7b1      	b.n	de0c <TCPIP_IPV4_Task+0x180>
    dea8:	4638      	mov	r0, r7
    deaa:	f013 f843 	bl	20f34 <TCPIP_Helper_ProtectedSingleListUnlock>
    return pktOk;
    deae:	e76c      	b.n	dd8a <TCPIP_IPV4_Task+0xfe>
    deb0:	2000e23c 	.word	0x2000e23c
    deb4:	2000e50c 	.word	0x2000e50c
    deb8:	0100007f 	.word	0x0100007f
    debc:	2000e3f4 	.word	0x2000e3f4

Disassembly of section .text._printf_i%220:

0000dec0 <_printf_i>:
    dec0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    dec4:	4606      	mov	r6, r0
    dec6:	460c      	mov	r4, r1
    dec8:	f101 0043 	add.w	r0, r1, #67	; 0x43
    decc:	7e09      	ldrb	r1, [r1, #24]
    dece:	b085      	sub	sp, #20
    ded0:	296e      	cmp	r1, #110	; 0x6e
    ded2:	4698      	mov	r8, r3
    ded4:	4617      	mov	r7, r2
    ded6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    ded8:	f000 80ba 	beq.w	e050 <_printf_i+0x190>
    dedc:	d824      	bhi.n	df28 <_printf_i+0x68>
    dede:	2963      	cmp	r1, #99	; 0x63
    dee0:	d039      	beq.n	df56 <_printf_i+0x96>
    dee2:	d80a      	bhi.n	defa <_printf_i+0x3a>
    dee4:	2900      	cmp	r1, #0
    dee6:	f000 80c3 	beq.w	e070 <_printf_i+0x1b0>
    deea:	2958      	cmp	r1, #88	; 0x58
    deec:	f000 8091 	beq.w	e012 <_printf_i+0x152>
    def0:	f104 0542 	add.w	r5, r4, #66	; 0x42
    def4:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
    def8:	e035      	b.n	df66 <_printf_i+0xa6>
    defa:	2964      	cmp	r1, #100	; 0x64
    defc:	d001      	beq.n	df02 <_printf_i+0x42>
    defe:	2969      	cmp	r1, #105	; 0x69
    df00:	d1f6      	bne.n	def0 <_printf_i+0x30>
    df02:	6825      	ldr	r5, [r4, #0]
    df04:	681a      	ldr	r2, [r3, #0]
    df06:	f015 0f80 	tst.w	r5, #128	; 0x80
    df0a:	f102 0104 	add.w	r1, r2, #4
    df0e:	d02c      	beq.n	df6a <_printf_i+0xaa>
    df10:	6812      	ldr	r2, [r2, #0]
    df12:	6019      	str	r1, [r3, #0]
    df14:	2a00      	cmp	r2, #0
    df16:	da03      	bge.n	df20 <_printf_i+0x60>
    df18:	232d      	movs	r3, #45	; 0x2d
    df1a:	4252      	negs	r2, r2
    df1c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    df20:	f8df c1bc 	ldr.w	ip, [pc, #444]	; e0e0 <_printf_i+0x220>
    df24:	230a      	movs	r3, #10
    df26:	e03f      	b.n	dfa8 <_printf_i+0xe8>
    df28:	2973      	cmp	r1, #115	; 0x73
    df2a:	f000 80a5 	beq.w	e078 <_printf_i+0x1b8>
    df2e:	d808      	bhi.n	df42 <_printf_i+0x82>
    df30:	296f      	cmp	r1, #111	; 0x6f
    df32:	d021      	beq.n	df78 <_printf_i+0xb8>
    df34:	2970      	cmp	r1, #112	; 0x70
    df36:	d1db      	bne.n	def0 <_printf_i+0x30>
    df38:	6822      	ldr	r2, [r4, #0]
    df3a:	f042 0220 	orr.w	r2, r2, #32
    df3e:	6022      	str	r2, [r4, #0]
    df40:	e003      	b.n	df4a <_printf_i+0x8a>
    df42:	2975      	cmp	r1, #117	; 0x75
    df44:	d018      	beq.n	df78 <_printf_i+0xb8>
    df46:	2978      	cmp	r1, #120	; 0x78
    df48:	d1d2      	bne.n	def0 <_printf_i+0x30>
    df4a:	2278      	movs	r2, #120	; 0x78
    df4c:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
    df50:	f8df c190 	ldr.w	ip, [pc, #400]	; e0e4 <_printf_i+0x224>
    df54:	e061      	b.n	e01a <_printf_i+0x15a>
    df56:	681a      	ldr	r2, [r3, #0]
    df58:	1d11      	adds	r1, r2, #4
    df5a:	6019      	str	r1, [r3, #0]
    df5c:	6813      	ldr	r3, [r2, #0]
    df5e:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    df62:	f104 0542 	add.w	r5, r4, #66	; 0x42
    df66:	2301      	movs	r3, #1
    df68:	e093      	b.n	e092 <_printf_i+0x1d2>
    df6a:	6812      	ldr	r2, [r2, #0]
    df6c:	6019      	str	r1, [r3, #0]
    df6e:	f015 0f40 	tst.w	r5, #64	; 0x40
    df72:	bf18      	it	ne
    df74:	b212      	sxthne	r2, r2
    df76:	e7cd      	b.n	df14 <_printf_i+0x54>
    df78:	f8d4 c000 	ldr.w	ip, [r4]
    df7c:	681a      	ldr	r2, [r3, #0]
    df7e:	f01c 0f80 	tst.w	ip, #128	; 0x80
    df82:	f102 0504 	add.w	r5, r2, #4
    df86:	601d      	str	r5, [r3, #0]
    df88:	d001      	beq.n	df8e <_printf_i+0xce>
    df8a:	6812      	ldr	r2, [r2, #0]
    df8c:	e003      	b.n	df96 <_printf_i+0xd6>
    df8e:	f01c 0f40 	tst.w	ip, #64	; 0x40
    df92:	d0fa      	beq.n	df8a <_printf_i+0xca>
    df94:	8812      	ldrh	r2, [r2, #0]
    df96:	f8df c148 	ldr.w	ip, [pc, #328]	; e0e0 <_printf_i+0x220>
    df9a:	296f      	cmp	r1, #111	; 0x6f
    df9c:	bf0c      	ite	eq
    df9e:	2308      	moveq	r3, #8
    dfa0:	230a      	movne	r3, #10
    dfa2:	2100      	movs	r1, #0
    dfa4:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
    dfa8:	6865      	ldr	r5, [r4, #4]
    dfaa:	60a5      	str	r5, [r4, #8]
    dfac:	2d00      	cmp	r5, #0
    dfae:	bfa2      	ittt	ge
    dfb0:	6821      	ldrge	r1, [r4, #0]
    dfb2:	f021 0104 	bicge.w	r1, r1, #4
    dfb6:	6021      	strge	r1, [r4, #0]
    dfb8:	b90a      	cbnz	r2, dfbe <_printf_i+0xfe>
    dfba:	2d00      	cmp	r5, #0
    dfbc:	d046      	beq.n	e04c <_printf_i+0x18c>
    dfbe:	4605      	mov	r5, r0
    dfc0:	fbb2 f1f3 	udiv	r1, r2, r3
    dfc4:	fb03 2e11 	mls	lr, r3, r1, r2
    dfc8:	4293      	cmp	r3, r2
    dfca:	f81c e00e 	ldrb.w	lr, [ip, lr]
    dfce:	f805 ed01 	strb.w	lr, [r5, #-1]!
    dfd2:	d939      	bls.n	e048 <_printf_i+0x188>
    dfd4:	2b08      	cmp	r3, #8
    dfd6:	d10b      	bne.n	dff0 <_printf_i+0x130>
    dfd8:	6823      	ldr	r3, [r4, #0]
    dfda:	07da      	lsls	r2, r3, #31
    dfdc:	d508      	bpl.n	dff0 <_printf_i+0x130>
    dfde:	6923      	ldr	r3, [r4, #16]
    dfe0:	6862      	ldr	r2, [r4, #4]
    dfe2:	429a      	cmp	r2, r3
    dfe4:	bfde      	ittt	le
    dfe6:	2330      	movle	r3, #48	; 0x30
    dfe8:	f805 3c01 	strble.w	r3, [r5, #-1]
    dfec:	f105 35ff 	addle.w	r5, r5, #4294967295
    dff0:	1b40      	subs	r0, r0, r5
    dff2:	6120      	str	r0, [r4, #16]
    dff4:	f8cd 8000 	str.w	r8, [sp]
    dff8:	463b      	mov	r3, r7
    dffa:	aa03      	add	r2, sp, #12
    dffc:	4621      	mov	r1, r4
    dffe:	4630      	mov	r0, r6
    e000:	f006 ff82 	bl	14f08 <_printf_common>
    e004:	3001      	adds	r0, #1
    e006:	d149      	bne.n	e09c <_printf_i+0x1dc>
    e008:	f04f 30ff 	mov.w	r0, #4294967295
    e00c:	b005      	add	sp, #20
    e00e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    e012:	f8df c0cc 	ldr.w	ip, [pc, #204]	; e0e0 <_printf_i+0x220>
    e016:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
    e01a:	681d      	ldr	r5, [r3, #0]
    e01c:	6821      	ldr	r1, [r4, #0]
    e01e:	f855 2b04 	ldr.w	r2, [r5], #4
    e022:	601d      	str	r5, [r3, #0]
    e024:	060d      	lsls	r5, r1, #24
    e026:	d50b      	bpl.n	e040 <_printf_i+0x180>
    e028:	07cd      	lsls	r5, r1, #31
    e02a:	bf44      	itt	mi
    e02c:	f041 0120 	orrmi.w	r1, r1, #32
    e030:	6021      	strmi	r1, [r4, #0]
    e032:	b91a      	cbnz	r2, e03c <_printf_i+0x17c>
    e034:	6823      	ldr	r3, [r4, #0]
    e036:	f023 0320 	bic.w	r3, r3, #32
    e03a:	6023      	str	r3, [r4, #0]
    e03c:	2310      	movs	r3, #16
    e03e:	e7b0      	b.n	dfa2 <_printf_i+0xe2>
    e040:	064b      	lsls	r3, r1, #25
    e042:	bf48      	it	mi
    e044:	b292      	uxthmi	r2, r2
    e046:	e7ef      	b.n	e028 <_printf_i+0x168>
    e048:	460a      	mov	r2, r1
    e04a:	e7b9      	b.n	dfc0 <_printf_i+0x100>
    e04c:	4605      	mov	r5, r0
    e04e:	e7c1      	b.n	dfd4 <_printf_i+0x114>
    e050:	681a      	ldr	r2, [r3, #0]
    e052:	f8d4 c000 	ldr.w	ip, [r4]
    e056:	6961      	ldr	r1, [r4, #20]
    e058:	1d15      	adds	r5, r2, #4
    e05a:	601d      	str	r5, [r3, #0]
    e05c:	f01c 0f80 	tst.w	ip, #128	; 0x80
    e060:	6813      	ldr	r3, [r2, #0]
    e062:	d001      	beq.n	e068 <_printf_i+0x1a8>
    e064:	6019      	str	r1, [r3, #0]
    e066:	e003      	b.n	e070 <_printf_i+0x1b0>
    e068:	f01c 0f40 	tst.w	ip, #64	; 0x40
    e06c:	d0fa      	beq.n	e064 <_printf_i+0x1a4>
    e06e:	8019      	strh	r1, [r3, #0]
    e070:	2300      	movs	r3, #0
    e072:	6123      	str	r3, [r4, #16]
    e074:	4605      	mov	r5, r0
    e076:	e7bd      	b.n	dff4 <_printf_i+0x134>
    e078:	681a      	ldr	r2, [r3, #0]
    e07a:	1d11      	adds	r1, r2, #4
    e07c:	6019      	str	r1, [r3, #0]
    e07e:	6815      	ldr	r5, [r2, #0]
    e080:	6862      	ldr	r2, [r4, #4]
    e082:	2100      	movs	r1, #0
    e084:	4628      	mov	r0, r5
    e086:	f009 fdbb 	bl	17c00 <memchr>
    e08a:	b108      	cbz	r0, e090 <_printf_i+0x1d0>
    e08c:	1b40      	subs	r0, r0, r5
    e08e:	6060      	str	r0, [r4, #4]
    e090:	6863      	ldr	r3, [r4, #4]
    e092:	6123      	str	r3, [r4, #16]
    e094:	2300      	movs	r3, #0
    e096:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    e09a:	e7ab      	b.n	dff4 <_printf_i+0x134>
    e09c:	6923      	ldr	r3, [r4, #16]
    e09e:	462a      	mov	r2, r5
    e0a0:	4639      	mov	r1, r7
    e0a2:	4630      	mov	r0, r6
    e0a4:	47c0      	blx	r8
    e0a6:	3001      	adds	r0, #1
    e0a8:	d0ae      	beq.n	e008 <_printf_i+0x148>
    e0aa:	6823      	ldr	r3, [r4, #0]
    e0ac:	079b      	lsls	r3, r3, #30
    e0ae:	d413      	bmi.n	e0d8 <_printf_i+0x218>
    e0b0:	68e0      	ldr	r0, [r4, #12]
    e0b2:	9b03      	ldr	r3, [sp, #12]
    e0b4:	4298      	cmp	r0, r3
    e0b6:	bfb8      	it	lt
    e0b8:	4618      	movlt	r0, r3
    e0ba:	e7a7      	b.n	e00c <_printf_i+0x14c>
    e0bc:	2301      	movs	r3, #1
    e0be:	464a      	mov	r2, r9
    e0c0:	4639      	mov	r1, r7
    e0c2:	4630      	mov	r0, r6
    e0c4:	47c0      	blx	r8
    e0c6:	3001      	adds	r0, #1
    e0c8:	d09e      	beq.n	e008 <_printf_i+0x148>
    e0ca:	3501      	adds	r5, #1
    e0cc:	68e3      	ldr	r3, [r4, #12]
    e0ce:	9a03      	ldr	r2, [sp, #12]
    e0d0:	1a9b      	subs	r3, r3, r2
    e0d2:	42ab      	cmp	r3, r5
    e0d4:	dcf2      	bgt.n	e0bc <_printf_i+0x1fc>
    e0d6:	e7eb      	b.n	e0b0 <_printf_i+0x1f0>
    e0d8:	2500      	movs	r5, #0
    e0da:	f104 0919 	add.w	r9, r4, #25
    e0de:	e7f5      	b.n	e0cc <_printf_i+0x20c>
    e0e0:	0002082c 	.word	0x0002082c
    e0e4:	0002083d 	.word	0x0002083d

Disassembly of section .text.TCPIP_UDP_Flush%221:

0000e0e8 <TCPIP_UDP_Flush>:
{
    e0e8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    e0ec:	b085      	sub	sp, #20
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
    e0ee:	f011 ff99 	bl	20024 <_UDPSocketDcpt>
    if(pSkt && _UDPTxPktValid(pSkt))
    e0f2:	2800      	cmp	r0, #0
    e0f4:	f000 8101 	beq.w	e2fa <TCPIP_UDP_Flush+0x212>
    e0f8:	4605      	mov	r5, r0
    e0fa:	f013 f915 	bl	21328 <_UDPTxPktValid>
    e0fe:	2800      	cmp	r0, #0
    e100:	f000 8100 	beq.w	e304 <TCPIP_UDP_Flush+0x21c>
        if(pSkt->flags.txSplitAlloc == 0)
    e104:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    e108:	f013 0f02 	tst.w	r3, #2
    e10c:	f040 80b9 	bne.w	e282 <TCPIP_UDP_Flush+0x19a>
            payload = pSkt->txWrite - pSkt->txStart;
    e110:	68ac      	ldr	r4, [r5, #8]
    e112:	682b      	ldr	r3, [r5, #0]
    e114:	1ae4      	subs	r4, r4, r3
    e116:	b2a4      	uxth	r4, r4
        if(payload)
    e118:	2c00      	cmp	r4, #0
    e11a:	f000 80ef 	beq.w	e2fc <TCPIP_UDP_Flush+0x214>
            switch(pSkt->addType)
    e11e:	8fab      	ldrh	r3, [r5, #60]	; 0x3c
    e120:	2b01      	cmp	r3, #1
    return 0;
    e122:	bf18      	it	ne
    e124:	2400      	movne	r4, #0
            switch(pSkt->addType)
    e126:	f040 80e9 	bne.w	e2fc <TCPIP_UDP_Flush+0x214>
    if(pSkt->destAddress.Val == 0)
    e12a:	696b      	ldr	r3, [r5, #20]
    e12c:	2b00      	cmp	r3, #0
    e12e:	f000 80e0 	beq.w	e2f2 <TCPIP_UDP_Flush+0x20a>
    if(pSkt->flags.srcSolved == 0 || pSkt->pSktNet == 0)
    e132:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
    e136:	f013 0f80 	tst.w	r3, #128	; 0x80
    e13a:	d001      	beq.n	e140 <TCPIP_UDP_Flush+0x58>
    e13c:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    e13e:	b992      	cbnz	r2, e166 <TCPIP_UDP_Flush+0x7e>
        pSkt->pSktNet = (TCPIP_NET_IF*)TCPIP_IPV4_SelectSourceInterface(pSkt->pSktNet, &pSkt->destAddress, &pSkt->srcAddress, pSkt->flags.srcValid != 0);
    e140:	f3c3 1380 	ubfx	r3, r3, #6, #1
    e144:	f105 0218 	add.w	r2, r5, #24
    e148:	f105 0114 	add.w	r1, r5, #20
    e14c:	6a68      	ldr	r0, [r5, #36]	; 0x24
    e14e:	f00e fd5f 	bl	1cc10 <TCPIP_IPV4_SelectSourceInterface>
    e152:	6268      	str	r0, [r5, #36]	; 0x24
        if(pSkt->pSktNet == 0)
    e154:	2800      	cmp	r0, #0
    e156:	f000 80ce 	beq.w	e2f6 <TCPIP_UDP_Flush+0x20e>
        pSkt->flags.srcSolved = 1;
    e15a:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
        pSkt->flags.srcValid = 1;
    e15e:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
    e162:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
    if(pSkt->flags.bcastForceType == UDP_BCAST_NETWORK_DIRECTED)
    e166:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
    e16a:	f003 0303 	and.w	r3, r3, #3
    e16e:	2b02      	cmp	r3, #2
    e170:	f000 808b 	beq.w	e28a <TCPIP_UDP_Flush+0x1a2>
    pv4Pkt = pSkt->pV4Pkt;
    e174:	68ee      	ldr	r6, [r5, #12]
    pv4Pkt->srcAddress.Val = pSkt->srcAddress.Val;
    e176:	69ab      	ldr	r3, [r5, #24]
    e178:	6373      	str	r3, [r6, #52]	; 0x34
    pv4Pkt->destAddress.Val = pSkt->destAddress.Val;
    e17a:	696b      	ldr	r3, [r5, #20]
    e17c:	63b3      	str	r3, [r6, #56]	; 0x38
    pv4Pkt->netIfH = pSkt->pSktNet;
    e17e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    e180:	63f3      	str	r3, [r6, #60]	; 0x3c
    pUDPHdr = (UDP_HEADER*)pv4Pkt->macPkt.pTransportLayer;
    e182:	69f7      	ldr	r7, [r6, #28]
    if(pSkt->flags.txSplitAlloc != 0)
    e184:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    e188:	f013 0f02 	tst.w	r3, #2
    e18c:	f000 8082 	beq.w	e294 <TCPIP_UDP_Flush+0x1ac>
        pZSeg = ((UDP_V4_PACKET*)pv4Pkt)->zcSeg;
    e190:	f106 0944 	add.w	r9, r6, #68	; 0x44
        udpLoadLen = pZSeg->segLen;
    e194:	f8b6 4050 	ldrh.w	r4, [r6, #80]	; 0x50
        rootLen = sizeof(UDP_HEADER);
    e198:	2308      	movs	r3, #8
    pv4Pkt->macPkt.pDSeg->segLen += rootLen;
    e19a:	6932      	ldr	r2, [r6, #16]
    e19c:	8991      	ldrh	r1, [r2, #12]
    e19e:	440b      	add	r3, r1
    e1a0:	8193      	strh	r3, [r2, #12]
    udpTotLen = udpLoadLen + sizeof(UDP_HEADER);
    e1a2:	f104 0808 	add.w	r8, r4, #8
    e1a6:	fa1f f888 	uxth.w	r8, r8
    pUDPHdr->SourcePort = TCPIP_Helper_htons(pSkt->localPort);
    e1aa:	8d6a      	ldrh	r2, [r5, #42]	; 0x2a
    e1ac:	0a13      	lsrs	r3, r2, #8
    e1ae:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    e1b2:	803b      	strh	r3, [r7, #0]
    pUDPHdr->DestinationPort = TCPIP_Helper_htons(pSkt->remotePort);
    e1b4:	8d2a      	ldrh	r2, [r5, #40]	; 0x28
    e1b6:	0a13      	lsrs	r3, r2, #8
    e1b8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    e1bc:	807b      	strh	r3, [r7, #2]
    e1be:	ea4f 2318 	mov.w	r3, r8, lsr #8
    e1c2:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
    pUDPHdr->Length = TCPIP_Helper_htons(udpTotLen);
    e1c6:	80bb      	strh	r3, [r7, #4]
    pUDPHdr->Checksum = 0;
    e1c8:	2200      	movs	r2, #0
    e1ca:	80fa      	strh	r2, [r7, #6]
    pseudoHdr.SourceAddress.Val = pv4Pkt->srcAddress.Val;
    e1cc:	6b73      	ldr	r3, [r6, #52]	; 0x34
    e1ce:	9301      	str	r3, [sp, #4]
    pseudoHdr.DestAddress.Val = pv4Pkt->destAddress.Val;
    e1d0:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    e1d2:	9302      	str	r3, [sp, #8]
    pseudoHdr.Zero = 0;
    e1d4:	f88d 200c 	strb.w	r2, [sp, #12]
    pseudoHdr.Protocol = IP_PROT_UDP;
    e1d8:	2311      	movs	r3, #17
    e1da:	f88d 300d 	strb.w	r3, [sp, #13]
    pseudoHdr.Length = pUDPHdr->Length;
    e1de:	88bb      	ldrh	r3, [r7, #4]
    e1e0:	f8ad 300e 	strh.w	r3, [sp, #14]
    checksum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)&pseudoHdr, sizeof(pseudoHdr), 0);
    e1e4:	210c      	movs	r1, #12
    e1e6:	a801      	add	r0, sp, #4
    e1e8:	f00c fa00 	bl	1a5ec <TCPIP_Helper_CalcIPChecksum>
    e1ec:	43c0      	mvns	r0, r0
    e1ee:	b282      	uxth	r2, r0
    if(pSkt->flags.txSplitAlloc != 0)
    e1f0:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    e1f4:	f013 0f02 	tst.w	r3, #2
    e1f8:	d056      	beq.n	e2a8 <TCPIP_UDP_Flush+0x1c0>
        checksum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)pUDPHdr, sizeof(UDP_HEADER), checksum);
    e1fa:	2108      	movs	r1, #8
    e1fc:	4638      	mov	r0, r7
    e1fe:	f00c f9f5 	bl	1a5ec <TCPIP_Helper_CalcIPChecksum>
    e202:	43c2      	mvns	r2, r0
        checksum = ~TCPIP_Helper_CalcIPChecksum(pZSeg->segLoad, udpLoadLen, checksum);
    e204:	b292      	uxth	r2, r2
    e206:	4621      	mov	r1, r4
    e208:	f8d9 0008 	ldr.w	r0, [r9, #8]
    e20c:	f00c f9ee 	bl	1a5ec <TCPIP_Helper_CalcIPChecksum>
    e210:	43c3      	mvns	r3, r0
    e212:	b29b      	uxth	r3, r3
    pUDPHdr->Checksum = ~checksum;
    e214:	43db      	mvns	r3, r3
    e216:	80fb      	strh	r3, [r7, #6]
    if(isMcastDest)
    e218:	f896 3038 	ldrb.w	r3, [r6, #56]	; 0x38
    e21c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    e220:	2be0      	cmp	r3, #224	; 0xe0
    e222:	d048      	beq.n	e2b6 <TCPIP_UDP_Flush+0x1ce>
        pktParams.ttl = pSkt->ttl;
    e224:	f895 305b 	ldrb.w	r3, [r5, #91]	; 0x5b
    e228:	f88d 3001 	strb.w	r3, [sp, #1]
    pktParams.tosFlags = pSkt->extFlags.tos;
    e22c:	f895 3043 	ldrb.w	r3, [r5, #67]	; 0x43
    e230:	f3c3 0205 	ubfx	r2, r3, #0, #6
    e234:	f88d 2000 	strb.w	r2, [sp]
    pktParams.df = pSkt->extFlags.df;
    e238:	f3c3 1380 	ubfx	r3, r3, #6, #1
    e23c:	f88d 3002 	strb.w	r3, [sp, #2]
    TCPIP_IPV4_PacketFormatTx(pv4Pkt, IP_PROT_UDP, udpTotLen, &pktParams);
    e240:	466b      	mov	r3, sp
    e242:	4642      	mov	r2, r8
    e244:	2111      	movs	r1, #17
    e246:	4630      	mov	r0, r6
    e248:	f005 f8aa 	bl	133a0 <TCPIP_IPV4_PacketFormatTx>
    pv4Pkt->macPkt.next = 0;    // single packet
    e24c:	2300      	movs	r3, #0
    e24e:	6033      	str	r3, [r6, #0]
    if(isMcastDest && pSkt->extFlags.mcastLoop)
    e250:	8673      	strh	r3, [r6, #50]	; 0x32
    if(TCPIP_IPV4_PacketTransmit(pv4Pkt))
    e252:	4630      	mov	r0, r6
    e254:	f013 feba 	bl	21fcc <TCPIP_IPV4_PacketTransmit>
    e258:	2800      	cmp	r0, #0
    e25a:	d14f      	bne.n	e2fc <TCPIP_UDP_Flush+0x214>
    pPkt->macPkt.pDSeg->segLen = 0;
    e25c:	6933      	ldr	r3, [r6, #16]
    e25e:	2200      	movs	r2, #0
    e260:	819a      	strh	r2, [r3, #12]
    if(pSkt->flags.txSplitAlloc)
    e262:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    e266:	f013 0f02 	tst.w	r3, #2
        ((UDP_V4_PACKET*)pPkt)->zcSeg->segLen = 0;
    e26a:	bf19      	ittee	ne
    e26c:	4613      	movne	r3, r2
    e26e:	f8a6 2050 	strhne.w	r2, [r6, #80]	; 0x50
        pSkt->txWrite = pSkt->txStart;
    e272:	682b      	ldreq	r3, [r5, #0]
    e274:	60ab      	streq	r3, [r5, #8]
    pPkt->macPkt.pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED;
    e276:	8c73      	ldrh	r3, [r6, #34]	; 0x22
    e278:	f023 0308 	bic.w	r3, r3, #8
    e27c:	8473      	strh	r3, [r6, #34]	; 0x22
    return 0;
    e27e:	2400      	movs	r4, #0
    e280:	e03c      	b.n	e2fc <TCPIP_UDP_Flush+0x214>
            payload = ((UDP_V4_PACKET*)pSkt->pPkt)->zcSeg->segLen;
    e282:	68eb      	ldr	r3, [r5, #12]
    e284:	f8b3 4050 	ldrh.w	r4, [r3, #80]	; 0x50
    e288:	e746      	b.n	e118 <TCPIP_UDP_Flush+0x30>
        pSkt->destAddress.Val = TCPIP_STACK_NetAddressBcast(pSkt->pSktNet);
    e28a:	6a68      	ldr	r0, [r5, #36]	; 0x24
    e28c:	f012 fd4e 	bl	20d2c <TCPIP_STACK_NetAddressBcast>
    e290:	6168      	str	r0, [r5, #20]
    e292:	e76f      	b.n	e174 <TCPIP_UDP_Flush+0x8c>
        udpLoadLen = pSkt->txWrite - pSkt->txStart;
    e294:	68ab      	ldr	r3, [r5, #8]
    e296:	682c      	ldr	r4, [r5, #0]
    e298:	1b1b      	subs	r3, r3, r4
    e29a:	b29c      	uxth	r4, r3
        rootLen = udpLoadLen + sizeof(UDP_HEADER); 
    e29c:	f104 0308 	add.w	r3, r4, #8
    e2a0:	b29b      	uxth	r3, r3
        pZSeg = 0;
    e2a2:	f04f 0900 	mov.w	r9, #0
    e2a6:	e778      	b.n	e19a <TCPIP_UDP_Flush+0xb2>
        checksum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)pUDPHdr, udpTotLen, checksum);
    e2a8:	4641      	mov	r1, r8
    e2aa:	4638      	mov	r0, r7
    e2ac:	f00c f99e 	bl	1a5ec <TCPIP_Helper_CalcIPChecksum>
    e2b0:	43c3      	mvns	r3, r0
    e2b2:	b29b      	uxth	r3, r3
    e2b4:	e7ae      	b.n	e214 <TCPIP_UDP_Flush+0x12c>
        pktParams.ttl = pSkt->ttl == 0 ? UDP_MULTICAST_DEFAULT_TTL : pSkt->ttl;
    e2b6:	f895 305b 	ldrb.w	r3, [r5, #91]	; 0x5b
    e2ba:	2b00      	cmp	r3, #0
    e2bc:	bf08      	it	eq
    e2be:	2301      	moveq	r3, #1
    e2c0:	f88d 3001 	strb.w	r3, [sp, #1]
    pktParams.tosFlags = pSkt->extFlags.tos;
    e2c4:	f895 3043 	ldrb.w	r3, [r5, #67]	; 0x43
    e2c8:	f3c3 0205 	ubfx	r2, r3, #0, #6
    e2cc:	f88d 2000 	strb.w	r2, [sp]
    pktParams.df = pSkt->extFlags.df;
    e2d0:	f3c3 1380 	ubfx	r3, r3, #6, #1
    e2d4:	f88d 3002 	strb.w	r3, [sp, #2]
    TCPIP_IPV4_PacketFormatTx(pv4Pkt, IP_PROT_UDP, udpTotLen, &pktParams);
    e2d8:	466b      	mov	r3, sp
    e2da:	4642      	mov	r2, r8
    e2dc:	2111      	movs	r1, #17
    e2de:	4630      	mov	r0, r6
    e2e0:	f005 f85e 	bl	133a0 <TCPIP_IPV4_PacketFormatTx>
    pv4Pkt->macPkt.next = 0;    // single packet
    e2e4:	2300      	movs	r3, #0
    e2e6:	6033      	str	r3, [r6, #0]
    if(isMcastDest && pSkt->extFlags.mcastLoop)
    e2e8:	f895 3042 	ldrb.w	r3, [r5, #66]	; 0x42
        pv4Pkt->macPkt.modPktData = 1;
    e2ec:	f3c3 0380 	ubfx	r3, r3, #2, #1
    e2f0:	e7ae      	b.n	e250 <TCPIP_UDP_Flush+0x168>
        return 0;
    e2f2:	2400      	movs	r4, #0
    e2f4:	e002      	b.n	e2fc <TCPIP_UDP_Flush+0x214>
            return 0;
    e2f6:	2400      	movs	r4, #0
                    return _UDPv4Flush(pSkt);
    e2f8:	e000      	b.n	e2fc <TCPIP_UDP_Flush+0x214>
    return 0;
    e2fa:	2400      	movs	r4, #0
}
    e2fc:	4620      	mov	r0, r4
    e2fe:	b005      	add	sp, #20
    e300:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return 0;
    e304:	2400      	movs	r4, #0
    e306:	e7f9      	b.n	e2fc <TCPIP_UDP_Flush+0x214>

Disassembly of section .text.TCPIP_IPV4_PktTx%222:

0000e308 <TCPIP_IPV4_PktTx>:
{
    e308:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    e30c:	b084      	sub	sp, #16
    if(isPersistent)
    e30e:	bb9a      	cbnz	r2, e378 <TCPIP_IPV4_PktTx+0x70>
        arpPkt = pMacPkt; 
    e310:	460f      	mov	r7, r1
        arpType = IPV4_ARP_PKT_TYPE_MAC;
    e312:	f04f 0802 	mov.w	r8, #2
    pNetIf = _TCPIPStackHandleToNet(pPkt->netIfH);
    e316:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
    if(pNetIf == 0)
    e318:	2b00      	cmp	r3, #0
    e31a:	f000 80e5 	beq.w	e4e8 <TCPIP_IPV4_PktTx+0x1e0>
    e31e:	460d      	mov	r5, r1
    e320:	4604      	mov	r4, r0
    if((pHostIf = TCPIP_STACK_MatchNetAddress(pNetIf, &pPkt->destAddress)))
    e322:	f100 0138 	add.w	r1, r0, #56	; 0x38
    e326:	4618      	mov	r0, r3
    e328:	f00e fe26 	bl	1cf78 <TCPIP_STACK_MatchNetAddress>
    e32c:	4606      	mov	r6, r0
    e32e:	b338      	cbz	r0, e380 <TCPIP_IPV4_PktTx+0x78>
        memcpy(pMacDst, _TCPIPStack_NetMACAddressGet(pHostIf), sizeof(*pMacDst));
    e330:	4603      	mov	r3, r0
    e332:	f853 0f3c 	ldr.w	r0, [r3, #60]!
    e336:	9002      	str	r0, [sp, #8]
    e338:	889b      	ldrh	r3, [r3, #4]
    e33a:	f8ad 300c 	strh.w	r3, [sp, #12]
        pPkt->netIfH = pHostIf;
    e33e:	63e6      	str	r6, [r4, #60]	; 0x3c
    pNetIf = TCPIP_IPV4_CheckPktTx(pPkt->netIfH, pMacPkt);
    e340:	4629      	mov	r1, r5
    e342:	4630      	mov	r0, r6
    e344:	f010 ff30 	bl	1f1a8 <TCPIP_IPV4_CheckPktTx>
    if(pNetIf == 0)
    e348:	4604      	mov	r4, r0
    e34a:	2800      	cmp	r0, #0
    e34c:	f000 80d0 	beq.w	e4f0 <TCPIP_IPV4_PktTx+0x1e8>
    pMacPkt->pktIf = pNetIf;
    e350:	62a8      	str	r0, [r5, #40]	; 0x28
    TCPIP_PKT_PacketMACFormat(pMacPkt, pMacDst, (const TCPIP_MAC_ADDR*)_TCPIPStack_NetMACAddressGet(pNetIf), TCPIP_ETHER_TYPE_IPV4);
    e352:	f44f 6300 	mov.w	r3, #2048	; 0x800
    e356:	f100 023c 	add.w	r2, r0, #60	; 0x3c
    e35a:	a902      	add	r1, sp, #8
    e35c:	4628      	mov	r0, r5
    e35e:	f010 fa2d 	bl	1e7bc <TCPIP_PKT_PacketMACFormat>
    pTxPkt->pktFlags |= flags;
    e362:	8c6b      	ldrh	r3, [r5, #34]	; 0x22
    e364:	f043 0310 	orr.w	r3, r3, #16
    e368:	846b      	strh	r3, [r5, #34]	; 0x22
    _TCPIPStackInsertRxPacket(pNetIf, pTxPkt, signal);
    e36a:	2201      	movs	r2, #1
    e36c:	4629      	mov	r1, r5
    e36e:	4620      	mov	r0, r4
    e370:	f00c fd3c 	bl	1adec <_TCPIPStackInsertRxPacket>
        return true;
    e374:	2001      	movs	r0, #1
    e376:	e0b8      	b.n	e4ea <TCPIP_IPV4_PktTx+0x1e2>
        arpPkt = pPkt;
    e378:	4607      	mov	r7, r0
        arpType = IPV4_ARP_PKT_TYPE_TX;
    e37a:	f04f 0801 	mov.w	r8, #1
    e37e:	e7ca      	b.n	e316 <TCPIP_IPV4_PktTx+0xe>
{
    TCPIP_ARP_RESULT  arpRes;
    TCPIP_MAC_ADDR*   pMacDst = *ppMacAdd;
    TCPIP_NET_IF* pNetIf = (TCPIP_NET_IF*)pPkt->netIfH;

    if(pIpAdd->Val == 0xffffffff || pIpAdd->Val == TCPIP_STACK_NetAddressBcast(pNetIf))
    e380:	f8d4 a038 	ldr.w	sl, [r4, #56]	; 0x38
    e384:	f1ba 3fff 	cmp.w	sl, #4294967295
    e388:	d028      	beq.n	e3dc <TCPIP_IPV4_PktTx+0xd4>
    TCPIP_NET_IF* pNetIf = (TCPIP_NET_IF*)pPkt->netIfH;
    e38a:	f8d4 903c 	ldr.w	r9, [r4, #60]	; 0x3c
    if(pIpAdd->Val == 0xffffffff || pIpAdd->Val == TCPIP_STACK_NetAddressBcast(pNetIf))
    e38e:	4648      	mov	r0, r9
    e390:	f012 fccc 	bl	20d2c <TCPIP_STACK_NetAddressBcast>
    e394:	4582      	cmp	sl, r0
    e396:	d021      	beq.n	e3dc <TCPIP_IPV4_PktTx+0xd4>
        return TCPIP_IPV4_DEST_NETWORK;
    }

    // check IP multicast address range from 224.0.0.0 to 239.255.255.255
    // can be done locally; No need for an ARP request.
    if ((pIpAdd->v[0] >= 224) && (pIpAdd->v[0] <= 239))
    e398:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
    e39c:	3320      	adds	r3, #32
    e39e:	b2db      	uxtb	r3, r3
    e3a0:	2b0f      	cmp	r3, #15
    e3a2:	d943      	bls.n	e42c <TCPIP_IPV4_PktTx+0x124>
    return ((pIf->netIPAddr.Val ^ pIpAddress->Val) & pIf->netMask.Val) == 0;
    e3a4:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    e3a6:	f8d9 3004 	ldr.w	r3, [r9, #4]
    e3aa:	4053      	eors	r3, r2
    e3ac:	f8d9 1008 	ldr.w	r1, [r9, #8]
        return TCPIP_IPV4_DEST_NETWORK;
    }

    TCPIP_IPV4_DEST_TYPE destType;

    if(_TCPIPStackIpAddFromLAN(pNetIf, pIpAdd))
    e3b0:	420b      	tst	r3, r1
        arpTarget->Val  = pIpAdd->Val;
        destType = TCPIP_IPV4_DEST_NETWORK;
    }
    else
    {   // not this LAN
        arpTarget->Val  = pNetIf->netGateway.Val;
    e3b2:	bf18      	it	ne
    e3b4:	f8d9 200c 	ldrne.w	r2, [r9, #12]
        destType = TCPIP_IPV4_DEST_GW;
    e3b8:	9201      	str	r2, [sp, #4]
    }

    arpRes = TCPIP_ARP_EntryGet(pNetIf, arpTarget, pMacDst, true);
    e3ba:	2301      	movs	r3, #1
    e3bc:	aa02      	add	r2, sp, #8
    e3be:	a901      	add	r1, sp, #4
    e3c0:	4648      	mov	r0, r9
    e3c2:	f00d f843 	bl	1b44c <TCPIP_ARP_EntryGet>
    if(arpRes == ARP_RES_ENTRY_SOLVED)
    e3c6:	2802      	cmp	r0, #2
    e3c8:	f000 8098 	beq.w	e4fc <TCPIP_IPV4_PktTx+0x1f4>
    {   // good to transmit
    }
    else if(arpRes == ARP_RES_ENTRY_QUEUED || arpRes == ARP_RES_ENTRY_NEW)
    e3cc:	f020 0002 	bic.w	r0, r0, #2
    e3d0:	b240      	sxtb	r0, r0
    e3d2:	2801      	cmp	r0, #1
            return false;
    e3d4:	bf18      	it	ne
    e3d6:	2000      	movne	r0, #0
    else if(arpRes == ARP_RES_ENTRY_QUEUED || arpRes == ARP_RES_ENTRY_NEW)
    e3d8:	d006      	beq.n	e3e8 <TCPIP_IPV4_PktTx+0xe0>
    e3da:	e086      	b.n	e4ea <TCPIP_IPV4_PktTx+0x1e2>
        memset(pMacDst, 0xff, sizeof(*pMacDst));
    e3dc:	f04f 33ff 	mov.w	r3, #4294967295
    e3e0:	9302      	str	r3, [sp, #8]
    e3e2:	f8ad 300c 	strh.w	r3, [sp, #12]
    pMacDst = &destMacAdd;
    e3e6:	ae02      	add	r6, sp, #8
    pNetIf = TCPIP_IPV4_CheckPktTx(pPkt->netIfH, pMacPkt);
    e3e8:	4629      	mov	r1, r5
    e3ea:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    e3ec:	f010 fedc 	bl	1f1a8 <TCPIP_IPV4_CheckPktTx>
    if(pNetIf == 0)
    e3f0:	4604      	mov	r4, r0
    e3f2:	2800      	cmp	r0, #0
    e3f4:	d07e      	beq.n	e4f4 <TCPIP_IPV4_PktTx+0x1ec>
    pMacPkt->pktIf = pNetIf;
    e3f6:	62a8      	str	r0, [r5, #40]	; 0x28
    TCPIP_PKT_PacketMACFormat(pMacPkt, pMacDst, (const TCPIP_MAC_ADDR*)_TCPIPStack_NetMACAddressGet(pNetIf), TCPIP_ETHER_TYPE_IPV4);
    e3f8:	f44f 6300 	mov.w	r3, #2048	; 0x800
    e3fc:	f100 023c 	add.w	r2, r0, #60	; 0x3c
    e400:	4631      	mov	r1, r6
    e402:	4628      	mov	r0, r5
    e404:	f010 f9da 	bl	1e7bc <TCPIP_PKT_PacketMACFormat>
        pktPayload = TCPIP_PKT_PayloadLen(pMacPkt) - sizeof(TCPIP_MAC_ETHERNET_HEADER);
    e408:	4628      	mov	r0, r5
    e40a:	f012 fcbc 	bl	20d86 <TCPIP_PKT_PayloadLen>
    e40e:	380e      	subs	r0, #14
        if(pktPayload > linkMtu)
    e410:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
    e414:	b280      	uxth	r0, r0
    e416:	4283      	cmp	r3, r0
    e418:	d36e      	bcc.n	e4f8 <TCPIP_IPV4_PktTx+0x1f0>
    if(pMacDst == 0)
    e41a:	b306      	cbz	r6, e45e <TCPIP_IPV4_PktTx+0x156>
    return _TCPIPStackPacketTx(pNetIf, pPkt) == TCPIP_MAC_RES_OK;
    e41c:	4629      	mov	r1, r5
    e41e:	4620      	mov	r0, r4
    e420:	f013 f9f0 	bl	21804 <_TCPIPStackPacketTx>
    e424:	fab0 f080 	clz	r0, r0
    e428:	0940      	lsrs	r0, r0, #5
    return txRes;
    e42a:	e05e      	b.n	e4ea <TCPIP_IPV4_PktTx+0x1e2>
        pMacDst->v[0] = 0x01;
    e42c:	2301      	movs	r3, #1
    e42e:	f88d 3008 	strb.w	r3, [sp, #8]
        pMacDst->v[1] = 0x00;
    e432:	2300      	movs	r3, #0
    e434:	f88d 3009 	strb.w	r3, [sp, #9]
        pMacDst->v[2] = 0x5E;
    e438:	235e      	movs	r3, #94	; 0x5e
    e43a:	f88d 300a 	strb.w	r3, [sp, #10]
        pMacDst->v[3] = 0x7f & pIpAdd->v[1];
    e43e:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
    e442:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    e446:	f88d 300b 	strb.w	r3, [sp, #11]
        pMacDst->v[4] = pIpAdd->v[2];
    e44a:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
    e44e:	f88d 300c 	strb.w	r3, [sp, #12]
        pMacDst->v[5] = pIpAdd->v[3];
    e452:	f894 303b 	ldrb.w	r3, [r4, #59]	; 0x3b
    e456:	f88d 300d 	strb.w	r3, [sp, #13]
    pMacDst = &destMacAdd;
    e45a:	ae02      	add	r6, sp, #8
    e45c:	e7c4      	b.n	e3e8 <TCPIP_IPV4_PktTx+0xe0>
        if(ipv4ArpHandle == 0)
    e45e:	4b28      	ldr	r3, [pc, #160]	; (e500 <TCPIP_IPV4_PktTx+0x1f8>)
    e460:	681b      	ldr	r3, [r3, #0]
    e462:	b1e3      	cbz	r3, e49e <TCPIP_IPV4_PktTx+0x196>
    return pIf->netIfIx;
    e464:	f8b4 4058 	ldrh.w	r4, [r4, #88]	; 0x58
    TCPIP_Helper_ProtectedSingleListLock(pList);
    e468:	4826      	ldr	r0, [pc, #152]	; (e504 <TCPIP_IPV4_PktTx+0x1fc>)
    e46a:	f012 fb21 	bl	20ab0 <TCPIP_Helper_ProtectedSingleListLock>
    IPV4_ARP_ENTRY* pEntry = (IPV4_ARP_ENTRY*)TCPIP_Helper_SingleListHeadRemove(&ipv4ArpPool);
    e46e:	4826      	ldr	r0, [pc, #152]	; (e508 <TCPIP_IPV4_PktTx+0x200>)
    e470:	f012 fd52 	bl	20f18 <TCPIP_Helper_SingleListHeadRemove>
    if(pEntry == 0)
    e474:	4601      	mov	r1, r0
    e476:	b340      	cbz	r0, e4ca <TCPIP_IPV4_PktTx+0x1c2>
    pEntry->type = (uint8_t)type;
    e478:	f880 8004 	strb.w	r8, [r0, #4]
    pEntry->arpIfIx = (uint8_t)arpIfIx;
    e47c:	7144      	strb	r4, [r0, #5]
    pEntry->pPkt = pPkt;     
    e47e:	6087      	str	r7, [r0, #8]
    pEntry->arpTarget.Val = arpTarget->Val;
    e480:	9b01      	ldr	r3, [sp, #4]
    e482:	60c3      	str	r3, [r0, #12]
    TCPIP_Helper_SingleListTailAdd(&pList->list, (SGL_LIST_NODE*)pEntry);
    e484:	4c1f      	ldr	r4, [pc, #124]	; (e504 <TCPIP_IPV4_PktTx+0x1fc>)
    e486:	4620      	mov	r0, r4
    e488:	f012 ff1a 	bl	212c0 <TCPIP_Helper_SingleListTailAdd>
    TCPIP_Helper_ProtectedSingleListUnlock(pList);
    e48c:	4620      	mov	r0, r4
    e48e:	f012 fd51 	bl	20f34 <TCPIP_Helper_ProtectedSingleListUnlock>
       pMacPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_QUEUED;
    e492:	8c6b      	ldrh	r3, [r5, #34]	; 0x22
    e494:	f043 0308 	orr.w	r3, r3, #8
    e498:	846b      	strh	r3, [r5, #34]	; 0x22
        return true;
    e49a:	2001      	movs	r0, #1
    e49c:	e025      	b.n	e4ea <TCPIP_IPV4_PktTx+0x1e2>
            if((ipv4ArpHandle = TCPIP_ARP_HandlerRegister(0, TCPIP_IPV4_ArpHandler, 0)) == 0)
    e49e:	2200      	movs	r2, #0
    e4a0:	491a      	ldr	r1, [pc, #104]	; (e50c <TCPIP_IPV4_PktTx+0x204>)
    e4a2:	4610      	mov	r0, r2
    e4a4:	f010 fb22 	bl	1eaec <TCPIP_ARP_HandlerRegister>
    e4a8:	4b15      	ldr	r3, [pc, #84]	; (e500 <TCPIP_IPV4_PktTx+0x1f8>)
    e4aa:	6018      	str	r0, [r3, #0]
    e4ac:	2800      	cmp	r0, #0
    e4ae:	d1d9      	bne.n	e464 <TCPIP_IPV4_PktTx+0x15c>
                SYS_ERROR(SYS_ERROR_WARNING, "IPv4: Failed to register ARP notification! \r\n");
    e4b0:	f013 fdce 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
    e4b4:	2801      	cmp	r0, #1
    e4b6:	d801      	bhi.n	e4bc <TCPIP_IPV4_PktTx+0x1b4>
                return false;
    e4b8:	2000      	movs	r0, #0
    e4ba:	e016      	b.n	e4ea <TCPIP_IPV4_PktTx+0x1e2>
                SYS_ERROR(SYS_ERROR_WARNING, "IPv4: Failed to register ARP notification! \r\n");
    e4bc:	f013 fdc2 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
    e4c0:	4913      	ldr	r1, [pc, #76]	; (e510 <TCPIP_IPV4_PktTx+0x208>)
    e4c2:	f00c faeb 	bl	1aa9c <SYS_CONSOLE_Print>
                return false;
    e4c6:	2000      	movs	r0, #0
    e4c8:	e00f      	b.n	e4ea <TCPIP_IPV4_PktTx+0x1e2>
        SYS_ERROR(SYS_ERROR_WARNING, "IPv4: ARP entries pool empty!\r\n");
    e4ca:	f013 fdc1 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
    e4ce:	2801      	cmp	r0, #1
    e4d0:	d804      	bhi.n	e4dc <TCPIP_IPV4_PktTx+0x1d4>
        TCPIP_Helper_ProtectedSingleListUnlock(pList);
    e4d2:	480c      	ldr	r0, [pc, #48]	; (e504 <TCPIP_IPV4_PktTx+0x1fc>)
    e4d4:	f012 fd2e 	bl	20f34 <TCPIP_Helper_ProtectedSingleListUnlock>
            return false;
    e4d8:	2000      	movs	r0, #0
    e4da:	e006      	b.n	e4ea <TCPIP_IPV4_PktTx+0x1e2>
        SYS_ERROR(SYS_ERROR_WARNING, "IPv4: ARP entries pool empty!\r\n");
    e4dc:	f013 fdb2 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
    e4e0:	490c      	ldr	r1, [pc, #48]	; (e514 <TCPIP_IPV4_PktTx+0x20c>)
    e4e2:	f00c fadb 	bl	1aa9c <SYS_CONSOLE_Print>
    e4e6:	e7f4      	b.n	e4d2 <TCPIP_IPV4_PktTx+0x1ca>
        return false;
    e4e8:	2000      	movs	r0, #0
}
    e4ea:	b004      	add	sp, #16
    e4ec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return false;
    e4f0:	2000      	movs	r0, #0
    e4f2:	e7fa      	b.n	e4ea <TCPIP_IPV4_PktTx+0x1e2>
    e4f4:	2000      	movs	r0, #0
    e4f6:	e7f8      	b.n	e4ea <TCPIP_IPV4_PktTx+0x1e2>
            return false;
    e4f8:	2000      	movs	r0, #0
    e4fa:	e7f6      	b.n	e4ea <TCPIP_IPV4_PktTx+0x1e2>
    pMacDst = &destMacAdd;
    e4fc:	ae02      	add	r6, sp, #8
    e4fe:	e773      	b.n	e3e8 <TCPIP_IPV4_PktTx+0xe0>
    e500:	2000e3fc 	.word	0x2000e3fc
    e504:	2000e228 	.word	0x2000e228
    e508:	2000e328 	.word	0x2000e328
    e50c:	00016939 	.word	0x00016939
    e510:	00019c90 	.word	0x00019c90
    e514:	00019cc0 	.word	0x00019cc0

Disassembly of section .text._Command_NetInfo%223:

0000e518 <_Command_NetInfo>:
{
    e518:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e51c:	b089      	sub	sp, #36	; 0x24
    e51e:	4606      	mov	r6, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
    e520:	6847      	ldr	r7, [r0, #4]
    if (argc > 2)
    e522:	2902      	cmp	r1, #2
    e524:	dc11      	bgt.n	e54a <_Command_NetInfo+0x32>
    for (i=0; i<initialNetIfs; i++)
    e526:	4b7c      	ldr	r3, [pc, #496]	; (e718 <_Command_NetInfo+0x200>)
    e528:	681b      	ldr	r3, [r3, #0]
    e52a:	2b00      	cmp	r3, #0
    return true;
    e52c:	bfd8      	it	le
    e52e:	2001      	movle	r0, #1
    for (i=0; i<initialNetIfs; i++)
    e530:	f340 80a5 	ble.w	e67e <_Command_NetInfo+0x166>
    e534:	f04f 0800 	mov.w	r8, #0
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "---------- Interface <%s/%s> ---------- \r\n", addrBuff, TCPIP_STACK_NetNameGet(netH));
    e538:	4d78      	ldr	r5, [pc, #480]	; (e71c <_Command_NetInfo+0x204>)
    e53a:	f505 7a82 	add.w	sl, r5, #260	; 0x104
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "dhcp is %s\r\n", TCPIP_DHCP_IsEnabled(netH) ? "enabled" : "disabled");
    e53e:	f8df b1e0 	ldr.w	fp, [pc, #480]	; e720 <_Command_NetInfo+0x208>
    e542:	f50b 73e4 	add.w	r3, fp, #456	; 0x1c8
    e546:	9301      	str	r3, [sp, #4]
    e548:	e0c6      	b.n	e6d8 <_Command_NetInfo+0x1c0>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: netinfo\r\n");
    e54a:	4c74      	ldr	r4, [pc, #464]	; (e71c <_Command_NetInfo+0x204>)
    e54c:	6803      	ldr	r3, [r0, #0]
    e54e:	681b      	ldr	r3, [r3, #0]
    e550:	f104 01e0 	add.w	r1, r4, #224	; 0xe0
    e554:	4638      	mov	r0, r7
    e556:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: netinfo\r\n");
    e558:	6833      	ldr	r3, [r6, #0]
    e55a:	681b      	ldr	r3, [r3, #0]
    e55c:	f104 01f4 	add.w	r1, r4, #244	; 0xf4
    e560:	4638      	mov	r0, r7
    e562:	4798      	blx	r3
        return false;
    e564:	2000      	movs	r0, #0
    e566:	e08a      	b.n	e67e <_Command_NetInfo+0x166>
        hostName = TCPIP_STACK_NetBIOSName(netH); 
    e568:	4620      	mov	r0, r4
    e56a:	f013 fe5c 	bl	22226 <TCPIP_STACK_NetBIOSName>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Host Name: %s - NBNS disabled \r\n", hostName);
    e56e:	6833      	ldr	r3, [r6, #0]
    e570:	685b      	ldr	r3, [r3, #4]
    e572:	4602      	mov	r2, r0
    e574:	f505 71a2 	add.w	r1, r5, #324	; 0x144
    e578:	4638      	mov	r0, r7
    e57a:	4798      	blx	r3
        ipAddr.Val = TCPIP_STACK_NetAddress(netH);
    e57c:	4620      	mov	r0, r4
    e57e:	f012 fbe4 	bl	20d4a <TCPIP_STACK_NetAddress>
    e582:	9007      	str	r0, [sp, #28]
        TCPIP_Helper_IPAddressToString(&ipAddr, addrBuff, sizeof(addrBuff));
    e584:	2214      	movs	r2, #20
    e586:	a902      	add	r1, sp, #8
    e588:	a807      	add	r0, sp, #28
    e58a:	f00e fa83 	bl	1ca94 <TCPIP_Helper_IPAddressToString>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv4 Address: %s\r\n", addrBuff);
    e58e:	6833      	ldr	r3, [r6, #0]
    e590:	685b      	ldr	r3, [r3, #4]
    e592:	aa02      	add	r2, sp, #8
    e594:	f505 71b4 	add.w	r1, r5, #360	; 0x168
    e598:	4638      	mov	r0, r7
    e59a:	4798      	blx	r3
        ipAddr.Val = TCPIP_STACK_NetMask(netH);
    e59c:	4620      	mov	r0, r4
    e59e:	f012 fd2b 	bl	20ff8 <TCPIP_STACK_NetMask>
    e5a2:	9007      	str	r0, [sp, #28]
        TCPIP_Helper_IPAddressToString(&ipAddr, addrBuff, sizeof(addrBuff));
    e5a4:	2214      	movs	r2, #20
    e5a6:	a902      	add	r1, sp, #8
    e5a8:	a807      	add	r0, sp, #28
    e5aa:	f00e fa73 	bl	1ca94 <TCPIP_Helper_IPAddressToString>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Mask: %s\r\n", addrBuff);
    e5ae:	6833      	ldr	r3, [r6, #0]
    e5b0:	685b      	ldr	r3, [r3, #4]
    e5b2:	aa02      	add	r2, sp, #8
    e5b4:	f505 71be 	add.w	r1, r5, #380	; 0x17c
    e5b8:	4638      	mov	r0, r7
    e5ba:	4798      	blx	r3
        ipAddr.Val = TCPIP_STACK_NetAddressGateway(netH);
    e5bc:	4620      	mov	r0, r4
    e5be:	f012 ffb5 	bl	2152c <TCPIP_STACK_NetAddressGateway>
    e5c2:	9007      	str	r0, [sp, #28]
        TCPIP_Helper_IPAddressToString(&ipAddr, addrBuff, sizeof(addrBuff));
    e5c4:	2214      	movs	r2, #20
    e5c6:	a902      	add	r1, sp, #8
    e5c8:	a807      	add	r0, sp, #28
    e5ca:	f00e fa63 	bl	1ca94 <TCPIP_Helper_IPAddressToString>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Gateway: %s\r\n", addrBuff);
    e5ce:	6833      	ldr	r3, [r6, #0]
    e5d0:	685b      	ldr	r3, [r3, #4]
    e5d2:	aa02      	add	r2, sp, #8
    e5d4:	f505 71c4 	add.w	r1, r5, #392	; 0x188
    e5d8:	4638      	mov	r0, r7
    e5da:	4798      	blx	r3
        ipAddr.Val = TCPIP_STACK_NetAddressDnsPrimary(netH);
    e5dc:	4620      	mov	r0, r4
    e5de:	f012 ffb1 	bl	21544 <TCPIP_STACK_NetAddressDnsPrimary>
    e5e2:	9007      	str	r0, [sp, #28]
        TCPIP_Helper_IPAddressToString(&ipAddr, addrBuff, sizeof(addrBuff));
    e5e4:	2214      	movs	r2, #20
    e5e6:	a902      	add	r1, sp, #8
    e5e8:	a807      	add	r0, sp, #28
    e5ea:	f00e fa53 	bl	1ca94 <TCPIP_Helper_IPAddressToString>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "DNS1: %s\r\n", addrBuff);
    e5ee:	6833      	ldr	r3, [r6, #0]
    e5f0:	685b      	ldr	r3, [r3, #4]
    e5f2:	aa02      	add	r2, sp, #8
    e5f4:	f505 71cc 	add.w	r1, r5, #408	; 0x198
    e5f8:	4638      	mov	r0, r7
    e5fa:	4798      	blx	r3
        ipAddr.Val = TCPIP_STACK_NetAddressDnsSecond(netH);
    e5fc:	4620      	mov	r0, r4
    e5fe:	f012 ffad 	bl	2155c <TCPIP_STACK_NetAddressDnsSecond>
    e602:	9007      	str	r0, [sp, #28]
        TCPIP_Helper_IPAddressToString(&ipAddr, addrBuff, sizeof(addrBuff));
    e604:	2214      	movs	r2, #20
    e606:	a902      	add	r1, sp, #8
    e608:	a807      	add	r0, sp, #28
    e60a:	f00e fa43 	bl	1ca94 <TCPIP_Helper_IPAddressToString>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "DNS2: %s\r\n", addrBuff);
    e60e:	6833      	ldr	r3, [r6, #0]
    e610:	685b      	ldr	r3, [r3, #4]
    e612:	aa02      	add	r2, sp, #8
    e614:	f505 71d2 	add.w	r1, r5, #420	; 0x1a4
    e618:	4638      	mov	r0, r7
    e61a:	4798      	blx	r3
        pMac = (const TCPIP_MAC_ADDR*)TCPIP_STACK_NetAddressMac(netH);
    e61c:	4620      	mov	r0, r4
    e61e:	f013 fdaa 	bl	22176 <TCPIP_STACK_NetAddressMac>
        TCPIP_Helper_MACAddressToString(pMac, addrBuff, sizeof(addrBuff));
    e622:	2214      	movs	r2, #20
    e624:	a902      	add	r1, sp, #8
    e626:	f00e ffaf 	bl	1d588 <TCPIP_Helper_MACAddressToString>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "MAC Address: %s\r\n", addrBuff);
    e62a:	6833      	ldr	r3, [r6, #0]
    e62c:	685b      	ldr	r3, [r3, #4]
    e62e:	aa02      	add	r2, sp, #8
    e630:	f505 71d8 	add.w	r1, r5, #432	; 0x1b0
    e634:	4638      	mov	r0, r7
    e636:	4798      	blx	r3
        if(TCPIP_DHCP_IsActive(netH))
    e638:	4620      	mov	r0, r4
    e63a:	f011 fc53 	bl	1fee4 <TCPIP_DHCP_IsActive>
    e63e:	bb08      	cbnz	r0, e684 <_Command_NetInfo+0x16c>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "%s is ON\r\n", msgAdd);
    e640:	6833      	ldr	r3, [r6, #0]
    e642:	685b      	ldr	r3, [r3, #4]
    e644:	f505 72fa 	add.w	r2, r5, #500	; 0x1f4
    e648:	f505 7102 	add.w	r1, r5, #520	; 0x208
    e64c:	4638      	mov	r0, r7
    e64e:	4798      	blx	r3
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "dhcp is %s\r\n", TCPIP_DHCP_IsEnabled(netH) ? "enabled" : "disabled");
    e650:	6833      	ldr	r3, [r6, #0]
    e652:	f8d3 9004 	ldr.w	r9, [r3, #4]
    e656:	4620      	mov	r0, r4
    e658:	f00f fd9a 	bl	1e190 <TCPIP_DHCP_IsEnabled>
    e65c:	b930      	cbnz	r0, e66c <_Command_NetInfo+0x154>
    e65e:	f50b 72da 	add.w	r2, fp, #436	; 0x1b4
    e662:	f505 71e2 	add.w	r1, r5, #452	; 0x1c4
    e666:	4638      	mov	r0, r7
    e668:	47c8      	blx	r9
    e66a:	e013      	b.n	e694 <_Command_NetInfo+0x17c>
    e66c:	9a01      	ldr	r2, [sp, #4]
    e66e:	e7f8      	b.n	e662 <_Command_NetInfo+0x14a>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Link is %s\r\n", TCPIP_STACK_NetIsLinked(netH) ? "UP" : "DOWN");
    e670:	f105 02c0 	add.w	r2, r5, #192	; 0xc0
    e674:	e018      	b.n	e6a8 <_Command_NetInfo+0x190>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Status: %s\r\n", TCPIP_STACK_NetIsReady(netH) ? "Ready" : "Not Ready");
    e676:	f105 02cc 	add.w	r2, r5, #204	; 0xcc
    e67a:	e023      	b.n	e6c4 <_Command_NetInfo+0x1ac>
    return true;
    e67c:	2001      	movs	r0, #1
}
    e67e:	b009      	add	sp, #36	; 0x24
    e680:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "%s is ON\r\n", msgAdd);
    e684:	6833      	ldr	r3, [r6, #0]
    e686:	685b      	ldr	r3, [r3, #4]
    e688:	f505 7205 	add.w	r2, r5, #532	; 0x214
    e68c:	f505 7102 	add.w	r1, r5, #520	; 0x208
    e690:	4638      	mov	r0, r7
    e692:	4798      	blx	r3
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Link is %s\r\n", TCPIP_STACK_NetIsLinked(netH) ? "UP" : "DOWN");
    e694:	6833      	ldr	r3, [r6, #0]
    e696:	f8d3 9004 	ldr.w	r9, [r3, #4]
    e69a:	4620      	mov	r0, r4
    e69c:	f012 fcba 	bl	21014 <TCPIP_STACK_NetIsLinked>
    e6a0:	2800      	cmp	r0, #0
    e6a2:	d1e5      	bne.n	e670 <_Command_NetInfo+0x158>
    e6a4:	f105 02c4 	add.w	r2, r5, #196	; 0xc4
    e6a8:	f505 71ea 	add.w	r1, r5, #468	; 0x1d4
    e6ac:	4638      	mov	r0, r7
    e6ae:	47c8      	blx	r9
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Status: %s\r\n", TCPIP_STACK_NetIsReady(netH) ? "Ready" : "Not Ready");
    e6b0:	6833      	ldr	r3, [r6, #0]
    e6b2:	f8d3 9004 	ldr.w	r9, [r3, #4]
    e6b6:	4620      	mov	r0, r4
    e6b8:	f012 fe1c 	bl	212f4 <TCPIP_STACK_NetIsReady>
    e6bc:	2800      	cmp	r0, #0
    e6be:	d1da      	bne.n	e676 <_Command_NetInfo+0x15e>
    e6c0:	f105 02d4 	add.w	r2, r5, #212	; 0xd4
    e6c4:	f505 71f2 	add.w	r1, r5, #484	; 0x1e4
    e6c8:	4638      	mov	r0, r7
    e6ca:	47c8      	blx	r9
    for (i=0; i<initialNetIfs; i++)
    e6cc:	f108 0801 	add.w	r8, r8, #1
    e6d0:	4b11      	ldr	r3, [pc, #68]	; (e718 <_Command_NetInfo+0x200>)
    e6d2:	681b      	ldr	r3, [r3, #0]
    e6d4:	4543      	cmp	r3, r8
    e6d6:	ddd1      	ble.n	e67c <_Command_NetInfo+0x164>
        netH = TCPIP_STACK_IndexToNet(i);
    e6d8:	4640      	mov	r0, r8
    e6da:	f011 fc3f 	bl	1ff5c <TCPIP_STACK_IndexToNet>
    e6de:	4604      	mov	r4, r0
        TCPIP_STACK_NetAliasNameGet(netH, addrBuff, sizeof(addrBuff));
    e6e0:	2214      	movs	r2, #20
    e6e2:	a902      	add	r1, sp, #8
    e6e4:	f00f ff88 	bl	1e5f8 <TCPIP_STACK_NetAliasNameGet>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "---------- Interface <%s/%s> ---------- \r\n", addrBuff, TCPIP_STACK_NetNameGet(netH));
    e6e8:	6833      	ldr	r3, [r6, #0]
    e6ea:	f8d3 9004 	ldr.w	r9, [r3, #4]
    e6ee:	4620      	mov	r0, r4
    e6f0:	f013 fd19 	bl	22126 <TCPIP_STACK_NetNameGet>
    e6f4:	4603      	mov	r3, r0
    e6f6:	aa02      	add	r2, sp, #8
    e6f8:	4651      	mov	r1, sl
    e6fa:	4638      	mov	r0, r7
    e6fc:	47c8      	blx	r9
        if(!TCPIP_STACK_NetIsUp(netH))
    e6fe:	4620      	mov	r0, r4
    e700:	f012 fc6c 	bl	20fdc <TCPIP_STACK_NetIsUp>
    e704:	2800      	cmp	r0, #0
    e706:	f47f af2f 	bne.w	e568 <_Command_NetInfo+0x50>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Interface is down\r\n");
    e70a:	6833      	ldr	r3, [r6, #0]
    e70c:	681b      	ldr	r3, [r3, #0]
    e70e:	f505 7198 	add.w	r1, r5, #304	; 0x130
    e712:	4638      	mov	r0, r7
    e714:	4798      	blx	r3
            continue;
    e716:	e7d9      	b.n	e6cc <_Command_NetInfo+0x1b4>
    e718:	2000e3d8 	.word	0x2000e3d8
    e71c:	00001384 	.word	0x00001384
    e720:	0000028c 	.word	0x0000028c

Disassembly of section .text.TCPIP_DNS_ClientInitialize%224:

0000e724 <TCPIP_DNS_ClientInitialize>:
{
    e724:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(stackData->stackAction == TCPIP_STACK_ACTION_IF_UP)
    e728:	7f03      	ldrb	r3, [r0, #28]
    e72a:	2b03      	cmp	r3, #3
    e72c:	d013      	beq.n	e756 <TCPIP_DNS_ClientInitialize+0x32>
    e72e:	4682      	mov	sl, r0
    e730:	4689      	mov	r9, r1
    if(dnsInitCount == 0)
    e732:	4b76      	ldr	r3, [pc, #472]	; (e90c <TCPIP_DNS_ClientInitialize+0x1e8>)
    e734:	681d      	ldr	r5, [r3, #0]
    e736:	b1e5      	cbz	r5, e772 <TCPIP_DNS_ClientInitialize+0x4e>
    if(stackData->pNetIf->Flags.bIsDnsClientEnabled != 0)
    e738:	f8da 0014 	ldr.w	r0, [sl, #20]
    e73c:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
    e740:	f013 0f08 	tst.w	r3, #8
    e744:	f040 80d5 	bne.w	e8f2 <TCPIP_DNS_ClientInitialize+0x1ce>
    dnsInitCount++;
    e748:	4a70      	ldr	r2, [pc, #448]	; (e90c <TCPIP_DNS_ClientInitialize+0x1e8>)
    e74a:	6813      	ldr	r3, [r2, #0]
    e74c:	3301      	adds	r3, #1
    e74e:	6013      	str	r3, [r2, #0]
    return true;
    e750:	2001      	movs	r0, #1
}
    e752:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(stackData->pNetIf->Flags.bIsDnsClientEnabled != 0)
    e756:	6940      	ldr	r0, [r0, #20]
    e758:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
    e75c:	f013 0f08 	tst.w	r3, #8
    e760:	d101      	bne.n	e766 <TCPIP_DNS_ClientInitialize+0x42>
        return true;
    e762:	2001      	movs	r0, #1
    e764:	e7f5      	b.n	e752 <TCPIP_DNS_ClientInitialize+0x2e>
            _DNS_Enable(stackData->pNetIf, false, TCPIP_DNS_ENABLE_DEFAULT);
    e766:	2200      	movs	r2, #0
    e768:	4611      	mov	r1, r2
    e76a:	f00d fb2b 	bl	1bdc4 <_DNS_Enable>
        return true;
    e76e:	2001      	movs	r0, #1
    e770:	e7ef      	b.n	e752 <TCPIP_DNS_ClientInitialize+0x2e>
        memset(pDnsDcpt, 0, sizeof(*pDnsDcpt));
    e772:	2228      	movs	r2, #40	; 0x28
    e774:	2100      	movs	r1, #0
    e776:	4866      	ldr	r0, [pc, #408]	; (e910 <TCPIP_DNS_ClientInitialize+0x1ec>)
    e778:	f013 fa88 	bl	21c8c <memset>
        if(dnsData == 0 || TCPIP_DNS_CLIENT_MAX_HOSTNAME_LEN == 0)
    e77c:	f1b9 0f00 	cmp.w	r9, #0
    e780:	f000 80bc 	beq.w	e8fc <TCPIP_DNS_ClientInitialize+0x1d8>
        pDnsDcpt->memH = stackData->memH;
    e784:	f8da 000c 	ldr.w	r0, [sl, #12]
    e788:	4b61      	ldr	r3, [pc, #388]	; (e910 <TCPIP_DNS_ClientInitialize+0x1ec>)
    e78a:	6118      	str	r0, [r3, #16]
        hashMemSize = sizeof(OA_HASH_DCPT) + dnsData->cacheEntries * sizeof(TCPIP_DNS_HASH_ENTRY);
    e78c:	f8d9 3004 	ldr.w	r3, [r9, #4]
    e790:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    e794:	011c      	lsls	r4, r3, #4
    e796:	3428      	adds	r4, #40	; 0x28
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
    e798:	6843      	ldr	r3, [r0, #4]
    e79a:	4621      	mov	r1, r4
    e79c:	4798      	blx	r3
        if(hashDcpt == 0)
    e79e:	4680      	mov	r8, r0
    e7a0:	2800      	cmp	r0, #0
    e7a2:	f000 80ad 	beq.w	e900 <TCPIP_DNS_ClientInitialize+0x1dc>
        memset(hashDcpt, 0, hashMemSize);
    e7a6:	4622      	mov	r2, r4
    e7a8:	2100      	movs	r1, #0
    e7aa:	f013 fa6f 	bl	21c8c <memset>
        hashDcpt->memBlk = hashDcpt + 1;
    e7ae:	f108 0328 	add.w	r3, r8, #40	; 0x28
    e7b2:	f8c8 3000 	str.w	r3, [r8]
        hashDcpt->hParam = hashDcpt;    // store the descriptor it belongs to
    e7b6:	f8c8 8004 	str.w	r8, [r8, #4]
        hashDcpt->hEntrySize = sizeof(TCPIP_DNS_HASH_ENTRY);
    e7ba:	2330      	movs	r3, #48	; 0x30
    e7bc:	f8c8 3008 	str.w	r3, [r8, #8]
        hashDcpt->hEntries = dnsData->cacheEntries;
    e7c0:	f8d9 3004 	ldr.w	r3, [r9, #4]
    e7c4:	f8c8 300c 	str.w	r3, [r8, #12]
        hashDcpt->probeStep = TCPIP_DNS_HASH_PROBE_STEP;
    e7c8:	2401      	movs	r4, #1
    e7ca:	f8c8 4010 	str.w	r4, [r8, #16]
        hashDcpt->hashF = TCPIP_DNS_OAHASH_KeyHash;
    e7ce:	4b51      	ldr	r3, [pc, #324]	; (e914 <TCPIP_DNS_ClientInitialize+0x1f0>)
    e7d0:	f8c8 3014 	str.w	r3, [r8, #20]
        hashDcpt->delF = TCPIP_DNS_OAHASH_DeleteEntry;
    e7d4:	4b50      	ldr	r3, [pc, #320]	; (e918 <TCPIP_DNS_ClientInitialize+0x1f4>)
    e7d6:	f8c8 3018 	str.w	r3, [r8, #24]
        hashDcpt->cmpF = TCPIP_DNS_OAHASH_KeyCompare;
    e7da:	4b50      	ldr	r3, [pc, #320]	; (e91c <TCPIP_DNS_ClientInitialize+0x1f8>)
    e7dc:	f8c8 301c 	str.w	r3, [r8, #28]
        hashDcpt->cpyF = TCPIP_DNS_OAHASH_KeyCopy;
    e7e0:	4b4f      	ldr	r3, [pc, #316]	; (e920 <TCPIP_DNS_ClientInitialize+0x1fc>)
    e7e2:	f8c8 3020 	str.w	r3, [r8, #32]
        TCPIP_OAHASH_Initialize(hashDcpt);
    e7e6:	4640      	mov	r0, r8
    e7e8:	f011 fd81 	bl	202ee <TCPIP_OAHASH_Initialize>
        pDnsDcpt->hashDcpt = hashDcpt;
    e7ec:	4a48      	ldr	r2, [pc, #288]	; (e910 <TCPIP_DNS_ClientInitialize+0x1ec>)
    e7ee:	f8c2 8000 	str.w	r8, [r2]
        pDnsDcpt->dnsSocket =  INVALID_UDP_SOCKET;
    e7f2:	f64f 73ff 	movw	r3, #65535	; 0xffff
    e7f6:	8493      	strh	r3, [r2, #36]	; 0x24
        pDnsDcpt->cacheEntryTMO = dnsData->entrySolvedTmo;
    e7f8:	f8d9 3008 	ldr.w	r3, [r9, #8]
    e7fc:	6153      	str	r3, [r2, #20]
        pDnsDcpt->nIPv4Entries= dnsData->nIPv4Entries;
    e7fe:	f8d9 300c 	ldr.w	r3, [r9, #12]
    e802:	8413      	strh	r3, [r2, #32]
        pDnsDcpt->nIPv6Entries = dnsData->nIPv6Entries;
    e804:	f8d9 1014 	ldr.w	r1, [r9, #20]
    e808:	8451      	strh	r1, [r2, #34]	; 0x22
        pDnsDcpt->ipAddressType = IP_ADDRESS_TYPE_IPV4;     // dnsData->ipAddressType;
    e80a:	7614      	strb	r4, [r2, #24]
            + pDnsDcpt->nIPv6Entries * sizeof(IPV6_ADDR)
    e80c:	b289      	uxth	r1, r1
        memoryBlockSize = pDnsDcpt->nIPv4Entries * sizeof(IPV4_ADDR)
    e80e:	fa1f fb83 	uxth.w	fp, r3
            + TCPIP_DNS_CLIENT_MAX_HOSTNAME_LEN ;
    e812:	f10b 0b10 	add.w	fp, fp, #16
    e816:	eb0b 0b81 	add.w	fp, fp, r1, lsl #2
        memoryBlockSize = pDnsDcpt->nIPv4Entries * sizeof(IPV4_ADDR)
    e81a:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
        for(hashCnt = 0; hashCnt < dnsData->cacheEntries; hashCnt++)
    e81e:	f8d9 3004 	ldr.w	r3, [r9, #4]
    e822:	2b00      	cmp	r3, #0
    e824:	dd2a      	ble.n	e87c <TCPIP_DNS_ClientInitialize+0x158>
            pMemoryBlock = (uint8_t *)TCPIP_HEAP_Malloc(pDnsDcpt->memH, memoryBlockSize);
    e826:	4616      	mov	r6, r2
            pE->pHostName = 0;
    e828:	2700      	movs	r7, #0
    e82a:	e00a      	b.n	e842 <TCPIP_DNS_ClientInitialize+0x11e>
                _DNS_DeleteHash(pDnsDcpt);
    e82c:	4838      	ldr	r0, [pc, #224]	; (e910 <TCPIP_DNS_ClientInitialize+0x1ec>)
    e82e:	f00d fccb 	bl	1c1c8 <_DNS_DeleteHash>
                return false;
    e832:	2000      	movs	r0, #0
    e834:	e78d      	b.n	e752 <TCPIP_DNS_ClientInitialize+0x2e>
            pE->pHostName = (char*)pMemoryBlock;
    e836:	6220      	str	r0, [r4, #32]
        for(hashCnt = 0; hashCnt < dnsData->cacheEntries; hashCnt++)
    e838:	3501      	adds	r5, #1
    e83a:	f8d9 3004 	ldr.w	r3, [r9, #4]
    e83e:	42ab      	cmp	r3, r5
    e840:	dd1c      	ble.n	e87c <TCPIP_DNS_ClientInitialize+0x158>
            pBkt = TCPIP_OAHASH_EntryGet(hashDcpt, hashCnt);
    e842:	4629      	mov	r1, r5
    e844:	4640      	mov	r0, r8
    e846:	f013 f918 	bl	21a7a <TCPIP_OAHASH_EntryGet>
    e84a:	4604      	mov	r4, r0
            pMemoryBlock = (uint8_t *)TCPIP_HEAP_Malloc(pDnsDcpt->memH, memoryBlockSize);
    e84c:	6930      	ldr	r0, [r6, #16]
    e84e:	6843      	ldr	r3, [r0, #4]
    e850:	4659      	mov	r1, fp
    e852:	4798      	blx	r3
            if((pE->memblk = pMemoryBlock) == 0)
    e854:	6060      	str	r0, [r4, #4]
    e856:	2800      	cmp	r0, #0
    e858:	d0e8      	beq.n	e82c <TCPIP_DNS_ClientInitialize+0x108>
            pE->pHostName = 0;
    e85a:	6227      	str	r7, [r4, #32]
            pE->pip4Address = 0;
    e85c:	6127      	str	r7, [r4, #16]
            pE->pip6Address = 0;
    e85e:	6167      	str	r7, [r4, #20]
            if(pDnsDcpt->nIPv4Entries)
    e860:	8c33      	ldrh	r3, [r6, #32]
    e862:	b11b      	cbz	r3, e86c <TCPIP_DNS_ClientInitialize+0x148>
                pE->pip4Address = (IPV4_ADDR *)pMemoryBlock;
    e864:	6120      	str	r0, [r4, #16]
                pMemoryBlock += pDnsDcpt->nIPv4Entries * (sizeof(IPV4_ADDR));
    e866:	8c33      	ldrh	r3, [r6, #32]
    e868:	eb00 0083 	add.w	r0, r0, r3, lsl #2
            if(pDnsDcpt->nIPv6Entries)
    e86c:	8c73      	ldrh	r3, [r6, #34]	; 0x22
    e86e:	2b00      	cmp	r3, #0
    e870:	d0e1      	beq.n	e836 <TCPIP_DNS_ClientInitialize+0x112>
                pE->pip6Address = (IPV6_ADDR *)pMemoryBlock;
    e872:	6160      	str	r0, [r4, #20]
                pMemoryBlock += pDnsDcpt->nIPv6Entries * (sizeof(IPV6_ADDR));
    e874:	8c73      	ldrh	r3, [r6, #34]	; 0x22
    e876:	eb00 1003 	add.w	r0, r0, r3, lsl #4
    e87a:	e7dc      	b.n	e836 <TCPIP_DNS_ClientInitialize+0x112>
            if((pDnsDcpt->dnsSignalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_DNS_ClientTask, TCPIP_DNS_CLIENT_TASK_PROCESS_RATE)) == 0)
    e87c:	22c8      	movs	r2, #200	; 0xc8
    e87e:	4929      	ldr	r1, [pc, #164]	; (e924 <TCPIP_DNS_ClientInitialize+0x200>)
    e880:	200f      	movs	r0, #15
    e882:	f00e fb9d 	bl	1cfc0 <_TCPIPStackSignalHandlerRegister>
    e886:	4b22      	ldr	r3, [pc, #136]	; (e910 <TCPIP_DNS_ClientInitialize+0x1ec>)
    e888:	60d8      	str	r0, [r3, #12]
    e88a:	b190      	cbz	r0, e8b2 <TCPIP_DNS_ClientInitialize+0x18e>
    if(pDnsDcpt->dnsSocket != INVALID_UDP_SOCKET)
    e88c:	f9b3 3024 	ldrsh.w	r3, [r3, #36]	; 0x24
    e890:	f1b3 3fff 	cmp.w	r3, #4294967295
    e894:	d003      	beq.n	e89e <TCPIP_DNS_ClientInitialize+0x17a>
        pgDnsDcpt = &gDnsDcpt;
    e896:	4b24      	ldr	r3, [pc, #144]	; (e928 <TCPIP_DNS_ClientInitialize+0x204>)
    e898:	4a1d      	ldr	r2, [pc, #116]	; (e910 <TCPIP_DNS_ClientInitialize+0x1ec>)
    e89a:	601a      	str	r2, [r3, #0]
    e89c:	e74c      	b.n	e738 <TCPIP_DNS_ClientInitialize+0x14>
        dnsSocket = TCPIP_UDP_ClientOpen(pDnsDcpt->ipAddressType, TCPIP_DNS_SERVER_PORT, 0);
    e89e:	2200      	movs	r2, #0
    e8a0:	2135      	movs	r1, #53	; 0x35
    e8a2:	4b1b      	ldr	r3, [pc, #108]	; (e910 <TCPIP_DNS_ClientInitialize+0x1ec>)
    e8a4:	7e18      	ldrb	r0, [r3, #24]
    e8a6:	f013 fc4d 	bl	22144 <TCPIP_UDP_ClientOpen>
    e8aa:	4604      	mov	r4, r0
        if(dnsSocket == INVALID_UDP_SOCKET)
    e8ac:	f1b0 3fff 	cmp.w	r0, #4294967295
    e8b0:	d104      	bne.n	e8bc <TCPIP_DNS_ClientInitialize+0x198>
            _DNSClientCleanup(pDnsDcpt);
    e8b2:	4817      	ldr	r0, [pc, #92]	; (e910 <TCPIP_DNS_ClientInitialize+0x1ec>)
    e8b4:	f010 ff26 	bl	1f704 <_DNSClientCleanup>
            return false;
    e8b8:	2000      	movs	r0, #0
    e8ba:	e74a      	b.n	e752 <TCPIP_DNS_ClientInitialize+0x2e>
        bufferSize = TCPIP_UDP_TxPutIsReady(dnsSocket, minDnsTxSize);
    e8bc:	2153      	movs	r1, #83	; 0x53
    e8be:	f013 fc66 	bl	2218e <TCPIP_UDP_TxPutIsReady>
        if(bufferSize < minDnsTxSize)
    e8c2:	2852      	cmp	r0, #82	; 0x52
    e8c4:	d805      	bhi.n	e8d2 <TCPIP_DNS_ClientInitialize+0x1ae>
            if(!TCPIP_UDP_OptionsSet(dnsSocket, UDP_OPTION_TX_BUFF, (void*)minDnsTxSize))
    e8c6:	2253      	movs	r2, #83	; 0x53
    e8c8:	2105      	movs	r1, #5
    e8ca:	4620      	mov	r0, r4
    e8cc:	f000 f830 	bl	e930 <TCPIP_UDP_OptionsSet>
    e8d0:	b1c0      	cbz	r0, e904 <TCPIP_DNS_ClientInitialize+0x1e0>
        TCPIP_UDP_OptionsSet(dnsSocket, UDP_OPTION_STRICT_ADDRESS, (void*)false);
    e8d2:	2200      	movs	r2, #0
    e8d4:	2102      	movs	r1, #2
    e8d6:	4620      	mov	r0, r4
    e8d8:	f000 f82a 	bl	e930 <TCPIP_UDP_OptionsSet>
        if(TCPIP_UDP_SignalHandlerRegister(dnsSocket, TCPIP_UDP_SIGNAL_RX_DATA, _DNSSocketRxSignalHandler, 0) == 0)
    e8dc:	2300      	movs	r3, #0
    e8de:	4a13      	ldr	r2, [pc, #76]	; (e92c <TCPIP_DNS_ClientInitialize+0x208>)
    e8e0:	f44f 7180 	mov.w	r1, #256	; 0x100
    e8e4:	4620      	mov	r0, r4
    e8e6:	f00e fda4 	bl	1d432 <TCPIP_UDP_SignalHandlerRegister>
    e8ea:	b158      	cbz	r0, e904 <TCPIP_DNS_ClientInitialize+0x1e0>
        pDnsDcpt->dnsSocket = dnsSocket;
    e8ec:	4b08      	ldr	r3, [pc, #32]	; (e910 <TCPIP_DNS_ClientInitialize+0x1ec>)
    e8ee:	849c      	strh	r4, [r3, #36]	; 0x24
    if(!success && dnsSocket != INVALID_UDP_SOCKET)
    e8f0:	e7d1      	b.n	e896 <TCPIP_DNS_ClientInitialize+0x172>
        _DNS_Enable(stackData->pNetIf, false, TCPIP_DNS_ENABLE_DEFAULT);
    e8f2:	2200      	movs	r2, #0
    e8f4:	4611      	mov	r1, r2
    e8f6:	f00d fa65 	bl	1bdc4 <_DNS_Enable>
    e8fa:	e725      	b.n	e748 <TCPIP_DNS_ClientInitialize+0x24>
            return false;
    e8fc:	2000      	movs	r0, #0
    e8fe:	e728      	b.n	e752 <TCPIP_DNS_ClientInitialize+0x2e>
            return false;
    e900:	2000      	movs	r0, #0
    e902:	e726      	b.n	e752 <TCPIP_DNS_ClientInitialize+0x2e>
        TCPIP_UDP_Close(dnsSocket);
    e904:	4620      	mov	r0, r4
    e906:	f010 fd0f 	bl	1f328 <TCPIP_UDP_Close>
    e90a:	e7d2      	b.n	e8b2 <TCPIP_DNS_ClientInitialize+0x18e>
    e90c:	2000e420 	.word	0x2000e420
    e910:	2000e0c8 	.word	0x2000e0c8
    e914:	00020a91 	.word	0x00020a91
    e918:	0001c69d 	.word	0x0001c69d
    e91c:	00021ff1 	.word	0x00021ff1
    e920:	0001fc35 	.word	0x0001fc35
    e924:	00014b55 	.word	0x00014b55
    e928:	2000e424 	.word	0x2000e424
    e92c:	000217d9 	.word	0x000217d9

Disassembly of section .text.TCPIP_UDP_OptionsSet%225:

0000e930 <TCPIP_UDP_OptionsSet>:
    return true;
}

// Allows setting options to a socket like enable broadcast, Rx/Tx buffer size, etc
bool TCPIP_UDP_OptionsSet(UDP_SOCKET hUDP, UDP_SOCKET_OPTION option, void* optParam)
{
    e930:	b570      	push	{r4, r5, r6, lr}
    e932:	460d      	mov	r5, r1
    e934:	4614      	mov	r4, r2
    UDP_SOCKET_DCPT*  pSkt = _UDPSocketDcpt(hUDP);
    e936:	f011 fb75 	bl	20024 <_UDPSocketDcpt>

    if(pSkt)
    e93a:	2800      	cmp	r0, #0
    e93c:	f000 80f0 	beq.w	eb20 <TCPIP_UDP_OptionsSet+0x1f0>
    e940:	4606      	mov	r6, r0
    {
        switch(option)
    e942:	2d0c      	cmp	r5, #12
    e944:	f200 80ee 	bhi.w	eb24 <TCPIP_UDP_OptionsSet+0x1f4>
    e948:	e8df f005 	tbb	[pc, r5]
    e94c:	281d1207 	.word	0x281d1207
    e950:	68645f46 	.word	0x68645f46
    e954:	d77b776c 	.word	0xd77b776c
    e958:	df          	.byte	0xdf
    e959:	00          	.byte	0x00
        {
            case UDP_OPTION_STRICT_PORT:
                pSkt->flags.looseRemPort = (optParam == 0);
    e95a:	fab4 f484 	clz	r4, r4
    e95e:	0964      	lsrs	r4, r4, #5
    e960:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    e964:	f364 0382 	bfi	r3, r4, #2, #1
    e968:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
                return true;
    e96c:	2001      	movs	r0, #1
    e96e:	e0d8      	b.n	eb22 <TCPIP_UDP_OptionsSet+0x1f2>


            case UDP_OPTION_STRICT_NET:
                pSkt->flags.looseNetIf = (optParam == 0);
    e970:	fab4 f484 	clz	r4, r4
    e974:	0964      	lsrs	r4, r4, #5
    e976:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    e97a:	f364 03c3 	bfi	r3, r4, #3, #1
    e97e:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
                return true;
    e982:	2001      	movs	r0, #1
    e984:	e0cd      	b.n	eb22 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_STRICT_ADDRESS:
                pSkt->flags.looseRemAddress = (optParam == 0);
    e986:	fab4 f484 	clz	r4, r4
    e98a:	0964      	lsrs	r4, r4, #5
    e98c:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    e990:	f364 1304 	bfi	r3, r4, #4, #1
    e994:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
                return true;
    e998:	2001      	movs	r0, #1
    e99a:	e0c2      	b.n	eb22 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_BROADCAST:
                if((pSkt->flags.bcastForceType = (int)optParam) != UDP_BCAST_NONE)
    e99c:	f004 0403 	and.w	r4, r4, #3
    e9a0:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    e9a4:	f364 0301 	bfi	r3, r4, #0, #2
    e9a8:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
    e9ac:	b154      	cbz	r4, e9c4 <TCPIP_UDP_OptionsSet+0x94>
                {   // set limited broadcast address (for now)
                    pSkt->destAddress.Val = 0xffffffff;
    e9ae:	f04f 33ff 	mov.w	r3, #4294967295
    e9b2:	6143      	str	r3, [r0, #20]
                    pSkt->flags.destSet = 1;
    e9b4:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
    e9b8:	f043 0301 	orr.w	r3, r3, #1
    e9bc:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
                {   // the discrete address will have to be set and take effect
                    pSkt->destAddress.Val = 0;
                    pSkt->flags.destSet = 0;
                }

                return true;
    e9c0:	2001      	movs	r0, #1
    e9c2:	e0ae      	b.n	eb22 <TCPIP_UDP_OptionsSet+0x1f2>
                    pSkt->destAddress.Val = 0;
    e9c4:	2200      	movs	r2, #0
    e9c6:	6142      	str	r2, [r0, #20]
                    pSkt->flags.destSet = 0;
    e9c8:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
    e9cc:	f362 0300 	bfi	r3, r2, #0, #1
    e9d0:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
                return true;
    e9d4:	2001      	movs	r0, #1
    e9d6:	e0a4      	b.n	eb22 <TCPIP_UDP_OptionsSet+0x1f2>
                if(pSkt->addType == IP_ADDRESS_TYPE_IPV6)
                {   
                    return false;
                }
#endif  // defined (TCPIP_STACK_USE_IPV6)
                if(pSkt->flags.txSplitAlloc != 0)
    e9d8:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
    e9dc:	f013 0f02 	tst.w	r3, #2
    e9e0:	f040 80a2 	bne.w	eb28 <TCPIP_UDP_OptionsSet+0x1f8>
                {   // no support for external payload sockets
                    return false;
                }

                if(pSkt->flags.usePool != (optParam != 0))
    e9e4:	3400      	adds	r4, #0
    e9e6:	bf18      	it	ne
    e9e8:	2401      	movne	r4, #1
    e9ea:	f3c3 0380 	ubfx	r3, r3, #2, #1
    e9ee:	42a3      	cmp	r3, r4
    e9f0:	d101      	bne.n	e9f6 <TCPIP_UDP_OptionsSet+0xc6>
                {   // changed the buffer type; just release the packet
                    _UDPFreeTxResources(pSkt);
                    pSkt->flags.usePool = (optParam != 0);
                }
                return true;
    e9f2:	2001      	movs	r0, #1
    e9f4:	e095      	b.n	eb22 <TCPIP_UDP_OptionsSet+0x1f2>
                    _UDPFreeTxResources(pSkt);
    e9f6:	f010 ffd5 	bl	1f9a4 <_UDPFreeTxResources>
                    pSkt->flags.usePool = (optParam != 0);
    e9fa:	f896 3041 	ldrb.w	r3, [r6, #65]	; 0x41
    e9fe:	f364 0382 	bfi	r3, r4, #2, #1
    ea02:	f886 3041 	strb.w	r3, [r6, #65]	; 0x41
                return true;
    ea06:	2001      	movs	r0, #1
    ea08:	e08b      	b.n	eb22 <TCPIP_UDP_OptionsSet+0x1f2>


            case UDP_OPTION_TX_BUFF:
                // just release the packet
                _UDPFreeTxResources(pSkt);
    ea0a:	f010 ffcb 	bl	1f9a4 <_UDPFreeTxResources>
                pSkt->txSize = (uint16_t)(unsigned int)optParam;
    ea0e:	8234      	strh	r4, [r6, #16]
                return true;
    ea10:	2001      	movs	r0, #1
    ea12:	e086      	b.n	eb22 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_TX_QUEUE_LIMIT:
                pSkt->txAllocLimit = (uint8_t)(unsigned int)optParam;
    ea14:	f880 403e 	strb.w	r4, [r0, #62]	; 0x3e
                return true;
    ea18:	2001      	movs	r0, #1
    ea1a:	e082      	b.n	eb22 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_RX_QUEUE_LIMIT:
                pSkt->rxQueueLimit = (uint8_t)(unsigned int)optParam;
    ea1c:	f880 405a 	strb.w	r4, [r0, #90]	; 0x5a
                return true;
    ea20:	2001      	movs	r0, #1
    ea22:	e07e      	b.n	eb22 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_RX_AUTO_ADVANCE:
                pSkt->extFlags.rxAutoAdvance = (optParam != 0);
    ea24:	3400      	adds	r4, #0
    ea26:	bf18      	it	ne
    ea28:	2401      	movne	r4, #1
    ea2a:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
    ea2e:	f364 0300 	bfi	r3, r4, #0, #1
    ea32:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
                return true;
    ea36:	2001      	movs	r0, #1
    ea38:	e073      	b.n	eb22 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_TX_TTL:
                pSkt->ttl = (uint8_t)(unsigned int)optParam;
    ea3a:	f880 405b 	strb.w	r4, [r0, #91]	; 0x5b
                return true;
    ea3e:	2001      	movs	r0, #1
    ea40:	e06f      	b.n	eb22 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_MULTICAST:
                {
                    UDP_OPTION_MULTICAST_DATA* pMcOpt = (UDP_OPTION_MULTICAST_DATA*)optParam;
                    if(pMcOpt!= 0)
    ea42:	2c00      	cmp	r4, #0
    ea44:	d072      	beq.n	eb2c <TCPIP_UDP_OptionsSet+0x1fc>
                    {
                        if((pMcOpt->flagsMask & UDP_MCAST_FLAG_LOOSE_NET_SOURCE_PORT) != 0)
    ea46:	7823      	ldrb	r3, [r4, #0]
    ea48:	f013 0f01 	tst.w	r3, #1
    ea4c:	d012      	beq.n	ea74 <TCPIP_UDP_OptionsSet+0x144>
                        {   // change the source/net/source/port value
                            pSkt->flags.looseNetIf = (pMcOpt->flagsValue & UDP_MCAST_FLAG_LOOSE_NET_SOURCE_PORT) != 0;
    ea4e:	7862      	ldrb	r2, [r4, #1]
    ea50:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    ea54:	f362 03c3 	bfi	r3, r2, #3, #1
    ea58:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
                            pSkt->flags.looseRemAddress = (pMcOpt->flagsValue & UDP_MCAST_FLAG_LOOSE_NET_SOURCE_PORT) != 0;
    ea5c:	7862      	ldrb	r2, [r4, #1]
    ea5e:	b2db      	uxtb	r3, r3
    ea60:	f362 1304 	bfi	r3, r2, #4, #1
    ea64:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
                            pSkt->flags.looseRemPort = (pMcOpt->flagsValue & UDP_MCAST_FLAG_LOOSE_NET_SOURCE_PORT) != 0;
    ea68:	7862      	ldrb	r2, [r4, #1]
    ea6a:	b2db      	uxtb	r3, r3
    ea6c:	f362 0382 	bfi	r3, r2, #2, #1
    ea70:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
                        }
                        if((pMcOpt->flagsMask & UDP_MCAST_FLAG_IGNORE_SOURCE_ADD) != 0)
    ea74:	7823      	ldrb	r3, [r4, #0]
    ea76:	f013 0f02 	tst.w	r3, #2
    ea7a:	d008      	beq.n	ea8e <TCPIP_UDP_OptionsSet+0x15e>
                        {
                            pSkt->extFlags.ignoreSrcAdd = (pMcOpt->flagsValue & UDP_MCAST_FLAG_IGNORE_SOURCE_ADD) != 0;
    ea7c:	7863      	ldrb	r3, [r4, #1]
    ea7e:	f3c3 0340 	ubfx	r3, r3, #1, #1
    ea82:	f896 2042 	ldrb.w	r2, [r6, #66]	; 0x42
    ea86:	f363 1204 	bfi	r2, r3, #4, #1
    ea8a:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42
                        }
                        if((pMcOpt->flagsMask & UDP_MCAST_FLAG_IGNORE_SOURCE_PORT) != 0)
    ea8e:	7823      	ldrb	r3, [r4, #0]
    ea90:	f013 0f04 	tst.w	r3, #4
    ea94:	d008      	beq.n	eaa8 <TCPIP_UDP_OptionsSet+0x178>
                        {
                            pSkt->extFlags.ignoreSrcPort = (pMcOpt->flagsValue & UDP_MCAST_FLAG_IGNORE_SOURCE_PORT) != 0;
    ea96:	7863      	ldrb	r3, [r4, #1]
    ea98:	f3c3 0380 	ubfx	r3, r3, #2, #1
    ea9c:	f896 2042 	ldrb.w	r2, [r6, #66]	; 0x42
    eaa0:	f363 1245 	bfi	r2, r3, #5, #1
    eaa4:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42
                        }
                        if((pMcOpt->flagsMask & UDP_MCAST_FLAG_IGNORE_UNICAST) != 0)
    eaa8:	7823      	ldrb	r3, [r4, #0]
    eaaa:	f013 0f08 	tst.w	r3, #8
    eaae:	d008      	beq.n	eac2 <TCPIP_UDP_OptionsSet+0x192>
                        {
                            pSkt->extFlags.mcastOnly = (pMcOpt->flagsValue & UDP_MCAST_FLAG_IGNORE_UNICAST) != 0;
    eab0:	7863      	ldrb	r3, [r4, #1]
    eab2:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    eab6:	f896 2042 	ldrb.w	r2, [r6, #66]	; 0x42
    eaba:	f363 1286 	bfi	r2, r3, #6, #1
    eabe:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42
                        }
                        if((pMcOpt->flagsMask & UDP_MCAST_FLAG_LOOP) != 0)
    eac2:	7823      	ldrb	r3, [r4, #0]
    eac4:	f013 0f10 	tst.w	r3, #16
    eac8:	d008      	beq.n	eadc <TCPIP_UDP_OptionsSet+0x1ac>
                        {
                            pSkt->extFlags.mcastLoop = (pMcOpt->flagsValue & UDP_MCAST_FLAG_LOOP) != 0;
    eaca:	7863      	ldrb	r3, [r4, #1]
    eacc:	f3c3 1300 	ubfx	r3, r3, #4, #1
    ead0:	f896 2042 	ldrb.w	r2, [r6, #66]	; 0x42
    ead4:	f363 0282 	bfi	r2, r3, #2, #1
    ead8:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42
                        }
                        if((pMcOpt->flagsMask & UDP_MCAST_FLAG_DISABLE_SOURCE_CHECK) != 0)
    eadc:	7823      	ldrb	r3, [r4, #0]
    eade:	f013 0f20 	tst.w	r3, #32
    eae2:	d025      	beq.n	eb30 <TCPIP_UDP_OptionsSet+0x200>
                        {
                            pSkt->extFlags.mcastSkipCheck = (pMcOpt->flagsValue & UDP_MCAST_FLAG_DISABLE_SOURCE_CHECK) != 0;
    eae4:	7863      	ldrb	r3, [r4, #1]
    eae6:	f3c3 1340 	ubfx	r3, r3, #5, #1
    eaea:	f896 2042 	ldrb.w	r2, [r6, #66]	; 0x42
    eaee:	f363 02c3 	bfi	r2, r3, #3, #1
    eaf2:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42
                        }

                        return true;
    eaf6:	2001      	movs	r0, #1
    eaf8:	e013      	b.n	eb22 <TCPIP_UDP_OptionsSet+0x1f2>
                    }
                }
                return false;

            case UDP_OPTION_TOS:
                pSkt->extFlags.tos = (uint8_t)(unsigned int)optParam;
    eafa:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
    eafe:	f364 0305 	bfi	r3, r4, #0, #6
    eb02:	f880 3043 	strb.w	r3, [r0, #67]	; 0x43
                return true;
    eb06:	2001      	movs	r0, #1
    eb08:	e00b      	b.n	eb22 <TCPIP_UDP_OptionsSet+0x1f2>
                
            case UDP_OPTION_DF:
                pSkt->extFlags.df = (optParam != 0);
    eb0a:	3400      	adds	r4, #0
    eb0c:	bf18      	it	ne
    eb0e:	2401      	movne	r4, #1
    eb10:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
    eb14:	f364 1386 	bfi	r3, r4, #6, #1
    eb18:	f880 3043 	strb.w	r3, [r0, #67]	; 0x43
                return true;
    eb1c:	2001      	movs	r0, #1
    eb1e:	e000      	b.n	eb22 <TCPIP_UDP_OptionsSet+0x1f2>
            default:
                break;
        }
    }    

    return false;
    eb20:	2000      	movs	r0, #0
}
    eb22:	bd70      	pop	{r4, r5, r6, pc}
    return false;
    eb24:	2000      	movs	r0, #0
    eb26:	e7fc      	b.n	eb22 <TCPIP_UDP_OptionsSet+0x1f2>
                    return false;
    eb28:	2000      	movs	r0, #0
    eb2a:	e7fa      	b.n	eb22 <TCPIP_UDP_OptionsSet+0x1f2>
                return false;
    eb2c:	2000      	movs	r0, #0
    eb2e:	e7f8      	b.n	eb22 <TCPIP_UDP_OptionsSet+0x1f2>
                        return true;
    eb30:	2001      	movs	r0, #1
    eb32:	e7f6      	b.n	eb22 <TCPIP_UDP_OptionsSet+0x1f2>

Disassembly of section .text._vfprintf_r%226:

0000eb34 <_vfiprintf_r>:
    eb34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    eb38:	460d      	mov	r5, r1
    eb3a:	b09d      	sub	sp, #116	; 0x74
    eb3c:	4614      	mov	r4, r2
    eb3e:	461e      	mov	r6, r3
    eb40:	4607      	mov	r7, r0
    eb42:	b118      	cbz	r0, eb4c <_vfiprintf_r+0x18>
    eb44:	6983      	ldr	r3, [r0, #24]
    eb46:	b90b      	cbnz	r3, eb4c <_vfiprintf_r+0x18>
    eb48:	f00c fe32 	bl	1b7b0 <__sinit>
    eb4c:	4b70      	ldr	r3, [pc, #448]	; (ed10 <_vfiprintf_r+0x1dc>)
    eb4e:	429d      	cmp	r5, r3
    eb50:	d15c      	bne.n	ec0c <_vfiprintf_r+0xd8>
    eb52:	687d      	ldr	r5, [r7, #4]
    eb54:	89ab      	ldrh	r3, [r5, #12]
    eb56:	071b      	lsls	r3, r3, #28
    eb58:	d562      	bpl.n	ec20 <_vfiprintf_r+0xec>
    eb5a:	692b      	ldr	r3, [r5, #16]
    eb5c:	2b00      	cmp	r3, #0
    eb5e:	d05f      	beq.n	ec20 <_vfiprintf_r+0xec>
    eb60:	2300      	movs	r3, #0
    eb62:	9309      	str	r3, [sp, #36]	; 0x24
    eb64:	f8df 91ac 	ldr.w	r9, [pc, #428]	; ed14 <_vfiprintf_r+0x1e0>
    eb68:	9603      	str	r6, [sp, #12]
    eb6a:	2320      	movs	r3, #32
    eb6c:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
    eb70:	2330      	movs	r3, #48	; 0x30
    eb72:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    eb76:	f04f 38ff 	mov.w	r8, #4294967295
    eb7a:	f109 0a06 	add.w	sl, r9, #6
    eb7e:	4623      	mov	r3, r4
    eb80:	461e      	mov	r6, r3
    eb82:	f813 2b01 	ldrb.w	r2, [r3], #1
    eb86:	b10a      	cbz	r2, eb8c <_vfiprintf_r+0x58>
    eb88:	2a25      	cmp	r2, #37	; 0x25
    eb8a:	d1f9      	bne.n	eb80 <_vfiprintf_r+0x4c>
    eb8c:	ebb6 0b04 	subs.w	fp, r6, r4
    eb90:	d00b      	beq.n	ebaa <_vfiprintf_r+0x76>
    eb92:	465b      	mov	r3, fp
    eb94:	4622      	mov	r2, r4
    eb96:	4629      	mov	r1, r5
    eb98:	4638      	mov	r0, r7
    eb9a:	f00e f8a8 	bl	1ccee <__ssfputs_r>
    eb9e:	3001      	adds	r0, #1
    eba0:	f000 80b0 	beq.w	ed04 <_vfiprintf_r+0x1d0>
    eba4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    eba6:	445b      	add	r3, fp
    eba8:	9309      	str	r3, [sp, #36]	; 0x24
    ebaa:	7833      	ldrb	r3, [r6, #0]
    ebac:	2b00      	cmp	r3, #0
    ebae:	f000 80a9 	beq.w	ed04 <_vfiprintf_r+0x1d0>
    ebb2:	2300      	movs	r3, #0
    ebb4:	e9cd 8305 	strd	r8, r3, [sp, #20]
    ebb8:	3601      	adds	r6, #1
    ebba:	9304      	str	r3, [sp, #16]
    ebbc:	9307      	str	r3, [sp, #28]
    ebbe:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    ebc2:	931a      	str	r3, [sp, #104]	; 0x68
    ebc4:	f04f 0b01 	mov.w	fp, #1
    ebc8:	4634      	mov	r4, r6
    ebca:	2205      	movs	r2, #5
    ebcc:	f814 1b01 	ldrb.w	r1, [r4], #1
    ebd0:	4850      	ldr	r0, [pc, #320]	; (ed14 <_vfiprintf_r+0x1e0>)
    ebd2:	f009 f815 	bl	17c00 <memchr>
    ebd6:	9b04      	ldr	r3, [sp, #16]
    ebd8:	bb68      	cbnz	r0, ec36 <_vfiprintf_r+0x102>
    ebda:	06d8      	lsls	r0, r3, #27
    ebdc:	bf44      	itt	mi
    ebde:	2220      	movmi	r2, #32
    ebe0:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    ebe4:	0719      	lsls	r1, r3, #28
    ebe6:	bf44      	itt	mi
    ebe8:	222b      	movmi	r2, #43	; 0x2b
    ebea:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    ebee:	7832      	ldrb	r2, [r6, #0]
    ebf0:	2a2a      	cmp	r2, #42	; 0x2a
    ebf2:	d028      	beq.n	ec46 <_vfiprintf_r+0x112>
    ebf4:	9a07      	ldr	r2, [sp, #28]
    ebf6:	4634      	mov	r4, r6
    ebf8:	2000      	movs	r0, #0
    ebfa:	260a      	movs	r6, #10
    ebfc:	4621      	mov	r1, r4
    ebfe:	f811 3b01 	ldrb.w	r3, [r1], #1
    ec02:	3b30      	subs	r3, #48	; 0x30
    ec04:	2b09      	cmp	r3, #9
    ec06:	d960      	bls.n	ecca <_vfiprintf_r+0x196>
    ec08:	bb18      	cbnz	r0, ec52 <_vfiprintf_r+0x11e>
    ec0a:	e029      	b.n	ec60 <_vfiprintf_r+0x12c>
    ec0c:	4b42      	ldr	r3, [pc, #264]	; (ed18 <_vfiprintf_r+0x1e4>)
    ec0e:	429d      	cmp	r5, r3
    ec10:	d101      	bne.n	ec16 <_vfiprintf_r+0xe2>
    ec12:	68bd      	ldr	r5, [r7, #8]
    ec14:	e79e      	b.n	eb54 <_vfiprintf_r+0x20>
    ec16:	4b41      	ldr	r3, [pc, #260]	; (ed1c <_vfiprintf_r+0x1e8>)
    ec18:	429d      	cmp	r5, r3
    ec1a:	bf08      	it	eq
    ec1c:	68fd      	ldreq	r5, [r7, #12]
    ec1e:	e799      	b.n	eb54 <_vfiprintf_r+0x20>
    ec20:	4629      	mov	r1, r5
    ec22:	4638      	mov	r0, r7
    ec24:	f006 fc1e 	bl	15464 <__swsetup_r>
    ec28:	2800      	cmp	r0, #0
    ec2a:	d099      	beq.n	eb60 <_vfiprintf_r+0x2c>
    ec2c:	f04f 30ff 	mov.w	r0, #4294967295
    ec30:	b01d      	add	sp, #116	; 0x74
    ec32:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ec36:	eba0 0009 	sub.w	r0, r0, r9
    ec3a:	fa0b f000 	lsl.w	r0, fp, r0
    ec3e:	4318      	orrs	r0, r3
    ec40:	9004      	str	r0, [sp, #16]
    ec42:	4626      	mov	r6, r4
    ec44:	e7c0      	b.n	ebc8 <_vfiprintf_r+0x94>
    ec46:	9a03      	ldr	r2, [sp, #12]
    ec48:	1d11      	adds	r1, r2, #4
    ec4a:	6812      	ldr	r2, [r2, #0]
    ec4c:	9103      	str	r1, [sp, #12]
    ec4e:	2a00      	cmp	r2, #0
    ec50:	db01      	blt.n	ec56 <_vfiprintf_r+0x122>
    ec52:	9207      	str	r2, [sp, #28]
    ec54:	e004      	b.n	ec60 <_vfiprintf_r+0x12c>
    ec56:	4252      	negs	r2, r2
    ec58:	f043 0302 	orr.w	r3, r3, #2
    ec5c:	9207      	str	r2, [sp, #28]
    ec5e:	9304      	str	r3, [sp, #16]
    ec60:	7823      	ldrb	r3, [r4, #0]
    ec62:	2b2e      	cmp	r3, #46	; 0x2e
    ec64:	d10b      	bne.n	ec7e <_vfiprintf_r+0x14a>
    ec66:	7863      	ldrb	r3, [r4, #1]
    ec68:	2b2a      	cmp	r3, #42	; 0x2a
    ec6a:	d133      	bne.n	ecd4 <_vfiprintf_r+0x1a0>
    ec6c:	9b03      	ldr	r3, [sp, #12]
    ec6e:	1d1a      	adds	r2, r3, #4
    ec70:	681b      	ldr	r3, [r3, #0]
    ec72:	9203      	str	r2, [sp, #12]
    ec74:	2b00      	cmp	r3, #0
    ec76:	bfb8      	it	lt
    ec78:	4643      	movlt	r3, r8
    ec7a:	3402      	adds	r4, #2
    ec7c:	9305      	str	r3, [sp, #20]
    ec7e:	2203      	movs	r2, #3
    ec80:	7821      	ldrb	r1, [r4, #0]
    ec82:	4827      	ldr	r0, [pc, #156]	; (ed20 <_vfiprintf_r+0x1ec>)
    ec84:	f008 ffbc 	bl	17c00 <memchr>
    ec88:	b140      	cbz	r0, ec9c <_vfiprintf_r+0x168>
    ec8a:	2340      	movs	r3, #64	; 0x40
    ec8c:	eba0 000a 	sub.w	r0, r0, sl
    ec90:	fa03 f000 	lsl.w	r0, r3, r0
    ec94:	9b04      	ldr	r3, [sp, #16]
    ec96:	4303      	orrs	r3, r0
    ec98:	3401      	adds	r4, #1
    ec9a:	9304      	str	r3, [sp, #16]
    ec9c:	f814 1b01 	ldrb.w	r1, [r4], #1
    eca0:	4820      	ldr	r0, [pc, #128]	; (ed24 <_vfiprintf_r+0x1f0>)
    eca2:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
    eca6:	2206      	movs	r2, #6
    eca8:	f008 ffaa 	bl	17c00 <memchr>
    ecac:	ab03      	add	r3, sp, #12
    ecae:	9300      	str	r3, [sp, #0]
    ecb0:	462a      	mov	r2, r5
    ecb2:	4b1d      	ldr	r3, [pc, #116]	; (ed28 <_vfiprintf_r+0x1f4>)
    ecb4:	a904      	add	r1, sp, #16
    ecb6:	b308      	cbz	r0, ecfc <_vfiprintf_r+0x1c8>
    ecb8:	4638      	mov	r0, r7
    ecba:	f7f9 fa8b 	bl	81d4 <_printf_float>
    ecbe:	1c42      	adds	r2, r0, #1
    ecc0:	d020      	beq.n	ed04 <_vfiprintf_r+0x1d0>
    ecc2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ecc4:	4403      	add	r3, r0
    ecc6:	9309      	str	r3, [sp, #36]	; 0x24
    ecc8:	e759      	b.n	eb7e <_vfiprintf_r+0x4a>
    ecca:	fb06 3202 	mla	r2, r6, r2, r3
    ecce:	2001      	movs	r0, #1
    ecd0:	460c      	mov	r4, r1
    ecd2:	e793      	b.n	ebfc <_vfiprintf_r+0xc8>
    ecd4:	2300      	movs	r3, #0
    ecd6:	3401      	adds	r4, #1
    ecd8:	9305      	str	r3, [sp, #20]
    ecda:	4619      	mov	r1, r3
    ecdc:	260a      	movs	r6, #10
    ecde:	4620      	mov	r0, r4
    ece0:	f810 2b01 	ldrb.w	r2, [r0], #1
    ece4:	3a30      	subs	r2, #48	; 0x30
    ece6:	2a09      	cmp	r2, #9
    ece8:	d903      	bls.n	ecf2 <_vfiprintf_r+0x1be>
    ecea:	2b00      	cmp	r3, #0
    ecec:	d0c7      	beq.n	ec7e <_vfiprintf_r+0x14a>
    ecee:	9105      	str	r1, [sp, #20]
    ecf0:	e7c5      	b.n	ec7e <_vfiprintf_r+0x14a>
    ecf2:	fb06 2101 	mla	r1, r6, r1, r2
    ecf6:	2301      	movs	r3, #1
    ecf8:	4604      	mov	r4, r0
    ecfa:	e7f0      	b.n	ecde <_vfiprintf_r+0x1aa>
    ecfc:	4638      	mov	r0, r7
    ecfe:	f7ff f8df 	bl	dec0 <_printf_i>
    ed02:	e7dc      	b.n	ecbe <_vfiprintf_r+0x18a>
    ed04:	89ab      	ldrh	r3, [r5, #12]
    ed06:	065b      	lsls	r3, r3, #25
    ed08:	d490      	bmi.n	ec2c <_vfiprintf_r+0xf8>
    ed0a:	9809      	ldr	r0, [sp, #36]	; 0x24
    ed0c:	e790      	b.n	ec30 <_vfiprintf_r+0xfc>
    ed0e:	bf00      	nop
    ed10:	2000e130 	.word	0x2000e130
    ed14:	00021b0a 	.word	0x00021b0a
    ed18:	2000e150 	.word	0x2000e150
    ed1c:	2000e110 	.word	0x2000e110
    ed20:	00021b10 	.word	0x00021b10
    ed24:	00021b14 	.word	0x00021b14
    ed28:	0001ccef 	.word	0x0001ccef

Disassembly of section .text.Lan867x_Miim_Task%227:

0000ed2c <Lan867x_Miim_Task>:
 *
 * Note:
 *****************************************************************************/
static DRV_MIIM_RESULT Lan867x_Miim_Task(LAN867X_REG_OBJ *clientObj, DRV_MIIM_OP_TYPE opType,
                                         uint32_t regAddr, uint16_t *data)
{
    ed2c:	b5f0      	push	{r4, r5, r6, r7, lr}
    ed2e:	b085      	sub	sp, #20
    ed30:	4604      	mov	r4, r0
    ed32:	460d      	mov	r5, r1
    ed34:	4611      	mov	r1, r2
    uint16_t mmdData = 0;
    DRV_MIIM_RESULT opRes = DRV_MIIM_RES_OK;
    ed36:	2000      	movs	r0, #0
    ed38:	f88d 000f 	strb.w	r0, [sp, #15]

    switch (R2F(clientObj->vendorData, VENDOR_INTERNAL_STATE)) {
    ed3c:	6860      	ldr	r0, [r4, #4]
    ed3e:	0e40      	lsrs	r0, r0, #25
    ed40:	2808      	cmp	r0, #8
    ed42:	f200 80e3 	bhi.w	ef0c <Lan867x_Miim_Task+0x1e0>
    ed46:	e8df f010 	tbh	[pc, r0, lsl #1]
    ed4a:	0020      	.short	0x0020
    ed4c:	00090024 	.word	0x00090024
    ed50:	0050003d 	.word	0x0050003d
    ed54:	0088006c 	.word	0x0088006c
    ed58:	00c600ab 	.word	0x00c600ab
    case WRITE_22_PHASE: /* Write to clause 22 register. */
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Write(
    ed5c:	6925      	ldr	r5, [r4, #16]
    ed5e:	68e2      	ldr	r2, [r4, #12]
    ed60:	f10d 000f 	add.w	r0, sp, #15
    ed64:	9001      	str	r0, [sp, #4]
    ed66:	2001      	movs	r0, #1
    ed68:	9000      	str	r0, [sp, #0]
    ed6a:	6b16      	ldr	r6, [r2, #48]	; 0x30
    ed6c:	881b      	ldrh	r3, [r3, #0]
    ed6e:	6822      	ldr	r2, [r4, #0]
    ed70:	68a0      	ldr	r0, [r4, #8]
    ed72:	47b0      	blx	r6
    ed74:	6028      	str	r0, [r5, #0]
            clientObj->miimHandle, regAddr, clientObj->phyAddress, *data,
            DRV_MIIM_OPERATION_FLAG_DISCARD, &opRes);
        /* If success in queuing the request, go to next state, else retry. */
        if (*clientObj->miimOpHandle != 0) {
    ed76:	6923      	ldr	r3, [r4, #16]
    ed78:	681b      	ldr	r3, [r3, #0]
    ed7a:	b133      	cbz	r3, ed8a <Lan867x_Miim_Task+0x5e>
            /* Operation successfully completed.*/
            clientObj->vendorData =
                F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
    ed7c:	6863      	ldr	r3, [r4, #4]
    ed7e:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
            clientObj->vendorData =
    ed82:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_OK;
    ed84:	2300      	movs	r3, #0
    ed86:	f88d 300f 	strb.w	r3, [sp, #15]
        /* shouldn't happen */
        opRes = DRV_MIIM_RES_OP_INTERNAL_ERR;
        break;
    }
    return opRes;
}
    ed8a:	f99d 000f 	ldrsb.w	r0, [sp, #15]
    ed8e:	b005      	add	sp, #20
    ed90:	bdf0      	pop	{r4, r5, r6, r7, pc}
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Read(
    ed92:	6925      	ldr	r5, [r4, #16]
    ed94:	68e3      	ldr	r3, [r4, #12]
    ed96:	f10d 020f 	add.w	r2, sp, #15
    ed9a:	9200      	str	r2, [sp, #0]
    ed9c:	6ade      	ldr	r6, [r3, #44]	; 0x2c
    ed9e:	2300      	movs	r3, #0
    eda0:	6822      	ldr	r2, [r4, #0]
    eda2:	68a0      	ldr	r0, [r4, #8]
    eda4:	47b0      	blx	r6
    eda6:	6028      	str	r0, [r5, #0]
        if (*clientObj->miimOpHandle != 0) {
    eda8:	6923      	ldr	r3, [r4, #16]
    edaa:	681b      	ldr	r3, [r3, #0]
    edac:	2b00      	cmp	r3, #0
    edae:	d0ec      	beq.n	ed8a <Lan867x_Miim_Task+0x5e>
                F2R(READ_RESULT_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
    edb0:	6863      	ldr	r3, [r4, #4]
    edb2:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    edb6:	f043 63c0 	orr.w	r3, r3, #100663296	; 0x6000000
            clientObj->vendorData =
    edba:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_PENDING;
    edbc:	2301      	movs	r3, #1
    edbe:	f88d 300f 	strb.w	r3, [sp, #15]
    edc2:	e7e2      	b.n	ed8a <Lan867x_Miim_Task+0x5e>
        opRes = clientObj->miimBase->DRV_MIIM_OperationResult(clientObj->miimHandle,
    edc4:	6921      	ldr	r1, [r4, #16]
    edc6:	68e2      	ldr	r2, [r4, #12]
    edc8:	6b95      	ldr	r5, [r2, #56]	; 0x38
    edca:	461a      	mov	r2, r3
    edcc:	6809      	ldr	r1, [r1, #0]
    edce:	68a0      	ldr	r0, [r4, #8]
    edd0:	47a8      	blx	r5
    edd2:	f88d 000f 	strb.w	r0, [sp, #15]
        if (opRes != DRV_MIIM_RES_PENDING) /* Check operation is in progress or not. */
    edd6:	2801      	cmp	r0, #1
    edd8:	d0d7      	beq.n	ed8a <Lan867x_Miim_Task+0x5e>
                F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
    edda:	6863      	ldr	r3, [r4, #4]
    eddc:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
            clientObj->vendorData =
    ede0:	6063      	str	r3, [r4, #4]
            *clientObj->miimOpHandle = 0;
    ede2:	6923      	ldr	r3, [r4, #16]
    ede4:	2200      	movs	r2, #0
    ede6:	601a      	str	r2, [r3, #0]
    ede8:	e7cf      	b.n	ed8a <Lan867x_Miim_Task+0x5e>
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Write(
    edea:	6925      	ldr	r5, [r4, #16]
    edec:	68e3      	ldr	r3, [r4, #12]
    edee:	f10d 020f 	add.w	r2, sp, #15
    edf2:	9201      	str	r2, [sp, #4]
    edf4:	2201      	movs	r2, #1
    edf6:	9200      	str	r2, [sp, #0]
    edf8:	6b1e      	ldr	r6, [r3, #48]	; 0x30
    edfa:	0c0b      	lsrs	r3, r1, #16
    edfc:	6822      	ldr	r2, [r4, #0]
    edfe:	210d      	movs	r1, #13
    ee00:	68a0      	ldr	r0, [r4, #8]
    ee02:	47b0      	blx	r6
    ee04:	6028      	str	r0, [r5, #0]
        if (*clientObj->miimOpHandle != 0) {
    ee06:	6923      	ldr	r3, [r4, #16]
    ee08:	681b      	ldr	r3, [r3, #0]
    ee0a:	2b00      	cmp	r3, #0
    ee0c:	d0bd      	beq.n	ed8a <Lan867x_Miim_Task+0x5e>
                F2R(MMD_ADDR_SET_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
    ee0e:	6863      	ldr	r3, [r4, #4]
    ee10:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    ee14:	f043 6320 	orr.w	r3, r3, #167772160	; 0xa000000
            clientObj->vendorData =
    ee18:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_PENDING;
    ee1a:	2301      	movs	r3, #1
    ee1c:	f88d 300f 	strb.w	r3, [sp, #15]
    ee20:	e7b3      	b.n	ed8a <Lan867x_Miim_Task+0x5e>
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Write(
    ee22:	6925      	ldr	r5, [r4, #16]
    ee24:	68e3      	ldr	r3, [r4, #12]
    ee26:	f10d 020f 	add.w	r2, sp, #15
    ee2a:	9201      	str	r2, [sp, #4]
    ee2c:	2201      	movs	r2, #1
    ee2e:	9200      	str	r2, [sp, #0]
    ee30:	6b1e      	ldr	r6, [r3, #48]	; 0x30
    ee32:	b28b      	uxth	r3, r1
    ee34:	6822      	ldr	r2, [r4, #0]
    ee36:	210e      	movs	r1, #14
    ee38:	68a0      	ldr	r0, [r4, #8]
    ee3a:	47b0      	blx	r6
    ee3c:	6028      	str	r0, [r5, #0]
        if (*clientObj->miimOpHandle != 0) {
    ee3e:	6923      	ldr	r3, [r4, #16]
    ee40:	681b      	ldr	r3, [r3, #0]
    ee42:	2b00      	cmp	r3, #0
    ee44:	d0a1      	beq.n	ed8a <Lan867x_Miim_Task+0x5e>
                F2R(MMD_DATA_CONFIG_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
    ee46:	6863      	ldr	r3, [r4, #4]
    ee48:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    ee4c:	f043 6340 	orr.w	r3, r3, #201326592	; 0xc000000
            clientObj->vendorData =
    ee50:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_PENDING;
    ee52:	2301      	movs	r3, #1
    ee54:	f88d 300f 	strb.w	r3, [sp, #15]
    ee58:	e797      	b.n	ed8a <Lan867x_Miim_Task+0x5e>
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Write(
    ee5a:	6926      	ldr	r6, [r4, #16]
        mmdData = (F2R_((regAddr >> 16), PHY_MMDCTRL_DEVAD) | F2R_(1, PHY_MMDCTRL_FNCTN));
    ee5c:	f3c1 4304 	ubfx	r3, r1, #16, #5
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Write(
    ee60:	68e2      	ldr	r2, [r4, #12]
    ee62:	f10d 010f 	add.w	r1, sp, #15
    ee66:	9101      	str	r1, [sp, #4]
    ee68:	2101      	movs	r1, #1
    ee6a:	9100      	str	r1, [sp, #0]
    ee6c:	6b17      	ldr	r7, [r2, #48]	; 0x30
    ee6e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    ee72:	6822      	ldr	r2, [r4, #0]
    ee74:	210d      	movs	r1, #13
    ee76:	68a0      	ldr	r0, [r4, #8]
    ee78:	47b8      	blx	r7
    ee7a:	6030      	str	r0, [r6, #0]
        if (*clientObj->miimOpHandle != 0) {
    ee7c:	6923      	ldr	r3, [r4, #16]
    ee7e:	681b      	ldr	r3, [r3, #0]
    ee80:	2b00      	cmp	r3, #0
    ee82:	d082      	beq.n	ed8a <Lan867x_Miim_Task+0x5e>
            if (opType == DRV_MIIM_OP_READ) {
    ee84:	2d01      	cmp	r5, #1
                    F2R(MMD_DATA_READ_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
    ee86:	6863      	ldr	r3, [r4, #4]
    ee88:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    ee8c:	bf0c      	ite	eq
    ee8e:	f043 6360 	orreq.w	r3, r3, #234881024	; 0xe000000
                    F2R(MMD_DATA_WRITE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
    ee92:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
    ee96:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_PENDING;
    ee98:	2301      	movs	r3, #1
    ee9a:	f88d 300f 	strb.w	r3, [sp, #15]
    ee9e:	e774      	b.n	ed8a <Lan867x_Miim_Task+0x5e>
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Read(
    eea0:	6925      	ldr	r5, [r4, #16]
    eea2:	68e3      	ldr	r3, [r4, #12]
    eea4:	f10d 020f 	add.w	r2, sp, #15
    eea8:	9200      	str	r2, [sp, #0]
    eeaa:	6ade      	ldr	r6, [r3, #44]	; 0x2c
    eeac:	2300      	movs	r3, #0
    eeae:	6822      	ldr	r2, [r4, #0]
    eeb0:	210e      	movs	r1, #14
    eeb2:	68a0      	ldr	r0, [r4, #8]
    eeb4:	47b0      	blx	r6
    eeb6:	6028      	str	r0, [r5, #0]
        if (*clientObj->miimOpHandle != 0) {
    eeb8:	6923      	ldr	r3, [r4, #16]
    eeba:	681b      	ldr	r3, [r3, #0]
    eebc:	2b00      	cmp	r3, #0
    eebe:	f43f af64 	beq.w	ed8a <Lan867x_Miim_Task+0x5e>
                F2R(READ_RESULT_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
    eec2:	6863      	ldr	r3, [r4, #4]
    eec4:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    eec8:	f043 63c0 	orr.w	r3, r3, #100663296	; 0x6000000
            clientObj->vendorData =
    eecc:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_PENDING;
    eece:	2301      	movs	r3, #1
    eed0:	f88d 300f 	strb.w	r3, [sp, #15]
    eed4:	e759      	b.n	ed8a <Lan867x_Miim_Task+0x5e>
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Write(
    eed6:	6925      	ldr	r5, [r4, #16]
    eed8:	68e2      	ldr	r2, [r4, #12]
    eeda:	f10d 010f 	add.w	r1, sp, #15
    eede:	9101      	str	r1, [sp, #4]
    eee0:	2101      	movs	r1, #1
    eee2:	9100      	str	r1, [sp, #0]
    eee4:	6b16      	ldr	r6, [r2, #48]	; 0x30
    eee6:	881b      	ldrh	r3, [r3, #0]
    eee8:	6822      	ldr	r2, [r4, #0]
    eeea:	210e      	movs	r1, #14
    eeec:	68a0      	ldr	r0, [r4, #8]
    eeee:	47b0      	blx	r6
    eef0:	6028      	str	r0, [r5, #0]
        if (*clientObj->miimOpHandle != 0) {
    eef2:	6923      	ldr	r3, [r4, #16]
    eef4:	681b      	ldr	r3, [r3, #0]
    eef6:	2b00      	cmp	r3, #0
    eef8:	f43f af47 	beq.w	ed8a <Lan867x_Miim_Task+0x5e>
                F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
    eefc:	6863      	ldr	r3, [r4, #4]
    eefe:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
            clientObj->vendorData =
    ef02:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_OK;
    ef04:	2300      	movs	r3, #0
    ef06:	f88d 300f 	strb.w	r3, [sp, #15]
    ef0a:	e73e      	b.n	ed8a <Lan867x_Miim_Task+0x5e>
        opRes = DRV_MIIM_RES_OP_INTERNAL_ERR;
    ef0c:	23ec      	movs	r3, #236	; 0xec
    ef0e:	f88d 300f 	strb.w	r3, [sp, #15]
        break;
    ef12:	e73a      	b.n	ed8a <Lan867x_Miim_Task+0x5e>

Disassembly of section .text.TCPIP_ICMP_Task%228:

0000ef14 <TCPIP_ICMP_Task>:


#endif

void  TCPIP_ICMP_Task(void)
{
    ef14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ef18:	b093      	sub	sp, #76	; 0x4c
    TCPIP_MODULE_SIGNAL sigPend;

    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    ef1a:	210f      	movs	r1, #15
    ef1c:	2006      	movs	r0, #6
    ef1e:	f00f f955 	bl	1e1cc <_TCPIPStackModuleSignalGet>
    ef22:	4606      	mov	r6, r0

    if((sigPend & TCPIP_MODULE_SIGNAL_RX_PENDING) != 0)
    ef24:	f010 0f01 	tst.w	r0, #1
    ef28:	d106      	bne.n	ef38 <TCPIP_ICMP_Task+0x24>
    { //  RX signal occurred
        TCPIP_ICMP_Process();
    }

#if defined(TCPIP_STACK_USE_ICMP_CLIENT)
    if((sigPend & TCPIP_MODULE_SIGNAL_TMO) != 0)
    ef2a:	f016 0f02 	tst.w	r6, #2
    ef2e:	f040 80ac 	bne.w	f08a <TCPIP_ICMP_Task+0x176>
    { // regular TMO occurred
        TCPIP_ICMP_Timeout();
    }
#endif  // defined(TCPIP_STACK_USE_ICMP_CLIENT)

}
    ef32:	b013      	add	sp, #76	; 0x4c
    ef34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    TCPIP_MAC_PKT_ACK_RES   ackRes;



    // extract queued ICMP packets
    while((pRxPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
    ef38:	2706      	movs	r7, #6

#if defined(TCPIP_STACK_USE_ICMP_CLIENT)
            if(pRxHdr->vType == ICMP_TYPE_ECHO_REPLY && pRxHdr->vCode == ICMP_CODE_ECHO_REPLY)
            {   // echo reply; check if our own
                // Get the sequence number and identifier fields
                if(pIcmpEchoRequest != 0)
    ef3a:	f8df 91ac 	ldr.w	r9, [pc, #428]	; f0e8 <TCPIP_ICMP_Task+0x1d4>
    TCPIP_Helper_ProtectedSingleListLock(notifyList);
    ef3e:	f8df a1b4 	ldr.w	sl, [pc, #436]	; f0f4 <TCPIP_ICMP_Task+0x1e0>
    ef42:	e077      	b.n	f034 <TCPIP_ICMP_Task+0x120>
                if(TCPIP_STACK_IsBcastAddress((TCPIP_NET_IF*)pRxPkt->pktIf, &pIpv4Header->DestAddress))
    ef44:	f108 0110 	add.w	r1, r8, #16
    ef48:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    ef4a:	f010 fce9 	bl	1f920 <TCPIP_STACK_IsBcastAddress>
    ef4e:	b110      	cbz	r0, ef56 <TCPIP_ICMP_Task+0x42>
                    ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;  // ignore request
    ef50:	f06f 010e 	mvn.w	r1, #14
    ef54:	e06a      	b.n	f02c <TCPIP_ICMP_Task+0x118>
                _ICMPProcessEchoRequest((TCPIP_NET_IF*)pRxPkt->pktIf, pRxPkt, pIpv4Header->DestAddress.Val, srcAdd);
    ef56:	6aa5      	ldr	r5, [r4, #40]	; 0x28
    TCPIP_UINT16_VAL checksum;
    IPV4_PACKET ipv4Pkt;
    IPV4_HEADER* pIpv4Hdr;

    // adjust the checksum
    pTxHdr = (ICMP_PACKET*)pRxPkt->pTransportLayer;
    ef58:	69e2      	ldr	r2, [r4, #28]

    pTxHdr->vType = ICMP_TYPE_ECHO_REPLY;
    ef5a:	2300      	movs	r3, #0
    ef5c:	7013      	strb	r3, [r2, #0]
    pTxHdr->vCode = ICMP_CODE_ECHO_REPLY;
    ef5e:	7053      	strb	r3, [r2, #1]
    checksum.Val = pTxHdr->wChecksum;
    ef60:	8853      	ldrh	r3, [r2, #2]
    ef62:	4618      	mov	r0, r3
    checksum.v[0] += 8;	// Subtract 0x0800 from the checksum
    ef64:	fa5f fc83 	uxtb.w	ip, r3
    ef68:	f10c 0108 	add.w	r1, ip, #8
    ef6c:	b2c9      	uxtb	r1, r1
    ef6e:	f361 0007 	bfi	r0, r1, #0, #8
    if(checksum.v[0] < 8u)
    ef72:	2907      	cmp	r1, #7
    ef74:	d80a      	bhi.n	ef8c <TCPIP_ICMP_Task+0x78>
    {
        checksum.v[1]++;
    ef76:	f3c3 2307 	ubfx	r3, r3, #8, #8
    ef7a:	3301      	adds	r3, #1
    ef7c:	b2db      	uxtb	r3, r3
    ef7e:	f363 200f 	bfi	r0, r3, #8, #8
        if(checksum.v[1] == 0u)
    ef82:	b91b      	cbnz	r3, ef8c <TCPIP_ICMP_Task+0x78>
        {
            checksum.v[0]++;
    ef84:	f10c 0c09 	add.w	ip, ip, #9
    ef88:	f36c 0007 	bfi	r0, ip, #0, #8
        }
    }

    pTxHdr->wChecksum = checksum.Val;
    ef8c:	8050      	strh	r0, [r2, #2]
    pRxPkt->next = 0; // single packet
    ef8e:	f04f 0800 	mov.w	r8, #0
    ef92:	f8c4 8000 	str.w	r8, [r4]
            TCPIP_PKT_PacketAcknowledge(pFragPkt, TCPIP_MAC_PKT_ACK_MAC_REJECT_ERR);
        }
        return false;
    }
#else
    TCPIP_IPV4_MacPacketSwitchTxToRx(pRxPkt, true, false); 
    ef96:	4642      	mov	r2, r8
    ef98:	2101      	movs	r1, #1
    ef9a:	4620      	mov	r0, r4
    ef9c:	f009 fff6 	bl	18f8c <TCPIP_IPV4_MacPacketSwitchTxToRx>

    // set proper address fields
    pIpv4Hdr = (IPV4_HEADER*)pRxPkt->pNetLayer;
    efa0:	69a3      	ldr	r3, [r4, #24]
    ipv4Pkt.srcAddress.Val = pIpv4Hdr->SourceAddress.Val;
    efa2:	68da      	ldr	r2, [r3, #12]
    efa4:	920e      	str	r2, [sp, #56]	; 0x38
    ipv4Pkt.destAddress.Val = pIpv4Hdr->DestAddress.Val;
    efa6:	691b      	ldr	r3, [r3, #16]
    efa8:	930f      	str	r3, [sp, #60]	; 0x3c
    ipv4Pkt.netIfH = pNetIf;
    efaa:	9510      	str	r5, [sp, #64]	; 0x40
    
    TCPIP_PKT_FlightLogTx(pRxPkt, TCPIP_THIS_MODULE_ID);
    if(!TCPIP_IPV4_PktTx(&ipv4Pkt, pRxPkt, false))
    efac:	4642      	mov	r2, r8
    efae:	4621      	mov	r1, r4
    efb0:	a801      	add	r0, sp, #4
    efb2:	f7ff f9a9 	bl	e308 <TCPIP_IPV4_PktTx>
    efb6:	2800      	cmp	r0, #0
    efb8:	d13c      	bne.n	f034 <TCPIP_ICMP_Task+0x120>
    {
        TCPIP_PKT_PacketAcknowledge(pRxPkt, TCPIP_MAC_PKT_ACK_MAC_REJECT_ERR);
    efba:	463a      	mov	r2, r7
    efbc:	f06f 0105 	mvn.w	r1, #5
    efc0:	4620      	mov	r0, r4
    efc2:	f00e fe17 	bl	1dbf4 <_TCPIP_PKT_PacketAcknowledge>
        return false;
    efc6:	e035      	b.n	f034 <TCPIP_ICMP_Task+0x120>
                    if(pIcmpEchoRequest->identifier == pRxHdr->wIdentifier && pIcmpEchoRequest->sequenceNumber == pRxHdr->wSequenceNumber)
    efc8:	8902      	ldrh	r2, [r0, #8]
    efca:	88eb      	ldrh	r3, [r5, #6]
    efcc:	429a      	cmp	r2, r3
    efce:	d002      	beq.n	efd6 <TCPIP_ICMP_Task+0xc2>
            ackRes = TCPIP_MAC_PKT_ACK_TYPE_ERR;
    efd0:	f06f 010c 	mvn.w	r1, #12
    efd4:	e02a      	b.n	f02c <TCPIP_ICMP_Task+0x118>
                        if(pIcmpEchoRequest->callback)
    efd6:	6943      	ldr	r3, [r0, #20]
    efd8:	b123      	cbz	r3, efe4 <TCPIP_ICMP_Task+0xd0>
                            pIcmpEchoRequest->targetAddr.Val = srcAdd; 
    efda:	f8c0 b004 	str.w	fp, [r0, #4]
                            (*pIcmpEchoRequest->callback)(pIcmpEchoRequest, pIcmpEchoRequest, TCPIP_ICMP_ECHO_REQUEST_RES_OK);
    efde:	2200      	movs	r2, #0
    efe0:	4601      	mov	r1, r0
    efe2:	4798      	blx	r3
                        pIcmpEchoRequest = 0;    // free
    efe4:	2300      	movs	r3, #0
    efe6:	f8c9 3000 	str.w	r3, [r9]
                        ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    efea:	2102      	movs	r1, #2
    efec:	e01e      	b.n	f02c <TCPIP_ICMP_Task+0x118>
                    userData.w[0] = pRxHdr->wIdentifier;
    efee:	88ab      	ldrh	r3, [r5, #4]
    eff0:	f8ad 3000 	strh.w	r3, [sp]
                    userData.w[1] = pRxHdr->wSequenceNumber;
    eff4:	88eb      	ldrh	r3, [r5, #6]
    eff6:	f8ad 3002 	strh.w	r3, [sp, #2]
                    remoteIPAddr.Val = srcAdd;
    effa:	f8cd b004 	str.w	fp, [sp, #4]
                    _ICMPNotifyClients((TCPIP_NET_IF*)pRxPkt->pktIf, &remoteIPAddr, (void *)userData.v);
    effe:	f8d4 8028 	ldr.w	r8, [r4, #40]	; 0x28
    f002:	4650      	mov	r0, sl
    f004:	f011 fd54 	bl	20ab0 <TCPIP_Helper_ProtectedSingleListLock>
static void _ICMPNotifyClients(TCPIP_NET_HANDLE hNetIf, IPV4_ADDR * remoteIP, void * data)
{
    ICMP_LIST_NODE* dNode;

    TCPIP_Notification_Lock(&icmpRegisteredUsers);
    for(dNode = (ICMP_LIST_NODE*)icmpRegisteredUsers.list.head; dNode != 0; dNode = dNode->next)
    f008:	f8da 5000 	ldr.w	r5, [sl]
    f00c:	b13d      	cbz	r5, f01e <TCPIP_ICMP_Task+0x10a>
    {
        (*dNode->callback)(hNetIf, remoteIP, data);
    f00e:	686b      	ldr	r3, [r5, #4]
    f010:	466a      	mov	r2, sp
    f012:	a901      	add	r1, sp, #4
    f014:	4640      	mov	r0, r8
    f016:	4798      	blx	r3
    for(dNode = (ICMP_LIST_NODE*)icmpRegisteredUsers.list.head; dNode != 0; dNode = dNode->next)
    f018:	682d      	ldr	r5, [r5, #0]
    f01a:	2d00      	cmp	r5, #0
    f01c:	d1f7      	bne.n	f00e <TCPIP_ICMP_Task+0xfa>
    TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
    f01e:	4650      	mov	r0, sl
    f020:	f011 ff88 	bl	20f34 <TCPIP_Helper_ProtectedSingleListUnlock>
                    ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    f024:	2102      	movs	r1, #2
    f026:	e001      	b.n	f02c <TCPIP_ICMP_Task+0x118>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    f028:	f06f 010d 	mvn.w	r1, #13
    TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
    f02c:	463a      	mov	r2, r7
    f02e:	4620      	mov	r0, r4
    f030:	f00e fde0 	bl	1dbf4 <_TCPIP_PKT_PacketAcknowledge>
    while((pRxPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
    f034:	4638      	mov	r0, r7
    f036:	f010 fc89 	bl	1f94c <_TCPIPStackModuleRxExtract>
    f03a:	4604      	mov	r4, r0
    f03c:	2800      	cmp	r0, #0
    f03e:	f43f af74 	beq.w	ef2a <TCPIP_ICMP_Task+0x16>
            icmpTotLength = pRxPkt->totTransportLen;    // length of the 1st segment (if fragmented)
    f042:	8c22      	ldrh	r2, [r4, #32]
            if(icmpTotLength < sizeof(*pRxHdr))
    f044:	2a07      	cmp	r2, #7
    f046:	d9ef      	bls.n	f028 <TCPIP_ICMP_Task+0x114>
        pRxHdr = (ICMP_PACKET*)pRxPkt->pTransportLayer;
    f048:	69e5      	ldr	r5, [r4, #28]
        pIpv4Header = (IPV4_HEADER*)pRxPkt->pNetLayer;
    f04a:	f8d4 8018 	ldr.w	r8, [r4, #24]
        srcAdd =  pIpv4Header->SourceAddress.Val;
    f04e:	f8d8 b00c 	ldr.w	fp, [r8, #12]
            checksum = TCPIP_Helper_PacketChecksum(pRxPkt, (uint8_t*)pRxHdr, icmpTotLength, 0);
    f052:	2300      	movs	r3, #0
    f054:	4629      	mov	r1, r5
    f056:	4620      	mov	r0, r4
    f058:	f00a f8e0 	bl	1921c <TCPIP_Helper_PacketChecksum>
            if(checksum != 0)
    f05c:	b978      	cbnz	r0, f07e <TCPIP_ICMP_Task+0x16a>
            if(pRxHdr->vType == ICMP_TYPE_ECHO_REQUEST && pRxHdr->vCode == ICMP_CODE_ECHO_REQUEST)
    f05e:	882b      	ldrh	r3, [r5, #0]
    f060:	2b08      	cmp	r3, #8
    f062:	f43f af6f 	beq.w	ef44 <TCPIP_ICMP_Task+0x30>
            if(pRxHdr->vType == ICMP_TYPE_ECHO_REPLY && pRxHdr->vCode == ICMP_CODE_ECHO_REPLY)
    f066:	b96b      	cbnz	r3, f084 <TCPIP_ICMP_Task+0x170>
                if(pIcmpEchoRequest != 0)
    f068:	f8d9 0000 	ldr.w	r0, [r9]
    f06c:	2800      	cmp	r0, #0
    f06e:	d0be      	beq.n	efee <TCPIP_ICMP_Task+0xda>
                    if(pIcmpEchoRequest->identifier == pRxHdr->wIdentifier && pIcmpEchoRequest->sequenceNumber == pRxHdr->wSequenceNumber)
    f070:	8942      	ldrh	r2, [r0, #10]
    f072:	88ab      	ldrh	r3, [r5, #4]
    f074:	429a      	cmp	r2, r3
    f076:	d0a7      	beq.n	efc8 <TCPIP_ICMP_Task+0xb4>
            ackRes = TCPIP_MAC_PKT_ACK_TYPE_ERR;
    f078:	f06f 010c 	mvn.w	r1, #12
    f07c:	e7d6      	b.n	f02c <TCPIP_ICMP_Task+0x118>
                ackRes = TCPIP_MAC_PKT_ACK_CHKSUM_ERR;
    f07e:	f06f 0109 	mvn.w	r1, #9
    f082:	e7d3      	b.n	f02c <TCPIP_ICMP_Task+0x118>
            ackRes = TCPIP_MAC_PKT_ACK_TYPE_ERR;
    f084:	f06f 010c 	mvn.w	r1, #12
    f088:	e7d0      	b.n	f02c <TCPIP_ICMP_Task+0x118>
    if(icmpEchoTmo == 0)
    f08a:	4b16      	ldr	r3, [pc, #88]	; (f0e4 <TCPIP_ICMP_Task+0x1d0>)
    f08c:	681b      	ldr	r3, [r3, #0]
    f08e:	b1d3      	cbz	r3, f0c6 <TCPIP_ICMP_Task+0x1b2>
    if(pIcmpEchoRequest != 0)
    f090:	4b15      	ldr	r3, [pc, #84]	; (f0e8 <TCPIP_ICMP_Task+0x1d4>)
    f092:	681b      	ldr	r3, [r3, #0]
    f094:	2b00      	cmp	r3, #0
    f096:	f43f af4c 	beq.w	ef32 <TCPIP_ICMP_Task+0x1e>
        if((SYS_TMR_TickCountGet() - icmpEchoStart) >= icmpEchoTmo) 
    f09a:	f011 f827 	bl	200ec <SYS_TMR_TickCountGet>
    f09e:	4b13      	ldr	r3, [pc, #76]	; (f0ec <TCPIP_ICMP_Task+0x1d8>)
    f0a0:	681b      	ldr	r3, [r3, #0]
    f0a2:	1ac0      	subs	r0, r0, r3
    f0a4:	4b0f      	ldr	r3, [pc, #60]	; (f0e4 <TCPIP_ICMP_Task+0x1d0>)
    f0a6:	681b      	ldr	r3, [r3, #0]
    f0a8:	4298      	cmp	r0, r3
    f0aa:	f4ff af42 	bcc.w	ef32 <TCPIP_ICMP_Task+0x1e>
            if(pIcmpEchoRequest->callback)
    f0ae:	4b0e      	ldr	r3, [pc, #56]	; (f0e8 <TCPIP_ICMP_Task+0x1d4>)
    f0b0:	6818      	ldr	r0, [r3, #0]
    f0b2:	6943      	ldr	r3, [r0, #20]
    f0b4:	b11b      	cbz	r3, f0be <TCPIP_ICMP_Task+0x1aa>
                (*pIcmpEchoRequest->callback)(pIcmpEchoRequest, pIcmpEchoRequest, TCPIP_ICMP_ECHO_REQUEST_RES_TMO);
    f0b6:	f04f 32ff 	mov.w	r2, #4294967295
    f0ba:	4601      	mov	r1, r0
    f0bc:	4798      	blx	r3
            pIcmpEchoRequest = 0;    // free
    f0be:	4b0a      	ldr	r3, [pc, #40]	; (f0e8 <TCPIP_ICMP_Task+0x1d4>)
    f0c0:	2200      	movs	r2, #0
    f0c2:	601a      	str	r2, [r3, #0]
}
    f0c4:	e735      	b.n	ef32 <TCPIP_ICMP_Task+0x1e>
        icmpEchoTmo = (TCPIP_ICMP_ECHO_REQUEST_TIMEOUT * SYS_TMR_TickCounterFrequencyGet() + 999) / 1000;
    f0c6:	f011 f839 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
    f0ca:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
    f0ce:	fb03 f300 	mul.w	r3, r3, r0
    f0d2:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
    f0d6:	4806      	ldr	r0, [pc, #24]	; (f0f0 <TCPIP_ICMP_Task+0x1dc>)
    f0d8:	fba0 2303 	umull	r2, r3, r0, r3
    f0dc:	099b      	lsrs	r3, r3, #6
    f0de:	4a01      	ldr	r2, [pc, #4]	; (f0e4 <TCPIP_ICMP_Task+0x1d0>)
    f0e0:	6013      	str	r3, [r2, #0]
    f0e2:	e7d5      	b.n	f090 <TCPIP_ICMP_Task+0x17c>
    f0e4:	2000e378 	.word	0x2000e378
    f0e8:	2000e384 	.word	0x2000e384
    f0ec:	2000e374 	.word	0x2000e374
    f0f0:	10624dd3 	.word	0x10624dd3
    f0f4:	2000e214 	.word	0x2000e214

Disassembly of section .text.TCPIP_ARP_Initialize%229:

0000f0f8 <TCPIP_ARP_Initialize>:
{
    f0f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f0fc:	b083      	sub	sp, #12
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_UP)
    f0fe:	7f03      	ldrb	r3, [r0, #28]
    f100:	2b03      	cmp	r3, #3
    f102:	d03e      	beq.n	f182 <TCPIP_ARP_Initialize+0x8a>
    f104:	4681      	mov	r9, r0
    f106:	460d      	mov	r5, r1
    if(arpMod.initCount == 0)
    f108:	4b6d      	ldr	r3, [pc, #436]	; (f2c0 <TCPIP_ARP_Initialize+0x1c8>)
    f10a:	f8d3 800c 	ldr.w	r8, [r3, #12]
    f10e:	f1b8 0f00 	cmp.w	r8, #0
    f112:	d123      	bne.n	f15c <TCPIP_ARP_Initialize+0x64>
        if(arpData == 0)
    f114:	2900      	cmp	r1, #0
    f116:	f000 80cf 	beq.w	f2b8 <TCPIP_ARP_Initialize+0x1c0>
        arpMod.deleteOld = arpData->deleteOld;
    f11a:	790a      	ldrb	r2, [r1, #4]
    f11c:	741a      	strb	r2, [r3, #16]
        nArpIfs = stackCtrl->nIfs;
    f11e:	6804      	ldr	r4, [r0, #0]
        if(arpMod.arpCacheDcpt != 0 && (arpData->deleteOld || arpMod.nIfs != nArpIfs))
    f120:	685b      	ldr	r3, [r3, #4]
    f122:	b133      	cbz	r3, f132 <TCPIP_ARP_Initialize+0x3a>
    f124:	b91a      	cbnz	r2, f12e <TCPIP_ARP_Initialize+0x36>
    f126:	4b66      	ldr	r3, [pc, #408]	; (f2c0 <TCPIP_ARP_Initialize+0x1c8>)
    f128:	681b      	ldr	r3, [r3, #0]
    f12a:	42a3      	cmp	r3, r4
    f12c:	d001      	beq.n	f132 <TCPIP_ARP_Initialize+0x3a>
            _ARPDeleteResources();
    f12e:	f008 fc71 	bl	17a14 <_ARPDeleteResources>
        arpMod.memH = stackCtrl->memH;
    f132:	f8d9 000c 	ldr.w	r0, [r9, #12]
    f136:	4b62      	ldr	r3, [pc, #392]	; (f2c0 <TCPIP_ARP_Initialize+0x1c8>)
    f138:	6098      	str	r0, [r3, #8]
        arpMod.nIfs =  nArpIfs;
    f13a:	601c      	str	r4, [r3, #0]
        arpMod.entrySolvedTmo = arpData->entrySolvedTmo;
    f13c:	68aa      	ldr	r2, [r5, #8]
    f13e:	635a      	str	r2, [r3, #52]	; 0x34
        arpMod.entryPendingTmo = arpData->entryPendingTmo;
    f140:	68ea      	ldr	r2, [r5, #12]
    f142:	639a      	str	r2, [r3, #56]	; 0x38
        arpMod.entryRetryTmo = arpData->entryRetryTmo;
    f144:	692a      	ldr	r2, [r5, #16]
    f146:	63da      	str	r2, [r3, #60]	; 0x3c
        arpMod.permQuota = arpData->permQuota;
    f148:	696a      	ldr	r2, [r5, #20]
    f14a:	641a      	str	r2, [r3, #64]	; 0x40
        arpMod.entryRetries = arpData->retries;
    f14c:	6a2a      	ldr	r2, [r5, #32]
    f14e:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
        arpMod.entryGratRetries =  arpData->gratProbeCount;
    f152:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    f154:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
        if(arpMod.arpCacheDcpt == 0)
    f158:	685b      	ldr	r3, [r3, #4]
    f15a:	b313      	cbz	r3, f1a2 <TCPIP_ARP_Initialize+0xaa>
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
    f15c:	4c58      	ldr	r4, [pc, #352]	; (f2c0 <TCPIP_ARP_Initialize+0x1c8>)
    f15e:	6865      	ldr	r5, [r4, #4]
    f160:	f8d9 0014 	ldr.w	r0, [r9, #20]
    f164:	f012 fdde 	bl	21d24 <TCPIP_STACK_NetIxGet>
    if(arpMod.deleteOld)
    f168:	7c23      	ldrb	r3, [r4, #16]
    f16a:	2b00      	cmp	r3, #0
    f16c:	f040 809d 	bne.w	f2aa <TCPIP_ARP_Initialize+0x1b2>
    arpMod.initCount++;
    f170:	4a53      	ldr	r2, [pc, #332]	; (f2c0 <TCPIP_ARP_Initialize+0x1c8>)
    f172:	68d3      	ldr	r3, [r2, #12]
    f174:	3301      	adds	r3, #1
    f176:	60d3      	str	r3, [r2, #12]
    return true;
    f178:	2401      	movs	r4, #1
}
    f17a:	4620      	mov	r0, r4
    f17c:	b003      	add	sp, #12
    f17e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(arpMod.deleteOld)
    f182:	4b4f      	ldr	r3, [pc, #316]	; (f2c0 <TCPIP_ARP_Initialize+0x1c8>)
    f184:	7c1c      	ldrb	r4, [r3, #16]
    f186:	b90c      	cbnz	r4, f18c <TCPIP_ARP_Initialize+0x94>
        return true;
    f188:	2401      	movs	r4, #1
    f18a:	e7f6      	b.n	f17a <TCPIP_ARP_Initialize+0x82>
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
    f18c:	685d      	ldr	r5, [r3, #4]
    f18e:	6940      	ldr	r0, [r0, #20]
    f190:	f012 fdc8 	bl	21d24 <TCPIP_STACK_NetIxGet>
    f194:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
            _ARPRemoveCacheEntries(pArpDcpt);
    f198:	eb05 00c0 	add.w	r0, r5, r0, lsl #3
    f19c:	f010 fe66 	bl	1fe6c <_ARPRemoveCacheEntries>
    f1a0:	e7eb      	b.n	f17a <TCPIP_ARP_Initialize+0x82>
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Calloc)(h, nElems, elemSize);
    f1a2:	6883      	ldr	r3, [r0, #8]
    f1a4:	2248      	movs	r2, #72	; 0x48
    f1a6:	4621      	mov	r1, r4
    f1a8:	4798      	blx	r3
            arpMod.arpCacheDcpt = (ARP_CACHE_DCPT*)TCPIP_HEAP_Calloc(arpMod.memH, arpMod.nIfs, sizeof(*arpMod.arpCacheDcpt)); 
    f1aa:	4b45      	ldr	r3, [pc, #276]	; (f2c0 <TCPIP_ARP_Initialize+0x1c8>)
    f1ac:	6058      	str	r0, [r3, #4]
            if(arpMod.arpCacheDcpt == 0)
    f1ae:	2800      	cmp	r0, #0
    f1b0:	f000 8084 	beq.w	f2bc <TCPIP_ARP_Initialize+0x1c4>
            hashMemSize = sizeof(OA_HASH_DCPT) + arpData->cacheEntries * sizeof(ARP_HASH_ENTRY);
    f1b4:	682b      	ldr	r3, [r5, #0]
    f1b6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    f1ba:	00db      	lsls	r3, r3, #3
    f1bc:	3328      	adds	r3, #40	; 0x28
    f1be:	9301      	str	r3, [sp, #4]
            for(ix = 0, pArpDcpt = arpMod.arpCacheDcpt; ix < arpMod.nIfs; ix++, pArpDcpt++)
    f1c0:	4b3f      	ldr	r3, [pc, #252]	; (f2c0 <TCPIP_ARP_Initialize+0x1c8>)
    f1c2:	681b      	ldr	r3, [r3, #0]
    f1c4:	2b00      	cmp	r3, #0
    f1c6:	dd53      	ble.n	f270 <TCPIP_ARP_Initialize+0x178>
    f1c8:	f100 062c 	add.w	r6, r0, #44	; 0x2c
                hashDcpt = (OA_HASH_DCPT*)TCPIP_HEAP_Malloc(arpMod.memH, hashMemSize);
    f1cc:	f8df a0f0 	ldr.w	sl, [pc, #240]	; f2c0 <TCPIP_ARP_Initialize+0x1c8>
                pArpDcpt->purgeThres = (arpData->purgeThres * pArpDcpt->hashDcpt->hEntries + 99)/100;
    f1d0:	f8df b104 	ldr.w	fp, [pc, #260]	; f2d8 <TCPIP_ARP_Initialize+0x1e0>
    f1d4:	e022      	b.n	f21c <TCPIP_ARP_Initialize+0x124>
                    _ARPDeleteResources();
    f1d6:	f008 fc1d 	bl	17a14 <_ARPDeleteResources>
                    return false;
    f1da:	2400      	movs	r4, #0
    f1dc:	e7cd      	b.n	f17a <TCPIP_ARP_Initialize+0x82>
                    if((iniRes = TCPIP_Helper_ProtectedSingleListInitialize(&pArpDcpt->completeList)) == false)
    f1de:	f1a6 0014 	sub.w	r0, r6, #20
    f1e2:	f011 faf0 	bl	207c6 <TCPIP_Helper_ProtectedSingleListInitialize>
    f1e6:	2800      	cmp	r0, #0
    f1e8:	d03e      	beq.n	f268 <TCPIP_ARP_Initialize+0x170>
                    iniRes = TCPIP_Helper_ProtectedSingleListInitialize(&pArpDcpt->incompleteList);
    f1ea:	4630      	mov	r0, r6
    f1ec:	f011 faeb 	bl	207c6 <TCPIP_Helper_ProtectedSingleListInitialize>
                if(iniRes == false)
    f1f0:	2800      	cmp	r0, #0
    f1f2:	d039      	beq.n	f268 <TCPIP_ARP_Initialize+0x170>
                pArpDcpt->purgeThres = (arpData->purgeThres * pArpDcpt->hashDcpt->hEntries + 99)/100;
    f1f4:	f856 3c2c 	ldr.w	r3, [r6, #-44]
    f1f8:	68da      	ldr	r2, [r3, #12]
    f1fa:	69ab      	ldr	r3, [r5, #24]
    f1fc:	fb03 f302 	mul.w	r3, r3, r2
    f200:	3363      	adds	r3, #99	; 0x63
    f202:	fbab 2303 	umull	r2, r3, fp, r3
    f206:	095b      	lsrs	r3, r3, #5
    f208:	6173      	str	r3, [r6, #20]
                pArpDcpt->purgeQuanta = arpData->purgeQuanta;
    f20a:	69eb      	ldr	r3, [r5, #28]
    f20c:	61b3      	str	r3, [r6, #24]
            for(ix = 0, pArpDcpt = arpMod.arpCacheDcpt; ix < arpMod.nIfs; ix++, pArpDcpt++)
    f20e:	f108 0801 	add.w	r8, r8, #1
    f212:	3648      	adds	r6, #72	; 0x48
    f214:	f8da 3000 	ldr.w	r3, [sl]
    f218:	4543      	cmp	r3, r8
    f21a:	dd29      	ble.n	f270 <TCPIP_ARP_Initialize+0x178>
    f21c:	f1a6 072c 	sub.w	r7, r6, #44	; 0x2c
                hashDcpt = (OA_HASH_DCPT*)TCPIP_HEAP_Malloc(arpMod.memH, hashMemSize);
    f220:	f8da 0008 	ldr.w	r0, [sl, #8]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
    f224:	6843      	ldr	r3, [r0, #4]
    f226:	9901      	ldr	r1, [sp, #4]
    f228:	4798      	blx	r3
                if(hashDcpt == 0)
    f22a:	4604      	mov	r4, r0
    f22c:	2800      	cmp	r0, #0
    f22e:	d0d2      	beq.n	f1d6 <TCPIP_ARP_Initialize+0xde>
                hashDcpt->memBlk = hashDcpt + 1;
    f230:	f100 0328 	add.w	r3, r0, #40	; 0x28
    f234:	6003      	str	r3, [r0, #0]
                hashDcpt->hParam = pArpDcpt;    // store the descriptor it belongs to
    f236:	6047      	str	r7, [r0, #4]
                hashDcpt->hEntrySize = sizeof(ARP_HASH_ENTRY);
    f238:	2318      	movs	r3, #24
    f23a:	6083      	str	r3, [r0, #8]
                hashDcpt->hEntries = arpData->cacheEntries;
    f23c:	682b      	ldr	r3, [r5, #0]
    f23e:	60c3      	str	r3, [r0, #12]
                hashDcpt->probeStep = ARP_HASH_PROBE_STEP;
    f240:	2301      	movs	r3, #1
    f242:	6103      	str	r3, [r0, #16]
                hashDcpt->hashF = TCPIP_ARP_HashKeyHash;
    f244:	4b1f      	ldr	r3, [pc, #124]	; (f2c4 <TCPIP_ARP_Initialize+0x1cc>)
    f246:	6143      	str	r3, [r0, #20]
                hashDcpt->delF = TCPIP_ARP_HashEntryDelete;
    f248:	4b1f      	ldr	r3, [pc, #124]	; (f2c8 <TCPIP_ARP_Initialize+0x1d0>)
    f24a:	6183      	str	r3, [r0, #24]
                hashDcpt->cmpF = TCPIP_ARP_HashKeyCompare;
    f24c:	4b1f      	ldr	r3, [pc, #124]	; (f2cc <TCPIP_ARP_Initialize+0x1d4>)
    f24e:	61c3      	str	r3, [r0, #28]
                hashDcpt->cpyF = TCPIP_ARP_HashKeyCopy; 
    f250:	4b1f      	ldr	r3, [pc, #124]	; (f2d0 <TCPIP_ARP_Initialize+0x1d8>)
    f252:	6203      	str	r3, [r0, #32]
                TCPIP_OAHASH_Initialize(hashDcpt);
    f254:	f011 f84b 	bl	202ee <TCPIP_OAHASH_Initialize>
                pArpDcpt->hashDcpt = hashDcpt;
    f258:	f846 4c2c 	str.w	r4, [r6, #-44]
                    if((iniRes = TCPIP_Helper_ProtectedSingleListInitialize(&pArpDcpt->permList)) == false)
    f25c:	f1a6 0028 	sub.w	r0, r6, #40	; 0x28
    f260:	f011 fab1 	bl	207c6 <TCPIP_Helper_ProtectedSingleListInitialize>
    f264:	2800      	cmp	r0, #0
    f266:	d1ba      	bne.n	f1de <TCPIP_ARP_Initialize+0xe6>
                    _ARPDeleteResources();
    f268:	f008 fbd4 	bl	17a14 <_ARPDeleteResources>
                    return false;
    f26c:	2400      	movs	r4, #0
    f26e:	e784      	b.n	f17a <TCPIP_ARP_Initialize+0x82>
            arpMod.pMacPkt = _ARPAllocateTxPacket();
    f270:	f011 f8f6 	bl	20460 <_ARPAllocateTxPacket>
    f274:	4c12      	ldr	r4, [pc, #72]	; (f2c0 <TCPIP_ARP_Initialize+0x1c8>)
    f276:	64a0      	str	r0, [r4, #72]	; 0x48
            arpMod.timerHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_ARP_Task, TCPIP_ARP_TASK_PROCESS_RATE);
    f278:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
    f27c:	4915      	ldr	r1, [pc, #84]	; (f2d4 <TCPIP_ARP_Initialize+0x1dc>)
    f27e:	2002      	movs	r0, #2
    f280:	f00d fe9e 	bl	1cfc0 <_TCPIPStackSignalHandlerRegister>
    f284:	61e0      	str	r0, [r4, #28]
            iniRes = TCPIP_Notification_Initialize(&arpMod.registeredUsers);
    f286:	f104 0020 	add.w	r0, r4, #32
    f28a:	f012 ff7c 	bl	22186 <TCPIP_Notification_Initialize>
            if(arpMod.pMacPkt == 0 || arpMod.timerHandle == 0 || iniRes == false)
    f28e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    f290:	b13b      	cbz	r3, f2a2 <TCPIP_ARP_Initialize+0x1aa>
    f292:	69e3      	ldr	r3, [r4, #28]
    f294:	b12b      	cbz	r3, f2a2 <TCPIP_ARP_Initialize+0x1aa>
    f296:	b120      	cbz	r0, f2a2 <TCPIP_ARP_Initialize+0x1aa>
            arpMod.timeSeconds = arpMod.timeMs = 0;
    f298:	4b09      	ldr	r3, [pc, #36]	; (f2c0 <TCPIP_ARP_Initialize+0x1c8>)
    f29a:	2200      	movs	r2, #0
    f29c:	619a      	str	r2, [r3, #24]
    f29e:	615a      	str	r2, [r3, #20]
    f2a0:	e75c      	b.n	f15c <TCPIP_ARP_Initialize+0x64>
                _ARPDeleteResources();
    f2a2:	f008 fbb7 	bl	17a14 <_ARPDeleteResources>
                return false;
    f2a6:	2400      	movs	r4, #0
    f2a8:	e767      	b.n	f17a <TCPIP_ARP_Initialize+0x82>
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
    f2aa:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
        _ARPRemoveCacheEntries(pArpDcpt);
    f2ae:	eb05 00c0 	add.w	r0, r5, r0, lsl #3
    f2b2:	f010 fddb 	bl	1fe6c <_ARPRemoveCacheEntries>
    f2b6:	e75b      	b.n	f170 <TCPIP_ARP_Initialize+0x78>
            return false;
    f2b8:	2400      	movs	r4, #0
    f2ba:	e75e      	b.n	f17a <TCPIP_ARP_Initialize+0x82>
                return false;
    f2bc:	2400      	movs	r4, #0
    f2be:	e75c      	b.n	f17a <TCPIP_ARP_Initialize+0x82>
    f2c0:	2000dfa4 	.word	0x2000dfa4
    f2c4:	000214fd 	.word	0x000214fd
    f2c8:	0001f149 	.word	0x0001f149
    f2cc:	00021fc1 	.word	0x00021fc1
    f2d0:	00022221 	.word	0x00022221
    f2d4:	0000c929 	.word	0x0000c929
    f2d8:	51eb851f 	.word	0x51eb851f

Disassembly of section .text.xTaskCreate%230:

0000f2dc <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    f2dc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f2e0:	4680      	mov	r8, r0
    f2e2:	460e      	mov	r6, r1
    f2e4:	4699      	mov	r9, r3
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    f2e6:	0095      	lsls	r5, r2, #2
    f2e8:	4628      	mov	r0, r5
    f2ea:	f00b fc0d 	bl	1ab08 <pvPortMalloc>

			if( pxStack != NULL )
    f2ee:	2800      	cmp	r0, #0
    f2f0:	f000 80c2 	beq.w	f478 <xTaskCreate+0x19c>
    f2f4:	4607      	mov	r7, r0
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    f2f6:	2054      	movs	r0, #84	; 0x54
    f2f8:	f00b fc06 	bl	1ab08 <pvPortMalloc>

				if( pxNewTCB != NULL )
    f2fc:	4604      	mov	r4, r0
    f2fe:	2800      	cmp	r0, #0
    f300:	f000 8081 	beq.w	f406 <xTaskCreate+0x12a>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    f304:	6307      	str	r7, [r0, #48]	; 0x30

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    f306:	462a      	mov	r2, r5
    f308:	21a5      	movs	r1, #165	; 0xa5
    f30a:	4638      	mov	r0, r7
    f30c:	f012 fcbe 	bl	21c8c <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    f310:	6b27      	ldr	r7, [r4, #48]	; 0x30
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    f312:	2e00      	cmp	r6, #0
    f314:	d07d      	beq.n	f412 <xTaskCreate+0x136>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    f316:	7833      	ldrb	r3, [r6, #0]
    f318:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    f31c:	b153      	cbz	r3, f334 <xTaskCreate+0x58>
    f31e:	4633      	mov	r3, r6
    f320:	f104 0134 	add.w	r1, r4, #52	; 0x34
    f324:	360f      	adds	r6, #15
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    f326:	f813 2f01 	ldrb.w	r2, [r3, #1]!
    f32a:	f801 2f01 	strb.w	r2, [r1, #1]!
			if( pcName[ x ] == ( char ) 0x00 )
    f32e:	b10a      	cbz	r2, f334 <xTaskCreate+0x58>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    f330:	42b3      	cmp	r3, r6
    f332:	d1f8      	bne.n	f326 <xTaskCreate+0x4a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    f334:	2300      	movs	r3, #0
    f336:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    f33a:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    f33c:	2e04      	cmp	r6, #4
    f33e:	bf28      	it	cs
    f340:	2604      	movcs	r6, #4
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    f342:	62e6      	str	r6, [r4, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    f344:	6466      	str	r6, [r4, #68]	; 0x44
		pxNewTCB->uxMutexesHeld = 0;
    f346:	f04f 0b00 	mov.w	fp, #0
    f34a:	f8c4 b048 	str.w	fp, [r4, #72]	; 0x48
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    f34e:	f104 0a04 	add.w	sl, r4, #4
    f352:	4650      	mov	r0, sl
    f354:	f012 ff6d 	bl	22232 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    f358:	f104 0018 	add.w	r0, r4, #24
    f35c:	f012 ff69 	bl	22232 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    f360:	6124      	str	r4, [r4, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    f362:	f1c6 0605 	rsb	r6, r6, #5
    f366:	61a6      	str	r6, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    f368:	6264      	str	r4, [r4, #36]	; 0x24
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    f36a:	f8c4 b04c 	str.w	fp, [r4, #76]	; 0x4c
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    f36e:	f884 b050 	strb.w	fp, [r4, #80]	; 0x50
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    f372:	3d04      	subs	r5, #4
    f374:	443d      	add	r5, r7
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    f376:	464a      	mov	r2, r9
    f378:	4641      	mov	r1, r8
    f37a:	f025 0007 	bic.w	r0, r5, #7
    f37e:	f010 fb69 	bl	1fa54 <pxPortInitialiseStack>
    f382:	6020      	str	r0, [r4, #0]
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    f384:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f386:	b103      	cbz	r3, f38a <xTaskCreate+0xae>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    f388:	601c      	str	r4, [r3, #0]

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    f38a:	f011 fc61 	bl	20c50 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
    f38e:	4a3e      	ldr	r2, [pc, #248]	; (f488 <xTaskCreate+0x1ac>)
    f390:	6813      	ldr	r3, [r2, #0]
    f392:	3301      	adds	r3, #1
    f394:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
    f396:	4b3d      	ldr	r3, [pc, #244]	; (f48c <xTaskCreate+0x1b0>)
    f398:	681b      	ldr	r3, [r3, #0]
    f39a:	2b00      	cmp	r3, #0
    f39c:	d03d      	beq.n	f41a <xTaskCreate+0x13e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    f39e:	4b3c      	ldr	r3, [pc, #240]	; (f490 <xTaskCreate+0x1b4>)
    f3a0:	681b      	ldr	r3, [r3, #0]
    f3a2:	b93b      	cbnz	r3, f3b4 <xTaskCreate+0xd8>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    f3a4:	4b39      	ldr	r3, [pc, #228]	; (f48c <xTaskCreate+0x1b0>)
    f3a6:	681b      	ldr	r3, [r3, #0]
    f3a8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    f3aa:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    f3ac:	429a      	cmp	r2, r3
				{
					pxCurrentTCB = pxNewTCB;
    f3ae:	bf9c      	itt	ls
    f3b0:	4b36      	ldrls	r3, [pc, #216]	; (f48c <xTaskCreate+0x1b0>)
    f3b2:	601c      	strls	r4, [r3, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    f3b4:	4a37      	ldr	r2, [pc, #220]	; (f494 <xTaskCreate+0x1b8>)
    f3b6:	6813      	ldr	r3, [r2, #0]
    f3b8:	3301      	adds	r3, #1
    f3ba:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    f3bc:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    f3be:	4a36      	ldr	r2, [pc, #216]	; (f498 <xTaskCreate+0x1bc>)
    f3c0:	6811      	ldr	r1, [r2, #0]
    f3c2:	2301      	movs	r3, #1
    f3c4:	4083      	lsls	r3, r0
    f3c6:	430b      	orrs	r3, r1
    f3c8:	6013      	str	r3, [r2, #0]
    f3ca:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    f3ce:	4651      	mov	r1, sl
    f3d0:	4b32      	ldr	r3, [pc, #200]	; (f49c <xTaskCreate+0x1c0>)
    f3d2:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    f3d6:	f012 fa36 	bl	21846 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    f3da:	f012 fb01 	bl	219e0 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
    f3de:	4b2c      	ldr	r3, [pc, #176]	; (f490 <xTaskCreate+0x1b4>)
    f3e0:	681b      	ldr	r3, [r3, #0]
    f3e2:	2b00      	cmp	r3, #0
    f3e4:	d04c      	beq.n	f480 <xTaskCreate+0x1a4>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    f3e6:	4b29      	ldr	r3, [pc, #164]	; (f48c <xTaskCreate+0x1b0>)
    f3e8:	681b      	ldr	r3, [r3, #0]
    f3ea:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    f3ec:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    f3ee:	429a      	cmp	r2, r3
    f3f0:	d248      	bcs.n	f484 <xTaskCreate+0x1a8>
		{
			taskYIELD_IF_USING_PREEMPTION();
    f3f2:	4b2b      	ldr	r3, [pc, #172]	; (f4a0 <xTaskCreate+0x1c4>)
    f3f4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    f3f8:	601a      	str	r2, [r3, #0]
    f3fa:	f3bf 8f4f 	dsb	sy
    f3fe:	f3bf 8f6f 	isb	sy
			xReturn = pdPASS;
    f402:	2001      	movs	r0, #1
    f404:	e03a      	b.n	f47c <xTaskCreate+0x1a0>
					vPortFree( pxStack );
    f406:	4638      	mov	r0, r7
    f408:	f00c f851 	bl	1b4ae <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    f40c:	f04f 30ff 	mov.w	r0, #4294967295
    f410:	e034      	b.n	f47c <xTaskCreate+0x1a0>
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    f412:	2300      	movs	r3, #0
    f414:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    f418:	e78f      	b.n	f33a <xTaskCreate+0x5e>
			pxCurrentTCB = pxNewTCB;
    f41a:	4b1c      	ldr	r3, [pc, #112]	; (f48c <xTaskCreate+0x1b0>)
    f41c:	601c      	str	r4, [r3, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    f41e:	6813      	ldr	r3, [r2, #0]
    f420:	2b01      	cmp	r3, #1
    f422:	d1c7      	bne.n	f3b4 <xTaskCreate+0xd8>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    f424:	4d1d      	ldr	r5, [pc, #116]	; (f49c <xTaskCreate+0x1c0>)
    f426:	4628      	mov	r0, r5
    f428:	f012 fa02 	bl	21830 <vListInitialise>
    f42c:	f105 0014 	add.w	r0, r5, #20
    f430:	f012 f9fe 	bl	21830 <vListInitialise>
    f434:	f105 0028 	add.w	r0, r5, #40	; 0x28
    f438:	f012 f9fa 	bl	21830 <vListInitialise>
    f43c:	f105 003c 	add.w	r0, r5, #60	; 0x3c
    f440:	f012 f9f6 	bl	21830 <vListInitialise>
    f444:	f105 0050 	add.w	r0, r5, #80	; 0x50
    f448:	f012 f9f2 	bl	21830 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
    f44c:	4e15      	ldr	r6, [pc, #84]	; (f4a4 <xTaskCreate+0x1c8>)
    f44e:	4630      	mov	r0, r6
    f450:	f012 f9ee 	bl	21830 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    f454:	4d14      	ldr	r5, [pc, #80]	; (f4a8 <xTaskCreate+0x1cc>)
    f456:	4628      	mov	r0, r5
    f458:	f012 f9ea 	bl	21830 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    f45c:	4813      	ldr	r0, [pc, #76]	; (f4ac <xTaskCreate+0x1d0>)
    f45e:	f012 f9e7 	bl	21830 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    f462:	4813      	ldr	r0, [pc, #76]	; (f4b0 <xTaskCreate+0x1d4>)
    f464:	f012 f9e4 	bl	21830 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    f468:	4812      	ldr	r0, [pc, #72]	; (f4b4 <xTaskCreate+0x1d8>)
    f46a:	f012 f9e1 	bl	21830 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    f46e:	4b12      	ldr	r3, [pc, #72]	; (f4b8 <xTaskCreate+0x1dc>)
    f470:	601e      	str	r6, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    f472:	4b12      	ldr	r3, [pc, #72]	; (f4bc <xTaskCreate+0x1e0>)
    f474:	601d      	str	r5, [r3, #0]
    f476:	e79d      	b.n	f3b4 <xTaskCreate+0xd8>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    f478:	f04f 30ff 	mov.w	r0, #4294967295
	}
    f47c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			xReturn = pdPASS;
    f480:	2001      	movs	r0, #1
    f482:	e7fb      	b.n	f47c <xTaskCreate+0x1a0>
    f484:	2001      	movs	r0, #1
		return xReturn;
    f486:	e7f9      	b.n	f47c <xTaskCreate+0x1a0>
    f488:	2000e4a8 	.word	0x2000e4a8
    f48c:	2000e49c 	.word	0x2000e49c
    f490:	2000e4cc 	.word	0x2000e4cc
    f494:	2000e4b4 	.word	0x2000e4b4
    f498:	2000e4b8 	.word	0x2000e4b8
    f49c:	2000de80 	.word	0x2000de80
    f4a0:	e000ed04 	.word	0xe000ed04
    f4a4:	2000e28c 	.word	0x2000e28c
    f4a8:	2000e2a0 	.word	0x2000e2a0
    f4ac:	2000e2b4 	.word	0x2000e2b4
    f4b0:	2000e2dc 	.word	0x2000e2dc
    f4b4:	2000e2c8 	.word	0x2000e2c8
    f4b8:	2000e4a0 	.word	0x2000e4a0
    f4bc:	2000e4a4 	.word	0x2000e4a4

Disassembly of section .text._DHCPReceive%231:

0000f4c0 <_DHCPReceive>:
{
    f4c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f4c4:	b0e1      	sub	sp, #388	; 0x184
    f4c6:	4606      	mov	r6, r0
    s = dhcpClientSocket;
    f4c8:	4b70      	ldr	r3, [pc, #448]	; (f68c <_DHCPReceive+0x1cc>)
    f4ca:	f9b3 4000 	ldrsh.w	r4, [r3]
        TCPIP_UDP_ArrayGet(s, &dhcpHdr.op, sizeof(dhcpHdr));
    f4ce:	222c      	movs	r2, #44	; 0x2c
    f4d0:	a955      	add	r1, sp, #340	; 0x154
    f4d2:	4620      	mov	r0, r4
    f4d4:	f005 fee8 	bl	152a8 <TCPIP_UDP_ArrayGet>
        if ( dhcpHdr.op != TCPIP_BOOT_REPLY )
    f4d8:	f89d 3154 	ldrb.w	r3, [sp, #340]	; 0x154
    f4dc:	2b02      	cmp	r3, #2
    f4de:	d004      	beq.n	f4ea <_DHCPReceive+0x2a>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
    f4e0:	2500      	movs	r5, #0
        TCPIP_UDP_Discard(s);                     
    f4e2:	4620      	mov	r0, r4
    f4e4:	f011 f991 	bl	2080a <TCPIP_UDP_Discard>
    return msgType;
    f4e8:	e05a      	b.n	f5a0 <_DHCPReceive+0xe0>
        if(TCPIP_UDP_ArrayGet(s, 0, sizeof(TCPIP_DHCP_FRAME_OPT_HEADER)) != sizeof(TCPIP_DHCP_FRAME_OPT_HEADER))
    f4ea:	22c0      	movs	r2, #192	; 0xc0
    f4ec:	2100      	movs	r1, #0
    f4ee:	4620      	mov	r0, r4
    f4f0:	f005 feda 	bl	152a8 <TCPIP_UDP_ArrayGet>
    f4f4:	28c0      	cmp	r0, #192	; 0xc0
    f4f6:	d001      	beq.n	f4fc <_DHCPReceive+0x3c>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
    f4f8:	2500      	movs	r5, #0
    f4fa:	e7f2      	b.n	f4e2 <_DHCPReceive+0x22>
        optSize = (int32_t)TCPIP_UDP_ArrayGet(s, dhcpOpt.cookie, sizeof(dhcpOpt));
    f4fc:	f44f 729c 	mov.w	r2, #312	; 0x138
    f500:	a907      	add	r1, sp, #28
    f502:	4620      	mov	r0, r4
    f504:	f005 fed0 	bl	152a8 <TCPIP_UDP_ArrayGet>
    f508:	4681      	mov	r9, r0
        if(optSize < sizeof(dhcpOpt.cookie) || (memcmp(dhcpOpt.cookie, dhcpMagicCookie, sizeof(dhcpOpt.cookie)) != 0))
    f50a:	2803      	cmp	r0, #3
    f50c:	f240 8091 	bls.w	f632 <_DHCPReceive+0x172>
    f510:	2204      	movs	r2, #4
    f512:	495f      	ldr	r1, [pc, #380]	; (f690 <_DHCPReceive+0x1d0>)
    f514:	a807      	add	r0, sp, #28
    f516:	f011 fe25 	bl	21164 <memcmp>
    f51a:	4605      	mov	r5, r0
    f51c:	b108      	cbz	r0, f522 <_DHCPReceive+0x62>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
    f51e:	2500      	movs	r5, #0
    f520:	e7df      	b.n	f4e2 <_DHCPReceive+0x22>
        nNets = TCPIP_STACK_NumberOfNetworksGet();
    f522:	f012 fd77 	bl	22014 <TCPIP_STACK_NumberOfNetworksGet>
        pSrchClient = DHCPClients; 
    f526:	4b5b      	ldr	r3, [pc, #364]	; (f694 <_DHCPReceive+0x1d4>)
    f528:	681f      	ldr	r7, [r3, #0]
        for(netIx = 0; netIx < nNets; netIx++, pSrchClient++) 
    f52a:	f1b0 0800 	subs.w	r8, r0, #0
    f52e:	f340 808d 	ble.w	f64c <_DHCPReceive+0x18c>
            if(pSrchClient->smState == TCPIP_DHCP_GET_OFFER || pSrchClient->smState == TCPIP_DHCP_GET_REQUEST_ACK ||
    f532:	f240 2a85 	movw	sl, #645	; 0x285
                if(dhcpHdr.xid == pSrchClient->transactionID.Val && memcmp(dhcpHdr.chaddr, _TCPIPStack_NetMACAddressGet(pIf), sizeof(TCPIP_MAC_ADDR)) == 0)
    f536:	f04f 0b06 	mov.w	fp, #6
    f53a:	e007      	b.n	f54c <_DHCPReceive+0x8c>
    f53c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    f53e:	9a56      	ldr	r2, [sp, #344]	; 0x158
    f540:	429a      	cmp	r2, r3
    f542:	d01f      	beq.n	f584 <_DHCPReceive+0xc4>
        for(netIx = 0; netIx < nNets; netIx++, pSrchClient++) 
    f544:	3501      	adds	r5, #1
    f546:	375c      	adds	r7, #92	; 0x5c
    f548:	45a8      	cmp	r8, r5
    f54a:	d07f      	beq.n	f64c <_DHCPReceive+0x18c>
            pIf = (TCPIP_NET_IF*)TCPIP_STACK_IndexToNet (netIx);
    f54c:	4628      	mov	r0, r5
    f54e:	f010 fd05 	bl	1ff5c <TCPIP_STACK_IndexToNet>
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
    f552:	4601      	mov	r1, r0
    f554:	2800      	cmp	r0, #0
    f556:	d0f5      	beq.n	f544 <_DHCPReceive+0x84>
    f558:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
    f55c:	f013 0f40 	tst.w	r3, #64	; 0x40
    f560:	d0f0      	beq.n	f544 <_DHCPReceive+0x84>
            if(!TCPIP_STACK_NetworkIsUp(pIf) || pSrchClient->flags.bDHCPEnabled == false)
    f562:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
    f566:	f013 0f01 	tst.w	r3, #1
    f56a:	d0eb      	beq.n	f544 <_DHCPReceive+0x84>
            if(pSrchClient->smState == TCPIP_DHCP_GET_OFFER || pSrchClient->smState == TCPIP_DHCP_GET_REQUEST_ACK ||
    f56c:	f8b7 3056 	ldrh.w	r3, [r7, #86]	; 0x56
    f570:	3b03      	subs	r3, #3
    f572:	b29b      	uxth	r3, r3
    f574:	2b09      	cmp	r3, #9
    f576:	d8e5      	bhi.n	f544 <_DHCPReceive+0x84>
    f578:	fa2a f303 	lsr.w	r3, sl, r3
    f57c:	f013 0f01 	tst.w	r3, #1
    f580:	d1dc      	bne.n	f53c <_DHCPReceive+0x7c>
    f582:	e7df      	b.n	f544 <_DHCPReceive+0x84>
                if(dhcpHdr.xid == pSrchClient->transactionID.Val && memcmp(dhcpHdr.chaddr, _TCPIPStack_NetMACAddressGet(pIf), sizeof(TCPIP_MAC_ADDR)) == 0)
    f584:	465a      	mov	r2, fp
    f586:	313c      	adds	r1, #60	; 0x3c
    f588:	a85c      	add	r0, sp, #368	; 0x170
    f58a:	f011 fdeb 	bl	21164 <memcmp>
    f58e:	2800      	cmp	r0, #0
    f590:	d1d8      	bne.n	f544 <_DHCPReceive+0x84>
        if(pClient != pOwner)
    f592:	42be      	cmp	r6, r7
    f594:	d05c      	beq.n	f650 <_DHCPReceive+0x190>
        TCPIP_UDP_RxOffsetSet(s, 0);
    f596:	2100      	movs	r1, #0
    f598:	4620      	mov	r0, r4
    f59a:	f00f fb0f 	bl	1ebbc <TCPIP_UDP_RxOffsetSet>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
    f59e:	2500      	movs	r5, #0
}
    f5a0:	4628      	mov	r0, r5
    f5a2:	b061      	add	sp, #388	; 0x184
    f5a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        pEntry = _DHCPOptProcTbl;
    f5a8:	4b3b      	ldr	r3, [pc, #236]	; (f698 <_DHCPReceive+0x1d8>)
                optLen = (*pEntry->dhcpProcFnc)(pClient, pOptData);
    f5aa:	685b      	ldr	r3, [r3, #4]
    f5ac:	4669      	mov	r1, sp
    f5ae:	4630      	mov	r0, r6
    f5b0:	4798      	blx	r3
                if(optLen > 0)
    f5b2:	2800      	cmp	r0, #0
    f5b4:	dd06      	ble.n	f5c4 <_DHCPReceive+0x104>
                    pOptData->pOpt += optLen;
    f5b6:	9b00      	ldr	r3, [sp, #0]
    f5b8:	4403      	add	r3, r0
    f5ba:	9300      	str	r3, [sp, #0]
                    pOptData->optSize -= optLen;
    f5bc:	9b01      	ldr	r3, [sp, #4]
    f5be:	1a1b      	subs	r3, r3, r0
    f5c0:	9301      	str	r3, [sp, #4]
        if(optFound == false)
    f5c2:	e009      	b.n	f5d8 <_DHCPReceive+0x118>
                else if(optLen == 0)
    f5c4:	2800      	cmp	r0, #0
    f5c6:	d036      	beq.n	f636 <_DHCPReceive+0x176>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
    f5c8:	2500      	movs	r5, #0
    f5ca:	e78a      	b.n	f4e2 <_DHCPReceive+0x22>
            optLen = *(pOptData->pOpt + 1);
    f5cc:	7843      	ldrb	r3, [r0, #1]
            pOptData->pOpt += optLen + 2;
    f5ce:	3302      	adds	r3, #2
    f5d0:	4418      	add	r0, r3
    f5d2:	9000      	str	r0, [sp, #0]
            pOptData->optSize -= optLen + 2;
    f5d4:	1ad3      	subs	r3, r2, r3
    f5d6:	9301      	str	r3, [sp, #4]
    while(pOptData->optSize > 0)
    f5d8:	9a01      	ldr	r2, [sp, #4]
    f5da:	2a00      	cmp	r2, #0
    f5dc:	ddf4      	ble.n	f5c8 <_DHCPReceive+0x108>
        opt = *pOptData->pOpt;
    f5de:	9800      	ldr	r0, [sp, #0]
            if(opt == pEntry->option)
    f5e0:	7801      	ldrb	r1, [r0, #0]
    f5e2:	2935      	cmp	r1, #53	; 0x35
    f5e4:	d0e0      	beq.n	f5a8 <_DHCPReceive+0xe8>
        for(optIx = 0; optIx < sizeof(_DHCPOptProcTbl) / sizeof(*_DHCPOptProcTbl); optIx++, pEntry++)
    f5e6:	f108 0308 	add.w	r3, r8, #8
            if(opt == pEntry->option)
    f5ea:	681f      	ldr	r7, [r3, #0]
    f5ec:	428f      	cmp	r7, r1
    f5ee:	d0dc      	beq.n	f5aa <_DHCPReceive+0xea>
        for(optIx = 0; optIx < sizeof(_DHCPOptProcTbl) / sizeof(*_DHCPOptProcTbl); optIx++, pEntry++)
    f5f0:	3308      	adds	r3, #8
    f5f2:	42ab      	cmp	r3, r5
    f5f4:	d1f9      	bne.n	f5ea <_DHCPReceive+0x12a>
    f5f6:	e7e9      	b.n	f5cc <_DHCPReceive+0x10c>
        if ( dhcpOptData.msgType == TCPIP_DHCP_OFFER_MESSAGE || (dhcpOptData.msgType == TCPIP_DHCP_ACK_MESSAGE && pClient->dhcpOp == TCPIP_DHCP_OPER_INIT_REBOOT))
    f5f8:	f8b6 3054 	ldrh.w	r3, [r6, #84]	; 0x54
    f5fc:	2b02      	cmp	r3, #2
    f5fe:	d005      	beq.n	f60c <_DHCPReceive+0x14c>
        else if(pClient->dwServerID != dhcpOptData.serverID.Val)
    f600:	9a03      	ldr	r2, [sp, #12]
    f602:	6a73      	ldr	r3, [r6, #36]	; 0x24
    f604:	429a      	cmp	r2, r3
    f606:	d00c      	beq.n	f622 <_DHCPReceive+0x162>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
    f608:	2500      	movs	r5, #0
    if(pOwner == 0)
    f60a:	e76a      	b.n	f4e2 <_DHCPReceive+0x22>
            pClient->dwServerID = dhcpOptData.serverID.Val;
    f60c:	9b03      	ldr	r3, [sp, #12]
    f60e:	6273      	str	r3, [r6, #36]	; 0x24
            pClient->flags.bOfferReceived = true;
    f610:	f896 3058 	ldrb.w	r3, [r6, #88]	; 0x58
    f614:	f043 0304 	orr.w	r3, r3, #4
    f618:	f886 3058 	strb.w	r3, [r6, #88]	; 0x58
        if(msgType == TCPIP_DHCP_ACK_MESSAGE)
    f61c:	2d05      	cmp	r5, #5
    f61e:	f47f af60 	bne.w	f4e2 <_DHCPReceive+0x22>
            _DHCPSetLeaseTimeParams(pClient, &dhcpOptData);
    f622:	4669      	mov	r1, sp
    f624:	4630      	mov	r0, r6
    f626:	f009 fba1 	bl	18d6c <_DHCPSetLeaseTimeParams>
        msgType = dhcpOptData.msgType;
    f62a:	2505      	movs	r5, #5
    f62c:	e759      	b.n	f4e2 <_DHCPReceive+0x22>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
    f62e:	2500      	movs	r5, #0
    f630:	e757      	b.n	f4e2 <_DHCPReceive+0x22>
    f632:	2500      	movs	r5, #0
    f634:	e755      	b.n	f4e2 <_DHCPReceive+0x22>
        if ( dhcpOptData.msgType == TCPIP_DHCP_OFFER_MESSAGE || (dhcpOptData.msgType == TCPIP_DHCP_ACK_MESSAGE && pClient->dhcpOp == TCPIP_DHCP_OPER_INIT_REBOOT))
    f636:	9d02      	ldr	r5, [sp, #8]
    f638:	2d02      	cmp	r5, #2
    f63a:	d0e7      	beq.n	f60c <_DHCPReceive+0x14c>
    f63c:	2d05      	cmp	r5, #5
    f63e:	d0db      	beq.n	f5f8 <_DHCPReceive+0x138>
        else if(pClient->dwServerID != dhcpOptData.serverID.Val)
    f640:	6a72      	ldr	r2, [r6, #36]	; 0x24
    f642:	9b03      	ldr	r3, [sp, #12]
    f644:	429a      	cmp	r2, r3
    f646:	d0e9      	beq.n	f61c <_DHCPReceive+0x15c>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
    f648:	2500      	movs	r5, #0
    f64a:	e74a      	b.n	f4e2 <_DHCPReceive+0x22>
        if(pClient != pOwner)
    f64c:	2e00      	cmp	r6, #0
    f64e:	d1ee      	bne.n	f62e <_DHCPReceive+0x16e>
        if(!pClient->flags.bOfferReceived)
    f650:	f896 3058 	ldrb.w	r3, [r6, #88]	; 0x58
    f654:	f013 0f04 	tst.w	r3, #4
    f658:	d107      	bne.n	f66a <_DHCPReceive+0x1aa>
            pClient->dhcpIPAddress.Val = dhcpHdr.yiaddr;
    f65a:	9b59      	ldr	r3, [sp, #356]	; 0x164
    f65c:	62f3      	str	r3, [r6, #44]	; 0x2c
            pClient->validValues.IPAddress = 1;
    f65e:	f896 3059 	ldrb.w	r3, [r6, #89]	; 0x59
    f662:	f043 0301 	orr.w	r3, r3, #1
    f666:	f886 3059 	strb.w	r3, [r6, #89]	; 0x59
        memset(&dhcpOptData, 0, sizeof(dhcpOptData));
    f66a:	2300      	movs	r3, #0
    f66c:	9302      	str	r3, [sp, #8]
    f66e:	9303      	str	r3, [sp, #12]
    f670:	9304      	str	r3, [sp, #16]
    f672:	9305      	str	r3, [sp, #20]
    f674:	9306      	str	r3, [sp, #24]
        dhcpOptData.pOpt = dhcpOpt.options;
    f676:	ab08      	add	r3, sp, #32
    f678:	9300      	str	r3, [sp, #0]
        dhcpOptData.optSize = optSize - sizeof(dhcpMagicCookie);   // eat up the cookie
    f67a:	f1a9 0304 	sub.w	r3, r9, #4
    f67e:	9301      	str	r3, [sp, #4]
        for(optIx = 0; optIx < sizeof(_DHCPOptProcTbl) / sizeof(*_DHCPOptProcTbl); optIx++, pEntry++)
    f680:	f8df 8014 	ldr.w	r8, [pc, #20]	; f698 <_DHCPReceive+0x1d8>
    f684:	f108 0548 	add.w	r5, r8, #72	; 0x48
    f688:	e7a6      	b.n	f5d8 <_DHCPReceive+0x118>
    f68a:	bf00      	nop
    f68c:	2000e504 	.word	0x2000e504
    f690:	00022254 	.word	0x00022254
    f694:	2000e408 	.word	0x2000e408
    f698:	0001cee8 	.word	0x0001cee8

Disassembly of section .text.GenericTxEnd%232:

0000f69c <GenericTxEnd>:
{
    f69c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    f6a0:	b085      	sub	sp, #20
    f6a2:	4604      	mov	r4, r0
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    f6a4:	f8d0 20c4 	ldr.w	r2, [r0, #196]	; 0xc4
    f6a8:	6855      	ldr	r5, [r2, #4]
    if(  pIState->remainingTxData  > 0u )
    f6aa:	f8b0 30b0 	ldrh.w	r3, [r0, #176]	; 0xb0
    f6ae:	b1db      	cbz	r3, f6e8 <GenericTxEnd+0x4c>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Socket send failed\r\n");
    f6b0:	6813      	ldr	r3, [r2, #0]
    f6b2:	681b      	ldr	r3, [r3, #0]
    f6b4:	4968      	ldr	r1, [pc, #416]	; (f858 <GenericTxEnd+0x1bc>)
    f6b6:	4628      	mov	r0, r5
    f6b8:	4798      	blx	r3
        pIState->errorCount++;
    f6ba:	6b23      	ldr	r3, [r4, #48]	; 0x30
    f6bc:	3301      	adds	r3, #1
    f6be:	6323      	str	r3, [r4, #48]	; 0x30
    pIState->lastPktId = pIState->pktId - 1;
    f6c0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    f6c2:	3b01      	subs	r3, #1
    f6c4:	62e3      	str	r3, [r4, #44]	; 0x2c
    if ( (int32_t)(SYS_TMR_TickCountGet() - pIState->lastCheckTime) >= (pIState->mInterval - TCPIP_IPERF_TIMING_ERROR_MARGIN) )
    f6c6:	f010 fd11 	bl	200ec <SYS_TMR_TickCountGet>
    f6ca:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
    f6ce:	1ac0      	subs	r0, r0, r3
    f6d0:	6823      	ldr	r3, [r4, #0]
    f6d2:	4298      	cmp	r0, r3
    f6d4:	f080 8086 	bcs.w	f7e4 <GenericTxEnd+0x148>
    if ( pIState->isLastTransmit == true )
    f6d8:	f894 30d0 	ldrb.w	r3, [r4, #208]	; 0xd0
    f6dc:	2b01      	cmp	r3, #1
    f6de:	f000 8086 	beq.w	f7ee <GenericTxEnd+0x152>
}
    f6e2:	b005      	add	sp, #20
    f6e4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if ( pIState->pktCount == 0u )
    f6e8:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
    f6ec:	2b00      	cmp	r3, #0
    f6ee:	d153      	bne.n	f798 <GenericTxEnd+0xfc>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: instance %d started ...\r\n", pIState - gIperfState);
    f6f0:	4b5a      	ldr	r3, [pc, #360]	; (f85c <GenericTxEnd+0x1c0>)
    f6f2:	1ac3      	subs	r3, r0, r3
    f6f4:	10db      	asrs	r3, r3, #3
    f6f6:	eb03 01c3 	add.w	r1, r3, r3, lsl #3
    f6fa:	eb03 0341 	add.w	r3, r3, r1, lsl #1
    f6fe:	ebc3 2343 	rsb	r3, r3, r3, lsl #9
    f702:	eb03 4383 	add.w	r3, r3, r3, lsl #18
    f706:	4e56      	ldr	r6, [pc, #344]	; (f860 <GenericTxEnd+0x1c4>)
    f708:	6812      	ldr	r2, [r2, #0]
    f70a:	6857      	ldr	r7, [r2, #4]
    f70c:	425a      	negs	r2, r3
    f70e:	f206 5164 	addw	r1, r6, #1380	; 0x564
    f712:	4628      	mov	r0, r5
    f714:	47b8      	blx	r7
            lclAddress.Val = TCPIP_STACK_NetAddress(pIState->pNetIf);
    f716:	f8d4 00c8 	ldr.w	r0, [r4, #200]	; 0xc8
    f71a:	f011 fb16 	bl	20d4a <TCPIP_STACK_NetAddress>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Local  %u.%u.%u.%u port %u connected with\r\n",
    f71e:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    f722:	681b      	ldr	r3, [r3, #0]
    f724:	f8b4 207e 	ldrh.w	r2, [r4, #126]	; 0x7e
    f728:	9202      	str	r2, [sp, #8]
    f72a:	0e02      	lsrs	r2, r0, #24
    f72c:	9201      	str	r2, [sp, #4]
    f72e:	f3c0 4207 	ubfx	r2, r0, #16, #8
    f732:	9200      	str	r2, [sp, #0]
    f734:	685f      	ldr	r7, [r3, #4]
    f736:	f3c0 2307 	ubfx	r3, r0, #8, #8
    f73a:	b2c2      	uxtb	r2, r0
    f73c:	f506 61b1 	add.w	r1, r6, #1416	; 0x588
    f740:	4628      	mov	r0, r5
    f742:	47b8      	blx	r7
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Remote %u.%u.%u.%u port %u\r\n",
    f744:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    f748:	681b      	ldr	r3, [r3, #0]
    f74a:	8a62      	ldrh	r2, [r4, #18]
    f74c:	9202      	str	r2, [sp, #8]
    f74e:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
    f752:	9201      	str	r2, [sp, #4]
    f754:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
    f758:	9200      	str	r2, [sp, #0]
    f75a:	685f      	ldr	r7, [r3, #4]
    f75c:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    f760:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
    f764:	f206 51bc 	addw	r1, r6, #1468	; 0x5bc
    f768:	4628      	mov	r0, r5
    f76a:	47b8      	blx	r7
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Target rate = %ld bps, period = %ld ms\r\n",
    f76c:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    f770:	681b      	ldr	r3, [r3, #0]
    f772:	f8d3 8004 	ldr.w	r8, [r3, #4]
                    (unsigned long)pIState->mTxRate, 
    f776:	f8d4 9018 	ldr.w	r9, [r4, #24]
                    (unsigned long)(pIState->mPktPeriod*1000/SYS_TMR_TickCounterFrequencyGet()) );
    f77a:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
    f77e:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
    f782:	fb07 f703 	mul.w	r7, r7, r3
    f786:	f010 fcd9 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Target rate = %ld bps, period = %ld ms\r\n",
    f78a:	fbb7 f3f0 	udiv	r3, r7, r0
    f78e:	464a      	mov	r2, r9
    f790:	f506 61bc 	add.w	r1, r6, #1504	; 0x5e0
    f794:	4628      	mov	r0, r5
    f796:	47c0      	blx	r8
        pIState->pktId++;
    f798:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    f79a:	3301      	adds	r3, #1
    f79c:	62a3      	str	r3, [r4, #40]	; 0x28
        pIState->pktCount++;
    f79e:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    f7a2:	3301      	adds	r3, #1
    f7a4:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
        if ( pIState->mProtocol == UDP_PROTOCOL )
    f7a8:	7c23      	ldrb	r3, [r4, #16]
    f7aa:	2b01      	cmp	r3, #1
    f7ac:	d00e      	beq.n	f7cc <GenericTxEnd+0x130>
        if ( pIState->mProtocol == TCP_PROTOCOL )
    f7ae:	2b02      	cmp	r3, #2
    f7b0:	d186      	bne.n	f6c0 <GenericTxEnd+0x24>
            pIState->totalLen += pIState->mMSS;
    f7b2:	f8b4 00d2 	ldrh.w	r0, [r4, #210]	; 0xd2
    f7b6:	f7fb fde9 	bl	b38c <__aeabi_i2d>
    f7ba:	4602      	mov	r2, r0
    f7bc:	460b      	mov	r3, r1
    f7be:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    f7c2:	f7fb fc97 	bl	b0f4 <__adddf3>
    f7c6:	e9c4 0108 	strd	r0, r1, [r4, #32]
    f7ca:	e779      	b.n	f6c0 <GenericTxEnd+0x24>
            pIState->totalLen += pIState->mDatagramSize;
    f7cc:	68e0      	ldr	r0, [r4, #12]
    f7ce:	f7fb fdcd 	bl	b36c <__aeabi_ui2d>
    f7d2:	4602      	mov	r2, r0
    f7d4:	460b      	mov	r3, r1
    f7d6:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    f7da:	f7fb fc8b 	bl	b0f4 <__adddf3>
    f7de:	e9c4 0108 	strd	r0, r1, [r4, #32]
        if ( pIState->mProtocol == TCP_PROTOCOL )
    f7e2:	e76d      	b.n	f6c0 <GenericTxEnd+0x24>
        ReportBW_Jitter_Loss(pIState, INTERVAL_REPORT);
    f7e4:	2100      	movs	r1, #0
    f7e6:	4620      	mov	r0, r4
    f7e8:	f7fd fdb4 	bl	d354 <ReportBW_Jitter_Loss>
    f7ec:	e774      	b.n	f6d8 <GenericTxEnd+0x3c>
        switch(pIState->mProtocol)
    f7ee:	7c23      	ldrb	r3, [r4, #16]
    f7f0:	2b01      	cmp	r3, #1
    f7f2:	d009      	beq.n	f808 <GenericTxEnd+0x16c>
    f7f4:	2b02      	cmp	r3, #2
    f7f6:	d02a      	beq.n	f84e <GenericTxEnd+0x1b2>
        pIState->sockWaitToSend = 0;
    f7f8:	2300      	movs	r3, #0
    f7fa:	f884 30d4 	strb.w	r3, [r4, #212]	; 0xd4
        pIState->stopTime = SYS_TMR_TickCountGet();
    f7fe:	f010 fc75 	bl	200ec <SYS_TMR_TickCountGet>
    f802:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
}
    f806:	e76c      	b.n	f6e2 <GenericTxEnd+0x46>
                if(++pIState->nAttempts < UDP_FIN_RETRANSMIT_COUNT)
    f808:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
    f80c:	3301      	adds	r3, #1
    f80e:	b2db      	uxtb	r3, r3
    f810:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
    f814:	2b09      	cmp	r3, #9
    f816:	d815      	bhi.n	f844 <GenericTxEnd+0x1a8>
                    if ( pIState->nAttempts == 1u )
    f818:	2b01      	cmp	r3, #1
    f81a:	d003      	beq.n	f824 <GenericTxEnd+0x188>
                    pIState->mPktPeriod = UDP_FIN_RETRANSMIT_PERIOD;
    f81c:	230a      	movs	r3, #10
    f81e:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
    f822:	e7e9      	b.n	f7f8 <GenericTxEnd+0x15c>
                        pIState->stopTime = SYS_TMR_TickCountGet();
    f824:	f010 fc62 	bl	200ec <SYS_TMR_TickCountGet>
    f828:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
                        ReportBW_Jitter_Loss(pIState, SUBTOTAL_REPORT);
    f82c:	2101      	movs	r1, #1
    f82e:	4620      	mov	r0, r4
    f830:	f7fd fd90 	bl	d354 <ReportBW_Jitter_Loss>
                        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "    -----------------------------------------\r\n"); 
    f834:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    f838:	681b      	ldr	r3, [r3, #0]
    f83a:	681b      	ldr	r3, [r3, #0]
    f83c:	4909      	ldr	r1, [pc, #36]	; (f864 <GenericTxEnd+0x1c8>)
    f83e:	4628      	mov	r0, r5
    f840:	4798      	blx	r3
    f842:	e7eb      	b.n	f81c <GenericTxEnd+0x180>
                    IperfSetState(pIState, IPERF_UDP_TX_DONE_STATE);
    f844:	2112      	movs	r1, #18
    f846:	4620      	mov	r0, r4
    f848:	f00c fc16 	bl	1c078 <IperfSetState>
    f84c:	e7d4      	b.n	f7f8 <GenericTxEnd+0x15c>
                IperfSetState(pIState, IPERF_TCP_TX_DONE_STATE);
    f84e:	210f      	movs	r1, #15
    f850:	4620      	mov	r0, r4
    f852:	f00c fc11 	bl	1c078 <IperfSetState>
                break;
    f856:	e7cf      	b.n	f7f8 <GenericTxEnd+0x15c>
    f858:	00005cfc 	.word	0x00005cfc
    f85c:	2000d9b0 	.word	0x2000d9b0
    f860:	000057b4 	.word	0x000057b4
    f864:	00005dc4 	.word	0x00005dc4

Disassembly of section .text._svfprintf_r%233:

0000f868 <_svfiprintf_r>:
    f868:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f86c:	461e      	mov	r6, r3
    f86e:	898b      	ldrh	r3, [r1, #12]
    f870:	061b      	lsls	r3, r3, #24
    f872:	b09d      	sub	sp, #116	; 0x74
    f874:	4607      	mov	r7, r0
    f876:	460d      	mov	r5, r1
    f878:	4614      	mov	r4, r2
    f87a:	d50e      	bpl.n	f89a <_svfiprintf_r+0x32>
    f87c:	690b      	ldr	r3, [r1, #16]
    f87e:	b963      	cbnz	r3, f89a <_svfiprintf_r+0x32>
    f880:	2140      	movs	r1, #64	; 0x40
    f882:	f007 fa7d 	bl	16d80 <_malloc_r>
    f886:	6028      	str	r0, [r5, #0]
    f888:	6128      	str	r0, [r5, #16]
    f88a:	b920      	cbnz	r0, f896 <_svfiprintf_r+0x2e>
    f88c:	230c      	movs	r3, #12
    f88e:	603b      	str	r3, [r7, #0]
    f890:	f04f 30ff 	mov.w	r0, #4294967295
    f894:	e0c3      	b.n	fa1e <_svfiprintf_r+0x1b6>
    f896:	2340      	movs	r3, #64	; 0x40
    f898:	616b      	str	r3, [r5, #20]
    f89a:	2300      	movs	r3, #0
    f89c:	9309      	str	r3, [sp, #36]	; 0x24
    f89e:	f8df 9184 	ldr.w	r9, [pc, #388]	; fa24 <_svfiprintf_r+0x1bc>
    f8a2:	9603      	str	r6, [sp, #12]
    f8a4:	2320      	movs	r3, #32
    f8a6:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
    f8aa:	2330      	movs	r3, #48	; 0x30
    f8ac:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    f8b0:	f04f 38ff 	mov.w	r8, #4294967295
    f8b4:	f109 0a06 	add.w	sl, r9, #6
    f8b8:	4623      	mov	r3, r4
    f8ba:	461e      	mov	r6, r3
    f8bc:	f813 2b01 	ldrb.w	r2, [r3], #1
    f8c0:	b10a      	cbz	r2, f8c6 <_svfiprintf_r+0x5e>
    f8c2:	2a25      	cmp	r2, #37	; 0x25
    f8c4:	d1f9      	bne.n	f8ba <_svfiprintf_r+0x52>
    f8c6:	ebb6 0b04 	subs.w	fp, r6, r4
    f8ca:	d00b      	beq.n	f8e4 <_svfiprintf_r+0x7c>
    f8cc:	465b      	mov	r3, fp
    f8ce:	4622      	mov	r2, r4
    f8d0:	4629      	mov	r1, r5
    f8d2:	4638      	mov	r0, r7
    f8d4:	f007 f944 	bl	16b60 <__ssputs_r>
    f8d8:	3001      	adds	r0, #1
    f8da:	f000 809b 	beq.w	fa14 <_svfiprintf_r+0x1ac>
    f8de:	9b09      	ldr	r3, [sp, #36]	; 0x24
    f8e0:	445b      	add	r3, fp
    f8e2:	9309      	str	r3, [sp, #36]	; 0x24
    f8e4:	7833      	ldrb	r3, [r6, #0]
    f8e6:	2b00      	cmp	r3, #0
    f8e8:	f000 8094 	beq.w	fa14 <_svfiprintf_r+0x1ac>
    f8ec:	2300      	movs	r3, #0
    f8ee:	e9cd 8305 	strd	r8, r3, [sp, #20]
    f8f2:	3601      	adds	r6, #1
    f8f4:	9304      	str	r3, [sp, #16]
    f8f6:	9307      	str	r3, [sp, #28]
    f8f8:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    f8fc:	931a      	str	r3, [sp, #104]	; 0x68
    f8fe:	f04f 0b01 	mov.w	fp, #1
    f902:	4634      	mov	r4, r6
    f904:	2205      	movs	r2, #5
    f906:	f814 1b01 	ldrb.w	r1, [r4], #1
    f90a:	4846      	ldr	r0, [pc, #280]	; (fa24 <_svfiprintf_r+0x1bc>)
    f90c:	f008 f978 	bl	17c00 <memchr>
    f910:	9b04      	ldr	r3, [sp, #16]
    f912:	b9c0      	cbnz	r0, f946 <_svfiprintf_r+0xde>
    f914:	06d8      	lsls	r0, r3, #27
    f916:	bf44      	itt	mi
    f918:	2220      	movmi	r2, #32
    f91a:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    f91e:	0719      	lsls	r1, r3, #28
    f920:	bf44      	itt	mi
    f922:	222b      	movmi	r2, #43	; 0x2b
    f924:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    f928:	7832      	ldrb	r2, [r6, #0]
    f92a:	2a2a      	cmp	r2, #42	; 0x2a
    f92c:	d013      	beq.n	f956 <_svfiprintf_r+0xee>
    f92e:	9a07      	ldr	r2, [sp, #28]
    f930:	4634      	mov	r4, r6
    f932:	2000      	movs	r0, #0
    f934:	260a      	movs	r6, #10
    f936:	4621      	mov	r1, r4
    f938:	f811 3b01 	ldrb.w	r3, [r1], #1
    f93c:	3b30      	subs	r3, #48	; 0x30
    f93e:	2b09      	cmp	r3, #9
    f940:	d94b      	bls.n	f9da <_svfiprintf_r+0x172>
    f942:	b970      	cbnz	r0, f962 <_svfiprintf_r+0xfa>
    f944:	e014      	b.n	f970 <_svfiprintf_r+0x108>
    f946:	eba0 0009 	sub.w	r0, r0, r9
    f94a:	fa0b f000 	lsl.w	r0, fp, r0
    f94e:	4318      	orrs	r0, r3
    f950:	9004      	str	r0, [sp, #16]
    f952:	4626      	mov	r6, r4
    f954:	e7d5      	b.n	f902 <_svfiprintf_r+0x9a>
    f956:	9a03      	ldr	r2, [sp, #12]
    f958:	1d11      	adds	r1, r2, #4
    f95a:	6812      	ldr	r2, [r2, #0]
    f95c:	9103      	str	r1, [sp, #12]
    f95e:	2a00      	cmp	r2, #0
    f960:	db01      	blt.n	f966 <_svfiprintf_r+0xfe>
    f962:	9207      	str	r2, [sp, #28]
    f964:	e004      	b.n	f970 <_svfiprintf_r+0x108>
    f966:	4252      	negs	r2, r2
    f968:	f043 0302 	orr.w	r3, r3, #2
    f96c:	9207      	str	r2, [sp, #28]
    f96e:	9304      	str	r3, [sp, #16]
    f970:	7823      	ldrb	r3, [r4, #0]
    f972:	2b2e      	cmp	r3, #46	; 0x2e
    f974:	d10b      	bne.n	f98e <_svfiprintf_r+0x126>
    f976:	7863      	ldrb	r3, [r4, #1]
    f978:	2b2a      	cmp	r3, #42	; 0x2a
    f97a:	d133      	bne.n	f9e4 <_svfiprintf_r+0x17c>
    f97c:	9b03      	ldr	r3, [sp, #12]
    f97e:	1d1a      	adds	r2, r3, #4
    f980:	681b      	ldr	r3, [r3, #0]
    f982:	9203      	str	r2, [sp, #12]
    f984:	2b00      	cmp	r3, #0
    f986:	bfb8      	it	lt
    f988:	4643      	movlt	r3, r8
    f98a:	3402      	adds	r4, #2
    f98c:	9305      	str	r3, [sp, #20]
    f98e:	2203      	movs	r2, #3
    f990:	7821      	ldrb	r1, [r4, #0]
    f992:	4825      	ldr	r0, [pc, #148]	; (fa28 <_svfiprintf_r+0x1c0>)
    f994:	f008 f934 	bl	17c00 <memchr>
    f998:	b140      	cbz	r0, f9ac <_svfiprintf_r+0x144>
    f99a:	2340      	movs	r3, #64	; 0x40
    f99c:	eba0 000a 	sub.w	r0, r0, sl
    f9a0:	fa03 f000 	lsl.w	r0, r3, r0
    f9a4:	9b04      	ldr	r3, [sp, #16]
    f9a6:	4303      	orrs	r3, r0
    f9a8:	3401      	adds	r4, #1
    f9aa:	9304      	str	r3, [sp, #16]
    f9ac:	f814 1b01 	ldrb.w	r1, [r4], #1
    f9b0:	481e      	ldr	r0, [pc, #120]	; (fa2c <_svfiprintf_r+0x1c4>)
    f9b2:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
    f9b6:	2206      	movs	r2, #6
    f9b8:	f008 f922 	bl	17c00 <memchr>
    f9bc:	ab03      	add	r3, sp, #12
    f9be:	9300      	str	r3, [sp, #0]
    f9c0:	462a      	mov	r2, r5
    f9c2:	4b1b      	ldr	r3, [pc, #108]	; (fa30 <_svfiprintf_r+0x1c8>)
    f9c4:	a904      	add	r1, sp, #16
    f9c6:	b308      	cbz	r0, fa0c <_svfiprintf_r+0x1a4>
    f9c8:	4638      	mov	r0, r7
    f9ca:	f7f8 fc03 	bl	81d4 <_printf_float>
    f9ce:	1c42      	adds	r2, r0, #1
    f9d0:	d020      	beq.n	fa14 <_svfiprintf_r+0x1ac>
    f9d2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    f9d4:	4403      	add	r3, r0
    f9d6:	9309      	str	r3, [sp, #36]	; 0x24
    f9d8:	e76e      	b.n	f8b8 <_svfiprintf_r+0x50>
    f9da:	fb06 3202 	mla	r2, r6, r2, r3
    f9de:	2001      	movs	r0, #1
    f9e0:	460c      	mov	r4, r1
    f9e2:	e7a8      	b.n	f936 <_svfiprintf_r+0xce>
    f9e4:	2300      	movs	r3, #0
    f9e6:	3401      	adds	r4, #1
    f9e8:	9305      	str	r3, [sp, #20]
    f9ea:	4619      	mov	r1, r3
    f9ec:	260a      	movs	r6, #10
    f9ee:	4620      	mov	r0, r4
    f9f0:	f810 2b01 	ldrb.w	r2, [r0], #1
    f9f4:	3a30      	subs	r2, #48	; 0x30
    f9f6:	2a09      	cmp	r2, #9
    f9f8:	d903      	bls.n	fa02 <_svfiprintf_r+0x19a>
    f9fa:	2b00      	cmp	r3, #0
    f9fc:	d0c7      	beq.n	f98e <_svfiprintf_r+0x126>
    f9fe:	9105      	str	r1, [sp, #20]
    fa00:	e7c5      	b.n	f98e <_svfiprintf_r+0x126>
    fa02:	fb06 2101 	mla	r1, r6, r1, r2
    fa06:	2301      	movs	r3, #1
    fa08:	4604      	mov	r4, r0
    fa0a:	e7f0      	b.n	f9ee <_svfiprintf_r+0x186>
    fa0c:	4638      	mov	r0, r7
    fa0e:	f7fe fa57 	bl	dec0 <_printf_i>
    fa12:	e7dc      	b.n	f9ce <_svfiprintf_r+0x166>
    fa14:	89ab      	ldrh	r3, [r5, #12]
    fa16:	065b      	lsls	r3, r3, #25
    fa18:	f53f af3a 	bmi.w	f890 <_svfiprintf_r+0x28>
    fa1c:	9809      	ldr	r0, [sp, #36]	; 0x24
    fa1e:	b01d      	add	sp, #116	; 0x74
    fa20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fa24:	00021b1b 	.word	0x00021b1b
    fa28:	00021b21 	.word	0x00021b21
    fa2c:	00021b25 	.word	0x00021b25
    fa30:	00016b61 	.word	0x00016b61

Disassembly of section .text.DRV_EXTPHY_MIIConfigure%234:

0000fa34 <DRV_EXTPHY_MIIConfigure>:
{
    fa34:	b5f0      	push	{r4, r5, r6, r7, lr}
    fa36:	b087      	sub	sp, #28
    fa38:	4606      	mov	r6, r0
    fa3a:	460d      	mov	r5, r1
    LAN867X_REG_OBJ clientObj = {0};
    fa3c:	2100      	movs	r1, #0
    fa3e:	9101      	str	r1, [sp, #4]
    fa40:	9102      	str	r1, [sp, #8]
    clientObj.miimBase =
    fa42:	692b      	ldr	r3, [r5, #16]
    fa44:	9304      	str	r3, [sp, #16]
    clientObj.miimHandle =
    fa46:	696b      	ldr	r3, [r5, #20]
    fa48:	9303      	str	r3, [sp, #12]
    clientObj.miimOpHandle = &((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)
    fa4a:	f105 0318 	add.w	r3, r5, #24
    fa4e:	9305      	str	r3, [sp, #20]
    pBaseObj->DRV_ETHPHY_PhyAddressGet(hClientObj, DRV_ETHPHY_INF_IDX_ALL_EXTERNAL,
    fa50:	6a83      	ldr	r3, [r0, #40]	; 0x28
    fa52:	aa01      	add	r2, sp, #4
    fa54:	4628      	mov	r0, r5
    fa56:	4798      	blx	r3
    pBaseObj->DRV_ETHPHY_VendorDataGet(hClientObj, &clientObj.vendorData);
    fa58:	6cb3      	ldr	r3, [r6, #72]	; 0x48
    fa5a:	a902      	add	r1, sp, #8
    fa5c:	4628      	mov	r0, r5
    fa5e:	4798      	blx	r3
    state = R2F(clientObj.vendorData, VENDOR_STATE);
    fa60:	f89d 400a 	ldrb.w	r4, [sp, #10]
    switch (state) {
    fa64:	2c0e      	cmp	r4, #14
    fa66:	f200 809d 	bhi.w	fba4 <DRV_EXTPHY_MIIConfigure+0x170>
    fa6a:	e8df f004 	tbb	[pc, r4]
    fa6e:	2a08      	.short	0x2a08
    fa70:	4b423b32 	.word	0x4b423b32
    fa74:	6d655c53 	.word	0x6d655c53
    fa78:	8d877e76 	.word	0x8d877e76
    fa7c:	94          	.byte	0x94
    fa7d:	00          	.byte	0x00
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F00D0, 0x0E03, 0x0002);
    fa7e:	2302      	movs	r3, #2
    fa80:	f640 6203 	movw	r2, #3587	; 0xe03
    fa84:	494d      	ldr	r1, [pc, #308]	; (fbbc <DRV_EXTPHY_MIIConfigure+0x188>)
    fa86:	a801      	add	r0, sp, #4
    fa88:	f008 fae0 	bl	1804c <Lan867x_Write_Bit_Register>
        if (miimRes < 0) {
    fa8c:	2800      	cmp	r0, #0
    fa8e:	f2c0 808f 	blt.w	fbb0 <DRV_EXTPHY_MIIConfigure+0x17c>
        } else if (miimRes != DRV_MIIM_RES_OK) {
    fa92:	2800      	cmp	r0, #0
    fa94:	f040 808f 	bne.w	fbb6 <DRV_EXTPHY_MIIConfigure+0x182>
            ++state;
    fa98:	3401      	adds	r4, #1
    fa9a:	b2a4      	uxth	r4, r4
                F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj.vendorData);
    fa9c:	9b02      	ldr	r3, [sp, #8]
    fa9e:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
            clientObj.vendorData =
    faa2:	9302      	str	r3, [sp, #8]
            res = DRV_ETHPHY_RES_PENDING;
    faa4:	2701      	movs	r7, #1
    clientObj.vendorData = F2R(state, VENDOR_STATE, clientObj.vendorData);
    faa6:	9902      	ldr	r1, [sp, #8]
    faa8:	f421 017f 	bic.w	r1, r1, #16711680	; 0xff0000
    faac:	0424      	lsls	r4, r4, #16
    faae:	f404 047f 	and.w	r4, r4, #16711680	; 0xff0000
    fab2:	4321      	orrs	r1, r4
    fab4:	9102      	str	r1, [sp, #8]
    pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, clientObj.vendorData);
    fab6:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
    fab8:	4628      	mov	r0, r5
    faba:	4798      	blx	r3
}
    fabc:	4638      	mov	r0, r7
    fabe:	b007      	add	sp, #28
    fac0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F00D1, 0x0300, 0x0000);
    fac2:	2300      	movs	r3, #0
    fac4:	f44f 7240 	mov.w	r2, #768	; 0x300
    fac8:	493d      	ldr	r1, [pc, #244]	; (fbc0 <DRV_EXTPHY_MIIConfigure+0x18c>)
    faca:	a801      	add	r0, sp, #4
    facc:	f008 fabe 	bl	1804c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    fad0:	e7dc      	b.n	fa8c <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0084, 0xFFC0, 0x3380);
    fad2:	f44f 534e 	mov.w	r3, #13184	; 0x3380
    fad6:	f64f 72c0 	movw	r2, #65472	; 0xffc0
    fada:	493a      	ldr	r1, [pc, #232]	; (fbc4 <DRV_EXTPHY_MIIConfigure+0x190>)
    fadc:	a801      	add	r0, sp, #4
    fade:	f008 fab5 	bl	1804c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    fae2:	e7d3      	b.n	fa8c <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0085, 0x000F, 0x0006);
    fae4:	2306      	movs	r3, #6
    fae6:	220f      	movs	r2, #15
    fae8:	4937      	ldr	r1, [pc, #220]	; (fbc8 <DRV_EXTPHY_MIIConfigure+0x194>)
    faea:	a801      	add	r0, sp, #4
    faec:	f008 faae 	bl	1804c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    faf0:	e7cc      	b.n	fa8c <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F008A, 0xF800, 0xC000);
    faf2:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    faf6:	f44f 4278 	mov.w	r2, #63488	; 0xf800
    fafa:	4934      	ldr	r1, [pc, #208]	; (fbcc <DRV_EXTPHY_MIIConfigure+0x198>)
    fafc:	a801      	add	r0, sp, #4
    fafe:	f008 faa5 	bl	1804c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    fb02:	e7c3      	b.n	fa8c <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0087, 0x801C, 0x801C);
    fb04:	f248 031c 	movw	r3, #32796	; 0x801c
    fb08:	461a      	mov	r2, r3
    fb0a:	4931      	ldr	r1, [pc, #196]	; (fbd0 <DRV_EXTPHY_MIIConfigure+0x19c>)
    fb0c:	a801      	add	r0, sp, #4
    fb0e:	f008 fa9d 	bl	1804c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    fb12:	e7bb      	b.n	fa8c <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0088, 0x1FFF, 0x033F);
    fb14:	f240 333f 	movw	r3, #831	; 0x33f
    fb18:	f641 72ff 	movw	r2, #8191	; 0x1fff
    fb1c:	492d      	ldr	r1, [pc, #180]	; (fbd4 <DRV_EXTPHY_MIIConfigure+0x1a0>)
    fb1e:	a801      	add	r0, sp, #4
    fb20:	f008 fa94 	bl	1804c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    fb24:	e7b2      	b.n	fa8c <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F008B, 0xFFFF, 0x0404);
    fb26:	f240 4304 	movw	r3, #1028	; 0x404
    fb2a:	f64f 72ff 	movw	r2, #65535	; 0xffff
    fb2e:	492a      	ldr	r1, [pc, #168]	; (fbd8 <DRV_EXTPHY_MIIConfigure+0x1a4>)
    fb30:	a801      	add	r0, sp, #4
    fb32:	f008 fa8b 	bl	1804c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    fb36:	e7a9      	b.n	fa8c <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0080, 0x0600, 0x0600);
    fb38:	f44f 63c0 	mov.w	r3, #1536	; 0x600
    fb3c:	461a      	mov	r2, r3
    fb3e:	4927      	ldr	r1, [pc, #156]	; (fbdc <DRV_EXTPHY_MIIConfigure+0x1a8>)
    fb40:	a801      	add	r0, sp, #4
    fb42:	f008 fa83 	bl	1804c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    fb46:	e7a1      	b.n	fa8c <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F00F1, 0x7F00, 0x2400);
    fb48:	f44f 5310 	mov.w	r3, #9216	; 0x2400
    fb4c:	f44f 42fe 	mov.w	r2, #32512	; 0x7f00
    fb50:	4923      	ldr	r1, [pc, #140]	; (fbe0 <DRV_EXTPHY_MIIConfigure+0x1ac>)
    fb52:	a801      	add	r0, sp, #4
    fb54:	f008 fa7a 	bl	1804c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    fb58:	e798      	b.n	fa8c <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0096, 0x2000, 0x2000);
    fb5a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    fb5e:	461a      	mov	r2, r3
    fb60:	4920      	ldr	r1, [pc, #128]	; (fbe4 <DRV_EXTPHY_MIIConfigure+0x1b0>)
    fb62:	a801      	add	r0, sp, #4
    fb64:	f008 fa72 	bl	1804c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    fb68:	e790      	b.n	fa8c <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0099, 0xFFFF, 0x7F80);
    fb6a:	f44f 43ff 	mov.w	r3, #32640	; 0x7f80
    fb6e:	f64f 72ff 	movw	r2, #65535	; 0xffff
    fb72:	491d      	ldr	r1, [pc, #116]	; (fbe8 <DRV_EXTPHY_MIIConfigure+0x1b4>)
    fb74:	a801      	add	r0, sp, #4
    fb76:	f008 fa69 	bl	1804c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    fb7a:	e787      	b.n	fa8c <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Register(&clientObj, PHY_PLCA_BURST, registerValue);
    fb7c:	2200      	movs	r2, #0
    fb7e:	491b      	ldr	r1, [pc, #108]	; (fbec <DRV_EXTPHY_MIIConfigure+0x1b8>)
    fb80:	a801      	add	r0, sp, #4
    fb82:	f00d fb61 	bl	1d248 <Lan867x_Write_Register>
    if (inProgress == true) {
    fb86:	e781      	b.n	fa8c <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Register(&clientObj, PHY_PLCA_CONTROL_1, registerValue);
    fb88:	f44f 6200 	mov.w	r2, #2048	; 0x800
    fb8c:	4918      	ldr	r1, [pc, #96]	; (fbf0 <DRV_EXTPHY_MIIConfigure+0x1bc>)
    fb8e:	a801      	add	r0, sp, #4
    fb90:	f00d fb5a 	bl	1d248 <Lan867x_Write_Register>
    if (inProgress == true) {
    fb94:	e77a      	b.n	fa8c <DRV_EXTPHY_MIIConfigure+0x58>
            Lan867x_Write_Register(&clientObj, PHY_PLCA_CONTROL_0, F2R_(1, PHY_PLCA_CTRL0_EN));
    fb96:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    fb9a:	4916      	ldr	r1, [pc, #88]	; (fbf4 <DRV_EXTPHY_MIIConfigure+0x1c0>)
    fb9c:	a801      	add	r0, sp, #4
    fb9e:	f00d fb53 	bl	1d248 <Lan867x_Write_Register>
    if (inProgress == true) {
    fba2:	e773      	b.n	fa8c <DRV_EXTPHY_MIIConfigure+0x58>
        ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->operRes = DRV_ETHPHY_RES_OK;
    fba4:	2700      	movs	r7, #0
    fba6:	f885 702c 	strb.w	r7, [r5, #44]	; 0x2c
        ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->miimOpHandle = 0;
    fbaa:	61af      	str	r7, [r5, #24]
        ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
    fbac:	86af      	strh	r7, [r5, #52]	; 0x34
    if (inProgress == true) {
    fbae:	e77a      	b.n	faa6 <DRV_EXTPHY_MIIConfigure+0x72>
            res = DRV_ETHPHY_RES_MIIM_ERR;
    fbb0:	f06f 070c 	mvn.w	r7, #12
    fbb4:	e777      	b.n	faa6 <DRV_EXTPHY_MIIConfigure+0x72>
            res = DRV_ETHPHY_RES_PENDING;
    fbb6:	2701      	movs	r7, #1
    fbb8:	e775      	b.n	faa6 <DRV_EXTPHY_MIIConfigure+0x72>
    fbba:	bf00      	nop
    fbbc:	001f00d0 	.word	0x001f00d0
    fbc0:	001f00d1 	.word	0x001f00d1
    fbc4:	001f0084 	.word	0x001f0084
    fbc8:	001f0085 	.word	0x001f0085
    fbcc:	001f008a 	.word	0x001f008a
    fbd0:	001f0087 	.word	0x001f0087
    fbd4:	001f0088 	.word	0x001f0088
    fbd8:	001f008b 	.word	0x001f008b
    fbdc:	001f0080 	.word	0x001f0080
    fbe0:	001f00f1 	.word	0x001f00f1
    fbe4:	001f0096 	.word	0x001f0096
    fbe8:	001f0099 	.word	0x001f0099
    fbec:	001fca05 	.word	0x001fca05
    fbf0:	001fca02 	.word	0x001fca02
    fbf4:	001fca01 	.word	0x001fca01

Disassembly of section .text._DHCPSend%235:

0000fbf8 <_DHCPSend>:
{
    fbf8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    fbfc:	b0d4      	sub	sp, #336	; 0x150
    fbfe:	4606      	mov	r6, r0
    fc00:	460d      	mov	r5, r1
    fc02:	4617      	mov	r7, r2
    fc04:	4698      	mov	r8, r3
    s = dhcpClientSocket;
    fc06:	4b68      	ldr	r3, [pc, #416]	; (fda8 <_DHCPSend+0x1b0>)
    fc08:	f9b3 4000 	ldrsh.w	r4, [r3]
    if(TCPIP_UDP_PutIsReady(s) < TCPIP_DHCP_MIN_UDP_TX_AVLBL_SIZE)
    fc0c:	4620      	mov	r0, r4
    fc0e:	f00c fe82 	bl	1c916 <TCPIP_UDP_PutIsReady>
    fc12:	f5b0 7f96 	cmp.w	r0, #300	; 0x12c
    fc16:	d338      	bcc.n	fc8a <_DHCPSend+0x92>
    TCPIP_UDP_SocketNetSet(s, pNetIf);
    fc18:	4629      	mov	r1, r5
    fc1a:	4620      	mov	r0, r4
    fc1c:	f00e f82a 	bl	1dc74 <TCPIP_UDP_SocketNetSet>
    TCPIP_UDP_OptionsSet(s, UDP_OPTION_STRICT_NET, (void*)0);
    fc20:	2200      	movs	r2, #0
    fc22:	2101      	movs	r1, #1
    fc24:	4620      	mov	r0, r4
    fc26:	f7fe fe83 	bl	e930 <TCPIP_UDP_OptionsSet>
    if((dhcpFlags & TCPIP_DHCP_FLAG_SEND_BCAST) != 0 || pClient->serverAddress.Val == 0)
    fc2a:	f018 0f01 	tst.w	r8, #1
    fc2e:	d101      	bne.n	fc34 <_DHCPSend+0x3c>
    fc30:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    fc32:	bb7b      	cbnz	r3, fc94 <_DHCPSend+0x9c>
        TCPIP_UDP_BcastIPV4AddressSet(s, UDP_BCAST_NETWORK_LIMITED, pNetIf);
    fc34:	462a      	mov	r2, r5
    fc36:	2101      	movs	r1, #1
    fc38:	4620      	mov	r0, r4
    fc3a:	f00c f812 	bl	1bc62 <TCPIP_UDP_BcastIPV4AddressSet>
    if((dhcpFlags & TCPIP_DHCP_FLAG_SEND_ZERO_ADD) != 0)
    fc3e:	f018 0f02 	tst.w	r8, #2
    return pNetIf->netIPAddr.Val;
    fc42:	bf0c      	ite	eq
    fc44:	686b      	ldreq	r3, [r5, #4]
        sourceIp.Val = 0;
    fc46:	2300      	movne	r3, #0
    fc48:	9353      	str	r3, [sp, #332]	; 0x14c
    TCPIP_UDP_SourceIPAddressSet(s, IP_ADDRESS_TYPE_IPV4, (IP_MULTI_ADDRESS*) & sourceIp);
    fc4a:	aa53      	add	r2, sp, #332	; 0x14c
    fc4c:	2101      	movs	r1, #1
    fc4e:	4620      	mov	r0, r4
    fc50:	f00d fe2f 	bl	1d8b2 <TCPIP_UDP_SourceIPAddressSet>
    newTransaction = (messageType == TCPIP_DHCP_DISCOVER_MESSAGE || messageType == TCPIP_DHCP_REQUEST_RENEW_MESSAGE || (messageType == TCPIP_DHCP_REQUEST_MESSAGE && pClient->dhcpOp == TCPIP_DHCP_OPER_INIT_REBOOT));
    fc54:	f027 0308 	bic.w	r3, r7, #8
    fc58:	2b01      	cmp	r3, #1
    fc5a:	d032      	beq.n	fcc2 <_DHCPSend+0xca>
    fc5c:	2f03      	cmp	r7, #3
    fc5e:	d13a      	bne.n	fcd6 <_DHCPSend+0xde>
    fc60:	f8b6 3054 	ldrh.w	r3, [r6, #84]	; 0x54
    fc64:	2b02      	cmp	r3, #2
    fc66:	d02c      	beq.n	fcc2 <_DHCPSend+0xca>
    memset(pDhcpHdr, 0, sizeof(*pDhcpHdr));
    fc68:	222a      	movs	r2, #42	; 0x2a
    fc6a:	2100      	movs	r1, #0
    fc6c:	f10d 0016 	add.w	r0, sp, #22
    fc70:	f012 f80c 	bl	21c8c <memset>
    pDhcpHdr->op = TCPIP_BOOT_REQUEST;
    fc74:	2301      	movs	r3, #1
    fc76:	f88d 3014 	strb.w	r3, [sp, #20]
    pDhcpHdr->htype = TCPIP_BOOT_HW_TYPE;
    fc7a:	f88d 3015 	strb.w	r3, [sp, #21]
    pDhcpHdr->hlen = TCPIP_BOOT_LEN_OF_HW_TYPE;
    fc7e:	2306      	movs	r3, #6
    fc80:	f88d 3016 	strb.w	r3, [sp, #22]
    pDhcpHdr->xid = pClient->transactionID.Val;
    fc84:	6c33      	ldr	r3, [r6, #64]	; 0x40
    fc86:	9306      	str	r3, [sp, #24]
    if( messageType == TCPIP_DHCP_RELEASE_MESSAGE || messageType == TCPIP_DHCP_REQUEST_RENEW_MESSAGE) 
    fc88:	e03b      	b.n	fd02 <_DHCPSend+0x10a>
        TCPIP_UDP_Flush(s); // discard old data that may be there
    fc8a:	4620      	mov	r0, r4
    fc8c:	f7fe fa2c 	bl	e0e8 <TCPIP_UDP_Flush>
        return false;
    fc90:	2000      	movs	r0, #0
    fc92:	e085      	b.n	fda0 <_DHCPSend+0x1a8>
        TCPIP_UDP_DestinationIPAddressSet(s, IP_ADDRESS_TYPE_IPV4, (IP_MULTI_ADDRESS*)&pClient->serverAddress);
    fc94:	f106 0228 	add.w	r2, r6, #40	; 0x28
    fc98:	2101      	movs	r1, #1
    fc9a:	4620      	mov	r0, r4
    fc9c:	f00d f802 	bl	1cca4 <TCPIP_UDP_DestinationIPAddressSet>
    fca0:	e7cd      	b.n	fc3e <_DHCPSend+0x46>
    fca2:	f00b f973 	bl	1af8c <rand>
            pClient->transactionID.Val = SYS_RANDOM_PseudoGet(); 
    fca6:	6430      	str	r0, [r6, #64]	; 0x40
    fca8:	e00f      	b.n	fcca <_DHCPSend+0xd2>
    return pNetIf ? pNetIf->netMACAddr.v : 0;
    fcaa:	462b      	mov	r3, r5
    fcac:	e02d      	b.n	fd0a <_DHCPSend+0x112>
        dhcpWriteData.writeBytes = TCPIP_DHCP_MIN_TX_FRAME_SIZE - sizeof (*pDhcpHdr) - sizeof(*pOptHdr);
    fcae:	2340      	movs	r3, #64	; 0x40
    fcb0:	9303      	str	r3, [sp, #12]
    fcb2:	e06b      	b.n	fd8c <_DHCPSend+0x194>
        TCPIP_UDP_TxOffsetSet(s , 0, false);
    fcb4:	2200      	movs	r2, #0
    fcb6:	4611      	mov	r1, r2
    fcb8:	4620      	mov	r0, r4
    fcba:	f00e f958 	bl	1df6e <TCPIP_UDP_TxOffsetSet>
        return false;
    fcbe:	2000      	movs	r0, #0
    fcc0:	e06e      	b.n	fda0 <_DHCPSend+0x1a8>
        if(pClient->flags.bRetry == false)
    fcc2:	f996 3058 	ldrsb.w	r3, [r6, #88]	; 0x58
    fcc6:	2b00      	cmp	r3, #0
    fcc8:	daeb      	bge.n	fca2 <_DHCPSend+0xaa>
        pClient->flags.bOfferReceived = false;
    fcca:	f896 3058 	ldrb.w	r3, [r6, #88]	; 0x58
    fcce:	f36f 0382 	bfc	r3, #2, #1
    fcd2:	f886 3058 	strb.w	r3, [r6, #88]	; 0x58
    memset(pDhcpHdr, 0, sizeof(*pDhcpHdr));
    fcd6:	222a      	movs	r2, #42	; 0x2a
    fcd8:	2100      	movs	r1, #0
    fcda:	f10d 0016 	add.w	r0, sp, #22
    fcde:	f011 ffd5 	bl	21c8c <memset>
    pDhcpHdr->op = TCPIP_BOOT_REQUEST;
    fce2:	2301      	movs	r3, #1
    fce4:	f88d 3014 	strb.w	r3, [sp, #20]
    pDhcpHdr->htype = TCPIP_BOOT_HW_TYPE;
    fce8:	f88d 3015 	strb.w	r3, [sp, #21]
    pDhcpHdr->hlen = TCPIP_BOOT_LEN_OF_HW_TYPE;
    fcec:	2306      	movs	r3, #6
    fcee:	f88d 3016 	strb.w	r3, [sp, #22]
    pDhcpHdr->xid = pClient->transactionID.Val;
    fcf2:	6c33      	ldr	r3, [r6, #64]	; 0x40
    fcf4:	9306      	str	r3, [sp, #24]
    if( messageType == TCPIP_DHCP_RELEASE_MESSAGE || messageType == TCPIP_DHCP_REQUEST_RENEW_MESSAGE) 
    fcf6:	2f07      	cmp	r7, #7
    fcf8:	d001      	beq.n	fcfe <_DHCPSend+0x106>
    fcfa:	2f09      	cmp	r7, #9
    fcfc:	d101      	bne.n	fd02 <_DHCPSend+0x10a>
        pDhcpHdr->ciaddr = pClient->dhcpIPAddress.Val;
    fcfe:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    fd00:	9308      	str	r3, [sp, #32]
    fd02:	2d00      	cmp	r5, #0
    fd04:	d0d1      	beq.n	fcaa <_DHCPSend+0xb2>
    fd06:	f105 033c 	add.w	r3, r5, #60	; 0x3c
    memcpy(pDhcpHdr->chaddr, _TCPIPStack_NetMACAddressGet(pNetIf), sizeof(TCPIP_MAC_ADDR));
    fd0a:	6818      	ldr	r0, [r3, #0]
    fd0c:	900c      	str	r0, [sp, #48]	; 0x30
    fd0e:	889b      	ldrh	r3, [r3, #4]
    fd10:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
    TCPIP_UDP_ArrayPut(s, (uint8_t*)pDhcpHdr, sizeof (*pDhcpHdr));
    fd14:	222c      	movs	r2, #44	; 0x2c
    fd16:	a905      	add	r1, sp, #20
    fd18:	4620      	mov	r0, r4
    fd1a:	f00c ff9e 	bl	1cc5a <TCPIP_UDP_ArrayPut>
    memset(pOptHdr, 0, sizeof(*pOptHdr));
    fd1e:	26c0      	movs	r6, #192	; 0xc0
    fd20:	4632      	mov	r2, r6
    fd22:	2100      	movs	r1, #0
    fd24:	a805      	add	r0, sp, #20
    fd26:	f011 ffb1 	bl	21c8c <memset>
    TCPIP_UDP_ArrayPut(s, (uint8_t*)pOptHdr, sizeof(*pOptHdr));
    fd2a:	4632      	mov	r2, r6
    fd2c:	a905      	add	r1, sp, #20
    fd2e:	4620      	mov	r0, r4
    fd30:	f00c ff93 	bl	1cc5a <TCPIP_UDP_ArrayPut>
    memset(pDOpt, 0, sizeof(*pDOpt));
    fd34:	f44f 729c 	mov.w	r2, #312	; 0x138
    fd38:	2100      	movs	r1, #0
    fd3a:	a805      	add	r0, sp, #20
    fd3c:	f011 ffa6 	bl	21c8c <memset>
    memcpy(pDOpt->cookie, dhcpMagicCookie, sizeof(pDOpt->cookie)); 
    fd40:	4b1a      	ldr	r3, [pc, #104]	; (fdac <_DHCPSend+0x1b4>)
    fd42:	681b      	ldr	r3, [r3, #0]
    fd44:	9305      	str	r3, [sp, #20]
    dhcpWriteData.pOpt = pDOpt->options;
    fd46:	ab06      	add	r3, sp, #24
    fd48:	9301      	str	r3, [sp, #4]
    dhcpWriteData.writeSpace = TCPIP_UDP_PutIsReady(s) - sizeof(pDOpt->cookie);
    fd4a:	4620      	mov	r0, r4
    fd4c:	f00c fde3 	bl	1c916 <TCPIP_UDP_PutIsReady>
    fd50:	3804      	subs	r0, #4
    fd52:	9002      	str	r0, [sp, #8]
    dhcpWriteData.writeBytes = sizeof(pDOpt->cookie);
    fd54:	2304      	movs	r3, #4
    fd56:	9303      	str	r3, [sp, #12]
    dhcpWriteData.msgType = messageType;
    fd58:	9704      	str	r7, [sp, #16]
    for(optIx = 0; optIx < sizeof(_DHCPOptWriteTbl) / sizeof(*_DHCPOptWriteTbl); optIx++, pEntry++)
    fd5a:	4f15      	ldr	r7, [pc, #84]	; (fdb0 <_DHCPSend+0x1b8>)
    fd5c:	1f3e      	subs	r6, r7, #4
    fd5e:	3718      	adds	r7, #24
        optSize = (*pEntry->dhcpWriteFnc)(pNetIf, pSendData);
    fd60:	f856 3f04 	ldr.w	r3, [r6, #4]!
    fd64:	a901      	add	r1, sp, #4
    fd66:	4628      	mov	r0, r5
    fd68:	4798      	blx	r3
        if(optSize < 0)
    fd6a:	2800      	cmp	r0, #0
    fd6c:	dba2      	blt.n	fcb4 <_DHCPSend+0xbc>
        pSendData->writeSpace -= optSize;
    fd6e:	9b02      	ldr	r3, [sp, #8]
    fd70:	1a1b      	subs	r3, r3, r0
    fd72:	9302      	str	r3, [sp, #8]
        pSendData->writeBytes += optSize;
    fd74:	9b03      	ldr	r3, [sp, #12]
    fd76:	4403      	add	r3, r0
    fd78:	9303      	str	r3, [sp, #12]
        pSendData->pOpt += optSize;
    fd7a:	9a01      	ldr	r2, [sp, #4]
    fd7c:	4402      	add	r2, r0
    fd7e:	9201      	str	r2, [sp, #4]
    for(optIx = 0; optIx < sizeof(_DHCPOptWriteTbl) / sizeof(*_DHCPOptWriteTbl); optIx++, pEntry++)
    fd80:	42b7      	cmp	r7, r6
    fd82:	d1ed      	bne.n	fd60 <_DHCPSend+0x168>
    if(sizeof (*pDhcpHdr) + sizeof(*pOptHdr) + dhcpWriteData.writeBytes < TCPIP_DHCP_MIN_TX_FRAME_SIZE)
    fd84:	33ec      	adds	r3, #236	; 0xec
    fd86:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
    fd8a:	d390      	bcc.n	fcae <_DHCPSend+0xb6>
    TCPIP_UDP_ArrayPut(s, pDOpt->cookie, dhcpWriteData.writeBytes);
    fd8c:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    fd90:	a905      	add	r1, sp, #20
    fd92:	4620      	mov	r0, r4
    fd94:	f00c ff61 	bl	1cc5a <TCPIP_UDP_ArrayPut>
    TCPIP_UDP_Flush(s);
    fd98:	4620      	mov	r0, r4
    fd9a:	f7fe f9a5 	bl	e0e8 <TCPIP_UDP_Flush>
    return true;
    fd9e:	2001      	movs	r0, #1
}
    fda0:	b054      	add	sp, #336	; 0x150
    fda2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    fda6:	bf00      	nop
    fda8:	2000e504 	.word	0x2000e504
    fdac:	00022254 	.word	0x00022254
    fdb0:	00020efc 	.word	0x00020efc

Disassembly of section .text.DRV_GMAC_PacketRx%236:

0000fdb4 <DRV_GMAC_PacketRx>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
    fdb4:	4b69      	ldr	r3, [pc, #420]	; (ff5c <DRV_GMAC_PacketRx+0x1a8>)
    fdb6:	4283      	cmp	r3, r0
    fdb8:	f040 80b0 	bne.w	ff1c <DRV_GMAC_PacketRx+0x168>
    if(pMACDrv == 0)
    fdbc:	2800      	cmp	r0, #0
    fdbe:	f000 80af 	beq.w	ff20 <DRV_GMAC_PacketRx+0x16c>
{
    fdc2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    fdc6:	b086      	sub	sp, #24
    fdc8:	4690      	mov	r8, r2
    fdca:	468a      	mov	sl, r1
	TCPIP_MAC_PACKET		*pRxPkt = NULL;
    fdcc:	2300      	movs	r3, #0
    fdce:	9305      	str	r3, [sp, #20]
	DRV_GMAC_RXDCPT_STATUS	pRxPktStat = {0};
    fdd0:	9304      	str	r3, [sp, #16]
	int                     buffsPerRxPkt = 0;
    fdd2:	9303      	str	r3, [sp, #12]
    queueIndex = DRV_PIC32CGMAC_LibGetHighPrioReadyQue();      
    fdd4:	f011 fd82 	bl	218dc <DRV_PIC32CGMAC_LibGetHighPrioReadyQue>
    fdd8:	4b61      	ldr	r3, [pc, #388]	; (ff60 <DRV_GMAC_PacketRx+0x1ac>)
    fdda:	7018      	strb	r0, [r3, #0]
    while(queueIndex != DRV_GMAC_NO_ACTIVE_QUEUE)
    fddc:	28ff      	cmp	r0, #255	; 0xff
    fdde:	d025      	beq.n	fe2c <DRV_GMAC_PacketRx+0x78>
	if(pMACDrv->sGmacData._synchF != 0)
    fde0:	4c5e      	ldr	r4, [pc, #376]	; (ff5c <DRV_GMAC_PacketRx+0x1a8>)
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
    fde2:	f104 065c 	add.w	r6, r4, #92	; 0x5c
        ethRes = DRV_PIC32CGMAC_LibRxGetPacket (pMACDrv, &pRxPkt, &buffsPerRxPkt, &pRxPktStat, queueIndex);
    fde6:	461d      	mov	r5, r3
    fde8:	e00b      	b.n	fe02 <DRV_GMAC_PacketRx+0x4e>
        if(ethRes == DRV_PIC32CGMAC_RES_OK)
    fdea:	2f00      	cmp	r7, #0
    fdec:	f000 809e 	beq.w	ff2c <DRV_GMAC_PacketRx+0x178>
            DRV_PIC32CGMAC_LibClearPriorityQue(pMACDrv,queueIndex);
    fdf0:	7829      	ldrb	r1, [r5, #0]
    fdf2:	4620      	mov	r0, r4
    fdf4:	f00e fe2c 	bl	1ea50 <DRV_PIC32CGMAC_LibClearPriorityQue>
            queueIndex = DRV_PIC32CGMAC_LibGetHighPrioReadyQue();
    fdf8:	f011 fd70 	bl	218dc <DRV_PIC32CGMAC_LibGetHighPrioReadyQue>
    fdfc:	7028      	strb	r0, [r5, #0]
    while(queueIndex != DRV_GMAC_NO_ACTIVE_QUEUE)
    fdfe:	28ff      	cmp	r0, #255	; 0xff
    fe00:	d015      	beq.n	fe2e <DRV_GMAC_PacketRx+0x7a>
	if(pMACDrv->sGmacData._synchF != 0)
    fe02:	6b23      	ldr	r3, [r4, #48]	; 0x30
    fe04:	b113      	cbz	r3, fe0c <DRV_GMAC_PacketRx+0x58>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
    fe06:	2105      	movs	r1, #5
    fe08:	4630      	mov	r0, r6
    fe0a:	4798      	blx	r3
        ethRes = DRV_PIC32CGMAC_LibRxGetPacket (pMACDrv, &pRxPkt, &buffsPerRxPkt, &pRxPktStat, queueIndex);
    fe0c:	782b      	ldrb	r3, [r5, #0]
    fe0e:	9300      	str	r3, [sp, #0]
    fe10:	ab04      	add	r3, sp, #16
    fe12:	aa03      	add	r2, sp, #12
    fe14:	a905      	add	r1, sp, #20
    fe16:	4620      	mov	r0, r4
    fe18:	f7fa ffa6 	bl	ad68 <DRV_PIC32CGMAC_LibRxGetPacket>
    fe1c:	4607      	mov	r7, r0
	if(pMACDrv->sGmacData._synchF != 0)
    fe1e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    fe20:	2b00      	cmp	r3, #0
    fe22:	d0e2      	beq.n	fdea <DRV_GMAC_PacketRx+0x36>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_LEAVE);
    fe24:	2106      	movs	r1, #6
    fe26:	4630      	mov	r0, r6
    fe28:	4798      	blx	r3
    fe2a:	e7de      	b.n	fdea <DRV_GMAC_PacketRx+0x36>
	DRV_PIC32CGMAC_RESULT	ethRes = DRV_PIC32CGMAC_RES_NO_PACKET;	
    fe2c:	2701      	movs	r7, #1
	if(buffsPerRxPkt > 1)
    fe2e:	9b03      	ldr	r3, [sp, #12]
    fe30:	2b01      	cmp	r3, #1
    fe32:	f340 8089 	ble.w	ff48 <DRV_GMAC_PacketRx+0x194>
        pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_SPLIT;
    fe36:	9a05      	ldr	r2, [sp, #20]
    fe38:	8c53      	ldrh	r3, [r2, #34]	; 0x22
    fe3a:	f043 0304 	orr.w	r3, r3, #4
    fe3e:	8453      	strh	r3, [r2, #34]	; 0x22
	if(ethRes == DRV_PIC32CGMAC_RES_PACKET_QUEUED || ethRes == DRV_PIC32CGMAC_RES_NO_PACKET)
    fe40:	1e7b      	subs	r3, r7, #1
    fe42:	b2db      	uxtb	r3, r3
    fe44:	2b01      	cmp	r3, #1
    fe46:	d81b      	bhi.n	fe80 <DRV_GMAC_PacketRx+0xcc>
		mRes = TCPIP_MAC_RES_PENDING;
    fe48:	2301      	movs	r3, #1
	if(pRes)
    fe4a:	f1ba 0f00 	cmp.w	sl, #0
    fe4e:	d06b      	beq.n	ff28 <DRV_GMAC_PacketRx+0x174>
		*pRes = mRes;
    fe50:	f88a 3000 	strb.w	r3, [sl]
	if(mRes == TCPIP_MAC_RES_OK)
    fe54:	2b00      	cmp	r3, #0
    fe56:	d165      	bne.n	ff24 <DRV_GMAC_PacketRx+0x170>
        pDSeg = pRxPkt->pDSeg;
    fe58:	9c05      	ldr	r4, [sp, #20]
    fe5a:	6921      	ldr	r1, [r4, #16]
        pDSeg->segLoad = pDSeg->segBuffer + pMACDrv->sGmacData._dataOffset;
    fe5c:	4b3f      	ldr	r3, [pc, #252]	; (ff5c <DRV_GMAC_PacketRx+0x1a8>)
    fe5e:	f893 20f6 	ldrb.w	r2, [r3, #246]	; 0xf6
    fe62:	684b      	ldr	r3, [r1, #4]
    fe64:	4413      	add	r3, r2
    fe66:	608b      	str	r3, [r1, #8]
        pDSeg->segLen = pDSeg->segLen - sizeof(TCPIP_MAC_ETHERNET_HEADER);
    fe68:	898a      	ldrh	r2, [r1, #12]
    fe6a:	3a0e      	subs	r2, #14
    fe6c:	b292      	uxth	r2, r2
    fe6e:	818a      	strh	r2, [r1, #12]
        if(pDSeg->next)
    fe70:	680b      	ldr	r3, [r1, #0]
    fe72:	b1d3      	cbz	r3, feaa <DRV_GMAC_PacketRx+0xf6>
            pDSeg->segLen = pDSeg->segLen - pMACDrv->sGmacData._dataOffset;
    fe74:	4839      	ldr	r0, [pc, #228]	; (ff5c <DRV_GMAC_PacketRx+0x1a8>)
    fe76:	f890 00f6 	ldrb.w	r0, [r0, #246]	; 0xf6
    fe7a:	1a12      	subs	r2, r2, r0
    fe7c:	818a      	strh	r2, [r1, #12]
            while (pDSeg->next)
    fe7e:	e009      	b.n	fe94 <DRV_GMAC_PacketRx+0xe0>
	else if(ethRes == DRV_PIC32CGMAC_RES_OK)
    fe80:	2f00      	cmp	r7, #0
    fe82:	d056      	beq.n	ff32 <DRV_GMAC_PacketRx+0x17e>
		pMACDrv->sGmacData._rxStat.nRxErrorPackets++;
    fe84:	4a35      	ldr	r2, [pc, #212]	; (ff5c <DRV_GMAC_PacketRx+0x1a8>)
    fe86:	6f13      	ldr	r3, [r2, #112]	; 0x70
    fe88:	3301      	adds	r3, #1
    fe8a:	6713      	str	r3, [r2, #112]	; 0x70
		mRes = TCPIP_MAC_RES_PACKET_ERR;
    fe8c:	f06f 0309 	mvn.w	r3, #9
    fe90:	e7db      	b.n	fe4a <DRV_GMAC_PacketRx+0x96>
            while (pDSeg->next)
    fe92:	4613      	mov	r3, r2
                pDSeg->segLoad = pDSeg->segBuffer;                
    fe94:	685a      	ldr	r2, [r3, #4]
    fe96:	609a      	str	r2, [r3, #8]
            while (pDSeg->next)
    fe98:	681a      	ldr	r2, [r3, #0]
    fe9a:	2a00      	cmp	r2, #0
    fe9c:	d1f9      	bne.n	fe92 <DRV_GMAC_PacketRx+0xde>
            pDSeg->segLen = pDSeg->segLen + pMACDrv->sGmacData._dataOffset;
    fe9e:	4a2f      	ldr	r2, [pc, #188]	; (ff5c <DRV_GMAC_PacketRx+0x1a8>)
    fea0:	f892 20f6 	ldrb.w	r2, [r2, #246]	; 0xf6
    fea4:	8999      	ldrh	r1, [r3, #12]
    fea6:	440a      	add	r2, r1
    fea8:	819a      	strh	r2, [r3, #12]
		pRxPkt->pMacLayer = pRxPkt->pDSeg->segLoad;
    feaa:	6923      	ldr	r3, [r4, #16]
    feac:	689b      	ldr	r3, [r3, #8]
    feae:	6163      	str	r3, [r4, #20]
		pRxPkt->pNetLayer = pRxPkt->pMacLayer + sizeof(TCPIP_MAC_ETHERNET_HEADER);
    feb0:	330e      	adds	r3, #14
    feb2:	61a3      	str	r3, [r4, #24]
		pRxPkt->tStamp = SYS_TMR_TickCountGet();
    feb4:	f010 f91a 	bl	200ec <SYS_TMR_TickCountGet>
    feb8:	6260      	str	r0, [r4, #36]	; 0x24
		pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_QUEUED;
    feba:	9c05      	ldr	r4, [sp, #20]
		pRxPkt->pktFlags &= ~TCPIP_MAC_PKT_FLAG_CAST_MASK;
    febc:	8c63      	ldrh	r3, [r4, #34]	; 0x22
    febe:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    fec2:	b29b      	uxth	r3, r3
    fec4:	f043 0208 	orr.w	r2, r3, #8
    fec8:	8462      	strh	r2, [r4, #34]	; 0x22
		if(pRxPktStat.bm.bBroadcastDetected)
    feca:	f89d 2013 	ldrb.w	r2, [sp, #19]
    fece:	f012 0f80 	tst.w	r2, #128	; 0x80
    fed2:	d106      	bne.n	fee2 <DRV_GMAC_PacketRx+0x12e>
		else if(pRxPktStat.bm.bMultiHashMatch)
    fed4:	f012 0f40 	tst.w	r2, #64	; 0x40
    fed8:	d019      	beq.n	ff0e <DRV_GMAC_PacketRx+0x15a>
			pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_MCAST;
    feda:	f043 0348 	orr.w	r3, r3, #72	; 0x48
    fede:	8463      	strh	r3, [r4, #34]	; 0x22
    fee0:	e002      	b.n	fee8 <DRV_GMAC_PacketRx+0x134>
			pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_BCAST;
    fee2:	f043 0328 	orr.w	r3, r3, #40	; 0x28
    fee6:	8463      	strh	r3, [r4, #34]	; 0x22
		if(pPktStat)
    fee8:	f1b8 0f00 	cmp.w	r8, #0
    feec:	d004      	beq.n	fef8 <DRV_GMAC_PacketRx+0x144>
			*pPktStat = *(TCPIP_MAC_PACKET_RX_STAT*)&pRxPktStat;
    feee:	ab06      	add	r3, sp, #24
    fef0:	e913 0003 	ldmdb	r3, {r0, r1}
    fef4:	e888 0003 	stmia.w	r8, {r0, r1}
        pRxPkt->pktPriority = DRV_PIC32CGMAC_LibGetPriorityFromQueueNum(pMACDrv, queueIndex);
    fef8:	4b19      	ldr	r3, [pc, #100]	; (ff60 <DRV_GMAC_PacketRx+0x1ac>)
    fefa:	7819      	ldrb	r1, [r3, #0]
    fefc:	4817      	ldr	r0, [pc, #92]	; (ff5c <DRV_GMAC_PacketRx+0x1a8>)
    fefe:	f012 f9a0 	bl	22242 <DRV_PIC32CGMAC_LibGetPriorityFromQueueNum>
    ff02:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
		return pRxPkt;
    ff06:	9805      	ldr	r0, [sp, #20]
}
    ff08:	b006      	add	sp, #24
    ff0a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		else if(pRxPktStat.bm.bUniHashMatch)
    ff0e:	f012 0f20 	tst.w	r2, #32
			pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_UNICAST;
    ff12:	bf1c      	itt	ne
    ff14:	f043 0318 	orrne.w	r3, r3, #24
    ff18:	8463      	strhne	r3, [r4, #34]	; 0x22
    ff1a:	e7e5      	b.n	fee8 <DRV_GMAC_PacketRx+0x134>
        return 0;
    ff1c:	2000      	movs	r0, #0
    ff1e:	4770      	bx	lr
    ff20:	2000      	movs	r0, #0
}
    ff22:	4770      	bx	lr
    return 0;
    ff24:	2000      	movs	r0, #0
    ff26:	e7ef      	b.n	ff08 <DRV_GMAC_PacketRx+0x154>
    ff28:	4650      	mov	r0, sl
    ff2a:	e7ed      	b.n	ff08 <DRV_GMAC_PacketRx+0x154>
	if(buffsPerRxPkt > 1)
    ff2c:	9b03      	ldr	r3, [sp, #12]
    ff2e:	2b01      	cmp	r3, #1
    ff30:	dc81      	bgt.n	fe36 <DRV_GMAC_PacketRx+0x82>
		pMACDrv->sGmacData._rxStat.nRxOkPackets++;		
    ff32:	4a0a      	ldr	r2, [pc, #40]	; (ff5c <DRV_GMAC_PacketRx+0x1a8>)
    ff34:	6e53      	ldr	r3, [r2, #100]	; 0x64
    ff36:	3301      	adds	r3, #1
    ff38:	6653      	str	r3, [r2, #100]	; 0x64
	if(pRes)
    ff3a:	f1ba 0f00 	cmp.w	sl, #0
    ff3e:	d08b      	beq.n	fe58 <DRV_GMAC_PacketRx+0xa4>
		*pRes = mRes;
    ff40:	2300      	movs	r3, #0
    ff42:	f88a 3000 	strb.w	r3, [sl]
	if(mRes == TCPIP_MAC_RES_OK)
    ff46:	e787      	b.n	fe58 <DRV_GMAC_PacketRx+0xa4>
	if(ethRes == DRV_PIC32CGMAC_RES_PACKET_QUEUED || ethRes == DRV_PIC32CGMAC_RES_NO_PACKET)
    ff48:	f107 39ff 	add.w	r9, r7, #4294967295
    ff4c:	fa5f f989 	uxtb.w	r9, r9
    ff50:	f1b9 0f01 	cmp.w	r9, #1
    ff54:	d896      	bhi.n	fe84 <DRV_GMAC_PacketRx+0xd0>
		mRes = TCPIP_MAC_RES_PENDING;
    ff56:	2301      	movs	r3, #1
    ff58:	e777      	b.n	fe4a <DRV_GMAC_PacketRx+0x96>
    ff5a:	bf00      	nop
    ff5c:	2000d8b8 	.word	0x2000d8b8
    ff60:	2000e18f 	.word	0x2000e18f

Disassembly of section .text.DRV_PIC32CGMAC_LibRxFilterHash_Calculate%237:

0000ff64 <DRV_PIC32CGMAC_LibRxFilterHash_Calculate>:
    if(hash->calculate_hash == true) // Calculate hash for given MAC address
    ff64:	7b0b      	ldrb	r3, [r1, #12]
    ff66:	2b01      	cmp	r3, #1
    ff68:	d008      	beq.n	ff7c <DRV_PIC32CGMAC_LibRxFilterHash_Calculate+0x18>
        hash_value = hash->hash_value;
    ff6a:	680b      	ldr	r3, [r1, #0]
    ff6c:	6849      	ldr	r1, [r1, #4]
    GMAC_REGS->GMAC_HRB = hash_value & 0xffffffff;
    ff6e:	4a68      	ldr	r2, [pc, #416]	; (10110 <DRV_PIC32CGMAC_LibRxFilterHash_Calculate+0x1ac>)
    ff70:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
    GMAC_REGS->GMAC_HRT = (hash_value >> 32) & 0xffffffff;    
    ff74:	f8c2 1084 	str.w	r1, [r2, #132]	; 0x84
}
    ff78:	2000      	movs	r0, #0
    ff7a:	4770      	bx	lr
{
    ff7c:	b4f0      	push	{r4, r5, r6, r7}
        mac_addr = (DRV_GMAC_MAC_ADDR*)(hash->DestMACAddr);
    ff7e:	6888      	ldr	r0, [r1, #8]
        hash_Index.index = 0;      
    ff80:	f04f 0100 	mov.w	r1, #0
        hash_Index.bits.b0 = (mac_addr[5].bits.b0)^(mac_addr[5].bits.b6)^(mac_addr[4].bits.b4)^(mac_addr[3].bits.b2)^(mac_addr[2].bits.b0)^(mac_addr[2].bits.b6)^(mac_addr[1].bits.b4)^(mac_addr[0].bits.b2);
    ff84:	7943      	ldrb	r3, [r0, #5]
    ff86:	f3c3 0200 	ubfx	r2, r3, #0, #1
    ff8a:	f3c3 1480 	ubfx	r4, r3, #6, #1
    ff8e:	4062      	eors	r2, r4
    ff90:	7907      	ldrb	r7, [r0, #4]
    ff92:	f3c7 1400 	ubfx	r4, r7, #4, #1
    ff96:	4062      	eors	r2, r4
    ff98:	78c6      	ldrb	r6, [r0, #3]
    ff9a:	f3c6 0480 	ubfx	r4, r6, #2, #1
    ff9e:	4062      	eors	r2, r4
    ffa0:	7885      	ldrb	r5, [r0, #2]
    ffa2:	f3c5 0400 	ubfx	r4, r5, #0, #1
    ffa6:	4062      	eors	r2, r4
    ffa8:	f3c5 1480 	ubfx	r4, r5, #6, #1
    ffac:	4062      	eors	r2, r4
    ffae:	7844      	ldrb	r4, [r0, #1]
    ffb0:	f3c4 1c00 	ubfx	ip, r4, #4, #1
    ffb4:	ea82 020c 	eor.w	r2, r2, ip
    ffb8:	7800      	ldrb	r0, [r0, #0]
    ffba:	f3c0 0c80 	ubfx	ip, r0, #2, #1
    ffbe:	ea82 020c 	eor.w	r2, r2, ip
    ffc2:	f362 0100 	bfi	r1, r2, #0, #1
        hash_Index.bits.b1 = (mac_addr[5].bits.b1)^(mac_addr[5].bits.b7)^(mac_addr[4].bits.b5)^(mac_addr[3].bits.b3)^(mac_addr[2].bits.b1)^(mac_addr[2].bits.b7)^(mac_addr[1].bits.b5)^(mac_addr[0].bits.b3);
    ffc6:	f3c3 0240 	ubfx	r2, r3, #1, #1
    ffca:	f3c3 1cc0 	ubfx	ip, r3, #7, #1
    ffce:	ea82 020c 	eor.w	r2, r2, ip
    ffd2:	f3c7 1c40 	ubfx	ip, r7, #5, #1
    ffd6:	ea82 020c 	eor.w	r2, r2, ip
    ffda:	f3c6 0cc0 	ubfx	ip, r6, #3, #1
    ffde:	ea82 020c 	eor.w	r2, r2, ip
    ffe2:	f3c5 0c40 	ubfx	ip, r5, #1, #1
    ffe6:	ea82 12d5 	eor.w	r2, r2, r5, lsr #7
    ffea:	ea82 020c 	eor.w	r2, r2, ip
    ffee:	f3c4 1c40 	ubfx	ip, r4, #5, #1
    fff2:	ea82 020c 	eor.w	r2, r2, ip
    fff6:	f3c0 0cc0 	ubfx	ip, r0, #3, #1
    fffa:	ea82 020c 	eor.w	r2, r2, ip
    fffe:	f362 0141 	bfi	r1, r2, #1, #1
        hash_Index.bits.b2 = (mac_addr[5].bits.b2)^(mac_addr[4].bits.b0)^(mac_addr[4].bits.b6)^(mac_addr[3].bits.b4)^(mac_addr[2].bits.b2)^(mac_addr[1].bits.b0)^(mac_addr[1].bits.b6)^(mac_addr[0].bits.b4);
   10002:	f3c3 0280 	ubfx	r2, r3, #2, #1
   10006:	f3c7 0c00 	ubfx	ip, r7, #0, #1
   1000a:	ea82 020c 	eor.w	r2, r2, ip
   1000e:	f3c7 1c80 	ubfx	ip, r7, #6, #1
   10012:	ea82 020c 	eor.w	r2, r2, ip
   10016:	f3c6 1c00 	ubfx	ip, r6, #4, #1
   1001a:	ea82 020c 	eor.w	r2, r2, ip
   1001e:	f3c5 0c80 	ubfx	ip, r5, #2, #1
   10022:	ea82 020c 	eor.w	r2, r2, ip
   10026:	f3c4 0c00 	ubfx	ip, r4, #0, #1
   1002a:	ea82 020c 	eor.w	r2, r2, ip
   1002e:	f3c4 1c80 	ubfx	ip, r4, #6, #1
   10032:	ea82 020c 	eor.w	r2, r2, ip
   10036:	f3c0 1c00 	ubfx	ip, r0, #4, #1
   1003a:	ea82 020c 	eor.w	r2, r2, ip
   1003e:	f362 0182 	bfi	r1, r2, #2, #1
        hash_Index.bits.b3 = (mac_addr[5].bits.b3)^(mac_addr[4].bits.b1)^(mac_addr[4].bits.b7)^(mac_addr[3].bits.b5)^(mac_addr[2].bits.b3)^(mac_addr[1].bits.b1)^(mac_addr[1].bits.b7)^(mac_addr[0].bits.b5);
   10042:	f3c3 02c0 	ubfx	r2, r3, #3, #1
   10046:	f3c7 0c40 	ubfx	ip, r7, #1, #1
   1004a:	ea82 12d7 	eor.w	r2, r2, r7, lsr #7
   1004e:	ea82 020c 	eor.w	r2, r2, ip
   10052:	f3c6 1c40 	ubfx	ip, r6, #5, #1
   10056:	ea82 020c 	eor.w	r2, r2, ip
   1005a:	f3c5 0cc0 	ubfx	ip, r5, #3, #1
   1005e:	ea82 020c 	eor.w	r2, r2, ip
   10062:	f3c4 0c40 	ubfx	ip, r4, #1, #1
   10066:	ea82 12d4 	eor.w	r2, r2, r4, lsr #7
   1006a:	ea82 020c 	eor.w	r2, r2, ip
   1006e:	f3c0 1c40 	ubfx	ip, r0, #5, #1
   10072:	ea82 020c 	eor.w	r2, r2, ip
   10076:	f362 01c3 	bfi	r1, r2, #3, #1
        hash_Index.bits.b4 = (mac_addr[5].bits.b4)^(mac_addr[4].bits.b2)^(mac_addr[3].bits.b0)^(mac_addr[3].bits.b6)^(mac_addr[2].bits.b4)^(mac_addr[1].bits.b2)^(mac_addr[0].bits.b0)^(mac_addr[0].bits.b6);
   1007a:	f3c3 1200 	ubfx	r2, r3, #4, #1
   1007e:	f3c7 0c80 	ubfx	ip, r7, #2, #1
   10082:	ea82 020c 	eor.w	r2, r2, ip
   10086:	f3c6 0c00 	ubfx	ip, r6, #0, #1
   1008a:	ea82 020c 	eor.w	r2, r2, ip
   1008e:	f3c6 1c80 	ubfx	ip, r6, #6, #1
   10092:	ea82 020c 	eor.w	r2, r2, ip
   10096:	f3c5 1c00 	ubfx	ip, r5, #4, #1
   1009a:	ea82 020c 	eor.w	r2, r2, ip
   1009e:	f3c4 0c80 	ubfx	ip, r4, #2, #1
   100a2:	ea82 020c 	eor.w	r2, r2, ip
   100a6:	f3c0 0c00 	ubfx	ip, r0, #0, #1
   100aa:	ea82 020c 	eor.w	r2, r2, ip
   100ae:	f3c0 1c80 	ubfx	ip, r0, #6, #1
   100b2:	ea82 020c 	eor.w	r2, r2, ip
   100b6:	f362 1104 	bfi	r1, r2, #4, #1
        hash_Index.bits.b5 = (mac_addr[5].bits.b5)^(mac_addr[4].bits.b3)^(mac_addr[3].bits.b1)^(mac_addr[3].bits.b7)^(mac_addr[2].bits.b5)^(mac_addr[1].bits.b3)^(mac_addr[0].bits.b1)^(mac_addr[0].bits.b7);
   100ba:	f3c3 1340 	ubfx	r3, r3, #5, #1
   100be:	f3c7 07c0 	ubfx	r7, r7, #3, #1
   100c2:	407b      	eors	r3, r7
   100c4:	f3c6 0240 	ubfx	r2, r6, #1, #1
   100c8:	ea83 13d6 	eor.w	r3, r3, r6, lsr #7
   100cc:	4053      	eors	r3, r2
   100ce:	f3c5 1540 	ubfx	r5, r5, #5, #1
   100d2:	406b      	eors	r3, r5
   100d4:	f3c4 04c0 	ubfx	r4, r4, #3, #1
   100d8:	4063      	eors	r3, r4
   100da:	f3c0 0240 	ubfx	r2, r0, #1, #1
   100de:	ea83 13d0 	eor.w	r3, r3, r0, lsr #7
   100e2:	4053      	eors	r3, r2
   100e4:	f363 1145 	bfi	r1, r3, #5, #1
    hash_value = GMAC_REGS->GMAC_HRT;
   100e8:	4b09      	ldr	r3, [pc, #36]	; (10110 <DRV_PIC32CGMAC_LibRxFilterHash_Calculate+0x1ac>)
   100ea:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
    hash_value = (hash_value << 32) | GMAC_REGS->GMAC_HRB;
   100ee:	f8d3 4080 	ldr.w	r4, [r3, #128]	; 0x80
        hash_value  |= (1 << (hash_Index.index));
   100f2:	b2c9      	uxtb	r1, r1
   100f4:	2301      	movs	r3, #1
   100f6:	408b      	lsls	r3, r1
   100f8:	17d9      	asrs	r1, r3, #31
   100fa:	4323      	orrs	r3, r4
   100fc:	4311      	orrs	r1, r2
    GMAC_REGS->GMAC_HRB = hash_value & 0xffffffff;
   100fe:	4a04      	ldr	r2, [pc, #16]	; (10110 <DRV_PIC32CGMAC_LibRxFilterHash_Calculate+0x1ac>)
   10100:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
    GMAC_REGS->GMAC_HRT = (hash_value >> 32) & 0xffffffff;    
   10104:	f8c2 1084 	str.w	r1, [r2, #132]	; 0x84
}
   10108:	2000      	movs	r0, #0
   1010a:	bcf0      	pop	{r4, r5, r6, r7}
   1010c:	4770      	bx	lr
   1010e:	bf00      	nop
   10110:	42000800 	.word	0x42000800

Disassembly of section .text.SERCOM1_USART_InterruptHandler%238:

00010114 <SERCOM1_USART_InterruptHandler>:
        }
    }
}

void SERCOM1_USART_InterruptHandler( void )
{
   10114:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    bool testCondition = false;
    if(SERCOM1_REGS->USART_INT.SERCOM_INTENSET != 0U)
   10116:	4b67      	ldr	r3, [pc, #412]	; (102b4 <SERCOM1_USART_InterruptHandler+0x1a0>)
   10118:	7d9b      	ldrb	r3, [r3, #22]
   1011a:	2b00      	cmp	r3, #0
   1011c:	f000 80c8 	beq.w	102b0 <SERCOM1_USART_InterruptHandler+0x19c>
    {
        /* Checks for error flag */
        testCondition = ((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_ERROR_Msk) == SERCOM_USART_INT_INTFLAG_ERROR_Msk);
   10120:	4a64      	ldr	r2, [pc, #400]	; (102b4 <SERCOM1_USART_InterruptHandler+0x1a0>)
   10122:	7e13      	ldrb	r3, [r2, #24]
   10124:	b2db      	uxtb	r3, r3
        testCondition = ((SERCOM1_REGS->USART_INT.SERCOM_INTENSET & SERCOM_USART_INT_INTENSET_ERROR_Msk) == SERCOM_USART_INT_INTENSET_ERROR_Msk) && testCondition;
   10126:	7d92      	ldrb	r2, [r2, #22]
   10128:	f012 0f80 	tst.w	r2, #128	; 0x80
   1012c:	d13f      	bne.n	101ae <SERCOM1_USART_InterruptHandler+0x9a>
        if(testCondition)
        {
            SERCOM1_USART_ISR_ERR_Handler();
        }

        testCondition = ((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_DRE_Msk) == SERCOM_USART_INT_INTFLAG_DRE_Msk);
   1012e:	4a61      	ldr	r2, [pc, #388]	; (102b4 <SERCOM1_USART_InterruptHandler+0x1a0>)
   10130:	7e13      	ldrb	r3, [r2, #24]
   10132:	b2db      	uxtb	r3, r3
        testCondition = ((SERCOM1_REGS->USART_INT.SERCOM_INTENSET & SERCOM_USART_INT_INTENSET_DRE_Msk) == SERCOM_USART_INT_INTENSET_DRE_Msk) && testCondition;
   10134:	7d92      	ldrb	r2, [r2, #22]
   10136:	f012 0f01 	tst.w	r2, #1
   1013a:	f000 80ac 	beq.w	10296 <SERCOM1_USART_InterruptHandler+0x182>
   1013e:	f013 0f01 	tst.w	r3, #1
   10142:	f000 80a8 	beq.w	10296 <SERCOM1_USART_InterruptHandler+0x182>
    while ((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_DRE_Msk) == SERCOM_USART_INT_INTFLAG_DRE_Msk)
   10146:	4d5b      	ldr	r5, [pc, #364]	; (102b4 <SERCOM1_USART_InterruptHandler+0x1a0>)
    uint32_t wrInIndex = sercom1USARTObj.wrInIndex;
   10148:	4c5b      	ldr	r4, [pc, #364]	; (102b8 <SERCOM1_USART_InterruptHandler+0x1a4>)
            *pWrByte = ((uint16_t*)&SERCOM1_USART_WriteBuffer)[wrOutIndex++];
   1014a:	4e5c      	ldr	r6, [pc, #368]	; (102bc <SERCOM1_USART_InterruptHandler+0x1a8>)
    while ((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_DRE_Msk) == SERCOM_USART_INT_INTFLAG_DRE_Msk)
   1014c:	7e2b      	ldrb	r3, [r5, #24]
   1014e:	f013 0f01 	tst.w	r3, #1
   10152:	f000 80a0 	beq.w	10296 <SERCOM1_USART_InterruptHandler+0x182>
    uint32_t wrInIndex = sercom1USARTObj.wrInIndex;
   10156:	68a3      	ldr	r3, [r4, #8]
    uint32_t wrOutIndex = sercom1USARTObj.wrOutIndex;
   10158:	68e2      	ldr	r2, [r4, #12]
    if (wrOutIndex != wrInIndex)
   1015a:	4293      	cmp	r3, r2
   1015c:	f000 8098 	beq.w	10290 <SERCOM1_USART_InterruptHandler+0x17c>
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   10160:	686b      	ldr	r3, [r5, #4]
   10162:	f003 0307 	and.w	r3, r3, #7
   10166:	2b01      	cmp	r3, #1
            *pWrByte = SERCOM1_USART_WriteBuffer[wrOutIndex++];
   10168:	f102 0301 	add.w	r3, r2, #1
   1016c:	bf14      	ite	ne
   1016e:	5cb2      	ldrbne	r2, [r6, r2]
            *pWrByte = ((uint16_t*)&SERCOM1_USART_WriteBuffer)[wrOutIndex++];
   10170:	f836 2012 	ldrheq.w	r2, [r6, r2, lsl #1]
        if (wrOutIndex >= sercom1USARTObj.wrBufferSize)
   10174:	6921      	ldr	r1, [r4, #16]
            wrOutIndex = 0U;
   10176:	4299      	cmp	r1, r3
   10178:	bf98      	it	ls
   1017a:	2300      	movls	r3, #0
        sercom1USARTObj.wrOutIndex = wrOutIndex;
   1017c:	60e3      	str	r3, [r4, #12]
            if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   1017e:	686b      	ldr	r3, [r5, #4]
   10180:	f003 0307 	and.w	r3, r3, #7
   10184:	2b01      	cmp	r3, #1
                SERCOM1_REGS->USART_INT.SERCOM_DATA = (uint8_t)wrByte;
   10186:	bf18      	it	ne
   10188:	b2d2      	uxtbne	r2, r2
                SERCOM1_REGS->USART_INT.SERCOM_DATA = wrByte;
   1018a:	62aa      	str	r2, [r5, #40]	; 0x28
    if (sercom1USARTObj.isWrNotificationEnabled == true)
   1018c:	7d23      	ldrb	r3, [r4, #20]
   1018e:	2b00      	cmp	r3, #0
   10190:	d0dc      	beq.n	1014c <SERCOM1_USART_InterruptHandler+0x38>
        nFreeWrBufferCount = SERCOM1_USART_WriteFreeBufferCountGet();
   10192:	f011 fbe9 	bl	21968 <SERCOM1_USART_WriteFreeBufferCountGet>
        if(sercom1USARTObj.wrCallback != NULL)
   10196:	6823      	ldr	r3, [r4, #0]
   10198:	2b00      	cmp	r3, #0
   1019a:	d0d7      	beq.n	1014c <SERCOM1_USART_InterruptHandler+0x38>
            if (sercom1USARTObj.isWrNotifyPersistently == true)
   1019c:	7f22      	ldrb	r2, [r4, #28]
   1019e:	b342      	cbz	r2, 101f2 <SERCOM1_USART_InterruptHandler+0xde>
                if (nFreeWrBufferCount >= sercom1USARTObj.wrThreshold)
   101a0:	69a2      	ldr	r2, [r4, #24]
   101a2:	4290      	cmp	r0, r2
   101a4:	d3d2      	bcc.n	1014c <SERCOM1_USART_InterruptHandler+0x38>
                    sercom1USARTObj.wrCallback(SERCOM_USART_EVENT_WRITE_THRESHOLD_REACHED, sercom1USARTObj.wrContext);
   101a6:	6861      	ldr	r1, [r4, #4]
   101a8:	2003      	movs	r0, #3
   101aa:	4798      	blx	r3
   101ac:	e7ce      	b.n	1014c <SERCOM1_USART_InterruptHandler+0x38>
        testCondition = ((SERCOM1_REGS->USART_INT.SERCOM_INTENSET & SERCOM_USART_INT_INTENSET_ERROR_Msk) == SERCOM_USART_INT_INTENSET_ERROR_Msk) && testCondition;
   101ae:	f013 0f80 	tst.w	r3, #128	; 0x80
   101b2:	d0bc      	beq.n	1012e <SERCOM1_USART_InterruptHandler+0x1a>
    USART_ERROR errorStatus = (USART_ERROR)(SERCOM1_REGS->USART_INT.SERCOM_STATUS & (SERCOM_USART_INT_STATUS_PERR_Msk | SERCOM_USART_INT_STATUS_FERR_Msk | SERCOM_USART_INT_STATUS_BUFOVF_Msk ));
   101b4:	4b3f      	ldr	r3, [pc, #252]	; (102b4 <SERCOM1_USART_InterruptHandler+0x1a0>)
   101b6:	8b5b      	ldrh	r3, [r3, #26]
    if(errorStatus != USART_ERROR_NONE)
   101b8:	f013 0307 	ands.w	r3, r3, #7
   101bc:	d0b7      	beq.n	1012e <SERCOM1_USART_InterruptHandler+0x1a>
        sercom1USARTObj.errorStatus = errorStatus;
   101be:	4a3e      	ldr	r2, [pc, #248]	; (102b8 <SERCOM1_USART_InterruptHandler+0x1a4>)
   101c0:	87d3      	strh	r3, [r2, #62]	; 0x3e
    SERCOM1_REGS->USART_INT.SERCOM_INTFLAG = SERCOM_USART_INT_INTFLAG_ERROR_Msk;
   101c2:	4b3c      	ldr	r3, [pc, #240]	; (102b4 <SERCOM1_USART_InterruptHandler+0x1a0>)
   101c4:	2280      	movs	r2, #128	; 0x80
   101c6:	761a      	strb	r2, [r3, #24]
    SERCOM1_REGS->USART_INT.SERCOM_STATUS = SERCOM_USART_INT_STATUS_PERR_Msk | SERCOM_USART_INT_STATUS_FERR_Msk | SERCOM_USART_INT_STATUS_BUFOVF_Msk ;
   101c8:	2207      	movs	r2, #7
   101ca:	835a      	strh	r2, [r3, #26]
    while((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_RXC_Msk) == SERCOM_USART_INT_INTFLAG_RXC_Msk)
   101cc:	7e1b      	ldrb	r3, [r3, #24]
   101ce:	f013 0f04 	tst.w	r3, #4
   101d2:	d005      	beq.n	101e0 <SERCOM1_USART_InterruptHandler+0xcc>
        u8dummyData = SERCOM1_REGS->USART_INT.SERCOM_DATA;
   101d4:	4b37      	ldr	r3, [pc, #220]	; (102b4 <SERCOM1_USART_InterruptHandler+0x1a0>)
   101d6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    while((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_RXC_Msk) == SERCOM_USART_INT_INTFLAG_RXC_Msk)
   101d8:	7e1a      	ldrb	r2, [r3, #24]
   101da:	f012 0f04 	tst.w	r2, #4
   101de:	d1fa      	bne.n	101d6 <SERCOM1_USART_InterruptHandler+0xc2>
        if(sercom1USARTObj.rdCallback != NULL)
   101e0:	4b35      	ldr	r3, [pc, #212]	; (102b8 <SERCOM1_USART_InterruptHandler+0x1a4>)
   101e2:	6a1b      	ldr	r3, [r3, #32]
   101e4:	2b00      	cmp	r3, #0
   101e6:	d0a2      	beq.n	1012e <SERCOM1_USART_InterruptHandler+0x1a>
            sercom1USARTObj.rdCallback(SERCOM_USART_EVENT_READ_ERROR, sercom1USARTObj.rdContext);
   101e8:	4a33      	ldr	r2, [pc, #204]	; (102b8 <SERCOM1_USART_InterruptHandler+0x1a4>)
   101ea:	6a51      	ldr	r1, [r2, #36]	; 0x24
   101ec:	2002      	movs	r0, #2
   101ee:	4798      	blx	r3
   101f0:	e79d      	b.n	1012e <SERCOM1_USART_InterruptHandler+0x1a>
                if (nFreeWrBufferCount == sercom1USARTObj.wrThreshold)
   101f2:	69a2      	ldr	r2, [r4, #24]
   101f4:	4290      	cmp	r0, r2
   101f6:	d1a9      	bne.n	1014c <SERCOM1_USART_InterruptHandler+0x38>
                    sercom1USARTObj.wrCallback(SERCOM_USART_EVENT_WRITE_THRESHOLD_REACHED, sercom1USARTObj.wrContext);
   101f8:	6861      	ldr	r1, [r4, #4]
   101fa:	2003      	movs	r0, #3
   101fc:	4798      	blx	r3
   101fe:	e7a5      	b.n	1014c <SERCOM1_USART_InterruptHandler+0x38>
        if(sercom1USARTObj.rdCallback != NULL)
   10200:	6a22      	ldr	r2, [r4, #32]
   10202:	2a00      	cmp	r2, #0
   10204:	d032      	beq.n	1026c <SERCOM1_USART_InterruptHandler+0x158>
            sercom1USARTObj.rdCallback(SERCOM_USART_EVENT_READ_BUFFER_FULL, sercom1USARTObj.rdContext);
   10206:	6a61      	ldr	r1, [r4, #36]	; 0x24
   10208:	4638      	mov	r0, r7
   1020a:	4790      	blx	r2
            tempInIndex = sercom1USARTObj.rdInIndex + 1U;
   1020c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1020e:	3301      	adds	r3, #1
            if (tempInIndex >= sercom1USARTObj.rdBufferSize)
   10210:	6b22      	ldr	r2, [r4, #48]	; 0x30
                tempInIndex = 0U;
   10212:	4293      	cmp	r3, r2
   10214:	bf28      	it	cs
   10216:	2300      	movcs	r3, #0
   10218:	e028      	b.n	1026c <SERCOM1_USART_InterruptHandler+0x158>
            ((uint16_t*)&SERCOM1_USART_ReadBuffer)[sercom1USARTObj.rdInIndex] = rdByte;
   1021a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
   1021c:	4a28      	ldr	r2, [pc, #160]	; (102c0 <SERCOM1_USART_InterruptHandler+0x1ac>)
        if (SERCOM1_USART_RxPushByte( (uint16_t)SERCOM1_REGS->USART_INT.SERCOM_DATA) == true)
   1021e:	f822 6011 	strh.w	r6, [r2, r1, lsl #1]
   10222:	e02e      	b.n	10282 <SERCOM1_USART_InterruptHandler+0x16e>
        nUnreadBytesAvailable = SERCOM1_USART_ReadCountGet();
   10224:	f011 fa06 	bl	21634 <SERCOM1_USART_ReadCountGet>
        if(sercom1USARTObj.rdCallback != NULL)
   10228:	6a23      	ldr	r3, [r4, #32]
   1022a:	2b00      	cmp	r3, #0
   1022c:	d02e      	beq.n	1028c <SERCOM1_USART_InterruptHandler+0x178>
            if (sercom1USARTObj.isRdNotifyPersistently == true)
   1022e:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
   10232:	b132      	cbz	r2, 10242 <SERCOM1_USART_InterruptHandler+0x12e>
                if (nUnreadBytesAvailable >= sercom1USARTObj.rdThreshold)
   10234:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   10236:	4290      	cmp	r0, r2
   10238:	d328      	bcc.n	1028c <SERCOM1_USART_InterruptHandler+0x178>
                    sercom1USARTObj.rdCallback(SERCOM_USART_EVENT_READ_THRESHOLD_REACHED, sercom1USARTObj.rdContext);
   1023a:	6a61      	ldr	r1, [r4, #36]	; 0x24
   1023c:	2000      	movs	r0, #0
   1023e:	4798      	blx	r3
   10240:	e024      	b.n	1028c <SERCOM1_USART_InterruptHandler+0x178>
                if (nUnreadBytesAvailable == sercom1USARTObj.rdThreshold)
   10242:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   10244:	4290      	cmp	r0, r2
   10246:	d121      	bne.n	1028c <SERCOM1_USART_InterruptHandler+0x178>
                    sercom1USARTObj.rdCallback(SERCOM_USART_EVENT_READ_THRESHOLD_REACHED, sercom1USARTObj.rdContext);
   10248:	6a61      	ldr	r1, [r4, #36]	; 0x24
   1024a:	2000      	movs	r0, #0
   1024c:	4798      	blx	r3
   1024e:	e01d      	b.n	1028c <SERCOM1_USART_InterruptHandler+0x178>
    while ((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_RXC_Msk) == SERCOM_USART_INT_INTFLAG_RXC_Msk)
   10250:	7e2b      	ldrb	r3, [r5, #24]
   10252:	f013 0f04 	tst.w	r3, #4
   10256:	d02b      	beq.n	102b0 <SERCOM1_USART_InterruptHandler+0x19c>
        if (SERCOM1_USART_RxPushByte( (uint16_t)SERCOM1_REGS->USART_INT.SERCOM_DATA) == true)
   10258:	6aae      	ldr	r6, [r5, #40]	; 0x28
    tempInIndex = sercom1USARTObj.rdInIndex + 1U;
   1025a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1025c:	3301      	adds	r3, #1
    if (tempInIndex >= sercom1USARTObj.rdBufferSize)
   1025e:	6b22      	ldr	r2, [r4, #48]	; 0x30
        tempInIndex = 0U;
   10260:	4293      	cmp	r3, r2
   10262:	bf28      	it	cs
   10264:	2300      	movcs	r3, #0
    if (tempInIndex == sercom1USARTObj.rdOutIndex)
   10266:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   10268:	429a      	cmp	r2, r3
   1026a:	d0c9      	beq.n	10200 <SERCOM1_USART_InterruptHandler+0xec>
    if (tempInIndex != sercom1USARTObj.rdOutIndex)
   1026c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   1026e:	429a      	cmp	r2, r3
   10270:	d0ee      	beq.n	10250 <SERCOM1_USART_InterruptHandler+0x13c>
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   10272:	686a      	ldr	r2, [r5, #4]
   10274:	f002 0207 	and.w	r2, r2, #7
   10278:	2a01      	cmp	r2, #1
   1027a:	d0ce      	beq.n	1021a <SERCOM1_USART_InterruptHandler+0x106>
            SERCOM1_USART_ReadBuffer[sercom1USARTObj.rdInIndex] = (uint8_t)rdByte;
   1027c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   1027e:	4910      	ldr	r1, [pc, #64]	; (102c0 <SERCOM1_USART_InterruptHandler+0x1ac>)
   10280:	548e      	strb	r6, [r1, r2]
        sercom1USARTObj.rdInIndex = tempInIndex;
   10282:	62a3      	str	r3, [r4, #40]	; 0x28
    if (sercom1USARTObj.isRdNotificationEnabled == true)
   10284:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
   10288:	2b00      	cmp	r3, #0
   1028a:	d1cb      	bne.n	10224 <SERCOM1_USART_InterruptHandler+0x110>
            sercom1USARTObj.rdCallback(SERCOM_USART_EVENT_READ_BUFFER_FULL, sercom1USARTObj.rdContext);
   1028c:	2701      	movs	r7, #1
   1028e:	e7df      	b.n	10250 <SERCOM1_USART_InterruptHandler+0x13c>
            SERCOM1_USART_TX_INT_DISABLE();
   10290:	4b08      	ldr	r3, [pc, #32]	; (102b4 <SERCOM1_USART_InterruptHandler+0x1a0>)
   10292:	2201      	movs	r2, #1
   10294:	751a      	strb	r2, [r3, #20]
        {
            SERCOM1_USART_ISR_TX_Handler();
        }

        /* Checks for receive complete empty flag */
        testCondition = (SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_RXC_Msk);
   10296:	4a07      	ldr	r2, [pc, #28]	; (102b4 <SERCOM1_USART_InterruptHandler+0x1a0>)
   10298:	7e13      	ldrb	r3, [r2, #24]
   1029a:	b2db      	uxtb	r3, r3
        testCondition = (SERCOM1_REGS->USART_INT.SERCOM_INTENSET & SERCOM_USART_INT_INTENSET_RXC_Msk) && testCondition;
   1029c:	7d92      	ldrb	r2, [r2, #22]
   1029e:	f012 0f04 	tst.w	r2, #4
   102a2:	d005      	beq.n	102b0 <SERCOM1_USART_InterruptHandler+0x19c>
   102a4:	f013 0f04 	tst.w	r3, #4
   102a8:	d002      	beq.n	102b0 <SERCOM1_USART_InterruptHandler+0x19c>
    while ((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_RXC_Msk) == SERCOM_USART_INT_INTFLAG_RXC_Msk)
   102aa:	4d02      	ldr	r5, [pc, #8]	; (102b4 <SERCOM1_USART_InterruptHandler+0x1a0>)
    tempInIndex = sercom1USARTObj.rdInIndex + 1U;
   102ac:	4c02      	ldr	r4, [pc, #8]	; (102b8 <SERCOM1_USART_InterruptHandler+0x1a4>)
   102ae:	e7ed      	b.n	1028c <SERCOM1_USART_InterruptHandler+0x178>
        if(testCondition)
        {
            SERCOM1_USART_ISR_RX_Handler();
        }
    }
   102b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   102b2:	bf00      	nop
   102b4:	40003400 	.word	0x40003400
   102b8:	2000dff0 	.word	0x2000dff0
   102bc:	2000b004 	.word	0x2000b004
   102c0:	2000a004 	.word	0x2000a004

Disassembly of section .text.APP_Tasks%239:

000102c4 <APP_Tasks>:

  Remarks:
    See prototype in app.h.
 */
void APP_Tasks(void)
{
   102c4:	b510      	push	{r4, lr}
   102c6:	b084      	sub	sp, #16
	DRV_MIIM_RESULT opRes = DRV_MIIM_RES_OK;
	/* Check the application's current state. */
	switch (appData.state)
   102c8:	4b54      	ldr	r3, [pc, #336]	; (1041c <APP_Tasks+0x158>)
   102ca:	781b      	ldrb	r3, [r3, #0]
   102cc:	2b06      	cmp	r3, #6
   102ce:	d810      	bhi.n	102f2 <APP_Tasks+0x2e>
   102d0:	e8df f003 	tbb	[pc, r3]
   102d4:	5011041b 	.word	0x5011041b
   102d8:	0f77      	.short	0x0f77
   102da:	96          	.byte	0x96
   102db:	00          	.byte	0x00
    {
        
        case APP_DISPLAY_INIT:
        {
            gfx_mono_ssd1306_init();
   102dc:	f00c fc4c 	bl	1cb78 <gfx_mono_ssd1306_init>
            gfx_mono_draw_string("Rock and Roll\n"
   102e0:	4b4f      	ldr	r3, [pc, #316]	; (10420 <APP_Tasks+0x15c>)
   102e2:	2200      	movs	r2, #0
   102e4:	4611      	mov	r1, r2
   102e6:	484f      	ldr	r0, [pc, #316]	; (10424 <APP_Tasks+0x160>)
   102e8:	f009 ffba 	bl	1a260 <gfx_mono_draw_string>
                                 "   ==> <==    ", 0, 0, &sysfont);
            appData.state = APP_WAIT_STACK_INIT;
   102ec:	4b4b      	ldr	r3, [pc, #300]	; (1041c <APP_Tasks+0x158>)
   102ee:	2202      	movs	r2, #2
   102f0:	701a      	strb	r2, [r3, #0]
        {
            /* TODO: Handle error in application's state machine. */
            break;
        }
	}
}
   102f2:	b004      	add	sp, #16
   102f4:	bd10      	pop	{r4, pc}
            if (TCPIP_STACK_Status(sysObj.tcpip) == SYS_STATUS_READY)
   102f6:	4b4c      	ldr	r3, [pc, #304]	; (10428 <APP_Tasks+0x164>)
   102f8:	6898      	ldr	r0, [r3, #8]
   102fa:	f010 fe37 	bl	20f6c <TCPIP_STACK_Status>
   102fe:	2802      	cmp	r0, #2
   10300:	d1f7      	bne.n	102f2 <APP_Tasks+0x2e>
                appData.state = APP_MIIM_INIT;
   10302:	4b46      	ldr	r3, [pc, #280]	; (1041c <APP_Tasks+0x158>)
   10304:	2200      	movs	r2, #0
   10306:	701a      	strb	r2, [r3, #0]
   10308:	e7f3      	b.n	102f2 <APP_Tasks+0x2e>
static DRV_MIIM_RESULT local_miim_init(void)
{
	DRV_MIIM_SETUP miimSetup;
	DRV_MIIM_RESULT res;

	opHandle                    = 0;
   1030a:	4b48      	ldr	r3, [pc, #288]	; (1042c <APP_Tasks+0x168>)
   1030c:	2000      	movs	r0, #0
   1030e:	6018      	str	r0, [r3, #0]
	clientObj.miimOpHandle      = &opHandle;
   10310:	4c47      	ldr	r4, [pc, #284]	; (10430 <APP_Tasks+0x16c>)
   10312:	6123      	str	r3, [r4, #16]
	clientObj.miimBase          = &DRV_MIIM_OBJECT_BASE_Default;
   10314:	4b47      	ldr	r3, [pc, #284]	; (10434 <APP_Tasks+0x170>)
   10316:	60e3      	str	r3, [r4, #12]
	miimObjIx                   = DRV_MIIM_DRIVER_INDEX;

	/*  Open the MIIM driver and get an instance to it. */
	clientObj.miimHandle = clientObj.miimBase->DRV_MIIM_Open(miimObjIx, DRV_IO_INTENT_SHARED);
   10318:	695b      	ldr	r3, [r3, #20]
   1031a:	4601      	mov	r1, r0
   1031c:	4798      	blx	r3
   1031e:	60a0      	str	r0, [r4, #8]
	if ( (clientObj.miimHandle == DRV_HANDLE_INVALID) || (clientObj.miimHandle == 0))
   10320:	1e43      	subs	r3, r0, #1
   10322:	f113 0f03 	cmn.w	r3, #3
   10326:	d815      	bhi.n	10354 <APP_Tasks+0x90>
		res = DRV_MIIM_RES_OP_INTERNAL_ERR;
	}
	else
	{

		miimSetup.hostClockFreq = (uint32_t) TCPIP_INTMAC_PERIPHERAL_CLK;
   10328:	4b43      	ldr	r3, [pc, #268]	; (10438 <APP_Tasks+0x174>)
   1032a:	9301      	str	r3, [sp, #4]
		miimSetup.maxBusFreq = 2000000;
   1032c:	4b43      	ldr	r3, [pc, #268]	; (1043c <APP_Tasks+0x178>)
   1032e:	9302      	str	r3, [sp, #8]
		miimSetup.setupFlags = 0;
   10330:	2300      	movs	r3, #0
   10332:	f88d 300c 	strb.w	r3, [sp, #12]

		/*  Setup the miim driver instance. */
		res = clientObj.miimBase->DRV_MIIM_Setup(clientObj.miimHandle, &miimSetup);
   10336:	4b3e      	ldr	r3, [pc, #248]	; (10430 <APP_Tasks+0x16c>)
   10338:	68db      	ldr	r3, [r3, #12]
   1033a:	699b      	ldr	r3, [r3, #24]
   1033c:	a901      	add	r1, sp, #4
   1033e:	4798      	blx	r3
		if (res < 0)
   10340:	2800      	cmp	r0, #0
   10342:	db0e      	blt.n	10362 <APP_Tasks+0x9e>
		{
			SYS_CONSOLE_PRINT("> Local miim setup: failed!\r\n");
		}
		else
		{
			SYS_CONSOLE_PRINT("> Miim Successfully opened. \r\n");
   10344:	493e      	ldr	r1, [pc, #248]	; (10440 <APP_Tasks+0x17c>)
   10346:	2000      	movs	r0, #0
   10348:	f00a fba8 	bl	1aa9c <SYS_CONSOLE_Print>
            appData.state = APP_READ_OPERATION_MODE;
   1034c:	4b33      	ldr	r3, [pc, #204]	; (1041c <APP_Tasks+0x158>)
   1034e:	2203      	movs	r2, #3
   10350:	701a      	strb	r2, [r3, #0]
            break;
   10352:	e7ce      	b.n	102f2 <APP_Tasks+0x2e>
		SYS_CONSOLE_PRINT("> Local miim open: failed!\r\n");
   10354:	493b      	ldr	r1, [pc, #236]	; (10444 <APP_Tasks+0x180>)
   10356:	2000      	movs	r0, #0
   10358:	f00a fba0 	bl	1aa9c <SYS_CONSOLE_Print>
		clientObj.miimHandle = 0;
   1035c:	2200      	movs	r2, #0
   1035e:	60a2      	str	r2, [r4, #8]
		res = DRV_MIIM_RES_OP_INTERNAL_ERR;
   10360:	e003      	b.n	1036a <APP_Tasks+0xa6>
			SYS_CONSOLE_PRINT("> Local miim setup: failed!\r\n");
   10362:	4939      	ldr	r1, [pc, #228]	; (10448 <APP_Tasks+0x184>)
   10364:	2000      	movs	r0, #0
   10366:	f00a fb99 	bl	1aa9c <SYS_CONSOLE_Print>
                SYS_CONSOLE_PRINT("App: miim setup failed !\r\n");
   1036a:	4938      	ldr	r1, [pc, #224]	; (1044c <APP_Tasks+0x188>)
   1036c:	2000      	movs	r0, #0
   1036e:	f00a fb95 	bl	1aa9c <SYS_CONSOLE_Print>
   10372:	e7eb      	b.n	1034c <APP_Tasks+0x88>
}
#endif

static DRV_MIIM_RESULT Read_Phy_Register (LAN867X_REG_OBJ *clientObj, int phyAddress, const uint32_t regAddr, uint16_t *rData)
{
	clientObj->phyAddress = phyAddress;
   10374:	482e      	ldr	r0, [pc, #184]	; (10430 <APP_Tasks+0x16c>)
   10376:	2300      	movs	r3, #0
   10378:	6003      	str	r3, [r0, #0]
	return Lan867x_Read_Register(clientObj, regAddr, rData);
   1037a:	4a35      	ldr	r2, [pc, #212]	; (10450 <APP_Tasks+0x18c>)
   1037c:	4935      	ldr	r1, [pc, #212]	; (10454 <APP_Tasks+0x190>)
   1037e:	f00d fe52 	bl	1e026 <Lan867x_Read_Register>
            if (opRes < 0)
   10382:	1e02      	subs	r2, r0, #0
   10384:	db0d      	blt.n	103a2 <APP_Tasks+0xde>
            else if (opRes == DRV_MIIM_RES_OK) /* Check operation is completed. */
   10386:	2a00      	cmp	r2, #0
   10388:	d1b3      	bne.n	102f2 <APP_Tasks+0x2e>
                if(1 == R2F(data, PHY_PLCA_CTRL0_EN))
   1038a:	4b31      	ldr	r3, [pc, #196]	; (10450 <APP_Tasks+0x18c>)
   1038c:	881a      	ldrh	r2, [r3, #0]
   1038e:	0bd3      	lsrs	r3, r2, #15
   10390:	d10f      	bne.n	103b2 <APP_Tasks+0xee>
                    SYS_CONSOLE_PRINT(" Lan867x is in CSMA mode. \r\n", data);
   10392:	4931      	ldr	r1, [pc, #196]	; (10458 <APP_Tasks+0x194>)
   10394:	2000      	movs	r0, #0
   10396:	f00a fb81 	bl	1aa9c <SYS_CONSOLE_Print>
                    appData.state = APP_MIIM_CLOSE;
   1039a:	4b20      	ldr	r3, [pc, #128]	; (1041c <APP_Tasks+0x158>)
   1039c:	2206      	movs	r2, #6
   1039e:	701a      	strb	r2, [r3, #0]
   103a0:	e7a7      	b.n	102f2 <APP_Tasks+0x2e>
                SYS_CONSOLE_PRINT("Error occured:%d\r\n", opRes);
   103a2:	492e      	ldr	r1, [pc, #184]	; (1045c <APP_Tasks+0x198>)
   103a4:	2000      	movs	r0, #0
   103a6:	f00a fb79 	bl	1aa9c <SYS_CONSOLE_Print>
                appData.state = APP_MIIM_CLOSE;
   103aa:	4b1c      	ldr	r3, [pc, #112]	; (1041c <APP_Tasks+0x158>)
   103ac:	2206      	movs	r2, #6
   103ae:	701a      	strb	r2, [r3, #0]
   103b0:	e79f      	b.n	102f2 <APP_Tasks+0x2e>
                    SYS_CONSOLE_PRINT(" Lan867x is in PLCA mode. \r\n", data);
   103b2:	492b      	ldr	r1, [pc, #172]	; (10460 <APP_Tasks+0x19c>)
   103b4:	2000      	movs	r0, #0
   103b6:	f00a fb71 	bl	1aa9c <SYS_CONSOLE_Print>
                    appData.state = APP_READ_PLCA_CONFIGURATION;
   103ba:	4b18      	ldr	r3, [pc, #96]	; (1041c <APP_Tasks+0x158>)
   103bc:	2204      	movs	r2, #4
   103be:	701a      	strb	r2, [r3, #0]
   103c0:	e797      	b.n	102f2 <APP_Tasks+0x2e>
	clientObj->phyAddress = phyAddress;
   103c2:	481b      	ldr	r0, [pc, #108]	; (10430 <APP_Tasks+0x16c>)
   103c4:	2300      	movs	r3, #0
   103c6:	6003      	str	r3, [r0, #0]
	return Lan867x_Read_Register(clientObj, regAddr, rData);
   103c8:	4a21      	ldr	r2, [pc, #132]	; (10450 <APP_Tasks+0x18c>)
   103ca:	4926      	ldr	r1, [pc, #152]	; (10464 <APP_Tasks+0x1a0>)
   103cc:	f00d fe2b 	bl	1e026 <Lan867x_Read_Register>
            if (opRes < 0)
   103d0:	1e02      	subs	r2, r0, #0
   103d2:	db0d      	blt.n	103f0 <APP_Tasks+0x12c>
            else if (opRes == DRV_MIIM_RES_OK) /* Check operation is completed. */
   103d4:	2a00      	cmp	r2, #0
   103d6:	d18c      	bne.n	102f2 <APP_Tasks+0x2e>
                SYS_CONSOLE_PRINT(" Node Id: %d, Node count: %d. \r\n", R2F(data, PHY_PLCA_CTRL1_ID0), R2F(data, PHY_PLCA_CTRL1_NCNT));
   103d8:	4b1d      	ldr	r3, [pc, #116]	; (10450 <APP_Tasks+0x18c>)
   103da:	881a      	ldrh	r2, [r3, #0]
   103dc:	0a13      	lsrs	r3, r2, #8
   103de:	b2d2      	uxtb	r2, r2
   103e0:	4921      	ldr	r1, [pc, #132]	; (10468 <APP_Tasks+0x1a4>)
   103e2:	2000      	movs	r0, #0
   103e4:	f00a fb5a 	bl	1aa9c <SYS_CONSOLE_Print>
                appData.state = APP_MIIM_CLOSE;
   103e8:	4b0c      	ldr	r3, [pc, #48]	; (1041c <APP_Tasks+0x158>)
   103ea:	2206      	movs	r2, #6
   103ec:	701a      	strb	r2, [r3, #0]
   103ee:	e780      	b.n	102f2 <APP_Tasks+0x2e>
                SYS_CONSOLE_PRINT("Error occured:%d\r\n", opRes);
   103f0:	491a      	ldr	r1, [pc, #104]	; (1045c <APP_Tasks+0x198>)
   103f2:	2000      	movs	r0, #0
   103f4:	f00a fb52 	bl	1aa9c <SYS_CONSOLE_Print>
                appData.state = APP_MIIM_CLOSE;
   103f8:	4b08      	ldr	r3, [pc, #32]	; (1041c <APP_Tasks+0x158>)
   103fa:	2206      	movs	r2, #6
   103fc:	701a      	strb	r2, [r3, #0]
   103fe:	e778      	b.n	102f2 <APP_Tasks+0x2e>
	clientObj.miimBase->DRV_MIIM_Close(clientObj.miimHandle);
   10400:	4c0b      	ldr	r4, [pc, #44]	; (10430 <APP_Tasks+0x16c>)
   10402:	68e3      	ldr	r3, [r4, #12]
   10404:	69db      	ldr	r3, [r3, #28]
   10406:	68a0      	ldr	r0, [r4, #8]
   10408:	4798      	blx	r3
	clientObj.miimHandle = 0;
   1040a:	2000      	movs	r0, #0
   1040c:	60a0      	str	r0, [r4, #8]
	SYS_CONSOLE_PRINT("> Miim closed. \r\n");
   1040e:	4917      	ldr	r1, [pc, #92]	; (1046c <APP_Tasks+0x1a8>)
   10410:	f00a fb44 	bl	1aa9c <SYS_CONSOLE_Print>
            appData.state = APP_STATE_SERVICE_TASKS;
   10414:	4b01      	ldr	r3, [pc, #4]	; (1041c <APP_Tasks+0x158>)
   10416:	2207      	movs	r2, #7
   10418:	701a      	strb	r2, [r3, #0]
}
   1041a:	e76a      	b.n	102f2 <APP_Tasks+0x2e>
   1041c:	2000e4f4 	.word	0x2000e4f4
   10420:	2000e34c 	.word	0x2000e34c
   10424:	00012cd0 	.word	0x00012cd0
   10428:	2000e264 	.word	0x2000e264
   1042c:	2000e4d8 	.word	0x2000e4d8
   10430:	2000e2f0 	.word	0x2000e2f0
   10434:	0001da34 	.word	0x0001da34
   10438:	07270e00 	.word	0x07270e00
   1043c:	001e8480 	.word	0x001e8480
   10440:	00012d30 	.word	0x00012d30
   10444:	00012cf0 	.word	0x00012cf0
   10448:	00012d10 	.word	0x00012d10
   1044c:	00012ddc 	.word	0x00012ddc
   10450:	2000e36e 	.word	0x2000e36e
   10454:	001fca01 	.word	0x001fca01
   10458:	00012d84 	.word	0x00012d84
   1045c:	00012d50 	.word	0x00012d50
   10460:	00012d64 	.word	0x00012d64
   10464:	001fca02 	.word	0x001fca02
   10468:	00012da4 	.word	0x00012da4
   1046c:	00012dc8 	.word	0x00012dc8

Disassembly of section .text._DRV_ETHPHY_DefaultDetect%240:

00010470 <_DRV_ETHPHY_DefaultDetect>:
}


// default PHY detection procedure
static DRV_ETHPHY_RESULT _DRV_ETHPHY_DefaultDetect( const struct DRV_ETHPHY_OBJECT_BASE_TYPE* pBaseObj, DRV_HANDLE hClientObj)
{
   10470:	b570      	push	{r4, r5, r6, lr}
   10472:	b084      	sub	sp, #16
   10474:	4605      	mov	r5, r0
   10476:	460c      	mov	r4, r1
            uint16_t high;
        };
    }vendorData;

    __BMCONbits_t bmcon;
    uint16_t    phyReg = 0;
   10478:	2300      	movs	r3, #0
   1047a:	f8ad 300a 	strh.w	r3, [sp, #10]
    uint16_t    detectPhase = 0;
    int         phyAddress = 0;
   1047e:	9301      	str	r3, [sp, #4]

    DRV_ETHPHY_RESULT res = pBaseObj->DRV_ETHPHY_VendorDataGet(hClientObj, &vendorData.w);
   10480:	6c83      	ldr	r3, [r0, #72]	; 0x48
   10482:	a903      	add	r1, sp, #12
   10484:	4620      	mov	r0, r4
   10486:	4798      	blx	r3

    if(res < 0)
   10488:	2800      	cmp	r0, #0
   1048a:	db20      	blt.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
    {   // some error occurred
        return res;
    }

    pBaseObj->DRV_ETHPHY_PhyAddressGet(hClientObj, DRV_ETHPHY_INF_IDX_ALL_EXTERNAL, &phyAddress);
   1048c:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1048e:	aa01      	add	r2, sp, #4
   10490:	2100      	movs	r1, #0
   10492:	4620      	mov	r0, r4
   10494:	4798      	blx	r3

    _PhyDetectPhase(detectPhase);

    // try to detect the PHY and reset it

    switch (detectPhase)
   10496:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   1049a:	2b07      	cmp	r3, #7
   1049c:	f200 80b5 	bhi.w	1060a <_DRV_ETHPHY_DefaultDetect+0x19a>
   104a0:	e8df f003 	tbb	[pc, r3]
   104a4:	48341704 	.word	0x48341704
   104a8:	9f8c765a 	.word	0x9f8c765a
    {
        case 0:
            // initiate a read of the BMCON register
            res = pBaseObj->DRV_ETHPHY_VendorSMIReadStart(hClientObj, PHY_REG_BMCON, phyAddress);
   104ac:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   104ae:	9a01      	ldr	r2, [sp, #4]
   104b0:	2100      	movs	r1, #0
   104b2:	4620      	mov	r0, r4
   104b4:	4798      	blx	r3
            if(res < 0)
   104b6:	2800      	cmp	r0, #0
   104b8:	db09      	blt.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            {   // some error
                return res;
            }
            else if(res == DRV_ETHPHY_RES_PENDING)
   104ba:	2801      	cmp	r0, #1
   104bc:	d007      	beq.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            {   // retry
                return DRV_ETHPHY_RES_PENDING;
            }

            // advance to the next phase
            vendorData.low = ++detectPhase;
   104be:	2601      	movs	r6, #1
   104c0:	f8ad 600c 	strh.w	r6, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
   104c4:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   104c6:	9903      	ldr	r1, [sp, #12]
   104c8:	4620      	mov	r0, r4
   104ca:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
   104cc:	4630      	mov	r0, r6

        default:
            // shouldn't happen
            return DRV_ETHPHY_RES_OPERATION_ERR;
    }
}
   104ce:	b004      	add	sp, #16
   104d0:	bd70      	pop	{r4, r5, r6, pc}
            res = pBaseObj->DRV_ETHPHY_VendorSMIReadResultGet(hClientObj, &phyReg);
   104d2:	6d6b      	ldr	r3, [r5, #84]	; 0x54
   104d4:	f10d 010a 	add.w	r1, sp, #10
   104d8:	4620      	mov	r0, r4
   104da:	4798      	blx	r3
            if(res < 0)
   104dc:	2800      	cmp	r0, #0
   104de:	dbf6      	blt.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
   104e0:	2801      	cmp	r0, #1
   104e2:	d0f4      	beq.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            if(bmcon.RESET == 0)
   104e4:	f99d 300b 	ldrsb.w	r3, [sp, #11]
   104e8:	2b00      	cmp	r3, #0
   104ea:	da06      	bge.n	104fa <_DRV_ETHPHY_DefaultDetect+0x8a>
            vendorData.w = 0;
   104ec:	2100      	movs	r1, #0
   104ee:	9103      	str	r1, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
   104f0:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   104f2:	4620      	mov	r0, r4
   104f4:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
   104f6:	2001      	movs	r0, #1
   104f8:	e7e9      	b.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
                vendorData.low = ++detectPhase;
   104fa:	2302      	movs	r3, #2
   104fc:	f8ad 300c 	strh.w	r3, [sp, #12]
                pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
   10500:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   10502:	9903      	ldr	r1, [sp, #12]
   10504:	4620      	mov	r0, r4
   10506:	4798      	blx	r3
                return DRV_ETHPHY_RES_PENDING;
   10508:	2001      	movs	r0, #1
   1050a:	e7e0      	b.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            res = pBaseObj->DRV_ETHPHY_VendorSMIWriteStart(hClientObj, PHY_REG_BMCON, bmcon.w, phyAddress);
   1050c:	6dae      	ldr	r6, [r5, #88]	; 0x58
   1050e:	9b01      	ldr	r3, [sp, #4]
   10510:	f44f 4282 	mov.w	r2, #16640	; 0x4100
   10514:	2100      	movs	r1, #0
   10516:	4620      	mov	r0, r4
   10518:	47b0      	blx	r6
            if(res < 0)
   1051a:	2800      	cmp	r0, #0
   1051c:	dbd7      	blt.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
   1051e:	2801      	cmp	r0, #1
   10520:	d0d5      	beq.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            vendorData.low = ++detectPhase;
   10522:	2303      	movs	r3, #3
   10524:	f8ad 300c 	strh.w	r3, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
   10528:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   1052a:	9903      	ldr	r1, [sp, #12]
   1052c:	4620      	mov	r0, r4
   1052e:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
   10530:	2001      	movs	r0, #1
   10532:	e7cc      	b.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            res = pBaseObj->DRV_ETHPHY_VendorSMIReadStart(hClientObj, PHY_REG_BMCON, phyAddress);
   10534:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   10536:	9a01      	ldr	r2, [sp, #4]
   10538:	2100      	movs	r1, #0
   1053a:	4620      	mov	r0, r4
   1053c:	4798      	blx	r3
            if(res < 0)
   1053e:	2800      	cmp	r0, #0
   10540:	dbc5      	blt.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
   10542:	2801      	cmp	r0, #1
   10544:	d0c3      	beq.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            vendorData.low = ++detectPhase;
   10546:	2304      	movs	r3, #4
   10548:	f8ad 300c 	strh.w	r3, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
   1054c:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   1054e:	9903      	ldr	r1, [sp, #12]
   10550:	4620      	mov	r0, r4
   10552:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
   10554:	2001      	movs	r0, #1
   10556:	e7ba      	b.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            res = pBaseObj->DRV_ETHPHY_VendorSMIReadResultGet(hClientObj, &phyReg);
   10558:	6d6b      	ldr	r3, [r5, #84]	; 0x54
   1055a:	f10d 010a 	add.w	r1, sp, #10
   1055e:	4620      	mov	r0, r4
   10560:	4798      	blx	r3
            if(res < 0)
   10562:	2800      	cmp	r0, #0
   10564:	dbb3      	blt.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
   10566:	2801      	cmp	r0, #1
   10568:	d0b1      	beq.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            bmcon.w = phyReg;
   1056a:	f8bd 200a 	ldrh.w	r2, [sp, #10]
            if( (bmcon.LOOPBACK == 0) || (bmcon.DUPLEX == 0) )
   1056e:	f3c2 2307 	ubfx	r3, r2, #8, #8
   10572:	f003 0341 	and.w	r3, r3, #65	; 0x41
   10576:	2b41      	cmp	r3, #65	; 0x41
   10578:	d14a      	bne.n	10610 <_DRV_ETHPHY_DefaultDetect+0x1a0>
            vendorData.high = phyReg;
   1057a:	f8ad 200e 	strh.w	r2, [sp, #14]
            vendorData.low = ++detectPhase;
   1057e:	2305      	movs	r3, #5
   10580:	f8ad 300c 	strh.w	r3, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
   10584:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   10586:	9903      	ldr	r1, [sp, #12]
   10588:	4620      	mov	r0, r4
   1058a:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
   1058c:	2001      	movs	r0, #1
   1058e:	e79e      	b.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            bmcon.w ^= _BMCON_LOOPBACK_MASK | _BMCON_DUPLEX_MASK;
   10590:	f8bd 200e 	ldrh.w	r2, [sp, #14]
            res = pBaseObj->DRV_ETHPHY_VendorSMIWriteStart(hClientObj, PHY_REG_BMCON, bmcon.w, phyAddress);
   10594:	6dae      	ldr	r6, [r5, #88]	; 0x58
   10596:	9b01      	ldr	r3, [sp, #4]
   10598:	f482 4282 	eor.w	r2, r2, #16640	; 0x4100
   1059c:	2100      	movs	r1, #0
   1059e:	4620      	mov	r0, r4
   105a0:	47b0      	blx	r6
            if(res < 0)
   105a2:	2800      	cmp	r0, #0
   105a4:	db93      	blt.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
   105a6:	2801      	cmp	r0, #1
   105a8:	d091      	beq.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            vendorData.low = ++detectPhase;
   105aa:	2306      	movs	r3, #6
   105ac:	f8ad 300c 	strh.w	r3, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
   105b0:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   105b2:	9903      	ldr	r1, [sp, #12]
   105b4:	4620      	mov	r0, r4
   105b6:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
   105b8:	2001      	movs	r0, #1
   105ba:	e788      	b.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            res = pBaseObj->DRV_ETHPHY_VendorSMIReadStart(hClientObj, PHY_REG_BMCON, phyAddress);
   105bc:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   105be:	9a01      	ldr	r2, [sp, #4]
   105c0:	2100      	movs	r1, #0
   105c2:	4620      	mov	r0, r4
   105c4:	4798      	blx	r3
            if(res < 0)
   105c6:	2800      	cmp	r0, #0
   105c8:	db81      	blt.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
   105ca:	2801      	cmp	r0, #1
   105cc:	f43f af7f 	beq.w	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            vendorData.low = ++detectPhase;
   105d0:	2307      	movs	r3, #7
   105d2:	f8ad 300c 	strh.w	r3, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
   105d6:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   105d8:	9903      	ldr	r1, [sp, #12]
   105da:	4620      	mov	r0, r4
   105dc:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
   105de:	2001      	movs	r0, #1
   105e0:	e775      	b.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            res = pBaseObj->DRV_ETHPHY_VendorSMIReadResultGet(hClientObj, &phyReg);
   105e2:	6d6b      	ldr	r3, [r5, #84]	; 0x54
   105e4:	f10d 010a 	add.w	r1, sp, #10
   105e8:	4620      	mov	r0, r4
   105ea:	4798      	blx	r3
            if(res < 0)
   105ec:	2800      	cmp	r0, #0
   105ee:	f6ff af6e 	blt.w	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
   105f2:	2801      	cmp	r0, #1
   105f4:	f43f af6b 	beq.w	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            if(bmcon.LOOPBACK || bmcon.DUPLEX)
   105f8:	f89d 300b 	ldrb.w	r3, [sp, #11]
   105fc:	f013 0f41 	tst.w	r3, #65	; 0x41
   10600:	bf14      	ite	ne
   10602:	f04f 30ff 	movne.w	r0, #4294967295
   10606:	2000      	moveq	r0, #0
   10608:	e761      	b.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
            return DRV_ETHPHY_RES_OPERATION_ERR;
   1060a:	f06f 0008 	mvn.w	r0, #8
   1060e:	e75e      	b.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>
                return DRV_ETHPHY_RES_DTCT_ERR; 
   10610:	f04f 30ff 	mov.w	r0, #4294967295
   10614:	e75b      	b.n	104ce <_DRV_ETHPHY_DefaultDetect+0x5e>

Disassembly of section .text.CommandIperfSize%241:

00010618 <CommandIperfSize>:
    (*pCmdIO->pCmdApi->print)(cmdIoParam, "iperfi: OK, set the IP address to instance: %d\r\n", iperfIndex);

}

static void CommandIperfSize(SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char** argv)
{
   10618:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1061c:	b087      	sub	sp, #28
    bool        setTx, setRx;
    uint32_t    txBuffSize, rxBuffSize;
    tIperfState* pIState;	
    int iperfIndex;

    const void* cmdIoParam = pCmdIO->cmdIoParam;
   1061e:	6843      	ldr	r3, [r0, #4]
   10620:	9302      	str	r3, [sp, #8]


    if (argc < 3)
   10622:	2902      	cmp	r1, #2
   10624:	dd18      	ble.n	10658 <CommandIperfSize+0x40>
   10626:	4682      	mov	sl, r0
   10628:	4614      	mov	r4, r2
   1062a:	3903      	subs	r1, #3
   1062c:	0849      	lsrs	r1, r1, #1
   1062e:	3208      	adds	r2, #8
   10630:	eb02 07c1 	add.w	r7, r2, r1, lsl #3
        return;
    }

    setTx = setRx = 0;
    txBuffSize = rxBuffSize = 0;
    iperfIndex = 0;     // assume index 0 if not specified
   10634:	f04f 0800 	mov.w	r8, #0
    txBuffSize = rxBuffSize = 0;
   10638:	f8cd 8014 	str.w	r8, [sp, #20]
   1063c:	f8cd 800c 	str.w	r8, [sp, #12]
    setTx = setRx = 0;
   10640:	f8cd 8010 	str.w	r8, [sp, #16]
   10644:	46c3      	mov	fp, r8
    while(currIx + 1 < argc)
    { 
        char* param = argv[currIx];
        char* paramVal = argv[currIx + 1];

        if(strcmp(param, "-tx") == 0)
   10646:	f8df 9140 	ldr.w	r9, [pc, #320]	; 10788 <CommandIperfSize+0x170>
        {
            setTx = true;
            txBuffSize = atoi(paramVal);
        }
        else if(strcmp(param, "-rx") == 0)
   1064a:	f109 0338 	add.w	r3, r9, #56	; 0x38
   1064e:	9300      	str	r3, [sp, #0]
        {
            setRx = true;
            rxBuffSize = atoi(paramVal);
        }
        else if((strcmp(param, "-i") == 0) || (strcmp(param, "--index") == 0))
   10650:	f109 033c 	add.w	r3, r9, #60	; 0x3c
   10654:	9301      	str	r3, [sp, #4]
   10656:	e010      	b.n	1067a <CommandIperfSize+0x62>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: iperfs <-tx size> <-rx size> <-i index>\r\n");
   10658:	6803      	ldr	r3, [r0, #0]
   1065a:	681b      	ldr	r3, [r3, #0]
   1065c:	494a      	ldr	r1, [pc, #296]	; (10788 <CommandIperfSize+0x170>)
   1065e:	9802      	ldr	r0, [sp, #8]
   10660:	4798      	blx	r3
    {
        pIState->rxBuffSize = rxBuffSize;
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "iperfs: OK, set instance %d rx size to %d\r\n", iperfIndex, rxBuffSize);
    }

}
   10662:	b007      	add	sp, #28
   10664:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            txBuffSize = atoi(paramVal);
   10668:	4630      	mov	r0, r6
   1066a:	f011 fdc9 	bl	22200 <atoi>
   1066e:	9003      	str	r0, [sp, #12]
            setTx = true;
   10670:	f04f 0b01 	mov.w	fp, #1
        currIx += 2;
   10674:	3408      	adds	r4, #8
    while(currIx + 1 < argc)
   10676:	42a7      	cmp	r7, r4
   10678:	d02b      	beq.n	106d2 <CommandIperfSize+0xba>
        char* param = argv[currIx];
   1067a:	6865      	ldr	r5, [r4, #4]
        char* paramVal = argv[currIx + 1];
   1067c:	68a6      	ldr	r6, [r4, #8]
        if(strcmp(param, "-tx") == 0)
   1067e:	4943      	ldr	r1, [pc, #268]	; (1078c <CommandIperfSize+0x174>)
   10680:	4628      	mov	r0, r5
   10682:	f011 f9cb 	bl	21a1c <strcmp>
   10686:	2800      	cmp	r0, #0
   10688:	d0ee      	beq.n	10668 <CommandIperfSize+0x50>
        else if(strcmp(param, "-rx") == 0)
   1068a:	9900      	ldr	r1, [sp, #0]
   1068c:	4628      	mov	r0, r5
   1068e:	f011 f9c5 	bl	21a1c <strcmp>
   10692:	b178      	cbz	r0, 106b4 <CommandIperfSize+0x9c>
        else if((strcmp(param, "-i") == 0) || (strcmp(param, "--index") == 0))
   10694:	9901      	ldr	r1, [sp, #4]
   10696:	4628      	mov	r0, r5
   10698:	f011 f9c0 	bl	21a1c <strcmp>
   1069c:	b128      	cbz	r0, 106aa <CommandIperfSize+0x92>
   1069e:	f109 0140 	add.w	r1, r9, #64	; 0x40
   106a2:	4628      	mov	r0, r5
   106a4:	f011 f9ba 	bl	21a1c <strcmp>
   106a8:	b958      	cbnz	r0, 106c2 <CommandIperfSize+0xaa>
            iperfIndex = atoi(paramVal);
   106aa:	4630      	mov	r0, r6
   106ac:	f011 fda8 	bl	22200 <atoi>
   106b0:	4680      	mov	r8, r0
   106b2:	e7df      	b.n	10674 <CommandIperfSize+0x5c>
            rxBuffSize = atoi(paramVal);
   106b4:	4630      	mov	r0, r6
   106b6:	f011 fda3 	bl	22200 <atoi>
   106ba:	9005      	str	r0, [sp, #20]
            setRx = true;
   106bc:	2301      	movs	r3, #1
   106be:	9304      	str	r3, [sp, #16]
   106c0:	e7d8      	b.n	10674 <CommandIperfSize+0x5c>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperfi: Unknown parameter\r\n");
   106c2:	f8da 3000 	ldr.w	r3, [sl]
   106c6:	681b      	ldr	r3, [r3, #0]
   106c8:	f109 0148 	add.w	r1, r9, #72	; 0x48
   106cc:	9802      	ldr	r0, [sp, #8]
   106ce:	4798      	blx	r3
   106d0:	e7d0      	b.n	10674 <CommandIperfSize+0x5c>
    if(iperfIndex < 0 || iperfIndex >= nIperfSessions)
   106d2:	f1b8 0f00 	cmp.w	r8, #0
   106d6:	db1e      	blt.n	10716 <CommandIperfSize+0xfe>
   106d8:	4b2d      	ldr	r3, [pc, #180]	; (10790 <CommandIperfSize+0x178>)
   106da:	681b      	ldr	r3, [r3, #0]
   106dc:	4543      	cmp	r3, r8
   106de:	dd1a      	ble.n	10716 <CommandIperfSize+0xfe>
    if((setTx && (txBuffSize <= 0 || txBuffSize >= 65536)) || (setRx && (rxBuffSize <= 0 || rxBuffSize >= 65536)))
   106e0:	f1bb 0f00 	cmp.w	fp, #0
   106e4:	d028      	beq.n	10738 <CommandIperfSize+0x120>
   106e6:	9b03      	ldr	r3, [sp, #12]
   106e8:	1e5a      	subs	r2, r3, #1
   106ea:	f64f 73fe 	movw	r3, #65534	; 0xfffe
   106ee:	429a      	cmp	r2, r3
   106f0:	d81b      	bhi.n	1072a <CommandIperfSize+0x112>
   106f2:	9b04      	ldr	r3, [sp, #16]
   106f4:	bb1b      	cbnz	r3, 1073e <CommandIperfSize+0x126>
        pIState->txBuffSize = txBuffSize;
   106f6:	4a27      	ldr	r2, [pc, #156]	; (10794 <CommandIperfSize+0x17c>)
   106f8:	23d8      	movs	r3, #216	; 0xd8
   106fa:	fb03 2308 	mla	r3, r3, r8, r2
   106fe:	9a03      	ldr	r2, [sp, #12]
   10700:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "iperfs: OK, set instance %d tx size to %d\r\n", iperfIndex, txBuffSize);
   10704:	f8da 3000 	ldr.w	r3, [sl]
   10708:	685c      	ldr	r4, [r3, #4]
   1070a:	4613      	mov	r3, r2
   1070c:	4642      	mov	r2, r8
   1070e:	4922      	ldr	r1, [pc, #136]	; (10798 <CommandIperfSize+0x180>)
   10710:	9802      	ldr	r0, [sp, #8]
   10712:	47a0      	blx	r4
    if(setRx)
   10714:	e7a5      	b.n	10662 <CommandIperfSize+0x4a>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: Invalid session number. Min: 0, Max: %d\r\n", nIperfSessions - 1);
   10716:	4b1e      	ldr	r3, [pc, #120]	; (10790 <CommandIperfSize+0x178>)
   10718:	681a      	ldr	r2, [r3, #0]
   1071a:	f8da 3000 	ldr.w	r3, [sl]
   1071e:	685b      	ldr	r3, [r3, #4]
   10720:	3a01      	subs	r2, #1
   10722:	491e      	ldr	r1, [pc, #120]	; (1079c <CommandIperfSize+0x184>)
   10724:	9802      	ldr	r0, [sp, #8]
   10726:	4798      	blx	r3
        return;
   10728:	e79b      	b.n	10662 <CommandIperfSize+0x4a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperfs: 0 < size < 65536\r\n");
   1072a:	f8da 3000 	ldr.w	r3, [sl]
   1072e:	681b      	ldr	r3, [r3, #0]
   10730:	491b      	ldr	r1, [pc, #108]	; (107a0 <CommandIperfSize+0x188>)
   10732:	9802      	ldr	r0, [sp, #8]
   10734:	4798      	blx	r3
        return;
   10736:	e794      	b.n	10662 <CommandIperfSize+0x4a>
    if((setTx && (txBuffSize <= 0 || txBuffSize >= 65536)) || (setRx && (rxBuffSize <= 0 || rxBuffSize >= 65536)))
   10738:	9b04      	ldr	r3, [sp, #16]
   1073a:	2b00      	cmp	r3, #0
   1073c:	d091      	beq.n	10662 <CommandIperfSize+0x4a>
   1073e:	9b05      	ldr	r3, [sp, #20]
   10740:	1e5a      	subs	r2, r3, #1
   10742:	f64f 73fe 	movw	r3, #65534	; 0xfffe
   10746:	429a      	cmp	r2, r3
   10748:	d8ef      	bhi.n	1072a <CommandIperfSize+0x112>
    pIState = gIperfState + iperfIndex;	
   1074a:	4b12      	ldr	r3, [pc, #72]	; (10794 <CommandIperfSize+0x17c>)
   1074c:	24d8      	movs	r4, #216	; 0xd8
   1074e:	fb04 3408 	mla	r4, r4, r8, r3
    if(setTx)
   10752:	f1bb 0f00 	cmp.w	fp, #0
   10756:	d00a      	beq.n	1076e <CommandIperfSize+0x156>
        pIState->txBuffSize = txBuffSize;
   10758:	9a03      	ldr	r2, [sp, #12]
   1075a:	f8c4 20b8 	str.w	r2, [r4, #184]	; 0xb8
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "iperfs: OK, set instance %d tx size to %d\r\n", iperfIndex, txBuffSize);
   1075e:	f8da 3000 	ldr.w	r3, [sl]
   10762:	685d      	ldr	r5, [r3, #4]
   10764:	4613      	mov	r3, r2
   10766:	4642      	mov	r2, r8
   10768:	490b      	ldr	r1, [pc, #44]	; (10798 <CommandIperfSize+0x180>)
   1076a:	9802      	ldr	r0, [sp, #8]
   1076c:	47a8      	blx	r5
        pIState->rxBuffSize = rxBuffSize;
   1076e:	9a05      	ldr	r2, [sp, #20]
   10770:	f8c4 20bc 	str.w	r2, [r4, #188]	; 0xbc
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "iperfs: OK, set instance %d rx size to %d\r\n", iperfIndex, rxBuffSize);
   10774:	f8da 3000 	ldr.w	r3, [sl]
   10778:	685c      	ldr	r4, [r3, #4]
   1077a:	4613      	mov	r3, r2
   1077c:	4642      	mov	r2, r8
   1077e:	4909      	ldr	r1, [pc, #36]	; (107a4 <CommandIperfSize+0x18c>)
   10780:	9802      	ldr	r0, [sp, #8]
   10782:	47a0      	blx	r4
   10784:	e76d      	b.n	10662 <CommandIperfSize+0x4a>
   10786:	bf00      	nop
   10788:	000057b4 	.word	0x000057b4
   1078c:	000057e8 	.word	0x000057e8
   10790:	2000e3f0 	.word	0x2000e3f0
   10794:	2000d9b0 	.word	0x2000d9b0
   10798:	00005894 	.word	0x00005894
   1079c:	00005818 	.word	0x00005818
   107a0:	0000584c 	.word	0x0000584c
   107a4:	00005868 	.word	0x00005868

Disassembly of section .text.TCPIP_DHCP_Initialize%242:

000107a8 <TCPIP_DHCP_Initialize>:
{
   107a8:	b5f0      	push	{r4, r5, r6, r7, lr}
   107aa:	b083      	sub	sp, #12
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_UP)
   107ac:	7f03      	ldrb	r3, [r0, #28]
   107ae:	2b03      	cmp	r3, #3
   107b0:	d062      	beq.n	10878 <TCPIP_DHCP_Initialize+0xd0>
   107b2:	4604      	mov	r4, r0
   107b4:	460d      	mov	r5, r1
    if(dhcpInitCount == 0)
   107b6:	4b55      	ldr	r3, [pc, #340]	; (1090c <TCPIP_DHCP_Initialize+0x164>)
   107b8:	681b      	ldr	r3, [r3, #0]
   107ba:	2b00      	cmp	r3, #0
   107bc:	d13b      	bne.n	10836 <TCPIP_DHCP_Initialize+0x8e>
        if(pDhcpConfig == 0)
   107be:	2900      	cmp	r1, #0
   107c0:	f000 809f 	beq.w	10902 <TCPIP_DHCP_Initialize+0x15a>
        dhcpMemH = stackCtrl->memH;
   107c4:	68c0      	ldr	r0, [r0, #12]
   107c6:	4b52      	ldr	r3, [pc, #328]	; (10910 <TCPIP_DHCP_Initialize+0x168>)
   107c8:	6018      	str	r0, [r3, #0]
        dhcpClientSocket = INVALID_UDP_SOCKET;
   107ca:	4b52      	ldr	r3, [pc, #328]	; (10914 <TCPIP_DHCP_Initialize+0x16c>)
   107cc:	f64f 72ff 	movw	r2, #65535	; 0xffff
   107d0:	801a      	strh	r2, [r3, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Calloc)(h, nElems, elemSize);
   107d2:	6883      	ldr	r3, [r0, #8]
   107d4:	225c      	movs	r2, #92	; 0x5c
   107d6:	6821      	ldr	r1, [r4, #0]
   107d8:	4798      	blx	r3
        DHCPClients = (DHCP_CLIENT_VARS*)TCPIP_HEAP_Calloc(dhcpMemH,  stackCtrl->nIfs, sizeof(DHCP_CLIENT_VARS));
   107da:	4b4f      	ldr	r3, [pc, #316]	; (10918 <TCPIP_DHCP_Initialize+0x170>)
   107dc:	6018      	str	r0, [r3, #0]
        if(DHCPClients == 0)
   107de:	2800      	cmp	r0, #0
   107e0:	f000 8091 	beq.w	10906 <TCPIP_DHCP_Initialize+0x15e>
        dhcpSignalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_DHCP_Task, TCPIP_DHCP_TASK_TICK_RATE);
   107e4:	2205      	movs	r2, #5
   107e6:	494d      	ldr	r1, [pc, #308]	; (1091c <TCPIP_DHCP_Initialize+0x174>)
   107e8:	200c      	movs	r0, #12
   107ea:	f00c fbe9 	bl	1cfc0 <_TCPIPStackSignalHandlerRegister>
   107ee:	4b4c      	ldr	r3, [pc, #304]	; (10920 <TCPIP_DHCP_Initialize+0x178>)
   107f0:	6018      	str	r0, [r3, #0]
        iniRes = TCPIP_Notification_Initialize(&dhcpRegisteredUsers);
   107f2:	484c      	ldr	r0, [pc, #304]	; (10924 <TCPIP_DHCP_Initialize+0x17c>)
   107f4:	f011 fcc7 	bl	22186 <TCPIP_Notification_Initialize>
   107f8:	4607      	mov	r7, r0
        dhcpClientPort = pDhcpConfig->dhcpCliPort;
   107fa:	68aa      	ldr	r2, [r5, #8]
   107fc:	4b4a      	ldr	r3, [pc, #296]	; (10928 <TCPIP_DHCP_Initialize+0x180>)
   107fe:	801a      	strh	r2, [r3, #0]
        dhcpServerPort = pDhcpConfig->dhcpSrvPort;
   10800:	89a9      	ldrh	r1, [r5, #12]
   10802:	4b4a      	ldr	r3, [pc, #296]	; (1092c <TCPIP_DHCP_Initialize+0x184>)
   10804:	8019      	strh	r1, [r3, #0]
    UDP_SOCKET dhcpSkt = TCPIP_UDP_OpenClientSkt(IP_ADDRESS_TYPE_IPV4, dhcpServerPort, 0, UDP_OPEN_CLIENT | UDP_OPEN_CONFIG_SERVICE);
   10806:	f44f 7381 	mov.w	r3, #258	; 0x102
   1080a:	2200      	movs	r2, #0
   1080c:	2001      	movs	r0, #1
   1080e:	f00d fd19 	bl	1e244 <TCPIP_UDP_OpenClientSkt>
   10812:	4606      	mov	r6, r0
    while(dhcpSkt != INVALID_UDP_SOCKET)
   10814:	f1b0 3fff 	cmp.w	r0, #4294967295
   10818:	d13b      	bne.n	10892 <TCPIP_DHCP_Initialize+0xea>
        dhcpClientSocket = _DHCPOpenSocket();
   1081a:	4b3e      	ldr	r3, [pc, #248]	; (10914 <TCPIP_DHCP_Initialize+0x16c>)
   1081c:	801e      	strh	r6, [r3, #0]
        if(dhcpSignalHandle == 0 || iniRes == 0 || dhcpClientSocket == INVALID_UDP_SOCKET)
   1081e:	4b40      	ldr	r3, [pc, #256]	; (10920 <TCPIP_DHCP_Initialize+0x178>)
   10820:	681b      	ldr	r3, [r3, #0]
   10822:	2b00      	cmp	r3, #0
   10824:	d065      	beq.n	108f2 <TCPIP_DHCP_Initialize+0x14a>
   10826:	2f00      	cmp	r7, #0
   10828:	d063      	beq.n	108f2 <TCPIP_DHCP_Initialize+0x14a>
   1082a:	f1b6 3fff 	cmp.w	r6, #4294967295
   1082e:	d060      	beq.n	108f2 <TCPIP_DHCP_Initialize+0x14a>
        dhcpInterfaces = stackCtrl->nIfs;
   10830:	6822      	ldr	r2, [r4, #0]
   10832:	4b3f      	ldr	r3, [pc, #252]	; (10930 <TCPIP_DHCP_Initialize+0x188>)
   10834:	601a      	str	r2, [r3, #0]
    pClient = DHCPClients + stackCtrl->netIx;
   10836:	69a3      	ldr	r3, [r4, #24]
   10838:	4a37      	ldr	r2, [pc, #220]	; (10918 <TCPIP_DHCP_Initialize+0x170>)
   1083a:	6812      	ldr	r2, [r2, #0]
   1083c:	215c      	movs	r1, #92	; 0x5c
   1083e:	fb01 2303 	mla	r3, r1, r3, r2
    pClient->flags.val = 0;
   10842:	2200      	movs	r2, #0
   10844:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
    pClient->tOpFailTmo = (pDhcpConfig->dhcpTmo < 1) ? TCPIP_DHCP_INIT_FAIL_TMO : (uint16_t)pDhcpConfig->dhcpTmo;
   10848:	686a      	ldr	r2, [r5, #4]
   1084a:	2a00      	cmp	r2, #0
   1084c:	bfd8      	it	le
   1084e:	220a      	movle	r2, #10
   10850:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
    pClient->dhcpTmoBase = (TCPIP_DHCP_EXP_BACKOFF_BASE < TCPIP_DHCP_EXP_BACKOFF_FUZZ + 1) ? TCPIP_DHCP_EXP_BACKOFF_FUZZ + 1 : TCPIP_DHCP_EXP_BACKOFF_BASE;
   10854:	2202      	movs	r2, #2
   10856:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    pClient->tLeaseCheck = TCPIP_DHCP_LEASE_CHECK_TMO;
   1085a:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
    if(stackCtrl->pNetIf->Flags.bIsDHCPEnabled != 0)
   1085e:	6960      	ldr	r0, [r4, #20]
   10860:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   10864:	f013 0f01 	tst.w	r3, #1
   10868:	d147      	bne.n	108fa <TCPIP_DHCP_Initialize+0x152>
    dhcpInitCount++;
   1086a:	4a28      	ldr	r2, [pc, #160]	; (1090c <TCPIP_DHCP_Initialize+0x164>)
   1086c:	6813      	ldr	r3, [r2, #0]
   1086e:	3301      	adds	r3, #1
   10870:	6013      	str	r3, [r2, #0]
    return true;
   10872:	2001      	movs	r0, #1
}
   10874:	b003      	add	sp, #12
   10876:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if(stackCtrl->pNetIf->Flags.bIsDHCPEnabled != 0)
   10878:	6940      	ldr	r0, [r0, #20]
   1087a:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   1087e:	f013 0f01 	tst.w	r3, #1
   10882:	d101      	bne.n	10888 <TCPIP_DHCP_Initialize+0xe0>
        return true;
   10884:	2001      	movs	r0, #1
   10886:	e7f5      	b.n	10874 <TCPIP_DHCP_Initialize+0xcc>
            _DHCPEnable(stackCtrl->pNetIf, TCPIP_DHCP_OPER_INIT);
   10888:	2101      	movs	r1, #1
   1088a:	f007 fcc5 	bl	18218 <_DHCPEnable>
        return true;
   1088e:	2001      	movs	r0, #1
   10890:	e7f0      	b.n	10874 <TCPIP_DHCP_Initialize+0xcc>
        TCPIP_UDP_OptionsGet(dhcpSkt, UDP_OPTION_TX_BUFF, (void*)&txBuffSize);
   10892:	f10d 0206 	add.w	r2, sp, #6
   10896:	2105      	movs	r1, #5
   10898:	f002 f986 	bl	12ba8 <TCPIP_UDP_OptionsGet>
        if(txBuffSize < TCPIP_DHCP_MIN_UDP_TX_BUFFER_SIZE)
   1089c:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   108a0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   108a4:	d208      	bcs.n	108b8 <TCPIP_DHCP_Initialize+0x110>
            txBuffSize = TCPIP_DHCP_MIN_UDP_TX_BUFFER_SIZE;
   108a6:	f44f 7200 	mov.w	r2, #512	; 0x200
   108aa:	f8ad 2006 	strh.w	r2, [sp, #6]
            if(!TCPIP_UDP_OptionsSet(dhcpSkt, UDP_OPTION_TX_BUFF, (void*)(uintptr_t)txBuffSize))
   108ae:	2105      	movs	r1, #5
   108b0:	4630      	mov	r0, r6
   108b2:	f7fe f83d 	bl	e930 <TCPIP_UDP_OptionsSet>
   108b6:	b138      	cbz	r0, 108c8 <TCPIP_DHCP_Initialize+0x120>
        if(!TCPIP_UDP_Bind(dhcpSkt, IP_ADDRESS_TYPE_IPV4, dhcpClientPort,  0))
   108b8:	2300      	movs	r3, #0
   108ba:	4a1b      	ldr	r2, [pc, #108]	; (10928 <TCPIP_DHCP_Initialize+0x180>)
   108bc:	8812      	ldrh	r2, [r2, #0]
   108be:	2101      	movs	r1, #1
   108c0:	4630      	mov	r0, r6
   108c2:	f002 fa99 	bl	12df8 <TCPIP_UDP_Bind>
   108c6:	b928      	cbnz	r0, 108d4 <TCPIP_DHCP_Initialize+0x12c>
        TCPIP_UDP_Close(dhcpSkt);
   108c8:	4630      	mov	r0, r6
   108ca:	f00e fd2d 	bl	1f328 <TCPIP_UDP_Close>
        dhcpSkt = INVALID_UDP_SOCKET;
   108ce:	f04f 36ff 	mov.w	r6, #4294967295
   108d2:	e7a2      	b.n	1081a <TCPIP_DHCP_Initialize+0x72>
        TCPIP_UDP_OptionsSet(dhcpSkt, UDP_OPTION_STRICT_ADDRESS, 0);
   108d4:	2200      	movs	r2, #0
   108d6:	2102      	movs	r1, #2
   108d8:	4630      	mov	r0, r6
   108da:	f7fe f829 	bl	e930 <TCPIP_UDP_OptionsSet>
        sigHandle = TCPIP_UDP_SignalHandlerRegister(dhcpSkt, TCPIP_UDP_SIGNAL_RX_DATA, _DHCPSocketRxSignalHandler, 0);
   108de:	2300      	movs	r3, #0
   108e0:	4a14      	ldr	r2, [pc, #80]	; (10934 <TCPIP_DHCP_Initialize+0x18c>)
   108e2:	f44f 7180 	mov.w	r1, #256	; 0x100
   108e6:	4630      	mov	r0, r6
   108e8:	f00c fda3 	bl	1d432 <TCPIP_UDP_SignalHandlerRegister>
        if(sigHandle == 0)
   108ec:	2800      	cmp	r0, #0
   108ee:	d194      	bne.n	1081a <TCPIP_DHCP_Initialize+0x72>
   108f0:	e7ea      	b.n	108c8 <TCPIP_DHCP_Initialize+0x120>
            _DHCPCleanup();
   108f2:	f007 ff33 	bl	1875c <_DHCPCleanup>
            return false;
   108f6:	2000      	movs	r0, #0
   108f8:	e7bc      	b.n	10874 <TCPIP_DHCP_Initialize+0xcc>
        _DHCPEnable(stackCtrl->pNetIf, TCPIP_DHCP_OPER_INIT);
   108fa:	2101      	movs	r1, #1
   108fc:	f007 fc8c 	bl	18218 <_DHCPEnable>
   10900:	e7b3      	b.n	1086a <TCPIP_DHCP_Initialize+0xc2>
            return false;
   10902:	2000      	movs	r0, #0
   10904:	e7b6      	b.n	10874 <TCPIP_DHCP_Initialize+0xcc>
            return false;
   10906:	2000      	movs	r0, #0
   10908:	e7b4      	b.n	10874 <TCPIP_DHCP_Initialize+0xcc>
   1090a:	bf00      	nop
   1090c:	2000e40c 	.word	0x2000e40c
   10910:	2000e414 	.word	0x2000e414
   10914:	2000e504 	.word	0x2000e504
   10918:	2000e408 	.word	0x2000e408
   1091c:	00008c19 	.word	0x00008c19
   10920:	2000e41c 	.word	0x2000e41c
   10924:	2000e250 	.word	0x2000e250
   10928:	2000e502 	.word	0x2000e502
   1092c:	2000e506 	.word	0x2000e506
   10930:	2000e410 	.word	0x2000e410
   10934:	000217c3 	.word	0x000217c3

Disassembly of section .text._Command_MacInfo%243:

00010938 <_Command_MacInfo>:
{
   10938:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1093c:	f6ad 0d3c 	subw	sp, sp, #2108	; 0x83c
   10940:	4606      	mov	r6, r0
   10942:	9102      	str	r1, [sp, #8]
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   10944:	f8d0 a004 	ldr.w	sl, [r0, #4]
    if (argc != 1) {
   10948:	2901      	cmp	r1, #1
   1094a:	d010      	beq.n	1096e <_Command_MacInfo+0x36>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: macinfo \r\n");
   1094c:	4c5a      	ldr	r4, [pc, #360]	; (10ab8 <_Command_MacInfo+0x180>)
   1094e:	6803      	ldr	r3, [r0, #0]
   10950:	681b      	ldr	r3, [r3, #0]
   10952:	4621      	mov	r1, r4
   10954:	4650      	mov	r0, sl
   10956:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: macinfo \r\n");
   10958:	6833      	ldr	r3, [r6, #0]
   1095a:	681b      	ldr	r3, [r3, #0]
   1095c:	f104 0114 	add.w	r1, r4, #20
   10960:	4650      	mov	r0, sl
   10962:	4798      	blx	r3
        return false;
   10964:	2000      	movs	r0, #0
}
   10966:	f60d 0d3c 	addw	sp, sp, #2108	; 0x83c
   1096a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    netNo = TCPIP_STACK_NumberOfNetworksGet();
   1096e:	f011 fb51 	bl	22014 <TCPIP_STACK_NumberOfNetworksGet>
    for(netIx = 0; netIx < netNo; netIx++)
   10972:	f1b0 0b00 	subs.w	fp, r0, #0
   10976:	f340 809c 	ble.w	10ab2 <_Command_MacInfo+0x17a>
   1097a:	2700      	movs	r7, #0
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Interface: %s Driver Statistics\r\n", netName);
   1097c:	f8df 9138 	ldr.w	r9, [pc, #312]	; 10ab8 <_Command_MacInfo+0x180>
   10980:	f109 0324 	add.w	r3, r9, #36	; 0x24
   10984:	9303      	str	r3, [sp, #12]
   10986:	e01d      	b.n	109c4 <_Command_MacInfo+0x8c>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "\tnot supported\r\n");
   10988:	6833      	ldr	r3, [r6, #0]
   1098a:	681b      	ldr	r3, [r3, #0]
   1098c:	f509 71b2 	add.w	r1, r9, #356	; 0x164
   10990:	4650      	mov	r0, sl
   10992:	4798      	blx	r3
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Interface: %s Hardware Register Status\r\n", netName);
   10994:	6833      	ldr	r3, [r6, #0]
   10996:	685b      	ldr	r3, [r3, #4]
   10998:	462a      	mov	r2, r5
   1099a:	f509 71bc 	add.w	r1, r9, #376	; 0x178
   1099e:	4650      	mov	r0, sl
   109a0:	4798      	blx	r3
        if(TCPIP_STACK_NetMACRegisterStatisticsGet(netH, regEntries, sizeof(regEntries)/sizeof(*regEntries), &hwEntries))
   109a2:	ab0f      	add	r3, sp, #60	; 0x3c
   109a4:	2232      	movs	r2, #50	; 0x32
   109a6:	a910      	add	r1, sp, #64	; 0x40
   109a8:	4620      	mov	r0, r4
   109aa:	f00f faff 	bl	1ffac <TCPIP_STACK_NetMACRegisterStatisticsGet>
   109ae:	2800      	cmp	r0, #0
   109b0:	d15d      	bne.n	10a6e <_Command_MacInfo+0x136>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "\tnot supported\r\n");
   109b2:	6833      	ldr	r3, [r6, #0]
   109b4:	681b      	ldr	r3, [r3, #0]
   109b6:	f509 71b2 	add.w	r1, r9, #356	; 0x164
   109ba:	4650      	mov	r0, sl
   109bc:	4798      	blx	r3
    for(netIx = 0; netIx < netNo; netIx++)
   109be:	3701      	adds	r7, #1
   109c0:	45bb      	cmp	fp, r7
   109c2:	d074      	beq.n	10aae <_Command_MacInfo+0x176>
        netH = TCPIP_STACK_IndexToNet(netIx);
   109c4:	4638      	mov	r0, r7
   109c6:	f00f fac9 	bl	1ff5c <TCPIP_STACK_IndexToNet>
   109ca:	4604      	mov	r4, r0
        if(TCPIP_STACK_NetGetType(netH) != TCPIP_NETWORK_TYPE_PRIMARY)
   109cc:	f011 fbd7 	bl	2217e <TCPIP_STACK_NetGetType>
   109d0:	2801      	cmp	r0, #1
   109d2:	d1f4      	bne.n	109be <_Command_MacInfo+0x86>
        netName = TCPIP_STACK_NetNameGet(netH);
   109d4:	4620      	mov	r0, r4
   109d6:	f011 fba6 	bl	22126 <TCPIP_STACK_NetNameGet>
   109da:	4605      	mov	r5, r0
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Interface: %s Driver Statistics\r\n", netName);
   109dc:	6833      	ldr	r3, [r6, #0]
   109de:	685b      	ldr	r3, [r3, #4]
   109e0:	4602      	mov	r2, r0
   109e2:	9903      	ldr	r1, [sp, #12]
   109e4:	4650      	mov	r0, sl
   109e6:	4798      	blx	r3
        if(TCPIP_STACK_NetMACStatisticsGet(netH, &rxStatistics, &txStatistics))
   109e8:	f50d 6201 	add.w	r2, sp, #2064	; 0x810
   109ec:	f50d 6102 	add.w	r1, sp, #2080	; 0x820
   109f0:	4620      	mov	r0, r4
   109f2:	f00f fac7 	bl	1ff84 <TCPIP_STACK_NetMACStatisticsGet>
   109f6:	2800      	cmp	r0, #0
   109f8:	d0c6      	beq.n	10988 <_Command_MacInfo+0x50>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\n Receive Statistics\r\n");
   109fa:	6833      	ldr	r3, [r6, #0]
   109fc:	685b      	ldr	r3, [r3, #4]
   109fe:	f109 0148 	add.w	r1, r9, #72	; 0x48
   10a02:	4650      	mov	r0, sl
   10a04:	4798      	blx	r3
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "\t nRxOkPackets: %d\r\n\t nRxPendBuffers: %d\r\n\t nRxSchedBuffers: %d\r\n",
   10a06:	6833      	ldr	r3, [r6, #0]
   10a08:	f8dd 2828 	ldr.w	r2, [sp, #2088]	; 0x828
   10a0c:	9200      	str	r2, [sp, #0]
   10a0e:	f8d3 8004 	ldr.w	r8, [r3, #4]
   10a12:	f8dd 3824 	ldr.w	r3, [sp, #2084]	; 0x824
   10a16:	f8dd 2820 	ldr.w	r2, [sp, #2080]	; 0x820
   10a1a:	f109 0160 	add.w	r1, r9, #96	; 0x60
   10a1e:	4650      	mov	r0, sl
   10a20:	47c0      	blx	r8
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "\t nRxErrorPackets: %d\r\n\t nRxFragmentErrors: %d\r\n\t nRxBuffNotAvailable: %d\r\n", rxStatistics.nRxErrorPackets, rxStatistics.nRxFragmentErrors,rxStatistics.nRxBuffNotAvailable);
   10a22:	6833      	ldr	r3, [r6, #0]
   10a24:	f8dd 2834 	ldr.w	r2, [sp, #2100]	; 0x834
   10a28:	9200      	str	r2, [sp, #0]
   10a2a:	f8d3 8004 	ldr.w	r8, [r3, #4]
   10a2e:	f8dd 3830 	ldr.w	r3, [sp, #2096]	; 0x830
   10a32:	f8dd 282c 	ldr.w	r2, [sp, #2092]	; 0x82c
   10a36:	f109 01a4 	add.w	r1, r9, #164	; 0xa4
   10a3a:	4650      	mov	r0, sl
   10a3c:	47c0      	blx	r8
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\n Transmit Statistics\r\n");
   10a3e:	6833      	ldr	r3, [r6, #0]
   10a40:	685b      	ldr	r3, [r3, #4]
   10a42:	f109 01f0 	add.w	r1, r9, #240	; 0xf0
   10a46:	4650      	mov	r0, sl
   10a48:	4798      	blx	r3
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "\t nTxOkPackets: %d\r\n\t nTxPendBuffers: %d\r\n\t nTxErrorPackets: %d\r\n\t nTxQueueFull: %d\r\n\r\n",
   10a4a:	6833      	ldr	r3, [r6, #0]
   10a4c:	f8dd 281c 	ldr.w	r2, [sp, #2076]	; 0x81c
   10a50:	9201      	str	r2, [sp, #4]
   10a52:	f8dd 2818 	ldr.w	r2, [sp, #2072]	; 0x818
   10a56:	9200      	str	r2, [sp, #0]
   10a58:	f8d3 8004 	ldr.w	r8, [r3, #4]
   10a5c:	f8dd 3814 	ldr.w	r3, [sp, #2068]	; 0x814
   10a60:	f8dd 2810 	ldr.w	r2, [sp, #2064]	; 0x810
   10a64:	f509 7186 	add.w	r1, r9, #268	; 0x10c
   10a68:	4650      	mov	r0, sl
   10a6a:	47c0      	blx	r8
   10a6c:	e792      	b.n	10994 <_Command_MacInfo+0x5c>
            entryName[sizeof(entryName) - 1] = 0;
   10a6e:	2300      	movs	r3, #0
   10a70:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
            for(jx = 0, pRegEntry = regEntries; jx < hwEntries && jx < sizeof(regEntries)/sizeof(*regEntries); jx++, pRegEntry++)
   10a74:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   10a76:	2b00      	cmp	r3, #0
   10a78:	dda1      	ble.n	109be <_Command_MacInfo+0x86>
   10a7a:	2500      	movs	r5, #0
   10a7c:	ac10      	add	r4, sp, #64	; 0x40
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "\t %s: 0x%x\r\n", entryName, pRegEntry->registerValue);
   10a7e:	46b8      	mov	r8, r7
                strncpy(entryName, pRegEntry->registerName, sizeof(entryName) - 1);
   10a80:	2224      	movs	r2, #36	; 0x24
   10a82:	4621      	mov	r1, r4
   10a84:	a805      	add	r0, sp, #20
   10a86:	f00f fc7e 	bl	20386 <strncpy>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "\t %s: 0x%x\r\n", entryName, pRegEntry->registerValue);
   10a8a:	6833      	ldr	r3, [r6, #0]
   10a8c:	685f      	ldr	r7, [r3, #4]
   10a8e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   10a90:	aa05      	add	r2, sp, #20
   10a92:	490a      	ldr	r1, [pc, #40]	; (10abc <_Command_MacInfo+0x184>)
   10a94:	4650      	mov	r0, sl
   10a96:	47b8      	blx	r7
            for(jx = 0, pRegEntry = regEntries; jx < hwEntries && jx < sizeof(regEntries)/sizeof(*regEntries); jx++, pRegEntry++)
   10a98:	3501      	adds	r5, #1
   10a9a:	3428      	adds	r4, #40	; 0x28
   10a9c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   10a9e:	42ab      	cmp	r3, r5
   10aa0:	dd03      	ble.n	10aaa <_Command_MacInfo+0x172>
   10aa2:	2d32      	cmp	r5, #50	; 0x32
   10aa4:	d1ec      	bne.n	10a80 <_Command_MacInfo+0x148>
   10aa6:	4647      	mov	r7, r8
   10aa8:	e789      	b.n	109be <_Command_MacInfo+0x86>
   10aaa:	4647      	mov	r7, r8
   10aac:	e787      	b.n	109be <_Command_MacInfo+0x86>
    return true;
   10aae:	9802      	ldr	r0, [sp, #8]
   10ab0:	e759      	b.n	10966 <_Command_MacInfo+0x2e>
   10ab2:	9802      	ldr	r0, [sp, #8]
   10ab4:	e757      	b.n	10966 <_Command_MacInfo+0x2e>
   10ab6:	bf00      	nop
   10ab8:	0000028c 	.word	0x0000028c
   10abc:	00000430 	.word	0x00000430

Disassembly of section .text.wc_Sha256Final%244:

00010ac0 <wc_Sha256Final>:

        return 0;
    }

    int wc_Sha256Final(wc_Sha256* sha256, byte* hash)
    {
   10ac0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        int ret;

        if (sha256 == NULL || hash == NULL) {
   10ac2:	2800      	cmp	r0, #0
   10ac4:	f000 80ab 	beq.w	10c1e <wc_Sha256Final+0x15e>
   10ac8:	4604      	mov	r4, r0
   10aca:	2900      	cmp	r1, #0
   10acc:	f000 80aa 	beq.w	10c24 <wc_Sha256Final+0x164>
   10ad0:	460d      	mov	r5, r1
            return BAD_FUNC_ARG;
        }

    #ifdef WOLF_CRYPTO_CB
        if (sha256->devId != INVALID_DEVID) {
   10ad2:	6f03      	ldr	r3, [r0, #112]	; 0x70
   10ad4:	f113 0f02 	cmn.w	r3, #2
   10ad8:	d00a      	beq.n	10af0 <wc_Sha256Final+0x30>
            ret = wc_CryptoCb_Sha256Hash(sha256, NULL, 0, hash);
   10ada:	460b      	mov	r3, r1
   10adc:	2200      	movs	r2, #0
   10ade:	4611      	mov	r1, r2
   10ae0:	f00a f87e 	bl	1abe0 <wc_CryptoCb_Sha256Hash>
   10ae4:	4607      	mov	r7, r0
            if (ret != CRYPTOCB_UNAVAILABLE)
   10ae6:	f46f 7387 	mvn.w	r3, #270	; 0x10e
   10aea:	4298      	cmp	r0, r3
   10aec:	f040 8095 	bne.w	10c1a <wc_Sha256Final+0x15a>
        local = (byte*)sha256->buffer;
   10af0:	f104 0620 	add.w	r6, r4, #32
        local[sha256->buffLen++] = 0x80; /* add 1 */
   10af4:	6e23      	ldr	r3, [r4, #96]	; 0x60
   10af6:	1c5a      	adds	r2, r3, #1
   10af8:	6622      	str	r2, [r4, #96]	; 0x60
   10afa:	2280      	movs	r2, #128	; 0x80
   10afc:	54f2      	strb	r2, [r6, r3]
        if (sha256->buffLen > WC_SHA256_PAD_SIZE) {
   10afe:	6e20      	ldr	r0, [r4, #96]	; 0x60
   10b00:	2838      	cmp	r0, #56	; 0x38
   10b02:	d922      	bls.n	10b4a <wc_Sha256Final+0x8a>
            XMEMSET(&local[sha256->buffLen], 0,
   10b04:	f1c0 0240 	rsb	r2, r0, #64	; 0x40
   10b08:	2100      	movs	r1, #0
   10b0a:	4430      	add	r0, r6
   10b0c:	f011 f8be 	bl	21c8c <memset>
            sha256->buffLen += WC_SHA256_BLOCK_SIZE - sha256->buffLen;
   10b10:	2340      	movs	r3, #64	; 0x40
   10b12:	6623      	str	r3, [r4, #96]	; 0x60
    for (i = 0; i < count; i++)
   10b14:	f104 011c 	add.w	r1, r4, #28
   10b18:	f104 005c 	add.w	r0, r4, #92	; 0x5c
        out[i] = ByteReverseWord32(in[i]);
   10b1c:	f851 2f04 	ldr.w	r2, [r1, #4]!
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
   10b20:	0a13      	lsrs	r3, r2, #8
   10b22:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
   10b26:	0212      	lsls	r2, r2, #8
   10b28:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
   10b2c:	4313      	orrs	r3, r2
        return (x << y) | (x >> (sizeof(y) * 8 - y));
   10b2e:	ea4f 4333 	mov.w	r3, r3, ror #16
        out[i] = ByteReverseWord32(in[i]);
   10b32:	600b      	str	r3, [r1, #0]
    for (i = 0; i < count; i++)
   10b34:	4281      	cmp	r1, r0
   10b36:	d1f1      	bne.n	10b1c <wc_Sha256Final+0x5c>
            ret = XTRANSFORM(sha256, (const byte*)local);
   10b38:	4631      	mov	r1, r6
   10b3a:	4620      	mov	r0, r4
   10b3c:	f7fa fe42 	bl	b7c4 <Transform_Sha256>
            if (ret != 0)
   10b40:	4607      	mov	r7, r0
   10b42:	2800      	cmp	r0, #0
   10b44:	d169      	bne.n	10c1a <wc_Sha256Final+0x15a>
            sha256->buffLen = 0;
   10b46:	2300      	movs	r3, #0
   10b48:	6623      	str	r3, [r4, #96]	; 0x60
        XMEMSET(&local[sha256->buffLen], 0,
   10b4a:	6e20      	ldr	r0, [r4, #96]	; 0x60
   10b4c:	f1c0 0238 	rsb	r2, r0, #56	; 0x38
   10b50:	2100      	movs	r1, #0
   10b52:	4430      	add	r0, r6
   10b54:	f011 f89a 	bl	21c8c <memset>
        sha256->hiLen = (sha256->loLen >> (8 * sizeof(sha256->loLen) - 3)) +
   10b58:	6e63      	ldr	r3, [r4, #100]	; 0x64
                                                         (sha256->hiLen << 3);
   10b5a:	6ea1      	ldr	r1, [r4, #104]	; 0x68
        sha256->hiLen = (sha256->loLen >> (8 * sizeof(sha256->loLen) - 3)) +
   10b5c:	0f5a      	lsrs	r2, r3, #29
   10b5e:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
   10b62:	66a2      	str	r2, [r4, #104]	; 0x68
        sha256->loLen = sha256->loLen << 3;
   10b64:	00db      	lsls	r3, r3, #3
   10b66:	6663      	str	r3, [r4, #100]	; 0x64
   10b68:	f104 011c 	add.w	r1, r4, #28
   10b6c:	f104 005c 	add.w	r0, r4, #92	; 0x5c
        out[i] = ByteReverseWord32(in[i]);
   10b70:	f851 2f04 	ldr.w	r2, [r1, #4]!
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
   10b74:	0a13      	lsrs	r3, r2, #8
   10b76:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
   10b7a:	0212      	lsls	r2, r2, #8
   10b7c:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
   10b80:	4313      	orrs	r3, r2
        return (x << y) | (x >> (sizeof(y) * 8 - y));
   10b82:	ea4f 4333 	mov.w	r3, r3, ror #16
        out[i] = ByteReverseWord32(in[i]);
   10b86:	600b      	str	r3, [r1, #0]
    for (i = 0; i < count; i++)
   10b88:	4281      	cmp	r1, r0
   10b8a:	d1f1      	bne.n	10b70 <wc_Sha256Final+0xb0>
        XMEMCPY(&local[WC_SHA256_PAD_SIZE], &sha256->hiLen, sizeof(word32));
   10b8c:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   10b8e:	65a3      	str	r3, [r4, #88]	; 0x58
        XMEMCPY(&local[WC_SHA256_PAD_SIZE + sizeof(word32)], &sha256->loLen,
   10b90:	6e63      	ldr	r3, [r4, #100]	; 0x64
   10b92:	65e3      	str	r3, [r4, #92]	; 0x5c
        ret = XTRANSFORM(sha256, (const byte*)local);
   10b94:	4631      	mov	r1, r6
   10b96:	4620      	mov	r0, r4
   10b98:	f7fa fe14 	bl	b7c4 <Transform_Sha256>
        #endif
        }
    #endif /* WOLFSSL_ASYNC_CRYPT */

        ret = Sha256Final(sha256);
        if (ret != 0)
   10b9c:	4607      	mov	r7, r0
   10b9e:	2800      	cmp	r0, #0
   10ba0:	d13b      	bne.n	10c1a <wc_Sha256Final+0x15a>
            return ret;

    #if defined(LITTLE_ENDIAN_ORDER)
        ByteReverseWords(sha256->digest, sha256->digest, WC_SHA256_DIGEST_SIZE);
   10ba2:	4626      	mov	r6, r4
   10ba4:	1f21      	subs	r1, r4, #4
   10ba6:	f104 001c 	add.w	r0, r4, #28
        out[i] = ByteReverseWord32(in[i]);
   10baa:	f851 2f04 	ldr.w	r2, [r1, #4]!
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
   10bae:	0a13      	lsrs	r3, r2, #8
   10bb0:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
   10bb4:	0212      	lsls	r2, r2, #8
   10bb6:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
   10bba:	4313      	orrs	r3, r2
        return (x << y) | (x >> (sizeof(y) * 8 - y));
   10bbc:	ea4f 4333 	mov.w	r3, r3, ror #16
        out[i] = ByteReverseWord32(in[i]);
   10bc0:	600b      	str	r3, [r1, #0]
    for (i = 0; i < count; i++)
   10bc2:	4288      	cmp	r0, r1
   10bc4:	d1f1      	bne.n	10baa <wc_Sha256Final+0xea>
    #endif
        XMEMCPY(hash, sha256->digest, WC_SHA256_DIGEST_SIZE);
   10bc6:	6830      	ldr	r0, [r6, #0]
   10bc8:	6871      	ldr	r1, [r6, #4]
   10bca:	68b2      	ldr	r2, [r6, #8]
   10bcc:	68f3      	ldr	r3, [r6, #12]
   10bce:	6028      	str	r0, [r5, #0]
   10bd0:	6069      	str	r1, [r5, #4]
   10bd2:	60aa      	str	r2, [r5, #8]
   10bd4:	60eb      	str	r3, [r5, #12]
   10bd6:	6930      	ldr	r0, [r6, #16]
   10bd8:	6971      	ldr	r1, [r6, #20]
   10bda:	69b2      	ldr	r2, [r6, #24]
   10bdc:	69f3      	ldr	r3, [r6, #28]
   10bde:	6128      	str	r0, [r5, #16]
   10be0:	6169      	str	r1, [r5, #20]
   10be2:	61aa      	str	r2, [r5, #24]
   10be4:	61eb      	str	r3, [r5, #28]
    sha256->digest[0] = 0x6A09E667L;
   10be6:	4b11      	ldr	r3, [pc, #68]	; (10c2c <wc_Sha256Final+0x16c>)
   10be8:	6023      	str	r3, [r4, #0]
    sha256->digest[1] = 0xBB67AE85L;
   10bea:	4b11      	ldr	r3, [pc, #68]	; (10c30 <wc_Sha256Final+0x170>)
   10bec:	6063      	str	r3, [r4, #4]
    sha256->digest[2] = 0x3C6EF372L;
   10bee:	4b11      	ldr	r3, [pc, #68]	; (10c34 <wc_Sha256Final+0x174>)
   10bf0:	60a3      	str	r3, [r4, #8]
    sha256->digest[3] = 0xA54FF53AL;
   10bf2:	4b11      	ldr	r3, [pc, #68]	; (10c38 <wc_Sha256Final+0x178>)
   10bf4:	60e3      	str	r3, [r4, #12]
    sha256->digest[4] = 0x510E527FL;
   10bf6:	4b11      	ldr	r3, [pc, #68]	; (10c3c <wc_Sha256Final+0x17c>)
   10bf8:	6123      	str	r3, [r4, #16]
    sha256->digest[5] = 0x9B05688CL;
   10bfa:	4b11      	ldr	r3, [pc, #68]	; (10c40 <wc_Sha256Final+0x180>)
   10bfc:	6163      	str	r3, [r4, #20]
    sha256->digest[6] = 0x1F83D9ABL;
   10bfe:	4b11      	ldr	r3, [pc, #68]	; (10c44 <wc_Sha256Final+0x184>)
   10c00:	61a3      	str	r3, [r4, #24]
    sha256->digest[7] = 0x5BE0CD19L;
   10c02:	f103 5374 	add.w	r3, r3, #1023410176	; 0x3d000000
   10c06:	f5a3 0323 	sub.w	r3, r3, #10682368	; 0xa30000
   10c0a:	f6a3 4392 	subw	r3, r3, #3218	; 0xc92
   10c0e:	61e3      	str	r3, [r4, #28]
    sha256->buffLen = 0;
   10c10:	2300      	movs	r3, #0
   10c12:	6623      	str	r3, [r4, #96]	; 0x60
    sha256->loLen   = 0;
   10c14:	6663      	str	r3, [r4, #100]	; 0x64
    sha256->hiLen   = 0;
   10c16:	66a3      	str	r3, [r4, #104]	; 0x68
    sha256->flags = 0;
   10c18:	67a3      	str	r3, [r4, #120]	; 0x78

        return InitSha256(sha256);  /* reset state */
    }
   10c1a:	4638      	mov	r0, r7
   10c1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return BAD_FUNC_ARG;
   10c1e:	f06f 07ac 	mvn.w	r7, #172	; 0xac
   10c22:	e7fa      	b.n	10c1a <wc_Sha256Final+0x15a>
   10c24:	f06f 07ac 	mvn.w	r7, #172	; 0xac
   10c28:	e7f7      	b.n	10c1a <wc_Sha256Final+0x15a>
   10c2a:	bf00      	nop
   10c2c:	6a09e667 	.word	0x6a09e667
   10c30:	bb67ae85 	.word	0xbb67ae85
   10c34:	3c6ef372 	.word	0x3c6ef372
   10c38:	a54ff53a 	.word	0xa54ff53a
   10c3c:	510e527f 	.word	0x510e527f
   10c40:	9b05688c 	.word	0x9b05688c
   10c44:	1f83d9ab 	.word	0x1f83d9ab

Disassembly of section .text._InitRng%245:

00010c48 <_InitRng>:
/* End NIST DRBG Code */


static int _InitRng(WC_RNG* rng, byte* nonce, word32 nonceSz,
                    void* heap, int devId)
{
   10c48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10c4c:	b0a9      	sub	sp, #164	; 0xa4
   10c4e:	f8dd b0c8 	ldr.w	fp, [sp, #200]	; 0xc8
#endif

    (void)nonce;
    (void)nonceSz;

    if (rng == NULL)
   10c52:	2800      	cmp	r0, #0
   10c54:	f000 80af 	beq.w	10db6 <_InitRng+0x16e>
   10c58:	4604      	mov	r4, r0
        return BAD_FUNC_ARG;
    if (nonce == NULL && nonceSz != 0)
   10c5a:	2900      	cmp	r1, #0
   10c5c:	d064      	beq.n	10d28 <_InitRng+0xe0>

#ifdef WOLFSSL_HEAP_TEST
    rng->heap = (void*)WOLFSSL_HEAP_TEST;
    (void)heap;
#else
    rng->heap = heap;
   10c5e:	6083      	str	r3, [r0, #8]
#endif
#if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
    rng->devId = devId;
   10c60:	f8c0 b014 	str.w	fp, [r0, #20]
    #if defined(WOLF_CRYPTO_CB)
        rng->seed.devId = devId;
   10c64:	f8c0 b004 	str.w	fp, [r0, #4]
    (void)devId;
#endif

#ifdef HAVE_HASHDRBG
    /* init the DBRG to known values */
    rng->drbg = NULL;
   10c68:	2300      	movs	r3, #0
   10c6a:	60c3      	str	r3, [r0, #12]
    rng->status = DRBG_NOT_INIT;
   10c6c:	7403      	strb	r3, [r0, #16]
#ifdef CUSTOM_RAND_GENERATE_BLOCK
    ret = 0; /* success */
#else
#ifdef HAVE_HASHDRBG
    if (nonceSz == 0)
        seedSz = MAX_SEED_SZ;
   10c6e:	429a      	cmp	r2, r3
   10c70:	bf14      	ite	ne
   10c72:	2724      	movne	r7, #36	; 0x24
   10c74:	2734      	moveq	r7, #52	; 0x34
   10c76:	4691      	mov	r9, r2
   10c78:	4688      	mov	r8, r1
            XMEMCPY_P(outputB, outputB_data, sizeof(outputB_data));
#else
        const byte* seedB = seedB_data;
        const byte* outputB = outputB_data;
#endif
        ret = wc_RNG_HealthTest(0, seedB, sizeof(seedB_data),
   10c7a:	2380      	movs	r3, #128	; 0x80
   10c7c:	9302      	str	r3, [sp, #8]
   10c7e:	ab08      	add	r3, sp, #32
   10c80:	9301      	str	r3, [sp, #4]
   10c82:	2000      	movs	r0, #0
   10c84:	9000      	str	r0, [sp, #0]
   10c86:	4603      	mov	r3, r0
   10c88:	2230      	movs	r2, #48	; 0x30
   10c8a:	494e      	ldr	r1, [pc, #312]	; (10dc4 <_InitRng+0x17c>)
   10c8c:	f00e ff24 	bl	1fad8 <wc_RNG_HealthTest>
                                NULL, 0,
                                check, RNG_HEALTH_TEST_CHECK_SIZE);
        if (ret == 0) {
   10c90:	4601      	mov	r1, r0
   10c92:	2800      	cmp	r0, #0
   10c94:	f040 808a 	bne.w	10dac <_InitRng+0x164>
   10c98:	f10d 051f 	add.w	r5, sp, #31
   10c9c:	f8df a128 	ldr.w	sl, [pc, #296]	; 10dc8 <_InitRng+0x180>
   10ca0:	f10d 069f 	add.w	r6, sp, #159	; 0x9f
   10ca4:	4650      	mov	r0, sl
   10ca6:	462a      	mov	r2, r5
{
    int i;
    int compareSum = 0;

    for (i = 0; i < length; i++) {
        compareSum |= a[i] ^ b[i];
   10ca8:	f812 3f01 	ldrb.w	r3, [r2, #1]!
   10cac:	f810 cf01 	ldrb.w	ip, [r0, #1]!
   10cb0:	ea83 030c 	eor.w	r3, r3, ip
   10cb4:	4319      	orrs	r1, r3
    for (i = 0; i < length; i++) {
   10cb6:	42b2      	cmp	r2, r6
   10cb8:	d1f6      	bne.n	10ca8 <_InitRng+0x60>
            if (ConstantCompare(check, outputB,
   10cba:	2900      	cmp	r1, #0
   10cbc:	d176      	bne.n	10dac <_InitRng+0x164>
        /* The previous test cases use a large seed instead of a seed and nonce.
         * seedB is actually from a test case with a seed and nonce, and
         * just concatenates them. The pivot point between seed and nonce is
         * byte 32, feed them into the health test separately. */
        if (ret == 0) {
            ret = wc_RNG_HealthTest_ex(0,
   10cbe:	4941      	ldr	r1, [pc, #260]	; (10dc4 <_InitRng+0x17c>)
   10cc0:	f06f 0301 	mvn.w	r3, #1
   10cc4:	9306      	str	r3, [sp, #24]
   10cc6:	2000      	movs	r0, #0
   10cc8:	9005      	str	r0, [sp, #20]
   10cca:	2380      	movs	r3, #128	; 0x80
   10ccc:	9304      	str	r3, [sp, #16]
   10cce:	ab08      	add	r3, sp, #32
   10cd0:	9303      	str	r3, [sp, #12]
   10cd2:	9002      	str	r0, [sp, #8]
   10cd4:	9001      	str	r0, [sp, #4]
   10cd6:	2320      	movs	r3, #32
   10cd8:	9300      	str	r3, [sp, #0]
   10cda:	460b      	mov	r3, r1
   10cdc:	2210      	movs	r2, #16
   10cde:	3120      	adds	r1, #32
   10ce0:	f006 fe46 	bl	17970 <wc_RNG_HealthTest_ex>
                                    seedB + 32, sizeof(seedB_data) - 32,
                                    seedB, 32,
                                    NULL, 0,
                                    check, RNG_HEALTH_TEST_CHECK_SIZE,
                                    NULL, INVALID_DEVID);
            if (ret == 0) {
   10ce4:	4602      	mov	r2, r0
   10ce6:	2800      	cmp	r0, #0
   10ce8:	d160      	bne.n	10dac <_InitRng+0x164>
        compareSum |= a[i] ^ b[i];
   10cea:	f815 3f01 	ldrb.w	r3, [r5, #1]!
   10cee:	f81a 1f01 	ldrb.w	r1, [sl, #1]!
   10cf2:	404b      	eors	r3, r1
   10cf4:	431a      	orrs	r2, r3
    for (i = 0; i < length; i++) {
   10cf6:	42b5      	cmp	r5, r6
   10cf8:	d1f7      	bne.n	10cea <_InitRng+0xa2>
                if (ConstantCompare(check, outputB, sizeof(outputB_data)) != 0)
   10cfa:	2a00      	cmp	r2, #0
   10cfc:	d156      	bne.n	10dac <_InitRng+0x164>
                (struct DRBG*)XMALLOC(sizeof(DRBG_internal), rng->heap,
   10cfe:	2084      	movs	r0, #132	; 0x84
   10d00:	f010 ffb4 	bl	21c6c <malloc>
        rng->drbg =
   10d04:	60e0      	str	r0, [r4, #12]
        if (rng->drbg == NULL) {
   10d06:	b1d8      	cbz	r0, 10d40 <_InitRng+0xf8>
            ret = wc_GenerateSeed(&rng->seed, seed, seedSz);
   10d08:	463a      	mov	r2, r7
   10d0a:	a908      	add	r1, sp, #32
   10d0c:	4620      	mov	r0, r4
   10d0e:	f009 fa6d 	bl	1a1ec <wc_GenerateSeed>
            if (ret == 0)
   10d12:	b338      	cbz	r0, 10d64 <_InitRng+0x11c>
                rng->status = DRBG_FAILED;
   10d14:	2302      	movs	r3, #2
   10d16:	7423      	strb	r3, [r4, #16]
                ret = DRBG_FAILURE;
   10d18:	2501      	movs	r5, #1
                XFREE(rng->drbg, rng->heap, DYNAMIC_TYPE_RNG);
   10d1a:	68e0      	ldr	r0, [r4, #12]
   10d1c:	b108      	cbz	r0, 10d22 <_InitRng+0xda>
   10d1e:	f010 ffad 	bl	21c7c <free>
                rng->drbg = NULL;
   10d22:	2300      	movs	r3, #0
   10d24:	60e3      	str	r3, [r4, #12]
   10d26:	e00f      	b.n	10d48 <_InitRng+0x100>
    if (nonce == NULL && nonceSz != 0)
   10d28:	2a00      	cmp	r2, #0
   10d2a:	d147      	bne.n	10dbc <_InitRng+0x174>
    rng->heap = heap;
   10d2c:	6083      	str	r3, [r0, #8]
    rng->devId = devId;
   10d2e:	f8c0 b014 	str.w	fp, [r0, #20]
        rng->seed.devId = devId;
   10d32:	f8c0 b004 	str.w	fp, [r0, #4]
    rng->drbg = NULL;
   10d36:	2300      	movs	r3, #0
   10d38:	60c3      	str	r3, [r0, #12]
    rng->status = DRBG_NOT_INIT;
   10d3a:	7403      	strb	r3, [r0, #16]
        seedSz = MAX_SEED_SZ;
   10d3c:	2734      	movs	r7, #52	; 0x34
   10d3e:	e79a      	b.n	10c76 <_InitRng+0x2e>
            rng->status = DRBG_FAILED;
   10d40:	2302      	movs	r3, #2
   10d42:	7423      	strb	r3, [r4, #16]
            ret = MEMORY_E;
   10d44:	f06f 057c 	mvn.w	r5, #124	; 0x7c
    while (len--) *z++ = 0;
   10d48:	ab08      	add	r3, sp, #32
   10d4a:	441f      	add	r7, r3
    volatile byte* z = (volatile byte*)mem;
   10d4c:	461a      	mov	r2, r3
    while (len--) *z++ = 0;
   10d4e:	2100      	movs	r1, #0
   10d50:	4613      	mov	r3, r2
   10d52:	f803 1b01 	strb.w	r1, [r3], #1
   10d56:	461a      	mov	r2, r3
   10d58:	42bb      	cmp	r3, r7
   10d5a:	d1f9      	bne.n	10d50 <_InitRng+0x108>
    if (ret == DRBG_SUCCESS) {
   10d5c:	b9cd      	cbnz	r5, 10d92 <_InitRng+0x14a>
        rng->status = DRBG_OK;
   10d5e:	2301      	movs	r3, #1
   10d60:	7423      	strb	r3, [r4, #16]
        ret = 0;
   10d62:	e01f      	b.n	10da4 <_InitRng+0x15c>
                ret = wc_RNG_TestSeed(seed, seedSz);
   10d64:	4639      	mov	r1, r7
   10d66:	a808      	add	r0, sp, #32
   10d68:	f00a f8dc 	bl	1af24 <wc_RNG_TestSeed>
            if (ret == DRBG_SUCCESS)
   10d6c:	4605      	mov	r5, r0
   10d6e:	2800      	cmp	r0, #0
   10d70:	d1d3      	bne.n	10d1a <_InitRng+0xd2>
	      ret = Hash_DRBG_Instantiate((DRBG_internal *)rng->drbg,
   10d72:	f8cd b008 	str.w	fp, [sp, #8]
   10d76:	68a3      	ldr	r3, [r4, #8]
   10d78:	9301      	str	r3, [sp, #4]
   10d7a:	f8cd 9000 	str.w	r9, [sp]
   10d7e:	4643      	mov	r3, r8
   10d80:	1f3a      	subs	r2, r7, #4
   10d82:	a909      	add	r1, sp, #36	; 0x24
   10d84:	68e0      	ldr	r0, [r4, #12]
   10d86:	f009 fb50 	bl	1a42a <Hash_DRBG_Instantiate>
            if (ret != DRBG_SUCCESS) {
   10d8a:	4605      	mov	r5, r0
   10d8c:	2800      	cmp	r0, #0
   10d8e:	d0db      	beq.n	10d48 <_InitRng+0x100>
   10d90:	e7c3      	b.n	10d1a <_InitRng+0xd2>
    else if (ret == DRBG_CONT_FAILURE) {
   10d92:	2d03      	cmp	r5, #3
   10d94:	d00a      	beq.n	10dac <_InitRng+0x164>
    else if (ret == DRBG_FAILURE) {
   10d96:	2d01      	cmp	r5, #1
        rng->status = DRBG_FAILED;
   10d98:	f04f 0302 	mov.w	r3, #2
   10d9c:	7423      	strb	r3, [r4, #16]
        ret = RNG_FAILURE_E;
   10d9e:	bf08      	it	eq
   10da0:	f06f 05c6 	mvneq.w	r5, #198	; 0xc6
}
   10da4:	4628      	mov	r0, r5
   10da6:	b029      	add	sp, #164	; 0xa4
   10da8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        rng->status = DRBG_CONT_FAILED;
   10dac:	2303      	movs	r3, #3
   10dae:	7423      	strb	r3, [r4, #16]
        ret = DRBG_CONT_FIPS_E;
   10db0:	f06f 05d0 	mvn.w	r5, #208	; 0xd0
   10db4:	e7f6      	b.n	10da4 <_InitRng+0x15c>
        return BAD_FUNC_ARG;
   10db6:	f06f 05ac 	mvn.w	r5, #172	; 0xac
   10dba:	e7f3      	b.n	10da4 <_InitRng+0x15c>
        return BAD_FUNC_ARG;
   10dbc:	f06f 05ac 	mvn.w	r5, #172	; 0xac
   10dc0:	e7f0      	b.n	10da4 <_InitRng+0x15c>
   10dc2:	bf00      	nop
   10dc4:	0001f4d8 	.word	0x0001f4d8
   10dc8:	0001969f 	.word	0x0001969f

Disassembly of section .text._TcpCloseSocket%246:

00010dcc <_TcpCloseSocket>:
{
   10dcc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   10dd0:	4604      	mov	r4, r0
   10dd2:	460d      	mov	r5, r1
    if(pSkt->Flags.bServer !=  0 && pSkt->flags.forceKill == 0)
   10dd4:	f890 3036 	ldrb.w	r3, [r0, #54]	; 0x36
   10dd8:	f013 0f01 	tst.w	r3, #1
   10ddc:	d024      	beq.n	10e28 <_TcpCloseSocket+0x5c>
   10dde:	f890 306d 	ldrb.w	r3, [r0, #109]	; 0x6d
   10de2:	f013 0f04 	tst.w	r3, #4
   10de6:	d13b      	bne.n	10e60 <_TcpCloseSocket+0x94>
        freePkt = (pSkt->flags.openAddType == IP_ADDRESS_TYPE_ANY) ? true : false;
   10de8:	f890 306c 	ldrb.w	r3, [r0, #108]	; 0x6c
   10dec:	f013 0f03 	tst.w	r3, #3
   10df0:	bf0c      	ite	eq
   10df2:	2201      	moveq	r2, #1
   10df4:	2200      	movne	r2, #0
        sktIsKilled = false;
   10df6:	f04f 0a00 	mov.w	sl, #0
        freePkt = (pSkt->flags.openAddType == IP_ADDRESS_TYPE_ANY) ? true : false;
   10dfa:	e017      	b.n	10e2c <_TcpCloseSocket+0x60>
            if(freePkt)
   10dfc:	b1e2      	cbz	r2, 10e38 <_TcpCloseSocket+0x6c>
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   10dfe:	2000      	movs	r0, #0
   10e00:	f010 fbdc 	bl	215bc <OSAL_CRIT_Enter>
   10e04:	4601      	mov	r1, r0
    if(pSkt->pV4Pkt != 0)
   10e06:	6c66      	ldr	r6, [r4, #68]	; 0x44
   10e08:	2e00      	cmp	r6, #0
   10e0a:	f000 808f 	beq.w	10f2c <_TcpCloseSocket+0x160>
        if((pSkt->pV4Pkt->macPkt.pktFlags & TCPIP_MAC_PKT_FLAG_QUEUED) == 0)
   10e0e:	8c73      	ldrh	r3, [r6, #34]	; 0x22
   10e10:	f013 0f08 	tst.w	r3, #8
   10e14:	f040 808e 	bne.w	10f34 <_TcpCloseSocket+0x168>
        pSkt->pTxPkt = 0;
   10e18:	2000      	movs	r0, #0
   10e1a:	6460      	str	r0, [r4, #68]	; 0x44
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   10e1c:	f010 fcfd 	bl	2181a <OSAL_CRIT_Leave>
                    TCPIP_PKT_PacketFree(pFreePkt);
   10e20:	4630      	mov	r0, r6
   10e22:	f00d f9f1 	bl	1e208 <_TCPIP_PKT_PacketFree>
   10e26:	e007      	b.n	10e38 <_TcpCloseSocket+0x6c>
        freePkt = true;
   10e28:	2201      	movs	r2, #1
        sktIsKilled = true;
   10e2a:	4692      	mov	sl, r2
    while(pSkt->pTxPkt != NULL)
   10e2c:	6c63      	ldr	r3, [r4, #68]	; 0x44
   10e2e:	b11b      	cbz	r3, 10e38 <_TcpCloseSocket+0x6c>
        if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   10e30:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
   10e34:	2b01      	cmp	r3, #1
   10e36:	d0e1      	beq.n	10dfc <_TcpCloseSocket+0x30>
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   10e38:	2000      	movs	r0, #0
   10e3a:	f010 fbbf 	bl	215bc <OSAL_CRIT_Enter>
    *pSigHandler = pSkt->sigHandler;
   10e3e:	6f67      	ldr	r7, [r4, #116]	; 0x74
    *pSigParam = pSkt->sigParam;
   10e40:	f8d4 9078 	ldr.w	r9, [r4, #120]	; 0x78
    uint16_t sigMask = pSkt->sigMask;
   10e44:	f8b4 6072 	ldrh.w	r6, [r4, #114]	; 0x72
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   10e48:	4601      	mov	r1, r0
   10e4a:	2000      	movs	r0, #0
   10e4c:	f010 fce5 	bl	2181a <OSAL_CRIT_Leave>
    if((tcpEvent &= sigMask))
   10e50:	4035      	ands	r5, r6
   10e52:	d008      	beq.n	10e66 <_TcpCloseSocket+0x9a>
        if(sigHandler != 0)
   10e54:	b1bf      	cbz	r7, 10e86 <_TcpCloseSocket+0xba>
            sktIx = pSkt->sktIx;
   10e56:	f9b4 6034 	ldrsh.w	r6, [r4, #52]	; 0x34
            pSktNet = pSkt->pSktNet;
   10e5a:	f8d4 8040 	ldr.w	r8, [r4, #64]	; 0x40
   10e5e:	e004      	b.n	10e6a <_TcpCloseSocket+0x9e>
        freePkt = true;
   10e60:	2201      	movs	r2, #1
        sktIsKilled = true;
   10e62:	4692      	mov	sl, r2
   10e64:	e7e2      	b.n	10e2c <_TcpCloseSocket+0x60>
    TCP_SOCKET   sktIx = 0; 
   10e66:	2600      	movs	r6, #0
    TCPIP_NET_HANDLE pSktNet = 0;
   10e68:	46b0      	mov	r8, r6
    if(sktIsKilled)
   10e6a:	f1ba 0f00 	cmp.w	sl, #0
   10e6e:	d00e      	beq.n	10e8e <_TcpCloseSocket+0xc2>
        _TcpSocketKill(pSkt);
   10e70:	4620      	mov	r0, r4
   10e72:	f00b fd9d 	bl	1c9b0 <_TcpSocketKill>
    if(tcpEvent)
   10e76:	b125      	cbz	r5, 10e82 <_TcpCloseSocket+0xb6>
        (*sigHandler)(sktIx, pSktNet, tcpEvent, sigParam);
   10e78:	464b      	mov	r3, r9
   10e7a:	462a      	mov	r2, r5
   10e7c:	4641      	mov	r1, r8
   10e7e:	4630      	mov	r0, r6
   10e80:	47b8      	blx	r7
}
   10e82:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    TCP_SOCKET   sktIx = 0; 
   10e86:	2600      	movs	r6, #0
    TCPIP_NET_HANDLE pSktNet = 0;
   10e88:	46b0      	mov	r8, r6
            tcpEvent = 0;
   10e8a:	4635      	mov	r5, r6
   10e8c:	e7ed      	b.n	10e6a <_TcpCloseSocket+0x9e>
	pSkt->remoteHash = pSkt->localPort;
   10e8e:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
   10e92:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
	pSkt->txHead = pSkt->txStart;
   10e96:	6823      	ldr	r3, [r4, #0]
   10e98:	60a3      	str	r3, [r4, #8]
	pSkt->txTail = pSkt->txStart;
   10e9a:	60e3      	str	r3, [r4, #12]
	pSkt->txUnackedTail = pSkt->txStart;
   10e9c:	6123      	str	r3, [r4, #16]
	pSkt->rxHead = pSkt->rxStart;
   10e9e:	6963      	ldr	r3, [r4, #20]
   10ea0:	61e3      	str	r3, [r4, #28]
	pSkt->rxTail = pSkt->rxStart;
   10ea2:	6223      	str	r3, [r4, #32]
	pSkt->Flags.bTimerEnabled = 0;
   10ea4:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
	pSkt->Flags.bTXASAPWithoutTimerReset = 0;
   10ea8:	f003 0381 	and.w	r3, r3, #129	; 0x81
   10eac:	f36f 13c7 	bfc	r3, #7, #1
   10eb0:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
	pSkt->Flags.bTXFIN = 0;
   10eb4:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
	pSkt->Flags.bSocketReset = 1;
   10eb8:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	pSkt->Flags.bRxFin = 0;
   10ebc:	f043 0302 	orr.w	r3, r3, #2
   10ec0:	f36f 0382 	bfc	r3, #2, #1
   10ec4:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37
	pSkt->flags.bFINSent = 0;
   10ec8:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
    pSkt->flags.seqInc = 0;
   10ecc:	f894 206d 	ldrb.w	r2, [r4, #109]	; 0x6d
   10ed0:	f36f 0241 	bfc	r2, #1, #1
   10ed4:	f884 206d 	strb.w	r2, [r4, #109]	; 0x6d
	pSkt->flags.bRXNoneACKed2 = 0;
   10ed8:	f003 03e3 	and.w	r3, r3, #227	; 0xe3
   10edc:	f36f 1345 	bfc	r3, #5, #1
   10ee0:	f884 306c 	strb.w	r3, [r4, #108]	; 0x6c
    pSkt->MySEQ = 0;
   10ee4:	2100      	movs	r1, #0
   10ee6:	64e1      	str	r1, [r4, #76]	; 0x4c
	pSkt->sHoleSize = -1;
   10ee8:	f04f 30ff 	mov.w	r0, #4294967295
   10eec:	6560      	str	r0, [r4, #84]	; 0x54
	pSkt->remoteWindow = 1;
   10eee:	2001      	movs	r0, #1
   10ef0:	f8a4 005c 	strh.w	r0, [r4, #92]	; 0x5c
    pSkt->maxRemoteWindow = 1;
   10ef4:	f8a4 0066 	strh.w	r0, [r4, #102]	; 0x66
    pSkt->remotePort = 0;
   10ef8:	f8a4 1058 	strh.w	r1, [r4, #88]	; 0x58
    pSkt->destAddress.Val = 0;
   10efc:	63a1      	str	r1, [r4, #56]	; 0x38
	pSkt->keepAliveCount = 0;
   10efe:	f884 1071 	strb.w	r1, [r4, #113]	; 0x71
    pSkt->addType = (IP_ADDRESS_TYPE)pSkt->flags.openAddType;
   10f02:	f003 0303 	and.w	r3, r3, #3
   10f06:	f884 306f 	strb.w	r3, [r4, #111]	; 0x6f
    if(pSkt->flags.openBindIf == 0)
   10f0a:	b2d2      	uxtb	r2, r2
   10f0c:	f012 0f20 	tst.w	r2, #32
        pSkt->pSktNet = 0;
   10f10:	bf04      	itt	eq
   10f12:	460b      	moveq	r3, r1
   10f14:	6421      	streq	r1, [r4, #64]	; 0x40
    if(pSkt->flags.openBindAdd == 0)
   10f16:	f012 0f40 	tst.w	r2, #64	; 0x40
        pSkt->srcAddress.Val = 0;
   10f1a:	bf04      	itt	eq
   10f1c:	2300      	moveq	r3, #0
   10f1e:	63e3      	streq	r3, [r4, #60]	; 0x3c
    pSkt->dbgFlags.val = 0;
   10f20:	2300      	movs	r3, #0
   10f22:	f884 307d 	strb.w	r3, [r4, #125]	; 0x7d
    pSkt->smState = newState;
   10f26:	f884 306e 	strb.w	r3, [r4, #110]	; 0x6e
   10f2a:	e7a4      	b.n	10e76 <_TcpCloseSocket+0xaa>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   10f2c:	2000      	movs	r0, #0
   10f2e:	f010 fc74 	bl	2181a <OSAL_CRIT_Leave>
                if(pFreePkt)
   10f32:	e781      	b.n	10e38 <_TcpCloseSocket+0x6c>
        pSkt->pTxPkt = 0;
   10f34:	2000      	movs	r0, #0
   10f36:	6460      	str	r0, [r4, #68]	; 0x44
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   10f38:	f010 fc6f 	bl	2181a <OSAL_CRIT_Leave>
                if(pFreePkt)
   10f3c:	e77c      	b.n	10e38 <_TcpCloseSocket+0x6c>

Disassembly of section .text.TCPIP_TCP_ArrayPut%247:

00010f40 <TCPIP_TCP_ArrayPut>:
{
   10f40:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    if(len == 0 || data == 0 || (pSkt = _TcpSocketChk(hTCP)) == 0)
   10f44:	2a00      	cmp	r2, #0
   10f46:	f000 809e 	beq.w	11086 <TCPIP_TCP_ArrayPut+0x146>
   10f4a:	460f      	mov	r7, r1
   10f4c:	4615      	mov	r5, r2
   10f4e:	2900      	cmp	r1, #0
   10f50:	f000 809d 	beq.w	1108e <TCPIP_TCP_ArrayPut+0x14e>
   10f54:	f00e ff62 	bl	1fe1c <_TcpSocketChk>
   10f58:	4604      	mov	r4, r0
   10f5a:	2800      	cmp	r0, #0
   10f5c:	f000 8099 	beq.w	11092 <TCPIP_TCP_ArrayPut+0x152>
    if(pSkt->pTxPkt == 0)
   10f60:	6c43      	ldr	r3, [r0, #68]	; 0x44
   10f62:	2b00      	cmp	r3, #0
   10f64:	f000 8097 	beq.w	11096 <TCPIP_TCP_ArrayPut+0x156>
    return _TCPSocketTxFreeSize(pSkt);
   10f68:	f00e f8d6 	bl	1f118 <_TCPSocketTxFreeSize>
	if(wFreeTxSpace == 0)
   10f6c:	4606      	mov	r6, r0
   10f6e:	2800      	cmp	r0, #0
   10f70:	f000 8093 	beq.w	1109a <TCPIP_TCP_ArrayPut+0x15a>
    wActualLen = len >= wFreeTxSpace ? wFreeTxSpace : len;
   10f74:	4285      	cmp	r5, r0
   10f76:	bf28      	it	cs
   10f78:	4605      	movcs	r5, r0
   10f7a:	b2ad      	uxth	r5, r5
	if(pSkt->txHead + wActualLen >= pSkt->txEnd)
   10f7c:	68a0      	ldr	r0, [r4, #8]
   10f7e:	6863      	ldr	r3, [r4, #4]
   10f80:	1942      	adds	r2, r0, r5
   10f82:	4293      	cmp	r3, r2
   10f84:	d930      	bls.n	10fe8 <TCPIP_TCP_ArrayPut+0xa8>
    wActualLen = len >= wFreeTxSpace ? wFreeTxSpace : len;
   10f86:	46a8      	mov	r8, r5
	uint16_t wRightLen = 0;
   10f88:	f04f 0900 	mov.w	r9, #0
    memcpy((uint8_t*)pSkt->txHead, data, wActualLen);
   10f8c:	4642      	mov	r2, r8
   10f8e:	4639      	mov	r1, r7
   10f90:	68a0      	ldr	r0, [r4, #8]
   10f92:	f010 f8f5 	bl	21180 <memcpy>
	pSkt->txHead += wActualLen;
   10f96:	68a3      	ldr	r3, [r4, #8]
   10f98:	4443      	add	r3, r8
   10f9a:	60a3      	str	r3, [r4, #8]
    if(pSkt->txHead != pSkt->txUnackedTail)
   10f9c:	6922      	ldr	r2, [r4, #16]
   10f9e:	4293      	cmp	r3, r2
   10fa0:	d019      	beq.n	10fd6 <TCPIP_TCP_ArrayPut+0x96>
        if(pSkt->flags.halfThresFlush != 0)
   10fa2:	f894 706d 	ldrb.w	r7, [r4, #109]	; 0x6d
   10fa6:	f017 0f80 	tst.w	r7, #128	; 0x80
   10faa:	d12d      	bne.n	11008 <TCPIP_TCP_ArrayPut+0xc8>
        if(pSkt->txHead > pSkt->txUnackedTail)
   10fac:	4293      	cmp	r3, r2
   10fae:	d942      	bls.n	11036 <TCPIP_TCP_ArrayPut+0xf6>
            toSendData = pSkt->txHead - pSkt->txUnackedTail;
   10fb0:	1a9b      	subs	r3, r3, r2
   10fb2:	b29b      	uxth	r3, r3
        if(toSendData > pSkt->remoteWindow)
   10fb4:	f8b4 005c 	ldrh.w	r0, [r4, #92]	; 0x5c
   10fb8:	4601      	mov	r1, r0
   10fba:	4298      	cmp	r0, r3
   10fbc:	bf28      	it	cs
   10fbe:	4619      	movcs	r1, r3
        if(canSend >= pSkt->wRemoteMSS || canSend >= (pSkt->maxRemoteWindow >> 1))
   10fc0:	f8b4 5062 	ldrh.w	r5, [r4, #98]	; 0x62
   10fc4:	428d      	cmp	r5, r1
   10fc6:	d947      	bls.n	11058 <TCPIP_TCP_ArrayPut+0x118>
   10fc8:	f8b4 5066 	ldrh.w	r5, [r4, #102]	; 0x66
   10fcc:	ebb1 0f55 	cmp.w	r1, r5, lsr #1
   10fd0:	d242      	bcs.n	11058 <TCPIP_TCP_ArrayPut+0x118>
        if(canSend == toSendData)
   10fd2:	4298      	cmp	r0, r3
   10fd4:	d236      	bcs.n	11044 <TCPIP_TCP_ArrayPut+0x104>
	else if(!pSkt->Flags.bTimer2Enabled)
   10fd6:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
   10fda:	f013 0f04 	tst.w	r3, #4
   10fde:	d03f      	beq.n	11060 <TCPIP_TCP_ArrayPut+0x120>
	return wActualLen + wRightLen;
   10fe0:	eb08 0609 	add.w	r6, r8, r9
   10fe4:	b2b6      	uxth	r6, r6
   10fe6:	e04f      	b.n	11088 <TCPIP_TCP_ArrayPut+0x148>
		wRightLen = pSkt->txEnd-pSkt->txHead;
   10fe8:	eba3 0900 	sub.w	r9, r3, r0
   10fec:	fa1f f989 	uxth.w	r9, r9
        memcpy((uint8_t*)pSkt->txHead, data, wRightLen);
   10ff0:	464a      	mov	r2, r9
   10ff2:	4639      	mov	r1, r7
   10ff4:	f010 f8c4 	bl	21180 <memcpy>
		data += wRightLen;
   10ff8:	444f      	add	r7, r9
		wActualLen -= wRightLen;
   10ffa:	eba5 0809 	sub.w	r8, r5, r9
   10ffe:	fa1f f888 	uxth.w	r8, r8
		pSkt->txHead = pSkt->txStart;
   11002:	6823      	ldr	r3, [r4, #0]
   11004:	60a3      	str	r3, [r4, #8]
   11006:	e7c1      	b.n	10f8c <TCPIP_TCP_ArrayPut+0x4c>
            if(pSkt->Flags.bHalfFullFlush == 0 && wFreeTxSpace <=  ((pSkt->txEnd - pSkt->txStart) >> 1) )
   11008:	f894 1036 	ldrb.w	r1, [r4, #54]	; 0x36
   1100c:	f011 0f20 	tst.w	r1, #32
   11010:	d1cc      	bne.n	10fac <TCPIP_TCP_ArrayPut+0x6c>
    wFreeTxSpace -= wActualLen; // new free space
   11012:	1b75      	subs	r5, r6, r5
            if(pSkt->Flags.bHalfFullFlush == 0 && wFreeTxSpace <=  ((pSkt->txEnd - pSkt->txStart) >> 1) )
   11014:	b2ad      	uxth	r5, r5
   11016:	6861      	ldr	r1, [r4, #4]
   11018:	6820      	ldr	r0, [r4, #0]
   1101a:	1a09      	subs	r1, r1, r0
        if(toFlush == false)
   1101c:	ebb5 0f61 	cmp.w	r5, r1, asr #1
   11020:	dcc4      	bgt.n	10fac <TCPIP_TCP_ArrayPut+0x6c>
        _TcpFlush(pSkt);
   11022:	4620      	mov	r0, r4
   11024:	f00e ff0e 	bl	1fe44 <_TcpFlush>
            pSkt->Flags.bHalfFullFlush = true;
   11028:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
   1102c:	f043 0320 	orr.w	r3, r3, #32
   11030:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
   11034:	e7d4      	b.n	10fe0 <TCPIP_TCP_ArrayPut+0xa0>
            toSendData = (pSkt->txEnd - pSkt->txUnackedTail) + (pSkt->txHead - pSkt->txStart);
   11036:	6861      	ldr	r1, [r4, #4]
   11038:	1a89      	subs	r1, r1, r2
   1103a:	6820      	ldr	r0, [r4, #0]
   1103c:	1a1b      	subs	r3, r3, r0
   1103e:	440b      	add	r3, r1
   11040:	b29b      	uxth	r3, r3
   11042:	e7b7      	b.n	10fb4 <TCPIP_TCP_ArrayPut+0x74>
            if(pSkt->flags.forceFlush || (pSkt->Flags.delayAckSend == 0 && pSkt->txTail == pSkt->txUnackedTail))
   11044:	f017 0f08 	tst.w	r7, #8
   11048:	d106      	bne.n	11058 <TCPIP_TCP_ArrayPut+0x118>
   1104a:	f994 3037 	ldrsb.w	r3, [r4, #55]	; 0x37
   1104e:	2b00      	cmp	r3, #0
   11050:	dbc1      	blt.n	10fd6 <TCPIP_TCP_ArrayPut+0x96>
   11052:	68e3      	ldr	r3, [r4, #12]
   11054:	429a      	cmp	r2, r3
   11056:	d1be      	bne.n	10fd6 <TCPIP_TCP_ArrayPut+0x96>
        _TcpFlush(pSkt);
   11058:	4620      	mov	r0, r4
   1105a:	f00e fef3 	bl	1fe44 <_TcpFlush>
        if(toSetFlag)
   1105e:	e7bf      	b.n	10fe0 <TCPIP_TCP_ArrayPut+0xa0>
		pSkt->Flags.bTimer2Enabled = true;
   11060:	f043 0304 	orr.w	r3, r3, #4
   11064:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
		pSkt->eventTime2 = SYS_TMR_TickCountGet() + (TCPIP_TCP_AUTO_TRANSMIT_TIMEOUT_VAL * SYS_TMR_TickCounterFrequencyGet())/1000;
   11068:	f00f f840 	bl	200ec <SYS_TMR_TickCountGet>
   1106c:	4605      	mov	r5, r0
   1106e:	f00f f865 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
   11072:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   11076:	00c0      	lsls	r0, r0, #3
   11078:	4b0c      	ldr	r3, [pc, #48]	; (110ac <TCPIP_TCP_ArrayPut+0x16c>)
   1107a:	fba3 3000 	umull	r3, r0, r3, r0
   1107e:	eb05 1090 	add.w	r0, r5, r0, lsr #6
   11082:	62a0      	str	r0, [r4, #40]	; 0x28
   11084:	e7ac      	b.n	10fe0 <TCPIP_TCP_ArrayPut+0xa0>
        return 0;
   11086:	4616      	mov	r6, r2
}
   11088:	4630      	mov	r0, r6
   1108a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return 0;
   1108e:	2600      	movs	r6, #0
   11090:	e7fa      	b.n	11088 <TCPIP_TCP_ArrayPut+0x148>
   11092:	2600      	movs	r6, #0
   11094:	e7f8      	b.n	11088 <TCPIP_TCP_ArrayPut+0x148>
        return 0;
   11096:	2600      	movs	r6, #0
   11098:	e7f6      	b.n	11088 <TCPIP_TCP_ArrayPut+0x148>
    switch(pSkt->addType)
   1109a:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
   1109e:	2b01      	cmp	r3, #1
   110a0:	d1f2      	bne.n	11088 <TCPIP_TCP_ArrayPut+0x148>
            _TcpFlush(pSkt);
   110a2:	4620      	mov	r0, r4
   110a4:	f00e fece 	bl	1fe44 <_TcpFlush>
   110a8:	e7ee      	b.n	11088 <TCPIP_TCP_ArrayPut+0x148>
   110aa:	bf00      	nop
   110ac:	10624dd3 	.word	0x10624dd3

Disassembly of section .text.SERCOM0_SPI_InterruptHandler%248:

000110b0 <SERCOM0_SPI_InterruptHandler>:
{
    uint32_t dataBits = 0U;
    uint32_t receivedData = 0U;
    static bool isLastByteTransferInProgress = false;

    if(SERCOM0_REGS->SPIM.SERCOM_INTENSET != 0U)
   110b0:	4b58      	ldr	r3, [pc, #352]	; (11214 <SERCOM0_SPI_InterruptHandler+0x164>)
   110b2:	7d9b      	ldrb	r3, [r3, #22]
   110b4:	2b00      	cmp	r3, #0
   110b6:	f000 80ab 	beq.w	11210 <SERCOM0_SPI_InterruptHandler+0x160>
{
   110ba:	b510      	push	{r4, lr}
    {
        dataBits = SERCOM0_REGS->SPIM.SERCOM_CTRLB & SERCOM_SPIM_CTRLB_CHSIZE_Msk;
   110bc:	4a55      	ldr	r2, [pc, #340]	; (11214 <SERCOM0_SPI_InterruptHandler+0x164>)
   110be:	6853      	ldr	r3, [r2, #4]
   110c0:	f003 0307 	and.w	r3, r3, #7

        if((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_RXC_Msk) == SERCOM_SPIM_INTFLAG_RXC_Msk)
   110c4:	7e12      	ldrb	r2, [r2, #24]
   110c6:	f012 0f04 	tst.w	r2, #4
   110ca:	d05b      	beq.n	11184 <SERCOM0_SPI_InterruptHandler+0xd4>
        {
            receivedData =  SERCOM0_REGS->SPIM.SERCOM_DATA;
   110cc:	4a51      	ldr	r2, [pc, #324]	; (11214 <SERCOM0_SPI_InterruptHandler+0x164>)
   110ce:	6a90      	ldr	r0, [r2, #40]	; 0x28

            if(sercom0SPIObj.rxCount < sercom0SPIObj.rxSize)
   110d0:	4a51      	ldr	r2, [pc, #324]	; (11218 <SERCOM0_SPI_InterruptHandler+0x168>)
   110d2:	6951      	ldr	r1, [r2, #20]
   110d4:	68d2      	ldr	r2, [r2, #12]
   110d6:	4291      	cmp	r1, r2
   110d8:	d254      	bcs.n	11184 <SERCOM0_SPI_InterruptHandler+0xd4>
            {
                if(dataBits == (uint32_t)SPI_DATA_BITS_8)
   110da:	2b00      	cmp	r3, #0
   110dc:	d143      	bne.n	11166 <SERCOM0_SPI_InterruptHandler+0xb6>
                {
                    ((uint8_t*)sercom0SPIObj.rxBuffer)[sercom0SPIObj.rxCount++] = (uint8_t)receivedData;
   110de:	4b4e      	ldr	r3, [pc, #312]	; (11218 <SERCOM0_SPI_InterruptHandler+0x168>)
   110e0:	685a      	ldr	r2, [r3, #4]
   110e2:	1c4c      	adds	r4, r1, #1
   110e4:	615c      	str	r4, [r3, #20]
   110e6:	5450      	strb	r0, [r2, r1]
                }
            }
        }

        /* If there are more words to be transmitted, then transmit them here and keep track of the count */
        if((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_DRE_Msk) == SERCOM_SPIM_INTFLAG_DRE_Msk)
   110e8:	4b4a      	ldr	r3, [pc, #296]	; (11214 <SERCOM0_SPI_InterruptHandler+0x164>)
   110ea:	7e1b      	ldrb	r3, [r3, #24]
   110ec:	f013 0f01 	tst.w	r3, #1
   110f0:	d018      	beq.n	11124 <SERCOM0_SPI_InterruptHandler+0x74>
        {
            /* Disable the DRE interrupt. This will be enabled back if more than
             * one byte is pending to be transmitted */
            SERCOM0_REGS->SPIM.SERCOM_INTENCLR = (uint8_t)SERCOM_SPIM_INTENCLR_DRE_Msk;
   110f2:	4b48      	ldr	r3, [pc, #288]	; (11214 <SERCOM0_SPI_InterruptHandler+0x164>)
   110f4:	2201      	movs	r2, #1
   110f6:	751a      	strb	r2, [r3, #20]

            if(dataBits == (uint32_t)SPI_DATA_BITS_8)
            {
                if(sercom0SPIObj.txCount < sercom0SPIObj.txSize)
   110f8:	4b47      	ldr	r3, [pc, #284]	; (11218 <SERCOM0_SPI_InterruptHandler+0x168>)
   110fa:	699a      	ldr	r2, [r3, #24]
   110fc:	689b      	ldr	r3, [r3, #8]
   110fe:	429a      	cmp	r2, r3
   11100:	d258      	bcs.n	111b4 <SERCOM0_SPI_InterruptHandler+0x104>
                {
                    SERCOM0_REGS->SPIM.SERCOM_DATA = ((uint8_t*)sercom0SPIObj.txBuffer)[sercom0SPIObj.txCount++];
   11102:	4b45      	ldr	r3, [pc, #276]	; (11218 <SERCOM0_SPI_InterruptHandler+0x168>)
   11104:	6819      	ldr	r1, [r3, #0]
   11106:	1c50      	adds	r0, r2, #1
   11108:	6198      	str	r0, [r3, #24]
   1110a:	5c8a      	ldrb	r2, [r1, r2]
   1110c:	4b41      	ldr	r3, [pc, #260]	; (11214 <SERCOM0_SPI_InterruptHandler+0x164>)
   1110e:	629a      	str	r2, [r3, #40]	; 0x28
                {
                    /* Do nothing */
                }
            }

            if((sercom0SPIObj.txCount == sercom0SPIObj.txSize) && (sercom0SPIObj.dummySize == 0U))
   11110:	4b41      	ldr	r3, [pc, #260]	; (11218 <SERCOM0_SPI_InterruptHandler+0x168>)
   11112:	699a      	ldr	r2, [r3, #24]
   11114:	689b      	ldr	r3, [r3, #8]
   11116:	429a      	cmp	r2, r3
   11118:	d061      	beq.n	111de <SERCOM0_SPI_InterruptHandler+0x12e>
                 * the TXC interrupt is not enabled until the very end.
                 */

                isLastByteTransferInProgress = true;
            }
            else if(sercom0SPIObj.rxCount == sercom0SPIObj.rxSize)
   1111a:	4b3f      	ldr	r3, [pc, #252]	; (11218 <SERCOM0_SPI_InterruptHandler+0x168>)
   1111c:	695a      	ldr	r2, [r3, #20]
   1111e:	68db      	ldr	r3, [r3, #12]
   11120:	429a      	cmp	r2, r3
   11122:	d069      	beq.n	111f8 <SERCOM0_SPI_InterruptHandler+0x148>
            {
                /* Do nothing */
            }
        }

        if(((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_TXC_Msk) == SERCOM_SPIM_INTFLAG_TXC_Msk) && (isLastByteTransferInProgress == true))
   11124:	4b3b      	ldr	r3, [pc, #236]	; (11214 <SERCOM0_SPI_InterruptHandler+0x164>)
   11126:	7e1b      	ldrb	r3, [r3, #24]
   11128:	f013 0f02 	tst.w	r3, #2
   1112c:	d014      	beq.n	11158 <SERCOM0_SPI_InterruptHandler+0xa8>
   1112e:	4b3b      	ldr	r3, [pc, #236]	; (1121c <SERCOM0_SPI_InterruptHandler+0x16c>)
   11130:	781b      	ldrb	r3, [r3, #0]
   11132:	b1bb      	cbz	r3, 11164 <SERCOM0_SPI_InterruptHandler+0xb4>
        {
            if(sercom0SPIObj.rxCount == sercom0SPIObj.rxSize)
   11134:	4b38      	ldr	r3, [pc, #224]	; (11218 <SERCOM0_SPI_InterruptHandler+0x168>)
   11136:	695a      	ldr	r2, [r3, #20]
   11138:	68db      	ldr	r3, [r3, #12]
   1113a:	429a      	cmp	r2, r3
   1113c:	d10f      	bne.n	1115e <SERCOM0_SPI_InterruptHandler+0xae>
            {
                sercom0SPIObj.transferIsBusy = false;
   1113e:	4b36      	ldr	r3, [pc, #216]	; (11218 <SERCOM0_SPI_InterruptHandler+0x168>)
   11140:	2200      	movs	r2, #0
   11142:	771a      	strb	r2, [r3, #28]

                /* Disable the Data Register empty and Receive Complete Interrupt flags */
                SERCOM0_REGS->SPIM.SERCOM_INTENCLR = (uint8_t)(SERCOM_SPIM_INTENCLR_DRE_Msk | SERCOM_SPIM_INTENCLR_RXC_Msk | SERCOM_SPIM_INTENSET_TXC_Msk);
   11144:	4933      	ldr	r1, [pc, #204]	; (11214 <SERCOM0_SPI_InterruptHandler+0x164>)
   11146:	2007      	movs	r0, #7
   11148:	7508      	strb	r0, [r1, #20]

                isLastByteTransferInProgress = false;
   1114a:	4934      	ldr	r1, [pc, #208]	; (1121c <SERCOM0_SPI_InterruptHandler+0x16c>)
   1114c:	700a      	strb	r2, [r1, #0]

                if(sercom0SPIObj.callback != NULL)
   1114e:	6a1b      	ldr	r3, [r3, #32]
   11150:	b143      	cbz	r3, 11164 <SERCOM0_SPI_InterruptHandler+0xb4>
                {
                    sercom0SPIObj.callback(sercom0SPIObj.context);
   11152:	4a31      	ldr	r2, [pc, #196]	; (11218 <SERCOM0_SPI_InterruptHandler+0x168>)
   11154:	6a50      	ldr	r0, [r2, #36]	; 0x24
   11156:	4798      	blx	r3
                }
            }
        }

        if(isLastByteTransferInProgress == true)
   11158:	4b30      	ldr	r3, [pc, #192]	; (1121c <SERCOM0_SPI_InterruptHandler+0x16c>)
   1115a:	781b      	ldrb	r3, [r3, #0]
   1115c:	b113      	cbz	r3, 11164 <SERCOM0_SPI_InterruptHandler+0xb4>
        {
            /* For the last byte transfer, the DRE interrupt is already disabled.
             * Enable TXC interrupt to ensure no data is present in the shift
             * register before application callback is called.
             */
            SERCOM0_REGS->SPIM.SERCOM_INTENSET = (uint8_t)SERCOM_SPIM_INTENSET_TXC_Msk;
   1115e:	4b2d      	ldr	r3, [pc, #180]	; (11214 <SERCOM0_SPI_InterruptHandler+0x164>)
   11160:	2202      	movs	r2, #2
   11162:	759a      	strb	r2, [r3, #22]
        }
    }
}
   11164:	bd10      	pop	{r4, pc}
                    ((uint16_t*)sercom0SPIObj.rxBuffer)[sercom0SPIObj.rxCount++] = (uint16_t)receivedData;
   11166:	4b2c      	ldr	r3, [pc, #176]	; (11218 <SERCOM0_SPI_InterruptHandler+0x168>)
   11168:	685a      	ldr	r2, [r3, #4]
   1116a:	1c4c      	adds	r4, r1, #1
   1116c:	615c      	str	r4, [r3, #20]
   1116e:	f822 0011 	strh.w	r0, [r2, r1, lsl #1]
        if((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_DRE_Msk) == SERCOM_SPIM_INTFLAG_DRE_Msk)
   11172:	4b28      	ldr	r3, [pc, #160]	; (11214 <SERCOM0_SPI_InterruptHandler+0x164>)
   11174:	7e1b      	ldrb	r3, [r3, #24]
   11176:	f013 0f01 	tst.w	r3, #1
   1117a:	d0d3      	beq.n	11124 <SERCOM0_SPI_InterruptHandler+0x74>
            SERCOM0_REGS->SPIM.SERCOM_INTENCLR = (uint8_t)SERCOM_SPIM_INTENCLR_DRE_Msk;
   1117c:	4b25      	ldr	r3, [pc, #148]	; (11214 <SERCOM0_SPI_InterruptHandler+0x164>)
   1117e:	2201      	movs	r2, #1
   11180:	751a      	strb	r2, [r3, #20]
            if(dataBits == (uint32_t)SPI_DATA_BITS_8)
   11182:	e009      	b.n	11198 <SERCOM0_SPI_InterruptHandler+0xe8>
        if((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_DRE_Msk) == SERCOM_SPIM_INTFLAG_DRE_Msk)
   11184:	4a23      	ldr	r2, [pc, #140]	; (11214 <SERCOM0_SPI_InterruptHandler+0x164>)
   11186:	7e12      	ldrb	r2, [r2, #24]
   11188:	f012 0f01 	tst.w	r2, #1
   1118c:	d0ca      	beq.n	11124 <SERCOM0_SPI_InterruptHandler+0x74>
            SERCOM0_REGS->SPIM.SERCOM_INTENCLR = (uint8_t)SERCOM_SPIM_INTENCLR_DRE_Msk;
   1118e:	4a21      	ldr	r2, [pc, #132]	; (11214 <SERCOM0_SPI_InterruptHandler+0x164>)
   11190:	2101      	movs	r1, #1
   11192:	7511      	strb	r1, [r2, #20]
            if(dataBits == (uint32_t)SPI_DATA_BITS_8)
   11194:	2b00      	cmp	r3, #0
   11196:	d0af      	beq.n	110f8 <SERCOM0_SPI_InterruptHandler+0x48>
                if(sercom0SPIObj.txCount < sercom0SPIObj.txSize)
   11198:	4b1f      	ldr	r3, [pc, #124]	; (11218 <SERCOM0_SPI_InterruptHandler+0x168>)
   1119a:	699a      	ldr	r2, [r3, #24]
   1119c:	689b      	ldr	r3, [r3, #8]
   1119e:	429a      	cmp	r2, r3
   111a0:	d212      	bcs.n	111c8 <SERCOM0_SPI_InterruptHandler+0x118>
                    SERCOM0_REGS->SPIM.SERCOM_DATA = ((uint16_t*)sercom0SPIObj.txBuffer)[sercom0SPIObj.txCount++];
   111a2:	4b1d      	ldr	r3, [pc, #116]	; (11218 <SERCOM0_SPI_InterruptHandler+0x168>)
   111a4:	6819      	ldr	r1, [r3, #0]
   111a6:	1c50      	adds	r0, r2, #1
   111a8:	6198      	str	r0, [r3, #24]
   111aa:	f831 2012 	ldrh.w	r2, [r1, r2, lsl #1]
   111ae:	4b19      	ldr	r3, [pc, #100]	; (11214 <SERCOM0_SPI_InterruptHandler+0x164>)
   111b0:	629a      	str	r2, [r3, #40]	; 0x28
   111b2:	e7ad      	b.n	11110 <SERCOM0_SPI_InterruptHandler+0x60>
                else if(sercom0SPIObj.dummySize > 0U)
   111b4:	4b18      	ldr	r3, [pc, #96]	; (11218 <SERCOM0_SPI_InterruptHandler+0x168>)
   111b6:	691b      	ldr	r3, [r3, #16]
   111b8:	b323      	cbz	r3, 11204 <SERCOM0_SPI_InterruptHandler+0x154>
                    SERCOM0_REGS->SPIM.SERCOM_DATA = 0xFFU;
   111ba:	4a16      	ldr	r2, [pc, #88]	; (11214 <SERCOM0_SPI_InterruptHandler+0x164>)
   111bc:	21ff      	movs	r1, #255	; 0xff
   111be:	6291      	str	r1, [r2, #40]	; 0x28
                    sercom0SPIObj.dummySize--;
   111c0:	3b01      	subs	r3, #1
   111c2:	4a15      	ldr	r2, [pc, #84]	; (11218 <SERCOM0_SPI_InterruptHandler+0x168>)
   111c4:	6113      	str	r3, [r2, #16]
   111c6:	e7a3      	b.n	11110 <SERCOM0_SPI_InterruptHandler+0x60>
                else if(sercom0SPIObj.dummySize > 0U)
   111c8:	4b13      	ldr	r3, [pc, #76]	; (11218 <SERCOM0_SPI_InterruptHandler+0x168>)
   111ca:	691b      	ldr	r3, [r3, #16]
   111cc:	b1d3      	cbz	r3, 11204 <SERCOM0_SPI_InterruptHandler+0x154>
                    SERCOM0_REGS->SPIM.SERCOM_DATA = 0xFFFFU;
   111ce:	4a11      	ldr	r2, [pc, #68]	; (11214 <SERCOM0_SPI_InterruptHandler+0x164>)
   111d0:	f64f 71ff 	movw	r1, #65535	; 0xffff
   111d4:	6291      	str	r1, [r2, #40]	; 0x28
                    sercom0SPIObj.dummySize--;
   111d6:	3b01      	subs	r3, #1
   111d8:	4a0f      	ldr	r2, [pc, #60]	; (11218 <SERCOM0_SPI_InterruptHandler+0x168>)
   111da:	6113      	str	r3, [r2, #16]
   111dc:	e798      	b.n	11110 <SERCOM0_SPI_InterruptHandler+0x60>
            if((sercom0SPIObj.txCount == sercom0SPIObj.txSize) && (sercom0SPIObj.dummySize == 0U))
   111de:	4b0e      	ldr	r3, [pc, #56]	; (11218 <SERCOM0_SPI_InterruptHandler+0x168>)
   111e0:	691b      	ldr	r3, [r3, #16]
   111e2:	2b00      	cmp	r3, #0
   111e4:	d199      	bne.n	1111a <SERCOM0_SPI_InterruptHandler+0x6a>
                isLastByteTransferInProgress = true;
   111e6:	4b0d      	ldr	r3, [pc, #52]	; (1121c <SERCOM0_SPI_InterruptHandler+0x16c>)
   111e8:	2201      	movs	r2, #1
   111ea:	701a      	strb	r2, [r3, #0]
        if(((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_TXC_Msk) == SERCOM_SPIM_INTFLAG_TXC_Msk) && (isLastByteTransferInProgress == true))
   111ec:	4b09      	ldr	r3, [pc, #36]	; (11214 <SERCOM0_SPI_InterruptHandler+0x164>)
   111ee:	7e1b      	ldrb	r3, [r3, #24]
   111f0:	f013 0f02 	tst.w	r3, #2
   111f4:	d19e      	bne.n	11134 <SERCOM0_SPI_InterruptHandler+0x84>
   111f6:	e7b2      	b.n	1115e <SERCOM0_SPI_InterruptHandler+0xae>
                SERCOM0_REGS->SPIM.SERCOM_INTENSET = (uint8_t)SERCOM_SPIM_INTENSET_DRE_Msk;
   111f8:	4b06      	ldr	r3, [pc, #24]	; (11214 <SERCOM0_SPI_InterruptHandler+0x164>)
   111fa:	2201      	movs	r2, #1
   111fc:	759a      	strb	r2, [r3, #22]
                SERCOM0_REGS->SPIM.SERCOM_INTENCLR = (uint8_t)SERCOM_SPIM_INTENCLR_RXC_Msk;
   111fe:	2204      	movs	r2, #4
   11200:	751a      	strb	r2, [r3, #20]
   11202:	e78f      	b.n	11124 <SERCOM0_SPI_InterruptHandler+0x74>
            if((sercom0SPIObj.txCount == sercom0SPIObj.txSize) && (sercom0SPIObj.dummySize == 0U))
   11204:	4b04      	ldr	r3, [pc, #16]	; (11218 <SERCOM0_SPI_InterruptHandler+0x168>)
   11206:	699a      	ldr	r2, [r3, #24]
   11208:	689b      	ldr	r3, [r3, #8]
   1120a:	429a      	cmp	r2, r3
   1120c:	d185      	bne.n	1111a <SERCOM0_SPI_InterruptHandler+0x6a>
   1120e:	e7ea      	b.n	111e6 <SERCOM0_SPI_InterruptHandler+0x136>
   11210:	4770      	bx	lr
   11212:	bf00      	nop
   11214:	40003000 	.word	0x40003000
   11218:	2000e09c 	.word	0x2000e09c
   1121c:	2000e510 	.word	0x2000e510

Disassembly of section .text._DHCPOptionHostName%249:

00011220 <_DHCPOptionHostName>:
{
   11220:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11224:	b087      	sub	sp, #28
   11226:	4681      	mov	r9, r0
   11228:	4688      	mov	r8, r1
    pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   1122a:	4b56      	ldr	r3, [pc, #344]	; (11384 <_DHCPOptionHostName+0x164>)
   1122c:	681c      	ldr	r4, [r3, #0]
   1122e:	f010 fd79 	bl	21d24 <TCPIP_STACK_NetIxGet>
   11232:	275c      	movs	r7, #92	; 0x5c
   11234:	fb07 4700 	mla	r7, r7, r0, r4
    if(pClient->nameCallback != 0)
   11238:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1123a:	b173      	cbz	r3, 1125a <_DHCPOptionHostName+0x3a>
        if((cbName = (*pClient->nameCallback)(pNetIf)) != 0)
   1123c:	4648      	mov	r0, r9
   1123e:	4798      	blx	r3
   11240:	4606      	mov	r6, r0
   11242:	b150      	cbz	r0, 1125a <_DHCPOptionHostName+0x3a>
            if(strlen(cbName) >= 2)
   11244:	f010 fd32 	bl	21cac <strlen>
   11248:	2801      	cmp	r0, #1
   1124a:	d906      	bls.n	1125a <_DHCPOptionHostName+0x3a>
                if(pClient->flags.bWriteBack != 0)
   1124c:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
   11250:	f013 0f40 	tst.w	r3, #64	; 0x40
   11254:	d02b      	beq.n	112ae <_DHCPOptionHostName+0x8e>
                    writeBackLen = strlen(cbName) + 1;
   11256:	1c45      	adds	r5, r0, #1
   11258:	e004      	b.n	11264 <_DHCPOptionHostName+0x44>
        srcName = (char*)TCPIP_STACK_NetBIOSName(pNetIf);
   1125a:	4648      	mov	r0, r9
   1125c:	f010 ffe3 	bl	22226 <TCPIP_STACK_NetBIOSName>
   11260:	4606      	mov	r6, r0
   11262:	2500      	movs	r5, #0
    memset(destBuffer, 0x0, destSize);
   11264:	2300      	movs	r3, #0
   11266:	9300      	str	r3, [sp, #0]
   11268:	9301      	str	r3, [sp, #4]
   1126a:	9302      	str	r3, [sp, #8]
   1126c:	9303      	str	r3, [sp, #12]
   1126e:	9304      	str	r3, [sp, #16]
   11270:	f88d 3014 	strb.w	r3, [sp, #20]
    for(ix = 0; ix < destSize - 1; ix++)
   11274:	f106 0414 	add.w	r4, r6, #20
    memset(destBuffer, 0x0, destSize);
   11278:	4632      	mov	r2, r6
    d = destBuffer;
   1127a:	466b      	mov	r3, sp
        if(!isspace(currC))
   1127c:	4842      	ldr	r0, [pc, #264]	; (11388 <_DHCPOptionHostName+0x168>)
        currC = *srcBuffer++;
   1127e:	f812 1b01 	ldrb.w	r1, [r2], #1
        if(!isspace(currC))
   11282:	5c0f      	ldrb	r7, [r1, r0]
   11284:	f017 0f08 	tst.w	r7, #8
            *d++ = currC;
   11288:	bf08      	it	eq
   1128a:	f803 1b01 	strbeq.w	r1, [r3], #1
    for(ix = 0; ix < destSize - 1; ix++)
   1128e:	42a2      	cmp	r2, r4
   11290:	d1f5      	bne.n	1127e <_DHCPOptionHostName+0x5e>
    len = strlen(destBuffer);
   11292:	4668      	mov	r0, sp
   11294:	f010 fd0a 	bl	21cac <strlen>
   11298:	4604      	mov	r4, r0
   1129a:	4607      	mov	r7, r0
    if(len)
   1129c:	2800      	cmp	r0, #0
   1129e:	d057      	beq.n	11350 <_DHCPOptionHostName+0x130>
   112a0:	4669      	mov	r1, sp
        for(ix = 0; ix < len; ix++)
   112a2:	2200      	movs	r2, #0
            if(currC != '-' && currC != '.' && !isalnum(currC))
   112a4:	f8df e0e0 	ldr.w	lr, [pc, #224]	; 11388 <_DHCPOptionHostName+0x168>
                *d = TCPIP_DHCP_HOST_REPLACE_CHAR;
   112a8:	f04f 0c78 	mov.w	ip, #120	; 0x78
   112ac:	e004      	b.n	112b8 <_DHCPOptionHostName+0x98>
    int     writeBackLen = 0;
   112ae:	2500      	movs	r5, #0
   112b0:	e7d8      	b.n	11264 <_DHCPOptionHostName+0x44>
        for(ix = 0; ix < len; ix++)
   112b2:	3201      	adds	r2, #1
   112b4:	4297      	cmp	r7, r2
   112b6:	dd0e      	ble.n	112d6 <_DHCPOptionHostName+0xb6>
            currC = *d;
   112b8:	f811 0b01 	ldrb.w	r0, [r1], #1
            if(currC != '-' && currC != '.' && !isalnum(currC))
   112bc:	f1a0 032d 	sub.w	r3, r0, #45	; 0x2d
   112c0:	b2db      	uxtb	r3, r3
   112c2:	2b01      	cmp	r3, #1
   112c4:	d9f5      	bls.n	112b2 <_DHCPOptionHostName+0x92>
   112c6:	f810 300e 	ldrb.w	r3, [r0, lr]
   112ca:	f013 0f07 	tst.w	r3, #7
                *d = TCPIP_DHCP_HOST_REPLACE_CHAR;
   112ce:	bf08      	it	eq
   112d0:	f801 cc01 	strbeq.w	ip, [r1, #-1]
   112d4:	e7ed      	b.n	112b2 <_DHCPOptionHostName+0x92>
        if(!isalpha(currC))
   112d6:	f89d 2000 	ldrb.w	r2, [sp]
   112da:	4b2b      	ldr	r3, [pc, #172]	; (11388 <_DHCPOptionHostName+0x168>)
   112dc:	5cd3      	ldrb	r3, [r2, r3]
   112de:	f013 0f03 	tst.w	r3, #3
            destBuffer[0] = TCPIP_DHCP_HOST_REPLACE_CHAR;
   112e2:	bf04      	itt	eq
   112e4:	2378      	moveq	r3, #120	; 0x78
   112e6:	f88d 3000 	strbeq.w	r3, [sp]
        currC = destBuffer[len - 1];
   112ea:	1e63      	subs	r3, r4, #1
        if(!isalnum(currC))
   112ec:	f81d 1003 	ldrb.w	r1, [sp, r3]
   112f0:	4a25      	ldr	r2, [pc, #148]	; (11388 <_DHCPOptionHostName+0x168>)
   112f2:	5c8a      	ldrb	r2, [r1, r2]
   112f4:	f012 0f07 	tst.w	r2, #7
   112f8:	d102      	bne.n	11300 <_DHCPOptionHostName+0xe0>
            destBuffer[len - 1] = TCPIP_DHCP_HOST_REPLACE_CHAR;
   112fa:	2278      	movs	r2, #120	; 0x78
   112fc:	f80d 2003 	strb.w	r2, [sp, r3]
    if(writeBackLen)
   11300:	b365      	cbz	r5, 1135c <_DHCPOptionHostName+0x13c>
        srcName[0] = 0;
   11302:	2300      	movs	r3, #0
   11304:	7033      	strb	r3, [r6, #0]
    if(pSendData->writeSpace >= sizeof(*pHost) + hostLen)
   11306:	1ca7      	adds	r7, r4, #2
   11308:	f8d8 3004 	ldr.w	r3, [r8, #4]
   1130c:	42bb      	cmp	r3, r7
    return -1;
   1130e:	bf38      	it	cc
   11310:	f04f 35ff 	movcc.w	r5, #4294967295
    if(pSendData->writeSpace >= sizeof(*pHost) + hostLen)
   11314:	d318      	bcc.n	11348 <_DHCPOptionHostName+0x128>
        pHost = (TCPIP_DHCP_OPTION_DATA_HOST_NAME*)pSendData->pOpt;
   11316:	f8d8 0000 	ldr.w	r0, [r8]
        pHost->opt = TCPIP_DHCP_HOST_NAME;
   1131a:	230c      	movs	r3, #12
   1131c:	7003      	strb	r3, [r0, #0]
        pHost->len = hostLen;
   1131e:	7044      	strb	r4, [r0, #1]
        memcpy(pHost->hostname, hostName, hostLen);
   11320:	4622      	mov	r2, r4
   11322:	4669      	mov	r1, sp
   11324:	3002      	adds	r0, #2
   11326:	f00f ff2b 	bl	21180 <memcpy>
        if(writeBackLen)
   1132a:	b165      	cbz	r5, 11346 <_DHCPOptionHostName+0x126>
            if(writeBackLen > hostLen + 1)
   1132c:	3401      	adds	r4, #1
            memcpy(srcName, hostName, writeBackLen);
   1132e:	42a5      	cmp	r5, r4
   11330:	bfa8      	it	ge
   11332:	4625      	movge	r5, r4
   11334:	462a      	mov	r2, r5
   11336:	4669      	mov	r1, sp
   11338:	4630      	mov	r0, r6
   1133a:	f00f ff21 	bl	21180 <memcpy>
            srcName[writeBackLen - 1] = 0;
   1133e:	4435      	add	r5, r6
   11340:	2300      	movs	r3, #0
   11342:	f805 3c01 	strb.w	r3, [r5, #-1]
        return sizeof(*pHost) + hostLen;
   11346:	463d      	mov	r5, r7
}
   11348:	4628      	mov	r0, r5
   1134a:	b007      	add	sp, #28
   1134c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if(writeBackLen)
   11350:	2d00      	cmp	r5, #0
   11352:	d0f9      	beq.n	11348 <_DHCPOptionHostName+0x128>
        srcName[0] = 0;
   11354:	2300      	movs	r3, #0
   11356:	7033      	strb	r3, [r6, #0]
        return 0;
   11358:	4605      	mov	r5, r0
   1135a:	e7f5      	b.n	11348 <_DHCPOptionHostName+0x128>
    if(pSendData->writeSpace >= sizeof(*pHost) + hostLen)
   1135c:	1ca7      	adds	r7, r4, #2
   1135e:	f8d8 3004 	ldr.w	r3, [r8, #4]
   11362:	42bb      	cmp	r3, r7
    return -1;
   11364:	bf38      	it	cc
   11366:	f04f 35ff 	movcc.w	r5, #4294967295
    if(pSendData->writeSpace >= sizeof(*pHost) + hostLen)
   1136a:	d3ed      	bcc.n	11348 <_DHCPOptionHostName+0x128>
        pHost = (TCPIP_DHCP_OPTION_DATA_HOST_NAME*)pSendData->pOpt;
   1136c:	f8d8 0000 	ldr.w	r0, [r8]
        pHost->opt = TCPIP_DHCP_HOST_NAME;
   11370:	230c      	movs	r3, #12
   11372:	7003      	strb	r3, [r0, #0]
        pHost->len = hostLen;
   11374:	7044      	strb	r4, [r0, #1]
        memcpy(pHost->hostname, hostName, hostLen);
   11376:	4622      	mov	r2, r4
   11378:	4669      	mov	r1, sp
   1137a:	3002      	adds	r0, #2
   1137c:	f00f ff00 	bl	21180 <memcpy>
        if(writeBackLen)
   11380:	e7e1      	b.n	11346 <_DHCPOptionHostName+0x126>
   11382:	bf00      	nop
   11384:	2000e408 	.word	0x2000e408
   11388:	00014195 	.word	0x00014195

Disassembly of section .text.DRV_PIC32CGMAC_LibTxAckPacket%250:

0001138c <DRV_PIC32CGMAC_LibTxAckPacket>:
{
   1138c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11390:	b083      	sub	sp, #12
    DRV_PIC32CGMAC_HW_TXDCPT *pTxDesc = pMACDrv->sGmacData.gmac_queue[queueIdx].pTxDesc;
   11392:	232c      	movs	r3, #44	; 0x2c
   11394:	fb03 0301 	mla	r3, r3, r1, r0
   11398:	f8d3 60a0 	ldr.w	r6, [r3, #160]	; 0xa0
	uint16_t tailIndex = pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail;
   1139c:	f8b3 40b4 	ldrh.w	r4, [r3, #180]	; 0xb4
	uint16_t headIndex = pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescHead;
   113a0:	f8b3 80b2 	ldrh.w	r8, [r3, #178]	; 0xb2
    while((tailIndex != headIndex) &&
   113a4:	4544      	cmp	r4, r8
   113a6:	f000 8096 	beq.w	114d6 <DRV_PIC32CGMAC_LibTxAckPacket+0x14a>
          ((pTxDesc[tailIndex].tx_desc_status.val) & GMAC_TX_USED_BIT) &&
   113aa:	00e3      	lsls	r3, r4, #3
   113ac:	18f2      	adds	r2, r6, r3
   113ae:	6855      	ldr	r5, [r2, #4]
    while((tailIndex != headIndex) &&
   113b0:	2d00      	cmp	r5, #0
   113b2:	f280 8092 	bge.w	114da <DRV_PIC32CGMAC_LibTxAckPacket+0x14e>
          (pTxDesc[tailIndex].tx_desc_buffaddr != 0))
   113b6:	f856 5034 	ldr.w	r5, [r6, r4, lsl #3]
          ((pTxDesc[tailIndex].tx_desc_status.val) & GMAC_TX_USED_BIT) &&
   113ba:	2d00      	cmp	r5, #0
   113bc:	f000 808f 	beq.w	114de <DRV_PIC32CGMAC_LibTxAckPacket+0x152>
   113c0:	468b      	mov	fp, r1
   113c2:	4682      	mov	sl, r0
        if(GMAC_TX_ERR_BITS & (pTxDesc[tailIndex].tx_desc_status.val) )
   113c4:	6852      	ldr	r2, [r2, #4]
   113c6:	f012 5f60 	tst.w	r2, #939524096	; 0x38000000
   113ca:	d10f      	bne.n	113ec <DRV_PIC32CGMAC_LibTxAckPacket+0x60>
        pbuff = (uint8_t*)((uint32_t)pTxDesc[tailIndex].tx_desc_buffaddr & pMACDrv->sGmacData._dataOffsetMask);
   113cc:	58f3      	ldr	r3, [r6, r3]
   113ce:	f8d0 20f0 	ldr.w	r2, [r0, #240]	; 0xf0
   113d2:	4013      	ands	r3, r2
        TCPIP_MAC_SEGMENT_GAP_DCPT* pGap = (TCPIP_MAC_SEGMENT_GAP_DCPT*)(pbuff + pMACDrv->sGmacData._dcptOffset);
   113d4:	f9b0 20ec 	ldrsh.w	r2, [r0, #236]	; 0xec
        pPkt = pGap->segmentPktPtr;
   113d8:	5898      	ldr	r0, [r3, r2]
	DRV_PIC32CGMAC_RESULT res = DRV_PIC32CGMAC_RES_NO_PACKET;
   113da:	2101      	movs	r1, #1
            pTxDesc[tailIndex].tx_desc_status.val &= GMAC_TX_USED_BIT | GMAC_TX_WRAP_BIT | GMAC_TX_LAST_BUFFER_BIT;
   113dc:	f8df 910c 	ldr.w	r9, [pc, #268]	; 114ec <DRV_PIC32CGMAC_LibTxAckPacket+0x160>
            pTxDesc[tailIndex].tx_desc_buffaddr = 0;
   113e0:	2700      	movs	r7, #0
        pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail = tailIndex;
   113e2:	232c      	movs	r3, #44	; 0x2c
   113e4:	fb03 a30b 	mla	r3, r3, fp, sl
   113e8:	9301      	str	r3, [sp, #4]
   113ea:	e03d      	b.n	11468 <DRV_PIC32CGMAC_LibTxAckPacket+0xdc>
            pMACDrv->sGmacData._txDiscard = true;
   113ec:	2301      	movs	r3, #1
   113ee:	f88a 30f7 	strb.w	r3, [sl, #247]	; 0xf7
            res = DRV_PIC32CGMAC_RES_TX_ERR;
   113f2:	f06f 0106 	mvn.w	r1, #6
            break;
   113f6:	e06a      	b.n	114ce <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
                pPkt->pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED;
   113f8:	8c43      	ldrh	r3, [r0, #34]	; 0x22
   113fa:	f023 0308 	bic.w	r3, r3, #8
   113fe:	8443      	strh	r3, [r0, #34]	; 0x22
                (pMACDrv->sGmacData.pktAckF)(pPkt, TCPIP_MAC_PKT_ACK_TX_OK, TCPIP_THIS_MODULE_ID);				
   11400:	f8da 302c 	ldr.w	r3, [sl, #44]	; 0x2c
   11404:	f241 0250 	movw	r2, #4176	; 0x1050
   11408:	2101      	movs	r1, #1
   1140a:	4798      	blx	r3
                pMACDrv->sGmacData._txStat.nTxOkPackets++;
   1140c:	f8da 307c 	ldr.w	r3, [sl, #124]	; 0x7c
   11410:	3301      	adds	r3, #1
   11412:	f8ca 307c 	str.w	r3, [sl, #124]	; 0x7c
                pTxDesc[tailIndex].tx_desc_status.val &= ~GMAC_TX_LAST_BUFFER_BIT;
   11416:	686b      	ldr	r3, [r5, #4]
   11418:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
   1141c:	606b      	str	r3, [r5, #4]
                GCIRC_INC(tailIndex, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt);   
   1141e:	3401      	adds	r4, #1
   11420:	b2a4      	uxth	r4, r4
   11422:	eb0b 03cb 	add.w	r3, fp, fp, lsl #3
   11426:	eb0a 0343 	add.w	r3, sl, r3, lsl #1
   1142a:	f8b3 30c8 	ldrh.w	r3, [r3, #200]	; 0xc8
   1142e:	42a3      	cmp	r3, r4
   11430:	bf98      	it	ls
   11432:	2400      	movls	r4, #0
        pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail = tailIndex;
   11434:	9b01      	ldr	r3, [sp, #4]
   11436:	f8a3 40b4 	strh.w	r4, [r3, #180]	; 0xb4
    while((tailIndex != headIndex) &&
   1143a:	4544      	cmp	r4, r8
   1143c:	d051      	beq.n	114e2 <DRV_PIC32CGMAC_LibTxAckPacket+0x156>
          ((pTxDesc[tailIndex].tx_desc_status.val) & GMAC_TX_USED_BIT) &&
   1143e:	00e2      	lsls	r2, r4, #3
   11440:	18b3      	adds	r3, r6, r2
   11442:	6859      	ldr	r1, [r3, #4]
    while((tailIndex != headIndex) &&
   11444:	2900      	cmp	r1, #0
   11446:	da4e      	bge.n	114e6 <DRV_PIC32CGMAC_LibTxAckPacket+0x15a>
          (pTxDesc[tailIndex].tx_desc_buffaddr != 0))
   11448:	f856 1034 	ldr.w	r1, [r6, r4, lsl #3]
          ((pTxDesc[tailIndex].tx_desc_status.val) & GMAC_TX_USED_BIT) &&
   1144c:	2900      	cmp	r1, #0
   1144e:	d03e      	beq.n	114ce <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
        if(GMAC_TX_ERR_BITS & (pTxDesc[tailIndex].tx_desc_status.val) )
   11450:	685b      	ldr	r3, [r3, #4]
   11452:	f013 5f60 	tst.w	r3, #939524096	; 0x38000000
   11456:	d1c9      	bne.n	113ec <DRV_PIC32CGMAC_LibTxAckPacket+0x60>
        pbuff = (uint8_t*)((uint32_t)pTxDesc[tailIndex].tx_desc_buffaddr & pMACDrv->sGmacData._dataOffsetMask);
   11458:	58b3      	ldr	r3, [r6, r2]
   1145a:	f8da 20f0 	ldr.w	r2, [sl, #240]	; 0xf0
   1145e:	4013      	ands	r3, r2
        TCPIP_MAC_SEGMENT_GAP_DCPT* pGap = (TCPIP_MAC_SEGMENT_GAP_DCPT*)(pbuff + pMACDrv->sGmacData._dcptOffset);
   11460:	f9ba 20ec 	ldrsh.w	r2, [sl, #236]	; 0xec
        pPkt = pGap->segmentPktPtr;
   11464:	5898      	ldr	r0, [r3, r2]
            GCIRC_INC(tailIndex, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt);  
   11466:	4639      	mov	r1, r7
            pTxDesc[tailIndex].tx_desc_status.val |= GMAC_TX_USED_BIT;
   11468:	eb06 05c4 	add.w	r5, r6, r4, lsl #3
   1146c:	686b      	ldr	r3, [r5, #4]
   1146e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   11472:	606b      	str	r3, [r5, #4]
            pTxDesc[tailIndex].tx_desc_status.val &= GMAC_TX_USED_BIT | GMAC_TX_WRAP_BIT | GMAC_TX_LAST_BUFFER_BIT;
   11474:	686b      	ldr	r3, [r5, #4]
   11476:	ea03 0309 	and.w	r3, r3, r9
   1147a:	606b      	str	r3, [r5, #4]
            pTxDesc[tailIndex].tx_desc_buffaddr = 0;
   1147c:	f846 7034 	str.w	r7, [r6, r4, lsl #3]
            if(GMAC_TX_LAST_BUFFER_BIT & (pTxDesc[tailIndex].tx_desc_status.val) )
   11480:	686b      	ldr	r3, [r5, #4]
   11482:	f413 4f00 	tst.w	r3, #32768	; 0x8000
   11486:	d1b7      	bne.n	113f8 <DRV_PIC32CGMAC_LibTxAckPacket+0x6c>
            GCIRC_INC(tailIndex, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt);  
   11488:	eb0b 02cb 	add.w	r2, fp, fp, lsl #3
   1148c:	eb0a 0242 	add.w	r2, sl, r2, lsl #1
   11490:	3401      	adds	r4, #1
   11492:	b2a4      	uxth	r4, r4
   11494:	f8b2 30c8 	ldrh.w	r3, [r2, #200]	; 0xc8
   11498:	42a3      	cmp	r3, r4
   1149a:	bf98      	it	ls
   1149c:	2400      	movls	r4, #0
        while(tailIndex != headIndex)
   1149e:	4544      	cmp	r4, r8
   114a0:	d010      	beq.n	114c4 <DRV_PIC32CGMAC_LibTxAckPacket+0x138>
            pTxDesc[tailIndex].tx_desc_status.val |= GMAC_TX_USED_BIT;
   114a2:	eb06 05c4 	add.w	r5, r6, r4, lsl #3
   114a6:	686b      	ldr	r3, [r5, #4]
   114a8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   114ac:	606b      	str	r3, [r5, #4]
            pTxDesc[tailIndex].tx_desc_status.val &= GMAC_TX_USED_BIT | GMAC_TX_WRAP_BIT | GMAC_TX_LAST_BUFFER_BIT;
   114ae:	686b      	ldr	r3, [r5, #4]
   114b0:	ea03 0309 	and.w	r3, r3, r9
   114b4:	606b      	str	r3, [r5, #4]
            pTxDesc[tailIndex].tx_desc_buffaddr = 0;
   114b6:	f846 7034 	str.w	r7, [r6, r4, lsl #3]
            if(GMAC_TX_LAST_BUFFER_BIT & (pTxDesc[tailIndex].tx_desc_status.val) )
   114ba:	686b      	ldr	r3, [r5, #4]
   114bc:	f413 4f00 	tst.w	r3, #32768	; 0x8000
   114c0:	d0e6      	beq.n	11490 <DRV_PIC32CGMAC_LibTxAckPacket+0x104>
   114c2:	e799      	b.n	113f8 <DRV_PIC32CGMAC_LibTxAckPacket+0x6c>
        pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail = tailIndex;
   114c4:	232c      	movs	r3, #44	; 0x2c
   114c6:	fb03 aa0b 	mla	sl, r3, fp, sl
   114ca:	f8aa 80b4 	strh.w	r8, [sl, #180]	; 0xb4
} //DRV_PIC32CGMAC_LibTxAckPacket
   114ce:	4608      	mov	r0, r1
   114d0:	b003      	add	sp, #12
   114d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	DRV_PIC32CGMAC_RESULT res = DRV_PIC32CGMAC_RES_NO_PACKET;
   114d6:	2101      	movs	r1, #1
   114d8:	e7f9      	b.n	114ce <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
   114da:	2101      	movs	r1, #1
   114dc:	e7f7      	b.n	114ce <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
   114de:	2101      	movs	r1, #1
   114e0:	e7f5      	b.n	114ce <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
   114e2:	2100      	movs	r1, #0
   114e4:	e7f3      	b.n	114ce <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
   114e6:	2100      	movs	r1, #0
	return res;	
   114e8:	e7f1      	b.n	114ce <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
   114ea:	bf00      	nop
   114ec:	c0008000 	.word	0xc0008000

Disassembly of section .text._Command_NetworkOnOff%251:

000114f0 <_Command_NetworkOnOff>:
{
   114f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   114f4:	b094      	sub	sp, #80	; 0x50
   114f6:	4604      	mov	r4, r0
    TCPIP_STACK_INIT    tcpip_init_data = {{0}};
   114f8:	2300      	movs	r3, #0
   114fa:	9300      	str	r3, [sp, #0]
   114fc:	9301      	str	r3, [sp, #4]
   114fe:	9302      	str	r3, [sp, #8]
   11500:	9303      	str	r3, [sp, #12]
   11502:	9304      	str	r3, [sp, #16]
   11504:	9305      	str	r3, [sp, #20]
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   11506:	6845      	ldr	r5, [r0, #4]
    if (argc != 3)
   11508:	2903      	cmp	r1, #3
   1150a:	d010      	beq.n	1152e <_Command_NetworkOnOff+0x3e>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: if <interface> <down/up> \r\n");
   1150c:	4e46      	ldr	r6, [pc, #280]	; (11628 <_Command_NetworkOnOff+0x138>)
   1150e:	6803      	ldr	r3, [r0, #0]
   11510:	681b      	ldr	r3, [r3, #0]
   11512:	f506 612e 	add.w	r1, r6, #2784	; 0xae0
   11516:	4628      	mov	r0, r5
   11518:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: if PIC32INT down \r\n");
   1151a:	6823      	ldr	r3, [r4, #0]
   1151c:	681b      	ldr	r3, [r3, #0]
   1151e:	f606 3104 	addw	r1, r6, #2820	; 0xb04
   11522:	4628      	mov	r0, r5
   11524:	4798      	blx	r3
        return false;
   11526:	2000      	movs	r0, #0
}
   11528:	b014      	add	sp, #80	; 0x50
   1152a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1152e:	4616      	mov	r6, r2
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
   11530:	6850      	ldr	r0, [r2, #4]
   11532:	f00c fb3f 	bl	1dbb4 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
   11536:	4607      	mov	r7, r0
   11538:	b1b8      	cbz	r0, 1156a <_Command_NetworkOnOff+0x7a>
    net_ix = TCPIP_STACK_NetIndexGet(netH);
   1153a:	f010 fbec 	bl	21d16 <TCPIP_STACK_NetIndexGet>
   1153e:	4680      	mov	r8, r0
    if (memcmp(argv[2], "up", 2) == 0)
   11540:	68b6      	ldr	r6, [r6, #8]
   11542:	2202      	movs	r2, #2
   11544:	4939      	ldr	r1, [pc, #228]	; (1162c <_Command_NetworkOnOff+0x13c>)
   11546:	4630      	mov	r0, r6
   11548:	f00f fe0c 	bl	21164 <memcmp>
   1154c:	b1a0      	cbz	r0, 11578 <_Command_NetworkOnOff+0x88>
    else if (memcmp(argv[2], "down", 4) == 0)
   1154e:	2204      	movs	r2, #4
   11550:	4937      	ldr	r1, [pc, #220]	; (11630 <_Command_NetworkOnOff+0x140>)
   11552:	4630      	mov	r0, r6
   11554:	f00f fe06 	bl	21164 <memcmp>
   11558:	2800      	cmp	r0, #0
   1155a:	d048      	beq.n	115ee <_Command_NetworkOnOff+0xfe>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Wrong parameter specified \r\n");
   1155c:	6823      	ldr	r3, [r4, #0]
   1155e:	681b      	ldr	r3, [r3, #0]
   11560:	4934      	ldr	r1, [pc, #208]	; (11634 <_Command_NetworkOnOff+0x144>)
   11562:	4628      	mov	r0, r5
   11564:	4798      	blx	r3
        return false;
   11566:	2000      	movs	r0, #0
   11568:	e7de      	b.n	11528 <_Command_NetworkOnOff+0x38>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   1156a:	6823      	ldr	r3, [r4, #0]
   1156c:	681b      	ldr	r3, [r3, #0]
   1156e:	4932      	ldr	r1, [pc, #200]	; (11638 <_Command_NetworkOnOff+0x148>)
   11570:	4628      	mov	r0, r5
   11572:	4798      	blx	r3
        return false;
   11574:	2000      	movs	r0, #0
   11576:	e7d7      	b.n	11528 <_Command_NetworkOnOff+0x38>
        if(TCPIP_STACK_NetIsUp(netH))
   11578:	4638      	mov	r0, r7
   1157a:	f00f fd2f 	bl	20fdc <TCPIP_STACK_NetIsUp>
   1157e:	b130      	cbz	r0, 1158e <_Command_NetworkOnOff+0x9e>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "This interface already up\r\n");
   11580:	6823      	ldr	r3, [r4, #0]
   11582:	681b      	ldr	r3, [r3, #0]
   11584:	492d      	ldr	r1, [pc, #180]	; (1163c <_Command_NetworkOnOff+0x14c>)
   11586:	4628      	mov	r0, r5
   11588:	4798      	blx	r3
            return true;
   1158a:	2001      	movs	r0, #1
   1158c:	e7cc      	b.n	11528 <_Command_NetworkOnOff+0x38>
        tcpipStackObj = TCPIP_STACK_Initialize(0, 0);
   1158e:	2100      	movs	r1, #0
   11590:	4608      	mov	r0, r1
   11592:	f007 fa91 	bl	18ab8 <TCPIP_STACK_Initialize>
        TCPIP_STACK_InitializeDataGet(tcpipStackObj, &tcpip_init_data);
   11596:	4669      	mov	r1, sp
   11598:	f00d fe96 	bl	1f2c8 <TCPIP_STACK_InitializeDataGet>
        if(tcpip_init_data.pNetConf == 0)
   1159c:	9e01      	ldr	r6, [sp, #4]
   1159e:	b1fe      	cbz	r6, 115e0 <_Command_NetworkOnOff+0xf0>
        memcpy(pIfConf, tcpip_init_data.pNetConf + net_ix, sizeof(*pIfConf));
   115a0:	fa1f f888 	uxth.w	r8, r8
   115a4:	ebc8 08c8 	rsb	r8, r8, r8, lsl #3
   115a8:	eb06 06c8 	add.w	r6, r6, r8, lsl #3
   115ac:	f10d 0e18 	add.w	lr, sp, #24
   115b0:	f106 0830 	add.w	r8, r6, #48	; 0x30
   115b4:	46f4      	mov	ip, lr
   115b6:	6830      	ldr	r0, [r6, #0]
   115b8:	6871      	ldr	r1, [r6, #4]
   115ba:	68b2      	ldr	r2, [r6, #8]
   115bc:	68f3      	ldr	r3, [r6, #12]
   115be:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   115c2:	3610      	adds	r6, #16
   115c4:	46e6      	mov	lr, ip
   115c6:	4546      	cmp	r6, r8
   115c8:	d1f4      	bne.n	115b4 <_Command_NetworkOnOff+0xc4>
   115ca:	6830      	ldr	r0, [r6, #0]
   115cc:	6871      	ldr	r1, [r6, #4]
   115ce:	e8ae 0003 	stmia.w	lr!, {r0, r1}
        pIfConf->powerMode = TCPIP_STACK_IF_POWER_FULL;
   115d2:	4b1b      	ldr	r3, [pc, #108]	; (11640 <_Command_NetworkOnOff+0x150>)
   115d4:	930e      	str	r3, [sp, #56]	; 0x38
        res = TCPIP_STACK_NetUp(netH, pIfConf);
   115d6:	a906      	add	r1, sp, #24
   115d8:	4638      	mov	r0, r7
   115da:	f005 fc2b 	bl	16e34 <TCPIP_STACK_NetUp>
   115de:	e014      	b.n	1160a <_Command_NetworkOnOff+0x11a>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Operation failed. No configuration\r\n");
   115e0:	6823      	ldr	r3, [r4, #0]
   115e2:	681b      	ldr	r3, [r3, #0]
   115e4:	4917      	ldr	r1, [pc, #92]	; (11644 <_Command_NetworkOnOff+0x154>)
   115e6:	4628      	mov	r0, r5
   115e8:	4798      	blx	r3
            return true;
   115ea:	2001      	movs	r0, #1
   115ec:	e79c      	b.n	11528 <_Command_NetworkOnOff+0x38>
        if(TCPIP_STACK_NetIsUp(netH) == 0)
   115ee:	4638      	mov	r0, r7
   115f0:	f00f fcf4 	bl	20fdc <TCPIP_STACK_NetIsUp>
   115f4:	b930      	cbnz	r0, 11604 <_Command_NetworkOnOff+0x114>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "This interface already down\r\n");
   115f6:	6823      	ldr	r3, [r4, #0]
   115f8:	681b      	ldr	r3, [r3, #0]
   115fa:	4913      	ldr	r1, [pc, #76]	; (11648 <_Command_NetworkOnOff+0x158>)
   115fc:	4628      	mov	r0, r5
   115fe:	4798      	blx	r3
            return true;
   11600:	2001      	movs	r0, #1
   11602:	e791      	b.n	11528 <_Command_NetworkOnOff+0x38>
        res = TCPIP_STACK_NetDown(netH);
   11604:	4638      	mov	r0, r7
   11606:	f00d fabf 	bl	1eb88 <TCPIP_STACK_NetDown>
    if (res == true)
   1160a:	b130      	cbz	r0, 1161a <_Command_NetworkOnOff+0x12a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Operation successful!\r\n");
   1160c:	6823      	ldr	r3, [r4, #0]
   1160e:	681b      	ldr	r3, [r3, #0]
   11610:	490e      	ldr	r1, [pc, #56]	; (1164c <_Command_NetworkOnOff+0x15c>)
   11612:	4628      	mov	r0, r5
   11614:	4798      	blx	r3
    return true;
   11616:	2001      	movs	r0, #1
   11618:	e786      	b.n	11528 <_Command_NetworkOnOff+0x38>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Operation failed!\r\n");
   1161a:	6823      	ldr	r3, [r4, #0]
   1161c:	681b      	ldr	r3, [r3, #0]
   1161e:	490c      	ldr	r1, [pc, #48]	; (11650 <_Command_NetworkOnOff+0x160>)
   11620:	4628      	mov	r0, r5
   11622:	4798      	blx	r3
    return true;
   11624:	2001      	movs	r0, #1
   11626:	e77f      	b.n	11528 <_Command_NetworkOnOff+0x38>
   11628:	0000028c 	.word	0x0000028c
   1162c:	00000cc0 	.word	0x00000cc0
   11630:	00000d24 	.word	0x00000d24
   11634:	00000e34 	.word	0x00000e34
   11638:	00000da8 	.word	0x00000da8
   1163c:	00000dc8 	.word	0x00000dc8
   11640:	00000e0c 	.word	0x00000e0c
   11644:	00000de4 	.word	0x00000de4
   11648:	00000e14 	.word	0x00000e14
   1164c:	00000e54 	.word	0x00000e54
   11650:	00000e6c 	.word	0x00000e6c

Disassembly of section .text.CommandHelp%252:

00011654 <CommandHelp>:
{
   11654:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   11658:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   1165a:	6845      	ldr	r5, [r0, #4]
    if(argc == 1)
   1165c:	2901      	cmp	r1, #1
   1165e:	d004      	beq.n	1166a <CommandHelp+0x16>
   11660:	4691      	mov	r9, r2
        pTbl = _usrCmdTbl;
   11662:	4e4f      	ldr	r6, [pc, #316]	; (117a0 <CommandHelp+0x14c>)
        for (groupIx=0; groupIx < MAX_CMD_GROUP; groupIx++)
   11664:	f106 0780 	add.w	r7, r6, #128	; 0x80
   11668:	e05c      	b.n	11724 <CommandHelp+0xd0>
        bool hadHeader = false;
   1166a:	2200      	movs	r2, #0
        pTbl = _usrCmdTbl;
   1166c:	4e4c      	ldr	r6, [pc, #304]	; (117a0 <CommandHelp+0x14c>)
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** ");
   1166e:	4f4d      	ldr	r7, [pc, #308]	; (117a4 <CommandHelp+0x150>)
   11670:	f107 0938 	add.w	r9, r7, #56	; 0x38
        for (groupIx=0; groupIx < MAX_CMD_GROUP; groupIx++)
   11674:	f106 0880 	add.w	r8, r6, #128	; 0x80
   11678:	e018      	b.n	116ac <CommandHelp+0x58>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** ");
   1167a:	6823      	ldr	r3, [r4, #0]
   1167c:	681b      	ldr	r3, [r3, #0]
   1167e:	4649      	mov	r1, r9
   11680:	4628      	mov	r0, r5
   11682:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, pTbl->cmdGroupName);
   11684:	6823      	ldr	r3, [r4, #0]
   11686:	681b      	ldr	r3, [r3, #0]
   11688:	68b1      	ldr	r1, [r6, #8]
   1168a:	4628      	mov	r0, r5
   1168c:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, pTbl->cmdMenuStr);
   1168e:	6823      	ldr	r3, [r4, #0]
   11690:	681b      	ldr	r3, [r3, #0]
   11692:	68f1      	ldr	r1, [r6, #12]
   11694:	4628      	mov	r0, r5
   11696:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, " ***");
   11698:	6823      	ldr	r3, [r4, #0]
   1169a:	681b      	ldr	r3, [r3, #0]
   1169c:	f107 0140 	add.w	r1, r7, #64	; 0x40
   116a0:	4628      	mov	r0, r5
   116a2:	4798      	blx	r3
   116a4:	2201      	movs	r2, #1
            pTbl++;
   116a6:	3610      	adds	r6, #16
        for (groupIx=0; groupIx < MAX_CMD_GROUP; groupIx++)
   116a8:	4546      	cmp	r6, r8
   116aa:	d00b      	beq.n	116c4 <CommandHelp+0x70>
            if (pTbl->pCmd)
   116ac:	6873      	ldr	r3, [r6, #4]
   116ae:	2b00      	cmp	r3, #0
   116b0:	d0f9      	beq.n	116a6 <CommandHelp+0x52>
                if(!hadHeader)
   116b2:	2a00      	cmp	r2, #0
   116b4:	d1e1      	bne.n	1167a <CommandHelp+0x26>
                    (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM "------- Supported command groups ------");
   116b6:	6823      	ldr	r3, [r4, #0]
   116b8:	681b      	ldr	r3, [r3, #0]
   116ba:	f107 010c 	add.w	r1, r7, #12
   116be:	4628      	mov	r0, r5
   116c0:	4798      	blx	r3
                    hadHeader = true;
   116c2:	e7da      	b.n	1167a <CommandHelp+0x26>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM "---------- Built in commands ----------");
   116c4:	6823      	ldr	r3, [r4, #0]
   116c6:	681b      	ldr	r3, [r3, #0]
   116c8:	4937      	ldr	r1, [pc, #220]	; (117a8 <CommandHelp+0x154>)
   116ca:	4628      	mov	r0, r5
   116cc:	4798      	blx	r3
        for(ix = 0, pDcpt = _builtinCmdTbl; ix < sizeof(_builtinCmdTbl)/sizeof(*_builtinCmdTbl); ix++, pDcpt++)
   116ce:	4b37      	ldr	r3, [pc, #220]	; (117ac <CommandHelp+0x158>)
   116d0:	f103 060c 	add.w	r6, r3, #12
   116d4:	f103 0830 	add.w	r8, r3, #48	; 0x30
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** ");
   116d8:	4f32      	ldr	r7, [pc, #200]	; (117a4 <CommandHelp+0x150>)
   116da:	f107 0938 	add.w	r9, r7, #56	; 0x38
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, " ***");
   116de:	3740      	adds	r7, #64	; 0x40
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** ");
   116e0:	6823      	ldr	r3, [r4, #0]
   116e2:	681b      	ldr	r3, [r3, #0]
   116e4:	4649      	mov	r1, r9
   116e6:	4628      	mov	r0, r5
   116e8:	4798      	blx	r3
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, pDcpt->cmdStr);
   116ea:	6823      	ldr	r3, [r4, #0]
   116ec:	681b      	ldr	r3, [r3, #0]
   116ee:	f856 1c0c 	ldr.w	r1, [r6, #-12]
   116f2:	4628      	mov	r0, r5
   116f4:	4798      	blx	r3
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, pDcpt->cmdDescr);
   116f6:	6823      	ldr	r3, [r4, #0]
   116f8:	681b      	ldr	r3, [r3, #0]
   116fa:	f856 1c04 	ldr.w	r1, [r6, #-4]
   116fe:	4628      	mov	r0, r5
   11700:	4798      	blx	r3
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, " ***");
   11702:	6823      	ldr	r3, [r4, #0]
   11704:	681b      	ldr	r3, [r3, #0]
   11706:	4639      	mov	r1, r7
   11708:	4628      	mov	r0, r5
   1170a:	4798      	blx	r3
   1170c:	360c      	adds	r6, #12
        for(ix = 0, pDcpt = _builtinCmdTbl; ix < sizeof(_builtinCmdTbl)/sizeof(*_builtinCmdTbl); ix++, pDcpt++)
   1170e:	45b0      	cmp	r8, r6
   11710:	d1e6      	bne.n	116e0 <CommandHelp+0x8c>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM);
   11712:	6823      	ldr	r3, [r4, #0]
   11714:	681b      	ldr	r3, [r3, #0]
   11716:	4926      	ldr	r1, [pc, #152]	; (117b0 <CommandHelp+0x15c>)
   11718:	4628      	mov	r0, r5
   1171a:	4798      	blx	r3
   1171c:	e038      	b.n	11790 <CommandHelp+0x13c>
            pTbl++;
   1171e:	3610      	adds	r6, #16
        for (groupIx=0; groupIx < MAX_CMD_GROUP; groupIx++)
   11720:	42be      	cmp	r6, r7
   11722:	d037      	beq.n	11794 <CommandHelp+0x140>
            if (pTbl->pCmd)
   11724:	6873      	ldr	r3, [r6, #4]
   11726:	2b00      	cmp	r3, #0
   11728:	d0f9      	beq.n	1171e <CommandHelp+0xca>
                if(strcmp(pTbl->cmdGroupName, argv[1]) == 0)
   1172a:	f8d9 1004 	ldr.w	r1, [r9, #4]
   1172e:	68b0      	ldr	r0, [r6, #8]
   11730:	f010 f974 	bl	21a1c <strcmp>
   11734:	4680      	mov	r8, r0
   11736:	2800      	cmp	r0, #0
   11738:	d1f1      	bne.n	1171e <CommandHelp+0xca>
            for(ix = 0, pDcpt = pDTbl->pCmd; ix < pDTbl->nCmds; ix++, pDcpt++)
   1173a:	6877      	ldr	r7, [r6, #4]
   1173c:	6833      	ldr	r3, [r6, #0]
   1173e:	2b00      	cmp	r3, #0
   11740:	dd21      	ble.n	11786 <CommandHelp+0x132>
   11742:	370c      	adds	r7, #12
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** ");
   11744:	4b17      	ldr	r3, [pc, #92]	; (117a4 <CommandHelp+0x150>)
   11746:	f103 0a38 	add.w	sl, r3, #56	; 0x38
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, " ***");
   1174a:	f103 0940 	add.w	r9, r3, #64	; 0x40
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** ");
   1174e:	6823      	ldr	r3, [r4, #0]
   11750:	681b      	ldr	r3, [r3, #0]
   11752:	4651      	mov	r1, sl
   11754:	4628      	mov	r0, r5
   11756:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, pDcpt->cmdStr);
   11758:	6823      	ldr	r3, [r4, #0]
   1175a:	681b      	ldr	r3, [r3, #0]
   1175c:	f857 1c0c 	ldr.w	r1, [r7, #-12]
   11760:	4628      	mov	r0, r5
   11762:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, pDcpt->cmdDescr);
   11764:	6823      	ldr	r3, [r4, #0]
   11766:	681b      	ldr	r3, [r3, #0]
   11768:	f857 1c04 	ldr.w	r1, [r7, #-4]
   1176c:	4628      	mov	r0, r5
   1176e:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, " ***");
   11770:	6823      	ldr	r3, [r4, #0]
   11772:	681b      	ldr	r3, [r3, #0]
   11774:	4649      	mov	r1, r9
   11776:	4628      	mov	r0, r5
   11778:	4798      	blx	r3
            for(ix = 0, pDcpt = pDTbl->pCmd; ix < pDTbl->nCmds; ix++, pDcpt++)
   1177a:	f108 0801 	add.w	r8, r8, #1
   1177e:	370c      	adds	r7, #12
   11780:	6833      	ldr	r3, [r6, #0]
   11782:	4543      	cmp	r3, r8
   11784:	dce3      	bgt.n	1174e <CommandHelp+0xfa>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM);
   11786:	6823      	ldr	r3, [r4, #0]
   11788:	681b      	ldr	r3, [r3, #0]
   1178a:	4909      	ldr	r1, [pc, #36]	; (117b0 <CommandHelp+0x15c>)
   1178c:	4628      	mov	r0, r5
   1178e:	4798      	blx	r3
}
   11790:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM "Unknown command group. Try help" LINE_TERM );
   11794:	6823      	ldr	r3, [r4, #0]
   11796:	681b      	ldr	r3, [r3, #0]
   11798:	4906      	ldr	r1, [pc, #24]	; (117b4 <CommandHelp+0x160>)
   1179a:	4628      	mov	r0, r5
   1179c:	4798      	blx	r3
   1179e:	e7f7      	b.n	11790 <CommandHelp+0x13c>
   117a0:	2000dd98 	.word	0x2000dd98
   117a4:	0000d0e8 	.word	0x0000d0e8
   117a8:	0000d130 	.word	0x0000d130
   117ac:	0002055c 	.word	0x0002055c
   117b0:	0000d15c 	.word	0x0000d15c
   117b4:	0000d160 	.word	0x0000d160

Disassembly of section .text._UDPOpen%253:

000117b8 <_UDPOpen>:
{
   117b8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   117bc:	4699      	mov	r9, r3
    if(UDPSocketDcpt == 0)
   117be:	4b50      	ldr	r3, [pc, #320]	; (11900 <_UDPOpen+0x148>)
   117c0:	681b      	ldr	r3, [r3, #0]
   117c2:	2b00      	cmp	r3, #0
   117c4:	f000 808a 	beq.w	118dc <_UDPOpen+0x124>
   117c8:	4606      	mov	r6, r0
   117ca:	460d      	mov	r5, r1
   117cc:	4617      	mov	r7, r2
    if((opType & UDP_OPEN_CLIENT) != 0)
   117ce:	f011 0802 	ands.w	r8, r1, #2
   117d2:	f040 8088 	bne.w	118e6 <_UDPOpen+0x12e>
    OSAL_SEM_Pend(&userSem, OSAL_WAIT_FOREVER);
   117d6:	f64f 71ff 	movw	r1, #65535	; 0xffff
   117da:	484a      	ldr	r0, [pc, #296]	; (11904 <_UDPOpen+0x14c>)
   117dc:	f00f fae2 	bl	20da4 <OSAL_SEM_Pend>
        if(localPort == 0)
   117e0:	2f00      	cmp	r7, #0
   117e2:	f000 8085 	beq.w	118f0 <_UDPOpen+0x138>
        for ( sktIx = 0; sktIx < nUdpSockets; sktIx++ )
   117e6:	4b48      	ldr	r3, [pc, #288]	; (11908 <_UDPOpen+0x150>)
   117e8:	6819      	ldr	r1, [r3, #0]
   117ea:	2900      	cmp	r1, #0
   117ec:	dd59      	ble.n	118a2 <_UDPOpen+0xea>
            pSkt = UDPSocketDcpt[sktIx];
   117ee:	4b44      	ldr	r3, [pc, #272]	; (11900 <_UDPOpen+0x148>)
   117f0:	681b      	ldr	r3, [r3, #0]
   117f2:	681a      	ldr	r2, [r3, #0]
            if(pSkt == 0)
   117f4:	2a00      	cmp	r2, #0
   117f6:	d074      	beq.n	118e2 <_UDPOpen+0x12a>
        for ( sktIx = 0; sktIx < nUdpSockets; sktIx++ )
   117f8:	2400      	movs	r4, #0
   117fa:	3401      	adds	r4, #1
   117fc:	428c      	cmp	r4, r1
   117fe:	d04f      	beq.n	118a0 <_UDPOpen+0xe8>
            pSkt = UDPSocketDcpt[sktIx];
   11800:	f853 2f04 	ldr.w	r2, [r3, #4]!
            if(pSkt == 0)
   11804:	2a00      	cmp	r2, #0
   11806:	d1f8      	bne.n	117fa <_UDPOpen+0x42>
        pSkt = (UDP_SOCKET_DCPT*)TCPIP_HEAP_Calloc(udpMemH, 1, sizeof(*pSkt));
   11808:	4b40      	ldr	r3, [pc, #256]	; (1190c <_UDPOpen+0x154>)
   1180a:	6818      	ldr	r0, [r3, #0]
   1180c:	6883      	ldr	r3, [r0, #8]
   1180e:	225c      	movs	r2, #92	; 0x5c
   11810:	2101      	movs	r1, #1
   11812:	4798      	blx	r3
    if(newSktValid)
   11814:	4682      	mov	sl, r0
   11816:	2800      	cmp	r0, #0
   11818:	d043      	beq.n	118a2 <_UDPOpen+0xea>
        pSkt->sktIx = sktIx;
   1181a:	fa0f fb84 	sxth.w	fp, r4
   1181e:	f8a0 b012 	strh.w	fp, [r0, #18]
        UDPSocketDcpt[sktIx] = pSkt;
   11822:	4b37      	ldr	r3, [pc, #220]	; (11900 <_UDPOpen+0x148>)
   11824:	681b      	ldr	r3, [r3, #0]
   11826:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
    OSAL_SEM_Post(&userSem);
   1182a:	4836      	ldr	r0, [pc, #216]	; (11904 <_UDPOpen+0x14c>)
   1182c:	f00f fed2 	bl	215d4 <OSAL_SEM_Post>
    pSkt->localPort = localPort;	
   11830:	f8aa 702a 	strh.w	r7, [sl, #42]	; 0x2a
    pSkt->remotePort = remotePort;
   11834:	f8aa 8028 	strh.w	r8, [sl, #40]	; 0x28
    pSkt->addType = addType;
   11838:	f8aa 603c 	strh.w	r6, [sl, #60]	; 0x3c
    pSkt->txAllocLimit = TCPIP_UDP_SOCKET_DEFAULT_TX_QUEUE_LIMIT; 
   1183c:	2303      	movs	r3, #3
   1183e:	f88a 303e 	strb.w	r3, [sl, #62]	; 0x3e
    pSkt->rxQueueLimit = TCPIP_UDP_SOCKET_DEFAULT_RX_QUEUE_LIMIT;
   11842:	f88a 305a 	strb.w	r3, [sl, #90]	; 0x5a
    pSkt->flags.openAddType = addType;
   11846:	f89a 3041 	ldrb.w	r3, [sl, #65]	; 0x41
   1184a:	f366 1305 	bfi	r3, r6, #4, #2
   1184e:	f88a 3041 	strb.w	r3, [sl, #65]	; 0x41
    if((opType & UDP_OPEN_TX_SPLIT) != 0)
   11852:	f015 0f80 	tst.w	r5, #128	; 0x80
   11856:	d02c      	beq.n	118b2 <_UDPOpen+0xfa>
        pSkt->txSize = 0;
   11858:	2300      	movs	r3, #0
   1185a:	f8aa 3010 	strh.w	r3, [sl, #16]
        pSkt->flags.txSplitAlloc = 1;
   1185e:	f89a 3041 	ldrb.w	r3, [sl, #65]	; 0x41
   11862:	f043 0302 	orr.w	r3, r3, #2
   11866:	f88a 3041 	strb.w	r3, [sl, #65]	; 0x41
    if((opType & UDP_OPEN_CONFIG_SERVICE) != 0)
   1186a:	f415 7f80 	tst.w	r5, #256	; 0x100
   1186e:	d005      	beq.n	1187c <_UDPOpen+0xc4>
        pSkt->flags.stackConfig = 1;
   11870:	f89a 3041 	ldrb.w	r3, [sl, #65]	; 0x41
   11874:	f043 0308 	orr.w	r3, r3, #8
   11878:	f88a 3041 	strb.w	r3, [sl, #65]	; 0x41
    if((opType & UDP_OPEN_SERVER) != 0)
   1187c:	f015 0f01 	tst.w	r5, #1
   11880:	d01c      	beq.n	118bc <_UDPOpen+0x104>
        pSkt->flags.looseRemPort = pSkt->flags.looseNetIf = pSkt->flags.looseRemAddress = 1; 
   11882:	f89a 3040 	ldrb.w	r3, [sl, #64]	; 0x40
   11886:	f043 031c 	orr.w	r3, r3, #28
   1188a:	f88a 3040 	strb.w	r3, [sl, #64]	; 0x40
        pSkt->extFlags.serverSkt = 1;
   1188e:	f89a 3042 	ldrb.w	r3, [sl, #66]	; 0x42
   11892:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   11896:	f88a 3042 	strb.w	r3, [sl, #66]	; 0x42
}
   1189a:	4658      	mov	r0, fp
   1189c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(pSkt != 0)
   118a0:	b12a      	cbz	r2, 118ae <_UDPOpen+0xf6>
    OSAL_SEM_Post(&userSem);
   118a2:	4818      	ldr	r0, [pc, #96]	; (11904 <_UDPOpen+0x14c>)
   118a4:	f00f fe96 	bl	215d4 <OSAL_SEM_Post>
        return (UDP_SOCKET)INVALID_UDP_SOCKET;
   118a8:	f04f 3bff 	mov.w	fp, #4294967295
   118ac:	e7f5      	b.n	1189a <_UDPOpen+0xe2>
        for ( sktIx = 0; sktIx < nUdpSockets; sktIx++ )
   118ae:	460c      	mov	r4, r1
   118b0:	e7aa      	b.n	11808 <_UDPOpen+0x50>
        pSkt->txSize = udpDefTxSize;
   118b2:	4b17      	ldr	r3, [pc, #92]	; (11910 <_UDPOpen+0x158>)
   118b4:	881b      	ldrh	r3, [r3, #0]
   118b6:	f8aa 3010 	strh.w	r3, [sl, #16]
   118ba:	e7d6      	b.n	1186a <_UDPOpen+0xb2>
        switch(addType)
   118bc:	2e01      	cmp	r6, #1
   118be:	d1ec      	bne.n	1189a <_UDPOpen+0xe2>
                if(hostAddress)
   118c0:	f1b9 0f00 	cmp.w	r9, #0
   118c4:	d0e9      	beq.n	1189a <_UDPOpen+0xe2>
                    pSkt->destAddress.Val = hostAddress->v4Add.Val;
   118c6:	f8d9 3000 	ldr.w	r3, [r9]
   118ca:	f8ca 3014 	str.w	r3, [sl, #20]
                    pSkt->flags.destSet = 1;
   118ce:	f89a 3041 	ldrb.w	r3, [sl, #65]	; 0x41
   118d2:	f043 0301 	orr.w	r3, r3, #1
   118d6:	f88a 3041 	strb.w	r3, [sl, #65]	; 0x41
    return (UDP_SOCKET)sktIx;
   118da:	e7de      	b.n	1189a <_UDPOpen+0xe2>
        return (UDP_SOCKET)INVALID_UDP_SOCKET;
   118dc:	f04f 3bff 	mov.w	fp, #4294967295
   118e0:	e7db      	b.n	1189a <_UDPOpen+0xe2>
        for ( sktIx = 0; sktIx < nUdpSockets; sktIx++ )
   118e2:	2400      	movs	r4, #0
        if(pSkt != 0)
   118e4:	e790      	b.n	11808 <_UDPOpen+0x50>
    OSAL_SEM_Pend(&userSem, OSAL_WAIT_FOREVER);
   118e6:	f64f 71ff 	movw	r1, #65535	; 0xffff
   118ea:	4806      	ldr	r0, [pc, #24]	; (11904 <_UDPOpen+0x14c>)
   118ec:	f00f fa5a 	bl	20da4 <OSAL_SEM_Pend>
            localPort = _UDPAllocateEphemeralPort();
   118f0:	f00c ff80 	bl	1e7f4 <_UDPAllocateEphemeralPort>
            if(localPort == 0)
   118f4:	2800      	cmp	r0, #0
   118f6:	d0d4      	beq.n	118a2 <_UDPOpen+0xea>
   118f8:	46b8      	mov	r8, r7
            localPort = _UDPAllocateEphemeralPort();
   118fa:	4607      	mov	r7, r0
   118fc:	e773      	b.n	117e6 <_UDPOpen+0x2e>
   118fe:	bf00      	nop
   11900:	2000e454 	.word	0x2000e454
   11904:	2000e468 	.word	0x2000e468
   11908:	2000e458 	.word	0x2000e458
   1190c:	2000e464 	.word	0x2000e464
   11910:	2000e508 	.word	0x2000e508

Disassembly of section .text.TCPIP_DNS_EntryQuery%254:

00011914 <TCPIP_DNS_EntryQuery>:
{
   11914:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    pDnsDcpt = pgDnsDcpt;
   11916:	4b53      	ldr	r3, [pc, #332]	; (11a64 <TCPIP_DNS_EntryQuery+0x150>)
   11918:	681e      	ldr	r6, [r3, #0]
    if(pDnsDcpt == 0 || pDnsDcpt->hashDcpt == 0)
   1191a:	2e00      	cmp	r6, #0
   1191c:	f000 808d 	beq.w	11a3a <TCPIP_DNS_EntryQuery+0x126>
   11920:	4604      	mov	r4, r0
   11922:	6830      	ldr	r0, [r6, #0]
   11924:	2800      	cmp	r0, #0
   11926:	f000 808b 	beq.w	11a40 <TCPIP_DNS_EntryQuery+0x12c>
    if(pDnsQuery == 0 || pDnsQuery->hostName == 0 || pDnsQuery->nameLen == 0)
   1192a:	2c00      	cmp	r4, #0
   1192c:	f000 808b 	beq.w	11a46 <TCPIP_DNS_EntryQuery+0x132>
   11930:	6823      	ldr	r3, [r4, #0]
   11932:	2b00      	cmp	r3, #0
   11934:	f000 808a 	beq.w	11a4c <TCPIP_DNS_EntryQuery+0x138>
   11938:	6863      	ldr	r3, [r4, #4]
   1193a:	2b00      	cmp	r3, #0
   1193c:	f000 8089 	beq.w	11a52 <TCPIP_DNS_EntryQuery+0x13e>
    pBkt = TCPIP_OAHASH_EntryGet(pDnsDcpt->hashDcpt, queryIndex);
   11940:	f010 f89b 	bl	21a7a <TCPIP_OAHASH_EntryGet>
    if(pBkt == 0)
   11944:	4605      	mov	r5, r0
   11946:	2800      	cmp	r0, #0
   11948:	f000 8086 	beq.w	11a58 <TCPIP_DNS_EntryQuery+0x144>
    if(pBkt->flags.busy != 0)
   1194c:	7803      	ldrb	r3, [r0, #0]
   1194e:	f013 0f01 	tst.w	r3, #1
   11952:	f000 8084 	beq.w	11a5e <TCPIP_DNS_EntryQuery+0x14a>
        strncpy(pDnsQuery->hostName, pE->pHostName, pDnsQuery->nameLen - 1);
   11956:	6862      	ldr	r2, [r4, #4]
   11958:	3a01      	subs	r2, #1
   1195a:	6a01      	ldr	r1, [r0, #32]
   1195c:	6820      	ldr	r0, [r4, #0]
   1195e:	f00e fd12 	bl	20386 <strncpy>
        pDnsQuery->hostName[pDnsQuery->nameLen - 1] = 0;
   11962:	6823      	ldr	r3, [r4, #0]
   11964:	6862      	ldr	r2, [r4, #4]
   11966:	4413      	add	r3, r2
   11968:	2200      	movs	r2, #0
   1196a:	f803 2c01 	strb.w	r2, [r3, #-1]
        pDnsQuery->hNet = pE->currNet;
   1196e:	69eb      	ldr	r3, [r5, #28]
   11970:	6223      	str	r3, [r4, #32]
        pDnsQuery->serverIx = pE->currServerIx;
   11972:	f895 3029 	ldrb.w	r3, [r5, #41]	; 0x29
   11976:	6263      	str	r3, [r4, #36]	; 0x24
        if((pBkt->flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) != 0)
   11978:	882b      	ldrh	r3, [r5, #0]
   1197a:	f013 0f80 	tst.w	r3, #128	; 0x80
   1197e:	d04f      	beq.n	11a20 <TCPIP_DNS_EntryQuery+0x10c>
            pDnsQuery->status = TCPIP_DNS_RES_OK;
   11980:	7622      	strb	r2, [r4, #24]
            currTime = pDnsDcpt->dnsTime;
   11982:	69f2      	ldr	r2, [r6, #28]
            if(pDnsDcpt->cacheEntryTMO > 0)
   11984:	6973      	ldr	r3, [r6, #20]
   11986:	2b00      	cmp	r3, #0
   11988:	d03d      	beq.n	11a06 <TCPIP_DNS_EntryQuery+0xf2>
                pDnsQuery->ttlTime = pDnsDcpt->cacheEntryTMO - (currTime - pE->tInsert);
   1198a:	1a9b      	subs	r3, r3, r2
   1198c:	68aa      	ldr	r2, [r5, #8]
   1198e:	4413      	add	r3, r2
   11990:	61e3      	str	r3, [r4, #28]
            for(ix = 0; ix < pE->nIPv4Entries && ix < pDnsQuery->nIPv4Entries; ix++)
   11992:	f895 3026 	ldrb.w	r3, [r5, #38]	; 0x26
   11996:	2b00      	cmp	r3, #0
   11998:	d03a      	beq.n	11a10 <TCPIP_DNS_EntryQuery+0xfc>
   1199a:	68e3      	ldr	r3, [r4, #12]
   1199c:	2b00      	cmp	r3, #0
   1199e:	dd39      	ble.n	11a14 <TCPIP_DNS_EntryQuery+0x100>
   119a0:	2300      	movs	r3, #0
                pDnsQuery->ipv4Entry[ix].Val = pE->pip4Address[ix].Val;
   119a2:	692a      	ldr	r2, [r5, #16]
   119a4:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
   119a8:	68a2      	ldr	r2, [r4, #8]
   119aa:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            for(ix = 0; ix < pE->nIPv4Entries && ix < pDnsQuery->nIPv4Entries; ix++)
   119ae:	3301      	adds	r3, #1
   119b0:	f895 2026 	ldrb.w	r2, [r5, #38]	; 0x26
   119b4:	429a      	cmp	r2, r3
   119b6:	dd02      	ble.n	119be <TCPIP_DNS_EntryQuery+0xaa>
   119b8:	68e2      	ldr	r2, [r4, #12]
   119ba:	429a      	cmp	r2, r3
   119bc:	dcf1      	bgt.n	119a2 <TCPIP_DNS_EntryQuery+0x8e>
            pDnsQuery->nIPv4ValidEntries = ix;
   119be:	62a3      	str	r3, [r4, #40]	; 0x28
            for(ix = 0; ix < pE->nIPv6Entries && ix < pDnsQuery->nIPv6Entries; ix++)
   119c0:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
   119c4:	b343      	cbz	r3, 11a18 <TCPIP_DNS_EntryQuery+0x104>
   119c6:	6963      	ldr	r3, [r4, #20]
   119c8:	2b00      	cmp	r3, #0
   119ca:	dd27      	ble.n	11a1c <TCPIP_DNS_EntryQuery+0x108>
   119cc:	2200      	movs	r2, #0
                memcpy(pDnsQuery->ipv6Entry[ix].v, pE->pip6Address[ix].v, sizeof(IPV6_ADDR));
   119ce:	0110      	lsls	r0, r2, #4
   119d0:	6926      	ldr	r6, [r4, #16]
   119d2:	1831      	adds	r1, r6, r0
   119d4:	696b      	ldr	r3, [r5, #20]
   119d6:	4403      	add	r3, r0
   119d8:	f8d3 e000 	ldr.w	lr, [r3]
   119dc:	f8d3 c004 	ldr.w	ip, [r3, #4]
   119e0:	689f      	ldr	r7, [r3, #8]
   119e2:	68db      	ldr	r3, [r3, #12]
   119e4:	f846 e000 	str.w	lr, [r6, r0]
   119e8:	f8c1 c004 	str.w	ip, [r1, #4]
   119ec:	608f      	str	r7, [r1, #8]
   119ee:	60cb      	str	r3, [r1, #12]
            for(ix = 0; ix < pE->nIPv6Entries && ix < pDnsQuery->nIPv6Entries; ix++)
   119f0:	3201      	adds	r2, #1
   119f2:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
   119f6:	4293      	cmp	r3, r2
   119f8:	dd02      	ble.n	11a00 <TCPIP_DNS_EntryQuery+0xec>
   119fa:	6963      	ldr	r3, [r4, #20]
   119fc:	4293      	cmp	r3, r2
   119fe:	dce6      	bgt.n	119ce <TCPIP_DNS_EntryQuery+0xba>
            pDnsQuery->nIPv6ValidEntries = ix;
   11a00:	62e2      	str	r2, [r4, #44]	; 0x2c
            return TCPIP_DNS_RES_OK;
   11a02:	2000      	movs	r0, #0
   11a04:	e018      	b.n	11a38 <TCPIP_DNS_EntryQuery+0x124>
                pDnsQuery->ttlTime = pE->ipTTL.Val - (currTime - pE->tInsert);
   11a06:	69ab      	ldr	r3, [r5, #24]
   11a08:	68a9      	ldr	r1, [r5, #8]
   11a0a:	440b      	add	r3, r1
   11a0c:	1a9b      	subs	r3, r3, r2
   11a0e:	e7bf      	b.n	11990 <TCPIP_DNS_EntryQuery+0x7c>
            for(ix = 0; ix < pE->nIPv4Entries && ix < pDnsQuery->nIPv4Entries; ix++)
   11a10:	2300      	movs	r3, #0
   11a12:	e7d4      	b.n	119be <TCPIP_DNS_EntryQuery+0xaa>
   11a14:	2300      	movs	r3, #0
   11a16:	e7d2      	b.n	119be <TCPIP_DNS_EntryQuery+0xaa>
            for(ix = 0; ix < pE->nIPv6Entries && ix < pDnsQuery->nIPv6Entries; ix++)
   11a18:	2200      	movs	r2, #0
   11a1a:	e7f1      	b.n	11a00 <TCPIP_DNS_EntryQuery+0xec>
   11a1c:	2200      	movs	r2, #0
   11a1e:	e7ef      	b.n	11a00 <TCPIP_DNS_EntryQuery+0xec>
            pDnsQuery->status = (pE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_TIMEOUT) == 0 ? TCPIP_DNS_RES_PENDING : TCPIP_DNS_RES_SERVER_TMO; 
   11a20:	f403 7380 	and.w	r3, r3, #256	; 0x100
   11a24:	2b00      	cmp	r3, #0
   11a26:	bf0c      	ite	eq
   11a28:	2301      	moveq	r3, #1
   11a2a:	f06f 0304 	mvnne.w	r3, #4
   11a2e:	7623      	strb	r3, [r4, #24]
            pDnsQuery->ttlTime = 0;
   11a30:	2000      	movs	r0, #0
   11a32:	61e0      	str	r0, [r4, #28]
            pDnsQuery->nIPv4ValidEntries = 0;
   11a34:	62a0      	str	r0, [r4, #40]	; 0x28
            pDnsQuery->nIPv6ValidEntries = 0;
   11a36:	62e0      	str	r0, [r4, #44]	; 0x2c
}
   11a38:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return TCPIP_DNS_RES_NO_SERVICE;
   11a3a:	f06f 0005 	mvn.w	r0, #5
   11a3e:	e7fb      	b.n	11a38 <TCPIP_DNS_EntryQuery+0x124>
   11a40:	f06f 0005 	mvn.w	r0, #5
   11a44:	e7f8      	b.n	11a38 <TCPIP_DNS_EntryQuery+0x124>
        return TCPIP_DNS_RES_INVALID_HOSTNAME;
   11a46:	f06f 0008 	mvn.w	r0, #8
   11a4a:	e7f5      	b.n	11a38 <TCPIP_DNS_EntryQuery+0x124>
   11a4c:	f06f 0008 	mvn.w	r0, #8
   11a50:	e7f2      	b.n	11a38 <TCPIP_DNS_EntryQuery+0x124>
   11a52:	f06f 0008 	mvn.w	r0, #8
   11a56:	e7ef      	b.n	11a38 <TCPIP_DNS_EntryQuery+0x124>
        return TCPIP_DNS_RES_NO_IX_ENTRY;
   11a58:	f06f 0002 	mvn.w	r0, #2
   11a5c:	e7ec      	b.n	11a38 <TCPIP_DNS_EntryQuery+0x124>
    return TCPIP_DNS_RES_EMPTY_IX_ENTRY;
   11a5e:	f06f 0003 	mvn.w	r0, #3
   11a62:	e7e9      	b.n	11a38 <TCPIP_DNS_EntryQuery+0x124>
   11a64:	2000e424 	.word	0x2000e424

Disassembly of section .text.xQueueSemaphoreTake%255:

00011a68 <xQueueSemaphoreTake>:
	} /*lint -restore */
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
   11a68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11a6c:	b084      	sub	sp, #16
   11a6e:	4604      	mov	r4, r0
   11a70:	9101      	str	r1, [sp, #4]
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
   11a72:	f04f 0800 	mov.w	r8, #0
BaseType_t xEntryTimeSet = pdFALSE;
   11a76:	4646      	mov	r6, r8

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
   11a78:	4645      	mov	r5, r8

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
				{
					portYIELD_WITHIN_API();
   11a7a:	4f4f      	ldr	r7, [pc, #316]	; (11bb8 <xQueueSemaphoreTake+0x150>)
   11a7c:	e043      	b.n	11b06 <xQueueSemaphoreTake+0x9e>
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
   11a7e:	3b01      	subs	r3, #1
   11a80:	63a3      	str	r3, [r4, #56]	; 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   11a82:	6823      	ldr	r3, [r4, #0]
   11a84:	b14b      	cbz	r3, 11a9a <xQueueSemaphoreTake+0x32>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   11a86:	6923      	ldr	r3, [r4, #16]
   11a88:	b95b      	cbnz	r3, 11aa2 <xQueueSemaphoreTake+0x3a>
				taskEXIT_CRITICAL();
   11a8a:	f00f ffa9 	bl	219e0 <vPortExitCritical>
				return pdPASS;
   11a8e:	f04f 0801 	mov.w	r8, #1
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
   11a92:	4640      	mov	r0, r8
   11a94:	b004      	add	sp, #16
   11a96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
   11a9a:	f00f fb55 	bl	21148 <pvTaskIncrementMutexHeldCount>
   11a9e:	60a0      	str	r0, [r4, #8]
   11aa0:	e7f1      	b.n	11a86 <xQueueSemaphoreTake+0x1e>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   11aa2:	f104 0010 	add.w	r0, r4, #16
   11aa6:	f008 fb67 	bl	1a178 <xTaskRemoveFromEventList>
   11aaa:	2800      	cmp	r0, #0
   11aac:	d0ed      	beq.n	11a8a <xQueueSemaphoreTake+0x22>
						queueYIELD_IF_USING_PREEMPTION();
   11aae:	4b42      	ldr	r3, [pc, #264]	; (11bb8 <xQueueSemaphoreTake+0x150>)
   11ab0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   11ab4:	601a      	str	r2, [r3, #0]
   11ab6:	f3bf 8f4f 	dsb	sy
   11aba:	f3bf 8f6f 	isb	sy
   11abe:	e7e4      	b.n	11a8a <xQueueSemaphoreTake+0x22>
					taskEXIT_CRITICAL();
   11ac0:	f00f ff8e 	bl	219e0 <vPortExitCritical>
					return errQUEUE_EMPTY;
   11ac4:	f04f 0800 	mov.w	r8, #0
   11ac8:	e7e3      	b.n	11a92 <xQueueSemaphoreTake+0x2a>
					vTaskInternalSetTimeOutState( &xTimeOut );
   11aca:	a802      	add	r0, sp, #8
   11acc:	f00f fe2a 	bl	21724 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   11ad0:	e023      	b.n	11b1a <xQueueSemaphoreTake+0xb2>
						taskENTER_CRITICAL();
   11ad2:	f00f f8bd 	bl	20c50 <vPortEnterCritical>
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
   11ad6:	68a0      	ldr	r0, [r4, #8]
   11ad8:	f005 fdae 	bl	17638 <xTaskPriorityInherit>
   11adc:	4680      	mov	r8, r0
						taskEXIT_CRITICAL();
   11ade:	f00f ff7f 	bl	219e0 <vPortExitCritical>
   11ae2:	e040      	b.n	11b66 <xQueueSemaphoreTake+0xfe>
				prvUnlockQueue( pxQueue );
   11ae4:	4620      	mov	r0, r4
   11ae6:	f007 fe1b 	bl	19720 <prvUnlockQueue>
				( void ) xTaskResumeAll();
   11aea:	f003 fb6b 	bl	151c4 <xTaskResumeAll>
   11aee:	e009      	b.n	11b04 <xQueueSemaphoreTake+0x9c>
			prvUnlockQueue( pxQueue );
   11af0:	4620      	mov	r0, r4
   11af2:	f007 fe15 	bl	19720 <prvUnlockQueue>
			( void ) xTaskResumeAll();
   11af6:	f003 fb65 	bl	151c4 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   11afa:	4620      	mov	r0, r4
   11afc:	f00f feae 	bl	2185c <prvIsQueueEmpty>
   11b00:	2800      	cmp	r0, #0
   11b02:	d144      	bne.n	11b8e <xQueueSemaphoreTake+0x126>
   11b04:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
   11b06:	f00f f8a3 	bl	20c50 <vPortEnterCritical>
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
   11b0a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
   11b0c:	2b00      	cmp	r3, #0
   11b0e:	d1b6      	bne.n	11a7e <xQueueSemaphoreTake+0x16>
				if( xTicksToWait == ( TickType_t ) 0 )
   11b10:	9b01      	ldr	r3, [sp, #4]
   11b12:	2b00      	cmp	r3, #0
   11b14:	d0d4      	beq.n	11ac0 <xQueueSemaphoreTake+0x58>
				else if( xEntryTimeSet == pdFALSE )
   11b16:	2e00      	cmp	r6, #0
   11b18:	d0d7      	beq.n	11aca <xQueueSemaphoreTake+0x62>
		taskEXIT_CRITICAL();
   11b1a:	f00f ff61 	bl	219e0 <vPortExitCritical>
		vTaskSuspendAll();
   11b1e:	f010 f88d 	bl	21c3c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   11b22:	f00f f895 	bl	20c50 <vPortEnterCritical>
   11b26:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
   11b2a:	b25b      	sxtb	r3, r3
   11b2c:	f1b3 3fff 	cmp.w	r3, #4294967295
   11b30:	bf08      	it	eq
   11b32:	f884 5044 	strbeq.w	r5, [r4, #68]	; 0x44
   11b36:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
   11b3a:	b25b      	sxtb	r3, r3
   11b3c:	f1b3 3fff 	cmp.w	r3, #4294967295
   11b40:	bf08      	it	eq
   11b42:	f884 5045 	strbeq.w	r5, [r4, #69]	; 0x45
   11b46:	f00f ff4b 	bl	219e0 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   11b4a:	a901      	add	r1, sp, #4
   11b4c:	a802      	add	r0, sp, #8
   11b4e:	f009 ffd1 	bl	1baf4 <xTaskCheckForTimeOut>
   11b52:	2800      	cmp	r0, #0
   11b54:	d1cc      	bne.n	11af0 <xQueueSemaphoreTake+0x88>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   11b56:	4620      	mov	r0, r4
   11b58:	f00f fe80 	bl	2185c <prvIsQueueEmpty>
   11b5c:	2800      	cmp	r0, #0
   11b5e:	d0c1      	beq.n	11ae4 <xQueueSemaphoreTake+0x7c>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   11b60:	6823      	ldr	r3, [r4, #0]
   11b62:	2b00      	cmp	r3, #0
   11b64:	d0b5      	beq.n	11ad2 <xQueueSemaphoreTake+0x6a>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   11b66:	9901      	ldr	r1, [sp, #4]
   11b68:	f104 0024 	add.w	r0, r4, #36	; 0x24
   11b6c:	f00f fade 	bl	2112c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
   11b70:	4620      	mov	r0, r4
   11b72:	f007 fdd5 	bl	19720 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
   11b76:	f003 fb25 	bl	151c4 <xTaskResumeAll>
   11b7a:	2800      	cmp	r0, #0
   11b7c:	d1c2      	bne.n	11b04 <xQueueSemaphoreTake+0x9c>
					portYIELD_WITHIN_API();
   11b7e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   11b82:	603b      	str	r3, [r7, #0]
   11b84:	f3bf 8f4f 	dsb	sy
   11b88:	f3bf 8f6f 	isb	sy
   11b8c:	e7ba      	b.n	11b04 <xQueueSemaphoreTake+0x9c>
					if( xInheritanceOccurred != pdFALSE )
   11b8e:	f1b8 0f00 	cmp.w	r8, #0
   11b92:	f43f af7e 	beq.w	11a92 <xQueueSemaphoreTake+0x2a>
						taskENTER_CRITICAL();
   11b96:	f00f f85b 	bl	20c50 <vPortEnterCritical>
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
   11b9a:	6a61      	ldr	r1, [r4, #36]	; 0x24
   11b9c:	b119      	cbz	r1, 11ba6 <xQueueSemaphoreTake+0x13e>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
   11b9e:	6b23      	ldr	r3, [r4, #48]	; 0x30
   11ba0:	6819      	ldr	r1, [r3, #0]
   11ba2:	f1c1 0105 	rsb	r1, r1, #5
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
   11ba6:	68a0      	ldr	r0, [r4, #8]
   11ba8:	f007 fcfa 	bl	195a0 <vTaskPriorityDisinheritAfterTimeout>
						taskEXIT_CRITICAL();
   11bac:	f00f ff18 	bl	219e0 <vPortExitCritical>
				return errQUEUE_EMPTY;
   11bb0:	f04f 0800 	mov.w	r8, #0
   11bb4:	e76d      	b.n	11a92 <xQueueSemaphoreTake+0x2a>
   11bb6:	bf00      	nop
   11bb8:	e000ed04 	.word	0xe000ed04

Disassembly of section .text.DRV_MIIM_Tasks%256:

00011bbc <DRV_MIIM_Tasks>:
    _DRV_MIIM_ObjUnlock(pMiimObj);
    return res;
}

void DRV_MIIM_Tasks( SYS_MODULE_OBJ hSysObj )
{
   11bbc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    DRV_MIIM_OP_DCPT *pOpDcpt, *pHead;
    DRV_MIIM_REPORT_ACT repAct;
    DRV_MIIM_OBJ * pMiimObj = _DRV_MIIM_GetObjectAndLock(hSysObj);
   11bc0:	f00d fcd1 	bl	1f566 <_DRV_MIIM_GetObjectAndLock>

    if(pMiimObj == 0)
   11bc4:	2800      	cmp	r0, #0
   11bc6:	f000 808d 	beq.w	11ce4 <DRV_MIIM_Tasks+0x128>
   11bca:	4605      	mov	r5, r0
            }
            break;

        default:
            _MIIMAssertCond(false, __func__, __LINE__);
            pOpDcpt->opStat = DRV_MIIM_TXFER_ERROR;
   11bcc:	f04f 0808 	mov.w	r8, #8
       GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_MPE_Msk;
    }
    
    static  __inline__ bool __attribute__((always_inline))_DRV_MIIM_IS_BUSY(uintptr_t ethPhyId)
    {
       if ((GMAC_REGS->GMAC_NSR & GMAC_NSR_IDLE_Msk) != GMAC_NSR_IDLE_Msk)
   11bd0:	4e4d      	ldr	r6, [pc, #308]	; (11d08 <DRV_MIIM_Tasks+0x14c>)
            pOpDcpt->opStat = DRV_MIIM_TXFER_DONE;
   11bd2:	2705      	movs	r7, #5
    while((pOpDcpt = (DRV_MIIM_OP_DCPT*)pMiimObj->busyOpList.head) != 0)
   11bd4:	6fec      	ldr	r4, [r5, #124]	; 0x7c
   11bd6:	2c00      	cmp	r4, #0
   11bd8:	f000 8081 	beq.w	11cde <DRV_MIIM_Tasks+0x122>
    switch(pOpDcpt->opStat)
   11bdc:	7aa3      	ldrb	r3, [r4, #10]
   11bde:	3b01      	subs	r3, #1
   11be0:	2b03      	cmp	r3, #3
   11be2:	d871      	bhi.n	11cc8 <DRV_MIIM_Tasks+0x10c>
   11be4:	e8df f003 	tbb	[pc, r3]
   11be8:	2c2c6002 	.word	0x2c2c6002
        GMAC_REGS->GMAC_NCR |=	GMAC_NCR_MPE_Msk;
   11bec:	6833      	ldr	r3, [r6, #0]
   11bee:	f043 0310 	orr.w	r3, r3, #16
   11bf2:	6033      	str	r3, [r6, #0]
       if ((GMAC_REGS->GMAC_NSR & GMAC_NSR_IDLE_Msk) != GMAC_NSR_IDLE_Msk)
   11bf4:	68b3      	ldr	r3, [r6, #8]
   11bf6:	f013 0f04 	tst.w	r3, #4
   11bfa:	d021      	beq.n	11c40 <DRV_MIIM_Tasks+0x84>
            if(pOpDcpt->opType == DRV_MIIM_OP_SCAN)
   11bfc:	7923      	ldrb	r3, [r4, #4]
   11bfe:	2b03      	cmp	r3, #3
   11c00:	d01d      	beq.n	11c3e <DRV_MIIM_Tasks+0x82>
            else if(pOpDcpt->opType == DRV_MIIM_OP_WRITE)
   11c02:	2b02      	cmp	r3, #2
   11c04:	d004      	beq.n	11c10 <DRV_MIIM_Tasks+0x54>
            else if(pOpDcpt->opType == DRV_MIIM_OP_READ)
   11c06:	2b01      	cmp	r3, #1
   11c08:	d03f      	beq.n	11c8a <DRV_MIIM_Tasks+0xce>
                pOpDcpt->opStat = DRV_MIIM_TXFER_ERROR; 
   11c0a:	f884 800a 	strb.w	r8, [r4, #10]
                break;
   11c0e:	e059      	b.n	11cc4 <DRV_MIIM_Tasks+0x108>
    {
        GMAC_REGS->GMAC_MAN = 
                                (~GMAC_MAN_WZO_Msk & GMAC_MAN_CLTTO_Msk)
                                 | (GMAC_MAN_OP(0x1)) 
                                 | GMAC_MAN_WTN(0x02) 
                                 | GMAC_MAN_PHYA(pOpDcpt->phyAdd) 
   11c10:	79a3      	ldrb	r3, [r4, #6]
   11c12:	05db      	lsls	r3, r3, #23
   11c14:	f003 6378 	and.w	r3, r3, #260046848	; 0xf800000
                                 | GMAC_MAN_REGA(pOpDcpt->regIx) 
   11c18:	7962      	ldrb	r2, [r4, #5]
   11c1a:	0492      	lsls	r2, r2, #18
   11c1c:	f402 02f8 	and.w	r2, r2, #8126464	; 0x7c0000
   11c20:	4313      	orrs	r3, r2
                                 | GMAC_MAN_DATA(pOpDcpt->opData);
   11c22:	8922      	ldrh	r2, [r4, #8]
   11c24:	4313      	orrs	r3, r2
   11c26:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
   11c2a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
        GMAC_REGS->GMAC_MAN = 
   11c2e:	6373      	str	r3, [r6, #52]	; 0x34
                newStat = ((pOpDcpt->opFlags & DRV_MIIM_OPERATION_FLAG_DISCARD) == 0) ? DRV_MIIM_TXFER_RDWR_WAIT_COMPLETE : DRV_MIIM_TXFER_DONE;
   11c30:	79e3      	ldrb	r3, [r4, #7]
   11c32:	f003 0301 	and.w	r3, r3, #1
   11c36:	2b00      	cmp	r3, #0
   11c38:	bf0c      	ite	eq
   11c3a:	2302      	moveq	r3, #2
   11c3c:	2305      	movne	r3, #5
            pOpDcpt->opStat = newStat;
   11c3e:	72a3      	strb	r3, [r4, #10]
        if(pOpDcpt->opStat >= DRV_MIIM_TXFER_REPORT_STATE)
   11c40:	7aa3      	ldrb	r3, [r4, #10]
   11c42:	2b03      	cmp	r3, #3
   11c44:	d94b      	bls.n	11cde <DRV_MIIM_Tasks+0x122>

    _MIIMAssertCond(pClient->parentObj == pMiimObj, __func__, __LINE__);

    while(true)
    {
        if((pOpDcpt->opFlags & DRV_MIIM_OPERATION_FLAG_DISCARD) == 0)
   11c46:	79e2      	ldrb	r2, [r4, #7]
   11c48:	f012 0f01 	tst.w	r2, #1
   11c4c:	d112      	bne.n	11c74 <DRV_MIIM_Tasks+0xb8>
    DRV_MIIM_CLIENT_DCPT* pClient = pOpDcpt->pOwner;
   11c4e:	68e0      	ldr	r0, [r4, #12]
        {   // need to signal to client that we're done...
            if(pClient->cbackHandler != 0)
   11c50:	6882      	ldr	r2, [r0, #8]
   11c52:	2a00      	cmp	r2, #0
   11c54:	d048      	beq.n	11ce8 <DRV_MIIM_Tasks+0x12c>
{
    if(DRV_MIIM_TXFER_START <= pOpDcpt->opStat &&  pOpDcpt->opStat < DRV_MIIM_TXFER_SCAN_VALID)
    {
        return DRV_MIIM_RES_PENDING;
    }
    else if(pOpDcpt->opStat <= DRV_MIIM_TXFER_DONE)
   11c56:	2b05      	cmp	r3, #5
   11c58:	d939      	bls.n	11cce <DRV_MIIM_Tasks+0x112>
        {
            pOpDcpt->opStat = DRV_MIIM_TXFER_SCAN_STALE;
        }
        return DRV_MIIM_RES_OK;
    }
    else if(pOpDcpt->opStat == DRV_MIIM_TXFER_TMO_START || pOpDcpt->opStat == DRV_MIIM_TXFER_TMO_END)
   11c5a:	3b06      	subs	r3, #6
   11c5c:	b2db      	uxtb	r3, r3
    {
        return DRV_MIIM_RES_OP_TIMEOUT_ERR;
   11c5e:	2b01      	cmp	r3, #1
   11c60:	bf8c      	ite	hi
   11c62:	f06f 0213 	mvnhi.w	r2, #19
   11c66:	f06f 0208 	mvnls.w	r2, #8
                (*pClient->cbackHandler)((DRV_HANDLE)pClient, pOpDcpt, opResult, pOpDcpt->opData);
   11c6a:	f8d0 9008 	ldr.w	r9, [r0, #8]
   11c6e:	8923      	ldrh	r3, [r4, #8]
   11c70:	4621      	mov	r1, r4
   11c72:	47c8      	blx	r9
        if(pOpDcpt->opType == DRV_MIIM_OP_SCAN)
   11c74:	7923      	ldrb	r3, [r4, #4]
   11c76:	2b03      	cmp	r3, #3
   11c78:	d031      	beq.n	11cde <DRV_MIIM_Tasks+0x122>
                _DRV_MIIM_ReleaseOpDcpt(pMiimObj, pOpDcpt, &pMiimObj->busyOpList, DRV_MIIM_QTYPE_BUSY);
   11c7a:	2302      	movs	r3, #2
   11c7c:	f105 027c 	add.w	r2, r5, #124	; 0x7c
   11c80:	4621      	mov	r1, r4
   11c82:	4628      	mov	r0, r5
   11c84:	f00c fc44 	bl	1e510 <_DRV_MIIM_ReleaseOpDcpt>
                continue;
   11c88:	e7a4      	b.n	11bd4 <DRV_MIIM_Tasks+0x18>
    static  __inline__ void __attribute__((always_inline))_DRV_MIIM_OP_READ_START(uintptr_t ethPhyId, DRV_MIIM_OP_DCPT* pOpDcpt)
    {
        GMAC_REGS->GMAC_MAN =    (~GMAC_MAN_WZO_Msk & GMAC_MAN_CLTTO_Msk) 
                                    | (GMAC_MAN_OP(0x2)) 
                                    | GMAC_MAN_WTN(0x02) 
                                    | GMAC_MAN_PHYA(pOpDcpt->phyAdd) 
   11c8a:	79a3      	ldrb	r3, [r4, #6]
   11c8c:	05db      	lsls	r3, r3, #23
   11c8e:	f003 6378 	and.w	r3, r3, #260046848	; 0xf800000
                                    | GMAC_MAN_REGA(pOpDcpt->regIx) 
   11c92:	7962      	ldrb	r2, [r4, #5]
   11c94:	0492      	lsls	r2, r2, #18
   11c96:	f402 02f8 	and.w	r2, r2, #8126464	; 0x7c0000
   11c9a:	4313      	orrs	r3, r2
                                    | GMAC_MAN_DATA(0);
   11c9c:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
   11ca0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
        GMAC_REGS->GMAC_MAN =    (~GMAC_MAN_WZO_Msk & GMAC_MAN_CLTTO_Msk) 
   11ca4:	6373      	str	r3, [r6, #52]	; 0x34
            if(checkDiscard)
   11ca6:	e7c3      	b.n	11c30 <DRV_MIIM_Tasks+0x74>
       if ((GMAC_REGS->GMAC_NSR & GMAC_NSR_IDLE_Msk) != GMAC_NSR_IDLE_Msk)
   11ca8:	68b3      	ldr	r3, [r6, #8]
   11caa:	f013 0f04 	tst.w	r3, #4
   11cae:	d016      	beq.n	11cde <DRV_MIIM_Tasks+0x122>
            if(pOpDcpt->opType == DRV_MIIM_OP_READ)
   11cb0:	7923      	ldrb	r3, [r4, #4]
   11cb2:	2b01      	cmp	r3, #1
    }
    
                                 
    static  __inline__ uint16_t __attribute__((always_inline))_DRV_MIIM_OP_READ_DATA_GET(uintptr_t ethPhyId)
    {
       return (uint16_t)(GMAC_REGS->GMAC_MAN & GMAC_MAN_DATA_Msk) ;
   11cb4:	bf04      	itt	eq
   11cb6:	6b73      	ldreq	r3, [r6, #52]	; 0x34
   11cb8:	8123      	strheq	r3, [r4, #8]
       GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_MPE_Msk;
   11cba:	6833      	ldr	r3, [r6, #0]
   11cbc:	f023 0310 	bic.w	r3, r3, #16
   11cc0:	6033      	str	r3, [r6, #0]
            pOpDcpt->opStat = DRV_MIIM_TXFER_DONE;
   11cc2:	72a7      	strb	r7, [r4, #10]
        if(pOpDcpt->opStat >= DRV_MIIM_TXFER_REPORT_STATE)
   11cc4:	7aa3      	ldrb	r3, [r4, #10]
   11cc6:	e7be      	b.n	11c46 <DRV_MIIM_Tasks+0x8a>
            pOpDcpt->opStat = DRV_MIIM_TXFER_ERROR;
   11cc8:	f884 800a 	strb.w	r8, [r4, #10]
            break;
   11ccc:	e7fa      	b.n	11cc4 <DRV_MIIM_Tasks+0x108>
        if(scanAck && pOpDcpt->opStat == DRV_MIIM_TXFER_SCAN_VALID)
   11cce:	2b04      	cmp	r3, #4
   11cd0:	d001      	beq.n	11cd6 <DRV_MIIM_Tasks+0x11a>
        return DRV_MIIM_RES_OK;
   11cd2:	2200      	movs	r2, #0
   11cd4:	e7c9      	b.n	11c6a <DRV_MIIM_Tasks+0xae>
            pOpDcpt->opStat = DRV_MIIM_TXFER_SCAN_STALE;
   11cd6:	2303      	movs	r3, #3
   11cd8:	72a3      	strb	r3, [r4, #10]
        return DRV_MIIM_RES_OK;
   11cda:	2200      	movs	r2, #0
   11cdc:	e7c5      	b.n	11c6a <DRV_MIIM_Tasks+0xae>
    OSAL_SEM_Post(&pMiimObj->objSem);
   11cde:	4628      	mov	r0, r5
   11ce0:	f00f fc78 	bl	215d4 <OSAL_SEM_Post>
} 
   11ce4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if(pOpDcpt->opType == DRV_MIIM_OP_SCAN)
   11ce8:	7923      	ldrb	r3, [r4, #4]
   11cea:	2b03      	cmp	r3, #3
   11cec:	d0f7      	beq.n	11cde <DRV_MIIM_Tasks+0x122>
    DRV_MIIM_OP_DCPT* pOpDcpt = (DRV_MIIM_OP_DCPT*)Helper_SingleListHeadRemove(pL);
   11cee:	f105 007c 	add.w	r0, r5, #124	; 0x7c
   11cf2:	f00f f8cb 	bl	20e8c <Helper_SingleListHeadRemove>
   11cf6:	4604      	mov	r4, r0
    Helper_SingleListTailAdd(pL, (SGL_LIST_NODE*)pOpDcpt);
   11cf8:	4601      	mov	r1, r0
   11cfa:	f105 0088 	add.w	r0, r5, #136	; 0x88
   11cfe:	f00f fa84 	bl	2120a <Helper_SingleListTailAdd>
    pOpDcpt->qType = qType;
   11d02:	2303      	movs	r3, #3
   11d04:	72e3      	strb	r3, [r4, #11]
                continue;
   11d06:	e765      	b.n	11bd4 <DRV_MIIM_Tasks+0x18>
   11d08:	42000800 	.word	0x42000800

Disassembly of section .text.TCPIP_TCP_Initialize%257:

00011d0c <TCPIP_TCP_Initialize>:
{
   11d0c:	b538      	push	{r3, r4, r5, lr}
   11d0e:	4605      	mov	r5, r0
   11d10:	460c      	mov	r4, r1
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);  // System Lock
   11d12:	2000      	movs	r0, #0
   11d14:	f00f fc52 	bl	215bc <OSAL_CRIT_Enter>
    if(tcpLockCount == 0)
   11d18:	4b44      	ldr	r3, [pc, #272]	; (11e2c <TCPIP_TCP_Initialize+0x120>)
   11d1a:	681b      	ldr	r3, [r3, #0]
   11d1c:	2b00      	cmp	r3, #0
   11d1e:	d142      	bne.n	11da6 <TCPIP_TCP_Initialize+0x9a>
        if(tcpInitCount != 0 || stackInit->stackAction != TCPIP_STACK_ACTION_INIT)
   11d20:	4b43      	ldr	r3, [pc, #268]	; (11e30 <TCPIP_TCP_Initialize+0x124>)
   11d22:	681b      	ldr	r3, [r3, #0]
   11d24:	2b00      	cmp	r3, #0
   11d26:	d177      	bne.n	11e18 <TCPIP_TCP_Initialize+0x10c>
   11d28:	7f2b      	ldrb	r3, [r5, #28]
   11d2a:	2b00      	cmp	r3, #0
   11d2c:	d174      	bne.n	11e18 <TCPIP_TCP_Initialize+0x10c>
            tcpLockCount = 2;     // get a lock
   11d2e:	4b3f      	ldr	r3, [pc, #252]	; (11e2c <TCPIP_TCP_Initialize+0x120>)
   11d30:	2202      	movs	r2, #2
   11d32:	601a      	str	r2, [r3, #0]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);  // System unlock
   11d34:	4601      	mov	r1, r0
   11d36:	2000      	movs	r0, #0
   11d38:	f00f fd6f 	bl	2181a <OSAL_CRIT_Leave>
    if(stackInit->memH == 0 || pTcpInit == 0 || pTcpInit->nSockets == 0)
   11d3c:	68e8      	ldr	r0, [r5, #12]
   11d3e:	2800      	cmp	r0, #0
   11d40:	d044      	beq.n	11dcc <TCPIP_TCP_Initialize+0xc0>
   11d42:	2c00      	cmp	r4, #0
   11d44:	d042      	beq.n	11dcc <TCPIP_TCP_Initialize+0xc0>
   11d46:	6825      	ldr	r5, [r4, #0]
   11d48:	2d00      	cmp	r5, #0
   11d4a:	d03f      	beq.n	11dcc <TCPIP_TCP_Initialize+0xc0>
    tcpHeapH = stackInit->memH;
   11d4c:	4b39      	ldr	r3, [pc, #228]	; (11e34 <TCPIP_TCP_Initialize+0x128>)
   11d4e:	6018      	str	r0, [r3, #0]
    tcpDefTxSize = pTcpInit->sktTxBuffSize;
   11d50:	88a2      	ldrh	r2, [r4, #4]
   11d52:	4b39      	ldr	r3, [pc, #228]	; (11e38 <TCPIP_TCP_Initialize+0x12c>)
   11d54:	801a      	strh	r2, [r3, #0]
    tcpDefRxSize = pTcpInit->sktRxBuffSize;
   11d56:	88e2      	ldrh	r2, [r4, #6]
   11d58:	4b38      	ldr	r3, [pc, #224]	; (11e3c <TCPIP_TCP_Initialize+0x130>)
   11d5a:	801a      	strh	r2, [r3, #0]
   11d5c:	6883      	ldr	r3, [r0, #8]
   11d5e:	2204      	movs	r2, #4
   11d60:	4629      	mov	r1, r5
   11d62:	4798      	blx	r3
    TCBStubs = (TCB_STUB**)TCPIP_HEAP_Calloc(tcpHeapH, nSockets, sizeof(*TCBStubs));
   11d64:	4b36      	ldr	r3, [pc, #216]	; (11e40 <TCPIP_TCP_Initialize+0x134>)
   11d66:	6018      	str	r0, [r3, #0]
    if(TCBStubs == 0)
   11d68:	2800      	cmp	r0, #0
   11d6a:	d03c      	beq.n	11de6 <TCPIP_TCP_Initialize+0xda>
    TcpSockets = nSockets;
   11d6c:	4b35      	ldr	r3, [pc, #212]	; (11e44 <TCPIP_TCP_Initialize+0x138>)
   11d6e:	601d      	str	r5, [r3, #0]
    tcpSignalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_TCP_Task, TCPIP_TCP_TASK_TICK_RATE);
   11d70:	2205      	movs	r2, #5
   11d72:	4935      	ldr	r1, [pc, #212]	; (11e48 <TCPIP_TCP_Initialize+0x13c>)
   11d74:	200a      	movs	r0, #10
   11d76:	f00b f923 	bl	1cfc0 <_TCPIPStackSignalHandlerRegister>
   11d7a:	4b34      	ldr	r3, [pc, #208]	; (11e4c <TCPIP_TCP_Initialize+0x140>)
   11d7c:	6018      	str	r0, [r3, #0]
    if(tcpSignalHandle == 0)
   11d7e:	2800      	cmp	r0, #0
   11d80:	d03e      	beq.n	11e00 <TCPIP_TCP_Initialize+0xf4>
    tcpInitCount++;
   11d82:	4a2b      	ldr	r2, [pc, #172]	; (11e30 <TCPIP_TCP_Initialize+0x124>)
   11d84:	6813      	ldr	r3, [r2, #0]
   11d86:	3301      	adds	r3, #1
   11d88:	6013      	str	r3, [r2, #0]
    tcpSemaphoreEnabled = OSAL_SEM_Create(&tcpSemaphore, OSAL_SEM_TYPE_BINARY, 1, 1) == OSAL_RESULT_TRUE;
   11d8a:	2301      	movs	r3, #1
   11d8c:	461a      	mov	r2, r3
   11d8e:	2100      	movs	r1, #0
   11d90:	482f      	ldr	r0, [pc, #188]	; (11e50 <TCPIP_TCP_Initialize+0x144>)
   11d92:	f00a f86f 	bl	1be74 <OSAL_SEM_Create>
    if(!tcpSemaphoreEnabled)
   11d96:	2801      	cmp	r0, #1
   11d98:	d138      	bne.n	11e0c <TCPIP_TCP_Initialize+0x100>
    tcpInitCount = 1; // initialized
   11d9a:	2401      	movs	r4, #1
   11d9c:	4b24      	ldr	r3, [pc, #144]	; (11e30 <TCPIP_TCP_Initialize+0x124>)
   11d9e:	601c      	str	r4, [r3, #0]
    tcpLockCount = 1; // release the lock
   11da0:	4b22      	ldr	r3, [pc, #136]	; (11e2c <TCPIP_TCP_Initialize+0x120>)
   11da2:	601c      	str	r4, [r3, #0]
    return true;
   11da4:	e03d      	b.n	11e22 <TCPIP_TCP_Initialize+0x116>
    else if(tcpLockCount == 1)
   11da6:	2b01      	cmp	r3, #1
   11da8:	d005      	beq.n	11db6 <TCPIP_TCP_Initialize+0xaa>
    bool    initRes = false;
   11daa:	2400      	movs	r4, #0
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);  // System unlock
   11dac:	4601      	mov	r1, r0
   11dae:	2000      	movs	r0, #0
   11db0:	f00f fd33 	bl	2181a <OSAL_CRIT_Leave>
    if(initFault)
   11db4:	e035      	b.n	11e22 <TCPIP_TCP_Initialize+0x116>
        if(tcpInitCount <= 0)
   11db6:	4b1e      	ldr	r3, [pc, #120]	; (11e30 <TCPIP_TCP_Initialize+0x124>)
   11db8:	681b      	ldr	r3, [r3, #0]
   11dba:	2b00      	cmp	r3, #0
   11dbc:	dd2c      	ble.n	11e18 <TCPIP_TCP_Initialize+0x10c>
            if(stackInit->stackAction == TCPIP_STACK_ACTION_INIT)
   11dbe:	7f2a      	ldrb	r2, [r5, #28]
   11dc0:	bb8a      	cbnz	r2, 11e26 <TCPIP_TCP_Initialize+0x11a>
                tcpInitCount++;
   11dc2:	3301      	adds	r3, #1
   11dc4:	4a1a      	ldr	r2, [pc, #104]	; (11e30 <TCPIP_TCP_Initialize+0x124>)
   11dc6:	6013      	str	r3, [r2, #0]
            initRes = true;
   11dc8:	2401      	movs	r4, #1
   11dca:	e7ef      	b.n	11dac <TCPIP_TCP_Initialize+0xa0>
        SYS_ERROR(SYS_ERROR_ERROR, "TCP NULL dynamic allocation handle/init data");
   11dcc:	f010 f940 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
   11dd0:	b918      	cbnz	r0, 11dda <TCPIP_TCP_Initialize+0xce>
        tcpLockCount = 0; // leave it uninitialized
   11dd2:	2400      	movs	r4, #0
   11dd4:	4b15      	ldr	r3, [pc, #84]	; (11e2c <TCPIP_TCP_Initialize+0x120>)
   11dd6:	601c      	str	r4, [r3, #0]
        return false;
   11dd8:	e023      	b.n	11e22 <TCPIP_TCP_Initialize+0x116>
        SYS_ERROR(SYS_ERROR_ERROR, "TCP NULL dynamic allocation handle/init data");
   11dda:	f010 f933 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
   11dde:	491d      	ldr	r1, [pc, #116]	; (11e54 <TCPIP_TCP_Initialize+0x148>)
   11de0:	f008 fe5c 	bl	1aa9c <SYS_CONSOLE_Print>
   11de4:	e7f5      	b.n	11dd2 <TCPIP_TCP_Initialize+0xc6>
        SYS_ERROR(SYS_ERROR_ERROR, " TCP Dynamic allocation failed");
   11de6:	f010 f933 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
   11dea:	b918      	cbnz	r0, 11df4 <TCPIP_TCP_Initialize+0xe8>
        tcpLockCount = 0; // leave it uninitialized
   11dec:	2400      	movs	r4, #0
   11dee:	4b0f      	ldr	r3, [pc, #60]	; (11e2c <TCPIP_TCP_Initialize+0x120>)
   11df0:	601c      	str	r4, [r3, #0]
        return false;
   11df2:	e016      	b.n	11e22 <TCPIP_TCP_Initialize+0x116>
        SYS_ERROR(SYS_ERROR_ERROR, " TCP Dynamic allocation failed");
   11df4:	f010 f926 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
   11df8:	4917      	ldr	r1, [pc, #92]	; (11e58 <TCPIP_TCP_Initialize+0x14c>)
   11dfa:	f008 fe4f 	bl	1aa9c <SYS_CONSOLE_Print>
   11dfe:	e7f5      	b.n	11dec <TCPIP_TCP_Initialize+0xe0>
        _TcpCleanup();
   11e00:	f008 fd3e 	bl	1a880 <_TcpCleanup>
        tcpLockCount = 0; // leave it uninitialized
   11e04:	2400      	movs	r4, #0
   11e06:	4b09      	ldr	r3, [pc, #36]	; (11e2c <TCPIP_TCP_Initialize+0x120>)
   11e08:	601c      	str	r4, [r3, #0]
        return false;
   11e0a:	e00a      	b.n	11e22 <TCPIP_TCP_Initialize+0x116>
        _TcpCleanup();
   11e0c:	f008 fd38 	bl	1a880 <_TcpCleanup>
        tcpLockCount = 0; // leave it uninitialized
   11e10:	2400      	movs	r4, #0
   11e12:	4b06      	ldr	r3, [pc, #24]	; (11e2c <TCPIP_TCP_Initialize+0x120>)
   11e14:	601c      	str	r4, [r3, #0]
        return false;
   11e16:	e004      	b.n	11e22 <TCPIP_TCP_Initialize+0x116>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);  // System unlock
   11e18:	4601      	mov	r1, r0
   11e1a:	2000      	movs	r0, #0
   11e1c:	f00f fcfd 	bl	2181a <OSAL_CRIT_Leave>
        return false;
   11e20:	2400      	movs	r4, #0
}
   11e22:	4620      	mov	r0, r4
   11e24:	bd38      	pop	{r3, r4, r5, pc}
            initRes = true;
   11e26:	2401      	movs	r4, #1
   11e28:	e7c0      	b.n	11dac <TCPIP_TCP_Initialize+0xa0>
   11e2a:	bf00      	nop
   11e2c:	2000e39c 	.word	0x2000e39c
   11e30:	2000e398 	.word	0x2000e398
   11e34:	2000e394 	.word	0x2000e394
   11e38:	2000e4f6 	.word	0x2000e4f6
   11e3c:	2000e316 	.word	0x2000e316
   11e40:	2000e38c 	.word	0x2000e38c
   11e44:	2000e390 	.word	0x2000e390
   11e48:	00001981 	.word	0x00001981
   11e4c:	2000e3a4 	.word	0x2000e3a4
   11e50:	2000e3a0 	.word	0x2000e3a0
   11e54:	0001c5ac 	.word	0x0001c5ac
   11e58:	0001c5dc 	.word	0x0001c5dc

Disassembly of section .text.wc_Sha256Update%258:

00011e5c <wc_Sha256Update>:
    {
   11e5c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        if (sha256 == NULL || (data == NULL && len > 0)) {
   11e60:	2800      	cmp	r0, #0
   11e62:	f000 8097 	beq.w	11f94 <wc_Sha256Update+0x138>
   11e66:	460d      	mov	r5, r1
   11e68:	4616      	mov	r6, r2
   11e6a:	4604      	mov	r4, r0
   11e6c:	b1f9      	cbz	r1, 11eae <wc_Sha256Update+0x52>
        if (sha256->devId != INVALID_DEVID) {
   11e6e:	6f03      	ldr	r3, [r0, #112]	; 0x70
   11e70:	f113 0f02 	cmn.w	r3, #2
   11e74:	d007      	beq.n	11e86 <wc_Sha256Update+0x2a>
            int ret = wc_CryptoCb_Sha256Hash(sha256, data, len, NULL);
   11e76:	2300      	movs	r3, #0
   11e78:	f008 feb2 	bl	1abe0 <wc_CryptoCb_Sha256Hash>
   11e7c:	4603      	mov	r3, r0
            if (ret != CRYPTOCB_UNAVAILABLE)
   11e7e:	f46f 7287 	mvn.w	r2, #270	; 0x10e
   11e82:	4290      	cmp	r0, r2
   11e84:	d118      	bne.n	11eb8 <wc_Sha256Update+0x5c>
        if (sha256->buffLen >= WC_SHA256_BLOCK_SIZE) {
   11e86:	6e20      	ldr	r0, [r4, #96]	; 0x60
   11e88:	283f      	cmp	r0, #63	; 0x3f
   11e8a:	f200 8086 	bhi.w	11f9a <wc_Sha256Update+0x13e>
        word32 tmp = sha256->loLen;
   11e8e:	6e62      	ldr	r2, [r4, #100]	; 0x64
        if ((sha256->loLen += len) < tmp) {
   11e90:	18b3      	adds	r3, r6, r2
   11e92:	6663      	str	r3, [r4, #100]	; 0x64
   11e94:	429a      	cmp	r2, r3
   11e96:	d902      	bls.n	11e9e <wc_Sha256Update+0x42>
            sha256->hiLen++;                       /* carry low to high */
   11e98:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   11e9a:	3301      	adds	r3, #1
   11e9c:	66a3      	str	r3, [r4, #104]	; 0x68
        local = (byte*)sha256->buffer;
   11e9e:	f104 0720 	add.w	r7, r4, #32
        if (sha256->buffLen > 0) {
   11ea2:	b960      	cbnz	r0, 11ebe <wc_Sha256Update+0x62>
            while (len >= WC_SHA256_BLOCK_SIZE) {
   11ea4:	2e3f      	cmp	r6, #63	; 0x3f
   11ea6:	d96a      	bls.n	11f7e <wc_Sha256Update+0x122>
   11ea8:	f104 085c 	add.w	r8, r4, #92	; 0x5c
   11eac:	e03e      	b.n	11f2c <wc_Sha256Update+0xd0>
            return 0;
   11eae:	2a00      	cmp	r2, #0
   11eb0:	bf14      	ite	ne
   11eb2:	f06f 03ac 	mvnne.w	r3, #172	; 0xac
   11eb6:	2300      	moveq	r3, #0
    }
   11eb8:	4618      	mov	r0, r3
   11eba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            blocksLen = min(len, WC_SHA256_BLOCK_SIZE - sha256->buffLen);
   11ebe:	f1c0 0840 	rsb	r8, r0, #64	; 0x40
        #define min min
    #endif
    /* returns the smaller of a and b */
    WC_STATIC WC_INLINE word32 min(word32 a, word32 b)
    {
        return a > b ? b : a;
   11ec2:	45b0      	cmp	r8, r6
   11ec4:	bf28      	it	cs
   11ec6:	46b0      	movcs	r8, r6
            XMEMCPY(&local[sha256->buffLen], data, blocksLen);
   11ec8:	4642      	mov	r2, r8
   11eca:	4629      	mov	r1, r5
   11ecc:	4438      	add	r0, r7
   11ece:	f00f f957 	bl	21180 <memcpy>
            sha256->buffLen += blocksLen;
   11ed2:	6e23      	ldr	r3, [r4, #96]	; 0x60
   11ed4:	4443      	add	r3, r8
   11ed6:	6623      	str	r3, [r4, #96]	; 0x60
            data            += blocksLen;
   11ed8:	4445      	add	r5, r8
            len             -= blocksLen;
   11eda:	eba6 0608 	sub.w	r6, r6, r8
            if (sha256->buffLen == WC_SHA256_BLOCK_SIZE) {
   11ede:	2b40      	cmp	r3, #64	; 0x40
   11ee0:	d1e0      	bne.n	11ea4 <wc_Sha256Update+0x48>
   11ee2:	f104 011c 	add.w	r1, r4, #28
   11ee6:	f104 005c 	add.w	r0, r4, #92	; 0x5c
        out[i] = ByteReverseWord32(in[i]);
   11eea:	f851 2f04 	ldr.w	r2, [r1, #4]!
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
   11eee:	0a13      	lsrs	r3, r2, #8
   11ef0:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
   11ef4:	0212      	lsls	r2, r2, #8
   11ef6:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
   11efa:	4313      	orrs	r3, r2
        return (x << y) | (x >> (sizeof(y) * 8 - y));
   11efc:	ea4f 4333 	mov.w	r3, r3, ror #16
        out[i] = ByteReverseWord32(in[i]);
   11f00:	600b      	str	r3, [r1, #0]
    for (i = 0; i < count; i++)
   11f02:	4281      	cmp	r1, r0
   11f04:	d1f1      	bne.n	11eea <wc_Sha256Update+0x8e>
                ret = XTRANSFORM(sha256, (const byte*)local);
   11f06:	4639      	mov	r1, r7
   11f08:	4620      	mov	r0, r4
   11f0a:	f7f9 fc5b 	bl	b7c4 <Transform_Sha256>
                if (ret == 0)
   11f0e:	4603      	mov	r3, r0
   11f10:	2800      	cmp	r0, #0
   11f12:	d1d1      	bne.n	11eb8 <wc_Sha256Update+0x5c>
                    sha256->buffLen = 0;
   11f14:	2300      	movs	r3, #0
   11f16:	6623      	str	r3, [r4, #96]	; 0x60
   11f18:	e7c4      	b.n	11ea4 <wc_Sha256Update+0x48>
                ret = XTRANSFORM(sha256, (const byte*)local32);
   11f1a:	4639      	mov	r1, r7
   11f1c:	4620      	mov	r0, r4
   11f1e:	f7f9 fc51 	bl	b7c4 <Transform_Sha256>
                if (ret != 0)
   11f22:	4603      	mov	r3, r0
   11f24:	2800      	cmp	r0, #0
   11f26:	d1c7      	bne.n	11eb8 <wc_Sha256Update+0x5c>
            while (len >= WC_SHA256_BLOCK_SIZE) {
   11f28:	2e3f      	cmp	r6, #63	; 0x3f
   11f2a:	d928      	bls.n	11f7e <wc_Sha256Update+0x122>
                    XMEMCPY(local32, data, WC_SHA256_BLOCK_SIZE);
   11f2c:	462b      	mov	r3, r5
   11f2e:	463a      	mov	r2, r7
   11f30:	f105 0140 	add.w	r1, r5, #64	; 0x40
   11f34:	f8d3 9000 	ldr.w	r9, [r3]
   11f38:	f8d3 e004 	ldr.w	lr, [r3, #4]
   11f3c:	f8d3 c008 	ldr.w	ip, [r3, #8]
   11f40:	68d8      	ldr	r0, [r3, #12]
   11f42:	f8c2 9000 	str.w	r9, [r2]
   11f46:	f8c2 e004 	str.w	lr, [r2, #4]
   11f4a:	f8c2 c008 	str.w	ip, [r2, #8]
   11f4e:	60d0      	str	r0, [r2, #12]
   11f50:	3310      	adds	r3, #16
   11f52:	3210      	adds	r2, #16
   11f54:	428b      	cmp	r3, r1
   11f56:	d1ed      	bne.n	11f34 <wc_Sha256Update+0xd8>
                data += WC_SHA256_BLOCK_SIZE;
   11f58:	3540      	adds	r5, #64	; 0x40
                len  -= WC_SHA256_BLOCK_SIZE;
   11f5a:	3e40      	subs	r6, #64	; 0x40
   11f5c:	f104 011c 	add.w	r1, r4, #28
        out[i] = ByteReverseWord32(in[i]);
   11f60:	f851 2f04 	ldr.w	r2, [r1, #4]!
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
   11f64:	0a13      	lsrs	r3, r2, #8
   11f66:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
   11f6a:	0212      	lsls	r2, r2, #8
   11f6c:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
   11f70:	4313      	orrs	r3, r2
        return (x << y) | (x >> (sizeof(y) * 8 - y));
   11f72:	ea4f 4333 	mov.w	r3, r3, ror #16
        out[i] = ByteReverseWord32(in[i]);
   11f76:	600b      	str	r3, [r1, #0]
    for (i = 0; i < count; i++)
   11f78:	4588      	cmp	r8, r1
   11f7a:	d1f1      	bne.n	11f60 <wc_Sha256Update+0x104>
   11f7c:	e7cd      	b.n	11f1a <wc_Sha256Update+0xbe>
        if (ret == 0 && len > 0) {
   11f7e:	b90e      	cbnz	r6, 11f84 <wc_Sha256Update+0x128>
        return ret;
   11f80:	2300      	movs	r3, #0
   11f82:	e799      	b.n	11eb8 <wc_Sha256Update+0x5c>
            XMEMCPY(local, data, len);
   11f84:	4632      	mov	r2, r6
   11f86:	4629      	mov	r1, r5
   11f88:	4638      	mov	r0, r7
   11f8a:	f00f f8f9 	bl	21180 <memcpy>
            sha256->buffLen = len;
   11f8e:	6626      	str	r6, [r4, #96]	; 0x60
        return ret;
   11f90:	2300      	movs	r3, #0
   11f92:	e791      	b.n	11eb8 <wc_Sha256Update+0x5c>
            return BAD_FUNC_ARG;
   11f94:	f06f 03ac 	mvn.w	r3, #172	; 0xac
   11f98:	e78e      	b.n	11eb8 <wc_Sha256Update+0x5c>
            return BUFFER_E;
   11f9a:	f06f 0383 	mvn.w	r3, #131	; 0x83
   11f9e:	e78b      	b.n	11eb8 <wc_Sha256Update+0x5c>

Disassembly of section .text.Hash_df%259:

00011fa0 <Hash_df>:
{
   11fa0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11fa4:	b0ad      	sub	sp, #180	; 0xb4
   11fa6:	4690      	mov	r8, r2
   11fa8:	f8dd a0e0 	ldr.w	sl, [sp, #224]	; 0xe0
   11fac:	f88d 3007 	strb.w	r3, [sp, #7]
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
   11fb0:	f3c2 1357 	ubfx	r3, r2, #5, #24
   11fb4:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
   11fb8:	02d2      	lsls	r2, r2, #11
   11fba:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
   11fbe:	4313      	orrs	r3, r2
        return (x << y) | (x >> (sizeof(y) * 8 - y));
   11fc0:	ea4f 4333 	mov.w	r3, r3, ror #16
    bits = ByteReverseWord32(bits);
   11fc4:	932a      	str	r3, [sp, #168]	; 0xa8
        + ((outSz % OUTPUT_BLOCK_LEN) ? 1 : 0);
   11fc6:	f018 091f 	ands.w	r9, r8, #31
   11fca:	bf18      	it	ne
   11fcc:	f04f 0901 	movne.w	r9, #1
    for (i = 0, ctr = 1; i < len; i++, ctr++) {
   11fd0:	2301      	movs	r3, #1
   11fd2:	f88d 30af 	strb.w	r3, [sp, #175]	; 0xaf
   11fd6:	eb19 1958 	adds.w	r9, r9, r8, lsr #5
   11fda:	d070      	beq.n	120be <Hash_df+0x11e>
   11fdc:	4607      	mov	r7, r0
   11fde:	460d      	mov	r5, r1
   11fe0:	2600      	movs	r6, #0
            ret = wc_Sha256Update(sha, &ctr, sizeof(ctr));
   11fe2:	469b      	mov	fp, r3
   11fe4:	e03e      	b.n	12064 <Hash_df+0xc4>
            ret = wc_Sha256Update(sha, (byte*)&bits, sizeof(bits));
   11fe6:	2204      	movs	r2, #4
   11fe8:	a92a      	add	r1, sp, #168	; 0xa8
   11fea:	a80b      	add	r0, sp, #44	; 0x2c
   11fec:	f7ff ff36 	bl	11e5c <wc_Sha256Update>
        if (ret == 0) {
   11ff0:	4604      	mov	r4, r0
   11ff2:	2800      	cmp	r0, #0
   11ff4:	d146      	bne.n	12084 <Hash_df+0xe4>
            if (type != drbgInitV)
   11ff6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   11ffa:	2b04      	cmp	r3, #4
   11ffc:	d146      	bne.n	1208c <Hash_df+0xec>
            ret = wc_Sha256Update(sha, inA, inASz);
   11ffe:	9a37      	ldr	r2, [sp, #220]	; 0xdc
   12000:	9936      	ldr	r1, [sp, #216]	; 0xd8
   12002:	a80b      	add	r0, sp, #44	; 0x2c
   12004:	f7ff ff2a 	bl	11e5c <wc_Sha256Update>
        if (ret == 0) {
   12008:	4604      	mov	r4, r0
   1200a:	2800      	cmp	r0, #0
   1200c:	d13a      	bne.n	12084 <Hash_df+0xe4>
            if (inB != NULL && inBSz > 0)
   1200e:	f1ba 0f00 	cmp.w	sl, #0
   12012:	d002      	beq.n	1201a <Hash_df+0x7a>
   12014:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   12016:	2b00      	cmp	r3, #0
   12018:	d142      	bne.n	120a0 <Hash_df+0x100>
            ret = wc_Sha256Final(sha, digest);
   1201a:	a903      	add	r1, sp, #12
   1201c:	a80b      	add	r0, sp, #44	; 0x2c
   1201e:	f7fe fd4f 	bl	10ac0 <wc_Sha256Final>
   12022:	4604      	mov	r4, r0
        wc_Sha256Free(sha);
   12024:	a80b      	add	r0, sp, #44	; 0x2c
   12026:	f009 fffc 	bl	1c022 <wc_Sha256Free>
        if (ret == 0) {
   1202a:	b99c      	cbnz	r4, 12054 <Hash_df+0xb4>
            if (outSz > OUTPUT_BLOCK_LEN) {
   1202c:	f1b8 0f20 	cmp.w	r8, #32
   12030:	d93f      	bls.n	120b2 <Hash_df+0x112>
                XMEMCPY(out, digest, OUTPUT_BLOCK_LEN);
   12032:	f10d 0c0c 	add.w	ip, sp, #12
   12036:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   1203a:	6028      	str	r0, [r5, #0]
   1203c:	6069      	str	r1, [r5, #4]
   1203e:	60aa      	str	r2, [r5, #8]
   12040:	60eb      	str	r3, [r5, #12]
   12042:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   12046:	6128      	str	r0, [r5, #16]
   12048:	6169      	str	r1, [r5, #20]
   1204a:	61aa      	str	r2, [r5, #24]
   1204c:	61eb      	str	r3, [r5, #28]
                outSz -= OUTPUT_BLOCK_LEN;
   1204e:	f1a8 0820 	sub.w	r8, r8, #32
                out += OUTPUT_BLOCK_LEN;
   12052:	3520      	adds	r5, #32
    for (i = 0, ctr = 1; i < len; i++, ctr++) {
   12054:	3601      	adds	r6, #1
   12056:	f89d 30af 	ldrb.w	r3, [sp, #175]	; 0xaf
   1205a:	3301      	adds	r3, #1
   1205c:	f88d 30af 	strb.w	r3, [sp, #175]	; 0xaf
   12060:	45b1      	cmp	r9, r6
   12062:	d02d      	beq.n	120c0 <Hash_df+0x120>
        ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
   12064:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
   12066:	6fb9      	ldr	r1, [r7, #120]	; 0x78
   12068:	a80b      	add	r0, sp, #44	; 0x2c
   1206a:	f009 f9bd 	bl	1b3e8 <wc_InitSha256_ex>
        if (ret != 0)
   1206e:	4604      	mov	r4, r0
   12070:	bb30      	cbnz	r0, 120c0 <Hash_df+0x120>
            ret = wc_Sha256Update(sha, &ctr, sizeof(ctr));
   12072:	465a      	mov	r2, fp
   12074:	f10d 01af 	add.w	r1, sp, #175	; 0xaf
   12078:	a80b      	add	r0, sp, #44	; 0x2c
   1207a:	f7ff feef 	bl	11e5c <wc_Sha256Update>
        if (ret == 0)
   1207e:	4604      	mov	r4, r0
   12080:	2800      	cmp	r0, #0
   12082:	d0b0      	beq.n	11fe6 <Hash_df+0x46>
        wc_Sha256Free(sha);
   12084:	a80b      	add	r0, sp, #44	; 0x2c
   12086:	f009 ffcc 	bl	1c022 <wc_Sha256Free>
        if (ret == 0) {
   1208a:	e7e3      	b.n	12054 <Hash_df+0xb4>
                ret = wc_Sha256Update(sha, &type, sizeof(type));
   1208c:	465a      	mov	r2, fp
   1208e:	f10d 0107 	add.w	r1, sp, #7
   12092:	a80b      	add	r0, sp, #44	; 0x2c
   12094:	f7ff fee2 	bl	11e5c <wc_Sha256Update>
        if (ret == 0)
   12098:	4604      	mov	r4, r0
   1209a:	2800      	cmp	r0, #0
   1209c:	d1f2      	bne.n	12084 <Hash_df+0xe4>
   1209e:	e7ae      	b.n	11ffe <Hash_df+0x5e>
                ret = wc_Sha256Update(sha, inB, inBSz);
   120a0:	461a      	mov	r2, r3
   120a2:	4651      	mov	r1, sl
   120a4:	a80b      	add	r0, sp, #44	; 0x2c
   120a6:	f7ff fed9 	bl	11e5c <wc_Sha256Update>
        if (ret == 0)
   120aa:	4604      	mov	r4, r0
   120ac:	2800      	cmp	r0, #0
   120ae:	d1e9      	bne.n	12084 <Hash_df+0xe4>
   120b0:	e7b3      	b.n	1201a <Hash_df+0x7a>
                XMEMCPY(out, digest, outSz);
   120b2:	4642      	mov	r2, r8
   120b4:	a903      	add	r1, sp, #12
   120b6:	4628      	mov	r0, r5
   120b8:	f00f f862 	bl	21180 <memcpy>
   120bc:	e7ca      	b.n	12054 <Hash_df+0xb4>
    int ret = DRBG_FAILURE;
   120be:	2401      	movs	r4, #1
    volatile byte* z = (volatile byte*)mem;
   120c0:	aa03      	add	r2, sp, #12
    while (len--) *z++ = 0;
   120c2:	2000      	movs	r0, #0
   120c4:	a90b      	add	r1, sp, #44	; 0x2c
   120c6:	4613      	mov	r3, r2
   120c8:	f803 0b01 	strb.w	r0, [r3], #1
   120cc:	461a      	mov	r2, r3
   120ce:	428b      	cmp	r3, r1
   120d0:	d1f9      	bne.n	120c6 <Hash_df+0x126>
    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
   120d2:	1c20      	adds	r0, r4, #0
   120d4:	bf18      	it	ne
   120d6:	2001      	movne	r0, #1
}
   120d8:	b02d      	add	sp, #180	; 0xb4
   120da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

Disassembly of section .text._MACDeinit%260:

000120e0 <_MACDeinit>:
{
   120e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   120e4:	b08c      	sub	sp, #48	; 0x30
   120e6:	4604      	mov	r4, r0
     DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, NULL);
   120e8:	2200      	movs	r2, #0
   120ea:	213f      	movs	r1, #63	; 0x3f
   120ec:	f00e f982 	bl	203f4 <DRV_PIC32CGMAC_LibSysInt_Disable>
	 DRV_PIC32CGMAC_LibClose(pMACDrv, DRV_PIC32CGMAC_CLOSE_DEFAULT);
   120f0:	2100      	movs	r1, #0
   120f2:	4620      	mov	r0, r4
   120f4:	f00e feae 	bl	20e54 <DRV_PIC32CGMAC_LibClose>
     DRV_PIC32CGMAC_LibSysIntStatus_Clear(pMACDrv, GMAC_ALL_QUE_MASK);
   120f8:	213f      	movs	r1, #63	; 0x3f
   120fa:	4620      	mov	r0, r4
   120fc:	f00d fe3e 	bl	1fd7c <DRV_PIC32CGMAC_LibSysIntStatus_Clear>
	if(_hEventMac != hMac)
   12100:	4b45      	ldr	r3, [pc, #276]	; (12218 <_MACDeinit+0x138>)
   12102:	681b      	ldr	r3, [r3, #0]
   12104:	429c      	cmp	r4, r3
   12106:	d114      	bne.n	12132 <_MACDeinit+0x52>
    DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, NULL);
   12108:	2200      	movs	r2, #0
   1210a:	213f      	movs	r1, #63	; 0x3f
   1210c:	4620      	mov	r0, r4
   1210e:	f00e f971 	bl	203f4 <DRV_PIC32CGMAC_LibSysInt_Disable>
    DRV_PIC32CGMAC_LibSysIntStatus_Clear(pMACDrv, GMAC_ALL_QUE_MASK);
   12112:	213f      	movs	r1, #63	; 0x3f
   12114:	4620      	mov	r0, r4
   12116:	f00d fe31 	bl	1fd7c <DRV_PIC32CGMAC_LibSysIntStatus_Clear>
	pDcpt->_TcpNotifyFnc = 0;
   1211a:	2300      	movs	r3, #0
   1211c:	6563      	str	r3, [r4, #84]	; 0x54
	pDcpt->_TcpEnabledEvents = pDcpt->_TcpPendingEvents = TCPIP_MAC_EV_NONE;
   1211e:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
   12122:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
	pDcpt->_EthEnabledEvents = pDcpt->_EthPendingEvents = 0;
   12126:	f8a4 3052 	strh.w	r3, [r4, #82]	; 0x52
   1212a:	f8a4 3050 	strh.w	r3, [r4, #80]	; 0x50
	_hEventMac = 0;
   1212e:	4a3a      	ldr	r2, [pc, #232]	; (12218 <_MACDeinit+0x138>)
   12130:	6013      	str	r3, [r2, #0]
	 const DRV_ETHPHY_OBJECT_BASE* pPhyBase =  pMACDrv->sGmacData.gmacConfig.pPhyBase;
   12132:	f8d4 50d8 	ldr.w	r5, [r4, #216]	; 0xd8
	 if(pMACDrv->sGmacData.hPhyClient != DRV_HANDLE_INVALID)
   12136:	6920      	ldr	r0, [r4, #16]
   12138:	f1b0 3fff 	cmp.w	r0, #4294967295
   1213c:	d004      	beq.n	12148 <_MACDeinit+0x68>
		 pPhyBase->DRV_ETHPHY_Close(pMACDrv->sGmacData.hPhyClient);
   1213e:	69ab      	ldr	r3, [r5, #24]
   12140:	4798      	blx	r3
		 pMACDrv->sGmacData.hPhyClient = DRV_HANDLE_INVALID;
   12142:	f04f 33ff 	mov.w	r3, #4294967295
   12146:	6123      	str	r3, [r4, #16]
	 if(pMACDrv->sGmacData.hPhySysObject != SYS_MODULE_OBJ_INVALID)
   12148:	68e0      	ldr	r0, [r4, #12]
   1214a:	f1b0 3fff 	cmp.w	r0, #4294967295
   1214e:	d004      	beq.n	1215a <_MACDeinit+0x7a>
		 pPhyBase->DRV_ETHPHY_Deinitialize(pMACDrv->sGmacData.hPhySysObject);
   12150:	68ab      	ldr	r3, [r5, #8]
   12152:	4798      	blx	r3
		 pMACDrv->sGmacData.hPhySysObject = SYS_MODULE_OBJ_INVALID;
   12154:	f04f 33ff 	mov.w	r3, #4294967295
   12158:	60e3      	str	r3, [r4, #12]
	if(pMACDrv->sGmacData._synchF != 0)
   1215a:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1215c:	b11b      	cbz	r3, 12166 <_MACDeinit+0x86>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_LOCK);
   1215e:	2103      	movs	r1, #3
   12160:	f104 0060 	add.w	r0, r4, #96	; 0x60
   12164:	4798      	blx	r3
    _MacTxDiscardQueues(pMACDrv,TCPIP_MAC_PKT_ACK_NET_DOWN);
   12166:	f06f 0101 	mvn.w	r1, #1
   1216a:	4620      	mov	r0, r4
   1216c:	f00b f9a6 	bl	1d4bc <_MacTxDiscardQueues>
	if(pMACDrv->sGmacData._synchF != 0)
   12170:	6b23      	ldr	r3, [r4, #48]	; 0x30
   12172:	b11b      	cbz	r3, 1217c <_MACDeinit+0x9c>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_UNLOCK);
   12174:	2104      	movs	r1, #4
   12176:	f104 0060 	add.w	r0, r4, #96	; 0x60
   1217a:	4798      	blx	r3
        gmac_queue = pMACDrv->sGmacData.gmac_queue[queueIdx];
   1217c:	ad01      	add	r5, sp, #4
   1217e:	f104 068c 	add.w	r6, r4, #140	; 0x8c
   12182:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   12184:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   12186:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   12188:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   1218a:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
   1218e:	e885 0007 	stmia.w	r5, {r0, r1, r2}
        while((pRxPkt = (TCPIP_MAC_PACKET*)DRV_PIC32CGMAC_SingleListHeadRemove(&gmac_queue._RxQueue))!= NULL)
   12192:	a803      	add	r0, sp, #12
   12194:	f00e fe6c 	bl	20e70 <DRV_PIC32CGMAC_SingleListHeadRemove>
   12198:	4603      	mov	r3, r0
   1219a:	b118      	cbz	r0, 121a4 <_MACDeinit+0xc4>
            (*pMACDrv->sGmacData.pktFreeF)(pRxPkt);                   
   1219c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   1219e:	4618      	mov	r0, r3
   121a0:	4790      	blx	r2
   121a2:	e7f6      	b.n	12192 <_MACDeinit+0xb2>
        for(index = 0; index < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxDescCnt; index++ )
   121a4:	f8b4 30be 	ldrh.w	r3, [r4, #190]	; 0xbe
   121a8:	b30b      	cbz	r3, 121ee <_MACDeinit+0x10e>
   121aa:	2500      	movs	r5, #0
				gmac_queue.nRxDescIndex = 0;
   121ac:	462e      	mov	r6, r5
   121ae:	e011      	b.n	121d4 <_MACDeinit+0xf4>
   121b0:	f8ad 6028 	strh.w	r6, [sp, #40]	; 0x28
				gmac_queue.pRxPckt[index] = 0;
   121b4:	9b01      	ldr	r3, [sp, #4]
   121b6:	f843 6008 	str.w	r6, [r3, r8]
				gmac_queue.pRxDesc[index].rx_desc_buffaddr.val = 0;
   121ba:	9b02      	ldr	r3, [sp, #8]
   121bc:	f843 6037 	str.w	r6, [r3, r7, lsl #3]
				gmac_queue.pRxDesc[index].rx_desc_status.val = 0;
   121c0:	9b02      	ldr	r3, [sp, #8]
   121c2:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
   121c6:	605e      	str	r6, [r3, #4]
        for(index = 0; index < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxDescCnt; index++ )
   121c8:	3501      	adds	r5, #1
   121ca:	b2ed      	uxtb	r5, r5
   121cc:	f8b4 30be 	ldrh.w	r3, [r4, #190]	; 0xbe
   121d0:	42ab      	cmp	r3, r5
   121d2:	d90c      	bls.n	121ee <_MACDeinit+0x10e>
            if(gmac_queue.pRxPckt != NULL)
   121d4:	9b01      	ldr	r3, [sp, #4]
   121d6:	2b00      	cmp	r3, #0
   121d8:	d0f6      	beq.n	121c8 <_MACDeinit+0xe8>
				pRxPkt = gmac_queue.pRxPckt[index];
   121da:	462f      	mov	r7, r5
   121dc:	ea4f 0885 	mov.w	r8, r5, lsl #2
   121e0:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
				if(pRxPkt)
   121e4:	2800      	cmp	r0, #0
   121e6:	d0e3      	beq.n	121b0 <_MACDeinit+0xd0>
					(*pMACDrv->sGmacData.pktFreeF)(pRxPkt);
   121e8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   121ea:	4798      	blx	r3
   121ec:	e7e0      	b.n	121b0 <_MACDeinit+0xd0>
        if(gmac_queue.pRxPckt != NULL)
   121ee:	9901      	ldr	r1, [sp, #4]
   121f0:	b121      	cbz	r1, 121fc <_MACDeinit+0x11c>
            (*pMACDrv->sGmacData._freeF)(pMACDrv->sGmacData._AllocH, gmac_queue.pRxPckt); 
   121f2:	6a23      	ldr	r3, [r4, #32]
   121f4:	69a0      	ldr	r0, [r4, #24]
   121f6:	4798      	blx	r3
            gmac_queue.pRxPckt = NULL;
   121f8:	2300      	movs	r3, #0
   121fa:	9301      	str	r3, [sp, #4]
   121fc:	f3bf 8f5f 	dmb	sy
	if(pMACDrv->sGmacData._synchF != 0)
   12200:	6b23      	ldr	r3, [r4, #48]	; 0x30
   12202:	b11b      	cbz	r3, 1220c <_MACDeinit+0x12c>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_DELETE);
   12204:	2102      	movs	r1, #2
   12206:	f104 0060 	add.w	r0, r4, #96	; 0x60
   1220a:	4798      	blx	r3
	pMACDrv->sGmacData.sysStat = SYS_STATUS_UNINITIALIZED;
   1220c:	2300      	movs	r3, #0
   1220e:	7523      	strb	r3, [r4, #20]
	pMACDrv->sGmacData._macFlags.val = 0;
   12210:	82e3      	strh	r3, [r4, #22]
}
   12212:	b00c      	add	sp, #48	; 0x30
   12214:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12218:	2000dd14 	.word	0x2000dd14

Disassembly of section .text.TCPIP_UDP_Deinitialize%261:

0001221c <TCPIP_UDP_Deinitialize>:
    if(udpInitCount == 0)
   1221c:	4b48      	ldr	r3, [pc, #288]	; (12340 <TCPIP_UDP_Deinitialize+0x124>)
   1221e:	681b      	ldr	r3, [r3, #0]
   12220:	b903      	cbnz	r3, 12224 <TCPIP_UDP_Deinitialize+0x8>
   12222:	4770      	bx	lr
{
   12224:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12228:	b085      	sub	sp, #20
   1222a:	4683      	mov	fp, r0
    OSAL_SEM_Pend(&userSem, OSAL_WAIT_FOREVER);
   1222c:	f64f 71ff 	movw	r1, #65535	; 0xffff
   12230:	4844      	ldr	r0, [pc, #272]	; (12344 <TCPIP_UDP_Deinitialize+0x128>)
   12232:	f00e fdb7 	bl	20da4 <OSAL_SEM_Pend>
    _UDPAbortSockets(1 << stackCtrl->netIx, TCPIP_UDP_SIGNAL_IF_DOWN); 
   12236:	f8db 3018 	ldr.w	r3, [fp, #24]
   1223a:	2601      	movs	r6, #1
   1223c:	409e      	lsls	r6, r3
    for(ix = 0; ix < nUdpSockets; ix++)
   1223e:	4b42      	ldr	r3, [pc, #264]	; (12348 <TCPIP_UDP_Deinitialize+0x12c>)
   12240:	681b      	ldr	r3, [r3, #0]
   12242:	2b00      	cmp	r3, #0
   12244:	dd3f      	ble.n	122c6 <TCPIP_UDP_Deinitialize+0xaa>
   12246:	2500      	movs	r5, #0
        if((pSkt = UDPSocketDcpt[ix]) != 0)  
   12248:	f8df 9100 	ldr.w	r9, [pc, #256]	; 1234c <TCPIP_UDP_Deinitialize+0x130>
                uint32_t sktIfMask = 1 << sktIfIx;
   1224c:	f04f 0a01 	mov.w	sl, #1
    for(ix = 0; ix < nUdpSockets; ix++)
   12250:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 12348 <TCPIP_UDP_Deinitialize+0x12c>
   12254:	e004      	b.n	12260 <TCPIP_UDP_Deinitialize+0x44>
   12256:	3501      	adds	r5, #1
   12258:	f8d8 3000 	ldr.w	r3, [r8]
   1225c:	429d      	cmp	r5, r3
   1225e:	da32      	bge.n	122c6 <TCPIP_UDP_Deinitialize+0xaa>
        if((pSkt = UDPSocketDcpt[ix]) != 0)  
   12260:	f8d9 3000 	ldr.w	r3, [r9]
   12264:	f853 4025 	ldr.w	r4, [r3, r5, lsl #2]
   12268:	2c00      	cmp	r4, #0
   1226a:	d0f4      	beq.n	12256 <TCPIP_UDP_Deinitialize+0x3a>
            sktIf = pSkt->pSktNet;
   1226c:	6a67      	ldr	r7, [r4, #36]	; 0x24
            sktIfIx = TCPIP_STACK_NetIxGet(sktIf); 
   1226e:	4638      	mov	r0, r7
   12270:	f00f fd58 	bl	21d24 <TCPIP_STACK_NetIxGet>
            if(sktIfIx >= 0)
   12274:	2800      	cmp	r0, #0
   12276:	dbee      	blt.n	12256 <TCPIP_UDP_Deinitialize+0x3a>
                uint32_t sktIfMask = 1 << sktIfIx;
   12278:	fa0a f000 	lsl.w	r0, sl, r0
                if((sktIfMask & netMask) != 0)
   1227c:	4230      	tst	r0, r6
   1227e:	d0ea      	beq.n	12256 <TCPIP_UDP_Deinitialize+0x3a>
                    TCPIP_UDP_Disconnect(pSkt->sktIx, true);
   12280:	4651      	mov	r1, sl
   12282:	f9b4 0012 	ldrsh.w	r0, [r4, #18]
   12286:	f005 fc65 	bl	17b54 <TCPIP_UDP_Disconnect>
                    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1228a:	2000      	movs	r0, #0
   1228c:	f00f f996 	bl	215bc <OSAL_CRIT_Enter>
                    sigHandler = pSkt->sigHandler;
   12290:	6d23      	ldr	r3, [r4, #80]	; 0x50
   12292:	9301      	str	r3, [sp, #4]
                    sigParam = pSkt->sigParam;
   12294:	6d61      	ldr	r1, [r4, #84]	; 0x54
   12296:	9103      	str	r1, [sp, #12]
                    sigMask = pSkt->sigMask;
   12298:	f8b4 1058 	ldrh.w	r1, [r4, #88]	; 0x58
   1229c:	9102      	str	r1, [sp, #8]
                    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   1229e:	4601      	mov	r1, r0
   122a0:	2000      	movs	r0, #0
   122a2:	f00f faba 	bl	2181a <OSAL_CRIT_Leave>
                    if(sigHandler != 0 && (sigMask & sigType) != 0)
   122a6:	9a01      	ldr	r2, [sp, #4]
   122a8:	2a00      	cmp	r2, #0
   122aa:	d0d4      	beq.n	12256 <TCPIP_UDP_Deinitialize+0x3a>
   122ac:	9902      	ldr	r1, [sp, #8]
   122ae:	f411 5f00 	tst.w	r1, #8192	; 0x2000
   122b2:	d0d0      	beq.n	12256 <TCPIP_UDP_Deinitialize+0x3a>
                        (*sigHandler)(pSkt->sktIx, (TCPIP_NET_HANDLE)sktIf, sigType, sigParam);
   122b4:	9b03      	ldr	r3, [sp, #12]
   122b6:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   122ba:	4639      	mov	r1, r7
   122bc:	f9b4 0012 	ldrsh.w	r0, [r4, #18]
   122c0:	9c01      	ldr	r4, [sp, #4]
   122c2:	47a0      	blx	r4
   122c4:	e7c7      	b.n	12256 <TCPIP_UDP_Deinitialize+0x3a>
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_DEINIT)
   122c6:	f89b 301c 	ldrb.w	r3, [fp, #28]
   122ca:	2b02      	cmp	r3, #2
   122cc:	d131      	bne.n	12332 <TCPIP_UDP_Deinitialize+0x116>
        if(--udpInitCount == 0)
   122ce:	4b1c      	ldr	r3, [pc, #112]	; (12340 <TCPIP_UDP_Deinitialize+0x124>)
   122d0:	681c      	ldr	r4, [r3, #0]
   122d2:	3c01      	subs	r4, #1
   122d4:	601c      	str	r4, [r3, #0]
   122d6:	2c00      	cmp	r4, #0
   122d8:	d12b      	bne.n	12332 <TCPIP_UDP_Deinitialize+0x116>
            for(ix = 0; ix < nUdpSockets; ix++)
   122da:	4b1b      	ldr	r3, [pc, #108]	; (12348 <TCPIP_UDP_Deinitialize+0x12c>)
   122dc:	681b      	ldr	r3, [r3, #0]
   122de:	2b00      	cmp	r3, #0
   122e0:	dd0e      	ble.n	12300 <TCPIP_UDP_Deinitialize+0xe4>
                pSkt = UDPSocketDcpt[ix];
   122e2:	4e1a      	ldr	r6, [pc, #104]	; (1234c <TCPIP_UDP_Deinitialize+0x130>)
            for(ix = 0; ix < nUdpSockets; ix++)
   122e4:	4d18      	ldr	r5, [pc, #96]	; (12348 <TCPIP_UDP_Deinitialize+0x12c>)
   122e6:	e005      	b.n	122f4 <TCPIP_UDP_Deinitialize+0xd8>
                    _UDPClose(pSkt);
   122e8:	f00a fc20 	bl	1cb2c <_UDPClose>
            for(ix = 0; ix < nUdpSockets; ix++)
   122ec:	3401      	adds	r4, #1
   122ee:	682b      	ldr	r3, [r5, #0]
   122f0:	42a3      	cmp	r3, r4
   122f2:	dd05      	ble.n	12300 <TCPIP_UDP_Deinitialize+0xe4>
                pSkt = UDPSocketDcpt[ix];
   122f4:	6833      	ldr	r3, [r6, #0]
   122f6:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
                if(pSkt) 
   122fa:	2800      	cmp	r0, #0
   122fc:	d1f4      	bne.n	122e8 <TCPIP_UDP_Deinitialize+0xcc>
   122fe:	e7f5      	b.n	122ec <TCPIP_UDP_Deinitialize+0xd0>
            TCPIP_HEAP_Free(udpMemH, UDPSocketDcpt);
   12300:	4b13      	ldr	r3, [pc, #76]	; (12350 <TCPIP_UDP_Deinitialize+0x134>)
   12302:	6818      	ldr	r0, [r3, #0]
   12304:	4c11      	ldr	r4, [pc, #68]	; (1234c <TCPIP_UDP_Deinitialize+0x130>)
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   12306:	68c3      	ldr	r3, [r0, #12]
   12308:	6821      	ldr	r1, [r4, #0]
   1230a:	4798      	blx	r3
            UDPSocketDcpt = 0;
   1230c:	2300      	movs	r3, #0
   1230e:	6023      	str	r3, [r4, #0]
            if(signalHandle)
   12310:	4b10      	ldr	r3, [pc, #64]	; (12354 <TCPIP_UDP_Deinitialize+0x138>)
   12312:	6818      	ldr	r0, [r3, #0]
   12314:	b120      	cbz	r0, 12320 <TCPIP_UDP_Deinitialize+0x104>
                _TCPIPStackSignalHandlerDeregister(signalHandle);
   12316:	f00f fd0c 	bl	21d32 <_TCPIPStackSignalHandlerDeregister>
                signalHandle = 0;
   1231a:	4b0e      	ldr	r3, [pc, #56]	; (12354 <TCPIP_UDP_Deinitialize+0x138>)
   1231c:	2200      	movs	r2, #0
   1231e:	601a      	str	r2, [r3, #0]
            udpMemH = 0;
   12320:	2300      	movs	r3, #0
   12322:	4a0b      	ldr	r2, [pc, #44]	; (12350 <TCPIP_UDP_Deinitialize+0x134>)
   12324:	6013      	str	r3, [r2, #0]
            nUdpSockets = 0;
   12326:	4a08      	ldr	r2, [pc, #32]	; (12348 <TCPIP_UDP_Deinitialize+0x12c>)
   12328:	6013      	str	r3, [r2, #0]
    OSAL_SEM_Delete(&userSem);
   1232a:	4806      	ldr	r0, [pc, #24]	; (12344 <TCPIP_UDP_Deinitialize+0x128>)
   1232c:	f00f fbae 	bl	21a8c <OSAL_SEM_Delete>
   12330:	e002      	b.n	12338 <TCPIP_UDP_Deinitialize+0x11c>
    OSAL_SEM_Post(&userSem);
   12332:	4804      	ldr	r0, [pc, #16]	; (12344 <TCPIP_UDP_Deinitialize+0x128>)
   12334:	f00f f94e 	bl	215d4 <OSAL_SEM_Post>
}
   12338:	b005      	add	sp, #20
   1233a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1233e:	bf00      	nop
   12340:	2000e460 	.word	0x2000e460
   12344:	2000e468 	.word	0x2000e468
   12348:	2000e458 	.word	0x2000e458
   1234c:	2000e454 	.word	0x2000e454
   12350:	2000e464 	.word	0x2000e464
   12354:	2000e45c 	.word	0x2000e45c

Disassembly of section .text._LoadNetworkConfig%262:

00012358 <_LoadNetworkConfig>:
{
   12358:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1235c:	b082      	sub	sp, #8
   1235e:	4605      	mov	r5, r0
   12360:	460c      	mov	r4, r1
    if(restartIf)
   12362:	4617      	mov	r7, r2
   12364:	2a00      	cmp	r2, #0
   12366:	d13b      	bne.n	123e0 <_LoadNetworkConfig+0x88>
    const void*  pMacConfig = 0;             // MAC configuration save
   12368:	2600      	movs	r6, #0
    int     netIfIx = 0;
   1236a:	46b0      	mov	r8, r6
        memset(pNetIf, 0, sizeof(*pNetIf));
   1236c:	226c      	movs	r2, #108	; 0x6c
   1236e:	2100      	movs	r1, #0
   12370:	4620      	mov	r0, r4
   12372:	f00f fc8b 	bl	21c8c <memset>
        if(pUsrConfig->macAddr != 0)
   12376:	68a8      	ldr	r0, [r5, #8]
   12378:	2800      	cmp	r0, #0
   1237a:	d03a      	beq.n	123f2 <_LoadNetworkConfig+0x9a>
            TCPIP_Helper_StringToMACAddress(pUsrConfig->macAddr, pNetIf->netMACAddr.v);
   1237c:	f104 013c 	add.w	r1, r4, #60	; 0x3c
   12380:	f003 ff8e 	bl	162a0 <TCPIP_Helper_StringToMACAddress>
        TCPIP_Helper_StringToIPAddress(pUsrConfig->ipAddr, &pNetIf->DefaultIPAddr);
   12384:	f104 0118 	add.w	r1, r4, #24
   12388:	68e8      	ldr	r0, [r5, #12]
   1238a:	f001 f899 	bl	134c0 <TCPIP_Helper_StringToIPAddress>
        TCPIP_Helper_StringToIPAddress(pUsrConfig->ipMask, &pNetIf->DefaultMask);
   1238e:	f104 011c 	add.w	r1, r4, #28
   12392:	6928      	ldr	r0, [r5, #16]
   12394:	f001 f894 	bl	134c0 <TCPIP_Helper_StringToIPAddress>
        TCPIP_Helper_StringToIPAddress(pUsrConfig->gateway, &pNetIf->DefaultGateway);
   12398:	f104 0120 	add.w	r1, r4, #32
   1239c:	6968      	ldr	r0, [r5, #20]
   1239e:	f001 f88f 	bl	134c0 <TCPIP_Helper_StringToIPAddress>
        TCPIP_Helper_StringToIPAddress(pUsrConfig->priDNS, &pNetIf->DefaultDNSServer[0]);
   123a2:	f104 0124 	add.w	r1, r4, #36	; 0x24
   123a6:	69a8      	ldr	r0, [r5, #24]
   123a8:	f001 f88a 	bl	134c0 <TCPIP_Helper_StringToIPAddress>
        TCPIP_Helper_StringToIPAddress(pUsrConfig->secondDNS, &pNetIf->DefaultDNSServer[1]);
   123ac:	f104 0128 	add.w	r1, r4, #40	; 0x28
   123b0:	69e8      	ldr	r0, [r5, #28]
   123b2:	f001 f885 	bl	134c0 <TCPIP_Helper_StringToIPAddress>
        if((pNetIf->pMacObj = pUsrConfig->pMacObject) == 0)
   123b6:	6aab      	ldr	r3, [r5, #40]	; 0x28
   123b8:	6463      	str	r3, [r4, #68]	; 0x44
   123ba:	2b00      	cmp	r3, #0
   123bc:	d055      	beq.n	1246a <_LoadNetworkConfig+0x112>
        pNetIf->macId = pNetIf->pMacObj->macId;
   123be:	881a      	ldrh	r2, [r3, #0]
   123c0:	8062      	strh	r2, [r4, #2]
        pNetIf->macType = pNetIf->pMacObj->macType;
   123c2:	789b      	ldrb	r3, [r3, #2]
   123c4:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69
        if(pNetIf->macType == 0 || pNetIf->macType >= TCPIP_MAC_TYPES)
   123c8:	3b01      	subs	r3, #1
   123ca:	b2db      	uxtb	r3, r3
   123cc:	2b01      	cmp	r3, #1
   123ce:	d915      	bls.n	123fc <_LoadNetworkConfig+0xa4>
            loadFault = true;       // no such MAC type
   123d0:	2301      	movs	r3, #1
    if(restartIf)
   123d2:	2f00      	cmp	r7, #0
   123d4:	d14d      	bne.n	12472 <_LoadNetworkConfig+0x11a>
}
   123d6:	f083 0001 	eor.w	r0, r3, #1
   123da:	b002      	add	sp, #8
   123dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        strncpy(oldIfName, pNetIf->ifName, sizeof(oldIfName) - 1); 
   123e0:	2207      	movs	r2, #7
   123e2:	3162      	adds	r1, #98	; 0x62
   123e4:	4668      	mov	r0, sp
   123e6:	f00d ffce 	bl	20386 <strncpy>
        pMacConfig = pNetIf->pMacConfig;
   123ea:	6d66      	ldr	r6, [r4, #84]	; 0x54
        netIfIx = pNetIf->netIfIx;
   123ec:	f8b4 8058 	ldrh.w	r8, [r4, #88]	; 0x58
   123f0:	e7bc      	b.n	1236c <_LoadNetworkConfig+0x14>
            memset(pNetIf->netMACAddr.v, 0, sizeof(pNetIf->netMACAddr.v));
   123f2:	2200      	movs	r2, #0
   123f4:	63e2      	str	r2, [r4, #60]	; 0x3c
   123f6:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
   123fa:	e7c3      	b.n	12384 <_LoadNetworkConfig+0x2c>
        memcpy(pNetIf->NetBIOSName, pUsrConfig->hostName, sizeof(tcpipNetIf[0].NetBIOSName));
   123fc:	f104 002c 	add.w	r0, r4, #44	; 0x2c
   12400:	686b      	ldr	r3, [r5, #4]
   12402:	f8d3 c000 	ldr.w	ip, [r3]
   12406:	6859      	ldr	r1, [r3, #4]
   12408:	689a      	ldr	r2, [r3, #8]
   1240a:	68db      	ldr	r3, [r3, #12]
   1240c:	f8c4 c02c 	str.w	ip, [r4, #44]	; 0x2c
   12410:	6041      	str	r1, [r0, #4]
   12412:	6082      	str	r2, [r0, #8]
   12414:	60c3      	str	r3, [r0, #12]
        TCPIP_Helper_FormatNetBIOSName(pNetIf->NetBIOSName);
   12416:	f00a f969 	bl	1c6ec <TCPIP_Helper_FormatNetBIOSName>
        pNetIf->startFlags = pUsrConfig->startFlags;
   1241a:	8cab      	ldrh	r3, [r5, #36]	; 0x24
   1241c:	64a3      	str	r3, [r4, #72]	; 0x48
    pNetIf->Flags.bInConfig = config;
   1241e:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   12422:	f043 0310 	orr.w	r3, r3, #16
   12426:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
        startAddService = TCPIP_STACK_AddressServiceSelect(pNetIf, pUsrConfig->startFlags);
   1242a:	8ca9      	ldrh	r1, [r5, #36]	; 0x24
   1242c:	4620      	mov	r0, r4
   1242e:	f00d ff84 	bl	2033a <TCPIP_STACK_AddressServiceSelect>
        if(startAddService == TCPIP_STACK_ADDRESS_SERVICE_NONE)
   12432:	b1b0      	cbz	r0, 12462 <_LoadNetworkConfig+0x10a>
    pNetIf->dnsServer[0].Val = pNetIf->DefaultDNSServer[0].Val;
   12434:	6a63      	ldr	r3, [r4, #36]	; 0x24
   12436:	6123      	str	r3, [r4, #16]
    pNetIf->dnsServer[1].Val = pNetIf->DefaultDNSServer[1].Val;
   12438:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1243a:	6163      	str	r3, [r4, #20]
        pNetIf->Flags.bIsDNSServerAuto = 1;
   1243c:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   12440:	f043 0320 	orr.w	r3, r3, #32
   12444:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        TCPIP_STACK_DNS_SERVICE_TYPE addDynamicNameService = TCPIP_STACK_DNSServiceSelect(pNetIf, pUsrConfig->startFlags);
   12448:	8ca9      	ldrh	r1, [r5, #36]	; 0x24
   1244a:	4620      	mov	r0, r4
   1244c:	f00d ff62 	bl	20314 <TCPIP_STACK_DNSServiceSelect>
        if(addDynamicNameService == TCPIP_STACK_DNS_SERVICE_NONE)
   12450:	b968      	cbnz	r0, 1246e <_LoadNetworkConfig+0x116>
            pNetIf->Flags.bIsDnsClientEnabled = 1;
   12452:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   12456:	f043 0308 	orr.w	r3, r3, #8
   1245a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        loadFault = false;
   1245e:	2300      	movs	r3, #0
   12460:	e7b7      	b.n	123d2 <_LoadNetworkConfig+0x7a>
            TCPIP_STACK_AddressServiceDefaultSet(pNetIf);
   12462:	4620      	mov	r0, r4
   12464:	f00b fd64 	bl	1df30 <TCPIP_STACK_AddressServiceDefaultSet>
   12468:	e7e4      	b.n	12434 <_LoadNetworkConfig+0xdc>
            loadFault = true;       // no such MAC interface
   1246a:	2301      	movs	r3, #1
   1246c:	e7b1      	b.n	123d2 <_LoadNetworkConfig+0x7a>
        loadFault = false;
   1246e:	2300      	movs	r3, #0
   12470:	e7af      	b.n	123d2 <_LoadNetworkConfig+0x7a>
        memcpy(pNetIf->ifName, oldIfName, sizeof(pNetIf->ifName)); 
   12472:	9800      	ldr	r0, [sp, #0]
   12474:	f8c4 0062 	str.w	r0, [r4, #98]	; 0x62
   12478:	f8bd 0004 	ldrh.w	r0, [sp, #4]
   1247c:	f89d 1006 	ldrb.w	r1, [sp, #6]
   12480:	f8a4 0066 	strh.w	r0, [r4, #102]	; 0x66
   12484:	f884 1068 	strb.w	r1, [r4, #104]	; 0x68
        pNetIf->pMacConfig = pMacConfig;
   12488:	6566      	str	r6, [r4, #84]	; 0x54
        pNetIf->netIfIx = netIfIx;
   1248a:	f8a4 8058 	strh.w	r8, [r4, #88]	; 0x58
   1248e:	e7a2      	b.n	123d6 <_LoadNetworkConfig+0x7e>

Disassembly of section .text.CommandIperfNetIf%263:

00012490 <CommandIperfNetIf>:
{
   12490:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12494:	b087      	sub	sp, #28
   12496:	4682      	mov	sl, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   12498:	6843      	ldr	r3, [r0, #4]
   1249a:	9301      	str	r3, [sp, #4]
    ipAddr.Val = 0;
   1249c:	2300      	movs	r3, #0
   1249e:	9305      	str	r3, [sp, #20]
    if (argc >= 3)
   124a0:	2902      	cmp	r1, #2
   124a2:	dd5c      	ble.n	1255e <CommandIperfNetIf+0xce>
   124a4:	4614      	mov	r4, r2
   124a6:	f1a1 0803 	sub.w	r8, r1, #3
   124aa:	f028 0801 	bic.w	r8, r8, #1
   124ae:	f108 0803 	add.w	r8, r8, #3
        int currIx = 1; // 1st param is always the command name, skip it
   124b2:	2601      	movs	r6, #1
    bool addFound = false;
   124b4:	9303      	str	r3, [sp, #12]
    int iperfIndex = 0;     // assume index 0 if not specified
   124b6:	4699      	mov	r9, r3
            if(strcmp(param, "-a") == 0)
   124b8:	f8df b100 	ldr.w	fp, [pc, #256]	; 125bc <CommandIperfNetIf+0x12c>
            else if((strcmp(param, "-i") == 0) || (strcmp(param, "--index") == 0))
   124bc:	f10b 033c 	add.w	r3, fp, #60	; 0x3c
   124c0:	9300      	str	r3, [sp, #0]
   124c2:	f10b 0340 	add.w	r3, fp, #64	; 0x40
   124c6:	9302      	str	r3, [sp, #8]
   124c8:	e014      	b.n	124f4 <CommandIperfNetIf+0x64>
                if(!TCPIP_Helper_StringToIPAddress(paramVal, &ipAddr))
   124ca:	a905      	add	r1, sp, #20
   124cc:	4638      	mov	r0, r7
   124ce:	f000 fff7 	bl	134c0 <TCPIP_Helper_StringToIPAddress>
   124d2:	9003      	str	r0, [sp, #12]
   124d4:	b950      	cbnz	r0, 124ec <CommandIperfNetIf+0x5c>
                    (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperfi: use a valid IP address!\r\n");
   124d6:	f8da 3000 	ldr.w	r3, [sl]
   124da:	681b      	ldr	r3, [r3, #0]
   124dc:	492f      	ldr	r1, [pc, #188]	; (1259c <CommandIperfNetIf+0x10c>)
   124de:	9801      	ldr	r0, [sp, #4]
   124e0:	4798      	blx	r3
                    return;
   124e2:	e042      	b.n	1256a <CommandIperfNetIf+0xda>
                iperfIndex = atoi(paramVal);
   124e4:	4638      	mov	r0, r7
   124e6:	f00f fe8b 	bl	22200 <atoi>
   124ea:	4681      	mov	r9, r0
            currIx += 2;
   124ec:	3602      	adds	r6, #2
   124ee:	3408      	adds	r4, #8
        while(currIx + 1 < argc)
   124f0:	45b0      	cmp	r8, r6
   124f2:	d01b      	beq.n	1252c <CommandIperfNetIf+0x9c>
            char* param = argv[currIx];
   124f4:	6865      	ldr	r5, [r4, #4]
            char* paramVal = argv[currIx + 1];
   124f6:	68a7      	ldr	r7, [r4, #8]
            if(strcmp(param, "-a") == 0)
   124f8:	4929      	ldr	r1, [pc, #164]	; (125a0 <CommandIperfNetIf+0x110>)
   124fa:	4628      	mov	r0, r5
   124fc:	f00f fa8e 	bl	21a1c <strcmp>
   12500:	2800      	cmp	r0, #0
   12502:	d0e2      	beq.n	124ca <CommandIperfNetIf+0x3a>
            else if((strcmp(param, "-i") == 0) || (strcmp(param, "--index") == 0))
   12504:	9900      	ldr	r1, [sp, #0]
   12506:	4628      	mov	r0, r5
   12508:	f00f fa88 	bl	21a1c <strcmp>
   1250c:	2800      	cmp	r0, #0
   1250e:	d0e9      	beq.n	124e4 <CommandIperfNetIf+0x54>
   12510:	9902      	ldr	r1, [sp, #8]
   12512:	4628      	mov	r0, r5
   12514:	f00f fa82 	bl	21a1c <strcmp>
   12518:	2800      	cmp	r0, #0
   1251a:	d0e3      	beq.n	124e4 <CommandIperfNetIf+0x54>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperfi: Unknown parameter\r\n");
   1251c:	f8da 3000 	ldr.w	r3, [sl]
   12520:	681b      	ldr	r3, [r3, #0]
   12522:	f10b 0148 	add.w	r1, fp, #72	; 0x48
   12526:	9801      	ldr	r0, [sp, #4]
   12528:	4798      	blx	r3
   1252a:	e7df      	b.n	124ec <CommandIperfNetIf+0x5c>
    if (!addFound)
   1252c:	9b03      	ldr	r3, [sp, #12]
   1252e:	b1b3      	cbz	r3, 1255e <CommandIperfNetIf+0xce>
    if(iperfIndex < 0 || iperfIndex >= nIperfSessions)
   12530:	f1b9 0f00 	cmp.w	r9, #0
   12534:	db1c      	blt.n	12570 <CommandIperfNetIf+0xe0>
   12536:	4b1b      	ldr	r3, [pc, #108]	; (125a4 <CommandIperfNetIf+0x114>)
   12538:	681b      	ldr	r3, [r3, #0]
   1253a:	454b      	cmp	r3, r9
   1253c:	dd18      	ble.n	12570 <CommandIperfNetIf+0xe0>
    pIState = gIperfState + iperfIndex;	
   1253e:	4a1a      	ldr	r2, [pc, #104]	; (125a8 <CommandIperfNetIf+0x118>)
   12540:	23d8      	movs	r3, #216	; 0xd8
   12542:	fb03 2309 	mla	r3, r3, r9, r2
    if (pIState->state != IPERF_STANDBY_STATE)
   12546:	f893 20ce 	ldrb.w	r2, [r3, #206]	; 0xce
   1254a:	2a01      	cmp	r2, #1
   1254c:	d01a      	beq.n	12584 <CommandIperfNetIf+0xf4>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperfi: cannot change the ip address while session: %d running!\r\n", iperfIndex);
   1254e:	f8da 3000 	ldr.w	r3, [sl]
   12552:	685b      	ldr	r3, [r3, #4]
   12554:	464a      	mov	r2, r9
   12556:	4915      	ldr	r1, [pc, #84]	; (125ac <CommandIperfNetIf+0x11c>)
   12558:	9801      	ldr	r0, [sp, #4]
   1255a:	4798      	blx	r3
        return;
   1255c:	e005      	b.n	1256a <CommandIperfNetIf+0xda>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: iperfi -a address <-i index>\r\n");
   1255e:	f8da 3000 	ldr.w	r3, [sl]
   12562:	681b      	ldr	r3, [r3, #0]
   12564:	4912      	ldr	r1, [pc, #72]	; (125b0 <CommandIperfNetIf+0x120>)
   12566:	9801      	ldr	r0, [sp, #4]
   12568:	4798      	blx	r3
}
   1256a:	b007      	add	sp, #28
   1256c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: Invalid session number. Min: 0, Max: %d\r\n", nIperfSessions - 1);
   12570:	4b0c      	ldr	r3, [pc, #48]	; (125a4 <CommandIperfNetIf+0x114>)
   12572:	681a      	ldr	r2, [r3, #0]
   12574:	f8da 3000 	ldr.w	r3, [sl]
   12578:	685b      	ldr	r3, [r3, #4]
   1257a:	3a01      	subs	r2, #1
   1257c:	490d      	ldr	r1, [pc, #52]	; (125b4 <CommandIperfNetIf+0x124>)
   1257e:	9801      	ldr	r0, [sp, #4]
   12580:	4798      	blx	r3
        return;
   12582:	e7f2      	b.n	1256a <CommandIperfNetIf+0xda>
    pIState->localAddr.Val = ipAddr.Val;
   12584:	9a05      	ldr	r2, [sp, #20]
   12586:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    (*pCmdIO->pCmdApi->print)(cmdIoParam, "iperfi: OK, set the IP address to instance: %d\r\n", iperfIndex);
   1258a:	f8da 3000 	ldr.w	r3, [sl]
   1258e:	685b      	ldr	r3, [r3, #4]
   12590:	464a      	mov	r2, r9
   12592:	4909      	ldr	r1, [pc, #36]	; (125b8 <CommandIperfNetIf+0x128>)
   12594:	9801      	ldr	r0, [sp, #4]
   12596:	4798      	blx	r3
   12598:	e7e7      	b.n	1256a <CommandIperfNetIf+0xda>
   1259a:	bf00      	nop
   1259c:	00005948 	.word	0x00005948
   125a0:	00005944 	.word	0x00005944
   125a4:	2000e3f0 	.word	0x2000e3f0
   125a8:	2000d9b0 	.word	0x2000d9b0
   125ac:	00005994 	.word	0x00005994
   125b0:	0000596c 	.word	0x0000596c
   125b4:	00005818 	.word	0x00005818
   125b8:	000059d8 	.word	0x000059d8
   125bc:	000057b4 	.word	0x000057b4

Disassembly of section .text._DNS_Resolve%264:

000125c0 <_DNS_Resolve>:
{
   125c0:	b5f0      	push	{r4, r5, r6, r7, lr}
   125c2:	b085      	sub	sp, #20
    pDnsDcpt = pgDnsDcpt;
   125c4:	4b49      	ldr	r3, [pc, #292]	; (126ec <_DNS_Resolve+0x12c>)
   125c6:	681d      	ldr	r5, [r3, #0]
    if(pDnsDcpt == 0)
   125c8:	2d00      	cmp	r5, #0
   125ca:	d07a      	beq.n	126c2 <_DNS_Resolve+0x102>
    if(hostName == 0 || strlen(hostName) == 0 || strlen(hostName)  >= TCPIP_DNS_CLIENT_MAX_HOSTNAME_LEN)
   125cc:	2800      	cmp	r0, #0
   125ce:	d07b      	beq.n	126c8 <_DNS_Resolve+0x108>
   125d0:	7803      	ldrb	r3, [r0, #0]
   125d2:	2b00      	cmp	r3, #0
   125d4:	d07b      	beq.n	126ce <_DNS_Resolve+0x10e>
   125d6:	4617      	mov	r7, r2
   125d8:	460e      	mov	r6, r1
   125da:	4604      	mov	r4, r0
   125dc:	f00f fb66 	bl	21cac <strlen>
   125e0:	283f      	cmp	r0, #63	; 0x3f
   125e2:	d877      	bhi.n	126d4 <_DNS_Resolve+0x114>
    if(TCPIP_Helper_StringToIPAddress(hostName, &ipAddr.v4Add) || TCPIP_Helper_StringToIPv6Address (hostName, &ipAddr.v6Add))
   125e4:	4669      	mov	r1, sp
   125e6:	4620      	mov	r0, r4
   125e8:	f000 ff6a 	bl	134c0 <TCPIP_Helper_StringToIPAddress>
   125ec:	2800      	cmp	r0, #0
   125ee:	d174      	bne.n	126da <_DNS_Resolve+0x11a>
   125f0:	4669      	mov	r1, sp
   125f2:	4620      	mov	r0, r4
   125f4:	f7f8 ff34 	bl	b460 <TCPIP_Helper_StringToIPv6Address>
   125f8:	2800      	cmp	r0, #0
   125fa:	d170      	bne.n	126de <_DNS_Resolve+0x11e>
    dnsHE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryLookupOrInsert(pDnsDcpt->hashDcpt, (void*)hostName);
   125fc:	4621      	mov	r1, r4
   125fe:	6828      	ldr	r0, [r5, #0]
   12600:	f008 fdf4 	bl	1b1ec <TCPIP_OAHASH_EntryLookupOrInsert>
    if(dnsHE == 0)
   12604:	4604      	mov	r4, r0
   12606:	2800      	cmp	r0, #0
   12608:	d06b      	beq.n	126e2 <_DNS_Resolve+0x122>
    if(type == TCPIP_DNS_TYPE_A)
   1260a:	2e01      	cmp	r6, #1
   1260c:	d019      	beq.n	12642 <_DNS_Resolve+0x82>
        recMask = TCPIP_DNS_ADDRESS_REC_IPV4 | TCPIP_DNS_ADDRESS_REC_IPV6;
   1260e:	2e1c      	cmp	r6, #28
   12610:	bf0c      	ite	eq
   12612:	2302      	moveq	r3, #2
   12614:	2303      	movne	r3, #3
    if(forceQuery == 0 && dnsHE->hEntry.flags.newEntry == 0)
   12616:	b9b7      	cbnz	r7, 12646 <_DNS_Resolve+0x86>
   12618:	7822      	ldrb	r2, [r4, #0]
   1261a:	f012 0f02 	tst.w	r2, #2
   1261e:	d127      	bne.n	12670 <_DNS_Resolve+0xb0>
        if((dnsHE->recordMask & recMask) == recMask)
   12620:	f894 202a 	ldrb.w	r2, [r4, #42]	; 0x2a
   12624:	ea33 0202 	bics.w	r2, r3, r2
   12628:	d111      	bne.n	1264e <_DNS_Resolve+0x8e>
            if((dnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) != 0)
   1262a:	8823      	ldrh	r3, [r4, #0]
   1262c:	f013 0f80 	tst.w	r3, #128	; 0x80
   12630:	d15a      	bne.n	126e8 <_DNS_Resolve+0x128>
            return (dnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_TIMEOUT) == 0 ? TCPIP_DNS_RES_PENDING : TCPIP_DNS_RES_SERVER_TMO; 
   12632:	f403 7380 	and.w	r3, r3, #256	; 0x100
   12636:	2b00      	cmp	r3, #0
   12638:	bf0c      	ite	eq
   1263a:	2001      	moveq	r0, #1
   1263c:	f06f 0004 	mvnne.w	r0, #4
   12640:	e03a      	b.n	126b8 <_DNS_Resolve+0xf8>
        recMask = TCPIP_DNS_ADDRESS_REC_IPV4;
   12642:	4633      	mov	r3, r6
   12644:	e7e7      	b.n	12616 <_DNS_Resolve+0x56>
    if(dnsHE->hEntry.flags.newEntry != 0)
   12646:	7822      	ldrb	r2, [r4, #0]
   12648:	f012 0f02 	tst.w	r2, #2
   1264c:	d110      	bne.n	12670 <_DNS_Resolve+0xb0>
        if((recMask & TCPIP_DNS_ADDRESS_REC_IPV4) != 0)
   1264e:	f013 0f01 	tst.w	r3, #1
            dnsHE->nIPv4Entries = 0;
   12652:	bf1c      	itt	ne
   12654:	2200      	movne	r2, #0
   12656:	f884 2026 	strbne.w	r2, [r4, #38]	; 0x26
        if((recMask & TCPIP_DNS_ADDRESS_REC_IPV6) != 0)
   1265a:	f013 0f02 	tst.w	r3, #2
            dnsHE->nIPv6Entries = 0;
   1265e:	bf1c      	itt	ne
   12660:	2200      	movne	r2, #0
   12662:	f884 2027 	strbne.w	r2, [r4, #39]	; 0x27
        dnsHE->hEntry.flags.value &= ~TCPIP_DNS_FLAG_ENTRY_COMPLETE;
   12666:	8822      	ldrh	r2, [r4, #0]
   12668:	f022 0280 	bic.w	r2, r2, #128	; 0x80
   1266c:	8022      	strh	r2, [r4, #0]
   1266e:	e008      	b.n	12682 <_DNS_Resolve+0xc2>
        dnsHE->nIPv4Entries = 0;
   12670:	2200      	movs	r2, #0
   12672:	f884 2026 	strb.w	r2, [r4, #38]	; 0x26
        dnsHE->nIPv6Entries = 0;
   12676:	f884 2027 	strb.w	r2, [r4, #39]	; 0x27
        dnsHE->hEntry.flags.value &= ~(TCPIP_DNS_FLAG_ENTRY_COMPLETE | TCPIP_DNS_FLAG_ENTRY_TIMEOUT);
   1267a:	8822      	ldrh	r2, [r4, #0]
   1267c:	f422 72c0 	bic.w	r2, r2, #384	; 0x180
   12680:	8022      	strh	r2, [r4, #0]
    dnsHE->ipTTL.Val = 0;
   12682:	2200      	movs	r2, #0
   12684:	61a2      	str	r2, [r4, #24]
    dnsHE->resolve_type = type;
   12686:	f884 6028 	strb.w	r6, [r4, #40]	; 0x28
    dnsHE->recordMask |= recMask;
   1268a:	f894 102a 	ldrb.w	r1, [r4, #42]	; 0x2a
   1268e:	430b      	orrs	r3, r1
   12690:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
    dnsHE->tRetry = dnsHE->tInsert = pDnsDcpt->dnsTime;
   12694:	69eb      	ldr	r3, [r5, #28]
   12696:	60a3      	str	r3, [r4, #8]
   12698:	60e3      	str	r3, [r4, #12]
    dnsHE->currRetry = 0;
   1269a:	f884 202b 	strb.w	r2, [r4, #43]	; 0x2b
    int retryIfs = (pDnsDcpt->strictNet == 0) ? TCPIP_STACK_NumberOfNetworksGet() : 1;
   1269e:	686b      	ldr	r3, [r5, #4]
   126a0:	b163      	cbz	r3, 126bc <_DNS_Resolve+0xfc>
   126a2:	2001      	movs	r0, #1
    dnsHE->nRetries = retryIfs * _TCPIP_DNS_IF_RETRY_COUNT;
   126a4:	0040      	lsls	r0, r0, #1
   126a6:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    pDnsDcpt->unsolvedEntries++;
   126aa:	8ceb      	ldrh	r3, [r5, #38]	; 0x26
   126ac:	3301      	adds	r3, #1
   126ae:	84eb      	strh	r3, [r5, #38]	; 0x26
    return _DNS_Send_Query(pDnsDcpt, dnsHE);
   126b0:	4621      	mov	r1, r4
   126b2:	4628      	mov	r0, r5
   126b4:	f7fa fa98 	bl	cbe8 <_DNS_Send_Query>
}
   126b8:	b005      	add	sp, #20
   126ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
    int retryIfs = (pDnsDcpt->strictNet == 0) ? TCPIP_STACK_NumberOfNetworksGet() : 1;
   126bc:	f00f fcaa 	bl	22014 <TCPIP_STACK_NumberOfNetworksGet>
   126c0:	e7f0      	b.n	126a4 <_DNS_Resolve+0xe4>
        return TCPIP_DNS_RES_NO_SERVICE;
   126c2:	f06f 0005 	mvn.w	r0, #5
   126c6:	e7f7      	b.n	126b8 <_DNS_Resolve+0xf8>
        return TCPIP_DNS_RES_INVALID_HOSTNAME; 
   126c8:	f06f 0008 	mvn.w	r0, #8
   126cc:	e7f4      	b.n	126b8 <_DNS_Resolve+0xf8>
   126ce:	f06f 0008 	mvn.w	r0, #8
   126d2:	e7f1      	b.n	126b8 <_DNS_Resolve+0xf8>
   126d4:	f06f 0008 	mvn.w	r0, #8
   126d8:	e7ee      	b.n	126b8 <_DNS_Resolve+0xf8>
        return  TCPIP_DNS_RES_NAME_IS_IPADDRESS;
   126da:	2002      	movs	r0, #2
   126dc:	e7ec      	b.n	126b8 <_DNS_Resolve+0xf8>
   126de:	2002      	movs	r0, #2
   126e0:	e7ea      	b.n	126b8 <_DNS_Resolve+0xf8>
        return TCPIP_DNS_RES_CACHE_FULL; 
   126e2:	f06f 0007 	mvn.w	r0, #7
   126e6:	e7e7      	b.n	126b8 <_DNS_Resolve+0xf8>
               return TCPIP_DNS_RES_OK; 
   126e8:	2000      	movs	r0, #0
   126ea:	e7e5      	b.n	126b8 <_DNS_Resolve+0xf8>
   126ec:	2000e424 	.word	0x2000e424

Disassembly of section .text.SERCOM0_SPI_WriteRead%265:

000126f0 <SERCOM0_SPI_WriteRead>:
{
   126f0:	b430      	push	{r4, r5}
    if((((txSize > 0U) && (pTransmitData != NULL)) || ((rxSize > 0U) && (pReceiveData != NULL))) && (sercom0SPIObj.transferIsBusy == false))
   126f2:	460c      	mov	r4, r1
   126f4:	2900      	cmp	r1, #0
   126f6:	d04d      	beq.n	12794 <SERCOM0_SPI_WriteRead+0xa4>
   126f8:	2800      	cmp	r0, #0
   126fa:	d04b      	beq.n	12794 <SERCOM0_SPI_WriteRead+0xa4>
   126fc:	4946      	ldr	r1, [pc, #280]	; (12818 <SERCOM0_SPI_WriteRead+0x128>)
   126fe:	7f09      	ldrb	r1, [r1, #28]
   12700:	2900      	cmp	r1, #0
   12702:	f040 8086 	bne.w	12812 <SERCOM0_SPI_WriteRead+0x122>
        if((SERCOM0_REGS->SPIM.SERCOM_CTRLB & SERCOM_SPIM_CTRLB_CHSIZE_Msk) == (uint32_t)SPI_DATA_BITS_9)
   12706:	4d45      	ldr	r5, [pc, #276]	; (1281c <SERCOM0_SPI_WriteRead+0x12c>)
   12708:	686d      	ldr	r5, [r5, #4]
   1270a:	f005 0507 	and.w	r5, r5, #7
   1270e:	2d01      	cmp	r5, #1
   12710:	d046      	beq.n	127a0 <SERCOM0_SPI_WriteRead+0xb0>
        sercom0SPIObj.txBuffer = pTransmitData;
   12712:	4941      	ldr	r1, [pc, #260]	; (12818 <SERCOM0_SPI_WriteRead+0x128>)
   12714:	6008      	str	r0, [r1, #0]
        sercom0SPIObj.rxBuffer = pReceiveData;
   12716:	604a      	str	r2, [r1, #4]
        sercom0SPIObj.rxCount = 0U;
   12718:	2500      	movs	r5, #0
   1271a:	614d      	str	r5, [r1, #20]
        sercom0SPIObj.txCount = 0U;
   1271c:	618d      	str	r5, [r1, #24]
        sercom0SPIObj.dummySize = 0U;
   1271e:	610d      	str	r5, [r1, #16]
            sercom0SPIObj.txSize = 0U;
   12720:	42a8      	cmp	r0, r5
   12722:	bf08      	it	eq
   12724:	462c      	moveq	r4, r5
   12726:	608c      	str	r4, [r1, #8]
            sercom0SPIObj.rxSize = 0U;
   12728:	42aa      	cmp	r2, r5
   1272a:	bf18      	it	ne
   1272c:	461d      	movne	r5, r3
   1272e:	460a      	mov	r2, r1
   12730:	60cd      	str	r5, [r1, #12]
        sercom0SPIObj.transferIsBusy = true;
   12732:	2101      	movs	r1, #1
   12734:	7711      	strb	r1, [r2, #28]
        while((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_RXC_Msk) == SERCOM_SPIM_INTFLAG_RXC_Msk)
   12736:	4a39      	ldr	r2, [pc, #228]	; (1281c <SERCOM0_SPI_WriteRead+0x12c>)
   12738:	7e12      	ldrb	r2, [r2, #24]
   1273a:	f012 0f04 	tst.w	r2, #4
   1273e:	d005      	beq.n	1274c <SERCOM0_SPI_WriteRead+0x5c>
            dummyData = SERCOM0_REGS->SPIM.SERCOM_DATA;
   12740:	4a36      	ldr	r2, [pc, #216]	; (1281c <SERCOM0_SPI_WriteRead+0x12c>)
   12742:	6a91      	ldr	r1, [r2, #40]	; 0x28
        while((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_RXC_Msk) == SERCOM_SPIM_INTFLAG_RXC_Msk)
   12744:	7e11      	ldrb	r1, [r2, #24]
   12746:	f011 0f04 	tst.w	r1, #4
   1274a:	d1fa      	bne.n	12742 <SERCOM0_SPI_WriteRead+0x52>
        SERCOM0_REGS->SPIM.SERCOM_STATUS |= (uint16_t)SERCOM_SPIM_STATUS_BUFOVF_Msk;
   1274c:	4a33      	ldr	r2, [pc, #204]	; (1281c <SERCOM0_SPI_WriteRead+0x12c>)
   1274e:	8b51      	ldrh	r1, [r2, #26]
   12750:	f041 0104 	orr.w	r1, r1, #4
   12754:	8351      	strh	r1, [r2, #26]
        SERCOM0_REGS->SPIM.SERCOM_INTFLAG |= (uint8_t)SERCOM_SPIM_INTFLAG_ERROR_Msk;
   12756:	7e11      	ldrb	r1, [r2, #24]
   12758:	f041 0180 	orr.w	r1, r1, #128	; 0x80
   1275c:	7611      	strb	r1, [r2, #24]
        if(sercom0SPIObj.rxSize > sercom0SPIObj.txSize)
   1275e:	42a5      	cmp	r5, r4
   12760:	d902      	bls.n	12768 <SERCOM0_SPI_WriteRead+0x78>
            sercom0SPIObj.dummySize = sercom0SPIObj.rxSize - sercom0SPIObj.txSize;
   12762:	1b2a      	subs	r2, r5, r4
   12764:	492c      	ldr	r1, [pc, #176]	; (12818 <SERCOM0_SPI_WriteRead+0x128>)
   12766:	610a      	str	r2, [r1, #16]
        if((SERCOM0_REGS->SPIM.SERCOM_CTRLB & SERCOM_SPIM_CTRLB_CHSIZE_Msk) == (uint32_t)SPI_DATA_BITS_8)
   12768:	4a2c      	ldr	r2, [pc, #176]	; (1281c <SERCOM0_SPI_WriteRead+0x12c>)
   1276a:	6852      	ldr	r2, [r2, #4]
   1276c:	f012 0f07 	tst.w	r2, #7
   12770:	d12b      	bne.n	127ca <SERCOM0_SPI_WriteRead+0xda>
            if(sercom0SPIObj.txCount < sercom0SPIObj.txSize)
   12772:	4a29      	ldr	r2, [pc, #164]	; (12818 <SERCOM0_SPI_WriteRead+0x128>)
   12774:	6992      	ldr	r2, [r2, #24]
   12776:	42a2      	cmp	r2, r4
   12778:	d21c      	bcs.n	127b4 <SERCOM0_SPI_WriteRead+0xc4>
                SERCOM0_REGS->SPIM.SERCOM_DATA = *((uint8_t*)sercom0SPIObj.txBuffer);
   1277a:	7800      	ldrb	r0, [r0, #0]
   1277c:	4927      	ldr	r1, [pc, #156]	; (1281c <SERCOM0_SPI_WriteRead+0x12c>)
   1277e:	6288      	str	r0, [r1, #40]	; 0x28
                sercom0SPIObj.txCount++;
   12780:	3201      	adds	r2, #1
   12782:	4925      	ldr	r1, [pc, #148]	; (12818 <SERCOM0_SPI_WriteRead+0x128>)
   12784:	618a      	str	r2, [r1, #24]
        if(rxSize > 0U)
   12786:	2b00      	cmp	r3, #0
   12788:	d03b      	beq.n	12802 <SERCOM0_SPI_WriteRead+0x112>
            SERCOM0_REGS->SPIM.SERCOM_INTENSET = (uint8_t)SERCOM_SPIM_INTENSET_RXC_Msk;
   1278a:	4b24      	ldr	r3, [pc, #144]	; (1281c <SERCOM0_SPI_WriteRead+0x12c>)
   1278c:	2204      	movs	r2, #4
   1278e:	759a      	strb	r2, [r3, #22]
        isRequestAccepted = true;
   12790:	2101      	movs	r1, #1
   12792:	e03b      	b.n	1280c <SERCOM0_SPI_WriteRead+0x11c>
    if((((txSize > 0U) && (pTransmitData != NULL)) || ((rxSize > 0U) && (pReceiveData != NULL))) && (sercom0SPIObj.transferIsBusy == false))
   12794:	2b00      	cmp	r3, #0
   12796:	d038      	beq.n	1280a <SERCOM0_SPI_WriteRead+0x11a>
   12798:	2a00      	cmp	r2, #0
   1279a:	d1af      	bne.n	126fc <SERCOM0_SPI_WriteRead+0xc>
    bool isRequestAccepted = false;
   1279c:	2100      	movs	r1, #0
   1279e:	e035      	b.n	1280c <SERCOM0_SPI_WriteRead+0x11c>
            if(((txSize > 0U) && ((txSize & 0x01U) != 0U)) || ((rxSize > 0U) && ((rxSize & 0x01U) != 0U)))
   127a0:	b114      	cbz	r4, 127a8 <SERCOM0_SPI_WriteRead+0xb8>
   127a2:	f014 0f01 	tst.w	r4, #1
   127a6:	d131      	bne.n	1280c <SERCOM0_SPI_WriteRead+0x11c>
   127a8:	2b00      	cmp	r3, #0
   127aa:	d0b2      	beq.n	12712 <SERCOM0_SPI_WriteRead+0x22>
   127ac:	f013 0f01 	tst.w	r3, #1
   127b0:	d0af      	beq.n	12712 <SERCOM0_SPI_WriteRead+0x22>
   127b2:	e02b      	b.n	1280c <SERCOM0_SPI_WriteRead+0x11c>
            else if(sercom0SPIObj.dummySize > 0U)
   127b4:	4a18      	ldr	r2, [pc, #96]	; (12818 <SERCOM0_SPI_WriteRead+0x128>)
   127b6:	6912      	ldr	r2, [r2, #16]
   127b8:	2a00      	cmp	r2, #0
   127ba:	d0e4      	beq.n	12786 <SERCOM0_SPI_WriteRead+0x96>
                SERCOM0_REGS->SPIM.SERCOM_DATA = 0xFFU;
   127bc:	4917      	ldr	r1, [pc, #92]	; (1281c <SERCOM0_SPI_WriteRead+0x12c>)
   127be:	20ff      	movs	r0, #255	; 0xff
   127c0:	6288      	str	r0, [r1, #40]	; 0x28
                sercom0SPIObj.dummySize--;
   127c2:	3a01      	subs	r2, #1
   127c4:	4914      	ldr	r1, [pc, #80]	; (12818 <SERCOM0_SPI_WriteRead+0x128>)
   127c6:	610a      	str	r2, [r1, #16]
   127c8:	e7dd      	b.n	12786 <SERCOM0_SPI_WriteRead+0x96>
            sercom0SPIObj.txSize >>= 1U;
   127ca:	0864      	lsrs	r4, r4, #1
   127cc:	4a12      	ldr	r2, [pc, #72]	; (12818 <SERCOM0_SPI_WriteRead+0x128>)
   127ce:	6094      	str	r4, [r2, #8]
            sercom0SPIObj.dummySize >>= 1U;
   127d0:	6911      	ldr	r1, [r2, #16]
   127d2:	0849      	lsrs	r1, r1, #1
   127d4:	6111      	str	r1, [r2, #16]
            sercom0SPIObj.rxSize >>= 1U;
   127d6:	086d      	lsrs	r5, r5, #1
   127d8:	60d5      	str	r5, [r2, #12]
            if(sercom0SPIObj.txCount < sercom0SPIObj.txSize)
   127da:	6992      	ldr	r2, [r2, #24]
   127dc:	4294      	cmp	r4, r2
   127de:	d906      	bls.n	127ee <SERCOM0_SPI_WriteRead+0xfe>
                SERCOM0_REGS->SPIM.SERCOM_DATA = *((uint16_t*)sercom0SPIObj.txBuffer) & SERCOM_SPIM_DATA_Msk;
   127e0:	8800      	ldrh	r0, [r0, #0]
   127e2:	490e      	ldr	r1, [pc, #56]	; (1281c <SERCOM0_SPI_WriteRead+0x12c>)
   127e4:	6288      	str	r0, [r1, #40]	; 0x28
                sercom0SPIObj.txCount++;
   127e6:	3201      	adds	r2, #1
   127e8:	490b      	ldr	r1, [pc, #44]	; (12818 <SERCOM0_SPI_WriteRead+0x128>)
   127ea:	618a      	str	r2, [r1, #24]
   127ec:	e7cb      	b.n	12786 <SERCOM0_SPI_WriteRead+0x96>
            else if(sercom0SPIObj.dummySize > 0U)
   127ee:	2900      	cmp	r1, #0
   127f0:	d0c9      	beq.n	12786 <SERCOM0_SPI_WriteRead+0x96>
                SERCOM0_REGS->SPIM.SERCOM_DATA = 0xFFFFU & SERCOM_SPIM_DATA_Msk;
   127f2:	4a0a      	ldr	r2, [pc, #40]	; (1281c <SERCOM0_SPI_WriteRead+0x12c>)
   127f4:	f64f 70ff 	movw	r0, #65535	; 0xffff
   127f8:	6290      	str	r0, [r2, #40]	; 0x28
                sercom0SPIObj.dummySize--;
   127fa:	3901      	subs	r1, #1
   127fc:	4a06      	ldr	r2, [pc, #24]	; (12818 <SERCOM0_SPI_WriteRead+0x128>)
   127fe:	6111      	str	r1, [r2, #16]
   12800:	e7c1      	b.n	12786 <SERCOM0_SPI_WriteRead+0x96>
            SERCOM0_REGS->SPIM.SERCOM_INTENSET = (uint8_t)SERCOM_SPIM_INTENSET_DRE_Msk;
   12802:	2101      	movs	r1, #1
   12804:	4b05      	ldr	r3, [pc, #20]	; (1281c <SERCOM0_SPI_WriteRead+0x12c>)
   12806:	7599      	strb	r1, [r3, #22]
   12808:	e000      	b.n	1280c <SERCOM0_SPI_WriteRead+0x11c>
    bool isRequestAccepted = false;
   1280a:	2100      	movs	r1, #0
}
   1280c:	4608      	mov	r0, r1
   1280e:	bc30      	pop	{r4, r5}
   12810:	4770      	bx	lr
    bool isRequestAccepted = false;
   12812:	2100      	movs	r1, #0
   12814:	e7fa      	b.n	1280c <SERCOM0_SPI_WriteRead+0x11c>
   12816:	bf00      	nop
   12818:	2000e09c 	.word	0x2000e09c
   1281c:	40003000 	.word	0x40003000

Disassembly of section .text.__multiply%266:

00012820 <__multiply>:
   12820:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12824:	4615      	mov	r5, r2
   12826:	690a      	ldr	r2, [r1, #16]
   12828:	692b      	ldr	r3, [r5, #16]
   1282a:	429a      	cmp	r2, r3
   1282c:	460c      	mov	r4, r1
   1282e:	bfbc      	itt	lt
   12830:	462c      	movlt	r4, r5
   12832:	460d      	movlt	r5, r1
   12834:	f8d4 9010 	ldr.w	r9, [r4, #16]
   12838:	f8d5 8010 	ldr.w	r8, [r5, #16]
   1283c:	68a3      	ldr	r3, [r4, #8]
   1283e:	6861      	ldr	r1, [r4, #4]
   12840:	eb09 0708 	add.w	r7, r9, r8
   12844:	42bb      	cmp	r3, r7
   12846:	b085      	sub	sp, #20
   12848:	bfb8      	it	lt
   1284a:	3101      	addlt	r1, #1
   1284c:	f008 fbd2 	bl	1aff4 <_Balloc>
   12850:	f100 0614 	add.w	r6, r0, #20
   12854:	eb06 0e87 	add.w	lr, r6, r7, lsl #2
   12858:	4633      	mov	r3, r6
   1285a:	2200      	movs	r2, #0
   1285c:	4573      	cmp	r3, lr
   1285e:	d319      	bcc.n	12894 <__multiply+0x74>
   12860:	f104 0314 	add.w	r3, r4, #20
   12864:	eb03 0389 	add.w	r3, r3, r9, lsl #2
   12868:	f105 0214 	add.w	r2, r5, #20
   1286c:	9300      	str	r3, [sp, #0]
   1286e:	eb02 0388 	add.w	r3, r2, r8, lsl #2
   12872:	9301      	str	r3, [sp, #4]
   12874:	f64f 75ff 	movw	r5, #65535	; 0xffff
   12878:	9b01      	ldr	r3, [sp, #4]
   1287a:	9202      	str	r2, [sp, #8]
   1287c:	4293      	cmp	r3, r2
   1287e:	d80c      	bhi.n	1289a <__multiply+0x7a>
   12880:	2f00      	cmp	r7, #0
   12882:	dd03      	ble.n	1288c <__multiply+0x6c>
   12884:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
   12888:	2b00      	cmp	r3, #0
   1288a:	d05f      	beq.n	1294c <__multiply+0x12c>
   1288c:	6107      	str	r7, [r0, #16]
   1288e:	b005      	add	sp, #20
   12890:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12894:	f843 2b04 	str.w	r2, [r3], #4
   12898:	e7e0      	b.n	1285c <__multiply+0x3c>
   1289a:	6813      	ldr	r3, [r2, #0]
   1289c:	ea13 0c05 	ands.w	ip, r3, r5
   128a0:	d027      	beq.n	128f2 <__multiply+0xd2>
   128a2:	f104 0a14 	add.w	sl, r4, #20
   128a6:	46b0      	mov	r8, r6
   128a8:	f04f 0900 	mov.w	r9, #0
   128ac:	f85a 1b04 	ldr.w	r1, [sl], #4
   128b0:	ea01 0305 	and.w	r3, r1, r5
   128b4:	9303      	str	r3, [sp, #12]
   128b6:	f8d8 3000 	ldr.w	r3, [r8]
   128ba:	ea03 0b05 	and.w	fp, r3, r5
   128be:	9b03      	ldr	r3, [sp, #12]
   128c0:	fb0c b303 	mla	r3, ip, r3, fp
   128c4:	ea4f 4b11 	mov.w	fp, r1, lsr #16
   128c8:	f8d8 1000 	ldr.w	r1, [r8]
   128cc:	444b      	add	r3, r9
   128ce:	ea4f 4911 	mov.w	r9, r1, lsr #16
   128d2:	fb0c 910b 	mla	r1, ip, fp, r9
   128d6:	eb01 4113 	add.w	r1, r1, r3, lsr #16
   128da:	402b      	ands	r3, r5
   128dc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   128e0:	f848 3b04 	str.w	r3, [r8], #4
   128e4:	9b00      	ldr	r3, [sp, #0]
   128e6:	4553      	cmp	r3, sl
   128e8:	ea4f 4911 	mov.w	r9, r1, lsr #16
   128ec:	d8de      	bhi.n	128ac <__multiply+0x8c>
   128ee:	f8c8 9000 	str.w	r9, [r8]
   128f2:	9b02      	ldr	r3, [sp, #8]
   128f4:	f8b3 9002 	ldrh.w	r9, [r3, #2]
   128f8:	3204      	adds	r2, #4
   128fa:	f1b9 0f00 	cmp.w	r9, #0
   128fe:	d023      	beq.n	12948 <__multiply+0x128>
   12900:	6833      	ldr	r3, [r6, #0]
   12902:	f104 0814 	add.w	r8, r4, #20
   12906:	46b4      	mov	ip, r6
   12908:	f04f 0a00 	mov.w	sl, #0
   1290c:	f8d8 1000 	ldr.w	r1, [r8]
   12910:	f8bc b002 	ldrh.w	fp, [ip, #2]
   12914:	4029      	ands	r1, r5
   12916:	fb09 b101 	mla	r1, r9, r1, fp
   1291a:	448a      	add	sl, r1
   1291c:	402b      	ands	r3, r5
   1291e:	ea43 430a 	orr.w	r3, r3, sl, lsl #16
   12922:	f84c 3b04 	str.w	r3, [ip], #4
   12926:	f858 3b04 	ldr.w	r3, [r8], #4
   1292a:	f8dc 1000 	ldr.w	r1, [ip]
   1292e:	0c1b      	lsrs	r3, r3, #16
   12930:	4029      	ands	r1, r5
   12932:	fb09 1303 	mla	r3, r9, r3, r1
   12936:	9900      	ldr	r1, [sp, #0]
   12938:	eb03 431a 	add.w	r3, r3, sl, lsr #16
   1293c:	4541      	cmp	r1, r8
   1293e:	ea4f 4a13 	mov.w	sl, r3, lsr #16
   12942:	d8e3      	bhi.n	1290c <__multiply+0xec>
   12944:	f8cc 3000 	str.w	r3, [ip]
   12948:	3604      	adds	r6, #4
   1294a:	e795      	b.n	12878 <__multiply+0x58>
   1294c:	3f01      	subs	r7, #1
   1294e:	e797      	b.n	12880 <__multiply+0x60>

Disassembly of section .text.quorem%267:

00012950 <quorem>:
   12950:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12954:	6903      	ldr	r3, [r0, #16]
   12956:	690c      	ldr	r4, [r1, #16]
   12958:	42a3      	cmp	r3, r4
   1295a:	4680      	mov	r8, r0
   1295c:	f2c0 808d 	blt.w	12a7a <quorem+0x12a>
   12960:	3c01      	subs	r4, #1
   12962:	f101 0714 	add.w	r7, r1, #20
   12966:	ea4f 0c84 	mov.w	ip, r4, lsl #2
   1296a:	eb07 030c 	add.w	r3, r7, ip
   1296e:	f100 0514 	add.w	r5, r0, #20
   12972:	9300      	str	r3, [sp, #0]
   12974:	eb05 030c 	add.w	r3, r5, ip
   12978:	9301      	str	r3, [sp, #4]
   1297a:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
   1297e:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
   12982:	3301      	adds	r3, #1
   12984:	429a      	cmp	r2, r3
   12986:	fbb2 f6f3 	udiv	r6, r2, r3
   1298a:	d336      	bcc.n	129fa <quorem+0xaa>
   1298c:	f04f 0a00 	mov.w	sl, #0
   12990:	46be      	mov	lr, r7
   12992:	46a9      	mov	r9, r5
   12994:	46d3      	mov	fp, sl
   12996:	f64f 70ff 	movw	r0, #65535	; 0xffff
   1299a:	f85e 2b04 	ldr.w	r2, [lr], #4
   1299e:	ea02 0300 	and.w	r3, r2, r0
   129a2:	fb06 a303 	mla	r3, r6, r3, sl
   129a6:	ea4f 4a13 	mov.w	sl, r3, lsr #16
   129aa:	4003      	ands	r3, r0
   129ac:	ebab 0303 	sub.w	r3, fp, r3
   129b0:	0c12      	lsrs	r2, r2, #16
   129b2:	f8d9 b000 	ldr.w	fp, [r9]
   129b6:	fb06 a202 	mla	r2, r6, r2, sl
   129ba:	fa13 f38b 	uxtah	r3, r3, fp
   129be:	ea4f 4a12 	mov.w	sl, r2, lsr #16
   129c2:	ea02 0b00 	and.w	fp, r2, r0
   129c6:	f8d9 2000 	ldr.w	r2, [r9]
   129ca:	ebcb 4212 	rsb	r2, fp, r2, lsr #16
   129ce:	eb02 4223 	add.w	r2, r2, r3, asr #16
   129d2:	4003      	ands	r3, r0
   129d4:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   129d8:	f849 3b04 	str.w	r3, [r9], #4
   129dc:	9b00      	ldr	r3, [sp, #0]
   129de:	4573      	cmp	r3, lr
   129e0:	ea4f 4b22 	mov.w	fp, r2, asr #16
   129e4:	d2d9      	bcs.n	1299a <quorem+0x4a>
   129e6:	f855 300c 	ldr.w	r3, [r5, ip]
   129ea:	b933      	cbnz	r3, 129fa <quorem+0xaa>
   129ec:	9b01      	ldr	r3, [sp, #4]
   129ee:	3b04      	subs	r3, #4
   129f0:	429d      	cmp	r5, r3
   129f2:	461a      	mov	r2, r3
   129f4:	d335      	bcc.n	12a62 <quorem+0x112>
   129f6:	f8c8 4010 	str.w	r4, [r8, #16]
   129fa:	4640      	mov	r0, r8
   129fc:	f00c fa64 	bl	1eec8 <__mcmp>
   12a00:	2800      	cmp	r0, #0
   12a02:	db2a      	blt.n	12a5a <quorem+0x10a>
   12a04:	3601      	adds	r6, #1
   12a06:	4628      	mov	r0, r5
   12a08:	f04f 0e00 	mov.w	lr, #0
   12a0c:	f64f 7cff 	movw	ip, #65535	; 0xffff
   12a10:	f857 2b04 	ldr.w	r2, [r7], #4
   12a14:	f8d0 9000 	ldr.w	r9, [r0]
   12a18:	ea02 030c 	and.w	r3, r2, ip
   12a1c:	ebae 0303 	sub.w	r3, lr, r3
   12a20:	0c12      	lsrs	r2, r2, #16
   12a22:	fa13 f389 	uxtah	r3, r3, r9
   12a26:	ebc2 4219 	rsb	r2, r2, r9, lsr #16
   12a2a:	eb02 4223 	add.w	r2, r2, r3, asr #16
   12a2e:	ea03 030c 	and.w	r3, r3, ip
   12a32:	ea4f 4e22 	mov.w	lr, r2, asr #16
   12a36:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
   12a3a:	9b00      	ldr	r3, [sp, #0]
   12a3c:	f840 2b04 	str.w	r2, [r0], #4
   12a40:	42bb      	cmp	r3, r7
   12a42:	d2e5      	bcs.n	12a10 <quorem+0xc0>
   12a44:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
   12a48:	eb05 0384 	add.w	r3, r5, r4, lsl #2
   12a4c:	b92a      	cbnz	r2, 12a5a <quorem+0x10a>
   12a4e:	3b04      	subs	r3, #4
   12a50:	429d      	cmp	r5, r3
   12a52:	461a      	mov	r2, r3
   12a54:	d30b      	bcc.n	12a6e <quorem+0x11e>
   12a56:	f8c8 4010 	str.w	r4, [r8, #16]
   12a5a:	4630      	mov	r0, r6
   12a5c:	b003      	add	sp, #12
   12a5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12a62:	6812      	ldr	r2, [r2, #0]
   12a64:	3b04      	subs	r3, #4
   12a66:	2a00      	cmp	r2, #0
   12a68:	d1c5      	bne.n	129f6 <quorem+0xa6>
   12a6a:	3c01      	subs	r4, #1
   12a6c:	e7c0      	b.n	129f0 <quorem+0xa0>
   12a6e:	6812      	ldr	r2, [r2, #0]
   12a70:	3b04      	subs	r3, #4
   12a72:	2a00      	cmp	r2, #0
   12a74:	d1ef      	bne.n	12a56 <quorem+0x106>
   12a76:	3c01      	subs	r4, #1
   12a78:	e7ea      	b.n	12a50 <quorem+0x100>
   12a7a:	2000      	movs	r0, #0
   12a7c:	e7ee      	b.n	12a5c <quorem+0x10c>

Disassembly of section .text.TCPIP_IPV4_Initialize%268:

00012a80 <TCPIP_IPV4_Initialize>:
{
   12a80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(stackInit->stackAction == TCPIP_STACK_ACTION_IF_UP)
   12a82:	7f03      	ldrb	r3, [r0, #28]
   12a84:	2b03      	cmp	r3, #3
   12a86:	d076      	beq.n	12b76 <TCPIP_IPV4_Initialize+0xf6>
    if(ipv4InitCount == 0)
   12a88:	4b3c      	ldr	r3, [pc, #240]	; (12b7c <TCPIP_IPV4_Initialize+0xfc>)
   12a8a:	881b      	ldrh	r3, [r3, #0]
   12a8c:	b12b      	cbz	r3, 12a9a <TCPIP_IPV4_Initialize+0x1a>
    ipv4InitCount++;
   12a8e:	4a3b      	ldr	r2, [pc, #236]	; (12b7c <TCPIP_IPV4_Initialize+0xfc>)
   12a90:	8813      	ldrh	r3, [r2, #0]
   12a92:	3301      	adds	r3, #1
   12a94:	8013      	strh	r3, [r2, #0]
    return true;
   12a96:	2001      	movs	r0, #1
}
   12a98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   12a9a:	460c      	mov	r4, r1
            ipv4MemH = stackInit->memH;
   12a9c:	68c2      	ldr	r2, [r0, #12]
   12a9e:	4b38      	ldr	r3, [pc, #224]	; (12b80 <TCPIP_IPV4_Initialize+0x100>)
   12aa0:	601a      	str	r2, [r3, #0]
            ipv4ArpHandle = 0;
   12aa2:	2300      	movs	r3, #0
   12aa4:	4a37      	ldr	r2, [pc, #220]	; (12b84 <TCPIP_IPV4_Initialize+0x104>)
   12aa6:	6013      	str	r3, [r2, #0]
            signalHandle = 0;
   12aa8:	4a37      	ldr	r2, [pc, #220]	; (12b88 <TCPIP_IPV4_Initialize+0x108>)
   12aaa:	6013      	str	r3, [r2, #0]
            memset(&ipv4ArpQueue, 0, sizeof(ipv4ArpQueue));
   12aac:	4a37      	ldr	r2, [pc, #220]	; (12b8c <TCPIP_IPV4_Initialize+0x10c>)
   12aae:	6013      	str	r3, [r2, #0]
   12ab0:	6053      	str	r3, [r2, #4]
   12ab2:	6093      	str	r3, [r2, #8]
   12ab4:	60d3      	str	r3, [r2, #12]
   12ab6:	6113      	str	r3, [r2, #16]
            memset(&ipv4ArpPool, 0, sizeof(ipv4ArpPool));
   12ab8:	4a35      	ldr	r2, [pc, #212]	; (12b90 <TCPIP_IPV4_Initialize+0x110>)
   12aba:	6013      	str	r3, [r2, #0]
   12abc:	6053      	str	r3, [r2, #4]
   12abe:	6093      	str	r3, [r2, #8]
            ipv4ArpEntries = 0;
   12ac0:	4a34      	ldr	r2, [pc, #208]	; (12b94 <TCPIP_IPV4_Initialize+0x114>)
   12ac2:	6013      	str	r3, [r2, #0]
            memset(&ipv4PacketFilters, 0, sizeof(ipv4PacketFilters));
   12ac4:	4a34      	ldr	r2, [pc, #208]	; (12b98 <TCPIP_IPV4_Initialize+0x118>)
   12ac6:	6013      	str	r3, [r2, #0]
   12ac8:	6053      	str	r3, [r2, #4]
   12aca:	6093      	str	r3, [r2, #8]
   12acc:	60d3      	str	r3, [r2, #12]
   12ace:	6113      	str	r3, [r2, #16]
            ipv4ActFilterCount = 0;
   12ad0:	4a32      	ldr	r2, [pc, #200]	; (12b9c <TCPIP_IPV4_Initialize+0x11c>)
   12ad2:	6013      	str	r3, [r2, #0]
            if(pIpInit == 0 || pIpInit->arpEntries == 0)
   12ad4:	2900      	cmp	r1, #0
   12ad6:	d03b      	beq.n	12b50 <TCPIP_IPV4_Initialize+0xd0>
   12ad8:	680b      	ldr	r3, [r1, #0]
   12ada:	b94b      	cbnz	r3, 12af0 <TCPIP_IPV4_Initialize+0x70>
                iniRes = TCPIP_IPV4_RES_INIT_VAL_ERR;
   12adc:	f04f 34ff 	mov.w	r4, #4294967295
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, "IPv4 Init: Failed to initalize: %d! \r\n", iniRes);
   12ae0:	f00f fab6 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
   12ae4:	2800      	cmp	r0, #0
   12ae6:	d13f      	bne.n	12b68 <TCPIP_IPV4_Initialize+0xe8>
            TCPIP_IPV4_Cleanup();
   12ae8:	f007 fd48 	bl	1a57c <TCPIP_IPV4_Cleanup>
            return false;
   12aec:	2000      	movs	r0, #0
   12aee:	e7d3      	b.n	12a98 <TCPIP_IPV4_Initialize+0x18>
            signalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_IPV4_Task, 0);
   12af0:	2200      	movs	r2, #0
   12af2:	492b      	ldr	r1, [pc, #172]	; (12ba0 <TCPIP_IPV4_Initialize+0x120>)
   12af4:	2003      	movs	r0, #3
   12af6:	f00a fa63 	bl	1cfc0 <_TCPIPStackSignalHandlerRegister>
   12afa:	4b23      	ldr	r3, [pc, #140]	; (12b88 <TCPIP_IPV4_Initialize+0x108>)
   12afc:	6018      	str	r0, [r3, #0]
            if(signalHandle == 0)
   12afe:	b350      	cbz	r0, 12b56 <TCPIP_IPV4_Initialize+0xd6>
            if(!TCPIP_Helper_ProtectedSingleListInitialize (&ipv4ArpQueue))
   12b00:	4822      	ldr	r0, [pc, #136]	; (12b8c <TCPIP_IPV4_Initialize+0x10c>)
   12b02:	f00d fe60 	bl	207c6 <TCPIP_Helper_ProtectedSingleListInitialize>
   12b06:	b910      	cbnz	r0, 12b0e <TCPIP_IPV4_Initialize+0x8e>
                iniRes = TCPIP_IPV4_RES_ARP_ERR;
   12b08:	f06f 0402 	mvn.w	r4, #2
   12b0c:	e7e8      	b.n	12ae0 <TCPIP_IPV4_Initialize+0x60>
            if(!TCPIP_Notification_Initialize(&ipv4PacketFilters))
   12b0e:	4822      	ldr	r0, [pc, #136]	; (12b98 <TCPIP_IPV4_Initialize+0x118>)
   12b10:	f00f fb39 	bl	22186 <TCPIP_Notification_Initialize>
   12b14:	b310      	cbz	r0, 12b5c <TCPIP_IPV4_Initialize+0xdc>
            ipv4ArpEntries = (IPV4_ARP_ENTRY*)TCPIP_HEAP_Calloc(ipv4MemH, pIpInit->arpEntries , sizeof(*ipv4ArpEntries));
   12b16:	4b1a      	ldr	r3, [pc, #104]	; (12b80 <TCPIP_IPV4_Initialize+0x100>)
   12b18:	6818      	ldr	r0, [r3, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Calloc)(h, nElems, elemSize);
   12b1a:	6883      	ldr	r3, [r0, #8]
   12b1c:	2210      	movs	r2, #16
   12b1e:	6821      	ldr	r1, [r4, #0]
   12b20:	4798      	blx	r3
   12b22:	4b1c      	ldr	r3, [pc, #112]	; (12b94 <TCPIP_IPV4_Initialize+0x114>)
   12b24:	6018      	str	r0, [r3, #0]
            if(ipv4ArpEntries == 0)
   12b26:	b1e0      	cbz	r0, 12b62 <TCPIP_IPV4_Initialize+0xe2>
            TCPIP_Helper_SingleListInitialize(&ipv4ArpPool);
   12b28:	4819      	ldr	r0, [pc, #100]	; (12b90 <TCPIP_IPV4_Initialize+0x110>)
   12b2a:	f00f faf7 	bl	2211c <TCPIP_Helper_SingleListInitialize>
            pEntry = ipv4ArpEntries;
   12b2e:	4b19      	ldr	r3, [pc, #100]	; (12b94 <TCPIP_IPV4_Initialize+0x114>)
   12b30:	681d      	ldr	r5, [r3, #0]
            for(ix = 0; ix < pIpInit->arpEntries; ix++, pEntry++)
   12b32:	6823      	ldr	r3, [r4, #0]
   12b34:	2b00      	cmp	r3, #0
   12b36:	d0aa      	beq.n	12a8e <TCPIP_IPV4_Initialize+0xe>
   12b38:	2600      	movs	r6, #0
                TCPIP_Helper_SingleListTailAdd(&ipv4ArpPool, (SGL_LIST_NODE*)pEntry); 
   12b3a:	4f15      	ldr	r7, [pc, #84]	; (12b90 <TCPIP_IPV4_Initialize+0x110>)
   12b3c:	4629      	mov	r1, r5
   12b3e:	4638      	mov	r0, r7
   12b40:	f00e fbbe 	bl	212c0 <TCPIP_Helper_SingleListTailAdd>
            for(ix = 0; ix < pIpInit->arpEntries; ix++, pEntry++)
   12b44:	3601      	adds	r6, #1
   12b46:	3510      	adds	r5, #16
   12b48:	6823      	ldr	r3, [r4, #0]
   12b4a:	42b3      	cmp	r3, r6
   12b4c:	d8f6      	bhi.n	12b3c <TCPIP_IPV4_Initialize+0xbc>
   12b4e:	e79e      	b.n	12a8e <TCPIP_IPV4_Initialize+0xe>
                iniRes = TCPIP_IPV4_RES_INIT_VAL_ERR;
   12b50:	f04f 34ff 	mov.w	r4, #4294967295
   12b54:	e7c4      	b.n	12ae0 <TCPIP_IPV4_Initialize+0x60>
                iniRes = TCPIP_IPV4_RES_SIGNAL_ERR;
   12b56:	f06f 0401 	mvn.w	r4, #1
   12b5a:	e7c1      	b.n	12ae0 <TCPIP_IPV4_Initialize+0x60>
                iniRes = TCPIP_IPV4_RES_NOTIFY_ERR;
   12b5c:	f06f 0403 	mvn.w	r4, #3
   12b60:	e7be      	b.n	12ae0 <TCPIP_IPV4_Initialize+0x60>
                iniRes = TCPIP_IPV4_RES_MEM_ERR;
   12b62:	f06f 0404 	mvn.w	r4, #4
   12b66:	e7bb      	b.n	12ae0 <TCPIP_IPV4_Initialize+0x60>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, "IPv4 Init: Failed to initalize: %d! \r\n", iniRes);
   12b68:	f00f fa6c 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
   12b6c:	4622      	mov	r2, r4
   12b6e:	490d      	ldr	r1, [pc, #52]	; (12ba4 <TCPIP_IPV4_Initialize+0x124>)
   12b70:	f007 ff94 	bl	1aa9c <SYS_CONSOLE_Print>
   12b74:	e7b8      	b.n	12ae8 <TCPIP_IPV4_Initialize+0x68>
        return true;
   12b76:	2001      	movs	r0, #1
   12b78:	e78e      	b.n	12a98 <TCPIP_IPV4_Initialize+0x18>
   12b7a:	bf00      	nop
   12b7c:	2000e500 	.word	0x2000e500
   12b80:	2000e400 	.word	0x2000e400
   12b84:	2000e3fc 	.word	0x2000e3fc
   12b88:	2000e404 	.word	0x2000e404
   12b8c:	2000e228 	.word	0x2000e228
   12b90:	2000e328 	.word	0x2000e328
   12b94:	2000e3f8 	.word	0x2000e3f8
   12b98:	2000e23c 	.word	0x2000e23c
   12b9c:	2000e3f4 	.word	0x2000e3f4
   12ba0:	0000dc8d 	.word	0x0000dc8d
   12ba4:	00019c68 	.word	0x00019c68

Disassembly of section .text.TCPIP_UDP_OptionsGet%269:

00012ba8 <TCPIP_UDP_OptionsGet>:

// Allows getting options to a socket like enable broadcast, Rx/Tx buffer size, etc
bool TCPIP_UDP_OptionsGet(UDP_SOCKET hUDP, UDP_SOCKET_OPTION option, void* optParam)
{
   12ba8:	b538      	push	{r3, r4, r5, lr}
   12baa:	460d      	mov	r5, r1
   12bac:	4614      	mov	r4, r2
    UDP_SOCKET_DCPT *pSkt = _UDPSocketDcpt(hUDP);
   12bae:	f00d fa39 	bl	20024 <_UDPSocketDcpt>

    if(pSkt && optParam)
   12bb2:	2800      	cmp	r0, #0
   12bb4:	f000 8086 	beq.w	12cc4 <TCPIP_UDP_OptionsGet+0x11c>
   12bb8:	2c00      	cmp	r4, #0
   12bba:	f000 8085 	beq.w	12cc8 <TCPIP_UDP_OptionsGet+0x120>
    {
        switch(option)
   12bbe:	2d0c      	cmp	r5, #12
   12bc0:	f200 8084 	bhi.w	12ccc <TCPIP_UDP_OptionsGet+0x124>
   12bc4:	e8df f005 	tbb	[pc, r5]
   12bc8:	22191007 	.word	0x22191007
   12bcc:	39343029 	.word	0x39343029
   12bd0:	704a453e 	.word	0x704a453e
   12bd4:	77          	.byte	0x77
   12bd5:	00          	.byte	0x00
        {
            case UDP_OPTION_STRICT_PORT:
                *(bool*)optParam = pSkt->flags.looseRemPort == 0;
   12bd6:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   12bda:	f083 0304 	eor.w	r3, r3, #4
   12bde:	f3c3 0380 	ubfx	r3, r3, #2, #1
   12be2:	7023      	strb	r3, [r4, #0]
                return true;
   12be4:	2001      	movs	r0, #1
   12be6:	e06e      	b.n	12cc6 <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_STRICT_NET:
                *(bool*)optParam = pSkt->flags.looseNetIf == 0;
   12be8:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   12bec:	f083 0308 	eor.w	r3, r3, #8
   12bf0:	f3c3 03c0 	ubfx	r3, r3, #3, #1
   12bf4:	7023      	strb	r3, [r4, #0]
                return true;
   12bf6:	2001      	movs	r0, #1
   12bf8:	e065      	b.n	12cc6 <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_STRICT_ADDRESS:
                *(bool*)optParam = pSkt->flags.looseRemAddress == 0;
   12bfa:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   12bfe:	f083 0310 	eor.w	r3, r3, #16
   12c02:	f3c3 1300 	ubfx	r3, r3, #4, #1
   12c06:	7023      	strb	r3, [r4, #0]
                return true;
   12c08:	2001      	movs	r0, #1
   12c0a:	e05c      	b.n	12cc6 <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_BROADCAST:
                *(UDP_SOCKET_BCAST_TYPE*)optParam = (UDP_SOCKET_BCAST_TYPE)pSkt->flags.bcastForceType;
   12c0c:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   12c10:	f3c3 0301 	ubfx	r3, r3, #0, #2
   12c14:	7023      	strb	r3, [r4, #0]
                return true;
   12c16:	2001      	movs	r0, #1
   12c18:	e055      	b.n	12cc6 <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_BUFFER_POOL:
                *(bool*)optParam = pSkt->flags.usePool != 0;
   12c1a:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
   12c1e:	f3c3 0380 	ubfx	r3, r3, #2, #1
   12c22:	7023      	strb	r3, [r4, #0]
                return true;
   12c24:	2001      	movs	r0, #1
   12c26:	e04e      	b.n	12cc6 <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_TX_BUFF:
                *(uint16_t*)optParam = pSkt->txSize;
   12c28:	8a03      	ldrh	r3, [r0, #16]
   12c2a:	8023      	strh	r3, [r4, #0]
                return true;
   12c2c:	2001      	movs	r0, #1
   12c2e:	e04a      	b.n	12cc6 <TCPIP_UDP_OptionsGet+0x11e>
                
            case UDP_OPTION_TX_QUEUE_LIMIT:
                *(uint8_t*)optParam = pSkt->txAllocLimit;
   12c30:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
   12c34:	7023      	strb	r3, [r4, #0]
                return true;
   12c36:	2001      	movs	r0, #1
   12c38:	e045      	b.n	12cc6 <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_RX_QUEUE_LIMIT:
                *(uint8_t*)optParam = pSkt->rxQueueLimit;
   12c3a:	f890 305a 	ldrb.w	r3, [r0, #90]	; 0x5a
   12c3e:	7023      	strb	r3, [r4, #0]
                return true;
   12c40:	2001      	movs	r0, #1
   12c42:	e040      	b.n	12cc6 <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_RX_AUTO_ADVANCE:
                *(bool*)optParam = pSkt->extFlags.rxAutoAdvance != 0;
   12c44:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   12c48:	f003 0301 	and.w	r3, r3, #1
   12c4c:	7023      	strb	r3, [r4, #0]
                return true;
   12c4e:	2001      	movs	r0, #1
   12c50:	e039      	b.n	12cc6 <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_TX_TTL:
                *(uint8_t*)optParam = pSkt->ttl;
   12c52:	f890 305b 	ldrb.w	r3, [r0, #91]	; 0x5b
   12c56:	7023      	strb	r3, [r4, #0]
                return true;
   12c58:	2001      	movs	r0, #1
   12c5a:	e034      	b.n	12cc6 <TCPIP_UDP_OptionsGet+0x11e>
                    UDP_MULTICAST_FLAGS* pMcFlags = (UDP_MULTICAST_FLAGS*)optParam;
                    if(pMcFlags!= 0)
                    {
                        UDP_MULTICAST_FLAGS mcFlags = 0;

                        if(pSkt->flags.looseNetIf == 1 && pSkt->flags.looseRemAddress == 1 && pSkt->flags.looseRemPort == 1)
   12c5c:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
   12c60:	f002 021c 	and.w	r2, r2, #28
                        UDP_MULTICAST_FLAGS mcFlags = 0;
   12c64:	2a1c      	cmp	r2, #28
   12c66:	bf14      	ite	ne
   12c68:	2200      	movne	r2, #0
   12c6a:	2201      	moveq	r2, #1
                        {
                            mcFlags |= UDP_MCAST_FLAG_LOOSE_NET_SOURCE_PORT;
                        }
                        if(pSkt->extFlags.ignoreSrcAdd != 0)
   12c6c:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   12c70:	f013 0f10 	tst.w	r3, #16
                        {
                            mcFlags |= UDP_MCAST_FLAG_IGNORE_SOURCE_ADD;
   12c74:	bf18      	it	ne
   12c76:	f042 0202 	orrne.w	r2, r2, #2
                        }
                        if(pSkt->extFlags.ignoreSrcPort != 0)
   12c7a:	f013 0f20 	tst.w	r3, #32
                        {
                            mcFlags |= UDP_MCAST_FLAG_IGNORE_SOURCE_PORT;
   12c7e:	bf18      	it	ne
   12c80:	f042 0204 	orrne.w	r2, r2, #4
                        }
                        if(pSkt->extFlags.mcastOnly != 0)
   12c84:	f013 0f40 	tst.w	r3, #64	; 0x40
                        {
                            mcFlags |= UDP_MCAST_FLAG_IGNORE_UNICAST;
   12c88:	bf18      	it	ne
   12c8a:	f042 0208 	orrne.w	r2, r2, #8
                        }
                        if(pSkt->extFlags.mcastLoop != 0)
   12c8e:	f013 0f04 	tst.w	r3, #4
                        {
                            mcFlags |= UDP_MCAST_FLAG_LOOP;
   12c92:	bf18      	it	ne
   12c94:	f042 0210 	orrne.w	r2, r2, #16
                        }
                        if(pSkt->extFlags.mcastSkipCheck != 0)
   12c98:	f013 0f08 	tst.w	r3, #8
                        {
                            mcFlags |= UDP_MCAST_FLAG_DISABLE_SOURCE_CHECK;
   12c9c:	bf18      	it	ne
   12c9e:	f042 0220 	orrne.w	r2, r2, #32
                        }

                        *pMcFlags = mcFlags;
   12ca2:	7022      	strb	r2, [r4, #0]
                        return true;
   12ca4:	2001      	movs	r0, #1
   12ca6:	e00e      	b.n	12cc6 <TCPIP_UDP_OptionsGet+0x11e>
                }

                return false;

             case UDP_OPTION_TOS:
                *(uint8_t*)optParam = pSkt->extFlags.tos;
   12ca8:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
   12cac:	f3c3 0305 	ubfx	r3, r3, #0, #6
   12cb0:	7023      	strb	r3, [r4, #0]
                return true;
   12cb2:	2001      	movs	r0, #1
   12cb4:	e007      	b.n	12cc6 <TCPIP_UDP_OptionsGet+0x11e>
                
             case UDP_OPTION_DF:
                *(bool*)optParam = pSkt->extFlags.df != 0;
   12cb6:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
   12cba:	f3c3 1380 	ubfx	r3, r3, #6, #1
   12cbe:	7023      	strb	r3, [r4, #0]
                return true;
   12cc0:	2001      	movs	r0, #1
   12cc2:	e000      	b.n	12cc6 <TCPIP_UDP_OptionsGet+0x11e>
           default:
                break;
        }
    }    

    return false;
   12cc4:	2000      	movs	r0, #0
}
   12cc6:	bd38      	pop	{r3, r4, r5, pc}
    return false;
   12cc8:	2000      	movs	r0, #0
   12cca:	e7fc      	b.n	12cc6 <TCPIP_UDP_OptionsGet+0x11e>
   12ccc:	2000      	movs	r0, #0
   12cce:	e7fa      	b.n	12cc6 <TCPIP_UDP_OptionsGet+0x11e>

Disassembly of section .rodata%270:

00012cd0 <.rodata%270>:
   12cd0:	6b636f52 	.word	0x6b636f52
   12cd4:	646e6120 	.word	0x646e6120
   12cd8:	6c6f5220 	.word	0x6c6f5220
   12cdc:	20200a6c 	.word	0x20200a6c
   12ce0:	3e3d3d20 	.word	0x3e3d3d20
   12ce4:	3d3d3c20 	.word	0x3d3d3c20
   12ce8:	20202020 	.word	0x20202020
   12cec:	00000000 	.word	0x00000000
   12cf0:	6f4c203e 	.word	0x6f4c203e
   12cf4:	206c6163 	.word	0x206c6163
   12cf8:	6d69696d 	.word	0x6d69696d
   12cfc:	65706f20 	.word	0x65706f20
   12d00:	66203a6e 	.word	0x66203a6e
   12d04:	656c6961 	.word	0x656c6961
   12d08:	0a0d2164 	.word	0x0a0d2164
   12d0c:	00000000 	.word	0x00000000
   12d10:	6f4c203e 	.word	0x6f4c203e
   12d14:	206c6163 	.word	0x206c6163
   12d18:	6d69696d 	.word	0x6d69696d
   12d1c:	74657320 	.word	0x74657320
   12d20:	203a7075 	.word	0x203a7075
   12d24:	6c696166 	.word	0x6c696166
   12d28:	0d216465 	.word	0x0d216465
   12d2c:	0000000a 	.word	0x0000000a
   12d30:	694d203e 	.word	0x694d203e
   12d34:	53206d69 	.word	0x53206d69
   12d38:	65636375 	.word	0x65636375
   12d3c:	75667373 	.word	0x75667373
   12d40:	20796c6c 	.word	0x20796c6c
   12d44:	6e65706f 	.word	0x6e65706f
   12d48:	202e6465 	.word	0x202e6465
   12d4c:	00000a0d 	.word	0x00000a0d
   12d50:	6f727245 	.word	0x6f727245
   12d54:	636f2072 	.word	0x636f2072
   12d58:	65727563 	.word	0x65727563
   12d5c:	64253a64 	.word	0x64253a64
   12d60:	00000a0d 	.word	0x00000a0d
   12d64:	6e614c20 	.word	0x6e614c20
   12d68:	78373638 	.word	0x78373638
   12d6c:	20736920 	.word	0x20736920
   12d70:	50206e69 	.word	0x50206e69
   12d74:	2041434c 	.word	0x2041434c
   12d78:	65646f6d 	.word	0x65646f6d
   12d7c:	0a0d202e 	.word	0x0a0d202e
   12d80:	00000000 	.word	0x00000000
   12d84:	6e614c20 	.word	0x6e614c20
   12d88:	78373638 	.word	0x78373638
   12d8c:	20736920 	.word	0x20736920
   12d90:	43206e69 	.word	0x43206e69
   12d94:	20414d53 	.word	0x20414d53
   12d98:	65646f6d 	.word	0x65646f6d
   12d9c:	0a0d202e 	.word	0x0a0d202e
   12da0:	00000000 	.word	0x00000000
   12da4:	646f4e20 	.word	0x646f4e20
   12da8:	64492065 	.word	0x64492065
   12dac:	6425203a 	.word	0x6425203a
   12db0:	6f4e202c 	.word	0x6f4e202c
   12db4:	63206564 	.word	0x63206564
   12db8:	746e756f 	.word	0x746e756f
   12dbc:	6425203a 	.word	0x6425203a
   12dc0:	0a0d202e 	.word	0x0a0d202e
   12dc4:	00000000 	.word	0x00000000
   12dc8:	694d203e 	.word	0x694d203e
   12dcc:	63206d69 	.word	0x63206d69
   12dd0:	65736f6c 	.word	0x65736f6c
   12dd4:	0d202e64 	.word	0x0d202e64
   12dd8:	0000000a 	.word	0x0000000a
   12ddc:	3a707041 	.word	0x3a707041
   12de0:	69696d20 	.word	0x69696d20
   12de4:	6573206d 	.word	0x6573206d
   12de8:	20707574 	.word	0x20707574
   12dec:	6c696166 	.word	0x6c696166
   12df0:	21206465 	.word	0x21206465
   12df4:	0a0d      	.short	0x0a0d
	...

Disassembly of section .text.TCPIP_UDP_Bind%271:

00012df8 <TCPIP_UDP_Bind>:
{
   12df8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12dfc:	460d      	mov	r5, r1
   12dfe:	4616      	mov	r6, r2
   12e00:	461f      	mov	r7, r3
    pSkt = _UDPSocketDcpt(s);
   12e02:	f00d f90f 	bl	20024 <_UDPSocketDcpt>
    if(pSkt == 0)
   12e06:	2800      	cmp	r0, #0
   12e08:	d07d      	beq.n	12f06 <TCPIP_UDP_Bind+0x10e>
   12e0a:	4604      	mov	r4, r0
    oldAddType = pSkt->addType;
   12e0c:	f8b0 803c 	ldrh.w	r8, [r0, #60]	; 0x3c
   12e10:	fa5f f288 	uxtb.w	r2, r8
    if(addType == IP_ADDRESS_TYPE_ANY)
   12e14:	bb65      	cbnz	r5, 12e70 <TCPIP_UDP_Bind+0x78>
        if(oldAddType != IP_ADDRESS_TYPE_ANY)
   12e16:	2a00      	cmp	r2, #0
   12e18:	d177      	bne.n	12f0a <TCPIP_UDP_Bind+0x112>
        localAddress = 0;
   12e1a:	2700      	movs	r7, #0
    pSktIf = 0;
   12e1c:	46ba      	mov	sl, r7
    OSAL_SEM_Pend(&userSem, OSAL_WAIT_FOREVER);
   12e1e:	f64f 71ff 	movw	r1, #65535	; 0xffff
   12e22:	483d      	ldr	r0, [pc, #244]	; (12f18 <TCPIP_UDP_Bind+0x120>)
   12e24:	f00d ffbe 	bl	20da4 <OSAL_SEM_Pend>
    if(localPort == 0)
   12e28:	2e00      	cmp	r6, #0
   12e2a:	d146      	bne.n	12eba <TCPIP_UDP_Bind+0xc2>
        if((localPort = pSkt->localPort) == 0)
   12e2c:	8d66      	ldrh	r6, [r4, #42]	; 0x2a
   12e2e:	2e00      	cmp	r6, #0
   12e30:	d03b      	beq.n	12eaa <TCPIP_UDP_Bind+0xb2>
    OSAL_SEM_Post(&userSem);
   12e32:	4839      	ldr	r0, [pc, #228]	; (12f18 <TCPIP_UDP_Bind+0x120>)
   12e34:	f00e fbce 	bl	215d4 <OSAL_SEM_Post>
    pSkt->extFlags.rxEnable = 0;
   12e38:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   12e3c:	f36f 0341 	bfc	r3, #1, #1
   12e40:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    pSkt->addType = addType;
   12e44:	87a5      	strh	r5, [r4, #60]	; 0x3c
    if((pSkt->pSktNet = pNet) != 0)
   12e46:	f8c4 a024 	str.w	sl, [r4, #36]	; 0x24
   12e4a:	f1ba 0f00 	cmp.w	sl, #0
   12e4e:	d005      	beq.n	12e5c <TCPIP_UDP_Bind+0x64>
        pSkt->flags.looseNetIf = 0;
   12e50:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
   12e54:	f36f 03c3 	bfc	r3, #3, #1
   12e58:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    if(localAddress == 0)
   12e5c:	2f00      	cmp	r7, #0
   12e5e:	d049      	beq.n	12ef4 <TCPIP_UDP_Bind+0xfc>
        if (addType == IP_ADDRESS_TYPE_IPV4)
   12e60:	2d01      	cmp	r5, #1
   12e62:	d03d      	beq.n	12ee0 <TCPIP_UDP_Bind+0xe8>
        pSkt->addType = oldAddType;
   12e64:	fa5f f888 	uxtb.w	r8, r8
   12e68:	f8a4 803c 	strh.w	r8, [r4, #60]	; 0x3c
    bindSuccess = _UDPSocketBind(pSkt, pSktIf, localAddress);
   12e6c:	2000      	movs	r0, #0
   12e6e:	e043      	b.n	12ef8 <TCPIP_UDP_Bind+0x100>
        if(addType != IP_ADDRESS_TYPE_IPV4 && addType != IP_ADDRESS_TYPE_IPV6) 
   12e70:	1e6b      	subs	r3, r5, #1
   12e72:	b2db      	uxtb	r3, r3
   12e74:	2b01      	cmp	r3, #1
   12e76:	d84a      	bhi.n	12f0e <TCPIP_UDP_Bind+0x116>
        if(oldAddType != IP_ADDRESS_TYPE_ANY && oldAddType != addType)
   12e78:	b10a      	cbz	r2, 12e7e <TCPIP_UDP_Bind+0x86>
   12e7a:	42aa      	cmp	r2, r5
   12e7c:	d149      	bne.n	12f12 <TCPIP_UDP_Bind+0x11a>
    if(localAddress != 0)
   12e7e:	b197      	cbz	r7, 12ea6 <TCPIP_UDP_Bind+0xae>
        if (addType == IP_ADDRESS_TYPE_IPV4 && localAddress->v4Add.Val != 0)
   12e80:	2d01      	cmp	r5, #1
   12e82:	d002      	beq.n	12e8a <TCPIP_UDP_Bind+0x92>
    pSktIf = 0;
   12e84:	f04f 0a00 	mov.w	sl, #0
   12e88:	e7c9      	b.n	12e1e <TCPIP_UDP_Bind+0x26>
        if (addType == IP_ADDRESS_TYPE_IPV4 && localAddress->v4Add.Val != 0)
   12e8a:	683b      	ldr	r3, [r7, #0]
   12e8c:	b913      	cbnz	r3, 12e94 <TCPIP_UDP_Bind+0x9c>
    pSktIf = 0;
   12e8e:	f04f 0a00 	mov.w	sl, #0
   12e92:	e7c4      	b.n	12e1e <TCPIP_UDP_Bind+0x26>
            if((pSktIf = TCPIP_STACK_IPAddToNet(&localAddress->v4Add, false)) == 0)
   12e94:	2100      	movs	r1, #0
   12e96:	4638      	mov	r0, r7
   12e98:	f00d fb3c 	bl	20514 <TCPIP_STACK_IPAddToNet>
   12e9c:	4682      	mov	sl, r0
   12e9e:	2800      	cmp	r0, #0
   12ea0:	d1bd      	bne.n	12e1e <TCPIP_UDP_Bind+0x26>
                return false;
   12ea2:	2000      	movs	r0, #0
   12ea4:	e01a      	b.n	12edc <TCPIP_UDP_Bind+0xe4>
    pSktIf = 0;
   12ea6:	46ba      	mov	sl, r7
   12ea8:	e7b9      	b.n	12e1e <TCPIP_UDP_Bind+0x26>
            localPort = _UDPAllocateEphemeralPort();
   12eaa:	f00b fca3 	bl	1e7f4 <_UDPAllocateEphemeralPort>
            if(localPort == 0)
   12eae:	4606      	mov	r6, r0
   12eb0:	fab0 f980 	clz	r9, r0
   12eb4:	ea4f 1959 	mov.w	r9, r9, lsr #5
   12eb8:	e009      	b.n	12ece <TCPIP_UDP_Bind+0xd6>
    else if(localPort != pSkt->localPort && _UDPIsAvailablePort(localPort) == false)
   12eba:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
   12ebc:	42b3      	cmp	r3, r6
   12ebe:	d0b8      	beq.n	12e32 <TCPIP_UDP_Bind+0x3a>
   12ec0:	4630      	mov	r0, r6
   12ec2:	f00a feb7 	bl	1dc34 <_UDPIsAvailablePort>
   12ec6:	f080 0001 	eor.w	r0, r0, #1
   12eca:	fa5f f980 	uxtb.w	r9, r0
    OSAL_SEM_Post(&userSem);
   12ece:	4812      	ldr	r0, [pc, #72]	; (12f18 <TCPIP_UDP_Bind+0x120>)
   12ed0:	f00e fb80 	bl	215d4 <OSAL_SEM_Post>
        return false;
   12ed4:	2000      	movs	r0, #0
    if(portFail)
   12ed6:	f1b9 0f00 	cmp.w	r9, #0
   12eda:	d0ad      	beq.n	12e38 <TCPIP_UDP_Bind+0x40>
}
   12edc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            pSkt->srcAddress.Val = localAddress->v4Add.Val;
   12ee0:	683b      	ldr	r3, [r7, #0]
   12ee2:	61a3      	str	r3, [r4, #24]
            pSkt->flags.srcSet = 1;
   12ee4:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
            pSkt->flags.srcSolved = 0;
   12ee8:	f043 0360 	orr.w	r3, r3, #96	; 0x60
   12eec:	f36f 13c7 	bfc	r3, #7, #1
   12ef0:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        pSkt->localPort = localPort;
   12ef4:	8566      	strh	r6, [r4, #42]	; 0x2a
   12ef6:	2001      	movs	r0, #1
    pSkt->extFlags.rxEnable = 1;
   12ef8:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   12efc:	f043 0302 	orr.w	r3, r3, #2
   12f00:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    return bindSuccess;
   12f04:	e7ea      	b.n	12edc <TCPIP_UDP_Bind+0xe4>
        return false;
   12f06:	2000      	movs	r0, #0
   12f08:	e7e8      	b.n	12edc <TCPIP_UDP_Bind+0xe4>
            return false;
   12f0a:	2000      	movs	r0, #0
   12f0c:	e7e6      	b.n	12edc <TCPIP_UDP_Bind+0xe4>
            return false;
   12f0e:	2000      	movs	r0, #0
   12f10:	e7e4      	b.n	12edc <TCPIP_UDP_Bind+0xe4>
            return false;
   12f12:	2000      	movs	r0, #0
   12f14:	e7e2      	b.n	12edc <TCPIP_UDP_Bind+0xe4>
   12f16:	bf00      	nop
   12f18:	2000e468 	.word	0x2000e468

Disassembly of section .text.xQueueGenericSend%272:

00012f1c <xQueueGenericSend>:
{
   12f1c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12f20:	b084      	sub	sp, #16
   12f22:	4604      	mov	r4, r0
   12f24:	4688      	mov	r8, r1
   12f26:	9201      	str	r2, [sp, #4]
   12f28:	461d      	mov	r5, r3
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
   12f2a:	f04f 0900 	mov.w	r9, #0
		prvLockQueue( pxQueue );
   12f2e:	464e      	mov	r6, r9
					portYIELD_WITHIN_API();
   12f30:	4f42      	ldr	r7, [pc, #264]	; (1303c <xQueueGenericSend+0x120>)
   12f32:	e033      	b.n	12f9c <xQueueGenericSend+0x80>
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   12f34:	462a      	mov	r2, r5
   12f36:	4641      	mov	r1, r8
   12f38:	4620      	mov	r0, r4
   12f3a:	f006 ffc0 	bl	19ebe <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   12f3e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   12f40:	b973      	cbnz	r3, 12f60 <xQueueGenericSend+0x44>
					else if( xYieldRequired != pdFALSE )
   12f42:	b138      	cbz	r0, 12f54 <xQueueGenericSend+0x38>
						queueYIELD_IF_USING_PREEMPTION();
   12f44:	4b3d      	ldr	r3, [pc, #244]	; (1303c <xQueueGenericSend+0x120>)
   12f46:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   12f4a:	601a      	str	r2, [r3, #0]
   12f4c:	f3bf 8f4f 	dsb	sy
   12f50:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
   12f54:	f00e fd44 	bl	219e0 <vPortExitCritical>
				return pdPASS;
   12f58:	2001      	movs	r0, #1
}
   12f5a:	b004      	add	sp, #16
   12f5c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   12f60:	f104 0024 	add.w	r0, r4, #36	; 0x24
   12f64:	f007 f908 	bl	1a178 <xTaskRemoveFromEventList>
   12f68:	2800      	cmp	r0, #0
   12f6a:	d0f3      	beq.n	12f54 <xQueueGenericSend+0x38>
							queueYIELD_IF_USING_PREEMPTION();
   12f6c:	4b33      	ldr	r3, [pc, #204]	; (1303c <xQueueGenericSend+0x120>)
   12f6e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   12f72:	601a      	str	r2, [r3, #0]
   12f74:	f3bf 8f4f 	dsb	sy
   12f78:	f3bf 8f6f 	isb	sy
   12f7c:	e7ea      	b.n	12f54 <xQueueGenericSend+0x38>
					taskEXIT_CRITICAL();
   12f7e:	f00e fd2f 	bl	219e0 <vPortExitCritical>
					return errQUEUE_FULL;
   12f82:	2000      	movs	r0, #0
   12f84:	e7e9      	b.n	12f5a <xQueueGenericSend+0x3e>
					vTaskInternalSetTimeOutState( &xTimeOut );
   12f86:	a802      	add	r0, sp, #8
   12f88:	f00e fbcc 	bl	21724 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   12f8c:	e014      	b.n	12fb8 <xQueueGenericSend+0x9c>
				prvUnlockQueue( pxQueue );
   12f8e:	4620      	mov	r0, r4
   12f90:	f006 fbc6 	bl	19720 <prvUnlockQueue>
				( void ) xTaskResumeAll();
   12f94:	f002 f916 	bl	151c4 <xTaskResumeAll>
   12f98:	f04f 0901 	mov.w	r9, #1
		taskENTER_CRITICAL();
   12f9c:	f00d fe58 	bl	20c50 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   12fa0:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   12fa2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   12fa4:	429a      	cmp	r2, r3
   12fa6:	d3c5      	bcc.n	12f34 <xQueueGenericSend+0x18>
   12fa8:	2d02      	cmp	r5, #2
   12faa:	d0c3      	beq.n	12f34 <xQueueGenericSend+0x18>
				if( xTicksToWait == ( TickType_t ) 0 )
   12fac:	9b01      	ldr	r3, [sp, #4]
   12fae:	2b00      	cmp	r3, #0
   12fb0:	d0e5      	beq.n	12f7e <xQueueGenericSend+0x62>
				else if( xEntryTimeSet == pdFALSE )
   12fb2:	f1b9 0f00 	cmp.w	r9, #0
   12fb6:	d0e6      	beq.n	12f86 <xQueueGenericSend+0x6a>
		taskEXIT_CRITICAL();
   12fb8:	f00e fd12 	bl	219e0 <vPortExitCritical>
		vTaskSuspendAll();
   12fbc:	f00e fe3e 	bl	21c3c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   12fc0:	f00d fe46 	bl	20c50 <vPortEnterCritical>
   12fc4:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
   12fc8:	b25b      	sxtb	r3, r3
   12fca:	f1b3 3fff 	cmp.w	r3, #4294967295
   12fce:	bf08      	it	eq
   12fd0:	f884 6044 	strbeq.w	r6, [r4, #68]	; 0x44
   12fd4:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
   12fd8:	b25b      	sxtb	r3, r3
   12fda:	f1b3 3fff 	cmp.w	r3, #4294967295
   12fde:	bf08      	it	eq
   12fe0:	f884 6045 	strbeq.w	r6, [r4, #69]	; 0x45
   12fe4:	f00e fcfc 	bl	219e0 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   12fe8:	a901      	add	r1, sp, #4
   12fea:	a802      	add	r0, sp, #8
   12fec:	f008 fd82 	bl	1baf4 <xTaskCheckForTimeOut>
   12ff0:	b9e8      	cbnz	r0, 1302e <xQueueGenericSend+0x112>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
   12ff2:	f00d fe2d 	bl	20c50 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   12ff6:	f8d4 a038 	ldr.w	sl, [r4, #56]	; 0x38
   12ffa:	f8d4 903c 	ldr.w	r9, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
   12ffe:	f00e fcef 	bl	219e0 <vPortExitCritical>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
   13002:	45ca      	cmp	sl, r9
   13004:	d1c3      	bne.n	12f8e <xQueueGenericSend+0x72>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
   13006:	9901      	ldr	r1, [sp, #4]
   13008:	f104 0010 	add.w	r0, r4, #16
   1300c:	f00e f88e 	bl	2112c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
   13010:	4620      	mov	r0, r4
   13012:	f006 fb85 	bl	19720 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
   13016:	f002 f8d5 	bl	151c4 <xTaskResumeAll>
   1301a:	2800      	cmp	r0, #0
   1301c:	d1bc      	bne.n	12f98 <xQueueGenericSend+0x7c>
					portYIELD_WITHIN_API();
   1301e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   13022:	603b      	str	r3, [r7, #0]
   13024:	f3bf 8f4f 	dsb	sy
   13028:	f3bf 8f6f 	isb	sy
   1302c:	e7b4      	b.n	12f98 <xQueueGenericSend+0x7c>
			prvUnlockQueue( pxQueue );
   1302e:	4620      	mov	r0, r4
   13030:	f006 fb76 	bl	19720 <prvUnlockQueue>
			( void ) xTaskResumeAll();
   13034:	f002 f8c6 	bl	151c4 <xTaskResumeAll>
			return errQUEUE_FULL;
   13038:	2000      	movs	r0, #0
   1303a:	e78e      	b.n	12f5a <xQueueGenericSend+0x3e>
   1303c:	e000ed04 	.word	0xe000ed04

Disassembly of section .text.DRV_GMAC_Tasks%273:

00013040 <DRV_GMAC_Tasks>:
{
   13040:	b538      	push	{r3, r4, r5, lr}
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   13042:	4b43      	ldr	r3, [pc, #268]	; (13150 <DRV_GMAC_Tasks+0x110>)
   13044:	4283      	cmp	r3, r0
   13046:	d135      	bne.n	130b4 <DRV_GMAC_Tasks+0x74>
    if(pMACDrv == 0 || (pMACDrv->sGmacData._macFlags._init == 0))
   13048:	2800      	cmp	r0, #0
   1304a:	d033      	beq.n	130b4 <DRV_GMAC_Tasks+0x74>
   1304c:	7d9b      	ldrb	r3, [r3, #22]
   1304e:	f013 0f01 	tst.w	r3, #1
   13052:	d02f      	beq.n	130b4 <DRV_GMAC_Tasks+0x74>
	pPhyBase =  pMACDrv->sGmacData.gmacConfig.pPhyBase;
   13054:	4c3e      	ldr	r4, [pc, #248]	; (13150 <DRV_GMAC_Tasks+0x110>)
   13056:	f8d4 50d8 	ldr.w	r5, [r4, #216]	; 0xd8
	pPhyBase->DRV_ETHPHY_Tasks(pMACDrv->sGmacData.hPhySysObject);
   1305a:	692b      	ldr	r3, [r5, #16]
   1305c:	68e0      	ldr	r0, [r4, #12]
   1305e:	4798      	blx	r3
	switch(pMACDrv->sGmacData.sysStat)
   13060:	f994 3014 	ldrsb.w	r3, [r4, #20]
   13064:	2b01      	cmp	r3, #1
   13066:	d026      	beq.n	130b6 <DRV_GMAC_Tasks+0x76>
            if(((pMACDrv->sGmacData._controlFlags & TCPIP_MAC_CONTROL_NO_LINK_CHECK) == 0 && pMACDrv->sGmacData._macFlags._linkPrev == false) ||
   13068:	4b39      	ldr	r3, [pc, #228]	; (13150 <DRV_GMAC_Tasks+0x110>)
   1306a:	f8b3 30f4 	ldrh.w	r3, [r3, #244]	; 0xf4
   1306e:	f013 0f04 	tst.w	r3, #4
   13072:	d104      	bne.n	1307e <DRV_GMAC_Tasks+0x3e>
   13074:	4b36      	ldr	r3, [pc, #216]	; (13150 <DRV_GMAC_Tasks+0x110>)
   13076:	7d9b      	ldrb	r3, [r3, #22]
   13078:	f013 0f10 	tst.w	r3, #16
   1307c:	d004      	beq.n	13088 <DRV_GMAC_Tasks+0x48>
                    (pMACDrv->sGmacData._txDiscard == true))
   1307e:	4b34      	ldr	r3, [pc, #208]	; (13150 <DRV_GMAC_Tasks+0x110>)
            if(((pMACDrv->sGmacData._controlFlags & TCPIP_MAC_CONTROL_NO_LINK_CHECK) == 0 && pMACDrv->sGmacData._macFlags._linkPrev == false) ||
   13080:	f893 30f7 	ldrb.w	r3, [r3, #247]	; 0xf7
   13084:	2b01      	cmp	r3, #1
   13086:	d115      	bne.n	130b4 <DRV_GMAC_Tasks+0x74>
	if(pMACDrv->sGmacData._synchF != 0)
   13088:	4b31      	ldr	r3, [pc, #196]	; (13150 <DRV_GMAC_Tasks+0x110>)
   1308a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   1308c:	b113      	cbz	r3, 13094 <DRV_GMAC_Tasks+0x54>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_LOCK);
   1308e:	2103      	movs	r1, #3
   13090:	4830      	ldr	r0, [pc, #192]	; (13154 <DRV_GMAC_Tasks+0x114>)
   13092:	4798      	blx	r3
                _MacTxDiscardQueues(pMACDrv, TCPIP_MAC_PKT_ACK_LINK_DOWN); 
   13094:	4c2e      	ldr	r4, [pc, #184]	; (13150 <DRV_GMAC_Tasks+0x110>)
   13096:	f04f 31ff 	mov.w	r1, #4294967295
   1309a:	4620      	mov	r0, r4
   1309c:	f00a fa0e 	bl	1d4bc <_MacTxDiscardQueues>
	if(pMACDrv->sGmacData._synchF != 0)
   130a0:	6b23      	ldr	r3, [r4, #48]	; 0x30
   130a2:	b11b      	cbz	r3, 130ac <DRV_GMAC_Tasks+0x6c>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_UNLOCK);
   130a4:	2104      	movs	r1, #4
   130a6:	f104 0060 	add.w	r0, r4, #96	; 0x60
   130aa:	4798      	blx	r3
                pMACDrv->sGmacData._txDiscard = false;
   130ac:	4b28      	ldr	r3, [pc, #160]	; (13150 <DRV_GMAC_Tasks+0x110>)
   130ae:	2200      	movs	r2, #0
   130b0:	f883 20f7 	strb.w	r2, [r3, #247]	; 0xf7
}
   130b4:	bd38      	pop	{r3, r4, r5, pc}
            hPhyClient = pMACDrv->sGmacData.hPhyClient;
   130b6:	6924      	ldr	r4, [r4, #16]
            phyStat = pPhyBase->DRV_ETHPHY_ClientStatus(hPhyClient);
   130b8:	69eb      	ldr	r3, [r5, #28]
   130ba:	4620      	mov	r0, r4
   130bc:	4798      	blx	r3
            if(phyStat == DRV_ETHPHY_CLIENT_STATUS_BUSY)
   130be:	2801      	cmp	r0, #1
   130c0:	d0f8      	beq.n	130b4 <DRV_GMAC_Tasks+0x74>
            phyInitRes = pPhyBase->DRV_ETHPHY_ClientOperationResult(hPhyClient);
   130c2:	6a2b      	ldr	r3, [r5, #32]
   130c4:	4620      	mov	r0, r4
   130c6:	4798      	blx	r3
            if ( phyInitRes != DRV_ETHPHY_RES_OK)
   130c8:	4604      	mov	r4, r0
   130ca:	bb28      	cbnz	r0, 13118 <DRV_GMAC_Tasks+0xd8>
            pMACDrv->sGmacData._macFlags._linkPresent = 1;
   130cc:	4b20      	ldr	r3, [pc, #128]	; (13150 <DRV_GMAC_Tasks+0x110>)
   130ce:	7d9a      	ldrb	r2, [r3, #22]
   130d0:	f042 0204 	orr.w	r2, r2, #4
   130d4:	759a      	strb	r2, [r3, #22]
            if((pMACDrv->sGmacData.gmacConfig.ethFlags & TCPIP_ETH_OPEN_AUTO) != 0)
   130d6:	f8b3 30d2 	ldrh.w	r3, [r3, #210]	; 0xd2
   130da:	f013 0f01 	tst.w	r3, #1
   130de:	d02c      	beq.n	1313a <DRV_GMAC_Tasks+0xfa>
                pMACDrv->sGmacData._macFlags._linkNegotiation = 1;	// performing the negotiation
   130e0:	4a1b      	ldr	r2, [pc, #108]	; (13150 <DRV_GMAC_Tasks+0x110>)
   130e2:	7d93      	ldrb	r3, [r2, #22]
   130e4:	f043 0308 	orr.w	r3, r3, #8
   130e8:	7593      	strb	r3, [r2, #22]
            pMACDrv->sGmacData._linkUpTick = SYS_TMR_TickCountGet();     // the initialization time
   130ea:	f00c ffff 	bl	200ec <SYS_TMR_TickCountGet>
   130ee:	4c18      	ldr	r4, [pc, #96]	; (13150 <DRV_GMAC_Tasks+0x110>)
   130f0:	63a0      	str	r0, [r4, #56]	; 0x38
            pMACDrv->sGmacData._linkWaitTick = ((SYS_TMR_TickCounterFrequencyGet() * pMACDrv->sGmacData.gmacConfig.linkInitDelay) + 999 ) / 1000;
   130f2:	f00d f823 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
   130f6:	f8b4 30d0 	ldrh.w	r3, [r4, #208]	; 0xd0
   130fa:	fb00 f303 	mul.w	r3, r0, r3
   130fe:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
   13102:	4a15      	ldr	r2, [pc, #84]	; (13158 <DRV_GMAC_Tasks+0x118>)
   13104:	fba2 2303 	umull	r2, r3, r2, r3
   13108:	099b      	lsrs	r3, r3, #6
   1310a:	63e3      	str	r3, [r4, #60]	; 0x3c
            pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_START_LINK;
   1310c:	2300      	movs	r3, #0
   1310e:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
            pMACDrv->sGmacData.sysStat = SYS_STATUS_READY;
   13112:	2302      	movs	r3, #2
   13114:	7523      	strb	r3, [r4, #20]
            break;
   13116:	e7cd      	b.n	130b4 <DRV_GMAC_Tasks+0x74>
                _MACDeinit(pMACDrv);
   13118:	4d0d      	ldr	r5, [pc, #52]	; (13150 <DRV_GMAC_Tasks+0x110>)
   1311a:	4628      	mov	r0, r5
   1311c:	f7fe ffe0 	bl	120e0 <_MACDeinit>
                pMACDrv->sGmacData.sysStat = SYS_STATUS_ERROR;
   13120:	23ff      	movs	r3, #255	; 0xff
   13122:	752b      	strb	r3, [r5, #20]
                SYS_ERROR_PRINT(SYS_ERROR_ERROR, "DRV PHY init failed: %d\r\n", phyInitRes);
   13124:	f00e ff94 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
   13128:	2800      	cmp	r0, #0
   1312a:	d0c3      	beq.n	130b4 <DRV_GMAC_Tasks+0x74>
   1312c:	f00e ff8a 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
   13130:	4622      	mov	r2, r4
   13132:	490a      	ldr	r1, [pc, #40]	; (1315c <DRV_GMAC_Tasks+0x11c>)
   13134:	f007 fcb2 	bl	1aa9c <SYS_CONSOLE_Print>
   13138:	e7bc      	b.n	130b4 <DRV_GMAC_Tasks+0x74>
                pauseType = (pMACDrv->sGmacData.gmacConfig.ethFlags & TCPIP_ETH_OPEN_FDUPLEX) ? DRV_GMAC_PAUSE_CPBL_MASK : TCPIP_ETH_PAUSE_TYPE_NONE;
   1313a:	f003 0302 	and.w	r3, r3, #2
   1313e:	2b00      	cmp	r3, #0
                DRV_PIC32CGMAC_LibMACOpen(pMACDrv, pMACDrv->sGmacData._linkResFlags, pauseType);
   13140:	4803      	ldr	r0, [pc, #12]	; (13150 <DRV_GMAC_Tasks+0x110>)
   13142:	bf14      	ite	ne
   13144:	220f      	movne	r2, #15
   13146:	2200      	moveq	r2, #0
   13148:	8e81      	ldrh	r1, [r0, #52]	; 0x34
   1314a:	f007 faf7 	bl	1a73c <DRV_PIC32CGMAC_LibMACOpen>
   1314e:	e7cc      	b.n	130ea <DRV_GMAC_Tasks+0xaa>
   13150:	2000d8b8 	.word	0x2000d8b8
   13154:	2000d918 	.word	0x2000d918
   13158:	10624dd3 	.word	0x10624dd3
   1315c:	000203d0 	.word	0x000203d0

Disassembly of section .text.DRV_PIC32CGMAC_LibRxBuffersAppend%274:

00013160 <DRV_PIC32CGMAC_LibRxBuffersAppend>:
{ 
   13160:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13164:	b085      	sub	sp, #20
   13166:	4607      	mov	r7, r0
   13168:	9101      	str	r1, [sp, #4]
   1316a:	461c      	mov	r4, r3
	uint16_t nRxDescCnt = pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxDescCnt;	
   1316c:	460e      	mov	r6, r1
   1316e:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
   13172:	eb00 0343 	add.w	r3, r0, r3, lsl #1
   13176:	f8b3 30be 	ldrh.w	r3, [r3, #190]	; 0xbe
   1317a:	9303      	str	r3, [sp, #12]
	uint8_t desc_idx = start_index;
   1317c:	b2d5      	uxtb	r5, r2
			if((pPacket = (TCPIP_MAC_PACKET *)DRV_PIC32CGMAC_SingleListHeadRemove(&pMACDrv->sGmacData.gmac_queue[queueIdx]._RxQueue))!= NULL)
   1317e:	232c      	movs	r3, #44	; 0x2c
   13180:	fb03 0301 	mla	r3, r3, r1, r0
   13184:	3394      	adds	r3, #148	; 0x94
   13186:	9302      	str	r3, [sp, #8]
	DRV_PIC32CGMAC_RESULT gmacRes = DRV_PIC32CGMAC_RES_OK;
   13188:	f04f 0900 	mov.w	r9, #0
		if((pMACDrv->sGmacData.gmac_queue[queueIdx]._RxQueue.nNodes) < (pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxBuffCntThres))
   1318c:	f04f 082c 	mov.w	r8, #44	; 0x2c
   13190:	fb08 0801 	mla	r8, r8, r1, r0
	while (nDesc_Cnt--)
   13194:	e009      	b.n	131aa <DRV_PIC32CGMAC_LibRxBuffersAppend+0x4a>
		if(pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[desc_idx] == 0)
   13196:	9500      	str	r5, [sp, #0]
   13198:	ea4f 0a85 	mov.w	sl, r5, lsl #2
   1319c:	f8d8 308c 	ldr.w	r3, [r8, #140]	; 0x8c
   131a0:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
   131a4:	b313      	cbz	r3, 131ec <DRV_PIC32CGMAC_LibRxBuffersAppend+0x8c>
   131a6:	3c01      	subs	r4, #1
   131a8:	b2a4      	uxth	r4, r4
	while (nDesc_Cnt--)
   131aa:	b1dc      	cbz	r4, 131e4 <DRV_PIC32CGMAC_LibRxBuffersAppend+0x84>
		if((pMACDrv->sGmacData.gmac_queue[queueIdx]._RxQueue.nNodes) < (pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxBuffCntThres))
   131ac:	eb06 03c6 	add.w	r3, r6, r6, lsl #3
   131b0:	eb07 0343 	add.w	r3, r7, r3, lsl #1
   131b4:	f8b3 30c4 	ldrh.w	r3, [r3, #196]	; 0xc4
   131b8:	f8d8 209c 	ldr.w	r2, [r8, #156]	; 0x9c
   131bc:	429a      	cmp	r2, r3
   131be:	daea      	bge.n	13196 <DRV_PIC32CGMAC_LibRxBuffersAppend+0x36>
            gmacRes = _AllocateRxPacket(pMACDrv, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxBuffAllocCnt, queueIdx, GMAC_RX_DYNAMIC_BUFFERS);
   131c0:	eb06 01c6 	add.w	r1, r6, r6, lsl #3
   131c4:	eb07 0141 	add.w	r1, r7, r1, lsl #1
   131c8:	2300      	movs	r3, #0
   131ca:	9a01      	ldr	r2, [sp, #4]
   131cc:	f8b1 10c6 	ldrh.w	r1, [r1, #198]	; 0xc6
   131d0:	4638      	mov	r0, r7
   131d2:	f007 fae9 	bl	1a7a8 <_AllocateRxPacket>
   131d6:	4681      	mov	r9, r0
            if(gmacRes == DRV_PIC32CGMAC_RES_OUT_OF_MEMORY)
   131d8:	f1b0 3fff 	cmp.w	r0, #4294967295
   131dc:	d1db      	bne.n	13196 <DRV_PIC32CGMAC_LibRxBuffersAppend+0x36>
                pMACDrv->sGmacData._rxStat.nRxBuffNotAvailable++;			
   131de:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   131e0:	3301      	adds	r3, #1
   131e2:	67bb      	str	r3, [r7, #120]	; 0x78
} //DRV_PIC32CGMAC_LibRxBuffersAppend
   131e4:	4648      	mov	r0, r9
   131e6:	b005      	add	sp, #20
   131e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if((pPacket = (TCPIP_MAC_PACKET *)DRV_PIC32CGMAC_SingleListHeadRemove(&pMACDrv->sGmacData.gmac_queue[queueIdx]._RxQueue))!= NULL)
   131ec:	9802      	ldr	r0, [sp, #8]
   131ee:	f00d fe3f 	bl	20e70 <DRV_PIC32CGMAC_SingleListHeadRemove>
   131f2:	4683      	mov	fp, r0
   131f4:	2800      	cmp	r0, #0
   131f6:	d0d6      	beq.n	131a6 <DRV_PIC32CGMAC_LibRxBuffersAppend+0x46>
	if(pMACDrv->sGmacData._synchF != 0)
   131f8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   131fa:	b11b      	cbz	r3, 13204 <DRV_PIC32CGMAC_LibRxBuffersAppend+0xa4>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
   131fc:	2105      	movs	r1, #5
   131fe:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   13202:	4798      	blx	r3
				pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc[desc_idx].rx_desc_status.val = 0;
   13204:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
   13208:	9a00      	ldr	r2, [sp, #0]
   1320a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   1320e:	2200      	movs	r2, #0
   13210:	605a      	str	r2, [r3, #4]
                uint32_t segBuffer = (uint32_t)(pPacket->pDSeg->segBuffer) & GMAC_RX_ADDRESS_MASK;   // should be 4-byte aligned
   13212:	f8db 3010 	ldr.w	r3, [fp, #16]
   13216:	685a      	ldr	r2, [r3, #4]
   13218:	f022 0203 	bic.w	r2, r2, #3
				if (desc_idx == pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxDescCnt - 1)
   1321c:	eb06 03c6 	add.w	r3, r6, r6, lsl #3
   13220:	eb07 0343 	add.w	r3, r7, r3, lsl #1
   13224:	f8b3 30be 	ldrh.w	r3, [r3, #190]	; 0xbe
   13228:	3b01      	subs	r3, #1
   1322a:	429d      	cmp	r5, r3
   1322c:	d01e      	beq.n	1326c <DRV_PIC32CGMAC_LibRxBuffersAppend+0x10c>
                    pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc[desc_idx].rx_desc_buffaddr.val =  segBuffer;            
   1322e:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
   13232:	9900      	ldr	r1, [sp, #0]
   13234:	f843 2031 	str.w	r2, [r3, r1, lsl #3]
	if(pMACDrv->sGmacData._synchF != 0)
   13238:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1323a:	b11b      	cbz	r3, 13244 <DRV_PIC32CGMAC_LibRxBuffersAppend+0xe4>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_LEAVE);
   1323c:	2106      	movs	r1, #6
   1323e:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   13242:	4798      	blx	r3
				pPacket->ackFunc = (TCPIP_MAC_PACKET_ACK_FUNC)_MacRxPacketAck;
   13244:	4b0d      	ldr	r3, [pc, #52]	; (1327c <DRV_PIC32CGMAC_LibRxBuffersAppend+0x11c>)
   13246:	f8cb 3008 	str.w	r3, [fp, #8]
				pPacket->ackParam = pMACDrv;
   1324a:	f8cb 700c 	str.w	r7, [fp, #12]
				pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[desc_idx] = pPacket;
   1324e:	f8d8 308c 	ldr.w	r3, [r8, #140]	; 0x8c
   13252:	f843 b00a 	str.w	fp, [r3, sl]
				pPacket->next = 0;
   13256:	2300      	movs	r3, #0
   13258:	f8cb 3000 	str.w	r3, [fp]
				GCIRC_INC(desc_idx,nRxDescCnt );
   1325c:	3501      	adds	r5, #1
   1325e:	b2ed      	uxtb	r5, r5
   13260:	b2ab      	uxth	r3, r5
   13262:	9a03      	ldr	r2, [sp, #12]
   13264:	4293      	cmp	r3, r2
   13266:	bf28      	it	cs
   13268:	2500      	movcs	r5, #0
   1326a:	e79c      	b.n	131a6 <DRV_PIC32CGMAC_LibRxBuffersAppend+0x46>
                    pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc[desc_idx].rx_desc_buffaddr.val =  segBuffer | GMAC_RX_WRAP_BIT;
   1326c:	f8d8 1090 	ldr.w	r1, [r8, #144]	; 0x90
   13270:	f042 0202 	orr.w	r2, r2, #2
   13274:	9b00      	ldr	r3, [sp, #0]
   13276:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
   1327a:	e7dd      	b.n	13238 <DRV_PIC32CGMAC_LibRxBuffersAppend+0xd8>
   1327c:	0001b189 	.word	0x0001b189

Disassembly of section .text._Command_StackOnOff%275:

00013280 <_Command_StackOnOff>:
{
   13280:	b5f0      	push	{r4, r5, r6, r7, lr}
   13282:	b087      	sub	sp, #28
   13284:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   13286:	6845      	ldr	r5, [r0, #4]
    if (argc < 2)
   13288:	2901      	cmp	r1, #1
   1328a:	dd10      	ble.n	132ae <_Command_StackOnOff+0x2e>
    if (memcmp(argv[1], "up", 2) == 0)
   1328c:	6856      	ldr	r6, [r2, #4]
   1328e:	2202      	movs	r2, #2
   13290:	4938      	ldr	r1, [pc, #224]	; (13374 <_Command_StackOnOff+0xf4>)
   13292:	4630      	mov	r0, r6
   13294:	f00d ff66 	bl	21164 <memcmp>
   13298:	b1c0      	cbz	r0, 132cc <_Command_StackOnOff+0x4c>
    else if (memcmp(argv[1], "down", 4) == 0)
   1329a:	2204      	movs	r2, #4
   1329c:	4936      	ldr	r1, [pc, #216]	; (13378 <_Command_StackOnOff+0xf8>)
   1329e:	4630      	mov	r0, r6
   132a0:	f00d ff60 	bl	21164 <memcmp>
   132a4:	2800      	cmp	r0, #0
   132a6:	d046      	beq.n	13336 <_Command_StackOnOff+0xb6>
    return true;
   132a8:	2001      	movs	r0, #1
}
   132aa:	b007      	add	sp, #28
   132ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: stack <up/down> <preserve>\r\n");
   132ae:	4e33      	ldr	r6, [pc, #204]	; (1337c <_Command_StackOnOff+0xfc>)
   132b0:	6803      	ldr	r3, [r0, #0]
   132b2:	681b      	ldr	r3, [r3, #0]
   132b4:	f606 11f4 	addw	r1, r6, #2548	; 0x9f4
   132b8:	4628      	mov	r0, r5
   132ba:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: stack down preserve\r\n");
   132bc:	6823      	ldr	r3, [r4, #0]
   132be:	681b      	ldr	r3, [r3, #0]
   132c0:	f606 2118 	addw	r1, r6, #2584	; 0xa18
   132c4:	4628      	mov	r0, r5
   132c6:	4798      	blx	r3
        return false;
   132c8:	2000      	movs	r0, #0
   132ca:	e7ee      	b.n	132aa <_Command_StackOnOff+0x2a>
        tcpipStackObj = TCPIP_STACK_Initialize(0, 0);
   132cc:	2100      	movs	r1, #0
   132ce:	4608      	mov	r0, r1
   132d0:	f005 fbf2 	bl	18ab8 <TCPIP_STACK_Initialize>
        if ( tcpipStackObj != SYS_MODULE_OBJ_INVALID)
   132d4:	f1b0 3fff 	cmp.w	r0, #4294967295
   132d8:	d006      	beq.n	132e8 <_Command_StackOnOff+0x68>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Stack already up!\r\n");
   132da:	6823      	ldr	r3, [r4, #0]
   132dc:	681b      	ldr	r3, [r3, #0]
   132de:	4928      	ldr	r1, [pc, #160]	; (13380 <_Command_StackOnOff+0x100>)
   132e0:	4628      	mov	r0, r5
   132e2:	4798      	blx	r3
            return true;
   132e4:	2001      	movs	r0, #1
   132e6:	e7e0      	b.n	132aa <_Command_StackOnOff+0x2a>
        if(pCmdTcpipInitData == 0)
   132e8:	4b26      	ldr	r3, [pc, #152]	; (13384 <_Command_StackOnOff+0x104>)
   132ea:	681e      	ldr	r6, [r3, #0]
   132ec:	b1e6      	cbz	r6, 13328 <_Command_StackOnOff+0xa8>
        tcpipInit = *pCmdTcpipInitData;
   132ee:	466f      	mov	r7, sp
   132f0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   132f2:	c70f      	stmia	r7!, {r0, r1, r2, r3}
   132f4:	e896 0003 	ldmia.w	r6, {r0, r1}
   132f8:	e887 0003 	stmia.w	r7, {r0, r1}
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Restarting the stack with %d interface(s)\r\n", tcpipInit.nNets);
   132fc:	6823      	ldr	r3, [r4, #0]
   132fe:	685b      	ldr	r3, [r3, #4]
   13300:	4921      	ldr	r1, [pc, #132]	; (13388 <_Command_StackOnOff+0x108>)
   13302:	4628      	mov	r0, r5
   13304:	4798      	blx	r3
        tcpipStackObj = TCPIP_STACK_Initialize(0, &tcpipInit.moduleInit);     // init the stack
   13306:	4669      	mov	r1, sp
   13308:	2000      	movs	r0, #0
   1330a:	f005 fbd5 	bl	18ab8 <TCPIP_STACK_Initialize>
        if ( tcpipStackObj == SYS_MODULE_OBJ_INVALID)
   1330e:	f1b0 3fff 	cmp.w	r0, #4294967295
            msg = "Stack up succeeded\r\n";
   13312:	491e      	ldr	r1, [pc, #120]	; (1338c <_Command_StackOnOff+0x10c>)
   13314:	f101 0314 	add.w	r3, r1, #20
   13318:	bf18      	it	ne
   1331a:	4619      	movne	r1, r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, msg);
   1331c:	6823      	ldr	r3, [r4, #0]
   1331e:	681b      	ldr	r3, [r3, #0]
   13320:	4628      	mov	r0, r5
   13322:	4798      	blx	r3
    return true;
   13324:	2001      	movs	r0, #1
   13326:	e7c0      	b.n	132aa <_Command_StackOnOff+0x2a>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Turn Stack down and then up!\r\n");
   13328:	6823      	ldr	r3, [r4, #0]
   1332a:	681b      	ldr	r3, [r3, #0]
   1332c:	4918      	ldr	r1, [pc, #96]	; (13390 <_Command_StackOnOff+0x110>)
   1332e:	4628      	mov	r0, r5
   13330:	4798      	blx	r3
            return true;
   13332:	2001      	movs	r0, #1
   13334:	e7b9      	b.n	132aa <_Command_StackOnOff+0x2a>
        tcpipStackObj = TCPIP_STACK_Initialize(0, 0);
   13336:	2100      	movs	r1, #0
   13338:	4608      	mov	r0, r1
   1333a:	f005 fbbd 	bl	18ab8 <TCPIP_STACK_Initialize>
   1333e:	4606      	mov	r6, r0
        if ( tcpipStackObj == SYS_MODULE_OBJ_INVALID)
   13340:	f1b0 3fff 	cmp.w	r0, #4294967295
   13344:	d106      	bne.n	13354 <_Command_StackOnOff+0xd4>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, msg);
   13346:	6823      	ldr	r3, [r4, #0]
   13348:	681b      	ldr	r3, [r3, #0]
   1334a:	4912      	ldr	r1, [pc, #72]	; (13394 <_Command_StackOnOff+0x114>)
   1334c:	4628      	mov	r0, r5
   1334e:	4798      	blx	r3
    return true;
   13350:	2001      	movs	r0, #1
   13352:	e7aa      	b.n	132aa <_Command_StackOnOff+0x2a>
            TCPIP_STACK_InitializeDataGet(tcpipStackObj, &cmdTcpipInitData);
   13354:	4f10      	ldr	r7, [pc, #64]	; (13398 <_Command_StackOnOff+0x118>)
   13356:	4639      	mov	r1, r7
   13358:	f00b ffb6 	bl	1f2c8 <TCPIP_STACK_InitializeDataGet>
            pCmdTcpipInitData = &cmdTcpipInitData;
   1335c:	4b09      	ldr	r3, [pc, #36]	; (13384 <_Command_StackOnOff+0x104>)
   1335e:	601f      	str	r7, [r3, #0]
            TCPIP_STACK_Deinitialize(tcpipStackObj);
   13360:	4630      	mov	r0, r6
   13362:	f00d fe65 	bl	21030 <TCPIP_STACK_Deinitialize>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Stack down succeeded\r\n");
   13366:	6823      	ldr	r3, [r4, #0]
   13368:	681b      	ldr	r3, [r3, #0]
   1336a:	490c      	ldr	r1, [pc, #48]	; (1339c <_Command_StackOnOff+0x11c>)
   1336c:	4628      	mov	r0, r5
   1336e:	4798      	blx	r3
    return true;
   13370:	2001      	movs	r0, #1
   13372:	e79a      	b.n	132aa <_Command_StackOnOff+0x2a>
   13374:	00000cc0 	.word	0x00000cc0
   13378:	00000d24 	.word	0x00000d24
   1337c:	0000028c 	.word	0x0000028c
   13380:	00000cc4 	.word	0x00000cc4
   13384:	2000e3dc 	.word	0x2000e3dc
   13388:	00000cf8 	.word	0x00000cf8
   1338c:	00000c54 	.word	0x00000c54
   13390:	00000cd8 	.word	0x00000cd8
   13394:	00000d2c 	.word	0x00000d2c
   13398:	2000e1e4 	.word	0x2000e1e4
   1339c:	00000d54 	.word	0x00000d54

Disassembly of section .text.TCPIP_IPV4_PacketFormatTx%276:

000133a0 <TCPIP_IPV4_PacketFormatTx>:
{
   133a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   133a4:	4605      	mov	r5, r0
    IPV4_HEADER*    pHdr = (IPV4_HEADER*)pPkt->macPkt.pNetLayer;
   133a6:	6984      	ldr	r4, [r0, #24]
    uint16_t hdrLen = sizeof(IPV4_HEADER) + pPkt->optionLen;
   133a8:	f890 6040 	ldrb.w	r6, [r0, #64]	; 0x40
   133ac:	3614      	adds	r6, #20
    pHdr->Version = IPv4_VERSION;
   133ae:	7820      	ldrb	r0, [r4, #0]
   133b0:	2704      	movs	r7, #4
   133b2:	f367 1007 	bfi	r0, r7, #4, #4
    pHdr->IHL = hdrLen >> 2;
   133b6:	08b7      	lsrs	r7, r6, #2
   133b8:	f367 0003 	bfi	r0, r7, #0, #4
   133bc:	7020      	strb	r0, [r4, #0]
    if((pPkt->optionMask & IPV4_OPTION_MASK_ROUTER_ALERT) != 0)
   133be:	f8b5 0042 	ldrh.w	r0, [r5, #66]	; 0x42
   133c2:	f010 0f01 	tst.w	r0, #1
   133c6:	d01f      	beq.n	13408 <TCPIP_IPV4_PacketFormatTx+0x68>
        pOpt = (IPV4_ROUTER_ALERT_OPTION*)pHdr->options + pPkt->optionOffset;
   133c8:	f104 0714 	add.w	r7, r4, #20
   133cc:	f895 e041 	ldrb.w	lr, [r5, #65]	; 0x41
   133d0:	eb07 0c8e 	add.w	ip, r7, lr, lsl #2
        pOpt->optCopied = IPV4_ROUTER_ALERT_OPTION_COPIED;
   133d4:	f817 002e 	ldrb.w	r0, [r7, lr, lsl #2]
        pOpt->optClass = IPV4_ROUTER_ALERT_OPTION_CLASS;
   133d8:	f060 007f 	orn	r0, r0, #127	; 0x7f
        pOpt->optNumber = TCPIP_IPV4_OPTION_ROUTER_ALERT;
   133dc:	f000 009f 	and.w	r0, r0, #159	; 0x9f
   133e0:	f04f 0814 	mov.w	r8, #20
   133e4:	f368 0004 	bfi	r0, r8, #0, #5
   133e8:	f807 002e 	strb.w	r0, [r7, lr, lsl #2]
        pOpt->optLength = IPV4_ROUTER_ALERT_OPTION_SIZE;
   133ec:	2004      	movs	r0, #4
   133ee:	f88c 0001 	strb.w	r0, [ip, #1]
        pOpt->optValue = IPV4_ROUTER_ALERT_OPTION_DATA;
   133f2:	2000      	movs	r0, #0
   133f4:	f8ac 0002 	strh.w	r0, [ip, #2]
        pEndOpt = (uint8_t*)(pOpt + 1);
   133f8:	f10c 0704 	add.w	r7, ip, #4
        pEndHdr = (uint8_t*)pHdr + hdrLen;
   133fc:	19a0      	adds	r0, r4, r6
        if(pEndOpt < pEndHdr)
   133fe:	4287      	cmp	r7, r0
            *pEndOpt = 0;
   13400:	bf3c      	itt	cc
   13402:	2000      	movcc	r0, #0
   13404:	f88c 0004 	strbcc.w	r0, [ip, #4]
    pHdr->TypeOfService.val = 0;
   13408:	2000      	movs	r0, #0
   1340a:	7060      	strb	r0, [r4, #1]
    if(pParams)
   1340c:	b1fb      	cbz	r3, 1344e <TCPIP_IPV4_PacketFormatTx+0xae>
        if((pParams->tosFlags & TCPIP_IPV4_RELIABILITY_HIGH) != 0)
   1340e:	7818      	ldrb	r0, [r3, #0]
   13410:	f010 0f20 	tst.w	r0, #32
   13414:	d003      	beq.n	1341e <TCPIP_IPV4_PacketFormatTx+0x7e>
            pHdr->TypeOfService.reliability = 1;
   13416:	7860      	ldrb	r0, [r4, #1]
   13418:	f040 0004 	orr.w	r0, r0, #4
   1341c:	7060      	strb	r0, [r4, #1]
        if((pParams->tosFlags & TCPIP_IPV4_THROUGHPUT_HIGH) != 0)
   1341e:	7818      	ldrb	r0, [r3, #0]
   13420:	f010 0f10 	tst.w	r0, #16
   13424:	d003      	beq.n	1342e <TCPIP_IPV4_PacketFormatTx+0x8e>
            pHdr->TypeOfService.throughput = 1;
   13426:	7860      	ldrb	r0, [r4, #1]
   13428:	f040 0008 	orr.w	r0, r0, #8
   1342c:	7060      	strb	r0, [r4, #1]
        if((pParams->tosFlags & TCPIP_IPV4_DELAY_LOW) != 0)
   1342e:	7818      	ldrb	r0, [r3, #0]
   13430:	f010 0f08 	tst.w	r0, #8
   13434:	d003      	beq.n	1343e <TCPIP_IPV4_PacketFormatTx+0x9e>
            pHdr->TypeOfService.delay = 1;
   13436:	7860      	ldrb	r0, [r4, #1]
   13438:	f040 0010 	orr.w	r0, r0, #16
   1343c:	7060      	strb	r0, [r4, #1]
        if((pParams->tosFlags & TCPIP_IPV4_PRECEDENCE_MASK) != 0)
   1343e:	7818      	ldrb	r0, [r3, #0]
   13440:	f010 0f07 	tst.w	r0, #7
   13444:	d003      	beq.n	1344e <TCPIP_IPV4_PacketFormatTx+0xae>
            pHdr->TypeOfService.precedence = pParams->tosFlags & TCPIP_IPV4_PRECEDENCE_MASK;
   13446:	7867      	ldrb	r7, [r4, #1]
   13448:	f360 1747 	bfi	r7, r0, #5, #3
   1344c:	7067      	strb	r7, [r4, #1]
    pHdr->TotalLength = TCPIP_Helper_htons(hdrLen + ipLoadLen);
   1344e:	4432      	add	r2, r6
   13450:	b292      	uxth	r2, r2
   13452:	0a10      	lsrs	r0, r2, #8
   13454:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
   13458:	8062      	strh	r2, [r4, #2]
    pHdr->Identification = TCPIP_Helper_htons(++ipv4Identifier);
   1345a:	4818      	ldr	r0, [pc, #96]	; (134bc <TCPIP_IPV4_PacketFormatTx+0x11c>)
   1345c:	8802      	ldrh	r2, [r0, #0]
   1345e:	3201      	adds	r2, #1
   13460:	b292      	uxth	r2, r2
   13462:	8002      	strh	r2, [r0, #0]
   13464:	0a10      	lsrs	r0, r2, #8
   13466:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
   1346a:	80a2      	strh	r2, [r4, #4]
    pHdr->FragmentInfo.val = TCPIP_Helper_htons(0);
   1346c:	2200      	movs	r2, #0
   1346e:	80e2      	strh	r2, [r4, #6]
    if(pParams !=0 && pParams->df != 0)
   13470:	b30b      	cbz	r3, 134b6 <TCPIP_IPV4_PacketFormatTx+0x116>
   13472:	789a      	ldrb	r2, [r3, #2]
   13474:	b11a      	cbz	r2, 1347e <TCPIP_IPV4_PacketFormatTx+0xde>
        pHdr->FragmentInfo.DF = 1;
   13476:	79e2      	ldrb	r2, [r4, #7]
   13478:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   1347c:	71e2      	strb	r2, [r4, #7]
    pHdr->TimeToLive = (pParams != 0 && pParams->ttl != 0) ? pParams->ttl : IPV4_DEFAULT_TTL;
   1347e:	785b      	ldrb	r3, [r3, #1]
   13480:	2b00      	cmp	r3, #0
   13482:	bf08      	it	eq
   13484:	2364      	moveq	r3, #100	; 0x64
   13486:	7223      	strb	r3, [r4, #8]
    pHdr->Protocol = protocol;
   13488:	7261      	strb	r1, [r4, #9]
    pHdr->HeaderChecksum = 0;
   1348a:	2200      	movs	r2, #0
   1348c:	8162      	strh	r2, [r4, #10]
    pHdr->SourceAddress.Val = pPkt->srcAddress.Val;
   1348e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
   13490:	60e3      	str	r3, [r4, #12]
    pHdr->DestAddress.Val = pPkt->destAddress.Val;
   13492:	6bab      	ldr	r3, [r5, #56]	; 0x38
   13494:	6123      	str	r3, [r4, #16]
    pHdr->HeaderChecksum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pHdr, hdrLen, 0);
   13496:	4631      	mov	r1, r6
   13498:	4620      	mov	r0, r4
   1349a:	f007 f8a7 	bl	1a5ec <TCPIP_Helper_CalcIPChecksum>
   1349e:	8160      	strh	r0, [r4, #10]
    pPkt->macPkt.pDSeg->segLen += hdrLen;
   134a0:	692a      	ldr	r2, [r5, #16]
   134a2:	8993      	ldrh	r3, [r2, #12]
   134a4:	4433      	add	r3, r6
   134a6:	8193      	strh	r3, [r2, #12]
    pPkt->macPkt.pTransportLayer = pPkt->macPkt.pNetLayer + hdrLen;
   134a8:	69ab      	ldr	r3, [r5, #24]
   134aa:	441e      	add	r6, r3
   134ac:	61ee      	str	r6, [r5, #28]
    pPkt->macPkt.pktIf = pPkt->netIfH;
   134ae:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   134b0:	62ab      	str	r3, [r5, #40]	; 0x28
}
   134b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    pHdr->TimeToLive = (pParams != 0 && pParams->ttl != 0) ? pParams->ttl : IPV4_DEFAULT_TTL;
   134b6:	2364      	movs	r3, #100	; 0x64
   134b8:	e7e5      	b.n	13486 <TCPIP_IPV4_PacketFormatTx+0xe6>
   134ba:	bf00      	nop
   134bc:	2000e4fe 	.word	0x2000e4fe

Disassembly of section .text.TCPIP_Helper_StringToIPAddress%277:

000134c0 <TCPIP_Helper_StringToIPAddress>:
{
   134c0:	b4f0      	push	{r4, r5, r6, r7}
   134c2:	b082      	sub	sp, #8
    if(addr)
   134c4:	460d      	mov	r5, r1
   134c6:	b109      	cbz	r1, 134cc <TCPIP_Helper_StringToIPAddress+0xc>
        addr->Val = 0;
   134c8:	2300      	movs	r3, #0
   134ca:	600b      	str	r3, [r1, #0]
    if(str == 0 || strlen(str) == 0)
   134cc:	2800      	cmp	r0, #0
   134ce:	d071      	beq.n	135b4 <TCPIP_Helper_StringToIPAddress+0xf4>
   134d0:	7803      	ldrb	r3, [r0, #0]
   134d2:	2b00      	cmp	r3, #0
   134d4:	d070      	beq.n	135b8 <TCPIP_Helper_StringToIPAddress+0xf8>
	dwVal.Val = 0;
   134d6:	2100      	movs	r1, #0
	while((i = *str++))
   134d8:	3001      	adds	r0, #1
	currentOctet = 0;
   134da:	460c      	mov	r4, r1
	charLen = 0;
   134dc:	460a      	mov	r2, r1
				if(dwVal.Val > 0x00020505ul)
   134de:	4e3f      	ldr	r6, [pc, #252]	; (135dc <TCPIP_Helper_StringToIPAddress+0x11c>)
   134e0:	e010      	b.n	13504 <TCPIP_Helper_StringToIPAddress+0x44>
		else if(charLen == 3u)
   134e2:	2a03      	cmp	r2, #3
   134e4:	d016      	beq.n	13514 <TCPIP_Helper_StringToIPAddress+0x54>
			if(i == (uint8_t)('.' - '0'))
   134e6:	2bfe      	cmp	r3, #254	; 0xfe
   134e8:	d031      	beq.n	1354e <TCPIP_Helper_StringToIPAddress+0x8e>
			if(i > 9u)
   134ea:	2b09      	cmp	r3, #9
   134ec:	d86c      	bhi.n	135c8 <TCPIP_Helper_StringToIPAddress+0x108>
		charLen++;
   134ee:	3201      	adds	r2, #1
   134f0:	b2d2      	uxtb	r2, r2
		dwVal.Val <<= 8;
   134f2:	0209      	lsls	r1, r1, #8
		dwVal.v[0] = i;
   134f4:	f363 0107 	bfi	r1, r3, #0, #8
	while((i = *str++))
   134f8:	f810 3b01 	ldrb.w	r3, [r0], #1
   134fc:	2b00      	cmp	r3, #0
   134fe:	d069      	beq.n	135d4 <TCPIP_Helper_StringToIPAddress+0x114>
		if(currentOctet > 3u)
   13500:	2c03      	cmp	r4, #3
   13502:	d85d      	bhi.n	135c0 <TCPIP_Helper_StringToIPAddress+0x100>
		i -= '0';
   13504:	3b30      	subs	r3, #48	; 0x30
   13506:	b2db      	uxtb	r3, r3
		if(charLen == 0u)
   13508:	2a00      	cmp	r2, #0
   1350a:	d1ea      	bne.n	134e2 <TCPIP_Helper_StringToIPAddress+0x22>
			if(i > 9u)
   1350c:	2b09      	cmp	r3, #9
   1350e:	d9ee      	bls.n	134ee <TCPIP_Helper_StringToIPAddress+0x2e>
				return false;
   13510:	2000      	movs	r0, #0
   13512:	e052      	b.n	135ba <TCPIP_Helper_StringToIPAddress+0xfa>
			if(i != (uint8_t)('.' - '0'))
   13514:	2bfe      	cmp	r3, #254	; 0xfe
   13516:	d155      	bne.n	135c4 <TCPIP_Helper_StringToIPAddress+0x104>
			if(dwVal.Val > 0x00020505ul)
   13518:	42b1      	cmp	r1, r6
   1351a:	d901      	bls.n	13520 <TCPIP_Helper_StringToIPAddress+0x60>
				return false;
   1351c:	2000      	movs	r0, #0
   1351e:	e04c      	b.n	135ba <TCPIP_Helper_StringToIPAddress+0xfa>
			convAddr.v[currentOctet++] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
   13520:	1c62      	adds	r2, r4, #1
   13522:	ab02      	add	r3, sp, #8
   13524:	441c      	add	r4, r3
   13526:	f3c1 4307 	ubfx	r3, r1, #16, #8
   1352a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   1352e:	eb03 0783 	add.w	r7, r3, r3, lsl #2
   13532:	f3c1 2307 	ubfx	r3, r1, #8, #8
   13536:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   1353a:	005b      	lsls	r3, r3, #1
   1353c:	eb03 0387 	add.w	r3, r3, r7, lsl #2
   13540:	4419      	add	r1, r3
   13542:	f804 1c04 	strb.w	r1, [r4, #-4]
			dwVal.Val = 0;
   13546:	2100      	movs	r1, #0
			convAddr.v[currentOctet++] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
   13548:	b2d4      	uxtb	r4, r2
			charLen = 0;
   1354a:	460a      	mov	r2, r1
			continue;
   1354c:	e7d4      	b.n	134f8 <TCPIP_Helper_StringToIPAddress+0x38>
				if(dwVal.Val > 0x00020505ul)
   1354e:	42b1      	cmp	r1, r6
   13550:	d901      	bls.n	13556 <TCPIP_Helper_StringToIPAddress+0x96>
					return false;
   13552:	2000      	movs	r0, #0
   13554:	e031      	b.n	135ba <TCPIP_Helper_StringToIPAddress+0xfa>
				convAddr.v[currentOctet++] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
   13556:	1c62      	adds	r2, r4, #1
   13558:	ab02      	add	r3, sp, #8
   1355a:	441c      	add	r4, r3
   1355c:	f3c1 4307 	ubfx	r3, r1, #16, #8
   13560:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   13564:	eb03 0783 	add.w	r7, r3, r3, lsl #2
   13568:	f3c1 2307 	ubfx	r3, r1, #8, #8
   1356c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   13570:	005b      	lsls	r3, r3, #1
   13572:	eb03 0387 	add.w	r3, r3, r7, lsl #2
   13576:	4419      	add	r1, r3
   13578:	f804 1c04 	strb.w	r1, [r4, #-4]
				dwVal.Val = 0;
   1357c:	2100      	movs	r1, #0
				convAddr.v[currentOctet++] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
   1357e:	b2d4      	uxtb	r4, r2
				charLen = 0;
   13580:	460a      	mov	r2, r1
				continue;
   13582:	e7b9      	b.n	134f8 <TCPIP_Helper_StringToIPAddress+0x38>
	if(dwVal.Val > 0x00020505ul)
   13584:	4b15      	ldr	r3, [pc, #84]	; (135dc <TCPIP_Helper_StringToIPAddress+0x11c>)
   13586:	4299      	cmp	r1, r3
   13588:	d820      	bhi.n	135cc <TCPIP_Helper_StringToIPAddress+0x10c>
	convAddr.v[3] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
   1358a:	f3c1 4307 	ubfx	r3, r1, #16, #8
   1358e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   13592:	eb03 0283 	add.w	r2, r3, r3, lsl #2
   13596:	f3c1 2307 	ubfx	r3, r1, #8, #8
   1359a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   1359e:	005b      	lsls	r3, r3, #1
   135a0:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   135a4:	4419      	add	r1, r3
   135a6:	f88d 1007 	strb.w	r1, [sp, #7]
    if(addr)
   135aa:	b18d      	cbz	r5, 135d0 <TCPIP_Helper_StringToIPAddress+0x110>
        addr->Val = convAddr.Val;
   135ac:	9b01      	ldr	r3, [sp, #4]
   135ae:	602b      	str	r3, [r5, #0]
	return true;
   135b0:	2001      	movs	r0, #1
   135b2:	e002      	b.n	135ba <TCPIP_Helper_StringToIPAddress+0xfa>
        return true;
   135b4:	2001      	movs	r0, #1
   135b6:	e000      	b.n	135ba <TCPIP_Helper_StringToIPAddress+0xfa>
   135b8:	2001      	movs	r0, #1
}
   135ba:	b002      	add	sp, #8
   135bc:	bcf0      	pop	{r4, r5, r6, r7}
   135be:	4770      	bx	lr
		return false;
   135c0:	2000      	movs	r0, #0
   135c2:	e7fa      	b.n	135ba <TCPIP_Helper_StringToIPAddress+0xfa>
				return false;
   135c4:	2000      	movs	r0, #0
   135c6:	e7f8      	b.n	135ba <TCPIP_Helper_StringToIPAddress+0xfa>
				return false;
   135c8:	2000      	movs	r0, #0
   135ca:	e7f6      	b.n	135ba <TCPIP_Helper_StringToIPAddress+0xfa>
		return false;
   135cc:	2000      	movs	r0, #0
   135ce:	e7f4      	b.n	135ba <TCPIP_Helper_StringToIPAddress+0xfa>
	return true;
   135d0:	2001      	movs	r0, #1
   135d2:	e7f2      	b.n	135ba <TCPIP_Helper_StringToIPAddress+0xfa>
	if(currentOctet != 3 || (i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t' && i != ':'))
   135d4:	2c03      	cmp	r4, #3
   135d6:	d0d5      	beq.n	13584 <TCPIP_Helper_StringToIPAddress+0xc4>
		return false;
   135d8:	2000      	movs	r0, #0
   135da:	e7ee      	b.n	135ba <TCPIP_Helper_StringToIPAddress+0xfa>
   135dc:	00020505 	.word	0x00020505

Disassembly of section .text.DRV_GMAC_EventMaskSet%278:

000135e0 <DRV_GMAC_EventMaskSet>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   135e0:	4b45      	ldr	r3, [pc, #276]	; (136f8 <DRV_GMAC_EventMaskSet+0x118>)
   135e2:	4283      	cmp	r3, r0
   135e4:	f040 8082 	bne.w	136ec <DRV_GMAC_EventMaskSet+0x10c>
    if(pMACDrv == 0)
   135e8:	2800      	cmp	r0, #0
   135ea:	f000 8081 	beq.w	136f0 <DRV_GMAC_EventMaskSet+0x110>
{
   135ee:	b570      	push	{r4, r5, r6, lr}
   135f0:	b082      	sub	sp, #8
   135f2:	4615      	mov	r5, r2
   135f4:	460c      	mov	r4, r1
	if(enable)
   135f6:	2a00      	cmp	r2, #0
   135f8:	d03d      	beq.n	13676 <DRV_GMAC_EventMaskSet+0x96>
		ethSetEvents = _XtlEventsTcp2Eth(macEvMask);
   135fa:	4608      	mov	r0, r1
   135fc:	f00b ff9c 	bl	1f538 <_XtlEventsTcp2Eth>
   13600:	4606      	mov	r6, r0
		if(pDcpt->_TcpEnabledEvents != 0)
   13602:	4b3d      	ldr	r3, [pc, #244]	; (136f8 <DRV_GMAC_EventMaskSet+0x118>)
   13604:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
   13608:	bb7b      	cbnz	r3, 1366a <DRV_GMAC_EventMaskSet+0x8a>
		pDcpt->_TcpEnabledEvents |= macEvMask;        // add more
   1360a:	4b3b      	ldr	r3, [pc, #236]	; (136f8 <DRV_GMAC_EventMaskSet+0x118>)
   1360c:	f8b3 104c 	ldrh.w	r1, [r3, #76]	; 0x4c
   13610:	430c      	orrs	r4, r1
   13612:	f8a3 404c 	strh.w	r4, [r3, #76]	; 0x4c
		pDcpt->_EthEnabledEvents |= ethSetEvents;
   13616:	f8b3 2050 	ldrh.w	r2, [r3, #80]	; 0x50
   1361a:	4332      	orrs	r2, r6
   1361c:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
		if(pDcpt->_TcpEnabledEvents != 0)
   13620:	2c00      	cmp	r4, #0
   13622:	d067      	beq.n	136f4 <DRV_GMAC_EventMaskSet+0x114>
			ethSetEvents &= ~pDcpt->_EthPendingEvents;		// keep just the new un-ack events			
   13624:	f8b3 4052 	ldrh.w	r4, [r3, #82]	; 0x52
   13628:	ea26 0404 	bic.w	r4, r6, r4
   1362c:	b2a4      	uxth	r4, r4
                if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queIdx].queueTxEnable != true)
   1362e:	f893 30ce 	ldrb.w	r3, [r3, #206]	; 0xce
   13632:	2b01      	cmp	r3, #1
                    ethEvents = ethEvents & (~GMAC_EV_TX_ALL);
   13634:	bf1c      	itt	ne
   13636:	f024 04d0 	bicne.w	r4, r4, #208	; 0xd0
   1363a:	b2a4      	uxthne	r4, r4
                if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queIdx].queueRxEnable != true)
   1363c:	4b2e      	ldr	r3, [pc, #184]	; (136f8 <DRV_GMAC_EventMaskSet+0x118>)
   1363e:	f893 30cf 	ldrb.w	r3, [r3, #207]	; 0xcf
   13642:	2b01      	cmp	r3, #1
   13644:	d004      	beq.n	13650 <DRV_GMAC_EventMaskSet+0x70>
                    ethEvents = ethEvents & (~GMAC_EV_RX_ALL);
   13646:	f424 6480 	bic.w	r4, r4, #1024	; 0x400
   1364a:	f024 0406 	bic.w	r4, r4, #6
   1364e:	b2a4      	uxth	r4, r4
                DRV_PIC32CGMAC_LibReadInterruptStatus(queIdx);
   13650:	2000      	movs	r0, #0
   13652:	f00e fc9d 	bl	21f90 <DRV_PIC32CGMAC_LibReadInterruptStatus>
                DRV_PIC32CGMAC_LibEnableInterrupt(queIdx, ethEvents);
   13656:	4621      	mov	r1, r4
   13658:	2000      	movs	r0, #0
   1365a:	f00e fc9f 	bl	21f9c <DRV_PIC32CGMAC_LibEnableInterrupt>
            DRV_PIC32CGMAC_LibSysInt_Enable(pMACDrv, GMAC_ALL_QUE_MASK);
   1365e:	213f      	movs	r1, #63	; 0x3f
   13660:	4825      	ldr	r0, [pc, #148]	; (136f8 <DRV_GMAC_EventMaskSet+0x118>)
   13662:	f00c fb9f 	bl	1fda4 <DRV_PIC32CGMAC_LibSysInt_Enable>
	return true;
   13666:	4628      	mov	r0, r5
   13668:	e032      	b.n	136d0 <DRV_GMAC_EventMaskSet+0xf0>
            DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, NULL);
   1366a:	2200      	movs	r2, #0
   1366c:	213f      	movs	r1, #63	; 0x3f
   1366e:	4822      	ldr	r0, [pc, #136]	; (136f8 <DRV_GMAC_EventMaskSet+0x118>)
   13670:	f00c fec0 	bl	203f4 <DRV_PIC32CGMAC_LibSysInt_Disable>
   13674:	e7c9      	b.n	1360a <DRV_GMAC_EventMaskSet+0x2a>
		macEvMask &= pDcpt->_TcpEnabledEvents;                  // keep just the enabled ones
   13676:	4b20      	ldr	r3, [pc, #128]	; (136f8 <DRV_GMAC_EventMaskSet+0x118>)
   13678:	f8b3 604c 	ldrh.w	r6, [r3, #76]	; 0x4c
   1367c:	4034      	ands	r4, r6
		ethClrEvents = _XtlEventsTcp2Eth(macEvMask);
   1367e:	4620      	mov	r0, r4
   13680:	f00b ff5a 	bl	1f538 <_XtlEventsTcp2Eth>
   13684:	4605      	mov	r5, r0
		if(pDcpt->_TcpEnabledEvents != 0)
   13686:	bb2e      	cbnz	r6, 136d4 <DRV_GMAC_EventMaskSet+0xf4>
		pDcpt->_TcpEnabledEvents &= ~macEvMask;     // clear some of them
   13688:	43e4      	mvns	r4, r4
   1368a:	b224      	sxth	r4, r4
   1368c:	4e1a      	ldr	r6, [pc, #104]	; (136f8 <DRV_GMAC_EventMaskSet+0x118>)
   1368e:	f8b6 304c 	ldrh.w	r3, [r6, #76]	; 0x4c
   13692:	4023      	ands	r3, r4
   13694:	f8a6 304c 	strh.w	r3, [r6, #76]	; 0x4c
		pDcpt->_EthEnabledEvents &= ~ethClrEvents;
   13698:	43eb      	mvns	r3, r5
   1369a:	b21b      	sxth	r3, r3
   1369c:	f8b6 2050 	ldrh.w	r2, [r6, #80]	; 0x50
   136a0:	401a      	ands	r2, r3
   136a2:	f8a6 2050 	strh.w	r2, [r6, #80]	; 0x50
		pDcpt->_TcpPendingEvents &= ~macEvMask;     // remove them from un-ack list
   136a6:	f8b6 204e 	ldrh.w	r2, [r6, #78]	; 0x4e
   136aa:	4014      	ands	r4, r2
   136ac:	f8a6 404e 	strh.w	r4, [r6, #78]	; 0x4e
		pDcpt->_EthPendingEvents &= ~ethClrEvents;
   136b0:	f8b6 2052 	ldrh.w	r2, [r6, #82]	; 0x52
   136b4:	4013      	ands	r3, r2
   136b6:	f8a6 3052 	strh.w	r3, [r6, #82]	; 0x52
            DRV_PIC32CGMAC_LibDisableInterrupt(queIdx, ethClrEvents);
   136ba:	4629      	mov	r1, r5
   136bc:	2000      	movs	r0, #0
   136be:	f00e fc73 	bl	21fa8 <DRV_PIC32CGMAC_LibDisableInterrupt>
            DRV_PIC32CGMAC_LibReadInterruptStatus(queIdx);
   136c2:	2000      	movs	r0, #0
   136c4:	f00e fc64 	bl	21f90 <DRV_PIC32CGMAC_LibReadInterruptStatus>
		if(pDcpt->_TcpEnabledEvents != 0)
   136c8:	f8b6 304c 	ldrh.w	r3, [r6, #76]	; 0x4c
   136cc:	b943      	cbnz	r3, 136e0 <DRV_GMAC_EventMaskSet+0x100>
	return true;
   136ce:	2001      	movs	r0, #1
}
   136d0:	b002      	add	sp, #8
   136d2:	bd70      	pop	{r4, r5, r6, pc}
            DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, intStat);
   136d4:	aa01      	add	r2, sp, #4
   136d6:	213f      	movs	r1, #63	; 0x3f
   136d8:	4807      	ldr	r0, [pc, #28]	; (136f8 <DRV_GMAC_EventMaskSet+0x118>)
   136da:	f00c fe8b 	bl	203f4 <DRV_PIC32CGMAC_LibSysInt_Disable>
   136de:	e7d3      	b.n	13688 <DRV_GMAC_EventMaskSet+0xa8>
            DRV_PIC32CGMAC_LibSysInt_Restore(pMACDrv, GMAC_ALL_QUE_MASK, intStat);
   136e0:	aa01      	add	r2, sp, #4
   136e2:	213f      	movs	r1, #63	; 0x3f
   136e4:	4630      	mov	r0, r6
   136e6:	f00d fef1 	bl	214cc <DRV_PIC32CGMAC_LibSysInt_Restore>
   136ea:	e7f0      	b.n	136ce <DRV_GMAC_EventMaskSet+0xee>
        return false;
   136ec:	2000      	movs	r0, #0
   136ee:	4770      	bx	lr
   136f0:	2000      	movs	r0, #0
}
   136f2:	4770      	bx	lr
	return true;
   136f4:	4628      	mov	r0, r5
   136f6:	e7eb      	b.n	136d0 <DRV_GMAC_EventMaskSet+0xf0>
   136f8:	2000d8b8 	.word	0x2000d8b8

Disassembly of section .text._UDPv4TxAckFnc%279:

000136fc <_UDPv4TxAckFnc>:
{
   136fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13700:	4606      	mov	r6, r0
	while(pSkt != 0)
   13702:	2900      	cmp	r1, #0
   13704:	d071      	beq.n	137ea <_UDPv4TxAckFnc+0xee>
   13706:	460c      	mov	r4, r1
        status =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   13708:	2000      	movs	r0, #0
   1370a:	f00d ff57 	bl	215bc <OSAL_CRIT_Enter>
   1370e:	4601      	mov	r1, r0
        sktIx = pSkt->sktIx;
   13710:	f9b4 5012 	ldrsh.w	r5, [r4, #18]
        if(UDPSocketDcpt == 0 || sktIx < 0 || sktIx >= nUdpSockets || pSkt != UDPSocketDcpt[sktIx])
   13714:	4b3e      	ldr	r3, [pc, #248]	; (13810 <_UDPv4TxAckFnc+0x114>)
   13716:	681b      	ldr	r3, [r3, #0]
   13718:	2b00      	cmp	r3, #0
   1371a:	d073      	beq.n	13804 <_UDPv4TxAckFnc+0x108>
   1371c:	2d00      	cmp	r5, #0
   1371e:	db73      	blt.n	13808 <_UDPv4TxAckFnc+0x10c>
   13720:	4a3c      	ldr	r2, [pc, #240]	; (13814 <_UDPv4TxAckFnc+0x118>)
   13722:	6812      	ldr	r2, [r2, #0]
   13724:	4295      	cmp	r5, r2
   13726:	da71      	bge.n	1380c <_UDPv4TxAckFnc+0x110>
   13728:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
   1372c:	42a3      	cmp	r3, r4
   1372e:	d001      	beq.n	13734 <_UDPv4TxAckFnc+0x38>
        critLock = true;
   13730:	2401      	movs	r4, #1
   13732:	e05d      	b.n	137f0 <_UDPv4TxAckFnc+0xf4>
        if(pPkt->modPktData != 0)
   13734:	8e73      	ldrh	r3, [r6, #50]	; 0x32
   13736:	b14b      	cbz	r3, 1374c <_UDPv4TxAckFnc+0x50>
            pPkt->modPktData = 0;
   13738:	f04f 0900 	mov.w	r9, #0
   1373c:	f8a6 9032 	strh.w	r9, [r6, #50]	; 0x32
    const void* sigParam = 0;
   13740:	46c8      	mov	r8, r9
    TCPIP_UDP_SIGNAL_FUNCTION sigHandler = 0;
   13742:	464f      	mov	r7, r9
            loopPkt = true;
   13744:	f04f 0a01 	mov.w	sl, #1
    bool freePkt = true;
   13748:	2400      	movs	r4, #0
   1374a:	e014      	b.n	13776 <_UDPv4TxAckFnc+0x7a>
        if((pSkt->sigMask & TCPIP_UDP_SIGNAL_TX_DONE) != 0)
   1374c:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
   13750:	f013 0f01 	tst.w	r3, #1
   13754:	d020      	beq.n	13798 <_UDPv4TxAckFnc+0x9c>
            sigHandler = pSkt->sigHandler;
   13756:	6d27      	ldr	r7, [r4, #80]	; 0x50
            sigParam = pSkt->sigParam;
   13758:	f8d4 8054 	ldr.w	r8, [r4, #84]	; 0x54
            pktIf = pPkt->pktIf;
   1375c:	f8d6 9028 	ldr.w	r9, [r6, #40]	; 0x28
        if(pSkt->pV4Pkt != (IPV4_PACKET*)pPkt)
   13760:	68e3      	ldr	r3, [r4, #12]
   13762:	42b3      	cmp	r3, r6
   13764:	d01d      	beq.n	137a2 <_UDPv4TxAckFnc+0xa6>
        pSkt->txAllocCnt--;
   13766:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
   1376a:	3b01      	subs	r3, #1
   1376c:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
    bool    loopPkt = false;
   13770:	f04f 0a00 	mov.w	sl, #0
    bool freePkt = true;
   13774:	2401      	movs	r4, #1
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   13776:	2000      	movs	r0, #0
   13778:	f00e f84f 	bl	2181a <OSAL_CRIT_Leave>
    if(loopPkt)
   1377c:	f1ba 0f00 	cmp.w	sl, #0
   13780:	d129      	bne.n	137d6 <_UDPv4TxAckFnc+0xda>
    if(freePkt)
   13782:	2c00      	cmp	r4, #0
   13784:	d13a      	bne.n	137fc <_UDPv4TxAckFnc+0x100>
    if(sigHandler)
   13786:	b127      	cbz	r7, 13792 <_UDPv4TxAckFnc+0x96>
        (*sigHandler)(sktIx, pktIf, TCPIP_UDP_SIGNAL_TX_DONE, sigParam);
   13788:	4643      	mov	r3, r8
   1378a:	2201      	movs	r2, #1
   1378c:	4649      	mov	r1, r9
   1378e:	4628      	mov	r0, r5
   13790:	47b8      	blx	r7
}
   13792:	2000      	movs	r0, #0
   13794:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    const void* sigParam = 0;
   13798:	f04f 0800 	mov.w	r8, #0
    TCPIP_UDP_SIGNAL_FUNCTION sigHandler = 0;
   1379c:	4647      	mov	r7, r8
    TCPIP_NET_HANDLE pktIf = 0;
   1379e:	46c1      	mov	r9, r8
   137a0:	e7de      	b.n	13760 <_UDPv4TxAckFnc+0x64>
    pPkt->macPkt.pDSeg->segLen = 0;
   137a2:	6933      	ldr	r3, [r6, #16]
   137a4:	2200      	movs	r2, #0
   137a6:	819a      	strh	r2, [r3, #12]
    if(pSkt->flags.txSplitAlloc)
   137a8:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
   137ac:	f013 0f02 	tst.w	r3, #2
        ((UDP_V4_PACKET*)pPkt)->zcSeg->segLen = 0;
   137b0:	bf19      	ittee	ne
   137b2:	4613      	movne	r3, r2
   137b4:	f8a6 2050 	strhne.w	r2, [r6, #80]	; 0x50
        pSkt->txWrite = pSkt->txStart;
   137b8:	6823      	ldreq	r3, [r4, #0]
   137ba:	60a3      	streq	r3, [r4, #8]
    pPkt->macPkt.pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED;
   137bc:	8c73      	ldrh	r3, [r6, #34]	; 0x22
   137be:	f023 0308 	bic.w	r3, r3, #8
   137c2:	8473      	strh	r3, [r6, #34]	; 0x22
    bool    loopPkt = false;
   137c4:	f04f 0a00 	mov.w	sl, #0
   137c8:	e7be      	b.n	13748 <_UDPv4TxAckFnc+0x4c>
    if(critLock)
   137ca:	f04f 0800 	mov.w	r8, #0
   137ce:	4647      	mov	r7, r8
   137d0:	46c2      	mov	sl, r8
   137d2:	46c1      	mov	r9, r8
   137d4:	e7cf      	b.n	13776 <_UDPv4TxAckFnc+0x7a>
        pPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_MCAST;
   137d6:	8c73      	ldrh	r3, [r6, #34]	; 0x22
   137d8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   137dc:	8473      	strh	r3, [r6, #34]	; 0x22
        _TCPIPStackInsertRxPacket((TCPIP_NET_IF*)pPkt->pktIf, pPkt, true);
   137de:	2201      	movs	r2, #1
   137e0:	4631      	mov	r1, r6
   137e2:	6ab0      	ldr	r0, [r6, #40]	; 0x28
   137e4:	f007 fb02 	bl	1adec <_TCPIPStackInsertRxPacket>
        return false;
   137e8:	e7d3      	b.n	13792 <_UDPv4TxAckFnc+0x96>
    OSAL_CRITSECT_DATA_TYPE status = 0;
   137ea:	2100      	movs	r1, #0
    bool critLock = false;
   137ec:	460c      	mov	r4, r1
    UDP_SOCKET   sktIx = 0;
   137ee:	460d      	mov	r5, r1
    if(critLock)
   137f0:	2c00      	cmp	r4, #0
   137f2:	d1ea      	bne.n	137ca <_UDPv4TxAckFnc+0xce>
   137f4:	f04f 0800 	mov.w	r8, #0
   137f8:	4647      	mov	r7, r8
   137fa:	46c1      	mov	r9, r8
            TCPIP_PKT_PacketFree(pPkt);
   137fc:	4630      	mov	r0, r6
   137fe:	f00a fd03 	bl	1e208 <_TCPIP_PKT_PacketFree>
   13802:	e7c0      	b.n	13786 <_UDPv4TxAckFnc+0x8a>
        critLock = true;
   13804:	2401      	movs	r4, #1
   13806:	e7f3      	b.n	137f0 <_UDPv4TxAckFnc+0xf4>
   13808:	2401      	movs	r4, #1
   1380a:	e7f1      	b.n	137f0 <_UDPv4TxAckFnc+0xf4>
   1380c:	2401      	movs	r4, #1
   1380e:	e7ef      	b.n	137f0 <_UDPv4TxAckFnc+0xf4>
   13810:	2000e454 	.word	0x2000e454
   13814:	2000e458 	.word	0x2000e458

Disassembly of section .text.wc_RNG_GenerateBlock%280:

00013818 <wc_RNG_GenerateBlock>:
    if (rng == NULL || output == NULL)
   13818:	2800      	cmp	r0, #0
   1381a:	d074      	beq.n	13906 <wc_RNG_GenerateBlock+0xee>
{
   1381c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1381e:	b0a5      	sub	sp, #148	; 0x94
   13820:	4606      	mov	r6, r0
    if (rng == NULL || output == NULL)
   13822:	2900      	cmp	r1, #0
   13824:	d073      	beq.n	1390e <wc_RNG_GenerateBlock+0xf6>
    if (sz == 0)
   13826:	2a00      	cmp	r2, #0
   13828:	d074      	beq.n	13914 <wc_RNG_GenerateBlock+0xfc>
   1382a:	4615      	mov	r5, r2
   1382c:	460c      	mov	r4, r1
    if (rng->devId != INVALID_DEVID) {
   1382e:	6943      	ldr	r3, [r0, #20]
   13830:	f113 0f02 	cmn.w	r3, #2
   13834:	d116      	bne.n	13864 <wc_RNG_GenerateBlock+0x4c>
    if (sz > RNG_MAX_BLOCK_LEN)
   13836:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
   1383a:	d86f      	bhi.n	1391c <wc_RNG_GenerateBlock+0x104>
    if (rng->status != DRBG_OK)
   1383c:	7c33      	ldrb	r3, [r6, #16]
   1383e:	2b01      	cmp	r3, #1
   13840:	d16f      	bne.n	13922 <wc_RNG_GenerateBlock+0x10a>
    ret = Hash_DRBG_Generate((DRBG_internal *)rng->drbg, output, sz);
   13842:	462a      	mov	r2, r5
   13844:	4621      	mov	r1, r4
   13846:	68f0      	ldr	r0, [r6, #12]
   13848:	f7f8 fc3e 	bl	c0c8 <Hash_DRBG_Generate>
   1384c:	4603      	mov	r3, r0
    if (ret == DRBG_NEED_RESEED) {
   1384e:	2802      	cmp	r0, #2
   13850:	d010      	beq.n	13874 <wc_RNG_GenerateBlock+0x5c>
    if (ret == DRBG_SUCCESS) {
   13852:	2b00      	cmp	r3, #0
   13854:	d05f      	beq.n	13916 <wc_RNG_GenerateBlock+0xfe>
    else if (ret == DRBG_CONT_FAILURE) {
   13856:	2b03      	cmp	r3, #3
   13858:	d050      	beq.n	138fc <wc_RNG_GenerateBlock+0xe4>
        rng->status = DRBG_FAILED;
   1385a:	2302      	movs	r3, #2
   1385c:	7433      	strb	r3, [r6, #16]
        ret = RNG_FAILURE_E;
   1385e:	f06f 03c6 	mvn.w	r3, #198	; 0xc6
   13862:	e058      	b.n	13916 <wc_RNG_GenerateBlock+0xfe>
        ret = wc_CryptoCb_RandomBlock(rng, output, sz);
   13864:	f008 f974 	bl	1bb50 <wc_CryptoCb_RandomBlock>
   13868:	4603      	mov	r3, r0
        if (ret != CRYPTOCB_UNAVAILABLE)
   1386a:	f46f 7287 	mvn.w	r2, #270	; 0x10e
   1386e:	4290      	cmp	r0, r2
   13870:	d151      	bne.n	13916 <wc_RNG_GenerateBlock+0xfe>
   13872:	e7e0      	b.n	13836 <wc_RNG_GenerateBlock+0x1e>
        ret = wc_RNG_HealthTest(1, seedA, sizeof(seedA_data),
   13874:	2380      	movs	r3, #128	; 0x80
   13876:	9302      	str	r3, [sp, #8]
   13878:	ab04      	add	r3, sp, #16
   1387a:	9301      	str	r3, [sp, #4]
   1387c:	2320      	movs	r3, #32
   1387e:	9300      	str	r3, [sp, #0]
   13880:	4b29      	ldr	r3, [pc, #164]	; (13928 <wc_RNG_GenerateBlock+0x110>)
   13882:	2230      	movs	r2, #48	; 0x30
   13884:	4929      	ldr	r1, [pc, #164]	; (1392c <wc_RNG_GenerateBlock+0x114>)
   13886:	2001      	movs	r0, #1
   13888:	f00c f926 	bl	1fad8 <wc_RNG_HealthTest>
        if (ret == 0) {
   1388c:	4601      	mov	r1, r0
   1388e:	2800      	cmp	r0, #0
   13890:	d134      	bne.n	138fc <wc_RNG_GenerateBlock+0xe4>
   13892:	f10d 020f 	add.w	r2, sp, #15
   13896:	4826      	ldr	r0, [pc, #152]	; (13930 <wc_RNG_GenerateBlock+0x118>)
   13898:	f10d 0c8f 	add.w	ip, sp, #143	; 0x8f
        compareSum |= a[i] ^ b[i];
   1389c:	f812 3f01 	ldrb.w	r3, [r2, #1]!
   138a0:	f810 7f01 	ldrb.w	r7, [r0, #1]!
   138a4:	407b      	eors	r3, r7
   138a6:	4319      	orrs	r1, r3
    for (i = 0; i < length; i++) {
   138a8:	4562      	cmp	r2, ip
   138aa:	d1f7      	bne.n	1389c <wc_RNG_GenerateBlock+0x84>
            if (ConstantCompare(check, outputA,
   138ac:	bb31      	cbnz	r1, 138fc <wc_RNG_GenerateBlock+0xe4>
            ret = wc_GenerateSeed(&rng->seed, newSeed,
   138ae:	2224      	movs	r2, #36	; 0x24
   138b0:	a904      	add	r1, sp, #16
   138b2:	4630      	mov	r0, r6
   138b4:	f006 fc9a 	bl	1a1ec <wc_GenerateSeed>
            if (ret != 0)
   138b8:	b150      	cbz	r0, 138d0 <wc_RNG_GenerateBlock+0xb8>
                ret = DRBG_FAILURE;
   138ba:	2301      	movs	r3, #1
    volatile byte* z = (volatile byte*)mem;
   138bc:	a904      	add	r1, sp, #16
    while (len--) *z++ = 0;
   138be:	2400      	movs	r4, #0
   138c0:	a80d      	add	r0, sp, #52	; 0x34
   138c2:	460a      	mov	r2, r1
   138c4:	f802 4b01 	strb.w	r4, [r2], #1
   138c8:	4611      	mov	r1, r2
   138ca:	4282      	cmp	r2, r0
   138cc:	d1f9      	bne.n	138c2 <wc_RNG_GenerateBlock+0xaa>
   138ce:	e7c0      	b.n	13852 <wc_RNG_GenerateBlock+0x3a>
                ret = wc_RNG_TestSeed(newSeed, SEED_SZ + SEED_BLOCK_SZ);
   138d0:	2124      	movs	r1, #36	; 0x24
   138d2:	a804      	add	r0, sp, #16
   138d4:	f007 fb26 	bl	1af24 <wc_RNG_TestSeed>
            if (ret == DRBG_SUCCESS)
   138d8:	4603      	mov	r3, r0
   138da:	2800      	cmp	r0, #0
   138dc:	d1ee      	bne.n	138bc <wc_RNG_GenerateBlock+0xa4>
	      ret = Hash_DRBG_Reseed((DRBG_internal *)rng->drbg, newSeed + SEED_BLOCK_SZ,
   138de:	2220      	movs	r2, #32
   138e0:	a905      	add	r1, sp, #20
   138e2:	68f0      	ldr	r0, [r6, #12]
   138e4:	f003 fcae 	bl	17244 <Hash_DRBG_Reseed>
            if (ret == DRBG_SUCCESS)
   138e8:	4603      	mov	r3, r0
   138ea:	2800      	cmp	r0, #0
   138ec:	d1e6      	bne.n	138bc <wc_RNG_GenerateBlock+0xa4>
	      ret = Hash_DRBG_Generate((DRBG_internal *)rng->drbg, output, sz);
   138ee:	462a      	mov	r2, r5
   138f0:	4621      	mov	r1, r4
   138f2:	68f0      	ldr	r0, [r6, #12]
   138f4:	f7f8 fbe8 	bl	c0c8 <Hash_DRBG_Generate>
   138f8:	4603      	mov	r3, r0
   138fa:	e7df      	b.n	138bc <wc_RNG_GenerateBlock+0xa4>
        rng->status = DRBG_CONT_FAILED;
   138fc:	2303      	movs	r3, #3
   138fe:	7433      	strb	r3, [r6, #16]
        ret = DRBG_CONT_FIPS_E;
   13900:	f06f 03d0 	mvn.w	r3, #208	; 0xd0
   13904:	e007      	b.n	13916 <wc_RNG_GenerateBlock+0xfe>
        return BAD_FUNC_ARG;
   13906:	f06f 03ac 	mvn.w	r3, #172	; 0xac
}
   1390a:	4618      	mov	r0, r3
   1390c:	4770      	bx	lr
        return BAD_FUNC_ARG;
   1390e:	f06f 03ac 	mvn.w	r3, #172	; 0xac
   13912:	e000      	b.n	13916 <wc_RNG_GenerateBlock+0xfe>
        return 0; 
   13914:	2300      	movs	r3, #0
}
   13916:	4618      	mov	r0, r3
   13918:	b025      	add	sp, #148	; 0x94
   1391a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return BAD_FUNC_ARG;
   1391c:	f06f 03ac 	mvn.w	r3, #172	; 0xac
   13920:	e7f9      	b.n	13916 <wc_RNG_GenerateBlock+0xfe>
        return RNG_FAILURE_E;
   13922:	f06f 03c6 	mvn.w	r3, #198	; 0xc6
   13926:	e7f6      	b.n	13916 <wc_RNG_GenerateBlock+0xfe>
   13928:	00020c70 	.word	0x00020c70
   1392c:	0001f4a8 	.word	0x0001f4a8
   13930:	0001961f 	.word	0x0001961f

Disassembly of section .text.xTaskIncrementTick%281:

00013934 <xTaskIncrementTick>:
{
   13934:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   13938:	4b38      	ldr	r3, [pc, #224]	; (13a1c <xTaskIncrementTick+0xe8>)
   1393a:	681b      	ldr	r3, [r3, #0]
   1393c:	2b00      	cmp	r3, #0
   1393e:	d167      	bne.n	13a10 <xTaskIncrementTick+0xdc>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
   13940:	4b37      	ldr	r3, [pc, #220]	; (13a20 <xTaskIncrementTick+0xec>)
   13942:	681f      	ldr	r7, [r3, #0]
   13944:	3701      	adds	r7, #1
		xTickCount = xConstTickCount;
   13946:	601f      	str	r7, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
   13948:	b1bf      	cbz	r7, 1397a <xTaskIncrementTick+0x46>
		if( xConstTickCount >= xNextTaskUnblockTime )
   1394a:	4b36      	ldr	r3, [pc, #216]	; (13a24 <xTaskIncrementTick+0xf0>)
   1394c:	681b      	ldr	r3, [r3, #0]
   1394e:	42bb      	cmp	r3, r7
   13950:	d920      	bls.n	13994 <xTaskIncrementTick+0x60>
BaseType_t xSwitchRequired = pdFALSE;
   13952:	2500      	movs	r5, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   13954:	4b34      	ldr	r3, [pc, #208]	; (13a28 <xTaskIncrementTick+0xf4>)
   13956:	681b      	ldr	r3, [r3, #0]
   13958:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1395a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   1395e:	009b      	lsls	r3, r3, #2
   13960:	4a32      	ldr	r2, [pc, #200]	; (13a2c <xTaskIncrementTick+0xf8>)
   13962:	58d3      	ldr	r3, [r2, r3]
				xSwitchRequired = pdTRUE;
   13964:	2b02      	cmp	r3, #2
   13966:	bf28      	it	cs
   13968:	2501      	movcs	r5, #1
			if( xYieldPending != pdFALSE )
   1396a:	4b31      	ldr	r3, [pc, #196]	; (13a30 <xTaskIncrementTick+0xfc>)
   1396c:	681b      	ldr	r3, [r3, #0]
				xSwitchRequired = pdTRUE;
   1396e:	2b00      	cmp	r3, #0
   13970:	bf18      	it	ne
   13972:	2501      	movne	r5, #1
}
   13974:	4628      	mov	r0, r5
   13976:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			taskSWITCH_DELAYED_LISTS();
   1397a:	4a2e      	ldr	r2, [pc, #184]	; (13a34 <xTaskIncrementTick+0x100>)
   1397c:	6811      	ldr	r1, [r2, #0]
   1397e:	4b2e      	ldr	r3, [pc, #184]	; (13a38 <xTaskIncrementTick+0x104>)
   13980:	6818      	ldr	r0, [r3, #0]
   13982:	6010      	str	r0, [r2, #0]
   13984:	6019      	str	r1, [r3, #0]
   13986:	4a2d      	ldr	r2, [pc, #180]	; (13a3c <xTaskIncrementTick+0x108>)
   13988:	6813      	ldr	r3, [r2, #0]
   1398a:	3301      	adds	r3, #1
   1398c:	6013      	str	r3, [r2, #0]
   1398e:	f00c f88d 	bl	1faac <prvResetNextTaskUnblockTime>
   13992:	e7da      	b.n	1394a <xTaskIncrementTick+0x16>
BaseType_t xSwitchRequired = pdFALSE;
   13994:	2500      	movs	r5, #0
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   13996:	f8df 809c 	ldr.w	r8, [pc, #156]	; 13a34 <xTaskIncrementTick+0x100>
					prvAddTaskToReadyList( pxTCB );
   1399a:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 13a44 <xTaskIncrementTick+0x110>
   1399e:	f8df a08c 	ldr.w	sl, [pc, #140]	; 13a2c <xTaskIncrementTick+0xf8>
   139a2:	e021      	b.n	139e8 <xTaskIncrementTick+0xb4>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   139a4:	4b1f      	ldr	r3, [pc, #124]	; (13a24 <xTaskIncrementTick+0xf0>)
   139a6:	f04f 32ff 	mov.w	r2, #4294967295
   139aa:	601a      	str	r2, [r3, #0]
					break;
   139ac:	e7d2      	b.n	13954 <xTaskIncrementTick+0x20>
						xNextTaskUnblockTime = xItemValue;
   139ae:	4a1d      	ldr	r2, [pc, #116]	; (13a24 <xTaskIncrementTick+0xf0>)
   139b0:	6013      	str	r3, [r2, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
   139b2:	e7cf      	b.n	13954 <xTaskIncrementTick+0x20>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   139b4:	f104 0018 	add.w	r0, r4, #24
   139b8:	f00c fe1c 	bl	205f4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   139bc:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   139be:	f8d9 2000 	ldr.w	r2, [r9]
   139c2:	2301      	movs	r3, #1
   139c4:	4083      	lsls	r3, r0
   139c6:	4313      	orrs	r3, r2
   139c8:	f8c9 3000 	str.w	r3, [r9]
   139cc:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   139d0:	4631      	mov	r1, r6
   139d2:	eb0a 0080 	add.w	r0, sl, r0, lsl #2
   139d6:	f00d ff36 	bl	21846 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   139da:	4b13      	ldr	r3, [pc, #76]	; (13a28 <xTaskIncrementTick+0xf4>)
   139dc:	681b      	ldr	r3, [r3, #0]
   139de:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   139e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
   139e2:	429a      	cmp	r2, r3
   139e4:	bf28      	it	cs
   139e6:	2501      	movcs	r5, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   139e8:	f8d8 3000 	ldr.w	r3, [r8]
   139ec:	681b      	ldr	r3, [r3, #0]
   139ee:	2b00      	cmp	r3, #0
   139f0:	d0d8      	beq.n	139a4 <xTaskIncrementTick+0x70>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   139f2:	f8d8 3000 	ldr.w	r3, [r8]
   139f6:	68db      	ldr	r3, [r3, #12]
   139f8:	68dc      	ldr	r4, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
   139fa:	6863      	ldr	r3, [r4, #4]
					if( xConstTickCount < xItemValue )
   139fc:	429f      	cmp	r7, r3
   139fe:	d3d6      	bcc.n	139ae <xTaskIncrementTick+0x7a>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   13a00:	1d26      	adds	r6, r4, #4
   13a02:	4630      	mov	r0, r6
   13a04:	f00c fdf6 	bl	205f4 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   13a08:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   13a0a:	2b00      	cmp	r3, #0
   13a0c:	d1d2      	bne.n	139b4 <xTaskIncrementTick+0x80>
   13a0e:	e7d5      	b.n	139bc <xTaskIncrementTick+0x88>
		++xPendedTicks;
   13a10:	4a0b      	ldr	r2, [pc, #44]	; (13a40 <xTaskIncrementTick+0x10c>)
   13a12:	6813      	ldr	r3, [r2, #0]
   13a14:	3301      	adds	r3, #1
   13a16:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
   13a18:	2500      	movs	r5, #0
	return xSwitchRequired;
   13a1a:	e7ab      	b.n	13974 <xTaskIncrementTick+0x40>
   13a1c:	2000e4b0 	.word	0x2000e4b0
   13a20:	2000e4d0 	.word	0x2000e4d0
   13a24:	2000e4c0 	.word	0x2000e4c0
   13a28:	2000e49c 	.word	0x2000e49c
   13a2c:	2000de80 	.word	0x2000de80
   13a30:	2000e4d4 	.word	0x2000e4d4
   13a34:	2000e4a0 	.word	0x2000e4a0
   13a38:	2000e4a4 	.word	0x2000e4a4
   13a3c:	2000e4c4 	.word	0x2000e4c4
   13a40:	2000e4c8 	.word	0x2000e4c8
   13a44:	2000e4b8 	.word	0x2000e4b8

Disassembly of section .text.CommandPingHandler%282:

00013a48 <CommandPingHandler>:
    if(result == TCPIP_ICMP_ECHO_REQUEST_RES_OK)
   13a48:	2a00      	cmp	r2, #0
   13a4a:	d168      	bne.n	13b1e <CommandPingHandler+0xd6>
{
   13a4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13a50:	b088      	sub	sp, #32
        if(pEchoReq->identifier != icmpIdentifier)
   13a52:	8943      	ldrh	r3, [r0, #10]
   13a54:	4a34      	ldr	r2, [pc, #208]	; (13b28 <CommandPingHandler+0xe0>)
   13a56:	8812      	ldrh	r2, [r2, #0]
   13a58:	1a9a      	subs	r2, r3, r2
   13a5a:	bf18      	it	ne
   13a5c:	2201      	movne	r2, #1
        if(pEchoReq->sequenceNumber != icmpSequenceNo)
   13a5e:	8901      	ldrh	r1, [r0, #8]
   13a60:	4b32      	ldr	r3, [pc, #200]	; (13b2c <CommandPingHandler+0xe4>)
   13a62:	881b      	ldrh	r3, [r3, #0]
   13a64:	4299      	cmp	r1, r3
            errorMask |= 0x2;
   13a66:	bf18      	it	ne
   13a68:	f042 0202 	orrne.w	r2, r2, #2
   13a6c:	4680      	mov	r8, r0
        if(pEchoReq->dataSize != icmpPingSize)
   13a6e:	8a03      	ldrh	r3, [r0, #16]
   13a70:	492f      	ldr	r1, [pc, #188]	; (13b30 <CommandPingHandler+0xe8>)
   13a72:	680f      	ldr	r7, [r1, #0]
   13a74:	42bb      	cmp	r3, r7
   13a76:	d028      	beq.n	13aca <CommandPingHandler+0x82>
            errorMask |= 0x8;
   13a78:	f042 0208 	orr.w	r2, r2, #8
        int checkSize = pEchoReq->dataSize < icmpPingSize ? pEchoReq->dataSize : icmpPingSize;
   13a7c:	429f      	cmp	r7, r3
   13a7e:	bfa8      	it	ge
   13a80:	461f      	movge	r7, r3
        uint8_t* pDst = pEchoReq->pData;
   13a82:	68c1      	ldr	r1, [r0, #12]
        for(ix = 0; ix < checkSize; ix++)
   13a84:	2f00      	cmp	r7, #0
   13a86:	dd12      	ble.n	13aae <CommandPingHandler+0x66>
            if(*pSrc++ != *pDst++)
   13a88:	4b2a      	ldr	r3, [pc, #168]	; (13b34 <CommandPingHandler+0xec>)
   13a8a:	7818      	ldrb	r0, [r3, #0]
   13a8c:	f811 3b01 	ldrb.w	r3, [r1], #1
   13a90:	4298      	cmp	r0, r3
   13a92:	d10a      	bne.n	13aaa <CommandPingHandler+0x62>
   13a94:	4c28      	ldr	r4, [pc, #160]	; (13b38 <CommandPingHandler+0xf0>)
        for(ix = 0; ix < checkSize; ix++)
   13a96:	2300      	movs	r3, #0
   13a98:	3301      	adds	r3, #1
   13a9a:	42bb      	cmp	r3, r7
   13a9c:	da18      	bge.n	13ad0 <CommandPingHandler+0x88>
            if(*pSrc++ != *pDst++)
   13a9e:	f814 6b01 	ldrb.w	r6, [r4], #1
   13aa2:	f811 5b01 	ldrb.w	r5, [r1], #1
   13aa6:	42ae      	cmp	r6, r5
   13aa8:	d0f6      	beq.n	13a98 <CommandPingHandler+0x50>
                errorMask |= 0x10;
   13aaa:	f042 0210 	orr.w	r2, r2, #16
            (*pTcpipCmdDevice->pCmdApi->print)(icmpCmdIoParam, "Ping: wrong reply received. Mask: 0x%2x\r\n", errorMask);
   13aae:	4b23      	ldr	r3, [pc, #140]	; (13b3c <CommandPingHandler+0xf4>)
   13ab0:	681b      	ldr	r3, [r3, #0]
   13ab2:	681b      	ldr	r3, [r3, #0]
   13ab4:	685b      	ldr	r3, [r3, #4]
   13ab6:	4922      	ldr	r1, [pc, #136]	; (13b40 <CommandPingHandler+0xf8>)
   13ab8:	4822      	ldr	r0, [pc, #136]	; (13b44 <CommandPingHandler+0xfc>)
   13aba:	6800      	ldr	r0, [r0, #0]
   13abc:	4798      	blx	r3
    icmpReqHandle = 0;
   13abe:	4b22      	ldr	r3, [pc, #136]	; (13b48 <CommandPingHandler+0x100>)
   13ac0:	2200      	movs	r2, #0
   13ac2:	601a      	str	r2, [r3, #0]
}
   13ac4:	b008      	add	sp, #32
   13ac6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        uint8_t* pDst = pEchoReq->pData;
   13aca:	68c1      	ldr	r1, [r0, #12]
        for(ix = 0; ix < checkSize; ix++)
   13acc:	2f00      	cmp	r7, #0
   13ace:	dcdb      	bgt.n	13a88 <CommandPingHandler+0x40>
        if(errorMask != 0)
   13ad0:	2a00      	cmp	r2, #0
   13ad2:	d1ec      	bne.n	13aae <CommandPingHandler+0x66>
            uint32_t pingTicks = SYS_TMR_TickCountGet() - icmpStartTick;
   13ad4:	f00c fb0a 	bl	200ec <SYS_TMR_TickCountGet>
   13ad8:	4b1c      	ldr	r3, [pc, #112]	; (13b4c <CommandPingHandler+0x104>)
   13ada:	681c      	ldr	r4, [r3, #0]
   13adc:	1b00      	subs	r0, r0, r4
            int pingMs = (pingTicks * 1000) / SYS_TMR_TickCounterFrequencyGet();
   13ade:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
   13ae2:	fb04 f400 	mul.w	r4, r4, r0
   13ae6:	f00c fb29 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
   13aea:	fbb4 f4f0 	udiv	r4, r4, r0
                pingMs = 1;
   13aee:	2c00      	cmp	r4, #0
   13af0:	bf08      	it	eq
   13af2:	2401      	moveq	r4, #1
            TCPIP_Helper_IPAddressToString(&pEchoReq->targetAddr, addBuff, sizeof(addBuff));
   13af4:	2214      	movs	r2, #20
   13af6:	a903      	add	r1, sp, #12
   13af8:	f108 0004 	add.w	r0, r8, #4
   13afc:	f008 ffca 	bl	1ca94 <TCPIP_Helper_IPAddressToString>
            (*pTcpipCmdDevice->pCmdApi->print)(icmpCmdIoParam, "Ping: reply[%d] from %s: time = %dms\r\n", ++icmpAckRecv, addBuff, pingMs);
   13b00:	4b0e      	ldr	r3, [pc, #56]	; (13b3c <CommandPingHandler+0xf4>)
   13b02:	681b      	ldr	r3, [r3, #0]
   13b04:	681b      	ldr	r3, [r3, #0]
   13b06:	685d      	ldr	r5, [r3, #4]
   13b08:	4b11      	ldr	r3, [pc, #68]	; (13b50 <CommandPingHandler+0x108>)
   13b0a:	681a      	ldr	r2, [r3, #0]
   13b0c:	3201      	adds	r2, #1
   13b0e:	601a      	str	r2, [r3, #0]
   13b10:	9400      	str	r4, [sp, #0]
   13b12:	ab03      	add	r3, sp, #12
   13b14:	490f      	ldr	r1, [pc, #60]	; (13b54 <CommandPingHandler+0x10c>)
   13b16:	480b      	ldr	r0, [pc, #44]	; (13b44 <CommandPingHandler+0xfc>)
   13b18:	6800      	ldr	r0, [r0, #0]
   13b1a:	47a8      	blx	r5
   13b1c:	e7cf      	b.n	13abe <CommandPingHandler+0x76>
    icmpReqHandle = 0;
   13b1e:	4b0a      	ldr	r3, [pc, #40]	; (13b48 <CommandPingHandler+0x100>)
   13b20:	2200      	movs	r2, #0
   13b22:	601a      	str	r2, [r3, #0]
   13b24:	4770      	bx	lr
   13b26:	bf00      	nop
   13b28:	2000e4fa 	.word	0x2000e4fa
   13b2c:	2000e4fc 	.word	0x2000e4fc
   13b30:	2000e3e8 	.word	0x2000e3e8
   13b34:	2000ca04 	.word	0x2000ca04
   13b38:	2000ca05 	.word	0x2000ca05
   13b3c:	2000e3e0 	.word	0x2000e3e0
   13b40:	000015a0 	.word	0x000015a0
   13b44:	2000e3b8 	.word	0x2000e3b8
   13b48:	2000e3c8 	.word	0x2000e3c8
   13b4c:	2000e3d0 	.word	0x2000e3d0
   13b50:	2000e3b4 	.word	0x2000e3b4
   13b54:	000015cc 	.word	0x000015cc

Disassembly of section .text%283:

00013b58 <__gedf2>:
   13b58:	f04f 3cff 	mov.w	ip, #4294967295
   13b5c:	e006      	b.n	13b6c <__cmpdf2+0x4>
   13b5e:	bf00      	nop

00013b60 <__ledf2>:
   13b60:	f04f 0c01 	mov.w	ip, #1
   13b64:	e002      	b.n	13b6c <__cmpdf2+0x4>
   13b66:	bf00      	nop

00013b68 <__cmpdf2>:
   13b68:	f04f 0c01 	mov.w	ip, #1
   13b6c:	f84d cd04 	str.w	ip, [sp, #-4]!
   13b70:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   13b74:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   13b78:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   13b7c:	bf18      	it	ne
   13b7e:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
   13b82:	d01b      	beq.n	13bbc <__cmpdf2+0x54>
   13b84:	b001      	add	sp, #4
   13b86:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
   13b8a:	bf0c      	ite	eq
   13b8c:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
   13b90:	ea91 0f03 	teqne	r1, r3
   13b94:	bf02      	ittt	eq
   13b96:	ea90 0f02 	teqeq	r0, r2
   13b9a:	2000      	moveq	r0, #0
   13b9c:	4770      	bxeq	lr
   13b9e:	f110 0f00 	cmn.w	r0, #0
   13ba2:	ea91 0f03 	teq	r1, r3
   13ba6:	bf58      	it	pl
   13ba8:	4299      	cmppl	r1, r3
   13baa:	bf08      	it	eq
   13bac:	4290      	cmpeq	r0, r2
   13bae:	bf2c      	ite	cs
   13bb0:	17d8      	asrcs	r0, r3, #31
   13bb2:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
   13bb6:	f040 0001 	orr.w	r0, r0, #1
   13bba:	4770      	bx	lr
   13bbc:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   13bc0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   13bc4:	d102      	bne.n	13bcc <__cmpdf2+0x64>
   13bc6:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
   13bca:	d107      	bne.n	13bdc <__cmpdf2+0x74>
   13bcc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   13bd0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   13bd4:	d1d6      	bne.n	13b84 <__cmpdf2+0x1c>
   13bd6:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
   13bda:	d0d3      	beq.n	13b84 <__cmpdf2+0x1c>
   13bdc:	f85d 0b04 	ldr.w	r0, [sp], #4
   13be0:	4770      	bx	lr
   13be2:	bf00      	nop

00013be4 <__aeabi_cdrcmple>:
   13be4:	4684      	mov	ip, r0
   13be6:	4610      	mov	r0, r2
   13be8:	4662      	mov	r2, ip
   13bea:	468c      	mov	ip, r1
   13bec:	4619      	mov	r1, r3
   13bee:	4663      	mov	r3, ip
   13bf0:	e000      	b.n	13bf4 <__aeabi_cdcmpeq>
   13bf2:	bf00      	nop

00013bf4 <__aeabi_cdcmpeq>:
   13bf4:	b501      	push	{r0, lr}
   13bf6:	f7ff ffb7 	bl	13b68 <__cmpdf2>
   13bfa:	2800      	cmp	r0, #0
   13bfc:	bf48      	it	mi
   13bfe:	f110 0f00 	cmnmi.w	r0, #0
   13c02:	bd01      	pop	{r0, pc}

00013c04 <__aeabi_dcmpeq>:
   13c04:	f84d ed08 	str.w	lr, [sp, #-8]!
   13c08:	f7ff fff4 	bl	13bf4 <__aeabi_cdcmpeq>
   13c0c:	bf0c      	ite	eq
   13c0e:	2001      	moveq	r0, #1
   13c10:	2000      	movne	r0, #0
   13c12:	f85d fb08 	ldr.w	pc, [sp], #8
   13c16:	bf00      	nop

00013c18 <__aeabi_dcmplt>:
   13c18:	f84d ed08 	str.w	lr, [sp, #-8]!
   13c1c:	f7ff ffea 	bl	13bf4 <__aeabi_cdcmpeq>
   13c20:	bf34      	ite	cc
   13c22:	2001      	movcc	r0, #1
   13c24:	2000      	movcs	r0, #0
   13c26:	f85d fb08 	ldr.w	pc, [sp], #8
   13c2a:	bf00      	nop

00013c2c <__aeabi_dcmple>:
   13c2c:	f84d ed08 	str.w	lr, [sp, #-8]!
   13c30:	f7ff ffe0 	bl	13bf4 <__aeabi_cdcmpeq>
   13c34:	bf94      	ite	ls
   13c36:	2001      	movls	r0, #1
   13c38:	2000      	movhi	r0, #0
   13c3a:	f85d fb08 	ldr.w	pc, [sp], #8
   13c3e:	bf00      	nop

00013c40 <__aeabi_dcmpge>:
   13c40:	f84d ed08 	str.w	lr, [sp, #-8]!
   13c44:	f7ff ffce 	bl	13be4 <__aeabi_cdrcmple>
   13c48:	bf94      	ite	ls
   13c4a:	2001      	movls	r0, #1
   13c4c:	2000      	movhi	r0, #0
   13c4e:	f85d fb08 	ldr.w	pc, [sp], #8
   13c52:	bf00      	nop

00013c54 <__aeabi_dcmpgt>:
   13c54:	f84d ed08 	str.w	lr, [sp, #-8]!
   13c58:	f7ff ffc4 	bl	13be4 <__aeabi_cdrcmple>
   13c5c:	bf34      	ite	cc
   13c5e:	2001      	movcc	r0, #1
   13c60:	2000      	movcs	r0, #0
   13c62:	f85d fb08 	ldr.w	pc, [sp], #8
   13c66:	bf00      	nop

Disassembly of section .text._Tcpv4TxAckFnc%284:

00013c68 <_Tcpv4TxAckFnc>:
{
   13c68:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13c6c:	4681      	mov	r9, r0
    while(pSkt != 0)
   13c6e:	460e      	mov	r6, r1
   13c70:	2900      	cmp	r1, #0
   13c72:	d051      	beq.n	13d18 <_Tcpv4TxAckFnc+0xb0>
        status =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   13c74:	2000      	movs	r0, #0
   13c76:	f00d fca1 	bl	215bc <OSAL_CRIT_Enter>
   13c7a:	4601      	mov	r1, r0
        sktIx = pSkt->sktIx;
   13c7c:	f9b6 7034 	ldrsh.w	r7, [r6, #52]	; 0x34
        if(TCBStubs == 0 || sktIx < 0 || sktIx >= TcpSockets || pSkt != TCBStubs[sktIx])
   13c80:	4b3a      	ldr	r3, [pc, #232]	; (13d6c <_Tcpv4TxAckFnc+0x104>)
   13c82:	681c      	ldr	r4, [r3, #0]
   13c84:	2c00      	cmp	r4, #0
   13c86:	d04f      	beq.n	13d28 <_Tcpv4TxAckFnc+0xc0>
   13c88:	2f00      	cmp	r7, #0
   13c8a:	db61      	blt.n	13d50 <_Tcpv4TxAckFnc+0xe8>
   13c8c:	4b38      	ldr	r3, [pc, #224]	; (13d70 <_Tcpv4TxAckFnc+0x108>)
   13c8e:	681b      	ldr	r3, [r3, #0]
   13c90:	429f      	cmp	r7, r3
   13c92:	d264      	bcs.n	13d5e <_Tcpv4TxAckFnc+0xf6>
   13c94:	f854 3027 	ldr.w	r3, [r4, r7, lsl #2]
   13c98:	42b3      	cmp	r3, r6
   13c9a:	d006      	beq.n	13caa <_Tcpv4TxAckFnc+0x42>
    const void* sigParam = 0;
   13c9c:	2400      	movs	r4, #0
    TCPIP_TCP_SIGNAL_FUNCTION sigHandler = 0;
   13c9e:	4625      	mov	r5, r4
    bool freePkt = true;
   13ca0:	f04f 0a01 	mov.w	sl, #1
    TCPIP_TCP_SIGNAL_TYPE sigType = 0;
   13ca4:	46a0      	mov	r8, r4
    TCPIP_NET_HANDLE pktIf = 0;
   13ca6:	4626      	mov	r6, r4
   13ca8:	e043      	b.n	13d32 <_Tcpv4TxAckFnc+0xca>
        if((pPkt->pDSeg->segFlags & TCPIP_MAC_SEG_FLAG_USER_PAYLOAD) != 0)
   13caa:	f8d9 3010 	ldr.w	r3, [r9, #16]
   13cae:	8a1b      	ldrh	r3, [r3, #16]
   13cb0:	f003 0308 	and.w	r3, r3, #8
            sigType = TCPIP_TCP_SIGNAL_TX_DONE;
   13cb4:	2b00      	cmp	r3, #0
   13cb6:	bf14      	ite	ne
   13cb8:	f04f 0803 	movne.w	r8, #3
   13cbc:	f04f 0801 	moveq.w	r8, #1
        if((sigType &= pSkt->sigMask) != 0)
   13cc0:	f8b6 3072 	ldrh.w	r3, [r6, #114]	; 0x72
   13cc4:	ea18 0803 	ands.w	r8, r8, r3
   13cc8:	d00a      	beq.n	13ce0 <_Tcpv4TxAckFnc+0x78>
            sigHandler = pSkt->sigHandler;
   13cca:	6f75      	ldr	r5, [r6, #116]	; 0x74
            sigParam = pSkt->sigParam;
   13ccc:	6fb4      	ldr	r4, [r6, #120]	; 0x78
            pktIf = pPkt->pktIf;
   13cce:	f8d9 0028 	ldr.w	r0, [r9, #40]	; 0x28
        if(pSkt->pV4Pkt != &((TCP_V4_PACKET*)pPkt)->v4Pkt)
   13cd2:	6c72      	ldr	r2, [r6, #68]	; 0x44
   13cd4:	454a      	cmp	r2, r9
   13cd6:	d007      	beq.n	13ce8 <_Tcpv4TxAckFnc+0x80>
   13cd8:	4606      	mov	r6, r0
    bool freePkt = true;
   13cda:	f04f 0a01 	mov.w	sl, #1
   13cde:	e028      	b.n	13d32 <_Tcpv4TxAckFnc+0xca>
    const void* sigParam = 0;
   13ce0:	2400      	movs	r4, #0
    TCPIP_TCP_SIGNAL_FUNCTION sigHandler = 0;
   13ce2:	4625      	mov	r5, r4
    TCPIP_NET_HANDLE pktIf = 0;
   13ce4:	4620      	mov	r0, r4
   13ce6:	e7f4      	b.n	13cd2 <_Tcpv4TxAckFnc+0x6a>
    pSeg->segLen = pSeg->segSize = 0;
   13ce8:	2300      	movs	r3, #0
   13cea:	f8a2 3052 	strh.w	r3, [r2, #82]	; 0x52
   13cee:	f8a2 3050 	strh.w	r3, [r2, #80]	; 0x50
    pSeg->next = 0;
   13cf2:	6453      	str	r3, [r2, #68]	; 0x44
    pSeg->segLen = pSeg->segSize = 0;
   13cf4:	f8a2 306a 	strh.w	r3, [r2, #106]	; 0x6a
   13cf8:	f8a2 3068 	strh.w	r3, [r2, #104]	; 0x68
    pSeg->next = 0;
   13cfc:	65d3      	str	r3, [r2, #92]	; 0x5c
    pTcpPkt->v4Pkt.macPkt.pDSeg->next = 0;    // unlink to the 1st data seg; leave header only
   13cfe:	6916      	ldr	r6, [r2, #16]
   13d00:	6033      	str	r3, [r6, #0]
    pTcpPkt->v4Pkt.macPkt.pDSeg->segLen = 0;  // clear the payload
   13d02:	6912      	ldr	r2, [r2, #16]
   13d04:	8193      	strh	r3, [r2, #12]
        pPkt->pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED;
   13d06:	f8b9 2022 	ldrh.w	r2, [r9, #34]	; 0x22
   13d0a:	f022 0208 	bic.w	r2, r2, #8
   13d0e:	f8a9 2022 	strh.w	r2, [r9, #34]	; 0x22
        break;
   13d12:	4606      	mov	r6, r0
        freePkt = false;
   13d14:	469a      	mov	sl, r3
        break;
   13d16:	e00c      	b.n	13d32 <_Tcpv4TxAckFnc+0xca>
    const void* sigParam = 0;
   13d18:	460c      	mov	r4, r1
    TCPIP_TCP_SIGNAL_FUNCTION sigHandler = 0;
   13d1a:	2500      	movs	r5, #0
    TCP_SOCKET   sktIx = 0;
   13d1c:	462f      	mov	r7, r5
    TCPIP_TCP_SIGNAL_TYPE sigType = 0;
   13d1e:	46a8      	mov	r8, r5
        TCPIP_PKT_PacketFree(pPkt);
   13d20:	4648      	mov	r0, r9
   13d22:	f00a fa71 	bl	1e208 <_TCPIP_PKT_PacketFree>
   13d26:	e00a      	b.n	13d3e <_Tcpv4TxAckFnc+0xd6>
    TCPIP_NET_HANDLE pktIf = 0;
   13d28:	4626      	mov	r6, r4
    TCPIP_TCP_SIGNAL_FUNCTION sigHandler = 0;
   13d2a:	2500      	movs	r5, #0
    bool freePkt = true;
   13d2c:	f04f 0a01 	mov.w	sl, #1
    TCPIP_TCP_SIGNAL_TYPE sigType = 0;
   13d30:	46a8      	mov	r8, r5
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   13d32:	2000      	movs	r0, #0
   13d34:	f00d fd71 	bl	2181a <OSAL_CRIT_Leave>
    if(freePkt)
   13d38:	f1ba 0f00 	cmp.w	sl, #0
   13d3c:	d1f0      	bne.n	13d20 <_Tcpv4TxAckFnc+0xb8>
    if(sigHandler)
   13d3e:	b125      	cbz	r5, 13d4a <_Tcpv4TxAckFnc+0xe2>
        (*sigHandler)(sktIx, pktIf, sigType, sigParam);
   13d40:	4623      	mov	r3, r4
   13d42:	4642      	mov	r2, r8
   13d44:	4631      	mov	r1, r6
   13d46:	4638      	mov	r0, r7
   13d48:	47a8      	blx	r5
}
   13d4a:	2000      	movs	r0, #0
   13d4c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    const void* sigParam = 0;
   13d50:	2400      	movs	r4, #0
    TCPIP_TCP_SIGNAL_FUNCTION sigHandler = 0;
   13d52:	4625      	mov	r5, r4
    bool freePkt = true;
   13d54:	f04f 0a01 	mov.w	sl, #1
    TCPIP_TCP_SIGNAL_TYPE sigType = 0;
   13d58:	46a0      	mov	r8, r4
    TCPIP_NET_HANDLE pktIf = 0;
   13d5a:	4626      	mov	r6, r4
   13d5c:	e7e9      	b.n	13d32 <_Tcpv4TxAckFnc+0xca>
    const void* sigParam = 0;
   13d5e:	2400      	movs	r4, #0
    TCPIP_TCP_SIGNAL_FUNCTION sigHandler = 0;
   13d60:	4625      	mov	r5, r4
    bool freePkt = true;
   13d62:	f04f 0a01 	mov.w	sl, #1
    TCPIP_TCP_SIGNAL_TYPE sigType = 0;
   13d66:	46a0      	mov	r8, r4
    TCPIP_NET_HANDLE pktIf = 0;
   13d68:	4626      	mov	r6, r4
   13d6a:	e7e2      	b.n	13d32 <_Tcpv4TxAckFnc+0xca>
   13d6c:	2000e38c 	.word	0x2000e38c
   13d70:	2000e390 	.word	0x2000e390

Disassembly of section .text.__sflush_r%285:

00013d74 <__sflush_r>:
   13d74:	898a      	ldrh	r2, [r1, #12]
   13d76:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13d7a:	4605      	mov	r5, r0
   13d7c:	0710      	lsls	r0, r2, #28
   13d7e:	460c      	mov	r4, r1
   13d80:	d458      	bmi.n	13e34 <__sflush_r+0xc0>
   13d82:	684b      	ldr	r3, [r1, #4]
   13d84:	2b00      	cmp	r3, #0
   13d86:	dc05      	bgt.n	13d94 <__sflush_r+0x20>
   13d88:	6c0b      	ldr	r3, [r1, #64]	; 0x40
   13d8a:	2b00      	cmp	r3, #0
   13d8c:	dc02      	bgt.n	13d94 <__sflush_r+0x20>
   13d8e:	2000      	movs	r0, #0
   13d90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   13d94:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   13d96:	2e00      	cmp	r6, #0
   13d98:	d0f9      	beq.n	13d8e <__sflush_r+0x1a>
   13d9a:	2300      	movs	r3, #0
   13d9c:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
   13da0:	682f      	ldr	r7, [r5, #0]
   13da2:	602b      	str	r3, [r5, #0]
   13da4:	d032      	beq.n	13e0c <__sflush_r+0x98>
   13da6:	6d60      	ldr	r0, [r4, #84]	; 0x54
   13da8:	89a3      	ldrh	r3, [r4, #12]
   13daa:	075a      	lsls	r2, r3, #29
   13dac:	d505      	bpl.n	13dba <__sflush_r+0x46>
   13dae:	6863      	ldr	r3, [r4, #4]
   13db0:	1ac0      	subs	r0, r0, r3
   13db2:	6b63      	ldr	r3, [r4, #52]	; 0x34
   13db4:	b10b      	cbz	r3, 13dba <__sflush_r+0x46>
   13db6:	6c23      	ldr	r3, [r4, #64]	; 0x40
   13db8:	1ac0      	subs	r0, r0, r3
   13dba:	2300      	movs	r3, #0
   13dbc:	4602      	mov	r2, r0
   13dbe:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   13dc0:	6a21      	ldr	r1, [r4, #32]
   13dc2:	4628      	mov	r0, r5
   13dc4:	47b0      	blx	r6
   13dc6:	1c43      	adds	r3, r0, #1
   13dc8:	89a3      	ldrh	r3, [r4, #12]
   13dca:	d106      	bne.n	13dda <__sflush_r+0x66>
   13dcc:	6829      	ldr	r1, [r5, #0]
   13dce:	291d      	cmp	r1, #29
   13dd0:	d82c      	bhi.n	13e2c <__sflush_r+0xb8>
   13dd2:	4a2a      	ldr	r2, [pc, #168]	; (13e7c <__sflush_r+0x108>)
   13dd4:	40ca      	lsrs	r2, r1
   13dd6:	07d6      	lsls	r6, r2, #31
   13dd8:	d528      	bpl.n	13e2c <__sflush_r+0xb8>
   13dda:	2200      	movs	r2, #0
   13ddc:	6062      	str	r2, [r4, #4]
   13dde:	04d9      	lsls	r1, r3, #19
   13de0:	6922      	ldr	r2, [r4, #16]
   13de2:	6022      	str	r2, [r4, #0]
   13de4:	d504      	bpl.n	13df0 <__sflush_r+0x7c>
   13de6:	1c42      	adds	r2, r0, #1
   13de8:	d101      	bne.n	13dee <__sflush_r+0x7a>
   13dea:	682b      	ldr	r3, [r5, #0]
   13dec:	b903      	cbnz	r3, 13df0 <__sflush_r+0x7c>
   13dee:	6560      	str	r0, [r4, #84]	; 0x54
   13df0:	6b61      	ldr	r1, [r4, #52]	; 0x34
   13df2:	602f      	str	r7, [r5, #0]
   13df4:	2900      	cmp	r1, #0
   13df6:	d0ca      	beq.n	13d8e <__sflush_r+0x1a>
   13df8:	f104 0344 	add.w	r3, r4, #68	; 0x44
   13dfc:	4299      	cmp	r1, r3
   13dfe:	d002      	beq.n	13e06 <__sflush_r+0x92>
   13e00:	4628      	mov	r0, r5
   13e02:	f004 f887 	bl	17f14 <_free_r>
   13e06:	2000      	movs	r0, #0
   13e08:	6360      	str	r0, [r4, #52]	; 0x34
   13e0a:	e7c1      	b.n	13d90 <__sflush_r+0x1c>
   13e0c:	6a21      	ldr	r1, [r4, #32]
   13e0e:	2301      	movs	r3, #1
   13e10:	4628      	mov	r0, r5
   13e12:	47b0      	blx	r6
   13e14:	1c41      	adds	r1, r0, #1
   13e16:	d1c7      	bne.n	13da8 <__sflush_r+0x34>
   13e18:	682b      	ldr	r3, [r5, #0]
   13e1a:	2b00      	cmp	r3, #0
   13e1c:	d0c4      	beq.n	13da8 <__sflush_r+0x34>
   13e1e:	2b1d      	cmp	r3, #29
   13e20:	d001      	beq.n	13e26 <__sflush_r+0xb2>
   13e22:	2b16      	cmp	r3, #22
   13e24:	d101      	bne.n	13e2a <__sflush_r+0xb6>
   13e26:	602f      	str	r7, [r5, #0]
   13e28:	e7b1      	b.n	13d8e <__sflush_r+0x1a>
   13e2a:	89a3      	ldrh	r3, [r4, #12]
   13e2c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   13e30:	81a3      	strh	r3, [r4, #12]
   13e32:	e7ad      	b.n	13d90 <__sflush_r+0x1c>
   13e34:	690f      	ldr	r7, [r1, #16]
   13e36:	2f00      	cmp	r7, #0
   13e38:	d0a9      	beq.n	13d8e <__sflush_r+0x1a>
   13e3a:	0793      	lsls	r3, r2, #30
   13e3c:	680e      	ldr	r6, [r1, #0]
   13e3e:	bf08      	it	eq
   13e40:	694b      	ldreq	r3, [r1, #20]
   13e42:	600f      	str	r7, [r1, #0]
   13e44:	bf18      	it	ne
   13e46:	2300      	movne	r3, #0
   13e48:	eba6 0807 	sub.w	r8, r6, r7
   13e4c:	608b      	str	r3, [r1, #8]
   13e4e:	f1b8 0f00 	cmp.w	r8, #0
   13e52:	dd9c      	ble.n	13d8e <__sflush_r+0x1a>
   13e54:	4643      	mov	r3, r8
   13e56:	463a      	mov	r2, r7
   13e58:	6a21      	ldr	r1, [r4, #32]
   13e5a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
   13e5c:	4628      	mov	r0, r5
   13e5e:	47b0      	blx	r6
   13e60:	2800      	cmp	r0, #0
   13e62:	dc06      	bgt.n	13e72 <__sflush_r+0xfe>
   13e64:	89a3      	ldrh	r3, [r4, #12]
   13e66:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   13e6a:	81a3      	strh	r3, [r4, #12]
   13e6c:	f04f 30ff 	mov.w	r0, #4294967295
   13e70:	e78e      	b.n	13d90 <__sflush_r+0x1c>
   13e72:	4407      	add	r7, r0
   13e74:	eba8 0800 	sub.w	r8, r8, r0
   13e78:	e7e9      	b.n	13e4e <__sflush_r+0xda>
   13e7a:	bf00      	nop
   13e7c:	20400001 	.word	0x20400001

Disassembly of section .text._TCPIP_HEAP_Free%286:

00013e80 <_TCPIP_HEAP_Free>:
// null if invalid
static __inline__ TCPIP_HEAP_DCPT* __attribute__((always_inline)) _TCPIP_HEAP_ObjDcpt(TCPIP_STACK_HEAP_HANDLE heapH)
{
    TCPIP_HEAP_OBJ_INSTANCE* hInst = _TCPIP_HEAP_ObjInstance(heapH);

    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   13e80:	2800      	cmp	r0, #0
   13e82:	d07e      	beq.n	13f82 <_TCPIP_HEAP_Free+0x102>
    return pBuff;

}

static size_t _TCPIP_HEAP_Free(TCPIP_STACK_HEAP_HANDLE heapH, const void* pBuff)
{  
   13e84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13e88:	4604      	mov	r4, r0
    int         fail;
    size_t      freedUnits;

    hDcpt = _TCPIP_HEAP_ObjDcpt(heapH);

    if(hDcpt == 0 || pBuff == 0)
   13e8a:	2900      	cmp	r1, #0
   13e8c:	d07b      	beq.n	13f86 <_TCPIP_HEAP_Free+0x106>
   13e8e:	460e      	mov	r6, r1
	{
        return 0;
    }

    ptr = (_headNode*)pBuff-1;
   13e90:	f1a1 0510 	sub.w	r5, r1, #16

    OSAL_SEM_Pend(&hDcpt->_heapSemaphore, OSAL_WAIT_FOREVER);
   13e94:	f100 0844 	add.w	r8, r0, #68	; 0x44
   13e98:	f64f 71ff 	movw	r1, #65535	; 0xffff
   13e9c:	4640      	mov	r0, r8
   13e9e:	f00c ff81 	bl	20da4 <OSAL_SEM_Pend>
        OSAL_SEM_Post(&hDcpt->_heapSemaphore);
        return 0;
    }
#endif
    
    freedUnits = ptr->units;
   13ea2:	f856 7c0c 	ldr.w	r7, [r6, #-12]
    
    fail = 0;
    
    if(!hDcpt->_heapHead)
   13ea6:	6a63      	ldr	r3, [r4, #36]	; 0x24
   13ea8:	b18b      	cbz	r3, 13ece <_TCPIP_HEAP_Free+0x4e>
    {
        ptr->next=0;
        hDcpt->_heapHead = hDcpt->_heapTail = ptr;
    }
    else if(ptr < hDcpt->_heapHead)
   13eaa:	42ab      	cmp	r3, r5
   13eac:	d922      	bls.n	13ef4 <_TCPIP_HEAP_Free+0x74>
    {   // put it in front
        if(ptr+ptr->units == hDcpt->_heapHead)
   13eae:	eb05 1207 	add.w	r2, r5, r7, lsl #4
   13eb2:	4293      	cmp	r3, r2
   13eb4:	d010      	beq.n	13ed8 <_TCPIP_HEAP_Free+0x58>
                hDcpt->_heapTail = ptr;
            }
        }
        else
        {
            ptr->next = hDcpt->_heapHead;
   13eb6:	f846 3c10 	str.w	r3, [r6, #-16]
        }
        hDcpt->_heapHead = ptr;    // new head
   13eba:	6265      	str	r5, [r4, #36]	; 0x24
        hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_PTR_ERR;   // corrupted pointer!!!
        OSAL_SEM_Post(&hDcpt->_heapSemaphore);
        return 0;
    }
    
    hDcpt->_heapAllocatedUnits -= freedUnits;
   13ebc:	6b23      	ldr	r3, [r4, #48]	; 0x30
   13ebe:	1bdb      	subs	r3, r3, r7
   13ec0:	6323      	str	r3, [r4, #48]	; 0x30
    OSAL_SEM_Post(&hDcpt->_heapSemaphore);
   13ec2:	4640      	mov	r0, r8
   13ec4:	f00d fb86 	bl	215d4 <OSAL_SEM_Post>
    return freedUnits * sizeof(_headNode);
   13ec8:	0138      	lsls	r0, r7, #4
}
   13eca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        ptr->next=0;
   13ece:	f846 3c10 	str.w	r3, [r6, #-16]
        hDcpt->_heapHead = hDcpt->_heapTail = ptr;
   13ed2:	62a5      	str	r5, [r4, #40]	; 0x28
   13ed4:	6265      	str	r5, [r4, #36]	; 0x24
    if(fail)
   13ed6:	e7f1      	b.n	13ebc <_TCPIP_HEAP_Free+0x3c>
            ptr->units += hDcpt->_heapHead->units;
   13ed8:	685b      	ldr	r3, [r3, #4]
   13eda:	443b      	add	r3, r7
   13edc:	f846 3c0c 	str.w	r3, [r6, #-12]
            ptr->next = hDcpt->_heapHead->next;
   13ee0:	6a63      	ldr	r3, [r4, #36]	; 0x24
   13ee2:	681b      	ldr	r3, [r3, #0]
   13ee4:	f846 3c10 	str.w	r3, [r6, #-16]
            if(hDcpt->_heapTail == hDcpt->_heapHead)
   13ee8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   13eea:	6a63      	ldr	r3, [r4, #36]	; 0x24
   13eec:	429a      	cmp	r2, r3
   13eee:	d1e4      	bne.n	13eba <_TCPIP_HEAP_Free+0x3a>
                hDcpt->_heapTail = ptr;
   13ef0:	62a5      	str	r5, [r4, #40]	; 0x28
   13ef2:	e7e2      	b.n	13eba <_TCPIP_HEAP_Free+0x3a>
    else if(ptr > hDcpt->_heapTail)
   13ef4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   13ef6:	42aa      	cmp	r2, r5
   13ef8:	d229      	bcs.n	13f4e <_TCPIP_HEAP_Free+0xce>
        if(hDcpt->_heapTail + hDcpt->_heapTail->units == ptr)
   13efa:	6853      	ldr	r3, [r2, #4]
   13efc:	eb02 1103 	add.w	r1, r2, r3, lsl #4
   13f00:	428d      	cmp	r5, r1
   13f02:	d005      	beq.n	13f10 <_TCPIP_HEAP_Free+0x90>
            hDcpt->_heapTail->next = ptr;
   13f04:	6015      	str	r5, [r2, #0]
            ptr->next = 0;
   13f06:	2300      	movs	r3, #0
   13f08:	f846 3c10 	str.w	r3, [r6, #-16]
            hDcpt->_heapTail = ptr;
   13f0c:	62a5      	str	r5, [r4, #40]	; 0x28
    if(fail)
   13f0e:	e7d5      	b.n	13ebc <_TCPIP_HEAP_Free+0x3c>
            hDcpt->_heapTail->units += ptr->units;
   13f10:	443b      	add	r3, r7
   13f12:	6053      	str	r3, [r2, #4]
    if(fail)
   13f14:	e7d2      	b.n	13ebc <_TCPIP_HEAP_Free+0x3c>
                    ptr->units += hdr->next->units;
   13f16:	6852      	ldr	r2, [r2, #4]
   13f18:	443a      	add	r2, r7
   13f1a:	f846 2c0c 	str.w	r2, [r6, #-12]
                    ptr->next = hdr->next->next;
   13f1e:	681a      	ldr	r2, [r3, #0]
   13f20:	6812      	ldr	r2, [r2, #0]
   13f22:	f846 2c10 	str.w	r2, [r6, #-16]
                    if(hDcpt->_heapTail == hdr->next)
   13f26:	6aa1      	ldr	r1, [r4, #40]	; 0x28
   13f28:	681a      	ldr	r2, [r3, #0]
   13f2a:	4291      	cmp	r1, r2
   13f2c:	d11a      	bne.n	13f64 <_TCPIP_HEAP_Free+0xe4>
                        hDcpt->_heapTail = ptr;
   13f2e:	62a5      	str	r5, [r4, #40]	; 0x28
   13f30:	e018      	b.n	13f64 <_TCPIP_HEAP_Free+0xe4>
                    hdr->units += ptr->units;
   13f32:	f856 1c0c 	ldr.w	r1, [r6, #-12]
   13f36:	440a      	add	r2, r1
   13f38:	605a      	str	r2, [r3, #4]
                    hdr->next = ptr->next;
   13f3a:	f856 2c10 	ldr.w	r2, [r6, #-16]
   13f3e:	601a      	str	r2, [r3, #0]
                    if(hDcpt->_heapTail == ptr)
   13f40:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   13f42:	42aa      	cmp	r2, r5
   13f44:	d1ba      	bne.n	13ebc <_TCPIP_HEAP_Free+0x3c>
                        hDcpt->_heapTail = hdr;
   13f46:	62a3      	str	r3, [r4, #40]	; 0x28
   13f48:	e7b8      	b.n	13ebc <_TCPIP_HEAP_Free+0x3c>
        for(hdr = hDcpt->_heapHead; hdr != 0; hdr = hdr->next)
   13f4a:	681b      	ldr	r3, [r3, #0]
   13f4c:	b18b      	cbz	r3, 13f72 <_TCPIP_HEAP_Free+0xf2>
            if(hdr<ptr && ptr<hdr->next)
   13f4e:	429d      	cmp	r5, r3
   13f50:	d9fb      	bls.n	13f4a <_TCPIP_HEAP_Free+0xca>
   13f52:	681a      	ldr	r2, [r3, #0]
   13f54:	42aa      	cmp	r2, r5
   13f56:	d9f8      	bls.n	13f4a <_TCPIP_HEAP_Free+0xca>
                if(ptr+ptr->units == hdr->next)
   13f58:	eb05 1107 	add.w	r1, r5, r7, lsl #4
   13f5c:	428a      	cmp	r2, r1
   13f5e:	d0da      	beq.n	13f16 <_TCPIP_HEAP_Free+0x96>
                    ptr->next = hdr->next;
   13f60:	f846 2c10 	str.w	r2, [r6, #-16]
                if(hdr+hdr->units == ptr)
   13f64:	685a      	ldr	r2, [r3, #4]
   13f66:	eb03 1102 	add.w	r1, r3, r2, lsl #4
   13f6a:	428d      	cmp	r5, r1
   13f6c:	d0e1      	beq.n	13f32 <_TCPIP_HEAP_Free+0xb2>
                    hdr->next = ptr;
   13f6e:	601d      	str	r5, [r3, #0]
   13f70:	e7a4      	b.n	13ebc <_TCPIP_HEAP_Free+0x3c>
        hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_PTR_ERR;   // corrupted pointer!!!
   13f72:	23f8      	movs	r3, #248	; 0xf8
   13f74:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
        OSAL_SEM_Post(&hDcpt->_heapSemaphore);
   13f78:	4640      	mov	r0, r8
   13f7a:	f00d fb2b 	bl	215d4 <OSAL_SEM_Post>
        return 0;
   13f7e:	2000      	movs	r0, #0
   13f80:	e7a3      	b.n	13eca <_TCPIP_HEAP_Free+0x4a>
        return 0;
   13f82:	2000      	movs	r0, #0
}
   13f84:	4770      	bx	lr
        return 0;
   13f86:	2000      	movs	r0, #0
   13f88:	e79f      	b.n	13eca <_TCPIP_HEAP_Free+0x4a>

Disassembly of section .text.TCPIP_TCP_OptionsSet%287:

00013f8a <TCPIP_TCP_OptionsSet>:
{
   13f8a:	b570      	push	{r4, r5, r6, lr}
   13f8c:	4606      	mov	r6, r0
   13f8e:	460c      	mov	r4, r1
   13f90:	4615      	mov	r5, r2
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   13f92:	f00b ff43 	bl	1fe1c <_TcpSocketChk>
    if(pSkt)
   13f96:	2800      	cmp	r0, #0
   13f98:	d070      	beq.n	1407c <TCPIP_TCP_OptionsSet+0xf2>
   13f9a:	4603      	mov	r3, r0
        switch(option)
   13f9c:	2c0b      	cmp	r4, #11
   13f9e:	d86f      	bhi.n	14080 <TCPIP_TCP_OptionsSet+0xf6>
   13fa0:	e8df f004 	tbb	[pc, r4]
   13fa4:	3f381b06 	.word	0x3f381b06
   13fa8:	6e466e6e 	.word	0x6e466e6e
   13fac:	68645951 	.word	0x68645951
                if(optParam)
   13fb0:	2d00      	cmp	r5, #0
   13fb2:	d067      	beq.n	14084 <TCPIP_TCP_OptionsSet+0xfa>
                    pSkt->flags.nonLinger = pLData->lingerEnable == 0;
   13fb4:	782a      	ldrb	r2, [r5, #0]
   13fb6:	f082 0201 	eor.w	r2, r2, #1
   13fba:	f890 106c 	ldrb.w	r1, [r0, #108]	; 0x6c
   13fbe:	f362 1186 	bfi	r1, r2, #6, #1
   13fc2:	f880 106c 	strb.w	r1, [r0, #108]	; 0x6c
                    pSkt->flags.nonGraceful = pLData->gracefulEnable == 0;
   13fc6:	786a      	ldrb	r2, [r5, #1]
   13fc8:	f082 0201 	eor.w	r2, r2, #1
   13fcc:	b2c9      	uxtb	r1, r1
   13fce:	f362 11c7 	bfi	r1, r2, #7, #1
   13fd2:	f880 106c 	strb.w	r1, [r0, #108]	; 0x6c
                    return true;
   13fd6:	2001      	movs	r0, #1
   13fd8:	e051      	b.n	1407e <TCPIP_TCP_OptionsSet+0xf4>
                if(optParam)
   13fda:	2d00      	cmp	r5, #0
   13fdc:	d054      	beq.n	14088 <TCPIP_TCP_OptionsSet+0xfe>
                    if((pSkt->Flags.keepAlive = pKData->keepAliveEnable))
   13fde:	7828      	ldrb	r0, [r5, #0]
   13fe0:	f893 2037 	ldrb.w	r2, [r3, #55]	; 0x37
   13fe4:	f360 1286 	bfi	r2, r0, #6, #1
   13fe8:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
   13fec:	2800      	cmp	r0, #0
   13fee:	d04d      	beq.n	1408c <TCPIP_TCP_OptionsSet+0x102>
                        pSkt->keepAliveCount = 0;
   13ff0:	2200      	movs	r2, #0
   13ff2:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
                        pSkt->keepAliveTmo = pKData->keepAliveTmo ? pKData->keepAliveTmo : TCPIP_TCP_KEEP_ALIVE_TIMEOUT;
   13ff6:	886a      	ldrh	r2, [r5, #2]
   13ff8:	f242 7110 	movw	r1, #10000	; 0x2710
   13ffc:	2a00      	cmp	r2, #0
   13ffe:	bf08      	it	eq
   14000:	460a      	moveq	r2, r1
   14002:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
                        pSkt->keepAliveLim = pKData->keepAliveUnackLim ? pKData->keepAliveUnackLim : TCPIP_TCP_MAX_UNACKED_KEEP_ALIVES;
   14006:	792a      	ldrb	r2, [r5, #4]
   14008:	2a00      	cmp	r2, #0
   1400a:	bf08      	it	eq
   1400c:	2206      	moveq	r2, #6
   1400e:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
   14012:	e034      	b.n	1407e <TCPIP_TCP_OptionsSet+0xf4>
                return TCPIP_TCP_FifoSizeAdjust(hTCP, (uint16_t)((unsigned int)optParam), 0, TCP_ADJUST_RX_ONLY | TCP_ADJUST_PRESERVE_RX);
   14014:	2324      	movs	r3, #36	; 0x24
   14016:	2200      	movs	r2, #0
   14018:	b2a9      	uxth	r1, r5
   1401a:	4630      	mov	r0, r6
   1401c:	f7f7 fedc 	bl	bdd8 <TCPIP_TCP_FifoSizeAdjust>
   14020:	e02d      	b.n	1407e <TCPIP_TCP_OptionsSet+0xf4>
                return TCPIP_TCP_FifoSizeAdjust(hTCP, 0, (uint16_t)((unsigned int)optParam), TCP_ADJUST_TX_ONLY | TCP_ADJUST_PRESERVE_TX);
   14022:	2318      	movs	r3, #24
   14024:	b2aa      	uxth	r2, r5
   14026:	2100      	movs	r1, #0
   14028:	4630      	mov	r0, r6
   1402a:	f7f7 fed5 	bl	bdd8 <TCPIP_TCP_FifoSizeAdjust>
   1402e:	e026      	b.n	1407e <TCPIP_TCP_OptionsSet+0xf4>
                pSkt->flags.forceFlush = (int)optParam != 0;
   14030:	3500      	adds	r5, #0
   14032:	bf18      	it	ne
   14034:	2501      	movne	r5, #1
   14036:	f890 206d 	ldrb.w	r2, [r0, #109]	; 0x6d
   1403a:	f365 02c3 	bfi	r2, r5, #3, #1
   1403e:	f880 206d 	strb.w	r2, [r0, #109]	; 0x6d
                return true;
   14042:	2001      	movs	r0, #1
   14044:	e01b      	b.n	1407e <TCPIP_TCP_OptionsSet+0xf4>
                pSkt->Flags.halfThresType = (TCP_OPTION_THRES_FLUSH_TYPE)(uint32_t)optParam;
   14046:	f890 2037 	ldrb.w	r2, [r0, #55]	; 0x37
   1404a:	f365 1205 	bfi	r2, r5, #4, #2
   1404e:	f880 2037 	strb.w	r2, [r0, #55]	; 0x37
                return true;
   14052:	2001      	movs	r0, #1
   14054:	e013      	b.n	1407e <TCPIP_TCP_OptionsSet+0xf4>
                pSkt->Flags.delayAckSend = (int)optParam != 0;
   14056:	3500      	adds	r5, #0
   14058:	bf18      	it	ne
   1405a:	2501      	movne	r5, #1
   1405c:	f890 2037 	ldrb.w	r2, [r0, #55]	; 0x37
   14060:	f365 12c7 	bfi	r2, r5, #7, #1
   14064:	f880 2037 	strb.w	r2, [r0, #55]	; 0x37
                return true;
   14068:	2001      	movs	r0, #1
   1406a:	e008      	b.n	1407e <TCPIP_TCP_OptionsSet+0xf4>
                pSkt->ttl = (uint8_t)(unsigned int)optParam;
   1406c:	f880 507e 	strb.w	r5, [r0, #126]	; 0x7e
                return true;
   14070:	2001      	movs	r0, #1
   14072:	e004      	b.n	1407e <TCPIP_TCP_OptionsSet+0xf4>
                pSkt->tos = (uint8_t)(unsigned int)optParam;
   14074:	f880 507f 	strb.w	r5, [r0, #127]	; 0x7f
                return true;
   14078:	2001      	movs	r0, #1
   1407a:	e000      	b.n	1407e <TCPIP_TCP_OptionsSet+0xf4>
    return false;
   1407c:	2000      	movs	r0, #0
}
   1407e:	bd70      	pop	{r4, r5, r6, pc}
                return false;   // not supported option
   14080:	2000      	movs	r0, #0
   14082:	e7fc      	b.n	1407e <TCPIP_TCP_OptionsSet+0xf4>
                return false;
   14084:	2000      	movs	r0, #0
   14086:	e7fa      	b.n	1407e <TCPIP_TCP_OptionsSet+0xf4>
                return false;
   14088:	2000      	movs	r0, #0
   1408a:	e7f8      	b.n	1407e <TCPIP_TCP_OptionsSet+0xf4>
                    return true;
   1408c:	2001      	movs	r0, #1
   1408e:	e7f6      	b.n	1407e <TCPIP_TCP_OptionsSet+0xf4>

Disassembly of section .text.TCPIP_UDP_Initialize%288:

00014090 <TCPIP_UDP_Initialize>:
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_UP)
   14090:	7f03      	ldrb	r3, [r0, #28]
   14092:	2b03      	cmp	r3, #3
   14094:	d065      	beq.n	14162 <TCPIP_UDP_Initialize+0xd2>
    if(udpInitCount != 0)
   14096:	4b35      	ldr	r3, [pc, #212]	; (1416c <TCPIP_UDP_Initialize+0xdc>)
   14098:	681b      	ldr	r3, [r3, #0]
   1409a:	b983      	cbnz	r3, 140be <TCPIP_UDP_Initialize+0x2e>
{
   1409c:	b570      	push	{r4, r5, r6, lr}
   1409e:	460d      	mov	r5, r1
   140a0:	4604      	mov	r4, r0
    if(stackCtrl->memH == 0)
   140a2:	68c3      	ldr	r3, [r0, #12]
   140a4:	b183      	cbz	r3, 140c8 <TCPIP_UDP_Initialize+0x38>
    if(pUdpInit == 0)
   140a6:	2900      	cmp	r1, #0
   140a8:	d05d      	beq.n	14166 <TCPIP_UDP_Initialize+0xd6>
    return OSAL_SEM_Create(&userSem, OSAL_SEM_TYPE_BINARY, 1, 1);
   140aa:	2301      	movs	r3, #1
   140ac:	461a      	mov	r2, r3
   140ae:	2100      	movs	r1, #0
   140b0:	482f      	ldr	r0, [pc, #188]	; (14170 <TCPIP_UDP_Initialize+0xe0>)
   140b2:	f007 fedf 	bl	1be74 <OSAL_SEM_Create>
    if(_UserGblLockCreate() != OSAL_RESULT_TRUE)
   140b6:	2801      	cmp	r0, #1
   140b8:	d012      	beq.n	140e0 <TCPIP_UDP_Initialize+0x50>
        return false;
   140ba:	2000      	movs	r0, #0
}
   140bc:	bd70      	pop	{r4, r5, r6, pc}
        udpInitCount++;
   140be:	3301      	adds	r3, #1
   140c0:	4a2a      	ldr	r2, [pc, #168]	; (1416c <TCPIP_UDP_Initialize+0xdc>)
   140c2:	6013      	str	r3, [r2, #0]
        return true;
   140c4:	2001      	movs	r0, #1
   140c6:	4770      	bx	lr
        SYS_ERROR(SYS_ERROR_ERROR, "UDP NULL dynamic allocation handle");
   140c8:	f00d ffc2 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
   140cc:	b908      	cbnz	r0, 140d2 <TCPIP_UDP_Initialize+0x42>
        return false;
   140ce:	2000      	movs	r0, #0
   140d0:	e7f4      	b.n	140bc <TCPIP_UDP_Initialize+0x2c>
        SYS_ERROR(SYS_ERROR_ERROR, "UDP NULL dynamic allocation handle");
   140d2:	f00d ffb7 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
   140d6:	4927      	ldr	r1, [pc, #156]	; (14174 <TCPIP_UDP_Initialize+0xe4>)
   140d8:	f006 fce0 	bl	1aa9c <SYS_CONSOLE_Print>
        return false;
   140dc:	2000      	movs	r0, #0
   140de:	e7ed      	b.n	140bc <TCPIP_UDP_Initialize+0x2c>
    signalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_UDP_Task, 0);
   140e0:	2200      	movs	r2, #0
   140e2:	4925      	ldr	r1, [pc, #148]	; (14178 <TCPIP_UDP_Initialize+0xe8>)
   140e4:	2009      	movs	r0, #9
   140e6:	f008 ff6b 	bl	1cfc0 <_TCPIPStackSignalHandlerRegister>
   140ea:	4b24      	ldr	r3, [pc, #144]	; (1417c <TCPIP_UDP_Initialize+0xec>)
   140ec:	6018      	str	r0, [r3, #0]
    if(signalHandle == 0)
   140ee:	b308      	cbz	r0, 14134 <TCPIP_UDP_Initialize+0xa4>
    newSktDcpt = (UDP_SOCKET_DCPT**)TCPIP_HEAP_Calloc(stackCtrl->memH, pUdpInit->nSockets, sizeof(UDP_SOCKET_DCPT*));
   140f0:	68e0      	ldr	r0, [r4, #12]
   140f2:	6883      	ldr	r3, [r0, #8]
   140f4:	2204      	movs	r2, #4
   140f6:	8829      	ldrh	r1, [r5, #0]
   140f8:	4798      	blx	r3
    if(newSktDcpt == 0)
   140fa:	4606      	mov	r6, r0
   140fc:	b1f8      	cbz	r0, 1413e <TCPIP_UDP_Initialize+0xae>
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   140fe:	2000      	movs	r0, #0
   14100:	f00d fa5c 	bl	215bc <OSAL_CRIT_Enter>
    udpMemH = stackCtrl->memH;
   14104:	68e2      	ldr	r2, [r4, #12]
   14106:	4b1e      	ldr	r3, [pc, #120]	; (14180 <TCPIP_UDP_Initialize+0xf0>)
   14108:	601a      	str	r2, [r3, #0]
    nUdpSockets = pUdpInit->nSockets;
   1410a:	882a      	ldrh	r2, [r5, #0]
   1410c:	4b1d      	ldr	r3, [pc, #116]	; (14184 <TCPIP_UDP_Initialize+0xf4>)
   1410e:	601a      	str	r2, [r3, #0]
    udpDefTxSize = pUdpInit->sktTxBuffSize;
   14110:	886a      	ldrh	r2, [r5, #2]
   14112:	4b1d      	ldr	r3, [pc, #116]	; (14188 <TCPIP_UDP_Initialize+0xf8>)
   14114:	801a      	strh	r2, [r3, #0]
    UDPSocketDcpt = newSktDcpt;
   14116:	4b1d      	ldr	r3, [pc, #116]	; (1418c <TCPIP_UDP_Initialize+0xfc>)
   14118:	601e      	str	r6, [r3, #0]
    udpInitCount++;
   1411a:	4a14      	ldr	r2, [pc, #80]	; (1416c <TCPIP_UDP_Initialize+0xdc>)
   1411c:	6813      	ldr	r3, [r2, #0]
   1411e:	3301      	adds	r3, #1
   14120:	6013      	str	r3, [r2, #0]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   14122:	4601      	mov	r1, r0
   14124:	2000      	movs	r0, #0
   14126:	f00d fb78 	bl	2181a <OSAL_CRIT_Leave>
    OSAL_SEM_Post(&userSem);
   1412a:	4811      	ldr	r0, [pc, #68]	; (14170 <TCPIP_UDP_Initialize+0xe0>)
   1412c:	f00d fa52 	bl	215d4 <OSAL_SEM_Post>
    return true;
   14130:	2001      	movs	r0, #1
   14132:	e7c3      	b.n	140bc <TCPIP_UDP_Initialize+0x2c>
    OSAL_SEM_Delete(&userSem);
   14134:	480e      	ldr	r0, [pc, #56]	; (14170 <TCPIP_UDP_Initialize+0xe0>)
   14136:	f00d fca9 	bl	21a8c <OSAL_SEM_Delete>
        return false;
   1413a:	2000      	movs	r0, #0
   1413c:	e7be      	b.n	140bc <TCPIP_UDP_Initialize+0x2c>
        SYS_ERROR(SYS_ERROR_ERROR, "UDP Dynamic allocation failed");
   1413e:	f00d ff87 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
   14142:	b940      	cbnz	r0, 14156 <TCPIP_UDP_Initialize+0xc6>
    OSAL_SEM_Delete(&userSem);
   14144:	480a      	ldr	r0, [pc, #40]	; (14170 <TCPIP_UDP_Initialize+0xe0>)
   14146:	f00d fca1 	bl	21a8c <OSAL_SEM_Delete>
        _TCPIPStackSignalHandlerDeregister(signalHandle);
   1414a:	4b0c      	ldr	r3, [pc, #48]	; (1417c <TCPIP_UDP_Initialize+0xec>)
   1414c:	6818      	ldr	r0, [r3, #0]
   1414e:	f00d fdf0 	bl	21d32 <_TCPIPStackSignalHandlerDeregister>
        return false;
   14152:	2000      	movs	r0, #0
   14154:	e7b2      	b.n	140bc <TCPIP_UDP_Initialize+0x2c>
        SYS_ERROR(SYS_ERROR_ERROR, "UDP Dynamic allocation failed");
   14156:	f00d ff75 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
   1415a:	490d      	ldr	r1, [pc, #52]	; (14190 <TCPIP_UDP_Initialize+0x100>)
   1415c:	f006 fc9e 	bl	1aa9c <SYS_CONSOLE_Print>
   14160:	e7f0      	b.n	14144 <TCPIP_UDP_Initialize+0xb4>
        return true;    // do not store per interface data
   14162:	2001      	movs	r0, #1
}
   14164:	4770      	bx	lr
        return false;
   14166:	2000      	movs	r0, #0
   14168:	e7a8      	b.n	140bc <TCPIP_UDP_Initialize+0x2c>
   1416a:	bf00      	nop
   1416c:	2000e460 	.word	0x2000e460
   14170:	2000e468 	.word	0x2000e468
   14174:	0001d698 	.word	0x0001d698
   14178:	0000d805 	.word	0x0000d805
   1417c:	2000e45c 	.word	0x2000e45c
   14180:	2000e464 	.word	0x2000e464
   14184:	2000e458 	.word	0x2000e458
   14188:	2000e508 	.word	0x2000e508
   1418c:	2000e454 	.word	0x2000e454
   14190:	0001d6bc 	.word	0x0001d6bc

Disassembly of section .rodata._ctype_%289:

00014194 <_ctype_>:
   14194:	20202000 20202020 28282020 20282828     .         ((((( 
   141a4:	20202020 20202020 20202020 20202020                     
   141b4:	10108820 10101010 10101010 10101010      ...............
   141c4:	04040410 04040404 10040404 10101010     ................
   141d4:	41411010 41414141 01010101 01010101     ..AAAAAA........
   141e4:	01010101 01010101 01010101 10101010     ................
   141f4:	42421010 42424242 02020202 02020202     ..BBBBBB........
   14204:	02020202 02020202 02020202 10101010     ................
   14214:	00000020 00000000 00000000 00000000      ...............
	...

Disassembly of section .rodata.K%290:

00014298 <K>:
   14298:	428a2f98 71374491 b5c0fbcf e9b5dba5     ./.B.D7q........
   142a8:	3956c25b 59f111f1 923f82a4 ab1c5ed5     [.V9...Y..?..^..
   142b8:	d807aa98 12835b01 243185be 550c7dc3     .....[....1$.}.U
   142c8:	72be5d74 80deb1fe 9bdc06a7 c19bf174     t].r........t...
   142d8:	e49b69c1 efbe4786 0fc19dc6 240ca1cc     .i...G.........$
   142e8:	2de92c6f 4a7484aa 5cb0a9dc 76f988da     o,.-..tJ...\...v
   142f8:	983e5152 a831c66d b00327c8 bf597fc7     RQ>.m.1..'....Y.
   14308:	c6e00bf3 d5a79147 06ca6351 14292967     ....G...Qc..g)).
   14318:	27b70a85 2e1b2138 4d2c6dfc 53380d13     ...'8!...m,M..8S
   14328:	650a7354 766a0abb 81c2c92e 92722c85     Ts.e..jv.....,r.
   14338:	a2bfe8a1 a81a664b c24b8b70 c76c51a3     ....Kf..p.K..Ql.
   14348:	d192e819 d6990624 f40e3585 106aa070     ....$....5..p.j.
   14358:	19a4c116 1e376c08 2748774c 34b0bcb5     .....l7.LwH'...4
   14368:	391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3     ...9J..NO..[.o.h
   14378:	748f82ee 78a5636f 84c87814 8cc70208     ...toc.x.x......
   14388:	90befffa a4506ceb bef9a3f7 c67178f2     .....lP......xq.

Disassembly of section .text.wc_Md5Update%291:

00014398 <wc_Md5Update>:
    return ret;
}

/* do block size increments/updates */
int wc_Md5Update(wc_Md5* md5, const byte* data, word32 len)
{
   14398:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    int ret = 0;
    word32 blocksLen;
    byte* local;

    if (md5 == NULL || (data == NULL && len > 0)) {
   1439c:	2800      	cmp	r0, #0
   1439e:	d071      	beq.n	14484 <wc_Md5Update+0xec>
   143a0:	460c      	mov	r4, r1
   143a2:	4690      	mov	r8, r2
   143a4:	4606      	mov	r6, r0
   143a6:	2900      	cmp	r1, #0
   143a8:	d03b      	beq.n	14422 <wc_Md5Update+0x8a>
#endif
    }
#endif /* WOLFSSL_ASYNC_CRYPT */

    /* check that internal buffLen is valid */
    if (md5->buffLen >= WC_MD5_BLOCK_SIZE)
   143aa:	6800      	ldr	r0, [r0, #0]
   143ac:	283f      	cmp	r0, #63	; 0x3f
   143ae:	d86f      	bhi.n	14490 <wc_Md5Update+0xf8>
    word32 tmp = md5->loLen;
   143b0:	6872      	ldr	r2, [r6, #4]
    if ((md5->loLen += len) < tmp) {
   143b2:	eb08 0302 	add.w	r3, r8, r2
   143b6:	6073      	str	r3, [r6, #4]
   143b8:	429a      	cmp	r2, r3
   143ba:	d902      	bls.n	143c2 <wc_Md5Update+0x2a>
        md5->hiLen++;                       /* carry low to high */
   143bc:	68b3      	ldr	r3, [r6, #8]
   143be:	3301      	adds	r3, #1
   143c0:	60b3      	str	r3, [r6, #8]
    }

    /* add length for final */
    AddLength(md5, len);

    local = (byte*)md5->buffer;
   143c2:	f106 050c 	add.w	r5, r6, #12

    /* process any remainder from previous operation */
    if (md5->buffLen > 0) {
   143c6:	bba8      	cbnz	r0, 14434 <wc_Md5Update+0x9c>
        XTRANSFORM_LEN(md5, data, blocksLen);
        data += blocksLen;
        len  -= blocksLen;
    }
#else
    while (len >= WC_MD5_BLOCK_SIZE) {
   143c8:	f1b8 0f3f 	cmp.w	r8, #63	; 0x3f
   143cc:	d94e      	bls.n	1446c <wc_Md5Update+0xd4>
   143ce:	f1a8 0740 	sub.w	r7, r8, #64	; 0x40
   143d2:	f027 073f 	bic.w	r7, r7, #63	; 0x3f
   143d6:	3740      	adds	r7, #64	; 0x40
   143d8:	4427      	add	r7, r4
            local32 = (word32*)data;
        }
        else
    #endif
        {
            XMEMCPY(local32, data, WC_MD5_BLOCK_SIZE);
   143da:	4623      	mov	r3, r4
   143dc:	462a      	mov	r2, r5
   143de:	f104 0940 	add.w	r9, r4, #64	; 0x40
   143e2:	f8d3 e000 	ldr.w	lr, [r3]
   143e6:	f8d3 c004 	ldr.w	ip, [r3, #4]
   143ea:	6898      	ldr	r0, [r3, #8]
   143ec:	68d9      	ldr	r1, [r3, #12]
   143ee:	f8c2 e000 	str.w	lr, [r2]
   143f2:	f8c2 c004 	str.w	ip, [r2, #4]
   143f6:	6090      	str	r0, [r2, #8]
   143f8:	60d1      	str	r1, [r2, #12]
   143fa:	3310      	adds	r3, #16
   143fc:	3210      	adds	r2, #16
   143fe:	454b      	cmp	r3, r9
   14400:	d1ef      	bne.n	143e2 <wc_Md5Update+0x4a>
        }

        data += WC_MD5_BLOCK_SIZE;
   14402:	3440      	adds	r4, #64	; 0x40

    #if defined(BIG_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
        ByteReverseWords(local32, local32, WC_MD5_BLOCK_SIZE);
    #endif

        ret = XTRANSFORM(md5, (const byte*)local32);
   14404:	4629      	mov	r1, r5
   14406:	4630      	mov	r0, r6
   14408:	f7f2 faaa 	bl	6960 <Transform>
   1440c:	4681      	mov	r9, r0
    while (len >= WC_MD5_BLOCK_SIZE) {
   1440e:	42bc      	cmp	r4, r7
   14410:	d1e3      	bne.n	143da <wc_Md5Update+0x42>
   14412:	f008 083f 	and.w	r8, r8, #63	; 0x3f
    }
#endif /* XTRANSFORM_LEN */

    /* save remainder */
    if (len > 0) {
   14416:	f1b8 0f00 	cmp.w	r8, #0
   1441a:	d12b      	bne.n	14474 <wc_Md5Update+0xdc>
        XMEMCPY(local, data, len);
        md5->buffLen = len;
    }

    return ret;
}
   1441c:	4648      	mov	r0, r9
   1441e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (md5 == NULL || (data == NULL && len > 0)) {
   14422:	bb92      	cbnz	r2, 1448a <wc_Md5Update+0xf2>
    if (md5->buffLen >= WC_MD5_BLOCK_SIZE)
   14424:	6803      	ldr	r3, [r0, #0]
        return BUFFER_E;
   14426:	2b40      	cmp	r3, #64	; 0x40
   14428:	bf34      	ite	cc
   1442a:	f04f 0900 	movcc.w	r9, #0
   1442e:	f06f 0983 	mvncs.w	r9, #131	; 0x83
   14432:	e7f3      	b.n	1441c <wc_Md5Update+0x84>
        blocksLen = min(len, WC_MD5_BLOCK_SIZE - md5->buffLen);
   14434:	f1c0 0740 	rsb	r7, r0, #64	; 0x40
        return a > b ? b : a;
   14438:	4547      	cmp	r7, r8
   1443a:	bf28      	it	cs
   1443c:	4647      	movcs	r7, r8
        XMEMCPY(&local[md5->buffLen], data, blocksLen);
   1443e:	463a      	mov	r2, r7
   14440:	4621      	mov	r1, r4
   14442:	4428      	add	r0, r5
   14444:	f00c fe9c 	bl	21180 <memcpy>
        md5->buffLen += blocksLen;
   14448:	6833      	ldr	r3, [r6, #0]
   1444a:	443b      	add	r3, r7
   1444c:	6033      	str	r3, [r6, #0]
        data         += blocksLen;
   1444e:	443c      	add	r4, r7
        len          -= blocksLen;
   14450:	eba8 0807 	sub.w	r8, r8, r7
        if (md5->buffLen == WC_MD5_BLOCK_SIZE) {
   14454:	2b40      	cmp	r3, #64	; 0x40
   14456:	d1b7      	bne.n	143c8 <wc_Md5Update+0x30>
            ret = XTRANSFORM(md5, (const byte*)local);
   14458:	4629      	mov	r1, r5
   1445a:	4630      	mov	r0, r6
   1445c:	f7f2 fa80 	bl	6960 <Transform>
            if (ret != 0)
   14460:	4681      	mov	r9, r0
   14462:	2800      	cmp	r0, #0
   14464:	d1da      	bne.n	1441c <wc_Md5Update+0x84>
            md5->buffLen = 0;
   14466:	2300      	movs	r3, #0
   14468:	6033      	str	r3, [r6, #0]
   1446a:	e7ad      	b.n	143c8 <wc_Md5Update+0x30>
    while (len >= WC_MD5_BLOCK_SIZE) {
   1446c:	4627      	mov	r7, r4
   1446e:	f04f 0900 	mov.w	r9, #0
   14472:	e7d0      	b.n	14416 <wc_Md5Update+0x7e>
        XMEMCPY(local, data, len);
   14474:	4642      	mov	r2, r8
   14476:	4639      	mov	r1, r7
   14478:	4628      	mov	r0, r5
   1447a:	f00c fe81 	bl	21180 <memcpy>
        md5->buffLen = len;
   1447e:	f8c6 8000 	str.w	r8, [r6]
   14482:	e7cb      	b.n	1441c <wc_Md5Update+0x84>
        return BAD_FUNC_ARG;
   14484:	f06f 09ac 	mvn.w	r9, #172	; 0xac
   14488:	e7c8      	b.n	1441c <wc_Md5Update+0x84>
   1448a:	f06f 09ac 	mvn.w	r9, #172	; 0xac
   1448e:	e7c5      	b.n	1441c <wc_Md5Update+0x84>
        return BUFFER_E;
   14490:	f06f 0983 	mvn.w	r9, #131	; 0x83
   14494:	e7c2      	b.n	1441c <wc_Md5Update+0x84>

Disassembly of section .text.TCPIP_ICMP_EchoRequest%292:

00014498 <TCPIP_ICMP_EchoRequest>:
{
   14498:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    if(pHandle)
   1449c:	4688      	mov	r8, r1
   1449e:	b109      	cbz	r1, 144a4 <TCPIP_ICMP_EchoRequest+0xc>
        *pHandle = 0;
   144a0:	2300      	movs	r3, #0
   144a2:	600b      	str	r3, [r1, #0]
    if(pIcmpEchoRequest != 0)
   144a4:	4b38      	ldr	r3, [pc, #224]	; (14588 <TCPIP_ICMP_EchoRequest+0xf0>)
   144a6:	681b      	ldr	r3, [r3, #0]
   144a8:	2b00      	cmp	r3, #0
   144aa:	d15a      	bne.n	14562 <TCPIP_ICMP_EchoRequest+0xca>
    if(pEchoRequest == 0)
   144ac:	2800      	cmp	r0, #0
   144ae:	d05b      	beq.n	14568 <TCPIP_ICMP_EchoRequest+0xd0>
   144b0:	4604      	mov	r4, r0
        pktSize = sizeof(ICMP_PACKET) + pEchoRequest->dataSize;
   144b2:	8a05      	ldrh	r5, [r0, #16]
   144b4:	3508      	adds	r5, #8
   144b6:	b2ad      	uxth	r5, r5
        pTxPkt = _ICMPAllocateTxPacketStruct(pktSize);
   144b8:	4628      	mov	r0, r5
   144ba:	f00b ffad 	bl	20418 <_ICMPAllocateTxPacketStruct>
        if(pTxPkt == 0)
   144be:	4607      	mov	r7, r0
   144c0:	2800      	cmp	r0, #0
   144c2:	d054      	beq.n	1456e <TCPIP_ICMP_EchoRequest+0xd6>
        pICMPPkt = (ICMP_PACKET*)pTxPkt->macPkt.pTransportLayer;
   144c4:	69c6      	ldr	r6, [r0, #28]
        pICMPPkt->vType = ICMP_TYPE_ECHO_REQUEST; 
   144c6:	2308      	movs	r3, #8
   144c8:	7033      	strb	r3, [r6, #0]
        pICMPPkt->vCode = ICMP_CODE_ECHO_REQUEST;
   144ca:	f04f 0900 	mov.w	r9, #0
   144ce:	f886 9001 	strb.w	r9, [r6, #1]
        pICMPPkt->wChecksum = 0x0000;
   144d2:	f8a6 9002 	strh.w	r9, [r6, #2]
        pICMPPkt->wIdentifier = pEchoRequest->identifier;
   144d6:	8963      	ldrh	r3, [r4, #10]
   144d8:	80b3      	strh	r3, [r6, #4]
        pICMPPkt->wSequenceNumber = pEchoRequest->sequenceNumber;
   144da:	8923      	ldrh	r3, [r4, #8]
   144dc:	80f3      	strh	r3, [r6, #6]
        memcpy(pICMPPkt->wData, pEchoRequest->pData, pEchoRequest->dataSize);
   144de:	8a22      	ldrh	r2, [r4, #16]
   144e0:	68e1      	ldr	r1, [r4, #12]
   144e2:	f106 0008 	add.w	r0, r6, #8
   144e6:	f00c fe4b 	bl	21180 <memcpy>
        pICMPPkt->wChecksum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pICMPPkt, pktSize, 0);
   144ea:	464a      	mov	r2, r9
   144ec:	4629      	mov	r1, r5
   144ee:	4630      	mov	r0, r6
   144f0:	f006 f87c 	bl	1a5ec <TCPIP_Helper_CalcIPChecksum>
   144f4:	8070      	strh	r0, [r6, #2]
        pTxPkt->destAddress.Val = pEchoRequest->targetAddr.Val;
   144f6:	6863      	ldr	r3, [r4, #4]
   144f8:	63bb      	str	r3, [r7, #56]	; 0x38
        pTxPkt->netIfH = TCPIP_IPV4_SelectSourceInterface(pEchoRequest->netH, &pTxPkt->destAddress, &pTxPkt->srcAddress, false);
   144fa:	464b      	mov	r3, r9
   144fc:	f107 0234 	add.w	r2, r7, #52	; 0x34
   14500:	f107 0138 	add.w	r1, r7, #56	; 0x38
   14504:	6820      	ldr	r0, [r4, #0]
   14506:	f008 fb83 	bl	1cc10 <TCPIP_IPV4_SelectSourceInterface>
   1450a:	63f8      	str	r0, [r7, #60]	; 0x3c
        if(pTxPkt->netIfH == 0)
   1450c:	2800      	cmp	r0, #0
   1450e:	d033      	beq.n	14578 <TCPIP_ICMP_EchoRequest+0xe0>
        icmpEchoRequest = *pEchoRequest;
   14510:	4e1e      	ldr	r6, [pc, #120]	; (1458c <TCPIP_ICMP_EchoRequest+0xf4>)
   14512:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   14514:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   14516:	e894 0003 	ldmia.w	r4, {r0, r1}
   1451a:	e886 0003 	stmia.w	r6, {r0, r1}
        pTxPkt->macPkt.pDSeg->segLen += pktSize;
   1451e:	693a      	ldr	r2, [r7, #16]
   14520:	8993      	ldrh	r3, [r2, #12]
   14522:	442b      	add	r3, r5
   14524:	8193      	strh	r3, [r2, #12]
        TCPIP_IPV4_PacketFormatTx(pTxPkt, IP_PROT_ICMP, pktSize, 0);
   14526:	464b      	mov	r3, r9
   14528:	462a      	mov	r2, r5
   1452a:	2101      	movs	r1, #1
   1452c:	4638      	mov	r0, r7
   1452e:	f7fe ff37 	bl	133a0 <TCPIP_IPV4_PacketFormatTx>
        if(!TCPIP_IPV4_PacketTransmit(pTxPkt))
   14532:	4638      	mov	r0, r7
   14534:	f00d fd4a 	bl	21fcc <TCPIP_IPV4_PacketTransmit>
   14538:	b910      	cbnz	r0, 14540 <TCPIP_ICMP_EchoRequest+0xa8>
            res = ICMP_ECHO_TRANSMIT_ERROR;
   1453a:	f06f 0402 	mvn.w	r4, #2
   1453e:	e01d      	b.n	1457c <TCPIP_ICMP_EchoRequest+0xe4>
        pIcmpEchoRequest = &icmpEchoRequest; // mark as busy
   14540:	4b11      	ldr	r3, [pc, #68]	; (14588 <TCPIP_ICMP_EchoRequest+0xf0>)
   14542:	f1a6 0210 	sub.w	r2, r6, #16
   14546:	601a      	str	r2, [r3, #0]
        icmpEchoStart = SYS_TMR_TickCountGet();
   14548:	f00b fdd0 	bl	200ec <SYS_TMR_TickCountGet>
   1454c:	4b10      	ldr	r3, [pc, #64]	; (14590 <TCPIP_ICMP_EchoRequest+0xf8>)
   1454e:	6018      	str	r0, [r3, #0]
        if(pHandle)
   14550:	f1b8 0f00 	cmp.w	r8, #0
   14554:	d00e      	beq.n	14574 <TCPIP_ICMP_EchoRequest+0xdc>
            *pHandle = pIcmpEchoRequest;
   14556:	4b0c      	ldr	r3, [pc, #48]	; (14588 <TCPIP_ICMP_EchoRequest+0xf0>)
   14558:	681b      	ldr	r3, [r3, #0]
   1455a:	f8c8 3000 	str.w	r3, [r8]
        res = ICMP_ECHO_OK;
   1455e:	464c      	mov	r4, r9
   14560:	e00f      	b.n	14582 <TCPIP_ICMP_EchoRequest+0xea>
        return ICMP_ECHO_BUSY;
   14562:	f06f 0404 	mvn.w	r4, #4
   14566:	e00c      	b.n	14582 <TCPIP_ICMP_EchoRequest+0xea>
        return ICMP_ECHO_PARAMETER_ERROR;
   14568:	f06f 0403 	mvn.w	r4, #3
   1456c:	e009      	b.n	14582 <TCPIP_ICMP_EchoRequest+0xea>
            res = ICMP_ECHO_ALLOC_ERROR;
   1456e:	f04f 34ff 	mov.w	r4, #4294967295
   14572:	e006      	b.n	14582 <TCPIP_ICMP_EchoRequest+0xea>
        res = ICMP_ECHO_OK;
   14574:	2400      	movs	r4, #0
   14576:	e004      	b.n	14582 <TCPIP_ICMP_EchoRequest+0xea>
            res = ICMP_ECHO_ROUTE_ERROR;
   14578:	f06f 0401 	mvn.w	r4, #1
        TCPIP_PKT_PacketFree(&pTxPkt->macPkt);
   1457c:	4638      	mov	r0, r7
   1457e:	f009 fe43 	bl	1e208 <_TCPIP_PKT_PacketFree>
}
   14582:	4620      	mov	r0, r4
   14584:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   14588:	2000e384 	.word	0x2000e384
   1458c:	2000e1cc 	.word	0x2000e1cc
   14590:	2000e374 	.word	0x2000e374

Disassembly of section .text._Command_AddressService%293:

00014594 <_Command_AddressService>:
{ 
   14594:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   14598:	4604      	mov	r4, r0
   1459a:	4615      	mov	r5, r2
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   1459c:	6846      	ldr	r6, [r0, #4]
    if (argc != 3)
   1459e:	2903      	cmp	r1, #3
   145a0:	d011      	beq.n	145c6 <_Command_AddressService+0x32>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Usage: %s <interface> <on/off> \r\n", argv[0]);
   145a2:	4f31      	ldr	r7, [pc, #196]	; (14668 <_Command_AddressService+0xd4>)
   145a4:	6803      	ldr	r3, [r0, #0]
   145a6:	685b      	ldr	r3, [r3, #4]
   145a8:	6812      	ldr	r2, [r2, #0]
   145aa:	f507 71ec 	add.w	r1, r7, #472	; 0x1d8
   145ae:	4630      	mov	r0, r6
   145b0:	4798      	blx	r3
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Ex: %s PIC32INT on \r\n", argv[0]);
   145b2:	6823      	ldr	r3, [r4, #0]
   145b4:	685b      	ldr	r3, [r3, #4]
   145b6:	682a      	ldr	r2, [r5, #0]
   145b8:	f507 71fe 	add.w	r1, r7, #508	; 0x1fc
   145bc:	4630      	mov	r0, r6
   145be:	4798      	blx	r3
        return false;
   145c0:	2000      	movs	r0, #0
}
   145c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   145c6:	461f      	mov	r7, r3
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
   145c8:	6850      	ldr	r0, [r2, #4]
   145ca:	f009 faf3 	bl	1dbb4 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
   145ce:	4681      	mov	r9, r0
   145d0:	b310      	cbz	r0, 14618 <_Command_AddressService+0x84>
    if (memcmp(argv[2], "on", 2) == 0)
   145d2:	f8d5 8008 	ldr.w	r8, [r5, #8]
   145d6:	2202      	movs	r2, #2
   145d8:	4924      	ldr	r1, [pc, #144]	; (1466c <_Command_AddressService+0xd8>)
   145da:	4640      	mov	r0, r8
   145dc:	f00c fdc2 	bl	21164 <memcmp>
   145e0:	2800      	cmp	r0, #0
   145e2:	d037      	beq.n	14654 <_Command_AddressService+0xc0>
    else if (memcmp(argv[2], "off", 2) == 0)
   145e4:	2202      	movs	r2, #2
   145e6:	4922      	ldr	r1, [pc, #136]	; (14670 <_Command_AddressService+0xdc>)
   145e8:	4640      	mov	r0, r8
   145ea:	f00c fdbb 	bl	21164 <memcmp>
   145ee:	b9d0      	cbnz	r0, 14626 <_Command_AddressService+0x92>
    switch(svcType)
   145f0:	2f01      	cmp	r7, #1
   145f2:	d131      	bne.n	14658 <_Command_AddressService+0xc4>
            addFnc = svcEnable?TCPIP_DHCP_Enable:TCPIP_DHCP_Disable;
   145f4:	4b1f      	ldr	r3, [pc, #124]	; (14674 <_Command_AddressService+0xe0>)
        msgOK   = svcEnable?"enabled":"disabled";
   145f6:	4a1c      	ldr	r2, [pc, #112]	; (14668 <_Command_AddressService+0xd4>)
   145f8:	f502 77da 	add.w	r7, r2, #436	; 0x1b4
        msgFail = svcEnable?"enable":"disable";
   145fc:	f502 78e0 	add.w	r8, r2, #448	; 0x1c0
        addRes = (*addFnc)(netH);
   14600:	4648      	mov	r0, r9
   14602:	4798      	blx	r3
        if(addRes)
   14604:	b1e8      	cbz	r0, 14642 <_Command_AddressService+0xae>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "%s %s\r\n", argv[0], msgOK);
   14606:	6823      	ldr	r3, [r4, #0]
   14608:	685c      	ldr	r4, [r3, #4]
   1460a:	463b      	mov	r3, r7
   1460c:	682a      	ldr	r2, [r5, #0]
   1460e:	491a      	ldr	r1, [pc, #104]	; (14678 <_Command_AddressService+0xe4>)
   14610:	4630      	mov	r0, r6
   14612:	47a0      	blx	r4
    return true;
   14614:	2001      	movs	r0, #1
   14616:	e7d4      	b.n	145c2 <_Command_AddressService+0x2e>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface\r\n");
   14618:	6823      	ldr	r3, [r4, #0]
   1461a:	681b      	ldr	r3, [r3, #0]
   1461c:	4917      	ldr	r1, [pc, #92]	; (1467c <_Command_AddressService+0xe8>)
   1461e:	4630      	mov	r0, r6
   14620:	4798      	blx	r3
        return false;
   14622:	2000      	movs	r0, #0
   14624:	e7cd      	b.n	145c2 <_Command_AddressService+0x2e>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown option\r\n");
   14626:	6823      	ldr	r3, [r4, #0]
   14628:	681b      	ldr	r3, [r3, #0]
   1462a:	4915      	ldr	r1, [pc, #84]	; (14680 <_Command_AddressService+0xec>)
   1462c:	4630      	mov	r0, r6
   1462e:	4798      	blx	r3
        return false;
   14630:	2000      	movs	r0, #0
   14632:	e7c6      	b.n	145c2 <_Command_AddressService+0x2e>
            addFnc = svcEnable?TCPIP_DHCP_Enable:TCPIP_DHCP_Disable;
   14634:	4b13      	ldr	r3, [pc, #76]	; (14684 <_Command_AddressService+0xf0>)
        msgOK   = svcEnable?"enabled":"disabled";
   14636:	4a0c      	ldr	r2, [pc, #48]	; (14668 <_Command_AddressService+0xd4>)
   14638:	f502 77e4 	add.w	r7, r2, #456	; 0x1c8
        msgFail = svcEnable?"enable":"disable";
   1463c:	f502 78e8 	add.w	r8, r2, #464	; 0x1d0
   14640:	e7de      	b.n	14600 <_Command_AddressService+0x6c>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Failed to %s %s\r\n", msgFail, argv[0]);
   14642:	6823      	ldr	r3, [r4, #0]
   14644:	685c      	ldr	r4, [r3, #4]
   14646:	682b      	ldr	r3, [r5, #0]
   14648:	4642      	mov	r2, r8
   1464a:	490f      	ldr	r1, [pc, #60]	; (14688 <_Command_AddressService+0xf4>)
   1464c:	4630      	mov	r0, r6
   1464e:	47a0      	blx	r4
    return true;
   14650:	2001      	movs	r0, #1
   14652:	e7b6      	b.n	145c2 <_Command_AddressService+0x2e>
    switch(svcType)
   14654:	2f01      	cmp	r7, #1
   14656:	d0ed      	beq.n	14634 <_Command_AddressService+0xa0>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Unknown service %s\r\n", argv[0]);
   14658:	6823      	ldr	r3, [r4, #0]
   1465a:	685b      	ldr	r3, [r3, #4]
   1465c:	682a      	ldr	r2, [r5, #0]
   1465e:	490b      	ldr	r1, [pc, #44]	; (1468c <_Command_AddressService+0xf8>)
   14660:	4630      	mov	r0, r6
   14662:	4798      	blx	r3
    return true;
   14664:	2001      	movs	r0, #1
   14666:	e7ac      	b.n	145c2 <_Command_AddressService+0x2e>
   14668:	0000028c 	.word	0x0000028c
   1466c:	000004b4 	.word	0x000004b4
   14670:	000004b8 	.word	0x000004b8
   14674:	0001b5d1 	.word	0x0001b5d1
   14678:	000004d0 	.word	0x000004d0
   1467c:	000004a0 	.word	0x000004a0
   14680:	000004bc 	.word	0x000004bc
   14684:	0001b9e1 	.word	0x0001b9e1
   14688:	000004d8 	.word	0x000004d8
   1468c:	000004ec 	.word	0x000004ec

Disassembly of section .text._Command_HeapInfo%294:

00014690 <_Command_HeapInfo>:
{
   14690:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14694:	b085      	sub	sp, #20
   14696:	4605      	mov	r5, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   14698:	6843      	ldr	r3, [r0, #4]
   1469a:	9301      	str	r3, [sp, #4]
    if (argc > 1)
   1469c:	2901      	cmp	r1, #1
   1469e:	dc51      	bgt.n	14744 <_Command_HeapInfo+0xb4>
    bool hasArgs = false;
   146a0:	2300      	movs	r3, #0
   146a2:	9303      	str	r3, [sp, #12]
        endType = TCPIP_STACK_HEAP_TYPES;
   146a4:	2704      	movs	r7, #4
        startType = TCPIP_STACK_HEAP_TYPE_NONE + 1;
   146a6:	2601      	movs	r6, #1
    for(hType = startType; hType < endType; hType++)
   146a8:	4b35      	ldr	r3, [pc, #212]	; (14780 <_Command_HeapInfo+0xf0>)
   146aa:	eb03 0986 	add.w	r9, r3, r6, lsl #2
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Heap type: %s. Initial created heap size: %d Bytes\r\n", typeMsg, heapSize);
   146ae:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 14788 <_Command_HeapInfo+0xf8>
   146b2:	f508 6310 	add.w	r3, r8, #2304	; 0x900
   146b6:	9302      	str	r3, [sp, #8]
   146b8:	46ba      	mov	sl, r7
        typeMsg = heapTypeStr[hType];
   146ba:	f859 7b04 	ldr.w	r7, [r9], #4
        heapH = TCPIP_STACK_HeapHandleGet(hType, 0);
   146be:	2100      	movs	r1, #0
   146c0:	b2f0      	uxtb	r0, r6
   146c2:	f00d f93d 	bl	21940 <TCPIP_STACK_HeapHandleGet>
        if(heapH == 0)
   146c6:	4604      	mov	r4, r0
   146c8:	2800      	cmp	r0, #0
   146ca:	d04e      	beq.n	1476a <_Command_HeapInfo+0xda>
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Size)(h);
   146cc:	6903      	ldr	r3, [r0, #16]
   146ce:	4798      	blx	r3
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Heap type: %s. Initial created heap size: %d Bytes\r\n", typeMsg, heapSize);
   146d0:	682b      	ldr	r3, [r5, #0]
   146d2:	f8d3 b004 	ldr.w	fp, [r3, #4]
   146d6:	4603      	mov	r3, r0
   146d8:	463a      	mov	r2, r7
   146da:	9902      	ldr	r1, [sp, #8]
   146dc:	9801      	ldr	r0, [sp, #4]
   146de:	47d8      	blx	fp
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Allocable block heap size: %d Bytes\r\n", TCPIP_HEAP_MaxSize(heapH));
   146e0:	682b      	ldr	r3, [r5, #0]
   146e2:	685f      	ldr	r7, [r3, #4]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_MaxSize)(h);
   146e4:	6963      	ldr	r3, [r4, #20]
   146e6:	4620      	mov	r0, r4
   146e8:	4798      	blx	r3
   146ea:	4602      	mov	r2, r0
   146ec:	f608 1138 	addw	r1, r8, #2360	; 0x938
   146f0:	9801      	ldr	r0, [sp, #4]
   146f2:	47b8      	blx	r7
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "All available heap size: %d Bytes, high watermark: %d\r\n", TCPIP_HEAP_FreeSize(heapH), TCPIP_HEAP_HighWatermark(heapH));
   146f4:	682b      	ldr	r3, [r5, #0]
   146f6:	685f      	ldr	r7, [r3, #4]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_FreeSize)(h);
   146f8:	69a3      	ldr	r3, [r4, #24]
   146fa:	4620      	mov	r0, r4
   146fc:	4798      	blx	r3
   146fe:	4683      	mov	fp, r0
}
#define TCPIP_HEAP_FreeSize(h) TCPIP_HEAP_FreeSizeInline(h)

static __inline__ size_t __attribute__((always_inline)) TCPIP_HEAP_HighWatermarkInline(TCPIP_STACK_HEAP_HANDLE h)
{
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_HighWatermark)(h);
   14700:	69e3      	ldr	r3, [r4, #28]
   14702:	4620      	mov	r0, r4
   14704:	4798      	blx	r3
   14706:	4603      	mov	r3, r0
   14708:	465a      	mov	r2, fp
   1470a:	f508 6116 	add.w	r1, r8, #2400	; 0x960
   1470e:	f8dd b004 	ldr.w	fp, [sp, #4]
   14712:	4658      	mov	r0, fp
   14714:	47b8      	blx	r7
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Last heap error: 0x%x\r\n", TCPIP_HEAP_LastError(heapH));
   14716:	682b      	ldr	r3, [r5, #0]
   14718:	685f      	ldr	r7, [r3, #4]
}
#define TCPIP_HEAP_HighWatermark(h) TCPIP_HEAP_HighWatermarkInline(h)

static __inline__ TCPIP_STACK_HEAP_RES __attribute__((always_inline)) TCPIP_HEAP_LastErrorInline(TCPIP_STACK_HEAP_HANDLE h)
{
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_LastError)(h);
   1471a:	6a23      	ldr	r3, [r4, #32]
   1471c:	4620      	mov	r0, r4
   1471e:	4798      	blx	r3
   14720:	4602      	mov	r2, r0
   14722:	f608 1198 	addw	r1, r8, #2456	; 0x998
   14726:	4658      	mov	r0, fp
   14728:	47b8      	blx	r7
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "No Trace info exists.\r\n");
   1472a:	682b      	ldr	r3, [r5, #0]
   1472c:	681b      	ldr	r3, [r3, #0]
   1472e:	f508 611b 	add.w	r1, r8, #2480	; 0x9b0
   14732:	4658      	mov	r0, fp
   14734:	4798      	blx	r3
    for(hType = startType; hType < endType; hType++)
   14736:	3601      	adds	r6, #1
   14738:	45b2      	cmp	sl, r6
   1473a:	d8be      	bhi.n	146ba <_Command_HeapInfo+0x2a>
    return true;
   1473c:	2001      	movs	r0, #1
}
   1473e:	b005      	add	sp, #20
   14740:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        hType = (unsigned int)atoi(argv[1]);
   14744:	6850      	ldr	r0, [r2, #4]
   14746:	f00d fd5b 	bl	22200 <atoi>
   1474a:	4606      	mov	r6, r0
        if(hType == TCPIP_STACK_HEAP_TYPE_NONE || hType >= TCPIP_STACK_HEAP_TYPES)
   1474c:	1e43      	subs	r3, r0, #1
   1474e:	2b02      	cmp	r3, #2
   14750:	d803      	bhi.n	1475a <_Command_HeapInfo+0xca>
        endType = hType + 1;
   14752:	1c47      	adds	r7, r0, #1
        hasArgs = true;
   14754:	2301      	movs	r3, #1
   14756:	9303      	str	r3, [sp, #12]
   14758:	e7a6      	b.n	146a8 <_Command_HeapInfo+0x18>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Unknown heap type. Use: [1, %d]\r\n", TCPIP_STACK_HEAP_TYPES - 1);
   1475a:	682b      	ldr	r3, [r5, #0]
   1475c:	685b      	ldr	r3, [r3, #4]
   1475e:	2203      	movs	r2, #3
   14760:	4908      	ldr	r1, [pc, #32]	; (14784 <_Command_HeapInfo+0xf4>)
   14762:	9801      	ldr	r0, [sp, #4]
   14764:	4798      	blx	r3
            return false;
   14766:	2000      	movs	r0, #0
   14768:	e7e9      	b.n	1473e <_Command_HeapInfo+0xae>
            if(hasArgs == true)
   1476a:	9b03      	ldr	r3, [sp, #12]
   1476c:	2b00      	cmp	r3, #0
   1476e:	d0e2      	beq.n	14736 <_Command_HeapInfo+0xa6>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "No heap info exists for type: %s!\r\n", typeMsg);
   14770:	682b      	ldr	r3, [r5, #0]
   14772:	685b      	ldr	r3, [r3, #4]
   14774:	463a      	mov	r2, r7
   14776:	f608 01dc 	addw	r1, r8, #2268	; 0x8dc
   1477a:	9801      	ldr	r0, [sp, #4]
   1477c:	4798      	blx	r3
   1477e:	e7da      	b.n	14736 <_Command_HeapInfo+0xa6>
   14780:	00021b6c 	.word	0x00021b6c
   14784:	00000b44 	.word	0x00000b44
   14788:	0000028c 	.word	0x0000028c

Disassembly of section .text.CLOCK_Initialize%295:

0001478c <CLOCK_Initialize>:
}

static void OSC32KCTRL_Initialize(void)
{

    OSC32KCTRL_REGS->OSC32KCTRL_RTCCTRL = OSC32KCTRL_RTCCTRL_RTCSEL(0);
   1478c:	4b36      	ldr	r3, [pc, #216]	; (14868 <CLOCK_Initialize+0xdc>)
   1478e:	2200      	movs	r2, #0
   14790:	741a      	strb	r2, [r3, #16]
    }
}

static void GCLK2_Initialize(void)
{
    GCLK_REGS->GCLK_GENCTRL[2] = GCLK_GENCTRL_DIV(48) | GCLK_GENCTRL_SRC(6) | GCLK_GENCTRL_GENEN_Msk;
   14792:	f503 6300 	add.w	r3, r3, #2048	; 0x800
   14796:	4a35      	ldr	r2, [pc, #212]	; (1486c <CLOCK_Initialize+0xe0>)
   14798:	629a      	str	r2, [r3, #40]	; 0x28

    while((GCLK_REGS->GCLK_SYNCBUSY & GCLK_SYNCBUSY_GENCTRL_GCLK2) == GCLK_SYNCBUSY_GENCTRL_GCLK2)
   1479a:	461a      	mov	r2, r3
   1479c:	6853      	ldr	r3, [r2, #4]
   1479e:	f013 0f10 	tst.w	r3, #16
   147a2:	d1fb      	bne.n	1479c <CLOCK_Initialize+0x10>
    GCLK_REGS->GCLK_PCHCTRL[1] = GCLK_PCHCTRL_GEN(0x2)  | GCLK_PCHCTRL_CHEN_Msk;
   147a4:	4b32      	ldr	r3, [pc, #200]	; (14870 <CLOCK_Initialize+0xe4>)
   147a6:	2242      	movs	r2, #66	; 0x42
   147a8:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    while ((GCLK_REGS->GCLK_PCHCTRL[1] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
   147ac:	461a      	mov	r2, r3
   147ae:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
   147b2:	f013 0f40 	tst.w	r3, #64	; 0x40
   147b6:	d0fa      	beq.n	147ae <CLOCK_Initialize+0x22>
    OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLCTRLB = OSCCTRL_DPLLCTRLB_FILTER(0) | OSCCTRL_DPLLCTRLB_LTIME(0x0)| OSCCTRL_DPLLCTRLB_REFCLK(0) ;
   147b8:	4b2e      	ldr	r3, [pc, #184]	; (14874 <CLOCK_Initialize+0xe8>)
   147ba:	2200      	movs	r2, #0
   147bc:	639a      	str	r2, [r3, #56]	; 0x38
    OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLRATIO = OSCCTRL_DPLLRATIO_LDRFRAC(0) | OSCCTRL_DPLLRATIO_LDR(119);
   147be:	2277      	movs	r2, #119	; 0x77
   147c0:	635a      	str	r2, [r3, #52]	; 0x34
    while((OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLSYNCBUSY & OSCCTRL_DPLLSYNCBUSY_DPLLRATIO_Msk) == OSCCTRL_DPLLSYNCBUSY_DPLLRATIO_Msk)
   147c2:	461a      	mov	r2, r3
   147c4:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   147c6:	f013 0f04 	tst.w	r3, #4
   147ca:	d1fb      	bne.n	147c4 <CLOCK_Initialize+0x38>
    OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLCTRLA = OSCCTRL_DPLLCTRLA_ENABLE_Msk   ;
   147cc:	4b29      	ldr	r3, [pc, #164]	; (14874 <CLOCK_Initialize+0xe8>)
   147ce:	2202      	movs	r2, #2
   147d0:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    while((OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLSYNCBUSY & OSCCTRL_DPLLSYNCBUSY_ENABLE_Msk) == OSCCTRL_DPLLSYNCBUSY_ENABLE_Msk )
   147d4:	461a      	mov	r2, r3
   147d6:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   147d8:	f013 0f02 	tst.w	r3, #2
   147dc:	d1fb      	bne.n	147d6 <CLOCK_Initialize+0x4a>
    while((OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLSTATUS & (OSCCTRL_DPLLSTATUS_LOCK_Msk | OSCCTRL_DPLLSTATUS_CLKRDY_Msk)) !=
   147de:	4a25      	ldr	r2, [pc, #148]	; (14874 <CLOCK_Initialize+0xe8>)
   147e0:	6c13      	ldr	r3, [r2, #64]	; 0x40
   147e2:	f003 0303 	and.w	r3, r3, #3
   147e6:	2b03      	cmp	r3, #3
   147e8:	d1fa      	bne.n	147e0 <CLOCK_Initialize+0x54>
    MCLK_REGS->MCLK_CPUDIV = MCLK_CPUDIV_DIV(0x01);
   147ea:	4b23      	ldr	r3, [pc, #140]	; (14878 <CLOCK_Initialize+0xec>)
   147ec:	2201      	movs	r2, #1
   147ee:	715a      	strb	r2, [r3, #5]
    while((MCLK_REGS->MCLK_INTFLAG & MCLK_INTFLAG_CKRDY_Msk) != MCLK_INTFLAG_CKRDY_Msk)
   147f0:	461a      	mov	r2, r3
   147f2:	78d3      	ldrb	r3, [r2, #3]
   147f4:	f013 0f01 	tst.w	r3, #1
   147f8:	d0fb      	beq.n	147f2 <CLOCK_Initialize+0x66>
    GCLK_REGS->GCLK_GENCTRL[0] = GCLK_GENCTRL_DIV(1) | GCLK_GENCTRL_SRC(7) | GCLK_GENCTRL_GENEN_Msk;
   147fa:	4b1d      	ldr	r3, [pc, #116]	; (14870 <CLOCK_Initialize+0xe4>)
   147fc:	4a1f      	ldr	r2, [pc, #124]	; (1487c <CLOCK_Initialize+0xf0>)
   147fe:	621a      	str	r2, [r3, #32]
    while((GCLK_REGS->GCLK_SYNCBUSY & GCLK_SYNCBUSY_GENCTRL_GCLK0) == GCLK_SYNCBUSY_GENCTRL_GCLK0)
   14800:	461a      	mov	r2, r3
   14802:	6853      	ldr	r3, [r2, #4]
   14804:	f013 0f04 	tst.w	r3, #4
   14808:	d1fb      	bne.n	14802 <CLOCK_Initialize+0x76>
    GCLK_REGS->GCLK_GENCTRL[1] = GCLK_GENCTRL_DIV(2) | GCLK_GENCTRL_SRC(7) | GCLK_GENCTRL_GENEN_Msk;
   1480a:	4b19      	ldr	r3, [pc, #100]	; (14870 <CLOCK_Initialize+0xe4>)
   1480c:	4a1c      	ldr	r2, [pc, #112]	; (14880 <CLOCK_Initialize+0xf4>)
   1480e:	625a      	str	r2, [r3, #36]	; 0x24
    while((GCLK_REGS->GCLK_SYNCBUSY & GCLK_SYNCBUSY_GENCTRL_GCLK1) == GCLK_SYNCBUSY_GENCTRL_GCLK1)
   14810:	461a      	mov	r2, r3
   14812:	6853      	ldr	r3, [r2, #4]
   14814:	f013 0f08 	tst.w	r3, #8
   14818:	d1fb      	bne.n	14812 <CLOCK_Initialize+0x86>
    GCLK1_Initialize();



    /* Selection of the Generator and write Lock for SERCOM0_CORE */
    GCLK_REGS->GCLK_PCHCTRL[7] = GCLK_PCHCTRL_GEN(0x1)  | GCLK_PCHCTRL_CHEN_Msk;
   1481a:	4b15      	ldr	r3, [pc, #84]	; (14870 <CLOCK_Initialize+0xe4>)
   1481c:	2241      	movs	r2, #65	; 0x41
   1481e:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c

    while ((GCLK_REGS->GCLK_PCHCTRL[7] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
   14822:	461a      	mov	r2, r3
   14824:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
   14828:	f013 0f40 	tst.w	r3, #64	; 0x40
   1482c:	d0fa      	beq.n	14824 <CLOCK_Initialize+0x98>
    {
        /* Wait for synchronization */
    }
    /* Selection of the Generator and write Lock for SERCOM1_CORE */
    GCLK_REGS->GCLK_PCHCTRL[8] = GCLK_PCHCTRL_GEN(0x1)  | GCLK_PCHCTRL_CHEN_Msk;
   1482e:	4b10      	ldr	r3, [pc, #64]	; (14870 <CLOCK_Initialize+0xe4>)
   14830:	2241      	movs	r2, #65	; 0x41
   14832:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

    while ((GCLK_REGS->GCLK_PCHCTRL[8] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
   14836:	461a      	mov	r2, r3
   14838:	f8d2 30a0 	ldr.w	r3, [r2, #160]	; 0xa0
   1483c:	f013 0f40 	tst.w	r3, #64	; 0x40
   14840:	d0fa      	beq.n	14838 <CLOCK_Initialize+0xac>
    {
        /* Wait for synchronization */
    }
    /* Selection of the Generator and write Lock for TC0 TC1 */
    GCLK_REGS->GCLK_PCHCTRL[9] = GCLK_PCHCTRL_GEN(0x1)  | GCLK_PCHCTRL_CHEN_Msk;
   14842:	4b0b      	ldr	r3, [pc, #44]	; (14870 <CLOCK_Initialize+0xe4>)
   14844:	2241      	movs	r2, #65	; 0x41
   14846:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4

    while ((GCLK_REGS->GCLK_PCHCTRL[9] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
   1484a:	461a      	mov	r2, r3
   1484c:	f8d2 30a4 	ldr.w	r3, [r2, #164]	; 0xa4
   14850:	f013 0f40 	tst.w	r3, #64	; 0x40
   14854:	d0fa      	beq.n	1484c <CLOCK_Initialize+0xc0>
    {
        /* Wait for synchronization */
    }

    /* Configure the AHB Bridge Clocks */
    MCLK_REGS->MCLK_AHBMASK = 0xffffff;
   14856:	4b08      	ldr	r3, [pc, #32]	; (14878 <CLOCK_Initialize+0xec>)
   14858:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
   1485c:	611a      	str	r2, [r3, #16]

    /* Configure the APBA Bridge Clocks */
    MCLK_REGS->MCLK_APBAMASK = 0x77ff;
   1485e:	f247 72ff 	movw	r2, #30719	; 0x77ff
   14862:	615a      	str	r2, [r3, #20]


}
   14864:	4770      	bx	lr
   14866:	bf00      	nop
   14868:	40001400 	.word	0x40001400
   1486c:	00300106 	.word	0x00300106
   14870:	40001c00 	.word	0x40001c00
   14874:	40001000 	.word	0x40001000
   14878:	40000800 	.word	0x40000800
   1487c:	00010107 	.word	0x00010107
   14880:	00020107 	.word	0x00020107

Disassembly of section .text.TCPIP_TCP_Deinitialize%296:

00014884 <TCPIP_TCP_Deinitialize>:
{
   14884:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14888:	4606      	mov	r6, r0
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);  // System Lock
   1488a:	2000      	movs	r0, #0
   1488c:	f00c fe96 	bl	215bc <OSAL_CRIT_Enter>
    if(tcpLockCount == 1)
   14890:	4b33      	ldr	r3, [pc, #204]	; (14960 <TCPIP_TCP_Deinitialize+0xdc>)
   14892:	681b      	ldr	r3, [r3, #0]
   14894:	2b01      	cmp	r3, #1
   14896:	d005      	beq.n	148a4 <TCPIP_TCP_Deinitialize+0x20>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);  // System unlock
   14898:	4601      	mov	r1, r0
   1489a:	2000      	movs	r0, #0
   1489c:	f00c ffbd 	bl	2181a <OSAL_CRIT_Leave>
}
   148a0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(tcpInitCount <= 0)
   148a4:	4b2f      	ldr	r3, [pc, #188]	; (14964 <TCPIP_TCP_Deinitialize+0xe0>)
   148a6:	681b      	ldr	r3, [r3, #0]
   148a8:	2b00      	cmp	r3, #0
   148aa:	dd54      	ble.n	14956 <TCPIP_TCP_Deinitialize+0xd2>
            tcpLockCount = 2;   // get lock
   148ac:	4b2c      	ldr	r3, [pc, #176]	; (14960 <TCPIP_TCP_Deinitialize+0xdc>)
   148ae:	2202      	movs	r2, #2
   148b0:	601a      	str	r2, [r3, #0]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);  // System unlock
   148b2:	4601      	mov	r1, r0
   148b4:	2000      	movs	r0, #0
   148b6:	f00c ffb0 	bl	2181a <OSAL_CRIT_Leave>
        _TCPAbortSockets(1 << stackInit->netIx, TCPIP_TCP_SIGNAL_IF_DOWN); 
   148ba:	69b3      	ldr	r3, [r6, #24]
   148bc:	f04f 0901 	mov.w	r9, #1
   148c0:	fa09 f903 	lsl.w	r9, r9, r3
    for(ix = 0; ix < TcpSockets; ix++)
   148c4:	4b28      	ldr	r3, [pc, #160]	; (14968 <TCPIP_TCP_Deinitialize+0xe4>)
   148c6:	681b      	ldr	r3, [r3, #0]
   148c8:	b37b      	cbz	r3, 1492a <TCPIP_TCP_Deinitialize+0xa6>
   148ca:	2400      	movs	r4, #0
        if((pSkt = TCBStubs[ix]) != 0)  
   148cc:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 14970 <TCPIP_TCP_Deinitialize+0xec>
                uint32_t sktIfMask = 1 << netIx;
   148d0:	f04f 0a01 	mov.w	sl, #1
    for(ix = 0; ix < TcpSockets; ix++)
   148d4:	4f24      	ldr	r7, [pc, #144]	; (14968 <TCPIP_TCP_Deinitialize+0xe4>)
   148d6:	e017      	b.n	14908 <TCPIP_TCP_Deinitialize+0x84>
                    bool isServer = pSkt->Flags.bServer;
   148d8:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
   148dc:	f003 0b01 	and.w	fp, r3, #1
                    pSkt->Flags.bServer = 1;
   148e0:	f043 0301 	orr.w	r3, r3, #1
   148e4:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
                    _TcpAbort(pSkt, _TCP_ABORT_FLAG_REGULAR, sigType);
   148e8:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   148ec:	2100      	movs	r1, #0
   148ee:	4628      	mov	r0, r5
   148f0:	f007 fd90 	bl	1c414 <_TcpAbort>
                    pSkt->Flags.bServer = isServer;
   148f4:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
   148f8:	f36b 0300 	bfi	r3, fp, #0, #1
   148fc:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
    for(ix = 0; ix < TcpSockets; ix++)
   14900:	3401      	adds	r4, #1
   14902:	683b      	ldr	r3, [r7, #0]
   14904:	42a3      	cmp	r3, r4
   14906:	d910      	bls.n	1492a <TCPIP_TCP_Deinitialize+0xa6>
        if((pSkt = TCBStubs[ix]) != 0)  
   14908:	f8d8 3000 	ldr.w	r3, [r8]
   1490c:	f853 5024 	ldr.w	r5, [r3, r4, lsl #2]
   14910:	2d00      	cmp	r5, #0
   14912:	d0f5      	beq.n	14900 <TCPIP_TCP_Deinitialize+0x7c>
            int netIx = TCPIP_STACK_NetIxGet(pSkt->pSktNet);
   14914:	6c28      	ldr	r0, [r5, #64]	; 0x40
   14916:	f00d fa05 	bl	21d24 <TCPIP_STACK_NetIxGet>
            if(netIx >= 0 )
   1491a:	2800      	cmp	r0, #0
   1491c:	dbf0      	blt.n	14900 <TCPIP_TCP_Deinitialize+0x7c>
                uint32_t sktIfMask = 1 << netIx;
   1491e:	fa0a f000 	lsl.w	r0, sl, r0
                if((sktIfMask & netMask) != 0)
   14922:	ea10 0f09 	tst.w	r0, r9
   14926:	d0eb      	beq.n	14900 <TCPIP_TCP_Deinitialize+0x7c>
   14928:	e7d6      	b.n	148d8 <TCPIP_TCP_Deinitialize+0x54>
        if(stackInit->stackAction == TCPIP_STACK_ACTION_DEINIT && --tcpInitCount == 0)
   1492a:	7f33      	ldrb	r3, [r6, #28]
   1492c:	2b02      	cmp	r3, #2
   1492e:	d003      	beq.n	14938 <TCPIP_TCP_Deinitialize+0xb4>
            tcpLockCount = 1;   // release lock
   14930:	4b0b      	ldr	r3, [pc, #44]	; (14960 <TCPIP_TCP_Deinitialize+0xdc>)
   14932:	2201      	movs	r2, #1
   14934:	601a      	str	r2, [r3, #0]
}
   14936:	e7b3      	b.n	148a0 <TCPIP_TCP_Deinitialize+0x1c>
        if(stackInit->stackAction == TCPIP_STACK_ACTION_DEINIT && --tcpInitCount == 0)
   14938:	4a0a      	ldr	r2, [pc, #40]	; (14964 <TCPIP_TCP_Deinitialize+0xe0>)
   1493a:	6813      	ldr	r3, [r2, #0]
   1493c:	3b01      	subs	r3, #1
   1493e:	6013      	str	r3, [r2, #0]
   14940:	2b00      	cmp	r3, #0
   14942:	d1f5      	bne.n	14930 <TCPIP_TCP_Deinitialize+0xac>
            _TcpCleanup();
   14944:	f005 ff9c 	bl	1a880 <_TcpCleanup>
            OSAL_SEM_Delete(&tcpSemaphore);
   14948:	4808      	ldr	r0, [pc, #32]	; (1496c <TCPIP_TCP_Deinitialize+0xe8>)
   1494a:	f00d f89f 	bl	21a8c <OSAL_SEM_Delete>
            tcpLockCount = 0;   // leave it uninitialized
   1494e:	4b04      	ldr	r3, [pc, #16]	; (14960 <TCPIP_TCP_Deinitialize+0xdc>)
   14950:	2200      	movs	r2, #0
   14952:	601a      	str	r2, [r3, #0]
   14954:	e7a4      	b.n	148a0 <TCPIP_TCP_Deinitialize+0x1c>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);  // System unlock
   14956:	4601      	mov	r1, r0
   14958:	2000      	movs	r0, #0
   1495a:	f00c ff5e 	bl	2181a <OSAL_CRIT_Leave>
    if(deinitFault)
   1495e:	e79f      	b.n	148a0 <TCPIP_TCP_Deinitialize+0x1c>
   14960:	2000e39c 	.word	0x2000e39c
   14964:	2000e398 	.word	0x2000e398
   14968:	2000e390 	.word	0x2000e390
   1496c:	2000e3a0 	.word	0x2000e3a0
   14970:	2000e38c 	.word	0x2000e38c

Disassembly of section .text.TCPIP_ARP_EntryRemoveNet%297:

00014974 <TCPIP_ARP_EntryRemoveNet>:
    TCPIP_NET_IF    *pIf;
    int             index;
    uint16_t        andFlags, resFlags;
    uint32_t        matchAdd;

    if(ipAdd == 0 || ipAdd->Val == 0)
   14974:	2900      	cmp	r1, #0
   14976:	d064      	beq.n	14a42 <TCPIP_ARP_EntryRemoveNet+0xce>
{
   14978:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1497c:	b083      	sub	sp, #12
   1497e:	460c      	mov	r4, r1
    if(ipAdd == 0 || ipAdd->Val == 0)
   14980:	6809      	ldr	r1, [r1, #0]
   14982:	2900      	cmp	r1, #0
   14984:	d060      	beq.n	14a48 <TCPIP_ARP_EntryRemoveNet+0xd4>
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   14986:	2800      	cmp	r0, #0
   14988:	d061      	beq.n	14a4e <TCPIP_ARP_EntryRemoveNet+0xda>
   1498a:	f890 1042 	ldrb.w	r1, [r0, #66]	; 0x42
   1498e:	f011 0f40 	tst.w	r1, #64	; 0x40
   14992:	d104      	bne.n	1499e <TCPIP_ARP_EntryRemoveNet+0x2a>
    }

    pIf = _TCPIPStackHandleToNetUp(hNet);
    if(!pIf)
    {
        return ARP_RES_NO_INTERFACE;
   14994:	f06f 0005 	mvn.w	r0, #5
            }
        }
    }

    return ARP_RES_OK;
}
   14998:	b003      	add	sp, #12
   1499a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    switch (type)
   1499e:	3b01      	subs	r3, #1
   149a0:	2b03      	cmp	r3, #3
   149a2:	d857      	bhi.n	14a54 <TCPIP_ARP_EntryRemoveNet+0xe0>
   149a4:	e8df f003 	tbb	[pc, r3]
   149a8:	0b06020f 	.word	0x0b06020f
            andFlags = resFlags =  ARP_FLAG_ENTRY_COMPLETE;
   149ac:	f04f 0980 	mov.w	r9, #128	; 0x80
   149b0:	46ca      	mov	sl, r9
   149b2:	e00b      	b.n	149cc <TCPIP_ARP_EntryRemoveNet+0x58>
            resFlags = 0;
   149b4:	f04f 0900 	mov.w	r9, #0
            andFlags = (ARP_FLAG_ENTRY_PERM | ARP_FLAG_ENTRY_COMPLETE);
   149b8:	f04f 0ac0 	mov.w	sl, #192	; 0xc0
            break;
   149bc:	e006      	b.n	149cc <TCPIP_ARP_EntryRemoveNet+0x58>
            andFlags = resFlags = 0;
   149be:	f04f 0900 	mov.w	r9, #0
   149c2:	46ca      	mov	sl, r9
            break;
   149c4:	e002      	b.n	149cc <TCPIP_ARP_EntryRemoveNet+0x58>
            andFlags = resFlags = ARP_FLAG_ENTRY_PERM;
   149c6:	f04f 0940 	mov.w	r9, #64	; 0x40
   149ca:	46ca      	mov	sl, r9
   149cc:	4617      	mov	r7, r2
   149ce:	9001      	str	r0, [sp, #4]
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   149d0:	4b23      	ldr	r3, [pc, #140]	; (14a60 <TCPIP_ARP_EntryRemoveNet+0xec>)
   149d2:	685d      	ldr	r5, [r3, #4]
   149d4:	f00d f9a6 	bl	21d24 <TCPIP_STACK_NetIxGet>
   149d8:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   149dc:	00c0      	lsls	r0, r0, #3
   149de:	eb05 0800 	add.w	r8, r5, r0
    pOH = pArpDcpt->hashDcpt;
   149e2:	582e      	ldr	r6, [r5, r0]
    matchAdd = ipAdd->Val & mask->Val;
   149e4:	6822      	ldr	r2, [r4, #0]
   149e6:	683b      	ldr	r3, [r7, #0]
   149e8:	ea02 0b03 	and.w	fp, r2, r3
    for(index = 0; index < pOH->hEntries; index++)
   149ec:	68f3      	ldr	r3, [r6, #12]
   149ee:	b3a3      	cbz	r3, 14a5a <TCPIP_ARP_EntryRemoveNet+0xe6>
   149f0:	2400      	movs	r4, #0
   149f2:	e003      	b.n	149fc <TCPIP_ARP_EntryRemoveNet+0x88>
   149f4:	3401      	adds	r4, #1
   149f6:	68f3      	ldr	r3, [r6, #12]
   149f8:	42a3      	cmp	r3, r4
   149fa:	d920      	bls.n	14a3e <TCPIP_ARP_EntryRemoveNet+0xca>
        hE = TCPIP_OAHASH_EntryGet(pArpDcpt->hashDcpt, index);
   149fc:	4621      	mov	r1, r4
   149fe:	f8d8 0000 	ldr.w	r0, [r8]
   14a02:	f00d f83a 	bl	21a7a <TCPIP_OAHASH_EntryGet>
   14a06:	4605      	mov	r5, r0
        if(hE->flags.busy != 0)
   14a08:	7803      	ldrb	r3, [r0, #0]
   14a0a:	f013 0f01 	tst.w	r3, #1
   14a0e:	d0f1      	beq.n	149f4 <TCPIP_ARP_EntryRemoveNet+0x80>
            if((hE->flags.value & andFlags) == resFlags)
   14a10:	8803      	ldrh	r3, [r0, #0]
   14a12:	ea0a 0303 	and.w	r3, sl, r3
   14a16:	454b      	cmp	r3, r9
   14a18:	d1ec      	bne.n	149f4 <TCPIP_ARP_EntryRemoveNet+0x80>
                if((arpHE->ipAddress.Val & mask->Val) == matchAdd)
   14a1a:	6883      	ldr	r3, [r0, #8]
   14a1c:	683a      	ldr	r2, [r7, #0]
   14a1e:	4013      	ands	r3, r2
   14a20:	455b      	cmp	r3, fp
   14a22:	d1e7      	bne.n	149f4 <TCPIP_ARP_EntryRemoveNet+0x80>
                    _ARPRemoveEntry(pArpDcpt, hE);
   14a24:	4601      	mov	r1, r0
   14a26:	4640      	mov	r0, r8
   14a28:	f00a ff4e 	bl	1f8c8 <_ARPRemoveEntry>
                    _ARPNotifyClients(pIf, &arpHE->ipAddress, 0, ARP_EVENT_REMOVED_USER);
   14a2c:	f06f 0301 	mvn.w	r3, #1
   14a30:	2200      	movs	r2, #0
   14a32:	f105 0108 	add.w	r1, r5, #8
   14a36:	9801      	ldr	r0, [sp, #4]
   14a38:	f007 faf4 	bl	1c024 <_ARPNotifyClients>
   14a3c:	e7da      	b.n	149f4 <TCPIP_ARP_EntryRemoveNet+0x80>
    return ARP_RES_OK;
   14a3e:	2000      	movs	r0, #0
   14a40:	e7aa      	b.n	14998 <TCPIP_ARP_EntryRemoveNet+0x24>
        return ARP_RES_BAD_ADDRESS;
   14a42:	f06f 0004 	mvn.w	r0, #4
}
   14a46:	4770      	bx	lr
        return ARP_RES_BAD_ADDRESS;
   14a48:	f06f 0004 	mvn.w	r0, #4
   14a4c:	e7a4      	b.n	14998 <TCPIP_ARP_EntryRemoveNet+0x24>
        return ARP_RES_NO_INTERFACE;
   14a4e:	f06f 0005 	mvn.w	r0, #5
   14a52:	e7a1      	b.n	14998 <TCPIP_ARP_EntryRemoveNet+0x24>
            return ARP_RES_BAD_TYPE;
   14a54:	f06f 0006 	mvn.w	r0, #6
   14a58:	e79e      	b.n	14998 <TCPIP_ARP_EntryRemoveNet+0x24>
    return ARP_RES_OK;
   14a5a:	2000      	movs	r0, #0
   14a5c:	e79c      	b.n	14998 <TCPIP_ARP_EntryRemoveNet+0x24>
   14a5e:	bf00      	nop
   14a60:	2000dfa4 	.word	0x2000dfa4

Disassembly of section .text._DNS_IsNameResolved%298:

00014a64 <_DNS_IsNameResolved>:
{    
   14a64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14a68:	b084      	sub	sp, #16
    if(hostIPv4)
   14a6a:	460e      	mov	r6, r1
   14a6c:	b109      	cbz	r1, 14a72 <_DNS_IsNameResolved+0xe>
        hostIPv4->Val = 0;
   14a6e:	2100      	movs	r1, #0
   14a70:	6031      	str	r1, [r6, #0]
    if(hostIPv6)
   14a72:	b122      	cbz	r2, 14a7e <_DNS_IsNameResolved+0x1a>
        memset(hostIPv6->v, 0, sizeof(*hostIPv6));
   14a74:	2100      	movs	r1, #0
   14a76:	6011      	str	r1, [r2, #0]
   14a78:	6051      	str	r1, [r2, #4]
   14a7a:	6091      	str	r1, [r2, #8]
   14a7c:	60d1      	str	r1, [r2, #12]
    pDnsDcpt = pgDnsDcpt;
   14a7e:	4934      	ldr	r1, [pc, #208]	; (14b50 <_DNS_IsNameResolved+0xec>)
   14a80:	680f      	ldr	r7, [r1, #0]
    if(pDnsDcpt == 0)
   14a82:	2f00      	cmp	r7, #0
   14a84:	d055      	beq.n	14b32 <_DNS_IsNameResolved+0xce>
   14a86:	4698      	mov	r8, r3
   14a88:	4614      	mov	r4, r2
   14a8a:	4605      	mov	r5, r0
    if(TCPIP_Helper_StringToIPAddress(hostName, &mAddr.v4Add))
   14a8c:	4669      	mov	r1, sp
   14a8e:	f7fe fd17 	bl	134c0 <TCPIP_Helper_StringToIPAddress>
   14a92:	b138      	cbz	r0, 14aa4 <_DNS_IsNameResolved+0x40>
        if(hostIPv4)
   14a94:	2e00      	cmp	r6, #0
   14a96:	d04f      	beq.n	14b38 <_DNS_IsNameResolved+0xd4>
            hostIPv4->Val = mAddr.v4Add.Val;
   14a98:	9b00      	ldr	r3, [sp, #0]
   14a9a:	6033      	str	r3, [r6, #0]
        return  TCPIP_DNS_RES_OK; 
   14a9c:	2000      	movs	r0, #0
}
   14a9e:	b004      	add	sp, #16
   14aa0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (TCPIP_Helper_StringToIPv6Address (hostName, &mAddr.v6Add))
   14aa4:	4669      	mov	r1, sp
   14aa6:	4628      	mov	r0, r5
   14aa8:	f7f6 fcda 	bl	b460 <TCPIP_Helper_StringToIPv6Address>
   14aac:	b148      	cbz	r0, 14ac2 <_DNS_IsNameResolved+0x5e>
        if(hostIPv6)
   14aae:	2c00      	cmp	r4, #0
   14ab0:	d044      	beq.n	14b3c <_DNS_IsNameResolved+0xd8>
            memcpy (hostIPv6->v, mAddr.v6Add.v, sizeof (IPV6_ADDR));
   14ab2:	466d      	mov	r5, sp
   14ab4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   14ab6:	6020      	str	r0, [r4, #0]
   14ab8:	6061      	str	r1, [r4, #4]
   14aba:	60a2      	str	r2, [r4, #8]
   14abc:	60e3      	str	r3, [r4, #12]
        return  TCPIP_DNS_RES_OK; 
   14abe:	2000      	movs	r0, #0
   14ac0:	e7ed      	b.n	14a9e <_DNS_IsNameResolved+0x3a>
    pDnsHE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryLookup(pDnsDcpt->hashDcpt, hostName);
   14ac2:	4629      	mov	r1, r5
   14ac4:	6838      	ldr	r0, [r7, #0]
   14ac6:	f006 f95d 	bl	1ad84 <TCPIP_OAHASH_EntryLookup>
    if(pDnsHE == 0)
   14aca:	4603      	mov	r3, r0
   14acc:	2800      	cmp	r0, #0
   14ace:	d037      	beq.n	14b40 <_DNS_IsNameResolved+0xdc>
    if((pDnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) == 0)
   14ad0:	8802      	ldrh	r2, [r0, #0]
   14ad2:	f012 0f80 	tst.w	r2, #128	; 0x80
   14ad6:	d00e      	beq.n	14af6 <_DNS_IsNameResolved+0x92>
    nIPv6Entries = pDnsHE->nIPv6Entries;
   14ad8:	f890 2027 	ldrb.w	r2, [r0, #39]	; 0x27
    nIPv4Entries = pDnsHE->nIPv4Entries;
   14adc:	f890 1026 	ldrb.w	r1, [r0, #38]	; 0x26
    if(nIPv6Entries || nIPv4Entries)
   14ae0:	b98a      	cbnz	r2, 14b06 <_DNS_IsNameResolved+0xa2>
    return TCPIP_DNS_RES_NO_IP_ENTRY;
   14ae2:	f06f 0001 	mvn.w	r0, #1
    if(nIPv6Entries || nIPv4Entries)
   14ae6:	2900      	cmp	r1, #0
   14ae8:	d0d9      	beq.n	14a9e <_DNS_IsNameResolved+0x3a>
            if(hostIPv4)
   14aea:	b376      	cbz	r6, 14b4a <_DNS_IsNameResolved+0xe6>
                hostIPv4->Val = (pDnsHE->pip4Address + 0)->Val;
   14aec:	691b      	ldr	r3, [r3, #16]
   14aee:	681b      	ldr	r3, [r3, #0]
   14af0:	6033      	str	r3, [r6, #0]
        return TCPIP_DNS_RES_OK;
   14af2:	2000      	movs	r0, #0
   14af4:	e7d3      	b.n	14a9e <_DNS_IsNameResolved+0x3a>
        return (pDnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_TIMEOUT) == 0 ? TCPIP_DNS_RES_PENDING : TCPIP_DNS_RES_SERVER_TMO; 
   14af6:	f402 7280 	and.w	r2, r2, #256	; 0x100
   14afa:	2a00      	cmp	r2, #0
   14afc:	bf0c      	ite	eq
   14afe:	2001      	moveq	r0, #1
   14b00:	f06f 0004 	mvnne.w	r0, #4
   14b04:	e7cb      	b.n	14a9e <_DNS_IsNameResolved+0x3a>
            if(hostIPv6)
   14b06:	b184      	cbz	r4, 14b2a <_DNS_IsNameResolved+0xc6>
                memcpy (hostIPv6->v, pDnsHE->pip6Address + nIPv6Entries - 1, sizeof (IPV6_ADDR));
   14b08:	f102 5280 	add.w	r2, r2, #268435456	; 0x10000000
   14b0c:	3a01      	subs	r2, #1
   14b0e:	6940      	ldr	r0, [r0, #20]
   14b10:	eb00 1202 	add.w	r2, r0, r2, lsl #4
   14b14:	6817      	ldr	r7, [r2, #0]
   14b16:	6855      	ldr	r5, [r2, #4]
   14b18:	6890      	ldr	r0, [r2, #8]
   14b1a:	68d2      	ldr	r2, [r2, #12]
   14b1c:	6027      	str	r7, [r4, #0]
   14b1e:	6065      	str	r5, [r4, #4]
   14b20:	60a0      	str	r0, [r4, #8]
   14b22:	60e2      	str	r2, [r4, #12]
                if(singleAddress)
   14b24:	f1b8 0f00 	cmp.w	r8, #0
   14b28:	d10d      	bne.n	14b46 <_DNS_IsNameResolved+0xe2>
        return TCPIP_DNS_RES_OK;
   14b2a:	2000      	movs	r0, #0
        if(nIPv4Entries)
   14b2c:	2900      	cmp	r1, #0
   14b2e:	d0b6      	beq.n	14a9e <_DNS_IsNameResolved+0x3a>
   14b30:	e7db      	b.n	14aea <_DNS_IsNameResolved+0x86>
        return TCPIP_DNS_RES_NO_SERVICE;
   14b32:	f06f 0005 	mvn.w	r0, #5
   14b36:	e7b2      	b.n	14a9e <_DNS_IsNameResolved+0x3a>
        return  TCPIP_DNS_RES_OK; 
   14b38:	2000      	movs	r0, #0
   14b3a:	e7b0      	b.n	14a9e <_DNS_IsNameResolved+0x3a>
        return  TCPIP_DNS_RES_OK; 
   14b3c:	2000      	movs	r0, #0
   14b3e:	e7ae      	b.n	14a9e <_DNS_IsNameResolved+0x3a>
        return TCPIP_DNS_RES_NO_NAME_ENTRY;
   14b40:	f04f 30ff 	mov.w	r0, #4294967295
   14b44:	e7ab      	b.n	14a9e <_DNS_IsNameResolved+0x3a>
        return TCPIP_DNS_RES_OK;
   14b46:	2000      	movs	r0, #0
   14b48:	e7a9      	b.n	14a9e <_DNS_IsNameResolved+0x3a>
   14b4a:	2000      	movs	r0, #0
   14b4c:	e7a7      	b.n	14a9e <_DNS_IsNameResolved+0x3a>
   14b4e:	bf00      	nop
   14b50:	2000e424 	.word	0x2000e424

Disassembly of section .text.TCPIP_DNS_ClientTask%299:

00014b54 <TCPIP_DNS_ClientTask>:
{
   14b54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
   14b56:	210f      	movs	r1, #15
   14b58:	4608      	mov	r0, r1
   14b5a:	f009 fb37 	bl	1e1cc <_TCPIPStackModuleSignalGet>
    if(sigPend != 0)
   14b5e:	b900      	cbnz	r0, 14b62 <TCPIP_DNS_ClientTask+0xe>
}
   14b60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        TCPIP_DNS_ClientProcess((sigPend & TCPIP_MODULE_SIGNAL_TMO) != 0);
   14b62:	f000 0302 	and.w	r3, r0, #2
    if((pDnsDcpt = pgDnsDcpt) == 0)
   14b66:	4a36      	ldr	r2, [pc, #216]	; (14c40 <TCPIP_DNS_ClientTask+0xec>)
   14b68:	6814      	ldr	r4, [r2, #0]
   14b6a:	2c00      	cmp	r4, #0
   14b6c:	d0f8      	beq.n	14b60 <TCPIP_DNS_ClientTask+0xc>
    if(isTmo)
   14b6e:	2b00      	cmp	r3, #0
   14b70:	d05a      	beq.n	14c28 <TCPIP_DNS_ClientTask+0xd4>
        pDnsDcpt->dnsTime = SYS_TMR_TickCountGetLong() / SYS_TMR_TickCounterFrequencyGet();
   14b72:	f00b facf 	bl	20114 <SYS_TMR_TickCountGetLong>
   14b76:	4606      	mov	r6, r0
   14b78:	460f      	mov	r7, r1
   14b7a:	f00b fadf 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
   14b7e:	4602      	mov	r2, r0
   14b80:	2300      	movs	r3, #0
   14b82:	4630      	mov	r0, r6
   14b84:	4639      	mov	r1, r7
   14b86:	f00a fcbf 	bl	1f508 <__aeabi_uldivmod>
   14b8a:	4607      	mov	r7, r0
   14b8c:	61e0      	str	r0, [r4, #28]
    pOH = pDnsDcpt->hashDcpt;
   14b8e:	6826      	ldr	r6, [r4, #0]
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   14b90:	68f3      	ldr	r3, [r6, #12]
   14b92:	2b00      	cmp	r3, #0
   14b94:	d048      	beq.n	14c28 <TCPIP_DNS_ClientTask+0xd4>
   14b96:	2500      	movs	r5, #0
   14b98:	e008      	b.n	14bac <TCPIP_DNS_ClientTask+0x58>
                    timeout = pDnsHE->ipTTL.Val;
   14b9a:	6982      	ldr	r2, [r0, #24]
                if((currTime - pDnsHE->tInsert) >= timeout)
   14b9c:	6883      	ldr	r3, [r0, #8]
   14b9e:	1afb      	subs	r3, r7, r3
   14ba0:	4293      	cmp	r3, r2
   14ba2:	d213      	bcs.n	14bcc <TCPIP_DNS_ClientTask+0x78>
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   14ba4:	3501      	adds	r5, #1
   14ba6:	68f3      	ldr	r3, [r6, #12]
   14ba8:	42ab      	cmp	r3, r5
   14baa:	d93d      	bls.n	14c28 <TCPIP_DNS_ClientTask+0xd4>
        pDnsHE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryGet(pOH, bktIx);
   14bac:	4629      	mov	r1, r5
   14bae:	4630      	mov	r0, r6
   14bb0:	f00c ff63 	bl	21a7a <TCPIP_OAHASH_EntryGet>
        if(pDnsHE->hEntry.flags.busy != 0)
   14bb4:	7803      	ldrb	r3, [r0, #0]
   14bb6:	f013 0f01 	tst.w	r3, #1
   14bba:	d0f3      	beq.n	14ba4 <TCPIP_DNS_ClientTask+0x50>
            if((pDnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) != 0)
   14bbc:	8803      	ldrh	r3, [r0, #0]
   14bbe:	f013 0f80 	tst.w	r3, #128	; 0x80
   14bc2:	d008      	beq.n	14bd6 <TCPIP_DNS_ClientTask+0x82>
                if((timeout = pDnsDcpt->cacheEntryTMO) == 0)
   14bc4:	6962      	ldr	r2, [r4, #20]
   14bc6:	2a00      	cmp	r2, #0
   14bc8:	d1e8      	bne.n	14b9c <TCPIP_DNS_ClientTask+0x48>
   14bca:	e7e6      	b.n	14b9a <TCPIP_DNS_ClientTask+0x46>
    _DNS_CleanCacheEntry(pDnsDcpt, pDnsHE);
   14bcc:	4601      	mov	r1, r0
   14bce:	4620      	mov	r0, r4
   14bd0:	f00a fd81 	bl	1f6d6 <_DNS_CleanCacheEntry>
   14bd4:	e7e6      	b.n	14ba4 <TCPIP_DNS_ClientTask+0x50>
                if((pDnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_TIMEOUT) == 0)
   14bd6:	f413 7f80 	tst.w	r3, #256	; 0x100
   14bda:	d116      	bne.n	14c0a <TCPIP_DNS_ClientTask+0xb6>
                    if((currTime - pDnsHE->tRetry) >= TCPIP_DNS_CLIENT_LOOKUP_RETRY_TMO)
   14bdc:	68c2      	ldr	r2, [r0, #12]
   14bde:	1aba      	subs	r2, r7, r2
   14be0:	2a01      	cmp	r2, #1
   14be2:	d9df      	bls.n	14ba4 <TCPIP_DNS_ClientTask+0x50>
                        pDnsHE->tRetry = currTime;
   14be4:	60c7      	str	r7, [r0, #12]
                        if(pDnsHE->currRetry < pDnsHE->nRetries)
   14be6:	f890 202b 	ldrb.w	r2, [r0, #43]	; 0x2b
   14bea:	f890 102c 	ldrb.w	r1, [r0, #44]	; 0x2c
   14bee:	4291      	cmp	r1, r2
   14bf0:	d803      	bhi.n	14bfa <TCPIP_DNS_ClientTask+0xa6>
                            pDnsHE->hEntry.flags.value |= TCPIP_DNS_FLAG_ENTRY_TIMEOUT;
   14bf2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   14bf6:	8003      	strh	r3, [r0, #0]
   14bf8:	e7d4      	b.n	14ba4 <TCPIP_DNS_ClientTask+0x50>
                            pDnsHE->currRetry++;
   14bfa:	3201      	adds	r2, #1
   14bfc:	f880 202b 	strb.w	r2, [r0, #43]	; 0x2b
                            _DNS_Send_Query(pDnsDcpt, pDnsHE);
   14c00:	4601      	mov	r1, r0
   14c02:	4620      	mov	r0, r4
   14c04:	f7f7 fff0 	bl	cbe8 <_DNS_Send_Query>
   14c08:	e7cc      	b.n	14ba4 <TCPIP_DNS_ClientTask+0x50>
                    if((currTime - pDnsHE->tRetry) >= _TCPIP_DNS_CLIENT_CACHE_UNSOLVED_EXPIRE_TMO)
   14c0a:	68c3      	ldr	r3, [r0, #12]
   14c0c:	429f      	cmp	r7, r3
   14c0e:	d0c9      	beq.n	14ba4 <TCPIP_DNS_ClientTask+0x50>
    _DNS_CleanCacheEntry(pDnsDcpt, pDnsHE);
   14c10:	4601      	mov	r1, r0
   14c12:	4620      	mov	r0, r4
   14c14:	f00a fd5f 	bl	1f6d6 <_DNS_CleanCacheEntry>
   14c18:	e7c4      	b.n	14ba4 <TCPIP_DNS_ClientTask+0x50>
            _DNS_ProcessPacket(pDnsDcpt);
   14c1a:	4620      	mov	r0, r4
   14c1c:	f7f5 fada 	bl	a1d4 <_DNS_ProcessPacket>
        TCPIP_UDP_Discard(pDnsDcpt->dnsSocket);
   14c20:	f9b4 0024 	ldrsh.w	r0, [r4, #36]	; 0x24
   14c24:	f00b fdf1 	bl	2080a <TCPIP_UDP_Discard>
        if(!TCPIP_UDP_GetIsReady(pDnsDcpt->dnsSocket))
   14c28:	f9b4 0024 	ldrsh.w	r0, [r4, #36]	; 0x24
   14c2c:	f00b fa22 	bl	20074 <TCPIP_UDP_GetIsReady>
   14c30:	2800      	cmp	r0, #0
   14c32:	d095      	beq.n	14b60 <TCPIP_DNS_ClientTask+0xc>
        if(pDnsDcpt->unsolvedEntries != 0)
   14c34:	f9b4 3026 	ldrsh.w	r3, [r4, #38]	; 0x26
   14c38:	2b00      	cmp	r3, #0
   14c3a:	d0f1      	beq.n	14c20 <TCPIP_DNS_ClientTask+0xcc>
   14c3c:	e7ed      	b.n	14c1a <TCPIP_DNS_ClientTask+0xc6>
   14c3e:	bf00      	nop
   14c40:	2000e424 	.word	0x2000e424

Disassembly of section .text._ARPProbeAddress%300:

00014c44 <_ARPProbeAddress>:
{
   14c44:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   14c48:	b083      	sub	sp, #12
   14c4a:	461c      	mov	r4, r3
    if((opType & ARP_OPERATION_PROBE_ONLY) != 0)
   14c4c:	f413 4f80 	tst.w	r3, #16384	; 0x4000
   14c50:	d11c      	bne.n	14c8c <_ARPProbeAddress+0x48>
   14c52:	4606      	mov	r6, r0
   14c54:	460d      	mov	r5, r1
   14c56:	4690      	mov	r8, r2
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   14c58:	4b33      	ldr	r3, [pc, #204]	; (14d28 <_ARPProbeAddress+0xe4>)
   14c5a:	685f      	ldr	r7, [r3, #4]
   14c5c:	f00d f862 	bl	21d24 <TCPIP_STACK_NetIxGet>
   14c60:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   14c64:	00c0      	lsls	r0, r0, #3
   14c66:	eb07 0900 	add.w	r9, r7, r0
    hE = TCPIP_OAHASH_EntryLookupOrInsert(pArpDcpt->hashDcpt, &IPAddr->Val);
   14c6a:	4629      	mov	r1, r5
   14c6c:	5838      	ldr	r0, [r7, r0]
   14c6e:	f006 fabd 	bl	1b1ec <TCPIP_OAHASH_EntryLookupOrInsert>
    if(hE == 0)
   14c72:	4605      	mov	r5, r0
   14c74:	2800      	cmp	r0, #0
   14c76:	d053      	beq.n	14d20 <_ARPProbeAddress+0xdc>
    if(hE->flags.newEntry != 0)
   14c78:	7803      	ldrb	r3, [r0, #0]
   14c7a:	f013 0f02 	tst.w	r3, #2
   14c7e:	d117      	bne.n	14cb0 <_ARPProbeAddress+0x6c>
    if((hE->flags.value & ARP_FLAG_ENTRY_VALID_MASK) != 0)
   14c80:	8803      	ldrh	r3, [r0, #0]
   14c82:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   14c86:	bb73      	cbnz	r3, 14ce6 <_ARPProbeAddress+0xa2>
    return ARP_RES_ENTRY_QUEUED;
   14c88:	2003      	movs	r0, #3
   14c8a:	e00e      	b.n	14caa <_ARPProbeAddress+0x66>
        return _ARPSendIfPkt(pIf, (opType & ARP_OPERATION_MASK), (uint32_t)srcAddr->Val, (uint32_t)IPAddr->Val, &arpBcastAdd, 0) ? ARP_RES_PROBE_OK : ARP_RES_PROBE_FAILED;
   14c8c:	2300      	movs	r3, #0
   14c8e:	9301      	str	r3, [sp, #4]
   14c90:	4b26      	ldr	r3, [pc, #152]	; (14d2c <_ARPProbeAddress+0xe8>)
   14c92:	9300      	str	r3, [sp, #0]
   14c94:	680b      	ldr	r3, [r1, #0]
   14c96:	6812      	ldr	r2, [r2, #0]
   14c98:	f004 010f 	and.w	r1, r4, #15
   14c9c:	f001 ffbc 	bl	16c18 <_ARPSendIfPkt>
   14ca0:	2800      	cmp	r0, #0
   14ca2:	bf14      	ite	ne
   14ca4:	2006      	movne	r0, #6
   14ca6:	f06f 0008 	mvneq.w	r0, #8
}
   14caa:	b003      	add	sp, #12
   14cac:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        ARP_ENTRY_FLAGS newFlags = (opType & ARP_OPERATION_CONFIGURE) != 0 ? ARP_FLAG_ENTRY_CONFIGURE : 0;
   14cb0:	1121      	asrs	r1, r4, #4
   14cb2:	f401 7180 	and.w	r1, r1, #256	; 0x100
        if((opType & ARP_OPERATION_GRATUITOUS) != 0) 
   14cb6:	f414 5f00 	tst.w	r4, #8192	; 0x2000
            newFlags |= ARP_FLAG_ENTRY_GRATUITOUS;
   14cba:	bf18      	it	ne
   14cbc:	f441 7100 	orrne.w	r1, r1, #512	; 0x200
        _ARPSetEntry((ARP_HASH_ENTRY*)hE, newFlags, 0, &pArpDcpt->incompleteList);
   14cc0:	f109 032c 	add.w	r3, r9, #44	; 0x2c
   14cc4:	2200      	movs	r2, #0
   14cc6:	f009 fef7 	bl	1eab8 <_ARPSetEntry>
        _ARPSendIfPkt(pIf, (opType & ARP_OPERATION_MASK), (uint32_t)srcAddr->Val, ((ARP_HASH_ENTRY*)hE)->ipAddress.Val, &arpBcastAdd, 0);
   14cca:	68ab      	ldr	r3, [r5, #8]
   14ccc:	2200      	movs	r2, #0
   14cce:	9201      	str	r2, [sp, #4]
   14cd0:	4a16      	ldr	r2, [pc, #88]	; (14d2c <_ARPProbeAddress+0xe8>)
   14cd2:	9200      	str	r2, [sp, #0]
   14cd4:	f8d8 2000 	ldr.w	r2, [r8]
   14cd8:	f004 010f 	and.w	r1, r4, #15
   14cdc:	4630      	mov	r0, r6
   14cde:	f001 ff9b 	bl	16c18 <_ARPSendIfPkt>
        return ARP_RES_ENTRY_NEW;
   14ce2:	2001      	movs	r0, #1
   14ce4:	e7e1      	b.n	14caa <_ARPProbeAddress+0x66>
        if(pHwAdd)
   14ce6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   14ce8:	b123      	cbz	r3, 14cf4 <_ARPProbeAddress+0xb0>
            *pHwAdd = arpHE->hwAdd;
   14cea:	6900      	ldr	r0, [r0, #16]
   14cec:	6018      	str	r0, [r3, #0]
   14cee:	8aab      	ldrh	r3, [r5, #20]
   14cf0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   14cf2:	8093      	strh	r3, [r2, #4]
        if((hE->flags.value & ARP_FLAG_ENTRY_COMPLETE) != 0 )
   14cf4:	882b      	ldrh	r3, [r5, #0]
   14cf6:	f013 0f80 	tst.w	r3, #128	; 0x80
   14cfa:	d101      	bne.n	14d00 <_ARPProbeAddress+0xbc>
        return ARP_RES_ENTRY_SOLVED;
   14cfc:	2002      	movs	r0, #2
   14cfe:	e7d4      	b.n	14caa <_ARPProbeAddress+0x66>
            _ARPRefreshEntry(arpHE, &pArpDcpt->completeList);
   14d00:	f109 0918 	add.w	r9, r9, #24
    TCPIP_Helper_ProtectedSingleListNodeRemove(pL, (SGL_LIST_NODE*)&arpHE->next);
   14d04:	1d2c      	adds	r4, r5, #4
   14d06:	4621      	mov	r1, r4
   14d08:	4648      	mov	r0, r9
   14d0a:	f00a fac5 	bl	1f298 <TCPIP_Helper_ProtectedSingleListNodeRemove>
    arpHE->tInsert = arpMod.timeSeconds;
   14d0e:	4b06      	ldr	r3, [pc, #24]	; (14d28 <_ARPProbeAddress+0xe4>)
   14d10:	695b      	ldr	r3, [r3, #20]
   14d12:	60eb      	str	r3, [r5, #12]
    TCPIP_Helper_ProtectedSingleListTailAdd(pL, (SGL_LIST_NODE*)&arpHE->next);
   14d14:	4621      	mov	r1, r4
   14d16:	4648      	mov	r0, r9
   14d18:	f00a ffa1 	bl	1fc5e <TCPIP_Helper_ProtectedSingleListTailAdd>
        return ARP_RES_ENTRY_SOLVED;
   14d1c:	2002      	movs	r0, #2
   14d1e:	e7c4      	b.n	14caa <_ARPProbeAddress+0x66>
        return ARP_RES_CACHE_FULL;
   14d20:	f06f 0001 	mvn.w	r0, #1
   14d24:	e7c1      	b.n	14caa <_ARPProbeAddress+0x66>
   14d26:	bf00      	nop
   14d28:	2000dfa4 	.word	0x2000dfa4
   14d2c:	2000e368 	.word	0x2000e368

Disassembly of section .text._DNS_GetAddresses%301:

00014d30 <_DNS_GetAddresses>:
{
   14d30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14d34:	f89d 7018 	ldrb.w	r7, [sp, #24]
    pDnsDcpt = pgDnsDcpt;
   14d38:	4c37      	ldr	r4, [pc, #220]	; (14e18 <_DNS_GetAddresses+0xe8>)
   14d3a:	6825      	ldr	r5, [r4, #0]
    if(pDnsDcpt == 0 || hostName == 0 || pIPAddr == 0 || nIPAddresses == 0)
   14d3c:	2d00      	cmp	r5, #0
   14d3e:	d057      	beq.n	14df0 <_DNS_GetAddresses+0xc0>
   14d40:	2800      	cmp	r0, #0
   14d42:	d057      	beq.n	14df4 <_DNS_GetAddresses+0xc4>
   14d44:	2a00      	cmp	r2, #0
   14d46:	d057      	beq.n	14df8 <_DNS_GetAddresses+0xc8>
   14d48:	b913      	cbnz	r3, 14d50 <_DNS_GetAddresses+0x20>
        return 0;
   14d4a:	4618      	mov	r0, r3
}
   14d4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14d50:	461c      	mov	r4, r3
   14d52:	4690      	mov	r8, r2
   14d54:	460e      	mov	r6, r1
   14d56:	4601      	mov	r1, r0
    dnsHashEntry = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryLookup(pDnsDcpt->hashDcpt, hostName);
   14d58:	6828      	ldr	r0, [r5, #0]
   14d5a:	f006 f813 	bl	1ad84 <TCPIP_OAHASH_EntryLookup>
    if(dnsHashEntry == 0 || (dnsHashEntry->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) == 0)
   14d5e:	4601      	mov	r1, r0
   14d60:	2800      	cmp	r0, #0
   14d62:	d04b      	beq.n	14dfc <_DNS_GetAddresses+0xcc>
   14d64:	8803      	ldrh	r3, [r0, #0]
   14d66:	f013 0f80 	tst.w	r3, #128	; 0x80
   14d6a:	d049      	beq.n	14e00 <_DNS_GetAddresses+0xd0>
    recMask &= (TCPIP_DNS_ADDRESS_REC_MASK)dnsHashEntry->recordMask;
   14d6c:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
    if(recMask == 0)
   14d70:	401f      	ands	r7, r3
   14d72:	d047      	beq.n	14e04 <_DNS_GetAddresses+0xd4>
    if(recMask == TCPIP_DNS_ADDRESS_REC_IPV4)
   14d74:	2f01      	cmp	r7, #1
   14d76:	d020      	beq.n	14dba <_DNS_GetAddresses+0x8a>
        pDst6Addr = &pIPAddr->v6Add;
   14d78:	4642      	mov	r2, r8
        pSrc6Addr =  dnsHashEntry->pip6Address + startIndex;
   14d7a:	46b6      	mov	lr, r6
   14d7c:	6943      	ldr	r3, [r0, #20]
   14d7e:	eb03 1306 	add.w	r3, r3, r6, lsl #4
        for(ix = startIndex; ix <= dnsHashEntry->nIPv6Entries && nAddrs < nIPAddresses; ix++, nAddrs++, pDst6Addr++)
   14d82:	f890 0027 	ldrb.w	r0, [r0, #39]	; 0x27
   14d86:	4286      	cmp	r6, r0
   14d88:	dc42      	bgt.n	14e10 <_DNS_GetAddresses+0xe0>
   14d8a:	2c00      	cmp	r4, #0
   14d8c:	dd42      	ble.n	14e14 <_DNS_GetAddresses+0xe4>
    nAddrs = 0;
   14d8e:	2000      	movs	r0, #0
            memcpy(pDst6Addr->v, pSrc6Addr->v, sizeof(*pDst6Addr));
   14d90:	f8d3 c000 	ldr.w	ip, [r3]
   14d94:	685f      	ldr	r7, [r3, #4]
   14d96:	689e      	ldr	r6, [r3, #8]
   14d98:	68dd      	ldr	r5, [r3, #12]
   14d9a:	f8c2 c000 	str.w	ip, [r2]
   14d9e:	6057      	str	r7, [r2, #4]
   14da0:	6096      	str	r6, [r2, #8]
   14da2:	60d5      	str	r5, [r2, #12]
        for(ix = startIndex; ix <= dnsHashEntry->nIPv6Entries && nAddrs < nIPAddresses; ix++, nAddrs++, pDst6Addr++)
   14da4:	3001      	adds	r0, #1
   14da6:	3210      	adds	r2, #16
   14da8:	f891 6027 	ldrb.w	r6, [r1, #39]	; 0x27
   14dac:	eb00 050e 	add.w	r5, r0, lr
   14db0:	42ae      	cmp	r6, r5
   14db2:	dbcb      	blt.n	14d4c <_DNS_GetAddresses+0x1c>
   14db4:	4284      	cmp	r4, r0
   14db6:	d1eb      	bne.n	14d90 <_DNS_GetAddresses+0x60>
   14db8:	e7c8      	b.n	14d4c <_DNS_GetAddresses+0x1c>
        pSrc4Addr =  dnsHashEntry->pip4Address + startIndex;
   14dba:	6903      	ldr	r3, [r0, #16]
   14dbc:	4637      	mov	r7, r6
   14dbe:	00b2      	lsls	r2, r6, #2
        for(ix = startIndex; ix <= dnsHashEntry->nIPv4Entries && nAddrs < nIPAddresses; ix++, nAddrs++, pDst4Addr++, pSrc4Addr++)
   14dc0:	f890 0026 	ldrb.w	r0, [r0, #38]	; 0x26
   14dc4:	4286      	cmp	r6, r0
   14dc6:	dc1f      	bgt.n	14e08 <_DNS_GetAddresses+0xd8>
   14dc8:	2c00      	cmp	r4, #0
   14dca:	dd1f      	ble.n	14e0c <_DNS_GetAddresses+0xdc>
   14dcc:	3a04      	subs	r2, #4
   14dce:	4413      	add	r3, r2
   14dd0:	f1a8 0204 	sub.w	r2, r8, #4
    nAddrs = 0;
   14dd4:	2000      	movs	r0, #0
            pDst4Addr->Val = pSrc4Addr->Val;
   14dd6:	f853 5f04 	ldr.w	r5, [r3, #4]!
   14dda:	f842 5f04 	str.w	r5, [r2, #4]!
        for(ix = startIndex; ix <= dnsHashEntry->nIPv4Entries && nAddrs < nIPAddresses; ix++, nAddrs++, pDst4Addr++, pSrc4Addr++)
   14dde:	3001      	adds	r0, #1
   14de0:	f891 6026 	ldrb.w	r6, [r1, #38]	; 0x26
   14de4:	19c5      	adds	r5, r0, r7
   14de6:	42ae      	cmp	r6, r5
   14de8:	dbb0      	blt.n	14d4c <_DNS_GetAddresses+0x1c>
   14dea:	4284      	cmp	r4, r0
   14dec:	d1f3      	bne.n	14dd6 <_DNS_GetAddresses+0xa6>
   14dee:	e7ad      	b.n	14d4c <_DNS_GetAddresses+0x1c>
        return 0;
   14df0:	2000      	movs	r0, #0
   14df2:	e7ab      	b.n	14d4c <_DNS_GetAddresses+0x1c>
   14df4:	2000      	movs	r0, #0
   14df6:	e7a9      	b.n	14d4c <_DNS_GetAddresses+0x1c>
   14df8:	2000      	movs	r0, #0
   14dfa:	e7a7      	b.n	14d4c <_DNS_GetAddresses+0x1c>
        return 0;
   14dfc:	2000      	movs	r0, #0
   14dfe:	e7a5      	b.n	14d4c <_DNS_GetAddresses+0x1c>
   14e00:	2000      	movs	r0, #0
   14e02:	e7a3      	b.n	14d4c <_DNS_GetAddresses+0x1c>
        return 0; 
   14e04:	2000      	movs	r0, #0
   14e06:	e7a1      	b.n	14d4c <_DNS_GetAddresses+0x1c>
    nAddrs = 0;
   14e08:	2000      	movs	r0, #0
   14e0a:	e79f      	b.n	14d4c <_DNS_GetAddresses+0x1c>
   14e0c:	2000      	movs	r0, #0
   14e0e:	e79d      	b.n	14d4c <_DNS_GetAddresses+0x1c>
   14e10:	2000      	movs	r0, #0
   14e12:	e79b      	b.n	14d4c <_DNS_GetAddresses+0x1c>
   14e14:	2000      	movs	r0, #0
   14e16:	e799      	b.n	14d4c <_DNS_GetAddresses+0x1c>
   14e18:	2000e424 	.word	0x2000e424

Disassembly of section .text._strtol_l.isra.0%302:

00014e1c <_strtol_l.isra.0>:
   14e1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14e20:	4f38      	ldr	r7, [pc, #224]	; (14f04 <_strtol_l.isra.0+0xe8>)
   14e22:	4686      	mov	lr, r0
   14e24:	4608      	mov	r0, r1
   14e26:	4605      	mov	r5, r0
   14e28:	f815 4b01 	ldrb.w	r4, [r5], #1
   14e2c:	5de6      	ldrb	r6, [r4, r7]
   14e2e:	f016 0608 	ands.w	r6, r6, #8
   14e32:	d136      	bne.n	14ea2 <_strtol_l.isra.0+0x86>
   14e34:	2c2d      	cmp	r4, #45	; 0x2d
   14e36:	d136      	bne.n	14ea6 <_strtol_l.isra.0+0x8a>
   14e38:	782c      	ldrb	r4, [r5, #0]
   14e3a:	2601      	movs	r6, #1
   14e3c:	1c85      	adds	r5, r0, #2
   14e3e:	2b00      	cmp	r3, #0
   14e40:	d05c      	beq.n	14efc <_strtol_l.isra.0+0xe0>
   14e42:	2b10      	cmp	r3, #16
   14e44:	d109      	bne.n	14e5a <_strtol_l.isra.0+0x3e>
   14e46:	2c30      	cmp	r4, #48	; 0x30
   14e48:	d107      	bne.n	14e5a <_strtol_l.isra.0+0x3e>
   14e4a:	7828      	ldrb	r0, [r5, #0]
   14e4c:	f000 00df 	and.w	r0, r0, #223	; 0xdf
   14e50:	2858      	cmp	r0, #88	; 0x58
   14e52:	d14e      	bne.n	14ef2 <_strtol_l.isra.0+0xd6>
   14e54:	786c      	ldrb	r4, [r5, #1]
   14e56:	2310      	movs	r3, #16
   14e58:	3502      	adds	r5, #2
   14e5a:	2e00      	cmp	r6, #0
   14e5c:	bf14      	ite	ne
   14e5e:	f04f 4c00 	movne.w	ip, #2147483648	; 0x80000000
   14e62:	f06f 4c00 	mvneq.w	ip, #2147483648	; 0x80000000
   14e66:	2700      	movs	r7, #0
   14e68:	fbbc f8f3 	udiv	r8, ip, r3
   14e6c:	4638      	mov	r0, r7
   14e6e:	fb03 ca18 	mls	sl, r3, r8, ip
   14e72:	f04f 39ff 	mov.w	r9, #4294967295
   14e76:	f1a4 0b30 	sub.w	fp, r4, #48	; 0x30
   14e7a:	f1bb 0f09 	cmp.w	fp, #9
   14e7e:	d817      	bhi.n	14eb0 <_strtol_l.isra.0+0x94>
   14e80:	465c      	mov	r4, fp
   14e82:	42a3      	cmp	r3, r4
   14e84:	dd24      	ble.n	14ed0 <_strtol_l.isra.0+0xb4>
   14e86:	f1b7 3fff 	cmp.w	r7, #4294967295
   14e8a:	d007      	beq.n	14e9c <_strtol_l.isra.0+0x80>
   14e8c:	4580      	cmp	r8, r0
   14e8e:	d31d      	bcc.n	14ecc <_strtol_l.isra.0+0xb0>
   14e90:	d101      	bne.n	14e96 <_strtol_l.isra.0+0x7a>
   14e92:	45a2      	cmp	sl, r4
   14e94:	db1a      	blt.n	14ecc <_strtol_l.isra.0+0xb0>
   14e96:	fb00 4003 	mla	r0, r0, r3, r4
   14e9a:	2701      	movs	r7, #1
   14e9c:	f815 4b01 	ldrb.w	r4, [r5], #1
   14ea0:	e7e9      	b.n	14e76 <_strtol_l.isra.0+0x5a>
   14ea2:	4628      	mov	r0, r5
   14ea4:	e7bf      	b.n	14e26 <_strtol_l.isra.0+0xa>
   14ea6:	2c2b      	cmp	r4, #43	; 0x2b
   14ea8:	bf04      	itt	eq
   14eaa:	782c      	ldrbeq	r4, [r5, #0]
   14eac:	1c85      	addeq	r5, r0, #2
   14eae:	e7c6      	b.n	14e3e <_strtol_l.isra.0+0x22>
   14eb0:	f1a4 0b41 	sub.w	fp, r4, #65	; 0x41
   14eb4:	f1bb 0f19 	cmp.w	fp, #25
   14eb8:	d801      	bhi.n	14ebe <_strtol_l.isra.0+0xa2>
   14eba:	3c37      	subs	r4, #55	; 0x37
   14ebc:	e7e1      	b.n	14e82 <_strtol_l.isra.0+0x66>
   14ebe:	f1a4 0b61 	sub.w	fp, r4, #97	; 0x61
   14ec2:	f1bb 0f19 	cmp.w	fp, #25
   14ec6:	d803      	bhi.n	14ed0 <_strtol_l.isra.0+0xb4>
   14ec8:	3c57      	subs	r4, #87	; 0x57
   14eca:	e7da      	b.n	14e82 <_strtol_l.isra.0+0x66>
   14ecc:	464f      	mov	r7, r9
   14ece:	e7e5      	b.n	14e9c <_strtol_l.isra.0+0x80>
   14ed0:	1c7b      	adds	r3, r7, #1
   14ed2:	d106      	bne.n	14ee2 <_strtol_l.isra.0+0xc6>
   14ed4:	2322      	movs	r3, #34	; 0x22
   14ed6:	f8ce 3000 	str.w	r3, [lr]
   14eda:	4660      	mov	r0, ip
   14edc:	b932      	cbnz	r2, 14eec <_strtol_l.isra.0+0xd0>
   14ede:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   14ee2:	b106      	cbz	r6, 14ee6 <_strtol_l.isra.0+0xca>
   14ee4:	4240      	negs	r0, r0
   14ee6:	2a00      	cmp	r2, #0
   14ee8:	d0f9      	beq.n	14ede <_strtol_l.isra.0+0xc2>
   14eea:	b107      	cbz	r7, 14eee <_strtol_l.isra.0+0xd2>
   14eec:	1e69      	subs	r1, r5, #1
   14eee:	6011      	str	r1, [r2, #0]
   14ef0:	e7f5      	b.n	14ede <_strtol_l.isra.0+0xc2>
   14ef2:	2430      	movs	r4, #48	; 0x30
   14ef4:	2b00      	cmp	r3, #0
   14ef6:	d1b0      	bne.n	14e5a <_strtol_l.isra.0+0x3e>
   14ef8:	2308      	movs	r3, #8
   14efa:	e7ae      	b.n	14e5a <_strtol_l.isra.0+0x3e>
   14efc:	2c30      	cmp	r4, #48	; 0x30
   14efe:	d0a4      	beq.n	14e4a <_strtol_l.isra.0+0x2e>
   14f00:	230a      	movs	r3, #10
   14f02:	e7aa      	b.n	14e5a <_strtol_l.isra.0+0x3e>
   14f04:	00014195 	.word	0x00014195

Disassembly of section .text._printf_common%303:

00014f08 <_printf_common>:
   14f08:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   14f0c:	4691      	mov	r9, r2
   14f0e:	461f      	mov	r7, r3
   14f10:	688a      	ldr	r2, [r1, #8]
   14f12:	690b      	ldr	r3, [r1, #16]
   14f14:	f8dd 8020 	ldr.w	r8, [sp, #32]
   14f18:	4293      	cmp	r3, r2
   14f1a:	bfb8      	it	lt
   14f1c:	4613      	movlt	r3, r2
   14f1e:	f8c9 3000 	str.w	r3, [r9]
   14f22:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
   14f26:	4606      	mov	r6, r0
   14f28:	460c      	mov	r4, r1
   14f2a:	b112      	cbz	r2, 14f32 <_printf_common+0x2a>
   14f2c:	3301      	adds	r3, #1
   14f2e:	f8c9 3000 	str.w	r3, [r9]
   14f32:	6823      	ldr	r3, [r4, #0]
   14f34:	0699      	lsls	r1, r3, #26
   14f36:	bf42      	ittt	mi
   14f38:	f8d9 3000 	ldrmi.w	r3, [r9]
   14f3c:	3302      	addmi	r3, #2
   14f3e:	f8c9 3000 	strmi.w	r3, [r9]
   14f42:	6825      	ldr	r5, [r4, #0]
   14f44:	f015 0506 	ands.w	r5, r5, #6
   14f48:	d107      	bne.n	14f5a <_printf_common+0x52>
   14f4a:	f104 0a19 	add.w	sl, r4, #25
   14f4e:	68e3      	ldr	r3, [r4, #12]
   14f50:	f8d9 2000 	ldr.w	r2, [r9]
   14f54:	1a9b      	subs	r3, r3, r2
   14f56:	42ab      	cmp	r3, r5
   14f58:	dc28      	bgt.n	14fac <_printf_common+0xa4>
   14f5a:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   14f5e:	6822      	ldr	r2, [r4, #0]
   14f60:	3300      	adds	r3, #0
   14f62:	bf18      	it	ne
   14f64:	2301      	movne	r3, #1
   14f66:	0692      	lsls	r2, r2, #26
   14f68:	d42d      	bmi.n	14fc6 <_printf_common+0xbe>
   14f6a:	f104 0243 	add.w	r2, r4, #67	; 0x43
   14f6e:	4639      	mov	r1, r7
   14f70:	4630      	mov	r0, r6
   14f72:	47c0      	blx	r8
   14f74:	3001      	adds	r0, #1
   14f76:	d020      	beq.n	14fba <_printf_common+0xb2>
   14f78:	6823      	ldr	r3, [r4, #0]
   14f7a:	68e5      	ldr	r5, [r4, #12]
   14f7c:	f8d9 2000 	ldr.w	r2, [r9]
   14f80:	f003 0306 	and.w	r3, r3, #6
   14f84:	2b04      	cmp	r3, #4
   14f86:	bf08      	it	eq
   14f88:	1aad      	subeq	r5, r5, r2
   14f8a:	68a3      	ldr	r3, [r4, #8]
   14f8c:	6922      	ldr	r2, [r4, #16]
   14f8e:	bf0c      	ite	eq
   14f90:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
   14f94:	2500      	movne	r5, #0
   14f96:	4293      	cmp	r3, r2
   14f98:	bfc4      	itt	gt
   14f9a:	1a9b      	subgt	r3, r3, r2
   14f9c:	18ed      	addgt	r5, r5, r3
   14f9e:	f04f 0900 	mov.w	r9, #0
   14fa2:	341a      	adds	r4, #26
   14fa4:	454d      	cmp	r5, r9
   14fa6:	d11a      	bne.n	14fde <_printf_common+0xd6>
   14fa8:	2000      	movs	r0, #0
   14faa:	e008      	b.n	14fbe <_printf_common+0xb6>
   14fac:	2301      	movs	r3, #1
   14fae:	4652      	mov	r2, sl
   14fb0:	4639      	mov	r1, r7
   14fb2:	4630      	mov	r0, r6
   14fb4:	47c0      	blx	r8
   14fb6:	3001      	adds	r0, #1
   14fb8:	d103      	bne.n	14fc2 <_printf_common+0xba>
   14fba:	f04f 30ff 	mov.w	r0, #4294967295
   14fbe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   14fc2:	3501      	adds	r5, #1
   14fc4:	e7c3      	b.n	14f4e <_printf_common+0x46>
   14fc6:	18e1      	adds	r1, r4, r3
   14fc8:	1c5a      	adds	r2, r3, #1
   14fca:	2030      	movs	r0, #48	; 0x30
   14fcc:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
   14fd0:	4422      	add	r2, r4
   14fd2:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
   14fd6:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
   14fda:	3302      	adds	r3, #2
   14fdc:	e7c5      	b.n	14f6a <_printf_common+0x62>
   14fde:	2301      	movs	r3, #1
   14fe0:	4622      	mov	r2, r4
   14fe2:	4639      	mov	r1, r7
   14fe4:	4630      	mov	r0, r6
   14fe6:	47c0      	blx	r8
   14fe8:	3001      	adds	r0, #1
   14fea:	d0e6      	beq.n	14fba <_printf_common+0xb2>
   14fec:	f109 0901 	add.w	r9, r9, #1
   14ff0:	e7d8      	b.n	14fa4 <_printf_common+0x9c>

Disassembly of section .text.DRV_PIC32CGMAC_LibTxSendPacket%304:

00014ff4 <DRV_PIC32CGMAC_LibTxSendPacket>:
{
   14ff4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	DRV_PIC32CGMAC_HW_TXDCPT *pTxDesc = pMACDrv->sGmacData.gmac_queue[queueIdx].pTxDesc;
   14ff8:	232c      	movs	r3, #44	; 0x2c
   14ffa:	fb03 0302 	mla	r3, r3, r2, r0
   14ffe:	f8d3 70a0 	ldr.w	r7, [r3, #160]	; 0xa0
	uint16_t wTxIndex = pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescHead ;
   15002:	f8b3 30b2 	ldrh.w	r3, [r3, #178]	; 0xb2
	uint16_t wTxDescCount =pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt;
   15006:	eb02 04c2 	add.w	r4, r2, r2, lsl #3
   1500a:	eb00 0444 	add.w	r4, r0, r4, lsl #1
   1500e:	f8b4 c0c8 	ldrh.w	ip, [r4, #200]	; 0xc8
    while (pPktDSeg)
   15012:	b371      	cbz	r1, 15072 <DRV_PIC32CGMAC_LibTxSendPacket+0x7e>
   15014:	460d      	mov	r5, r1
    uint8_t nLoopCnt =0;
   15016:	2400      	movs	r4, #0
        if((_DRV_GMAC_DescSpace(wTxIndex, pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail, wTxDescCount)) &&
   15018:	f04f 0e2c 	mov.w	lr, #44	; 0x2c
   1501c:	fb0e 0e02 	mla	lr, lr, r2, r0
   15020:	e01d      	b.n	1505e <DRV_PIC32CGMAC_LibTxSendPacket+0x6a>
           (pTxDesc[wTxIndex].tx_desc_buffaddr == 0))
   15022:	eb07 06c3 	add.w	r6, r7, r3, lsl #3
   15026:	f857 1033 	ldr.w	r1, [r7, r3, lsl #3]
        if((_DRV_GMAC_DescSpace(wTxIndex, pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail, wTxDescCount)) &&
   1502a:	2900      	cmp	r1, #0
   1502c:	d152      	bne.n	150d4 <DRV_PIC32CGMAC_LibTxSendPacket+0xe0>
            pTxDesc[wTxIndex].tx_desc_status.val &= (GMAC_TX_WRAP_BIT |GMAC_TX_USED_BIT); //clear all Tx Status except Wrap Bit and Used Bit
   1502e:	6871      	ldr	r1, [r6, #4]
   15030:	f001 4140 	and.w	r1, r1, #3221225472	; 0xc0000000
   15034:	6071      	str	r1, [r6, #4]
            pTxDesc[wTxIndex].tx_desc_buffaddr = (uint32_t)((uint8_t *)pPktDSeg->segLoad);	//set the buffer address
   15036:	68a9      	ldr	r1, [r5, #8]
   15038:	f847 1033 	str.w	r1, [r7, r3, lsl #3]
            pTxDesc[wTxIndex].tx_desc_status.val |= (pPktDSeg->segLen) & GMAC_LENGTH_FRAME; //Set Length for each frame
   1503c:	f8d6 8004 	ldr.w	r8, [r6, #4]
   15040:	89a9      	ldrh	r1, [r5, #12]
   15042:	f3c1 010d 	ubfx	r1, r1, #0, #14
   15046:	ea41 0108 	orr.w	r1, r1, r8
   1504a:	6071      	str	r1, [r6, #4]
            GCIRC_INC(wTxIndex,wTxDescCount); //Increment the index of Tx Desc
   1504c:	3301      	adds	r3, #1
   1504e:	b29b      	uxth	r3, r3
   15050:	459c      	cmp	ip, r3
   15052:	bf98      	it	ls
   15054:	2300      	movls	r3, #0
            pPktDSeg = pPktDSeg->next;
   15056:	682d      	ldr	r5, [r5, #0]
            nLoopCnt++;
   15058:	3401      	adds	r4, #1
   1505a:	b2e4      	uxtb	r4, r4
    while (pPktDSeg)
   1505c:	b155      	cbz	r5, 15074 <DRV_PIC32CGMAC_LibTxSendPacket+0x80>
        if((_DRV_GMAC_DescSpace(wTxIndex, pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail, wTxDescCount)) &&
   1505e:	f8be 10b4 	ldrh.w	r1, [lr, #180]	; 0xb4
    return (tail > head)? (tail - head) : (size - head + tail);
   15062:	4299      	cmp	r1, r3
   15064:	d8dd      	bhi.n	15022 <DRV_PIC32CGMAC_LibTxSendPacket+0x2e>
   15066:	4461      	add	r1, ip
   15068:	b289      	uxth	r1, r1
   1506a:	4299      	cmp	r1, r3
   1506c:	d1d9      	bne.n	15022 <DRV_PIC32CGMAC_LibTxSendPacket+0x2e>
            return DRV_PIC32CGMAC_RES_NO_DESCRIPTORS;
   1506e:	2003      	movs	r0, #3
   15070:	e02e      	b.n	150d0 <DRV_PIC32CGMAC_LibTxSendPacket+0xdc>
    uint8_t nLoopCnt =0;
   15072:	2400      	movs	r4, #0
    pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescHead = wTxIndex;
   15074:	212c      	movs	r1, #44	; 0x2c
   15076:	fb01 0002 	mla	r0, r1, r2, r0
   1507a:	f8a0 30b2 	strh.w	r3, [r0, #178]	; 0xb2
    GCIRC_DEC(wTxIndex,wTxDescCount);
   1507e:	b973      	cbnz	r3, 1509e <DRV_PIC32CGMAC_LibTxSendPacket+0xaa>
   15080:	f10c 33ff 	add.w	r3, ip, #4294967295
   15084:	b29b      	uxth	r3, r3
    pTxDesc[wTxIndex].tx_desc_status.val |= GMAC_TX_LAST_BUFFER_BIT;
   15086:	eb07 01c3 	add.w	r1, r7, r3, lsl #3
   1508a:	684a      	ldr	r2, [r1, #4]
   1508c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
   15090:	604a      	str	r2, [r1, #4]
    while(nLoopCnt)
   15092:	b1bc      	cbz	r4, 150c4 <DRV_PIC32CGMAC_LibTxSendPacket+0xd0>
        GCIRC_DEC(wTxIndex,wTxDescCount);
   15094:	f10c 3cff 	add.w	ip, ip, #4294967295
   15098:	fa1f fc8c 	uxth.w	ip, ip
   1509c:	e008      	b.n	150b0 <DRV_PIC32CGMAC_LibTxSendPacket+0xbc>
    GCIRC_DEC(wTxIndex,wTxDescCount);
   1509e:	3b01      	subs	r3, #1
   150a0:	b29b      	uxth	r3, r3
   150a2:	e7f0      	b.n	15086 <DRV_PIC32CGMAC_LibTxSendPacket+0x92>
        GCIRC_DEC(wTxIndex,wTxDescCount);
   150a4:	3b01      	subs	r3, #1
   150a6:	b29b      	uxth	r3, r3
        nLoopCnt--;
   150a8:	3c01      	subs	r4, #1
    while(nLoopCnt)
   150aa:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
   150ae:	d009      	beq.n	150c4 <DRV_PIC32CGMAC_LibTxSendPacket+0xd0>
        pTxDesc[wTxIndex].tx_desc_status.val &= ~GMAC_TX_USED_BIT;
   150b0:	eb07 01c3 	add.w	r1, r7, r3, lsl #3
   150b4:	684a      	ldr	r2, [r1, #4]
   150b6:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
   150ba:	604a      	str	r2, [r1, #4]
        GCIRC_DEC(wTxIndex,wTxDescCount);
   150bc:	2b00      	cmp	r3, #0
   150be:	d1f1      	bne.n	150a4 <DRV_PIC32CGMAC_LibTxSendPacket+0xb0>
   150c0:	4663      	mov	r3, ip
   150c2:	e7f1      	b.n	150a8 <DRV_PIC32CGMAC_LibTxSendPacket+0xb4>
    GMAC_REGS->GMAC_NCR |= GMAC_NCR_TSTART_Msk;	
   150c4:	4a04      	ldr	r2, [pc, #16]	; (150d8 <DRV_PIC32CGMAC_LibTxSendPacket+0xe4>)
   150c6:	6813      	ldr	r3, [r2, #0]
   150c8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   150cc:	6013      	str	r3, [r2, #0]
	return DRV_PIC32CGMAC_RES_OK;
   150ce:	2000      	movs	r0, #0
} //DRV_PIC32CGMAC_LibTxSendPacket
   150d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            return DRV_PIC32CGMAC_RES_NO_DESCRIPTORS;
   150d4:	2003      	movs	r0, #3
   150d6:	e7fb      	b.n	150d0 <DRV_PIC32CGMAC_LibTxSendPacket+0xdc>
   150d8:	42000800 	.word	0x42000800

Disassembly of section .text._Command_IPAddressSet%305:

000150dc <_Command_IPAddressSet>:
{
   150dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   150e0:	b082      	sub	sp, #8
   150e2:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   150e4:	6845      	ldr	r5, [r0, #4]
    if (argc < 3)
   150e6:	2902      	cmp	r1, #2
   150e8:	dc10      	bgt.n	1510c <_Command_IPAddressSet+0x30>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: setip <interface> <ipv4/6 address> <ipv4mask/ipv6 prefix len>\r\n");
   150ea:	4e2f      	ldr	r6, [pc, #188]	; (151a8 <_Command_IPAddressSet+0xcc>)
   150ec:	6803      	ldr	r3, [r0, #0]
   150ee:	681b      	ldr	r3, [r3, #0]
   150f0:	f606 51fc 	addw	r1, r6, #3580	; 0xdfc
   150f4:	4628      	mov	r0, r5
   150f6:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: setip PIC32INT 192.168.0.8 255.255.255.0 \r\n");
   150f8:	6823      	ldr	r3, [r4, #0]
   150fa:	681b      	ldr	r3, [r3, #0]
   150fc:	f606 6144 	addw	r1, r6, #3652	; 0xe44
   15100:	4628      	mov	r0, r5
   15102:	4798      	blx	r3
}
   15104:	2000      	movs	r0, #0
   15106:	b002      	add	sp, #8
   15108:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1510c:	460e      	mov	r6, r1
   1510e:	4617      	mov	r7, r2
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
   15110:	6850      	ldr	r0, [r2, #4]
   15112:	f008 fd4f 	bl	1dbb4 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
   15116:	4680      	mov	r8, r0
   15118:	b150      	cbz	r0, 15130 <_Command_IPAddressSet+0x54>
   1511a:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   1511e:	f013 0f40 	tst.w	r3, #64	; 0x40
   15122:	d10b      	bne.n	1513c <_Command_IPAddressSet+0x60>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "No such interface is up\r\n");
   15124:	6823      	ldr	r3, [r4, #0]
   15126:	681b      	ldr	r3, [r3, #0]
   15128:	4920      	ldr	r1, [pc, #128]	; (151ac <_Command_IPAddressSet+0xd0>)
   1512a:	4628      	mov	r0, r5
   1512c:	4798      	blx	r3
        return false;
   1512e:	e7e9      	b.n	15104 <_Command_IPAddressSet+0x28>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   15130:	6823      	ldr	r3, [r4, #0]
   15132:	681b      	ldr	r3, [r3, #0]
   15134:	491e      	ldr	r1, [pc, #120]	; (151b0 <_Command_IPAddressSet+0xd4>)
   15136:	4628      	mov	r0, r5
   15138:	4798      	blx	r3
        return false;
   1513a:	e7e3      	b.n	15104 <_Command_IPAddressSet+0x28>
    if (TCPIP_Helper_StringToIPAddress(argv[2], &ipAddr))
   1513c:	a901      	add	r1, sp, #4
   1513e:	68b8      	ldr	r0, [r7, #8]
   15140:	f7fe f9be 	bl	134c0 <TCPIP_Helper_StringToIPAddress>
   15144:	b928      	cbnz	r0, 15152 <_Command_IPAddressSet+0x76>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Invalid IP address string \r\n");
   15146:	6823      	ldr	r3, [r4, #0]
   15148:	681b      	ldr	r3, [r3, #0]
   1514a:	491a      	ldr	r1, [pc, #104]	; (151b4 <_Command_IPAddressSet+0xd8>)
   1514c:	4628      	mov	r0, r5
   1514e:	4798      	blx	r3
        return false;
   15150:	e7d8      	b.n	15104 <_Command_IPAddressSet+0x28>
        if(_TCPIPStackAddressServiceIsRunning(pNetIf) != TCPIP_STACK_ADDRESS_SERVICE_NONE)
   15152:	4640      	mov	r0, r8
   15154:	f00c ffec 	bl	22130 <_TCPIPStackAddressServiceIsRunning>
   15158:	b940      	cbnz	r0, 1516c <_Command_IPAddressSet+0x90>
        if(argc > 3)
   1515a:	2e03      	cmp	r6, #3
   1515c:	dd12      	ble.n	15184 <_Command_IPAddressSet+0xa8>
            if (!TCPIP_Helper_StringToIPAddress(argv[3], &ipMask))
   1515e:	4669      	mov	r1, sp
   15160:	68f8      	ldr	r0, [r7, #12]
   15162:	f7fe f9ad 	bl	134c0 <TCPIP_Helper_StringToIPAddress>
   15166:	b138      	cbz	r0, 15178 <_Command_IPAddressSet+0x9c>
            pMask = &ipMask;
   15168:	466a      	mov	r2, sp
   1516a:	e00c      	b.n	15186 <_Command_IPAddressSet+0xaa>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "An address service is already running. Stop DHCP, ZCLL, etc. first\r\n");
   1516c:	6823      	ldr	r3, [r4, #0]
   1516e:	681b      	ldr	r3, [r3, #0]
   15170:	4911      	ldr	r1, [pc, #68]	; (151b8 <_Command_IPAddressSet+0xdc>)
   15172:	4628      	mov	r0, r5
   15174:	4798      	blx	r3
            return false;
   15176:	e7c5      	b.n	15104 <_Command_IPAddressSet+0x28>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Invalid IP mask string \r\n");
   15178:	6823      	ldr	r3, [r4, #0]
   1517a:	681b      	ldr	r3, [r3, #0]
   1517c:	490f      	ldr	r1, [pc, #60]	; (151bc <_Command_IPAddressSet+0xe0>)
   1517e:	4628      	mov	r0, r5
   15180:	4798      	blx	r3
                return false;
   15182:	e7bf      	b.n	15104 <_Command_IPAddressSet+0x28>
            pMask = 0;
   15184:	2200      	movs	r2, #0
        if(TCPIP_STACK_NetAddressSet(netH, &ipAddr, pMask, true))
   15186:	2301      	movs	r3, #1
   15188:	a901      	add	r1, sp, #4
   1518a:	4640      	mov	r0, r8
   1518c:	f003 ff40 	bl	19010 <TCPIP_STACK_NetAddressSet>
    (*pCmdIO->pCmdApi->msg)(cmdIoParam, success ? "Set ip address OK\r\n" : "Set ip address failed\r\n");
   15190:	6823      	ldr	r3, [r4, #0]
   15192:	681b      	ldr	r3, [r3, #0]
   15194:	2800      	cmp	r0, #0
   15196:	490a      	ldr	r1, [pc, #40]	; (151c0 <_Command_IPAddressSet+0xe4>)
   15198:	f101 0214 	add.w	r2, r1, #20
   1519c:	bf08      	it	eq
   1519e:	4611      	moveq	r1, r2
   151a0:	4628      	mov	r0, r5
   151a2:	4798      	blx	r3
    return false;
   151a4:	e7ae      	b.n	15104 <_Command_IPAddressSet+0x28>
   151a6:	bf00      	nop
   151a8:	0000028c 	.word	0x0000028c
   151ac:	00001100 	.word	0x00001100
   151b0:	00000da8 	.word	0x00000da8
   151b4:	0000103c 	.word	0x0000103c
   151b8:	0000111c 	.word	0x0000111c
   151bc:	00001164 	.word	0x00001164
   151c0:	0000105c 	.word	0x0000105c

Disassembly of section .text.xTaskResumeAll%306:

000151c4 <xTaskResumeAll>:
{
   151c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	taskENTER_CRITICAL();
   151c8:	f00b fd42 	bl	20c50 <vPortEnterCritical>
		--uxSchedulerSuspended;
   151cc:	4b2d      	ldr	r3, [pc, #180]	; (15284 <xTaskResumeAll+0xc0>)
   151ce:	681a      	ldr	r2, [r3, #0]
   151d0:	3a01      	subs	r2, #1
   151d2:	601a      	str	r2, [r3, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   151d4:	681b      	ldr	r3, [r3, #0]
   151d6:	2b00      	cmp	r3, #0
   151d8:	d14d      	bne.n	15276 <xTaskResumeAll+0xb2>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   151da:	4b2b      	ldr	r3, [pc, #172]	; (15288 <xTaskResumeAll+0xc4>)
   151dc:	681b      	ldr	r3, [r3, #0]
   151de:	b90b      	cbnz	r3, 151e4 <xTaskResumeAll+0x20>
BaseType_t xAlreadyYielded = pdFALSE;
   151e0:	2400      	movs	r4, #0
   151e2:	e049      	b.n	15278 <xTaskResumeAll+0xb4>
TCB_t *pxTCB = NULL;
   151e4:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   151e6:	4e29      	ldr	r6, [pc, #164]	; (1528c <xTaskResumeAll+0xc8>)
					prvAddTaskToReadyList( pxTCB );
   151e8:	4f29      	ldr	r7, [pc, #164]	; (15290 <xTaskResumeAll+0xcc>)
   151ea:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 152a4 <xTaskResumeAll+0xe0>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   151ee:	6833      	ldr	r3, [r6, #0]
   151f0:	b303      	cbz	r3, 15234 <xTaskResumeAll+0x70>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   151f2:	68f3      	ldr	r3, [r6, #12]
   151f4:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   151f6:	f104 0018 	add.w	r0, r4, #24
   151fa:	f00b f9fb 	bl	205f4 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   151fe:	1d25      	adds	r5, r4, #4
   15200:	4628      	mov	r0, r5
   15202:	f00b f9f7 	bl	205f4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   15206:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   15208:	683a      	ldr	r2, [r7, #0]
   1520a:	2301      	movs	r3, #1
   1520c:	4083      	lsls	r3, r0
   1520e:	4313      	orrs	r3, r2
   15210:	603b      	str	r3, [r7, #0]
   15212:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   15216:	4629      	mov	r1, r5
   15218:	eb08 0080 	add.w	r0, r8, r0, lsl #2
   1521c:	f00c fb13 	bl	21846 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   15220:	4b1c      	ldr	r3, [pc, #112]	; (15294 <xTaskResumeAll+0xd0>)
   15222:	681b      	ldr	r3, [r3, #0]
   15224:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   15226:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   15228:	429a      	cmp	r2, r3
   1522a:	d3e0      	bcc.n	151ee <xTaskResumeAll+0x2a>
						xYieldPending = pdTRUE;
   1522c:	4b1a      	ldr	r3, [pc, #104]	; (15298 <xTaskResumeAll+0xd4>)
   1522e:	2201      	movs	r2, #1
   15230:	601a      	str	r2, [r3, #0]
   15232:	e7dc      	b.n	151ee <xTaskResumeAll+0x2a>
				if( pxTCB != NULL )
   15234:	b10c      	cbz	r4, 1523a <xTaskResumeAll+0x76>
					prvResetNextTaskUnblockTime();
   15236:	f00a fc39 	bl	1faac <prvResetNextTaskUnblockTime>
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
   1523a:	4b18      	ldr	r3, [pc, #96]	; (1529c <xTaskResumeAll+0xd8>)
   1523c:	681c      	ldr	r4, [r3, #0]
					if( xPendedCounts > ( TickType_t ) 0U )
   1523e:	b16c      	cbz	r4, 1525c <xTaskResumeAll+0x98>
								xYieldPending = pdTRUE;
   15240:	4e15      	ldr	r6, [pc, #84]	; (15298 <xTaskResumeAll+0xd4>)
   15242:	2501      	movs	r5, #1
   15244:	e001      	b.n	1524a <xTaskResumeAll+0x86>
						} while( xPendedCounts > ( TickType_t ) 0U );
   15246:	3c01      	subs	r4, #1
   15248:	d005      	beq.n	15256 <xTaskResumeAll+0x92>
							if( xTaskIncrementTick() != pdFALSE )
   1524a:	f7fe fb73 	bl	13934 <xTaskIncrementTick>
   1524e:	2800      	cmp	r0, #0
   15250:	d0f9      	beq.n	15246 <xTaskResumeAll+0x82>
								xYieldPending = pdTRUE;
   15252:	6035      	str	r5, [r6, #0]
   15254:	e7f7      	b.n	15246 <xTaskResumeAll+0x82>
						xPendedTicks = 0;
   15256:	4b11      	ldr	r3, [pc, #68]	; (1529c <xTaskResumeAll+0xd8>)
   15258:	2200      	movs	r2, #0
   1525a:	601a      	str	r2, [r3, #0]
				if( xYieldPending != pdFALSE )
   1525c:	4b0e      	ldr	r3, [pc, #56]	; (15298 <xTaskResumeAll+0xd4>)
   1525e:	681c      	ldr	r4, [r3, #0]
   15260:	b154      	cbz	r4, 15278 <xTaskResumeAll+0xb4>
					taskYIELD_IF_USING_PREEMPTION();
   15262:	4b0f      	ldr	r3, [pc, #60]	; (152a0 <xTaskResumeAll+0xdc>)
   15264:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   15268:	601a      	str	r2, [r3, #0]
   1526a:	f3bf 8f4f 	dsb	sy
   1526e:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
   15272:	2401      	movs	r4, #1
   15274:	e000      	b.n	15278 <xTaskResumeAll+0xb4>
BaseType_t xAlreadyYielded = pdFALSE;
   15276:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
   15278:	f00c fbb2 	bl	219e0 <vPortExitCritical>
}
   1527c:	4620      	mov	r0, r4
   1527e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   15282:	bf00      	nop
   15284:	2000e4b0 	.word	0x2000e4b0
   15288:	2000e4a8 	.word	0x2000e4a8
   1528c:	2000e2b4 	.word	0x2000e2b4
   15290:	2000e4b8 	.word	0x2000e4b8
   15294:	2000e49c 	.word	0x2000e49c
   15298:	2000e4d4 	.word	0x2000e4d4
   1529c:	2000e4c8 	.word	0x2000e4c8
   152a0:	e000ed04 	.word	0xe000ed04
   152a4:	2000de80 	.word	0x2000de80

Disassembly of section .text.TCPIP_UDP_ArrayGet%307:

000152a8 <TCPIP_UDP_ArrayGet>:
{
   152a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    if(reqBytes == 0 || pSkt == 0)
   152ac:	2a00      	cmp	r2, #0
   152ae:	d063      	beq.n	15378 <TCPIP_UDP_ArrayGet+0xd0>
   152b0:	4689      	mov	r9, r1
   152b2:	4616      	mov	r6, r2
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   152b4:	f00a feb6 	bl	20024 <_UDPSocketDcpt>
    if(reqBytes == 0 || pSkt == 0)
   152b8:	4604      	mov	r4, r0
   152ba:	2800      	cmp	r0, #0
   152bc:	d060      	beq.n	15380 <TCPIP_UDP_ArrayGet+0xd8>
    if(pSkt->pCurrRxSeg == 0 && pSkt->extFlags.rxAutoAdvance != 0)
   152be:	6b03      	ldr	r3, [r0, #48]	; 0x30
   152c0:	b133      	cbz	r3, 152d0 <TCPIP_UDP_ArrayGet+0x28>
    while(reqBytes != 0 && (pSeg = pSkt->pCurrRxSeg) != 0 && pSkt->rxTotLen != 0)
   152c2:	6b07      	ldr	r7, [r0, #48]	; 0x30
   152c4:	8ee5      	ldrh	r5, [r4, #54]	; 0x36
   152c6:	46a8      	mov	r8, r5
   152c8:	b1c5      	cbz	r5, 152fc <TCPIP_UDP_ArrayGet+0x54>
   152ca:	f04f 0800 	mov.w	r8, #0
   152ce:	e026      	b.n	1531e <TCPIP_UDP_ArrayGet+0x76>
    if(pSkt->pCurrRxSeg == 0 && pSkt->extFlags.rxAutoAdvance != 0)
   152d0:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   152d4:	f013 0f01 	tst.w	r3, #1
   152d8:	d102      	bne.n	152e0 <TCPIP_UDP_ArrayGet+0x38>
   152da:	f04f 0800 	mov.w	r8, #0
   152de:	e00a      	b.n	152f6 <TCPIP_UDP_ArrayGet+0x4e>
        _UDPUpdatePacketLock(pSkt);
   152e0:	f00a feb4 	bl	2004c <_UDPUpdatePacketLock>
    while(reqBytes != 0 && (pSeg = pSkt->pCurrRxSeg) != 0 && pSkt->rxTotLen != 0)
   152e4:	6b27      	ldr	r7, [r4, #48]	; 0x30
   152e6:	f04f 0800 	mov.w	r8, #0
   152ea:	2f00      	cmp	r7, #0
   152ec:	d1ea      	bne.n	152c4 <TCPIP_UDP_ArrayGet+0x1c>
   152ee:	e002      	b.n	152f6 <TCPIP_UDP_ArrayGet+0x4e>
                pSkt->rxSegLen = 0;
   152f0:	2300      	movs	r3, #0
   152f2:	86a3      	strh	r3, [r4, #52]	; 0x34
                pSkt->rxCurr = 0;
   152f4:	63a3      	str	r3, [r4, #56]	; 0x38
    if(pSkt->rxTotLen == 0 && pSkt->extFlags.rxAutoAdvance != 0)
   152f6:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   152f8:	2b00      	cmp	r3, #0
   152fa:	d13e      	bne.n	1537a <TCPIP_UDP_ArrayGet+0xd2>
   152fc:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   15300:	f013 0f01 	tst.w	r3, #1
   15304:	d039      	beq.n	1537a <TCPIP_UDP_ArrayGet+0xd2>
        _UDPUpdatePacketLock(pSkt);
   15306:	4620      	mov	r0, r4
   15308:	f00a fea0 	bl	2004c <_UDPUpdatePacketLock>
   1530c:	e035      	b.n	1537a <TCPIP_UDP_ArrayGet+0xd2>
    while(reqBytes != 0 && (pSeg = pSkt->pCurrRxSeg) != 0 && pSkt->rxTotLen != 0)
   1530e:	2e00      	cmp	r6, #0
   15310:	d0f1      	beq.n	152f6 <TCPIP_UDP_ArrayGet+0x4e>
   15312:	6b27      	ldr	r7, [r4, #48]	; 0x30
   15314:	2f00      	cmp	r7, #0
   15316:	d0ee      	beq.n	152f6 <TCPIP_UDP_ArrayGet+0x4e>
   15318:	8ee5      	ldrh	r5, [r4, #54]	; 0x36
   1531a:	2d00      	cmp	r5, #0
   1531c:	d0ee      	beq.n	152fc <TCPIP_UDP_ArrayGet+0x54>
        xtractBytes = reqBytes <= pSkt->rxSegLen ? reqBytes : pSkt->rxSegLen;
   1531e:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
   15320:	42b3      	cmp	r3, r6
   15322:	bf28      	it	cs
   15324:	4633      	movcs	r3, r6
        if(xtractBytes > pSkt->rxTotLen)
   15326:	429d      	cmp	r5, r3
   15328:	bf28      	it	cs
   1532a:	461d      	movcs	r5, r3
        if(xtractBytes)
   1532c:	b1b5      	cbz	r5, 1535c <TCPIP_UDP_ArrayGet+0xb4>
            if(cData != 0)
   1532e:	f1b9 0f00 	cmp.w	r9, #0
   15332:	d005      	beq.n	15340 <TCPIP_UDP_ArrayGet+0x98>
                memcpy(cData, pSkt->rxCurr, xtractBytes);
   15334:	462a      	mov	r2, r5
   15336:	6ba1      	ldr	r1, [r4, #56]	; 0x38
   15338:	4648      	mov	r0, r9
   1533a:	f00b ff21 	bl	21180 <memcpy>
                cData += xtractBytes;
   1533e:	44a9      	add	r9, r5
            reqBytes -= xtractBytes;
   15340:	1b76      	subs	r6, r6, r5
   15342:	b2b6      	uxth	r6, r6
            avlblBytes += xtractBytes;
   15344:	44a8      	add	r8, r5
   15346:	fa1f f888 	uxth.w	r8, r8
            pSkt->rxTotLen -= xtractBytes;
   1534a:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   1534c:	1b5b      	subs	r3, r3, r5
   1534e:	86e3      	strh	r3, [r4, #54]	; 0x36
            pSkt->rxSegLen -= xtractBytes;
   15350:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
   15352:	1b5b      	subs	r3, r3, r5
   15354:	86a3      	strh	r3, [r4, #52]	; 0x34
            pSkt->rxCurr += xtractBytes;
   15356:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   15358:	441d      	add	r5, r3
   1535a:	63a5      	str	r5, [r4, #56]	; 0x38
        if(pSkt->rxSegLen == 0)
   1535c:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
   1535e:	2b00      	cmp	r3, #0
   15360:	d1d5      	bne.n	1530e <TCPIP_UDP_ArrayGet+0x66>
            pSeg = pSeg->next;
   15362:	683f      	ldr	r7, [r7, #0]
            if((pSkt->pCurrRxSeg = pSeg) != 0)
   15364:	6327      	str	r7, [r4, #48]	; 0x30
   15366:	2f00      	cmp	r7, #0
   15368:	d0c2      	beq.n	152f0 <TCPIP_UDP_ArrayGet+0x48>
                pSkt->rxSegLen = pSeg->segLen;
   1536a:	89bb      	ldrh	r3, [r7, #12]
   1536c:	86a3      	strh	r3, [r4, #52]	; 0x34
                pSkt->rxCurr = pSeg->segLoad;
   1536e:	68bb      	ldr	r3, [r7, #8]
   15370:	63a3      	str	r3, [r4, #56]	; 0x38
    while(reqBytes != 0 && (pSeg = pSkt->pCurrRxSeg) != 0 && pSkt->rxTotLen != 0)
   15372:	2e00      	cmp	r6, #0
   15374:	d1d0      	bne.n	15318 <TCPIP_UDP_ArrayGet+0x70>
   15376:	e7be      	b.n	152f6 <TCPIP_UDP_ArrayGet+0x4e>
        return 0;
   15378:	4690      	mov	r8, r2
}
   1537a:	4640      	mov	r0, r8
   1537c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return 0;
   15380:	f04f 0800 	mov.w	r8, #0
   15384:	e7f9      	b.n	1537a <TCPIP_UDP_ArrayGet+0xd2>

Disassembly of section .text.DRV_ETHPHY_Setup%308:

00015388 <DRV_ETHPHY_Setup>:
    if(hClientObj == 0)
   15388:	2800      	cmp	r0, #0
   1538a:	d045      	beq.n	15418 <DRV_ETHPHY_Setup+0x90>
{
   1538c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1538e:	b085      	sub	sp, #20
   15390:	4604      	mov	r4, r0
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   15392:	68c0      	ldr	r0, [r0, #12]
   15394:	4b30      	ldr	r3, [pc, #192]	; (15458 <DRV_ETHPHY_Setup+0xd0>)
   15396:	4298      	cmp	r0, r3
   15398:	d141      	bne.n	1541e <DRV_ETHPHY_Setup+0x96>
    if(hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_READY)
   1539a:	f994 3008 	ldrsb.w	r3, [r4, #8]
   1539e:	2b02      	cmp	r3, #2
   153a0:	d141      	bne.n	15426 <DRV_ETHPHY_Setup+0x9e>
    if(pSetUp == 0 || pSetupFlags == 0)
   153a2:	2900      	cmp	r1, #0
   153a4:	d042      	beq.n	1542c <DRV_ETHPHY_Setup+0xa4>
   153a6:	2a00      	cmp	r2, #0
   153a8:	d043      	beq.n	15432 <DRV_ETHPHY_Setup+0xaa>
    pPhyObj = phyInst->pPhyObj;
   153aa:	4b2b      	ldr	r3, [pc, #172]	; (15458 <DRV_ETHPHY_Setup+0xd0>)
   153ac:	695f      	ldr	r7, [r3, #20]
    if(pPhyObj == 0 || pPhyObj->miiConfigure == 0 || pPhyObj->mdixConfigure == 0 || pPhyObj->smiClockGet == 0)
   153ae:	2f00      	cmp	r7, #0
   153b0:	d042      	beq.n	15438 <DRV_ETHPHY_Setup+0xb0>
   153b2:	683b      	ldr	r3, [r7, #0]
   153b4:	2b00      	cmp	r3, #0
   153b6:	d042      	beq.n	1543e <DRV_ETHPHY_Setup+0xb6>
   153b8:	687b      	ldr	r3, [r7, #4]
   153ba:	2b00      	cmp	r3, #0
   153bc:	d042      	beq.n	15444 <DRV_ETHPHY_Setup+0xbc>
   153be:	68bb      	ldr	r3, [r7, #8]
   153c0:	2b00      	cmp	r3, #0
   153c2:	d042      	beq.n	1544a <DRV_ETHPHY_Setup+0xc2>
   153c4:	4616      	mov	r6, r2
   153c6:	460d      	mov	r5, r1
    if(pSetUp->resetFunction)
   153c8:	688b      	ldr	r3, [r1, #8]
   153ca:	b10b      	cbz	r3, 153d0 <DRV_ETHPHY_Setup+0x48>
        (*pSetUp->resetFunction)(gDrvEthBaseObj);
   153cc:	4823      	ldr	r0, [pc, #140]	; (1545c <DRV_ETHPHY_Setup+0xd4>)
   153ce:	4798      	blx	r3
	miimSetup.hostClockFreq = (uint32_t)TCPIP_INTMAC_PERIPHERAL_CLK;
   153d0:	4b23      	ldr	r3, [pc, #140]	; (15460 <DRV_ETHPHY_Setup+0xd8>)
   153d2:	9301      	str	r3, [sp, #4]
    miimSetup.maxBusFreq = (*pPhyObj->smiClockGet)(gDrvEthBaseObj, handle);
   153d4:	68bb      	ldr	r3, [r7, #8]
   153d6:	4621      	mov	r1, r4
   153d8:	4820      	ldr	r0, [pc, #128]	; (1545c <DRV_ETHPHY_Setup+0xd4>)
   153da:	4798      	blx	r3
   153dc:	9002      	str	r0, [sp, #8]
    miimSetup.setupFlags = DRV_MIIM_SETUP_FLAG_NONE;
   153de:	2300      	movs	r3, #0
   153e0:	f88d 300c 	strb.w	r3, [sp, #12]
    DRV_MIIM_RESULT miimRes = hClientObj->pMiimBase->DRV_MIIM_Setup(hClientObj->miimHandle, &miimSetup); 
   153e4:	6923      	ldr	r3, [r4, #16]
   153e6:	699b      	ldr	r3, [r3, #24]
   153e8:	a901      	add	r1, sp, #4
   153ea:	6960      	ldr	r0, [r4, #20]
   153ec:	4798      	blx	r3
    if(miimRes < 0)
   153ee:	2800      	cmp	r0, #0
   153f0:	db2e      	blt.n	15450 <DRV_ETHPHY_Setup+0xc8>
    phyInst->phyAddress = pSetUp->phyAddress;
   153f2:	682a      	ldr	r2, [r5, #0]
   153f4:	4b18      	ldr	r3, [pc, #96]	; (15458 <DRV_ETHPHY_Setup+0xd0>)
   153f6:	611a      	str	r2, [r3, #16]
    phyInst->openFlags = pSetUp->openFlags;
   153f8:	88aa      	ldrh	r2, [r5, #4]
   153fa:	819a      	strh	r2, [r3, #12]
    phyInst->configFlags = pSetUp->configFlags;
   153fc:	79aa      	ldrb	r2, [r5, #6]
   153fe:	739a      	strb	r2, [r3, #14]
    phyInst->macPauseType = pSetUp->macPauseType;
   15400:	79ea      	ldrb	r2, [r5, #7]
   15402:	73da      	strb	r2, [r3, #15]
    hClientObj->operParam = (uintptr_t)pSetupFlags;
   15404:	6326      	str	r6, [r4, #48]	; 0x30
    hClientObj->operType = opType;
   15406:	2001      	movs	r0, #1
   15408:	83a0      	strh	r0, [r4, #28]
    hClientObj->operPhase = hClientObj->operSubPhase = 0; 
   1540a:	2300      	movs	r3, #0
   1540c:	8423      	strh	r3, [r4, #32]
   1540e:	83e3      	strh	r3, [r4, #30]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_BUSY; 
   15410:	7220      	strb	r0, [r4, #8]
    hClientObj->operRes = res;
   15412:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
   15416:	e004      	b.n	15422 <DRV_ETHPHY_Setup+0x9a>
        return DRV_ETHPHY_RES_HANDLE_ERR;
   15418:	f06f 000a 	mvn.w	r0, #10
}
   1541c:	4770      	bx	lr
        return DRV_ETHPHY_RES_HANDLE_ERR;
   1541e:	f06f 000a 	mvn.w	r0, #10
}
   15422:	b005      	add	sp, #20
   15424:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   15426:	f06f 0009 	mvn.w	r0, #9
   1542a:	e7fa      	b.n	15422 <DRV_ETHPHY_Setup+0x9a>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   1542c:	f06f 0008 	mvn.w	r0, #8
   15430:	e7f7      	b.n	15422 <DRV_ETHPHY_Setup+0x9a>
   15432:	f06f 0008 	mvn.w	r0, #8
   15436:	e7f4      	b.n	15422 <DRV_ETHPHY_Setup+0x9a>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   15438:	f06f 0008 	mvn.w	r0, #8
   1543c:	e7f1      	b.n	15422 <DRV_ETHPHY_Setup+0x9a>
   1543e:	f06f 0008 	mvn.w	r0, #8
   15442:	e7ee      	b.n	15422 <DRV_ETHPHY_Setup+0x9a>
   15444:	f06f 0008 	mvn.w	r0, #8
   15448:	e7eb      	b.n	15422 <DRV_ETHPHY_Setup+0x9a>
   1544a:	f06f 0008 	mvn.w	r0, #8
   1544e:	e7e8      	b.n	15422 <DRV_ETHPHY_Setup+0x9a>
        return DRV_ETHPHY_RES_MIIM_ERR;
   15450:	f06f 000c 	mvn.w	r0, #12
   15454:	e7e5      	b.n	15422 <DRV_ETHPHY_Setup+0x9a>
   15456:	bf00      	nop
   15458:	2000de18 	.word	0x2000de18
   1545c:	0001b870 	.word	0x0001b870
   15460:	07270e00 	.word	0x07270e00

Disassembly of section .text.__swsetup_r%309:

00015464 <__swsetup_r>:
   15464:	4b32      	ldr	r3, [pc, #200]	; (15530 <__swsetup_r+0xcc>)
   15466:	b570      	push	{r4, r5, r6, lr}
   15468:	681d      	ldr	r5, [r3, #0]
   1546a:	4606      	mov	r6, r0
   1546c:	460c      	mov	r4, r1
   1546e:	b125      	cbz	r5, 1547a <__swsetup_r+0x16>
   15470:	69ab      	ldr	r3, [r5, #24]
   15472:	b913      	cbnz	r3, 1547a <__swsetup_r+0x16>
   15474:	4628      	mov	r0, r5
   15476:	f006 f99b 	bl	1b7b0 <__sinit>
   1547a:	4b2e      	ldr	r3, [pc, #184]	; (15534 <__swsetup_r+0xd0>)
   1547c:	429c      	cmp	r4, r3
   1547e:	d10f      	bne.n	154a0 <__swsetup_r+0x3c>
   15480:	686c      	ldr	r4, [r5, #4]
   15482:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   15486:	b29a      	uxth	r2, r3
   15488:	0715      	lsls	r5, r2, #28
   1548a:	d42c      	bmi.n	154e6 <__swsetup_r+0x82>
   1548c:	06d0      	lsls	r0, r2, #27
   1548e:	d411      	bmi.n	154b4 <__swsetup_r+0x50>
   15490:	2209      	movs	r2, #9
   15492:	6032      	str	r2, [r6, #0]
   15494:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   15498:	81a3      	strh	r3, [r4, #12]
   1549a:	f04f 30ff 	mov.w	r0, #4294967295
   1549e:	e03e      	b.n	1551e <__swsetup_r+0xba>
   154a0:	4b25      	ldr	r3, [pc, #148]	; (15538 <__swsetup_r+0xd4>)
   154a2:	429c      	cmp	r4, r3
   154a4:	d101      	bne.n	154aa <__swsetup_r+0x46>
   154a6:	68ac      	ldr	r4, [r5, #8]
   154a8:	e7eb      	b.n	15482 <__swsetup_r+0x1e>
   154aa:	4b24      	ldr	r3, [pc, #144]	; (1553c <__swsetup_r+0xd8>)
   154ac:	429c      	cmp	r4, r3
   154ae:	bf08      	it	eq
   154b0:	68ec      	ldreq	r4, [r5, #12]
   154b2:	e7e6      	b.n	15482 <__swsetup_r+0x1e>
   154b4:	0751      	lsls	r1, r2, #29
   154b6:	d512      	bpl.n	154de <__swsetup_r+0x7a>
   154b8:	6b61      	ldr	r1, [r4, #52]	; 0x34
   154ba:	b141      	cbz	r1, 154ce <__swsetup_r+0x6a>
   154bc:	f104 0344 	add.w	r3, r4, #68	; 0x44
   154c0:	4299      	cmp	r1, r3
   154c2:	d002      	beq.n	154ca <__swsetup_r+0x66>
   154c4:	4630      	mov	r0, r6
   154c6:	f002 fd25 	bl	17f14 <_free_r>
   154ca:	2300      	movs	r3, #0
   154cc:	6363      	str	r3, [r4, #52]	; 0x34
   154ce:	89a3      	ldrh	r3, [r4, #12]
   154d0:	f023 0324 	bic.w	r3, r3, #36	; 0x24
   154d4:	81a3      	strh	r3, [r4, #12]
   154d6:	2300      	movs	r3, #0
   154d8:	6063      	str	r3, [r4, #4]
   154da:	6923      	ldr	r3, [r4, #16]
   154dc:	6023      	str	r3, [r4, #0]
   154de:	89a3      	ldrh	r3, [r4, #12]
   154e0:	f043 0308 	orr.w	r3, r3, #8
   154e4:	81a3      	strh	r3, [r4, #12]
   154e6:	6923      	ldr	r3, [r4, #16]
   154e8:	b94b      	cbnz	r3, 154fe <__swsetup_r+0x9a>
   154ea:	89a3      	ldrh	r3, [r4, #12]
   154ec:	f403 7320 	and.w	r3, r3, #640	; 0x280
   154f0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   154f4:	d003      	beq.n	154fe <__swsetup_r+0x9a>
   154f6:	4621      	mov	r1, r4
   154f8:	4630      	mov	r0, r6
   154fa:	f003 fb69 	bl	18bd0 <__smakebuf_r>
   154fe:	89a2      	ldrh	r2, [r4, #12]
   15500:	f012 0301 	ands.w	r3, r2, #1
   15504:	d00c      	beq.n	15520 <__swsetup_r+0xbc>
   15506:	2300      	movs	r3, #0
   15508:	60a3      	str	r3, [r4, #8]
   1550a:	6963      	ldr	r3, [r4, #20]
   1550c:	425b      	negs	r3, r3
   1550e:	61a3      	str	r3, [r4, #24]
   15510:	6923      	ldr	r3, [r4, #16]
   15512:	b953      	cbnz	r3, 1552a <__swsetup_r+0xc6>
   15514:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   15518:	f013 0080 	ands.w	r0, r3, #128	; 0x80
   1551c:	d1ba      	bne.n	15494 <__swsetup_r+0x30>
   1551e:	bd70      	pop	{r4, r5, r6, pc}
   15520:	0792      	lsls	r2, r2, #30
   15522:	bf58      	it	pl
   15524:	6963      	ldrpl	r3, [r4, #20]
   15526:	60a3      	str	r3, [r4, #8]
   15528:	e7f2      	b.n	15510 <__swsetup_r+0xac>
   1552a:	2000      	movs	r0, #0
   1552c:	e7f7      	b.n	1551e <__swsetup_r+0xba>
   1552e:	bf00      	nop
   15530:	2000e4e4 	.word	0x2000e4e4
   15534:	2000e130 	.word	0x2000e130
   15538:	2000e150 	.word	0x2000e150
   1553c:	2000e110 	.word	0x2000e110

Disassembly of section .text.SYS_TIME_PLIBCallback%310:

00015540 <SYS_TIME_PLIBCallback>:
        }
    }
}

static void SYS_TIME_PLIBCallback(uint32_t status, uintptr_t context)
{
   15540:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    SYS_TIME_COUNTER_OBJ* counterObj = (SYS_TIME_COUNTER_OBJ *)&gSystemCounterObj;
    SYS_TIME_TIMER_OBJ* tmrActive = counterObj->tmrActive;
   15542:	4c32      	ldr	r4, [pc, #200]	; (1560c <SYS_TIME_PLIBCallback+0xcc>)
   15544:	6b25      	ldr	r5, [r4, #48]	; 0x30
    uint32_t elapsedCount = 0;
    bool interruptState;

    counterObj->hwTimerCurrentValue = counterObj->timePlib->timerCounterGet();
   15546:	6863      	ldr	r3, [r4, #4]
   15548:	699b      	ldr	r3, [r3, #24]
   1554a:	4798      	blx	r3
   1554c:	6160      	str	r0, [r4, #20]

    elapsedCount = SYS_TIME_GetElapsedCount(counterObj->hwTimerCurrentValue);
   1554e:	6960      	ldr	r0, [r4, #20]
   15550:	f00b fdb4 	bl	210bc <SYS_TIME_GetElapsedCount>
   15554:	4606      	mov	r6, r0
	
	SYS_TIME_Counter64Update(elapsedCount);
   15556:	f00b fda3 	bl	210a0 <SYS_TIME_Counter64Update>

    if (tmrActive != NULL)
   1555a:	2d00      	cmp	r5, #0
   1555c:	d04d      	beq.n	155fa <SYS_TIME_PLIBCallback+0xba>
    {
        counterObj->interruptNestingCount++;
   1555e:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
   15562:	3301      	adds	r3, #1
   15564:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
    SYS_TIME_UpdateTimerList(elapsedCounts);
   15568:	4630      	mov	r0, r6
   1556a:	f009 ff55 	bl	1f418 <SYS_TIME_UpdateTimerList>
    SYS_TIME_TIMER_OBJ* tmrActive = counterObj->tmrActive;
   1556e:	6b24      	ldr	r4, [r4, #48]	; 0x30
    while (tmrActive != NULL)
   15570:	b12c      	cbz	r4, 1557e <SYS_TIME_PLIBCallback+0x3e>
        if(tmrActive->relativeTimePending == 0)
   15572:	68a3      	ldr	r3, [r4, #8]
   15574:	b91b      	cbnz	r3, 1557e <SYS_TIME_PLIBCallback+0x3e>
            tmrActive->tmrElapsedFlag = true;
   15576:	2501      	movs	r5, #1
                    tmrActive->active = false;
   15578:	2700      	movs	r7, #0
            tmrActive = counterObj->tmrActive;
   1557a:	4e24      	ldr	r6, [pc, #144]	; (1560c <SYS_TIME_PLIBCallback+0xcc>)
   1557c:	e011      	b.n	155a2 <SYS_TIME_PLIBCallback+0x62>
   1557e:	4d24      	ldr	r5, [pc, #144]	; (15610 <SYS_TIME_PLIBCallback+0xd0>)
{
   15580:	2400      	movs	r4, #0
        if (timers[i].tmrElapsed == true)
   15582:	462e      	mov	r6, r5
            timers[i].tmrElapsed = false;
   15584:	4627      	mov	r7, r4
   15586:	e01f      	b.n	155c8 <SYS_TIME_PLIBCallback+0x88>
                SYS_TIME_TimerDestroy(tmrActive->tmrHandle);
   15588:	69e0      	ldr	r0, [r4, #28]
   1558a:	f008 ff0f 	bl	1e3ac <SYS_TIME_TimerDestroy>
            if(tmrActive->callback != NULL)
   1558e:	68e3      	ldr	r3, [r4, #12]
   15590:	b10b      	cbz	r3, 15596 <SYS_TIME_PLIBCallback+0x56>
                tmrActive->callback(tmrActive->context);
   15592:	6920      	ldr	r0, [r4, #16]
   15594:	4798      	blx	r3
            tmrActive = counterObj->tmrActive;
   15596:	6b34      	ldr	r4, [r6, #48]	; 0x30
    while (tmrActive != NULL)
   15598:	2c00      	cmp	r4, #0
   1559a:	d0f0      	beq.n	1557e <SYS_TIME_PLIBCallback+0x3e>
        if(tmrActive->relativeTimePending == 0)
   1559c:	68a3      	ldr	r3, [r4, #8]
   1559e:	2b00      	cmp	r3, #0
   155a0:	d1ed      	bne.n	1557e <SYS_TIME_PLIBCallback+0x3e>
            tmrActive->tmrElapsedFlag = true;
   155a2:	7525      	strb	r5, [r4, #20]
            tmrActive->tmrElapsed = true;
   155a4:	7565      	strb	r5, [r4, #21]
            if ((tmrActive->type == SYS_TIME_SINGLE) && (tmrActive->callback != NULL))
   155a6:	78a3      	ldrb	r3, [r4, #2]
   155a8:	b913      	cbnz	r3, 155b0 <SYS_TIME_PLIBCallback+0x70>
   155aa:	68e3      	ldr	r3, [r4, #12]
   155ac:	2b00      	cmp	r3, #0
   155ae:	d1eb      	bne.n	15588 <SYS_TIME_PLIBCallback+0x48>
                SYS_TIME_RemoveFromList(tmrActive);
   155b0:	4620      	mov	r0, r4
   155b2:	f006 fa71 	bl	1ba98 <SYS_TIME_RemoveFromList>
                if (tmrActive->type == SYS_TIME_SINGLE)
   155b6:	78a3      	ldrb	r3, [r4, #2]
   155b8:	2b00      	cmp	r3, #0
   155ba:	d1e8      	bne.n	1558e <SYS_TIME_PLIBCallback+0x4e>
                    tmrActive->active = false;
   155bc:	7067      	strb	r7, [r4, #1]
   155be:	e7e6      	b.n	1558e <SYS_TIME_PLIBCallback+0x4e>
   155c0:	3401      	adds	r4, #1
   155c2:	3520      	adds	r5, #32
    for ( i = 0; i < SYS_TIME_MAX_TIMERS; i++)
   155c4:	2c05      	cmp	r4, #5
   155c6:	d012      	beq.n	155ee <SYS_TIME_PLIBCallback+0xae>
        if (timers[i].tmrElapsed == true)
   155c8:	eb06 1344 	add.w	r3, r6, r4, lsl #5
   155cc:	7d5b      	ldrb	r3, [r3, #21]
   155ce:	2b00      	cmp	r3, #0
   155d0:	d0f6      	beq.n	155c0 <SYS_TIME_PLIBCallback+0x80>
            timers[i].tmrElapsed = false;
   155d2:	eb06 1344 	add.w	r3, r6, r4, lsl #5
   155d6:	755f      	strb	r7, [r3, #21]
            if (timers[i].type == SYS_TIME_PERIODIC)
   155d8:	78ab      	ldrb	r3, [r5, #2]
   155da:	2b01      	cmp	r3, #1
   155dc:	d1f0      	bne.n	155c0 <SYS_TIME_PLIBCallback+0x80>
                timers[i].relativeTimePending = timers[i].requestedTime;
   155de:	686b      	ldr	r3, [r5, #4]
   155e0:	eb06 1244 	add.w	r2, r6, r4, lsl #5
   155e4:	6093      	str	r3, [r2, #8]
                SYS_TIME_AddToList(&timers[i]);
   155e6:	4628      	mov	r0, r5
   155e8:	f003 f990 	bl	1890c <SYS_TIME_AddToList>
   155ec:	e7e8      	b.n	155c0 <SYS_TIME_PLIBCallback+0x80>

        SYS_TIME_UpdateTime(elapsedCount);

        counterObj->interruptNestingCount--;
   155ee:	4a07      	ldr	r2, [pc, #28]	; (1560c <SYS_TIME_PLIBCallback+0xcc>)
   155f0:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
   155f4:	3b01      	subs	r3, #1
   155f6:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
    }
    
    interruptState = SYS_INT_Disable();
   155fa:	f00c fdd9 	bl	221b0 <SYS_INT_Disable>
   155fe:	4604      	mov	r4, r0
    SYS_TIME_HwTimerCompareUpdate();
   15600:	f001 fb64 	bl	16ccc <SYS_TIME_HwTimerCompareUpdate>
    SYS_INT_Restore(interruptState);
   15604:	4620      	mov	r0, r4
   15606:	f00c fdd7 	bl	221b8 <SYS_INT_Restore>
}
   1560a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1560c:	2000e030 	.word	0x2000e030
   15610:	2000db50 	.word	0x2000db50

Disassembly of section .text.ssd1306_init%311:

00015614 <ssd1306_init>:
 *
 * Call this function to initialize the hardware interface and the OLED
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void ssd1306_init(void) {
   15614:	b530      	push	{r4, r5, lr}
   15616:	b083      	sub	sp, #12
     * \brief Perform a hard reset of the OLED controller
     *
     * This functions will reset the OLED controller by setting the reset pin low.
     */
    static inline void ssd1306_hard_reset(void) {
        GFX_DELAY_FUNCTION(20); // At least 10us	
   15618:	2014      	movs	r0, #20
   1561a:	f009 fbed 	bl	1edf8 <vTaskDelay>
        GFX_DISPLAY_RESET_CLEAR();
   1561e:	4c31      	ldr	r4, [pc, #196]	; (156e4 <ssd1306_init+0xd0>)
   15620:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   15624:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
        GFX_DELAY_FUNCTION(20); // At least 10us	
   15628:	2014      	movs	r0, #20
   1562a:	f009 fbe5 	bl	1edf8 <vTaskDelay>
        GFX_DISPLAY_RESET_SET();
   1562e:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98
        GFX_DELAY_FUNCTION(20); // At least 10us	
   15632:	2014      	movs	r0, #20
   15634:	f009 fbe0 	bl	1edf8 <vTaskDelay>

    // Do a hard reset of the OLED display controller
    ssd1306_hard_reset();

    // Set the reset pin to the default state	
    GFX_DISPLAY_RESET_SET();
   15638:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98

    // 1/32 Duty (0x0F~0x3F)
    ssd1306_write_command(SSD1306_CMD_SET_MULTIPLEX_RATIO);
   1563c:	20a8      	movs	r0, #168	; 0xa8
   1563e:	f008 fb99 	bl	1dd74 <ssd1306_write_command>
    ssd1306_write_command(0x1F);
   15642:	201f      	movs	r0, #31
   15644:	f008 fb96 	bl	1dd74 <ssd1306_write_command>

    // Shift Mapping RAM Counter (0x00~0x3F)
    ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_OFFSET);
   15648:	20d3      	movs	r0, #211	; 0xd3
   1564a:	f008 fb93 	bl	1dd74 <ssd1306_write_command>
    ssd1306_write_command(0x00);
   1564e:	2000      	movs	r0, #0
   15650:	f008 fb90 	bl	1dd74 <ssd1306_write_command>

    // Set Mapping RAM Display Start Line (0x00~0x3F)
    ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_START_LINE(0x00));
   15654:	2040      	movs	r0, #64	; 0x40
   15656:	f008 fb8d 	bl	1dd74 <ssd1306_write_command>

    // Set Column Address 0 Mapped to SEG0
    ssd1306_write_command(SSD1306_CMD_SET_SEGMENT_RE_MAP_COL127_SEG0);
   1565a:	20a1      	movs	r0, #161	; 0xa1
   1565c:	f008 fb8a 	bl	1dd74 <ssd1306_write_command>

    // Set COM/Row Scan Scan from COM63 to 0
    ssd1306_write_command(SSD1306_CMD_SET_COM_OUTPUT_SCAN_DOWN);
   15660:	20c8      	movs	r0, #200	; 0xc8
   15662:	f008 fb87 	bl	1dd74 <ssd1306_write_command>

    // Set COM Pins hardware configuration
    ssd1306_write_command(SSD1306_CMD_SET_COM_PINS);
   15666:	20da      	movs	r0, #218	; 0xda
   15668:	f008 fb84 	bl	1dd74 <ssd1306_write_command>
    ssd1306_write_command(0x02);
   1566c:	2002      	movs	r0, #2
   1566e:	f008 fb81 	bl	1dd74 <ssd1306_write_command>
     * \param contrast a number between 0 and 0xFF
     *
     * \retval contrast the contrast value written to the OLED controller
     */
    static inline uint8_t ssd1306_set_contrast(uint8_t contrast) {
        ssd1306_write_command(SSD1306_CMD_SET_CONTRAST_CONTROL_FOR_BANK0);
   15672:	2081      	movs	r0, #129	; 0x81
   15674:	f008 fb7e 	bl	1dd74 <ssd1306_write_command>
        ssd1306_write_command(contrast);
   15678:	208f      	movs	r0, #143	; 0x8f
   1567a:	f008 fb7b 	bl	1dd74 <ssd1306_write_command>

    ssd1306_set_contrast(0x8F);

    // Disable Entire display On
    ssd1306_write_command(SSD1306_CMD_ENTIRE_DISPLAY_AND_GDDRAM_ON);
   1567e:	20a4      	movs	r0, #164	; 0xa4
   15680:	f008 fb78 	bl	1dd74 <ssd1306_write_command>
     *
     * This function will disable invert on all pixels on the OLED
     *
     */
    static inline void ssd1306_display_invert_disable(void) {
        ssd1306_write_command(SSD1306_CMD_SET_NORMAL_DISPLAY);
   15684:	20a6      	movs	r0, #166	; 0xa6
   15686:	f008 fb75 	bl	1dd74 <ssd1306_write_command>

    ssd1306_display_invert_disable();

    // Set Display Clock Divide Ratio / Oscillator Frequency (Default => 0x80)
    ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_CLOCK_DIVIDE_RATIO);
   1568a:	20d5      	movs	r0, #213	; 0xd5
   1568c:	f008 fb72 	bl	1dd74 <ssd1306_write_command>
    ssd1306_write_command(0x80);
   15690:	2080      	movs	r0, #128	; 0x80
   15692:	f008 fb6f 	bl	1dd74 <ssd1306_write_command>

    // Enable charge pump regulator
    ssd1306_write_command(SSD1306_CMD_SET_CHARGE_PUMP_SETTING);
   15696:	208d      	movs	r0, #141	; 0x8d
   15698:	f008 fb6c 	bl	1dd74 <ssd1306_write_command>
    ssd1306_write_command(0x14);
   1569c:	2014      	movs	r0, #20
   1569e:	f008 fb69 	bl	1dd74 <ssd1306_write_command>

    // Set VCOMH Deselect Level
    ssd1306_write_command(SSD1306_CMD_SET_VCOMH_DESELECT_LEVEL);
   156a2:	20db      	movs	r0, #219	; 0xdb
   156a4:	f008 fb66 	bl	1dd74 <ssd1306_write_command>
    ssd1306_write_command(0x40); // Default => 0x20 (0.77*VCC)
   156a8:	2040      	movs	r0, #64	; 0x40
   156aa:	f008 fb63 	bl	1dd74 <ssd1306_write_command>

    // Set Pre-Charge as 15 Clocks & Discharge as 1 Clock
    ssd1306_write_command(SSD1306_CMD_SET_PRE_CHARGE_PERIOD);
   156ae:	20d9      	movs	r0, #217	; 0xd9
   156b0:	f008 fb60 	bl	1dd74 <ssd1306_write_command>
    ssd1306_write_command(0xF1);
   156b4:	20f1      	movs	r0, #241	; 0xf1
   156b6:	f008 fb5d 	bl	1dd74 <ssd1306_write_command>
        ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_ON);
   156ba:	20af      	movs	r0, #175	; 0xaf
   156bc:	f008 fb5a 	bl	1dd74 <ssd1306_write_command>

    ssd1306_display_on();

    gfx_mono_draw_filled_rect(0, 0, 128, 32, GFX_PIXEL_SET);
   156c0:	2301      	movs	r3, #1
   156c2:	9300      	str	r3, [sp, #0]
   156c4:	2320      	movs	r3, #32
   156c6:	2280      	movs	r2, #128	; 0x80
   156c8:	2100      	movs	r1, #0
   156ca:	4608      	mov	r0, r1
   156cc:	f009 fbc8 	bl	1ee60 <gfx_mono_generic_draw_filled_rect>
    gfx_mono_draw_filled_rect(0, 0, 128, 32, GFX_PIXEL_CLR);
   156d0:	2000      	movs	r0, #0
   156d2:	9000      	str	r0, [sp, #0]
   156d4:	2320      	movs	r3, #32
   156d6:	2280      	movs	r2, #128	; 0x80
   156d8:	4601      	mov	r1, r0
   156da:	f009 fbc1 	bl	1ee60 <gfx_mono_generic_draw_filled_rect>
}
   156de:	b003      	add	sp, #12
   156e0:	bd30      	pop	{r4, r5, pc}
   156e2:	bf00      	nop
   156e4:	41008000 	.word	0x41008000

Disassembly of section .text._DRV_ETHPHY_NegResultPhase_ANAD%312:

000156e8 <_DRV_ETHPHY_NegResultPhase_ANAD>:
        _DRV_PHY_SetOperPhase(hClientObj, DRV_ETHPHY_NEG_RESULT_PHASE_ANAD, 0);
    }
}

static void _DRV_ETHPHY_NegResultPhase_ANAD(DRV_ETHPHY_CLIENT_OBJ * hClientObj)
{
   156e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   156ea:	4604      	mov	r4, r0
    DRV_ETHPHY_LINK_STATUS  linkStat;
    TCPIP_ETH_OPEN_FLAGS   oFlags;
    TCPIP_ETH_PAUSE_TYPE   pauseType;

    // wait the ANAD read to complete
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   156ec:	f00b f85a 	bl	207a4 <_DRV_PHY_SMITransfer_Wait>
   156f0:	2800      	cmp	r0, #0
   156f2:	d059      	beq.n	157a8 <_DRV_ETHPHY_NegResultPhase_ANAD+0xc0>
    {
        return;
    }

    anadReg.w = hClientObj->smiData;
   156f4:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
    // restore ANEXP
    phyExp.w = hClientObj->operReg[0];
    // restore ANLPAD
    lpAD.w = hClientObj->operReg[1];
   156f6:	8ca5      	ldrh	r5, [r4, #36]	; 0x24

    oFlags = 0;   // don't know the result yet
    pauseType = TCPIP_ETH_PAUSE_TYPE_NONE;
    linkStat = DRV_ETHPHY_LINK_ST_UP;

    lcl_Pause  = (hClientObj->hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_PAUSE) ? 1 : 0;
   156f8:	68e2      	ldr	r2, [r4, #12]
   156fa:	7bd7      	ldrb	r7, [r2, #15]
    lcl_AsmDir = (hClientObj->hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_ASM_DIR) ? 1 : 0;
    lp_Pause   = lp_AsmDir = 0;         // in case negotiation failed

    if(phyExp.LP_AN_ABLE)
   156fc:	f894 2022 	ldrb.w	r2, [r4, #34]	; 0x22
   15700:	f012 0101 	ands.w	r1, r2, #1
   15704:	d025      	beq.n	15752 <_DRV_ETHPHY_NegResultPhase_ANAD+0x6a>
    {   // ok,valid auto negotiation info

        if(lpAD.REM_FAULT)
   15706:	0a29      	lsrs	r1, r5, #8
   15708:	f001 0220 	and.w	r2, r1, #32
        {
            linkStat |= DRV_ETHPHY_LINK_ST_REMOTE_FAULT;
   1570c:	2a00      	cmp	r2, #0
   1570e:	bf0c      	ite	eq
   15710:	2001      	moveq	r0, #1
   15712:	2005      	movne	r0, #5
        }

        if(lpAD.PAUSE)
   15714:	f011 0f04 	tst.w	r1, #4
        {
            linkStat |= DRV_ETHPHY_LINK_ST_LP_PAUSE;
   15718:	bf1a      	itte	ne
   1571a:	f040 0010 	orrne.w	r0, r0, #16
            lp_Pause = 1;
   1571e:	2601      	movne	r6, #1
    lp_Pause   = lp_AsmDir = 0;         // in case negotiation failed
   15720:	2600      	moveq	r6, #0
        }
        if(lpAD.ASM_DIR)
   15722:	f011 0f08 	tst.w	r1, #8
   15726:	d021      	beq.n	1576c <_DRV_ETHPHY_NegResultPhase_ANAD+0x84>
        {
            linkStat |= DRV_ETHPHY_LINK_ST_LP_ASM_DIR;
   15728:	f040 0020 	orr.w	r0, r0, #32
            lp_AsmDir = 1;
   1572c:	2201      	movs	r2, #1
        }
    }

    // set the PHY connection params
    // advertised capabilities & the matching ones
    anadReg.w &= lpAD.w;
   1572e:	402b      	ands	r3, r5
    // get the settings, according to IEEE 802.3 Annex 28B.3 Priority Resolution
    // Note: we don't support 100BaseT4 !

    if(anadReg.w & _ANAD_BASE100TX_FDX_MASK)
   15730:	f413 7f80 	tst.w	r3, #256	; 0x100
   15734:	d121      	bne.n	1577a <_DRV_ETHPHY_NegResultPhase_ANAD+0x92>
    {
        oFlags = (TCPIP_ETH_OPEN_100|TCPIP_ETH_OPEN_FDUPLEX);
    }
    else if(anadReg.w & _ANAD_BASE100TX_MASK)
   15736:	f013 0f80 	tst.w	r3, #128	; 0x80
   1573a:	d119      	bne.n	15770 <_DRV_ETHPHY_NegResultPhase_ANAD+0x88>
    {
        oFlags = (TCPIP_ETH_OPEN_100 | TCPIP_ETH_OPEN_HDUPLEX);
    }
    else if(anadReg.w & _ANAD_BASE10T_FDX_MASK)
   1573c:	f013 0f40 	tst.w	r3, #64	; 0x40
   15740:	d133      	bne.n	157aa <_DRV_ETHPHY_NegResultPhase_ANAD+0xc2>
    {
        oFlags = (TCPIP_ETH_OPEN_10 | TCPIP_ETH_OPEN_FDUPLEX);
    }
    else if(anadReg.w & _ANAD_BASE10T_MASK)
   15742:	f013 0320 	ands.w	r3, r3, #32
   15746:	d116      	bne.n	15776 <_DRV_ETHPHY_NegResultPhase_ANAD+0x8e>
        oFlags = (TCPIP_ETH_OPEN_10 | TCPIP_ETH_OPEN_HDUPLEX);
    }
    else
    {   // this should NOT happen!
        linkStat |= DRV_ETHPHY_LINK_ST_NEG_FATAL_ERR;
        linkStat &= ~DRV_ETHPHY_LINK_ST_UP;      // make sure we stop...!
   15748:	f020 0001 	bic.w	r0, r0, #1
   1574c:	f440 5000 	orr.w	r0, r0, #8192	; 0x2000
   15750:	e00f      	b.n	15772 <_DRV_ETHPHY_NegResultPhase_ANAD+0x8a>
        if(phyExp.PDF)
   15752:	f002 0210 	and.w	r2, r2, #16
        linkStat |= DRV_ETHPHY_LINK_ST_LP_NEG_UNABLE;
   15756:	2a00      	cmp	r2, #0
   15758:	bf14      	ite	ne
   1575a:	200b      	movne	r0, #11
   1575c:	2003      	moveq	r0, #3
    anadReg.w &= lpAD.w;
   1575e:	402b      	ands	r3, r5
    if(anadReg.w & _ANAD_BASE100TX_FDX_MASK)
   15760:	f413 7f80 	tst.w	r3, #256	; 0x100
   15764:	d123      	bne.n	157ae <_DRV_ETHPHY_NegResultPhase_ANAD+0xc6>
   15766:	2200      	movs	r2, #0
   15768:	4616      	mov	r6, r2
   1576a:	e7e4      	b.n	15736 <_DRV_ETHPHY_NegResultPhase_ANAD+0x4e>
    lp_Pause   = lp_AsmDir = 0;         // in case negotiation failed
   1576c:	2200      	movs	r2, #0
   1576e:	e7de      	b.n	1572e <_DRV_ETHPHY_NegResultPhase_ANAD+0x46>
        oFlags = (TCPIP_ETH_OPEN_100 | TCPIP_ETH_OPEN_HDUPLEX);
   15770:	230c      	movs	r3, #12
    pauseType = TCPIP_ETH_PAUSE_TYPE_NONE;
   15772:	2100      	movs	r1, #0
   15774:	e00f      	b.n	15796 <_DRV_ETHPHY_NegResultPhase_ANAD+0xae>
        oFlags = (TCPIP_ETH_OPEN_10 | TCPIP_ETH_OPEN_HDUPLEX);
   15776:	2314      	movs	r3, #20
   15778:	e7fb      	b.n	15772 <_DRV_ETHPHY_NegResultPhase_ANAD+0x8a>
        oFlags = (TCPIP_ETH_OPEN_100|TCPIP_ETH_OPEN_FDUPLEX);
   1577a:	230a      	movs	r3, #10
    lcl_Pause  = (hClientObj->hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_PAUSE) ? 1 : 0;
   1577c:	f007 0501 	and.w	r5, r7, #1

    // set the pause type for the MAC
    // according to IEEE Std 802.3-2002 Tables 28B-2, 28B-3
    if(oFlags & TCPIP_ETH_OPEN_FDUPLEX)
    {   // pause type relevant for full duplex only
        if(lp_Pause & (lcl_Pause | (lcl_AsmDir & lp_AsmDir)))
   15780:	ea02 0267 	and.w	r2, r2, r7, asr #1
   15784:	ea45 0102 	orr.w	r1, r5, r2
   15788:	4031      	ands	r1, r6
    pauseType = TCPIP_ETH_PAUSE_TYPE_NONE;
   1578a:	0089      	lsls	r1, r1, #2
        {
            pauseType = TCPIP_ETH_PAUSE_TYPE_EN_TX;
        }
        if(lcl_Pause & (lp_Pause | (lcl_AsmDir & lp_AsmDir)))
   1578c:	4332      	orrs	r2, r6
   1578e:	422a      	tst	r2, r5
        {
            pauseType |= TCPIP_ETH_PAUSE_TYPE_EN_RX;
   15790:	bf18      	it	ne
   15792:	f041 0108 	orrne.w	r1, r1, #8


static void _DRV_PHY_NegResultSetOperResult(DRV_ETHPHY_CLIENT_OBJ* hClientObj, DRV_ETHPHY_LINK_STATUS linkStatus,
       TCPIP_ETH_OPEN_FLAGS openFlags, TCPIP_ETH_PAUSE_TYPE pauseType, DRV_ETHPHY_RESULT res)
{
    DRV_ETHPHY_NEGOTIATION_RESULT* pNegResult = (DRV_ETHPHY_NEGOTIATION_RESULT*)hClientObj->operParam;
   15796:	6b22      	ldr	r2, [r4, #48]	; 0x30

    if(pNegResult)
   15798:	b112      	cbz	r2, 157a0 <_DRV_ETHPHY_NegResultPhase_ANAD+0xb8>
    {
        pNegResult->linkStatus = linkStatus;
   1579a:	8010      	strh	r0, [r2, #0]
        pNegResult->linkFlags = openFlags;
   1579c:	8053      	strh	r3, [r2, #2]
        pNegResult->pauseType = pauseType;
   1579e:	7111      	strb	r1, [r2, #4]
    }

    _DRV_PHY_SetOperDoneResult(hClientObj, res);
   157a0:	2100      	movs	r1, #0
   157a2:	4620      	mov	r0, r4
   157a4:	f00a fac2 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
}
   157a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        oFlags = (TCPIP_ETH_OPEN_10 | TCPIP_ETH_OPEN_FDUPLEX);
   157aa:	2312      	movs	r3, #18
   157ac:	e7e6      	b.n	1577c <_DRV_ETHPHY_NegResultPhase_ANAD+0x94>
    lcl_Pause  = (hClientObj->hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_PAUSE) ? 1 : 0;
   157ae:	f007 0501 	and.w	r5, r7, #1
        oFlags = (TCPIP_ETH_OPEN_100|TCPIP_ETH_OPEN_FDUPLEX);
   157b2:	230a      	movs	r3, #10
    lcl_Pause  = (hClientObj->hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_PAUSE) ? 1 : 0;
   157b4:	2600      	movs	r6, #0
        if(lp_Pause & (lcl_Pause | (lcl_AsmDir & lp_AsmDir)))
   157b6:	4632      	mov	r2, r6
   157b8:	e7e8      	b.n	1578c <_DRV_ETHPHY_NegResultPhase_ANAD+0xa4>

Disassembly of section .text.DRV_ETHPHY_Detect%313:

000157ba <DRV_ETHPHY_Detect>:
{
   157ba:	b5f0      	push	{r4, r5, r6, r7, lr}
   157bc:	b087      	sub	sp, #28
   157be:	4606      	mov	r6, r0
   157c0:	460c      	mov	r4, r1
    uint16_t registerValue = 0;
   157c2:	2100      	movs	r1, #0
   157c4:	f8ad 1016 	strh.w	r1, [sp, #22]
    LAN867X_REG_OBJ clientObj = {0};
   157c8:	9100      	str	r1, [sp, #0]
   157ca:	9101      	str	r1, [sp, #4]
    clientObj.miimBase = ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->pMiimBase;
   157cc:	6923      	ldr	r3, [r4, #16]
   157ce:	9303      	str	r3, [sp, #12]
    clientObj.miimHandle = ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->miimHandle;
   157d0:	6963      	ldr	r3, [r4, #20]
   157d2:	9302      	str	r3, [sp, #8]
    clientObj.miimOpHandle = &((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->miimOpHandle;
   157d4:	f104 0318 	add.w	r3, r4, #24
   157d8:	9304      	str	r3, [sp, #16]
    pBaseObj->DRV_ETHPHY_PhyAddressGet(hClientObj, DRV_ETHPHY_INF_IDX_ALL_EXTERNAL,
   157da:	6a83      	ldr	r3, [r0, #40]	; 0x28
   157dc:	466a      	mov	r2, sp
   157de:	4620      	mov	r0, r4
   157e0:	4798      	blx	r3
    pBaseObj->DRV_ETHPHY_VendorDataGet(hClientObj, &clientObj.vendorData);
   157e2:	6cb3      	ldr	r3, [r6, #72]	; 0x48
   157e4:	a901      	add	r1, sp, #4
   157e6:	4620      	mov	r0, r4
   157e8:	4798      	blx	r3
    state = R2F(clientObj.vendorData, VENDOR_STATE);
   157ea:	f89d 5006 	ldrb.w	r5, [sp, #6]
    switch (state) {
   157ee:	b195      	cbz	r5, 15816 <DRV_ETHPHY_Detect+0x5c>
   157f0:	2d01      	cmp	r5, #1
   157f2:	d024      	beq.n	1583e <DRV_ETHPHY_Detect+0x84>
        ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->operRes = DRV_ETHPHY_RES_OK;
   157f4:	2700      	movs	r7, #0
   157f6:	f884 702c 	strb.w	r7, [r4, #44]	; 0x2c
        ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->miimOpHandle = 0;
   157fa:	61a7      	str	r7, [r4, #24]
        ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
   157fc:	86a7      	strh	r7, [r4, #52]	; 0x34
    clientObj.vendorData = F2R(state, VENDOR_STATE, clientObj.vendorData);
   157fe:	9901      	ldr	r1, [sp, #4]
   15800:	f421 017f 	bic.w	r1, r1, #16711680	; 0xff0000
   15804:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
   15808:	9101      	str	r1, [sp, #4]
    pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, clientObj.vendorData);
   1580a:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
   1580c:	4620      	mov	r0, r4
   1580e:	4798      	blx	r3
}
   15810:	4638      	mov	r0, r7
   15812:	b007      	add	sp, #28
   15814:	bdf0      	pop	{r4, r5, r6, r7, pc}
        miimRes = Lan867x_Read_Register(&clientObj, PHY_REG_PHYID1, &registerValue);
   15816:	f10d 0216 	add.w	r2, sp, #22
   1581a:	2102      	movs	r1, #2
   1581c:	4668      	mov	r0, sp
   1581e:	f008 fc02 	bl	1e026 <Lan867x_Read_Register>
        if (miimRes < 0) {
   15822:	2800      	cmp	r0, #0
   15824:	db21      	blt.n	1586a <DRV_ETHPHY_Detect+0xb0>
        } else if (miimRes != DRV_MIIM_RES_OK) {
   15826:	bb18      	cbnz	r0, 15870 <DRV_ETHPHY_Detect+0xb6>
            if (registerValue != (uint16_t)0x07) {
   15828:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   1582c:	2b07      	cmp	r3, #7
   1582e:	d121      	bne.n	15874 <DRV_ETHPHY_Detect+0xba>
                    F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj.vendorData);
   15830:	9b01      	ldr	r3, [sp, #4]
   15832:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
                clientObj.vendorData =
   15836:	9301      	str	r3, [sp, #4]
                res = DRV_ETHPHY_RES_PENDING;
   15838:	2701      	movs	r7, #1
                ++state;
   1583a:	463d      	mov	r5, r7
   1583c:	e7df      	b.n	157fe <DRV_ETHPHY_Detect+0x44>
        miimRes = Lan867x_Read_Register(&clientObj, PHY_REG_PHYID2, &registerValue);
   1583e:	f10d 0216 	add.w	r2, sp, #22
   15842:	2103      	movs	r1, #3
   15844:	4668      	mov	r0, sp
   15846:	f008 fbee 	bl	1e026 <Lan867x_Read_Register>
        if (miimRes < 0) {
   1584a:	2800      	cmp	r0, #0
   1584c:	db15      	blt.n	1587a <DRV_ETHPHY_Detect+0xc0>
        } else if (miimRes != DRV_MIIM_RES_OK) {
   1584e:	b9b8      	cbnz	r0, 15880 <DRV_ETHPHY_Detect+0xc6>
            if (registerValue != (uint16_t)0xC162) {
   15850:	f8bd 2016 	ldrh.w	r2, [sp, #22]
   15854:	f24c 1362 	movw	r3, #49506	; 0xc162
   15858:	429a      	cmp	r2, r3
   1585a:	d113      	bne.n	15884 <DRV_ETHPHY_Detect+0xca>
                    F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj.vendorData);
   1585c:	9b01      	ldr	r3, [sp, #4]
   1585e:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
                clientObj.vendorData =
   15862:	9301      	str	r3, [sp, #4]
                res = DRV_ETHPHY_RES_PENDING;
   15864:	2701      	movs	r7, #1
                ++state;
   15866:	2502      	movs	r5, #2
   15868:	e7c9      	b.n	157fe <DRV_ETHPHY_Detect+0x44>
            res = DRV_ETHPHY_RES_MIIM_ERR;
   1586a:	f06f 070c 	mvn.w	r7, #12
   1586e:	e7c6      	b.n	157fe <DRV_ETHPHY_Detect+0x44>
            res = DRV_ETHPHY_RES_PENDING;
   15870:	2701      	movs	r7, #1
   15872:	e7c4      	b.n	157fe <DRV_ETHPHY_Detect+0x44>
                res = DRV_ETHPHY_RES_CPBL_ERR;
   15874:	f06f 0702 	mvn.w	r7, #2
   15878:	e7c1      	b.n	157fe <DRV_ETHPHY_Detect+0x44>
            res = DRV_ETHPHY_RES_MIIM_ERR;
   1587a:	f06f 070c 	mvn.w	r7, #12
   1587e:	e7be      	b.n	157fe <DRV_ETHPHY_Detect+0x44>
            res = DRV_ETHPHY_RES_PENDING;
   15880:	2701      	movs	r7, #1
   15882:	e7bc      	b.n	157fe <DRV_ETHPHY_Detect+0x44>
                res = DRV_ETHPHY_RES_CPBL_ERR;
   15884:	f06f 0702 	mvn.w	r7, #2
   15888:	e7b9      	b.n	157fe <DRV_ETHPHY_Detect+0x44>

Disassembly of section .text.DRV_GMAC_PacketTx%314:

0001588c <DRV_GMAC_PacketTx>:
{
   1588c:	b538      	push	{r3, r4, r5, lr}
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1588e:	4b2e      	ldr	r3, [pc, #184]	; (15948 <DRV_GMAC_PacketTx+0xbc>)
   15890:	4283      	cmp	r3, r0
   15892:	d141      	bne.n	15918 <DRV_GMAC_PacketTx+0x8c>
   15894:	460c      	mov	r4, r1
    if(pMACDrv == 0)
   15896:	2800      	cmp	r0, #0
   15898:	d041      	beq.n	1591e <DRV_GMAC_PacketTx+0x92>
    if ((ptrPacket->pktPriority) >= DRV_GMAC_NUMBER_OF_QUEUES)
   1589a:	f891 302d 	ldrb.w	r3, [r1, #45]	; 0x2d
   1589e:	2b00      	cmp	r3, #0
   158a0:	d140      	bne.n	15924 <DRV_GMAC_PacketTx+0x98>
	queueIdx = (GMAC_QUE_LIST)(pMACDrv->sGmacData.gmacConfig.txPrioNumToQueIndx[ptrPacket->pktPriority]);
   158a2:	4b29      	ldr	r3, [pc, #164]	; (15948 <DRV_GMAC_PacketTx+0xbc>)
    else if(queueIdx >= DRV_GMAC_NUMBER_OF_QUEUES)
   158a4:	f893 30e3 	ldrb.w	r3, [r3, #227]	; 0xe3
   158a8:	3b01      	subs	r3, #1
   158aa:	b2db      	uxtb	r3, r3
   158ac:	2bfd      	cmp	r3, #253	; 0xfd
   158ae:	d93c      	bls.n	1592a <DRV_GMAC_PacketTx+0x9e>
	if(pMACDrv->sGmacData._synchF != 0)
   158b0:	4b25      	ldr	r3, [pc, #148]	; (15948 <DRV_GMAC_PacketTx+0xbc>)
   158b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   158b4:	2b00      	cmp	r3, #0
   158b6:	d040      	beq.n	1593a <DRV_GMAC_PacketTx+0xae>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_LOCK);
   158b8:	2103      	movs	r1, #3
   158ba:	4824      	ldr	r0, [pc, #144]	; (1594c <DRV_GMAC_PacketTx+0xc0>)
   158bc:	4798      	blx	r3
        if(pSeg == 0)
   158be:	6923      	ldr	r3, [r4, #16]
   158c0:	b16b      	cbz	r3, 158de <DRV_GMAC_PacketTx+0x52>
            DRV_PIC32CGMAC_SingleListTailAdd(&pMACDrv->sGmacData.gmac_queue[queueIdx]._TxQueue, (DRV_PIC32CGMAC_SGL_LIST_NODE*)ptrPacket);
   158c2:	4d23      	ldr	r5, [pc, #140]	; (15950 <DRV_GMAC_PacketTx+0xc4>)
   158c4:	4621      	mov	r1, r4
   158c6:	4628      	mov	r0, r5
   158c8:	f00b fc92 	bl	211f0 <DRV_PIC32CGMAC_SingleListTailAdd>
            ptrPacket->pktFlags |= TCPIP_MAC_PKT_FLAG_QUEUED;
   158cc:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   158ce:	f043 0308 	orr.w	r3, r3, #8
   158d2:	8463      	strh	r3, [r4, #34]	; 0x22
            ptrPacket = ptrPacket->next;
   158d4:	6824      	ldr	r4, [r4, #0]
	while(ptrPacket)
   158d6:	b15c      	cbz	r4, 158f0 <DRV_GMAC_PacketTx+0x64>
        if(pSeg == 0)
   158d8:	6923      	ldr	r3, [r4, #16]
   158da:	2b00      	cmp	r3, #0
   158dc:	d1f2      	bne.n	158c4 <DRV_GMAC_PacketTx+0x38>
	if(pMACDrv->sGmacData._synchF != 0)
   158de:	4b1a      	ldr	r3, [pc, #104]	; (15948 <DRV_GMAC_PacketTx+0xbc>)
   158e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   158e2:	b32b      	cbz	r3, 15930 <DRV_GMAC_PacketTx+0xa4>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_UNLOCK);
   158e4:	2104      	movs	r1, #4
   158e6:	4819      	ldr	r0, [pc, #100]	; (1594c <DRV_GMAC_PacketTx+0xc0>)
   158e8:	4798      	blx	r3
            return TCPIP_MAC_RES_PACKET_ERR;
   158ea:	f06f 0009 	mvn.w	r0, #9
   158ee:	e015      	b.n	1591c <DRV_GMAC_PacketTx+0x90>
	_MacTxPendingPackets(pMACDrv,queueIdx);
   158f0:	4c15      	ldr	r4, [pc, #84]	; (15948 <DRV_GMAC_PacketTx+0xbc>)
   158f2:	2100      	movs	r1, #0
   158f4:	4620      	mov	r0, r4
   158f6:	f004 fced 	bl	1a2d4 <_MacTxPendingPackets>
    GMAC_REGS->GMAC_TSR = GMAC_TSR_TXCOMP_Msk;
   158fa:	4b16      	ldr	r3, [pc, #88]	; (15954 <DRV_GMAC_PacketTx+0xc8>)
   158fc:	2220      	movs	r2, #32
   158fe:	615a      	str	r2, [r3, #20]
    DRV_PIC32CGMAC_LibTxAckPacket(pMACDrv,queueIdx);
   15900:	2100      	movs	r1, #0
   15902:	4620      	mov	r0, r4
   15904:	f7fb fd42 	bl	1138c <DRV_PIC32CGMAC_LibTxAckPacket>
	if(pMACDrv->sGmacData._synchF != 0)
   15908:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1590a:	b1a3      	cbz	r3, 15936 <DRV_GMAC_PacketTx+0xaa>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_UNLOCK);
   1590c:	2104      	movs	r1, #4
   1590e:	f104 0060 	add.w	r0, r4, #96	; 0x60
   15912:	4798      	blx	r3
	return TCPIP_MAC_RES_OK;
   15914:	2000      	movs	r0, #0
   15916:	e001      	b.n	1591c <DRV_GMAC_PacketTx+0x90>
        return TCPIP_MAC_RES_OP_ERR;
   15918:	f06f 0005 	mvn.w	r0, #5
}
   1591c:	bd38      	pop	{r3, r4, r5, pc}
        return TCPIP_MAC_RES_OP_ERR;
   1591e:	f06f 0005 	mvn.w	r0, #5
   15922:	e7fb      	b.n	1591c <DRV_GMAC_PacketTx+0x90>
        return TCPIP_MAC_RES_PACKET_ERR; 	        
   15924:	f06f 0009 	mvn.w	r0, #9
   15928:	e7f8      	b.n	1591c <DRV_GMAC_PacketTx+0x90>
        return TCPIP_MAC_RES_PACKET_ERR; 
   1592a:	f06f 0009 	mvn.w	r0, #9
   1592e:	e7f5      	b.n	1591c <DRV_GMAC_PacketTx+0x90>
            return TCPIP_MAC_RES_PACKET_ERR;
   15930:	f06f 0009 	mvn.w	r0, #9
   15934:	e7f2      	b.n	1591c <DRV_GMAC_PacketTx+0x90>
	return TCPIP_MAC_RES_OK;
   15936:	2000      	movs	r0, #0
   15938:	e7f0      	b.n	1591c <DRV_GMAC_PacketTx+0x90>
        if(pSeg == 0)
   1593a:	690b      	ldr	r3, [r1, #16]
   1593c:	2b00      	cmp	r3, #0
   1593e:	d1c0      	bne.n	158c2 <DRV_GMAC_PacketTx+0x36>
            return TCPIP_MAC_RES_PACKET_ERR;
   15940:	f06f 0009 	mvn.w	r0, #9
   15944:	e7ea      	b.n	1591c <DRV_GMAC_PacketTx+0x90>
   15946:	bf00      	nop
   15948:	2000d8b8 	.word	0x2000d8b8
   1594c:	2000d918 	.word	0x2000d918
   15950:	2000d95c 	.word	0x2000d95c
   15954:	42000800 	.word	0x42000800

Disassembly of section .text.TCPIP_TCP_ArrayGet%315:

00015958 <TCPIP_TCP_ArrayGet>:
{
   15958:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if(len == 0 || (pSkt= _TcpSocketChk(hTCP)) == 0 || (wGetReadyCount = _TCPIsGetReady(pSkt)) == 0)
   1595c:	4614      	mov	r4, r2
   1595e:	2a00      	cmp	r2, #0
   15960:	d05a      	beq.n	15a18 <TCPIP_TCP_ArrayGet+0xc0>
   15962:	4688      	mov	r8, r1
   15964:	f00a fa5a 	bl	1fe1c <_TcpSocketChk>
   15968:	4605      	mov	r5, r0
   1596a:	2800      	cmp	r0, #0
   1596c:	d051      	beq.n	15a12 <TCPIP_TCP_ArrayGet+0xba>
   1596e:	f00b f9ce 	bl	20d0e <_TCPIsGetReady>
   15972:	4607      	mov	r7, r0
   15974:	2800      	cmp	r0, #0
   15976:	d04e      	beq.n	15a16 <TCPIP_TCP_ArrayGet+0xbe>
	if(len > wGetReadyCount)
   15978:	4284      	cmp	r4, r0
   1597a:	bf28      	it	cs
   1597c:	4604      	movcs	r4, r0
   1597e:	b2a4      	uxth	r4, r4
	if(pSkt->rxTail + len > pSkt->rxEnd)
   15980:	6a29      	ldr	r1, [r5, #32]
   15982:	69ae      	ldr	r6, [r5, #24]
   15984:	190b      	adds	r3, r1, r4
   15986:	429e      	cmp	r6, r3
   15988:	d229      	bcs.n	159de <TCPIP_TCP_ArrayGet+0x86>
		RightLen = pSkt->rxEnd - pSkt->rxTail + 1;
   1598a:	1a76      	subs	r6, r6, r1
   1598c:	3601      	adds	r6, #1
   1598e:	b2b6      	uxth	r6, r6
		if(buffer)
   15990:	f1b8 0f00 	cmp.w	r8, #0
   15994:	d004      	beq.n	159a0 <TCPIP_TCP_ArrayGet+0x48>
			memcpy(buffer, (uint8_t*)pSkt->rxTail, RightLen);
   15996:	4632      	mov	r2, r6
   15998:	4640      	mov	r0, r8
   1599a:	f00b fbf1 	bl	21180 <memcpy>
			buffer += RightLen;
   1599e:	44b0      	add	r8, r6
		len -= RightLen;
   159a0:	1ba4      	subs	r4, r4, r6
   159a2:	b2a4      	uxth	r4, r4
		pSkt->rxTail = pSkt->rxStart;
   159a4:	696b      	ldr	r3, [r5, #20]
   159a6:	622b      	str	r3, [r5, #32]
	if(buffer)
   159a8:	f1b8 0f00 	cmp.w	r8, #0
   159ac:	d004      	beq.n	159b8 <TCPIP_TCP_ArrayGet+0x60>
		memcpy(buffer, (uint8_t*)pSkt->rxTail, len);
   159ae:	4622      	mov	r2, r4
   159b0:	6a29      	ldr	r1, [r5, #32]
   159b2:	4640      	mov	r0, r8
   159b4:	f00b fbe4 	bl	21180 <memcpy>
	pSkt->rxTail += len;
   159b8:	6a2b      	ldr	r3, [r5, #32]
   159ba:	4423      	add	r3, r4
   159bc:	622b      	str	r3, [r5, #32]
	len += RightLen;
   159be:	4434      	add	r4, r6
   159c0:	b2a4      	uxth	r4, r4
    if(!_TCPSendWinIncUpdate(pSkt))
   159c2:	4628      	mov	r0, r5
   159c4:	f007 fa24 	bl	1ce10 <_TCPSendWinIncUpdate>
   159c8:	bb30      	cbnz	r0, 15a18 <TCPIP_TCP_ArrayGet+0xc0>
        if(wGetReadyCount - len <= len)
   159ca:	1b3f      	subs	r7, r7, r4
   159cc:	42bc      	cmp	r4, r7
   159ce:	db08      	blt.n	159e2 <TCPIP_TCP_ArrayGet+0x8a>
            pSkt->Flags.bTXASAPWithoutTimerReset = 1;
   159d0:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
   159d4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   159d8:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
   159dc:	e01c      	b.n	15a18 <TCPIP_TCP_ArrayGet+0xc0>
	uint16_t RightLen = 0;
   159de:	2600      	movs	r6, #0
   159e0:	e7e2      	b.n	159a8 <TCPIP_TCP_ArrayGet+0x50>
        else if(!pSkt->Flags.bTimer2Enabled)
   159e2:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
   159e6:	f013 0f04 	tst.w	r3, #4
   159ea:	d115      	bne.n	15a18 <TCPIP_TCP_ArrayGet+0xc0>
            pSkt->Flags.bTimer2Enabled = true;
   159ec:	f043 0304 	orr.w	r3, r3, #4
   159f0:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
            pSkt->eventTime2 = SYS_TMR_TickCountGet() + (TCPIP_TCP_WINDOW_UPDATE_TIMEOUT_VAL * SYS_TMR_TickCounterFrequencyGet())/1000;
   159f4:	f00a fb7a 	bl	200ec <SYS_TMR_TickCountGet>
   159f8:	4606      	mov	r6, r0
   159fa:	f00a fb9f 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
   159fe:	23c8      	movs	r3, #200	; 0xc8
   15a00:	fb03 f300 	mul.w	r3, r3, r0
   15a04:	4806      	ldr	r0, [pc, #24]	; (15a20 <TCPIP_TCP_ArrayGet+0xc8>)
   15a06:	fba0 2303 	umull	r2, r3, r0, r3
   15a0a:	eb06 1393 	add.w	r3, r6, r3, lsr #6
   15a0e:	62ab      	str	r3, [r5, #40]	; 0x28
   15a10:	e002      	b.n	15a18 <TCPIP_TCP_ArrayGet+0xc0>
        return 0;
   15a12:	2400      	movs	r4, #0
   15a14:	e000      	b.n	15a18 <TCPIP_TCP_ArrayGet+0xc0>
   15a16:	4604      	mov	r4, r0
}
   15a18:	4620      	mov	r0, r4
   15a1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   15a1e:	bf00      	nop
   15a20:	10624dd3 	.word	0x10624dd3

Disassembly of section .text.TCPIP_HEAP_CreateInternal%316:

00015a24 <TCPIP_HEAP_CreateInternal>:
{
   15a24:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   15a28:	4688      	mov	r8, r1
        if( pHeapConfig == 0)
   15a2a:	2800      	cmp	r0, #0
   15a2c:	d04b      	beq.n	15ac6 <TCPIP_HEAP_CreateInternal+0xa2>
   15a2e:	4606      	mov	r6, r0
        heapBufferSize = pHeapConfig->heapSize;
   15a30:	6904      	ldr	r4, [r0, #16]
        allocatedHeapBuffer = (uint8_t*)(*pHeapConfig->malloc_fnc)(heapBufferSize);
   15a32:	6843      	ldr	r3, [r0, #4]
   15a34:	4620      	mov	r0, r4
   15a36:	4798      	blx	r3
        if(allocatedHeapBuffer == 0)
   15a38:	4607      	mov	r7, r0
   15a3a:	2800      	cmp	r0, #0
   15a3c:	d047      	beq.n	15ace <TCPIP_HEAP_CreateInternal+0xaa>
        alignBuffer = ((uintptr_t)allocatedHeapBuffer + sizeof(_heap_Align)-1 ) & ~(sizeof(_heap_Align)-1);
   15a3e:	300f      	adds	r0, #15
   15a40:	f020 000f 	bic.w	r0, r0, #15
        heapBufferSize -= (uint8_t*)alignBuffer - allocatedHeapBuffer ;
   15a44:	1bc1      	subs	r1, r0, r7
   15a46:	1a61      	subs	r1, r4, r1
        heapBufferSize &= ~(sizeof(_heap_Align)-1) ;
   15a48:	f021 010f 	bic.w	r1, r1, #15
        heapSize = heapBufferSize - headerSize;
   15a4c:	f1a1 0950 	sub.w	r9, r1, #80	; 0x50
        if(heapUnits < _TCPIP_HEAP_MIN_BLKS_)
   15a50:	f5b9 6f80 	cmp.w	r9, #1024	; 0x400
   15a54:	d33f      	bcc.n	15ad6 <TCPIP_HEAP_CreateInternal+0xb2>
        heapUnits = heapSize / sizeof(_headNode);           // adjust to multiple of heads
   15a56:	ea4f 1919 	mov.w	r9, r9, lsr #4
            alignHeapBuffer = (uint8_t*)_TCPIP_HEAP_BufferMapNonCached(alignHeapBuffer, heapBufferSize);
   15a5a:	f7fd f810 	bl	12a7e <_TCPIP_HEAP_BufferMapNonCached>
   15a5e:	4604      	mov	r4, r0
        heapStart = alignHeapBuffer + headerSize; 
   15a60:	f100 0e50 	add.w	lr, r0, #80	; 0x50
        hInst->heapObj = _tcpip_heap_object;
   15a64:	4605      	mov	r5, r0
   15a66:	f8df c084 	ldr.w	ip, [pc, #132]	; 15aec <TCPIP_HEAP_CreateInternal+0xc8>
   15a6a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   15a6e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   15a70:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   15a74:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   15a76:	f8dc 3000 	ldr.w	r3, [ip]
   15a7a:	602b      	str	r3, [r5, #0]
        hDcpt->_heapHead = (_headNode*)heapStart;
   15a7c:	f8c4 e024 	str.w	lr, [r4, #36]	; 0x24
        hDcpt->_heapHead->units = heapUnits;
   15a80:	f8c4 9054 	str.w	r9, [r4, #84]	; 0x54
        hDcpt->_heapHead->next = 0;
   15a84:	2100      	movs	r1, #0
   15a86:	6521      	str	r1, [r4, #80]	; 0x50
        hDcpt->_heapTail = hDcpt->_heapHead;
   15a88:	f8c4 e028 	str.w	lr, [r4, #40]	; 0x28
        hDcpt->_heapUnits = heapUnits;
   15a8c:	f8c4 902c 	str.w	r9, [r4, #44]	; 0x2c
        hDcpt->_heapAllocatedUnits = 0;
   15a90:	6321      	str	r1, [r4, #48]	; 0x30
        hDcpt->_heapWatermark = 0;
   15a92:	6361      	str	r1, [r4, #52]	; 0x34
        hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_OK;
   15a94:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
        hDcpt->_heapFlags = pHeapConfig->heapFlags;
   15a98:	7873      	ldrb	r3, [r6, #1]
   15a9a:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
        hDcpt->allocatedBuffer = allocatedHeapBuffer;
   15a9e:	63e7      	str	r7, [r4, #60]	; 0x3c
        hDcpt->free_fnc = pHeapConfig->free_fnc;
   15aa0:	68f3      	ldr	r3, [r6, #12]
   15aa2:	6423      	str	r3, [r4, #64]	; 0x40
        if(OSAL_SEM_Create(&hDcpt->_heapSemaphore, OSAL_SEM_TYPE_BINARY, 1, 1) != OSAL_RESULT_TRUE)
   15aa4:	2301      	movs	r3, #1
   15aa6:	461a      	mov	r2, r3
   15aa8:	f104 0044 	add.w	r0, r4, #68	; 0x44
   15aac:	f006 f9e2 	bl	1be74 <OSAL_SEM_Create>
   15ab0:	2801      	cmp	r0, #1
   15ab2:	d101      	bne.n	15ab8 <TCPIP_HEAP_CreateInternal+0x94>
        res = TCPIP_STACK_HEAP_RES_OK;
   15ab4:	2300      	movs	r3, #0
   15ab6:	e011      	b.n	15adc <TCPIP_HEAP_CreateInternal+0xb8>
            (*pHeapConfig->free_fnc)(allocatedHeapBuffer);
   15ab8:	68f3      	ldr	r3, [r6, #12]
   15aba:	4638      	mov	r0, r7
   15abc:	4798      	blx	r3
            res = TCPIP_STACK_HEAP_RES_SYNCH_ERR;
   15abe:	f06f 0302 	mvn.w	r3, #2
            hInst = 0;
   15ac2:	2400      	movs	r4, #0
            break;
   15ac4:	e00a      	b.n	15adc <TCPIP_HEAP_CreateInternal+0xb8>
        hInst = 0;
   15ac6:	4604      	mov	r4, r0
            res = TCPIP_STACK_HEAP_RES_INIT_ERR;
   15ac8:	f04f 33ff 	mov.w	r3, #4294967295
   15acc:	e006      	b.n	15adc <TCPIP_HEAP_CreateInternal+0xb8>
        hInst = 0;
   15ace:	4604      	mov	r4, r0
            res = TCPIP_STACK_HEAP_RES_CREATE_ERR;
   15ad0:	f06f 0301 	mvn.w	r3, #1
   15ad4:	e002      	b.n	15adc <TCPIP_HEAP_CreateInternal+0xb8>
            res = TCPIP_STACK_HEAP_RES_BUFF_SIZE_ERR;
   15ad6:	f06f 0303 	mvn.w	r3, #3
        hInst = 0;
   15ada:	2400      	movs	r4, #0
    if(pRes)
   15adc:	f1b8 0f00 	cmp.w	r8, #0
   15ae0:	d001      	beq.n	15ae6 <TCPIP_HEAP_CreateInternal+0xc2>
        *pRes = res;
   15ae2:	f888 3000 	strb.w	r3, [r8]
}
   15ae6:	4620      	mov	r0, r4
   15ae8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   15aec:	000204a8 	.word	0x000204a8

Disassembly of section .text.DRV_PIC32CGMAC_LibRxInit%317:

00015af0 <DRV_PIC32CGMAC_LibRxInit>:
{	   
   15af0:	b510      	push	{r4, lr}
   15af2:	4604      	mov	r4, r0
}DRV_PIC32CGMAC_SGL_LIST;	// single linked list

//Initialize Single List
static  __inline__ void  __attribute__((always_inline)) DRV_PIC32CGMAC_SingleListInitialize(DRV_PIC32CGMAC_SGL_LIST* pL)
{
    pL->head = pL->tail = 0;
   15af4:	2300      	movs	r3, #0
   15af6:	f8c0 3098 	str.w	r3, [r0, #152]	; 0x98
   15afa:	f8c0 3094 	str.w	r3, [r0, #148]	; 0x94
    pL->nNodes = 0;
   15afe:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
        pRxPcktAlloc = (*pMACDrv->sGmacData._callocF)(pMACDrv->sGmacData._AllocH,pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt, sizeof(TCPIP_MAC_PACKET *));
   15b02:	69c3      	ldr	r3, [r0, #28]
   15b04:	2204      	movs	r2, #4
   15b06:	f8b0 10be 	ldrh.w	r1, [r0, #190]	; 0xbe
   15b0a:	6980      	ldr	r0, [r0, #24]
   15b0c:	4798      	blx	r3
		if(pRxPcktAlloc == NULL)
   15b0e:	2800      	cmp	r0, #0
   15b10:	d04c      	beq.n	15bac <DRV_PIC32CGMAC_LibRxInit+0xbc>
        (pMACDrv->sGmacData.gmac_queue[queue_idx].pRxPckt) = pRxPcktAlloc;
   15b12:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
		for(desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt; desc_idx++)
   15b16:	f8b4 30be 	ldrh.w	r3, [r4, #190]	; 0xbe
   15b1a:	2b00      	cmp	r3, #0
   15b1c:	d044      	beq.n	15ba8 <DRV_PIC32CGMAC_LibRxInit+0xb8>
   15b1e:	2300      	movs	r3, #0
            pMACDrv->sGmacData.gmac_queue[queue_idx].nRxDescIndex = 0;
   15b20:	461a      	mov	r2, r3
   15b22:	f8a4 20b0 	strh.w	r2, [r4, #176]	; 0xb0
			pMACDrv->sGmacData.gmac_queue[queue_idx].pRxPckt[desc_idx] = 0;
   15b26:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
   15b2a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
			pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc[desc_idx].rx_desc_buffaddr.val = 0;
   15b2e:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
   15b32:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
			pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc[desc_idx].rx_desc_status.val = 0;
   15b36:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
   15b3a:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
   15b3e:	604a      	str	r2, [r1, #4]
		for(desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt; desc_idx++)
   15b40:	3301      	adds	r3, #1
   15b42:	b2db      	uxtb	r3, r3
   15b44:	f8b4 10be 	ldrh.w	r1, [r4, #190]	; 0xbe
   15b48:	4299      	cmp	r1, r3
   15b4a:	d8ea      	bhi.n	15b22 <DRV_PIC32CGMAC_LibRxInit+0x32>
		pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc[desc_idx-1].rx_desc_buffaddr.val |= GMAC_RX_WRAP_BIT;
   15b4c:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
   15b50:	3b01      	subs	r3, #1
   15b52:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
   15b56:	f851 2033 	ldr.w	r2, [r1, r3, lsl #3]
   15b5a:	f042 0202 	orr.w	r2, r2, #2
   15b5e:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
        gmacRes = _AllocateRxPacket(pMACDrv, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDedicatedBuffers, queue_idx, GMAC_RX_STICKY_BUFFERS);	
   15b62:	2301      	movs	r3, #1
   15b64:	2200      	movs	r2, #0
   15b66:	f8b4 10c0 	ldrh.w	r1, [r4, #192]	; 0xc0
   15b6a:	4620      	mov	r0, r4
   15b6c:	f004 fe1c 	bl	1a7a8 <_AllocateRxPacket>
        if(gmacRes != DRV_PIC32CGMAC_RES_OK)
   15b70:	4603      	mov	r3, r0
   15b72:	b9b8      	cbnz	r0, 15ba4 <DRV_PIC32CGMAC_LibRxInit+0xb4>
		gmacRes = _AllocateRxPacket(pMACDrv, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxAddlBuffCount, queue_idx, GMAC_RX_DYNAMIC_BUFFERS);	
   15b74:	2300      	movs	r3, #0
   15b76:	461a      	mov	r2, r3
   15b78:	f8b4 10c2 	ldrh.w	r1, [r4, #194]	; 0xc2
   15b7c:	4620      	mov	r0, r4
   15b7e:	f004 fe13 	bl	1a7a8 <_AllocateRxPacket>
        if(gmacRes != DRV_PIC32CGMAC_RES_OK)
   15b82:	4603      	mov	r3, r0
   15b84:	b970      	cbnz	r0, 15ba4 <DRV_PIC32CGMAC_LibRxInit+0xb4>
		gmacRes = DRV_PIC32CGMAC_LibRxBuffersAppend(pMACDrv, queue_idx,0,pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt);		
   15b86:	f8b4 30be 	ldrh.w	r3, [r4, #190]	; 0xbe
   15b8a:	2200      	movs	r2, #0
   15b8c:	4611      	mov	r1, r2
   15b8e:	4620      	mov	r0, r4
   15b90:	f7fd fae6 	bl	13160 <DRV_PIC32CGMAC_LibRxBuffersAppend>
		if(gmacRes != DRV_PIC32CGMAC_RES_OK)
   15b94:	4603      	mov	r3, r0
   15b96:	b928      	cbnz	r0, 15ba4 <DRV_PIC32CGMAC_LibRxInit+0xb4>
		GMAC_REGS->GMAC_RBQB = GMAC_RBQB_ADDR_Msk & ((uint32_t)pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc);
   15b98:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
   15b9c:	f022 0203 	bic.w	r2, r2, #3
   15ba0:	4904      	ldr	r1, [pc, #16]	; (15bb4 <DRV_PIC32CGMAC_LibRxInit+0xc4>)
   15ba2:	618a      	str	r2, [r1, #24]
}//DRV_PIC32CGMAC_LibRxInit
   15ba4:	4618      	mov	r0, r3
   15ba6:	bd10      	pop	{r4, pc}
		for(desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt; desc_idx++)
   15ba8:	2300      	movs	r3, #0
   15baa:	e7cf      	b.n	15b4c <DRV_PIC32CGMAC_LibRxInit+0x5c>
			gmacRes = DRV_PIC32CGMAC_RES_OUT_OF_MEMORY;
   15bac:	f04f 33ff 	mov.w	r3, #4294967295
   15bb0:	e7f8      	b.n	15ba4 <DRV_PIC32CGMAC_LibRxInit+0xb4>
   15bb2:	bf00      	nop
   15bb4:	42000800 	.word	0x42000800

Disassembly of section .text._Command_DNSAddressSet%318:

00015bb8 <_Command_DNSAddressSet>:
{
   15bb8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15bbc:	b082      	sub	sp, #8
   15bbe:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   15bc0:	6845      	ldr	r5, [r0, #4]
    if (argc != 4)
   15bc2:	2904      	cmp	r1, #4
   15bc4:	d010      	beq.n	15be8 <_Command_DNSAddressSet+0x30>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: setdns 1/2 <interface> <x.x.x.x> \r\n");
   15bc6:	4e28      	ldr	r6, [pc, #160]	; (15c68 <_Command_DNSAddressSet+0xb0>)
   15bc8:	6803      	ldr	r3, [r0, #0]
   15bca:	681b      	ldr	r3, [r3, #0]
   15bcc:	f606 7104 	addw	r1, r6, #3844	; 0xf04
   15bd0:	4628      	mov	r0, r5
   15bd2:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: setdns 1 eth0 255.255.255.0 \r\n");
   15bd4:	6823      	ldr	r3, [r4, #0]
   15bd6:	681b      	ldr	r3, [r3, #0]
   15bd8:	f506 6173 	add.w	r1, r6, #3888	; 0xf30
   15bdc:	4628      	mov	r0, r5
   15bde:	4798      	blx	r3
        return false;
   15be0:	2000      	movs	r0, #0
}
   15be2:	b002      	add	sp, #8
   15be4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   15be8:	4616      	mov	r6, r2
    int dnsIx = atoi(argv[1]);
   15bea:	6850      	ldr	r0, [r2, #4]
   15bec:	f00c fb08 	bl	22200 <atoi>
   15bf0:	4607      	mov	r7, r0
    if(dnsIx != 1 && dnsIx != 2)
   15bf2:	1e43      	subs	r3, r0, #1
   15bf4:	2b01      	cmp	r3, #1
   15bf6:	d906      	bls.n	15c06 <_Command_DNSAddressSet+0x4e>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown DNS index\r\n");
   15bf8:	6823      	ldr	r3, [r4, #0]
   15bfa:	681b      	ldr	r3, [r3, #0]
   15bfc:	491b      	ldr	r1, [pc, #108]	; (15c6c <_Command_DNSAddressSet+0xb4>)
   15bfe:	4628      	mov	r0, r5
   15c00:	4798      	blx	r3
        return false;
   15c02:	2000      	movs	r0, #0
   15c04:	e7ed      	b.n	15be2 <_Command_DNSAddressSet+0x2a>
    netH = TCPIP_STACK_NetHandleGet(argv[2]);
   15c06:	68b0      	ldr	r0, [r6, #8]
   15c08:	f007 ffd4 	bl	1dbb4 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
   15c0c:	4680      	mov	r8, r0
   15c0e:	b1c0      	cbz	r0, 15c42 <_Command_DNSAddressSet+0x8a>
    if (!TCPIP_Helper_StringToIPAddress(argv[3], &ipDNS))
   15c10:	a901      	add	r1, sp, #4
   15c12:	68f0      	ldr	r0, [r6, #12]
   15c14:	f7fd fc54 	bl	134c0 <TCPIP_Helper_StringToIPAddress>
   15c18:	b1d0      	cbz	r0, 15c50 <_Command_DNSAddressSet+0x98>
    bool res = dnsIx == 1 ? TCPIP_STACK_NetAddressDnsPrimarySet(netH, &ipDNS) : TCPIP_STACK_NetAddressDnsSecondSet(netH, &ipDNS); 
   15c1a:	2f01      	cmp	r7, #1
   15c1c:	d01f      	beq.n	15c5e <_Command_DNSAddressSet+0xa6>
   15c1e:	a901      	add	r1, sp, #4
   15c20:	4640      	mov	r0, r8
   15c22:	f00b f9cd 	bl	20fc0 <TCPIP_STACK_NetAddressDnsSecondSet>
    (*pCmdIO->pCmdApi->print)(cmdIoParam, "Set DNS %d address %s\r\n", dnsIx, res ? "success" : "failed");
   15c26:	6823      	ldr	r3, [r4, #0]
   15c28:	685c      	ldr	r4, [r3, #4]
   15c2a:	2800      	cmp	r0, #0
   15c2c:	4b10      	ldr	r3, [pc, #64]	; (15c70 <_Command_DNSAddressSet+0xb8>)
   15c2e:	f103 0208 	add.w	r2, r3, #8
   15c32:	bf08      	it	eq
   15c34:	4613      	moveq	r3, r2
   15c36:	463a      	mov	r2, r7
   15c38:	490e      	ldr	r1, [pc, #56]	; (15c74 <_Command_DNSAddressSet+0xbc>)
   15c3a:	4628      	mov	r0, r5
   15c3c:	47a0      	blx	r4
    return true;
   15c3e:	2001      	movs	r0, #1
   15c40:	e7cf      	b.n	15be2 <_Command_DNSAddressSet+0x2a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   15c42:	6823      	ldr	r3, [r4, #0]
   15c44:	681b      	ldr	r3, [r3, #0]
   15c46:	490c      	ldr	r1, [pc, #48]	; (15c78 <_Command_DNSAddressSet+0xc0>)
   15c48:	4628      	mov	r0, r5
   15c4a:	4798      	blx	r3
        return false;
   15c4c:	2000      	movs	r0, #0
   15c4e:	e7c8      	b.n	15be2 <_Command_DNSAddressSet+0x2a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Invalid IP address string \r\n");
   15c50:	6823      	ldr	r3, [r4, #0]
   15c52:	681b      	ldr	r3, [r3, #0]
   15c54:	4909      	ldr	r1, [pc, #36]	; (15c7c <_Command_DNSAddressSet+0xc4>)
   15c56:	4628      	mov	r0, r5
   15c58:	4798      	blx	r3
        return false;
   15c5a:	2000      	movs	r0, #0
   15c5c:	e7c1      	b.n	15be2 <_Command_DNSAddressSet+0x2a>
    bool res = dnsIx == 1 ? TCPIP_STACK_NetAddressDnsPrimarySet(netH, &ipDNS) : TCPIP_STACK_NetAddressDnsSecondSet(netH, &ipDNS); 
   15c5e:	a901      	add	r1, sp, #4
   15c60:	4640      	mov	r0, r8
   15c62:	f00b f99f 	bl	20fa4 <TCPIP_STACK_NetAddressDnsPrimarySet>
   15c66:	e7de      	b.n	15c26 <_Command_DNSAddressSet+0x6e>
   15c68:	0000028c 	.word	0x0000028c
   15c6c:	000011e0 	.word	0x000011e0
   15c70:	00001180 	.word	0x00001180
   15c74:	000011f4 	.word	0x000011f4
   15c78:	00000da8 	.word	0x00000da8
   15c7c:	0000103c 	.word	0x0000103c

Disassembly of section .text.gfx_mono_generic_draw_horizontal_line%319:

00015c80 <gfx_mono_generic_draw_horizontal_line>:
        gfx_coord_t length, enum gfx_mono_color color) {
    uint8_t page;
    uint8_t pixelmask;
    uint8_t temp;

    if (x > GFX_MONO_LCD_WIDTH) {
   15c80:	2880      	cmp	r0, #128	; 0x80
   15c82:	d860      	bhi.n	15d46 <gfx_mono_generic_draw_horizontal_line+0xc6>
        gfx_coord_t length, enum gfx_mono_color color) {
   15c84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15c88:	4606      	mov	r6, r0
        return;
    }

    /* Clip line length if too long */
    if (x + length > GFX_MONO_LCD_WIDTH) {
   15c8a:	4410      	add	r0, r2
   15c8c:	2880      	cmp	r0, #128	; 0x80
        length = GFX_MONO_LCD_WIDTH - x;
   15c8e:	bfc4      	itt	gt
   15c90:	f1c6 0480 	rsbgt	r4, r6, #128	; 0x80
   15c94:	b2e2      	uxtbgt	r2, r4
    }

    page = y / 8;
    pixelmask = (1 << (y - (page * 8)));

    if (length == 0) {
   15c96:	b382      	cbz	r2, 15cfa <gfx_mono_generic_draw_horizontal_line+0x7a>
    page = y / 8;
   15c98:	08cd      	lsrs	r5, r1, #3
    pixelmask = (1 << (y - (page * 8)));
   15c9a:	eba1 01c5 	sub.w	r1, r1, r5, lsl #3
   15c9e:	2701      	movs	r7, #1
   15ca0:	fa07 f101 	lsl.w	r1, r7, r1
   15ca4:	b2cf      	uxtb	r7, r1
        /* Nothing to do. Move along. */
        return;
    }

    switch (color) {
   15ca6:	2b01      	cmp	r3, #1
   15ca8:	d009      	beq.n	15cbe <gfx_mono_generic_draw_horizontal_line+0x3e>
   15caa:	b258      	sxtb	r0, r3
   15cac:	b168      	cbz	r0, 15cca <gfx_mono_generic_draw_horizontal_line+0x4a>
   15cae:	2b02      	cmp	r3, #2
   15cb0:	d123      	bne.n	15cfa <gfx_mono_generic_draw_horizontal_line+0x7a>
   15cb2:	1e73      	subs	r3, r6, #1
   15cb4:	18d4      	adds	r4, r2, r3
   15cb6:	b2e4      	uxtb	r4, r4

        case GFX_PIXEL_XOR:
            while (length-- > 0) {
                temp = gfx_mono_get_byte(page, x + length);
                temp ^= pixelmask;
                gfx_mono_put_byte(page, x + length, temp);
   15cb8:	f04f 0800 	mov.w	r8, #0
   15cbc:	e032      	b.n	15d24 <gfx_mono_generic_draw_horizontal_line+0xa4>
   15cbe:	1e73      	subs	r3, r6, #1
   15cc0:	18d4      	adds	r4, r2, r3
   15cc2:	b2e4      	uxtb	r4, r4
                gfx_mono_put_byte(page, x + length, temp);
   15cc4:	f04f 0800 	mov.w	r8, #0
   15cc8:	e007      	b.n	15cda <gfx_mono_generic_draw_horizontal_line+0x5a>
   15cca:	1e74      	subs	r4, r6, #1
   15ccc:	4414      	add	r4, r2
   15cce:	b2e4      	uxtb	r4, r4
                temp &= ~pixelmask;
   15cd0:	43cf      	mvns	r7, r1
                gfx_mono_put_byte(page, x + length, temp);
   15cd2:	f04f 0800 	mov.w	r8, #0
   15cd6:	e013      	b.n	15d00 <gfx_mono_generic_draw_horizontal_line+0x80>
   15cd8:	461c      	mov	r4, r3
                temp = gfx_mono_get_byte(page, x + length);
   15cda:	4621      	mov	r1, r4
   15cdc:	4628      	mov	r0, r5
   15cde:	f00c fa8b 	bl	221f8 <gfx_mono_ssd1306_get_byte>
                temp |= pixelmask;
   15ce2:	ea47 0200 	orr.w	r2, r7, r0
                gfx_mono_put_byte(page, x + length, temp);
   15ce6:	4643      	mov	r3, r8
   15ce8:	b2d2      	uxtb	r2, r2
   15cea:	4621      	mov	r1, r4
   15cec:	4628      	mov	r0, r5
   15cee:	f007 fd39 	bl	1d764 <gfx_mono_ssd1306_put_byte>
   15cf2:	1e63      	subs	r3, r4, #1
   15cf4:	b2db      	uxtb	r3, r3
            while (length-- > 0) {
   15cf6:	42a6      	cmp	r6, r4
   15cf8:	d1ee      	bne.n	15cd8 <gfx_mono_generic_draw_horizontal_line+0x58>
            break;

        default:
            break;
    }
}
   15cfa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   15cfe:	461c      	mov	r4, r3
                temp = gfx_mono_get_byte(page, x + length);
   15d00:	4621      	mov	r1, r4
   15d02:	4628      	mov	r0, r5
   15d04:	f00c fa78 	bl	221f8 <gfx_mono_ssd1306_get_byte>
                temp &= ~pixelmask;
   15d08:	ea07 0200 	and.w	r2, r7, r0
                gfx_mono_put_byte(page, x + length, temp);
   15d0c:	4643      	mov	r3, r8
   15d0e:	b2d2      	uxtb	r2, r2
   15d10:	4621      	mov	r1, r4
   15d12:	4628      	mov	r0, r5
   15d14:	f007 fd26 	bl	1d764 <gfx_mono_ssd1306_put_byte>
   15d18:	1e63      	subs	r3, r4, #1
   15d1a:	b2db      	uxtb	r3, r3
            while (length-- > 0) {
   15d1c:	42a6      	cmp	r6, r4
   15d1e:	d1ee      	bne.n	15cfe <gfx_mono_generic_draw_horizontal_line+0x7e>
   15d20:	e7eb      	b.n	15cfa <gfx_mono_generic_draw_horizontal_line+0x7a>
   15d22:	461c      	mov	r4, r3
                temp = gfx_mono_get_byte(page, x + length);
   15d24:	4621      	mov	r1, r4
   15d26:	4628      	mov	r0, r5
   15d28:	f00c fa66 	bl	221f8 <gfx_mono_ssd1306_get_byte>
                temp ^= pixelmask;
   15d2c:	ea87 0200 	eor.w	r2, r7, r0
                gfx_mono_put_byte(page, x + length, temp);
   15d30:	4643      	mov	r3, r8
   15d32:	b2d2      	uxtb	r2, r2
   15d34:	4621      	mov	r1, r4
   15d36:	4628      	mov	r0, r5
   15d38:	f007 fd14 	bl	1d764 <gfx_mono_ssd1306_put_byte>
   15d3c:	1e63      	subs	r3, r4, #1
   15d3e:	b2db      	uxtb	r3, r3
            while (length-- > 0) {
   15d40:	42b4      	cmp	r4, r6
   15d42:	d1ee      	bne.n	15d22 <gfx_mono_generic_draw_horizontal_line+0xa2>
   15d44:	e7d9      	b.n	15cfa <gfx_mono_generic_draw_horizontal_line+0x7a>
   15d46:	4770      	bx	lr

Disassembly of section .text.__mdiff%320:

00015d48 <__mdiff>:
   15d48:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15d4c:	460d      	mov	r5, r1
   15d4e:	4607      	mov	r7, r0
   15d50:	4611      	mov	r1, r2
   15d52:	4628      	mov	r0, r5
   15d54:	4614      	mov	r4, r2
   15d56:	f009 f8b7 	bl	1eec8 <__mcmp>
   15d5a:	1e06      	subs	r6, r0, #0
   15d5c:	d108      	bne.n	15d70 <__mdiff+0x28>
   15d5e:	4631      	mov	r1, r6
   15d60:	4638      	mov	r0, r7
   15d62:	f005 f947 	bl	1aff4 <_Balloc>
   15d66:	2301      	movs	r3, #1
   15d68:	e9c0 3604 	strd	r3, r6, [r0, #16]
   15d6c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15d70:	bfa4      	itt	ge
   15d72:	4623      	movge	r3, r4
   15d74:	462c      	movge	r4, r5
   15d76:	4638      	mov	r0, r7
   15d78:	6861      	ldr	r1, [r4, #4]
   15d7a:	bfa6      	itte	ge
   15d7c:	461d      	movge	r5, r3
   15d7e:	2600      	movge	r6, #0
   15d80:	2601      	movlt	r6, #1
   15d82:	f005 f937 	bl	1aff4 <_Balloc>
   15d86:	692b      	ldr	r3, [r5, #16]
   15d88:	6927      	ldr	r7, [r4, #16]
   15d8a:	60c6      	str	r6, [r0, #12]
   15d8c:	f104 0214 	add.w	r2, r4, #20
   15d90:	f105 0614 	add.w	r6, r5, #20
   15d94:	eb02 0887 	add.w	r8, r2, r7, lsl #2
   15d98:	eb06 0e83 	add.w	lr, r6, r3, lsl #2
   15d9c:	f100 0514 	add.w	r5, r0, #20
   15da0:	f04f 0a00 	mov.w	sl, #0
   15da4:	f64f 79ff 	movw	r9, #65535	; 0xffff
   15da8:	f852 bb04 	ldr.w	fp, [r2], #4
   15dac:	f856 3b04 	ldr.w	r3, [r6], #4
   15db0:	fa1a fa8b 	uxtah	sl, sl, fp
   15db4:	ea03 0109 	and.w	r1, r3, r9
   15db8:	0c1b      	lsrs	r3, r3, #16
   15dba:	ebaa 0101 	sub.w	r1, sl, r1
   15dbe:	ebc3 431b 	rsb	r3, r3, fp, lsr #16
   15dc2:	eb03 4321 	add.w	r3, r3, r1, asr #16
   15dc6:	ea01 0109 	and.w	r1, r1, r9
   15dca:	ea4f 4a23 	mov.w	sl, r3, asr #16
   15dce:	45b6      	cmp	lr, r6
   15dd0:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
   15dd4:	4694      	mov	ip, r2
   15dd6:	f845 3b04 	str.w	r3, [r5], #4
   15dda:	d8e5      	bhi.n	15da8 <__mdiff+0x60>
   15ddc:	f64f 74ff 	movw	r4, #65535	; 0xffff
   15de0:	45c4      	cmp	ip, r8
   15de2:	d304      	bcc.n	15dee <__mdiff+0xa6>
   15de4:	f855 3d04 	ldr.w	r3, [r5, #-4]!
   15de8:	b183      	cbz	r3, 15e0c <__mdiff+0xc4>
   15dea:	6107      	str	r7, [r0, #16]
   15dec:	e7be      	b.n	15d6c <__mdiff+0x24>
   15dee:	f85c 1b04 	ldr.w	r1, [ip], #4
   15df2:	fa1a f381 	uxtah	r3, sl, r1
   15df6:	141a      	asrs	r2, r3, #16
   15df8:	eb02 4211 	add.w	r2, r2, r1, lsr #16
   15dfc:	4023      	ands	r3, r4
   15dfe:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   15e02:	ea4f 4a22 	mov.w	sl, r2, asr #16
   15e06:	f845 3b04 	str.w	r3, [r5], #4
   15e0a:	e7e9      	b.n	15de0 <__mdiff+0x98>
   15e0c:	3f01      	subs	r7, #1
   15e0e:	e7e9      	b.n	15de4 <__mdiff+0x9c>

Disassembly of section .rodata.__mprec_tens%321:

00015e10 <__mprec_tens>:
   15e10:	0000 0000 0000 3ff0 0000 0000 0000 4024     .......?......$@
   15e20:	0000 0000 0000 4059 0000 0000 4000 408f     ......Y@.....@.@
   15e30:	0000 0000 8800 40c3 0000 0000 6a00 40f8     .......@.....j.@
   15e40:	0000 0000 8480 412e 0000 0000 12d0 4163     .......A......cA
   15e50:	0000 0000 d784 4197 0000 0000 cd65 41cd     .......A....e..A
   15e60:	0000 2000 a05f 4202 0000 e800 4876 4237     ... _..B....vH7B
   15e70:	0000 a200 1a94 426d 0000 e540 309c 42a2     ......mB..@..0.B
   15e80:	0000 1e90 bcc4 42d6 0000 2634 6bf5 430c     .......B..4&.k.C
   15e90:	8000 37e0 c379 4341 a000 85d8 3457 4376     ...7y.AC....W4vC
   15ea0:	c800 674e c16d 43ab 3d00 6091 58e4 43e1     ..Ngm..C.=.`.X.C
   15eb0:	8c40 78b5 af1d 4415 ef50 d6e2 1ae4 444b     @..x...DP.....KD
   15ec0:	d592 064d f0cf 4480 4af6 c7e1 2d02 44b5     ..M....D.J...-.D
   15ed0:	9db4 79d9 7843 44ea                         ...yCx.D

Disassembly of section .text._DRV_MIIM_StartOp%322:

00015ed8 <_DRV_MIIM_StartOp>:
{
   15ed8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15edc:	460f      	mov	r7, r1
   15ede:	4690      	mov	r8, r2
   15ee0:	469a      	mov	sl, r3
   15ee2:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   15ee4:	f89d 9030 	ldrb.w	r9, [sp, #48]	; 0x30
        if((pClient = _DRV_MIIM_GetClientAndLock(handle, true)) == 0)
   15ee8:	2101      	movs	r1, #1
   15eea:	f006 fcc6 	bl	1c87a <_DRV_MIIM_GetClientAndLock>
   15eee:	b3c8      	cbz	r0, 15f64 <_DRV_MIIM_StartOp+0x8c>
   15ef0:	4606      	mov	r6, r0
        pMiimObj = pClient->parentObj;
   15ef2:	6844      	ldr	r4, [r0, #4]
        if(pSchedData->regIx > DRV_MIIM_MAX_REG_INDEX_VALUE)
   15ef4:	2f1f      	cmp	r7, #31
   15ef6:	d839      	bhi.n	15f6c <_DRV_MIIM_StartOp+0x94>
        if(pSchedData->phyAdd > DRV_MIIM_MAX_ADDRESS_VALUE)
   15ef8:	f1b8 0f1f 	cmp.w	r8, #31
   15efc:	d83e      	bhi.n	15f7c <_DRV_MIIM_StartOp+0xa4>
        if((pMiimObj->objFlags & DRV_MIIM_OBJ_FLAG_SETUP_DONE) == 0)
   15efe:	88a3      	ldrh	r3, [r4, #4]
   15f00:	f013 0f02 	tst.w	r3, #2
   15f04:	d03d      	beq.n	15f82 <_DRV_MIIM_StartOp+0xaa>
        if((pMiimObj->objFlags & DRV_MIIM_OBJ_FLAG_IS_SCANNING) != 0)
   15f06:	f013 0f08 	tst.w	r3, #8
   15f0a:	d002      	beq.n	15f12 <_DRV_MIIM_StartOp+0x3a>
            res = DRV_MIIM_RES_OP_SCAN_ERR;
   15f0c:	f06f 0607 	mvn.w	r6, #7
   15f10:	e039      	b.n	15f86 <_DRV_MIIM_StartOp+0xae>
    DRV_MIIM_OP_DCPT* pOpDcpt = (DRV_MIIM_OP_DCPT*)Helper_SingleListHeadRemove(pL);
   15f12:	f104 0070 	add.w	r0, r4, #112	; 0x70
   15f16:	f00a ffb9 	bl	20e8c <Helper_SingleListHeadRemove>
        if(pOpDcpt == 0)
   15f1a:	4683      	mov	fp, r0
   15f1c:	b3e0      	cbz	r0, 15f98 <_DRV_MIIM_StartOp+0xc0>
        pOpDcpt->opType = pSchedData->opType;
   15f1e:	f880 9004 	strb.w	r9, [r0, #4]
        pOpDcpt->regIx = (uint8_t)pSchedData->regIx;
   15f22:	7147      	strb	r7, [r0, #5]
        pOpDcpt->phyAdd = (uint8_t)pSchedData->phyAdd;
   15f24:	f880 8006 	strb.w	r8, [r0, #6]
        pOpDcpt->opFlags = pSchedData->opFlags;
   15f28:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
   15f2c:	71c3      	strb	r3, [r0, #7]
        pOpDcpt->opData = pSchedData->opData;
   15f2e:	f8a0 a008 	strh.w	sl, [r0, #8]
        pOpDcpt->opStat = DRV_MIIM_TXFER_START;
   15f32:	2301      	movs	r3, #1
   15f34:	7283      	strb	r3, [r0, #10]
        pOpDcpt->pOwner = pClient;
   15f36:	60c6      	str	r6, [r0, #12]
        if(pOpDcpt->opType == DRV_MIIM_OP_SCAN)
   15f38:	f1b9 0f03 	cmp.w	r9, #3
   15f3c:	d00d      	beq.n	15f5a <_DRV_MIIM_StartOp+0x82>
    Helper_SingleListTailAdd(pL, (SGL_LIST_NODE*)pOpDcpt);
   15f3e:	4659      	mov	r1, fp
   15f40:	f104 007c 	add.w	r0, r4, #124	; 0x7c
   15f44:	f00b f961 	bl	2120a <Helper_SingleListTailAdd>
    pOpDcpt->qType = qType;
   15f48:	2302      	movs	r3, #2
   15f4a:	f88b 300b 	strb.w	r3, [fp, #11]
    OSAL_SEM_Post(&pMiimObj->objSem);
   15f4e:	4620      	mov	r0, r4
   15f50:	f00b fb40 	bl	215d4 <OSAL_SEM_Post>
        pSchedData->opHandle = opHandle;
   15f54:	465c      	mov	r4, fp
    OSAL_SEM_Post(&pMiimObj->objSem);
   15f56:	2600      	movs	r6, #0
   15f58:	e019      	b.n	15f8e <_DRV_MIIM_StartOp+0xb6>
            pMiimObj->objFlags |= DRV_MIIM_OBJ_FLAG_IS_SCANNING;
   15f5a:	88a3      	ldrh	r3, [r4, #4]
   15f5c:	f043 0308 	orr.w	r3, r3, #8
   15f60:	80a3      	strh	r3, [r4, #4]
   15f62:	e7ec      	b.n	15f3e <_DRV_MIIM_StartOp+0x66>
        opHandle = 0;
   15f64:	4604      	mov	r4, r0
            res = DRV_MIIM_RES_HANDLE_ERR;
   15f66:	f04f 36ff 	mov.w	r6, #4294967295
   15f6a:	e010      	b.n	15f8e <_DRV_MIIM_StartOp+0xb6>
            res = DRV_MIIM_RES_REGISTER_ERR;
   15f6c:	f06f 0604 	mvn.w	r6, #4
    if(pMiimObj != 0)
   15f70:	b16c      	cbz	r4, 15f8e <_DRV_MIIM_StartOp+0xb6>
    OSAL_SEM_Post(&pMiimObj->objSem);
   15f72:	4620      	mov	r0, r4
   15f74:	f00b fb2e 	bl	215d4 <OSAL_SEM_Post>
        opHandle = 0;
   15f78:	2400      	movs	r4, #0
   15f7a:	e008      	b.n	15f8e <_DRV_MIIM_StartOp+0xb6>
            res = DRV_MIIM_RES_ADDRESS_ERR;
   15f7c:	f06f 0605 	mvn.w	r6, #5
   15f80:	e7f6      	b.n	15f70 <_DRV_MIIM_StartOp+0x98>
            res = DRV_MIIM_RES_SETUP_ERR;
   15f82:	f06f 0603 	mvn.w	r6, #3
    OSAL_SEM_Post(&pMiimObj->objSem);
   15f86:	4620      	mov	r0, r4
   15f88:	f00b fb24 	bl	215d4 <OSAL_SEM_Post>
        opHandle = 0;
   15f8c:	2400      	movs	r4, #0
    if(pOpResult)
   15f8e:	b105      	cbz	r5, 15f92 <_DRV_MIIM_StartOp+0xba>
        *pOpResult = opRes;
   15f90:	702e      	strb	r6, [r5, #0]
}
   15f92:	4620      	mov	r0, r4
   15f94:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
            res = DRV_MIIM_RES_BUSY;
   15f98:	2602      	movs	r6, #2
   15f9a:	e7f4      	b.n	15f86 <_DRV_MIIM_StartOp+0xae>

Disassembly of section .text.TCPIP_UDP_OpenServerSkt%323:

00015f9c <TCPIP_UDP_OpenServerSkt>:
   if(addType == IP_ADDRESS_TYPE_IPV6)
   15f9c:	2802      	cmp	r0, #2
   15f9e:	d056      	beq.n	1604e <TCPIP_UDP_OpenServerSkt+0xb2>
{
   15fa0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   15fa2:	461d      	mov	r5, r3
   15fa4:	4614      	mov	r4, r2
   15fa6:	460e      	mov	r6, r1
   if(addType == IP_ADDRESS_TYPE_IPV4 && localAddress != 0)
   15fa8:	b10a      	cbz	r2, 15fae <TCPIP_UDP_OpenServerSkt+0x12>
       if(localAddress->v4Add.Val == 0)
   15faa:	6813      	ldr	r3, [r2, #0]
   15fac:	b9ab      	cbnz	r3, 15fda <TCPIP_UDP_OpenServerSkt+0x3e>
    skt = _UDPOpen(addType, opType, localPort, 0);
   15fae:	2300      	movs	r3, #0
   15fb0:	4632      	mov	r2, r6
   15fb2:	4629      	mov	r1, r5
   15fb4:	2001      	movs	r0, #1
   15fb6:	f7fb fbff 	bl	117b8 <_UDPOpen>
    if(skt != INVALID_UDP_SOCKET)
   15fba:	f1b0 3fff 	cmp.w	r0, #4294967295
   15fbe:	d00b      	beq.n	15fd8 <TCPIP_UDP_OpenServerSkt+0x3c>
        UDP_SOCKET_DCPT* pSkt = UDPSocketDcpt[skt];
   15fc0:	4b26      	ldr	r3, [pc, #152]	; (1605c <TCPIP_UDP_OpenServerSkt+0xc0>)
   15fc2:	681b      	ldr	r3, [r3, #0]
   15fc4:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    if((pSkt->pSktNet = pNet) != 0)
   15fc8:	2200      	movs	r2, #0
   15fca:	625a      	str	r2, [r3, #36]	; 0x24
    pSkt->extFlags.rxEnable = 1;
   15fcc:	f893 2042 	ldrb.w	r2, [r3, #66]	; 0x42
   15fd0:	f042 0202 	orr.w	r2, r2, #2
   15fd4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
}
   15fd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
           pDefIf = TCPIP_STACK_IPAddToNet(&localAddress->v4Add, false);
   15fda:	2100      	movs	r1, #0
   15fdc:	4610      	mov	r0, r2
   15fde:	f00a fa99 	bl	20514 <TCPIP_STACK_IPAddToNet>
           if(pDefIf == 0)
   15fe2:	4607      	mov	r7, r0
   15fe4:	b3b0      	cbz	r0, 16054 <TCPIP_UDP_OpenServerSkt+0xb8>
    skt = _UDPOpen(addType, opType, localPort, 0);
   15fe6:	2300      	movs	r3, #0
   15fe8:	4632      	mov	r2, r6
   15fea:	4629      	mov	r1, r5
   15fec:	2001      	movs	r0, #1
   15fee:	f7fb fbe3 	bl	117b8 <_UDPOpen>
    if(skt != INVALID_UDP_SOCKET)
   15ff2:	f1b0 3fff 	cmp.w	r0, #4294967295
   15ff6:	d0ef      	beq.n	15fd8 <TCPIP_UDP_OpenServerSkt+0x3c>
        UDP_SOCKET_DCPT* pSkt = UDPSocketDcpt[skt];
   15ff8:	4b18      	ldr	r3, [pc, #96]	; (1605c <TCPIP_UDP_OpenServerSkt+0xc0>)
   15ffa:	681b      	ldr	r3, [r3, #0]
   15ffc:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    if((pSkt->pSktNet = pNet) != 0)
   16000:	625f      	str	r7, [r3, #36]	; 0x24
        pSkt->flags.looseNetIf = 0;
   16002:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
   16006:	f36f 02c3 	bfc	r2, #3, #1
   1600a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    return _UDPSetSourceAddress(pSkt, pSkt->addType, srcAddress);
   1600e:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
    while(pSkt->addType == addType)
   16010:	b2d1      	uxtb	r1, r2
   16012:	428a      	cmp	r2, r1
   16014:	d00d      	beq.n	16032 <TCPIP_UDP_OpenServerSkt+0x96>
        if(pDefIf != 0)
   16016:	b12f      	cbz	r7, 16024 <TCPIP_UDP_OpenServerSkt+0x88>
            pSkt->flags.openBindIf = 1;
   16018:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
   1601c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   16020:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
            pSkt->flags.openBindAdd = 1;
   16024:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
   16028:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   1602c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
   16030:	e7cc      	b.n	15fcc <TCPIP_UDP_OpenServerSkt+0x30>
        if (addType == IP_ADDRESS_TYPE_IPV4)
   16032:	b2d2      	uxtb	r2, r2
   16034:	2a01      	cmp	r2, #1
   16036:	d1ee      	bne.n	16016 <TCPIP_UDP_OpenServerSkt+0x7a>
            pSkt->srcAddress.Val = localAddress->v4Add.Val;
   16038:	6822      	ldr	r2, [r4, #0]
   1603a:	619a      	str	r2, [r3, #24]
            pSkt->flags.srcSet = 1;
   1603c:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
            pSkt->flags.srcSolved = 0;
   16040:	f042 0260 	orr.w	r2, r2, #96	; 0x60
   16044:	f36f 12c7 	bfc	r2, #7, #1
   16048:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
            return true;
   1604c:	e7e3      	b.n	16016 <TCPIP_UDP_OpenServerSkt+0x7a>
       return INVALID_SOCKET;
   1604e:	f04f 30ff 	mov.w	r0, #4294967295
}
   16052:	4770      	bx	lr
               return INVALID_UDP_SOCKET;
   16054:	f04f 30ff 	mov.w	r0, #4294967295
   16058:	e7be      	b.n	15fd8 <TCPIP_UDP_OpenServerSkt+0x3c>
   1605a:	bf00      	nop
   1605c:	2000e454 	.word	0x2000e454

Disassembly of section .text.TCPIP_TCP_Bind%324:

00016060 <TCPIP_TCP_Bind>:
{
   16060:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   16064:	460d      	mov	r5, r1
   16066:	4616      	mov	r6, r2
   16068:	461f      	mov	r7, r3
    pSkt = _TcpSocketChk(hTCP); 
   1606a:	f009 fed7 	bl	1fe1c <_TcpSocketChk>
    if(pSkt == 0 || _TCP_IsConnected(pSkt))
   1606e:	2800      	cmp	r0, #0
   16070:	d04c      	beq.n	1610c <TCPIP_TCP_Bind+0xac>
   16072:	4604      	mov	r4, r0
    return (pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1 || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2 || pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT);
   16074:	f890 206e 	ldrb.w	r2, [r0, #110]	; 0x6e
   16078:	1ed3      	subs	r3, r2, #3
   1607a:	b2db      	uxtb	r3, r3
   1607c:	2b02      	cmp	r3, #2
   1607e:	d947      	bls.n	16110 <TCPIP_TCP_Bind+0xb0>
    if(pSkt == 0 || _TCP_IsConnected(pSkt))
   16080:	2a08      	cmp	r2, #8
   16082:	d049      	beq.n	16118 <TCPIP_TCP_Bind+0xb8>
    if(pSkt->addType != IP_ADDRESS_TYPE_ANY && pSkt->addType != addType)
   16084:	f890 306f 	ldrb.w	r3, [r0, #111]	; 0x6f
   16088:	b10b      	cbz	r3, 1608e <TCPIP_TCP_Bind+0x2e>
   1608a:	42ab      	cmp	r3, r5
   1608c:	d146      	bne.n	1611c <TCPIP_TCP_Bind+0xbc>
    if(localAddress != 0)
   1608e:	b15f      	cbz	r7, 160a8 <TCPIP_TCP_Bind+0x48>
        if (addType == IP_ADDRESS_TYPE_IPV4)
   16090:	2d01      	cmp	r5, #1
   16092:	d001      	beq.n	16098 <TCPIP_TCP_Bind+0x38>
            return false;
   16094:	2300      	movs	r3, #0
   16096:	e03c      	b.n	16112 <TCPIP_TCP_Bind+0xb2>
            pSktIf = TCPIP_STACK_IPAddToNet(&localAddress->v4Add, false);
   16098:	2100      	movs	r1, #0
   1609a:	4638      	mov	r0, r7
   1609c:	f00a fa3a 	bl	20514 <TCPIP_STACK_IPAddToNet>
        if(pSktIf == 0)
   160a0:	4680      	mov	r8, r0
   160a2:	b918      	cbnz	r0, 160ac <TCPIP_TCP_Bind+0x4c>
            return false;
   160a4:	2300      	movs	r3, #0
   160a6:	e034      	b.n	16112 <TCPIP_TCP_Bind+0xb2>
        pSktIf = pSkt->pSktNet;
   160a8:	f8d4 8040 	ldr.w	r8, [r4, #64]	; 0x40
    if(localPort == 0)
   160ac:	b1e6      	cbz	r6, 160e8 <TCPIP_TCP_Bind+0x88>
    else if(localPort != pSkt->localPort && !_TCP_PortIsAvailable(localPort))
   160ae:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
   160b2:	42b3      	cmp	r3, r6
   160b4:	d004      	beq.n	160c0 <TCPIP_TCP_Bind+0x60>
   160b6:	4630      	mov	r0, r6
   160b8:	f007 fcdc 	bl	1da74 <_TCP_PortIsAvailable>
   160bc:	4603      	mov	r3, r0
   160be:	b340      	cbz	r0, 16112 <TCPIP_TCP_Bind+0xb2>
    pSkt->addType = addType;
   160c0:	f884 506f 	strb.w	r5, [r4, #111]	; 0x6f
    pSkt->pSktNet = pNet;
   160c4:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
    _TCPSetSourceAddress(pSkt, pSkt->addType, srcAddress);
   160c8:	463a      	mov	r2, r7
   160ca:	4629      	mov	r1, r5
   160cc:	4620      	mov	r0, r4
   160ce:	f008 fc54 	bl	1e97a <_TCPSetSourceAddress>
    pSkt->localPort = localPort;
   160d2:	f8a4 605a 	strh.w	r6, [r4, #90]	; 0x5a
    if(pSkt->Flags.bServer)
   160d6:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
   160da:	f013 0f01 	tst.w	r3, #1
   160de:	d00a      	beq.n	160f6 <TCPIP_TCP_Bind+0x96>
        pSkt->remoteHash = localPort;
   160e0:	f8a4 606a 	strh.w	r6, [r4, #106]	; 0x6a
    return true;
   160e4:	2301      	movs	r3, #1
   160e6:	e014      	b.n	16112 <TCPIP_TCP_Bind+0xb2>
        localPort = _TCP_EphemeralPortAllocate();
   160e8:	f008 fb14 	bl	1e714 <_TCP_EphemeralPortAllocate>
        if(localPort == 0)
   160ec:	4606      	mov	r6, r0
   160ee:	2800      	cmp	r0, #0
   160f0:	d1e6      	bne.n	160c0 <TCPIP_TCP_Bind+0x60>
            return false;
   160f2:	2300      	movs	r3, #0
   160f4:	e00d      	b.n	16112 <TCPIP_TCP_Bind+0xb2>
    return (pAdd->w[1] + pAdd->w[0] + pSkt->remotePort) ^ pSkt->localPort;
   160f6:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   160f8:	8f22      	ldrh	r2, [r4, #56]	; 0x38
   160fa:	4413      	add	r3, r2
   160fc:	f8b4 2058 	ldrh.w	r2, [r4, #88]	; 0x58
   16100:	4413      	add	r3, r2
   16102:	405e      	eors	r6, r3
        pSkt->remoteHash = _TCP_ClientIPV4RemoteHash(&pSkt->destAddress, pSkt);
   16104:	f8a4 606a 	strh.w	r6, [r4, #106]	; 0x6a
    return true;
   16108:	2301      	movs	r3, #1
   1610a:	e002      	b.n	16112 <TCPIP_TCP_Bind+0xb2>
        return false;
   1610c:	2300      	movs	r3, #0
   1610e:	e000      	b.n	16112 <TCPIP_TCP_Bind+0xb2>
   16110:	2300      	movs	r3, #0
}
   16112:	4618      	mov	r0, r3
   16114:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return false;
   16118:	2300      	movs	r3, #0
   1611a:	e7fa      	b.n	16112 <TCPIP_TCP_Bind+0xb2>
        return false;
   1611c:	2300      	movs	r3, #0
   1611e:	e7f8      	b.n	16112 <TCPIP_TCP_Bind+0xb2>

Disassembly of section .text._Command_DefaultInterfaceSet%325:

00016120 <_Command_DefaultInterfaceSet>:
{
   16120:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   16124:	b086      	sub	sp, #24
   16126:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   16128:	6845      	ldr	r5, [r0, #4]
    while(argc >= 2)
   1612a:	2901      	cmp	r1, #1
   1612c:	dd0a      	ble.n	16144 <_Command_DefaultInterfaceSet+0x24>
   1612e:	460e      	mov	r6, r1
   16130:	4617      	mov	r7, r2
        if(strcmp(argv[1], "set") == 0)
   16132:	f8d2 8004 	ldr.w	r8, [r2, #4]
   16136:	4923      	ldr	r1, [pc, #140]	; (161c4 <_Command_DefaultInterfaceSet+0xa4>)
   16138:	4640      	mov	r0, r8
   1613a:	f00b fc6f 	bl	21a1c <strcmp>
   1613e:	bb50      	cbnz	r0, 16196 <_Command_DefaultInterfaceSet+0x76>
            if(argc < 3)
   16140:	2e02      	cmp	r6, #2
   16142:	dc10      	bgt.n	16166 <_Command_DefaultInterfaceSet+0x46>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: defnet set/get <interface>\r\n");
   16144:	4e20      	ldr	r6, [pc, #128]	; (161c8 <_Command_DefaultInterfaceSet+0xa8>)
   16146:	6823      	ldr	r3, [r4, #0]
   16148:	681b      	ldr	r3, [r3, #0]
   1614a:	f106 0184 	add.w	r1, r6, #132	; 0x84
   1614e:	4628      	mov	r0, r5
   16150:	4798      	blx	r3
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: defnet set eth0\r\n");
   16152:	6823      	ldr	r3, [r4, #0]
   16154:	681b      	ldr	r3, [r3, #0]
   16156:	f106 01a8 	add.w	r1, r6, #168	; 0xa8
   1615a:	4628      	mov	r0, r5
   1615c:	4798      	blx	r3
}
   1615e:	2000      	movs	r0, #0
   16160:	b006      	add	sp, #24
   16162:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            netH = TCPIP_STACK_NetHandleGet(argv[2]);
   16166:	68b8      	ldr	r0, [r7, #8]
   16168:	f007 fd24 	bl	1dbb4 <TCPIP_STACK_NetHandleGet>
            if (netH == 0)
   1616c:	b168      	cbz	r0, 1618a <_Command_DefaultInterfaceSet+0x6a>
            res = TCPIP_STACK_NetDefaultSet(netH);
   1616e:	f00a fcbf 	bl	20af0 <TCPIP_STACK_NetDefaultSet>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Default interface set %s\r\n", res ? "successful" : "failed!");
   16172:	6823      	ldr	r3, [r4, #0]
   16174:	685b      	ldr	r3, [r3, #4]
   16176:	2800      	cmp	r0, #0
   16178:	4a14      	ldr	r2, [pc, #80]	; (161cc <_Command_DefaultInterfaceSet+0xac>)
   1617a:	f102 010c 	add.w	r1, r2, #12
   1617e:	bf08      	it	eq
   16180:	460a      	moveq	r2, r1
   16182:	3110      	adds	r1, #16
   16184:	4628      	mov	r0, r5
   16186:	4798      	blx	r3
            break;
   16188:	e7e9      	b.n	1615e <_Command_DefaultInterfaceSet+0x3e>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   1618a:	6823      	ldr	r3, [r4, #0]
   1618c:	681b      	ldr	r3, [r3, #0]
   1618e:	4910      	ldr	r1, [pc, #64]	; (161d0 <_Command_DefaultInterfaceSet+0xb0>)
   16190:	4628      	mov	r0, r5
   16192:	4798      	blx	r3
                return false;
   16194:	e7e3      	b.n	1615e <_Command_DefaultInterfaceSet+0x3e>
        else if(strcmp(argv[1], "get") == 0)
   16196:	490f      	ldr	r1, [pc, #60]	; (161d4 <_Command_DefaultInterfaceSet+0xb4>)
   16198:	4640      	mov	r0, r8
   1619a:	f00b fc3f 	bl	21a1c <strcmp>
   1619e:	2800      	cmp	r0, #0
   161a0:	d1d0      	bne.n	16144 <_Command_DefaultInterfaceSet+0x24>
            netH = TCPIP_STACK_NetDefaultGet();
   161a2:	f00b ff31 	bl	22008 <TCPIP_STACK_NetDefaultGet>
            nameSize = TCPIP_STACK_NetAliasNameGet(netH, nameBuff, sizeof(nameBuff));
   161a6:	2214      	movs	r2, #20
   161a8:	a901      	add	r1, sp, #4
   161aa:	f008 fa25 	bl	1e5f8 <TCPIP_STACK_NetAliasNameGet>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Default interface is: %s\r\n", nameSize ? nameBuff : "None");
   161ae:	6823      	ldr	r3, [r4, #0]
   161b0:	685b      	ldr	r3, [r3, #4]
   161b2:	b920      	cbnz	r0, 161be <_Command_DefaultInterfaceSet+0x9e>
   161b4:	4a08      	ldr	r2, [pc, #32]	; (161d8 <_Command_DefaultInterfaceSet+0xb8>)
   161b6:	4909      	ldr	r1, [pc, #36]	; (161dc <_Command_DefaultInterfaceSet+0xbc>)
   161b8:	4628      	mov	r0, r5
   161ba:	4798      	blx	r3
            break;
   161bc:	e7cf      	b.n	1615e <_Command_DefaultInterfaceSet+0x3e>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Default interface is: %s\r\n", nameSize ? nameBuff : "None");
   161be:	aa01      	add	r2, sp, #4
   161c0:	e7f9      	b.n	161b6 <_Command_DefaultInterfaceSet+0x96>
   161c2:	bf00      	nop
   161c4:	000013c8 	.word	0x000013c8
   161c8:	00001384 	.word	0x00001384
   161cc:	000013b4 	.word	0x000013b4
   161d0:	00000da8 	.word	0x00000da8
   161d4:	000013cc 	.word	0x000013cc
   161d8:	00001218 	.word	0x00001218
   161dc:	000013ec 	.word	0x000013ec

Disassembly of section .rodata.tcpipCmdTbl%326:

000161e0 <tcpipCmdTbl>:
   161e0:	00001780 0000e519 00001788 000017a4     ................
   161f0:	00016121 000017ac 00001598 0000ce79     !a..........y...
   16200:	000017c8 000017e0 000220ff 000017e8     ......... ......
   16210:	00001804 000220f5 0000180c 00001820     ..... ...... ...
   16220:	00015bb9 00001828 0000183c 000150dd     .[..(...<....P..
   16230:	00001844 00001860 00018c5d 00001868     D...`...]...h...
   16240:	00001880 0001a8ed 00001888 000018a4     ................
   16250:	00017e79 000018ac 000018c0 000114f1     y~..............
   16260:	000018c4 000018e4 00013281 000018ec     .........2......
   16270:	00001900 00014691 0000190c 00001920     .....F...... ...
   16280:	0000d5b1 00001928 00001940 00008701     ....(...@.......
   16290:	00001948 00001960 00010939 00001968     H...`...9...h...

Disassembly of section .text.TCPIP_Helper_StringToMACAddress%327:

000162a0 <TCPIP_Helper_StringToMACAddress>:
  Return Values:
  	true - a MAC address was successfully decoded
  	false - no MAC address could be found, or the format was incorrect
  ***************************************************************************/
bool TCPIP_Helper_StringToMACAddress(const char* str, uint8_t macAddr[6])
{
   162a0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   162a4:	b083      	sub	sp, #12
    TCPIP_UINT16_VAL    hexDigit;
    uint8_t     convAddr[6];
    uint8_t*    pAdd;
    int         ix;
    
    if(macAddr)
   162a6:	4688      	mov	r8, r1
   162a8:	b111      	cbz	r1, 162b0 <TCPIP_Helper_StringToMACAddress+0x10>
    {
        memset(macAddr, 0, sizeof(convAddr));
   162aa:	2300      	movs	r3, #0
   162ac:	600b      	str	r3, [r1, #0]
   162ae:	808b      	strh	r3, [r1, #4]
    }

    if(str == 0 || strlen(str) == 0)
   162b0:	2800      	cmp	r0, #0
   162b2:	d046      	beq.n	16342 <TCPIP_Helper_StringToMACAddress+0xa2>
   162b4:	7803      	ldrb	r3, [r0, #0]
   162b6:	2b00      	cmp	r3, #0
   162b8:	d045      	beq.n	16346 <TCPIP_Helper_StringToMACAddress+0xa6>

    beg = str;
    pAdd = convAddr;
    for(ix=0; ix<6; ix++)
    {
        if(!isxdigit(beg[0]) || !isxdigit(beg[1]))
   162ba:	4a28      	ldr	r2, [pc, #160]	; (1635c <TCPIP_Helper_StringToMACAddress+0xbc>)
   162bc:	5c9a      	ldrb	r2, [r3, r2]
   162be:	f012 0f44 	tst.w	r2, #68	; 0x44
   162c2:	d042      	beq.n	1634a <TCPIP_Helper_StringToMACAddress+0xaa>
   162c4:	7842      	ldrb	r2, [r0, #1]
   162c6:	4925      	ldr	r1, [pc, #148]	; (1635c <TCPIP_Helper_StringToMACAddress+0xbc>)
   162c8:	5c51      	ldrb	r1, [r2, r1]
   162ca:	f011 0f44 	tst.w	r1, #68	; 0x44
   162ce:	d03e      	beq.n	1634e <TCPIP_Helper_StringToMACAddress+0xae>
   162d0:	4604      	mov	r4, r0
    for(ix=0; ix<6; ix++)
   162d2:	2500      	movs	r5, #0
    pAdd = convAddr;
   162d4:	466f      	mov	r7, sp
        if(!isxdigit(beg[0]) || !isxdigit(beg[1]))
   162d6:	f8df 9084 	ldr.w	r9, [pc, #132]	; 1635c <TCPIP_Helper_StringToMACAddress+0xbc>
   162da:	e00f      	b.n	162fc <TCPIP_Helper_StringToMACAddress+0x5c>
    for(ix=0; ix<6; ix++)
   162dc:	3501      	adds	r5, #1
   162de:	2d06      	cmp	r5, #6
   162e0:	d01e      	beq.n	16320 <TCPIP_Helper_StringToMACAddress+0x80>
        if(!isxdigit(beg[0]) || !isxdigit(beg[1]))
   162e2:	78d3      	ldrb	r3, [r2, #3]
   162e4:	f813 1009 	ldrb.w	r1, [r3, r9]
   162e8:	f011 0f44 	tst.w	r1, #68	; 0x44
   162ec:	d031      	beq.n	16352 <TCPIP_Helper_StringToMACAddress+0xb2>
   162ee:	7912      	ldrb	r2, [r2, #4]
   162f0:	3403      	adds	r4, #3
   162f2:	f812 1009 	ldrb.w	r1, [r2, r9]
   162f6:	f011 0f44 	tst.w	r1, #68	; 0x44
   162fa:	d02c      	beq.n	16356 <TCPIP_Helper_StringToMACAddress+0xb6>
        {
            return false;
        }

        // found valid byte
        hexDigit.v[0] = beg[1];
   162fc:	f362 0607 	bfi	r6, r2, #0, #8
        hexDigit.v[1] = beg[0];
   16300:	f363 260f 	bfi	r6, r3, #8, #8
        *pAdd++ = hexatob(hexDigit.Val);
   16304:	b2b0      	uxth	r0, r6
   16306:	f007 feca 	bl	1e09e <hexatob>
   1630a:	f807 0b01 	strb.w	r0, [r7], #1

        // next colon number
        beg += 2;
        if(beg[0] == '\0')
   1630e:	4622      	mov	r2, r4
   16310:	78a3      	ldrb	r3, [r4, #2]
   16312:	b12b      	cbz	r3, 16320 <TCPIP_Helper_StringToMACAddress+0x80>
        {
            break;  // done
        }
        else if(beg[0] != ':' && beg[0] != '-')
   16314:	2b3a      	cmp	r3, #58	; 0x3a
   16316:	d0e1      	beq.n	162dc <TCPIP_Helper_StringToMACAddress+0x3c>
   16318:	2b2d      	cmp	r3, #45	; 0x2d
   1631a:	d0df      	beq.n	162dc <TCPIP_Helper_StringToMACAddress+0x3c>
        {
            return false;   // invalid delimiter
   1631c:	2000      	movs	r0, #0
   1631e:	e00d      	b.n	1633c <TCPIP_Helper_StringToMACAddress+0x9c>
        }
        beg++; // next digit
    }

    if(macAddr)
   16320:	f1b8 0f00 	cmp.w	r8, #0
   16324:	d006      	beq.n	16334 <TCPIP_Helper_StringToMACAddress+0x94>
    {
        memcpy(macAddr, convAddr, sizeof(convAddr));
   16326:	9800      	ldr	r0, [sp, #0]
   16328:	f8c8 0000 	str.w	r0, [r8]
   1632c:	f8bd 3004 	ldrh.w	r3, [sp, #4]
   16330:	f8a8 3004 	strh.w	r3, [r8, #4]
    }
    
    return ix == 5 ? true : false;    // false if not enough digits    
   16334:	2d05      	cmp	r5, #5
   16336:	bf14      	ite	ne
   16338:	2000      	movne	r0, #0
   1633a:	2001      	moveq	r0, #1
    
}
   1633c:	b003      	add	sp, #12
   1633e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return true;
   16342:	2001      	movs	r0, #1
   16344:	e7fa      	b.n	1633c <TCPIP_Helper_StringToMACAddress+0x9c>
   16346:	2001      	movs	r0, #1
   16348:	e7f8      	b.n	1633c <TCPIP_Helper_StringToMACAddress+0x9c>
            return false;
   1634a:	2000      	movs	r0, #0
   1634c:	e7f6      	b.n	1633c <TCPIP_Helper_StringToMACAddress+0x9c>
   1634e:	2000      	movs	r0, #0
   16350:	e7f4      	b.n	1633c <TCPIP_Helper_StringToMACAddress+0x9c>
   16352:	2000      	movs	r0, #0
   16354:	e7f2      	b.n	1633c <TCPIP_Helper_StringToMACAddress+0x9c>
   16356:	2000      	movs	r0, #0
   16358:	e7f0      	b.n	1633c <TCPIP_Helper_StringToMACAddress+0x9c>
   1635a:	bf00      	nop
   1635c:	00014195 	.word	0x00014195

Disassembly of section .text._DRV_MIIM_ClientDeallocate%328:

00016360 <_DRV_MIIM_ClientDeallocate>:


// de-allocates a client
// MIIM object should be locked
static void _DRV_MIIM_ClientDeallocate( DRV_MIIM_CLIENT_DCPT* pClient)
{
   16360:	b570      	push	{r4, r5, r6, lr}
   16362:	b08a      	sub	sp, #40	; 0x28
   16364:	4604      	mov	r4, r0
// all operations owned by this client
static void _DRV_MIIM_PurgeClientOp(DRV_MIIM_CLIENT_DCPT* pClient)
{
    DRV_MIIM_OP_DCPT* pOpDcpt;
    SINGLE_LIST delList, busyList, completeList;
    DRV_MIIM_OBJ* pMiimObj = pClient->parentObj;
   16366:	6845      	ldr	r5, [r0, #4]

}

void  Helper_SingleListInitialize(SINGLE_LIST* pL)
{
    pL->head = pL->tail = 0;
   16368:	2300      	movs	r3, #0
   1636a:	9302      	str	r3, [sp, #8]
   1636c:	9301      	str	r3, [sp, #4]
    pL->nNodes = 0;
   1636e:	9303      	str	r3, [sp, #12]
    pL->head = pL->tail = 0;
   16370:	9305      	str	r3, [sp, #20]
   16372:	9304      	str	r3, [sp, #16]
    pL->nNodes = 0;
   16374:	9306      	str	r3, [sp, #24]
    pL->head = pL->tail = 0;
   16376:	9308      	str	r3, [sp, #32]
   16378:	9307      	str	r3, [sp, #28]
    pL->nNodes = 0;
   1637a:	9309      	str	r3, [sp, #36]	; 0x24
    while((pOpDcpt = _DRV_MIIM_OpListRemove(&pMiimObj->busyOpList, DRV_MIIM_QTYPE_BUSY)) != 0)
   1637c:	f105 067c 	add.w	r6, r5, #124	; 0x7c
    DRV_MIIM_OP_DCPT* pOpDcpt = (DRV_MIIM_OP_DCPT*)Helper_SingleListHeadRemove(pL);
   16380:	4630      	mov	r0, r6
   16382:	f00a fd83 	bl	20e8c <Helper_SingleListHeadRemove>
    while((pOpDcpt = _DRV_MIIM_OpListRemove(&pMiimObj->busyOpList, DRV_MIIM_QTYPE_BUSY)) != 0)
   16386:	4601      	mov	r1, r0
   16388:	b138      	cbz	r0, 1639a <_DRV_MIIM_ClientDeallocate+0x3a>
        if(pOpDcpt->pOwner == pClient)
   1638a:	68cb      	ldr	r3, [r1, #12]
   1638c:	429c      	cmp	r4, r3
            Helper_SingleListTailAdd(&delList, (SGL_LIST_NODE*)pOpDcpt);
   1638e:	bf0c      	ite	eq
   16390:	a801      	addeq	r0, sp, #4
            Helper_SingleListTailAdd(&busyList, (SGL_LIST_NODE*)pOpDcpt);
   16392:	a804      	addne	r0, sp, #16
   16394:	f00a ff39 	bl	2120a <Helper_SingleListTailAdd>
   16398:	e7f2      	b.n	16380 <_DRV_MIIM_ClientDeallocate+0x20>
    pMiimObj->busyOpList = busyList;
   1639a:	f105 037c 	add.w	r3, r5, #124	; 0x7c
   1639e:	aa04      	add	r2, sp, #16
   163a0:	ca07      	ldmia	r2, {r0, r1, r2}
   163a2:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    while((pOpDcpt = (DRV_MIIM_OP_DCPT*)delList.head) != 0)
   163a6:	9901      	ldr	r1, [sp, #4]
   163a8:	b141      	cbz	r1, 163bc <_DRV_MIIM_ClientDeallocate+0x5c>
        _DRV_MIIM_ReleaseOpDcpt(pMiimObj, pOpDcpt, &delList, DRV_MIIM_QTYPE_BUSY);
   163aa:	2602      	movs	r6, #2
   163ac:	4633      	mov	r3, r6
   163ae:	aa01      	add	r2, sp, #4
   163b0:	4628      	mov	r0, r5
   163b2:	f008 f8ad 	bl	1e510 <_DRV_MIIM_ReleaseOpDcpt>
    while((pOpDcpt = (DRV_MIIM_OP_DCPT*)delList.head) != 0)
   163b6:	9901      	ldr	r1, [sp, #4]
   163b8:	2900      	cmp	r1, #0
   163ba:	d1f7      	bne.n	163ac <_DRV_MIIM_ClientDeallocate+0x4c>
    while((pOpDcpt = _DRV_MIIM_OpListRemove(&pMiimObj->completeOpList, DRV_MIIM_QTYPE_COMPLETE)) != 0)
   163bc:	f105 0688 	add.w	r6, r5, #136	; 0x88
    DRV_MIIM_OP_DCPT* pOpDcpt = (DRV_MIIM_OP_DCPT*)Helper_SingleListHeadRemove(pL);
   163c0:	4630      	mov	r0, r6
   163c2:	f00a fd63 	bl	20e8c <Helper_SingleListHeadRemove>
    while((pOpDcpt = _DRV_MIIM_OpListRemove(&pMiimObj->completeOpList, DRV_MIIM_QTYPE_COMPLETE)) != 0)
   163c6:	4601      	mov	r1, r0
   163c8:	b138      	cbz	r0, 163da <_DRV_MIIM_ClientDeallocate+0x7a>
        if(pOpDcpt->pOwner == pClient)
   163ca:	68cb      	ldr	r3, [r1, #12]
   163cc:	429c      	cmp	r4, r3
            Helper_SingleListTailAdd(&delList, (SGL_LIST_NODE*)pOpDcpt);
   163ce:	bf0c      	ite	eq
   163d0:	a801      	addeq	r0, sp, #4
            Helper_SingleListTailAdd(&completeList, (SGL_LIST_NODE*)pOpDcpt);
   163d2:	a807      	addne	r0, sp, #28
   163d4:	f00a ff19 	bl	2120a <Helper_SingleListTailAdd>
   163d8:	e7f2      	b.n	163c0 <_DRV_MIIM_ClientDeallocate+0x60>
    pMiimObj->completeOpList = completeList;
   163da:	f105 0388 	add.w	r3, r5, #136	; 0x88
   163de:	aa0a      	add	r2, sp, #40	; 0x28
   163e0:	e912 0007 	ldmdb	r2, {r0, r1, r2}
   163e4:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    while((pOpDcpt = (DRV_MIIM_OP_DCPT*)delList.head) != 0)
   163e8:	9901      	ldr	r1, [sp, #4]
   163ea:	b141      	cbz	r1, 163fe <_DRV_MIIM_ClientDeallocate+0x9e>
        _DRV_MIIM_ReleaseOpDcpt(pMiimObj, pOpDcpt, &delList, DRV_MIIM_QTYPE_COMPLETE);
   163ec:	2603      	movs	r6, #3
   163ee:	4633      	mov	r3, r6
   163f0:	aa01      	add	r2, sp, #4
   163f2:	4628      	mov	r0, r5
   163f4:	f008 f88c 	bl	1e510 <_DRV_MIIM_ReleaseOpDcpt>
    while((pOpDcpt = (DRV_MIIM_OP_DCPT*)delList.head) != 0)
   163f8:	9901      	ldr	r1, [sp, #4]
   163fa:	2900      	cmp	r1, #0
   163fc:	d1f7      	bne.n	163ee <_DRV_MIIM_ClientDeallocate+0x8e>
    pClient->clientInUse = false ;
   163fe:	2300      	movs	r3, #0
   16400:	8023      	strh	r3, [r4, #0]
    pClient->cliStatus = DRV_CLIENT_STATUS_ERROR;
   16402:	23ff      	movs	r3, #255	; 0xff
   16404:	7323      	strb	r3, [r4, #12]
    pClient->parentObj->numClients--;
   16406:	6862      	ldr	r2, [r4, #4]
   16408:	88d3      	ldrh	r3, [r2, #6]
   1640a:	3b01      	subs	r3, #1
   1640c:	80d3      	strh	r3, [r2, #6]
    pClient->parentObj->objFlags &= ~DRV_MIIM_OBJ_FLAG_EXCLUSIVE;
   1640e:	6862      	ldr	r2, [r4, #4]
   16410:	8893      	ldrh	r3, [r2, #4]
   16412:	f023 0304 	bic.w	r3, r3, #4
   16416:	8093      	strh	r3, [r2, #4]
}
   16418:	b00a      	add	sp, #40	; 0x28
   1641a:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_IPV4_DeInitialize%329:

0001641c <TCPIP_IPV4_DeInitialize>:
    if(ipv4InitCount > 0)
   1641c:	4b2b      	ldr	r3, [pc, #172]	; (164cc <TCPIP_IPV4_DeInitialize+0xb0>)
   1641e:	881b      	ldrh	r3, [r3, #0]
   16420:	b903      	cbnz	r3, 16424 <TCPIP_IPV4_DeInitialize+0x8>
   16422:	4770      	bx	lr
{
   16424:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   16428:	b084      	sub	sp, #16
   1642a:	4607      	mov	r7, r0
        TCPIP_IPV4_ArpListPurge(stackCtrl->pNetIf);
   1642c:	6946      	ldr	r6, [r0, #20]
    TCPIP_Helper_SingleListInitialize (&newList);
   1642e:	a801      	add	r0, sp, #4
   16430:	f00b fe74 	bl	2211c <TCPIP_Helper_SingleListInitialize>
    TCPIP_Helper_ProtectedSingleListLock(pList);
   16434:	4826      	ldr	r0, [pc, #152]	; (164d0 <TCPIP_IPV4_DeInitialize+0xb4>)
   16436:	f00a fb3b 	bl	20ab0 <TCPIP_Helper_ProtectedSingleListLock>
    while((pEntry = (IPV4_ARP_ENTRY*)TCPIP_Helper_SingleListHeadRemove(&pList->list)) != 0)
   1643a:	f8df 9094 	ldr.w	r9, [pc, #148]	; 164d0 <TCPIP_IPV4_DeInitialize+0xb4>
            TCPIP_Helper_SingleListTailAdd(&ipv4ArpPool, (SGL_LIST_NODE*)pEntry); 
   1643e:	f8df 8094 	ldr.w	r8, [pc, #148]	; 164d4 <TCPIP_IPV4_DeInitialize+0xb8>
        TCPIP_PKT_PacketAcknowledge(pTxPkt, ackRes);
   16442:	f04f 0a03 	mov.w	sl, #3
   16446:	e00a      	b.n	1645e <TCPIP_IPV4_DeInitialize+0x42>
            pMacPkt = &pEntry->pTxPkt->macPkt;
   16448:	68a5      	ldr	r5, [r4, #8]
   1644a:	e013      	b.n	16474 <TCPIP_IPV4_DeInitialize+0x58>
            if(pEntry->type == IPV4_ARP_PKT_TYPE_TX || pEntry->type == IPV4_ARP_PKT_TYPE_MAC)
   1644c:	7923      	ldrb	r3, [r4, #4]
   1644e:	3b01      	subs	r3, #1
   16450:	b2db      	uxtb	r3, r3
   16452:	2b01      	cmp	r3, #1
   16454:	d91a      	bls.n	1648c <TCPIP_IPV4_DeInitialize+0x70>
            TCPIP_Helper_SingleListTailAdd(&ipv4ArpPool, (SGL_LIST_NODE*)pEntry); 
   16456:	4621      	mov	r1, r4
   16458:	4640      	mov	r0, r8
   1645a:	f00a ff31 	bl	212c0 <TCPIP_Helper_SingleListTailAdd>
    while((pEntry = (IPV4_ARP_ENTRY*)TCPIP_Helper_SingleListHeadRemove(&pList->list)) != 0)
   1645e:	4648      	mov	r0, r9
   16460:	f00a fd5a 	bl	20f18 <TCPIP_Helper_SingleListHeadRemove>
   16464:	4604      	mov	r4, r0
   16466:	b1c0      	cbz	r0, 1649a <TCPIP_IPV4_DeInitialize+0x7e>
        if(pEntry->type == IPV4_ARP_PKT_TYPE_TX)
   16468:	7923      	ldrb	r3, [r4, #4]
   1646a:	2b01      	cmp	r3, #1
   1646c:	d0ec      	beq.n	16448 <TCPIP_IPV4_DeInitialize+0x2c>
        else if(pEntry->type == IPV4_ARP_PKT_TYPE_MAC)
   1646e:	2b02      	cmp	r3, #2
   16470:	d11c      	bne.n	164ac <TCPIP_IPV4_DeInitialize+0x90>
            pMacPkt = pEntry->pMacPkt; 
   16472:	68a5      	ldr	r5, [r4, #8]
        pPktIf = (TCPIP_NET_IF*)TCPIP_STACK_IndexToNet(pEntry->arpIfIx);
   16474:	7960      	ldrb	r0, [r4, #5]
   16476:	f009 fd71 	bl	1ff5c <TCPIP_STACK_IndexToNet>
        if(pNetIf == 0 || pNetIf == pPktIf)
   1647a:	2e00      	cmp	r6, #0
   1647c:	d0e6      	beq.n	1644c <TCPIP_IPV4_DeInitialize+0x30>
   1647e:	4286      	cmp	r6, r0
   16480:	d0e4      	beq.n	1644c <TCPIP_IPV4_DeInitialize+0x30>
            TCPIP_Helper_SingleListTailAdd(&newList, (SGL_LIST_NODE*)pEntry);
   16482:	4621      	mov	r1, r4
   16484:	a801      	add	r0, sp, #4
   16486:	f00a ff1b 	bl	212c0 <TCPIP_Helper_SingleListTailAdd>
   1648a:	e7e8      	b.n	1645e <TCPIP_IPV4_DeInitialize+0x42>
        TCPIP_PKT_PacketAcknowledge(pTxPkt, ackRes);
   1648c:	4652      	mov	r2, sl
   1648e:	f06f 0104 	mvn.w	r1, #4
   16492:	4628      	mov	r0, r5
   16494:	f007 fbae 	bl	1dbf4 <_TCPIP_PKT_PacketAcknowledge>
   16498:	e7dd      	b.n	16456 <TCPIP_IPV4_DeInitialize+0x3a>
    pList->list = newList;
   1649a:	4b0d      	ldr	r3, [pc, #52]	; (164d0 <TCPIP_IPV4_DeInitialize+0xb4>)
   1649c:	aa04      	add	r2, sp, #16
   1649e:	e912 0007 	ldmdb	r2, {r0, r1, r2}
   164a2:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    TCPIP_Helper_ProtectedSingleListUnlock(pList);
   164a6:	4618      	mov	r0, r3
   164a8:	f00a fd44 	bl	20f34 <TCPIP_Helper_ProtectedSingleListUnlock>
        if(stackCtrl->stackAction == TCPIP_STACK_ACTION_DEINIT)
   164ac:	7f3b      	ldrb	r3, [r7, #28]
   164ae:	2b02      	cmp	r3, #2
   164b0:	d002      	beq.n	164b8 <TCPIP_IPV4_DeInitialize+0x9c>
}
   164b2:	b004      	add	sp, #16
   164b4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            if (--ipv4InitCount == 0)
   164b8:	4a04      	ldr	r2, [pc, #16]	; (164cc <TCPIP_IPV4_DeInitialize+0xb0>)
   164ba:	8813      	ldrh	r3, [r2, #0]
   164bc:	3b01      	subs	r3, #1
   164be:	b29b      	uxth	r3, r3
   164c0:	8013      	strh	r3, [r2, #0]
   164c2:	2b00      	cmp	r3, #0
   164c4:	d1f5      	bne.n	164b2 <TCPIP_IPV4_DeInitialize+0x96>
                TCPIP_IPV4_Cleanup();
   164c6:	f004 f859 	bl	1a57c <TCPIP_IPV4_Cleanup>
}
   164ca:	e7f2      	b.n	164b2 <TCPIP_IPV4_DeInitialize+0x96>
   164cc:	2000e500 	.word	0x2000e500
   164d0:	2000e228 	.word	0x2000e228
   164d4:	2000e328 	.word	0x2000e328

Disassembly of section .text.TCPIP_STACK_KillStack%330:

000164d8 <TCPIP_STACK_KillStack>:
{
   164d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (tcpip_stack_tickH != SYS_TMR_HANDLE_INVALID)
   164dc:	4b26      	ldr	r3, [pc, #152]	; (16578 <TCPIP_STACK_KillStack+0xa0>)
   164de:	6818      	ldr	r0, [r3, #0]
   164e0:	f1b0 3fff 	cmp.w	r0, #4294967295
   164e4:	d137      	bne.n	16556 <TCPIP_STACK_KillStack+0x7e>
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   164e6:	4b25      	ldr	r3, [pc, #148]	; (1657c <TCPIP_STACK_KillStack+0xa4>)
   164e8:	681c      	ldr	r4, [r3, #0]
   164ea:	4b25      	ldr	r3, [pc, #148]	; (16580 <TCPIP_STACK_KillStack+0xa8>)
   164ec:	681b      	ldr	r3, [r3, #0]
   164ee:	2b00      	cmp	r3, #0
   164f0:	dd0f      	ble.n	16512 <TCPIP_STACK_KillStack+0x3a>
   164f2:	2500      	movs	r5, #0
        TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pNetIf, TCPIP_STACK_ACTION_DEINIT, TCPIP_MAC_POWER_DOWN);
   164f4:	4e22      	ldr	r6, [pc, #136]	; (16580 <TCPIP_STACK_KillStack+0xa8>)
   164f6:	f04f 0803 	mov.w	r8, #3
   164fa:	2702      	movs	r7, #2
   164fc:	4643      	mov	r3, r8
   164fe:	463a      	mov	r2, r7
   16500:	4621      	mov	r1, r4
   16502:	4630      	mov	r0, r6
   16504:	f004 fea4 	bl	1b250 <TCPIP_STACK_BringNetDown>
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   16508:	3501      	adds	r5, #1
   1650a:	346c      	adds	r4, #108	; 0x6c
   1650c:	6833      	ldr	r3, [r6, #0]
   1650e:	42ab      	cmp	r3, r5
   16510:	dcf4      	bgt.n	164fc <TCPIP_STACK_KillStack+0x24>
    TCPIP_PKT_Deinitialize();
   16512:	f00b fd8b 	bl	2202c <TCPIP_PKT_Deinitialize>
    if(tcpip_stack_ctrl_data.memH != 0)
   16516:	4b1a      	ldr	r3, [pc, #104]	; (16580 <TCPIP_STACK_KillStack+0xa8>)
   16518:	68d8      	ldr	r0, [r3, #12]
   1651a:	b148      	cbz	r0, 16530 <TCPIP_STACK_KillStack+0x58>
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   1651c:	68c3      	ldr	r3, [r0, #12]
   1651e:	4a17      	ldr	r2, [pc, #92]	; (1657c <TCPIP_STACK_KillStack+0xa4>)
   16520:	6811      	ldr	r1, [r2, #0]
   16522:	4798      	blx	r3
        if(TCPIP_HEAP_Delete(tcpip_stack_ctrl_data.memH) < 0)     // destroy the heap
   16524:	4b16      	ldr	r3, [pc, #88]	; (16580 <TCPIP_STACK_KillStack+0xa8>)
   16526:	68d8      	ldr	r0, [r3, #12]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Delete)(h);
   16528:	6803      	ldr	r3, [r0, #0]
   1652a:	4798      	blx	r3
   1652c:	2800      	cmp	r0, #0
   1652e:	db19      	blt.n	16564 <TCPIP_STACK_KillStack+0x8c>
    tcpip_stack_ctrl_data.memH = 0;
   16530:	4a13      	ldr	r2, [pc, #76]	; (16580 <TCPIP_STACK_KillStack+0xa8>)
   16532:	2300      	movs	r3, #0
   16534:	60d3      	str	r3, [r2, #12]
    tcpip_stack_ctrl_data.heapType = 0;
   16536:	7413      	strb	r3, [r2, #16]
    tcpipNetIf = 0;
   16538:	4910      	ldr	r1, [pc, #64]	; (1657c <TCPIP_STACK_KillStack+0xa4>)
   1653a:	600b      	str	r3, [r1, #0]
    tcpip_stack_ctrl_data.nIfs = 0;
   1653c:	6013      	str	r3, [r2, #0]
    tcpip_stack_ctrl_data.nModules = 0;
   1653e:	6093      	str	r3, [r2, #8]
    tcpip_stack_status = SYS_STATUS_UNINITIALIZED;
   16540:	4a10      	ldr	r2, [pc, #64]	; (16584 <TCPIP_STACK_KillStack+0xac>)
   16542:	7013      	strb	r3, [r2, #0]
    stackAsyncSignalCount = 0;
   16544:	4a10      	ldr	r2, [pc, #64]	; (16588 <TCPIP_STACK_KillStack+0xb0>)
   16546:	6013      	str	r3, [r2, #0]
    memset(&tcpip_heap_config, 0, sizeof(tcpip_heap_config));
   16548:	4a10      	ldr	r2, [pc, #64]	; (1658c <TCPIP_STACK_KillStack+0xb4>)
   1654a:	6013      	str	r3, [r2, #0]
   1654c:	6053      	str	r3, [r2, #4]
   1654e:	6093      	str	r3, [r2, #8]
   16550:	60d3      	str	r3, [r2, #12]
}
   16552:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    
*/

static __inline__ void  __attribute__((always_inline)) SYS_TMR_CallbackStop ( SYS_TMR_HANDLE handle )
{
	SYS_TIME_TimerDestroy(handle);
   16556:	f007 ff29 	bl	1e3ac <SYS_TIME_TimerDestroy>
        tcpip_stack_tickH = SYS_TMR_HANDLE_INVALID;
   1655a:	4b07      	ldr	r3, [pc, #28]	; (16578 <TCPIP_STACK_KillStack+0xa0>)
   1655c:	f04f 32ff 	mov.w	r2, #4294967295
   16560:	601a      	str	r2, [r3, #0]
   16562:	e7c0      	b.n	164e6 <TCPIP_STACK_KillStack+0xe>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Heap Delete fail!\r\n");
   16564:	f00b fd74 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
   16568:	2800      	cmp	r0, #0
   1656a:	d0e1      	beq.n	16530 <TCPIP_STACK_KillStack+0x58>
   1656c:	f00b fd6a 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
   16570:	4907      	ldr	r1, [pc, #28]	; (16590 <TCPIP_STACK_KillStack+0xb8>)
   16572:	f004 fa93 	bl	1aa9c <SYS_CONSOLE_Print>
   16576:	e7db      	b.n	16530 <TCPIP_STACK_KillStack+0x58>
   16578:	2000e44c 	.word	0x2000e44c
   1657c:	2000e440 	.word	0x2000e440
   16580:	2000e0f0 	.word	0x2000e0f0
   16584:	2000e50d 	.word	0x2000e50d
   16588:	2000e434 	.word	0x2000e434
   1658c:	2000e318 	.word	0x2000e318
   16590:	0000919c 	.word	0x0000919c

Disassembly of section .text.PORT_Initialize%331:

00016594 <PORT_Initialize>:
  Remarks:
    Refer plib_port.h file for more information.
*/

void PORT_Initialize(void)
{
   16594:	b430      	push	{r4, r5}
   /************************** GROUP 0 Initialization *************************/
   PORT_REGS->GROUP[0].PORT_PINCFG[8] = 0x2;
   16596:	4b2c      	ldr	r3, [pc, #176]	; (16648 <PORT_Initialize+0xb4>)
   16598:	2002      	movs	r0, #2
   1659a:	f883 0048 	strb.w	r0, [r3, #72]	; 0x48
   PORT_REGS->GROUP[0].PORT_PINCFG[9] = 0x2;
   1659e:	f883 0049 	strb.w	r0, [r3, #73]	; 0x49
   PORT_REGS->GROUP[0].PORT_PINCFG[12] = 0x1;
   165a2:	2201      	movs	r2, #1
   165a4:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
   PORT_REGS->GROUP[0].PORT_PINCFG[13] = 0x1;
   165a8:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
   PORT_REGS->GROUP[0].PORT_PINCFG[14] = 0x1;
   165ac:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
   PORT_REGS->GROUP[0].PORT_PINCFG[15] = 0x1;
   165b0:	f883 204f 	strb.w	r2, [r3, #79]	; 0x4f
   PORT_REGS->GROUP[0].PORT_PINCFG[17] = 0x1;
   165b4:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
   PORT_REGS->GROUP[0].PORT_PINCFG[18] = 0x1;
   165b8:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
   PORT_REGS->GROUP[0].PORT_PINCFG[19] = 0x1;
   165bc:	f883 2053 	strb.w	r2, [r3, #83]	; 0x53

   PORT_REGS->GROUP[0].PORT_PMUX[6] = 0xbb;
   165c0:	24bb      	movs	r4, #187	; 0xbb
   165c2:	f883 4036 	strb.w	r4, [r3, #54]	; 0x36
   PORT_REGS->GROUP[0].PORT_PMUX[7] = 0xbb;
   165c6:	f883 4037 	strb.w	r4, [r3, #55]	; 0x37
   PORT_REGS->GROUP[0].PORT_PMUX[8] = 0xb0;
   165ca:	21b0      	movs	r1, #176	; 0xb0
   165cc:	f883 1038 	strb.w	r1, [r3, #56]	; 0x38
   PORT_REGS->GROUP[0].PORT_PMUX[9] = 0xbb;
   165d0:	f883 4039 	strb.w	r4, [r3, #57]	; 0x39

   /************************** GROUP 1 Initialization *************************/
   PORT_REGS->GROUP[1].PORT_DIR = 0x1000c000;
   165d4:	491d      	ldr	r1, [pc, #116]	; (1664c <PORT_Initialize+0xb8>)
   165d6:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
   PORT_REGS->GROUP[1].PORT_PINCFG[14] = 0x0;
   165da:	2100      	movs	r1, #0
   165dc:	f883 10ce 	strb.w	r1, [r3, #206]	; 0xce
   PORT_REGS->GROUP[1].PORT_PINCFG[15] = 0x0;
   165e0:	f883 10cf 	strb.w	r1, [r3, #207]	; 0xcf
   PORT_REGS->GROUP[1].PORT_PINCFG[24] = 0x1;
   165e4:	f883 20d8 	strb.w	r2, [r3, #216]	; 0xd8
   PORT_REGS->GROUP[1].PORT_PINCFG[25] = 0x1;
   165e8:	f883 20d9 	strb.w	r2, [r3, #217]	; 0xd9
   PORT_REGS->GROUP[1].PORT_PINCFG[28] = 0x0;
   165ec:	f883 10dc 	strb.w	r1, [r3, #220]	; 0xdc

   PORT_REGS->GROUP[1].PORT_PMUX[12] = 0x22;
   165f0:	2522      	movs	r5, #34	; 0x22
   165f2:	f883 50bc 	strb.w	r5, [r3, #188]	; 0xbc

   /************************** GROUP 2 Initialization *************************/
   PORT_REGS->GROUP[2].PORT_DIR = 0x1000000;
   165f6:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000
   165fa:	f8c3 5100 	str.w	r5, [r3, #256]	; 0x100
   PORT_REGS->GROUP[2].PORT_OUT = 0x1000000;
   165fe:	f8c3 5110 	str.w	r5, [r3, #272]	; 0x110
   PORT_REGS->GROUP[2].PORT_PINCFG[20] = 0x1;
   16602:	f883 2154 	strb.w	r2, [r3, #340]	; 0x154
   PORT_REGS->GROUP[2].PORT_PINCFG[22] = 0x1;
   16606:	f883 2156 	strb.w	r2, [r3, #342]	; 0x156
   PORT_REGS->GROUP[2].PORT_PINCFG[23] = 0x1;
   1660a:	f883 2157 	strb.w	r2, [r3, #343]	; 0x157
   PORT_REGS->GROUP[2].PORT_PINCFG[24] = 0x0;
   1660e:	f883 1158 	strb.w	r1, [r3, #344]	; 0x158
   PORT_REGS->GROUP[2].PORT_PINCFG[27] = 0x1;
   16612:	f883 215b 	strb.w	r2, [r3, #347]	; 0x15b
   PORT_REGS->GROUP[2].PORT_PINCFG[28] = 0x1;
   16616:	f883 215c 	strb.w	r2, [r3, #348]	; 0x15c

   PORT_REGS->GROUP[2].PORT_PMUX[10] = 0xb;
   1661a:	220b      	movs	r2, #11
   1661c:	f883 213a 	strb.w	r2, [r3, #314]	; 0x13a
   PORT_REGS->GROUP[2].PORT_PMUX[11] = 0xbb;
   16620:	f883 413b 	strb.w	r4, [r3, #315]	; 0x13b
   PORT_REGS->GROUP[2].PORT_PMUX[13] = 0x20;
   16624:	2220      	movs	r2, #32
   16626:	f883 213d 	strb.w	r2, [r3, #317]	; 0x13d
   PORT_REGS->GROUP[2].PORT_PMUX[14] = 0x2;
   1662a:	f883 013e 	strb.w	r0, [r3, #318]	; 0x13e

   /************************** GROUP 3 Initialization *************************/
   PORT_REGS->GROUP[3].PORT_DIR = 0x1400;
   1662e:	f44f 52a0 	mov.w	r2, #5120	; 0x1400
   16632:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
   PORT_REGS->GROUP[3].PORT_PINCFG[10] = 0x0;
   16636:	f883 11ca 	strb.w	r1, [r3, #458]	; 0x1ca
   PORT_REGS->GROUP[3].PORT_PINCFG[11] = 0x2;
   1663a:	f883 01cb 	strb.w	r0, [r3, #459]	; 0x1cb
   PORT_REGS->GROUP[3].PORT_PINCFG[12] = 0x0;
   1663e:	f883 11cc 	strb.w	r1, [r3, #460]	; 0x1cc


}
   16642:	bc30      	pop	{r4, r5}
   16644:	4770      	bx	lr
   16646:	bf00      	nop
   16648:	41008000 	.word	0x41008000
   1664c:	1000c000 	.word	0x1000c000

Disassembly of section .text.__swbuf_r%332:

00016650 <__swbuf_r>:
   16650:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16652:	460e      	mov	r6, r1
   16654:	4614      	mov	r4, r2
   16656:	4605      	mov	r5, r0
   16658:	b118      	cbz	r0, 16662 <__swbuf_r+0x12>
   1665a:	6983      	ldr	r3, [r0, #24]
   1665c:	b90b      	cbnz	r3, 16662 <__swbuf_r+0x12>
   1665e:	f005 f8a7 	bl	1b7b0 <__sinit>
   16662:	4b27      	ldr	r3, [pc, #156]	; (16700 <__swbuf_r+0xb0>)
   16664:	429c      	cmp	r4, r3
   16666:	d130      	bne.n	166ca <__swbuf_r+0x7a>
   16668:	686c      	ldr	r4, [r5, #4]
   1666a:	69a3      	ldr	r3, [r4, #24]
   1666c:	60a3      	str	r3, [r4, #8]
   1666e:	89a3      	ldrh	r3, [r4, #12]
   16670:	0719      	lsls	r1, r3, #28
   16672:	d534      	bpl.n	166de <__swbuf_r+0x8e>
   16674:	6923      	ldr	r3, [r4, #16]
   16676:	2b00      	cmp	r3, #0
   16678:	d031      	beq.n	166de <__swbuf_r+0x8e>
   1667a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   1667e:	b2f6      	uxtb	r6, r6
   16680:	049a      	lsls	r2, r3, #18
   16682:	4637      	mov	r7, r6
   16684:	d534      	bpl.n	166f0 <__swbuf_r+0xa0>
   16686:	6923      	ldr	r3, [r4, #16]
   16688:	6820      	ldr	r0, [r4, #0]
   1668a:	1ac0      	subs	r0, r0, r3
   1668c:	6963      	ldr	r3, [r4, #20]
   1668e:	4283      	cmp	r3, r0
   16690:	dc04      	bgt.n	1669c <__swbuf_r+0x4c>
   16692:	4621      	mov	r1, r4
   16694:	4628      	mov	r0, r5
   16696:	f005 fe93 	bl	1c3c0 <_fflush_r>
   1669a:	bb30      	cbnz	r0, 166ea <__swbuf_r+0x9a>
   1669c:	68a3      	ldr	r3, [r4, #8]
   1669e:	3b01      	subs	r3, #1
   166a0:	60a3      	str	r3, [r4, #8]
   166a2:	6823      	ldr	r3, [r4, #0]
   166a4:	1c5a      	adds	r2, r3, #1
   166a6:	6022      	str	r2, [r4, #0]
   166a8:	701e      	strb	r6, [r3, #0]
   166aa:	6963      	ldr	r3, [r4, #20]
   166ac:	3001      	adds	r0, #1
   166ae:	4283      	cmp	r3, r0
   166b0:	d004      	beq.n	166bc <__swbuf_r+0x6c>
   166b2:	89a3      	ldrh	r3, [r4, #12]
   166b4:	07db      	lsls	r3, r3, #31
   166b6:	d506      	bpl.n	166c6 <__swbuf_r+0x76>
   166b8:	2e0a      	cmp	r6, #10
   166ba:	d104      	bne.n	166c6 <__swbuf_r+0x76>
   166bc:	4621      	mov	r1, r4
   166be:	4628      	mov	r0, r5
   166c0:	f005 fe7e 	bl	1c3c0 <_fflush_r>
   166c4:	b988      	cbnz	r0, 166ea <__swbuf_r+0x9a>
   166c6:	4638      	mov	r0, r7
   166c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   166ca:	4b0e      	ldr	r3, [pc, #56]	; (16704 <__swbuf_r+0xb4>)
   166cc:	429c      	cmp	r4, r3
   166ce:	d101      	bne.n	166d4 <__swbuf_r+0x84>
   166d0:	68ac      	ldr	r4, [r5, #8]
   166d2:	e7ca      	b.n	1666a <__swbuf_r+0x1a>
   166d4:	4b0c      	ldr	r3, [pc, #48]	; (16708 <__swbuf_r+0xb8>)
   166d6:	429c      	cmp	r4, r3
   166d8:	bf08      	it	eq
   166da:	68ec      	ldreq	r4, [r5, #12]
   166dc:	e7c5      	b.n	1666a <__swbuf_r+0x1a>
   166de:	4621      	mov	r1, r4
   166e0:	4628      	mov	r0, r5
   166e2:	f7fe febf 	bl	15464 <__swsetup_r>
   166e6:	2800      	cmp	r0, #0
   166e8:	d0c7      	beq.n	1667a <__swbuf_r+0x2a>
   166ea:	f04f 37ff 	mov.w	r7, #4294967295
   166ee:	e7ea      	b.n	166c6 <__swbuf_r+0x76>
   166f0:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   166f4:	81a3      	strh	r3, [r4, #12]
   166f6:	6e23      	ldr	r3, [r4, #96]	; 0x60
   166f8:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
   166fc:	6623      	str	r3, [r4, #96]	; 0x60
   166fe:	e7c2      	b.n	16686 <__swbuf_r+0x36>
   16700:	2000e130 	.word	0x2000e130
   16704:	2000e150 	.word	0x2000e150
   16708:	2000e110 	.word	0x2000e110

Disassembly of section .text._GetMaxSegSizeOption%333:

0001670c <_GetMaxSegSizeOption>:
	vOptionsBytes = (h->DataOffset.Val << 2) - sizeof(*h);
   1670c:	7b03      	ldrb	r3, [r0, #12]
   1670e:	f3c3 1303 	ubfx	r3, r3, #4, #4
   16712:	009b      	lsls	r3, r3, #2
   16714:	3b14      	subs	r3, #20
    if(vOptionsBytes == 0u)
   16716:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
   1671a:	d043      	beq.n	167a4 <_GetMaxSegSizeOption+0x98>
{
   1671c:	b470      	push	{r4, r5, r6}
   1671e:	b083      	sub	sp, #12
    pOption = (uint8_t*)(h + 1);
   16720:	3014      	adds	r0, #20
    pEnd = pOption + vOptionsBytes;
   16722:	18c6      	adds	r6, r0, r3
    while(vOptionsBytes-- && pOption < pEnd)
   16724:	e01f      	b.n	16766 <_GetMaxSegSizeOption+0x5a>
            if(vOptionsBytes < 3u)
   16726:	2b02      	cmp	r3, #2
   16728:	d942      	bls.n	167b0 <_GetMaxSegSizeOption+0xa4>
            wMSS = 0;
   1672a:	2300      	movs	r3, #0
   1672c:	f8ad 3006 	strh.w	r3, [sp, #6]
            if(vOption == 4u)
   16730:	7853      	ldrb	r3, [r2, #1]
   16732:	2b04      	cmp	r3, #4
   16734:	d00c      	beq.n	16750 <_GetMaxSegSizeOption+0x44>
            if(wMSS < TCP_MIN_DEFAULT_MTU)
   16736:	f8bd 0006 	ldrh.w	r0, [sp, #6]
   1673a:	f240 53b4 	movw	r3, #1460	; 0x5b4
   1673e:	4298      	cmp	r0, r3
   16740:	bf28      	it	cs
   16742:	4618      	movcs	r0, r3
   16744:	f5b0 7f06 	cmp.w	r0, #536	; 0x218
   16748:	bf38      	it	cc
   1674a:	f44f 7006 	movcc.w	r0, #536	; 0x218
   1674e:	e037      	b.n	167c0 <_GetMaxSegSizeOption+0xb4>
                ((uint8_t*)&wMSS)[1] = *pOption++;
   16750:	7893      	ldrb	r3, [r2, #2]
   16752:	f88d 3007 	strb.w	r3, [sp, #7]
                ((uint8_t*)&wMSS)[0] = *pOption++;
   16756:	78d3      	ldrb	r3, [r2, #3]
   16758:	f88d 3006 	strb.w	r3, [sp, #6]
   1675c:	e7eb      	b.n	16736 <_GetMaxSegSizeOption+0x2a>
            pOption += vOption;
   1675e:	1c88      	adds	r0, r1, #2
   16760:	4410      	add	r0, r2
            vOptionsBytes -= vOption;
   16762:	1a5b      	subs	r3, r3, r1
   16764:	b2db      	uxtb	r3, r3
   16766:	18c5      	adds	r5, r0, r3
{
   16768:	4602      	mov	r2, r0
   1676a:	3b01      	subs	r3, #1
   1676c:	4418      	add	r0, r3
   1676e:	1a83      	subs	r3, r0, r2
   16770:	b2db      	uxtb	r3, r3
    while(vOptionsBytes-- && pOption < pEnd)
   16772:	42aa      	cmp	r2, r5
   16774:	d022      	beq.n	167bc <_GetMaxSegSizeOption+0xb0>
   16776:	42b2      	cmp	r2, r6
   16778:	d211      	bcs.n	1679e <_GetMaxSegSizeOption+0x92>
        vOption = *pOption++;
   1677a:	4614      	mov	r4, r2
   1677c:	f814 1b01 	ldrb.w	r1, [r4], #1
        if(vOption == 0u)	// End of Options list
   16780:	b199      	cbz	r1, 167aa <_GetMaxSegSizeOption+0x9e>
        if(vOption == 1u)	// NOP option
   16782:	2901      	cmp	r1, #1
   16784:	d009      	beq.n	1679a <_GetMaxSegSizeOption+0x8e>
        if(vOption == 2u)	// Maximum Segment Size option
   16786:	2902      	cmp	r1, #2
   16788:	d0cd      	beq.n	16726 <_GetMaxSegSizeOption+0x1a>
            if(vOptionsBytes < 2u)
   1678a:	2b01      	cmp	r3, #1
   1678c:	d913      	bls.n	167b6 <_GetMaxSegSizeOption+0xaa>
            vOption = *pOption++;
   1678e:	7851      	ldrb	r1, [r2, #1]
            if(vOptionsBytes < vOption)
   16790:	4299      	cmp	r1, r3
   16792:	d9e4      	bls.n	1675e <_GetMaxSegSizeOption+0x52>
    return TCP_MIN_DEFAULT_MTU;
   16794:	f44f 7006 	mov.w	r0, #536	; 0x218
   16798:	e012      	b.n	167c0 <_GetMaxSegSizeOption+0xb4>
        vOption = *pOption++;
   1679a:	4622      	mov	r2, r4
   1679c:	e7e7      	b.n	1676e <_GetMaxSegSizeOption+0x62>
    return TCP_MIN_DEFAULT_MTU;
   1679e:	f44f 7006 	mov.w	r0, #536	; 0x218
   167a2:	e00d      	b.n	167c0 <_GetMaxSegSizeOption+0xb4>
        return TCP_MIN_DEFAULT_MTU;
   167a4:	f44f 7006 	mov.w	r0, #536	; 0x218
}
   167a8:	4770      	bx	lr
    return TCP_MIN_DEFAULT_MTU;
   167aa:	f44f 7006 	mov.w	r0, #536	; 0x218
   167ae:	e007      	b.n	167c0 <_GetMaxSegSizeOption+0xb4>
   167b0:	f44f 7006 	mov.w	r0, #536	; 0x218
   167b4:	e004      	b.n	167c0 <_GetMaxSegSizeOption+0xb4>
   167b6:	f44f 7006 	mov.w	r0, #536	; 0x218
   167ba:	e001      	b.n	167c0 <_GetMaxSegSizeOption+0xb4>
   167bc:	f44f 7006 	mov.w	r0, #536	; 0x218
}
   167c0:	b003      	add	sp, #12
   167c2:	bc70      	pop	{r4, r5, r6}
   167c4:	4770      	bx	lr

Disassembly of section .text.CommandIperfStop%334:

000167c8 <CommandIperfStop>:
{
   167c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   167ca:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   167cc:	6845      	ldr	r5, [r0, #4]
    if(argc == 1)
   167ce:	2901      	cmp	r1, #1
   167d0:	d008      	beq.n	167e4 <CommandIperfStop+0x1c>
   167d2:	4616      	mov	r6, r2
    else if(argc == 3)
   167d4:	2903      	cmp	r1, #3
   167d6:	d020      	beq.n	1681a <CommandIperfStop+0x52>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: iperfk <-i index>\r\n");
   167d8:	6823      	ldr	r3, [r4, #0]
   167da:	681b      	ldr	r3, [r3, #0]
   167dc:	491f      	ldr	r1, [pc, #124]	; (1685c <CommandIperfStop+0x94>)
   167de:	4628      	mov	r0, r5
   167e0:	4798      	blx	r3
}
   167e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperfk: Using index 0\r\n");
   167e4:	6803      	ldr	r3, [r0, #0]
   167e6:	681b      	ldr	r3, [r3, #0]
   167e8:	491d      	ldr	r1, [pc, #116]	; (16860 <CommandIperfStop+0x98>)
   167ea:	4628      	mov	r0, r5
   167ec:	4798      	blx	r3
    int iperfIndex = 0;
   167ee:	2200      	movs	r2, #0
    if(iperfIndex < 0 || iperfIndex >= nIperfSessions)
   167f0:	4b1c      	ldr	r3, [pc, #112]	; (16864 <CommandIperfStop+0x9c>)
   167f2:	681b      	ldr	r3, [r3, #0]
   167f4:	4293      	cmp	r3, r2
   167f6:	dd21      	ble.n	1683c <CommandIperfStop+0x74>
    pIState = gIperfState + iperfIndex;	
   167f8:	491b      	ldr	r1, [pc, #108]	; (16868 <CommandIperfStop+0xa0>)
   167fa:	23d8      	movs	r3, #216	; 0xd8
   167fc:	fb03 1302 	mla	r3, r3, r2, r1
    if(pIState->state == IPERF_STANDBY_STATE)
   16800:	f893 10ce 	ldrb.w	r1, [r3, #206]	; 0xce
   16804:	2901      	cmp	r1, #1
   16806:	d022      	beq.n	1684e <CommandIperfStop+0x86>
        pIState->stopRequested = true;
   16808:	2101      	movs	r1, #1
   1680a:	f883 10cf 	strb.w	r1, [r3, #207]	; 0xcf
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: trying to stop iperf instance %d...\r\n", iperfIndex);
   1680e:	6823      	ldr	r3, [r4, #0]
   16810:	685b      	ldr	r3, [r3, #4]
   16812:	4916      	ldr	r1, [pc, #88]	; (1686c <CommandIperfStop+0xa4>)
   16814:	4628      	mov	r0, r5
   16816:	4798      	blx	r3
   16818:	e7e3      	b.n	167e2 <CommandIperfStop+0x1a>
        if((strcmp(argv[1], "-i") == 0) || (strcmp(argv[1], "--index") == 0))
   1681a:	6857      	ldr	r7, [r2, #4]
   1681c:	4914      	ldr	r1, [pc, #80]	; (16870 <CommandIperfStop+0xa8>)
   1681e:	4638      	mov	r0, r7
   16820:	f00b f8fc 	bl	21a1c <strcmp>
   16824:	b128      	cbz	r0, 16832 <CommandIperfStop+0x6a>
   16826:	4913      	ldr	r1, [pc, #76]	; (16874 <CommandIperfStop+0xac>)
   16828:	4638      	mov	r0, r7
   1682a:	f00b f8f7 	bl	21a1c <strcmp>
   1682e:	2800      	cmp	r0, #0
   16830:	d1d2      	bne.n	167d8 <CommandIperfStop+0x10>
            iperfIndex = atoi(argv[2]);
   16832:	68b0      	ldr	r0, [r6, #8]
   16834:	f00b fce4 	bl	22200 <atoi>
    if(iperfIndex < 0 || iperfIndex >= nIperfSessions)
   16838:	1e02      	subs	r2, r0, #0
   1683a:	dad9      	bge.n	167f0 <CommandIperfStop+0x28>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: Invalid session number. Min: 0, Max: %d\r\n", nIperfSessions - 1);
   1683c:	4b09      	ldr	r3, [pc, #36]	; (16864 <CommandIperfStop+0x9c>)
   1683e:	681a      	ldr	r2, [r3, #0]
   16840:	6823      	ldr	r3, [r4, #0]
   16842:	685b      	ldr	r3, [r3, #4]
   16844:	3a01      	subs	r2, #1
   16846:	490c      	ldr	r1, [pc, #48]	; (16878 <CommandIperfStop+0xb0>)
   16848:	4628      	mov	r0, r5
   1684a:	4798      	blx	r3
        return;
   1684c:	e7c9      	b.n	167e2 <CommandIperfStop+0x1a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "\r\niperf session: not started!\r\n");
   1684e:	6823      	ldr	r3, [r4, #0]
   16850:	681b      	ldr	r3, [r3, #0]
   16852:	490a      	ldr	r1, [pc, #40]	; (1687c <CommandIperfStop+0xb4>)
   16854:	4628      	mov	r0, r5
   16856:	4798      	blx	r3
   16858:	e7c3      	b.n	167e2 <CommandIperfStop+0x1a>
   1685a:	bf00      	nop
   1685c:	00005928 	.word	0x00005928
   16860:	000058c0 	.word	0x000058c0
   16864:	2000e3f0 	.word	0x2000e3f0
   16868:	2000d9b0 	.word	0x2000d9b0
   1686c:	000058f8 	.word	0x000058f8
   16870:	000057f0 	.word	0x000057f0
   16874:	000057f4 	.word	0x000057f4
   16878:	00005818 	.word	0x00005818
   1687c:	000058d8 	.word	0x000058d8

Disassembly of section .text.TCPIP_IPERF_Initialize%335:

00016880 <TCPIP_IPERF_Initialize>:
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_UP)
   16880:	7f03      	ldrb	r3, [r0, #28]
   16882:	2b03      	cmp	r3, #3
   16884:	d047      	beq.n	16916 <TCPIP_IPERF_Initialize+0x96>
{
   16886:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if(iperfInitCount == 0)
   1688a:	4b25      	ldr	r3, [pc, #148]	; (16920 <TCPIP_IPERF_Initialize+0xa0>)
   1688c:	681e      	ldr	r6, [r3, #0]
   1688e:	2e00      	cmp	r6, #0
   16890:	d139      	bne.n	16906 <TCPIP_IPERF_Initialize+0x86>
        nIperfSessions = sizeof(gIperfState) / sizeof(*gIperfState);
   16892:	4b24      	ldr	r3, [pc, #144]	; (16924 <TCPIP_IPERF_Initialize+0xa4>)
   16894:	2201      	movs	r2, #1
   16896:	601a      	str	r2, [r3, #0]
        for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
   16898:	4c23      	ldr	r4, [pc, #140]	; (16928 <TCPIP_IPERF_Initialize+0xa8>)
	        memset( pIState, 0, sizeof(*pIState) );
   1689a:	2500      	movs	r5, #0
	        pIState->signalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_IPERF_Task, 0);
   1689c:	4f23      	ldr	r7, [pc, #140]	; (1692c <TCPIP_IPERF_Initialize+0xac>)
        for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
   1689e:	4698      	mov	r8, r3
	        memset( pIState, 0, sizeof(*pIState) );
   168a0:	22d8      	movs	r2, #216	; 0xd8
   168a2:	4629      	mov	r1, r5
   168a4:	4620      	mov	r0, r4
   168a6:	f00b f9f1 	bl	21c8c <memset>
	        pIState->state = IPERF_STANDBY_STATE;
   168aa:	2301      	movs	r3, #1
   168ac:	f884 30ce 	strb.w	r3, [r4, #206]	; 0xce
	        pIState->stopRequested = false;
   168b0:	f884 50cf 	strb.w	r5, [r4, #207]	; 0xcf
	        pIState->tcpClientSock = INVALID_SOCKET;
   168b4:	f64f 73ff 	movw	r3, #65535	; 0xffff
   168b8:	8763      	strh	r3, [r4, #58]	; 0x3a
	        pIState->tcpServerSock = INVALID_SOCKET;
   168ba:	8723      	strh	r3, [r4, #56]	; 0x38
	        pIState->udpSock = INVALID_SOCKET;
   168bc:	87a3      	strh	r3, [r4, #60]	; 0x3c
	        pIState->txBuffSize = TCPIP_IPERF_TX_BUFFER_SIZE;
   168be:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   168c2:	f8c4 20b8 	str.w	r2, [r4, #184]	; 0xb8
	        pIState->rxBuffSize = TCPIP_IPERF_RX_BUFFER_SIZE;
   168c6:	f8c4 20bc 	str.w	r2, [r4, #188]	; 0xbc
               pIState->waitCount = 0;
   168ca:	f884 50d5 	strb.w	r5, [r4, #213]	; 0xd5
               pIState->sockWaitToSend = 0;
   168ce:	f884 50d4 	strb.w	r5, [r4, #212]	; 0xd4
               pIState->mTypeOfService = 0xFF;
   168d2:	7523      	strb	r3, [r4, #20]
	        pIState->signalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_IPERF_Task, 0);
   168d4:	462a      	mov	r2, r5
   168d6:	4639      	mov	r1, r7
   168d8:	2020      	movs	r0, #32
   168da:	f006 fb71 	bl	1cfc0 <_TCPIPStackSignalHandlerRegister>
   168de:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
	        if(pIState->signalHandle == 0)
   168e2:	b1d8      	cbz	r0, 1691c <TCPIP_IPERF_Initialize+0x9c>
        for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
   168e4:	3601      	adds	r6, #1
   168e6:	34d8      	adds	r4, #216	; 0xd8
   168e8:	f8d8 3000 	ldr.w	r3, [r8]
   168ec:	42b3      	cmp	r3, r6
   168ee:	dcd7      	bgt.n	168a0 <TCPIP_IPERF_Initialize+0x20>
		if(!SYS_CMD_ADDGRP(iperfCmdTbl, sizeof(iperfCmdTbl)/sizeof(*iperfCmdTbl), "iperf", ": iperf commands"))
   168f0:	4a0f      	ldr	r2, [pc, #60]	; (16930 <TCPIP_IPERF_Initialize+0xb0>)
   168f2:	f602 13f8 	addw	r3, r2, #2552	; 0x9f8
   168f6:	f602 220c 	addw	r2, r2, #2572	; 0xa0c
   168fa:	2104      	movs	r1, #4
   168fc:	480d      	ldr	r0, [pc, #52]	; (16934 <TCPIP_IPERF_Initialize+0xb4>)
   168fe:	f004 f897 	bl	1aa30 <SYS_CMD_ADDGRP>
   16902:	4603      	mov	r3, r0
   16904:	b120      	cbz	r0, 16910 <TCPIP_IPERF_Initialize+0x90>
    iperfInitCount++;
   16906:	4a06      	ldr	r2, [pc, #24]	; (16920 <TCPIP_IPERF_Initialize+0xa0>)
   16908:	6813      	ldr	r3, [r2, #0]
   1690a:	3301      	adds	r3, #1
   1690c:	6013      	str	r3, [r2, #0]
    return true;
   1690e:	2301      	movs	r3, #1
}
   16910:	4618      	mov	r0, r3
   16912:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return true;
   16916:	2301      	movs	r3, #1
}
   16918:	4618      	mov	r0, r3
   1691a:	4770      	bx	lr
	            return false;
   1691c:	2300      	movs	r3, #0
   1691e:	e7f7      	b.n	16910 <TCPIP_IPERF_Initialize+0x90>
   16920:	2000e3ec 	.word	0x2000e3ec
   16924:	2000e3f0 	.word	0x2000e3f0
   16928:	2000d9b0 	.word	0x2000d9b0
   1692c:	000027c1 	.word	0x000027c1
   16930:	000057b4 	.word	0x000057b4
   16934:	0001f178 	.word	0x0001f178

Disassembly of section .text.TCPIP_IPV4_ArpHandler%336:

00016938 <TCPIP_IPV4_ArpHandler>:
{
   16938:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1693c:	b084      	sub	sp, #16
   1693e:	460f      	mov	r7, r1
   16940:	4690      	mov	r8, r2
   16942:	469a      	mov	sl, r3
    TCPIP_Helper_SingleListInitialize (&newList);
   16944:	a801      	add	r0, sp, #4
   16946:	f00b fbe9 	bl	2211c <TCPIP_Helper_SingleListInitialize>
    TCPIP_Helper_ProtectedSingleListLock(&ipv4ArpQueue);
   1694a:	4827      	ldr	r0, [pc, #156]	; (169e8 <TCPIP_IPV4_ArpHandler+0xb0>)
   1694c:	f00a f8b0 	bl	20ab0 <TCPIP_Helper_ProtectedSingleListLock>
    while((pEntry = (IPV4_ARP_ENTRY*)TCPIP_Helper_SingleListHeadRemove(arpList)) != 0)
   16950:	4e25      	ldr	r6, [pc, #148]	; (169e8 <TCPIP_IPV4_ArpHandler+0xb0>)
            TCPIP_Helper_SingleListTailAdd(&ipv4ArpPool, (SGL_LIST_NODE*)pEntry); 
   16952:	f8df 9098 	ldr.w	r9, [pc, #152]	; 169ec <TCPIP_IPV4_ArpHandler+0xb4>
    while((pEntry = (IPV4_ARP_ENTRY*)TCPIP_Helper_SingleListHeadRemove(arpList)) != 0)
   16956:	e00b      	b.n	16970 <TCPIP_IPV4_ArpHandler+0x38>
            pMacPkt = &pEntry->pTxPkt->macPkt;
   16958:	68a5      	ldr	r5, [r4, #8]
   1695a:	e014      	b.n	16986 <TCPIP_IPV4_ArpHandler+0x4e>
                pktAckFail = TCPIP_MAC_PKT_ACK_ARP_TMO; 
   1695c:	f06f 0103 	mvn.w	r1, #3
        TCPIP_PKT_PacketAcknowledge(pTxPkt, ackRes);
   16960:	2203      	movs	r2, #3
   16962:	4628      	mov	r0, r5
   16964:	f007 f946 	bl	1dbf4 <_TCPIP_PKT_PacketAcknowledge>
            TCPIP_Helper_SingleListTailAdd(&ipv4ArpPool, (SGL_LIST_NODE*)pEntry); 
   16968:	4621      	mov	r1, r4
   1696a:	4648      	mov	r0, r9
   1696c:	f00a fca8 	bl	212c0 <TCPIP_Helper_SingleListTailAdd>
    while((pEntry = (IPV4_ARP_ENTRY*)TCPIP_Helper_SingleListHeadRemove(arpList)) != 0)
   16970:	4630      	mov	r0, r6
   16972:	f00a fad1 	bl	20f18 <TCPIP_Helper_SingleListHeadRemove>
   16976:	4604      	mov	r4, r0
   16978:	b348      	cbz	r0, 169ce <TCPIP_IPV4_ArpHandler+0x96>
        if(pEntry->type == IPV4_ARP_PKT_TYPE_TX)
   1697a:	7923      	ldrb	r3, [r4, #4]
   1697c:	2b01      	cmp	r3, #1
   1697e:	d0eb      	beq.n	16958 <TCPIP_IPV4_ArpHandler+0x20>
        else if(pEntry->type == IPV4_ARP_PKT_TYPE_MAC)
   16980:	2b02      	cmp	r3, #2
   16982:	d12d      	bne.n	169e0 <TCPIP_IPV4_ArpHandler+0xa8>
            pMacPkt = pEntry->pMacPkt;
   16984:	68a5      	ldr	r5, [r4, #8]
        pPktIf = (TCPIP_NET_IF*)TCPIP_STACK_IndexToNet(pEntry->arpIfIx);
   16986:	7960      	ldrb	r0, [r4, #5]
   16988:	f009 fae8 	bl	1ff5c <TCPIP_STACK_IndexToNet>
        if(pEntry->arpTarget.Val == ipAdd->Val)
   1698c:	68e2      	ldr	r2, [r4, #12]
   1698e:	683b      	ldr	r3, [r7, #0]
   16990:	429a      	cmp	r2, r3
   16992:	d117      	bne.n	169c4 <TCPIP_IPV4_ArpHandler+0x8c>
            if(evType >= 0)
   16994:	f1ba 0f00 	cmp.w	sl, #0
   16998:	dbe0      	blt.n	1695c <TCPIP_IPV4_ArpHandler+0x24>
                memcpy(&macHdr->DestMACAddr, MACAddr, sizeof(*MACAddr));
   1699a:	696b      	ldr	r3, [r5, #20]
   1699c:	f8d8 2000 	ldr.w	r2, [r8]
   169a0:	601a      	str	r2, [r3, #0]
   169a2:	f8b8 2004 	ldrh.w	r2, [r8, #4]
   169a6:	809a      	strh	r2, [r3, #4]
                pMacPkt->next = 0;  // send single packet
   169a8:	2300      	movs	r3, #0
   169aa:	602b      	str	r3, [r5, #0]
                if(pPktIf == 0 || !TCPIP_IPV4_TxMacPkt(pPktIf, pMacPkt))
   169ac:	b138      	cbz	r0, 169be <TCPIP_IPV4_ArpHandler+0x86>
    return _TCPIPStackPacketTx(pNetIf, pPkt) == TCPIP_MAC_RES_OK;
   169ae:	4629      	mov	r1, r5
   169b0:	f00a ff28 	bl	21804 <_TCPIPStackPacketTx>
                if(pPktIf == 0 || !TCPIP_IPV4_TxMacPkt(pPktIf, pMacPkt))
   169b4:	2800      	cmp	r0, #0
   169b6:	d0d7      	beq.n	16968 <TCPIP_IPV4_ArpHandler+0x30>
                    pktAckFail = TCPIP_MAC_PKT_ACK_ARP_NET_ERR; 
   169b8:	f06f 0104 	mvn.w	r1, #4
   169bc:	e7d0      	b.n	16960 <TCPIP_IPV4_ArpHandler+0x28>
   169be:	f06f 0104 	mvn.w	r1, #4
   169c2:	e7cd      	b.n	16960 <TCPIP_IPV4_ArpHandler+0x28>
            TCPIP_Helper_SingleListTailAdd(&newList, (SGL_LIST_NODE*)pEntry);
   169c4:	4621      	mov	r1, r4
   169c6:	a801      	add	r0, sp, #4
   169c8:	f00a fc7a 	bl	212c0 <TCPIP_Helper_SingleListTailAdd>
   169cc:	e7d0      	b.n	16970 <TCPIP_IPV4_ArpHandler+0x38>
    ipv4ArpQueue.list = newList;
   169ce:	4b06      	ldr	r3, [pc, #24]	; (169e8 <TCPIP_IPV4_ArpHandler+0xb0>)
   169d0:	aa04      	add	r2, sp, #16
   169d2:	e912 0007 	ldmdb	r2, {r0, r1, r2}
   169d6:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    TCPIP_Helper_ProtectedSingleListUnlock(&ipv4ArpQueue);
   169da:	4618      	mov	r0, r3
   169dc:	f00a faaa 	bl	20f34 <TCPIP_Helper_ProtectedSingleListUnlock>
}
   169e0:	b004      	add	sp, #16
   169e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   169e6:	bf00      	nop
   169e8:	2000e228 	.word	0x2000e228
   169ec:	2000e328 	.word	0x2000e328

Disassembly of section .text.wc_Md5Final%337:

000169f0 <wc_Md5Final>:

int wc_Md5Final(wc_Md5* md5, byte* hash)
{
    byte* local;

    if (md5 == NULL || hash == NULL) {
   169f0:	2800      	cmp	r0, #0
   169f2:	d051      	beq.n	16a98 <wc_Md5Final+0xa8>
{
   169f4:	b570      	push	{r4, r5, r6, lr}
   169f6:	4604      	mov	r4, r0
    if (md5 == NULL || hash == NULL) {
   169f8:	2900      	cmp	r1, #0
   169fa:	d050      	beq.n	16a9e <wc_Md5Final+0xae>
   169fc:	460d      	mov	r5, r1
        return IntelQaSymMd5(&md5->asyncDev, hash, NULL, WC_MD5_DIGEST_SIZE);
#endif
    }
#endif /* WOLFSSL_ASYNC_CRYPT */

    local = (byte*)md5->buffer;
   169fe:	4606      	mov	r6, r0

    local[md5->buffLen++] = 0x80;  /* add 1 */
   16a00:	f856 3b0c 	ldr.w	r3, [r6], #12
   16a04:	1c5a      	adds	r2, r3, #1
   16a06:	6002      	str	r2, [r0, #0]
   16a08:	2280      	movs	r2, #128	; 0x80
   16a0a:	54f2      	strb	r2, [r6, r3]

    /* pad with zeros */
    if (md5->buffLen > WC_MD5_PAD_SIZE) {
   16a0c:	6800      	ldr	r0, [r0, #0]
   16a0e:	2838      	cmp	r0, #56	; 0x38
   16a10:	d833      	bhi.n	16a7a <wc_Md5Final+0x8a>
        ByteReverseWords(md5->buffer, md5->buffer, WC_MD5_BLOCK_SIZE);
#endif
        XTRANSFORM(md5, local);
        md5->buffLen = 0;
    }
    XMEMSET(&local[md5->buffLen], 0, WC_MD5_PAD_SIZE - md5->buffLen);
   16a12:	6820      	ldr	r0, [r4, #0]
   16a14:	f1c0 0238 	rsb	r2, r0, #56	; 0x38
   16a18:	2100      	movs	r1, #0
   16a1a:	4430      	add	r0, r6
   16a1c:	f00b f936 	bl	21c8c <memset>
#if defined(BIG_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
    ByteReverseWords(md5->buffer, md5->buffer, WC_MD5_BLOCK_SIZE);
#endif

    /* put lengths in bits */
    md5->hiLen = (md5->loLen >> (8 * sizeof(md5->loLen) - 3)) +
   16a20:	6863      	ldr	r3, [r4, #4]
                 (md5->hiLen << 3);
   16a22:	68a1      	ldr	r1, [r4, #8]
    md5->hiLen = (md5->loLen >> (8 * sizeof(md5->loLen) - 3)) +
   16a24:	0f5a      	lsrs	r2, r3, #29
   16a26:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
   16a2a:	60a2      	str	r2, [r4, #8]
    md5->loLen = md5->loLen << 3;
   16a2c:	00db      	lsls	r3, r3, #3
   16a2e:	6063      	str	r3, [r4, #4]

    /* store lengths */
    /* ! length ordering dependent on digest endian type ! */
    XMEMCPY(&local[WC_MD5_PAD_SIZE], &md5->loLen, sizeof(word32));
   16a30:	6463      	str	r3, [r4, #68]	; 0x44
    XMEMCPY(&local[WC_MD5_PAD_SIZE + sizeof(word32)], &md5->hiLen, sizeof(word32));
   16a32:	64a2      	str	r2, [r4, #72]	; 0x48

    /* final transform and result to hash */
    XTRANSFORM(md5, local);
   16a34:	4631      	mov	r1, r6
   16a36:	4620      	mov	r0, r4
   16a38:	f7ef ff92 	bl	6960 <Transform>
#ifdef BIG_ENDIAN_ORDER
    ByteReverseWords(md5->digest, md5->digest, WC_MD5_DIGEST_SIZE);
#endif
    XMEMCPY(hash, md5->digest, WC_MD5_DIGEST_SIZE);
   16a3c:	4623      	mov	r3, r4
   16a3e:	f853 0f4c 	ldr.w	r0, [r3, #76]!
   16a42:	6859      	ldr	r1, [r3, #4]
   16a44:	689a      	ldr	r2, [r3, #8]
   16a46:	68db      	ldr	r3, [r3, #12]
   16a48:	6028      	str	r0, [r5, #0]
   16a4a:	6069      	str	r1, [r5, #4]
   16a4c:	60aa      	str	r2, [r5, #8]
   16a4e:	60eb      	str	r3, [r5, #12]
    md5->digest[0] = 0x67452301L;
   16a50:	4b14      	ldr	r3, [pc, #80]	; (16aa4 <wc_Md5Final+0xb4>)
   16a52:	64e3      	str	r3, [r4, #76]	; 0x4c
    md5->digest[1] = 0xefcdab89L;
   16a54:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
   16a58:	6523      	str	r3, [r4, #80]	; 0x50
    md5->digest[2] = 0x98badcfeL;
   16a5a:	f103 4329 	add.w	r3, r3, #2835349504	; 0xa9000000
   16a5e:	f5a3 1396 	sub.w	r3, r3, #1228800	; 0x12c000
   16a62:	f6a3 638b 	subw	r3, r3, #3723	; 0xe8b
   16a66:	6563      	str	r3, [r4, #84]	; 0x54
    md5->digest[3] = 0x10325476L;
   16a68:	f1a3 3388 	sub.w	r3, r3, #2290649224	; 0x88888888
   16a6c:	65a3      	str	r3, [r4, #88]	; 0x58
    md5->buffLen = 0;
   16a6e:	2000      	movs	r0, #0
   16a70:	6020      	str	r0, [r4, #0]
    md5->loLen   = 0;
   16a72:	6060      	str	r0, [r4, #4]
    md5->hiLen   = 0;
   16a74:	60a0      	str	r0, [r4, #8]
    md5->flags = 0;
   16a76:	6620      	str	r0, [r4, #96]	; 0x60

    return _InitMd5(md5); /* reset state */
}
   16a78:	bd70      	pop	{r4, r5, r6, pc}
        XMEMSET(&local[md5->buffLen], 0, WC_MD5_BLOCK_SIZE - md5->buffLen);
   16a7a:	f1c0 0240 	rsb	r2, r0, #64	; 0x40
   16a7e:	2100      	movs	r1, #0
   16a80:	4430      	add	r0, r6
   16a82:	f00b f903 	bl	21c8c <memset>
        md5->buffLen += WC_MD5_BLOCK_SIZE - md5->buffLen;
   16a86:	2340      	movs	r3, #64	; 0x40
   16a88:	6023      	str	r3, [r4, #0]
        XTRANSFORM(md5, local);
   16a8a:	4631      	mov	r1, r6
   16a8c:	4620      	mov	r0, r4
   16a8e:	f7ef ff67 	bl	6960 <Transform>
        md5->buffLen = 0;
   16a92:	2300      	movs	r3, #0
   16a94:	6023      	str	r3, [r4, #0]
   16a96:	e7bc      	b.n	16a12 <wc_Md5Final+0x22>
        return BAD_FUNC_ARG;
   16a98:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
   16a9c:	4770      	bx	lr
        return BAD_FUNC_ARG;
   16a9e:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   16aa2:	e7e9      	b.n	16a78 <wc_Md5Final+0x88>
   16aa4:	67452301 	.word	0x67452301

Disassembly of section .text.gfx_mono_draw_char%338:

00016aa8 <gfx_mono_draw_char>:
 * \param[in] x        X coordinate on screen.
 * \param[in] y        Y coordinate on screen.
 * \param[in] font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
        const struct font *font) {
   16aa8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16aac:	b085      	sub	sp, #20
   16aae:	4607      	mov	r7, r0
   16ab0:	468a      	mov	sl, r1
   16ab2:	4615      	mov	r5, r2
   16ab4:	461e      	mov	r6, r3
    gfx_mono_draw_filled_rect(x, y, font->width, font->height,
   16ab6:	2300      	movs	r3, #0
   16ab8:	9300      	str	r3, [sp, #0]
   16aba:	7a73      	ldrb	r3, [r6, #9]
   16abc:	7a32      	ldrb	r2, [r6, #8]
   16abe:	4629      	mov	r1, r5
   16ac0:	4650      	mov	r0, sl
   16ac2:	f008 f9cd 	bl	1ee60 <gfx_mono_generic_draw_filled_rect>
            GFX_PIXEL_CLR);

    switch (font->type) {
   16ac6:	7833      	ldrb	r3, [r6, #0]
   16ac8:	2b00      	cmp	r3, #0
   16aca:	d13b      	bne.n	16b44 <gfx_mono_draw_char+0x9c>
    char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
   16acc:	7a32      	ldrb	r2, [r6, #8]
   16ace:	08d1      	lsrs	r1, r2, #3
    if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
   16ad0:	f012 0f07 	tst.w	r2, #7
        char_row_size++;
   16ad4:	bf18      	it	ne
   16ad6:	3101      	addne	r1, #1
    glyph_data_offset = char_row_size * font->height *
   16ad8:	f896 8009 	ldrb.w	r8, [r6, #9]
            ((uint8_t) ch - font->first_char);
   16adc:	7ab4      	ldrb	r4, [r6, #10]
   16ade:	1b3c      	subs	r4, r7, r4
    glyph_data_offset = char_row_size * font->height *
   16ae0:	fb14 f408 	smulbb	r4, r4, r8
   16ae4:	fb14 f401 	smulbb	r4, r4, r1
    glyph_data = font->data.progmem + glyph_data_offset;
   16ae8:	6872      	ldr	r2, [r6, #4]
   16aea:	fa12 f484 	uxtah	r4, r2, r4
    rows_left = font->height;
   16aee:	44a8      	add	r8, r5
   16af0:	fa5f f888 	uxtb.w	r8, r8
        uint8_t glyph_byte = 0;
   16af4:	9303      	str	r3, [sp, #12]
                gfx_mono_draw_pixel(inc_x, inc_y,
   16af6:	46a3      	mov	fp, r4
   16af8:	e01d      	b.n	16b36 <gfx_mono_draw_char+0x8e>
            glyph_byte <<= 1;
   16afa:	007f      	lsls	r7, r7, #1
   16afc:	b2ff      	uxtb	r7, r7
   16afe:	f109 0901 	add.w	r9, r9, #1
        for (i = 0; i < pixelsToDraw; i++) {
   16b02:	fa5f f389 	uxtb.w	r3, r9
   16b06:	429c      	cmp	r4, r3
   16b08:	d911      	bls.n	16b2e <gfx_mono_draw_char+0x86>
   16b0a:	fa5f f389 	uxtb.w	r3, r9
   16b0e:	eb0a 0003 	add.w	r0, sl, r3
   16b12:	b2c0      	uxtb	r0, r0
            if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
   16b14:	f013 0f07 	tst.w	r3, #7
                glyph_byte = PROGMEM_READ_BYTE(glyph_data);
   16b18:	bf08      	it	eq
   16b1a:	f81b 7b01 	ldrbeq.w	r7, [fp], #1
            if ((glyph_byte & 0x80)) {
   16b1e:	f017 0f80 	tst.w	r7, #128	; 0x80
   16b22:	d0ea      	beq.n	16afa <gfx_mono_draw_char+0x52>
                gfx_mono_draw_pixel(inc_x, inc_y,
   16b24:	2201      	movs	r2, #1
   16b26:	4629      	mov	r1, r5
   16b28:	f004 fe12 	bl	1b750 <gfx_mono_ssd1306_draw_pixel>
   16b2c:	e7e5      	b.n	16afa <gfx_mono_draw_char+0x52>
        inc_y += 1;
   16b2e:	3501      	adds	r5, #1
   16b30:	b2ed      	uxtb	r5, r5
    } while (rows_left > 0);
   16b32:	4545      	cmp	r5, r8
   16b34:	d00d      	beq.n	16b52 <gfx_mono_draw_char+0xaa>
        uint8_t pixelsToDraw = font->width;
   16b36:	7a34      	ldrb	r4, [r6, #8]
        for (i = 0; i < pixelsToDraw; i++) {
   16b38:	2c00      	cmp	r4, #0
   16b3a:	d0f8      	beq.n	16b2e <gfx_mono_draw_char+0x86>
        uint8_t glyph_byte = 0;
   16b3c:	9f03      	ldr	r7, [sp, #12]
        for (i = 0; i < pixelsToDraw; i++) {
   16b3e:	f04f 0900 	mov.w	r9, #0
   16b42:	e7e2      	b.n	16b0a <gfx_mono_draw_char+0x62>
            break;

#endif
        default:
            /* Unsupported mode, call assert */
            assert(false);
   16b44:	4804      	ldr	r0, [pc, #16]	; (16b58 <gfx_mono_draw_char+0xb0>)
   16b46:	4603      	mov	r3, r0
   16b48:	4a04      	ldr	r2, [pc, #16]	; (16b5c <gfx_mono_draw_char+0xb4>)
   16b4a:	21f0      	movs	r1, #240	; 0xf0
   16b4c:	3008      	adds	r0, #8
   16b4e:	f007 fc69 	bl	1e424 <__assert_func>
            break;
    }
}
   16b52:	b005      	add	sp, #20
   16b54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   16b58:	0001d720 	.word	0x0001d720
   16b5c:	00021a08 	.word	0x00021a08

Disassembly of section .text.__ssputs_r%339:

00016b60 <__ssputs_r>:
   16b60:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   16b64:	688e      	ldr	r6, [r1, #8]
   16b66:	429e      	cmp	r6, r3
   16b68:	4682      	mov	sl, r0
   16b6a:	460c      	mov	r4, r1
   16b6c:	4691      	mov	r9, r2
   16b6e:	4698      	mov	r8, r3
   16b70:	d838      	bhi.n	16be4 <__ssputs_r+0x84>
   16b72:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
   16b76:	f41c 6f90 	tst.w	ip, #1152	; 0x480
   16b7a:	d031      	beq.n	16be0 <__ssputs_r+0x80>
   16b7c:	6962      	ldr	r2, [r4, #20]
   16b7e:	6825      	ldr	r5, [r4, #0]
   16b80:	6909      	ldr	r1, [r1, #16]
   16b82:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   16b86:	1a6f      	subs	r7, r5, r1
   16b88:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
   16b8c:	3301      	adds	r3, #1
   16b8e:	1055      	asrs	r5, r2, #1
   16b90:	443b      	add	r3, r7
   16b92:	429d      	cmp	r5, r3
   16b94:	bf38      	it	cc
   16b96:	461d      	movcc	r5, r3
   16b98:	f41c 6f80 	tst.w	ip, #1024	; 0x400
   16b9c:	d030      	beq.n	16c00 <__ssputs_r+0xa0>
   16b9e:	4629      	mov	r1, r5
   16ba0:	f000 f8ee 	bl	16d80 <_malloc_r>
   16ba4:	4606      	mov	r6, r0
   16ba6:	b950      	cbnz	r0, 16bbe <__ssputs_r+0x5e>
   16ba8:	230c      	movs	r3, #12
   16baa:	f8ca 3000 	str.w	r3, [sl]
   16bae:	89a3      	ldrh	r3, [r4, #12]
   16bb0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   16bb4:	81a3      	strh	r3, [r4, #12]
   16bb6:	f04f 30ff 	mov.w	r0, #4294967295
   16bba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   16bbe:	463a      	mov	r2, r7
   16bc0:	6921      	ldr	r1, [r4, #16]
   16bc2:	f00a fadd 	bl	21180 <memcpy>
   16bc6:	89a3      	ldrh	r3, [r4, #12]
   16bc8:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
   16bcc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   16bd0:	81a3      	strh	r3, [r4, #12]
   16bd2:	6126      	str	r6, [r4, #16]
   16bd4:	6165      	str	r5, [r4, #20]
   16bd6:	443e      	add	r6, r7
   16bd8:	1bed      	subs	r5, r5, r7
   16bda:	6026      	str	r6, [r4, #0]
   16bdc:	60a5      	str	r5, [r4, #8]
   16bde:	4646      	mov	r6, r8
   16be0:	4546      	cmp	r6, r8
   16be2:	d900      	bls.n	16be6 <__ssputs_r+0x86>
   16be4:	4646      	mov	r6, r8
   16be6:	4632      	mov	r2, r6
   16be8:	4649      	mov	r1, r9
   16bea:	6820      	ldr	r0, [r4, #0]
   16bec:	f008 f952 	bl	1ee94 <memmove>
   16bf0:	68a3      	ldr	r3, [r4, #8]
   16bf2:	1b9b      	subs	r3, r3, r6
   16bf4:	60a3      	str	r3, [r4, #8]
   16bf6:	6823      	ldr	r3, [r4, #0]
   16bf8:	441e      	add	r6, r3
   16bfa:	6026      	str	r6, [r4, #0]
   16bfc:	2000      	movs	r0, #0
   16bfe:	e7dc      	b.n	16bba <__ssputs_r+0x5a>
   16c00:	462a      	mov	r2, r5
   16c02:	f005 ffdf 	bl	1cbc4 <_realloc_r>
   16c06:	4606      	mov	r6, r0
   16c08:	2800      	cmp	r0, #0
   16c0a:	d1e2      	bne.n	16bd2 <__ssputs_r+0x72>
   16c0c:	6921      	ldr	r1, [r4, #16]
   16c0e:	4650      	mov	r0, sl
   16c10:	f001 f980 	bl	17f14 <_free_r>
   16c14:	e7c8      	b.n	16ba8 <__ssputs_r+0x48>

Disassembly of section .text._ARPSendIfPkt%340:

00016c18 <_ARPSendIfPkt>:
{
   16c18:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   16c1c:	4607      	mov	r7, r0
   16c1e:	468a      	mov	sl, r1
   16c20:	4691      	mov	r9, r2
   16c22:	4698      	mov	r8, r3
   16c24:	9d08      	ldr	r5, [sp, #32]
   16c26:	9e09      	ldr	r6, [sp, #36]	; 0x24
    if(arpMod.pMacPkt != 0 && (arpMod.pMacPkt->pktFlags & TCPIP_MAC_PKT_FLAG_QUEUED) == 0)
   16c28:	4b27      	ldr	r3, [pc, #156]	; (16cc8 <_ARPSendIfPkt+0xb0>)
   16c2a:	6c9c      	ldr	r4, [r3, #72]	; 0x48
   16c2c:	b11c      	cbz	r4, 16c36 <_ARPSendIfPkt+0x1e>
   16c2e:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   16c30:	f013 0f08 	tst.w	r3, #8
   16c34:	d006      	beq.n	16c44 <_ARPSendIfPkt+0x2c>
        if((pMacPkt = _ARPAllocateTxPacket()) == 0)
   16c36:	f009 fc13 	bl	20460 <_ARPAllocateTxPacket>
   16c3a:	4604      	mov	r4, r0
   16c3c:	2800      	cmp	r0, #0
   16c3e:	d041      	beq.n	16cc4 <_ARPSendIfPkt+0xac>
        arpMod.pMacPkt = pMacPkt;   // show we're using this one now
   16c40:	4b21      	ldr	r3, [pc, #132]	; (16cc8 <_ARPSendIfPkt+0xb0>)
   16c42:	6498      	str	r0, [r3, #72]	; 0x48
    pArp = (ARP_PACKET*)pMacPkt->pNetLayer;
   16c44:	69a3      	ldr	r3, [r4, #24]
    pArp->HardwareType  = HW_ETHERNET;
   16c46:	2201      	movs	r2, #1
   16c48:	801a      	strh	r2, [r3, #0]
    pArp->Protocol      = ARP_IP;
   16c4a:	f44f 6200 	mov.w	r2, #2048	; 0x800
   16c4e:	805a      	strh	r2, [r3, #2]
    pArp->MACAddrLen    = sizeof(TCPIP_MAC_ADDR);
   16c50:	2206      	movs	r2, #6
   16c52:	711a      	strb	r2, [r3, #4]
    pArp->ProtocolLen   = sizeof(IPV4_ADDR);
   16c54:	2204      	movs	r2, #4
   16c56:	715a      	strb	r2, [r3, #5]
    pArp->Operation = oper;
   16c58:	f8a3 a006 	strh.w	sl, [r3, #6]
    if(srcMAC == 0)
   16c5c:	b30e      	cbz	r6, 16ca2 <_ARPSendIfPkt+0x8a>
        pArp->SenderMACAddr = *srcMAC;
   16c5e:	6832      	ldr	r2, [r6, #0]
   16c60:	609a      	str	r2, [r3, #8]
   16c62:	88b2      	ldrh	r2, [r6, #4]
   16c64:	819a      	strh	r2, [r3, #12]
    pArp->SenderIPAddr.Val  = srcIP;
   16c66:	f8c3 900e 	str.w	r9, [r3, #14]
    pArp->TargetMACAddr = *dstMAC;
   16c6a:	682a      	ldr	r2, [r5, #0]
   16c6c:	f8c3 2012 	str.w	r2, [r3, #18]
   16c70:	88aa      	ldrh	r2, [r5, #4]
   16c72:	82da      	strh	r2, [r3, #22]
    pArp->TargetIPAddr.Val  = dstIP;
   16c74:	f8c3 8018 	str.w	r8, [r3, #24]
    _SwapARPPacket(pArp);
   16c78:	4618      	mov	r0, r3
   16c7a:	f009 fef9 	bl	20a70 <_SwapARPPacket>
    pMacPkt->pDSeg->segLen = sizeof(ARP_PACKET);
   16c7e:	6923      	ldr	r3, [r4, #16]
   16c80:	221c      	movs	r2, #28
   16c82:	819a      	strh	r2, [r3, #12]
    if(TCPIP_PKT_PacketMACFormat(pMacPkt, dstMAC, (const TCPIP_MAC_ADDR*)TCPIP_STACK_NetUpMACAddressGet(pIf), TCPIP_ETHER_TYPE_ARP))
   16c84:	4638      	mov	r0, r7
   16c86:	f00a fe51 	bl	2192c <TCPIP_STACK_NetUpMACAddressGet>
   16c8a:	f640 0306 	movw	r3, #2054	; 0x806
   16c8e:	4602      	mov	r2, r0
   16c90:	4629      	mov	r1, r5
   16c92:	4620      	mov	r0, r4
   16c94:	f007 fd92 	bl	1e7bc <TCPIP_PKT_PacketMACFormat>
   16c98:	4603      	mov	r3, r0
   16c9a:	b940      	cbnz	r0, 16cae <_ARPSendIfPkt+0x96>
}
   16c9c:	4618      	mov	r0, r3
   16c9e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        pArp->SenderMACAddr = pIf->netMACAddr;
   16ca2:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   16ca4:	6098      	str	r0, [r3, #8]
   16ca6:	f8b7 2040 	ldrh.w	r2, [r7, #64]	; 0x40
   16caa:	819a      	strh	r2, [r3, #12]
   16cac:	e7db      	b.n	16c66 <_ARPSendIfPkt+0x4e>
        pMacPkt->next = 0;  // send single packet
   16cae:	2300      	movs	r3, #0
   16cb0:	6023      	str	r3, [r4, #0]
        pMacPkt->pktIf = pIf;
   16cb2:	62a7      	str	r7, [r4, #40]	; 0x28
        if(_TCPIPStackPacketTx(pIf, pMacPkt) >= 0)
   16cb4:	4621      	mov	r1, r4
   16cb6:	4638      	mov	r0, r7
   16cb8:	f00a fda4 	bl	21804 <_TCPIPStackPacketTx>
   16cbc:	43c0      	mvns	r0, r0
   16cbe:	f3c0 13c0 	ubfx	r3, r0, #7, #1
   16cc2:	e7eb      	b.n	16c9c <_ARPSendIfPkt+0x84>
            return false;
   16cc4:	2300      	movs	r3, #0
   16cc6:	e7e9      	b.n	16c9c <_ARPSendIfPkt+0x84>
   16cc8:	2000dfa4 	.word	0x2000dfa4

Disassembly of section .text.SYS_TIME_HwTimerCompareUpdate%341:

00016ccc <SYS_TIME_HwTimerCompareUpdate>:
{
   16ccc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    SYS_TIME_TIMER_OBJ* tmrActive = counterObj->tmrActive;
   16cd0:	4b2a      	ldr	r3, [pc, #168]	; (16d7c <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   16cd2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    counterObj->hwTimerPreviousValue = counterObj->hwTimerCurrentValue;
   16cd4:	6959      	ldr	r1, [r3, #20]
   16cd6:	6119      	str	r1, [r3, #16]
    if (tmrActive != NULL)
   16cd8:	2a00      	cmp	r2, #0
   16cda:	d040      	beq.n	16d5e <SYS_TIME_HwTimerCompareUpdate+0x92>
        if (tmrActive->relativeTimePending > SYS_TIME_HW_COUNTER_HALF_PERIOD)
   16cdc:	6893      	ldr	r3, [r2, #8]
   16cde:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   16ce2:	d333      	bcc.n	16d4c <SYS_TIME_HwTimerCompareUpdate+0x80>
            nextHwCounterValue = (uint64_t)counterObj->hwTimerCurrentValue + SYS_TIME_HW_COUNTER_HALF_PERIOD;
   16ce4:	4b25      	ldr	r3, [pc, #148]	; (16d7c <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   16ce6:	695b      	ldr	r3, [r3, #20]
   16ce8:	f647 74ff 	movw	r4, #32767	; 0x7fff
   16cec:	2500      	movs	r5, #0
   16cee:	eb14 0803 	adds.w	r8, r4, r3
   16cf2:	f145 0900 	adc.w	r9, r5, #0
    currHwCounterValue = counterObj->timePlib->timerCounterGet();
   16cf6:	4e21      	ldr	r6, [pc, #132]	; (16d7c <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   16cf8:	6873      	ldr	r3, [r6, #4]
   16cfa:	699b      	ldr	r3, [r3, #24]
   16cfc:	4798      	blx	r3
   16cfe:	b282      	uxth	r2, r0
   16d00:	2300      	movs	r3, #0
    if (currHwCounterValue < counterObj->hwTimerPreviousValue)
   16d02:	6931      	ldr	r1, [r6, #16]
   16d04:	4281      	cmp	r1, r0
   16d06:	d906      	bls.n	16d16 <SYS_TIME_HwTimerCompareUpdate+0x4a>
        currHwCounterValue = SYS_TIME_HW_COUNTER_PERIOD + currHwCounterValue;
   16d08:	f64f 71ff 	movw	r1, #65535	; 0xffff
   16d0c:	1852      	adds	r2, r2, r1
   16d0e:	f04f 0100 	mov.w	r1, #0
   16d12:	eb41 0303 	adc.w	r3, r1, r3
    if (nextHwCounterValue  < (currHwCounterValue + counterObj->hwTimerCompareMargin))
   16d16:	4919      	ldr	r1, [pc, #100]	; (16d7c <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   16d18:	6a09      	ldr	r1, [r1, #32]
   16d1a:	1856      	adds	r6, r2, r1
   16d1c:	f143 0700 	adc.w	r7, r3, #0
   16d20:	45b9      	cmp	r9, r7
   16d22:	bf08      	it	eq
   16d24:	45b0      	cmpeq	r8, r6
   16d26:	d224      	bcs.n	16d72 <SYS_TIME_HwTimerCompareUpdate+0xa6>
        counterObj->hwTimerCompareValue = currHwCounterValue + counterObj->hwTimerCompareMargin;
   16d28:	440a      	add	r2, r1
   16d2a:	4b14      	ldr	r3, [pc, #80]	; (16d7c <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   16d2c:	61da      	str	r2, [r3, #28]
    if ((counterObj->hwTimerCompareValue & SYS_TIME_HW_COUNTER_PERIOD) == 0)
   16d2e:	4b13      	ldr	r3, [pc, #76]	; (16d7c <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   16d30:	69db      	ldr	r3, [r3, #28]
   16d32:	b29b      	uxth	r3, r3
   16d34:	b913      	cbnz	r3, 16d3c <SYS_TIME_HwTimerCompareUpdate+0x70>
        counterObj->hwTimerCompareValue = 1;
   16d36:	4b11      	ldr	r3, [pc, #68]	; (16d7c <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   16d38:	2201      	movs	r2, #1
   16d3a:	61da      	str	r2, [r3, #28]
    counterObj->timePlib->timerCompareSet(counterObj->hwTimerCompareValue);
   16d3c:	4b0f      	ldr	r3, [pc, #60]	; (16d7c <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   16d3e:	69d8      	ldr	r0, [r3, #28]
   16d40:	685b      	ldr	r3, [r3, #4]
   16d42:	695b      	ldr	r3, [r3, #20]
   16d44:	b280      	uxth	r0, r0
   16d46:	4798      	blx	r3
}
   16d48:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            uint32_t relativeTimePending = tmrActive->relativeTimePending;
   16d4c:	6894      	ldr	r4, [r2, #8]
            nextHwCounterValue = (uint64_t)counterObj->hwTimerCurrentValue + relativeTimePending;
   16d4e:	4b0b      	ldr	r3, [pc, #44]	; (16d7c <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   16d50:	695b      	ldr	r3, [r3, #20]
   16d52:	2500      	movs	r5, #0
   16d54:	eb14 0803 	adds.w	r8, r4, r3
   16d58:	f145 0900 	adc.w	r9, r5, #0
   16d5c:	e7cb      	b.n	16cf6 <SYS_TIME_HwTimerCompareUpdate+0x2a>
        nextHwCounterValue = (uint64_t)counterObj->hwTimerCurrentValue + SYS_TIME_HW_COUNTER_HALF_PERIOD;
   16d5e:	4b07      	ldr	r3, [pc, #28]	; (16d7c <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   16d60:	695b      	ldr	r3, [r3, #20]
   16d62:	f647 74ff 	movw	r4, #32767	; 0x7fff
   16d66:	2500      	movs	r5, #0
   16d68:	eb14 0803 	adds.w	r8, r4, r3
   16d6c:	f145 0900 	adc.w	r9, r5, #0
   16d70:	e7c1      	b.n	16cf6 <SYS_TIME_HwTimerCompareUpdate+0x2a>
        counterObj->hwTimerCompareValue = nextHwCounterValue;
   16d72:	4b02      	ldr	r3, [pc, #8]	; (16d7c <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   16d74:	f8c3 801c 	str.w	r8, [r3, #28]
   16d78:	e7d9      	b.n	16d2e <SYS_TIME_HwTimerCompareUpdate+0x62>
   16d7a:	bf00      	nop
   16d7c:	2000e030 	.word	0x2000e030

Disassembly of section .text._malloc_r%342:

00016d80 <_malloc_r>:
   16d80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16d82:	1ccd      	adds	r5, r1, #3
   16d84:	f025 0503 	bic.w	r5, r5, #3
   16d88:	3508      	adds	r5, #8
   16d8a:	2d0c      	cmp	r5, #12
   16d8c:	bf38      	it	cc
   16d8e:	250c      	movcc	r5, #12
   16d90:	2d00      	cmp	r5, #0
   16d92:	4606      	mov	r6, r0
   16d94:	db01      	blt.n	16d9a <_malloc_r+0x1a>
   16d96:	42a9      	cmp	r1, r5
   16d98:	d903      	bls.n	16da2 <_malloc_r+0x22>
   16d9a:	230c      	movs	r3, #12
   16d9c:	6033      	str	r3, [r6, #0]
   16d9e:	2000      	movs	r0, #0
   16da0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   16da2:	f005 fbb2 	bl	1c50a <__malloc_lock>
   16da6:	4921      	ldr	r1, [pc, #132]	; (16e2c <_malloc_r+0xac>)
   16da8:	680a      	ldr	r2, [r1, #0]
   16daa:	4614      	mov	r4, r2
   16dac:	b99c      	cbnz	r4, 16dd6 <_malloc_r+0x56>
   16dae:	4f20      	ldr	r7, [pc, #128]	; (16e30 <_malloc_r+0xb0>)
   16db0:	683b      	ldr	r3, [r7, #0]
   16db2:	b923      	cbnz	r3, 16dbe <_malloc_r+0x3e>
   16db4:	4621      	mov	r1, r4
   16db6:	4630      	mov	r0, r6
   16db8:	f009 ff6a 	bl	20c90 <_sbrk_r>
   16dbc:	6038      	str	r0, [r7, #0]
   16dbe:	4629      	mov	r1, r5
   16dc0:	4630      	mov	r0, r6
   16dc2:	f009 ff65 	bl	20c90 <_sbrk_r>
   16dc6:	1c43      	adds	r3, r0, #1
   16dc8:	d123      	bne.n	16e12 <_malloc_r+0x92>
   16dca:	230c      	movs	r3, #12
   16dcc:	6033      	str	r3, [r6, #0]
   16dce:	4630      	mov	r0, r6
   16dd0:	f007 f9bf 	bl	1e152 <__malloc_unlock>
   16dd4:	e7e3      	b.n	16d9e <_malloc_r+0x1e>
   16dd6:	6823      	ldr	r3, [r4, #0]
   16dd8:	1b5b      	subs	r3, r3, r5
   16dda:	d417      	bmi.n	16e0c <_malloc_r+0x8c>
   16ddc:	2b0b      	cmp	r3, #11
   16dde:	d903      	bls.n	16de8 <_malloc_r+0x68>
   16de0:	6023      	str	r3, [r4, #0]
   16de2:	441c      	add	r4, r3
   16de4:	6025      	str	r5, [r4, #0]
   16de6:	e004      	b.n	16df2 <_malloc_r+0x72>
   16de8:	6863      	ldr	r3, [r4, #4]
   16dea:	42a2      	cmp	r2, r4
   16dec:	bf0c      	ite	eq
   16dee:	600b      	streq	r3, [r1, #0]
   16df0:	6053      	strne	r3, [r2, #4]
   16df2:	4630      	mov	r0, r6
   16df4:	f007 f9ad 	bl	1e152 <__malloc_unlock>
   16df8:	f104 000b 	add.w	r0, r4, #11
   16dfc:	1d23      	adds	r3, r4, #4
   16dfe:	f020 0007 	bic.w	r0, r0, #7
   16e02:	1ac2      	subs	r2, r0, r3
   16e04:	d0cc      	beq.n	16da0 <_malloc_r+0x20>
   16e06:	1a1b      	subs	r3, r3, r0
   16e08:	50a3      	str	r3, [r4, r2]
   16e0a:	e7c9      	b.n	16da0 <_malloc_r+0x20>
   16e0c:	4622      	mov	r2, r4
   16e0e:	6864      	ldr	r4, [r4, #4]
   16e10:	e7cc      	b.n	16dac <_malloc_r+0x2c>
   16e12:	1cc4      	adds	r4, r0, #3
   16e14:	f024 0403 	bic.w	r4, r4, #3
   16e18:	42a0      	cmp	r0, r4
   16e1a:	d0e3      	beq.n	16de4 <_malloc_r+0x64>
   16e1c:	1a21      	subs	r1, r4, r0
   16e1e:	4630      	mov	r0, r6
   16e20:	f009 ff36 	bl	20c90 <_sbrk_r>
   16e24:	3001      	adds	r0, #1
   16e26:	d1dd      	bne.n	16de4 <_malloc_r+0x64>
   16e28:	e7cf      	b.n	16dca <_malloc_r+0x4a>
   16e2a:	bf00      	nop
   16e2c:	2000e4e8 	.word	0x2000e4e8
   16e30:	2000e4ec 	.word	0x2000e4ec

Disassembly of section .text.TCPIP_STACK_NetUp%343:

00016e34 <TCPIP_STACK_NetUp>:
{
   16e34:	b570      	push	{r4, r5, r6, lr}
    if(pNetIf)
   16e36:	2800      	cmp	r0, #0
   16e38:	d047      	beq.n	16eca <TCPIP_STACK_NetUp+0x96>
   16e3a:	4605      	mov	r5, r0
        if(pNetIf->Flags.bInterfaceEnabled || pNetIf->Flags.bMacInitialize)
   16e3c:	f8b0 2042 	ldrh.w	r2, [r0, #66]	; 0x42
   16e40:	f244 0040 	movw	r0, #16448	; 0x4040
   16e44:	4210      	tst	r0, r2
   16e46:	d143      	bne.n	16ed0 <TCPIP_STACK_NetUp+0x9c>
        if(pUsrConfig == 0)
   16e48:	2900      	cmp	r1, #0
   16e4a:	d043      	beq.n	16ed4 <TCPIP_STACK_NetUp+0xa0>
   16e4c:	460e      	mov	r6, r1
        tcpip_stack_ctrl_data.pNetIf = pNetIf;
   16e4e:	4b22      	ldr	r3, [pc, #136]	; (16ed8 <TCPIP_STACK_NetUp+0xa4>)
   16e50:	615d      	str	r5, [r3, #20]
        tcpip_stack_ctrl_data.netIx = pNetIf->netIfIx;
   16e52:	f8b5 2058 	ldrh.w	r2, [r5, #88]	; 0x58
   16e56:	619a      	str	r2, [r3, #24]
        tcpip_stack_ctrl_data.stackAction = TCPIP_STACK_ACTION_IF_UP;
   16e58:	2203      	movs	r2, #3
   16e5a:	771a      	strb	r2, [r3, #28]
        if(!_LoadNetworkConfig(pUsrConfig, pNetIf, true))
   16e5c:	2201      	movs	r2, #1
   16e5e:	4629      	mov	r1, r5
   16e60:	4630      	mov	r0, r6
   16e62:	f7fb fa79 	bl	12358 <_LoadNetworkConfig>
   16e66:	4604      	mov	r4, r0
   16e68:	b160      	cbz	r0, 16e84 <TCPIP_STACK_NetUp+0x50>
        powerMode = TCPIP_Helper_StringToPowerMode(pUsrConfig->powerMode);
   16e6a:	6a30      	ldr	r0, [r6, #32]
   16e6c:	f008 f9e4 	bl	1f238 <TCPIP_Helper_StringToPowerMode>
   16e70:	4604      	mov	r4, r0
        if(powerMode != TCPIP_MAC_POWER_FULL && powerMode != TCPIP_MAC_POWER_DOWN)
   16e72:	f000 03fd 	and.w	r3, r0, #253	; 0xfd
   16e76:	2b01      	cmp	r3, #1
   16e78:	d017      	beq.n	16eaa <TCPIP_STACK_NetUp+0x76>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Power Mode initialization fail: %d\r\n", powerMode);
   16e7a:	f00b f8e9 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
   16e7e:	b960      	cbnz	r0, 16e9a <TCPIP_STACK_NetUp+0x66>
            return false;
   16e80:	2400      	movs	r4, #0
   16e82:	e023      	b.n	16ecc <TCPIP_STACK_NetUp+0x98>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration load failed: %d\r\n", pNetIf->netIfIx);
   16e84:	f00b f8e4 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
   16e88:	b300      	cbz	r0, 16ecc <TCPIP_STACK_NetUp+0x98>
   16e8a:	f00b f8db 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
   16e8e:	f8b5 2058 	ldrh.w	r2, [r5, #88]	; 0x58
   16e92:	4912      	ldr	r1, [pc, #72]	; (16edc <TCPIP_STACK_NetUp+0xa8>)
   16e94:	f003 fe02 	bl	1aa9c <SYS_CONSOLE_Print>
   16e98:	e018      	b.n	16ecc <TCPIP_STACK_NetUp+0x98>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Power Mode initialization fail: %d\r\n", powerMode);
   16e9a:	f00b f8d3 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
   16e9e:	4622      	mov	r2, r4
   16ea0:	490f      	ldr	r1, [pc, #60]	; (16ee0 <TCPIP_STACK_NetUp+0xac>)
   16ea2:	f003 fdfb 	bl	1aa9c <SYS_CONSOLE_Print>
            return false;
   16ea6:	2400      	movs	r4, #0
   16ea8:	e010      	b.n	16ecc <TCPIP_STACK_NetUp+0x98>
        tcpip_stack_ctrl_data.powerMode = powerMode;
   16eaa:	480b      	ldr	r0, [pc, #44]	; (16ed8 <TCPIP_STACK_NetUp+0xa4>)
   16eac:	7744      	strb	r4, [r0, #29]
        success = TCPIP_STACK_BringNetUp(&tcpip_stack_ctrl_data, pUsrConfig, 0, 0);
   16eae:	2300      	movs	r3, #0
   16eb0:	461a      	mov	r2, r3
   16eb2:	4631      	mov	r1, r6
   16eb4:	f7f6 fdcc 	bl	da50 <TCPIP_STACK_BringNetUp>
        if(!success)
   16eb8:	4604      	mov	r4, r0
   16eba:	b938      	cbnz	r0, 16ecc <TCPIP_STACK_NetUp+0x98>
            TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pNetIf, TCPIP_STACK_ACTION_IF_DOWN, TCPIP_MAC_POWER_DOWN);
   16ebc:	2303      	movs	r3, #3
   16ebe:	2204      	movs	r2, #4
   16ec0:	4629      	mov	r1, r5
   16ec2:	4805      	ldr	r0, [pc, #20]	; (16ed8 <TCPIP_STACK_NetUp+0xa4>)
   16ec4:	f004 f9c4 	bl	1b250 <TCPIP_STACK_BringNetDown>
   16ec8:	e000      	b.n	16ecc <TCPIP_STACK_NetUp+0x98>
    return false;
   16eca:	2400      	movs	r4, #0
}
   16ecc:	4620      	mov	r0, r4
   16ece:	bd70      	pop	{r4, r5, r6, pc}
            return true;
   16ed0:	2401      	movs	r4, #1
   16ed2:	e7fb      	b.n	16ecc <TCPIP_STACK_NetUp+0x98>
            return false;
   16ed4:	2400      	movs	r4, #0
   16ed6:	e7f9      	b.n	16ecc <TCPIP_STACK_NetUp+0x98>
   16ed8:	2000e0f0 	.word	0x2000e0f0
   16edc:	00009438 	.word	0x00009438
   16ee0:	00009378 	.word	0x00009378

Disassembly of section .text.SYS_TIME_TimerObjectCreate%344:

00016ee4 <SYS_TIME_TimerObjectCreate>:
    uint32_t period,
    SYS_TIME_CALLBACK callBack,
    uintptr_t context,
    SYS_TIME_CALLBACK_TYPE type
)
{
   16ee4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16ee6:	4605      	mov	r5, r0
   16ee8:	460c      	mov	r4, r1
   16eea:	4617      	mov	r7, r2
   16eec:	461e      	mov	r6, r3
    SYS_TIME_HANDLE tmrHandle = SYS_TIME_HANDLE_INVALID;
    SYS_TIME_TIMER_OBJ *tmr;
    uint32_t tmrObjIndex = 0;

    if (SYS_TIME_ResourceLock() == false)
   16eee:	f007 fcb9 	bl	1e864 <SYS_TIME_ResourceLock>
   16ef2:	2800      	cmp	r0, #0
   16ef4:	d042      	beq.n	16f7c <SYS_TIME_TimerObjectCreate+0x98>
    {
        return tmrHandle;
    }
    if((gSystemCounterObj.status == SYS_STATUS_READY) && (period > 0) && (period >= count))
   16ef6:	4b23      	ldr	r3, [pc, #140]	; (16f84 <SYS_TIME_TimerObjectCreate+0xa0>)
   16ef8:	f993 3000 	ldrsb.w	r3, [r3]
   16efc:	2b02      	cmp	r3, #2
   16efe:	d005      	beq.n	16f0c <SYS_TIME_TimerObjectCreate+0x28>
    SYS_TIME_HANDLE tmrHandle = SYS_TIME_HANDLE_INVALID;
   16f00:	f04f 34ff 	mov.w	r4, #4294967295
            }
            tmrObjIndex++;
        }
    }

    SYS_TIME_ResourceUnlock();
   16f04:	f007 fa16 	bl	1e334 <SYS_TIME_ResourceUnlock>

    return tmrHandle;
}
   16f08:	4620      	mov	r0, r4
   16f0a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((gSystemCounterObj.status == SYS_STATUS_READY) && (period > 0) && (period >= count))
   16f0c:	2c00      	cmp	r4, #0
   16f0e:	d02f      	beq.n	16f70 <SYS_TIME_TimerObjectCreate+0x8c>
   16f10:	42ac      	cmp	r4, r5
   16f12:	d330      	bcc.n	16f76 <SYS_TIME_TimerObjectCreate+0x92>
            if(tmr->inUse == false)
   16f14:	4b1c      	ldr	r3, [pc, #112]	; (16f88 <SYS_TIME_TimerObjectCreate+0xa4>)
   16f16:	781b      	ldrb	r3, [r3, #0]
   16f18:	b153      	cbz	r3, 16f30 <SYS_TIME_TimerObjectCreate+0x4c>
        for(tmr = timers; tmr < &timers[SYS_TIME_MAX_TIMERS]; tmr++)
   16f1a:	4a1c      	ldr	r2, [pc, #112]	; (16f8c <SYS_TIME_TimerObjectCreate+0xa8>)
            tmrObjIndex++;
   16f1c:	2301      	movs	r3, #1
            if(tmr->inUse == false)
   16f1e:	7811      	ldrb	r1, [r2, #0]
   16f20:	b141      	cbz	r1, 16f34 <SYS_TIME_TimerObjectCreate+0x50>
            tmrObjIndex++;
   16f22:	3301      	adds	r3, #1
        for(tmr = timers; tmr < &timers[SYS_TIME_MAX_TIMERS]; tmr++)
   16f24:	3220      	adds	r2, #32
   16f26:	2b05      	cmp	r3, #5
   16f28:	d1f9      	bne.n	16f1e <SYS_TIME_TimerObjectCreate+0x3a>
    SYS_TIME_HANDLE tmrHandle = SYS_TIME_HANDLE_INVALID;
   16f2a:	f04f 34ff 	mov.w	r4, #4294967295
   16f2e:	e7e9      	b.n	16f04 <SYS_TIME_TimerObjectCreate+0x20>
    uint32_t tmrObjIndex = 0;
   16f30:	2300      	movs	r3, #0
        for(tmr = timers; tmr < &timers[SYS_TIME_MAX_TIMERS]; tmr++)
   16f32:	4a15      	ldr	r2, [pc, #84]	; (16f88 <SYS_TIME_TimerObjectCreate+0xa4>)
                tmr->inUse = true;
   16f34:	2101      	movs	r1, #1
   16f36:	7011      	strb	r1, [r2, #0]
                tmr->active = false;
   16f38:	2100      	movs	r1, #0
   16f3a:	7051      	strb	r1, [r2, #1]
                tmr->tmrElapsedFlag = false;
   16f3c:	7511      	strb	r1, [r2, #20]
                tmr->tmrElapsed = false;
   16f3e:	7551      	strb	r1, [r2, #21]
                tmr->type = type;
   16f40:	f89d 1018 	ldrb.w	r1, [sp, #24]
   16f44:	7091      	strb	r1, [r2, #2]
                tmr->requestedTime = period;
   16f46:	6054      	str	r4, [r2, #4]
                tmr->callback = callBack;
   16f48:	60d7      	str	r7, [r2, #12]
                tmr->context = context;
   16f4a:	6116      	str	r6, [r2, #16]
                tmr->relativeTimePending = period - count;
   16f4c:	1b64      	subs	r4, r4, r5
   16f4e:	6094      	str	r4, [r2, #8]
                tmr->tmrHandle = (SYS_TIME_HANDLE) SYS_TIME_MAKE_HANDLE(gSysTimeTokenCount, tmrObjIndex);
   16f50:	490f      	ldr	r1, [pc, #60]	; (16f90 <SYS_TIME_TimerObjectCreate+0xac>)
   16f52:	8809      	ldrh	r1, [r1, #0]
    return ((token) << 16 | (index));
   16f54:	b29b      	uxth	r3, r3
   16f56:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
                tmr->tmrHandle = (SYS_TIME_HANDLE) SYS_TIME_MAKE_HANDLE(gSysTimeTokenCount, tmrObjIndex);
   16f5a:	61d4      	str	r4, [r2, #28]
    token++;
   16f5c:	1c4b      	adds	r3, r1, #1
   16f5e:	b29b      	uxth	r3, r3
        token = 1;
   16f60:	f64f 72ff 	movw	r2, #65535	; 0xffff
   16f64:	4293      	cmp	r3, r2
   16f66:	bf08      	it	eq
   16f68:	2301      	moveq	r3, #1
                gSysTimeTokenCount = SYS_TIME_UPDATE_TOKEN(gSysTimeTokenCount);
   16f6a:	4a09      	ldr	r2, [pc, #36]	; (16f90 <SYS_TIME_TimerObjectCreate+0xac>)
   16f6c:	8013      	strh	r3, [r2, #0]
                break;
   16f6e:	e7c9      	b.n	16f04 <SYS_TIME_TimerObjectCreate+0x20>
    SYS_TIME_HANDLE tmrHandle = SYS_TIME_HANDLE_INVALID;
   16f70:	f04f 34ff 	mov.w	r4, #4294967295
   16f74:	e7c6      	b.n	16f04 <SYS_TIME_TimerObjectCreate+0x20>
   16f76:	f04f 34ff 	mov.w	r4, #4294967295
   16f7a:	e7c3      	b.n	16f04 <SYS_TIME_TimerObjectCreate+0x20>
        return tmrHandle;
   16f7c:	f04f 34ff 	mov.w	r4, #4294967295
   16f80:	e7c2      	b.n	16f08 <SYS_TIME_TimerObjectCreate+0x24>
   16f82:	bf00      	nop
   16f84:	2000e030 	.word	0x2000e030
   16f88:	2000db50 	.word	0x2000db50
   16f8c:	2000db70 	.word	0x2000db70
   16f90:	2000e50a 	.word	0x2000e50a

Disassembly of section .text.SYS_TIME_Initialize%345:

00016f94 <SYS_TIME_Initialize>:
// Section: System Interface Functions
// *****************************************************************************
// *****************************************************************************
SYS_MODULE_OBJ SYS_TIME_Initialize( const SYS_MODULE_INDEX index, const SYS_MODULE_INIT * const init )
{
    if(init == 0 || index != SYS_TIME_INDEX_0)
   16f94:	2900      	cmp	r1, #0
   16f96:	d044      	beq.n	17022 <SYS_TIME_Initialize+0x8e>
{
   16f98:	b538      	push	{r3, r4, r5, lr}
   16f9a:	460d      	mov	r5, r1
    if(init == 0 || index != SYS_TIME_INDEX_0)
   16f9c:	2800      	cmp	r0, #0
   16f9e:	d143      	bne.n	17028 <SYS_TIME_Initialize+0x94>
    {
        return SYS_MODULE_OBJ_INVALID;
    }
    /* Create mutex to guard from multiple contesting threads */
    if(OSAL_MUTEX_Create(&gSystemCounterObj.timerMutex) != OSAL_RESULT_TRUE)
   16fa0:	4823      	ldr	r0, [pc, #140]	; (17030 <SYS_TIME_Initialize+0x9c>)
   16fa2:	f00a fb23 	bl	215ec <OSAL_MUTEX_Create>
   16fa6:	2801      	cmp	r0, #1
   16fa8:	d002      	beq.n	16fb0 <SYS_TIME_Initialize+0x1c>
    {
        return SYS_MODULE_OBJ_INVALID;
   16faa:	f04f 30ff 	mov.w	r0, #4294967295
   16fae:	e03d      	b.n	1702c <SYS_TIME_Initialize+0x98>
    counterObj->timePlib = initData->timePlib;
   16fb0:	682b      	ldr	r3, [r5, #0]
   16fb2:	4c20      	ldr	r4, [pc, #128]	; (17034 <SYS_TIME_Initialize+0xa0>)
   16fb4:	6063      	str	r3, [r4, #4]
    counterObj->hwTimerFrequency = counterObj->timePlib->timerFrequencyGet();
   16fb6:	68db      	ldr	r3, [r3, #12]
   16fb8:	4798      	blx	r3
   16fba:	60e0      	str	r0, [r4, #12]
    cpuCyclesPerTimerClock=(SYS_TIME_CPU_CLOCK_FREQUENCY/counterObj->hwTimerFrequency);
   16fbc:	4b1e      	ldr	r3, [pc, #120]	; (17038 <SYS_TIME_Initialize+0xa4>)
   16fbe:	fbb3 f3f0 	udiv	r3, r3, r0
    counterObj->hwTimerCompareMargin=(SYS_TIME_COMPARE_UPDATE_EXECUTION_CYCLES/cpuCyclesPerTimerClock) +2;
   16fc2:	20bc      	movs	r0, #188	; 0xbc
   16fc4:	fb90 f0f3 	sdiv	r0, r0, r3
   16fc8:	3002      	adds	r0, #2
   16fca:	6220      	str	r0, [r4, #32]
    counterObj->hwTimerIntNum = initData->hwTimerIntNum;
   16fcc:	f9b5 3004 	ldrsh.w	r3, [r5, #4]
   16fd0:	8123      	strh	r3, [r4, #8]
    counterObj->hwTimerPreviousValue = 0;
   16fd2:	2100      	movs	r1, #0
   16fd4:	6121      	str	r1, [r4, #16]
    counterObj->hwTimerPeriodValue = SYS_TIME_HW_COUNTER_PERIOD;
   16fd6:	f64f 73ff 	movw	r3, #65535	; 0xffff
   16fda:	61a3      	str	r3, [r4, #24]
    counterObj->hwTimerCompareValue = SYS_TIME_HW_COUNTER_HALF_PERIOD;
   16fdc:	f647 73ff 	movw	r3, #32767	; 0x7fff
   16fe0:	61e3      	str	r3, [r4, #28]
    counterObj->swCounter64Low = 0;
   16fe2:	6261      	str	r1, [r4, #36]	; 0x24
    counterObj->swCounter64High = 0;
   16fe4:	62a1      	str	r1, [r4, #40]	; 0x28
    counterObj->tmrActive = NULL;
   16fe6:	6321      	str	r1, [r4, #48]	; 0x30
    counterObj->interruptNestingCount = 0;
   16fe8:	f884 102c 	strb.w	r1, [r4, #44]	; 0x2c
    counterObj->timePlib->timerCallbackSet(SYS_TIME_PLIBCallback, 0);
   16fec:	6863      	ldr	r3, [r4, #4]
   16fee:	681b      	ldr	r3, [r3, #0]
   16ff0:	4812      	ldr	r0, [pc, #72]	; (1703c <SYS_TIME_Initialize+0xa8>)
   16ff2:	4798      	blx	r3
    if (counterObj->timePlib->timerPeriodSet != NULL)
   16ff4:	6863      	ldr	r3, [r4, #4]
   16ff6:	691b      	ldr	r3, [r3, #16]
   16ff8:	b10b      	cbz	r3, 16ffe <SYS_TIME_Initialize+0x6a>
        counterObj->timePlib->timerPeriodSet(counterObj->hwTimerPeriodValue);
   16ffa:	8b20      	ldrh	r0, [r4, #24]
   16ffc:	4798      	blx	r3
    counterObj->timePlib->timerCompareSet(counterObj->hwTimerCompareValue);
   16ffe:	4c0d      	ldr	r4, [pc, #52]	; (17034 <SYS_TIME_Initialize+0xa0>)
   17000:	69e0      	ldr	r0, [r4, #28]
   17002:	6863      	ldr	r3, [r4, #4]
   17004:	695b      	ldr	r3, [r3, #20]
   17006:	b280      	uxth	r0, r0
   17008:	4798      	blx	r3
    counterObj->timePlib->timerStart();
   1700a:	6863      	ldr	r3, [r4, #4]
   1700c:	685b      	ldr	r3, [r3, #4]
   1700e:	4798      	blx	r3
    }

    SYS_TIME_CounterInit((SYS_MODULE_INIT *)init);
    memset(timers, 0, sizeof(timers));
   17010:	22a0      	movs	r2, #160	; 0xa0
   17012:	2100      	movs	r1, #0
   17014:	480a      	ldr	r0, [pc, #40]	; (17040 <SYS_TIME_Initialize+0xac>)
   17016:	f00a fe39 	bl	21c8c <memset>

    gSystemCounterObj.status = SYS_STATUS_READY;
   1701a:	2302      	movs	r3, #2
   1701c:	7023      	strb	r3, [r4, #0]

    return (SYS_MODULE_OBJ)&gSystemCounterObj;
   1701e:	4620      	mov	r0, r4
   17020:	e004      	b.n	1702c <SYS_TIME_Initialize+0x98>
        return SYS_MODULE_OBJ_INVALID;
   17022:	f04f 30ff 	mov.w	r0, #4294967295
}
   17026:	4770      	bx	lr
        return SYS_MODULE_OBJ_INVALID;
   17028:	f04f 30ff 	mov.w	r0, #4294967295
}
   1702c:	bd38      	pop	{r3, r4, r5, pc}
   1702e:	bf00      	nop
   17030:	2000e064 	.word	0x2000e064
   17034:	2000e030 	.word	0x2000e030
   17038:	07270e00 	.word	0x07270e00
   1703c:	00015541 	.word	0x00015541
   17040:	2000db50 	.word	0x2000db50

Disassembly of section .text.TCPIP_Commands_Initialize%346:

00017044 <TCPIP_Commands_Initialize>:
{
   17044:	b510      	push	{r4, lr}
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_UP)
   17046:	7f03      	ldrb	r3, [r0, #28]
   17048:	2b03      	cmp	r3, #3
   1704a:	d03b      	beq.n	170c4 <TCPIP_Commands_Initialize+0x80>
    if(commandInitCount == 0)
   1704c:	4b1e      	ldr	r3, [pc, #120]	; (170c8 <TCPIP_Commands_Initialize+0x84>)
   1704e:	681b      	ldr	r3, [r3, #0]
   17050:	b133      	cbz	r3, 17060 <TCPIP_Commands_Initialize+0x1c>
    commandInitCount++;
   17052:	4a1d      	ldr	r2, [pc, #116]	; (170c8 <TCPIP_Commands_Initialize+0x84>)
   17054:	6813      	ldr	r3, [r2, #0]
   17056:	3301      	adds	r3, #1
   17058:	6013      	str	r3, [r2, #0]
    return true;
   1705a:	2401      	movs	r4, #1
}
   1705c:	4620      	mov	r0, r4
   1705e:	bd10      	pop	{r4, pc}
        initialNetIfs = stackCtrl->nIfs;
   17060:	6802      	ldr	r2, [r0, #0]
   17062:	4b1a      	ldr	r3, [pc, #104]	; (170cc <TCPIP_Commands_Initialize+0x88>)
   17064:	601a      	str	r2, [r3, #0]
        if (!SYS_CMD_ADDGRP(tcpipCmdTbl, sizeof(tcpipCmdTbl)/sizeof(*tcpipCmdTbl), "tcpip", ": stack commands"))
   17066:	4a1a      	ldr	r2, [pc, #104]	; (170d0 <TCPIP_Commands_Initialize+0x8c>)
   17068:	f502 7359 	add.w	r3, r2, #868	; 0x364
   1706c:	f502 725e 	add.w	r2, r2, #888	; 0x378
   17070:	2110      	movs	r1, #16
   17072:	4818      	ldr	r0, [pc, #96]	; (170d4 <TCPIP_Commands_Initialize+0x90>)
   17074:	f003 fcdc 	bl	1aa30 <SYS_CMD_ADDGRP>
   17078:	4604      	mov	r4, r0
   1707a:	b168      	cbz	r0, 17098 <TCPIP_Commands_Initialize+0x54>
        icmpAckRecv = 0;
   1707c:	2200      	movs	r2, #0
   1707e:	4b16      	ldr	r3, [pc, #88]	; (170d8 <TCPIP_Commands_Initialize+0x94>)
   17080:	601a      	str	r2, [r3, #0]
        tcpipCmdSignalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_COMMAND_Task, 0);
   17082:	4916      	ldr	r1, [pc, #88]	; (170dc <TCPIP_Commands_Initialize+0x98>)
   17084:	201f      	movs	r0, #31
   17086:	f005 ff9b 	bl	1cfc0 <_TCPIPStackSignalHandlerRegister>
   1708a:	4b15      	ldr	r3, [pc, #84]	; (170e0 <TCPIP_Commands_Initialize+0x9c>)
   1708c:	6018      	str	r0, [r3, #0]
        if(tcpipCmdSignalHandle == 0)
   1708e:	b168      	cbz	r0, 170ac <TCPIP_Commands_Initialize+0x68>
        tcpipCmdStat = TCPIP_CMD_STAT_IDLE;
   17090:	4b14      	ldr	r3, [pc, #80]	; (170e4 <TCPIP_Commands_Initialize+0xa0>)
   17092:	2200      	movs	r2, #0
   17094:	701a      	strb	r2, [r3, #0]
   17096:	e7dc      	b.n	17052 <TCPIP_Commands_Initialize+0xe>
            SYS_ERROR(SYS_ERROR_ERROR, "Failed to create TCPIP Commands\r\n");
   17098:	f00a ffda 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
   1709c:	2800      	cmp	r0, #0
   1709e:	d0dd      	beq.n	1705c <TCPIP_Commands_Initialize+0x18>
   170a0:	f00a ffd0 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
   170a4:	4910      	ldr	r1, [pc, #64]	; (170e8 <TCPIP_Commands_Initialize+0xa4>)
   170a6:	f003 fcf9 	bl	1aa9c <SYS_CONSOLE_Print>
   170aa:	e7d7      	b.n	1705c <TCPIP_Commands_Initialize+0x18>
            SYS_ERROR(SYS_ERROR_ERROR, "TCPIP commands task registration failed\r\n");
   170ac:	f00a ffd0 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
   170b0:	b908      	cbnz	r0, 170b6 <TCPIP_Commands_Initialize+0x72>
            return false;
   170b2:	2400      	movs	r4, #0
   170b4:	e7d2      	b.n	1705c <TCPIP_Commands_Initialize+0x18>
            SYS_ERROR(SYS_ERROR_ERROR, "TCPIP commands task registration failed\r\n");
   170b6:	f00a ffc5 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
   170ba:	490c      	ldr	r1, [pc, #48]	; (170ec <TCPIP_Commands_Initialize+0xa8>)
   170bc:	f003 fcee 	bl	1aa9c <SYS_CONSOLE_Print>
            return false;
   170c0:	2400      	movs	r4, #0
   170c2:	e7cb      	b.n	1705c <TCPIP_Commands_Initialize+0x18>
        return true;
   170c4:	2401      	movs	r4, #1
   170c6:	e7c9      	b.n	1705c <TCPIP_Commands_Initialize+0x18>
   170c8:	2000e3a8 	.word	0x2000e3a8
   170cc:	2000e3d8 	.word	0x2000e3d8
   170d0:	00001384 	.word	0x00001384
   170d4:	000161e0 	.word	0x000161e0
   170d8:	2000e3b4 	.word	0x2000e3b4
   170dc:	0000a5cd 	.word	0x0000a5cd
   170e0:	2000e3e4 	.word	0x2000e3e4
   170e4:	2000e1af 	.word	0x2000e1af
   170e8:	00001704 	.word	0x00001704
   170ec:	00001728 	.word	0x00001728

Disassembly of section .text._TcpDisconnect%347:

000170f0 <_TcpDisconnect>:
{
   170f0:	b570      	push	{r4, r5, r6, lr}
	switch(pSkt->smState)
   170f2:	f890 306e 	ldrb.w	r3, [r0, #110]	; 0x6e
   170f6:	3b02      	subs	r3, #2
   170f8:	2b08      	cmp	r3, #8
   170fa:	d806      	bhi.n	1710a <_TcpDisconnect+0x1a>
   170fc:	e8df f003 	tbb	[pc, r3]
   17100:	4b4b0707 	.word	0x4b4b0707
   17104:	4b074b4b 	.word	0x4b074b4b
   17108:	46          	.byte	0x46
   17109:	00          	.byte	0x00
            sendRes = _TCP_SEND_NOT_CONN;
   1710a:	2001      	movs	r0, #1
   1710c:	e044      	b.n	17198 <_TcpDisconnect+0xa8>
   1710e:	4604      	mov	r4, r0
            if(pSkt->flags.nonLinger != 0)
   17110:	f890 306c 	ldrb.w	r3, [r0, #108]	; 0x6c
   17114:	f013 0f40 	tst.w	r3, #64	; 0x40
   17118:	d114      	bne.n	17144 <_TcpDisconnect+0x54>
            sendData = (signalFIN || (pSkt->txHead != pSkt->txUnackedTail));
   1711a:	b9f1      	cbnz	r1, 1715a <_TcpDisconnect+0x6a>
            if(sendData)
   1711c:	6882      	ldr	r2, [r0, #8]
   1711e:	6903      	ldr	r3, [r0, #16]
   17120:	429a      	cmp	r2, r3
   17122:	d118      	bne.n	17156 <_TcpDisconnect+0x66>
                sendRes = _TCP_SEND_OK; 
   17124:	2000      	movs	r0, #0
                pSkt->Flags.failedDisconnect = 0;
   17126:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
   1712a:	f36f 03c3 	bfc	r3, #3, #1
   1712e:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37
                _TcpSocketSetState(pSkt, pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT ? TCPIP_TCP_STATE_LAST_ACK : TCPIP_TCP_STATE_FIN_WAIT_1);
   17132:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
   17136:	2b08      	cmp	r3, #8
   17138:	bf0c      	ite	eq
   1713a:	2309      	moveq	r3, #9
   1713c:	2304      	movne	r3, #4
    pSkt->smState = newState;
   1713e:	f884 306e 	strb.w	r3, [r4, #110]	; 0x6e
   17142:	e029      	b.n	17198 <_TcpDisconnect+0xa8>
    pSkt->txHead = pSkt->txTail = pSkt->txUnackedTail = pSkt->txStart;
   17144:	6803      	ldr	r3, [r0, #0]
   17146:	6103      	str	r3, [r0, #16]
   17148:	60c3      	str	r3, [r0, #12]
   1714a:	6083      	str	r3, [r0, #8]
            sendData = (signalFIN || (pSkt->txHead != pSkt->txUnackedTail));
   1714c:	b109      	cbz	r1, 17152 <_TcpDisconnect+0x62>
                tcpFlags = signalFIN? FIN | ACK : ACK;
   1714e:	2511      	movs	r5, #17
   17150:	e004      	b.n	1715c <_TcpDisconnect+0x6c>
                sendRes = _TCP_SEND_OK; 
   17152:	2000      	movs	r0, #0
   17154:	e7e7      	b.n	17126 <_TcpDisconnect+0x36>
                tcpFlags = signalFIN? FIN | ACK : ACK;
   17156:	2510      	movs	r5, #16
   17158:	e000      	b.n	1715c <_TcpDisconnect+0x6c>
   1715a:	2511      	movs	r5, #17
                    sendRes = _TcpSend(pSkt, tcpFlags, SENDTCP_RESET_TIMERS);
   1715c:	2601      	movs	r6, #1
   1715e:	4632      	mov	r2, r6
   17160:	4629      	mov	r1, r5
   17162:	4620      	mov	r0, r4
   17164:	f7f0 fd5e 	bl	7c24 <_TcpSend>
                    if(sendRes < 0 || pSkt->remoteWindow == 0u)
   17168:	2800      	cmp	r0, #0
   1716a:	db08      	blt.n	1717e <_TcpDisconnect+0x8e>
   1716c:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
   17170:	2b00      	cmp	r3, #0
   17172:	d0d8      	beq.n	17126 <_TcpDisconnect+0x36>
                } while(pSkt->txHead != pSkt->txUnackedTail);
   17174:	68a2      	ldr	r2, [r4, #8]
   17176:	6923      	ldr	r3, [r4, #16]
   17178:	429a      	cmp	r2, r3
   1717a:	d1f0      	bne.n	1715e <_TcpDisconnect+0x6e>
   1717c:	e7d3      	b.n	17126 <_TcpDisconnect+0x36>
                pSkt->Flags.failedDisconnect = 1;
   1717e:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
   17182:	f043 0308 	orr.w	r3, r3, #8
   17186:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37
   1718a:	e005      	b.n	17198 <_TcpDisconnect+0xa8>
            _TcpCloseSocket(pSkt, 0);
   1718c:	2100      	movs	r1, #0
   1718e:	f7f9 fe1d 	bl	10dcc <_TcpCloseSocket>
            sendRes = _TCP_SEND_OK;
   17192:	2000      	movs	r0, #0
            break;
   17194:	e000      	b.n	17198 <_TcpDisconnect+0xa8>
            sendRes = _TCP_SEND_OK;
   17196:	2000      	movs	r0, #0
}
   17198:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text._TCPIP_HEAP_Malloc%348:

0001719a <_TCPIP_HEAP_Malloc>:
    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   1719a:	2800      	cmp	r0, #0
   1719c:	d051      	beq.n	17242 <_TCPIP_HEAP_Malloc+0xa8>
{
   1719e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   171a0:	4606      	mov	r6, r0
	if(hDcpt == 0 || nBytes == 0)
   171a2:	2900      	cmp	r1, #0
   171a4:	d03f      	beq.n	17226 <_TCPIP_HEAP_Malloc+0x8c>
	nunits=(nBytes+sizeof(_headNode)-1)/sizeof(_headNode)+1;	// allocate units   
   171a6:	f101 050f 	add.w	r5, r1, #15
   171aa:	092d      	lsrs	r5, r5, #4
   171ac:	3501      	adds	r5, #1
    OSAL_SEM_Pend(&hDcpt->_heapSemaphore, OSAL_WAIT_FOREVER);
   171ae:	f100 0744 	add.w	r7, r0, #68	; 0x44
   171b2:	f64f 71ff 	movw	r1, #65535	; 0xffff
   171b6:	4638      	mov	r0, r7
   171b8:	f009 fdf4 	bl	20da4 <OSAL_SEM_Pend>
	for(ptr = hDcpt->_heapHead; ptr != 0; prev = ptr, ptr = ptr->next)
   171bc:	6a73      	ldr	r3, [r6, #36]	; 0x24
   171be:	b353      	cbz	r3, 17216 <_TCPIP_HEAP_Malloc+0x7c>
		if(ptr->units >= nunits)
   171c0:	685a      	ldr	r2, [r3, #4]
   171c2:	4295      	cmp	r5, r2
   171c4:	d931      	bls.n	1722a <_TCPIP_HEAP_Malloc+0x90>
	for(ptr = hDcpt->_heapHead; ptr != 0; prev = ptr, ptr = ptr->next)
   171c6:	681c      	ldr	r4, [r3, #0]
   171c8:	b32c      	cbz	r4, 17216 <_TCPIP_HEAP_Malloc+0x7c>
		if(ptr->units >= nunits)
   171ca:	6862      	ldr	r2, [r4, #4]
   171cc:	42aa      	cmp	r2, r5
   171ce:	d201      	bcs.n	171d4 <_TCPIP_HEAP_Malloc+0x3a>
	for(ptr = hDcpt->_heapHead; ptr != 0; prev = ptr, ptr = ptr->next)
   171d0:	4623      	mov	r3, r4
   171d2:	e7f8      	b.n	171c6 <_TCPIP_HEAP_Malloc+0x2c>
			if(ptr->units-nunits <= _TCPIP_HEAP_MIN_BLK_USIZE_)
   171d4:	1b51      	subs	r1, r2, r5
   171d6:	2902      	cmp	r1, #2
   171d8:	d913      	bls.n	17202 <_TCPIP_HEAP_Malloc+0x68>
            if(ptr->units == nunits)
   171da:	4295      	cmp	r5, r2
   171dc:	d010      	beq.n	17200 <_TCPIP_HEAP_Malloc+0x66>
				ptr->units -= nunits;
   171de:	6061      	str	r1, [r4, #4]
				ptr += ptr->units;
   171e0:	eb04 1401 	add.w	r4, r4, r1, lsl #4
				ptr->units = nunits;
   171e4:	6065      	str	r5, [r4, #4]
            if((hDcpt->_heapAllocatedUnits += nunits) > hDcpt->_heapWatermark)
   171e6:	6b33      	ldr	r3, [r6, #48]	; 0x30
   171e8:	441d      	add	r5, r3
   171ea:	6335      	str	r5, [r6, #48]	; 0x30
   171ec:	6b73      	ldr	r3, [r6, #52]	; 0x34
   171ee:	429d      	cmp	r5, r3
                hDcpt->_heapWatermark = hDcpt->_heapAllocatedUnits;
   171f0:	bf88      	it	hi
   171f2:	6375      	strhi	r5, [r6, #52]	; 0x34
            OSAL_SEM_Post(&hDcpt->_heapSemaphore);
   171f4:	4638      	mov	r0, r7
   171f6:	f00a f9ed 	bl	215d4 <OSAL_SEM_Post>
            return ptr + 1;
   171fa:	f104 0010 	add.w	r0, r4, #16
   171fe:	e011      	b.n	17224 <_TCPIP_HEAP_Malloc+0x8a>
				if(prev)
   17200:	b13b      	cbz	r3, 17212 <_TCPIP_HEAP_Malloc+0x78>
					prev->next = ptr->next;
   17202:	6821      	ldr	r1, [r4, #0]
   17204:	6019      	str	r1, [r3, #0]
   17206:	4615      	mov	r5, r2
                if(hDcpt->_heapTail == ptr)
   17208:	6ab2      	ldr	r2, [r6, #40]	; 0x28
   1720a:	42a2      	cmp	r2, r4
   1720c:	d1eb      	bne.n	171e6 <_TCPIP_HEAP_Malloc+0x4c>
                    hDcpt->_heapTail = prev;
   1720e:	62b3      	str	r3, [r6, #40]	; 0x28
   17210:	e7e9      	b.n	171e6 <_TCPIP_HEAP_Malloc+0x4c>
   17212:	4623      	mov	r3, r4
   17214:	e00c      	b.n	17230 <_TCPIP_HEAP_Malloc+0x96>
    hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_NO_MEM;
   17216:	23fa      	movs	r3, #250	; 0xfa
   17218:	f886 3038 	strb.w	r3, [r6, #56]	; 0x38
    OSAL_SEM_Post(&hDcpt->_heapSemaphore);
   1721c:	4638      	mov	r0, r7
   1721e:	f00a f9d9 	bl	215d4 <OSAL_SEM_Post>
    return 0;
   17222:	2000      	movs	r0, #0
}
   17224:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return 0;
   17226:	2000      	movs	r0, #0
   17228:	e7fc      	b.n	17224 <_TCPIP_HEAP_Malloc+0x8a>
			if(ptr->units-nunits <= _TCPIP_HEAP_MIN_BLK_USIZE_)
   1722a:	1b51      	subs	r1, r2, r5
   1722c:	2902      	cmp	r1, #2
   1722e:	d805      	bhi.n	1723c <_TCPIP_HEAP_Malloc+0xa2>
					hDcpt->_heapHead = ptr->next;
   17230:	6819      	ldr	r1, [r3, #0]
   17232:	6271      	str	r1, [r6, #36]	; 0x24
   17234:	461c      	mov	r4, r3
   17236:	4615      	mov	r5, r2
                    prev = hDcpt->_heapHead;
   17238:	460b      	mov	r3, r1
   1723a:	e7e5      	b.n	17208 <_TCPIP_HEAP_Malloc+0x6e>
	for(ptr = hDcpt->_heapHead; ptr != 0; prev = ptr, ptr = ptr->next)
   1723c:	461c      	mov	r4, r3
	prev=0;
   1723e:	2300      	movs	r3, #0
   17240:	e7cb      	b.n	171da <_TCPIP_HEAP_Malloc+0x40>
}
   17242:	4770      	bx	lr

Disassembly of section .text.Hash_DRBG_Reseed%349:

00017244 <Hash_DRBG_Reseed>:
{
   17244:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   17248:	b092      	sub	sp, #72	; 0x48
   1724a:	4607      	mov	r7, r0
   1724c:	460d      	mov	r5, r1
   1724e:	4616      	mov	r6, r2
    XMEMSET(newV, 0, DRBG_SEED_LEN);
   17250:	2437      	movs	r4, #55	; 0x37
   17252:	4622      	mov	r2, r4
   17254:	2100      	movs	r1, #0
   17256:	a804      	add	r0, sp, #16
   17258:	f00a fd18 	bl	21c8c <memset>
                drbg->V, sizeof(drbg->V), seed, seedSz) != DRBG_SUCCESS) {
   1725c:	f107 0808 	add.w	r8, r7, #8
    if (Hash_df(drbg, newV, sizeof(newV), drbgReseed,
   17260:	9603      	str	r6, [sp, #12]
   17262:	9502      	str	r5, [sp, #8]
   17264:	9401      	str	r4, [sp, #4]
   17266:	f8cd 8000 	str.w	r8, [sp]
   1726a:	2301      	movs	r3, #1
   1726c:	4622      	mov	r2, r4
   1726e:	a904      	add	r1, sp, #16
   17270:	4638      	mov	r0, r7
   17272:	f7fa fe95 	bl	11fa0 <Hash_df>
   17276:	2800      	cmp	r0, #0
   17278:	d135      	bne.n	172e6 <Hash_DRBG_Reseed+0xa2>
    XMEMCPY(drbg->V, newV, sizeof(drbg->V));
   1727a:	ae04      	add	r6, sp, #16
   1727c:	4644      	mov	r4, r8
   1727e:	f10d 0c40 	add.w	ip, sp, #64	; 0x40
   17282:	4635      	mov	r5, r6
   17284:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   17286:	6020      	str	r0, [r4, #0]
   17288:	6061      	str	r1, [r4, #4]
   1728a:	60a2      	str	r2, [r4, #8]
   1728c:	60e3      	str	r3, [r4, #12]
   1728e:	462e      	mov	r6, r5
   17290:	3410      	adds	r4, #16
   17292:	4565      	cmp	r5, ip
   17294:	d1f5      	bne.n	17282 <Hash_DRBG_Reseed+0x3e>
   17296:	6828      	ldr	r0, [r5, #0]
   17298:	6020      	str	r0, [r4, #0]
   1729a:	88aa      	ldrh	r2, [r5, #4]
   1729c:	79ab      	ldrb	r3, [r5, #6]
   1729e:	80a2      	strh	r2, [r4, #4]
   172a0:	71a3      	strb	r3, [r4, #6]
    volatile byte* z = (volatile byte*)mem;
   172a2:	aa04      	add	r2, sp, #16
    while (len--) *z++ = 0;
   172a4:	2000      	movs	r0, #0
   172a6:	f10d 0147 	add.w	r1, sp, #71	; 0x47
   172aa:	4613      	mov	r3, r2
   172ac:	f803 0b01 	strb.w	r0, [r3], #1
   172b0:	461a      	mov	r2, r3
   172b2:	428b      	cmp	r3, r1
   172b4:	d1f9      	bne.n	172aa <Hash_DRBG_Reseed+0x66>
    if (Hash_df(drbg, drbg->C, sizeof(drbg->C), drbgInitC, drbg->V,
   172b6:	2300      	movs	r3, #0
   172b8:	9303      	str	r3, [sp, #12]
   172ba:	9302      	str	r3, [sp, #8]
   172bc:	2237      	movs	r2, #55	; 0x37
   172be:	9201      	str	r2, [sp, #4]
   172c0:	f8cd 8000 	str.w	r8, [sp]
   172c4:	f107 013f 	add.w	r1, r7, #63	; 0x3f
   172c8:	4638      	mov	r0, r7
   172ca:	f7fa fe69 	bl	11fa0 <Hash_df>
   172ce:	4603      	mov	r3, r0
   172d0:	b958      	cbnz	r0, 172ea <Hash_DRBG_Reseed+0xa6>
    drbg->reseedCtr = 1;
   172d2:	2201      	movs	r2, #1
   172d4:	603a      	str	r2, [r7, #0]
    drbg->lastBlock = 0;
   172d6:	2200      	movs	r2, #0
   172d8:	607a      	str	r2, [r7, #4]
    drbg->matchCount = 0;
   172da:	f887 2080 	strb.w	r2, [r7, #128]	; 0x80
}
   172de:	4618      	mov	r0, r3
   172e0:	b012      	add	sp, #72	; 0x48
   172e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return DRBG_FAILURE;
   172e6:	2301      	movs	r3, #1
   172e8:	e7f9      	b.n	172de <Hash_DRBG_Reseed+0x9a>
        return DRBG_FAILURE;
   172ea:	2301      	movs	r3, #1
   172ec:	e7f7      	b.n	172de <Hash_DRBG_Reseed+0x9a>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseReset%350:

000172f0 <_DRV_ETHPHY_SetupPhaseReset>:
{
   172f0:	b538      	push	{r3, r4, r5, lr}
   172f2:	4604      	mov	r4, r0
    switch(hClientObj->operSubPhase)
   172f4:	8c03      	ldrh	r3, [r0, #32]
   172f6:	2b01      	cmp	r3, #1
   172f8:	d014      	beq.n	17324 <_DRV_ETHPHY_SetupPhaseReset+0x34>
   172fa:	b21a      	sxth	r2, r3
   172fc:	b132      	cbz	r2, 1730c <_DRV_ETHPHY_SetupPhaseReset+0x1c>
   172fe:	2b02      	cmp	r3, #2
   17300:	d02a      	beq.n	17358 <_DRV_ETHPHY_SetupPhaseReset+0x68>
            _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_DTCT_ERR);
   17302:	f04f 31ff 	mov.w	r1, #4294967295
   17306:	f008 fd11 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
}
   1730a:	bd38      	pop	{r3, r4, r5, pc}
            if(_DRV_PHY_SMIWriteStart(hClientObj, PHY_REG_BMCON, _BMCON_RESET_MASK))
   1730c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   17310:	2100      	movs	r1, #0
   17312:	f007 fe0c 	bl	1ef2e <_DRV_PHY_SMIWriteStart>
   17316:	2800      	cmp	r0, #0
   17318:	d0f7      	beq.n	1730a <_DRV_ETHPHY_SetupPhaseReset+0x1a>
    hClientObj->operPhase = operPhase;
   1731a:	2302      	movs	r3, #2
   1731c:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1731e:	2301      	movs	r3, #1
   17320:	8423      	strh	r3, [r4, #32]
   17322:	e7f2      	b.n	1730a <_DRV_ETHPHY_SetupPhaseReset+0x1a>
            if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMCON))
   17324:	2100      	movs	r1, #0
   17326:	f007 fde9 	bl	1eefc <_DRV_PHY_SMIReadStart>
   1732a:	2800      	cmp	r0, #0
   1732c:	d0ed      	beq.n	1730a <_DRV_ETHPHY_SetupPhaseReset+0x1a>
                hClientObj->operTStamp = SYS_TMR_TickCountGet() + ((DRV_ETHPHY_RESET_CLR_TMO * SYS_TMR_TickCounterFrequencyGet()) + 999) / 1000;
   1732e:	f008 fedd 	bl	200ec <SYS_TMR_TickCountGet>
   17332:	4605      	mov	r5, r0
   17334:	f008 ff02 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
   17338:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   1733c:	fb03 f000 	mul.w	r0, r3, r0
   17340:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
   17344:	4b13      	ldr	r3, [pc, #76]	; (17394 <_DRV_ETHPHY_SetupPhaseReset+0xa4>)
   17346:	fba3 3000 	umull	r3, r0, r3, r0
   1734a:	eb05 1090 	add.w	r0, r5, r0, lsr #6
   1734e:	62a0      	str	r0, [r4, #40]	; 0x28
    hClientObj->operPhase = operPhase;
   17350:	2302      	movs	r3, #2
   17352:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   17354:	8423      	strh	r3, [r4, #32]
   17356:	e7d8      	b.n	1730a <_DRV_ETHPHY_SetupPhaseReset+0x1a>
            if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   17358:	f009 fa24 	bl	207a4 <_DRV_PHY_SMITransfer_Wait>
   1735c:	2800      	cmp	r0, #0
   1735e:	d0d4      	beq.n	1730a <_DRV_ETHPHY_SetupPhaseReset+0x1a>
            if(bmcon.RESET)
   17360:	f994 303b 	ldrsb.w	r3, [r4, #59]	; 0x3b
   17364:	2b00      	cmp	r3, #0
   17366:	db04      	blt.n	17372 <_DRV_ETHPHY_SetupPhaseReset+0x82>
    hClientObj->operPhase = operPhase;
   17368:	2303      	movs	r3, #3
   1736a:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1736c:	2300      	movs	r3, #0
   1736e:	8423      	strh	r3, [r4, #32]
   17370:	e7cb      	b.n	1730a <_DRV_ETHPHY_SetupPhaseReset+0x1a>
                if(SYS_TMR_TickCountGet() < hClientObj->operTStamp)
   17372:	f008 febb 	bl	200ec <SYS_TMR_TickCountGet>
   17376:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   17378:	4298      	cmp	r0, r3
   1737a:	d204      	bcs.n	17386 <_DRV_ETHPHY_SetupPhaseReset+0x96>
    hClientObj->operPhase = operPhase;
   1737c:	2302      	movs	r3, #2
   1737e:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   17380:	2301      	movs	r3, #1
   17382:	8423      	strh	r3, [r4, #32]
   17384:	e7c1      	b.n	1730a <_DRV_ETHPHY_SetupPhaseReset+0x1a>
                    _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_DTCT_ERR);
   17386:	f04f 31ff 	mov.w	r1, #4294967295
   1738a:	4620      	mov	r0, r4
   1738c:	f008 fcce 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
   17390:	e7bb      	b.n	1730a <_DRV_ETHPHY_SetupPhaseReset+0x1a>
   17392:	bf00      	nop
   17394:	10624dd3 	.word	0x10624dd3

Disassembly of section .text._TCP_SktSetSequenceNo%351:

00017398 <_TCP_SktSetSequenceNo>:
{
   17398:	b570      	push	{r4, r5, r6, lr}
   1739a:	b0fa      	sub	sp, #488	; 0x1e8
   1739c:	4604      	mov	r4, r0
    SYS_RANDOM_CryptoBlockGet(secretKey, sizeof(secretKey));
   1739e:	2110      	movs	r1, #16
   173a0:	a808      	add	r0, sp, #32
   173a2:	f008 ffdd 	bl	20360 <SYS_RANDOM_CryptoBlockGet>
    CRYPT_MD5_Initialize(&md5Ctx);
   173a6:	a80c      	add	r0, sp, #48	; 0x30
   173a8:	f00a fb4c 	bl	21a44 <CRYPT_MD5_Initialize>
    if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   173ac:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
   173b0:	2b01      	cmp	r3, #1
   173b2:	d033      	beq.n	1741c <_TCP_SktSetSequenceNo+0x84>
    size_t dataSize = 0;    // actual data size
   173b4:	2200      	movs	r2, #0
    CRYPT_MD5_DataAdd(&md5Ctx, hashData.data8, dataSize);
   173b6:	a901      	add	r1, sp, #4
   173b8:	a80c      	add	r0, sp, #48	; 0x30
   173ba:	f009 fff6 	bl	213aa <CRYPT_MD5_DataAdd>
    CRYPT_MD5_Finalize(&md5Ctx, hashData.data8);
   173be:	a901      	add	r1, sp, #4
   173c0:	a80c      	add	r0, sp, #48	; 0x30
   173c2:	f009 fffe 	bl	213c2 <CRYPT_MD5_Finalize>
    uint32_t m = (SYS_TIME_Counter64Get() * 1000000 / 64 ) / SYS_TIME_FrequencyGet();   // 274 seconds period > MSL = 120 seconds
   173c6:	f006 ffd3 	bl	1e370 <SYS_TIME_Counter64Get>
   173ca:	4604      	mov	r4, r0
   173cc:	460d      	mov	r5, r1
   173ce:	f00a fe45 	bl	2205c <SYS_TIME_FrequencyGet>
   173d2:	016a      	lsls	r2, r5, #5
   173d4:	0163      	lsls	r3, r4, #5
   173d6:	ea42 61d4 	orr.w	r1, r2, r4, lsr #27
   173da:	1b1b      	subs	r3, r3, r4
   173dc:	eb61 0105 	sbc.w	r1, r1, r5
   173e0:	024a      	lsls	r2, r1, #9
   173e2:	ea42 52d3 	orr.w	r2, r2, r3, lsr #23
   173e6:	025e      	lsls	r6, r3, #9
   173e8:	4611      	mov	r1, r2
   173ea:	1933      	adds	r3, r6, r4
   173ec:	eb45 0101 	adc.w	r1, r5, r1
   173f0:	018e      	lsls	r6, r1, #6
   173f2:	ea46 6693 	orr.w	r6, r6, r3, lsr #26
   173f6:	019a      	lsls	r2, r3, #6
   173f8:	1ad3      	subs	r3, r2, r3
   173fa:	eb66 0101 	sbc.w	r1, r6, r1
   173fe:	191b      	adds	r3, r3, r4
   17400:	eb45 0101 	adc.w	r1, r5, r1
   17404:	099c      	lsrs	r4, r3, #6
   17406:	4602      	mov	r2, r0
   17408:	2300      	movs	r3, #0
   1740a:	ea44 6081 	orr.w	r0, r4, r1, lsl #26
   1740e:	0989      	lsrs	r1, r1, #6
   17410:	f008 f87a 	bl	1f508 <__aeabi_uldivmod>
    uint32_t seq = hashData.data32[0] + m;
   17414:	9b01      	ldr	r3, [sp, #4]
}
   17416:	4418      	add	r0, r3
   17418:	b07a      	add	sp, #488	; 0x1e8
   1741a:	bd70      	pop	{r4, r5, r6, pc}
        hashData.ipv4HashData[0] = pSkt->srcAddress.Val;
   1741c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1741e:	9301      	str	r3, [sp, #4]
        hashData.ipv4HashData[1] = pSkt->destAddress.Val;
   17420:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   17422:	9302      	str	r3, [sp, #8]
        hashData.ipv4HashData[2] = ((uint32_t)pSkt->localPort << 16) + (uint32_t)pSkt->remotePort;
   17424:	f8b4 205a 	ldrh.w	r2, [r4, #90]	; 0x5a
   17428:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
   1742c:	eb03 4302 	add.w	r3, r3, r2, lsl #16
   17430:	9303      	str	r3, [sp, #12]
        memcpy(hashData.ipv4HashData + 3, secretKey, sizeof(secretKey));
   17432:	ab08      	add	r3, sp, #32
   17434:	ac04      	add	r4, sp, #16
   17436:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   17438:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        dataSize = sizeof(hashData.ipv4HashData);
   1743c:	221c      	movs	r2, #28
   1743e:	e7ba      	b.n	173b6 <_TCP_SktSetSequenceNo+0x1e>

Disassembly of section .text.TCPIP_TCP_ServerOpen%352:

00017440 <TCPIP_TCP_ServerOpen>:
{
   17440:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   if(addType == IP_ADDRESS_TYPE_IPV6)
   17442:	2802      	cmp	r0, #2
   17444:	d038      	beq.n	174b8 <TCPIP_TCP_ServerOpen+0x78>
   17446:	4614      	mov	r4, r2
   17448:	460d      	mov	r5, r1
    if(addType == IP_ADDRESS_TYPE_IPV4 && localAddress != 0 && localAddress->v4Add.Val != 0)
   1744a:	b10a      	cbz	r2, 17450 <TCPIP_TCP_ServerOpen+0x10>
   1744c:	6813      	ldr	r3, [r2, #0]
   1744e:	b95b      	cbnz	r3, 17468 <TCPIP_TCP_ServerOpen+0x28>
    skt = _TCP_Open(addType, TCP_OPEN_SERVER, localPort, 0);
   17450:	2300      	movs	r3, #0
   17452:	462a      	mov	r2, r5
   17454:	4619      	mov	r1, r3
   17456:	2001      	movs	r0, #1
   17458:	f7f5 f906 	bl	c668 <_TCP_Open>
   1745c:	4606      	mov	r6, r0
    if(skt != INVALID_SOCKET)
   1745e:	f1b0 3fff 	cmp.w	r0, #4294967295
   17462:	d12f      	bne.n	174c4 <TCPIP_TCP_ServerOpen+0x84>
}
   17464:	4630      	mov	r0, r6
   17466:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        pDefIf = TCPIP_STACK_IPAddToNet(&localAddress->v4Add, false);
   17468:	2100      	movs	r1, #0
   1746a:	4610      	mov	r0, r2
   1746c:	f009 f852 	bl	20514 <TCPIP_STACK_IPAddToNet>
        if(pDefIf == 0)
   17470:	4607      	mov	r7, r0
   17472:	b320      	cbz	r0, 174be <TCPIP_TCP_ServerOpen+0x7e>
    skt = _TCP_Open(addType, TCP_OPEN_SERVER, localPort, 0);
   17474:	2300      	movs	r3, #0
   17476:	462a      	mov	r2, r5
   17478:	4619      	mov	r1, r3
   1747a:	2001      	movs	r0, #1
   1747c:	f7f5 f8f4 	bl	c668 <_TCP_Open>
   17480:	4606      	mov	r6, r0
    if(skt != INVALID_SOCKET)
   17482:	f1b0 3fff 	cmp.w	r0, #4294967295
   17486:	d0ed      	beq.n	17464 <TCPIP_TCP_ServerOpen+0x24>
        TCB_STUB* pSkt = TCBStubs[skt]; 
   17488:	4b16      	ldr	r3, [pc, #88]	; (174e4 <TCPIP_TCP_ServerOpen+0xa4>)
   1748a:	681b      	ldr	r3, [r3, #0]
   1748c:	f853 5026 	ldr.w	r5, [r3, r6, lsl #2]
    pSkt->pSktNet = pNet;
   17490:	642f      	str	r7, [r5, #64]	; 0x40
    _TCPSetSourceAddress(pSkt, pSkt->addType, srcAddress);
   17492:	4622      	mov	r2, r4
   17494:	f895 106f 	ldrb.w	r1, [r5, #111]	; 0x6f
   17498:	4628      	mov	r0, r5
   1749a:	f007 fa6e 	bl	1e97a <_TCPSetSourceAddress>
            pSkt->flags.openBindIf = 1;
   1749e:	f895 306d 	ldrb.w	r3, [r5, #109]	; 0x6d
   174a2:	f043 0320 	orr.w	r3, r3, #32
   174a6:	f885 306d 	strb.w	r3, [r5, #109]	; 0x6d
            pSkt->flags.openBindAdd = 1;
   174aa:	f895 306d 	ldrb.w	r3, [r5, #109]	; 0x6d
   174ae:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   174b2:	f885 306d 	strb.w	r3, [r5, #109]	; 0x6d
   174b6:	e7d5      	b.n	17464 <TCPIP_TCP_ServerOpen+0x24>
       return INVALID_SOCKET;
   174b8:	f04f 36ff 	mov.w	r6, #4294967295
   174bc:	e7d2      	b.n	17464 <TCPIP_TCP_ServerOpen+0x24>
            return INVALID_SOCKET;
   174be:	f04f 36ff 	mov.w	r6, #4294967295
   174c2:	e7cf      	b.n	17464 <TCPIP_TCP_ServerOpen+0x24>
        TCB_STUB* pSkt = TCBStubs[skt]; 
   174c4:	4b07      	ldr	r3, [pc, #28]	; (174e4 <TCPIP_TCP_ServerOpen+0xa4>)
   174c6:	681b      	ldr	r3, [r3, #0]
   174c8:	f853 5026 	ldr.w	r5, [r3, r6, lsl #2]
    pSkt->pSktNet = pNet;
   174cc:	2300      	movs	r3, #0
   174ce:	642b      	str	r3, [r5, #64]	; 0x40
    _TCPSetSourceAddress(pSkt, pSkt->addType, srcAddress);
   174d0:	4622      	mov	r2, r4
   174d2:	f895 106f 	ldrb.w	r1, [r5, #111]	; 0x6f
   174d6:	4628      	mov	r0, r5
   174d8:	f007 fa4f 	bl	1e97a <_TCPSetSourceAddress>
        if(localAddress != 0)
   174dc:	2c00      	cmp	r4, #0
   174de:	d0c1      	beq.n	17464 <TCPIP_TCP_ServerOpen+0x24>
   174e0:	e7e3      	b.n	174aa <TCPIP_TCP_ServerOpen+0x6a>
   174e2:	bf00      	nop
   174e4:	2000e38c 	.word	0x2000e38c

Disassembly of section .text.SERCOM1_USART_Write%353:

000174e8 <SERCOM1_USART_Write>:
{
   174e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    while (nBytesWritten < size)
   174ec:	2900      	cmp	r1, #0
   174ee:	d046      	beq.n	1757e <SERCOM1_USART_Write+0x96>
   174f0:	468c      	mov	ip, r1
    if (tempInIndex >= sercom1USARTObj.wrBufferSize)
   174f2:	4b24      	ldr	r3, [pc, #144]	; (17584 <SERCOM1_USART_Write+0x9c>)
   174f4:	691f      	ldr	r7, [r3, #16]
   174f6:	2400      	movs	r4, #0
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   174f8:	4923      	ldr	r1, [pc, #140]	; (17588 <SERCOM1_USART_Write+0xa0>)
    uint32_t wrInIndex = sercom1USARTObj.wrInIndex;
   174fa:	461a      	mov	r2, r3
            ((uint16_t*)&SERCOM1_USART_WriteBuffer)[wrInIndex] = wrByte;
   174fc:	f8df e08c 	ldr.w	lr, [pc, #140]	; 1758c <SERCOM1_USART_Write+0xa4>
   17500:	e00f      	b.n	17522 <SERCOM1_USART_Write+0x3a>
            if (SERCOM1_USART_TxPushByte(pWrBuffer[nBytesWritten]) == true)
   17502:	f810 8004 	ldrb.w	r8, [r0, r4]
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   17506:	684e      	ldr	r6, [r1, #4]
   17508:	f006 0607 	and.w	r6, r6, #7
   1750c:	2e01      	cmp	r6, #1
            SERCOM1_USART_WriteBuffer[wrInIndex] = (uint8_t)wrByte;
   1750e:	bf14      	ite	ne
   17510:	f80e 8005 	strbne.w	r8, [lr, r5]
            if (SERCOM1_USART_TxPushByte(pWrBuffer[nBytesWritten]) == true)
   17514:	f82e 8015 	strheq.w	r8, [lr, r5, lsl #1]
        sercom1USARTObj.wrInIndex = tempInIndex;
   17518:	6093      	str	r3, [r2, #8]
                nBytesWritten++;
   1751a:	1c63      	adds	r3, r4, #1
   1751c:	3401      	adds	r4, #1
    while (nBytesWritten < size)
   1751e:	4563      	cmp	r3, ip
   17520:	d22b      	bcs.n	1757a <SERCOM1_USART_Write+0x92>
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   17522:	684b      	ldr	r3, [r1, #4]
   17524:	f003 0307 	and.w	r3, r3, #7
   17528:	2b01      	cmp	r3, #1
   1752a:	d010      	beq.n	1754e <SERCOM1_USART_Write+0x66>
    uint32_t wrInIndex = sercom1USARTObj.wrInIndex;
   1752c:	6895      	ldr	r5, [r2, #8]
    uint32_t wrOutIndex = sercom1USARTObj.wrOutIndex;
   1752e:	68d6      	ldr	r6, [r2, #12]
    tempInIndex = wrInIndex + 1U;
   17530:	1c6b      	adds	r3, r5, #1
        tempInIndex = 0U;
   17532:	42bb      	cmp	r3, r7
   17534:	bf28      	it	cs
   17536:	2300      	movcs	r3, #0
    if (tempInIndex != wrOutIndex)
   17538:	429e      	cmp	r6, r3
   1753a:	d1e2      	bne.n	17502 <SERCOM1_USART_Write+0x1a>
    if (SERCOM1_USART_WritePendingBytesGet() > 0U)
   1753c:	f00a f86e 	bl	2161c <SERCOM1_USART_WritePendingBytesGet>
   17540:	b110      	cbz	r0, 17548 <SERCOM1_USART_Write+0x60>
        SERCOM1_USART_TX_INT_ENABLE();
   17542:	4b11      	ldr	r3, [pc, #68]	; (17588 <SERCOM1_USART_Write+0xa0>)
   17544:	2201      	movs	r2, #1
   17546:	759a      	strb	r2, [r3, #22]
}
   17548:	4620      	mov	r0, r4
   1754a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    uint32_t wrInIndex = sercom1USARTObj.wrInIndex;
   1754e:	6895      	ldr	r5, [r2, #8]
    uint32_t wrOutIndex = sercom1USARTObj.wrOutIndex;
   17550:	68d6      	ldr	r6, [r2, #12]
    tempInIndex = wrInIndex + 1U;
   17552:	1c6b      	adds	r3, r5, #1
        tempInIndex = 0U;
   17554:	42bb      	cmp	r3, r7
   17556:	bf28      	it	cs
   17558:	2300      	movcs	r3, #0
    if (tempInIndex != wrOutIndex)
   1755a:	429e      	cmp	r6, r3
   1755c:	d0ee      	beq.n	1753c <SERCOM1_USART_Write+0x54>
            if (SERCOM1_USART_TxPushByte(((uint16_t*)pWrBuffer)[nBytesWritten]) == true)
   1755e:	f830 8014 	ldrh.w	r8, [r0, r4, lsl #1]
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   17562:	684e      	ldr	r6, [r1, #4]
   17564:	f006 0607 	and.w	r6, r6, #7
   17568:	2e01      	cmp	r6, #1
            SERCOM1_USART_WriteBuffer[wrInIndex] = (uint8_t)wrByte;
   1756a:	bf14      	ite	ne
   1756c:	f80e 8005 	strbne.w	r8, [lr, r5]
            ((uint16_t*)&SERCOM1_USART_WriteBuffer)[wrInIndex] = wrByte;
   17570:	f82e 8015 	strheq.w	r8, [lr, r5, lsl #1]
        sercom1USARTObj.wrInIndex = tempInIndex;
   17574:	6093      	str	r3, [r2, #8]
                nBytesWritten++;
   17576:	1c63      	adds	r3, r4, #1
   17578:	e7d0      	b.n	1751c <SERCOM1_USART_Write+0x34>
   1757a:	461c      	mov	r4, r3
   1757c:	e7de      	b.n	1753c <SERCOM1_USART_Write+0x54>
    size_t nBytesWritten  = 0U;
   1757e:	460c      	mov	r4, r1
   17580:	e7dc      	b.n	1753c <SERCOM1_USART_Write+0x54>
   17582:	bf00      	nop
   17584:	2000dff0 	.word	0x2000dff0
   17588:	40003400 	.word	0x40003400
   1758c:	2000b004 	.word	0x2000b004

Disassembly of section .text.vTaskSwitchContext%354:

00017590 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   17590:	4b24      	ldr	r3, [pc, #144]	; (17624 <vTaskSwitchContext+0x94>)
   17592:	681b      	ldr	r3, [r3, #0]
   17594:	b11b      	cbz	r3, 1759e <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
   17596:	4b24      	ldr	r3, [pc, #144]	; (17628 <vTaskSwitchContext+0x98>)
   17598:	2201      	movs	r2, #1
   1759a:	601a      	str	r2, [r3, #0]
   1759c:	4770      	bx	lr
{
   1759e:	b510      	push	{r4, lr}
		xYieldPending = pdFALSE;
   175a0:	4b21      	ldr	r3, [pc, #132]	; (17628 <vTaskSwitchContext+0x98>)
   175a2:	2200      	movs	r2, #0
   175a4:	601a      	str	r2, [r3, #0]
		taskCHECK_FOR_STACK_OVERFLOW();
   175a6:	4b21      	ldr	r3, [pc, #132]	; (1762c <vTaskSwitchContext+0x9c>)
   175a8:	681b      	ldr	r3, [r3, #0]
   175aa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   175ac:	681a      	ldr	r2, [r3, #0]
   175ae:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
   175b2:	d103      	bne.n	175bc <vTaskSwitchContext+0x2c>
   175b4:	685a      	ldr	r2, [r3, #4]
   175b6:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
   175ba:	d023      	beq.n	17604 <vTaskSwitchContext+0x74>
   175bc:	4b1b      	ldr	r3, [pc, #108]	; (1762c <vTaskSwitchContext+0x9c>)
   175be:	6818      	ldr	r0, [r3, #0]
   175c0:	6819      	ldr	r1, [r3, #0]
   175c2:	3134      	adds	r1, #52	; 0x34
   175c4:	f00a fa7d 	bl	21ac2 <vApplicationStackOverflowHook>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   175c8:	4b19      	ldr	r3, [pc, #100]	; (17630 <vTaskSwitchContext+0xa0>)
   175ca:	681b      	ldr	r3, [r3, #0]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
	{
	uint8_t ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
   175cc:	fab3 f383 	clz	r3, r3
   175d0:	b2db      	uxtb	r3, r3
   175d2:	f1c3 031f 	rsb	r3, r3, #31
   175d6:	4a17      	ldr	r2, [pc, #92]	; (17634 <vTaskSwitchContext+0xa4>)
   175d8:	0099      	lsls	r1, r3, #2
   175da:	18c8      	adds	r0, r1, r3
   175dc:	eb02 0080 	add.w	r0, r2, r0, lsl #2
   175e0:	6844      	ldr	r4, [r0, #4]
   175e2:	6864      	ldr	r4, [r4, #4]
   175e4:	6044      	str	r4, [r0, #4]
   175e6:	4419      	add	r1, r3
   175e8:	4602      	mov	r2, r0
   175ea:	3208      	adds	r2, #8
   175ec:	4294      	cmp	r4, r2
   175ee:	d012      	beq.n	17616 <vTaskSwitchContext+0x86>
   175f0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   175f4:	4a0f      	ldr	r2, [pc, #60]	; (17634 <vTaskSwitchContext+0xa4>)
   175f6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   175fa:	685b      	ldr	r3, [r3, #4]
   175fc:	68da      	ldr	r2, [r3, #12]
   175fe:	4b0b      	ldr	r3, [pc, #44]	; (1762c <vTaskSwitchContext+0x9c>)
   17600:	601a      	str	r2, [r3, #0]
}
   17602:	bd10      	pop	{r4, pc}
		taskCHECK_FOR_STACK_OVERFLOW();
   17604:	689a      	ldr	r2, [r3, #8]
   17606:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
   1760a:	d1d7      	bne.n	175bc <vTaskSwitchContext+0x2c>
   1760c:	68db      	ldr	r3, [r3, #12]
   1760e:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
   17612:	d1d3      	bne.n	175bc <vTaskSwitchContext+0x2c>
   17614:	e7d8      	b.n	175c8 <vTaskSwitchContext+0x38>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   17616:	6860      	ldr	r0, [r4, #4]
   17618:	460a      	mov	r2, r1
   1761a:	4906      	ldr	r1, [pc, #24]	; (17634 <vTaskSwitchContext+0xa4>)
   1761c:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   17620:	6050      	str	r0, [r2, #4]
   17622:	e7e5      	b.n	175f0 <vTaskSwitchContext+0x60>
   17624:	2000e4b0 	.word	0x2000e4b0
   17628:	2000e4d4 	.word	0x2000e4d4
   1762c:	2000e49c 	.word	0x2000e49c
   17630:	2000e4b8 	.word	0x2000e4b8
   17634:	2000de80 	.word	0x2000de80

Disassembly of section .text.xTaskPriorityInherit%355:

00017638 <xTaskPriorityInherit>:
	BaseType_t xReturn = pdFALSE;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
   17638:	2800      	cmp	r0, #0
   1763a:	d049      	beq.n	176d0 <xTaskPriorityInherit+0x98>
	{
   1763c:	b538      	push	{r3, r4, r5, lr}
   1763e:	4604      	mov	r4, r0
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
   17640:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   17642:	4924      	ldr	r1, [pc, #144]	; (176d4 <xTaskPriorityInherit+0x9c>)
   17644:	6809      	ldr	r1, [r1, #0]
   17646:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
   17648:	428a      	cmp	r2, r1
   1764a:	d238      	bcs.n	176be <xTaskPriorityInherit+0x86>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   1764c:	6981      	ldr	r1, [r0, #24]
   1764e:	2900      	cmp	r1, #0
   17650:	db05      	blt.n	1765e <xTaskPriorityInherit+0x26>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   17652:	4920      	ldr	r1, [pc, #128]	; (176d4 <xTaskPriorityInherit+0x9c>)
   17654:	6809      	ldr	r1, [r1, #0]
   17656:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
   17658:	f1c1 0105 	rsb	r1, r1, #5
   1765c:	6181      	str	r1, [r0, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
   1765e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   17662:	491d      	ldr	r1, [pc, #116]	; (176d8 <xTaskPriorityInherit+0xa0>)
   17664:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   17668:	6961      	ldr	r1, [r4, #20]
   1766a:	4291      	cmp	r1, r2
   1766c:	d005      	beq.n	1767a <xTaskPriorityInherit+0x42>
					prvAddTaskToReadyList( pxMutexHolderTCB );
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   1766e:	4a19      	ldr	r2, [pc, #100]	; (176d4 <xTaskPriorityInherit+0x9c>)
   17670:	6812      	ldr	r2, [r2, #0]
   17672:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
   17674:	62e2      	str	r2, [r4, #44]	; 0x2c
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
   17676:	2001      	movs	r0, #1
   17678:	e029      	b.n	176ce <xTaskPriorityInherit+0x96>
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   1767a:	1d25      	adds	r5, r4, #4
   1767c:	4628      	mov	r0, r5
   1767e:	f008 ffb9 	bl	205f4 <uxListRemove>
   17682:	b938      	cbnz	r0, 17694 <xTaskPriorityInherit+0x5c>
						portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
   17684:	4915      	ldr	r1, [pc, #84]	; (176dc <xTaskPriorityInherit+0xa4>)
   17686:	680b      	ldr	r3, [r1, #0]
   17688:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   1768a:	2201      	movs	r2, #1
   1768c:	4082      	lsls	r2, r0
   1768e:	ea23 0302 	bic.w	r3, r3, r2
   17692:	600b      	str	r3, [r1, #0]
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   17694:	4b0f      	ldr	r3, [pc, #60]	; (176d4 <xTaskPriorityInherit+0x9c>)
   17696:	681b      	ldr	r3, [r3, #0]
   17698:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
   1769a:	62e0      	str	r0, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
   1769c:	4a0f      	ldr	r2, [pc, #60]	; (176dc <xTaskPriorityInherit+0xa4>)
   1769e:	6811      	ldr	r1, [r2, #0]
   176a0:	2401      	movs	r4, #1
   176a2:	fa04 f300 	lsl.w	r3, r4, r0
   176a6:	430b      	orrs	r3, r1
   176a8:	6013      	str	r3, [r2, #0]
   176aa:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   176ae:	4629      	mov	r1, r5
   176b0:	4b09      	ldr	r3, [pc, #36]	; (176d8 <xTaskPriorityInherit+0xa0>)
   176b2:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   176b6:	f00a f8c6 	bl	21846 <vListInsertEnd>
				xReturn = pdTRUE;
   176ba:	4620      	mov	r0, r4
   176bc:	e007      	b.n	176ce <xTaskPriorityInherit+0x96>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
   176be:	4a05      	ldr	r2, [pc, #20]	; (176d4 <xTaskPriorityInherit+0x9c>)
   176c0:	6812      	ldr	r2, [r2, #0]
   176c2:	6c40      	ldr	r0, [r0, #68]	; 0x44
   176c4:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   176c6:	4298      	cmp	r0, r3
   176c8:	bf2c      	ite	cs
   176ca:	2000      	movcs	r0, #0
   176cc:	2001      	movcc	r0, #1
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
   176ce:	bd38      	pop	{r3, r4, r5, pc}
	BaseType_t xReturn = pdFALSE;
   176d0:	2000      	movs	r0, #0
	}
   176d2:	4770      	bx	lr
   176d4:	2000e49c 	.word	0x2000e49c
   176d8:	2000de80 	.word	0x2000de80
   176dc:	2000e4b8 	.word	0x2000e4b8

Disassembly of section .text.__lshift%356:

000176e0 <__lshift>:
   176e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   176e4:	460c      	mov	r4, r1
   176e6:	ea4f 1a62 	mov.w	sl, r2, asr #5
   176ea:	6923      	ldr	r3, [r4, #16]
   176ec:	6849      	ldr	r1, [r1, #4]
   176ee:	eb0a 0903 	add.w	r9, sl, r3
   176f2:	68a3      	ldr	r3, [r4, #8]
   176f4:	4607      	mov	r7, r0
   176f6:	4616      	mov	r6, r2
   176f8:	f109 0501 	add.w	r5, r9, #1
   176fc:	42ab      	cmp	r3, r5
   176fe:	db33      	blt.n	17768 <__lshift+0x88>
   17700:	4638      	mov	r0, r7
   17702:	f003 fc77 	bl	1aff4 <_Balloc>
   17706:	2300      	movs	r3, #0
   17708:	4680      	mov	r8, r0
   1770a:	f100 0114 	add.w	r1, r0, #20
   1770e:	f100 0210 	add.w	r2, r0, #16
   17712:	4618      	mov	r0, r3
   17714:	4553      	cmp	r3, sl
   17716:	db2a      	blt.n	1776e <__lshift+0x8e>
   17718:	6920      	ldr	r0, [r4, #16]
   1771a:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
   1771e:	f104 0314 	add.w	r3, r4, #20
   17722:	f016 021f 	ands.w	r2, r6, #31
   17726:	eb01 018a 	add.w	r1, r1, sl, lsl #2
   1772a:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
   1772e:	d022      	beq.n	17776 <__lshift+0x96>
   17730:	f1c2 0e20 	rsb	lr, r2, #32
   17734:	2000      	movs	r0, #0
   17736:	681e      	ldr	r6, [r3, #0]
   17738:	4096      	lsls	r6, r2
   1773a:	4330      	orrs	r0, r6
   1773c:	f841 0b04 	str.w	r0, [r1], #4
   17740:	f853 0b04 	ldr.w	r0, [r3], #4
   17744:	459c      	cmp	ip, r3
   17746:	fa20 f00e 	lsr.w	r0, r0, lr
   1774a:	d8f4      	bhi.n	17736 <__lshift+0x56>
   1774c:	6008      	str	r0, [r1, #0]
   1774e:	b108      	cbz	r0, 17754 <__lshift+0x74>
   17750:	f109 0502 	add.w	r5, r9, #2
   17754:	3d01      	subs	r5, #1
   17756:	4638      	mov	r0, r7
   17758:	f8c8 5010 	str.w	r5, [r8, #16]
   1775c:	4621      	mov	r1, r4
   1775e:	f008 f844 	bl	1f7ea <_Bfree>
   17762:	4640      	mov	r0, r8
   17764:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   17768:	3101      	adds	r1, #1
   1776a:	005b      	lsls	r3, r3, #1
   1776c:	e7c6      	b.n	176fc <__lshift+0x1c>
   1776e:	f842 0f04 	str.w	r0, [r2, #4]!
   17772:	3301      	adds	r3, #1
   17774:	e7ce      	b.n	17714 <__lshift+0x34>
   17776:	3904      	subs	r1, #4
   17778:	f853 2b04 	ldr.w	r2, [r3], #4
   1777c:	f841 2f04 	str.w	r2, [r1, #4]!
   17780:	459c      	cmp	ip, r3
   17782:	d8f9      	bhi.n	17778 <__lshift+0x98>
   17784:	e7e6      	b.n	17754 <__lshift+0x74>

Disassembly of section .text._DHCPProcessReceiveData%357:

00017788 <_DHCPProcessReceiveData>:
{
   17788:	b5f0      	push	{r4, r5, r6, r7, lr}
   1778a:	b083      	sub	sp, #12
   1778c:	4605      	mov	r5, r0
   1778e:	460e      	mov	r6, r1
    if(TCPIP_UDP_GetIsReady(dhcpClientSocket) == 0)
   17790:	4b24      	ldr	r3, [pc, #144]	; (17824 <_DHCPProcessReceiveData+0x9c>)
   17792:	f9b3 0000 	ldrsh.w	r0, [r3]
   17796:	f008 fc6d 	bl	20074 <TCPIP_UDP_GetIsReady>
   1779a:	2800      	cmp	r0, #0
   1779c:	d03d      	beq.n	1781a <_DHCPProcessReceiveData+0x92>
    recvRes = _DHCPReceive(pClient, pNetIf);
   1779e:	4631      	mov	r1, r6
   177a0:	4628      	mov	r0, r5
   177a2:	f7f7 fe8d 	bl	f4c0 <_DHCPReceive>
   177a6:	4604      	mov	r4, r0
    switch(recvRes)
   177a8:	2805      	cmp	r0, #5
   177aa:	d00c      	beq.n	177c6 <_DHCPProcessReceiveData+0x3e>
   177ac:	2806      	cmp	r0, #6
   177ae:	d135      	bne.n	1781c <_DHCPProcessReceiveData+0x94>
            dhcpEv = DHCP_EVENT_NACK;
   177b0:	2706      	movs	r7, #6
        _DHCPSetRunFail(pClient, TCPIP_DHCP_SEND_DISCOVERY, false);
   177b2:	2200      	movs	r2, #0
   177b4:	2102      	movs	r1, #2
   177b6:	4628      	mov	r0, r5
   177b8:	f005 f946 	bl	1ca48 <_DHCPSetRunFail>
        _DHCPNotifyClients(pNetIf, dhcpEv);
   177bc:	4639      	mov	r1, r7
   177be:	4630      	mov	r0, r6
   177c0:	f006 fcc8 	bl	1e154 <_DHCPNotifyClients>
   177c4:	e02a      	b.n	1781c <_DHCPProcessReceiveData+0x94>
            if( pClient->smState == TCPIP_DHCP_GET_REQUEST_ACK)
   177c6:	f8b5 3056 	ldrh.w	r3, [r5, #86]	; 0x56
   177ca:	2b05      	cmp	r3, #5
   177cc:	d00a      	beq.n	177e4 <_DHCPProcessReceiveData+0x5c>
            else if( pClient->smState == TCPIP_DHCP_GET_RENEW_ACK || pClient->smState == TCPIP_DHCP_GET_REBIND_ACK)
   177ce:	2b0a      	cmp	r3, #10
   177d0:	d001      	beq.n	177d6 <_DHCPProcessReceiveData+0x4e>
   177d2:	2b0c      	cmp	r3, #12
   177d4:	d122      	bne.n	1781c <_DHCPProcessReceiveData+0x94>
                pClient->tRequest = pClient->tRenewRequest;
   177d6:	68eb      	ldr	r3, [r5, #12]
   177d8:	60ab      	str	r3, [r5, #8]
                _DHCPSetBoundState(pClient);
   177da:	4628      	mov	r0, r5
   177dc:	f006 f96a 	bl	1dab4 <_DHCPSetBoundState>
                dhcpEv = DHCP_EVENT_BOUND;
   177e0:	2708      	movs	r7, #8
   177e2:	e7eb      	b.n	177bc <_DHCPProcessReceiveData+0x34>
                if(pClient->validValues.IPAddress == 0 || pClient->validValues.Mask == 0)
   177e4:	f895 3059 	ldrb.w	r3, [r5, #89]	; 0x59
   177e8:	f003 0305 	and.w	r3, r3, #5
   177ec:	2b05      	cmp	r3, #5
   177ee:	d001      	beq.n	177f4 <_DHCPProcessReceiveData+0x6c>
                    dhcpEv = DHCP_EVENT_ACK_INVALID;
   177f0:	2704      	movs	r7, #4
   177f2:	e7de      	b.n	177b2 <_DHCPProcessReceiveData+0x2a>
                IPV4_ADDR zeroAdd = { 0 };
   177f4:	2300      	movs	r3, #0
   177f6:	9301      	str	r3, [sp, #4]
                arpCheck.Val = pClient->dhcpIPAddress.Val;
   177f8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   177fa:	9300      	str	r3, [sp, #0]
                TCPIP_ARP_Probe(pNetIf, &arpCheck, &zeroAdd, ARP_OPERATION_REQ | ARP_OPERATION_CONFIGURE |  ARP_OPERATION_GRATUITOUS);
   177fc:	f243 0301 	movw	r3, #12289	; 0x3001
   17800:	aa01      	add	r2, sp, #4
   17802:	4669      	mov	r1, sp
   17804:	4630      	mov	r0, r6
   17806:	f004 f8bd 	bl	1b984 <TCPIP_ARP_Probe>
    return dhcpSecondCount;
   1780a:	4b07      	ldr	r3, [pc, #28]	; (17828 <_DHCPProcessReceiveData+0xa0>)
                pClient->startWait = _DHCPSecondCountGet();
   1780c:	681b      	ldr	r3, [r3, #0]
   1780e:	606b      	str	r3, [r5, #4]
    pClient->smState = newState;
   17810:	2306      	movs	r3, #6
   17812:	f8a5 3056 	strh.w	r3, [r5, #86]	; 0x56
                dhcpEv = DHCP_EVENT_ACK;
   17816:	2703      	movs	r7, #3
   17818:	e7d0      	b.n	177bc <_DHCPProcessReceiveData+0x34>
        return TCPIP_DHCP_TIMEOUT_MESSAGE;
   1781a:	240a      	movs	r4, #10
}
   1781c:	4620      	mov	r0, r4
   1781e:	b003      	add	sp, #12
   17820:	bdf0      	pop	{r4, r5, r6, r7, pc}
   17822:	bf00      	nop
   17824:	2000e504 	.word	0x2000e504
   17828:	2000e418 	.word	0x2000e418

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0%358:

0001782c <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0>:
{
   1782c:	b510      	push	{r4, lr}
   1782e:	4604      	mov	r4, r0
    openFlags = hClientObj->hDriver->openFlags;
   17830:	68c1      	ldr	r1, [r0, #12]
   17832:	898b      	ldrh	r3, [r1, #12]
    if(!(openFlags & (TCPIP_ETH_OPEN_FDUPLEX|TCPIP_ETH_OPEN_HDUPLEX)))
   17834:	f013 0f06 	tst.w	r3, #6
        openFlags |= TCPIP_ETH_OPEN_HDUPLEX;
   17838:	bf08      	it	eq
   1783a:	f043 0304 	orreq.w	r3, r3, #4
    if(!(openFlags & (TCPIP_ETH_OPEN_100|TCPIP_ETH_OPEN_10)))
   1783e:	f013 0f18 	tst.w	r3, #24
        openFlags |= TCPIP_ETH_OPEN_10;
   17842:	bf08      	it	eq
   17844:	f043 0310 	orreq.w	r3, r3, #16
    if(openFlags & TCPIP_ETH_OPEN_AUTO)
   17848:	f013 0f01 	tst.w	r3, #1
   1784c:	d01e      	beq.n	1788c <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x60>
        if(openFlags & TCPIP_ETH_OPEN_100)
   1784e:	f013 0f08 	tst.w	r3, #8
   17852:	d00c      	beq.n	1786e <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x42>
            if(openFlags & TCPIP_ETH_OPEN_FDUPLEX)
   17854:	f003 0202 	and.w	r2, r3, #2
                openReqs |= _BMSTAT_BASE100TX_FDX_MASK;
   17858:	2a00      	cmp	r2, #0
   1785a:	f244 0208 	movw	r2, #16392	; 0x4008
   1785e:	bf08      	it	eq
   17860:	2208      	moveq	r2, #8
            if(openFlags & TCPIP_ETH_OPEN_HDUPLEX)
   17862:	f013 0f04 	tst.w	r3, #4
   17866:	d003      	beq.n	17870 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x44>
                openReqs |= _BMSTAT_BASE100TX_HDX_MASK;
   17868:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
   1786c:	e000      	b.n	17870 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x44>
        openReqs = _BMSTAT_AN_ABLE_MASK;
   1786e:	2208      	movs	r2, #8
        if(openFlags & TCPIP_ETH_OPEN_10)
   17870:	f013 0f10 	tst.w	r3, #16
   17874:	d015      	beq.n	178a2 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x76>
            if(openFlags & TCPIP_ETH_OPEN_FDUPLEX)
   17876:	f013 0f02 	tst.w	r3, #2
                openReqs |= _BMSTAT_BASE10T_FDX_MASK;
   1787a:	bf18      	it	ne
   1787c:	f442 5280 	orrne.w	r2, r2, #4096	; 0x1000
            if(openFlags & TCPIP_ETH_OPEN_HDUPLEX)
   17880:	f013 0f04 	tst.w	r3, #4
   17884:	d00d      	beq.n	178a2 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x76>
                openReqs |= _BMSTAT_BASE10T_HDX_MASK;
   17886:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
   1788a:	e00a      	b.n	178a2 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x76>
        if(openFlags & TCPIP_ETH_OPEN_100)
   1788c:	f013 0f08 	tst.w	r3, #8
   17890:	d00f      	beq.n	178b2 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x86>
            openReqs = (openFlags & TCPIP_ETH_OPEN_FDUPLEX) ? _BMSTAT_BASE100TX_FDX_MASK : _BMSTAT_BASE100TX_HDX_MASK;
   17892:	f003 0202 	and.w	r2, r3, #2
   17896:	2a00      	cmp	r2, #0
   17898:	bf14      	ite	ne
   1789a:	f44f 4280 	movne.w	r2, #16384	; 0x4000
   1789e:	f44f 5200 	moveq.w	r2, #8192	; 0x2000
    hClientObj->hDriver->openFlags = openFlags;
   178a2:	818b      	strh	r3, [r1, #12]
    hClientObj->operReg[0] = openReqs;
   178a4:	8462      	strh	r2, [r4, #34]	; 0x22
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   178a6:	2101      	movs	r1, #1
   178a8:	4620      	mov	r0, r4
   178aa:	f007 fb27 	bl	1eefc <_DRV_PHY_SMIReadStart>
   178ae:	b948      	cbnz	r0, 178c4 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x98>
}
   178b0:	bd10      	pop	{r4, pc}
            openReqs = (openFlags & TCPIP_ETH_OPEN_FDUPLEX) ? _BMSTAT_BASE10T_FDX_MASK : _BMSTAT_BASE10T_HDX_MASK;
   178b2:	f003 0202 	and.w	r2, r3, #2
   178b6:	2a00      	cmp	r2, #0
   178b8:	bf14      	ite	ne
   178ba:	f44f 5280 	movne.w	r2, #4096	; 0x1000
   178be:	f44f 6200 	moveq.w	r2, #2048	; 0x800
   178c2:	e7ee      	b.n	178a2 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x76>
    hClientObj->operPhase = operPhase;
   178c4:	2303      	movs	r3, #3
   178c6:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   178c8:	2301      	movs	r3, #1
   178ca:	8423      	strh	r3, [r4, #32]
}
   178cc:	e7f0      	b.n	178b0 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x84>

Disassembly of section .text.TCPIP_Helper_IPv6AddressToString%359:

000178ce <TCPIP_Helper_IPv6AddressToString>:
    if(v6Addr && buff && buffSize >= 41)
   178ce:	b3d8      	cbz	r0, 17948 <TCPIP_Helper_IPv6AddressToString+0x7a>
{
   178d0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   178d4:	460e      	mov	r6, r1
   178d6:	4607      	mov	r7, r0
    if(v6Addr && buff && buffSize >= 41)
   178d8:	b3c1      	cbz	r1, 1794c <TCPIP_Helper_IPv6AddressToString+0x7e>
   178da:	2a28      	cmp	r2, #40	; 0x28
   178dc:	d802      	bhi.n	178e4 <TCPIP_Helper_IPv6AddressToString+0x16>
    return false;
   178de:	2000      	movs	r0, #0
}
   178e0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   178e4:	1c45      	adds	r5, r0, #1
   178e6:	4682      	mov	sl, r0
   178e8:	f100 0b11 	add.w	fp, r0, #17
   178ec:	f100 090f 	add.w	r9, r0, #15
   178f0:	e017      	b.n	17922 <TCPIP_Helper_IPv6AddressToString+0x54>
                *str++ = k;
   178f2:	f806 0b01 	strb.w	r0, [r6], #1
            k = btohexa_high(v6Addr->v[1 + (i<<1)]);
   178f6:	eba5 080a 	sub.w	r8, r5, sl
   178fa:	7820      	ldrb	r0, [r4, #0]
   178fc:	f00a fb5a 	bl	21fb4 <btohexa_high>
                *str++ = k;
   17900:	4634      	mov	r4, r6
   17902:	f804 0b01 	strb.w	r0, [r4], #1
            k = btohexa_low(v6Addr->v[1 + (i<<1)]);
   17906:	f817 0008 	ldrb.w	r0, [r7, r8]
   1790a:	f00a f9f6 	bl	21cfa <btohexa_low>
            *str++ = k;
   1790e:	7020      	strb	r0, [r4, #0]
            if (i != 7)
   17910:	454d      	cmp	r5, r9
   17912:	d014      	beq.n	1793e <TCPIP_Helper_IPv6AddressToString+0x70>
                *str++ = ':';
   17914:	1ca6      	adds	r6, r4, #2
   17916:	f04f 033a 	mov.w	r3, #58	; 0x3a
   1791a:	7063      	strb	r3, [r4, #1]
   1791c:	3502      	adds	r5, #2
        for (i = 0; i < 8; i++)
   1791e:	455d      	cmp	r5, fp
   17920:	d00e      	beq.n	17940 <TCPIP_Helper_IPv6AddressToString+0x72>
            k = btohexa_high(v6Addr->v[(i<<1)]);
   17922:	462c      	mov	r4, r5
   17924:	f815 0c01 	ldrb.w	r0, [r5, #-1]
   17928:	f00a fb44 	bl	21fb4 <btohexa_high>
            if (k != '0')
   1792c:	2830      	cmp	r0, #48	; 0x30
   1792e:	d00f      	beq.n	17950 <TCPIP_Helper_IPv6AddressToString+0x82>
                *str++ = k;
   17930:	f806 0b01 	strb.w	r0, [r6], #1
            k = btohexa_low(v6Addr->v[(i<<1)]);
   17934:	f815 0c01 	ldrb.w	r0, [r5, #-1]
   17938:	f00a f9df 	bl	21cfa <btohexa_low>
            if (k != '0' || j == true)
   1793c:	e7d9      	b.n	178f2 <TCPIP_Helper_IPv6AddressToString+0x24>
            *str++ = k;
   1793e:	1c66      	adds	r6, r4, #1
        *str = 0;
   17940:	2300      	movs	r3, #0
   17942:	7033      	strb	r3, [r6, #0]
        return true;
   17944:	2001      	movs	r0, #1
   17946:	e7cb      	b.n	178e0 <TCPIP_Helper_IPv6AddressToString+0x12>
    return false;
   17948:	2000      	movs	r0, #0
}
   1794a:	4770      	bx	lr
    return false;
   1794c:	2000      	movs	r0, #0
   1794e:	e7c7      	b.n	178e0 <TCPIP_Helper_IPv6AddressToString+0x12>
            k = btohexa_low(v6Addr->v[(i<<1)]);
   17950:	f815 0c01 	ldrb.w	r0, [r5, #-1]
   17954:	f00a f9d1 	bl	21cfa <btohexa_low>
            if (k != '0' || j == true)
   17958:	2830      	cmp	r0, #48	; 0x30
   1795a:	d1ca      	bne.n	178f2 <TCPIP_Helper_IPv6AddressToString+0x24>
            k = btohexa_high(v6Addr->v[1 + (i<<1)]);
   1795c:	eba5 080a 	sub.w	r8, r5, sl
   17960:	7820      	ldrb	r0, [r4, #0]
   17962:	f00a fb27 	bl	21fb4 <btohexa_high>
            if (k != '0' || j == true)
   17966:	2830      	cmp	r0, #48	; 0x30
   17968:	bf08      	it	eq
   1796a:	4634      	moveq	r4, r6
   1796c:	d0cb      	beq.n	17906 <TCPIP_Helper_IPv6AddressToString+0x38>
   1796e:	e7c7      	b.n	17900 <TCPIP_Helper_IPv6AddressToString+0x32>

Disassembly of section .text.wc_RNG_HealthTest_ex%360:

00017970 <wc_RNG_HealthTest_ex>:
{
   17970:	b570      	push	{r4, r5, r6, lr}
   17972:	b0a6      	sub	sp, #152	; 0x98
   17974:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
    if (seedA == NULL || output == NULL) {
   17976:	2b00      	cmp	r3, #0
   17978:	d03f      	beq.n	179fa <wc_RNG_HealthTest_ex+0x8a>
   1797a:	461e      	mov	r6, r3
   1797c:	2d00      	cmp	r5, #0
   1797e:	d03f      	beq.n	17a00 <wc_RNG_HealthTest_ex+0x90>
    if (reseed != 0 && seedB == NULL) {
   17980:	b110      	cbz	r0, 17988 <wc_RNG_HealthTest_ex+0x18>
   17982:	9b2b      	ldr	r3, [sp, #172]	; 0xac
   17984:	2b00      	cmp	r3, #0
   17986:	d03e      	beq.n	17a06 <wc_RNG_HealthTest_ex+0x96>
    if (outputSz != RNG_HEALTH_TEST_CHECK_SIZE) {
   17988:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
   1798a:	2b80      	cmp	r3, #128	; 0x80
   1798c:	d13e      	bne.n	17a0c <wc_RNG_HealthTest_ex+0x9c>
   1798e:	460b      	mov	r3, r1
   17990:	4604      	mov	r4, r0
    if (Hash_DRBG_Instantiate(drbg, seedA, seedASz, nonce, nonceSz,
   17992:	9930      	ldr	r1, [sp, #192]	; 0xc0
   17994:	9102      	str	r1, [sp, #8]
   17996:	992f      	ldr	r1, [sp, #188]	; 0xbc
   17998:	9101      	str	r1, [sp, #4]
   1799a:	9200      	str	r2, [sp, #0]
   1799c:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
   1799e:	4631      	mov	r1, r6
   179a0:	a805      	add	r0, sp, #20
   179a2:	f002 fd42 	bl	1a42a <Hash_DRBG_Instantiate>
   179a6:	b9c8      	cbnz	r0, 179dc <wc_RNG_HealthTest_ex+0x6c>
    if (reseed) {
   179a8:	b12c      	cbz	r4, 179b6 <wc_RNG_HealthTest_ex+0x46>
        if (Hash_DRBG_Reseed(drbg, seedB, seedBSz) != 0) {
   179aa:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
   179ac:	992b      	ldr	r1, [sp, #172]	; 0xac
   179ae:	a805      	add	r0, sp, #20
   179b0:	f7ff fc48 	bl	17244 <Hash_DRBG_Reseed>
   179b4:	b9f0      	cbnz	r0, 179f4 <wc_RNG_HealthTest_ex+0x84>
    if (Hash_DRBG_Generate(drbg, output, outputSz) != 0) {
   179b6:	2280      	movs	r2, #128	; 0x80
   179b8:	4629      	mov	r1, r5
   179ba:	a805      	add	r0, sp, #20
   179bc:	f7f4 fb84 	bl	c0c8 <Hash_DRBG_Generate>
   179c0:	b110      	cbz	r0, 179c8 <wc_RNG_HealthTest_ex+0x58>
    int ret = -1;
   179c2:	f04f 34ff 	mov.w	r4, #4294967295
   179c6:	e00b      	b.n	179e0 <wc_RNG_HealthTest_ex+0x70>
    if (Hash_DRBG_Generate(drbg, output, outputSz) != 0) {
   179c8:	2280      	movs	r2, #128	; 0x80
   179ca:	4629      	mov	r1, r5
   179cc:	a805      	add	r0, sp, #20
   179ce:	f7f4 fb7b 	bl	c0c8 <Hash_DRBG_Generate>
   179d2:	3000      	adds	r0, #0
   179d4:	bf18      	it	ne
   179d6:	2001      	movne	r0, #1
   179d8:	4244      	negs	r4, r0
   179da:	e001      	b.n	179e0 <wc_RNG_HealthTest_ex+0x70>
    int ret = -1;
   179dc:	f04f 34ff 	mov.w	r4, #4294967295
    if (Hash_DRBG_Uninstantiate(drbg) != 0) {
   179e0:	a805      	add	r0, sp, #20
   179e2:	f007 fa23 	bl	1ee2c <Hash_DRBG_Uninstantiate>
   179e6:	2800      	cmp	r0, #0
        ret = -1;
   179e8:	bf18      	it	ne
   179ea:	f04f 34ff 	movne.w	r4, #4294967295
}
   179ee:	4620      	mov	r0, r4
   179f0:	b026      	add	sp, #152	; 0x98
   179f2:	bd70      	pop	{r4, r5, r6, pc}
    int ret = -1;
   179f4:	f04f 34ff 	mov.w	r4, #4294967295
   179f8:	e7f2      	b.n	179e0 <wc_RNG_HealthTest_ex+0x70>
        return BAD_FUNC_ARG;
   179fa:	f06f 04ac 	mvn.w	r4, #172	; 0xac
   179fe:	e7f6      	b.n	179ee <wc_RNG_HealthTest_ex+0x7e>
   17a00:	f06f 04ac 	mvn.w	r4, #172	; 0xac
   17a04:	e7f3      	b.n	179ee <wc_RNG_HealthTest_ex+0x7e>
        return BAD_FUNC_ARG;
   17a06:	f06f 04ac 	mvn.w	r4, #172	; 0xac
   17a0a:	e7f0      	b.n	179ee <wc_RNG_HealthTest_ex+0x7e>
        return ret;
   17a0c:	f04f 34ff 	mov.w	r4, #4294967295
   17a10:	e7ed      	b.n	179ee <wc_RNG_HealthTest_ex+0x7e>

Disassembly of section .text._ARPDeleteResources%361:

00017a14 <_ARPDeleteResources>:
{
   17a14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(arpMod.arpCacheDcpt)
   17a16:	4b26      	ldr	r3, [pc, #152]	; (17ab0 <_ARPDeleteResources+0x9c>)
   17a18:	685c      	ldr	r4, [r3, #4]
   17a1a:	b364      	cbz	r4, 17a76 <_ARPDeleteResources+0x62>
        for(ix = 0, pArpDcpt = arpMod.arpCacheDcpt; ix < arpMod.nIfs; ix++, pArpDcpt++)
   17a1c:	681b      	ldr	r3, [r3, #0]
   17a1e:	2b00      	cmp	r3, #0
   17a20:	dd22      	ble.n	17a68 <_ARPDeleteResources+0x54>
   17a22:	342c      	adds	r4, #44	; 0x2c
   17a24:	2500      	movs	r5, #0
        TCPIP_HEAP_Free(arpMod.memH, pArpDcpt->hashDcpt);
   17a26:	4e22      	ldr	r6, [pc, #136]	; (17ab0 <_ARPDeleteResources+0x9c>)
        pArpDcpt->hashDcpt = 0;
   17a28:	462f      	mov	r7, r5
   17a2a:	e018      	b.n	17a5e <_ARPDeleteResources+0x4a>
        TCPIP_OAHASH_EntriesRemoveAll(pArpDcpt->hashDcpt);
   17a2c:	f007 fbec 	bl	1f208 <TCPIP_OAHASH_EntriesRemoveAll>
        TCPIP_Helper_ProtectedSingleListDeinitialize(&pArpDcpt->incompleteList);
   17a30:	4620      	mov	r0, r4
   17a32:	f007 fc19 	bl	1f268 <TCPIP_Helper_ProtectedSingleListDeinitialize>
        TCPIP_Helper_ProtectedSingleListDeinitialize(&pArpDcpt->completeList);
   17a36:	f1a4 0014 	sub.w	r0, r4, #20
   17a3a:	f007 fc15 	bl	1f268 <TCPIP_Helper_ProtectedSingleListDeinitialize>
        TCPIP_Helper_ProtectedSingleListDeinitialize(&pArpDcpt->permList);
   17a3e:	f1a4 0028 	sub.w	r0, r4, #40	; 0x28
   17a42:	f007 fc11 	bl	1f268 <TCPIP_Helper_ProtectedSingleListDeinitialize>
        TCPIP_HEAP_Free(arpMod.memH, pArpDcpt->hashDcpt);
   17a46:	68b0      	ldr	r0, [r6, #8]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   17a48:	68c3      	ldr	r3, [r0, #12]
   17a4a:	f854 1c2c 	ldr.w	r1, [r4, #-44]
   17a4e:	4798      	blx	r3
        pArpDcpt->hashDcpt = 0;
   17a50:	f844 7c2c 	str.w	r7, [r4, #-44]
        for(ix = 0, pArpDcpt = arpMod.arpCacheDcpt; ix < arpMod.nIfs; ix++, pArpDcpt++)
   17a54:	3501      	adds	r5, #1
   17a56:	3448      	adds	r4, #72	; 0x48
   17a58:	6833      	ldr	r3, [r6, #0]
   17a5a:	42ab      	cmp	r3, r5
   17a5c:	dd04      	ble.n	17a68 <_ARPDeleteResources+0x54>
    if(pArpDcpt->hashDcpt)
   17a5e:	f854 0c2c 	ldr.w	r0, [r4, #-44]
   17a62:	2800      	cmp	r0, #0
   17a64:	d1e2      	bne.n	17a2c <_ARPDeleteResources+0x18>
   17a66:	e7f5      	b.n	17a54 <_ARPDeleteResources+0x40>
        TCPIP_HEAP_Free(arpMod.memH, arpMod.arpCacheDcpt);
   17a68:	4c11      	ldr	r4, [pc, #68]	; (17ab0 <_ARPDeleteResources+0x9c>)
   17a6a:	68a0      	ldr	r0, [r4, #8]
   17a6c:	68c3      	ldr	r3, [r0, #12]
   17a6e:	6861      	ldr	r1, [r4, #4]
   17a70:	4798      	blx	r3
        arpMod.arpCacheDcpt = 0;
   17a72:	2300      	movs	r3, #0
   17a74:	6063      	str	r3, [r4, #4]
    TCPIP_Notification_Deinitialize(&arpMod.registeredUsers, arpMod.memH);
   17a76:	4c0e      	ldr	r4, [pc, #56]	; (17ab0 <_ARPDeleteResources+0x9c>)
   17a78:	68a1      	ldr	r1, [r4, #8]
   17a7a:	f104 0020 	add.w	r0, r4, #32
   17a7e:	f00a f88d 	bl	21b9c <TCPIP_Notification_Deinitialize>
    arpMod.memH = 0;
   17a82:	2300      	movs	r3, #0
   17a84:	60a3      	str	r3, [r4, #8]
    if(arpMod.timerHandle)
   17a86:	69e0      	ldr	r0, [r4, #28]
   17a88:	b118      	cbz	r0, 17a92 <_ARPDeleteResources+0x7e>
        _TCPIPStackSignalHandlerDeregister(arpMod.timerHandle);
   17a8a:	f00a f952 	bl	21d32 <_TCPIPStackSignalHandlerDeregister>
        arpMod.timerHandle = 0;
   17a8e:	2200      	movs	r2, #0
   17a90:	61e2      	str	r2, [r4, #28]
    if(arpMod.pMacPkt)
   17a92:	4b07      	ldr	r3, [pc, #28]	; (17ab0 <_ARPDeleteResources+0x9c>)
   17a94:	6c98      	ldr	r0, [r3, #72]	; 0x48
   17a96:	b130      	cbz	r0, 17aa6 <_ARPDeleteResources+0x92>
        if((arpMod.pMacPkt->pktFlags & TCPIP_MAC_PKT_FLAG_QUEUED) == 0 )
   17a98:	8c43      	ldrh	r3, [r0, #34]	; 0x22
   17a9a:	f013 0f08 	tst.w	r3, #8
   17a9e:	d003      	beq.n	17aa8 <_ARPDeleteResources+0x94>
        arpMod.pMacPkt = 0;
   17aa0:	4b03      	ldr	r3, [pc, #12]	; (17ab0 <_ARPDeleteResources+0x9c>)
   17aa2:	2200      	movs	r2, #0
   17aa4:	649a      	str	r2, [r3, #72]	; 0x48
}
   17aa6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            TCPIP_PKT_PacketFree(arpMod.pMacPkt);
   17aa8:	f006 fbae 	bl	1e208 <_TCPIP_PKT_PacketFree>
   17aac:	e7f8      	b.n	17aa0 <_ARPDeleteResources+0x8c>
   17aae:	bf00      	nop
   17ab0:	2000dfa4 	.word	0x2000dfa4

Disassembly of section .text._UDPv4AllocateSktTxBuffer%362:

00017ab4 <_UDPv4AllocateSktTxBuffer>:
    if(addType != IP_ADDRESS_TYPE_IPV4)
   17ab4:	2901      	cmp	r1, #1
   17ab6:	d145      	bne.n	17b44 <__MIN_HEAP_SIZE+0x84>
    if(pSkt->txAllocCnt >= pSkt->txAllocLimit)
   17ab8:	f890 103f 	ldrb.w	r1, [r0, #63]	; 0x3f
   17abc:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
   17ac0:	4299      	cmp	r1, r3
   17ac2:	d242      	bcs.n	17b4a <__MIN_HEAP_SIZE+0x8a>
{
   17ac4:	b570      	push	{r4, r5, r6, lr}
    if(pSkt->flags.stackConfig != 0)
   17ac6:	f890 1041 	ldrb.w	r1, [r0, #65]	; 0x41
   17aca:	f001 0308 	and.w	r3, r1, #8
        allocFlags |= TCPIP_MAC_PKT_FLAG_CONFIG;
   17ace:	2b00      	cmp	r3, #0
   17ad0:	bf0c      	ite	eq
   17ad2:	2300      	moveq	r3, #0
   17ad4:	f44f 4300 	movne.w	r3, #32768	; 0x8000
    if(pSkt->flags.txSplitAlloc == 0)
   17ad8:	f011 0f02 	tst.w	r1, #2
        allocFlags |= TCPIP_MAC_PKT_FLAG_SPLIT;
   17adc:	bf1a      	itte	ne
   17ade:	f043 0304 	orrne.w	r3, r3, #4
        pktSize = sizeof(UDP_V4_PACKET) + sizeof(*((UDP_V4_PACKET*)0)->zcSeg);
   17ae2:	265c      	movne	r6, #92	; 0x5c
        pktSize = sizeof(UDP_V4_PACKET);
   17ae4:	2644      	moveq	r6, #68	; 0x44
   17ae6:	4615      	mov	r5, r2
   17ae8:	4604      	mov	r4, r0
    return TCPIP_PKT_SocketAlloc(pktSize, sizeof(UDP_HEADER), txBuffSize, allocFlags);
   17aea:	f043 0302 	orr.w	r3, r3, #2
   17aee:	8a02      	ldrh	r2, [r0, #16]
   17af0:	2108      	movs	r1, #8
   17af2:	4630      	mov	r0, r6
   17af4:	f007 ff40 	bl	1f978 <_TCPIP_PKT_SocketAlloc>
    if(pPkt)
   17af8:	4603      	mov	r3, r0
   17afa:	b1a8      	cbz	r0, 17b28 <__MIN_HEAP_SIZE+0x68>
    pPkt->ackFunc = ackFunc;
   17afc:	4a14      	ldr	r2, [pc, #80]	; (17b50 <__MIN_HEAP_SIZE+0x90>)
   17afe:	6082      	str	r2, [r0, #8]
    pPkt->ackParam = ackParam;
   17b00:	60c4      	str	r4, [r0, #12]
        if(pSkt->flags.txSplitAlloc)
   17b02:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
   17b06:	f012 0f02 	tst.w	r2, #2
   17b0a:	d00f      	beq.n	17b2c <__MIN_HEAP_SIZE+0x6c>
            pPkt->pDSeg->next = pZSeg;
   17b0c:	6902      	ldr	r2, [r0, #16]
            TCPIP_MAC_DATA_SEGMENT* pZSeg = ((UDP_V4_PACKET*)pPkt)->zcSeg;
   17b0e:	f100 0144 	add.w	r1, r0, #68	; 0x44
            pPkt->pDSeg->next = pZSeg;
   17b12:	6011      	str	r1, [r2, #0]
            pZSeg->segFlags = TCPIP_MAC_SEG_FLAG_STATIC;   // embedded in packet itself
   17b14:	2201      	movs	r2, #1
   17b16:	f8a0 2054 	strh.w	r2, [r0, #84]	; 0x54
            pTxBuff = 0;    // will be set as external payload
   17b1a:	2200      	movs	r2, #0
        if(update)
   17b1c:	b94d      	cbnz	r5, 17b32 <__MIN_HEAP_SIZE+0x72>
        pSkt->txAllocCnt++;
   17b1e:	f894 203f 	ldrb.w	r2, [r4, #63]	; 0x3f
   17b22:	3201      	adds	r2, #1
   17b24:	f884 203f 	strb.w	r2, [r4, #63]	; 0x3f
}
   17b28:	4618      	mov	r0, r3
   17b2a:	bd70      	pop	{r4, r5, r6, pc}
            pTxBuff = pPkt->pTransportLayer + sizeof(UDP_HEADER);
   17b2c:	69c2      	ldr	r2, [r0, #28]
   17b2e:	3208      	adds	r2, #8
   17b30:	e7f4      	b.n	17b1c <__MIN_HEAP_SIZE+0x5c>
    pSkt->txStart = txBuff;
   17b32:	6022      	str	r2, [r4, #0]
    pSkt->txEnd = txBuff + pSkt->txSize;
   17b34:	8a21      	ldrh	r1, [r4, #16]
   17b36:	4411      	add	r1, r2
   17b38:	6061      	str	r1, [r4, #4]
    pSkt->txWrite = txBuff;
   17b3a:	60a2      	str	r2, [r4, #8]
    pSkt->addType =  addType;
   17b3c:	2201      	movs	r2, #1
   17b3e:	87a2      	strh	r2, [r4, #60]	; 0x3c
    pSkt->pPkt = pTxPkt;
   17b40:	60e3      	str	r3, [r4, #12]
   17b42:	e7ec      	b.n	17b1e <__MIN_HEAP_SIZE+0x5e>
        return 0;
   17b44:	2300      	movs	r3, #0
}
   17b46:	4618      	mov	r0, r3
   17b48:	4770      	bx	lr
        return 0;
   17b4a:	2300      	movs	r3, #0
   17b4c:	e7fb      	b.n	17b46 <__MIN_HEAP_SIZE+0x86>
   17b4e:	bf00      	nop
   17b50:	000136fd 	.word	0x000136fd

Disassembly of section .text.TCPIP_UDP_Disconnect%363:

00017b54 <TCPIP_UDP_Disconnect>:
{
   17b54:	b538      	push	{r3, r4, r5, lr}
   17b56:	460d      	mov	r5, r1
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   17b58:	f008 fa64 	bl	20024 <_UDPSocketDcpt>
    if(pSkt)
   17b5c:	2800      	cmp	r0, #0
   17b5e:	d044      	beq.n	17bea <TCPIP_UDP_Disconnect+0x96>
   17b60:	4604      	mov	r4, r0
        if(pSkt->flags.openAddType == IP_ADDRESS_TYPE_ANY)
   17b62:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
   17b66:	f013 0f30 	tst.w	r3, #48	; 0x30
   17b6a:	d036      	beq.n	17bda <TCPIP_UDP_Disconnect+0x86>
    pSkt->extFlags.rxEnable = 0;
   17b6c:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   17b70:	f36f 0341 	bfc	r3, #1, #1
   17b74:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        pSkt->addType = (IP_ADDRESS_TYPE)pSkt->flags.openAddType;
   17b78:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
   17b7c:	f3c3 1201 	ubfx	r2, r3, #4, #2
   17b80:	87a2      	strh	r2, [r4, #60]	; 0x3c
        if(pSkt->flags.openBindIf == 0)
   17b82:	f013 0f40 	tst.w	r3, #64	; 0x40
            pSkt->pSktNet = 0;
   17b86:	bf04      	itt	eq
   17b88:	2200      	moveq	r2, #0
   17b8a:	6262      	streq	r2, [r4, #36]	; 0x24
        if(pSkt->flags.openBindAdd == 0)
   17b8c:	f013 0f80 	tst.w	r3, #128	; 0x80
   17b90:	d109      	bne.n	17ba6 <TCPIP_UDP_Disconnect+0x52>
            pSkt->srcAddress.Val = 0;
   17b92:	2200      	movs	r2, #0
   17b94:	61a2      	str	r2, [r4, #24]
            pSkt->flags.srcValid = pSkt->flags.srcSolved = 0;
   17b96:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
   17b9a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   17b9e:	f362 1386 	bfi	r3, r2, #6, #1
   17ba2:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        if(pSkt->extFlags.serverSkt != 0 && pSkt->flags.looseRemPort != 0)
   17ba6:	6c22      	ldr	r2, [r4, #64]	; 0x40
   17ba8:	4b11      	ldr	r3, [pc, #68]	; (17bf0 <TCPIP_UDP_Disconnect+0x9c>)
   17baa:	4393      	bics	r3, r2
            pSkt->remotePort = 0;
   17bac:	bf04      	itt	eq
   17bae:	2300      	moveq	r3, #0
   17bb0:	8523      	strheq	r3, [r4, #40]	; 0x28
        if(flushRxQueue)
   17bb2:	b1ad      	cbz	r5, 17be0 <TCPIP_UDP_Disconnect+0x8c>
            _UDPFreeRxQueue(pSkt);
   17bb4:	4620      	mov	r0, r4
   17bb6:	f008 fcbf 	bl	20538 <_UDPFreeRxQueue>
    TCPIP_MAC_PACKET* pNextPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(&pSkt->rxQueue);
   17bba:	f104 0044 	add.w	r0, r4, #68	; 0x44
   17bbe:	f009 f9ab 	bl	20f18 <TCPIP_Helper_SingleListHeadRemove>
    _UDPSetNewRxPacket(pSkt, pNextPkt);
   17bc2:	4601      	mov	r1, r0
   17bc4:	4620      	mov	r0, r4
   17bc6:	f005 fe53 	bl	1d870 <_UDPSetNewRxPacket>
    pSkt->extFlags.rxEnable = 1;
   17bca:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   17bce:	f043 0302 	orr.w	r3, r3, #2
   17bd2:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        return true;
   17bd6:	2001      	movs	r0, #1
}
   17bd8:	bd38      	pop	{r3, r4, r5, pc}
            _UDPFreeTxResources(pSkt);
   17bda:	f007 fee3 	bl	1f9a4 <_UDPFreeTxResources>
   17bde:	e7c5      	b.n	17b6c <TCPIP_UDP_Disconnect+0x18>
            _UDPsetPacketInfo(pSkt, pSkt->pCurrRxPkt);
   17be0:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   17be2:	4620      	mov	r0, r4
   17be4:	f000 ffae 	bl	18b44 <_UDPsetPacketInfo>
   17be8:	e7ef      	b.n	17bca <TCPIP_UDP_Disconnect+0x76>
    return false;
   17bea:	2000      	movs	r0, #0
   17bec:	e7f4      	b.n	17bd8 <TCPIP_UDP_Disconnect+0x84>
   17bee:	bf00      	nop
   17bf0:	00800004 	.word	0x00800004

Disassembly of section .text%364:

00017c00 <memchr>:
   17c00:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   17c04:	2a10      	cmp	r2, #16
   17c06:	db2b      	blt.n	17c60 <memchr+0x60>
   17c08:	f010 0f07 	tst.w	r0, #7
   17c0c:	d008      	beq.n	17c20 <memchr+0x20>
   17c0e:	f810 3b01 	ldrb.w	r3, [r0], #1
   17c12:	3a01      	subs	r2, #1
   17c14:	428b      	cmp	r3, r1
   17c16:	d02d      	beq.n	17c74 <memchr+0x74>
   17c18:	f010 0f07 	tst.w	r0, #7
   17c1c:	b342      	cbz	r2, 17c70 <memchr+0x70>
   17c1e:	d1f6      	bne.n	17c0e <memchr+0xe>
   17c20:	b4f0      	push	{r4, r5, r6, r7}
   17c22:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
   17c26:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
   17c2a:	f022 0407 	bic.w	r4, r2, #7
   17c2e:	f07f 0700 	mvns.w	r7, #0
   17c32:	2300      	movs	r3, #0
   17c34:	e8f0 5602 	ldrd	r5, r6, [r0], #8
   17c38:	3c08      	subs	r4, #8
   17c3a:	ea85 0501 	eor.w	r5, r5, r1
   17c3e:	ea86 0601 	eor.w	r6, r6, r1
   17c42:	fa85 f547 	uadd8	r5, r5, r7
   17c46:	faa3 f587 	sel	r5, r3, r7
   17c4a:	fa86 f647 	uadd8	r6, r6, r7
   17c4e:	faa5 f687 	sel	r6, r5, r7
   17c52:	b98e      	cbnz	r6, 17c78 <memchr+0x78>
   17c54:	d1ee      	bne.n	17c34 <memchr+0x34>
   17c56:	bcf0      	pop	{r4, r5, r6, r7}
   17c58:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   17c5c:	f002 0207 	and.w	r2, r2, #7
   17c60:	b132      	cbz	r2, 17c70 <memchr+0x70>
   17c62:	f810 3b01 	ldrb.w	r3, [r0], #1
   17c66:	3a01      	subs	r2, #1
   17c68:	ea83 0301 	eor.w	r3, r3, r1
   17c6c:	b113      	cbz	r3, 17c74 <memchr+0x74>
   17c6e:	d1f8      	bne.n	17c62 <memchr+0x62>
   17c70:	2000      	movs	r0, #0
   17c72:	4770      	bx	lr
   17c74:	3801      	subs	r0, #1
   17c76:	4770      	bx	lr
   17c78:	2d00      	cmp	r5, #0
   17c7a:	bf06      	itte	eq
   17c7c:	4635      	moveq	r5, r6
   17c7e:	3803      	subeq	r0, #3
   17c80:	3807      	subne	r0, #7
   17c82:	f015 0f01 	tst.w	r5, #1
   17c86:	d107      	bne.n	17c98 <memchr+0x98>
   17c88:	3001      	adds	r0, #1
   17c8a:	f415 7f80 	tst.w	r5, #256	; 0x100
   17c8e:	bf02      	ittt	eq
   17c90:	3001      	addeq	r0, #1
   17c92:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
   17c96:	3001      	addeq	r0, #1
   17c98:	bcf0      	pop	{r4, r5, r6, r7}
   17c9a:	3801      	subs	r0, #1
   17c9c:	4770      	bx	lr
   17c9e:	bf00      	nop

Disassembly of section .text._DRV_PHY_SMITransferStart%365:

00017ca0 <_DRV_PHY_SMITransferStart>:
    if(hClientObj->miimOpHandle != 0)
   17ca0:	6983      	ldr	r3, [r0, #24]
   17ca2:	2b00      	cmp	r3, #0
   17ca4:	d135      	bne.n	17d12 <_DRV_PHY_SMITransferStart+0x72>
{
   17ca6:	b530      	push	{r4, r5, lr}
   17ca8:	b085      	sub	sp, #20
   17caa:	4604      	mov	r4, r0
    DRV_ETHPHY_SMI_XFER_TYPE txType = hClientObj->smiTxferType;
   17cac:	f890 3036 	ldrb.w	r3, [r0, #54]	; 0x36
    if(txType == DRV_ETHPHY_SMI_XFER_TYPE_READ)
   17cb0:	2b03      	cmp	r3, #3
   17cb2:	d01b      	beq.n	17cec <_DRV_PHY_SMITransferStart+0x4c>
    else if(txType == DRV_ETHPHY_SMI_XFER_TYPE_WRITE || txType == DRV_ETHPHY_SMI_XFER_TYPE_WRITE_COMPLETE)
   17cb4:	1e5a      	subs	r2, r3, #1
   17cb6:	b2d2      	uxtb	r2, r2
   17cb8:	2a01      	cmp	r2, #1
   17cba:	d82c      	bhi.n	17d16 <_DRV_PHY_SMITransferStart+0x76>
        if(txType == DRV_ETHPHY_SMI_XFER_TYPE_WRITE)
   17cbc:	2b01      	cmp	r3, #1
   17cbe:	d02d      	beq.n	17d1c <_DRV_PHY_SMITransferStart+0x7c>
        miimOpHandle = hClientObj->pMiimBase->DRV_MIIM_Write(hClientObj->miimHandle, hClientObj->smiRIx, hClientObj->smiPhyAddress, hClientObj->smiData, opFlags, &miimRes);
   17cc0:	6903      	ldr	r3, [r0, #16]
   17cc2:	f10d 020f 	add.w	r2, sp, #15
   17cc6:	9201      	str	r2, [sp, #4]
   17cc8:	2200      	movs	r2, #0
   17cca:	9200      	str	r2, [sp, #0]
   17ccc:	6b1d      	ldr	r5, [r3, #48]	; 0x30
   17cce:	8f43      	ldrh	r3, [r0, #58]	; 0x3a
   17cd0:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
   17cd2:	8f01      	ldrh	r1, [r0, #56]	; 0x38
   17cd4:	6940      	ldr	r0, [r0, #20]
   17cd6:	47a8      	blx	r5
    if(miimOpHandle == 0)
   17cd8:	4603      	mov	r3, r0
   17cda:	b9a0      	cbnz	r0, 17d06 <_DRV_PHY_SMITransferStart+0x66>
        if(miimRes == DRV_MIIM_RES_BUSY)
   17cdc:	f99d 300f 	ldrsb.w	r3, [sp, #15]
            return DRV_ETHPHY_SMI_TXFER_RES_MIIM_ERROR;
   17ce0:	2b02      	cmp	r3, #2
   17ce2:	bf0c      	ite	eq
   17ce4:	2003      	moveq	r0, #3
   17ce6:	f06f 0001 	mvnne.w	r0, #1
   17cea:	e010      	b.n	17d0e <_DRV_PHY_SMITransferStart+0x6e>
        miimOpHandle = hClientObj->pMiimBase->DRV_MIIM_Read(hClientObj->miimHandle, hClientObj->smiRIx, hClientObj->smiPhyAddress, DRV_MIIM_OPERATION_FLAG_NONE, &miimRes);
   17cec:	6903      	ldr	r3, [r0, #16]
   17cee:	f10d 020f 	add.w	r2, sp, #15
   17cf2:	9200      	str	r2, [sp, #0]
   17cf4:	6add      	ldr	r5, [r3, #44]	; 0x2c
   17cf6:	2300      	movs	r3, #0
   17cf8:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
   17cfa:	8f01      	ldrh	r1, [r0, #56]	; 0x38
   17cfc:	6940      	ldr	r0, [r0, #20]
   17cfe:	47a8      	blx	r5
    if(miimOpHandle == 0)
   17d00:	4603      	mov	r3, r0
   17d02:	2800      	cmp	r0, #0
   17d04:	d0ea      	beq.n	17cdc <_DRV_PHY_SMITransferStart+0x3c>
        hClientObj->miimOpHandle = miimOpHandle;
   17d06:	61a3      	str	r3, [r4, #24]
        txferRes = DRV_ETHPHY_SMI_TXFER_RES_SCHEDULED; 
   17d08:	2302      	movs	r3, #2
   17d0a:	2001      	movs	r0, #1
    hClientObj->smiTxferStatus = newTxferStatus;
   17d0c:	86a3      	strh	r3, [r4, #52]	; 0x34
}
   17d0e:	b005      	add	sp, #20
   17d10:	bd30      	pop	{r4, r5, pc}
        return DRV_ETHPHY_SMI_TXFER_RES_BUSY;
   17d12:	2003      	movs	r0, #3
}
   17d14:	4770      	bx	lr
        return DRV_ETHPHY_SMI_TXFER_RES_ILLEGAL;
   17d16:	f04f 30ff 	mov.w	r0, #4294967295
   17d1a:	e7f8      	b.n	17d0e <_DRV_PHY_SMITransferStart+0x6e>
        miimOpHandle = hClientObj->pMiimBase->DRV_MIIM_Write(hClientObj->miimHandle, hClientObj->smiRIx, hClientObj->smiPhyAddress, hClientObj->smiData, opFlags, &miimRes);
   17d1c:	6903      	ldr	r3, [r0, #16]
   17d1e:	f10d 020f 	add.w	r2, sp, #15
   17d22:	9201      	str	r2, [sp, #4]
   17d24:	2201      	movs	r2, #1
   17d26:	9200      	str	r2, [sp, #0]
   17d28:	6b1d      	ldr	r5, [r3, #48]	; 0x30
   17d2a:	8f43      	ldrh	r3, [r0, #58]	; 0x3a
   17d2c:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
   17d2e:	8f01      	ldrh	r1, [r0, #56]	; 0x38
   17d30:	6940      	ldr	r0, [r0, #20]
   17d32:	47a8      	blx	r5
    if(miimOpHandle == 0)
   17d34:	2800      	cmp	r0, #0
   17d36:	d0d1      	beq.n	17cdc <_DRV_PHY_SMITransferStart+0x3c>
            newTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
   17d38:	2300      	movs	r3, #0
        txferRes = DRV_ETHPHY_SMI_TXFER_RES_DONE; 
   17d3a:	4618      	mov	r0, r3
   17d3c:	e7e6      	b.n	17d0c <_DRV_PHY_SMITransferStart+0x6c>

Disassembly of section .text.__d2b%366:

00017d3e <__d2b>:
   17d3e:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   17d42:	ec59 8b10 	vmov	r8, r9, d0
   17d46:	460e      	mov	r6, r1
   17d48:	f240 74ff 	movw	r4, #2047	; 0x7ff
   17d4c:	2101      	movs	r1, #1
   17d4e:	4615      	mov	r5, r2
   17d50:	f003 f950 	bl	1aff4 <_Balloc>
   17d54:	f3c9 0313 	ubfx	r3, r9, #0, #20
   17d58:	ea14 5419 	ands.w	r4, r4, r9, lsr #20
   17d5c:	bf18      	it	ne
   17d5e:	f443 1380 	orrne.w	r3, r3, #1048576	; 0x100000
   17d62:	9301      	str	r3, [sp, #4]
   17d64:	f1b8 0300 	subs.w	r3, r8, #0
   17d68:	4607      	mov	r7, r0
   17d6a:	d023      	beq.n	17db4 <__d2b+0x76>
   17d6c:	4668      	mov	r0, sp
   17d6e:	9300      	str	r3, [sp, #0]
   17d70:	f003 fd4e 	bl	1b810 <__lo0bits>
   17d74:	9900      	ldr	r1, [sp, #0]
   17d76:	b1d8      	cbz	r0, 17db0 <__d2b+0x72>
   17d78:	9a01      	ldr	r2, [sp, #4]
   17d7a:	f1c0 0320 	rsb	r3, r0, #32
   17d7e:	fa02 f303 	lsl.w	r3, r2, r3
   17d82:	430b      	orrs	r3, r1
   17d84:	40c2      	lsrs	r2, r0
   17d86:	617b      	str	r3, [r7, #20]
   17d88:	9201      	str	r2, [sp, #4]
   17d8a:	9b01      	ldr	r3, [sp, #4]
   17d8c:	61bb      	str	r3, [r7, #24]
   17d8e:	2b00      	cmp	r3, #0
   17d90:	bf14      	ite	ne
   17d92:	2102      	movne	r1, #2
   17d94:	2101      	moveq	r1, #1
   17d96:	6139      	str	r1, [r7, #16]
   17d98:	b1ac      	cbz	r4, 17dc6 <__d2b+0x88>
   17d9a:	f2a4 4433 	subw	r4, r4, #1075	; 0x433
   17d9e:	4404      	add	r4, r0
   17da0:	6034      	str	r4, [r6, #0]
   17da2:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
   17da6:	6028      	str	r0, [r5, #0]
   17da8:	4638      	mov	r0, r7
   17daa:	b003      	add	sp, #12
   17dac:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   17db0:	6179      	str	r1, [r7, #20]
   17db2:	e7ea      	b.n	17d8a <__d2b+0x4c>
   17db4:	a801      	add	r0, sp, #4
   17db6:	f003 fd2b 	bl	1b810 <__lo0bits>
   17dba:	9b01      	ldr	r3, [sp, #4]
   17dbc:	617b      	str	r3, [r7, #20]
   17dbe:	2101      	movs	r1, #1
   17dc0:	6139      	str	r1, [r7, #16]
   17dc2:	3020      	adds	r0, #32
   17dc4:	e7e8      	b.n	17d98 <__d2b+0x5a>
   17dc6:	eb07 0381 	add.w	r3, r7, r1, lsl #2
   17dca:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
   17dce:	6030      	str	r0, [r6, #0]
   17dd0:	6918      	ldr	r0, [r3, #16]
   17dd2:	f006 f82f 	bl	1de34 <__hi0bits>
   17dd6:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
   17dda:	e7e4      	b.n	17da6 <__d2b+0x68>

Disassembly of section .text.DRV_MIIM_Setup%367:

00017ddc <DRV_MIIM_Setup>:
    if(pSetUp == 0)
   17ddc:	2900      	cmp	r1, #0
   17dde:	d042      	beq.n	17e66 <DRV_MIIM_Setup+0x8a>
{
   17de0:	b510      	push	{r4, lr}
   17de2:	460c      	mov	r4, r1
    if((pClient = _DRV_MIIM_GetClientAndLock(handle, true)) == 0)
   17de4:	2101      	movs	r1, #1
   17de6:	f004 fd48 	bl	1c87a <_DRV_MIIM_GetClientAndLock>
   17dea:	2800      	cmp	r0, #0
   17dec:	d03e      	beq.n	17e6c <DRV_MIIM_Setup+0x90>
    pMiimObj = pClient->parentObj;
   17dee:	6840      	ldr	r0, [r0, #4]
    
    static  __inline__ void __attribute__((always_inline)) _DRV_MIIM_SMI_CLOCK_SET(uintptr_t ethPhyId, uint32_t hostClock, uint32_t maxMIIMClock )
    { 
    	uint32_t mdc_div; 
        GMAC_MIIM_CLK clock_dividor ; 
        mdc_div = hostClock/maxMIIMClock; 
   17df0:	6823      	ldr	r3, [r4, #0]
   17df2:	6862      	ldr	r2, [r4, #4]
   17df4:	fbb3 f3f2 	udiv	r3, r3, r2
        if (mdc_div <= 8 ) 
   17df8:	2b08      	cmp	r3, #8
   17dfa:	d90c      	bls.n	17e16 <DRV_MIIM_Setup+0x3a>
        { 
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_8; 
        } 
        else if (mdc_div <= 16 ) 
   17dfc:	2b10      	cmp	r3, #16
   17dfe:	d92a      	bls.n	17e56 <DRV_MIIM_Setup+0x7a>
        { 
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_16; 
        } 
        else if (mdc_div <= 32 ) 
   17e00:	2b20      	cmp	r3, #32
   17e02:	d92a      	bls.n	17e5a <DRV_MIIM_Setup+0x7e>
        { 
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_32; 
        } 
        else if (mdc_div <= 48 ) 
   17e04:	2b30      	cmp	r3, #48	; 0x30
   17e06:	d92a      	bls.n	17e5e <DRV_MIIM_Setup+0x82>
        { 
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_48; 
        } 
        else if (mdc_div <= 64 ) 
   17e08:	2b40      	cmp	r3, #64	; 0x40
   17e0a:	d92a      	bls.n	17e62 <DRV_MIIM_Setup+0x86>
        { 
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_96; 
        } 
        else 
        { 
            clock_dividor = 0; 
   17e0c:	2b61      	cmp	r3, #97	; 0x61
   17e0e:	bf34      	ite	cc
   17e10:	2405      	movcc	r4, #5
   17e12:	2400      	movcs	r4, #0
   17e14:	e000      	b.n	17e18 <DRV_MIIM_Setup+0x3c>
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_8; 
   17e16:	2400      	movs	r4, #0
        } 
        GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_TXEN_Msk; 
   17e18:	4b16      	ldr	r3, [pc, #88]	; (17e74 <DRV_MIIM_Setup+0x98>)
   17e1a:	6819      	ldr	r1, [r3, #0]
   17e1c:	f021 0108 	bic.w	r1, r1, #8
   17e20:	6019      	str	r1, [r3, #0]
        GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_RXEN_Msk;	
   17e22:	6819      	ldr	r1, [r3, #0]
   17e24:	f021 0104 	bic.w	r1, r1, #4
   17e28:	6019      	str	r1, [r3, #0]
        GMAC_REGS->GMAC_NCFGR = 
                   (GMAC_REGS->GMAC_NCFGR & 
   17e2a:	685a      	ldr	r2, [r3, #4]
   17e2c:	f422 12e0 	bic.w	r2, r2, #1835008	; 0x1c0000
                        (~GMAC_NCFGR_CLK_Msk)) | (clock_dividor << GMAC_NCFGR_CLK_Pos); 
   17e30:	ea42 4284 	orr.w	r2, r2, r4, lsl #18
        GMAC_REGS->GMAC_NCFGR = 
   17e34:	605a      	str	r2, [r3, #4]
        GMAC_REGS->GMAC_NCR |= GMAC_NCR_TXEN_Msk; 
   17e36:	681a      	ldr	r2, [r3, #0]
   17e38:	f042 0208 	orr.w	r2, r2, #8
   17e3c:	601a      	str	r2, [r3, #0]
        GMAC_REGS->GMAC_NCR |= GMAC_NCR_RXEN_Msk;	
   17e3e:	681a      	ldr	r2, [r3, #0]
   17e40:	f042 0204 	orr.w	r2, r2, #4
   17e44:	601a      	str	r2, [r3, #0]
    pMiimObj->objFlags |= DRV_MIIM_OBJ_FLAG_SETUP_DONE;
   17e46:	8883      	ldrh	r3, [r0, #4]
   17e48:	f043 0302 	orr.w	r3, r3, #2
   17e4c:	8083      	strh	r3, [r0, #4]
    OSAL_SEM_Post(&pMiimObj->objSem);
   17e4e:	f009 fbc1 	bl	215d4 <OSAL_SEM_Post>
    return res;
   17e52:	2000      	movs	r0, #0
}
   17e54:	bd10      	pop	{r4, pc}
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_16; 
   17e56:	2401      	movs	r4, #1
   17e58:	e7de      	b.n	17e18 <DRV_MIIM_Setup+0x3c>
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_32; 
   17e5a:	2402      	movs	r4, #2
   17e5c:	e7dc      	b.n	17e18 <DRV_MIIM_Setup+0x3c>
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_48; 
   17e5e:	2403      	movs	r4, #3
   17e60:	e7da      	b.n	17e18 <DRV_MIIM_Setup+0x3c>
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_64; 
   17e62:	2404      	movs	r4, #4
   17e64:	e7d8      	b.n	17e18 <DRV_MIIM_Setup+0x3c>
        return DRV_MIIM_RES_PARAMETER_ERR;
   17e66:	f06f 0006 	mvn.w	r0, #6
}
   17e6a:	4770      	bx	lr
        return DRV_MIIM_RES_HANDLE_ERR;
   17e6c:	f04f 30ff 	mov.w	r0, #4294967295
   17e70:	e7f0      	b.n	17e54 <DRV_MIIM_Setup+0x78>
   17e72:	bf00      	nop
   17e74:	42000800 	.word	0x42000800

Disassembly of section .text._Command_MACAddressSet%368:

00017e78 <_Command_MACAddressSet>:
{
   17e78:	b5f0      	push	{r4, r5, r6, r7, lr}
   17e7a:	b083      	sub	sp, #12
   17e7c:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   17e7e:	6845      	ldr	r5, [r0, #4]
    if (argc != 3) {
   17e80:	2903      	cmp	r1, #3
   17e82:	d00f      	beq.n	17ea4 <_Command_MACAddressSet+0x2c>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: setmac <interface> <x:x:x:x:x:x> \r\n");
   17e84:	4e1e      	ldr	r6, [pc, #120]	; (17f00 <_Command_MACAddressSet+0x88>)
   17e86:	6803      	ldr	r3, [r0, #0]
   17e88:	681b      	ldr	r3, [r3, #0]
   17e8a:	f606 31f4 	addw	r1, r6, #3060	; 0xbf4
   17e8e:	4628      	mov	r0, r5
   17e90:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: setmac PIC32INT aa:bb:cc:dd:ee:ff \r\n");
   17e92:	6823      	ldr	r3, [r4, #0]
   17e94:	681b      	ldr	r3, [r3, #0]
   17e96:	f506 6142 	add.w	r1, r6, #3104	; 0xc20
   17e9a:	4628      	mov	r0, r5
   17e9c:	4798      	blx	r3
        return false;
   17e9e:	2000      	movs	r0, #0
}
   17ea0:	b003      	add	sp, #12
   17ea2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   17ea4:	4616      	mov	r6, r2
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
   17ea6:	6850      	ldr	r0, [r2, #4]
   17ea8:	f005 fe84 	bl	1dbb4 <TCPIP_STACK_NetHandleGet>
    if (netH == 0) {
   17eac:	4607      	mov	r7, r0
   17eae:	b188      	cbz	r0, 17ed4 <_Command_MACAddressSet+0x5c>
    (*pCmdIO->pCmdApi->print)(cmdIoParam, "argv[2]: %s\r\n", argv[2]);
   17eb0:	6823      	ldr	r3, [r4, #0]
   17eb2:	685b      	ldr	r3, [r3, #4]
   17eb4:	68b2      	ldr	r2, [r6, #8]
   17eb6:	4913      	ldr	r1, [pc, #76]	; (17f04 <_Command_MACAddressSet+0x8c>)
   17eb8:	4628      	mov	r0, r5
   17eba:	4798      	blx	r3
    if (!TCPIP_Helper_StringToMACAddress(argv[2], macAddr.v)) {
   17ebc:	4669      	mov	r1, sp
   17ebe:	68b0      	ldr	r0, [r6, #8]
   17ec0:	f7fe f9ee 	bl	162a0 <TCPIP_Helper_StringToMACAddress>
   17ec4:	b968      	cbnz	r0, 17ee2 <_Command_MACAddressSet+0x6a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Invalid MAC address string \r\n");
   17ec6:	6823      	ldr	r3, [r4, #0]
   17ec8:	681b      	ldr	r3, [r3, #0]
   17eca:	490f      	ldr	r1, [pc, #60]	; (17f08 <_Command_MACAddressSet+0x90>)
   17ecc:	4628      	mov	r0, r5
   17ece:	4798      	blx	r3
        return false;
   17ed0:	2000      	movs	r0, #0
   17ed2:	e7e5      	b.n	17ea0 <_Command_MACAddressSet+0x28>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   17ed4:	6823      	ldr	r3, [r4, #0]
   17ed6:	681b      	ldr	r3, [r3, #0]
   17ed8:	490c      	ldr	r1, [pc, #48]	; (17f0c <_Command_MACAddressSet+0x94>)
   17eda:	4628      	mov	r0, r5
   17edc:	4798      	blx	r3
        return false;
   17ede:	2000      	movs	r0, #0
   17ee0:	e7de      	b.n	17ea0 <_Command_MACAddressSet+0x28>
    if(!TCPIP_STACK_NetAddressMacSet(netH, &macAddr)) {
   17ee2:	4669      	mov	r1, sp
   17ee4:	4638      	mov	r0, r7
   17ee6:	f008 fc7f 	bl	207e8 <TCPIP_STACK_NetAddressMacSet>
   17eea:	b108      	cbz	r0, 17ef0 <_Command_MACAddressSet+0x78>
    return true;
   17eec:	2001      	movs	r0, #1
   17eee:	e7d7      	b.n	17ea0 <_Command_MACAddressSet+0x28>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Set MAC address failed\r\n");
   17ef0:	6823      	ldr	r3, [r4, #0]
   17ef2:	681b      	ldr	r3, [r3, #0]
   17ef4:	4906      	ldr	r1, [pc, #24]	; (17f10 <_Command_MACAddressSet+0x98>)
   17ef6:	4628      	mov	r0, r5
   17ef8:	4798      	blx	r3
        return false;
   17efa:	2000      	movs	r0, #0
   17efc:	e7d0      	b.n	17ea0 <_Command_MACAddressSet+0x28>
   17efe:	bf00      	nop
   17f00:	0000028c 	.word	0x0000028c
   17f04:	00000ed8 	.word	0x00000ed8
   17f08:	00000ee8 	.word	0x00000ee8
   17f0c:	00000da8 	.word	0x00000da8
   17f10:	00000f08 	.word	0x00000f08

Disassembly of section .text._free_r%369:

00017f14 <_free_r>:
   17f14:	b538      	push	{r3, r4, r5, lr}
   17f16:	4605      	mov	r5, r0
   17f18:	2900      	cmp	r1, #0
   17f1a:	d045      	beq.n	17fa8 <_free_r+0x94>
   17f1c:	f851 3c04 	ldr.w	r3, [r1, #-4]
   17f20:	1f0c      	subs	r4, r1, #4
   17f22:	2b00      	cmp	r3, #0
   17f24:	bfb8      	it	lt
   17f26:	18e4      	addlt	r4, r4, r3
   17f28:	f004 faef 	bl	1c50a <__malloc_lock>
   17f2c:	4a1f      	ldr	r2, [pc, #124]	; (17fac <_free_r+0x98>)
   17f2e:	6813      	ldr	r3, [r2, #0]
   17f30:	4610      	mov	r0, r2
   17f32:	b933      	cbnz	r3, 17f42 <_free_r+0x2e>
   17f34:	6063      	str	r3, [r4, #4]
   17f36:	6014      	str	r4, [r2, #0]
   17f38:	4628      	mov	r0, r5
   17f3a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   17f3e:	f006 b908 	b.w	1e152 <__malloc_unlock>
   17f42:	42a3      	cmp	r3, r4
   17f44:	d90c      	bls.n	17f60 <_free_r+0x4c>
   17f46:	6821      	ldr	r1, [r4, #0]
   17f48:	1862      	adds	r2, r4, r1
   17f4a:	4293      	cmp	r3, r2
   17f4c:	bf04      	itt	eq
   17f4e:	681a      	ldreq	r2, [r3, #0]
   17f50:	685b      	ldreq	r3, [r3, #4]
   17f52:	6063      	str	r3, [r4, #4]
   17f54:	bf04      	itt	eq
   17f56:	1852      	addeq	r2, r2, r1
   17f58:	6022      	streq	r2, [r4, #0]
   17f5a:	6004      	str	r4, [r0, #0]
   17f5c:	e7ec      	b.n	17f38 <_free_r+0x24>
   17f5e:	4613      	mov	r3, r2
   17f60:	685a      	ldr	r2, [r3, #4]
   17f62:	b10a      	cbz	r2, 17f68 <_free_r+0x54>
   17f64:	42a2      	cmp	r2, r4
   17f66:	d9fa      	bls.n	17f5e <_free_r+0x4a>
   17f68:	6819      	ldr	r1, [r3, #0]
   17f6a:	1858      	adds	r0, r3, r1
   17f6c:	42a0      	cmp	r0, r4
   17f6e:	d10b      	bne.n	17f88 <_free_r+0x74>
   17f70:	6820      	ldr	r0, [r4, #0]
   17f72:	4401      	add	r1, r0
   17f74:	1858      	adds	r0, r3, r1
   17f76:	4282      	cmp	r2, r0
   17f78:	6019      	str	r1, [r3, #0]
   17f7a:	d1dd      	bne.n	17f38 <_free_r+0x24>
   17f7c:	6810      	ldr	r0, [r2, #0]
   17f7e:	6852      	ldr	r2, [r2, #4]
   17f80:	605a      	str	r2, [r3, #4]
   17f82:	4401      	add	r1, r0
   17f84:	6019      	str	r1, [r3, #0]
   17f86:	e7d7      	b.n	17f38 <_free_r+0x24>
   17f88:	d902      	bls.n	17f90 <_free_r+0x7c>
   17f8a:	230c      	movs	r3, #12
   17f8c:	602b      	str	r3, [r5, #0]
   17f8e:	e7d3      	b.n	17f38 <_free_r+0x24>
   17f90:	6820      	ldr	r0, [r4, #0]
   17f92:	1821      	adds	r1, r4, r0
   17f94:	428a      	cmp	r2, r1
   17f96:	bf04      	itt	eq
   17f98:	6811      	ldreq	r1, [r2, #0]
   17f9a:	6852      	ldreq	r2, [r2, #4]
   17f9c:	6062      	str	r2, [r4, #4]
   17f9e:	bf04      	itt	eq
   17fa0:	1809      	addeq	r1, r1, r0
   17fa2:	6021      	streq	r1, [r4, #0]
   17fa4:	605c      	str	r4, [r3, #4]
   17fa6:	e7c7      	b.n	17f38 <_free_r+0x24>
   17fa8:	bd38      	pop	{r3, r4, r5, pc}
   17faa:	bf00      	nop
   17fac:	2000e4e8 	.word	0x2000e4e8

Disassembly of section .text.__pow5mult%370:

00017fb0 <__pow5mult>:
   17fb0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   17fb4:	4615      	mov	r5, r2
   17fb6:	f012 0203 	ands.w	r2, r2, #3
   17fba:	4606      	mov	r6, r0
   17fbc:	460f      	mov	r7, r1
   17fbe:	d007      	beq.n	17fd0 <__pow5mult+0x20>
   17fc0:	3a01      	subs	r2, #1
   17fc2:	4c21      	ldr	r4, [pc, #132]	; (18048 <__pow5mult+0x98>)
   17fc4:	2300      	movs	r3, #0
   17fc6:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
   17fca:	f001 fbe8 	bl	1979e <__multadd>
   17fce:	4607      	mov	r7, r0
   17fd0:	10ad      	asrs	r5, r5, #2
   17fd2:	d035      	beq.n	18040 <__pow5mult+0x90>
   17fd4:	6a74      	ldr	r4, [r6, #36]	; 0x24
   17fd6:	b93c      	cbnz	r4, 17fe8 <__pow5mult+0x38>
   17fd8:	2010      	movs	r0, #16
   17fda:	f009 fe47 	bl	21c6c <malloc>
   17fde:	e9c0 4401 	strd	r4, r4, [r0, #4]
   17fe2:	6270      	str	r0, [r6, #36]	; 0x24
   17fe4:	6004      	str	r4, [r0, #0]
   17fe6:	60c4      	str	r4, [r0, #12]
   17fe8:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
   17fec:	f8d8 4008 	ldr.w	r4, [r8, #8]
   17ff0:	b94c      	cbnz	r4, 18006 <__pow5mult+0x56>
   17ff2:	f240 2171 	movw	r1, #625	; 0x271
   17ff6:	4630      	mov	r0, r6
   17ff8:	f009 fd7e 	bl	21af8 <__i2b>
   17ffc:	2300      	movs	r3, #0
   17ffe:	f8c8 0008 	str.w	r0, [r8, #8]
   18002:	4604      	mov	r4, r0
   18004:	6003      	str	r3, [r0, #0]
   18006:	f04f 0800 	mov.w	r8, #0
   1800a:	07eb      	lsls	r3, r5, #31
   1800c:	d50a      	bpl.n	18024 <__pow5mult+0x74>
   1800e:	4639      	mov	r1, r7
   18010:	4622      	mov	r2, r4
   18012:	4630      	mov	r0, r6
   18014:	f7fa fc04 	bl	12820 <__multiply>
   18018:	4639      	mov	r1, r7
   1801a:	4681      	mov	r9, r0
   1801c:	4630      	mov	r0, r6
   1801e:	f007 fbe4 	bl	1f7ea <_Bfree>
   18022:	464f      	mov	r7, r9
   18024:	106d      	asrs	r5, r5, #1
   18026:	d00b      	beq.n	18040 <__pow5mult+0x90>
   18028:	6820      	ldr	r0, [r4, #0]
   1802a:	b938      	cbnz	r0, 1803c <__pow5mult+0x8c>
   1802c:	4622      	mov	r2, r4
   1802e:	4621      	mov	r1, r4
   18030:	4630      	mov	r0, r6
   18032:	f7fa fbf5 	bl	12820 <__multiply>
   18036:	6020      	str	r0, [r4, #0]
   18038:	f8c0 8000 	str.w	r8, [r0]
   1803c:	4604      	mov	r4, r0
   1803e:	e7e4      	b.n	1800a <__pow5mult+0x5a>
   18040:	4638      	mov	r0, r7
   18042:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   18046:	bf00      	nop
   18048:	000220bc 	.word	0x000220bc

Disassembly of section .text.Lan867x_Write_Bit_Register%371:

0001804c <Lan867x_Write_Bit_Register>:
{
   1804c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1804e:	b083      	sub	sp, #12
   18050:	4604      	mov	r4, r0
   18052:	460d      	mov	r5, r1
   18054:	4616      	mov	r6, r2
   18056:	461f      	mov	r7, r3
    uint16_t regValue = 0;
   18058:	2300      	movs	r3, #0
   1805a:	f8ad 3006 	strh.w	r3, [sp, #6]
    if (R2F(clientObj->vendorData, VENDOR_INTERNAL_STATE) == IDLE_PHASE) {
   1805e:	6843      	ldr	r3, [r0, #4]
   18060:	0e5a      	lsrs	r2, r3, #25
   18062:	d00f      	beq.n	18084 <Lan867x_Write_Bit_Register+0x38>
    if (R2F(clientObj->vendorData, VENDOR_IS_BIT_OP) == true) {
   18064:	6863      	ldr	r3, [r4, #4]
   18066:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
   1806a:	d02b      	beq.n	180c4 <Lan867x_Write_Bit_Register+0x78>
        res = Lan867x_Miim_Task(clientObj, DRV_MIIM_OP_READ, regAddr, &regValue);
   1806c:	f10d 0306 	add.w	r3, sp, #6
   18070:	462a      	mov	r2, r5
   18072:	2101      	movs	r1, #1
   18074:	4620      	mov	r0, r4
   18076:	f7f6 fe59 	bl	ed2c <Lan867x_Miim_Task>
        if (res == DRV_MIIM_RES_OK) {
   1807a:	4603      	mov	r3, r0
   1807c:	b178      	cbz	r0, 1809e <Lan867x_Write_Bit_Register+0x52>
}
   1807e:	4618      	mov	r0, r3
   18080:	b003      	add	sp, #12
   18082:	bdf0      	pop	{r4, r5, r6, r7, pc}
            F2R(internalState, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   18084:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   18088:	291f      	cmp	r1, #31
   1808a:	bf94      	ite	ls
   1808c:	f04f 7200 	movls.w	r2, #33554432	; 0x2000000
   18090:	f04f 6200 	movhi.w	r2, #134217728	; 0x8000000
   18094:	4313      	orrs	r3, r2
        clientObj->vendorData = F2R(true, VENDOR_IS_BIT_OP, clientObj->vendorData);
   18096:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   1809a:	6043      	str	r3, [r0, #4]
   1809c:	e7e2      	b.n	18064 <Lan867x_Write_Bit_Register+0x18>
            clientObj->vendorData = F2R(((regValue & (uint16_t)~mask) | (wData & mask)),
   1809e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   180a2:	405f      	eors	r7, r3
   180a4:	403e      	ands	r6, r7
   180a6:	405e      	eors	r6, r3
   180a8:	6863      	ldr	r3, [r4, #4]
   180aa:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
                F2R(internalState, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   180ae:	431e      	orrs	r6, r3
   180b0:	2d1f      	cmp	r5, #31
   180b2:	bf94      	ite	ls
   180b4:	f04f 6580 	movls.w	r5, #67108864	; 0x4000000
   180b8:	f04f 6500 	movhi.w	r5, #134217728	; 0x8000000
   180bc:	4335      	orrs	r5, r6
            clientObj->vendorData =
   180be:	6065      	str	r5, [r4, #4]
            res = DRV_MIIM_RES_PENDING;
   180c0:	2301      	movs	r3, #1
   180c2:	e7dc      	b.n	1807e <Lan867x_Write_Bit_Register+0x32>
        regValue = R2F(clientObj->vendorData, VENDOR_DATA);
   180c4:	f8ad 3006 	strh.w	r3, [sp, #6]
        res = Lan867x_Miim_Task(clientObj, DRV_MIIM_OP_WRITE, regAddr, &regValue);
   180c8:	f10d 0306 	add.w	r3, sp, #6
   180cc:	462a      	mov	r2, r5
   180ce:	2102      	movs	r1, #2
   180d0:	4620      	mov	r0, r4
   180d2:	f7f6 fe2b 	bl	ed2c <Lan867x_Miim_Task>
        if (res == DRV_MIIM_RES_OK) {
   180d6:	4603      	mov	r3, r0
   180d8:	2800      	cmp	r0, #0
   180da:	d1d0      	bne.n	1807e <Lan867x_Write_Bit_Register+0x32>
                F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   180dc:	6862      	ldr	r2, [r4, #4]
   180de:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
            clientObj->vendorData =
   180e2:	6062      	str	r2, [r4, #4]
            res = DRV_MIIM_RES_OK;
   180e4:	e7cb      	b.n	1807e <Lan867x_Write_Bit_Register+0x32>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseDetect%372:

000180e8 <_DRV_ETHPHY_SetupPhaseDetect>:
{
   180e8:	b538      	push	{r3, r4, r5, lr}
   180ea:	4604      	mov	r4, r0
    switch (hClientObj->operSubPhase)
   180ec:	8c03      	ldrh	r3, [r0, #32]
   180ee:	b133      	cbz	r3, 180fe <_DRV_ETHPHY_SetupPhaseDetect+0x16>
   180f0:	2b01      	cmp	r3, #1
   180f2:	d023      	beq.n	1813c <_DRV_ETHPHY_SetupPhaseDetect+0x54>
            _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   180f4:	f06f 0108 	mvn.w	r1, #8
   180f8:	f007 fe18 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
}
   180fc:	e01d      	b.n	1813a <_DRV_ETHPHY_SetupPhaseDetect+0x52>
            if((detectF = hDriver->pPhyObj->phyDetect) == 0)
   180fe:	68c3      	ldr	r3, [r0, #12]
   18100:	695b      	ldr	r3, [r3, #20]
   18102:	691b      	ldr	r3, [r3, #16]
                detectF = _DRV_ETHPHY_DefaultDetect;
   18104:	4a1b      	ldr	r2, [pc, #108]	; (18174 <_DRV_ETHPHY_SetupPhaseDetect+0x8c>)
   18106:	2b00      	cmp	r3, #0
   18108:	bf08      	it	eq
   1810a:	4613      	moveq	r3, r2
            hClientObj->vendorDetect = detectF;
   1810c:	6443      	str	r3, [r0, #68]	; 0x44
            hClientObj->vendorData = 0;
   1810e:	2300      	movs	r3, #0
   18110:	6403      	str	r3, [r0, #64]	; 0x40
            hClientObj->operTStamp = SYS_TMR_TickCountGet() + ((DRV_ETHPHY_RESET_CLR_TMO * SYS_TMR_TickCounterFrequencyGet()) + 999) / 1000;
   18112:	f007 ffeb 	bl	200ec <SYS_TMR_TickCountGet>
   18116:	4605      	mov	r5, r0
   18118:	f008 f810 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
   1811c:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   18120:	fb03 f000 	mul.w	r0, r3, r0
   18124:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
   18128:	4b13      	ldr	r3, [pc, #76]	; (18178 <_DRV_ETHPHY_SetupPhaseDetect+0x90>)
   1812a:	fba3 3000 	umull	r3, r0, r3, r0
   1812e:	eb05 1090 	add.w	r0, r5, r0, lsr #6
   18132:	62a0      	str	r0, [r4, #40]	; 0x28
    hClientObj->operPhase = operPhase;
   18134:	2301      	movs	r3, #1
   18136:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   18138:	8423      	strh	r3, [r4, #32]
}
   1813a:	bd38      	pop	{r3, r4, r5, pc}
            res =  hClientObj->vendorDetect(gDrvEthBaseObj, (DRV_HANDLE)hClientObj);
   1813c:	6c43      	ldr	r3, [r0, #68]	; 0x44
   1813e:	4601      	mov	r1, r0
   18140:	480e      	ldr	r0, [pc, #56]	; (1817c <_DRV_ETHPHY_SetupPhaseDetect+0x94>)
   18142:	4798      	blx	r3
            if(res == DRV_ETHPHY_RES_OK)
   18144:	4601      	mov	r1, r0
   18146:	b160      	cbz	r0, 18162 <_DRV_ETHPHY_SetupPhaseDetect+0x7a>
            else if(res < 0)
   18148:	2800      	cmp	r0, #0
   1814a:	db0f      	blt.n	1816c <_DRV_ETHPHY_SetupPhaseDetect+0x84>
                if(SYS_TMR_TickCountGet() >= hClientObj->operTStamp)
   1814c:	f007 ffce 	bl	200ec <SYS_TMR_TickCountGet>
   18150:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   18152:	4298      	cmp	r0, r3
   18154:	d3f1      	bcc.n	1813a <_DRV_ETHPHY_SetupPhaseDetect+0x52>
                    _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_DTCT_TMO);
   18156:	f06f 0101 	mvn.w	r1, #1
   1815a:	4620      	mov	r0, r4
   1815c:	f007 fde6 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
   18160:	e7eb      	b.n	1813a <_DRV_ETHPHY_SetupPhaseDetect+0x52>
    hClientObj->operPhase = operPhase;
   18162:	2302      	movs	r3, #2
   18164:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   18166:	2300      	movs	r3, #0
   18168:	8423      	strh	r3, [r4, #32]
   1816a:	e7e6      	b.n	1813a <_DRV_ETHPHY_SetupPhaseDetect+0x52>
                _DRV_PHY_SetOperDoneResult(hClientObj, res);
   1816c:	4620      	mov	r0, r4
   1816e:	f007 fddd 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
   18172:	e7e2      	b.n	1813a <_DRV_ETHPHY_SetupPhaseDetect+0x52>
   18174:	00010471 	.word	0x00010471
   18178:	10624dd3 	.word	0x10624dd3
   1817c:	0001b870 	.word	0x0001b870

Disassembly of section .text.DRV_GMAC_StatisticsGet%373:

00018180 <DRV_GMAC_StatisticsGet>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   18180:	4b20      	ldr	r3, [pc, #128]	; (18204 <DRV_GMAC_StatisticsGet+0x84>)
   18182:	4283      	cmp	r3, r0
   18184:	d136      	bne.n	181f4 <DRV_GMAC_StatisticsGet+0x74>
    if(pMACDrv == 0)
   18186:	2800      	cmp	r0, #0
   18188:	d037      	beq.n	181fa <DRV_GMAC_StatisticsGet+0x7a>
{
   1818a:	b570      	push	{r4, r5, r6, lr}
   1818c:	4615      	mov	r5, r2
   1818e:	460c      	mov	r4, r1
	if(pRxStatistics)
   18190:	b1c9      	cbz	r1, 181c6 <DRV_GMAC_StatisticsGet+0x46>
	if(pMACDrv->sGmacData._synchF != 0)
   18192:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   18194:	b113      	cbz	r3, 1819c <DRV_GMAC_StatisticsGet+0x1c>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
   18196:	2105      	movs	r1, #5
   18198:	481b      	ldr	r0, [pc, #108]	; (18208 <DRV_GMAC_StatisticsGet+0x88>)
   1819a:	4798      	blx	r3
		DRV_PIC32CGMAC_LibRxBuffersCountGet(pMACDrv, &pMACDrv->sGmacData._rxStat.nRxPendBuffers, &pMACDrv->sGmacData._rxStat.nRxSchedBuffers);
   1819c:	4e19      	ldr	r6, [pc, #100]	; (18204 <DRV_GMAC_StatisticsGet+0x84>)
   1819e:	f106 026c 	add.w	r2, r6, #108	; 0x6c
   181a2:	f106 0168 	add.w	r1, r6, #104	; 0x68
   181a6:	4630      	mov	r0, r6
   181a8:	f003 fd2e 	bl	1bc08 <DRV_PIC32CGMAC_LibRxBuffersCountGet>
	if(pMACDrv->sGmacData._synchF != 0)
   181ac:	6b33      	ldr	r3, [r6, #48]	; 0x30
   181ae:	b11b      	cbz	r3, 181b8 <DRV_GMAC_StatisticsGet+0x38>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_LEAVE);
   181b0:	2106      	movs	r1, #6
   181b2:	f106 005c 	add.w	r0, r6, #92	; 0x5c
   181b6:	4798      	blx	r3
		*pRxStatistics = pMACDrv->sGmacData._rxStat;
   181b8:	4e14      	ldr	r6, [pc, #80]	; (1820c <DRV_GMAC_StatisticsGet+0x8c>)
   181ba:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   181bc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   181be:	e896 0003 	ldmia.w	r6, {r0, r1}
   181c2:	e884 0003 	stmia.w	r4, {r0, r1}
	if(pTxStatistics)
   181c6:	b1dd      	cbz	r5, 18200 <DRV_GMAC_StatisticsGet+0x80>
	if(pMACDrv->sGmacData._synchF != 0)
   181c8:	4b0e      	ldr	r3, [pc, #56]	; (18204 <DRV_GMAC_StatisticsGet+0x84>)
   181ca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   181cc:	b113      	cbz	r3, 181d4 <DRV_GMAC_StatisticsGet+0x54>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_LOCK);
   181ce:	2103      	movs	r1, #3
   181d0:	480f      	ldr	r0, [pc, #60]	; (18210 <DRV_GMAC_StatisticsGet+0x90>)
   181d2:	4798      	blx	r3
			pMACDrv->sGmacData._txStat.nTxPendBuffers += DRV_PIC32CGMAC_SingleListCount(&(pMACDrv->sGmacData.gmac_queue[index]._TxQueue));
   181d4:	4b0b      	ldr	r3, [pc, #44]	; (18204 <DRV_GMAC_StatisticsGet+0x84>)
   181d6:	f8d3 20ac 	ldr.w	r2, [r3, #172]	; 0xac
   181da:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	if(pMACDrv->sGmacData._synchF != 0)
   181de:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   181e0:	b113      	cbz	r3, 181e8 <DRV_GMAC_StatisticsGet+0x68>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_UNLOCK);
   181e2:	2104      	movs	r1, #4
   181e4:	480a      	ldr	r0, [pc, #40]	; (18210 <DRV_GMAC_StatisticsGet+0x90>)
   181e6:	4798      	blx	r3
		*pTxStatistics = pMACDrv->sGmacData._txStat;
   181e8:	4b0a      	ldr	r3, [pc, #40]	; (18214 <DRV_GMAC_StatisticsGet+0x94>)
   181ea:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   181ec:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
	return TCPIP_MAC_RES_OK;
   181f0:	2000      	movs	r0, #0
}
   181f2:	bd70      	pop	{r4, r5, r6, pc}
        return TCPIP_MAC_RES_OP_ERR;
   181f4:	f06f 0005 	mvn.w	r0, #5
   181f8:	4770      	bx	lr
   181fa:	f06f 0005 	mvn.w	r0, #5
}
   181fe:	4770      	bx	lr
	return TCPIP_MAC_RES_OK;
   18200:	2000      	movs	r0, #0
   18202:	e7f6      	b.n	181f2 <DRV_GMAC_StatisticsGet+0x72>
   18204:	2000d8b8 	.word	0x2000d8b8
   18208:	2000d914 	.word	0x2000d914
   1820c:	2000d91c 	.word	0x2000d91c
   18210:	2000d918 	.word	0x2000d918
   18214:	2000d934 	.word	0x2000d934

Disassembly of section .text._DHCPEnable%374:

00018218 <_DHCPEnable>:
{
   18218:	b570      	push	{r4, r5, r6, lr}
   1821a:	4606      	mov	r6, r0
   1821c:	460d      	mov	r5, r1
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   1821e:	4b20      	ldr	r3, [pc, #128]	; (182a0 <_DHCPEnable+0x88>)
   18220:	681c      	ldr	r4, [r3, #0]
   18222:	f009 fd7f 	bl	21d24 <TCPIP_STACK_NetIxGet>
   18226:	235c      	movs	r3, #92	; 0x5c
   18228:	fb03 4400 	mla	r4, r3, r0, r4
    if(TCPIP_STACK_NetworkIsLinked(pNetIf) || !_TCPIPStackNetIsPrimary(pNetIf))
   1822c:	4630      	mov	r0, r6
   1822e:	f008 fd9b 	bl	20d68 <TCPIP_STACK_NetworkIsLinked>
    pClient->smState = newState;
   18232:	f8a4 0056 	strh.w	r0, [r4, #86]	; 0x56
    pClient->flags.bDHCPEnabled = true;
   18236:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
   1823a:	f043 0301 	orr.w	r3, r3, #1
   1823e:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    pClient->dhcpOp = opType;
   18242:	f8a4 5054 	strh.w	r5, [r4, #84]	; 0x54
    pNetIf->Flags.bIsDHCPEnabled = true;
   18246:	f896 3042 	ldrb.w	r3, [r6, #66]	; 0x42
   1824a:	f043 0301 	orr.w	r3, r3, #1
   1824e:	f886 3042 	strb.w	r3, [r6, #66]	; 0x42
    if(pClient->dhcpFilterHandle == 0)
   18252:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   18254:	b123      	cbz	r3, 18260 <_DHCPEnable+0x48>
    if(opType == TCPIP_DHCP_OPER_INIT || opType == TCPIP_DHCP_OPER_INIT_REBOOT)
   18256:	3d01      	subs	r5, #1
   18258:	b2ed      	uxtb	r5, r5
   1825a:	2d01      	cmp	r5, #1
   1825c:	d911      	bls.n	18282 <_DHCPEnable+0x6a>
}
   1825e:	bd70      	pop	{r4, r5, r6, pc}
        pClient->dhcpFilterHandle = IPv4RegisterFilter(_DHCPPacketFilter, true);
   18260:	2101      	movs	r1, #1
   18262:	4810      	ldr	r0, [pc, #64]	; (182a4 <_DHCPEnable+0x8c>)
   18264:	f003 ff5c 	bl	1c120 <IPv4RegisterFilter>
   18268:	64a0      	str	r0, [r4, #72]	; 0x48
        if(pClient->dhcpFilterHandle == 0)
   1826a:	2800      	cmp	r0, #0
   1826c:	d1f3      	bne.n	18256 <_DHCPEnable+0x3e>
            SYS_ERROR(SYS_ERROR_WARNING, "DHCP: Failed to register IPv4 filter! \r\n");
   1826e:	f009 feef 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
   18272:	2801      	cmp	r0, #1
   18274:	d9ef      	bls.n	18256 <_DHCPEnable+0x3e>
   18276:	f009 fee5 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
   1827a:	490b      	ldr	r1, [pc, #44]	; (182a8 <_DHCPEnable+0x90>)
   1827c:	f002 fc0e 	bl	1aa9c <SYS_CONSOLE_Print>
   18280:	e7e9      	b.n	18256 <_DHCPEnable+0x3e>
        pClient->dhcpTmo = pClient->dhcpTmoBase;
   18282:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
   18286:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    pClient->flags.bReportFail = 1;
   1828a:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
   1828e:	f043 0320 	orr.w	r3, r3, #32
   18292:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    return dhcpSecondCount;
   18296:	4b05      	ldr	r3, [pc, #20]	; (182ac <_DHCPEnable+0x94>)
        pClient->tOpStart = _DHCPSecondCountGet();
   18298:	681b      	ldr	r3, [r3, #0]
   1829a:	6223      	str	r3, [r4, #32]
}
   1829c:	e7df      	b.n	1825e <_DHCPEnable+0x46>
   1829e:	bf00      	nop
   182a0:	2000e408 	.word	0x2000e408
   182a4:	00018ce5 	.word	0x00018ce5
   182a8:	0001eb20 	.word	0x0001eb20
   182ac:	2000e418 	.word	0x2000e418

Disassembly of section .text.TCPIP_DHCP_Request%375:

000182b0 <TCPIP_DHCP_Request>:
   182b0:	b1a8      	cbz	r0, 182de <TCPIP_DHCP_Request+0x2e>
{
   182b2:	b570      	push	{r4, r5, r6, lr}
   182b4:	b082      	sub	sp, #8
   182b6:	4604      	mov	r4, r0
   182b8:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   182bc:	f012 0f40 	tst.w	r2, #64	; 0x40
   182c0:	d114      	bne.n	182ec <TCPIP_DHCP_Request+0x3c>
        return false;
   182c2:	2300      	movs	r3, #0
}
   182c4:	4618      	mov	r0, r3
   182c6:	b002      	add	sp, #8
   182c8:	bd70      	pop	{r4, r5, r6, pc}
                       return false;
   182ca:	2300      	movs	r3, #0
   182cc:	e7fa      	b.n	182c4 <TCPIP_DHCP_Request+0x14>
                else if(!TCPIP_STACK_AddressServiceCanStart(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_DHCPC))
   182ce:	2101      	movs	r1, #1
   182d0:	4620      	mov	r0, r4
   182d2:	f009 fa8c 	bl	217ee <TCPIP_STACK_AddressServiceCanStart>
   182d6:	4603      	mov	r3, r0
   182d8:	2800      	cmp	r0, #0
   182da:	d0f3      	beq.n	182c4 <TCPIP_DHCP_Request+0x14>
   182dc:	e02b      	b.n	18336 <TCPIP_DHCP_Request+0x86>
        return false;
   182de:	2300      	movs	r3, #0
}
   182e0:	4618      	mov	r0, r3
   182e2:	4770      	bx	lr
    return false;
   182e4:	2300      	movs	r3, #0
   182e6:	e7ed      	b.n	182c4 <TCPIP_DHCP_Request+0x14>
        return false;
   182e8:	2300      	movs	r3, #0
    return _DHCPStartOperation(_TCPIPStackHandleToNetUp(hNet), TCPIP_DHCP_OP_REQ_REQUEST, reqAddress.Val);
   182ea:	e7eb      	b.n	182c4 <TCPIP_DHCP_Request+0x14>
    if(DHCPClients == 0 || pNetIf == 0)
   182ec:	4a15      	ldr	r2, [pc, #84]	; (18344 <TCPIP_DHCP_Request+0x94>)
   182ee:	6816      	ldr	r6, [r2, #0]
   182f0:	2e00      	cmp	r6, #0
   182f2:	d0f9      	beq.n	182e8 <TCPIP_DHCP_Request+0x38>
   182f4:	460d      	mov	r5, r1
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   182f6:	4620      	mov	r0, r4
   182f8:	f009 fd14 	bl	21d24 <TCPIP_STACK_NetIxGet>
            if(reqAddress != 0)
   182fc:	2d00      	cmp	r5, #0
   182fe:	d0f1      	beq.n	182e4 <TCPIP_DHCP_Request+0x34>
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   18300:	235c      	movs	r3, #92	; 0x5c
   18302:	fb03 6600 	mla	r6, r3, r0, r6
                if(pClient->flags.bDHCPEnabled != 0)
   18306:	f896 3058 	ldrb.w	r3, [r6, #88]	; 0x58
   1830a:	f013 0f01 	tst.w	r3, #1
   1830e:	d0de      	beq.n	182ce <TCPIP_DHCP_Request+0x1e>
                    if(pClient->smState == TCPIP_DHCP_GET_REQUEST_ACK || 
   18310:	f8b6 3056 	ldrh.w	r3, [r6, #86]	; 0x56
   18314:	2b0c      	cmp	r3, #12
   18316:	d806      	bhi.n	18326 <TCPIP_DHCP_Request+0x76>
   18318:	f44f 52a1 	mov.w	r2, #5152	; 0x1420
   1831c:	fa22 f303 	lsr.w	r3, r2, r3
   18320:	f013 0f01 	tst.w	r3, #1
   18324:	d1d1      	bne.n	182ca <TCPIP_DHCP_Request+0x1a>
                    IPV4_ADDR zeroAdd = {0};
   18326:	2300      	movs	r3, #0
   18328:	9301      	str	r3, [sp, #4]
                    _TCPIPStackSetConfigAddress(pNetIf, &zeroAdd, &zeroAdd, true);
   1832a:	2301      	movs	r3, #1
   1832c:	aa01      	add	r2, sp, #4
   1832e:	4611      	mov	r1, r2
   18330:	4620      	mov	r0, r4
   18332:	f006 fb58 	bl	1e9e6 <_TCPIPStackSetConfigAddress>
                pClient->dhcpIPAddress.Val = reqAddress;
   18336:	62f5      	str	r5, [r6, #44]	; 0x2c
        _DHCPEnable(pNetIf, opType);
   18338:	2102      	movs	r1, #2
   1833a:	4620      	mov	r0, r4
   1833c:	f7ff ff6c 	bl	18218 <_DHCPEnable>
        return true;
   18340:	2301      	movs	r3, #1
   18342:	e7bf      	b.n	182c4 <TCPIP_DHCP_Request+0x14>
   18344:	2000e408 	.word	0x2000e408

Disassembly of section .text.TCPIP_DHCP_InfoGet%376:

00018348 <TCPIP_DHCP_InfoGet>:
{
   18348:	b570      	push	{r4, r5, r6, lr}
   1834a:	4604      	mov	r4, r0
    if(pDhcpInfo)
   1834c:	460e      	mov	r6, r1
   1834e:	b121      	cbz	r1, 1835a <TCPIP_DHCP_InfoGet+0x12>
        memset(pDhcpInfo, 0, sizeof(*pDhcpInfo));
   18350:	2234      	movs	r2, #52	; 0x34
   18352:	2100      	movs	r1, #0
   18354:	4630      	mov	r0, r6
   18356:	f009 fc99 	bl	21c8c <memset>
   1835a:	b30c      	cbz	r4, 183a0 <TCPIP_DHCP_InfoGet+0x58>
   1835c:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   18360:	f013 0f40 	tst.w	r3, #64	; 0x40
   18364:	d122      	bne.n	183ac <TCPIP_DHCP_InfoGet+0x64>
    return false;
   18366:	2000      	movs	r0, #0
}
   18368:	bd70      	pop	{r4, r5, r6, pc}
            if(pDhcpInfo)
   1836a:	b1ee      	cbz	r6, 183a8 <TCPIP_DHCP_InfoGet+0x60>
                pDhcpInfo->status = pClient->smState;
   1836c:	7033      	strb	r3, [r6, #0]
    return dhcpSecondCount;
   1836e:	4b1a      	ldr	r3, [pc, #104]	; (183d8 <TCPIP_DHCP_InfoGet+0x90>)
                pDhcpInfo->dhcpTime = _DHCPSecondCountGet();
   18370:	681b      	ldr	r3, [r3, #0]
   18372:	6073      	str	r3, [r6, #4]
                pDhcpInfo->leaseStartTime = pClient->tRequest;
   18374:	6883      	ldr	r3, [r0, #8]
   18376:	60b3      	str	r3, [r6, #8]
                pDhcpInfo->leaseDuration = pClient->tExpSeconds;
   18378:	6983      	ldr	r3, [r0, #24]
   1837a:	60f3      	str	r3, [r6, #12]
                pDhcpInfo->renewTime = pClient->tRequest + pClient->t1Seconds;
   1837c:	6883      	ldr	r3, [r0, #8]
   1837e:	6902      	ldr	r2, [r0, #16]
   18380:	4413      	add	r3, r2
   18382:	6133      	str	r3, [r6, #16]
                pDhcpInfo->rebindTime = pClient->tRequest + pClient->t2Seconds;
   18384:	6883      	ldr	r3, [r0, #8]
   18386:	6942      	ldr	r2, [r0, #20]
   18388:	4413      	add	r3, r2
   1838a:	6173      	str	r3, [r6, #20]
                pDhcpInfo->dhcpAddress.Val = pClient->dhcpIPAddress.Val;
   1838c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   1838e:	61b3      	str	r3, [r6, #24]
                pDhcpInfo->subnetMask.Val = pClient->dhcpMask.Val;
   18390:	6b43      	ldr	r3, [r0, #52]	; 0x34
   18392:	61f3      	str	r3, [r6, #28]
                pDhcpInfo->serverAddress.Val = pClient->serverAddress.Val;
   18394:	6a83      	ldr	r3, [r0, #40]	; 0x28
   18396:	6233      	str	r3, [r6, #32]
                pDhcpInfo->bootFileName = 0;
   18398:	2300      	movs	r3, #0
   1839a:	6273      	str	r3, [r6, #36]	; 0x24
            return true;
   1839c:	2001      	movs	r0, #1
   1839e:	e7e3      	b.n	18368 <TCPIP_DHCP_InfoGet+0x20>
    return false;
   183a0:	2000      	movs	r0, #0
   183a2:	e7e1      	b.n	18368 <TCPIP_DHCP_InfoGet+0x20>
   183a4:	2000      	movs	r0, #0
   183a6:	e7df      	b.n	18368 <TCPIP_DHCP_InfoGet+0x20>
            return true;
   183a8:	2001      	movs	r0, #1
   183aa:	e7dd      	b.n	18368 <TCPIP_DHCP_InfoGet+0x20>
    if(DHCPClients && pNetIf)
   183ac:	4b0b      	ldr	r3, [pc, #44]	; (183dc <TCPIP_DHCP_InfoGet+0x94>)
   183ae:	681d      	ldr	r5, [r3, #0]
   183b0:	b185      	cbz	r5, 183d4 <TCPIP_DHCP_InfoGet+0x8c>
        DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   183b2:	4620      	mov	r0, r4
   183b4:	f009 fcb6 	bl	21d24 <TCPIP_STACK_NetIxGet>
   183b8:	235c      	movs	r3, #92	; 0x5c
   183ba:	fb03 5000 	mla	r0, r3, r0, r5
        if(pClient->flags.bDHCPEnabled == true && pClient->smState >= TCPIP_DHCP_BOUND)
   183be:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   183c2:	f013 0f01 	tst.w	r3, #1
   183c6:	d0ed      	beq.n	183a4 <TCPIP_DHCP_InfoGet+0x5c>
   183c8:	f8b0 3056 	ldrh.w	r3, [r0, #86]	; 0x56
   183cc:	2b07      	cmp	r3, #7
   183ce:	d8cc      	bhi.n	1836a <TCPIP_DHCP_InfoGet+0x22>
    return false;
   183d0:	2000      	movs	r0, #0
   183d2:	e7c9      	b.n	18368 <TCPIP_DHCP_InfoGet+0x20>
   183d4:	2000      	movs	r0, #0
   183d6:	e7c7      	b.n	18368 <TCPIP_DHCP_InfoGet+0x20>
   183d8:	2000e418 	.word	0x2000e418
   183dc:	2000e408 	.word	0x2000e408

Disassembly of section .text.DisplayNodeMsg%377:

000183e0 <DisplayNodeMsg>:
{
   183e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   183e4:	b083      	sub	sp, #12
   183e6:	4680      	mov	r8, r0
   183e8:	468b      	mov	fp, r1
    if((nCmdLen = strlen(pNext->cmdBuff)))
   183ea:	f101 0308 	add.w	r3, r1, #8
   183ee:	9301      	str	r3, [sp, #4]
   183f0:	4618      	mov	r0, r3
   183f2:	f009 fc5b 	bl	21cac <strlen>
   183f6:	2800      	cmp	r0, #0
   183f8:	d034      	beq.n	18464 <DisplayNodeMsg+0x84>
   183fa:	4681      	mov	r9, r0
   183fc:	4605      	mov	r5, r0
    const SYS_CMD_API* pCmdApi = pCmdIO->devNode.pCmdApi;
   183fe:	f8d8 7000 	ldr.w	r7, [r8]
    const void* cmdIoParam = pCmdIO->devNode.cmdIoParam;
   18402:	f8d8 6004 	ldr.w	r6, [r8, #4]
        oCmdLen = pCmdIO->cmdEnd - pCmdIO->cmdBuff;
   18406:	f108 0a20 	add.w	sl, r8, #32
   1840a:	f8d8 401c 	ldr.w	r4, [r8, #28]
   1840e:	eba4 040a 	sub.w	r4, r4, sl
        while(oCmdLen > nCmdLen)
   18412:	42a0      	cmp	r0, r4
   18414:	da07      	bge.n	18426 <DisplayNodeMsg+0x46>
            (*pCmdApi->msg)(cmdIoParam, "\b \b");     // clear the old command
   18416:	683b      	ldr	r3, [r7, #0]
   18418:	4914      	ldr	r1, [pc, #80]	; (1846c <DisplayNodeMsg+0x8c>)
   1841a:	4630      	mov	r0, r6
   1841c:	4798      	blx	r3
            oCmdLen--;
   1841e:	3c01      	subs	r4, #1
        while(oCmdLen > nCmdLen)
   18420:	42a5      	cmp	r5, r4
   18422:	d1f8      	bne.n	18416 <DisplayNodeMsg+0x36>
   18424:	464c      	mov	r4, r9
        while(oCmdLen--)
   18426:	1e65      	subs	r5, r4, #1
   18428:	b144      	cbz	r4, 1843c <DisplayNodeMsg+0x5c>
            (*pCmdApi->msg)(cmdIoParam, "\b");
   1842a:	4c11      	ldr	r4, [pc, #68]	; (18470 <DisplayNodeMsg+0x90>)
   1842c:	683b      	ldr	r3, [r7, #0]
   1842e:	4621      	mov	r1, r4
   18430:	4630      	mov	r0, r6
   18432:	4798      	blx	r3
        while(oCmdLen--)
   18434:	3d01      	subs	r5, #1
   18436:	f1b5 3fff 	cmp.w	r5, #4294967295
   1843a:	d1f7      	bne.n	1842c <DisplayNodeMsg+0x4c>
        strcpy(pCmdIO->cmdBuff, pNext->cmdBuff);
   1843c:	9901      	ldr	r1, [sp, #4]
   1843e:	4650      	mov	r0, sl
   18440:	f009 fc2c 	bl	21c9c <strcpy>
        (*pCmdApi->msg)(cmdIoParam, "\r\n>");
   18444:	683b      	ldr	r3, [r7, #0]
   18446:	490b      	ldr	r1, [pc, #44]	; (18474 <DisplayNodeMsg+0x94>)
   18448:	4630      	mov	r0, r6
   1844a:	4798      	blx	r3
        (*pCmdApi->msg)(cmdIoParam, pCmdIO->cmdBuff);
   1844c:	683b      	ldr	r3, [r7, #0]
   1844e:	4651      	mov	r1, sl
   18450:	4630      	mov	r0, r6
   18452:	4798      	blx	r3
        pCmdIO->cmdPnt = pCmdIO->cmdEnd = pCmdIO->cmdBuff + nCmdLen;
   18454:	eb0a 0309 	add.w	r3, sl, r9
   18458:	f8c8 301c 	str.w	r3, [r8, #28]
   1845c:	f8c8 3018 	str.w	r3, [r8, #24]
        pCmdIO->currHistN = pNext;
   18460:	f8c8 b0d4 	str.w	fp, [r8, #212]	; 0xd4
}
   18464:	b003      	add	sp, #12
   18466:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1846a:	bf00      	nop
   1846c:	0000d0e8 	.word	0x0000d0e8
   18470:	0000d0ec 	.word	0x0000d0ec
   18474:	0000d0f0 	.word	0x0000d0f0

Disassembly of section .text.prvAddCurrentTaskToDelayedList%378:

00018478 <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
   18478:	b570      	push	{r4, r5, r6, lr}
   1847a:	4604      	mov	r4, r0
   1847c:	460e      	mov	r6, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
   1847e:	4b1d      	ldr	r3, [pc, #116]	; (184f4 <prvAddCurrentTaskToDelayedList+0x7c>)
   18480:	681d      	ldr	r5, [r3, #0]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   18482:	4b1d      	ldr	r3, [pc, #116]	; (184f8 <prvAddCurrentTaskToDelayedList+0x80>)
   18484:	6818      	ldr	r0, [r3, #0]
   18486:	3004      	adds	r0, #4
   18488:	f008 f8b4 	bl	205f4 <uxListRemove>
   1848c:	b948      	cbnz	r0, 184a2 <prvAddCurrentTaskToDelayedList+0x2a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
   1848e:	4b1a      	ldr	r3, [pc, #104]	; (184f8 <prvAddCurrentTaskToDelayedList+0x80>)
   18490:	681a      	ldr	r2, [r3, #0]
   18492:	491a      	ldr	r1, [pc, #104]	; (184fc <prvAddCurrentTaskToDelayedList+0x84>)
   18494:	680b      	ldr	r3, [r1, #0]
   18496:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
   18498:	2201      	movs	r2, #1
   1849a:	4082      	lsls	r2, r0
   1849c:	ea23 0302 	bic.w	r3, r3, r2
   184a0:	600b      	str	r3, [r1, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   184a2:	f1b4 3fff 	cmp.w	r4, #4294967295
   184a6:	d00d      	beq.n	184c4 <prvAddCurrentTaskToDelayedList+0x4c>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
   184a8:	442c      	add	r4, r5

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   184aa:	4b13      	ldr	r3, [pc, #76]	; (184f8 <prvAddCurrentTaskToDelayedList+0x80>)
   184ac:	681b      	ldr	r3, [r3, #0]
   184ae:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
   184b0:	42a5      	cmp	r5, r4
   184b2:	d910      	bls.n	184d6 <prvAddCurrentTaskToDelayedList+0x5e>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   184b4:	4b12      	ldr	r3, [pc, #72]	; (18500 <prvAddCurrentTaskToDelayedList+0x88>)
   184b6:	6818      	ldr	r0, [r3, #0]
   184b8:	4b0f      	ldr	r3, [pc, #60]	; (184f8 <prvAddCurrentTaskToDelayedList+0x80>)
   184ba:	6819      	ldr	r1, [r3, #0]
   184bc:	3104      	adds	r1, #4
   184be:	f006 fc81 	bl	1edc4 <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   184c2:	bd70      	pop	{r4, r5, r6, pc}
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   184c4:	2e00      	cmp	r6, #0
   184c6:	d0ef      	beq.n	184a8 <prvAddCurrentTaskToDelayedList+0x30>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
   184c8:	4b0b      	ldr	r3, [pc, #44]	; (184f8 <prvAddCurrentTaskToDelayedList+0x80>)
   184ca:	6819      	ldr	r1, [r3, #0]
   184cc:	3104      	adds	r1, #4
   184ce:	480d      	ldr	r0, [pc, #52]	; (18504 <prvAddCurrentTaskToDelayedList+0x8c>)
   184d0:	f009 f9b9 	bl	21846 <vListInsertEnd>
   184d4:	e7f5      	b.n	184c2 <prvAddCurrentTaskToDelayedList+0x4a>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   184d6:	4b0c      	ldr	r3, [pc, #48]	; (18508 <prvAddCurrentTaskToDelayedList+0x90>)
   184d8:	6818      	ldr	r0, [r3, #0]
   184da:	4b07      	ldr	r3, [pc, #28]	; (184f8 <prvAddCurrentTaskToDelayedList+0x80>)
   184dc:	6819      	ldr	r1, [r3, #0]
   184de:	3104      	adds	r1, #4
   184e0:	f006 fc70 	bl	1edc4 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
   184e4:	4b09      	ldr	r3, [pc, #36]	; (1850c <prvAddCurrentTaskToDelayedList+0x94>)
   184e6:	681b      	ldr	r3, [r3, #0]
   184e8:	42a3      	cmp	r3, r4
					xNextTaskUnblockTime = xTimeToWake;
   184ea:	bf84      	itt	hi
   184ec:	4b07      	ldrhi	r3, [pc, #28]	; (1850c <prvAddCurrentTaskToDelayedList+0x94>)
   184ee:	601c      	strhi	r4, [r3, #0]
}
   184f0:	e7e7      	b.n	184c2 <prvAddCurrentTaskToDelayedList+0x4a>
   184f2:	bf00      	nop
   184f4:	2000e4d0 	.word	0x2000e4d0
   184f8:	2000e49c 	.word	0x2000e49c
   184fc:	2000e4b8 	.word	0x2000e4b8
   18500:	2000e4a4 	.word	0x2000e4a4
   18504:	2000e2c8 	.word	0x2000e2c8
   18508:	2000e4a0 	.word	0x2000e4a0
   1850c:	2000e4c0 	.word	0x2000e4c0

Disassembly of section .text.DRV_PIC32CGMAC_LibInitTransfer%379:

00018510 <DRV_PIC32CGMAC_LibInitTransfer>:
	uint16_t wRxDescCnt_temp = pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxDescCnt;
   18510:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
   18514:	eb00 0343 	add.w	r3, r0, r3, lsl #1
	if (wRxDescCnt_temp < 1 || wTxDescCnt_temp < 1)
   18518:	f8b3 30be 	ldrh.w	r3, [r3, #190]	; 0xbe
   1851c:	2b00      	cmp	r3, #0
   1851e:	d036      	beq.n	1858e <DRV_PIC32CGMAC_LibInitTransfer+0x7e>
	uint16_t wTxDescCnt_temp = pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt;
   18520:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
   18524:	eb00 0343 	add.w	r3, r0, r3, lsl #1
	if (wRxDescCnt_temp < 1 || wTxDescCnt_temp < 1)
   18528:	f8b3 30c8 	ldrh.w	r3, [r3, #200]	; 0xc8
   1852c:	b38b      	cbz	r3, 18592 <DRV_PIC32CGMAC_LibInitTransfer+0x82>
	uint16_t wRxBufferSize_temp = pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].rxBufferSize;
   1852e:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
   18532:	eb00 0343 	add.w	r3, r0, r3, lsl #1
   18536:	f8b3 30cc 	ldrh.w	r3, [r3, #204]	; 0xcc
	if (wRxBufferSize_temp < DRV_GMAC_MIN_RX_SIZE)
   1853a:	2b3f      	cmp	r3, #63	; 0x3f
   1853c:	d92b      	bls.n	18596 <DRV_PIC32CGMAC_LibInitTransfer+0x86>
    if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].queueRxEnable == true)
   1853e:	eb01 02c1 	add.w	r2, r1, r1, lsl #3
   18542:	eb00 0242 	add.w	r2, r0, r2, lsl #1
   18546:	f892 20cf 	ldrb.w	r2, [r2, #207]	; 0xcf
        queIntEnable = GMAC_INT_RX_BITS;
   1854a:	2a01      	cmp	r2, #1
   1854c:	f240 4206 	movw	r2, #1030	; 0x406
   18550:	bf18      	it	ne
   18552:	2200      	movne	r2, #0
    if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].queueTxEnable == true)
   18554:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
   18558:	eb00 0141 	add.w	r1, r0, r1, lsl #1
   1855c:	f891 10ce 	ldrb.w	r1, [r1, #206]	; 0xce
   18560:	2901      	cmp	r1, #1
        queIntEnable |= GMAC_INT_TX_BITS;
   18562:	bf08      	it	eq
   18564:	f442 6207 	orreq.w	r2, r2, #2160	; 0x870
	GMAC_REGS->GMAC_DCFGR = GMAC_DCFGR_DRBS((wRxBufferSize_temp >> 6)) | GMAC_DCFGR_RXBMS(3) | GMAC_DCFGR_TXPBMS(1) | GMAC_DCFGR_FBLDO(4) | GMAC_DCFGR_DDRP(1);
   18568:	029b      	lsls	r3, r3, #10
   1856a:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
   1856e:	490b      	ldr	r1, [pc, #44]	; (1859c <DRV_PIC32CGMAC_LibInitTransfer+0x8c>)
   18570:	4319      	orrs	r1, r3
   18572:	4b0b      	ldr	r3, [pc, #44]	; (185a0 <DRV_PIC32CGMAC_LibInitTransfer+0x90>)
   18574:	6119      	str	r1, [r3, #16]
	if((pMACDrv->sGmacData.gmacConfig.checksumOffloadTx) != TCPIP_MAC_CHECKSUM_NONE)
   18576:	f890 30e1 	ldrb.w	r3, [r0, #225]	; 0xe1
   1857a:	b123      	cbz	r3, 18586 <DRV_PIC32CGMAC_LibInitTransfer+0x76>
        GMAC_REGS->GMAC_DCFGR |= GMAC_DCFGR_TXCOEN_Msk;
   1857c:	4908      	ldr	r1, [pc, #32]	; (185a0 <DRV_PIC32CGMAC_LibInitTransfer+0x90>)
   1857e:	690b      	ldr	r3, [r1, #16]
   18580:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   18584:	610b      	str	r3, [r1, #16]
	GMAC_REGS->GMAC_IER = queIntEnable;
   18586:	4b06      	ldr	r3, [pc, #24]	; (185a0 <DRV_PIC32CGMAC_LibInitTransfer+0x90>)
   18588:	629a      	str	r2, [r3, #40]	; 0x28
	return DRV_PIC32CGMAC_RES_OK;
   1858a:	2000      	movs	r0, #0
   1858c:	4770      	bx	lr
        return DRV_PIC32CGMAC_RES_DESC_CNT_ERR;
   1858e:	2006      	movs	r0, #6
   18590:	4770      	bx	lr
   18592:	2006      	movs	r0, #6
   18594:	4770      	bx	lr
        return DRV_PIC32CGMAC_RES_RX_SIZE_ERR;
   18596:	f06f 0002 	mvn.w	r0, #2
}
   1859a:	4770      	bx	lr
   1859c:	01000704 	.word	0x01000704
   185a0:	42000800 	.word	0x42000800

Disassembly of section .text.TCPIP_ARP_IsResolved%380:

000185a4 <TCPIP_ARP_IsResolved>:
    if(IPAddr == 0 || IPAddr->Val == 0)
   185a4:	2900      	cmp	r1, #0
   185a6:	d03c      	beq.n	18622 <TCPIP_ARP_IsResolved+0x7e>
{
   185a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   185aa:	460c      	mov	r4, r1
    if(IPAddr == 0 || IPAddr->Val == 0)
   185ac:	6809      	ldr	r1, [r1, #0]
   185ae:	2900      	cmp	r1, #0
   185b0:	d039      	beq.n	18626 <TCPIP_ARP_IsResolved+0x82>
   185b2:	2800      	cmp	r0, #0
   185b4:	d039      	beq.n	1862a <TCPIP_ARP_IsResolved+0x86>
   185b6:	f890 1042 	ldrb.w	r1, [r0, #66]	; 0x42
   185ba:	f011 0f40 	tst.w	r1, #64	; 0x40
   185be:	d101      	bne.n	185c4 <TCPIP_ARP_IsResolved+0x20>
        return false;
   185c0:	2000      	movs	r0, #0
   185c2:	e031      	b.n	18628 <TCPIP_ARP_IsResolved+0x84>
   185c4:	4615      	mov	r5, r2
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   185c6:	4b1b      	ldr	r3, [pc, #108]	; (18634 <TCPIP_ARP_IsResolved+0x90>)
   185c8:	685e      	ldr	r6, [r3, #4]
   185ca:	f009 fbab 	bl	21d24 <TCPIP_STACK_NetIxGet>
   185ce:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   185d2:	00c0      	lsls	r0, r0, #3
   185d4:	1837      	adds	r7, r6, r0
    hE = TCPIP_OAHASH_EntryLookup(pArpDcpt->hashDcpt, &IPAddr->Val);
   185d6:	4621      	mov	r1, r4
   185d8:	5830      	ldr	r0, [r6, r0]
   185da:	f002 fbd3 	bl	1ad84 <TCPIP_OAHASH_EntryLookup>
    if(hE != 0 && (hE->flags.value & ARP_FLAG_ENTRY_VALID_MASK) != 0 )
   185de:	4604      	mov	r4, r0
   185e0:	b328      	cbz	r0, 1862e <TCPIP_ARP_IsResolved+0x8a>
   185e2:	8803      	ldrh	r3, [r0, #0]
   185e4:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   185e8:	b90b      	cbnz	r3, 185ee <TCPIP_ARP_IsResolved+0x4a>
    return false;
   185ea:	2000      	movs	r0, #0
   185ec:	e01c      	b.n	18628 <TCPIP_ARP_IsResolved+0x84>
        if(MACAddr)
   185ee:	b11d      	cbz	r5, 185f8 <TCPIP_ARP_IsResolved+0x54>
            *MACAddr = arpHE->hwAdd;
   185f0:	6900      	ldr	r0, [r0, #16]
   185f2:	6028      	str	r0, [r5, #0]
   185f4:	8aa3      	ldrh	r3, [r4, #20]
   185f6:	80ab      	strh	r3, [r5, #4]
        if((hE->flags.value & ARP_FLAG_ENTRY_COMPLETE) != 0 )
   185f8:	8823      	ldrh	r3, [r4, #0]
   185fa:	f013 0f80 	tst.w	r3, #128	; 0x80
   185fe:	d101      	bne.n	18604 <TCPIP_ARP_IsResolved+0x60>
        return true;
   18600:	2001      	movs	r0, #1
   18602:	e011      	b.n	18628 <TCPIP_ARP_IsResolved+0x84>
            _ARPRefreshEntry(arpHE, &pArpDcpt->completeList);
   18604:	3718      	adds	r7, #24
    TCPIP_Helper_ProtectedSingleListNodeRemove(pL, (SGL_LIST_NODE*)&arpHE->next);
   18606:	1d25      	adds	r5, r4, #4
   18608:	4629      	mov	r1, r5
   1860a:	4638      	mov	r0, r7
   1860c:	f006 fe44 	bl	1f298 <TCPIP_Helper_ProtectedSingleListNodeRemove>
    arpHE->tInsert = arpMod.timeSeconds;
   18610:	4b08      	ldr	r3, [pc, #32]	; (18634 <TCPIP_ARP_IsResolved+0x90>)
   18612:	695b      	ldr	r3, [r3, #20]
   18614:	60e3      	str	r3, [r4, #12]
    TCPIP_Helper_ProtectedSingleListTailAdd(pL, (SGL_LIST_NODE*)&arpHE->next);
   18616:	4629      	mov	r1, r5
   18618:	4638      	mov	r0, r7
   1861a:	f007 fb20 	bl	1fc5e <TCPIP_Helper_ProtectedSingleListTailAdd>
        return true;
   1861e:	2001      	movs	r0, #1
   18620:	e002      	b.n	18628 <TCPIP_ARP_IsResolved+0x84>
        return false;
   18622:	2000      	movs	r0, #0
}
   18624:	4770      	bx	lr
        return false;
   18626:	2000      	movs	r0, #0
}
   18628:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return false;
   1862a:	2000      	movs	r0, #0
   1862c:	e7fc      	b.n	18628 <TCPIP_ARP_IsResolved+0x84>
    return false;
   1862e:	2000      	movs	r0, #0
   18630:	e7fa      	b.n	18628 <TCPIP_ARP_IsResolved+0x84>
   18632:	bf00      	nop
   18634:	2000dfa4 	.word	0x2000dfa4

Disassembly of section .text.ascii_to_u32s%381:

00018638 <ascii_to_u32s>:
    if(ptr == 0)
   18638:	b1f8      	cbz	r0, 1867a <ascii_to_u32s+0x42>
{
   1863a:	b4f0      	push	{r4, r5, r6, r7}
   1863c:	4604      	mov	r4, r0
    for (i = 0; i < count; i++)
   1863e:	b1d2      	cbz	r2, 18676 <ascii_to_u32s+0x3e>
   18640:	1f0d      	subs	r5, r1, #4
   18642:	3a01      	subs	r2, #1
   18644:	b2d2      	uxtb	r2, r2
   18646:	eb01 0182 	add.w	r1, r1, r2, lsl #2
            tmp = tmp * 1000 * 1000;
   1864a:	4f1f      	ldr	r7, [pc, #124]	; (186c8 <ascii_to_u32s+0x90>)
            tmp = tmp * 1000;
   1864c:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
        while ( (*ptr > (int8_t)'9') || (*ptr < (int8_t)'0') )
   18650:	7822      	ldrb	r2, [r4, #0]
   18652:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
   18656:	b2db      	uxtb	r3, r3
   18658:	2b09      	cmp	r3, #9
   1865a:	d931      	bls.n	186c0 <ascii_to_u32s+0x88>
            if ( (*ptr == (int8_t)' ') || (*ptr == (int8_t)0) ) return; // terminates at blank or NULL.
   1865c:	f012 0fdf 	tst.w	r2, #223	; 0xdf
   18660:	d009      	beq.n	18676 <ascii_to_u32s+0x3e>
        while ( (*ptr > (int8_t)'9') || (*ptr < (int8_t)'0') )
   18662:	f814 2f01 	ldrb.w	r2, [r4, #1]!
   18666:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
   1866a:	b2db      	uxtb	r3, r3
   1866c:	2b09      	cmp	r3, #9
   1866e:	d927      	bls.n	186c0 <ascii_to_u32s+0x88>
            if ( (*ptr == (int8_t)' ') || (*ptr == (int8_t)0) ) return; // terminates at blank or NULL.
   18670:	f012 0fdf 	tst.w	r2, #223	; 0xdf
   18674:	d1f5      	bne.n	18662 <ascii_to_u32s+0x2a>
}
   18676:	bcf0      	pop	{r4, r5, r6, r7}
   18678:	4770      	bx	lr
        *values = 0;
   1867a:	2300      	movs	r3, #0
   1867c:	600b      	str	r3, [r1, #0]
        return;
   1867e:	4770      	bx	lr
            ptr++;
   18680:	4664      	mov	r4, ip
            tmp = tmp*10 + *ptr - '0';
   18682:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   18686:	eb02 0343 	add.w	r3, r2, r3, lsl #1
   1868a:	3b30      	subs	r3, #48	; 0x30
            ptr++;
   1868c:	f104 0c01 	add.w	ip, r4, #1
        while ( (*ptr <= (int8_t)'9') && (*ptr >= (int8_t)'0') )
   18690:	7862      	ldrb	r2, [r4, #1]
   18692:	f1a2 0030 	sub.w	r0, r2, #48	; 0x30
   18696:	b2c0      	uxtb	r0, r0
   18698:	2809      	cmp	r0, #9
   1869a:	d9f1      	bls.n	18680 <ascii_to_u32s+0x48>
        if ( (*ptr == (int8_t)'k') || (*ptr == (int8_t)'K') )
   1869c:	f002 02df 	and.w	r2, r2, #223	; 0xdf
   186a0:	2a4b      	cmp	r2, #75	; 0x4b
   186a2:	d005      	beq.n	186b0 <ascii_to_u32s+0x78>
        else if ( (*ptr == (int8_t)'m') || (*ptr == (int8_t)'M') )
   186a4:	2a4d      	cmp	r2, #77	; 0x4d
            tmp = tmp * 1000 * 1000;
   186a6:	bf06      	itte	eq
   186a8:	437b      	muleq	r3, r7
            ptr++;
   186aa:	3402      	addeq	r4, #2
            ptr++;
   186ac:	4664      	movne	r4, ip
   186ae:	e002      	b.n	186b6 <ascii_to_u32s+0x7e>
            tmp = tmp * 1000;
   186b0:	fb06 f303 	mul.w	r3, r6, r3
            ptr++;
   186b4:	3402      	adds	r4, #2
        values[i] = tmp;
   186b6:	f845 3f04 	str.w	r3, [r5, #4]!
    for (i = 0; i < count; i++)
   186ba:	428d      	cmp	r5, r1
   186bc:	d1c8      	bne.n	18650 <ascii_to_u32s+0x18>
   186be:	e7da      	b.n	18676 <ascii_to_u32s+0x3e>
        while ( (*ptr <= (int8_t)'9') && (*ptr >= (int8_t)'0') )
   186c0:	7822      	ldrb	r2, [r4, #0]
        tmp = 0;
   186c2:	2300      	movs	r3, #0
   186c4:	e7dd      	b.n	18682 <ascii_to_u32s+0x4a>
   186c6:	bf00      	nop
   186c8:	000f4240 	.word	0x000f4240

Disassembly of section .text.DRV_MIIM_OperationResult%382:

000186cc <DRV_MIIM_OperationResult>:
{
   186cc:	b570      	push	{r4, r5, r6, lr}
   186ce:	460c      	mov	r4, r1
   186d0:	4616      	mov	r6, r2
        if((pClient = _DRV_MIIM_GetClientAndLock(handle, true)) == 0)
   186d2:	2101      	movs	r1, #1
   186d4:	f004 f8d1 	bl	1c87a <_DRV_MIIM_GetClientAndLock>
   186d8:	b1f0      	cbz	r0, 18718 <DRV_MIIM_OperationResult+0x4c>
   186da:	4602      	mov	r2, r0
        pMiimObj = pClient->parentObj;
   186dc:	6845      	ldr	r5, [r0, #4]
    if(pOpDcpt != 0 && (pOpDcpt->qType == DRV_MIIM_QTYPE_BUSY || pOpDcpt->qType == DRV_MIIM_QTYPE_COMPLETE))
   186de:	b1c4      	cbz	r4, 18712 <DRV_MIIM_OperationResult+0x46>
   186e0:	7ae3      	ldrb	r3, [r4, #11]
   186e2:	3b02      	subs	r3, #2
   186e4:	b2db      	uxtb	r3, r3
   186e6:	2b01      	cmp	r3, #1
   186e8:	d919      	bls.n	1871e <DRV_MIIM_OperationResult+0x52>
            miimRes = DRV_MIIM_RES_OP_HANDLE_ERR;
   186ea:	f06f 0601 	mvn.w	r6, #1
    if(pMiimObj != 0)
   186ee:	b115      	cbz	r5, 186f6 <DRV_MIIM_OperationResult+0x2a>
    OSAL_SEM_Post(&pMiimObj->objSem);
   186f0:	4628      	mov	r0, r5
   186f2:	f008 ff6f 	bl	215d4 <OSAL_SEM_Post>
}
   186f6:	4630      	mov	r0, r6
   186f8:	bd70      	pop	{r4, r5, r6, pc}
        if(scanAck && pOpDcpt->opStat == DRV_MIIM_TXFER_SCAN_VALID)
   186fa:	2b04      	cmp	r3, #4
   186fc:	d001      	beq.n	18702 <DRV_MIIM_OperationResult+0x36>
        return DRV_MIIM_RES_OK;
   186fe:	2600      	movs	r6, #0
   18700:	e004      	b.n	1870c <DRV_MIIM_OperationResult+0x40>
            pOpDcpt->opStat = DRV_MIIM_TXFER_SCAN_STALE;
   18702:	2303      	movs	r3, #3
   18704:	72a3      	strb	r3, [r4, #10]
        return DRV_MIIM_RES_OK;
   18706:	2600      	movs	r6, #0
   18708:	e7f1      	b.n	186ee <DRV_MIIM_OperationResult+0x22>
        return DRV_MIIM_RES_PENDING;
   1870a:	2601      	movs	r6, #1
        if(pOpDcpt->opStat >= DRV_MIIM_TXFER_DONE)
   1870c:	2b04      	cmp	r3, #4
   1870e:	d9ee      	bls.n	186ee <DRV_MIIM_OperationResult+0x22>
   18710:	e01c      	b.n	1874c <DRV_MIIM_OperationResult+0x80>
            miimRes = DRV_MIIM_RES_OP_HANDLE_ERR;
   18712:	f06f 0601 	mvn.w	r6, #1
   18716:	e7ea      	b.n	186ee <DRV_MIIM_OperationResult+0x22>
            miimRes = DRV_MIIM_RES_HANDLE_ERR;
   18718:	f04f 36ff 	mov.w	r6, #4294967295
    return miimRes;
   1871c:	e7eb      	b.n	186f6 <DRV_MIIM_OperationResult+0x2a>
        if(pOpData != 0)
   1871e:	b136      	cbz	r6, 1872e <DRV_MIIM_OperationResult+0x62>
            if(DRV_MIIM_TXFER_SCAN_STALE <= pOpDcpt->opStat &&  pOpDcpt->opStat <= DRV_MIIM_TXFER_DONE)
   18720:	7aa3      	ldrb	r3, [r4, #10]
   18722:	3b03      	subs	r3, #3
   18724:	b2db      	uxtb	r3, r3
   18726:	2b02      	cmp	r3, #2
                *pOpData = pOpDcpt->opData;
   18728:	bf9c      	itt	ls
   1872a:	8923      	ldrhls	r3, [r4, #8]
   1872c:	8033      	strhls	r3, [r6, #0]
    if(DRV_MIIM_TXFER_START <= pOpDcpt->opStat &&  pOpDcpt->opStat < DRV_MIIM_TXFER_SCAN_VALID)
   1872e:	7aa3      	ldrb	r3, [r4, #10]
   18730:	1e59      	subs	r1, r3, #1
   18732:	b2c9      	uxtb	r1, r1
   18734:	2902      	cmp	r1, #2
   18736:	d9e8      	bls.n	1870a <DRV_MIIM_OperationResult+0x3e>
    else if(pOpDcpt->opStat <= DRV_MIIM_TXFER_DONE)
   18738:	2b05      	cmp	r3, #5
   1873a:	d9de      	bls.n	186fa <DRV_MIIM_OperationResult+0x2e>
    else if(pOpDcpt->opStat == DRV_MIIM_TXFER_TMO_START || pOpDcpt->opStat == DRV_MIIM_TXFER_TMO_END)
   1873c:	3b06      	subs	r3, #6
   1873e:	b2db      	uxtb	r3, r3
        return DRV_MIIM_RES_OP_TIMEOUT_ERR;
   18740:	2b01      	cmp	r3, #1
   18742:	bf8c      	ite	hi
   18744:	f06f 0613 	mvnhi.w	r6, #19
   18748:	f06f 0608 	mvnls.w	r6, #8
            _DRV_MIIM_ReleaseOpDcpt(pMiimObj, pOpDcpt,  &pClient->parentObj->completeOpList, DRV_MIIM_QTYPE_COMPLETE);
   1874c:	6852      	ldr	r2, [r2, #4]
   1874e:	2303      	movs	r3, #3
   18750:	3288      	adds	r2, #136	; 0x88
   18752:	4621      	mov	r1, r4
   18754:	4628      	mov	r0, r5
   18756:	f005 fedb 	bl	1e510 <_DRV_MIIM_ReleaseOpDcpt>
   1875a:	e7c8      	b.n	186ee <DRV_MIIM_OperationResult+0x22>

Disassembly of section .text._DHCPCleanup%383:

0001875c <_DHCPCleanup>:
{
   1875c:	b570      	push	{r4, r5, r6, lr}
    if(dhcpClientSocket != INVALID_UDP_SOCKET)
   1875e:	4b1d      	ldr	r3, [pc, #116]	; (187d4 <_DHCPCleanup+0x78>)
   18760:	f9b3 0000 	ldrsh.w	r0, [r3]
   18764:	f1b0 3fff 	cmp.w	r0, #4294967295
   18768:	d109      	bne.n	1877e <_DHCPCleanup+0x22>
    if(DHCPClients != 0)
   1876a:	4b1b      	ldr	r3, [pc, #108]	; (187d8 <_DHCPCleanup+0x7c>)
   1876c:	681c      	ldr	r4, [r3, #0]
   1876e:	b304      	cbz	r4, 187b2 <_DHCPCleanup+0x56>
        for(ix = 0; ix < dhcpInterfaces; ix++, pClient++)
   18770:	4b1a      	ldr	r3, [pc, #104]	; (187dc <_DHCPCleanup+0x80>)
   18772:	681b      	ldr	r3, [r3, #0]
   18774:	2b00      	cmp	r3, #0
   18776:	dd14      	ble.n	187a2 <_DHCPCleanup+0x46>
   18778:	2500      	movs	r5, #0
   1877a:	4e18      	ldr	r6, [pc, #96]	; (187dc <_DHCPCleanup+0x80>)
   1877c:	e00d      	b.n	1879a <_DHCPCleanup+0x3e>
        TCPIP_UDP_Close(dhcpClientSocket);
   1877e:	f006 fdd3 	bl	1f328 <TCPIP_UDP_Close>
        dhcpClientSocket = INVALID_UDP_SOCKET;
   18782:	4b14      	ldr	r3, [pc, #80]	; (187d4 <_DHCPCleanup+0x78>)
   18784:	f64f 72ff 	movw	r2, #65535	; 0xffff
   18788:	801a      	strh	r2, [r3, #0]
   1878a:	e7ee      	b.n	1876a <_DHCPCleanup+0xe>
                Ipv4DeRegisterFilter(pClient->dhcpFilterHandle);
   1878c:	f007 fb82 	bl	1fe94 <Ipv4DeRegisterFilter>
        for(ix = 0; ix < dhcpInterfaces; ix++, pClient++)
   18790:	3501      	adds	r5, #1
   18792:	345c      	adds	r4, #92	; 0x5c
   18794:	6833      	ldr	r3, [r6, #0]
   18796:	42ab      	cmp	r3, r5
   18798:	dd03      	ble.n	187a2 <_DHCPCleanup+0x46>
            if(pClient->dhcpFilterHandle != 0)
   1879a:	6ca0      	ldr	r0, [r4, #72]	; 0x48
   1879c:	2800      	cmp	r0, #0
   1879e:	d1f5      	bne.n	1878c <_DHCPCleanup+0x30>
   187a0:	e7f6      	b.n	18790 <_DHCPCleanup+0x34>
        TCPIP_HEAP_Free(dhcpMemH, DHCPClients);
   187a2:	4b0f      	ldr	r3, [pc, #60]	; (187e0 <_DHCPCleanup+0x84>)
   187a4:	6818      	ldr	r0, [r3, #0]
   187a6:	4c0c      	ldr	r4, [pc, #48]	; (187d8 <_DHCPCleanup+0x7c>)
   187a8:	68c3      	ldr	r3, [r0, #12]
   187aa:	6821      	ldr	r1, [r4, #0]
   187ac:	4798      	blx	r3
        DHCPClients = 0;
   187ae:	2300      	movs	r3, #0
   187b0:	6023      	str	r3, [r4, #0]
    TCPIP_Notification_Deinitialize(&dhcpRegisteredUsers, dhcpMemH);
   187b2:	4b0b      	ldr	r3, [pc, #44]	; (187e0 <_DHCPCleanup+0x84>)
   187b4:	6819      	ldr	r1, [r3, #0]
   187b6:	480b      	ldr	r0, [pc, #44]	; (187e4 <_DHCPCleanup+0x88>)
   187b8:	f009 f9f0 	bl	21b9c <TCPIP_Notification_Deinitialize>
    if(dhcpSignalHandle)
   187bc:	4b0a      	ldr	r3, [pc, #40]	; (187e8 <_DHCPCleanup+0x8c>)
   187be:	6818      	ldr	r0, [r3, #0]
   187c0:	b120      	cbz	r0, 187cc <_DHCPCleanup+0x70>
        _TCPIPStackSignalHandlerDeregister(dhcpSignalHandle);
   187c2:	f009 fab6 	bl	21d32 <_TCPIPStackSignalHandlerDeregister>
        dhcpSignalHandle = 0;
   187c6:	4b08      	ldr	r3, [pc, #32]	; (187e8 <_DHCPCleanup+0x8c>)
   187c8:	2200      	movs	r2, #0
   187ca:	601a      	str	r2, [r3, #0]
    dhcpInterfaces = 0;
   187cc:	4b03      	ldr	r3, [pc, #12]	; (187dc <_DHCPCleanup+0x80>)
   187ce:	2200      	movs	r2, #0
   187d0:	601a      	str	r2, [r3, #0]
}
   187d2:	bd70      	pop	{r4, r5, r6, pc}
   187d4:	2000e504 	.word	0x2000e504
   187d8:	2000e408 	.word	0x2000e408
   187dc:	2000e410 	.word	0x2000e410
   187e0:	2000e414 	.word	0x2000e414
   187e4:	2000e250 	.word	0x2000e250
   187e8:	2000e41c 	.word	0x2000e41c

Disassembly of section .text._TCPIPStackModuleRxPurge%384:

000187ec <_TCPIPStackModuleRxPurge>:
}

// purges the packets from a module RX queue
// belonging to the pNetIf
void _TCPIPStackModuleRxPurge(TCPIP_STACK_MODULE modId, TCPIP_NET_IF* pNetIf)
{
   187ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   187f0:	b086      	sub	sp, #24
   187f2:	4688      	mov	r8, r1
    TCPIP_MAC_PACKET* pRxPkt;
    SINGLE_LIST       remList = { 0 };  // list of packets to remove/ack
   187f4:	2300      	movs	r3, #0
   187f6:	9303      	str	r3, [sp, #12]
   187f8:	9304      	str	r3, [sp, #16]
   187fa:	9305      	str	r3, [sp, #20]
    SINGLE_LIST       keepList = { 0 };  // list of packets to keep
   187fc:	9300      	str	r3, [sp, #0]
   187fe:	9301      	str	r3, [sp, #4]
   18800:	9302      	str	r3, [sp, #8]

    SINGLE_LIST*      pRxQueue = (TCPIP_MODULES_QUEUE_TBL + modId); // list to extract from
   18802:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   18806:	4f1c      	ldr	r7, [pc, #112]	; (18878 <_TCPIPStackModuleRxPurge+0x8c>)
   18808:	eb07 0780 	add.w	r7, r7, r0, lsl #2
    
    // kill the list
    while(true)
    {
        OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1880c:	461d      	mov	r5, r3
   1880e:	4628      	mov	r0, r5
   18810:	f008 fed4 	bl	215bc <OSAL_CRIT_Enter>
   18814:	4606      	mov	r6, r0
        pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(pRxQueue);
   18816:	4638      	mov	r0, r7
   18818:	f008 fb7e 	bl	20f18 <TCPIP_Helper_SingleListHeadRemove>
   1881c:	4604      	mov	r4, r0
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1881e:	4631      	mov	r1, r6
   18820:	4628      	mov	r0, r5
   18822:	f008 fffa 	bl	2181a <OSAL_CRIT_Leave>
        if(pRxPkt == 0)
   18826:	b144      	cbz	r4, 1883a <_TCPIPStackModuleRxPurge+0x4e>
        {
            break;
        }


        if(pRxPkt->pktIf == pNetIf)
   18828:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1882a:	4543      	cmp	r3, r8
        {   // need to remove
            TCPIP_Helper_SingleListTailAdd(&remList, (SGL_LIST_NODE*)pRxPkt);
   1882c:	4621      	mov	r1, r4
   1882e:	bf0c      	ite	eq
   18830:	a803      	addeq	r0, sp, #12
        }
        else
        {   // need to keep
            TCPIP_Helper_SingleListTailAdd(&keepList, (SGL_LIST_NODE*)pRxPkt);
   18832:	4668      	movne	r0, sp
   18834:	f008 fd44 	bl	212c0 <TCPIP_Helper_SingleListTailAdd>
   18838:	e7e9      	b.n	1880e <_TCPIPStackModuleRxPurge+0x22>
    }

    // acknowledge the removed packets
    while((pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(&remList)) != 0)
    {
        TCPIP_PKT_PacketAcknowledge(pRxPkt, TCPIP_MAC_PKT_ACK_SOURCE_ERR);
   1883a:	2501      	movs	r5, #1
   1883c:	f06f 040a 	mvn.w	r4, #10
   18840:	e004      	b.n	1884c <_TCPIPStackModuleRxPurge+0x60>
   18842:	462a      	mov	r2, r5
   18844:	4621      	mov	r1, r4
   18846:	4618      	mov	r0, r3
   18848:	f005 f9d4 	bl	1dbf4 <_TCPIP_PKT_PacketAcknowledge>
    while((pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(&remList)) != 0)
   1884c:	a803      	add	r0, sp, #12
   1884e:	f008 fb63 	bl	20f18 <TCPIP_Helper_SingleListHeadRemove>
   18852:	4603      	mov	r3, r0
   18854:	2800      	cmp	r0, #0
   18856:	d1f4      	bne.n	18842 <_TCPIPStackModuleRxPurge+0x56>
    }

    if(!TCPIP_Helper_SingleListIsEmpty(&keepList))
   18858:	9b00      	ldr	r3, [sp, #0]
   1885a:	b153      	cbz	r3, 18872 <_TCPIPStackModuleRxPurge+0x86>
    {   // replace the remaining packets
        OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1885c:	f008 feae 	bl	215bc <OSAL_CRIT_Enter>
   18860:	4604      	mov	r4, r0
        TCPIP_Helper_SingleListAppend(pRxQueue, &keepList);
   18862:	4669      	mov	r1, sp
   18864:	4638      	mov	r0, r7
   18866:	f008 fd38 	bl	212da <TCPIP_Helper_SingleListAppend>
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1886a:	4621      	mov	r1, r4
   1886c:	2000      	movs	r0, #0
   1886e:	f008 ffd4 	bl	2181a <OSAL_CRIT_Leave>
    }

}
   18872:	b006      	add	sp, #24
   18874:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   18878:	2000dc84 	.word	0x2000dc84

Disassembly of section .text.NVIC_Initialize%385:

0001887c <NVIC_Initialize>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
   1887c:	4921      	ldr	r1, [pc, #132]	; (18904 <NVIC_Initialize+0x88>)
   1887e:	68cb      	ldr	r3, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
   18880:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
   18884:	041b      	lsls	r3, r3, #16
   18886:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                   |
   18888:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
   1888c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  SCB->AIRCR =  reg_value;
   18890:	60cb      	str	r3, [r1, #12]
   18892:	f3bf 8f5f 	dmb	sy
  \details Enables IRQ interrupts by clearing special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   18896:	b662      	cpsie	i
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   18898:	22e0      	movs	r2, #224	; 0xe0
   1889a:	f881 2023 	strb.w	r2, [r1, #35]	; 0x23
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1889e:	4b1a      	ldr	r3, [pc, #104]	; (18908 <NVIC_Initialize+0x8c>)
   188a0:	f883 232e 	strb.w	r2, [r3, #814]	; 0x32e
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   188a4:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   188a8:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   188aa:	f883 232f 	strb.w	r2, [r3, #815]	; 0x32f
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   188ae:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   188b2:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   188b4:	f883 2330 	strb.w	r2, [r3, #816]	; 0x330
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   188b8:	f44f 3180 	mov.w	r1, #65536	; 0x10000
   188bc:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   188be:	f883 2331 	strb.w	r2, [r3, #817]	; 0x331
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   188c2:	f44f 3100 	mov.w	r1, #131072	; 0x20000
   188c6:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   188c8:	f883 2332 	strb.w	r2, [r3, #818]	; 0x332
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   188cc:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   188d0:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   188d2:	f883 2333 	strb.w	r2, [r3, #819]	; 0x333
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   188d6:	f44f 2100 	mov.w	r1, #524288	; 0x80000
   188da:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   188dc:	f883 2334 	strb.w	r2, [r3, #820]	; 0x334
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   188e0:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
   188e4:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   188e6:	f883 2335 	strb.w	r2, [r3, #821]	; 0x335
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   188ea:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
   188ee:	6058      	str	r0, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   188f0:	f883 2354 	strb.w	r2, [r3, #852]	; 0x354
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   188f4:	6099      	str	r1, [r3, #8]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   188f6:	f883 236b 	strb.w	r2, [r3, #875]	; 0x36b
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   188fa:	f44f 6200 	mov.w	r2, #2048	; 0x800
   188fe:	60da      	str	r2, [r3, #12]
    NVIC_SetPriority(TC0_IRQn, 7);
    NVIC_EnableIRQ(TC0_IRQn);



}
   18900:	4770      	bx	lr
   18902:	bf00      	nop
   18904:	e000ed00 	.word	0xe000ed00
   18908:	e000e100 	.word	0xe000e100

Disassembly of section .text.SYS_TIME_AddToList%386:

0001890c <SYS_TIME_AddToList>:
    if (newTimer == NULL)
   1890c:	b330      	cbz	r0, 1895c <SYS_TIME_AddToList+0x50>
{
   1890e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   18912:	4686      	mov	lr, r0
    SYS_TIME_TIMER_OBJ* tmr = counter->tmrActive;
   18914:	4b20      	ldr	r3, [pc, #128]	; (18998 <SYS_TIME_AddToList+0x8c>)
   18916:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    newTimerTime = newTimer->relativeTimePending;
   18918:	f8d0 8008 	ldr.w	r8, [r0, #8]
    if (tmr == NULL)
   1891c:	b1c2      	cbz	r2, 18950 <SYS_TIME_AddToList+0x44>
            if ((total_time + tmr->relativeTimePending) > newTimerTime)
   1891e:	6893      	ldr	r3, [r2, #8]
   18920:	4640      	mov	r0, r8
   18922:	2100      	movs	r1, #0
   18924:	4598      	cmp	r8, r3
   18926:	d31b      	bcc.n	18960 <SYS_TIME_AddToList+0x54>
    uint64_t total_time = 0;
   18928:	2400      	movs	r4, #0
   1892a:	2500      	movs	r5, #0
            total_time += tmr->relativeTimePending;
   1892c:	6893      	ldr	r3, [r2, #8]
   1892e:	18e4      	adds	r4, r4, r3
   18930:	f145 0500 	adc.w	r5, r5, #0
            tmr = tmr->tmrNext;
   18934:	6993      	ldr	r3, [r2, #24]
        while (tmr != NULL)
   18936:	b1db      	cbz	r3, 18970 <SYS_TIME_AddToList+0x64>
            if ((total_time + tmr->relativeTimePending) > newTimerTime)
   18938:	f8d3 c008 	ldr.w	ip, [r3, #8]
   1893c:	eb14 060c 	adds.w	r6, r4, ip
   18940:	f145 0700 	adc.w	r7, r5, #0
   18944:	42b9      	cmp	r1, r7
   18946:	bf08      	it	eq
   18948:	42b0      	cmpeq	r0, r6
   1894a:	d311      	bcc.n	18970 <SYS_TIME_AddToList+0x64>
            tmr = tmr->tmrNext;
   1894c:	461a      	mov	r2, r3
   1894e:	e7ed      	b.n	1892c <SYS_TIME_AddToList+0x20>
        newTimer->relativeTimePending = newTimerTime;
   18950:	f8c0 8008 	str.w	r8, [r0, #8]
        counter->tmrActive = newTimer;
   18954:	4b10      	ldr	r3, [pc, #64]	; (18998 <SYS_TIME_AddToList+0x8c>)
   18956:	6318      	str	r0, [r3, #48]	; 0x30
        isHeadTimerUpdated = true;
   18958:	2001      	movs	r0, #1
   1895a:	e01a      	b.n	18992 <SYS_TIME_AddToList+0x86>
        return isHeadTimerUpdated;
   1895c:	2000      	movs	r0, #0
}
   1895e:	4770      	bx	lr
            counter->tmrActive = newTimer;
   18960:	4b0d      	ldr	r3, [pc, #52]	; (18998 <SYS_TIME_AddToList+0x8c>)
   18962:	f8c3 e030 	str.w	lr, [r3, #48]	; 0x30
            newTimer->tmrNext = tmr;
   18966:	f8ce 2018 	str.w	r2, [lr, #24]
    uint64_t total_time = 0;
   1896a:	2400      	movs	r4, #0
            isHeadTimerUpdated = true;
   1896c:	2001      	movs	r0, #1
   1896e:	e004      	b.n	1897a <SYS_TIME_AddToList+0x6e>
            newTimer->tmrNext = prevTmr->tmrNext;
   18970:	f8ce 3018 	str.w	r3, [lr, #24]
            prevTmr->tmrNext = newTimer;
   18974:	f8c2 e018 	str.w	lr, [r2, #24]
    bool isHeadTimerUpdated = false;
   18978:	2000      	movs	r0, #0
        newTimer->relativeTimePending = newTimerTime - total_time;
   1897a:	eba8 0404 	sub.w	r4, r8, r4
   1897e:	f8ce 4008 	str.w	r4, [lr, #8]
        if (newTimer->tmrNext != NULL)
   18982:	f8de 3018 	ldr.w	r3, [lr, #24]
   18986:	b123      	cbz	r3, 18992 <SYS_TIME_AddToList+0x86>
            newTimerTime = newTimer->relativeTimePending;
   18988:	f8de 1008 	ldr.w	r1, [lr, #8]
            newTimer->tmrNext->relativeTimePending -= newTimerTime;
   1898c:	689a      	ldr	r2, [r3, #8]
   1898e:	1a52      	subs	r2, r2, r1
   18990:	609a      	str	r2, [r3, #8]
}
   18992:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   18996:	bf00      	nop
   18998:	2000e030 	.word	0x2000e030

Disassembly of section .text.Reset_Handler%387:

0001899c <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void __attribute__((optimize("-O1"), section(".text.Reset_Handler"), long_call, noreturn)) Reset_Handler(void)
{
   1899c:	b508      	push	{r3, lr}
    __asm__ volatile ("add r7, sp, #0" : : : "r7");
#endif


    /* Call the optional application-provided _on_reset() function. */
    _on_reset();
   1899e:	4b1b      	ldr	r3, [pc, #108]	; (18a0c <Reset_Handler+0x70>)
   189a0:	4798      	blx	r3

    /* Reserved for use by MPLAB XC32. */
    __xc32_on_reset();
   189a2:	4b1b      	ldr	r3, [pc, #108]	; (18a10 <Reset_Handler+0x74>)
   189a4:	4798      	blx	r3
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   189a6:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
   189aa:	b672      	cpsid	i
     SCB->CPACR |= (0xFu << 20);
   189ac:	4a19      	ldr	r2, [pc, #100]	; (18a14 <Reset_Handler+0x78>)
   189ae:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
   189b2:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
   189b6:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
   189ba:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   189be:	f3bf 8f6f 	isb	sy
    if (!prim)
   189c2:	b901      	cbnz	r1, 189c6 <Reset_Handler+0x2a>
  __ASM volatile ("cpsie i" : : : "memory");
   189c4:	b662      	cpsie	i
    CMCC_REGS->CMCC_CFG = CMCC_CFG_CSIZESW(tcmSize);
   189c6:	4c14      	ldr	r4, [pc, #80]	; (18a18 <Reset_Handler+0x7c>)
   189c8:	2320      	movs	r3, #32
   189ca:	6063      	str	r3, [r4, #4]
    /* Enable TCM   */
    TCM_Enable();

    /* Initialize data after TCM is enabled.
     * Data initialization from the XC32 .dinit template */
    __pic32c_data_initialization();
   189cc:	f000 fa9a 	bl	18f04 <__pic32c_data_initialization>


#  ifdef SCB_VTOR_TBLOFF_Msk
    /*  Set the vector-table base address in FLASH */
    pSrc = (uint32_t *) & __svectors;
    SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
   189d0:	4b12      	ldr	r3, [pc, #72]	; (18a1c <Reset_Handler+0x80>)
   189d2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
   189d6:	4a0f      	ldr	r2, [pc, #60]	; (18a14 <Reset_Handler+0x78>)
   189d8:	6093      	str	r3, [r2, #8]
#  endif /* SCB_VTOR_TBLOFF_Msk */

    /* Initialize the C library */
    __libc_init_array();
   189da:	4b11      	ldr	r3, [pc, #68]	; (18a20 <Reset_Handler+0x84>)
   189dc:	4798      	blx	r3
    CMCC_REGS->CMCC_CTRL &= ~(CMCC_CTRL_CEN_Msk);
   189de:	68a3      	ldr	r3, [r4, #8]
   189e0:	f023 0301 	bic.w	r3, r3, #1
   189e4:	60a3      	str	r3, [r4, #8]
    while((CMCC_REGS->CMCC_SR & CMCC_SR_CSTS_Msk) == CMCC_SR_CSTS_Msk)
   189e6:	4623      	mov	r3, r4
   189e8:	68da      	ldr	r2, [r3, #12]
   189ea:	f012 0f01 	tst.w	r2, #1
   189ee:	d1fb      	bne.n	189e8 <Reset_Handler+0x4c>
    CMCC_REGS->CMCC_CFG |= (CMCC_CFG_DCDIS_Msk);
   189f0:	4b09      	ldr	r3, [pc, #36]	; (18a18 <Reset_Handler+0x7c>)
   189f2:	685a      	ldr	r2, [r3, #4]
   189f4:	f042 0204 	orr.w	r2, r2, #4
   189f8:	605a      	str	r2, [r3, #4]
    CMCC_REGS->CMCC_CTRL = (CMCC_CTRL_CEN_Msk);
   189fa:	2201      	movs	r2, #1
   189fc:	609a      	str	r2, [r3, #8]
    /* Enable Instruction Cache */
    ICache_Enable();


    /* Call the optional application-provided _on_bootstrap() function. */
    _on_bootstrap();
   189fe:	4b09      	ldr	r3, [pc, #36]	; (18a24 <Reset_Handler+0x88>)
   18a00:	4798      	blx	r3
    
    /* Reserved for use by MPLAB XC32. */
    __xc32_on_bootstrap();
   18a02:	4b09      	ldr	r3, [pc, #36]	; (18a28 <Reset_Handler+0x8c>)
   18a04:	4798      	blx	r3

    /* Branch to application's main function */
    int retval = main();
   18a06:	f009 f99b 	bl	21d40 <main>

#if (defined(__DEBUG) || defined(__DEBUG_D)) && defined(__XC32)
    __builtin_software_breakpoint();
#endif
    /* Infinite loop */
    while (true) {}
   18a0a:	e7fe      	b.n	18a0a <Reset_Handler+0x6e>
   18a0c:	00019aff 	.word	0x00019aff
   18a10:	00019aff 	.word	0x00019aff
   18a14:	e000ed00 	.word	0xe000ed00
   18a18:	41006000 	.word	0x41006000
   18a1c:	00000000 	.word	0x00000000
   18a20:	0001d129 	.word	0x0001d129
   18a24:	00019aff 	.word	0x00019aff
   18a28:	00019aff 	.word	0x00019aff

Disassembly of section .text._DHCPClientClose%388:

00018a2c <_DHCPClientClose>:
{
   18a2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18a2e:	4605      	mov	r5, r0
   18a30:	460e      	mov	r6, r1
   18a32:	4617      	mov	r7, r2
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   18a34:	4b1f      	ldr	r3, [pc, #124]	; (18ab4 <_DHCPClientClose+0x88>)
   18a36:	681c      	ldr	r4, [r3, #0]
   18a38:	f009 f974 	bl	21d24 <TCPIP_STACK_NetIxGet>
   18a3c:	235c      	movs	r3, #92	; 0x5c
   18a3e:	fb03 4400 	mla	r4, r3, r0, r4
    if(pClient->flags.bDHCPEnabled != 0)
   18a42:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
   18a46:	f013 0f01 	tst.w	r3, #1
   18a4a:	d026      	beq.n	18a9a <_DHCPClientClose+0x6e>
        if(release && pClient->smState >= TCPIP_DHCP_BOUND)
   18a4c:	b11f      	cbz	r7, 18a56 <_DHCPClientClose+0x2a>
   18a4e:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
   18a52:	2b07      	cmp	r3, #7
   18a54:	d822      	bhi.n	18a9c <_DHCPClientClose+0x70>
		pClient->flags.bIsBound = false;
   18a56:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
        pClient->flags.bReportFail = 1;	
   18a5a:	f003 03f5 	and.w	r3, r3, #245	; 0xf5
   18a5e:	f043 0320 	orr.w	r3, r3, #32
   18a62:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
        pClient->tOpStart = 0; 
   18a66:	2300      	movs	r3, #0
   18a68:	6223      	str	r3, [r4, #32]
        pClient->dhcpTmo = pClient->dhcpTmoBase;
   18a6a:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
   18a6e:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    if(pClient->dhcpFilterHandle != 0)
   18a72:	6ca0      	ldr	r0, [r4, #72]	; 0x48
   18a74:	b110      	cbz	r0, 18a7c <_DHCPClientClose+0x50>
        Ipv4FilterSetActive(pClient->dhcpFilterHandle, active);
   18a76:	2100      	movs	r1, #0
   18a78:	f002 fd4a 	bl	1b510 <Ipv4FilterSetActive>
        if(disable)
   18a7c:	b1ae      	cbz	r6, 18aaa <_DHCPClientClose+0x7e>
            pClient->flags.bWasBound = false;	
   18a7e:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
            pClient->flags.bDHCPEnabled = false;
   18a82:	f003 03ef 	and.w	r3, r3, #239	; 0xef
   18a86:	f36f 0300 	bfc	r3, #0, #1
   18a8a:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
            pNetIf->Flags.bIsDHCPEnabled = false;
   18a8e:	f895 3042 	ldrb.w	r3, [r5, #66]	; 0x42
   18a92:	f36f 0300 	bfc	r3, #0, #1
   18a96:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
}
   18a9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            _DHCPSend(pClient, pNetIf, TCPIP_DHCP_RELEASE_MESSAGE, 0);
   18a9c:	2300      	movs	r3, #0
   18a9e:	2207      	movs	r2, #7
   18aa0:	4629      	mov	r1, r5
   18aa2:	4620      	mov	r0, r4
   18aa4:	f7f7 f8a8 	bl	fbf8 <_DHCPSend>
   18aa8:	e7d5      	b.n	18a56 <_DHCPClientClose+0x2a>
    pClient->smState = newState;
   18aaa:	2300      	movs	r3, #0
   18aac:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
}
   18ab0:	e7f3      	b.n	18a9a <_DHCPClientClose+0x6e>
   18ab2:	bf00      	nop
   18ab4:	2000e408 	.word	0x2000e408

Disassembly of section .text.TCPIP_STACK_Initialize%389:

00018ab8 <TCPIP_STACK_Initialize>:
{
   18ab8:	b538      	push	{r3, r4, r5, lr}
    if(tcpipNetIf != 0)
   18aba:	4b18      	ldr	r3, [pc, #96]	; (18b1c <TCPIP_STACK_Initialize+0x64>)
   18abc:	681b      	ldr	r3, [r3, #0]
   18abe:	b10b      	cbz	r3, 18ac4 <TCPIP_STACK_Initialize+0xc>
        return (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data;
   18ac0:	4817      	ldr	r0, [pc, #92]	; (18b20 <TCPIP_STACK_Initialize+0x68>)
}
   18ac2:	bd38      	pop	{r3, r4, r5, pc}
    if(init == 0)
   18ac4:	b331      	cbz	r1, 18b14 <TCPIP_STACK_Initialize+0x5c>
   18ac6:	460d      	mov	r5, r1
    totTcpipEventsCnt = 0;
   18ac8:	2400      	movs	r4, #0
   18aca:	4b16      	ldr	r3, [pc, #88]	; (18b24 <TCPIP_STACK_Initialize+0x6c>)
   18acc:	601c      	str	r4, [r3, #0]
    newTcpipErrorEventCnt = 0;
   18ace:	4b16      	ldr	r3, [pc, #88]	; (18b28 <TCPIP_STACK_Initialize+0x70>)
   18ad0:	601c      	str	r4, [r3, #0]
    newTcpipStackEventCnt = 0;
   18ad2:	4b16      	ldr	r3, [pc, #88]	; (18b2c <TCPIP_STACK_Initialize+0x74>)
   18ad4:	601c      	str	r4, [r3, #0]
    newTcpipTickAvlbl = 0;
   18ad6:	4b16      	ldr	r3, [pc, #88]	; (18b30 <TCPIP_STACK_Initialize+0x78>)
   18ad8:	601c      	str	r4, [r3, #0]
    stackTaskRate = 0;
   18ada:	4b16      	ldr	r3, [pc, #88]	; (18b34 <TCPIP_STACK_Initialize+0x7c>)
   18adc:	601c      	str	r4, [r3, #0]
    memset(&tcpip_stack_ctrl_data, 0, sizeof(tcpip_stack_ctrl_data));
   18ade:	2220      	movs	r2, #32
   18ae0:	4621      	mov	r1, r4
   18ae2:	480f      	ldr	r0, [pc, #60]	; (18b20 <TCPIP_STACK_Initialize+0x68>)
   18ae4:	f009 f8d2 	bl	21c8c <memset>
    SYS_CONSOLE_MESSAGE(TCPIP_STACK_HDR_MESSAGE "Initialization Started \r\n");
   18ae8:	4913      	ldr	r1, [pc, #76]	; (18b38 <TCPIP_STACK_Initialize+0x80>)
   18aea:	4620      	mov	r0, r4
   18aec:	f006 fc7c 	bl	1f3e8 <SYS_CONSOLE_Message>
    tcpip_stack_status = SYS_STATUS_BUSY;
   18af0:	4b12      	ldr	r3, [pc, #72]	; (18b3c <TCPIP_STACK_Initialize+0x84>)
   18af2:	2201      	movs	r2, #1
   18af4:	701a      	strb	r2, [r3, #0]
    if((tcpip_stack_init_cb = ((TCPIP_STACK_INIT*)init)->initCback) == 0)
   18af6:	696b      	ldr	r3, [r5, #20]
   18af8:	4a11      	ldr	r2, [pc, #68]	; (18b40 <TCPIP_STACK_Initialize+0x88>)
   18afa:	6013      	str	r3, [r2, #0]
   18afc:	b10b      	cbz	r3, 18b02 <TCPIP_STACK_Initialize+0x4a>
    return (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data;
   18afe:	4808      	ldr	r0, [pc, #32]	; (18b20 <TCPIP_STACK_Initialize+0x68>)
   18b00:	e7df      	b.n	18ac2 <TCPIP_STACK_Initialize+0xa>
        bool init_res = _TCPIP_DoInitialize((const TCPIP_STACK_INIT*)init);
   18b02:	4628      	mov	r0, r5
   18b04:	f7f0 fd30 	bl	9568 <_TCPIP_DoInitialize>
        return init_res ? (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data : SYS_MODULE_OBJ_INVALID;
   18b08:	2800      	cmp	r0, #0
   18b0a:	4805      	ldr	r0, [pc, #20]	; (18b20 <TCPIP_STACK_Initialize+0x68>)
   18b0c:	bf08      	it	eq
   18b0e:	f04f 30ff 	moveq.w	r0, #4294967295
   18b12:	e7d6      	b.n	18ac2 <TCPIP_STACK_Initialize+0xa>
        return SYS_MODULE_OBJ_INVALID;
   18b14:	f04f 30ff 	mov.w	r0, #4294967295
   18b18:	e7d3      	b.n	18ac2 <TCPIP_STACK_Initialize+0xa>
   18b1a:	bf00      	nop
   18b1c:	2000e440 	.word	0x2000e440
   18b20:	2000e0f0 	.word	0x2000e0f0
   18b24:	2000e448 	.word	0x2000e448
   18b28:	2000e428 	.word	0x2000e428
   18b2c:	2000e42c 	.word	0x2000e42c
   18b30:	2000e430 	.word	0x2000e430
   18b34:	2000e438 	.word	0x2000e438
   18b38:	00009410 	.word	0x00009410
   18b3c:	2000e50d 	.word	0x2000e50d
   18b40:	2000e444 	.word	0x2000e444

Disassembly of section .text._UDPsetPacketInfo%390:

00018b44 <_UDPsetPacketInfo>:
    if(pRxPkt != 0 && pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   18b44:	2900      	cmp	r1, #0
   18b46:	d040      	beq.n	18bca <_UDPsetPacketInfo+0x86>
{
   18b48:	b570      	push	{r4, r5, r6, lr}
   18b4a:	b082      	sub	sp, #8
   18b4c:	460d      	mov	r5, r1
    if(pRxPkt != 0 && pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   18b4e:	8f82      	ldrh	r2, [r0, #60]	; 0x3c
   18b50:	2a01      	cmp	r2, #1
   18b52:	d001      	beq.n	18b58 <_UDPsetPacketInfo+0x14>
}
   18b54:	b002      	add	sp, #8
   18b56:	bd70      	pop	{r4, r5, r6, pc}
        uint32_t pktSrcAdd = TCPIP_IPV4_PacketGetSourceAddress(pRxPkt)->Val;
   18b58:	698a      	ldr	r2, [r1, #24]
   18b5a:	68d2      	ldr	r2, [r2, #12]
        pSkt->pktSrcAddress.Val = pktSrcAdd;
   18b5c:	61c2      	str	r2, [r0, #28]
        if(pSkt->extFlags.ignoreSrcAdd == 0 && pSkt->flags.destSet == 0)
   18b5e:	6c01      	ldr	r1, [r0, #64]	; 0x40
   18b60:	4c1a      	ldr	r4, [pc, #104]	; (18bcc <_UDPsetPacketInfo+0x88>)
   18b62:	420c      	tst	r4, r1
            pSkt->destAddress.Val = pktSrcAdd;
   18b64:	bf08      	it	eq
   18b66:	6142      	streq	r2, [r0, #20]
   18b68:	4604      	mov	r4, r0
        uint32_t pktDestAdd = TCPIP_IPV4_PacketGetDestAddress(pRxPkt)->Val;
   18b6a:	69ab      	ldr	r3, [r5, #24]
   18b6c:	691e      	ldr	r6, [r3, #16]
   18b6e:	9601      	str	r6, [sp, #4]
        pSkt->pktDestAddress.Val = pktDestAdd;
   18b70:	6206      	str	r6, [r0, #32]
        if(pSkt->flags.srcSet == 0)
   18b72:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   18b76:	f013 0f20 	tst.w	r3, #32
   18b7a:	d00a      	beq.n	18b92 <_UDPsetPacketInfo+0x4e>
        pSkt->pSktNet = (TCPIP_NET_IF*)pRxPkt->pktIf;    // bind it
   18b7c:	6aab      	ldr	r3, [r5, #40]	; 0x28
   18b7e:	6263      	str	r3, [r4, #36]	; 0x24
        if(pSkt->extFlags.ignoreSrcPort == 0 )
   18b80:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   18b84:	f013 0f20 	tst.w	r3, #32
   18b88:	d1e4      	bne.n	18b54 <_UDPsetPacketInfo+0x10>
    return ((UDP_HEADER*)pRxPkt->pTransportLayer)->SourcePort;
   18b8a:	69eb      	ldr	r3, [r5, #28]
   18b8c:	881b      	ldrh	r3, [r3, #0]
            pSkt->remotePort = _UDPRxPktSourcePort(pRxPkt); 
   18b8e:	8523      	strh	r3, [r4, #40]	; 0x28
}
   18b90:	e7e0      	b.n	18b54 <_UDPsetPacketInfo+0x10>
            bool isBcastAdd = TCPIP_STACK_IsBcastAddress((TCPIP_NET_IF*)pRxPkt->pktIf, (IPV4_ADDR*)&pktDestAdd);
   18b92:	a901      	add	r1, sp, #4
   18b94:	6aa8      	ldr	r0, [r5, #40]	; 0x28
   18b96:	f006 fec3 	bl	1f920 <TCPIP_STACK_IsBcastAddress>
            if(!isBcastAdd && !isMcastAdd)
   18b9a:	2800      	cmp	r0, #0
   18b9c:	d1ee      	bne.n	18b7c <_UDPsetPacketInfo+0x38>
   18b9e:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
   18ba2:	2ee0      	cmp	r6, #224	; 0xe0
   18ba4:	d0ea      	beq.n	18b7c <_UDPsetPacketInfo+0x38>
                if(pSkt->srcAddress.Val != pktDestAdd)
   18ba6:	9b01      	ldr	r3, [sp, #4]
   18ba8:	69a2      	ldr	r2, [r4, #24]
   18baa:	429a      	cmp	r2, r3
   18bac:	d006      	beq.n	18bbc <_UDPsetPacketInfo+0x78>
                    pSkt->flags.srcSolved = 0;
   18bae:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
   18bb2:	f36f 12c7 	bfc	r2, #7, #1
   18bb6:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
                    pSkt->srcAddress.Val = pktDestAdd;
   18bba:	61a3      	str	r3, [r4, #24]
                pSkt->flags.srcValid = 1;
   18bbc:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
   18bc0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   18bc4:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
   18bc8:	e7d8      	b.n	18b7c <_UDPsetPacketInfo+0x38>
   18bca:	4770      	bx	lr
   18bcc:	00100100 	.word	0x00100100

Disassembly of section .text.__smakebuf_r%391:

00018bd0 <__smakebuf_r>:
   18bd0:	898b      	ldrh	r3, [r1, #12]
   18bd2:	b573      	push	{r0, r1, r4, r5, r6, lr}
   18bd4:	079d      	lsls	r5, r3, #30
   18bd6:	4606      	mov	r6, r0
   18bd8:	460c      	mov	r4, r1
   18bda:	d507      	bpl.n	18bec <__smakebuf_r+0x1c>
   18bdc:	f101 0347 	add.w	r3, r1, #71	; 0x47
   18be0:	600b      	str	r3, [r1, #0]
   18be2:	610b      	str	r3, [r1, #16]
   18be4:	2301      	movs	r3, #1
   18be6:	614b      	str	r3, [r1, #20]
   18be8:	b002      	add	sp, #8
   18bea:	bd70      	pop	{r4, r5, r6, pc}
   18bec:	ab01      	add	r3, sp, #4
   18bee:	466a      	mov	r2, sp
   18bf0:	f004 fb06 	bl	1d200 <__swhatbuf_r>
   18bf4:	9900      	ldr	r1, [sp, #0]
   18bf6:	4605      	mov	r5, r0
   18bf8:	4630      	mov	r0, r6
   18bfa:	f7fe f8c1 	bl	16d80 <_malloc_r>
   18bfe:	b978      	cbnz	r0, 18c20 <__smakebuf_r+0x50>
   18c00:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   18c04:	059a      	lsls	r2, r3, #22
   18c06:	d4ef      	bmi.n	18be8 <__smakebuf_r+0x18>
   18c08:	f023 0303 	bic.w	r3, r3, #3
   18c0c:	f043 0302 	orr.w	r3, r3, #2
   18c10:	81a3      	strh	r3, [r4, #12]
   18c12:	f104 0347 	add.w	r3, r4, #71	; 0x47
   18c16:	6023      	str	r3, [r4, #0]
   18c18:	6123      	str	r3, [r4, #16]
   18c1a:	2301      	movs	r3, #1
   18c1c:	6163      	str	r3, [r4, #20]
   18c1e:	e7e3      	b.n	18be8 <__smakebuf_r+0x18>
   18c20:	4b0d      	ldr	r3, [pc, #52]	; (18c58 <__smakebuf_r+0x88>)
   18c22:	62b3      	str	r3, [r6, #40]	; 0x28
   18c24:	89a3      	ldrh	r3, [r4, #12]
   18c26:	6020      	str	r0, [r4, #0]
   18c28:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   18c2c:	81a3      	strh	r3, [r4, #12]
   18c2e:	9b00      	ldr	r3, [sp, #0]
   18c30:	6163      	str	r3, [r4, #20]
   18c32:	9b01      	ldr	r3, [sp, #4]
   18c34:	6120      	str	r0, [r4, #16]
   18c36:	b15b      	cbz	r3, 18c50 <__smakebuf_r+0x80>
   18c38:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   18c3c:	4630      	mov	r0, r6
   18c3e:	f008 f847 	bl	20cd0 <_isatty_r>
   18c42:	b128      	cbz	r0, 18c50 <__smakebuf_r+0x80>
   18c44:	89a3      	ldrh	r3, [r4, #12]
   18c46:	f023 0303 	bic.w	r3, r3, #3
   18c4a:	f043 0301 	orr.w	r3, r3, #1
   18c4e:	81a3      	strh	r3, [r4, #12]
   18c50:	89a3      	ldrh	r3, [r4, #12]
   18c52:	431d      	orrs	r5, r3
   18c54:	81a5      	strh	r5, [r4, #12]
   18c56:	e7c7      	b.n	18be8 <__smakebuf_r+0x18>
   18c58:	000220a5 	.word	0x000220a5

Disassembly of section .text._Command_GatewayAddressSet%392:

00018c5c <_Command_GatewayAddressSet>:
{
   18c5c:	b5f0      	push	{r4, r5, r6, r7, lr}
   18c5e:	b083      	sub	sp, #12
   18c60:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   18c62:	6845      	ldr	r5, [r0, #4]
    if (argc != 3)
   18c64:	2903      	cmp	r1, #3
   18c66:	d00f      	beq.n	18c88 <_Command_GatewayAddressSet+0x2c>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: setgw <interface> <ipv4/6 address> <validTime> \r\n");
   18c68:	4e1a      	ldr	r6, [pc, #104]	; (18cd4 <_Command_GatewayAddressSet+0x78>)
   18c6a:	6803      	ldr	r3, [r0, #0]
   18c6c:	681b      	ldr	r3, [r3, #0]
   18c6e:	f506 6155 	add.w	r1, r6, #3408	; 0xd50
   18c72:	4628      	mov	r0, r5
   18c74:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: setgw PIC32INT 192.168.0.1 \r\n");
   18c76:	6823      	ldr	r3, [r4, #0]
   18c78:	681b      	ldr	r3, [r3, #0]
   18c7a:	f606 518c 	addw	r1, r6, #3468	; 0xd8c
   18c7e:	4628      	mov	r0, r5
   18c80:	4798      	blx	r3
}
   18c82:	2000      	movs	r0, #0
   18c84:	b003      	add	sp, #12
   18c86:	bdf0      	pop	{r4, r5, r6, r7, pc}
   18c88:	4616      	mov	r6, r2
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
   18c8a:	6850      	ldr	r0, [r2, #4]
   18c8c:	f004 ff92 	bl	1dbb4 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
   18c90:	4607      	mov	r7, r0
   18c92:	b150      	cbz	r0, 18caa <_Command_GatewayAddressSet+0x4e>
    if (TCPIP_Helper_StringToIPAddress(argv[2], &ipGateway))
   18c94:	a901      	add	r1, sp, #4
   18c96:	68b0      	ldr	r0, [r6, #8]
   18c98:	f7fa fc12 	bl	134c0 <TCPIP_Helper_StringToIPAddress>
   18c9c:	b958      	cbnz	r0, 18cb6 <_Command_GatewayAddressSet+0x5a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Invalid IP address string \r\n");
   18c9e:	6823      	ldr	r3, [r4, #0]
   18ca0:	681b      	ldr	r3, [r3, #0]
   18ca2:	490d      	ldr	r1, [pc, #52]	; (18cd8 <_Command_GatewayAddressSet+0x7c>)
   18ca4:	4628      	mov	r0, r5
   18ca6:	4798      	blx	r3
        return false;
   18ca8:	e7eb      	b.n	18c82 <_Command_GatewayAddressSet+0x26>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   18caa:	6823      	ldr	r3, [r4, #0]
   18cac:	681b      	ldr	r3, [r3, #0]
   18cae:	490b      	ldr	r1, [pc, #44]	; (18cdc <_Command_GatewayAddressSet+0x80>)
   18cb0:	4628      	mov	r0, r5
   18cb2:	4798      	blx	r3
        return false;
   18cb4:	e7e5      	b.n	18c82 <_Command_GatewayAddressSet+0x26>
        success = TCPIP_STACK_NetAddressGatewaySet(netH, &ipGateway);
   18cb6:	a901      	add	r1, sp, #4
   18cb8:	4638      	mov	r0, r7
   18cba:	f008 f965 	bl	20f88 <TCPIP_STACK_NetAddressGatewaySet>
    (*pCmdIO->pCmdApi->msg)(cmdIoParam, success ? "Set gateway address OK\r\n" : "Set gateway address failed\r\n");
   18cbe:	6823      	ldr	r3, [r4, #0]
   18cc0:	681b      	ldr	r3, [r3, #0]
   18cc2:	2800      	cmp	r0, #0
   18cc4:	4906      	ldr	r1, [pc, #24]	; (18ce0 <_Command_GatewayAddressSet+0x84>)
   18cc6:	f101 021c 	add.w	r2, r1, #28
   18cca:	bf08      	it	eq
   18ccc:	4611      	moveq	r1, r2
   18cce:	4628      	mov	r0, r5
   18cd0:	4798      	blx	r3
    return false;
   18cd2:	e7d6      	b.n	18c82 <_Command_GatewayAddressSet+0x26>
   18cd4:	0000028c 	.word	0x0000028c
   18cd8:	0000103c 	.word	0x0000103c
   18cdc:	00000da8 	.word	0x00000da8
   18ce0:	00000fa0 	.word	0x00000fa0

Disassembly of section .text._DHCPPacketFilter%393:

00018ce4 <_DHCPPacketFilter>:
{
   18ce4:	b5f0      	push	{r4, r5, r6, r7, lr}
   18ce6:	b083      	sub	sp, #12
   18ce8:	4604      	mov	r4, r0
   18cea:	460f      	mov	r7, r1
    TCPIP_MAC_ADDR bcastAdd = { {0xff, 0xff, 0xff, 0xff, 0xff, 0xff} };
   18cec:	4b1c      	ldr	r3, [pc, #112]	; (18d60 <_DHCPPacketFilter+0x7c>)
   18cee:	e893 0003 	ldmia.w	r3, {r0, r1}
   18cf2:	9000      	str	r0, [sp, #0]
   18cf4:	f8ad 1004 	strh.w	r1, [sp, #4]
    TCPIP_MAC_ETHERNET_HEADER* macHdr = (TCPIP_MAC_ETHERNET_HEADER*)pRxPkt->pMacLayer;
   18cf8:	6966      	ldr	r6, [r4, #20]
    const uint8_t* netMacAddr = TCPIP_STACK_NetUpMACAddressGet((TCPIP_NET_IF*)pRxPkt->pktIf);
   18cfa:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   18cfc:	f008 fe16 	bl	2192c <TCPIP_STACK_NetUpMACAddressGet>
    if(netMacAddr)
   18d00:	b350      	cbz	r0, 18d58 <_DHCPPacketFilter+0x74>
   18d02:	4605      	mov	r5, r0
        if(memcmp(netMacAddr, macHdr->DestMACAddr.v, sizeof(macHdr->DestMACAddr)) == 0 || 
   18d04:	2206      	movs	r2, #6
   18d06:	4631      	mov	r1, r6
   18d08:	f008 fa2c 	bl	21164 <memcmp>
   18d0c:	b128      	cbz	r0, 18d1a <_DHCPPacketFilter+0x36>
           memcmp(netMacAddr, bcastAdd.v, sizeof(bcastAdd)) == 0 )
   18d0e:	2206      	movs	r2, #6
   18d10:	4669      	mov	r1, sp
   18d12:	4628      	mov	r0, r5
   18d14:	f008 fa26 	bl	21164 <memcmp>
        if(memcmp(netMacAddr, macHdr->DestMACAddr.v, sizeof(macHdr->DestMACAddr)) == 0 || 
   18d18:	bb00      	cbnz	r0, 18d5c <_DHCPPacketFilter+0x78>
            IPV4_HEADER* pHeader = (IPV4_HEADER*)pRxPkt->pNetLayer;
   18d1a:	69a3      	ldr	r3, [r4, #24]
            if(pHeader->Protocol == IP_PROT_UDP)
   18d1c:	7a5a      	ldrb	r2, [r3, #9]
   18d1e:	2a11      	cmp	r2, #17
   18d20:	d002      	beq.n	18d28 <_DHCPPacketFilter+0x44>
    return false;
   18d22:	2000      	movs	r0, #0
}
   18d24:	b003      	add	sp, #12
   18d26:	bdf0      	pop	{r4, r5, r6, r7, pc}
                UDP_HEADER* pUDPHdr = (UDP_HEADER*)(pRxPkt->pNetLayer + hdrlen);
   18d28:	19da      	adds	r2, r3, r7
                UDP_PORT destPort = TCPIP_Helper_ntohs(pUDPHdr->DestinationPort);
   18d2a:	8851      	ldrh	r1, [r2, #2]
   18d2c:	0a0a      	lsrs	r2, r1, #8
   18d2e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
                if(destPort == dhcpClientPort && srcPort == dhcpServerPort)
   18d32:	490c      	ldr	r1, [pc, #48]	; (18d64 <_DHCPPacketFilter+0x80>)
   18d34:	8809      	ldrh	r1, [r1, #0]
   18d36:	b292      	uxth	r2, r2
   18d38:	4291      	cmp	r1, r2
   18d3a:	d001      	beq.n	18d40 <_DHCPPacketFilter+0x5c>
    return false;
   18d3c:	2000      	movs	r0, #0
   18d3e:	e7f1      	b.n	18d24 <_DHCPPacketFilter+0x40>
                UDP_PORT srcPort = TCPIP_Helper_ntohs(pUDPHdr->SourcePort);
   18d40:	5bd8      	ldrh	r0, [r3, r7]
   18d42:	0a03      	lsrs	r3, r0, #8
   18d44:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                if(destPort == dhcpClientPort && srcPort == dhcpServerPort)
   18d48:	4a07      	ldr	r2, [pc, #28]	; (18d68 <_DHCPPacketFilter+0x84>)
   18d4a:	8810      	ldrh	r0, [r2, #0]
   18d4c:	b29b      	uxth	r3, r3
   18d4e:	4298      	cmp	r0, r3
   18d50:	bf14      	ite	ne
   18d52:	2000      	movne	r0, #0
   18d54:	2001      	moveq	r0, #1
   18d56:	e7e5      	b.n	18d24 <_DHCPPacketFilter+0x40>
    return false;
   18d58:	2000      	movs	r0, #0
   18d5a:	e7e3      	b.n	18d24 <_DHCPPacketFilter+0x40>
   18d5c:	2000      	movs	r0, #0
   18d5e:	e7e1      	b.n	18d24 <_DHCPPacketFilter+0x40>
   18d60:	0001eb4c 	.word	0x0001eb4c
   18d64:	2000e502 	.word	0x2000e502
   18d68:	2000e506 	.word	0x2000e506

Disassembly of section .text._DHCPSetLeaseTimeParams%394:

00018d6c <_DHCPSetLeaseTimeParams>:
{
   18d6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   18d70:	4606      	mov	r6, r0
    if(pDhcpData == 0 || pDhcpData->leaseTime.Val == 0)
   18d72:	b131      	cbz	r1, 18d82 <_DHCPSetLeaseTimeParams+0x16>
   18d74:	460b      	mov	r3, r1
   18d76:	690d      	ldr	r5, [r1, #16]
   18d78:	b13d      	cbz	r5, 18d8a <_DHCPSetLeaseTimeParams+0x1e>
    if(leaseTime < 2 * TCPIP_DHCP_LEASE_EXPIRE_FUZZ)
   18d7a:	2d14      	cmp	r5, #20
   18d7c:	bf38      	it	cc
   18d7e:	2514      	movcc	r5, #20
   18d80:	e004      	b.n	18d8c <_DHCPSetLeaseTimeParams+0x20>
        t1Time = leaseTime >> 1;
   18d82:	f04f 083c 	mov.w	r8, #60	; 0x3c
        leaseTime = TCPIP_DHCP_LEASE_TIME_DEFAULT;
   18d86:	2578      	movs	r5, #120	; 0x78
   18d88:	e009      	b.n	18d9e <_DHCPSetLeaseTimeParams+0x32>
   18d8a:	2578      	movs	r5, #120	; 0x78
    if(pDhcpData == 0 || pDhcpData->renewTime.Val == 0)
   18d8c:	f8d3 8014 	ldr.w	r8, [r3, #20]
   18d90:	f1b8 0f00 	cmp.w	r8, #0
   18d94:	d101      	bne.n	18d9a <_DHCPSetLeaseTimeParams+0x2e>
        t1Time = leaseTime >> 1;
   18d96:	ea4f 0855 	mov.w	r8, r5, lsr #1
    if(pDhcpData == 0 || pDhcpData->rebindTime.Val == 0)
   18d9a:	699f      	ldr	r7, [r3, #24]
   18d9c:	b947      	cbnz	r7, 18db0 <_DHCPSetLeaseTimeParams+0x44>
        if(leaseTime >= 0xffffffff / 7)
   18d9e:	4b13      	ldr	r3, [pc, #76]	; (18dec <_DHCPSetLeaseTimeParams+0x80>)
   18da0:	429d      	cmp	r5, r3
            t2Time = (leaseTime >> 3) * 7 ;
   18da2:	bf87      	ittee	hi
   18da4:	08ef      	lsrhi	r7, r5, #3
   18da6:	ebc7 07c7 	rsbhi	r7, r7, r7, lsl #3
            t2Time = (leaseTime * 7) >> 3 ;
   18daa:	ebc5 07c5 	rsbls	r7, r5, r5, lsl #3
   18dae:	08ff      	lsrls	r7, r7, #3
   18db0:	f002 f8ec 	bl	1af8c <rand>
    pClient->t1Seconds = (t1Time - TCPIP_DHCP_LEASE_EXPIRE_FUZZ) + SYS_RANDOM_PseudoGet() %  (2 * TCPIP_DHCP_LEASE_EXPIRE_FUZZ);
   18db4:	4c0e      	ldr	r4, [pc, #56]	; (18df0 <_DHCPSetLeaseTimeParams+0x84>)
   18db6:	fba4 2300 	umull	r2, r3, r4, r0
   18dba:	091b      	lsrs	r3, r3, #4
   18dbc:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   18dc0:	eba0 0083 	sub.w	r0, r0, r3, lsl #2
   18dc4:	f1a8 080a 	sub.w	r8, r8, #10
   18dc8:	4440      	add	r0, r8
   18dca:	6130      	str	r0, [r6, #16]
   18dcc:	f002 f8de 	bl	1af8c <rand>
    pClient->t2Seconds = (t2Time - TCPIP_DHCP_LEASE_EXPIRE_FUZZ) + SYS_RANDOM_PseudoGet() %  (2 * TCPIP_DHCP_LEASE_EXPIRE_FUZZ);
   18dd0:	fba4 3400 	umull	r3, r4, r4, r0
   18dd4:	0924      	lsrs	r4, r4, #4
   18dd6:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   18dda:	eba0 0484 	sub.w	r4, r0, r4, lsl #2
   18dde:	3f0a      	subs	r7, #10
   18de0:	443c      	add	r4, r7
   18de2:	6174      	str	r4, [r6, #20]
    pClient->tExpSeconds = leaseTime;
   18de4:	61b5      	str	r5, [r6, #24]
}
   18de6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   18dea:	bf00      	nop
   18dec:	24924923 	.word	0x24924923
   18df0:	cccccccd 	.word	0xcccccccd

Disassembly of section .text._OAHashFindBkt%395:

00018df4 <_OAHashFindBkt>:
// implementation

// finds a entry that either contains the desired key
// or is empty and can be used to insert the key 
static OA_HASH_ENTRY* _OAHashFindBkt(OA_HASH_DCPT* pOH, const void* key)
{
   18df4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   18df8:	4604      	mov	r4, r0
   18dfa:	460f      	mov	r7, r1
    probeStep = pOH->probeStep;
   18dfc:	f8d0 8010 	ldr.w	r8, [r0, #16]
    size_t      probeStep;
    size_t      bkts = 0;

    probeStep = _OAHashProbeStep(pOH, key);
#if defined ( OA_HASH_DYNAMIC_KEY_MANIPULATION )
    bktIx = (*pOH->hashF)(pOH, key);
   18e00:	6943      	ldr	r3, [r0, #20]
   18e02:	4798      	blx	r3
#else
    bktIx = TCPIP_OAHASH_KeyHash(pOH, key);
#endif  // defined ( OA_HASH_DYNAMIC_KEY_MANIPULATION )

    while(bkts < pOH->hEntries)
   18e04:	68e3      	ldr	r3, [r4, #12]
   18e06:	2b00      	cmp	r3, #0
   18e08:	d035      	beq.n	18e76 <_OAHashFindBkt+0x82>
   18e0a:	4605      	mov	r5, r0
    {
        pBkt = (OA_HASH_ENTRY*)((uint8_t*)(pOH->memBlk) + bktIx * pOH->hEntrySize);
   18e0c:	68a3      	ldr	r3, [r4, #8]
   18e0e:	fb03 f300 	mul.w	r3, r3, r0
   18e12:	6822      	ldr	r2, [r4, #0]
   18e14:	eb02 0903 	add.w	r9, r2, r3
        if(pBkt->flags.busy == 0)
   18e18:	5cd3      	ldrb	r3, [r2, r3]
   18e1a:	f013 0f01 	tst.w	r3, #1
   18e1e:	d025      	beq.n	18e6c <_OAHashFindBkt+0x78>
    size_t      bkts = 0;
   18e20:	2600      	movs	r6, #0
            pOH->fullSlots++;
            return pBkt;
        }

#if defined ( OA_HASH_DYNAMIC_KEY_MANIPULATION )
        if((*pOH->cmpF)(pOH, pBkt, key) == 0)
   18e22:	69e3      	ldr	r3, [r4, #28]
   18e24:	463a      	mov	r2, r7
   18e26:	4649      	mov	r1, r9
   18e28:	4620      	mov	r0, r4
   18e2a:	4798      	blx	r3
   18e2c:	b1d8      	cbz	r0, 18e66 <_OAHashFindBkt+0x72>
            return pBkt;
        }
#endif  // defined ( OA_HASH_DYNAMIC_KEY_MANIPULATION )

        // advance to the next hash slot
        bktIx += probeStep;
   18e2e:	4445      	add	r5, r8
        if(bktIx >= pOH->hEntries)
   18e30:	68e3      	ldr	r3, [r4, #12]
   18e32:	42ab      	cmp	r3, r5
        {
            bktIx -= pOH->hEntries;
   18e34:	bf98      	it	ls
   18e36:	1aed      	subls	r5, r5, r3
        }

        bkts++;
   18e38:	3601      	adds	r6, #1
    while(bkts < pOH->hEntries)
   18e3a:	42b3      	cmp	r3, r6
   18e3c:	d918      	bls.n	18e70 <_OAHashFindBkt+0x7c>
        pBkt = (OA_HASH_ENTRY*)((uint8_t*)(pOH->memBlk) + bktIx * pOH->hEntrySize);
   18e3e:	68a3      	ldr	r3, [r4, #8]
   18e40:	fb03 f305 	mul.w	r3, r3, r5
   18e44:	6822      	ldr	r2, [r4, #0]
   18e46:	eb02 0903 	add.w	r9, r2, r3
        if(pBkt->flags.busy == 0)
   18e4a:	5cd3      	ldrb	r3, [r2, r3]
   18e4c:	f013 0f01 	tst.w	r3, #1
   18e50:	d1e7      	bne.n	18e22 <_OAHashFindBkt+0x2e>
            (*pOH->cpyF)(pOH, pBkt, key);   // set the key
   18e52:	6a23      	ldr	r3, [r4, #32]
   18e54:	463a      	mov	r2, r7
   18e56:	4649      	mov	r1, r9
   18e58:	4620      	mov	r0, r4
   18e5a:	4798      	blx	r3
            pBkt->probeCount = bkts;
   18e5c:	f8a9 6002 	strh.w	r6, [r9, #2]
            pOH->fullSlots++;
   18e60:	6a63      	ldr	r3, [r4, #36]	; 0x24
   18e62:	3301      	adds	r3, #1
   18e64:	6263      	str	r3, [r4, #36]	; 0x24
    }
    
    return 0;   // cache full, not found
}
   18e66:	4648      	mov	r0, r9
   18e68:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    size_t      bkts = 0;
   18e6c:	2600      	movs	r6, #0
   18e6e:	e7f0      	b.n	18e52 <_OAHashFindBkt+0x5e>
    return 0;   // cache full, not found
   18e70:	f04f 0900 	mov.w	r9, #0
   18e74:	e7f7      	b.n	18e66 <_OAHashFindBkt+0x72>
   18e76:	f04f 0900 	mov.w	r9, #0
   18e7a:	e7f4      	b.n	18e66 <_OAHashFindBkt+0x72>

Disassembly of section .text.SYS_CMDIO_ADD%396:

00018e7c <SYS_CMDIO_ADD>:
{
   18e7c:	b570      	push	{r4, r5, r6, lr}
   18e7e:	4606      	mov	r6, r0
   18e80:	460d      	mov	r5, r1
    pNewIo = (SYS_CMD_IO_DCPT*)OSAL_Malloc(sizeof(*pNewIo));
   18e82:	f44f 7012 	mov.w	r0, #584	; 0x248
   18e86:	f009 f986 	bl	22196 <OSAL_Malloc>
    if (!pNewIo)
   18e8a:	4604      	mov	r4, r0
   18e8c:	2800      	cmp	r0, #0
   18e8e:	d030      	beq.n	18ef2 <SYS_CMDIO_ADD+0x76>
	memset(pNewIo, 0, sizeof(*pNewIo));
   18e90:	f44f 7212 	mov.w	r2, #584	; 0x248
   18e94:	2100      	movs	r1, #0
   18e96:	f008 fef9 	bl	21c8c <memset>
    pNewIo->devNode.pCmdApi = opApi;
   18e9a:	6026      	str	r6, [r4, #0]
    pNewIo->devNode.cmdIoParam = cmdIoParam;
   18e9c:	6065      	str	r5, [r4, #4]
    pNewIo->cmdPnt = pNewIo->cmdEnd = pNewIo->cmdBuff;
   18e9e:	f104 0320 	add.w	r3, r4, #32
   18ea2:	61e3      	str	r3, [r4, #28]
   18ea4:	61a3      	str	r3, [r4, #24]
    for(ix = 0; ix < sizeof(pNewIo->histArray) / sizeof(*pNewIo->histArray); ix++)
   18ea6:	f104 03d8 	add.w	r3, r4, #216	; 0xd8
   18eaa:	f504 7112 	add.w	r1, r4, #584	; 0x248
   18eae:	e008      	b.n	18ec2 <SYS_CMDIO_ADD+0x46>
        pL->head = pL->tail = pN;
   18eb0:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
   18eb4:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
        pN->next = pN->prev = pN;
   18eb8:	605b      	str	r3, [r3, #4]
   18eba:	601b      	str	r3, [r3, #0]
   18ebc:	335c      	adds	r3, #92	; 0x5c
    for(ix = 0; ix < sizeof(pNewIo->histArray) / sizeof(*pNewIo->histArray); ix++)
   18ebe:	428b      	cmp	r3, r1
   18ec0:	d00e      	beq.n	18ee0 <SYS_CMDIO_ADD+0x64>
    if(pL->head == 0)
   18ec2:	f8d4 20cc 	ldr.w	r2, [r4, #204]	; 0xcc
   18ec6:	2a00      	cmp	r2, #0
   18ec8:	d0f2      	beq.n	18eb0 <SYS_CMDIO_ADD+0x34>
        pN->next = pL->head;
   18eca:	601a      	str	r2, [r3, #0]
        pN->prev = pL->tail;
   18ecc:	f8d4 20d0 	ldr.w	r2, [r4, #208]	; 0xd0
   18ed0:	605a      	str	r2, [r3, #4]
        pL->tail->next = pN;
   18ed2:	6013      	str	r3, [r2, #0]
        pL->head->prev = pN;
   18ed4:	f8d4 20cc 	ldr.w	r2, [r4, #204]	; 0xcc
   18ed8:	6053      	str	r3, [r2, #4]
        pL->head = pN;
   18eda:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
   18ede:	e7ed      	b.n	18ebc <SYS_CMDIO_ADD+0x40>
    pNewIo->next = 0;
   18ee0:	2300      	movs	r3, #0
   18ee2:	60a3      	str	r3, [r4, #8]
    if(cmdIODevList.head == 0)
   18ee4:	4b06      	ldr	r3, [pc, #24]	; (18f00 <SYS_CMDIO_ADD+0x84>)
   18ee6:	681b      	ldr	r3, [r3, #0]
   18ee8:	b12b      	cbz	r3, 18ef6 <SYS_CMDIO_ADD+0x7a>
        cmdIODevList.tail->next = pNewIo;
   18eea:	4b05      	ldr	r3, [pc, #20]	; (18f00 <SYS_CMDIO_ADD+0x84>)
   18eec:	685a      	ldr	r2, [r3, #4]
   18eee:	6094      	str	r4, [r2, #8]
        cmdIODevList.tail = pNewIo;
   18ef0:	605c      	str	r4, [r3, #4]
}
   18ef2:	4620      	mov	r0, r4
   18ef4:	bd70      	pop	{r4, r5, r6, pc}
        cmdIODevList.head = pNewIo;
   18ef6:	4b02      	ldr	r3, [pc, #8]	; (18f00 <SYS_CMDIO_ADD+0x84>)
   18ef8:	601c      	str	r4, [r3, #0]
        cmdIODevList.tail = pNewIo;
   18efa:	605c      	str	r4, [r3, #4]
   18efc:	e7f9      	b.n	18ef2 <SYS_CMDIO_ADD+0x76>
   18efe:	bf00      	nop
   18f00:	2000e360 	.word	0x2000e360

Disassembly of section .text.__pic32c_data_initialization%397:

00018f04 <__pic32c_data_initialization>:
   18f04:	4b1e      	ldr	r3, [pc, #120]	; (18f80 <__pic32c_data_initialization+0x7c>)
   18f06:	4a1f      	ldr	r2, [pc, #124]	; (18f84 <__pic32c_data_initialization+0x80>)
   18f08:	4293      	cmp	r3, r2
   18f0a:	b4f0      	push	{r4, r5, r6, r7}
   18f0c:	bf38      	it	cc
   18f0e:	2100      	movcc	r1, #0
   18f10:	d203      	bcs.n	18f1a <__pic32c_data_initialization+0x16>
   18f12:	f803 1b01 	strb.w	r1, [r3], #1
   18f16:	4293      	cmp	r3, r2
   18f18:	d1fb      	bne.n	18f12 <__pic32c_data_initialization+0xe>
   18f1a:	4a1b      	ldr	r2, [pc, #108]	; (18f88 <__pic32c_data_initialization+0x84>)
   18f1c:	e9d2 0100 	ldrd	r0, r1, [r2]
   18f20:	ea50 0301 	orrs.w	r3, r0, r1
   18f24:	f04f 0600 	mov.w	r6, #0
   18f28:	d010      	beq.n	18f4c <__pic32c_data_initialization+0x48>
   18f2a:	6894      	ldr	r4, [r2, #8]
   18f2c:	4603      	mov	r3, r0
   18f2e:	f102 070c 	add.w	r7, r2, #12
   18f32:	b96c      	cbnz	r4, 18f50 <__pic32c_data_initialization+0x4c>
   18f34:	b121      	cbz	r1, 18f40 <__pic32c_data_initialization+0x3c>
   18f36:	4401      	add	r1, r0
   18f38:	f803 6b01 	strb.w	r6, [r3], #1
   18f3c:	4299      	cmp	r1, r3
   18f3e:	d1fb      	bne.n	18f38 <__pic32c_data_initialization+0x34>
   18f40:	463a      	mov	r2, r7
   18f42:	e9d2 0100 	ldrd	r0, r1, [r2]
   18f46:	ea50 0301 	orrs.w	r3, r0, r1
   18f4a:	d1ee      	bne.n	18f2a <__pic32c_data_initialization+0x26>
   18f4c:	bcf0      	pop	{r4, r5, r6, r7}
   18f4e:	4770      	bx	lr
   18f50:	b159      	cbz	r1, 18f6a <__pic32c_data_initialization+0x66>
   18f52:	f101 030c 	add.w	r3, r1, #12
   18f56:	380c      	subs	r0, #12
   18f58:	1a80      	subs	r0, r0, r2
   18f5a:	441a      	add	r2, r3
   18f5c:	463b      	mov	r3, r7
   18f5e:	181c      	adds	r4, r3, r0
   18f60:	f813 5b01 	ldrb.w	r5, [r3], #1
   18f64:	7025      	strb	r5, [r4, #0]
   18f66:	4293      	cmp	r3, r2
   18f68:	d1f9      	bne.n	18f5e <__pic32c_data_initialization+0x5a>
   18f6a:	f011 0303 	ands.w	r3, r1, #3
   18f6e:	bf18      	it	ne
   18f70:	2301      	movne	r3, #1
   18f72:	eb03 0191 	add.w	r1, r3, r1, lsr #2
   18f76:	eb07 0781 	add.w	r7, r7, r1, lsl #2
   18f7a:	463a      	mov	r2, r7
   18f7c:	e7e1      	b.n	18f42 <__pic32c_data_initialization+0x3e>
   18f7e:	bf00      	nop
   18f80:	20000000 	.word	0x20000000
   18f84:	20000004 	.word	0x20000004
   18f88:	000040b4 	.word	0x000040b4

Disassembly of section .text.TCPIP_IPV4_MacPacketSwitchTxToRx%398:

00018f8c <TCPIP_IPV4_MacPacketSwitchTxToRx>:
//          - the destination addresses is set as the MAC packet source address
//          - the source address is the MAC address of the coresponding packet interface (which should be set!) 
//          - data segment is re-adjusted with the MAC header length
// TCPIP_MAC_PKT_FLAG_TX flag is set
void TCPIP_IPV4_MacPacketSwitchTxToRx(TCPIP_MAC_PACKET* pRxPkt, bool setChecksum, bool setMac)
{
   18f8c:	b570      	push	{r4, r5, r6, lr}
   18f8e:	4605      	mov	r5, r0
   18f90:	4616      	mov	r6, r2
    IPV4_HEADER* pIpv4Hdr;

    pIpv4Hdr = (IPV4_HEADER*)pRxPkt->pNetLayer;
   18f92:	6984      	ldr	r4, [r0, #24]
    pIpv4Hdr->DestAddress.Val = pIpv4Hdr->SourceAddress.Val;
   18f94:	68e3      	ldr	r3, [r4, #12]
   18f96:	6123      	str	r3, [r4, #16]
    return pNetIf->netIPAddr.Val;
   18f98:	6a83      	ldr	r3, [r0, #40]	; 0x28
   18f9a:	685b      	ldr	r3, [r3, #4]
    pIpv4Hdr->SourceAddress.Val = _TCPIPStackNetAddress((TCPIP_NET_IF*)pRxPkt->pktIf);
   18f9c:	60e3      	str	r3, [r4, #12]

    pIpv4Hdr->TotalLength = TCPIP_Helper_htons(pIpv4Hdr->TotalLength);
   18f9e:	8862      	ldrh	r2, [r4, #2]
   18fa0:	0a13      	lsrs	r3, r2, #8
   18fa2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   18fa6:	8063      	strh	r3, [r4, #2]
    pIpv4Hdr->FragmentInfo.val = TCPIP_Helper_htons(pIpv4Hdr->FragmentInfo.val);
   18fa8:	88e2      	ldrh	r2, [r4, #6]
   18faa:	0a13      	lsrs	r3, r2, #8
   18fac:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   18fb0:	80e3      	strh	r3, [r4, #6]
    if(pIpv4Hdr->TimeToLive == 0)
   18fb2:	7a23      	ldrb	r3, [r4, #8]
   18fb4:	b90b      	cbnz	r3, 18fba <TCPIP_IPV4_MacPacketSwitchTxToRx+0x2e>
    {
        pIpv4Hdr->TimeToLive = IPV4_DEFAULT_TTL;
   18fb6:	2364      	movs	r3, #100	; 0x64
   18fb8:	7223      	strb	r3, [r4, #8]
    }
    uint8_t headerLen = pIpv4Hdr->IHL << 2;  
    pRxPkt->pDSeg->segLen += headerLen;
   18fba:	6928      	ldr	r0, [r5, #16]
    uint8_t headerLen = pIpv4Hdr->IHL << 2;  
   18fbc:	7823      	ldrb	r3, [r4, #0]
   18fbe:	009b      	lsls	r3, r3, #2
    pRxPkt->pDSeg->segLen += headerLen;
   18fc0:	f003 033c 	and.w	r3, r3, #60	; 0x3c
   18fc4:	8982      	ldrh	r2, [r0, #12]
   18fc6:	441a      	add	r2, r3
   18fc8:	8182      	strh	r2, [r0, #12]

    if(setChecksum)
   18fca:	b929      	cbnz	r1, 18fd8 <TCPIP_IPV4_MacPacketSwitchTxToRx+0x4c>
    {
        pIpv4Hdr->HeaderChecksum = 0;
        pIpv4Hdr->HeaderChecksum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pIpv4Hdr, headerLen, 0);
    }

    if(setMac)
   18fcc:	b966      	cbnz	r6, 18fe8 <TCPIP_IPV4_MacPacketSwitchTxToRx+0x5c>
        memcpy(&macHdr->SourceMACAddr, _TCPIPStack_NetMACAddressGet((TCPIP_NET_IF*)pRxPkt->pktIf), sizeof(TCPIP_MAC_ADDR));

        pRxPkt->pDSeg->segLen += sizeof(TCPIP_MAC_ETHERNET_HEADER);
    }

    pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_TX; 
   18fce:	8c6b      	ldrh	r3, [r5, #34]	; 0x22
   18fd0:	f043 0302 	orr.w	r3, r3, #2
   18fd4:	846b      	strh	r3, [r5, #34]	; 0x22
}
   18fd6:	bd70      	pop	{r4, r5, r6, pc}
        pIpv4Hdr->HeaderChecksum = 0;
   18fd8:	2200      	movs	r2, #0
   18fda:	8162      	strh	r2, [r4, #10]
        pIpv4Hdr->HeaderChecksum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pIpv4Hdr, headerLen, 0);
   18fdc:	4619      	mov	r1, r3
   18fde:	4620      	mov	r0, r4
   18fe0:	f001 fb04 	bl	1a5ec <TCPIP_Helper_CalcIPChecksum>
   18fe4:	8160      	strh	r0, [r4, #10]
   18fe6:	e7f1      	b.n	18fcc <TCPIP_IPV4_MacPacketSwitchTxToRx+0x40>
        macHdr = (TCPIP_MAC_ETHERNET_HEADER*)pRxPkt->pMacLayer;
   18fe8:	6969      	ldr	r1, [r5, #20]
        memcpy(&macHdr->DestMACAddr, &macHdr->SourceMACAddr, sizeof(TCPIP_MAC_ADDR));
   18fea:	460a      	mov	r2, r1
   18fec:	f852 3f06 	ldr.w	r3, [r2, #6]!
   18ff0:	600b      	str	r3, [r1, #0]
   18ff2:	8893      	ldrh	r3, [r2, #4]
   18ff4:	808b      	strh	r3, [r1, #4]
        memcpy(&macHdr->SourceMACAddr, _TCPIPStack_NetMACAddressGet((TCPIP_NET_IF*)pRxPkt->pktIf), sizeof(TCPIP_MAC_ADDR));
   18ff6:	6aab      	ldr	r3, [r5, #40]	; 0x28
    return pNetIf ? pNetIf->netMACAddr.v : 0;
   18ff8:	b103      	cbz	r3, 18ffc <TCPIP_IPV4_MacPacketSwitchTxToRx+0x70>
   18ffa:	333c      	adds	r3, #60	; 0x3c
   18ffc:	6818      	ldr	r0, [r3, #0]
   18ffe:	f8c1 0006 	str.w	r0, [r1, #6]
   19002:	889b      	ldrh	r3, [r3, #4]
   19004:	8093      	strh	r3, [r2, #4]
        pRxPkt->pDSeg->segLen += sizeof(TCPIP_MAC_ETHERNET_HEADER);
   19006:	692a      	ldr	r2, [r5, #16]
   19008:	8993      	ldrh	r3, [r2, #12]
   1900a:	330e      	adds	r3, #14
   1900c:	8193      	strh	r3, [r2, #12]
   1900e:	e7de      	b.n	18fce <TCPIP_IPV4_MacPacketSwitchTxToRx+0x42>

Disassembly of section .text.TCPIP_STACK_NetAddressSet%399:

00019010 <TCPIP_STACK_NetAddressSet>:
{
   19010:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   19014:	4604      	mov	r4, r0
   19016:	460f      	mov	r7, r1
   19018:	4690      	mov	r8, r2
   1901a:	4699      	mov	r9, r3
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1901c:	2000      	movs	r0, #0
   1901e:	f008 facd 	bl	215bc <OSAL_CRIT_Enter>
   19022:	4605      	mov	r5, r0
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   19024:	b124      	cbz	r4, 19030 <TCPIP_STACK_NetAddressSet+0x20>
   19026:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   1902a:	f013 0f40 	tst.w	r3, #64	; 0x40
   1902e:	d105      	bne.n	1903c <TCPIP_STACK_NetAddressSet+0x2c>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   19030:	4629      	mov	r1, r5
   19032:	2000      	movs	r0, #0
   19034:	f008 fbf1 	bl	2181a <OSAL_CRIT_Leave>
   19038:	2600      	movs	r6, #0
   1903a:	e028      	b.n	1908e <TCPIP_STACK_NetAddressSet+0x7e>
    if(pNetIf != 0 && TCPIP_STACK_AddressServiceCanStart(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_NONE))
   1903c:	2100      	movs	r1, #0
   1903e:	4620      	mov	r0, r4
   19040:	f008 fbd5 	bl	217ee <TCPIP_STACK_AddressServiceCanStart>
   19044:	4606      	mov	r6, r0
   19046:	2800      	cmp	r0, #0
   19048:	d0f2      	beq.n	19030 <TCPIP_STACK_NetAddressSet+0x20>
    if(ipAddress)
   1904a:	b16f      	cbz	r7, 19068 <TCPIP_STACK_NetAddressSet+0x58>
        pNetIf->netIPAddr.Val = ipAddress->Val;
   1904c:	683b      	ldr	r3, [r7, #0]
   1904e:	6063      	str	r3, [r4, #4]
        if(setDefault)
   19050:	f1b9 0f00 	cmp.w	r9, #0
   19054:	d008      	beq.n	19068 <TCPIP_STACK_NetAddressSet+0x58>
            pNetIf->DefaultIPAddr.Val = ipAddress->Val;
   19056:	61a3      	str	r3, [r4, #24]
    if(mask)
   19058:	f1b8 0f00 	cmp.w	r8, #0
   1905c:	d00d      	beq.n	1907a <TCPIP_STACK_NetAddressSet+0x6a>
        pNetIf->netMask.Val = mask->Val;
   1905e:	f8d8 3000 	ldr.w	r3, [r8]
   19062:	60a3      	str	r3, [r4, #8]
            pNetIf->DefaultMask.Val = mask->Val;
   19064:	61e3      	str	r3, [r4, #28]
   19066:	e008      	b.n	1907a <TCPIP_STACK_NetAddressSet+0x6a>
    if(mask)
   19068:	f1b8 0f00 	cmp.w	r8, #0
   1906c:	d005      	beq.n	1907a <TCPIP_STACK_NetAddressSet+0x6a>
        pNetIf->netMask.Val = mask->Val;
   1906e:	f8d8 3000 	ldr.w	r3, [r8]
   19072:	60a3      	str	r3, [r4, #8]
        if(setDefault)
   19074:	f1b9 0f00 	cmp.w	r9, #0
   19078:	d1f4      	bne.n	19064 <TCPIP_STACK_NetAddressSet+0x54>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1907a:	4629      	mov	r1, r5
   1907c:	2000      	movs	r0, #0
   1907e:	f008 fbcc 	bl	2181a <OSAL_CRIT_Leave>
    pNetIf->Flags.bInConfig = config;
   19082:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   19086:	f36f 1304 	bfc	r3, #4, #1
   1908a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
}
   1908e:	4630      	mov	r0, r6
   19090:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

Disassembly of section .text._TCPIP_PKT_PacketAlloc%400:

00019094 <_TCPIP_PKT_PacketAlloc>:

#else
// regular allocation functions, non-debug
// they don't take a module Id parameter; otherwise exactly the same functions
TCPIP_MAC_PACKET* _TCPIP_PKT_PacketAlloc(uint16_t pktLen, uint16_t segLoadLen, TCPIP_MAC_PACKET_FLAGS flags)
{
   19094:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   19098:	4688      	mov	r8, r1
   1909a:	4617      	mov	r7, r2
    if(pktLen < sizeof(TCPIP_MAC_PACKET))
    {
        pktLen = sizeof(TCPIP_MAC_PACKET);
    }

    pktUpLen = (((pktLen + 3) >> 2) << 2);     // 32 bits round up
   1909c:	2834      	cmp	r0, #52	; 0x34
   1909e:	bf38      	it	cc
   190a0:	2034      	movcc	r0, #52	; 0x34
   190a2:	1cc3      	adds	r3, r0, #3
   190a4:	f023 0303 	bic.w	r3, r3, #3
   190a8:	b29c      	uxth	r4, r3
    // segment size, multiple of cache line size
    segAlignSize = ((segLoadLen + sizeof(TCPIP_MAC_ETHERNET_HEADER) + TCPIP_SEGMENT_CACHE_ALIGN_SIZE  - 1) / TCPIP_SEGMENT_CACHE_ALIGN_SIZE) * TCPIP_SEGMENT_CACHE_ALIGN_SIZE;
   190aa:	f101 051d 	add.w	r5, r1, #29
   190ae:	f025 050f 	bic.w	r5, r5, #15
   190b2:	b2ad      	uxth	r5, r5
    // segment allocation size, extra cache line so that the segBuffer can start on a cache line boundary
    segAllocSize = segAlignSize + _TCPIP_MAC_DATA_SEGMENT_GAP_SIZE + TCPIP_MAC_PAYLOAD_OFFSET + TCPIP_SEGMENT_CACHE_ALIGN_SIZE; 
    // total allocation size
    allocLen = pktUpLen + sizeof(*pSeg) + segAllocSize;

    pPkt = (TCPIP_MAC_PACKET*)TCPIP_HEAP_Malloc(pktMemH, allocLen);
   190b4:	4b17      	ldr	r3, [pc, #92]	; (19114 <_TCPIP_PKT_PacketAlloc+0x80>)
   190b6:	6818      	ldr	r0, [r3, #0]
    allocLen = pktUpLen + sizeof(*pSeg) + segAllocSize;
   190b8:	f105 0132 	add.w	r1, r5, #50	; 0x32
   190bc:	4421      	add	r1, r4
    pPkt = (TCPIP_MAC_PACKET*)TCPIP_HEAP_Malloc(pktMemH, allocLen);
   190be:	b289      	uxth	r1, r1
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
   190c0:	6843      	ldr	r3, [r0, #4]
   190c2:	4798      	blx	r3

    if(pPkt)
   190c4:	4606      	mov	r6, r0
   190c6:	b308      	cbz	r0, 1910c <_TCPIP_PKT_PacketAlloc+0x78>
    {   
        // clear the TCPIP_MAC_PACKET and 1st segment fields
        // populate the 1st segment
        memset(pPkt, 0, pktUpLen + sizeof(*pSeg));
   190c8:	f104 0218 	add.w	r2, r4, #24
   190cc:	2100      	movs	r1, #0
   190ce:	f008 fddd 	bl	21c8c <memset>
        pSeg = (TCPIP_MAC_DATA_SEGMENT*)((uint8_t*)pPkt + pktUpLen);
   190d2:	4434      	add	r4, r6

        pSeg->segSize = segAlignSize;
   190d4:	81e5      	strh	r5, [r4, #14]
    segAllocSize = segAlignSize + _TCPIP_MAC_DATA_SEGMENT_GAP_SIZE + TCPIP_MAC_PAYLOAD_OFFSET + TCPIP_SEGMENT_CACHE_ALIGN_SIZE; 
   190d6:	351a      	adds	r5, #26
        pSeg->segAllocSize = segAllocSize;
   190d8:	8265      	strh	r5, [r4, #18]
        pSeg->segBuffer = (uint8_t*)(pSeg + 1) + _TCPIP_MAC_DATA_SEGMENT_GAP_SIZE;
        // cache-align the data segment
        pSeg->segBuffer = (uint8_t*)((((uint32_t)pSeg->segBuffer + TCPIP_SEGMENT_CACHE_ALIGN_SIZE - 1) / TCPIP_SEGMENT_CACHE_ALIGN_SIZE) * TCPIP_SEGMENT_CACHE_ALIGN_SIZE);
   190da:	f104 022f 	add.w	r2, r4, #47	; 0x2f
   190de:	f022 020f 	bic.w	r2, r2, #15
   190e2:	6062      	str	r2, [r4, #4]
        // set the pointer to the packet that segment belongs to
        TCPIP_MAC_SEGMENT_GAP_DCPT* pGap = (TCPIP_MAC_SEGMENT_GAP_DCPT*)(pSeg->segBuffer + _TCPIP_MAC_GAP_OFFSET);
        pGap->segmentPktPtr = pPkt;
   190e4:	f842 6c08 	str.w	r6, [r2, #-8]

        pSeg->segFlags = TCPIP_MAC_SEG_FLAG_STATIC; // embedded in TCPIP_MAC_PACKET itself
   190e8:	2201      	movs	r2, #1
   190ea:	8222      	strh	r2, [r4, #16]
        pPkt->pDSeg = pSeg;
   190ec:	6134      	str	r4, [r6, #16]

        pSeg->segLoad = pSeg->segBuffer + TCPIP_MAC_PAYLOAD_OFFSET;
   190ee:	6862      	ldr	r2, [r4, #4]
   190f0:	1c91      	adds	r1, r2, #2
   190f2:	60a1      	str	r1, [r4, #8]
        pPkt->pMacLayer = pSeg->segLoad;
   190f4:	6171      	str	r1, [r6, #20]
        pPkt->pktFlags = flags & (~TCPIP_MAC_PKT_FLAG_STATIC);  // this packet is dynamically allocated
   190f6:	f027 0701 	bic.w	r7, r7, #1
   190fa:	8477      	strh	r7, [r6, #34]	; 0x22
        if(segLoadLen)
   190fc:	f1b8 0f00 	cmp.w	r8, #0
   19100:	d001      	beq.n	19106 <_TCPIP_PKT_PacketAlloc+0x72>
        {
            pPkt->pNetLayer = pPkt->pMacLayer + sizeof(TCPIP_MAC_ETHERNET_HEADER);
   19102:	3210      	adds	r2, #16
   19104:	61b2      	str	r2, [r6, #24]
        }
        pPkt->pktPriority = 0; // set the default priority
   19106:	2300      	movs	r3, #0
   19108:	f886 302d 	strb.w	r3, [r6, #45]	; 0x2d

    }

    return pPkt;
}
   1910c:	4630      	mov	r0, r6
   1910e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   19112:	bf00      	nop
   19114:	2000e450 	.word	0x2000e450

Disassembly of section .text.DRV_PIC32CGMAC_LibTxAckErrPacket%401:

00019118 <DRV_PIC32CGMAC_LibTxAckErrPacket>:
{
   19118:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1911c:	b083      	sub	sp, #12
    DRV_PIC32CGMAC_HW_TXDCPT *pTxDesc = pMACDrv->sGmacData.gmac_queue[queueIdx].pTxDesc;
   1911e:	4688      	mov	r8, r1
   19120:	232c      	movs	r3, #44	; 0x2c
   19122:	fb03 0101 	mla	r1, r3, r1, r0
   19126:	f8d1 70a0 	ldr.w	r7, [r1, #160]	; 0xa0
	uint16_t tailIndex = pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail;
   1912a:	f8b1 40b4 	ldrh.w	r4, [r1, #180]	; 0xb4
	uint16_t headIndex = pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescHead;
   1912e:	f8b1 90b2 	ldrh.w	r9, [r1, #178]	; 0xb2
	while(tailIndex != headIndex)
   19132:	454c      	cmp	r4, r9
   19134:	d02e      	beq.n	19194 <DRV_PIC32CGMAC_LibTxAckErrPacket+0x7c>
   19136:	9201      	str	r2, [sp, #4]
   19138:	4606      	mov	r6, r0
        (pMACDrv->sGmacData.pktAckF)(pPkt, ackRes, TCPIP_THIS_MODULE_ID);	
   1913a:	f241 0b50 	movw	fp, #4176	; 0x1050
        pTxDesc[tailIndex].tx_desc_buffaddr = 0;
   1913e:	f04f 0a00 	mov.w	sl, #0
        GCIRC_INC(tailIndex, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt);  
   19142:	eb08 08c8 	add.w	r8, r8, r8, lsl #3
   19146:	eb00 0848 	add.w	r8, r0, r8, lsl #1
        pbuff = (uint8_t*)((uint32_t)pTxDesc[tailIndex].tx_desc_buffaddr & pMACDrv->sGmacData._dataOffsetMask);
   1914a:	eb07 05c4 	add.w	r5, r7, r4, lsl #3
   1914e:	f857 3034 	ldr.w	r3, [r7, r4, lsl #3]
   19152:	f8d6 20f0 	ldr.w	r2, [r6, #240]	; 0xf0
   19156:	4013      	ands	r3, r2
        TCPIP_MAC_SEGMENT_GAP_DCPT* pGap = (TCPIP_MAC_SEGMENT_GAP_DCPT*)(pbuff + pMACDrv->sGmacData._dcptOffset);
   19158:	f9b6 20ec 	ldrsh.w	r2, [r6, #236]	; 0xec
        pPkt = pGap->segmentPktPtr;
   1915c:	5898      	ldr	r0, [r3, r2]
        pPkt->pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED;
   1915e:	8c43      	ldrh	r3, [r0, #34]	; 0x22
   19160:	f023 0308 	bic.w	r3, r3, #8
   19164:	8443      	strh	r3, [r0, #34]	; 0x22
        (pMACDrv->sGmacData.pktAckF)(pPkt, ackRes, TCPIP_THIS_MODULE_ID);	
   19166:	6af3      	ldr	r3, [r6, #44]	; 0x2c
   19168:	465a      	mov	r2, fp
   1916a:	9901      	ldr	r1, [sp, #4]
   1916c:	4798      	blx	r3
        pTxDesc[tailIndex].tx_desc_status.val &= GMAC_TX_WRAP_BIT;
   1916e:	686b      	ldr	r3, [r5, #4]
   19170:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
   19174:	606b      	str	r3, [r5, #4]
        pTxDesc[tailIndex].tx_desc_status.val |= GMAC_TX_USED_BIT | GMAC_TX_LAST_BUFFER_BIT;
   19176:	686b      	ldr	r3, [r5, #4]
   19178:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
   1917c:	606b      	str	r3, [r5, #4]
        pTxDesc[tailIndex].tx_desc_buffaddr = 0;
   1917e:	f847 a034 	str.w	sl, [r7, r4, lsl #3]
        GCIRC_INC(tailIndex, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt);  
   19182:	3401      	adds	r4, #1
   19184:	b2a4      	uxth	r4, r4
   19186:	f8b8 30c8 	ldrh.w	r3, [r8, #200]	; 0xc8
   1918a:	42a3      	cmp	r3, r4
   1918c:	bf98      	it	ls
   1918e:	2400      	movls	r4, #0
	while(tailIndex != headIndex)
   19190:	454c      	cmp	r4, r9
   19192:	d1da      	bne.n	1914a <DRV_PIC32CGMAC_LibTxAckErrPacket+0x32>
}
   19194:	b003      	add	sp, #12
   19196:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

Disassembly of section .text._DNS_ValidateIf%402:

0001919a <_DNS_ValidateIf>:
{
   1919a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1919c:	4604      	mov	r4, r0
   1919e:	460d      	mov	r5, r1
   191a0:	4616      	mov	r6, r2
    if(_DNS_NetIsValid(pIf))
   191a2:	f005 fc05 	bl	1e9b0 <_DNS_NetIsValid>
   191a6:	4607      	mov	r7, r0
   191a8:	b1a8      	cbz	r0, 191d6 <_DNS_ValidateIf+0x3c>
        if(pDnsHE->currNet == pIf)
   191aa:	69eb      	ldr	r3, [r5, #28]
   191ac:	42a3      	cmp	r3, r4
   191ae:	d014      	beq.n	191da <_DNS_ValidateIf+0x40>
            startIx = 0;
   191b0:	2000      	movs	r0, #0
            if(pIf->dnsServer[ix].Val != 0)
   191b2:	1d03      	adds	r3, r0, #4
   191b4:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
   191b8:	bb73      	cbnz	r3, 19218 <_DNS_ValidateIf+0x7e>
   191ba:	1d42      	adds	r2, r0, #5
   191bc:	eb04 0282 	add.w	r2, r4, r2, lsl #2
   191c0:	4603      	mov	r3, r0
        for(ix = startIx; ix < sizeof(pIf->dnsServer) / sizeof(*pIf->dnsServer); ix++)
   191c2:	3301      	adds	r3, #1
   191c4:	2b01      	cmp	r3, #1
   191c6:	d80f      	bhi.n	191e8 <_DNS_ValidateIf+0x4e>
            if(pIf->dnsServer[ix].Val != 0)
   191c8:	f852 1b04 	ldr.w	r1, [r2], #4
   191cc:	2900      	cmp	r1, #0
   191ce:	d0f8      	beq.n	191c2 <_DNS_ValidateIf+0x28>
            pDnsHE->currNet = pIf;
   191d0:	61ec      	str	r4, [r5, #28]
            pDnsHE->currServerIx = ix;
   191d2:	f885 3029 	strb.w	r3, [r5, #41]	; 0x29
}
   191d6:	4638      	mov	r0, r7
   191d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            startIx = (pDnsHE->currRetry == 0) ? pDnsHE->currServerIx : pDnsHE->currServerIx + 1;
   191da:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
   191de:	b933      	cbnz	r3, 191ee <_DNS_ValidateIf+0x54>
   191e0:	f895 0029 	ldrb.w	r0, [r5, #41]	; 0x29
        for(ix = startIx; ix < sizeof(pIf->dnsServer) / sizeof(*pIf->dnsServer); ix++)
   191e4:	2801      	cmp	r0, #1
   191e6:	d9e4      	bls.n	191b2 <_DNS_ValidateIf+0x18>
        if(!srvFound && wrapAround) 
   191e8:	b92e      	cbnz	r6, 191f6 <_DNS_ValidateIf+0x5c>
    return false;
   191ea:	4637      	mov	r7, r6
   191ec:	e7f3      	b.n	191d6 <_DNS_ValidateIf+0x3c>
            startIx = (pDnsHE->currRetry == 0) ? pDnsHE->currServerIx : pDnsHE->currServerIx + 1;
   191ee:	f895 0029 	ldrb.w	r0, [r5, #41]	; 0x29
   191f2:	3001      	adds	r0, #1
   191f4:	e7f6      	b.n	191e4 <_DNS_ValidateIf+0x4a>
            for(ix = 0; ix < startIx; ix++)
   191f6:	b138      	cbz	r0, 19208 <_DNS_ValidateIf+0x6e>
                if(pIf->dnsServer[ix].Val != 0)
   191f8:	6923      	ldr	r3, [r4, #16]
   191fa:	b94b      	cbnz	r3, 19210 <_DNS_ValidateIf+0x76>
            for(ix = 0; ix < startIx; ix++)
   191fc:	2801      	cmp	r0, #1
   191fe:	dd05      	ble.n	1920c <_DNS_ValidateIf+0x72>
                if(pIf->dnsServer[ix].Val != 0)
   19200:	6963      	ldr	r3, [r4, #20]
   19202:	b93b      	cbnz	r3, 19214 <_DNS_ValidateIf+0x7a>
    return false;
   19204:	2700      	movs	r7, #0
   19206:	e7e6      	b.n	191d6 <_DNS_ValidateIf+0x3c>
   19208:	2700      	movs	r7, #0
   1920a:	e7e4      	b.n	191d6 <_DNS_ValidateIf+0x3c>
   1920c:	2700      	movs	r7, #0
   1920e:	e7e2      	b.n	191d6 <_DNS_ValidateIf+0x3c>
            for(ix = 0; ix < startIx; ix++)
   19210:	2300      	movs	r3, #0
   19212:	e7dd      	b.n	191d0 <_DNS_ValidateIf+0x36>
   19214:	2301      	movs	r3, #1
   19216:	e7db      	b.n	191d0 <_DNS_ValidateIf+0x36>
            if(pIf->dnsServer[ix].Val != 0)
   19218:	4603      	mov	r3, r0
        if(!srvFound && wrapAround) 
   1921a:	e7d9      	b.n	191d0 <_DNS_ValidateIf+0x36>

Disassembly of section .text.TCPIP_Helper_PacketChecksum%403:

0001921c <TCPIP_Helper_PacketChecksum>:
    uint8_t* pChkBuff;
    uint16_t checkLength, chkBytes, nBytes;
    uint16_t segChkSum;
    uint32_t calcChkSum;

    if(len == 0)
   1921c:	b90a      	cbnz	r2, 19222 <TCPIP_Helper_PacketChecksum+0x6>
        }
#endif  // defined(TCPIP_IPV4_FRAGMENTATION) && (TCPIP_IPV4_FRAGMENTATION != 0)
    }

    return ~TCPIP_Helper_ChecksumFold(calcChkSum);
}
   1921e:	4618      	mov	r0, r3
   19220:	4770      	bx	lr
{
   19222:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   19226:	460f      	mov	r7, r1
   19228:	4616      	mov	r6, r2
    calcChkSum = seed;
   1922a:	4698      	mov	r8, r3
    pSeg = TCPIP_PKT_DataSegmentGet(pPkt, startAdd, true);
   1922c:	2201      	movs	r2, #1
   1922e:	f001 f8c3 	bl	1a3b8 <TCPIP_PKT_DataSegmentGet>
    while(pSeg != 0 && checkLength != 0)
   19232:	4605      	mov	r5, r0
   19234:	b358      	cbz	r0, 1928e <TCPIP_Helper_PacketChecksum+0x72>
    nBytes = 0;
   19236:	f04f 0900 	mov.w	r9, #0
            segChkSum = ~TCPIP_Helper_CalcIPChecksum(pChkBuff, chkBytes, 0);
   1923a:	46ca      	mov	sl, r9
   1923c:	e009      	b.n	19252 <TCPIP_Helper_PacketChecksum+0x36>
            checkLength -= chkBytes;
   1923e:	1b36      	subs	r6, r6, r4
   19240:	b2b6      	uxth	r6, r6
            nBytes += chkBytes;
   19242:	44a1      	add	r9, r4
   19244:	fa1f f989 	uxth.w	r9, r9
            calcChkSum += segChkSum;
   19248:	4480      	add	r8, r0
        if((pSeg = pSeg->next) != 0)
   1924a:	682d      	ldr	r5, [r5, #0]
   1924c:	b1fd      	cbz	r5, 1928e <TCPIP_Helper_PacketChecksum+0x72>
            pChkBuff = pSeg->segLoad;
   1924e:	68af      	ldr	r7, [r5, #8]
    while(pSeg != 0 && checkLength != 0)
   19250:	b1ee      	cbz	r6, 1928e <TCPIP_Helper_PacketChecksum+0x72>
        chkBytes = (pSeg->segLoad + pSeg->segSize) - pChkBuff;
   19252:	89eb      	ldrh	r3, [r5, #14]
   19254:	68ac      	ldr	r4, [r5, #8]
   19256:	441c      	add	r4, r3
   19258:	1be4      	subs	r4, r4, r7
   1925a:	b2a4      	uxth	r4, r4
        if( pSeg->segLen && (chkBytes > pSeg->segLen) )
   1925c:	89ab      	ldrh	r3, [r5, #12]
   1925e:	b113      	cbz	r3, 19266 <TCPIP_Helper_PacketChecksum+0x4a>
   19260:	429c      	cmp	r4, r3
   19262:	bf28      	it	cs
   19264:	461c      	movcs	r4, r3
        if(chkBytes > checkLength)
   19266:	42b4      	cmp	r4, r6
   19268:	bf28      	it	cs
   1926a:	4634      	movcs	r4, r6
        if(chkBytes)
   1926c:	2c00      	cmp	r4, #0
   1926e:	d0ec      	beq.n	1924a <TCPIP_Helper_PacketChecksum+0x2e>
            segChkSum = ~TCPIP_Helper_CalcIPChecksum(pChkBuff, chkBytes, 0);
   19270:	4652      	mov	r2, sl
   19272:	4621      	mov	r1, r4
   19274:	4638      	mov	r0, r7
   19276:	f001 f9b9 	bl	1a5ec <TCPIP_Helper_CalcIPChecksum>
   1927a:	43c0      	mvns	r0, r0
   1927c:	b280      	uxth	r0, r0
            if((nBytes & 0x1) != 0)
   1927e:	f019 0f01 	tst.w	r9, #1
   19282:	d0dc      	beq.n	1923e <TCPIP_Helper_PacketChecksum+0x22>
   19284:	0a03      	lsrs	r3, r0, #8
   19286:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
   1928a:	b280      	uxth	r0, r0
   1928c:	e7d7      	b.n	1923e <TCPIP_Helper_PacketChecksum+0x22>
    return ~TCPIP_Helper_ChecksumFold(calcChkSum);
   1928e:	4640      	mov	r0, r8
   19290:	f008 fd3a 	bl	21d08 <TCPIP_Helper_ChecksumFold>
   19294:	43c0      	mvns	r0, r0
   19296:	b283      	uxth	r3, r0
}
   19298:	4618      	mov	r0, r3
   1929a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

Disassembly of section .text.__fputwc%404:

0001929e <__fputwc>:
   1929e:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   192a2:	4680      	mov	r8, r0
   192a4:	460e      	mov	r6, r1
   192a6:	4614      	mov	r4, r2
   192a8:	f008 ff02 	bl	220b0 <__locale_mb_cur_max>
   192ac:	2801      	cmp	r0, #1
   192ae:	d10e      	bne.n	192ce <__fputwc+0x30>
   192b0:	1e73      	subs	r3, r6, #1
   192b2:	2bfe      	cmp	r3, #254	; 0xfe
   192b4:	d80b      	bhi.n	192ce <__fputwc+0x30>
   192b6:	f88d 6004 	strb.w	r6, [sp, #4]
   192ba:	4605      	mov	r5, r0
   192bc:	2700      	movs	r7, #0
   192be:	f10d 0904 	add.w	r9, sp, #4
   192c2:	42af      	cmp	r7, r5
   192c4:	d113      	bne.n	192ee <__fputwc+0x50>
   192c6:	4630      	mov	r0, r6
   192c8:	b003      	add	sp, #12
   192ca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   192ce:	4632      	mov	r2, r6
   192d0:	f104 0358 	add.w	r3, r4, #88	; 0x58
   192d4:	a901      	add	r1, sp, #4
   192d6:	4640      	mov	r0, r8
   192d8:	f006 fc40 	bl	1fb5c <_wcrtomb_r>
   192dc:	1c42      	adds	r2, r0, #1
   192de:	4605      	mov	r5, r0
   192e0:	d1ec      	bne.n	192bc <__fputwc+0x1e>
   192e2:	89a3      	ldrh	r3, [r4, #12]
   192e4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   192e8:	81a3      	strh	r3, [r4, #12]
   192ea:	4606      	mov	r6, r0
   192ec:	e7eb      	b.n	192c6 <__fputwc+0x28>
   192ee:	68a3      	ldr	r3, [r4, #8]
   192f0:	f817 1009 	ldrb.w	r1, [r7, r9]
   192f4:	3b01      	subs	r3, #1
   192f6:	2b00      	cmp	r3, #0
   192f8:	60a3      	str	r3, [r4, #8]
   192fa:	da04      	bge.n	19306 <__fputwc+0x68>
   192fc:	69a2      	ldr	r2, [r4, #24]
   192fe:	4293      	cmp	r3, r2
   19300:	db07      	blt.n	19312 <__fputwc+0x74>
   19302:	290a      	cmp	r1, #10
   19304:	d005      	beq.n	19312 <__fputwc+0x74>
   19306:	6823      	ldr	r3, [r4, #0]
   19308:	1c5a      	adds	r2, r3, #1
   1930a:	6022      	str	r2, [r4, #0]
   1930c:	7019      	strb	r1, [r3, #0]
   1930e:	3701      	adds	r7, #1
   19310:	e7d7      	b.n	192c2 <__fputwc+0x24>
   19312:	4622      	mov	r2, r4
   19314:	4640      	mov	r0, r8
   19316:	f7fd f99b 	bl	16650 <__swbuf_r>
   1931a:	1c43      	adds	r3, r0, #1
   1931c:	d1f7      	bne.n	1930e <__fputwc+0x70>
   1931e:	e7e4      	b.n	192ea <__fputwc+0x4c>

Disassembly of section .text.DRV_ETHPHY_VendorSMIReadStart%405:

00019320 <DRV_ETHPHY_VendorSMIReadStart>:
}



DRV_ETHPHY_RESULT DRV_ETHPHY_VendorSMIReadStart( DRV_HANDLE handle, uint16_t rIx,  int phyAddress )
{
   19320:	b538      	push	{r3, r4, r5, lr}
    DRV_ETHPHY_SMI_TXFER_RES opRes;
    DRV_ETHPHY_CLIENT_OBJ * hClientObj = (DRV_ETHPHY_CLIENT_OBJ *) handle;

    if(hClientObj == 0 || _DRVHandleToInst(hClientObj->hDriver) == 0)
   19322:	b340      	cbz	r0, 19376 <DRV_ETHPHY_VendorSMIReadStart+0x56>
   19324:	4604      	mov	r4, r0
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   19326:	68c3      	ldr	r3, [r0, #12]
   19328:	481c      	ldr	r0, [pc, #112]	; (1939c <DRV_ETHPHY_VendorSMIReadStart+0x7c>)
   1932a:	4283      	cmp	r3, r0
   1932c:	d126      	bne.n	1937c <DRV_ETHPHY_VendorSMIReadStart+0x5c>
    {
        return DRV_ETHPHY_RES_HANDLE_ERR;
    }
    
    if( hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_BUSY || 
   1932e:	f994 5008 	ldrsb.w	r5, [r4, #8]
   19332:	2d01      	cmp	r5, #1
   19334:	d126      	bne.n	19384 <DRV_ETHPHY_VendorSMIReadStart+0x64>
   19336:	8ba0      	ldrh	r0, [r4, #28]
   19338:	2801      	cmp	r0, #1
   1933a:	d126      	bne.n	1938a <DRV_ETHPHY_VendorSMIReadStart+0x6a>
        hClientObj->operType != DRV_ETHPHY_CLIENT_OP_TYPE_SETUP || 
   1933c:	8be0      	ldrh	r0, [r4, #30]
   1933e:	f020 0002 	bic.w	r0, r0, #2
   19342:	b280      	uxth	r0, r0
   19344:	2801      	cmp	r0, #1
   19346:	d002      	beq.n	1934e <DRV_ETHPHY_VendorSMIReadStart+0x2e>
        (hClientObj->operPhase != DRV_ETHPHY_SETUP_PHASE_DETECT && hClientObj->operPhase != DRV_ETHPHY_SETUP_PHASE_NEGOTIATE))
    {   // not allowed
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   19348:	f06f 0509 	mvn.w	r5, #9
   1934c:	e018      	b.n	19380 <DRV_ETHPHY_VendorSMIReadStart+0x60>
    }

    if(hClientObj->smiTxferStatus != DRV_ETHPHY_SMI_TXFER_OP_NONE)
   1934e:	8ea0      	ldrh	r0, [r4, #52]	; 0x34
   19350:	b9f0      	cbnz	r0, 19390 <DRV_ETHPHY_VendorSMIReadStart+0x70>
    hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_START;
   19352:	2301      	movs	r3, #1
   19354:	86a3      	strh	r3, [r4, #52]	; 0x34
    hClientObj->smiRIx = rIx;
   19356:	8721      	strh	r1, [r4, #56]	; 0x38
    hClientObj->smiTxferType = DRV_ETHPHY_SMI_XFER_TYPE_READ;
   19358:	2303      	movs	r3, #3
   1935a:	86e3      	strh	r3, [r4, #54]	; 0x36
    hClientObj->smiPhyAddress = phyAdd;
   1935c:	63e2      	str	r2, [r4, #60]	; 0x3c
    return _DRV_PHY_SMITransferStart(hClientObj);
   1935e:	4620      	mov	r0, r4
   19360:	f7fe fc9e 	bl	17ca0 <_DRV_PHY_SMITransferStart>
        return DRV_ETHPHY_RES_OPERATION_ERR;
    }


    opRes = _DRV_PHY_SMIReadStartEx(hClientObj, rIx, phyAddress);
    if(opRes < 0)
   19364:	2800      	cmp	r0, #0
   19366:	db16      	blt.n	19396 <DRV_ETHPHY_VendorSMIReadStart+0x76>
    {   // error occurred 
        return DRV_ETHPHY_RES_OPERATION_ERR;
    }
    else if(opRes == DRV_ETHPHY_SMI_TXFER_RES_BUSY)
   19368:	2803      	cmp	r0, #3
   1936a:	d001      	beq.n	19370 <DRV_ETHPHY_VendorSMIReadStart+0x50>
        hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
        return DRV_ETHPHY_RES_PENDING;
    } 

    // went through
    return DRV_ETHPHY_RES_OK;
   1936c:	2500      	movs	r5, #0
   1936e:	e007      	b.n	19380 <DRV_ETHPHY_VendorSMIReadStart+0x60>
        hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
   19370:	2300      	movs	r3, #0
   19372:	86a3      	strh	r3, [r4, #52]	; 0x34
        return DRV_ETHPHY_RES_PENDING;
   19374:	e004      	b.n	19380 <DRV_ETHPHY_VendorSMIReadStart+0x60>
        return DRV_ETHPHY_RES_HANDLE_ERR;
   19376:	f06f 050a 	mvn.w	r5, #10
   1937a:	e001      	b.n	19380 <DRV_ETHPHY_VendorSMIReadStart+0x60>
   1937c:	f06f 050a 	mvn.w	r5, #10
}
   19380:	4628      	mov	r0, r5
   19382:	bd38      	pop	{r3, r4, r5, pc}
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   19384:	f06f 0509 	mvn.w	r5, #9
   19388:	e7fa      	b.n	19380 <DRV_ETHPHY_VendorSMIReadStart+0x60>
   1938a:	f06f 0509 	mvn.w	r5, #9
   1938e:	e7f7      	b.n	19380 <DRV_ETHPHY_VendorSMIReadStart+0x60>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   19390:	f06f 0508 	mvn.w	r5, #8
   19394:	e7f4      	b.n	19380 <DRV_ETHPHY_VendorSMIReadStart+0x60>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   19396:	f06f 0508 	mvn.w	r5, #8
   1939a:	e7f1      	b.n	19380 <DRV_ETHPHY_VendorSMIReadStart+0x60>
   1939c:	2000de18 	.word	0x2000de18

Disassembly of section .text.DRV_ETHPHY_VendorSMIWriteStart%406:

000193a0 <DRV_ETHPHY_VendorSMIWriteStart>:
{
    DRV_ETHPHY_RESULT phyRes;
    DRV_ETHPHY_SMI_TXFER_RES opRes;
    DRV_ETHPHY_CLIENT_OBJ * hClientObj = (DRV_ETHPHY_CLIENT_OBJ *) handle;

    if(hClientObj == 0 || _DRVHandleToInst(hClientObj->hDriver) == 0)
   193a0:	b348      	cbz	r0, 193f6 <DRV_ETHPHY_VendorSMIWriteStart+0x56>
{
   193a2:	b538      	push	{r3, r4, r5, lr}
   193a4:	4604      	mov	r4, r0
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   193a6:	68c5      	ldr	r5, [r0, #12]
   193a8:	481c      	ldr	r0, [pc, #112]	; (1941c <DRV_ETHPHY_VendorSMIWriteStart+0x7c>)
   193aa:	4285      	cmp	r5, r0
   193ac:	d126      	bne.n	193fc <DRV_ETHPHY_VendorSMIWriteStart+0x5c>
    {
        return DRV_ETHPHY_RES_HANDLE_ERR;
    }

    
    if( hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_BUSY || 
   193ae:	f994 0008 	ldrsb.w	r0, [r4, #8]
   193b2:	2801      	cmp	r0, #1
   193b4:	d125      	bne.n	19402 <DRV_ETHPHY_VendorSMIWriteStart+0x62>
   193b6:	8ba0      	ldrh	r0, [r4, #28]
   193b8:	2801      	cmp	r0, #1
   193ba:	d125      	bne.n	19408 <DRV_ETHPHY_VendorSMIWriteStart+0x68>
        hClientObj->operType != DRV_ETHPHY_CLIENT_OP_TYPE_SETUP || 
   193bc:	8be0      	ldrh	r0, [r4, #30]
   193be:	f020 0002 	bic.w	r0, r0, #2
   193c2:	b280      	uxth	r0, r0
   193c4:	2801      	cmp	r0, #1
   193c6:	d002      	beq.n	193ce <DRV_ETHPHY_VendorSMIWriteStart+0x2e>
        (hClientObj->operPhase != DRV_ETHPHY_SETUP_PHASE_DETECT && hClientObj->operPhase != DRV_ETHPHY_SETUP_PHASE_NEGOTIATE))
    {   // not allowed
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   193c8:	f06f 0009 	mvn.w	r0, #9
   193cc:	e018      	b.n	19400 <DRV_ETHPHY_VendorSMIWriteStart+0x60>
    }

    if(hClientObj->smiTxferStatus != DRV_ETHPHY_SMI_TXFER_OP_NONE)
   193ce:	8ea0      	ldrh	r0, [r4, #52]	; 0x34
   193d0:	b9e8      	cbnz	r0, 1940e <DRV_ETHPHY_VendorSMIWriteStart+0x6e>
    hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_START;
   193d2:	2001      	movs	r0, #1
   193d4:	86a0      	strh	r0, [r4, #52]	; 0x34
    hClientObj->smiRIx = rIx;
   193d6:	8721      	strh	r1, [r4, #56]	; 0x38
    hClientObj->smiTxferType = DRV_ETHPHY_SMI_XFER_TYPE_WRITE;
   193d8:	86e0      	strh	r0, [r4, #54]	; 0x36
    hClientObj->smiData =  wData;
   193da:	8762      	strh	r2, [r4, #58]	; 0x3a
    hClientObj->smiPhyAddress = phyAdd;
   193dc:	63e3      	str	r3, [r4, #60]	; 0x3c
   return  _DRV_PHY_SMITransferStart(hClientObj);
   193de:	4620      	mov	r0, r4
   193e0:	f7fe fc5e 	bl	17ca0 <_DRV_PHY_SMITransferStart>
    {   // calling this before the previous SMI done?
        return DRV_ETHPHY_RES_OPERATION_ERR;
    }

    opRes = _DRV_PHY_SMIWriteStartEx(hClientObj, rIx, wData, phyAddress);
    if(opRes < 0)
   193e4:	2800      	cmp	r0, #0
   193e6:	db15      	blt.n	19414 <DRV_ETHPHY_VendorSMIWriteStart+0x74>
        return DRV_ETHPHY_RES_OPERATION_ERR;
    }

    if(opRes == DRV_ETHPHY_SMI_TXFER_RES_BUSY)
    {   // retry
        phyRes = DRV_ETHPHY_RES_PENDING;
   193e8:	2803      	cmp	r0, #3
   193ea:	bf14      	ite	ne
   193ec:	2000      	movne	r0, #0
   193ee:	2001      	moveq	r0, #1
    else
    {   // went through
        phyRes = DRV_ETHPHY_RES_OK;
    }

    hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
   193f0:	2300      	movs	r3, #0
   193f2:	86a3      	strh	r3, [r4, #52]	; 0x34


    return phyRes;
   193f4:	e004      	b.n	19400 <DRV_ETHPHY_VendorSMIWriteStart+0x60>
        return DRV_ETHPHY_RES_HANDLE_ERR;
   193f6:	f06f 000a 	mvn.w	r0, #10

}
   193fa:	4770      	bx	lr
        return DRV_ETHPHY_RES_HANDLE_ERR;
   193fc:	f06f 000a 	mvn.w	r0, #10
}
   19400:	bd38      	pop	{r3, r4, r5, pc}
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   19402:	f06f 0009 	mvn.w	r0, #9
   19406:	e7fb      	b.n	19400 <DRV_ETHPHY_VendorSMIWriteStart+0x60>
   19408:	f06f 0009 	mvn.w	r0, #9
   1940c:	e7f8      	b.n	19400 <DRV_ETHPHY_VendorSMIWriteStart+0x60>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   1940e:	f06f 0008 	mvn.w	r0, #8
   19412:	e7f5      	b.n	19400 <DRV_ETHPHY_VendorSMIWriteStart+0x60>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   19414:	f06f 0008 	mvn.w	r0, #8
   19418:	e7f2      	b.n	19400 <DRV_ETHPHY_VendorSMIWriteStart+0x60>
   1941a:	bf00      	nop
   1941c:	2000de18 	.word	0x2000de18

Disassembly of section .text.SERCOM1_USART_Initialize%407:

00019420 <SERCOM1_USART_Initialize>:
    SERCOM1_REGS->USART_INT.SERCOM_CTRLA = SERCOM_USART_INT_CTRLA_MODE_USART_INT_CLK | SERCOM_USART_INT_CTRLA_RXPO(0x1UL) | SERCOM_USART_INT_CTRLA_TXPO(0x0UL) | SERCOM_USART_INT_CTRLA_DORD_Msk | SERCOM_USART_INT_CTRLA_IBON_Msk | SERCOM_USART_INT_CTRLA_FORM(0x0UL) | SERCOM_USART_INT_CTRLA_SAMPR(0UL) ;
   19420:	4b1c      	ldr	r3, [pc, #112]	; (19494 <SERCOM1_USART_Initialize+0x74>)
   19422:	4a1d      	ldr	r2, [pc, #116]	; (19498 <SERCOM1_USART_Initialize+0x78>)
   19424:	601a      	str	r2, [r3, #0]
    SERCOM1_REGS->USART_INT.SERCOM_BAUD = (uint16_t)SERCOM_USART_INT_BAUD_BAUD(SERCOM1_USART_INT_BAUD_VALUE);
   19426:	f64f 0222 	movw	r2, #63522	; 0xf822
   1942a:	819a      	strh	r2, [r3, #12]
    SERCOM1_REGS->USART_INT.SERCOM_CTRLB = SERCOM_USART_INT_CTRLB_CHSIZE_8_BIT | SERCOM_USART_INT_CTRLB_SBMODE_1_BIT | SERCOM_USART_INT_CTRLB_RXEN_Msk | SERCOM_USART_INT_CTRLB_TXEN_Msk;
   1942c:	f44f 3240 	mov.w	r2, #196608	; 0x30000
   19430:	605a      	str	r2, [r3, #4]
    while((SERCOM1_REGS->USART_INT.SERCOM_SYNCBUSY) != 0U)
   19432:	461a      	mov	r2, r3
   19434:	69d3      	ldr	r3, [r2, #28]
   19436:	2b00      	cmp	r3, #0
   19438:	d1fc      	bne.n	19434 <SERCOM1_USART_Initialize+0x14>
    SERCOM1_REGS->USART_INT.SERCOM_CTRLA |= SERCOM_USART_INT_CTRLA_ENABLE_Msk;
   1943a:	4a16      	ldr	r2, [pc, #88]	; (19494 <SERCOM1_USART_Initialize+0x74>)
   1943c:	6813      	ldr	r3, [r2, #0]
   1943e:	f043 0302 	orr.w	r3, r3, #2
   19442:	6013      	str	r3, [r2, #0]
    while((SERCOM1_REGS->USART_INT.SERCOM_SYNCBUSY) != 0U)
   19444:	69d3      	ldr	r3, [r2, #28]
   19446:	2b00      	cmp	r3, #0
   19448:	d1fc      	bne.n	19444 <SERCOM1_USART_Initialize+0x24>
    sercom1USARTObj.rdCallback = NULL;
   1944a:	4b14      	ldr	r3, [pc, #80]	; (1949c <SERCOM1_USART_Initialize+0x7c>)
   1944c:	2200      	movs	r2, #0
   1944e:	621a      	str	r2, [r3, #32]
    sercom1USARTObj.rdInIndex = 0U;
   19450:	629a      	str	r2, [r3, #40]	; 0x28
    sercom1USARTObj.rdOutIndex = 0U;
   19452:	62da      	str	r2, [r3, #44]	; 0x2c
    sercom1USARTObj.isRdNotificationEnabled = false;
   19454:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    sercom1USARTObj.isRdNotifyPersistently = false;
   19458:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    sercom1USARTObj.rdThreshold = 0U;
   1945c:	639a      	str	r2, [r3, #56]	; 0x38
    sercom1USARTObj.errorStatus = USART_ERROR_NONE;
   1945e:	87da      	strh	r2, [r3, #62]	; 0x3e
    sercom1USARTObj.wrCallback = NULL;
   19460:	601a      	str	r2, [r3, #0]
    sercom1USARTObj.wrInIndex = 0U;
   19462:	609a      	str	r2, [r3, #8]
    sercom1USARTObj.wrOutIndex = 0U;
   19464:	60da      	str	r2, [r3, #12]
    sercom1USARTObj.isWrNotificationEnabled = false;
   19466:	751a      	strb	r2, [r3, #20]
    sercom1USARTObj.isWrNotifyPersistently = false;
   19468:	771a      	strb	r2, [r3, #28]
    sercom1USARTObj.wrThreshold = 0U;
   1946a:	619a      	str	r2, [r3, #24]
    if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   1946c:	4b09      	ldr	r3, [pc, #36]	; (19494 <SERCOM1_USART_Initialize+0x74>)
   1946e:	685b      	ldr	r3, [r3, #4]
   19470:	f003 0307 	and.w	r3, r3, #7
   19474:	2b01      	cmp	r3, #1
        sercom1USARTObj.rdBufferSize = SERCOM1_USART_READ_BUFFER_SIZE;
   19476:	4b09      	ldr	r3, [pc, #36]	; (1949c <SERCOM1_USART_Initialize+0x7c>)
   19478:	bf14      	ite	ne
   1947a:	f44f 5280 	movne.w	r2, #4096	; 0x1000
        sercom1USARTObj.rdBufferSize = SERCOM1_USART_READ_BUFFER_9BIT_SIZE;
   1947e:	f44f 6200 	moveq.w	r2, #2048	; 0x800
   19482:	631a      	str	r2, [r3, #48]	; 0x30
        sercom1USARTObj.wrBufferSize = SERCOM1_USART_WRITE_BUFFER_9BIT_SIZE;
   19484:	611a      	str	r2, [r3, #16]
    SERCOM1_REGS->USART_INT.SERCOM_INTENSET = (uint8_t)SERCOM_USART_INT_INTENSET_ERROR_Msk;
   19486:	4b03      	ldr	r3, [pc, #12]	; (19494 <SERCOM1_USART_Initialize+0x74>)
   19488:	2280      	movs	r2, #128	; 0x80
   1948a:	759a      	strb	r2, [r3, #22]
    SERCOM1_REGS->USART_INT.SERCOM_INTENSET = (uint8_t)SERCOM_USART_INT_INTENSET_RXC_Msk;
   1948c:	2204      	movs	r2, #4
   1948e:	759a      	strb	r2, [r3, #22]
}
   19490:	4770      	bx	lr
   19492:	bf00      	nop
   19494:	40003400 	.word	0x40003400
   19498:	40100104 	.word	0x40100104
   1949c:	2000dff0 	.word	0x2000dff0

Disassembly of section .text.SendCommandPrint%408:

000194a0 <SendCommandPrint>:
{
   194a0:	b40e      	push	{r1, r2, r3}
   194a2:	b530      	push	{r4, r5, lr}
   194a4:	f6ad 2d08 	subw	sp, sp, #2568	; 0xa08
   194a8:	f60d 2314 	addw	r3, sp, #2580	; 0xa14
   194ac:	f853 2b04 	ldr.w	r2, [r3], #4
    va_start( args, format );
   194b0:	9301      	str	r3, [sp, #4]
    len = vsnprintf(tmpBuf, SYS_CMD_PRINT_BUFFER_SIZE, format, args);
   194b2:	f44f 6120 	mov.w	r1, #2560	; 0xa00
   194b6:	a802      	add	r0, sp, #8
   194b8:	f007 fe7e 	bl	211b8 <vsniprintf>
    if (len > 0 && len < SYS_CMD_PRINT_BUFFER_SIZE)
   194bc:	1e42      	subs	r2, r0, #1
   194be:	f640 13fe 	movw	r3, #2558	; 0x9fe
   194c2:	429a      	cmp	r2, r3
   194c4:	d821      	bhi.n	1950a <SendCommandPrint+0x6a>
   194c6:	4604      	mov	r4, r0
        tmpBuf[len] = '\0';
   194c8:	ab02      	add	r3, sp, #8
   194ca:	2200      	movs	r2, #0
   194cc:	541a      	strb	r2, [r3, r0]
        if (len + printBuffPtr >= SYS_CMD_PRINT_BUFFER_SIZE)
   194ce:	4b12      	ldr	r3, [pc, #72]	; (19518 <SendCommandPrint+0x78>)
   194d0:	681b      	ldr	r3, [r3, #0]
   194d2:	4403      	add	r3, r0
   194d4:	f5b3 6f20 	cmp.w	r3, #2560	; 0xa00
            printBuffPtr = 0;
   194d8:	bf24      	itt	cs
   194da:	4b0f      	ldrcs	r3, [pc, #60]	; (19518 <SendCommandPrint+0x78>)
   194dc:	601a      	strcs	r2, [r3, #0]
        strcpy(&printBuff[printBuffPtr], tmpBuf);
   194de:	4b0e      	ldr	r3, [pc, #56]	; (19518 <SendCommandPrint+0x78>)
   194e0:	681b      	ldr	r3, [r3, #0]
   194e2:	4d0e      	ldr	r5, [pc, #56]	; (1951c <SendCommandPrint+0x7c>)
   194e4:	441d      	add	r5, r3
   194e6:	a902      	add	r1, sp, #8
   194e8:	4628      	mov	r0, r5
   194ea:	f008 fbd7 	bl	21c9c <strcpy>
        SendCommandMessage(NULL, &printBuff[printBuffPtr]);
   194ee:	4629      	mov	r1, r5
   194f0:	2000      	movs	r0, #0
   194f2:	f007 fdb9 	bl	21068 <SendCommandMessage>
        if (padding > 0)
   194f6:	f014 0203 	ands.w	r2, r4, #3
            padding = 4 - padding;
   194fa:	bf18      	it	ne
   194fc:	f1c2 0204 	rsbne	r2, r2, #4
        printBuffPtr += len + padding;
   19500:	4b05      	ldr	r3, [pc, #20]	; (19518 <SendCommandPrint+0x78>)
   19502:	6819      	ldr	r1, [r3, #0]
   19504:	440c      	add	r4, r1
   19506:	4414      	add	r4, r2
   19508:	601c      	str	r4, [r3, #0]
}
   1950a:	f60d 2d08 	addw	sp, sp, #2568	; 0xa08
   1950e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   19512:	b003      	add	sp, #12
   19514:	4770      	bx	lr
   19516:	bf00      	nop
   19518:	2000e470 	.word	0x2000e470
   1951c:	2000c004 	.word	0x2000c004

Disassembly of section .text.xTaskPriorityDisinherit%409:

00019520 <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
   19520:	2800      	cmp	r0, #0
   19522:	d035      	beq.n	19590 <xTaskPriorityDisinherit+0x70>
	{
   19524:	b538      	push	{r3, r4, r5, lr}
   19526:	4604      	mov	r4, r0
			( pxTCB->uxMutexesHeld )--;
   19528:	6c82      	ldr	r2, [r0, #72]	; 0x48
   1952a:	3a01      	subs	r2, #1
   1952c:	6482      	str	r2, [r0, #72]	; 0x48
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   1952e:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   19530:	6c61      	ldr	r1, [r4, #68]	; 0x44
   19532:	4288      	cmp	r0, r1
   19534:	d02e      	beq.n	19594 <xTaskPriorityDisinherit+0x74>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   19536:	b10a      	cbz	r2, 1953c <xTaskPriorityDisinherit+0x1c>
	BaseType_t xReturn = pdFALSE;
   19538:	2000      	movs	r0, #0
	}
   1953a:	bd38      	pop	{r3, r4, r5, pc}
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   1953c:	1d25      	adds	r5, r4, #4
   1953e:	4628      	mov	r0, r5
   19540:	f007 f858 	bl	205f4 <uxListRemove>
   19544:	b970      	cbnz	r0, 19564 <xTaskPriorityDisinherit+0x44>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   19546:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   19548:	eb02 0382 	add.w	r3, r2, r2, lsl #2
   1954c:	009b      	lsls	r3, r3, #2
   1954e:	4912      	ldr	r1, [pc, #72]	; (19598 <xTaskPriorityDisinherit+0x78>)
   19550:	58cb      	ldr	r3, [r1, r3]
   19552:	b93b      	cbnz	r3, 19564 <xTaskPriorityDisinherit+0x44>
   19554:	4811      	ldr	r0, [pc, #68]	; (1959c <xTaskPriorityDisinherit+0x7c>)
   19556:	6803      	ldr	r3, [r0, #0]
   19558:	2101      	movs	r1, #1
   1955a:	fa01 f202 	lsl.w	r2, r1, r2
   1955e:	ea23 0202 	bic.w	r2, r3, r2
   19562:	6002      	str	r2, [r0, #0]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
   19564:	6c60      	ldr	r0, [r4, #68]	; 0x44
   19566:	62e0      	str	r0, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   19568:	f1c0 0305 	rsb	r3, r0, #5
   1956c:	61a3      	str	r3, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
   1956e:	4a0b      	ldr	r2, [pc, #44]	; (1959c <xTaskPriorityDisinherit+0x7c>)
   19570:	6811      	ldr	r1, [r2, #0]
   19572:	2401      	movs	r4, #1
   19574:	fa04 f300 	lsl.w	r3, r4, r0
   19578:	430b      	orrs	r3, r1
   1957a:	6013      	str	r3, [r2, #0]
   1957c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   19580:	4629      	mov	r1, r5
   19582:	4b05      	ldr	r3, [pc, #20]	; (19598 <xTaskPriorityDisinherit+0x78>)
   19584:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   19588:	f008 f95d 	bl	21846 <vListInsertEnd>
					xReturn = pdTRUE;
   1958c:	4620      	mov	r0, r4
   1958e:	e7d4      	b.n	1953a <xTaskPriorityDisinherit+0x1a>
	BaseType_t xReturn = pdFALSE;
   19590:	2000      	movs	r0, #0
	}
   19592:	4770      	bx	lr
	BaseType_t xReturn = pdFALSE;
   19594:	2000      	movs	r0, #0
   19596:	e7d0      	b.n	1953a <xTaskPriorityDisinherit+0x1a>
   19598:	2000de80 	.word	0x2000de80
   1959c:	2000e4b8 	.word	0x2000e4b8

Disassembly of section .text.vTaskPriorityDisinheritAfterTimeout%410:

000195a0 <vTaskPriorityDisinheritAfterTimeout>:
		if( pxMutexHolder != NULL )
   195a0:	2800      	cmp	r0, #0
   195a2:	d038      	beq.n	19616 <vTaskPriorityDisinheritAfterTimeout+0x76>
	{
   195a4:	b538      	push	{r3, r4, r5, lr}
   195a6:	4604      	mov	r4, r0
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
   195a8:	6c42      	ldr	r2, [r0, #68]	; 0x44
   195aa:	4291      	cmp	r1, r2
   195ac:	bf38      	it	cc
   195ae:	4611      	movcc	r1, r2
			if( pxTCB->uxPriority != uxPriorityToUse )
   195b0:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   195b2:	428a      	cmp	r2, r1
   195b4:	d002      	beq.n	195bc <vTaskPriorityDisinheritAfterTimeout+0x1c>
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
   195b6:	6c80      	ldr	r0, [r0, #72]	; 0x48
   195b8:	2801      	cmp	r0, #1
   195ba:	d000      	beq.n	195be <vTaskPriorityDisinheritAfterTimeout+0x1e>
	}
   195bc:	bd38      	pop	{r3, r4, r5, pc}
					pxTCB->uxPriority = uxPriorityToUse;
   195be:	62e1      	str	r1, [r4, #44]	; 0x2c
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   195c0:	69a0      	ldr	r0, [r4, #24]
   195c2:	2800      	cmp	r0, #0
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   195c4:	bfa4      	itt	ge
   195c6:	f1c1 0105 	rsbge	r1, r1, #5
   195ca:	61a1      	strge	r1, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
   195cc:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   195d0:	4911      	ldr	r1, [pc, #68]	; (19618 <vTaskPriorityDisinheritAfterTimeout+0x78>)
   195d2:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   195d6:	6961      	ldr	r1, [r4, #20]
   195d8:	4291      	cmp	r1, r2
   195da:	d1ef      	bne.n	195bc <vTaskPriorityDisinheritAfterTimeout+0x1c>
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   195dc:	1d25      	adds	r5, r4, #4
   195de:	4628      	mov	r0, r5
   195e0:	f007 f808 	bl	205f4 <uxListRemove>
   195e4:	b938      	cbnz	r0, 195f6 <vTaskPriorityDisinheritAfterTimeout+0x56>
							portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
   195e6:	490d      	ldr	r1, [pc, #52]	; (1961c <vTaskPriorityDisinheritAfterTimeout+0x7c>)
   195e8:	680b      	ldr	r3, [r1, #0]
   195ea:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   195ec:	2201      	movs	r2, #1
   195ee:	4082      	lsls	r2, r0
   195f0:	ea23 0302 	bic.w	r3, r3, r2
   195f4:	600b      	str	r3, [r1, #0]
						prvAddTaskToReadyList( pxTCB );
   195f6:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   195f8:	4a08      	ldr	r2, [pc, #32]	; (1961c <vTaskPriorityDisinheritAfterTimeout+0x7c>)
   195fa:	6811      	ldr	r1, [r2, #0]
   195fc:	2301      	movs	r3, #1
   195fe:	4083      	lsls	r3, r0
   19600:	430b      	orrs	r3, r1
   19602:	6013      	str	r3, [r2, #0]
   19604:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   19608:	4629      	mov	r1, r5
   1960a:	4b03      	ldr	r3, [pc, #12]	; (19618 <vTaskPriorityDisinheritAfterTimeout+0x78>)
   1960c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   19610:	f008 f919 	bl	21846 <vListInsertEnd>
	}
   19614:	e7d2      	b.n	195bc <vTaskPriorityDisinheritAfterTimeout+0x1c>
   19616:	4770      	bx	lr
   19618:	2000de80 	.word	0x2000de80
   1961c:	2000e4b8 	.word	0x2000e4b8

Disassembly of section .rodata.outputA_data%411:

00019620 <outputA_data>:
   19620:	3bc6ee04 2cdf31b2 fb1a0a63 9d9424e7     ...;.1.,c....$..
   19630:	78585a00 79aae151 4773475e 6256b0c8     .ZXxQ..y^GsG..Vb
   19640:	dcbd181c fc998ddd 20b9c25f accfd853     ........_.. S...
   19650:	83b80bfb d1fa0512 71c0d6dd 18608a31     ...........q1.`.
   19660:	f5733bf0 d0d4e4ed 03def971 10ea7afd     .;s.....q....z..
   19670:	b899925d 07aa99af b94ddb5b 8dc128aa     ].......[.M..(..
   19680:	ee564b17 094d012a 22ff9688 a855c982     .KV.*.M...."..U.
   19690:	69e06919 07e08cfa 3a1880a1 17aedf07     .i.i.......:....

Disassembly of section .rodata.outputB_data%412:

000196a0 <outputB_data>:
   196a0:	c360e1d3 40f3995b 648262b2 601075d1     ..`.[..@.b.d.u.`
   196b0:	a35d04e0 a557ff83 73a6737d 0dd8b8d2     ..]...W.}s.s....
   196c0:	c3a6f6aa 45bb915a d03fd779 11d1fec8     ....Z..Ey.?.....
   196d0:	061339b0 eddf8a82 81018f52 bdfeb321     .9......R...!...
   196e0:	97e743c3 63bb7db8 de3313db e1ecd1d9     .C...}.c..3.....
   196f0:	b7a6cf77 1dabe81f ed2466a4 1ce51564     w........f$.d...
   19700:	cac7e2cd 9983e286 91ebea0e 52150412     ...............R
   19710:	9195228b 2db08102 c9f431d4 df2704f7     .".....-.1....'.

Disassembly of section .text.prvUnlockQueue%413:

00019720 <prvUnlockQueue>:
{
   19720:	b570      	push	{r4, r5, r6, lr}
   19722:	4605      	mov	r5, r0
	taskENTER_CRITICAL();
   19724:	f007 fa94 	bl	20c50 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
   19728:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
   1972c:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
   1972e:	2c00      	cmp	r4, #0
   19730:	dd11      	ble.n	19756 <prvUnlockQueue+0x36>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   19732:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   19734:	b17b      	cbz	r3, 19756 <prvUnlockQueue+0x36>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   19736:	f105 0624 	add.w	r6, r5, #36	; 0x24
   1973a:	e006      	b.n	1974a <prvUnlockQueue+0x2a>
						vTaskMissedYield();
   1973c:	f008 fc9a 	bl	22074 <vTaskMissedYield>
			--cTxLock;
   19740:	3c01      	subs	r4, #1
   19742:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
   19744:	b13c      	cbz	r4, 19756 <prvUnlockQueue+0x36>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   19746:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   19748:	b12b      	cbz	r3, 19756 <prvUnlockQueue+0x36>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1974a:	4630      	mov	r0, r6
   1974c:	f000 fd14 	bl	1a178 <xTaskRemoveFromEventList>
   19750:	2800      	cmp	r0, #0
   19752:	d0f5      	beq.n	19740 <prvUnlockQueue+0x20>
   19754:	e7f2      	b.n	1973c <prvUnlockQueue+0x1c>
		pxQueue->cTxLock = queueUNLOCKED;
   19756:	23ff      	movs	r3, #255	; 0xff
   19758:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	taskEXIT_CRITICAL();
   1975c:	f008 f940 	bl	219e0 <vPortExitCritical>
	taskENTER_CRITICAL();
   19760:	f007 fa76 	bl	20c50 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
   19764:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
   19768:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
   1976a:	2c00      	cmp	r4, #0
   1976c:	dd11      	ble.n	19792 <prvUnlockQueue+0x72>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1976e:	692b      	ldr	r3, [r5, #16]
   19770:	b17b      	cbz	r3, 19792 <prvUnlockQueue+0x72>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   19772:	f105 0610 	add.w	r6, r5, #16
   19776:	e006      	b.n	19786 <prvUnlockQueue+0x66>
					vTaskMissedYield();
   19778:	f008 fc7c 	bl	22074 <vTaskMissedYield>
				--cRxLock;
   1977c:	3c01      	subs	r4, #1
   1977e:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
   19780:	b13c      	cbz	r4, 19792 <prvUnlockQueue+0x72>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   19782:	692b      	ldr	r3, [r5, #16]
   19784:	b12b      	cbz	r3, 19792 <prvUnlockQueue+0x72>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   19786:	4630      	mov	r0, r6
   19788:	f000 fcf6 	bl	1a178 <xTaskRemoveFromEventList>
   1978c:	2800      	cmp	r0, #0
   1978e:	d0f5      	beq.n	1977c <prvUnlockQueue+0x5c>
   19790:	e7f2      	b.n	19778 <prvUnlockQueue+0x58>
		pxQueue->cRxLock = queueUNLOCKED;
   19792:	23ff      	movs	r3, #255	; 0xff
   19794:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	taskEXIT_CRITICAL();
   19798:	f008 f922 	bl	219e0 <vPortExitCritical>
}
   1979c:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.__multadd%414:

0001979e <__multadd>:
   1979e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   197a2:	690d      	ldr	r5, [r1, #16]
   197a4:	461f      	mov	r7, r3
   197a6:	4606      	mov	r6, r0
   197a8:	460c      	mov	r4, r1
   197aa:	f101 0c14 	add.w	ip, r1, #20
   197ae:	2300      	movs	r3, #0
   197b0:	f64f 7eff 	movw	lr, #65535	; 0xffff
   197b4:	f8dc 0000 	ldr.w	r0, [ip]
   197b8:	ea00 010e 	and.w	r1, r0, lr
   197bc:	fb02 7101 	mla	r1, r2, r1, r7
   197c0:	0c0f      	lsrs	r7, r1, #16
   197c2:	0c00      	lsrs	r0, r0, #16
   197c4:	fb02 7000 	mla	r0, r2, r0, r7
   197c8:	ea01 010e 	and.w	r1, r1, lr
   197cc:	3301      	adds	r3, #1
   197ce:	eb01 4100 	add.w	r1, r1, r0, lsl #16
   197d2:	429d      	cmp	r5, r3
   197d4:	ea4f 4710 	mov.w	r7, r0, lsr #16
   197d8:	f84c 1b04 	str.w	r1, [ip], #4
   197dc:	dcea      	bgt.n	197b4 <__multadd+0x16>
   197de:	b1d7      	cbz	r7, 19816 <__multadd+0x78>
   197e0:	68a3      	ldr	r3, [r4, #8]
   197e2:	42ab      	cmp	r3, r5
   197e4:	dc12      	bgt.n	1980c <__multadd+0x6e>
   197e6:	6861      	ldr	r1, [r4, #4]
   197e8:	4630      	mov	r0, r6
   197ea:	3101      	adds	r1, #1
   197ec:	f001 fc02 	bl	1aff4 <_Balloc>
   197f0:	6922      	ldr	r2, [r4, #16]
   197f2:	3202      	adds	r2, #2
   197f4:	f104 010c 	add.w	r1, r4, #12
   197f8:	4680      	mov	r8, r0
   197fa:	0092      	lsls	r2, r2, #2
   197fc:	300c      	adds	r0, #12
   197fe:	f007 fcbf 	bl	21180 <memcpy>
   19802:	4621      	mov	r1, r4
   19804:	4630      	mov	r0, r6
   19806:	f005 fff0 	bl	1f7ea <_Bfree>
   1980a:	4644      	mov	r4, r8
   1980c:	eb04 0385 	add.w	r3, r4, r5, lsl #2
   19810:	3501      	adds	r5, #1
   19812:	615f      	str	r7, [r3, #20]
   19814:	6125      	str	r5, [r4, #16]
   19816:	4620      	mov	r0, r4
   19818:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.DRV_ETHPHY_VendorSMIReadResultGet%415:

0001981c <DRV_ETHPHY_VendorSMIReadResultGet>:
{
   1981c:	b570      	push	{r4, r5, r6, lr}
    if(hClientObj == 0 || _DRVHandleToInst(hClientObj->hDriver) == 0)
   1981e:	b320      	cbz	r0, 1986a <DRV_ETHPHY_VendorSMIReadResultGet+0x4e>
   19820:	4604      	mov	r4, r0
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   19822:	68c0      	ldr	r0, [r0, #12]
   19824:	4a1b      	ldr	r2, [pc, #108]	; (19894 <DRV_ETHPHY_VendorSMIReadResultGet+0x78>)
   19826:	4290      	cmp	r0, r2
   19828:	d122      	bne.n	19870 <DRV_ETHPHY_VendorSMIReadResultGet+0x54>
    if( hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_BUSY || 
   1982a:	f994 5008 	ldrsb.w	r5, [r4, #8]
   1982e:	2d01      	cmp	r5, #1
   19830:	d122      	bne.n	19878 <DRV_ETHPHY_VendorSMIReadResultGet+0x5c>
   19832:	8ba2      	ldrh	r2, [r4, #28]
   19834:	2a01      	cmp	r2, #1
   19836:	d122      	bne.n	1987e <DRV_ETHPHY_VendorSMIReadResultGet+0x62>
        hClientObj->operType != DRV_ETHPHY_CLIENT_OP_TYPE_SETUP || 
   19838:	8be2      	ldrh	r2, [r4, #30]
   1983a:	f022 0202 	bic.w	r2, r2, #2
   1983e:	b292      	uxth	r2, r2
   19840:	2a01      	cmp	r2, #1
   19842:	d002      	beq.n	1984a <DRV_ETHPHY_VendorSMIReadResultGet+0x2e>
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   19844:	f06f 0509 	mvn.w	r5, #9
   19848:	e014      	b.n	19874 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
    if(hClientObj->smiTxferStatus != DRV_ETHPHY_SMI_TXFER_OP_WAIT_COMPLETE)
   1984a:	8ea2      	ldrh	r2, [r4, #52]	; 0x34
   1984c:	2a02      	cmp	r2, #2
   1984e:	d119      	bne.n	19884 <DRV_ETHPHY_VendorSMIReadResultGet+0x68>
   19850:	460e      	mov	r6, r1
    DRV_ETHPHY_SMI_TXFER_RES opRes = _DRV_PHY_SMITransferWaitComplete(hClientObj);
   19852:	4620      	mov	r0, r4
   19854:	f002 fb91 	bl	1bf7a <_DRV_PHY_SMITransferWaitComplete>
    if(opRes < 0)
   19858:	2800      	cmp	r0, #0
   1985a:	db16      	blt.n	1988a <DRV_ETHPHY_VendorSMIReadResultGet+0x6e>
    else if(opRes == DRV_ETHPHY_SMI_TXFER_RES_WAIT)
   1985c:	2802      	cmp	r0, #2
   1985e:	d009      	beq.n	19874 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
    if(pSmiRes)
   19860:	b1b6      	cbz	r6, 19890 <DRV_ETHPHY_VendorSMIReadResultGet+0x74>
        *pSmiRes = hClientObj->smiData;
   19862:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   19864:	8033      	strh	r3, [r6, #0]
    return DRV_ETHPHY_RES_OK;
   19866:	2500      	movs	r5, #0
   19868:	e004      	b.n	19874 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
        return DRV_ETHPHY_RES_HANDLE_ERR;
   1986a:	f06f 050a 	mvn.w	r5, #10
   1986e:	e001      	b.n	19874 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
   19870:	f06f 050a 	mvn.w	r5, #10
}
   19874:	4628      	mov	r0, r5
   19876:	bd70      	pop	{r4, r5, r6, pc}
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   19878:	f06f 0509 	mvn.w	r5, #9
   1987c:	e7fa      	b.n	19874 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
   1987e:	f06f 0509 	mvn.w	r5, #9
   19882:	e7f7      	b.n	19874 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   19884:	f06f 0508 	mvn.w	r5, #8
   19888:	e7f4      	b.n	19874 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   1988a:	f06f 0508 	mvn.w	r5, #8
   1988e:	e7f1      	b.n	19874 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
    return DRV_ETHPHY_RES_OK;
   19890:	2500      	movs	r5, #0
   19892:	e7ef      	b.n	19874 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
   19894:	2000de18 	.word	0x2000de18

Disassembly of section .text.DRV_PIC32CGMAC_LibInit%416:

00019898 <DRV_PIC32CGMAC_LibInit>:
{		
   19898:	b508      	push	{r3, lr}
    MCLK_REGS->MCLK_AHBMASK |= MCLK_AHBMASK_GMAC(1);	
   1989a:	4b1b      	ldr	r3, [pc, #108]	; (19908 <DRV_PIC32CGMAC_LibInit+0x70>)
   1989c:	691a      	ldr	r2, [r3, #16]
   1989e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   198a2:	611a      	str	r2, [r3, #16]
    MCLK_REGS->MCLK_APBCMASK |= MCLK_APBCMASK_GMAC(1);
   198a4:	69da      	ldr	r2, [r3, #28]
   198a6:	f042 0204 	orr.w	r2, r2, #4
   198aa:	61da      	str	r2, [r3, #28]
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_TXEN_Msk;
   198ac:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
   198b0:	681a      	ldr	r2, [r3, #0]
   198b2:	f022 0208 	bic.w	r2, r2, #8
   198b6:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_RXEN_Msk;
   198b8:	681a      	ldr	r2, [r3, #0]
   198ba:	f022 0204 	bic.w	r2, r2, #4
   198be:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_IDR = GMAC_INT_ALL;	//Clear statistics register
   198c0:	f04f 32ff 	mov.w	r2, #4294967295
   198c4:	62da      	str	r2, [r3, #44]	; 0x2c
	GMAC_REGS->GMAC_NCR |=  GMAC_NCR_CLRSTAT_Msk;
   198c6:	681a      	ldr	r2, [r3, #0]
   198c8:	f042 0220 	orr.w	r2, r2, #32
   198cc:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_RSR =  GMAC_RSR_RXOVR_Msk | GMAC_RSR_REC_Msk | GMAC_RSR_BNA_Msk  | GMAC_RSR_HNO_Msk;
   198ce:	220f      	movs	r2, #15
   198d0:	621a      	str	r2, [r3, #32]
	GMAC_REGS->GMAC_TSR = GMAC_TSR_UBR_Msk  | GMAC_TSR_COL_Msk  | GMAC_TSR_RLE_Msk | GMAC_TSR_TXGO_Msk |
   198d2:	f240 123f 	movw	r2, #319	; 0x13f
   198d6:	615a      	str	r2, [r3, #20]
	GMAC_REGS->GMAC_ISR;
   198d8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
                            | GMAC_NCFGR_MAXFS(GMAC_MAX_RXFS)| GMAC_NCFGR_RXBUFO(pMACDrv->sGmacData._dataOffset);
   198da:	f890 20f6 	ldrb.w	r2, [r0, #246]	; 0xf6
   198de:	0392      	lsls	r2, r2, #14
   198e0:	b292      	uxth	r2, r2
   198e2:	490a      	ldr	r1, [pc, #40]	; (1990c <DRV_PIC32CGMAC_LibInit+0x74>)
   198e4:	4311      	orrs	r1, r2
    GMAC_REGS->GMAC_NCFGR = GMAC_NCFGR_SPD(1) | GMAC_NCFGR_FD(1) | GMAC_NCFGR_CLK(3)  |	GMAC_NCFGR_PEN(1)  | GMAC_NCFGR_RFCS(1)
   198e6:	6059      	str	r1, [r3, #4]
	if((pMACDrv->sGmacData.gmacConfig.checksumOffloadRx) != TCPIP_MAC_CHECKSUM_NONE)
   198e8:	f890 30e0 	ldrb.w	r3, [r0, #224]	; 0xe0
   198ec:	b123      	cbz	r3, 198f8 <DRV_PIC32CGMAC_LibInit+0x60>
        GMAC_REGS->GMAC_NCFGR |= GMAC_NCFGR_RXCOEN_Msk;
   198ee:	4a08      	ldr	r2, [pc, #32]	; (19910 <DRV_PIC32CGMAC_LibInit+0x78>)
   198f0:	6853      	ldr	r3, [r2, #4]
   198f2:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   198f6:	6053      	str	r3, [r2, #4]
    DRV_PIC32CGMAC_LibSetMacAddr((const uint8_t *)(pMACDrv->sGmacData.gmacConfig.macAddress.v));
   198f8:	30b8      	adds	r0, #184	; 0xb8
   198fa:	f005 fbc5 	bl	1f088 <DRV_PIC32CGMAC_LibSetMacAddr>
		GMAC_REGS->GMAC_UR = GMAC_UR_MII(0); //initial mode set as RMII
   198fe:	4b04      	ldr	r3, [pc, #16]	; (19910 <DRV_PIC32CGMAC_LibInit+0x78>)
   19900:	2200      	movs	r2, #0
   19902:	60da      	str	r2, [r3, #12]
}
   19904:	bd08      	pop	{r3, pc}
   19906:	bf00      	nop
   19908:	40000800 	.word	0x40000800
   1990c:	000e2103 	.word	0x000e2103
   19910:	42000800 	.word	0x42000800

Disassembly of section .text.SYS_Tasks%417:

00019914 <SYS_Tasks>:

  Remarks:
    See prototype in system/common/sys_module.h.
*/
void SYS_Tasks ( void )
{
   19914:	b570      	push	{r4, r5, r6, lr}
   19916:	b082      	sub	sp, #8
    /* Maintain system services */
    

    xTaskCreate( _SYS_CMD_Tasks,
   19918:	4d17      	ldr	r5, [pc, #92]	; (19978 <SYS_Tasks+0x64>)
   1991a:	2400      	movs	r4, #0
   1991c:	9401      	str	r4, [sp, #4]
   1991e:	2601      	movs	r6, #1
   19920:	9600      	str	r6, [sp, #0]
   19922:	4623      	mov	r3, r4
   19924:	f44f 6220 	mov.w	r2, #2560	; 0xa00
   19928:	4629      	mov	r1, r5
   1992a:	4814      	ldr	r0, [pc, #80]	; (1997c <SYS_Tasks+0x68>)
   1992c:	f7f5 fcd6 	bl	f2dc <xTaskCreate>




    /* Maintain Device Drivers */
        xTaskCreate( _DRV_MIIM_Task,
   19930:	9401      	str	r4, [sp, #4]
   19932:	9600      	str	r6, [sp, #0]
   19934:	4623      	mov	r3, r4
   19936:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1993a:	f105 0110 	add.w	r1, r5, #16
   1993e:	4810      	ldr	r0, [pc, #64]	; (19980 <SYS_Tasks+0x6c>)
   19940:	f7f5 fccc 	bl	f2dc <xTaskCreate>



    /* Maintain Middleware & Other Libraries */
    
    xTaskCreate( _TCPIP_STACK_Task,
   19944:	9401      	str	r4, [sp, #4]
   19946:	9600      	str	r6, [sp, #0]
   19948:	4623      	mov	r3, r4
   1994a:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1994e:	f105 0120 	add.w	r1, r5, #32
   19952:	480c      	ldr	r0, [pc, #48]	; (19984 <SYS_Tasks+0x70>)
   19954:	f7f5 fcc2 	bl	f2dc <xTaskCreate>



    /* Maintain the application's state machine. */
        /* Create OS Thread for APP_Tasks. */
    xTaskCreate((TaskFunction_t) _APP_Tasks,
   19958:	4b0b      	ldr	r3, [pc, #44]	; (19988 <SYS_Tasks+0x74>)
   1995a:	9301      	str	r3, [sp, #4]
   1995c:	9600      	str	r6, [sp, #0]
   1995e:	4623      	mov	r3, r4
   19960:	f44f 6280 	mov.w	r2, #1024	; 0x400
   19964:	f105 0134 	add.w	r1, r5, #52	; 0x34
   19968:	4808      	ldr	r0, [pc, #32]	; (1998c <SYS_Tasks+0x78>)
   1996a:	f7f5 fcb7 	bl	f2dc <xTaskCreate>
    /* Start RTOS Scheduler. */
    
     /**********************************************************************
     * Create all Threads for APP Tasks before starting FreeRTOS Scheduler *
     ***********************************************************************/
    vTaskStartScheduler(); /* This function never returns. */
   1996e:	f001 fd09 	bl	1b384 <vTaskStartScheduler>

}
   19972:	b002      	add	sp, #8
   19974:	bd70      	pop	{r4, r5, r6, pc}
   19976:	bf00      	nop
   19978:	0001dd34 	.word	0x0001dd34
   1997c:	00021c0d 	.word	0x00021c0d
   19980:	000216dd 	.word	0x000216dd
   19984:	000216c5 	.word	0x000216c5
   19988:	2000e488 	.word	0x2000e488
   1998c:	00021bfd 	.word	0x00021bfd

Disassembly of section .text.SYS_Initialize%418:

00019990 <SYS_Initialize>:

  Remarks:
 */

void SYS_Initialize ( void* data )
{
   19990:	b510      	push	{r4, lr}

    NVMCTRL_Initialize( );
   19992:	f008 f913 	bl	21bbc <NVMCTRL_Initialize>

  
    PORT_Initialize();
   19996:	f7fc fdfd 	bl	16594 <PORT_Initialize>

    CLOCK_Initialize();
   1999a:	f7fa fef7 	bl	1478c <CLOCK_Initialize>




    TC0_TimerInitialize();
   1999e:	f004 f989 	bl	1dcb4 <TC0_TimerInitialize>

    SERCOM1_USART_Initialize();
   199a2:	f7ff fd3d 	bl	19420 <SERCOM1_USART_Initialize>

    EVSYS_Initialize();
   199a6:	f7fa fd76 	bl	14496 <EVSYS_Initialize>

    SERCOM0_SPI_Initialize();
   199aa:	f004 ff93 	bl	1e8d4 <SERCOM0_SPI_Initialize>



    /* Initialize the MIIM Driver */
    sysObj.drvMiim = DRV_MIIM_Initialize( DRV_MIIM_INDEX_0, (const SYS_MODULE_INIT *) &drvMiimInitData );
   199ae:	4911      	ldr	r1, [pc, #68]	; (199f4 <SYS_Initialize+0x64>)
   199b0:	2000      	movs	r0, #0
   199b2:	f000 f91d 	bl	19bf0 <DRV_MIIM_Initialize>
   199b6:	4c10      	ldr	r4, [pc, #64]	; (199f8 <SYS_Initialize+0x68>)
   199b8:	60e0      	str	r0, [r4, #12]


    sysObj.sysTime = SYS_TIME_Initialize(SYS_TIME_INDEX_0, (SYS_MODULE_INIT *)&sysTimeInitData);
   199ba:	4910      	ldr	r1, [pc, #64]	; (199fc <SYS_Initialize+0x6c>)
   199bc:	2000      	movs	r0, #0
   199be:	f7fd fae9 	bl	16f94 <SYS_TIME_Initialize>
   199c2:	6020      	str	r0, [r4, #0]
    sysObj.sysConsole0 = SYS_CONSOLE_Initialize(SYS_CONSOLE_INDEX_0, (SYS_MODULE_INIT *)&sysConsole0Init);
   199c4:	490e      	ldr	r1, [pc, #56]	; (19a00 <SYS_Initialize+0x70>)
   199c6:	2000      	movs	r0, #0
   199c8:	f001 fa44 	bl	1ae54 <SYS_CONSOLE_Initialize>
   199cc:	6060      	str	r0, [r4, #4]

    SYS_CMD_Initialize((SYS_MODULE_INIT*)&sysCmdInit);
   199ce:	480d      	ldr	r0, [pc, #52]	; (19a04 <SYS_Initialize+0x74>)
   199d0:	f004 ff2c 	bl	1e82c <SYS_CMD_Initialize>

    sysObj.sysDebug = SYS_DEBUG_Initialize(SYS_DEBUG_INDEX_0, (SYS_MODULE_INIT*)&debugInit);
   199d4:	490c      	ldr	r1, [pc, #48]	; (19a08 <SYS_Initialize+0x78>)
   199d6:	2000      	movs	r0, #0
   199d8:	f007 fb54 	bl	21084 <SYS_DEBUG_Initialize>
   199dc:	6120      	str	r0, [r4, #16]




/* TCPIP Stack Initialization */
sysObj.tcpip = TCPIP_STACK_Init();
   199de:	f006 f823 	bl	1fa28 <TCPIP_STACK_Init>
   199e2:	60a0      	str	r0, [r4, #8]
SYS_ASSERT(sysObj.tcpip != SYS_MODULE_OBJ_INVALID, "TCPIP_STACK_Init Failed" );


    CRYPT_WCCB_Initialize();
   199e4:	f008 f806 	bl	219f4 <CRYPT_WCCB_Initialize>

    APP_Initialize();
   199e8:	f008 fb4a 	bl	22080 <APP_Initialize>


    NVIC_Initialize();
   199ec:	f7fe ff46 	bl	1887c <NVIC_Initialize>

}
   199f0:	bd10      	pop	{r4, pc}
   199f2:	bf00      	nop
   199f4:	000221c8 	.word	0x000221c8
   199f8:	2000e264 	.word	0x2000e264
   199fc:	000221d0 	.word	0x000221d0
   19a00:	00022068 	.word	0x00022068
   19a04:	2000e48c 	.word	0x2000e48c
   19a08:	00022264 	.word	0x00022264

Disassembly of section .text.TCPIP_TCP_SocketInfoGet%419:

00019a0c <TCPIP_TCP_SocketInfoGet>:
{
   19a0c:	b570      	push	{r4, r5, r6, lr}
   19a0e:	4606      	mov	r6, r0
   19a10:	460d      	mov	r5, r1
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   19a12:	f006 fa03 	bl	1fe1c <_TcpSocketChk>
    if(pSkt == 0)
   19a16:	2800      	cmp	r0, #0
   19a18:	d033      	beq.n	19a82 <TCPIP_TCP_SocketInfoGet+0x76>
   19a1a:	4604      	mov	r4, r0
        memset(remoteInfo, 0, sizeof(*remoteInfo));
   19a1c:	2238      	movs	r2, #56	; 0x38
   19a1e:	2100      	movs	r1, #0
   19a20:	4628      	mov	r0, r5
   19a22:	f008 f933 	bl	21c8c <memset>
        if (pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   19a26:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
   19a2a:	2b01      	cmp	r3, #1
   19a2c:	d022      	beq.n	19a74 <TCPIP_TCP_SocketInfoGet+0x68>
	remoteInfo->remotePort = pSkt->remotePort;
   19a2e:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
   19a32:	84ab      	strh	r3, [r5, #36]	; 0x24
	remoteInfo->localPort = pSkt->localPort;
   19a34:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
   19a38:	84eb      	strh	r3, [r5, #38]	; 0x26
	remoteInfo->hNet = pSkt->pSktNet;
   19a3a:	6c23      	ldr	r3, [r4, #64]	; 0x40
   19a3c:	62ab      	str	r3, [r5, #40]	; 0x28
	remoteInfo->state = (TCPIP_TCP_STATE)pSkt->smState;
   19a3e:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
   19a42:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
    remoteInfo->rxSize = pSkt->rxEnd - pSkt->rxStart;
   19a46:	69a3      	ldr	r3, [r4, #24]
   19a48:	6962      	ldr	r2, [r4, #20]
   19a4a:	1a9b      	subs	r3, r3, r2
   19a4c:	85eb      	strh	r3, [r5, #46]	; 0x2e
    remoteInfo->txSize = pSkt->txEnd - pSkt->txStart;
   19a4e:	6863      	ldr	r3, [r4, #4]
   19a50:	6822      	ldr	r2, [r4, #0]
   19a52:	1a9b      	subs	r3, r3, r2
   19a54:	862b      	strh	r3, [r5, #48]	; 0x30
    remoteInfo->rxPending = _TCPIsGetReady(pSkt);
   19a56:	4620      	mov	r0, r4
   19a58:	f007 f959 	bl	20d0e <_TCPIsGetReady>
   19a5c:	8668      	strh	r0, [r5, #50]	; 0x32
    remoteInfo->txPending = TCPIP_TCP_FifoTxFullGet(hTCP);
   19a5e:	4630      	mov	r0, r6
   19a60:	f003 fc38 	bl	1d2d4 <TCPIP_TCP_FifoTxFullGet>
   19a64:	86a8      	strh	r0, [r5, #52]	; 0x34
    remoteInfo->flags = _TCP_SktFlagsGet(pSkt);
   19a66:	4620      	mov	r0, r4
   19a68:	f005 f80c 	bl	1ea84 <_TCP_SktFlagsGet>
   19a6c:	f885 0036 	strb.w	r0, [r5, #54]	; 0x36
	return true;
   19a70:	2001      	movs	r0, #1
}
   19a72:	bd70      	pop	{r4, r5, r6, pc}
            remoteInfo->remoteIPaddress.v4Add = pSkt->destAddress;
   19a74:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   19a76:	606b      	str	r3, [r5, #4]
            remoteInfo->localIPaddress.v4Add = pSkt->srcAddress;
   19a78:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   19a7a:	616b      	str	r3, [r5, #20]
            remoteInfo->addressType = IP_ADDRESS_TYPE_IPV4;
   19a7c:	2301      	movs	r3, #1
   19a7e:	702b      	strb	r3, [r5, #0]
   19a80:	e7d5      	b.n	19a2e <TCPIP_TCP_SocketInfoGet+0x22>
        return false;
   19a82:	2000      	movs	r0, #0
   19a84:	e7f5      	b.n	19a72 <TCPIP_TCP_SocketInfoGet+0x66>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4%420:

00019a86 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4>:
{
   19a86:	b510      	push	{r4, lr}
   19a88:	4604      	mov	r4, r0
    DRV_ETHPHY_INSTANCE *hDriver = hClientObj->hDriver;
   19a8a:	68c1      	ldr	r1, [r0, #12]
    uint16_t  matchCpbl = hClientObj->operReg[1];
   19a8c:	8c83      	ldrh	r3, [r0, #36]	; 0x24
    if(matchCpbl &_BMSTAT_AN_ABLE_MASK)
   19a8e:	f013 0f08 	tst.w	r3, #8
   19a92:	d018      	beq.n	19ac6 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4+0x40>
        anadReg = (((matchCpbl >> _BMSTAT_NEGOTIATION_POS) << _ANAD_NEGOTIATION_POS) & _ANAD_NEGOTIATION_MASK) | PROT_802_3;
   19a94:	0ada      	lsrs	r2, r3, #11
   19a96:	0152      	lsls	r2, r2, #5
   19a98:	f042 0201 	orr.w	r2, r2, #1
        if(hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_PAUSE)
   19a9c:	7bcb      	ldrb	r3, [r1, #15]
   19a9e:	f013 0f01 	tst.w	r3, #1
            anadReg |= _ANAD_PAUSE_MASK;
   19aa2:	bf18      	it	ne
   19aa4:	f442 6280 	orrne.w	r2, r2, #1024	; 0x400
        if(hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_ASM_DIR)
   19aa8:	f013 0f02 	tst.w	r3, #2
            anadReg |= _ANAD_ASM_DIR_MASK;
   19aac:	bf18      	it	ne
   19aae:	f442 6200 	orrne.w	r2, r2, #2048	; 0x800
        if(_DRV_PHY_SMIWriteStart(hClientObj, PHY_REG_ANAD, anadReg))
   19ab2:	2104      	movs	r1, #4
   19ab4:	f005 fa3b 	bl	1ef2e <_DRV_PHY_SMIWriteStart>
   19ab8:	b900      	cbnz	r0, 19abc <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4+0x36>
}
   19aba:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   19abc:	2303      	movs	r3, #3
   19abe:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   19ac0:	2305      	movs	r3, #5
   19ac2:	8423      	strh	r3, [r4, #32]
   19ac4:	e7f9      	b.n	19aba <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4+0x34>
        if(matchCpbl & (_BMSTAT_BASE100TX_HDX_MASK | _BMSTAT_BASE100TX_FDX_MASK))   // set 100Mbps request/capability
   19ac6:	f403 42c0 	and.w	r2, r3, #24576	; 0x6000
            ctrlReg |= _BMCON_SPEED_MASK;
   19aca:	2a00      	cmp	r2, #0
   19acc:	bf18      	it	ne
   19ace:	f44f 5200 	movne.w	r2, #8192	; 0x2000
        if(matchCpbl & (_BMSTAT_BASE10T_FDX_MASK | _BMSTAT_BASE100TX_FDX_MASK))
   19ad2:	f413 4fa0 	tst.w	r3, #20480	; 0x5000
            ctrlReg |= _BMCON_DUPLEX_MASK;
   19ad6:	bf18      	it	ne
   19ad8:	f442 7280 	orrne.w	r2, r2, #256	; 0x100
        if(hClientObj->hDriver->openFlags & TCPIP_ETH_OPEN_PHY_LOOPBACK)
   19adc:	898b      	ldrh	r3, [r1, #12]
   19ade:	f013 0f80 	tst.w	r3, #128	; 0x80
            ctrlReg |= _BMCON_LOOPBACK_MASK;
   19ae2:	bf1c      	itt	ne
   19ae4:	f442 4280 	orrne.w	r2, r2, #16384	; 0x4000
   19ae8:	b292      	uxthne	r2, r2
        if(_DRV_PHY_SMIWriteStart(hClientObj, PHY_REG_BMCON, ctrlReg))
   19aea:	2100      	movs	r1, #0
   19aec:	f005 fa1f 	bl	1ef2e <_DRV_PHY_SMIWriteStart>
   19af0:	2800      	cmp	r0, #0
   19af2:	d0e2      	beq.n	19aba <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4+0x34>
    hClientObj->operPhase = operPhase;
   19af4:	2303      	movs	r3, #3
   19af6:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   19af8:	2307      	movs	r3, #7
   19afa:	8423      	strh	r3, [r4, #32]
}
   19afc:	e7dd      	b.n	19aba <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4+0x34>

Disassembly of section .text.DRV_PIC32CGMAC_LibTxInit%421:

00019b00 <DRV_PIC32CGMAC_LibTxInit>:
{
   19b00:	b410      	push	{r4}
    pL->head = pL->tail = 0;
   19b02:	2300      	movs	r3, #0
   19b04:	f8c0 30a8 	str.w	r3, [r0, #168]	; 0xa8
   19b08:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
    pL->nNodes = 0;
   19b0c:	f8c0 30ac 	str.w	r3, [r0, #172]	; 0xac
		for(desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nTxDescCnt; desc_idx++)
   19b10:	f8b0 30c8 	ldrh.w	r3, [r0, #200]	; 0xc8
   19b14:	b35b      	cbz	r3, 19b6e <DRV_PIC32CGMAC_LibTxInit+0x6e>
   19b16:	2300      	movs	r3, #0
            pMACDrv->sGmacData.gmac_queue[queue_idx].nTxDescHead = 0;
   19b18:	4619      	mov	r1, r3
			pMACDrv->sGmacData.gmac_queue[queue_idx].pTxDesc[desc_idx].tx_desc_status.val = GMAC_TX_USED_BIT | GMAC_TX_LAST_BUFFER_BIT;
   19b1a:	f04f 2480 	mov.w	r4, #2147516416	; 0x80008000
            pMACDrv->sGmacData.gmac_queue[queue_idx].nTxDescHead = 0;
   19b1e:	f8a0 10b2 	strh.w	r1, [r0, #178]	; 0xb2
            pMACDrv->sGmacData.gmac_queue[queue_idx].nTxDescTail = 0;
   19b22:	f8a0 10b4 	strh.w	r1, [r0, #180]	; 0xb4
			pMACDrv->sGmacData.gmac_queue[queue_idx].pTxDesc[desc_idx].tx_desc_buffaddr = 0;
   19b26:	f8d0 20a0 	ldr.w	r2, [r0, #160]	; 0xa0
   19b2a:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
			pMACDrv->sGmacData.gmac_queue[queue_idx].pTxDesc[desc_idx].tx_desc_status.val = GMAC_TX_USED_BIT | GMAC_TX_LAST_BUFFER_BIT;
   19b2e:	f8d0 20a0 	ldr.w	r2, [r0, #160]	; 0xa0
   19b32:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
   19b36:	6054      	str	r4, [r2, #4]
		for(desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nTxDescCnt; desc_idx++)
   19b38:	3301      	adds	r3, #1
   19b3a:	b2db      	uxtb	r3, r3
   19b3c:	f8b0 20c8 	ldrh.w	r2, [r0, #200]	; 0xc8
   19b40:	429a      	cmp	r2, r3
   19b42:	d8ec      	bhi.n	19b1e <DRV_PIC32CGMAC_LibTxInit+0x1e>
		pMACDrv->sGmacData.gmac_queue[queue_idx].pTxDesc[desc_idx-1].tx_desc_status.val |= GMAC_TX_WRAP_BIT;
   19b44:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
   19b48:	3b01      	subs	r3, #1
   19b4a:	f8d0 20a0 	ldr.w	r2, [r0, #160]	; 0xa0
   19b4e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   19b52:	685a      	ldr	r2, [r3, #4]
   19b54:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
   19b58:	605a      	str	r2, [r3, #4]
		GMAC_REGS->GMAC_TBQB = GMAC_TBQB_ADDR_Msk & ((uint32_t)pMACDrv->sGmacData.gmac_queue[queue_idx].pTxDesc);
   19b5a:	f8d0 30a0 	ldr.w	r3, [r0, #160]	; 0xa0
   19b5e:	f023 0303 	bic.w	r3, r3, #3
   19b62:	4a04      	ldr	r2, [pc, #16]	; (19b74 <DRV_PIC32CGMAC_LibTxInit+0x74>)
   19b64:	61d3      	str	r3, [r2, #28]
}//DRV_PIC32CGMAC_LibTxInit
   19b66:	2000      	movs	r0, #0
   19b68:	f85d 4b04 	ldr.w	r4, [sp], #4
   19b6c:	4770      	bx	lr
		for(desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nTxDescCnt; desc_idx++)
   19b6e:	2300      	movs	r3, #0
   19b70:	e7e8      	b.n	19b44 <DRV_PIC32CGMAC_LibTxInit+0x44>
   19b72:	bf00      	nop
   19b74:	42000800 	.word	0x42000800

Disassembly of section .text.DRV_MIIM_Open%422:

00019b78 <DRV_MIIM_Open>:
{
   19b78:	b510      	push	{r4, lr}
        if(iModule >= DRV_MIIM_INSTANCES_NUMBER)
   19b7a:	b118      	cbz	r0, 19b84 <DRV_MIIM_Open+0xc>
    DRV_HANDLE drvHandle = DRV_HANDLE_INVALID;
   19b7c:	f04f 34ff 	mov.w	r4, #4294967295
}
   19b80:	4620      	mov	r0, r4
   19b82:	bd10      	pop	{r4, pc}
   19b84:	460c      	mov	r4, r1
        pMiimObj = _DRV_MIIM_GetObjectAndLock((SYS_MODULE_OBJ)(gDrvMIIMObj + iModule));
   19b86:	4819      	ldr	r0, [pc, #100]	; (19bec <DRV_MIIM_Open+0x74>)
   19b88:	f005 fced 	bl	1f566 <_DRV_MIIM_GetObjectAndLock>
        if(pMiimObj == 0)
   19b8c:	4603      	mov	r3, r0
   19b8e:	b180      	cbz	r0, 19bb2 <DRV_MIIM_Open+0x3a>
        if((ioIntent & DRV_IO_INTENT_EXCLUSIVE) != 0)
   19b90:	f014 0108 	ands.w	r1, r4, #8
   19b94:	d001      	beq.n	19b9a <DRV_MIIM_Open+0x22>
            if(pMiimObj->numClients > 0)
   19b96:	88c2      	ldrh	r2, [r0, #6]
   19b98:	b972      	cbnz	r2, 19bb8 <DRV_MIIM_Open+0x40>
        if(pClient->clientInUse == 0)
   19b9a:	8a1a      	ldrh	r2, [r3, #16]
   19b9c:	b17a      	cbz	r2, 19bbe <DRV_MIIM_Open+0x46>
    for(ix = 0; ix < sizeof(pMiimObj->objClients) / sizeof(*pMiimObj->objClients); ix++, pClient++)
   19b9e:	f103 0420 	add.w	r4, r3, #32
        if(pClient->clientInUse == 0)
   19ba2:	8c1a      	ldrh	r2, [r3, #32]
   19ba4:	b302      	cbz	r2, 19be8 <DRV_MIIM_Open+0x70>
    DRV_HANDLE drvHandle = DRV_HANDLE_INVALID;
   19ba6:	f04f 34ff 	mov.w	r4, #4294967295
    OSAL_SEM_Post(&pMiimObj->objSem);
   19baa:	4618      	mov	r0, r3
   19bac:	f007 fd12 	bl	215d4 <OSAL_SEM_Post>
   19bb0:	e7e6      	b.n	19b80 <DRV_MIIM_Open+0x8>
    DRV_HANDLE drvHandle = DRV_HANDLE_INVALID;
   19bb2:	f04f 34ff 	mov.w	r4, #4294967295
    return drvHandle;
   19bb6:	e7e3      	b.n	19b80 <DRV_MIIM_Open+0x8>
    DRV_HANDLE drvHandle = DRV_HANDLE_INVALID;
   19bb8:	f04f 34ff 	mov.w	r4, #4294967295
   19bbc:	e7f5      	b.n	19baa <DRV_MIIM_Open+0x32>
    DRV_MIIM_CLIENT_DCPT* pClient = pMiimObj->objClients;
   19bbe:	f103 0410 	add.w	r4, r3, #16
    for(ix = 0; ix < sizeof(pMiimObj->objClients) / sizeof(*pMiimObj->objClients); ix++, pClient++)
   19bc2:	2000      	movs	r0, #0
            memset(pClient, 0, sizeof(*pClient));
   19bc4:	2200      	movs	r2, #0
   19bc6:	60a2      	str	r2, [r4, #8]
   19bc8:	60e2      	str	r2, [r4, #12]
            pClient->clientInUse = true;
   19bca:	2201      	movs	r2, #1
   19bcc:	8022      	strh	r2, [r4, #0]
            pClient->clientIx = clientIx;
   19bce:	8060      	strh	r0, [r4, #2]
            pClient->parentObj  = pMiimObj;
   19bd0:	6063      	str	r3, [r4, #4]
            pClient->cliStatus = DRV_MIIM_CLIENT_STATUS_READY;
   19bd2:	2202      	movs	r2, #2
   19bd4:	7322      	strb	r2, [r4, #12]
            if((ioIntent & DRV_IO_INTENT_EXCLUSIVE) != 0)
   19bd6:	b119      	cbz	r1, 19be0 <DRV_MIIM_Open+0x68>
                pMiimObj->objFlags |= DRV_MIIM_OBJ_FLAG_EXCLUSIVE;
   19bd8:	889a      	ldrh	r2, [r3, #4]
   19bda:	f042 0204 	orr.w	r2, r2, #4
   19bde:	809a      	strh	r2, [r3, #4]
            pMiimObj->numClients++;
   19be0:	88da      	ldrh	r2, [r3, #6]
   19be2:	3201      	adds	r2, #1
   19be4:	80da      	strh	r2, [r3, #6]
            drvHandle =  (DRV_HANDLE)pClient;
   19be6:	e7e0      	b.n	19baa <DRV_MIIM_Open+0x32>
        if(pClient->clientInUse == 0)
   19be8:	2001      	movs	r0, #1
   19bea:	e7eb      	b.n	19bc4 <DRV_MIIM_Open+0x4c>
   19bec:	2000dbf0 	.word	0x2000dbf0

Disassembly of section .text.DRV_MIIM_Initialize%423:

00019bf0 <DRV_MIIM_Initialize>:
{
   19bf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(iModule >= DRV_MIIM_INSTANCES_NUMBER)
   19bf2:	bb70      	cbnz	r0, 19c52 <DRV_MIIM_Initialize+0x62>
    pMiimObj = _DRV_MIIM_GetObject((SYS_MODULE_OBJ)(gDrvMIIMObj + iModule));
   19bf4:	4e1b      	ldr	r6, [pc, #108]	; (19c64 <DRV_MIIM_Initialize+0x74>)
        if(pMiimObj->objStatus == SYS_STATUS_READY && (pMiimObj->objFlags & DRV_MIIM_OBJ_FLAG_IN_USE) != 0)
   19bf6:	f996 3008 	ldrsb.w	r3, [r6, #8]
   19bfa:	2b02      	cmp	r3, #2
   19bfc:	d103      	bne.n	19c06 <DRV_MIIM_Initialize+0x16>
   19bfe:	88b3      	ldrh	r3, [r6, #4]
   19c00:	f013 0f01 	tst.w	r3, #1
   19c04:	d123      	bne.n	19c4e <DRV_MIIM_Initialize+0x5e>
   19c06:	460d      	mov	r5, r1
    memset(pMiimObj, 0, sizeof(*pMiimObj));
   19c08:	2294      	movs	r2, #148	; 0x94
   19c0a:	2100      	movs	r1, #0
   19c0c:	4815      	ldr	r0, [pc, #84]	; (19c64 <DRV_MIIM_Initialize+0x74>)
   19c0e:	f008 f83d 	bl	21c8c <memset>
    if((miimInit = (DRV_MIIM_INIT*) init) == 0)
   19c12:	b30d      	cbz	r5, 19c58 <DRV_MIIM_Initialize+0x68>
    if(OSAL_SEM_Create(&pMiimObj->objSem, OSAL_SEM_TYPE_BINARY, 1, 1) != OSAL_RESULT_TRUE)
   19c14:	2301      	movs	r3, #1
   19c16:	461a      	mov	r2, r3
   19c18:	2100      	movs	r1, #0
   19c1a:	4812      	ldr	r0, [pc, #72]	; (19c64 <DRV_MIIM_Initialize+0x74>)
   19c1c:	f002 f92a 	bl	1be74 <OSAL_SEM_Create>
   19c20:	2801      	cmp	r0, #1
   19c22:	d11c      	bne.n	19c5e <DRV_MIIM_Initialize+0x6e>
    pMiimObj->objFlags = DRV_MIIM_OBJ_FLAG_IN_USE;      // Set object to be in use
   19c24:	4c0f      	ldr	r4, [pc, #60]	; (19c64 <DRV_MIIM_Initialize+0x74>)
   19c26:	2301      	movs	r3, #1
   19c28:	80a3      	strh	r3, [r4, #4]
    pMiimObj->objStatus = SYS_STATUS_READY; // Set module state
   19c2a:	2302      	movs	r3, #2
   19c2c:	7223      	strb	r3, [r4, #8]
    pMiimObj->iModule  = iModule;  // Store driver instance
   19c2e:	2300      	movs	r3, #0
   19c30:	8163      	strh	r3, [r4, #10]
    pMiimObj->ethphyId = miimInit->ethphyId; // Store PLIB ID
   19c32:	686b      	ldr	r3, [r5, #4]
   19c34:	60e3      	str	r3, [r4, #12]
    DRV_MIIM_OP_DCPT* pOpDcpt = pMiimObj->opPool;
   19c36:	3430      	adds	r4, #48	; 0x30
        pOpDcpt->qType = DRV_MIIM_QTYPE_FREE;
   19c38:	2701      	movs	r7, #1
        Helper_SingleListTailAdd(&pMiimObj->freeOpList, (SGL_LIST_NODE*)pOpDcpt);
   19c3a:	f104 0540 	add.w	r5, r4, #64	; 0x40
        pOpDcpt->qType = DRV_MIIM_QTYPE_FREE;
   19c3e:	72e7      	strb	r7, [r4, #11]
        Helper_SingleListTailAdd(&pMiimObj->freeOpList, (SGL_LIST_NODE*)pOpDcpt);
   19c40:	4621      	mov	r1, r4
   19c42:	4628      	mov	r0, r5
   19c44:	f007 fae1 	bl	2120a <Helper_SingleListTailAdd>
    for(ix = 0; ix < sizeof(pMiimObj->opPool) / sizeof(*pMiimObj->opPool); ix++, pOpDcpt++)
   19c48:	3410      	adds	r4, #16
   19c4a:	42ac      	cmp	r4, r5
   19c4c:	d1f7      	bne.n	19c3e <DRV_MIIM_Initialize+0x4e>
}
   19c4e:	4630      	mov	r0, r6
   19c50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return SYS_MODULE_OBJ_INVALID;
   19c52:	f04f 36ff 	mov.w	r6, #4294967295
   19c56:	e7fa      	b.n	19c4e <DRV_MIIM_Initialize+0x5e>
        return SYS_MODULE_OBJ_INVALID;
   19c58:	f04f 36ff 	mov.w	r6, #4294967295
   19c5c:	e7f7      	b.n	19c4e <DRV_MIIM_Initialize+0x5e>
        return SYS_MODULE_OBJ_INVALID;
   19c5e:	f04f 36ff 	mov.w	r6, #4294967295
   19c62:	e7f4      	b.n	19c4e <DRV_MIIM_Initialize+0x5e>
   19c64:	2000dbf0 	.word	0x2000dbf0

Disassembly of section .rodata%424:

00019c68 <.rodata%424>:
   19c68:	34765049 	.word	0x34765049
   19c6c:	696e4920 	.word	0x696e4920
   19c70:	46203a74 	.word	0x46203a74
   19c74:	656c6961 	.word	0x656c6961
   19c78:	6f742064 	.word	0x6f742064
   19c7c:	696e6920 	.word	0x696e6920
   19c80:	696c6174 	.word	0x696c6174
   19c84:	203a657a 	.word	0x203a657a
   19c88:	20216425 	.word	0x20216425
   19c8c:	00000a0d 	.word	0x00000a0d
   19c90:	34765049 	.word	0x34765049
   19c94:	6146203a 	.word	0x6146203a
   19c98:	64656c69 	.word	0x64656c69
   19c9c:	206f7420 	.word	0x206f7420
   19ca0:	69676572 	.word	0x69676572
   19ca4:	72657473 	.word	0x72657473
   19ca8:	50524120 	.word	0x50524120
   19cac:	746f6e20 	.word	0x746f6e20
   19cb0:	63696669 	.word	0x63696669
   19cb4:	6f697461 	.word	0x6f697461
   19cb8:	0d20216e 	.word	0x0d20216e
   19cbc:	0000000a 	.word	0x0000000a
   19cc0:	34765049 	.word	0x34765049
   19cc4:	5241203a 	.word	0x5241203a
   19cc8:	6e652050 	.word	0x6e652050
   19ccc:	65697274 	.word	0x65697274
   19cd0:	6f702073 	.word	0x6f702073
   19cd4:	65206c6f 	.word	0x65206c6f
   19cd8:	7974706d 	.word	0x7974706d
   19cdc:	000a0d21 	.word	0x000a0d21

Disassembly of section .text.TCPIP_Helper_PacketCopy%425:

00019ce0 <TCPIP_Helper_PacketCopy>:

// copies packet segment data to a linear destination buffer
// updates the pointer to the current location in the packet segment for further copy
// returns the number of total bytes copied
uint16_t TCPIP_Helper_PacketCopy(TCPIP_MAC_PACKET* pSrcPkt, uint8_t* pDest, uint8_t** pStartAdd, uint16_t len, bool srchTransport)
{
   19ce0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   19ce4:	4688      	mov	r8, r1
   19ce6:	4692      	mov	sl, r2
   19ce8:	461e      	mov	r6, r3
    uint16_t copyLen, copyBytes;
    uint8_t  *pCopyBuff, *pSrcBuff;
    uint16_t totCopyBytes = 0;

    copyLen = len;
    pCopyBuff = pSrcBuff = *pStartAdd; 
   19cea:	6817      	ldr	r7, [r2, #0]
    pSeg = TCPIP_PKT_DataSegmentGet(pSrcPkt, pSrcBuff, srchTransport);
   19cec:	f89d 2020 	ldrb.w	r2, [sp, #32]
   19cf0:	4639      	mov	r1, r7
   19cf2:	f000 fb61 	bl	1a3b8 <TCPIP_PKT_DataSegmentGet>

    while(pSeg != 0 && copyLen != 0)
   19cf6:	b320      	cbz	r0, 19d42 <TCPIP_Helper_PacketCopy+0x62>
   19cf8:	4605      	mov	r5, r0
   19cfa:	b356      	cbz	r6, 19d52 <TCPIP_Helper_PacketCopy+0x72>
    pCopyBuff = pSrcBuff = *pStartAdd; 
   19cfc:	463a      	mov	r2, r7
    uint16_t totCopyBytes = 0;
   19cfe:	f04f 0900 	mov.w	r9, #0
   19d02:	e00f      	b.n	19d24 <TCPIP_Helper_PacketCopy+0x44>
            copyBytes = copyLen;
        } 

        if(copyBytes)
        {
            memcpy(pDest, pCopyBuff, copyBytes);
   19d04:	4622      	mov	r2, r4
   19d06:	4639      	mov	r1, r7
   19d08:	4640      	mov	r0, r8
   19d0a:	f007 fa39 	bl	21180 <memcpy>
            pDest += copyBytes;
   19d0e:	44a0      	add	r8, r4
            copyLen -= copyBytes;
   19d10:	1b36      	subs	r6, r6, r4
   19d12:	b2b6      	uxth	r6, r6
            pSrcBuff = pCopyBuff + copyBytes;
   19d14:	193a      	adds	r2, r7, r4
            totCopyBytes += copyBytes;
   19d16:	44a1      	add	r9, r4
   19d18:	fa1f f989 	uxth.w	r9, r9
        }

        pSeg = pSeg->next;
   19d1c:	682d      	ldr	r5, [r5, #0]
        if(pSeg)
   19d1e:	b19d      	cbz	r5, 19d48 <TCPIP_Helper_PacketCopy+0x68>
        {
            pCopyBuff = pSeg->segLoad;
   19d20:	68af      	ldr	r7, [r5, #8]
    while(pSeg != 0 && copyLen != 0)
   19d22:	b18e      	cbz	r6, 19d48 <TCPIP_Helper_PacketCopy+0x68>
        copyBytes = (pSeg->segLoad + pSeg->segSize) - pCopyBuff;
   19d24:	89ec      	ldrh	r4, [r5, #14]
   19d26:	68ab      	ldr	r3, [r5, #8]
   19d28:	4423      	add	r3, r4
   19d2a:	1bdb      	subs	r3, r3, r7
   19d2c:	b29b      	uxth	r3, r3
        if(copyBytes > copyLen)
   19d2e:	89ac      	ldrh	r4, [r5, #12]
   19d30:	42b4      	cmp	r4, r6
   19d32:	bf28      	it	cs
   19d34:	4634      	movcs	r4, r6
   19d36:	429c      	cmp	r4, r3
   19d38:	bf28      	it	cs
   19d3a:	461c      	movcs	r4, r3
        if(copyBytes)
   19d3c:	2c00      	cmp	r4, #0
   19d3e:	d0ed      	beq.n	19d1c <TCPIP_Helper_PacketCopy+0x3c>
   19d40:	e7e0      	b.n	19d04 <TCPIP_Helper_PacketCopy+0x24>
    pCopyBuff = pSrcBuff = *pStartAdd; 
   19d42:	463a      	mov	r2, r7
    uint16_t totCopyBytes = 0;
   19d44:	f04f 0900 	mov.w	r9, #0
        }
    }
    
    *pStartAdd = pSrcBuff;
   19d48:	f8ca 2000 	str.w	r2, [sl]

    return totCopyBytes;
}
   19d4c:	4648      	mov	r0, r9
   19d4e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    uint16_t totCopyBytes = 0;
   19d52:	46b1      	mov	r9, r6
    pCopyBuff = pSrcBuff = *pStartAdd; 
   19d54:	463a      	mov	r2, r7
   19d56:	e7f7      	b.n	19d48 <TCPIP_Helper_PacketCopy+0x68>

Disassembly of section .text.SERCOM1_USART_Read%426:

00019d58 <SERCOM1_USART_Read>:
{
   19d58:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    rdOutIndex = sercom1USARTObj.rdOutIndex;
   19d5c:	4c19      	ldr	r4, [pc, #100]	; (19dc4 <SERCOM1_USART_Read+0x6c>)
   19d5e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    rdInIndex = sercom1USARTObj.rdInIndex;
   19d60:	6aa4      	ldr	r4, [r4, #40]	; 0x28
    while (nBytesRead < size)
   19d62:	b349      	cbz	r1, 19db8 <SERCOM1_USART_Read+0x60>
   19d64:	460d      	mov	r5, r1
        if (rdOutIndex != rdInIndex)
   19d66:	42a3      	cmp	r3, r4
   19d68:	d029      	beq.n	19dbe <SERCOM1_USART_Read+0x66>
            if (rdOutIndex >= sercom1USARTObj.rdBufferSize)
   19d6a:	4a16      	ldr	r2, [pc, #88]	; (19dc4 <SERCOM1_USART_Read+0x6c>)
   19d6c:	6b17      	ldr	r7, [r2, #48]	; 0x30
   19d6e:	4602      	mov	r2, r0
            if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   19d70:	4e15      	ldr	r6, [pc, #84]	; (19dc8 <SERCOM1_USART_Read+0x70>)
   19d72:	f1c0 0e01 	rsb	lr, r0, #1
                ((uint16_t*)pRdBuffer)[nBytesRead++] = ((uint16_t*)&SERCOM1_USART_ReadBuffer)[rdOutIndex++];
   19d76:	f8df c054 	ldr.w	ip, [pc, #84]	; 19dcc <SERCOM1_USART_Read+0x74>
   19d7a:	f1c0 0800 	rsb	r8, r0, #0
            if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   19d7e:	6871      	ldr	r1, [r6, #4]
   19d80:	f001 0107 	and.w	r1, r1, #7
   19d84:	2901      	cmp	r1, #1
                pRdBuffer[nBytesRead++] = SERCOM1_USART_ReadBuffer[rdOutIndex++];
   19d86:	eb0e 0002 	add.w	r0, lr, r2
   19d8a:	bf19      	ittee	ne
   19d8c:	f81c 1003 	ldrbne.w	r1, [ip, r3]
   19d90:	7011      	strbne	r1, [r2, #0]
                ((uint16_t*)pRdBuffer)[nBytesRead++] = ((uint16_t*)&SERCOM1_USART_ReadBuffer)[rdOutIndex++];
   19d92:	f83c 1013 	ldrheq.w	r1, [ip, r3, lsl #1]
   19d96:	f828 1012 	strheq.w	r1, [r8, r2, lsl #1]
   19d9a:	3301      	adds	r3, #1
                rdOutIndex = 0U;
   19d9c:	429f      	cmp	r7, r3
   19d9e:	bf98      	it	ls
   19da0:	2300      	movls	r3, #0
    while (nBytesRead < size)
   19da2:	42a8      	cmp	r0, r5
   19da4:	d203      	bcs.n	19dae <SERCOM1_USART_Read+0x56>
        if (rdOutIndex != rdInIndex)
   19da6:	3201      	adds	r2, #1
   19da8:	42a3      	cmp	r3, r4
   19daa:	d1e8      	bne.n	19d7e <SERCOM1_USART_Read+0x26>
   19dac:	e000      	b.n	19db0 <SERCOM1_USART_Read+0x58>
   19dae:	461c      	mov	r4, r3
    sercom1USARTObj.rdOutIndex = rdOutIndex;
   19db0:	4b04      	ldr	r3, [pc, #16]	; (19dc4 <SERCOM1_USART_Read+0x6c>)
   19db2:	62dc      	str	r4, [r3, #44]	; 0x2c
}
   19db4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    rdOutIndex = sercom1USARTObj.rdOutIndex;
   19db8:	461c      	mov	r4, r3
    size_t nBytesRead = 0U;
   19dba:	4608      	mov	r0, r1
   19dbc:	e7f8      	b.n	19db0 <SERCOM1_USART_Read+0x58>
   19dbe:	2000      	movs	r0, #0
   19dc0:	e7f6      	b.n	19db0 <SERCOM1_USART_Read+0x58>
   19dc2:	bf00      	nop
   19dc4:	2000dff0 	.word	0x2000dff0
   19dc8:	40003400 	.word	0x40003400
   19dcc:	2000a004 	.word	0x2000a004

Disassembly of section .text.__sfp%427:

00019dd0 <__sfp>:
   19dd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   19dd2:	4b1b      	ldr	r3, [pc, #108]	; (19e40 <__sfp+0x70>)
   19dd4:	681e      	ldr	r6, [r3, #0]
   19dd6:	69b3      	ldr	r3, [r6, #24]
   19dd8:	4607      	mov	r7, r0
   19dda:	b913      	cbnz	r3, 19de2 <__sfp+0x12>
   19ddc:	4630      	mov	r0, r6
   19dde:	f001 fce7 	bl	1b7b0 <__sinit>
   19de2:	3648      	adds	r6, #72	; 0x48
   19de4:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
   19de8:	3b01      	subs	r3, #1
   19dea:	d503      	bpl.n	19df4 <__sfp+0x24>
   19dec:	6833      	ldr	r3, [r6, #0]
   19dee:	b1db      	cbz	r3, 19e28 <__sfp+0x58>
   19df0:	6836      	ldr	r6, [r6, #0]
   19df2:	e7f7      	b.n	19de4 <__sfp+0x14>
   19df4:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
   19df8:	b9a5      	cbnz	r5, 19e24 <__sfp+0x54>
   19dfa:	4b12      	ldr	r3, [pc, #72]	; (19e44 <__sfp+0x74>)
   19dfc:	6625      	str	r5, [r4, #96]	; 0x60
   19dfe:	e9c4 5500 	strd	r5, r5, [r4]
   19e02:	60a5      	str	r5, [r4, #8]
   19e04:	e9c4 3503 	strd	r3, r5, [r4, #12]
   19e08:	e9c4 5505 	strd	r5, r5, [r4, #20]
   19e0c:	2208      	movs	r2, #8
   19e0e:	4629      	mov	r1, r5
   19e10:	f104 0058 	add.w	r0, r4, #88	; 0x58
   19e14:	f007 ff3a 	bl	21c8c <memset>
   19e18:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
   19e1c:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
   19e20:	4620      	mov	r0, r4
   19e22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   19e24:	3464      	adds	r4, #100	; 0x64
   19e26:	e7df      	b.n	19de8 <__sfp+0x18>
   19e28:	2104      	movs	r1, #4
   19e2a:	4638      	mov	r0, r7
   19e2c:	f005 fe80 	bl	1fb30 <__sfmoreglue>
   19e30:	4604      	mov	r4, r0
   19e32:	6030      	str	r0, [r6, #0]
   19e34:	2800      	cmp	r0, #0
   19e36:	d1db      	bne.n	19df0 <__sfp+0x20>
   19e38:	230c      	movs	r3, #12
   19e3a:	603b      	str	r3, [r7, #0]
   19e3c:	e7f0      	b.n	19e20 <__sfp+0x50>
   19e3e:	bf00      	nop
   19e40:	00022270 	.word	0x00022270
   19e44:	ffff0001 	.word	0xffff0001

Disassembly of section .text._DRV_GMAC_LinkStateNegResult%428:

00019e48 <_DRV_GMAC_LinkStateNegResult>:
{
   19e48:	b530      	push	{r4, r5, lr}
   19e4a:	b083      	sub	sp, #12
   19e4c:	4604      	mov	r4, r0
	DRV_ETHPHY_CONFIG_FLAGS phyCfgFlags = 0;
   19e4e:	2300      	movs	r3, #0
   19e50:	f88d 3007 	strb.w	r3, [sp, #7]
	pPhyBase =  pMACDrv->sGmacData.gmacConfig.pPhyBase;
   19e54:	f8d0 50d8 	ldr.w	r5, [r0, #216]	; 0xd8
	phyStat = pPhyBase->DRV_ETHPHY_ClientStatus( pMACDrv->sGmacData.hPhyClient );
   19e58:	69eb      	ldr	r3, [r5, #28]
   19e5a:	6900      	ldr	r0, [r0, #16]
   19e5c:	4798      	blx	r3
	if(phyStat == DRV_ETHPHY_CLIENT_STATUS_BUSY)
   19e5e:	2801      	cmp	r0, #1
   19e60:	d023      	beq.n	19eaa <_DRV_GMAC_LinkStateNegResult+0x62>
	phyRes = pPhyBase->DRV_ETHPHY_ClientOperationResult(pMACDrv->sGmacData.hPhyClient);
   19e62:	6a2b      	ldr	r3, [r5, #32]
   19e64:	6920      	ldr	r0, [r4, #16]
   19e66:	4798      	blx	r3
	if(phyRes != DRV_ETHPHY_RES_OK)
   19e68:	bb08      	cbnz	r0, 19eae <_DRV_GMAC_LinkStateNegResult+0x66>
	if( (pMACDrv->sGmacData._negResult.linkStatus & DRV_ETHPHY_LINK_ST_UP) != 0 )
   19e6a:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
   19e6e:	f013 0f01 	tst.w	r3, #1
   19e72:	d020      	beq.n	19eb6 <_DRV_GMAC_LinkStateNegResult+0x6e>
		pPhyBase->DRV_ETHPHY_HWConfigFlagsGet(pMACDrv->sGmacData.hPhyClient, &phyCfgFlags);
   19e74:	6b6b      	ldr	r3, [r5, #52]	; 0x34
   19e76:	f10d 0107 	add.w	r1, sp, #7
   19e7a:	6920      	ldr	r0, [r4, #16]
   19e7c:	4798      	blx	r3
		pMACDrv->sGmacData._negResult.linkFlags |= (phyCfgFlags & DRV_ETHPHY_CFG_RMII) ? TCPIP_ETH_OPEN_RMII : TCPIP_ETH_OPEN_MII ;
   19e7e:	f89d 1007 	ldrb.w	r1, [sp, #7]
   19e82:	0289      	lsls	r1, r1, #10
   19e84:	f401 6180 	and.w	r1, r1, #1024	; 0x400
   19e88:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
   19e8c:	4319      	orrs	r1, r3
   19e8e:	f8a4 1042 	strh.w	r1, [r4, #66]	; 0x42
		DRV_PIC32CGMAC_LibMACOpen(pMACDrv, pMACDrv->sGmacData._negResult.linkFlags, pauseType);
   19e92:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
   19e96:	4620      	mov	r0, r4
   19e98:	f000 fc50 	bl	1a73c <DRV_PIC32CGMAC_LibMACOpen>
		pMACDrv->sGmacData._macFlags._linkPrev = 1;
   19e9c:	7da3      	ldrb	r3, [r4, #22]
   19e9e:	f043 0310 	orr.w	r3, r3, #16
   19ea2:	75a3      	strb	r3, [r4, #22]
		pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_START_LINK;
   19ea4:	2300      	movs	r3, #0
   19ea6:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
}
   19eaa:	b003      	add	sp, #12
   19eac:	bd30      	pop	{r4, r5, pc}
		_DRV_GMAC_LinkStateDown(pMACDrv);
   19eae:	4620      	mov	r0, r4
   19eb0:	f006 ff1e 	bl	20cf0 <_DRV_GMAC_LinkStateDown>
		return;
   19eb4:	e7f9      	b.n	19eaa <_DRV_GMAC_LinkStateNegResult+0x62>
		_DRV_GMAC_LinkStateDown(pMACDrv);
   19eb6:	4620      	mov	r0, r4
   19eb8:	f006 ff1a 	bl	20cf0 <_DRV_GMAC_LinkStateDown>
   19ebc:	e7f5      	b.n	19eaa <_DRV_GMAC_LinkStateNegResult+0x62>

Disassembly of section .text.prvCopyDataToQueue%429:

00019ebe <prvCopyDataToQueue>:
{
   19ebe:	b570      	push	{r4, r5, r6, lr}
   19ec0:	4604      	mov	r4, r0
   19ec2:	4616      	mov	r6, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   19ec4:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   19ec6:	6c02      	ldr	r2, [r0, #64]	; 0x40
   19ec8:	b95a      	cbnz	r2, 19ee2 <prvCopyDataToQueue+0x24>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   19eca:	6803      	ldr	r3, [r0, #0]
   19ecc:	b11b      	cbz	r3, 19ed6 <prvCopyDataToQueue+0x18>
BaseType_t xReturn = pdFALSE;
   19ece:	2000      	movs	r0, #0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   19ed0:	3501      	adds	r5, #1
   19ed2:	63a5      	str	r5, [r4, #56]	; 0x38
}
   19ed4:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
   19ed6:	6880      	ldr	r0, [r0, #8]
   19ed8:	f7ff fb22 	bl	19520 <xTaskPriorityDisinherit>
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
   19edc:	2300      	movs	r3, #0
   19ede:	60a3      	str	r3, [r4, #8]
   19ee0:	e7f6      	b.n	19ed0 <prvCopyDataToQueue+0x12>
	else if( xPosition == queueSEND_TO_BACK )
   19ee2:	b96e      	cbnz	r6, 19f00 <prvCopyDataToQueue+0x42>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
   19ee4:	6840      	ldr	r0, [r0, #4]
   19ee6:	f007 f94b 	bl	21180 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
   19eea:	6863      	ldr	r3, [r4, #4]
   19eec:	6c22      	ldr	r2, [r4, #64]	; 0x40
   19eee:	4413      	add	r3, r2
   19ef0:	6063      	str	r3, [r4, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   19ef2:	68a2      	ldr	r2, [r4, #8]
   19ef4:	4293      	cmp	r3, r2
   19ef6:	d319      	bcc.n	19f2c <prvCopyDataToQueue+0x6e>
			pxQueue->pcWriteTo = pxQueue->pcHead;
   19ef8:	6823      	ldr	r3, [r4, #0]
   19efa:	6063      	str	r3, [r4, #4]
BaseType_t xReturn = pdFALSE;
   19efc:	4630      	mov	r0, r6
   19efe:	e7e7      	b.n	19ed0 <prvCopyDataToQueue+0x12>
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
   19f00:	68c0      	ldr	r0, [r0, #12]
   19f02:	f007 f93d 	bl	21180 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
   19f06:	6c22      	ldr	r2, [r4, #64]	; 0x40
   19f08:	4252      	negs	r2, r2
   19f0a:	68e3      	ldr	r3, [r4, #12]
   19f0c:	4413      	add	r3, r2
   19f0e:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   19f10:	6821      	ldr	r1, [r4, #0]
   19f12:	428b      	cmp	r3, r1
   19f14:	d202      	bcs.n	19f1c <prvCopyDataToQueue+0x5e>
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
   19f16:	68a3      	ldr	r3, [r4, #8]
   19f18:	441a      	add	r2, r3
   19f1a:	60e2      	str	r2, [r4, #12]
		if( xPosition == queueOVERWRITE )
   19f1c:	2e02      	cmp	r6, #2
   19f1e:	d001      	beq.n	19f24 <prvCopyDataToQueue+0x66>
BaseType_t xReturn = pdFALSE;
   19f20:	2000      	movs	r0, #0
   19f22:	e7d5      	b.n	19ed0 <prvCopyDataToQueue+0x12>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   19f24:	b125      	cbz	r5, 19f30 <prvCopyDataToQueue+0x72>
				--uxMessagesWaiting;
   19f26:	3d01      	subs	r5, #1
BaseType_t xReturn = pdFALSE;
   19f28:	2000      	movs	r0, #0
   19f2a:	e7d1      	b.n	19ed0 <prvCopyDataToQueue+0x12>
   19f2c:	4630      	mov	r0, r6
   19f2e:	e7cf      	b.n	19ed0 <prvCopyDataToQueue+0x12>
   19f30:	2000      	movs	r0, #0
   19f32:	e7cd      	b.n	19ed0 <prvCopyDataToQueue+0x12>

Disassembly of section .text.DRV_GMAC_Process%430:

00019f34 <DRV_GMAC_Process>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   19f34:	4b19      	ldr	r3, [pc, #100]	; (19f9c <DRV_GMAC_Process+0x68>)
   19f36:	4283      	cmp	r3, r0
   19f38:	d120      	bne.n	19f7c <DRV_GMAC_Process+0x48>
    if(pMACDrv == 0)
   19f3a:	b310      	cbz	r0, 19f82 <DRV_GMAC_Process+0x4e>
{
   19f3c:	b510      	push	{r4, lr}
	if(pMACDrv->sGmacData._synchF != 0)
   19f3e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   19f40:	b323      	cbz	r3, 19f8c <DRV_GMAC_Process+0x58>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_LOCK);
   19f42:	4c16      	ldr	r4, [pc, #88]	; (19f9c <DRV_GMAC_Process+0x68>)
   19f44:	2103      	movs	r1, #3
   19f46:	f104 0060 	add.w	r0, r4, #96	; 0x60
   19f4a:	4798      	blx	r3
        if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].queueTxEnable)
   19f4c:	f894 30ce 	ldrb.w	r3, [r4, #206]	; 0xce
   19f50:	b93b      	cbnz	r3, 19f62 <DRV_GMAC_Process+0x2e>
	if(pMACDrv->sGmacData._synchF != 0)
   19f52:	4b12      	ldr	r3, [pc, #72]	; (19f9c <DRV_GMAC_Process+0x68>)
   19f54:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   19f56:	b1bb      	cbz	r3, 19f88 <DRV_GMAC_Process+0x54>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_UNLOCK);
   19f58:	2104      	movs	r1, #4
   19f5a:	4811      	ldr	r0, [pc, #68]	; (19fa0 <DRV_GMAC_Process+0x6c>)
   19f5c:	4798      	blx	r3
	return TCPIP_MAC_RES_OK;
   19f5e:	2000      	movs	r0, #0
}
   19f60:	bd10      	pop	{r4, pc}
    GMAC_REGS->GMAC_TSR = GMAC_TSR_TXCOMP_Msk;
   19f62:	4b10      	ldr	r3, [pc, #64]	; (19fa4 <DRV_GMAC_Process+0x70>)
   19f64:	2220      	movs	r2, #32
   19f66:	615a      	str	r2, [r3, #20]
    DRV_PIC32CGMAC_LibTxAckPacket(pMACDrv,queueIdx);
   19f68:	4c0c      	ldr	r4, [pc, #48]	; (19f9c <DRV_GMAC_Process+0x68>)
   19f6a:	2100      	movs	r1, #0
   19f6c:	4620      	mov	r0, r4
   19f6e:	f7f7 fa0d 	bl	1138c <DRV_PIC32CGMAC_LibTxAckPacket>
            _MacTxPendingPackets(pMACDrv,queueIdx);            
   19f72:	2100      	movs	r1, #0
   19f74:	4620      	mov	r0, r4
   19f76:	f000 f9ad 	bl	1a2d4 <_MacTxPendingPackets>
   19f7a:	e7ea      	b.n	19f52 <DRV_GMAC_Process+0x1e>
        return TCPIP_MAC_RES_OP_ERR;
   19f7c:	f06f 0005 	mvn.w	r0, #5
   19f80:	4770      	bx	lr
   19f82:	f06f 0005 	mvn.w	r0, #5
}
   19f86:	4770      	bx	lr
	return TCPIP_MAC_RES_OK;
   19f88:	2000      	movs	r0, #0
   19f8a:	e7e9      	b.n	19f60 <DRV_GMAC_Process+0x2c>
        if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].queueTxEnable)
   19f8c:	4b03      	ldr	r3, [pc, #12]	; (19f9c <DRV_GMAC_Process+0x68>)
   19f8e:	f893 30ce 	ldrb.w	r3, [r3, #206]	; 0xce
   19f92:	2b00      	cmp	r3, #0
   19f94:	d1e5      	bne.n	19f62 <DRV_GMAC_Process+0x2e>
	return TCPIP_MAC_RES_OK;
   19f96:	2000      	movs	r0, #0
   19f98:	e7e2      	b.n	19f60 <DRV_GMAC_Process+0x2c>
   19f9a:	bf00      	nop
   19f9c:	2000d8b8 	.word	0x2000d8b8
   19fa0:	2000d918 	.word	0x2000d918
   19fa4:	42000800 	.word	0x42000800

Disassembly of section .text._ARPUpdateEntry%431:

00019fa8 <_ARPUpdateEntry>:
{
   19fa8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   19fac:	4606      	mov	r6, r0
   19fae:	460c      	mov	r4, r1
   19fb0:	4617      	mov	r7, r2
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   19fb2:	4b19      	ldr	r3, [pc, #100]	; (1a018 <_ARPUpdateEntry+0x70>)
   19fb4:	685d      	ldr	r5, [r3, #4]
   19fb6:	f007 feb5 	bl	21d24 <TCPIP_STACK_NetIxGet>
    if((arpHE->hEntry.flags.value & ARP_FLAG_ENTRY_PERM) == 0)
   19fba:	8823      	ldrh	r3, [r4, #0]
   19fbc:	f013 0f40 	tst.w	r3, #64	; 0x40
   19fc0:	d11d      	bne.n	19ffe <_ARPUpdateEntry+0x56>
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   19fc2:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   19fc6:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
        if((arpHE->hEntry.flags.value & ARP_FLAG_ENTRY_COMPLETE) == 0)
   19fca:	f013 0f80 	tst.w	r3, #128	; 0x80
   19fce:	d10e      	bne.n	19fee <_ARPUpdateEntry+0x46>
            TCPIP_Helper_ProtectedSingleListNodeRemove(&pArpDcpt->incompleteList, (SGL_LIST_NODE*)&arpHE->next);
   19fd0:	1d21      	adds	r1, r4, #4
   19fd2:	f105 002c 	add.w	r0, r5, #44	; 0x2c
   19fd6:	f005 f95f 	bl	1f298 <TCPIP_Helper_ProtectedSingleListNodeRemove>
            evType = ARP_EVENT_SOLVED;
   19fda:	f04f 0801 	mov.w	r8, #1
        _ARPSetEntry(arpHE, ARP_FLAG_ENTRY_COMPLETE, hwAdd, &pArpDcpt->completeList);
   19fde:	f105 0318 	add.w	r3, r5, #24
   19fe2:	463a      	mov	r2, r7
   19fe4:	2180      	movs	r1, #128	; 0x80
   19fe6:	4620      	mov	r0, r4
   19fe8:	f004 fd66 	bl	1eab8 <_ARPSetEntry>
   19fec:	e009      	b.n	1a002 <_ARPUpdateEntry+0x5a>
            TCPIP_Helper_ProtectedSingleListNodeRemove(&pArpDcpt->completeList, (SGL_LIST_NODE*)&arpHE->next);
   19fee:	1d21      	adds	r1, r4, #4
   19ff0:	f105 0018 	add.w	r0, r5, #24
   19ff4:	f005 f950 	bl	1f298 <TCPIP_Helper_ProtectedSingleListNodeRemove>
            evType = ARP_EVENT_UPDATED;
   19ff8:	f04f 0802 	mov.w	r8, #2
   19ffc:	e7ef      	b.n	19fde <_ARPUpdateEntry+0x36>
        evType = ARP_EVENT_PERM_UPDATE;
   19ffe:	f04f 0803 	mov.w	r8, #3
    _ARPNotifyClients(pIf, &arpHE->ipAddress, &arpHE->hwAdd, evType);
   1a002:	4643      	mov	r3, r8
   1a004:	f104 0210 	add.w	r2, r4, #16
   1a008:	f104 0108 	add.w	r1, r4, #8
   1a00c:	4630      	mov	r0, r6
   1a00e:	f002 f809 	bl	1c024 <_ARPNotifyClients>
}
   1a012:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1a016:	bf00      	nop
   1a018:	2000dfa4 	.word	0x2000dfa4

Disassembly of section .text.TCPIP_ARP_EntryRemove%432:

0001a01c <TCPIP_ARP_EntryRemove>:
    if(ipAdd == 0 || ipAdd->Val == 0)
   1a01c:	b349      	cbz	r1, 1a072 <TCPIP_ARP_EntryRemove+0x56>
{
   1a01e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1a020:	460d      	mov	r5, r1
    if(ipAdd == 0 || ipAdd->Val == 0)
   1a022:	680a      	ldr	r2, [r1, #0]
   1a024:	b342      	cbz	r2, 1a078 <TCPIP_ARP_EntryRemove+0x5c>
   1a026:	b350      	cbz	r0, 1a07e <TCPIP_ARP_EntryRemove+0x62>
   1a028:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1a02c:	f012 0f40 	tst.w	r2, #64	; 0x40
   1a030:	d102      	bne.n	1a038 <TCPIP_ARP_EntryRemove+0x1c>
        return ARP_RES_NO_INTERFACE;
   1a032:	f06f 0005 	mvn.w	r0, #5
}
   1a036:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1a038:	4604      	mov	r4, r0
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   1a03a:	4b14      	ldr	r3, [pc, #80]	; (1a08c <TCPIP_ARP_EntryRemove+0x70>)
   1a03c:	685e      	ldr	r6, [r3, #4]
   1a03e:	f007 fe71 	bl	21d24 <TCPIP_STACK_NetIxGet>
   1a042:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   1a046:	00c0      	lsls	r0, r0, #3
   1a048:	1837      	adds	r7, r6, r0
    hE = TCPIP_OAHASH_EntryLookup(pArpDcpt->hashDcpt, &ipAdd->Val);
   1a04a:	4629      	mov	r1, r5
   1a04c:	5830      	ldr	r0, [r6, r0]
   1a04e:	f000 fe99 	bl	1ad84 <TCPIP_OAHASH_EntryLookup>
    if(hE == 0)
   1a052:	4605      	mov	r5, r0
   1a054:	b1b0      	cbz	r0, 1a084 <TCPIP_ARP_EntryRemove+0x68>
    _ARPRemoveEntry(pArpDcpt, hE);
   1a056:	4601      	mov	r1, r0
   1a058:	4638      	mov	r0, r7
   1a05a:	f005 fc35 	bl	1f8c8 <_ARPRemoveEntry>
    _ARPNotifyClients(pIf, &((ARP_HASH_ENTRY*)hE)->ipAddress, 0, ARP_EVENT_REMOVED_USER);
   1a05e:	f06f 0301 	mvn.w	r3, #1
   1a062:	2200      	movs	r2, #0
   1a064:	f105 0108 	add.w	r1, r5, #8
   1a068:	4620      	mov	r0, r4
   1a06a:	f001 ffdb 	bl	1c024 <_ARPNotifyClients>
    return ARP_RES_OK;
   1a06e:	2000      	movs	r0, #0
   1a070:	e7e1      	b.n	1a036 <TCPIP_ARP_EntryRemove+0x1a>
        return ARP_RES_BAD_ADDRESS;
   1a072:	f06f 0004 	mvn.w	r0, #4
}
   1a076:	4770      	bx	lr
        return ARP_RES_BAD_ADDRESS;
   1a078:	f06f 0004 	mvn.w	r0, #4
   1a07c:	e7db      	b.n	1a036 <TCPIP_ARP_EntryRemove+0x1a>
        return ARP_RES_NO_INTERFACE;
   1a07e:	f06f 0005 	mvn.w	r0, #5
   1a082:	e7d8      	b.n	1a036 <TCPIP_ARP_EntryRemove+0x1a>
        return ARP_RES_NO_ENTRY;
   1a084:	f04f 30ff 	mov.w	r0, #4294967295
   1a088:	e7d5      	b.n	1a036 <TCPIP_ARP_EntryRemove+0x1a>
   1a08a:	bf00      	nop
   1a08c:	2000dfa4 	.word	0x2000dfa4

Disassembly of section .text.GenericTxDone%433:

0001a090 <GenericTxDone>:
{
   1a090:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1a092:	4605      	mov	r5, r0
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
   1a094:	f8d0 30c4 	ldr.w	r3, [r0, #196]	; 0xc4
   1a098:	685e      	ldr	r6, [r3, #4]
    if ( pIState->statusReported == 0u )
   1a09a:	f890 30cd 	ldrb.w	r3, [r0, #205]	; 0xcd
   1a09e:	b333      	cbz	r3, 1a0ee <GenericTxDone+0x5e>
    IperfSetState(pIState, IPERF_STANDBY_STATE);
   1a0a0:	2101      	movs	r1, #1
   1a0a2:	4628      	mov	r0, r5
   1a0a4:	f001 ffe8 	bl	1c078 <IperfSetState>
    (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf instance %d: Tx done. Socket closed.\r\n", pIState - gIperfState);
   1a0a8:	4b14      	ldr	r3, [pc, #80]	; (1a0fc <GenericTxDone+0x6c>)
   1a0aa:	1aeb      	subs	r3, r5, r3
   1a0ac:	10db      	asrs	r3, r3, #3
   1a0ae:	eb03 04c3 	add.w	r4, r3, r3, lsl #3
   1a0b2:	eb03 0344 	add.w	r3, r3, r4, lsl #1
   1a0b6:	ebc3 2343 	rsb	r3, r3, r3, lsl #9
   1a0ba:	eb03 4383 	add.w	r3, r3, r3, lsl #18
   1a0be:	425c      	negs	r4, r3
   1a0c0:	4f0f      	ldr	r7, [pc, #60]	; (1a100 <GenericTxDone+0x70>)
   1a0c2:	f8d5 30c4 	ldr.w	r3, [r5, #196]	; 0xc4
   1a0c6:	681b      	ldr	r3, [r3, #0]
   1a0c8:	685b      	ldr	r3, [r3, #4]
   1a0ca:	4622      	mov	r2, r4
   1a0cc:	f507 619f 	add.w	r1, r7, #1272	; 0x4f8
   1a0d0:	4630      	mov	r0, r6
   1a0d2:	4798      	blx	r3
    ResetIperfCounters(pIState);
   1a0d4:	4628      	mov	r0, r5
   1a0d6:	f002 fc91 	bl	1c9fc <ResetIperfCounters>
    (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf: instance %d completed.\r\n", pIState - gIperfState);
   1a0da:	f8d5 30c4 	ldr.w	r3, [r5, #196]	; 0xc4
   1a0de:	681b      	ldr	r3, [r3, #0]
   1a0e0:	685b      	ldr	r3, [r3, #4]
   1a0e2:	4622      	mov	r2, r4
   1a0e4:	f507 61a5 	add.w	r1, r7, #1320	; 0x528
   1a0e8:	4630      	mov	r0, r6
   1a0ea:	4798      	blx	r3
}
   1a0ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ReportBW_Jitter_Loss(pIState, SESSION_REPORT);
   1a0ee:	2102      	movs	r1, #2
   1a0f0:	f7f3 f930 	bl	d354 <ReportBW_Jitter_Loss>
        pIState->statusReported = 1;
   1a0f4:	2301      	movs	r3, #1
   1a0f6:	f885 30cd 	strb.w	r3, [r5, #205]	; 0xcd
   1a0fa:	e7d1      	b.n	1a0a0 <GenericTxDone+0x10>
   1a0fc:	2000d9b0 	.word	0x2000d9b0
   1a100:	000057b4 	.word	0x000057b4

Disassembly of section .text.TCPIP_DHCP_ConnectionHandler%434:

0001a104 <TCPIP_DHCP_ConnectionHandler>:
{
   1a104:	b570      	push	{r4, r5, r6, lr}
   1a106:	4605      	mov	r5, r0
   1a108:	460e      	mov	r6, r1
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   1a10a:	4b1a      	ldr	r3, [pc, #104]	; (1a174 <TCPIP_DHCP_ConnectionHandler+0x70>)
   1a10c:	681c      	ldr	r4, [r3, #0]
   1a10e:	f007 fe09 	bl	21d24 <TCPIP_STACK_NetIxGet>
    if (pClient->flags.bDHCPEnabled != 0)
   1a112:	235c      	movs	r3, #92	; 0x5c
   1a114:	fb03 4000 	mla	r0, r3, r0, r4
   1a118:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   1a11c:	f013 0101 	ands.w	r1, r3, #1
   1a120:	d011      	beq.n	1a146 <TCPIP_DHCP_ConnectionHandler+0x42>
        if (connEvent & TCPIP_MAC_EV_CONN_LOST)
   1a122:	f416 5f80 	tst.w	r6, #4096	; 0x1000
   1a126:	d10f      	bne.n	1a148 <TCPIP_DHCP_ConnectionHandler+0x44>
        else if (connEvent & TCPIP_MAC_EV_CONN_ESTABLISHED)
   1a128:	f416 6f00 	tst.w	r6, #2048	; 0x800
   1a12c:	d00b      	beq.n	1a146 <TCPIP_DHCP_ConnectionHandler+0x42>
            _DHCPEnable(pNetIf, pClient->flags.bWasBound ? TCPIP_DHCP_OPER_INIT_REBOOT : TCPIP_DHCP_OPER_INIT);
   1a12e:	f003 0310 	and.w	r3, r3, #16
   1a132:	2b00      	cmp	r3, #0
   1a134:	bf18      	it	ne
   1a136:	2102      	movne	r1, #2
   1a138:	4628      	mov	r0, r5
   1a13a:	f7fe f86d 	bl	18218 <_DHCPEnable>
            _DHCPNotifyClients(pNetIf, DHCP_EVENT_CONN_ESTABLISHED);
   1a13e:	210c      	movs	r1, #12
   1a140:	4628      	mov	r0, r5
   1a142:	f004 f807 	bl	1e154 <_DHCPNotifyClients>
}
   1a146:	bd70      	pop	{r4, r5, r6, pc}
            _DHCPClientClose(pNetIf, false, false);
   1a148:	2200      	movs	r2, #0
   1a14a:	4611      	mov	r1, r2
   1a14c:	4628      	mov	r0, r5
   1a14e:	f7fe fc6d 	bl	18a2c <_DHCPClientClose>
            _TCPIPStackSetConfigAddress(pNetIf, 0, 0, true);
   1a152:	2301      	movs	r3, #1
   1a154:	2200      	movs	r2, #0
   1a156:	4611      	mov	r1, r2
   1a158:	4628      	mov	r0, r5
   1a15a:	f004 fc44 	bl	1e9e6 <_TCPIPStackSetConfigAddress>
            TCPIP_STACK_AddressServiceEvent(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_DHCPC, TCPIP_STACK_ADDRESS_SERVICE_EVENT_CONN_LOST);
   1a15e:	2202      	movs	r2, #2
   1a160:	2101      	movs	r1, #1
   1a162:	4628      	mov	r0, r5
   1a164:	f003 fa54 	bl	1d610 <TCPIP_STACK_AddressServiceEvent>
            _DHCPNotifyClients(pNetIf, DHCP_EVENT_CONN_LOST);
   1a168:	210b      	movs	r1, #11
   1a16a:	4628      	mov	r0, r5
   1a16c:	f003 fff2 	bl	1e154 <_DHCPNotifyClients>
   1a170:	e7e9      	b.n	1a146 <TCPIP_DHCP_ConnectionHandler+0x42>
   1a172:	bf00      	nop
   1a174:	2000e408 	.word	0x2000e408

Disassembly of section .text.xTaskRemoveFromEventList%435:

0001a178 <xTaskRemoveFromEventList>:
{
   1a178:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   1a17a:	68c3      	ldr	r3, [r0, #12]
   1a17c:	68dc      	ldr	r4, [r3, #12]
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   1a17e:	f104 0518 	add.w	r5, r4, #24
   1a182:	4628      	mov	r0, r5
   1a184:	f006 fa36 	bl	205f4 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1a188:	4b12      	ldr	r3, [pc, #72]	; (1a1d4 <xTaskRemoveFromEventList+0x5c>)
   1a18a:	681b      	ldr	r3, [r3, #0]
   1a18c:	b9eb      	cbnz	r3, 1a1ca <xTaskRemoveFromEventList+0x52>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   1a18e:	1d25      	adds	r5, r4, #4
   1a190:	4628      	mov	r0, r5
   1a192:	f006 fa2f 	bl	205f4 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
   1a196:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   1a198:	4a0f      	ldr	r2, [pc, #60]	; (1a1d8 <xTaskRemoveFromEventList+0x60>)
   1a19a:	6811      	ldr	r1, [r2, #0]
   1a19c:	2301      	movs	r3, #1
   1a19e:	4083      	lsls	r3, r0
   1a1a0:	430b      	orrs	r3, r1
   1a1a2:	6013      	str	r3, [r2, #0]
   1a1a4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   1a1a8:	4629      	mov	r1, r5
   1a1aa:	4b0c      	ldr	r3, [pc, #48]	; (1a1dc <xTaskRemoveFromEventList+0x64>)
   1a1ac:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1a1b0:	f007 fb49 	bl	21846 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   1a1b4:	4b0a      	ldr	r3, [pc, #40]	; (1a1e0 <xTaskRemoveFromEventList+0x68>)
   1a1b6:	681b      	ldr	r3, [r3, #0]
   1a1b8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   1a1ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1a1bc:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
   1a1be:	bf83      	ittte	hi
   1a1c0:	2001      	movhi	r0, #1
   1a1c2:	4b08      	ldrhi	r3, [pc, #32]	; (1a1e4 <xTaskRemoveFromEventList+0x6c>)
   1a1c4:	6018      	strhi	r0, [r3, #0]
		xReturn = pdFALSE;
   1a1c6:	2000      	movls	r0, #0
}
   1a1c8:	bd38      	pop	{r3, r4, r5, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   1a1ca:	4629      	mov	r1, r5
   1a1cc:	4806      	ldr	r0, [pc, #24]	; (1a1e8 <xTaskRemoveFromEventList+0x70>)
   1a1ce:	f007 fb3a 	bl	21846 <vListInsertEnd>
   1a1d2:	e7ef      	b.n	1a1b4 <xTaskRemoveFromEventList+0x3c>
   1a1d4:	2000e4b0 	.word	0x2000e4b0
   1a1d8:	2000e4b8 	.word	0x2000e4b8
   1a1dc:	2000de80 	.word	0x2000de80
   1a1e0:	2000e49c 	.word	0x2000e49c
   1a1e4:	2000e4d4 	.word	0x2000e4d4
   1a1e8:	2000e2b4 	.word	0x2000e2b4

Disassembly of section .text.wc_GenerateSeed%436:

0001a1ec <wc_GenerateSeed>:
            return 0;
        }
    #else  /* WOLFSSL_PIC32MZ_RNG */
        /* uses the core timer, in nanoseconds to seed srand */
        int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
        {
   1a1ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1a1ee:	460f      	mov	r7, r1
   1a1f0:	4616      	mov	r6, r2
            int i;
            srand(PIC32_SEED_COUNT() * 25);
   1a1f2:	f007 ffe5 	bl	221c0 <SYS_TIME_CounterGet>
   1a1f6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   1a1fa:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   1a1fe:	f002 ffb7 	bl	1d170 <srand>

            for (i = 0; i < sz; i++ ) {
   1a202:	b35e      	cbz	r6, 1a25c <wc_GenerateSeed+0x70>
                output[i] = rand() % 256;
   1a204:	f000 fec2 	bl	1af8c <rand>
   1a208:	4243      	negs	r3, r0
   1a20a:	b2c0      	uxtb	r0, r0
   1a20c:	b2db      	uxtb	r3, r3
   1a20e:	bf58      	it	pl
   1a210:	4258      	negpl	r0, r3
   1a212:	7038      	strb	r0, [r7, #0]
                if ( (i % 8) == 7)
   1a214:	443e      	add	r6, r7
   1a216:	3e01      	subs	r6, #1
                output[i] = rand() % 256;
   1a218:	463d      	mov	r5, r7
   1a21a:	f1c7 0701 	rsb	r7, r7, #1
   1a21e:	e007      	b.n	1a230 <wc_GenerateSeed+0x44>
                    srand(PIC32_SEED_COUNT() * 25);
   1a220:	f007 ffce 	bl	221c0 <SYS_TIME_CounterGet>
   1a224:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   1a228:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   1a22c:	f002 ffa0 	bl	1d170 <srand>
   1a230:	197c      	adds	r4, r7, r5
            for (i = 0; i < sz; i++ ) {
   1a232:	42b5      	cmp	r5, r6
   1a234:	d012      	beq.n	1a25c <wc_GenerateSeed+0x70>
                output[i] = rand() % 256;
   1a236:	f000 fea9 	bl	1af8c <rand>
   1a23a:	4243      	negs	r3, r0
   1a23c:	b2c0      	uxtb	r0, r0
   1a23e:	b2db      	uxtb	r3, r3
   1a240:	bf58      	it	pl
   1a242:	4258      	negpl	r0, r3
   1a244:	f805 0f01 	strb.w	r0, [r5, #1]!
                if ( (i % 8) == 7)
   1a248:	4263      	negs	r3, r4
   1a24a:	f004 0407 	and.w	r4, r4, #7
   1a24e:	f003 0307 	and.w	r3, r3, #7
   1a252:	bf58      	it	pl
   1a254:	425c      	negpl	r4, r3
   1a256:	2c07      	cmp	r4, #7
   1a258:	d1ea      	bne.n	1a230 <wc_GenerateSeed+0x44>
   1a25a:	e7e1      	b.n	1a220 <wc_GenerateSeed+0x34>
            }
            return 0;
        }
   1a25c:	2000      	movs	r0, #0
   1a25e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.gfx_mono_draw_string%437:

0001a260 <gfx_mono_draw_string>:
 * \param[in] x         X coordinate on screen.
 * \param[in] y         Y coordinate on screen.
 * \param[in] font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
        const struct font *font) {
   1a260:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    /* Save X in order to know where to return to on CR. */
    const gfx_coord_t start_of_string_position_x = x;

    /* Sanity check on parameters, assert if str or font is NULL. */
    assert(str != NULL);
   1a264:	b130      	cbz	r0, 1a274 <gfx_mono_draw_string+0x14>
   1a266:	4617      	mov	r7, r2
   1a268:	461d      	mov	r5, r3
   1a26a:	4604      	mov	r4, r0
    assert(font != NULL);
   1a26c:	b15b      	cbz	r3, 1a286 <gfx_mono_draw_string+0x26>
   1a26e:	4688      	mov	r8, r1

    /* Draw characters until trailing null byte */
    do {
        /* Handle '\n' as newline, draw normal characters. */
        if (*str == '\n') {
            x = start_of_string_position_x;
   1a270:	460e      	mov	r6, r1
   1a272:	e019      	b.n	1a2a8 <gfx_mono_draw_string+0x48>
    assert(str != NULL);
   1a274:	4815      	ldr	r0, [pc, #84]	; (1a2cc <gfx_mono_draw_string+0x6c>)
   1a276:	f100 0328 	add.w	r3, r0, #40	; 0x28
   1a27a:	4a15      	ldr	r2, [pc, #84]	; (1a2d0 <gfx_mono_draw_string+0x70>)
   1a27c:	f240 1105 	movw	r1, #261	; 0x105
   1a280:	3008      	adds	r0, #8
   1a282:	f004 f8cf 	bl	1e424 <__assert_func>
    assert(font != NULL);
   1a286:	4811      	ldr	r0, [pc, #68]	; (1a2cc <gfx_mono_draw_string+0x6c>)
   1a288:	f100 0334 	add.w	r3, r0, #52	; 0x34
   1a28c:	4a10      	ldr	r2, [pc, #64]	; (1a2d0 <gfx_mono_draw_string+0x70>)
   1a28e:	f44f 7183 	mov.w	r1, #262	; 0x106
   1a292:	3008      	adds	r0, #8
   1a294:	f004 f8c6 	bl	1e424 <__assert_func>
            y += font->height + 1;
   1a298:	7a6a      	ldrb	r2, [r5, #9]
   1a29a:	3201      	adds	r2, #1
   1a29c:	443a      	add	r2, r7
   1a29e:	b2d7      	uxtb	r7, r2
            x = start_of_string_position_x;
   1a2a0:	46b0      	mov	r8, r6
            /* Skip '\r' characters. */
        } else {
            gfx_mono_draw_char(*str, x, y, font);
            x += font->width;
        }
    } while (*(++str));
   1a2a2:	f814 3f01 	ldrb.w	r3, [r4, #1]!
   1a2a6:	b173      	cbz	r3, 1a2c6 <gfx_mono_draw_string+0x66>
        if (*str == '\n') {
   1a2a8:	7820      	ldrb	r0, [r4, #0]
   1a2aa:	280a      	cmp	r0, #10
   1a2ac:	d0f4      	beq.n	1a298 <gfx_mono_draw_string+0x38>
        } else if (*str == '\r') {
   1a2ae:	280d      	cmp	r0, #13
   1a2b0:	d0f7      	beq.n	1a2a2 <gfx_mono_draw_string+0x42>
            gfx_mono_draw_char(*str, x, y, font);
   1a2b2:	462b      	mov	r3, r5
   1a2b4:	463a      	mov	r2, r7
   1a2b6:	4641      	mov	r1, r8
   1a2b8:	f7fc fbf6 	bl	16aa8 <gfx_mono_draw_char>
            x += font->width;
   1a2bc:	7a2b      	ldrb	r3, [r5, #8]
   1a2be:	4498      	add	r8, r3
   1a2c0:	fa5f f888 	uxtb.w	r8, r8
   1a2c4:	e7ed      	b.n	1a2a2 <gfx_mono_draw_string+0x42>
}
   1a2c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1a2ca:	bf00      	nop
   1a2cc:	0001d720 	.word	0x0001d720
   1a2d0:	0002173c 	.word	0x0002173c

Disassembly of section .text._MacTxPendingPackets%438:

0001a2d4 <_MacTxPendingPackets>:
{
   1a2d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1a2d8:	4607      	mov	r7, r0
   1a2da:	4688      	mov	r8, r1
    while((pPkt = (TCPIP_MAC_PACKET*)DRV_PIC32CGMAC_SingleListHeadRemove(&pMACDrv->sGmacData.gmac_queue[queueIdx]._TxQueue)) != 0)
   1a2dc:	262c      	movs	r6, #44	; 0x2c
   1a2de:	fb06 0601 	mla	r6, r6, r1, r0
   1a2e2:	36a4      	adds	r6, #164	; 0xa4
	DRV_PIC32CGMAC_RESULT ethRes = DRV_PIC32CGMAC_RES_NO_PACKET;    
   1a2e4:	2401      	movs	r4, #1
    while((pPkt = (TCPIP_MAC_PACKET*)DRV_PIC32CGMAC_SingleListHeadRemove(&pMACDrv->sGmacData.gmac_queue[queueIdx]._TxQueue)) != 0)
   1a2e6:	4630      	mov	r0, r6
   1a2e8:	f006 fdc2 	bl	20e70 <DRV_PIC32CGMAC_SingleListHeadRemove>
   1a2ec:	4605      	mov	r5, r0
   1a2ee:	b198      	cbz	r0, 1a318 <_MacTxPendingPackets+0x44>
		ethRes = DRV_PIC32CGMAC_LibTxSendPacket(pMACDrv,  pPkt->pDSeg, queueIdx);
   1a2f0:	4642      	mov	r2, r8
   1a2f2:	6929      	ldr	r1, [r5, #16]
   1a2f4:	4638      	mov	r0, r7
   1a2f6:	f7fa fe7d 	bl	14ff4 <DRV_PIC32CGMAC_LibTxSendPacket>
   1a2fa:	4604      	mov	r4, r0
        if(ethRes == DRV_PIC32CGMAC_RES_NO_DESCRIPTORS)
   1a2fc:	2803      	cmp	r0, #3
   1a2fe:	d1f2      	bne.n	1a2e6 <_MacTxPendingPackets+0x12>
            pMACDrv->sGmacData._txStat.nTxQueueFull++;
   1a300:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
   1a304:	3301      	adds	r3, #1
   1a306:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
            DRV_PIC32CGMAC_SingleListHeadAdd(&pMACDrv->sGmacData.gmac_queue[queueIdx]._TxQueue, (DRV_PIC32CGMAC_SGL_LIST_NODE*)pPkt); 
   1a30a:	4629      	mov	r1, r5
   1a30c:	4630      	mov	r0, r6
   1a30e:	f007 f8d1 	bl	214b4 <DRV_PIC32CGMAC_SingleListHeadAdd>
		return TCPIP_MAC_RES_PENDING;
   1a312:	2001      	movs	r0, #1
}
   1a314:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if((ethRes == DRV_PIC32CGMAC_RES_OK)||(ethRes == DRV_PIC32CGMAC_RES_NO_PACKET))
   1a318:	b2e3      	uxtb	r3, r4
   1a31a:	2b01      	cmp	r3, #1
   1a31c:	d801      	bhi.n	1a322 <_MacTxPendingPackets+0x4e>
		return TCPIP_MAC_RES_OK;
   1a31e:	2000      	movs	r0, #0
   1a320:	e7f8      	b.n	1a314 <_MacTxPendingPackets+0x40>
	else if(ethRes == DRV_PIC32CGMAC_RES_NO_DESCRIPTORS)
   1a322:	2c03      	cmp	r4, #3
		return TCPIP_MAC_RES_PENDING;
   1a324:	bf08      	it	eq
   1a326:	2001      	moveq	r0, #1
	else if(ethRes == DRV_PIC32CGMAC_RES_NO_DESCRIPTORS)
   1a328:	d0f4      	beq.n	1a314 <_MacTxPendingPackets+0x40>
		pMACDrv->sGmacData._txStat.nTxErrorPackets++;
   1a32a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
   1a32e:	3301      	adds	r3, #1
   1a330:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
		(*pMACDrv->sGmacData.pktAckF)(pPkt, TCPIP_MAC_PKT_ACK_BUFFER_ERR,TCPIP_THIS_MODULE_ID);	
   1a334:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1a336:	f241 0250 	movw	r2, #4176	; 0x1050
   1a33a:	f06f 0102 	mvn.w	r1, #2
   1a33e:	4798      	blx	r3
        return TCPIP_MAC_RES_PACKET_ERR; 
   1a340:	f06f 0009 	mvn.w	r0, #9
   1a344:	e7e6      	b.n	1a314 <_MacTxPendingPackets+0x40>

Disassembly of section .text._TCPIP_StackSyncFunction%439:

0001a346 <_TCPIP_StackSyncFunction>:
    TCPIP_PKT_FlightLogTx(ptrPacket, pNetIf->macId);    // MAC doesn't call the log function
    return pNetIf->hIfMac != 0 ? (*pNetIf->pMacObj->TCPIP_MAC_PacketTx)(pNetIf->hIfMac, ptrPacket) : TCPIP_MAC_RES_NOT_READY_ERR;
}

static bool _TCPIP_StackSyncFunction(void* synchHandle, TCPIP_MAC_SYNCH_REQUEST req)
{
   1a346:	b510      	push	{r4, lr}
    switch(req)
   1a348:	3901      	subs	r1, #1
   1a34a:	2905      	cmp	r1, #5
   1a34c:	d832      	bhi.n	1a3b4 <_TCPIP_StackSyncFunction+0x6e>
   1a34e:	e8df f001 	tbb	[pc, r1]
   1a352:	0d03      	.short	0x0d03
   1a354:	2b241d14 	.word	0x2b241d14
    {
        case TCPIP_MAC_SYNCH_REQUEST_OBJ_CREATE: 
            return (OSAL_SEM_Create((OSAL_SEM_HANDLE_TYPE*)synchHandle, OSAL_SEM_TYPE_BINARY, 1, 1) == OSAL_RESULT_TRUE) ? true : false;
   1a358:	2301      	movs	r3, #1
   1a35a:	461a      	mov	r2, r3
   1a35c:	2100      	movs	r1, #0
   1a35e:	f001 fd89 	bl	1be74 <OSAL_SEM_Create>
   1a362:	2801      	cmp	r0, #1
   1a364:	bf14      	ite	ne
   1a366:	2000      	movne	r0, #0
   1a368:	2001      	moveq	r0, #1

        default:
            return false;
    }

}
   1a36a:	bd10      	pop	{r4, pc}
            return (OSAL_SEM_Delete((OSAL_SEM_HANDLE_TYPE*)synchHandle) == OSAL_RESULT_TRUE) ? true : false;
   1a36c:	f007 fb8e 	bl	21a8c <OSAL_SEM_Delete>
   1a370:	2801      	cmp	r0, #1
   1a372:	bf14      	ite	ne
   1a374:	2000      	movne	r0, #0
   1a376:	2001      	moveq	r0, #1
   1a378:	e7f7      	b.n	1a36a <_TCPIP_StackSyncFunction+0x24>
            return (OSAL_SEM_Pend((OSAL_SEM_HANDLE_TYPE*)synchHandle, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE) ? true: false;
   1a37a:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1a37e:	f006 fd11 	bl	20da4 <OSAL_SEM_Pend>
   1a382:	2801      	cmp	r0, #1
   1a384:	bf14      	ite	ne
   1a386:	2000      	movne	r0, #0
   1a388:	2001      	moveq	r0, #1
   1a38a:	e7ee      	b.n	1a36a <_TCPIP_StackSyncFunction+0x24>
            return (OSAL_SEM_Post((OSAL_SEM_HANDLE_TYPE*)synchHandle) == OSAL_RESULT_TRUE) ? true: false;
   1a38c:	f007 f922 	bl	215d4 <OSAL_SEM_Post>
   1a390:	2801      	cmp	r0, #1
   1a392:	bf14      	ite	ne
   1a394:	2000      	movne	r0, #0
   1a396:	2001      	moveq	r0, #1
   1a398:	e7e7      	b.n	1a36a <_TCPIP_StackSyncFunction+0x24>
   1a39a:	4604      	mov	r4, r0
            *(OSAL_CRITSECT_DATA_TYPE*)synchHandle =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1a39c:	2000      	movs	r0, #0
   1a39e:	f007 f90d 	bl	215bc <OSAL_CRIT_Enter>
   1a3a2:	6020      	str	r0, [r4, #0]
            return true; 
   1a3a4:	2001      	movs	r0, #1
   1a3a6:	e7e0      	b.n	1a36a <_TCPIP_StackSyncFunction+0x24>
            OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, *(OSAL_CRITSECT_DATA_TYPE*)synchHandle);
   1a3a8:	6801      	ldr	r1, [r0, #0]
   1a3aa:	2000      	movs	r0, #0
   1a3ac:	f007 fa35 	bl	2181a <OSAL_CRIT_Leave>
            return true; 
   1a3b0:	2001      	movs	r0, #1
   1a3b2:	e7da      	b.n	1a36a <_TCPIP_StackSyncFunction+0x24>
            return false;
   1a3b4:	2000      	movs	r0, #0
   1a3b6:	e7d8      	b.n	1a36a <_TCPIP_StackSyncFunction+0x24>

Disassembly of section .text.TCPIP_PKT_DataSegmentGet%440:

0001a3b8 <TCPIP_PKT_DataSegmentGet>:
    if(srchTransport)
   1a3b8:	b34a      	cbz	r2, 1a40e <TCPIP_PKT_DataSegmentGet+0x56>
        for(pSeg = pPkt->pDSeg; pSeg != 0; pSeg = pSeg->next)
   1a3ba:	6903      	ldr	r3, [r0, #16]
   1a3bc:	2b00      	cmp	r3, #0
   1a3be:	d032      	beq.n	1a426 <TCPIP_PKT_DataSegmentGet+0x6e>
            if(pSeg->segLoad <= pPkt->pTransportLayer && pPkt->pTransportLayer <= pSeg->segLoad + pSeg->segSize)
   1a3c0:	69c0      	ldr	r0, [r0, #28]
   1a3c2:	e015      	b.n	1a3f0 <TCPIP_PKT_DataSegmentGet+0x38>
                if(pPkt->pTransportLayer <= dataAddress && dataAddress <= pSeg->segLoad + pSeg->segSize)
   1a3c4:	4288      	cmp	r0, r1
   1a3c6:	d801      	bhi.n	1a3cc <TCPIP_PKT_DataSegmentGet+0x14>
   1a3c8:	428a      	cmp	r2, r1
   1a3ca:	d20b      	bcs.n	1a3e4 <TCPIP_PKT_DataSegmentGet+0x2c>
                pStartSeg = pSeg->next;
   1a3cc:	681b      	ldr	r3, [r3, #0]
    for(pSeg = pStartSeg; pSeg != 0; pSeg = pSeg->next)
   1a3ce:	b913      	cbnz	r3, 1a3d6 <TCPIP_PKT_DataSegmentGet+0x1e>
   1a3d0:	e008      	b.n	1a3e4 <TCPIP_PKT_DataSegmentGet+0x2c>
   1a3d2:	681b      	ldr	r3, [r3, #0]
   1a3d4:	b133      	cbz	r3, 1a3e4 <TCPIP_PKT_DataSegmentGet+0x2c>
        if(pSeg->segLoad <= dataAddress && dataAddress <= pSeg->segLoad + pSeg->segSize)
   1a3d6:	689a      	ldr	r2, [r3, #8]
   1a3d8:	428a      	cmp	r2, r1
   1a3da:	d8fa      	bhi.n	1a3d2 <TCPIP_PKT_DataSegmentGet+0x1a>
   1a3dc:	89d8      	ldrh	r0, [r3, #14]
   1a3de:	4402      	add	r2, r0
   1a3e0:	4291      	cmp	r1, r2
   1a3e2:	d8f6      	bhi.n	1a3d2 <TCPIP_PKT_DataSegmentGet+0x1a>
}
   1a3e4:	4618      	mov	r0, r3
   1a3e6:	f85d 4b04 	ldr.w	r4, [sp], #4
   1a3ea:	4770      	bx	lr
        for(pSeg = pPkt->pDSeg; pSeg != 0; pSeg = pSeg->next)
   1a3ec:	681b      	ldr	r3, [r3, #0]
   1a3ee:	b1d3      	cbz	r3, 1a426 <TCPIP_PKT_DataSegmentGet+0x6e>
            if(pSeg->segLoad <= pPkt->pTransportLayer && pPkt->pTransportLayer <= pSeg->segLoad + pSeg->segSize)
   1a3f0:	689a      	ldr	r2, [r3, #8]
   1a3f2:	4282      	cmp	r2, r0
   1a3f4:	d8fa      	bhi.n	1a3ec <TCPIP_PKT_DataSegmentGet+0x34>
{
   1a3f6:	b410      	push	{r4}
            if(pSeg->segLoad <= pPkt->pTransportLayer && pPkt->pTransportLayer <= pSeg->segLoad + pSeg->segSize)
   1a3f8:	89dc      	ldrh	r4, [r3, #14]
   1a3fa:	4422      	add	r2, r4
   1a3fc:	4290      	cmp	r0, r2
   1a3fe:	d9e1      	bls.n	1a3c4 <TCPIP_PKT_DataSegmentGet+0xc>
        for(pSeg = pPkt->pDSeg; pSeg != 0; pSeg = pSeg->next)
   1a400:	681b      	ldr	r3, [r3, #0]
   1a402:	2b00      	cmp	r3, #0
   1a404:	d0ee      	beq.n	1a3e4 <TCPIP_PKT_DataSegmentGet+0x2c>
            if(pSeg->segLoad <= pPkt->pTransportLayer && pPkt->pTransportLayer <= pSeg->segLoad + pSeg->segSize)
   1a406:	689a      	ldr	r2, [r3, #8]
   1a408:	4282      	cmp	r2, r0
   1a40a:	d8f9      	bhi.n	1a400 <TCPIP_PKT_DataSegmentGet+0x48>
   1a40c:	e7f4      	b.n	1a3f8 <TCPIP_PKT_DataSegmentGet+0x40>
        pStartSeg = pPkt->pDSeg;
   1a40e:	6903      	ldr	r3, [r0, #16]
    for(pSeg = pStartSeg; pSeg != 0; pSeg = pSeg->next)
   1a410:	b913      	cbnz	r3, 1a418 <TCPIP_PKT_DataSegmentGet+0x60>
   1a412:	e008      	b.n	1a426 <TCPIP_PKT_DataSegmentGet+0x6e>
   1a414:	681b      	ldr	r3, [r3, #0]
   1a416:	b133      	cbz	r3, 1a426 <TCPIP_PKT_DataSegmentGet+0x6e>
        if(pSeg->segLoad <= dataAddress && dataAddress <= pSeg->segLoad + pSeg->segSize)
   1a418:	689a      	ldr	r2, [r3, #8]
   1a41a:	428a      	cmp	r2, r1
   1a41c:	d8fa      	bhi.n	1a414 <TCPIP_PKT_DataSegmentGet+0x5c>
   1a41e:	89d8      	ldrh	r0, [r3, #14]
   1a420:	4402      	add	r2, r0
   1a422:	4291      	cmp	r1, r2
   1a424:	d8f6      	bhi.n	1a414 <TCPIP_PKT_DataSegmentGet+0x5c>
}
   1a426:	4618      	mov	r0, r3
   1a428:	4770      	bx	lr

Disassembly of section .text.Hash_DRBG_Instantiate%441:

0001a42a <Hash_DRBG_Instantiate>:
{
   1a42a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1a42e:	b084      	sub	sp, #16
   1a430:	4604      	mov	r4, r0
   1a432:	460e      	mov	r6, r1
   1a434:	4617      	mov	r7, r2
   1a436:	4698      	mov	r8, r3
    XMEMSET(drbg, 0, sizeof(DRBG_internal));
   1a438:	2284      	movs	r2, #132	; 0x84
   1a43a:	2100      	movs	r1, #0
   1a43c:	f007 fc26 	bl	21c8c <memset>
    drbg->heap = heap;
   1a440:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1a442:	67a3      	str	r3, [r4, #120]	; 0x78
    drbg->devId = devId;
   1a444:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1a446:	67e3      	str	r3, [r4, #124]	; 0x7c
    if (Hash_df(drbg, drbg->V, sizeof(drbg->V), drbgInitV, seed, seedSz,
   1a448:	f104 0508 	add.w	r5, r4, #8
   1a44c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1a44e:	9303      	str	r3, [sp, #12]
   1a450:	f8cd 8008 	str.w	r8, [sp, #8]
   1a454:	9701      	str	r7, [sp, #4]
   1a456:	9600      	str	r6, [sp, #0]
   1a458:	2304      	movs	r3, #4
   1a45a:	2237      	movs	r2, #55	; 0x37
   1a45c:	4629      	mov	r1, r5
   1a45e:	4620      	mov	r0, r4
   1a460:	f7f7 fd9e 	bl	11fa0 <Hash_df>
   1a464:	b120      	cbz	r0, 1a470 <Hash_DRBG_Instantiate+0x46>
    int ret = DRBG_FAILURE;
   1a466:	2301      	movs	r3, #1
}
   1a468:	4618      	mov	r0, r3
   1a46a:	b004      	add	sp, #16
   1a46c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        Hash_df(drbg, drbg->C, sizeof(drbg->C), drbgInitC, drbg->V,
   1a470:	2300      	movs	r3, #0
   1a472:	9303      	str	r3, [sp, #12]
   1a474:	9302      	str	r3, [sp, #8]
   1a476:	2237      	movs	r2, #55	; 0x37
   1a478:	9201      	str	r2, [sp, #4]
   1a47a:	9500      	str	r5, [sp, #0]
   1a47c:	f104 013f 	add.w	r1, r4, #63	; 0x3f
   1a480:	4620      	mov	r0, r4
   1a482:	f7f7 fd8d 	bl	11fa0 <Hash_df>
                                              nonce, nonceSz) == DRBG_SUCCESS &&
   1a486:	4603      	mov	r3, r0
   1a488:	b930      	cbnz	r0, 1a498 <Hash_DRBG_Instantiate+0x6e>
        drbg->reseedCtr = 1;
   1a48a:	2201      	movs	r2, #1
   1a48c:	6022      	str	r2, [r4, #0]
        drbg->lastBlock = 0;
   1a48e:	2200      	movs	r2, #0
   1a490:	6062      	str	r2, [r4, #4]
        drbg->matchCount = 0;
   1a492:	f884 2080 	strb.w	r2, [r4, #128]	; 0x80
        ret = DRBG_SUCCESS;
   1a496:	e7e7      	b.n	1a468 <Hash_DRBG_Instantiate+0x3e>
    int ret = DRBG_FAILURE;
   1a498:	2301      	movs	r3, #1
    return ret;
   1a49a:	e7e5      	b.n	1a468 <Hash_DRBG_Instantiate+0x3e>

Disassembly of section .text.DRV_GMAC_EventAcknowledge%442:

0001a49c <DRV_GMAC_EventAcknowledge>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1a49c:	4b1a      	ldr	r3, [pc, #104]	; (1a508 <DRV_GMAC_EventAcknowledge+0x6c>)
   1a49e:	4283      	cmp	r3, r0
   1a4a0:	d12d      	bne.n	1a4fe <DRV_GMAC_EventAcknowledge+0x62>
    if(pMACDrv == 0)
   1a4a2:	b370      	cbz	r0, 1a502 <DRV_GMAC_EventAcknowledge+0x66>
	if(pDcpt->_TcpEnabledEvents != 0)
   1a4a4:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
   1a4a8:	b90b      	cbnz	r3, 1a4ae <DRV_GMAC_EventAcknowledge+0x12>
	return false;
   1a4aa:	2000      	movs	r0, #0
}
   1a4ac:	4770      	bx	lr
{
   1a4ae:	b570      	push	{r4, r5, r6, lr}
   1a4b0:	b082      	sub	sp, #8
   1a4b2:	460c      	mov	r4, r1
		ethAckEv=_XtlEventsTcp2Eth(tcpAckEv);
   1a4b4:	4608      	mov	r0, r1
   1a4b6:	f005 f83f 	bl	1f538 <_XtlEventsTcp2Eth>
   1a4ba:	4606      	mov	r6, r0
        DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, intStat);
   1a4bc:	4d12      	ldr	r5, [pc, #72]	; (1a508 <DRV_GMAC_EventAcknowledge+0x6c>)
   1a4be:	aa01      	add	r2, sp, #4
   1a4c0:	213f      	movs	r1, #63	; 0x3f
   1a4c2:	4628      	mov	r0, r5
   1a4c4:	f005 ff96 	bl	203f4 <DRV_PIC32CGMAC_LibSysInt_Disable>
		pDcpt->_TcpPendingEvents &= ~tcpAckEv;         // no longer pending
   1a4c8:	f8b5 104e 	ldrh.w	r1, [r5, #78]	; 0x4e
   1a4cc:	ea21 0104 	bic.w	r1, r1, r4
   1a4d0:	f8a5 104e 	strh.w	r1, [r5, #78]	; 0x4e
		pDcpt->_EthPendingEvents &= ~ethAckEv;         // no longer pending
   1a4d4:	f8b5 3052 	ldrh.w	r3, [r5, #82]	; 0x52
   1a4d8:	ea23 0306 	bic.w	r3, r3, r6
   1a4dc:	f8a5 3052 	strh.w	r3, [r5, #82]	; 0x52
            DRV_PIC32CGMAC_LibReadInterruptStatus(queIdx);
   1a4e0:	2000      	movs	r0, #0
   1a4e2:	f007 fd55 	bl	21f90 <DRV_PIC32CGMAC_LibReadInterruptStatus>
            DRV_PIC32CGMAC_LibEnableInterrupt(queIdx, ethAckEv);
   1a4e6:	4631      	mov	r1, r6
   1a4e8:	2000      	movs	r0, #0
   1a4ea:	f007 fd57 	bl	21f9c <DRV_PIC32CGMAC_LibEnableInterrupt>
        DRV_PIC32CGMAC_LibSysInt_Restore(pMACDrv, GMAC_ALL_QUE_MASK, intStat);
   1a4ee:	aa01      	add	r2, sp, #4
   1a4f0:	213f      	movs	r1, #63	; 0x3f
   1a4f2:	4628      	mov	r0, r5
   1a4f4:	f006 ffea 	bl	214cc <DRV_PIC32CGMAC_LibSysInt_Restore>
		return true;
   1a4f8:	2001      	movs	r0, #1
}
   1a4fa:	b002      	add	sp, #8
   1a4fc:	bd70      	pop	{r4, r5, r6, pc}
        return false;
   1a4fe:	2000      	movs	r0, #0
   1a500:	4770      	bx	lr
   1a502:	2000      	movs	r0, #0
   1a504:	4770      	bx	lr
   1a506:	bf00      	nop
   1a508:	2000d8b8 	.word	0x2000d8b8

Disassembly of section .text.DRV_GMAC_Tasks_ISR%443:

0001a50c <DRV_GMAC_Tasks_ISR>:
{
   1a50c:	b538      	push	{r3, r4, r5, lr}
	currGroupEvents = ((GMAC_EVENTS)currEthEvents) & pDcpt->_EthEnabledEvents;
   1a50e:	ebc0 1240 	rsb	r2, r0, r0, lsl #5
   1a512:	4b19      	ldr	r3, [pc, #100]	; (1a578 <DRV_GMAC_Tasks_ISR+0x6c>)
   1a514:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   1a518:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
	if(currGroupEvents)
   1a51c:	4019      	ands	r1, r3
   1a51e:	d02a      	beq.n	1a576 <DRV_GMAC_Tasks_ISR+0x6a>
		pDcpt->_EthPendingEvents |= currGroupEvents;                    
   1a520:	4b15      	ldr	r3, [pc, #84]	; (1a578 <DRV_GMAC_Tasks_ISR+0x6c>)
   1a522:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
   1a526:	f8b2 3052 	ldrh.w	r3, [r2, #82]	; 0x52
   1a52a:	430b      	orrs	r3, r1
   1a52c:	f8a2 3052 	strh.w	r3, [r2, #82]	; 0x52
	tcpEv |= (eEvents&(GMAC_EV_RXCOMPLETE))? TCPIP_MAC_EV_RX_DONE:0;
   1a530:	00cb      	lsls	r3, r1, #3
   1a532:	f003 0310 	and.w	r3, r3, #16
	tcpEv |= (eEvents&(GMAC_EV_RXOVERRUN))? TCPIP_MAC_EV_RX_OVFLOW:0;
   1a536:	124c      	asrs	r4, r1, #9
   1a538:	f004 0402 	and.w	r4, r4, #2
	tcpEv |= (eEvents&(GMAC_EV_RXUSEDBITREAD))? TCPIP_MAC_EV_RX_BUFNA:0; // mapping RX Used bit interrupt to BUFNA;
   1a53c:	4323      	orrs	r3, r4
   1a53e:	f001 0404 	and.w	r4, r1, #4
   1a542:	4323      	orrs	r3, r4
	tcpEv |= (eEvents&(GMAC_EV_TXFRAMECORRUPT))? TCPIP_MAC_EV_TX_BUSERR:0;
   1a544:	010c      	lsls	r4, r1, #4
   1a546:	f404 6480 	and.w	r4, r4, #1024	; 0x400
	tcpEv |= (eEvents&(GMAC_EV_RXUSEDBITREAD))? TCPIP_MAC_EV_RX_BUFNA:0; // mapping RX Used bit interrupt to BUFNA;
   1a54a:	4323      	orrs	r3, r4
    tcpEv = (eEvents&(GMAC_EV_TXCOMPLETE))? TCPIP_MAC_EV_TX_DONE:0;
   1a54c:	0049      	lsls	r1, r1, #1
   1a54e:	f401 7180 	and.w	r1, r1, #256	; 0x100
	tcpEv |= (eEvents&(GMAC_EV_RXUSEDBITREAD))? TCPIP_MAC_EV_RX_BUFNA:0; // mapping RX Used bit interrupt to BUFNA;
   1a552:	430b      	orrs	r3, r1
		pDcpt->_TcpPendingEvents |= _XtlEventsEth2Tcp(currGroupEvents);
   1a554:	f8b2 104e 	ldrh.w	r1, [r2, #78]	; 0x4e
   1a558:	430b      	orrs	r3, r1
   1a55a:	f8a2 304e 	strh.w	r3, [r2, #78]	; 0x4e
		if(pDcpt->_TcpNotifyFnc)
   1a55e:	6d54      	ldr	r4, [r2, #84]	; 0x54
   1a560:	b14c      	cbz	r4, 1a576 <DRV_GMAC_Tasks_ISR+0x6a>
			(*pDcpt->_TcpNotifyFnc)(pDcpt->_TcpPendingEvents, pDcpt->_TcpNotifyParam);     
   1a562:	4b05      	ldr	r3, [pc, #20]	; (1a578 <DRV_GMAC_Tasks_ISR+0x6c>)
   1a564:	0142      	lsls	r2, r0, #5
   1a566:	1a11      	subs	r1, r2, r0
   1a568:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
   1a56c:	f8b1 504e 	ldrh.w	r5, [r1, #78]	; 0x4e
   1a570:	6d89      	ldr	r1, [r1, #88]	; 0x58
   1a572:	4628      	mov	r0, r5
   1a574:	47a0      	blx	r4
}
   1a576:	bd38      	pop	{r3, r4, r5, pc}
   1a578:	2000d8b8 	.word	0x2000d8b8

Disassembly of section .text.TCPIP_IPV4_Cleanup%444:

0001a57c <TCPIP_IPV4_Cleanup>:
{
   1a57c:	b508      	push	{r3, lr}
    if(ipv4ArpHandle)
   1a57e:	4b14      	ldr	r3, [pc, #80]	; (1a5d0 <TCPIP_IPV4_Cleanup+0x54>)
   1a580:	6818      	ldr	r0, [r3, #0]
   1a582:	b120      	cbz	r0, 1a58e <TCPIP_IPV4_Cleanup+0x12>
        TCPIP_ARP_HandlerDeRegister(ipv4ArpHandle);
   1a584:	f005 ff7e 	bl	20484 <TCPIP_ARP_HandlerDeRegister>
        ipv4ArpHandle = 0;
   1a588:	4b11      	ldr	r3, [pc, #68]	; (1a5d0 <TCPIP_IPV4_Cleanup+0x54>)
   1a58a:	2200      	movs	r2, #0
   1a58c:	601a      	str	r2, [r3, #0]
    TCPIP_Notification_Deinitialize(&ipv4PacketFilters, ipv4MemH);
   1a58e:	4b11      	ldr	r3, [pc, #68]	; (1a5d4 <TCPIP_IPV4_Cleanup+0x58>)
   1a590:	6819      	ldr	r1, [r3, #0]
   1a592:	4811      	ldr	r0, [pc, #68]	; (1a5d8 <TCPIP_IPV4_Cleanup+0x5c>)
   1a594:	f007 fb02 	bl	21b9c <TCPIP_Notification_Deinitialize>
    ipv4ActFilterCount = 0;
   1a598:	4b10      	ldr	r3, [pc, #64]	; (1a5dc <TCPIP_IPV4_Cleanup+0x60>)
   1a59a:	2200      	movs	r2, #0
   1a59c:	601a      	str	r2, [r3, #0]
    TCPIP_Helper_ProtectedSingleListDeinitialize(&ipv4ArpQueue);
   1a59e:	4810      	ldr	r0, [pc, #64]	; (1a5e0 <TCPIP_IPV4_Cleanup+0x64>)
   1a5a0:	f004 fe62 	bl	1f268 <TCPIP_Helper_ProtectedSingleListDeinitialize>
    if(signalHandle)
   1a5a4:	4b0f      	ldr	r3, [pc, #60]	; (1a5e4 <TCPIP_IPV4_Cleanup+0x68>)
   1a5a6:	6818      	ldr	r0, [r3, #0]
   1a5a8:	b120      	cbz	r0, 1a5b4 <TCPIP_IPV4_Cleanup+0x38>
        _TCPIPStackSignalHandlerDeregister(signalHandle);
   1a5aa:	f007 fbc2 	bl	21d32 <_TCPIPStackSignalHandlerDeregister>
        signalHandle = 0;
   1a5ae:	4b0d      	ldr	r3, [pc, #52]	; (1a5e4 <TCPIP_IPV4_Cleanup+0x68>)
   1a5b0:	2200      	movs	r2, #0
   1a5b2:	601a      	str	r2, [r3, #0]
    if(ipv4ArpEntries != 0)
   1a5b4:	4b0c      	ldr	r3, [pc, #48]	; (1a5e8 <TCPIP_IPV4_Cleanup+0x6c>)
   1a5b6:	6819      	ldr	r1, [r3, #0]
   1a5b8:	b131      	cbz	r1, 1a5c8 <TCPIP_IPV4_Cleanup+0x4c>
        TCPIP_HEAP_Free(ipv4MemH, ipv4ArpEntries);
   1a5ba:	4b06      	ldr	r3, [pc, #24]	; (1a5d4 <TCPIP_IPV4_Cleanup+0x58>)
   1a5bc:	6818      	ldr	r0, [r3, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   1a5be:	68c3      	ldr	r3, [r0, #12]
   1a5c0:	4798      	blx	r3
        ipv4ArpEntries = 0;
   1a5c2:	4b09      	ldr	r3, [pc, #36]	; (1a5e8 <TCPIP_IPV4_Cleanup+0x6c>)
   1a5c4:	2200      	movs	r2, #0
   1a5c6:	601a      	str	r2, [r3, #0]
    ipv4MemH = 0;
   1a5c8:	4b02      	ldr	r3, [pc, #8]	; (1a5d4 <TCPIP_IPV4_Cleanup+0x58>)
   1a5ca:	2200      	movs	r2, #0
   1a5cc:	601a      	str	r2, [r3, #0]
}
   1a5ce:	bd08      	pop	{r3, pc}
   1a5d0:	2000e3fc 	.word	0x2000e3fc
   1a5d4:	2000e400 	.word	0x2000e400
   1a5d8:	2000e23c 	.word	0x2000e23c
   1a5dc:	2000e3f4 	.word	0x2000e3f4
   1a5e0:	2000e228 	.word	0x2000e228
   1a5e4:	2000e404 	.word	0x2000e404
   1a5e8:	2000e3f8 	.word	0x2000e3f8

Disassembly of section .text.TCPIP_Helper_CalcIPChecksum%445:

0001a5ec <TCPIP_Helper_CalcIPChecksum>:
    if(buffer == 0)
   1a5ec:	b3a0      	cbz	r0, 1a658 <TCPIP_Helper_CalcIPChecksum+0x6c>
{
   1a5ee:	b430      	push	{r4, r5}
   1a5f0:	4603      	mov	r3, r0
	sum.dw = (uint32_t)seed;
   1a5f2:	4610      	mov	r0, r2
    if ((unsigned int)buffer % 2)
   1a5f4:	f013 0501 	ands.w	r5, r3, #1
   1a5f8:	d007      	beq.n	1a60a <TCPIP_Helper_CalcIPChecksum+0x1e>
        sum.w[0] += (*(uint8_t *)buffer) << 8;
   1a5fa:	f813 4b01 	ldrb.w	r4, [r3], #1
   1a5fe:	eb02 2204 	add.w	r2, r2, r4, lsl #8
   1a602:	f362 000f 	bfi	r0, r2, #0, #16
        count--;
   1a606:	3901      	subs	r1, #1
   1a608:	b289      	uxth	r1, r1
	i = count >> 1;
   1a60a:	084a      	lsrs	r2, r1, #1
	while(i--)
   1a60c:	1e54      	subs	r4, r2, #1
   1a60e:	b2a4      	uxth	r4, r4
   1a610:	b1ca      	cbz	r2, 1a646 <TCPIP_Helper_CalcIPChecksum+0x5a>
   1a612:	3401      	adds	r4, #1
   1a614:	eb03 0444 	add.w	r4, r3, r4, lsl #1
		sum.dw += (uint32_t)*val++;
   1a618:	f833 2b02 	ldrh.w	r2, [r3], #2
   1a61c:	4410      	add	r0, r2
	while(i--)
   1a61e:	42a3      	cmp	r3, r4
   1a620:	d1fa      	bne.n	1a618 <TCPIP_Helper_CalcIPChecksum+0x2c>
	if(count & 0x1)
   1a622:	f011 0f01 	tst.w	r1, #1
		sum.dw += (uint32_t)*(uint8_t*)val;
   1a626:	bf1c      	itt	ne
   1a628:	7823      	ldrbne	r3, [r4, #0]
   1a62a:	18c0      	addne	r0, r0, r3
	sum.dw = (uint32_t)sum.w[0] + (uint32_t)sum.w[1];
   1a62c:	0c03      	lsrs	r3, r0, #16
   1a62e:	fa13 f080 	uxtah	r0, r3, r0
	sum.w[0] += sum.w[1];
   1a632:	eb00 4310 	add.w	r3, r0, r0, lsr #16
   1a636:	b29b      	uxth	r3, r3
    if ((unsigned int)buffer % 2)
   1a638:	b93d      	cbnz	r5, 1a64a <TCPIP_Helper_CalcIPChecksum+0x5e>
	sum.w[0] += sum.w[1];
   1a63a:	f363 000f 	bfi	r0, r3, #0, #16
	return ~sum.w[0];
   1a63e:	43c0      	mvns	r0, r0
   1a640:	b280      	uxth	r0, r0
}
   1a642:	bc30      	pop	{r4, r5}
   1a644:	4770      	bx	lr
	while(i--)
   1a646:	461c      	mov	r4, r3
   1a648:	e7eb      	b.n	1a622 <TCPIP_Helper_CalcIPChecksum+0x36>
        sum.w[0] = ((uint16_t)sum.b[0] << 8 ) | (uint16_t)sum.b[1];
   1a64a:	b2da      	uxtb	r2, r3
   1a64c:	0a1b      	lsrs	r3, r3, #8
   1a64e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1a652:	f363 000f 	bfi	r0, r3, #0, #16
   1a656:	e7f2      	b.n	1a63e <TCPIP_Helper_CalcIPChecksum+0x52>
        return 0;
   1a658:	2000      	movs	r0, #0
}
   1a65a:	4770      	bx	lr

Disassembly of section .text.xQueueGenericReset%446:

0001a65c <xQueueGenericReset>:
{
   1a65c:	b538      	push	{r3, r4, r5, lr}
   1a65e:	4604      	mov	r4, r0
   1a660:	460d      	mov	r5, r1
	taskENTER_CRITICAL();
   1a662:	f006 faf5 	bl	20c50 <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
   1a666:	6822      	ldr	r2, [r4, #0]
   1a668:	6c21      	ldr	r1, [r4, #64]	; 0x40
   1a66a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1a66c:	fb03 f301 	mul.w	r3, r3, r1
   1a670:	18d0      	adds	r0, r2, r3
   1a672:	60a0      	str	r0, [r4, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
   1a674:	2000      	movs	r0, #0
   1a676:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
   1a678:	6062      	str	r2, [r4, #4]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
   1a67a:	1a5b      	subs	r3, r3, r1
   1a67c:	4413      	add	r3, r2
   1a67e:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
   1a680:	23ff      	movs	r3, #255	; 0xff
   1a682:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
   1a686:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if( xNewQueue == pdFALSE )
   1a68a:	b9a5      	cbnz	r5, 1a6b6 <xQueueGenericReset+0x5a>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1a68c:	6923      	ldr	r3, [r4, #16]
   1a68e:	b91b      	cbnz	r3, 1a698 <xQueueGenericReset+0x3c>
	taskEXIT_CRITICAL();
   1a690:	f007 f9a6 	bl	219e0 <vPortExitCritical>
}
   1a694:	2001      	movs	r0, #1
   1a696:	bd38      	pop	{r3, r4, r5, pc}
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   1a698:	f104 0010 	add.w	r0, r4, #16
   1a69c:	f7ff fd6c 	bl	1a178 <xTaskRemoveFromEventList>
   1a6a0:	2800      	cmp	r0, #0
   1a6a2:	d0f5      	beq.n	1a690 <xQueueGenericReset+0x34>
					queueYIELD_IF_USING_PREEMPTION();
   1a6a4:	4b08      	ldr	r3, [pc, #32]	; (1a6c8 <xQueueGenericReset+0x6c>)
   1a6a6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1a6aa:	601a      	str	r2, [r3, #0]
   1a6ac:	f3bf 8f4f 	dsb	sy
   1a6b0:	f3bf 8f6f 	isb	sy
   1a6b4:	e7ec      	b.n	1a690 <xQueueGenericReset+0x34>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   1a6b6:	f104 0010 	add.w	r0, r4, #16
   1a6ba:	f007 f8b9 	bl	21830 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   1a6be:	f104 0024 	add.w	r0, r4, #36	; 0x24
   1a6c2:	f007 f8b5 	bl	21830 <vListInitialise>
   1a6c6:	e7e3      	b.n	1a690 <xQueueGenericReset+0x34>
   1a6c8:	e000ed04 	.word	0xe000ed04

Disassembly of section .text.prvIdleTask%447:

0001a6cc <prvIdleTask>:
{
   1a6cc:	b580      	push	{r7, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   1a6ce:	4c16      	ldr	r4, [pc, #88]	; (1a728 <prvIdleTask+0x5c>)
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   1a6d0:	4f16      	ldr	r7, [pc, #88]	; (1a72c <prvIdleTask+0x60>)
				--uxCurrentNumberOfTasks;
   1a6d2:	4e17      	ldr	r6, [pc, #92]	; (1a730 <prvIdleTask+0x64>)
				taskYIELD();
   1a6d4:	f8df 8060 	ldr.w	r8, [pc, #96]	; 1a738 <prvIdleTask+0x6c>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   1a6d8:	6823      	ldr	r3, [r4, #0]
   1a6da:	b1bb      	cbz	r3, 1a70c <prvIdleTask+0x40>
			taskENTER_CRITICAL();
   1a6dc:	f006 fab8 	bl	20c50 <vPortEnterCritical>
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   1a6e0:	68fb      	ldr	r3, [r7, #12]
   1a6e2:	68dd      	ldr	r5, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   1a6e4:	1d28      	adds	r0, r5, #4
   1a6e6:	f005 ff85 	bl	205f4 <uxListRemove>
				--uxCurrentNumberOfTasks;
   1a6ea:	6833      	ldr	r3, [r6, #0]
   1a6ec:	3b01      	subs	r3, #1
   1a6ee:	6033      	str	r3, [r6, #0]
				--uxDeletedTasksWaitingCleanUp;
   1a6f0:	6823      	ldr	r3, [r4, #0]
   1a6f2:	3b01      	subs	r3, #1
   1a6f4:	6023      	str	r3, [r4, #0]
			taskEXIT_CRITICAL();
   1a6f6:	f007 f973 	bl	219e0 <vPortExitCritical>
			vPortFree( pxTCB->pxStack );
   1a6fa:	6b28      	ldr	r0, [r5, #48]	; 0x30
   1a6fc:	f000 fed7 	bl	1b4ae <vPortFree>
			vPortFree( pxTCB );
   1a700:	4628      	mov	r0, r5
   1a702:	f000 fed4 	bl	1b4ae <vPortFree>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   1a706:	6823      	ldr	r3, [r4, #0]
   1a708:	2b00      	cmp	r3, #0
   1a70a:	d1e7      	bne.n	1a6dc <prvIdleTask+0x10>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   1a70c:	4b09      	ldr	r3, [pc, #36]	; (1a734 <prvIdleTask+0x68>)
   1a70e:	681b      	ldr	r3, [r3, #0]
   1a710:	2b01      	cmp	r3, #1
   1a712:	d9e1      	bls.n	1a6d8 <prvIdleTask+0xc>
				taskYIELD();
   1a714:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   1a718:	f8c8 3000 	str.w	r3, [r8]
   1a71c:	f3bf 8f4f 	dsb	sy
   1a720:	f3bf 8f6f 	isb	sy
   1a724:	e7d8      	b.n	1a6d8 <prvIdleTask+0xc>
   1a726:	bf00      	nop
   1a728:	2000e4ac 	.word	0x2000e4ac
   1a72c:	2000e2dc 	.word	0x2000e2dc
   1a730:	2000e4a8 	.word	0x2000e4a8
   1a734:	2000de80 	.word	0x2000de80
   1a738:	e000ed04 	.word	0xe000ed04

Disassembly of section .text.DRV_PIC32CGMAC_LibMACOpen%448:

0001a73c <DRV_PIC32CGMAC_LibMACOpen>:
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_TXEN_Msk;
   1a73c:	4b19      	ldr	r3, [pc, #100]	; (1a7a4 <DRV_PIC32CGMAC_LibMACOpen+0x68>)
   1a73e:	6818      	ldr	r0, [r3, #0]
   1a740:	f020 0008 	bic.w	r0, r0, #8
   1a744:	6018      	str	r0, [r3, #0]
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_RXEN_Msk;
   1a746:	6818      	ldr	r0, [r3, #0]
   1a748:	f020 0004 	bic.w	r0, r0, #4
   1a74c:	6018      	str	r0, [r3, #0]
	ncfgr = GMAC_REGS->GMAC_NCFGR;
   1a74e:	685b      	ldr	r3, [r3, #4]
	if(oFlags & TCPIP_ETH_OPEN_FDUPLEX)
   1a750:	f011 0f02 	tst.w	r1, #2
		ncfgr |= GMAC_NCFGR_FD_Msk ;
   1a754:	bf14      	ite	ne
   1a756:	f043 0302 	orrne.w	r3, r3, #2
		ncfgr &= ~GMAC_NCFGR_FD_Msk ;	
   1a75a:	f023 0302 	biceq.w	r3, r3, #2
	if(oFlags & TCPIP_ETH_OPEN_100)
   1a75e:	f011 0f08 	tst.w	r1, #8
		ncfgr |= GMAC_NCFGR_SPD_Msk ;
   1a762:	bf14      	ite	ne
   1a764:	f043 0301 	orrne.w	r3, r3, #1
		ncfgr &= ~GMAC_NCFGR_SPD_Msk ;
   1a768:	f023 0301 	biceq.w	r3, r3, #1
	if(pauseType & TCPIP_ETH_PAUSE_TYPE_EN_RX)
   1a76c:	f012 0f08 	tst.w	r2, #8
		ncfgr |= GMAC_NCFGR_PEN_Msk ;
   1a770:	bf14      	ite	ne
   1a772:	f443 5300 	orrne.w	r3, r3, #8192	; 0x2000
		ncfgr &= ~GMAC_NCFGR_PEN_Msk ;		
   1a776:	f423 5300 	biceq.w	r3, r3, #8192	; 0x2000
	GMAC_REGS->GMAC_NCFGR = ncfgr;
   1a77a:	4a0a      	ldr	r2, [pc, #40]	; (1a7a4 <DRV_PIC32CGMAC_LibMACOpen+0x68>)
   1a77c:	6053      	str	r3, [r2, #4]
	if(oFlags & TCPIP_ETH_OPEN_RMII)	
   1a77e:	f411 6f80 	tst.w	r1, #1024	; 0x400
        GMAC_REGS->GMAC_UR = GMAC_UR_MII(0);
   1a782:	bf19      	ittee	ne
   1a784:	4613      	movne	r3, r2
   1a786:	2200      	movne	r2, #0
        GMAC_REGS->GMAC_UR = GMAC_UR_MII(1);
   1a788:	4b06      	ldreq	r3, [pc, #24]	; (1a7a4 <DRV_PIC32CGMAC_LibMACOpen+0x68>)
   1a78a:	2201      	moveq	r2, #1
   1a78c:	60da      	str	r2, [r3, #12]
	GMAC_REGS->GMAC_NCR |= GMAC_NCR_RXEN_Msk;
   1a78e:	4b05      	ldr	r3, [pc, #20]	; (1a7a4 <DRV_PIC32CGMAC_LibMACOpen+0x68>)
   1a790:	681a      	ldr	r2, [r3, #0]
   1a792:	f042 0204 	orr.w	r2, r2, #4
   1a796:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_NCR |= GMAC_NCR_TXEN_Msk;
   1a798:	681a      	ldr	r2, [r3, #0]
   1a79a:	f042 0208 	orr.w	r2, r2, #8
   1a79e:	601a      	str	r2, [r3, #0]
}
   1a7a0:	4770      	bx	lr
   1a7a2:	bf00      	nop
   1a7a4:	42000800 	.word	0x42000800

Disassembly of section .text._AllocateRxPacket%449:

0001a7a8 <_AllocateRxPacket>:
{
	TCPIP_MAC_PACKET* pRxPkt;
    DRV_PIC32CGMAC_RESULT gmacAllocRes = DRV_PIC32CGMAC_RES_OK;
	uint8_t rxbuff_idx;
	
	for(rxbuff_idx=0; rxbuff_idx < buffer_count; rxbuff_idx++)
   1a7a8:	b371      	cbz	r1, 1a808 <_AllocateRxPacket+0x60>
{
   1a7aa:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1a7ae:	4689      	mov	r9, r1
   1a7b0:	4698      	mov	r8, r3
   1a7b2:	4606      	mov	r6, r0
        if(sticky_flag)
        {
            pRxPkt->pDSeg->segFlags |=  TCPIP_MAC_SEG_FLAG_RX_STICKY;
        }
        
		DRV_PIC32CGMAC_SingleListTailAdd(&pMACDrv->sGmacData.gmac_queue[queue_idx]._RxQueue, (DRV_PIC32CGMAC_SGL_LIST_NODE*)pRxPkt); 
   1a7b4:	272c      	movs	r7, #44	; 0x2c
   1a7b6:	fb07 0702 	mla	r7, r7, r2, r0
   1a7ba:	3794      	adds	r7, #148	; 0x94
	for(rxbuff_idx=0; rxbuff_idx < buffer_count; rxbuff_idx++)
   1a7bc:	2400      	movs	r4, #0
		pRxPkt = (*pMACDrv->sGmacData.pktAllocF)(sizeof(*pRxPkt), pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].rxBufferSize   - sizeof(TCPIP_MAC_ETHERNET_HEADER), 0);
   1a7be:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
   1a7c2:	eb00 0542 	add.w	r5, r0, r2, lsl #1
   1a7c6:	46a3      	mov	fp, r4
   1a7c8:	f04f 0a34 	mov.w	sl, #52	; 0x34
   1a7cc:	e007      	b.n	1a7de <_AllocateRxPacket+0x36>
		DRV_PIC32CGMAC_SingleListTailAdd(&pMACDrv->sGmacData.gmac_queue[queue_idx]._RxQueue, (DRV_PIC32CGMAC_SGL_LIST_NODE*)pRxPkt); 
   1a7ce:	4638      	mov	r0, r7
   1a7d0:	f006 fd0e 	bl	211f0 <DRV_PIC32CGMAC_SingleListTailAdd>
	for(rxbuff_idx=0; rxbuff_idx < buffer_count; rxbuff_idx++)
   1a7d4:	3401      	adds	r4, #1
   1a7d6:	b2e4      	uxtb	r4, r4
   1a7d8:	b2a3      	uxth	r3, r4
   1a7da:	454b      	cmp	r3, r9
   1a7dc:	d212      	bcs.n	1a804 <_AllocateRxPacket+0x5c>
		pRxPkt = (*pMACDrv->sGmacData.pktAllocF)(sizeof(*pRxPkt), pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].rxBufferSize   - sizeof(TCPIP_MAC_ETHERNET_HEADER), 0);
   1a7de:	f8b5 10cc 	ldrh.w	r1, [r5, #204]	; 0xcc
   1a7e2:	390e      	subs	r1, #14
   1a7e4:	6a73      	ldr	r3, [r6, #36]	; 0x24
   1a7e6:	465a      	mov	r2, fp
   1a7e8:	b289      	uxth	r1, r1
   1a7ea:	4650      	mov	r0, sl
   1a7ec:	4798      	blx	r3
		if(pRxPkt == NULL)
   1a7ee:	4601      	mov	r1, r0
   1a7f0:	b160      	cbz	r0, 1a80c <_AllocateRxPacket+0x64>
        if(sticky_flag)
   1a7f2:	f1b8 0f00 	cmp.w	r8, #0
   1a7f6:	d0ea      	beq.n	1a7ce <_AllocateRxPacket+0x26>
            pRxPkt->pDSeg->segFlags |=  TCPIP_MAC_SEG_FLAG_RX_STICKY;
   1a7f8:	6902      	ldr	r2, [r0, #16]
   1a7fa:	8a13      	ldrh	r3, [r2, #16]
   1a7fc:	f043 0304 	orr.w	r3, r3, #4
   1a800:	8213      	strh	r3, [r2, #16]
   1a802:	e7e4      	b.n	1a7ce <_AllocateRxPacket+0x26>
    DRV_PIC32CGMAC_RESULT gmacAllocRes = DRV_PIC32CGMAC_RES_OK;
   1a804:	2000      	movs	r0, #0
   1a806:	e003      	b.n	1a810 <_AllocateRxPacket+0x68>
   1a808:	2000      	movs	r0, #0
    }
	return gmacAllocRes;
}	
   1a80a:	4770      	bx	lr
			gmacAllocRes = DRV_PIC32CGMAC_RES_OUT_OF_MEMORY;
   1a80c:	f04f 30ff 	mov.w	r0, #4294967295
}	
   1a810:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

Disassembly of section .text.TCPIP_ICMP_Initialize%450:

0001a814 <TCPIP_ICMP_Initialize>:
{
   1a814:	b508      	push	{r3, lr}
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_UP)
   1a816:	7f03      	ldrb	r3, [r0, #28]
   1a818:	2b03      	cmp	r3, #3
   1a81a:	d021      	beq.n	1a860 <TCPIP_ICMP_Initialize+0x4c>
    if(icmpInitCount == 0)
   1a81c:	4b11      	ldr	r3, [pc, #68]	; (1a864 <TCPIP_ICMP_Initialize+0x50>)
   1a81e:	681b      	ldr	r3, [r3, #0]
   1a820:	b12b      	cbz	r3, 1a82e <TCPIP_ICMP_Initialize+0x1a>
    icmpInitCount++;
   1a822:	4a10      	ldr	r2, [pc, #64]	; (1a864 <TCPIP_ICMP_Initialize+0x50>)
   1a824:	6813      	ldr	r3, [r2, #0]
   1a826:	3301      	adds	r3, #1
   1a828:	6013      	str	r3, [r2, #0]
    return true;
   1a82a:	2001      	movs	r0, #1
}
   1a82c:	bd08      	pop	{r3, pc}
        icmpMemH = stackCtrl->memH;
   1a82e:	68c2      	ldr	r2, [r0, #12]
   1a830:	4b0d      	ldr	r3, [pc, #52]	; (1a868 <TCPIP_ICMP_Initialize+0x54>)
   1a832:	601a      	str	r2, [r3, #0]
            iniRes = (signalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_ICMP_Task, TCPIP_ICMP_TASK_TICK_RATE)) != 0;
   1a834:	2221      	movs	r2, #33	; 0x21
   1a836:	490d      	ldr	r1, [pc, #52]	; (1a86c <TCPIP_ICMP_Initialize+0x58>)
   1a838:	2006      	movs	r0, #6
   1a83a:	f002 fbc1 	bl	1cfc0 <_TCPIPStackSignalHandlerRegister>
   1a83e:	4b0c      	ldr	r3, [pc, #48]	; (1a870 <TCPIP_ICMP_Initialize+0x5c>)
   1a840:	6018      	str	r0, [r3, #0]
            if(iniRes == false)
   1a842:	b148      	cbz	r0, 1a858 <TCPIP_ICMP_Initialize+0x44>
            pIcmpEchoRequest = 0;        // one and only request (for now)
   1a844:	2300      	movs	r3, #0
   1a846:	4a0b      	ldr	r2, [pc, #44]	; (1a874 <TCPIP_ICMP_Initialize+0x60>)
   1a848:	6013      	str	r3, [r2, #0]
            icmpEchoTmo = 0;
   1a84a:	4a0b      	ldr	r2, [pc, #44]	; (1a878 <TCPIP_ICMP_Initialize+0x64>)
   1a84c:	6013      	str	r3, [r2, #0]
            iniRes = TCPIP_Notification_Initialize(&icmpRegisteredUsers);
   1a84e:	480b      	ldr	r0, [pc, #44]	; (1a87c <TCPIP_ICMP_Initialize+0x68>)
   1a850:	f007 fc99 	bl	22186 <TCPIP_Notification_Initialize>
        if(iniRes == false)
   1a854:	2800      	cmp	r0, #0
   1a856:	d1e4      	bne.n	1a822 <TCPIP_ICMP_Initialize+0xe>
            TCPIP_ICMP_Cleanup();
   1a858:	f004 fc46 	bl	1f0e8 <TCPIP_ICMP_Cleanup>
            return false;
   1a85c:	2000      	movs	r0, #0
   1a85e:	e7e5      	b.n	1a82c <TCPIP_ICMP_Initialize+0x18>
        return true;
   1a860:	2001      	movs	r0, #1
   1a862:	e7e3      	b.n	1a82c <TCPIP_ICMP_Initialize+0x18>
   1a864:	2000e37c 	.word	0x2000e37c
   1a868:	2000e380 	.word	0x2000e380
   1a86c:	0000ef15 	.word	0x0000ef15
   1a870:	2000e388 	.word	0x2000e388
   1a874:	2000e384 	.word	0x2000e384
   1a878:	2000e378 	.word	0x2000e378
   1a87c:	2000e214 	.word	0x2000e214

Disassembly of section .text._TcpCleanup%451:

0001a880 <_TcpCleanup>:
{
   1a880:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(TCBStubs)
   1a882:	4b16      	ldr	r3, [pc, #88]	; (1a8dc <_TcpCleanup+0x5c>)
   1a884:	681b      	ldr	r3, [r3, #0]
   1a886:	b1ab      	cbz	r3, 1a8b4 <_TcpCleanup+0x34>
        for(ix = 0; ix < TcpSockets; ix++)
   1a888:	4b15      	ldr	r3, [pc, #84]	; (1a8e0 <_TcpCleanup+0x60>)
   1a88a:	681b      	ldr	r3, [r3, #0]
   1a88c:	b193      	cbz	r3, 1a8b4 <_TcpCleanup+0x34>
   1a88e:	2400      	movs	r4, #0
            pSkt = TCBStubs[ix]; 
   1a890:	4e12      	ldr	r6, [pc, #72]	; (1a8dc <_TcpCleanup+0x5c>)
                _TcpAbort(pSkt, _TCP_ABORT_FLAG_SHUTDOWN, 0);
   1a892:	4627      	mov	r7, r4
        for(ix = 0; ix < TcpSockets; ix++)
   1a894:	4d12      	ldr	r5, [pc, #72]	; (1a8e0 <_TcpCleanup+0x60>)
   1a896:	e007      	b.n	1a8a8 <_TcpCleanup+0x28>
                _TcpAbort(pSkt, _TCP_ABORT_FLAG_SHUTDOWN, 0);
   1a898:	463a      	mov	r2, r7
   1a89a:	2102      	movs	r1, #2
   1a89c:	f001 fdba 	bl	1c414 <_TcpAbort>
        for(ix = 0; ix < TcpSockets; ix++)
   1a8a0:	3401      	adds	r4, #1
   1a8a2:	682b      	ldr	r3, [r5, #0]
   1a8a4:	42a3      	cmp	r3, r4
   1a8a6:	d905      	bls.n	1a8b4 <_TcpCleanup+0x34>
            pSkt = TCBStubs[ix]; 
   1a8a8:	6833      	ldr	r3, [r6, #0]
   1a8aa:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
            if(pSkt) 
   1a8ae:	2800      	cmp	r0, #0
   1a8b0:	d1f2      	bne.n	1a898 <_TcpCleanup+0x18>
   1a8b2:	e7f5      	b.n	1a8a0 <_TcpCleanup+0x20>
    TCPIP_HEAP_Free(tcpHeapH, TCBStubs);
   1a8b4:	4b0b      	ldr	r3, [pc, #44]	; (1a8e4 <_TcpCleanup+0x64>)
   1a8b6:	6818      	ldr	r0, [r3, #0]
   1a8b8:	4c08      	ldr	r4, [pc, #32]	; (1a8dc <_TcpCleanup+0x5c>)
   1a8ba:	68c3      	ldr	r3, [r0, #12]
   1a8bc:	6821      	ldr	r1, [r4, #0]
   1a8be:	4798      	blx	r3
    TCBStubs = 0;
   1a8c0:	2300      	movs	r3, #0
   1a8c2:	6023      	str	r3, [r4, #0]
    TcpSockets = 0;
   1a8c4:	4a06      	ldr	r2, [pc, #24]	; (1a8e0 <_TcpCleanup+0x60>)
   1a8c6:	6013      	str	r3, [r2, #0]
    if(tcpSignalHandle)
   1a8c8:	4b07      	ldr	r3, [pc, #28]	; (1a8e8 <_TcpCleanup+0x68>)
   1a8ca:	6818      	ldr	r0, [r3, #0]
   1a8cc:	b120      	cbz	r0, 1a8d8 <_TcpCleanup+0x58>
        _TCPIPStackSignalHandlerDeregister(tcpSignalHandle);
   1a8ce:	f007 fa30 	bl	21d32 <_TCPIPStackSignalHandlerDeregister>
        tcpSignalHandle = 0;
   1a8d2:	4b05      	ldr	r3, [pc, #20]	; (1a8e8 <_TcpCleanup+0x68>)
   1a8d4:	2200      	movs	r2, #0
   1a8d6:	601a      	str	r2, [r3, #0]
}
   1a8d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1a8da:	bf00      	nop
   1a8dc:	2000e38c 	.word	0x2000e38c
   1a8e0:	2000e390 	.word	0x2000e390
   1a8e4:	2000e394 	.word	0x2000e394
   1a8e8:	2000e3a4 	.word	0x2000e3a4

Disassembly of section .text._Command_BIOSNameSet%452:

0001a8ec <_Command_BIOSNameSet>:
{
   1a8ec:	b570      	push	{r4, r5, r6, lr}
   1a8ee:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   1a8f0:	6845      	ldr	r5, [r0, #4]
    if (argc != 3)
   1a8f2:	2903      	cmp	r1, #3
   1a8f4:	d00e      	beq.n	1a914 <_Command_BIOSNameSet+0x28>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: setbios <interface> <x.x.x.x> \r\n");
   1a8f6:	4e15      	ldr	r6, [pc, #84]	; (1a94c <_Command_BIOSNameSet+0x60>)
   1a8f8:	6803      	ldr	r3, [r0, #0]
   1a8fa:	681b      	ldr	r3, [r3, #0]
   1a8fc:	f606 41c4 	addw	r1, r6, #3268	; 0xcc4
   1a900:	4628      	mov	r0, r5
   1a902:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: setbios PIC32INT MCHPBOARD_29 \r\n");
   1a904:	6823      	ldr	r3, [r4, #0]
   1a906:	681b      	ldr	r3, [r3, #0]
   1a908:	f606 41ec 	addw	r1, r6, #3308	; 0xcec
   1a90c:	4628      	mov	r0, r5
   1a90e:	4798      	blx	r3
        return false;
   1a910:	2000      	movs	r0, #0
}
   1a912:	bd70      	pop	{r4, r5, r6, pc}
   1a914:	4616      	mov	r6, r2
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
   1a916:	6850      	ldr	r0, [r2, #4]
   1a918:	f003 f94c 	bl	1dbb4 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
   1a91c:	b170      	cbz	r0, 1a93c <_Command_BIOSNameSet+0x50>
    if(TCPIP_STACK_NetBiosNameSet(netH, argv[2]))
   1a91e:	68b1      	ldr	r1, [r6, #8]
   1a920:	f004 fb50 	bl	1efc4 <TCPIP_STACK_NetBiosNameSet>
        msg = "Set BIOS Name failed\r\n";
   1a924:	2800      	cmp	r0, #0
   1a926:	490a      	ldr	r1, [pc, #40]	; (1a950 <_Command_BIOSNameSet+0x64>)
   1a928:	f101 0314 	add.w	r3, r1, #20
   1a92c:	bf08      	it	eq
   1a92e:	4619      	moveq	r1, r3
    (*pCmdIO->pCmdApi->msg)(cmdIoParam, msg);
   1a930:	6823      	ldr	r3, [r4, #0]
   1a932:	681b      	ldr	r3, [r3, #0]
   1a934:	4628      	mov	r0, r5
   1a936:	4798      	blx	r3
    return true;
   1a938:	2001      	movs	r0, #1
   1a93a:	e7ea      	b.n	1a912 <_Command_BIOSNameSet+0x26>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   1a93c:	6823      	ldr	r3, [r4, #0]
   1a93e:	681b      	ldr	r3, [r3, #0]
   1a940:	4904      	ldr	r1, [pc, #16]	; (1a954 <_Command_BIOSNameSet+0x68>)
   1a942:	4628      	mov	r0, r5
   1a944:	4798      	blx	r3
        return false;
   1a946:	2000      	movs	r0, #0
   1a948:	e7e3      	b.n	1a912 <_Command_BIOSNameSet+0x26>
   1a94a:	bf00      	nop
   1a94c:	0000028c 	.word	0x0000028c
   1a950:	00000f24 	.word	0x00000f24
   1a954:	00000da8 	.word	0x00000da8

Disassembly of section .text.TCPIP_DNS_Disable%453:

0001a958 <TCPIP_DNS_Disable>:
    }
    return true;
}

bool TCPIP_DNS_Disable(TCPIP_NET_HANDLE hNet, bool clearCache)
{
   1a958:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    TCPIP_NET_IF* pNetIf = _TCPIPStackHandleToNet(hNet);
    TCPIP_DNS_DCPT *pDnsDcpt;

    pDnsDcpt = pgDnsDcpt;
   1a95a:	4b19      	ldr	r3, [pc, #100]	; (1a9c0 <TCPIP_DNS_Disable+0x68>)
   1a95c:	681c      	ldr	r4, [r3, #0]
    if(pDnsDcpt == 0 || pNetIf == 0)
   1a95e:	b33c      	cbz	r4, 1a9b0 <TCPIP_DNS_Disable+0x58>
   1a960:	b340      	cbz	r0, 1a9b4 <TCPIP_DNS_Disable+0x5c>
    {
        return false;
    }

    pNetIf->Flags.bIsDnsClientEnabled = false;
   1a962:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   1a966:	f36f 03c3 	bfc	r3, #3, #1
   1a96a:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
    if(pDnsDcpt->strictNet == pNetIf)
   1a96e:	6863      	ldr	r3, [r4, #4]
   1a970:	4283      	cmp	r3, r0
    {
        pDnsDcpt->strictNet = 0;
   1a972:	bf04      	itt	eq
   1a974:	2300      	moveq	r3, #0
   1a976:	6063      	streq	r3, [r4, #4]
    }
    if(pDnsDcpt->prefNet == pNetIf)
   1a978:	68a3      	ldr	r3, [r4, #8]
   1a97a:	4283      	cmp	r3, r0
    {
        pDnsDcpt->prefNet = 0;
   1a97c:	bf04      	itt	eq
   1a97e:	2300      	moveq	r3, #0
   1a980:	60a3      	streq	r3, [r4, #8]
    }

    if(clearCache)
   1a982:	b909      	cbnz	r1, 1a988 <TCPIP_DNS_Disable+0x30>
    {
        _DNS_CleanCache(pDnsDcpt);
    }

    return true;    
   1a984:	2001      	movs	r0, #1
}
   1a986:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((pOh = pDnsDcpt->hashDcpt) != 0)
   1a988:	6827      	ldr	r7, [r4, #0]
   1a98a:	b1af      	cbz	r7, 1a9b8 <TCPIP_DNS_Disable+0x60>
        for(bktIx = 0; bktIx < pOh->hEntries; bktIx++)
   1a98c:	68fb      	ldr	r3, [r7, #12]
   1a98e:	b1ab      	cbz	r3, 1a9bc <TCPIP_DNS_Disable+0x64>
   1a990:	460d      	mov	r5, r1
   1a992:	2600      	movs	r6, #0
            pE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryGet(pOh, bktIx);
   1a994:	4631      	mov	r1, r6
   1a996:	4638      	mov	r0, r7
   1a998:	f007 f86f 	bl	21a7a <TCPIP_OAHASH_EntryGet>
            _DNS_CleanCacheEntry(pDnsDcpt, pE);
   1a99c:	4601      	mov	r1, r0
   1a99e:	4620      	mov	r0, r4
   1a9a0:	f004 fe99 	bl	1f6d6 <_DNS_CleanCacheEntry>
        for(bktIx = 0; bktIx < pOh->hEntries; bktIx++)
   1a9a4:	3601      	adds	r6, #1
   1a9a6:	68fb      	ldr	r3, [r7, #12]
   1a9a8:	429e      	cmp	r6, r3
   1a9aa:	d3f3      	bcc.n	1a994 <TCPIP_DNS_Disable+0x3c>
    return true;    
   1a9ac:	4628      	mov	r0, r5
   1a9ae:	e7ea      	b.n	1a986 <TCPIP_DNS_Disable+0x2e>
        return false;
   1a9b0:	2000      	movs	r0, #0
   1a9b2:	e7e8      	b.n	1a986 <TCPIP_DNS_Disable+0x2e>
   1a9b4:	2000      	movs	r0, #0
   1a9b6:	e7e6      	b.n	1a986 <TCPIP_DNS_Disable+0x2e>
    return true;    
   1a9b8:	4608      	mov	r0, r1
   1a9ba:	e7e4      	b.n	1a986 <TCPIP_DNS_Disable+0x2e>
   1a9bc:	4608      	mov	r0, r1
   1a9be:	e7e2      	b.n	1a986 <TCPIP_DNS_Disable+0x2e>
   1a9c0:	2000e424 	.word	0x2000e424

Disassembly of section .rodata.TCPIP_STACK_MODULE_ENTRY_TBL%454:

0001a9c4 <TCPIP_STACK_MODULE_ENTRY_TBL>:
   1a9c4:	00000002 0000f0f9 0001cea1 00000003     ................
   1a9d4:	00012a81 0001641d 00000006 0001a815     .*...d..........
   1a9e4:	0001fdf5 00000009 00014091 0001221d     .........@..."..
   1a9f4:	0000000a 00011d0d 00014885 0000000c     .........H......
   1aa04:	000107a9 0001daf5 0000000f 0000e725     ............%...
   1aa14:	0001b631 0000001f 00017045 0001e74d     1.......Ep..M...
   1aa24:	00000020 00016881 0001c0cd               ....h......

Disassembly of section .text.SYS_CMD_ADDGRP%455:

0001aa30 <SYS_CMD_ADDGRP>:
{
   1aa30:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1aa34:	4605      	mov	r5, r0
   1aa36:	4688      	mov	r8, r1
   1aa38:	4616      	mov	r6, r2
   1aa3a:	461f      	mov	r7, r3
    for (i=0; i<MAX_CMD_GROUP; i++)
   1aa3c:	4b16      	ldr	r3, [pc, #88]	; (1aa98 <SYS_CMD_ADDGRP+0x68>)
    int i, groupIx = -1, emptyIx = -1;
   1aa3e:	f04f 39ff 	mov.w	r9, #4294967295
    for (i=0; i<MAX_CMD_GROUP; i++)
   1aa42:	2400      	movs	r4, #0
   1aa44:	e004      	b.n	1aa50 <SYS_CMD_ADDGRP+0x20>
   1aa46:	46a1      	mov	r9, r4
   1aa48:	3401      	adds	r4, #1
   1aa4a:	3310      	adds	r3, #16
   1aa4c:	2c08      	cmp	r4, #8
   1aa4e:	d01a      	beq.n	1aa86 <SYS_CMD_ADDGRP+0x56>
        if(_usrCmdTbl[i].pCmd == 0)
   1aa50:	685a      	ldr	r2, [r3, #4]
   1aa52:	2a00      	cmp	r2, #0
   1aa54:	d0f7      	beq.n	1aa46 <SYS_CMD_ADDGRP+0x16>
        else if(_usrCmdTbl[i].pCmd == pCmdTbl)
   1aa56:	42aa      	cmp	r2, r5
   1aa58:	d1f6      	bne.n	1aa48 <SYS_CMD_ADDGRP+0x18>
            if(strcmp(groupName, _usrCmdTbl[i].cmdGroupName) != 0)
   1aa5a:	4b0f      	ldr	r3, [pc, #60]	; (1aa98 <SYS_CMD_ADDGRP+0x68>)
   1aa5c:	eb03 1304 	add.w	r3, r3, r4, lsl #4
   1aa60:	6899      	ldr	r1, [r3, #8]
   1aa62:	4630      	mov	r0, r6
   1aa64:	f006 ffda 	bl	21a1c <strcmp>
   1aa68:	b990      	cbnz	r0, 1aa90 <SYS_CMD_ADDGRP+0x60>
    if (groupIx != -1)
   1aa6a:	f1b4 3fff 	cmp.w	r4, #4294967295
   1aa6e:	d00a      	beq.n	1aa86 <SYS_CMD_ADDGRP+0x56>
    _usrCmdTbl[insertIx].pCmd = pCmdTbl;
   1aa70:	4a09      	ldr	r2, [pc, #36]	; (1aa98 <SYS_CMD_ADDGRP+0x68>)
   1aa72:	0124      	lsls	r4, r4, #4
   1aa74:	1913      	adds	r3, r2, r4
   1aa76:	605d      	str	r5, [r3, #4]
    _usrCmdTbl[insertIx].nCmds = nCmds;
   1aa78:	f842 8004 	str.w	r8, [r2, r4]
    _usrCmdTbl[insertIx].cmdGroupName = groupName;
   1aa7c:	609e      	str	r6, [r3, #8]
    _usrCmdTbl[insertIx].cmdMenuStr = menuStr;
   1aa7e:	60df      	str	r7, [r3, #12]
    return true;
   1aa80:	2001      	movs	r0, #1
}
   1aa82:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    else if(emptyIx != -1)
   1aa86:	f1b9 3fff 	cmp.w	r9, #4294967295
   1aa8a:	d003      	beq.n	1aa94 <SYS_CMD_ADDGRP+0x64>
   1aa8c:	464c      	mov	r4, r9
   1aa8e:	e7ef      	b.n	1aa70 <SYS_CMD_ADDGRP+0x40>
                return false;
   1aa90:	2000      	movs	r0, #0
   1aa92:	e7f6      	b.n	1aa82 <SYS_CMD_ADDGRP+0x52>
        return false;
   1aa94:	2000      	movs	r0, #0
   1aa96:	e7f4      	b.n	1aa82 <SYS_CMD_ADDGRP+0x52>
   1aa98:	2000dd98 	.word	0x2000dd98

Disassembly of section .text.SYS_CONSOLE_Print%456:

0001aa9c <SYS_CONSOLE_Print>:
        return -1;
    }
}

void SYS_CONSOLE_Print(const SYS_CONSOLE_HANDLE handle, const char *format, ...)
{
   1aa9c:	b40e      	push	{r1, r2, r3}
   1aa9e:	b510      	push	{r4, lr}
   1aaa0:	b083      	sub	sp, #12
    size_t len = 0;
    va_list args = {0};
   1aaa2:	2300      	movs	r3, #0
   1aaa4:	9301      	str	r3, [sp, #4]
    SYS_CONSOLE_OBJECT_INSTANCE* pConsoleObj = SYS_CONSOLE_GET_INSTANCE(handle);
   1aaa6:	b960      	cbnz	r0, 1aac2 <SYS_CONSOLE_Print+0x26>
    if (pConsoleObj == NULL)
    {
        return;
    }

    if ((pConsoleObj->status == SYS_STATUS_UNINITIALIZED) || (pConsoleObj->devDesc == NULL))
   1aaa8:	4b14      	ldr	r3, [pc, #80]	; (1aafc <SYS_CONSOLE_Print+0x60>)
   1aaaa:	f993 3000 	ldrsb.w	r3, [r3]
   1aaae:	b143      	cbz	r3, 1aac2 <SYS_CONSOLE_Print+0x26>
   1aab0:	4b12      	ldr	r3, [pc, #72]	; (1aafc <SYS_CONSOLE_Print+0x60>)
   1aab2:	685b      	ldr	r3, [r3, #4]
   1aab4:	b12b      	cbz	r3, 1aac2 <SYS_CONSOLE_Print+0x26>
    {
        return;
    }

    /* Must protect the common print buffer from multiple threads */
    if(OSAL_MUTEX_Lock(&consolePrintBufferMutex, OSAL_WAIT_FOREVER) == OSAL_RESULT_FALSE)
   1aab6:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1aaba:	4811      	ldr	r0, [pc, #68]	; (1ab00 <SYS_CONSOLE_Print+0x64>)
   1aabc:	f006 f981 	bl	20dc2 <OSAL_MUTEX_Lock>
   1aac0:	b920      	cbnz	r0, 1aacc <SYS_CONSOLE_Print+0x30>
        pConsoleObj->devDesc->write(pConsoleObj->devIndex, consolePrintBuffer, len);
    }

    /* Release mutex */
    OSAL_MUTEX_Unlock(&consolePrintBufferMutex);
}
   1aac2:	b003      	add	sp, #12
   1aac4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1aac8:	b003      	add	sp, #12
   1aaca:	4770      	bx	lr
    va_start( args, format );
   1aacc:	ab06      	add	r3, sp, #24
   1aace:	9301      	str	r3, [sp, #4]
    len = vsnprintf(consolePrintBuffer, SYS_CONSOLE_PRINT_BUFFER_SIZE, format, args);
   1aad0:	9a05      	ldr	r2, [sp, #20]
   1aad2:	21c8      	movs	r1, #200	; 0xc8
   1aad4:	480b      	ldr	r0, [pc, #44]	; (1ab04 <SYS_CONSOLE_Print+0x68>)
   1aad6:	f006 fb6f 	bl	211b8 <vsniprintf>
    if ((len > 0) && (len < SYS_CONSOLE_PRINT_BUFFER_SIZE))
   1aada:	1e43      	subs	r3, r0, #1
   1aadc:	2bc6      	cmp	r3, #198	; 0xc6
   1aade:	d808      	bhi.n	1aaf2 <SYS_CONSOLE_Print+0x56>
        consolePrintBuffer[len] = '\0';
   1aae0:	4908      	ldr	r1, [pc, #32]	; (1ab04 <SYS_CONSOLE_Print+0x68>)
   1aae2:	2300      	movs	r3, #0
   1aae4:	540b      	strb	r3, [r1, r0]
        pConsoleObj->devDesc->write(pConsoleObj->devIndex, consolePrintBuffer, len);
   1aae6:	4b05      	ldr	r3, [pc, #20]	; (1aafc <SYS_CONSOLE_Print+0x60>)
   1aae8:	685a      	ldr	r2, [r3, #4]
   1aaea:	6954      	ldr	r4, [r2, #20]
   1aaec:	4602      	mov	r2, r0
   1aaee:	6898      	ldr	r0, [r3, #8]
   1aaf0:	47a0      	blx	r4
    OSAL_MUTEX_Unlock(&consolePrintBufferMutex);
   1aaf2:	4803      	ldr	r0, [pc, #12]	; (1ab00 <SYS_CONSOLE_Print+0x64>)
   1aaf4:	f006 fd86 	bl	21604 <OSAL_MUTEX_Unlock>
   1aaf8:	e7e3      	b.n	1aac2 <SYS_CONSOLE_Print+0x26>
   1aafa:	bf00      	nop
   1aafc:	2000e340 	.word	0x2000e340
   1ab00:	2000e474 	.word	0x2000e474
   1ab04:	2000da88 	.word	0x2000da88

Disassembly of section .text.pvPortMalloc%457:

0001ab08 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   1ab08:	b538      	push	{r3, r4, r5, lr}
   1ab0a:	4604      	mov	r4, r0
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if( portBYTE_ALIGNMENT != 1 )
	{
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
   1ab0c:	f010 0f07 	tst.w	r0, #7
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
   1ab10:	bf1c      	itt	ne
   1ab12:	f020 0407 	bicne.w	r4, r0, #7
   1ab16:	3408      	addne	r4, #8
		}
	}
	#endif

	vTaskSuspendAll();
   1ab18:	f007 f890 	bl	21c3c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
   1ab1c:	4b12      	ldr	r3, [pc, #72]	; (1ab68 <pvPortMalloc+0x60>)
   1ab1e:	681b      	ldr	r3, [r3, #0]
   1ab20:	b17b      	cbz	r3, 1ab42 <pvPortMalloc+0x3a>
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
   1ab22:	4b12      	ldr	r3, [pc, #72]	; (1ab6c <pvPortMalloc+0x64>)
   1ab24:	681b      	ldr	r3, [r3, #0]
   1ab26:	441c      	add	r4, r3
   1ab28:	f649 72f7 	movw	r2, #40951	; 0x9ff7
   1ab2c:	4294      	cmp	r4, r2
   1ab2e:	d80e      	bhi.n	1ab4e <pvPortMalloc+0x46>
   1ab30:	42a3      	cmp	r3, r4
   1ab32:	d30f      	bcc.n	1ab54 <pvPortMalloc+0x4c>
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
   1ab34:	f7fa fb46 	bl	151c4 <xTaskResumeAll>
	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
   1ab38:	f006 ffcc 	bl	21ad4 <vApplicationMallocFailedHook>
   1ab3c:	2500      	movs	r5, #0
		}
	}
	#endif

	return pvReturn;
}
   1ab3e:	4628      	mov	r0, r5
   1ab40:	bd38      	pop	{r3, r4, r5, pc}
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
   1ab42:	4a09      	ldr	r2, [pc, #36]	; (1ab68 <pvPortMalloc+0x60>)
   1ab44:	4b0a      	ldr	r3, [pc, #40]	; (1ab70 <pvPortMalloc+0x68>)
   1ab46:	f023 0307 	bic.w	r3, r3, #7
   1ab4a:	6013      	str	r3, [r2, #0]
   1ab4c:	e7e9      	b.n	1ab22 <pvPortMalloc+0x1a>
	( void ) xTaskResumeAll();
   1ab4e:	f7fa fb39 	bl	151c4 <xTaskResumeAll>
		if( pvReturn == NULL )
   1ab52:	e7f1      	b.n	1ab38 <pvPortMalloc+0x30>
			pvReturn = pucAlignedHeap + xNextFreeByte;
   1ab54:	4a04      	ldr	r2, [pc, #16]	; (1ab68 <pvPortMalloc+0x60>)
   1ab56:	6815      	ldr	r5, [r2, #0]
   1ab58:	441d      	add	r5, r3
			xNextFreeByte += xWantedSize;
   1ab5a:	4b04      	ldr	r3, [pc, #16]	; (1ab6c <pvPortMalloc+0x64>)
   1ab5c:	601c      	str	r4, [r3, #0]
	( void ) xTaskResumeAll();
   1ab5e:	f7fa fb31 	bl	151c4 <xTaskResumeAll>
		if( pvReturn == NULL )
   1ab62:	2d00      	cmp	r5, #0
   1ab64:	d1eb      	bne.n	1ab3e <pvPortMalloc+0x36>
   1ab66:	e7e7      	b.n	1ab38 <pvPortMalloc+0x30>
   1ab68:	2000e494 	.word	0x2000e494
   1ab6c:	2000e498 	.word	0x2000e498
   1ab70:	2000000c 	.word	0x2000000c

Disassembly of section .text.snprintf%458:

0001ab74 <sniprintf>:
   1ab74:	b40c      	push	{r2, r3}
   1ab76:	b530      	push	{r4, r5, lr}
   1ab78:	4b18      	ldr	r3, [pc, #96]	; (1abdc <sniprintf+0x68>)
   1ab7a:	1e0c      	subs	r4, r1, #0
   1ab7c:	b09b      	sub	sp, #108	; 0x6c
   1ab7e:	681d      	ldr	r5, [r3, #0]
   1ab80:	da08      	bge.n	1ab94 <sniprintf+0x20>
   1ab82:	238b      	movs	r3, #139	; 0x8b
   1ab84:	602b      	str	r3, [r5, #0]
   1ab86:	f04f 30ff 	mov.w	r0, #4294967295
   1ab8a:	b01b      	add	sp, #108	; 0x6c
   1ab8c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   1ab90:	b002      	add	sp, #8
   1ab92:	4770      	bx	lr
   1ab94:	f44f 7302 	mov.w	r3, #520	; 0x208
   1ab98:	f8ad 3010 	strh.w	r3, [sp, #16]
   1ab9c:	bf14      	ite	ne
   1ab9e:	f104 33ff 	addne.w	r3, r4, #4294967295
   1aba2:	4623      	moveq	r3, r4
   1aba4:	9303      	str	r3, [sp, #12]
   1aba6:	9306      	str	r3, [sp, #24]
   1aba8:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1abac:	f8ad 3012 	strh.w	r3, [sp, #18]
   1abb0:	2300      	movs	r3, #0
   1abb2:	9001      	str	r0, [sp, #4]
   1abb4:	9005      	str	r0, [sp, #20]
   1abb6:	9319      	str	r3, [sp, #100]	; 0x64
   1abb8:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   1abba:	ab1f      	add	r3, sp, #124	; 0x7c
   1abbc:	a901      	add	r1, sp, #4
   1abbe:	4628      	mov	r0, r5
   1abc0:	9300      	str	r3, [sp, #0]
   1abc2:	f7f4 fe51 	bl	f868 <_svfiprintf_r>
   1abc6:	1c43      	adds	r3, r0, #1
   1abc8:	bfbc      	itt	lt
   1abca:	238b      	movlt	r3, #139	; 0x8b
   1abcc:	602b      	strlt	r3, [r5, #0]
   1abce:	2c00      	cmp	r4, #0
   1abd0:	d0db      	beq.n	1ab8a <sniprintf+0x16>
   1abd2:	9b01      	ldr	r3, [sp, #4]
   1abd4:	2200      	movs	r2, #0
   1abd6:	701a      	strb	r2, [r3, #0]
   1abd8:	e7d7      	b.n	1ab8a <sniprintf+0x16>
   1abda:	bf00      	nop
   1abdc:	2000e4e4 	.word	0x2000e4e4

Disassembly of section .text.wc_CryptoCb_Sha256Hash%459:

0001abe0 <wc_CryptoCb_Sha256Hash>:
#endif /* !NO_SHA */

#ifndef NO_SHA256
int wc_CryptoCb_Sha256Hash(wc_Sha256* sha256, const byte* in,
    word32 inSz, byte* digest)
{
   1abe0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1abe4:	b0a6      	sub	sp, #152	; 0x98
   1abe6:	4688      	mov	r8, r1
   1abe8:	4617      	mov	r7, r2
   1abea:	461e      	mov	r6, r3
    int ret = CRYPTOCB_UNAVAILABLE;
    CryptoCb* dev;

    /* locate registered callback */
    if (sha256) {
   1abec:	4605      	mov	r5, r0
   1abee:	b308      	cbz	r0, 1ac34 <wc_CryptoCb_Sha256Hash+0x54>
        dev = wc_CryptoCb_FindDevice(sha256->devId);
   1abf0:	6f00      	ldr	r0, [r0, #112]	; 0x70
   1abf2:	f004 fc41 	bl	1f478 <wc_CryptoCb_FindDevice>
   1abf6:	4604      	mov	r4, r0
    else {
        /* locate first callback and try using it */
        dev = wc_CryptoCb_FindDeviceByIndex(0);
    }

    if (dev && dev->cb) {
   1abf8:	b30c      	cbz	r4, 1ac3e <wc_CryptoCb_Sha256Hash+0x5e>
   1abfa:	6863      	ldr	r3, [r4, #4]
   1abfc:	b313      	cbz	r3, 1ac44 <wc_CryptoCb_Sha256Hash+0x64>
        wc_CryptoInfo cryptoInfo;
        XMEMSET(&cryptoInfo, 0, sizeof(cryptoInfo));
   1abfe:	2290      	movs	r2, #144	; 0x90
   1ac00:	2100      	movs	r1, #0
   1ac02:	a802      	add	r0, sp, #8
   1ac04:	f007 f842 	bl	21c8c <memset>
        cryptoInfo.algo_type = WC_ALGO_TYPE_HASH;
   1ac08:	2301      	movs	r3, #1
   1ac0a:	9301      	str	r3, [sp, #4]
        cryptoInfo.hash.type = WC_HASH_TYPE_SHA256;
   1ac0c:	2306      	movs	r3, #6
   1ac0e:	9316      	str	r3, [sp, #88]	; 0x58
        cryptoInfo.hash.sha256 = sha256;
   1ac10:	951a      	str	r5, [sp, #104]	; 0x68
        cryptoInfo.hash.in = in;
   1ac12:	f8cd 805c 	str.w	r8, [sp, #92]	; 0x5c
        cryptoInfo.hash.inSz = inSz;
   1ac16:	9718      	str	r7, [sp, #96]	; 0x60
        cryptoInfo.hash.digest = digest;
   1ac18:	9619      	str	r6, [sp, #100]	; 0x64

        ret = dev->cb(dev->devId, &cryptoInfo, dev->ctx);
   1ac1a:	6863      	ldr	r3, [r4, #4]
   1ac1c:	68a2      	ldr	r2, [r4, #8]
   1ac1e:	a901      	add	r1, sp, #4
   1ac20:	6820      	ldr	r0, [r4, #0]
   1ac22:	4798      	blx	r3
        ret = CRYPTOCB_UNAVAILABLE;
   1ac24:	f110 0fae 	cmn.w	r0, #174	; 0xae
   1ac28:	bf08      	it	eq
   1ac2a:	f46f 7087 	mvneq.w	r0, #270	; 0x10e
    }

    return wc_CryptoCb_TranslateErrorCode(ret);
}
   1ac2e:	b026      	add	sp, #152	; 0x98
   1ac30:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        dev = wc_CryptoCb_FindDeviceByIndex(0);
   1ac34:	2000      	movs	r0, #0
   1ac36:	f002 fa53 	bl	1d0e0 <wc_CryptoCb_FindDeviceByIndex>
   1ac3a:	4604      	mov	r4, r0
   1ac3c:	e7dc      	b.n	1abf8 <wc_CryptoCb_Sha256Hash+0x18>
    int ret = CRYPTOCB_UNAVAILABLE;
   1ac3e:	f46f 7087 	mvn.w	r0, #270	; 0x10e
   1ac42:	e7f4      	b.n	1ac2e <wc_CryptoCb_Sha256Hash+0x4e>
   1ac44:	f46f 7087 	mvn.w	r0, #270	; 0x10e
    return wc_CryptoCb_TranslateErrorCode(ret);
   1ac48:	e7f1      	b.n	1ac2e <wc_CryptoCb_Sha256Hash+0x4e>

Disassembly of section .text.DRV_ETHPHY_Open%460:

0001ac4c <DRV_ETHPHY_Open>:
{
   1ac4c:	b508      	push	{r3, lr}
    if(phyInst->objInUse == false)
   1ac4e:	4b18      	ldr	r3, [pc, #96]	; (1acb0 <DRV_ETHPHY_Open+0x64>)
   1ac50:	781b      	ldrb	r3, [r3, #0]
   1ac52:	b133      	cbz	r3, 1ac62 <DRV_ETHPHY_Open+0x16>
        if(pClientObj->clientInUse == 0)
   1ac54:	4b16      	ldr	r3, [pc, #88]	; (1acb0 <DRV_ETHPHY_Open+0x64>)
   1ac56:	8b1b      	ldrh	r3, [r3, #24]
   1ac58:	4303      	orrs	r3, r0
   1ac5a:	d005      	beq.n	1ac68 <DRV_ETHPHY_Open+0x1c>
    return DRV_HANDLE_INVALID;
   1ac5c:	f04f 30ff 	mov.w	r0, #4294967295
}
   1ac60:	bd08      	pop	{r3, pc}
        return DRV_HANDLE_INVALID;
   1ac62:	f04f 30ff 	mov.w	r0, #4294967295
   1ac66:	e7fb      	b.n	1ac60 <DRV_ETHPHY_Open+0x14>
        DRV_HANDLE miimHandle = phyInst->pMiimBase->DRV_MIIM_Open(phyInst->miimIndex, DRV_IO_INTENT_SHARED);
   1ac68:	4b11      	ldr	r3, [pc, #68]	; (1acb0 <DRV_ETHPHY_Open+0x64>)
   1ac6a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   1ac6c:	6952      	ldr	r2, [r2, #20]
   1ac6e:	2100      	movs	r1, #0
   1ac70:	f8b3 0064 	ldrh.w	r0, [r3, #100]	; 0x64
   1ac74:	4790      	blx	r2
        if(miimHandle == DRV_HANDLE_INVALID)
   1ac76:	f1b0 3fff 	cmp.w	r0, #4294967295
   1ac7a:	d0f1      	beq.n	1ac60 <DRV_ETHPHY_Open+0x14>
        hClientObj->pMiimBase = phyInst->pMiimBase;
   1ac7c:	4b0c      	ldr	r3, [pc, #48]	; (1acb0 <DRV_ETHPHY_Open+0x64>)
   1ac7e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   1ac80:	629a      	str	r2, [r3, #40]	; 0x28
        hClientObj->miimHandle = miimHandle;
   1ac82:	62d8      	str	r0, [r3, #44]	; 0x2c
        hClientObj->miimOpHandle = 0;
   1ac84:	2200      	movs	r2, #0
   1ac86:	631a      	str	r2, [r3, #48]	; 0x30
        hClientObj->clientInUse    = true;
   1ac88:	2101      	movs	r1, #1
   1ac8a:	8319      	strh	r1, [r3, #24]
        hClientObj->clientIx = clientIx;
   1ac8c:	835a      	strh	r2, [r3, #26]
        hClientObj->hDriver  = phyInst;
   1ac8e:	625b      	str	r3, [r3, #36]	; 0x24
        hClientObj->ethphyId = phyInst->ethphyId;
   1ac90:	6899      	ldr	r1, [r3, #8]
   1ac92:	61d9      	str	r1, [r3, #28]
        hClientObj->operType = DRV_ETHPHY_CLIENT_OP_TYPE_NONE;
   1ac94:	869a      	strh	r2, [r3, #52]	; 0x34
        hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
   1ac96:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    hClientObj->operPhase = operPhase;
   1ac9a:	86da      	strh	r2, [r3, #54]	; 0x36
    hClientObj->operSubPhase = operSubPhase;
   1ac9c:	871a      	strh	r2, [r3, #56]	; 0x38
        phyInst->numClients++;
   1ac9e:	885a      	ldrh	r2, [r3, #2]
   1aca0:	3201      	adds	r2, #1
   1aca2:	805a      	strh	r2, [r3, #2]
        hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_READY;
   1aca4:	2202      	movs	r2, #2
   1aca6:	f883 2020 	strb.w	r2, [r3, #32]
        return ( ( DRV_HANDLE ) hClientObj );
   1acaa:	f103 0018 	add.w	r0, r3, #24
   1acae:	e7d7      	b.n	1ac60 <DRV_ETHPHY_Open+0x14>
   1acb0:	2000de18 	.word	0x2000de18

Disassembly of section .text._TcpSwapHeader%461:

0001acb4 <_TcpSwapHeader>:
	header->SourcePort      = TCPIP_Helper_ntohs(header->SourcePort);
   1acb4:	8802      	ldrh	r2, [r0, #0]
   1acb6:	0a13      	lsrs	r3, r2, #8
   1acb8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1acbc:	8003      	strh	r3, [r0, #0]
	header->DestPort        = TCPIP_Helper_ntohs(header->DestPort);
   1acbe:	8842      	ldrh	r2, [r0, #2]
   1acc0:	0a13      	lsrs	r3, r2, #8
   1acc2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1acc6:	8043      	strh	r3, [r0, #2]
	header->SeqNumber       = TCPIP_Helper_ntohl(header->SeqNumber);
   1acc8:	6843      	ldr	r3, [r0, #4]
    return (((hLong & 0x000000ff) << 24) | ((hLong & 0x0000ff00) << 8) | ((hLong & 0x00ff0000) >> 8) | ((hLong & 0xff000000) >> 24));
   1acca:	0e1a      	lsrs	r2, r3, #24
   1accc:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
   1acd0:	0219      	lsls	r1, r3, #8
   1acd2:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
   1acd6:	430a      	orrs	r2, r1
   1acd8:	0a1b      	lsrs	r3, r3, #8
   1acda:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   1acde:	4313      	orrs	r3, r2
   1ace0:	6043      	str	r3, [r0, #4]
	header->AckNumber       = TCPIP_Helper_ntohl(header->AckNumber);
   1ace2:	6883      	ldr	r3, [r0, #8]
   1ace4:	0e1a      	lsrs	r2, r3, #24
   1ace6:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
   1acea:	0219      	lsls	r1, r3, #8
   1acec:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
   1acf0:	430a      	orrs	r2, r1
   1acf2:	0a1b      	lsrs	r3, r3, #8
   1acf4:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   1acf8:	4313      	orrs	r3, r2
   1acfa:	6083      	str	r3, [r0, #8]
	header->Window          = TCPIP_Helper_ntohs(header->Window);
   1acfc:	89c2      	ldrh	r2, [r0, #14]
       return (((hShort) << 8) | ((hShort) >> 8));
   1acfe:	0a13      	lsrs	r3, r2, #8
   1ad00:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1ad04:	81c3      	strh	r3, [r0, #14]
	header->Checksum        = TCPIP_Helper_ntohs(header->Checksum);
   1ad06:	8a02      	ldrh	r2, [r0, #16]
   1ad08:	0a13      	lsrs	r3, r2, #8
   1ad0a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1ad0e:	8203      	strh	r3, [r0, #16]
	header->UrgentPointer   = TCPIP_Helper_ntohs(header->UrgentPointer);
   1ad10:	8a42      	ldrh	r2, [r0, #18]
   1ad12:	0213      	lsls	r3, r2, #8
   1ad14:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
   1ad18:	8243      	strh	r3, [r0, #18]
}
   1ad1a:	4770      	bx	lr

Disassembly of section .text._DNS_AddSelectionIf%462:

0001ad1c <_DNS_AddSelectionIf>:
    if(pIf && _DNS_NetIsValid(pIf))
   1ad1c:	b320      	cbz	r0, 1ad68 <_DNS_AddSelectionIf+0x4c>
{
   1ad1e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1ad20:	4605      	mov	r5, r0
   1ad22:	4616      	mov	r6, r2
   1ad24:	460f      	mov	r7, r1
    if(pIf && _DNS_NetIsValid(pIf))
   1ad26:	f003 fe43 	bl	1e9b0 <_DNS_NetIsValid>
   1ad2a:	4684      	mov	ip, r0
   1ad2c:	b300      	cbz	r0, 1ad70 <_DNS_AddSelectionIf+0x54>
        for(ix = 0; ix < tblEntries; ix++)
   1ad2e:	2e00      	cmp	r6, #0
   1ad30:	dd22      	ble.n	1ad78 <_DNS_AddSelectionIf+0x5c>
            if(dnsIfTbl[ix] == pIf)
   1ad32:	683c      	ldr	r4, [r7, #0]
   1ad34:	42a5      	cmp	r5, r4
   1ad36:	d01d      	beq.n	1ad74 <_DNS_AddSelectionIf+0x58>
   1ad38:	463a      	mov	r2, r7
        addIx = -1;
   1ad3a:	f04f 31ff 	mov.w	r1, #4294967295
        for(ix = 0; ix < tblEntries; ix++)
   1ad3e:	2300      	movs	r3, #0
   1ad40:	e00a      	b.n	1ad58 <_DNS_AddSelectionIf+0x3c>
            if(dnsIfTbl[ix] == 0 && addIx < 0)
   1ad42:	ea31 0121 	bics.w	r1, r1, r1, asr #32
   1ad46:	bf28      	it	cs
   1ad48:	4619      	movcs	r1, r3
        for(ix = 0; ix < tblEntries; ix++)
   1ad4a:	3301      	adds	r3, #1
   1ad4c:	429e      	cmp	r6, r3
   1ad4e:	d006      	beq.n	1ad5e <_DNS_AddSelectionIf+0x42>
            if(dnsIfTbl[ix] == pIf)
   1ad50:	f852 4f04 	ldr.w	r4, [r2, #4]!
   1ad54:	42ac      	cmp	r4, r5
   1ad56:	d00d      	beq.n	1ad74 <_DNS_AddSelectionIf+0x58>
            if(dnsIfTbl[ix] == 0 && addIx < 0)
   1ad58:	2c00      	cmp	r4, #0
   1ad5a:	d1f6      	bne.n	1ad4a <_DNS_AddSelectionIf+0x2e>
   1ad5c:	e7f1      	b.n	1ad42 <_DNS_AddSelectionIf+0x26>
        if(addIx >= 0)
   1ad5e:	2900      	cmp	r1, #0
   1ad60:	db0d      	blt.n	1ad7e <_DNS_AddSelectionIf+0x62>
            dnsIfTbl[addIx] = pIf;
   1ad62:	f847 5021 	str.w	r5, [r7, r1, lsl #2]
   1ad66:	e005      	b.n	1ad74 <_DNS_AddSelectionIf+0x58>
    return true;
   1ad68:	f04f 0c01 	mov.w	ip, #1
}
   1ad6c:	4660      	mov	r0, ip
   1ad6e:	4770      	bx	lr
    return true;
   1ad70:	f04f 0c01 	mov.w	ip, #1
}
   1ad74:	4660      	mov	r0, ip
   1ad76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return false;
   1ad78:	f04f 0c00 	mov.w	ip, #0
   1ad7c:	e7fa      	b.n	1ad74 <_DNS_AddSelectionIf+0x58>
   1ad7e:	f04f 0c00 	mov.w	ip, #0
   1ad82:	e7f7      	b.n	1ad74 <_DNS_AddSelectionIf+0x58>

Disassembly of section .text.TCPIP_OAHASH_EntryLookup%463:

0001ad84 <TCPIP_OAHASH_EntryLookup>:
{
   1ad84:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1ad88:	4605      	mov	r5, r0
   1ad8a:	4688      	mov	r8, r1
    probeStep = pOH->probeStep;
   1ad8c:	6907      	ldr	r7, [r0, #16]
    bktIx = (*pOH->hashF)(pOH, key);
   1ad8e:	6943      	ldr	r3, [r0, #20]
   1ad90:	4798      	blx	r3
    while(bkts < pOH->hEntries)
   1ad92:	68eb      	ldr	r3, [r5, #12]
   1ad94:	b33b      	cbz	r3, 1ade6 <TCPIP_OAHASH_EntryLookup+0x62>
   1ad96:	4604      	mov	r4, r0
    size_t      bkts = 0;
   1ad98:	2600      	movs	r6, #0
   1ad9a:	e007      	b.n	1adac <TCPIP_OAHASH_EntryLookup+0x28>
        bktIx += probeStep;
   1ad9c:	443c      	add	r4, r7
        if(bktIx >= pOH->hEntries)
   1ad9e:	68eb      	ldr	r3, [r5, #12]
   1ada0:	42a3      	cmp	r3, r4
            bktIx -= pOH->hEntries;
   1ada2:	bf98      	it	ls
   1ada4:	1ae4      	subls	r4, r4, r3
        bkts++;
   1ada6:	3601      	adds	r6, #1
    while(bkts < pOH->hEntries)
   1ada8:	42b3      	cmp	r3, r6
   1adaa:	d917      	bls.n	1addc <TCPIP_OAHASH_EntryLookup+0x58>
        pBkt = (OA_HASH_ENTRY*)((uint8_t*)(pOH->memBlk) + bktIx * pOH->hEntrySize);
   1adac:	68ab      	ldr	r3, [r5, #8]
   1adae:	fb03 f304 	mul.w	r3, r3, r4
   1adb2:	682a      	ldr	r2, [r5, #0]
   1adb4:	eb02 0903 	add.w	r9, r2, r3
        if(pBkt->flags.busy && (*pOH->cmpF)(pOH, pBkt, key) == 0)
   1adb8:	5cd3      	ldrb	r3, [r2, r3]
   1adba:	f013 0f01 	tst.w	r3, #1
   1adbe:	d0ed      	beq.n	1ad9c <TCPIP_OAHASH_EntryLookup+0x18>
   1adc0:	69eb      	ldr	r3, [r5, #28]
   1adc2:	4642      	mov	r2, r8
   1adc4:	4649      	mov	r1, r9
   1adc6:	4628      	mov	r0, r5
   1adc8:	4798      	blx	r3
   1adca:	2800      	cmp	r0, #0
   1adcc:	d1e6      	bne.n	1ad9c <TCPIP_OAHASH_EntryLookup+0x18>
            pBkt->flags.newEntry = 0;
   1adce:	f899 3000 	ldrb.w	r3, [r9]
   1add2:	f36f 0341 	bfc	r3, #1, #1
   1add6:	f889 3000 	strb.w	r3, [r9]
            return pBkt;
   1adda:	e001      	b.n	1ade0 <TCPIP_OAHASH_EntryLookup+0x5c>
    return 0;   // not found
   1addc:	f04f 0900 	mov.w	r9, #0
}
   1ade0:	4648      	mov	r0, r9
   1ade2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return 0;   // not found
   1ade6:	f04f 0900 	mov.w	r9, #0
   1adea:	e7f9      	b.n	1ade0 <TCPIP_OAHASH_EntryLookup+0x5c>

Disassembly of section .text._TCPIPStackInsertRxPacket%464:

0001adec <_TCPIPStackInsertRxPacket>:
{
   1adec:	b538      	push	{r3, r4, r5, lr}
   1adee:	4604      	mov	r4, r0
   1adf0:	4615      	mov	r5, r2
    pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_QUEUED;
   1adf2:	8c4a      	ldrh	r2, [r1, #34]	; 0x22
   1adf4:	f042 0208 	orr.w	r2, r2, #8
   1adf8:	844a      	strh	r2, [r1, #34]	; 0x22
    pRxPkt->pDSeg->segLen -= sizeof(TCPIP_MAC_ETHERNET_HEADER);
   1adfa:	6908      	ldr	r0, [r1, #16]
   1adfc:	8982      	ldrh	r2, [r0, #12]
   1adfe:	3a0e      	subs	r2, #14
   1ae00:	8182      	strh	r2, [r0, #12]
    pRxPkt->pktIf = pNetIf;
   1ae02:	628c      	str	r4, [r1, #40]	; 0x28
    _TCPIPStackModuleRxInsert(TCPIP_MODULE_MANAGER, pRxPkt, 0);
   1ae04:	2200      	movs	r2, #0
   1ae06:	2001      	movs	r0, #1
   1ae08:	f002 fc24 	bl	1d654 <_TCPIPStackModuleRxInsert>
    if(signal)
   1ae0c:	b905      	cbnz	r5, 1ae10 <_TCPIPStackInsertRxPacket+0x24>
}
   1ae0e:	bd38      	pop	{r3, r4, r5, pc}
    return OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
   1ae10:	2001      	movs	r0, #1
   1ae12:	f006 fbd3 	bl	215bc <OSAL_CRIT_Enter>
    pNetIf->activeEvents |= event;
   1ae16:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
   1ae1a:	f043 0310 	orr.w	r3, r3, #16
   1ae1e:	f8a4 305a 	strh.w	r3, [r4, #90]	; 0x5a
    totTcpipEventsCnt++;
   1ae22:	4a0a      	ldr	r2, [pc, #40]	; (1ae4c <_TCPIPStackInsertRxPacket+0x60>)
   1ae24:	6813      	ldr	r3, [r2, #0]
   1ae26:	3301      	adds	r3, #1
   1ae28:	6013      	str	r3, [r2, #0]
        pSigEntry->signalVal |= TCPIP_MODULE_SIGNAL_RX_PENDING;
   1ae2a:	4c09      	ldr	r4, [pc, #36]	; (1ae50 <_TCPIPStackInsertRxPacket+0x64>)
   1ae2c:	8b23      	ldrh	r3, [r4, #24]
   1ae2e:	f043 0301 	orr.w	r3, r3, #1
   1ae32:	8323      	strh	r3, [r4, #24]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, suspLevel);
   1ae34:	4601      	mov	r1, r0
   1ae36:	2001      	movs	r0, #1
   1ae38:	f006 fcef 	bl	2181a <OSAL_CRIT_Leave>
        _TCPIPSignalEntryNotify(pSigEntry, TCPIP_MODULE_SIGNAL_RX_PENDING, 0);
   1ae3c:	2200      	movs	r2, #0
   1ae3e:	2101      	movs	r1, #1
   1ae40:	f104 0010 	add.w	r0, r4, #16
   1ae44:	f006 f884 	bl	20f50 <_TCPIPSignalEntryNotify>
}
   1ae48:	e7e1      	b.n	1ae0e <_TCPIPStackInsertRxPacket+0x22>
   1ae4a:	bf00      	nop
   1ae4c:	2000e448 	.word	0x2000e448
   1ae50:	2000d1d4 	.word	0x2000d1d4

Disassembly of section .text.SYS_CONSOLE_Initialize%465:

0001ae54 <SYS_CONSOLE_Initialize>:
{
   1ae54:	b538      	push	{r3, r4, r5, lr}
   1ae56:	4605      	mov	r5, r0
   1ae58:	460c      	mov	r4, r1
    if (isConsoleMutexCreated == false)
   1ae5a:	4b15      	ldr	r3, [pc, #84]	; (1aeb0 <SYS_CONSOLE_Initialize+0x5c>)
   1ae5c:	781b      	ldrb	r3, [r3, #0]
   1ae5e:	b143      	cbz	r3, 1ae72 <SYS_CONSOLE_Initialize+0x1e>
    if (index >= SYS_CONSOLE_DEVICE_MAX_INSTANCES || init == NULL)
   1ae60:	b9fd      	cbnz	r5, 1aea2 <SYS_CONSOLE_Initialize+0x4e>
   1ae62:	b30c      	cbz	r4, 1aea8 <SYS_CONSOLE_Initialize+0x54>
    if ((pConsoleObj->status == SYS_STATUS_UNINITIALIZED) && initConfig)
   1ae64:	4b13      	ldr	r3, [pc, #76]	; (1aeb4 <SYS_CONSOLE_Initialize+0x60>)
   1ae66:	f993 3000 	ldrsb.w	r3, [r3]
   1ae6a:	b15b      	cbz	r3, 1ae84 <SYS_CONSOLE_Initialize+0x30>
    return SYS_MODULE_OBJ_INVALID;
   1ae6c:	f04f 30ff 	mov.w	r0, #4294967295
}
   1ae70:	bd38      	pop	{r3, r4, r5, pc}
        if(OSAL_MUTEX_Create(&(consolePrintBufferMutex)) != OSAL_RESULT_TRUE)
   1ae72:	4811      	ldr	r0, [pc, #68]	; (1aeb8 <SYS_CONSOLE_Initialize+0x64>)
   1ae74:	f006 fbba 	bl	215ec <OSAL_MUTEX_Create>
   1ae78:	2801      	cmp	r0, #1
   1ae7a:	d10f      	bne.n	1ae9c <SYS_CONSOLE_Initialize+0x48>
            isConsoleMutexCreated = true;
   1ae7c:	4b0c      	ldr	r3, [pc, #48]	; (1aeb0 <SYS_CONSOLE_Initialize+0x5c>)
   1ae7e:	2201      	movs	r2, #1
   1ae80:	701a      	strb	r2, [r3, #0]
   1ae82:	e7ed      	b.n	1ae60 <SYS_CONSOLE_Initialize+0xc>
        pConsoleObj->devIndex = initConfig->deviceIndex;
   1ae84:	68a0      	ldr	r0, [r4, #8]
   1ae86:	4b0b      	ldr	r3, [pc, #44]	; (1aeb4 <SYS_CONSOLE_Initialize+0x60>)
   1ae88:	6098      	str	r0, [r3, #8]
        pConsoleObj->devDesc = initConfig->consDevDesc;
   1ae8a:	6862      	ldr	r2, [r4, #4]
   1ae8c:	605a      	str	r2, [r3, #4]
        pConsoleObj->status = SYS_STATUS_READY;
   1ae8e:	2102      	movs	r1, #2
   1ae90:	7019      	strb	r1, [r3, #0]
        pConsoleObj->devDesc->init( pConsoleObj->devIndex, initConfig->deviceInitData);
   1ae92:	6853      	ldr	r3, [r2, #4]
   1ae94:	6821      	ldr	r1, [r4, #0]
   1ae96:	4798      	blx	r3
        return index;
   1ae98:	2000      	movs	r0, #0
   1ae9a:	e7e9      	b.n	1ae70 <SYS_CONSOLE_Initialize+0x1c>
            return SYS_MODULE_OBJ_INVALID;
   1ae9c:	f04f 30ff 	mov.w	r0, #4294967295
   1aea0:	e7e6      	b.n	1ae70 <SYS_CONSOLE_Initialize+0x1c>
        return SYS_MODULE_OBJ_INVALID;
   1aea2:	f04f 30ff 	mov.w	r0, #4294967295
   1aea6:	e7e3      	b.n	1ae70 <SYS_CONSOLE_Initialize+0x1c>
   1aea8:	f04f 30ff 	mov.w	r0, #4294967295
   1aeac:	e7e0      	b.n	1ae70 <SYS_CONSOLE_Initialize+0x1c>
   1aeae:	bf00      	nop
   1aeb0:	2000e50e 	.word	0x2000e50e
   1aeb4:	2000e340 	.word	0x2000e340
   1aeb8:	2000e474 	.word	0x2000e474

Disassembly of section .rodata%466:

0001aebc <.rodata%466>:
   1aebc:	43414d47 	.word	0x43414d47
   1aec0:	00000000 	.word	0x00000000
   1aec4:	5048434d 	.word	0x5048434d
   1aec8:	52414f42 	.word	0x52414f42
   1aecc:	00435f44 	.word	0x00435f44
   1aed0:	303a3030 	.word	0x303a3030
   1aed4:	35323a34 	.word	0x35323a34
   1aed8:	3a43313a 	.word	0x3a43313a
   1aedc:	303a3041 	.word	0x303a3041
   1aee0:	00000032 	.word	0x00000032
   1aee4:	2e323931 	.word	0x2e323931
   1aee8:	2e383631 	.word	0x2e383631
   1aeec:	2e303031 	.word	0x2e303031
   1aef0:	00003131 	.word	0x00003131
   1aef4:	2e353532 	.word	0x2e353532
   1aef8:	2e353532 	.word	0x2e353532
   1aefc:	2e353532 	.word	0x2e353532
   1af00:	00000030 	.word	0x00000030
   1af04:	2e323931 	.word	0x2e323931
   1af08:	2e383631 	.word	0x2e383631
   1af0c:	2e303031 	.word	0x2e303031
   1af10:	00000031 	.word	0x00000031
   1af14:	2e302e30 	.word	0x2e302e30
   1af18:	00302e30 	.word	0x00302e30
   1af1c:	6c6c7566 	.word	0x6c6c7566
   1af20:	00          	.byte	0x00
   1af21:	00          	.byte	0x00
   1af22:	bf00      	nop

Disassembly of section .text.wc_RNG_TestSeed%467:

0001af24 <wc_RNG_TestSeed>:
{
   1af24:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    word32 scratchSz = min(SEED_BLOCK_SZ, seedSz - SEED_BLOCK_SZ);
   1af28:	f1a1 0e04 	sub.w	lr, r1, #4
        return a > b ? b : a;
   1af2c:	4673      	mov	r3, lr
   1af2e:	2b04      	cmp	r3, #4
   1af30:	bf28      	it	cs
   1af32:	2304      	movcs	r3, #4
    while (seedIdx < seedSz - SEED_BLOCK_SZ) {
   1af34:	f1be 0f00 	cmp.w	lr, #0
   1af38:	d025      	beq.n	1af86 <wc_RNG_TestSeed+0x62>
   1af3a:	4684      	mov	ip, r0
    word32 seedIdx = 0;
   1af3c:	2700      	movs	r7, #0
    int ret = 0;
   1af3e:	4638      	mov	r0, r7
   1af40:	f10c 38ff 	add.w	r8, ip, #4294967295
   1af44:	e009      	b.n	1af5a <wc_RNG_TestSeed+0x36>
            ret = DRBG_CONT_FAILURE;
   1af46:	2c00      	cmp	r4, #0
   1af48:	bf08      	it	eq
   1af4a:	2003      	moveq	r0, #3
        seedIdx += SEED_BLOCK_SZ;
   1af4c:	3704      	adds	r7, #4
   1af4e:	1bcb      	subs	r3, r1, r7
   1af50:	2b04      	cmp	r3, #4
   1af52:	bf28      	it	cs
   1af54:	2304      	movcs	r3, #4
    while (seedIdx < seedSz - SEED_BLOCK_SZ) {
   1af56:	45be      	cmp	lr, r7
   1af58:	d916      	bls.n	1af88 <wc_RNG_TestSeed+0x64>
                            seed + seedIdx + scratchSz,
   1af5a:	18fe      	adds	r6, r7, r3
    for (i = 0; i < length; i++) {
   1af5c:	2b00      	cmp	r3, #0
   1af5e:	dd10      	ble.n	1af82 <wc_RNG_TestSeed+0x5e>
   1af60:	eb08 0507 	add.w	r5, r8, r7
   1af64:	eb0c 0206 	add.w	r2, ip, r6
   1af68:	4463      	add	r3, ip
   1af6a:	441e      	add	r6, r3
    int compareSum = 0;
   1af6c:	2400      	movs	r4, #0
        compareSum |= a[i] ^ b[i];
   1af6e:	f812 3b01 	ldrb.w	r3, [r2], #1
   1af72:	f815 9f01 	ldrb.w	r9, [r5, #1]!
   1af76:	ea83 0309 	eor.w	r3, r3, r9
   1af7a:	431c      	orrs	r4, r3
    for (i = 0; i < length; i++) {
   1af7c:	42b2      	cmp	r2, r6
   1af7e:	d1f6      	bne.n	1af6e <wc_RNG_TestSeed+0x4a>
   1af80:	e7e1      	b.n	1af46 <wc_RNG_TestSeed+0x22>
            ret = DRBG_CONT_FAILURE;
   1af82:	2003      	movs	r0, #3
   1af84:	e7e2      	b.n	1af4c <wc_RNG_TestSeed+0x28>
    int ret = 0;
   1af86:	2000      	movs	r0, #0
}
   1af88:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

Disassembly of section .text.rand%468:

0001af8c <rand>:
   1af8c:	4b13      	ldr	r3, [pc, #76]	; (1afdc <rand+0x50>)
   1af8e:	b510      	push	{r4, lr}
   1af90:	681c      	ldr	r4, [r3, #0]
   1af92:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1af94:	b97b      	cbnz	r3, 1afb6 <rand+0x2a>
   1af96:	2018      	movs	r0, #24
   1af98:	f006 fe68 	bl	21c6c <malloc>
   1af9c:	4a10      	ldr	r2, [pc, #64]	; (1afe0 <rand+0x54>)
   1af9e:	4b11      	ldr	r3, [pc, #68]	; (1afe4 <rand+0x58>)
   1afa0:	63a0      	str	r0, [r4, #56]	; 0x38
   1afa2:	e9c0 2300 	strd	r2, r3, [r0]
   1afa6:	4b10      	ldr	r3, [pc, #64]	; (1afe8 <rand+0x5c>)
   1afa8:	6083      	str	r3, [r0, #8]
   1afaa:	230b      	movs	r3, #11
   1afac:	8183      	strh	r3, [r0, #12]
   1afae:	2201      	movs	r2, #1
   1afb0:	2300      	movs	r3, #0
   1afb2:	e9c0 2304 	strd	r2, r3, [r0, #16]
   1afb6:	6ba1      	ldr	r1, [r4, #56]	; 0x38
   1afb8:	480c      	ldr	r0, [pc, #48]	; (1afec <rand+0x60>)
   1afba:	690a      	ldr	r2, [r1, #16]
   1afbc:	694b      	ldr	r3, [r1, #20]
   1afbe:	4c0c      	ldr	r4, [pc, #48]	; (1aff0 <rand+0x64>)
   1afc0:	4350      	muls	r0, r2
   1afc2:	fb04 0003 	mla	r0, r4, r3, r0
   1afc6:	fba2 3404 	umull	r3, r4, r2, r4
   1afca:	1c5a      	adds	r2, r3, #1
   1afcc:	4404      	add	r4, r0
   1afce:	f144 0000 	adc.w	r0, r4, #0
   1afd2:	e9c1 2004 	strd	r2, r0, [r1, #16]
   1afd6:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
   1afda:	bd10      	pop	{r4, pc}
   1afdc:	2000e4e4 	.word	0x2000e4e4
   1afe0:	abcd330e 	.word	0xabcd330e
   1afe4:	e66d1234 	.word	0xe66d1234
   1afe8:	0005deec 	.word	0x0005deec
   1afec:	5851f42d 	.word	0x5851f42d
   1aff0:	4c957f2d 	.word	0x4c957f2d

Disassembly of section .text._Balloc%469:

0001aff4 <_Balloc>:
   1aff4:	b570      	push	{r4, r5, r6, lr}
   1aff6:	6a45      	ldr	r5, [r0, #36]	; 0x24
   1aff8:	4604      	mov	r4, r0
   1affa:	460e      	mov	r6, r1
   1affc:	b93d      	cbnz	r5, 1b00e <_Balloc+0x1a>
   1affe:	2010      	movs	r0, #16
   1b000:	f006 fe34 	bl	21c6c <malloc>
   1b004:	e9c0 5501 	strd	r5, r5, [r0, #4]
   1b008:	6260      	str	r0, [r4, #36]	; 0x24
   1b00a:	6005      	str	r5, [r0, #0]
   1b00c:	60c5      	str	r5, [r0, #12]
   1b00e:	6a65      	ldr	r5, [r4, #36]	; 0x24
   1b010:	68eb      	ldr	r3, [r5, #12]
   1b012:	b183      	cbz	r3, 1b036 <_Balloc+0x42>
   1b014:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1b016:	68db      	ldr	r3, [r3, #12]
   1b018:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
   1b01c:	b9b8      	cbnz	r0, 1b04e <_Balloc+0x5a>
   1b01e:	2101      	movs	r1, #1
   1b020:	fa01 f506 	lsl.w	r5, r1, r6
   1b024:	1d6a      	adds	r2, r5, #5
   1b026:	0092      	lsls	r2, r2, #2
   1b028:	4620      	mov	r0, r4
   1b02a:	f006 f8b7 	bl	2119c <_calloc_r>
   1b02e:	b160      	cbz	r0, 1b04a <_Balloc+0x56>
   1b030:	e9c0 6501 	strd	r6, r5, [r0, #4]
   1b034:	e00e      	b.n	1b054 <_Balloc+0x60>
   1b036:	2221      	movs	r2, #33	; 0x21
   1b038:	2104      	movs	r1, #4
   1b03a:	4620      	mov	r0, r4
   1b03c:	f006 f8ae 	bl	2119c <_calloc_r>
   1b040:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1b042:	60e8      	str	r0, [r5, #12]
   1b044:	68db      	ldr	r3, [r3, #12]
   1b046:	2b00      	cmp	r3, #0
   1b048:	d1e4      	bne.n	1b014 <_Balloc+0x20>
   1b04a:	2000      	movs	r0, #0
   1b04c:	bd70      	pop	{r4, r5, r6, pc}
   1b04e:	6802      	ldr	r2, [r0, #0]
   1b050:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
   1b054:	2300      	movs	r3, #0
   1b056:	e9c0 3303 	strd	r3, r3, [r0, #12]
   1b05a:	e7f7      	b.n	1b04c <_Balloc+0x58>

Disassembly of section .text._DRV_ETHPHY_NegResultPhase_BMSTAT%470:

0001b05c <_DRV_ETHPHY_NegResultPhase_BMSTAT>:
{
   1b05c:	b510      	push	{r4, lr}
   1b05e:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1b060:	f005 fba0 	bl	207a4 <_DRV_PHY_SMITransfer_Wait>
   1b064:	b190      	cbz	r0, 1b08c <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x30>
    if(phyStat.AN_COMPLETE == 0)
   1b066:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
   1b06a:	f013 0f20 	tst.w	r3, #32
   1b06e:	d00e      	beq.n	1b08e <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x32>
    else if(phyStat.LINK_STAT == 0)
   1b070:	f013 0f04 	tst.w	r3, #4
   1b074:	d119      	bne.n	1b0aa <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x4e>
    DRV_ETHPHY_NEGOTIATION_RESULT* pNegResult = (DRV_ETHPHY_NEGOTIATION_RESULT*)hClientObj->operParam;
   1b076:	6b23      	ldr	r3, [r4, #48]	; 0x30
    if(pNegResult)
   1b078:	b11b      	cbz	r3, 1b082 <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x26>
        pNegResult->linkStatus = linkStatus;
   1b07a:	2200      	movs	r2, #0
   1b07c:	801a      	strh	r2, [r3, #0]
        pNegResult->linkFlags = openFlags;
   1b07e:	805a      	strh	r2, [r3, #2]
        pNegResult->pauseType = pauseType;
   1b080:	711a      	strb	r2, [r3, #4]
    _DRV_PHY_SetOperDoneResult(hClientObj, res);
   1b082:	f06f 0107 	mvn.w	r1, #7
   1b086:	4620      	mov	r0, r4
   1b088:	f004 fe50 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
}
   1b08c:	bd10      	pop	{r4, pc}
    DRV_ETHPHY_NEGOTIATION_RESULT* pNegResult = (DRV_ETHPHY_NEGOTIATION_RESULT*)hClientObj->operParam;
   1b08e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    if(pNegResult)
   1b090:	b12b      	cbz	r3, 1b09e <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x42>
        pNegResult->linkStatus = linkStatus;
   1b092:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   1b096:	801a      	strh	r2, [r3, #0]
        pNegResult->linkFlags = openFlags;
   1b098:	2200      	movs	r2, #0
   1b09a:	805a      	strh	r2, [r3, #2]
        pNegResult->pauseType = pauseType;
   1b09c:	711a      	strb	r2, [r3, #4]
    _DRV_PHY_SetOperDoneResult(hClientObj, res);
   1b09e:	f06f 0107 	mvn.w	r1, #7
   1b0a2:	4620      	mov	r0, r4
   1b0a4:	f004 fe42 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
   1b0a8:	e7f0      	b.n	1b08c <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x30>
        if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_ANEXP))
   1b0aa:	2106      	movs	r1, #6
   1b0ac:	4620      	mov	r0, r4
   1b0ae:	f003 ff25 	bl	1eefc <_DRV_PHY_SMIReadStart>
   1b0b2:	2800      	cmp	r0, #0
   1b0b4:	d0ea      	beq.n	1b08c <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x30>
    hClientObj->operPhase = operPhase;
   1b0b6:	2302      	movs	r3, #2
   1b0b8:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1b0ba:	2300      	movs	r3, #0
   1b0bc:	8423      	strh	r3, [r4, #32]
   1b0be:	e7e5      	b.n	1b08c <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x30>

Disassembly of section .text._DRV_ETHPHY_ResetPhaseRead%471:

0001b0c0 <_DRV_ETHPHY_ResetPhaseRead>:
{
   1b0c0:	b510      	push	{r4, lr}
   1b0c2:	4604      	mov	r4, r0
    switch(hClientObj->operSubPhase)
   1b0c4:	8c03      	ldrh	r3, [r0, #32]
   1b0c6:	b133      	cbz	r3, 1b0d6 <_DRV_ETHPHY_ResetPhaseRead+0x16>
   1b0c8:	2b01      	cmp	r3, #1
   1b0ca:	d00e      	beq.n	1b0ea <_DRV_ETHPHY_ResetPhaseRead+0x2a>
            _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   1b0cc:	f06f 0108 	mvn.w	r1, #8
   1b0d0:	f004 fe2c 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
}
   1b0d4:	bd10      	pop	{r4, pc}
            if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMCON))
   1b0d6:	2100      	movs	r1, #0
   1b0d8:	f003 ff10 	bl	1eefc <_DRV_PHY_SMIReadStart>
   1b0dc:	2800      	cmp	r0, #0
   1b0de:	d0f9      	beq.n	1b0d4 <_DRV_ETHPHY_ResetPhaseRead+0x14>
    hClientObj->operPhase = operPhase;
   1b0e0:	2302      	movs	r3, #2
   1b0e2:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1b0e4:	2301      	movs	r3, #1
   1b0e6:	8423      	strh	r3, [r4, #32]
   1b0e8:	e7f4      	b.n	1b0d4 <_DRV_ETHPHY_ResetPhaseRead+0x14>
            if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1b0ea:	f005 fb5b 	bl	207a4 <_DRV_PHY_SMITransfer_Wait>
   1b0ee:	2800      	cmp	r0, #0
   1b0f0:	d0f0      	beq.n	1b0d4 <_DRV_ETHPHY_ResetPhaseRead+0x14>
            if(bmcon.RESET)
   1b0f2:	f994 303b 	ldrsb.w	r3, [r4, #59]	; 0x3b
   1b0f6:	2b00      	cmp	r3, #0
   1b0f8:	db04      	blt.n	1b104 <_DRV_ETHPHY_ResetPhaseRead+0x44>
                _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OK);
   1b0fa:	2100      	movs	r1, #0
   1b0fc:	4620      	mov	r0, r4
   1b0fe:	f004 fe15 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
   1b102:	e7e7      	b.n	1b0d4 <_DRV_ETHPHY_ResetPhaseRead+0x14>
                if(SYS_TMR_TickCountGet() < hClientObj->operTStamp)
   1b104:	f004 fff2 	bl	200ec <SYS_TMR_TickCountGet>
   1b108:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1b10a:	4298      	cmp	r0, r3
   1b10c:	d204      	bcs.n	1b118 <_DRV_ETHPHY_ResetPhaseRead+0x58>
    hClientObj->operPhase = operPhase;
   1b10e:	2302      	movs	r3, #2
   1b110:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1b112:	2300      	movs	r3, #0
   1b114:	8423      	strh	r3, [r4, #32]
   1b116:	e7dd      	b.n	1b0d4 <_DRV_ETHPHY_ResetPhaseRead+0x14>
                    _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_DTCT_ERR);
   1b118:	f04f 31ff 	mov.w	r1, #4294967295
   1b11c:	4620      	mov	r0, r4
   1b11e:	f004 fe05 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
   1b122:	e7d7      	b.n	1b0d4 <_DRV_ETHPHY_ResetPhaseRead+0x14>

Disassembly of section .text.DRV_GMAC_RegisterStatisticsGet%472:

0001b124 <DRV_GMAC_RegisterStatisticsGet>:
{
   1b124:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1b128:	460c      	mov	r4, r1
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1b12a:	4915      	ldr	r1, [pc, #84]	; (1b180 <DRV_GMAC_RegisterStatisticsGet+0x5c>)
   1b12c:	4281      	cmp	r1, r0
   1b12e:	d11c      	bne.n	1b16a <DRV_GMAC_RegisterStatisticsGet+0x46>
    if(pMACDrv == 0)
   1b130:	b1f8      	cbz	r0, 1b172 <DRV_GMAC_RegisterStatisticsGet+0x4e>
	if(pHwEntries)
   1b132:	b10b      	cbz	r3, 1b138 <DRV_GMAC_RegisterStatisticsGet+0x14>
		*pHwEntries = nHwEntries;
   1b134:	212d      	movs	r1, #45	; 0x2d
   1b136:	6019      	str	r1, [r3, #0]
	if(pRegEntries)
   1b138:	b1f4      	cbz	r4, 1b178 <DRV_GMAC_RegisterStatisticsGet+0x54>
		regLim = nEntries > nHwEntries ? nHwEntries : nEntries;
   1b13a:	2a2d      	cmp	r2, #45	; 0x2d
   1b13c:	bfa8      	it	ge
   1b13e:	222d      	movge	r2, #45	; 0x2d
   1b140:	4617      	mov	r7, r2
		for(ix = 0; ix < regLim; ix++, pRegEntries++, pHwRegDcpt++)
   1b142:	b1da      	cbz	r2, 1b17c <DRV_GMAC_RegisterStatisticsGet+0x58>
   1b144:	2600      	movs	r6, #0
		pHwRegDcpt = macPIC32CHwRegDcpt;
   1b146:	4d0f      	ldr	r5, [pc, #60]	; (1b184 <DRV_GMAC_RegisterStatisticsGet+0x60>)
			strncpy(pRegEntries->registerName, pHwRegDcpt->regName, sizeof(pRegEntries->registerName));
   1b148:	f04f 0824 	mov.w	r8, #36	; 0x24
   1b14c:	4642      	mov	r2, r8
   1b14e:	4629      	mov	r1, r5
   1b150:	4620      	mov	r0, r4
   1b152:	f005 f918 	bl	20386 <strncpy>
			pRegEntries->registerValue = (*pHwRegDcpt->regFunc)();
   1b156:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1b158:	4798      	blx	r3
   1b15a:	6260      	str	r0, [r4, #36]	; 0x24
		for(ix = 0; ix < regLim; ix++, pRegEntries++, pHwRegDcpt++)
   1b15c:	3601      	adds	r6, #1
   1b15e:	3428      	adds	r4, #40	; 0x28
   1b160:	3528      	adds	r5, #40	; 0x28
   1b162:	42b7      	cmp	r7, r6
   1b164:	d1f2      	bne.n	1b14c <DRV_GMAC_RegisterStatisticsGet+0x28>
	return TCPIP_MAC_RES_OK;
   1b166:	2000      	movs	r0, #0
   1b168:	e001      	b.n	1b16e <DRV_GMAC_RegisterStatisticsGet+0x4a>
        return TCPIP_MAC_RES_OP_ERR;
   1b16a:	f06f 0005 	mvn.w	r0, #5
}
   1b16e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return TCPIP_MAC_RES_OP_ERR;
   1b172:	f06f 0005 	mvn.w	r0, #5
   1b176:	e7fa      	b.n	1b16e <DRV_GMAC_RegisterStatisticsGet+0x4a>
	return TCPIP_MAC_RES_OK;
   1b178:	2000      	movs	r0, #0
   1b17a:	e7f8      	b.n	1b16e <DRV_GMAC_RegisterStatisticsGet+0x4a>
   1b17c:	2000      	movs	r0, #0
   1b17e:	e7f6      	b.n	1b16e <DRV_GMAC_RegisterStatisticsGet+0x4a>
   1b180:	2000d8b8 	.word	0x2000d8b8
   1b184:	00006258 	.word	0x00006258

Disassembly of section .text._MacRxPacketAck%473:

0001b188 <_MacRxPacketAck>:
    if(pPkt && pPkt->pDSeg)
   1b188:	b350      	cbz	r0, 1b1e0 <_MacRxPacketAck+0x58>
{
   1b18a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1b18c:	460c      	mov	r4, r1
   1b18e:	4601      	mov	r1, r0
    if(pPkt && pPkt->pDSeg)
   1b190:	6903      	ldr	r3, [r0, #16]
   1b192:	b33b      	cbz	r3, 1b1e4 <_MacRxPacketAck+0x5c>
            pPkt->pDSeg->next = 0;
   1b194:	2600      	movs	r6, #0
                DRV_PIC32CGMAC_SingleListTailAdd(&pMacDrv->sGmacData.gmac_queue[queueIdx]._RxQueue, (DRV_PIC32CGMAC_SGL_LIST_NODE*)pPkt); 
   1b196:	f104 0794 	add.w	r7, r4, #148	; 0x94
   1b19a:	e009      	b.n	1b1b0 <_MacRxPacketAck+0x28>
                (*pMacDrv->sGmacData.pktFreeF)(pPkt);          
   1b19c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1b19e:	4608      	mov	r0, r1
   1b1a0:	4798      	blx	r3
            if( !pDSegNext )
   1b1a2:	b30d      	cbz	r5, 1b1e8 <_MacRxPacketAck+0x60>
            TCPIP_MAC_SEGMENT_GAP_DCPT* pGap = (TCPIP_MAC_SEGMENT_GAP_DCPT*)(pDSegNext->segBuffer + pMacDrv->sGmacData._dcptOffset);
   1b1a4:	f9b4 30ec 	ldrsh.w	r3, [r4, #236]	; 0xec
            pPkt = pGap->segmentPktPtr;
   1b1a8:	686a      	ldr	r2, [r5, #4]
   1b1aa:	58d1      	ldr	r1, [r2, r3]
        while(pPkt->pDSeg)
   1b1ac:	690b      	ldr	r3, [r1, #16]
   1b1ae:	b1ab      	cbz	r3, 1b1dc <_MacRxPacketAck+0x54>
            pDSegNext = pPkt->pDSeg->next;
   1b1b0:	681d      	ldr	r5, [r3, #0]
            pPkt->pDSeg->next = 0;
   1b1b2:	601e      	str	r6, [r3, #0]
            if((pPkt->pDSeg->segFlags  & TCPIP_MAC_SEG_FLAG_RX_STICKY) == 0 && 
   1b1b4:	690b      	ldr	r3, [r1, #16]
   1b1b6:	8a1b      	ldrh	r3, [r3, #16]
   1b1b8:	f013 0f04 	tst.w	r3, #4
   1b1bc:	d10a      	bne.n	1b1d4 <_MacRxPacketAck+0x4c>
   1b1be:	f8b4 30f4 	ldrh.w	r3, [r4, #244]	; 0xf4
   1b1c2:	f013 0f02 	tst.w	r3, #2
   1b1c6:	d1e9      	bne.n	1b19c <_MacRxPacketAck+0x14>
                        pMacDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxBuffCntThres)))
   1b1c8:	f8b4 30c4 	ldrh.w	r3, [r4, #196]	; 0xc4
                (((pMacDrv->sGmacData._controlFlags & TCPIP_MAC_CONTROL_NO_SMART_ALLOC) != 0) ||
   1b1cc:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
   1b1d0:	429a      	cmp	r2, r3
   1b1d2:	dce3      	bgt.n	1b19c <_MacRxPacketAck+0x14>
                DRV_PIC32CGMAC_SingleListTailAdd(&pMacDrv->sGmacData.gmac_queue[queueIdx]._RxQueue, (DRV_PIC32CGMAC_SGL_LIST_NODE*)pPkt); 
   1b1d4:	4638      	mov	r0, r7
   1b1d6:	f006 f80b 	bl	211f0 <DRV_PIC32CGMAC_SingleListTailAdd>
   1b1da:	e7e2      	b.n	1b1a2 <_MacRxPacketAck+0x1a>
        res  = true; 
   1b1dc:	2001      	movs	r0, #1
   1b1de:	e004      	b.n	1b1ea <_MacRxPacketAck+0x62>
    bool res = false;
   1b1e0:	2000      	movs	r0, #0
}
   1b1e2:	4770      	bx	lr
    bool res = false;
   1b1e4:	2000      	movs	r0, #0
   1b1e6:	e000      	b.n	1b1ea <_MacRxPacketAck+0x62>
        res  = true; 
   1b1e8:	2001      	movs	r0, #1
}
   1b1ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.TCPIP_OAHASH_EntryLookupOrInsert%474:

0001b1ec <TCPIP_OAHASH_EntryLookupOrInsert>:
{
   1b1ec:	b538      	push	{r3, r4, r5, lr}
   1b1ee:	4604      	mov	r4, r0
   1b1f0:	460d      	mov	r5, r1
    pBkt = _OAHashFindBkt(pOH, key);
   1b1f2:	f7fd fdff 	bl	18df4 <_OAHashFindBkt>
    if(pBkt == 0)
   1b1f6:	4603      	mov	r3, r0
   1b1f8:	b158      	cbz	r0, 1b212 <TCPIP_OAHASH_EntryLookupOrInsert+0x26>
    if(pBkt->flags.busy == 0)
   1b1fa:	781a      	ldrb	r2, [r3, #0]
   1b1fc:	f012 0f01 	tst.w	r2, #1
        pBkt->flags.newEntry = 1;
   1b200:	bf0e      	itee	eq
   1b202:	f042 0203 	orreq.w	r2, r2, #3
        pBkt->flags.newEntry = 0;
   1b206:	781a      	ldrbne	r2, [r3, #0]
   1b208:	f36f 0241 	bfcne	r2, #1, #1
   1b20c:	701a      	strb	r2, [r3, #0]
}
   1b20e:	4618      	mov	r0, r3
   1b210:	bd38      	pop	{r3, r4, r5, pc}
        if(pOH->fullSlots != pOH->hEntries)
   1b212:	6a61      	ldr	r1, [r4, #36]	; 0x24
   1b214:	68e2      	ldr	r2, [r4, #12]
   1b216:	4291      	cmp	r1, r2
   1b218:	d1f9      	bne.n	1b20e <TCPIP_OAHASH_EntryLookupOrInsert+0x22>
        if(pOH->delF == 0 || (pDel = (*pOH->delF)(pOH)) == 0)
   1b21a:	69a2      	ldr	r2, [r4, #24]
   1b21c:	2a00      	cmp	r2, #0
   1b21e:	d0f6      	beq.n	1b20e <TCPIP_OAHASH_EntryLookupOrInsert+0x22>
   1b220:	4620      	mov	r0, r4
   1b222:	4790      	blx	r2
   1b224:	4603      	mov	r3, r0
   1b226:	2800      	cmp	r0, #0
   1b228:	d0f1      	beq.n	1b20e <TCPIP_OAHASH_EntryLookupOrInsert+0x22>
    if(pOE->flags.busy)
   1b22a:	7802      	ldrb	r2, [r0, #0]
   1b22c:	f012 0f01 	tst.w	r2, #1
   1b230:	d006      	beq.n	1b240 <TCPIP_OAHASH_EntryLookupOrInsert+0x54>
        pOE->flags.busy = 0;
   1b232:	7802      	ldrb	r2, [r0, #0]
   1b234:	f36f 0200 	bfc	r2, #0, #1
   1b238:	7002      	strb	r2, [r0, #0]
        pOH->fullSlots--;
   1b23a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1b23c:	3b01      	subs	r3, #1
   1b23e:	6263      	str	r3, [r4, #36]	; 0x24
        pBkt = _OAHashFindBkt(pOH, key);
   1b240:	4629      	mov	r1, r5
   1b242:	4620      	mov	r0, r4
   1b244:	f7fd fdd6 	bl	18df4 <_OAHashFindBkt>
        if(pBkt == 0)
   1b248:	4603      	mov	r3, r0
   1b24a:	2800      	cmp	r0, #0
   1b24c:	d1d5      	bne.n	1b1fa <TCPIP_OAHASH_EntryLookupOrInsert+0xe>
   1b24e:	e7de      	b.n	1b20e <TCPIP_OAHASH_EntryLookupOrInsert+0x22>

Disassembly of section .text.TCPIP_STACK_BringNetDown%475:

0001b250 <TCPIP_STACK_BringNetDown>:
{
   1b250:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1b252:	4605      	mov	r5, r0
   1b254:	460e      	mov	r6, r1
    stackCtrlData->pNetIf = pNetIf;
   1b256:	6141      	str	r1, [r0, #20]
    stackCtrlData->netIx = pNetIf->netIfIx;
   1b258:	f8b1 1058 	ldrh.w	r1, [r1, #88]	; 0x58
   1b25c:	6181      	str	r1, [r0, #24]
    stackCtrlData->stackAction = action;
   1b25e:	7702      	strb	r2, [r0, #28]
    stackCtrlData->powerMode = powerMode;
   1b260:	7743      	strb	r3, [r0, #29]
    pEntry = TCPIP_STACK_MODULE_ENTRY_TBL + sizeof(TCPIP_STACK_MODULE_ENTRY_TBL)/sizeof(*TCPIP_STACK_MODULE_ENTRY_TBL);
   1b262:	4c13      	ldr	r4, [pc, #76]	; (1b2b0 <TCPIP_STACK_BringNetDown+0x60>)
    while (pEntry != TCPIP_STACK_MODULE_ENTRY_TBL);
   1b264:	f1a4 076c 	sub.w	r7, r4, #108	; 0x6c
        pEntry--;
   1b268:	3c0c      	subs	r4, #12
        pEntry->deInitFunc(stackCtrlData);
   1b26a:	68a3      	ldr	r3, [r4, #8]
   1b26c:	4628      	mov	r0, r5
   1b26e:	4798      	blx	r3
    while (pEntry != TCPIP_STACK_MODULE_ENTRY_TBL);
   1b270:	42bc      	cmp	r4, r7
   1b272:	d1f9      	bne.n	1b268 <TCPIP_STACK_BringNetDown+0x18>
    _TCPIPStackModuleRxPurge(TCPIP_MODULE_MANAGER, pNetIf);
   1b274:	4631      	mov	r1, r6
   1b276:	2001      	movs	r0, #1
   1b278:	f7fd fab8 	bl	187ec <_TCPIPStackModuleRxPurge>
        if(pNetIf->hIfMac != 0)
   1b27c:	6d30      	ldr	r0, [r6, #80]	; 0x50
   1b27e:	b110      	cbz	r0, 1b286 <TCPIP_STACK_BringNetDown+0x36>
            (*pNetIf->pMacObj->TCPIP_MAC_Close)(pNetIf->hIfMac);
   1b280:	6c73      	ldr	r3, [r6, #68]	; 0x44
   1b282:	6a1b      	ldr	r3, [r3, #32]
   1b284:	4798      	blx	r3
        if(pNetIf->macObjHandle != 0)
   1b286:	6cf0      	ldr	r0, [r6, #76]	; 0x4c
   1b288:	b110      	cbz	r0, 1b290 <TCPIP_STACK_BringNetDown+0x40>
            (*pNetIf->pMacObj->TCPIP_MAC_Deinitialize)(pNetIf->macObjHandle);
   1b28a:	6c73      	ldr	r3, [r6, #68]	; 0x44
   1b28c:	68db      	ldr	r3, [r3, #12]
   1b28e:	4798      	blx	r3
    pNetIf->hIfMac = 0;
   1b290:	2300      	movs	r3, #0
   1b292:	6533      	str	r3, [r6, #80]	; 0x50
    pNetIf->macObjHandle = 0;
   1b294:	64f3      	str	r3, [r6, #76]	; 0x4c
    pNetIf->Flags.bInterfaceEnabled = pNetIf->Flags.bMacInitialize = false;
   1b296:	f896 2043 	ldrb.w	r2, [r6, #67]	; 0x43
   1b29a:	f363 1286 	bfi	r2, r3, #6, #1
   1b29e:	f886 2043 	strb.w	r2, [r6, #67]	; 0x43
   1b2a2:	f896 2042 	ldrb.w	r2, [r6, #66]	; 0x42
   1b2a6:	f363 1286 	bfi	r2, r3, #6, #1
   1b2aa:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42
}
   1b2ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1b2b0:	0001aa30 	.word	0x0001aa30

Disassembly of section .text.TCPIP_UDP_SocketInfoGet%476:

0001b2b4 <TCPIP_UDP_SocketInfoGet>:
{
   1b2b4:	b538      	push	{r3, r4, r5, lr}
   1b2b6:	460c      	mov	r4, r1
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1b2b8:	f004 feb4 	bl	20024 <_UDPSocketDcpt>
    if(pSkt == 0 || pInfo == 0)
   1b2bc:	b340      	cbz	r0, 1b310 <TCPIP_UDP_SocketInfoGet+0x5c>
   1b2be:	4605      	mov	r5, r0
   1b2c0:	b344      	cbz	r4, 1b314 <TCPIP_UDP_SocketInfoGet+0x60>
    memset(pInfo, 0, sizeof(*pInfo));
   1b2c2:	2250      	movs	r2, #80	; 0x50
   1b2c4:	2100      	movs	r1, #0
   1b2c6:	4620      	mov	r0, r4
   1b2c8:	f006 fce0 	bl	21c8c <memset>
        if (pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   1b2cc:	8fab      	ldrh	r3, [r5, #60]	; 0x3c
   1b2ce:	2b01      	cmp	r3, #1
   1b2d0:	d013      	beq.n	1b2fa <TCPIP_UDP_SocketInfoGet+0x46>
        pInfo->addressType = IP_ADDRESS_TYPE_ANY;
   1b2d2:	2300      	movs	r3, #0
   1b2d4:	7023      	strb	r3, [r4, #0]
	pInfo->remotePort = pSkt->remotePort;
   1b2d6:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
   1b2d8:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
	pInfo->localPort = pSkt->localPort;
   1b2dc:	8d6b      	ldrh	r3, [r5, #42]	; 0x2a
   1b2de:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
    pInfo->hNet = pSkt->pSktNet;
   1b2e2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1b2e4:	64a3      	str	r3, [r4, #72]	; 0x48
    pInfo->rxQueueSize = TCPIP_Helper_SingleListCount(&pSkt->rxQueue);
   1b2e6:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   1b2e8:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    pInfo->txSize = pSkt->txEnd - pSkt->txStart;
   1b2ec:	686b      	ldr	r3, [r5, #4]
   1b2ee:	682a      	ldr	r2, [r5, #0]
   1b2f0:	1a9b      	subs	r3, r3, r2
   1b2f2:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
	return true;
   1b2f6:	2001      	movs	r0, #1
}
   1b2f8:	bd38      	pop	{r3, r4, r5, pc}
            pInfo->remoteIPaddress.v4Add.Val = pSkt->destAddress.Val;
   1b2fa:	696b      	ldr	r3, [r5, #20]
   1b2fc:	6063      	str	r3, [r4, #4]
            pInfo->localIPaddress.v4Add.Val = pSkt->srcAddress.Val;
   1b2fe:	69ab      	ldr	r3, [r5, #24]
   1b300:	6163      	str	r3, [r4, #20]
            pInfo->sourceIPaddress.v4Add.Val = pSkt->pktSrcAddress.Val;
   1b302:	69eb      	ldr	r3, [r5, #28]
   1b304:	6263      	str	r3, [r4, #36]	; 0x24
            pInfo->destIPaddress.v4Add.Val = pSkt->pktDestAddress.Val;
   1b306:	6a2b      	ldr	r3, [r5, #32]
   1b308:	6363      	str	r3, [r4, #52]	; 0x34
            pInfo->addressType = IP_ADDRESS_TYPE_IPV4;
   1b30a:	2301      	movs	r3, #1
   1b30c:	7023      	strb	r3, [r4, #0]
            break;
   1b30e:	e7e2      	b.n	1b2d6 <TCPIP_UDP_SocketInfoGet+0x22>
        return false;
   1b310:	2000      	movs	r0, #0
   1b312:	e7f1      	b.n	1b2f8 <TCPIP_UDP_SocketInfoGet+0x44>
   1b314:	2000      	movs	r0, #0
   1b316:	e7ef      	b.n	1b2f8 <TCPIP_UDP_SocketInfoGet+0x44>

Disassembly of section .text.xPortPendSVHandler%477:

0001b320 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
   1b320:	f3ef 8009 	mrs	r0, PSP
   1b324:	f3bf 8f6f 	isb	sy
   1b328:	4b15      	ldr	r3, [pc, #84]	; (1b380 <pxCurrentTCBConst>)
   1b32a:	681a      	ldr	r2, [r3, #0]
   1b32c:	f01e 0f10 	tst.w	lr, #16
   1b330:	bf08      	it	eq
   1b332:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
   1b336:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b33a:	6010      	str	r0, [r2, #0]
   1b33c:	e92d 0009 	stmdb	sp!, {r0, r3}
   1b340:	f04f 0020 	mov.w	r0, #32
   1b344:	f380 8811 	msr	BASEPRI, r0
   1b348:	f3bf 8f4f 	dsb	sy
   1b34c:	f3bf 8f6f 	isb	sy
   1b350:	f7fc f91e 	bl	17590 <vTaskSwitchContext>
   1b354:	f04f 0000 	mov.w	r0, #0
   1b358:	f380 8811 	msr	BASEPRI, r0
   1b35c:	bc09      	pop	{r0, r3}
   1b35e:	6819      	ldr	r1, [r3, #0]
   1b360:	6808      	ldr	r0, [r1, #0]
   1b362:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b366:	f01e 0f10 	tst.w	lr, #16
   1b36a:	bf08      	it	eq
   1b36c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
   1b370:	f380 8809 	msr	PSP, r0
   1b374:	f3bf 8f6f 	isb	sy
   1b378:	4770      	bx	lr
   1b37a:	bf00      	nop
   1b37c:	f3af 8000 	nop.w

0001b380 <pxCurrentTCBConst>:
   1b380:	2000e49c 	.word	0x2000e49c

Disassembly of section .text.vTaskStartScheduler%478:

0001b384 <vTaskStartScheduler>:
{
   1b384:	b500      	push	{lr}
   1b386:	b083      	sub	sp, #12
		xReturn = xTaskCreate(	prvIdleTask,
   1b388:	4b11      	ldr	r3, [pc, #68]	; (1b3d0 <vTaskStartScheduler+0x4c>)
   1b38a:	9301      	str	r3, [sp, #4]
   1b38c:	2300      	movs	r3, #0
   1b38e:	9300      	str	r3, [sp, #0]
   1b390:	2280      	movs	r2, #128	; 0x80
   1b392:	4910      	ldr	r1, [pc, #64]	; (1b3d4 <vTaskStartScheduler+0x50>)
   1b394:	4810      	ldr	r0, [pc, #64]	; (1b3d8 <vTaskStartScheduler+0x54>)
   1b396:	f7f3 ffa1 	bl	f2dc <xTaskCreate>
	if( xReturn == pdPASS )
   1b39a:	2801      	cmp	r0, #1
   1b39c:	d002      	beq.n	1b3a4 <vTaskStartScheduler+0x20>
}
   1b39e:	b003      	add	sp, #12
   1b3a0:	f85d fb04 	ldr.w	pc, [sp], #4

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   1b3a4:	f04f 0320 	mov.w	r3, #32
   1b3a8:	f383 8811 	msr	BASEPRI, r3
   1b3ac:	f3bf 8f6f 	isb	sy
   1b3b0:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
   1b3b4:	4b09      	ldr	r3, [pc, #36]	; (1b3dc <vTaskStartScheduler+0x58>)
   1b3b6:	f04f 32ff 	mov.w	r2, #4294967295
   1b3ba:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
   1b3bc:	4b08      	ldr	r3, [pc, #32]	; (1b3e0 <vTaskStartScheduler+0x5c>)
   1b3be:	2201      	movs	r2, #1
   1b3c0:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
   1b3c2:	4b08      	ldr	r3, [pc, #32]	; (1b3e4 <vTaskStartScheduler+0x60>)
   1b3c4:	2200      	movs	r2, #0
   1b3c6:	601a      	str	r2, [r3, #0]
		if( xPortStartScheduler() != pdFALSE )
   1b3c8:	f001 fe66 	bl	1d098 <xPortStartScheduler>
}
   1b3cc:	e7e7      	b.n	1b39e <vTaskStartScheduler+0x1a>
   1b3ce:	bf00      	nop
   1b3d0:	2000e4bc 	.word	0x2000e4bc
   1b3d4:	000221f0 	.word	0x000221f0
   1b3d8:	0001a6cd 	.word	0x0001a6cd
   1b3dc:	2000e4c0 	.word	0x2000e4c0
   1b3e0:	2000e4cc 	.word	0x2000e4cc
   1b3e4:	2000e4d0 	.word	0x2000e4d0

Disassembly of section .text.wc_InitSha256_ex%479:

0001b3e8 <wc_InitSha256_ex>:
        if (sha256 == NULL)
   1b3e8:	4603      	mov	r3, r0
   1b3ea:	b1e8      	cbz	r0, 1b428 <wc_InitSha256_ex+0x40>
        sha256->heap = heap;
   1b3ec:	66c1      	str	r1, [r0, #108]	; 0x6c
        sha256->devId = devId;
   1b3ee:	6702      	str	r2, [r0, #112]	; 0x70
        sha256->devCtx = NULL;
   1b3f0:	2000      	movs	r0, #0
   1b3f2:	6758      	str	r0, [r3, #116]	; 0x74
    sha256->digest[0] = 0x6A09E667L;
   1b3f4:	4a0e      	ldr	r2, [pc, #56]	; (1b430 <wc_InitSha256_ex+0x48>)
   1b3f6:	601a      	str	r2, [r3, #0]
    sha256->digest[1] = 0xBB67AE85L;
   1b3f8:	4a0e      	ldr	r2, [pc, #56]	; (1b434 <wc_InitSha256_ex+0x4c>)
   1b3fa:	605a      	str	r2, [r3, #4]
    sha256->digest[2] = 0x3C6EF372L;
   1b3fc:	4a0e      	ldr	r2, [pc, #56]	; (1b438 <wc_InitSha256_ex+0x50>)
   1b3fe:	609a      	str	r2, [r3, #8]
    sha256->digest[3] = 0xA54FF53AL;
   1b400:	4a0e      	ldr	r2, [pc, #56]	; (1b43c <wc_InitSha256_ex+0x54>)
   1b402:	60da      	str	r2, [r3, #12]
    sha256->digest[4] = 0x510E527FL;
   1b404:	4a0e      	ldr	r2, [pc, #56]	; (1b440 <wc_InitSha256_ex+0x58>)
   1b406:	611a      	str	r2, [r3, #16]
    sha256->digest[5] = 0x9B05688CL;
   1b408:	4a0e      	ldr	r2, [pc, #56]	; (1b444 <wc_InitSha256_ex+0x5c>)
   1b40a:	615a      	str	r2, [r3, #20]
    sha256->digest[6] = 0x1F83D9ABL;
   1b40c:	4a0e      	ldr	r2, [pc, #56]	; (1b448 <wc_InitSha256_ex+0x60>)
   1b40e:	619a      	str	r2, [r3, #24]
    sha256->digest[7] = 0x5BE0CD19L;
   1b410:	f102 5274 	add.w	r2, r2, #1023410176	; 0x3d000000
   1b414:	f5a2 0223 	sub.w	r2, r2, #10682368	; 0xa30000
   1b418:	f6a2 4292 	subw	r2, r2, #3218	; 0xc92
   1b41c:	61da      	str	r2, [r3, #28]
    sha256->buffLen = 0;
   1b41e:	6618      	str	r0, [r3, #96]	; 0x60
    sha256->loLen   = 0;
   1b420:	6658      	str	r0, [r3, #100]	; 0x64
    sha256->hiLen   = 0;
   1b422:	6698      	str	r0, [r3, #104]	; 0x68
    sha256->flags = 0;
   1b424:	6798      	str	r0, [r3, #120]	; 0x78
        if (ret != 0)
   1b426:	4770      	bx	lr
            return BAD_FUNC_ARG;
   1b428:	f06f 00ac 	mvn.w	r0, #172	; 0xac
    }
   1b42c:	4770      	bx	lr
   1b42e:	bf00      	nop
   1b430:	6a09e667 	.word	0x6a09e667
   1b434:	bb67ae85 	.word	0xbb67ae85
   1b438:	3c6ef372 	.word	0x3c6ef372
   1b43c:	a54ff53a 	.word	0xa54ff53a
   1b440:	510e527f 	.word	0x510e527f
   1b444:	9b05688c 	.word	0x9b05688c
   1b448:	1f83d9ab 	.word	0x1f83d9ab

Disassembly of section .text.TCPIP_ARP_EntryGet%480:

0001b44c <TCPIP_ARP_EntryGet>:
    if(ipAdd == 0 || ipAdd->Val == 0)
   1b44c:	b319      	cbz	r1, 1b496 <TCPIP_ARP_EntryGet+0x4a>
{   
   1b44e:	b510      	push	{r4, lr}
   1b450:	b082      	sub	sp, #8
   1b452:	460c      	mov	r4, r1
    if(ipAdd == 0 || ipAdd->Val == 0)
   1b454:	6809      	ldr	r1, [r1, #0]
   1b456:	b309      	cbz	r1, 1b49c <TCPIP_ARP_EntryGet+0x50>
   1b458:	b318      	cbz	r0, 1b4a2 <TCPIP_ARP_EntryGet+0x56>
   1b45a:	f890 1042 	ldrb.w	r1, [r0, #66]	; 0x42
   1b45e:	f011 0f40 	tst.w	r1, #64	; 0x40
   1b462:	d103      	bne.n	1b46c <TCPIP_ARP_EntryGet+0x20>
        return ARP_RES_NO_INTERFACE;
   1b464:	f06f 0005 	mvn.w	r0, #5
}
   1b468:	b002      	add	sp, #8
   1b46a:	bd10      	pop	{r4, pc}
   1b46c:	4621      	mov	r1, r4
    if(probe)
   1b46e:	b153      	cbz	r3, 1b486 <TCPIP_ARP_EntryGet+0x3a>
    return pNetIf->Flags.bInConfig != 0;
   1b470:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
        if(_TCPIPStackIsConfig(pIf))
   1b474:	f013 0f10 	tst.w	r3, #16
   1b478:	d116      	bne.n	1b4a8 <TCPIP_ARP_EntryGet+0x5c>
        return _ARPProbeAddress(pIf, ipAdd, &pIf->netIPAddr, ARP_OPERATION_REQ, pHwAdd);
   1b47a:	9200      	str	r2, [sp, #0]
   1b47c:	2301      	movs	r3, #1
   1b47e:	1d02      	adds	r2, r0, #4
   1b480:	f7f9 fbe0 	bl	14c44 <_ARPProbeAddress>
   1b484:	e7f0      	b.n	1b468 <TCPIP_ARP_EntryGet+0x1c>
        return (TCPIP_ARP_IsResolved(pIf, ipAdd, pHwAdd))? ARP_RES_ENTRY_SOLVED : ARP_RES_NO_ENTRY;
   1b486:	f7fd f88d 	bl	185a4 <TCPIP_ARP_IsResolved>
   1b48a:	2800      	cmp	r0, #0
   1b48c:	bf14      	ite	ne
   1b48e:	2002      	movne	r0, #2
   1b490:	f04f 30ff 	moveq.w	r0, #4294967295
   1b494:	e7e8      	b.n	1b468 <TCPIP_ARP_EntryGet+0x1c>
        return ARP_RES_BAD_ADDRESS;
   1b496:	f06f 0004 	mvn.w	r0, #4
}
   1b49a:	4770      	bx	lr
        return ARP_RES_BAD_ADDRESS;
   1b49c:	f06f 0004 	mvn.w	r0, #4
   1b4a0:	e7e2      	b.n	1b468 <TCPIP_ARP_EntryGet+0x1c>
        return ARP_RES_NO_INTERFACE;
   1b4a2:	f06f 0005 	mvn.w	r0, #5
   1b4a6:	e7df      	b.n	1b468 <TCPIP_ARP_EntryGet+0x1c>
            return ARP_RES_CONFIGURE_ERR;
   1b4a8:	f06f 0007 	mvn.w	r0, #7
   1b4ac:	e7dc      	b.n	1b468 <TCPIP_ARP_EntryGet+0x1c>

Disassembly of section .text._PingStop%481:

0001b4b0 <_PingStop>:
{
   1b4b0:	b538      	push	{r3, r4, r5, lr}
   1b4b2:	4604      	mov	r4, r0
   1b4b4:	460d      	mov	r5, r1
    if(icmpReqHandle != 0)
   1b4b6:	4b0f      	ldr	r3, [pc, #60]	; (1b4f4 <_PingStop+0x44>)
   1b4b8:	6818      	ldr	r0, [r3, #0]
   1b4ba:	b120      	cbz	r0, 1b4c6 <_PingStop+0x16>
        TCPIP_ICMP_EchoRequestCancel(icmpReqHandle);
   1b4bc:	f004 ffbe 	bl	2043c <TCPIP_ICMP_EchoRequestCancel>
        icmpReqHandle = 0;
   1b4c0:	4b0c      	ldr	r3, [pc, #48]	; (1b4f4 <_PingStop+0x44>)
   1b4c2:	2200      	movs	r2, #0
   1b4c4:	601a      	str	r2, [r3, #0]
    _TCPIPStackSignalHandlerSetParams(TCPIP_THIS_MODULE_ID, tcpipCmdSignalHandle, 0);
   1b4c6:	2200      	movs	r2, #0
   1b4c8:	4b0b      	ldr	r3, [pc, #44]	; (1b4f8 <_PingStop+0x48>)
   1b4ca:	6819      	ldr	r1, [r3, #0]
   1b4cc:	201f      	movs	r0, #31
   1b4ce:	f004 fd95 	bl	1fffc <_TCPIPStackSignalHandlerSetParams>
    tcpipCmdStat = TCPIP_CMD_STAT_IDLE;
   1b4d2:	4b0a      	ldr	r3, [pc, #40]	; (1b4fc <_PingStop+0x4c>)
   1b4d4:	2200      	movs	r2, #0
   1b4d6:	701a      	strb	r2, [r3, #0]
    if(pCmdIO)
   1b4d8:	b144      	cbz	r4, 1b4ec <_PingStop+0x3c>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Ping: done. Sent %d requests, received %d replies.\r\n", icmpReqCount, icmpAckRecv);
   1b4da:	6823      	ldr	r3, [r4, #0]
   1b4dc:	685c      	ldr	r4, [r3, #4]
   1b4de:	4b08      	ldr	r3, [pc, #32]	; (1b500 <_PingStop+0x50>)
   1b4e0:	681b      	ldr	r3, [r3, #0]
   1b4e2:	4a08      	ldr	r2, [pc, #32]	; (1b504 <_PingStop+0x54>)
   1b4e4:	6812      	ldr	r2, [r2, #0]
   1b4e6:	4908      	ldr	r1, [pc, #32]	; (1b508 <_PingStop+0x58>)
   1b4e8:	4628      	mov	r0, r5
   1b4ea:	47a0      	blx	r4
    pTcpipCmdDevice = 0;
   1b4ec:	4b07      	ldr	r3, [pc, #28]	; (1b50c <_PingStop+0x5c>)
   1b4ee:	2200      	movs	r2, #0
   1b4f0:	601a      	str	r2, [r3, #0]
}
   1b4f2:	bd38      	pop	{r3, r4, r5, pc}
   1b4f4:	2000e3c8 	.word	0x2000e3c8
   1b4f8:	2000e3e4 	.word	0x2000e3e4
   1b4fc:	2000e1af 	.word	0x2000e1af
   1b500:	2000e3b4 	.word	0x2000e3b4
   1b504:	2000e3c0 	.word	0x2000e3c0
   1b508:	000009e8 	.word	0x000009e8
   1b50c:	2000e3e0 	.word	0x2000e3e0

Disassembly of section .text.Ipv4FilterSetActive%482:

0001b510 <Ipv4FilterSetActive>:
{
   1b510:	b570      	push	{r4, r5, r6, lr}
   1b512:	4604      	mov	r4, r0
   1b514:	460e      	mov	r6, r1
    TCPIP_Helper_ProtectedSingleListLock(notifyList);
   1b516:	4d14      	ldr	r5, [pc, #80]	; (1b568 <Ipv4FilterSetActive+0x58>)
   1b518:	4628      	mov	r0, r5
   1b51a:	f005 fac9 	bl	20ab0 <TCPIP_Helper_ProtectedSingleListLock>
    for(fNode = (IPV4_FILTER_LIST_NODE*)ipv4PacketFilters.list.head; fNode != 0; fNode = fNode->next)
   1b51e:	682b      	ldr	r3, [r5, #0]
   1b520:	b1eb      	cbz	r3, 1b55e <Ipv4FilterSetActive+0x4e>
        if(fNode == (IPV4_FILTER_LIST_NODE*)hFilter)
   1b522:	42a3      	cmp	r3, r4
   1b524:	d00e      	beq.n	1b544 <Ipv4FilterSetActive+0x34>
    for(fNode = (IPV4_FILTER_LIST_NODE*)ipv4PacketFilters.list.head; fNode != 0; fNode = fNode->next)
   1b526:	681b      	ldr	r3, [r3, #0]
   1b528:	b19b      	cbz	r3, 1b552 <Ipv4FilterSetActive+0x42>
        if(fNode == (IPV4_FILTER_LIST_NODE*)hFilter)
   1b52a:	429c      	cmp	r4, r3
   1b52c:	d1fb      	bne.n	1b526 <Ipv4FilterSetActive+0x16>
            if(fNode->active != active)
   1b52e:	7a1a      	ldrb	r2, [r3, #8]
   1b530:	42b2      	cmp	r2, r6
   1b532:	d016      	beq.n	1b562 <Ipv4FilterSetActive+0x52>
                if(active)
   1b534:	b146      	cbz	r6, 1b548 <Ipv4FilterSetActive+0x38>
                    ipv4ActFilterCount++;
   1b536:	490d      	ldr	r1, [pc, #52]	; (1b56c <Ipv4FilterSetActive+0x5c>)
   1b538:	680a      	ldr	r2, [r1, #0]
   1b53a:	3201      	adds	r2, #1
   1b53c:	600a      	str	r2, [r1, #0]
                fNode->active = active;
   1b53e:	721e      	strb	r6, [r3, #8]
                activeOk = true;
   1b540:	2401      	movs	r4, #1
   1b542:	e007      	b.n	1b554 <Ipv4FilterSetActive+0x44>
    for(fNode = (IPV4_FILTER_LIST_NODE*)ipv4PacketFilters.list.head; fNode != 0; fNode = fNode->next)
   1b544:	4623      	mov	r3, r4
   1b546:	e7f2      	b.n	1b52e <Ipv4FilterSetActive+0x1e>
                    ipv4ActFilterCount--;
   1b548:	4908      	ldr	r1, [pc, #32]	; (1b56c <Ipv4FilterSetActive+0x5c>)
   1b54a:	680a      	ldr	r2, [r1, #0]
   1b54c:	3a01      	subs	r2, #1
   1b54e:	600a      	str	r2, [r1, #0]
   1b550:	e7f5      	b.n	1b53e <Ipv4FilterSetActive+0x2e>
    bool activeOk = false;
   1b552:	2400      	movs	r4, #0
    TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
   1b554:	4804      	ldr	r0, [pc, #16]	; (1b568 <Ipv4FilterSetActive+0x58>)
   1b556:	f005 fced 	bl	20f34 <TCPIP_Helper_ProtectedSingleListUnlock>
}
   1b55a:	4620      	mov	r0, r4
   1b55c:	bd70      	pop	{r4, r5, r6, pc}
    bool activeOk = false;
   1b55e:	2400      	movs	r4, #0
   1b560:	e7f8      	b.n	1b554 <Ipv4FilterSetActive+0x44>
   1b562:	2400      	movs	r4, #0
   1b564:	e7f6      	b.n	1b554 <Ipv4FilterSetActive+0x44>
   1b566:	bf00      	nop
   1b568:	2000e23c 	.word	0x2000e23c
   1b56c:	2000e3f4 	.word	0x2000e3f4

Disassembly of section .text._DHCPOptionProcessDns%483:

0001b570 <_DHCPOptionProcessDns>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_DNS1))
   1b570:	684b      	ldr	r3, [r1, #4]
   1b572:	2b05      	cmp	r3, #5
   1b574:	d923      	bls.n	1b5be <_DHCPOptionProcessDns+0x4e>
        TCPIP_DHCP_OPTION_DATA_DNS* pDns = (TCPIP_DHCP_OPTION_DATA_DNS*)pOptData->pOpt;
   1b576:	680b      	ldr	r3, [r1, #0]
        if((pDns->len & 0x3) == 0 && pDns->len >= sizeof(pDns->dns1))
   1b578:	785a      	ldrb	r2, [r3, #1]
   1b57a:	f012 0f03 	tst.w	r2, #3
   1b57e:	d121      	bne.n	1b5c4 <_DHCPOptionProcessDns+0x54>
   1b580:	2a03      	cmp	r2, #3
   1b582:	d922      	bls.n	1b5ca <_DHCPOptionProcessDns+0x5a>
            if(pClient->flags.bOfferReceived == 0)
   1b584:	f890 2058 	ldrb.w	r2, [r0, #88]	; 0x58
   1b588:	f012 0f04 	tst.w	r2, #4
   1b58c:	d114      	bne.n	1b5b8 <_DHCPOptionProcessDns+0x48>
                memcpy(&pClient->dhcpDNS, pDns->dns1, sizeof(pClient->dhcpDNS)); 
   1b58e:	f8d3 2002 	ldr.w	r2, [r3, #2]
   1b592:	6382      	str	r2, [r0, #56]	; 0x38
                pClient->validValues.DNS = 1;
   1b594:	f890 2059 	ldrb.w	r2, [r0, #89]	; 0x59
   1b598:	f042 0208 	orr.w	r2, r2, #8
   1b59c:	f880 2059 	strb.w	r2, [r0, #89]	; 0x59
                if(pDns->len >= sizeof(pDns->dns1) + sizeof(pDns->dns2))
   1b5a0:	785a      	ldrb	r2, [r3, #1]
   1b5a2:	2a07      	cmp	r2, #7
   1b5a4:	d908      	bls.n	1b5b8 <_DHCPOptionProcessDns+0x48>
                    memcpy(&pClient->dhcpDNS2, pDns->dns2, sizeof(pClient->dhcpDNS2)); 
   1b5a6:	f8d3 2006 	ldr.w	r2, [r3, #6]
   1b5aa:	63c2      	str	r2, [r0, #60]	; 0x3c
                    pClient->validValues.DNS2 = 1;
   1b5ac:	f890 2059 	ldrb.w	r2, [r0, #89]	; 0x59
   1b5b0:	f042 0210 	orr.w	r2, r2, #16
   1b5b4:	f880 2059 	strb.w	r2, [r0, #89]	; 0x59
            return 2 + pDns->len;
   1b5b8:	7858      	ldrb	r0, [r3, #1]
   1b5ba:	3002      	adds	r0, #2
   1b5bc:	4770      	bx	lr
    return -1;
   1b5be:	f04f 30ff 	mov.w	r0, #4294967295
   1b5c2:	4770      	bx	lr
   1b5c4:	f04f 30ff 	mov.w	r0, #4294967295
   1b5c8:	4770      	bx	lr
   1b5ca:	f04f 30ff 	mov.w	r0, #4294967295
}
   1b5ce:	4770      	bx	lr

Disassembly of section .text.TCPIP_DHCP_Disable%484:

0001b5d0 <TCPIP_DHCP_Disable>:
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   1b5d0:	b1c0      	cbz	r0, 1b604 <TCPIP_DHCP_Disable+0x34>
{
   1b5d2:	b538      	push	{r3, r4, r5, lr}
   1b5d4:	4604      	mov	r4, r0
   1b5d6:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1b5da:	f012 0f40 	tst.w	r2, #64	; 0x40
   1b5de:	d113      	bne.n	1b608 <TCPIP_DHCP_Disable+0x38>
    return false;
   1b5e0:	2000      	movs	r0, #0
}
   1b5e2:	bd38      	pop	{r3, r4, r5, pc}
            _DHCPClientClose(pNetIf, true, true);
   1b5e4:	2201      	movs	r2, #1
   1b5e6:	4611      	mov	r1, r2
   1b5e8:	4620      	mov	r0, r4
   1b5ea:	f7fd fa1f 	bl	18a2c <_DHCPClientClose>
            TCPIP_STACK_AddressServiceEvent(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_DHCPC, TCPIP_STACK_ADDRESS_SERVICE_EVENT_USER_STOP);
   1b5ee:	2203      	movs	r2, #3
   1b5f0:	2101      	movs	r1, #1
   1b5f2:	4620      	mov	r0, r4
   1b5f4:	f002 f80c 	bl	1d610 <TCPIP_STACK_AddressServiceEvent>
            _DHCPNotifyClients(pNetIf, DHCP_EVENT_SERVICE_DISABLED);
   1b5f8:	210d      	movs	r1, #13
   1b5fa:	4620      	mov	r0, r4
   1b5fc:	f002 fdaa 	bl	1e154 <_DHCPNotifyClients>
        return true;
   1b600:	2001      	movs	r0, #1
   1b602:	e7ee      	b.n	1b5e2 <TCPIP_DHCP_Disable+0x12>
    return false;
   1b604:	2000      	movs	r0, #0
}
   1b606:	4770      	bx	lr
    if(DHCPClients && pNetIf)
   1b608:	4a08      	ldr	r2, [pc, #32]	; (1b62c <TCPIP_DHCP_Disable+0x5c>)
   1b60a:	6815      	ldr	r5, [r2, #0]
   1b60c:	b165      	cbz	r5, 1b628 <TCPIP_DHCP_Disable+0x58>
        DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   1b60e:	4620      	mov	r0, r4
   1b610:	f006 fb88 	bl	21d24 <TCPIP_STACK_NetIxGet>
        if(pClient->flags.bDHCPEnabled != 0)
   1b614:	235c      	movs	r3, #92	; 0x5c
   1b616:	fb03 5000 	mla	r0, r3, r0, r5
   1b61a:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   1b61e:	f013 0f01 	tst.w	r3, #1
   1b622:	d1df      	bne.n	1b5e4 <TCPIP_DHCP_Disable+0x14>
        return true;
   1b624:	2001      	movs	r0, #1
   1b626:	e7dc      	b.n	1b5e2 <TCPIP_DHCP_Disable+0x12>
    return false;
   1b628:	2000      	movs	r0, #0
   1b62a:	e7da      	b.n	1b5e2 <TCPIP_DHCP_Disable+0x12>
   1b62c:	2000e408 	.word	0x2000e408

Disassembly of section .text.TCPIP_DNS_ClientDeinitialize%485:

0001b630 <TCPIP_DNS_ClientDeinitialize>:
    if(dnsInitCount > 0)
   1b630:	4b15      	ldr	r3, [pc, #84]	; (1b688 <TCPIP_DNS_ClientDeinitialize+0x58>)
   1b632:	681b      	ldr	r3, [r3, #0]
   1b634:	2b00      	cmp	r3, #0
   1b636:	dc00      	bgt.n	1b63a <TCPIP_DNS_ClientDeinitialize+0xa>
   1b638:	4770      	bx	lr
{
   1b63a:	b530      	push	{r4, r5, lr}
   1b63c:	b095      	sub	sp, #84	; 0x54
   1b63e:	4604      	mov	r4, r0
        TCPIP_DNS_DCPT* pDnsDcpt = pgDnsDcpt;
   1b640:	4b12      	ldr	r3, [pc, #72]	; (1b68c <TCPIP_DNS_ClientDeinitialize+0x5c>)
   1b642:	681d      	ldr	r5, [r3, #0]
        if(TCPIP_UDP_SocketInfoGet(pDnsDcpt->dnsSocket, &sktInfo))
   1b644:	4669      	mov	r1, sp
   1b646:	f9b5 0024 	ldrsh.w	r0, [r5, #36]	; 0x24
   1b64a:	f7ff fe33 	bl	1b2b4 <TCPIP_UDP_SocketInfoGet>
   1b64e:	b118      	cbz	r0, 1b658 <TCPIP_DNS_ClientDeinitialize+0x28>
            if(sktInfo.hNet == stackData->pNetIf)
   1b650:	6963      	ldr	r3, [r4, #20]
   1b652:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1b654:	429a      	cmp	r2, r3
   1b656:	d004      	beq.n	1b662 <TCPIP_DNS_ClientDeinitialize+0x32>
        if(stackData->stackAction == TCPIP_STACK_ACTION_DEINIT)
   1b658:	7f23      	ldrb	r3, [r4, #28]
   1b65a:	2b02      	cmp	r3, #2
   1b65c:	d007      	beq.n	1b66e <TCPIP_DNS_ClientDeinitialize+0x3e>
}
   1b65e:	b015      	add	sp, #84	; 0x54
   1b660:	bd30      	pop	{r4, r5, pc}
                TCPIP_UDP_Disconnect(pDnsDcpt->dnsSocket, true);
   1b662:	2101      	movs	r1, #1
   1b664:	f9b5 0024 	ldrsh.w	r0, [r5, #36]	; 0x24
   1b668:	f7fc fa74 	bl	17b54 <TCPIP_UDP_Disconnect>
   1b66c:	e7f4      	b.n	1b658 <TCPIP_DNS_ClientDeinitialize+0x28>
            if(--dnsInitCount == 0)
   1b66e:	4a06      	ldr	r2, [pc, #24]	; (1b688 <TCPIP_DNS_ClientDeinitialize+0x58>)
   1b670:	6813      	ldr	r3, [r2, #0]
   1b672:	3b01      	subs	r3, #1
   1b674:	6013      	str	r3, [r2, #0]
   1b676:	2b00      	cmp	r3, #0
   1b678:	d1f1      	bne.n	1b65e <TCPIP_DNS_ClientDeinitialize+0x2e>
                _DNSClientCleanup(pDnsDcpt);
   1b67a:	4628      	mov	r0, r5
   1b67c:	f004 f842 	bl	1f704 <_DNSClientCleanup>
                pgDnsDcpt = 0;
   1b680:	4b02      	ldr	r3, [pc, #8]	; (1b68c <TCPIP_DNS_ClientDeinitialize+0x5c>)
   1b682:	2200      	movs	r2, #0
   1b684:	601a      	str	r2, [r3, #0]
}
   1b686:	e7ea      	b.n	1b65e <TCPIP_DNS_ClientDeinitialize+0x2e>
   1b688:	2000e420 	.word	0x2000e420
   1b68c:	2000e424 	.word	0x2000e424

Disassembly of section .text.TCPIP_DNS_GetIPAddressesNumber%486:

0001b690 <TCPIP_DNS_GetIPAddressesNumber>:
    pDnsDcpt = pgDnsDcpt;
   1b690:	4b16      	ldr	r3, [pc, #88]	; (1b6ec <TCPIP_DNS_GetIPAddressesNumber+0x5c>)
   1b692:	681b      	ldr	r3, [r3, #0]
    if(pDnsDcpt == 0 || hostName == 0)
   1b694:	b313      	cbz	r3, 1b6dc <TCPIP_DNS_GetIPAddressesNumber+0x4c>
{
   1b696:	b510      	push	{r4, lr}
   1b698:	460c      	mov	r4, r1
    if(pDnsDcpt == 0 || hostName == 0)
   1b69a:	b308      	cbz	r0, 1b6e0 <TCPIP_DNS_GetIPAddressesNumber+0x50>
    if(type == IP_ADDRESS_TYPE_IPV4)
   1b69c:	2901      	cmp	r1, #1
   1b69e:	d003      	beq.n	1b6a8 <TCPIP_DNS_GetIPAddressesNumber+0x18>
        recMask = TCPIP_DNS_ADDRESS_REC_IPV4 | TCPIP_DNS_ADDRESS_REC_IPV6;
   1b6a0:	2902      	cmp	r1, #2
   1b6a2:	bf0c      	ite	eq
   1b6a4:	460c      	moveq	r4, r1
   1b6a6:	2403      	movne	r4, #3
    hE = TCPIP_OAHASH_EntryLookup(pDnsDcpt->hashDcpt, hostName);
   1b6a8:	4601      	mov	r1, r0
   1b6aa:	6818      	ldr	r0, [r3, #0]
   1b6ac:	f7ff fb6a 	bl	1ad84 <TCPIP_OAHASH_EntryLookup>
    if(hE != 0)
   1b6b0:	4603      	mov	r3, r0
   1b6b2:	b1b8      	cbz	r0, 1b6e4 <TCPIP_DNS_GetIPAddressesNumber+0x54>
        if(hE->flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE)
   1b6b4:	8802      	ldrh	r2, [r0, #0]
   1b6b6:	f012 0f80 	tst.w	r2, #128	; 0x80
   1b6ba:	d015      	beq.n	1b6e8 <TCPIP_DNS_GetIPAddressesNumber+0x58>
            if(((dnsHashEntry->recordMask & recMask) & TCPIP_DNS_ADDRESS_REC_IPV4) != 0)
   1b6bc:	f890 202a 	ldrb.w	r2, [r0, #42]	; 0x2a
   1b6c0:	4014      	ands	r4, r2
   1b6c2:	f014 0f01 	tst.w	r4, #1
                nAddresses += dnsHashEntry->nIPv4Entries;
   1b6c6:	bf14      	ite	ne
   1b6c8:	f890 0026 	ldrbne.w	r0, [r0, #38]	; 0x26
    nAddresses = 0;
   1b6cc:	2000      	moveq	r0, #0
            if(((dnsHashEntry->recordMask & recMask) & TCPIP_DNS_ADDRESS_REC_IPV6) != 0)
   1b6ce:	f014 0f02 	tst.w	r4, #2
   1b6d2:	d00a      	beq.n	1b6ea <TCPIP_DNS_GetIPAddressesNumber+0x5a>
                 nAddresses += dnsHashEntry->nIPv6Entries;
   1b6d4:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
   1b6d8:	4418      	add	r0, r3
   1b6da:	e006      	b.n	1b6ea <TCPIP_DNS_GetIPAddressesNumber+0x5a>
        return 0;
   1b6dc:	2000      	movs	r0, #0
}
   1b6de:	4770      	bx	lr
        return 0;
   1b6e0:	2000      	movs	r0, #0
   1b6e2:	e002      	b.n	1b6ea <TCPIP_DNS_GetIPAddressesNumber+0x5a>
    nAddresses = 0;
   1b6e4:	2000      	movs	r0, #0
   1b6e6:	e000      	b.n	1b6ea <TCPIP_DNS_GetIPAddressesNumber+0x5a>
   1b6e8:	2000      	movs	r0, #0
}
   1b6ea:	bd10      	pop	{r4, pc}
   1b6ec:	2000e424 	.word	0x2000e424

Disassembly of section .text._TCPIP_SelectDefaultNet%487:

0001b6f0 <_TCPIP_SelectDefaultNet>:
    if(tcpipDefIf.defaultNet == 0)
   1b6f0:	4b14      	ldr	r3, [pc, #80]	; (1b744 <_TCPIP_SelectDefaultNet+0x54>)
   1b6f2:	681b      	ldr	r3, [r3, #0]
   1b6f4:	b12b      	cbz	r3, 1b702 <_TCPIP_SelectDefaultNet+0x12>
    else if(tcpipDefIf.defaultNet == pDownIf)
   1b6f6:	4283      	cmp	r3, r0
   1b6f8:	d000      	beq.n	1b6fc <_TCPIP_SelectDefaultNet+0xc>
}
   1b6fa:	4770      	bx	lr
        tcpipDefIf.defaultNet = 0;
   1b6fc:	4b11      	ldr	r3, [pc, #68]	; (1b744 <_TCPIP_SelectDefaultNet+0x54>)
   1b6fe:	2200      	movs	r2, #0
   1b700:	601a      	str	r2, [r3, #0]
        for(netIx = 0, pIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1b702:	4b11      	ldr	r3, [pc, #68]	; (1b748 <_TCPIP_SelectDefaultNet+0x58>)
   1b704:	681b      	ldr	r3, [r3, #0]
   1b706:	4a11      	ldr	r2, [pc, #68]	; (1b74c <_TCPIP_SelectDefaultNet+0x5c>)
   1b708:	6810      	ldr	r0, [r2, #0]
   1b70a:	2800      	cmp	r0, #0
        pNewIf = 0;
   1b70c:	bfd8      	it	le
   1b70e:	2300      	movle	r3, #0
        for(netIx = 0, pIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1b710:	dd14      	ble.n	1b73c <_TCPIP_SelectDefaultNet+0x4c>
            if(pIf->Flags.bInterfaceEnabled)
   1b712:	f893 2042 	ldrb.w	r2, [r3, #66]	; 0x42
   1b716:	f012 0f40 	tst.w	r2, #64	; 0x40
   1b71a:	d10b      	bne.n	1b734 <_TCPIP_SelectDefaultNet+0x44>
        for(netIx = 0, pIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1b71c:	2200      	movs	r2, #0
   1b71e:	3201      	adds	r2, #1
   1b720:	336c      	adds	r3, #108	; 0x6c
   1b722:	4282      	cmp	r2, r0
   1b724:	d005      	beq.n	1b732 <_TCPIP_SelectDefaultNet+0x42>
            if(pIf->Flags.bInterfaceEnabled)
   1b726:	f893 1042 	ldrb.w	r1, [r3, #66]	; 0x42
   1b72a:	f011 0f40 	tst.w	r1, #64	; 0x40
   1b72e:	d0f6      	beq.n	1b71e <_TCPIP_SelectDefaultNet+0x2e>
   1b730:	e000      	b.n	1b734 <_TCPIP_SelectDefaultNet+0x44>
        pNewIf = 0;
   1b732:	2300      	movs	r3, #0
        if(tcpipDefIf.defaultNet == 0)
   1b734:	4a03      	ldr	r2, [pc, #12]	; (1b744 <_TCPIP_SelectDefaultNet+0x54>)
   1b736:	6812      	ldr	r2, [r2, #0]
   1b738:	2a00      	cmp	r2, #0
   1b73a:	d1de      	bne.n	1b6fa <_TCPIP_SelectDefaultNet+0xa>
            tcpipDefIf.defaultNet = pNewIf;
   1b73c:	4a01      	ldr	r2, [pc, #4]	; (1b744 <_TCPIP_SelectDefaultNet+0x54>)
   1b73e:	6013      	str	r3, [r2, #0]
}
   1b740:	4770      	bx	lr
   1b742:	bf00      	nop
   1b744:	2000e43c 	.word	0x2000e43c
   1b748:	2000e440 	.word	0x2000e440
   1b74c:	2000e0f0 	.word	0x2000e0f0

Disassembly of section .text.gfx_mono_ssd1306_draw_pixel%488:

0001b750 <gfx_mono_ssd1306_draw_pixel>:
    uint8_t page;
    uint8_t pixel_mask;
    uint8_t pixel_value;

    /* Discard pixels drawn outside the screen */
    if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
   1b750:	f010 0f80 	tst.w	r0, #128	; 0x80
   1b754:	d101      	bne.n	1b75a <gfx_mono_ssd1306_draw_pixel+0xa>
   1b756:	291f      	cmp	r1, #31
   1b758:	d900      	bls.n	1b75c <gfx_mono_ssd1306_draw_pixel+0xc>
   1b75a:	4770      	bx	lr
        gfx_coord_t color) {
   1b75c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1b760:	4614      	mov	r4, r2
   1b762:	4605      	mov	r5, r0
        return;
    }

    page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
   1b764:	08ce      	lsrs	r6, r1, #3
    pixel_mask = (1 << (y - (page * 8)));
   1b766:	eba1 01c6 	sub.w	r1, r1, r6, lsl #3
   1b76a:	2201      	movs	r2, #1
   1b76c:	fa02 f701 	lsl.w	r7, r2, r1
   1b770:	fa5f f887 	uxtb.w	r8, r7
    data = gfx_mono_ssd1306_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_ssd1306_get_byte(gfx_coord_t page, gfx_coord_t column) {
#ifdef CONFIG_SSD1306_FRAMEBUFFER
    return gfx_mono_framebuffer_get_byte(page, column);
   1b774:	4601      	mov	r1, r0
   1b776:	4630      	mov	r0, r6
   1b778:	f006 fa68 	bl	21c4c <gfx_mono_framebuffer_get_byte>
   1b77c:	4602      	mov	r2, r0
    switch (color) {
   1b77e:	2c01      	cmp	r4, #1
   1b780:	d00a      	beq.n	1b798 <gfx_mono_ssd1306_draw_pixel+0x48>
   1b782:	b263      	sxtb	r3, r4
   1b784:	b163      	cbz	r3, 1b7a0 <gfx_mono_ssd1306_draw_pixel+0x50>
   1b786:	2c02      	cmp	r4, #2
   1b788:	d00e      	beq.n	1b7a8 <gfx_mono_ssd1306_draw_pixel+0x58>
    gfx_mono_put_byte(page, x, pixel_value);
   1b78a:	2300      	movs	r3, #0
   1b78c:	4629      	mov	r1, r5
   1b78e:	4630      	mov	r0, r6
   1b790:	f001 ffe8 	bl	1d764 <gfx_mono_ssd1306_put_byte>
}
   1b794:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            pixel_value |= pixel_mask;
   1b798:	ea48 0200 	orr.w	r2, r8, r0
   1b79c:	b2d2      	uxtb	r2, r2
            break;
   1b79e:	e7f4      	b.n	1b78a <gfx_mono_ssd1306_draw_pixel+0x3a>
            pixel_value &= ~pixel_mask;
   1b7a0:	ea20 0207 	bic.w	r2, r0, r7
   1b7a4:	b2d2      	uxtb	r2, r2
            break;
   1b7a6:	e7f0      	b.n	1b78a <gfx_mono_ssd1306_draw_pixel+0x3a>
            pixel_value ^= pixel_mask;
   1b7a8:	ea88 0200 	eor.w	r2, r8, r0
   1b7ac:	b2d2      	uxtb	r2, r2
            break;
   1b7ae:	e7ec      	b.n	1b78a <gfx_mono_ssd1306_draw_pixel+0x3a>

Disassembly of section .text.__sinit%489:

0001b7b0 <__sinit>:
   1b7b0:	6983      	ldr	r3, [r0, #24]
   1b7b2:	b510      	push	{r4, lr}
   1b7b4:	4604      	mov	r4, r0
   1b7b6:	bb33      	cbnz	r3, 1b806 <__sinit+0x56>
   1b7b8:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
   1b7bc:	6503      	str	r3, [r0, #80]	; 0x50
   1b7be:	4b12      	ldr	r3, [pc, #72]	; (1b808 <__sinit+0x58>)
   1b7c0:	4a12      	ldr	r2, [pc, #72]	; (1b80c <__sinit+0x5c>)
   1b7c2:	681b      	ldr	r3, [r3, #0]
   1b7c4:	6282      	str	r2, [r0, #40]	; 0x28
   1b7c6:	4298      	cmp	r0, r3
   1b7c8:	bf04      	itt	eq
   1b7ca:	2301      	moveq	r3, #1
   1b7cc:	6183      	streq	r3, [r0, #24]
   1b7ce:	f7fe faff 	bl	19dd0 <__sfp>
   1b7d2:	6060      	str	r0, [r4, #4]
   1b7d4:	4620      	mov	r0, r4
   1b7d6:	f7fe fafb 	bl	19dd0 <__sfp>
   1b7da:	60a0      	str	r0, [r4, #8]
   1b7dc:	4620      	mov	r0, r4
   1b7de:	f7fe faf7 	bl	19dd0 <__sfp>
   1b7e2:	2200      	movs	r2, #0
   1b7e4:	60e0      	str	r0, [r4, #12]
   1b7e6:	2104      	movs	r1, #4
   1b7e8:	6860      	ldr	r0, [r4, #4]
   1b7ea:	f001 fce5 	bl	1d1b8 <std>
   1b7ee:	2201      	movs	r2, #1
   1b7f0:	2109      	movs	r1, #9
   1b7f2:	68a0      	ldr	r0, [r4, #8]
   1b7f4:	f001 fce0 	bl	1d1b8 <std>
   1b7f8:	2202      	movs	r2, #2
   1b7fa:	2112      	movs	r1, #18
   1b7fc:	68e0      	ldr	r0, [r4, #12]
   1b7fe:	f001 fcdb 	bl	1d1b8 <std>
   1b802:	2301      	movs	r3, #1
   1b804:	61a3      	str	r3, [r4, #24]
   1b806:	bd10      	pop	{r4, pc}
   1b808:	00022270 	.word	0x00022270
   1b80c:	000220a5 	.word	0x000220a5

Disassembly of section .text.__lo0bits%490:

0001b810 <__lo0bits>:
   1b810:	6803      	ldr	r3, [r0, #0]
   1b812:	f013 0207 	ands.w	r2, r3, #7
   1b816:	4601      	mov	r1, r0
   1b818:	d00b      	beq.n	1b832 <__lo0bits+0x22>
   1b81a:	07da      	lsls	r2, r3, #31
   1b81c:	d424      	bmi.n	1b868 <__lo0bits+0x58>
   1b81e:	0799      	lsls	r1, r3, #30
   1b820:	bf4b      	itete	mi
   1b822:	085b      	lsrmi	r3, r3, #1
   1b824:	089b      	lsrpl	r3, r3, #2
   1b826:	6003      	strmi	r3, [r0, #0]
   1b828:	6003      	strpl	r3, [r0, #0]
   1b82a:	bf4c      	ite	mi
   1b82c:	2001      	movmi	r0, #1
   1b82e:	2002      	movpl	r0, #2
   1b830:	4770      	bx	lr
   1b832:	b298      	uxth	r0, r3
   1b834:	b9b0      	cbnz	r0, 1b864 <__lo0bits+0x54>
   1b836:	0c1b      	lsrs	r3, r3, #16
   1b838:	2010      	movs	r0, #16
   1b83a:	f013 0fff 	tst.w	r3, #255	; 0xff
   1b83e:	bf04      	itt	eq
   1b840:	0a1b      	lsreq	r3, r3, #8
   1b842:	3008      	addeq	r0, #8
   1b844:	071a      	lsls	r2, r3, #28
   1b846:	bf04      	itt	eq
   1b848:	091b      	lsreq	r3, r3, #4
   1b84a:	3004      	addeq	r0, #4
   1b84c:	079a      	lsls	r2, r3, #30
   1b84e:	bf04      	itt	eq
   1b850:	089b      	lsreq	r3, r3, #2
   1b852:	3002      	addeq	r0, #2
   1b854:	07da      	lsls	r2, r3, #31
   1b856:	d403      	bmi.n	1b860 <__lo0bits+0x50>
   1b858:	085b      	lsrs	r3, r3, #1
   1b85a:	f100 0001 	add.w	r0, r0, #1
   1b85e:	d005      	beq.n	1b86c <__lo0bits+0x5c>
   1b860:	600b      	str	r3, [r1, #0]
   1b862:	4770      	bx	lr
   1b864:	4610      	mov	r0, r2
   1b866:	e7e8      	b.n	1b83a <__lo0bits+0x2a>
   1b868:	2000      	movs	r0, #0
   1b86a:	4770      	bx	lr
   1b86c:	2020      	movs	r0, #32
   1b86e:	4770      	bx	lr

Disassembly of section .rodata.DRV_ETHPHY_OBJECT_BASE_Default%491:

0001b870 <DRV_ETHPHY_OBJECT_BASE_Default>:
   1b870:	bcbd 0001 f871 0001 13f5 0002 0871 0002     ....q.......q...
   1b880:	fcdd 0001 ac4d 0001 f819 0001 0891 0002     ....M...........
   1b890:	08b1 0002 fd55 0001 fd05 0001 5389 0001     ....U........S..
   1b8a0:	d9b5 0001 e635 0001 d975 0001 cd39 0001     ....5...u...9...
   1b8b0:	c50d 0001 d935 0001 f845 0001 03ad 0002     ....5...E.......
   1b8c0:	9321 0001 981d 0001 93a1 0001               !...........

Disassembly of section .text._DRV_GMAC_LinkStateWaitLinkUp%492:

0001b8cc <_DRV_GMAC_LinkStateWaitLinkUp>:
{
   1b8cc:	b510      	push	{r4, lr}
   1b8ce:	4604      	mov	r4, r0
	if(pMACDrv->sGmacData._macFlags._linkUpDone == 0)
   1b8d0:	7d83      	ldrb	r3, [r0, #22]
   1b8d2:	f013 0f20 	tst.w	r3, #32
   1b8d6:	d010      	beq.n	1b8fa <_DRV_GMAC_LinkStateWaitLinkUp+0x2e>
	if(pMACDrv->sGmacData._macFlags._linkNegotiation == 0)
   1b8d8:	7da3      	ldrb	r3, [r4, #22]
   1b8da:	f013 0f08 	tst.w	r3, #8
   1b8de:	d018      	beq.n	1b912 <_DRV_GMAC_LinkStateWaitLinkUp+0x46>
	phyRes = pMACDrv->sGmacData.gmacConfig.pPhyBase->DRV_ETHPHY_NegotiationIsComplete(pMACDrv->sGmacData.hPhyClient, DRV_ETHPHY_INF_IDX_ALL_EXTERNAL, false);
   1b8e0:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
   1b8e4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1b8e6:	2200      	movs	r2, #0
   1b8e8:	4611      	mov	r1, r2
   1b8ea:	6920      	ldr	r0, [r4, #16]
   1b8ec:	4798      	blx	r3
	if(phyRes < 0)
   1b8ee:	2800      	cmp	r0, #0
   1b8f0:	db16      	blt.n	1b920 <_DRV_GMAC_LinkStateWaitLinkUp+0x54>
		pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_NEG_COMPLETE;
   1b8f2:	2303      	movs	r3, #3
   1b8f4:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
}
   1b8f8:	bd10      	pop	{r4, pc}
		uint32_t currTick = SYS_TMR_TickCountGet();
   1b8fa:	f004 fbf7 	bl	200ec <SYS_TMR_TickCountGet>
		if(currTick - pMACDrv->sGmacData._linkUpTick < pMACDrv->sGmacData._linkWaitTick)
   1b8fe:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1b900:	1ac0      	subs	r0, r0, r3
   1b902:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1b904:	4298      	cmp	r0, r3
   1b906:	d3f7      	bcc.n	1b8f8 <_DRV_GMAC_LinkStateWaitLinkUp+0x2c>
		pMACDrv->sGmacData._macFlags._linkUpDone = 1;
   1b908:	7da3      	ldrb	r3, [r4, #22]
   1b90a:	f043 0320 	orr.w	r3, r3, #32
   1b90e:	75a3      	strb	r3, [r4, #22]
   1b910:	e7e2      	b.n	1b8d8 <_DRV_GMAC_LinkStateWaitLinkUp+0xc>
		pMACDrv->sGmacData._macFlags._linkPrev = true;
   1b912:	f043 0310 	orr.w	r3, r3, #16
   1b916:	75a3      	strb	r3, [r4, #22]
		pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_START_LINK;
   1b918:	2300      	movs	r3, #0
   1b91a:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
		return;
   1b91e:	e7eb      	b.n	1b8f8 <_DRV_GMAC_LinkStateWaitLinkUp+0x2c>
		_DRV_GMAC_LinkStateDown(pMACDrv);
   1b920:	4620      	mov	r0, r4
   1b922:	f005 f9e5 	bl	20cf0 <_DRV_GMAC_LinkStateDown>
   1b926:	e7e7      	b.n	1b8f8 <_DRV_GMAC_LinkStateWaitLinkUp+0x2c>

Disassembly of section .text._TcpClientSocketConnect%493:

0001b928 <_TcpClientSocketConnect>:
    switch(pSkt->addType)
   1b928:	f890 306f 	ldrb.w	r3, [r0, #111]	; 0x6f
   1b92c:	2b01      	cmp	r3, #1
   1b92e:	d002      	beq.n	1b936 <_TcpClientSocketConnect+0xe>
            return -1;  // IP_ADDRESS_TYPE_ANY
   1b930:	f04f 30ff 	mov.w	r0, #4294967295
   1b934:	4770      	bx	lr
            if( pSkt->destAddress.Val == 0)
   1b936:	6b83      	ldr	r3, [r0, #56]	; 0x38
   1b938:	b913      	cbnz	r3, 1b940 <_TcpClientSocketConnect+0x18>
                return -1;
   1b93a:	f04f 30ff 	mov.w	r0, #4294967295
}
   1b93e:	4770      	bx	lr
{
   1b940:	b510      	push	{r4, lr}
   1b942:	4604      	mov	r4, r0
    return (pAdd->w[1] + pAdd->w[0] + pSkt->remotePort) ^ pSkt->localPort;
   1b944:	8f43      	ldrh	r3, [r0, #58]	; 0x3a
   1b946:	8f02      	ldrh	r2, [r0, #56]	; 0x38
   1b948:	4413      	add	r3, r2
   1b94a:	f8b0 2058 	ldrh.w	r2, [r0, #88]	; 0x58
   1b94e:	4413      	add	r3, r2
   1b950:	f8b0 205a 	ldrh.w	r2, [r0, #90]	; 0x5a
   1b954:	4053      	eors	r3, r2
            pSkt->remoteHash = _TCP_ClientIPV4RemoteHash(&pSkt->destAddress, pSkt);
   1b956:	f8a0 306a 	strh.w	r3, [r0, #106]	; 0x6a
    pSkt->retryCount = 0;
   1b95a:	2300      	movs	r3, #0
   1b95c:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    pSkt->retryInterval = (SYS_TMR_TickCounterFrequencyGet()/4);
   1b960:	f004 fbec 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
   1b964:	0880      	lsrs	r0, r0, #2
   1b966:	64a0      	str	r0, [r4, #72]	; 0x48
    _TCP_SEND_RES sendRes = _TcpSend(pSkt, SYN, SENDTCP_RESET_TIMERS);
   1b968:	2201      	movs	r2, #1
   1b96a:	2102      	movs	r1, #2
   1b96c:	4620      	mov	r0, r4
   1b96e:	f7ec f959 	bl	7c24 <_TcpSend>
    if(sendRes == _TCP_SEND_OK)
   1b972:	b128      	cbz	r0, 1b980 <_TcpClientSocketConnect+0x58>
    return sendRes > 0 ? 1 : -1;
   1b974:	2800      	cmp	r0, #0
   1b976:	bfcc      	ite	gt
   1b978:	2001      	movgt	r0, #1
   1b97a:	f04f 30ff 	movle.w	r0, #4294967295
}
   1b97e:	bd10      	pop	{r4, pc}
        return 0;
   1b980:	2000      	movs	r0, #0
   1b982:	e7fc      	b.n	1b97e <_TcpClientSocketConnect+0x56>

Disassembly of section .text.TCPIP_ARP_Probe%494:

0001b984 <TCPIP_ARP_Probe>:
    if(IPAddr == 0 || IPAddr->Val == 0 || srcAddr == 0)
   1b984:	b1e9      	cbz	r1, 1b9c2 <TCPIP_ARP_Probe+0x3e>
{
   1b986:	b5f0      	push	{r4, r5, r6, r7, lr}
   1b988:	b083      	sub	sp, #12
   1b98a:	460c      	mov	r4, r1
    if(IPAddr == 0 || IPAddr->Val == 0 || srcAddr == 0)
   1b98c:	6809      	ldr	r1, [r1, #0]
   1b98e:	b1d9      	cbz	r1, 1b9c8 <TCPIP_ARP_Probe+0x44>
   1b990:	b1ea      	cbz	r2, 1b9ce <TCPIP_ARP_Probe+0x4a>
   1b992:	461d      	mov	r5, r3
   1b994:	4616      	mov	r6, r2
    pIf =_TCPIPStackHandleToNetLinked(hNet);
   1b996:	f005 f8bb 	bl	20b10 <_TCPIPStackHandleToNetLinked>
    if(pIf == 0)
   1b99a:	4607      	mov	r7, r0
   1b99c:	b1d0      	cbz	r0, 1b9d4 <TCPIP_ARP_Probe+0x50>
    return pNetIf->Flags.bInConfig != 0;
   1b99e:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
    if(_TCPIPStackIsConfig(pIf) && (opType & ARP_OPERATION_CONFIGURE) == 0)
   1b9a2:	f013 0f10 	tst.w	r3, #16
   1b9a6:	d002      	beq.n	1b9ae <TCPIP_ARP_Probe+0x2a>
   1b9a8:	f415 5f80 	tst.w	r5, #4096	; 0x1000
   1b9ac:	d015      	beq.n	1b9da <TCPIP_ARP_Probe+0x56>
    return _ARPProbeAddress(pIf, IPAddr, srcAddr, opType, 0);
   1b9ae:	2300      	movs	r3, #0
   1b9b0:	9300      	str	r3, [sp, #0]
   1b9b2:	462b      	mov	r3, r5
   1b9b4:	4632      	mov	r2, r6
   1b9b6:	4621      	mov	r1, r4
   1b9b8:	4638      	mov	r0, r7
   1b9ba:	f7f9 f943 	bl	14c44 <_ARPProbeAddress>
}
   1b9be:	b003      	add	sp, #12
   1b9c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return ARP_RES_BAD_ADDRESS;
   1b9c2:	f06f 0004 	mvn.w	r0, #4
}
   1b9c6:	4770      	bx	lr
        return ARP_RES_BAD_ADDRESS;
   1b9c8:	f06f 0004 	mvn.w	r0, #4
   1b9cc:	e7f7      	b.n	1b9be <TCPIP_ARP_Probe+0x3a>
   1b9ce:	f06f 0004 	mvn.w	r0, #4
   1b9d2:	e7f4      	b.n	1b9be <TCPIP_ARP_Probe+0x3a>
        return ARP_RES_NO_INTERFACE;
   1b9d4:	f06f 0005 	mvn.w	r0, #5
   1b9d8:	e7f1      	b.n	1b9be <TCPIP_ARP_Probe+0x3a>
        return ARP_RES_CONFIGURE_ERR;
   1b9da:	f06f 0007 	mvn.w	r0, #7
   1b9de:	e7ee      	b.n	1b9be <TCPIP_ARP_Probe+0x3a>

Disassembly of section .text.TCPIP_DHCP_Enable%495:

0001b9e0 <TCPIP_DHCP_Enable>:
{
   1b9e0:	b538      	push	{r3, r4, r5, lr}
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   1b9e2:	b1a0      	cbz	r0, 1ba0e <TCPIP_DHCP_Enable+0x2e>
   1b9e4:	4604      	mov	r4, r0
   1b9e6:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1b9ea:	f012 0f40 	tst.w	r2, #64	; 0x40
   1b9ee:	d112      	bne.n	1ba16 <TCPIP_DHCP_Enable+0x36>
        return false;
   1b9f0:	2500      	movs	r5, #0
}
   1b9f2:	4628      	mov	r0, r5
   1b9f4:	bd38      	pop	{r3, r4, r5, pc}
            if(TCPIP_STACK_AddressServiceCanStart(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_DHCPC))
   1b9f6:	2101      	movs	r1, #1
   1b9f8:	4620      	mov	r0, r4
   1b9fa:	f005 fef8 	bl	217ee <TCPIP_STACK_AddressServiceCanStart>
   1b9fe:	4605      	mov	r5, r0
   1ba00:	2800      	cmp	r0, #0
   1ba02:	d0f6      	beq.n	1b9f2 <TCPIP_DHCP_Enable+0x12>
        _DHCPEnable(pNetIf, opType);
   1ba04:	2101      	movs	r1, #1
   1ba06:	4620      	mov	r0, r4
   1ba08:	f7fc fc06 	bl	18218 <_DHCPEnable>
        return true;
   1ba0c:	e7f1      	b.n	1b9f2 <TCPIP_DHCP_Enable+0x12>
        return false;
   1ba0e:	2500      	movs	r5, #0
   1ba10:	e7ef      	b.n	1b9f2 <TCPIP_DHCP_Enable+0x12>
   1ba12:	2500      	movs	r5, #0
    return _DHCPStartOperation(_TCPIPStackHandleToNetUp(hNet), TCPIP_DHCP_OP_REQ_ENABLE, 0);
   1ba14:	e7ed      	b.n	1b9f2 <TCPIP_DHCP_Enable+0x12>
    if(DHCPClients == 0 || pNetIf == 0)
   1ba16:	4a08      	ldr	r2, [pc, #32]	; (1ba38 <TCPIP_DHCP_Enable+0x58>)
   1ba18:	6815      	ldr	r5, [r2, #0]
   1ba1a:	2d00      	cmp	r5, #0
   1ba1c:	d0f9      	beq.n	1ba12 <TCPIP_DHCP_Enable+0x32>
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   1ba1e:	4620      	mov	r0, r4
   1ba20:	f006 f980 	bl	21d24 <TCPIP_STACK_NetIxGet>
            if(pClient->flags.bDHCPEnabled != 0)
   1ba24:	235c      	movs	r3, #92	; 0x5c
   1ba26:	fb03 5000 	mla	r0, r3, r0, r5
   1ba2a:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   1ba2e:	f013 0f01 	tst.w	r3, #1
   1ba32:	d0e0      	beq.n	1b9f6 <TCPIP_DHCP_Enable+0x16>
                return true;
   1ba34:	2501      	movs	r5, #1
   1ba36:	e7dc      	b.n	1b9f2 <TCPIP_DHCP_Enable+0x12>
   1ba38:	2000e408 	.word	0x2000e408

Disassembly of section .text._TCPIPStackIpAddFromAnyNet%496:

0001ba3c <_TCPIPStackIpAddFromAnyNet>:
    if(pIpAddress && pIpAddress->Val != 0)
   1ba3c:	b329      	cbz	r1, 1ba8a <_TCPIPStackIpAddFromAnyNet+0x4e>
{
   1ba3e:	b470      	push	{r4, r5, r6}
    if(pIpAddress && pIpAddress->Val != 0)
   1ba40:	680e      	ldr	r6, [r1, #0]
   1ba42:	b1f6      	cbz	r6, 1ba82 <_TCPIPStackIpAddFromAnyNet+0x46>
        for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1ba44:	4b12      	ldr	r3, [pc, #72]	; (1ba90 <_TCPIPStackIpAddFromAnyNet+0x54>)
   1ba46:	6819      	ldr	r1, [r3, #0]
   1ba48:	4b12      	ldr	r3, [pc, #72]	; (1ba94 <_TCPIPStackIpAddFromAnyNet+0x58>)
   1ba4a:	681a      	ldr	r2, [r3, #0]
   1ba4c:	2a00      	cmp	r2, #0
   1ba4e:	dd1a      	ble.n	1ba86 <_TCPIPStackIpAddFromAnyNet+0x4a>
   1ba50:	2300      	movs	r3, #0
   1ba52:	e00d      	b.n	1ba70 <_TCPIPStackIpAddFromAnyNet+0x34>
                if(pIf->Flags.bInterfaceEnabled)
   1ba54:	f891 4042 	ldrb.w	r4, [r1, #66]	; 0x42
   1ba58:	f014 0f40 	tst.w	r4, #64	; 0x40
   1ba5c:	d004      	beq.n	1ba68 <_TCPIPStackIpAddFromAnyNet+0x2c>
    return ((pIf->netIPAddr.Val ^ pIpAddress->Val) & pIf->netMask.Val) == 0;
   1ba5e:	684c      	ldr	r4, [r1, #4]
   1ba60:	4074      	eors	r4, r6
   1ba62:	688d      	ldr	r5, [r1, #8]
                    if(_TCPIPStackIpAddFromLAN(pIf, pIpAddress))
   1ba64:	422c      	tst	r4, r5
   1ba66:	d009      	beq.n	1ba7c <_TCPIPStackIpAddFromAnyNet+0x40>
        for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1ba68:	3301      	adds	r3, #1
   1ba6a:	316c      	adds	r1, #108	; 0x6c
   1ba6c:	4293      	cmp	r3, r2
   1ba6e:	d004      	beq.n	1ba7a <_TCPIPStackIpAddFromAnyNet+0x3e>
            if(pNetIf == 0 || pIf == pNetIf)
   1ba70:	2800      	cmp	r0, #0
   1ba72:	d0ef      	beq.n	1ba54 <_TCPIPStackIpAddFromAnyNet+0x18>
   1ba74:	4288      	cmp	r0, r1
   1ba76:	d1f7      	bne.n	1ba68 <_TCPIPStackIpAddFromAnyNet+0x2c>
   1ba78:	e7ec      	b.n	1ba54 <_TCPIPStackIpAddFromAnyNet+0x18>
    return 0;
   1ba7a:	2100      	movs	r1, #0
}
   1ba7c:	4608      	mov	r0, r1
   1ba7e:	bc70      	pop	{r4, r5, r6}
   1ba80:	4770      	bx	lr
    return 0;
   1ba82:	2100      	movs	r1, #0
   1ba84:	e7fa      	b.n	1ba7c <_TCPIPStackIpAddFromAnyNet+0x40>
   1ba86:	2100      	movs	r1, #0
   1ba88:	e7f8      	b.n	1ba7c <_TCPIPStackIpAddFromAnyNet+0x40>
}
   1ba8a:	4608      	mov	r0, r1
   1ba8c:	4770      	bx	lr
   1ba8e:	bf00      	nop
   1ba90:	2000e440 	.word	0x2000e440
   1ba94:	2000e0f0 	.word	0x2000e0f0

Disassembly of section .text.SYS_TIME_RemoveFromList%497:

0001ba98 <SYS_TIME_RemoveFromList>:
    SYS_TIME_TIMER_OBJ* tmr = counter->tmrActive;
   1ba98:	4b15      	ldr	r3, [pc, #84]	; (1baf0 <SYS_TIME_RemoveFromList+0x58>)
   1ba9a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    while ((tmr != NULL) && (tmr != delTimer))
   1ba9c:	b31a      	cbz	r2, 1bae6 <SYS_TIME_RemoveFromList+0x4e>
{
   1ba9e:	b410      	push	{r4}
   1baa0:	4601      	mov	r1, r0
    while ((tmr != NULL) && (tmr != delTimer))
   1baa2:	4282      	cmp	r2, r0
   1baa4:	d104      	bne.n	1bab0 <SYS_TIME_RemoveFromList+0x18>
    if (delTimer->tmrNext != NULL)
   1baa6:	6983      	ldr	r3, [r0, #24]
   1baa8:	b1ab      	cbz	r3, 1bad6 <SYS_TIME_RemoveFromList+0x3e>
    SYS_TIME_TIMER_OBJ* prevTmr = NULL;
   1baaa:	2200      	movs	r2, #0
   1baac:	e006      	b.n	1babc <SYS_TIME_RemoveFromList+0x24>
        tmr = tmr->tmrNext;
   1baae:	461a      	mov	r2, r3
   1bab0:	6993      	ldr	r3, [r2, #24]
    while ((tmr != NULL) && (tmr != delTimer))
   1bab2:	b1d3      	cbz	r3, 1baea <SYS_TIME_RemoveFromList+0x52>
   1bab4:	4299      	cmp	r1, r3
   1bab6:	d1fa      	bne.n	1baae <SYS_TIME_RemoveFromList+0x16>
    if (delTimer->tmrNext != NULL)
   1bab8:	698b      	ldr	r3, [r1, #24]
   1baba:	b123      	cbz	r3, 1bac6 <SYS_TIME_RemoveFromList+0x2e>
        uint32_t relativeTimePending = delTimer->relativeTimePending;
   1babc:	688c      	ldr	r4, [r1, #8]
        delTimer->tmrNext->relativeTimePending += relativeTimePending;
   1babe:	6898      	ldr	r0, [r3, #8]
   1bac0:	4420      	add	r0, r4
   1bac2:	6098      	str	r0, [r3, #8]
    if (prevTmr == NULL)
   1bac4:	b14a      	cbz	r2, 1bada <SYS_TIME_RemoveFromList+0x42>
        prevTmr->tmrNext = delTimer->tmrNext;
   1bac6:	698b      	ldr	r3, [r1, #24]
   1bac8:	6193      	str	r3, [r2, #24]
    bool isHeadTimerUpdated = false;
   1baca:	2000      	movs	r0, #0
    delTimer->tmrNext = NULL;
   1bacc:	2300      	movs	r3, #0
   1bace:	618b      	str	r3, [r1, #24]
}
   1bad0:	f85d 4b04 	ldr.w	r4, [sp], #4
   1bad4:	4770      	bx	lr
    SYS_TIME_TIMER_OBJ* prevTmr = NULL;
   1bad6:	461a      	mov	r2, r3
   1bad8:	e7f4      	b.n	1bac4 <SYS_TIME_RemoveFromList+0x2c>
        counter->tmrActive = counter->tmrActive->tmrNext;
   1bada:	4b05      	ldr	r3, [pc, #20]	; (1baf0 <SYS_TIME_RemoveFromList+0x58>)
   1badc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   1bade:	6992      	ldr	r2, [r2, #24]
   1bae0:	631a      	str	r2, [r3, #48]	; 0x30
        isHeadTimerUpdated = true;
   1bae2:	2001      	movs	r0, #1
   1bae4:	e7f2      	b.n	1bacc <SYS_TIME_RemoveFromList+0x34>
        return isHeadTimerUpdated;
   1bae6:	2000      	movs	r0, #0
}
   1bae8:	4770      	bx	lr
        return isHeadTimerUpdated;
   1baea:	2000      	movs	r0, #0
   1baec:	e7f0      	b.n	1bad0 <SYS_TIME_RemoveFromList+0x38>
   1baee:	bf00      	nop
   1baf0:	2000e030 	.word	0x2000e030

Disassembly of section .text.xTaskCheckForTimeOut%498:

0001baf4 <xTaskCheckForTimeOut>:
{
   1baf4:	b570      	push	{r4, r5, r6, lr}
   1baf6:	4604      	mov	r4, r0
   1baf8:	460d      	mov	r5, r1
	taskENTER_CRITICAL();
   1bafa:	f005 f8a9 	bl	20c50 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
   1bafe:	4b12      	ldr	r3, [pc, #72]	; (1bb48 <xTaskCheckForTimeOut+0x54>)
   1bb00:	681a      	ldr	r2, [r3, #0]
			if( *pxTicksToWait == portMAX_DELAY )
   1bb02:	682b      	ldr	r3, [r5, #0]
   1bb04:	f1b3 3fff 	cmp.w	r3, #4294967295
   1bb08:	d016      	beq.n	1bb38 <xTaskCheckForTimeOut+0x44>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   1bb0a:	6861      	ldr	r1, [r4, #4]
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   1bb0c:	480f      	ldr	r0, [pc, #60]	; (1bb4c <xTaskCheckForTimeOut+0x58>)
   1bb0e:	6800      	ldr	r0, [r0, #0]
   1bb10:	6826      	ldr	r6, [r4, #0]
   1bb12:	4286      	cmp	r6, r0
   1bb14:	d001      	beq.n	1bb1a <xTaskCheckForTimeOut+0x26>
   1bb16:	4291      	cmp	r1, r2
   1bb18:	d913      	bls.n	1bb42 <xTaskCheckForTimeOut+0x4e>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   1bb1a:	1a50      	subs	r0, r2, r1
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
   1bb1c:	4283      	cmp	r3, r0
   1bb1e:	d803      	bhi.n	1bb28 <xTaskCheckForTimeOut+0x34>
			*pxTicksToWait = 0;
   1bb20:	2300      	movs	r3, #0
   1bb22:	602b      	str	r3, [r5, #0]
			xReturn = pdTRUE;
   1bb24:	2401      	movs	r4, #1
   1bb26:	e008      	b.n	1bb3a <xTaskCheckForTimeOut+0x46>
			*pxTicksToWait -= xElapsedTime;
   1bb28:	1a9b      	subs	r3, r3, r2
   1bb2a:	440b      	add	r3, r1
   1bb2c:	602b      	str	r3, [r5, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
   1bb2e:	4620      	mov	r0, r4
   1bb30:	f005 fdf8 	bl	21724 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
   1bb34:	2400      	movs	r4, #0
   1bb36:	e000      	b.n	1bb3a <xTaskCheckForTimeOut+0x46>
				xReturn = pdFALSE;
   1bb38:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
   1bb3a:	f005 ff51 	bl	219e0 <vPortExitCritical>
}
   1bb3e:	4620      	mov	r0, r4
   1bb40:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = pdTRUE;
   1bb42:	2401      	movs	r4, #1
   1bb44:	e7f9      	b.n	1bb3a <xTaskCheckForTimeOut+0x46>
   1bb46:	bf00      	nop
   1bb48:	2000e4d0 	.word	0x2000e4d0
   1bb4c:	2000e4c4 	.word	0x2000e4c4

Disassembly of section .text.wc_CryptoCb_RandomBlock%499:

0001bb50 <wc_CryptoCb_RandomBlock>:
}
#endif /* !NO_HMAC */

#ifndef WC_NO_RNG
int wc_CryptoCb_RandomBlock(WC_RNG* rng, byte* out, word32 sz)
{
   1bb50:	b5f0      	push	{r4, r5, r6, r7, lr}
   1bb52:	b0a7      	sub	sp, #156	; 0x9c
   1bb54:	460f      	mov	r7, r1
   1bb56:	4616      	mov	r6, r2
    int ret = CRYPTOCB_UNAVAILABLE;
    CryptoCb* dev;

    /* locate registered callback */
    if (rng) {
   1bb58:	4605      	mov	r5, r0
   1bb5a:	b1e0      	cbz	r0, 1bb96 <wc_CryptoCb_RandomBlock+0x46>
        dev = wc_CryptoCb_FindDevice(rng->devId);
   1bb5c:	6940      	ldr	r0, [r0, #20]
   1bb5e:	f003 fc8b 	bl	1f478 <wc_CryptoCb_FindDevice>
   1bb62:	4604      	mov	r4, r0
    else {
        /* locate first callback and try using it */
        dev = wc_CryptoCb_FindDeviceByIndex(0);
    }

    if (dev && dev->cb) {
   1bb64:	b1e4      	cbz	r4, 1bba0 <wc_CryptoCb_RandomBlock+0x50>
   1bb66:	6863      	ldr	r3, [r4, #4]
   1bb68:	b1eb      	cbz	r3, 1bba6 <wc_CryptoCb_RandomBlock+0x56>
        wc_CryptoInfo cryptoInfo;
        XMEMSET(&cryptoInfo, 0, sizeof(cryptoInfo));
   1bb6a:	2290      	movs	r2, #144	; 0x90
   1bb6c:	2100      	movs	r1, #0
   1bb6e:	a802      	add	r0, sp, #8
   1bb70:	f006 f88c 	bl	21c8c <memset>
        cryptoInfo.algo_type = WC_ALGO_TYPE_RNG;
   1bb74:	2304      	movs	r3, #4
   1bb76:	9301      	str	r3, [sp, #4]
        cryptoInfo.rng.rng = rng;
   1bb78:	9520      	str	r5, [sp, #128]	; 0x80
        cryptoInfo.rng.out = out;
   1bb7a:	9721      	str	r7, [sp, #132]	; 0x84
        cryptoInfo.rng.sz = sz;
   1bb7c:	9622      	str	r6, [sp, #136]	; 0x88

        ret = dev->cb(dev->devId, &cryptoInfo, dev->ctx);
   1bb7e:	6863      	ldr	r3, [r4, #4]
   1bb80:	68a2      	ldr	r2, [r4, #8]
   1bb82:	a901      	add	r1, sp, #4
   1bb84:	6820      	ldr	r0, [r4, #0]
   1bb86:	4798      	blx	r3
        ret = CRYPTOCB_UNAVAILABLE;
   1bb88:	f110 0fae 	cmn.w	r0, #174	; 0xae
   1bb8c:	bf08      	it	eq
   1bb8e:	f46f 7087 	mvneq.w	r0, #270	; 0x10e
    }

    return wc_CryptoCb_TranslateErrorCode(ret);
}
   1bb92:	b027      	add	sp, #156	; 0x9c
   1bb94:	bdf0      	pop	{r4, r5, r6, r7, pc}
        dev = wc_CryptoCb_FindDeviceByIndex(0);
   1bb96:	2000      	movs	r0, #0
   1bb98:	f001 faa2 	bl	1d0e0 <wc_CryptoCb_FindDeviceByIndex>
   1bb9c:	4604      	mov	r4, r0
   1bb9e:	e7e1      	b.n	1bb64 <wc_CryptoCb_RandomBlock+0x14>
    int ret = CRYPTOCB_UNAVAILABLE;
   1bba0:	f46f 7087 	mvn.w	r0, #270	; 0x10e
   1bba4:	e7f5      	b.n	1bb92 <wc_CryptoCb_RandomBlock+0x42>
   1bba6:	f46f 7087 	mvn.w	r0, #270	; 0x10e
    return wc_CryptoCb_TranslateErrorCode(ret);
   1bbaa:	e7f2      	b.n	1bb92 <wc_CryptoCb_RandomBlock+0x42>

Disassembly of section .text._vsnprintf_r%500:

0001bbac <_vsniprintf_r>:
   1bbac:	b530      	push	{r4, r5, lr}
   1bbae:	1e14      	subs	r4, r2, #0
   1bbb0:	4605      	mov	r5, r0
   1bbb2:	b09b      	sub	sp, #108	; 0x6c
   1bbb4:	4618      	mov	r0, r3
   1bbb6:	da05      	bge.n	1bbc4 <_vsniprintf_r+0x18>
   1bbb8:	238b      	movs	r3, #139	; 0x8b
   1bbba:	602b      	str	r3, [r5, #0]
   1bbbc:	f04f 30ff 	mov.w	r0, #4294967295
   1bbc0:	b01b      	add	sp, #108	; 0x6c
   1bbc2:	bd30      	pop	{r4, r5, pc}
   1bbc4:	f44f 7302 	mov.w	r3, #520	; 0x208
   1bbc8:	f8ad 3010 	strh.w	r3, [sp, #16]
   1bbcc:	bf14      	ite	ne
   1bbce:	f104 33ff 	addne.w	r3, r4, #4294967295
   1bbd2:	4623      	moveq	r3, r4
   1bbd4:	9303      	str	r3, [sp, #12]
   1bbd6:	9306      	str	r3, [sp, #24]
   1bbd8:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1bbdc:	f8ad 3012 	strh.w	r3, [sp, #18]
   1bbe0:	2300      	movs	r3, #0
   1bbe2:	9101      	str	r1, [sp, #4]
   1bbe4:	9105      	str	r1, [sp, #20]
   1bbe6:	9319      	str	r3, [sp, #100]	; 0x64
   1bbe8:	4602      	mov	r2, r0
   1bbea:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   1bbec:	a901      	add	r1, sp, #4
   1bbee:	4628      	mov	r0, r5
   1bbf0:	f7f3 fe3a 	bl	f868 <_svfiprintf_r>
   1bbf4:	1c43      	adds	r3, r0, #1
   1bbf6:	bfbc      	itt	lt
   1bbf8:	238b      	movlt	r3, #139	; 0x8b
   1bbfa:	602b      	strlt	r3, [r5, #0]
   1bbfc:	2c00      	cmp	r4, #0
   1bbfe:	d0df      	beq.n	1bbc0 <_vsniprintf_r+0x14>
   1bc00:	9b01      	ldr	r3, [sp, #4]
   1bc02:	2200      	movs	r2, #0
   1bc04:	701a      	strb	r2, [r3, #0]
   1bc06:	e7db      	b.n	1bbc0 <_vsniprintf_r+0x14>

Disassembly of section .text.DRV_PIC32CGMAC_LibRxBuffersCountGet%501:

0001bc08 <DRV_PIC32CGMAC_LibRxBuffersCountGet>:
{
   1bc08:	b470      	push	{r4, r5, r6}
        if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].queueRxEnable == true)
   1bc0a:	f890 30cf 	ldrb.w	r3, [r0, #207]	; 0xcf
   1bc0e:	2b01      	cmp	r3, #1
   1bc10:	d008      	beq.n	1bc24 <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x1c>
   1bc12:	2000      	movs	r0, #0
   1bc14:	4605      	mov	r5, r0
    if(pendBuffs)
   1bc16:	b101      	cbz	r1, 1bc1a <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x12>
        *pendBuffs = pend_buffer_cnt;
   1bc18:	600d      	str	r5, [r1, #0]
    if(schedBuffs)
   1bc1a:	b102      	cbz	r2, 1bc1e <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x16>
        *schedBuffs = sched_buffer_cnt;
   1bc1c:	6010      	str	r0, [r2, #0]
}
   1bc1e:	2000      	movs	r0, #0
   1bc20:	bc70      	pop	{r4, r5, r6}
   1bc22:	4770      	bx	lr
            for(uint16_t desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt; desc_idx++)
   1bc24:	f8b0 60be 	ldrh.w	r6, [r0, #190]	; 0xbe
   1bc28:	b1c6      	cbz	r6, 1bc5c <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x54>
   1bc2a:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
   1bc2e:	3e01      	subs	r6, #1
   1bc30:	b2b0      	uxth	r0, r6
   1bc32:	f103 0608 	add.w	r6, r3, #8
   1bc36:	eb06 06c0 	add.w	r6, r6, r0, lsl #3
                if ((pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc[desc_idx].rx_desc_buffaddr.val) & GMAC_RX_ADDRESS_MASK)
   1bc3a:	2000      	movs	r0, #0
   1bc3c:	4605      	mov	r5, r0
   1bc3e:	e002      	b.n	1bc46 <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x3e>
   1bc40:	3308      	adds	r3, #8
            for(uint16_t desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt; desc_idx++)
   1bc42:	42b3      	cmp	r3, r6
   1bc44:	d0e7      	beq.n	1bc16 <DRV_PIC32CGMAC_LibRxBuffersCountGet+0xe>
                if ((pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc[desc_idx].rx_desc_buffaddr.val) & GMAC_RX_ADDRESS_MASK)
   1bc46:	681c      	ldr	r4, [r3, #0]
   1bc48:	f034 0403 	bics.w	r4, r4, #3
   1bc4c:	d0f8      	beq.n	1bc40 <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x38>
                    if ((pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc[desc_idx].rx_desc_buffaddr.val) & GMAC_RX_OWNERSHIP_BIT)
   1bc4e:	681c      	ldr	r4, [r3, #0]
   1bc50:	f014 0f01 	tst.w	r4, #1
                        pend_buffer_cnt++;
   1bc54:	bf14      	ite	ne
   1bc56:	3501      	addne	r5, #1
                        sched_buffer_cnt++;
   1bc58:	3001      	addeq	r0, #1
   1bc5a:	e7f1      	b.n	1bc40 <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x38>
            for(uint16_t desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt; desc_idx++)
   1bc5c:	2000      	movs	r0, #0
   1bc5e:	4605      	mov	r5, r0
   1bc60:	e7d9      	b.n	1bc16 <DRV_PIC32CGMAC_LibRxBuffersCountGet+0xe>

Disassembly of section .text.TCPIP_UDP_BcastIPV4AddressSet%502:

0001bc62 <TCPIP_UDP_BcastIPV4AddressSet>:
{
   1bc62:	b570      	push	{r4, r5, r6, lr}
   1bc64:	460d      	mov	r5, r1
   1bc66:	4616      	mov	r6, r2
    pSkt = _UDPSocketDcpt(s);
   1bc68:	f004 f9dc 	bl	20024 <_UDPSocketDcpt>
    if(pSkt == 0 || pSkt->addType != IP_ADDRESS_TYPE_IPV4)
   1bc6c:	b1f0      	cbz	r0, 1bcac <TCPIP_UDP_BcastIPV4AddressSet+0x4a>
   1bc6e:	4604      	mov	r4, r0
   1bc70:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
   1bc72:	2b01      	cmp	r3, #1
   1bc74:	d11c      	bne.n	1bcb0 <TCPIP_UDP_BcastIPV4AddressSet+0x4e>
    if(pSkt->flags.bcastForceType != UDP_BCAST_NONE)
   1bc76:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   1bc7a:	f013 0f03 	tst.w	r3, #3
   1bc7e:	d119      	bne.n	1bcb4 <TCPIP_UDP_BcastIPV4AddressSet+0x52>
    switch (bcastType)
   1bc80:	2d01      	cmp	r5, #1
   1bc82:	d008      	beq.n	1bc96 <TCPIP_UDP_BcastIPV4AddressSet+0x34>
   1bc84:	2d02      	cmp	r5, #2
   1bc86:	d117      	bne.n	1bcb8 <TCPIP_UDP_BcastIPV4AddressSet+0x56>
            if((bcastAddress.Val = TCPIP_STACK_NetAddressBcast(hNet)) == 0)
   1bc88:	4630      	mov	r0, r6
   1bc8a:	f005 f84f 	bl	20d2c <TCPIP_STACK_NetAddressBcast>
   1bc8e:	4603      	mov	r3, r0
   1bc90:	b918      	cbnz	r0, 1bc9a <TCPIP_UDP_BcastIPV4AddressSet+0x38>
                return false;
   1bc92:	2000      	movs	r0, #0
   1bc94:	e00d      	b.n	1bcb2 <TCPIP_UDP_BcastIPV4AddressSet+0x50>
            bcastAddress.Val = 0xffffffff;
   1bc96:	f04f 33ff 	mov.w	r3, #4294967295
    pSkt->destAddress.Val = bcastAddress.Val;
   1bc9a:	6163      	str	r3, [r4, #20]
    pSkt->flags.destSet = 1;
   1bc9c:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
   1bca0:	f043 0301 	orr.w	r3, r3, #1
   1bca4:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    return true;
   1bca8:	2001      	movs	r0, #1
   1bcaa:	e002      	b.n	1bcb2 <TCPIP_UDP_BcastIPV4AddressSet+0x50>
        return false;
   1bcac:	2000      	movs	r0, #0
   1bcae:	e000      	b.n	1bcb2 <TCPIP_UDP_BcastIPV4AddressSet+0x50>
   1bcb0:	2000      	movs	r0, #0
}
   1bcb2:	bd70      	pop	{r4, r5, r6, pc}
        return false;
   1bcb4:	2000      	movs	r0, #0
   1bcb6:	e7fc      	b.n	1bcb2 <TCPIP_UDP_BcastIPV4AddressSet+0x50>
            return false;
   1bcb8:	2000      	movs	r0, #0
   1bcba:	e7fa      	b.n	1bcb2 <TCPIP_UDP_BcastIPV4AddressSet+0x50>

Disassembly of section .text.DRV_ETHPHY_Initialize%503:

0001bcbc <DRV_ETHPHY_Initialize>:
    if ( iModule >= _DRV_ETHPHY_INSTANCES_NUMBER )
   1bcbc:	bb10      	cbnz	r0, 1bd04 <DRV_ETHPHY_Initialize+0x48>
    if( hSysObj->objInUse == true )
   1bcbe:	4b14      	ldr	r3, [pc, #80]	; (1bd10 <DRV_ETHPHY_Initialize+0x54>)
   1bcc0:	781b      	ldrb	r3, [r3, #0]
   1bcc2:	2b01      	cmp	r3, #1
   1bcc4:	d01c      	beq.n	1bd00 <DRV_ETHPHY_Initialize+0x44>
    if((hSysObj->pMiimBase = ethphyInit->pMiimObject) == 0)
   1bcc6:	694b      	ldr	r3, [r1, #20]
   1bcc8:	4a11      	ldr	r2, [pc, #68]	; (1bd10 <DRV_ETHPHY_Initialize+0x54>)
   1bcca:	6613      	str	r3, [r2, #96]	; 0x60
   1bccc:	b1eb      	cbz	r3, 1bd0a <DRV_ETHPHY_Initialize+0x4e>
{
   1bcce:	b510      	push	{r4, lr}
   1bcd0:	460b      	mov	r3, r1
    hSysObj->miimIndex = ethphyInit->miimIndex;
   1bcd2:	8b8a      	ldrh	r2, [r1, #28]
   1bcd4:	4c0e      	ldr	r4, [pc, #56]	; (1bd10 <DRV_ETHPHY_Initialize+0x54>)
   1bcd6:	f8a4 2064 	strh.w	r2, [r4, #100]	; 0x64
    hSysObj->objInUse = true;      // Set object to be in use
   1bcda:	2201      	movs	r2, #1
   1bcdc:	7022      	strb	r2, [r4, #0]
    hSysObj->busInUse = 0;
   1bcde:	2100      	movs	r1, #0
   1bce0:	7061      	strb	r1, [r4, #1]
    hSysObj->numClients = 0;
   1bce2:	8061      	strh	r1, [r4, #2]
    hSysObj->status = SYS_STATUS_READY; // Set module state
   1bce4:	2202      	movs	r2, #2
   1bce6:	7122      	strb	r2, [r4, #4]
    hSysObj->iModule  = iModule;  // Store driver instance
   1bce8:	80e1      	strh	r1, [r4, #6]
    hSysObj->ethphyId = ethphyInit->ethphyId; // Store PLIB ID
   1bcea:	685a      	ldr	r2, [r3, #4]
   1bcec:	60a2      	str	r2, [r4, #8]
    hSysObj->pPhyObj = ethphyInit->pPhyObject;
   1bcee:	68db      	ldr	r3, [r3, #12]
   1bcf0:	6163      	str	r3, [r4, #20]
    memset(hSysObj->objClients, 0, sizeof(hSysObj->objClients));
   1bcf2:	2248      	movs	r2, #72	; 0x48
   1bcf4:	f104 0018 	add.w	r0, r4, #24
   1bcf8:	f005 ffc8 	bl	21c8c <memset>
    return ( SYS_MODULE_OBJ )hSysObj ;
   1bcfc:	4620      	mov	r0, r4
}
   1bcfe:	bd10      	pop	{r4, pc}
        return ( SYS_MODULE_OBJ )hSysObj ;
   1bd00:	4803      	ldr	r0, [pc, #12]	; (1bd10 <DRV_ETHPHY_Initialize+0x54>)
   1bd02:	4770      	bx	lr
        return SYS_MODULE_OBJ_INVALID;
   1bd04:	f04f 30ff 	mov.w	r0, #4294967295
   1bd08:	4770      	bx	lr
        return SYS_MODULE_OBJ_INVALID;
   1bd0a:	f04f 30ff 	mov.w	r0, #4294967295
}
   1bd0e:	4770      	bx	lr
   1bd10:	2000de18 	.word	0x2000de18

Disassembly of section .text.DRV_GMAC_RxFilterHashTableEntrySet%504:

0001bd14 <DRV_GMAC_RxFilterHashTableEntrySet>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1bd14:	4b14      	ldr	r3, [pc, #80]	; (1bd68 <DRV_GMAC_RxFilterHashTableEntrySet+0x54>)
   1bd16:	4283      	cmp	r3, r0
   1bd18:	d120      	bne.n	1bd5c <DRV_GMAC_RxFilterHashTableEntrySet+0x48>
    if(pMACDrv == 0)
   1bd1a:	b310      	cbz	r0, 1bd62 <DRV_GMAC_RxFilterHashTableEntrySet+0x4e>
{ 
   1bd1c:	b510      	push	{r4, lr}
   1bd1e:	b086      	sub	sp, #24
   1bd20:	460c      	mov	r4, r1
    uint8_t nullMACAddr[6] =   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
   1bd22:	2300      	movs	r3, #0
   1bd24:	9300      	str	r3, [sp, #0]
   1bd26:	f8ad 3004 	strh.w	r3, [sp, #4]
    if( DestMACAddr == 0 || memcmp(DestMACAddr->v, nullMACAddr, sizeof(nullMACAddr))==0 )
   1bd2a:	b129      	cbz	r1, 1bd38 <DRV_GMAC_RxFilterHashTableEntrySet+0x24>
   1bd2c:	2206      	movs	r2, #6
   1bd2e:	4669      	mov	r1, sp
   1bd30:	4620      	mov	r0, r4
   1bd32:	f005 fa17 	bl	21164 <memcmp>
   1bd36:	b960      	cbnz	r0, 1bd52 <DRV_GMAC_RxFilterHashTableEntrySet+0x3e>
        hash.hash_value = 0x0; //Clear to all 0 for 64-bit Hash value to reject all hash match
   1bd38:	2200      	movs	r2, #0
   1bd3a:	2300      	movs	r3, #0
   1bd3c:	e9cd 2302 	strd	r2, r3, [sp, #8]
        hash.calculate_hash = false; // No hash calculation; directly set hash register
   1bd40:	f88d 3014 	strb.w	r3, [sp, #20]
    DRV_PIC32CGMAC_LibRxFilterHash_Calculate(pMACDrv, &hash);
   1bd44:	a902      	add	r1, sp, #8
   1bd46:	4808      	ldr	r0, [pc, #32]	; (1bd68 <DRV_GMAC_RxFilterHashTableEntrySet+0x54>)
   1bd48:	f7f4 f90c 	bl	ff64 <DRV_PIC32CGMAC_LibRxFilterHash_Calculate>
    return TCPIP_MAC_RES_OK;
   1bd4c:	2000      	movs	r0, #0
}
   1bd4e:	b006      	add	sp, #24
   1bd50:	bd10      	pop	{r4, pc}
        hash.DestMACAddr = DestMACAddr;    
   1bd52:	9404      	str	r4, [sp, #16]
        hash.calculate_hash = true; // calculate hash and set hash register
   1bd54:	2301      	movs	r3, #1
   1bd56:	f88d 3014 	strb.w	r3, [sp, #20]
   1bd5a:	e7f3      	b.n	1bd44 <DRV_GMAC_RxFilterHashTableEntrySet+0x30>
        return TCPIP_MAC_RES_OP_ERR;
   1bd5c:	f06f 0005 	mvn.w	r0, #5
   1bd60:	4770      	bx	lr
   1bd62:	f06f 0005 	mvn.w	r0, #5
}
   1bd66:	4770      	bx	lr
   1bd68:	2000d8b8 	.word	0x2000d8b8

Disassembly of section .rodata.DRV_GMAC_Object%505:

0001bd6c <DRV_GMAC_Object>:
   1bd6c:	00011050 000203ec 0000bad1 00020a11     P...............
   1bd7c:	00010f3f 0001f059 00013041 0001e6a5     ?...Y...A0......
   1bd8c:	000209f1 0001cdc9 0001bd15 000201dd     ................
   1bd9c:	0001588d 0000fdb5 00019f35 00018181     .X......5.......
   1bdac:	0001c55d 0001b125 0001d479 000135e1     ]...%...y....5..
   1bdbc:	0001a49d 00020e39                       ....9...

Disassembly of section .text._DNS_Enable%506:

0001bdc4 <_DNS_Enable>:
{
   1bdc4:	b570      	push	{r4, r5, r6, lr}
    pDnsDcpt = pgDnsDcpt;
   1bdc6:	4b14      	ldr	r3, [pc, #80]	; (1be18 <_DNS_Enable+0x54>)
   1bdc8:	681d      	ldr	r5, [r3, #0]
    if(pDnsDcpt == 0)
   1bdca:	b30d      	cbz	r5, 1be10 <_DNS_Enable+0x4c>
    if(checkIfUp)
   1bdcc:	b141      	cbz	r1, 1bde0 <_DNS_Enable+0x1c>
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   1bdce:	b308      	cbz	r0, 1be14 <_DNS_Enable+0x50>
   1bdd0:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   1bdd4:	f013 0f40 	tst.w	r3, #64	; 0x40
   1bdd8:	d104      	bne.n	1bde4 <_DNS_Enable+0x20>
        return false;
   1bdda:	2100      	movs	r1, #0
}
   1bddc:	4608      	mov	r0, r1
   1bdde:	bd70      	pop	{r4, r5, r6, pc}
    if(pNetIf == 0 || TCPIP_STACK_DNSServiceCanStart(pNetIf, TCPIP_STACK_DNS_SERVICE_CLIENT) == false)
   1bde0:	2800      	cmp	r0, #0
   1bde2:	d0fb      	beq.n	1bddc <_DNS_Enable+0x18>
   1bde4:	4616      	mov	r6, r2
   1bde6:	4604      	mov	r4, r0
   1bde8:	2101      	movs	r1, #1
   1bdea:	f003 fca2 	bl	1f732 <TCPIP_STACK_DNSServiceCanStart>
   1bdee:	4601      	mov	r1, r0
   1bdf0:	2800      	cmp	r0, #0
   1bdf2:	d0f3      	beq.n	1bddc <_DNS_Enable+0x18>
    pNetIf->Flags.bIsDnsClientEnabled = true;      
   1bdf4:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   1bdf8:	f043 0308 	orr.w	r3, r3, #8
   1bdfc:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    if(flags == TCPIP_DNS_ENABLE_STRICT)
   1be00:	2e01      	cmp	r6, #1
   1be02:	d003      	beq.n	1be0c <_DNS_Enable+0x48>
    else if(flags == TCPIP_DNS_ENABLE_PREFERRED)
   1be04:	2e02      	cmp	r6, #2
   1be06:	d1e9      	bne.n	1bddc <_DNS_Enable+0x18>
        pDnsDcpt->prefNet =  pNetIf;
   1be08:	60ac      	str	r4, [r5, #8]
   1be0a:	e7e7      	b.n	1bddc <_DNS_Enable+0x18>
        pDnsDcpt->strictNet =  pNetIf;
   1be0c:	606c      	str	r4, [r5, #4]
   1be0e:	e7e5      	b.n	1bddc <_DNS_Enable+0x18>
        return false;
   1be10:	2100      	movs	r1, #0
   1be12:	e7e3      	b.n	1bddc <_DNS_Enable+0x18>
        return false;
   1be14:	2100      	movs	r1, #0
   1be16:	e7e1      	b.n	1bddc <_DNS_Enable+0x18>
   1be18:	2000e424 	.word	0x2000e424

Disassembly of section .text._TCPIPStackModuleSignalRequest%507:

0001be1c <_TCPIPStackModuleSignalRequest>:
    if(modId <= TCPIP_MODULE_MANAGER)
   1be1c:	2801      	cmp	r0, #1
   1be1e:	d921      	bls.n	1be64 <_TCPIPStackModuleSignalRequest+0x48>
{
   1be20:	b538      	push	{r3, r4, r5, lr}
   1be22:	4615      	mov	r5, r2
   1be24:	460c      	mov	r4, r1
    _TCPIPSignalEntrySetNotify(_TCPIPModuleToSignalEntry(modId), signals, 0);
   1be26:	2200      	movs	r2, #0
   1be28:	4b0f      	ldr	r3, [pc, #60]	; (1be68 <_TCPIPStackModuleSignalRequest+0x4c>)
   1be2a:	eb03 1000 	add.w	r0, r3, r0, lsl #4
   1be2e:	f004 f881 	bl	1ff34 <_TCPIPSignalEntrySetNotify>
    if((signal & TCPIP_MODULE_SIGNAL_ASYNC) != 0)
   1be32:	f414 7f80 	tst.w	r4, #256	; 0x100
   1be36:	d102      	bne.n	1be3e <_TCPIPStackModuleSignalRequest+0x22>
    if(noMgrAlert == 0)
   1be38:	b16d      	cbz	r5, 1be56 <_TCPIPStackModuleSignalRequest+0x3a>
    return true;
   1be3a:	4628      	mov	r0, r5
}
   1be3c:	bd38      	pop	{r3, r4, r5, pc}
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1be3e:	2000      	movs	r0, #0
   1be40:	f005 fbbc 	bl	215bc <OSAL_CRIT_Enter>
    stackAsyncSignalCount += 1; 
   1be44:	4a09      	ldr	r2, [pc, #36]	; (1be6c <_TCPIPStackModuleSignalRequest+0x50>)
   1be46:	6813      	ldr	r3, [r2, #0]
   1be48:	3301      	adds	r3, #1
   1be4a:	6013      	str	r3, [r2, #0]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1be4c:	4601      	mov	r1, r0
   1be4e:	2000      	movs	r0, #0
   1be50:	f005 fce3 	bl	2181a <OSAL_CRIT_Leave>
   1be54:	e7f0      	b.n	1be38 <_TCPIPStackModuleSignalRequest+0x1c>
        _TCPIPSignalEntryNotify(_TCPIPModuleToSignalEntry(TCPIP_MODULE_MANAGER), signal, 0);
   1be56:	2200      	movs	r2, #0
   1be58:	4621      	mov	r1, r4
   1be5a:	4805      	ldr	r0, [pc, #20]	; (1be70 <_TCPIPStackModuleSignalRequest+0x54>)
   1be5c:	f005 f878 	bl	20f50 <_TCPIPSignalEntryNotify>
    return true;
   1be60:	2001      	movs	r0, #1
   1be62:	e7eb      	b.n	1be3c <_TCPIPStackModuleSignalRequest+0x20>
        return false;
   1be64:	2000      	movs	r0, #0
}
   1be66:	4770      	bx	lr
   1be68:	2000d1d4 	.word	0x2000d1d4
   1be6c:	2000e434 	.word	0x2000e434
   1be70:	2000d1e4 	.word	0x2000d1e4

Disassembly of section .text.OSAL_SEM_Create%508:

0001be74 <OSAL_SEM_Create>:
    </code>

  Remarks:
 */
OSAL_RESULT OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE* semID, OSAL_SEM_TYPE type, uint8_t maxCount, uint8_t initialCount)
{
   1be74:	b538      	push	{r3, r4, r5, lr}
   1be76:	4604      	mov	r4, r0
   1be78:	461d      	mov	r5, r3
  switch (type)
   1be7a:	b131      	cbz	r1, 1be8a <OSAL_SEM_Create+0x16>
   1be7c:	2901      	cmp	r1, #1
   1be7e:	d01b      	beq.n	1beb8 <OSAL_SEM_Create+0x44>
    case OSAL_SEM_TYPE_COUNTING:
      *(SemaphoreHandle_t*)semID = xSemaphoreCreateCounting((UBaseType_t)maxCount, (UBaseType_t)initialCount);
    break;

    default:
      *(SemaphoreHandle_t*)semID = NULL;
   1be80:	2300      	movs	r3, #0
   1be82:	6003      	str	r3, [r0, #0]

    return OSAL_RESULT_NOT_IMPLEMENTED;
   1be84:	f04f 30ff 	mov.w	r0, #4294967295
   1be88:	e01f      	b.n	1beca <OSAL_SEM_Create+0x56>
      if ( initialCount <= 1)
   1be8a:	2d01      	cmp	r5, #1
   1be8c:	d901      	bls.n	1be92 <OSAL_SEM_Create+0x1e>
        return OSAL_RESULT_FALSE;
   1be8e:	2000      	movs	r0, #0
   1be90:	e01b      	b.n	1beca <OSAL_SEM_Create+0x56>
        *(SemaphoreHandle_t*)semID = xSemaphoreCreateBinary();
   1be92:	2203      	movs	r2, #3
   1be94:	2100      	movs	r1, #0
   1be96:	2001      	movs	r0, #1
   1be98:	f003 fad6 	bl	1f448 <xQueueGenericCreate>
   1be9c:	6020      	str	r0, [r4, #0]
        if (*(SemaphoreHandle_t*)semID != NULL && initialCount == 1)
   1be9e:	b180      	cbz	r0, 1bec2 <OSAL_SEM_Create+0x4e>
   1bea0:	2d01      	cmp	r5, #1
   1bea2:	d10e      	bne.n	1bec2 <OSAL_SEM_Create+0x4e>
          if (xSemaphoreGive(*(SemaphoreHandle_t*)semID) == pdTRUE)
   1bea4:	2300      	movs	r3, #0
   1bea6:	461a      	mov	r2, r3
   1bea8:	4619      	mov	r1, r3
   1beaa:	f7f7 f837 	bl	12f1c <xQueueGenericSend>
            return OSAL_RESULT_TRUE;
   1beae:	2801      	cmp	r0, #1
   1beb0:	bf14      	ite	ne
   1beb2:	2000      	movne	r0, #0
   1beb4:	2001      	moveq	r0, #1
   1beb6:	e008      	b.n	1beca <OSAL_SEM_Create+0x56>
      *(SemaphoreHandle_t*)semID = xSemaphoreCreateCounting((UBaseType_t)maxCount, (UBaseType_t)initialCount);
   1beb8:	4629      	mov	r1, r5
   1beba:	4610      	mov	r0, r2
   1bebc:	f005 fcd9 	bl	21872 <xQueueCreateCountingSemaphore>
   1bec0:	6020      	str	r0, [r4, #0]
  }

  if (*(SemaphoreHandle_t*)semID == NULL)
   1bec2:	6820      	ldr	r0, [r4, #0]
            return OSAL_RESULT_TRUE;
   1bec4:	3000      	adds	r0, #0
   1bec6:	bf18      	it	ne
   1bec8:	2001      	movne	r0, #1
  {
    return OSAL_RESULT_FALSE;
  }

  return OSAL_RESULT_TRUE;
}
   1beca:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.SYS_TIME_TimerStart%509:

0001becc <SYS_TIME_TimerStart>:
    SYS_TIME_ResourceUnlock();
    return result;
}

SYS_TIME_RESULT SYS_TIME_TimerStart(SYS_TIME_HANDLE handle)
{
   1becc:	b538      	push	{r3, r4, r5, lr}
   1bece:	4604      	mov	r4, r0
    SYS_TIME_TIMER_OBJ *tmr = NULL;
    SYS_TIME_RESULT result = SYS_TIME_ERROR;

    if (SYS_TIME_ResourceLock() == false)
   1bed0:	f002 fcc8 	bl	1e864 <SYS_TIME_ResourceLock>
   1bed4:	b310      	cbz	r0, 1bf1c <SYS_TIME_TimerStart+0x50>
    {
        return result;
    }

    tmr = SYS_TIME_GetTimerObject(handle);
   1bed6:	4620      	mov	r0, r4
   1bed8:	f002 fa0e 	bl	1e2f8 <SYS_TIME_GetTimerObject>

    if(tmr != NULL)
   1bedc:	4605      	mov	r5, r0
   1bede:	b1b0      	cbz	r0, 1bf0e <SYS_TIME_TimerStart+0x42>
    {
        if (tmr->active == false)
   1bee0:	7843      	ldrb	r3, [r0, #1]
   1bee2:	b9b3      	cbnz	r3, 1bf12 <SYS_TIME_TimerStart+0x46>
        {
            /* Single shot timers can be started back from the single shot timer's
             * callback where relativeTimePending is 0. For this reason, if the
             * relativeTimePending is 0, it is reloaded with the requested time.
             */
            if (tmr->relativeTimePending == 0)
   1bee4:	6883      	ldr	r3, [r0, #8]
   1bee6:	b90b      	cbnz	r3, 1beec <SYS_TIME_TimerStart+0x20>
            {
                tmr->relativeTimePending = tmr->requestedTime;
   1bee8:	6843      	ldr	r3, [r0, #4]
   1beea:	6083      	str	r3, [r0, #8]
            }
            if (gSystemCounterObj.interruptNestingCount == 0)
   1beec:	4b0c      	ldr	r3, [pc, #48]	; (1bf20 <SYS_TIME_TimerStart+0x54>)
   1beee:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   1bef2:	b943      	cbnz	r3, 1bf06 <SYS_TIME_TimerStart+0x3a>
            {
                SYS_TIME_TimerAdd(tmr);
   1bef4:	4628      	mov	r0, r5
   1bef6:	f001 fefd 	bl	1dcf4 <SYS_TIME_TimerAdd>
            }
            else
            {
                SYS_TIME_AddToList(tmr);
            }
            tmr->tmrElapsedFlag = false;
   1befa:	2400      	movs	r4, #0
   1befc:	752c      	strb	r4, [r5, #20]
            tmr->tmrElapsed = false;
   1befe:	756c      	strb	r4, [r5, #21]
            tmr->active = true;
   1bf00:	2301      	movs	r3, #1
   1bf02:	706b      	strb	r3, [r5, #1]
   1bf04:	e006      	b.n	1bf14 <SYS_TIME_TimerStart+0x48>
                SYS_TIME_AddToList(tmr);
   1bf06:	4628      	mov	r0, r5
   1bf08:	f7fc fd00 	bl	1890c <SYS_TIME_AddToList>
   1bf0c:	e7f5      	b.n	1befa <SYS_TIME_TimerStart+0x2e>
    SYS_TIME_RESULT result = SYS_TIME_ERROR;
   1bf0e:	2401      	movs	r4, #1
   1bf10:	e000      	b.n	1bf14 <SYS_TIME_TimerStart+0x48>
        }
        result = SYS_TIME_SUCCESS;
   1bf12:	2400      	movs	r4, #0
    }

    SYS_TIME_ResourceUnlock();
   1bf14:	f002 fa0e 	bl	1e334 <SYS_TIME_ResourceUnlock>
    return result;
}
   1bf18:	4620      	mov	r0, r4
   1bf1a:	bd38      	pop	{r3, r4, r5, pc}
        return result;
   1bf1c:	2401      	movs	r4, #1
   1bf1e:	e7fb      	b.n	1bf18 <SYS_TIME_TimerStart+0x4c>
   1bf20:	2000e030 	.word	0x2000e030

Disassembly of section .text.DRV_MIIM_OperationAbort%510:

0001bf24 <DRV_MIIM_OperationAbort>:
{
   1bf24:	b538      	push	{r3, r4, r5, lr}
   1bf26:	460c      	mov	r4, r1
        if((pClient = _DRV_MIIM_GetClientAndLock(handle, true)) == 0)
   1bf28:	2101      	movs	r1, #1
   1bf2a:	f000 fca6 	bl	1c87a <_DRV_MIIM_GetClientAndLock>
   1bf2e:	b1d0      	cbz	r0, 1bf66 <DRV_MIIM_OperationAbort+0x42>
        pMiimObj = pClient->parentObj;
   1bf30:	6845      	ldr	r5, [r0, #4]
    if(pOpDcpt != 0 && (pOpDcpt->qType == DRV_MIIM_QTYPE_BUSY || pOpDcpt->qType == DRV_MIIM_QTYPE_COMPLETE))
   1bf32:	b1ac      	cbz	r4, 1bf60 <DRV_MIIM_OperationAbort+0x3c>
   1bf34:	7ae3      	ldrb	r3, [r4, #11]
   1bf36:	3b02      	subs	r3, #2
   1bf38:	b2db      	uxtb	r3, r3
   1bf3a:	2b01      	cmp	r3, #1
   1bf3c:	d916      	bls.n	1bf6c <DRV_MIIM_OperationAbort+0x48>
            miimRes = DRV_MIIM_RES_OP_HANDLE_ERR;
   1bf3e:	f06f 0401 	mvn.w	r4, #1
   1bf42:	e007      	b.n	1bf54 <DRV_MIIM_OperationAbort+0x30>
            pList = &pMiimObj->completeOpList;
   1bf44:	f105 0288 	add.w	r2, r5, #136	; 0x88
            qType = DRV_MIIM_QTYPE_COMPLETE;
   1bf48:	2303      	movs	r3, #3
        _DRV_MIIM_ReleaseOpDcpt(pMiimObj, pOpDcpt, pList, qType);
   1bf4a:	4621      	mov	r1, r4
   1bf4c:	4628      	mov	r0, r5
   1bf4e:	f002 fadf 	bl	1e510 <_DRV_MIIM_ReleaseOpDcpt>
        miimRes = DRV_MIIM_RES_OK;
   1bf52:	2400      	movs	r4, #0
    if(pMiimObj != 0)
   1bf54:	b115      	cbz	r5, 1bf5c <DRV_MIIM_OperationAbort+0x38>
    OSAL_SEM_Post(&pMiimObj->objSem);
   1bf56:	4628      	mov	r0, r5
   1bf58:	f005 fb3c 	bl	215d4 <OSAL_SEM_Post>
}
   1bf5c:	4620      	mov	r0, r4
   1bf5e:	bd38      	pop	{r3, r4, r5, pc}
            miimRes = DRV_MIIM_RES_OP_HANDLE_ERR;
   1bf60:	f06f 0401 	mvn.w	r4, #1
   1bf64:	e7f6      	b.n	1bf54 <DRV_MIIM_OperationAbort+0x30>
            miimRes = DRV_MIIM_RES_HANDLE_ERR;
   1bf66:	f04f 34ff 	mov.w	r4, #4294967295
    return miimRes;
   1bf6a:	e7f7      	b.n	1bf5c <DRV_MIIM_OperationAbort+0x38>
        if(pOpDcpt->opStat >= DRV_MIIM_TXFER_DONE)
   1bf6c:	7aa3      	ldrb	r3, [r4, #10]
   1bf6e:	2b04      	cmp	r3, #4
   1bf70:	d8e8      	bhi.n	1bf44 <DRV_MIIM_OperationAbort+0x20>
            pList = &pMiimObj->busyOpList;
   1bf72:	f105 027c 	add.w	r2, r5, #124	; 0x7c
            qType = DRV_MIIM_QTYPE_BUSY;
   1bf76:	2302      	movs	r3, #2
   1bf78:	e7e7      	b.n	1bf4a <DRV_MIIM_OperationAbort+0x26>

Disassembly of section .text._DRV_PHY_SMITransferWaitComplete%511:

0001bf7a <_DRV_PHY_SMITransferWaitComplete>:
    if(hClientObj->smiTxferStatus != DRV_ETHPHY_SMI_TXFER_OP_WAIT_COMPLETE)
   1bf7a:	8e83      	ldrh	r3, [r0, #52]	; 0x34
   1bf7c:	2b02      	cmp	r3, #2
   1bf7e:	d11f      	bne.n	1bfc0 <_DRV_PHY_SMITransferWaitComplete+0x46>
    if(hClientObj->miimHandle == 0)
   1bf80:	6943      	ldr	r3, [r0, #20]
   1bf82:	b1fb      	cbz	r3, 1bfc4 <_DRV_PHY_SMITransferWaitComplete+0x4a>
{
   1bf84:	b510      	push	{r4, lr}
   1bf86:	b082      	sub	sp, #8
   1bf88:	4604      	mov	r4, r0
    miimRes = DRV_MIIM_OperationResult(hClientObj->miimHandle, hClientObj->miimOpHandle, &opData);
   1bf8a:	f10d 0206 	add.w	r2, sp, #6
   1bf8e:	6981      	ldr	r1, [r0, #24]
   1bf90:	4618      	mov	r0, r3
   1bf92:	f7fc fb9b 	bl	186cc <DRV_MIIM_OperationResult>
    if(miimRes == DRV_MIIM_RES_PENDING)
   1bf96:	2801      	cmp	r0, #1
   1bf98:	d017      	beq.n	1bfca <_DRV_PHY_SMITransferWaitComplete+0x50>
    if(miimRes < 0)
   1bf9a:	2800      	cmp	r0, #0
   1bf9c:	db09      	blt.n	1bfb2 <_DRV_PHY_SMITransferWaitComplete+0x38>
        if(hClientObj->smiTxferType == DRV_ETHPHY_SMI_XFER_TYPE_READ)
   1bf9e:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   1bfa0:	2b03      	cmp	r3, #3
   1bfa2:	d001      	beq.n	1bfa8 <_DRV_PHY_SMITransferWaitComplete+0x2e>
        txferRes = DRV_ETHPHY_SMI_TXFER_RES_DONE; 
   1bfa4:	2000      	movs	r0, #0
   1bfa6:	e006      	b.n	1bfb6 <_DRV_PHY_SMITransferWaitComplete+0x3c>
            hClientObj->smiData = opData; // set the read result
   1bfa8:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   1bfac:	8763      	strh	r3, [r4, #58]	; 0x3a
        txferRes = DRV_ETHPHY_SMI_TXFER_RES_DONE; 
   1bfae:	2000      	movs	r0, #0
   1bfb0:	e001      	b.n	1bfb6 <_DRV_PHY_SMITransferWaitComplete+0x3c>
        txferRes = DRV_ETHPHY_SMI_TXFER_RES_MIIM_ERROR; 
   1bfb2:	f06f 0001 	mvn.w	r0, #1
    hClientObj->miimOpHandle = 0;  // operation done
   1bfb6:	2300      	movs	r3, #0
   1bfb8:	61a3      	str	r3, [r4, #24]
    hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
   1bfba:	86a3      	strh	r3, [r4, #52]	; 0x34
}
   1bfbc:	b002      	add	sp, #8
   1bfbe:	bd10      	pop	{r4, pc}
        return DRV_ETHPHY_SMI_TXFER_RES_DONE;
   1bfc0:	2000      	movs	r0, #0
   1bfc2:	4770      	bx	lr
        return DRV_ETHPHY_SMI_TXFER_RES_ILLEGAL;
   1bfc4:	f04f 30ff 	mov.w	r0, #4294967295
}
   1bfc8:	4770      	bx	lr
        return DRV_ETHPHY_SMI_TXFER_RES_WAIT;
   1bfca:	2002      	movs	r0, #2
   1bfcc:	e7f6      	b.n	1bfbc <_DRV_PHY_SMITransferWaitComplete+0x42>

Disassembly of section .text._DRV_ETHPHY_NegCompletePhaseAN_Restart%512:

0001bfce <_DRV_ETHPHY_NegCompletePhaseAN_Restart>:
{
   1bfce:	b510      	push	{r4, lr}
   1bfd0:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1bfd2:	f004 fbe7 	bl	207a4 <_DRV_PHY_SMITransfer_Wait>
   1bfd6:	b168      	cbz	r0, 1bff4 <_DRV_ETHPHY_NegCompletePhaseAN_Restart+0x26>
    hClientObj->operReg[1] = phyBMCon.w = hClientObj->smiData;
   1bfd8:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   1bfda:	84a3      	strh	r3, [r4, #36]	; 0x24
    if(phyBMCon.AN_RESTART == 0)
   1bfdc:	f413 7f00 	tst.w	r3, #512	; 0x200
   1bfe0:	d009      	beq.n	1bff6 <_DRV_ETHPHY_NegCompletePhaseAN_Restart+0x28>
    if(SYS_TMR_TickCountGet() < hClientObj->operTStamp)
   1bfe2:	f004 f883 	bl	200ec <SYS_TMR_TickCountGet>
   1bfe6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1bfe8:	4298      	cmp	r0, r3
   1bfea:	d214      	bcs.n	1c016 <_DRV_ETHPHY_NegCompletePhaseAN_Restart+0x48>
        _DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMCON);
   1bfec:	2100      	movs	r1, #0
   1bfee:	4620      	mov	r0, r4
   1bff0:	f002 ff84 	bl	1eefc <_DRV_PHY_SMIReadStart>
}
   1bff4:	bd10      	pop	{r4, pc}
        hClientObj->operTStamp = SYS_TMR_TickCountGet() + ((DRV_ETHPHY_NEG_DONE_TMO * SYS_TMR_TickCounterFrequencyGet()) + 999) / 1000;
   1bff6:	f004 f8a1 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
   1bffa:	f004 f877 	bl	200ec <SYS_TMR_TickCountGet>
   1bffe:	62a0      	str	r0, [r4, #40]	; 0x28
        if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   1c000:	2101      	movs	r1, #1
   1c002:	4620      	mov	r0, r4
   1c004:	f002 ff7a 	bl	1eefc <_DRV_PHY_SMIReadStart>
   1c008:	2800      	cmp	r0, #0
   1c00a:	d0f3      	beq.n	1bff4 <_DRV_ETHPHY_NegCompletePhaseAN_Restart+0x26>
    hClientObj->operPhase = operPhase;
   1c00c:	2305      	movs	r3, #5
   1c00e:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1c010:	2300      	movs	r3, #0
   1c012:	8423      	strh	r3, [r4, #32]
   1c014:	e7ee      	b.n	1bff4 <_DRV_ETHPHY_NegCompletePhaseAN_Restart+0x26>
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_NEGOTIATION_NOT_STARTED);
   1c016:	f06f 0106 	mvn.w	r1, #6
   1c01a:	4620      	mov	r0, r4
   1c01c:	f003 fe86 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
   1c020:	e7e8      	b.n	1bff4 <_DRV_ETHPHY_NegCompletePhaseAN_Restart+0x26>

Disassembly of section .text._ARPNotifyClients%513:

0001c024 <_ARPNotifyClients>:
{
   1c024:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1c028:	b083      	sub	sp, #12
   1c02a:	4605      	mov	r5, r0
   1c02c:	4689      	mov	r9, r1
   1c02e:	4690      	mov	r8, r2
   1c030:	461f      	mov	r7, r3
    TCPIP_Helper_ProtectedSingleListLock(notifyList);
   1c032:	4c0f      	ldr	r4, [pc, #60]	; (1c070 <_ARPNotifyClients+0x4c>)
   1c034:	f104 0020 	add.w	r0, r4, #32
   1c038:	f004 fd3a 	bl	20ab0 <TCPIP_Helper_ProtectedSingleListLock>
    for(aNode = (ARP_LIST_NODE*)arpMod.registeredUsers.list.head; aNode != 0; aNode = aNode->next)
   1c03c:	6a24      	ldr	r4, [r4, #32]
   1c03e:	b984      	cbnz	r4, 1c062 <_ARPNotifyClients+0x3e>
    TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
   1c040:	480c      	ldr	r0, [pc, #48]	; (1c074 <_ARPNotifyClients+0x50>)
   1c042:	f004 ff77 	bl	20f34 <TCPIP_Helper_ProtectedSingleListUnlock>
}
   1c046:	b003      	add	sp, #12
   1c048:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            (*aNode->handler)(pNetIf, ipAdd, MACAddr, evType, aNode->hParam);
   1c04c:	68a3      	ldr	r3, [r4, #8]
   1c04e:	9300      	str	r3, [sp, #0]
   1c050:	6866      	ldr	r6, [r4, #4]
   1c052:	463b      	mov	r3, r7
   1c054:	4642      	mov	r2, r8
   1c056:	4649      	mov	r1, r9
   1c058:	4628      	mov	r0, r5
   1c05a:	47b0      	blx	r6
    for(aNode = (ARP_LIST_NODE*)arpMod.registeredUsers.list.head; aNode != 0; aNode = aNode->next)
   1c05c:	6824      	ldr	r4, [r4, #0]
   1c05e:	2c00      	cmp	r4, #0
   1c060:	d0ee      	beq.n	1c040 <_ARPNotifyClients+0x1c>
        if(aNode->hNet == 0 || aNode->hNet == pNetIf)
   1c062:	68e3      	ldr	r3, [r4, #12]
   1c064:	2b00      	cmp	r3, #0
   1c066:	d0f1      	beq.n	1c04c <_ARPNotifyClients+0x28>
   1c068:	42ab      	cmp	r3, r5
   1c06a:	d1f7      	bne.n	1c05c <_ARPNotifyClients+0x38>
   1c06c:	e7ee      	b.n	1c04c <_ARPNotifyClients+0x28>
   1c06e:	bf00      	nop
   1c070:	2000dfa4 	.word	0x2000dfa4
   1c074:	2000dfc4 	.word	0x2000dfc4

Disassembly of section .text.IperfSetState%514:

0001c078 <IperfSetState>:

static void IperfSetState(tIperfState* pIState, int newState)
{
   1c078:	b538      	push	{r3, r4, r5, lr}
   1c07a:	4604      	mov	r4, r0
   1c07c:	460d      	mov	r5, r1
    uint8_t oldState = pIState->state;
   1c07e:	f890 30ce 	ldrb.w	r3, [r0, #206]	; 0xce
	static uint8_t	iperf_async_request = 0;
	
    if(newState == IPERF_STANDBY_STATE)
   1c082:	2901      	cmp	r1, #1
   1c084:	d007      	beq.n	1c096 <IperfSetState+0x1e>
        if(oldState != IPERF_STANDBY_STATE)
        {   // clear the async request
        	iperf_async_request--;
        }
    }
    else if (oldState == IPERF_STANDBY_STATE)
   1c086:	2b01      	cmp	r3, #1
   1c088:	d00c      	beq.n	1c0a4 <IperfSetState+0x2c>
    {   // going busy; set the async request
    	iperf_async_request++;
		_TCPIPStackModuleSignalRequest(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_ASYNC, 0); 
    }

	if(iperf_async_request == 0)
   1c08a:	4b0f      	ldr	r3, [pc, #60]	; (1c0c8 <IperfSetState+0x50>)
   1c08c:	781b      	ldrb	r3, [r3, #0]
   1c08e:	b1a3      	cbz	r3, 1c0ba <IperfSetState+0x42>
		_TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_ASYNC); 
	
    pIState->state = (uint8_t)newState;
   1c090:	f884 50ce 	strb.w	r5, [r4, #206]	; 0xce

}
   1c094:	bd38      	pop	{r3, r4, r5, pc}
        if(oldState != IPERF_STANDBY_STATE)
   1c096:	2b01      	cmp	r3, #1
   1c098:	d0f7      	beq.n	1c08a <IperfSetState+0x12>
        	iperf_async_request--;
   1c09a:	4a0b      	ldr	r2, [pc, #44]	; (1c0c8 <IperfSetState+0x50>)
   1c09c:	7813      	ldrb	r3, [r2, #0]
   1c09e:	3b01      	subs	r3, #1
   1c0a0:	7013      	strb	r3, [r2, #0]
   1c0a2:	e7f2      	b.n	1c08a <IperfSetState+0x12>
    	iperf_async_request++;
   1c0a4:	4a08      	ldr	r2, [pc, #32]	; (1c0c8 <IperfSetState+0x50>)
   1c0a6:	7813      	ldrb	r3, [r2, #0]
   1c0a8:	3301      	adds	r3, #1
   1c0aa:	7013      	strb	r3, [r2, #0]
		_TCPIPStackModuleSignalRequest(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_ASYNC, 0); 
   1c0ac:	2200      	movs	r2, #0
   1c0ae:	f44f 7180 	mov.w	r1, #256	; 0x100
   1c0b2:	2020      	movs	r0, #32
   1c0b4:	f7ff feb2 	bl	1be1c <_TCPIPStackModuleSignalRequest>
   1c0b8:	e7e7      	b.n	1c08a <IperfSetState+0x12>
		_TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_ASYNC); 
   1c0ba:	f44f 7180 	mov.w	r1, #256	; 0x100
   1c0be:	2020      	movs	r0, #32
   1c0c0:	f002 f884 	bl	1e1cc <_TCPIPStackModuleSignalGet>
   1c0c4:	e7e4      	b.n	1c090 <IperfSetState+0x18>
   1c0c6:	bf00      	nop
   1c0c8:	2000e4f5 	.word	0x2000e4f5

Disassembly of section .text.TCPIP_IPERF_Deinitialize%515:

0001c0cc <TCPIP_IPERF_Deinitialize>:
{
   1c0cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(iperfInitCount > 0)
   1c0ce:	4b11      	ldr	r3, [pc, #68]	; (1c114 <TCPIP_IPERF_Deinitialize+0x48>)
   1c0d0:	681c      	ldr	r4, [r3, #0]
   1c0d2:	2c00      	cmp	r4, #0
   1c0d4:	dd02      	ble.n	1c0dc <TCPIP_IPERF_Deinitialize+0x10>
        if(stackCtrl->stackAction == TCPIP_STACK_ACTION_DEINIT)
   1c0d6:	7f03      	ldrb	r3, [r0, #28]
   1c0d8:	2b02      	cmp	r3, #2
   1c0da:	d000      	beq.n	1c0de <TCPIP_IPERF_Deinitialize+0x12>
}
   1c0dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            if(--iperfInitCount == 0)
   1c0de:	3c01      	subs	r4, #1
   1c0e0:	4b0c      	ldr	r3, [pc, #48]	; (1c114 <TCPIP_IPERF_Deinitialize+0x48>)
   1c0e2:	601c      	str	r4, [r3, #0]
   1c0e4:	2c00      	cmp	r4, #0
   1c0e6:	d1f9      	bne.n	1c0dc <TCPIP_IPERF_Deinitialize+0x10>
                for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
   1c0e8:	4b0b      	ldr	r3, [pc, #44]	; (1c118 <TCPIP_IPERF_Deinitialize+0x4c>)
   1c0ea:	681b      	ldr	r3, [r3, #0]
   1c0ec:	2b00      	cmp	r3, #0
   1c0ee:	ddf5      	ble.n	1c0dc <TCPIP_IPERF_Deinitialize+0x10>
   1c0f0:	4d0a      	ldr	r5, [pc, #40]	; (1c11c <TCPIP_IPERF_Deinitialize+0x50>)
                    	pIState->signalHandle = 0;
   1c0f2:	2700      	movs	r7, #0
                for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
   1c0f4:	4e08      	ldr	r6, [pc, #32]	; (1c118 <TCPIP_IPERF_Deinitialize+0x4c>)
   1c0f6:	e008      	b.n	1c10a <TCPIP_IPERF_Deinitialize+0x3e>
                    	_TCPIPStackSignalHandlerDeregister(pIState->signalHandle);
   1c0f8:	f005 fe1b 	bl	21d32 <_TCPIPStackSignalHandlerDeregister>
                    	pIState->signalHandle = 0;
   1c0fc:	f8c5 70c0 	str.w	r7, [r5, #192]	; 0xc0
                for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
   1c100:	3401      	adds	r4, #1
   1c102:	35d8      	adds	r5, #216	; 0xd8
   1c104:	6833      	ldr	r3, [r6, #0]
   1c106:	42a3      	cmp	r3, r4
   1c108:	dde8      	ble.n	1c0dc <TCPIP_IPERF_Deinitialize+0x10>
                	if(pIState->signalHandle != 0)
   1c10a:	f8d5 00c0 	ldr.w	r0, [r5, #192]	; 0xc0
   1c10e:	2800      	cmp	r0, #0
   1c110:	d1f2      	bne.n	1c0f8 <TCPIP_IPERF_Deinitialize+0x2c>
   1c112:	e7f5      	b.n	1c100 <TCPIP_IPERF_Deinitialize+0x34>
   1c114:	2000e3ec 	.word	0x2000e3ec
   1c118:	2000e3f0 	.word	0x2000e3f0
   1c11c:	2000d9b0 	.word	0x2000d9b0

Disassembly of section .text.IPv4RegisterFilter%516:

0001c120 <IPv4RegisterFilter>:
{
   1c120:	b530      	push	{r4, r5, lr}
   1c122:	b085      	sub	sp, #20
    if(ipv4MemH && handler)
   1c124:	4b10      	ldr	r3, [pc, #64]	; (1c168 <IPv4RegisterFilter+0x48>)
   1c126:	681c      	ldr	r4, [r3, #0]
   1c128:	b16c      	cbz	r4, 1c146 <IPv4RegisterFilter+0x26>
   1c12a:	b1d8      	cbz	r0, 1c164 <IPv4RegisterFilter+0x44>
   1c12c:	460d      	mov	r5, r1
        filtNode.handler = handler;
   1c12e:	9002      	str	r0, [sp, #8]
        filtNode.active = active;
   1c130:	f88d 100c 	strb.w	r1, [sp, #12]
        newNode = (IPV4_FILTER_LIST_NODE*)TCPIP_Notification_Add(&ipv4PacketFilters, ipv4MemH, &filtNode, sizeof(*newNode));
   1c134:	230c      	movs	r3, #12
   1c136:	aa01      	add	r2, sp, #4
   1c138:	4621      	mov	r1, r4
   1c13a:	480c      	ldr	r0, [pc, #48]	; (1c16c <IPv4RegisterFilter+0x4c>)
   1c13c:	f003 fdb9 	bl	1fcb2 <TCPIP_Notification_Add>
        if(newNode && active)
   1c140:	4604      	mov	r4, r0
   1c142:	b100      	cbz	r0, 1c146 <IPv4RegisterFilter+0x26>
   1c144:	b915      	cbnz	r5, 1c14c <IPv4RegisterFilter+0x2c>
}
   1c146:	4620      	mov	r0, r4
   1c148:	b005      	add	sp, #20
   1c14a:	bd30      	pop	{r4, r5, pc}
    TCPIP_Helper_ProtectedSingleListLock(notifyList);
   1c14c:	4d07      	ldr	r5, [pc, #28]	; (1c16c <IPv4RegisterFilter+0x4c>)
   1c14e:	4628      	mov	r0, r5
   1c150:	f004 fcae 	bl	20ab0 <TCPIP_Helper_ProtectedSingleListLock>
            ipv4ActFilterCount++;
   1c154:	4a06      	ldr	r2, [pc, #24]	; (1c170 <IPv4RegisterFilter+0x50>)
   1c156:	6813      	ldr	r3, [r2, #0]
   1c158:	3301      	adds	r3, #1
   1c15a:	6013      	str	r3, [r2, #0]
    TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
   1c15c:	4628      	mov	r0, r5
   1c15e:	f004 fee9 	bl	20f34 <TCPIP_Helper_ProtectedSingleListUnlock>
   1c162:	e7f0      	b.n	1c146 <IPv4RegisterFilter+0x26>
    IPV4_FILTER_LIST_NODE* newNode = 0;
   1c164:	2400      	movs	r4, #0
    return newNode;
   1c166:	e7ee      	b.n	1c146 <IPv4RegisterFilter+0x26>
   1c168:	2000e400 	.word	0x2000e400
   1c16c:	2000e23c 	.word	0x2000e23c
   1c170:	2000e3f4 	.word	0x2000e3f4

Disassembly of section .text._DHCPOptionWriteSrvIdent%517:

0001c174 <_DHCPOptionWriteSrvIdent>:
{
   1c174:	b570      	push	{r4, r5, r6, lr}
   1c176:	460c      	mov	r4, r1
    unsigned int msgType = pSendData->msgType;
   1c178:	68cd      	ldr	r5, [r1, #12]
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf); 
   1c17a:	4b12      	ldr	r3, [pc, #72]	; (1c1c4 <_DHCPOptionWriteSrvIdent+0x50>)
   1c17c:	681e      	ldr	r6, [r3, #0]
   1c17e:	f005 fdd1 	bl	21d24 <TCPIP_STACK_NetIxGet>
   1c182:	235c      	movs	r3, #92	; 0x5c
   1c184:	fb03 6000 	mla	r0, r3, r0, r6
    if( (msgType == TCPIP_DHCP_DECLINE_MESSAGE) ||  (msgType == TCPIP_DHCP_RELEASE_MESSAGE) ||
   1c188:	2d04      	cmp	r5, #4
   1c18a:	d009      	beq.n	1c1a0 <_DHCPOptionWriteSrvIdent+0x2c>
   1c18c:	2d07      	cmp	r5, #7
   1c18e:	d007      	beq.n	1c1a0 <_DHCPOptionWriteSrvIdent+0x2c>
   1c190:	2d03      	cmp	r5, #3
   1c192:	d001      	beq.n	1c198 <_DHCPOptionWriteSrvIdent+0x24>
    return 0;
   1c194:	2000      	movs	r0, #0
   1c196:	e00f      	b.n	1c1b8 <_DHCPOptionWriteSrvIdent+0x44>
            (msgType == TCPIP_DHCP_REQUEST_MESSAGE && pClient->dhcpOp != TCPIP_DHCP_OPER_INIT_REBOOT) )
   1c198:	f8b0 3054 	ldrh.w	r3, [r0, #84]	; 0x54
   1c19c:	2b02      	cmp	r3, #2
   1c19e:	d00c      	beq.n	1c1ba <_DHCPOptionWriteSrvIdent+0x46>
        if(pSendData->writeSpace >= sizeof(*pSrvId))
   1c1a0:	6863      	ldr	r3, [r4, #4]
   1c1a2:	2b05      	cmp	r3, #5
   1c1a4:	d90b      	bls.n	1c1be <_DHCPOptionWriteSrvIdent+0x4a>
            pSrvId = (TCPIP_DHCP_OPTION_DATA_SERVER_ID*)pSendData->pOpt;
   1c1a6:	6823      	ldr	r3, [r4, #0]
            pSrvId->opt = TCPIP_DHCP_SERVER_IDENTIFIER;
   1c1a8:	2236      	movs	r2, #54	; 0x36
   1c1aa:	701a      	strb	r2, [r3, #0]
            pSrvId->len = sizeof(pSrvId->serverId);
   1c1ac:	2204      	movs	r2, #4
   1c1ae:	705a      	strb	r2, [r3, #1]
            memcpy(pSrvId->serverId, &pClient->dwServerID, sizeof(pSrvId->serverId));
   1c1b0:	6a42      	ldr	r2, [r0, #36]	; 0x24
   1c1b2:	f8c3 2002 	str.w	r2, [r3, #2]
            return sizeof(*pSrvId);
   1c1b6:	2006      	movs	r0, #6
}
   1c1b8:	bd70      	pop	{r4, r5, r6, pc}
    return 0;
   1c1ba:	2000      	movs	r0, #0
   1c1bc:	e7fc      	b.n	1c1b8 <_DHCPOptionWriteSrvIdent+0x44>
        return -1;
   1c1be:	f04f 30ff 	mov.w	r0, #4294967295
   1c1c2:	e7f9      	b.n	1c1b8 <_DHCPOptionWriteSrvIdent+0x44>
   1c1c4:	2000e408 	.word	0x2000e408

Disassembly of section .text._DNS_DeleteHash%518:

0001c1c8 <_DNS_DeleteHash>:
{
   1c1c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1c1cc:	4604      	mov	r4, r0
    if((pOh = pDnsDcpt->hashDcpt) != 0)
   1c1ce:	6805      	ldr	r5, [r0, #0]
   1c1d0:	b1dd      	cbz	r5, 1c20a <_DNS_DeleteHash+0x42>
        for(bktIx = 0; bktIx < pOh->hEntries; bktIx++)
   1c1d2:	68eb      	ldr	r3, [r5, #12]
   1c1d4:	b1cb      	cbz	r3, 1c20a <_DNS_DeleteHash+0x42>
   1c1d6:	2600      	movs	r6, #0
            memset(pE, 0, sizeof(*pE));
   1c1d8:	f04f 0930 	mov.w	r9, #48	; 0x30
   1c1dc:	46b0      	mov	r8, r6
            pE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryGet(pOh, bktIx);
   1c1de:	4631      	mov	r1, r6
   1c1e0:	4628      	mov	r0, r5
   1c1e2:	f005 fc4a 	bl	21a7a <TCPIP_OAHASH_EntryGet>
   1c1e6:	4607      	mov	r7, r0
            TCPIP_OAHASH_EntryRemove(pOh, &pE->hEntry);
   1c1e8:	4601      	mov	r1, r0
   1c1ea:	4628      	mov	r0, r5
   1c1ec:	f005 f992 	bl	21514 <TCPIP_OAHASH_EntryRemove>
            TCPIP_HEAP_Free(pDnsDcpt->memH, pE->memblk);
   1c1f0:	6920      	ldr	r0, [r4, #16]
   1c1f2:	68c3      	ldr	r3, [r0, #12]
   1c1f4:	6879      	ldr	r1, [r7, #4]
   1c1f6:	4798      	blx	r3
            memset(pE, 0, sizeof(*pE));
   1c1f8:	464a      	mov	r2, r9
   1c1fa:	4641      	mov	r1, r8
   1c1fc:	4638      	mov	r0, r7
   1c1fe:	f005 fd45 	bl	21c8c <memset>
        for(bktIx = 0; bktIx < pOh->hEntries; bktIx++)
   1c202:	3601      	adds	r6, #1
   1c204:	68eb      	ldr	r3, [r5, #12]
   1c206:	429e      	cmp	r6, r3
   1c208:	d3e9      	bcc.n	1c1de <_DNS_DeleteHash+0x16>
    TCPIP_HEAP_Free(pDnsDcpt->memH, pDnsDcpt->hashDcpt);
   1c20a:	6920      	ldr	r0, [r4, #16]
   1c20c:	68c3      	ldr	r3, [r0, #12]
   1c20e:	6821      	ldr	r1, [r4, #0]
   1c210:	4798      	blx	r3
    pDnsDcpt->hashDcpt = 0;
   1c212:	2300      	movs	r3, #0
   1c214:	6023      	str	r3, [r4, #0]
    pDnsDcpt->unsolvedEntries = 0;
   1c216:	84e3      	strh	r3, [r4, #38]	; 0x26
}
   1c218:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

Disassembly of section .text.TCPIP_DNS_RemoveAll%519:

0001c21c <TCPIP_DNS_RemoveAll>:
{
   1c21c:	b570      	push	{r4, r5, r6, lr}
    pDnsDcpt = pgDnsDcpt;
   1c21e:	4b13      	ldr	r3, [pc, #76]	; (1c26c <TCPIP_DNS_RemoveAll+0x50>)
   1c220:	681e      	ldr	r6, [r3, #0]
    if(pDnsDcpt == 0 || pDnsDcpt->hashDcpt == 0)
   1c222:	b1d6      	cbz	r6, 1c25a <TCPIP_DNS_RemoveAll+0x3e>
   1c224:	6835      	ldr	r5, [r6, #0]
   1c226:	b1dd      	cbz	r5, 1c260 <TCPIP_DNS_RemoveAll+0x44>
    for(bktIx = 0; bktIx < pOh->hEntries; bktIx++)
   1c228:	68eb      	ldr	r3, [r5, #12]
   1c22a:	b1e3      	cbz	r3, 1c266 <TCPIP_DNS_RemoveAll+0x4a>
   1c22c:	2400      	movs	r4, #0
   1c22e:	e006      	b.n	1c23e <TCPIP_DNS_RemoveAll+0x22>
    _DNS_CleanCacheEntry(pDnsDcpt, pDnsHE);
   1c230:	4630      	mov	r0, r6
   1c232:	f003 fa50 	bl	1f6d6 <_DNS_CleanCacheEntry>
    for(bktIx = 0; bktIx < pOh->hEntries; bktIx++)
   1c236:	3401      	adds	r4, #1
   1c238:	68eb      	ldr	r3, [r5, #12]
   1c23a:	42a3      	cmp	r3, r4
   1c23c:	d90b      	bls.n	1c256 <TCPIP_DNS_RemoveAll+0x3a>
        pBkt = TCPIP_OAHASH_EntryGet(pOh, bktIx);
   1c23e:	4621      	mov	r1, r4
   1c240:	4628      	mov	r0, r5
   1c242:	f005 fc1a 	bl	21a7a <TCPIP_OAHASH_EntryGet>
        if(pBkt != 0)
   1c246:	4601      	mov	r1, r0
   1c248:	2800      	cmp	r0, #0
   1c24a:	d0f4      	beq.n	1c236 <TCPIP_DNS_RemoveAll+0x1a>
            if(pBkt->flags.busy != 0)
   1c24c:	7803      	ldrb	r3, [r0, #0]
   1c24e:	f013 0f01 	tst.w	r3, #1
   1c252:	d0f0      	beq.n	1c236 <TCPIP_DNS_RemoveAll+0x1a>
   1c254:	e7ec      	b.n	1c230 <TCPIP_DNS_RemoveAll+0x14>
    return TCPIP_DNS_RES_OK;
   1c256:	2000      	movs	r0, #0
}
   1c258:	bd70      	pop	{r4, r5, r6, pc}
        return TCPIP_DNS_RES_NO_SERVICE;
   1c25a:	f06f 0005 	mvn.w	r0, #5
   1c25e:	e7fb      	b.n	1c258 <TCPIP_DNS_RemoveAll+0x3c>
   1c260:	f06f 0005 	mvn.w	r0, #5
   1c264:	e7f8      	b.n	1c258 <TCPIP_DNS_RemoveAll+0x3c>
    return TCPIP_DNS_RES_OK;
   1c266:	2000      	movs	r0, #0
   1c268:	e7f6      	b.n	1c258 <TCPIP_DNS_RemoveAll+0x3c>
   1c26a:	bf00      	nop
   1c26c:	2000e424 	.word	0x2000e424

Disassembly of section .text.TCPIP_STACK_StringToMACId%520:

0001c270 <TCPIP_STACK_StringToMACId>:
    if(str)
   1c270:	b1e8      	cbz	r0, 1c2ae <TCPIP_STACK_StringToMACId+0x3e>
{
   1c272:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1c276:	4680      	mov	r8, r0
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   1c278:	4b10      	ldr	r3, [pc, #64]	; (1c2bc <TCPIP_STACK_StringToMACId+0x4c>)
   1c27a:	681c      	ldr	r4, [r3, #0]
   1c27c:	4b10      	ldr	r3, [pc, #64]	; (1c2c0 <TCPIP_STACK_StringToMACId+0x50>)
   1c27e:	681f      	ldr	r7, [r3, #0]
   1c280:	2f00      	cmp	r7, #0
   1c282:	dd17      	ble.n	1c2b4 <TCPIP_STACK_StringToMACId+0x44>
   1c284:	2500      	movs	r5, #0
   1c286:	e003      	b.n	1c290 <TCPIP_STACK_StringToMACId+0x20>
   1c288:	3501      	adds	r5, #1
   1c28a:	346c      	adds	r4, #108	; 0x6c
   1c28c:	42bd      	cmp	r5, r7
   1c28e:	d00a      	beq.n	1c2a6 <TCPIP_STACK_StringToMACId+0x36>
            if((pObj = pNetIf->pMacObj) != 0)
   1c290:	6c66      	ldr	r6, [r4, #68]	; 0x44
   1c292:	2e00      	cmp	r6, #0
   1c294:	d0f8      	beq.n	1c288 <TCPIP_STACK_StringToMACId+0x18>
                if(strcmp(str, pObj->macName) == 0)
   1c296:	6871      	ldr	r1, [r6, #4]
   1c298:	4640      	mov	r0, r8
   1c29a:	f005 fbbf 	bl	21a1c <strcmp>
   1c29e:	2800      	cmp	r0, #0
   1c2a0:	d1f2      	bne.n	1c288 <TCPIP_STACK_StringToMACId+0x18>
                    return pObj->macId;
   1c2a2:	8830      	ldrh	r0, [r6, #0]
   1c2a4:	e001      	b.n	1c2aa <TCPIP_STACK_StringToMACId+0x3a>
    return (TCPIP_STACK_MODULE)TCPIP_MODULE_MAC_NONE;
   1c2a6:	f44f 5080 	mov.w	r0, #4096	; 0x1000
}
   1c2aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return (TCPIP_STACK_MODULE)TCPIP_MODULE_MAC_NONE;
   1c2ae:	f44f 5080 	mov.w	r0, #4096	; 0x1000
}
   1c2b2:	4770      	bx	lr
    return (TCPIP_STACK_MODULE)TCPIP_MODULE_MAC_NONE;
   1c2b4:	f44f 5080 	mov.w	r0, #4096	; 0x1000
   1c2b8:	e7f7      	b.n	1c2aa <TCPIP_STACK_StringToMACId+0x3a>
   1c2ba:	bf00      	nop
   1c2bc:	2000e440 	.word	0x2000e440
   1c2c0:	2000e0f0 	.word	0x2000e0f0

Disassembly of section .text._TCPIPStackAnyNetLinked%521:

0001c2c4 <_TCPIPStackAnyNetLinked>:
{
   1c2c4:	b508      	push	{r3, lr}
    if(useDefault)
   1c2c6:	b128      	cbz	r0, 1c2d4 <_TCPIPStackAnyNetLinked+0x10>
        pNetIf = _TCPIPStackHandleToNetLinked(tcpipDefIf.defaultNet);
   1c2c8:	4b10      	ldr	r3, [pc, #64]	; (1c30c <_TCPIPStackAnyNetLinked+0x48>)
   1c2ca:	6818      	ldr	r0, [r3, #0]
   1c2cc:	f004 fc20 	bl	20b10 <_TCPIPStackHandleToNetLinked>
    if(pNetIf == 0)
   1c2d0:	4603      	mov	r3, r0
   1c2d2:	b9b8      	cbnz	r0, 1c304 <_TCPIPStackAnyNetLinked+0x40>
        for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1c2d4:	4b0e      	ldr	r3, [pc, #56]	; (1c310 <_TCPIPStackAnyNetLinked+0x4c>)
   1c2d6:	681b      	ldr	r3, [r3, #0]
   1c2d8:	4a0e      	ldr	r2, [pc, #56]	; (1c314 <_TCPIPStackAnyNetLinked+0x50>)
   1c2da:	6810      	ldr	r0, [r2, #0]
   1c2dc:	2800      	cmp	r0, #0
   1c2de:	dd13      	ble.n	1c308 <_TCPIPStackAnyNetLinked+0x44>
   1c2e0:	2200      	movs	r2, #0
   1c2e2:	e003      	b.n	1c2ec <_TCPIPStackAnyNetLinked+0x28>
   1c2e4:	3201      	adds	r2, #1
   1c2e6:	336c      	adds	r3, #108	; 0x6c
   1c2e8:	4282      	cmp	r2, r0
   1c2ea:	d00a      	beq.n	1c302 <_TCPIPStackAnyNetLinked+0x3e>
            if(pIf->Flags.bInterfaceEnabled && pIf->exFlags.linkPrev != 0)
   1c2ec:	f893 1042 	ldrb.w	r1, [r3, #66]	; 0x42
   1c2f0:	f011 0f40 	tst.w	r1, #64	; 0x40
   1c2f4:	d0f6      	beq.n	1c2e4 <_TCPIPStackAnyNetLinked+0x20>
   1c2f6:	f893 1060 	ldrb.w	r1, [r3, #96]	; 0x60
   1c2fa:	f011 0f01 	tst.w	r1, #1
   1c2fe:	d0f1      	beq.n	1c2e4 <_TCPIPStackAnyNetLinked+0x20>
   1c300:	e000      	b.n	1c304 <_TCPIPStackAnyNetLinked+0x40>
   1c302:	2300      	movs	r3, #0
}
   1c304:	4618      	mov	r0, r3
   1c306:	bd08      	pop	{r3, pc}
        for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1c308:	2300      	movs	r3, #0
    return pNetIf;
   1c30a:	e7fb      	b.n	1c304 <_TCPIPStackAnyNetLinked+0x40>
   1c30c:	2000e43c 	.word	0x2000e43c
   1c310:	2000e440 	.word	0x2000e440
   1c314:	2000e0f0 	.word	0x2000e0f0

Disassembly of section .text.SYS_TIME_CallbackRegisterMS%522:

0001c318 <SYS_TIME_CallbackRegisterMS>:

    return handle;
}

SYS_TIME_HANDLE SYS_TIME_CallbackRegisterMS ( SYS_TIME_CALLBACK callback, uintptr_t context, uint32_t ms, SYS_TIME_CALLBACK_TYPE type )
{
   1c318:	b5f0      	push	{r4, r5, r6, r7, lr}
   1c31a:	b083      	sub	sp, #12
    SYS_TIME_HANDLE handle = SYS_TIME_HANDLE_INVALID;

    /* Single shot timers must register a callback. */
    if ((type == SYS_TIME_SINGLE) && (callback == NULL))
   1c31c:	461f      	mov	r7, r3
   1c31e:	b903      	cbnz	r3, 1c322 <SYS_TIME_CallbackRegisterMS+0xa>
   1c320:	b1f8      	cbz	r0, 1c362 <SYS_TIME_CallbackRegisterMS+0x4a>
    {
        return handle;
    }

    if (ms != 0)
   1c322:	b922      	cbnz	r2, 1c32e <SYS_TIME_CallbackRegisterMS+0x16>
    SYS_TIME_HANDLE handle = SYS_TIME_HANDLE_INVALID;
   1c324:	f04f 34ff 	mov.w	r4, #4294967295
            SYS_TIME_TimerStart(handle);
        }
    }

    return handle;
}
   1c328:	4620      	mov	r0, r4
   1c32a:	b003      	add	sp, #12
   1c32c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1c32e:	4614      	mov	r4, r2
   1c330:	460e      	mov	r6, r1
   1c332:	4605      	mov	r5, r0
    return (uint32_t) (( ms * (uint64_t) gSystemCounterObj.hwTimerFrequency) / 1000);
   1c334:	4b0c      	ldr	r3, [pc, #48]	; (1c368 <SYS_TIME_CallbackRegisterMS+0x50>)
   1c336:	68d8      	ldr	r0, [r3, #12]
   1c338:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1c33c:	2300      	movs	r3, #0
   1c33e:	fba0 0104 	umull	r0, r1, r0, r4
   1c342:	f003 f8e1 	bl	1f508 <__aeabi_uldivmod>
        handle = SYS_TIME_TimerObjectCreate(0, SYS_TIME_MSToCount(ms), callback, context, type);
   1c346:	9700      	str	r7, [sp, #0]
   1c348:	4633      	mov	r3, r6
   1c34a:	462a      	mov	r2, r5
   1c34c:	4601      	mov	r1, r0
   1c34e:	2000      	movs	r0, #0
   1c350:	f7fa fdc8 	bl	16ee4 <SYS_TIME_TimerObjectCreate>
   1c354:	4604      	mov	r4, r0
        if(handle != SYS_TIME_HANDLE_INVALID)
   1c356:	f1b0 3fff 	cmp.w	r0, #4294967295
   1c35a:	d0e5      	beq.n	1c328 <SYS_TIME_CallbackRegisterMS+0x10>
            SYS_TIME_TimerStart(handle);
   1c35c:	f7ff fdb6 	bl	1becc <SYS_TIME_TimerStart>
   1c360:	e7e2      	b.n	1c328 <SYS_TIME_CallbackRegisterMS+0x10>
        return handle;
   1c362:	f04f 34ff 	mov.w	r4, #4294967295
   1c366:	e7df      	b.n	1c328 <SYS_TIME_CallbackRegisterMS+0x10>
   1c368:	2000e030 	.word	0x2000e030

Disassembly of section .text.strtok%523:

0001c36c <strtok>:
   1c36c:	4b13      	ldr	r3, [pc, #76]	; (1c3bc <strtok+0x50>)
   1c36e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1c372:	681d      	ldr	r5, [r3, #0]
   1c374:	6dac      	ldr	r4, [r5, #88]	; 0x58
   1c376:	4606      	mov	r6, r0
   1c378:	460f      	mov	r7, r1
   1c37a:	b9b4      	cbnz	r4, 1c3aa <strtok+0x3e>
   1c37c:	2050      	movs	r0, #80	; 0x50
   1c37e:	f005 fc75 	bl	21c6c <malloc>
   1c382:	65a8      	str	r0, [r5, #88]	; 0x58
   1c384:	e9c0 4400 	strd	r4, r4, [r0]
   1c388:	e9c0 4402 	strd	r4, r4, [r0, #8]
   1c38c:	e9c0 4404 	strd	r4, r4, [r0, #16]
   1c390:	e9c0 440a 	strd	r4, r4, [r0, #40]	; 0x28
   1c394:	e9c0 440c 	strd	r4, r4, [r0, #48]	; 0x30
   1c398:	e9c0 440e 	strd	r4, r4, [r0, #56]	; 0x38
   1c39c:	e9c0 4410 	strd	r4, r4, [r0, #64]	; 0x40
   1c3a0:	e9c0 4412 	strd	r4, r4, [r0, #72]	; 0x48
   1c3a4:	6184      	str	r4, [r0, #24]
   1c3a6:	7704      	strb	r4, [r0, #28]
   1c3a8:	6244      	str	r4, [r0, #36]	; 0x24
   1c3aa:	6daa      	ldr	r2, [r5, #88]	; 0x58
   1c3ac:	4639      	mov	r1, r7
   1c3ae:	4630      	mov	r0, r6
   1c3b0:	2301      	movs	r3, #1
   1c3b2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1c3b6:	f000 b87f 	b.w	1c4b8 <__strtok_r>
   1c3ba:	bf00      	nop
   1c3bc:	2000e4e4 	.word	0x2000e4e4

Disassembly of section .text._fflush_r%524:

0001c3c0 <_fflush_r>:
   1c3c0:	b538      	push	{r3, r4, r5, lr}
   1c3c2:	690b      	ldr	r3, [r1, #16]
   1c3c4:	4605      	mov	r5, r0
   1c3c6:	460c      	mov	r4, r1
   1c3c8:	b1db      	cbz	r3, 1c402 <_fflush_r+0x42>
   1c3ca:	b118      	cbz	r0, 1c3d4 <_fflush_r+0x14>
   1c3cc:	6983      	ldr	r3, [r0, #24]
   1c3ce:	b90b      	cbnz	r3, 1c3d4 <_fflush_r+0x14>
   1c3d0:	f7ff f9ee 	bl	1b7b0 <__sinit>
   1c3d4:	4b0c      	ldr	r3, [pc, #48]	; (1c408 <_fflush_r+0x48>)
   1c3d6:	429c      	cmp	r4, r3
   1c3d8:	d109      	bne.n	1c3ee <_fflush_r+0x2e>
   1c3da:	686c      	ldr	r4, [r5, #4]
   1c3dc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   1c3e0:	b17b      	cbz	r3, 1c402 <_fflush_r+0x42>
   1c3e2:	4621      	mov	r1, r4
   1c3e4:	4628      	mov	r0, r5
   1c3e6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1c3ea:	f7f7 bcc3 	b.w	13d74 <__sflush_r>
   1c3ee:	4b07      	ldr	r3, [pc, #28]	; (1c40c <_fflush_r+0x4c>)
   1c3f0:	429c      	cmp	r4, r3
   1c3f2:	d101      	bne.n	1c3f8 <_fflush_r+0x38>
   1c3f4:	68ac      	ldr	r4, [r5, #8]
   1c3f6:	e7f1      	b.n	1c3dc <_fflush_r+0x1c>
   1c3f8:	4b05      	ldr	r3, [pc, #20]	; (1c410 <_fflush_r+0x50>)
   1c3fa:	429c      	cmp	r4, r3
   1c3fc:	bf08      	it	eq
   1c3fe:	68ec      	ldreq	r4, [r5, #12]
   1c400:	e7ec      	b.n	1c3dc <_fflush_r+0x1c>
   1c402:	2000      	movs	r0, #0
   1c404:	bd38      	pop	{r3, r4, r5, pc}
   1c406:	bf00      	nop
   1c408:	2000e130 	.word	0x2000e130
   1c40c:	2000e150 	.word	0x2000e150
   1c410:	2000e110 	.word	0x2000e110

Disassembly of section .text._TcpAbort%525:

0001c414 <_TcpAbort>:
{
   1c414:	b570      	push	{r4, r5, r6, lr}
   1c416:	4604      	mov	r4, r0
   1c418:	460d      	mov	r5, r1
   1c41a:	4616      	mov	r6, r2
	switch(pSkt->smState)
   1c41c:	f890 306e 	ldrb.w	r3, [r0, #110]	; 0x6e
   1c420:	3b02      	subs	r3, #2
   1c422:	2b07      	cmp	r3, #7
   1c424:	d811      	bhi.n	1c44a <_TcpAbort+0x36>
   1c426:	e8df f003 	tbb	[pc, r3]
   1c42a:	0808      	.short	0x0808
   1c42c:	04100808 	.word	0x04100808
   1c430:	0808      	.short	0x0808
            if((abFlags & _TCP_ABORT_FLAG_SHUTDOWN) == 0)
   1c432:	f011 0f02 	tst.w	r1, #2
   1c436:	d108      	bne.n	1c44a <_TcpAbort+0x36>
   1c438:	e014      	b.n	1c464 <_TcpAbort+0x50>
    pSkt->txHead = pSkt->txTail = pSkt->txUnackedTail = pSkt->txStart;
   1c43a:	6803      	ldr	r3, [r0, #0]
   1c43c:	6103      	str	r3, [r0, #16]
   1c43e:	60c3      	str	r3, [r0, #12]
   1c440:	6083      	str	r3, [r0, #8]
        _TcpSend(pSkt, RST | ACK, 0);
   1c442:	2200      	movs	r2, #0
   1c444:	2114      	movs	r1, #20
   1c446:	f7eb fbed 	bl	7c24 <_TcpSend>
    if((abFlags & (_TCP_ABORT_FLAG_FORCE_CLOSE | _TCP_ABORT_FLAG_SHUTDOWN)) != 0)
   1c44a:	f015 0f03 	tst.w	r5, #3
   1c44e:	d005      	beq.n	1c45c <_TcpAbort+0x48>
        pSkt->flags.forceKill = 1;
   1c450:	f894 306d 	ldrb.w	r3, [r4, #109]	; 0x6d
   1c454:	f043 0304 	orr.w	r3, r3, #4
   1c458:	f884 306d 	strb.w	r3, [r4, #109]	; 0x6d
    _TcpCloseSocket(pSkt, tcpEvent);
   1c45c:	4631      	mov	r1, r6
   1c45e:	4620      	mov	r0, r4
   1c460:	f7f4 fcb4 	bl	10dcc <_TcpCloseSocket>
}
   1c464:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_TCP_RemoteBind%526:

0001c466 <TCPIP_TCP_RemoteBind>:
{
   1c466:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1c46a:	4607      	mov	r7, r0
   1c46c:	4688      	mov	r8, r1
   1c46e:	4616      	mov	r6, r2
   1c470:	461d      	mov	r5, r3
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   1c472:	f003 fcd3 	bl	1fe1c <_TcpSocketChk>
    if(pSkt != 0 && !_TCP_IsConnected(pSkt))
   1c476:	b1a8      	cbz	r0, 1c4a4 <TCPIP_TCP_RemoteBind+0x3e>
   1c478:	4604      	mov	r4, r0
    return (pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1 || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2 || pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT);
   1c47a:	f890 206e 	ldrb.w	r2, [r0, #110]	; 0x6e
   1c47e:	1ed3      	subs	r3, r2, #3
   1c480:	b2db      	uxtb	r3, r3
   1c482:	2b02      	cmp	r3, #2
   1c484:	d910      	bls.n	1c4a8 <TCPIP_TCP_RemoteBind+0x42>
    if(pSkt != 0 && !_TCP_IsConnected(pSkt))
   1c486:	2a08      	cmp	r2, #8
   1c488:	d012      	beq.n	1c4b0 <TCPIP_TCP_RemoteBind+0x4a>
        if(remoteAddress == 0 || TCPIP_TCP_DestinationIPAddressSet(hTCP, addType, remoteAddress) == true)
   1c48a:	b135      	cbz	r5, 1c49a <TCPIP_TCP_RemoteBind+0x34>
   1c48c:	462a      	mov	r2, r5
   1c48e:	4641      	mov	r1, r8
   1c490:	4638      	mov	r0, r7
   1c492:	f000 fce1 	bl	1ce58 <TCPIP_TCP_DestinationIPAddressSet>
   1c496:	4603      	mov	r3, r0
   1c498:	b138      	cbz	r0, 1c4aa <TCPIP_TCP_RemoteBind+0x44>
            if(remotePort != 0)
   1c49a:	b15e      	cbz	r6, 1c4b4 <TCPIP_TCP_RemoteBind+0x4e>
                pSkt->remotePort = remotePort;
   1c49c:	f8a4 6058 	strh.w	r6, [r4, #88]	; 0x58
            return true;
   1c4a0:	2301      	movs	r3, #1
   1c4a2:	e002      	b.n	1c4aa <TCPIP_TCP_RemoteBind+0x44>
    return false;
   1c4a4:	2300      	movs	r3, #0
   1c4a6:	e000      	b.n	1c4aa <TCPIP_TCP_RemoteBind+0x44>
   1c4a8:	2300      	movs	r3, #0
}
   1c4aa:	4618      	mov	r0, r3
   1c4ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return false;
   1c4b0:	2300      	movs	r3, #0
   1c4b2:	e7fa      	b.n	1c4aa <TCPIP_TCP_RemoteBind+0x44>
            return true;
   1c4b4:	2301      	movs	r3, #1
   1c4b6:	e7f8      	b.n	1c4aa <TCPIP_TCP_RemoteBind+0x44>

Disassembly of section .text.__strtok_r%527:

0001c4b8 <__strtok_r>:
   1c4b8:	b5f0      	push	{r4, r5, r6, r7, lr}
   1c4ba:	b918      	cbnz	r0, 1c4c4 <__strtok_r+0xc>
   1c4bc:	6810      	ldr	r0, [r2, #0]
   1c4be:	b908      	cbnz	r0, 1c4c4 <__strtok_r+0xc>
   1c4c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1c4c2:	4620      	mov	r0, r4
   1c4c4:	4604      	mov	r4, r0
   1c4c6:	460f      	mov	r7, r1
   1c4c8:	f814 5b01 	ldrb.w	r5, [r4], #1
   1c4cc:	f817 6b01 	ldrb.w	r6, [r7], #1
   1c4d0:	b91e      	cbnz	r6, 1c4da <__strtok_r+0x22>
   1c4d2:	b965      	cbnz	r5, 1c4ee <__strtok_r+0x36>
   1c4d4:	6015      	str	r5, [r2, #0]
   1c4d6:	4628      	mov	r0, r5
   1c4d8:	e7f2      	b.n	1c4c0 <__strtok_r+0x8>
   1c4da:	42b5      	cmp	r5, r6
   1c4dc:	d1f6      	bne.n	1c4cc <__strtok_r+0x14>
   1c4de:	2b00      	cmp	r3, #0
   1c4e0:	d1ef      	bne.n	1c4c2 <__strtok_r+0xa>
   1c4e2:	6014      	str	r4, [r2, #0]
   1c4e4:	7003      	strb	r3, [r0, #0]
   1c4e6:	e7eb      	b.n	1c4c0 <__strtok_r+0x8>
   1c4e8:	461c      	mov	r4, r3
   1c4ea:	e00c      	b.n	1c506 <__strtok_r+0x4e>
   1c4ec:	b915      	cbnz	r5, 1c4f4 <__strtok_r+0x3c>
   1c4ee:	f814 3b01 	ldrb.w	r3, [r4], #1
   1c4f2:	460e      	mov	r6, r1
   1c4f4:	f816 5b01 	ldrb.w	r5, [r6], #1
   1c4f8:	42ab      	cmp	r3, r5
   1c4fa:	d1f7      	bne.n	1c4ec <__strtok_r+0x34>
   1c4fc:	2b00      	cmp	r3, #0
   1c4fe:	d0f3      	beq.n	1c4e8 <__strtok_r+0x30>
   1c500:	2300      	movs	r3, #0
   1c502:	f804 3c01 	strb.w	r3, [r4, #-1]
   1c506:	6014      	str	r4, [r2, #0]
   1c508:	e7da      	b.n	1c4c0 <__strtok_r+0x8>

Disassembly of section .text.DRV_ETHPHY_LinkStatusGet%528:

0001c50c <DRV_ETHPHY_LinkStatusGet>:
    if(hClientObj != 0)
   1c50c:	b1c0      	cbz	r0, 1c540 <DRV_ETHPHY_LinkStatusGet+0x34>
{
   1c50e:	b410      	push	{r4}
   1c510:	4601      	mov	r1, r0
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1c512:	68c4      	ldr	r4, [r0, #12]
   1c514:	4810      	ldr	r0, [pc, #64]	; (1c558 <DRV_ETHPHY_LinkStatusGet+0x4c>)
   1c516:	4284      	cmp	r4, r0
   1c518:	d115      	bne.n	1c546 <DRV_ETHPHY_LinkStatusGet+0x3a>
            if(hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_READY)
   1c51a:	f991 0008 	ldrsb.w	r0, [r1, #8]
   1c51e:	2802      	cmp	r0, #2
   1c520:	d114      	bne.n	1c54c <DRV_ETHPHY_LinkStatusGet+0x40>
            if(pLinkStat == 0)
   1c522:	b1b2      	cbz	r2, 1c552 <DRV_ETHPHY_LinkStatusGet+0x46>
            hClientObj->operParam = (uintptr_t)pLinkStat;
   1c524:	630a      	str	r2, [r1, #48]	; 0x30
            hClientObj->operReg[0] = refresh;
   1c526:	844b      	strh	r3, [r1, #34]	; 0x22
    hClientObj->operType = opType;
   1c528:	2302      	movs	r3, #2
   1c52a:	838b      	strh	r3, [r1, #28]
    hClientObj->operPhase = hClientObj->operSubPhase = 0; 
   1c52c:	2300      	movs	r3, #0
   1c52e:	840b      	strh	r3, [r1, #32]
   1c530:	83cb      	strh	r3, [r1, #30]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_BUSY; 
   1c532:	2001      	movs	r0, #1
   1c534:	7208      	strb	r0, [r1, #8]
    hClientObj->operRes = res;
   1c536:	f881 002c 	strb.w	r0, [r1, #44]	; 0x2c
}
   1c53a:	f85d 4b04 	ldr.w	r4, [sp], #4
   1c53e:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1c540:	f06f 000a 	mvn.w	r0, #10
}
   1c544:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1c546:	f06f 000a 	mvn.w	r0, #10
   1c54a:	e7f6      	b.n	1c53a <DRV_ETHPHY_LinkStatusGet+0x2e>
                return DRV_ETHPHY_RES_NOT_READY_ERR;
   1c54c:	f06f 0009 	mvn.w	r0, #9
   1c550:	e7f3      	b.n	1c53a <DRV_ETHPHY_LinkStatusGet+0x2e>
                return DRV_ETHPHY_RES_OPERATION_ERR;
   1c552:	f06f 0008 	mvn.w	r0, #8
   1c556:	e7f0      	b.n	1c53a <DRV_ETHPHY_LinkStatusGet+0x2e>
   1c558:	2000de18 	.word	0x2000de18

Disassembly of section .text.DRV_GMAC_ParametersGet%529:

0001c55c <DRV_GMAC_ParametersGet>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1c55c:	4b12      	ldr	r3, [pc, #72]	; (1c5a8 <DRV_GMAC_ParametersGet+0x4c>)
   1c55e:	4283      	cmp	r3, r0
   1c560:	d117      	bne.n	1c592 <DRV_GMAC_ParametersGet+0x36>
    if(pMACDrv == 0)
   1c562:	b1c8      	cbz	r0, 1c598 <DRV_GMAC_ParametersGet+0x3c>
	if(pMACDrv->sGmacData.sysStat == SYS_STATUS_READY)
   1c564:	f993 3014 	ldrsb.w	r3, [r3, #20]
   1c568:	2b02      	cmp	r3, #2
   1c56a:	d118      	bne.n	1c59e <DRV_GMAC_ParametersGet+0x42>
		if(pMacParams)
   1c56c:	b1d1      	cbz	r1, 1c5a4 <DRV_GMAC_ParametersGet+0x48>
{
   1c56e:	b510      	push	{r4, lr}
   1c570:	460c      	mov	r4, r1
            DRV_PIC32CGMAC_LibGetMacAddr(pMacParams->ifPhyAddress.v);
   1c572:	4608      	mov	r0, r1
   1c574:	f002 f8b2 	bl	1e6dc <DRV_PIC32CGMAC_LibGetMacAddr>
			pMacParams->processFlags = (TCPIP_MAC_PROCESS_FLAG_RX | TCPIP_MAC_PROCESS_FLAG_TX);
   1c578:	2303      	movs	r3, #3
   1c57a:	80e3      	strh	r3, [r4, #6]
			pMacParams->macType = TCPIP_MAC_TYPE_ETH;
   1c57c:	2301      	movs	r3, #1
   1c57e:	7223      	strb	r3, [r4, #8]
			pMacParams->linkMtu = TCPIP_MAC_LINK_MTU_ETH;
   1c580:	f240 52dc 	movw	r2, #1500	; 0x5dc
   1c584:	8162      	strh	r2, [r4, #10]
            pMacParams->checksumOffloadRx = DRV_GMAC_RX_CHKSM_OFFLOAD;
   1c586:	2000      	movs	r0, #0
   1c588:	7320      	strb	r0, [r4, #12]
            pMacParams->checksumOffloadTx = DRV_GMAC_TX_CHKSM_OFFLOAD;
   1c58a:	7360      	strb	r0, [r4, #13]
            pMacParams->macTxPrioNum = TCPIP_GMAC_TX_PRIO_COUNT;
   1c58c:	73a3      	strb	r3, [r4, #14]
            pMacParams->macRxPrioNum = TCPIP_GMAC_RX_PRIO_COUNT;
   1c58e:	73e3      	strb	r3, [r4, #15]
}
   1c590:	bd10      	pop	{r4, pc}
        return TCPIP_MAC_RES_OP_ERR;
   1c592:	f06f 0005 	mvn.w	r0, #5
   1c596:	4770      	bx	lr
   1c598:	f06f 0005 	mvn.w	r0, #5
   1c59c:	4770      	bx	lr
	return TCPIP_MAC_RES_IS_BUSY;
   1c59e:	f06f 0001 	mvn.w	r0, #1
   1c5a2:	4770      	bx	lr
		return TCPIP_MAC_RES_OK;
   1c5a4:	2000      	movs	r0, #0
}
   1c5a6:	4770      	bx	lr
   1c5a8:	2000d8b8 	.word	0x2000d8b8

Disassembly of section .rodata%530:

0001c5ac <.rodata%530>:
   1c5ac:	20504354 	.word	0x20504354
   1c5b0:	4c4c554e 	.word	0x4c4c554e
   1c5b4:	6e796420 	.word	0x6e796420
   1c5b8:	63696d61 	.word	0x63696d61
   1c5bc:	6c6c6120 	.word	0x6c6c6120
   1c5c0:	7461636f 	.word	0x7461636f
   1c5c4:	206e6f69 	.word	0x206e6f69
   1c5c8:	646e6168 	.word	0x646e6168
   1c5cc:	692f656c 	.word	0x692f656c
   1c5d0:	2074696e 	.word	0x2074696e
   1c5d4:	61746164 	.word	0x61746164
   1c5d8:	00000000 	.word	0x00000000
   1c5dc:	50435420 	.word	0x50435420
   1c5e0:	6e794420 	.word	0x6e794420
   1c5e4:	63696d61 	.word	0x63696d61
   1c5e8:	6c6c6120 	.word	0x6c6c6120
   1c5ec:	7461636f 	.word	0x7461636f
   1c5f0:	206e6f69 	.word	0x206e6f69
   1c5f4:	6c696166 	.word	0x6c696166
   1c5f8:	6465      	.short	0x6465
	...

Disassembly of section .text._DHCPOptionWriteIPRequest%531:

0001c5fc <_DHCPOptionWriteIPRequest>:
{
   1c5fc:	b570      	push	{r4, r5, r6, lr}
   1c5fe:	460c      	mov	r4, r1
    unsigned int msgType = pSendData->msgType;
   1c600:	68cd      	ldr	r5, [r1, #12]
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf); 
   1c602:	4b11      	ldr	r3, [pc, #68]	; (1c648 <_DHCPOptionWriteIPRequest+0x4c>)
   1c604:	681e      	ldr	r6, [r3, #0]
   1c606:	f005 fb8d 	bl	21d24 <TCPIP_STACK_NetIxGet>
   1c60a:	235c      	movs	r3, #92	; 0x5c
   1c60c:	fb03 6000 	mla	r0, r3, r0, r6
    if ( (msgType == TCPIP_DHCP_DECLINE_MESSAGE) || (msgType == TCPIP_DHCP_REQUEST_MESSAGE) ||  
   1c610:	1eeb      	subs	r3, r5, #3
   1c612:	2b01      	cmp	r3, #1
   1c614:	d905      	bls.n	1c622 <_DHCPOptionWriteIPRequest+0x26>
   1c616:	2d01      	cmp	r5, #1
   1c618:	d001      	beq.n	1c61e <_DHCPOptionWriteIPRequest+0x22>
    return 0;
   1c61a:	2000      	movs	r0, #0
   1c61c:	e00d      	b.n	1c63a <_DHCPOptionWriteIPRequest+0x3e>
            ((msgType == TCPIP_DHCP_DISCOVER_MESSAGE) && pClient->dhcpIPAddress.Val))
   1c61e:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   1c620:	b163      	cbz	r3, 1c63c <_DHCPOptionWriteIPRequest+0x40>
        if(pSendData->writeSpace >= sizeof(*pReqAdd))
   1c622:	6863      	ldr	r3, [r4, #4]
   1c624:	2b05      	cmp	r3, #5
   1c626:	d90b      	bls.n	1c640 <_DHCPOptionWriteIPRequest+0x44>
            pReqAdd = (TCPIP_DHCP_OPTION_DATA_REQUEST_IP_ADDRESS*)pSendData->pOpt;
   1c628:	6823      	ldr	r3, [r4, #0]
            pReqAdd->opt = TCPIP_DHCP_PARAM_REQUEST_IP_ADDRESS;
   1c62a:	2232      	movs	r2, #50	; 0x32
   1c62c:	701a      	strb	r2, [r3, #0]
            pReqAdd->len = sizeof(pReqAdd->reqIpAddr);
   1c62e:	2204      	movs	r2, #4
   1c630:	705a      	strb	r2, [r3, #1]
            memcpy(pReqAdd->reqIpAddr, pClient->dhcpIPAddress.v, sizeof(pReqAdd->reqIpAddr));
   1c632:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   1c634:	f8c3 2002 	str.w	r2, [r3, #2]
            return sizeof(*pReqAdd);
   1c638:	2006      	movs	r0, #6
}
   1c63a:	bd70      	pop	{r4, r5, r6, pc}
    return 0;
   1c63c:	2000      	movs	r0, #0
   1c63e:	e7fc      	b.n	1c63a <_DHCPOptionWriteIPRequest+0x3e>
        return -1;
   1c640:	f04f 30ff 	mov.w	r0, #4294967295
   1c644:	e7f9      	b.n	1c63a <_DHCPOptionWriteIPRequest+0x3e>
   1c646:	bf00      	nop
   1c648:	2000e408 	.word	0x2000e408

Disassembly of section .text.TCPIP_DHCP_Renew%532:

0001c64c <TCPIP_DHCP_Renew>:
   1c64c:	b170      	cbz	r0, 1c66c <TCPIP_DHCP_Renew+0x20>
{
   1c64e:	b538      	push	{r3, r4, r5, lr}
   1c650:	4604      	mov	r4, r0
   1c652:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1c656:	f012 0f40 	tst.w	r2, #64	; 0x40
   1c65a:	d10b      	bne.n	1c674 <TCPIP_DHCP_Renew+0x28>
        return false;
   1c65c:	2000      	movs	r0, #0
}
   1c65e:	bd38      	pop	{r3, r4, r5, pc}
        _DHCPEnable(pNetIf, opType);
   1c660:	2103      	movs	r1, #3
   1c662:	4620      	mov	r0, r4
   1c664:	f7fb fdd8 	bl	18218 <_DHCPEnable>
        return true;
   1c668:	2001      	movs	r0, #1
   1c66a:	e7f8      	b.n	1c65e <TCPIP_DHCP_Renew+0x12>
        return false;
   1c66c:	2000      	movs	r0, #0
}
   1c66e:	4770      	bx	lr
        return false;
   1c670:	2000      	movs	r0, #0
    return _DHCPStartOperation(_TCPIPStackHandleToNetUp(hNet), TCPIP_DHCP_OP_REQ_RENEW, 0);
   1c672:	e7f4      	b.n	1c65e <TCPIP_DHCP_Renew+0x12>
    if(DHCPClients == 0 || pNetIf == 0)
   1c674:	4a08      	ldr	r2, [pc, #32]	; (1c698 <TCPIP_DHCP_Renew+0x4c>)
   1c676:	6815      	ldr	r5, [r2, #0]
   1c678:	2d00      	cmp	r5, #0
   1c67a:	d0f9      	beq.n	1c670 <TCPIP_DHCP_Renew+0x24>
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   1c67c:	4620      	mov	r0, r4
   1c67e:	f005 fb51 	bl	21d24 <TCPIP_STACK_NetIxGet>
            if(pClient->flags.bDHCPEnabled != 0 && pClient->flags.bIsBound != 0)
   1c682:	235c      	movs	r3, #92	; 0x5c
   1c684:	fb03 5000 	mla	r0, r3, r0, r5
   1c688:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   1c68c:	f003 0303 	and.w	r3, r3, #3
   1c690:	2b03      	cmp	r3, #3
   1c692:	d0e5      	beq.n	1c660 <TCPIP_DHCP_Renew+0x14>
    return false;
   1c694:	2000      	movs	r0, #0
   1c696:	e7e2      	b.n	1c65e <TCPIP_DHCP_Renew+0x12>
   1c698:	2000e408 	.word	0x2000e408

Disassembly of section .text.TCPIP_DNS_OAHASH_DeleteEntry%533:

0001c69c <TCPIP_DNS_OAHASH_DeleteEntry>:
{
   1c69c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    pDnsDcpt = pgDnsDcpt;
   1c69e:	4b12      	ldr	r3, [pc, #72]	; (1c6e8 <TCPIP_DNS_OAHASH_DeleteEntry+0x4c>)
   1c6a0:	681e      	ldr	r6, [r3, #0]
    currTime = pDnsDcpt->dnsTime;
   1c6a2:	69f7      	ldr	r7, [r6, #28]
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   1c6a4:	68c3      	ldr	r3, [r0, #12]
   1c6a6:	b1eb      	cbz	r3, 1c6e4 <TCPIP_DNS_OAHASH_DeleteEntry+0x48>
   1c6a8:	4605      	mov	r5, r0
   1c6aa:	2400      	movs	r4, #0
   1c6ac:	e007      	b.n	1c6be <TCPIP_DNS_OAHASH_DeleteEntry+0x22>
            if((currTime - pE->tInsert) >= timeout)
   1c6ae:	6883      	ldr	r3, [r0, #8]
   1c6b0:	1afb      	subs	r3, r7, r3
   1c6b2:	4293      	cmp	r3, r2
   1c6b4:	d215      	bcs.n	1c6e2 <TCPIP_DNS_OAHASH_DeleteEntry+0x46>
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   1c6b6:	3401      	adds	r4, #1
   1c6b8:	68eb      	ldr	r3, [r5, #12]
   1c6ba:	42a3      	cmp	r3, r4
   1c6bc:	d910      	bls.n	1c6e0 <TCPIP_DNS_OAHASH_DeleteEntry+0x44>
        pBkt = TCPIP_OAHASH_EntryGet(pOH, bktIx);       
   1c6be:	4621      	mov	r1, r4
   1c6c0:	4628      	mov	r0, r5
   1c6c2:	f005 f9da 	bl	21a7a <TCPIP_OAHASH_EntryGet>
        if(pBkt->flags.busy != 0 && (pBkt->flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) != 0)
   1c6c6:	7803      	ldrb	r3, [r0, #0]
   1c6c8:	f013 0f01 	tst.w	r3, #1
   1c6cc:	d0f3      	beq.n	1c6b6 <TCPIP_DNS_OAHASH_DeleteEntry+0x1a>
   1c6ce:	8803      	ldrh	r3, [r0, #0]
   1c6d0:	f013 0f80 	tst.w	r3, #128	; 0x80
   1c6d4:	d0ef      	beq.n	1c6b6 <TCPIP_DNS_OAHASH_DeleteEntry+0x1a>
            timeout = (pDnsDcpt->cacheEntryTMO > 0) ? pDnsDcpt->cacheEntryTMO : pE->ipTTL.Val;
   1c6d6:	6972      	ldr	r2, [r6, #20]
   1c6d8:	2a00      	cmp	r2, #0
   1c6da:	d1e8      	bne.n	1c6ae <TCPIP_DNS_OAHASH_DeleteEntry+0x12>
   1c6dc:	6982      	ldr	r2, [r0, #24]
   1c6de:	e7e6      	b.n	1c6ae <TCPIP_DNS_OAHASH_DeleteEntry+0x12>
    return 0;
   1c6e0:	2000      	movs	r0, #0
}
   1c6e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return 0;
   1c6e4:	2000      	movs	r0, #0
   1c6e6:	e7fc      	b.n	1c6e2 <TCPIP_DNS_OAHASH_DeleteEntry+0x46>
   1c6e8:	2000e424 	.word	0x2000e424

Disassembly of section .text.TCPIP_Helper_FormatNetBIOSName%534:

0001c6ec <TCPIP_Helper_FormatNetBIOSName>:

  Returns:
	None
  ***************************************************************************/
void TCPIP_Helper_FormatNetBIOSName(uint8_t Name[])
{
   1c6ec:	b470      	push	{r4, r5, r6}
	uint8_t i;

	Name[15] = '\0';
   1c6ee:	2200      	movs	r2, #0
   1c6f0:	73c2      	strb	r2, [r0, #15]
	i = 0;
	while(i < 15u)
   1c6f2:	1e41      	subs	r1, r0, #1
	{
        Name[i] = toupper(Name[i]);
   1c6f4:	4e10      	ldr	r6, [pc, #64]	; (1c738 <TCPIP_Helper_FormatNetBIOSName+0x4c>)
   1c6f6:	3101      	adds	r1, #1
   1c6f8:	780b      	ldrb	r3, [r1, #0]
   1c6fa:	5d9c      	ldrb	r4, [r3, r6]
   1c6fc:	f004 0403 	and.w	r4, r4, #3
   1c700:	2c02      	cmp	r4, #2
   1c702:	bf08      	it	eq
   1c704:	3b20      	subeq	r3, #32
   1c706:	b2db      	uxtb	r3, r3
   1c708:	700b      	strb	r3, [r1, #0]
		if(Name[i] == '\0')
   1c70a:	b12b      	cbz	r3, 1c718 <TCPIP_Helper_FormatNetBIOSName+0x2c>
			{
				Name[i++] = ' ';
			}
			break;
		}
		i++;
   1c70c:	3201      	adds	r2, #1
   1c70e:	b2d2      	uxtb	r2, r2
	while(i < 15u)
   1c710:	2a0f      	cmp	r2, #15
   1c712:	d1f0      	bne.n	1c6f6 <TCPIP_Helper_FormatNetBIOSName+0xa>
	}
}
   1c714:	bc70      	pop	{r4, r5, r6}
   1c716:	4770      	bx	lr
			while(i < 15u)
   1c718:	2a0e      	cmp	r2, #14
   1c71a:	d8fb      	bhi.n	1c714 <TCPIP_Helper_FormatNetBIOSName+0x28>
   1c71c:	1883      	adds	r3, r0, r2
   1c71e:	3001      	adds	r0, #1
   1c720:	4410      	add	r0, r2
   1c722:	f1c2 020e 	rsb	r2, r2, #14
   1c726:	fa50 f282 	uxtab	r2, r0, r2
				Name[i++] = ' ';
   1c72a:	2120      	movs	r1, #32
   1c72c:	f803 1b01 	strb.w	r1, [r3], #1
			while(i < 15u)
   1c730:	4293      	cmp	r3, r2
   1c732:	d1fb      	bne.n	1c72c <TCPIP_Helper_FormatNetBIOSName+0x40>
   1c734:	e7ee      	b.n	1c714 <TCPIP_Helper_FormatNetBIOSName+0x28>
   1c736:	bf00      	nop
   1c738:	00014195 	.word	0x00014195

Disassembly of section .text.SYS_CONSOLE_Status%535:

0001c73c <SYS_CONSOLE_Status>:
{
   1c73c:	b508      	push	{r3, lr}
    if (index >= SYS_CONSOLE_DEVICE_MAX_INSTANCES)
   1c73e:	b283      	uxth	r3, r0
   1c740:	b9cb      	cbnz	r3, 1c776 <SYS_CONSOLE_Status+0x3a>
    pConsoleObj = &consoleDeviceInstance[index];
   1c742:	4618      	mov	r0, r3
    if (pConsoleObj->devDesc == NULL)
   1c744:	eb03 0243 	add.w	r2, r3, r3, lsl #1
   1c748:	4b0f      	ldr	r3, [pc, #60]	; (1c788 <SYS_CONSOLE_Status+0x4c>)
   1c74a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   1c74e:	685a      	ldr	r2, [r3, #4]
   1c750:	b1a2      	cbz	r2, 1c77c <SYS_CONSOLE_Status+0x40>
    status = pConsoleObj->devDesc->status(pConsoleObj->devIndex);
   1c752:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   1c756:	4b0c      	ldr	r3, [pc, #48]	; (1c788 <SYS_CONSOLE_Status+0x4c>)
   1c758:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1c75c:	6a53      	ldr	r3, [r2, #36]	; 0x24
   1c75e:	6880      	ldr	r0, [r0, #8]
   1c760:	4798      	blx	r3
    switch (status)
   1c762:	2801      	cmp	r0, #1
   1c764:	d00c      	beq.n	1c780 <SYS_CONSOLE_Status+0x44>
   1c766:	b243      	sxtb	r3, r0
   1c768:	b163      	cbz	r3, 1c784 <SYS_CONSOLE_Status+0x48>
    SYS_STATUS ret = SYS_STATUS_ERROR;
   1c76a:	2802      	cmp	r0, #2
   1c76c:	bf0c      	ite	eq
   1c76e:	2001      	moveq	r0, #1
   1c770:	f04f 30ff 	movne.w	r0, #4294967295
}
   1c774:	bd08      	pop	{r3, pc}
        return SYS_STATUS_ERROR;
   1c776:	f04f 30ff 	mov.w	r0, #4294967295
   1c77a:	e7fb      	b.n	1c774 <SYS_CONSOLE_Status+0x38>
        return SYS_STATUS_UNINITIALIZED;
   1c77c:	2000      	movs	r0, #0
   1c77e:	e7f9      	b.n	1c774 <SYS_CONSOLE_Status+0x38>
            ret = SYS_STATUS_READY;
   1c780:	2002      	movs	r0, #2
   1c782:	e7f7      	b.n	1c774 <SYS_CONSOLE_Status+0x38>
            ret = SYS_STATUS_UNINITIALIZED;
   1c784:	2000      	movs	r0, #0
   1c786:	e7f5      	b.n	1c774 <SYS_CONSOLE_Status+0x38>
   1c788:	2000e340 	.word	0x2000e340

Disassembly of section .text._raise_r%536:

0001c78c <_raise_r>:
   1c78c:	291f      	cmp	r1, #31
   1c78e:	b538      	push	{r3, r4, r5, lr}
   1c790:	4604      	mov	r4, r0
   1c792:	460d      	mov	r5, r1
   1c794:	d904      	bls.n	1c7a0 <_raise_r+0x14>
   1c796:	2316      	movs	r3, #22
   1c798:	6003      	str	r3, [r0, #0]
   1c79a:	f04f 30ff 	mov.w	r0, #4294967295
   1c79e:	bd38      	pop	{r3, r4, r5, pc}
   1c7a0:	6c42      	ldr	r2, [r0, #68]	; 0x44
   1c7a2:	b112      	cbz	r2, 1c7aa <_raise_r+0x1e>
   1c7a4:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   1c7a8:	b94b      	cbnz	r3, 1c7be <_raise_r+0x32>
   1c7aa:	4620      	mov	r0, r4
   1c7ac:	f005 fd62 	bl	22274 <_getpid_r>
   1c7b0:	462a      	mov	r2, r5
   1c7b2:	4601      	mov	r1, r0
   1c7b4:	4620      	mov	r0, r4
   1c7b6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1c7ba:	f003 bf87 	b.w	206cc <_kill_r>
   1c7be:	2b01      	cmp	r3, #1
   1c7c0:	d00a      	beq.n	1c7d8 <_raise_r+0x4c>
   1c7c2:	1c5c      	adds	r4, r3, #1
   1c7c4:	d103      	bne.n	1c7ce <_raise_r+0x42>
   1c7c6:	2316      	movs	r3, #22
   1c7c8:	6003      	str	r3, [r0, #0]
   1c7ca:	2001      	movs	r0, #1
   1c7cc:	e7e7      	b.n	1c79e <_raise_r+0x12>
   1c7ce:	2400      	movs	r4, #0
   1c7d0:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
   1c7d4:	4608      	mov	r0, r1
   1c7d6:	4798      	blx	r3
   1c7d8:	2000      	movs	r0, #0
   1c7da:	e7e0      	b.n	1c79e <_raise_r+0x12>

Disassembly of section .text%537:

0001c7dc <__aeabi_d2iz>:
   1c7dc:	ea4f 0241 	mov.w	r2, r1, lsl #1
   1c7e0:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   1c7e4:	d215      	bcs.n	1c812 <__aeabi_d2iz+0x36>
   1c7e6:	d511      	bpl.n	1c80c <__aeabi_d2iz+0x30>
   1c7e8:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   1c7ec:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   1c7f0:	d912      	bls.n	1c818 <__aeabi_d2iz+0x3c>
   1c7f2:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   1c7f6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1c7fa:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   1c7fe:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   1c802:	fa23 f002 	lsr.w	r0, r3, r2
   1c806:	bf18      	it	ne
   1c808:	4240      	negne	r0, r0
   1c80a:	4770      	bx	lr
   1c80c:	f04f 0000 	mov.w	r0, #0
   1c810:	4770      	bx	lr
   1c812:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   1c816:	d105      	bne.n	1c824 <__aeabi_d2iz+0x48>
   1c818:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
   1c81c:	bf08      	it	eq
   1c81e:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
   1c822:	4770      	bx	lr
   1c824:	f04f 0000 	mov.w	r0, #0
   1c828:	4770      	bx	lr
   1c82a:	bf00      	nop

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase7%538:

0001c82c <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase7>:
{
   1c82c:	b508      	push	{r3, lr}
    openFlags = hClientObj->hDriver->openFlags;
   1c82e:	68c1      	ldr	r1, [r0, #12]
   1c830:	898b      	ldrh	r3, [r1, #12]
    matchCpbl = hClientObj->operReg[1];
   1c832:	8c82      	ldrh	r2, [r0, #36]	; 0x24
    openFlags &= ~(TCPIP_ETH_OPEN_AUTO | TCPIP_ETH_OPEN_FDUPLEX | TCPIP_ETH_OPEN_HDUPLEX | TCPIP_ETH_OPEN_100|TCPIP_ETH_OPEN_10);
   1c834:	f023 031f 	bic.w	r3, r3, #31
   1c838:	b29b      	uxth	r3, r3
    if(matchCpbl & _BMSTAT_AN_ABLE_MASK)
   1c83a:	f012 0f08 	tst.w	r2, #8
        openFlags |= TCPIP_ETH_OPEN_AUTO;
   1c83e:	bf18      	it	ne
   1c840:	f043 0301 	orrne.w	r3, r3, #1
    if(matchCpbl & (_BMSTAT_BASE100TX_HDX_MASK | _BMSTAT_BASE100TX_FDX_MASK))   // set 100Mbps request/capability
   1c844:	f412 4fc0 	tst.w	r2, #24576	; 0x6000
        openFlags |= TCPIP_ETH_OPEN_100;
   1c848:	bf18      	it	ne
   1c84a:	f043 0308 	orrne.w	r3, r3, #8
    if(matchCpbl & (_BMSTAT_BASE10T_HDX_MASK | _BMSTAT_BASE10T_FDX_MASK))   // set 10Mbps request/capability
   1c84e:	f412 5fc0 	tst.w	r2, #6144	; 0x1800
        openFlags |= TCPIP_ETH_OPEN_10;
   1c852:	bf18      	it	ne
   1c854:	f043 0310 	orrne.w	r3, r3, #16
    if(matchCpbl & (_BMSTAT_BASE10T_FDX_MASK | _BMSTAT_BASE100TX_FDX_MASK))
   1c858:	f412 4fa0 	tst.w	r2, #20480	; 0x5000
        openFlags |= TCPIP_ETH_OPEN_FDUPLEX;
   1c85c:	bf18      	it	ne
   1c85e:	f043 0302 	orrne.w	r3, r3, #2
    if(matchCpbl & (_BMSTAT_BASE10T_HDX_MASK | _BMSTAT_BASE100TX_HDX_MASK))
   1c862:	f412 5f20 	tst.w	r2, #10240	; 0x2800
        openFlags |= TCPIP_ETH_OPEN_HDUPLEX;
   1c866:	bf18      	it	ne
   1c868:	f043 0304 	orrne.w	r3, r3, #4
    hClientObj->hDriver->openFlags = openFlags;
   1c86c:	818b      	strh	r3, [r1, #12]
    *pSetUpFlags = openFlags;
   1c86e:	6b02      	ldr	r2, [r0, #48]	; 0x30
   1c870:	8013      	strh	r3, [r2, #0]
    _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OK);
   1c872:	2100      	movs	r1, #0
   1c874:	f003 fa5a 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
} 
   1c878:	bd08      	pop	{r3, pc}

Disassembly of section .text._DRV_MIIM_GetClientAndLock%539:

0001c87a <_DRV_MIIM_GetClientAndLock>:
    if(pClient != 0)
   1c87a:	b1e8      	cbz	r0, 1c8b8 <_DRV_MIIM_GetClientAndLock+0x3e>
{
   1c87c:	b510      	push	{r4, lr}
   1c87e:	4604      	mov	r4, r0
        if(pClient->clientInUse != 0 && pClient->cliStatus == DRV_MIIM_CLIENT_STATUS_READY)
   1c880:	8802      	ldrh	r2, [r0, #0]
   1c882:	b1da      	cbz	r2, 1c8bc <_DRV_MIIM_GetClientAndLock+0x42>
   1c884:	f990 200c 	ldrsb.w	r2, [r0, #12]
   1c888:	2a02      	cmp	r2, #2
   1c88a:	d119      	bne.n	1c8c0 <_DRV_MIIM_GetClientAndLock+0x46>
            if(lock)
   1c88c:	b969      	cbnz	r1, 1c8aa <_DRV_MIIM_GetClientAndLock+0x30>
                pMiimObj = _DRV_MIIM_GetObject((SYS_MODULE_OBJ)pClient->parentObj);
   1c88e:	6840      	ldr	r0, [r0, #4]
    if(pMiimObj != 0)
   1c890:	b1b8      	cbz	r0, 1c8c2 <_DRV_MIIM_GetClientAndLock+0x48>
        if(pMiimObj->objStatus == SYS_STATUS_READY && (pMiimObj->objFlags & DRV_MIIM_OBJ_FLAG_IN_USE) != 0)
   1c892:	f990 2008 	ldrsb.w	r2, [r0, #8]
   1c896:	2a02      	cmp	r2, #2
   1c898:	d114      	bne.n	1c8c4 <_DRV_MIIM_GetClientAndLock+0x4a>
   1c89a:	8882      	ldrh	r2, [r0, #4]
   1c89c:	f002 0201 	and.w	r2, r2, #1
                return pClient;
   1c8a0:	2a00      	cmp	r2, #0
   1c8a2:	bf14      	ite	ne
   1c8a4:	4620      	movne	r0, r4
   1c8a6:	2000      	moveq	r0, #0
   1c8a8:	e00b      	b.n	1c8c2 <_DRV_MIIM_GetClientAndLock+0x48>
                pMiimObj = _DRV_MIIM_GetObjectAndLock((SYS_MODULE_OBJ)pClient->parentObj);
   1c8aa:	6840      	ldr	r0, [r0, #4]
   1c8ac:	f002 fe5b 	bl	1f566 <_DRV_MIIM_GetObjectAndLock>
            if(pMiimObj != 0)
   1c8b0:	2800      	cmp	r0, #0
                return pClient;
   1c8b2:	bf18      	it	ne
   1c8b4:	4620      	movne	r0, r4
   1c8b6:	e004      	b.n	1c8c2 <_DRV_MIIM_GetClientAndLock+0x48>
    return 0;
   1c8b8:	2000      	movs	r0, #0
}
   1c8ba:	4770      	bx	lr
    return 0;
   1c8bc:	2000      	movs	r0, #0
   1c8be:	e000      	b.n	1c8c2 <_DRV_MIIM_GetClientAndLock+0x48>
   1c8c0:	2000      	movs	r0, #0
}
   1c8c2:	bd10      	pop	{r4, pc}
    return 0;
   1c8c4:	2000      	movs	r0, #0
   1c8c6:	e7fc      	b.n	1c8c2 <_DRV_MIIM_GetClientAndLock+0x48>

Disassembly of section .text.TCPIP_IPV4_SelectDestInterface%540:

0001c8c8 <TCPIP_IPV4_SelectDestInterface>:
    if(pDestAddress == 0 || pDestAddress->Val == 0)
   1c8c8:	b310      	cbz	r0, 1c910 <TCPIP_IPV4_SelectDestInterface+0x48>
{
   1c8ca:	b570      	push	{r4, r5, r6, lr}
   1c8cc:	4605      	mov	r5, r0
    if(pDestAddress == 0 || pDestAddress->Val == 0)
   1c8ce:	6803      	ldr	r3, [r0, #0]
   1c8d0:	b1fb      	cbz	r3, 1c912 <TCPIP_IPV4_SelectDestInterface+0x4a>
    if((avlblInterfaces = TCPIP_STACK_NumberOfNetworksGet()) > 1)
   1c8d2:	f005 fb9f 	bl	22014 <TCPIP_STACK_NumberOfNetworksGet>
   1c8d6:	4606      	mov	r6, r0
   1c8d8:	2801      	cmp	r0, #1
   1c8da:	dd13      	ble.n	1c904 <TCPIP_IPV4_SelectDestInterface+0x3c>
        for(netIx = 0; netIx < avlblInterfaces; netIx++)
   1c8dc:	2400      	movs	r4, #0
   1c8de:	e002      	b.n	1c8e6 <TCPIP_IPV4_SelectDestInterface+0x1e>
   1c8e0:	3401      	adds	r4, #1
   1c8e2:	42a6      	cmp	r6, r4
   1c8e4:	d00e      	beq.n	1c904 <TCPIP_IPV4_SelectDestInterface+0x3c>
            pIf = _TCPIPStackHandleToNetLinked(TCPIP_STACK_IndexToNet(netIx));
   1c8e6:	4620      	mov	r0, r4
   1c8e8:	f003 fb38 	bl	1ff5c <TCPIP_STACK_IndexToNet>
   1c8ec:	f004 f910 	bl	20b10 <_TCPIPStackHandleToNetLinked>
            if(pIf)
   1c8f0:	4602      	mov	r2, r0
   1c8f2:	2800      	cmp	r0, #0
   1c8f4:	d0f4      	beq.n	1c8e0 <TCPIP_IPV4_SelectDestInterface+0x18>
                if((ifAdd & ifMask) == (pDestAddress->Val & ifMask))
   1c8f6:	682b      	ldr	r3, [r5, #0]
   1c8f8:	6841      	ldr	r1, [r0, #4]
   1c8fa:	404b      	eors	r3, r1
   1c8fc:	6881      	ldr	r1, [r0, #8]
   1c8fe:	420b      	tst	r3, r1
   1c900:	d1ee      	bne.n	1c8e0 <TCPIP_IPV4_SelectDestInterface+0x18>
   1c902:	e003      	b.n	1c90c <TCPIP_IPV4_SelectDestInterface+0x44>
    return _TCPIPStackAnyNetLinked(true);
   1c904:	2001      	movs	r0, #1
   1c906:	f7ff fcdd 	bl	1c2c4 <_TCPIPStackAnyNetLinked>
   1c90a:	4602      	mov	r2, r0
}
   1c90c:	4610      	mov	r0, r2
   1c90e:	bd70      	pop	{r4, r5, r6, pc}
   1c910:	4770      	bx	lr
        return 0;
   1c912:	2200      	movs	r2, #0
   1c914:	e7fa      	b.n	1c90c <TCPIP_IPV4_SelectDestInterface+0x44>

Disassembly of section .text.TCPIP_UDP_PutIsReady%541:

0001c916 <TCPIP_UDP_PutIsReady>:
{
   1c916:	b510      	push	{r4, lr}
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1c918:	f003 fb84 	bl	20024 <_UDPSocketDcpt>
    if(pSkt == 0)
   1c91c:	b300      	cbz	r0, 1c960 <TCPIP_UDP_PutIsReady+0x4a>
   1c91e:	4604      	mov	r4, r0
    if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   1c920:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
   1c922:	2b01      	cmp	r3, #1
    return 0;   // can happen if it is a server socket and opened with IP_ADDRESS_TYPE_ANY
   1c924:	bf18      	it	ne
   1c926:	2000      	movne	r0, #0
    if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   1c928:	d000      	beq.n	1c92c <TCPIP_UDP_PutIsReady+0x16>
}
   1c92a:	bd10      	pop	{r4, pc}
    void* pPkt = _TxSktGetLockedV4Pkt(pSkt, true);
   1c92c:	2101      	movs	r1, #1
   1c92e:	f002 ff17 	bl	1f760 <_TxSktGetLockedV4Pkt>
    if(pPkt == 0)
   1c932:	b138      	cbz	r0, 1c944 <TCPIP_UDP_PutIsReady+0x2e>
    if(pSkt->flags.txSplitAlloc == 0)
   1c934:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
   1c938:	f013 0f02 	tst.w	r3, #2
   1c93c:	d00b      	beq.n	1c956 <TCPIP_UDP_PutIsReady+0x40>
    return 1514 - sizeof(TCPIP_MAC_ETHERNET_HEADER) - sizeof(IPV4_HEADER) - sizeof(UDP_HEADER);
   1c93e:	f44f 60b8 	mov.w	r0, #1472	; 0x5c0
   1c942:	e7f2      	b.n	1c92a <TCPIP_UDP_PutIsReady+0x14>
        if(_UDPv4AllocateSktTxBuffer(pSkt, IP_ADDRESS_TYPE_IPV4, true) == 0)
   1c944:	2201      	movs	r2, #1
   1c946:	4611      	mov	r1, r2
   1c948:	4620      	mov	r0, r4
   1c94a:	f7fb f8b3 	bl	17ab4 <_UDPv4AllocateSktTxBuffer>
   1c94e:	2800      	cmp	r0, #0
   1c950:	d1f0      	bne.n	1c934 <TCPIP_UDP_PutIsReady+0x1e>
            return 0;
   1c952:	2000      	movs	r0, #0
   1c954:	e7e9      	b.n	1c92a <TCPIP_UDP_PutIsReady+0x14>
        return pSkt->txEnd - pSkt->txWrite;
   1c956:	6860      	ldr	r0, [r4, #4]
   1c958:	68a3      	ldr	r3, [r4, #8]
   1c95a:	1ac0      	subs	r0, r0, r3
   1c95c:	b280      	uxth	r0, r0
   1c95e:	e7e4      	b.n	1c92a <TCPIP_UDP_PutIsReady+0x14>
        return 0;
   1c960:	2000      	movs	r0, #0
   1c962:	e7e2      	b.n	1c92a <TCPIP_UDP_PutIsReady+0x14>

Disassembly of section .text._DRV_ETHPHY_LinkStatPhaseRead%542:

0001c964 <_DRV_ETHPHY_LinkStatPhaseRead>:
{
   1c964:	b510      	push	{r4, lr}
   1c966:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1c968:	f003 ff1c 	bl	207a4 <_DRV_PHY_SMITransfer_Wait>
   1c96c:	b1a0      	cbz	r0, 1c998 <_DRV_ETHPHY_LinkStatPhaseRead+0x34>
    if( phyStat.LINK_STAT != 0 || hClientObj->operReg[0] == 0)
   1c96e:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
   1c972:	f013 0f04 	tst.w	r3, #4
   1c976:	d101      	bne.n	1c97c <_DRV_ETHPHY_LinkStatPhaseRead+0x18>
   1c978:	8c62      	ldrh	r2, [r4, #34]	; 0x22
   1c97a:	b972      	cbnz	r2, 1c99a <_DRV_ETHPHY_LinkStatPhaseRead+0x36>
        DRV_ETHPHY_LINK_STATUS* pLinkStat = (DRV_ETHPHY_LINK_STATUS*)hClientObj->operParam;
   1c97c:	6b22      	ldr	r2, [r4, #48]	; 0x30
        if(pLinkStat)
   1c97e:	b13a      	cbz	r2, 1c990 <_DRV_ETHPHY_LinkStatPhaseRead+0x2c>
    linkStat = (phyStat.LINK_STAT)?DRV_ETHPHY_LINK_ST_UP:DRV_ETHPHY_LINK_ST_DOWN;
   1c980:	f3c3 0180 	ubfx	r1, r3, #2, #1
    if(phyStat.REM_FAULT)
   1c984:	f013 0f10 	tst.w	r3, #16
        linkStat|=DRV_ETHPHY_LINK_ST_REMOTE_FAULT;
   1c988:	bf18      	it	ne
   1c98a:	f041 0104 	orrne.w	r1, r1, #4
            *pLinkStat = _Phy2LinkStat(phyStat);
   1c98e:	8011      	strh	r1, [r2, #0]
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OK);
   1c990:	2100      	movs	r1, #0
   1c992:	4620      	mov	r0, r4
   1c994:	f003 f9ca 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
}
   1c998:	bd10      	pop	{r4, pc}
        if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   1c99a:	2101      	movs	r1, #1
   1c99c:	4620      	mov	r0, r4
   1c99e:	f002 faad 	bl	1eefc <_DRV_PHY_SMIReadStart>
   1c9a2:	2800      	cmp	r0, #0
   1c9a4:	d0f8      	beq.n	1c998 <_DRV_ETHPHY_LinkStatPhaseRead+0x34>
    hClientObj->operPhase = operPhase;
   1c9a6:	2302      	movs	r3, #2
   1c9a8:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1c9aa:	2300      	movs	r3, #0
   1c9ac:	8423      	strh	r3, [r4, #32]
   1c9ae:	e7f3      	b.n	1c998 <_DRV_ETHPHY_LinkStatPhaseRead+0x34>

Disassembly of section .text._TcpSocketKill%543:

0001c9b0 <_TcpSocketKill>:
{
   1c9b0:	b538      	push	{r3, r4, r5, lr}
   1c9b2:	4604      	mov	r4, r0
    pSkt->smState = newState;
   1c9b4:	230c      	movs	r3, #12
   1c9b6:	f880 306e 	strb.w	r3, [r0, #110]	; 0x6e
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1c9ba:	2000      	movs	r0, #0
   1c9bc:	f004 fdfe 	bl	215bc <OSAL_CRIT_Enter>
    TCBStubs[pSkt->sktIx] = 0;
   1c9c0:	f9b4 1034 	ldrsh.w	r1, [r4, #52]	; 0x34
   1c9c4:	4b0b      	ldr	r3, [pc, #44]	; (1c9f4 <_TcpSocketKill+0x44>)
   1c9c6:	681a      	ldr	r2, [r3, #0]
   1c9c8:	2300      	movs	r3, #0
   1c9ca:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   1c9ce:	4601      	mov	r1, r0
   1c9d0:	4618      	mov	r0, r3
   1c9d2:	f004 ff22 	bl	2181a <OSAL_CRIT_Leave>
    TCPIP_HEAP_Free(tcpHeapH, (void*)pSkt->rxStart);
   1c9d6:	4d08      	ldr	r5, [pc, #32]	; (1c9f8 <_TcpSocketKill+0x48>)
   1c9d8:	6828      	ldr	r0, [r5, #0]
   1c9da:	68c3      	ldr	r3, [r0, #12]
   1c9dc:	6961      	ldr	r1, [r4, #20]
   1c9de:	4798      	blx	r3
    TCPIP_HEAP_Free(tcpHeapH, (void*)pSkt->txStart);
   1c9e0:	6828      	ldr	r0, [r5, #0]
   1c9e2:	68c3      	ldr	r3, [r0, #12]
   1c9e4:	6821      	ldr	r1, [r4, #0]
   1c9e6:	4798      	blx	r3
    TCPIP_HEAP_Free(tcpHeapH, pSkt);
   1c9e8:	6828      	ldr	r0, [r5, #0]
   1c9ea:	68c3      	ldr	r3, [r0, #12]
   1c9ec:	4621      	mov	r1, r4
   1c9ee:	4798      	blx	r3
}
   1c9f0:	bd38      	pop	{r3, r4, r5, pc}
   1c9f2:	bf00      	nop
   1c9f4:	2000e38c 	.word	0x2000e38c
   1c9f8:	2000e394 	.word	0x2000e394

Disassembly of section .text.ResetIperfCounters%544:

0001c9fc <ResetIperfCounters>:
    pIState->mMSS = IPERF_TCP_MSS;
   1c9fc:	f240 53b4 	movw	r3, #1460	; 0x5b4
   1ca00:	f8a0 30d2 	strh.w	r3, [r0, #210]	; 0xd2
    pIState->mDatagramSize = 1470; // -l: default 1470 bytes. UDP datagram size.
   1ca04:	f240 53be 	movw	r3, #1470	; 0x5be
   1ca08:	60c3      	str	r3, [r0, #12]
    pIState->totalLen = 0;
   1ca0a:	2200      	movs	r2, #0
   1ca0c:	2300      	movs	r3, #0
   1ca0e:	e9c0 2308 	strd	r2, r3, [r0, #32]
    pIState->pktId = 0;
   1ca12:	6283      	str	r3, [r0, #40]	; 0x28
    pIState->lastPktId = 0;
   1ca14:	62c3      	str	r3, [r0, #44]	; 0x2c
    pIState->errorCount = 0;
   1ca16:	6303      	str	r3, [r0, #48]	; 0x30
    pIState->outofOrder = 0;
   1ca18:	6343      	str	r3, [r0, #52]	; 0x34
    pIState->pktCount = 0;
   1ca1a:	f8c0 3094 	str.w	r3, [r0, #148]	; 0x94
    pIState->statusReported = 0;
   1ca1e:	f880 30cd 	strb.w	r3, [r0, #205]	; 0xcd
    pIState->startTime = 0;
   1ca22:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
    pIState->stopTime = 0;
   1ca26:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
    pIState->lastCheckPktCount = 0;
   1ca2a:	f8c0 3098 	str.w	r3, [r0, #152]	; 0x98
    pIState->lastCheckPktId = 0;
   1ca2e:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
    pIState->lastCheckErrorCount = 0;
   1ca32:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
    pIState->lastCheckTotalLen = 0;
   1ca36:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
    pIState->lastCheckTime = 0;
   1ca3a:	f8c0 30a8 	str.w	r3, [r0, #168]	; 0xa8
    pIState->isLastTransmit = false;
   1ca3e:	f880 30d0 	strb.w	r3, [r0, #208]	; 0xd0
    pIState->txWaitTick = 0;
   1ca42:	f8c0 30b4 	str.w	r3, [r0, #180]	; 0xb4
}
   1ca46:	4770      	bx	lr

Disassembly of section .text._DHCPSetRunFail%545:

0001ca48 <_DHCPSetRunFail>:
    pClient->smState = newState;
   1ca48:	f8a0 1056 	strh.w	r1, [r0, #86]	; 0x56
    pClient->dhcpOp = TCPIP_DHCP_OPER_INIT;       // failure forces a brand new lease acquisition
   1ca4c:	2301      	movs	r3, #1
   1ca4e:	f8a0 3054 	strh.w	r3, [r0, #84]	; 0x54
    if(expBackoff)
   1ca52:	b142      	cbz	r2, 1ca66 <_DHCPSetRunFail+0x1e>
        pClient->dhcpTmo <<= 1;
   1ca54:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
   1ca58:	005b      	lsls	r3, r3, #1
   1ca5a:	b29b      	uxth	r3, r3
        if(pClient->dhcpTmo > TCPIP_DHCP_EXP_BACKOFF_LIMIT)
   1ca5c:	2b40      	cmp	r3, #64	; 0x40
            pClient->dhcpTmo = TCPIP_DHCP_EXP_BACKOFF_LIMIT;
   1ca5e:	bf88      	it	hi
   1ca60:	2340      	movhi	r3, #64	; 0x40
   1ca62:	f8a0 304c 	strh.w	r3, [r0, #76]	; 0x4c
    if(pClient->flags.bReportFail)
   1ca66:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   1ca6a:	f013 0f20 	tst.w	r3, #32
   1ca6e:	d008      	beq.n	1ca82 <_DHCPSetRunFail+0x3a>
    pClient->flags.bReportFail = 1;
   1ca70:	f043 0320 	orr.w	r3, r3, #32
   1ca74:	f880 3058 	strb.w	r3, [r0, #88]	; 0x58
    if(resetTmo || pClient->tOpStart == 0)
   1ca78:	6a03      	ldr	r3, [r0, #32]
   1ca7a:	b913      	cbnz	r3, 1ca82 <_DHCPSetRunFail+0x3a>
    return dhcpSecondCount;
   1ca7c:	4b04      	ldr	r3, [pc, #16]	; (1ca90 <_DHCPSetRunFail+0x48>)
        pClient->tOpStart = _DHCPSecondCountGet();
   1ca7e:	681b      	ldr	r3, [r3, #0]
   1ca80:	6203      	str	r3, [r0, #32]
    pClient->flags.bRetry = true;
   1ca82:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   1ca86:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   1ca8a:	f880 3058 	strb.w	r3, [r0, #88]	; 0x58
}
   1ca8e:	4770      	bx	lr
   1ca90:	2000e418 	.word	0x2000e418

Disassembly of section .text.TCPIP_Helper_IPAddressToString%546:

0001ca94 <TCPIP_Helper_IPAddressToString>:
    if(ipAdd && buff)
   1ca94:	b1e8      	cbz	r0, 1cad2 <TCPIP_Helper_IPAddressToString+0x3e>
   1ca96:	b1f1      	cbz	r1, 1cad6 <TCPIP_Helper_IPAddressToString+0x42>
{
   1ca98:	b530      	push	{r4, r5, lr}
   1ca9a:	b089      	sub	sp, #36	; 0x24
   1ca9c:	4615      	mov	r5, r2
   1ca9e:	460c      	mov	r4, r1
        sprintf(tempBuff, "%d.%d.%d.%d", ipAdd->v[0], ipAdd->v[1], ipAdd->v[2], ipAdd->v[3]);
   1caa0:	78c3      	ldrb	r3, [r0, #3]
   1caa2:	9301      	str	r3, [sp, #4]
   1caa4:	7883      	ldrb	r3, [r0, #2]
   1caa6:	9300      	str	r3, [sp, #0]
   1caa8:	7843      	ldrb	r3, [r0, #1]
   1caaa:	7802      	ldrb	r2, [r0, #0]
   1caac:	490b      	ldr	r1, [pc, #44]	; (1cadc <TCPIP_Helper_IPAddressToString+0x48>)
   1caae:	a803      	add	r0, sp, #12
   1cab0:	f000 fe7a 	bl	1d7a8 <siprintf>
        len = strlen(tempBuff) + 1;
   1cab4:	a803      	add	r0, sp, #12
   1cab6:	f005 f8f9 	bl	21cac <strlen>
   1caba:	3001      	adds	r0, #1
        if(buffSize >= len)
   1cabc:	42a8      	cmp	r0, r5
   1cabe:	d902      	bls.n	1cac6 <TCPIP_Helper_IPAddressToString+0x32>
    return false; 
   1cac0:	2000      	movs	r0, #0
}
   1cac2:	b009      	add	sp, #36	; 0x24
   1cac4:	bd30      	pop	{r4, r5, pc}
            strcpy(buff, tempBuff);
   1cac6:	a903      	add	r1, sp, #12
   1cac8:	4620      	mov	r0, r4
   1caca:	f005 f8e7 	bl	21c9c <strcpy>
            return true;
   1cace:	2001      	movs	r0, #1
   1cad0:	e7f7      	b.n	1cac2 <TCPIP_Helper_IPAddressToString+0x2e>
    return false; 
   1cad2:	2000      	movs	r0, #0
   1cad4:	4770      	bx	lr
   1cad6:	2000      	movs	r0, #0
}
   1cad8:	4770      	bx	lr
   1cada:	bf00      	nop
   1cadc:	0001db74 	.word	0x0001db74

Disassembly of section .text._TCPIP_MacEventCB%547:

0001cae0 <_TCPIP_MacEventCB>:
{
   1cae0:	b508      	push	{r3, lr}
    pSigEntry = ((event & (TCPIP_STACK_MAC_ACTIVE_RX_EVENTS)) != 0) ? _TCPIPModuleToSignalEntry(TCPIP_MODULE_MANAGER) : 0;
   1cae2:	f010 0f16 	tst.w	r0, #22
   1cae6:	d109      	bne.n	1cafc <_TCPIP_MacEventCB+0x1c>
    pNetIf->activeEvents |= event;
   1cae8:	f8b1 305a 	ldrh.w	r3, [r1, #90]	; 0x5a
   1caec:	4318      	orrs	r0, r3
   1caee:	f8a1 005a 	strh.w	r0, [r1, #90]	; 0x5a
    totTcpipEventsCnt++;
   1caf2:	4a0c      	ldr	r2, [pc, #48]	; (1cb24 <_TCPIP_MacEventCB+0x44>)
   1caf4:	6813      	ldr	r3, [r2, #0]
   1caf6:	3301      	adds	r3, #1
   1caf8:	6013      	str	r3, [r2, #0]
    if(pSigEntry)
   1cafa:	e012      	b.n	1cb22 <_TCPIP_MacEventCB+0x42>
    pNetIf->activeEvents |= event;
   1cafc:	f8b1 305a 	ldrh.w	r3, [r1, #90]	; 0x5a
   1cb00:	4318      	orrs	r0, r3
   1cb02:	f8a1 005a 	strh.w	r0, [r1, #90]	; 0x5a
    totTcpipEventsCnt++;
   1cb06:	4a07      	ldr	r2, [pc, #28]	; (1cb24 <_TCPIP_MacEventCB+0x44>)
   1cb08:	6813      	ldr	r3, [r2, #0]
   1cb0a:	3301      	adds	r3, #1
   1cb0c:	6013      	str	r3, [r2, #0]
        pSigEntry->signalVal |= TCPIP_MODULE_SIGNAL_RX_PENDING;
   1cb0e:	4806      	ldr	r0, [pc, #24]	; (1cb28 <_TCPIP_MacEventCB+0x48>)
   1cb10:	8b03      	ldrh	r3, [r0, #24]
   1cb12:	f043 0301 	orr.w	r3, r3, #1
   1cb16:	8303      	strh	r3, [r0, #24]
        _TCPIPSignalEntryNotify(pSigEntry, TCPIP_MODULE_SIGNAL_RX_PENDING, 0);
   1cb18:	2200      	movs	r2, #0
   1cb1a:	2101      	movs	r1, #1
   1cb1c:	3010      	adds	r0, #16
   1cb1e:	f004 fa17 	bl	20f50 <_TCPIPSignalEntryNotify>
}
   1cb22:	bd08      	pop	{r3, pc}
   1cb24:	2000e448 	.word	0x2000e448
   1cb28:	2000d1d4 	.word	0x2000d1d4

Disassembly of section .text._UDPClose%548:

0001cb2c <_UDPClose>:
{
   1cb2c:	b510      	push	{r4, lr}
   1cb2e:	4604      	mov	r4, r0
    _UDPFreeTxResources(pSkt);
   1cb30:	f002 ff38 	bl	1f9a4 <_UDPFreeTxResources>
    pSkt->extFlags.rxEnable = 0;
   1cb34:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   1cb38:	f36f 0341 	bfc	r3, #1, #1
   1cb3c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    _UDPFreeRxQueue(pSkt);
   1cb40:	4620      	mov	r0, r4
   1cb42:	f003 fcf9 	bl	20538 <_UDPFreeRxQueue>
    if(pSkt->pCurrRxPkt != 0)
   1cb46:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   1cb48:	b120      	cbz	r0, 1cb54 <_UDPClose+0x28>
    TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
   1cb4a:	2209      	movs	r2, #9
   1cb4c:	f06f 0110 	mvn.w	r1, #16
   1cb50:	f001 f850 	bl	1dbf4 <_TCPIP_PKT_PacketAcknowledge>
    UDPSocketDcpt[pSkt->sktIx] = 0;
   1cb54:	f9b4 2012 	ldrsh.w	r2, [r4, #18]
   1cb58:	4b05      	ldr	r3, [pc, #20]	; (1cb70 <_UDPClose+0x44>)
   1cb5a:	681b      	ldr	r3, [r3, #0]
   1cb5c:	2100      	movs	r1, #0
   1cb5e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    TCPIP_HEAP_Free(udpMemH, pSkt);
   1cb62:	4b04      	ldr	r3, [pc, #16]	; (1cb74 <_UDPClose+0x48>)
   1cb64:	6818      	ldr	r0, [r3, #0]
   1cb66:	68c3      	ldr	r3, [r0, #12]
   1cb68:	4621      	mov	r1, r4
   1cb6a:	4798      	blx	r3
}
   1cb6c:	bd10      	pop	{r4, pc}
   1cb6e:	bf00      	nop
   1cb70:	2000e454 	.word	0x2000e454
   1cb74:	2000e464 	.word	0x2000e464

Disassembly of section .text.gfx_mono_ssd1306_init%549:

0001cb78 <gfx_mono_ssd1306_init>:
void gfx_mono_ssd1306_init(void) {
   1cb78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    for (ix = 0; ix < GFX_MONO_LCD_FRAMEBUFFER_SIZE; ix++) {
   1cb7a:	4a11      	ldr	r2, [pc, #68]	; (1cbc0 <gfx_mono_ssd1306_init+0x48>)
   1cb7c:	1e53      	subs	r3, r2, #1
   1cb7e:	f202 12ff 	addw	r2, r2, #511	; 0x1ff
        framebuffer[ix] = 0x00;
   1cb82:	2100      	movs	r1, #0
   1cb84:	f803 1f01 	strb.w	r1, [r3, #1]!
    for (ix = 0; ix < GFX_MONO_LCD_FRAMEBUFFER_SIZE; ix++) {
   1cb88:	4293      	cmp	r3, r2
   1cb8a:	d1fb      	bne.n	1cb84 <gfx_mono_ssd1306_init+0xc>
    gfx_mono_set_framebuffer(framebuffer);
   1cb8c:	480c      	ldr	r0, [pc, #48]	; (1cbc0 <gfx_mono_ssd1306_init+0x48>)
   1cb8e:	f005 fa83 	bl	22098 <gfx_mono_set_framebuffer>
    ssd1306_init();
   1cb92:	f7f8 fd3f 	bl	15614 <ssd1306_init>
        ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_START_LINE(address));
   1cb96:	2040      	movs	r0, #64	; 0x40
   1cb98:	f001 f8ec 	bl	1dd74 <ssd1306_write_command>
    for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
   1cb9c:	2500      	movs	r5, #0
            gfx_mono_ssd1306_put_byte(page, column, 0x00, true);
   1cb9e:	2701      	movs	r7, #1
   1cba0:	462e      	mov	r6, r5
void gfx_mono_ssd1306_init(void) {
   1cba2:	2400      	movs	r4, #0
            gfx_mono_ssd1306_put_byte(page, column, 0x00, true);
   1cba4:	463b      	mov	r3, r7
   1cba6:	4632      	mov	r2, r6
   1cba8:	b2e1      	uxtb	r1, r4
   1cbaa:	4628      	mov	r0, r5
   1cbac:	f000 fdda 	bl	1d764 <gfx_mono_ssd1306_put_byte>
   1cbb0:	3401      	adds	r4, #1
        for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
   1cbb2:	2c80      	cmp	r4, #128	; 0x80
   1cbb4:	d1f6      	bne.n	1cba4 <gfx_mono_ssd1306_init+0x2c>
    for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
   1cbb6:	3501      	adds	r5, #1
   1cbb8:	b2ed      	uxtb	r5, r5
   1cbba:	2d04      	cmp	r5, #4
   1cbbc:	d1f1      	bne.n	1cba2 <gfx_mono_ssd1306_init+0x2a>
}
   1cbbe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1cbc0:	2000d444 	.word	0x2000d444

Disassembly of section .text._realloc_r%550:

0001cbc4 <_realloc_r>:
   1cbc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1cbc6:	4607      	mov	r7, r0
   1cbc8:	4614      	mov	r4, r2
   1cbca:	460e      	mov	r6, r1
   1cbcc:	b921      	cbnz	r1, 1cbd8 <_realloc_r+0x14>
   1cbce:	4611      	mov	r1, r2
   1cbd0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   1cbd4:	f7fa b8d4 	b.w	16d80 <_malloc_r>
   1cbd8:	b922      	cbnz	r2, 1cbe4 <_realloc_r+0x20>
   1cbda:	f7fb f99b 	bl	17f14 <_free_r>
   1cbde:	4625      	mov	r5, r4
   1cbe0:	4628      	mov	r0, r5
   1cbe2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1cbe4:	f005 f872 	bl	21ccc <_malloc_usable_size_r>
   1cbe8:	42a0      	cmp	r0, r4
   1cbea:	d20f      	bcs.n	1cc0c <_realloc_r+0x48>
   1cbec:	4621      	mov	r1, r4
   1cbee:	4638      	mov	r0, r7
   1cbf0:	f7fa f8c6 	bl	16d80 <_malloc_r>
   1cbf4:	4605      	mov	r5, r0
   1cbf6:	2800      	cmp	r0, #0
   1cbf8:	d0f2      	beq.n	1cbe0 <_realloc_r+0x1c>
   1cbfa:	4631      	mov	r1, r6
   1cbfc:	4622      	mov	r2, r4
   1cbfe:	f004 fabf 	bl	21180 <memcpy>
   1cc02:	4631      	mov	r1, r6
   1cc04:	4638      	mov	r0, r7
   1cc06:	f7fb f985 	bl	17f14 <_free_r>
   1cc0a:	e7e9      	b.n	1cbe0 <_realloc_r+0x1c>
   1cc0c:	4635      	mov	r5, r6
   1cc0e:	e7e7      	b.n	1cbe0 <_realloc_r+0x1c>

Disassembly of section .text.TCPIP_IPV4_SelectSourceInterface%551:

0001cc10 <TCPIP_IPV4_SelectSourceInterface>:
{
   1cc10:	b570      	push	{r4, r5, r6, lr}
   1cc12:	460e      	mov	r6, r1
   1cc14:	4615      	mov	r5, r2
   1cc16:	b160      	cbz	r0, 1cc32 <TCPIP_IPV4_SelectSourceInterface+0x22>
   1cc18:	4604      	mov	r4, r0
   1cc1a:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1cc1e:	f012 0f40 	tst.w	r2, #64	; 0x40
   1cc22:	d113      	bne.n	1cc4c <TCPIP_IPV4_SelectSourceInterface+0x3c>
    if(srcSet)
   1cc24:	b93b      	cbnz	r3, 1cc36 <TCPIP_IPV4_SelectSourceInterface+0x26>
        pIf = (TCPIP_NET_IF*)TCPIP_IPV4_SelectDestInterface(pDestAddress);
   1cc26:	4630      	mov	r0, r6
   1cc28:	f7ff fe4e 	bl	1c8c8 <TCPIP_IPV4_SelectDestInterface>
    if(pIf)
   1cc2c:	4604      	mov	r4, r0
   1cc2e:	b190      	cbz	r0, 1cc56 <TCPIP_IPV4_SelectSourceInterface+0x46>
   1cc30:	e00d      	b.n	1cc4e <TCPIP_IPV4_SelectSourceInterface+0x3e>
    if(srcSet)
   1cc32:	2b00      	cmp	r3, #0
   1cc34:	d0f7      	beq.n	1cc26 <TCPIP_IPV4_SelectSourceInterface+0x16>
            pIf = _TCPIPStackIpAddFromAnyNet(0, pSrcAddress);
   1cc36:	4629      	mov	r1, r5
   1cc38:	2000      	movs	r0, #0
   1cc3a:	f7fe feff 	bl	1ba3c <_TCPIPStackIpAddFromAnyNet>
            if(pIf == 0)
   1cc3e:	4604      	mov	r4, r0
   1cc40:	b948      	cbnz	r0, 1cc56 <TCPIP_IPV4_SelectSourceInterface+0x46>
                pIf = (TCPIP_NET_IF*)TCPIP_IPV4_SelectDestInterface(pDestAddress);
   1cc42:	4630      	mov	r0, r6
   1cc44:	f7ff fe40 	bl	1c8c8 <TCPIP_IPV4_SelectDestInterface>
   1cc48:	4604      	mov	r4, r0
   1cc4a:	e004      	b.n	1cc56 <TCPIP_IPV4_SelectSourceInterface+0x46>
    if(srcSet)
   1cc4c:	b91b      	cbnz	r3, 1cc56 <TCPIP_IPV4_SelectSourceInterface+0x46>
        pSrcAddress->Val = TCPIP_STACK_NetAddressGet(pIf);
   1cc4e:	4620      	mov	r0, r4
   1cc50:	f004 fc90 	bl	21574 <TCPIP_STACK_NetAddressGet>
   1cc54:	6028      	str	r0, [r5, #0]
}
   1cc56:	4620      	mov	r0, r4
   1cc58:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_UDP_ArrayPut%552:

0001cc5a <TCPIP_UDP_ArrayPut>:
{
   1cc5a:	b570      	push	{r4, r5, r6, lr}
    if(cData != 0 && wDataLen != 0)
   1cc5c:	b1d9      	cbz	r1, 1cc96 <TCPIP_UDP_ArrayPut+0x3c>
   1cc5e:	460d      	mov	r5, r1
   1cc60:	b1da      	cbz	r2, 1cc9a <TCPIP_UDP_ArrayPut+0x40>
   1cc62:	4614      	mov	r4, r2
        UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1cc64:	f003 f9de 	bl	20024 <_UDPSocketDcpt>
        if(pSkt != 0 && _UDPTxPktValid(pSkt))
   1cc68:	4606      	mov	r6, r0
   1cc6a:	b1c8      	cbz	r0, 1cca0 <TCPIP_UDP_ArrayPut+0x46>
   1cc6c:	f004 fb5c 	bl	21328 <_UDPTxPktValid>
   1cc70:	b908      	cbnz	r0, 1cc76 <TCPIP_UDP_ArrayPut+0x1c>
    return 0;
   1cc72:	2400      	movs	r4, #0
   1cc74:	e012      	b.n	1cc9c <TCPIP_UDP_ArrayPut+0x42>
            uint16_t wrSpace = pSkt->txEnd - pSkt->txWrite;
   1cc76:	68b0      	ldr	r0, [r6, #8]
   1cc78:	6873      	ldr	r3, [r6, #4]
   1cc7a:	1a1b      	subs	r3, r3, r0
   1cc7c:	b29a      	uxth	r2, r3
   1cc7e:	4294      	cmp	r4, r2
   1cc80:	bf28      	it	cs
   1cc82:	4614      	movcs	r4, r2
            if(wDataLen)
   1cc84:	b154      	cbz	r4, 1cc9c <TCPIP_UDP_ArrayPut+0x42>
                memcpy(pSkt->txWrite, cData, wDataLen);
   1cc86:	4622      	mov	r2, r4
   1cc88:	4629      	mov	r1, r5
   1cc8a:	f004 fa79 	bl	21180 <memcpy>
                pSkt->txWrite += wDataLen;
   1cc8e:	68b3      	ldr	r3, [r6, #8]
   1cc90:	4423      	add	r3, r4
   1cc92:	60b3      	str	r3, [r6, #8]
   1cc94:	e002      	b.n	1cc9c <TCPIP_UDP_ArrayPut+0x42>
    return 0;
   1cc96:	2400      	movs	r4, #0
   1cc98:	e000      	b.n	1cc9c <TCPIP_UDP_ArrayPut+0x42>
   1cc9a:	4614      	mov	r4, r2
}
   1cc9c:	4620      	mov	r0, r4
   1cc9e:	bd70      	pop	{r4, r5, r6, pc}
    return 0;
   1cca0:	2400      	movs	r4, #0
   1cca2:	e7fb      	b.n	1cc9c <TCPIP_UDP_ArrayPut+0x42>

Disassembly of section .text.TCPIP_UDP_DestinationIPAddressSet%553:

0001cca4 <TCPIP_UDP_DestinationIPAddressSet>:

bool TCPIP_UDP_DestinationIPAddressSet(UDP_SOCKET s, IP_ADDRESS_TYPE addType, IP_MULTI_ADDRESS* remoteAddress)
{
    UDP_SOCKET_DCPT *pSkt;

    if(remoteAddress == 0)
   1cca4:	b1fa      	cbz	r2, 1cce6 <TCPIP_UDP_DestinationIPAddressSet+0x42>
{
   1cca6:	b538      	push	{r3, r4, r5, lr}
   1cca8:	4615      	mov	r5, r2
   1ccaa:	460c      	mov	r4, r1
    {
        return false;
    }

    pSkt = _UDPSocketDcpt(s);
   1ccac:	f003 f9ba 	bl	20024 <_UDPSocketDcpt>

    while(pSkt != 0 && pSkt->addType == addType)
   1ccb0:	4603      	mov	r3, r0
   1ccb2:	b120      	cbz	r0, 1ccbe <TCPIP_UDP_DestinationIPAddressSet+0x1a>
   1ccb4:	8f82      	ldrh	r2, [r0, #60]	; 0x3c
   1ccb6:	b2a1      	uxth	r1, r4
   1ccb8:	428a      	cmp	r2, r1
   1ccba:	d001      	beq.n	1ccc0 <TCPIP_UDP_DestinationIPAddressSet+0x1c>
#endif  // defined (TCPIP_STACK_USE_IPV4)

        break;
    }

    return false;
   1ccbc:	2000      	movs	r0, #0
}
   1ccbe:	bd38      	pop	{r3, r4, r5, pc}
        if (pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   1ccc0:	2a01      	cmp	r2, #1
   1ccc2:	d001      	beq.n	1ccc8 <TCPIP_UDP_DestinationIPAddressSet+0x24>
    return false;
   1ccc4:	2000      	movs	r0, #0
   1ccc6:	e7fa      	b.n	1ccbe <TCPIP_UDP_DestinationIPAddressSet+0x1a>
            if(pSkt->flags.bcastForceType != UDP_BCAST_NONE)
   1ccc8:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
   1cccc:	f012 0f03 	tst.w	r2, #3
   1ccd0:	d10b      	bne.n	1ccea <TCPIP_UDP_DestinationIPAddressSet+0x46>
            pSkt->destAddress.Val = remoteAddress->v4Add.Val;
   1ccd2:	682a      	ldr	r2, [r5, #0]
   1ccd4:	615a      	str	r2, [r3, #20]
            pSkt->flags.destSet = 1;
   1ccd6:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
   1ccda:	f042 0201 	orr.w	r2, r2, #1
   1ccde:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
            return true;
   1cce2:	2001      	movs	r0, #1
   1cce4:	e7eb      	b.n	1ccbe <TCPIP_UDP_DestinationIPAddressSet+0x1a>
        return false;
   1cce6:	2000      	movs	r0, #0
}
   1cce8:	4770      	bx	lr
                return false;
   1ccea:	2000      	movs	r0, #0
   1ccec:	e7e7      	b.n	1ccbe <TCPIP_UDP_DestinationIPAddressSet+0x1a>

Disassembly of section .text.__ssfputs_r%554:

0001ccee <__ssfputs_r>:
   1ccee:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1ccf0:	460e      	mov	r6, r1
   1ccf2:	6e09      	ldr	r1, [r1, #96]	; 0x60
   1ccf4:	0489      	lsls	r1, r1, #18
   1ccf6:	4607      	mov	r7, r0
   1ccf8:	4614      	mov	r4, r2
   1ccfa:	d40b      	bmi.n	1cd14 <__ssfputs_r+0x26>
   1ccfc:	18d5      	adds	r5, r2, r3
   1ccfe:	42ac      	cmp	r4, r5
   1cd00:	d00d      	beq.n	1cd1e <__ssfputs_r+0x30>
   1cd02:	4632      	mov	r2, r6
   1cd04:	f814 1b01 	ldrb.w	r1, [r4], #1
   1cd08:	4638      	mov	r0, r7
   1cd0a:	f002 fd57 	bl	1f7bc <__sfputc_r>
   1cd0e:	3001      	adds	r0, #1
   1cd10:	d1f5      	bne.n	1ccfe <__ssfputs_r+0x10>
   1cd12:	e00e      	b.n	1cd32 <__ssfputs_r+0x44>
   1cd14:	f023 0303 	bic.w	r3, r3, #3
   1cd18:	18d5      	adds	r5, r2, r3
   1cd1a:	42ac      	cmp	r4, r5
   1cd1c:	d101      	bne.n	1cd22 <__ssfputs_r+0x34>
   1cd1e:	2000      	movs	r0, #0
   1cd20:	e009      	b.n	1cd36 <__ssfputs_r+0x48>
   1cd22:	4632      	mov	r2, r6
   1cd24:	f854 1b04 	ldr.w	r1, [r4], #4
   1cd28:	4638      	mov	r0, r7
   1cd2a:	f004 fa53 	bl	211d4 <_fputwc_r>
   1cd2e:	3001      	adds	r0, #1
   1cd30:	d1f3      	bne.n	1cd1a <__ssfputs_r+0x2c>
   1cd32:	f04f 30ff 	mov.w	r0, #4294967295
   1cd36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.DRV_ETHPHY_NegotiationResultGet%555:

0001cd38 <DRV_ETHPHY_NegotiationResultGet>:
    if(hClientObj != 0)
   1cd38:	4603      	mov	r3, r0
   1cd3a:	b198      	cbz	r0, 1cd64 <DRV_ETHPHY_NegotiationResultGet+0x2c>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1cd3c:	68c0      	ldr	r0, [r0, #12]
   1cd3e:	490f      	ldr	r1, [pc, #60]	; (1cd7c <DRV_ETHPHY_NegotiationResultGet+0x44>)
   1cd40:	4288      	cmp	r0, r1
   1cd42:	d112      	bne.n	1cd6a <DRV_ETHPHY_NegotiationResultGet+0x32>
            if(hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_READY)
   1cd44:	f993 1008 	ldrsb.w	r1, [r3, #8]
   1cd48:	2902      	cmp	r1, #2
   1cd4a:	d111      	bne.n	1cd70 <DRV_ETHPHY_NegotiationResultGet+0x38>
            if(pNegResult == 0)
   1cd4c:	b19a      	cbz	r2, 1cd76 <DRV_ETHPHY_NegotiationResultGet+0x3e>
            hClientObj->operParam = (uintptr_t)pNegResult;
   1cd4e:	631a      	str	r2, [r3, #48]	; 0x30
    hClientObj->operType = opType;
   1cd50:	2204      	movs	r2, #4
   1cd52:	839a      	strh	r2, [r3, #28]
    hClientObj->operPhase = hClientObj->operSubPhase = 0; 
   1cd54:	2200      	movs	r2, #0
   1cd56:	841a      	strh	r2, [r3, #32]
   1cd58:	83da      	strh	r2, [r3, #30]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_BUSY; 
   1cd5a:	2001      	movs	r0, #1
   1cd5c:	7218      	strb	r0, [r3, #8]
    hClientObj->operRes = res;
   1cd5e:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c
   1cd62:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1cd64:	f06f 000a 	mvn.w	r0, #10
   1cd68:	4770      	bx	lr
   1cd6a:	f06f 000a 	mvn.w	r0, #10
   1cd6e:	4770      	bx	lr
                return DRV_ETHPHY_RES_NOT_READY_ERR;
   1cd70:	f06f 0009 	mvn.w	r0, #9
   1cd74:	4770      	bx	lr
                return DRV_ETHPHY_RES_OPERATION_ERR;
   1cd76:	f06f 0008 	mvn.w	r0, #8
}
   1cd7a:	4770      	bx	lr
   1cd7c:	2000de18 	.word	0x2000de18

Disassembly of section .text._DRV_ETHPHY_NegCompletePhaseRead2%556:

0001cd80 <_DRV_ETHPHY_NegCompletePhaseRead2>:
{
   1cd80:	b510      	push	{r4, lr}
   1cd82:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1cd84:	f003 fd0e 	bl	207a4 <_DRV_PHY_SMITransfer_Wait>
   1cd88:	b168      	cbz	r0, 1cda6 <_DRV_ETHPHY_NegCompletePhaseRead2+0x26>
    hClientObj->operReg[1] = hClientObj->smiData;
   1cd8a:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   1cd8c:	84a3      	strh	r3, [r4, #36]	; 0x24
    if(hClientObj->operParam == 0)
   1cd8e:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1cd90:	b153      	cbz	r3, 1cda8 <_DRV_ETHPHY_NegCompletePhaseRead2+0x28>
    hClientObj->operTStamp = SYS_TMR_TickCountGet() + ((DRV_ETHPHY_NEG_INIT_TMO * SYS_TMR_TickCounterFrequencyGet()) + 999) / 1000;
   1cd92:	f003 f9d3 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
   1cd96:	f003 f9a9 	bl	200ec <SYS_TMR_TickCountGet>
   1cd9a:	62a0      	str	r0, [r4, #40]	; 0x28
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMCON))
   1cd9c:	2100      	movs	r1, #0
   1cd9e:	4620      	mov	r0, r4
   1cda0:	f002 f8ac 	bl	1eefc <_DRV_PHY_SMIReadStart>
   1cda4:	b958      	cbnz	r0, 1cdbe <_DRV_ETHPHY_NegCompletePhaseRead2+0x3e>
}
   1cda6:	bd10      	pop	{r4, pc}
        if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   1cda8:	2101      	movs	r1, #1
   1cdaa:	4620      	mov	r0, r4
   1cdac:	f002 f8a6 	bl	1eefc <_DRV_PHY_SMIReadStart>
   1cdb0:	2800      	cmp	r0, #0
   1cdb2:	d0f8      	beq.n	1cda6 <_DRV_ETHPHY_NegCompletePhaseRead2+0x26>
    hClientObj->operPhase = operPhase;
   1cdb4:	2303      	movs	r3, #3
   1cdb6:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1cdb8:	2300      	movs	r3, #0
   1cdba:	8423      	strh	r3, [r4, #32]
   1cdbc:	e7f3      	b.n	1cda6 <_DRV_ETHPHY_NegCompletePhaseRead2+0x26>
    hClientObj->operPhase = operPhase;
   1cdbe:	2304      	movs	r3, #4
   1cdc0:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1cdc2:	2300      	movs	r3, #0
   1cdc4:	8423      	strh	r3, [r4, #32]
   1cdc6:	e7ee      	b.n	1cda6 <_DRV_ETHPHY_NegCompletePhaseRead2+0x26>

Disassembly of section .text.DRV_GMAC_LinkCheck%557:

0001cdc8 <DRV_GMAC_LinkCheck>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1cdc8:	4b0f      	ldr	r3, [pc, #60]	; (1ce08 <DRV_GMAC_LinkCheck+0x40>)
   1cdca:	4283      	cmp	r3, r0
   1cdcc:	d116      	bne.n	1cdfc <DRV_GMAC_LinkCheck+0x34>
    if(pMACDrv == 0 || (pMACDrv->sGmacData._macFlags._linkPresent == 0))
   1cdce:	b1b8      	cbz	r0, 1ce00 <DRV_GMAC_LinkCheck+0x38>
   1cdd0:	7d9b      	ldrb	r3, [r3, #22]
   1cdd2:	f013 0f04 	tst.w	r3, #4
   1cdd6:	d015      	beq.n	1ce04 <DRV_GMAC_LinkCheck+0x3c>
{
   1cdd8:	b510      	push	{r4, lr}
	pPhyBase->DRV_ETHPHY_Tasks(pMACDrv->sGmacData.hPhySysObject);
   1cdda:	4c0b      	ldr	r4, [pc, #44]	; (1ce08 <DRV_GMAC_LinkCheck+0x40>)
   1cddc:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
   1cde0:	691b      	ldr	r3, [r3, #16]
   1cde2:	68e0      	ldr	r0, [r4, #12]
   1cde4:	4798      	blx	r3
    (*_DRV_GMAC_LinkStateTbl[pMACDrv->sGmacData._linkCheckState])(pMACDrv);
   1cde6:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
   1cdea:	4b08      	ldr	r3, [pc, #32]	; (1ce0c <DRV_GMAC_LinkCheck+0x44>)
   1cdec:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1cdf0:	4620      	mov	r0, r4
   1cdf2:	4798      	blx	r3
    return pMACDrv->sGmacData._macFlags._linkPrev == 1;	
   1cdf4:	7da0      	ldrb	r0, [r4, #22]
   1cdf6:	f3c0 1000 	ubfx	r0, r0, #4, #1
}
   1cdfa:	bd10      	pop	{r4, pc}
	    return false;
   1cdfc:	2000      	movs	r0, #0
   1cdfe:	4770      	bx	lr
   1ce00:	2000      	movs	r0, #0
   1ce02:	4770      	bx	lr
   1ce04:	2000      	movs	r0, #0
}
   1ce06:	4770      	bx	lr
   1ce08:	2000d8b8 	.word	0x2000d8b8
   1ce0c:	000218c8 	.word	0x000218c8

Disassembly of section .text._TCPSendWinIncUpdate%558:

0001ce10 <_TCPSendWinIncUpdate>:
{
   1ce10:	b570      	push	{r4, r5, r6, lr}
   1ce12:	4605      	mov	r5, r0
    oldWin = pSkt->localWindow;
   1ce14:	f8b0 605e 	ldrh.w	r6, [r0, #94]	; 0x5e
    wFIFOSize = pSkt->rxEnd - pSkt->rxStart;
   1ce18:	6984      	ldr	r4, [r0, #24]
   1ce1a:	6943      	ldr	r3, [r0, #20]
   1ce1c:	1ae4      	subs	r4, r4, r3
   1ce1e:	b2a4      	uxth	r4, r4
    wDataLen = _TCPIsGetReady(pSkt);
   1ce20:	f003 ff75 	bl	20d0e <_TCPIsGetReady>
    return wFIFOSize - wDataLen;
   1ce24:	1a20      	subs	r0, r4, r0
   1ce26:	b280      	uxth	r0, r0
    if(newWin == rxBuffSz)
   1ce28:	4284      	cmp	r4, r0
   1ce2a:	d00c      	beq.n	1ce46 <_TCPSendWinIncUpdate+0x36>
    else if(newWin > oldWin)
   1ce2c:	4286      	cmp	r6, r0
   1ce2e:	d211      	bcs.n	1ce54 <_TCPSendWinIncUpdate+0x44>
        minWinInc = rxBuffSz >> 1; // half RX buffer
   1ce30:	0864      	lsrs	r4, r4, #1
        if((newWin - oldWin) > minWinInc)
   1ce32:	1b80      	subs	r0, r0, r6
   1ce34:	f8b5 3064 	ldrh.w	r3, [r5, #100]	; 0x64
   1ce38:	429c      	cmp	r4, r3
   1ce3a:	bf28      	it	cs
   1ce3c:	461c      	movcs	r4, r3
   1ce3e:	42a0      	cmp	r0, r4
   1ce40:	dc01      	bgt.n	1ce46 <_TCPSendWinIncUpdate+0x36>
    return false;
   1ce42:	2000      	movs	r0, #0
   1ce44:	e007      	b.n	1ce56 <_TCPSendWinIncUpdate+0x46>
        _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
   1ce46:	2201      	movs	r2, #1
   1ce48:	2110      	movs	r1, #16
   1ce4a:	4628      	mov	r0, r5
   1ce4c:	f7ea feea 	bl	7c24 <_TcpSend>
        return true;
   1ce50:	2001      	movs	r0, #1
   1ce52:	e000      	b.n	1ce56 <_TCPSendWinIncUpdate+0x46>
    return false;
   1ce54:	2000      	movs	r0, #0
}
   1ce56:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_TCP_DestinationIPAddressSet%559:

0001ce58 <TCPIP_TCP_DestinationIPAddressSet>:
    if(remoteAddress == 0)
   1ce58:	b1f2      	cbz	r2, 1ce98 <TCPIP_TCP_DestinationIPAddressSet+0x40>
{
   1ce5a:	b538      	push	{r3, r4, r5, lr}
   1ce5c:	4615      	mov	r5, r2
   1ce5e:	460c      	mov	r4, r1
    pSkt = _TcpSocketChk(hTCP); 
   1ce60:	f002 ffdc 	bl	1fe1c <_TcpSocketChk>
    while(pSkt != 0 && pSkt->addType == addType && !_TCP_IsConnected(pSkt))
   1ce64:	4603      	mov	r3, r0
   1ce66:	b120      	cbz	r0, 1ce72 <TCPIP_TCP_DestinationIPAddressSet+0x1a>
   1ce68:	f890 206f 	ldrb.w	r2, [r0, #111]	; 0x6f
   1ce6c:	42a2      	cmp	r2, r4
   1ce6e:	d005      	beq.n	1ce7c <TCPIP_TCP_DestinationIPAddressSet+0x24>
    return false;
   1ce70:	2000      	movs	r0, #0
}
   1ce72:	bd38      	pop	{r3, r4, r5, pc}
            pSkt->destAddress.Val = remoteAddress->v4Add.Val;
   1ce74:	682a      	ldr	r2, [r5, #0]
   1ce76:	639a      	str	r2, [r3, #56]	; 0x38
            return true;
   1ce78:	2001      	movs	r0, #1
   1ce7a:	e7fa      	b.n	1ce72 <TCPIP_TCP_DestinationIPAddressSet+0x1a>
    return (pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1 || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2 || pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT);
   1ce7c:	f890 006e 	ldrb.w	r0, [r0, #110]	; 0x6e
   1ce80:	1ec1      	subs	r1, r0, #3
   1ce82:	b2c9      	uxtb	r1, r1
   1ce84:	2902      	cmp	r1, #2
   1ce86:	d909      	bls.n	1ce9c <TCPIP_TCP_DestinationIPAddressSet+0x44>
    while(pSkt != 0 && pSkt->addType == addType && !_TCP_IsConnected(pSkt))
   1ce88:	2808      	cmp	r0, #8
    return false;
   1ce8a:	bf08      	it	eq
   1ce8c:	2000      	moveq	r0, #0
    while(pSkt != 0 && pSkt->addType == addType && !_TCP_IsConnected(pSkt))
   1ce8e:	d0f0      	beq.n	1ce72 <TCPIP_TCP_DestinationIPAddressSet+0x1a>
        if (pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   1ce90:	2a01      	cmp	r2, #1
   1ce92:	d0ef      	beq.n	1ce74 <TCPIP_TCP_DestinationIPAddressSet+0x1c>
    return false;
   1ce94:	2000      	movs	r0, #0
   1ce96:	e7ec      	b.n	1ce72 <TCPIP_TCP_DestinationIPAddressSet+0x1a>
        return false;
   1ce98:	2000      	movs	r0, #0
}
   1ce9a:	4770      	bx	lr
    return false;
   1ce9c:	2000      	movs	r0, #0
   1ce9e:	e7e8      	b.n	1ce72 <TCPIP_TCP_DestinationIPAddressSet+0x1a>

Disassembly of section .text.TCPIP_ARP_Deinitialize%560:

0001cea0 <TCPIP_ARP_Deinitialize>:
    if(arpMod.initCount > 0)
   1cea0:	4b10      	ldr	r3, [pc, #64]	; (1cee4 <TCPIP_ARP_Deinitialize+0x44>)
   1cea2:	68db      	ldr	r3, [r3, #12]
   1cea4:	2b00      	cmp	r3, #0
   1cea6:	dd1c      	ble.n	1cee2 <TCPIP_ARP_Deinitialize+0x42>
{
   1cea8:	b510      	push	{r4, lr}
        if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_DOWN)
   1ceaa:	7f02      	ldrb	r2, [r0, #28]
   1ceac:	2a04      	cmp	r2, #4
   1ceae:	d004      	beq.n	1ceba <TCPIP_ARP_Deinitialize+0x1a>
            if(--arpMod.initCount == 0)
   1ceb0:	3b01      	subs	r3, #1
   1ceb2:	4a0c      	ldr	r2, [pc, #48]	; (1cee4 <TCPIP_ARP_Deinitialize+0x44>)
   1ceb4:	60d3      	str	r3, [r2, #12]
   1ceb6:	b18b      	cbz	r3, 1cedc <TCPIP_ARP_Deinitialize+0x3c>
}
   1ceb8:	bd10      	pop	{r4, pc}
            if(arpMod.deleteOld)
   1ceba:	4b0a      	ldr	r3, [pc, #40]	; (1cee4 <TCPIP_ARP_Deinitialize+0x44>)
   1cebc:	7c1b      	ldrb	r3, [r3, #16]
   1cebe:	2b00      	cmp	r3, #0
   1cec0:	d0fa      	beq.n	1ceb8 <TCPIP_ARP_Deinitialize+0x18>
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   1cec2:	4b08      	ldr	r3, [pc, #32]	; (1cee4 <TCPIP_ARP_Deinitialize+0x44>)
   1cec4:	685c      	ldr	r4, [r3, #4]
   1cec6:	6940      	ldr	r0, [r0, #20]
   1cec8:	f004 ff2c 	bl	21d24 <TCPIP_STACK_NetIxGet>
   1cecc:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
                if(pArpDcpt != 0)
   1ced0:	eb14 00c0 	adds.w	r0, r4, r0, lsl #3
   1ced4:	d0f0      	beq.n	1ceb8 <TCPIP_ARP_Deinitialize+0x18>
                    _ARPRemoveCacheEntries(pArpDcpt);
   1ced6:	f002 ffc9 	bl	1fe6c <_ARPRemoveCacheEntries>
   1ceda:	e7ed      	b.n	1ceb8 <TCPIP_ARP_Deinitialize+0x18>
                    _ARPDeleteResources();
   1cedc:	f7fa fd9a 	bl	17a14 <_ARPDeleteResources>
}
   1cee0:	e7ea      	b.n	1ceb8 <TCPIP_ARP_Deinitialize+0x18>
   1cee2:	4770      	bx	lr
   1cee4:	2000dfa4 	.word	0x2000dfa4

Disassembly of section .rodata._DHCPOptProcTbl%561:

0001cee8 <_DHCPOptProcTbl>:
   1cee8:	00000035 0001e5bf 00000001 0001def3     5...............
   1cef8:	00000003 0001e117 00000006 0001b571     ............q...
   1cf08:	00000036 000204cd 00000033 0001f5f1     6.......3.......
   1cf18:	0000003a 0001f61f 0000003b 0001f64d     :.......;...M...
   1cf28:	000000ff 0002224b                       ....K"..

Disassembly of section .text.TCPIP_STACK_MACIdToNet%562:

0001cf30 <TCPIP_STACK_MACIdToNet>:
    if(macId != (TCPIP_STACK_MODULE)TCPIP_MODULE_MAC_NONE)
   1cf30:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
   1cf34:	d017      	beq.n	1cf66 <TCPIP_STACK_MACIdToNet+0x36>
{
   1cf36:	b410      	push	{r4}
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   1cf38:	4b0d      	ldr	r3, [pc, #52]	; (1cf70 <TCPIP_STACK_MACIdToNet+0x40>)
   1cf3a:	681b      	ldr	r3, [r3, #0]
   1cf3c:	4a0d      	ldr	r2, [pc, #52]	; (1cf74 <TCPIP_STACK_MACIdToNet+0x44>)
   1cf3e:	6814      	ldr	r4, [r2, #0]
   1cf40:	2c00      	cmp	r4, #0
   1cf42:	dd13      	ble.n	1cf6c <TCPIP_STACK_MACIdToNet+0x3c>
            if(pNetIf->macId == macId)
   1cf44:	885a      	ldrh	r2, [r3, #2]
   1cf46:	4282      	cmp	r2, r0
   1cf48:	d009      	beq.n	1cf5e <TCPIP_STACK_MACIdToNet+0x2e>
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   1cf4a:	2200      	movs	r2, #0
   1cf4c:	3201      	adds	r2, #1
   1cf4e:	336c      	adds	r3, #108	; 0x6c
   1cf50:	42a2      	cmp	r2, r4
   1cf52:	d003      	beq.n	1cf5c <TCPIP_STACK_MACIdToNet+0x2c>
            if(pNetIf->macId == macId)
   1cf54:	8859      	ldrh	r1, [r3, #2]
   1cf56:	4281      	cmp	r1, r0
   1cf58:	d1f8      	bne.n	1cf4c <TCPIP_STACK_MACIdToNet+0x1c>
   1cf5a:	e000      	b.n	1cf5e <TCPIP_STACK_MACIdToNet+0x2e>
    return 0;
   1cf5c:	2300      	movs	r3, #0
}
   1cf5e:	4618      	mov	r0, r3
   1cf60:	f85d 4b04 	ldr.w	r4, [sp], #4
   1cf64:	4770      	bx	lr
    return 0;
   1cf66:	2300      	movs	r3, #0
}
   1cf68:	4618      	mov	r0, r3
   1cf6a:	4770      	bx	lr
    return 0;
   1cf6c:	2300      	movs	r3, #0
   1cf6e:	e7f6      	b.n	1cf5e <TCPIP_STACK_MACIdToNet+0x2e>
   1cf70:	2000e440 	.word	0x2000e440
   1cf74:	2000e0f0 	.word	0x2000e0f0

Disassembly of section .text.TCPIP_STACK_MatchNetAddress%563:

0001cf78 <TCPIP_STACK_MatchNetAddress>:
    if(pIpAdd->Val == 0x0100007f /* || pNetIf->netIPAddr.Val == pIpAdd->Val*/)
   1cf78:	6809      	ldr	r1, [r1, #0]
   1cf7a:	4b0e      	ldr	r3, [pc, #56]	; (1cfb4 <TCPIP_STACK_MatchNetAddress+0x3c>)
   1cf7c:	4299      	cmp	r1, r3
   1cf7e:	d018      	beq.n	1cfb2 <TCPIP_STACK_MatchNetAddress+0x3a>
{
   1cf80:	b410      	push	{r4}
    for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1cf82:	4b0d      	ldr	r3, [pc, #52]	; (1cfb8 <TCPIP_STACK_MatchNetAddress+0x40>)
   1cf84:	6818      	ldr	r0, [r3, #0]
   1cf86:	4b0d      	ldr	r3, [pc, #52]	; (1cfbc <TCPIP_STACK_MatchNetAddress+0x44>)
   1cf88:	681c      	ldr	r4, [r3, #0]
   1cf8a:	2c00      	cmp	r4, #0
   1cf8c:	dd0f      	ble.n	1cfae <TCPIP_STACK_MatchNetAddress+0x36>
        if(pIf->netIPAddr.Val == pIpAdd->Val)
   1cf8e:	6843      	ldr	r3, [r0, #4]
   1cf90:	4299      	cmp	r1, r3
   1cf92:	d009      	beq.n	1cfa8 <TCPIP_STACK_MatchNetAddress+0x30>
    for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1cf94:	2300      	movs	r3, #0
   1cf96:	3301      	adds	r3, #1
   1cf98:	306c      	adds	r0, #108	; 0x6c
   1cf9a:	42a3      	cmp	r3, r4
   1cf9c:	d003      	beq.n	1cfa6 <TCPIP_STACK_MatchNetAddress+0x2e>
        if(pIf->netIPAddr.Val == pIpAdd->Val)
   1cf9e:	6842      	ldr	r2, [r0, #4]
   1cfa0:	4291      	cmp	r1, r2
   1cfa2:	d1f8      	bne.n	1cf96 <TCPIP_STACK_MatchNetAddress+0x1e>
   1cfa4:	e000      	b.n	1cfa8 <TCPIP_STACK_MatchNetAddress+0x30>
    return 0;
   1cfa6:	2000      	movs	r0, #0
}
   1cfa8:	f85d 4b04 	ldr.w	r4, [sp], #4
   1cfac:	4770      	bx	lr
    return 0;
   1cfae:	2000      	movs	r0, #0
   1cfb0:	e7fa      	b.n	1cfa8 <TCPIP_STACK_MatchNetAddress+0x30>
}
   1cfb2:	4770      	bx	lr
   1cfb4:	0100007f 	.word	0x0100007f
   1cfb8:	2000e440 	.word	0x2000e440
   1cfbc:	2000e0f0 	.word	0x2000e0f0

Disassembly of section .text._TCPIPStackSignalHandlerRegister%564:

0001cfc0 <_TCPIPStackSignalHandlerRegister>:
    if(signalHandler != 0 )
   1cfc0:	b1c9      	cbz	r1, 1cff6 <_TCPIPStackSignalHandlerRegister+0x36>
{
   1cfc2:	b430      	push	{r4, r5}
   1cfc4:	460c      	mov	r4, r1
        if(TCPIP_MODULE_LAYER1 <= modId && modId < sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL)/sizeof(*TCPIP_STACK_MODULE_SIGNAL_TBL))
   1cfc6:	1e83      	subs	r3, r0, #2
   1cfc8:	b29b      	uxth	r3, r3
   1cfca:	2b24      	cmp	r3, #36	; 0x24
   1cfcc:	d815      	bhi.n	1cffa <_TCPIPStackSignalHandlerRegister+0x3a>
            TCPIP_MODULE_SIGNAL_ENTRY* pSignalEntry = TCPIP_STACK_MODULE_SIGNAL_TBL + modId;
   1cfce:	490c      	ldr	r1, [pc, #48]	; (1d000 <_TCPIPStackSignalHandlerRegister+0x40>)
   1cfd0:	0103      	lsls	r3, r0, #4
   1cfd2:	18c8      	adds	r0, r1, r3
            if(pSignalEntry->signalHandler == 0 || pSignalEntry->signalHandler == signalHandler)
   1cfd4:	58cd      	ldr	r5, [r1, r3]
   1cfd6:	b125      	cbz	r5, 1cfe2 <_TCPIPStackSignalHandlerRegister+0x22>
   1cfd8:	42a5      	cmp	r5, r4
   1cfda:	d002      	beq.n	1cfe2 <_TCPIPStackSignalHandlerRegister+0x22>
    return 0;
   1cfdc:	2000      	movs	r0, #0
}
   1cfde:	bc30      	pop	{r4, r5}
   1cfe0:	4770      	bx	lr
                pSignalEntry->signalHandler = signalHandler;
   1cfe2:	50cc      	str	r4, [r1, r3]
                if ((asyncTmoMs != 0) && (asyncTmoMs < stackTaskRate))
   1cfe4:	b122      	cbz	r2, 1cff0 <_TCPIPStackSignalHandlerRegister+0x30>
   1cfe6:	4b07      	ldr	r3, [pc, #28]	; (1d004 <_TCPIPStackSignalHandlerRegister+0x44>)
   1cfe8:	681b      	ldr	r3, [r3, #0]
   1cfea:	429a      	cmp	r2, r3
                    asyncTmoMs = stackTaskRate;
   1cfec:	bf38      	it	cc
   1cfee:	b21a      	sxthcc	r2, r3
                pSignalEntry->asyncTmo = pSignalEntry->currTmo = asyncTmoMs;
   1cff0:	8182      	strh	r2, [r0, #12]
   1cff2:	8142      	strh	r2, [r0, #10]
                return pSignalEntry;
   1cff4:	e7f3      	b.n	1cfde <_TCPIPStackSignalHandlerRegister+0x1e>
    return 0;
   1cff6:	2000      	movs	r0, #0
}
   1cff8:	4770      	bx	lr
    return 0;
   1cffa:	2000      	movs	r0, #0
   1cffc:	e7ef      	b.n	1cfde <_TCPIPStackSignalHandlerRegister+0x1e>
   1cffe:	bf00      	nop
   1d000:	2000d1d4 	.word	0x2000d1d4
   1d004:	2000e438 	.word	0x2000e438

Disassembly of section .rodata.keySeqTbl%565:

0001d008 <keySeqTbl>:
   1d008:	0000d334 00020de1 00000003 0000d338     4...........8...
   1d018:	0002167d 00000003 0000d33c 00020b91     }.......<.......
   1d028:	00000003 0000d340 0002104d 00000003     ....@...M.......
   1d038:	0000d344 0001f3b9 00000004 0000d34c     D...........L...
   1d048:	0001f389 00000004                       ........

Disassembly of section .rodata.TCPIP_STACK_MODULE_CONFIG_TBL%566:

0001d050 <TCPIP_STACK_MODULE_CONFIG_TBL>:
   1d050:	00000003 00021c2c 00000006 00000000     ....,...........
   1d060:	00000002 00020164 00000009 000221e0     ....d........!..
   1d070:	0000000a 000221d8 0000000c 00021c1c     .....!..........
   1d080:	0000000f 0002170c 00000001 2000e278     ............x.. 
   1d090:	00001050 0001ed90                       P.......

Disassembly of section .text.xPortStartScheduler%567:

0001d098 <xPortStartScheduler>:
{
   1d098:	b510      	push	{r4, lr}
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
   1d09a:	4b0e      	ldr	r3, [pc, #56]	; (1d0d4 <xPortStartScheduler+0x3c>)
   1d09c:	681a      	ldr	r2, [r3, #0]
   1d09e:	f442 0260 	orr.w	r2, r2, #14680064	; 0xe00000
   1d0a2:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
   1d0a4:	681a      	ldr	r2, [r3, #0]
   1d0a6:	f042 4260 	orr.w	r2, r2, #3758096384	; 0xe0000000
   1d0aa:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
   1d0ac:	f003 f882 	bl	201b4 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
   1d0b0:	2400      	movs	r4, #0
   1d0b2:	4b09      	ldr	r3, [pc, #36]	; (1d0d8 <xPortStartScheduler+0x40>)
   1d0b4:	601c      	str	r4, [r3, #0]
	vPortEnableVFP();
   1d0b6:	f004 fc89 	bl	219cc <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
   1d0ba:	4a08      	ldr	r2, [pc, #32]	; (1d0dc <xPortStartScheduler+0x44>)
   1d0bc:	6813      	ldr	r3, [r2, #0]
   1d0be:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
   1d0c2:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
   1d0c4:	f003 f862 	bl	2018c <prvPortStartFirstTask>
	vTaskSwitchContext();
   1d0c8:	f7fa fa62 	bl	17590 <vTaskSwitchContext>
	prvTaskExitError();
   1d0cc:	f003 fdb0 	bl	20c30 <prvTaskExitError>
}
   1d0d0:	4620      	mov	r0, r4
   1d0d2:	bd10      	pop	{r4, pc}
   1d0d4:	e000ed20 	.word	0xe000ed20
   1d0d8:	2000e490 	.word	0x2000e490
   1d0dc:	e000ef34 	.word	0xe000ef34

Disassembly of section .text.wc_CryptoCb_FindDeviceByIndex%568:

0001d0e0 <wc_CryptoCb_FindDeviceByIndex>:
    for (i=startIdx; i<MAX_CRYPTO_DEVID_CALLBACKS; i++) {
   1d0e0:	2807      	cmp	r0, #7
   1d0e2:	dc1c      	bgt.n	1d11e <wc_CryptoCb_FindDeviceByIndex+0x3e>
        if (gCryptoDev[i].devId != INVALID_DEVID)
   1d0e4:	eb00 0340 	add.w	r3, r0, r0, lsl #1
   1d0e8:	4a0e      	ldr	r2, [pc, #56]	; (1d124 <wc_CryptoCb_FindDeviceByIndex+0x44>)
   1d0ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1d0ee:	f113 0f02 	cmn.w	r3, #2
   1d0f2:	d10c      	bne.n	1d10e <wc_CryptoCb_FindDeviceByIndex+0x2e>
   1d0f4:	eb00 0340 	add.w	r3, r0, r0, lsl #1
   1d0f8:	4a0a      	ldr	r2, [pc, #40]	; (1d124 <wc_CryptoCb_FindDeviceByIndex+0x44>)
   1d0fa:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    for (i=startIdx; i<MAX_CRYPTO_DEVID_CALLBACKS; i++) {
   1d0fe:	3001      	adds	r0, #1
   1d100:	2808      	cmp	r0, #8
   1d102:	d00a      	beq.n	1d11a <wc_CryptoCb_FindDeviceByIndex+0x3a>
        if (gCryptoDev[i].devId != INVALID_DEVID)
   1d104:	f853 2f0c 	ldr.w	r2, [r3, #12]!
   1d108:	f112 0f02 	cmn.w	r2, #2
   1d10c:	d0f7      	beq.n	1d0fe <wc_CryptoCb_FindDeviceByIndex+0x1e>
            return &gCryptoDev[i];
   1d10e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   1d112:	4b04      	ldr	r3, [pc, #16]	; (1d124 <wc_CryptoCb_FindDeviceByIndex+0x44>)
   1d114:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1d118:	4770      	bx	lr
    return NULL;
   1d11a:	2000      	movs	r0, #0
   1d11c:	4770      	bx	lr
   1d11e:	2000      	movs	r0, #0
}
   1d120:	4770      	bx	lr
   1d122:	bf00      	nop
   1d124:	2000dee4 	.word	0x2000dee4

Disassembly of section .text.__libc_init_array%569:

0001d128 <__libc_init_array>:
   1d128:	b570      	push	{r4, r5, r6, lr}
   1d12a:	4d0d      	ldr	r5, [pc, #52]	; (1d160 <__libc_init_array+0x38>)
   1d12c:	4c0d      	ldr	r4, [pc, #52]	; (1d164 <__libc_init_array+0x3c>)
   1d12e:	1b64      	subs	r4, r4, r5
   1d130:	10a4      	asrs	r4, r4, #2
   1d132:	2600      	movs	r6, #0
   1d134:	42a6      	cmp	r6, r4
   1d136:	d109      	bne.n	1d14c <__libc_init_array+0x24>
   1d138:	4d0b      	ldr	r5, [pc, #44]	; (1d168 <__libc_init_array+0x40>)
   1d13a:	4c0c      	ldr	r4, [pc, #48]	; (1d16c <__libc_init_array+0x44>)
   1d13c:	f7e3 f892 	bl	264 <_init>
   1d140:	1b64      	subs	r4, r4, r5
   1d142:	10a4      	asrs	r4, r4, #2
   1d144:	2600      	movs	r6, #0
   1d146:	42a6      	cmp	r6, r4
   1d148:	d105      	bne.n	1d156 <__libc_init_array+0x2e>
   1d14a:	bd70      	pop	{r4, r5, r6, pc}
   1d14c:	f855 3b04 	ldr.w	r3, [r5], #4
   1d150:	4798      	blx	r3
   1d152:	3601      	adds	r6, #1
   1d154:	e7ee      	b.n	1d134 <__libc_init_array+0xc>
   1d156:	f855 3b04 	ldr.w	r3, [r5], #4
   1d15a:	4798      	blx	r3
   1d15c:	3601      	adds	r6, #1
   1d15e:	e7f2      	b.n	1d146 <__libc_init_array+0x1e>
   1d160:	00000270 	.word	0x00000270
   1d164:	00000270 	.word	0x00000270
   1d168:	00000270 	.word	0x00000270
   1d16c:	00000274 	.word	0x00000274

Disassembly of section .text.srand%570:

0001d170 <srand>:
   1d170:	b538      	push	{r3, r4, r5, lr}
   1d172:	4b0d      	ldr	r3, [pc, #52]	; (1d1a8 <srand+0x38>)
   1d174:	681c      	ldr	r4, [r3, #0]
   1d176:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1d178:	4605      	mov	r5, r0
   1d17a:	b97b      	cbnz	r3, 1d19c <srand+0x2c>
   1d17c:	2018      	movs	r0, #24
   1d17e:	f004 fd75 	bl	21c6c <malloc>
   1d182:	4a0a      	ldr	r2, [pc, #40]	; (1d1ac <srand+0x3c>)
   1d184:	4b0a      	ldr	r3, [pc, #40]	; (1d1b0 <srand+0x40>)
   1d186:	63a0      	str	r0, [r4, #56]	; 0x38
   1d188:	e9c0 2300 	strd	r2, r3, [r0]
   1d18c:	4b09      	ldr	r3, [pc, #36]	; (1d1b4 <srand+0x44>)
   1d18e:	6083      	str	r3, [r0, #8]
   1d190:	230b      	movs	r3, #11
   1d192:	8183      	strh	r3, [r0, #12]
   1d194:	2201      	movs	r2, #1
   1d196:	2300      	movs	r3, #0
   1d198:	e9c0 2304 	strd	r2, r3, [r0, #16]
   1d19c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1d19e:	2200      	movs	r2, #0
   1d1a0:	611d      	str	r5, [r3, #16]
   1d1a2:	615a      	str	r2, [r3, #20]
   1d1a4:	bd38      	pop	{r3, r4, r5, pc}
   1d1a6:	bf00      	nop
   1d1a8:	2000e4e4 	.word	0x2000e4e4
   1d1ac:	abcd330e 	.word	0xabcd330e
   1d1b0:	e66d1234 	.word	0xe66d1234
   1d1b4:	0005deec 	.word	0x0005deec

Disassembly of section .text.std%571:

0001d1b8 <std>:
   1d1b8:	2300      	movs	r3, #0
   1d1ba:	b510      	push	{r4, lr}
   1d1bc:	4604      	mov	r4, r0
   1d1be:	e9c0 3300 	strd	r3, r3, [r0]
   1d1c2:	6083      	str	r3, [r0, #8]
   1d1c4:	8181      	strh	r1, [r0, #12]
   1d1c6:	6603      	str	r3, [r0, #96]	; 0x60
   1d1c8:	81c2      	strh	r2, [r0, #14]
   1d1ca:	e9c0 3304 	strd	r3, r3, [r0, #16]
   1d1ce:	6183      	str	r3, [r0, #24]
   1d1d0:	4619      	mov	r1, r3
   1d1d2:	2208      	movs	r2, #8
   1d1d4:	3058      	adds	r0, #88	; 0x58
   1d1d6:	f004 fd59 	bl	21c8c <memset>
   1d1da:	4b05      	ldr	r3, [pc, #20]	; (1d1f0 <std+0x38>)
   1d1dc:	6263      	str	r3, [r4, #36]	; 0x24
   1d1de:	4b05      	ldr	r3, [pc, #20]	; (1d1f4 <std+0x3c>)
   1d1e0:	62a3      	str	r3, [r4, #40]	; 0x28
   1d1e2:	4b05      	ldr	r3, [pc, #20]	; (1d1f8 <std+0x40>)
   1d1e4:	62e3      	str	r3, [r4, #44]	; 0x2c
   1d1e6:	4b05      	ldr	r3, [pc, #20]	; (1d1fc <std+0x44>)
   1d1e8:	6224      	str	r4, [r4, #32]
   1d1ea:	6323      	str	r3, [r4, #48]	; 0x30
   1d1ec:	bd10      	pop	{r4, pc}
   1d1ee:	bf00      	nop
   1d1f0:	0002084f 	.word	0x0002084f
   1d1f4:	0001e90d 	.word	0x0001e90d
   1d1f8:	000206f1 	.word	0x000206f1
   1d1fc:	00022211 	.word	0x00022211

Disassembly of section .text.__swhatbuf_r%572:

0001d200 <__swhatbuf_r>:
   1d200:	b570      	push	{r4, r5, r6, lr}
   1d202:	460e      	mov	r6, r1
   1d204:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   1d208:	2900      	cmp	r1, #0
   1d20a:	b090      	sub	sp, #64	; 0x40
   1d20c:	4614      	mov	r4, r2
   1d20e:	461d      	mov	r5, r3
   1d210:	da07      	bge.n	1d222 <__swhatbuf_r+0x22>
   1d212:	2300      	movs	r3, #0
   1d214:	602b      	str	r3, [r5, #0]
   1d216:	89b3      	ldrh	r3, [r6, #12]
   1d218:	061a      	lsls	r2, r3, #24
   1d21a:	d410      	bmi.n	1d23e <__swhatbuf_r+0x3e>
   1d21c:	f44f 6380 	mov.w	r3, #1024	; 0x400
   1d220:	e00e      	b.n	1d240 <__swhatbuf_r+0x40>
   1d222:	aa01      	add	r2, sp, #4
   1d224:	f003 fa88 	bl	20738 <_fstat_r>
   1d228:	2800      	cmp	r0, #0
   1d22a:	dbf2      	blt.n	1d212 <__swhatbuf_r+0x12>
   1d22c:	9a02      	ldr	r2, [sp, #8]
   1d22e:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
   1d232:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
   1d236:	425a      	negs	r2, r3
   1d238:	415a      	adcs	r2, r3
   1d23a:	602a      	str	r2, [r5, #0]
   1d23c:	e7ee      	b.n	1d21c <__swhatbuf_r+0x1c>
   1d23e:	2340      	movs	r3, #64	; 0x40
   1d240:	2000      	movs	r0, #0
   1d242:	6023      	str	r3, [r4, #0]
   1d244:	b010      	add	sp, #64	; 0x40
   1d246:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.Lan867x_Write_Register%573:

0001d248 <Lan867x_Write_Register>:
{
   1d248:	b510      	push	{r4, lr}
   1d24a:	b082      	sub	sp, #8
   1d24c:	4604      	mov	r4, r0
   1d24e:	f8ad 2006 	strh.w	r2, [sp, #6]
    if (R2F(clientObj->vendorData, VENDOR_INTERNAL_STATE) == IDLE_PHASE) {
   1d252:	6843      	ldr	r3, [r0, #4]
   1d254:	0e5a      	lsrs	r2, r3, #25
   1d256:	d00f      	beq.n	1d278 <Lan867x_Write_Register+0x30>
    res = Lan867x_Miim_Task(clientObj, DRV_MIIM_OP_WRITE, regAddr, &wData);
   1d258:	f10d 0306 	add.w	r3, sp, #6
   1d25c:	460a      	mov	r2, r1
   1d25e:	2102      	movs	r1, #2
   1d260:	4620      	mov	r0, r4
   1d262:	f7f1 fd63 	bl	ed2c <Lan867x_Miim_Task>
    if (res == DRV_MIIM_RES_OK) {
   1d266:	4603      	mov	r3, r0
   1d268:	b918      	cbnz	r0, 1d272 <Lan867x_Write_Register+0x2a>
        clientObj->vendorData = F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   1d26a:	6862      	ldr	r2, [r4, #4]
   1d26c:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   1d270:	6062      	str	r2, [r4, #4]
}
   1d272:	4618      	mov	r0, r3
   1d274:	b002      	add	sp, #8
   1d276:	bd10      	pop	{r4, pc}
            F2R(initialState, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   1d278:	291f      	cmp	r1, #31
   1d27a:	bf94      	ite	ls
   1d27c:	f04f 6280 	movls.w	r2, #67108864	; 0x4000000
   1d280:	f04f 6200 	movhi.w	r2, #134217728	; 0x8000000
   1d284:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
        clientObj->vendorData = F2R(false, VENDOR_IS_BIT_OP, clientObj->vendorData);
   1d288:	4313      	orrs	r3, r2
   1d28a:	6043      	str	r3, [r0, #4]
   1d28c:	e7e4      	b.n	1d258 <Lan867x_Write_Register+0x10>

Disassembly of section .text._DRV_GMAC_LinkStateGetLink%574:

0001d28e <_DRV_GMAC_LinkStateGetLink>:
{
   1d28e:	b538      	push	{r3, r4, r5, lr}
   1d290:	4604      	mov	r4, r0
	pPhyBase =  pMACDrv->sGmacData.gmacConfig.pPhyBase;
   1d292:	f8d0 50d8 	ldr.w	r5, [r0, #216]	; 0xd8
	phyStat = pPhyBase->DRV_ETHPHY_ClientStatus( pMACDrv->sGmacData.hPhyClient );
   1d296:	69eb      	ldr	r3, [r5, #28]
   1d298:	6900      	ldr	r0, [r0, #16]
   1d29a:	4798      	blx	r3
	if(phyStat == DRV_ETHPHY_CLIENT_STATUS_BUSY)
   1d29c:	2801      	cmp	r0, #1
   1d29e:	d010      	beq.n	1d2c2 <_DRV_GMAC_LinkStateGetLink+0x34>
	phyRes = pPhyBase->DRV_ETHPHY_ClientOperationResult(pMACDrv->sGmacData.hPhyClient);
   1d2a0:	6a2b      	ldr	r3, [r5, #32]
   1d2a2:	6920      	ldr	r0, [r4, #16]
   1d2a4:	4798      	blx	r3
	if(phyRes != DRV_ETHPHY_RES_OK)
   1d2a6:	b968      	cbnz	r0, 1d2c4 <_DRV_GMAC_LinkStateGetLink+0x36>
	if(linkCurrUp == false)
   1d2a8:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
   1d2ac:	f013 0f01 	tst.w	r3, #1
   1d2b0:	d00c      	beq.n	1d2cc <_DRV_GMAC_LinkStateGetLink+0x3e>
	if( (bool) pMACDrv->sGmacData._macFlags._linkPrev == linkCurrUp )
   1d2b2:	7da3      	ldrb	r3, [r4, #22]
   1d2b4:	f013 0f10 	tst.w	r3, #16
		pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_START_LINK;
   1d2b8:	bf14      	ite	ne
   1d2ba:	2300      	movne	r3, #0
		pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_WAIT_LINK_UP;
   1d2bc:	2302      	moveq	r3, #2
   1d2be:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
}
   1d2c2:	bd38      	pop	{r3, r4, r5, pc}
		_DRV_GMAC_LinkStateDown(pMACDrv);
   1d2c4:	4620      	mov	r0, r4
   1d2c6:	f003 fd13 	bl	20cf0 <_DRV_GMAC_LinkStateDown>
		return;
   1d2ca:	e7fa      	b.n	1d2c2 <_DRV_GMAC_LinkStateGetLink+0x34>
		_DRV_GMAC_LinkStateDown(pMACDrv);
   1d2cc:	4620      	mov	r0, r4
   1d2ce:	f003 fd0f 	bl	20cf0 <_DRV_GMAC_LinkStateDown>
		return;
   1d2d2:	e7f6      	b.n	1d2c2 <_DRV_GMAC_LinkStateGetLink+0x34>

Disassembly of section .text.TCPIP_TCP_FifoTxFullGet%575:

0001d2d4 <TCPIP_TCP_FifoTxFullGet>:
{
   1d2d4:	b510      	push	{r4, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   1d2d6:	f002 fda1 	bl	1fe1c <_TcpSocketChk>
    if(pSkt != 0 && _TCP_TxPktValid(pSkt))
   1d2da:	b1d0      	cbz	r0, 1d312 <TCPIP_TCP_FifoTxFullGet+0x3e>
   1d2dc:	4604      	mov	r4, r0
    switch(pSkt->addType)
   1d2de:	f890 306f 	ldrb.w	r3, [r0, #111]	; 0x6f
   1d2e2:	2b01      	cmp	r3, #1
   1d2e4:	d001      	beq.n	1d2ea <TCPIP_TCP_FifoTxFullGet+0x16>
    return 0;
   1d2e6:	2000      	movs	r0, #0
}
   1d2e8:	bd10      	pop	{r4, pc}
    if(pSkt != 0 && _TCP_TxPktValid(pSkt))
   1d2ea:	6c43      	ldr	r3, [r0, #68]	; 0x44
   1d2ec:	b19b      	cbz	r3, 1d316 <TCPIP_TCP_FifoTxFullGet+0x42>
        if((pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED) || (pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT))
   1d2ee:	f890 306e 	ldrb.w	r3, [r0, #110]	; 0x6e
   1d2f2:	2b03      	cmp	r3, #3
   1d2f4:	d003      	beq.n	1d2fe <TCPIP_TCP_FifoTxFullGet+0x2a>
   1d2f6:	2b08      	cmp	r3, #8
   1d2f8:	d001      	beq.n	1d2fe <TCPIP_TCP_FifoTxFullGet+0x2a>
    return 0;
   1d2fa:	2000      	movs	r0, #0
   1d2fc:	e7f4      	b.n	1d2e8 <TCPIP_TCP_FifoTxFullGet+0x14>
            wDataLen = _TCPSocketTxFreeSize(pSkt);
   1d2fe:	4620      	mov	r0, r4
   1d300:	f001 ff0a 	bl	1f118 <_TCPSocketTxFreeSize>
            wFIFOSize = pSkt->txEnd - pSkt->txStart - 1;
   1d304:	6863      	ldr	r3, [r4, #4]
   1d306:	6822      	ldr	r2, [r4, #0]
   1d308:	1a9b      	subs	r3, r3, r2
   1d30a:	3b01      	subs	r3, #1
            return wFIFOSize - wDataLen;
   1d30c:	1a18      	subs	r0, r3, r0
   1d30e:	b280      	uxth	r0, r0
   1d310:	e7ea      	b.n	1d2e8 <TCPIP_TCP_FifoTxFullGet+0x14>
    return 0;
   1d312:	2000      	movs	r0, #0
   1d314:	e7e8      	b.n	1d2e8 <TCPIP_TCP_FifoTxFullGet+0x14>
   1d316:	2000      	movs	r0, #0
   1d318:	e7e6      	b.n	1d2e8 <TCPIP_TCP_FifoTxFullGet+0x14>

Disassembly of section .text.TCPIP_ARP_Resolve%576:

0001d31a <TCPIP_ARP_Resolve>:
    if(IPAddr == 0 || IPAddr->Val == 0)
   1d31a:	b1a9      	cbz	r1, 1d348 <TCPIP_ARP_Resolve+0x2e>
{
   1d31c:	b530      	push	{r4, r5, lr}
   1d31e:	b083      	sub	sp, #12
   1d320:	460c      	mov	r4, r1
    if(IPAddr == 0 || IPAddr->Val == 0)
   1d322:	680a      	ldr	r2, [r1, #0]
   1d324:	b19a      	cbz	r2, 1d34e <TCPIP_ARP_Resolve+0x34>
    pIf = _TCPIPStackHandleToNetLinked(hNet);
   1d326:	f003 fbf3 	bl	20b10 <_TCPIPStackHandleToNetLinked>
    if(pIf == 0)
   1d32a:	b198      	cbz	r0, 1d354 <TCPIP_ARP_Resolve+0x3a>
    return pNetIf->Flags.bInConfig != 0;
   1d32c:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
    if(_TCPIPStackIsConfig(pIf))
   1d330:	f013 0f10 	tst.w	r3, #16
   1d334:	d111      	bne.n	1d35a <TCPIP_ARP_Resolve+0x40>
    return _ARPProbeAddress(pIf, IPAddr, &pIf->netIPAddr, ARP_OPERATION_REQ, 0);
   1d336:	2300      	movs	r3, #0
   1d338:	9300      	str	r3, [sp, #0]
   1d33a:	2301      	movs	r3, #1
   1d33c:	1d02      	adds	r2, r0, #4
   1d33e:	4621      	mov	r1, r4
   1d340:	f7f7 fc80 	bl	14c44 <_ARPProbeAddress>
}
   1d344:	b003      	add	sp, #12
   1d346:	bd30      	pop	{r4, r5, pc}
        return ARP_RES_BAD_ADDRESS;
   1d348:	f06f 0004 	mvn.w	r0, #4
}
   1d34c:	4770      	bx	lr
        return ARP_RES_BAD_ADDRESS;
   1d34e:	f06f 0004 	mvn.w	r0, #4
   1d352:	e7f7      	b.n	1d344 <TCPIP_ARP_Resolve+0x2a>
        return ARP_RES_NO_INTERFACE;
   1d354:	f06f 0005 	mvn.w	r0, #5
   1d358:	e7f4      	b.n	1d344 <TCPIP_ARP_Resolve+0x2a>
        return ARP_RES_CONFIGURE_ERR;
   1d35a:	f06f 0007 	mvn.w	r0, #7
   1d35e:	e7f1      	b.n	1d344 <TCPIP_ARP_Resolve+0x2a>

Disassembly of section .text._TCPIP_HEAP_Delete%577:

0001d360 <_TCPIP_HEAP_Delete>:
    if(hInst == 0)
   1d360:	b1f0      	cbz	r0, 1d3a0 <_TCPIP_HEAP_Delete+0x40>
{
   1d362:	b510      	push	{r4, lr}
   1d364:	4604      	mov	r4, r0
    if(hDcpt->_heapHead)
   1d366:	6a43      	ldr	r3, [r0, #36]	; 0x24
   1d368:	b1a3      	cbz	r3, 1d394 <_TCPIP_HEAP_Delete+0x34>
        if(hDcpt->_heapAllocatedUnits != 0)
   1d36a:	6b03      	ldr	r3, [r0, #48]	; 0x30
   1d36c:	b963      	cbnz	r3, 1d388 <_TCPIP_HEAP_Delete+0x28>
        OSAL_SEM_Delete(&hDcpt->_heapSemaphore);
   1d36e:	3044      	adds	r0, #68	; 0x44
   1d370:	f004 fb8c 	bl	21a8c <OSAL_SEM_Delete>
        memset(&hInst->heapObj, 0, sizeof(hInst->heapObj));
   1d374:	2224      	movs	r2, #36	; 0x24
   1d376:	2100      	movs	r1, #0
   1d378:	4620      	mov	r0, r4
   1d37a:	f004 fc87 	bl	21c8c <memset>
        (*hDcpt->free_fnc)(hDcpt->allocatedBuffer);
   1d37e:	6c23      	ldr	r3, [r4, #64]	; 0x40
   1d380:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1d382:	4798      	blx	r3
        return TCPIP_STACK_HEAP_RES_OK;
   1d384:	2000      	movs	r0, #0
}
   1d386:	bd10      	pop	{r4, pc}
            return (hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_IN_USE); 
   1d388:	23f9      	movs	r3, #249	; 0xf9
   1d38a:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
   1d38e:	f06f 0006 	mvn.w	r0, #6
   1d392:	e7f8      	b.n	1d386 <_TCPIP_HEAP_Delete+0x26>
    return (hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_IN_USE); 
   1d394:	23f9      	movs	r3, #249	; 0xf9
   1d396:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
   1d39a:	f06f 0006 	mvn.w	r0, #6
   1d39e:	e7f2      	b.n	1d386 <_TCPIP_HEAP_Delete+0x26>
        return TCPIP_STACK_HEAP_RES_NO_HEAP; 
   1d3a0:	f06f 0008 	mvn.w	r0, #8
}
   1d3a4:	4770      	bx	lr

Disassembly of section .text.TCPIP_Helper_SingleListNodeRemove%578:

0001d3a6 <TCPIP_Helper_SingleListNodeRemove>:
// Use a double linked list if faster operation needed!



SGL_LIST_NODE*  TCPIP_Helper_SingleListNodeRemove(SINGLE_LIST* pL, SGL_LIST_NODE* pN)
{
   1d3a6:	b510      	push	{r4, lr}
    if(pN == pL->head)
   1d3a8:	6802      	ldr	r2, [r0, #0]
   1d3aa:	428a      	cmp	r2, r1
   1d3ac:	d00b      	beq.n	1d3c6 <TCPIP_Helper_SingleListNodeRemove+0x20>
        TCPIP_Helper_SingleListHeadRemove(pL);
    }
    else
    {
        SGL_LIST_NODE* prev;
        for(prev = pL->head; prev != 0 && prev->next != pN; prev = prev->next);
   1d3ae:	b182      	cbz	r2, 1d3d2 <TCPIP_Helper_SingleListNodeRemove+0x2c>
   1d3b0:	6814      	ldr	r4, [r2, #0]
   1d3b2:	42a1      	cmp	r1, r4
   1d3b4:	bf08      	it	eq
   1d3b6:	4614      	moveq	r4, r2
   1d3b8:	d00d      	beq.n	1d3d6 <TCPIP_Helper_SingleListNodeRemove+0x30>
   1d3ba:	b1ac      	cbz	r4, 1d3e8 <TCPIP_Helper_SingleListNodeRemove+0x42>
   1d3bc:	6822      	ldr	r2, [r4, #0]
   1d3be:	428a      	cmp	r2, r1
   1d3c0:	d009      	beq.n	1d3d6 <TCPIP_Helper_SingleListNodeRemove+0x30>
   1d3c2:	4614      	mov	r4, r2
   1d3c4:	e7f9      	b.n	1d3ba <TCPIP_Helper_SingleListNodeRemove+0x14>
   1d3c6:	460c      	mov	r4, r1
        TCPIP_Helper_SingleListHeadRemove(pL);
   1d3c8:	f003 fda6 	bl	20f18 <TCPIP_Helper_SingleListHeadRemove>
   1d3cc:	e00c      	b.n	1d3e8 <TCPIP_Helper_SingleListNodeRemove+0x42>
        }
        // found it
        prev->next = pN->next;
        if(pN == pL->tail)
        {
            pL->tail = prev;
   1d3ce:	6044      	str	r4, [r0, #4]
   1d3d0:	e006      	b.n	1d3e0 <TCPIP_Helper_SingleListNodeRemove+0x3a>
            return 0;
   1d3d2:	4614      	mov	r4, r2
   1d3d4:	e008      	b.n	1d3e8 <TCPIP_Helper_SingleListNodeRemove+0x42>
        prev->next = pN->next;
   1d3d6:	680a      	ldr	r2, [r1, #0]
   1d3d8:	6022      	str	r2, [r4, #0]
        if(pN == pL->tail)
   1d3da:	6842      	ldr	r2, [r0, #4]
   1d3dc:	428a      	cmp	r2, r1
   1d3de:	d0f6      	beq.n	1d3ce <TCPIP_Helper_SingleListNodeRemove+0x28>
        }
        pL->nNodes--;
   1d3e0:	6883      	ldr	r3, [r0, #8]
   1d3e2:	3b01      	subs	r3, #1
   1d3e4:	6083      	str	r3, [r0, #8]
    }

    return pN;
   1d3e6:	460c      	mov	r4, r1
}
   1d3e8:	4620      	mov	r0, r4
   1d3ea:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_Notification_CbackRemove%579:

0001d3ec <TCPIP_Notification_CbackRemove>:
    return false;

}

bool TCPIP_Notification_CbackRemove(SGL_LIST_NODE* node, PROTECTED_SINGLE_LIST* notifyList, TCPIP_STACK_HEAP_HANDLE heapH, void (*pCback)(SGL_LIST_NODE* node))
{
   1d3ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d3f0:	4606      	mov	r6, r0
   1d3f2:	460c      	mov	r4, r1
   1d3f4:	4690      	mov	r8, r2
   1d3f6:	461f      	mov	r7, r3
    if(TCPIP_Helper_ProtectedSingleListLock(notifyList))
   1d3f8:	4608      	mov	r0, r1
   1d3fa:	f003 fb59 	bl	20ab0 <TCPIP_Helper_ProtectedSingleListLock>
   1d3fe:	4605      	mov	r5, r0
   1d400:	b910      	cbnz	r0, 1d408 <TCPIP_Notification_CbackRemove+0x1c>
            TCPIP_HEAP_Free(heapH, node);
            return true;
        }
    }
    return false;
}
   1d402:	4628      	mov	r0, r5
   1d404:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        SGL_LIST_NODE* ret = TCPIP_Helper_SingleListNodeRemove(&notifyList->list, node);
   1d408:	4631      	mov	r1, r6
   1d40a:	4620      	mov	r0, r4
   1d40c:	f7ff ffcb 	bl	1d3a6 <TCPIP_Helper_SingleListNodeRemove>
        if(ret && pCback)
   1d410:	b150      	cbz	r0, 1d428 <TCPIP_Notification_CbackRemove+0x3c>
   1d412:	b107      	cbz	r7, 1d416 <TCPIP_Notification_CbackRemove+0x2a>
            (*pCback)(ret);
   1d414:	47b8      	blx	r7
        TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
   1d416:	4620      	mov	r0, r4
   1d418:	f003 fd8c 	bl	20f34 <TCPIP_Helper_ProtectedSingleListUnlock>
   1d41c:	f8d8 300c 	ldr.w	r3, [r8, #12]
   1d420:	4631      	mov	r1, r6
   1d422:	4640      	mov	r0, r8
   1d424:	4798      	blx	r3
            return true;
   1d426:	e7ec      	b.n	1d402 <TCPIP_Notification_CbackRemove+0x16>
        TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
   1d428:	4620      	mov	r0, r4
   1d42a:	f003 fd83 	bl	20f34 <TCPIP_Helper_ProtectedSingleListUnlock>
    return false;
   1d42e:	2500      	movs	r5, #0
   1d430:	e7e7      	b.n	1d402 <TCPIP_Notification_CbackRemove+0x16>

Disassembly of section .text.TCPIP_UDP_SignalHandlerRegister%580:

0001d432 <TCPIP_UDP_SignalHandlerRegister>:

    return true;
}

TCPIP_UDP_SIGNAL_HANDLE TCPIP_UDP_SignalHandlerRegister(UDP_SOCKET s, TCPIP_UDP_SIGNAL_TYPE sigMask, TCPIP_UDP_SIGNAL_FUNCTION handler, const void* hParam)
{
   1d432:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d436:	4604      	mov	r4, r0
   1d438:	460f      	mov	r7, r1
   1d43a:	4615      	mov	r5, r2
   1d43c:	4698      	mov	r8, r3
    TCPIP_UDP_SIGNAL_HANDLE sHandle = 0;

    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1d43e:	2000      	movs	r0, #0
   1d440:	f004 f8bc 	bl	215bc <OSAL_CRIT_Enter>
   1d444:	4606      	mov	r6, r0
    if(handler != 0)
   1d446:	b19d      	cbz	r5, 1d470 <TCPIP_UDP_SignalHandlerRegister+0x3e>
    {
        UDP_SOCKET_DCPT *pSkt = _UDPSocketDcpt(s);
   1d448:	4620      	mov	r0, r4
   1d44a:	f002 fdeb 	bl	20024 <_UDPSocketDcpt>
        if(pSkt != 0 && pSkt->sigHandler == 0)
   1d44e:	4604      	mov	r4, r0
   1d450:	b138      	cbz	r0, 1d462 <TCPIP_UDP_SignalHandlerRegister+0x30>
   1d452:	6d03      	ldr	r3, [r0, #80]	; 0x50
   1d454:	b973      	cbnz	r3, 1d474 <TCPIP_UDP_SignalHandlerRegister+0x42>
        {
            pSkt->sigHandler = handler;
   1d456:	6505      	str	r5, [r0, #80]	; 0x50
            pSkt->sigParam = hParam;
   1d458:	f8c0 8054 	str.w	r8, [r0, #84]	; 0x54
            pSkt->sigMask = sigMask;
   1d45c:	f8a0 7058 	strh.w	r7, [r0, #88]	; 0x58
            sHandle = (TCPIP_UDP_SIGNAL_HANDLE)handler;
   1d460:	462c      	mov	r4, r5
            // Note: this may change if multiple notfication handlers required 
        }
    }

    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1d462:	4631      	mov	r1, r6
   1d464:	2000      	movs	r0, #0
   1d466:	f004 f9d8 	bl	2181a <OSAL_CRIT_Leave>
    return sHandle;
}
   1d46a:	4620      	mov	r0, r4
   1d46c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    TCPIP_UDP_SIGNAL_HANDLE sHandle = 0;
   1d470:	2400      	movs	r4, #0
   1d472:	e7f6      	b.n	1d462 <TCPIP_UDP_SignalHandlerRegister+0x30>
   1d474:	2400      	movs	r4, #0
   1d476:	e7f4      	b.n	1d462 <TCPIP_UDP_SignalHandlerRegister+0x30>

Disassembly of section .text.DRV_GMAC_ConfigGet%581:

0001d478 <DRV_GMAC_ConfigGet>:
{	
   1d478:	b430      	push	{r4, r5}
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1d47a:	4c0e      	ldr	r4, [pc, #56]	; (1d4b4 <DRV_GMAC_ConfigGet+0x3c>)
   1d47c:	4284      	cmp	r4, r0
   1d47e:	d114      	bne.n	1d4aa <DRV_GMAC_ConfigGet+0x32>
    if(pMACDrv != 0)
   1d480:	b1a0      	cbz	r0, 1d4ac <DRV_GMAC_ConfigGet+0x34>
        if(pConfigSize)
   1d482:	b10b      	cbz	r3, 1d488 <DRV_GMAC_ConfigGet+0x10>
            *pConfigSize =  sizeof(TCPIP_MODULE_MAC_PIC32C_CONFIG);
   1d484:	2034      	movs	r0, #52	; 0x34
   1d486:	6018      	str	r0, [r3, #0]
        if(configBuff && buffSize >= sizeof(TCPIP_MODULE_MAC_PIC32C_CONFIG))
   1d488:	b191      	cbz	r1, 1d4b0 <DRV_GMAC_ConfigGet+0x38>
   1d48a:	2a33      	cmp	r2, #51	; 0x33
   1d48c:	d801      	bhi.n	1d492 <DRV_GMAC_ConfigGet+0x1a>
    return 0;
   1d48e:	2000      	movs	r0, #0
   1d490:	e00c      	b.n	1d4ac <DRV_GMAC_ConfigGet+0x34>
            *pMacConfig = pMACDrv->sGmacData.gmacConfig;
   1d492:	460c      	mov	r4, r1
   1d494:	4d08      	ldr	r5, [pc, #32]	; (1d4b8 <DRV_GMAC_ConfigGet+0x40>)
   1d496:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1d498:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1d49a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1d49c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1d49e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1d4a0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1d4a2:	682b      	ldr	r3, [r5, #0]
   1d4a4:	6023      	str	r3, [r4, #0]
            return sizeof(TCPIP_MODULE_MAC_PIC32C_CONFIG);
   1d4a6:	2034      	movs	r0, #52	; 0x34
   1d4a8:	e000      	b.n	1d4ac <DRV_GMAC_ConfigGet+0x34>
    return 0;
   1d4aa:	2000      	movs	r0, #0
}
   1d4ac:	bc30      	pop	{r4, r5}
   1d4ae:	4770      	bx	lr
    return 0;
   1d4b0:	2000      	movs	r0, #0
   1d4b2:	e7fb      	b.n	1d4ac <DRV_GMAC_ConfigGet+0x34>
   1d4b4:	2000d8b8 	.word	0x2000d8b8
   1d4b8:	2000d970 	.word	0x2000d970

Disassembly of section .text._MacTxDiscardQueues%582:

0001d4bc <_MacTxDiscardQueues>:
{
   1d4bc:	b570      	push	{r4, r5, r6, lr}
   1d4be:	4605      	mov	r5, r0
   1d4c0:	460e      	mov	r6, r1
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_TXEN_Msk;           
   1d4c2:	4c0e      	ldr	r4, [pc, #56]	; (1d4fc <_MacTxDiscardQueues+0x40>)
   1d4c4:	6823      	ldr	r3, [r4, #0]
   1d4c6:	f023 0308 	bic.w	r3, r3, #8
   1d4ca:	6023      	str	r3, [r4, #0]
    GMAC_REGS->GMAC_TSR = GMAC_TSR_TXCOMP_Msk;
   1d4cc:	2320      	movs	r3, #32
   1d4ce:	6163      	str	r3, [r4, #20]
    DRV_PIC32CGMAC_LibTxAckPacket(pMACDrv,queueIdx);
   1d4d0:	2100      	movs	r1, #0
   1d4d2:	f7f3 ff5b 	bl	1138c <DRV_PIC32CGMAC_LibTxAckPacket>
        DRV_PIC32CGMAC_LibTxAckErrPacket(pMACDrv, queueIdx, ackRes); 
   1d4d6:	4632      	mov	r2, r6
   1d4d8:	2100      	movs	r1, #0
   1d4da:	4628      	mov	r0, r5
   1d4dc:	f7fb fe1c 	bl	19118 <DRV_PIC32CGMAC_LibTxAckErrPacket>
        DRV_PIC32CGMAC_LibTxAckPendPacket(pMACDrv, queueIdx, ackRes);  
   1d4e0:	4632      	mov	r2, r6
   1d4e2:	2100      	movs	r1, #0
   1d4e4:	4628      	mov	r0, r5
   1d4e6:	f001 fd54 	bl	1ef92 <DRV_PIC32CGMAC_LibTxAckPendPacket>
        DRV_PIC32CGMAC_LibTxInit(pMACDrv);
   1d4ea:	4628      	mov	r0, r5
   1d4ec:	f7fc fb08 	bl	19b00 <DRV_PIC32CGMAC_LibTxInit>
    GMAC_REGS->GMAC_NCR |= GMAC_NCR_TXEN_Msk; 
   1d4f0:	6823      	ldr	r3, [r4, #0]
   1d4f2:	f043 0308 	orr.w	r3, r3, #8
   1d4f6:	6023      	str	r3, [r4, #0]
}
   1d4f8:	bd70      	pop	{r4, r5, r6, pc}
   1d4fa:	bf00      	nop
   1d4fc:	42000800 	.word	0x42000800

Disassembly of section .text.Helper_SingleListNodeRemove%583:

0001d500 <Helper_SingleListNodeRemove>:
// Use a double linked list if faster operation needed!



SGL_LIST_NODE*  Helper_SingleListNodeRemove(SINGLE_LIST* pL, SGL_LIST_NODE* pN)
{
   1d500:	b508      	push	{r3, lr}
    if(pN == pL->head)
   1d502:	6803      	ldr	r3, [r0, #0]
   1d504:	428b      	cmp	r3, r1
   1d506:	d00c      	beq.n	1d522 <Helper_SingleListNodeRemove+0x22>
   1d508:	4602      	mov	r2, r0
        return Helper_SingleListHeadRemove(pL);
    }
    else
    {
        SGL_LIST_NODE* prev;
        for(prev = pL->head; prev != 0 && prev->next != pN; prev = prev->next);
   1d50a:	b17b      	cbz	r3, 1d52c <Helper_SingleListNodeRemove+0x2c>
   1d50c:	6818      	ldr	r0, [r3, #0]
   1d50e:	4281      	cmp	r1, r0
   1d510:	bf08      	it	eq
   1d512:	4618      	moveq	r0, r3
   1d514:	d00c      	beq.n	1d530 <Helper_SingleListNodeRemove+0x30>
   1d516:	b1a0      	cbz	r0, 1d542 <Helper_SingleListNodeRemove+0x42>
   1d518:	6803      	ldr	r3, [r0, #0]
   1d51a:	428b      	cmp	r3, r1
   1d51c:	d008      	beq.n	1d530 <Helper_SingleListNodeRemove+0x30>
   1d51e:	4618      	mov	r0, r3
   1d520:	e7f9      	b.n	1d516 <Helper_SingleListNodeRemove+0x16>
        return Helper_SingleListHeadRemove(pL);
   1d522:	f003 fcb3 	bl	20e8c <Helper_SingleListHeadRemove>
   1d526:	e00c      	b.n	1d542 <Helper_SingleListNodeRemove+0x42>
        }
        // found it
        prev->next = pN->next;
        if(pN == pL->tail)
        {
            pL->tail = prev;
   1d528:	6050      	str	r0, [r2, #4]
   1d52a:	e006      	b.n	1d53a <Helper_SingleListNodeRemove+0x3a>
            return 0;
   1d52c:	4618      	mov	r0, r3
   1d52e:	e008      	b.n	1d542 <Helper_SingleListNodeRemove+0x42>
        prev->next = pN->next;
   1d530:	680b      	ldr	r3, [r1, #0]
   1d532:	6003      	str	r3, [r0, #0]
        if(pN == pL->tail)
   1d534:	6853      	ldr	r3, [r2, #4]
   1d536:	428b      	cmp	r3, r1
   1d538:	d0f6      	beq.n	1d528 <Helper_SingleListNodeRemove+0x28>
        }
        pL->nNodes--;
   1d53a:	6893      	ldr	r3, [r2, #8]
   1d53c:	3b01      	subs	r3, #1
   1d53e:	6093      	str	r3, [r2, #8]
    }

    return pN;
   1d540:	4608      	mov	r0, r1
}
   1d542:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_TCP_SignalHandlerRegister%584:

0001d544 <TCPIP_TCP_SignalHandlerRegister>:
    }
}


TCPIP_TCP_SIGNAL_HANDLE TCPIP_TCP_SignalHandlerRegister(TCP_SOCKET s, TCPIP_TCP_SIGNAL_TYPE sigMask, TCPIP_TCP_SIGNAL_FUNCTION handler, const void* hParam)
{
   1d544:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d548:	4604      	mov	r4, r0
   1d54a:	4688      	mov	r8, r1
   1d54c:	4615      	mov	r5, r2
   1d54e:	461f      	mov	r7, r3
    TCPIP_TCP_SIGNAL_HANDLE sHandle = 0;

    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1d550:	2000      	movs	r0, #0
   1d552:	f004 f833 	bl	215bc <OSAL_CRIT_Enter>
   1d556:	4606      	mov	r6, r0
    if(handler != 0)
   1d558:	b195      	cbz	r5, 1d580 <TCPIP_TCP_SignalHandlerRegister+0x3c>
    {
        TCB_STUB* pSkt = _TcpSocketChk(s);
   1d55a:	4620      	mov	r0, r4
   1d55c:	f002 fc5e 	bl	1fe1c <_TcpSocketChk>
        if(pSkt != 0 && pSkt->sigHandler == 0)
   1d560:	4604      	mov	r4, r0
   1d562:	b130      	cbz	r0, 1d572 <TCPIP_TCP_SignalHandlerRegister+0x2e>
   1d564:	6f43      	ldr	r3, [r0, #116]	; 0x74
   1d566:	b96b      	cbnz	r3, 1d584 <TCPIP_TCP_SignalHandlerRegister+0x40>
        {
            pSkt->sigHandler = handler;
   1d568:	6745      	str	r5, [r0, #116]	; 0x74
            pSkt->sigMask = (uint16_t)sigMask;
   1d56a:	f8a0 8072 	strh.w	r8, [r0, #114]	; 0x72
            pSkt->sigParam = hParam;
   1d56e:	6787      	str	r7, [r0, #120]	; 0x78
            sHandle = (TCPIP_TCP_SIGNAL_HANDLE)handler;
   1d570:	462c      	mov	r4, r5
            // Note: this may change if multiple notfication handlers required 
        }
    }
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1d572:	4631      	mov	r1, r6
   1d574:	2000      	movs	r0, #0
   1d576:	f004 f950 	bl	2181a <OSAL_CRIT_Leave>

    return sHandle;
}
   1d57a:	4620      	mov	r0, r4
   1d57c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    TCPIP_TCP_SIGNAL_HANDLE sHandle = 0;
   1d580:	2400      	movs	r4, #0
   1d582:	e7f6      	b.n	1d572 <TCPIP_TCP_SignalHandlerRegister+0x2e>
   1d584:	2400      	movs	r4, #0
   1d586:	e7f4      	b.n	1d572 <TCPIP_TCP_SignalHandlerRegister+0x2e>

Disassembly of section .text.TCPIP_Helper_MACAddressToString%585:

0001d588 <TCPIP_Helper_MACAddressToString>:
    if(macAddr && buff && buffSize >= 18)
   1d588:	b1d0      	cbz	r0, 1d5c0 <TCPIP_Helper_MACAddressToString+0x38>
   1d58a:	4603      	mov	r3, r0
   1d58c:	b1d1      	cbz	r1, 1d5c4 <TCPIP_Helper_MACAddressToString+0x3c>
   1d58e:	2a11      	cmp	r2, #17
   1d590:	d801      	bhi.n	1d596 <TCPIP_Helper_MACAddressToString+0xe>
    return false;
   1d592:	2000      	movs	r0, #0
}
   1d594:	4770      	bx	lr
{
   1d596:	b500      	push	{lr}
   1d598:	b085      	sub	sp, #20
   1d59a:	4602      	mov	r2, r0
   1d59c:	4608      	mov	r0, r1
        sprintf(buff, "%.2x:%.2x:%.2x:%.2x:%.2x:%.2x", *pAdd, *(pAdd+1), *(pAdd+2), *(pAdd+3), *(pAdd+4), *(pAdd+5));
   1d59e:	795b      	ldrb	r3, [r3, #5]
   1d5a0:	9303      	str	r3, [sp, #12]
   1d5a2:	7913      	ldrb	r3, [r2, #4]
   1d5a4:	9302      	str	r3, [sp, #8]
   1d5a6:	78d3      	ldrb	r3, [r2, #3]
   1d5a8:	9301      	str	r3, [sp, #4]
   1d5aa:	7893      	ldrb	r3, [r2, #2]
   1d5ac:	9300      	str	r3, [sp, #0]
   1d5ae:	7853      	ldrb	r3, [r2, #1]
   1d5b0:	7812      	ldrb	r2, [r2, #0]
   1d5b2:	4905      	ldr	r1, [pc, #20]	; (1d5c8 <TCPIP_Helper_MACAddressToString+0x40>)
   1d5b4:	f000 f8f8 	bl	1d7a8 <siprintf>
        return true;
   1d5b8:	2001      	movs	r0, #1
}
   1d5ba:	b005      	add	sp, #20
   1d5bc:	f85d fb04 	ldr.w	pc, [sp], #4
    return false;
   1d5c0:	2000      	movs	r0, #0
   1d5c2:	4770      	bx	lr
   1d5c4:	2000      	movs	r0, #0
   1d5c6:	4770      	bx	lr
   1d5c8:	0001db80 	.word	0x0001db80

Disassembly of section .text.TCPIP_STACK_NetByAddress%586:

0001d5cc <TCPIP_STACK_NetByAddress>:
{
   1d5cc:	b430      	push	{r4, r5}
    for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1d5ce:	4b0e      	ldr	r3, [pc, #56]	; (1d608 <TCPIP_STACK_NetByAddress+0x3c>)
   1d5d0:	681b      	ldr	r3, [r3, #0]
   1d5d2:	4a0e      	ldr	r2, [pc, #56]	; (1d60c <TCPIP_STACK_NetByAddress+0x40>)
   1d5d4:	6814      	ldr	r4, [r2, #0]
   1d5d6:	2c00      	cmp	r4, #0
   1d5d8:	dd13      	ble.n	1d602 <TCPIP_STACK_NetByAddress+0x36>
   1d5da:	2200      	movs	r2, #0
   1d5dc:	e003      	b.n	1d5e6 <TCPIP_STACK_NetByAddress+0x1a>
   1d5de:	3201      	adds	r2, #1
   1d5e0:	336c      	adds	r3, #108	; 0x6c
   1d5e2:	42a2      	cmp	r2, r4
   1d5e4:	d009      	beq.n	1d5fa <TCPIP_STACK_NetByAddress+0x2e>
        if(pIf->Flags.bInterfaceEnabled && pIf->netIPAddr.Val == pIpAddress->Val)
   1d5e6:	f893 1042 	ldrb.w	r1, [r3, #66]	; 0x42
   1d5ea:	f011 0f40 	tst.w	r1, #64	; 0x40
   1d5ee:	d0f6      	beq.n	1d5de <TCPIP_STACK_NetByAddress+0x12>
   1d5f0:	685d      	ldr	r5, [r3, #4]
   1d5f2:	6801      	ldr	r1, [r0, #0]
   1d5f4:	428d      	cmp	r5, r1
   1d5f6:	d1f2      	bne.n	1d5de <TCPIP_STACK_NetByAddress+0x12>
   1d5f8:	e000      	b.n	1d5fc <TCPIP_STACK_NetByAddress+0x30>
    return 0;
   1d5fa:	2300      	movs	r3, #0
}
   1d5fc:	4618      	mov	r0, r3
   1d5fe:	bc30      	pop	{r4, r5}
   1d600:	4770      	bx	lr
    return 0;
   1d602:	2300      	movs	r3, #0
   1d604:	e7fa      	b.n	1d5fc <TCPIP_STACK_NetByAddress+0x30>
   1d606:	bf00      	nop
   1d608:	2000e440 	.word	0x2000e440
   1d60c:	2000e0f0 	.word	0x2000e0f0

Disassembly of section .text.TCPIP_STACK_AddressServiceEvent%587:

0001d610 <TCPIP_STACK_AddressServiceEvent>:
{
   1d610:	b508      	push	{r3, lr}
    if(evType == TCPIP_STACK_ADDRESS_SERVICE_EVENT_RUN_RESTORE)
   1d612:	2a04      	cmp	r2, #4
   1d614:	d015      	beq.n	1d642 <TCPIP_STACK_AddressServiceEvent+0x32>
    else if(evType == TCPIP_STACK_ADDRESS_SERVICE_EVENT_CONN_LOST)
   1d616:	2a02      	cmp	r2, #2
   1d618:	d012      	beq.n	1d640 <TCPIP_STACK_AddressServiceEvent+0x30>
    else if(adSvcType == TCPIP_STACK_ADDRESS_SERVICE_DHCPS)
   1d61a:	2903      	cmp	r1, #3
   1d61c:	d010      	beq.n	1d640 <TCPIP_STACK_AddressServiceEvent+0x30>
    pNetIf->Flags.v &= ~TCPIP_STACK_ADDRESS_SERVICE_MASK;
   1d61e:	f8b0 3042 	ldrh.w	r3, [r0, #66]	; 0x42
   1d622:	f023 0307 	bic.w	r3, r3, #7
   1d626:	f8a0 3042 	strh.w	r3, [r0, #66]	; 0x42
    pNetIf->Flags.bInConfig = config;
   1d62a:	0a1b      	lsrs	r3, r3, #8
   1d62c:	f043 0310 	orr.w	r3, r3, #16
   1d630:	f880 3043 	strb.w	r3, [r0, #67]	; 0x43
    pNetIf->dnsServer[0].Val = pNetIf->DefaultDNSServer[0].Val;
   1d634:	6a43      	ldr	r3, [r0, #36]	; 0x24
   1d636:	6103      	str	r3, [r0, #16]
    pNetIf->dnsServer[1].Val = pNetIf->DefaultDNSServer[1].Val;
   1d638:	6a83      	ldr	r3, [r0, #40]	; 0x28
   1d63a:	6143      	str	r3, [r0, #20]
    TCPIP_STACK_AddressServiceDefaultSet(pNetIf);
   1d63c:	f000 fc78 	bl	1df30 <TCPIP_STACK_AddressServiceDefaultSet>
}
   1d640:	bd08      	pop	{r3, pc}
        if(adSvcType == TCPIP_STACK_ADDRESS_SERVICE_DHCPC)
   1d642:	2901      	cmp	r1, #1
   1d644:	d1eb      	bne.n	1d61e <TCPIP_STACK_AddressServiceEvent+0xe>
            pNetIf->Flags.bIsDHCPEnabled = 1;
   1d646:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   1d64a:	f043 0301 	orr.w	r3, r3, #1
   1d64e:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
            return;
   1d652:	e7f5      	b.n	1d640 <TCPIP_STACK_AddressServiceEvent+0x30>

Disassembly of section .text._TCPIPStackModuleRxInsert%588:

0001d654 <_TCPIPStackModuleRxInsert>:
{
   1d654:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1d656:	4604      	mov	r4, r0
   1d658:	460f      	mov	r7, r1
   1d65a:	4615      	mov	r5, r2
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1d65c:	2000      	movs	r0, #0
   1d65e:	f003 ffad 	bl	215bc <OSAL_CRIT_Enter>
   1d662:	4606      	mov	r6, r0
    SINGLE_LIST* pQueue = TCPIP_MODULES_QUEUE_TBL + modId;
   1d664:	eb04 0044 	add.w	r0, r4, r4, lsl #1
    TCPIP_Helper_SingleListTailAdd(pQueue, (SGL_LIST_NODE*)pRxPkt);
   1d668:	4639      	mov	r1, r7
   1d66a:	4b09      	ldr	r3, [pc, #36]	; (1d690 <_TCPIPStackModuleRxInsert+0x3c>)
   1d66c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1d670:	f003 fe26 	bl	212c0 <TCPIP_Helper_SingleListTailAdd>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1d674:	4631      	mov	r1, r6
   1d676:	2000      	movs	r0, #0
   1d678:	f004 f8cf 	bl	2181a <OSAL_CRIT_Leave>
    if(signal)
   1d67c:	b905      	cbnz	r5, 1d680 <_TCPIPStackModuleRxInsert+0x2c>
}
   1d67e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    _TCPIPSignalEntrySetNotify(_TCPIPModuleToSignalEntry(modId), signals, 0);
   1d680:	2200      	movs	r2, #0
   1d682:	2101      	movs	r1, #1
   1d684:	4803      	ldr	r0, [pc, #12]	; (1d694 <_TCPIPStackModuleRxInsert+0x40>)
   1d686:	eb00 1004 	add.w	r0, r0, r4, lsl #4
   1d68a:	f002 fc53 	bl	1ff34 <_TCPIPSignalEntrySetNotify>
}
   1d68e:	e7f6      	b.n	1d67e <_TCPIPStackModuleRxInsert+0x2a>
   1d690:	2000dc84 	.word	0x2000dc84
   1d694:	2000d1d4 	.word	0x2000d1d4

Disassembly of section .rodata%589:

0001d698 <.rodata%589>:
   1d698:	20504455 	.word	0x20504455
   1d69c:	4c4c554e 	.word	0x4c4c554e
   1d6a0:	6e796420 	.word	0x6e796420
   1d6a4:	63696d61 	.word	0x63696d61
   1d6a8:	6c6c6120 	.word	0x6c6c6120
   1d6ac:	7461636f 	.word	0x7461636f
   1d6b0:	206e6f69 	.word	0x206e6f69
   1d6b4:	646e6168 	.word	0x646e6168
   1d6b8:	0000656c 	.word	0x0000656c
   1d6bc:	20504455 	.word	0x20504455
   1d6c0:	616e7944 	.word	0x616e7944
   1d6c4:	2063696d 	.word	0x2063696d
   1d6c8:	6f6c6c61 	.word	0x6f6c6c61
   1d6cc:	69746163 	.word	0x69746163
   1d6d0:	66206e6f 	.word	0x66206e6f
   1d6d4:	656c6961 	.word	0x656c6961
   1d6d8:	0064      	.short	0x0064
   1d6da:	bf00      	nop

Disassembly of section .text.SYS_INT_SourceDisable%590:

0001d6dc <SYS_INT_SourceDisable>:
{
    NVIC_INT_Restore(state);
}

bool SYS_INT_SourceDisable( INT_SOURCE source )
{
   1d6dc:	b538      	push	{r3, r4, r5, lr}
   1d6de:	4604      	mov	r4, r0
    return NVIC_INT_Disable();
   1d6e0:	f004 f9dd 	bl	21a9e <NVIC_INT_Disable>
  if ((int32_t)(IRQn) >= 0)
   1d6e4:	2c00      	cmp	r4, #0
   1d6e6:	db16      	blt.n	1d716 <SYS_INT_SourceDisable+0x3a>
    return((uint32_t)(((NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
   1d6e8:	0963      	lsrs	r3, r4, #5
   1d6ea:	490c      	ldr	r1, [pc, #48]	; (1d71c <SYS_INT_SourceDisable+0x40>)
   1d6ec:	f851 5023 	ldr.w	r5, [r1, r3, lsl #2]
   1d6f0:	f004 041f 	and.w	r4, r4, #31
   1d6f4:	40e5      	lsrs	r5, r4
    bool processorStatus;
    bool intSrcStatus;

    processorStatus = SYS_INT_Disable();

    intSrcStatus = NVIC_GetEnableIRQ(source);
   1d6f6:	f005 0501 	and.w	r5, r5, #1
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1d6fa:	2201      	movs	r2, #1
   1d6fc:	fa02 f404 	lsl.w	r4, r2, r4
   1d700:	3320      	adds	r3, #32
   1d702:	f841 4023 	str.w	r4, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   1d706:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1d70a:	f3bf 8f6f 	isb	sy
    NVIC_INT_Restore(state);
   1d70e:	f004 f9cf 	bl	21ab0 <NVIC_INT_Restore>

    SYS_INT_Restore( processorStatus );

    /* return the source status */
    return intSrcStatus;
}
   1d712:	4628      	mov	r0, r5
   1d714:	bd38      	pop	{r3, r4, r5, pc}
    intSrcStatus = NVIC_GetEnableIRQ(source);
   1d716:	2500      	movs	r5, #0
   1d718:	e7f9      	b.n	1d70e <SYS_INT_SourceDisable+0x32>
   1d71a:	bf00      	nop
   1d71c:	e000e100 	.word	0xe000e100

Disassembly of section .rodata%591:

0001d720 <.rodata%591>:
   1d720:	736c6166 	.word	0x736c6166
   1d724:	00000065 	.word	0x00000065
   1d728:	732f2e2e 	.word	0x732f2e2e
   1d72c:	672f6372 	.word	0x672f6372
   1d730:	6d5f7866 	.word	0x6d5f7866
   1d734:	2f6f6e6f 	.word	0x2f6f6e6f
   1d738:	5f786667 	.word	0x5f786667
   1d73c:	6f6e6f6d 	.word	0x6f6e6f6d
   1d740:	7865745f 	.word	0x7865745f
   1d744:	00632e74 	.word	0x00632e74
   1d748:	20727473 	.word	0x20727473
   1d74c:	4e203d21 	.word	0x4e203d21
   1d750:	004c4c55 	.word	0x004c4c55
   1d754:	746e6f66 	.word	0x746e6f66
   1d758:	203d2120 	.word	0x203d2120
   1d75c:	4c4c554e 	.word	0x4c4c554e
   1d760:	00          	.byte	0x00
   1d761:	00          	.byte	0x00
   1d762:	bf00      	nop

Disassembly of section .text.gfx_mono_ssd1306_put_byte%592:

0001d764 <gfx_mono_ssd1306_put_byte>:
        uint8_t data, bool force) {
   1d764:	b570      	push	{r4, r5, r6, lr}
   1d766:	4604      	mov	r4, r0
   1d768:	460d      	mov	r5, r1
   1d76a:	4616      	mov	r6, r2
    if (!force && data == gfx_mono_framebuffer_get_byte(page, column)) {
   1d76c:	b91b      	cbnz	r3, 1d776 <gfx_mono_ssd1306_put_byte+0x12>
   1d76e:	f004 fa6d 	bl	21c4c <gfx_mono_framebuffer_get_byte>
   1d772:	42b0      	cmp	r0, r6
   1d774:	d017      	beq.n	1d7a6 <gfx_mono_ssd1306_put_byte+0x42>
    gfx_mono_framebuffer_put_byte(page, column, data);
   1d776:	4632      	mov	r2, r6
   1d778:	4629      	mov	r1, r5
   1d77a:	4620      	mov	r0, r4
   1d77c:	f002 ff5e 	bl	2063c <gfx_mono_framebuffer_put_byte>
        address &= 0x0F;
   1d780:	f004 000f 	and.w	r0, r4, #15
        ssd1306_write_command(SSD1306_CMD_SET_PAGE_START_ADDRESS(address));
   1d784:	f040 00b0 	orr.w	r0, r0, #176	; 0xb0
   1d788:	f000 faf4 	bl	1dd74 <ssd1306_write_command>
        ssd1306_write_command(SSD1306_CMD_COL_ADD_SET_MSB(address >> 4));
   1d78c:	f3c5 1002 	ubfx	r0, r5, #4, #3
   1d790:	f040 0010 	orr.w	r0, r0, #16
   1d794:	f000 faee 	bl	1dd74 <ssd1306_write_command>
        ssd1306_write_command(SSD1306_CMD_COL_ADD_SET_LSB(address & 0x0F));
   1d798:	f005 000f 	and.w	r0, r5, #15
   1d79c:	f000 faea 	bl	1dd74 <ssd1306_write_command>
    ssd1306_write_data(data);
   1d7a0:	4630      	mov	r0, r6
   1d7a2:	f000 fb07 	bl	1ddb4 <ssd1306_write_data>
}
   1d7a6:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.sprintf%593:

0001d7a8 <siprintf>:
   1d7a8:	b40e      	push	{r1, r2, r3}
   1d7aa:	b510      	push	{r4, lr}
   1d7ac:	b09b      	sub	sp, #108	; 0x6c
   1d7ae:	ab1d      	add	r3, sp, #116	; 0x74
   1d7b0:	9001      	str	r0, [sp, #4]
   1d7b2:	9005      	str	r0, [sp, #20]
   1d7b4:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   1d7b8:	480a      	ldr	r0, [pc, #40]	; (1d7e4 <siprintf+0x3c>)
   1d7ba:	9106      	str	r1, [sp, #24]
   1d7bc:	9103      	str	r1, [sp, #12]
   1d7be:	490a      	ldr	r1, [pc, #40]	; (1d7e8 <siprintf+0x40>)
   1d7c0:	f853 2b04 	ldr.w	r2, [r3], #4
   1d7c4:	9104      	str	r1, [sp, #16]
   1d7c6:	2400      	movs	r4, #0
   1d7c8:	a901      	add	r1, sp, #4
   1d7ca:	6800      	ldr	r0, [r0, #0]
   1d7cc:	9300      	str	r3, [sp, #0]
   1d7ce:	9419      	str	r4, [sp, #100]	; 0x64
   1d7d0:	f7f2 f84a 	bl	f868 <_svfiprintf_r>
   1d7d4:	9b01      	ldr	r3, [sp, #4]
   1d7d6:	701c      	strb	r4, [r3, #0]
   1d7d8:	b01b      	add	sp, #108	; 0x6c
   1d7da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1d7de:	b003      	add	sp, #12
   1d7e0:	4770      	bx	lr
   1d7e2:	bf00      	nop
   1d7e4:	2000e4e4 	.word	0x2000e4e4
   1d7e8:	ffff0208 	.word	0xffff0208

Disassembly of section .text._DRV_GMAC_LinkStateNegComplete%594:

0001d7ec <_DRV_GMAC_LinkStateNegComplete>:
{
   1d7ec:	b538      	push	{r3, r4, r5, lr}
   1d7ee:	4604      	mov	r4, r0
	pPhyBase =  pMACDrv->sGmacData.gmacConfig.pPhyBase;
   1d7f0:	f8d0 50d8 	ldr.w	r5, [r0, #216]	; 0xd8
	phyStat = pPhyBase->DRV_ETHPHY_ClientStatus( pMACDrv->sGmacData.hPhyClient );
   1d7f4:	69eb      	ldr	r3, [r5, #28]
   1d7f6:	6900      	ldr	r0, [r0, #16]
   1d7f8:	4798      	blx	r3
	if(phyStat == DRV_ETHPHY_CLIENT_STATUS_BUSY)
   1d7fa:	2801      	cmp	r0, #1
   1d7fc:	d00e      	beq.n	1d81c <_DRV_GMAC_LinkStateNegComplete+0x30>
	phyRes = pPhyBase->DRV_ETHPHY_ClientOperationResult(pMACDrv->sGmacData.hPhyClient);
   1d7fe:	6a2b      	ldr	r3, [r5, #32]
   1d800:	6920      	ldr	r0, [r4, #16]
   1d802:	4798      	blx	r3
	if(phyRes != DRV_ETHPHY_RES_OK)
   1d804:	b958      	cbnz	r0, 1d81e <_DRV_GMAC_LinkStateNegComplete+0x32>
	phyRes = pPhyBase->DRV_ETHPHY_NegotiationResultGet(pMACDrv->sGmacData.hPhyClient, DRV_ETHPHY_INF_IDX_ALL_EXTERNAL, &pMACDrv->sGmacData._negResult);
   1d806:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   1d808:	f104 0240 	add.w	r2, r4, #64	; 0x40
   1d80c:	2100      	movs	r1, #0
   1d80e:	6920      	ldr	r0, [r4, #16]
   1d810:	4798      	blx	r3
	if(phyRes < 0)
   1d812:	2800      	cmp	r0, #0
   1d814:	db07      	blt.n	1d826 <_DRV_GMAC_LinkStateNegComplete+0x3a>
		pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_NEG_RESULT;
   1d816:	2304      	movs	r3, #4
   1d818:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
}
   1d81c:	bd38      	pop	{r3, r4, r5, pc}
		_DRV_GMAC_LinkStateDown(pMACDrv);
   1d81e:	4620      	mov	r0, r4
   1d820:	f003 fa66 	bl	20cf0 <_DRV_GMAC_LinkStateDown>
		return;
   1d824:	e7fa      	b.n	1d81c <_DRV_GMAC_LinkStateNegComplete+0x30>
		_DRV_GMAC_LinkStateDown(pMACDrv);
   1d826:	4620      	mov	r0, r4
   1d828:	f003 fa62 	bl	20cf0 <_DRV_GMAC_LinkStateDown>
   1d82c:	e7f6      	b.n	1d81c <_DRV_GMAC_LinkStateNegComplete+0x30>

Disassembly of section .text._TcpSocketSetSourceInterface%595:

0001d82e <_TcpSocketSetSourceInterface>:
    if(pSkt->flags.srcSet == 0 || pSkt->pSktNet == 0)
   1d82e:	f890 306d 	ldrb.w	r3, [r0, #109]	; 0x6d
   1d832:	f013 0310 	ands.w	r3, r3, #16
   1d836:	d003      	beq.n	1d840 <_TcpSocketSetSourceInterface+0x12>
   1d838:	6c02      	ldr	r2, [r0, #64]	; 0x40
   1d83a:	b10a      	cbz	r2, 1d840 <_TcpSocketSetSourceInterface+0x12>
    return true;
   1d83c:	2001      	movs	r0, #1
}
   1d83e:	4770      	bx	lr
{
   1d840:	b510      	push	{r4, lr}
   1d842:	4604      	mov	r4, r0
        pSkt->pSktNet = (TCPIP_NET_IF*)TCPIP_IPV4_SelectSourceInterface(pSkt->pSktNet, &pSkt->destAddress, &pSkt->srcAddress, pSkt->flags.srcSet != 0);
   1d844:	3300      	adds	r3, #0
   1d846:	bf18      	it	ne
   1d848:	2301      	movne	r3, #1
   1d84a:	f100 023c 	add.w	r2, r0, #60	; 0x3c
   1d84e:	f100 0138 	add.w	r1, r0, #56	; 0x38
   1d852:	6c00      	ldr	r0, [r0, #64]	; 0x40
   1d854:	f7ff f9dc 	bl	1cc10 <TCPIP_IPV4_SelectSourceInterface>
   1d858:	6420      	str	r0, [r4, #64]	; 0x40
        if(pSkt->pSktNet == 0)
   1d85a:	b138      	cbz	r0, 1d86c <_TcpSocketSetSourceInterface+0x3e>
        pSkt->flags.srcSet = 1;
   1d85c:	f894 306d 	ldrb.w	r3, [r4, #109]	; 0x6d
   1d860:	f043 0310 	orr.w	r3, r3, #16
   1d864:	f884 306d 	strb.w	r3, [r4, #109]	; 0x6d
    return true;
   1d868:	2001      	movs	r0, #1
}
   1d86a:	bd10      	pop	{r4, pc}
            return false;
   1d86c:	2000      	movs	r0, #0
   1d86e:	e7fc      	b.n	1d86a <_TcpSocketSetSourceInterface+0x3c>

Disassembly of section .text._UDPSetNewRxPacket%596:

0001d870 <_UDPSetNewRxPacket>:
{
   1d870:	b538      	push	{r3, r4, r5, lr}
   1d872:	4604      	mov	r4, r0
   1d874:	460d      	mov	r5, r1
    if(pSkt->pCurrRxPkt != 0)
   1d876:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   1d878:	b118      	cbz	r0, 1d882 <_UDPSetNewRxPacket+0x12>
    TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
   1d87a:	2209      	movs	r2, #9
   1d87c:	2102      	movs	r1, #2
   1d87e:	f000 f9b9 	bl	1dbf4 <_TCPIP_PKT_PacketAcknowledge>
    if((pSkt->pCurrRxPkt = pRxPkt) != 0)
   1d882:	62e5      	str	r5, [r4, #44]	; 0x2c
   1d884:	b17d      	cbz	r5, 1d8a6 <_UDPSetNewRxPacket+0x36>
        UDP_HEADER* pUDPHdr = (UDP_HEADER*)pRxPkt->pTransportLayer;
   1d886:	69ea      	ldr	r2, [r5, #28]
        pSkt->pCurrRxSeg = pRxPkt->pDSeg;
   1d888:	692b      	ldr	r3, [r5, #16]
   1d88a:	6323      	str	r3, [r4, #48]	; 0x30
        pSkt->rxSegLen = pRxPkt->pDSeg->segLen - sizeof(UDP_HEADER);
   1d88c:	899b      	ldrh	r3, [r3, #12]
   1d88e:	3b08      	subs	r3, #8
   1d890:	86a3      	strh	r3, [r4, #52]	; 0x34
        pSkt->rxTotLen = pUDPHdr->Length;  
   1d892:	8893      	ldrh	r3, [r2, #4]
   1d894:	86e3      	strh	r3, [r4, #54]	; 0x36
        pSkt->rxCurr = pRxPkt->pTransportLayer + sizeof(UDP_HEADER);
   1d896:	69eb      	ldr	r3, [r5, #28]
   1d898:	3308      	adds	r3, #8
   1d89a:	63a3      	str	r3, [r4, #56]	; 0x38
    _UDPsetPacketInfo(pSkt, pRxPkt);
   1d89c:	4629      	mov	r1, r5
   1d89e:	4620      	mov	r0, r4
   1d8a0:	f7fb f950 	bl	18b44 <_UDPsetPacketInfo>
}
   1d8a4:	bd38      	pop	{r3, r4, r5, pc}
        pSkt->pCurrRxSeg = 0;
   1d8a6:	2300      	movs	r3, #0
   1d8a8:	6323      	str	r3, [r4, #48]	; 0x30
        pSkt->rxSegLen = 0;
   1d8aa:	86a3      	strh	r3, [r4, #52]	; 0x34
        pSkt->rxTotLen = 0;
   1d8ac:	86e3      	strh	r3, [r4, #54]	; 0x36
        pSkt->rxCurr = 0;
   1d8ae:	63a3      	str	r3, [r4, #56]	; 0x38
   1d8b0:	e7f4      	b.n	1d89c <_UDPSetNewRxPacket+0x2c>

Disassembly of section .text.TCPIP_UDP_SourceIPAddressSet%597:

0001d8b2 <TCPIP_UDP_SourceIPAddressSet>:
{
   1d8b2:	b538      	push	{r3, r4, r5, lr}
   1d8b4:	460c      	mov	r4, r1
   1d8b6:	4615      	mov	r5, r2
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1d8b8:	f002 fbb4 	bl	20024 <_UDPSocketDcpt>
    return pSkt ? _UDPSetSourceAddress(pSkt, addType, localAddress) : false;
   1d8bc:	b1c0      	cbz	r0, 1d8f0 <TCPIP_UDP_SourceIPAddressSet+0x3e>
   1d8be:	4603      	mov	r3, r0
    if(localAddress == 0)
   1d8c0:	b1a5      	cbz	r5, 1d8ec <TCPIP_UDP_SourceIPAddressSet+0x3a>
    while(pSkt->addType == addType)
   1d8c2:	8f82      	ldrh	r2, [r0, #60]	; 0x3c
   1d8c4:	42a2      	cmp	r2, r4
   1d8c6:	d001      	beq.n	1d8cc <TCPIP_UDP_SourceIPAddressSet+0x1a>
    return false;
   1d8c8:	2000      	movs	r0, #0
   1d8ca:	e012      	b.n	1d8f2 <TCPIP_UDP_SourceIPAddressSet+0x40>
        if (addType == IP_ADDRESS_TYPE_IPV4)
   1d8cc:	2c01      	cmp	r4, #1
   1d8ce:	d001      	beq.n	1d8d4 <TCPIP_UDP_SourceIPAddressSet+0x22>
    return false;
   1d8d0:	2000      	movs	r0, #0
   1d8d2:	e00e      	b.n	1d8f2 <TCPIP_UDP_SourceIPAddressSet+0x40>
            pSkt->srcAddress.Val = localAddress->v4Add.Val;
   1d8d4:	682a      	ldr	r2, [r5, #0]
   1d8d6:	619a      	str	r2, [r3, #24]
            pSkt->flags.srcSet = 1;
   1d8d8:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
            pSkt->flags.srcSolved = 0;
   1d8dc:	f042 0260 	orr.w	r2, r2, #96	; 0x60
   1d8e0:	f36f 12c7 	bfc	r2, #7, #1
   1d8e4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
            return true;
   1d8e8:	2001      	movs	r0, #1
   1d8ea:	e002      	b.n	1d8f2 <TCPIP_UDP_SourceIPAddressSet+0x40>
        return false;
   1d8ec:	2000      	movs	r0, #0
   1d8ee:	e000      	b.n	1d8f2 <TCPIP_UDP_SourceIPAddressSet+0x40>
    return pSkt ? _UDPSetSourceAddress(pSkt, addType, localAddress) : false;
   1d8f0:	2000      	movs	r0, #0
}
   1d8f2:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text%598:

0001d8f4 <__do_global_dtors_aux>:
   1d8f4:	b510      	push	{r4, lr}
   1d8f6:	4c05      	ldr	r4, [pc, #20]	; (1d90c <__do_global_dtors_aux+0x18>)
   1d8f8:	7823      	ldrb	r3, [r4, #0]
   1d8fa:	b933      	cbnz	r3, 1d90a <__do_global_dtors_aux+0x16>
   1d8fc:	4b04      	ldr	r3, [pc, #16]	; (1d910 <__do_global_dtors_aux+0x1c>)
   1d8fe:	b113      	cbz	r3, 1d906 <__do_global_dtors_aux+0x12>
   1d900:	4804      	ldr	r0, [pc, #16]	; (1d914 <__do_global_dtors_aux+0x20>)
   1d902:	f3af 8000 	nop.w
   1d906:	2301      	movs	r3, #1
   1d908:	7023      	strb	r3, [r4, #0]
   1d90a:	bd10      	pop	{r4, pc}
   1d90c:	2000e1b0 	.word	0x2000e1b0
	...

0001d918 <frame_dummy>:
   1d918:	b508      	push	{r3, lr}
   1d91a:	4b03      	ldr	r3, [pc, #12]	; (1d928 <frame_dummy+0x10>)
   1d91c:	b11b      	cbz	r3, 1d926 <frame_dummy+0xe>
   1d91e:	4903      	ldr	r1, [pc, #12]	; (1d92c <frame_dummy+0x14>)
   1d920:	4803      	ldr	r0, [pc, #12]	; (1d930 <frame_dummy+0x18>)
   1d922:	f3af 8000 	nop.w
   1d926:	bd08      	pop	{r3, pc}
   1d928:	00000000 	.word	0x00000000
   1d92c:	2000e1b4 	.word	0x2000e1b4
   1d930:	00000000 	.word	0x00000000

Disassembly of section .text.DRV_ETHPHY_Reset%599:

0001d934 <DRV_ETHPHY_Reset>:
    if(hClientObj != 0)
   1d934:	4603      	mov	r3, r0
   1d936:	b190      	cbz	r0, 1d95e <DRV_ETHPHY_Reset+0x2a>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1d938:	68c0      	ldr	r0, [r0, #12]
   1d93a:	4a0d      	ldr	r2, [pc, #52]	; (1d970 <DRV_ETHPHY_Reset+0x3c>)
   1d93c:	4290      	cmp	r0, r2
   1d93e:	d111      	bne.n	1d964 <DRV_ETHPHY_Reset+0x30>
            if(hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_READY)
   1d940:	f993 2008 	ldrsb.w	r2, [r3, #8]
   1d944:	2a02      	cmp	r2, #2
   1d946:	d110      	bne.n	1d96a <DRV_ETHPHY_Reset+0x36>
            hClientObj->operParam = waitComplete;
   1d948:	6319      	str	r1, [r3, #48]	; 0x30
    hClientObj->operType = opType;
   1d94a:	2206      	movs	r2, #6
   1d94c:	839a      	strh	r2, [r3, #28]
    hClientObj->operPhase = hClientObj->operSubPhase = 0; 
   1d94e:	2200      	movs	r2, #0
   1d950:	841a      	strh	r2, [r3, #32]
   1d952:	83da      	strh	r2, [r3, #30]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_BUSY; 
   1d954:	2001      	movs	r0, #1
   1d956:	7218      	strb	r0, [r3, #8]
    hClientObj->operRes = res;
   1d958:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c
   1d95c:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1d95e:	f06f 000a 	mvn.w	r0, #10
   1d962:	4770      	bx	lr
   1d964:	f06f 000a 	mvn.w	r0, #10
   1d968:	4770      	bx	lr
                return DRV_ETHPHY_RES_NOT_READY_ERR;
   1d96a:	f06f 0009 	mvn.w	r0, #9
}
   1d96e:	4770      	bx	lr
   1d970:	2000de18 	.word	0x2000de18

Disassembly of section .text.DRV_ETHPHY_NegotiationIsComplete%600:

0001d974 <DRV_ETHPHY_NegotiationIsComplete>:
    if(hClientObj != 0)
   1d974:	4603      	mov	r3, r0
   1d976:	b190      	cbz	r0, 1d99e <DRV_ETHPHY_NegotiationIsComplete+0x2a>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1d978:	68c0      	ldr	r0, [r0, #12]
   1d97a:	490d      	ldr	r1, [pc, #52]	; (1d9b0 <DRV_ETHPHY_NegotiationIsComplete+0x3c>)
   1d97c:	4288      	cmp	r0, r1
   1d97e:	d111      	bne.n	1d9a4 <DRV_ETHPHY_NegotiationIsComplete+0x30>
            if(hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_READY)
   1d980:	f993 1008 	ldrsb.w	r1, [r3, #8]
   1d984:	2902      	cmp	r1, #2
   1d986:	d110      	bne.n	1d9aa <DRV_ETHPHY_NegotiationIsComplete+0x36>
            hClientObj->operParam = waitComplete;
   1d988:	631a      	str	r2, [r3, #48]	; 0x30
    hClientObj->operType = opType;
   1d98a:	2203      	movs	r2, #3
   1d98c:	839a      	strh	r2, [r3, #28]
    hClientObj->operPhase = hClientObj->operSubPhase = 0; 
   1d98e:	2200      	movs	r2, #0
   1d990:	841a      	strh	r2, [r3, #32]
   1d992:	83da      	strh	r2, [r3, #30]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_BUSY; 
   1d994:	2001      	movs	r0, #1
   1d996:	7218      	strb	r0, [r3, #8]
    hClientObj->operRes = res;
   1d998:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c
   1d99c:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1d99e:	f06f 000a 	mvn.w	r0, #10
   1d9a2:	4770      	bx	lr
   1d9a4:	f06f 000a 	mvn.w	r0, #10
   1d9a8:	4770      	bx	lr
                return DRV_ETHPHY_RES_NOT_READY_ERR;
   1d9aa:	f06f 0009 	mvn.w	r0, #9
}
   1d9ae:	4770      	bx	lr
   1d9b0:	2000de18 	.word	0x2000de18

Disassembly of section .text.DRV_ETHPHY_RestartNegotiation%601:

0001d9b4 <DRV_ETHPHY_RestartNegotiation>:
    if(hClientObj != 0)
   1d9b4:	4603      	mov	r3, r0
   1d9b6:	b188      	cbz	r0, 1d9dc <DRV_ETHPHY_RestartNegotiation+0x28>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1d9b8:	68c1      	ldr	r1, [r0, #12]
   1d9ba:	4a0d      	ldr	r2, [pc, #52]	; (1d9f0 <DRV_ETHPHY_RestartNegotiation+0x3c>)
   1d9bc:	4291      	cmp	r1, r2
   1d9be:	d110      	bne.n	1d9e2 <DRV_ETHPHY_RestartNegotiation+0x2e>
            if(hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_READY)
   1d9c0:	f990 2008 	ldrsb.w	r2, [r0, #8]
   1d9c4:	2a02      	cmp	r2, #2
   1d9c6:	d10f      	bne.n	1d9e8 <DRV_ETHPHY_RestartNegotiation+0x34>
    hClientObj->operType = opType;
   1d9c8:	2205      	movs	r2, #5
   1d9ca:	8382      	strh	r2, [r0, #28]
    hClientObj->operPhase = hClientObj->operSubPhase = 0; 
   1d9cc:	2200      	movs	r2, #0
   1d9ce:	8402      	strh	r2, [r0, #32]
   1d9d0:	83c2      	strh	r2, [r0, #30]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_BUSY; 
   1d9d2:	2001      	movs	r0, #1
   1d9d4:	7218      	strb	r0, [r3, #8]
    hClientObj->operRes = res;
   1d9d6:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c
   1d9da:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1d9dc:	f06f 000a 	mvn.w	r0, #10
   1d9e0:	4770      	bx	lr
   1d9e2:	f06f 000a 	mvn.w	r0, #10
   1d9e6:	4770      	bx	lr
                return DRV_ETHPHY_RES_NOT_READY_ERR;
   1d9e8:	f06f 0009 	mvn.w	r0, #9
}
   1d9ec:	4770      	bx	lr
   1d9ee:	bf00      	nop
   1d9f0:	2000de18 	.word	0x2000de18

Disassembly of section .text._DRV_ETHPHY_ResetPhaseWrite%602:

0001d9f4 <_DRV_ETHPHY_ResetPhaseWrite>:
{
   1d9f4:	b538      	push	{r3, r4, r5, lr}
    if( hClientObj->operParam == 0)
   1d9f6:	6b03      	ldr	r3, [r0, #48]	; 0x30
   1d9f8:	b91b      	cbnz	r3, 1da02 <_DRV_ETHPHY_ResetPhaseWrite+0xe>
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OK);
   1d9fa:	2100      	movs	r1, #0
   1d9fc:	f002 f996 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
}
   1da00:	bd38      	pop	{r3, r4, r5, pc}
   1da02:	4604      	mov	r4, r0
        hClientObj->operTStamp = SYS_TMR_TickCountGet() + ((DRV_ETHPHY_RESET_CLR_TMO * SYS_TMR_TickCounterFrequencyGet()) + 999) / 1000;
   1da04:	f002 fb72 	bl	200ec <SYS_TMR_TickCountGet>
   1da08:	4605      	mov	r5, r0
   1da0a:	f002 fb97 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
   1da0e:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   1da12:	fb03 f000 	mul.w	r0, r3, r0
   1da16:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
   1da1a:	4b05      	ldr	r3, [pc, #20]	; (1da30 <_DRV_ETHPHY_ResetPhaseWrite+0x3c>)
   1da1c:	fba3 3000 	umull	r3, r0, r3, r0
   1da20:	eb05 1090 	add.w	r0, r5, r0, lsr #6
   1da24:	62a0      	str	r0, [r4, #40]	; 0x28
    hClientObj->operPhase = operPhase;
   1da26:	2302      	movs	r3, #2
   1da28:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1da2a:	2300      	movs	r3, #0
   1da2c:	8423      	strh	r3, [r4, #32]
}
   1da2e:	e7e7      	b.n	1da00 <_DRV_ETHPHY_ResetPhaseWrite+0xc>
   1da30:	10624dd3 	.word	0x10624dd3

Disassembly of section .rodata.DRV_MIIM_OBJECT_BASE_Default%603:

0001da34 <DRV_MIIM_OBJECT_BASE_Default>:
   1da34:	00019bf1 000120df 0001e54b 0001fdcd     ..... ..K.......
   1da44:	00011bbd 00019b79 00017ddd 000214e5     ....y....}......
   1da54:	00021755 0001e063 0001f595 00021225     U...c.......%...
   1da64:	0002123f 00021259 000186cd 0001bf25     ?...Y.......%...

Disassembly of section .text._TCP_PortIsAvailable%604:

0001da74 <_TCP_PortIsAvailable>:
{
   1da74:	b410      	push	{r4}
    for(sktIx = 0; sktIx < TcpSockets; sktIx++)
   1da76:	4b0d      	ldr	r3, [pc, #52]	; (1daac <_TCP_PortIsAvailable+0x38>)
   1da78:	681c      	ldr	r4, [r3, #0]
   1da7a:	b1ac      	cbz	r4, 1daa8 <_TCP_PortIsAvailable+0x34>
        pSkt = TCBStubs[sktIx];
   1da7c:	4b0c      	ldr	r3, [pc, #48]	; (1dab0 <_TCP_PortIsAvailable+0x3c>)
   1da7e:	6819      	ldr	r1, [r3, #0]
   1da80:	3904      	subs	r1, #4
    for(sktIx = 0; sktIx < TcpSockets; sktIx++)
   1da82:	2300      	movs	r3, #0
   1da84:	e002      	b.n	1da8c <_TCP_PortIsAvailable+0x18>
   1da86:	3301      	adds	r3, #1
   1da88:	42a3      	cmp	r3, r4
   1da8a:	d009      	beq.n	1daa0 <_TCP_PortIsAvailable+0x2c>
        pSkt = TCBStubs[sktIx];
   1da8c:	f851 2f04 	ldr.w	r2, [r1, #4]!
        if(pSkt && pSkt->localPort == port)
   1da90:	2a00      	cmp	r2, #0
   1da92:	d0f8      	beq.n	1da86 <_TCP_PortIsAvailable+0x12>
   1da94:	f8b2 205a 	ldrh.w	r2, [r2, #90]	; 0x5a
   1da98:	4282      	cmp	r2, r0
   1da9a:	d1f4      	bne.n	1da86 <_TCP_PortIsAvailable+0x12>
            return false;
   1da9c:	2000      	movs	r0, #0
   1da9e:	e000      	b.n	1daa2 <_TCP_PortIsAvailable+0x2e>
    return true;
   1daa0:	2001      	movs	r0, #1
}
   1daa2:	f85d 4b04 	ldr.w	r4, [sp], #4
   1daa6:	4770      	bx	lr
    return true;
   1daa8:	2001      	movs	r0, #1
   1daaa:	e7fa      	b.n	1daa2 <_TCP_PortIsAvailable+0x2e>
   1daac:	2000e390 	.word	0x2000e390
   1dab0:	2000e38c 	.word	0x2000e38c

Disassembly of section .text._DHCPSetBoundState%605:

0001dab4 <_DHCPSetBoundState>:
{
   1dab4:	b510      	push	{r4, lr}
   1dab6:	b094      	sub	sp, #80	; 0x50
   1dab8:	4604      	mov	r4, r0
    TCPIP_UDP_SocketInfoGet(dhcpClientSocket , &sktInfo);
   1daba:	4669      	mov	r1, sp
   1dabc:	4b0c      	ldr	r3, [pc, #48]	; (1daf0 <_DHCPSetBoundState+0x3c>)
   1dabe:	f9b3 0000 	ldrsh.w	r0, [r3]
   1dac2:	f7fd fbf7 	bl	1b2b4 <TCPIP_UDP_SocketInfoGet>
    pClient->serverAddress.Val = sktInfo.sourceIPaddress.v4Add.Val;
   1dac6:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1dac8:	62a3      	str	r3, [r4, #40]	; 0x28
    pClient->smState = newState;
   1daca:	2308      	movs	r3, #8
   1dacc:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    pClient->flags.bIsBound = true;	
   1dad0:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
    pClient->flags.bRetry = false; 
   1dad4:	f043 0332 	orr.w	r3, r3, #50	; 0x32
   1dad8:	f36f 13c7 	bfc	r3, #7, #1
   1dadc:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    if(pClient->dhcpFilterHandle != 0)
   1dae0:	6ca0      	ldr	r0, [r4, #72]	; 0x48
   1dae2:	b110      	cbz	r0, 1daea <_DHCPSetBoundState+0x36>
        Ipv4FilterSetActive(pClient->dhcpFilterHandle, active);
   1dae4:	2100      	movs	r1, #0
   1dae6:	f7fd fd13 	bl	1b510 <Ipv4FilterSetActive>
}
   1daea:	b014      	add	sp, #80	; 0x50
   1daec:	bd10      	pop	{r4, pc}
   1daee:	bf00      	nop
   1daf0:	2000e504 	.word	0x2000e504

Disassembly of section .text.TCPIP_DHCP_Deinitialize%606:

0001daf4 <TCPIP_DHCP_Deinitialize>:
    if(dhcpInitCount > 0)
   1daf4:	4b0d      	ldr	r3, [pc, #52]	; (1db2c <TCPIP_DHCP_Deinitialize+0x38>)
   1daf6:	681b      	ldr	r3, [r3, #0]
   1daf8:	2b00      	cmp	r3, #0
   1dafa:	dc00      	bgt.n	1dafe <TCPIP_DHCP_Deinitialize+0xa>
   1dafc:	4770      	bx	lr
{
   1dafe:	b510      	push	{r4, lr}
   1db00:	4604      	mov	r4, r0
        _DHCPClientClose(stackCtrl->pNetIf, true, true);
   1db02:	2201      	movs	r2, #1
   1db04:	4611      	mov	r1, r2
   1db06:	6940      	ldr	r0, [r0, #20]
   1db08:	f7fa ff90 	bl	18a2c <_DHCPClientClose>
        if(stackCtrl->stackAction == TCPIP_STACK_ACTION_DEINIT)
   1db0c:	7f23      	ldrb	r3, [r4, #28]
   1db0e:	2b02      	cmp	r3, #2
   1db10:	d000      	beq.n	1db14 <TCPIP_DHCP_Deinitialize+0x20>
}
   1db12:	bd10      	pop	{r4, pc}
            if(--dhcpInitCount == 0)
   1db14:	4a05      	ldr	r2, [pc, #20]	; (1db2c <TCPIP_DHCP_Deinitialize+0x38>)
   1db16:	6813      	ldr	r3, [r2, #0]
   1db18:	3b01      	subs	r3, #1
   1db1a:	6013      	str	r3, [r2, #0]
   1db1c:	2b00      	cmp	r3, #0
   1db1e:	d1f8      	bne.n	1db12 <TCPIP_DHCP_Deinitialize+0x1e>
                _DHCPCleanup();
   1db20:	f7fa fe1c 	bl	1875c <_DHCPCleanup>
                dhcpMemH = 0;
   1db24:	4b02      	ldr	r3, [pc, #8]	; (1db30 <TCPIP_DHCP_Deinitialize+0x3c>)
   1db26:	2200      	movs	r2, #0
   1db28:	601a      	str	r2, [r3, #0]
}
   1db2a:	e7f2      	b.n	1db12 <TCPIP_DHCP_Deinitialize+0x1e>
   1db2c:	2000e40c 	.word	0x2000e40c
   1db30:	2000e414 	.word	0x2000e414

Disassembly of section .text.TCPIP_DNS_RemoveEntry%607:

0001db34 <TCPIP_DNS_RemoveEntry>:
{
   1db34:	b510      	push	{r4, lr}
    pDnsDcpt = pgDnsDcpt;
   1db36:	4b0e      	ldr	r3, [pc, #56]	; (1db70 <TCPIP_DNS_RemoveEntry+0x3c>)
   1db38:	681c      	ldr	r4, [r3, #0]
    if(pDnsDcpt == 0 || pDnsDcpt->hashDcpt == 0)
   1db3a:	b164      	cbz	r4, 1db56 <TCPIP_DNS_RemoveEntry+0x22>
   1db3c:	4601      	mov	r1, r0
   1db3e:	6820      	ldr	r0, [r4, #0]
   1db40:	b160      	cbz	r0, 1db5c <TCPIP_DNS_RemoveEntry+0x28>
    if(hostName == NULL)
   1db42:	b171      	cbz	r1, 1db62 <TCPIP_DNS_RemoveEntry+0x2e>
    pDnsHE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryLookup(pDnsDcpt->hashDcpt, hostName);
   1db44:	f7fd f91e 	bl	1ad84 <TCPIP_OAHASH_EntryLookup>
    if(pDnsHE != 0)
   1db48:	4601      	mov	r1, r0
   1db4a:	b168      	cbz	r0, 1db68 <TCPIP_DNS_RemoveEntry+0x34>
    _DNS_CleanCacheEntry(pDnsDcpt, pDnsHE);
   1db4c:	4620      	mov	r0, r4
   1db4e:	f001 fdc2 	bl	1f6d6 <_DNS_CleanCacheEntry>
        return TCPIP_DNS_RES_OK;
   1db52:	2000      	movs	r0, #0
}
   1db54:	bd10      	pop	{r4, pc}
        return TCPIP_DNS_RES_NO_SERVICE;
   1db56:	f06f 0005 	mvn.w	r0, #5
   1db5a:	e7fb      	b.n	1db54 <TCPIP_DNS_RemoveEntry+0x20>
   1db5c:	f06f 0005 	mvn.w	r0, #5
   1db60:	e7f8      	b.n	1db54 <TCPIP_DNS_RemoveEntry+0x20>
        return TCPIP_DNS_RES_INVALID_HOSTNAME;
   1db62:	f06f 0008 	mvn.w	r0, #8
   1db66:	e7f5      	b.n	1db54 <TCPIP_DNS_RemoveEntry+0x20>
    return TCPIP_DNS_RES_NO_NAME_ENTRY;
   1db68:	f04f 30ff 	mov.w	r0, #4294967295
   1db6c:	e7f2      	b.n	1db54 <TCPIP_DNS_RemoveEntry+0x20>
   1db6e:	bf00      	nop
   1db70:	2000e424 	.word	0x2000e424

Disassembly of section .rodata%608:

0001db74 <.rodata%608>:
   1db74:	252e6425 	.word	0x252e6425
   1db78:	64252e64 	.word	0x64252e64
   1db7c:	0064252e 	.word	0x0064252e
   1db80:	78322e25 	.word	0x78322e25
   1db84:	322e253a 	.word	0x322e253a
   1db88:	2e253a78 	.word	0x2e253a78
   1db8c:	253a7832 	.word	0x253a7832
   1db90:	3a78322e 	.word	0x3a78322e
   1db94:	78322e25 	.word	0x78322e25
   1db98:	322e253a 	.word	0x322e253a
   1db9c:	00000078 	.word	0x00000078
   1dba0:	6c6c7566 	.word	0x6c6c7566
   1dba4:	00000000 	.word	0x00000000
   1dba8:	00776f6c 	.word	0x00776f6c
   1dbac:	6e776f64 	.word	0x6e776f64
   1dbb0:	00          	.byte	0x00
   1dbb1:	00          	.byte	0x00
   1dbb2:	bf00      	nop

Disassembly of section .text.TCPIP_STACK_NetHandleGet%609:

0001dbb4 <TCPIP_STACK_NetHandleGet>:
{
   1dbb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1dbb6:	4606      	mov	r6, r0
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   1dbb8:	4b0c      	ldr	r3, [pc, #48]	; (1dbec <TCPIP_STACK_NetHandleGet+0x38>)
   1dbba:	681c      	ldr	r4, [r3, #0]
   1dbbc:	4b0c      	ldr	r3, [pc, #48]	; (1dbf0 <TCPIP_STACK_NetHandleGet+0x3c>)
   1dbbe:	681f      	ldr	r7, [r3, #0]
   1dbc0:	2f00      	cmp	r7, #0
   1dbc2:	dd0a      	ble.n	1dbda <TCPIP_STACK_NetHandleGet+0x26>
   1dbc4:	2500      	movs	r5, #0
        if(strcmp(pNetIf->ifName, interface) == 0)
   1dbc6:	4631      	mov	r1, r6
   1dbc8:	f104 0062 	add.w	r0, r4, #98	; 0x62
   1dbcc:	f003 ff26 	bl	21a1c <strcmp>
   1dbd0:	b148      	cbz	r0, 1dbe6 <TCPIP_STACK_NetHandleGet+0x32>
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   1dbd2:	3501      	adds	r5, #1
   1dbd4:	346c      	adds	r4, #108	; 0x6c
   1dbd6:	42bd      	cmp	r5, r7
   1dbd8:	d1f5      	bne.n	1dbc6 <TCPIP_STACK_NetHandleGet+0x12>
    return TCPIP_STACK_MACIdToNet(TCPIP_STACK_StringToMACId(interface));
   1dbda:	4630      	mov	r0, r6
   1dbdc:	f7fe fb48 	bl	1c270 <TCPIP_STACK_StringToMACId>
   1dbe0:	f7ff f9a6 	bl	1cf30 <TCPIP_STACK_MACIdToNet>
   1dbe4:	4604      	mov	r4, r0
}
   1dbe6:	4620      	mov	r0, r4
   1dbe8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1dbea:	bf00      	nop
   1dbec:	2000e440 	.word	0x2000e440
   1dbf0:	2000e0f0 	.word	0x2000e0f0

Disassembly of section .text._TCPIP_PKT_PacketAcknowledge%610:

0001dbf4 <_TCPIP_PKT_PacketAcknowledge>:
{
   1dbf4:	b510      	push	{r4, lr}
   1dbf6:	4604      	mov	r4, r0
    if(ackRes != TCPIP_MAC_PKT_ACK_NONE)
   1dbf8:	b109      	cbz	r1, 1dbfe <_TCPIP_PKT_PacketAcknowledge+0xa>
        pPkt->ackRes = ackRes;
   1dbfa:	f880 102c 	strb.w	r1, [r0, #44]	; 0x2c
    pPkt->pktPriority = 0; //clear the packet priority to default
   1dbfe:	2300      	movs	r3, #0
   1dc00:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
    if(pPkt->ackFunc)
   1dc04:	68a3      	ldr	r3, [r4, #8]
   1dc06:	b143      	cbz	r3, 1dc1a <_TCPIP_PKT_PacketAcknowledge+0x26>
       if((*pPkt->ackFunc)(pPkt, pPkt->ackParam))
   1dc08:	68e1      	ldr	r1, [r4, #12]
   1dc0a:	4620      	mov	r0, r4
   1dc0c:	4798      	blx	r3
   1dc0e:	b118      	cbz	r0, 1dc18 <_TCPIP_PKT_PacketAcknowledge+0x24>
           pPkt->pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED;
   1dc10:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   1dc12:	f023 0308 	bic.w	r3, r3, #8
   1dc16:	8463      	strh	r3, [r4, #34]	; 0x22
}
   1dc18:	bd10      	pop	{r4, pc}
        SYS_ERROR(SYS_ERROR_WARNING, "Packet Ack: orphan packet! \r\n");
   1dc1a:	f004 fa19 	bl	22050 <SYS_DEBUG_ErrorLevelGet>
   1dc1e:	2801      	cmp	r0, #1
   1dc20:	d9fa      	bls.n	1dc18 <_TCPIP_PKT_PacketAcknowledge+0x24>
   1dc22:	f004 fa0f 	bl	22044 <SYS_DEBUG_ConsoleInstanceGet>
   1dc26:	4902      	ldr	r1, [pc, #8]	; (1dc30 <_TCPIP_PKT_PacketAcknowledge+0x3c>)
   1dc28:	f7fc ff38 	bl	1aa9c <SYS_CONSOLE_Print>
}
   1dc2c:	e7f4      	b.n	1dc18 <_TCPIP_PKT_PacketAcknowledge+0x24>
   1dc2e:	bf00      	nop
   1dc30:	00020b50 	.word	0x00020b50

Disassembly of section .text._UDPIsAvailablePort%611:

0001dc34 <_UDPIsAvailablePort>:
{
   1dc34:	b410      	push	{r4}
    for(skt = 0; skt < nUdpSockets; skt++)
   1dc36:	4b0d      	ldr	r3, [pc, #52]	; (1dc6c <_UDPIsAvailablePort+0x38>)
   1dc38:	681c      	ldr	r4, [r3, #0]
   1dc3a:	2c00      	cmp	r4, #0
   1dc3c:	dd14      	ble.n	1dc68 <_UDPIsAvailablePort+0x34>
        pSkt = UDPSocketDcpt[skt]; 
   1dc3e:	4b0c      	ldr	r3, [pc, #48]	; (1dc70 <_UDPIsAvailablePort+0x3c>)
   1dc40:	6819      	ldr	r1, [r3, #0]
   1dc42:	3904      	subs	r1, #4
    for(skt = 0; skt < nUdpSockets; skt++)
   1dc44:	2300      	movs	r3, #0
   1dc46:	e002      	b.n	1dc4e <_UDPIsAvailablePort+0x1a>
   1dc48:	3301      	adds	r3, #1
   1dc4a:	42a3      	cmp	r3, r4
   1dc4c:	d008      	beq.n	1dc60 <_UDPIsAvailablePort+0x2c>
        pSkt = UDPSocketDcpt[skt]; 
   1dc4e:	f851 2f04 	ldr.w	r2, [r1, #4]!
        if(pSkt && pSkt->localPort == port)
   1dc52:	2a00      	cmp	r2, #0
   1dc54:	d0f8      	beq.n	1dc48 <_UDPIsAvailablePort+0x14>
   1dc56:	8d52      	ldrh	r2, [r2, #42]	; 0x2a
   1dc58:	4282      	cmp	r2, r0
   1dc5a:	d1f5      	bne.n	1dc48 <_UDPIsAvailablePort+0x14>
            return false;
   1dc5c:	2000      	movs	r0, #0
   1dc5e:	e000      	b.n	1dc62 <_UDPIsAvailablePort+0x2e>
    return true;
   1dc60:	2001      	movs	r0, #1
}
   1dc62:	f85d 4b04 	ldr.w	r4, [sp], #4
   1dc66:	4770      	bx	lr
    return true;
   1dc68:	2001      	movs	r0, #1
   1dc6a:	e7fa      	b.n	1dc62 <_UDPIsAvailablePort+0x2e>
   1dc6c:	2000e458 	.word	0x2000e458
   1dc70:	2000e454 	.word	0x2000e454

Disassembly of section .text.TCPIP_UDP_SocketNetSet%612:

0001dc74 <TCPIP_UDP_SocketNetSet>:
{
   1dc74:	b510      	push	{r4, lr}
   1dc76:	460c      	mov	r4, r1
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1dc78:	f002 f9d4 	bl	20024 <_UDPSocketDcpt>
    if(pSkt)
   1dc7c:	b148      	cbz	r0, 1dc92 <TCPIP_UDP_SocketNetSet+0x1e>
   1dc7e:	4603      	mov	r3, r0
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   1dc80:	b124      	cbz	r4, 1dc8c <TCPIP_UDP_SocketNetSet+0x18>
   1dc82:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
   1dc86:	f012 0f40 	tst.w	r2, #64	; 0x40
   1dc8a:	d104      	bne.n	1dc96 <TCPIP_UDP_SocketNetSet+0x22>
        if((pSkt->pSktNet = pIf) != 0)
   1dc8c:	2200      	movs	r2, #0
   1dc8e:	625a      	str	r2, [r3, #36]	; 0x24
   1dc90:	e008      	b.n	1dca4 <TCPIP_UDP_SocketNetSet+0x30>
    return false;
   1dc92:	2000      	movs	r0, #0
   1dc94:	e00d      	b.n	1dcb2 <TCPIP_UDP_SocketNetSet+0x3e>
        if((pSkt->pSktNet = pIf) != 0)
   1dc96:	6244      	str	r4, [r0, #36]	; 0x24
            pSkt->flags.looseNetIf = 0;
   1dc98:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
   1dc9c:	f36f 02c3 	bfc	r2, #3, #1
   1dca0:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
    pSkt->extFlags.rxEnable = 1;
   1dca4:	f893 2042 	ldrb.w	r2, [r3, #66]	; 0x42
   1dca8:	f042 0202 	orr.w	r2, r2, #2
   1dcac:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        return true;
   1dcb0:	2001      	movs	r0, #1
}
   1dcb2:	bd10      	pop	{r4, pc}

Disassembly of section .text.TC0_TimerInitialize%613:

0001dcb4 <TC0_TimerInitialize>:
// *****************************************************************************
/* Initialize the TC module in Timer mode */
void TC0_TimerInitialize( void )
{
    /* Reset TC */
    TC0_REGS->COUNT16.TC_CTRLA = TC_CTRLA_SWRST_Msk;
   1dcb4:	4b0d      	ldr	r3, [pc, #52]	; (1dcec <TC0_TimerInitialize+0x38>)
   1dcb6:	2201      	movs	r2, #1
   1dcb8:	601a      	str	r2, [r3, #0]

    while((TC0_REGS->COUNT16.TC_SYNCBUSY & TC_SYNCBUSY_SWRST_Msk) == TC_SYNCBUSY_SWRST_Msk)
   1dcba:	461a      	mov	r2, r3
   1dcbc:	6913      	ldr	r3, [r2, #16]
   1dcbe:	f013 0f01 	tst.w	r3, #1
   1dcc2:	d1fb      	bne.n	1dcbc <TC0_TimerInitialize+0x8>
    {
        /* Wait for Write Synchronization */
    }

    /* Configure counter mode & prescaler */
    TC0_REGS->COUNT16.TC_CTRLA = TC_CTRLA_MODE_COUNT16 | TC_CTRLA_PRESCALER_DIV1 | TC_CTRLA_PRESCSYNC_PRESC ;
   1dcc4:	4b09      	ldr	r3, [pc, #36]	; (1dcec <TC0_TimerInitialize+0x38>)
   1dcc6:	2210      	movs	r2, #16
   1dcc8:	601a      	str	r2, [r3, #0]

    /* Configure in Match Frequency Mode */
    TC0_REGS->COUNT16.TC_WAVE = (uint8_t)TC_WAVE_WAVEGEN_MPWM;
   1dcca:	2203      	movs	r2, #3
   1dccc:	731a      	strb	r2, [r3, #12]

    /* Configure timer period */
    TC0_REGS->COUNT16.TC_CC[0U] = 60000U;
   1dcce:	f64e 2260 	movw	r2, #60000	; 0xea60
   1dcd2:	839a      	strh	r2, [r3, #28]

    /* Clear all interrupt flags */
    TC0_REGS->COUNT16.TC_INTFLAG = (uint8_t)TC_INTFLAG_Msk;
   1dcd4:	2233      	movs	r2, #51	; 0x33
   1dcd6:	729a      	strb	r2, [r3, #10]

    TC0_CallbackObject.callback = NULL;
   1dcd8:	4a05      	ldr	r2, [pc, #20]	; (1dcf0 <TC0_TimerInitialize+0x3c>)
   1dcda:	2100      	movs	r1, #0
   1dcdc:	6011      	str	r1, [r2, #0]
    /* Enable interrupt*/
    TC0_REGS->COUNT16.TC_INTENSET = (uint8_t)(TC_INTENSET_MC1_Msk);
   1dcde:	2220      	movs	r2, #32
   1dce0:	725a      	strb	r2, [r3, #9]


    while((TC0_REGS->COUNT16.TC_SYNCBUSY) != 0U)
   1dce2:	461a      	mov	r2, r3
   1dce4:	6913      	ldr	r3, [r2, #16]
   1dce6:	2b00      	cmp	r3, #0
   1dce8:	d1fc      	bne.n	1dce4 <TC0_TimerInitialize+0x30>
    {
        /* Wait for Write Synchronization */
    }
}
   1dcea:	4770      	bx	lr
   1dcec:	40003800 	.word	0x40003800
   1dcf0:	2000e358 	.word	0x2000e358

Disassembly of section .text.SYS_TIME_TimerAdd%614:

0001dcf4 <SYS_TIME_TimerAdd>:
{
   1dcf4:	b538      	push	{r3, r4, r5, lr}
   1dcf6:	4605      	mov	r5, r0
    counterObj->hwTimerCurrentValue = counterObj->timePlib->timerCounterGet();
   1dcf8:	4c0d      	ldr	r4, [pc, #52]	; (1dd30 <SYS_TIME_TimerAdd+0x3c>)
   1dcfa:	6863      	ldr	r3, [r4, #4]
   1dcfc:	699b      	ldr	r3, [r3, #24]
   1dcfe:	4798      	blx	r3
   1dd00:	6160      	str	r0, [r4, #20]
    elapsedCount = SYS_TIME_GetElapsedCount(counterObj->hwTimerCurrentValue);
   1dd02:	6960      	ldr	r0, [r4, #20]
   1dd04:	f003 f9da 	bl	210bc <SYS_TIME_GetElapsedCount>
   1dd08:	4604      	mov	r4, r0
    SYS_TIME_UpdateTimerList(elapsedCount);
   1dd0a:	f001 fb85 	bl	1f418 <SYS_TIME_UpdateTimerList>
    SYS_TIME_Counter64Update(elapsedCount);
   1dd0e:	4620      	mov	r0, r4
   1dd10:	f003 f9c6 	bl	210a0 <SYS_TIME_Counter64Update>
    isHeadTimerUpdated = SYS_TIME_AddToList(newTimer);
   1dd14:	4628      	mov	r0, r5
   1dd16:	f7fa fdf9 	bl	1890c <SYS_TIME_AddToList>
    if (isHeadTimerUpdated == true)
   1dd1a:	b900      	cbnz	r0, 1dd1e <SYS_TIME_TimerAdd+0x2a>
}
   1dd1c:	bd38      	pop	{r3, r4, r5, pc}
        interruptState = SYS_INT_Disable();
   1dd1e:	f004 fa47 	bl	221b0 <SYS_INT_Disable>
   1dd22:	4604      	mov	r4, r0
        SYS_TIME_HwTimerCompareUpdate();
   1dd24:	f7f8 ffd2 	bl	16ccc <SYS_TIME_HwTimerCompareUpdate>
        SYS_INT_Restore(interruptState);
   1dd28:	4620      	mov	r0, r4
   1dd2a:	f004 fa45 	bl	221b8 <SYS_INT_Restore>
}
   1dd2e:	e7f5      	b.n	1dd1c <SYS_TIME_TimerAdd+0x28>
   1dd30:	2000e030 	.word	0x2000e030

Disassembly of section .rodata%615:

0001dd34 <.rodata%615>:
   1dd34:	5f535953 	.word	0x5f535953
   1dd38:	5f444d43 	.word	0x5f444d43
   1dd3c:	4b534154 	.word	0x4b534154
   1dd40:	00000053 	.word	0x00000053
   1dd44:	5f565244 	.word	0x5f565244
   1dd48:	4d49494d 	.word	0x4d49494d
   1dd4c:	7361545f 	.word	0x7361545f
   1dd50:	0000736b 	.word	0x0000736b
   1dd54:	49504354 	.word	0x49504354
   1dd58:	54535f50 	.word	0x54535f50
   1dd5c:	5f4b4341 	.word	0x5f4b4341
   1dd60:	6b736154 	.word	0x6b736154
   1dd64:	00000073 	.word	0x00000073
   1dd68:	5f505041 	.word	0x5f505041
   1dd6c:	6b736154 	.word	0x6b736154
   1dd70:	0073      	.short	0x0073
   1dd72:	bf00      	nop

Disassembly of section .text.ssd1306_write_command%616:

0001dd74 <ssd1306_write_command>:
 * This functions pull pin D/C# low before writing to the controller. Different
 * data write function is called based on the selected interface.
 *
 * \param command the command to write
 */
void ssd1306_write_command(uint8_t command) {
   1dd74:	b500      	push	{lr}
   1dd76:	b083      	sub	sp, #12
   1dd78:	f88d 0007 	strb.w	r0, [sp, #7]
    GFX_DISPLAY_SS_N_CLEAR();
   1dd7c:	4b0c      	ldr	r3, [pc, #48]	; (1ddb0 <ssd1306_write_command+0x3c>)
   1dd7e:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   1dd82:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    GFX_DATA_CMD_SEL_CLEAR();
   1dd86:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1dd8a:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194
    GFX_SPI_WRITE_FUNCTION(&command, 1);
   1dd8e:	2101      	movs	r1, #1
   1dd90:	f10d 0007 	add.w	r0, sp, #7
   1dd94:	f004 f97a 	bl	2208c <SERCOM0_SPI_Write>
    while (GFX_SPI_IS_BUSY());
   1dd98:	f001 feb4 	bl	1fb04 <SERCOM0_SPI_IsBusy>
   1dd9c:	2800      	cmp	r0, #0
   1dd9e:	d1fb      	bne.n	1dd98 <ssd1306_write_command+0x24>
    GFX_DISPLAY_SS_N_SET();
   1dda0:	4b03      	ldr	r3, [pc, #12]	; (1ddb0 <ssd1306_write_command+0x3c>)
   1dda2:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   1dda6:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
}
   1ddaa:	b003      	add	sp, #12
   1ddac:	f85d fb04 	ldr.w	pc, [sp], #4
   1ddb0:	41008000 	.word	0x41008000

Disassembly of section .text.ssd1306_write_data%617:

0001ddb4 <ssd1306_write_data>:
 * This functions sets the pin D/C# before writing to the controller. Different
 * data write function is called based on the selected interface.
 *
 * \param data the data to write
 */
void ssd1306_write_data(uint8_t data) {
   1ddb4:	b500      	push	{lr}
   1ddb6:	b083      	sub	sp, #12
   1ddb8:	f88d 0007 	strb.w	r0, [sp, #7]
    GFX_DISPLAY_SS_N_CLEAR();
   1ddbc:	4b0c      	ldr	r3, [pc, #48]	; (1ddf0 <ssd1306_write_data+0x3c>)
   1ddbe:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   1ddc2:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    GFX_DATA_CMD_SEL_SET();
   1ddc6:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1ddca:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
    GFX_SPI_WRITE_FUNCTION(&data, 1);
   1ddce:	2101      	movs	r1, #1
   1ddd0:	f10d 0007 	add.w	r0, sp, #7
   1ddd4:	f004 f95a 	bl	2208c <SERCOM0_SPI_Write>
    while (GFX_SPI_IS_BUSY());
   1ddd8:	f001 fe94 	bl	1fb04 <SERCOM0_SPI_IsBusy>
   1dddc:	2800      	cmp	r0, #0
   1ddde:	d1fb      	bne.n	1ddd8 <ssd1306_write_data+0x24>
    GFX_DISPLAY_SS_N_SET();
   1dde0:	4b03      	ldr	r3, [pc, #12]	; (1ddf0 <ssd1306_write_data+0x3c>)
   1dde2:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   1dde6:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
}
   1ddea:	b003      	add	sp, #12
   1ddec:	f85d fb04 	ldr.w	pc, [sp], #4
   1ddf0:	41008000 	.word	0x41008000

Disassembly of section .text%618:

0001ddf4 <__aeabi_d2uiz>:
   1ddf4:	004a      	lsls	r2, r1, #1
   1ddf6:	d211      	bcs.n	1de1c <__aeabi_d2uiz+0x28>
   1ddf8:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   1ddfc:	d211      	bcs.n	1de22 <__aeabi_d2uiz+0x2e>
   1ddfe:	d50d      	bpl.n	1de1c <__aeabi_d2uiz+0x28>
   1de00:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   1de04:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   1de08:	d40e      	bmi.n	1de28 <__aeabi_d2uiz+0x34>
   1de0a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   1de0e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1de12:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   1de16:	fa23 f002 	lsr.w	r0, r3, r2
   1de1a:	4770      	bx	lr
   1de1c:	f04f 0000 	mov.w	r0, #0
   1de20:	4770      	bx	lr
   1de22:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   1de26:	d102      	bne.n	1de2e <__aeabi_d2uiz+0x3a>
   1de28:	f04f 30ff 	mov.w	r0, #4294967295
   1de2c:	4770      	bx	lr
   1de2e:	f04f 0000 	mov.w	r0, #0
   1de32:	4770      	bx	lr

Disassembly of section .text.__hi0bits%619:

0001de34 <__hi0bits>:
   1de34:	0c02      	lsrs	r2, r0, #16
   1de36:	0412      	lsls	r2, r2, #16
   1de38:	4603      	mov	r3, r0
   1de3a:	b9ca      	cbnz	r2, 1de70 <__hi0bits+0x3c>
   1de3c:	0403      	lsls	r3, r0, #16
   1de3e:	2010      	movs	r0, #16
   1de40:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
   1de44:	bf04      	itt	eq
   1de46:	021b      	lsleq	r3, r3, #8
   1de48:	3008      	addeq	r0, #8
   1de4a:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
   1de4e:	bf04      	itt	eq
   1de50:	011b      	lsleq	r3, r3, #4
   1de52:	3004      	addeq	r0, #4
   1de54:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
   1de58:	bf04      	itt	eq
   1de5a:	009b      	lsleq	r3, r3, #2
   1de5c:	3002      	addeq	r0, #2
   1de5e:	2b00      	cmp	r3, #0
   1de60:	db05      	blt.n	1de6e <__hi0bits+0x3a>
   1de62:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
   1de66:	f100 0001 	add.w	r0, r0, #1
   1de6a:	bf08      	it	eq
   1de6c:	2020      	moveq	r0, #32
   1de6e:	4770      	bx	lr
   1de70:	2000      	movs	r0, #0
   1de72:	e7e5      	b.n	1de40 <__hi0bits+0xc>

Disassembly of section .text.write%620:

0001de74 <write>:
   1de74:	b570      	push	{r4, r5, r6, lr}
   1de76:	b1b9      	cbz	r1, 1dea8 <write+0x34>
   1de78:	4615      	mov	r5, r2
   1de7a:	b10a      	cbz	r2, 1de80 <write+0xc>
   1de7c:	2802      	cmp	r0, #2
   1de7e:	d901      	bls.n	1de84 <write+0x10>
   1de80:	4628      	mov	r0, r5
   1de82:	bd70      	pop	{r4, r5, r6, pc}
   1de84:	4b0a      	ldr	r3, [pc, #40]	; (1deb0 <write+0x3c>)
   1de86:	b12b      	cbz	r3, 1de94 <write+0x20>
   1de88:	4608      	mov	r0, r1
   1de8a:	4611      	mov	r1, r2
   1de8c:	f3af 8000 	nop.w
   1de90:	4628      	mov	r0, r5
   1de92:	bd70      	pop	{r4, r5, r6, pc}
   1de94:	460c      	mov	r4, r1
   1de96:	188e      	adds	r6, r1, r2
   1de98:	f814 0b01 	ldrb.w	r0, [r4], #1
   1de9c:	f7f7 f8a9 	bl	14ff2 <_mon_putc>
   1dea0:	42b4      	cmp	r4, r6
   1dea2:	d1f9      	bne.n	1de98 <write+0x24>
   1dea4:	4628      	mov	r0, r5
   1dea6:	bd70      	pop	{r4, r5, r6, pc}
   1dea8:	460d      	mov	r5, r1
   1deaa:	4628      	mov	r0, r5
   1deac:	bd70      	pop	{r4, r5, r6, pc}
   1deae:	bf00      	nop
   1deb0:	00000000 	.word	0x00000000

Disassembly of section .text._TCPSetHalfFlushFlag%621:

0001deb4 <_TCPSetHalfFlushFlag>:
    TCP_OPTION_THRES_FLUSH_TYPE flushType = (TCP_OPTION_THRES_FLUSH_TYPE)pSkt->Flags.halfThresType;
   1deb4:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
   1deb8:	f3c3 1301 	ubfx	r3, r3, #4, #2
    switch(flushType)
   1debc:	b163      	cbz	r3, 1ded8 <_TCPSetHalfFlushFlag+0x24>
    bool    clrFlushFlag = false;
   1debe:	2b01      	cmp	r3, #1
   1dec0:	bf14      	ite	ne
   1dec2:	2300      	movne	r3, #0
   1dec4:	2301      	moveq	r3, #1
    pSkt->flags.halfThresFlush = clrFlushFlag ? 0 : 1;
   1dec6:	f083 0301 	eor.w	r3, r3, #1
   1deca:	f890 206d 	ldrb.w	r2, [r0, #109]	; 0x6d
   1dece:	f363 12c7 	bfi	r2, r3, #7, #1
   1ded2:	f880 206d 	strb.w	r2, [r0, #109]	; 0x6d
}
   1ded6:	4770      	bx	lr
            if((pSkt->txEnd - pSkt->txStart) >= (pSkt->wRemoteMSS * 3) / 2 )
   1ded8:	6843      	ldr	r3, [r0, #4]
   1deda:	6802      	ldr	r2, [r0, #0]
   1dedc:	1a9a      	subs	r2, r3, r2
   1dede:	f8b0 3062 	ldrh.w	r3, [r0, #98]	; 0x62
   1dee2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1dee6:	ebb2 0f63 	cmp.w	r2, r3, asr #1
   1deea:	bfac      	ite	ge
   1deec:	2301      	movge	r3, #1
   1deee:	2300      	movlt	r3, #0
   1def0:	e7e9      	b.n	1dec6 <_TCPSetHalfFlushFlag+0x12>

Disassembly of section .text._DHCPOptionProcessSubNet%622:

0001def2 <_DHCPOptionProcessSubNet>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_SUBNET_MASK))
   1def2:	684b      	ldr	r3, [r1, #4]
   1def4:	2b05      	cmp	r3, #5
   1def6:	d913      	bls.n	1df20 <_DHCPOptionProcessSubNet+0x2e>
        TCPIP_DHCP_OPTION_DATA_SUBNET_MASK* pSubMask = (TCPIP_DHCP_OPTION_DATA_SUBNET_MASK*)pOptData->pOpt;
   1def8:	680b      	ldr	r3, [r1, #0]
        if(pSubMask->len == sizeof(pSubMask->mask))
   1defa:	785a      	ldrb	r2, [r3, #1]
   1defc:	2a04      	cmp	r2, #4
   1defe:	d112      	bne.n	1df26 <_DHCPOptionProcessSubNet+0x34>
            if(pClient->flags.bOfferReceived == 0)
   1df00:	f890 2058 	ldrb.w	r2, [r0, #88]	; 0x58
   1df04:	f012 0f04 	tst.w	r2, #4
   1df08:	d110      	bne.n	1df2c <_DHCPOptionProcessSubNet+0x3a>
                memcpy(&pClient->dhcpMask, pSubMask->mask, sizeof(pClient->dhcpMask)); 
   1df0a:	f8d3 3002 	ldr.w	r3, [r3, #2]
   1df0e:	6343      	str	r3, [r0, #52]	; 0x34
                pClient->validValues.Mask = 1;
   1df10:	f890 3059 	ldrb.w	r3, [r0, #89]	; 0x59
   1df14:	f043 0304 	orr.w	r3, r3, #4
   1df18:	f880 3059 	strb.w	r3, [r0, #89]	; 0x59
            return sizeof(TCPIP_DHCP_OPTION_DATA_SUBNET_MASK);
   1df1c:	2006      	movs	r0, #6
   1df1e:	4770      	bx	lr
    return -1;
   1df20:	f04f 30ff 	mov.w	r0, #4294967295
   1df24:	4770      	bx	lr
   1df26:	f04f 30ff 	mov.w	r0, #4294967295
   1df2a:	4770      	bx	lr
            return sizeof(TCPIP_DHCP_OPTION_DATA_SUBNET_MASK);
   1df2c:	2006      	movs	r0, #6
}
   1df2e:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_AddressServiceDefaultSet%623:

0001df30 <TCPIP_STACK_AddressServiceDefaultSet>:
{
   1df30:	b510      	push	{r4, lr}
   1df32:	4604      	mov	r4, r0
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1df34:	2000      	movs	r0, #0
   1df36:	f003 fb41 	bl	215bc <OSAL_CRIT_Enter>
   1df3a:	4601      	mov	r1, r0
    _TCPIPStackSetIpAddress(pNetIf, &pNetIf->DefaultIPAddr, &pNetIf->DefaultMask, &pNetIf->DefaultGateway, false);
   1df3c:	f104 021c 	add.w	r2, r4, #28
   1df40:	f104 0320 	add.w	r3, r4, #32
    if(ipAddress)
   1df44:	f114 0f18 	cmn.w	r4, #24
        pNetIf->netIPAddr.Val = ipAddress->Val;
   1df48:	bf1c      	itt	ne
   1df4a:	69a0      	ldrne	r0, [r4, #24]
   1df4c:	6060      	strne	r0, [r4, #4]
    if(mask)
   1df4e:	b10a      	cbz	r2, 1df54 <TCPIP_STACK_AddressServiceDefaultSet+0x24>
        pNetIf->netMask.Val = mask->Val;
   1df50:	69e2      	ldr	r2, [r4, #28]
   1df52:	60a2      	str	r2, [r4, #8]
    if(gw)
   1df54:	b10b      	cbz	r3, 1df5a <TCPIP_STACK_AddressServiceDefaultSet+0x2a>
        pNetIf->netGateway.Val = gw->Val;
   1df56:	6a23      	ldr	r3, [r4, #32]
   1df58:	60e3      	str	r3, [r4, #12]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1df5a:	2000      	movs	r0, #0
   1df5c:	f003 fc5d 	bl	2181a <OSAL_CRIT_Leave>
    pNetIf->Flags.bInConfig = config;
   1df60:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   1df64:	f36f 1304 	bfc	r3, #4, #1
   1df68:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
}
   1df6c:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_UDP_TxOffsetSet%624:

0001df6e <TCPIP_UDP_TxOffsetSet>:
{
   1df6e:	b570      	push	{r4, r5, r6, lr}
   1df70:	460d      	mov	r5, r1
   1df72:	4616      	mov	r6, r2
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1df74:	f002 f856 	bl	20024 <_UDPSocketDcpt>
    if(pSkt && _UDPTxPktValid(pSkt))
   1df78:	b198      	cbz	r0, 1dfa2 <TCPIP_UDP_TxOffsetSet+0x34>
   1df7a:	4604      	mov	r4, r0
   1df7c:	f003 f9d4 	bl	21328 <_UDPTxPktValid>
   1df80:	4603      	mov	r3, r0
   1df82:	b178      	cbz	r0, 1dfa4 <TCPIP_UDP_TxOffsetSet+0x36>
        uint8_t* pNewWrite = relative ? pSkt->txWrite : pSkt->txStart;
   1df84:	b14e      	cbz	r6, 1df9a <TCPIP_UDP_TxOffsetSet+0x2c>
   1df86:	68a2      	ldr	r2, [r4, #8]
        pNewWrite += wOffset;
   1df88:	4415      	add	r5, r2
        if(pSkt->txStart <= pNewWrite && pNewWrite <= pSkt->txEnd)
   1df8a:	6822      	ldr	r2, [r4, #0]
   1df8c:	42aa      	cmp	r2, r5
   1df8e:	d80b      	bhi.n	1dfa8 <TCPIP_UDP_TxOffsetSet+0x3a>
   1df90:	6862      	ldr	r2, [r4, #4]
   1df92:	42aa      	cmp	r2, r5
   1df94:	d203      	bcs.n	1df9e <TCPIP_UDP_TxOffsetSet+0x30>
    return false;
   1df96:	2300      	movs	r3, #0
   1df98:	e004      	b.n	1dfa4 <TCPIP_UDP_TxOffsetSet+0x36>
        uint8_t* pNewWrite = relative ? pSkt->txWrite : pSkt->txStart;
   1df9a:	6822      	ldr	r2, [r4, #0]
   1df9c:	e7f4      	b.n	1df88 <TCPIP_UDP_TxOffsetSet+0x1a>
            pSkt->txWrite = pNewWrite;
   1df9e:	60a5      	str	r5, [r4, #8]
            return true;
   1dfa0:	e000      	b.n	1dfa4 <TCPIP_UDP_TxOffsetSet+0x36>
    return false;
   1dfa2:	2300      	movs	r3, #0
}
   1dfa4:	4618      	mov	r0, r3
   1dfa6:	bd70      	pop	{r4, r5, r6, pc}
    return false;
   1dfa8:	2300      	movs	r3, #0
   1dfaa:	e7fb      	b.n	1dfa4 <TCPIP_UDP_TxOffsetSet+0x36>

Disassembly of section .rodata%625:

0001dfac <.rodata%625>:
   1dfac:	66202c00 	.word	0x66202c00
   1dfb0:	74636e75 	.word	0x74636e75
   1dfb4:	3a6e6f69 	.word	0x3a6e6f69
   1dfb8:	73610020 	.word	0x73610020
   1dfbc:	74726573 	.word	0x74726573
   1dfc0:	206e6f69 	.word	0x206e6f69
   1dfc4:	22732522 	.word	0x22732522
   1dfc8:	69616620 	.word	0x69616620
   1dfcc:	3a64656c 	.word	0x3a64656c
   1dfd0:	6c696620 	.word	0x6c696620
   1dfd4:	25222065 	.word	0x25222065
   1dfd8:	202c2273 	.word	0x202c2273
   1dfdc:	656e696c 	.word	0x656e696c
   1dfe0:	25642520 	.word	0x25642520
   1dfe4:	0a732573 	.word	0x0a732573
	...

Disassembly of section .text._DRV_ETHPHY_NegCompletePhaseAN_Complete%626:

0001dfea <_DRV_ETHPHY_NegCompletePhaseAN_Complete>:
{
   1dfea:	b510      	push	{r4, lr}
   1dfec:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1dfee:	f002 fbd9 	bl	207a4 <_DRV_PHY_SMITransfer_Wait>
   1dff2:	b1b8      	cbz	r0, 1e024 <_DRV_ETHPHY_NegCompletePhaseAN_Complete+0x3a>
    phyStat.w = hClientObj->smiData;
   1dff4:	8f62      	ldrh	r2, [r4, #58]	; 0x3a
    if(phyStat.AN_COMPLETE == 0)
   1dff6:	f012 0f20 	tst.w	r2, #32
   1dffa:	d10f      	bne.n	1e01c <_DRV_ETHPHY_NegCompletePhaseAN_Complete+0x32>
        if(SYS_TMR_TickCountGet() < hClientObj->operTStamp)
   1dffc:	f002 f876 	bl	200ec <SYS_TMR_TickCountGet>
   1e000:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1e002:	4298      	cmp	r0, r3
   1e004:	d204      	bcs.n	1e010 <_DRV_ETHPHY_NegCompletePhaseAN_Complete+0x26>
            _DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT);
   1e006:	2101      	movs	r1, #1
   1e008:	4620      	mov	r0, r4
   1e00a:	f000 ff77 	bl	1eefc <_DRV_PHY_SMIReadStart>
   1e00e:	e009      	b.n	1e024 <_DRV_ETHPHY_NegCompletePhaseAN_Complete+0x3a>
            _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_NEGOTIATION_ACTIVE);
   1e010:	f06f 0107 	mvn.w	r1, #7
   1e014:	4620      	mov	r0, r4
   1e016:	f001 fe89 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
   1e01a:	e003      	b.n	1e024 <_DRV_ETHPHY_NegCompletePhaseAN_Complete+0x3a>
        _DRV_PHY_NegCompleteSetOperResult(hClientObj, phyBMCon.w, phyStat.w);
   1e01c:	8ca1      	ldrh	r1, [r4, #36]	; 0x24
   1e01e:	4620      	mov	r0, r4
   1e020:	f000 ffe9 	bl	1eff6 <_DRV_PHY_NegCompleteSetOperResult>
}
   1e024:	bd10      	pop	{r4, pc}

Disassembly of section .text.Lan867x_Read_Register%627:

0001e026 <Lan867x_Read_Register>:
{
   1e026:	b510      	push	{r4, lr}
   1e028:	4604      	mov	r4, r0
   1e02a:	4613      	mov	r3, r2
    if (R2F(clientObj->vendorData, VENDOR_INTERNAL_STATE) == IDLE_PHASE) {
   1e02c:	6840      	ldr	r0, [r0, #4]
   1e02e:	0e42      	lsrs	r2, r0, #25
   1e030:	d00c      	beq.n	1e04c <Lan867x_Read_Register+0x26>
    res = Lan867x_Miim_Task(clientObj, DRV_MIIM_OP_READ, regAddr, rData);
   1e032:	460a      	mov	r2, r1
   1e034:	2101      	movs	r1, #1
   1e036:	4620      	mov	r0, r4
   1e038:	f7f0 fe78 	bl	ed2c <Lan867x_Miim_Task>
    if (res == DRV_MIIM_RES_OK) {
   1e03c:	4603      	mov	r3, r0
   1e03e:	b918      	cbnz	r0, 1e048 <Lan867x_Read_Register+0x22>
        clientObj->vendorData = F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   1e040:	6862      	ldr	r2, [r4, #4]
   1e042:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   1e046:	6062      	str	r2, [r4, #4]
}
   1e048:	4618      	mov	r0, r3
   1e04a:	bd10      	pop	{r4, pc}
            F2R(initialState, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   1e04c:	291f      	cmp	r1, #31
   1e04e:	bf94      	ite	ls
   1e050:	f04f 7200 	movls.w	r2, #33554432	; 0x2000000
   1e054:	f04f 6200 	movhi.w	r2, #134217728	; 0x8000000
   1e058:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
        clientObj->vendorData = F2R(false, VENDOR_IS_BIT_OP, clientObj->vendorData);
   1e05c:	4310      	orrs	r0, r2
   1e05e:	6060      	str	r0, [r4, #4]
   1e060:	e7e7      	b.n	1e032 <Lan867x_Read_Register+0xc>

Disassembly of section .text.DRV_MIIM_RegisterCallback%628:

0001e062 <DRV_MIIM_RegisterCallback>:
{
   1e062:	b538      	push	{r3, r4, r5, lr}
   1e064:	4615      	mov	r5, r2
        if(cbFunction == 0)
   1e066:	b181      	cbz	r1, 1e08a <DRV_MIIM_RegisterCallback+0x28>
   1e068:	460c      	mov	r4, r1
        if((pClient = _DRV_MIIM_GetClientAndLock(handle, true)) == 0)
   1e06a:	2101      	movs	r1, #1
   1e06c:	f7fe fc05 	bl	1c87a <_DRV_MIIM_GetClientAndLock>
   1e070:	4603      	mov	r3, r0
   1e072:	b188      	cbz	r0, 1e098 <DRV_MIIM_RegisterCallback+0x36>
        pClient->cbackHandler = cbFunction;
   1e074:	6084      	str	r4, [r0, #8]
    if(pRegResult)
   1e076:	b10d      	cbz	r5, 1e07c <DRV_MIIM_RegisterCallback+0x1a>
        *pRegResult = miimRes;
   1e078:	2200      	movs	r2, #0
   1e07a:	702a      	strb	r2, [r5, #0]
    OSAL_SEM_Post(&pMiimObj->objSem);
   1e07c:	6858      	ldr	r0, [r3, #4]
   1e07e:	f003 faa9 	bl	215d4 <OSAL_SEM_Post>
   1e082:	4620      	mov	r0, r4
}
   1e084:	bd38      	pop	{r3, r4, r5, pc}
    if(pRegResult)
   1e086:	4628      	mov	r0, r5
    return cbHandle;
   1e088:	e7fc      	b.n	1e084 <DRV_MIIM_RegisterCallback+0x22>
            miimRes = DRV_MIIM_RES_CALLBACK_HANDLE_ERR; 
   1e08a:	f06f 0302 	mvn.w	r3, #2
    if(pRegResult)
   1e08e:	2d00      	cmp	r5, #0
   1e090:	d0f9      	beq.n	1e086 <DRV_MIIM_RegisterCallback+0x24>
        *pRegResult = miimRes;
   1e092:	702b      	strb	r3, [r5, #0]
   1e094:	2000      	movs	r0, #0
   1e096:	e7f5      	b.n	1e084 <DRV_MIIM_RegisterCallback+0x22>
            miimRes = DRV_MIIM_RES_HANDLE_ERR;
   1e098:	f04f 33ff 	mov.w	r3, #4294967295
   1e09c:	e7f7      	b.n	1e08e <DRV_MIIM_RegisterCallback+0x2c>

Disassembly of section .text.hexatob%629:

0001e09e <hexatob>:
  	Resulting packed byte 0x00 - 0xFF.
  ***************************************************************************/
uint8_t hexatob(uint16_t AsciiVal)
{
    MCHP_UINT16_VAL AsciiChars;
    AsciiChars.Val = AsciiVal;
   1e09e:	4603      	mov	r3, r0

	// Convert lowercase to uppercase
	if(AsciiChars.v[1] > 'F')
   1e0a0:	0a02      	lsrs	r2, r0, #8
   1e0a2:	2a46      	cmp	r2, #70	; 0x46
		AsciiChars.v[1] -= 'a'-'A';
   1e0a4:	bf84      	itt	hi
   1e0a6:	3a20      	subhi	r2, #32
   1e0a8:	f362 230f 	bfihi	r3, r2, #8, #8
	if(AsciiChars.v[0] > 'F')
   1e0ac:	b2c0      	uxtb	r0, r0
   1e0ae:	2846      	cmp	r0, #70	; 0x46
		AsciiChars.v[0] -= 'a'-'A';
   1e0b0:	bf84      	itt	hi
   1e0b2:	3820      	subhi	r0, #32
   1e0b4:	f360 0307 	bfihi	r3, r0, #0, #8

	// Convert 0-9, A-F to 0x0-0xF
	if(AsciiChars.v[1] > '9')
   1e0b8:	f3c3 2007 	ubfx	r0, r3, #8, #8
   1e0bc:	2839      	cmp	r0, #57	; 0x39
		AsciiChars.v[1] -= 'A' - 10;
   1e0be:	bf8c      	ite	hi
   1e0c0:	3837      	subhi	r0, #55	; 0x37
	else
		AsciiChars.v[1] -= '0';
   1e0c2:	3830      	subls	r0, #48	; 0x30
   1e0c4:	b2c2      	uxtb	r2, r0

	if(AsciiChars.v[0] > '9')
   1e0c6:	b2db      	uxtb	r3, r3
   1e0c8:	2b39      	cmp	r3, #57	; 0x39
		AsciiChars.v[0] -= 'A' - 10;
   1e0ca:	bf8c      	ite	hi
   1e0cc:	3b37      	subhi	r3, #55	; 0x37
	else
		AsciiChars.v[0] -= '0';
   1e0ce:	3b30      	subls	r3, #48	; 0x30
   1e0d0:	b2d8      	uxtb	r0, r3

	// Concatenate
	return (AsciiChars.v[1]<<4) |  AsciiChars.v[0];
   1e0d2:	ea40 1002 	orr.w	r0, r0, r2, lsl #4
}
   1e0d6:	b2c0      	uxtb	r0, r0
   1e0d8:	4770      	bx	lr

Disassembly of section .text.TCPIP_TCP_Close%630:

0001e0da <TCPIP_TCP_Close>:
{
   1e0da:	b510      	push	{r4, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   1e0dc:	f001 fe9e 	bl	1fe1c <_TcpSocketChk>
    if(pSkt)
   1e0e0:	b1a8      	cbz	r0, 1e10e <TCPIP_TCP_Close+0x34>
   1e0e2:	4604      	mov	r4, r0
        if(pSkt->flags.nonGraceful == 0)
   1e0e4:	f990 306c 	ldrsb.w	r3, [r0, #108]	; 0x6c
   1e0e8:	2b00      	cmp	r3, #0
   1e0ea:	db09      	blt.n	1e100 <TCPIP_TCP_Close+0x26>
            pSkt->flags.forceKill = 1;
   1e0ec:	f890 306d 	ldrb.w	r3, [r0, #109]	; 0x6d
   1e0f0:	f043 0304 	orr.w	r3, r3, #4
   1e0f4:	f880 306d 	strb.w	r3, [r0, #109]	; 0x6d
            _TCP_SEND_RES sRes = _TcpDisconnect(pSkt, true);
   1e0f8:	2101      	movs	r1, #1
   1e0fa:	f7f8 fff9 	bl	170f0 <_TcpDisconnect>
            if(sRes != _TCP_SEND_OK)
   1e0fe:	b140      	cbz	r0, 1e112 <TCPIP_TCP_Close+0x38>
            _TcpAbort(pSkt, _TCP_ABORT_FLAG_FORCE_CLOSE, 0);
   1e100:	2200      	movs	r2, #0
   1e102:	2101      	movs	r1, #1
   1e104:	4620      	mov	r0, r4
   1e106:	f7fe f985 	bl	1c414 <_TcpAbort>
        return true;
   1e10a:	2001      	movs	r0, #1
   1e10c:	e000      	b.n	1e110 <TCPIP_TCP_Close+0x36>
    return false;
   1e10e:	2000      	movs	r0, #0
}
   1e110:	bd10      	pop	{r4, pc}
        return true;
   1e112:	2001      	movs	r0, #1
   1e114:	e7fc      	b.n	1e110 <TCPIP_TCP_Close+0x36>

Disassembly of section .text._DHCPOptionProcessRouter%631:

0001e116 <_DHCPOptionProcessRouter>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_ROUTER))
   1e116:	684b      	ldr	r3, [r1, #4]
   1e118:	2b05      	cmp	r3, #5
   1e11a:	d914      	bls.n	1e146 <_DHCPOptionProcessRouter+0x30>
        TCPIP_DHCP_OPTION_DATA_ROUTER* pRouter = (TCPIP_DHCP_OPTION_DATA_ROUTER*)pOptData->pOpt;
   1e11c:	680b      	ldr	r3, [r1, #0]
        if(pRouter->len >= sizeof(pRouter->gateway))
   1e11e:	785a      	ldrb	r2, [r3, #1]
   1e120:	2a03      	cmp	r2, #3
   1e122:	d913      	bls.n	1e14c <_DHCPOptionProcessRouter+0x36>
            if(pClient->flags.bOfferReceived == 0)
   1e124:	f890 2058 	ldrb.w	r2, [r0, #88]	; 0x58
   1e128:	f012 0f04 	tst.w	r2, #4
   1e12c:	d108      	bne.n	1e140 <_DHCPOptionProcessRouter+0x2a>
                memcpy(&pClient->dhcpGateway, pRouter->gateway, sizeof(pClient->dhcpGateway)); 
   1e12e:	f8d3 2002 	ldr.w	r2, [r3, #2]
   1e132:	6302      	str	r2, [r0, #48]	; 0x30
                pClient->validValues.Gateway = 1;
   1e134:	f890 2059 	ldrb.w	r2, [r0, #89]	; 0x59
   1e138:	f042 0202 	orr.w	r2, r2, #2
   1e13c:	f880 2059 	strb.w	r2, [r0, #89]	; 0x59
            return 2 + pRouter->len;
   1e140:	7858      	ldrb	r0, [r3, #1]
   1e142:	3002      	adds	r0, #2
   1e144:	4770      	bx	lr
    return -1;
   1e146:	f04f 30ff 	mov.w	r0, #4294967295
   1e14a:	4770      	bx	lr
   1e14c:	f04f 30ff 	mov.w	r0, #4294967295
}
   1e150:	4770      	bx	lr

Disassembly of section .text._DHCPNotifyClients%632:

0001e154 <_DHCPNotifyClients>:
{
   1e154:	b570      	push	{r4, r5, r6, lr}
   1e156:	4605      	mov	r5, r0
   1e158:	460e      	mov	r6, r1
    TCPIP_Helper_ProtectedSingleListLock(notifyList);
   1e15a:	4c0c      	ldr	r4, [pc, #48]	; (1e18c <_DHCPNotifyClients+0x38>)
   1e15c:	4620      	mov	r0, r4
   1e15e:	f002 fca7 	bl	20ab0 <TCPIP_Helper_ProtectedSingleListLock>
    for(dNode = (TCPIP_DHCP_LIST_NODE*)dhcpRegisteredUsers.list.head; dNode != 0; dNode = dNode->next)
   1e162:	6824      	ldr	r4, [r4, #0]
   1e164:	b95c      	cbnz	r4, 1e17e <_DHCPNotifyClients+0x2a>
    TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
   1e166:	4809      	ldr	r0, [pc, #36]	; (1e18c <_DHCPNotifyClients+0x38>)
   1e168:	f002 fee4 	bl	20f34 <TCPIP_Helper_ProtectedSingleListUnlock>
}
   1e16c:	bd70      	pop	{r4, r5, r6, pc}
            (*dNode->handler)(pNetIf, evType, dNode->hParam);
   1e16e:	6863      	ldr	r3, [r4, #4]
   1e170:	68a2      	ldr	r2, [r4, #8]
   1e172:	4631      	mov	r1, r6
   1e174:	4628      	mov	r0, r5
   1e176:	4798      	blx	r3
    for(dNode = (TCPIP_DHCP_LIST_NODE*)dhcpRegisteredUsers.list.head; dNode != 0; dNode = dNode->next)
   1e178:	6824      	ldr	r4, [r4, #0]
   1e17a:	2c00      	cmp	r4, #0
   1e17c:	d0f3      	beq.n	1e166 <_DHCPNotifyClients+0x12>
        if(dNode->hNet == 0 || dNode->hNet == pNetIf)
   1e17e:	68e3      	ldr	r3, [r4, #12]
   1e180:	2b00      	cmp	r3, #0
   1e182:	d0f4      	beq.n	1e16e <_DHCPNotifyClients+0x1a>
   1e184:	42ab      	cmp	r3, r5
   1e186:	d1f7      	bne.n	1e178 <_DHCPNotifyClients+0x24>
   1e188:	e7f1      	b.n	1e16e <_DHCPNotifyClients+0x1a>
   1e18a:	bf00      	nop
   1e18c:	2000e250 	.word	0x2000e250

Disassembly of section .text.TCPIP_DHCP_IsEnabled%633:

0001e190 <TCPIP_DHCP_IsEnabled>:
   1e190:	b138      	cbz	r0, 1e1a2 <TCPIP_DHCP_IsEnabled+0x12>
   1e192:	4603      	mov	r3, r0
   1e194:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1e198:	f012 0f40 	tst.w	r2, #64	; 0x40
   1e19c:	d103      	bne.n	1e1a6 <TCPIP_DHCP_IsEnabled+0x16>
    return false;
   1e19e:	2000      	movs	r0, #0
   1e1a0:	4770      	bx	lr
   1e1a2:	2000      	movs	r0, #0
}
   1e1a4:	4770      	bx	lr
{
   1e1a6:	b510      	push	{r4, lr}
    if(DHCPClients && pNetIf)
   1e1a8:	4a07      	ldr	r2, [pc, #28]	; (1e1c8 <TCPIP_DHCP_IsEnabled+0x38>)
   1e1aa:	6814      	ldr	r4, [r2, #0]
   1e1ac:	b154      	cbz	r4, 1e1c4 <TCPIP_DHCP_IsEnabled+0x34>
   1e1ae:	4618      	mov	r0, r3
        DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   1e1b0:	f003 fdb8 	bl	21d24 <TCPIP_STACK_NetIxGet>
        return pClient->flags.bDHCPEnabled != 0;
   1e1b4:	235c      	movs	r3, #92	; 0x5c
   1e1b6:	fb03 4000 	mla	r0, r3, r0, r4
   1e1ba:	f890 0058 	ldrb.w	r0, [r0, #88]	; 0x58
   1e1be:	f000 0001 	and.w	r0, r0, #1
}
   1e1c2:	bd10      	pop	{r4, pc}
    return false;
   1e1c4:	2000      	movs	r0, #0
   1e1c6:	e7fc      	b.n	1e1c2 <TCPIP_DHCP_IsEnabled+0x32>
   1e1c8:	2000e408 	.word	0x2000e408

Disassembly of section .text._TCPIPStackModuleSignalGet%634:

0001e1cc <_TCPIPStackModuleSignalGet>:
{
   1e1cc:	b570      	push	{r4, r5, r6, lr}
   1e1ce:	460e      	mov	r6, r1
    TCPIP_MODULE_SIGNAL_ENTRY* pSignalEntry = TCPIP_STACK_MODULE_SIGNAL_TBL + modId;
   1e1d0:	4c0b      	ldr	r4, [pc, #44]	; (1e200 <_TCPIPStackModuleSignalGet+0x34>)
   1e1d2:	eb04 1400 	add.w	r4, r4, r0, lsl #4
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1e1d6:	2000      	movs	r0, #0
   1e1d8:	f003 f9f0 	bl	215bc <OSAL_CRIT_Enter>
   1e1dc:	4601      	mov	r1, r0
    TCPIP_MODULE_SIGNAL modSignal = pSignalEntry->signalVal;
   1e1de:	8925      	ldrh	r5, [r4, #8]
    pSignalEntry->signalVal &= (uint16_t)(~clrMask);
   1e1e0:	ea25 0306 	bic.w	r3, r5, r6
   1e1e4:	8123      	strh	r3, [r4, #8]
    if((clrMask & TCPIP_MODULE_SIGNAL_ASYNC) != 0)
   1e1e6:	f416 7f80 	tst.w	r6, #256	; 0x100
   1e1ea:	d003      	beq.n	1e1f4 <_TCPIPStackModuleSignalGet+0x28>
        stackAsyncSignalCount -= 1; 
   1e1ec:	4a05      	ldr	r2, [pc, #20]	; (1e204 <_TCPIPStackModuleSignalGet+0x38>)
   1e1ee:	6813      	ldr	r3, [r2, #0]
   1e1f0:	3b01      	subs	r3, #1
   1e1f2:	6013      	str	r3, [r2, #0]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1e1f4:	2000      	movs	r0, #0
   1e1f6:	f003 fb10 	bl	2181a <OSAL_CRIT_Leave>
}
   1e1fa:	4628      	mov	r0, r5
   1e1fc:	bd70      	pop	{r4, r5, r6, pc}
   1e1fe:	bf00      	nop
   1e200:	2000d1d4 	.word	0x2000d1d4
   1e204:	2000e434 	.word	0x2000e434

Disassembly of section .text._TCPIP_PKT_PacketFree%635:

0001e208 <_TCPIP_PKT_PacketFree>:
}

// frees a previously allocated packet
void _TCPIP_PKT_PacketFree(TCPIP_MAC_PACKET* pPkt)
{
    if((pPkt->pktFlags & TCPIP_MAC_PKT_FLAG_STATIC) == 0)
   1e208:	8c43      	ldrh	r3, [r0, #34]	; 0x22
   1e20a:	f013 0f01 	tst.w	r3, #1
   1e20e:	d116      	bne.n	1e23e <_TCPIP_PKT_PacketFree+0x36>
{
   1e210:	b570      	push	{r4, r5, r6, lr}
   1e212:	4605      	mov	r5, r0
    {   // we don't deallocate static packets
        TCPIP_MAC_DATA_SEGMENT  *pSeg, *pNSeg;

        for( pSeg = pPkt->pDSeg; pSeg != 0; pSeg = pNSeg )
   1e214:	6901      	ldr	r1, [r0, #16]
   1e216:	b161      	cbz	r1, 1e232 <_TCPIP_PKT_PacketFree+0x2a>
        {
            pNSeg = pSeg->next;
            if((pSeg->segFlags & TCPIP_MAC_SEG_FLAG_STATIC) == 0)
            {
                TCPIP_HEAP_Free(pktMemH, pSeg);
   1e218:	4e09      	ldr	r6, [pc, #36]	; (1e240 <_TCPIP_PKT_PacketFree+0x38>)
   1e21a:	e001      	b.n	1e220 <_TCPIP_PKT_PacketFree+0x18>
   1e21c:	4621      	mov	r1, r4
        for( pSeg = pPkt->pDSeg; pSeg != 0; pSeg = pNSeg )
   1e21e:	b144      	cbz	r4, 1e232 <_TCPIP_PKT_PacketFree+0x2a>
            pNSeg = pSeg->next;
   1e220:	680c      	ldr	r4, [r1, #0]
            if((pSeg->segFlags & TCPIP_MAC_SEG_FLAG_STATIC) == 0)
   1e222:	8a0b      	ldrh	r3, [r1, #16]
   1e224:	f013 0f01 	tst.w	r3, #1
   1e228:	d1f8      	bne.n	1e21c <_TCPIP_PKT_PacketFree+0x14>
                TCPIP_HEAP_Free(pktMemH, pSeg);
   1e22a:	6830      	ldr	r0, [r6, #0]
   1e22c:	68c3      	ldr	r3, [r0, #12]
   1e22e:	4798      	blx	r3
   1e230:	e7f4      	b.n	1e21c <_TCPIP_PKT_PacketFree+0x14>
            }
        }

        TCPIP_HEAP_Free(pktMemH, pPkt);
   1e232:	4b03      	ldr	r3, [pc, #12]	; (1e240 <_TCPIP_PKT_PacketFree+0x38>)
   1e234:	6818      	ldr	r0, [r3, #0]
   1e236:	68c3      	ldr	r3, [r0, #12]
   1e238:	4629      	mov	r1, r5
   1e23a:	4798      	blx	r3
    }
}
   1e23c:	bd70      	pop	{r4, r5, r6, pc}
   1e23e:	4770      	bx	lr
   1e240:	2000e450 	.word	0x2000e450

Disassembly of section .text.TCPIP_UDP_OpenClientSkt%636:

0001e244 <TCPIP_UDP_OpenClientSkt>:
    if(addType == IP_ADDRESS_TYPE_IPV6)
   1e244:	2802      	cmp	r0, #2
   1e246:	d015      	beq.n	1e274 <TCPIP_UDP_OpenClientSkt+0x30>
{
   1e248:	b508      	push	{r3, lr}
   1e24a:	4618      	mov	r0, r3
   1e24c:	4613      	mov	r3, r2
   1e24e:	460a      	mov	r2, r1
    skt = _UDPOpen(addType, opType, remotePort, remoteAddress);
   1e250:	4601      	mov	r1, r0
   1e252:	2001      	movs	r0, #1
   1e254:	f7f3 fab0 	bl	117b8 <_UDPOpen>
    if(skt != INVALID_UDP_SOCKET)
   1e258:	f1b0 3fff 	cmp.w	r0, #4294967295
   1e25c:	d009      	beq.n	1e272 <TCPIP_UDP_OpenClientSkt+0x2e>
        UDP_SOCKET_DCPT* pSkt = UDPSocketDcpt[skt];
   1e25e:	4b07      	ldr	r3, [pc, #28]	; (1e27c <TCPIP_UDP_OpenClientSkt+0x38>)
   1e260:	681b      	ldr	r3, [r3, #0]
   1e262:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
    pSkt->extFlags.rxEnable = 1;
   1e266:	f892 3042 	ldrb.w	r3, [r2, #66]	; 0x42
   1e26a:	f043 0302 	orr.w	r3, r3, #2
   1e26e:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
}
   1e272:	bd08      	pop	{r3, pc}
        return INVALID_SOCKET; 
   1e274:	f04f 30ff 	mov.w	r0, #4294967295
}
   1e278:	4770      	bx	lr
   1e27a:	bf00      	nop
   1e27c:	2000e454 	.word	0x2000e454

Disassembly of section .text.Console_UART_Read%637:

0001e280 <Console_UART_Read>:
    pConsoleUartData->status = SYS_CONSOLE_STATUS_CONFIGURED;
}

/* Read out the data from the RX Ring Buffer */
ssize_t Console_UART_Read(uint32_t index, void* pRdBuffer, size_t count)
{
   1e280:	b570      	push	{r4, r5, r6, lr}
    ssize_t nBytesRead = 0;
    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   1e282:	b990      	cbnz	r0, 1e2aa <Console_UART_Read+0x2a>
   1e284:	4615      	mov	r5, r2
   1e286:	460c      	mov	r4, r1
    if (pConsoleUartData == NULL)
    {
        return -1;
    }

    if (Console_UART_ResourceLock(pConsoleUartData) == false)
   1e288:	480b      	ldr	r0, [pc, #44]	; (1e2b8 <Console_UART_Read+0x38>)
   1e28a:	f003 fb95 	bl	219b8 <Console_UART_ResourceLock>
   1e28e:	b178      	cbz	r0, 1e2b0 <Console_UART_Read+0x30>
    {
        return -1;
    }

    nBytesRead = pConsoleUartData->uartPLIB->read(pRdBuffer, count);
   1e290:	4e09      	ldr	r6, [pc, #36]	; (1e2b8 <Console_UART_Read+0x38>)
   1e292:	f856 3b08 	ldr.w	r3, [r6], #8
   1e296:	681b      	ldr	r3, [r3, #0]
   1e298:	4629      	mov	r1, r5
   1e29a:	4620      	mov	r0, r4
   1e29c:	4798      	blx	r3
   1e29e:	4604      	mov	r4, r0
    OSAL_MUTEX_Unlock(&(pConsoleUartData->mutexTransferObjects));
   1e2a0:	4630      	mov	r0, r6
   1e2a2:	f003 f9af 	bl	21604 <OSAL_MUTEX_Unlock>

    Console_UART_ResourceUnlock(pConsoleUartData);

    return nBytesRead;
}
   1e2a6:	4620      	mov	r0, r4
   1e2a8:	bd70      	pop	{r4, r5, r6, pc}
        return -1;
   1e2aa:	f04f 34ff 	mov.w	r4, #4294967295
   1e2ae:	e7fa      	b.n	1e2a6 <Console_UART_Read+0x26>
        return -1;
   1e2b0:	f04f 34ff 	mov.w	r4, #4294967295
   1e2b4:	e7f7      	b.n	1e2a6 <Console_UART_Read+0x26>
   1e2b6:	bf00      	nop
   1e2b8:	2000e334 	.word	0x2000e334

Disassembly of section .text.Console_UART_Write%638:

0001e2bc <Console_UART_Write>:

    return nFreeBufferAvailable;
}

ssize_t Console_UART_Write(uint32_t index, const void* pWrBuffer, size_t count )
{
   1e2bc:	b570      	push	{r4, r5, r6, lr}
    ssize_t nBytesWritten = 0;

    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   1e2be:	b990      	cbnz	r0, 1e2e6 <Console_UART_Write+0x2a>
   1e2c0:	4615      	mov	r5, r2
   1e2c2:	460c      	mov	r4, r1
    if (pConsoleUartData == NULL)
    {
        return -1;
    }

    if (Console_UART_ResourceLock(pConsoleUartData) == false)
   1e2c4:	480b      	ldr	r0, [pc, #44]	; (1e2f4 <Console_UART_Write+0x38>)
   1e2c6:	f003 fb77 	bl	219b8 <Console_UART_ResourceLock>
   1e2ca:	b178      	cbz	r0, 1e2ec <Console_UART_Write+0x30>
    {
        return -1;
    }

    nBytesWritten = pConsoleUartData->uartPLIB->write((uint8_t*)pWrBuffer, count);
   1e2cc:	4e09      	ldr	r6, [pc, #36]	; (1e2f4 <Console_UART_Write+0x38>)
   1e2ce:	f856 3b08 	ldr.w	r3, [r6], #8
   1e2d2:	68db      	ldr	r3, [r3, #12]
   1e2d4:	4629      	mov	r1, r5
   1e2d6:	4620      	mov	r0, r4
   1e2d8:	4798      	blx	r3
   1e2da:	4604      	mov	r4, r0
    OSAL_MUTEX_Unlock(&(pConsoleUartData->mutexTransferObjects));
   1e2dc:	4630      	mov	r0, r6
   1e2de:	f003 f991 	bl	21604 <OSAL_MUTEX_Unlock>

    Console_UART_ResourceUnlock(pConsoleUartData);

    return nBytesWritten;
}
   1e2e2:	4620      	mov	r0, r4
   1e2e4:	bd70      	pop	{r4, r5, r6, pc}
        return -1;
   1e2e6:	f04f 34ff 	mov.w	r4, #4294967295
   1e2ea:	e7fa      	b.n	1e2e2 <Console_UART_Write+0x26>
        return -1;
   1e2ec:	f04f 34ff 	mov.w	r4, #4294967295
   1e2f0:	e7f7      	b.n	1e2e2 <Console_UART_Write+0x26>
   1e2f2:	bf00      	nop
   1e2f4:	2000e334 	.word	0x2000e334

Disassembly of section .text.SYS_TIME_GetTimerObject%639:

0001e2f8 <SYS_TIME_GetTimerObject>:
    if ((handle != SYS_TIME_HANDLE_INVALID) && (handle != 0))
   1e2f8:	1e43      	subs	r3, r0, #1
   1e2fa:	f113 0f03 	cmn.w	r3, #3
   1e2fe:	d80f      	bhi.n	1e320 <SYS_TIME_GetTimerObject+0x28>
        if ((handle & _SYS_TIME_INDEX_MASK) < SYS_TIME_MAX_TIMERS)
   1e300:	b283      	uxth	r3, r0
   1e302:	2b04      	cmp	r3, #4
   1e304:	d80e      	bhi.n	1e324 <SYS_TIME_GetTimerObject+0x2c>
            if ((timerObj->tmrHandle == handle) && (timerObj->inUse == true))
   1e306:	4a0a      	ldr	r2, [pc, #40]	; (1e330 <SYS_TIME_GetTimerObject+0x38>)
   1e308:	eb02 1243 	add.w	r2, r2, r3, lsl #5
   1e30c:	69d2      	ldr	r2, [r2, #28]
   1e30e:	4282      	cmp	r2, r0
   1e310:	d10a      	bne.n	1e328 <SYS_TIME_GetTimerObject+0x30>
   1e312:	015a      	lsls	r2, r3, #5
   1e314:	4906      	ldr	r1, [pc, #24]	; (1e330 <SYS_TIME_GetTimerObject+0x38>)
   1e316:	5c8a      	ldrb	r2, [r1, r2]
   1e318:	b142      	cbz	r2, 1e32c <SYS_TIME_GetTimerObject+0x34>
            timerObj = &timers[handle & _SYS_TIME_INDEX_MASK];
   1e31a:	eb01 1043 	add.w	r0, r1, r3, lsl #5
                return timerObj;
   1e31e:	4770      	bx	lr
    return NULL;
   1e320:	2000      	movs	r0, #0
   1e322:	4770      	bx	lr
   1e324:	2000      	movs	r0, #0
   1e326:	4770      	bx	lr
   1e328:	2000      	movs	r0, #0
   1e32a:	4770      	bx	lr
   1e32c:	2000      	movs	r0, #0
}
   1e32e:	4770      	bx	lr
   1e330:	2000db50 	.word	0x2000db50

Disassembly of section .text.SYS_TIME_ResourceUnlock%640:

0001e334 <SYS_TIME_ResourceUnlock>:
{
   1e334:	b508      	push	{r3, lr}
    SYS_INT_SourceEnable(gSystemCounterObj.hwTimerIntNum);
   1e336:	4b0b      	ldr	r3, [pc, #44]	; (1e364 <SYS_TIME_ResourceUnlock+0x30>)
   1e338:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
  if ((int32_t)(IRQn) >= 0)
   1e33c:	2b00      	cmp	r3, #0
   1e33e:	db08      	blt.n	1e352 <SYS_TIME_ResourceUnlock+0x1e>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1e340:	0959      	lsrs	r1, r3, #5
   1e342:	f003 031f 	and.w	r3, r3, #31
   1e346:	2201      	movs	r2, #1
   1e348:	fa02 f303 	lsl.w	r3, r2, r3
   1e34c:	4a06      	ldr	r2, [pc, #24]	; (1e368 <SYS_TIME_ResourceUnlock+0x34>)
   1e34e:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    if(gSystemCounterObj.interruptNestingCount == 0)
   1e352:	4b04      	ldr	r3, [pc, #16]	; (1e364 <SYS_TIME_ResourceUnlock+0x30>)
   1e354:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   1e358:	b103      	cbz	r3, 1e35c <SYS_TIME_ResourceUnlock+0x28>
}
   1e35a:	bd08      	pop	{r3, pc}
        OSAL_MUTEX_Unlock(&gSystemCounterObj.timerMutex);
   1e35c:	4803      	ldr	r0, [pc, #12]	; (1e36c <SYS_TIME_ResourceUnlock+0x38>)
   1e35e:	f003 f951 	bl	21604 <OSAL_MUTEX_Unlock>
}
   1e362:	e7fa      	b.n	1e35a <SYS_TIME_ResourceUnlock+0x26>
   1e364:	2000e030 	.word	0x2000e030
   1e368:	e000e100 	.word	0xe000e100
   1e36c:	2000e064 	.word	0x2000e064

Disassembly of section .text.SYS_TIME_Counter64Get%641:

0001e370 <SYS_TIME_Counter64Get>:
{
   1e370:	b538      	push	{r3, r4, r5, lr}
    if (SYS_TIME_ResourceLock() == false)
   1e372:	f000 fa77 	bl	1e864 <SYS_TIME_ResourceLock>
   1e376:	b1a0      	cbz	r0, 1e3a2 <SYS_TIME_Counter64Get+0x32>
    elapsedCount = SYS_TIME_GetElapsedCount(counterObj->timePlib->timerCounterGet());
   1e378:	4c0b      	ldr	r4, [pc, #44]	; (1e3a8 <SYS_TIME_Counter64Get+0x38>)
   1e37a:	6863      	ldr	r3, [r4, #4]
   1e37c:	699b      	ldr	r3, [r3, #24]
   1e37e:	4798      	blx	r3
   1e380:	f002 fe9c 	bl	210bc <SYS_TIME_GetElapsedCount>
    uint32_t prevSwCounter32Bit = counterObj->swCounter64Low;
   1e384:	6a63      	ldr	r3, [r4, #36]	; 0x24
    counter64 = counterObj->swCounter64High;
   1e386:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    if (isSwCounter32Oveflow == true)
   1e388:	18c0      	adds	r0, r0, r3
   1e38a:	d208      	bcs.n	1e39e <SYS_TIME_Counter64Get+0x2e>
    counter64 = ((counter64 << 32) + counter32);
   1e38c:	2200      	movs	r2, #0
   1e38e:	1814      	adds	r4, r2, r0
   1e390:	f141 0500 	adc.w	r5, r1, #0
    SYS_TIME_ResourceUnlock();
   1e394:	f7ff ffce 	bl	1e334 <SYS_TIME_ResourceUnlock>
}
   1e398:	4620      	mov	r0, r4
   1e39a:	4629      	mov	r1, r5
   1e39c:	bd38      	pop	{r3, r4, r5, pc}
        counter64++;
   1e39e:	3101      	adds	r1, #1
   1e3a0:	e7f4      	b.n	1e38c <SYS_TIME_Counter64Get+0x1c>
        return counter64;
   1e3a2:	2400      	movs	r4, #0
   1e3a4:	2500      	movs	r5, #0
   1e3a6:	e7f7      	b.n	1e398 <SYS_TIME_Counter64Get+0x28>
   1e3a8:	2000e030 	.word	0x2000e030

Disassembly of section .text.SYS_TIME_TimerDestroy%642:

0001e3ac <SYS_TIME_TimerDestroy>:
{
   1e3ac:	b510      	push	{r4, lr}
   1e3ae:	4604      	mov	r4, r0
    if (SYS_TIME_ResourceLock() == false)
   1e3b0:	f000 fa58 	bl	1e864 <SYS_TIME_ResourceLock>
   1e3b4:	b1b0      	cbz	r0, 1e3e4 <SYS_TIME_TimerDestroy+0x38>
    tmr = SYS_TIME_GetTimerObject(handle);
   1e3b6:	4620      	mov	r0, r4
   1e3b8:	f7ff ff9e 	bl	1e2f8 <SYS_TIME_GetTimerObject>
    if(tmr != NULL)
   1e3bc:	4604      	mov	r4, r0
   1e3be:	b178      	cbz	r0, 1e3e0 <SYS_TIME_TimerDestroy+0x34>
        if(tmr->active == true)
   1e3c0:	7843      	ldrb	r3, [r0, #1]
   1e3c2:	b943      	cbnz	r3, 1e3d6 <SYS_TIME_TimerDestroy+0x2a>
        tmr->tmrElapsedFlag = false;
   1e3c4:	2000      	movs	r0, #0
   1e3c6:	7520      	strb	r0, [r4, #20]
        tmr->tmrElapsed = false;
   1e3c8:	7560      	strb	r0, [r4, #21]
        tmr->inUse = false;
   1e3ca:	7020      	strb	r0, [r4, #0]
        result = SYS_TIME_SUCCESS;
   1e3cc:	4604      	mov	r4, r0
    SYS_TIME_ResourceUnlock();
   1e3ce:	f7ff ffb1 	bl	1e334 <SYS_TIME_ResourceUnlock>
}
   1e3d2:	4620      	mov	r0, r4
   1e3d4:	bd10      	pop	{r4, pc}
            SYS_TIME_RemoveFromList(tmr);
   1e3d6:	f7fd fb5f 	bl	1ba98 <SYS_TIME_RemoveFromList>
            tmr->active = false;
   1e3da:	2300      	movs	r3, #0
   1e3dc:	7063      	strb	r3, [r4, #1]
   1e3de:	e7f1      	b.n	1e3c4 <SYS_TIME_TimerDestroy+0x18>
    SYS_TIME_RESULT result = SYS_TIME_ERROR;
   1e3e0:	2401      	movs	r4, #1
   1e3e2:	e7f4      	b.n	1e3ce <SYS_TIME_TimerDestroy+0x22>
        return result;
   1e3e4:	2401      	movs	r4, #1
   1e3e6:	e7f4      	b.n	1e3d2 <SYS_TIME_TimerDestroy+0x26>

Disassembly of section .text.wc_InitMd5_ex%643:

0001e3e8 <wc_InitMd5_ex>:
    if (md5 == NULL)
   1e3e8:	4603      	mov	r3, r0
   1e3ea:	b1a8      	cbz	r0, 1e418 <wc_InitMd5_ex+0x30>
    md5->heap = heap;
   1e3ec:	65c1      	str	r1, [r0, #92]	; 0x5c
    md5->digest[0] = 0x67452301L;
   1e3ee:	4a0c      	ldr	r2, [pc, #48]	; (1e420 <wc_InitMd5_ex+0x38>)
   1e3f0:	64c2      	str	r2, [r0, #76]	; 0x4c
    md5->digest[1] = 0xefcdab89L;
   1e3f2:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
   1e3f6:	6502      	str	r2, [r0, #80]	; 0x50
    md5->digest[2] = 0x98badcfeL;
   1e3f8:	f102 4229 	add.w	r2, r2, #2835349504	; 0xa9000000
   1e3fc:	f5a2 1296 	sub.w	r2, r2, #1228800	; 0x12c000
   1e400:	f6a2 628b 	subw	r2, r2, #3723	; 0xe8b
   1e404:	6542      	str	r2, [r0, #84]	; 0x54
    md5->digest[3] = 0x10325476L;
   1e406:	f1a2 3288 	sub.w	r2, r2, #2290649224	; 0x88888888
   1e40a:	6582      	str	r2, [r0, #88]	; 0x58
    md5->buffLen = 0;
   1e40c:	2000      	movs	r0, #0
   1e40e:	6018      	str	r0, [r3, #0]
    md5->loLen   = 0;
   1e410:	6058      	str	r0, [r3, #4]
    md5->hiLen   = 0;
   1e412:	6098      	str	r0, [r3, #8]
    md5->flags = 0;
   1e414:	6618      	str	r0, [r3, #96]	; 0x60
    if (ret != 0)
   1e416:	4770      	bx	lr
        return BAD_FUNC_ARG;
   1e418:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
   1e41c:	4770      	bx	lr
   1e41e:	bf00      	nop
   1e420:	67452301 	.word	0x67452301

Disassembly of section .text.__assert_func%644:

0001e424 <__assert_func>:
   1e424:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   1e426:	461c      	mov	r4, r3
   1e428:	4b09      	ldr	r3, [pc, #36]	; (1e450 <__assert_func+0x2c>)
   1e42a:	681b      	ldr	r3, [r3, #0]
   1e42c:	4605      	mov	r5, r0
   1e42e:	68d8      	ldr	r0, [r3, #12]
   1e430:	b152      	cbz	r2, 1e448 <__assert_func+0x24>
   1e432:	4b08      	ldr	r3, [pc, #32]	; (1e454 <__assert_func+0x30>)
   1e434:	9100      	str	r1, [sp, #0]
   1e436:	e9cd 3201 	strd	r3, r2, [sp, #4]
   1e43a:	4907      	ldr	r1, [pc, #28]	; (1e458 <__assert_func+0x34>)
   1e43c:	462b      	mov	r3, r5
   1e43e:	4622      	mov	r2, r4
   1e440:	f002 f90e 	bl	20660 <fiprintf>
   1e444:	f003 fc83 	bl	21d4e <abort>
   1e448:	4b04      	ldr	r3, [pc, #16]	; (1e45c <__assert_func+0x38>)
   1e44a:	461a      	mov	r2, r3
   1e44c:	e7f2      	b.n	1e434 <__assert_func+0x10>
   1e44e:	bf00      	nop
   1e450:	2000e4e4 	.word	0x2000e4e4
   1e454:	0001dfad 	.word	0x0001dfad
   1e458:	0001dfba 	.word	0x0001dfba
   1e45c:	0001dfac 	.word	0x0001dfac

Disassembly of section .text._fwalk_reent%645:

0001e460 <_fwalk_reent>:
   1e460:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1e464:	4680      	mov	r8, r0
   1e466:	4689      	mov	r9, r1
   1e468:	f100 0448 	add.w	r4, r0, #72	; 0x48
   1e46c:	2600      	movs	r6, #0
   1e46e:	b914      	cbnz	r4, 1e476 <_fwalk_reent+0x16>
   1e470:	4630      	mov	r0, r6
   1e472:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1e476:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
   1e47a:	3f01      	subs	r7, #1
   1e47c:	d501      	bpl.n	1e482 <_fwalk_reent+0x22>
   1e47e:	6824      	ldr	r4, [r4, #0]
   1e480:	e7f5      	b.n	1e46e <_fwalk_reent+0xe>
   1e482:	89ab      	ldrh	r3, [r5, #12]
   1e484:	2b01      	cmp	r3, #1
   1e486:	d907      	bls.n	1e498 <_fwalk_reent+0x38>
   1e488:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
   1e48c:	3301      	adds	r3, #1
   1e48e:	d003      	beq.n	1e498 <_fwalk_reent+0x38>
   1e490:	4629      	mov	r1, r5
   1e492:	4640      	mov	r0, r8
   1e494:	47c8      	blx	r9
   1e496:	4306      	orrs	r6, r0
   1e498:	3564      	adds	r5, #100	; 0x64
   1e49a:	e7ee      	b.n	1e47a <_fwalk_reent+0x1a>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase1%646:

0001e49c <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase1>:
{
   1e49c:	b510      	push	{r4, lr}
   1e49e:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1e4a0:	f002 f980 	bl	207a4 <_DRV_PHY_SMITransfer_Wait>
   1e4a4:	b180      	cbz	r0, 1e4c8 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase1+0x2c>
    matchCpbl = (hClientObj->operReg[0] & (MAC_COMM_CPBL_MASK | _BMSTAT_AN_ABLE_MASK)) & phyCpbl; // common features
   1e4a6:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   1e4a8:	8f62      	ldrh	r2, [r4, #58]	; 0x3a
   1e4aa:	4013      	ands	r3, r2
    if(!(matchCpbl & MAC_COMM_CPBL_MASK))
   1e4ac:	f413 4ff0 	tst.w	r3, #30720	; 0x7800
   1e4b0:	d00b      	beq.n	1e4ca <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase1+0x2e>
    matchCpbl = (hClientObj->operReg[0] & (MAC_COMM_CPBL_MASK | _BMSTAT_AN_ABLE_MASK)) & phyCpbl; // common features
   1e4b2:	f423 4307 	bic.w	r3, r3, #34560	; 0x8700
   1e4b6:	f023 03f7 	bic.w	r3, r3, #247	; 0xf7
    hClientObj->operReg[1] = matchCpbl;
   1e4ba:	84a3      	strh	r3, [r4, #36]	; 0x24
    hClientObj->vendorData = 0;
   1e4bc:	2300      	movs	r3, #0
   1e4be:	6423      	str	r3, [r4, #64]	; 0x40
    hClientObj->operPhase = operPhase;
   1e4c0:	2303      	movs	r3, #3
   1e4c2:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1e4c4:	2302      	movs	r3, #2
   1e4c6:	8423      	strh	r3, [r4, #32]
}
   1e4c8:	bd10      	pop	{r4, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_CPBL_ERR);
   1e4ca:	f06f 0102 	mvn.w	r1, #2
   1e4ce:	4620      	mov	r0, r4
   1e4d0:	f001 fc2c 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
        return;
   1e4d4:	e7f8      	b.n	1e4c8 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase1+0x2c>

Disassembly of section .text._DRV_ETHPHY_NegRestartPhaseRead%647:

0001e4d6 <_DRV_ETHPHY_NegRestartPhaseRead>:
{
   1e4d6:	b510      	push	{r4, lr}
   1e4d8:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1e4da:	f002 f963 	bl	207a4 <_DRV_PHY_SMITransfer_Wait>
   1e4de:	b158      	cbz	r0, 1e4f8 <_DRV_ETHPHY_NegRestartPhaseRead+0x22>
    if(phyCpbl.AN_ABLE == 0)
   1e4e0:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
   1e4e4:	f013 0f08 	tst.w	r3, #8
   1e4e8:	d007      	beq.n	1e4fa <_DRV_ETHPHY_NegRestartPhaseRead+0x24>
    if(_DRV_PHY_SMIWriteStart(hClientObj, PHY_REG_BMCON, _BMCON_AN_ENABLE_MASK | _BMCON_AN_RESTART_MASK ))
   1e4ea:	f44f 5290 	mov.w	r2, #4608	; 0x1200
   1e4ee:	2100      	movs	r1, #0
   1e4f0:	4620      	mov	r0, r4
   1e4f2:	f000 fd1c 	bl	1ef2e <_DRV_PHY_SMIWriteStart>
   1e4f6:	b930      	cbnz	r0, 1e506 <_DRV_ETHPHY_NegRestartPhaseRead+0x30>
}
   1e4f8:	bd10      	pop	{r4, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_NEGOTIATION_UNABLE);
   1e4fa:	f06f 0105 	mvn.w	r1, #5
   1e4fe:	4620      	mov	r0, r4
   1e500:	f001 fc14 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
        return;
   1e504:	e7f8      	b.n	1e4f8 <_DRV_ETHPHY_NegRestartPhaseRead+0x22>
    hClientObj->operPhase = operPhase;
   1e506:	2302      	movs	r3, #2
   1e508:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1e50a:	2300      	movs	r3, #0
   1e50c:	8423      	strh	r3, [r4, #32]
   1e50e:	e7f3      	b.n	1e4f8 <_DRV_ETHPHY_NegRestartPhaseRead+0x22>

Disassembly of section .text._DRV_MIIM_ReleaseOpDcpt%648:

0001e510 <_DRV_MIIM_ReleaseOpDcpt>:
{
   1e510:	b570      	push	{r4, r5, r6, lr}
   1e512:	4605      	mov	r5, r0
   1e514:	460c      	mov	r4, r1
    pRemNode =  (DRV_MIIM_OP_DCPT*)Helper_SingleListNodeRemove(pRemList, (SGL_LIST_NODE*)pOpDcpt);
   1e516:	4610      	mov	r0, r2
   1e518:	f7fe fff2 	bl	1d500 <Helper_SingleListNodeRemove>
    if(pRemNode == pOpDcpt)
   1e51c:	4284      	cmp	r4, r0
   1e51e:	d000      	beq.n	1e522 <_DRV_MIIM_ReleaseOpDcpt+0x12>
}
   1e520:	bd70      	pop	{r4, r5, r6, pc}
        wasScan = pOpDcpt->opType == DRV_MIIM_OP_SCAN; 
   1e522:	7926      	ldrb	r6, [r4, #4]
        memset(pOpDcpt, 0, sizeof(*pOpDcpt));
   1e524:	2300      	movs	r3, #0
   1e526:	6023      	str	r3, [r4, #0]
   1e528:	6063      	str	r3, [r4, #4]
   1e52a:	60a3      	str	r3, [r4, #8]
   1e52c:	60e3      	str	r3, [r4, #12]
    Helper_SingleListTailAdd(pL, (SGL_LIST_NODE*)pOpDcpt);
   1e52e:	4621      	mov	r1, r4
   1e530:	f105 0070 	add.w	r0, r5, #112	; 0x70
   1e534:	f002 fe69 	bl	2120a <Helper_SingleListTailAdd>
    pOpDcpt->qType = qType;
   1e538:	2301      	movs	r3, #1
   1e53a:	72e3      	strb	r3, [r4, #11]
    if(wasScan)
   1e53c:	2e03      	cmp	r6, #3
   1e53e:	d1ef      	bne.n	1e520 <_DRV_MIIM_ReleaseOpDcpt+0x10>
        pMiimObj->objFlags &= ~DRV_MIIM_OBJ_FLAG_IS_SCANNING;
   1e540:	88ab      	ldrh	r3, [r5, #4]
   1e542:	f023 0308 	bic.w	r3, r3, #8
   1e546:	80ab      	strh	r3, [r5, #4]
}
   1e548:	e7ea      	b.n	1e520 <_DRV_MIIM_ReleaseOpDcpt+0x10>

Disassembly of section .text.DRV_MIIM_Deinitialize%649:

0001e54a <DRV_MIIM_Deinitialize>:
{
   1e54a:	b510      	push	{r4, lr}
    DRV_MIIM_OBJ* pMiimObj = _DRV_MIIM_GetObjectAndLock(hSysObj);
   1e54c:	f001 f80b 	bl	1f566 <_DRV_MIIM_GetObjectAndLock>
    if(pMiimObj != 0)
   1e550:	b188      	cbz	r0, 1e576 <DRV_MIIM_Deinitialize+0x2c>
   1e552:	4604      	mov	r4, r0
        pClient = pMiimObj->objClients;
   1e554:	3010      	adds	r0, #16
            if(pClient->clientInUse != 0)
   1e556:	8a23      	ldrh	r3, [r4, #16]
   1e558:	b973      	cbnz	r3, 1e578 <DRV_MIIM_Deinitialize+0x2e>
        for(ix = 0; ix < sizeof(pMiimObj->objClients) / sizeof(*pMiimObj->objClients); ix++, pClient++)
   1e55a:	f104 0020 	add.w	r0, r4, #32
            if(pClient->clientInUse != 0)
   1e55e:	8c23      	ldrh	r3, [r4, #32]
   1e560:	b96b      	cbnz	r3, 1e57e <DRV_MIIM_Deinitialize+0x34>
        OSAL_SEM_Delete(&pMiimObj->objSem);
   1e562:	4620      	mov	r0, r4
   1e564:	f003 fa92 	bl	21a8c <OSAL_SEM_Delete>
        memset(pMiimObj, 0, sizeof(*pMiimObj));
   1e568:	2294      	movs	r2, #148	; 0x94
   1e56a:	2100      	movs	r1, #0
   1e56c:	4620      	mov	r0, r4
   1e56e:	f003 fb8d 	bl	21c8c <memset>
        pMiimObj->objStatus  = SYS_STATUS_UNINITIALIZED;
   1e572:	2300      	movs	r3, #0
   1e574:	7223      	strb	r3, [r4, #8]
} 
   1e576:	bd10      	pop	{r4, pc}
                _DRV_MIIM_ClientDeallocate(pClient);
   1e578:	f7f7 fef2 	bl	16360 <_DRV_MIIM_ClientDeallocate>
   1e57c:	e7ed      	b.n	1e55a <DRV_MIIM_Deinitialize+0x10>
   1e57e:	f7f7 feef 	bl	16360 <_DRV_MIIM_ClientDeallocate>
   1e582:	e7ee      	b.n	1e562 <DRV_MIIM_Deinitialize+0x18>

Disassembly of section .text._TCPIP_HEAP_MaxSize%650:

0001e584 <_TCPIP_HEAP_MaxSize>:
    }
    return 0;
}

static size_t _TCPIP_HEAP_MaxSize(TCPIP_STACK_HEAP_HANDLE heapH)
{
   1e584:	b538      	push	{r3, r4, r5, lr}
    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   1e586:	b1c0      	cbz	r0, 1e5ba <_TCPIP_HEAP_MaxSize+0x36>
   1e588:	4604      	mov	r4, r0
    max_nunits = 0;

    hDcpt = _TCPIP_HEAP_ObjDcpt(heapH);
    if(hDcpt)
    {
        OSAL_SEM_Pend(&hDcpt->_heapSemaphore, OSAL_WAIT_FOREVER);
   1e58a:	f100 0544 	add.w	r5, r0, #68	; 0x44
   1e58e:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1e592:	4628      	mov	r0, r5
   1e594:	f002 fc06 	bl	20da4 <OSAL_SEM_Pend>

        for(ptr = hDcpt->_heapHead; ptr != 0; ptr = ptr->next)
   1e598:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1e59a:	b163      	cbz	r3, 1e5b6 <_TCPIP_HEAP_MaxSize+0x32>
    max_nunits = 0;
   1e59c:	2400      	movs	r4, #0
        {
            if(ptr->units >= max_nunits)
   1e59e:	685a      	ldr	r2, [r3, #4]
   1e5a0:	4294      	cmp	r4, r2
   1e5a2:	bf38      	it	cc
   1e5a4:	4614      	movcc	r4, r2
        for(ptr = hDcpt->_heapHead; ptr != 0; ptr = ptr->next)
   1e5a6:	681b      	ldr	r3, [r3, #0]
   1e5a8:	2b00      	cmp	r3, #0
   1e5aa:	d1f8      	bne.n	1e59e <_TCPIP_HEAP_MaxSize+0x1a>
            {   // found block
                max_nunits = ptr->units;
            }
        }
        OSAL_SEM_Post(&hDcpt->_heapSemaphore);
   1e5ac:	4628      	mov	r0, r5
   1e5ae:	f003 f811 	bl	215d4 <OSAL_SEM_Post>
    }

    return max_nunits * sizeof(_headNode);   

}
   1e5b2:	0120      	lsls	r0, r4, #4
   1e5b4:	bd38      	pop	{r3, r4, r5, pc}
    max_nunits = 0;
   1e5b6:	2400      	movs	r4, #0
   1e5b8:	e7f8      	b.n	1e5ac <_TCPIP_HEAP_MaxSize+0x28>
   1e5ba:	2400      	movs	r4, #0
   1e5bc:	e7f9      	b.n	1e5b2 <_TCPIP_HEAP_MaxSize+0x2e>

Disassembly of section .text._DHCPOptionProcessMsgType%651:

0001e5be <_DHCPOptionProcessMsgType>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_MSG_TYPE))
   1e5be:	684b      	ldr	r3, [r1, #4]
   1e5c0:	2b02      	cmp	r3, #2
   1e5c2:	d911      	bls.n	1e5e8 <_DHCPOptionProcessMsgType+0x2a>
        TCPIP_DHCP_OPTION_DATA_MSG_TYPE* pMsgType = (TCPIP_DHCP_OPTION_DATA_MSG_TYPE*)pOptData->pOpt;
   1e5c4:	680b      	ldr	r3, [r1, #0]
        if(pMsgType->len == sizeof(pMsgType->type))
   1e5c6:	785a      	ldrb	r2, [r3, #1]
   1e5c8:	2a01      	cmp	r2, #1
   1e5ca:	d110      	bne.n	1e5ee <_DHCPOptionProcessMsgType+0x30>
            pOptData->msgType = pMsgType->type;
   1e5cc:	789b      	ldrb	r3, [r3, #2]
   1e5ce:	608b      	str	r3, [r1, #8]
            if(pOptData->msgType != TCPIP_DHCP_OFFER_MESSAGE || pClient->flags.bOfferReceived == 0)
   1e5d0:	2b02      	cmp	r3, #2
   1e5d2:	d10f      	bne.n	1e5f4 <_DHCPOptionProcessMsgType+0x36>
   1e5d4:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   1e5d8:	f003 0304 	and.w	r3, r3, #4
                return sizeof(TCPIP_DHCP_OPTION_DATA_MSG_TYPE);
   1e5dc:	2b00      	cmp	r3, #0
   1e5de:	bf14      	ite	ne
   1e5e0:	f04f 30ff 	movne.w	r0, #4294967295
   1e5e4:	2003      	moveq	r0, #3
   1e5e6:	4770      	bx	lr
    return -1;
   1e5e8:	f04f 30ff 	mov.w	r0, #4294967295
   1e5ec:	4770      	bx	lr
   1e5ee:	f04f 30ff 	mov.w	r0, #4294967295
   1e5f2:	4770      	bx	lr
                return sizeof(TCPIP_DHCP_OPTION_DATA_MSG_TYPE);
   1e5f4:	2003      	movs	r0, #3
}
   1e5f6:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAliasNameGet%652:

0001e5f8 <TCPIP_STACK_NetAliasNameGet>:
{
   1e5f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1e5fa:	460c      	mov	r4, r1
   1e5fc:	4616      	mov	r6, r2
    if(pNetIf)
   1e5fe:	4607      	mov	r7, r0
   1e600:	b150      	cbz	r0, 1e618 <TCPIP_STACK_NetAliasNameGet+0x20>
        aliasSize = strlen(pNetIf->ifName);
   1e602:	3062      	adds	r0, #98	; 0x62
   1e604:	f003 fb52 	bl	21cac <strlen>
   1e608:	4605      	mov	r5, r0
    if(nameBuffer && buffSize)
   1e60a:	b11c      	cbz	r4, 1e614 <TCPIP_STACK_NetAliasNameGet+0x1c>
   1e60c:	b116      	cbz	r6, 1e614 <TCPIP_STACK_NetAliasNameGet+0x1c>
        if(aliasSize)
   1e60e:	b92d      	cbnz	r5, 1e61c <TCPIP_STACK_NetAliasNameGet+0x24>
            nameBuffer[0] = 0;
   1e610:	2300      	movs	r3, #0
   1e612:	7023      	strb	r3, [r4, #0]
}
   1e614:	4628      	mov	r0, r5
   1e616:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        aliasSize = 0;
   1e618:	2500      	movs	r5, #0
   1e61a:	e7f6      	b.n	1e60a <TCPIP_STACK_NetAliasNameGet+0x12>
            strncpy(nameBuffer, pNetIf->ifName, buffSize - 1);
   1e61c:	1e72      	subs	r2, r6, #1
   1e61e:	f107 0162 	add.w	r1, r7, #98	; 0x62
   1e622:	4620      	mov	r0, r4
   1e624:	f001 feaf 	bl	20386 <strncpy>
            nameBuffer[buffSize - 1] = 0;
   1e628:	4434      	add	r4, r6
   1e62a:	2300      	movs	r3, #0
   1e62c:	f804 3c01 	strb.w	r3, [r4, #-1]
   1e630:	e7f0      	b.n	1e614 <TCPIP_STACK_NetAliasNameGet+0x1c>

Disassembly of section .text.DRV_ETHPHY_HWConfigFlagsGet%653:

0001e634 <DRV_ETHPHY_HWConfigFlagsGet>:
    if(hClientObj != 0)
   1e634:	b168      	cbz	r0, 1e652 <DRV_ETHPHY_HWConfigFlagsGet+0x1e>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1e636:	68c2      	ldr	r2, [r0, #12]
   1e638:	4b0a      	ldr	r3, [pc, #40]	; (1e664 <DRV_ETHPHY_HWConfigFlagsGet+0x30>)
   1e63a:	429a      	cmp	r2, r3
   1e63c:	d10c      	bne.n	1e658 <DRV_ETHPHY_HWConfigFlagsGet+0x24>
            hwFlags = ((GMAC_REGS->GMAC_UR & GMAC_UR_Msk)== DRV_GMAC_RMII_MODE) ?  DRV_ETHPHY_CFG_RMII : DRV_ETHPHY_CFG_MII;
   1e63e:	4b0a      	ldr	r3, [pc, #40]	; (1e668 <DRV_ETHPHY_HWConfigFlagsGet+0x34>)
   1e640:	68db      	ldr	r3, [r3, #12]
            if(pFlags)
   1e642:	b161      	cbz	r1, 1e65e <DRV_ETHPHY_HWConfigFlagsGet+0x2a>
            hwFlags = ((GMAC_REGS->GMAC_UR & GMAC_UR_Msk)== DRV_GMAC_RMII_MODE) ?  DRV_ETHPHY_CFG_RMII : DRV_ETHPHY_CFG_MII;
   1e644:	f083 0301 	eor.w	r3, r3, #1
   1e648:	f003 0301 	and.w	r3, r3, #1
                *pFlags = hwFlags;
   1e64c:	700b      	strb	r3, [r1, #0]
            return ethRes;
   1e64e:	2000      	movs	r0, #0
   1e650:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1e652:	f06f 000a 	mvn.w	r0, #10
   1e656:	4770      	bx	lr
   1e658:	f06f 000a 	mvn.w	r0, #10
   1e65c:	4770      	bx	lr
            return ethRes;
   1e65e:	2000      	movs	r0, #0
}
   1e660:	4770      	bx	lr
   1e662:	bf00      	nop
   1e664:	2000de18 	.word	0x2000de18
   1e668:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase6%654:

0001e66c <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase6>:
{
   1e66c:	b510      	push	{r4, lr}
   1e66e:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1e670:	f002 f898 	bl	207a4 <_DRV_PHY_SMITransfer_Wait>
   1e674:	b1a8      	cbz	r0, 1e6a2 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase6+0x36>
    if(phyCpbl.AN_ABLE)
   1e676:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
   1e67a:	f013 0f08 	tst.w	r3, #8
   1e67e:	d00b      	beq.n	1e698 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase6+0x2c>
        if(_DRV_PHY_SMIWriteStart( hClientObj, PHY_REG_BMCON, _BMCON_AN_ENABLE_MASK | _BMCON_AN_RESTART_MASK ))
   1e680:	f44f 5290 	mov.w	r2, #4608	; 0x1200
   1e684:	2100      	movs	r1, #0
   1e686:	4620      	mov	r0, r4
   1e688:	f000 fc51 	bl	1ef2e <_DRV_PHY_SMIWriteStart>
   1e68c:	b148      	cbz	r0, 1e6a2 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase6+0x36>
    hClientObj->operPhase = operPhase;
   1e68e:	2303      	movs	r3, #3
   1e690:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1e692:	2307      	movs	r3, #7
   1e694:	8423      	strh	r3, [r4, #32]
   1e696:	e004      	b.n	1e6a2 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase6+0x36>
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_NEGOTIATION_UNABLE);
   1e698:	f06f 0105 	mvn.w	r1, #5
   1e69c:	4620      	mov	r0, r4
   1e69e:	f001 fb45 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
}
   1e6a2:	bd10      	pop	{r4, pc}

Disassembly of section .text.DRV_GMAC_Open%655:

0001e6a4 <DRV_GMAC_Open>:
    if(macIx >= 0 && macIx < sizeof(_gmac_drv_dcpt)/sizeof(*_gmac_drv_dcpt))
   1e6a4:	f241 0350 	movw	r3, #4176	; 0x1050
   1e6a8:	4298      	cmp	r0, r3
   1e6aa:	d10c      	bne.n	1e6c6 <DRV_GMAC_Open+0x22>
		if(pMACDrv->sGmacData._macFlags._init == 1)
   1e6ac:	4b0a      	ldr	r3, [pc, #40]	; (1e6d8 <DRV_GMAC_Open+0x34>)
   1e6ae:	7d9b      	ldrb	r3, [r3, #22]
   1e6b0:	f013 0f01 	tst.w	r3, #1
   1e6b4:	d00a      	beq.n	1e6cc <DRV_GMAC_Open+0x28>
			if(pMACDrv->sGmacData._macFlags._open == 0)
   1e6b6:	f013 0f02 	tst.w	r3, #2
   1e6ba:	d10a      	bne.n	1e6d2 <DRV_GMAC_Open+0x2e>
				pMACDrv->sGmacData._macFlags._open = 1;
   1e6bc:	4806      	ldr	r0, [pc, #24]	; (1e6d8 <DRV_GMAC_Open+0x34>)
   1e6be:	f043 0302 	orr.w	r3, r3, #2
   1e6c2:	7583      	strb	r3, [r0, #22]
				hMac = (DRV_HANDLE)pMACDrv;
   1e6c4:	4770      	bx	lr
    DRV_HANDLE    hMac = DRV_HANDLE_INVALID;
   1e6c6:	f04f 30ff 	mov.w	r0, #4294967295
   1e6ca:	4770      	bx	lr
   1e6cc:	f04f 30ff 	mov.w	r0, #4294967295
   1e6d0:	4770      	bx	lr
   1e6d2:	f04f 30ff 	mov.w	r0, #4294967295
}
   1e6d6:	4770      	bx	lr
   1e6d8:	2000d8b8 	.word	0x2000d8b8

Disassembly of section .text.DRV_PIC32CGMAC_LibGetMacAddr%656:

0001e6dc <DRV_PIC32CGMAC_LibGetMacAddr>:
    pMacAddr[0] = (GMAC_REGS->SA[0].GMAC_SAB)& 0xFF;
   1e6dc:	4b0c      	ldr	r3, [pc, #48]	; (1e710 <DRV_PIC32CGMAC_LibGetMacAddr+0x34>)
   1e6de:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   1e6e2:	7002      	strb	r2, [r0, #0]
    pMacAddr[1] = ((GMAC_REGS->SA[0].GMAC_SAB)>>8)& 0xFF;
   1e6e4:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   1e6e8:	0a12      	lsrs	r2, r2, #8
   1e6ea:	7042      	strb	r2, [r0, #1]
    pMacAddr[2] = ((GMAC_REGS->SA[0].GMAC_SAB)>>16)& 0xFF;
   1e6ec:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   1e6f0:	0c12      	lsrs	r2, r2, #16
   1e6f2:	7082      	strb	r2, [r0, #2]
    pMacAddr[3] = ((GMAC_REGS->SA[0].GMAC_SAB)>>24)& 0xFF;
   1e6f4:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   1e6f8:	0e12      	lsrs	r2, r2, #24
   1e6fa:	70c2      	strb	r2, [r0, #3]
    pMacAddr[4] = (GMAC_REGS->SA[0].GMAC_SAT)& 0xFF;
   1e6fc:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
   1e700:	7102      	strb	r2, [r0, #4]
    pMacAddr[5] = ((GMAC_REGS->SA[0].GMAC_SAT)>>8)& 0xFF;
   1e702:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
   1e706:	0a1b      	lsrs	r3, r3, #8
   1e708:	7143      	strb	r3, [r0, #5]
}
   1e70a:	2000      	movs	r0, #0
   1e70c:	4770      	bx	lr
   1e70e:	bf00      	nop
   1e710:	42000800 	.word	0x42000800

Disassembly of section .text._TCP_EphemeralPortAllocate%657:

0001e714 <_TCP_EphemeralPortAllocate>:
{
   1e714:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    next_ephemeral = TCPIP_TCP_LOCAL_PORT_START_NUMBER + (SYS_RANDOM_CryptoGet() % num_ephemeral);
   1e716:	f001 ff45 	bl	205a4 <SYS_RANDOM_CryptoGet>
   1e71a:	ea6f 4080 	mvn.w	r0, r0, lsl #18
   1e71e:	ea6f 4090 	mvn.w	r0, r0, lsr #18
   1e722:	b284      	uxth	r4, r0
   1e724:	f44f 4580 	mov.w	r5, #16384	; 0x4000
        if (next_ephemeral == TCPIP_TCP_LOCAL_PORT_END_NUMBER)
   1e728:	f64f 76ff 	movw	r6, #65535	; 0xffff
            next_ephemeral = TCPIP_TCP_LOCAL_PORT_START_NUMBER;
   1e72c:	f44f 4740 	mov.w	r7, #49152	; 0xc000
        if(_TCP_PortIsAvailable(next_ephemeral))
   1e730:	4620      	mov	r0, r4
   1e732:	f7ff f99f 	bl	1da74 <_TCP_PortIsAvailable>
   1e736:	b938      	cbnz	r0, 1e748 <_TCP_EphemeralPortAllocate+0x34>
        if (next_ephemeral == TCPIP_TCP_LOCAL_PORT_END_NUMBER)
   1e738:	42b4      	cmp	r4, r6
            next_ephemeral++;
   1e73a:	bf1a      	itte	ne
   1e73c:	3401      	addne	r4, #1
   1e73e:	b2a4      	uxthne	r4, r4
            next_ephemeral = TCPIP_TCP_LOCAL_PORT_START_NUMBER;
   1e740:	463c      	moveq	r4, r7
    while(count--)
   1e742:	3d01      	subs	r5, #1
   1e744:	d1f4      	bne.n	1e730 <_TCP_EphemeralPortAllocate+0x1c>
    return 0;   // not found
   1e746:	2400      	movs	r4, #0
}
   1e748:	4620      	mov	r0, r4
   1e74a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.TCPIP_Commands_Deinitialize%658:

0001e74c <TCPIP_Commands_Deinitialize>:
{
   1e74c:	b508      	push	{r3, lr}
    if(commandInitCount > 0 && stackCtrl->stackAction == TCPIP_STACK_ACTION_DEINIT)
   1e74e:	4b0b      	ldr	r3, [pc, #44]	; (1e77c <TCPIP_Commands_Deinitialize+0x30>)
   1e750:	681b      	ldr	r3, [r3, #0]
   1e752:	2b00      	cmp	r3, #0
   1e754:	dd02      	ble.n	1e75c <TCPIP_Commands_Deinitialize+0x10>
   1e756:	7f02      	ldrb	r2, [r0, #28]
   1e758:	2a02      	cmp	r2, #2
   1e75a:	d000      	beq.n	1e75e <TCPIP_Commands_Deinitialize+0x12>
}
   1e75c:	bd08      	pop	{r3, pc}
        if(--commandInitCount == 0)
   1e75e:	3b01      	subs	r3, #1
   1e760:	4a06      	ldr	r2, [pc, #24]	; (1e77c <TCPIP_Commands_Deinitialize+0x30>)
   1e762:	6013      	str	r3, [r2, #0]
   1e764:	2b00      	cmp	r3, #0
   1e766:	d1f9      	bne.n	1e75c <TCPIP_Commands_Deinitialize+0x10>
            if(tcpipCmdSignalHandle != 0)
   1e768:	4b05      	ldr	r3, [pc, #20]	; (1e780 <TCPIP_Commands_Deinitialize+0x34>)
   1e76a:	6818      	ldr	r0, [r3, #0]
   1e76c:	2800      	cmp	r0, #0
   1e76e:	d0f5      	beq.n	1e75c <TCPIP_Commands_Deinitialize+0x10>
                _TCPIPStackSignalHandlerDeregister(tcpipCmdSignalHandle);
   1e770:	f003 fadf 	bl	21d32 <_TCPIPStackSignalHandlerDeregister>
                tcpipCmdSignalHandle = 0;
   1e774:	4b02      	ldr	r3, [pc, #8]	; (1e780 <TCPIP_Commands_Deinitialize+0x34>)
   1e776:	2200      	movs	r2, #0
   1e778:	601a      	str	r2, [r3, #0]
}
   1e77a:	e7ef      	b.n	1e75c <TCPIP_Commands_Deinitialize+0x10>
   1e77c:	2000e3a8 	.word	0x2000e3a8
   1e780:	2000e3e4 	.word	0x2000e3e4

Disassembly of section .text.TCPIP_DNS_ClientInfoGet%659:

0001e784 <TCPIP_DNS_ClientInfoGet>:
    TCPIP_DNS_DCPT* pDnsDcpt = pgDnsDcpt;
   1e784:	4b0c      	ldr	r3, [pc, #48]	; (1e7b8 <TCPIP_DNS_ClientInfoGet+0x34>)
   1e786:	681b      	ldr	r3, [r3, #0]
    if(pDnsDcpt==NULL)
   1e788:	b183      	cbz	r3, 1e7ac <TCPIP_DNS_ClientInfoGet+0x28>
    if(pClientInfo)
   1e78a:	b190      	cbz	r0, 1e7b2 <TCPIP_DNS_ClientInfoGet+0x2e>
        pClientInfo->strictNet = pDnsDcpt->strictNet;
   1e78c:	685a      	ldr	r2, [r3, #4]
   1e78e:	6002      	str	r2, [r0, #0]
        pClientInfo->prefNet = pDnsDcpt->prefNet;
   1e790:	689a      	ldr	r2, [r3, #8]
   1e792:	6042      	str	r2, [r0, #4]
        pClientInfo->dnsTime = pDnsDcpt->dnsTime;
   1e794:	69da      	ldr	r2, [r3, #28]
   1e796:	6082      	str	r2, [r0, #8]
        pClientInfo->pendingEntries = pDnsDcpt->unsolvedEntries;
   1e798:	8cda      	ldrh	r2, [r3, #38]	; 0x26
   1e79a:	8182      	strh	r2, [r0, #12]
        pClientInfo->currentEntries = pDnsDcpt->hashDcpt->fullSlots;
   1e79c:	681a      	ldr	r2, [r3, #0]
   1e79e:	6a52      	ldr	r2, [r2, #36]	; 0x24
   1e7a0:	81c2      	strh	r2, [r0, #14]
        pClientInfo->totalEntries = pDnsDcpt->hashDcpt->hEntries;
   1e7a2:	681b      	ldr	r3, [r3, #0]
   1e7a4:	68db      	ldr	r3, [r3, #12]
   1e7a6:	8203      	strh	r3, [r0, #16]
    return TCPIP_DNS_RES_OK;
   1e7a8:	2000      	movs	r0, #0
   1e7aa:	4770      	bx	lr
         return TCPIP_DNS_RES_NO_SERVICE;
   1e7ac:	f06f 0005 	mvn.w	r0, #5
   1e7b0:	4770      	bx	lr
    return TCPIP_DNS_RES_OK;
   1e7b2:	2000      	movs	r0, #0
}
   1e7b4:	4770      	bx	lr
   1e7b6:	bf00      	nop
   1e7b8:	2000e424 	.word	0x2000e424

Disassembly of section .text.TCPIP_PKT_PacketMACFormat%660:

0001e7bc <TCPIP_PKT_PacketMACFormat>:
    if(srcAddr)
   1e7bc:	b1c2      	cbz	r2, 1e7f0 <TCPIP_PKT_PacketMACFormat+0x34>
{
   1e7be:	b470      	push	{r4, r5, r6}
   1e7c0:	4614      	mov	r4, r2
        macHdr = (TCPIP_MAC_ETHERNET_HEADER*)pPkt->pMacLayer;
   1e7c2:	6942      	ldr	r2, [r0, #20]
        srcHdrAdd = &macHdr->SourceMACAddr;
   1e7c4:	1d95      	adds	r5, r2, #6
        if(dstAddr)
   1e7c6:	b119      	cbz	r1, 1e7d0 <TCPIP_PKT_PacketMACFormat+0x14>
            memcpy(destHdrAdd, dstAddr, sizeof(*destHdrAdd));
   1e7c8:	680e      	ldr	r6, [r1, #0]
   1e7ca:	6016      	str	r6, [r2, #0]
   1e7cc:	8889      	ldrh	r1, [r1, #4]
   1e7ce:	8091      	strh	r1, [r2, #4]
        memcpy(srcHdrAdd, srcAddr, sizeof(*srcHdrAdd));
   1e7d0:	6821      	ldr	r1, [r4, #0]
   1e7d2:	f8c2 1006 	str.w	r1, [r2, #6]
   1e7d6:	88a1      	ldrh	r1, [r4, #4]
   1e7d8:	80a9      	strh	r1, [r5, #4]
   1e7da:	0a19      	lsrs	r1, r3, #8
   1e7dc:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
        macHdr->Type = TCPIP_Helper_htons(pktType);
   1e7e0:	8191      	strh	r1, [r2, #12]
        pPkt->pDSeg->segLen += sizeof(TCPIP_MAC_ETHERNET_HEADER);
   1e7e2:	6902      	ldr	r2, [r0, #16]
   1e7e4:	8993      	ldrh	r3, [r2, #12]
   1e7e6:	330e      	adds	r3, #14
   1e7e8:	8193      	strh	r3, [r2, #12]
        return true;
   1e7ea:	2001      	movs	r0, #1
}
   1e7ec:	bc70      	pop	{r4, r5, r6}
   1e7ee:	4770      	bx	lr
    return false;
   1e7f0:	2000      	movs	r0, #0
}
   1e7f2:	4770      	bx	lr

Disassembly of section .text._UDPAllocateEphemeralPort%661:

0001e7f4 <_UDPAllocateEphemeralPort>:
{
   1e7f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1e7f6:	f7fc fbc9 	bl	1af8c <rand>
    next_ephemeral = TCPIP_UDP_LOCAL_PORT_START_NUMBER + (SYS_RANDOM_PseudoGet() % num_ephemeral);
   1e7fa:	ea6f 4080 	mvn.w	r0, r0, lsl #18
   1e7fe:	ea6f 4090 	mvn.w	r0, r0, lsr #18
   1e802:	b284      	uxth	r4, r0
   1e804:	f44f 4580 	mov.w	r5, #16384	; 0x4000
        if (next_ephemeral == TCPIP_UDP_LOCAL_PORT_END_NUMBER)
   1e808:	f64f 76ff 	movw	r6, #65535	; 0xffff
            next_ephemeral = TCPIP_UDP_LOCAL_PORT_START_NUMBER;
   1e80c:	f44f 4740 	mov.w	r7, #49152	; 0xc000
        if(_UDPIsAvailablePort(next_ephemeral))
   1e810:	4620      	mov	r0, r4
   1e812:	f7ff fa0f 	bl	1dc34 <_UDPIsAvailablePort>
   1e816:	b938      	cbnz	r0, 1e828 <_UDPAllocateEphemeralPort+0x34>
        if (next_ephemeral == TCPIP_UDP_LOCAL_PORT_END_NUMBER)
   1e818:	42b4      	cmp	r4, r6
            next_ephemeral++;
   1e81a:	bf1a      	itte	ne
   1e81c:	3401      	addne	r4, #1
   1e81e:	b2a4      	uxthne	r4, r4
            next_ephemeral = TCPIP_UDP_LOCAL_PORT_START_NUMBER;
   1e820:	463c      	moveq	r4, r7
    while(count--)
   1e822:	3d01      	subs	r5, #1
   1e824:	d1f4      	bne.n	1e810 <_UDPAllocateEphemeralPort+0x1c>
    return 0;   // not found
   1e826:	2400      	movs	r4, #0
}
   1e828:	4620      	mov	r0, r4
   1e82a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.SYS_CMD_Initialize%662:

0001e82c <SYS_CMD_Initialize>:
    if (initConfig == 0)
   1e82c:	b190      	cbz	r0, 1e854 <SYS_CMD_Initialize+0x28>
{
   1e82e:	b538      	push	{r3, r4, r5, lr}
   1e830:	4604      	mov	r4, r0
    _cmdInitData = *initConfig; // save a copy of the initialization data
   1e832:	4d09      	ldr	r5, [pc, #36]	; (1e858 <SYS_CMD_Initialize+0x2c>)
   1e834:	6800      	ldr	r0, [r0, #0]
   1e836:	6028      	str	r0, [r5, #0]
    cmdIODevList.head = cmdIODevList.tail = 0;
   1e838:	4b08      	ldr	r3, [pc, #32]	; (1e85c <SYS_CMD_Initialize+0x30>)
   1e83a:	2200      	movs	r2, #0
   1e83c:	605a      	str	r2, [r3, #4]
   1e83e:	601a      	str	r2, [r3, #0]
    SYS_CMDIO_ADD(&sysConsoleApi, &initConfig->consoleCmdIOParam, initConfig->consoleCmdIOParam);
   1e840:	4621      	mov	r1, r4
   1e842:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   1e846:	4806      	ldr	r0, [pc, #24]	; (1e860 <SYS_CMD_Initialize+0x34>)
   1e848:	f7fa fb18 	bl	18e7c <SYS_CMDIO_ADD>
    _cmdInitData.consoleIndex = initConfig->consoleIndex;
   1e84c:	8863      	ldrh	r3, [r4, #2]
   1e84e:	806b      	strh	r3, [r5, #2]
    return true;
   1e850:	2001      	movs	r0, #1
}
   1e852:	bd38      	pop	{r3, r4, r5, pc}
        return false;
   1e854:	2000      	movs	r0, #0
}
   1e856:	4770      	bx	lr
   1e858:	2000e46c 	.word	0x2000e46c
   1e85c:	2000e360 	.word	0x2000e360
   1e860:	000219a4 	.word	0x000219a4

Disassembly of section .text.SYS_TIME_ResourceLock%663:

0001e864 <SYS_TIME_ResourceLock>:
{
   1e864:	b508      	push	{r3, lr}
    if (gSystemCounterObj.interruptNestingCount == 0)
   1e866:	4b0b      	ldr	r3, [pc, #44]	; (1e894 <SYS_TIME_ResourceLock+0x30>)
   1e868:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   1e86c:	b10b      	cbz	r3, 1e872 <SYS_TIME_ResourceLock+0xe>
    return true;
   1e86e:	2001      	movs	r0, #1
}
   1e870:	bd08      	pop	{r3, pc}
        if(OSAL_MUTEX_Lock(&gSystemCounterObj.timerMutex, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
   1e872:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1e876:	4808      	ldr	r0, [pc, #32]	; (1e898 <SYS_TIME_ResourceLock+0x34>)
   1e878:	f002 faa3 	bl	20dc2 <OSAL_MUTEX_Lock>
   1e87c:	2801      	cmp	r0, #1
   1e87e:	d001      	beq.n	1e884 <SYS_TIME_ResourceLock+0x20>
            return false;
   1e880:	2000      	movs	r0, #0
   1e882:	e7f5      	b.n	1e870 <SYS_TIME_ResourceLock+0xc>
            SYS_INT_SourceDisable(gSystemCounterObj.hwTimerIntNum);
   1e884:	4b03      	ldr	r3, [pc, #12]	; (1e894 <SYS_TIME_ResourceLock+0x30>)
   1e886:	f9b3 0008 	ldrsh.w	r0, [r3, #8]
   1e88a:	f7fe ff27 	bl	1d6dc <SYS_INT_SourceDisable>
            return true;
   1e88e:	2001      	movs	r0, #1
   1e890:	e7ee      	b.n	1e870 <SYS_TIME_ResourceLock+0xc>
   1e892:	bf00      	nop
   1e894:	2000e030 	.word	0x2000e030
   1e898:	2000e064 	.word	0x2000e064

Disassembly of section .rodata.TCPIP_HOSTS_CONFIGURATION%664:

0001e89c <TCPIP_HOSTS_CONFIGURATION>:
   1e89c:	0001aebc 0001aec4 0001aed0 0001aee4     ................
   1e8ac:	0001aef4 0001af04 0001af04 0001af14     ................
   1e8bc:	0001af1c 00000009 0001bd6c 00000000     ........l.......
	...

Disassembly of section .text.SERCOM0_SPI_Initialize%665:

0001e8d4 <SERCOM0_SPI_Initialize>:
    sercom0SPIObj.callback = NULL ;
   1e8d4:	4b0b      	ldr	r3, [pc, #44]	; (1e904 <SERCOM0_SPI_Initialize+0x30>)
   1e8d6:	2200      	movs	r2, #0
   1e8d8:	621a      	str	r2, [r3, #32]
    sercom0SPIObj.transferIsBusy = false ;
   1e8da:	771a      	strb	r2, [r3, #28]
    sercom0SPIObj.txSize = 0U;
   1e8dc:	609a      	str	r2, [r3, #8]
    sercom0SPIObj.rxSize = 0U;
   1e8de:	60da      	str	r2, [r3, #12]
    SERCOM0_REGS->SPIM.SERCOM_CTRLB = SERCOM_SPIM_CTRLB_CHSIZE_8_BIT | SERCOM_SPIM_CTRLB_RXEN_Msk ;
   1e8e0:	4b09      	ldr	r3, [pc, #36]	; (1e908 <SERCOM0_SPI_Initialize+0x34>)
   1e8e2:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   1e8e6:	605a      	str	r2, [r3, #4]
    while((SERCOM0_REGS->SPIM.SERCOM_SYNCBUSY) != 0U)
   1e8e8:	461a      	mov	r2, r3
   1e8ea:	69d3      	ldr	r3, [r2, #28]
   1e8ec:	2b00      	cmp	r3, #0
   1e8ee:	d1fc      	bne.n	1e8ea <SERCOM0_SPI_Initialize+0x16>
    SERCOM0_REGS->SPIM.SERCOM_BAUD = (uint8_t)SERCOM_SPIM_BAUD_BAUD(SERCOM0_SPIM_BAUD_VALUE);
   1e8f0:	4b05      	ldr	r3, [pc, #20]	; (1e908 <SERCOM0_SPI_Initialize+0x34>)
   1e8f2:	221d      	movs	r2, #29
   1e8f4:	731a      	strb	r2, [r3, #12]
    SERCOM0_REGS->SPIM.SERCOM_CTRLA = SERCOM_SPIM_CTRLA_MODE_SPI_MASTER | SERCOM_SPIM_CTRLA_DOPO_PAD0 | SERCOM_SPIM_CTRLA_DIPO_PAD0 | SERCOM_SPIM_CTRLA_CPOL_IDLE_LOW | SERCOM_SPIM_CTRLA_CPHA_LEADING_EDGE | SERCOM_SPIM_CTRLA_DORD_MSB | SERCOM_SPIM_CTRLA_ENABLE_Msk ;
   1e8f6:	220e      	movs	r2, #14
   1e8f8:	601a      	str	r2, [r3, #0]
    while((SERCOM0_REGS->SPIM.SERCOM_SYNCBUSY) != 0U)
   1e8fa:	461a      	mov	r2, r3
   1e8fc:	69d3      	ldr	r3, [r2, #28]
   1e8fe:	2b00      	cmp	r3, #0
   1e900:	d1fc      	bne.n	1e8fc <SERCOM0_SPI_Initialize+0x28>
}
   1e902:	4770      	bx	lr
   1e904:	2000e09c 	.word	0x2000e09c
   1e908:	40003000 	.word	0x40003000

Disassembly of section .text.__swrite%666:

0001e90c <__swrite>:
   1e90c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1e910:	461f      	mov	r7, r3
   1e912:	898b      	ldrh	r3, [r1, #12]
   1e914:	05db      	lsls	r3, r3, #23
   1e916:	4605      	mov	r5, r0
   1e918:	460c      	mov	r4, r1
   1e91a:	4616      	mov	r6, r2
   1e91c:	d505      	bpl.n	1e92a <__swrite+0x1e>
   1e91e:	2302      	movs	r3, #2
   1e920:	2200      	movs	r2, #0
   1e922:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   1e926:	f001 ff19 	bl	2075c <_lseek_r>
   1e92a:	89a3      	ldrh	r3, [r4, #12]
   1e92c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   1e930:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
   1e934:	81a3      	strh	r3, [r4, #12]
   1e936:	4632      	mov	r2, r6
   1e938:	463b      	mov	r3, r7
   1e93a:	4628      	mov	r0, r5
   1e93c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1e940:	f001 bee8 	b.w	20714 <_write_r>

Disassembly of section .text._DRV_ETHPHY_NegCompletePhaseRead1%667:

0001e944 <_DRV_ETHPHY_NegCompletePhaseRead1>:
{
   1e944:	b510      	push	{r4, lr}
   1e946:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1e948:	f001 ff2c 	bl	207a4 <_DRV_PHY_SMITransfer_Wait>
   1e94c:	b148      	cbz	r0, 1e962 <_DRV_ETHPHY_NegCompletePhaseRead1+0x1e>
    if(phyBMCon.AN_ENABLE == 0)
   1e94e:	f894 303b 	ldrb.w	r3, [r4, #59]	; 0x3b
   1e952:	f013 0f10 	tst.w	r3, #16
   1e956:	d005      	beq.n	1e964 <_DRV_ETHPHY_NegCompletePhaseRead1+0x20>
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMCON))
   1e958:	2100      	movs	r1, #0
   1e95a:	4620      	mov	r0, r4
   1e95c:	f000 face 	bl	1eefc <_DRV_PHY_SMIReadStart>
   1e960:	b930      	cbnz	r0, 1e970 <_DRV_ETHPHY_NegCompletePhaseRead1+0x2c>
}
   1e962:	bd10      	pop	{r4, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_NEGOTIATION_INACTIVE);
   1e964:	f06f 0104 	mvn.w	r1, #4
   1e968:	4620      	mov	r0, r4
   1e96a:	f001 f9df 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
        return;
   1e96e:	e7f8      	b.n	1e962 <_DRV_ETHPHY_NegCompletePhaseRead1+0x1e>
    hClientObj->operPhase = operPhase;
   1e970:	2302      	movs	r3, #2
   1e972:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1e974:	2300      	movs	r3, #0
   1e976:	8423      	strh	r3, [r4, #32]
   1e978:	e7f3      	b.n	1e962 <_DRV_ETHPHY_NegCompletePhaseRead1+0x1e>

Disassembly of section .text._TCPSetSourceAddress%668:

0001e97a <_TCPSetSourceAddress>:
    if(localAddress == 0)
   1e97a:	b1ba      	cbz	r2, 1e9ac <_TCPSetSourceAddress+0x32>
{
   1e97c:	b410      	push	{r4}
   1e97e:	4614      	mov	r4, r2
    while(pSkt->addType == addType)
   1e980:	f890 306f 	ldrb.w	r3, [r0, #111]	; 0x6f
   1e984:	428b      	cmp	r3, r1
   1e986:	d003      	beq.n	1e990 <_TCPSetSourceAddress+0x16>
    return false;
   1e988:	2000      	movs	r0, #0
}
   1e98a:	f85d 4b04 	ldr.w	r4, [sp], #4
   1e98e:	4770      	bx	lr
        if (addType == IP_ADDRESS_TYPE_IPV4)
   1e990:	2901      	cmp	r1, #1
   1e992:	d001      	beq.n	1e998 <_TCPSetSourceAddress+0x1e>
    return false;
   1e994:	2000      	movs	r0, #0
   1e996:	e7f8      	b.n	1e98a <_TCPSetSourceAddress+0x10>
            pSkt->srcAddress.Val = localAddress->v4Add.Val;
   1e998:	6823      	ldr	r3, [r4, #0]
   1e99a:	63c3      	str	r3, [r0, #60]	; 0x3c
            pSkt->flags.srcSet = 1;
   1e99c:	f890 306d 	ldrb.w	r3, [r0, #109]	; 0x6d
   1e9a0:	f043 0310 	orr.w	r3, r3, #16
   1e9a4:	f880 306d 	strb.w	r3, [r0, #109]	; 0x6d
            return true;
   1e9a8:	2001      	movs	r0, #1
   1e9aa:	e7ee      	b.n	1e98a <_TCPSetSourceAddress+0x10>
        return false;
   1e9ac:	2000      	movs	r0, #0
}
   1e9ae:	4770      	bx	lr

Disassembly of section .text._DNS_NetIsValid%669:

0001e9b0 <_DNS_NetIsValid>:
{
   1e9b0:	b510      	push	{r4, lr}
   1e9b2:	4604      	mov	r4, r0
    if(TCPIP_STACK_NetIsReady(pIf) != 0)
   1e9b4:	f002 fc9e 	bl	212f4 <TCPIP_STACK_NetIsReady>
   1e9b8:	4603      	mov	r3, r0
   1e9ba:	b190      	cbz	r0, 1e9e2 <_DNS_NetIsValid+0x32>
        if(_TCPIPStackNetAddress(pIf) != 0)
   1e9bc:	6863      	ldr	r3, [r4, #4]
   1e9be:	b17b      	cbz	r3, 1e9e0 <_DNS_NetIsValid+0x30>
            if(pIf->Flags.bIsDnsClientEnabled != 0)
   1e9c0:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   1e9c4:	f013 0f08 	tst.w	r3, #8
   1e9c8:	d101      	bne.n	1e9ce <_DNS_NetIsValid+0x1e>
    return false;
   1e9ca:	2300      	movs	r3, #0
   1e9cc:	e009      	b.n	1e9e2 <_DNS_NetIsValid+0x32>
                return pIf->dnsServer[0].Val != 0 || pIf->dnsServer[1].Val != 0;
   1e9ce:	6923      	ldr	r3, [r4, #16]
   1e9d0:	b923      	cbnz	r3, 1e9dc <_DNS_NetIsValid+0x2c>
   1e9d2:	6963      	ldr	r3, [r4, #20]
   1e9d4:	3300      	adds	r3, #0
   1e9d6:	bf18      	it	ne
   1e9d8:	2301      	movne	r3, #1
   1e9da:	e002      	b.n	1e9e2 <_DNS_NetIsValid+0x32>
   1e9dc:	2301      	movs	r3, #1
   1e9de:	e000      	b.n	1e9e2 <_DNS_NetIsValid+0x32>
    return false;
   1e9e0:	2300      	movs	r3, #0
}
   1e9e2:	4618      	mov	r0, r3
   1e9e4:	bd10      	pop	{r4, pc}

Disassembly of section .text._TCPIPStackSetConfigAddress%670:

0001e9e6 <_TCPIPStackSetConfigAddress>:
    if(pNetIf)
   1e9e6:	b1c0      	cbz	r0, 1ea1a <_TCPIPStackSetConfigAddress+0x34>
{
   1e9e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1e9ea:	4604      	mov	r4, r0
   1e9ec:	461f      	mov	r7, r3
   1e9ee:	4615      	mov	r5, r2
   1e9f0:	460e      	mov	r6, r1
        OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1e9f2:	2000      	movs	r0, #0
   1e9f4:	f002 fde2 	bl	215bc <OSAL_CRIT_Enter>
   1e9f8:	4601      	mov	r1, r0
    if(ipAddress)
   1e9fa:	b10e      	cbz	r6, 1ea00 <_TCPIPStackSetConfigAddress+0x1a>
        pNetIf->netIPAddr.Val = ipAddress->Val;
   1e9fc:	6833      	ldr	r3, [r6, #0]
   1e9fe:	6063      	str	r3, [r4, #4]
    if(mask)
   1ea00:	b10d      	cbz	r5, 1ea06 <_TCPIPStackSetConfigAddress+0x20>
        pNetIf->netMask.Val = mask->Val;
   1ea02:	682b      	ldr	r3, [r5, #0]
   1ea04:	60a3      	str	r3, [r4, #8]
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1ea06:	2000      	movs	r0, #0
   1ea08:	f002 ff07 	bl	2181a <OSAL_CRIT_Leave>
    pNetIf->Flags.bInConfig = config;
   1ea0c:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
   1ea10:	f367 1204 	bfi	r2, r7, #4, #1
   1ea14:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
}
   1ea18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1ea1a:	4770      	bx	lr

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2%671:

0001ea1c <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2>:
{
   1ea1c:	b538      	push	{r3, r4, r5, lr}
   1ea1e:	4604      	mov	r4, r0
    hDriver = hClientObj->hDriver;
   1ea20:	68c3      	ldr	r3, [r0, #12]
    res = (*hDriver->pPhyObj->miiConfigure)(gDrvEthBaseObj, (DRV_HANDLE)hClientObj, hDriver->configFlags);
   1ea22:	695a      	ldr	r2, [r3, #20]
   1ea24:	6815      	ldr	r5, [r2, #0]
   1ea26:	7b9a      	ldrb	r2, [r3, #14]
   1ea28:	4601      	mov	r1, r0
   1ea2a:	4808      	ldr	r0, [pc, #32]	; (1ea4c <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2+0x30>)
   1ea2c:	47a8      	blx	r5
    if(res == DRV_ETHPHY_RES_OK)
   1ea2e:	b118      	cbz	r0, 1ea38 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2+0x1c>
   1ea30:	4601      	mov	r1, r0
    else if(res != DRV_ETHPHY_RES_PENDING)
   1ea32:	2801      	cmp	r0, #1
   1ea34:	d106      	bne.n	1ea44 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2+0x28>
}
   1ea36:	bd38      	pop	{r3, r4, r5, pc}
        hClientObj->vendorData = 0;
   1ea38:	2300      	movs	r3, #0
   1ea3a:	6423      	str	r3, [r4, #64]	; 0x40
    hClientObj->operPhase = operPhase;
   1ea3c:	2303      	movs	r3, #3
   1ea3e:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1ea40:	8423      	strh	r3, [r4, #32]
   1ea42:	e7f8      	b.n	1ea36 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2+0x1a>
        _DRV_PHY_SetOperDoneResult(hClientObj, res);
   1ea44:	4620      	mov	r0, r4
   1ea46:	f001 f971 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
}
   1ea4a:	e7f4      	b.n	1ea36 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2+0x1a>
   1ea4c:	0001b870 	.word	0x0001b870

Disassembly of section .text.DRV_PIC32CGMAC_LibClearPriorityQue%672:

0001ea50 <DRV_PIC32CGMAC_LibClearPriorityQue>:
{
   1ea50:	b570      	push	{r4, r5, r6, lr}
   1ea52:	4604      	mov	r4, r0
   1ea54:	460e      	mov	r6, r1
    intStat = SYS_INT_SourceDisable(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc);
   1ea56:	f9b0 00b6 	ldrsh.w	r0, [r0, #182]	; 0xb6
   1ea5a:	f7fe fe3f 	bl	1d6dc <SYS_INT_SourceDisable>
   1ea5e:	4601      	mov	r1, r0
    drvGmacQueEvents &= ~(1<<queueIdx);
   1ea60:	4d07      	ldr	r5, [pc, #28]	; (1ea80 <DRV_PIC32CGMAC_LibClearPriorityQue+0x30>)
   1ea62:	2301      	movs	r3, #1
   1ea64:	fa03 f206 	lsl.w	r2, r3, r6
   1ea68:	682b      	ldr	r3, [r5, #0]
   1ea6a:	ea23 0302 	bic.w	r3, r3, r2
   1ea6e:	602b      	str	r3, [r5, #0]
  __ASM volatile ("dmb 0xF":::"memory");
   1ea70:	f3bf 8f5f 	dmb	sy
    SYS_INT_SourceRestore(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc, intStat);
   1ea74:	f9b4 00b6 	ldrsh.w	r0, [r4, #182]	; 0xb6
   1ea78:	f002 f8aa 	bl	20bd0 <SYS_INT_SourceRestore>
}
   1ea7c:	bd70      	pop	{r4, r5, r6, pc}
   1ea7e:	bf00      	nop
   1ea80:	2000e370 	.word	0x2000e370

Disassembly of section .text._TCP_SktFlagsGet%673:

0001ea84 <_TCP_SktFlagsGet>:
    return (pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1 || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2 || pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT);
   1ea84:	f890 206e 	ldrb.w	r2, [r0, #110]	; 0x6e
   1ea88:	1ed3      	subs	r3, r2, #3
   1ea8a:	b2db      	uxtb	r3, r3
   1ea8c:	2b02      	cmp	r3, #2
   1ea8e:	d911      	bls.n	1eab4 <_TCP_SktFlagsGet+0x30>
        flags |= TCP_SOCKET_FLAG_CONNECTED;
   1ea90:	2a08      	cmp	r2, #8
   1ea92:	bf14      	ite	ne
   1ea94:	2301      	movne	r3, #1
   1ea96:	2303      	moveq	r3, #3
    if(pSkt->Flags.bSocketReset)
   1ea98:	f890 2037 	ldrb.w	r2, [r0, #55]	; 0x37
   1ea9c:	f012 0f02 	tst.w	r2, #2
        flags |= TCP_SOCKET_FLAG_RST;
   1eaa0:	bf18      	it	ne
   1eaa2:	f043 0304 	orrne.w	r3, r3, #4
    if(pSkt->Flags.bRxFin)
   1eaa6:	f012 0f04 	tst.w	r2, #4
        flags |= TCP_SOCKET_FLAG_FIN;
   1eaaa:	bf18      	it	ne
   1eaac:	f043 0308 	orrne.w	r3, r3, #8
}
   1eab0:	4618      	mov	r0, r3
   1eab2:	4770      	bx	lr
        flags |= TCP_SOCKET_FLAG_CONNECTED;
   1eab4:	2303      	movs	r3, #3
   1eab6:	e7ef      	b.n	1ea98 <_TCP_SktFlagsGet+0x14>

Disassembly of section .text._ARPSetEntry%674:

0001eab8 <_ARPSetEntry>:
{
   1eab8:	b538      	push	{r3, r4, r5, lr}
   1eaba:	4604      	mov	r4, r0
    arpHE->hEntry.flags.value &= ~ARP_FLAG_ENTRY_VALID_MASK;
   1eabc:	8805      	ldrh	r5, [r0, #0]
   1eabe:	f025 05c0 	bic.w	r5, r5, #192	; 0xc0
    arpHE->hEntry.flags.value |= newFlags;
   1eac2:	4329      	orrs	r1, r5
   1eac4:	8001      	strh	r1, [r0, #0]
    if(hwAdd)
   1eac6:	b11a      	cbz	r2, 1ead0 <_ARPSetEntry+0x18>
        arpHE->hwAdd = *hwAdd;
   1eac8:	6810      	ldr	r0, [r2, #0]
   1eaca:	6120      	str	r0, [r4, #16]
   1eacc:	8892      	ldrh	r2, [r2, #4]
   1eace:	82a2      	strh	r2, [r4, #20]
    arpHE->tInsert = arpMod.timeSeconds;
   1ead0:	4a05      	ldr	r2, [pc, #20]	; (1eae8 <_ARPSetEntry+0x30>)
   1ead2:	6952      	ldr	r2, [r2, #20]
   1ead4:	60e2      	str	r2, [r4, #12]
    arpHE->nRetries = 1;
   1ead6:	2201      	movs	r2, #1
   1ead8:	82e2      	strh	r2, [r4, #22]
    if(addList)
   1eada:	b11b      	cbz	r3, 1eae4 <_ARPSetEntry+0x2c>
   1eadc:	4618      	mov	r0, r3
        TCPIP_Helper_ProtectedSingleListTailAdd(addList, (SGL_LIST_NODE*)&arpHE->next);
   1eade:	1d21      	adds	r1, r4, #4
   1eae0:	f001 f8bd 	bl	1fc5e <TCPIP_Helper_ProtectedSingleListTailAdd>
}
   1eae4:	bd38      	pop	{r3, r4, r5, pc}
   1eae6:	bf00      	nop
   1eae8:	2000dfa4 	.word	0x2000dfa4

Disassembly of section .text.TCPIP_ARP_HandlerRegister%675:

0001eaec <TCPIP_ARP_HandlerRegister>:
    if(handler && arpMod.memH)
   1eaec:	b181      	cbz	r1, 1eb10 <TCPIP_ARP_HandlerRegister+0x24>
   1eaee:	460b      	mov	r3, r1
   1eaf0:	4909      	ldr	r1, [pc, #36]	; (1eb18 <TCPIP_ARP_HandlerRegister+0x2c>)
   1eaf2:	6889      	ldr	r1, [r1, #8]
   1eaf4:	b169      	cbz	r1, 1eb12 <TCPIP_ARP_HandlerRegister+0x26>
{
   1eaf6:	b500      	push	{lr}
   1eaf8:	b085      	sub	sp, #20
        arpNode.handler = handler;
   1eafa:	9301      	str	r3, [sp, #4]
        arpNode.hParam = hParam;
   1eafc:	9202      	str	r2, [sp, #8]
        arpNode.hNet = hNet;
   1eafe:	9003      	str	r0, [sp, #12]
        return (ARP_LIST_NODE*)TCPIP_Notification_Add(&arpMod.registeredUsers, arpMod.memH, &arpNode, sizeof(arpNode));
   1eb00:	2310      	movs	r3, #16
   1eb02:	466a      	mov	r2, sp
   1eb04:	4805      	ldr	r0, [pc, #20]	; (1eb1c <TCPIP_ARP_HandlerRegister+0x30>)
   1eb06:	f001 f8d4 	bl	1fcb2 <TCPIP_Notification_Add>
}
   1eb0a:	b005      	add	sp, #20
   1eb0c:	f85d fb04 	ldr.w	pc, [sp], #4
    return 0;
   1eb10:	2100      	movs	r1, #0
}
   1eb12:	4608      	mov	r0, r1
   1eb14:	4770      	bx	lr
   1eb16:	bf00      	nop
   1eb18:	2000dfa4 	.word	0x2000dfa4
   1eb1c:	2000dfc4 	.word	0x2000dfc4

Disassembly of section .rodata%676:

0001eb20 <.rodata%676>:
   1eb20:	50434844 	.word	0x50434844
   1eb24:	6146203a 	.word	0x6146203a
   1eb28:	64656c69 	.word	0x64656c69
   1eb2c:	206f7420 	.word	0x206f7420
   1eb30:	69676572 	.word	0x69676572
   1eb34:	72657473 	.word	0x72657473
   1eb38:	76504920 	.word	0x76504920
   1eb3c:	69662034 	.word	0x69662034
   1eb40:	7265746c 	.word	0x7265746c
   1eb44:	0a0d2021 	.word	0x0a0d2021
   1eb48:	00000000 	.word	0x00000000
   1eb4c:	ffffffff 	.word	0xffffffff
   1eb50:	ffff      	.short	0xffff
   1eb52:	bf00      	nop

Disassembly of section .text._DNSGetData%677:

0001eb54 <_DNSGetData>:
{
   1eb54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1eb56:	4605      	mov	r5, r0
   1eb58:	4616      	mov	r6, r2
    size_t avlblBytes = srcBuff->endPtr - srcBuff->rdPtr;
   1eb5a:	6843      	ldr	r3, [r0, #4]
   1eb5c:	6884      	ldr	r4, [r0, #8]
   1eb5e:	1ae4      	subs	r4, r4, r3
    if(copyBytes > avlblBytes)
   1eb60:	4627      	mov	r7, r4
   1eb62:	4294      	cmp	r4, r2
   1eb64:	bf28      	it	cs
   1eb66:	4617      	movcs	r7, r2
    if(destBuff && copyBytes)
   1eb68:	4608      	mov	r0, r1
   1eb6a:	b101      	cbz	r1, 1eb6e <_DNSGetData+0x1a>
   1eb6c:	b93f      	cbnz	r7, 1eb7e <_DNSGetData+0x2a>
    srcBuff->rdPtr += copyBytes;
   1eb6e:	686a      	ldr	r2, [r5, #4]
   1eb70:	443a      	add	r2, r7
   1eb72:	606a      	str	r2, [r5, #4]
}
   1eb74:	42b4      	cmp	r4, r6
   1eb76:	bf34      	ite	cc
   1eb78:	2000      	movcc	r0, #0
   1eb7a:	2001      	movcs	r0, #1
   1eb7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        memcpy(destBuff, srcBuff->rdPtr, copyBytes);
   1eb7e:	463a      	mov	r2, r7
   1eb80:	4619      	mov	r1, r3
   1eb82:	f002 fafd 	bl	21180 <memcpy>
   1eb86:	e7f2      	b.n	1eb6e <_DNSGetData+0x1a>

Disassembly of section .text.TCPIP_STACK_NetDown%678:

0001eb88 <TCPIP_STACK_NetDown>:
    if(pDownIf)
   1eb88:	b1a0      	cbz	r0, 1ebb4 <TCPIP_STACK_NetDown+0x2c>
{
   1eb8a:	b510      	push	{r4, lr}
   1eb8c:	4604      	mov	r4, r0
        if(pDownIf->Flags.bInterfaceEnabled || pDownIf->Flags.bMacInitialize)
   1eb8e:	f8b0 3042 	ldrh.w	r3, [r0, #66]	; 0x42
   1eb92:	f244 0240 	movw	r2, #16448	; 0x4040
   1eb96:	421a      	tst	r2, r3
   1eb98:	d101      	bne.n	1eb9e <TCPIP_STACK_NetDown+0x16>
        return true;
   1eb9a:	2001      	movs	r0, #1
}
   1eb9c:	bd10      	pop	{r4, pc}
            TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pDownIf, TCPIP_STACK_ACTION_IF_DOWN, TCPIP_MAC_POWER_DOWN);
   1eb9e:	2303      	movs	r3, #3
   1eba0:	2204      	movs	r2, #4
   1eba2:	4601      	mov	r1, r0
   1eba4:	4804      	ldr	r0, [pc, #16]	; (1ebb8 <TCPIP_STACK_NetDown+0x30>)
   1eba6:	f7fc fb53 	bl	1b250 <TCPIP_STACK_BringNetDown>
            _TCPIP_SelectDefaultNet(pDownIf);
   1ebaa:	4620      	mov	r0, r4
   1ebac:	f7fc fda0 	bl	1b6f0 <_TCPIP_SelectDefaultNet>
        return true;
   1ebb0:	2001      	movs	r0, #1
   1ebb2:	e7f3      	b.n	1eb9c <TCPIP_STACK_NetDown+0x14>
    return false;
   1ebb4:	2000      	movs	r0, #0
}
   1ebb6:	4770      	bx	lr
   1ebb8:	2000e0f0 	.word	0x2000e0f0

Disassembly of section .text.TCPIP_UDP_RxOffsetSet%679:

0001ebbc <TCPIP_UDP_RxOffsetSet>:
{
   1ebbc:	b538      	push	{r3, r4, r5, lr}
   1ebbe:	4604      	mov	r4, r0
   1ebc0:	460d      	mov	r5, r1
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1ebc2:	f001 fa2f 	bl	20024 <_UDPSocketDcpt>
    if(pSkt && pSkt->pCurrRxPkt != 0)
   1ebc6:	b190      	cbz	r0, 1ebee <TCPIP_UDP_RxOffsetSet+0x32>
   1ebc8:	4603      	mov	r3, r0
   1ebca:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   1ebcc:	b17a      	cbz	r2, 1ebee <TCPIP_UDP_RxOffsetSet+0x32>
        UDP_HEADER* pUDPHdr = (UDP_HEADER*)pRxPkt->pTransportLayer;
   1ebce:	69d0      	ldr	r0, [r2, #28]
        pSkt->pCurrRxSeg = pRxPkt->pDSeg;
   1ebd0:	6911      	ldr	r1, [r2, #16]
   1ebd2:	6319      	str	r1, [r3, #48]	; 0x30
        pSkt->rxSegLen = pRxPkt->pDSeg->segLen - sizeof(UDP_HEADER);
   1ebd4:	8989      	ldrh	r1, [r1, #12]
   1ebd6:	3908      	subs	r1, #8
   1ebd8:	8699      	strh	r1, [r3, #52]	; 0x34
        pSkt->rxTotLen = pUDPHdr->Length;  
   1ebda:	8881      	ldrh	r1, [r0, #4]
   1ebdc:	86d9      	strh	r1, [r3, #54]	; 0x36
        pSkt->rxCurr = pRxPkt->pTransportLayer + sizeof(UDP_HEADER);
   1ebde:	69d2      	ldr	r2, [r2, #28]
   1ebe0:	3208      	adds	r2, #8
   1ebe2:	639a      	str	r2, [r3, #56]	; 0x38
        TCPIP_UDP_ArrayGet(s, 0, wOffset);
   1ebe4:	462a      	mov	r2, r5
   1ebe6:	2100      	movs	r1, #0
   1ebe8:	4620      	mov	r0, r4
   1ebea:	f7f6 fb5d 	bl	152a8 <TCPIP_UDP_ArrayGet>
}
   1ebee:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.CommandQuit%680:

0001ebf0 <CommandQuit>:
{
   1ebf0:	b510      	push	{r4, lr}
    (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** Quitting the Command Processor. Bye ***\r\n" );
   1ebf2:	6803      	ldr	r3, [r0, #0]
   1ebf4:	681b      	ldr	r3, [r3, #0]
   1ebf6:	4908      	ldr	r1, [pc, #32]	; (1ec18 <CommandQuit+0x28>)
   1ebf8:	6840      	ldr	r0, [r0, #4]
   1ebfa:	4798      	blx	r3
    memset(_usrCmdTbl, 0x0, sizeof(_usrCmdTbl));
   1ebfc:	2280      	movs	r2, #128	; 0x80
   1ebfe:	2100      	movs	r1, #0
   1ec00:	4806      	ldr	r0, [pc, #24]	; (1ec1c <CommandQuit+0x2c>)
   1ec02:	f003 f843 	bl	21c8c <memset>
    while((pCmdIoNode = cmdIODevList.head) != NULL)
   1ec06:	4b06      	ldr	r3, [pc, #24]	; (1ec20 <CommandQuit+0x30>)
   1ec08:	681c      	ldr	r4, [r3, #0]
   1ec0a:	b11c      	cbz	r4, 1ec14 <CommandQuit+0x24>
        free(pCmdIoNode);
   1ec0c:	4620      	mov	r0, r4
   1ec0e:	f003 f835 	bl	21c7c <free>
   1ec12:	e7fb      	b.n	1ec0c <CommandQuit+0x1c>
}
   1ec14:	bd10      	pop	{r4, pc}
   1ec16:	bf00      	nop
   1ec18:	0000d194 	.word	0x0000d194
   1ec1c:	2000dd98 	.word	0x2000dd98
   1ec20:	2000e360 	.word	0x2000e360

Disassembly of section .text.Console_UART_WriteCountGet%681:

0001ec24 <Console_UART_WriteCountGet>:

    return nFreeBufferAvailable;
}

ssize_t Console_UART_WriteCountGet(uint32_t index)
{
   1ec24:	b538      	push	{r3, r4, r5, lr}
    ssize_t nPendingTxBytes = 0;

    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   1ec26:	b970      	cbnz	r0, 1ec46 <Console_UART_WriteCountGet+0x22>
    if (pConsoleUartData == NULL)
    {
        return -1;
    }

    if (Console_UART_ResourceLock(pConsoleUartData) == false)
   1ec28:	480a      	ldr	r0, [pc, #40]	; (1ec54 <Console_UART_WriteCountGet+0x30>)
   1ec2a:	f002 fec5 	bl	219b8 <Console_UART_ResourceLock>
   1ec2e:	b168      	cbz	r0, 1ec4c <Console_UART_WriteCountGet+0x28>
    {
        return -1;
    }

    nPendingTxBytes = pConsoleUartData->uartPLIB->writeCountGet();
   1ec30:	4c08      	ldr	r4, [pc, #32]	; (1ec54 <Console_UART_WriteCountGet+0x30>)
   1ec32:	f854 3b08 	ldr.w	r3, [r4], #8
   1ec36:	691b      	ldr	r3, [r3, #16]
   1ec38:	4798      	blx	r3
   1ec3a:	4605      	mov	r5, r0
    OSAL_MUTEX_Unlock(&(pConsoleUartData->mutexTransferObjects));
   1ec3c:	4620      	mov	r0, r4
   1ec3e:	f002 fce1 	bl	21604 <OSAL_MUTEX_Unlock>

    Console_UART_ResourceUnlock(pConsoleUartData);

    return nPendingTxBytes;
}
   1ec42:	4628      	mov	r0, r5
   1ec44:	bd38      	pop	{r3, r4, r5, pc}
        return -1;
   1ec46:	f04f 35ff 	mov.w	r5, #4294967295
   1ec4a:	e7fa      	b.n	1ec42 <Console_UART_WriteCountGet+0x1e>
        return -1;
   1ec4c:	f04f 35ff 	mov.w	r5, #4294967295
   1ec50:	e7f7      	b.n	1ec42 <Console_UART_WriteCountGet+0x1e>
   1ec52:	bf00      	nop
   1ec54:	2000e334 	.word	0x2000e334

Disassembly of section .text.Console_UART_WriteFreeBufferCountGet%682:

0001ec58 <Console_UART_WriteFreeBufferCountGet>:
{
   1ec58:	b538      	push	{r3, r4, r5, lr}
    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   1ec5a:	b970      	cbnz	r0, 1ec7a <Console_UART_WriteFreeBufferCountGet+0x22>
    if (Console_UART_ResourceLock(pConsoleUartData) == false)
   1ec5c:	480a      	ldr	r0, [pc, #40]	; (1ec88 <Console_UART_WriteFreeBufferCountGet+0x30>)
   1ec5e:	f002 feab 	bl	219b8 <Console_UART_ResourceLock>
   1ec62:	b168      	cbz	r0, 1ec80 <Console_UART_WriteFreeBufferCountGet+0x28>
    nFreeBufferAvailable = pConsoleUartData->uartPLIB->writeFreeBufferCountGet();
   1ec64:	4c08      	ldr	r4, [pc, #32]	; (1ec88 <Console_UART_WriteFreeBufferCountGet+0x30>)
   1ec66:	f854 3b08 	ldr.w	r3, [r4], #8
   1ec6a:	695b      	ldr	r3, [r3, #20]
   1ec6c:	4798      	blx	r3
   1ec6e:	4605      	mov	r5, r0
    OSAL_MUTEX_Unlock(&(pConsoleUartData->mutexTransferObjects));
   1ec70:	4620      	mov	r0, r4
   1ec72:	f002 fcc7 	bl	21604 <OSAL_MUTEX_Unlock>
}
   1ec76:	4628      	mov	r0, r5
   1ec78:	bd38      	pop	{r3, r4, r5, pc}
        return -1;
   1ec7a:	f04f 35ff 	mov.w	r5, #4294967295
   1ec7e:	e7fa      	b.n	1ec76 <Console_UART_WriteFreeBufferCountGet+0x1e>
        return -1;
   1ec80:	f04f 35ff 	mov.w	r5, #4294967295
   1ec84:	e7f7      	b.n	1ec76 <Console_UART_WriteFreeBufferCountGet+0x1e>
   1ec86:	bf00      	nop
   1ec88:	2000e334 	.word	0x2000e334

Disassembly of section .text.Console_UART_ReadFreeBufferCountGet%683:

0001ec8c <Console_UART_ReadFreeBufferCountGet>:
{
   1ec8c:	b538      	push	{r3, r4, r5, lr}
    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   1ec8e:	b970      	cbnz	r0, 1ecae <Console_UART_ReadFreeBufferCountGet+0x22>
    if (Console_UART_ResourceLock(pConsoleUartData) == false)
   1ec90:	480a      	ldr	r0, [pc, #40]	; (1ecbc <Console_UART_ReadFreeBufferCountGet+0x30>)
   1ec92:	f002 fe91 	bl	219b8 <Console_UART_ResourceLock>
   1ec96:	b168      	cbz	r0, 1ecb4 <Console_UART_ReadFreeBufferCountGet+0x28>
    nFreeBufferAvailable = pConsoleUartData->uartPLIB->readFreeBufferCountGet();
   1ec98:	4c08      	ldr	r4, [pc, #32]	; (1ecbc <Console_UART_ReadFreeBufferCountGet+0x30>)
   1ec9a:	f854 3b08 	ldr.w	r3, [r4], #8
   1ec9e:	689b      	ldr	r3, [r3, #8]
   1eca0:	4798      	blx	r3
   1eca2:	4605      	mov	r5, r0
    OSAL_MUTEX_Unlock(&(pConsoleUartData->mutexTransferObjects));
   1eca4:	4620      	mov	r0, r4
   1eca6:	f002 fcad 	bl	21604 <OSAL_MUTEX_Unlock>
}
   1ecaa:	4628      	mov	r0, r5
   1ecac:	bd38      	pop	{r3, r4, r5, pc}
        return -1;
   1ecae:	f04f 35ff 	mov.w	r5, #4294967295
   1ecb2:	e7fa      	b.n	1ecaa <Console_UART_ReadFreeBufferCountGet+0x1e>
        return -1;
   1ecb4:	f04f 35ff 	mov.w	r5, #4294967295
   1ecb8:	e7f7      	b.n	1ecaa <Console_UART_ReadFreeBufferCountGet+0x1e>
   1ecba:	bf00      	nop
   1ecbc:	2000e334 	.word	0x2000e334

Disassembly of section .text.Console_UART_ReadCountGet%684:

0001ecc0 <Console_UART_ReadCountGet>:
{
   1ecc0:	b538      	push	{r3, r4, r5, lr}
    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   1ecc2:	b970      	cbnz	r0, 1ece2 <Console_UART_ReadCountGet+0x22>
    if (Console_UART_ResourceLock(pConsoleUartData) == false)
   1ecc4:	480a      	ldr	r0, [pc, #40]	; (1ecf0 <Console_UART_ReadCountGet+0x30>)
   1ecc6:	f002 fe77 	bl	219b8 <Console_UART_ResourceLock>
   1ecca:	b168      	cbz	r0, 1ece8 <Console_UART_ReadCountGet+0x28>
    nUnreadBytesAvailable = pConsoleUartData->uartPLIB->readCountGet();
   1eccc:	4c08      	ldr	r4, [pc, #32]	; (1ecf0 <Console_UART_ReadCountGet+0x30>)
   1ecce:	f854 3b08 	ldr.w	r3, [r4], #8
   1ecd2:	685b      	ldr	r3, [r3, #4]
   1ecd4:	4798      	blx	r3
   1ecd6:	4605      	mov	r5, r0
    OSAL_MUTEX_Unlock(&(pConsoleUartData->mutexTransferObjects));
   1ecd8:	4620      	mov	r0, r4
   1ecda:	f002 fc93 	bl	21604 <OSAL_MUTEX_Unlock>
}
   1ecde:	4628      	mov	r0, r5
   1ece0:	bd38      	pop	{r3, r4, r5, pc}
        return -1;
   1ece2:	f04f 35ff 	mov.w	r5, #4294967295
   1ece6:	e7fa      	b.n	1ecde <Console_UART_ReadCountGet+0x1e>
        return -1;
   1ece8:	f04f 35ff 	mov.w	r5, #4294967295
   1ecec:	e7f7      	b.n	1ecde <Console_UART_ReadCountGet+0x1e>
   1ecee:	bf00      	nop
   1ecf0:	2000e334 	.word	0x2000e334

Disassembly of section .text.SYS_CONSOLE_Read%685:

0001ecf4 <SYS_CONSOLE_Read>:
    SYS_CONSOLE_OBJECT_INSTANCE* pConsoleObj = SYS_CONSOLE_GET_INSTANCE(handle);
   1ecf4:	b960      	cbnz	r0, 1ed10 <SYS_CONSOLE_Read+0x1c>
{
   1ecf6:	b508      	push	{r3, lr}
        if (pConsoleObj->status == SYS_STATUS_UNINITIALIZED || pConsoleObj->devDesc == NULL)
   1ecf8:	4b0a      	ldr	r3, [pc, #40]	; (1ed24 <SYS_CONSOLE_Read+0x30>)
   1ecfa:	f993 3000 	ldrsb.w	r3, [r3]
   1ecfe:	b153      	cbz	r3, 1ed16 <SYS_CONSOLE_Read+0x22>
   1ed00:	4b08      	ldr	r3, [pc, #32]	; (1ed24 <SYS_CONSOLE_Read+0x30>)
   1ed02:	685b      	ldr	r3, [r3, #4]
   1ed04:	b153      	cbz	r3, 1ed1c <SYS_CONSOLE_Read+0x28>
        return pConsoleObj->devDesc->read(pConsoleObj->devIndex, buf, count);
   1ed06:	689b      	ldr	r3, [r3, #8]
   1ed08:	4806      	ldr	r0, [pc, #24]	; (1ed24 <SYS_CONSOLE_Read+0x30>)
   1ed0a:	6880      	ldr	r0, [r0, #8]
   1ed0c:	4798      	blx	r3
}
   1ed0e:	bd08      	pop	{r3, pc}
        return -1;
   1ed10:	f04f 30ff 	mov.w	r0, #4294967295
}
   1ed14:	4770      	bx	lr
            return -1;
   1ed16:	f04f 30ff 	mov.w	r0, #4294967295
   1ed1a:	e7f8      	b.n	1ed0e <SYS_CONSOLE_Read+0x1a>
   1ed1c:	f04f 30ff 	mov.w	r0, #4294967295
   1ed20:	e7f5      	b.n	1ed0e <SYS_CONSOLE_Read+0x1a>
   1ed22:	bf00      	nop
   1ed24:	2000e340 	.word	0x2000e340

Disassembly of section .text.SYS_CONSOLE_ReadCountGet%686:

0001ed28 <SYS_CONSOLE_ReadCountGet>:
    SYS_CONSOLE_OBJECT_INSTANCE* pConsoleObj = SYS_CONSOLE_GET_INSTANCE(handle);
   1ed28:	b960      	cbnz	r0, 1ed44 <SYS_CONSOLE_ReadCountGet+0x1c>
{
   1ed2a:	b508      	push	{r3, lr}
        if (pConsoleObj->status == SYS_STATUS_UNINITIALIZED || pConsoleObj->devDesc == NULL)
   1ed2c:	4b0a      	ldr	r3, [pc, #40]	; (1ed58 <SYS_CONSOLE_ReadCountGet+0x30>)
   1ed2e:	f993 3000 	ldrsb.w	r3, [r3]
   1ed32:	b153      	cbz	r3, 1ed4a <SYS_CONSOLE_ReadCountGet+0x22>
   1ed34:	4b08      	ldr	r3, [pc, #32]	; (1ed58 <SYS_CONSOLE_ReadCountGet+0x30>)
   1ed36:	685b      	ldr	r3, [r3, #4]
   1ed38:	b153      	cbz	r3, 1ed50 <SYS_CONSOLE_ReadCountGet+0x28>
        return pConsoleObj->devDesc->readCountGet(pConsoleObj->devIndex);
   1ed3a:	68db      	ldr	r3, [r3, #12]
   1ed3c:	4a06      	ldr	r2, [pc, #24]	; (1ed58 <SYS_CONSOLE_ReadCountGet+0x30>)
   1ed3e:	6890      	ldr	r0, [r2, #8]
   1ed40:	4798      	blx	r3
}
   1ed42:	bd08      	pop	{r3, pc}
        return -1;
   1ed44:	f04f 30ff 	mov.w	r0, #4294967295
}
   1ed48:	4770      	bx	lr
            return -1;
   1ed4a:	f04f 30ff 	mov.w	r0, #4294967295
   1ed4e:	e7f8      	b.n	1ed42 <SYS_CONSOLE_ReadCountGet+0x1a>
   1ed50:	f04f 30ff 	mov.w	r0, #4294967295
   1ed54:	e7f5      	b.n	1ed42 <SYS_CONSOLE_ReadCountGet+0x1a>
   1ed56:	bf00      	nop
   1ed58:	2000e340 	.word	0x2000e340

Disassembly of section .text.SYS_CONSOLE_Write%687:

0001ed5c <SYS_CONSOLE_Write>:
    SYS_CONSOLE_OBJECT_INSTANCE* pConsoleObj = SYS_CONSOLE_GET_INSTANCE(handle);
   1ed5c:	b960      	cbnz	r0, 1ed78 <SYS_CONSOLE_Write+0x1c>
{
   1ed5e:	b508      	push	{r3, lr}
        if (pConsoleObj->status == SYS_STATUS_UNINITIALIZED || pConsoleObj->devDesc == NULL)
   1ed60:	4b0a      	ldr	r3, [pc, #40]	; (1ed8c <SYS_CONSOLE_Write+0x30>)
   1ed62:	f993 3000 	ldrsb.w	r3, [r3]
   1ed66:	b153      	cbz	r3, 1ed7e <SYS_CONSOLE_Write+0x22>
   1ed68:	4b08      	ldr	r3, [pc, #32]	; (1ed8c <SYS_CONSOLE_Write+0x30>)
   1ed6a:	685b      	ldr	r3, [r3, #4]
   1ed6c:	b153      	cbz	r3, 1ed84 <SYS_CONSOLE_Write+0x28>
        return pConsoleObj->devDesc->write(pConsoleObj->devIndex, buf, count);
   1ed6e:	695b      	ldr	r3, [r3, #20]
   1ed70:	4806      	ldr	r0, [pc, #24]	; (1ed8c <SYS_CONSOLE_Write+0x30>)
   1ed72:	6880      	ldr	r0, [r0, #8]
   1ed74:	4798      	blx	r3
}
   1ed76:	bd08      	pop	{r3, pc}
        return -1;
   1ed78:	f04f 30ff 	mov.w	r0, #4294967295
}
   1ed7c:	4770      	bx	lr
            return -1;
   1ed7e:	f04f 30ff 	mov.w	r0, #4294967295
   1ed82:	e7f8      	b.n	1ed76 <SYS_CONSOLE_Write+0x1a>
   1ed84:	f04f 30ff 	mov.w	r0, #4294967295
   1ed88:	e7f5      	b.n	1ed76 <SYS_CONSOLE_Write+0x1a>
   1ed8a:	bf00      	nop
   1ed8c:	2000e340 	.word	0x2000e340

Disassembly of section .rodata.tcpipMACPIC32CINTInitData%688:

0001ed90 <tcpipMACPIC32CINTInitData>:
   1ed90:	00000000 00080000 00020008 00020001     ................
   1eda0:	06000008 01010600 041401f4 42000800     ...............B
   1edb0:	0001b870 00020c10 00010000 00000001     p...............
   1edc0:	00000000                                ....

Disassembly of section .text.vListInsert%689:

0001edc4 <vListInsert>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   1edc4:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
   1edc6:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
   1edc8:	f1b5 3fff 	cmp.w	r5, #4294967295
   1edcc:	d002      	beq.n	1edd4 <vListInsert+0x10>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
   1edce:	f100 0208 	add.w	r2, r0, #8
   1edd2:	e002      	b.n	1edda <vListInsert+0x16>
		pxIterator = pxList->xListEnd.pxPrevious;
   1edd4:	6902      	ldr	r2, [r0, #16]
   1edd6:	e004      	b.n	1ede2 <vListInsert+0x1e>
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
   1edd8:	461a      	mov	r2, r3
   1edda:	6853      	ldr	r3, [r2, #4]
   1eddc:	681c      	ldr	r4, [r3, #0]
   1edde:	42ac      	cmp	r4, r5
   1ede0:	d9fa      	bls.n	1edd8 <vListInsert+0x14>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
   1ede2:	6853      	ldr	r3, [r2, #4]
   1ede4:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
   1ede6:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
   1ede8:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
   1edea:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
   1edec:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
   1edee:	6803      	ldr	r3, [r0, #0]
   1edf0:	3301      	adds	r3, #1
   1edf2:	6003      	str	r3, [r0, #0]
}
   1edf4:	bc30      	pop	{r4, r5}
   1edf6:	4770      	bx	lr

Disassembly of section .text.vTaskDelay%690:

0001edf8 <vTaskDelay>:
	{
   1edf8:	b510      	push	{r4, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
   1edfa:	b940      	cbnz	r0, 1ee0e <vTaskDelay+0x16>
			portYIELD_WITHIN_API();
   1edfc:	4b0a      	ldr	r3, [pc, #40]	; (1ee28 <vTaskDelay+0x30>)
   1edfe:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1ee02:	601a      	str	r2, [r3, #0]
   1ee04:	f3bf 8f4f 	dsb	sy
   1ee08:	f3bf 8f6f 	isb	sy
	}
   1ee0c:	bd10      	pop	{r4, pc}
   1ee0e:	4604      	mov	r4, r0
			vTaskSuspendAll();
   1ee10:	f002 ff14 	bl	21c3c <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
   1ee14:	2100      	movs	r1, #0
   1ee16:	4620      	mov	r0, r4
   1ee18:	f7f9 fb2e 	bl	18478 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
   1ee1c:	f7f6 f9d2 	bl	151c4 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
   1ee20:	2800      	cmp	r0, #0
   1ee22:	d1f3      	bne.n	1ee0c <vTaskDelay+0x14>
   1ee24:	e7ea      	b.n	1edfc <vTaskDelay+0x4>
   1ee26:	bf00      	nop
   1ee28:	e000ed04 	.word	0xe000ed04

Disassembly of section .text.Hash_DRBG_Uninstantiate%691:

0001ee2c <Hash_DRBG_Uninstantiate>:
{
   1ee2c:	b410      	push	{r4}
    while (len--) *z++ = 0;
   1ee2e:	f100 0484 	add.w	r4, r0, #132	; 0x84
    volatile byte* z = (volatile byte*)mem;
   1ee32:	4602      	mov	r2, r0
    while (len--) *z++ = 0;
   1ee34:	2100      	movs	r1, #0
   1ee36:	4613      	mov	r3, r2
   1ee38:	f803 1b01 	strb.w	r1, [r3], #1
   1ee3c:	461a      	mov	r2, r3
   1ee3e:	42a3      	cmp	r3, r4
   1ee40:	d1f9      	bne.n	1ee36 <Hash_DRBG_Uninstantiate+0xa>
   1ee42:	1e43      	subs	r3, r0, #1
   1ee44:	f100 0183 	add.w	r1, r0, #131	; 0x83
    int    compareSum = 0;
   1ee48:	2000      	movs	r0, #0
        compareSum |= compareDrbg[i] ^ 0;
   1ee4a:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   1ee4e:	4310      	orrs	r0, r2
    for (i = 0; i < sizeof(DRBG_internal); i++)
   1ee50:	428b      	cmp	r3, r1
   1ee52:	d1fa      	bne.n	1ee4a <Hash_DRBG_Uninstantiate+0x1e>
}
   1ee54:	3000      	adds	r0, #0
   1ee56:	bf18      	it	ne
   1ee58:	2001      	movne	r0, #1
   1ee5a:	f85d 4b04 	ldr.w	r4, [sp], #4
   1ee5e:	4770      	bx	lr

Disassembly of section .text.gfx_mono_generic_draw_filled_rect%692:

0001ee60 <gfx_mono_generic_draw_filled_rect>:
 * \param[in]  height      Height of the rectangle.
 * \param[in]  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
        gfx_coord_t width, gfx_coord_t height,
        enum gfx_mono_color color) {
   1ee60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1ee64:	f89d 7018 	ldrb.w	r7, [sp, #24]
    if (height == 0) {
   1ee68:	b193      	cbz	r3, 1ee90 <gfx_mono_generic_draw_filled_rect+0x30>
   1ee6a:	461c      	mov	r4, r3
   1ee6c:	4690      	mov	r8, r2
   1ee6e:	460d      	mov	r5, r1
   1ee70:	4606      	mov	r6, r0
   1ee72:	1e4b      	subs	r3, r1, #1
   1ee74:	441c      	add	r4, r3
   1ee76:	b2e4      	uxtb	r4, r4
   1ee78:	e000      	b.n	1ee7c <gfx_mono_generic_draw_filled_rect+0x1c>
   1ee7a:	461c      	mov	r4, r3
        /* Nothing to do. Move along. */
        return;
    }

    while (height-- > 0) {
        gfx_mono_draw_horizontal_line(x, y + height, width, color);
   1ee7c:	463b      	mov	r3, r7
   1ee7e:	4642      	mov	r2, r8
   1ee80:	4621      	mov	r1, r4
   1ee82:	4630      	mov	r0, r6
   1ee84:	f7f6 fefc 	bl	15c80 <gfx_mono_generic_draw_horizontal_line>
   1ee88:	1e63      	subs	r3, r4, #1
   1ee8a:	b2db      	uxtb	r3, r3
    while (height-- > 0) {
   1ee8c:	42a5      	cmp	r5, r4
   1ee8e:	d1f4      	bne.n	1ee7a <gfx_mono_generic_draw_filled_rect+0x1a>
    }
}
   1ee90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.memmove%693:

0001ee94 <memmove>:
   1ee94:	4288      	cmp	r0, r1
   1ee96:	b510      	push	{r4, lr}
   1ee98:	eb01 0302 	add.w	r3, r1, r2
   1ee9c:	d902      	bls.n	1eea4 <memmove+0x10>
   1ee9e:	4283      	cmp	r3, r0
   1eea0:	461c      	mov	r4, r3
   1eea2:	d807      	bhi.n	1eeb4 <memmove+0x20>
   1eea4:	1e42      	subs	r2, r0, #1
   1eea6:	4299      	cmp	r1, r3
   1eea8:	d008      	beq.n	1eebc <memmove+0x28>
   1eeaa:	f811 4b01 	ldrb.w	r4, [r1], #1
   1eeae:	f802 4f01 	strb.w	r4, [r2, #1]!
   1eeb2:	e7f8      	b.n	1eea6 <memmove+0x12>
   1eeb4:	1883      	adds	r3, r0, r2
   1eeb6:	1a9a      	subs	r2, r3, r2
   1eeb8:	429a      	cmp	r2, r3
   1eeba:	d100      	bne.n	1eebe <memmove+0x2a>
   1eebc:	bd10      	pop	{r4, pc}
   1eebe:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
   1eec2:	f803 1d01 	strb.w	r1, [r3, #-1]!
   1eec6:	e7f7      	b.n	1eeb8 <memmove+0x24>

Disassembly of section .text.__mcmp%694:

0001eec8 <__mcmp>:
   1eec8:	6903      	ldr	r3, [r0, #16]
   1eeca:	690a      	ldr	r2, [r1, #16]
   1eecc:	1a9b      	subs	r3, r3, r2
   1eece:	b530      	push	{r4, r5, lr}
   1eed0:	d10c      	bne.n	1eeec <__mcmp+0x24>
   1eed2:	0092      	lsls	r2, r2, #2
   1eed4:	3014      	adds	r0, #20
   1eed6:	3114      	adds	r1, #20
   1eed8:	1884      	adds	r4, r0, r2
   1eeda:	4411      	add	r1, r2
   1eedc:	f854 5d04 	ldr.w	r5, [r4, #-4]!
   1eee0:	f851 2d04 	ldr.w	r2, [r1, #-4]!
   1eee4:	4295      	cmp	r5, r2
   1eee6:	d003      	beq.n	1eef0 <__mcmp+0x28>
   1eee8:	d305      	bcc.n	1eef6 <__mcmp+0x2e>
   1eeea:	2301      	movs	r3, #1
   1eeec:	4618      	mov	r0, r3
   1eeee:	bd30      	pop	{r4, r5, pc}
   1eef0:	42a0      	cmp	r0, r4
   1eef2:	d3f3      	bcc.n	1eedc <__mcmp+0x14>
   1eef4:	e7fa      	b.n	1eeec <__mcmp+0x24>
   1eef6:	f04f 33ff 	mov.w	r3, #4294967295
   1eefa:	e7f7      	b.n	1eeec <__mcmp+0x24>

Disassembly of section .text._DRV_PHY_SMIReadStart%695:

0001eefc <_DRV_PHY_SMIReadStart>:
{
   1eefc:	b510      	push	{r4, lr}
   1eefe:	4604      	mov	r4, r0
    hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_START;
   1ef00:	2301      	movs	r3, #1
   1ef02:	8683      	strh	r3, [r0, #52]	; 0x34
    hClientObj->smiRIx = rIx;
   1ef04:	8701      	strh	r1, [r0, #56]	; 0x38
    hClientObj->smiTxferType = DRV_ETHPHY_SMI_XFER_TYPE_READ;
   1ef06:	2303      	movs	r3, #3
   1ef08:	86c3      	strh	r3, [r0, #54]	; 0x36
    hClientObj->smiPhyAddress = hClientObj->hDriver->phyAddress;
   1ef0a:	68c3      	ldr	r3, [r0, #12]
   1ef0c:	691b      	ldr	r3, [r3, #16]
   1ef0e:	63c3      	str	r3, [r0, #60]	; 0x3c
    DRV_ETHPHY_SMI_TXFER_RES opRes = _DRV_PHY_SMITransferStart(hClientObj);
   1ef10:	f7f8 fec6 	bl	17ca0 <_DRV_PHY_SMITransferStart>
    if(opRes < 0)
   1ef14:	2800      	cmp	r0, #0
   1ef16:	db03      	blt.n	1ef20 <_DRV_PHY_SMIReadStart+0x24>
    else if(opRes == DRV_ETHPHY_SMI_TXFER_RES_BUSY)
   1ef18:	3803      	subs	r0, #3
   1ef1a:	bf18      	it	ne
   1ef1c:	2001      	movne	r0, #1
}
   1ef1e:	bd10      	pop	{r4, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   1ef20:	f06f 0108 	mvn.w	r1, #8
   1ef24:	4620      	mov	r0, r4
   1ef26:	f000 ff01 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
        return false;
   1ef2a:	2000      	movs	r0, #0
   1ef2c:	e7f7      	b.n	1ef1e <_DRV_PHY_SMIReadStart+0x22>

Disassembly of section .text._DRV_PHY_SMIWriteStart%696:

0001ef2e <_DRV_PHY_SMIWriteStart>:
{
   1ef2e:	b510      	push	{r4, lr}
   1ef30:	4604      	mov	r4, r0
    hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_START;
   1ef32:	2301      	movs	r3, #1
   1ef34:	8683      	strh	r3, [r0, #52]	; 0x34
    hClientObj->smiRIx = rIx;
   1ef36:	8701      	strh	r1, [r0, #56]	; 0x38
    hClientObj->smiTxferType = DRV_ETHPHY_SMI_XFER_TYPE_WRITE;
   1ef38:	86c3      	strh	r3, [r0, #54]	; 0x36
    hClientObj->smiData =  wData;
   1ef3a:	8742      	strh	r2, [r0, #58]	; 0x3a
    hClientObj->smiPhyAddress = hClientObj->hDriver->phyAddress;
   1ef3c:	68c3      	ldr	r3, [r0, #12]
   1ef3e:	691b      	ldr	r3, [r3, #16]
   1ef40:	63c3      	str	r3, [r0, #60]	; 0x3c
    DRV_ETHPHY_SMI_TXFER_RES opRes = _DRV_PHY_SMITransferStart(hClientObj);
   1ef42:	f7f8 fead 	bl	17ca0 <_DRV_PHY_SMITransferStart>
    if(opRes < 0)
   1ef46:	2800      	cmp	r0, #0
   1ef48:	db03      	blt.n	1ef52 <_DRV_PHY_SMIWriteStart+0x24>
    else if(opRes == DRV_ETHPHY_SMI_TXFER_RES_BUSY)
   1ef4a:	3803      	subs	r0, #3
   1ef4c:	bf18      	it	ne
   1ef4e:	2001      	movne	r0, #1
}
   1ef50:	bd10      	pop	{r4, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   1ef52:	f06f 0108 	mvn.w	r1, #8
   1ef56:	4620      	mov	r0, r4
   1ef58:	f000 fee8 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
        return false;
   1ef5c:	2000      	movs	r0, #0
   1ef5e:	e7f7      	b.n	1ef50 <_DRV_PHY_SMIWriteStart+0x22>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseIdle%697:

0001ef60 <_DRV_ETHPHY_SetupPhaseIdle>:
    hDriver = hClientObj->hDriver;
   1ef60:	68c1      	ldr	r1, [r0, #12]
    configFlags = hDriver->configFlags;
   1ef62:	7b8b      	ldrb	r3, [r1, #14]
    openFlags = hDriver->openFlags;
   1ef64:	898a      	ldrh	r2, [r1, #12]
    if(openFlags & (TCPIP_ETH_OPEN_PHY_LOOPBACK | TCPIP_ETH_OPEN_MAC_LOOPBACK))
   1ef66:	f012 0fc0 	tst.w	r2, #192	; 0xc0
        openFlags &= ~TCPIP_ETH_OPEN_AUTO; // no negotiation in loopback mode!
   1ef6a:	bf1c      	itt	ne
   1ef6c:	f022 0201 	bicne.w	r2, r2, #1
   1ef70:	b292      	uxthne	r2, r2
    if(!(openFlags & TCPIP_ETH_OPEN_AUTO))
   1ef72:	f012 0f01 	tst.w	r2, #1
        openFlags &= ~TCPIP_ETH_OPEN_MDIX_AUTO;        // Auto-MDIX has to be in auto negotiation only
   1ef76:	bf04      	itt	eq
   1ef78:	f422 7280 	biceq.w	r2, r2, #256	; 0x100
   1ef7c:	b292      	uxtheq	r2, r2
    openFlags |= (configFlags & DRV_ETHPHY_CFG_RMII) ? TCPIP_ETH_OPEN_RMII : TCPIP_ETH_OPEN_MII;
   1ef7e:	029b      	lsls	r3, r3, #10
   1ef80:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   1ef84:	4313      	orrs	r3, r2
    hDriver->openFlags = openFlags;
   1ef86:	818b      	strh	r3, [r1, #12]
    hClientObj->operPhase = operPhase;
   1ef88:	2301      	movs	r3, #1
   1ef8a:	83c3      	strh	r3, [r0, #30]
    hClientObj->operSubPhase = operSubPhase;
   1ef8c:	2300      	movs	r3, #0
   1ef8e:	8403      	strh	r3, [r0, #32]
}
   1ef90:	4770      	bx	lr

Disassembly of section .text.DRV_PIC32CGMAC_LibTxAckPendPacket%698:

0001ef92 <DRV_PIC32CGMAC_LibTxAckPendPacket>:
{
   1ef92:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1ef96:	4605      	mov	r5, r0
   1ef98:	4690      	mov	r8, r2
    while((pPkt = (TCPIP_MAC_PACKET*)DRV_PIC32CGMAC_SingleListHeadRemove(&pMACDrv->sGmacData.gmac_queue[queueIdx]._TxQueue)) != 0)
   1ef9a:	242c      	movs	r4, #44	; 0x2c
   1ef9c:	fb04 0401 	mla	r4, r4, r1, r0
   1efa0:	34a4      	adds	r4, #164	; 0xa4
            (*pMACDrv->sGmacData.pktAckF)(pPkt, ackRes, TCPIP_THIS_MODULE_ID);
   1efa2:	f241 0750 	movw	r7, #4176	; 0x1050
    while((pPkt = (TCPIP_MAC_PACKET*)DRV_PIC32CGMAC_SingleListHeadRemove(&pMACDrv->sGmacData.gmac_queue[queueIdx]._TxQueue)) != 0)
   1efa6:	4620      	mov	r0, r4
   1efa8:	f001 ff62 	bl	20e70 <DRV_PIC32CGMAC_SingleListHeadRemove>
   1efac:	4606      	mov	r6, r0
   1efae:	b138      	cbz	r0, 1efc0 <DRV_PIC32CGMAC_LibTxAckPendPacket+0x2e>
        if(*pMACDrv->sGmacData.pktAckF)
   1efb0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   1efb2:	2b00      	cmp	r3, #0
   1efb4:	d0f7      	beq.n	1efa6 <DRV_PIC32CGMAC_LibTxAckPendPacket+0x14>
            (*pMACDrv->sGmacData.pktAckF)(pPkt, ackRes, TCPIP_THIS_MODULE_ID);
   1efb6:	463a      	mov	r2, r7
   1efb8:	4641      	mov	r1, r8
   1efba:	4630      	mov	r0, r6
   1efbc:	4798      	blx	r3
   1efbe:	e7f2      	b.n	1efa6 <DRV_PIC32CGMAC_LibTxAckPendPacket+0x14>
}
   1efc0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.TCPIP_STACK_NetBiosNameSet%699:

0001efc4 <TCPIP_STACK_NetBiosNameSet>:
   1efc4:	b1a8      	cbz	r0, 1eff2 <TCPIP_STACK_NetBiosNameSet+0x2e>
   1efc6:	4603      	mov	r3, r0
   1efc8:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1efcc:	f012 0f40 	tst.w	r2, #64	; 0x40
   1efd0:	d101      	bne.n	1efd6 <TCPIP_STACK_NetBiosNameSet+0x12>
    return false;
   1efd2:	2000      	movs	r0, #0
}
   1efd4:	4770      	bx	lr
{
   1efd6:	b570      	push	{r4, r5, r6, lr}
        memcpy(pNetIf->NetBIOSName, biosName, sizeof(pNetIf->NetBIOSName));
   1efd8:	302c      	adds	r0, #44	; 0x2c
   1efda:	680e      	ldr	r6, [r1, #0]
   1efdc:	684d      	ldr	r5, [r1, #4]
   1efde:	688c      	ldr	r4, [r1, #8]
   1efe0:	68ca      	ldr	r2, [r1, #12]
   1efe2:	62de      	str	r6, [r3, #44]	; 0x2c
   1efe4:	6045      	str	r5, [r0, #4]
   1efe6:	6084      	str	r4, [r0, #8]
   1efe8:	60c2      	str	r2, [r0, #12]
        TCPIP_Helper_FormatNetBIOSName(pNetIf->NetBIOSName);
   1efea:	f7fd fb7f 	bl	1c6ec <TCPIP_Helper_FormatNetBIOSName>
        return true;
   1efee:	2001      	movs	r0, #1
}
   1eff0:	bd70      	pop	{r4, r5, r6, pc}
    return false;
   1eff2:	2000      	movs	r0, #0
   1eff4:	4770      	bx	lr

Disassembly of section .text._DRV_PHY_NegCompleteSetOperResult%700:

0001eff6 <_DRV_PHY_NegCompleteSetOperResult>:
{
   1eff6:	b508      	push	{r3, lr}
    if(!phyBMCon.AN_ENABLE)
   1eff8:	0a09      	lsrs	r1, r1, #8
   1effa:	f011 0f10 	tst.w	r1, #16
   1effe:	d00a      	beq.n	1f016 <_DRV_PHY_NegCompleteSetOperResult+0x20>
    else if(phyBMCon.AN_RESTART)
   1f000:	f011 0f02 	tst.w	r1, #2
   1f004:	d10c      	bne.n	1f020 <_DRV_PHY_NegCompleteSetOperResult+0x2a>
        res = (phyStat.AN_COMPLETE == 0) ? DRV_ETHPHY_RES_NEGOTIATION_ACTIVE : DRV_ETHPHY_RES_OK;    // active/tmo/ok
   1f006:	f002 0220 	and.w	r2, r2, #32
   1f00a:	2a00      	cmp	r2, #0
   1f00c:	bf0c      	ite	eq
   1f00e:	f06f 0107 	mvneq.w	r1, #7
   1f012:	2100      	movne	r1, #0
   1f014:	e001      	b.n	1f01a <_DRV_PHY_NegCompleteSetOperResult+0x24>
        res = DRV_ETHPHY_RES_NEGOTIATION_INACTIVE;       // no negotiation is taking place!
   1f016:	f06f 0104 	mvn.w	r1, #4
    _DRV_PHY_SetOperDoneResult(hClientObj, res);
   1f01a:	f000 fe87 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
}
   1f01e:	bd08      	pop	{r3, pc}
        res = DRV_ETHPHY_RES_NEGOTIATION_NOT_STARTED;        // not started yet/tmo
   1f020:	f06f 0106 	mvn.w	r1, #6
   1f024:	e7f9      	b.n	1f01a <_DRV_PHY_NegCompleteSetOperResult+0x24>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3%701:

0001f028 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3>:
{
   1f028:	b538      	push	{r3, r4, r5, lr}
   1f02a:	4604      	mov	r4, r0
    DRV_ETHPHY_INSTANCE *hDriver = hClientObj->hDriver;
   1f02c:	68c3      	ldr	r3, [r0, #12]
    res = (*hDriver->pPhyObj->mdixConfigure)(gDrvEthBaseObj, (DRV_HANDLE)hClientObj, hClientObj->hDriver->openFlags);
   1f02e:	695a      	ldr	r2, [r3, #20]
   1f030:	6855      	ldr	r5, [r2, #4]
   1f032:	899a      	ldrh	r2, [r3, #12]
   1f034:	4601      	mov	r1, r0
   1f036:	4807      	ldr	r0, [pc, #28]	; (1f054 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3+0x2c>)
   1f038:	47a8      	blx	r5
    if(res < 0)
   1f03a:	1e01      	subs	r1, r0, #0
   1f03c:	db01      	blt.n	1f042 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3+0x1a>
    else if(res != DRV_ETHPHY_RES_OK)
   1f03e:	b121      	cbz	r1, 1f04a <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3+0x22>
}
   1f040:	bd38      	pop	{r3, r4, r5, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, res);
   1f042:	4620      	mov	r0, r4
   1f044:	f000 fe72 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
        return;
   1f048:	e7fa      	b.n	1f040 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3+0x18>
    hClientObj->operPhase = operPhase;
   1f04a:	2303      	movs	r3, #3
   1f04c:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1f04e:	2304      	movs	r3, #4
   1f050:	8423      	strh	r3, [r4, #32]
   1f052:	e7f5      	b.n	1f040 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3+0x18>
   1f054:	0001b870 	.word	0x0001b870

Disassembly of section .text.DRV_GMAC_Status%702:

0001f058 <DRV_GMAC_Status>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1f058:	4b0a      	ldr	r3, [pc, #40]	; (1f084 <DRV_GMAC_Status+0x2c>)
   1f05a:	4283      	cmp	r3, r0
   1f05c:	d108      	bne.n	1f070 <DRV_GMAC_Status+0x18>
    if(pMACDrv != 0)
   1f05e:	b150      	cbz	r0, 1f076 <DRV_GMAC_Status+0x1e>
        if(pMACDrv->sGmacData._macFlags._init != 0)
   1f060:	7d9b      	ldrb	r3, [r3, #22]
   1f062:	f013 0f01 	tst.w	r3, #1
   1f066:	d009      	beq.n	1f07c <DRV_GMAC_Status+0x24>
            return pMACDrv->sGmacData.sysStat;
   1f068:	4b06      	ldr	r3, [pc, #24]	; (1f084 <DRV_GMAC_Status+0x2c>)
   1f06a:	f993 0014 	ldrsb.w	r0, [r3, #20]
   1f06e:	4770      	bx	lr
	return SYS_STATUS_ERROR;
   1f070:	f04f 30ff 	mov.w	r0, #4294967295
   1f074:	4770      	bx	lr
   1f076:	f04f 30ff 	mov.w	r0, #4294967295
   1f07a:	4770      	bx	lr
   1f07c:	f04f 30ff 	mov.w	r0, #4294967295
}
   1f080:	4770      	bx	lr
   1f082:	bf00      	nop
   1f084:	2000d8b8 	.word	0x2000d8b8

Disassembly of section .text.DRV_PIC32CGMAC_LibSetMacAddr%703:

0001f088 <DRV_PIC32CGMAC_LibSetMacAddr>:
    GMAC_REGS->SA[0].GMAC_SAB = (pMacAddr[3] << 24)
   1f088:	78c2      	ldrb	r2, [r0, #3]
                                | (pMacAddr[2] << 16)
   1f08a:	7883      	ldrb	r3, [r0, #2]
   1f08c:	041b      	lsls	r3, r3, #16
   1f08e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
                                | (pMacAddr[0]);
   1f092:	7802      	ldrb	r2, [r0, #0]
   1f094:	4313      	orrs	r3, r2
                                | (pMacAddr[1] <<  8)
   1f096:	7842      	ldrb	r2, [r0, #1]
                                | (pMacAddr[0]);
   1f098:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    GMAC_REGS->SA[0].GMAC_SAB = (pMacAddr[3] << 24)
   1f09c:	4a05      	ldr	r2, [pc, #20]	; (1f0b4 <DRV_PIC32CGMAC_LibSetMacAddr+0x2c>)
   1f09e:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    GMAC_REGS->SA[0].GMAC_SAT = (pMacAddr[5] <<  8)
   1f0a2:	7941      	ldrb	r1, [r0, #5]
                                | (pMacAddr[4]) ;
   1f0a4:	7903      	ldrb	r3, [r0, #4]
   1f0a6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    GMAC_REGS->SA[0].GMAC_SAT = (pMacAddr[5] <<  8)
   1f0aa:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
}
   1f0ae:	2000      	movs	r0, #0
   1f0b0:	4770      	bx	lr
   1f0b2:	bf00      	nop
   1f0b4:	42000800 	.word	0x42000800

Disassembly of section .text.GMAC_InterruptHandler%704:

0001f0b8 <GMAC_InterruptHandler>:
{
   1f0b8:	b508      	push	{r3, lr}
    GMAC_EVENTS  currEthEvents = (GMAC_EVENTS)GMAC_REGS->GMAC_ISR;
   1f0ba:	4b09      	ldr	r3, [pc, #36]	; (1f0e0 <GMAC_InterruptHandler+0x28>)
   1f0bc:	6a59      	ldr	r1, [r3, #36]	; 0x24
    GMAC_REGS->GMAC_IDR = currEthEvents;
   1f0be:	b289      	uxth	r1, r1
   1f0c0:	62d9      	str	r1, [r3, #44]	; 0x2c
    if(currEthEvents & GMAC_EV_RX_ALL)
   1f0c2:	f240 4306 	movw	r3, #1030	; 0x406
   1f0c6:	4219      	tst	r1, r3
   1f0c8:	d004      	beq.n	1f0d4 <GMAC_InterruptHandler+0x1c>
        drvGmacQueEvents |= GMAC_QUE0_MASK;
   1f0ca:	4a06      	ldr	r2, [pc, #24]	; (1f0e4 <GMAC_InterruptHandler+0x2c>)
   1f0cc:	6813      	ldr	r3, [r2, #0]
   1f0ce:	f043 0301 	orr.w	r3, r3, #1
   1f0d2:	6013      	str	r3, [r2, #0]
   1f0d4:	f3bf 8f5f 	dmb	sy
	DRV_GMAC_Tasks_ISR((SYS_MODULE_OBJ)0, (uint32_t)currEthEvents);
   1f0d8:	2000      	movs	r0, #0
   1f0da:	f7fb fa17 	bl	1a50c <DRV_GMAC_Tasks_ISR>
}
   1f0de:	bd08      	pop	{r3, pc}
   1f0e0:	42000800 	.word	0x42000800
   1f0e4:	2000e370 	.word	0x2000e370

Disassembly of section .text.TCPIP_ICMP_Cleanup%705:

0001f0e8 <TCPIP_ICMP_Cleanup>:
{
   1f0e8:	b508      	push	{r3, lr}
    TCPIP_Notification_Deinitialize(&icmpRegisteredUsers, icmpMemH);
   1f0ea:	4b08      	ldr	r3, [pc, #32]	; (1f10c <TCPIP_ICMP_Cleanup+0x24>)
   1f0ec:	6819      	ldr	r1, [r3, #0]
   1f0ee:	4808      	ldr	r0, [pc, #32]	; (1f110 <TCPIP_ICMP_Cleanup+0x28>)
   1f0f0:	f002 fd54 	bl	21b9c <TCPIP_Notification_Deinitialize>
    if(signalHandle)
   1f0f4:	4b07      	ldr	r3, [pc, #28]	; (1f114 <TCPIP_ICMP_Cleanup+0x2c>)
   1f0f6:	6818      	ldr	r0, [r3, #0]
   1f0f8:	b120      	cbz	r0, 1f104 <TCPIP_ICMP_Cleanup+0x1c>
        _TCPIPStackSignalHandlerDeregister(signalHandle);
   1f0fa:	f002 fe1a 	bl	21d32 <_TCPIPStackSignalHandlerDeregister>
        signalHandle = 0;
   1f0fe:	4b05      	ldr	r3, [pc, #20]	; (1f114 <TCPIP_ICMP_Cleanup+0x2c>)
   1f100:	2200      	movs	r2, #0
   1f102:	601a      	str	r2, [r3, #0]
    icmpMemH = 0;
   1f104:	4b01      	ldr	r3, [pc, #4]	; (1f10c <TCPIP_ICMP_Cleanup+0x24>)
   1f106:	2200      	movs	r2, #0
   1f108:	601a      	str	r2, [r3, #0]
}
   1f10a:	bd08      	pop	{r3, pc}
   1f10c:	2000e380 	.word	0x2000e380
   1f110:	2000e214 	.word	0x2000e214
   1f114:	2000e388 	.word	0x2000e388

Disassembly of section .text._TCPSocketTxFreeSize%706:

0001f118 <_TCPSocketTxFreeSize>:
	if(!( (pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED) || (pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT) ))
   1f118:	f890 306e 	ldrb.w	r3, [r0, #110]	; 0x6e
   1f11c:	2b03      	cmp	r3, #3
   1f11e:	d001      	beq.n	1f124 <_TCPSocketTxFreeSize+0xc>
   1f120:	2b08      	cmp	r3, #8
   1f122:	d10f      	bne.n	1f144 <_TCPSocketTxFreeSize+0x2c>
	if(pSkt->txHead >= pSkt->txTail)
   1f124:	6882      	ldr	r2, [r0, #8]
   1f126:	68c3      	ldr	r3, [r0, #12]
   1f128:	429a      	cmp	r2, r3
   1f12a:	d203      	bcs.n	1f134 <_TCPSocketTxFreeSize+0x1c>
	return pSkt->txTail - pSkt->txHead - 1;
   1f12c:	1a98      	subs	r0, r3, r2
   1f12e:	3801      	subs	r0, #1
   1f130:	b280      	uxth	r0, r0
   1f132:	4770      	bx	lr
		return (pSkt->txEnd - pSkt->txStart - 1) - (pSkt->txHead - pSkt->txTail);
   1f134:	6841      	ldr	r1, [r0, #4]
   1f136:	6800      	ldr	r0, [r0, #0]
   1f138:	1a09      	subs	r1, r1, r0
   1f13a:	3901      	subs	r1, #1
   1f13c:	1ad0      	subs	r0, r2, r3
   1f13e:	1a08      	subs	r0, r1, r0
   1f140:	b280      	uxth	r0, r0
   1f142:	4770      	bx	lr
		return 0;
   1f144:	2000      	movs	r0, #0
}
   1f146:	4770      	bx	lr

Disassembly of section .text.TCPIP_ARP_HashEntryDelete%707:

0001f148 <TCPIP_ARP_HashEntryDelete>:
// This shouldn't normally occur if TCPIP_ARP_Task()
// does its job of periodically performing the cache clean-up.
// However, since the threshold can be dynamically adjusted,
// the situation could still occur
OA_HASH_ENTRY* TCPIP_ARP_HashEntryDelete(OA_HASH_DCPT* pOH)
{
   1f148:	b508      	push	{r3, lr}
    ARP_CACHE_DCPT  *pArpDcpt;
    ARP_HASH_ENTRY  *pE;
    SGL_LIST_NODE   *pN;
    PROTECTED_SINGLE_LIST     *pRemList = 0;
    
    pArpDcpt = (ARP_CACHE_DCPT*)pOH->hParam;
   1f14a:	6840      	ldr	r0, [r0, #4]

    if( (pN = pArpDcpt->incompleteList.list.head) != 0)
   1f14c:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   1f14e:	b142      	cbz	r2, 1f162 <TCPIP_ARP_HashEntryDelete+0x1a>
    {
        pE = (ARP_HASH_ENTRY*) ((uint8_t*)pN - offsetof(struct _TAG_ARP_HASH_ENTRY, next));
        if( (arpMod.timeSeconds - pE->tInsert) >= arpMod.entryPendingTmo)
   1f150:	4908      	ldr	r1, [pc, #32]	; (1f174 <TCPIP_ARP_HashEntryDelete+0x2c>)
   1f152:	694b      	ldr	r3, [r1, #20]
   1f154:	6892      	ldr	r2, [r2, #8]
   1f156:	1a9b      	subs	r3, r3, r2
   1f158:	6b8a      	ldr	r2, [r1, #56]	; 0x38
   1f15a:	4293      	cmp	r3, r2
   1f15c:	d301      	bcc.n	1f162 <TCPIP_ARP_HashEntryDelete+0x1a>
        {   // we remove this one
            pRemList = &pArpDcpt->incompleteList;
   1f15e:	302c      	adds	r0, #44	; 0x2c
        }
    }

    if(pRemList == 0)
   1f160:	e000      	b.n	1f164 <TCPIP_ARP_HashEntryDelete+0x1c>
    {   // no luck with the incomplete list; use the complete one
            pRemList = &pArpDcpt->completeList;
   1f162:	3018      	adds	r0, #24
    }

    pN = TCPIP_Helper_ProtectedSingleListHeadRemove(pRemList);
   1f164:	f000 fbc6 	bl	1f8f4 <TCPIP_Helper_ProtectedSingleListHeadRemove>

    if(pN)
   1f168:	4603      	mov	r3, r0
   1f16a:	b100      	cbz	r0, 1f16e <TCPIP_ARP_HashEntryDelete+0x26>
    {
        pE = (ARP_HASH_ENTRY*) ((uint8_t*)pN - offsetof(struct _TAG_ARP_HASH_ENTRY, next));
        return &pE->hEntry;    
   1f16c:	1f03      	subs	r3, r0, #4

    // it's possible to be unable to make room in the cache
    // for example, too many permanent entries added...
                   
    return 0;
}
   1f16e:	4618      	mov	r0, r3
   1f170:	bd08      	pop	{r3, pc}
   1f172:	bf00      	nop
   1f174:	2000dfa4 	.word	0x2000dfa4

Disassembly of section .rodata.iperfCmdTbl%708:

0001f178 <iperfCmdTbl>:
   1f178:	000061c0 00007661 000061c8 000061e0     .a..av...a...a..
   1f188:	000167c9 000061e8 000061fc 00012491     .g...a...a...$..
   1f198:	00006204 00006228 00010619 00006230     .b..(b......0b..

Disassembly of section .text.TCPIP_IPV4_CheckPktTx%709:

0001f1a8 <TCPIP_IPV4_CheckPktTx>:
{
   1f1a8:	b538      	push	{r3, r4, r5, lr}
    if(pPkt->next == 0)
   1f1aa:	680d      	ldr	r5, [r1, #0]
   1f1ac:	b115      	cbz	r5, 1f1b4 <TCPIP_IPV4_CheckPktTx+0xc>
    TCPIP_NET_IF* pNetIf = 0;
   1f1ae:	2300      	movs	r3, #0
}
   1f1b0:	4618      	mov	r0, r3
   1f1b2:	bd38      	pop	{r3, r4, r5, pc}
   1f1b4:	460c      	mov	r4, r1
        if((pNetIf = _TCPIPStackHandleToNetLinked(hNet)) != 0)
   1f1b6:	f001 fcab 	bl	20b10 <_TCPIPStackHandleToNetLinked>
   1f1ba:	4603      	mov	r3, r0
   1f1bc:	2800      	cmp	r0, #0
   1f1be:	d0f7      	beq.n	1f1b0 <TCPIP_IPV4_CheckPktTx+0x8>
    return pNetIf->Flags.bInConfig != 0;
   1f1c0:	f890 2043 	ldrb.w	r2, [r0, #67]	; 0x43
            if(_TCPIPStackIsConfig(pNetIf) && (pPkt->pktFlags & TCPIP_MAC_PKT_FLAG_CONFIG) == 0)
   1f1c4:	f012 0f10 	tst.w	r2, #16
   1f1c8:	d0f2      	beq.n	1f1b0 <TCPIP_IPV4_CheckPktTx+0x8>
   1f1ca:	f9b4 2022 	ldrsh.w	r2, [r4, #34]	; 0x22
                pNetIf = 0;
   1f1ce:	ea13 0322 	ands.w	r3, r3, r2, asr #32
   1f1d2:	bf38      	it	cc
   1f1d4:	462b      	movcc	r3, r5
   1f1d6:	e7eb      	b.n	1f1b0 <TCPIP_IPV4_CheckPktTx+0x8>

Disassembly of section .text.fnv_32_hash%710:

0001f1d8 <fnv_32_hash>:

#include "tcpip/src/hash_fnv.h"


uint32_t fnv_32_hash(const void *key, size_t keyLen)
{
   1f1d8:	4602      	mov	r2, r0
    size_t      ix;
    uint32_t    hval = FNV_32_INIT;
    
    const uint8_t* p = (const uint8_t*)key;

    for(ix = 0; ix < keyLen; ix++)
   1f1da:	b189      	cbz	r1, 1f200 <fnv_32_hash+0x28>
   1f1dc:	1841      	adds	r1, r0, r1
    uint32_t    hval = FNV_32_INIT;
   1f1de:	4809      	ldr	r0, [pc, #36]	; (1f204 <fnv_32_hash+0x2c>)
    {
#if defined(NO_FNV_GCC_OPTIMIZATION)
        hval *= FNV_32_PRIME;
#else
        hval += (hval<<1) + (hval<<4) + (hval<<7) + (hval<<8) + (hval<<24);
   1f1e0:	0103      	lsls	r3, r0, #4
   1f1e2:	eb03 0340 	add.w	r3, r3, r0, lsl #1
   1f1e6:	4403      	add	r3, r0
   1f1e8:	eb03 13c0 	add.w	r3, r3, r0, lsl #7
   1f1ec:	eb03 2300 	add.w	r3, r3, r0, lsl #8
   1f1f0:	eb03 6300 	add.w	r3, r3, r0, lsl #24
#endif
        hval ^= (uint32_t)*p++;
   1f1f4:	f812 0b01 	ldrb.w	r0, [r2], #1
   1f1f8:	4058      	eors	r0, r3
    for(ix = 0; ix < keyLen; ix++)
   1f1fa:	4291      	cmp	r1, r2
   1f1fc:	d1f0      	bne.n	1f1e0 <fnv_32_hash+0x8>
   1f1fe:	4770      	bx	lr
    uint32_t    hval = FNV_32_INIT;
   1f200:	4800      	ldr	r0, [pc, #0]	; (1f204 <fnv_32_hash+0x2c>)
    }
    return hval;
}
   1f202:	4770      	bx	lr
   1f204:	811c9dc5 	.word	0x811c9dc5

Disassembly of section .text.TCPIP_OAHASH_EntriesRemoveAll%711:

0001f208 <TCPIP_OAHASH_EntriesRemoveAll>:
    pBkt = (OA_HASH_ENTRY*)pOH->memBlk;
   1f208:	6803      	ldr	r3, [r0, #0]
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   1f20a:	68c2      	ldr	r2, [r0, #12]
   1f20c:	b19a      	cbz	r2, 1f236 <TCPIP_OAHASH_EntriesRemoveAll+0x2e>
   1f20e:	2200      	movs	r2, #0
   1f210:	e005      	b.n	1f21e <TCPIP_OAHASH_EntriesRemoveAll+0x16>
        pBkt = (OA_HASH_ENTRY*)((uint8_t*)pBkt + pOH->hEntrySize);
   1f212:	6881      	ldr	r1, [r0, #8]
   1f214:	440b      	add	r3, r1
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   1f216:	3201      	adds	r2, #1
   1f218:	68c1      	ldr	r1, [r0, #12]
   1f21a:	4291      	cmp	r1, r2
   1f21c:	d90b      	bls.n	1f236 <TCPIP_OAHASH_EntriesRemoveAll+0x2e>
        if(pBkt->flags.busy)
   1f21e:	7819      	ldrb	r1, [r3, #0]
   1f220:	f011 0f01 	tst.w	r1, #1
   1f224:	d0f5      	beq.n	1f212 <TCPIP_OAHASH_EntriesRemoveAll+0xa>
        pOE->flags.busy = 0;
   1f226:	7819      	ldrb	r1, [r3, #0]
   1f228:	f36f 0100 	bfc	r1, #0, #1
   1f22c:	7019      	strb	r1, [r3, #0]
        pOH->fullSlots--;
   1f22e:	6a41      	ldr	r1, [r0, #36]	; 0x24
   1f230:	3901      	subs	r1, #1
   1f232:	6241      	str	r1, [r0, #36]	; 0x24
   1f234:	e7ed      	b.n	1f212 <TCPIP_OAHASH_EntriesRemoveAll+0xa>
}
   1f236:	4770      	bx	lr

Disassembly of section .text.TCPIP_Helper_StringToPowerMode%712:

0001f238 <TCPIP_Helper_StringToPowerMode>:
    if(str)
   1f238:	b188      	cbz	r0, 1f25e <TCPIP_Helper_StringToPowerMode+0x26>
{
   1f23a:	b570      	push	{r4, r5, r6, lr}
   1f23c:	4605      	mov	r5, r0
        pEntry = TCPIP_MAC_POWER_TBL + 0;
   1f23e:	4c09      	ldr	r4, [pc, #36]	; (1f264 <TCPIP_Helper_StringToPowerMode+0x2c>)
        for(pwrIx = 0; pwrIx < sizeof(TCPIP_MAC_POWER_TBL)/sizeof(*TCPIP_MAC_POWER_TBL); pwrIx++, pEntry++)
   1f240:	f104 0620 	add.w	r6, r4, #32
   1f244:	3408      	adds	r4, #8
   1f246:	42b4      	cmp	r4, r6
   1f248:	d00a      	beq.n	1f260 <TCPIP_Helper_StringToPowerMode+0x28>
            if(pEntry->pwrName)
   1f24a:	6861      	ldr	r1, [r4, #4]
   1f24c:	2900      	cmp	r1, #0
   1f24e:	d0f9      	beq.n	1f244 <TCPIP_Helper_StringToPowerMode+0xc>
                if(!strcmp(str, pEntry->pwrName))
   1f250:	4628      	mov	r0, r5
   1f252:	f002 fbe3 	bl	21a1c <strcmp>
   1f256:	2800      	cmp	r0, #0
   1f258:	d1f4      	bne.n	1f244 <TCPIP_Helper_StringToPowerMode+0xc>
                    return pEntry->pwrMode;
   1f25a:	7820      	ldrb	r0, [r4, #0]
   1f25c:	e001      	b.n	1f262 <TCPIP_Helper_StringToPowerMode+0x2a>
   1f25e:	4770      	bx	lr
    return TCPIP_MAC_POWER_NONE;
   1f260:	2000      	movs	r0, #0
}
   1f262:	bd70      	pop	{r4, r5, r6, pc}
   1f264:	00020ad0 	.word	0x00020ad0

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListDeinitialize%713:

0001f268 <TCPIP_Helper_ProtectedSingleListDeinitialize>:
    return pL->semValid;
}

void  TCPIP_Helper_ProtectedSingleListDeinitialize(PROTECTED_SINGLE_LIST* pL)
{
    if(pL->semValid)
   1f268:	7c03      	ldrb	r3, [r0, #16]
   1f26a:	b903      	cbnz	r3, 1f26e <TCPIP_Helper_ProtectedSingleListDeinitialize+0x6>
   1f26c:	4770      	bx	lr
{
   1f26e:	b570      	push	{r4, r5, r6, lr}
   1f270:	4604      	mov	r4, r0
    {
        if (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
   1f272:	f100 060c 	add.w	r6, r0, #12
   1f276:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1f27a:	4630      	mov	r0, r6
   1f27c:	f001 fd92 	bl	20da4 <OSAL_SEM_Pend>
        {
            //SYS_DEBUG LOG
        }
        TCPIP_Helper_SingleListRemoveAll(&pL->list);
   1f280:	4625      	mov	r5, r4


// no memory de-allocation is performed, just removes the nodes from the list
static __inline__ void __attribute__((always_inline)) TCPIP_Helper_SingleListRemoveAll(SINGLE_LIST* pL)
{
	while((TCPIP_Helper_SingleListHeadRemove(pL)));
   1f282:	4628      	mov	r0, r5
   1f284:	f001 fe48 	bl	20f18 <TCPIP_Helper_SingleListHeadRemove>
   1f288:	2800      	cmp	r0, #0
   1f28a:	d1fa      	bne.n	1f282 <TCPIP_Helper_ProtectedSingleListDeinitialize+0x1a>
        OSAL_SEM_Delete(&pL->semaphore);
   1f28c:	4630      	mov	r0, r6
   1f28e:	f002 fbfd 	bl	21a8c <OSAL_SEM_Delete>
        pL->semValid = false;
   1f292:	2300      	movs	r3, #0
   1f294:	7423      	strb	r3, [r4, #16]
    }
}
   1f296:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListNodeRemove%714:

0001f298 <TCPIP_Helper_ProtectedSingleListNodeRemove>:

// removes a node anywhere in the list
// Note: this is lengthy!
// Use a double linked list if faster operation needed!
SGL_LIST_NODE*  TCPIP_Helper_ProtectedSingleListNodeRemove(PROTECTED_SINGLE_LIST* pL, SGL_LIST_NODE* pN)
{
   1f298:	b570      	push	{r4, r5, r6, lr}

    if(pL->semValid)
   1f29a:	7c03      	ldrb	r3, [r0, #16]
   1f29c:	b913      	cbnz	r3, 1f2a4 <TCPIP_Helper_ProtectedSingleListNodeRemove+0xc>
            //SYS_DEBUG LOG
        }
        return ret;
    }

    return 0;
   1f29e:	2400      	movs	r4, #0
}
   1f2a0:	4620      	mov	r0, r4
   1f2a2:	bd70      	pop	{r4, r5, r6, pc}
   1f2a4:	460d      	mov	r5, r1
   1f2a6:	4604      	mov	r4, r0
        if (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
   1f2a8:	f100 060c 	add.w	r6, r0, #12
   1f2ac:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1f2b0:	4630      	mov	r0, r6
   1f2b2:	f001 fd77 	bl	20da4 <OSAL_SEM_Pend>
        SGL_LIST_NODE * ret = TCPIP_Helper_SingleListNodeRemove(&pL->list, pN);
   1f2b6:	4629      	mov	r1, r5
   1f2b8:	4620      	mov	r0, r4
   1f2ba:	f7fe f874 	bl	1d3a6 <TCPIP_Helper_SingleListNodeRemove>
   1f2be:	4604      	mov	r4, r0
        if (OSAL_SEM_Post(&pL->semaphore) != OSAL_RESULT_TRUE)
   1f2c0:	4630      	mov	r0, r6
   1f2c2:	f002 f987 	bl	215d4 <OSAL_SEM_Post>
        return ret;
   1f2c6:	e7eb      	b.n	1f2a0 <TCPIP_Helper_ProtectedSingleListNodeRemove+0x8>

Disassembly of section .text.TCPIP_STACK_InitializeDataGet%715:

0001f2c8 <TCPIP_STACK_InitializeDataGet>:
    if(object != (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data)
   1f2c8:	4b09      	ldr	r3, [pc, #36]	; (1f2f0 <TCPIP_STACK_InitializeDataGet+0x28>)
   1f2ca:	4283      	cmp	r3, r0
   1f2cc:	d10c      	bne.n	1f2e8 <TCPIP_STACK_InitializeDataGet+0x20>
    if(pStackInit)
   1f2ce:	b169      	cbz	r1, 1f2ec <TCPIP_STACK_InitializeDataGet+0x24>
{
   1f2d0:	b430      	push	{r4, r5}
        *pStackInit = tcpip_init_data;
   1f2d2:	460c      	mov	r4, r1
   1f2d4:	4d07      	ldr	r5, [pc, #28]	; (1f2f4 <TCPIP_STACK_InitializeDataGet+0x2c>)
   1f2d6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1f2d8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1f2da:	e895 0003 	ldmia.w	r5, {r0, r1}
   1f2de:	e884 0003 	stmia.w	r4, {r0, r1}
    return true;
   1f2e2:	2001      	movs	r0, #1
}
   1f2e4:	bc30      	pop	{r4, r5}
   1f2e6:	4770      	bx	lr
        return false;
   1f2e8:	2000      	movs	r0, #0
   1f2ea:	4770      	bx	lr
    return true;
   1f2ec:	2001      	movs	r0, #1
}
   1f2ee:	4770      	bx	lr
   1f2f0:	2000e0f0 	.word	0x2000e0f0
   1f2f4:	2000e1fc 	.word	0x2000e1fc

Disassembly of section .text.TCPIP_PKT_Initialize%716:

0001f2f8 <TCPIP_PKT_Initialize>:
{
   1f2f8:	b510      	push	{r4, lr}
    pktMemH = 0;
   1f2fa:	4b0a      	ldr	r3, [pc, #40]	; (1f324 <TCPIP_PKT_Initialize+0x2c>)
   1f2fc:	2200      	movs	r2, #0
   1f2fe:	601a      	str	r2, [r3, #0]
    while(heapH != 0)
   1f300:	b150      	cbz	r0, 1f318 <TCPIP_PKT_Initialize+0x20>
   1f302:	4604      	mov	r4, r0
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
   1f304:	6843      	ldr	r3, [r0, #4]
   1f306:	2134      	movs	r1, #52	; 0x34
   1f308:	4798      	blx	r3
        if(allocPtr == 0)
   1f30a:	4601      	mov	r1, r0
   1f30c:	b120      	cbz	r0, 1f318 <TCPIP_PKT_Initialize+0x20>
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   1f30e:	68e3      	ldr	r3, [r4, #12]
   1f310:	4620      	mov	r0, r4
   1f312:	4798      	blx	r3
        pktMemH = heapH;
   1f314:	4b03      	ldr	r3, [pc, #12]	; (1f324 <TCPIP_PKT_Initialize+0x2c>)
   1f316:	601c      	str	r4, [r3, #0]
    return pktMemH != 0;
   1f318:	4b02      	ldr	r3, [pc, #8]	; (1f324 <TCPIP_PKT_Initialize+0x2c>)
   1f31a:	6818      	ldr	r0, [r3, #0]
}
   1f31c:	3000      	adds	r0, #0
   1f31e:	bf18      	it	ne
   1f320:	2001      	movne	r0, #1
   1f322:	bd10      	pop	{r4, pc}
   1f324:	2000e450 	.word	0x2000e450

Disassembly of section .text.TCPIP_UDP_Close%717:

0001f328 <TCPIP_UDP_Close>:
{
   1f328:	b538      	push	{r3, r4, r5, lr}
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1f32a:	f000 fe7b 	bl	20024 <_UDPSocketDcpt>
    if(pSkt)
   1f32e:	b908      	cbnz	r0, 1f334 <TCPIP_UDP_Close+0xc>
    return false;
   1f330:	2000      	movs	r0, #0
}
   1f332:	bd38      	pop	{r3, r4, r5, pc}
   1f334:	4604      	mov	r4, r0
    OSAL_SEM_Pend(&userSem, OSAL_WAIT_FOREVER);
   1f336:	4d07      	ldr	r5, [pc, #28]	; (1f354 <TCPIP_UDP_Close+0x2c>)
   1f338:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1f33c:	4628      	mov	r0, r5
   1f33e:	f001 fd31 	bl	20da4 <OSAL_SEM_Pend>
        _UDPClose(pSkt);
   1f342:	4620      	mov	r0, r4
   1f344:	f7fd fbf2 	bl	1cb2c <_UDPClose>
    OSAL_SEM_Post(&userSem);
   1f348:	4628      	mov	r0, r5
   1f34a:	f002 f943 	bl	215d4 <OSAL_SEM_Post>
        return true;
   1f34e:	2001      	movs	r0, #1
   1f350:	e7ef      	b.n	1f332 <TCPIP_UDP_Close+0xa>
   1f352:	bf00      	nop
   1f354:	2000e468 	.word	0x2000e468

Disassembly of section .text.SendCommandCharacter%718:

0001f358 <SendCommandCharacter>:
{
   1f358:	b500      	push	{lr}
   1f35a:	b083      	sub	sp, #12
   1f35c:	f88d 1007 	strb.w	r1, [sp, #7]
    if (SYS_CONSOLE_Status((SYS_MODULE_OBJ)_cmdInitData.consoleIndex) == SYS_STATUS_READY)
   1f360:	4b08      	ldr	r3, [pc, #32]	; (1f384 <SendCommandCharacter+0x2c>)
   1f362:	8858      	ldrh	r0, [r3, #2]
   1f364:	f7fd f9ea 	bl	1c73c <SYS_CONSOLE_Status>
   1f368:	2802      	cmp	r0, #2
   1f36a:	d002      	beq.n	1f372 <SendCommandCharacter+0x1a>
}
   1f36c:	b003      	add	sp, #12
   1f36e:	f85d fb04 	ldr.w	pc, [sp], #4
        SYS_CONSOLE_Write(_cmdInitData.consoleIndex, (const char*)&c, 1);
   1f372:	2201      	movs	r2, #1
   1f374:	f10d 0107 	add.w	r1, sp, #7
   1f378:	4b02      	ldr	r3, [pc, #8]	; (1f384 <SendCommandCharacter+0x2c>)
   1f37a:	8858      	ldrh	r0, [r3, #2]
   1f37c:	f7ff fcee 	bl	1ed5c <SYS_CONSOLE_Write>
}
   1f380:	e7f4      	b.n	1f36c <SendCommandCharacter+0x14>
   1f382:	bf00      	nop
   1f384:	2000e46c 	.word	0x2000e46c

Disassembly of section .text._keyEndProcess%719:

0001f388 <_keyEndProcess>:
    int nChars = pCmdIO->cmdEnd - pCmdIO->cmdPnt;
   1f388:	69c2      	ldr	r2, [r0, #28]
   1f38a:	6983      	ldr	r3, [r0, #24]
    if(nChars)
   1f38c:	1ad2      	subs	r2, r2, r3
   1f38e:	d010      	beq.n	1f3b2 <_keyEndProcess+0x2a>
{   // end key
   1f390:	b570      	push	{r4, r5, r6, lr}
   1f392:	b084      	sub	sp, #16
   1f394:	4604      	mov	r4, r0
    const SYS_CMD_API* pCmdApi = pCmdIO->devNode.pCmdApi;
   1f396:	6806      	ldr	r6, [r0, #0]
    const void* cmdIoParam = pCmdIO->devNode.cmdIoParam;
   1f398:	6845      	ldr	r5, [r0, #4]
        sprintf(endBuff, "\x1b[%dC", nChars);
   1f39a:	4906      	ldr	r1, [pc, #24]	; (1f3b4 <_keyEndProcess+0x2c>)
   1f39c:	a801      	add	r0, sp, #4
   1f39e:	f7fe fa03 	bl	1d7a8 <siprintf>
        (*pCmdApi->msg)(cmdIoParam, endBuff);
   1f3a2:	6833      	ldr	r3, [r6, #0]
   1f3a4:	a901      	add	r1, sp, #4
   1f3a6:	4628      	mov	r0, r5
   1f3a8:	4798      	blx	r3
        pCmdIO->cmdPnt = pCmdIO->cmdEnd;
   1f3aa:	69e3      	ldr	r3, [r4, #28]
   1f3ac:	61a3      	str	r3, [r4, #24]
}
   1f3ae:	b004      	add	sp, #16
   1f3b0:	bd70      	pop	{r4, r5, r6, pc}
   1f3b2:	4770      	bx	lr
   1f3b4:	0000d184 	.word	0x0000d184

Disassembly of section .text._keyHomeProcess%720:

0001f3b8 <_keyHomeProcess>:
{   // home key
   1f3b8:	b5f0      	push	{r4, r5, r6, r7, lr}
   1f3ba:	b085      	sub	sp, #20
    int nChars = pCmdIO->cmdPnt - pCmdIO->cmdBuff;
   1f3bc:	f100 0520 	add.w	r5, r0, #32
   1f3c0:	6982      	ldr	r2, [r0, #24]
    if(nChars != 0)
   1f3c2:	1b52      	subs	r2, r2, r5
   1f3c4:	d00b      	beq.n	1f3de <_keyHomeProcess+0x26>
   1f3c6:	4604      	mov	r4, r0
    const SYS_CMD_API* pCmdApi = pCmdIO->devNode.pCmdApi;
   1f3c8:	6807      	ldr	r7, [r0, #0]
    const void* cmdIoParam = pCmdIO->devNode.cmdIoParam;
   1f3ca:	6846      	ldr	r6, [r0, #4]
        sprintf(homeBuff, "\x1b[%dD", nChars);
   1f3cc:	4905      	ldr	r1, [pc, #20]	; (1f3e4 <_keyHomeProcess+0x2c>)
   1f3ce:	a801      	add	r0, sp, #4
   1f3d0:	f7fe f9ea 	bl	1d7a8 <siprintf>
        (*pCmdApi->msg)(cmdIoParam, homeBuff);
   1f3d4:	683b      	ldr	r3, [r7, #0]
   1f3d6:	a901      	add	r1, sp, #4
   1f3d8:	4630      	mov	r0, r6
   1f3da:	4798      	blx	r3
        pCmdIO->cmdPnt = pCmdIO->cmdBuff;
   1f3dc:	61a5      	str	r5, [r4, #24]
}
   1f3de:	b005      	add	sp, #20
   1f3e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f3e2:	bf00      	nop
   1f3e4:	0000d18c 	.word	0x0000d18c

Disassembly of section .text.SYS_CONSOLE_Message%721:

0001f3e8 <SYS_CONSOLE_Message>:

void SYS_CONSOLE_Message(const SYS_CONSOLE_HANDLE handle, const char *message)
{
    SYS_CONSOLE_OBJECT_INSTANCE* pConsoleObj = SYS_CONSOLE_GET_INSTANCE(handle);
   1f3e8:	b990      	cbnz	r0, 1f410 <SYS_CONSOLE_Message+0x28>
{
   1f3ea:	b538      	push	{r3, r4, r5, lr}
    if (pConsoleObj == NULL)
    {
        return;
    }

    if (pConsoleObj->status == SYS_STATUS_UNINITIALIZED || pConsoleObj->devDesc == NULL)
   1f3ec:	4b09      	ldr	r3, [pc, #36]	; (1f414 <SYS_CONSOLE_Message+0x2c>)
   1f3ee:	f993 3000 	ldrsb.w	r3, [r3]
   1f3f2:	b163      	cbz	r3, 1f40e <SYS_CONSOLE_Message+0x26>
   1f3f4:	4b07      	ldr	r3, [pc, #28]	; (1f414 <SYS_CONSOLE_Message+0x2c>)
   1f3f6:	685d      	ldr	r5, [r3, #4]
   1f3f8:	b14d      	cbz	r5, 1f40e <SYS_CONSOLE_Message+0x26>
   1f3fa:	460c      	mov	r4, r1
    {
        return;
    }

    pConsoleObj->devDesc->write(pConsoleObj->devIndex, message, strlen(message));
   1f3fc:	4608      	mov	r0, r1
   1f3fe:	f002 fc55 	bl	21cac <strlen>
   1f402:	696b      	ldr	r3, [r5, #20]
   1f404:	4602      	mov	r2, r0
   1f406:	4621      	mov	r1, r4
   1f408:	4802      	ldr	r0, [pc, #8]	; (1f414 <SYS_CONSOLE_Message+0x2c>)
   1f40a:	6880      	ldr	r0, [r0, #8]
   1f40c:	4798      	blx	r3
}
   1f40e:	bd38      	pop	{r3, r4, r5, pc}
   1f410:	4770      	bx	lr
   1f412:	bf00      	nop
   1f414:	2000e340 	.word	0x2000e340

Disassembly of section .text.SYS_TIME_UpdateTimerList%722:

0001f418 <SYS_TIME_UpdateTimerList>:
    tmr = counterObj->tmrActive;
   1f418:	4b0a      	ldr	r3, [pc, #40]	; (1f444 <SYS_TIME_UpdateTimerList+0x2c>)
   1f41a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    while ((tmr != NULL) && (elapsedCount > 0))
   1f41c:	b173      	cbz	r3, 1f43c <SYS_TIME_UpdateTimerList+0x24>
   1f41e:	b168      	cbz	r0, 1f43c <SYS_TIME_UpdateTimerList+0x24>
            tmr->relativeTimePending = 0;
   1f420:	2100      	movs	r1, #0
   1f422:	e005      	b.n	1f430 <SYS_TIME_UpdateTimerList+0x18>
            elapsedCount -= tmr->relativeTimePending;
   1f424:	689a      	ldr	r2, [r3, #8]
   1f426:	1a80      	subs	r0, r0, r2
            tmr->relativeTimePending = 0;
   1f428:	6099      	str	r1, [r3, #8]
        tmr = tmr->tmrNext;
   1f42a:	699b      	ldr	r3, [r3, #24]
    while ((tmr != NULL) && (elapsedCount > 0))
   1f42c:	b133      	cbz	r3, 1f43c <SYS_TIME_UpdateTimerList+0x24>
   1f42e:	b128      	cbz	r0, 1f43c <SYS_TIME_UpdateTimerList+0x24>
        if (tmr->relativeTimePending >= elapsedCount)
   1f430:	689a      	ldr	r2, [r3, #8]
   1f432:	4282      	cmp	r2, r0
   1f434:	d3f6      	bcc.n	1f424 <SYS_TIME_UpdateTimerList+0xc>
            tmr->relativeTimePending -= elapsedCount;
   1f436:	689a      	ldr	r2, [r3, #8]
   1f438:	1a10      	subs	r0, r2, r0
   1f43a:	6098      	str	r0, [r3, #8]
    counterObj->hwTimerPreviousValue = counterObj->hwTimerCurrentValue;
   1f43c:	4b01      	ldr	r3, [pc, #4]	; (1f444 <SYS_TIME_UpdateTimerList+0x2c>)
   1f43e:	695a      	ldr	r2, [r3, #20]
   1f440:	611a      	str	r2, [r3, #16]
}
   1f442:	4770      	bx	lr
   1f444:	2000e030 	.word	0x2000e030

Disassembly of section .text.xQueueGenericCreate%723:

0001f448 <xQueueGenericCreate>:
	{
   1f448:	b570      	push	{r4, r5, r6, lr}
   1f44a:	4606      	mov	r6, r0
   1f44c:	460d      	mov	r5, r1
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1f44e:	fb01 f000 	mul.w	r0, r1, r0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
   1f452:	3048      	adds	r0, #72	; 0x48
   1f454:	f7fb fb58 	bl	1ab08 <pvPortMalloc>
		if( pxNewQueue != NULL )
   1f458:	4604      	mov	r4, r0
   1f45a:	b148      	cbz	r0, 1f470 <xQueueGenericCreate+0x28>
	if( uxItemSize == ( UBaseType_t ) 0 )
   1f45c:	b155      	cbz	r5, 1f474 <xQueueGenericCreate+0x2c>
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
   1f45e:	f100 0348 	add.w	r3, r0, #72	; 0x48
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
   1f462:	6023      	str	r3, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
   1f464:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
   1f466:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
   1f468:	2101      	movs	r1, #1
   1f46a:	4620      	mov	r0, r4
   1f46c:	f7fb f8f6 	bl	1a65c <xQueueGenericReset>
	}
   1f470:	4620      	mov	r0, r4
   1f472:	bd70      	pop	{r4, r5, r6, pc}
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
   1f474:	4603      	mov	r3, r0
   1f476:	e7f4      	b.n	1f462 <xQueueGenericCreate+0x1a>

Disassembly of section .text.wc_CryptoCb_FindDevice%724:

0001f478 <wc_CryptoCb_FindDevice>:
        if (gCryptoDev[i].devId == devId)
   1f478:	4b0a      	ldr	r3, [pc, #40]	; (1f4a4 <wc_CryptoCb_FindDevice+0x2c>)
   1f47a:	681b      	ldr	r3, [r3, #0]
   1f47c:	4298      	cmp	r0, r3
   1f47e:	d00a      	beq.n	1f496 <wc_CryptoCb_FindDevice+0x1e>
   1f480:	4a08      	ldr	r2, [pc, #32]	; (1f4a4 <wc_CryptoCb_FindDevice+0x2c>)
    for (i=0; i<MAX_CRYPTO_DEVID_CALLBACKS; i++) {
   1f482:	2301      	movs	r3, #1
        if (gCryptoDev[i].devId == devId)
   1f484:	68d1      	ldr	r1, [r2, #12]
   1f486:	4281      	cmp	r1, r0
   1f488:	d006      	beq.n	1f498 <wc_CryptoCb_FindDevice+0x20>
    for (i=0; i<MAX_CRYPTO_DEVID_CALLBACKS; i++) {
   1f48a:	3301      	adds	r3, #1
   1f48c:	320c      	adds	r2, #12
   1f48e:	2b08      	cmp	r3, #8
   1f490:	d1f8      	bne.n	1f484 <wc_CryptoCb_FindDevice+0xc>
    return NULL;
   1f492:	2000      	movs	r0, #0
}
   1f494:	4770      	bx	lr
    for (i=0; i<MAX_CRYPTO_DEVID_CALLBACKS; i++) {
   1f496:	2300      	movs	r3, #0
            return &gCryptoDev[i];
   1f498:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1f49c:	4801      	ldr	r0, [pc, #4]	; (1f4a4 <wc_CryptoCb_FindDevice+0x2c>)
   1f49e:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   1f4a2:	4770      	bx	lr
   1f4a4:	2000dee4 	.word	0x2000dee4

Disassembly of section .rodata.seedA_data%725:

0001f4a8 <seedA_data>:
   1f4a8:	77333663 46861ee4 b40aeb8d 3f68eda8     c63w...F......h?
   1f4b8:	474e136a 00c714e0 e9814e45 69a55853     j.NG....EN..SX.i
   1f4c8:	8fa38a80 23a6722a 9f5a9159 68ca048a     ....*r.#Y.Z....h

Disassembly of section .rodata.seedB_data%726:

0001f4d8 <seedB_data>:
   1f4d8:	f3d05aa6 0e4edb45 c375e8ff 421fe7a2     .Z..E.N...u....B
   1f4e8:	629d12c7 19c1f50f f055efa9 fbe08551     ...b......U.Q...
   1f4f8:	31f98185 6e271775 7d60e906 2ecccbdb     ...1u.'n..`}....

Disassembly of section .text%727:

0001f508 <__aeabi_uldivmod>:
   1f508:	b953      	cbnz	r3, 1f520 <__aeabi_uldivmod+0x18>
   1f50a:	b94a      	cbnz	r2, 1f520 <__aeabi_uldivmod+0x18>
   1f50c:	2900      	cmp	r1, #0
   1f50e:	bf08      	it	eq
   1f510:	2800      	cmpeq	r0, #0
   1f512:	bf1c      	itt	ne
   1f514:	f04f 31ff 	movne.w	r1, #4294967295
   1f518:	f04f 30ff 	movne.w	r0, #4294967295
   1f51c:	f002 bea6 	b.w	2226c <__aeabi_idiv0>
   1f520:	f1ad 0c08 	sub.w	ip, sp, #8
   1f524:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   1f528:	f7ec ff36 	bl	c398 <__udivmoddi4>
   1f52c:	f8dd e004 	ldr.w	lr, [sp, #4]
   1f530:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   1f534:	b004      	add	sp, #16
   1f536:	4770      	bx	lr

Disassembly of section .text._XtlEventsTcp2Eth%728:

0001f538 <_XtlEventsTcp2Eth>:
	eEvents |= (tcpEv&(TCPIP_MAC_EV_RX_DONE))? GMAC_EV_RXCOMPLETE:0;	
   1f538:	10c3      	asrs	r3, r0, #3
   1f53a:	f003 0302 	and.w	r3, r3, #2
	eEvents |= (tcpEv&(TCPIP_MAC_EV_RX_OVFLOW))? GMAC_EV_RXOVERRUN:0;
   1f53e:	0242      	lsls	r2, r0, #9
   1f540:	f402 6280 	and.w	r2, r2, #1024	; 0x400
	eEvents |= (tcpEv&(TCPIP_MAC_EV_RX_BUFNA))? GMAC_EV_RXUSEDBITREAD:0; // mapping RX Used bit interrupt to BUFNA;
   1f544:	4313      	orrs	r3, r2
   1f546:	f000 0204 	and.w	r2, r0, #4
   1f54a:	4313      	orrs	r3, r2
	eEvents |= (tcpEv&(TCPIP_MAC_EV_TX_BUSERR))? GMAC_EV_TXFRAMECORRUPT:0;
   1f54c:	1102      	asrs	r2, r0, #4
   1f54e:	f002 0240 	and.w	r2, r2, #64	; 0x40
	eEvents |= (tcpEv&(TCPIP_MAC_EV_RX_BUFNA))? GMAC_EV_RXUSEDBITREAD:0; // mapping RX Used bit interrupt to BUFNA;
   1f552:	4313      	orrs	r3, r2
    eEvents |= (tcpEv&(TCPIP_MAC_EV_TX_ABORT))? GMAC_EV_TXUNDERRUN:0;
   1f554:	1142      	asrs	r2, r0, #5
   1f556:	f002 0210 	and.w	r2, r2, #16
	eEvents |= (tcpEv&(TCPIP_MAC_EV_RX_BUFNA))? GMAC_EV_RXUSEDBITREAD:0; // mapping RX Used bit interrupt to BUFNA;
   1f55a:	4313      	orrs	r3, r2
	eEvents = (tcpEv&(TCPIP_MAC_EV_TX_DONE))? GMAC_EV_TXCOMPLETE:0;	
   1f55c:	1040      	asrs	r0, r0, #1
   1f55e:	f000 0080 	and.w	r0, r0, #128	; 0x80
}
   1f562:	4318      	orrs	r0, r3
   1f564:	4770      	bx	lr

Disassembly of section .text._DRV_MIIM_GetObjectAndLock%729:

0001f566 <_DRV_MIIM_GetObjectAndLock>:
{
   1f566:	b510      	push	{r4, lr}
    if(pMiimObj != 0)
   1f568:	b168      	cbz	r0, 1f586 <_DRV_MIIM_GetObjectAndLock+0x20>
    pMiimObj = (DRV_MIIM_OBJ*)object;
   1f56a:	4604      	mov	r4, r0
        if(pMiimObj->objStatus == SYS_STATUS_READY && (pMiimObj->objFlags & DRV_MIIM_OBJ_FLAG_IN_USE) != 0)
   1f56c:	f990 2008 	ldrsb.w	r2, [r0, #8]
   1f570:	2a02      	cmp	r2, #2
   1f572:	d10a      	bne.n	1f58a <_DRV_MIIM_GetObjectAndLock+0x24>
   1f574:	8882      	ldrh	r2, [r0, #4]
   1f576:	f012 0f01 	tst.w	r2, #1
   1f57a:	d009      	beq.n	1f590 <_DRV_MIIM_GetObjectAndLock+0x2a>
    OSAL_SEM_Pend(&pMiimObj->objSem, OSAL_WAIT_FOREVER);
   1f57c:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1f580:	f001 fc10 	bl	20da4 <OSAL_SEM_Pend>
        return pMiimObj;
   1f584:	e002      	b.n	1f58c <_DRV_MIIM_GetObjectAndLock+0x26>
    return 0;
   1f586:	2400      	movs	r4, #0
   1f588:	e000      	b.n	1f58c <_DRV_MIIM_GetObjectAndLock+0x26>
   1f58a:	2400      	movs	r4, #0
}
   1f58c:	4620      	mov	r0, r4
   1f58e:	bd10      	pop	{r4, pc}
    return 0;
   1f590:	2400      	movs	r4, #0
   1f592:	e7fb      	b.n	1f58c <_DRV_MIIM_GetObjectAndLock+0x26>

Disassembly of section .text.DRV_MIIM_DeregisterCallback%730:

0001f594 <DRV_MIIM_DeregisterCallback>:
{
   1f594:	b510      	push	{r4, lr}
   1f596:	460c      	mov	r4, r1
        if((pClient = _DRV_MIIM_GetClientAndLock(handle, true)) == 0)
   1f598:	2101      	movs	r1, #1
   1f59a:	f7fd f96e 	bl	1c87a <_DRV_MIIM_GetClientAndLock>
   1f59e:	b150      	cbz	r0, 1f5b6 <DRV_MIIM_DeregisterCallback+0x22>
   1f5a0:	4603      	mov	r3, r0
        if(pClient->cbackHandler != (DRV_MIIM_OPERATION_CALLBACK)cbHandle)
   1f5a2:	6882      	ldr	r2, [r0, #8]
   1f5a4:	42a2      	cmp	r2, r4
   1f5a6:	d109      	bne.n	1f5bc <DRV_MIIM_DeregisterCallback+0x28>
        pClient->cbackHandler = 0;
   1f5a8:	2400      	movs	r4, #0
   1f5aa:	6084      	str	r4, [r0, #8]
    OSAL_SEM_Post(&pMiimObj->objSem);
   1f5ac:	6858      	ldr	r0, [r3, #4]
   1f5ae:	f002 f811 	bl	215d4 <OSAL_SEM_Post>
}
   1f5b2:	4620      	mov	r0, r4
   1f5b4:	bd10      	pop	{r4, pc}
            res = DRV_MIIM_RES_HANDLE_ERR;
   1f5b6:	f04f 34ff 	mov.w	r4, #4294967295
   1f5ba:	e7fa      	b.n	1f5b2 <DRV_MIIM_DeregisterCallback+0x1e>
            res = DRV_MIIM_RES_CALLBACK_HANDLE_ERR;
   1f5bc:	f06f 0402 	mvn.w	r4, #2
   1f5c0:	e7f4      	b.n	1f5ac <DRV_MIIM_DeregisterCallback+0x18>

Disassembly of section .text.TCPIP_TCP_Connect%731:

0001f5c2 <TCPIP_TCP_Connect>:
{
   1f5c2:	b510      	push	{r4, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   1f5c4:	f000 fc2a 	bl	1fe1c <_TcpSocketChk>
    if(pSkt && pSkt->smState == TCPIP_TCP_STATE_CLIENT_WAIT_CONNECT)
   1f5c8:	b180      	cbz	r0, 1f5ec <TCPIP_TCP_Connect+0x2a>
   1f5ca:	4604      	mov	r4, r0
   1f5cc:	f890 306e 	ldrb.w	r3, [r0, #110]	; 0x6e
   1f5d0:	2b0b      	cmp	r3, #11
   1f5d2:	d001      	beq.n	1f5d8 <TCPIP_TCP_Connect+0x16>
    return false;
   1f5d4:	2000      	movs	r0, #0
}
   1f5d6:	bd10      	pop	{r4, pc}
        if(_TcpClientSocketConnect(pSkt) >= 0)
   1f5d8:	f7fc f9a6 	bl	1b928 <_TcpClientSocketConnect>
   1f5dc:	2800      	cmp	r0, #0
   1f5de:	da01      	bge.n	1f5e4 <TCPIP_TCP_Connect+0x22>
    return false;
   1f5e0:	2000      	movs	r0, #0
   1f5e2:	e7f8      	b.n	1f5d6 <TCPIP_TCP_Connect+0x14>
    pSkt->smState = newState;
   1f5e4:	2001      	movs	r0, #1
   1f5e6:	f884 006e 	strb.w	r0, [r4, #110]	; 0x6e
            return true;
   1f5ea:	e7f4      	b.n	1f5d6 <TCPIP_TCP_Connect+0x14>
    return false;
   1f5ec:	2000      	movs	r0, #0
   1f5ee:	e7f2      	b.n	1f5d6 <TCPIP_TCP_Connect+0x14>

Disassembly of section .text._DHCPOptionProcessLease%732:

0001f5f0 <_DHCPOptionProcessLease>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_LEASE_TIME))
   1f5f0:	684b      	ldr	r3, [r1, #4]
   1f5f2:	2b05      	cmp	r3, #5
   1f5f4:	d90d      	bls.n	1f612 <_DHCPOptionProcessLease+0x22>
        TCPIP_DHCP_OPTION_DATA_LEASE_TIME* pLease = (TCPIP_DHCP_OPTION_DATA_LEASE_TIME*)pOptData->pOpt;
   1f5f6:	680b      	ldr	r3, [r1, #0]
        if(pLease->len == sizeof(pLease->lease))
   1f5f8:	785a      	ldrb	r2, [r3, #1]
   1f5fa:	2a04      	cmp	r2, #4
   1f5fc:	d10c      	bne.n	1f618 <_DHCPOptionProcessLease+0x28>
            pOptData->leaseTime.v[3] = pLease->lease[0];
   1f5fe:	789a      	ldrb	r2, [r3, #2]
   1f600:	74ca      	strb	r2, [r1, #19]
            pOptData->leaseTime.v[2] = pLease->lease[1];
   1f602:	78da      	ldrb	r2, [r3, #3]
   1f604:	748a      	strb	r2, [r1, #18]
            pOptData->leaseTime.v[1] = pLease->lease[2];
   1f606:	791a      	ldrb	r2, [r3, #4]
   1f608:	744a      	strb	r2, [r1, #17]
            pOptData->leaseTime.v[0] = pLease->lease[3];
   1f60a:	795b      	ldrb	r3, [r3, #5]
   1f60c:	740b      	strb	r3, [r1, #16]
            return sizeof(TCPIP_DHCP_OPTION_DATA_LEASE_TIME);
   1f60e:	2006      	movs	r0, #6
   1f610:	4770      	bx	lr
    return -1;
   1f612:	f04f 30ff 	mov.w	r0, #4294967295
   1f616:	4770      	bx	lr
   1f618:	f04f 30ff 	mov.w	r0, #4294967295
}
   1f61c:	4770      	bx	lr

Disassembly of section .text._DHCPOptionProcessRenewT%733:

0001f61e <_DHCPOptionProcessRenewT>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_RENEW_TIME))
   1f61e:	684b      	ldr	r3, [r1, #4]
   1f620:	2b05      	cmp	r3, #5
   1f622:	d90d      	bls.n	1f640 <_DHCPOptionProcessRenewT+0x22>
        TCPIP_DHCP_OPTION_DATA_RENEW_TIME* pRenew = (TCPIP_DHCP_OPTION_DATA_RENEW_TIME*)pOptData->pOpt;
   1f624:	680b      	ldr	r3, [r1, #0]
        if(pRenew->len == sizeof(pRenew->tRenew))
   1f626:	785a      	ldrb	r2, [r3, #1]
   1f628:	2a04      	cmp	r2, #4
   1f62a:	d10c      	bne.n	1f646 <_DHCPOptionProcessRenewT+0x28>
            pOptData->renewTime.v[3] = pRenew->tRenew[0];
   1f62c:	789a      	ldrb	r2, [r3, #2]
   1f62e:	75ca      	strb	r2, [r1, #23]
            pOptData->renewTime.v[2] = pRenew->tRenew[1];
   1f630:	78da      	ldrb	r2, [r3, #3]
   1f632:	758a      	strb	r2, [r1, #22]
            pOptData->renewTime.v[1] = pRenew->tRenew[2];
   1f634:	791a      	ldrb	r2, [r3, #4]
   1f636:	754a      	strb	r2, [r1, #21]
            pOptData->renewTime.v[0] = pRenew->tRenew[3];
   1f638:	795b      	ldrb	r3, [r3, #5]
   1f63a:	750b      	strb	r3, [r1, #20]
            return sizeof(TCPIP_DHCP_OPTION_DATA_RENEW_TIME);
   1f63c:	2006      	movs	r0, #6
   1f63e:	4770      	bx	lr
    return -1;
   1f640:	f04f 30ff 	mov.w	r0, #4294967295
   1f644:	4770      	bx	lr
   1f646:	f04f 30ff 	mov.w	r0, #4294967295
}
   1f64a:	4770      	bx	lr

Disassembly of section .text._DHCPOptionProcessRebindT%734:

0001f64c <_DHCPOptionProcessRebindT>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_REBIND_TIME))
   1f64c:	684b      	ldr	r3, [r1, #4]
   1f64e:	2b05      	cmp	r3, #5
   1f650:	d90d      	bls.n	1f66e <_DHCPOptionProcessRebindT+0x22>
        TCPIP_DHCP_OPTION_DATA_REBIND_TIME* pRebind = (TCPIP_DHCP_OPTION_DATA_REBIND_TIME*)pOptData->pOpt;
   1f652:	680b      	ldr	r3, [r1, #0]
        if(pRebind->len == sizeof(pRebind->tRebind))
   1f654:	785a      	ldrb	r2, [r3, #1]
   1f656:	2a04      	cmp	r2, #4
   1f658:	d10c      	bne.n	1f674 <_DHCPOptionProcessRebindT+0x28>
            pOptData->rebindTime.v[3] = pRebind->tRebind[0];
   1f65a:	789a      	ldrb	r2, [r3, #2]
   1f65c:	76ca      	strb	r2, [r1, #27]
            pOptData->rebindTime.v[2] = pRebind->tRebind[1];
   1f65e:	78da      	ldrb	r2, [r3, #3]
   1f660:	768a      	strb	r2, [r1, #26]
            pOptData->rebindTime.v[1] = pRebind->tRebind[2];
   1f662:	791a      	ldrb	r2, [r3, #4]
   1f664:	764a      	strb	r2, [r1, #25]
            pOptData->rebindTime.v[0] = pRebind->tRebind[3];
   1f666:	795b      	ldrb	r3, [r3, #5]
   1f668:	760b      	strb	r3, [r1, #24]
            return sizeof(TCPIP_DHCP_OPTION_DATA_REBIND_TIME);
   1f66a:	2006      	movs	r0, #6
   1f66c:	4770      	bx	lr
    return -1;
   1f66e:	f04f 30ff 	mov.w	r0, #4294967295
   1f672:	4770      	bx	lr
   1f674:	f04f 30ff 	mov.w	r0, #4294967295
}
   1f678:	4770      	bx	lr

Disassembly of section .text._DHCPOptionClientId%735:

0001f67a <_DHCPOptionClientId>:
    if(pSendData->writeSpace >= sizeof(*pClientOpt))
   1f67a:	684b      	ldr	r3, [r1, #4]
   1f67c:	2b08      	cmp	r3, #8
   1f67e:	d910      	bls.n	1f6a2 <_DHCPOptionClientId+0x28>
        pClientOpt = (TCPIP_DHCP_OPTION_DATA_CLIENT_ID*)pSendData->pOpt;
   1f680:	680b      	ldr	r3, [r1, #0]
        pClientOpt->opt = TCPIP_DHCP_PARAM_REQUEST_CLIENT_ID;
   1f682:	223d      	movs	r2, #61	; 0x3d
   1f684:	701a      	strb	r2, [r3, #0]
        pClientOpt->len = sizeof(pClientOpt->cliId);
   1f686:	2207      	movs	r2, #7
   1f688:	705a      	strb	r2, [r3, #1]
        pClientOpt->cliId.type = TCPIP_BOOT_HW_TYPE;    // standard hardware address
   1f68a:	2201      	movs	r2, #1
   1f68c:	709a      	strb	r2, [r3, #2]
        memcpy(pClientOpt->cliId.id, _TCPIPStack_NetMACAddressGet(pNetIf), sizeof(pClientOpt->cliId.id));
   1f68e:	1cda      	adds	r2, r3, #3
    return pNetIf ? pNetIf->netMACAddr.v : 0;
   1f690:	b100      	cbz	r0, 1f694 <_DHCPOptionClientId+0x1a>
   1f692:	303c      	adds	r0, #60	; 0x3c
   1f694:	6801      	ldr	r1, [r0, #0]
   1f696:	f8c3 1003 	str.w	r1, [r3, #3]
   1f69a:	8883      	ldrh	r3, [r0, #4]
   1f69c:	8093      	strh	r3, [r2, #4]
        return sizeof(*pClientOpt);
   1f69e:	2009      	movs	r0, #9
   1f6a0:	4770      	bx	lr
    return -1;
   1f6a2:	f04f 30ff 	mov.w	r0, #4294967295
}
   1f6a6:	4770      	bx	lr

Disassembly of section .text._DHCPSetTimeout%736:

0001f6a8 <_DHCPSetTimeout>:
{
   1f6a8:	b570      	push	{r4, r5, r6, lr}
   1f6aa:	4606      	mov	r6, r0
    uint32_t sysFreq = SYS_TMR_TickCounterFrequencyGet();
   1f6ac:	f000 fd46 	bl	2013c <SYS_TMR_TickCounterFrequencyGet>
   1f6b0:	4604      	mov	r4, r0
    pClient->waitTicks = (pClient->dhcpTmo - TCPIP_DHCP_EXP_BACKOFF_FUZZ) * sysFreq + SYS_RANDOM_PseudoGet() % ((2 * TCPIP_DHCP_EXP_BACKOFF_FUZZ) * sysFreq);
   1f6b2:	f8b6 504c 	ldrh.w	r5, [r6, #76]	; 0x4c
   1f6b6:	3d01      	subs	r5, #1
   1f6b8:	fb00 f505 	mul.w	r5, r0, r5
   1f6bc:	f7fb fc66 	bl	1af8c <rand>
   1f6c0:	0064      	lsls	r4, r4, #1
   1f6c2:	fbb0 f3f4 	udiv	r3, r0, r4
   1f6c6:	fb03 0414 	mls	r4, r3, r4, r0
   1f6ca:	442c      	add	r4, r5
   1f6cc:	6034      	str	r4, [r6, #0]
    pClient->startWait = SYS_TMR_TickCountGet();
   1f6ce:	f000 fd0d 	bl	200ec <SYS_TMR_TickCountGet>
   1f6d2:	6070      	str	r0, [r6, #4]
}
   1f6d4:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text._DNS_CleanCacheEntry%737:

0001f6d6 <_DNS_CleanCacheEntry>:
    if(pDnsHE->hEntry.flags.busy)
   1f6d6:	780b      	ldrb	r3, [r1, #0]
   1f6d8:	f013 0f01 	tst.w	r3, #1
   1f6dc:	d011      	beq.n	1f702 <_DNS_CleanCacheEntry+0x2c>
{
   1f6de:	b510      	push	{r4, lr}
        if((pDnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) == 0)
   1f6e0:	880b      	ldrh	r3, [r1, #0]
   1f6e2:	f013 0f80 	tst.w	r3, #128	; 0x80
   1f6e6:	d102      	bne.n	1f6ee <_DNS_CleanCacheEntry+0x18>
            pDnsDcpt->unsolvedEntries--;
   1f6e8:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
   1f6ea:	3b01      	subs	r3, #1
   1f6ec:	84c3      	strh	r3, [r0, #38]	; 0x26
   1f6ee:	460c      	mov	r4, r1
        TCPIP_OAHASH_EntryRemove(pDnsDcpt->hashDcpt, &pDnsHE->hEntry);
   1f6f0:	6800      	ldr	r0, [r0, #0]
   1f6f2:	f001 ff0f 	bl	21514 <TCPIP_OAHASH_EntryRemove>
        pDnsHE->nIPv4Entries = pDnsHE->nIPv6Entries = 0;
   1f6f6:	2300      	movs	r3, #0
   1f6f8:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
   1f6fc:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
}
   1f700:	bd10      	pop	{r4, pc}
   1f702:	4770      	bx	lr

Disassembly of section .text._DNSClientCleanup%738:

0001f704 <_DNSClientCleanup>:
{
   1f704:	b510      	push	{r4, lr}
   1f706:	4604      	mov	r4, r0
    if(pDnsDcpt->dnsSocket != INVALID_UDP_SOCKET)
   1f708:	f9b0 0024 	ldrsh.w	r0, [r0, #36]	; 0x24
   1f70c:	f1b0 3fff 	cmp.w	r0, #4294967295
   1f710:	d109      	bne.n	1f726 <_DNSClientCleanup+0x22>
    if( pDnsDcpt->dnsSignalHandle)
   1f712:	68e0      	ldr	r0, [r4, #12]
   1f714:	b118      	cbz	r0, 1f71e <_DNSClientCleanup+0x1a>
       _TCPIPStackSignalHandlerDeregister( pDnsDcpt->dnsSignalHandle);
   1f716:	f002 fb0c 	bl	21d32 <_TCPIPStackSignalHandlerDeregister>
        pDnsDcpt->dnsSignalHandle = 0;
   1f71a:	2300      	movs	r3, #0
   1f71c:	60e3      	str	r3, [r4, #12]
    _DNS_DeleteHash(pDnsDcpt);
   1f71e:	4620      	mov	r0, r4
   1f720:	f7fc fd52 	bl	1c1c8 <_DNS_DeleteHash>
}
   1f724:	bd10      	pop	{r4, pc}
        TCPIP_UDP_Close(pDnsDcpt->dnsSocket);
   1f726:	f7ff fdff 	bl	1f328 <TCPIP_UDP_Close>
        pDnsDcpt->dnsSocket = INVALID_UDP_SOCKET;
   1f72a:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1f72e:	84a3      	strh	r3, [r4, #36]	; 0x24
   1f730:	e7ef      	b.n	1f712 <_DNSClientCleanup+0xe>

Disassembly of section .text.TCPIP_STACK_DNSServiceCanStart%739:

0001f732 <TCPIP_STACK_DNSServiceCanStart>:
    if(pNetIf)
   1f732:	b198      	cbz	r0, 1f75c <TCPIP_STACK_DNSServiceCanStart+0x2a>
        if(dnsSvcType == TCPIP_STACK_DNS_SERVICE_SERVER)
   1f734:	2902      	cmp	r1, #2
   1f736:	d003      	beq.n	1f740 <TCPIP_STACK_DNSServiceCanStart+0xe>
        else if(dnsSvcType == TCPIP_STACK_DNS_SERVICE_CLIENT)
   1f738:	2901      	cmp	r1, #1
   1f73a:	d008      	beq.n	1f74e <TCPIP_STACK_DNSServiceCanStart+0x1c>
    return false;
   1f73c:	2000      	movs	r0, #0
}
   1f73e:	4770      	bx	lr
            return (pNetIf->Flags.bIsDnsClientEnabled == 0);
   1f740:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
   1f744:	f080 0008 	eor.w	r0, r0, #8
   1f748:	f3c0 00c0 	ubfx	r0, r0, #3, #1
   1f74c:	4770      	bx	lr
            return (pNetIf->Flags.bIsDnsServerEnabled == 0);
   1f74e:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
   1f752:	f080 0010 	eor.w	r0, r0, #16
   1f756:	f3c0 1000 	ubfx	r0, r0, #4, #1
   1f75a:	4770      	bx	lr
    return false;
   1f75c:	2000      	movs	r0, #0
   1f75e:	4770      	bx	lr

Disassembly of section .text._TxSktGetLockedV4Pkt%740:

0001f760 <_TxSktGetLockedV4Pkt>:
{
   1f760:	b570      	push	{r4, r5, r6, lr}
   1f762:	4605      	mov	r5, r0
   1f764:	460e      	mov	r6, r1
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1f766:	2000      	movs	r0, #0
   1f768:	f001 ff28 	bl	215bc <OSAL_CRIT_Enter>
   1f76c:	4601      	mov	r1, r0
    if((pPkt = pSkt->pV4Pkt) != 0)
   1f76e:	68ec      	ldr	r4, [r5, #12]
   1f770:	b134      	cbz	r4, 1f780 <_TxSktGetLockedV4Pkt+0x20>
        if((pPkt->macPkt.pktFlags & TCPIP_MAC_PKT_FLAG_QUEUED) != 0)
   1f772:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   1f774:	f013 0f08 	tst.w	r3, #8
   1f778:	d002      	beq.n	1f780 <_TxSktGetLockedV4Pkt+0x20>
            if(clrSktPkt)
   1f77a:	b136      	cbz	r6, 1f78a <_TxSktGetLockedV4Pkt+0x2a>
                pSkt->pV4Pkt = 0;
   1f77c:	2400      	movs	r4, #0
   1f77e:	60ec      	str	r4, [r5, #12]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   1f780:	2000      	movs	r0, #0
   1f782:	f002 f84a 	bl	2181a <OSAL_CRIT_Leave>
}
   1f786:	4620      	mov	r0, r4
   1f788:	bd70      	pop	{r4, r5, r6, pc}
            pPkt = 0;
   1f78a:	2400      	movs	r4, #0
   1f78c:	e7f8      	b.n	1f780 <_TxSktGetLockedV4Pkt+0x20>

Disassembly of section .text.wc_CryptoCb_RegisterDevice%741:

0001f78e <wc_CryptoCb_RegisterDevice>:
{
   1f78e:	b570      	push	{r4, r5, r6, lr}
   1f790:	4606      	mov	r6, r0
   1f792:	460d      	mov	r5, r1
   1f794:	4614      	mov	r4, r2
    CryptoCb* dev = wc_CryptoCb_FindDevice(devId);
   1f796:	f7ff fe6f 	bl	1f478 <wc_CryptoCb_FindDevice>
    if (dev == NULL)
   1f79a:	4603      	mov	r3, r0
   1f79c:	b120      	cbz	r0, 1f7a8 <wc_CryptoCb_RegisterDevice+0x1a>
    dev->devId = devId;
   1f79e:	601e      	str	r6, [r3, #0]
    dev->cb = cb;
   1f7a0:	605d      	str	r5, [r3, #4]
    dev->ctx = ctx;
   1f7a2:	609c      	str	r4, [r3, #8]
    return 0;
   1f7a4:	2000      	movs	r0, #0
}
   1f7a6:	bd70      	pop	{r4, r5, r6, pc}
        dev = wc_CryptoCb_FindDevice(INVALID_DEVID);
   1f7a8:	f06f 0001 	mvn.w	r0, #1
   1f7ac:	f7ff fe64 	bl	1f478 <wc_CryptoCb_FindDevice>
    if (dev == NULL)
   1f7b0:	4603      	mov	r3, r0
   1f7b2:	2800      	cmp	r0, #0
   1f7b4:	d1f3      	bne.n	1f79e <wc_CryptoCb_RegisterDevice+0x10>
        return BUFFER_E; /* out of devices */
   1f7b6:	f06f 0083 	mvn.w	r0, #131	; 0x83
   1f7ba:	e7f4      	b.n	1f7a6 <wc_CryptoCb_RegisterDevice+0x18>

Disassembly of section .text.__sfputc_r%742:

0001f7bc <__sfputc_r>:
   1f7bc:	6893      	ldr	r3, [r2, #8]
   1f7be:	3b01      	subs	r3, #1
   1f7c0:	2b00      	cmp	r3, #0
   1f7c2:	b410      	push	{r4}
   1f7c4:	6093      	str	r3, [r2, #8]
   1f7c6:	da08      	bge.n	1f7da <__sfputc_r+0x1e>
   1f7c8:	6994      	ldr	r4, [r2, #24]
   1f7ca:	42a3      	cmp	r3, r4
   1f7cc:	db01      	blt.n	1f7d2 <__sfputc_r+0x16>
   1f7ce:	290a      	cmp	r1, #10
   1f7d0:	d103      	bne.n	1f7da <__sfputc_r+0x1e>
   1f7d2:	f85d 4b04 	ldr.w	r4, [sp], #4
   1f7d6:	f7f6 bf3b 	b.w	16650 <__swbuf_r>
   1f7da:	6813      	ldr	r3, [r2, #0]
   1f7dc:	1c58      	adds	r0, r3, #1
   1f7de:	6010      	str	r0, [r2, #0]
   1f7e0:	7019      	strb	r1, [r3, #0]
   1f7e2:	4608      	mov	r0, r1
   1f7e4:	f85d 4b04 	ldr.w	r4, [sp], #4
   1f7e8:	4770      	bx	lr

Disassembly of section .text._Bfree%743:

0001f7ea <_Bfree>:
   1f7ea:	b570      	push	{r4, r5, r6, lr}
   1f7ec:	6a44      	ldr	r4, [r0, #36]	; 0x24
   1f7ee:	4606      	mov	r6, r0
   1f7f0:	460d      	mov	r5, r1
   1f7f2:	b93c      	cbnz	r4, 1f804 <_Bfree+0x1a>
   1f7f4:	2010      	movs	r0, #16
   1f7f6:	f002 fa39 	bl	21c6c <malloc>
   1f7fa:	e9c0 4401 	strd	r4, r4, [r0, #4]
   1f7fe:	6270      	str	r0, [r6, #36]	; 0x24
   1f800:	6004      	str	r4, [r0, #0]
   1f802:	60c4      	str	r4, [r0, #12]
   1f804:	b13d      	cbz	r5, 1f816 <_Bfree+0x2c>
   1f806:	6a73      	ldr	r3, [r6, #36]	; 0x24
   1f808:	686a      	ldr	r2, [r5, #4]
   1f80a:	68db      	ldr	r3, [r3, #12]
   1f80c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   1f810:	6029      	str	r1, [r5, #0]
   1f812:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
   1f816:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.DRV_ETHPHY_Close%744:

0001f818 <DRV_ETHPHY_Close>:
    if(hClientObj != 0)
   1f818:	b188      	cbz	r0, 1f83e <DRV_ETHPHY_Close+0x26>
{
   1f81a:	b510      	push	{r4, lr}
   1f81c:	4604      	mov	r4, r0
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1f81e:	68c1      	ldr	r1, [r0, #12]
   1f820:	4a07      	ldr	r2, [pc, #28]	; (1f840 <DRV_ETHPHY_Close+0x28>)
   1f822:	4291      	cmp	r1, r2
   1f824:	d10a      	bne.n	1f83c <DRV_ETHPHY_Close+0x24>
            hClientObj->pMiimBase->DRV_MIIM_Close(hClientObj->miimHandle);
   1f826:	6903      	ldr	r3, [r0, #16]
   1f828:	69db      	ldr	r3, [r3, #28]
   1f82a:	6940      	ldr	r0, [r0, #20]
   1f82c:	4798      	blx	r3
            hClientObj->clientInUse = false ;
   1f82e:	2200      	movs	r2, #0
   1f830:	8022      	strh	r2, [r4, #0]
            hClientObj->hDriver->numClients--;
   1f832:	68e1      	ldr	r1, [r4, #12]
   1f834:	884b      	ldrh	r3, [r1, #2]
   1f836:	3b01      	subs	r3, #1
   1f838:	804b      	strh	r3, [r1, #2]
            hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_CLOSED;
   1f83a:	7222      	strb	r2, [r4, #8]
}
   1f83c:	bd10      	pop	{r4, pc}
   1f83e:	4770      	bx	lr
   1f840:	2000de18 	.word	0x2000de18

Disassembly of section .text.DRV_ETHPHY_VendorDataGet%745:

0001f844 <DRV_ETHPHY_VendorDataGet>:
    if(hClientObj != 0)
   1f844:	4603      	mov	r3, r0
   1f846:	b140      	cbz	r0, 1f85a <DRV_ETHPHY_VendorDataGet+0x16>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1f848:	68c0      	ldr	r0, [r0, #12]
   1f84a:	4a08      	ldr	r2, [pc, #32]	; (1f86c <DRV_ETHPHY_VendorDataGet+0x28>)
   1f84c:	4290      	cmp	r0, r2
   1f84e:	d107      	bne.n	1f860 <DRV_ETHPHY_VendorDataGet+0x1c>
            if(pVendorData)
   1f850:	b149      	cbz	r1, 1f866 <DRV_ETHPHY_VendorDataGet+0x22>
                *pVendorData = hClientObj->vendorData;
   1f852:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   1f854:	600b      	str	r3, [r1, #0]
            return DRV_ETHPHY_RES_OK;
   1f856:	2000      	movs	r0, #0
   1f858:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1f85a:	f06f 000a 	mvn.w	r0, #10
   1f85e:	4770      	bx	lr
   1f860:	f06f 000a 	mvn.w	r0, #10
   1f864:	4770      	bx	lr
            return DRV_ETHPHY_RES_OK;
   1f866:	2000      	movs	r0, #0
}
   1f868:	4770      	bx	lr
   1f86a:	bf00      	nop
   1f86c:	2000de18 	.word	0x2000de18

Disassembly of section .text.DRV_ETHPHY_Reinitialize%746:

0001f870 <DRV_ETHPHY_Reinitialize>:
{
   1f870:	b508      	push	{r3, lr}
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1f872:	4b09      	ldr	r3, [pc, #36]	; (1f898 <DRV_ETHPHY_Reinitialize+0x28>)
   1f874:	4283      	cmp	r3, r0
   1f876:	d10e      	bne.n	1f896 <DRV_ETHPHY_Reinitialize+0x26>
    if(phyInst != 0)
   1f878:	b168      	cbz	r0, 1f896 <DRV_ETHPHY_Reinitialize+0x26>
   1f87a:	460b      	mov	r3, r1
        phyInst->numClients = 0;
   1f87c:	4806      	ldr	r0, [pc, #24]	; (1f898 <DRV_ETHPHY_Reinitialize+0x28>)
   1f87e:	2100      	movs	r1, #0
   1f880:	8041      	strh	r1, [r0, #2]
        phyInst->status = SYS_STATUS_READY; // Set module state
   1f882:	2202      	movs	r2, #2
   1f884:	7102      	strb	r2, [r0, #4]
        phyInst->ethphyId = ethphyInit->ethphyId; // Store PLIB ID
   1f886:	685a      	ldr	r2, [r3, #4]
   1f888:	6082      	str	r2, [r0, #8]
        phyInst->pPhyObj = ethphyInit->pPhyObject;
   1f88a:	68db      	ldr	r3, [r3, #12]
   1f88c:	6143      	str	r3, [r0, #20]
        memset(phyInst->objClients, 0, sizeof(phyInst->objClients));
   1f88e:	2248      	movs	r2, #72	; 0x48
   1f890:	3018      	adds	r0, #24
   1f892:	f002 f9fb 	bl	21c8c <memset>
}
   1f896:	bd08      	pop	{r3, pc}
   1f898:	2000de18 	.word	0x2000de18

Disassembly of section .text._DRV_ETHPHY_LinkStatPhaseRefresh%747:

0001f89c <_DRV_ETHPHY_LinkStatPhaseRefresh>:
{
   1f89c:	b510      	push	{r4, lr}
   1f89e:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1f8a0:	f000 ff80 	bl	207a4 <_DRV_PHY_SMITransfer_Wait>
   1f8a4:	b178      	cbz	r0, 1f8c6 <_DRV_ETHPHY_LinkStatPhaseRefresh+0x2a>
    DRV_ETHPHY_LINK_STATUS* pLinkStat = (DRV_ETHPHY_LINK_STATUS*)hClientObj->operParam;
   1f8a6:	6b23      	ldr	r3, [r4, #48]	; 0x30
    if(pLinkStat)
   1f8a8:	b14b      	cbz	r3, 1f8be <_DRV_ETHPHY_LinkStatPhaseRefresh+0x22>
    linkStat = (phyStat.LINK_STAT)?DRV_ETHPHY_LINK_ST_UP:DRV_ETHPHY_LINK_ST_DOWN;
   1f8aa:	f894 103a 	ldrb.w	r1, [r4, #58]	; 0x3a
   1f8ae:	f3c1 0280 	ubfx	r2, r1, #2, #1
    if(phyStat.REM_FAULT)
   1f8b2:	f011 0f10 	tst.w	r1, #16
        linkStat|=DRV_ETHPHY_LINK_ST_REMOTE_FAULT;
   1f8b6:	bf18      	it	ne
   1f8b8:	f042 0204 	orrne.w	r2, r2, #4
        *pLinkStat = _Phy2LinkStat(phyStat);
   1f8bc:	801a      	strh	r2, [r3, #0]
    _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OK);
   1f8be:	2100      	movs	r1, #0
   1f8c0:	4620      	mov	r0, r4
   1f8c2:	f000 fa33 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
}
   1f8c6:	bd10      	pop	{r4, pc}

Disassembly of section .text._ARPRemoveEntry%748:

0001f8c8 <_ARPRemoveEntry>:
{
   1f8c8:	b538      	push	{r3, r4, r5, lr}
   1f8ca:	4605      	mov	r5, r0
   1f8cc:	460c      	mov	r4, r1
    if((hE->flags.value & ARP_FLAG_ENTRY_PERM) != 0 )
   1f8ce:	880b      	ldrh	r3, [r1, #0]
   1f8d0:	f013 0f40 	tst.w	r3, #64	; 0x40
   1f8d4:	d008      	beq.n	1f8e8 <_ARPRemoveEntry+0x20>
        remList =  &pArpDcpt->permList;
   1f8d6:	3004      	adds	r0, #4
    TCPIP_Helper_ProtectedSingleListNodeRemove(remList, (SGL_LIST_NODE*)&((ARP_HASH_ENTRY*)hE)->next);
   1f8d8:	1d21      	adds	r1, r4, #4
   1f8da:	f7ff fcdd 	bl	1f298 <TCPIP_Helper_ProtectedSingleListNodeRemove>
    TCPIP_OAHASH_EntryRemove(pArpDcpt->hashDcpt, hE);
   1f8de:	4621      	mov	r1, r4
   1f8e0:	6828      	ldr	r0, [r5, #0]
   1f8e2:	f001 fe17 	bl	21514 <TCPIP_OAHASH_EntryRemove>
}
   1f8e6:	bd38      	pop	{r3, r4, r5, pc}
    else if((hE->flags.value & ARP_FLAG_ENTRY_COMPLETE) != 0 )
   1f8e8:	f013 0f80 	tst.w	r3, #128	; 0x80
        remList =  &pArpDcpt->completeList;
   1f8ec:	bf14      	ite	ne
   1f8ee:	3018      	addne	r0, #24
        remList =  &pArpDcpt->incompleteList;
   1f8f0:	302c      	addeq	r0, #44	; 0x2c
   1f8f2:	e7f1      	b.n	1f8d8 <_ARPRemoveEntry+0x10>

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListHeadRemove%749:

0001f8f4 <TCPIP_Helper_ProtectedSingleListHeadRemove>:
{
   1f8f4:	b538      	push	{r3, r4, r5, lr}
    if(pL->semValid)
   1f8f6:	7c03      	ldrb	r3, [r0, #16]
   1f8f8:	b913      	cbnz	r3, 1f900 <TCPIP_Helper_ProtectedSingleListHeadRemove+0xc>
    return 0;
   1f8fa:	2400      	movs	r4, #0
}
   1f8fc:	4620      	mov	r0, r4
   1f8fe:	bd38      	pop	{r3, r4, r5, pc}
   1f900:	4604      	mov	r4, r0
        if (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
   1f902:	f100 050c 	add.w	r5, r0, #12
   1f906:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1f90a:	4628      	mov	r0, r5
   1f90c:	f001 fa4a 	bl	20da4 <OSAL_SEM_Pend>
        SGL_LIST_NODE * ret = TCPIP_Helper_SingleListHeadRemove(&pL->list);
   1f910:	4620      	mov	r0, r4
   1f912:	f001 fb01 	bl	20f18 <TCPIP_Helper_SingleListHeadRemove>
   1f916:	4604      	mov	r4, r0
        if (OSAL_SEM_Post(&pL->semaphore) != OSAL_RESULT_TRUE)
   1f918:	4628      	mov	r0, r5
   1f91a:	f001 fe5b 	bl	215d4 <OSAL_SEM_Post>
        return ret;
   1f91e:	e7ed      	b.n	1f8fc <TCPIP_Helper_ProtectedSingleListHeadRemove+0x8>

Disassembly of section .text.TCPIP_STACK_IsBcastAddress%750:

0001f920 <TCPIP_STACK_IsBcastAddress>:
{
   1f920:	b508      	push	{r3, lr}
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   1f922:	b188      	cbz	r0, 1f948 <TCPIP_STACK_IsBcastAddress+0x28>
   1f924:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1f928:	f012 0f40 	tst.w	r2, #64	; 0x40
   1f92c:	d101      	bne.n	1f932 <TCPIP_STACK_IsBcastAddress+0x12>
    return false;
   1f92e:	2000      	movs	r0, #0
}
   1f930:	bd08      	pop	{r3, pc}
       return (TCPIP_Helper_IsBcastAddress(pIpAdd) ||  TCPIP_STACK_NetIsBcastAddress(pNetIf, pIpAdd));
   1f932:	680a      	ldr	r2, [r1, #0]
   1f934:	f1b2 3fff 	cmp.w	r2, #4294967295
   1f938:	d004      	beq.n	1f944 <TCPIP_STACK_IsBcastAddress+0x24>
   1f93a:	f000 fb4b 	bl	1ffd4 <TCPIP_STACK_NetIsBcastAddress>
   1f93e:	f000 0001 	and.w	r0, r0, #1
   1f942:	e7f5      	b.n	1f930 <TCPIP_STACK_IsBcastAddress+0x10>
   1f944:	2001      	movs	r0, #1
   1f946:	e7fa      	b.n	1f93e <TCPIP_STACK_IsBcastAddress+0x1e>
    return false;
   1f948:	2000      	movs	r0, #0
   1f94a:	e7f1      	b.n	1f930 <TCPIP_STACK_IsBcastAddress+0x10>

Disassembly of section .text._TCPIPStackModuleRxExtract%751:

0001f94c <_TCPIPStackModuleRxExtract>:
{
   1f94c:	b538      	push	{r3, r4, r5, lr}
   1f94e:	4604      	mov	r4, r0
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1f950:	2000      	movs	r0, #0
   1f952:	f001 fe33 	bl	215bc <OSAL_CRIT_Enter>
   1f956:	4605      	mov	r5, r0
    SINGLE_LIST* pQueue = TCPIP_MODULES_QUEUE_TBL + modId;
   1f958:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    TCPIP_MAC_PACKET* pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(pQueue);
   1f95c:	4805      	ldr	r0, [pc, #20]	; (1f974 <_TCPIPStackModuleRxExtract+0x28>)
   1f95e:	eb00 0084 	add.w	r0, r0, r4, lsl #2
   1f962:	f001 fad9 	bl	20f18 <TCPIP_Helper_SingleListHeadRemove>
   1f966:	4604      	mov	r4, r0
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1f968:	4629      	mov	r1, r5
   1f96a:	2000      	movs	r0, #0
   1f96c:	f001 ff55 	bl	2181a <OSAL_CRIT_Leave>
}
   1f970:	4620      	mov	r0, r4
   1f972:	bd38      	pop	{r3, r4, r5, pc}
   1f974:	2000dc84 	.word	0x2000dc84

Disassembly of section .text._TCPIP_PKT_SocketAlloc%752:

0001f978 <_TCPIP_PKT_SocketAlloc>:
{
   1f978:	b538      	push	{r3, r4, r5, lr}
   1f97a:	460c      	mov	r4, r1
    if((flags & TCPIP_MAC_PKT_FLAG_IPV6) != 0)
   1f97c:	f403 7100 	and.w	r1, r3, #512	; 0x200
        netHdrLen = sizeof(IPV4_HEADER);
   1f980:	2900      	cmp	r1, #0
   1f982:	bf14      	ite	ne
   1f984:	2528      	movne	r5, #40	; 0x28
   1f986:	2514      	moveq	r5, #20
    pPkt = _TCPIP_PKT_PacketAlloc(pktLen, totHdrLen +  payloadLen, flags );
   1f988:	4422      	add	r2, r4
   1f98a:	18a9      	adds	r1, r5, r2
   1f98c:	461a      	mov	r2, r3
   1f98e:	b289      	uxth	r1, r1
   1f990:	f7f9 fb80 	bl	19094 <_TCPIP_PKT_PacketAlloc>
    if(pPkt)
   1f994:	4603      	mov	r3, r0
   1f996:	b118      	cbz	r0, 1f9a0 <_TCPIP_PKT_SocketAlloc+0x28>
        if(transpHdrLen)
   1f998:	b114      	cbz	r4, 1f9a0 <_TCPIP_PKT_SocketAlloc+0x28>
            pPkt->pTransportLayer = pPkt->pNetLayer + netHdrLen;
   1f99a:	6982      	ldr	r2, [r0, #24]
   1f99c:	4415      	add	r5, r2
   1f99e:	61c5      	str	r5, [r0, #28]
}
   1f9a0:	4618      	mov	r0, r3
   1f9a2:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text._UDPFreeTxResources%753:

0001f9a4 <_UDPFreeTxResources>:
{
   1f9a4:	b510      	push	{r4, lr}
   1f9a6:	4604      	mov	r4, r0
    switch(pSkt->addType)
   1f9a8:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
   1f9aa:	2b01      	cmp	r3, #1
   1f9ac:	d002      	beq.n	1f9b4 <_UDPFreeTxResources+0x10>
    pSkt->pPkt = 0;
   1f9ae:	2300      	movs	r3, #0
   1f9b0:	60e3      	str	r3, [r4, #12]
}
   1f9b2:	bd10      	pop	{r4, pc}
            pCurrPkt = _TxSktGetLockedV4Pkt(pSkt, true);
   1f9b4:	2101      	movs	r1, #1
   1f9b6:	f7ff fed3 	bl	1f760 <_TxSktGetLockedV4Pkt>
            if(pCurrPkt)
   1f9ba:	2800      	cmp	r0, #0
   1f9bc:	d0f7      	beq.n	1f9ae <_UDPFreeTxResources+0xa>
                    TCPIP_PKT_PacketFree(pPkt);
   1f9be:	68e0      	ldr	r0, [r4, #12]
   1f9c0:	f7fe fc22 	bl	1e208 <_TCPIP_PKT_PacketFree>
        pSkt->txAllocCnt--;
   1f9c4:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
   1f9c8:	3b01      	subs	r3, #1
   1f9ca:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
   1f9ce:	e7ee      	b.n	1f9ae <_UDPFreeTxResources+0xa>

Disassembly of section .text.TC0_TimerInterruptHandler%754:

0001f9d0 <TC0_TimerInterruptHandler>:
    TC0_CallbackObject.context = context;
}

/* Timer Interrupt handler */
void TC0_TimerInterruptHandler( void )
{
   1f9d0:	b508      	push	{r3, lr}
    if (TC0_REGS->COUNT16.TC_INTENSET != 0U)
   1f9d2:	4b08      	ldr	r3, [pc, #32]	; (1f9f4 <TC0_TimerInterruptHandler+0x24>)
   1f9d4:	7a5b      	ldrb	r3, [r3, #9]
   1f9d6:	b163      	cbz	r3, 1f9f2 <TC0_TimerInterruptHandler+0x22>
    {
        TC_TIMER_STATUS status;
        status = (TC_TIMER_STATUS) TC0_REGS->COUNT16.TC_INTFLAG;
   1f9d8:	4a06      	ldr	r2, [pc, #24]	; (1f9f4 <TC0_TimerInterruptHandler+0x24>)
   1f9da:	7a93      	ldrb	r3, [r2, #10]
        /* Clear interrupt flags */
        TC0_REGS->COUNT16.TC_INTFLAG = (uint8_t)TC_INTFLAG_Msk;
   1f9dc:	2133      	movs	r1, #51	; 0x33
   1f9de:	7291      	strb	r1, [r2, #10]
        if((status != TC_TIMER_STATUS_NONE) && (TC0_CallbackObject.callback != NULL))
   1f9e0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
   1f9e4:	b12b      	cbz	r3, 1f9f2 <TC0_TimerInterruptHandler+0x22>
   1f9e6:	4b04      	ldr	r3, [pc, #16]	; (1f9f8 <TC0_TimerInterruptHandler+0x28>)
   1f9e8:	681b      	ldr	r3, [r3, #0]
   1f9ea:	b113      	cbz	r3, 1f9f2 <TC0_TimerInterruptHandler+0x22>
        {
            TC0_CallbackObject.callback(status, TC0_CallbackObject.context);
   1f9ec:	4a02      	ldr	r2, [pc, #8]	; (1f9f8 <TC0_TimerInterruptHandler+0x28>)
   1f9ee:	6851      	ldr	r1, [r2, #4]
   1f9f0:	4798      	blx	r3
        }
    }
}
   1f9f2:	bd08      	pop	{r3, pc}
   1f9f4:	40003800 	.word	0x40003800
   1f9f8:	2000e358 	.word	0x2000e358

Disassembly of section .rodata.sysConsoleUARTDevDesc%755:

0001f9fc <sysConsoleUARTDevDesc>:
   1f9fc:	00000300 000200c5 0001e281 0001ecc1     ................
   1fa0c:	0001ec8d 0001e2bd 0001ec25 0001ec59     ........%...Y...
   1fa1c:	00015387 00021bdd 00022261              .S......a"..

Disassembly of section .text.TCPIP_STACK_Init%756:

0001fa28 <TCPIP_STACK_Init>:
{
   1fa28:	b500      	push	{lr}
   1fa2a:	b087      	sub	sp, #28
    tcpipInit.pNetConf = TCPIP_HOSTS_CONFIGURATION;
   1fa2c:	4b07      	ldr	r3, [pc, #28]	; (1fa4c <TCPIP_STACK_Init+0x24>)
   1fa2e:	9301      	str	r3, [sp, #4]
    tcpipInit.nNets = TCPIP_HOSTS_CONFIGURATION_SIZE;
   1fa30:	2301      	movs	r3, #1
   1fa32:	9302      	str	r3, [sp, #8]
    tcpipInit.pModConfig = TCPIP_STACK_MODULE_CONFIG_TBL;
   1fa34:	4b06      	ldr	r3, [pc, #24]	; (1fa50 <TCPIP_STACK_Init+0x28>)
   1fa36:	9303      	str	r3, [sp, #12]
    tcpipInit.nModules = TCPIP_STACK_MODULE_CONFIG_TBL_SIZE;
   1fa38:	2309      	movs	r3, #9
   1fa3a:	9304      	str	r3, [sp, #16]
    tcpipInit.initCback = 0;
   1fa3c:	2000      	movs	r0, #0
   1fa3e:	9005      	str	r0, [sp, #20]
    return TCPIP_STACK_Initialize(0, &tcpipInit.moduleInit);
   1fa40:	4669      	mov	r1, sp
   1fa42:	f7f9 f839 	bl	18ab8 <TCPIP_STACK_Initialize>
}
   1fa46:	b007      	add	sp, #28
   1fa48:	f85d fb04 	ldr.w	pc, [sp], #4
   1fa4c:	0001e89c 	.word	0x0001e89c
   1fa50:	0001d050 	.word	0x0001d050

Disassembly of section .text.pxPortInitialiseStack%757:

0001fa54 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   1fa54:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   1fa58:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
   1fa5c:	f021 0101 	bic.w	r1, r1, #1
   1fa60:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
   1fa64:	4b05      	ldr	r3, [pc, #20]	; (1fa7c <pxPortInitialiseStack+0x28>)
   1fa66:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
   1fa6a:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
   1fa6e:	f06f 0302 	mvn.w	r3, #2
   1fa72:	f840 3c24 	str.w	r3, [r0, #-36]
}
   1fa76:	3844      	subs	r0, #68	; 0x44
   1fa78:	4770      	bx	lr
   1fa7a:	bf00      	nop
   1fa7c:	00020c31 	.word	0x00020c31

Disassembly of section .text.xPortSysTickHandler%758:

0001fa80 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
   1fa80:	b508      	push	{r3, lr}
   1fa82:	f04f 0320 	mov.w	r3, #32
   1fa86:	f383 8811 	msr	BASEPRI, r3
   1fa8a:	f3bf 8f6f 	isb	sy
   1fa8e:	f3bf 8f4f 	dsb	sy
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
   1fa92:	f7f3 ff4f 	bl	13934 <xTaskIncrementTick>
   1fa96:	b118      	cbz	r0, 1faa0 <xPortSysTickHandler+0x20>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   1fa98:	4b03      	ldr	r3, [pc, #12]	; (1faa8 <xPortSysTickHandler+0x28>)
   1fa9a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1fa9e:	601a      	str	r2, [r3, #0]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   1faa0:	2300      	movs	r3, #0
   1faa2:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
   1faa6:	bd08      	pop	{r3, pc}
   1faa8:	e000ed04 	.word	0xe000ed04

Disassembly of section .text.prvResetNextTaskUnblockTime%759:

0001faac <prvResetNextTaskUnblockTime>:
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   1faac:	4b08      	ldr	r3, [pc, #32]	; (1fad0 <prvResetNextTaskUnblockTime+0x24>)
   1faae:	681b      	ldr	r3, [r3, #0]
   1fab0:	681b      	ldr	r3, [r3, #0]
   1fab2:	b923      	cbnz	r3, 1fabe <prvResetNextTaskUnblockTime+0x12>
		xNextTaskUnblockTime = portMAX_DELAY;
   1fab4:	4b07      	ldr	r3, [pc, #28]	; (1fad4 <prvResetNextTaskUnblockTime+0x28>)
   1fab6:	f04f 32ff 	mov.w	r2, #4294967295
   1faba:	601a      	str	r2, [r3, #0]
   1fabc:	4770      	bx	lr
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   1fabe:	4b04      	ldr	r3, [pc, #16]	; (1fad0 <prvResetNextTaskUnblockTime+0x24>)
   1fac0:	681b      	ldr	r3, [r3, #0]
   1fac2:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
   1fac4:	68db      	ldr	r3, [r3, #12]
   1fac6:	685a      	ldr	r2, [r3, #4]
   1fac8:	4b02      	ldr	r3, [pc, #8]	; (1fad4 <prvResetNextTaskUnblockTime+0x28>)
   1faca:	601a      	str	r2, [r3, #0]
}
   1facc:	4770      	bx	lr
   1face:	bf00      	nop
   1fad0:	2000e4a0 	.word	0x2000e4a0
   1fad4:	2000e4c0 	.word	0x2000e4c0

Disassembly of section .text.wc_RNG_HealthTest%760:

0001fad8 <wc_RNG_HealthTest>:
{
   1fad8:	b530      	push	{r4, r5, lr}
   1fada:	b089      	sub	sp, #36	; 0x24
    return wc_RNG_HealthTest_ex(reseed, NULL, 0,
   1fadc:	f06f 0401 	mvn.w	r4, #1
   1fae0:	9406      	str	r4, [sp, #24]
   1fae2:	2400      	movs	r4, #0
   1fae4:	9405      	str	r4, [sp, #20]
   1fae6:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   1fae8:	9504      	str	r5, [sp, #16]
   1faea:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   1faec:	9503      	str	r5, [sp, #12]
   1faee:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   1faf0:	9502      	str	r5, [sp, #8]
   1faf2:	9301      	str	r3, [sp, #4]
   1faf4:	9200      	str	r2, [sp, #0]
   1faf6:	460b      	mov	r3, r1
   1faf8:	4622      	mov	r2, r4
   1fafa:	4621      	mov	r1, r4
   1fafc:	f7f7 ff38 	bl	17970 <wc_RNG_HealthTest_ex>
}
   1fb00:	b009      	add	sp, #36	; 0x24
   1fb02:	bd30      	pop	{r4, r5, pc}

Disassembly of section .text.SERCOM0_SPI_IsBusy%761:

0001fb04 <SERCOM0_SPI_IsBusy>:
	if ((sercom0SPIObj.txSize == 0U) && (sercom0SPIObj.rxSize == 0U))
   1fb04:	4b08      	ldr	r3, [pc, #32]	; (1fb28 <SERCOM0_SPI_IsBusy+0x24>)
   1fb06:	689a      	ldr	r2, [r3, #8]
   1fb08:	68db      	ldr	r3, [r3, #12]
   1fb0a:	4313      	orrs	r3, r2
   1fb0c:	d00a      	beq.n	1fb24 <SERCOM0_SPI_IsBusy+0x20>
        isBusy = (((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_TXC_Msk) == 0U) || sercom0SPIObj.transferIsBusy);
   1fb0e:	4b07      	ldr	r3, [pc, #28]	; (1fb2c <SERCOM0_SPI_IsBusy+0x28>)
   1fb10:	7e1b      	ldrb	r3, [r3, #24]
   1fb12:	f013 0f02 	tst.w	r3, #2
   1fb16:	bf1a      	itte	ne
   1fb18:	4b03      	ldrne	r3, [pc, #12]	; (1fb28 <SERCOM0_SPI_IsBusy+0x24>)
   1fb1a:	7f18      	ldrbne	r0, [r3, #28]
   1fb1c:	2001      	moveq	r0, #1
   1fb1e:	f000 0001 	and.w	r0, r0, #1
   1fb22:	4770      	bx	lr
		isBusy = false;
   1fb24:	2000      	movs	r0, #0
}
   1fb26:	4770      	bx	lr
   1fb28:	2000e09c 	.word	0x2000e09c
   1fb2c:	40003000 	.word	0x40003000

Disassembly of section .text.__sfmoreglue%762:

0001fb30 <__sfmoreglue>:
   1fb30:	b570      	push	{r4, r5, r6, lr}
   1fb32:	1e4a      	subs	r2, r1, #1
   1fb34:	2564      	movs	r5, #100	; 0x64
   1fb36:	4355      	muls	r5, r2
   1fb38:	460e      	mov	r6, r1
   1fb3a:	f105 0170 	add.w	r1, r5, #112	; 0x70
   1fb3e:	f7f7 f91f 	bl	16d80 <_malloc_r>
   1fb42:	4604      	mov	r4, r0
   1fb44:	b140      	cbz	r0, 1fb58 <__sfmoreglue+0x28>
   1fb46:	2100      	movs	r1, #0
   1fb48:	e9c0 1600 	strd	r1, r6, [r0]
   1fb4c:	300c      	adds	r0, #12
   1fb4e:	60a0      	str	r0, [r4, #8]
   1fb50:	f105 0264 	add.w	r2, r5, #100	; 0x64
   1fb54:	f002 f89a 	bl	21c8c <memset>
   1fb58:	4620      	mov	r0, r4
   1fb5a:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text._wcrtomb_r%763:

0001fb5c <_wcrtomb_r>:
   1fb5c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1fb5e:	4c09      	ldr	r4, [pc, #36]	; (1fb84 <_wcrtomb_r+0x28>)
   1fb60:	b085      	sub	sp, #20
   1fb62:	4605      	mov	r5, r0
   1fb64:	461e      	mov	r6, r3
   1fb66:	f8d4 40e0 	ldr.w	r4, [r4, #224]	; 0xe0
   1fb6a:	b909      	cbnz	r1, 1fb70 <_wcrtomb_r+0x14>
   1fb6c:	460a      	mov	r2, r1
   1fb6e:	a901      	add	r1, sp, #4
   1fb70:	47a0      	blx	r4
   1fb72:	1c43      	adds	r3, r0, #1
   1fb74:	bf01      	itttt	eq
   1fb76:	2300      	moveq	r3, #0
   1fb78:	6033      	streq	r3, [r6, #0]
   1fb7a:	238a      	moveq	r3, #138	; 0x8a
   1fb7c:	602b      	streq	r3, [r5, #0]
   1fb7e:	b005      	add	sp, #20
   1fb80:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1fb82:	bf00      	nop
   1fb84:	2000d644 	.word	0x2000d644

Disassembly of section .text._sbrk%764:

0001fb88 <_sbrk>:
   1fb88:	4a07      	ldr	r2, [pc, #28]	; (1fba8 <_sbrk+0x20>)
   1fb8a:	6813      	ldr	r3, [r2, #0]
   1fb8c:	b143      	cbz	r3, 1fba0 <_sbrk+0x18>
   1fb8e:	4907      	ldr	r1, [pc, #28]	; (1fbac <_sbrk+0x24>)
   1fb90:	4418      	add	r0, r3
   1fb92:	4288      	cmp	r0, r1
   1fb94:	bf8c      	ite	hi
   1fb96:	f04f 33ff 	movhi.w	r3, #4294967295
   1fb9a:	6010      	strls	r0, [r2, #0]
   1fb9c:	4618      	mov	r0, r3
   1fb9e:	4770      	bx	lr
   1fba0:	4b03      	ldr	r3, [pc, #12]	; (1fbb0 <_sbrk+0x28>)
   1fba2:	6013      	str	r3, [r2, #0]
   1fba4:	e7f3      	b.n	1fb8e <_sbrk+0x6>
   1fba6:	bf00      	nop
   1fba8:	2000e4f0 	.word	0x2000e4f0
   1fbac:	20025fd8 	.word	0x20025fd8
   1fbb0:	2000e518 	.word	0x2000e518

Disassembly of section .text%765:

0001fbb4 <__aeabi_dcmpun>:
   1fbb4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   1fbb8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   1fbbc:	d102      	bne.n	1fbc4 <__aeabi_dcmpun+0x10>
   1fbbe:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
   1fbc2:	d10a      	bne.n	1fbda <__aeabi_dcmpun+0x26>
   1fbc4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   1fbc8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   1fbcc:	d102      	bne.n	1fbd4 <__aeabi_dcmpun+0x20>
   1fbce:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
   1fbd2:	d102      	bne.n	1fbda <__aeabi_dcmpun+0x26>
   1fbd4:	f04f 0000 	mov.w	r0, #0
   1fbd8:	4770      	bx	lr
   1fbda:	f04f 0001 	mov.w	r0, #1
   1fbde:	4770      	bx	lr

Disassembly of section .text._DRV_GMAC_LinkStateStartLink%766:

0001fbe0 <_DRV_GMAC_LinkStateStartLink>:
{
   1fbe0:	b538      	push	{r3, r4, r5, lr}
   1fbe2:	4604      	mov	r4, r0
	phyRes = pMACDrv->sGmacData.gmacConfig.pPhyBase->DRV_ETHPHY_LinkStatusGet(pMACDrv->sGmacData.hPhyClient, DRV_ETHPHY_INF_IDX_ALL_EXTERNAL, &pMACDrv->sGmacData._negResult.linkStatus, false);
   1fbe4:	f8d0 30d8 	ldr.w	r3, [r0, #216]	; 0xd8
   1fbe8:	6c1d      	ldr	r5, [r3, #64]	; 0x40
   1fbea:	2300      	movs	r3, #0
   1fbec:	f100 0240 	add.w	r2, r0, #64	; 0x40
   1fbf0:	4619      	mov	r1, r3
   1fbf2:	6900      	ldr	r0, [r0, #16]
   1fbf4:	47a8      	blx	r5
    if(phyRes < 0)
   1fbf6:	2800      	cmp	r0, #0
   1fbf8:	db03      	blt.n	1fc02 <_DRV_GMAC_LinkStateStartLink+0x22>
    pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_GET_LINK;
   1fbfa:	2301      	movs	r3, #1
   1fbfc:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
}
   1fc00:	bd38      	pop	{r3, r4, r5, pc}
	    _DRV_GMAC_LinkStateDown(pMACDrv);
   1fc02:	4620      	mov	r0, r4
   1fc04:	f001 f874 	bl	20cf0 <_DRV_GMAC_LinkStateDown>
	    return;
   1fc08:	e7fa      	b.n	1fc00 <_DRV_GMAC_LinkStateStartLink+0x20>

Disassembly of section .text.TCPIP_TCP_WasReset%767:

0001fc0a <TCPIP_TCP_WasReset>:
{
   1fc0a:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   1fc0c:	f000 f906 	bl	1fe1c <_TcpSocketChk>
    if(pSkt)
   1fc10:	b160      	cbz	r0, 1fc2c <TCPIP_TCP_WasReset+0x22>
        if(pSkt->Flags.bSocketReset)
   1fc12:	f890 2037 	ldrb.w	r2, [r0, #55]	; 0x37
   1fc16:	f012 0f02 	tst.w	r2, #2
   1fc1a:	d009      	beq.n	1fc30 <TCPIP_TCP_WasReset+0x26>
            pSkt->Flags.bSocketReset = 0;
   1fc1c:	f890 2037 	ldrb.w	r2, [r0, #55]	; 0x37
   1fc20:	f36f 0241 	bfc	r2, #1, #1
   1fc24:	f880 2037 	strb.w	r2, [r0, #55]	; 0x37
            return true;
   1fc28:	2001      	movs	r0, #1
   1fc2a:	e002      	b.n	1fc32 <TCPIP_TCP_WasReset+0x28>
    return true;
   1fc2c:	2001      	movs	r0, #1
   1fc2e:	e000      	b.n	1fc32 <TCPIP_TCP_WasReset+0x28>
        return false;
   1fc30:	2000      	movs	r0, #0
}
   1fc32:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_DNS_OAHASH_KeyCopy%768:

0001fc34 <TCPIP_DNS_OAHASH_KeyCopy>:
    if(key == 0) 
   1fc34:	b192      	cbz	r2, 1fc5c <TCPIP_DNS_OAHASH_KeyCopy+0x28>
{
   1fc36:	b570      	push	{r4, r5, r6, lr}
   1fc38:	4615      	mov	r5, r2
   1fc3a:	460c      	mov	r4, r1
    size_t hostnameLen = strlen(dnsHostNameKey);
   1fc3c:	4610      	mov	r0, r2
   1fc3e:	f002 f835 	bl	21cac <strlen>
    if(hostnameLen > TCPIP_DNS_CLIENT_MAX_HOSTNAME_LEN) 
   1fc42:	2840      	cmp	r0, #64	; 0x40
   1fc44:	bf28      	it	cs
   1fc46:	2040      	movcs	r0, #64	; 0x40
   1fc48:	4606      	mov	r6, r0
    memcpy(pDnsHE->pHostName, dnsHostNameKey, hostnameLen);
   1fc4a:	4602      	mov	r2, r0
   1fc4c:	4629      	mov	r1, r5
   1fc4e:	6a20      	ldr	r0, [r4, #32]
   1fc50:	f001 fa96 	bl	21180 <memcpy>
    pDnsHE->pHostName[hostnameLen] = '\0';
   1fc54:	6a23      	ldr	r3, [r4, #32]
   1fc56:	2200      	movs	r2, #0
   1fc58:	559a      	strb	r2, [r3, r6]
}
   1fc5a:	bd70      	pop	{r4, r5, r6, pc}
   1fc5c:	4770      	bx	lr

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListTailAdd%769:

0001fc5e <TCPIP_Helper_ProtectedSingleListTailAdd>:
    if(pL->semValid)
   1fc5e:	7c03      	ldrb	r3, [r0, #16]
   1fc60:	b903      	cbnz	r3, 1fc64 <TCPIP_Helper_ProtectedSingleListTailAdd+0x6>
   1fc62:	4770      	bx	lr
{
   1fc64:	b570      	push	{r4, r5, r6, lr}
   1fc66:	460d      	mov	r5, r1
   1fc68:	4604      	mov	r4, r0
        if (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
   1fc6a:	f100 060c 	add.w	r6, r0, #12
   1fc6e:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1fc72:	4630      	mov	r0, r6
   1fc74:	f001 f896 	bl	20da4 <OSAL_SEM_Pend>
        TCPIP_Helper_SingleListTailAdd(&pL->list, pN);
   1fc78:	4629      	mov	r1, r5
   1fc7a:	4620      	mov	r0, r4
   1fc7c:	f001 fb20 	bl	212c0 <TCPIP_Helper_SingleListTailAdd>
        if (OSAL_SEM_Post(&pL->semaphore) != OSAL_RESULT_TRUE)
   1fc80:	4630      	mov	r0, r6
   1fc82:	f001 fca7 	bl	215d4 <OSAL_SEM_Post>
}
   1fc86:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListRemoveAll%770:

0001fc88 <TCPIP_Helper_ProtectedSingleListRemoveAll>:
}



void TCPIP_Helper_ProtectedSingleListRemoveAll(PROTECTED_SINGLE_LIST* pL)
{
   1fc88:	b538      	push	{r3, r4, r5, lr}
    if(pL->semValid)
   1fc8a:	7c03      	ldrb	r3, [r0, #16]
   1fc8c:	b903      	cbnz	r3, 1fc90 <TCPIP_Helper_ProtectedSingleListRemoveAll+0x8>
        if (OSAL_SEM_Post(&pL->semaphore) != OSAL_RESULT_TRUE)
        {
            //SYS_DEBUG LOG
        }
    }
}
   1fc8e:	bd38      	pop	{r3, r4, r5, pc}
   1fc90:	4604      	mov	r4, r0
        if (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
   1fc92:	f100 050c 	add.w	r5, r0, #12
   1fc96:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1fc9a:	4628      	mov	r0, r5
   1fc9c:	f001 f882 	bl	20da4 <OSAL_SEM_Pend>
   1fca0:	4620      	mov	r0, r4
   1fca2:	f001 f939 	bl	20f18 <TCPIP_Helper_SingleListHeadRemove>
   1fca6:	2800      	cmp	r0, #0
   1fca8:	d1fa      	bne.n	1fca0 <TCPIP_Helper_ProtectedSingleListRemoveAll+0x18>
        if (OSAL_SEM_Post(&pL->semaphore) != OSAL_RESULT_TRUE)
   1fcaa:	4628      	mov	r0, r5
   1fcac:	f001 fc92 	bl	215d4 <OSAL_SEM_Post>
}
   1fcb0:	e7ed      	b.n	1fc8e <TCPIP_Helper_ProtectedSingleListRemoveAll+0x6>

Disassembly of section .text.TCPIP_Notification_Add%771:

0001fcb2 <TCPIP_Notification_Add>:
{
   1fcb2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1fcb4:	4607      	mov	r7, r0
   1fcb6:	4608      	mov	r0, r1
   1fcb8:	4616      	mov	r6, r2
   1fcba:	461d      	mov	r5, r3
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
   1fcbc:	684b      	ldr	r3, [r1, #4]
   1fcbe:	4629      	mov	r1, r5
   1fcc0:	4798      	blx	r3
    if(newNode)
   1fcc2:	4604      	mov	r4, r0
   1fcc4:	b140      	cbz	r0, 1fcd8 <TCPIP_Notification_Add+0x26>
        if(pContent)
   1fcc6:	b11e      	cbz	r6, 1fcd0 <TCPIP_Notification_Add+0x1e>
            memcpy(newNode, pContent, nBytes);
   1fcc8:	462a      	mov	r2, r5
   1fcca:	4631      	mov	r1, r6
   1fccc:	f001 fa58 	bl	21180 <memcpy>
        TCPIP_Helper_ProtectedSingleListTailAdd(notifyList, newNode);
   1fcd0:	4621      	mov	r1, r4
   1fcd2:	4638      	mov	r0, r7
   1fcd4:	f7ff ffc3 	bl	1fc5e <TCPIP_Helper_ProtectedSingleListTailAdd>
}
   1fcd8:	4620      	mov	r0, r4
   1fcda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.DRV_ETHPHY_Tasks%772:

0001fcdc <DRV_ETHPHY_Tasks>:
{
   1fcdc:	b508      	push	{r3, lr}
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1fcde:	4b07      	ldr	r3, [pc, #28]	; (1fcfc <DRV_ETHPHY_Tasks+0x20>)
   1fce0:	4283      	cmp	r3, r0
   1fce2:	d109      	bne.n	1fcf8 <DRV_ETHPHY_Tasks+0x1c>
    if(phyInst != 0)
   1fce4:	b140      	cbz	r0, 1fcf8 <DRV_ETHPHY_Tasks+0x1c>
            if(hClientObj->clientInUse != 0)
   1fce6:	8b1b      	ldrh	r3, [r3, #24]
   1fce8:	b133      	cbz	r3, 1fcf8 <DRV_ETHPHY_Tasks+0x1c>
                (*_DRV_PHY_ClientOpTbl[hClientObj->operType])(hClientObj);
   1fcea:	4804      	ldr	r0, [pc, #16]	; (1fcfc <DRV_ETHPHY_Tasks+0x20>)
   1fcec:	8e82      	ldrh	r2, [r0, #52]	; 0x34
   1fcee:	4b04      	ldr	r3, [pc, #16]	; (1fd00 <DRV_ETHPHY_Tasks+0x24>)
   1fcf0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1fcf4:	3018      	adds	r0, #24
   1fcf6:	4798      	blx	r3
} 
   1fcf8:	bd08      	pop	{r3, pc}
   1fcfa:	bf00      	nop
   1fcfc:	2000de18 	.word	0x2000de18
   1fd00:	00020e1c 	.word	0x00020e1c

Disassembly of section .text.DRV_ETHPHY_PhyAddressGet%773:

0001fd04 <DRV_ETHPHY_PhyAddressGet>:
    if( hClientObj != 0)
   1fd04:	b140      	cbz	r0, 1fd18 <DRV_ETHPHY_PhyAddressGet+0x14>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1fd06:	68c1      	ldr	r1, [r0, #12]
   1fd08:	4b07      	ldr	r3, [pc, #28]	; (1fd28 <DRV_ETHPHY_PhyAddressGet+0x24>)
   1fd0a:	4299      	cmp	r1, r3
   1fd0c:	d107      	bne.n	1fd1e <DRV_ETHPHY_PhyAddressGet+0x1a>
            if(pPhyAddress)
   1fd0e:	b14a      	cbz	r2, 1fd24 <DRV_ETHPHY_PhyAddressGet+0x20>
                *pPhyAddress = hClientObj->hDriver->phyAddress;
   1fd10:	691b      	ldr	r3, [r3, #16]
   1fd12:	6013      	str	r3, [r2, #0]
            return DRV_ETHPHY_RES_OK;
   1fd14:	2000      	movs	r0, #0
   1fd16:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1fd18:	f06f 000a 	mvn.w	r0, #10
   1fd1c:	4770      	bx	lr
   1fd1e:	f06f 000a 	mvn.w	r0, #10
   1fd22:	4770      	bx	lr
            return DRV_ETHPHY_RES_OK;
   1fd24:	2000      	movs	r0, #0
}
   1fd26:	4770      	bx	lr
   1fd28:	2000de18 	.word	0x2000de18

Disassembly of section .text._DRV_PHY_SetOperDoneResult%774:

0001fd2c <_DRV_PHY_SetOperDoneResult>:
{
   1fd2c:	b508      	push	{r3, lr}
    hClientObj->operPhase =  hClientObj->operSubPhase = 0;
   1fd2e:	2300      	movs	r3, #0
   1fd30:	8403      	strh	r3, [r0, #32]
   1fd32:	83c3      	strh	r3, [r0, #30]
    hClientObj->operType = DRV_ETHPHY_CLIENT_OP_TYPE_NONE;
   1fd34:	8383      	strh	r3, [r0, #28]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_READY;
   1fd36:	2302      	movs	r3, #2
   1fd38:	7203      	strb	r3, [r0, #8]
    hClientObj->operRes = res;
   1fd3a:	f880 102c 	strb.w	r1, [r0, #44]	; 0x2c
    if(res < 0)
   1fd3e:	2900      	cmp	r1, #0
   1fd40:	db00      	blt.n	1fd44 <_DRV_PHY_SetOperDoneResult+0x18>
}
   1fd42:	bd08      	pop	{r3, pc}
   1fd44:	460a      	mov	r2, r1
        SYS_CONSOLE_PRINT("DRV_PHY operation error: %d\r\n", res);
   1fd46:	4902      	ldr	r1, [pc, #8]	; (1fd50 <_DRV_PHY_SetOperDoneResult+0x24>)
   1fd48:	2000      	movs	r0, #0
   1fd4a:	f7fa fea7 	bl	1aa9c <SYS_CONSOLE_Print>
}
   1fd4e:	e7f8      	b.n	1fd42 <_DRV_PHY_SetOperDoneResult+0x16>
   1fd50:	000209b0 	.word	0x000209b0

Disassembly of section .text.DRV_ETHPHY_ClientOperationAbort%775:

0001fd54 <DRV_ETHPHY_ClientOperationAbort>:
{
   1fd54:	b508      	push	{r3, lr}
    if( hClientObj != 0)
   1fd56:	b148      	cbz	r0, 1fd6c <DRV_ETHPHY_ClientOperationAbort+0x18>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1fd58:	68c1      	ldr	r1, [r0, #12]
   1fd5a:	4a07      	ldr	r2, [pc, #28]	; (1fd78 <DRV_ETHPHY_ClientOperationAbort+0x24>)
   1fd5c:	4291      	cmp	r1, r2
   1fd5e:	d108      	bne.n	1fd72 <DRV_ETHPHY_ClientOperationAbort+0x1e>
            _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_ABORTED);
   1fd60:	f06f 010b 	mvn.w	r1, #11
   1fd64:	f7ff ffe2 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
            return DRV_ETHPHY_RES_OK;
   1fd68:	2000      	movs	r0, #0
}
   1fd6a:	bd08      	pop	{r3, pc}
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1fd6c:	f06f 000a 	mvn.w	r0, #10
   1fd70:	e7fb      	b.n	1fd6a <DRV_ETHPHY_ClientOperationAbort+0x16>
   1fd72:	f06f 000a 	mvn.w	r0, #10
   1fd76:	e7f8      	b.n	1fd6a <DRV_ETHPHY_ClientOperationAbort+0x16>
   1fd78:	2000de18 	.word	0x2000de18

Disassembly of section .text.DRV_PIC32CGMAC_LibSysIntStatus_Clear%776:

0001fd7c <DRV_PIC32CGMAC_LibSysIntStatus_Clear>:
    if(queMask & GMAC_QUE0_MASK)
   1fd7c:	f011 0f01 	tst.w	r1, #1
   1fd80:	d00d      	beq.n	1fd9e <DRV_PIC32CGMAC_LibSysIntStatus_Clear+0x22>
        SYS_INT_SourceStatusClear(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc);                        
   1fd82:	f9b0 30b6 	ldrsh.w	r3, [r0, #182]	; 0xb6
  if ((int32_t)(IRQn) >= 0)
   1fd86:	2b00      	cmp	r3, #0
   1fd88:	db09      	blt.n	1fd9e <DRV_PIC32CGMAC_LibSysIntStatus_Clear+0x22>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1fd8a:	095a      	lsrs	r2, r3, #5
   1fd8c:	f003 031f 	and.w	r3, r3, #31
   1fd90:	2101      	movs	r1, #1
   1fd92:	fa01 f303 	lsl.w	r3, r1, r3
   1fd96:	3260      	adds	r2, #96	; 0x60
   1fd98:	4901      	ldr	r1, [pc, #4]	; (1fda0 <DRV_PIC32CGMAC_LibSysIntStatus_Clear+0x24>)
   1fd9a:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
   1fd9e:	4770      	bx	lr
   1fda0:	e000e100 	.word	0xe000e100

Disassembly of section .text.DRV_PIC32CGMAC_LibSysInt_Enable%777:

0001fda4 <DRV_PIC32CGMAC_LibSysInt_Enable>:
    if(queMask & GMAC_QUE0_MASK)
   1fda4:	f011 0f01 	tst.w	r1, #1
   1fda8:	d00c      	beq.n	1fdc4 <DRV_PIC32CGMAC_LibSysInt_Enable+0x20>
        SYS_INT_SourceEnable(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc);
   1fdaa:	f9b0 30b6 	ldrsh.w	r3, [r0, #182]	; 0xb6
  if ((int32_t)(IRQn) >= 0)
   1fdae:	2b00      	cmp	r3, #0
   1fdb0:	db08      	blt.n	1fdc4 <DRV_PIC32CGMAC_LibSysInt_Enable+0x20>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1fdb2:	0959      	lsrs	r1, r3, #5
   1fdb4:	f003 031f 	and.w	r3, r3, #31
   1fdb8:	2201      	movs	r2, #1
   1fdba:	fa02 f303 	lsl.w	r3, r2, r3
   1fdbe:	4a02      	ldr	r2, [pc, #8]	; (1fdc8 <DRV_PIC32CGMAC_LibSysInt_Enable+0x24>)
   1fdc0:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
   1fdc4:	4770      	bx	lr
   1fdc6:	bf00      	nop
   1fdc8:	e000e100 	.word	0xe000e100

Disassembly of section .text.DRV_MIIM_Status%778:

0001fdcc <DRV_MIIM_Status>:
    if(pMiimObj != 0)
   1fdcc:	4603      	mov	r3, r0
   1fdce:	b158      	cbz	r0, 1fde8 <DRV_MIIM_Status+0x1c>
        if(pMiimObj->objStatus == SYS_STATUS_READY && (pMiimObj->objFlags & DRV_MIIM_OBJ_FLAG_IN_USE) != 0)
   1fdd0:	f990 0008 	ldrsb.w	r0, [r0, #8]
   1fdd4:	2802      	cmp	r0, #2
   1fdd6:	d10a      	bne.n	1fdee <DRV_MIIM_Status+0x22>
   1fdd8:	889b      	ldrh	r3, [r3, #4]
   1fdda:	f003 0301 	and.w	r3, r3, #1
    return SYS_STATUS_ERROR;
   1fdde:	2b00      	cmp	r3, #0
   1fde0:	bf08      	it	eq
   1fde2:	f04f 30ff 	moveq.w	r0, #4294967295
   1fde6:	4770      	bx	lr
   1fde8:	f04f 30ff 	mov.w	r0, #4294967295
   1fdec:	4770      	bx	lr
   1fdee:	f04f 30ff 	mov.w	r0, #4294967295
} 
   1fdf2:	4770      	bx	lr

Disassembly of section .text.TCPIP_ICMP_Deinitialize%779:

0001fdf4 <TCPIP_ICMP_Deinitialize>:
{
   1fdf4:	b508      	push	{r3, lr}
    if(icmpInitCount > 0)
   1fdf6:	4b08      	ldr	r3, [pc, #32]	; (1fe18 <TCPIP_ICMP_Deinitialize+0x24>)
   1fdf8:	681b      	ldr	r3, [r3, #0]
   1fdfa:	2b00      	cmp	r3, #0
   1fdfc:	dd02      	ble.n	1fe04 <TCPIP_ICMP_Deinitialize+0x10>
        if(stackCtrl->stackAction == TCPIP_STACK_ACTION_DEINIT)
   1fdfe:	7f02      	ldrb	r2, [r0, #28]
   1fe00:	2a02      	cmp	r2, #2
   1fe02:	d000      	beq.n	1fe06 <TCPIP_ICMP_Deinitialize+0x12>
}
   1fe04:	bd08      	pop	{r3, pc}
            if(--icmpInitCount == 0)
   1fe06:	3b01      	subs	r3, #1
   1fe08:	4a03      	ldr	r2, [pc, #12]	; (1fe18 <TCPIP_ICMP_Deinitialize+0x24>)
   1fe0a:	6013      	str	r3, [r2, #0]
   1fe0c:	2b00      	cmp	r3, #0
   1fe0e:	d1f9      	bne.n	1fe04 <TCPIP_ICMP_Deinitialize+0x10>
                TCPIP_ICMP_Cleanup();
   1fe10:	f7ff f96a 	bl	1f0e8 <TCPIP_ICMP_Cleanup>
}
   1fe14:	e7f6      	b.n	1fe04 <TCPIP_ICMP_Deinitialize+0x10>
   1fe16:	bf00      	nop
   1fe18:	2000e37c 	.word	0x2000e37c

Disassembly of section .text._TcpSocketChk%780:

0001fe1c <_TcpSocketChk>:
    if(hTCP >= 0 && hTCP < TcpSockets)
   1fe1c:	2800      	cmp	r0, #0
   1fe1e:	db08      	blt.n	1fe32 <_TcpSocketChk+0x16>
   1fe20:	4b06      	ldr	r3, [pc, #24]	; (1fe3c <_TcpSocketChk+0x20>)
   1fe22:	681b      	ldr	r3, [r3, #0]
   1fe24:	4298      	cmp	r0, r3
   1fe26:	d206      	bcs.n	1fe36 <_TcpSocketChk+0x1a>
        return TCBStubs[hTCP];
   1fe28:	4b05      	ldr	r3, [pc, #20]	; (1fe40 <_TcpSocketChk+0x24>)
   1fe2a:	681b      	ldr	r3, [r3, #0]
   1fe2c:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
   1fe30:	4770      	bx	lr
    return 0;
   1fe32:	2000      	movs	r0, #0
   1fe34:	4770      	bx	lr
   1fe36:	2000      	movs	r0, #0
}
   1fe38:	4770      	bx	lr
   1fe3a:	bf00      	nop
   1fe3c:	2000e390 	.word	0x2000e390
   1fe40:	2000e38c 	.word	0x2000e38c

Disassembly of section .text._TcpFlush%781:

0001fe44 <_TcpFlush>:
{
   1fe44:	b508      	push	{r3, lr}
    if(pSkt->txHead != pSkt->txUnackedTail && pSkt->remoteWindow != 0)
   1fe46:	6882      	ldr	r2, [r0, #8]
   1fe48:	6903      	ldr	r3, [r0, #16]
   1fe4a:	429a      	cmp	r2, r3
   1fe4c:	d00c      	beq.n	1fe68 <_TcpFlush+0x24>
   1fe4e:	f8b0 305c 	ldrh.w	r3, [r0, #92]	; 0x5c
   1fe52:	b90b      	cbnz	r3, 1fe58 <_TcpFlush+0x14>
    return false;
   1fe54:	2000      	movs	r0, #0
}
   1fe56:	bd08      	pop	{r3, pc}
        return _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS) == 0;
   1fe58:	2201      	movs	r2, #1
   1fe5a:	2110      	movs	r1, #16
   1fe5c:	f7e7 fee2 	bl	7c24 <_TcpSend>
   1fe60:	fab0 f080 	clz	r0, r0
   1fe64:	0940      	lsrs	r0, r0, #5
   1fe66:	e7f6      	b.n	1fe56 <_TcpFlush+0x12>
    return false;
   1fe68:	2000      	movs	r0, #0
   1fe6a:	e7f4      	b.n	1fe56 <_TcpFlush+0x12>

Disassembly of section .text._ARPRemoveCacheEntries%782:

0001fe6c <_ARPRemoveCacheEntries>:
    if(pArpDcpt->hashDcpt)
   1fe6c:	6803      	ldr	r3, [r0, #0]
   1fe6e:	b183      	cbz	r3, 1fe92 <_ARPRemoveCacheEntries+0x26>
{
   1fe70:	b510      	push	{r4, lr}
   1fe72:	4604      	mov	r4, r0
        TCPIP_OAHASH_EntriesRemoveAll(pArpDcpt->hashDcpt);
   1fe74:	4618      	mov	r0, r3
   1fe76:	f7ff f9c7 	bl	1f208 <TCPIP_OAHASH_EntriesRemoveAll>
        TCPIP_Helper_ProtectedSingleListRemoveAll(&pArpDcpt->incompleteList);
   1fe7a:	f104 002c 	add.w	r0, r4, #44	; 0x2c
   1fe7e:	f7ff ff03 	bl	1fc88 <TCPIP_Helper_ProtectedSingleListRemoveAll>
        TCPIP_Helper_ProtectedSingleListRemoveAll(&pArpDcpt->completeList);
   1fe82:	f104 0018 	add.w	r0, r4, #24
   1fe86:	f7ff feff 	bl	1fc88 <TCPIP_Helper_ProtectedSingleListRemoveAll>
        TCPIP_Helper_ProtectedSingleListRemoveAll(&pArpDcpt->permList);
   1fe8a:	1d20      	adds	r0, r4, #4
   1fe8c:	f7ff fefc 	bl	1fc88 <TCPIP_Helper_ProtectedSingleListRemoveAll>
}
   1fe90:	bd10      	pop	{r4, pc}
   1fe92:	4770      	bx	lr

Disassembly of section .text.Ipv4DeRegisterFilter%783:

0001fe94 <Ipv4DeRegisterFilter>:
{
   1fe94:	b508      	push	{r3, lr}
    if(hFilter && ipv4MemH)
   1fe96:	b138      	cbz	r0, 1fea8 <Ipv4DeRegisterFilter+0x14>
   1fe98:	4a05      	ldr	r2, [pc, #20]	; (1feb0 <Ipv4DeRegisterFilter+0x1c>)
   1fe9a:	6812      	ldr	r2, [r2, #0]
   1fe9c:	b132      	cbz	r2, 1feac <Ipv4DeRegisterFilter+0x18>
        if(TCPIP_Notification_CbackRemove((SGL_LIST_NODE*)hFilter, &ipv4PacketFilters, ipv4MemH, Ipv4DeRegisterCallback))
   1fe9e:	4b05      	ldr	r3, [pc, #20]	; (1feb4 <Ipv4DeRegisterFilter+0x20>)
   1fea0:	4905      	ldr	r1, [pc, #20]	; (1feb8 <Ipv4DeRegisterFilter+0x24>)
   1fea2:	f7fd faa3 	bl	1d3ec <TCPIP_Notification_CbackRemove>
}
   1fea6:	bd08      	pop	{r3, pc}
    return false;
   1fea8:	2000      	movs	r0, #0
   1feaa:	e7fc      	b.n	1fea6 <Ipv4DeRegisterFilter+0x12>
   1feac:	2000      	movs	r0, #0
   1feae:	e7fa      	b.n	1fea6 <Ipv4DeRegisterFilter+0x12>
   1feb0:	2000e400 	.word	0x2000e400
   1feb4:	000218f1 	.word	0x000218f1
   1feb8:	2000e23c 	.word	0x2000e23c

Disassembly of section .text._DHCPOptionWriteParamRequest%784:

0001febc <_DHCPOptionWriteParamRequest>:
    if(pSendData->writeSpace >= sizeof(*pReqL) + nOptions)
   1febc:	684b      	ldr	r3, [r1, #4]
   1febe:	2b04      	cmp	r3, #4
   1fec0:	d90b      	bls.n	1feda <_DHCPOptionWriteParamRequest+0x1e>
        pReqL = (TCPIP_DHCP_OPTION_DATA_REQUEST_LIST*)pSendData->pOpt;
   1fec2:	680b      	ldr	r3, [r1, #0]
        pReqL->opt = TCPIP_DHCP_PARAM_REQUEST_LIST;
   1fec4:	2237      	movs	r2, #55	; 0x37
   1fec6:	701a      	strb	r2, [r3, #0]
        pReqL->len = (uint8_t)nOptions;
   1fec8:	2203      	movs	r2, #3
   1feca:	705a      	strb	r2, [r3, #1]
        memcpy(pReqL->optList, _DHCPRequestParamsTbl, nOptions);
   1fecc:	4a04      	ldr	r2, [pc, #16]	; (1fee0 <_DHCPOptionWriteParamRequest+0x24>)
   1fece:	8811      	ldrh	r1, [r2, #0]
   1fed0:	7892      	ldrb	r2, [r2, #2]
   1fed2:	8059      	strh	r1, [r3, #2]
   1fed4:	711a      	strb	r2, [r3, #4]
        return sizeof(*pReqL) + nOptions;
   1fed6:	2005      	movs	r0, #5
   1fed8:	4770      	bx	lr
    return -1;
   1feda:	f04f 30ff 	mov.w	r0, #4294967295
}
   1fede:	4770      	bx	lr
   1fee0:	00022250 	.word	0x00022250

Disassembly of section .text.TCPIP_DHCP_IsActive%785:

0001fee4 <TCPIP_DHCP_IsActive>:
   1fee4:	b130      	cbz	r0, 1fef4 <TCPIP_DHCP_IsActive+0x10>
   1fee6:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
   1feea:	f010 0f40 	tst.w	r0, #64	; 0x40
   1feee:	d103      	bne.n	1fef8 <TCPIP_DHCP_IsActive+0x14>
    return false;
   1fef0:	2000      	movs	r0, #0
   1fef2:	4770      	bx	lr
   1fef4:	2000      	movs	r0, #0
   1fef6:	4770      	bx	lr
    if(DHCPClients && pNetIf)
   1fef8:	4b03      	ldr	r3, [pc, #12]	; (1ff08 <TCPIP_DHCP_IsActive+0x24>)
   1fefa:	681b      	ldr	r3, [r3, #0]
   1fefc:	b113      	cbz	r3, 1ff04 <TCPIP_DHCP_IsActive+0x20>
        return pNetIf->Flags.bIsDHCPEnabled != 0;
   1fefe:	f000 0001 	and.w	r0, r0, #1
   1ff02:	4770      	bx	lr
    return false;
   1ff04:	2000      	movs	r0, #0
}
   1ff06:	4770      	bx	lr
   1ff08:	2000e408 	.word	0x2000e408

Disassembly of section .text._TCPIP_STACK_TickHandler%786:

0001ff0c <_TCPIP_STACK_TickHandler>:
{
   1ff0c:	b508      	push	{r3, lr}
    newTcpipTickAvlbl++;
   1ff0e:	4a07      	ldr	r2, [pc, #28]	; (1ff2c <_TCPIP_STACK_TickHandler+0x20>)
   1ff10:	6813      	ldr	r3, [r2, #0]
   1ff12:	3301      	adds	r3, #1
   1ff14:	6013      	str	r3, [r2, #0]
    pTmoEntry->signalVal |= TCPIP_MODULE_SIGNAL_TMO;
   1ff16:	4806      	ldr	r0, [pc, #24]	; (1ff30 <_TCPIP_STACK_TickHandler+0x24>)
   1ff18:	8903      	ldrh	r3, [r0, #8]
   1ff1a:	f043 0302 	orr.w	r3, r3, #2
   1ff1e:	8103      	strh	r3, [r0, #8]
    _TCPIPSignalEntryNotify(pMgrEntry, TCPIP_MODULE_SIGNAL_TMO, 0);
   1ff20:	2200      	movs	r2, #0
   1ff22:	2102      	movs	r1, #2
   1ff24:	3010      	adds	r0, #16
   1ff26:	f001 f813 	bl	20f50 <_TCPIPSignalEntryNotify>
}
   1ff2a:	bd08      	pop	{r3, pc}
   1ff2c:	2000e430 	.word	0x2000e430
   1ff30:	2000d1d4 	.word	0x2000d1d4

Disassembly of section .text._TCPIPSignalEntrySetNotify%787:

0001ff34 <_TCPIPSignalEntrySetNotify>:
{
   1ff34:	b570      	push	{r4, r5, r6, lr}
   1ff36:	4604      	mov	r4, r0
   1ff38:	460d      	mov	r5, r1
   1ff3a:	4616      	mov	r6, r2
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1ff3c:	2000      	movs	r0, #0
   1ff3e:	f001 fb3d 	bl	215bc <OSAL_CRIT_Enter>
    pSigEntry->signalVal |= (uint16_t)signal;
   1ff42:	8923      	ldrh	r3, [r4, #8]
   1ff44:	432b      	orrs	r3, r5
   1ff46:	8123      	strh	r3, [r4, #8]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1ff48:	4601      	mov	r1, r0
   1ff4a:	2000      	movs	r0, #0
   1ff4c:	f001 fc65 	bl	2181a <OSAL_CRIT_Leave>
    _TCPIPSignalEntryNotify(pSigEntry, signals, sigParam);
   1ff50:	4632      	mov	r2, r6
   1ff52:	4629      	mov	r1, r5
   1ff54:	4620      	mov	r0, r4
   1ff56:	f000 fffb 	bl	20f50 <_TCPIPSignalEntryNotify>
}
   1ff5a:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_STACK_IndexToNet%788:

0001ff5c <TCPIP_STACK_IndexToNet>:
    if(0 <= netIx && netIx < tcpip_stack_ctrl_data.nIfs)
   1ff5c:	2800      	cmp	r0, #0
   1ff5e:	db09      	blt.n	1ff74 <TCPIP_STACK_IndexToNet+0x18>
   1ff60:	4b06      	ldr	r3, [pc, #24]	; (1ff7c <TCPIP_STACK_IndexToNet+0x20>)
   1ff62:	681b      	ldr	r3, [r3, #0]
   1ff64:	4283      	cmp	r3, r0
   1ff66:	dd07      	ble.n	1ff78 <TCPIP_STACK_IndexToNet+0x1c>
        return tcpipNetIf + netIx;
   1ff68:	4b05      	ldr	r3, [pc, #20]	; (1ff80 <TCPIP_STACK_IndexToNet+0x24>)
   1ff6a:	681b      	ldr	r3, [r3, #0]
   1ff6c:	226c      	movs	r2, #108	; 0x6c
   1ff6e:	fb02 3000 	mla	r0, r2, r0, r3
   1ff72:	4770      	bx	lr
    return 0;
   1ff74:	2000      	movs	r0, #0
   1ff76:	4770      	bx	lr
   1ff78:	2000      	movs	r0, #0
}
   1ff7a:	4770      	bx	lr
   1ff7c:	2000e0f0 	.word	0x2000e0f0
   1ff80:	2000e440 	.word	0x2000e440

Disassembly of section .text.TCPIP_STACK_NetMACStatisticsGet%789:

0001ff84 <TCPIP_STACK_NetMACStatisticsGet>:
   1ff84:	b180      	cbz	r0, 1ffa8 <TCPIP_STACK_NetMACStatisticsGet+0x24>
   1ff86:	4603      	mov	r3, r0
   1ff88:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
   1ff8c:	f010 0f40 	tst.w	r0, #64	; 0x40
   1ff90:	d101      	bne.n	1ff96 <TCPIP_STACK_NetMACStatisticsGet+0x12>
    return false;
   1ff92:	2000      	movs	r0, #0
}
   1ff94:	4770      	bx	lr
{
   1ff96:	b510      	push	{r4, lr}
        TCPIP_MAC_RES res = (*pNetIf->pMacObj->TCPIP_MAC_StatisticsGet)(pNetIf->hIfMac, pRxStatistics, pTxStatistics);
   1ff98:	6c58      	ldr	r0, [r3, #68]	; 0x44
   1ff9a:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
   1ff9c:	6d18      	ldr	r0, [r3, #80]	; 0x50
   1ff9e:	47a0      	blx	r4
        if(res == TCPIP_MAC_RES_OK)
   1ffa0:	fab0 f080 	clz	r0, r0
   1ffa4:	0940      	lsrs	r0, r0, #5
}
   1ffa6:	bd10      	pop	{r4, pc}
    return false;
   1ffa8:	2000      	movs	r0, #0
   1ffaa:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetMACRegisterStatisticsGet%790:

0001ffac <TCPIP_STACK_NetMACRegisterStatisticsGet>:
   1ffac:	b180      	cbz	r0, 1ffd0 <TCPIP_STACK_NetMACRegisterStatisticsGet+0x24>
{
   1ffae:	b538      	push	{r3, r4, r5, lr}
   1ffb0:	4604      	mov	r4, r0
   1ffb2:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
   1ffb6:	f010 0f40 	tst.w	r0, #64	; 0x40
   1ffba:	d101      	bne.n	1ffc0 <TCPIP_STACK_NetMACRegisterStatisticsGet+0x14>
    return false;
   1ffbc:	2000      	movs	r0, #0
}
   1ffbe:	bd38      	pop	{r3, r4, r5, pc}
        TCPIP_MAC_RES res = (*pNetIf->pMacObj->TCPIP_MAC_RegisterStatisticsGet)(pNetIf->hIfMac, pRegEntries, nEntries, pHwEntries);
   1ffc0:	6c60      	ldr	r0, [r4, #68]	; 0x44
   1ffc2:	6c45      	ldr	r5, [r0, #68]	; 0x44
   1ffc4:	6d20      	ldr	r0, [r4, #80]	; 0x50
   1ffc6:	47a8      	blx	r5
        if(res == TCPIP_MAC_RES_OK)
   1ffc8:	fab0 f080 	clz	r0, r0
   1ffcc:	0940      	lsrs	r0, r0, #5
   1ffce:	e7f6      	b.n	1ffbe <TCPIP_STACK_NetMACRegisterStatisticsGet+0x12>
    return false;
   1ffd0:	2000      	movs	r0, #0
}
   1ffd2:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetIsBcastAddress%791:

0001ffd4 <TCPIP_STACK_NetIsBcastAddress>:
   1ffd4:	b180      	cbz	r0, 1fff8 <TCPIP_STACK_NetIsBcastAddress+0x24>
   1ffd6:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1ffda:	f012 0f40 	tst.w	r2, #64	; 0x40
   1ffde:	d101      	bne.n	1ffe4 <TCPIP_STACK_NetIsBcastAddress+0x10>
    return false;
   1ffe0:	2000      	movs	r0, #0
}
   1ffe2:	4770      	bx	lr
       return (pIpAdd->Val == (pNetIf->netIPAddr.Val | ~pNetIf->netMask.Val));
   1ffe4:	6882      	ldr	r2, [r0, #8]
   1ffe6:	6840      	ldr	r0, [r0, #4]
   1ffe8:	ea60 0002 	orn	r0, r0, r2
   1ffec:	680b      	ldr	r3, [r1, #0]
   1ffee:	4298      	cmp	r0, r3
   1fff0:	bf14      	ite	ne
   1fff2:	2000      	movne	r0, #0
   1fff4:	2001      	moveq	r0, #1
   1fff6:	4770      	bx	lr
    return false;
   1fff8:	2000      	movs	r0, #0
   1fffa:	4770      	bx	lr

Disassembly of section .text._TCPIPStackSignalHandlerSetParams%792:

0001fffc <_TCPIPStackSignalHandlerSetParams>:
    if((pSignalEntry = (TCPIP_MODULE_SIGNAL_ENTRY*)handle) != 0 && pSignalEntry->signalHandler != 0)
   1fffc:	460b      	mov	r3, r1
   1fffe:	b159      	cbz	r1, 20018 <_TCPIPStackSignalHandlerSetParams+0x1c>
   20000:	6809      	ldr	r1, [r1, #0]
   20002:	b159      	cbz	r1, 2001c <_TCPIPStackSignalHandlerSetParams+0x20>
		if ((asyncTmoMs != 0) && (asyncTmoMs < stackTaskRate))
   20004:	b122      	cbz	r2, 20010 <_TCPIPStackSignalHandlerSetParams+0x14>
   20006:	4906      	ldr	r1, [pc, #24]	; (20020 <_TCPIPStackSignalHandlerSetParams+0x24>)
   20008:	6809      	ldr	r1, [r1, #0]
   2000a:	428a      	cmp	r2, r1
            asyncTmoMs = stackTaskRate;
   2000c:	bf38      	it	cc
   2000e:	b20a      	sxthcc	r2, r1
        pSignalEntry->asyncTmo = pSignalEntry->currTmo = asyncTmoMs;
   20010:	819a      	strh	r2, [r3, #12]
   20012:	815a      	strh	r2, [r3, #10]
        return true;
   20014:	2001      	movs	r0, #1
   20016:	4770      	bx	lr
    return false;
   20018:	2000      	movs	r0, #0
   2001a:	4770      	bx	lr
   2001c:	2000      	movs	r0, #0
}
   2001e:	4770      	bx	lr
   20020:	2000e438 	.word	0x2000e438

Disassembly of section .text._UDPSocketDcpt%793:

00020024 <_UDPSocketDcpt>:
    if(s >= 0 && s < nUdpSockets)
   20024:	2800      	cmp	r0, #0
   20026:	db08      	blt.n	2003a <_UDPSocketDcpt+0x16>
   20028:	4b06      	ldr	r3, [pc, #24]	; (20044 <_UDPSocketDcpt+0x20>)
   2002a:	681b      	ldr	r3, [r3, #0]
   2002c:	4298      	cmp	r0, r3
   2002e:	da06      	bge.n	2003e <_UDPSocketDcpt+0x1a>
       return UDPSocketDcpt[s];
   20030:	4b05      	ldr	r3, [pc, #20]	; (20048 <_UDPSocketDcpt+0x24>)
   20032:	681b      	ldr	r3, [r3, #0]
   20034:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
   20038:	4770      	bx	lr
    return 0;
   2003a:	2000      	movs	r0, #0
   2003c:	4770      	bx	lr
   2003e:	2000      	movs	r0, #0
}
   20040:	4770      	bx	lr
   20042:	bf00      	nop
   20044:	2000e458 	.word	0x2000e458
   20048:	2000e454 	.word	0x2000e454

Disassembly of section .text._UDPUpdatePacketLock%794:

0002004c <_UDPUpdatePacketLock>:
{
   2004c:	b570      	push	{r4, r5, r6, lr}
   2004e:	4604      	mov	r4, r0
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   20050:	2000      	movs	r0, #0
   20052:	f001 fab3 	bl	215bc <OSAL_CRIT_Enter>
   20056:	4606      	mov	r6, r0
    SGL_LIST_NODE* pNode = TCPIP_Helper_SingleListHeadRemove(&pSkt->rxQueue);
   20058:	f104 0044 	add.w	r0, r4, #68	; 0x44
   2005c:	f000 ff5c 	bl	20f18 <TCPIP_Helper_SingleListHeadRemove>
   20060:	4605      	mov	r5, r0
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   20062:	4631      	mov	r1, r6
   20064:	2000      	movs	r0, #0
   20066:	f001 fbd8 	bl	2181a <OSAL_CRIT_Leave>
    _UDPSetNewRxPacket(pSkt, pNextPkt);
   2006a:	4629      	mov	r1, r5
   2006c:	4620      	mov	r0, r4
   2006e:	f7fd fbff 	bl	1d870 <_UDPSetNewRxPacket>
}
   20072:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_UDP_GetIsReady%795:

00020074 <TCPIP_UDP_GetIsReady>:
{
   20074:	b510      	push	{r4, lr}
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   20076:	f7ff ffd5 	bl	20024 <_UDPSocketDcpt>
    if(pSkt == 0)
   2007a:	b168      	cbz	r0, 20098 <TCPIP_UDP_GetIsReady+0x24>
   2007c:	4604      	mov	r4, r0
    if(pSkt->pCurrRxSeg == 0 || pSkt->rxTotLen == 0)
   2007e:	6b03      	ldr	r3, [r0, #48]	; 0x30
   20080:	b10b      	cbz	r3, 20086 <TCPIP_UDP_GetIsReady+0x12>
   20082:	8ec3      	ldrh	r3, [r0, #54]	; 0x36
   20084:	b933      	cbnz	r3, 20094 <TCPIP_UDP_GetIsReady+0x20>
        _UDPUpdatePacketLock(pSkt);
   20086:	4620      	mov	r0, r4
   20088:	f7ff ffe0 	bl	2004c <_UDPUpdatePacketLock>
    return pSkt->pCurrRxSeg == 0 ? 0 : pSkt->rxTotLen;
   2008c:	6b23      	ldr	r3, [r4, #48]	; 0x30
   2008e:	b90b      	cbnz	r3, 20094 <TCPIP_UDP_GetIsReady+0x20>
   20090:	2000      	movs	r0, #0
   20092:	e000      	b.n	20096 <TCPIP_UDP_GetIsReady+0x22>
   20094:	8ee0      	ldrh	r0, [r4, #54]	; 0x36
}
   20096:	bd10      	pop	{r4, pc}
        return 0;
   20098:	2000      	movs	r0, #0
   2009a:	e7fc      	b.n	20096 <TCPIP_UDP_GetIsReady+0x22>

Disassembly of section .text.TC0_Timer16bitCounterGet%796:

0002009c <TC0_Timer16bitCounterGet>:
    TC0_REGS->COUNT16.TC_CTRLBSET |= (uint8_t)TC_CTRLBSET_CMD_READSYNC;
   2009c:	4a08      	ldr	r2, [pc, #32]	; (200c0 <TC0_Timer16bitCounterGet+0x24>)
   2009e:	7953      	ldrb	r3, [r2, #5]
   200a0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   200a4:	7153      	strb	r3, [r2, #5]
    while((TC0_REGS->COUNT16.TC_SYNCBUSY & TC_SYNCBUSY_CTRLB_Msk) == TC_SYNCBUSY_CTRLB_Msk)
   200a6:	6913      	ldr	r3, [r2, #16]
   200a8:	f013 0f04 	tst.w	r3, #4
   200ac:	d1fb      	bne.n	200a6 <TC0_Timer16bitCounterGet+0xa>
    while((TC0_REGS->COUNT16.TC_CTRLBSET & TC_CTRLBSET_CMD_Msk) != 0U)
   200ae:	4a04      	ldr	r2, [pc, #16]	; (200c0 <TC0_Timer16bitCounterGet+0x24>)
   200b0:	7953      	ldrb	r3, [r2, #5]
   200b2:	f013 0fe0 	tst.w	r3, #224	; 0xe0
   200b6:	d1fb      	bne.n	200b0 <TC0_Timer16bitCounterGet+0x14>
    return (uint16_t)TC0_REGS->COUNT16.TC_COUNT;
   200b8:	4b01      	ldr	r3, [pc, #4]	; (200c0 <TC0_Timer16bitCounterGet+0x24>)
   200ba:	8a98      	ldrh	r0, [r3, #20]
}
   200bc:	4770      	bx	lr
   200be:	bf00      	nop
   200c0:	40003800 	.word	0x40003800

Disassembly of section .text.Console_UART_Initialize%797:

000200c4 <Console_UART_Initialize>:
    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   200c4:	b960      	cbnz	r0, 200e0 <Console_UART_Initialize+0x1c>
{
   200c6:	b510      	push	{r4, lr}
   200c8:	460c      	mov	r4, r1
    if(OSAL_MUTEX_Create(&(pConsoleUartData->mutexTransferObjects)) != OSAL_RESULT_TRUE)
   200ca:	4806      	ldr	r0, [pc, #24]	; (200e4 <Console_UART_Initialize+0x20>)
   200cc:	f001 fa8e 	bl	215ec <OSAL_MUTEX_Create>
   200d0:	2801      	cmp	r0, #1
   200d2:	d104      	bne.n	200de <Console_UART_Initialize+0x1a>
    pConsoleUartData->uartPLIB = consoleUsartInitData->uartPLIB;
   200d4:	6822      	ldr	r2, [r4, #0]
   200d6:	4b04      	ldr	r3, [pc, #16]	; (200e8 <Console_UART_Initialize+0x24>)
   200d8:	601a      	str	r2, [r3, #0]
    pConsoleUartData->status = SYS_CONSOLE_STATUS_CONFIGURED;
   200da:	2201      	movs	r2, #1
   200dc:	711a      	strb	r2, [r3, #4]
}
   200de:	bd10      	pop	{r4, pc}
   200e0:	4770      	bx	lr
   200e2:	bf00      	nop
   200e4:	2000e33c 	.word	0x2000e33c
   200e8:	2000e334 	.word	0x2000e334

Disassembly of section .text.SYS_TMR_TickCountGet%798:

000200ec <SYS_TMR_TickCountGet>:
}

static uint32_t gTickConv = 0;

uint32_t SYS_TMR_TickCountGet(void)
{
   200ec:	b508      	push	{r3, lr}
    if(gTickConv == 0)
   200ee:	4b08      	ldr	r3, [pc, #32]	; (20110 <SYS_TMR_TickCountGet+0x24>)
   200f0:	681b      	ldr	r3, [r3, #0]
   200f2:	b13b      	cbz	r3, 20104 <SYS_TMR_TickCountGet+0x18>
    {
        gTickConv = SYS_TIME_MSToCount(1);
    }

    return (uint32_t)(SYS_TIME_Counter64Get() / (uint64_t)gTickConv);
   200f4:	f7fe f93c 	bl	1e370 <SYS_TIME_Counter64Get>
   200f8:	4b05      	ldr	r3, [pc, #20]	; (20110 <SYS_TMR_TickCountGet+0x24>)
   200fa:	681a      	ldr	r2, [r3, #0]
   200fc:	2300      	movs	r3, #0
   200fe:	f7ff fa03 	bl	1f508 <__aeabi_uldivmod>
}
   20102:	bd08      	pop	{r3, pc}
        gTickConv = SYS_TIME_MSToCount(1);
   20104:	2001      	movs	r0, #1
   20106:	f000 ffe7 	bl	210d8 <SYS_TIME_MSToCount>
   2010a:	4b01      	ldr	r3, [pc, #4]	; (20110 <SYS_TMR_TickCountGet+0x24>)
   2010c:	6018      	str	r0, [r3, #0]
   2010e:	e7f1      	b.n	200f4 <SYS_TMR_TickCountGet+0x8>
   20110:	2000e47c 	.word	0x2000e47c

Disassembly of section .text.SYS_TMR_TickCountGetLong%799:

00020114 <SYS_TMR_TickCountGetLong>:

uint64_t SYS_TMR_TickCountGetLong(void)
{
   20114:	b508      	push	{r3, lr}
    if(gTickConv == 0)
   20116:	4b08      	ldr	r3, [pc, #32]	; (20138 <SYS_TMR_TickCountGetLong+0x24>)
   20118:	681b      	ldr	r3, [r3, #0]
   2011a:	b13b      	cbz	r3, 2012c <SYS_TMR_TickCountGetLong+0x18>
    {
        gTickConv = SYS_TIME_MSToCount(1);
    }

	return SYS_TIME_Counter64Get() / (uint64_t)gTickConv;
   2011c:	f7fe f928 	bl	1e370 <SYS_TIME_Counter64Get>
   20120:	4b05      	ldr	r3, [pc, #20]	; (20138 <SYS_TMR_TickCountGetLong+0x24>)
   20122:	681a      	ldr	r2, [r3, #0]
   20124:	2300      	movs	r3, #0
   20126:	f7ff f9ef 	bl	1f508 <__aeabi_uldivmod>
}
   2012a:	bd08      	pop	{r3, pc}
        gTickConv = SYS_TIME_MSToCount(1);
   2012c:	2001      	movs	r0, #1
   2012e:	f000 ffd3 	bl	210d8 <SYS_TIME_MSToCount>
   20132:	4b01      	ldr	r3, [pc, #4]	; (20138 <SYS_TMR_TickCountGetLong+0x24>)
   20134:	6018      	str	r0, [r3, #0]
   20136:	e7f1      	b.n	2011c <SYS_TMR_TickCountGetLong+0x8>
   20138:	2000e47c 	.word	0x2000e47c

Disassembly of section .text.SYS_TMR_TickCounterFrequencyGet%800:

0002013c <SYS_TMR_TickCounterFrequencyGet>:

uint32_t SYS_TMR_TickCounterFrequencyGet ( void )
{
   2013c:	b508      	push	{r3, lr}
    if(gTickConv == 0)
   2013e:	4b08      	ldr	r3, [pc, #32]	; (20160 <SYS_TMR_TickCounterFrequencyGet+0x24>)
   20140:	681b      	ldr	r3, [r3, #0]
   20142:	b133      	cbz	r3, 20152 <SYS_TMR_TickCounterFrequencyGet+0x16>
    {
        gTickConv = SYS_TIME_MSToCount(1);
    }

	return SYS_TIME_FrequencyGet() / gTickConv;
   20144:	f001 ff8a 	bl	2205c <SYS_TIME_FrequencyGet>
   20148:	4b05      	ldr	r3, [pc, #20]	; (20160 <SYS_TMR_TickCounterFrequencyGet+0x24>)
   2014a:	681b      	ldr	r3, [r3, #0]
}
   2014c:	fbb0 f0f3 	udiv	r0, r0, r3
   20150:	bd08      	pop	{r3, pc}
        gTickConv = SYS_TIME_MSToCount(1);
   20152:	2001      	movs	r0, #1
   20154:	f000 ffc0 	bl	210d8 <SYS_TIME_MSToCount>
   20158:	4b01      	ldr	r3, [pc, #4]	; (20160 <SYS_TMR_TickCounterFrequencyGet+0x24>)
   2015a:	6018      	str	r0, [r3, #0]
   2015c:	e7f2      	b.n	20144 <SYS_TMR_TickCounterFrequencyGet+0x8>
   2015e:	bf00      	nop
   20160:	2000e47c 	.word	0x2000e47c

Disassembly of section .rodata.tcpipARPInitData%801:

00020164 <tcpipARPInitData>:
   20164:	00000005 00000001 000004b0 0000003c     ............<...
   20174:	00000002 00000032 0000004b 00000001     ....2...K.......
   20184:	00000003 00000001                       ........

Disassembly of section .text.prvPortStartFirstTask%802:

0002018c <prvPortStartFirstTask>:
	__asm volatile(
   2018c:	4808      	ldr	r0, [pc, #32]	; (201b0 <prvPortStartFirstTask+0x24>)
   2018e:	6800      	ldr	r0, [r0, #0]
   20190:	6800      	ldr	r0, [r0, #0]
   20192:	f380 8808 	msr	MSP, r0
   20196:	f04f 0000 	mov.w	r0, #0
   2019a:	f380 8814 	msr	CONTROL, r0
   2019e:	b662      	cpsie	i
   201a0:	b661      	cpsie	f
   201a2:	f3bf 8f4f 	dsb	sy
   201a6:	f3bf 8f6f 	isb	sy
   201aa:	df00      	svc	0
   201ac:	bf00      	nop
}
   201ae:	0000      	.short	0x0000
   201b0:	e000ed08 	.word	0xe000ed08

Disassembly of section .text.vPortSetupTimerInterrupt%803:

000201b4 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Stop and clear the SysTick. */
	portNVIC_SYSTICK_CTRL_REG = 0UL;
   201b4:	4b05      	ldr	r3, [pc, #20]	; (201cc <vPortSetupTimerInterrupt+0x18>)
   201b6:	2200      	movs	r2, #0
   201b8:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
   201ba:	4905      	ldr	r1, [pc, #20]	; (201d0 <vPortSetupTimerInterrupt+0x1c>)
   201bc:	600a      	str	r2, [r1, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
   201be:	4a05      	ldr	r2, [pc, #20]	; (201d4 <vPortSetupTimerInterrupt+0x20>)
   201c0:	4905      	ldr	r1, [pc, #20]	; (201d8 <vPortSetupTimerInterrupt+0x24>)
   201c2:	6011      	str	r1, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
   201c4:	2207      	movs	r2, #7
   201c6:	601a      	str	r2, [r3, #0]
}
   201c8:	4770      	bx	lr
   201ca:	bf00      	nop
   201cc:	e000e010 	.word	0xe000e010
   201d0:	e000e018 	.word	0xe000e018
   201d4:	e000e014 	.word	0xe000e014
   201d8:	0001d4bf 	.word	0x0001d4bf

Disassembly of section .rodata.__mprec_bigtens%804:

000201e0 <__mprec_bigtens>:
   201e0:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
   201f0:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
   20200:	7f73bf3c 75154fdd                       <.s..O.u

Disassembly of section .text.read%805:

00020208 <read>:
   20208:	b570      	push	{r4, r5, r6, lr}
   2020a:	b169      	cbz	r1, 20228 <read+0x20>
   2020c:	4615      	mov	r5, r2
   2020e:	b14a      	cbz	r2, 20224 <read+0x1c>
   20210:	b940      	cbnz	r0, 20224 <read+0x1c>
   20212:	460c      	mov	r4, r1
   20214:	188e      	adds	r6, r1, r2
   20216:	2001      	movs	r0, #1
   20218:	f002 f820 	bl	2225c <_mon_getc>
   2021c:	f804 0b01 	strb.w	r0, [r4], #1
   20220:	42a6      	cmp	r6, r4
   20222:	d1f8      	bne.n	20216 <read+0xe>
   20224:	4628      	mov	r0, r5
   20226:	bd70      	pop	{r4, r5, r6, pc}
   20228:	460d      	mov	r5, r1
   2022a:	4628      	mov	r0, r5
   2022c:	bd70      	pop	{r4, r5, r6, pc}
   2022e:	bf00      	nop

Disassembly of section .text._DRV_ETHPHY_NegResultPhase_ANEXP%806:

00020230 <_DRV_ETHPHY_NegResultPhase_ANEXP>:
{
   20230:	b510      	push	{r4, lr}
   20232:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   20234:	f000 fab6 	bl	207a4 <_DRV_PHY_SMITransfer_Wait>
   20238:	b900      	cbnz	r0, 2023c <_DRV_ETHPHY_NegResultPhase_ANEXP+0xc>
}
   2023a:	bd10      	pop	{r4, pc}
    hClientObj->operReg[0] = hClientObj->smiData;
   2023c:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   2023e:	8463      	strh	r3, [r4, #34]	; 0x22
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_ANLPAD))
   20240:	2105      	movs	r1, #5
   20242:	4620      	mov	r0, r4
   20244:	f7fe fe5a 	bl	1eefc <_DRV_PHY_SMIReadStart>
   20248:	2800      	cmp	r0, #0
   2024a:	d0f6      	beq.n	2023a <_DRV_ETHPHY_NegResultPhase_ANEXP+0xa>
    hClientObj->operPhase = operPhase;
   2024c:	2303      	movs	r3, #3
   2024e:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   20250:	2300      	movs	r3, #0
   20252:	8423      	strh	r3, [r4, #32]
   20254:	e7f1      	b.n	2023a <_DRV_ETHPHY_NegResultPhase_ANEXP+0xa>

Disassembly of section .text._DRV_ETHPHY_NegResultPhase_ANLPAD%807:

00020256 <_DRV_ETHPHY_NegResultPhase_ANLPAD>:
{
   20256:	b510      	push	{r4, lr}
   20258:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   2025a:	f000 faa3 	bl	207a4 <_DRV_PHY_SMITransfer_Wait>
   2025e:	b900      	cbnz	r0, 20262 <_DRV_ETHPHY_NegResultPhase_ANLPAD+0xc>
}
   20260:	bd10      	pop	{r4, pc}
    hClientObj->operReg[1] = hClientObj->smiData;
   20262:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   20264:	84a3      	strh	r3, [r4, #36]	; 0x24
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_ANAD))
   20266:	2104      	movs	r1, #4
   20268:	4620      	mov	r0, r4
   2026a:	f7fe fe47 	bl	1eefc <_DRV_PHY_SMIReadStart>
   2026e:	2800      	cmp	r0, #0
   20270:	d0f6      	beq.n	20260 <_DRV_ETHPHY_NegResultPhase_ANLPAD+0xa>
    hClientObj->operPhase = operPhase;
   20272:	2304      	movs	r3, #4
   20274:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   20276:	2300      	movs	r3, #0
   20278:	8423      	strh	r3, [r4, #32]
   2027a:	e7f1      	b.n	20260 <_DRV_ETHPHY_NegResultPhase_ANLPAD+0xa>

Disassembly of section .text.TCPIP_TCP_IsConnected%808:

0002027c <TCPIP_TCP_IsConnected>:
{
   2027c:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   2027e:	f7ff fdcd 	bl	1fe1c <_TcpSocketChk>
    return (pSkt) ? _TCP_IsConnected(pSkt) : false;
   20282:	b160      	cbz	r0, 2029e <TCPIP_TCP_IsConnected+0x22>
    return (pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1 || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2 || pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT);
   20284:	f890 006e 	ldrb.w	r0, [r0, #110]	; 0x6e
   20288:	1ec3      	subs	r3, r0, #3
   2028a:	b2db      	uxtb	r3, r3
   2028c:	2b02      	cmp	r3, #2
   2028e:	d904      	bls.n	2029a <TCPIP_TCP_IsConnected+0x1e>
   20290:	2808      	cmp	r0, #8
   20292:	bf14      	ite	ne
   20294:	2000      	movne	r0, #0
   20296:	2001      	moveq	r0, #1
   20298:	e000      	b.n	2029c <TCPIP_TCP_IsConnected+0x20>
   2029a:	2001      	movs	r0, #1
}
   2029c:	bd08      	pop	{r3, pc}
    return (pSkt) ? _TCP_IsConnected(pSkt) : false;
   2029e:	2000      	movs	r0, #0
   202a0:	e7fc      	b.n	2029c <TCPIP_TCP_IsConnected+0x20>

Disassembly of section .text.TCPIP_TCP_Flush%809:

000202a2 <TCPIP_TCP_Flush>:
{
   202a2:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   202a4:	f7ff fdba 	bl	1fe1c <_TcpSocketChk>
    if(pSkt && _TCP_TxPktValid(pSkt))
   202a8:	b150      	cbz	r0, 202c0 <TCPIP_TCP_Flush+0x1e>
    switch(pSkt->addType)
   202aa:	f890 206f 	ldrb.w	r2, [r0, #111]	; 0x6f
   202ae:	2a01      	cmp	r2, #1
   202b0:	d001      	beq.n	202b6 <TCPIP_TCP_Flush+0x14>
    return false;
   202b2:	2000      	movs	r0, #0
}
   202b4:	bd08      	pop	{r3, pc}
    if(pSkt && _TCP_TxPktValid(pSkt))
   202b6:	6c42      	ldr	r2, [r0, #68]	; 0x44
   202b8:	b122      	cbz	r2, 202c4 <TCPIP_TCP_Flush+0x22>
        return _TcpFlush(pSkt);
   202ba:	f7ff fdc3 	bl	1fe44 <_TcpFlush>
   202be:	e7f9      	b.n	202b4 <TCPIP_TCP_Flush+0x12>
    return false;
   202c0:	2000      	movs	r0, #0
   202c2:	e7f7      	b.n	202b4 <TCPIP_TCP_Flush+0x12>
   202c4:	2000      	movs	r0, #0
   202c6:	e7f5      	b.n	202b4 <TCPIP_TCP_Flush+0x12>

Disassembly of section .text.TCPIP_TCP_Discard%810:

000202c8 <TCPIP_TCP_Discard>:
{
   202c8:	b538      	push	{r3, r4, r5, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   202ca:	f7ff fda7 	bl	1fe1c <_TcpSocketChk>
    if(pSkt)
   202ce:	b160      	cbz	r0, 202ea <TCPIP_TCP_Discard+0x22>
   202d0:	4604      	mov	r4, r0
        nBytes = _TCPIsGetReady(pSkt);
   202d2:	f000 fd1c 	bl	20d0e <_TCPIsGetReady>
        if(nBytes)
   202d6:	4605      	mov	r5, r0
   202d8:	b908      	cbnz	r0, 202de <TCPIP_TCP_Discard+0x16>
}
   202da:	4628      	mov	r0, r5
   202dc:	bd38      	pop	{r3, r4, r5, pc}
            pSkt->rxTail = pSkt->rxHead;
   202de:	69e3      	ldr	r3, [r4, #28]
   202e0:	6223      	str	r3, [r4, #32]
            _TCPSendWinIncUpdate(pSkt);
   202e2:	4620      	mov	r0, r4
   202e4:	f7fc fd94 	bl	1ce10 <_TCPSendWinIncUpdate>
   202e8:	e7f7      	b.n	202da <TCPIP_TCP_Discard+0x12>
    uint16_t nBytes = 0;
   202ea:	2500      	movs	r5, #0
   202ec:	e7f5      	b.n	202da <TCPIP_TCP_Discard+0x12>

Disassembly of section .text.TCPIP_OAHASH_Initialize%811:

000202ee <TCPIP_OAHASH_Initialize>:
    pOH->fullSlots = 0; 
   202ee:	2300      	movs	r3, #0
   202f0:	6243      	str	r3, [r0, #36]	; 0x24
    pHE = (OA_HASH_ENTRY*)pOH->memBlk;
   202f2:	6803      	ldr	r3, [r0, #0]
    for(ix = 0; ix < pOH->hEntries; ix++)
   202f4:	68c2      	ldr	r2, [r0, #12]
   202f6:	b162      	cbz	r2, 20312 <TCPIP_OAHASH_Initialize+0x24>
{
   202f8:	b410      	push	{r4}
    for(ix = 0; ix < pOH->hEntries; ix++)
   202fa:	2200      	movs	r2, #0
        pHE->flags.value = 0;
   202fc:	4614      	mov	r4, r2
   202fe:	801c      	strh	r4, [r3, #0]
        pHE = (OA_HASH_ENTRY*)((uint8_t*)pHE + pOH->hEntrySize);
   20300:	6881      	ldr	r1, [r0, #8]
   20302:	440b      	add	r3, r1
    for(ix = 0; ix < pOH->hEntries; ix++)
   20304:	3201      	adds	r2, #1
   20306:	68c1      	ldr	r1, [r0, #12]
   20308:	4291      	cmp	r1, r2
   2030a:	d8f8      	bhi.n	202fe <TCPIP_OAHASH_Initialize+0x10>
}
   2030c:	f85d 4b04 	ldr.w	r4, [sp], #4
   20310:	4770      	bx	lr
   20312:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_DNSServiceSelect%812:

00020314 <TCPIP_STACK_DNSServiceSelect>:
    pNetIf->Flags.v &= ~TCPIP_STACK_DNS_SERVICE_MASK;
   20314:	f8b0 3042 	ldrh.w	r3, [r0, #66]	; 0x42
   20318:	f023 0318 	bic.w	r3, r3, #24
   2031c:	f8a0 3042 	strh.w	r3, [r0, #66]	; 0x42
        if((configFlags & TCPIP_NETWORK_CONFIG_DNS_CLIENT_ON) != 0 )
   20320:	f011 0f08 	tst.w	r1, #8
   20324:	d101      	bne.n	2032a <TCPIP_STACK_DNSServiceSelect+0x16>
    return TCPIP_STACK_DNS_SERVICE_NONE;
   20326:	2000      	movs	r0, #0
}
   20328:	4770      	bx	lr
            pNetIf->Flags.bIsDnsClientEnabled = 1;
   2032a:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   2032e:	f043 0308 	orr.w	r3, r3, #8
   20332:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
            return TCPIP_STACK_DNS_SERVICE_CLIENT;
   20336:	2001      	movs	r0, #1
   20338:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_AddressServiceSelect%813:

0002033a <TCPIP_STACK_AddressServiceSelect>:
    pNetIf->Flags.v &= ~TCPIP_STACK_ADDRESS_SERVICE_MASK;
   2033a:	f8b0 3042 	ldrh.w	r3, [r0, #66]	; 0x42
   2033e:	f023 0307 	bic.w	r3, r3, #7
   20342:	f8a0 3042 	strh.w	r3, [r0, #66]	; 0x42
    if((configFlags & TCPIP_NETWORK_CONFIG_DHCP_CLIENT_ON) != 0 )
   20346:	f011 0f01 	tst.w	r1, #1
   2034a:	d101      	bne.n	20350 <TCPIP_STACK_AddressServiceSelect+0x16>
    return TCPIP_STACK_ADDRESS_SERVICE_NONE;
   2034c:	2000      	movs	r0, #0
}
   2034e:	4770      	bx	lr
        pNetIf->Flags.bIsDHCPEnabled = 1;
   20350:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   20354:	f043 0301 	orr.w	r3, r3, #1
   20358:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
        return TCPIP_STACK_ADDRESS_SERVICE_DHCPC;
   2035c:	2001      	movs	r0, #1
   2035e:	4770      	bx	lr

Disassembly of section .text.SYS_RANDOM_CryptoBlockGet%814:

00020360 <SYS_RANDOM_CryptoBlockGet>:
}



size_t SYS_RANDOM_CryptoBlockGet( void *buffer, size_t size )
{
   20360:	b538      	push	{r3, r4, r5, lr}
    if(buffer != 0 && size != 0)
   20362:	b170      	cbz	r0, 20382 <SYS_RANDOM_CryptoBlockGet+0x22>
   20364:	460c      	mov	r4, r1
   20366:	4605      	mov	r5, r0
   20368:	b909      	cbnz	r1, 2036e <SYS_RANDOM_CryptoBlockGet+0xe>
            return size;
        }
    }

    return 0;
}
   2036a:	4620      	mov	r0, r4
   2036c:	bd38      	pop	{r3, r4, r5, pc}
        CRYPT_RNG_CTX* pCtx = _SYS_RANDOM_CryptoContext();
   2036e:	f001 f99d 	bl	216ac <_SYS_RANDOM_CryptoContext>
        if(pCtx)
   20372:	b908      	cbnz	r0, 20378 <SYS_RANDOM_CryptoBlockGet+0x18>
    return 0;
   20374:	2400      	movs	r4, #0
   20376:	e7f8      	b.n	2036a <SYS_RANDOM_CryptoBlockGet+0xa>
            CRYPT_RNG_BlockGenerate(pCtx, (uint8_t*)buffer, size);
   20378:	4622      	mov	r2, r4
   2037a:	4629      	mov	r1, r5
   2037c:	f001 f82d 	bl	213da <CRYPT_RNG_BlockGenerate>
            return size;
   20380:	e7f3      	b.n	2036a <SYS_RANDOM_CryptoBlockGet+0xa>
    return 0;
   20382:	2400      	movs	r4, #0
   20384:	e7f1      	b.n	2036a <SYS_RANDOM_CryptoBlockGet+0xa>

Disassembly of section .text.strncpy%815:

00020386 <strncpy>:
   20386:	b510      	push	{r4, lr}
   20388:	3901      	subs	r1, #1
   2038a:	4603      	mov	r3, r0
   2038c:	b132      	cbz	r2, 2039c <strncpy+0x16>
   2038e:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   20392:	f803 4b01 	strb.w	r4, [r3], #1
   20396:	3a01      	subs	r2, #1
   20398:	2c00      	cmp	r4, #0
   2039a:	d1f7      	bne.n	2038c <strncpy+0x6>
   2039c:	441a      	add	r2, r3
   2039e:	2100      	movs	r1, #0
   203a0:	4293      	cmp	r3, r2
   203a2:	d100      	bne.n	203a6 <strncpy+0x20>
   203a4:	bd10      	pop	{r4, pc}
   203a6:	f803 1b01 	strb.w	r1, [r3], #1
   203aa:	e7f9      	b.n	203a0 <strncpy+0x1a>

Disassembly of section .text.DRV_ETHPHY_VendorDataSet%816:

000203ac <DRV_ETHPHY_VendorDataSet>:
    if(hClientObj != 0)
   203ac:	4603      	mov	r3, r0
   203ae:	b130      	cbz	r0, 203be <DRV_ETHPHY_VendorDataSet+0x12>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   203b0:	68c0      	ldr	r0, [r0, #12]
   203b2:	4a06      	ldr	r2, [pc, #24]	; (203cc <DRV_ETHPHY_VendorDataSet+0x20>)
   203b4:	4290      	cmp	r0, r2
   203b6:	d105      	bne.n	203c4 <DRV_ETHPHY_VendorDataSet+0x18>
            hClientObj->vendorData = vendorData;
   203b8:	6419      	str	r1, [r3, #64]	; 0x40
            return DRV_ETHPHY_RES_OK;
   203ba:	2000      	movs	r0, #0
   203bc:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   203be:	f06f 000a 	mvn.w	r0, #10
   203c2:	4770      	bx	lr
   203c4:	f06f 000a 	mvn.w	r0, #10
}
   203c8:	4770      	bx	lr
   203ca:	bf00      	nop
   203cc:	2000de18 	.word	0x2000de18

Disassembly of section .rodata%817:

000203d0 <.rodata%817>:
   203d0:	20565244 	.word	0x20565244
   203d4:	20594850 	.word	0x20594850
   203d8:	74696e69 	.word	0x74696e69
   203dc:	69616620 	.word	0x69616620
   203e0:	3a64656c 	.word	0x3a64656c
   203e4:	0d642520 	.word	0x0d642520
   203e8:	0000000a 	.word	0x0000000a
   203ec:	43414d47 	.word	0x43414d47
   203f0:	00          	.byte	0x00
   203f1:	00          	.byte	0x00
   203f2:	bf00      	nop

Disassembly of section .text.DRV_PIC32CGMAC_LibSysInt_Disable%818:

000203f4 <DRV_PIC32CGMAC_LibSysInt_Disable>:
    if(queMask & GMAC_QUE0_MASK)
   203f4:	f011 0f01 	tst.w	r1, #1
   203f8:	d00d      	beq.n	20416 <DRV_PIC32CGMAC_LibSysInt_Disable+0x22>
{
   203fa:	b510      	push	{r4, lr}
   203fc:	4614      	mov	r4, r2
        if(queStat)
   203fe:	b12a      	cbz	r2, 2040c <DRV_PIC32CGMAC_LibSysInt_Disable+0x18>
            queStat[GMAC_QUE_0] = SYS_INT_SourceDisable(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc);
   20400:	f9b0 00b6 	ldrsh.w	r0, [r0, #182]	; 0xb6
   20404:	f7fd f96a 	bl	1d6dc <SYS_INT_SourceDisable>
   20408:	7020      	strb	r0, [r4, #0]
}
   2040a:	bd10      	pop	{r4, pc}
            SYS_INT_SourceDisable(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc);
   2040c:	f9b0 00b6 	ldrsh.w	r0, [r0, #182]	; 0xb6
   20410:	f7fd f964 	bl	1d6dc <SYS_INT_SourceDisable>
}
   20414:	e7f9      	b.n	2040a <DRV_PIC32CGMAC_LibSysInt_Disable+0x16>
   20416:	4770      	bx	lr

Disassembly of section .text._ICMPAllocateTxPacketStruct%819:

00020418 <_ICMPAllocateTxPacketStruct>:
{
   20418:	b508      	push	{r3, lr}
    ptrPacket = (IPV4_PACKET*)TCPIP_PKT_SocketAlloc(sizeof(IPV4_PACKET), totICMPLen, 0, TCPIP_MAC_PKT_FLAG_ICMPV4 | TCPIP_MAC_PKT_FLAG_IPV4 | TCPIP_MAC_PKT_FLAG_TX);
   2041a:	2302      	movs	r3, #2
   2041c:	2200      	movs	r2, #0
   2041e:	4601      	mov	r1, r0
   20420:	2044      	movs	r0, #68	; 0x44
   20422:	f7ff faa9 	bl	1f978 <_TCPIP_PKT_SocketAlloc>
    if (ptrPacket != 0)
   20426:	4603      	mov	r3, r0
   20428:	b118      	cbz	r0, 20432 <_ICMPAllocateTxPacketStruct+0x1a>
    pPkt->ackFunc = ackFunc;
   2042a:	4a03      	ldr	r2, [pc, #12]	; (20438 <_ICMPAllocateTxPacketStruct+0x20>)
   2042c:	6082      	str	r2, [r0, #8]
    pPkt->ackParam = ackParam;
   2042e:	2200      	movs	r2, #0
   20430:	60c2      	str	r2, [r0, #12]
}
   20432:	4618      	mov	r0, r3
   20434:	bd08      	pop	{r3, pc}
   20436:	bf00      	nop
   20438:	000220eb 	.word	0x000220eb

Disassembly of section .text.TCPIP_ICMP_EchoRequestCancel%820:

0002043c <TCPIP_ICMP_EchoRequestCancel>:
    if(icmpHandle == pIcmpEchoRequest && pIcmpEchoRequest != 0)
   2043c:	4b07      	ldr	r3, [pc, #28]	; (2045c <TCPIP_ICMP_EchoRequestCancel+0x20>)
   2043e:	681b      	ldr	r3, [r3, #0]
   20440:	4283      	cmp	r3, r0
   20442:	d104      	bne.n	2044e <TCPIP_ICMP_EchoRequestCancel+0x12>
   20444:	b133      	cbz	r3, 20454 <TCPIP_ICMP_EchoRequestCancel+0x18>
        pIcmpEchoRequest = 0;    // free
   20446:	2000      	movs	r0, #0
   20448:	4b04      	ldr	r3, [pc, #16]	; (2045c <TCPIP_ICMP_EchoRequestCancel+0x20>)
   2044a:	6018      	str	r0, [r3, #0]
        return ICMP_ECHO_OK;
   2044c:	4770      	bx	lr
    return ICMP_ECHO_BAD_HANDLE;
   2044e:	f06f 0005 	mvn.w	r0, #5
   20452:	4770      	bx	lr
   20454:	f06f 0005 	mvn.w	r0, #5
}
   20458:	4770      	bx	lr
   2045a:	bf00      	nop
   2045c:	2000e384 	.word	0x2000e384

Disassembly of section .text._ARPAllocateTxPacket%821:

00020460 <_ARPAllocateTxPacket>:
{
   20460:	b508      	push	{r3, lr}
    pPkt = TCPIP_PKT_PacketAlloc(sizeof(TCPIP_MAC_PACKET), sizeof(ARP_PACKET), TCPIP_MAC_PKT_FLAG_ARP | TCPIP_MAC_PKT_FLAG_TX);
   20462:	f44f 7281 	mov.w	r2, #258	; 0x102
   20466:	211c      	movs	r1, #28
   20468:	2034      	movs	r0, #52	; 0x34
   2046a:	f7f8 fe13 	bl	19094 <_TCPIP_PKT_PacketAlloc>
    if(pPkt)
   2046e:	4603      	mov	r3, r0
   20470:	b118      	cbz	r0, 2047a <_ARPAllocateTxPacket+0x1a>
    pPkt->ackFunc = ackFunc;
   20472:	4a03      	ldr	r2, [pc, #12]	; (20480 <_ARPAllocateTxPacket+0x20>)
   20474:	6082      	str	r2, [r0, #8]
    pPkt->ackParam = ackParam;
   20476:	2200      	movs	r2, #0
   20478:	60c2      	str	r2, [r0, #12]
}
   2047a:	4618      	mov	r0, r3
   2047c:	bd08      	pop	{r3, pc}
   2047e:	bf00      	nop
   20480:	00020ea9 	.word	0x00020ea9

Disassembly of section .text.TCPIP_ARP_HandlerDeRegister%822:

00020484 <TCPIP_ARP_HandlerDeRegister>:
{
   20484:	b508      	push	{r3, lr}
    if(hArp && arpMod.memH)
   20486:	b130      	cbz	r0, 20496 <TCPIP_ARP_HandlerDeRegister+0x12>
   20488:	4a05      	ldr	r2, [pc, #20]	; (204a0 <TCPIP_ARP_HandlerDeRegister+0x1c>)
   2048a:	6892      	ldr	r2, [r2, #8]
   2048c:	b12a      	cbz	r2, 2049a <TCPIP_ARP_HandlerDeRegister+0x16>
        if(TCPIP_Notification_Remove((SGL_LIST_NODE*)hArp, &arpMod.registeredUsers, arpMod.memH))
   2048e:	4905      	ldr	r1, [pc, #20]	; (204a4 <TCPIP_ARP_HandlerDeRegister+0x20>)
   20490:	f000 fb4e 	bl	20b30 <TCPIP_Notification_Remove>
}
   20494:	bd08      	pop	{r3, pc}
    return false;
   20496:	2000      	movs	r0, #0
   20498:	e7fc      	b.n	20494 <TCPIP_ARP_HandlerDeRegister+0x10>
   2049a:	2000      	movs	r0, #0
   2049c:	e7fa      	b.n	20494 <TCPIP_ARP_HandlerDeRegister+0x10>
   2049e:	bf00      	nop
   204a0:	2000dfa4 	.word	0x2000dfa4
   204a4:	2000dfc4 	.word	0x2000dfc4

Disassembly of section .rodata._tcpip_heap_object%823:

000204a8 <_tcpip_heap_object>:
   204a8:	0001d361 0001719b 00020ee1 00013e81     a....q.......>..
   204b8:	00021fd9 0001e585 00021a69 00021fe5     ........i.......
   204c8:	000217ad                                ....

Disassembly of section .text._DHCPOptionProcessSrvIdent%824:

000204cc <_DHCPOptionProcessSrvIdent>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_SERVER_ID))
   204cc:	684b      	ldr	r3, [r1, #4]
   204ce:	2b05      	cmp	r3, #5
   204d0:	d908      	bls.n	204e4 <_DHCPOptionProcessSrvIdent+0x18>
        TCPIP_DHCP_OPTION_DATA_SERVER_ID* pServId = (TCPIP_DHCP_OPTION_DATA_SERVER_ID*)pOptData->pOpt;
   204d2:	680b      	ldr	r3, [r1, #0]
        if(pServId->len == sizeof(pServId->serverId))
   204d4:	785a      	ldrb	r2, [r3, #1]
   204d6:	2a04      	cmp	r2, #4
   204d8:	d107      	bne.n	204ea <_DHCPOptionProcessSrvIdent+0x1e>
            memcpy( pOptData->serverID.v, pServId->serverId, sizeof(pServId->serverId));
   204da:	f8d3 3002 	ldr.w	r3, [r3, #2]
   204de:	60cb      	str	r3, [r1, #12]
            return sizeof(TCPIP_DHCP_OPTION_DATA_SERVER_ID);
   204e0:	2006      	movs	r0, #6
   204e2:	4770      	bx	lr
    return -1;
   204e4:	f04f 30ff 	mov.w	r0, #4294967295
   204e8:	4770      	bx	lr
   204ea:	f04f 30ff 	mov.w	r0, #4294967295
}
   204ee:	4770      	bx	lr

Disassembly of section .text._DHCPOptionWriteMsgType%825:

000204f0 <_DHCPOptionWriteMsgType>:
    if(pSendData->writeSpace >= sizeof(*pDhcpOptType))
   204f0:	684b      	ldr	r3, [r1, #4]
   204f2:	2b02      	cmp	r3, #2
   204f4:	d90b      	bls.n	2050e <_DHCPOptionWriteMsgType+0x1e>
        pDhcpOptType = (TCPIP_DHCP_OPTION_DATA_MSG_TYPE*)pSendData->pOpt;
   204f6:	680a      	ldr	r2, [r1, #0]
        pDhcpOptType->opt = TCPIP_DHCP_MESSAGE_TYPE;
   204f8:	2335      	movs	r3, #53	; 0x35
   204fa:	7013      	strb	r3, [r2, #0]
        pDhcpOptType->len = sizeof(pDhcpOptType->type);
   204fc:	2301      	movs	r3, #1
   204fe:	7053      	strb	r3, [r2, #1]
        pDhcpOptType->type = (pSendData->msgType == TCPIP_DHCP_REQUEST_RENEW_MESSAGE) ? TCPIP_DHCP_REQUEST_MESSAGE : (uint8_t)pSendData->msgType;
   20500:	68cb      	ldr	r3, [r1, #12]
   20502:	2b09      	cmp	r3, #9
   20504:	bf08      	it	eq
   20506:	2303      	moveq	r3, #3
   20508:	7093      	strb	r3, [r2, #2]
        return sizeof(*pDhcpOptType);
   2050a:	2003      	movs	r0, #3
   2050c:	4770      	bx	lr
    return -1;
   2050e:	f04f 30ff 	mov.w	r0, #4294967295
}
   20512:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_IPAddToNet%826:

00020514 <TCPIP_STACK_IPAddToNet>:
{
   20514:	b510      	push	{r4, lr}
   20516:	460c      	mov	r4, r1
    if(pIpAddress && pIpAddress->Val != 0)
   20518:	b128      	cbz	r0, 20526 <TCPIP_STACK_IPAddToNet+0x12>
   2051a:	6802      	ldr	r2, [r0, #0]
   2051c:	b11a      	cbz	r2, 20526 <TCPIP_STACK_IPAddToNet+0x12>
        pNetIf = TCPIP_STACK_NetByAddress(pIpAddress);
   2051e:	f7fd f855 	bl	1d5cc <TCPIP_STACK_NetByAddress>
    if(pNetIf == 0 && useDefault)
   20522:	4603      	mov	r3, r0
   20524:	b910      	cbnz	r0, 2052c <TCPIP_STACK_IPAddToNet+0x18>
   20526:	b11c      	cbz	r4, 20530 <TCPIP_STACK_IPAddToNet+0x1c>
        pNetIf = tcpipDefIf.defaultNet;
   20528:	4b02      	ldr	r3, [pc, #8]	; (20534 <TCPIP_STACK_IPAddToNet+0x20>)
   2052a:	681b      	ldr	r3, [r3, #0]
}
   2052c:	4618      	mov	r0, r3
   2052e:	bd10      	pop	{r4, pc}
   20530:	2300      	movs	r3, #0
    return pNetIf;
   20532:	e7fb      	b.n	2052c <TCPIP_STACK_IPAddToNet+0x18>
   20534:	2000e43c 	.word	0x2000e43c

Disassembly of section .text._UDPFreeRxQueue%827:

00020538 <_UDPFreeRxQueue>:
{
   20538:	b570      	push	{r4, r5, r6, lr}
    while((pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(&pSkt->rxQueue)) != 0)
   2053a:	f100 0444 	add.w	r4, r0, #68	; 0x44
    TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
   2053e:	2609      	movs	r6, #9
   20540:	f06f 0510 	mvn.w	r5, #16
    while((pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(&pSkt->rxQueue)) != 0)
   20544:	4620      	mov	r0, r4
   20546:	f000 fce7 	bl	20f18 <TCPIP_Helper_SingleListHeadRemove>
   2054a:	4603      	mov	r3, r0
   2054c:	b128      	cbz	r0, 2055a <_UDPFreeRxQueue+0x22>
    TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
   2054e:	4632      	mov	r2, r6
   20550:	4629      	mov	r1, r5
   20552:	4618      	mov	r0, r3
   20554:	f7fd fb4e 	bl	1dbf4 <_TCPIP_PKT_PacketAcknowledge>
   20558:	e7f4      	b.n	20544 <_UDPFreeRxQueue+0xc>
}
   2055a:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .rodata._builtinCmdTbl%828:

0002055c <_builtinCmdTbl>:
   2055c:	d2ec 0000 1695 0002 d2f4 0000 d304 0000     ................
   2056c:	ebf1 0001 d308 0000 d324 0000 1655 0001     ........$...U...
   2057c:	d32c 0000                                   ,...

Disassembly of section .text.SYS_RESET_SoftwareReset%829:

00020580 <SYS_RESET_SoftwareReset>:
  __ASM volatile ("dsb 0xF":::"memory");
   20580:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   20584:	4905      	ldr	r1, [pc, #20]	; (2059c <SYS_RESET_SoftwareReset+0x1c>)
   20586:	68ca      	ldr	r2, [r1, #12]
   20588:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   2058c:	4b04      	ldr	r3, [pc, #16]	; (205a0 <SYS_RESET_SoftwareReset+0x20>)
   2058e:	4313      	orrs	r3, r2
   20590:	60cb      	str	r3, [r1, #12]
   20592:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
   20596:	bf00      	nop
   20598:	e7fd      	b.n	20596 <SYS_RESET_SoftwareReset+0x16>
   2059a:	bf00      	nop
   2059c:	e000ed00 	.word	0xe000ed00
   205a0:	05fa0004 	.word	0x05fa0004

Disassembly of section .text.SYS_RANDOM_CryptoGet%830:

000205a4 <SYS_RANDOM_CryptoGet>:
{
   205a4:	b500      	push	{lr}
   205a6:	b083      	sub	sp, #12
    }sUint = {0};
   205a8:	2300      	movs	r3, #0
   205aa:	9301      	str	r3, [sp, #4]
    CRYPT_RNG_CTX* pCtx = _SYS_RANDOM_CryptoContext();
   205ac:	f001 f87e 	bl	216ac <_SYS_RANDOM_CryptoContext>
    if(pCtx)
   205b0:	b918      	cbnz	r0, 205ba <SYS_RANDOM_CryptoGet+0x16>
    return 0;
   205b2:	2000      	movs	r0, #0
}
   205b4:	b003      	add	sp, #12
   205b6:	f85d fb04 	ldr.w	pc, [sp], #4
        CRYPT_RNG_BlockGenerate(pCtx, (unsigned char*)sUint.u8, sizeof(sUint.u8));
   205ba:	2204      	movs	r2, #4
   205bc:	eb0d 0102 	add.w	r1, sp, r2
   205c0:	f000 ff0b 	bl	213da <CRYPT_RNG_BlockGenerate>
        return sUint.u32;
   205c4:	9801      	ldr	r0, [sp, #4]
   205c6:	e7f5      	b.n	205b4 <SYS_RANDOM_CryptoGet+0x10>

Disassembly of section .text.vPortSVCHandler%831:

000205d0 <vPortSVCHandler>:
	__asm volatile (
   205d0:	4b07      	ldr	r3, [pc, #28]	; (205f0 <pxCurrentTCBConst2>)
   205d2:	6819      	ldr	r1, [r3, #0]
   205d4:	6808      	ldr	r0, [r1, #0]
   205d6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   205da:	f380 8809 	msr	PSP, r0
   205de:	f3bf 8f6f 	isb	sy
   205e2:	f04f 0000 	mov.w	r0, #0
   205e6:	f380 8811 	msr	BASEPRI, r0
   205ea:	4770      	bx	lr
   205ec:	f3af 8000 	nop.w

000205f0 <pxCurrentTCBConst2>:
   205f0:	2000e49c 	.word	0x2000e49c

Disassembly of section .text.uxListRemove%832:

000205f4 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
   205f4:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   205f6:	6841      	ldr	r1, [r0, #4]
   205f8:	6882      	ldr	r2, [r0, #8]
   205fa:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   205fc:	6841      	ldr	r1, [r0, #4]
   205fe:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
   20600:	685a      	ldr	r2, [r3, #4]
   20602:	4282      	cmp	r2, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
   20604:	bf04      	itt	eq
   20606:	6882      	ldreq	r2, [r0, #8]
   20608:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
   2060a:	2200      	movs	r2, #0
   2060c:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
   2060e:	681a      	ldr	r2, [r3, #0]
   20610:	3a01      	subs	r2, #1
   20612:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
   20614:	6818      	ldr	r0, [r3, #0]
}
   20616:	4770      	bx	lr

Disassembly of section .text.xQueueCreateMutex%833:

00020618 <xQueueCreateMutex>:
	{
   20618:	b510      	push	{r4, lr}
		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
   2061a:	4602      	mov	r2, r0
   2061c:	2100      	movs	r1, #0
   2061e:	2001      	movs	r0, #1
   20620:	f7fe ff12 	bl	1f448 <xQueueGenericCreate>
		if( pxNewQueue != NULL )
   20624:	4604      	mov	r4, r0
   20626:	b138      	cbz	r0, 20638 <xQueueCreateMutex+0x20>
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
   20628:	2100      	movs	r1, #0
   2062a:	6081      	str	r1, [r0, #8]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
   2062c:	6001      	str	r1, [r0, #0]
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
   2062e:	60c1      	str	r1, [r0, #12]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
   20630:	460b      	mov	r3, r1
   20632:	460a      	mov	r2, r1
   20634:	f7f2 fc72 	bl	12f1c <xQueueGenericSend>
	}
   20638:	4620      	mov	r0, r4
   2063a:	bd10      	pop	{r4, pc}

Disassembly of section .text.gfx_mono_framebuffer_put_byte%834:

0002063c <gfx_mono_framebuffer_put_byte>:
    gfx_mono_framebuffer_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
        uint8_t data) {
    uint8_t *fBufferBegin = fbpointer;
   2063c:	4b07      	ldr	r3, [pc, #28]	; (2065c <gfx_mono_framebuffer_put_byte+0x20>)
   2063e:	681b      	ldr	r3, [r3, #0]
    uint8_t *fBufferEnd = fbpointer + GFX_MONO_LCD_FRAMEBUFFER_SIZE;
    uint8_t *fbpointerTemp = (fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
   20640:	eb01 11c0 	add.w	r1, r1, r0, lsl #7
    if ((fbpointerTemp >= fBufferBegin) && (fbpointerTemp <= fBufferEnd)) {
   20644:	1858      	adds	r0, r3, r1
   20646:	d208      	bcs.n	2065a <gfx_mono_framebuffer_put_byte+0x1e>
        uint8_t data) {
   20648:	b410      	push	{r4}
    uint8_t *fBufferEnd = fbpointer + GFX_MONO_LCD_FRAMEBUFFER_SIZE;
   2064a:	f503 7400 	add.w	r4, r3, #512	; 0x200
    if ((fbpointerTemp >= fBufferBegin) && (fbpointerTemp <= fBufferEnd)) {
   2064e:	42a0      	cmp	r0, r4
        *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
   20650:	bf98      	it	ls
   20652:	545a      	strbls	r2, [r3, r1]
    }
}
   20654:	f85d 4b04 	ldr.w	r4, [sp], #4
   20658:	4770      	bx	lr
   2065a:	4770      	bx	lr
   2065c:	2000e4dc 	.word	0x2000e4dc

Disassembly of section .text.fprintf%835:

00020660 <fiprintf>:
   20660:	b40e      	push	{r1, r2, r3}
   20662:	b503      	push	{r0, r1, lr}
   20664:	4601      	mov	r1, r0
   20666:	ab03      	add	r3, sp, #12
   20668:	4805      	ldr	r0, [pc, #20]	; (20680 <fiprintf+0x20>)
   2066a:	f853 2b04 	ldr.w	r2, [r3], #4
   2066e:	6800      	ldr	r0, [r0, #0]
   20670:	9301      	str	r3, [sp, #4]
   20672:	f7ee fa5f 	bl	eb34 <_vfiprintf_r>
   20676:	b002      	add	sp, #8
   20678:	f85d eb04 	ldr.w	lr, [sp], #4
   2067c:	b003      	add	sp, #12
   2067e:	4770      	bx	lr
   20680:	2000e4e4 	.word	0x2000e4e4

Disassembly of section .text.strncmp%836:

00020684 <strncmp>:
   20684:	b510      	push	{r4, lr}
   20686:	b16a      	cbz	r2, 206a4 <strncmp+0x20>
   20688:	3901      	subs	r1, #1
   2068a:	1884      	adds	r4, r0, r2
   2068c:	f810 3b01 	ldrb.w	r3, [r0], #1
   20690:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   20694:	4293      	cmp	r3, r2
   20696:	d103      	bne.n	206a0 <strncmp+0x1c>
   20698:	42a0      	cmp	r0, r4
   2069a:	d001      	beq.n	206a0 <strncmp+0x1c>
   2069c:	2b00      	cmp	r3, #0
   2069e:	d1f5      	bne.n	2068c <strncmp+0x8>
   206a0:	1a98      	subs	r0, r3, r2
   206a2:	bd10      	pop	{r4, pc}
   206a4:	4610      	mov	r0, r2
   206a6:	e7fc      	b.n	206a2 <strncmp+0x1e>

Disassembly of section .text.__ascii_mbtowc%837:

000206a8 <__ascii_mbtowc>:
   206a8:	b082      	sub	sp, #8
   206aa:	b901      	cbnz	r1, 206ae <__ascii_mbtowc+0x6>
   206ac:	a901      	add	r1, sp, #4
   206ae:	b142      	cbz	r2, 206c2 <__ascii_mbtowc+0x1a>
   206b0:	b14b      	cbz	r3, 206c6 <__ascii_mbtowc+0x1e>
   206b2:	7813      	ldrb	r3, [r2, #0]
   206b4:	600b      	str	r3, [r1, #0]
   206b6:	7812      	ldrb	r2, [r2, #0]
   206b8:	1c10      	adds	r0, r2, #0
   206ba:	bf18      	it	ne
   206bc:	2001      	movne	r0, #1
   206be:	b002      	add	sp, #8
   206c0:	4770      	bx	lr
   206c2:	4610      	mov	r0, r2
   206c4:	e7fb      	b.n	206be <__ascii_mbtowc+0x16>
   206c6:	f06f 0001 	mvn.w	r0, #1
   206ca:	e7f8      	b.n	206be <__ascii_mbtowc+0x16>

Disassembly of section .text._kill_r%838:

000206cc <_kill_r>:
   206cc:	b538      	push	{r3, r4, r5, lr}
   206ce:	4c07      	ldr	r4, [pc, #28]	; (206ec <_kill_r+0x20>)
   206d0:	2300      	movs	r3, #0
   206d2:	4605      	mov	r5, r0
   206d4:	4608      	mov	r0, r1
   206d6:	4611      	mov	r1, r2
   206d8:	6023      	str	r3, [r4, #0]
   206da:	f001 fdd5 	bl	22288 <_kill>
   206de:	1c43      	adds	r3, r0, #1
   206e0:	d102      	bne.n	206e8 <_kill_r+0x1c>
   206e2:	6823      	ldr	r3, [r4, #0]
   206e4:	b103      	cbz	r3, 206e8 <_kill_r+0x1c>
   206e6:	602b      	str	r3, [r5, #0]
   206e8:	bd38      	pop	{r3, r4, r5, pc}
   206ea:	bf00      	nop
   206ec:	20000000 	.word	0x20000000

Disassembly of section .text.__sseek%839:

000206f0 <__sseek>:
   206f0:	b510      	push	{r4, lr}
   206f2:	460c      	mov	r4, r1
   206f4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   206f8:	f000 f830 	bl	2075c <_lseek_r>
   206fc:	1c43      	adds	r3, r0, #1
   206fe:	89a3      	ldrh	r3, [r4, #12]
   20700:	bf15      	itete	ne
   20702:	6560      	strne	r0, [r4, #84]	; 0x54
   20704:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
   20708:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
   2070c:	81a3      	strheq	r3, [r4, #12]
   2070e:	bf18      	it	ne
   20710:	81a3      	strhne	r3, [r4, #12]
   20712:	bd10      	pop	{r4, pc}

Disassembly of section .text._write_r%840:

00020714 <_write_r>:
   20714:	b538      	push	{r3, r4, r5, lr}
   20716:	4c07      	ldr	r4, [pc, #28]	; (20734 <_write_r+0x20>)
   20718:	4605      	mov	r5, r0
   2071a:	4608      	mov	r0, r1
   2071c:	4611      	mov	r1, r2
   2071e:	2200      	movs	r2, #0
   20720:	6022      	str	r2, [r4, #0]
   20722:	461a      	mov	r2, r3
   20724:	f001 fdb6 	bl	22294 <_write>
   20728:	1c43      	adds	r3, r0, #1
   2072a:	d102      	bne.n	20732 <_write_r+0x1e>
   2072c:	6823      	ldr	r3, [r4, #0]
   2072e:	b103      	cbz	r3, 20732 <_write_r+0x1e>
   20730:	602b      	str	r3, [r5, #0]
   20732:	bd38      	pop	{r3, r4, r5, pc}
   20734:	20000000 	.word	0x20000000

Disassembly of section .text._fstat_r%841:

00020738 <_fstat_r>:
   20738:	b538      	push	{r3, r4, r5, lr}
   2073a:	4c07      	ldr	r4, [pc, #28]	; (20758 <_fstat_r+0x20>)
   2073c:	2300      	movs	r3, #0
   2073e:	4605      	mov	r5, r0
   20740:	4608      	mov	r0, r1
   20742:	4611      	mov	r1, r2
   20744:	6023      	str	r3, [r4, #0]
   20746:	f001 fd99 	bl	2227c <_fstat>
   2074a:	1c43      	adds	r3, r0, #1
   2074c:	d102      	bne.n	20754 <_fstat_r+0x1c>
   2074e:	6823      	ldr	r3, [r4, #0]
   20750:	b103      	cbz	r3, 20754 <_fstat_r+0x1c>
   20752:	602b      	str	r3, [r5, #0]
   20754:	bd38      	pop	{r3, r4, r5, pc}
   20756:	bf00      	nop
   20758:	20000000 	.word	0x20000000

Disassembly of section .text._lseek_r%842:

0002075c <_lseek_r>:
   2075c:	b538      	push	{r3, r4, r5, lr}
   2075e:	4c07      	ldr	r4, [pc, #28]	; (2077c <_lseek_r+0x20>)
   20760:	4605      	mov	r5, r0
   20762:	4608      	mov	r0, r1
   20764:	4611      	mov	r1, r2
   20766:	2200      	movs	r2, #0
   20768:	6022      	str	r2, [r4, #0]
   2076a:	461a      	mov	r2, r3
   2076c:	f001 fd8e 	bl	2228c <_lseek>
   20770:	1c43      	adds	r3, r0, #1
   20772:	d102      	bne.n	2077a <_lseek_r+0x1e>
   20774:	6823      	ldr	r3, [r4, #0]
   20776:	b103      	cbz	r3, 2077a <_lseek_r+0x1e>
   20778:	602b      	str	r3, [r5, #0]
   2077a:	bd38      	pop	{r3, r4, r5, pc}
   2077c:	20000000 	.word	0x20000000

Disassembly of section .text._read_r%843:

00020780 <_read_r>:
   20780:	b538      	push	{r3, r4, r5, lr}
   20782:	4c07      	ldr	r4, [pc, #28]	; (207a0 <_read_r+0x20>)
   20784:	4605      	mov	r5, r0
   20786:	4608      	mov	r0, r1
   20788:	4611      	mov	r1, r2
   2078a:	2200      	movs	r2, #0
   2078c:	6022      	str	r2, [r4, #0]
   2078e:	461a      	mov	r2, r3
   20790:	f001 fd7e 	bl	22290 <_read>
   20794:	1c43      	adds	r3, r0, #1
   20796:	d102      	bne.n	2079e <_read_r+0x1e>
   20798:	6823      	ldr	r3, [r4, #0]
   2079a:	b103      	cbz	r3, 2079e <_read_r+0x1e>
   2079c:	602b      	str	r3, [r5, #0]
   2079e:	bd38      	pop	{r3, r4, r5, pc}
   207a0:	20000000 	.word	0x20000000

Disassembly of section .text._DRV_PHY_SMITransfer_Wait%844:

000207a4 <_DRV_PHY_SMITransfer_Wait>:
{
   207a4:	b510      	push	{r4, lr}
   207a6:	4604      	mov	r4, r0
    DRV_ETHPHY_SMI_TXFER_RES opRes = _DRV_PHY_SMITransferWaitComplete(hClientObj);
   207a8:	f7fb fbe7 	bl	1bf7a <_DRV_PHY_SMITransferWaitComplete>
    if(opRes < 0)
   207ac:	2800      	cmp	r0, #0
   207ae:	db03      	blt.n	207b8 <_DRV_PHY_SMITransfer_Wait+0x14>
    else if(opRes == DRV_ETHPHY_SMI_TXFER_RES_WAIT)
   207b0:	3802      	subs	r0, #2
   207b2:	bf18      	it	ne
   207b4:	2001      	movne	r0, #1
}
   207b6:	bd10      	pop	{r4, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   207b8:	f06f 0108 	mvn.w	r1, #8
   207bc:	4620      	mov	r0, r4
   207be:	f7ff fab5 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
        return false;
   207c2:	2000      	movs	r0, #0
   207c4:	e7f7      	b.n	207b6 <_DRV_PHY_SMITransfer_Wait+0x12>

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListInitialize%845:

000207c6 <TCPIP_Helper_ProtectedSingleListInitialize>:
{
   207c6:	b510      	push	{r4, lr}
   207c8:	4604      	mov	r4, r0
    pL->head = pL->tail = 0;
   207ca:	2100      	movs	r1, #0
   207cc:	6041      	str	r1, [r0, #4]
   207ce:	6001      	str	r1, [r0, #0]
    pL->nNodes = 0;
   207d0:	6081      	str	r1, [r0, #8]
    pL->semValid = (OSAL_SEM_Create(&pL->semaphore, OSAL_SEM_TYPE_BINARY, 1, 1) == OSAL_RESULT_TRUE);
   207d2:	2301      	movs	r3, #1
   207d4:	461a      	mov	r2, r3
   207d6:	300c      	adds	r0, #12
   207d8:	f7fb fb4c 	bl	1be74 <OSAL_SEM_Create>
   207dc:	2801      	cmp	r0, #1
   207de:	bf14      	ite	ne
   207e0:	2000      	movne	r0, #0
   207e2:	2001      	moveq	r0, #1
   207e4:	7420      	strb	r0, [r4, #16]
}
   207e6:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_STACK_NetAddressMacSet%846:

000207e8 <TCPIP_STACK_NetAddressMacSet>:
   207e8:	b168      	cbz	r0, 20806 <TCPIP_STACK_NetAddressMacSet+0x1e>
   207ea:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   207ee:	f012 0f40 	tst.w	r2, #64	; 0x40
   207f2:	d101      	bne.n	207f8 <TCPIP_STACK_NetAddressMacSet+0x10>
    return false;
   207f4:	2000      	movs	r0, #0
}
   207f6:	4770      	bx	lr
        memcpy(pNetIf->netMACAddr.v, pAddr->v, sizeof(pNetIf->netMACAddr));
   207f8:	680a      	ldr	r2, [r1, #0]
   207fa:	63c2      	str	r2, [r0, #60]	; 0x3c
   207fc:	888a      	ldrh	r2, [r1, #4]
   207fe:	f8a0 2040 	strh.w	r2, [r0, #64]	; 0x40
        return true;
   20802:	2001      	movs	r0, #1
   20804:	4770      	bx	lr
    return false;
   20806:	2000      	movs	r0, #0
   20808:	4770      	bx	lr

Disassembly of section .text.TCPIP_UDP_Discard%847:

0002080a <TCPIP_UDP_Discard>:
{
   2080a:	b510      	push	{r4, lr}
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   2080c:	f7ff fc0a 	bl	20024 <_UDPSocketDcpt>
    if(pSkt)
   20810:	b150      	cbz	r0, 20828 <TCPIP_UDP_Discard+0x1e>
   20812:	4603      	mov	r3, r0
        if(pSkt->pCurrRxSeg)
   20814:	6b02      	ldr	r2, [r0, #48]	; 0x30
   20816:	b12a      	cbz	r2, 20824 <TCPIP_UDP_Discard+0x1a>
            nBytes = pSkt->rxTotLen;
   20818:	8ec4      	ldrh	r4, [r0, #54]	; 0x36
        _UDPUpdatePacketLock(pSkt);
   2081a:	4618      	mov	r0, r3
   2081c:	f7ff fc16 	bl	2004c <_UDPUpdatePacketLock>
}
   20820:	4620      	mov	r0, r4
   20822:	bd10      	pop	{r4, pc}
    uint16_t nBytes = 0;
   20824:	2400      	movs	r4, #0
   20826:	e7f8      	b.n	2081a <TCPIP_UDP_Discard+0x10>
   20828:	2400      	movs	r4, #0
   2082a:	e7f9      	b.n	20820 <TCPIP_UDP_Discard+0x16>

Disassembly of section .rodata%848:

0002082c <.rodata%848>:
   2082c:	33323130 	.word	0x33323130
   20830:	37363534 	.word	0x37363534
   20834:	42413938 	.word	0x42413938
   20838:	46454443 	.word	0x46454443
   2083c:	32313000 	.word	0x32313000
   20840:	36353433 	.word	0x36353433
   20844:	61393837 	.word	0x61393837
   20848:	65646362 	.word	0x65646362
   2084c:	Address 0x0002084c is out of bounds.


Disassembly of section .text.__sread%849:

0002084e <__sread>:
   2084e:	b510      	push	{r4, lr}
   20850:	460c      	mov	r4, r1
   20852:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   20856:	f7ff ff93 	bl	20780 <_read_r>
   2085a:	2800      	cmp	r0, #0
   2085c:	bfab      	itete	ge
   2085e:	6d63      	ldrge	r3, [r4, #84]	; 0x54
   20860:	89a3      	ldrhlt	r3, [r4, #12]
   20862:	181b      	addge	r3, r3, r0
   20864:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
   20868:	bfac      	ite	ge
   2086a:	6563      	strge	r3, [r4, #84]	; 0x54
   2086c:	81a3      	strhlt	r3, [r4, #12]
   2086e:	bd10      	pop	{r4, pc}

Disassembly of section .text.DRV_ETHPHY_Status%850:

00020870 <DRV_ETHPHY_Status>:
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   20870:	4b06      	ldr	r3, [pc, #24]	; (2088c <DRV_ETHPHY_Status+0x1c>)
   20872:	4283      	cmp	r3, r0
   20874:	d103      	bne.n	2087e <DRV_ETHPHY_Status+0xe>
    if(phyInst != 0)
   20876:	b128      	cbz	r0, 20884 <DRV_ETHPHY_Status+0x14>
        return( phyInst->status ) ;
   20878:	f993 0004 	ldrsb.w	r0, [r3, #4]
   2087c:	4770      	bx	lr
    return SYS_STATUS_ERROR;
   2087e:	f04f 30ff 	mov.w	r0, #4294967295
   20882:	4770      	bx	lr
   20884:	f04f 30ff 	mov.w	r0, #4294967295
} 
   20888:	4770      	bx	lr
   2088a:	bf00      	nop
   2088c:	2000de18 	.word	0x2000de18

Disassembly of section .text.DRV_ETHPHY_ClientStatus%851:

00020890 <DRV_ETHPHY_ClientStatus>:
    if( hClientObj != 0)
   20890:	b130      	cbz	r0, 208a0 <DRV_ETHPHY_ClientStatus+0x10>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   20892:	68c1      	ldr	r1, [r0, #12]
   20894:	4a05      	ldr	r2, [pc, #20]	; (208ac <DRV_ETHPHY_ClientStatus+0x1c>)
   20896:	4291      	cmp	r1, r2
   20898:	d105      	bne.n	208a6 <DRV_ETHPHY_ClientStatus+0x16>
            return( hClientObj->status );
   2089a:	f990 0008 	ldrsb.w	r0, [r0, #8]
   2089e:	4770      	bx	lr
    return DRV_ETHPHY_CLIENT_STATUS_ERROR;
   208a0:	f04f 30ff 	mov.w	r0, #4294967295
   208a4:	4770      	bx	lr
   208a6:	f04f 30ff 	mov.w	r0, #4294967295
}
   208aa:	4770      	bx	lr
   208ac:	2000de18 	.word	0x2000de18

Disassembly of section .text.DRV_ETHPHY_ClientOperationResult%852:

000208b0 <DRV_ETHPHY_ClientOperationResult>:
    if( hClientObj != 0)
   208b0:	b130      	cbz	r0, 208c0 <DRV_ETHPHY_ClientOperationResult+0x10>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   208b2:	68c1      	ldr	r1, [r0, #12]
   208b4:	4a05      	ldr	r2, [pc, #20]	; (208cc <DRV_ETHPHY_ClientOperationResult+0x1c>)
   208b6:	4291      	cmp	r1, r2
   208b8:	d105      	bne.n	208c6 <DRV_ETHPHY_ClientOperationResult+0x16>
            return( hClientObj->operRes );
   208ba:	f990 002c 	ldrsb.w	r0, [r0, #44]	; 0x2c
   208be:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   208c0:	f06f 000a 	mvn.w	r0, #10
   208c4:	4770      	bx	lr
   208c6:	f06f 000a 	mvn.w	r0, #10
}
   208ca:	4770      	bx	lr
   208cc:	2000de18 	.word	0x2000de18

Disassembly of section .text._DRV_ETHPHY_ClientOpReset%853:

000208d0 <_DRV_ETHPHY_ClientOpReset>:
{
   208d0:	b508      	push	{r3, lr}
    if((unsigned int)hClientObj->operPhase < sizeof(_DRV_PHY_ResetPhasesTbl)/sizeof(*_DRV_PHY_ResetPhasesTbl))
   208d2:	8bc3      	ldrh	r3, [r0, #30]
   208d4:	2b02      	cmp	r3, #2
   208d6:	d804      	bhi.n	208e2 <_DRV_ETHPHY_ClientOpReset+0x12>
        (*_DRV_PHY_ResetPhasesTbl[hClientObj->operPhase])(hClientObj);
   208d8:	4a04      	ldr	r2, [pc, #16]	; (208ec <_DRV_ETHPHY_ClientOpReset+0x1c>)
   208da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   208de:	4798      	blx	r3
}
   208e0:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   208e2:	f06f 0108 	mvn.w	r1, #8
   208e6:	f7ff fa21 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
}
   208ea:	e7f9      	b.n	208e0 <_DRV_ETHPHY_ClientOpReset+0x10>
   208ec:	00021d68 	.word	0x00021d68

Disassembly of section .text._DRV_ETHPHY_ClientOpNegRestart%854:

000208f0 <_DRV_ETHPHY_ClientOpNegRestart>:
{
   208f0:	b508      	push	{r3, lr}
    if((unsigned int)hClientObj->operPhase < sizeof(_DRV_PHY_NegRestartPhasesTbl)/sizeof(*_DRV_PHY_NegRestartPhasesTbl))
   208f2:	8bc3      	ldrh	r3, [r0, #30]
   208f4:	2b02      	cmp	r3, #2
   208f6:	d804      	bhi.n	20902 <_DRV_ETHPHY_ClientOpNegRestart+0x12>
        (*_DRV_PHY_NegRestartPhasesTbl[hClientObj->operPhase])(hClientObj);
   208f8:	4a04      	ldr	r2, [pc, #16]	; (2090c <_DRV_ETHPHY_ClientOpNegRestart+0x1c>)
   208fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   208fe:	4798      	blx	r3
}
   20900:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   20902:	f06f 0108 	mvn.w	r1, #8
   20906:	f7ff fa11 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
}
   2090a:	e7f9      	b.n	20900 <_DRV_ETHPHY_ClientOpNegRestart+0x10>
   2090c:	00021d5c 	.word	0x00021d5c

Disassembly of section .text._DRV_ETHPHY_ClientOpNegResult%855:

00020910 <_DRV_ETHPHY_ClientOpNegResult>:
{
   20910:	b508      	push	{r3, lr}
    if((unsigned int)hClientObj->operPhase < sizeof(_DRV_PHY_NegResultPhasesTbl)/sizeof(*_DRV_PHY_NegResultPhasesTbl))
   20912:	8bc3      	ldrh	r3, [r0, #30]
   20914:	2b04      	cmp	r3, #4
   20916:	d804      	bhi.n	20922 <_DRV_ETHPHY_ClientOpNegResult+0x12>
        (*_DRV_PHY_NegResultPhasesTbl[hClientObj->operPhase])(hClientObj);
   20918:	4a04      	ldr	r2, [pc, #16]	; (2092c <_DRV_ETHPHY_ClientOpNegResult+0x1c>)
   2091a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   2091e:	4798      	blx	r3
}
   20920:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   20922:	f06f 0108 	mvn.w	r1, #8
   20926:	f7ff fa01 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
}
   2092a:	e7f9      	b.n	20920 <_DRV_ETHPHY_ClientOpNegResult+0x10>
   2092c:	000218a0 	.word	0x000218a0

Disassembly of section .text._DRV_ETHPHY_ClientOpNegComplete%856:

00020930 <_DRV_ETHPHY_ClientOpNegComplete>:
{
   20930:	b508      	push	{r3, lr}
    if((unsigned int)hClientObj->operPhase < sizeof(_DRV_PHY_NegCompletePhasesTbl)/sizeof(*_DRV_PHY_NegCompletePhasesTbl))
   20932:	8bc3      	ldrh	r3, [r0, #30]
   20934:	2b05      	cmp	r3, #5
   20936:	d804      	bhi.n	20942 <_DRV_ETHPHY_ClientOpNegComplete+0x12>
        (*_DRV_PHY_NegCompletePhasesTbl[hClientObj->operPhase])(hClientObj);
   20938:	4a04      	ldr	r2, [pc, #16]	; (2094c <_DRV_ETHPHY_ClientOpNegComplete+0x1c>)
   2093a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   2093e:	4798      	blx	r3
}
   20940:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   20942:	f06f 0108 	mvn.w	r1, #8
   20946:	f7ff f9f1 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
}
   2094a:	e7f9      	b.n	20940 <_DRV_ETHPHY_ClientOpNegComplete+0x10>
   2094c:	0002149c 	.word	0x0002149c

Disassembly of section .text._DRV_ETHPHY_ClientOpLinkStat%857:

00020950 <_DRV_ETHPHY_ClientOpLinkStat>:
{
   20950:	b508      	push	{r3, lr}
    if((unsigned int)hClientObj->operPhase < sizeof(_DRV_PHY_LinkStatPhasesTbl)/sizeof(*_DRV_PHY_LinkStatPhasesTbl))
   20952:	8bc3      	ldrh	r3, [r0, #30]
   20954:	2b02      	cmp	r3, #2
   20956:	d804      	bhi.n	20962 <_DRV_ETHPHY_ClientOpLinkStat+0x12>
        (*_DRV_PHY_LinkStatPhasesTbl[hClientObj->operPhase])(hClientObj);
   20958:	4a04      	ldr	r2, [pc, #16]	; (2096c <_DRV_ETHPHY_ClientOpLinkStat+0x1c>)
   2095a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   2095e:	4798      	blx	r3
}
   20960:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   20962:	f06f 0108 	mvn.w	r1, #8
   20966:	f7ff f9e1 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
}
   2096a:	e7f9      	b.n	20960 <_DRV_ETHPHY_ClientOpLinkStat+0x10>
   2096c:	00017bf4 	.word	0x00017bf4

Disassembly of section .text._DRV_ETHPHY_ClientOpSetup%858:

00020970 <_DRV_ETHPHY_ClientOpSetup>:
{
   20970:	b508      	push	{r3, lr}
    if((unsigned int)hClientObj->operPhase >= sizeof(_DRV_PHY_SetupPhasesTbl)/sizeof(*_DRV_PHY_SetupPhasesTbl))
   20972:	8bc3      	ldrh	r3, [r0, #30]
   20974:	2b03      	cmp	r3, #3
   20976:	d804      	bhi.n	20982 <_DRV_ETHPHY_ClientOpSetup+0x12>
        (*_DRV_PHY_SetupPhasesTbl[hClientObj->operPhase])(hClientObj);
   20978:	4a04      	ldr	r2, [pc, #16]	; (2098c <_DRV_ETHPHY_ClientOpSetup+0x1c>)
   2097a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   2097e:	4798      	blx	r3
}
   20980:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   20982:	f06f 0108 	mvn.w	r1, #8
   20986:	f7ff f9d1 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
   2098a:	e7f9      	b.n	20980 <_DRV_ETHPHY_ClientOpSetup+0x10>
   2098c:	00021b3c 	.word	0x00021b3c

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate%859:

00020990 <_DRV_ETHPHY_SetupPhaseNegotiate>:
{
   20990:	b508      	push	{r3, lr}
    if(hClientObj->operSubPhase <  sizeof(_DRV_PHY_SetupPhaseNegotiateSubPhaseTbl) / sizeof(*_DRV_PHY_SetupPhaseNegotiateSubPhaseTbl))
   20992:	8c03      	ldrh	r3, [r0, #32]
   20994:	2b07      	cmp	r3, #7
   20996:	d804      	bhi.n	209a2 <_DRV_ETHPHY_SetupPhaseNegotiate+0x12>
        (*_DRV_PHY_SetupPhaseNegotiateSubPhaseTbl[hClientObj->operSubPhase])(hClientObj);
   20998:	4a04      	ldr	r2, [pc, #16]	; (209ac <_DRV_ETHPHY_SetupPhaseNegotiate+0x1c>)
   2099a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   2099e:	4798      	blx	r3
}
   209a0:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   209a2:	f06f 0108 	mvn.w	r1, #8
   209a6:	f7ff f9c1 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
}
   209aa:	e7f9      	b.n	209a0 <_DRV_ETHPHY_SetupPhaseNegotiate+0x10>
   209ac:	000209d0 	.word	0x000209d0

Disassembly of section .rodata%860:

000209b0 <.rodata%860>:
   209b0:	5f565244 	.word	0x5f565244
   209b4:	20594850 	.word	0x20594850
   209b8:	7265706f 	.word	0x7265706f
   209bc:	6f697461 	.word	0x6f697461
   209c0:	7265206e 	.word	0x7265206e
   209c4:	3a726f72 	.word	0x3a726f72
   209c8:	0d642520 	.word	0x0d642520
   209cc:	000a      	.short	0x000a
   209ce:	bf00      	nop

Disassembly of section .rodata._DRV_PHY_SetupPhaseNegotiateSubPhaseTbl%861:

000209d0 <_DRV_PHY_SetupPhaseNegotiateSubPhaseTbl>:
   209d0:	782d 0001 e49d 0001 ea1d 0001 f029 0001     -x..........)...
   209e0:	9a87 0001 1425 0002 e66d 0001 c82d 0001     ....%...m...-...

Disassembly of section .text.DRV_GMAC_Close%862:

000209f0 <DRV_GMAC_Close>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   209f0:	4b06      	ldr	r3, [pc, #24]	; (20a0c <DRV_GMAC_Close+0x1c>)
   209f2:	4283      	cmp	r3, r0
   209f4:	d109      	bne.n	20a0a <DRV_GMAC_Close+0x1a>
    if(pMACDrv != 0)
   209f6:	b140      	cbz	r0, 20a0a <DRV_GMAC_Close+0x1a>
        if(pMACDrv->sGmacData._macFlags._init == 1)	
   209f8:	7d9b      	ldrb	r3, [r3, #22]
   209fa:	f013 0f01 	tst.w	r3, #1
   209fe:	d004      	beq.n	20a0a <DRV_GMAC_Close+0x1a>
            pMACDrv->sGmacData._macFlags._open = 0;
   20a00:	4b02      	ldr	r3, [pc, #8]	; (20a0c <DRV_GMAC_Close+0x1c>)
   20a02:	7d9a      	ldrb	r2, [r3, #22]
   20a04:	f36f 0241 	bfc	r2, #1, #1
   20a08:	759a      	strb	r2, [r3, #22]
}
   20a0a:	4770      	bx	lr
   20a0c:	2000d8b8 	.word	0x2000d8b8

Disassembly of section .text.DRV_GMAC_Deinitialize%863:

00020a10 <DRV_GMAC_Deinitialize>:
{
   20a10:	b508      	push	{r3, lr}
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   20a12:	4b06      	ldr	r3, [pc, #24]	; (20a2c <DRV_GMAC_Deinitialize+0x1c>)
   20a14:	4283      	cmp	r3, r0
   20a16:	d104      	bne.n	20a22 <DRV_GMAC_Deinitialize+0x12>
    if(pMACDrv != 0)
   20a18:	b118      	cbz	r0, 20a22 <DRV_GMAC_Deinitialize+0x12>
        if(pMACDrv->sGmacData._macFlags._init != 0)
   20a1a:	7d9b      	ldrb	r3, [r3, #22]
   20a1c:	f013 0f01 	tst.w	r3, #1
   20a20:	d100      	bne.n	20a24 <DRV_GMAC_Deinitialize+0x14>
}
   20a22:	bd08      	pop	{r3, pc}
            _MACDeinit(pMACDrv);
   20a24:	4801      	ldr	r0, [pc, #4]	; (20a2c <DRV_GMAC_Deinitialize+0x1c>)
   20a26:	f7f1 fb5b 	bl	120e0 <_MACDeinit>
}
   20a2a:	e7fa      	b.n	20a22 <DRV_GMAC_Deinitialize+0x12>
   20a2c:	2000d8b8 	.word	0x2000d8b8

Disassembly of section .text.DRV_PIC32CGMAC_LibTransferEnable%864:

00020a30 <DRV_PIC32CGMAC_LibTransferEnable>:
	GMAC_REGS->GMAC_NCR |= GMAC_NCR_TXEN_Msk;
   20a30:	4b06      	ldr	r3, [pc, #24]	; (20a4c <DRV_PIC32CGMAC_LibTransferEnable+0x1c>)
   20a32:	681a      	ldr	r2, [r3, #0]
   20a34:	f042 0208 	orr.w	r2, r2, #8
   20a38:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_NCR |= GMAC_NCR_RXEN_Msk;	
   20a3a:	681a      	ldr	r2, [r3, #0]
   20a3c:	f042 0204 	orr.w	r2, r2, #4
   20a40:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_NCR |= GMAC_NCR_WESTAT_Msk;
   20a42:	681a      	ldr	r2, [r3, #0]
   20a44:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   20a48:	601a      	str	r2, [r3, #0]
}
   20a4a:	4770      	bx	lr
   20a4c:	42000800 	.word	0x42000800

Disassembly of section .text.DRV_GMAC_LibDescriptorsPoolAdd%865:

00020a50 <DRV_GMAC_LibDescriptorsPoolAdd>:
    if(dType == DRV_GMAC_DCPT_TYPE_TX)
   20a50:	2902      	cmp	r1, #2
   20a52:	d005      	beq.n	20a60 <DRV_GMAC_LibDescriptorsPoolAdd+0x10>
    else if(dType == DRV_GMAC_DCPT_TYPE_RX)
   20a54:	2901      	cmp	r1, #1
        pMACDrv->sGmacData.gmac_queue[0].pRxDesc = gmac_dcpt_array.sRxDesc_queue0;
   20a56:	bf04      	itt	eq
   20a58:	4b03      	ldreq	r3, [pc, #12]	; (20a68 <DRV_GMAC_LibDescriptorsPoolAdd+0x18>)
   20a5a:	f8c0 3090 	streq.w	r3, [r0, #144]	; 0x90
}
   20a5e:	4770      	bx	lr
        pMACDrv->sGmacData.gmac_queue[0].pTxDesc = gmac_dcpt_array.sTxDesc_queue0;
   20a60:	4b02      	ldr	r3, [pc, #8]	; (20a6c <DRV_GMAC_LibDescriptorsPoolAdd+0x1c>)
   20a62:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
   20a66:	4770      	bx	lr
   20a68:	2000dd58 	.word	0x2000dd58
   20a6c:	2000dd18 	.word	0x2000dd18

Disassembly of section .text._SwapARPPacket%866:

00020a70 <_SwapARPPacket>:
    p->HardwareType     = TCPIP_Helper_htons(p->HardwareType);
   20a70:	8802      	ldrh	r2, [r0, #0]
   20a72:	0a13      	lsrs	r3, r2, #8
   20a74:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   20a78:	8003      	strh	r3, [r0, #0]
    p->Protocol         = TCPIP_Helper_htons(p->Protocol);
   20a7a:	8842      	ldrh	r2, [r0, #2]
   20a7c:	0a13      	lsrs	r3, r2, #8
   20a7e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   20a82:	8043      	strh	r3, [r0, #2]
    p->Operation        = TCPIP_Helper_htons(p->Operation);
   20a84:	88c2      	ldrh	r2, [r0, #6]
   20a86:	0a13      	lsrs	r3, r2, #8
   20a88:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   20a8c:	80c3      	strh	r3, [r0, #6]
}
   20a8e:	4770      	bx	lr

Disassembly of section .text.TCPIP_DNS_OAHASH_KeyHash%867:

00020a90 <TCPIP_DNS_OAHASH_KeyHash>:
{
   20a90:	b538      	push	{r3, r4, r5, lr}
   20a92:	4605      	mov	r5, r0
   20a94:	460c      	mov	r4, r1
    hostnameLen = strlen((const char*)dnsHostNameKey);
   20a96:	4608      	mov	r0, r1
   20a98:	f001 f908 	bl	21cac <strlen>
    return fnv_32_hash(dnsHostNameKey, hostnameLen) % (pOH->hEntries);
   20a9c:	4601      	mov	r1, r0
   20a9e:	4620      	mov	r0, r4
   20aa0:	f7fe fb9a 	bl	1f1d8 <fnv_32_hash>
   20aa4:	68eb      	ldr	r3, [r5, #12]
   20aa6:	fbb0 f2f3 	udiv	r2, r0, r3
}
   20aaa:	fb02 0013 	mls	r0, r2, r3, r0
   20aae:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListLock%868:

00020ab0 <TCPIP_Helper_ProtectedSingleListLock>:

bool TCPIP_Helper_ProtectedSingleListLock(PROTECTED_SINGLE_LIST* pL)
{
   20ab0:	b508      	push	{r3, lr}
   20ab2:	4603      	mov	r3, r0
    if(pL->semValid)
   20ab4:	7c00      	ldrb	r0, [r0, #16]
   20ab6:	b900      	cbnz	r0, 20aba <TCPIP_Helper_ProtectedSingleListLock+0xa>
    {
        return (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE);
    }

    return false;
}
   20ab8:	bd08      	pop	{r3, pc}
        return (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE);
   20aba:	f64f 71ff 	movw	r1, #65535	; 0xffff
   20abe:	f103 000c 	add.w	r0, r3, #12
   20ac2:	f000 f96f 	bl	20da4 <OSAL_SEM_Pend>
   20ac6:	2801      	cmp	r0, #1
   20ac8:	bf14      	ite	ne
   20aca:	2000      	movne	r0, #0
   20acc:	2001      	moveq	r0, #1
   20ace:	e7f3      	b.n	20ab8 <TCPIP_Helper_ProtectedSingleListLock+0x8>

Disassembly of section .rodata.TCPIP_MAC_POWER_TBL%869:

00020ad0 <TCPIP_MAC_POWER_TBL>:
	...
   20ad8:	0001 0000 dba0 0001 0002 0000 dba8 0001     ................
   20ae8:	0003 0000 dbac 0001                         ........

Disassembly of section .text.TCPIP_STACK_NetDefaultSet%870:

00020af0 <TCPIP_STACK_NetDefaultSet>:
   20af0:	b150      	cbz	r0, 20b08 <TCPIP_STACK_NetDefaultSet+0x18>
   20af2:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20af6:	f012 0f40 	tst.w	r2, #64	; 0x40
   20afa:	d101      	bne.n	20b00 <TCPIP_STACK_NetDefaultSet+0x10>
    return false;
   20afc:	2000      	movs	r0, #0
}
   20afe:	4770      	bx	lr
        tcpipDefIf.defaultNet = pNewIf;
   20b00:	4a02      	ldr	r2, [pc, #8]	; (20b0c <TCPIP_STACK_NetDefaultSet+0x1c>)
   20b02:	6010      	str	r0, [r2, #0]
        return true;
   20b04:	2001      	movs	r0, #1
   20b06:	4770      	bx	lr
    return false;
   20b08:	2000      	movs	r0, #0
   20b0a:	4770      	bx	lr
   20b0c:	2000e43c 	.word	0x2000e43c

Disassembly of section .text._TCPIPStackHandleToNetLinked%871:

00020b10 <_TCPIPStackHandleToNetLinked>:
   20b10:	b128      	cbz	r0, 20b1e <_TCPIPStackHandleToNetLinked+0xe>
   20b12:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20b16:	f012 0f40 	tst.w	r2, #64	; 0x40
   20b1a:	d101      	bne.n	20b20 <_TCPIPStackHandleToNetLinked+0x10>
    return 0;
   20b1c:	2000      	movs	r0, #0
}
   20b1e:	4770      	bx	lr
    if(pNetIf != 0 && pNetIf->exFlags.linkPrev != 0)
   20b20:	f890 2060 	ldrb.w	r2, [r0, #96]	; 0x60
   20b24:	f002 0201 	and.w	r2, r2, #1
        return pNetIf;
   20b28:	2a00      	cmp	r2, #0
   20b2a:	bf08      	it	eq
   20b2c:	2000      	moveq	r0, #0
   20b2e:	4770      	bx	lr

Disassembly of section .text.TCPIP_Notification_Remove%872:

00020b30 <TCPIP_Notification_Remove>:
{
   20b30:	b538      	push	{r3, r4, r5, lr}
   20b32:	4604      	mov	r4, r0
   20b34:	4608      	mov	r0, r1
   20b36:	4615      	mov	r5, r2
    if(TCPIP_Helper_ProtectedSingleListNodeRemove(notifyList, node))
   20b38:	4621      	mov	r1, r4
   20b3a:	f7fe fbad 	bl	1f298 <TCPIP_Helper_ProtectedSingleListNodeRemove>
   20b3e:	b128      	cbz	r0, 20b4c <TCPIP_Notification_Remove+0x1c>
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   20b40:	68eb      	ldr	r3, [r5, #12]
   20b42:	4621      	mov	r1, r4
   20b44:	4628      	mov	r0, r5
   20b46:	4798      	blx	r3
        return true;
   20b48:	2001      	movs	r0, #1
}
   20b4a:	bd38      	pop	{r3, r4, r5, pc}
    return false;
   20b4c:	2000      	movs	r0, #0
   20b4e:	e7fc      	b.n	20b4a <TCPIP_Notification_Remove+0x1a>

Disassembly of section .rodata%873:

00020b50 <.rodata%873>:
   20b50:	6b636150 	.word	0x6b636150
   20b54:	41207465 	.word	0x41207465
   20b58:	203a6b63 	.word	0x203a6b63
   20b5c:	6870726f 	.word	0x6870726f
   20b60:	70206e61 	.word	0x70206e61
   20b64:	656b6361 	.word	0x656b6361
   20b68:	0d202174 	.word	0x0d202174
   20b6c:	000a      	.short	0x000a
   20b6e:	bf00      	nop

Disassembly of section .text.TCPIP_UDP_DestinationPortSet%874:

00020b70 <TCPIP_UDP_DestinationPortSet>:
{
   20b70:	b510      	push	{r4, lr}
   20b72:	460c      	mov	r4, r1
    UDP_SOCKET_DCPT *pSkt = _UDPSocketDcpt(s);
   20b74:	f7ff fa56 	bl	20024 <_UDPSocketDcpt>
    if(pSkt != 0)
   20b78:	b140      	cbz	r0, 20b8c <TCPIP_UDP_DestinationPortSet+0x1c>
        pSkt->remotePort = remotePort;
   20b7a:	8504      	strh	r4, [r0, #40]	; 0x28
    pSkt->extFlags.rxEnable = 1;
   20b7c:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20b80:	f042 0202 	orr.w	r2, r2, #2
   20b84:	f880 2042 	strb.w	r2, [r0, #66]	; 0x42
        return true;
   20b88:	2001      	movs	r0, #1
}
   20b8a:	bd10      	pop	{r4, pc}
    return false;
   20b8c:	2000      	movs	r0, #0
   20b8e:	e7fc      	b.n	20b8a <TCPIP_UDP_DestinationPortSet+0x1a>

Disassembly of section .text._keyRightProcess%875:

00020b90 <_keyRightProcess>:
    if(pCmdIO->cmdPnt < pCmdIO->cmdEnd)
   20b90:	6982      	ldr	r2, [r0, #24]
   20b92:	69c3      	ldr	r3, [r0, #28]
   20b94:	429a      	cmp	r2, r3
   20b96:	d20a      	bcs.n	20bae <_keyRightProcess+0x1e>
{   // right arrow
   20b98:	b510      	push	{r4, lr}
   20b9a:	4604      	mov	r4, r0
        (*pCmdApi->msg)(cmdIoParam, pSeqDcpt->keyCode);
   20b9c:	6803      	ldr	r3, [r0, #0]
   20b9e:	681b      	ldr	r3, [r3, #0]
   20ba0:	6809      	ldr	r1, [r1, #0]
   20ba2:	6840      	ldr	r0, [r0, #4]
   20ba4:	4798      	blx	r3
        pCmdIO->cmdPnt++;
   20ba6:	69a3      	ldr	r3, [r4, #24]
   20ba8:	3301      	adds	r3, #1
   20baa:	61a3      	str	r3, [r4, #24]
}
   20bac:	bd10      	pop	{r4, pc}
   20bae:	4770      	bx	lr

Disassembly of section .text.GetCommandCharacter%876:

00020bb0 <GetCommandCharacter>:
{
   20bb0:	b500      	push	{lr}
   20bb2:	b083      	sub	sp, #12
    SYS_CONSOLE_Read(_cmdInitData.consoleIndex, &new_c, 1);
   20bb4:	2201      	movs	r2, #1
   20bb6:	f10d 0107 	add.w	r1, sp, #7
   20bba:	4b04      	ldr	r3, [pc, #16]	; (20bcc <GetCommandCharacter+0x1c>)
   20bbc:	8858      	ldrh	r0, [r3, #2]
   20bbe:	f7fe f899 	bl	1ecf4 <SYS_CONSOLE_Read>
}
   20bc2:	f89d 0007 	ldrb.w	r0, [sp, #7]
   20bc6:	b003      	add	sp, #12
   20bc8:	f85d fb04 	ldr.w	pc, [sp], #4
   20bcc:	2000e46c 	.word	0x2000e46c

Disassembly of section .text.SYS_INT_SourceRestore%877:

00020bd0 <SYS_INT_SourceRestore>:

void SYS_INT_SourceRestore( INT_SOURCE source, bool status )
{
    if( status ) {
   20bd0:	b151      	cbz	r1, 20be8 <SYS_INT_SourceRestore+0x18>
  if ((int32_t)(IRQn) >= 0)
   20bd2:	2800      	cmp	r0, #0
   20bd4:	db08      	blt.n	20be8 <SYS_INT_SourceRestore+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   20bd6:	0942      	lsrs	r2, r0, #5
   20bd8:	f000 001f 	and.w	r0, r0, #31
   20bdc:	2301      	movs	r3, #1
   20bde:	fa03 f000 	lsl.w	r0, r3, r0
   20be2:	4b02      	ldr	r3, [pc, #8]	; (20bec <SYS_INT_SourceRestore+0x1c>)
   20be4:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
        SYS_INT_SourceEnable( source );
    }
    return;
}
   20be8:	4770      	bx	lr
   20bea:	bf00      	nop
   20bec:	e000e100 	.word	0xe000e100

Disassembly of section .text.SYS_RANDOM_CryptoInitialize%878:

00020bf0 <SYS_RANDOM_CryptoInitialize>:
{
   20bf0:	b508      	push	{r3, lr}
    if(CRYPT_RNG_Initialize(&sysRandCtx) >= 0)
   20bf2:	4805      	ldr	r0, [pc, #20]	; (20c08 <SYS_RANDOM_CryptoInitialize+0x18>)
   20bf4:	f000 ff9a 	bl	21b2c <CRYPT_RNG_Initialize>
   20bf8:	2800      	cmp	r0, #0
        pRandCtx = 0;
   20bfa:	4803      	ldr	r0, [pc, #12]	; (20c08 <SYS_RANDOM_CryptoInitialize+0x18>)
   20bfc:	bfb8      	it	lt
   20bfe:	2000      	movlt	r0, #0
   20c00:	4b02      	ldr	r3, [pc, #8]	; (20c0c <SYS_RANDOM_CryptoInitialize+0x1c>)
   20c02:	6018      	str	r0, [r3, #0]
}
   20c04:	bd08      	pop	{r3, pc}
   20c06:	bf00      	nop
   20c08:	2000d7b0 	.word	0x2000d7b0
   20c0c:	2000e484 	.word	0x2000e484

Disassembly of section .rodata.tcpipPhyInitData_LAN867x%879:

00020c10 <tcpipPhyInitData_LAN867x>:
   20c10:	00000000 42000800 00010000 000218b4     .......B........
   20c20:	00000000 0001da34 000221c8 00000000     ....4....!......

Disassembly of section .text.prvTaskExitError%880:

00020c30 <prvTaskExitError>:
{
   20c30:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
   20c32:	2300      	movs	r3, #0
   20c34:	9301      	str	r3, [sp, #4]
	__asm volatile
   20c36:	f04f 0320 	mov.w	r3, #32
   20c3a:	f383 8811 	msr	BASEPRI, r3
   20c3e:	f3bf 8f6f 	isb	sy
   20c42:	f3bf 8f4f 	dsb	sy
	while( ulDummy == 0 )
   20c46:	9b01      	ldr	r3, [sp, #4]
   20c48:	2b00      	cmp	r3, #0
   20c4a:	d0fc      	beq.n	20c46 <prvTaskExitError+0x16>
}
   20c4c:	b002      	add	sp, #8
   20c4e:	4770      	bx	lr

Disassembly of section .text.vPortEnterCritical%881:

00020c50 <vPortEnterCritical>:
   20c50:	f04f 0320 	mov.w	r3, #32
   20c54:	f383 8811 	msr	BASEPRI, r3
   20c58:	f3bf 8f6f 	isb	sy
   20c5c:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
   20c60:	4a02      	ldr	r2, [pc, #8]	; (20c6c <vPortEnterCritical+0x1c>)
   20c62:	6813      	ldr	r3, [r2, #0]
   20c64:	3301      	adds	r3, #1
   20c66:	6013      	str	r3, [r2, #0]
}
   20c68:	4770      	bx	lr
   20c6a:	bf00      	nop
   20c6c:	2000e490 	.word	0x2000e490

Disassembly of section .rodata.reseedSeedA_data%882:

00020c70 <reseedSeedA_data>:
   20c70:	8e8a2be6 b641f1e8 e3660598 49c0e3bf     .+....A...f....I
   20c80:	acd4da03 229fdf2c 670a0180 d383bc39     ....,.."...g9...

Disassembly of section .text._sbrk_r%883:

00020c90 <_sbrk_r>:
   20c90:	b538      	push	{r3, r4, r5, lr}
   20c92:	4c06      	ldr	r4, [pc, #24]	; (20cac <_sbrk_r+0x1c>)
   20c94:	2300      	movs	r3, #0
   20c96:	4605      	mov	r5, r0
   20c98:	4608      	mov	r0, r1
   20c9a:	6023      	str	r3, [r4, #0]
   20c9c:	f7fe ff74 	bl	1fb88 <_sbrk>
   20ca0:	1c43      	adds	r3, r0, #1
   20ca2:	d102      	bne.n	20caa <_sbrk_r+0x1a>
   20ca4:	6823      	ldr	r3, [r4, #0]
   20ca6:	b103      	cbz	r3, 20caa <_sbrk_r+0x1a>
   20ca8:	602b      	str	r3, [r5, #0]
   20caa:	bd38      	pop	{r3, r4, r5, pc}
   20cac:	20000000 	.word	0x20000000

Disassembly of section .text._close_r%884:

00020cb0 <_close_r>:
   20cb0:	b538      	push	{r3, r4, r5, lr}
   20cb2:	4c06      	ldr	r4, [pc, #24]	; (20ccc <_close_r+0x1c>)
   20cb4:	2300      	movs	r3, #0
   20cb6:	4605      	mov	r5, r0
   20cb8:	4608      	mov	r0, r1
   20cba:	6023      	str	r3, [r4, #0]
   20cbc:	f001 fadc 	bl	22278 <_close>
   20cc0:	1c43      	adds	r3, r0, #1
   20cc2:	d102      	bne.n	20cca <_close_r+0x1a>
   20cc4:	6823      	ldr	r3, [r4, #0]
   20cc6:	b103      	cbz	r3, 20cca <_close_r+0x1a>
   20cc8:	602b      	str	r3, [r5, #0]
   20cca:	bd38      	pop	{r3, r4, r5, pc}
   20ccc:	20000000 	.word	0x20000000

Disassembly of section .text._isatty_r%885:

00020cd0 <_isatty_r>:
   20cd0:	b538      	push	{r3, r4, r5, lr}
   20cd2:	4c06      	ldr	r4, [pc, #24]	; (20cec <_isatty_r+0x1c>)
   20cd4:	2300      	movs	r3, #0
   20cd6:	4605      	mov	r5, r0
   20cd8:	4608      	mov	r0, r1
   20cda:	6023      	str	r3, [r4, #0]
   20cdc:	f001 fad2 	bl	22284 <_isatty>
   20ce0:	1c43      	adds	r3, r0, #1
   20ce2:	d102      	bne.n	20cea <_isatty_r+0x1a>
   20ce4:	6823      	ldr	r3, [r4, #0]
   20ce6:	b103      	cbz	r3, 20cea <_isatty_r+0x1a>
   20ce8:	602b      	str	r3, [r5, #0]
   20cea:	bd38      	pop	{r3, r4, r5, pc}
   20cec:	20000000 	.word	0x20000000

Disassembly of section .text._DRV_GMAC_LinkStateDown%886:

00020cf0 <_DRV_GMAC_LinkStateDown>:
{
   20cf0:	b510      	push	{r4, lr}
   20cf2:	4604      	mov	r4, r0
	pMACDrv->sGmacData._macFlags._linkPrev = 0;
   20cf4:	7d83      	ldrb	r3, [r0, #22]
	pMACDrv->sGmacData._macFlags._linkUpDone = 0;
   20cf6:	f003 03ef 	and.w	r3, r3, #239	; 0xef
   20cfa:	f36f 1345 	bfc	r3, #5, #1
   20cfe:	7583      	strb	r3, [r0, #22]
	pMACDrv->sGmacData._linkUpTick = SYS_TMR_TickCountGet();
   20d00:	f7ff f9f4 	bl	200ec <SYS_TMR_TickCountGet>
   20d04:	63a0      	str	r0, [r4, #56]	; 0x38
	pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_START_LINK;
   20d06:	2300      	movs	r3, #0
   20d08:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
}
   20d0c:	bd10      	pop	{r4, pc}

Disassembly of section .text._TCPIsGetReady%887:

00020d0e <_TCPIsGetReady>:
	if(pSkt->rxHead >= pSkt->rxTail)
   20d0e:	69c2      	ldr	r2, [r0, #28]
   20d10:	6a01      	ldr	r1, [r0, #32]
   20d12:	428a      	cmp	r2, r1
   20d14:	d207      	bcs.n	20d26 <_TCPIsGetReady+0x18>
    return (pSkt->rxEnd - pSkt->rxTail + 1) + (pSkt->rxHead - pSkt->rxStart);
   20d16:	6983      	ldr	r3, [r0, #24]
   20d18:	1a5b      	subs	r3, r3, r1
   20d1a:	6940      	ldr	r0, [r0, #20]
   20d1c:	1a10      	subs	r0, r2, r0
   20d1e:	4418      	add	r0, r3
   20d20:	3001      	adds	r0, #1
   20d22:	b280      	uxth	r0, r0
}
   20d24:	4770      	bx	lr
		return pSkt->rxHead - pSkt->rxTail;
   20d26:	1a50      	subs	r0, r2, r1
   20d28:	b280      	uxth	r0, r0
   20d2a:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressBcast%888:

00020d2c <TCPIP_STACK_NetAddressBcast>:
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   20d2c:	b158      	cbz	r0, 20d46 <TCPIP_STACK_NetAddressBcast+0x1a>
   20d2e:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20d32:	f012 0f40 	tst.w	r2, #64	; 0x40
   20d36:	d101      	bne.n	20d3c <TCPIP_STACK_NetAddressBcast+0x10>
    return 0;
   20d38:	2000      	movs	r0, #0
}
   20d3a:	4770      	bx	lr
        return (pNetIf->netIPAddr.Val | ~pNetIf->netMask.Val);
   20d3c:	6882      	ldr	r2, [r0, #8]
   20d3e:	6840      	ldr	r0, [r0, #4]
   20d40:	ea60 0002 	orn	r0, r0, r2
   20d44:	4770      	bx	lr
    return 0;
   20d46:	2000      	movs	r0, #0
   20d48:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddress%889:

00020d4a <TCPIP_STACK_NetAddress>:
{
   20d4a:	b508      	push	{r3, lr}
   20d4c:	4603      	mov	r3, r0
   20d4e:	b138      	cbz	r0, 20d60 <TCPIP_STACK_NetAddress+0x16>
   20d50:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20d54:	f002 0240 	and.w	r2, r2, #64	; 0x40
    return 0;
   20d58:	2a00      	cmp	r2, #0
   20d5a:	bf14      	ite	ne
   20d5c:	4603      	movne	r3, r0
   20d5e:	2300      	moveq	r3, #0
    return TCPIP_STACK_NetAddressGet(pNetIf);
   20d60:	4618      	mov	r0, r3
   20d62:	f000 fc07 	bl	21574 <TCPIP_STACK_NetAddressGet>
}
   20d66:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_STACK_NetworkIsLinked%890:

00020d68 <TCPIP_STACK_NetworkIsLinked>:
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   20d68:	b158      	cbz	r0, 20d82 <TCPIP_STACK_NetworkIsLinked+0x1a>
   20d6a:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20d6e:	f012 0f40 	tst.w	r2, #64	; 0x40
   20d72:	d101      	bne.n	20d78 <TCPIP_STACK_NetworkIsLinked+0x10>
    return false;
   20d74:	2000      	movs	r0, #0
}
   20d76:	4770      	bx	lr
        return pNetIf->exFlags.linkPrev;
   20d78:	f890 0060 	ldrb.w	r0, [r0, #96]	; 0x60
   20d7c:	f000 0001 	and.w	r0, r0, #1
   20d80:	4770      	bx	lr
    return false;
   20d82:	2000      	movs	r0, #0
   20d84:	4770      	bx	lr

Disassembly of section .text.TCPIP_PKT_PayloadLen%891:

00020d86 <TCPIP_PKT_PayloadLen>:
    if(pPkt)
   20d86:	b148      	cbz	r0, 20d9c <TCPIP_PKT_PayloadLen+0x16>
        TCPIP_MAC_DATA_SEGMENT* pSeg = pPkt->pDSeg;
   20d88:	6903      	ldr	r3, [r0, #16]
        while(pSeg != 0)
   20d8a:	b14b      	cbz	r3, 20da0 <TCPIP_PKT_PayloadLen+0x1a>
    uint32_t payloadSize = 0;
   20d8c:	2000      	movs	r0, #0
            payloadSize += pSeg->segLen;
   20d8e:	899a      	ldrh	r2, [r3, #12]
   20d90:	4410      	add	r0, r2
            pSeg = pSeg->next;
   20d92:	681b      	ldr	r3, [r3, #0]
        while(pSeg != 0)
   20d94:	2b00      	cmp	r3, #0
   20d96:	d1fa      	bne.n	20d8e <TCPIP_PKT_PayloadLen+0x8>
}
   20d98:	b280      	uxth	r0, r0
   20d9a:	4770      	bx	lr
    uint32_t payloadSize = 0;
   20d9c:	2000      	movs	r0, #0
   20d9e:	e7fb      	b.n	20d98 <TCPIP_PKT_PayloadLen+0x12>
   20da0:	2000      	movs	r0, #0
   20da2:	e7f9      	b.n	20d98 <TCPIP_PKT_PayloadLen+0x12>

Disassembly of section .text.OSAL_SEM_Pend%892:

00020da4 <OSAL_SEM_Pend>:
   </code>

  Remarks:
 */
OSAL_RESULT OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE* semID, uint16_t waitMS)
{
   20da4:	b508      	push	{r3, lr}
  else
  {
    timeout = (TickType_t)(waitMS / portTICK_PERIOD_MS);
  }

  if (xSemaphoreTake(*(SemaphoreHandle_t*)semID, timeout) == pdTRUE)
   20da6:	f64f 73ff 	movw	r3, #65535	; 0xffff
   20daa:	4299      	cmp	r1, r3
   20dac:	bf08      	it	eq
   20dae:	f04f 31ff 	moveq.w	r1, #4294967295
   20db2:	6800      	ldr	r0, [r0, #0]
   20db4:	f7f0 fe58 	bl	11a68 <xQueueSemaphoreTake>
    return OSAL_RESULT_TRUE;
  else
    return OSAL_RESULT_FALSE;
}
   20db8:	2801      	cmp	r0, #1
   20dba:	bf14      	ite	ne
   20dbc:	2000      	movne	r0, #0
   20dbe:	2001      	moveq	r0, #1
   20dc0:	bd08      	pop	{r3, pc}

Disassembly of section .text.OSAL_MUTEX_Lock%893:

00020dc2 <OSAL_MUTEX_Lock>:

  Remarks:

 */
OSAL_RESULT OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE* mutexID, uint16_t waitMS)
{
   20dc2:	b508      	push	{r3, lr}
  else
  {
    timeout = (TickType_t)(waitMS / portTICK_PERIOD_MS);
  }

  if (xSemaphoreTake(*(SemaphoreHandle_t*)mutexID, timeout) == pdTRUE)
   20dc4:	f64f 73ff 	movw	r3, #65535	; 0xffff
   20dc8:	4299      	cmp	r1, r3
   20dca:	bf08      	it	eq
   20dcc:	f04f 31ff 	moveq.w	r1, #4294967295
   20dd0:	6800      	ldr	r0, [r0, #0]
   20dd2:	f7f0 fe49 	bl	11a68 <xQueueSemaphoreTake>
    return OSAL_RESULT_TRUE;
  else
    return OSAL_RESULT_FALSE;
}
   20dd6:	2801      	cmp	r0, #1
   20dd8:	bf14      	ite	ne
   20dda:	2000      	movne	r0, #0
   20ddc:	2001      	moveq	r0, #1
   20dde:	bd08      	pop	{r3, pc}

Disassembly of section .text._keyUpProcess%894:

00020de0 <_keyUpProcess>:
{   // up arrow
   20de0:	b508      	push	{r3, lr}
    if(pCmdIO->currHistN)
   20de2:	f8d0 30d4 	ldr.w	r3, [r0, #212]	; 0xd4
   20de6:	b13b      	cbz	r3, 20df8 <_keyUpProcess+0x18>
        pNext = pCmdIO->currHistN->next;
   20de8:	6819      	ldr	r1, [r3, #0]
        if(pNext == pCmdIO->histList.head)
   20dea:	f8d0 30cc 	ldr.w	r3, [r0, #204]	; 0xcc
   20dee:	428b      	cmp	r3, r1
   20df0:	d001      	beq.n	20df6 <_keyUpProcess+0x16>
    DisplayNodeMsg(pCmdIO, pNext);
   20df2:	f7f7 faf5 	bl	183e0 <DisplayNodeMsg>
}
   20df6:	bd08      	pop	{r3, pc}
        pNext = pCmdIO->histList.head;
   20df8:	f8d0 10cc 	ldr.w	r1, [r0, #204]	; 0xcc
   20dfc:	e7f9      	b.n	20df2 <_keyUpProcess+0x12>

Disassembly of section .text._DRV_ETHPHY_ResetPhaseIdle%895:

00020dfe <_DRV_ETHPHY_ResetPhaseIdle>:
{
   20dfe:	b510      	push	{r4, lr}
   20e00:	4604      	mov	r4, r0
    if(_DRV_PHY_SMIWriteStart(hClientObj, PHY_REG_BMCON, _BMCON_RESET_MASK))
   20e02:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   20e06:	2100      	movs	r1, #0
   20e08:	f7fe f891 	bl	1ef2e <_DRV_PHY_SMIWriteStart>
   20e0c:	b900      	cbnz	r0, 20e10 <_DRV_ETHPHY_ResetPhaseIdle+0x12>
}
   20e0e:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   20e10:	2301      	movs	r3, #1
   20e12:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   20e14:	2300      	movs	r3, #0
   20e16:	8423      	strh	r3, [r4, #32]
}
   20e18:	e7f9      	b.n	20e0e <_DRV_ETHPHY_ResetPhaseIdle+0x10>

Disassembly of section .rodata._DRV_PHY_ClientOpTbl%896:

00020e1c <_DRV_PHY_ClientOpTbl>:
   20e1c:	0617 0001 0971 0002 0951 0002 0931 0002     ....q...Q...1...
   20e2c:	0911 0002 08f1 0002 08d1 0002               ............

Disassembly of section .text.DRV_GMAC_EventPendingGet%897:

00020e38 <DRV_GMAC_EventPendingGet>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   20e38:	4b05      	ldr	r3, [pc, #20]	; (20e50 <DRV_GMAC_EventPendingGet+0x18>)
   20e3a:	4283      	cmp	r3, r0
   20e3c:	d104      	bne.n	20e48 <DRV_GMAC_EventPendingGet+0x10>
    if(pMACDrv != 0)
   20e3e:	b128      	cbz	r0, 20e4c <DRV_GMAC_EventPendingGet+0x14>
        return pMACDrv->sGmacData._gmac_event_group_dcpt._TcpPendingEvents;
   20e40:	f8b3 004e 	ldrh.w	r0, [r3, #78]	; 0x4e
   20e44:	b280      	uxth	r0, r0
   20e46:	4770      	bx	lr
    return TCPIP_MAC_EV_NONE;
   20e48:	2000      	movs	r0, #0
   20e4a:	4770      	bx	lr
   20e4c:	2000      	movs	r0, #0
}
   20e4e:	4770      	bx	lr
   20e50:	2000d8b8 	.word	0x2000d8b8

Disassembly of section .text.DRV_PIC32CGMAC_LibClose%898:

00020e54 <DRV_PIC32CGMAC_LibClose>:
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_TXEN_Msk;
   20e54:	4b05      	ldr	r3, [pc, #20]	; (20e6c <DRV_PIC32CGMAC_LibClose+0x18>)
   20e56:	681a      	ldr	r2, [r3, #0]
   20e58:	f022 0208 	bic.w	r2, r2, #8
   20e5c:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_RXEN_Msk;
   20e5e:	681a      	ldr	r2, [r3, #0]
   20e60:	f022 0204 	bic.w	r2, r2, #4
   20e64:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_ISR;
   20e66:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
   20e68:	4770      	bx	lr
   20e6a:	bf00      	nop
   20e6c:	42000800 	.word	0x42000800

Disassembly of section .text.DRV_PIC32CGMAC_SingleListHeadRemove%899:

00020e70 <DRV_PIC32CGMAC_SingleListHeadRemove>:
{
   20e70:	4603      	mov	r3, r0
	DRV_PIC32CGMAC_SGL_LIST_NODE* pN = pL->head;
   20e72:	6800      	ldr	r0, [r0, #0]
    if(pN)
   20e74:	b148      	cbz	r0, 20e8a <DRV_PIC32CGMAC_SingleListHeadRemove+0x1a>
        if(pL->head == pL->tail)
   20e76:	685a      	ldr	r2, [r3, #4]
   20e78:	4282      	cmp	r2, r0
            pL->head = pL->tail = 0;
   20e7a:	bf06      	itte	eq
   20e7c:	2200      	moveq	r2, #0
   20e7e:	605a      	streq	r2, [r3, #4]
            pL->head = pN->next;
   20e80:	6802      	ldrne	r2, [r0, #0]
   20e82:	601a      	str	r2, [r3, #0]
        pL->nNodes--;
   20e84:	689a      	ldr	r2, [r3, #8]
   20e86:	3a01      	subs	r2, #1
   20e88:	609a      	str	r2, [r3, #8]
}
   20e8a:	4770      	bx	lr

Disassembly of section .text.Helper_SingleListHeadRemove%900:

00020e8c <Helper_SingleListHeadRemove>:
{
   20e8c:	4603      	mov	r3, r0
	SGL_LIST_NODE* pN = pL->head;
   20e8e:	6800      	ldr	r0, [r0, #0]
    if(pN)
   20e90:	b148      	cbz	r0, 20ea6 <Helper_SingleListHeadRemove+0x1a>
        if(pL->head == pL->tail)
   20e92:	685a      	ldr	r2, [r3, #4]
   20e94:	4282      	cmp	r2, r0
            pL->head = pL->tail = 0;
   20e96:	bf06      	itte	eq
   20e98:	2200      	moveq	r2, #0
   20e9a:	605a      	streq	r2, [r3, #4]
            pL->head = pN->next;
   20e9c:	6802      	ldrne	r2, [r0, #0]
   20e9e:	601a      	str	r2, [r3, #0]
        pL->nNodes--;
   20ea0:	689a      	ldr	r2, [r3, #8]
   20ea2:	3a01      	subs	r2, #1
   20ea4:	609a      	str	r2, [r3, #8]
}
   20ea6:	4770      	bx	lr

Disassembly of section .text._ARPTxAckFnc%901:

00020ea8 <_ARPTxAckFnc>:
{
   20ea8:	b508      	push	{r3, lr}
    if(arpMod.pMacPkt != pPkt)
   20eaa:	4b05      	ldr	r3, [pc, #20]	; (20ec0 <_ARPTxAckFnc+0x18>)
   20eac:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   20eae:	4283      	cmp	r3, r0
   20eb0:	d101      	bne.n	20eb6 <_ARPTxAckFnc+0xe>
    return true;
   20eb2:	2001      	movs	r0, #1
}
   20eb4:	bd08      	pop	{r3, pc}
        TCPIP_PKT_PacketFree(pPkt);
   20eb6:	f7fd f9a7 	bl	1e208 <_TCPIP_PKT_PacketFree>
        return false;
   20eba:	2000      	movs	r0, #0
   20ebc:	e7fa      	b.n	20eb4 <_ARPTxAckFnc+0xc>
   20ebe:	bf00      	nop
   20ec0:	2000dfa4 	.word	0x2000dfa4

Disassembly of section .text.TCPIP_IPV4_MaxDatagramDataSizeGet%902:

00020ec4 <TCPIP_IPV4_MaxDatagramDataSizeGet>:
   20ec4:	b150      	cbz	r0, 20edc <TCPIP_IPV4_MaxDatagramDataSizeGet+0x18>
   20ec6:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20eca:	f012 0f40 	tst.w	r2, #64	; 0x40
   20ece:	d101      	bne.n	20ed4 <TCPIP_IPV4_MaxDatagramDataSizeGet+0x10>

int TCPIP_IPV4_MaxDatagramDataSizeGet(TCPIP_NET_HANDLE netH)
{
    TCPIP_NET_IF* pIf = _TCPIPStackHandleToNetUp(netH);

    return pIf ? _TCPIPStackNetLinkMtu(pIf) - sizeof(IPV4_HEADER) : 0;
   20ed0:	2000      	movs	r0, #0
}
   20ed2:	4770      	bx	lr
    return pIf ? _TCPIPStackNetLinkMtu(pIf) - sizeof(IPV4_HEADER) : 0;
   20ed4:	f8b0 005e 	ldrh.w	r0, [r0, #94]	; 0x5e
   20ed8:	3814      	subs	r0, #20
   20eda:	4770      	bx	lr
   20edc:	2000      	movs	r0, #0
   20ede:	4770      	bx	lr

Disassembly of section .text._TCPIP_HEAP_Calloc%903:

00020ee0 <_TCPIP_HEAP_Calloc>:
{
   20ee0:	b538      	push	{r3, r4, r5, lr}
    void* pBuff = _TCPIP_HEAP_Malloc(heapH, nElems * elemSize);
   20ee2:	fb02 f501 	mul.w	r5, r2, r1
   20ee6:	4629      	mov	r1, r5
   20ee8:	f7f6 f957 	bl	1719a <_TCPIP_HEAP_Malloc>
    if(pBuff)
   20eec:	4604      	mov	r4, r0
   20eee:	b118      	cbz	r0, 20ef8 <_TCPIP_HEAP_Calloc+0x18>
        memset(pBuff, 0, nElems * elemSize);
   20ef0:	462a      	mov	r2, r5
   20ef2:	2100      	movs	r1, #0
   20ef4:	f000 feca 	bl	21c8c <memset>
}
   20ef8:	4620      	mov	r0, r4
   20efa:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .rodata._DHCPOptWriteTbl%904:

00020efc <_DHCPOptWriteTbl>:
   20efc:	04f1 0002 c175 0001 febd 0001 c5fd 0001     ....u...........
   20f0c:	1221 0001 f67b 0001 1919 0002               !...{.......

Disassembly of section .text.TCPIP_Helper_SingleListHeadRemove%905:

00020f18 <TCPIP_Helper_SingleListHeadRemove>:
{
   20f18:	4603      	mov	r3, r0
	SGL_LIST_NODE* pN = pL->head;
   20f1a:	6800      	ldr	r0, [r0, #0]
    if(pN)
   20f1c:	b148      	cbz	r0, 20f32 <TCPIP_Helper_SingleListHeadRemove+0x1a>
        if(pL->head == pL->tail)
   20f1e:	685a      	ldr	r2, [r3, #4]
   20f20:	4282      	cmp	r2, r0
            pL->head = pL->tail = 0;
   20f22:	bf06      	itte	eq
   20f24:	2200      	moveq	r2, #0
   20f26:	605a      	streq	r2, [r3, #4]
            pL->head = pN->next;
   20f28:	6802      	ldrne	r2, [r0, #0]
   20f2a:	601a      	str	r2, [r3, #0]
        pL->nNodes--;
   20f2c:	689a      	ldr	r2, [r3, #8]
   20f2e:	3a01      	subs	r2, #1
   20f30:	609a      	str	r2, [r3, #8]
}
   20f32:	4770      	bx	lr

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListUnlock%906:

00020f34 <TCPIP_Helper_ProtectedSingleListUnlock>:

bool TCPIP_Helper_ProtectedSingleListUnlock(PROTECTED_SINGLE_LIST* pL)
{
   20f34:	b508      	push	{r3, lr}
   20f36:	4603      	mov	r3, r0
    if(pL->semValid)
   20f38:	7c00      	ldrb	r0, [r0, #16]
   20f3a:	b900      	cbnz	r0, 20f3e <TCPIP_Helper_ProtectedSingleListUnlock+0xa>
    {
        return (OSAL_SEM_Post(&pL->semaphore) == OSAL_RESULT_TRUE);
    }

    return false;
}
   20f3c:	bd08      	pop	{r3, pc}
        return (OSAL_SEM_Post(&pL->semaphore) == OSAL_RESULT_TRUE);
   20f3e:	f103 000c 	add.w	r0, r3, #12
   20f42:	f000 fb47 	bl	215d4 <OSAL_SEM_Post>
   20f46:	2801      	cmp	r0, #1
   20f48:	bf14      	ite	ne
   20f4a:	2000      	movne	r0, #0
   20f4c:	2001      	moveq	r0, #1
   20f4e:	e7f5      	b.n	20f3c <TCPIP_Helper_ProtectedSingleListUnlock+0x8>

Disassembly of section .text._TCPIPSignalEntryNotify%907:

00020f50 <_TCPIPSignalEntryNotify>:
{
   20f50:	b510      	push	{r4, lr}
    if((userF = pSigEntry->userSignalF) != 0)
   20f52:	6844      	ldr	r4, [r0, #4]
   20f54:	b134      	cbz	r4, 20f64 <_TCPIPSignalEntryNotify+0x14>
   20f56:	4613      	mov	r3, r2
   20f58:	460a      	mov	r2, r1
        (*userF)(pSigEntry, pSigEntry - TCPIP_STACK_MODULE_SIGNAL_TBL, signal, sigParam);
   20f5a:	4903      	ldr	r1, [pc, #12]	; (20f68 <_TCPIPSignalEntryNotify+0x18>)
   20f5c:	1a41      	subs	r1, r0, r1
   20f5e:	f3c1 110f 	ubfx	r1, r1, #4, #16
   20f62:	47a0      	blx	r4
}
   20f64:	bd10      	pop	{r4, pc}
   20f66:	bf00      	nop
   20f68:	2000d1d4 	.word	0x2000d1d4

Disassembly of section .text.TCPIP_STACK_Status%908:

00020f6c <TCPIP_STACK_Status>:
    if(object != (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data)
   20f6c:	4b04      	ldr	r3, [pc, #16]	; (20f80 <TCPIP_STACK_Status+0x14>)
   20f6e:	4283      	cmp	r3, r0
    return tcpip_stack_status;
   20f70:	bf06      	itte	eq
   20f72:	4b04      	ldreq	r3, [pc, #16]	; (20f84 <TCPIP_STACK_Status+0x18>)
   20f74:	f993 0000 	ldrsbeq.w	r0, [r3]
        return SYS_STATUS_ERROR;
   20f78:	f04f 30ff 	movne.w	r0, #4294967295
}
   20f7c:	4770      	bx	lr
   20f7e:	bf00      	nop
   20f80:	2000e0f0 	.word	0x2000e0f0
   20f84:	2000e50d 	.word	0x2000e50d

Disassembly of section .text.TCPIP_STACK_NetAddressGatewaySet%909:

00020f88 <TCPIP_STACK_NetAddressGatewaySet>:
   20f88:	b150      	cbz	r0, 20fa0 <TCPIP_STACK_NetAddressGatewaySet+0x18>
   20f8a:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20f8e:	f012 0f40 	tst.w	r2, #64	; 0x40
   20f92:	d101      	bne.n	20f98 <TCPIP_STACK_NetAddressGatewaySet+0x10>
    return false;
   20f94:	2000      	movs	r0, #0
}
   20f96:	4770      	bx	lr
        pNetIf->netGateway.Val = ipAddress->Val;
   20f98:	680a      	ldr	r2, [r1, #0]
   20f9a:	60c2      	str	r2, [r0, #12]
        return true;
   20f9c:	2001      	movs	r0, #1
   20f9e:	4770      	bx	lr
    return false;
   20fa0:	2000      	movs	r0, #0
   20fa2:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressDnsPrimarySet%910:

00020fa4 <TCPIP_STACK_NetAddressDnsPrimarySet>:
   20fa4:	4603      	mov	r3, r0
   20fa6:	b138      	cbz	r0, 20fb8 <TCPIP_STACK_NetAddressDnsPrimarySet+0x14>
   20fa8:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20fac:	f012 0f40 	tst.w	r2, #64	; 0x40
   20fb0:	bf0e      	itee	eq
   20fb2:	2300      	moveq	r3, #0
        pNetIf->dnsServer[0].Val = ipAddress->Val;
   20fb4:	680a      	ldrne	r2, [r1, #0]
   20fb6:	6102      	strne	r2, [r0, #16]
    return pNetIf != 0;
   20fb8:	1c18      	adds	r0, r3, #0
   20fba:	bf18      	it	ne
   20fbc:	2001      	movne	r0, #1
}
   20fbe:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressDnsSecondSet%911:

00020fc0 <TCPIP_STACK_NetAddressDnsSecondSet>:
   20fc0:	b150      	cbz	r0, 20fd8 <TCPIP_STACK_NetAddressDnsSecondSet+0x18>
   20fc2:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20fc6:	f012 0f40 	tst.w	r2, #64	; 0x40
   20fca:	d101      	bne.n	20fd0 <TCPIP_STACK_NetAddressDnsSecondSet+0x10>
    return false;
   20fcc:	2000      	movs	r0, #0
}
   20fce:	4770      	bx	lr
        pNetIf->dnsServer[1].Val = ipAddress->Val;
   20fd0:	680a      	ldr	r2, [r1, #0]
   20fd2:	6142      	str	r2, [r0, #20]
        return true;
   20fd4:	2001      	movs	r0, #1
   20fd6:	4770      	bx	lr
    return false;
   20fd8:	2000      	movs	r0, #0
   20fda:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetIsUp%912:

00020fdc <TCPIP_STACK_NetIsUp>:
   20fdc:	4603      	mov	r3, r0
   20fde:	b138      	cbz	r0, 20ff0 <TCPIP_STACK_NetIsUp+0x14>
   20fe0:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20fe4:	f002 0240 	and.w	r2, r2, #64	; 0x40
    return 0;
   20fe8:	2a00      	cmp	r2, #0
   20fea:	bf14      	ite	ne
   20fec:	4603      	movne	r3, r0
   20fee:	2300      	moveq	r3, #0
}
   20ff0:	1c18      	adds	r0, r3, #0
   20ff2:	bf18      	it	ne
   20ff4:	2001      	movne	r0, #1
   20ff6:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetMask%913:

00020ff8 <TCPIP_STACK_NetMask>:
{
   20ff8:	b508      	push	{r3, lr}
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   20ffa:	b148      	cbz	r0, 21010 <TCPIP_STACK_NetMask+0x18>
   20ffc:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   21000:	f012 0f40 	tst.w	r2, #64	; 0x40
   21004:	d101      	bne.n	2100a <TCPIP_STACK_NetMask+0x12>
    return 0;
   21006:	2000      	movs	r0, #0
}
   21008:	bd08      	pop	{r3, pc}
        return TCPIP_STACK_NetMaskGet(pNetIf);
   2100a:	f000 fabf 	bl	2158c <TCPIP_STACK_NetMaskGet>
   2100e:	e7fb      	b.n	21008 <TCPIP_STACK_NetMask+0x10>
    return 0;
   21010:	2000      	movs	r0, #0
   21012:	e7f9      	b.n	21008 <TCPIP_STACK_NetMask+0x10>

Disassembly of section .text.TCPIP_STACK_NetIsLinked%914:

00021014 <TCPIP_STACK_NetIsLinked>:
{
   21014:	b508      	push	{r3, lr}
   21016:	b148      	cbz	r0, 2102c <TCPIP_STACK_NetIsLinked+0x18>
   21018:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   2101c:	f012 0f40 	tst.w	r2, #64	; 0x40
   21020:	d101      	bne.n	21026 <TCPIP_STACK_NetIsLinked+0x12>
    return false;
   21022:	2000      	movs	r0, #0
}
   21024:	bd08      	pop	{r3, pc}
        return TCPIP_STACK_NetworkIsLinked(pNetIf);
   21026:	f7ff fe9f 	bl	20d68 <TCPIP_STACK_NetworkIsLinked>
   2102a:	e7fb      	b.n	21024 <TCPIP_STACK_NetIsLinked+0x10>
    return false;
   2102c:	2000      	movs	r0, #0
   2102e:	e7f9      	b.n	21024 <TCPIP_STACK_NetIsLinked+0x10>

Disassembly of section .text.TCPIP_STACK_Deinitialize%915:

00021030 <TCPIP_STACK_Deinitialize>:
{
   21030:	b508      	push	{r3, lr}
    if(object != (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data || tcpipNetIf == 0)
   21032:	4b04      	ldr	r3, [pc, #16]	; (21044 <TCPIP_STACK_Deinitialize+0x14>)
   21034:	4283      	cmp	r3, r0
   21036:	d104      	bne.n	21042 <TCPIP_STACK_Deinitialize+0x12>
   21038:	4b03      	ldr	r3, [pc, #12]	; (21048 <TCPIP_STACK_Deinitialize+0x18>)
   2103a:	681b      	ldr	r3, [r3, #0]
   2103c:	b10b      	cbz	r3, 21042 <TCPIP_STACK_Deinitialize+0x12>
    TCPIP_STACK_KillStack();
   2103e:	f7f5 fa4b 	bl	164d8 <TCPIP_STACK_KillStack>
}
   21042:	bd08      	pop	{r3, pc}
   21044:	2000e0f0 	.word	0x2000e0f0
   21048:	2000e440 	.word	0x2000e440

Disassembly of section .text._keyLeftProcess%916:

0002104c <_keyLeftProcess>:
{   // left arrow
   2104c:	b508      	push	{r3, lr}
    if(pCmdIO->cmdPnt > pCmdIO->cmdBuff)
   2104e:	6983      	ldr	r3, [r0, #24]
   21050:	f100 0220 	add.w	r2, r0, #32
   21054:	4293      	cmp	r3, r2
   21056:	d906      	bls.n	21066 <_keyLeftProcess+0x1a>
    const SYS_CMD_API* pCmdApi = pCmdIO->devNode.pCmdApi;
   21058:	6802      	ldr	r2, [r0, #0]
        pCmdIO->cmdPnt--;
   2105a:	3b01      	subs	r3, #1
   2105c:	6183      	str	r3, [r0, #24]
        (*pCmdApi->msg)(cmdIoParam, pSeqDcpt->keyCode);
   2105e:	6813      	ldr	r3, [r2, #0]
   21060:	6809      	ldr	r1, [r1, #0]
   21062:	6840      	ldr	r0, [r0, #4]
   21064:	4798      	blx	r3
}
   21066:	bd08      	pop	{r3, pc}

Disassembly of section .text.SendCommandMessage%917:

00021068 <SendCommandMessage>:
{
   21068:	b510      	push	{r4, lr}
   2106a:	460c      	mov	r4, r1
    SYS_CONSOLE_Write(_cmdInitData.consoleIndex, message, strlen(message));
   2106c:	4608      	mov	r0, r1
   2106e:	f000 fe1d 	bl	21cac <strlen>
   21072:	4602      	mov	r2, r0
   21074:	4621      	mov	r1, r4
   21076:	4b02      	ldr	r3, [pc, #8]	; (21080 <SendCommandMessage+0x18>)
   21078:	8858      	ldrh	r0, [r3, #2]
   2107a:	f7fd fe6f 	bl	1ed5c <SYS_CONSOLE_Write>
}
   2107e:	bd10      	pop	{r4, pc}
   21080:	2000e46c 	.word	0x2000e46c

Disassembly of section .text.SYS_DEBUG_Initialize%918:

00021084 <SYS_DEBUG_Initialize>:
    const SYS_MODULE_INIT* const init
)
{
    SYS_DEBUG_INIT* initConfig = (SYS_DEBUG_INIT*)init;

    gblErrLvl = initConfig->errorLevel;
   21084:	784a      	ldrb	r2, [r1, #1]
   21086:	4b04      	ldr	r3, [pc, #16]	; (21098 <SYS_DEBUG_Initialize+0x14>)
   21088:	701a      	strb	r2, [r3, #0]

    sysDebugInstance.debugConsole = initConfig->consoleIndex;
   2108a:	4b04      	ldr	r3, [pc, #16]	; (2109c <SYS_DEBUG_Initialize+0x18>)
   2108c:	884a      	ldrh	r2, [r1, #2]
   2108e:	805a      	strh	r2, [r3, #2]
    sysDebugInstance.status = SYS_STATUS_READY;
   21090:	2202      	movs	r2, #2
   21092:	701a      	strb	r2, [r3, #0]

    return SYS_MODULE_OBJ_STATIC;
}
   21094:	2000      	movs	r0, #0
   21096:	4770      	bx	lr
   21098:	2000e50f 	.word	0x2000e50f
   2109c:	2000e478 	.word	0x2000e478

Disassembly of section .text.SYS_TIME_Counter64Update%919:

000210a0 <SYS_TIME_Counter64Update>:
    uint32_t prevSwCounter32Bit = counterObj->swCounter64Low;
   210a0:	4a05      	ldr	r2, [pc, #20]	; (210b8 <SYS_TIME_Counter64Update+0x18>)
   210a2:	6a53      	ldr	r3, [r2, #36]	; 0x24
    newSwCounter32Bit = prevSwCounter32Bit + elapsedCount;
   210a4:	4418      	add	r0, r3
    counterObj->swCounter64Low = SYS_TIME_Counter32Update(elapsedCount, &isSwCounter32Oveflow);
   210a6:	6250      	str	r0, [r2, #36]	; 0x24
    if (isSwCounter32Oveflow == true)
   210a8:	4283      	cmp	r3, r0
   210aa:	d800      	bhi.n	210ae <SYS_TIME_Counter64Update+0xe>
}
   210ac:	4770      	bx	lr
        counterObj->swCounter64High++;
   210ae:	6a93      	ldr	r3, [r2, #40]	; 0x28
   210b0:	3301      	adds	r3, #1
   210b2:	6293      	str	r3, [r2, #40]	; 0x28
}
   210b4:	e7fa      	b.n	210ac <SYS_TIME_Counter64Update+0xc>
   210b6:	bf00      	nop
   210b8:	2000e030 	.word	0x2000e030

Disassembly of section .text.SYS_TIME_GetElapsedCount%920:

000210bc <SYS_TIME_GetElapsedCount>:
    if (hwTimerCurrentValue > counterObj->hwTimerPreviousValue)
   210bc:	4b05      	ldr	r3, [pc, #20]	; (210d4 <SYS_TIME_GetElapsedCount+0x18>)
   210be:	691b      	ldr	r3, [r3, #16]
   210c0:	4283      	cmp	r3, r0
        elapsedCount = hwTimerCurrentValue - counterObj->hwTimerPreviousValue;
   210c2:	4b04      	ldr	r3, [pc, #16]	; (210d4 <SYS_TIME_GetElapsedCount+0x18>)
   210c4:	691b      	ldr	r3, [r3, #16]
   210c6:	bf32      	itee	cc
   210c8:	1ac0      	subcc	r0, r0, r3
        elapsedCount = (SYS_TIME_HW_COUNTER_PERIOD - counterObj->hwTimerPreviousValue) + hwTimerCurrentValue + 1;
   210ca:	f5c3 3380 	rsbcs	r3, r3, #65536	; 0x10000
   210ce:	18c0      	addcs	r0, r0, r3
}
   210d0:	4770      	bx	lr
   210d2:	bf00      	nop
   210d4:	2000e030 	.word	0x2000e030

Disassembly of section .text.SYS_TIME_MSToCount%921:

000210d8 <SYS_TIME_MSToCount>:
{
   210d8:	b508      	push	{r3, lr}
    return (uint32_t) (( ms * (uint64_t) gSystemCounterObj.hwTimerFrequency) / 1000);
   210da:	4b05      	ldr	r3, [pc, #20]	; (210f0 <SYS_TIME_MSToCount+0x18>)
   210dc:	68d9      	ldr	r1, [r3, #12]
   210de:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   210e2:	2300      	movs	r3, #0
   210e4:	fba1 0100 	umull	r0, r1, r1, r0
   210e8:	f7fe fa0e 	bl	1f508 <__aeabi_uldivmod>
}
   210ec:	bd08      	pop	{r3, pc}
   210ee:	bf00      	nop
   210f0:	2000e030 	.word	0x2000e030

Disassembly of section .text.SYS_TMR_CallbackPeriodic%922:

000210f4 <SYS_TMR_CallbackPeriodic>:
{
   210f4:	b508      	push	{r3, lr}
	systemAdaptObj.callback = callback;
   210f6:	4b04      	ldr	r3, [pc, #16]	; (21108 <SYS_TMR_CallbackPeriodic+0x14>)
   210f8:	601a      	str	r2, [r3, #0]
	return SYS_TIME_CallbackRegisterMS((SYS_TIME_CALLBACK)sy_time_h2_adapter_callback, context, periodMs, SYS_TIME_PERIODIC );
   210fa:	2301      	movs	r3, #1
   210fc:	4602      	mov	r2, r0
   210fe:	4803      	ldr	r0, [pc, #12]	; (2110c <SYS_TMR_CallbackPeriodic+0x18>)
   21100:	f7fb f90a 	bl	1c318 <SYS_TIME_CallbackRegisterMS>
}
   21104:	bd08      	pop	{r3, pc}
   21106:	bf00      	nop
   21108:	2000e480 	.word	0x2000e480
   2110c:	00021bed 	.word	0x00021bed

Disassembly of section .rodata.sysTimePlibAPI%923:

00021110 <sysTimePlibAPI>:
   21110:	00022039 0002164d 00021665 000221a9     9 ..M...e....!..
   21120:	0002197d 00021991 0002009d              }...........

Disassembly of section .text.vTaskPlaceOnEventList%924:

0002112c <vTaskPlaceOnEventList>:
{
   2112c:	b510      	push	{r4, lr}
   2112e:	460c      	mov	r4, r1
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   21130:	4b04      	ldr	r3, [pc, #16]	; (21144 <vTaskPlaceOnEventList+0x18>)
   21132:	6819      	ldr	r1, [r3, #0]
   21134:	3118      	adds	r1, #24
   21136:	f7fd fe45 	bl	1edc4 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   2113a:	2101      	movs	r1, #1
   2113c:	4620      	mov	r0, r4
   2113e:	f7f7 f99b 	bl	18478 <prvAddCurrentTaskToDelayedList>
}
   21142:	bd10      	pop	{r4, pc}
   21144:	2000e49c 	.word	0x2000e49c

Disassembly of section .text.pvTaskIncrementMutexHeldCount%925:

00021148 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
   21148:	4b05      	ldr	r3, [pc, #20]	; (21160 <pvTaskIncrementMutexHeldCount+0x18>)
   2114a:	681b      	ldr	r3, [r3, #0]
   2114c:	b123      	cbz	r3, 21158 <pvTaskIncrementMutexHeldCount+0x10>
			( pxCurrentTCB->uxMutexesHeld )++;
   2114e:	4b04      	ldr	r3, [pc, #16]	; (21160 <pvTaskIncrementMutexHeldCount+0x18>)
   21150:	681a      	ldr	r2, [r3, #0]
   21152:	6c93      	ldr	r3, [r2, #72]	; 0x48
   21154:	3301      	adds	r3, #1
   21156:	6493      	str	r3, [r2, #72]	; 0x48
		return pxCurrentTCB;
   21158:	4b01      	ldr	r3, [pc, #4]	; (21160 <pvTaskIncrementMutexHeldCount+0x18>)
   2115a:	6818      	ldr	r0, [r3, #0]
	}
   2115c:	4770      	bx	lr
   2115e:	bf00      	nop
   21160:	2000e49c 	.word	0x2000e49c

Disassembly of section .text.memcmp%926:

00021164 <memcmp>:
   21164:	b530      	push	{r4, r5, lr}
   21166:	3901      	subs	r1, #1
   21168:	2400      	movs	r4, #0
   2116a:	42a2      	cmp	r2, r4
   2116c:	d101      	bne.n	21172 <memcmp+0xe>
   2116e:	2000      	movs	r0, #0
   21170:	e005      	b.n	2117e <memcmp+0x1a>
   21172:	5d03      	ldrb	r3, [r0, r4]
   21174:	3401      	adds	r4, #1
   21176:	5d0d      	ldrb	r5, [r1, r4]
   21178:	42ab      	cmp	r3, r5
   2117a:	d0f6      	beq.n	2116a <memcmp+0x6>
   2117c:	1b58      	subs	r0, r3, r5
   2117e:	bd30      	pop	{r4, r5, pc}

Disassembly of section .text.memcpy%927:

00021180 <memcpy>:
   21180:	440a      	add	r2, r1
   21182:	4291      	cmp	r1, r2
   21184:	f100 33ff 	add.w	r3, r0, #4294967295
   21188:	d100      	bne.n	2118c <memcpy+0xc>
   2118a:	4770      	bx	lr
   2118c:	b510      	push	{r4, lr}
   2118e:	f811 4b01 	ldrb.w	r4, [r1], #1
   21192:	f803 4f01 	strb.w	r4, [r3, #1]!
   21196:	4291      	cmp	r1, r2
   21198:	d1f9      	bne.n	2118e <memcpy+0xe>
   2119a:	bd10      	pop	{r4, pc}

Disassembly of section .text._calloc_r%928:

0002119c <_calloc_r>:
   2119c:	b538      	push	{r3, r4, r5, lr}
   2119e:	fb02 f401 	mul.w	r4, r2, r1
   211a2:	4621      	mov	r1, r4
   211a4:	f7f5 fdec 	bl	16d80 <_malloc_r>
   211a8:	4605      	mov	r5, r0
   211aa:	b118      	cbz	r0, 211b4 <_calloc_r+0x18>
   211ac:	4622      	mov	r2, r4
   211ae:	2100      	movs	r1, #0
   211b0:	f000 fd6c 	bl	21c8c <memset>
   211b4:	4628      	mov	r0, r5
   211b6:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.vsnprintf%929:

000211b8 <vsniprintf>:
   211b8:	b507      	push	{r0, r1, r2, lr}
   211ba:	9300      	str	r3, [sp, #0]
   211bc:	4613      	mov	r3, r2
   211be:	460a      	mov	r2, r1
   211c0:	4601      	mov	r1, r0
   211c2:	4803      	ldr	r0, [pc, #12]	; (211d0 <vsniprintf+0x18>)
   211c4:	6800      	ldr	r0, [r0, #0]
   211c6:	f7fa fcf1 	bl	1bbac <_vsniprintf_r>
   211ca:	b003      	add	sp, #12
   211cc:	f85d fb04 	ldr.w	pc, [sp], #4
   211d0:	2000e4e4 	.word	0x2000e4e4

Disassembly of section .text._fputwc_r%930:

000211d4 <_fputwc_r>:
   211d4:	f9b2 300c 	ldrsh.w	r3, [r2, #12]
   211d8:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   211dc:	d106      	bne.n	211ec <_fputwc_r+0x18>
   211de:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   211e2:	8193      	strh	r3, [r2, #12]
   211e4:	6e13      	ldr	r3, [r2, #96]	; 0x60
   211e6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   211ea:	6613      	str	r3, [r2, #96]	; 0x60
   211ec:	f7f8 b857 	b.w	1929e <__fputwc>

Disassembly of section .text.DRV_PIC32CGMAC_SingleListTailAdd%931:

000211f0 <DRV_PIC32CGMAC_SingleListTailAdd>:
	pN->next = 0;
   211f0:	2300      	movs	r3, #0
   211f2:	600b      	str	r3, [r1, #0]
	if(pL->tail == 0)
   211f4:	6843      	ldr	r3, [r0, #4]
   211f6:	b12b      	cbz	r3, 21204 <DRV_PIC32CGMAC_SingleListTailAdd+0x14>
		pL->tail->next = pN;
   211f8:	6019      	str	r1, [r3, #0]
		pL->tail = pN;
   211fa:	6041      	str	r1, [r0, #4]
    pL->nNodes++;
   211fc:	6883      	ldr	r3, [r0, #8]
   211fe:	3301      	adds	r3, #1
   21200:	6083      	str	r3, [r0, #8]
}
   21202:	4770      	bx	lr
		pL->head = pL->tail = pN;
   21204:	6041      	str	r1, [r0, #4]
   21206:	6001      	str	r1, [r0, #0]
   21208:	e7f8      	b.n	211fc <DRV_PIC32CGMAC_SingleListTailAdd+0xc>

Disassembly of section .text.Helper_SingleListTailAdd%932:

0002120a <Helper_SingleListTailAdd>:
	pN->next = 0;
   2120a:	2300      	movs	r3, #0
   2120c:	600b      	str	r3, [r1, #0]
	if(pL->tail == 0)
   2120e:	6843      	ldr	r3, [r0, #4]
   21210:	b12b      	cbz	r3, 2121e <Helper_SingleListTailAdd+0x14>
		pL->tail->next = pN;
   21212:	6019      	str	r1, [r3, #0]
		pL->tail = pN;
   21214:	6041      	str	r1, [r0, #4]
    pL->nNodes++;
   21216:	6883      	ldr	r3, [r0, #8]
   21218:	3301      	adds	r3, #1
   2121a:	6083      	str	r3, [r0, #8]
}
   2121c:	4770      	bx	lr
		pL->head = pL->tail = pN;
   2121e:	6041      	str	r1, [r0, #4]
   21220:	6001      	str	r1, [r0, #0]
   21222:	e7f8      	b.n	21216 <Helper_SingleListTailAdd+0xc>

Disassembly of section .text.DRV_MIIM_Read%933:

00021224 <DRV_MIIM_Read>:
{
   21224:	b510      	push	{r4, lr}
   21226:	b084      	sub	sp, #16
    return _DRV_MIIM_StartOp(handle, rIx, phyAdd, 0xffff, opFlags, pOpResult, DRV_MIIM_OP_READ);
   21228:	2401      	movs	r4, #1
   2122a:	9402      	str	r4, [sp, #8]
   2122c:	9c06      	ldr	r4, [sp, #24]
   2122e:	9401      	str	r4, [sp, #4]
   21230:	9300      	str	r3, [sp, #0]
   21232:	f64f 73ff 	movw	r3, #65535	; 0xffff
   21236:	f7f4 fe4f 	bl	15ed8 <_DRV_MIIM_StartOp>
}
   2123a:	b004      	add	sp, #16
   2123c:	bd10      	pop	{r4, pc}

Disassembly of section .text.DRV_MIIM_Write%934:

0002123e <DRV_MIIM_Write>:
{
   2123e:	b510      	push	{r4, lr}
   21240:	b084      	sub	sp, #16
    return _DRV_MIIM_StartOp(handle, rIx, phyAdd, wData, opFlags, pOpResult, DRV_MIIM_OP_WRITE);
   21242:	2402      	movs	r4, #2
   21244:	9402      	str	r4, [sp, #8]
   21246:	9c07      	ldr	r4, [sp, #28]
   21248:	9401      	str	r4, [sp, #4]
   2124a:	f89d 4018 	ldrb.w	r4, [sp, #24]
   2124e:	9400      	str	r4, [sp, #0]
   21250:	f7f4 fe42 	bl	15ed8 <_DRV_MIIM_StartOp>
}
   21254:	b004      	add	sp, #16
   21256:	bd10      	pop	{r4, pc}

Disassembly of section .text.DRV_MIIM_Scan%935:

00021258 <DRV_MIIM_Scan>:
{
   21258:	b510      	push	{r4, lr}
   2125a:	b084      	sub	sp, #16
    return _DRV_MIIM_StartOp(handle, rIx, phyAdd, 0xffff, opFlags, pOpResult, DRV_MIIM_OP_SCAN);
   2125c:	2403      	movs	r4, #3
   2125e:	9402      	str	r4, [sp, #8]
   21260:	9c06      	ldr	r4, [sp, #24]
   21262:	9401      	str	r4, [sp, #4]
   21264:	9300      	str	r3, [sp, #0]
   21266:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2126a:	f7f4 fe35 	bl	15ed8 <_DRV_MIIM_StartOp>
}
   2126e:	b004      	add	sp, #16
   21270:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_TCP_ClientOpen%936:

00021272 <TCPIP_TCP_ClientOpen>:
    if(addType == IP_ADDRESS_TYPE_IPV6)
   21272:	2802      	cmp	r0, #2
   21274:	d007      	beq.n	21286 <TCPIP_TCP_ClientOpen+0x14>
{
   21276:	b508      	push	{r3, lr}
   21278:	4613      	mov	r3, r2
   2127a:	460a      	mov	r2, r1
    skt = _TCP_Open(addType, TCP_OPEN_CLIENT, remotePort, remoteAddress);
   2127c:	2101      	movs	r1, #1
   2127e:	4608      	mov	r0, r1
   21280:	f7eb f9f2 	bl	c668 <_TCP_Open>
}
   21284:	bd08      	pop	{r3, pc}
        return INVALID_SOCKET; 
   21286:	f04f 30ff 	mov.w	r0, #4294967295
}
   2128a:	4770      	bx	lr

Disassembly of section .text.TCPIP_TCP_PutIsReady%937:

0002128c <TCPIP_TCP_PutIsReady>:
{
   2128c:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   2128e:	f7fe fdc5 	bl	1fe1c <_TcpSocketChk>
    return pSkt ? _TCPIsPutReady(pSkt) : 0;
   21292:	b120      	cbz	r0, 2129e <TCPIP_TCP_PutIsReady+0x12>
    if(pSkt->pTxPkt == 0)
   21294:	6c42      	ldr	r2, [r0, #68]	; 0x44
   21296:	b122      	cbz	r2, 212a2 <TCPIP_TCP_PutIsReady+0x16>
    return _TCPSocketTxFreeSize(pSkt);
   21298:	f7fd ff3e 	bl	1f118 <_TCPSocketTxFreeSize>
}
   2129c:	bd08      	pop	{r3, pc}
    return pSkt ? _TCPIsPutReady(pSkt) : 0;
   2129e:	2000      	movs	r0, #0
   212a0:	e7fc      	b.n	2129c <TCPIP_TCP_PutIsReady+0x10>
        return 0;
   212a2:	2000      	movs	r0, #0
   212a4:	e7fa      	b.n	2129c <TCPIP_TCP_PutIsReady+0x10>

Disassembly of section .text.TCPIP_DNS_IsResolved%938:

000212a6 <TCPIP_DNS_IsResolved>:
{
   212a6:	b508      	push	{r3, lr}
    if(type == IP_ADDRESS_TYPE_IPV4)
   212a8:	2a01      	cmp	r2, #1
   212aa:	d007      	beq.n	212bc <TCPIP_DNS_IsResolved+0x16>
    else if(type == IP_ADDRESS_TYPE_IPV6)
   212ac:	2a02      	cmp	r2, #2
        hostIPv6 = &hostIP->v6Add;
   212ae:	460a      	mov	r2, r1
   212b0:	bf08      	it	eq
   212b2:	2100      	moveq	r1, #0
    return _DNS_IsNameResolved(hostName, hostIPv4, hostIPv6, true);
   212b4:	2301      	movs	r3, #1
   212b6:	f7f3 fbd5 	bl	14a64 <_DNS_IsNameResolved>
}
   212ba:	bd08      	pop	{r3, pc}
        hostIPv6 = 0;
   212bc:	2200      	movs	r2, #0
   212be:	e7f9      	b.n	212b4 <TCPIP_DNS_IsResolved+0xe>

Disassembly of section .text.TCPIP_Helper_SingleListTailAdd%939:

000212c0 <TCPIP_Helper_SingleListTailAdd>:
	pN->next = 0;
   212c0:	2300      	movs	r3, #0
   212c2:	600b      	str	r3, [r1, #0]
	if(pL->tail == 0)
   212c4:	6843      	ldr	r3, [r0, #4]
   212c6:	b12b      	cbz	r3, 212d4 <TCPIP_Helper_SingleListTailAdd+0x14>
		pL->tail->next = pN;
   212c8:	6019      	str	r1, [r3, #0]
		pL->tail = pN;
   212ca:	6041      	str	r1, [r0, #4]
    pL->nNodes++;
   212cc:	6883      	ldr	r3, [r0, #8]
   212ce:	3301      	adds	r3, #1
   212d0:	6083      	str	r3, [r0, #8]
}
   212d2:	4770      	bx	lr
		pL->head = pL->tail = pN;
   212d4:	6041      	str	r1, [r0, #4]
   212d6:	6001      	str	r1, [r0, #0]
   212d8:	e7f8      	b.n	212cc <TCPIP_Helper_SingleListTailAdd+0xc>

Disassembly of section .text.TCPIP_Helper_SingleListAppend%940:

000212da <TCPIP_Helper_SingleListAppend>:
{
   212da:	b538      	push	{r3, r4, r5, lr}
   212dc:	4605      	mov	r5, r0
   212de:	460c      	mov	r4, r1
	while((pN = TCPIP_Helper_SingleListHeadRemove(pAList)))
   212e0:	4620      	mov	r0, r4
   212e2:	f7ff fe19 	bl	20f18 <TCPIP_Helper_SingleListHeadRemove>
   212e6:	4601      	mov	r1, r0
   212e8:	b118      	cbz	r0, 212f2 <TCPIP_Helper_SingleListAppend+0x18>
		TCPIP_Helper_SingleListTailAdd(pDstL, pN);
   212ea:	4628      	mov	r0, r5
   212ec:	f7ff ffe8 	bl	212c0 <TCPIP_Helper_SingleListTailAdd>
   212f0:	e7f6      	b.n	212e0 <TCPIP_Helper_SingleListAppend+0x6>
}
   212f2:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.TCPIP_STACK_NetIsReady%941:

000212f4 <TCPIP_STACK_NetIsReady>:
{
   212f4:	b508      	push	{r3, lr}
    TCPIP_NET_IF* pNetIf = _TCPIPStackHandleToNetLinked(netH);
   212f6:	f7ff fc0b 	bl	20b10 <_TCPIPStackHandleToNetLinked>
    if(pNetIf)
   212fa:	b130      	cbz	r0, 2130a <TCPIP_STACK_NetIsReady+0x16>
        return _TCPIPStackIsConfig(pNetIf) == 0;
   212fc:	f890 0043 	ldrb.w	r0, [r0, #67]	; 0x43
   21300:	f080 0010 	eor.w	r0, r0, #16
   21304:	f3c0 1000 	ubfx	r0, r0, #4, #1
}
   21308:	bd08      	pop	{r3, pc}
    return false;
   2130a:	2000      	movs	r0, #0
   2130c:	e7fc      	b.n	21308 <TCPIP_STACK_NetIsReady+0x14>

Disassembly of section .text.TCPIP_Notification_RemoveAll%942:

0002130e <TCPIP_Notification_RemoveAll>:

void TCPIP_Notification_RemoveAll(PROTECTED_SINGLE_LIST* notifyList, TCPIP_STACK_HEAP_HANDLE heapH)
{
   2130e:	b538      	push	{r3, r4, r5, lr}
   21310:	4605      	mov	r5, r0
   21312:	460c      	mov	r4, r1
    SGL_LIST_NODE* dNode;

    while( (dNode = TCPIP_Helper_ProtectedSingleListHeadRemove(notifyList)) != 0 )
   21314:	4628      	mov	r0, r5
   21316:	f7fe faed 	bl	1f8f4 <TCPIP_Helper_ProtectedSingleListHeadRemove>
   2131a:	4601      	mov	r1, r0
   2131c:	b118      	cbz	r0, 21326 <TCPIP_Notification_RemoveAll+0x18>
   2131e:	68e3      	ldr	r3, [r4, #12]
   21320:	4620      	mov	r0, r4
   21322:	4798      	blx	r3
   21324:	e7f6      	b.n	21314 <TCPIP_Notification_RemoveAll+0x6>
    {
        TCPIP_HEAP_Free(heapH, dNode);
    }

}
   21326:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text._UDPTxPktValid%943:

00021328 <_UDPTxPktValid>:
{
   21328:	b508      	push	{r3, lr}
    switch(pSkt->addType)
   2132a:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
   2132c:	2b01      	cmp	r3, #1
   2132e:	d001      	beq.n	21334 <_UDPTxPktValid+0xc>
            return false;
   21330:	2000      	movs	r0, #0
}
   21332:	bd08      	pop	{r3, pc}
            return _TxSktGetLockedV4Pkt(pSkt, false) != 0;
   21334:	2100      	movs	r1, #0
   21336:	f7fe fa13 	bl	1f760 <_TxSktGetLockedV4Pkt>
   2133a:	3000      	adds	r0, #0
   2133c:	bf18      	it	ne
   2133e:	2001      	movne	r0, #1
   21340:	e7f7      	b.n	21332 <_UDPTxPktValid+0xa>

Disassembly of section .text.TCPIP_UDP_TxPointerGet%944:

00021342 <TCPIP_UDP_TxPointerGet>:
{
   21342:	b510      	push	{r4, lr}
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   21344:	f7fe fe6e 	bl	20024 <_UDPSocketDcpt>
    if(pSkt && _UDPTxPktValid(pSkt))
   21348:	4604      	mov	r4, r0
   2134a:	b118      	cbz	r0, 21354 <TCPIP_UDP_TxPointerGet+0x12>
   2134c:	f7ff ffec 	bl	21328 <_UDPTxPktValid>
   21350:	b110      	cbz	r0, 21358 <TCPIP_UDP_TxPointerGet+0x16>
        return pSkt->txWrite;
   21352:	68a4      	ldr	r4, [r4, #8]
}
   21354:	4620      	mov	r0, r4
   21356:	bd10      	pop	{r4, pc}
    return 0;
   21358:	2400      	movs	r4, #0
   2135a:	e7fb      	b.n	21354 <TCPIP_UDP_TxPointerGet+0x12>

Disassembly of section .text.wc_InitRng%945:

0002135c <wc_InitRng>:
{
   2135c:	b500      	push	{lr}
   2135e:	b083      	sub	sp, #12
    return _InitRng(rng, NULL, 0, NULL, INVALID_DEVID);
   21360:	f06f 0301 	mvn.w	r3, #1
   21364:	9300      	str	r3, [sp, #0]
   21366:	2300      	movs	r3, #0
   21368:	461a      	mov	r2, r3
   2136a:	4619      	mov	r1, r3
   2136c:	f7ef fc6c 	bl	10c48 <_InitRng>
}
   21370:	b003      	add	sp, #12
   21372:	f85d fb04 	ldr.w	pc, [sp], #4

Disassembly of section .text.strchr%946:

00021376 <strchr>:
   21376:	b2c9      	uxtb	r1, r1
   21378:	4603      	mov	r3, r0
   2137a:	f810 2b01 	ldrb.w	r2, [r0], #1
   2137e:	b11a      	cbz	r2, 21388 <strchr+0x12>
   21380:	428a      	cmp	r2, r1
   21382:	d1f9      	bne.n	21378 <strchr+0x2>
   21384:	4618      	mov	r0, r3
   21386:	4770      	bx	lr
   21388:	2900      	cmp	r1, #0
   2138a:	bf18      	it	ne
   2138c:	2300      	movne	r3, #0
   2138e:	e7f9      	b.n	21384 <strchr+0xe>

Disassembly of section .text.__ascii_wctomb%947:

00021390 <__ascii_wctomb>:
   21390:	b149      	cbz	r1, 213a6 <__ascii_wctomb+0x16>
   21392:	2aff      	cmp	r2, #255	; 0xff
   21394:	bf85      	ittet	hi
   21396:	238a      	movhi	r3, #138	; 0x8a
   21398:	6003      	strhi	r3, [r0, #0]
   2139a:	700a      	strbls	r2, [r1, #0]
   2139c:	f04f 30ff 	movhi.w	r0, #4294967295
   213a0:	bf98      	it	ls
   213a2:	2001      	movls	r0, #1
   213a4:	4770      	bx	lr
   213a6:	4608      	mov	r0, r1
   213a8:	4770      	bx	lr

Disassembly of section .text.CRYPT_MD5_DataAdd%948:

000213aa <CRYPT_MD5_DataAdd>:


/* Add data to MD5 */
int CRYPT_MD5_DataAdd(CRYPT_MD5_CTX* md5, const unsigned char* input,
                      unsigned int sz)
{
   213aa:	b508      	push	{r3, lr}
    if (md5 == NULL || input == NULL)
   213ac:	b118      	cbz	r0, 213b6 <CRYPT_MD5_DataAdd+0xc>
   213ae:	b129      	cbz	r1, 213bc <CRYPT_MD5_DataAdd+0x12>
        return BAD_FUNC_ARG;

    return wc_Md5Update((Md5*)md5, input, sz);
   213b0:	f7f2 fff2 	bl	14398 <wc_Md5Update>
}
   213b4:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
   213b6:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   213ba:	e7fb      	b.n	213b4 <CRYPT_MD5_DataAdd+0xa>
   213bc:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   213c0:	e7f8      	b.n	213b4 <CRYPT_MD5_DataAdd+0xa>

Disassembly of section .text.CRYPT_MD5_Finalize%949:

000213c2 <CRYPT_MD5_Finalize>:


/* Get MD5 Final into digest */
int CRYPT_MD5_Finalize(CRYPT_MD5_CTX* md5, unsigned char* digest)
{
   213c2:	b508      	push	{r3, lr}
    if (md5 == NULL || digest == NULL)
   213c4:	b118      	cbz	r0, 213ce <CRYPT_MD5_Finalize+0xc>
   213c6:	b129      	cbz	r1, 213d4 <CRYPT_MD5_Finalize+0x12>
        return BAD_FUNC_ARG;

    return wc_Md5Final((Md5*)md5, digest);
   213c8:	f7f5 fb12 	bl	169f0 <wc_Md5Final>
}
   213cc:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
   213ce:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   213d2:	e7fb      	b.n	213cc <CRYPT_MD5_Finalize+0xa>
   213d4:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   213d8:	e7f8      	b.n	213cc <CRYPT_MD5_Finalize+0xa>

Disassembly of section .text.CRYPT_RNG_BlockGenerate%950:

000213da <CRYPT_RNG_BlockGenerate>:


/* RNG Block Generation of sz bytes, < 0 on error */
int CRYPT_RNG_BlockGenerate(CRYPT_RNG_CTX* rng, unsigned char* b,
                            unsigned int sz)
{
   213da:	b508      	push	{r3, lr}
    if (rng == NULL || b == NULL)
   213dc:	b118      	cbz	r0, 213e6 <CRYPT_RNG_BlockGenerate+0xc>
   213de:	b129      	cbz	r1, 213ec <CRYPT_RNG_BlockGenerate+0x12>
        return BAD_FUNC_ARG;

#if defined(WOLFSSL_MICROCHIP_SAME70)
    return same70_RNG_GenerateBlock(b, sz);
#else
    return wc_RNG_GenerateBlock((WC_RNG*)rng, b, sz);
   213e0:	f7f2 fa1a 	bl	13818 <wc_RNG_GenerateBlock>
#endif
}
   213e4:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
   213e6:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   213ea:	e7fb      	b.n	213e4 <CRYPT_RNG_BlockGenerate+0xa>
   213ec:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   213f0:	e7f8      	b.n	213e4 <CRYPT_RNG_BlockGenerate+0xa>

Disassembly of section .text.DRV_ETHPHY_Deinitialize%951:

000213f4 <DRV_ETHPHY_Deinitialize>:
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   213f4:	4b04      	ldr	r3, [pc, #16]	; (21408 <DRV_ETHPHY_Deinitialize+0x14>)
   213f6:	4283      	cmp	r3, r0
   213f8:	d104      	bne.n	21404 <DRV_ETHPHY_Deinitialize+0x10>
    if(phyInst != 0)
   213fa:	b118      	cbz	r0, 21404 <DRV_ETHPHY_Deinitialize+0x10>
        phyInst->status  = SYS_STATUS_UNINITIALIZED;
   213fc:	2200      	movs	r2, #0
   213fe:	711a      	strb	r2, [r3, #4]
        phyInst->objInUse  = false;
   21400:	701a      	strb	r2, [r3, #0]
        phyInst->pPhyObj = 0;
   21402:	615a      	str	r2, [r3, #20]
} 
   21404:	4770      	bx	lr
   21406:	bf00      	nop
   21408:	2000de18 	.word	0x2000de18

Disassembly of section .text._DRV_ETHPHY_NegCompletePhaseResultNoWait%952:

0002140c <_DRV_ETHPHY_NegCompletePhaseResultNoWait>:
{
   2140c:	b510      	push	{r4, lr}
   2140e:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   21410:	f7ff f9c8 	bl	207a4 <_DRV_PHY_SMITransfer_Wait>
   21414:	b900      	cbnz	r0, 21418 <_DRV_ETHPHY_NegCompletePhaseResultNoWait+0xc>
}
   21416:	bd10      	pop	{r4, pc}
    _DRV_PHY_NegCompleteSetOperResult(hClientObj, phyBMCon.w, phyStat.w);
   21418:	8f62      	ldrh	r2, [r4, #58]	; 0x3a
   2141a:	8ca1      	ldrh	r1, [r4, #36]	; 0x24
   2141c:	4620      	mov	r0, r4
   2141e:	f7fd fdea 	bl	1eff6 <_DRV_PHY_NegCompleteSetOperResult>
   21422:	e7f8      	b.n	21416 <_DRV_ETHPHY_NegCompletePhaseResultNoWait+0xa>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase5%953:

00021424 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase5>:
{
   21424:	b510      	push	{r4, lr}
   21426:	4604      	mov	r4, r0
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   21428:	2101      	movs	r1, #1
   2142a:	f7fd fd67 	bl	1eefc <_DRV_PHY_SMIReadStart>
   2142e:	b900      	cbnz	r0, 21432 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase5+0xe>
}
   21430:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   21432:	2303      	movs	r3, #3
   21434:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   21436:	2306      	movs	r3, #6
   21438:	8423      	strh	r3, [r4, #32]
}
   2143a:	e7f9      	b.n	21430 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase5+0xc>

Disassembly of section .text._DRV_ETHPHY_LinkStatPhaseIdle%954:

0002143c <_DRV_ETHPHY_LinkStatPhaseIdle>:
{
   2143c:	b510      	push	{r4, lr}
   2143e:	4604      	mov	r4, r0
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   21440:	2101      	movs	r1, #1
   21442:	f7fd fd5b 	bl	1eefc <_DRV_PHY_SMIReadStart>
   21446:	b900      	cbnz	r0, 2144a <_DRV_ETHPHY_LinkStatPhaseIdle+0xe>
}
   21448:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   2144a:	2301      	movs	r3, #1
   2144c:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   2144e:	2300      	movs	r3, #0
   21450:	8423      	strh	r3, [r4, #32]
}
   21452:	e7f9      	b.n	21448 <_DRV_ETHPHY_LinkStatPhaseIdle+0xc>

Disassembly of section .text._DRV_ETHPHY_NegCompletePhaseIdle%955:

00021454 <_DRV_ETHPHY_NegCompletePhaseIdle>:
{
   21454:	b510      	push	{r4, lr}
   21456:	4604      	mov	r4, r0
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMCON))
   21458:	2100      	movs	r1, #0
   2145a:	f7fd fd4f 	bl	1eefc <_DRV_PHY_SMIReadStart>
   2145e:	b900      	cbnz	r0, 21462 <_DRV_ETHPHY_NegCompletePhaseIdle+0xe>
}
   21460:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   21462:	2301      	movs	r3, #1
   21464:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   21466:	2300      	movs	r3, #0
   21468:	8423      	strh	r3, [r4, #32]
}
   2146a:	e7f9      	b.n	21460 <_DRV_ETHPHY_NegCompletePhaseIdle+0xc>

Disassembly of section .text._DRV_ETHPHY_NegResultPhaseIdle%956:

0002146c <_DRV_ETHPHY_NegResultPhaseIdle>:
{
   2146c:	b510      	push	{r4, lr}
   2146e:	4604      	mov	r4, r0
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   21470:	2101      	movs	r1, #1
   21472:	f7fd fd43 	bl	1eefc <_DRV_PHY_SMIReadStart>
   21476:	b900      	cbnz	r0, 2147a <_DRV_ETHPHY_NegResultPhaseIdle+0xe>
}
   21478:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   2147a:	2301      	movs	r3, #1
   2147c:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   2147e:	2300      	movs	r3, #0
   21480:	8423      	strh	r3, [r4, #32]
}
   21482:	e7f9      	b.n	21478 <_DRV_ETHPHY_NegResultPhaseIdle+0xc>

Disassembly of section .text._DRV_ETHPHY_NegRestartPhaseIdle%957:

00021484 <_DRV_ETHPHY_NegRestartPhaseIdle>:
{
   21484:	b510      	push	{r4, lr}
   21486:	4604      	mov	r4, r0
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   21488:	2101      	movs	r1, #1
   2148a:	f7fd fd37 	bl	1eefc <_DRV_PHY_SMIReadStart>
   2148e:	b900      	cbnz	r0, 21492 <_DRV_ETHPHY_NegRestartPhaseIdle+0xe>
}
   21490:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   21492:	2301      	movs	r3, #1
   21494:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   21496:	2300      	movs	r3, #0
   21498:	8423      	strh	r3, [r4, #32]
}
   2149a:	e7f9      	b.n	21490 <_DRV_ETHPHY_NegRestartPhaseIdle+0xc>

Disassembly of section .rodata._DRV_PHY_NegCompletePhasesTbl%958:

0002149c <_DRV_PHY_NegCompletePhasesTbl>:
   2149c:	1455 0002 e945 0001 cd81 0001 140d 0002     U...E...........
   214ac:	bfcf 0001 dfeb 0001                         ........

Disassembly of section .text.DRV_PIC32CGMAC_SingleListHeadAdd%959:

000214b4 <DRV_PIC32CGMAC_SingleListHeadAdd>:
	if(pN)
   214b4:	b131      	cbz	r1, 214c4 <DRV_PIC32CGMAC_SingleListHeadAdd+0x10>
		if(pL->head == 0)
   214b6:	6802      	ldr	r2, [r0, #0]
   214b8:	b12a      	cbz	r2, 214c6 <DRV_PIC32CGMAC_SingleListHeadAdd+0x12>
			pN->next = pL->head;
   214ba:	600a      	str	r2, [r1, #0]
			pL->head = pN;
   214bc:	6001      	str	r1, [r0, #0]
		pL->nNodes++;
   214be:	6883      	ldr	r3, [r0, #8]
   214c0:	3301      	adds	r3, #1
   214c2:	6083      	str	r3, [r0, #8]
}
   214c4:	4770      	bx	lr
			pL->head = pL->tail = pN;
   214c6:	6041      	str	r1, [r0, #4]
   214c8:	6001      	str	r1, [r0, #0]
   214ca:	e7f8      	b.n	214be <DRV_PIC32CGMAC_SingleListHeadAdd+0xa>

Disassembly of section .text.DRV_PIC32CGMAC_LibSysInt_Restore%960:

000214cc <DRV_PIC32CGMAC_LibSysInt_Restore>:
    if(queMask & GMAC_QUE0_MASK)
   214cc:	f011 0f01 	tst.w	r1, #1
   214d0:	d007      	beq.n	214e2 <DRV_PIC32CGMAC_LibSysInt_Restore+0x16>
        if(queStat)
   214d2:	b132      	cbz	r2, 214e2 <DRV_PIC32CGMAC_LibSysInt_Restore+0x16>
{
   214d4:	b508      	push	{r3, lr}
            SYS_INT_SourceRestore(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc, queStat[GMAC_QUE_0]); 
   214d6:	7811      	ldrb	r1, [r2, #0]
   214d8:	f9b0 00b6 	ldrsh.w	r0, [r0, #182]	; 0xb6
   214dc:	f7ff fb78 	bl	20bd0 <SYS_INT_SourceRestore>
}
   214e0:	bd08      	pop	{r3, pc}
   214e2:	4770      	bx	lr

Disassembly of section .text.DRV_MIIM_Close%961:

000214e4 <DRV_MIIM_Close>:
{
   214e4:	b510      	push	{r4, lr}
    DRV_MIIM_CLIENT_DCPT * pClient = _DRV_MIIM_GetClientAndLock(handle, true);
   214e6:	2101      	movs	r1, #1
   214e8:	f7fb f9c7 	bl	1c87a <_DRV_MIIM_GetClientAndLock>
    if(pClient != 0)
   214ec:	b128      	cbz	r0, 214fa <DRV_MIIM_Close+0x16>
   214ee:	4604      	mov	r4, r0
        _DRV_MIIM_ClientDeallocate(pClient);
   214f0:	f7f4 ff36 	bl	16360 <_DRV_MIIM_ClientDeallocate>
    OSAL_SEM_Post(&pMiimObj->objSem);
   214f4:	6860      	ldr	r0, [r4, #4]
   214f6:	f000 f86d 	bl	215d4 <OSAL_SEM_Post>
}
   214fa:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_ARP_HashKeyHash%962:

000214fc <TCPIP_ARP_HashKeyHash>:
{
   214fc:	b510      	push	{r4, lr}
   214fe:	4604      	mov	r4, r0
   21500:	4608      	mov	r0, r1
    return fnv_32_hash(key, sizeof(((ARP_HASH_ENTRY*)0)->ipAddress)) % (pOH->hEntries);
   21502:	2104      	movs	r1, #4
   21504:	f7fd fe68 	bl	1f1d8 <fnv_32_hash>
   21508:	68e3      	ldr	r3, [r4, #12]
   2150a:	fbb0 f2f3 	udiv	r2, r0, r3
}
   2150e:	fb02 0013 	mls	r0, r2, r3, r0
   21512:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_OAHASH_EntryRemove%963:

00021514 <TCPIP_OAHASH_EntryRemove>:
    if(pOE->flags.busy)
   21514:	780b      	ldrb	r3, [r1, #0]
   21516:	f013 0f01 	tst.w	r3, #1
   2151a:	d006      	beq.n	2152a <TCPIP_OAHASH_EntryRemove+0x16>
        pOE->flags.busy = 0;
   2151c:	780b      	ldrb	r3, [r1, #0]
   2151e:	f36f 0300 	bfc	r3, #0, #1
   21522:	700b      	strb	r3, [r1, #0]
        pOH->fullSlots--;
   21524:	6a43      	ldr	r3, [r0, #36]	; 0x24
   21526:	3b01      	subs	r3, #1
   21528:	6243      	str	r3, [r0, #36]	; 0x24
}
   2152a:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressGateway%964:

0002152c <TCPIP_STACK_NetAddressGateway>:
   2152c:	b140      	cbz	r0, 21540 <TCPIP_STACK_NetAddressGateway+0x14>
   2152e:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   21532:	f012 0f40 	tst.w	r2, #64	; 0x40
   21536:	d101      	bne.n	2153c <TCPIP_STACK_NetAddressGateway+0x10>
    return 0;
   21538:	2000      	movs	r0, #0
}
   2153a:	4770      	bx	lr
        return pNetIf->netGateway.Val;
   2153c:	68c0      	ldr	r0, [r0, #12]
   2153e:	4770      	bx	lr
    return 0;
   21540:	2000      	movs	r0, #0
   21542:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressDnsPrimary%965:

00021544 <TCPIP_STACK_NetAddressDnsPrimary>:
   21544:	b140      	cbz	r0, 21558 <TCPIP_STACK_NetAddressDnsPrimary+0x14>
   21546:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   2154a:	f012 0f40 	tst.w	r2, #64	; 0x40
   2154e:	d101      	bne.n	21554 <TCPIP_STACK_NetAddressDnsPrimary+0x10>
    return 0;
   21550:	2000      	movs	r0, #0
}
   21552:	4770      	bx	lr
        return pNetIf->dnsServer[0].Val;
   21554:	6900      	ldr	r0, [r0, #16]
   21556:	4770      	bx	lr
    return 0;
   21558:	2000      	movs	r0, #0
   2155a:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressDnsSecond%966:

0002155c <TCPIP_STACK_NetAddressDnsSecond>:
   2155c:	b140      	cbz	r0, 21570 <TCPIP_STACK_NetAddressDnsSecond+0x14>
   2155e:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   21562:	f012 0f40 	tst.w	r2, #64	; 0x40
   21566:	d101      	bne.n	2156c <TCPIP_STACK_NetAddressDnsSecond+0x10>
    return 0;
   21568:	2000      	movs	r0, #0
}
   2156a:	4770      	bx	lr
        return pNetIf->dnsServer[1].Val;
   2156c:	6940      	ldr	r0, [r0, #20]
   2156e:	4770      	bx	lr
    return 0;
   21570:	2000      	movs	r0, #0
   21572:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressGet%967:

00021574 <TCPIP_STACK_NetAddressGet>:
   21574:	b140      	cbz	r0, 21588 <TCPIP_STACK_NetAddressGet+0x14>
   21576:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   2157a:	f012 0f40 	tst.w	r2, #64	; 0x40
   2157e:	d101      	bne.n	21584 <TCPIP_STACK_NetAddressGet+0x10>
    return 0;
   21580:	2000      	movs	r0, #0
}
   21582:	4770      	bx	lr
    return pNetIf->netIPAddr.Val;
   21584:	6840      	ldr	r0, [r0, #4]
        return _TCPIPStackNetAddress(pNetIf);
   21586:	4770      	bx	lr
    return 0;
   21588:	2000      	movs	r0, #0
   2158a:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetMaskGet%968:

0002158c <TCPIP_STACK_NetMaskGet>:
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   2158c:	b140      	cbz	r0, 215a0 <TCPIP_STACK_NetMaskGet+0x14>
   2158e:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   21592:	f012 0f40 	tst.w	r2, #64	; 0x40
   21596:	d101      	bne.n	2159c <TCPIP_STACK_NetMaskGet+0x10>
    return 0;
   21598:	2000      	movs	r0, #0
}
   2159a:	4770      	bx	lr
        return pNetIf->netMask.Val;
   2159c:	6880      	ldr	r0, [r0, #8]
   2159e:	4770      	bx	lr
    return 0;
   215a0:	2000      	movs	r0, #0
   215a2:	4770      	bx	lr

Disassembly of section .rodata.TCPIP_FRAME_PROCESS_TBL%969:

000215a4 <TCPIP_FRAME_PROCESS_TBL>:
   215a4:	0806 0100 0002 0800 0000 0003 ffff 0000     ................
   215b4:	0004 ffff 0000 0005                         ........

Disassembly of section .text.OSAL_CRIT_Enter%970:

000215bc <OSAL_CRIT_Enter>:
{
   215bc:	b508      	push	{r3, lr}
  switch (severity)
   215be:	b118      	cbz	r0, 215c8 <OSAL_CRIT_Enter+0xc>
   215c0:	2801      	cmp	r0, #1
   215c2:	d004      	beq.n	215ce <OSAL_CRIT_Enter+0x12>
}
   215c4:	2000      	movs	r0, #0
   215c6:	bd08      	pop	{r3, pc}
      vTaskSuspendAll();
   215c8:	f000 fb38 	bl	21c3c <vTaskSuspendAll>
      break;
   215cc:	e7fa      	b.n	215c4 <OSAL_CRIT_Enter+0x8>
      portENTER_CRITICAL();
   215ce:	f7ff fb3f 	bl	20c50 <vPortEnterCritical>
      break;
   215d2:	e7f7      	b.n	215c4 <OSAL_CRIT_Enter+0x8>

Disassembly of section .text.OSAL_SEM_Post%971:

000215d4 <OSAL_SEM_Post>:
{
   215d4:	b508      	push	{r3, lr}
  if (xSemaphoreGive(*(SemaphoreHandle_t*)semID) == pdTRUE)
   215d6:	2300      	movs	r3, #0
   215d8:	461a      	mov	r2, r3
   215da:	4619      	mov	r1, r3
   215dc:	6800      	ldr	r0, [r0, #0]
   215de:	f7f1 fc9d 	bl	12f1c <xQueueGenericSend>
}
   215e2:	2801      	cmp	r0, #1
   215e4:	bf14      	ite	ne
   215e6:	2000      	movne	r0, #0
   215e8:	2001      	moveq	r0, #1
   215ea:	bd08      	pop	{r3, pc}

Disassembly of section .text.OSAL_MUTEX_Create%972:

000215ec <OSAL_MUTEX_Create>:
  if (*(SemaphoreHandle_t*)mutexID != NULL)
   215ec:	6803      	ldr	r3, [r0, #0]
   215ee:	b10b      	cbz	r3, 215f4 <OSAL_MUTEX_Create+0x8>
    return OSAL_RESULT_FALSE;
   215f0:	2000      	movs	r0, #0
}
   215f2:	4770      	bx	lr
{
   215f4:	b510      	push	{r4, lr}
   215f6:	4604      	mov	r4, r0
  *(SemaphoreHandle_t*)mutexID = xSemaphoreCreateMutex();
   215f8:	2001      	movs	r0, #1
   215fa:	f7ff f80d 	bl	20618 <xQueueCreateMutex>
   215fe:	6020      	str	r0, [r4, #0]
  return OSAL_RESULT_TRUE;
   21600:	2001      	movs	r0, #1
}
   21602:	bd10      	pop	{r4, pc}

Disassembly of section .text.OSAL_MUTEX_Unlock%973:

00021604 <OSAL_MUTEX_Unlock>:

  Remarks:

 */
OSAL_RESULT OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE* mutexID)
{
   21604:	b508      	push	{r3, lr}
  if (xSemaphoreGive(*(SemaphoreHandle_t*)mutexID) == pdTRUE)
   21606:	2300      	movs	r3, #0
   21608:	461a      	mov	r2, r3
   2160a:	4619      	mov	r1, r3
   2160c:	6800      	ldr	r0, [r0, #0]
   2160e:	f7f1 fc85 	bl	12f1c <xQueueGenericSend>
  {
    return OSAL_RESULT_TRUE;
  }

  return OSAL_RESULT_FALSE;
}
   21612:	2801      	cmp	r0, #1
   21614:	bf14      	ite	ne
   21616:	2000      	movne	r0, #0
   21618:	2001      	moveq	r0, #1
   2161a:	bd08      	pop	{r3, pc}

Disassembly of section .text.SERCOM1_USART_WritePendingBytesGet%974:

0002161c <SERCOM1_USART_WritePendingBytesGet>:
    uint32_t wrInIndex = sercom1USARTObj.wrInIndex;
   2161c:	4a04      	ldr	r2, [pc, #16]	; (21630 <SERCOM1_USART_WritePendingBytesGet+0x14>)
   2161e:	6893      	ldr	r3, [r2, #8]
    uint32_t wrOutIndex = sercom1USARTObj.wrOutIndex;
   21620:	68d0      	ldr	r0, [r2, #12]
    if ( wrInIndex >= wrOutIndex)
   21622:	4283      	cmp	r3, r0
        nPendingTxBytes =  (sercom1USARTObj.wrBufferSize -  wrOutIndex) + wrInIndex;
   21624:	bf3e      	ittt	cc
   21626:	4a02      	ldrcc	r2, [pc, #8]	; (21630 <SERCOM1_USART_WritePendingBytesGet+0x14>)
   21628:	6912      	ldrcc	r2, [r2, #16]
   2162a:	189b      	addcc	r3, r3, r2
   2162c:	1a18      	subs	r0, r3, r0
}
   2162e:	4770      	bx	lr
   21630:	2000dff0 	.word	0x2000dff0

Disassembly of section .text.SERCOM1_USART_ReadCountGet%975:

00021634 <SERCOM1_USART_ReadCountGet>:
    rdOutIndex = sercom1USARTObj.rdOutIndex;
   21634:	4b04      	ldr	r3, [pc, #16]	; (21648 <SERCOM1_USART_ReadCountGet+0x14>)
   21636:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    rdInIndex = sercom1USARTObj.rdInIndex;
   21638:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    if ( rdInIndex >=  rdOutIndex)
   2163a:	4298      	cmp	r0, r3
        nUnreadBytesAvailable =  (sercom1USARTObj.rdBufferSize -  rdOutIndex) + rdInIndex;
   2163c:	bf82      	ittt	hi
   2163e:	4a02      	ldrhi	r2, [pc, #8]	; (21648 <SERCOM1_USART_ReadCountGet+0x14>)
   21640:	6b12      	ldrhi	r2, [r2, #48]	; 0x30
   21642:	189b      	addhi	r3, r3, r2
   21644:	1a18      	subs	r0, r3, r0
}
   21646:	4770      	bx	lr
   21648:	2000dff0 	.word	0x2000dff0

Disassembly of section .text.TC0_TimerStart%976:

0002164c <TC0_TimerStart>:
    TC0_REGS->COUNT16.TC_CTRLA |= TC_CTRLA_ENABLE_Msk;
   2164c:	4a04      	ldr	r2, [pc, #16]	; (21660 <TC0_TimerStart+0x14>)
   2164e:	6813      	ldr	r3, [r2, #0]
   21650:	f043 0302 	orr.w	r3, r3, #2
   21654:	6013      	str	r3, [r2, #0]
    while((TC0_REGS->COUNT16.TC_SYNCBUSY & TC_SYNCBUSY_ENABLE_Msk) == TC_SYNCBUSY_ENABLE_Msk)
   21656:	6913      	ldr	r3, [r2, #16]
   21658:	f013 0f02 	tst.w	r3, #2
   2165c:	d1fb      	bne.n	21656 <TC0_TimerStart+0xa>
}
   2165e:	4770      	bx	lr
   21660:	40003800 	.word	0x40003800

Disassembly of section .text.TC0_TimerStop%977:

00021664 <TC0_TimerStop>:
    TC0_REGS->COUNT16.TC_CTRLA &= ~TC_CTRLA_ENABLE_Msk;
   21664:	4a04      	ldr	r2, [pc, #16]	; (21678 <TC0_TimerStop+0x14>)
   21666:	6813      	ldr	r3, [r2, #0]
   21668:	f023 0302 	bic.w	r3, r3, #2
   2166c:	6013      	str	r3, [r2, #0]
    while((TC0_REGS->COUNT16.TC_SYNCBUSY & TC_SYNCBUSY_ENABLE_Msk) == TC_SYNCBUSY_ENABLE_Msk)
   2166e:	6913      	ldr	r3, [r2, #16]
   21670:	f013 0f02 	tst.w	r3, #2
   21674:	d1fb      	bne.n	2166e <TC0_TimerStop+0xa>
}
   21676:	4770      	bx	lr
   21678:	40003800 	.word	0x40003800

Disassembly of section .text._keyDownProcess%978:

0002167c <_keyDownProcess>:
{   // down arrow
   2167c:	b508      	push	{r3, lr}
    if(pCmdIO->currHistN)
   2167e:	f8d0 30d4 	ldr.w	r3, [r0, #212]	; 0xd4
   21682:	b133      	cbz	r3, 21692 <_keyDownProcess+0x16>
        pNext = pCmdIO->currHistN->prev;
   21684:	6859      	ldr	r1, [r3, #4]
        if(pNext != pCmdIO->histList.tail)
   21686:	f8d0 30d0 	ldr.w	r3, [r0, #208]	; 0xd0
   2168a:	428b      	cmp	r3, r1
   2168c:	d001      	beq.n	21692 <_keyDownProcess+0x16>
            DisplayNodeMsg(pCmdIO, pNext);
   2168e:	f7f6 fea7 	bl	183e0 <DisplayNodeMsg>
}
   21692:	bd08      	pop	{r3, pc}

Disassembly of section .text.CommandReset%979:

00021694 <CommandReset>:
{
   21694:	b508      	push	{r3, lr}
    (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** System Reboot ***\r\n" );
   21696:	6803      	ldr	r3, [r0, #0]
   21698:	681b      	ldr	r3, [r3, #0]
   2169a:	4903      	ldr	r1, [pc, #12]	; (216a8 <CommandReset+0x14>)
   2169c:	6840      	ldr	r0, [r0, #4]
   2169e:	4798      	blx	r3
    SYS_RESET_SoftwareReset();
   216a0:	f7fe ff6e 	bl	20580 <SYS_RESET_SoftwareReset>
}
   216a4:	bd08      	pop	{r3, pc}
   216a6:	bf00      	nop
   216a8:	0000d1c8 	.word	0x0000d1c8

Disassembly of section .text._SYS_RANDOM_CryptoContext%980:

000216ac <_SYS_RANDOM_CryptoContext>:
{
   216ac:	b508      	push	{r3, lr}
    if(pRandCtx == 0)
   216ae:	4b04      	ldr	r3, [pc, #16]	; (216c0 <_SYS_RANDOM_CryptoContext+0x14>)
   216b0:	681b      	ldr	r3, [r3, #0]
   216b2:	b113      	cbz	r3, 216ba <_SYS_RANDOM_CryptoContext+0xe>
} 
   216b4:	4b02      	ldr	r3, [pc, #8]	; (216c0 <_SYS_RANDOM_CryptoContext+0x14>)
   216b6:	6818      	ldr	r0, [r3, #0]
   216b8:	bd08      	pop	{r3, pc}
        SYS_RANDOM_CryptoInitialize();
   216ba:	f7ff fa99 	bl	20bf0 <SYS_RANDOM_CryptoInitialize>
   216be:	e7f9      	b.n	216b4 <_SYS_RANDOM_CryptoContext+0x8>
   216c0:	2000e484 	.word	0x2000e484

Disassembly of section .text._TCPIP_STACK_Task%981:

000216c4 <_TCPIP_STACK_Task>:
{
   216c4:	b508      	push	{r3, lr}
        TCPIP_STACK_Task(sysObj.tcpip);
   216c6:	4d04      	ldr	r5, [pc, #16]	; (216d8 <_TCPIP_STACK_Task+0x14>)
        vTaskDelay(1 / portTICK_PERIOD_MS);
   216c8:	2401      	movs	r4, #1
        TCPIP_STACK_Task(sysObj.tcpip);
   216ca:	68a8      	ldr	r0, [r5, #8]
   216cc:	f7e5 fcb0 	bl	7030 <TCPIP_STACK_Task>
        vTaskDelay(1 / portTICK_PERIOD_MS);
   216d0:	4620      	mov	r0, r4
   216d2:	f7fd fb91 	bl	1edf8 <vTaskDelay>
   216d6:	e7f8      	b.n	216ca <_TCPIP_STACK_Task+0x6>
   216d8:	2000e264 	.word	0x2000e264

Disassembly of section .text._DRV_MIIM_Task%982:

000216dc <_DRV_MIIM_Task>:
{
   216dc:	b508      	push	{r3, lr}
        DRV_MIIM_Tasks(sysObj.drvMiim);
   216de:	4d04      	ldr	r5, [pc, #16]	; (216f0 <_DRV_MIIM_Task+0x14>)
        vTaskDelay(1 / portTICK_PERIOD_MS);
   216e0:	2401      	movs	r4, #1
        DRV_MIIM_Tasks(sysObj.drvMiim);
   216e2:	68e8      	ldr	r0, [r5, #12]
   216e4:	f7f0 fa6a 	bl	11bbc <DRV_MIIM_Tasks>
        vTaskDelay(1 / portTICK_PERIOD_MS);
   216e8:	4620      	mov	r0, r4
   216ea:	f7fd fb85 	bl	1edf8 <vTaskDelay>
   216ee:	e7f8      	b.n	216e2 <_DRV_MIIM_Task+0x6>
   216f0:	2000e264 	.word	0x2000e264

Disassembly of section .rodata.sysConsole0UARTPlibAPI%983:

000216f4 <sysConsole0UARTPlibAPI>:
   216f4:	00019d59 00021635 00021955 000174e9     Y...5...U....t..
   21704:	0002219f 00021969                       .!..i...

Disassembly of section .rodata.tcpipDNSClientInitData%984:

0002170c <tcpipDNSClientInitData>:
   2170c:	00000001 00000005 00000000 00000005     ................
   2171c:	00000001 00000001                       ........

Disassembly of section .text.vTaskInternalSetTimeOutState%985:

00021724 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
   21724:	4b03      	ldr	r3, [pc, #12]	; (21734 <vTaskInternalSetTimeOutState+0x10>)
   21726:	681b      	ldr	r3, [r3, #0]
   21728:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   2172a:	4b03      	ldr	r3, [pc, #12]	; (21738 <vTaskInternalSetTimeOutState+0x14>)
   2172c:	681b      	ldr	r3, [r3, #0]
   2172e:	6043      	str	r3, [r0, #4]
}
   21730:	4770      	bx	lr
   21732:	bf00      	nop
   21734:	2000e4c4 	.word	0x2000e4c4
   21738:	2000e4d0 	.word	0x2000e4d0

Disassembly of section .rodata.__func__.8948%986:

0002173c <__func__.8948>:
   2173c:	5f786667 6f6e6f6d 6172645f 74735f77     gfx_mono_draw_st
   2174c:	676e6972 bf000000                       ring....

Disassembly of section .text.DRV_MIIM_ClientStatus%987:

00021754 <DRV_MIIM_ClientStatus>:
{
   21754:	b508      	push	{r3, lr}
    DRV_MIIM_CLIENT_DCPT * pClient = _DRV_MIIM_GetClientAndLock(handle, false);
   21756:	2100      	movs	r1, #0
   21758:	f7fb f88f 	bl	1c87a <_DRV_MIIM_GetClientAndLock>
    if(pClient == 0)
   2175c:	b110      	cbz	r0, 21764 <DRV_MIIM_ClientStatus+0x10>
    return pClient->cliStatus; 
   2175e:	f990 000c 	ldrsb.w	r0, [r0, #12]
}
   21762:	bd08      	pop	{r3, pc}
        return DRV_MIIM_CLIENT_STATUS_ERROR;
   21764:	f04f 30ff 	mov.w	r0, #4294967295
   21768:	e7fb      	b.n	21762 <DRV_MIIM_ClientStatus+0xe>

Disassembly of section .text.TCPIP_TCP_WasDisconnected%988:

0002176a <TCPIP_TCP_WasDisconnected>:
{
   2176a:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   2176c:	f7fe fb56 	bl	1fe1c <_TcpSocketChk>
    if(pSkt)
   21770:	b120      	cbz	r0, 2177c <TCPIP_TCP_WasDisconnected+0x12>
        return pSkt->Flags.bRxFin != 0;
   21772:	f890 0037 	ldrb.w	r0, [r0, #55]	; 0x37
   21776:	f3c0 0080 	ubfx	r0, r0, #2, #1
}
   2177a:	bd08      	pop	{r3, pc}
    return false;
   2177c:	2000      	movs	r0, #0
   2177e:	e7fc      	b.n	2177a <TCPIP_TCP_WasDisconnected+0x10>

Disassembly of section .text._IperfUDPRxSignalHandler%989:

00021780 <_IperfUDPRxSignalHandler>:
    if(sigType == TCPIP_UDP_SIGNAL_RX_DATA)
   21780:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
   21784:	d000      	beq.n	21788 <_IperfUDPRxSignalHandler+0x8>
   21786:	4770      	bx	lr
{
   21788:	b508      	push	{r3, lr}
        _TCPIPStackModuleSignalRequest(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_RX_PENDING, true); 
   2178a:	2201      	movs	r2, #1
   2178c:	4611      	mov	r1, r2
   2178e:	2020      	movs	r0, #32
   21790:	f7fa fb44 	bl	1be1c <_TCPIPStackModuleSignalRequest>
}
   21794:	bd08      	pop	{r3, pc}

Disassembly of section .text._IperfTCPRxSignalHandler%990:

00021796 <_IperfTCPRxSignalHandler>:
    if(sigType == TCPIP_TCP_SIGNAL_RX_DATA)
   21796:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
   2179a:	d000      	beq.n	2179e <_IperfTCPRxSignalHandler+0x8>
   2179c:	4770      	bx	lr
{
   2179e:	b508      	push	{r3, lr}
        _TCPIPStackModuleSignalRequest(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_RX_PENDING, true); 
   217a0:	2201      	movs	r2, #1
   217a2:	4611      	mov	r1, r2
   217a4:	2020      	movs	r0, #32
   217a6:	f7fa fb39 	bl	1be1c <_TCPIPStackModuleSignalRequest>
}
   217aa:	bd08      	pop	{r3, pc}

Disassembly of section .text._TCPIP_HEAP_LastError%991:

000217ac <_TCPIP_HEAP_LastError>:
    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   217ac:	4603      	mov	r3, r0
   217ae:	b128      	cbz	r0, 217bc <_TCPIP_HEAP_LastError+0x10>

    hDcpt = _TCPIP_HEAP_ObjDcpt(heapH);

    if(hDcpt)
    {
        res = hDcpt->_lastHeapErr;
   217b0:	f990 0038 	ldrsb.w	r0, [r0, #56]	; 0x38
        hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_OK;
   217b4:	2200      	movs	r2, #0
   217b6:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
        return res;
   217ba:	4770      	bx	lr
    }

    return TCPIP_STACK_HEAP_RES_NO_HEAP;
   217bc:	f06f 0008 	mvn.w	r0, #8

}
   217c0:	4770      	bx	lr

Disassembly of section .text._DHCPSocketRxSignalHandler%992:

000217c2 <_DHCPSocketRxSignalHandler>:
    if(sigType == TCPIP_UDP_SIGNAL_RX_DATA)
   217c2:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
   217c6:	d000      	beq.n	217ca <_DHCPSocketRxSignalHandler+0x8>
   217c8:	4770      	bx	lr
{
   217ca:	b508      	push	{r3, lr}
        _TCPIPStackModuleSignalRequest(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_RX_PENDING, true); 
   217cc:	2201      	movs	r2, #1
   217ce:	4611      	mov	r1, r2
   217d0:	200c      	movs	r0, #12
   217d2:	f7fa fb23 	bl	1be1c <_TCPIPStackModuleSignalRequest>
}
   217d6:	bd08      	pop	{r3, pc}

Disassembly of section .text._DNSSocketRxSignalHandler%993:

000217d8 <_DNSSocketRxSignalHandler>:
    if(sigType == TCPIP_UDP_SIGNAL_RX_DATA)
   217d8:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
   217dc:	d000      	beq.n	217e0 <_DNSSocketRxSignalHandler+0x8>
   217de:	4770      	bx	lr
{
   217e0:	b508      	push	{r3, lr}
        _TCPIPStackModuleSignalRequest(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_RX_PENDING, true); 
   217e2:	2201      	movs	r2, #1
   217e4:	4611      	mov	r1, r2
   217e6:	200f      	movs	r0, #15
   217e8:	f7fa fb18 	bl	1be1c <_TCPIPStackModuleSignalRequest>
}
   217ec:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_STACK_AddressServiceCanStart%994:

000217ee <TCPIP_STACK_AddressServiceCanStart>:
    if(pNetIf)
   217ee:	b138      	cbz	r0, 21800 <TCPIP_STACK_AddressServiceCanStart+0x12>
        return (pNetIf->Flags.v & TCPIP_STACK_ADDRESS_SERVICE_MASK) == TCPIP_STACK_ADDRESS_SERVICE_NONE;
   217f0:	f8b0 3042 	ldrh.w	r3, [r0, #66]	; 0x42
   217f4:	f013 0f07 	tst.w	r3, #7
   217f8:	bf0c      	ite	eq
   217fa:	2001      	moveq	r0, #1
   217fc:	2000      	movne	r0, #0
   217fe:	4770      	bx	lr
    return false;
   21800:	2000      	movs	r0, #0
}
   21802:	4770      	bx	lr

Disassembly of section .text._TCPIPStackPacketTx%995:

00021804 <_TCPIPStackPacketTx>:
    return pNetIf->hIfMac != 0 ? (*pNetIf->pMacObj->TCPIP_MAC_PacketTx)(pNetIf->hIfMac, ptrPacket) : TCPIP_MAC_RES_NOT_READY_ERR;
   21804:	6d02      	ldr	r2, [r0, #80]	; 0x50
   21806:	b12a      	cbz	r2, 21814 <_TCPIPStackPacketTx+0x10>
{
   21808:	b508      	push	{r3, lr}
    return pNetIf->hIfMac != 0 ? (*pNetIf->pMacObj->TCPIP_MAC_PacketTx)(pNetIf->hIfMac, ptrPacket) : TCPIP_MAC_RES_NOT_READY_ERR;
   2180a:	6c43      	ldr	r3, [r0, #68]	; 0x44
   2180c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   2180e:	4610      	mov	r0, r2
   21810:	4798      	blx	r3
}
   21812:	bd08      	pop	{r3, pc}
    return pNetIf->hIfMac != 0 ? (*pNetIf->pMacObj->TCPIP_MAC_PacketTx)(pNetIf->hIfMac, ptrPacket) : TCPIP_MAC_RES_NOT_READY_ERR;
   21814:	f06f 000c 	mvn.w	r0, #12
}
   21818:	4770      	bx	lr

Disassembly of section .text.OSAL_CRIT_Leave%996:

0002181a <OSAL_CRIT_Leave>:
{
   2181a:	b508      	push	{r3, lr}
  switch (severity)
   2181c:	b110      	cbz	r0, 21824 <OSAL_CRIT_Leave+0xa>
   2181e:	2801      	cmp	r0, #1
   21820:	d003      	beq.n	2182a <OSAL_CRIT_Leave+0x10>
}
   21822:	bd08      	pop	{r3, pc}
      xTaskResumeAll();
   21824:	f7f3 fcce 	bl	151c4 <xTaskResumeAll>
      break;
   21828:	e7fb      	b.n	21822 <OSAL_CRIT_Leave+0x8>
      portEXIT_CRITICAL();
   2182a:	f000 f8d9 	bl	219e0 <vPortExitCritical>
}
   2182e:	e7f8      	b.n	21822 <OSAL_CRIT_Leave+0x8>

Disassembly of section .text.vListInitialise%997:

00021830 <vListInitialise>:
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   21830:	f100 0308 	add.w	r3, r0, #8
   21834:	6043      	str	r3, [r0, #4]
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   21836:	f04f 32ff 	mov.w	r2, #4294967295
   2183a:	6082      	str	r2, [r0, #8]
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   2183c:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   2183e:	6103      	str	r3, [r0, #16]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
   21840:	2300      	movs	r3, #0
   21842:	6003      	str	r3, [r0, #0]
}
   21844:	4770      	bx	lr

Disassembly of section .text.vListInsertEnd%998:

00021846 <vListInsertEnd>:
ListItem_t * const pxIndex = pxList->pxIndex;
   21846:	6843      	ldr	r3, [r0, #4]
	pxNewListItem->pxNext = pxIndex;
   21848:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
   2184a:	689a      	ldr	r2, [r3, #8]
   2184c:	608a      	str	r2, [r1, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
   2184e:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
   21850:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxContainer = pxList;
   21852:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
   21854:	6803      	ldr	r3, [r0, #0]
   21856:	3301      	adds	r3, #1
   21858:	6003      	str	r3, [r0, #0]
}
   2185a:	4770      	bx	lr

Disassembly of section .text.prvIsQueueEmpty%999:

0002185c <prvIsQueueEmpty>:
{
   2185c:	b510      	push	{r4, lr}
   2185e:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
   21860:	f7ff f9f6 	bl	20c50 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
   21864:	6ba4      	ldr	r4, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
   21866:	f000 f8bb 	bl	219e0 <vPortExitCritical>
}
   2186a:	fab4 f084 	clz	r0, r4
   2186e:	0940      	lsrs	r0, r0, #5
   21870:	bd10      	pop	{r4, pc}

Disassembly of section .text.xQueueCreateCountingSemaphore%1000:

00021872 <xQueueCreateCountingSemaphore>:
	{
   21872:	b510      	push	{r4, lr}
   21874:	460c      	mov	r4, r1
		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
   21876:	2202      	movs	r2, #2
   21878:	2100      	movs	r1, #0
   2187a:	f7fd fde5 	bl	1f448 <xQueueGenericCreate>
		if( xHandle != NULL )
   2187e:	4603      	mov	r3, r0
   21880:	b100      	cbz	r0, 21884 <xQueueCreateCountingSemaphore+0x12>
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
   21882:	6384      	str	r4, [r0, #56]	; 0x38
	}
   21884:	4618      	mov	r0, r3
   21886:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_InitMd5%1001:

00021888 <wc_InitMd5>:
#endif /* !HAVE_MD5_CUST_API */


int wc_InitMd5(wc_Md5* md5)
{
   21888:	b508      	push	{r3, lr}
    if (md5 == NULL) {
   2188a:	b128      	cbz	r0, 21898 <wc_InitMd5+0x10>
        return BAD_FUNC_ARG;
    }
    return wc_InitMd5_ex(md5, NULL, INVALID_DEVID);
   2188c:	f06f 0201 	mvn.w	r2, #1
   21890:	2100      	movs	r1, #0
   21892:	f7fc fda9 	bl	1e3e8 <wc_InitMd5_ex>
}
   21896:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
   21898:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   2189c:	e7fb      	b.n	21896 <wc_InitMd5+0xe>

Disassembly of section .rodata._DRV_PHY_NegResultPhasesTbl%1002:

000218a0 <_DRV_PHY_NegResultPhasesTbl>:
   218a0:	146d 0002 b05d 0001 0231 0002 0257 0002     m...]...1...W...
   218b0:	56e9 0001                                   .V..

Disassembly of section .rodata.DRV_ETHPHY_OBJECT_LAN867x%1003:

000218b4 <DRV_ETHPHY_OBJECT_LAN867x>:
   218b4:	fa35 0000 4c45 0000 b319 0001 0000 0000     5...EL..........
   218c4:	57bb 0001                                   .W..

Disassembly of section .rodata._DRV_GMAC_LinkStateTbl%1004:

000218c8 <_DRV_GMAC_LinkStateTbl>:
   218c8:	fbe1 0001 d28f 0001 b8cd 0001 d7ed 0001     ................
   218d8:	9e49 0001                                   I...

Disassembly of section .text.DRV_PIC32CGMAC_LibGetHighPrioReadyQue%1005:

000218dc <DRV_PIC32CGMAC_LibGetHighPrioReadyQue>:
    if(drvGmacQueEvents & GMAC_QUE0_MASK)
   218dc:	4b03      	ldr	r3, [pc, #12]	; (218ec <DRV_PIC32CGMAC_LibGetHighPrioReadyQue+0x10>)
   218de:	6818      	ldr	r0, [r3, #0]
   218e0:	f080 0001 	eor.w	r0, r0, #1
   218e4:	f340 0000 	sbfx	r0, r0, #0, #1
}
   218e8:	b2c0      	uxtb	r0, r0
   218ea:	4770      	bx	lr
   218ec:	2000e370 	.word	0x2000e370

Disassembly of section .text.Ipv4DeRegisterCallback%1006:

000218f0 <Ipv4DeRegisterCallback>:
    if(filtNode->active)
   218f0:	7a03      	ldrb	r3, [r0, #8]
   218f2:	b11b      	cbz	r3, 218fc <Ipv4DeRegisterCallback+0xc>
        ipv4ActFilterCount--;
   218f4:	4a02      	ldr	r2, [pc, #8]	; (21900 <Ipv4DeRegisterCallback+0x10>)
   218f6:	6813      	ldr	r3, [r2, #0]
   218f8:	3b01      	subs	r3, #1
   218fa:	6013      	str	r3, [r2, #0]
}
   218fc:	4770      	bx	lr
   218fe:	bf00      	nop
   21900:	2000e3f4 	.word	0x2000e3f4

Disassembly of section .text.TCPIP_HEAP_Create%1007:

00021904 <TCPIP_HEAP_Create>:
#if !defined(TCPIP_STACK_DRAM_DEBUG_ENABLE) 

// functions needed when debugging is not enabled

TCPIP_STACK_HEAP_HANDLE TCPIP_HEAP_Create(const TCPIP_STACK_HEAP_CONFIG* initData, TCPIP_STACK_HEAP_RES* pRes)
{
   21904:	b508      	push	{r3, lr}
    if(initData != 0)
   21906:	b118      	cbz	r0, 21910 <TCPIP_HEAP_Create+0xc>
    {
        switch (initData->heapType)
   21908:	7802      	ldrb	r2, [r0, #0]
   2190a:	2a01      	cmp	r2, #1
   2190c:	d001      	beq.n	21912 <TCPIP_HEAP_Create+0xe>
            default:
                break;
        }
    }

    return 0;
   2190e:	2000      	movs	r0, #0
}
   21910:	bd08      	pop	{r3, pc}
                return TCPIP_HEAP_CreateInternal((const TCPIP_STACK_HEAP_INTERNAL_CONFIG*)initData, pRes);
   21912:	f7f4 f887 	bl	15a24 <TCPIP_HEAP_CreateInternal>
   21916:	e7fb      	b.n	21910 <TCPIP_HEAP_Create+0xc>

Disassembly of section .text._DHCPOptionWriteEnd%1008:

00021918 <_DHCPOptionWriteEnd>:
    if(pSendData->writeSpace >= sizeof(*pEnd))
   21918:	684b      	ldr	r3, [r1, #4]
   2191a:	b913      	cbnz	r3, 21922 <_DHCPOptionWriteEnd+0xa>
    return -1;
   2191c:	f04f 30ff 	mov.w	r0, #4294967295
}
   21920:	4770      	bx	lr
        pEnd = (TCPIP_DHCP_OPTION_DATA_END*)pSendData->pOpt;
   21922:	680b      	ldr	r3, [r1, #0]
        pEnd->opt = TCPIP_DHCP_END_OPTION;
   21924:	22ff      	movs	r2, #255	; 0xff
   21926:	701a      	strb	r2, [r3, #0]
        return sizeof(*pEnd);
   21928:	2001      	movs	r0, #1
   2192a:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetUpMACAddressGet%1009:

0002192c <TCPIP_STACK_NetUpMACAddressGet>:
   2192c:	b128      	cbz	r0, 2193a <TCPIP_STACK_NetUpMACAddressGet+0xe>
   2192e:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   21932:	f012 0f40 	tst.w	r2, #64	; 0x40
   21936:	d101      	bne.n	2193c <TCPIP_STACK_NetUpMACAddressGet+0x10>
    return 0;
   21938:	2000      	movs	r0, #0
}
   2193a:	4770      	bx	lr
        return pNetIf->netMACAddr.v;
   2193c:	303c      	adds	r0, #60	; 0x3c
   2193e:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_HeapHandleGet%1010:

00021940 <TCPIP_STACK_HeapHandleGet>:
    return TCPIP_MODULE_SIGNAL_NONE; 
}

TCPIP_STACK_HEAP_HANDLE TCPIP_STACK_HeapHandleGet(TCPIP_STACK_HEAP_TYPE heapType, int heapIndex)
{
    return (heapType == tcpip_stack_ctrl_data.heapType) ? tcpip_stack_ctrl_data.memH : 0;
   21940:	4b03      	ldr	r3, [pc, #12]	; (21950 <TCPIP_STACK_HeapHandleGet+0x10>)
   21942:	7c1b      	ldrb	r3, [r3, #16]
   21944:	4283      	cmp	r3, r0
   21946:	bf06      	itte	eq
   21948:	4b01      	ldreq	r3, [pc, #4]	; (21950 <TCPIP_STACK_HeapHandleGet+0x10>)
   2194a:	68d8      	ldreq	r0, [r3, #12]
   2194c:	2000      	movne	r0, #0
}
   2194e:	4770      	bx	lr
   21950:	2000e0f0 	.word	0x2000e0f0

Disassembly of section .text.SERCOM1_USART_ReadFreeBufferCountGet%1011:

00021954 <SERCOM1_USART_ReadFreeBufferCountGet>:
{
   21954:	b510      	push	{r4, lr}
    return (sercom1USARTObj.rdBufferSize - 1U) - SERCOM1_USART_ReadCountGet();
   21956:	4b03      	ldr	r3, [pc, #12]	; (21964 <SERCOM1_USART_ReadFreeBufferCountGet+0x10>)
   21958:	6b1c      	ldr	r4, [r3, #48]	; 0x30
   2195a:	f7ff fe6b 	bl	21634 <SERCOM1_USART_ReadCountGet>
   2195e:	3c01      	subs	r4, #1
}
   21960:	1a20      	subs	r0, r4, r0
   21962:	bd10      	pop	{r4, pc}
   21964:	2000dff0 	.word	0x2000dff0

Disassembly of section .text.SERCOM1_USART_WriteFreeBufferCountGet%1012:

00021968 <SERCOM1_USART_WriteFreeBufferCountGet>:
{
   21968:	b510      	push	{r4, lr}
    return (sercom1USARTObj.wrBufferSize - 1U) - SERCOM1_USART_WriteCountGet();
   2196a:	4b03      	ldr	r3, [pc, #12]	; (21978 <SERCOM1_USART_WriteFreeBufferCountGet+0x10>)
   2196c:	691c      	ldr	r4, [r3, #16]
    nPendingTxBytes = SERCOM1_USART_WritePendingBytesGet();
   2196e:	f7ff fe55 	bl	2161c <SERCOM1_USART_WritePendingBytesGet>
    return (sercom1USARTObj.wrBufferSize - 1U) - SERCOM1_USART_WriteCountGet();
   21972:	3c01      	subs	r4, #1
}
   21974:	1a20      	subs	r0, r4, r0
   21976:	bd10      	pop	{r4, pc}
   21978:	2000dff0 	.word	0x2000dff0

Disassembly of section .text.TC0_Timer16bitPeriodSet%1013:

0002197c <TC0_Timer16bitPeriodSet>:
    TC0_REGS->COUNT16.TC_CC[0] = period;
   2197c:	4b03      	ldr	r3, [pc, #12]	; (2198c <TC0_Timer16bitPeriodSet+0x10>)
   2197e:	8398      	strh	r0, [r3, #28]
    while((TC0_REGS->COUNT16.TC_SYNCBUSY & TC_SYNCBUSY_CC0_Msk) == TC_SYNCBUSY_CC0_Msk)
   21980:	461a      	mov	r2, r3
   21982:	6913      	ldr	r3, [r2, #16]
   21984:	f013 0f40 	tst.w	r3, #64	; 0x40
   21988:	d1fb      	bne.n	21982 <TC0_Timer16bitPeriodSet+0x6>
}
   2198a:	4770      	bx	lr
   2198c:	40003800 	.word	0x40003800

Disassembly of section .text.TC0_Timer16bitCompareSet%1014:

00021990 <TC0_Timer16bitCompareSet>:
    TC0_REGS->COUNT16.TC_CC[1] = compare;
   21990:	4b03      	ldr	r3, [pc, #12]	; (219a0 <TC0_Timer16bitCompareSet+0x10>)
   21992:	83d8      	strh	r0, [r3, #30]
    while((TC0_REGS->COUNT16.TC_SYNCBUSY & TC_SYNCBUSY_CC1_Msk) == TC_SYNCBUSY_CC1_Msk)
   21994:	461a      	mov	r2, r3
   21996:	6913      	ldr	r3, [r2, #16]
   21998:	f013 0f80 	tst.w	r3, #128	; 0x80
   2199c:	d1fb      	bne.n	21996 <TC0_Timer16bitCompareSet+0x6>
}
   2199e:	4770      	bx	lr
   219a0:	40003800 	.word	0x40003800

Disassembly of section .rodata.sysConsoleApi%1015:

000219a4 <sysConsoleApi>:
   219a4:	00021069 000194a1 0001f359 00021bcd     i.......Y.......
   219b4:	00020bb1                                ....

Disassembly of section .text.Console_UART_ResourceLock%1016:

000219b8 <Console_UART_ResourceLock>:
{
   219b8:	b508      	push	{r3, lr}
    if(OSAL_MUTEX_Lock(&(pConsoleUartData->mutexTransferObjects), OSAL_WAIT_FOREVER) == OSAL_RESULT_FALSE)
   219ba:	f64f 71ff 	movw	r1, #65535	; 0xffff
   219be:	3008      	adds	r0, #8
   219c0:	f7ff f9ff 	bl	20dc2 <OSAL_MUTEX_Lock>
}
   219c4:	3000      	adds	r0, #0
   219c6:	bf18      	it	ne
   219c8:	2001      	movne	r0, #1
   219ca:	bd08      	pop	{r3, pc}

Disassembly of section .text.vPortEnableVFP%1017:

000219cc <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
   219cc:	f8df 000c 	ldr.w	r0, [pc, #12]	; 219dc <vPortEnableVFP+0x10>
   219d0:	6801      	ldr	r1, [r0, #0]
   219d2:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   219d6:	6001      	str	r1, [r0, #0]
   219d8:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
   219da:	0000      	.short	0x0000
   219dc:	e000ed88 	.word	0xe000ed88

Disassembly of section .text.vPortExitCritical%1018:

000219e0 <vPortExitCritical>:
	uxCriticalNesting--;
   219e0:	4a03      	ldr	r2, [pc, #12]	; (219f0 <vPortExitCritical+0x10>)
   219e2:	6813      	ldr	r3, [r2, #0]
   219e4:	3b01      	subs	r3, #1
   219e6:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
   219e8:	b90b      	cbnz	r3, 219ee <vPortExitCritical+0xe>
	__asm volatile
   219ea:	f383 8811 	msr	BASEPRI, r3
}
   219ee:	4770      	bx	lr
   219f0:	2000e490 	.word	0x2000e490

Disassembly of section .text.CRYPT_WCCB_Initialize%1019:

000219f4 <CRYPT_WCCB_Initialize>:
    }    
    return CRYPTOCB_UNAVAILABLE;
}

void CRYPT_WCCB_Initialize()
{
   219f4:	b508      	push	{r3, lr}
    wc_CryptoCb_RegisterDevice(0, CRYPT_WCCB_Callback, NULL);
   219f6:	2200      	movs	r2, #0
   219f8:	4902      	ldr	r1, [pc, #8]	; (21a04 <CRYPT_WCCB_Initialize+0x10>)
   219fa:	4610      	mov	r0, r2
   219fc:	f7fd fec7 	bl	1f78e <wc_CryptoCb_RegisterDevice>
   21a00:	bd08      	pop	{r3, pc}
   21a02:	bf00      	nop
   21a04:	00022239 	.word	0x00022239

Disassembly of section .rodata.__func__.8940%1020:

00021a08 <__func__.8940>:
   21a08:	5f786667 6f6e6f6d 6172645f 68635f77     gfx_mono_draw_ch
   21a18:	00007261                                ar..

Disassembly of section .text%1021:

00021a1c <strcmp>:
   21a1c:	f810 2b01 	ldrb.w	r2, [r0], #1
   21a20:	f811 3b01 	ldrb.w	r3, [r1], #1
   21a24:	2a01      	cmp	r2, #1
   21a26:	bf28      	it	cs
   21a28:	429a      	cmpcs	r2, r3
   21a2a:	d0f7      	beq.n	21a1c <strcmp>
   21a2c:	1ad0      	subs	r0, r2, r3
   21a2e:	4770      	bx	lr

Disassembly of section .text.strtol%1022:

00021a30 <strtol>:
   21a30:	4613      	mov	r3, r2
   21a32:	460a      	mov	r2, r1
   21a34:	4601      	mov	r1, r0
   21a36:	4802      	ldr	r0, [pc, #8]	; (21a40 <strtol+0x10>)
   21a38:	6800      	ldr	r0, [r0, #0]
   21a3a:	f7f3 b9ef 	b.w	14e1c <_strtol_l.isra.0>
   21a3e:	bf00      	nop
   21a40:	2000e4e4 	.word	0x2000e4e4

Disassembly of section .text.CRYPT_MD5_Initialize%1023:

00021a44 <CRYPT_MD5_Initialize>:
{
   21a44:	b508      	push	{r3, lr}
    if (md5 == NULL)
   21a46:	b118      	cbz	r0, 21a50 <CRYPT_MD5_Initialize+0xc>
    wc_InitMd5((Md5*)md5);
   21a48:	f7ff ff1e 	bl	21888 <wc_InitMd5>
    return 0;
   21a4c:	2000      	movs	r0, #0
}
   21a4e:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
   21a50:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   21a54:	e7fb      	b.n	21a4e <CRYPT_MD5_Initialize+0xa>

Disassembly of section .text.TCPIP_TCP_GetIsReady%1024:

00021a56 <TCPIP_TCP_GetIsReady>:
{
   21a56:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   21a58:	f7fe f9e0 	bl	1fe1c <_TcpSocketChk>
    if(pSkt)
   21a5c:	b110      	cbz	r0, 21a64 <TCPIP_TCP_GetIsReady+0xe>
        return _TCPIsGetReady(pSkt);
   21a5e:	f7ff f956 	bl	20d0e <_TCPIsGetReady>
}
   21a62:	bd08      	pop	{r3, pc}
    return 0;
   21a64:	2000      	movs	r0, #0
   21a66:	e7fc      	b.n	21a62 <TCPIP_TCP_GetIsReady+0xc>

Disassembly of section .text._TCPIP_HEAP_FreeSize%1025:

00021a68 <_TCPIP_HEAP_FreeSize>:
    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   21a68:	4603      	mov	r3, r0
   21a6a:	b120      	cbz	r0, 21a76 <_TCPIP_HEAP_FreeSize+0xe>
        return (hDcpt->_heapUnits - hDcpt->_heapAllocatedUnits) * sizeof(_headNode);   
   21a6c:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   21a6e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   21a70:	1ac0      	subs	r0, r0, r3
   21a72:	0100      	lsls	r0, r0, #4
   21a74:	4770      	bx	lr
    return 0;
   21a76:	2000      	movs	r0, #0
}
   21a78:	4770      	bx	lr

Disassembly of section .text.TCPIP_OAHASH_EntryGet%1026:

00021a7a <TCPIP_OAHASH_EntryGet>:
    if(entryIx < pOH->hEntries)
   21a7a:	68c3      	ldr	r3, [r0, #12]
   21a7c:	428b      	cmp	r3, r1
        return (OA_HASH_ENTRY*)((uint8_t*)(pOH->memBlk) + entryIx * pOH->hEntrySize);
   21a7e:	bf83      	ittte	hi
   21a80:	6883      	ldrhi	r3, [r0, #8]
   21a82:	6800      	ldrhi	r0, [r0, #0]
   21a84:	fb03 0001 	mlahi	r0, r3, r1, r0
    return 0;
   21a88:	2000      	movls	r0, #0
}
   21a8a:	4770      	bx	lr

Disassembly of section .text.OSAL_SEM_Delete%1027:

00021a8c <OSAL_SEM_Delete>:
{
   21a8c:	b510      	push	{r4, lr}
   21a8e:	4604      	mov	r4, r0
  vSemaphoreDelete(*(SemaphoreHandle_t*)semID);
   21a90:	6800      	ldr	r0, [r0, #0]
   21a92:	f000 fba9 	bl	221e8 <vQueueDelete>
  *(SemaphoreHandle_t*)semID = NULL;
   21a96:	2300      	movs	r3, #0
   21a98:	6023      	str	r3, [r4, #0]
}
   21a9a:	2001      	movs	r0, #1
   21a9c:	bd10      	pop	{r4, pc}

Disassembly of section .text.NVIC_INT_Disable%1028:

00021a9e <NVIC_INT_Disable>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   21a9e:	f3ef 8010 	mrs	r0, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
   21aa2:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   21aa4:	f3bf 8f5f 	dmb	sy

    __disable_irq();
    __DMB();

    return processorStatus;
}
   21aa8:	fab0 f080 	clz	r0, r0
   21aac:	0940      	lsrs	r0, r0, #5
   21aae:	4770      	bx	lr

Disassembly of section .text.NVIC_INT_Restore%1029:

00021ab0 <NVIC_INT_Restore>:

void NVIC_INT_Restore( bool state )
{
    if( state == true )
   21ab0:	b118      	cbz	r0, 21aba <NVIC_INT_Restore+0xa>
   21ab2:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   21ab6:	b662      	cpsie	i
   21ab8:	4770      	bx	lr
  __ASM volatile ("cpsid i" : : : "memory");
   21aba:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   21abc:	f3bf 8f5f 	dmb	sy
    else
    {
        __disable_irq();
        __DMB();
    }
}
   21ac0:	4770      	bx	lr

Disassembly of section .text.vApplicationStackOverflowHook%1030:

00021ac2 <vApplicationStackOverflowHook>:
	__asm volatile
   21ac2:	f04f 0320 	mov.w	r3, #32
   21ac6:	f383 8811 	msr	BASEPRI, r3
   21aca:	f3bf 8f6f 	isb	sy
   21ace:	f3bf 8f4f 	dsb	sy
   /* Run time task stack overflow checking is performed if
   configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook  function is
   called if a task stack overflow is detected.  Note the system/interrupt
   stack is not checked. */
   taskDISABLE_INTERRUPTS();
   for( ;; );
   21ad2:	e7fe      	b.n	21ad2 <vApplicationStackOverflowHook+0x10>

Disassembly of section .text.vApplicationMallocFailedHook%1031:

00021ad4 <vApplicationMallocFailedHook>:
   21ad4:	f04f 0320 	mov.w	r3, #32
   21ad8:	f383 8811 	msr	BASEPRI, r3
   21adc:	f3bf 8f6f 	isb	sy
   21ae0:	f3bf 8f4f 	dsb	sy
      heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
      FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
      to query the size of free heap space that remains (although it does not
      provide information on how the remaining heap might be fragmented). */
   taskDISABLE_INTERRUPTS();
   for( ;; );
   21ae4:	e7fe      	b.n	21ae4 <vApplicationMallocFailedHook+0x10>

Disassembly of section .rodata%1032:

00021ae6 <.rodata%1032>:
   21ae6:	4e49      	.short	0x4e49
   21ae8:	6e690046 	.word	0x6e690046
   21aec:	414e0066 	.word	0x414e0066
   21af0:	616e004e 	.word	0x616e004e
   21af4:	0030006e 	.word	0x0030006e

Disassembly of section .text.__i2b%1033:

00021af8 <__i2b>:
   21af8:	b510      	push	{r4, lr}
   21afa:	460c      	mov	r4, r1
   21afc:	2101      	movs	r1, #1
   21afe:	f7f9 fa79 	bl	1aff4 <_Balloc>
   21b02:	2201      	movs	r2, #1
   21b04:	6144      	str	r4, [r0, #20]
   21b06:	6102      	str	r2, [r0, #16]
   21b08:	bd10      	pop	{r4, pc}

Disassembly of section .rodata%1034:

00021b0a <.rodata%1034>:
   21b0a:	2d23      	.short	0x2d23
   21b0c:	00202b30 	.word	0x00202b30
   21b10:	004c6c68 	.word	0x004c6c68
   21b14:	45676665 	.word	0x45676665
   21b18:	4746      	.short	0x4746
   21b1a:	00          	.byte	0x00
   21b1b:	23          	.byte	0x23
   21b1c:	202b302d 	.word	0x202b302d
   21b20:	4c6c6800 	.word	0x4c6c6800
   21b24:	67666500 	.word	0x67666500
   21b28:	00474645 	.word	0x00474645

Disassembly of section .text.CRYPT_RNG_Initialize%1036:

00021b2c <CRYPT_RNG_Initialize>:
{
   21b2c:	b508      	push	{r3, lr}
    if (rng == NULL)
   21b2e:	b110      	cbz	r0, 21b36 <CRYPT_RNG_Initialize+0xa>
    return wc_InitRng((WC_RNG*)rng);
   21b30:	f7ff fc14 	bl	2135c <wc_InitRng>
}
   21b34:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
   21b36:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   21b3a:	e7fb      	b.n	21b34 <CRYPT_RNG_Initialize+0x8>

Disassembly of section .rodata._DRV_PHY_SetupPhasesTbl%1037:

00021b3c <_DRV_PHY_SetupPhasesTbl>:
   21b3c:	ef61 0001 80e9 0001 72f1 0001 0991 0002     a........r......

Disassembly of section .text.DRV_PIC32CGMAC_LibSetInterruptSrc%1038:

00021b4c <DRV_PIC32CGMAC_LibSetInterruptSrc>:
    pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc = drvGmacIRQ[GMAC_QUE_0];    
   21b4c:	4b02      	ldr	r3, [pc, #8]	; (21b58 <DRV_PIC32CGMAC_LibSetInterruptSrc+0xc>)
   21b4e:	881b      	ldrh	r3, [r3, #0]
   21b50:	f8a0 30b6 	strh.w	r3, [r0, #182]	; 0xb6
}
   21b54:	4770      	bx	lr
   21b56:	bf00      	nop
   21b58:	2000e4f8 	.word	0x2000e4f8

Disassembly of section .text.TCPIP_TCP_SocketNetGet%1039:

00021b5c <TCPIP_TCP_SocketNetGet>:
{
   21b5c:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   21b5e:	f7fe f95d 	bl	1fe1c <_TcpSocketChk>
    if(pSkt == 0)
   21b62:	4603      	mov	r3, r0
   21b64:	b100      	cbz	r0, 21b68 <TCPIP_TCP_SocketNetGet+0xc>
    return pSkt->pSktNet;
   21b66:	6c03      	ldr	r3, [r0, #64]	; 0x40
}
   21b68:	4618      	mov	r0, r3
   21b6a:	bd08      	pop	{r3, pc}

Disassembly of section .rodata.heapTypeStr.14744%1040:

00021b6c <heapTypeStr.14744>:
   21b6c:	0000 0000 1754 0000 1760 0000 1768 0000     ....T...`...h...

Disassembly of section .text.TCPIP_DNS_GetIPv4Addresses%1041:

00021b7c <TCPIP_DNS_GetIPv4Addresses>:
{
   21b7c:	b510      	push	{r4, lr}
   21b7e:	b082      	sub	sp, #8
    return _DNS_GetAddresses(hostName, startIndex, (IP_MULTI_ADDRESS*)pIPv4Addr, nIPv4Addresses, TCPIP_DNS_ADDRESS_REC_IPV4);
   21b80:	2401      	movs	r4, #1
   21b82:	9400      	str	r4, [sp, #0]
   21b84:	f7f3 f8d4 	bl	14d30 <_DNS_GetAddresses>
}
   21b88:	b002      	add	sp, #8
   21b8a:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_DNS_GetIPv6Addresses%1042:

00021b8c <TCPIP_DNS_GetIPv6Addresses>:
{
   21b8c:	b510      	push	{r4, lr}
   21b8e:	b082      	sub	sp, #8
    return _DNS_GetAddresses(hostName, startIndex, (IP_MULTI_ADDRESS*)pIPv6Addr, nIPv6Addresses, TCPIP_DNS_ADDRESS_REC_IPV6);
   21b90:	2402      	movs	r4, #2
   21b92:	9400      	str	r4, [sp, #0]
   21b94:	f7f3 f8cc 	bl	14d30 <_DNS_GetAddresses>
}
   21b98:	b002      	add	sp, #8
   21b9a:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_Notification_Deinitialize%1043:

00021b9c <TCPIP_Notification_Deinitialize>:
{
   21b9c:	b510      	push	{r4, lr}
   21b9e:	4604      	mov	r4, r0
    TCPIP_Notification_RemoveAll(notifyList, heapH);
   21ba0:	f7ff fbb5 	bl	2130e <TCPIP_Notification_RemoveAll>
    TCPIP_Helper_ProtectedSingleListDeinitialize(notifyList);
   21ba4:	4620      	mov	r0, r4
   21ba6:	f7fd fb5f 	bl	1f268 <TCPIP_Helper_ProtectedSingleListDeinitialize>
}
   21baa:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_UDP_SocketNetGet%1044:

00021bac <TCPIP_UDP_SocketNetGet>:
{
   21bac:	b508      	push	{r3, lr}
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   21bae:	f7fe fa39 	bl	20024 <_UDPSocketDcpt>
    return pSkt?pSkt->pSktNet:0;
   21bb2:	4603      	mov	r3, r0
   21bb4:	b100      	cbz	r0, 21bb8 <TCPIP_UDP_SocketNetGet+0xc>
   21bb6:	6a43      	ldr	r3, [r0, #36]	; 0x24
}
   21bb8:	4618      	mov	r0, r3
   21bba:	bd08      	pop	{r3, pc}

Disassembly of section .text.NVMCTRL_Initialize%1045:

00021bbc <NVMCTRL_Initialize>:



void NVMCTRL_Initialize(void)
{
   NVMCTRL_REGS->NVMCTRL_CTRLA = NVMCTRL_CTRLA_RWS(5) | NVMCTRL_CTRLA_AUTOWS_Msk;    
   21bbc:	4b02      	ldr	r3, [pc, #8]	; (21bc8 <NVMCTRL_Initialize+0xc>)
   21bbe:	f240 5204 	movw	r2, #1284	; 0x504
   21bc2:	801a      	strh	r2, [r3, #0]
}
   21bc4:	4770      	bx	lr
   21bc6:	bf00      	nop
   21bc8:	41004000 	.word	0x41004000

Disassembly of section .text.IsCommandReady%1046:

00021bcc <IsCommandReady>:
{
   21bcc:	b508      	push	{r3, lr}
    return (int)SYS_CONSOLE_ReadCountGet(_cmdInitData.consoleIndex);
   21bce:	4b02      	ldr	r3, [pc, #8]	; (21bd8 <IsCommandReady+0xc>)
   21bd0:	8858      	ldrh	r0, [r3, #2]
   21bd2:	f7fd f8a9 	bl	1ed28 <SYS_CONSOLE_ReadCountGet>
}
   21bd6:	bd08      	pop	{r3, pc}
   21bd8:	2000e46c 	.word	0x2000e46c

Disassembly of section .text.Console_UART_Status%1047:

00021bdc <Console_UART_Status>:
    return true;
}

SYS_CONSOLE_STATUS Console_UART_Status(uint32_t index)
{
    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   21bdc:	b910      	cbnz	r0, 21be4 <Console_UART_Status+0x8>
    {
        return SYS_CONSOLE_STATUS_ERROR;
    }
    else
    {
        return pConsoleUartData->status;
   21bde:	4b02      	ldr	r3, [pc, #8]	; (21be8 <Console_UART_Status+0xc>)
   21be0:	7918      	ldrb	r0, [r3, #4]
   21be2:	4770      	bx	lr
        return SYS_CONSOLE_STATUS_ERROR;
   21be4:	2003      	movs	r0, #3
    }
}
   21be6:	4770      	bx	lr
   21be8:	2000e334 	.word	0x2000e334

Disassembly of section .text.sy_time_h2_adapter_callback%1048:

00021bec <sy_time_h2_adapter_callback>:
{
   21bec:	b508      	push	{r3, lr}
	systemAdaptObj.callback(context,0);
   21bee:	4b02      	ldr	r3, [pc, #8]	; (21bf8 <sy_time_h2_adapter_callback+0xc>)
   21bf0:	681b      	ldr	r3, [r3, #0]
   21bf2:	2100      	movs	r1, #0
   21bf4:	4798      	blx	r3
}
   21bf6:	bd08      	pop	{r3, pc}
   21bf8:	2000e480 	.word	0x2000e480

Disassembly of section .text._APP_Tasks%1049:

00021bfc <_APP_Tasks>:
{   
   21bfc:	b508      	push	{r3, lr}
        vTaskDelay(2 / portTICK_PERIOD_MS);
   21bfe:	2402      	movs	r4, #2
        APP_Tasks();
   21c00:	f7ee fb60 	bl	102c4 <APP_Tasks>
        vTaskDelay(2 / portTICK_PERIOD_MS);
   21c04:	4620      	mov	r0, r4
   21c06:	f7fd f8f7 	bl	1edf8 <vTaskDelay>
   21c0a:	e7f9      	b.n	21c00 <_APP_Tasks+0x4>

Disassembly of section .text._SYS_CMD_Tasks%1050:

00021c0c <_SYS_CMD_Tasks>:
{
   21c0c:	b508      	push	{r3, lr}
        vTaskDelay(10 / portTICK_PERIOD_MS);
   21c0e:	240a      	movs	r4, #10
        SYS_CMD_Tasks();
   21c10:	f7e7 febc 	bl	998c <SYS_CMD_Tasks>
        vTaskDelay(10 / portTICK_PERIOD_MS);
   21c14:	4620      	mov	r0, r4
   21c16:	f7fd f8ef 	bl	1edf8 <vTaskDelay>
   21c1a:	e7f9      	b.n	21c10 <_SYS_CMD_Tasks+0x4>

Disassembly of section .rodata.tcpipDHCPInitData%1051:

00021c1c <tcpipDHCPInitData>:
   21c1c:	0000 0000 000a 0000 0044 0000 0043 0000     ........D...C...

Disassembly of section .rodata.tcpipIPv4InitData%1052:

00021c2c <tcpipIPv4InitData>:
   21c2c:	000a 0000 0000 0000 0000 0000 0000 0000     ................

Disassembly of section .text.vTaskSuspendAll%1053:

00021c3c <vTaskSuspendAll>:
	++uxSchedulerSuspended;
   21c3c:	4a02      	ldr	r2, [pc, #8]	; (21c48 <vTaskSuspendAll+0xc>)
   21c3e:	6813      	ldr	r3, [r2, #0]
   21c40:	3301      	adds	r3, #1
   21c42:	6013      	str	r3, [r2, #0]
}
   21c44:	4770      	bx	lr
   21c46:	bf00      	nop
   21c48:	2000e4b0 	.word	0x2000e4b0

Disassembly of section .text.gfx_mono_framebuffer_get_byte%1054:

00021c4c <gfx_mono_framebuffer_get_byte>:
 * \code
    data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column) {
    return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
   21c4c:	4b02      	ldr	r3, [pc, #8]	; (21c58 <gfx_mono_framebuffer_get_byte+0xc>)
   21c4e:	681b      	ldr	r3, [r3, #0]
   21c50:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
}
   21c54:	5c40      	ldrb	r0, [r0, r1]
   21c56:	4770      	bx	lr
   21c58:	2000e4dc 	.word	0x2000e4dc

Disassembly of section .text.calloc%1055:

00021c5c <calloc>:
   21c5c:	4b02      	ldr	r3, [pc, #8]	; (21c68 <calloc+0xc>)
   21c5e:	460a      	mov	r2, r1
   21c60:	4601      	mov	r1, r0
   21c62:	6818      	ldr	r0, [r3, #0]
   21c64:	f7ff ba9a 	b.w	2119c <_calloc_r>
   21c68:	2000e4e4 	.word	0x2000e4e4

Disassembly of section .text.malloc%1056:

00021c6c <malloc>:
   21c6c:	4b02      	ldr	r3, [pc, #8]	; (21c78 <malloc+0xc>)
   21c6e:	4601      	mov	r1, r0
   21c70:	6818      	ldr	r0, [r3, #0]
   21c72:	f7f5 b885 	b.w	16d80 <_malloc_r>
   21c76:	bf00      	nop
   21c78:	2000e4e4 	.word	0x2000e4e4

Disassembly of section .text.free%1057:

00021c7c <free>:
   21c7c:	4b02      	ldr	r3, [pc, #8]	; (21c88 <free+0xc>)
   21c7e:	4601      	mov	r1, r0
   21c80:	6818      	ldr	r0, [r3, #0]
   21c82:	f7f6 b947 	b.w	17f14 <_free_r>
   21c86:	bf00      	nop
   21c88:	2000e4e4 	.word	0x2000e4e4

Disassembly of section .text.memset%1058:

00021c8c <memset>:
   21c8c:	4402      	add	r2, r0
   21c8e:	4603      	mov	r3, r0
   21c90:	4293      	cmp	r3, r2
   21c92:	d100      	bne.n	21c96 <memset+0xa>
   21c94:	4770      	bx	lr
   21c96:	f803 1b01 	strb.w	r1, [r3], #1
   21c9a:	e7f9      	b.n	21c90 <memset+0x4>

Disassembly of section .text.strcpy%1059:

00021c9c <strcpy>:
   21c9c:	4603      	mov	r3, r0
   21c9e:	f811 2b01 	ldrb.w	r2, [r1], #1
   21ca2:	f803 2b01 	strb.w	r2, [r3], #1
   21ca6:	2a00      	cmp	r2, #0
   21ca8:	d1f9      	bne.n	21c9e <strcpy+0x2>
   21caa:	4770      	bx	lr

Disassembly of section .text%1060:

00021cac <strlen>:
   21cac:	4603      	mov	r3, r0
   21cae:	f813 2b01 	ldrb.w	r2, [r3], #1
   21cb2:	2a00      	cmp	r2, #0
   21cb4:	d1fb      	bne.n	21cae <strlen+0x2>
   21cb6:	1a18      	subs	r0, r3, r0
   21cb8:	3801      	subs	r0, #1
   21cba:	4770      	bx	lr

Disassembly of section .text.raise%1061:

00021cbc <raise>:
   21cbc:	4b02      	ldr	r3, [pc, #8]	; (21cc8 <raise+0xc>)
   21cbe:	4601      	mov	r1, r0
   21cc0:	6818      	ldr	r0, [r3, #0]
   21cc2:	f7fa bd63 	b.w	1c78c <_raise_r>
   21cc6:	bf00      	nop
   21cc8:	2000e4e4 	.word	0x2000e4e4

Disassembly of section .text._malloc_usable_size_r%1062:

00021ccc <_malloc_usable_size_r>:
   21ccc:	f851 3c04 	ldr.w	r3, [r1, #-4]
   21cd0:	1f18      	subs	r0, r3, #4
   21cd2:	2b00      	cmp	r3, #0
   21cd4:	bfbc      	itt	lt
   21cd6:	580b      	ldrlt	r3, [r1, r0]
   21cd8:	18c0      	addlt	r0, r0, r3
   21cda:	4770      	bx	lr

Disassembly of section .rodata%1063:

00021cdc <.rodata%1063>:
   21cdc:	69666e49 	.word	0x69666e49
   21ce0:	7974696e 	.word	0x7974696e
   21ce4:	4e614e00 	.word	0x4e614e00
   21ce8:	Address 0x00021ce8 is out of bounds.


Disassembly of section .text.DRV_PIC32CGMAC_LibSetPriorityToQueueNum%1064:

00021cec <DRV_PIC32CGMAC_LibSetPriorityToQueueNum>:
    pMACDrv->sGmacData.gmacConfig.txPrioNumToQueIndx[0] = GMAC_QUE_0;
   21cec:	2300      	movs	r3, #0
   21cee:	f880 30e3 	strb.w	r3, [r0, #227]	; 0xe3
    pMACDrv->sGmacData.gmacConfig.rxPrioNumToQueIndx[0] = GMAC_QUE_0;    
   21cf2:	f880 30e5 	strb.w	r3, [r0, #229]	; 0xe5
}
   21cf6:	2001      	movs	r0, #1
   21cf8:	4770      	bx	lr

Disassembly of section .text.btohexa_low%1065:

00021cfa <btohexa_low>:
  Returns:
  	The lower hexadecimal ASCII byte '0'-'9' or 'a'-'f'.
  ***************************************************************************/
uint8_t btohexa_low(uint8_t b)
{
	b &= 0x0F;
   21cfa:	f000 000f 	and.w	r0, r0, #15
	return (b>9u) ? b+'a'-10:b+'0';
   21cfe:	2809      	cmp	r0, #9
   21d00:	bf8c      	ite	hi
   21d02:	3057      	addhi	r0, #87	; 0x57
   21d04:	3030      	addls	r0, #48	; 0x30
}
   21d06:	4770      	bx	lr

Disassembly of section .text.TCPIP_Helper_ChecksumFold%1066:

00021d08 <TCPIP_Helper_ChecksumFold>:
    checksum.Val = (uint32_t)checksum.w[0] + (uint32_t)checksum.w[1];
   21d08:	b283      	uxth	r3, r0
   21d0a:	eb03 4010 	add.w	r0, r3, r0, lsr #16
    checksum.w[0] += checksum.w[1];
   21d0e:	eb00 4010 	add.w	r0, r0, r0, lsr #16
}
   21d12:	b280      	uxth	r0, r0
   21d14:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetIndexGet%1067:

00021d16 <TCPIP_STACK_NetIndexGet>:
    if(pNetIf)
   21d16:	b110      	cbz	r0, 21d1e <TCPIP_STACK_NetIndexGet+0x8>
        return pNetIf->netIfIx;
   21d18:	f8b0 0058 	ldrh.w	r0, [r0, #88]	; 0x58
   21d1c:	4770      	bx	lr
    return -1;
   21d1e:	f04f 30ff 	mov.w	r0, #4294967295
}
   21d22:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetIxGet%1068:

00021d24 <TCPIP_STACK_NetIxGet>:
    if(pNetIf)
   21d24:	b110      	cbz	r0, 21d2c <TCPIP_STACK_NetIxGet+0x8>
        return pNetIf->netIfIx;
   21d26:	f8b0 0058 	ldrh.w	r0, [r0, #88]	; 0x58
   21d2a:	4770      	bx	lr
    return -1;
   21d2c:	f04f 30ff 	mov.w	r0, #4294967295
}
   21d30:	4770      	bx	lr

Disassembly of section .text._TCPIPStackSignalHandlerDeregister%1069:

00021d32 <_TCPIPStackSignalHandlerDeregister>:
    if((pSignalEntry = (TCPIP_MODULE_SIGNAL_ENTRY*)handle) != 0)
   21d32:	b120      	cbz	r0, 21d3e <_TCPIPStackSignalHandlerDeregister+0xc>
        memset(pSignalEntry, 0x0, sizeof(*pSignalEntry));
   21d34:	2200      	movs	r2, #0
   21d36:	6002      	str	r2, [r0, #0]
   21d38:	6042      	str	r2, [r0, #4]
   21d3a:	6082      	str	r2, [r0, #8]
   21d3c:	60c2      	str	r2, [r0, #12]
}
   21d3e:	4770      	bx	lr

Disassembly of section .text.main%1070:

00021d40 <main>:
// Section: Main Entry Point
// *****************************************************************************
// *****************************************************************************

int main ( void )
{
   21d40:	b508      	push	{r3, lr}
    /* Initialize all modules */
    SYS_Initialize ( NULL );
   21d42:	2000      	movs	r0, #0
   21d44:	f7f7 fe24 	bl	19990 <SYS_Initialize>

    while ( true )
    {
        /* Maintain state machines of all polled MPLAB Harmony modules. */
        SYS_Tasks ( );
   21d48:	f7f7 fde4 	bl	19914 <SYS_Tasks>
   21d4c:	e7fc      	b.n	21d48 <main+0x8>

Disassembly of section .text.abort%1071:

00021d4e <abort>:
   21d4e:	b508      	push	{r3, lr}
   21d50:	2006      	movs	r0, #6
   21d52:	f7ff ffb3 	bl	21cbc <raise>
   21d56:	2001      	movs	r0, #1
   21d58:	f7f8 ff77 	bl	1ac4a <_exit>

Disassembly of section .rodata._DRV_PHY_LinkStatPhasesTbl%1072:

00017bf4 <_DRV_PHY_LinkStatPhasesTbl>:
   17bf4:	143d 0002 c965 0001 f89d 0001               =...e.......

Disassembly of section .rodata._DRV_PHY_NegRestartPhasesTbl%1073:

00021d5c <_DRV_PHY_NegRestartPhasesTbl>:
   21d5c:	1485 0002 e4d7 0001 20e1 0002               ......... ..

Disassembly of section .rodata._DRV_PHY_ResetPhasesTbl%1074:

00021d68 <_DRV_PHY_ResetPhasesTbl>:
   21d68:	0dff 0002 d9f5 0001 b0c1 0001               ............

Disassembly of section .text._DRV_GMAC_GetTxOctetLow%1075:

00021d74 <_DRV_GMAC_GetTxOctetLow>:
	return GMAC_REGS->GMAC_OTLO;	
   21d74:	4b01      	ldr	r3, [pc, #4]	; (21d7c <_DRV_GMAC_GetTxOctetLow+0x8>)
   21d76:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
}
   21d7a:	4770      	bx	lr
   21d7c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxOctetHigh%1076:

00021d80 <_DRV_GMAC_GetTxOctetHigh>:
	return GMAC_REGS->GMAC_OTHI;
   21d80:	4b01      	ldr	r3, [pc, #4]	; (21d88 <_DRV_GMAC_GetTxOctetHigh+0x8>)
   21d82:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
}
   21d86:	4770      	bx	lr
   21d88:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxFrameCount%1077:

00021d8c <_DRV_GMAC_GetTxFrameCount>:
	return GMAC_REGS->GMAC_FT;
   21d8c:	4b01      	ldr	r3, [pc, #4]	; (21d94 <_DRV_GMAC_GetTxFrameCount+0x8>)
   21d8e:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
}
   21d92:	4770      	bx	lr
   21d94:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxBCastFrameCount%1078:

00021d98 <_DRV_GMAC_GetTxBCastFrameCount>:
	return GMAC_REGS->GMAC_BCFT;
   21d98:	4b01      	ldr	r3, [pc, #4]	; (21da0 <_DRV_GMAC_GetTxBCastFrameCount+0x8>)
   21d9a:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
}
   21d9e:	4770      	bx	lr
   21da0:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxMCastFrameCount%1079:

00021da4 <_DRV_GMAC_GetTxMCastFrameCount>:
	return GMAC_REGS->GMAC_MFT;
   21da4:	4b01      	ldr	r3, [pc, #4]	; (21dac <_DRV_GMAC_GetTxMCastFrameCount+0x8>)
   21da6:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
}
   21daa:	4770      	bx	lr
   21dac:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxPauseFrameCount%1080:

00021db0 <_DRV_GMAC_GetTxPauseFrameCount>:
	return GMAC_REGS->GMAC_PFT;
   21db0:	4b01      	ldr	r3, [pc, #4]	; (21db8 <_DRV_GMAC_GetTxPauseFrameCount+0x8>)
   21db2:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
}
   21db6:	4770      	bx	lr
   21db8:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTx64ByteFrameCount%1081:

00021dbc <_DRV_GMAC_GetTx64ByteFrameCount>:
	return GMAC_REGS->GMAC_BFT64;
   21dbc:	4b01      	ldr	r3, [pc, #4]	; (21dc4 <_DRV_GMAC_GetTx64ByteFrameCount+0x8>)
   21dbe:	f8d3 0118 	ldr.w	r0, [r3, #280]	; 0x118
}
   21dc2:	4770      	bx	lr
   21dc4:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTx127ByteFrameCount%1082:

00021dc8 <_DRV_GMAC_GetTx127ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFT127;
   21dc8:	4b01      	ldr	r3, [pc, #4]	; (21dd0 <_DRV_GMAC_GetTx127ByteFrameCount+0x8>)
   21dca:	f8d3 011c 	ldr.w	r0, [r3, #284]	; 0x11c
}
   21dce:	4770      	bx	lr
   21dd0:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTx255ByteFrameCount%1083:

00021dd4 <_DRV_GMAC_GetTx255ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFT255;
   21dd4:	4b01      	ldr	r3, [pc, #4]	; (21ddc <_DRV_GMAC_GetTx255ByteFrameCount+0x8>)
   21dd6:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
}
   21dda:	4770      	bx	lr
   21ddc:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTx511ByteFrameCount%1084:

00021de0 <_DRV_GMAC_GetTx511ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFT511;
   21de0:	4b01      	ldr	r3, [pc, #4]	; (21de8 <_DRV_GMAC_GetTx511ByteFrameCount+0x8>)
   21de2:	f8d3 0124 	ldr.w	r0, [r3, #292]	; 0x124
}
   21de6:	4770      	bx	lr
   21de8:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTx1023ByteFrameCount%1085:

00021dec <_DRV_GMAC_GetTx1023ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFT1023;
   21dec:	4b01      	ldr	r3, [pc, #4]	; (21df4 <_DRV_GMAC_GetTx1023ByteFrameCount+0x8>)
   21dee:	f8d3 0128 	ldr.w	r0, [r3, #296]	; 0x128
}
   21df2:	4770      	bx	lr
   21df4:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTx1518ByteFrameCount%1086:

00021df8 <_DRV_GMAC_GetTx1518ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFT1518;
   21df8:	4b01      	ldr	r3, [pc, #4]	; (21e00 <_DRV_GMAC_GetTx1518ByteFrameCount+0x8>)
   21dfa:	f8d3 012c 	ldr.w	r0, [r3, #300]	; 0x12c
}
   21dfe:	4770      	bx	lr
   21e00:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxGT1518ByteFrameCount%1087:

00021e04 <_DRV_GMAC_GetTxGT1518ByteFrameCount>:
	return GMAC_REGS->GMAC_GTBFT1518;
   21e04:	4b01      	ldr	r3, [pc, #4]	; (21e0c <_DRV_GMAC_GetTxGT1518ByteFrameCount+0x8>)
   21e06:	f8d3 0130 	ldr.w	r0, [r3, #304]	; 0x130
}
   21e0a:	4770      	bx	lr
   21e0c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxUnderRunFrameCount%1088:

00021e10 <_DRV_GMAC_GetTxUnderRunFrameCount>:
	return GMAC_REGS->GMAC_TUR;
   21e10:	4b01      	ldr	r3, [pc, #4]	; (21e18 <_DRV_GMAC_GetTxUnderRunFrameCount+0x8>)
   21e12:	f8d3 0134 	ldr.w	r0, [r3, #308]	; 0x134
}
   21e16:	4770      	bx	lr
   21e18:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxSingleCollFrameCount%1089:

00021e1c <_DRV_GMAC_GetTxSingleCollFrameCount>:
	return GMAC_REGS->GMAC_SCF;
   21e1c:	4b01      	ldr	r3, [pc, #4]	; (21e24 <_DRV_GMAC_GetTxSingleCollFrameCount+0x8>)
   21e1e:	f8d3 0138 	ldr.w	r0, [r3, #312]	; 0x138
}
   21e22:	4770      	bx	lr
   21e24:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxMultiCollFrameCount%1090:

00021e28 <_DRV_GMAC_GetTxMultiCollFrameCount>:
	return GMAC_REGS->GMAC_MCF;
   21e28:	4b01      	ldr	r3, [pc, #4]	; (21e30 <_DRV_GMAC_GetTxMultiCollFrameCount+0x8>)
   21e2a:	f8d3 013c 	ldr.w	r0, [r3, #316]	; 0x13c
}
   21e2e:	4770      	bx	lr
   21e30:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxExcessCollFrameCount%1091:

00021e34 <_DRV_GMAC_GetTxExcessCollFrameCount>:
	return GMAC_REGS->GMAC_EC;
   21e34:	4b01      	ldr	r3, [pc, #4]	; (21e3c <_DRV_GMAC_GetTxExcessCollFrameCount+0x8>)
   21e36:	f8d3 0140 	ldr.w	r0, [r3, #320]	; 0x140
}
   21e3a:	4770      	bx	lr
   21e3c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxLateCollFrameCount%1092:

00021e40 <_DRV_GMAC_GetTxLateCollFrameCount>:
	return GMAC_REGS->GMAC_LC;
   21e40:	4b01      	ldr	r3, [pc, #4]	; (21e48 <_DRV_GMAC_GetTxLateCollFrameCount+0x8>)
   21e42:	f8d3 0144 	ldr.w	r0, [r3, #324]	; 0x144
}
   21e46:	4770      	bx	lr
   21e48:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxDeferFrameCount%1093:

00021e4c <_DRV_GMAC_GetTxDeferFrameCount>:
	return GMAC_REGS->GMAC_DTF;
   21e4c:	4b01      	ldr	r3, [pc, #4]	; (21e54 <_DRV_GMAC_GetTxDeferFrameCount+0x8>)
   21e4e:	f8d3 0148 	ldr.w	r0, [r3, #328]	; 0x148
}
   21e52:	4770      	bx	lr
   21e54:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxCSErrorFrameCount%1094:

00021e58 <_DRV_GMAC_GetTxCSErrorFrameCount>:
	return GMAC_REGS->GMAC_CSE;
   21e58:	4b01      	ldr	r3, [pc, #4]	; (21e60 <_DRV_GMAC_GetTxCSErrorFrameCount+0x8>)
   21e5a:	f8d3 014c 	ldr.w	r0, [r3, #332]	; 0x14c
}
   21e5e:	4770      	bx	lr
   21e60:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxOctetLow%1095:

00021e64 <_DRV_GMAC_GetRxOctetLow>:
	return GMAC_REGS->GMAC_ORLO;
   21e64:	4b01      	ldr	r3, [pc, #4]	; (21e6c <_DRV_GMAC_GetRxOctetLow+0x8>)
   21e66:	f8d3 0150 	ldr.w	r0, [r3, #336]	; 0x150
}
   21e6a:	4770      	bx	lr
   21e6c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxOctetHigh%1096:

00021e70 <_DRV_GMAC_GetRxOctetHigh>:
	return GMAC_REGS->GMAC_ORHI;
   21e70:	4b01      	ldr	r3, [pc, #4]	; (21e78 <_DRV_GMAC_GetRxOctetHigh+0x8>)
   21e72:	f8d3 0154 	ldr.w	r0, [r3, #340]	; 0x154
}
   21e76:	4770      	bx	lr
   21e78:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxFrameCount%1097:

00021e7c <_DRV_GMAC_GetRxFrameCount>:
	return GMAC_REGS->GMAC_FR;
   21e7c:	4b01      	ldr	r3, [pc, #4]	; (21e84 <_DRV_GMAC_GetRxFrameCount+0x8>)
   21e7e:	f8d3 0158 	ldr.w	r0, [r3, #344]	; 0x158
}
   21e82:	4770      	bx	lr
   21e84:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxBCastFrameCount%1098:

00021e88 <_DRV_GMAC_GetRxBCastFrameCount>:
	return GMAC_REGS->GMAC_BCFR;
   21e88:	4b01      	ldr	r3, [pc, #4]	; (21e90 <_DRV_GMAC_GetRxBCastFrameCount+0x8>)
   21e8a:	f8d3 015c 	ldr.w	r0, [r3, #348]	; 0x15c
}
   21e8e:	4770      	bx	lr
   21e90:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxMCastFrameCount%1099:

00021e94 <_DRV_GMAC_GetRxMCastFrameCount>:
	return GMAC_REGS->GMAC_MFR;
   21e94:	4b01      	ldr	r3, [pc, #4]	; (21e9c <_DRV_GMAC_GetRxMCastFrameCount+0x8>)
   21e96:	f8d3 0160 	ldr.w	r0, [r3, #352]	; 0x160
}
   21e9a:	4770      	bx	lr
   21e9c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxPauseFrameCount%1100:

00021ea0 <_DRV_GMAC_GetRxPauseFrameCount>:
	return GMAC_REGS->GMAC_PFR;
   21ea0:	4b01      	ldr	r3, [pc, #4]	; (21ea8 <_DRV_GMAC_GetRxPauseFrameCount+0x8>)
   21ea2:	f8d3 0164 	ldr.w	r0, [r3, #356]	; 0x164
}
   21ea6:	4770      	bx	lr
   21ea8:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRx64ByteFrameCount%1101:

00021eac <_DRV_GMAC_GetRx64ByteFrameCount>:
	return GMAC_REGS->GMAC_BFR64;
   21eac:	4b01      	ldr	r3, [pc, #4]	; (21eb4 <_DRV_GMAC_GetRx64ByteFrameCount+0x8>)
   21eae:	f8d3 0168 	ldr.w	r0, [r3, #360]	; 0x168
}
   21eb2:	4770      	bx	lr
   21eb4:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRx127ByteFrameCount%1102:

00021eb8 <_DRV_GMAC_GetRx127ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFR127;
   21eb8:	4b01      	ldr	r3, [pc, #4]	; (21ec0 <_DRV_GMAC_GetRx127ByteFrameCount+0x8>)
   21eba:	f8d3 016c 	ldr.w	r0, [r3, #364]	; 0x16c
}
   21ebe:	4770      	bx	lr
   21ec0:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRx255ByteFrameCount%1103:

00021ec4 <_DRV_GMAC_GetRx255ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFR255;
   21ec4:	4b01      	ldr	r3, [pc, #4]	; (21ecc <_DRV_GMAC_GetRx255ByteFrameCount+0x8>)
   21ec6:	f8d3 0170 	ldr.w	r0, [r3, #368]	; 0x170
}
   21eca:	4770      	bx	lr
   21ecc:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRx511ByteFrameCount%1104:

00021ed0 <_DRV_GMAC_GetRx511ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFR511;
   21ed0:	4b01      	ldr	r3, [pc, #4]	; (21ed8 <_DRV_GMAC_GetRx511ByteFrameCount+0x8>)
   21ed2:	f8d3 0174 	ldr.w	r0, [r3, #372]	; 0x174
}
   21ed6:	4770      	bx	lr
   21ed8:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRx1023ByteFrameCount%1105:

00021edc <_DRV_GMAC_GetRx1023ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFR1023;
   21edc:	4b01      	ldr	r3, [pc, #4]	; (21ee4 <_DRV_GMAC_GetRx1023ByteFrameCount+0x8>)
   21ede:	f8d3 0178 	ldr.w	r0, [r3, #376]	; 0x178
}
   21ee2:	4770      	bx	lr
   21ee4:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRx1518ByteFrameCount%1106:

00021ee8 <_DRV_GMAC_GetRx1518ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFR1518;
   21ee8:	4b01      	ldr	r3, [pc, #4]	; (21ef0 <_DRV_GMAC_GetRx1518ByteFrameCount+0x8>)
   21eea:	f8d3 017c 	ldr.w	r0, [r3, #380]	; 0x17c
}
   21eee:	4770      	bx	lr
   21ef0:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxGT1518ByteFrameCount%1107:

00021ef4 <_DRV_GMAC_GetRxGT1518ByteFrameCount>:
	return GMAC_REGS->GMAC_TMXBFR;
   21ef4:	4b01      	ldr	r3, [pc, #4]	; (21efc <_DRV_GMAC_GetRxGT1518ByteFrameCount+0x8>)
   21ef6:	f8d3 0180 	ldr.w	r0, [r3, #384]	; 0x180
}
   21efa:	4770      	bx	lr
   21efc:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxUnderSizeFrameCount%1108:

00021f00 <_DRV_GMAC_GetRxUnderSizeFrameCount>:
	return GMAC_REGS->GMAC_UFR;
   21f00:	4b01      	ldr	r3, [pc, #4]	; (21f08 <_DRV_GMAC_GetRxUnderSizeFrameCount+0x8>)
   21f02:	f8d3 0184 	ldr.w	r0, [r3, #388]	; 0x184
}
   21f06:	4770      	bx	lr
   21f08:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxOverSizeFrameCount%1109:

00021f0c <_DRV_GMAC_GetRxOverSizeFrameCount>:
	return GMAC_REGS->GMAC_OFR;
   21f0c:	4b01      	ldr	r3, [pc, #4]	; (21f14 <_DRV_GMAC_GetRxOverSizeFrameCount+0x8>)
   21f0e:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
}
   21f12:	4770      	bx	lr
   21f14:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxJabberFrameCount%1110:

00021f18 <_DRV_GMAC_GetRxJabberFrameCount>:
	return GMAC_REGS->GMAC_JR;
   21f18:	4b01      	ldr	r3, [pc, #4]	; (21f20 <_DRV_GMAC_GetRxJabberFrameCount+0x8>)
   21f1a:	f8d3 018c 	ldr.w	r0, [r3, #396]	; 0x18c
}
   21f1e:	4770      	bx	lr
   21f20:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxFCSErrorFrameCount%1111:

00021f24 <_DRV_GMAC_GetRxFCSErrorFrameCount>:
	return GMAC_REGS->GMAC_FCSE;
   21f24:	4b01      	ldr	r3, [pc, #4]	; (21f2c <_DRV_GMAC_GetRxFCSErrorFrameCount+0x8>)
   21f26:	f8d3 0190 	ldr.w	r0, [r3, #400]	; 0x190
}
   21f2a:	4770      	bx	lr
   21f2c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxLFErrorFrameCount%1112:

00021f30 <_DRV_GMAC_GetRxLFErrorFrameCount>:
	return GMAC_REGS->GMAC_LFFE;
   21f30:	4b01      	ldr	r3, [pc, #4]	; (21f38 <_DRV_GMAC_GetRxLFErrorFrameCount+0x8>)
   21f32:	f8d3 0194 	ldr.w	r0, [r3, #404]	; 0x194
}
   21f36:	4770      	bx	lr
   21f38:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxSymErrorFrameCount%1113:

00021f3c <_DRV_GMAC_GetRxSymErrorFrameCount>:
	return GMAC_REGS->GMAC_RSE;
   21f3c:	4b01      	ldr	r3, [pc, #4]	; (21f44 <_DRV_GMAC_GetRxSymErrorFrameCount+0x8>)
   21f3e:	f8d3 0198 	ldr.w	r0, [r3, #408]	; 0x198
}
   21f42:	4770      	bx	lr
   21f44:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxAlignErrorFrameCount%1114:

00021f48 <_DRV_GMAC_GetRxAlignErrorFrameCount>:
	return GMAC_REGS->GMAC_AE;
   21f48:	4b01      	ldr	r3, [pc, #4]	; (21f50 <_DRV_GMAC_GetRxAlignErrorFrameCount+0x8>)
   21f4a:	f8d3 019c 	ldr.w	r0, [r3, #412]	; 0x19c
}
   21f4e:	4770      	bx	lr
   21f50:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxResErrorFrameCount%1115:

00021f54 <_DRV_GMAC_GetRxResErrorFrameCount>:
	return GMAC_REGS->GMAC_RRE;
   21f54:	4b01      	ldr	r3, [pc, #4]	; (21f5c <_DRV_GMAC_GetRxResErrorFrameCount+0x8>)
   21f56:	f8d3 01a0 	ldr.w	r0, [r3, #416]	; 0x1a0
}
   21f5a:	4770      	bx	lr
   21f5c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxOverRunFrameCount%1116:

00021f60 <_DRV_GMAC_GetRxOverRunFrameCount>:
	return GMAC_REGS->GMAC_ROE;
   21f60:	4b01      	ldr	r3, [pc, #4]	; (21f68 <_DRV_GMAC_GetRxOverRunFrameCount+0x8>)
   21f62:	f8d3 01a4 	ldr.w	r0, [r3, #420]	; 0x1a4
}
   21f66:	4770      	bx	lr
   21f68:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxIPHdrCSErrorFrameCount%1117:

00021f6c <_DRV_GMAC_GetRxIPHdrCSErrorFrameCount>:
	return GMAC_REGS->GMAC_IHCE;
   21f6c:	4b01      	ldr	r3, [pc, #4]	; (21f74 <_DRV_GMAC_GetRxIPHdrCSErrorFrameCount+0x8>)
   21f6e:	f8d3 01a8 	ldr.w	r0, [r3, #424]	; 0x1a8
}
   21f72:	4770      	bx	lr
   21f74:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxTCPCSErrorFrameCount%1118:

00021f78 <_DRV_GMAC_GetRxTCPCSErrorFrameCount>:
	return GMAC_REGS->GMAC_TCE;
   21f78:	4b01      	ldr	r3, [pc, #4]	; (21f80 <_DRV_GMAC_GetRxTCPCSErrorFrameCount+0x8>)
   21f7a:	f8d3 01ac 	ldr.w	r0, [r3, #428]	; 0x1ac
}
   21f7e:	4770      	bx	lr
   21f80:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxUDPCSErrorFrameCount%1119:

00021f84 <_DRV_GMAC_GetRxUDPCSErrorFrameCount>:
	return GMAC_REGS->GMAC_UCE;
   21f84:	4b01      	ldr	r3, [pc, #4]	; (21f8c <_DRV_GMAC_GetRxUDPCSErrorFrameCount+0x8>)
   21f86:	f8d3 01b0 	ldr.w	r0, [r3, #432]	; 0x1b0
}
   21f8a:	4770      	bx	lr
   21f8c:	42000800 	.word	0x42000800

Disassembly of section .text.DRV_PIC32CGMAC_LibReadInterruptStatus%1120:

00021f90 <DRV_PIC32CGMAC_LibReadInterruptStatus>:
    return GMAC_REGS->GMAC_ISR;
   21f90:	4b01      	ldr	r3, [pc, #4]	; (21f98 <DRV_PIC32CGMAC_LibReadInterruptStatus+0x8>)
   21f92:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
   21f94:	4770      	bx	lr
   21f96:	bf00      	nop
   21f98:	42000800 	.word	0x42000800

Disassembly of section .text.DRV_PIC32CGMAC_LibEnableInterrupt%1121:

00021f9c <DRV_PIC32CGMAC_LibEnableInterrupt>:
    GMAC_REGS->GMAC_IER = ethEvents;
   21f9c:	4b01      	ldr	r3, [pc, #4]	; (21fa4 <DRV_PIC32CGMAC_LibEnableInterrupt+0x8>)
   21f9e:	6299      	str	r1, [r3, #40]	; 0x28
}
   21fa0:	4770      	bx	lr
   21fa2:	bf00      	nop
   21fa4:	42000800 	.word	0x42000800

Disassembly of section .text.DRV_PIC32CGMAC_LibDisableInterrupt%1122:

00021fa8 <DRV_PIC32CGMAC_LibDisableInterrupt>:
    GMAC_REGS->GMAC_IDR = ethEvents;
   21fa8:	4b01      	ldr	r3, [pc, #4]	; (21fb0 <DRV_PIC32CGMAC_LibDisableInterrupt+0x8>)
   21faa:	62d9      	str	r1, [r3, #44]	; 0x2c
}
   21fac:	4770      	bx	lr
   21fae:	bf00      	nop
   21fb0:	42000800 	.word	0x42000800

Disassembly of section .text.btohexa_high%1123:

00021fb4 <btohexa_high>:
	b >>= 4;
   21fb4:	0900      	lsrs	r0, r0, #4
	return (b>0x9u) ? b+'a'-10:b+'0';
   21fb6:	2809      	cmp	r0, #9
   21fb8:	bf8c      	ite	hi
   21fba:	3057      	addhi	r0, #87	; 0x57
   21fbc:	3030      	addls	r0, #48	; 0x30
}
   21fbe:	4770      	bx	lr

Disassembly of section .text.TCPIP_ARP_HashKeyCompare%1124:

00021fc0 <TCPIP_ARP_HashKeyCompare>:


int TCPIP_ARP_HashKeyCompare(OA_HASH_DCPT* pOH, OA_HASH_ENTRY* hEntry, const void* key)
{
    return ((ARP_HASH_ENTRY*)hEntry)->ipAddress.Val != ((ARP_UNALIGNED_KEY*)key)->v;
   21fc0:	6813      	ldr	r3, [r2, #0]
   21fc2:	6888      	ldr	r0, [r1, #8]
}
   21fc4:	1ac0      	subs	r0, r0, r3
   21fc6:	bf18      	it	ne
   21fc8:	2001      	movne	r0, #1
   21fca:	4770      	bx	lr

Disassembly of section .text.TCPIP_IPV4_PacketTransmit%1125:

00021fcc <TCPIP_IPV4_PacketTransmit>:
{
   21fcc:	b508      	push	{r3, lr}
    return TCPIP_IPV4_PktTx(pPkt, &pPkt->macPkt, true);
   21fce:	2201      	movs	r2, #1
   21fd0:	4601      	mov	r1, r0
   21fd2:	f7ec f999 	bl	e308 <TCPIP_IPV4_PktTx>
}
   21fd6:	bd08      	pop	{r3, pc}

Disassembly of section .text._TCPIP_HEAP_Size%1126:

00021fd8 <_TCPIP_HEAP_Size>:
    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   21fd8:	b110      	cbz	r0, 21fe0 <_TCPIP_HEAP_Size+0x8>
        return hDcpt->_heapUnits * sizeof(_headNode);   
   21fda:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   21fdc:	0100      	lsls	r0, r0, #4
   21fde:	4770      	bx	lr
    return 0;
   21fe0:	2000      	movs	r0, #0
}
   21fe2:	4770      	bx	lr

Disassembly of section .text._TCPIP_HEAP_HighWatermark%1127:

00021fe4 <_TCPIP_HEAP_HighWatermark>:
    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   21fe4:	b110      	cbz	r0, 21fec <_TCPIP_HEAP_HighWatermark+0x8>
        return hDcpt->_heapWatermark * sizeof(_headNode);
   21fe6:	6b40      	ldr	r0, [r0, #52]	; 0x34
   21fe8:	0100      	lsls	r0, r0, #4
   21fea:	4770      	bx	lr
    return 0;
   21fec:	2000      	movs	r0, #0
}
   21fee:	4770      	bx	lr

Disassembly of section .text.TCPIP_DNS_OAHASH_KeyCompare%1128:

00021ff0 <TCPIP_DNS_OAHASH_KeyCompare>:
{
   21ff0:	b508      	push	{r3, lr}
    return strcmp(pDnsHE->pHostName, (const char*)dnsHostNameKey);
   21ff2:	6a08      	ldr	r0, [r1, #32]
   21ff4:	4611      	mov	r1, r2
   21ff6:	f7ff fd11 	bl	21a1c <strcmp>
}
   21ffa:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_DNS_Enable%1129:

00021ffc <TCPIP_DNS_Enable>:
{
   21ffc:	b508      	push	{r3, lr}
    return _DNS_Enable(hNet, true, flags);
   21ffe:	460a      	mov	r2, r1
   22000:	2101      	movs	r1, #1
   22002:	f7f9 fedf 	bl	1bdc4 <_DNS_Enable>
}
   22006:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_STACK_NetDefaultGet%1130:

00022008 <TCPIP_STACK_NetDefaultGet>:
}
   22008:	4b01      	ldr	r3, [pc, #4]	; (22010 <TCPIP_STACK_NetDefaultGet+0x8>)
   2200a:	6818      	ldr	r0, [r3, #0]
   2200c:	4770      	bx	lr
   2200e:	bf00      	nop
   22010:	2000e43c 	.word	0x2000e43c

Disassembly of section .text.TCPIP_STACK_NumberOfNetworksGet%1131:

00022014 <TCPIP_STACK_NumberOfNetworksGet>:
}
   22014:	4b01      	ldr	r3, [pc, #4]	; (2201c <TCPIP_STACK_NumberOfNetworksGet+0x8>)
   22016:	6818      	ldr	r0, [r3, #0]
   22018:	4770      	bx	lr
   2201a:	bf00      	nop
   2201c:	2000e0f0 	.word	0x2000e0f0

Disassembly of section .rodata.TCPIP_STACK_IF_ALIAS_NAME_TBL%1132:

00022020 <TCPIP_STACK_IF_ALIAS_NAME_TBL>:
   22020:	00009558 0000955c 00009560              X...\...`...

Disassembly of section .text.TCPIP_PKT_Deinitialize%1133:

0002202c <TCPIP_PKT_Deinitialize>:
    pktMemH = 0;
   2202c:	4b01      	ldr	r3, [pc, #4]	; (22034 <TCPIP_PKT_Deinitialize+0x8>)
   2202e:	2200      	movs	r2, #0
   22030:	601a      	str	r2, [r3, #0]
}
   22032:	4770      	bx	lr
   22034:	2000e450 	.word	0x2000e450

Disassembly of section .text.TC0_TimerCallbackRegister%1134:

00022038 <TC0_TimerCallbackRegister>:
    TC0_CallbackObject.callback = callback;
   22038:	4b01      	ldr	r3, [pc, #4]	; (22040 <TC0_TimerCallbackRegister+0x8>)
   2203a:	6018      	str	r0, [r3, #0]
    TC0_CallbackObject.context = context;
   2203c:	6059      	str	r1, [r3, #4]
}
   2203e:	4770      	bx	lr
   22040:	2000e358 	.word	0x2000e358

Disassembly of section .text.SYS_DEBUG_ConsoleInstanceGet%1135:

00022044 <SYS_DEBUG_ConsoleInstanceGet>:


SYS_MODULE_INDEX SYS_DEBUG_ConsoleInstanceGet(void)
{
    return sysDebugInstance.debugConsole;
}
   22044:	4b01      	ldr	r3, [pc, #4]	; (2204c <SYS_DEBUG_ConsoleInstanceGet+0x8>)
   22046:	8858      	ldrh	r0, [r3, #2]
   22048:	4770      	bx	lr
   2204a:	bf00      	nop
   2204c:	2000e478 	.word	0x2000e478

Disassembly of section .text.SYS_DEBUG_ErrorLevelGet%1136:

00022050 <SYS_DEBUG_ErrorLevelGet>:
}

SYS_ERROR_LEVEL SYS_DEBUG_ErrorLevelGet(void)
{
    return gblErrLvl;
}
   22050:	4b01      	ldr	r3, [pc, #4]	; (22058 <SYS_DEBUG_ErrorLevelGet+0x8>)
   22052:	7818      	ldrb	r0, [r3, #0]
   22054:	4770      	bx	lr
   22056:	bf00      	nop
   22058:	2000e50f 	.word	0x2000e50f

Disassembly of section .text.SYS_TIME_FrequencyGet%1137:

0002205c <SYS_TIME_FrequencyGet>:
}
   2205c:	4b01      	ldr	r3, [pc, #4]	; (22064 <SYS_TIME_FrequencyGet+0x8>)
   2205e:	68d8      	ldr	r0, [r3, #12]
   22060:	4770      	bx	lr
   22062:	bf00      	nop
   22064:	2000e030 	.word	0x2000e030

Disassembly of section .rodata.sysConsole0Init%1138:

00022068 <sysConsole0Init>:
   22068:	00022268 0001f9fc 00000000              h"..........

Disassembly of section .text.vTaskMissedYield%1139:

00022074 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
   22074:	4b01      	ldr	r3, [pc, #4]	; (2207c <vTaskMissedYield+0x8>)
   22076:	2201      	movs	r2, #1
   22078:	601a      	str	r2, [r3, #0]
}
   2207a:	4770      	bx	lr
   2207c:	2000e4d4 	.word	0x2000e4d4

Disassembly of section .text.APP_Initialize%1140:

00022080 <APP_Initialize>:
	appData.state = APP_DISPLAY_INIT;    
   22080:	4b01      	ldr	r3, [pc, #4]	; (22088 <APP_Initialize+0x8>)
   22082:	2201      	movs	r2, #1
   22084:	701a      	strb	r2, [r3, #0]
}
   22086:	4770      	bx	lr
   22088:	2000e4f4 	.word	0x2000e4f4

Disassembly of section .text.SERCOM0_SPI_Write%1141:

0002208c <SERCOM0_SPI_Write>:
{
   2208c:	b508      	push	{r3, lr}
    return SERCOM0_SPI_WriteRead(pTransmitData, txSize, NULL, 0U);
   2208e:	2300      	movs	r3, #0
   22090:	461a      	mov	r2, r3
   22092:	f7f0 fb2d 	bl	126f0 <SERCOM0_SPI_WriteRead>
}
   22096:	bd08      	pop	{r3, pc}

Disassembly of section .text.gfx_mono_set_framebuffer%1142:

00022098 <gfx_mono_set_framebuffer>:
    fbpointer = framebuffer;
   22098:	4b01      	ldr	r3, [pc, #4]	; (220a0 <gfx_mono_set_framebuffer+0x8>)
   2209a:	6018      	str	r0, [r3, #0]
}
   2209c:	4770      	bx	lr
   2209e:	bf00      	nop
   220a0:	2000e4dc 	.word	0x2000e4dc

Disassembly of section .text._cleanup_r%1143:

000220a4 <_cleanup_r>:
   220a4:	4901      	ldr	r1, [pc, #4]	; (220ac <_cleanup_r+0x8>)
   220a6:	f7fc b9db 	b.w	1e460 <_fwalk_reent>
   220aa:	bf00      	nop
   220ac:	0001c3c1 	.word	0x0001c3c1

Disassembly of section .text.__locale_mb_cur_max%1144:

000220b0 <__locale_mb_cur_max>:
   220b0:	4b01      	ldr	r3, [pc, #4]	; (220b8 <__locale_mb_cur_max+0x8>)
   220b2:	f893 0128 	ldrb.w	r0, [r3, #296]	; 0x128
   220b6:	4770      	bx	lr
   220b8:	2000d644 	.word	0x2000d644

Disassembly of section .rodata.p05.7453%1145:

000220bc <p05.7453>:
   220bc:	00000005 00000019 0000007d              ........}...

Disassembly of section .text.fstat%1146:

000220c8 <fstat>:
   220c8:	f44f 5300 	mov.w	r3, #8192	; 0x2000
   220cc:	604b      	str	r3, [r1, #4]
   220ce:	2000      	movs	r0, #0
   220d0:	4770      	bx	lr
   220d2:	bf00      	nop

Disassembly of section .rodata%1147:

000220d4 <.rodata%1147>:
   220d4:	4f500043 	.word	0x4f500043
   220d8:	00584953 	.word	0x00584953
   220dc:	Address 0x000220dc is out of bounds.


Disassembly of section .text._DRV_ETHPHY_NegRestartPhaseWrite%1148:

000220e0 <_DRV_ETHPHY_NegRestartPhaseWrite>:
{
   220e0:	b508      	push	{r3, lr}
    _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OK);
   220e2:	2100      	movs	r1, #0
   220e4:	f7fd fe22 	bl	1fd2c <_DRV_PHY_SetOperDoneResult>
}
   220e8:	bd08      	pop	{r3, pc}

Disassembly of section .text._ICMPTxPktAcknowledge%1149:

000220ea <_ICMPTxPktAcknowledge>:
{
   220ea:	b508      	push	{r3, lr}
    TCPIP_PKT_PacketFree(pTxPkt);
   220ec:	f7fc f88c 	bl	1e208 <_TCPIP_PKT_PacketFree>
}
   220f0:	2000      	movs	r0, #0
   220f2:	bd08      	pop	{r3, pc}

Disassembly of section .text._Command_ZcllOnOff%1150:

000220f4 <_Command_ZcllOnOff>:
{
   220f4:	b508      	push	{r3, lr}
    return _Command_AddressService(pCmdIO, argc, argv, TCPIP_STACK_ADDRESS_SERVICE_ZCLL);
   220f6:	2302      	movs	r3, #2
   220f8:	f7f2 fa4c 	bl	14594 <_Command_AddressService>
}
   220fc:	bd08      	pop	{r3, pc}

Disassembly of section .text._Command_DHCPSOnOff%1151:

000220fe <_Command_DHCPSOnOff>:
{
   220fe:	b508      	push	{r3, lr}
    return _Command_AddressService(pCmdIO, argc, argv, TCPIP_STACK_ADDRESS_SERVICE_DHCPS);
   22100:	2303      	movs	r3, #3
   22102:	f7f2 fa47 	bl	14594 <_Command_AddressService>
}
   22106:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_DNS_Resolve%1152:

00022108 <TCPIP_DNS_Resolve>:
{
   22108:	b508      	push	{r3, lr}
    return _DNS_Resolve(hostName, type, false);
   2210a:	2200      	movs	r2, #0
   2210c:	f7f0 fa58 	bl	125c0 <_DNS_Resolve>
}
   22110:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_DNS_IsNameResolved%1153:

00022112 <TCPIP_DNS_IsNameResolved>:
{
   22112:	b508      	push	{r3, lr}
    return _DNS_IsNameResolved(hostName, hostIPv4, hostIPv6, false);
   22114:	2300      	movs	r3, #0
   22116:	f7f2 fca5 	bl	14a64 <_DNS_IsNameResolved>
}
   2211a:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_Helper_SingleListInitialize%1154:

0002211c <TCPIP_Helper_SingleListInitialize>:
    pL->head = pL->tail = 0;
   2211c:	2300      	movs	r3, #0
   2211e:	6043      	str	r3, [r0, #4]
   22120:	6003      	str	r3, [r0, #0]
    pL->nNodes = 0;
   22122:	6083      	str	r3, [r0, #8]
}
   22124:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetNameGet%1155:

00022126 <TCPIP_STACK_NetNameGet>:
    if(pNetIf != 0 && pNetIf->pMacObj != 0)
   22126:	b110      	cbz	r0, 2212e <TCPIP_STACK_NetNameGet+0x8>
   22128:	6c40      	ldr	r0, [r0, #68]	; 0x44
   2212a:	b100      	cbz	r0, 2212e <TCPIP_STACK_NetNameGet+0x8>
        return pNetIf->pMacObj->macName;
   2212c:	6840      	ldr	r0, [r0, #4]
}
   2212e:	4770      	bx	lr

Disassembly of section .text._TCPIPStackAddressServiceIsRunning%1156:

00022130 <_TCPIPStackAddressServiceIsRunning>:
    return (TCPIP_STACK_ADDRESS_SERVICE_TYPE)(pNetIf->Flags.v & TCPIP_STACK_ADDRESS_SERVICE_MASK);
   22130:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
}
   22134:	f000 0007 	and.w	r0, r0, #7
   22138:	4770      	bx	lr

Disassembly of section .text.TCPIP_UDP_ServerOpen%1157:

0002213a <TCPIP_UDP_ServerOpen>:
{
   2213a:	b508      	push	{r3, lr}
    return TCPIP_UDP_OpenServerSkt(addType, localPort, localAddress, UDP_OPEN_SERVER);
   2213c:	2301      	movs	r3, #1
   2213e:	f7f3 ff2d 	bl	15f9c <TCPIP_UDP_OpenServerSkt>
}
   22142:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_UDP_ClientOpen%1158:

00022144 <TCPIP_UDP_ClientOpen>:
{
   22144:	b508      	push	{r3, lr}
    return TCPIP_UDP_OpenClientSkt(addType, remotePort, remoteAddress, UDP_OPEN_CLIENT);
   22146:	2302      	movs	r3, #2
   22148:	f7fc f87c 	bl	1e244 <TCPIP_UDP_OpenClientSkt>
}
   2214c:	bd08      	pop	{r3, pc}

Disassembly of section .text.DRV_EXTPHY_SMIClockGet%1159:

0001b318 <DRV_EXTPHY_SMIClockGet>:
}
   1b318:	4800      	ldr	r0, [pc, #0]	; (1b31c <DRV_EXTPHY_SMIClockGet+0x4>)
   1b31a:	4770      	bx	lr
   1b31c:	002625a0 	.word	0x002625a0

Disassembly of section .text.TCPIP_HEAP_MallocOutline%1160:

000205c8 <TCPIP_HEAP_MallocOutline>:

// functions needed when not inlined
void* TCPIP_HEAP_MallocOutline(TCPIP_STACK_HEAP_HANDLE h, size_t nBytes)
{
   205c8:	b508      	push	{r3, lr}
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
   205ca:	6843      	ldr	r3, [r0, #4]
   205cc:	4798      	blx	r3
}
   205ce:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_HEAP_CallocOutline%1161:

0002214e <TCPIP_HEAP_CallocOutline>:

void* TCPIP_HEAP_CallocOutline(TCPIP_STACK_HEAP_HANDLE h, size_t nElems, size_t elemSize)
{
   2214e:	b508      	push	{r3, lr}
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Calloc)(h, nElems, elemSize);
   22150:	6883      	ldr	r3, [r0, #8]
   22152:	4798      	blx	r3
}
   22154:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_HEAP_FreeOutline%1162:

00022156 <TCPIP_HEAP_FreeOutline>:

size_t TCPIP_HEAP_FreeOutline(TCPIP_STACK_HEAP_HANDLE h, const void* ptr)
{
   22156:	b508      	push	{r3, lr}
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   22158:	68c3      	ldr	r3, [r0, #12]
   2215a:	4798      	blx	r3
}
   2215c:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_STACK_GatewayAddressSet%1163:

0002215e <TCPIP_STACK_GatewayAddressSet>:
    if(pNetIf)
   2215e:	b108      	cbz	r0, 22164 <TCPIP_STACK_GatewayAddressSet+0x6>
        pNetIf->netGateway.Val = ipAddress->Val;
   22160:	680a      	ldr	r2, [r1, #0]
   22162:	60c2      	str	r2, [r0, #12]
}
   22164:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_PrimaryDNSAddressSet%1164:

00022166 <TCPIP_STACK_PrimaryDNSAddressSet>:
    if(pNetIf)
   22166:	b108      	cbz	r0, 2216c <TCPIP_STACK_PrimaryDNSAddressSet+0x6>
        pNetIf->dnsServer[0].Val = ipAddress->Val;
   22168:	680a      	ldr	r2, [r1, #0]
   2216a:	6102      	str	r2, [r0, #16]
}
   2216c:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_SecondaryDNSAddressSet%1165:

0002216e <TCPIP_STACK_SecondaryDNSAddressSet>:
    if(pNetIf)
   2216e:	b108      	cbz	r0, 22174 <TCPIP_STACK_SecondaryDNSAddressSet+0x6>
        pNetIf->dnsServer[1].Val = ipAddress->Val;
   22170:	680a      	ldr	r2, [r1, #0]
   22172:	6142      	str	r2, [r0, #20]
}
   22174:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressMac%1166:

00022176 <TCPIP_STACK_NetAddressMac>:
{
   22176:	b508      	push	{r3, lr}
    return TCPIP_STACK_NetUpMACAddressGet(pNetIf);
   22178:	f7ff fbd8 	bl	2192c <TCPIP_STACK_NetUpMACAddressGet>
}
   2217c:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_STACK_NetGetType%1167:

0002217e <TCPIP_STACK_NetGetType>:
    {
        return _TCPIPStackNetIsPrimary(pNetIf) ? TCPIP_NETWORK_TYPE_PRIMARY : TCPIP_NETWORK_TYPE_ALIAS;
    }

    return TCPIP_NETWORK_TYPE_UNKNOWN; 
}
   2217e:	3000      	adds	r0, #0
   22180:	bf18      	it	ne
   22182:	2001      	movne	r0, #1
   22184:	4770      	bx	lr

Disassembly of section .text.TCPIP_Notification_Initialize%1168:

00022186 <TCPIP_Notification_Initialize>:
{
   22186:	b508      	push	{r3, lr}
    return TCPIP_Helper_ProtectedSingleListInitialize(notifyList);
   22188:	f7fe fb1d 	bl	207c6 <TCPIP_Helper_ProtectedSingleListInitialize>
}
   2218c:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_UDP_TxPutIsReady%1169:

0002218e <TCPIP_UDP_TxPutIsReady>:
{
   2218e:	b508      	push	{r3, lr}
    return TCPIP_UDP_PutIsReady(s);
   22190:	f7fa fbc1 	bl	1c916 <TCPIP_UDP_PutIsReady>
}
   22194:	bd08      	pop	{r3, pc}

Disassembly of section .text.OSAL_Malloc%1170:

00022196 <OSAL_Malloc>:
  Remarks:
    None.

 */
void* OSAL_Malloc(size_t size)
{
   22196:	b508      	push	{r3, lr}
    return pvPortMalloc(size);
   22198:	f7f8 fcb6 	bl	1ab08 <pvPortMalloc>
}
   2219c:	bd08      	pop	{r3, pc}

Disassembly of section .text.SERCOM1_USART_WriteCountGet%1171:

0002219e <SERCOM1_USART_WriteCountGet>:
{
   2219e:	b508      	push	{r3, lr}
    nPendingTxBytes = SERCOM1_USART_WritePendingBytesGet();
   221a0:	f7ff fa3c 	bl	2161c <SERCOM1_USART_WritePendingBytesGet>
}
   221a4:	bd08      	pop	{r3, pc}

Disassembly of section .text.TC0_TimerFrequencyGet%1172:

000221a8 <TC0_TimerFrequencyGet>:
}
   221a8:	4800      	ldr	r0, [pc, #0]	; (221ac <TC0_TimerFrequencyGet+0x4>)
   221aa:	4770      	bx	lr
   221ac:	03938700 	.word	0x03938700

Disassembly of section .text.SYS_INT_Disable%1173:

000221b0 <SYS_INT_Disable>:
{
   221b0:	b508      	push	{r3, lr}
    return NVIC_INT_Disable();
   221b2:	f7ff fc74 	bl	21a9e <NVIC_INT_Disable>
}
   221b6:	bd08      	pop	{r3, pc}

Disassembly of section .text.SYS_INT_Restore%1174:

000221b8 <SYS_INT_Restore>:
{
   221b8:	b508      	push	{r3, lr}
    NVIC_INT_Restore(state);
   221ba:	f7ff fc79 	bl	21ab0 <NVIC_INT_Restore>
}
   221be:	bd08      	pop	{r3, pc}

Disassembly of section .text.SYS_TIME_CounterGet%1175:

000221c0 <SYS_TIME_CounterGet>:
{
   221c0:	b508      	push	{r3, lr}
    counter32 = (uint32_t)SYS_TIME_Counter64Get();
   221c2:	f7fc f8d5 	bl	1e370 <SYS_TIME_Counter64Get>
}
   221c6:	bd08      	pop	{r3, pc}

Disassembly of section .rodata.drvMiimInitData%1176:

000221c8 <drvMiimInitData>:
   221c8:	0000 0000 0800 4200                         .......B

Disassembly of section .rodata.sysTimeInitData%1177:

000221d0 <sysTimeInitData>:
   221d0:	1110 0002 006b 0000                         ....k...

Disassembly of section .rodata.tcpipTCPInitData%1178:

000221d8 <tcpipTCPInitData>:
   221d8:	000a 0000 0200 0200                         ........

Disassembly of section .rodata.tcpipUDPInitData%1179:

000221e0 <tcpipUDPInitData>:
   221e0:	000a 0200 0000 0000                         ........

Disassembly of section .text.vQueueDelete%1180:

000221e8 <vQueueDelete>:
{
   221e8:	b508      	push	{r3, lr}
		vPortFree( pxQueue );
   221ea:	f7f9 f960 	bl	1b4ae <vPortFree>
}
   221ee:	bd08      	pop	{r3, pc}

Disassembly of section .rodata%1181:

000221f0 <.rodata%1181>:
   221f0:	454c4449 	.word	0x454c4449
   221f4:	00          	.byte	0x00
   221f5:	00          	.byte	0x00
   221f6:	bf00      	nop

Disassembly of section .text.gfx_mono_ssd1306_get_byte%1182:

000221f8 <gfx_mono_ssd1306_get_byte>:
uint8_t gfx_mono_ssd1306_get_byte(gfx_coord_t page, gfx_coord_t column) {
   221f8:	b508      	push	{r3, lr}
    return gfx_mono_framebuffer_get_byte(page, column);
   221fa:	f7ff fd27 	bl	21c4c <gfx_mono_framebuffer_get_byte>
    ssd1306_set_column_address(column);

    return ssd1306_read_data();

#endif
}
   221fe:	bd08      	pop	{r3, pc}

Disassembly of section .text.atoi%1183:

00022200 <atoi>:
   22200:	220a      	movs	r2, #10
   22202:	2100      	movs	r1, #0
   22204:	f7ff bc14 	b.w	21a30 <strtol>

Disassembly of section .text._localeconv_r%1184:

00022208 <_localeconv_r>:
   22208:	4800      	ldr	r0, [pc, #0]	; (2220c <_localeconv_r+0x4>)
   2220a:	4770      	bx	lr
   2220c:	2000d734 	.word	0x2000d734

Disassembly of section .text.__sclose%1185:

00022210 <__sclose>:
   22210:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   22214:	f7fe bd4c 	b.w	20cb0 <_close_r>

Disassembly of section .text.close%1186:

00022218 <close>:
   22218:	f04f 30ff 	mov.w	r0, #4294967295
   2221c:	4770      	bx	lr
   2221e:	bf00      	nop

Disassembly of section .text.TCPIP_ARP_HashKeyCopy%1187:

00022220 <TCPIP_ARP_HashKeyCopy>:

void TCPIP_ARP_HashKeyCopy(OA_HASH_DCPT* pOH, OA_HASH_ENTRY* dstEntry, const void* key)
{

    ((ARP_HASH_ENTRY*)dstEntry)->ipAddress.Val = ((ARP_UNALIGNED_KEY*)key)->v;
   22220:	6813      	ldr	r3, [r2, #0]
   22222:	608b      	str	r3, [r1, #8]
}
   22224:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetBIOSName%1188:

00022226 <TCPIP_STACK_NetBIOSName>:
    if(pNetIf)
   22226:	b100      	cbz	r0, 2222a <TCPIP_STACK_NetBIOSName+0x4>
        return (const char*)pNetIf->NetBIOSName;
   22228:	302c      	adds	r0, #44	; 0x2c
}
   2222a:	4770      	bx	lr

Disassembly of section .text.TCPIP_PKT_GapDcptOffset%1189:

0002222c <TCPIP_PKT_GapDcptOffset>:
}
   2222c:	f06f 0007 	mvn.w	r0, #7
   22230:	4770      	bx	lr

Disassembly of section .text.vListInitialiseItem%1190:

00022232 <vListInitialiseItem>:
	pxItem->pxContainer = NULL;
   22232:	2300      	movs	r3, #0
   22234:	6103      	str	r3, [r0, #16]
}
   22236:	4770      	bx	lr

Disassembly of section .text.CRYPT_WCCB_Callback%1191:

00022238 <CRYPT_WCCB_Callback>:
}
   22238:	f46f 7087 	mvn.w	r0, #270	; 0x10e
   2223c:	4770      	bx	lr

Disassembly of section .text.DRV_EXTPHY_MDIXConfigure%1192:

00004c44 <DRV_EXTPHY_MDIXConfigure>:
}
    4c44:	2000      	movs	r0, #0
    4c46:	4770      	bx	lr

Disassembly of section .text.DRV_GMAC_PowerMode%1193:

000201dc <DRV_GMAC_PowerMode>:
}
   201dc:	2001      	movs	r0, #1
   201de:	4770      	bx	lr

Disassembly of section .text.DRV_PIC32CGMAC_LibRxQueFilterInit%1194:

0002223e <DRV_PIC32CGMAC_LibRxQueFilterInit>:
}
   2223e:	2000      	movs	r0, #0
   22240:	4770      	bx	lr

Disassembly of section .text.DRV_PIC32CGMAC_LibGetPriorityFromQueueNum%1195:

00022242 <DRV_PIC32CGMAC_LibGetPriorityFromQueueNum>:
}
   22242:	4608      	mov	r0, r1
   22244:	4770      	bx	lr

Disassembly of section .text.TCPIP_IPV4_IsFragmentationEnabled%1196:

00022246 <TCPIP_IPV4_IsFragmentationEnabled>:
#if (_TCPIP_IPV4_FRAGMENTATION != 0)
    return true;
#else
    return false;
#endif  // (_TCPIP_IPV4_FRAGMENTATION != 0)
}
   22246:	2000      	movs	r0, #0
   22248:	4770      	bx	lr

Disassembly of section .text._DHCPOptionProcessEnd%1197:

0002224a <_DHCPOptionProcessEnd>:
}
   2224a:	2000      	movs	r0, #0
   2224c:	4770      	bx	lr

Disassembly of section .rodata._DHCPRequestParamsTbl%1198:

00022250 <_DHCPRequestParamsTbl>:
   22250:	0301 0006                                   ....

Disassembly of section .rodata.dhcpMagicCookie%1199:

00022254 <dhcpMagicCookie>:
   22254:	8263 6353                                   c.Sc

Disassembly of section .text.TCPIP_PKT_GapDcptSize%1200:

00022258 <TCPIP_PKT_GapDcptSize>:
}
   22258:	2008      	movs	r0, #8
   2225a:	4770      	bx	lr

Disassembly of section .text._mon_getc%1201:

0002225c <_mon_getc>:

int _mon_getc(int canblock)
{
   (void)canblock;
   return 0;
}
   2225c:	2000      	movs	r0, #0
   2225e:	4770      	bx	lr

Disassembly of section .text.Console_UART_Flush%1202:

00022260 <Console_UART_Flush>:
}
   22260:	2001      	movs	r0, #1
   22262:	4770      	bx	lr

Disassembly of section .rodata.debugInit%1203:

00022264 <debugInit>:
   22264:	0400 0000                                   ....

Disassembly of section .rodata.sysConsole0UARTInitData%1204:

00022268 <sysConsole0UARTInitData>:
   22268:	16f4 0002                                   ....

Disassembly of section .text%1205:

0002226c <__aeabi_idiv0>:
   2226c:	4770      	bx	lr
   2226e:	bf00      	nop

Disassembly of section .rodata._global_impure_ptr%1206:

00022270 <_global_impure_ptr>:
   22270:	df44 2000                                   D.. 

Disassembly of section .text._getpid_r%1207:

00022274 <_getpid_r>:
   22274:	f000 b804 	b.w	22280 <_getpid>

Disassembly of section .text._close%1208:

00022278 <_close>:
   22278:	f7ff bfce 	b.w	22218 <close>

Disassembly of section .text._fstat%1209:

0002227c <_fstat>:
   2227c:	f7ff bf24 	b.w	220c8 <fstat>

Disassembly of section .text._getpid%1210:

00022280 <_getpid>:
   22280:	f000 b80a 	b.w	22298 <getpid>

Disassembly of section .text._isatty%1211:

00022284 <_isatty>:
   22284:	f000 b80a 	b.w	2229c <isatty>

Disassembly of section .text._kill%1212:

00022288 <_kill>:
   22288:	f000 b80a 	b.w	222a0 <kill>

Disassembly of section .text._lseek%1213:

0002228c <_lseek>:
   2228c:	f000 b80a 	b.w	222a4 <lseek>

Disassembly of section .text._read%1214:

00022290 <_read>:
   22290:	f7fd bfba 	b.w	20208 <read>

Disassembly of section .text._write%1215:

00022294 <_write>:
   22294:	f7fb bdee 	b.w	1de74 <write>

Disassembly of section .text.getpid%1216:

00022298 <getpid>:
   22298:	2000      	movs	r0, #0
   2229a:	4770      	bx	lr

Disassembly of section .text.isatty%1217:

0002229c <isatty>:
   2229c:	2001      	movs	r0, #1
   2229e:	4770      	bx	lr

Disassembly of section .text.kill%1218:

000222a0 <kill>:
   222a0:	4770      	bx	lr
   222a2:	bf00      	nop

Disassembly of section .text.lseek%1219:

000222a4 <lseek>:
   222a4:	2000      	movs	r0, #0
   222a6:	4770      	bx	lr

Disassembly of section .text._DRV_ETHPHY_ClientOpNone%1220:

00010616 <_DRV_ETHPHY_ClientOpNone>:
}
   10616:	4770      	bx	lr

Disassembly of section .text.DRV_GMAC_Reinitialize%1221:

00010f3e <DRV_GMAC_Reinitialize>:
}
   10f3e:	4770      	bx	lr

Disassembly of section .text.DRV_MIIM_Reinitialize%1222:

000120de <DRV_MIIM_Reinitialize>:
}
   120de:	4770      	bx	lr

Disassembly of section .text._TCPIP_HEAP_BufferMapNonCached%1223:

00012a7e <_TCPIP_HEAP_BufferMapNonCached>:
}
   12a7e:	4770      	bx	lr

Disassembly of section .text.EVSYS_Initialize%1224:

00014496 <EVSYS_Initialize>:

void EVSYS_Initialize( void )
{
    /*Event Channel User Configuration*/

}
   14496:	4770      	bx	lr

Disassembly of section .text._mon_putc%1225:

00014ff2 <_mon_putc>:

void _mon_putc(char c)
{
   (void)c;
}
   14ff2:	4770      	bx	lr

Disassembly of section .text.Console_UART_Tasks%1226:

00015386 <Console_UART_Tasks>:

void Console_UART_Tasks(uint32_t index, SYS_MODULE_OBJ object)
{
    /* Do nothing. */
   15386:	4770      	bx	lr

Disassembly of section .text.Dummy_Handler%1227:

0001588a <Dummy_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
    __builtin_software_breakpoint();
#endif
    while (true)
    {
    }
   1588a:	e7fe      	b.n	1588a <Dummy_Handler>

Disassembly of section .text.NonMaskableInt_Handler%1228:

000167c6 <NonMaskableInt_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
    __builtin_software_breakpoint();
#endif
    while (true)
    {
    }
   167c6:	e7fe      	b.n	167c6 <NonMaskableInt_Handler>

Disassembly of section .text.HardFault_Handler%1229:

00016c16 <HardFault_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
   __builtin_software_breakpoint();
#endif
   while (true)
   {
   }
   16c16:	e7fe      	b.n	16c16 <HardFault_Handler>

Disassembly of section .text.DebugMonitor_Handler%1230:

000172ee <DebugMonitor_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
   __builtin_software_breakpoint();
#endif
   while (true)
   {
   }
   172ee:	e7fe      	b.n	172ee <DebugMonitor_Handler>

Disassembly of section .text.MemoryManagement_Handler%1231:

00017786 <MemoryManagement_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
   __builtin_software_breakpoint();
#endif
   while (true)
   {
   }
   17786:	e7fe      	b.n	17786 <MemoryManagement_Handler>

Disassembly of section .text.BusFault_Handler%1232:

00017a12 <BusFault_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
   __builtin_software_breakpoint();
#endif
   while (true)
   {
   }
   17a12:	e7fe      	b.n	17a12 <BusFault_Handler>

Disassembly of section .text.UsageFault_Handler%1233:

000180e6 <UsageFault_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
   __builtin_software_breakpoint();
#endif
   while (true)
   {
   }
   180e6:	e7fe      	b.n	180e6 <UsageFault_Handler>

Disassembly of section .text.Dummy_App_Func%1234:

00019afe <Dummy_App_Func>:
}
   19afe:	4770      	bx	lr

Disassembly of section .text._exit%1235:

0001ac4a <_exit>:
#endif

    /* halt CPU */
    while (true)
    {
    }
   1ac4a:	e7fe      	b.n	1ac4a <_exit>

Disassembly of section .text.vPortFree%1236:

0001b4ae <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
   1b4ae:	4770      	bx	lr

Disassembly of section .text.wc_Sha256Free%1237:

0001c022 <wc_Sha256Free>:
    }
#endif
#ifdef WOLFSSL_IMXRT_DCP
    DCPSha256Free(sha256);
#endif
}
   1c022:	4770      	bx	lr

Disassembly of section .text.__malloc_lock%1238:

0001c50a <__malloc_lock>:
   1c50a:	4770      	bx	lr

Disassembly of section .text.__malloc_unlock%1239:

0001e152 <__malloc_unlock>:
   1e152:	4770      	bx	lr
