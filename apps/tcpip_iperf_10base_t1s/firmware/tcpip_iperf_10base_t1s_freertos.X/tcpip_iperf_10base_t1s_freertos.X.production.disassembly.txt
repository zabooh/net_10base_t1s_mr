
.\dist\FreeRTOS\production\tcpip_iperf_10base_t1s_freertos.X.production.elf:     file format elf32-littlearm


Disassembly of section .config_00804000:

00804000 <__config_00804000>:
  804000:	39 12 00 3c                                         9..<

Disassembly of section .config_00804008:

00804008 <__config_00804008>:
  804008:	ff ff ff ff                                         ....

Disassembly of section .config_00804004:

00804004 <__config_00804004>:
  804004:	80 00 a8 2a                                         ...*

Disassembly of section .vectors:

00000000 <exception_table>:
   0:	f0 ff 03 20 0d a4 01 00 53 80 01 00 a3 84 01 00     ... ....S.......
  10:	6f 91 01 00 fb 93 01 00 c7 9a 01 00 00 00 00 00     o...............
	...
  2c:	01 27 02 00 2f 8c 01 00 00 00 00 00 b1 ce 01 00     .'../...........
  3c:	81 1b 02 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .....p...p...p..
  4c:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
  5c:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
  6c:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
  7c:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
  8c:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
  9c:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
  ac:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
  bc:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
  cc:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
  dc:	f7 70 01 00 f7 70 01 00 f7 70 01 00 00 00 00 00     .p...p...p......
	...
  f4:	f7 70 01 00 31 25 01 00 31 25 01 00 31 25 01 00     .p..1%..1%..1%..
 104:	31 25 01 00 d1 20 01 00 d1 20 01 00 d1 20 01 00     1%... ... ... ..
 114:	d1 20 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     . ...p...p...p..
 124:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
 134:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
 144:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
 154:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
 164:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
 174:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
 184:	f7 70 01 00 f7 70 01 00 f7 70 01 00 2d 11 02 00     .p...p...p..-...
 194:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
 1a4:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
 1b4:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
 1c4:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
 1d4:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
 1e4:	f7 70 01 00 f7 70 01 00 d1 1a 02 00 f7 70 01 00     .p...p.......p..
 1f4:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
 204:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
 214:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
 224:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
 234:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
 244:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..
 254:	f7 70 01 00 f7 70 01 00 f7 70 01 00 f7 70 01 00     .p...p...p...p..

Disassembly of section .text:

00000264 <_init>:
 264:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 266:	bf00      	nop
 268:	bcf8      	pop	{r3, r4, r5, r6, r7}
 26a:	bc08      	pop	{r3}
 26c:	469e      	mov	lr, r3
 26e:	4770      	bx	lr

00000270 <__init_array_start>:
 270:	0001f7c9 	.word	0x0001f7c9

00000274 <_fini>:
 274:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 276:	bf00      	nop
 278:	bcf8      	pop	{r3, r4, r5, r6, r7}
 27a:	bc08      	pop	{r3}
 27c:	469e      	mov	lr, r3
 27e:	4770      	bx	lr

00000280 <__fini_array_start>:
 280:	0001f7a5 	.word	0x0001f7a5

Disassembly of section .rodata%211:

0000028c <.rodata%211>:
     28c:	67617355 	.word	0x67617355
     290:	6d203a65 	.word	0x6d203a65
     294:	6e696361 	.word	0x6e696361
     298:	0d206f66 	.word	0x0d206f66
     29c:	0000000a 	.word	0x0000000a
     2a0:	203a7845 	.word	0x203a7845
     2a4:	6963616d 	.word	0x6963616d
     2a8:	206f666e 	.word	0x206f666e
     2ac:	00000a0d 	.word	0x00000a0d
     2b0:	65746e49 	.word	0x65746e49
     2b4:	63616672 	.word	0x63616672
     2b8:	25203a65 	.word	0x25203a65
     2bc:	72442073 	.word	0x72442073
     2c0:	72657669 	.word	0x72657669
     2c4:	61745320 	.word	0x61745320
     2c8:	74736974 	.word	0x74736974
     2cc:	0d736369 	.word	0x0d736369
     2d0:	0000000a 	.word	0x0000000a
     2d4:	52200a0d 	.word	0x52200a0d
     2d8:	69656365 	.word	0x69656365
     2dc:	53206576 	.word	0x53206576
     2e0:	69746174 	.word	0x69746174
     2e4:	63697473 	.word	0x63697473
     2e8:	000a0d73 	.word	0x000a0d73
     2ec:	526e2009 	.word	0x526e2009
     2f0:	506b4f78 	.word	0x506b4f78
     2f4:	656b6361 	.word	0x656b6361
     2f8:	203a7374 	.word	0x203a7374
     2fc:	0a0d6425 	.word	0x0a0d6425
     300:	526e2009 	.word	0x526e2009
     304:	6e655078 	.word	0x6e655078
     308:	66754264 	.word	0x66754264
     30c:	73726566 	.word	0x73726566
     310:	6425203a 	.word	0x6425203a
     314:	20090a0d 	.word	0x20090a0d
     318:	5378526e 	.word	0x5378526e
     31c:	64656863 	.word	0x64656863
     320:	66667542 	.word	0x66667542
     324:	3a737265 	.word	0x3a737265
     328:	0d642520 	.word	0x0d642520
     32c:	0000000a 	.word	0x0000000a
     330:	526e2009 	.word	0x526e2009
     334:	72724578 	.word	0x72724578
     338:	6150726f 	.word	0x6150726f
     33c:	74656b63 	.word	0x74656b63
     340:	25203a73 	.word	0x25203a73
     344:	090a0d64 	.word	0x090a0d64
     348:	78526e20 	.word	0x78526e20
     34c:	67617246 	.word	0x67617246
     350:	746e656d 	.word	0x746e656d
     354:	6f727245 	.word	0x6f727245
     358:	203a7372 	.word	0x203a7372
     35c:	0a0d6425 	.word	0x0a0d6425
     360:	526e2009 	.word	0x526e2009
     364:	66754278 	.word	0x66754278
     368:	746f4e66 	.word	0x746f4e66
     36c:	69617641 	.word	0x69617641
     370:	6c62616c 	.word	0x6c62616c
     374:	25203a65 	.word	0x25203a65
     378:	000a0d64 	.word	0x000a0d64
     37c:	54200a0d 	.word	0x54200a0d
     380:	736e6172 	.word	0x736e6172
     384:	2074696d 	.word	0x2074696d
     388:	74617453 	.word	0x74617453
     38c:	69747369 	.word	0x69747369
     390:	0a0d7363 	.word	0x0a0d7363
     394:	00000000 	.word	0x00000000
     398:	546e2009 	.word	0x546e2009
     39c:	506b4f78 	.word	0x506b4f78
     3a0:	656b6361 	.word	0x656b6361
     3a4:	203a7374 	.word	0x203a7374
     3a8:	0a0d6425 	.word	0x0a0d6425
     3ac:	546e2009 	.word	0x546e2009
     3b0:	6e655078 	.word	0x6e655078
     3b4:	66754264 	.word	0x66754264
     3b8:	73726566 	.word	0x73726566
     3bc:	6425203a 	.word	0x6425203a
     3c0:	20090a0d 	.word	0x20090a0d
     3c4:	4578546e 	.word	0x4578546e
     3c8:	726f7272 	.word	0x726f7272
     3cc:	6b636150 	.word	0x6b636150
     3d0:	3a737465 	.word	0x3a737465
     3d4:	0d642520 	.word	0x0d642520
     3d8:	6e20090a 	.word	0x6e20090a
     3dc:	75517854 	.word	0x75517854
     3e0:	46657565 	.word	0x46657565
     3e4:	3a6c6c75 	.word	0x3a6c6c75
     3e8:	0d642520 	.word	0x0d642520
     3ec:	000a0d0a 	.word	0x000a0d0a
     3f0:	746f6e09 	.word	0x746f6e09
     3f4:	70757320 	.word	0x70757320
     3f8:	74726f70 	.word	0x74726f70
     3fc:	0a0d6465 	.word	0x0a0d6465
     400:	00000000 	.word	0x00000000
     404:	65746e49 	.word	0x65746e49
     408:	63616672 	.word	0x63616672
     40c:	25203a65 	.word	0x25203a65
     410:	61482073 	.word	0x61482073
     414:	61776472 	.word	0x61776472
     418:	52206572 	.word	0x52206572
     41c:	73696765 	.word	0x73696765
     420:	20726574 	.word	0x20726574
     424:	74617453 	.word	0x74617453
     428:	0a0d7375 	.word	0x0a0d7375
     42c:	00000000 	.word	0x00000000
     430:	73252009 	.word	0x73252009
     434:	7830203a 	.word	0x7830203a
     438:	0a0d7825 	.word	0x0a0d7825
     43c:	00000000 	.word	0x00000000
     440:	62616e65 	.word	0x62616e65
     444:	0064656c 	.word	0x0064656c
     448:	62616e65 	.word	0x62616e65
     44c:	0000656c 	.word	0x0000656c
     450:	61736964 	.word	0x61736964
     454:	64656c62 	.word	0x64656c62
     458:	00000000 	.word	0x00000000
     45c:	61736964 	.word	0x61736964
     460:	00656c62 	.word	0x00656c62
     464:	67617355 	.word	0x67617355
     468:	25203a65 	.word	0x25203a65
     46c:	693c2073 	.word	0x693c2073
     470:	7265746e 	.word	0x7265746e
     474:	65636166 	.word	0x65636166
     478:	6f3c203e 	.word	0x6f3c203e
     47c:	666f2f6e 	.word	0x666f2f6e
     480:	0d203e66 	.word	0x0d203e66
     484:	0000000a 	.word	0x0000000a
     488:	203a7845 	.word	0x203a7845
     48c:	50207325 	.word	0x50207325
     490:	32334349 	.word	0x32334349
     494:	20544e49 	.word	0x20544e49
     498:	0d206e6f 	.word	0x0d206e6f
     49c:	0000000a 	.word	0x0000000a
     4a0:	6e6b6e55 	.word	0x6e6b6e55
     4a4:	206e776f 	.word	0x206e776f
     4a8:	65746e69 	.word	0x65746e69
     4ac:	63616672 	.word	0x63616672
     4b0:	000a0d65 	.word	0x000a0d65
     4b4:	00006e6f 	.word	0x00006e6f
     4b8:	0066666f 	.word	0x0066666f
     4bc:	6e6b6e55 	.word	0x6e6b6e55
     4c0:	206e776f 	.word	0x206e776f
     4c4:	6974706f 	.word	0x6974706f
     4c8:	0a0d6e6f 	.word	0x0a0d6e6f
     4cc:	00000000 	.word	0x00000000
     4d0:	25207325 	.word	0x25207325
     4d4:	000a0d73 	.word	0x000a0d73
     4d8:	6c696146 	.word	0x6c696146
     4dc:	74206465 	.word	0x74206465
     4e0:	7325206f 	.word	0x7325206f
     4e4:	0d732520 	.word	0x0d732520
     4e8:	0000000a 	.word	0x0000000a
     4ec:	6e6b6e55 	.word	0x6e6b6e55
     4f0:	206e776f 	.word	0x206e776f
     4f4:	76726573 	.word	0x76726573
     4f8:	20656369 	.word	0x20656369
     4fc:	0a0d7325 	.word	0x0a0d7325
     500:	00000000 	.word	0x00000000
     504:	656e6f6e 	.word	0x656e6f6e
     508:	00000000 	.word	0x00000000
     50c:	00001820 	.word	0x00001820
     510:	00000001 	.word	0x00000001
     514:	00001334 	.word	0x00001334
     518:	00000002 	.word	0x00000002
     51c:	000004b4 	.word	0x000004b4
     520:	00000003 	.word	0x00000003
     524:	000004b8 	.word	0x000004b8
     528:	00000003 	.word	0x00000003
     52c:	00001824 	.word	0x00001824
     530:	00000004 	.word	0x00000004
     534:	67617355 	.word	0x67617355
     538:	64203a65 	.word	0x64203a65
     53c:	2063736e 	.word	0x2063736e
     540:	6c65643c 	.word	0x6c65643c
     544:	666e692f 	.word	0x666e692f
     548:	6e6f2f6f 	.word	0x6e6f2f6f
     54c:	66666f2f 	.word	0x66666f2f
     550:	6f6f6c2f 	.word	0x6f6f6c2f
     554:	3e70756b 	.word	0x3e70756b
     558:	000a0d20 	.word	0x000a0d20
     55c:	67617355 	.word	0x67617355
     560:	25203a65 	.word	0x25203a65
     564:	6f3c2073 	.word	0x6f3c2073
     568:	666f2f6e 	.word	0x666f2f6e
     56c:	3c203e66 	.word	0x3c203e66
     570:	65746e69 	.word	0x65746e69
     574:	63616672 	.word	0x63616672
     578:	3c203e65 	.word	0x3c203e65
     57c:	69727473 	.word	0x69727473
     580:	702f7463 	.word	0x702f7463
     584:	3e666572 	.word	0x3e666572
     588:	6c633c2f 	.word	0x6c633c2f
     58c:	3e726165 	.word	0x3e726165
     590:	000a0d20 	.word	0x000a0d20
     594:	203a7845 	.word	0x203a7845
     598:	6f207325 	.word	0x6f207325
     59c:	7465206e 	.word	0x7465206e
     5a0:	0a0d3068 	.word	0x0a0d3068
     5a4:	00000000 	.word	0x00000000
     5a8:	69727473 	.word	0x69727473
     5ac:	00007463 	.word	0x00007463
     5b0:	66657270 	.word	0x66657270
     5b4:	00000000 	.word	0x00000000
     5b8:	61656c63 	.word	0x61656c63
     5bc:	00000072 	.word	0x00000072
     5c0:	67617355 	.word	0x67617355
     5c4:	64203a65 	.word	0x64203a65
     5c8:	2063736e 	.word	0x2063736e
     5cc:	6b6f6f6c 	.word	0x6b6f6f6c
     5d0:	3c207075 	.word	0x3c207075
     5d4:	65707974 	.word	0x65707974
     5d8:	683c203e 	.word	0x683c203e
     5dc:	4e74736f 	.word	0x4e74736f
     5e0:	3e656d61 	.word	0x3e656d61
     5e4:	000a0d20 	.word	0x000a0d20
     5e8:	706c6548 	.word	0x706c6548
     5ec:	683c203a 	.word	0x683c203a
     5f0:	4e74736f 	.word	0x4e74736f
     5f4:	3e656d61 	.word	0x3e656d61
     5f8:	4c525528 	.word	0x4c525528
     5fc:	202d2029 	.word	0x202d2029
     600:	6b6f6f6c 	.word	0x6b6f6f6c
     604:	20707520 	.word	0x20707520
     608:	20726f66 	.word	0x20726f66
     60c:	74736f68 	.word	0x74736f68
     610:	656d616e 	.word	0x656d616e
     614:	00000a0d 	.word	0x00000a0d
     618:	706c6548 	.word	0x706c6548
     61c:	743c203a 	.word	0x743c203a
     620:	3e657079 	.word	0x3e657079
     624:	61203a20 	.word	0x61203a20
     628:	20726f20 	.word	0x20726f20
     62c:	6f662041 	.word	0x6f662041
     630:	50492072 	.word	0x50492072
     634:	61203476 	.word	0x61203476
     638:	65726464 	.word	0x65726464
     63c:	6c207373 	.word	0x6c207373
     640:	756b6f6f 	.word	0x756b6f6f
     644:	000a0d70 	.word	0x000a0d70
     648:	706c6548 	.word	0x706c6548
     64c:	743c203a 	.word	0x743c203a
     650:	3e657079 	.word	0x3e657079
     654:	61203a20 	.word	0x61203a20
     658:	20616161 	.word	0x20616161
     65c:	4120726f 	.word	0x4120726f
     660:	20414141 	.word	0x20414141
     664:	20726f66 	.word	0x20726f66
     668:	36765049 	.word	0x36765049
     66c:	64646120 	.word	0x64646120
     670:	73736572 	.word	0x73736572
     674:	6f6f6c20 	.word	0x6f6f6c20
     678:	0d70756b 	.word	0x0d70756b
     67c:	0000000a 	.word	0x0000000a
     680:	706c6548 	.word	0x706c6548
     684:	743c203a 	.word	0x743c203a
     688:	3e657079 	.word	0x3e657079
     68c:	61203a20 	.word	0x61203a20
     690:	6620796e 	.word	0x6620796e
     694:	6220726f 	.word	0x6220726f
     698:	2068746f 	.word	0x2068746f
     69c:	34765049 	.word	0x34765049
     6a0:	646e6120 	.word	0x646e6120
     6a4:	76504920 	.word	0x76504920
     6a8:	64612036 	.word	0x64612036
     6ac:	73657264 	.word	0x73657264
     6b0:	6f6c2073 	.word	0x6f6c2073
     6b4:	70756b6f 	.word	0x70756b6f
     6b8:	00000a0d 	.word	0x00000a0d
     6bc:	63736e64 	.word	0x63736e64
     6c0:	6f6f6c20 	.word	0x6f6f6c20
     6c4:	3a70756b 	.word	0x3a70756b
     6c8:	6d6f6320 	.word	0x6d6f6320
     6cc:	646e616d 	.word	0x646e616d
     6d0:	206e6920 	.word	0x206e6920
     6d4:	676f7270 	.word	0x676f7270
     6d8:	73736572 	.word	0x73736572
     6dc:	6552202e 	.word	0x6552202e
     6e0:	20797274 	.word	0x20797274
     6e4:	6574616c 	.word	0x6574616c
     6e8:	0a0d2e72 	.word	0x0a0d2e72
     6ec:	00000000 	.word	0x00000000
     6f0:	00000041 	.word	0x00000041
     6f4:	00000061 	.word	0x00000061
     6f8:	41414141 	.word	0x41414141
     6fc:	00000000 	.word	0x00000000
     700:	61616161 	.word	0x61616161
     704:	00000000 	.word	0x00000000
     708:	00594e41 	.word	0x00594e41
     70c:	00796e61 	.word	0x00796e61
     710:	63736e64 	.word	0x63736e64
     714:	6f6f6c20 	.word	0x6f6f6c20
     718:	3a70756b 	.word	0x3a70756b
     71c:	73255b20 	.word	0x73255b20
     720:	6f4c205d 	.word	0x6f4c205d
     724:	70756b6f 	.word	0x70756b6f
     728:	70795420 	.word	0x70795420
     72c:	6f6e2065 	.word	0x6f6e2065
     730:	75732074 	.word	0x75732074
     734:	726f7070 	.word	0x726f7070
     738:	2e646574 	.word	0x2e646574
     73c:	00000a0d 	.word	0x00000a0d
     740:	63736e64 	.word	0x63736e64
     744:	6f6f6c20 	.word	0x6f6f6c20
     748:	3a70756b 	.word	0x3a70756b
     74c:	736f4820 	.word	0x736f4820
     750:	616e2074 	.word	0x616e2074
     754:	7420656d 	.word	0x7420656d
     758:	6c206f6f 	.word	0x6c206f6f
     75c:	2e676e6f 	.word	0x2e676e6f
     760:	74655220 	.word	0x74655220
     764:	0d2e7972 	.word	0x0d2e7972
     768:	0000000a 	.word	0x0000000a
     76c:	63736e64 	.word	0x63736e64
     770:	6f6f6c20 	.word	0x6f6f6c20
     774:	3a70756b 	.word	0x3a70756b
     778:	73657220 	.word	0x73657220
     77c:	69766c6f 	.word	0x69766c6f
     780:	6820676e 	.word	0x6820676e
     784:	3a74736f 	.word	0x3a74736f
     788:	20732520 	.word	0x20732520
     78c:	20726f66 	.word	0x20726f66
     790:	65707974 	.word	0x65707974
     794:	2073253a 	.word	0x2073253a
     798:	00000a0d 	.word	0x00000a0d
     79c:	67617355 	.word	0x67617355
     7a0:	64203a65 	.word	0x64203a65
     7a4:	2063736e 	.word	0x2063736e
     7a8:	206c6564 	.word	0x206c6564
     7ac:	736f683c 	.word	0x736f683c
     7b0:	6d614e74 	.word	0x6d614e74
     7b4:	617c3e65 	.word	0x617c3e65
     7b8:	0d206c6c 	.word	0x0d206c6c
     7bc:	0000000a 	.word	0x0000000a
     7c0:	706c6548 	.word	0x706c6548
     7c4:	683c203a 	.word	0x683c203a
     7c8:	4e74736f 	.word	0x4e74736f
     7cc:	3e656d61 	.word	0x3e656d61
     7d0:	4c525528 	.word	0x4c525528
     7d4:	202d2029 	.word	0x202d2029
     7d8:	6f6d6552 	.word	0x6f6d6552
     7dc:	74206576 	.word	0x74206576
     7e0:	65206568 	.word	0x65206568
     7e4:	7972746e 	.word	0x7972746e
     7e8:	20666920 	.word	0x20666920
     7ec:	73697865 	.word	0x73697865
     7f0:	0d207374 	.word	0x0d207374
     7f4:	0000000a 	.word	0x0000000a
     7f8:	706c6548 	.word	0x706c6548
     7fc:	6c61203a 	.word	0x6c61203a
     800:	202d206c 	.word	0x202d206c
     804:	6f6d6552 	.word	0x6f6d6552
     808:	61206576 	.word	0x61206576
     80c:	74206c6c 	.word	0x74206c6c
     810:	72206568 	.word	0x72206568
     814:	6c6f7365 	.word	0x6c6f7365
     818:	20646576 	.word	0x20646576
     81c:	72746e65 	.word	0x72746e65
     820:	0a0d2079 	.word	0x0a0d2079
     824:	00000000 	.word	0x00000000
     828:	006c6c61 	.word	0x006c6c61
     82c:	5d73255b 	.word	0x5d73255b
     830:	746f6e20 	.word	0x746f6e20
     834:	72617020 	.word	0x72617020
     838:	666f2074 	.word	0x666f2074
     83c:	65687420 	.word	0x65687420
     840:	534e4420 	.word	0x534e4420
     844:	63614320 	.word	0x63614320
     848:	65206568 	.word	0x65206568
     84c:	7972746e 	.word	0x7972746e
     850:	000a0d20 	.word	0x000a0d20
     854:	6f636e49 	.word	0x6f636e49
     858:	656c706d 	.word	0x656c706d
     85c:	63206574 	.word	0x63206574
     860:	616d6d6f 	.word	0x616d6d6f
     864:	0d20646e 	.word	0x0d20646e
     868:	0000000a 	.word	0x0000000a
     86c:	67617355 	.word	0x67617355
     870:	64203a65 	.word	0x64203a65
     874:	2063736e 	.word	0x2063736e
     878:	6f666e69 	.word	0x6f666e69
     87c:	000a0d20 	.word	0x000a0d20
     880:	706c6548 	.word	0x706c6548
     884:	6964203a 	.word	0x6964203a
     888:	616c7073 	.word	0x616c7073
     88c:	68742079 	.word	0x68742079
     890:	4e442065 	.word	0x4e442065
     894:	61632053 	.word	0x61632053
     898:	20656863 	.word	0x20656863
     89c:	72746e65 	.word	0x72746e65
     8a0:	65642079 	.word	0x65642079
     8a4:	6c696174 	.word	0x6c696174
     8a8:	0a0d2073 	.word	0x0a0d2073
     8ac:	00000000 	.word	0x00000000
     8b0:	20534e44 	.word	0x20534e44
     8b4:	65696c43 	.word	0x65696c43
     8b8:	6920746e 	.word	0x6920746e
     8bc:	6f642073 	.word	0x6f642073
     8c0:	0d216e77 	.word	0x0d216e77
     8c4:	0000000a 	.word	0x0000000a
     8c8:	20534e44 	.word	0x20534e44
     8cc:	65696c43 	.word	0x65696c43
     8d0:	4920746e 	.word	0x4920746e
     8d4:	202d2046 	.word	0x202d2046
     8d8:	69727453 	.word	0x69727453
     8dc:	203a7463 	.word	0x203a7463
     8e0:	202c7325 	.word	0x202c7325
     8e4:	66657250 	.word	0x66657250
     8e8:	65727265 	.word	0x65727265
     8ec:	25203a64 	.word	0x25203a64
     8f0:	000a0d73 	.word	0x000a0d73
     8f4:	20534e44 	.word	0x20534e44
     8f8:	65696c43 	.word	0x65696c43
     8fc:	2d20746e 	.word	0x2d20746e
     900:	6d697420 	.word	0x6d697420
     904:	25203a65 	.word	0x25203a65
     908:	70202c64 	.word	0x70202c64
     90c:	69646e65 	.word	0x69646e65
     910:	203a676e 	.word	0x203a676e
     914:	202c6425 	.word	0x202c6425
     918:	72727563 	.word	0x72727563
     91c:	3a746e65 	.word	0x3a746e65
     920:	2c642520 	.word	0x2c642520
     924:	746f7420 	.word	0x746f7420
     928:	203a6c61 	.word	0x203a6c61
     92c:	0a0d6425 	.word	0x0a0d6425
     930:	00000000 	.word	0x00000000
     934:	74736f48 	.word	0x74736f48
     938:	656d616e 	.word	0x656d616e
     93c:	25203d20 	.word	0x25203d20
     940:	0a0d2073 	.word	0x0a0d2073
     944:	656d6954 	.word	0x656d6954
     948:	2074756f 	.word	0x2074756f
     94c:	6425203d 	.word	0x6425203d
     950:	000a0d20 	.word	0x000a0d20
     954:	34765049 	.word	0x34765049
     958:	73253d20 	.word	0x73253d20
     95c:	00000a0d 	.word	0x00000a0d
     960:	36765049 	.word	0x36765049
     964:	25203d20 	.word	0x25203d20
     968:	000a0d73 	.word	0x000a0d73
     96c:	2d2d2d2d 	.word	0x2d2d2d2d
     970:	2d2d2d2d 	.word	0x2d2d2d2d
     974:	2d2d2d2d 	.word	0x2d2d2d2d
     978:	2d2d2d2d 	.word	0x2d2d2d2d
     97c:	2d2d2d2d 	.word	0x2d2d2d2d
     980:	2d2d2d2d 	.word	0x2d2d2d2d
     984:	2d2d2d2d 	.word	0x2d2d2d2d
     988:	2d2d2d2d 	.word	0x2d2d2d2d
     98c:	2d2d2d2d 	.word	0x2d2d2d2d
     990:	2d2d2d2d 	.word	0x2d2d2d2d
     994:	2d2d2d2d 	.word	0x2d2d2d2d
     998:	2d2d2d2d 	.word	0x2d2d2d2d
     99c:	2d2d2d2d 	.word	0x2d2d2d2d
     9a0:	00000a0d 	.word	0x00000a0d
     9a4:	44206f4e 	.word	0x44206f4e
     9a8:	4320534e 	.word	0x4320534e
     9ac:	6e65696c 	.word	0x6e65696c
     9b0:	61432074 	.word	0x61432074
     9b4:	20656863 	.word	0x20656863
     9b8:	72746e65 	.word	0x72746e65
     9bc:	20736569 	.word	0x20736569
     9c0:	00000a0d 	.word	0x00000a0d
     9c4:	61766e49 	.word	0x61766e49
     9c8:	2064696c 	.word	0x2064696c
     9cc:	75706e49 	.word	0x75706e49
     9d0:	6f432074 	.word	0x6f432074
     9d4:	6e616d6d 	.word	0x6e616d6d
     9d8:	5b3a2064 	.word	0x5b3a2064
     9dc:	20732520 	.word	0x20732520
     9e0:	0a0d205d 	.word	0x0a0d205d
     9e4:	00000000 	.word	0x00000000
     9e8:	676e6950 	.word	0x676e6950
     9ec:	6f64203a 	.word	0x6f64203a
     9f0:	202e656e 	.word	0x202e656e
     9f4:	746e6553 	.word	0x746e6553
     9f8:	20642520 	.word	0x20642520
     9fc:	75716572 	.word	0x75716572
     a00:	73747365 	.word	0x73747365
     a04:	6572202c 	.word	0x6572202c
     a08:	76696563 	.word	0x76696563
     a0c:	25206465 	.word	0x25206465
     a10:	65722064 	.word	0x65722064
     a14:	65696c70 	.word	0x65696c70
     a18:	0a0d2e73 	.word	0x0a0d2e73
     a1c:	00000000 	.word	0x00000000
     a20:	676e6950 	.word	0x676e6950
     a24:	61735520 	.word	0x61735520
     a28:	203a6567 	.word	0x203a6567
     a2c:	676e6970 	.word	0x676e6970
     a30:	74733c20 	.word	0x74733c20
     a34:	2f3e706f 	.word	0x2f3e706f
     a38:	6d616e3c 	.word	0x6d616e3c
     a3c:	64612f65 	.word	0x64612f65
     a40:	73657264 	.word	0x73657264
     a44:	3c203e73 	.word	0x3c203e73
     a48:	6e692069 	.word	0x6e692069
     a4c:	66726574 	.word	0x66726574
     a50:	3e656361 	.word	0x3e656361
     a54:	206e3c20 	.word	0x206e3c20
     a58:	6e69506e 	.word	0x6e69506e
     a5c:	203e7367 	.word	0x203e7367
     a60:	6d20743c 	.word	0x6d20743c
     a64:	72655073 	.word	0x72655073
     a68:	3e646f69 	.word	0x3e646f69
     a6c:	20733c20 	.word	0x20733c20
     a70:	657a6973 	.word	0x657a6973
     a74:	000a0d3e 	.word	0x000a0d3e
     a78:	706f7473 	.word	0x706f7473
     a7c:	00000000 	.word	0x00000000
     a80:	676e6950 	.word	0x676e6950
     a84:	6f63203a 	.word	0x6f63203a
     a88:	6e616d6d 	.word	0x6e616d6d
     a8c:	6e692064 	.word	0x6e692064
     a90:	6f727020 	.word	0x6f727020
     a94:	73657267 	.word	0x73657267
     a98:	52202e73 	.word	0x52202e73
     a9c:	79727465 	.word	0x79727465
     aa0:	74616c20 	.word	0x74616c20
     aa4:	0d2e7265 	.word	0x0d2e7265
     aa8:	0000000a 	.word	0x0000000a
     aac:	676e6950 	.word	0x676e6950
     ab0:	6f48203a 	.word	0x6f48203a
     ab4:	6e207473 	.word	0x6e207473
     ab8:	20656d61 	.word	0x20656d61
     abc:	206f6f74 	.word	0x206f6f74
     ac0:	676e6f6c 	.word	0x676e6f6c
     ac4:	6552202e 	.word	0x6552202e
     ac8:	2e797274 	.word	0x2e797274
     acc:	00000a0d 	.word	0x00000a0d
     ad0:	00000069 	.word	0x00000069
     ad4:	0000006e 	.word	0x0000006e
     ad8:	00000074 	.word	0x00000074
     adc:	00000073 	.word	0x00000073
     ae0:	676e6950 	.word	0x676e6950
     ae4:	6144203a 	.word	0x6144203a
     ae8:	73206174 	.word	0x73206174
     aec:	20657a69 	.word	0x20657a69
     af0:	206f6f74 	.word	0x206f6f74
     af4:	2e676962 	.word	0x2e676962
     af8:	78614d20 	.word	0x78614d20
     afc:	6425203a 	.word	0x6425203a
     b00:	6552202e 	.word	0x6552202e
     b04:	0d797274 	.word	0x0d797274
     b08:	0000000a 	.word	0x0000000a
     b0c:	676e6950 	.word	0x676e6950
     b10:	6e55203a 	.word	0x6e55203a
     b14:	776f6e6b 	.word	0x776f6e6b
     b18:	6170206e 	.word	0x6170206e
     b1c:	656d6172 	.word	0x656d6172
     b20:	0d726574 	.word	0x0d726574
     b24:	0000000a 	.word	0x0000000a
     b28:	676e6950 	.word	0x676e6950
     b2c:	6572203a 	.word	0x6572203a
     b30:	766c6f73 	.word	0x766c6f73
     b34:	20676e69 	.word	0x20676e69
     b38:	74736f68 	.word	0x74736f68
     b3c:	7325203a 	.word	0x7325203a
     b40:	00000a0d 	.word	0x00000a0d
     b44:	67617355 	.word	0x67617355
     b48:	64203a65 	.word	0x64203a65
     b4c:	73706368 	.word	0x73706368
     b50:	6f666e69 	.word	0x6f666e69
     b54:	6e693c20 	.word	0x6e693c20
     b58:	66726574 	.word	0x66726574
     b5c:	3e656361 	.word	0x3e656361
     b60:	000a0d20 	.word	0x000a0d20
     b64:	203a7845 	.word	0x203a7845
     b68:	70636864 	.word	0x70636864
     b6c:	666e6973 	.word	0x666e6973
     b70:	4950206f 	.word	0x4950206f
     b74:	49323343 	.word	0x49323343
     b78:	0d20544e 	.word	0x0d20544e
     b7c:	0000000a 	.word	0x0000000a
     b80:	6e6b6e55 	.word	0x6e6b6e55
     b84:	206e776f 	.word	0x206e776f
     b88:	65746e69 	.word	0x65746e69
     b8c:	63616672 	.word	0x63616672
     b90:	70732065 	.word	0x70732065
     b94:	66696365 	.word	0x66696365
     b98:	20646569 	.word	0x20646569
     b9c:	00000a0d 	.word	0x00000a0d
     ba0:	2043414d 	.word	0x2043414d
     ba4:	72646441 	.word	0x72646441
     ba8:	09737365 	.word	0x09737365
     bac:	41504909 	.word	0x41504909
     bb0:	65726464 	.word	0x65726464
     bb4:	09097373 	.word	0x09097373
     bb8:	616d6552 	.word	0x616d6552
     bbc:	6e696e69 	.word	0x6e696e69
     bc0:	61654c67 	.word	0x61654c67
     bc4:	69546573 	.word	0x69546573
     bc8:	0d20656d 	.word	0x0d20656d
     bcc:	0000000a 	.word	0x0000000a
     bd0:	200a0d20 	.word	0x200a0d20
     bd4:	6d206f4e 	.word	0x6d206f4e
     bd8:	2065726f 	.word	0x2065726f
     bdc:	72746e65 	.word	0x72746e65
     be0:	72702079 	.word	0x72702079
     be4:	6e657365 	.word	0x6e657365
     be8:	0a0d2074 	.word	0x0a0d2074
     bec:	00000000 	.word	0x00000000
     bf0:	00007325 	.word	0x00007325
     bf4:	20732509 	.word	0x20732509
     bf8:	00000000 	.word	0x00000000
     bfc:	20642509 	.word	0x20642509
     c00:	73636553 	.word	0x73636553
     c04:	00000a0d 	.word	0x00000a0d
     c08:	6e6b6e55 	.word	0x6e6b6e55
     c0c:	206e776f 	.word	0x206e776f
     c10:	70616568 	.word	0x70616568
     c14:	70797420 	.word	0x70797420
     c18:	55202e65 	.word	0x55202e65
     c1c:	203a6573 	.word	0x203a6573
     c20:	202c315b 	.word	0x202c315b
     c24:	0d5d6425 	.word	0x0d5d6425
     c28:	0000000a 	.word	0x0000000a
     c2c:	68206f4e 	.word	0x68206f4e
     c30:	20706165 	.word	0x20706165
     c34:	6f666e69 	.word	0x6f666e69
     c38:	69786520 	.word	0x69786520
     c3c:	20737473 	.word	0x20737473
     c40:	20726f66 	.word	0x20726f66
     c44:	65707974 	.word	0x65707974
     c48:	7325203a 	.word	0x7325203a
     c4c:	000a0d21 	.word	0x000a0d21
     c50:	70616548 	.word	0x70616548
     c54:	70797420 	.word	0x70797420
     c58:	25203a65 	.word	0x25203a65
     c5c:	49202e73 	.word	0x49202e73
     c60:	6974696e 	.word	0x6974696e
     c64:	63206c61 	.word	0x63206c61
     c68:	74616572 	.word	0x74616572
     c6c:	68206465 	.word	0x68206465
     c70:	20706165 	.word	0x20706165
     c74:	657a6973 	.word	0x657a6973
     c78:	6425203a 	.word	0x6425203a
     c7c:	74794220 	.word	0x74794220
     c80:	0a0d7365 	.word	0x0a0d7365
     c84:	00000000 	.word	0x00000000
     c88:	6f6c6c41 	.word	0x6f6c6c41
     c8c:	6c626163 	.word	0x6c626163
     c90:	6c622065 	.word	0x6c622065
     c94:	206b636f 	.word	0x206b636f
     c98:	70616568 	.word	0x70616568
     c9c:	7a697320 	.word	0x7a697320
     ca0:	25203a65 	.word	0x25203a65
     ca4:	79422064 	.word	0x79422064
     ca8:	0d736574 	.word	0x0d736574
     cac:	0000000a 	.word	0x0000000a
     cb0:	206c6c41 	.word	0x206c6c41
     cb4:	69617661 	.word	0x69617661
     cb8:	6c62616c 	.word	0x6c62616c
     cbc:	65682065 	.word	0x65682065
     cc0:	73207061 	.word	0x73207061
     cc4:	3a657a69 	.word	0x3a657a69
     cc8:	20642520 	.word	0x20642520
     ccc:	65747942 	.word	0x65747942
     cd0:	68202c73 	.word	0x68202c73
     cd4:	20686769 	.word	0x20686769
     cd8:	65746177 	.word	0x65746177
     cdc:	72616d72 	.word	0x72616d72
     ce0:	25203a6b 	.word	0x25203a6b
     ce4:	000a0d64 	.word	0x000a0d64
     ce8:	7473614c 	.word	0x7473614c
     cec:	61656820 	.word	0x61656820
     cf0:	72652070 	.word	0x72652070
     cf4:	3a726f72 	.word	0x3a726f72
     cf8:	25783020 	.word	0x25783020
     cfc:	000a0d78 	.word	0x000a0d78
     d00:	54206f4e 	.word	0x54206f4e
     d04:	65636172 	.word	0x65636172
     d08:	666e6920 	.word	0x666e6920
     d0c:	7865206f 	.word	0x7865206f
     d10:	73747369 	.word	0x73747369
     d14:	000a0d2e 	.word	0x000a0d2e
     d18:	63617453 	.word	0x63617453
     d1c:	7075206b 	.word	0x7075206b
     d20:	69616620 	.word	0x69616620
     d24:	0d64656c 	.word	0x0d64656c
     d28:	0000000a 	.word	0x0000000a
     d2c:	63617453 	.word	0x63617453
     d30:	7075206b 	.word	0x7075206b
     d34:	63757320 	.word	0x63757320
     d38:	64656563 	.word	0x64656563
     d3c:	0a0d6465 	.word	0x0a0d6465
     d40:	00000000 	.word	0x00000000
     d44:	67617355 	.word	0x67617355
     d48:	73203a65 	.word	0x73203a65
     d4c:	6b636174 	.word	0x6b636174
     d50:	70753c20 	.word	0x70753c20
     d54:	776f642f 	.word	0x776f642f
     d58:	3c203e6e 	.word	0x3c203e6e
     d5c:	73657270 	.word	0x73657270
     d60:	65767265 	.word	0x65767265
     d64:	000a0d3e 	.word	0x000a0d3e
     d68:	203a7845 	.word	0x203a7845
     d6c:	63617473 	.word	0x63617473
     d70:	6f64206b 	.word	0x6f64206b
     d74:	70206e77 	.word	0x70206e77
     d78:	65736572 	.word	0x65736572
     d7c:	0d657672 	.word	0x0d657672
     d80:	0000000a 	.word	0x0000000a
     d84:	00007075 	.word	0x00007075
     d88:	63617453 	.word	0x63617453
     d8c:	6c61206b 	.word	0x6c61206b
     d90:	64616572 	.word	0x64616572
     d94:	70752079 	.word	0x70752079
     d98:	000a0d21 	.word	0x000a0d21
     d9c:	6e727554 	.word	0x6e727554
     da0:	61745320 	.word	0x61745320
     da4:	64206b63 	.word	0x64206b63
     da8:	206e776f 	.word	0x206e776f
     dac:	20646e61 	.word	0x20646e61
     db0:	6e656874 	.word	0x6e656874
     db4:	21707520 	.word	0x21707520
     db8:	00000a0d 	.word	0x00000a0d
     dbc:	74736552 	.word	0x74736552
     dc0:	69747261 	.word	0x69747261
     dc4:	7420676e 	.word	0x7420676e
     dc8:	73206568 	.word	0x73206568
     dcc:	6b636174 	.word	0x6b636174
     dd0:	74697720 	.word	0x74697720
     dd4:	64252068 	.word	0x64252068
     dd8:	746e6920 	.word	0x746e6920
     ddc:	61667265 	.word	0x61667265
     de0:	73286563 	.word	0x73286563
     de4:	000a0d29 	.word	0x000a0d29
     de8:	6e776f64 	.word	0x6e776f64
     dec:	00000000 	.word	0x00000000
     df0:	63617453 	.word	0x63617453
     df4:	6f64206b 	.word	0x6f64206b
     df8:	203a6e77 	.word	0x203a6e77
     dfc:	6e6e6163 	.word	0x6e6e6163
     e00:	6720746f 	.word	0x6720746f
     e04:	61207465 	.word	0x61207465
     e08:	61747320 	.word	0x61747320
     e0c:	68206b63 	.word	0x68206b63
     e10:	6c646e61 	.word	0x6c646e61
     e14:	000a0d65 	.word	0x000a0d65
     e18:	63617453 	.word	0x63617453
     e1c:	6f64206b 	.word	0x6f64206b
     e20:	73206e77 	.word	0x73206e77
     e24:	65636375 	.word	0x65636375
     e28:	64656465 	.word	0x64656465
     e2c:	00000a0d 	.word	0x00000a0d
     e30:	67617355 	.word	0x67617355
     e34:	69203a65 	.word	0x69203a65
     e38:	693c2066 	.word	0x693c2066
     e3c:	7265746e 	.word	0x7265746e
     e40:	65636166 	.word	0x65636166
     e44:	643c203e 	.word	0x643c203e
     e48:	2f6e776f 	.word	0x2f6e776f
     e4c:	203e7075 	.word	0x203e7075
     e50:	00000a0d 	.word	0x00000a0d
     e54:	203a7845 	.word	0x203a7845
     e58:	50206669 	.word	0x50206669
     e5c:	32334349 	.word	0x32334349
     e60:	20544e49 	.word	0x20544e49
     e64:	6e776f64 	.word	0x6e776f64
     e68:	000a0d20 	.word	0x000a0d20
     e6c:	73696854 	.word	0x73696854
     e70:	746e6920 	.word	0x746e6920
     e74:	61667265 	.word	0x61667265
     e78:	61206563 	.word	0x61206563
     e7c:	6165726c 	.word	0x6165726c
     e80:	75207964 	.word	0x75207964
     e84:	000a0d70 	.word	0x000a0d70
     e88:	7265704f 	.word	0x7265704f
     e8c:	6f697461 	.word	0x6f697461
     e90:	6166206e 	.word	0x6166206e
     e94:	64656c69 	.word	0x64656c69
     e98:	6f4e202e 	.word	0x6f4e202e
     e9c:	6e6f6320 	.word	0x6e6f6320
     ea0:	75676966 	.word	0x75676966
     ea4:	69746172 	.word	0x69746172
     ea8:	0a0d6e6f 	.word	0x0a0d6e6f
     eac:	00000000 	.word	0x00000000
     eb0:	6c6c7566 	.word	0x6c6c7566
     eb4:	00000000 	.word	0x00000000
     eb8:	73696854 	.word	0x73696854
     ebc:	746e6920 	.word	0x746e6920
     ec0:	61667265 	.word	0x61667265
     ec4:	61206563 	.word	0x61206563
     ec8:	6165726c 	.word	0x6165726c
     ecc:	64207964 	.word	0x64207964
     ed0:	0d6e776f 	.word	0x0d6e776f
     ed4:	0000000a 	.word	0x0000000a
     ed8:	6e6f7257 	.word	0x6e6f7257
     edc:	61702067 	.word	0x61702067
     ee0:	656d6172 	.word	0x656d6172
     ee4:	20726574 	.word	0x20726574
     ee8:	63657073 	.word	0x63657073
     eec:	65696669 	.word	0x65696669
     ef0:	0a0d2064 	.word	0x0a0d2064
     ef4:	00000000 	.word	0x00000000
     ef8:	7265704f 	.word	0x7265704f
     efc:	6f697461 	.word	0x6f697461
     f00:	7573206e 	.word	0x7573206e
     f04:	73656363 	.word	0x73656363
     f08:	6c756673 	.word	0x6c756673
     f0c:	000a0d21 	.word	0x000a0d21
     f10:	7265704f 	.word	0x7265704f
     f14:	6f697461 	.word	0x6f697461
     f18:	6166206e 	.word	0x6166206e
     f1c:	64656c69 	.word	0x64656c69
     f20:	000a0d21 	.word	0x000a0d21
     f24:	67617355 	.word	0x67617355
     f28:	73203a65 	.word	0x73203a65
     f2c:	616d7465 	.word	0x616d7465
     f30:	693c2063 	.word	0x693c2063
     f34:	7265746e 	.word	0x7265746e
     f38:	65636166 	.word	0x65636166
     f3c:	783c203e 	.word	0x783c203e
     f40:	783a783a 	.word	0x783a783a
     f44:	783a783a 	.word	0x783a783a
     f48:	203e783a 	.word	0x203e783a
     f4c:	00000a0d 	.word	0x00000a0d
     f50:	203a7845 	.word	0x203a7845
     f54:	6d746573 	.word	0x6d746573
     f58:	50206361 	.word	0x50206361
     f5c:	32334349 	.word	0x32334349
     f60:	20544e49 	.word	0x20544e49
     f64:	623a6161 	.word	0x623a6161
     f68:	63633a62 	.word	0x63633a62
     f6c:	3a64643a 	.word	0x3a64643a
     f70:	663a6565 	.word	0x663a6565
     f74:	0a0d2066 	.word	0x0a0d2066
     f78:	00000000 	.word	0x00000000
     f7c:	76677261 	.word	0x76677261
     f80:	3a5d325b 	.word	0x3a5d325b
     f84:	0d732520 	.word	0x0d732520
     f88:	0000000a 	.word	0x0000000a
     f8c:	61766e49 	.word	0x61766e49
     f90:	2064696c 	.word	0x2064696c
     f94:	2043414d 	.word	0x2043414d
     f98:	72646461 	.word	0x72646461
     f9c:	20737365 	.word	0x20737365
     fa0:	69727473 	.word	0x69727473
     fa4:	0d20676e 	.word	0x0d20676e
     fa8:	0000000a 	.word	0x0000000a
     fac:	20746553 	.word	0x20746553
     fb0:	2043414d 	.word	0x2043414d
     fb4:	72646461 	.word	0x72646461
     fb8:	20737365 	.word	0x20737365
     fbc:	6c696166 	.word	0x6c696166
     fc0:	0a0d6465 	.word	0x0a0d6465
     fc4:	00000000 	.word	0x00000000
     fc8:	20746553 	.word	0x20746553
     fcc:	534f4942 	.word	0x534f4942
     fd0:	6d614e20 	.word	0x6d614e20
     fd4:	4b4f2065 	.word	0x4b4f2065
     fd8:	00000a0d 	.word	0x00000a0d
     fdc:	20746553 	.word	0x20746553
     fe0:	534f4942 	.word	0x534f4942
     fe4:	6d614e20 	.word	0x6d614e20
     fe8:	61662065 	.word	0x61662065
     fec:	64656c69 	.word	0x64656c69
     ff0:	00000a0d 	.word	0x00000a0d
     ff4:	67617355 	.word	0x67617355
     ff8:	73203a65 	.word	0x73203a65
     ffc:	69627465 	.word	0x69627465
    1000:	3c20736f 	.word	0x3c20736f
    1004:	65746e69 	.word	0x65746e69
    1008:	63616672 	.word	0x63616672
    100c:	3c203e65 	.word	0x3c203e65
    1010:	2e782e78 	.word	0x2e782e78
    1014:	3e782e78 	.word	0x3e782e78
    1018:	000a0d20 	.word	0x000a0d20
    101c:	203a7845 	.word	0x203a7845
    1020:	62746573 	.word	0x62746573
    1024:	20736f69 	.word	0x20736f69
    1028:	33434950 	.word	0x33434950
    102c:	544e4932 	.word	0x544e4932
    1030:	48434d20 	.word	0x48434d20
    1034:	414f4250 	.word	0x414f4250
    1038:	325f4452 	.word	0x325f4452
    103c:	0a0d2039 	.word	0x0a0d2039
    1040:	00000000 	.word	0x00000000
    1044:	20746553 	.word	0x20746553
    1048:	65746167 	.word	0x65746167
    104c:	20796177 	.word	0x20796177
    1050:	72646461 	.word	0x72646461
    1054:	20737365 	.word	0x20737365
    1058:	0a0d4b4f 	.word	0x0a0d4b4f
    105c:	00000000 	.word	0x00000000
    1060:	20746553 	.word	0x20746553
    1064:	65746167 	.word	0x65746167
    1068:	20796177 	.word	0x20796177
    106c:	72646461 	.word	0x72646461
    1070:	20737365 	.word	0x20737365
    1074:	6c696166 	.word	0x6c696166
    1078:	0a0d6465 	.word	0x0a0d6465
    107c:	00000000 	.word	0x00000000
    1080:	67617355 	.word	0x67617355
    1084:	73203a65 	.word	0x73203a65
    1088:	77677465 	.word	0x77677465
    108c:	6e693c20 	.word	0x6e693c20
    1090:	66726574 	.word	0x66726574
    1094:	3e656361 	.word	0x3e656361
    1098:	70693c20 	.word	0x70693c20
    109c:	362f3476 	.word	0x362f3476
    10a0:	64646120 	.word	0x64646120
    10a4:	73736572 	.word	0x73736572
    10a8:	763c203e 	.word	0x763c203e
    10ac:	64696c61 	.word	0x64696c61
    10b0:	656d6954 	.word	0x656d6954
    10b4:	0a0d203e 	.word	0x0a0d203e
    10b8:	00000000 	.word	0x00000000
    10bc:	203a7845 	.word	0x203a7845
    10c0:	67746573 	.word	0x67746573
    10c4:	49502077 	.word	0x49502077
    10c8:	49323343 	.word	0x49323343
    10cc:	3120544e 	.word	0x3120544e
    10d0:	312e3239 	.word	0x312e3239
    10d4:	302e3836 	.word	0x302e3836
    10d8:	0d20312e 	.word	0x0d20312e
    10dc:	0000000a 	.word	0x0000000a
    10e0:	61766e49 	.word	0x61766e49
    10e4:	2064696c 	.word	0x2064696c
    10e8:	61205049 	.word	0x61205049
    10ec:	65726464 	.word	0x65726464
    10f0:	73207373 	.word	0x73207373
    10f4:	6e697274 	.word	0x6e697274
    10f8:	0a0d2067 	.word	0x0a0d2067
    10fc:	00000000 	.word	0x00000000
    1100:	20746553 	.word	0x20746553
    1104:	61207069 	.word	0x61207069
    1108:	65726464 	.word	0x65726464
    110c:	4f207373 	.word	0x4f207373
    1110:	000a0d4b 	.word	0x000a0d4b
    1114:	20746553 	.word	0x20746553
    1118:	61207069 	.word	0x61207069
    111c:	65726464 	.word	0x65726464
    1120:	66207373 	.word	0x66207373
    1124:	656c6961 	.word	0x656c6961
    1128:	000a0d64 	.word	0x000a0d64
    112c:	67617355 	.word	0x67617355
    1130:	73203a65 	.word	0x73203a65
    1134:	70697465 	.word	0x70697465
    1138:	6e693c20 	.word	0x6e693c20
    113c:	66726574 	.word	0x66726574
    1140:	3e656361 	.word	0x3e656361
    1144:	70693c20 	.word	0x70693c20
    1148:	362f3476 	.word	0x362f3476
    114c:	64646120 	.word	0x64646120
    1150:	73736572 	.word	0x73736572
    1154:	693c203e 	.word	0x693c203e
    1158:	6d347670 	.word	0x6d347670
    115c:	2f6b7361 	.word	0x2f6b7361
    1160:	36767069 	.word	0x36767069
    1164:	65727020 	.word	0x65727020
    1168:	20786966 	.word	0x20786966
    116c:	3e6e656c 	.word	0x3e6e656c
    1170:	00000a0d 	.word	0x00000a0d
    1174:	203a7845 	.word	0x203a7845
    1178:	69746573 	.word	0x69746573
    117c:	49502070 	.word	0x49502070
    1180:	49323343 	.word	0x49323343
    1184:	3120544e 	.word	0x3120544e
    1188:	312e3239 	.word	0x312e3239
    118c:	302e3836 	.word	0x302e3836
    1190:	3220382e 	.word	0x3220382e
    1194:	322e3535 	.word	0x322e3535
    1198:	322e3535 	.word	0x322e3535
    119c:	302e3535 	.word	0x302e3535
    11a0:	000a0d20 	.word	0x000a0d20
    11a4:	73206f4e 	.word	0x73206f4e
    11a8:	20686375 	.word	0x20686375
    11ac:	65746e69 	.word	0x65746e69
    11b0:	63616672 	.word	0x63616672
    11b4:	73692065 	.word	0x73692065
    11b8:	0d707520 	.word	0x0d707520
    11bc:	0000000a 	.word	0x0000000a
    11c0:	61206e41 	.word	0x61206e41
    11c4:	65726464 	.word	0x65726464
    11c8:	73207373 	.word	0x73207373
    11cc:	69767265 	.word	0x69767265
    11d0:	69206563 	.word	0x69206563
    11d4:	6c612073 	.word	0x6c612073
    11d8:	64616572 	.word	0x64616572
    11dc:	75722079 	.word	0x75722079
    11e0:	6e696e6e 	.word	0x6e696e6e
    11e4:	53202e67 	.word	0x53202e67
    11e8:	20706f74 	.word	0x20706f74
    11ec:	50434844 	.word	0x50434844
    11f0:	435a202c 	.word	0x435a202c
    11f4:	202c4c4c 	.word	0x202c4c4c
    11f8:	2e637465 	.word	0x2e637465
    11fc:	72696620 	.word	0x72696620
    1200:	0a0d7473 	.word	0x0a0d7473
    1204:	00000000 	.word	0x00000000
    1208:	61766e49 	.word	0x61766e49
    120c:	2064696c 	.word	0x2064696c
    1210:	6d205049 	.word	0x6d205049
    1214:	206b7361 	.word	0x206b7361
    1218:	69727473 	.word	0x69727473
    121c:	0d20676e 	.word	0x0d20676e
    1220:	0000000a 	.word	0x0000000a
    1224:	63637573 	.word	0x63637573
    1228:	00737365 	.word	0x00737365
    122c:	6c696166 	.word	0x6c696166
    1230:	00006465 	.word	0x00006465
    1234:	67617355 	.word	0x67617355
    1238:	73203a65 	.word	0x73203a65
    123c:	6e647465 	.word	0x6e647465
    1240:	2f312073 	.word	0x2f312073
    1244:	693c2032 	.word	0x693c2032
    1248:	7265746e 	.word	0x7265746e
    124c:	65636166 	.word	0x65636166
    1250:	783c203e 	.word	0x783c203e
    1254:	782e782e 	.word	0x782e782e
    1258:	203e782e 	.word	0x203e782e
    125c:	00000a0d 	.word	0x00000a0d
    1260:	203a7845 	.word	0x203a7845
    1264:	64746573 	.word	0x64746573
    1268:	3120736e 	.word	0x3120736e
    126c:	68746520 	.word	0x68746520
    1270:	35322030 	.word	0x35322030
    1274:	35322e35 	.word	0x35322e35
    1278:	35322e35 	.word	0x35322e35
    127c:	20302e35 	.word	0x20302e35
    1280:	00000a0d 	.word	0x00000a0d
    1284:	6e6b6e55 	.word	0x6e6b6e55
    1288:	206e776f 	.word	0x206e776f
    128c:	20534e44 	.word	0x20534e44
    1290:	65646e69 	.word	0x65646e69
    1294:	000a0d78 	.word	0x000a0d78
    1298:	20746553 	.word	0x20746553
    129c:	20534e44 	.word	0x20534e44
    12a0:	61206425 	.word	0x61206425
    12a4:	65726464 	.word	0x65726464
    12a8:	25207373 	.word	0x25207373
    12ac:	000a0d73 	.word	0x000a0d73
    12b0:	20746f6e 	.word	0x20746f6e
    12b4:	65766967 	.word	0x65766967
    12b8:	0000006e 	.word	0x0000006e
    12bc:	656e6f4e 	.word	0x656e6f4e
    12c0:	00000000 	.word	0x00000000
    12c4:	6c696166 	.word	0x6c696166
    12c8:	00000000 	.word	0x00000000
    12cc:	67617355 	.word	0x67617355
    12d0:	25203a65 	.word	0x25203a65
    12d4:	693c2073 	.word	0x693c2073
    12d8:	7265746e 	.word	0x7265746e
    12dc:	65636166 	.word	0x65636166
    12e0:	6f3c203e 	.word	0x6f3c203e
    12e4:	666f2f6e 	.word	0x666f2f6e
    12e8:	65722f66 	.word	0x65722f66
    12ec:	2f77656e 	.word	0x2f77656e
    12f0:	75716572 	.word	0x75716572
    12f4:	2f747365 	.word	0x2f747365
    12f8:	6f666e69 	.word	0x6f666e69
    12fc:	0a0d203e 	.word	0x0a0d203e
    1300:	00000000 	.word	0x00000000
    1304:	656e6572 	.word	0x656e6572
    1308:	00000077 	.word	0x00000077
    130c:	75716572 	.word	0x75716572
    1310:	00747365 	.word	0x00747365
    1314:	75716552 	.word	0x75716552
    1318:	20747365 	.word	0x20747365
    131c:	6465656e 	.word	0x6465656e
    1320:	6e612073 	.word	0x6e612073
    1324:	20504920 	.word	0x20504920
    1328:	72646461 	.word	0x72646461
    132c:	0d737365 	.word	0x0d737365
    1330:	0000000a 	.word	0x0000000a
    1334:	6f666e69 	.word	0x6f666e69
    1338:	00000000 	.word	0x00000000
    133c:	50434844 	.word	0x50434844
    1340:	61747320 	.word	0x61747320
    1344:	3a737574 	.word	0x3a737574
    1348:	20642520 	.word	0x20642520
    134c:	64252028 	.word	0x64252028
    1350:	203d3d20 	.word	0x203d3d20
    1354:	6e756f42 	.word	0x6e756f42
    1358:	202c2964 	.word	0x202c2964
    135c:	656d6974 	.word	0x656d6974
    1360:	6425203a 	.word	0x6425203a
    1364:	00000a0d 	.word	0x00000a0d
    1368:	50434844 	.word	0x50434844
    136c:	61656c20 	.word	0x61656c20
    1370:	73206573 	.word	0x73206573
    1374:	74726174 	.word	0x74726174
    1378:	6425203a 	.word	0x6425203a
    137c:	7564202c 	.word	0x7564202c
    1380:	69746172 	.word	0x69746172
    1384:	203a6e6f 	.word	0x203a6e6f
    1388:	0d736425 	.word	0x0d736425
    138c:	0000000a 	.word	0x0000000a
    1390:	50434844 	.word	0x50434844
    1394:	6e657220 	.word	0x6e657220
    1398:	74207765 	.word	0x74207765
    139c:	3a656d69 	.word	0x3a656d69
    13a0:	2c642520 	.word	0x2c642520
    13a4:	62657220 	.word	0x62657220
    13a8:	20646e69 	.word	0x20646e69
    13ac:	656d6974 	.word	0x656d6974
    13b0:	6425203a 	.word	0x6425203a
    13b4:	00000a0d 	.word	0x00000a0d
    13b8:	50434844 	.word	0x50434844
    13bc:	64646120 	.word	0x64646120
    13c0:	73736572 	.word	0x73736572
    13c4:	7325203a 	.word	0x7325203a
    13c8:	00000a0d 	.word	0x00000a0d
    13cc:	50434844 	.word	0x50434844
    13d0:	72657320 	.word	0x72657320
    13d4:	3a726576 	.word	0x3a726576
    13d8:	0d732520 	.word	0x0d732520
    13dc:	0000000a 	.word	0x0000000a
    13e0:	50434844 	.word	0x50434844
    13e4:	6f6f6220 	.word	0x6f6f6220
    13e8:	616e2074 	.word	0x616e2074
    13ec:	203a656d 	.word	0x203a656d
    13f0:	0a0d7325 	.word	0x0a0d7325
    13f4:	00000000 	.word	0x00000000
    13f8:	50434844 	.word	0x50434844
    13fc:	6d695420 	.word	0x6d695420
    1400:	65732065 	.word	0x65732065
    1404:	72657672 	.word	0x72657672
    1408:	25203a73 	.word	0x25203a73
    140c:	25202c64 	.word	0x25202c64
    1410:	000a0d73 	.word	0x000a0d73
    1414:	50434844 	.word	0x50434844
    1418:	50544e20 	.word	0x50544e20
    141c:	72657320 	.word	0x72657320
    1420:	73726576 	.word	0x73726576
    1424:	6425203a 	.word	0x6425203a
    1428:	7325202c 	.word	0x7325202c
    142c:	00000a0d 	.word	0x00000a0d
    1430:	50434844 	.word	0x50434844
    1434:	6166203a 	.word	0x6166203a
    1438:	64656c69 	.word	0x64656c69
    143c:	206f7420 	.word	0x206f7420
    1440:	20746567 	.word	0x20746567
    1444:	6f666e69 	.word	0x6f666e69
    1448:	00000a0d 	.word	0x00000a0d
    144c:	25207325 	.word	0x25207325
    1450:	73252073 	.word	0x73252073
    1454:	00000a0d 	.word	0x00000a0d
    1458:	63637573 	.word	0x63637573
    145c:	66737365 	.word	0x66737365
    1460:	00006c75 	.word	0x00006c75
    1464:	6c696166 	.word	0x6c696166
    1468:	00216465 	.word	0x00216465
    146c:	00746573 	.word	0x00746573
    1470:	00746567 	.word	0x00746567
    1474:	61666544 	.word	0x61666544
    1478:	20746c75 	.word	0x20746c75
    147c:	65746e69 	.word	0x65746e69
    1480:	63616672 	.word	0x63616672
    1484:	65732065 	.word	0x65732065
    1488:	73252074 	.word	0x73252074
    148c:	00000a0d 	.word	0x00000a0d
    1490:	61666544 	.word	0x61666544
    1494:	20746c75 	.word	0x20746c75
    1498:	65746e69 	.word	0x65746e69
    149c:	63616672 	.word	0x63616672
    14a0:	73692065 	.word	0x73692065
    14a4:	7325203a 	.word	0x7325203a
    14a8:	00000a0d 	.word	0x00000a0d
    14ac:	67617355 	.word	0x67617355
    14b0:	64203a65 	.word	0x64203a65
    14b4:	656e6665 	.word	0x656e6665
    14b8:	65732074 	.word	0x65732074
    14bc:	65672f74 	.word	0x65672f74
    14c0:	693c2074 	.word	0x693c2074
    14c4:	7265746e 	.word	0x7265746e
    14c8:	65636166 	.word	0x65636166
    14cc:	000a0d3e 	.word	0x000a0d3e
    14d0:	203a7845 	.word	0x203a7845
    14d4:	6e666564 	.word	0x6e666564
    14d8:	73207465 	.word	0x73207465
    14dc:	65207465 	.word	0x65207465
    14e0:	0d306874 	.word	0x0d306874
    14e4:	0000000a 	.word	0x0000000a
    14e8:	00005055 	.word	0x00005055
    14ec:	4e574f44 	.word	0x4e574f44
    14f0:	00000000 	.word	0x00000000
    14f4:	64616552 	.word	0x64616552
    14f8:	00000079 	.word	0x00000079
    14fc:	20746f4e 	.word	0x20746f4e
    1500:	64616552 	.word	0x64616552
    1504:	00000079 	.word	0x00000079
    1508:	70636864 	.word	0x70636864
    150c:	00000073 	.word	0x00000073
    1510:	61666564 	.word	0x61666564
    1514:	20746c75 	.word	0x20746c75
    1518:	61205049 	.word	0x61205049
    151c:	65726464 	.word	0x65726464
    1520:	00007373 	.word	0x00007373
    1524:	67617355 	.word	0x67617355
    1528:	6e203a65 	.word	0x6e203a65
    152c:	6e697465 	.word	0x6e697465
    1530:	0a0d6f66 	.word	0x0a0d6f66
    1534:	00000000 	.word	0x00000000
    1538:	203a7845 	.word	0x203a7845
    153c:	6974656e 	.word	0x6974656e
    1540:	0d6f666e 	.word	0x0d6f666e
    1544:	0000000a 	.word	0x0000000a
    1548:	2d2d2d2d 	.word	0x2d2d2d2d
    154c:	2d2d2d2d 	.word	0x2d2d2d2d
    1550:	49202d2d 	.word	0x49202d2d
    1554:	7265746e 	.word	0x7265746e
    1558:	65636166 	.word	0x65636166
    155c:	73253c20 	.word	0x73253c20
    1560:	3e73252f 	.word	0x3e73252f
    1564:	2d2d2d20 	.word	0x2d2d2d20
    1568:	2d2d2d2d 	.word	0x2d2d2d2d
    156c:	202d2d2d 	.word	0x202d2d2d
    1570:	00000a0d 	.word	0x00000a0d
    1574:	65746e49 	.word	0x65746e49
    1578:	63616672 	.word	0x63616672
    157c:	73692065 	.word	0x73692065
    1580:	776f6420 	.word	0x776f6420
    1584:	000a0d6e 	.word	0x000a0d6e
    1588:	74736f48 	.word	0x74736f48
    158c:	6d614e20 	.word	0x6d614e20
    1590:	25203a65 	.word	0x25203a65
    1594:	202d2073 	.word	0x202d2073
    1598:	534e424e 	.word	0x534e424e
    159c:	73696420 	.word	0x73696420
    15a0:	656c6261 	.word	0x656c6261
    15a4:	0a0d2064 	.word	0x0a0d2064
    15a8:	00000000 	.word	0x00000000
    15ac:	34765049 	.word	0x34765049
    15b0:	64644120 	.word	0x64644120
    15b4:	73736572 	.word	0x73736572
    15b8:	7325203a 	.word	0x7325203a
    15bc:	00000a0d 	.word	0x00000a0d
    15c0:	6b73614d 	.word	0x6b73614d
    15c4:	7325203a 	.word	0x7325203a
    15c8:	00000a0d 	.word	0x00000a0d
    15cc:	65746147 	.word	0x65746147
    15d0:	3a796177 	.word	0x3a796177
    15d4:	0d732520 	.word	0x0d732520
    15d8:	0000000a 	.word	0x0000000a
    15dc:	31534e44 	.word	0x31534e44
    15e0:	7325203a 	.word	0x7325203a
    15e4:	00000a0d 	.word	0x00000a0d
    15e8:	32534e44 	.word	0x32534e44
    15ec:	7325203a 	.word	0x7325203a
    15f0:	00000a0d 	.word	0x00000a0d
    15f4:	2043414d 	.word	0x2043414d
    15f8:	72646441 	.word	0x72646441
    15fc:	3a737365 	.word	0x3a737365
    1600:	0d732520 	.word	0x0d732520
    1604:	0000000a 	.word	0x0000000a
    1608:	70636864 	.word	0x70636864
    160c:	20736920 	.word	0x20736920
    1610:	0a0d7325 	.word	0x0a0d7325
    1614:	00000000 	.word	0x00000000
    1618:	6b6e694c 	.word	0x6b6e694c
    161c:	20736920 	.word	0x20736920
    1620:	0a0d7325 	.word	0x0a0d7325
    1624:	00000000 	.word	0x00000000
    1628:	74617453 	.word	0x74617453
    162c:	203a7375 	.word	0x203a7375
    1630:	0a0d7325 	.word	0x0a0d7325
    1634:	00000000 	.word	0x00000000
    1638:	70636864 	.word	0x70636864
    163c:	00000000 	.word	0x00000000
    1640:	69207325 	.word	0x69207325
    1644:	4e4f2073 	.word	0x4e4f2073
    1648:	00000a0d 	.word	0x00000a0d
    164c:	676e6950 	.word	0x676e6950
    1650:	7277203a 	.word	0x7277203a
    1654:	20676e6f 	.word	0x20676e6f
    1658:	6c706572 	.word	0x6c706572
    165c:	65722079 	.word	0x65722079
    1660:	76696563 	.word	0x76696563
    1664:	202e6465 	.word	0x202e6465
    1668:	6b73614d 	.word	0x6b73614d
    166c:	7830203a 	.word	0x7830203a
    1670:	0d783225 	.word	0x0d783225
    1674:	0000000a 	.word	0x0000000a
    1678:	676e6950 	.word	0x676e6950
    167c:	6572203a 	.word	0x6572203a
    1680:	5b796c70 	.word	0x5b796c70
    1684:	205d6425 	.word	0x205d6425
    1688:	6d6f7266 	.word	0x6d6f7266
    168c:	3a732520 	.word	0x3a732520
    1690:	6d697420 	.word	0x6d697420
    1694:	203d2065 	.word	0x203d2065
    1698:	736d6425 	.word	0x736d6425
    169c:	00000a0d 	.word	0x00000a0d
    16a0:	676e6950 	.word	0x676e6950
    16a4:	4e44203a 	.word	0x4e44203a
    16a8:	61662053 	.word	0x61662053
    16ac:	72756c69 	.word	0x72756c69
    16b0:	6f662065 	.word	0x6f662065
    16b4:	73252072 	.word	0x73252072
    16b8:	00000a0d 	.word	0x00000a0d
    16bc:	20534e44 	.word	0x20534e44
    16c0:	6b6f6f4c 	.word	0x6b6f6f4c
    16c4:	203a7075 	.word	0x203a7075
    16c8:	20534e44 	.word	0x20534e44
    16cc:	6c696166 	.word	0x6c696166
    16d0:	20657275 	.word	0x20657275
    16d4:	20726f66 	.word	0x20726f66
    16d8:	202c7325 	.word	0x202c7325
    16dc:	3a727265 	.word	0x3a727265
    16e0:	0d642520 	.word	0x0d642520
    16e4:	0000000a 	.word	0x0000000a
    16e8:	20534e44 	.word	0x20534e44
    16ec:	6b6f6f4c 	.word	0x6b6f6f4c
    16f0:	203a7075 	.word	0x203a7075
    16f4:	75716572 	.word	0x75716572
    16f8:	20747365 	.word	0x20747365
    16fc:	656d6974 	.word	0x656d6974
    1700:	2e74756f 	.word	0x2e74756f
    1704:	00000a0d 	.word	0x00000a0d
    1708:	6b6f6f4c 	.word	0x6b6f6f4c
    170c:	41207075 	.word	0x41207075
    1710:	6577736e 	.word	0x6577736e
    1714:	0a0d3a72 	.word	0x0a0d3a72
    1718:	2d2d2d2d 	.word	0x2d2d2d2d
    171c:	2d2d2d2d 	.word	0x2d2d2d2d
    1720:	2d2d2d2d 	.word	0x2d2d2d2d
    1724:	2d2d2d2d 	.word	0x2d2d2d2d
    1728:	2d2d2d2d 	.word	0x2d2d2d2d
    172c:	0a0d2d2d 	.word	0x0a0d2d2d
    1730:	00000000 	.word	0x00000000
    1734:	4c206f4e 	.word	0x4c206f4e
    1738:	756b6f6f 	.word	0x756b6f6f
    173c:	6e652070 	.word	0x6e652070
    1740:	20797274 	.word	0x20797274
    1744:	20726f66 	.word	0x20726f66
    1748:	5d73255b 	.word	0x5d73255b
    174c:	00000a0d 	.word	0x00000a0d
    1750:	5d73255b 	.word	0x5d73255b
    1754:	49204120 	.word	0x49204120
    1758:	20347650 	.word	0x20347650
    175c:	72646441 	.word	0x72646441
    1760:	20737365 	.word	0x20737365
    1764:	6425203a 	.word	0x6425203a
    1768:	2e64252e 	.word	0x2e64252e
    176c:	252e6425 	.word	0x252e6425
    1770:	000a0d64 	.word	0x000a0d64
    1774:	5d73255b 	.word	0x5d73255b
    1778:	41414120 	.word	0x41414120
    177c:	50492041 	.word	0x50492041
    1780:	41203676 	.word	0x41203676
    1784:	65726464 	.word	0x65726464
    1788:	3a207373 	.word	0x3a207373
    178c:	0a0d7325 	.word	0x0a0d7325
    1790:	00000000 	.word	0x00000000
    1794:	7473203a 	.word	0x7473203a
    1798:	206b6361 	.word	0x206b6361
    179c:	6d6d6f63 	.word	0x6d6d6f63
    17a0:	73646e61 	.word	0x73646e61
    17a4:	00000000 	.word	0x00000000
    17a8:	69706374 	.word	0x69706374
    17ac:	00000070 	.word	0x00000070
    17b0:	6c696146 	.word	0x6c696146
    17b4:	74206465 	.word	0x74206465
    17b8:	7263206f 	.word	0x7263206f
    17bc:	65746165 	.word	0x65746165
    17c0:	50435420 	.word	0x50435420
    17c4:	43205049 	.word	0x43205049
    17c8:	616d6d6f 	.word	0x616d6d6f
    17cc:	0d73646e 	.word	0x0d73646e
    17d0:	0000000a 	.word	0x0000000a
    17d4:	49504354 	.word	0x49504354
    17d8:	6f632050 	.word	0x6f632050
    17dc:	6e616d6d 	.word	0x6e616d6d
    17e0:	74207364 	.word	0x74207364
    17e4:	206b7361 	.word	0x206b7361
    17e8:	69676572 	.word	0x69676572
    17ec:	61727473 	.word	0x61727473
    17f0:	6e6f6974 	.word	0x6e6f6974
    17f4:	69616620 	.word	0x69616620
    17f8:	0d64656c 	.word	0x0d64656c
    17fc:	0000000a 	.word	0x0000000a
    1800:	65746e69 	.word	0x65746e69
    1804:	6c616e72 	.word	0x6c616e72
    1808:	00000000 	.word	0x00000000
    180c:	6c6f6f70 	.word	0x6c6f6f70
    1810:	00000000 	.word	0x00000000
    1814:	65747865 	.word	0x65747865
    1818:	6c616e72 	.word	0x6c616e72
    181c:	00000000 	.word	0x00000000
    1820:	006c6564 	.word	0x006c6564
    1824:	6b6f6f6c 	.word	0x6b6f6f6c
    1828:	00007075 	.word	0x00007075
    182c:	6974656e 	.word	0x6974656e
    1830:	006f666e 	.word	0x006f666e
    1834:	6547203a 	.word	0x6547203a
    1838:	656e2074 	.word	0x656e2074
    183c:	726f7774 	.word	0x726f7774
    1840:	6e69206b 	.word	0x6e69206b
    1844:	6d726f66 	.word	0x6d726f66
    1848:	6f697461 	.word	0x6f697461
    184c:	0000006e 	.word	0x0000006e
    1850:	6e666564 	.word	0x6e666564
    1854:	00007465 	.word	0x00007465
    1858:	6553203a 	.word	0x6553203a
    185c:	65472f74 	.word	0x65472f74
    1860:	65642074 	.word	0x65642074
    1864:	6c756166 	.word	0x6c756166
    1868:	6e692074 	.word	0x6e692074
    186c:	66726574 	.word	0x66726574
    1870:	00656361 	.word	0x00656361
    1874:	4844203a 	.word	0x4844203a
    1878:	63205043 	.word	0x63205043
    187c:	6e65696c 	.word	0x6e65696c
    1880:	6f632074 	.word	0x6f632074
    1884:	6e616d6d 	.word	0x6e616d6d
    1888:	00007364 	.word	0x00007364
    188c:	7554203a 	.word	0x7554203a
    1890:	44206e72 	.word	0x44206e72
    1894:	20504348 	.word	0x20504348
    1898:	76726573 	.word	0x76726573
    189c:	6f207265 	.word	0x6f207265
    18a0:	666f2f6e 	.word	0x666f2f6e
    18a4:	00000066 	.word	0x00000066
    18a8:	6c6c637a 	.word	0x6c6c637a
    18ac:	00000000 	.word	0x00000000
    18b0:	7554203a 	.word	0x7554203a
    18b4:	5a206e72 	.word	0x5a206e72
    18b8:	204c4c43 	.word	0x204c4c43
    18bc:	6f2f6e6f 	.word	0x6f2f6e6f
    18c0:	00006666 	.word	0x00006666
    18c4:	64746573 	.word	0x64746573
    18c8:	0000736e 	.word	0x0000736e
    18cc:	6553203a 	.word	0x6553203a
    18d0:	4e442074 	.word	0x4e442074
    18d4:	64612053 	.word	0x64612053
    18d8:	73657264 	.word	0x73657264
    18dc:	00000073 	.word	0x00000073
    18e0:	69746573 	.word	0x69746573
    18e4:	00000070 	.word	0x00000070
    18e8:	6553203a 	.word	0x6553203a
    18ec:	50492074 	.word	0x50492074
    18f0:	64646120 	.word	0x64646120
    18f4:	73736572 	.word	0x73736572
    18f8:	646e6120 	.word	0x646e6120
    18fc:	73616d20 	.word	0x73616d20
    1900:	0000006b 	.word	0x0000006b
    1904:	67746573 	.word	0x67746573
    1908:	00000077 	.word	0x00000077
    190c:	6553203a 	.word	0x6553203a
    1910:	61472074 	.word	0x61472074
    1914:	61776574 	.word	0x61776574
    1918:	64612079 	.word	0x64612079
    191c:	73657264 	.word	0x73657264
    1920:	00000073 	.word	0x00000073
    1924:	62746573 	.word	0x62746573
    1928:	00736f69 	.word	0x00736f69
    192c:	6553203a 	.word	0x6553203a
    1930:	6f682074 	.word	0x6f682074
    1934:	73277473 	.word	0x73277473
    1938:	74654e20 	.word	0x74654e20
    193c:	534f4942 	.word	0x534f4942
    1940:	6d616e20 	.word	0x6d616e20
    1944:	00000065 	.word	0x00000065
    1948:	6d746573 	.word	0x6d746573
    194c:	00006361 	.word	0x00006361
    1950:	6553203a 	.word	0x6553203a
    1954:	414d2074 	.word	0x414d2074
    1958:	64612043 	.word	0x64612043
    195c:	73657264 	.word	0x73657264
    1960:	00000073 	.word	0x00000073
    1964:	00006669 	.word	0x00006669
    1968:	7242203a 	.word	0x7242203a
    196c:	20676e69 	.word	0x20676e69
    1970:	69206e61 	.word	0x69206e61
    1974:	7265746e 	.word	0x7265746e
    1978:	65636166 	.word	0x65636166
    197c:	2f707520 	.word	0x2f707520
    1980:	6e776f64 	.word	0x6e776f64
    1984:	00000000 	.word	0x00000000
    1988:	63617473 	.word	0x63617473
    198c:	0000006b 	.word	0x0000006b
    1990:	7453203a 	.word	0x7453203a
    1994:	206b6361 	.word	0x206b6361
    1998:	6e727574 	.word	0x6e727574
    199c:	2f6e6f20 	.word	0x2f6e6f20
    19a0:	0066666f 	.word	0x0066666f
    19a4:	70616568 	.word	0x70616568
    19a8:	6f666e69 	.word	0x6f666e69
    19ac:	00000000 	.word	0x00000000
    19b0:	6843203a 	.word	0x6843203a
    19b4:	206b6365 	.word	0x206b6365
    19b8:	70616568 	.word	0x70616568
    19bc:	61747320 	.word	0x61747320
    19c0:	00737574 	.word	0x00737574
    19c4:	70636864 	.word	0x70636864
    19c8:	666e6973 	.word	0x666e6973
    19cc:	0000006f 	.word	0x0000006f
    19d0:	6944203a 	.word	0x6944203a
    19d4:	616c7073 	.word	0x616c7073
    19d8:	48442079 	.word	0x48442079
    19dc:	53205043 	.word	0x53205043
    19e0:	65767265 	.word	0x65767265
    19e4:	654c2072 	.word	0x654c2072
    19e8:	20657361 	.word	0x20657361
    19ec:	61746544 	.word	0x61746544
    19f0:	00736c69 	.word	0x00736c69
    19f4:	676e6970 	.word	0x676e6970
    19f8:	00000000 	.word	0x00000000
    19fc:	6950203a 	.word	0x6950203a
    1a00:	6120676e 	.word	0x6120676e
    1a04:	5049206e 	.word	0x5049206e
    1a08:	64646120 	.word	0x64646120
    1a0c:	73736572 	.word	0x73736572
    1a10:	00000000 	.word	0x00000000
    1a14:	63736e64 	.word	0x63736e64
    1a18:	00000000 	.word	0x00000000
    1a1c:	4e44203a 	.word	0x4e44203a
    1a20:	6c632053 	.word	0x6c632053
    1a24:	746e6569 	.word	0x746e6569
    1a28:	6d6f6320 	.word	0x6d6f6320
    1a2c:	646e616d 	.word	0x646e616d
    1a30:	00000073 	.word	0x00000073
    1a34:	6963616d 	.word	0x6963616d
    1a38:	006f666e 	.word	0x006f666e
    1a3c:	6843203a 	.word	0x6843203a
    1a40:	206b6365 	.word	0x206b6365
    1a44:	2043414d 	.word	0x2043414d
    1a48:	74617473 	.word	0x74617473
    1a4c:	69747369 	.word	0x69747369
    1a50:	7363      	.short	0x7363
	...

Disassembly of section .text.TCPIP_TCP_Task%212:

00001a54 <TCPIP_TCP_Task>:
    return hTCP;		

}

void  TCPIP_TCP_Task(void)
{
    1a54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1a58:	b091      	sub	sp, #68	; 0x44
    if((sigPend & (TCPIP_MODULE_SIGNAL_INTERFACE_CHANGE)) != 0)
    { // interface address change occurred
        _TCPAbortSockets(ifMask, TCPIP_TCP_SIGNAL_IF_CHANGE); 
    }
#else
    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    1a5a:	210f      	movs	r1, #15
    1a5c:	200a      	movs	r0, #10
    1a5e:	f01e fb69 	bl	20134 <_TCPIPStackModuleSignalGet>
    1a62:	9003      	str	r0, [sp, #12]
#endif  // (_TCPIP_STACK_INTERFACE_CHANGE_SIGNALING != 0)

    if((sigPend & TCPIP_MODULE_SIGNAL_RX_PENDING) != 0)
    1a64:	f010 0f01 	tst.w	r0, #1
    1a68:	f040 852b 	bne.w	24c2 <__ext_attr_.config_00804000+0x4be>
    { //  RX signal occurred
        TCPIP_TCP_Process();
    }

    if((sigPend & TCPIP_MODULE_SIGNAL_TMO) != 0)
    1a6c:	9b03      	ldr	r3, [sp, #12]
    1a6e:	f013 0f02 	tst.w	r3, #2
    1a72:	f040 854a 	bne.w	250a <__ext_attr_.config_00804000+0x506>
    { // regular TMO occurred
        TCPIP_TCP_Tick();
    }
}
    1a76:	b011      	add	sp, #68	; 0x44
    1a78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 */
static __inline__ const IPV4_ADDR* TCPIP_IPV4_PacketGetSourceAddress(TCPIP_MAC_PACKET* pPkt);

static __inline__ const IPV4_ADDR* __attribute__((always_inline)) TCPIP_IPV4_PacketGetSourceAddress(TCPIP_MAC_PACKET* pPkt)
{
    return &((IPV4_HEADER*)pPkt->pNetLayer)->SourceAddress;
    1a7c:	f8d9 7018 	ldr.w	r7, [r9, #24]
    return &((IPV4_HEADER*)pPkt->pNetLayer)->DestAddress;
    1a80:	f107 0310 	add.w	r3, r7, #16
    1a84:	9307      	str	r3, [sp, #28]

    pPktSrcAdd = TCPIP_IPV4_PacketGetSourceAddress(pRxPkt);
    pPktDstAdd = TCPIP_IPV4_PacketGetDestAddress(pRxPkt);

    // Calculate IP pseudoheader checksum.
    pseudoHdr.SourceAddress.Val = pPktSrcAdd->Val;
    1a86:	68fb      	ldr	r3, [r7, #12]
    1a88:	930d      	str	r3, [sp, #52]	; 0x34
    pseudoHdr.DestAddress.Val = pPktDstAdd->Val;
    1a8a:	693b      	ldr	r3, [r7, #16]
    1a8c:	930e      	str	r3, [sp, #56]	; 0x38
    pseudoHdr.Zero	= 0;
    1a8e:	2200      	movs	r2, #0
    1a90:	f88d 203c 	strb.w	r2, [sp, #60]	; 0x3c
    pseudoHdr.Protocol = IP_PROT_TCP;
    1a94:	2306      	movs	r3, #6
    1a96:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
    return (((hLong & 0x000000ff) << 24) | ((hLong & 0x0000ff00) << 8) | ((hLong & 0x00ff0000) >> 8) | ((hLong & 0xff000000) >> 24));
}

static inline uint16_t __attribute__((always_inline)) TCPIP_Helper_htons(uint16_t hShort)
{
       return (((hShort) << 8) | ((hShort) >> 8));
    1a9a:	0a2b      	lsrs	r3, r5, #8
    1a9c:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    pseudoHdr.Length = TCPIP_Helper_ntohs(tcpTotLength);
    1aa0:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e

    calcChkSum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)&pseudoHdr, sizeof(pseudoHdr), 0);
    1aa4:	210c      	movs	r1, #12
    1aa6:	a80d      	add	r0, sp, #52	; 0x34
    1aa8:	f01a fbd6 	bl	1c258 <TCPIP_Helper_CalcIPChecksum>
    1aac:	43c3      	mvns	r3, r0
    1aae:	b29b      	uxth	r3, r3
    // Note: pseudoHdr length is multiple of 4!
    if((pRxPkt->pktFlags & TCPIP_MAC_PKT_FLAG_SPLIT) != 0)
    1ab0:	f8b9 2022 	ldrh.w	r2, [r9, #34]	; 0x22
    1ab4:	f012 0f04 	tst.w	r2, #4
    1ab8:	d033      	beq.n	1b22 <TCPIP_TCP_Task+0xce>
    {
        calcChkSum = TCPIP_Helper_PacketChecksum(pRxPkt, (uint8_t*)pTCPHdr, tcpTotLength, calcChkSum);
    1aba:	462a      	mov	r2, r5
    1abc:	4641      	mov	r1, r8
    1abe:	4648      	mov	r0, r9
    1ac0:	f019 f926 	bl	1ad10 <TCPIP_Helper_PacketChecksum>
    1ac4:	9004      	str	r0, [sp, #16]
    else
    {
        calcChkSum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pTCPHdr, tcpTotLength, calcChkSum);
    }

    if(calcChkSum != 0)
    1ac6:	9b04      	ldr	r3, [sp, #16]
    1ac8:	2b00      	cmp	r3, #0
    1aca:	f040 8663 	bne.w	2794 <__ext_attr_.config_00804000+0x790>
    {   // discard packet
        return TCPIP_MAC_PKT_ACK_CHKSUM_ERR;
    }


	_TcpSwapHeader(pTCPHdr);
    1ace:	4640      	mov	r0, r8
    1ad0:	f01a fef0 	bl	1c8b4 <_TcpSwapHeader>
    TCPIP_TCP_CheckRxPkt(pTCPHdr);

	// Skip over options to retrieve data bytes
	optionsSize = (pTCPHdr->DataOffset.Val << 2) - sizeof(*pTCPHdr);
    1ad4:	f898 b00c 	ldrb.w	fp, [r8, #12]
    1ad8:	ea4f 1b1b 	mov.w	fp, fp, lsr #4
    1adc:	ea4f 038b 	mov.w	r3, fp, lsl #2
    1ae0:	9306      	str	r3, [sp, #24]
	TCP_SOCKET hTCP;
	uint16_t hash;
    TCB_STUB* pSkt, *partialSkt;
    TCPIP_NET_IF* pPktIf;

    TCP_HEADER* h = (TCP_HEADER*)pRxPkt->pTransportLayer;
    1ae2:	f8d9 b01c 	ldr.w	fp, [r9, #28]
    pPktIf = (TCPIP_NET_IF*)pRxPkt->pktIf;

	// Prevent connections on invalid port 0
	if(h->DestPort == 0)
    1ae6:	f8bb 2002 	ldrh.w	r2, [fp, #2]
    1aea:	2a00      	cmp	r2, #0
    1aec:	f000 8655 	beq.w	279a <__ext_attr_.config_00804000+0x796>
            break;  // OK
#endif  // defined (TCPIP_STACK_USE_IPV6)

#if defined (TCPIP_STACK_USE_IPV4)
        case IP_ADDRESS_TYPE_IPV4:
            hash = (((IPV4_ADDR *)remoteIP)->w[1] + ((IPV4_ADDR *)remoteIP)->w[0] + h->SourcePort) ^ h->DestPort;
    1af0:	89fe      	ldrh	r6, [r7, #14]
    1af2:	89bb      	ldrh	r3, [r7, #12]
    1af4:	441e      	add	r6, r3
    1af6:	f8bb 3000 	ldrh.w	r3, [fp]
    1afa:	441e      	add	r6, r3
    1afc:	4056      	eors	r6, r2
    1afe:	b2b6      	uxth	r6, r6
            return 0;  // shouldn't happen
    }

	// Loop through all sockets looking for a socket that is expecting this 
	// packet or can handle it.
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    1b00:	4bcc      	ldr	r3, [pc, #816]	; (1e34 <TCPIP_TCP_Task+0x3e0>)
    1b02:	f8d3 c000 	ldr.w	ip, [r3]
    1b06:	f1bc 0f00 	cmp.w	ip, #0
    1b0a:	f000 8649 	beq.w	27a0 <__ext_attr_.config_00804000+0x79c>
    pPktIf = (TCPIP_NET_IF*)pRxPkt->pktIf;
    1b0e:	f8d9 e028 	ldr.w	lr, [r9, #40]	; 0x28
    {
        pSkt = TCBStubs[hTCP];
    1b12:	4bc9      	ldr	r3, [pc, #804]	; (1e38 <TCPIP_TCP_Task+0x3e4>)
    1b14:	681b      	ldr	r3, [r3, #0]
    1b16:	9305      	str	r3, [sp, #20]
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    1b18:	2300      	movs	r3, #0
	partialSkt = 0;
    1b1a:	469a      	mov	sl, r3
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    1b1c:	4619      	mov	r1, r3
    1b1e:	4610      	mov	r0, r2
    1b20:	e00f      	b.n	1b42 <TCPIP_TCP_Task+0xee>
        calcChkSum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pTCPHdr, tcpTotLength, calcChkSum);
    1b22:	461a      	mov	r2, r3
    1b24:	4629      	mov	r1, r5
    1b26:	4640      	mov	r0, r8
    1b28:	f01a fb96 	bl	1c258 <TCPIP_Helper_CalcIPChecksum>
    1b2c:	9004      	str	r0, [sp, #16]
    1b2e:	e7ca      	b.n	1ac6 <TCPIP_TCP_Task+0x72>
            bool found = false;

            if(pSkt->smState == TCPIP_TCP_STATE_LISTEN)
            {
                // For listening ports, check if this is the correct port
                if(pSkt->remoteHash == h->DestPort && partialSkt == 0)
    1b30:	f8b4 206a 	ldrh.w	r2, [r4, #106]	; 0x6a
    1b34:	4282      	cmp	r2, r0
    1b36:	d02f      	beq.n	1b98 <TCPIP_TCP_Task+0x144>
    1b38:	3301      	adds	r3, #1
    1b3a:	b21b      	sxth	r3, r3
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    1b3c:	4619      	mov	r1, r3
    1b3e:	4563      	cmp	r3, ip
    1b40:	d22f      	bcs.n	1ba2 <TCPIP_TCP_Task+0x14e>
        pSkt = TCBStubs[hTCP];
    1b42:	9a05      	ldr	r2, [sp, #20]
    1b44:	f852 4021 	ldr.w	r4, [r2, r1, lsl #2]
        if(pSkt == 0 || pSkt->smState == TCPIP_TCP_STATE_CLIENT_WAIT_CONNECT)
    1b48:	2c00      	cmp	r4, #0
    1b4a:	d0f5      	beq.n	1b38 <TCPIP_TCP_Task+0xe4>
    1b4c:	f894 206e 	ldrb.w	r2, [r4, #110]	; 0x6e
    1b50:	2a0b      	cmp	r2, #11
    1b52:	d0f1      	beq.n	1b38 <TCPIP_TCP_Task+0xe4>
        if( (pSkt->addType == IP_ADDRESS_TYPE_ANY || pSkt->addType == addressType) &&
    1b54:	f894 106f 	ldrb.w	r1, [r4, #111]	; 0x6f
    1b58:	2901      	cmp	r1, #1
    1b5a:	d8ed      	bhi.n	1b38 <TCPIP_TCP_Task+0xe4>
                (pSkt->pSktNet == 0 || pSkt->pSktNet == pPktIf) )
    1b5c:	6c21      	ldr	r1, [r4, #64]	; 0x40
        if( (pSkt->addType == IP_ADDRESS_TYPE_ANY || pSkt->addType == addressType) &&
    1b5e:	b109      	cbz	r1, 1b64 <TCPIP_TCP_Task+0x110>
                (pSkt->pSktNet == 0 || pSkt->pSktNet == pPktIf) )
    1b60:	458e      	cmp	lr, r1
    1b62:	d1e9      	bne.n	1b38 <TCPIP_TCP_Task+0xe4>
            if(pSkt->smState == TCPIP_TCP_STATE_LISTEN)
    1b64:	2a00      	cmp	r2, #0
    1b66:	d0e3      	beq.n	1b30 <TCPIP_TCP_Task+0xdc>
                {
                    partialSkt = pSkt;
                }
                continue;
            }
            else if(pSkt->remoteHash != hash)
    1b68:	f8b4 206a 	ldrh.w	r2, [r4, #106]	; 0x6a
    1b6c:	42b2      	cmp	r2, r6
    1b6e:	d1e3      	bne.n	1b38 <TCPIP_TCP_Task+0xe4>
            {// Ignore if the hash doesn't match
                continue;
            }

            while(	h->DestPort == pSkt->localPort && h->SourcePort == pSkt->remotePort )  
    1b70:	f8db 1000 	ldr.w	r1, [fp]
    1b74:	6da2      	ldr	r2, [r4, #88]	; 0x58
    1b76:	4291      	cmp	r1, r2
    1b78:	d1de      	bne.n	1b38 <TCPIP_TCP_Task+0xe4>
#endif  // defined (TCPIP_STACK_USE_IPV6)

#if defined (TCPIP_STACK_USE_IPV4)
                if (addressType == IP_ADDRESS_TYPE_IPV4)
                {
                    if (pSkt->destAddress.Val == ((IPV4_ADDR *)remoteIP)->Val)
    1b7a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    1b7c:	68fa      	ldr	r2, [r7, #12]
    1b7e:	4291      	cmp	r1, r2
    1b80:	d1da      	bne.n	1b38 <TCPIP_TCP_Task+0xe4>
                break;
            }

            if(found)
            { 
                pSkt->addType = addressType;
    1b82:	2101      	movs	r1, #1
    1b84:	f884 106f 	strb.w	r1, [r4, #111]	; 0x6f
    pSkt->pSktNet = pNet;
    1b88:	f8c4 e040 	str.w	lr, [r4, #64]	; 0x40
    _TCPSetSourceAddress(pSkt, pSkt->addType, srcAddress);
    1b8c:	9a07      	ldr	r2, [sp, #28]
    1b8e:	4620      	mov	r0, r4
    1b90:	f01e fec3 	bl	2091a <_TCPSetSourceAddress>
        pSkt = TCBStubs[hTCP];
    1b94:	46a2      	mov	sl, r4
    1b96:	e021      	b.n	1bdc <TCPIP_TCP_Task+0x188>
    1b98:	f1ba 0f00 	cmp.w	sl, #0
    1b9c:	bf08      	it	eq
    1b9e:	46a2      	moveq	sl, r4
    1ba0:	e7ca      	b.n	1b38 <TCPIP_TCP_Task+0xe4>

	// If there is a partial match, then a listening socket is currently 
	// available.  Set up the extended TCB with the info needed 
	// to establish a connection and return this socket to the 
	// caller.
	while(partialSkt != 0)
    1ba2:	f1ba 0f00 	cmp.w	sl, #0
    1ba6:	d07f      	beq.n	1ca8 <TCPIP_TCP_Task+0x254>
#endif  // defined (TCPIP_STACK_USE_IPV6)

#if defined (TCPIP_STACK_USE_IPV4)
            case IP_ADDRESS_TYPE_IPV4:
                // IPv4 lazy allocation
                pSkt->destAddress.Val = ((IPV4_ADDR *)remoteIP)->Val;
    1ba8:	68fb      	ldr	r3, [r7, #12]
    1baa:	f8ca 3038 	str.w	r3, [sl, #56]	; 0x38
            default:    // shouldn't happen
                break;
        }

        // success; bind it
        pSkt->addType = addressType;
    1bae:	2101      	movs	r1, #1
    1bb0:	f88a 106f 	strb.w	r1, [sl, #111]	; 0x6f
    pSkt->pSktNet = pNet;
    1bb4:	f8ca e040 	str.w	lr, [sl, #64]	; 0x40
    _TCPSetSourceAddress(pSkt, pSkt->addType, srcAddress);
    1bb8:	9a07      	ldr	r2, [sp, #28]
    1bba:	4650      	mov	r0, sl
    1bbc:	f01e fead 	bl	2091a <_TCPSetSourceAddress>
        _TcpSocketBind(pSkt, pPktIf, (IP_MULTI_ADDRESS*)localIP);
        pSkt->remoteHash = hash;
    1bc0:	f8aa 606a 	strh.w	r6, [sl, #106]	; 0x6a
        pSkt->remotePort = h->SourcePort;
    1bc4:	f8bb 3000 	ldrh.w	r3, [fp]
    1bc8:	f8aa 3058 	strh.w	r3, [sl, #88]	; 0x58
        pSkt->localPort = h->DestPort;
    1bcc:	f8bb 3002 	ldrh.w	r3, [fp, #2]
    1bd0:	f8aa 305a 	strh.w	r3, [sl, #90]	; 0x5a
        pSkt->txUnackedTail	= pSkt->txStart;
    1bd4:	f8da 3000 	ldr.w	r3, [sl]
    1bd8:	f8ca 3010 	str.w	r3, [sl, #16]
        pRxPkt->pDSeg->segLen -=  optionsSize + sizeof(*pTCPHdr);    
    1bdc:	f8d9 2010 	ldr.w	r2, [r9, #16]
    1be0:	8993      	ldrh	r3, [r2, #12]
    1be2:	9906      	ldr	r1, [sp, #24]
    1be4:	1a5b      	subs	r3, r3, r1
    1be6:	8193      	strh	r3, [r2, #12]
    uint16_t nCopiedBytes;
    uint8_t* newRxHead;


     
    localHeaderFlags = h->Flags.byte;
    1be8:	f898 400d 	ldrb.w	r4, [r8, #13]
    localAckNumber = h->AckNumber;
    1bec:	f8d8 7008 	ldr.w	r7, [r8, #8]
    localSeqNumber = h->SeqNumber;
    1bf0:	f8d8 6004 	ldr.w	r6, [r8, #4]

    // We received a packet, reset the keep alive timer and count
    if(pSkt->Flags.keepAlive)
    1bf4:	f89a 3037 	ldrb.w	r3, [sl, #55]	; 0x37
    1bf8:	f013 0f40 	tst.w	r3, #64	; 0x40
    1bfc:	d158      	bne.n	1cb0 <TCPIP_TCP_Task+0x25c>
        {
            pSkt->eventTime = SYS_TMR_TickCountGet() + (pSkt->keepAliveTmo * SYS_TMR_TickCounterFrequencyGet())/1000;
        }
    }

    pSkt->flags.ackSent = 0;   // clear the ACK already sent
    1bfe:	f89a 306d 	ldrb.w	r3, [sl, #109]	; 0x6d
    1c02:	f36f 0300 	bfc	r3, #0, #1
    1c06:	f88a 306d 	strb.w	r3, [sl, #109]	; 0x6d

    // Handle TCPIP_TCP_STATE_LISTEN and TCPIP_TCP_STATE_SYN_SENT states
    // Both of these states will return, so code following this 
    // state machine need not check explicitly for these two 
    // states.
    switch(pSkt->smState)
    1c0a:	f89a 306e 	ldrb.w	r3, [sl, #110]	; 0x6e
    1c0e:	2b00      	cmp	r3, #0
    1c10:	d069      	beq.n	1ce6 <TCPIP_TCP_Task+0x292>
    1c12:	2b01      	cmp	r3, #1
    1c14:	f000 80b6 	beq.w	1d84 <TCPIP_TCP_Task+0x330>
        _TcpHandleSeg(pSkt, pTCPHdr, tcpTotLength - optionsSize - sizeof(*pTCPHdr), pRxPkt, &sktEvent);
    1c18:	3514      	adds	r5, #20
    1c1a:	9a06      	ldr	r2, [sp, #24]
    1c1c:	eba5 0b02 	sub.w	fp, r5, r2
    1c20:	fa1f fb8b 	uxth.w	fp, fp
    1c24:	f1ab 0214 	sub.w	r2, fp, #20
    1c28:	b292      	uxth	r2, r2
    1c2a:	9206      	str	r2, [sp, #24]

    //
    // First: check the sequence number
    //
    wSegmentLength = len = tcpLen;
    if(localHeaderFlags & FIN)
    1c2c:	f014 0201 	ands.w	r2, r4, #1
    1c30:	9207      	str	r2, [sp, #28]
    {
        wSegmentLength++;
    1c32:	bf1a      	itte	ne
    1c34:	f1ab 0b13 	subne.w	fp, fp, #19
    1c38:	fa1f f28b 	uxthne.w	r2, fp
    wSegmentLength = len = tcpLen;
    1c3c:	9a06      	ldreq	r2, [sp, #24]
    1c3e:	9205      	str	r2, [sp, #20]
    }
    if(localHeaderFlags & SYN)
    1c40:	f014 0f02 	tst.w	r4, #2
    1c44:	d003      	beq.n	1c4e <TCPIP_TCP_Task+0x1fa>
    {
        wSegmentLength++;
    1c46:	9a05      	ldr	r2, [sp, #20]
    1c48:	3201      	adds	r2, #1
    1c4a:	b292      	uxth	r2, r2
    1c4c:	9205      	str	r2, [sp, #20]
    }

    // Calculate the RX FIFO space
    if(pSkt->rxHead >= pSkt->rxTail)
    1c4e:	f8da 501c 	ldr.w	r5, [sl, #28]
    1c52:	f8da 2020 	ldr.w	r2, [sl, #32]
    1c56:	4295      	cmp	r5, r2
    1c58:	f0c0 80e5 	bcc.w	1e26 <TCPIP_TCP_Task+0x3d2>
    {
        wFreeSpace = (pSkt->rxEnd - pSkt->rxStart) - (pSkt->rxHead - pSkt->rxTail);
    1c5c:	f8da 1018 	ldr.w	r1, [sl, #24]
    1c60:	f8da 0014 	ldr.w	r0, [sl, #20]
    1c64:	1a09      	subs	r1, r1, r0
    1c66:	eba5 0b02 	sub.w	fp, r5, r2
    1c6a:	eba1 0b0b 	sub.w	fp, r1, fp
    1c6e:	fa1f fb8b 	uxth.w	fp, fp
    {
        wFreeSpace = pSkt->rxTail - pSkt->rxHead - 1;
    }

    // Calculate the number of bytes ahead of our head pointer this segment skips
    lMissingBytes = localSeqNumber - pSkt->RemoteSEQ;
    1c72:	f8da 2050 	ldr.w	r2, [sl, #80]	; 0x50
    1c76:	1ab5      	subs	r5, r6, r2
    wMissingBytes = lMissingBytes; 

    // Run TCP acceptability tests to verify that this packet has a valid sequence number
    bSegmentAcceptable = false;
    if(wSegmentLength)
    1c78:	9a05      	ldr	r2, [sp, #20]
    1c7a:	2a00      	cmp	r2, #0
    1c7c:	f000 80f0 	beq.w	1e60 <TCPIP_TCP_Task+0x40c>
    {
        // Check to see if we have free space, and if so, if any of the data falls within the freespace
        if(wFreeSpace)
    1c80:	f1bb 0f00 	cmp.w	fp, #0
    1c84:	f000 80e2 	beq.w	1e4c <TCPIP_TCP_Task+0x3f8>
        {
            // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
            if((lMissingBytes >= 0) && (wFreeSpace > (uint32_t)lMissingBytes))
    1c88:	2d00      	cmp	r5, #0
    1c8a:	f2c0 80d9 	blt.w	1e40 <TCPIP_TCP_Task+0x3ec>
    1c8e:	455d      	cmp	r5, fp
    1c90:	f0c0 80eb 	bcc.w	1e6a <TCPIP_TCP_Task+0x416>
                bSegmentAcceptable = true;
            }
            else
            {
                // RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND
                if((lMissingBytes + (int32_t)wSegmentLength > 0) && (lMissingBytes <= (int32_t)(wFreeSpace - wSegmentLength)))
    1c94:	9a05      	ldr	r2, [sp, #20]
    1c96:	ebab 0202 	sub.w	r2, fp, r2
                {
                    bSegmentAcceptable = true;
                }
            }

            if((lMissingBytes < (int32_t)wFreeSpace) && (wMissingBytes + (int32_t)wSegmentLength > 0))
    1c9a:	45ab      	cmp	fp, r5
    1c9c:	f300 80e5 	bgt.w	1e6a <TCPIP_TCP_Task+0x416>
                bSegmentAcceptable = true;
            }
        }
    }

    if(!bSegmentAcceptable)
    1ca0:	4295      	cmp	r5, r2
    1ca2:	f340 80e2 	ble.w	1e6a <TCPIP_TCP_Task+0x416>
    1ca6:	e0d1      	b.n	1e4c <TCPIP_TCP_Task+0x3f8>
            ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    1ca8:	f06f 010e 	mvn.w	r1, #14
    1cac:	f000 bc05 	b.w	24ba <__ext_attr_.config_00804000+0x4b6>
        pSkt->keepAliveCount = 0;
    1cb0:	2300      	movs	r3, #0
    1cb2:	f88a 3071 	strb.w	r3, [sl, #113]	; 0x71
        if(!pSkt->Flags.bTimerEnabled)
    1cb6:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    1cba:	f013 0f02 	tst.w	r3, #2
    1cbe:	d19e      	bne.n	1bfe <TCPIP_TCP_Task+0x1aa>
            pSkt->eventTime = SYS_TMR_TickCountGet() + (pSkt->keepAliveTmo * SYS_TMR_TickCounterFrequencyGet())/1000;
    1cc0:	f020 fabc 	bl	2223c <SYS_TMR_TickCountGet>
    1cc4:	4683      	mov	fp, r0
    1cc6:	f8ba 3068 	ldrh.w	r3, [sl, #104]	; 0x68
    1cca:	9305      	str	r3, [sp, #20]
    1ccc:	f020 fade 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    1cd0:	9b05      	ldr	r3, [sp, #20]
    1cd2:	fb00 f003 	mul.w	r0, r0, r3
    1cd6:	4b59      	ldr	r3, [pc, #356]	; (1e3c <TCPIP_TCP_Task+0x3e8>)
    1cd8:	fba3 3000 	umull	r3, r0, r3, r0
    1cdc:	eb0b 1090 	add.w	r0, fp, r0, lsr #6
    1ce0:	f8ca 0024 	str.w	r0, [sl, #36]	; 0x24
    1ce4:	e78b      	b.n	1bfe <TCPIP_TCP_Task+0x1aa>
            if(localHeaderFlags & RST)
    1ce6:	f014 0f04 	tst.w	r4, #4
    1cea:	d135      	bne.n	1d58 <TCPIP_TCP_Task+0x304>
            if(localHeaderFlags & ACK)
    1cec:	f014 0f10 	tst.w	r4, #16
    1cf0:	d137      	bne.n	1d62 <TCPIP_TCP_Task+0x30e>
            if(localHeaderFlags & SYN)
    1cf2:	f014 0f02 	tst.w	r4, #2
    1cf6:	d040      	beq.n	1d7a <TCPIP_TCP_Task+0x326>
                pSkt->RemoteSEQ = localSeqNumber + 1;
    1cf8:	3601      	adds	r6, #1
    1cfa:	f8ca 6050 	str.w	r6, [sl, #80]	; 0x50
                pSkt->wRemoteMSS = _GetMaxSegSizeOption(h);
    1cfe:	4640      	mov	r0, r8
    1d00:	f016 f94a 	bl	17f98 <_GetMaxSegSizeOption>
    1d04:	f8aa 0062 	strh.w	r0, [sl, #98]	; 0x62
                _TCPSetHalfFlushFlag(pSkt);
    1d08:	4650      	mov	r0, sl
    1d0a:	f01e f84b 	bl	1fda4 <_TCPSetHalfFlushFlag>
                _TcpSend(pSkt, SYN | ACK, SENDTCP_RESET_TIMERS);
    1d0e:	2201      	movs	r2, #1
    1d10:	2112      	movs	r1, #18
    1d12:	4650      	mov	r0, sl
    1d14:	f006 f914 	bl	7f40 <_TcpSend>
    pSkt->smState = newState;
    1d18:	2302      	movs	r3, #2
    1d1a:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    1d1e:	2000      	movs	r0, #0
    1d20:	f021 fd28 	bl	23774 <OSAL_CRIT_Enter>
    *pSigHandler = pSkt->sigHandler;
    1d24:	f8da 5074 	ldr.w	r5, [sl, #116]	; 0x74
    *pSigParam = pSkt->sigParam;
    1d28:	f8da 6078 	ldr.w	r6, [sl, #120]	; 0x78
    uint16_t sigMask = pSkt->sigMask;
    1d2c:	f8ba 4072 	ldrh.w	r4, [sl, #114]	; 0x72
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
    1d30:	4601      	mov	r1, r0
    1d32:	2000      	movs	r0, #0
    1d34:	f021 fe58 	bl	239e8 <OSAL_CRIT_Leave>
        if((sktEvent &= sigMask) != 0)
    1d38:	9b04      	ldr	r3, [sp, #16]
    1d3a:	ea14 0203 	ands.w	r2, r4, r3
    1d3e:	f000 8532 	beq.w	27a6 <__ext_attr_.config_00804000+0x7a2>
            if(sigHandler != 0)
    1d42:	2d00      	cmp	r5, #0
    1d44:	f000 8531 	beq.w	27aa <__ext_attr_.config_00804000+0x7a6>
                (*sigHandler)(pSkt->sktIx, pRxPkt->pktIf, sktEvent, sigParam);
    1d48:	4633      	mov	r3, r6
    1d4a:	f8d9 1028 	ldr.w	r1, [r9, #40]	; 0x28
    1d4e:	f9ba 0034 	ldrsh.w	r0, [sl, #52]	; 0x34
    1d52:	47a8      	blx	r5
        ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    1d54:	2102      	movs	r1, #2
    1d56:	e3b0      	b.n	24ba <__ext_attr_.config_00804000+0x4b6>
                _TcpCloseSocket(pSkt, 0);	// Unbind remote IP address/port info
    1d58:	2100      	movs	r1, #0
    1d5a:	4650      	mov	r0, sl
    1d5c:	f010 fa76 	bl	1224c <_TcpCloseSocket>
                return;
    1d60:	e7dd      	b.n	1d1e <TCPIP_TCP_Task+0x2ca>
                pSkt->MySEQ = localAckNumber;
    1d62:	f8ca 704c 	str.w	r7, [sl, #76]	; 0x4c
                _TcpSend(pSkt, RST, 0);
    1d66:	2200      	movs	r2, #0
    1d68:	2104      	movs	r1, #4
    1d6a:	4650      	mov	r0, sl
    1d6c:	f006 f8e8 	bl	7f40 <_TcpSend>
                _TcpCloseSocket(pSkt, 0);	// Unbind remote IP address/port info
    1d70:	2100      	movs	r1, #0
    1d72:	4650      	mov	r0, sl
    1d74:	f010 fa6a 	bl	1224c <_TcpCloseSocket>
                return;
    1d78:	e7d1      	b.n	1d1e <TCPIP_TCP_Task+0x2ca>
                _TcpCloseSocket(pSkt, 0);	// Unbind remote IP address/port info
    1d7a:	2100      	movs	r1, #0
    1d7c:	4650      	mov	r0, sl
    1d7e:	f010 fa65 	bl	1224c <_TcpCloseSocket>
    1d82:	e7cc      	b.n	1d1e <TCPIP_TCP_Task+0x2ca>
            if(localHeaderFlags & RST)
    1d84:	f014 0f04 	tst.w	r4, #4
    1d88:	d1c9      	bne.n	1d1e <TCPIP_TCP_Task+0x2ca>
            if(localHeaderFlags & ACK)
    1d8a:	f014 0f10 	tst.w	r4, #16
    1d8e:	f000 850e 	beq.w	27ae <__ext_attr_.config_00804000+0x7aa>
                if(localAckNumber != pSkt->MySEQ)
    1d92:	f8da 504c 	ldr.w	r5, [sl, #76]	; 0x4c
    1d96:	42af      	cmp	r7, r5
    1d98:	d12a      	bne.n	1df0 <TCPIP_TCP_Task+0x39c>
            if(localHeaderFlags & SYN)
    1d9a:	f014 0f02 	tst.w	r4, #2
    1d9e:	d0be      	beq.n	1d1e <TCPIP_TCP_Task+0x2ca>
                pSkt->RemoteSEQ = localSeqNumber + 1;
    1da0:	3601      	adds	r6, #1
    1da2:	f8ca 6050 	str.w	r6, [sl, #80]	; 0x50
                pSkt->remoteWindow = pSkt->maxRemoteWindow = h->Window;
    1da6:	f8b8 300e 	ldrh.w	r3, [r8, #14]
    1daa:	f8aa 3066 	strh.w	r3, [sl, #102]	; 0x66
    1dae:	f8aa 305c 	strh.w	r3, [sl, #92]	; 0x5c
                pSkt->wRemoteMSS = _GetMaxSegSizeOption(h);
    1db2:	4640      	mov	r0, r8
    1db4:	f016 f8f0 	bl	17f98 <_GetMaxSegSizeOption>
    1db8:	f8aa 0062 	strh.w	r0, [sl, #98]	; 0x62
                _TCPSetHalfFlushFlag(pSkt);
    1dbc:	4650      	mov	r0, sl
    1dbe:	f01d fff1 	bl	1fda4 <_TCPSetHalfFlushFlag>
                    _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
    1dc2:	2201      	movs	r2, #1
    1dc4:	2110      	movs	r1, #16
    1dc6:	4650      	mov	r0, sl
    1dc8:	f006 f8ba 	bl	7f40 <_TcpSend>
    pSkt->smState = newState;
    1dcc:	2303      	movs	r3, #3
    1dce:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
                    if(pSkt->Flags.keepAlive)
    1dd2:	f89a 3037 	ldrb.w	r3, [sl, #55]	; 0x37
    1dd6:	f013 0f40 	tst.w	r3, #64	; 0x40
    1dda:	d113      	bne.n	1e04 <TCPIP_TCP_Task+0x3b0>
                    pSkt->Flags.bTimerEnabled = 0;
    1ddc:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    1de0:	f36f 0341 	bfc	r3, #1, #1
    1de4:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36
                    *pSktEvent |= TCPIP_TCP_SIGNAL_ESTABLISHED;
    1de8:	f44f 7380 	mov.w	r3, #256	; 0x100
    1dec:	9304      	str	r3, [sp, #16]
    1dee:	e796      	b.n	1d1e <TCPIP_TCP_Task+0x2ca>
                    pSkt->MySEQ = localAckNumber;	// Set SEQ = SEG.ACK
    1df0:	f8ca 704c 	str.w	r7, [sl, #76]	; 0x4c
                    _TcpSend(pSkt, RST, SENDTCP_RESET_TIMERS);		// Send the RST
    1df4:	2201      	movs	r2, #1
    1df6:	2104      	movs	r1, #4
    1df8:	4650      	mov	r0, sl
    1dfa:	f006 f8a1 	bl	7f40 <_TcpSend>
                    pSkt->MySEQ = localSeqNumber;	// Restore original SEQ number
    1dfe:	f8ca 504c 	str.w	r5, [sl, #76]	; 0x4c
                    return;
    1e02:	e78c      	b.n	1d1e <TCPIP_TCP_Task+0x2ca>
                        pSkt->eventTime = SYS_TMR_TickCountGet() + (pSkt->keepAliveTmo * SYS_TMR_TickCounterFrequencyGet())/1000;
    1e04:	f020 fa1a 	bl	2223c <SYS_TMR_TickCountGet>
    1e08:	4605      	mov	r5, r0
    1e0a:	f8ba 4068 	ldrh.w	r4, [sl, #104]	; 0x68
    1e0e:	f020 fa3d 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    1e12:	fb00 f304 	mul.w	r3, r0, r4
    1e16:	4a09      	ldr	r2, [pc, #36]	; (1e3c <TCPIP_TCP_Task+0x3e8>)
    1e18:	fba2 2303 	umull	r2, r3, r2, r3
    1e1c:	eb05 1393 	add.w	r3, r5, r3, lsr #6
    1e20:	f8ca 3024 	str.w	r3, [sl, #36]	; 0x24
    1e24:	e7da      	b.n	1ddc <TCPIP_TCP_Task+0x388>
        wFreeSpace = pSkt->rxTail - pSkt->rxHead - 1;
    1e26:	eba2 0b05 	sub.w	fp, r2, r5
    1e2a:	f10b 3bff 	add.w	fp, fp, #4294967295
    1e2e:	fa1f fb8b 	uxth.w	fp, fp
    1e32:	e71e      	b.n	1c72 <TCPIP_TCP_Task+0x21e>
    1e34:	2000edc4 	.word	0x2000edc4
    1e38:	2000edc0 	.word	0x2000edc0
    1e3c:	10624dd3 	.word	0x10624dd3
                if((lMissingBytes + (int32_t)wSegmentLength > 0) && (lMissingBytes <= (int32_t)(wFreeSpace - wSegmentLength)))
    1e40:	9905      	ldr	r1, [sp, #20]
    1e42:	460a      	mov	r2, r1
    1e44:	1869      	adds	r1, r5, r1
    1e46:	2900      	cmp	r1, #0
    1e48:	f73f af25 	bgt.w	1c96 <TCPIP_TCP_Task+0x242>
    {
        // Unacceptable segment, drop it and respond appropriately
        if(!(localHeaderFlags & RST)) 
    1e4c:	f014 0f04 	tst.w	r4, #4
    1e50:	f47f af65 	bne.w	1d1e <TCPIP_TCP_Task+0x2ca>
        {
            _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
    1e54:	2201      	movs	r2, #1
    1e56:	2110      	movs	r1, #16
    1e58:	4650      	mov	r0, sl
    1e5a:	f006 f871 	bl	7f40 <_TcpSend>
    1e5e:	e75e      	b.n	1d1e <TCPIP_TCP_Task+0x2ca>
        if(lMissingBytes == 0)
    1e60:	b11d      	cbz	r5, 1e6a <TCPIP_TCP_Task+0x416>
            if((lMissingBytes >= 0) && ((int32_t)wFreeSpace > lMissingBytes))
    1e62:	2d00      	cmp	r5, #0
    1e64:	dbf2      	blt.n	1e4c <TCPIP_TCP_Task+0x3f8>
    1e66:	455d      	cmp	r5, fp
    1e68:	daf0      	bge.n	1e4c <TCPIP_TCP_Task+0x3f8>
    //
    // Fourth: check the SYN bit
    //
    // Note, that since the third step is not implemented, we can 
    // combine this second and fourth step into a single operation.
    if(localHeaderFlags & (RST | SYN))
    1e6a:	f014 0f06 	tst.w	r4, #6
    1e6e:	d111      	bne.n	1e94 <TCPIP_TCP_Task+0x440>
    // Feature not supported.  Let's process this segment.

    //
    // Fifth: check the ACK bit
    //
    if(!(localHeaderFlags & ACK))
    1e70:	f014 0f10 	tst.w	r4, #16
    1e74:	f43f af53 	beq.w	1d1e <TCPIP_TCP_Task+0x2ca>
    {
        TCPIP_NDP_NborReachConfirm (pSkt->pSktNet, TCPIP_IPV6_DestAddressGet(pSkt->pV6Pkt));
    }
#endif  // defined (TCPIP_STACK_USE_IPV6)

    switch(pSkt->smState)
    1e78:	3b02      	subs	r3, #2
    1e7a:	2b07      	cmp	r3, #7
    1e7c:	f200 80fe 	bhi.w	207c <__ext_attr_.config_00804000+0x78>
    1e80:	e8df f013 	tbh	[pc, r3, lsl #1]
    1e84:	00240019 	.word	0x00240019
    1e88:	00240024 	.word	0x00240024
    1e8c:	00fc0024 	.word	0x00fc0024
    1e90:	01f90024 	.word	0x01f90024
        if(localHeaderFlags & RST)
    1e94:	f014 0f04 	tst.w	r4, #4
    1e98:	d008      	beq.n	1eac <TCPIP_TCP_Task+0x458>
            pSkt->Flags.bSocketReset = 1;
    1e9a:	f89a 3037 	ldrb.w	r3, [sl, #55]	; 0x37
    1e9e:	f043 0302 	orr.w	r3, r3, #2
    1ea2:	f88a 3037 	strb.w	r3, [sl, #55]	; 0x37
            *pSktEvent |= TCPIP_TCP_SIGNAL_RX_RST;
    1ea6:	f44f 6300 	mov.w	r3, #2048	; 0x800
    1eaa:	9304      	str	r3, [sp, #16]
        _TcpCloseSocket(pSkt, 0);
    1eac:	2100      	movs	r1, #0
    1eae:	4650      	mov	r0, sl
    1eb0:	f010 f9cc 	bl	1224c <_TcpCloseSocket>
        return;
    1eb4:	e733      	b.n	1d1e <TCPIP_TCP_Task+0x2ca>
    {
        case TCPIP_TCP_STATE_SYN_RECEIVED:
            if(localAckNumber != pSkt->MySEQ)
    1eb6:	f8da 304c 	ldr.w	r3, [sl, #76]	; 0x4c
    1eba:	9308      	str	r3, [sp, #32]
    1ebc:	429f      	cmp	r7, r3
    1ebe:	d120      	bne.n	1f02 <TCPIP_TCP_Task+0x4ae>
    pSkt->smState = newState;
    1ec0:	2303      	movs	r3, #3
    1ec2:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
                _TcpSend(pSkt, RST, SENDTCP_RESET_TIMERS);		// Send the RST
                pSkt->MySEQ = localSeqNumber;	// Restore original SEQ number
                return;
            }
            _TcpSocketSetState(pSkt, TCPIP_TCP_STATE_ESTABLISHED);
            *pSktEvent |= TCPIP_TCP_SIGNAL_ESTABLISHED;
    1ec6:	f44f 7380 	mov.w	r3, #256	; 0x100
    1eca:	9304      	str	r3, [sp, #16]
        case TCPIP_TCP_STATE_FIN_WAIT_1:
        case TCPIP_TCP_STATE_FIN_WAIT_2:
        case TCPIP_TCP_STATE_CLOSE_WAIT:
        case TCPIP_TCP_STATE_CLOSING:
            // Calculate what the highest possible SEQ number in our TX FIFO is
            wTemp = pSkt->txHead - pSkt->txUnackedTail;
    1ecc:	f8da c008 	ldr.w	ip, [sl, #8]
    1ed0:	f8da 3010 	ldr.w	r3, [sl, #16]
            if((int32_t)wTemp < 0)
    1ed4:	ebbc 0003 	subs.w	r0, ip, r3
    1ed8:	d41e      	bmi.n	1f18 <TCPIP_TCP_Task+0x4c4>
            {
                wTemp += pSkt->txEnd - pSkt->txStart;
            }
            dwTemp = pSkt->MySEQ + wTemp;
    1eda:	f8da 104c 	ldr.w	r1, [sl, #76]	; 0x4c

            // Drop the packet if it ACKs something we haven't sent
            dwTemp = localAckNumber - dwTemp;
    1ede:	1a7a      	subs	r2, r7, r1
    1ee0:	1a12      	subs	r2, r2, r0
            if((int32_t)dwTemp > 0)
    1ee2:	2a00      	cmp	r2, #0
    1ee4:	dd28      	ble.n	1f38 <TCPIP_TCP_Task+0x4e4>
            {   // acknowledged more than we've sent??
                if(!pSkt->flags.bFINSent || pSkt->flags.seqInc || dwTemp != 1)
    1ee6:	f8ba 006c 	ldrh.w	r0, [sl, #108]	; 0x6c
    1eea:	f400 7001 	and.w	r0, r0, #516	; 0x204
    1eee:	2804      	cmp	r0, #4
    1ef0:	d101      	bne.n	1ef6 <TCPIP_TCP_Task+0x4a2>
    1ef2:	2a01      	cmp	r2, #1
    1ef4:	d017      	beq.n	1f26 <TCPIP_TCP_Task+0x4d2>
                {
                    _TcpSend(pSkt, ACK, 0);
    1ef6:	2200      	movs	r2, #0
    1ef8:	2110      	movs	r1, #16
    1efa:	4650      	mov	r0, sl
    1efc:	f006 f820 	bl	7f40 <_TcpSend>
                    return;
    1f00:	e70d      	b.n	1d1e <TCPIP_TCP_Task+0x2ca>
                pSkt->MySEQ = localAckNumber;	// Set SEQ = SEG.ACK
    1f02:	f8ca 704c 	str.w	r7, [sl, #76]	; 0x4c
                _TcpSend(pSkt, RST, SENDTCP_RESET_TIMERS);		// Send the RST
    1f06:	2201      	movs	r2, #1
    1f08:	2104      	movs	r1, #4
    1f0a:	4650      	mov	r0, sl
    1f0c:	f006 f818 	bl	7f40 <_TcpSend>
                pSkt->MySEQ = localSeqNumber;	// Restore original SEQ number
    1f10:	9b08      	ldr	r3, [sp, #32]
    1f12:	f8ca 304c 	str.w	r3, [sl, #76]	; 0x4c
                return;
    1f16:	e702      	b.n	1d1e <TCPIP_TCP_Task+0x2ca>
                wTemp += pSkt->txEnd - pSkt->txStart;
    1f18:	f8da 1004 	ldr.w	r1, [sl, #4]
    1f1c:	f8da 2000 	ldr.w	r2, [sl]
    1f20:	1a89      	subs	r1, r1, r2
    1f22:	4408      	add	r0, r1
    1f24:	e7d9      	b.n	1eda <TCPIP_TCP_Task+0x486>
                }
                else
                {
                    pSkt->MySEQ++;      // since we didn't count the FIN
    1f26:	3101      	adds	r1, #1
    1f28:	f8ca 104c 	str.w	r1, [sl, #76]	; 0x4c
                    pSkt->flags.seqInc = 1;
    1f2c:	f89a 206d 	ldrb.w	r2, [sl, #109]	; 0x6d
    1f30:	f042 0202 	orr.w	r2, r2, #2
    1f34:	f88a 206d 	strb.w	r2, [sl, #109]	; 0x6d
                }
            }

            // Throw away all ACKnowledged TX data:
            // Calculate what the last acknowledged sequence number was (ignoring any FINs we sent)
            dwTemp = pSkt->MySEQ - (uint32_t)(pSkt->txUnackedTail - pSkt->txTail);
    1f38:	f8da 204c 	ldr.w	r2, [sl, #76]	; 0x4c
    1f3c:	9209      	str	r2, [sp, #36]	; 0x24
    1f3e:	f8da 100c 	ldr.w	r1, [sl, #12]
    1f42:	9108      	str	r1, [sp, #32]
    1f44:	eba3 0e01 	sub.w	lr, r3, r1
            if(pSkt->txUnackedTail < pSkt->txTail)
    1f48:	428b      	cmp	r3, r1
    1f4a:	d22f      	bcs.n	1fac <TCPIP_TCP_Task+0x558>
            {
                dwTemp -= pSkt->txEnd - pSkt->txStart;
    1f4c:	f8da 0004 	ldr.w	r0, [sl, #4]
    1f50:	f8da 1000 	ldr.w	r1, [sl]
    1f54:	1a41      	subs	r1, r0, r1
            }

            // Calcluate how many bytes were ACKed with this packet
            dwTemp = localAckNumber - dwTemp;
    1f56:	1ab8      	subs	r0, r7, r2
    1f58:	4470      	add	r0, lr
    1f5a:	4408      	add	r0, r1
            if(((int32_t)(dwTemp) > 0) && (dwTemp <= pSkt->txEnd - pSkt->txStart))
    1f5c:	2800      	cmp	r0, #0
    1f5e:	dd38      	ble.n	1fd2 <TCPIP_TCP_Task+0x57e>
    1f60:	f8da 2004 	ldr.w	r2, [sl, #4]
    1f64:	920a      	str	r2, [sp, #40]	; 0x28
    1f66:	f8da 1000 	ldr.w	r1, [sl]
    1f6a:	1a52      	subs	r2, r2, r1
    1f6c:	920b      	str	r2, [sp, #44]	; 0x2c
    1f6e:	4290      	cmp	r0, r2
    1f70:	d82c      	bhi.n	1fcc <TCPIP_TCP_Task+0x578>
            {
                pSkt->flags.bRXNoneACKed1 = 0;
    1f72:	f89a 106c 	ldrb.w	r1, [sl, #108]	; 0x6c
                pSkt->flags.bRXNoneACKed2 = 0;
    1f76:	f001 01ef 	and.w	r1, r1, #239	; 0xef
    1f7a:	f36f 1145 	bfc	r1, #5, #1
    1f7e:	f88a 106c 	strb.w	r1, [sl, #108]	; 0x6c
                pSkt->Flags.bHalfFullFlush = false;
    1f82:	f89a 1036 	ldrb.w	r1, [sl, #54]	; 0x36
    1f86:	f36f 1145 	bfc	r1, #5, #1
    1f8a:	f88a 1036 	strb.w	r1, [sl, #54]	; 0x36

                // Bytes ACKed, free up the TX FIFO space
                ptrTemp = pSkt->txTail;
                pSkt->txTail += dwTemp;
    1f8e:	9a08      	ldr	r2, [sp, #32]
    1f90:	4402      	add	r2, r0
    1f92:	f8ca 200c 	str.w	r2, [sl, #12]
                        pSkt->txUnackedTail = pSkt->txTail;
                    }
                }
                else
                {
                    ptrTemp = pSkt->txUnackedTail + (pSkt->txEnd - pSkt->txStart);
    1f96:	990b      	ldr	r1, [sp, #44]	; 0x2c
    1f98:	440b      	add	r3, r1
                    if(ptrTemp < pSkt->txTail)
    1f9a:	4293      	cmp	r3, r2
    1f9c:	f0c0 80ff 	bcc.w	219e <__ext_attr_.config_00804000+0x19a>
                    {
                        pSkt->MySEQ += pSkt->txTail - ptrTemp;
                        pSkt->txUnackedTail = pSkt->txTail;
                    }
                }
                if(pSkt->txTail >= pSkt->txEnd)
    1fa0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1fa2:	429a      	cmp	r2, r3
    1fa4:	f0c0 8455 	bcc.w	2852 <__ext_attr_.config_00804000+0x84e>
    1fa8:	f000 bc4f 	b.w	284a <__ext_attr_.config_00804000+0x846>
            dwTemp = localAckNumber - dwTemp;
    1fac:	9909      	ldr	r1, [sp, #36]	; 0x24
    1fae:	1a78      	subs	r0, r7, r1
    1fb0:	4470      	add	r0, lr
            if(((int32_t)(dwTemp) > 0) && (dwTemp <= pSkt->txEnd - pSkt->txStart))
    1fb2:	2800      	cmp	r0, #0
    1fb4:	dd0a      	ble.n	1fcc <TCPIP_TCP_Task+0x578>
    1fb6:	f8da 1004 	ldr.w	r1, [sl, #4]
    1fba:	460a      	mov	r2, r1
    1fbc:	910a      	str	r1, [sp, #40]	; 0x28
    1fbe:	f8da 1000 	ldr.w	r1, [sl]
    1fc2:	1a52      	subs	r2, r2, r1
    1fc4:	920b      	str	r2, [sp, #44]	; 0x2c
    1fc6:	4290      	cmp	r0, r2
    1fc8:	f240 8420 	bls.w	280c <__ext_attr_.config_00804000+0x808>
                }
            }
            else
            {   // no acknowledge
                // See if we have outstanding TX data that is waiting for an ACK
                if(pSkt->txTail != pSkt->txUnackedTail)
    1fcc:	9a08      	ldr	r2, [sp, #32]
    1fce:	4293      	cmp	r3, r2
    1fd0:	d02c      	beq.n	202c <__ext_attr_.config_00804000+0x28>
                {
                    if(pSkt->flags.bRXNoneACKed1)
    1fd2:	f89a 106c 	ldrb.w	r1, [sl, #108]	; 0x6c
    1fd6:	f011 0f10 	tst.w	r1, #16
    1fda:	d021      	beq.n	2020 <__ext_attr_.config_00804000+0x1c>
                    {
                        if(pSkt->flags.bRXNoneACKed2)
    1fdc:	f011 0f20 	tst.w	r1, #32
    1fe0:	d018      	beq.n	2014 <__ext_attr_.config_00804000+0x10>
            dwTemp = pSkt->MySEQ - (uint32_t)(pSkt->txUnackedTail - pSkt->txTail);
    1fe2:	9a09      	ldr	r2, [sp, #36]	; 0x24
    1fe4:	eba2 010e 	sub.w	r1, r2, lr
                        {
                            // Set up to perform a fast retransmission
                            // Roll back unacknowledged TX tail pointer to cause retransmit to occur
                            pSkt->MySEQ -= (pSkt->txUnackedTail - pSkt->txTail);
    1fe8:	f8ca 104c 	str.w	r1, [sl, #76]	; 0x4c
                            if(pSkt->txUnackedTail < pSkt->txTail)
    1fec:	9a08      	ldr	r2, [sp, #32]
    1fee:	4293      	cmp	r3, r2
    1ff0:	d207      	bcs.n	2002 <TCPIP_TCP_Task+0x5ae>
                            {
                                pSkt->MySEQ -= (pSkt->txEnd - pSkt->txStart);
    1ff2:	f8da 3004 	ldr.w	r3, [sl, #4]
    1ff6:	f8da 0000 	ldr.w	r0, [sl]
    1ffa:	1a1b      	subs	r3, r3, r0
    1ffc:	1acb      	subs	r3, r1, r3
    1ffe:	f8ca 304c 	str.w	r3, [sl, #76]	; 0x4c
                            }
                            pSkt->txUnackedTail = pSkt->txTail;
    2002:	9b08      	ldr	r3, [sp, #32]
    2004:	f8ca 3010 	str.w	r3, [sl, #16]
                            pSkt->Flags.bTXASAPWithoutTimerReset = 1;
    2008:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    200c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    2010:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36
                        }
                        pSkt->flags.bRXNoneACKed2 = 1;
    2014:	f89a 306c 	ldrb.w	r3, [sl, #108]	; 0x6c
    2018:	f043 0320 	orr.w	r3, r3, #32
    201c:	f88a 306c 	strb.w	r3, [sl, #108]	; 0x6c
                    }
                    pSkt->flags.bRXNoneACKed1 = 1;
    2020:	f89a 306c 	ldrb.w	r3, [sl, #108]	; 0x6c
    2024:	f043 0310 	orr.w	r3, r3, #16
    2028:	f88a 306c 	strb.w	r3, [sl, #108]	; 0x6c
                }
            }

            // No need to keep our retransmit timer going if we have nothing that needs ACKing anymore
            if(pSkt->txTail == pSkt->txHead)
    202c:	f8da 300c 	ldr.w	r3, [sl, #12]
    2030:	459c      	cmp	ip, r3
    2032:	f000 80bc 	beq.w	21ae <__ext_attr_.config_00804000+0x1aa>
                    }
                }
            }

            // update the max window
            if(h->Window > pSkt->maxRemoteWindow)
    2036:	f8b8 300e 	ldrh.w	r3, [r8, #14]
    203a:	f8ba 2066 	ldrh.w	r2, [sl, #102]	; 0x66
    203e:	429a      	cmp	r2, r3
            {
                pSkt->maxRemoteWindow = h->Window;
    2040:	bf38      	it	cc
    2042:	f8aa 3066 	strhcc.w	r3, [sl, #102]	; 0x66
            }
            // The window size advertised in this packet is adjusted to account 
            // for any bytes that we have transmitted but haven't been ACKed yet 
            // by this segment.
            wNewWindow = h->Window - ((uint16_t)(pSkt->MySEQ - localAckNumber));
    2046:	f8da 204c 	ldr.w	r2, [sl, #76]	; 0x4c
    204a:	f8b8 300e 	ldrh.w	r3, [r8, #14]
    204e:	443b      	add	r3, r7
    2050:	1a9b      	subs	r3, r3, r2
    2052:	b29b      	uxth	r3, r3

            // Update the local stored copy of the RemoteWindow.
            // If previously we had a zero window, and now we don't, then 
            // immediately send whatever was pending.
            if((pSkt->remoteWindow == 0u) && wNewWindow)
    2054:	f8ba 105c 	ldrh.w	r1, [sl, #92]	; 0x5c
    2058:	b931      	cbnz	r1, 2068 <__ext_attr_.config_00804000+0x64>
    205a:	b12b      	cbz	r3, 2068 <__ext_attr_.config_00804000+0x64>
            {
                pSkt->Flags.bTXASAP = 1;
    205c:	f89a 1036 	ldrb.w	r1, [sl, #54]	; 0x36
    2060:	f041 0140 	orr.w	r1, r1, #64	; 0x40
    2064:	f88a 1036 	strb.w	r1, [sl, #54]	; 0x36
            }
            pSkt->remoteWindow = wNewWindow;
    2068:	f8aa 305c 	strh.w	r3, [sl, #92]	; 0x5c

            // A couple of states must do all of the TCPIP_TCP_STATE_ESTABLISHED stuff, but also a little more
            if(pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1)
    206c:	f89a 306e 	ldrb.w	r3, [sl, #110]	; 0x6e
    2070:	2b04      	cmp	r3, #4
    2072:	f000 80d7 	beq.w	2224 <__ext_attr_.config_00804000+0x220>
                    // doesn't send us a FIN in a timely manner.
                    pSkt->closeWaitTime = SYS_TMR_TickCountGet() + (TCPIP_TCP_FIN_WAIT_2_TIMEOUT * SYS_TMR_TickCounterFrequencyGet())/1000;
                    _TcpSocketSetState(pSkt, TCPIP_TCP_STATE_FIN_WAIT_2);
                }
            }
            else if(pSkt->smState == TCPIP_TCP_STATE_CLOSING)
    2076:	2b06      	cmp	r3, #6
    2078:	f000 80f5 	beq.w	2266 <__ext_attr_.config_00804000+0x262>
    //
    // Sixth: Check the URG bit
    //
    // Urgent packets are not supported in this stack, so we
    // will throw them away instead
    if(localHeaderFlags & URG)
    207c:	f014 0f20 	tst.w	r4, #32
    2080:	f47f ae4d 	bne.w	1d1e <TCPIP_TCP_Task+0x2ca>

    //
    // Seventh: Process the segment text
    //
    // Throw data away if in a state that doesn't accept data
    if(pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT || pSkt->smState == TCPIP_TCP_STATE_CLOSING || pSkt->smState == TCPIP_TCP_STATE_LAST_ACK)
    2084:	f89a 206e 	ldrb.w	r2, [sl, #110]	; 0x6e
    2088:	f1a2 0308 	sub.w	r3, r2, #8
    208c:	b2db      	uxtb	r3, r3
    208e:	2b01      	cmp	r3, #1
    2090:	f67f ae45 	bls.w	1d1e <TCPIP_TCP_Task+0x2ca>
    2094:	2a06      	cmp	r2, #6
    2096:	f43f ae42 	beq.w	1d1e <TCPIP_TCP_Task+0x2ca>
    {
        return;
    }

    // Copy any valid segment data into our RX FIFO, if any
    if(len)
    209a:	9a06      	ldr	r2, [sp, #24]
    209c:	2a00      	cmp	r2, #0
    209e:	d03d      	beq.n	211c <__ext_attr_.config_00804000+0x118>
    {
        // See if there are bytes we must skip
        // wMissingBytes == 0: this new data is in sync with what we expect
        // wMissingBytes  < 0: this packet contains old data that needs to be skipped
        if(wMissingBytes <= 0)
    20a0:	2d00      	cmp	r5, #0
    20a2:	f340 80f3 	ble.w	228c <__ext_attr_.config_00804000+0x288>
        } 
        else if(wMissingBytes > 0)
        {   // wMissingBytes  > 0: this packet contains ahead data
            // This packet is out of order or we lost a packet, see if we can generate a hole to accomodate it
            // Truncate packets that would overflow our TCP RX FIFO
            if(len + wMissingBytes > wFreeSpace)
    20a6:	9b06      	ldr	r3, [sp, #24]
    20a8:	442b      	add	r3, r5
    20aa:	455b      	cmp	r3, fp
    20ac:	dd04      	ble.n	20b8 <__ext_attr_.config_00804000+0xb4>
            {
                len = wFreeSpace - wMissingBytes;
    20ae:	ebab 0b05 	sub.w	fp, fp, r5
    20b2:	fa1f f38b 	uxth.w	r3, fp
    20b6:	9306      	str	r3, [sp, #24]
            }

            // Position packet read pointer to start of useful data area.
            pSegSrc = (uint8_t*)h + (h->DataOffset.Val << 2);
    20b8:	f898 300c 	ldrb.w	r3, [r8, #12]
    20bc:	091b      	lsrs	r3, r3, #4
    20be:	eb08 0383 	add.w	r3, r8, r3, lsl #2
    20c2:	930c      	str	r3, [sp, #48]	; 0x30

            // See if we need a two part copy (spans rxEnd->rxStart)
            if(pSkt->rxHead + wMissingBytes + len > pSkt->rxEnd)
    20c4:	f8da 101c 	ldr.w	r1, [sl, #28]
    20c8:	f8da 3018 	ldr.w	r3, [sl, #24]
    20cc:	9a06      	ldr	r2, [sp, #24]
    20ce:	442a      	add	r2, r5
    20d0:	440a      	add	r2, r1
    20d2:	4293      	cmp	r3, r2
    20d4:	f080 8169 	bcs.w	23aa <__ext_attr_.config_00804000+0x3a6>
            {
                // Calculate number of data bytes to copy before wraparound
                wTemp = pSkt->rxEnd - pSkt->rxHead + 1 - wMissingBytes;
    20d8:	1a5a      	subs	r2, r3, r1
    20da:	3201      	adds	r2, #1
                if((int32_t)wTemp >= 0)
    20dc:	1b52      	subs	r2, r2, r5
    20de:	f100 8156 	bmi.w	238e <__ext_attr_.config_00804000+0x38a>
                {
                    nCopiedBytes = TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxHead + wMissingBytes, &pSegSrc, wTemp, true);
    20e2:	fa1f f882 	uxth.w	r8, r2
    20e6:	2401      	movs	r4, #1
    20e8:	9400      	str	r4, [sp, #0]
    20ea:	4643      	mov	r3, r8
    20ec:	a80c      	add	r0, sp, #48	; 0x30
    20ee:	4602      	mov	r2, r0
    20f0:	4429      	add	r1, r5
    20f2:	4648      	mov	r0, r9
    20f4:	f019 fbec 	bl	1b8d0 <TCPIP_Helper_PacketCopy>
    20f8:	4683      	mov	fp, r0
                    nCopiedBytes += TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxStart, &pSegSrc, len - wTemp, true);
    20fa:	9a06      	ldr	r2, [sp, #24]
    20fc:	eba2 0308 	sub.w	r3, r2, r8
    2100:	9400      	str	r4, [sp, #0]
    2102:	b29b      	uxth	r3, r3
    2104:	aa0c      	add	r2, sp, #48	; 0x30
    2106:	f8da 1014 	ldr.w	r1, [sl, #20]
    210a:	4648      	mov	r0, r9
    210c:	f019 fbe0 	bl	1b8d0 <TCPIP_Helper_PacketCopy>
    2110:	4458      	add	r0, fp
    2112:	b280      	uxth	r0, r0
            else
            {
                nCopiedBytes = TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxHead + wMissingBytes, &pSegSrc, len, true);
            }

            if(nCopiedBytes == len)
    2114:	9b06      	ldr	r3, [sp, #24]
    2116:	4283      	cmp	r3, r0
    2118:	f000 8150 	beq.w	23bc <__ext_attr_.config_00804000+0x3b8>
    // Send back an ACK of the data (+SYN | FIN) we just received, 
    // if any.  To minimize bandwidth waste, we are implementing 
    // the delayed acknowledgement algorithm here, only sending 
    // back an immediate ACK if this is the second segment received.  
    // Otherwise, a 200ms timer will cause the ACK to be transmitted.
    if(wSegmentLength)
    211c:	9b05      	ldr	r3, [sp, #20]
    211e:	b1cb      	cbz	r3, 2154 <__ext_attr_.config_00804000+0x150>
        // For non-established sockets, delete all data in 
        // the RX buffer immediately after receiving it.
        // That'll ensure that the RX window is nonzero and 
        // the remote node will be able to send a FIN response, 
        // which needs an RX window of at least 1.
        if(pSkt->smState != TCPIP_TCP_STATE_ESTABLISHED && pSkt->smState != TCPIP_TCP_STATE_FIN_WAIT_1 && pSkt->smState != TCPIP_TCP_STATE_FIN_WAIT_2)
    2120:	f89a 306e 	ldrb.w	r3, [sl, #110]	; 0x6e
    2124:	3b03      	subs	r3, #3
    2126:	b2db      	uxtb	r3, r3
    2128:	2b02      	cmp	r3, #2
        {
            pSkt->rxTail = pSkt->rxHead;
    212a:	bf84      	itt	hi
    212c:	f8da 301c 	ldrhi.w	r3, [sl, #28]
    2130:	f8ca 3020 	strhi.w	r3, [sl, #32]
        }

        if(pSkt->Flags.bOneSegmentReceived)
    2134:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    2138:	f013 0f10 	tst.w	r3, #16
    213c:	f040 816d 	bne.w	241a <__ext_attr_.config_00804000+0x416>
            _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
            // bOneSegmentReceived is cleared in _TcpSend(pSkt, ), so no need here
        }
        else
        {
            pSkt->Flags.bOneSegmentReceived = true;	
    2140:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    2144:	f043 0310 	orr.w	r3, r3, #16
    2148:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36

            // Do not send an ACK immediately back.  Instead, we will 
            // perform delayed acknowledgements.  To do this, we will 
            // just start a timer
            if(!pSkt->Flags.bDelayedACKTimerEnabled)
    214c:	f013 0f08 	tst.w	r3, #8
    2150:	f000 8169 	beq.w	2426 <__ext_attr_.config_00804000+0x422>
    }

    //
    // Eighth: check the FIN bit
    //
    if(localHeaderFlags & FIN)
    2154:	9b07      	ldr	r3, [sp, #28]
    2156:	2b00      	cmp	r3, #0
    2158:	f43f ade1 	beq.w	1d1e <TCPIP_TCP_Task+0x2ca>
    {
        // Note: Since we don't have a good means of storing "FIN bytes" 
        // in our TCP RX FIFO, we must ensure that FINs are processed 
        // in-order.
        if(pSkt->RemoteSEQ + 1 == localSeqNumber + (uint32_t)wSegmentLength)
    215c:	f8da 3050 	ldr.w	r3, [sl, #80]	; 0x50
    2160:	3301      	adds	r3, #1
    2162:	9a05      	ldr	r2, [sp, #20]
    2164:	4432      	add	r2, r6
    2166:	4293      	cmp	r3, r2
    2168:	f47f add9 	bne.w	1d1e <TCPIP_TCP_Task+0x2ca>
        {
            // FINs are treated as one byte of data for ACK sequencing
            pSkt->RemoteSEQ++;
    216c:	f8ca 3050 	str.w	r3, [sl, #80]	; 0x50

            *pSktEvent |= TCPIP_TCP_SIGNAL_RX_FIN;
    2170:	9b04      	ldr	r3, [sp, #16]
    2172:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
    2176:	b293      	uxth	r3, r2
    2178:	9304      	str	r3, [sp, #16]
            pSkt->Flags.bRxFin = 1;
    217a:	f89a 3037 	ldrb.w	r3, [sl, #55]	; 0x37
    217e:	f043 0304 	orr.w	r3, r3, #4
    2182:	f88a 3037 	strb.w	r3, [sl, #55]	; 0x37
            switch(pSkt->smState)
    2186:	f89a 306e 	ldrb.w	r3, [sl, #110]	; 0x6e
    218a:	3b02      	subs	r3, #2
    218c:	2b03      	cmp	r3, #3
    218e:	f200 8178 	bhi.w	2482 <__ext_attr_.config_00804000+0x47e>
    2192:	e8df f013 	tbh	[pc, r3, lsl #1]
    2196:	015d      	.short	0x015d
    2198:	016f0166 	.word	0x016f0166
    219c:	0186      	.short	0x0186
                        pSkt->MySEQ += pSkt->txTail - ptrTemp;
    219e:	1ad3      	subs	r3, r2, r3
    21a0:	9909      	ldr	r1, [sp, #36]	; 0x24
    21a2:	440b      	add	r3, r1
    21a4:	f8ca 304c 	str.w	r3, [sl, #76]	; 0x4c
                        pSkt->txUnackedTail = pSkt->txTail;
    21a8:	f8ca 2010 	str.w	r2, [sl, #16]
    21ac:	e34a      	b.n	2844 <__ext_attr_.config_00804000+0x840>
                if(pSkt->Flags.bTXFIN == 0u)
    21ae:	f89a 3037 	ldrb.w	r3, [sl, #55]	; 0x37
    21b2:	f013 0f01 	tst.w	r3, #1
    21b6:	d11d      	bne.n	21f4 <__ext_attr_.config_00804000+0x1f0>
                    if(pSkt->Flags.keepAlive)
    21b8:	f013 0f40 	tst.w	r3, #64	; 0x40
    21bc:	d106      	bne.n	21cc <__ext_attr_.config_00804000+0x1c8>
                    pSkt->Flags.bTimerEnabled = 0;
    21be:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    21c2:	f36f 0341 	bfc	r3, #1, #1
    21c6:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36
    21ca:	e734      	b.n	2036 <__ext_attr_.config_00804000+0x32>
                        pSkt->eventTime = SYS_TMR_TickCountGet() + (pSkt->keepAliveTmo * SYS_TMR_TickCounterFrequencyGet())/1000;
    21cc:	f020 f836 	bl	2223c <SYS_TMR_TickCountGet>
    21d0:	9008      	str	r0, [sp, #32]
    21d2:	f8ba 3068 	ldrh.w	r3, [sl, #104]	; 0x68
    21d6:	9309      	str	r3, [sp, #36]	; 0x24
    21d8:	f020 f858 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    21dc:	9b09      	ldr	r3, [sp, #36]	; 0x24
    21de:	fb00 f303 	mul.w	r3, r0, r3
    21e2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    21e6:	fbb3 f3f2 	udiv	r3, r3, r2
    21ea:	9a08      	ldr	r2, [sp, #32]
    21ec:	4413      	add	r3, r2
    21ee:	f8ca 3024 	str.w	r3, [sl, #36]	; 0x24
    21f2:	e7e4      	b.n	21be <__ext_attr_.config_00804000+0x1ba>
                    if((pSkt->MySEQ == localAckNumber) && pSkt->flags.bFINSent)
    21f4:	f8da 304c 	ldr.w	r3, [sl, #76]	; 0x4c
    21f8:	429f      	cmp	r7, r3
    21fa:	f47f af1c 	bne.w	2036 <__ext_attr_.config_00804000+0x32>
    21fe:	f89a 306c 	ldrb.w	r3, [sl, #108]	; 0x6c
    2202:	f013 0f04 	tst.w	r3, #4
    2206:	f43f af16 	beq.w	2036 <__ext_attr_.config_00804000+0x32>
                        pSkt->Flags.bTimerEnabled = 0;
    220a:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    220e:	f36f 0341 	bfc	r3, #1, #1
    2212:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36
                        pSkt->Flags.bTXFIN = 0;
    2216:	f89a 3037 	ldrb.w	r3, [sl, #55]	; 0x37
    221a:	f36f 0300 	bfc	r3, #0, #1
    221e:	f88a 3037 	strb.w	r3, [sl, #55]	; 0x37
    2222:	e708      	b.n	2036 <__ext_attr_.config_00804000+0x32>
                if((pSkt->MySEQ == localAckNumber) && pSkt->flags.bFINSent)
    2224:	4297      	cmp	r7, r2
    2226:	d004      	beq.n	2232 <__ext_attr_.config_00804000+0x22e>
    if(localHeaderFlags & URG)
    2228:	f014 0f20 	tst.w	r4, #32
    222c:	f43f af35 	beq.w	209a <__ext_attr_.config_00804000+0x96>
    2230:	e575      	b.n	1d1e <TCPIP_TCP_Task+0x2ca>
                if((pSkt->MySEQ == localAckNumber) && pSkt->flags.bFINSent)
    2232:	f89a 306c 	ldrb.w	r3, [sl, #108]	; 0x6c
    2236:	f013 0f04 	tst.w	r3, #4
    223a:	d0f5      	beq.n	2228 <__ext_attr_.config_00804000+0x224>
                    pSkt->closeWaitTime = SYS_TMR_TickCountGet() + (TCPIP_TCP_FIN_WAIT_2_TIMEOUT * SYS_TMR_TickCounterFrequencyGet())/1000;
    223c:	f01f fffe 	bl	2223c <SYS_TMR_TickCountGet>
    2240:	9008      	str	r0, [sp, #32]
    2242:	f020 f823 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    2246:	f241 3388 	movw	r3, #5000	; 0x1388
    224a:	fb03 f300 	mul.w	r3, r3, r0
    224e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    2252:	fbb3 f3f2 	udiv	r3, r3, r2
    2256:	9a08      	ldr	r2, [sp, #32]
    2258:	4413      	add	r3, r2
    225a:	f8ca 3030 	str.w	r3, [sl, #48]	; 0x30
    pSkt->smState = newState;
    225e:	2305      	movs	r3, #5
    2260:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
    2264:	e7e0      	b.n	2228 <__ext_attr_.config_00804000+0x224>
                if(pSkt->MySEQ == localAckNumber)
    2266:	4297      	cmp	r7, r2
    2268:	f47f ad59 	bne.w	1d1e <TCPIP_TCP_Task+0x2ca>
                    _TcpCloseSocket(pSkt, 0);
    226c:	2100      	movs	r1, #0
    226e:	4650      	mov	r0, sl
    2270:	f00f ffec 	bl	1224c <_TcpCloseSocket>
    2274:	e553      	b.n	1d1e <TCPIP_TCP_Task+0x2ca>
            if(pSkt->MySEQ + 1 == localAckNumber)
    2276:	f8da 304c 	ldr.w	r3, [sl, #76]	; 0x4c
    227a:	3301      	adds	r3, #1
    227c:	429f      	cmp	r7, r3
    227e:	f47f ad4e 	bne.w	1d1e <TCPIP_TCP_Task+0x2ca>
                _TcpCloseSocket(pSkt, 0);
    2282:	2100      	movs	r1, #0
    2284:	4650      	mov	r0, sl
    2286:	f00f ffe1 	bl	1224c <_TcpCloseSocket>
    228a:	e548      	b.n	1d1e <TCPIP_TCP_Task+0x2ca>
            pSegSrc = (uint8_t*)h + ((h->DataOffset.Val << 2) - wMissingBytes);
    228c:	f898 300c 	ldrb.w	r3, [r8, #12]
    2290:	091b      	lsrs	r3, r3, #4
    2292:	ebc5 0383 	rsb	r3, r5, r3, lsl #2
    2296:	4443      	add	r3, r8
    2298:	930c      	str	r3, [sp, #48]	; 0x30
            len += wMissingBytes;		
    229a:	442a      	add	r2, r5
    229c:	b293      	uxth	r3, r2
            if(len > wFreeSpace)
    229e:	459b      	cmp	fp, r3
    22a0:	bf28      	it	cs
    22a2:	469b      	movcs	fp, r3
            if(pSkt->rxHead + len > pSkt->rxEnd)
    22a4:	f8da 101c 	ldr.w	r1, [sl, #28]
    22a8:	f8da 3018 	ldr.w	r3, [sl, #24]
    22ac:	eb01 020b 	add.w	r2, r1, fp
    22b0:	4293      	cmp	r3, r2
    22b2:	d25c      	bcs.n	236e <__ext_attr_.config_00804000+0x36a>
                wTemp = pSkt->rxEnd - pSkt->rxHead + 1;
    22b4:	1a5b      	subs	r3, r3, r1
    22b6:	f103 0801 	add.w	r8, r3, #1
                nCopiedBytes = TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxHead, &pSegSrc, wTemp, true);
    22ba:	fa1f f588 	uxth.w	r5, r8
    22be:	2401      	movs	r4, #1
    22c0:	9400      	str	r4, [sp, #0]
    22c2:	462b      	mov	r3, r5
    22c4:	aa0c      	add	r2, sp, #48	; 0x30
    22c6:	4648      	mov	r0, r9
    22c8:	f019 fb02 	bl	1b8d0 <TCPIP_Helper_PacketCopy>
    22cc:	9006      	str	r0, [sp, #24]
                nCopiedBytes += TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxStart, &pSegSrc, len - wTemp, true);
    22ce:	ebab 0305 	sub.w	r3, fp, r5
    22d2:	9400      	str	r4, [sp, #0]
    22d4:	b29b      	uxth	r3, r3
    22d6:	aa0c      	add	r2, sp, #48	; 0x30
    22d8:	f8da 1014 	ldr.w	r1, [sl, #20]
    22dc:	4648      	mov	r0, r9
    22de:	f019 faf7 	bl	1b8d0 <TCPIP_Helper_PacketCopy>
    22e2:	9b06      	ldr	r3, [sp, #24]
    22e4:	4403      	add	r3, r0
    22e6:	b298      	uxth	r0, r3
                newRxHead = pSkt->rxStart + (len - wTemp);
    22e8:	ebab 0308 	sub.w	r3, fp, r8
    22ec:	f8da 2014 	ldr.w	r2, [sl, #20]
    22f0:	4413      	add	r3, r2
            if(nCopiedBytes == len)
    22f2:	4558      	cmp	r0, fp
    22f4:	f47f af12 	bne.w	211c <__ext_attr_.config_00804000+0x118>
                pSkt->RemoteSEQ += (uint32_t)len;
    22f8:	f8da 1050 	ldr.w	r1, [sl, #80]	; 0x50
    22fc:	4459      	add	r1, fp
    22fe:	f8ca 1050 	str.w	r1, [sl, #80]	; 0x50
                pSkt->rxHead = newRxHead;
    2302:	f8ca 301c 	str.w	r3, [sl, #28]
                if(pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1 || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2)
    2306:	f89a 206e 	ldrb.w	r2, [sl, #110]	; 0x6e
    230a:	3a03      	subs	r2, #3
    230c:	b2d2      	uxtb	r2, r2
    230e:	2a02      	cmp	r2, #2
    2310:	d804      	bhi.n	231c <__ext_attr_.config_00804000+0x318>
                    *pSktEvent |= TCPIP_TCP_SIGNAL_RX_DATA;
    2312:	9a04      	ldr	r2, [sp, #16]
    2314:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    2318:	b292      	uxth	r2, r2
    231a:	9204      	str	r2, [sp, #16]
                if(pSkt->sHoleSize != -1)
    231c:	f8da 2054 	ldr.w	r2, [sl, #84]	; 0x54
    2320:	f1b2 3fff 	cmp.w	r2, #4294967295
    2324:	f43f aefa 	beq.w	211c <__ext_attr_.config_00804000+0x118>
                    pSkt->sHoleSize -= len;
    2328:	eba2 0b0b 	sub.w	fp, r2, fp
    232c:	f8ca b054 	str.w	fp, [sl, #84]	; 0x54
                    wTemp = pSkt->wFutureDataSize + pSkt->sHoleSize;
    2330:	f8ba 2060 	ldrh.w	r2, [sl, #96]	; 0x60
                    if((int32_t)wTemp < 0)
    2334:	eb12 020b 	adds.w	r2, r2, fp
    2338:	d424      	bmi.n	2384 <__ext_attr_.config_00804000+0x380>
                    else if(pSkt->sHoleSize <= 0)
    233a:	f1bb 0f00 	cmp.w	fp, #0
    233e:	f73f aeed 	bgt.w	211c <__ext_attr_.config_00804000+0x118>
                        pSkt->RemoteSEQ += wTemp;
    2342:	4411      	add	r1, r2
    2344:	f8ca 1050 	str.w	r1, [sl, #80]	; 0x50
                        pSkt->rxHead += wTemp;
    2348:	4413      	add	r3, r2
    234a:	f8ca 301c 	str.w	r3, [sl, #28]
                        if(pSkt->rxHead > pSkt->rxEnd)
    234e:	f8da 2018 	ldr.w	r2, [sl, #24]
    2352:	4293      	cmp	r3, r2
    2354:	d906      	bls.n	2364 <__ext_attr_.config_00804000+0x360>
                            pSkt->rxHead -= pSkt->rxEnd - pSkt->rxStart + 1;							
    2356:	f8da 1014 	ldr.w	r1, [sl, #20]
    235a:	1a52      	subs	r2, r2, r1
    235c:	43d2      	mvns	r2, r2
    235e:	4413      	add	r3, r2
    2360:	f8ca 301c 	str.w	r3, [sl, #28]
                        pSkt->sHoleSize = -1;
    2364:	f04f 33ff 	mov.w	r3, #4294967295
    2368:	f8ca 3054 	str.w	r3, [sl, #84]	; 0x54
    236c:	e6d6      	b.n	211c <__ext_attr_.config_00804000+0x118>
                nCopiedBytes = TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxHead, &pSegSrc, len, true);
    236e:	2301      	movs	r3, #1
    2370:	9300      	str	r3, [sp, #0]
    2372:	465b      	mov	r3, fp
    2374:	aa0c      	add	r2, sp, #48	; 0x30
    2376:	4648      	mov	r0, r9
    2378:	f019 faaa 	bl	1b8d0 <TCPIP_Helper_PacketCopy>
                newRxHead = pSkt->rxHead + len;
    237c:	f8da 301c 	ldr.w	r3, [sl, #28]
    2380:	445b      	add	r3, fp
    2382:	e7b6      	b.n	22f2 <__ext_attr_.config_00804000+0x2ee>
                        pSkt->sHoleSize = -1;
    2384:	f04f 33ff 	mov.w	r3, #4294967295
    2388:	f8ca 3054 	str.w	r3, [sl, #84]	; 0x54
    238c:	e6c6      	b.n	211c <__ext_attr_.config_00804000+0x118>
                    nCopiedBytes = TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxHead + wMissingBytes - (pSkt->rxEnd - pSkt->rxStart + 1), &pSegSrc, len, true);
    238e:	1e68      	subs	r0, r5, #1
    2390:	f8da 2014 	ldr.w	r2, [sl, #20]
    2394:	1a9b      	subs	r3, r3, r2
    2396:	1ac0      	subs	r0, r0, r3
    2398:	2301      	movs	r3, #1
    239a:	9300      	str	r3, [sp, #0]
    239c:	9b06      	ldr	r3, [sp, #24]
    239e:	aa0c      	add	r2, sp, #48	; 0x30
    23a0:	4401      	add	r1, r0
    23a2:	4648      	mov	r0, r9
    23a4:	f019 fa94 	bl	1b8d0 <TCPIP_Helper_PacketCopy>
    23a8:	e6b4      	b.n	2114 <__ext_attr_.config_00804000+0x110>
                nCopiedBytes = TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxHead + wMissingBytes, &pSegSrc, len, true);
    23aa:	2301      	movs	r3, #1
    23ac:	9300      	str	r3, [sp, #0]
    23ae:	9b06      	ldr	r3, [sp, #24]
    23b0:	aa0c      	add	r2, sp, #48	; 0x30
    23b2:	4429      	add	r1, r5
    23b4:	4648      	mov	r0, r9
    23b6:	f019 fa8b 	bl	1b8d0 <TCPIP_Helper_PacketCopy>
    23ba:	e6ab      	b.n	2114 <__ext_attr_.config_00804000+0x110>
                if(pSkt->sHoleSize == -1)
    23bc:	f8da 3054 	ldr.w	r3, [sl, #84]	; 0x54
    23c0:	f1b3 3fff 	cmp.w	r3, #4294967295
    23c4:	d013      	beq.n	23ee <__ext_attr_.config_00804000+0x3ea>
                    if(wMissingBytes < (uint32_t)pSkt->sHoleSize)
    23c6:	429d      	cmp	r5, r3
    23c8:	d217      	bcs.n	23fa <__ext_attr_.config_00804000+0x3f6>
                        if((wMissingBytes + len > (uint32_t)pSkt->sHoleSize + pSkt->wFutureDataSize) || (wMissingBytes + len < (uint32_t)pSkt->sHoleSize))
    23ca:	9a06      	ldr	r2, [sp, #24]
    23cc:	1951      	adds	r1, r2, r5
    23ce:	f8ba 2060 	ldrh.w	r2, [sl, #96]	; 0x60
    23d2:	18d0      	adds	r0, r2, r3
    23d4:	4281      	cmp	r1, r0
    23d6:	d804      	bhi.n	23e2 <__ext_attr_.config_00804000+0x3de>
    23d8:	428b      	cmp	r3, r1
    23da:	d802      	bhi.n	23e2 <__ext_attr_.config_00804000+0x3de>
                            pSkt->wFutureDataSize = (uint32_t)pSkt->sHoleSize + pSkt->wFutureDataSize - wMissingBytes;
    23dc:	1b43      	subs	r3, r0, r5
    23de:	b29b      	uxth	r3, r3
    23e0:	9306      	str	r3, [sp, #24]
    23e2:	9b06      	ldr	r3, [sp, #24]
    23e4:	f8aa 3060 	strh.w	r3, [sl, #96]	; 0x60
                        pSkt->sHoleSize = wMissingBytes;
    23e8:	f8ca 5054 	str.w	r5, [sl, #84]	; 0x54
    23ec:	e696      	b.n	211c <__ext_attr_.config_00804000+0x118>
                    pSkt->sHoleSize = wMissingBytes;
    23ee:	f8ca 5054 	str.w	r5, [sl, #84]	; 0x54
                    pSkt->wFutureDataSize = len;
    23f2:	9b06      	ldr	r3, [sp, #24]
    23f4:	f8aa 3060 	strh.w	r3, [sl, #96]	; 0x60
    23f8:	e690      	b.n	211c <__ext_attr_.config_00804000+0x118>
                    else if(wMissingBytes + len > (uint32_t)pSkt->sHoleSize + pSkt->wFutureDataSize)
    23fa:	f8ba 2060 	ldrh.w	r2, [sl, #96]	; 0x60
    23fe:	441a      	add	r2, r3
    2400:	9806      	ldr	r0, [sp, #24]
    2402:	1941      	adds	r1, r0, r5
    2404:	4291      	cmp	r1, r2
    2406:	f67f ae89 	bls.w	211c <__ext_attr_.config_00804000+0x118>
                        if(wMissingBytes <= (uint32_t)pSkt->sHoleSize + pSkt->wFutureDataSize)
    240a:	4295      	cmp	r5, r2
    240c:	f63f ae86 	bhi.w	211c <__ext_attr_.config_00804000+0x118>
                            pSkt->wFutureDataSize += wMissingBytes + len - (uint32_t)pSkt->sHoleSize - pSkt->wFutureDataSize;
    2410:	1aeb      	subs	r3, r5, r3
    2412:	4418      	add	r0, r3
    2414:	f8aa 0060 	strh.w	r0, [sl, #96]	; 0x60
    2418:	e680      	b.n	211c <__ext_attr_.config_00804000+0x118>
            _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
    241a:	2201      	movs	r2, #1
    241c:	2110      	movs	r1, #16
    241e:	4650      	mov	r0, sl
    2420:	f005 fd8e 	bl	7f40 <_TcpSend>
    2424:	e696      	b.n	2154 <__ext_attr_.config_00804000+0x150>
                pSkt->Flags.bDelayedACKTimerEnabled = 1;
    2426:	b2db      	uxtb	r3, r3
    2428:	f043 0308 	orr.w	r3, r3, #8
    242c:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36
                pSkt->delayedACKTime = SYS_TMR_TickCountGet() + (TCPIP_TCP_DELAYED_ACK_TIMEOUT * SYS_TMR_TickCounterFrequencyGet())/1000;
    2430:	f01f ff04 	bl	2223c <SYS_TMR_TickCountGet>
    2434:	4604      	mov	r4, r0
    2436:	f01f ff29 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    243a:	2364      	movs	r3, #100	; 0x64
    243c:	fb03 f300 	mul.w	r3, r3, r0
    2440:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    2444:	fbb3 f3f2 	udiv	r3, r3, r2
    2448:	441c      	add	r4, r3
    244a:	f8ca 402c 	str.w	r4, [sl, #44]	; 0x2c
    244e:	e681      	b.n	2154 <__ext_attr_.config_00804000+0x150>
    pSkt->smState = newState;
    2450:	2309      	movs	r3, #9
    2452:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
                    // to explicitly close a socket that never really 
                    // got opened fully in the first place, so just 
                    // transmit a FIN automatically and jump to 
                    // TCPIP_TCP_STATE_LAST_ACK
                    _TcpSocketSetState(pSkt, TCPIP_TCP_STATE_LAST_ACK);
                    _TcpSend(pSkt, FIN | ACK, SENDTCP_RESET_TIMERS);
    2456:	2201      	movs	r2, #1
    2458:	2111      	movs	r1, #17
    245a:	4650      	mov	r0, sl
    245c:	f005 fd70 	bl	7f40 <_TcpSend>
                    return;
    2460:	e45d      	b.n	1d1e <TCPIP_TCP_Task+0x2ca>
    pSkt->smState = newState;
    2462:	2308      	movs	r3, #8
    2464:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
                    // remote node sends a FIN, a timer is started so 
                    // that the socket will eventually be closed automatically
                    pSkt->closeWaitTime = SYS_TMR_TickCountGet() + (TCPIP_TCP_CLOSE_WAIT_TIMEOUT * SYS_TMR_TickCounterFrequencyGet())/1000;
#endif  // (TCPIP_TCP_CLOSE_WAIT_TIMEOUT != 0)

                    if(pSkt->flags.ackSent)
    2468:	f89a 306d 	ldrb.w	r3, [sl, #109]	; 0x6d
    246c:	f013 0f01 	tst.w	r3, #1
    2470:	d007      	beq.n	2482 <__ext_attr_.config_00804000+0x47e>
    2472:	e454      	b.n	1d1e <TCPIP_TCP_Task+0x2ca>
                    }

                    break;

                case TCPIP_TCP_STATE_FIN_WAIT_1:
                    if(pSkt->MySEQ == localAckNumber)
    2474:	f8da 304c 	ldr.w	r3, [sl, #76]	; 0x4c
    2478:	429f      	cmp	r7, r3
    247a:	d008      	beq.n	248e <__ext_attr_.config_00804000+0x48a>
    pSkt->smState = newState;
    247c:	2306      	movs	r3, #6
    247e:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
                default:    // case TCPIP_TCP_STATE_TIME_WAIT: reacknowledge
                    break;
            }

            // Acknowledge receipt of FIN
            _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
    2482:	2201      	movs	r2, #1
    2484:	2110      	movs	r1, #16
    2486:	4650      	mov	r0, sl
    2488:	f005 fd5a 	bl	7f40 <_TcpSend>
    248c:	e447      	b.n	1d1e <TCPIP_TCP_Task+0x2ca>
                        _TcpSend(pSkt, ACK, 0);
    248e:	2200      	movs	r2, #0
    2490:	2110      	movs	r1, #16
    2492:	4650      	mov	r0, sl
    2494:	f005 fd54 	bl	7f40 <_TcpSend>
                        _TcpCloseSocket(pSkt, 0);
    2498:	2100      	movs	r1, #0
    249a:	4650      	mov	r0, sl
    249c:	f00f fed6 	bl	1224c <_TcpCloseSocket>
                        return;
    24a0:	e43d      	b.n	1d1e <TCPIP_TCP_Task+0x2ca>
                    _TcpSend(pSkt, ACK, 0);
    24a2:	2200      	movs	r2, #0
    24a4:	2110      	movs	r1, #16
    24a6:	4650      	mov	r0, sl
    24a8:	f005 fd4a 	bl	7f40 <_TcpSend>
                    _TcpCloseSocket(pSkt, 0);
    24ac:	2100      	movs	r1, #0
    24ae:	4650      	mov	r0, sl
    24b0:	f00f fecc 	bl	1224c <_TcpCloseSocket>
                    return;
    24b4:	e433      	b.n	1d1e <TCPIP_TCP_Task+0x2ca>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    24b6:	f06f 010d 	mvn.w	r1, #13
            TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
    24ba:	220a      	movs	r2, #10
    24bc:	4648      	mov	r0, r9
    24be:	f01d faf1 	bl	1faa4 <_TCPIP_PKT_PacketAcknowledge>
    while((pRxPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
    24c2:	200a      	movs	r0, #10
    24c4:	f01f faac 	bl	21a20 <_TCPIPStackModuleRxExtract>
    24c8:	4681      	mov	r9, r0
    24ca:	2800      	cmp	r0, #0
    24cc:	f43f aace 	beq.w	1a6c <TCPIP_TCP_Task+0x18>
        uint16_t tcpTotLength = pRxPkt->totTransportLen;
    24d0:	f8b9 5020 	ldrh.w	r5, [r9, #32]
        if(tcpTotLength < sizeof(TCP_HEADER))
    24d4:	2d13      	cmp	r5, #19
    24d6:	d9ee      	bls.n	24b6 <__ext_attr_.config_00804000+0x4b2>
        TCP_HEADER* pHdr = (TCP_HEADER*)pRxPkt->pTransportLayer;
    24d8:	f8d9 801c 	ldr.w	r8, [r9, #28]
        uint8_t optionsField = pHdr->DataOffset.Val;
    24dc:	f898 300c 	ldrb.w	r3, [r8, #12]
    24e0:	091b      	lsrs	r3, r3, #4
        if(optionsField < TCP_DATA_OFFSET_VAL_MIN)
    24e2:	2b04      	cmp	r3, #4
    24e4:	d90b      	bls.n	24fe <__ext_attr_.config_00804000+0x4fa>
        if(tcpTotLength < optionsField << 2)
    24e6:	ebb5 0f83 	cmp.w	r5, r3, lsl #2
    24ea:	db0b      	blt.n	2504 <__ext_attr_.config_00804000+0x500>
            else if((pRxPkt->pktFlags & TCPIP_MAC_PKT_FLAG_NET_TYPE) == TCPIP_MAC_PKT_FLAG_IPV4) 
    24ec:	f8b9 3022 	ldrh.w	r3, [r9, #34]	; 0x22
    24f0:	f413 7f00 	tst.w	r3, #512	; 0x200
    24f4:	f43f aac2 	beq.w	1a7c <TCPIP_TCP_Task+0x28>
        ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    24f8:	f06f 010e 	mvn.w	r1, #14
    24fc:	e7dd      	b.n	24ba <__ext_attr_.config_00804000+0x4b6>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    24fe:	f06f 010d 	mvn.w	r1, #13
    2502:	e7da      	b.n	24ba <__ext_attr_.config_00804000+0x4b6>
    2504:	f06f 010d 	mvn.w	r1, #13
    2508:	e7d7      	b.n	24ba <__ext_attr_.config_00804000+0x4b6>
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    250a:	4bbd      	ldr	r3, [pc, #756]	; (2800 <__ext_attr_.config_00804000+0x7fc>)
    250c:	681b      	ldr	r3, [r3, #0]
    250e:	2b00      	cmp	r3, #0
    2510:	f43f aab1 	beq.w	1a76 <TCPIP_TCP_Task+0x22>
    2514:	2500      	movs	r5, #0
    2516:	462b      	mov	r3, r5
        pSkt = TCBStubs[hTCP];
    2518:	f8df 92e8 	ldr.w	r9, [pc, #744]	; 2804 <__ext_attr_.config_00804000+0x800>
                        pSkt->retryInterval = ((TCPIP_TCP_START_TIMEOUT_VAL * SYS_TMR_TickCounterFrequencyGet())/1000) << (TCPIP_TCP_MAX_RETRIES-1);
    251c:	f8df a2e8 	ldr.w	sl, [pc, #744]	; 2808 <__ext_attr_.config_00804000+0x804>
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    2520:	f8df 82dc 	ldr.w	r8, [pc, #732]	; 2800 <__ext_attr_.config_00804000+0x7fc>
    2524:	e0de      	b.n	26e4 <__ext_attr_.config_00804000+0x6e0>
                if((int32_t)(SYS_TMR_TickCountGet() - pSkt->eventTime2) >= 0)
    2526:	f01f fe89 	bl	2223c <SYS_TMR_TickCountGet>
    252a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    252c:	1ac0      	subs	r0, r0, r3
                    vFlags = ACK;
    252e:	2800      	cmp	r0, #0
    2530:	bfa8      	it	ge
    2532:	2610      	movge	r6, #16
    2534:	e0ed      	b.n	2712 <__ext_attr_.config_00804000+0x70e>
                if((int32_t)(SYS_TMR_TickCountGet() - pSkt->delayedACKTime) >= 0)
    2536:	f01f fe81 	bl	2223c <SYS_TMR_TickCountGet>
    253a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    253c:	1ac0      	subs	r0, r0, r3
    253e:	2800      	cmp	r0, #0
    2540:	f2c0 80ed 	blt.w	271e <__ext_attr_.config_00804000+0x71a>
            if(pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2)
    2544:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
    2548:	2b05      	cmp	r3, #5
    254a:	f000 8199 	beq.w	2880 <__ext_attr_.config_00804000+0x87c>
                    vFlags = ACK;
    254e:	2610      	movs	r6, #16
                _TcpSend(pSkt, vFlags, bRetransmit ? 0 : SENDTCP_RESET_TIMERS);
    2550:	f087 0201 	eor.w	r2, r7, #1
    2554:	4631      	mov	r1, r6
    2556:	4620      	mov	r0, r4
    2558:	f005 fcf2 	bl	7f40 <_TcpSend>
    255c:	e0e7      	b.n	272e <__ext_attr_.config_00804000+0x72a>
                if((int32_t)(SYS_TMR_TickCountGet() - pSkt->closeWaitTime) >= 0)
    255e:	f01f fe6d 	bl	2223c <SYS_TMR_TickCountGet>
    2562:	6b23      	ldr	r3, [r4, #48]	; 0x30
    2564:	1ac0      	subs	r0, r0, r3
    2566:	2800      	cmp	r0, #0
    2568:	f2c0 80de 	blt.w	2728 <__ext_attr_.config_00804000+0x724>
                    _TcpSend(pSkt, RST | ACK, SENDTCP_RESET_TIMERS);
    256c:	2201      	movs	r2, #1
    256e:	2114      	movs	r1, #20
    2570:	4620      	mov	r0, r4
    2572:	f005 fce5 	bl	7f40 <_TcpSend>
                    _TcpCloseSocket(pSkt, 0);
    2576:	2100      	movs	r1, #0
    2578:	4620      	mov	r0, r4
    257a:	f00f fe67 	bl	1224c <_TcpCloseSocket>
                    continue;
    257e:	e0a9      	b.n	26d4 <__ext_attr_.config_00804000+0x6d0>
                            vFlags = pSkt->Flags.bServer;
    2580:	f894 6036 	ldrb.w	r6, [r4, #54]	; 0x36
    2584:	f006 0601 	and.w	r6, r6, #1
                            _TcpDisconnect(pSkt, true);
    2588:	2101      	movs	r1, #1
    258a:	4620      	mov	r0, r4
    258c:	f016 fa50 	bl	18a30 <_TcpDisconnect>
                            pSkt->Flags.bServer = 1;    // force client socket non-closing
    2590:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    2594:	f043 0301 	orr.w	r3, r3, #1
    2598:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
                            _TcpAbort(pSkt, _TCP_ABORT_FLAG_REGULAR, TCPIP_TCP_SIGNAL_KEEP_ALIVE_TMO);
    259c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    25a0:	2100      	movs	r1, #0
    25a2:	4620      	mov	r0, r4
    25a4:	f01b fd86 	bl	1e0b4 <_TcpAbort>
                            if(!vFlags)
    25a8:	2e00      	cmp	r6, #0
    25aa:	f040 8093 	bne.w	26d4 <__ext_attr_.config_00804000+0x6d0>
                                pSkt->Flags.bServer = 0;    // restore the client socket
    25ae:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    25b2:	f36f 0300 	bfc	r3, #0, #1
    25b6:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
    pSkt->smState = newState;
    25ba:	230a      	movs	r3, #10
    25bc:	f884 306e 	strb.w	r3, [r4, #110]	; 0x6e
    25c0:	e088      	b.n	26d4 <__ext_attr_.config_00804000+0x6d0>
            if((int32_t)(SYS_TMR_TickCountGet() - pSkt->eventTime) < 0 )
    25c2:	f01f fe3b 	bl	2223c <SYS_TMR_TickCountGet>
    25c6:	6a63      	ldr	r3, [r4, #36]	; 0x24
    25c8:	1ac0      	subs	r0, r0, r3
    25ca:	2800      	cmp	r0, #0
    25cc:	f2c0 8082 	blt.w	26d4 <__ext_attr_.config_00804000+0x6d0>
            switch(pSkt->smState)
    25d0:	f894 106e 	ldrb.w	r1, [r4, #110]	; 0x6e
    25d4:	1e4b      	subs	r3, r1, #1
    25d6:	2b08      	cmp	r3, #8
    25d8:	d87a      	bhi.n	26d0 <__ext_attr_.config_00804000+0x6cc>
    25da:	e8df f003 	tbb	[pc, r3]
    25de:	4205      	.short	0x4205
    25e0:	69796156 	.word	0x69796156
    25e4:	7979      	.short	0x7979
    25e6:	71          	.byte	0x71
    25e7:	00          	.byte	0x00
                    if(pSkt->retryCount >= (TCPIP_TCP_MAX_RETRIES - 1))
    25e8:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    25ec:	2b03      	cmp	r3, #3
    25ee:	d828      	bhi.n	2642 <__ext_attr_.config_00804000+0x63e>
                    vFlags = SYN;
    25f0:	2102      	movs	r1, #2
            bCloseSocket = false;
    25f2:	2600      	movs	r6, #0
                    pSkt->retryCount++;
    25f4:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    25f8:	3301      	adds	r3, #1
    25fa:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
                    pSkt->retryInterval <<= 1;
    25fe:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    2600:	005b      	lsls	r3, r3, #1
    2602:	64a3      	str	r3, [r4, #72]	; 0x48
                    w = pSkt->txUnackedTail - pSkt->txTail;
    2604:	6920      	ldr	r0, [r4, #16]
    2606:	68e2      	ldr	r2, [r4, #12]
    2608:	1a83      	subs	r3, r0, r2
    260a:	b29b      	uxth	r3, r3
                    if(pSkt->txUnackedTail < pSkt->txTail)
    260c:	4290      	cmp	r0, r2
    260e:	d204      	bcs.n	261a <__ext_attr_.config_00804000+0x616>
                        w += pSkt->txEnd - pSkt->txStart;
    2610:	6860      	ldr	r0, [r4, #4]
    2612:	6827      	ldr	r7, [r4, #0]
    2614:	1bc0      	subs	r0, r0, r7
    2616:	4403      	add	r3, r0
    2618:	b29b      	uxth	r3, r3
                    pSkt->MySEQ -= w;
    261a:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    261c:	1ac0      	subs	r0, r0, r3
    261e:	64e0      	str	r0, [r4, #76]	; 0x4c
                    pSkt->remoteWindow += w;
    2620:	f8b4 005c 	ldrh.w	r0, [r4, #92]	; 0x5c
    2624:	4403      	add	r3, r0
    2626:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
                    pSkt->txUnackedTail = pSkt->txTail;		
    262a:	6122      	str	r2, [r4, #16]
                    _TcpSend(pSkt, vFlags, 0);
    262c:	2200      	movs	r2, #0
    262e:	4620      	mov	r0, r4
    2630:	f005 fc86 	bl	7f40 <_TcpSend>
            if(bCloseSocket)
    2634:	2e00      	cmp	r6, #0
    2636:	d04d      	beq.n	26d4 <__ext_attr_.config_00804000+0x6d0>
                _TcpCloseSocket(pSkt, 0);
    2638:	2100      	movs	r1, #0
    263a:	4620      	mov	r0, r4
    263c:	f00f fe06 	bl	1224c <_TcpCloseSocket>
    2640:	e048      	b.n	26d4 <__ext_attr_.config_00804000+0x6d0>
                        pSkt->retryCount = TCPIP_TCP_MAX_RETRIES - 1;
    2642:	2304      	movs	r3, #4
    2644:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
                        pSkt->retryInterval = ((TCPIP_TCP_START_TIMEOUT_VAL * SYS_TMR_TickCounterFrequencyGet())/1000) << (TCPIP_TCP_MAX_RETRIES-1);
    2648:	f01f fe20 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    264c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    2650:	fb03 f300 	mul.w	r3, r3, r0
    2654:	fbaa 2303 	umull	r2, r3, sl, r3
    2658:	099b      	lsrs	r3, r3, #6
    265a:	011b      	lsls	r3, r3, #4
    265c:	64a3      	str	r3, [r4, #72]	; 0x48
                    vFlags = SYN;
    265e:	2102      	movs	r1, #2
    2660:	e7c7      	b.n	25f2 <__ext_attr_.config_00804000+0x5ee>
                    if(pSkt->retryCount < TCPIP_TCP_MAX_SYN_RETRIES)
    2662:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    2666:	2b02      	cmp	r3, #2
    2668:	f240 80c0 	bls.w	27ec <__ext_attr_.config_00804000+0x7e8>
                        if(pSkt->Flags.bServer)
    266c:	f894 6036 	ldrb.w	r6, [r4, #54]	; 0x36
            bCloseSocket = false;
    2670:	f006 0301 	and.w	r3, r6, #1
    2674:	461e      	mov	r6, r3
    2676:	2b00      	cmp	r3, #0
    2678:	bf18      	it	ne
    267a:	2114      	movne	r1, #20
                if(bRetransmit)
    267c:	2f00      	cmp	r7, #0
    267e:	d1b9      	bne.n	25f4 <__ext_attr_.config_00804000+0x5f0>
                    _TcpSend(pSkt, vFlags, SENDTCP_RESET_TIMERS);
    2680:	2201      	movs	r2, #1
    2682:	4620      	mov	r0, r4
    2684:	f005 fc5c 	bl	7f40 <_TcpSend>
    2688:	e7d4      	b.n	2634 <__ext_attr_.config_00804000+0x630>
                    if(pSkt->retryCount < TCPIP_TCP_MAX_RETRIES)
    268a:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    268e:	2b04      	cmp	r3, #4
    2690:	f240 80ae 	bls.w	27f0 <__ext_attr_.config_00804000+0x7ec>
    pSkt->smState = newState;
    2694:	2304      	movs	r3, #4
    2696:	f884 306e 	strb.w	r3, [r4, #110]	; 0x6e
                        vFlags = FIN | ACK;
    269a:	2111      	movs	r1, #17
            bCloseSocket = false;
    269c:	2600      	movs	r6, #0
    269e:	e7ed      	b.n	267c <__ext_attr_.config_00804000+0x678>
                    if(pSkt->retryCount < TCPIP_TCP_MAX_RETRIES)
    26a0:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    26a4:	2b04      	cmp	r3, #4
    26a6:	f240 80a5 	bls.w	27f4 <__ext_attr_.config_00804000+0x7f0>
                        vFlags = RST | ACK;
    26aa:	2114      	movs	r1, #20
                        bCloseSocket = true;
    26ac:	2601      	movs	r6, #1
    26ae:	e7e5      	b.n	267c <__ext_attr_.config_00804000+0x678>
                    if(pSkt->retryCount < TCPIP_TCP_MAX_RETRIES)
    26b0:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    26b4:	2b04      	cmp	r3, #4
    26b6:	f240 809f 	bls.w	27f8 <__ext_attr_.config_00804000+0x7f4>
                        vFlags = RST | ACK;
    26ba:	2114      	movs	r1, #20
                        bCloseSocket = true;
    26bc:	2601      	movs	r6, #1
    26be:	e7dd      	b.n	267c <__ext_attr_.config_00804000+0x678>
                    if(pSkt->retryCount < TCPIP_TCP_MAX_RETRIES)
    26c0:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    26c4:	2b04      	cmp	r3, #4
    26c6:	f240 8099 	bls.w	27fc <__ext_attr_.config_00804000+0x7f8>
                        vFlags = RST | ACK;
    26ca:	2114      	movs	r1, #20
                        bCloseSocket = true;
    26cc:	2601      	movs	r6, #1
    26ce:	e7d5      	b.n	267c <__ext_attr_.config_00804000+0x678>
            if(vFlags)
    26d0:	2e00      	cmp	r6, #0
    26d2:	d15c      	bne.n	278e <__ext_attr_.config_00804000+0x78a>
    26d4:	3501      	adds	r5, #1
    26d6:	b22d      	sxth	r5, r5
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    26d8:	462b      	mov	r3, r5
    26da:	f8d8 2000 	ldr.w	r2, [r8]
    26de:	4295      	cmp	r5, r2
    26e0:	f4bf a9c9 	bcs.w	1a76 <TCPIP_TCP_Task+0x22>
        pSkt = TCBStubs[hTCP];
    26e4:	f8d9 2000 	ldr.w	r2, [r9]
    26e8:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
        if(pSkt != 0 && pSkt->smState != TCPIP_TCP_STATE_CLIENT_WAIT_CONNECT)
    26ec:	2c00      	cmp	r4, #0
    26ee:	d0f1      	beq.n	26d4 <__ext_attr_.config_00804000+0x6d0>
    26f0:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
    26f4:	2b0b      	cmp	r3, #11
    26f6:	d0ed      	beq.n	26d4 <__ext_attr_.config_00804000+0x6d0>
            if(pSkt->Flags.bTXASAP || pSkt->Flags.bTXASAPWithoutTimerReset)
    26f8:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    26fc:	f013 06c0 	ands.w	r6, r3, #192	; 0xc0
                bRetransmit = pSkt->Flags.bTXASAPWithoutTimerReset;
    2700:	bf1d      	ittte	ne
    2702:	461f      	movne	r7, r3
    2704:	09df      	lsrne	r7, r3, #7
                vFlags = ACK;
    2706:	2610      	movne	r6, #16
            bRetransmit = false;
    2708:	2700      	moveq	r7, #0
            if(pSkt->Flags.bTimer2Enabled)
    270a:	f013 0f04 	tst.w	r3, #4
    270e:	f47f af0a 	bne.w	2526 <__ext_attr_.config_00804000+0x522>
            if(pSkt->Flags.bDelayedACKTimerEnabled)
    2712:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    2716:	f013 0f08 	tst.w	r3, #8
    271a:	f47f af0c 	bne.w	2536 <__ext_attr_.config_00804000+0x532>
            if(pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2)
    271e:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
    2722:	2b05      	cmp	r3, #5
    2724:	f43f af1b 	beq.w	255e <__ext_attr_.config_00804000+0x55a>
            if(vFlags)
    2728:	2e00      	cmp	r6, #0
    272a:	f47f af11 	bne.w	2550 <__ext_attr_.config_00804000+0x54c>
            if(!pSkt->Flags.bTimerEnabled)
    272e:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    2732:	f013 0f02 	tst.w	r3, #2
    2736:	f47f af44 	bne.w	25c2 <__ext_attr_.config_00804000+0x5be>
                if(pSkt->Flags.keepAlive)
    273a:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
    273e:	f013 0f40 	tst.w	r3, #64	; 0x40
    2742:	d0c7      	beq.n	26d4 <__ext_attr_.config_00804000+0x6d0>
                    if(pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED)
    2744:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
    2748:	2b03      	cmp	r3, #3
    274a:	d1c3      	bne.n	26d4 <__ext_attr_.config_00804000+0x6d0>
                        if((int32_t)(SYS_TMR_TickCountGet() - pSkt->eventTime) < 0)
    274c:	f01f fd76 	bl	2223c <SYS_TMR_TickCountGet>
    2750:	6a63      	ldr	r3, [r4, #36]	; 0x24
    2752:	1ac0      	subs	r0, r0, r3
    2754:	2800      	cmp	r0, #0
    2756:	dbbd      	blt.n	26d4 <__ext_attr_.config_00804000+0x6d0>
                        if(pSkt->keepAliveCount == pSkt->keepAliveLim)
    2758:	f894 2071 	ldrb.w	r2, [r4, #113]	; 0x71
    275c:	f894 307c 	ldrb.w	r3, [r4, #124]	; 0x7c
    2760:	429a      	cmp	r2, r3
    2762:	f43f af0d 	beq.w	2580 <__ext_attr_.config_00804000+0x57c>
                        _TcpSend(pSkt, ACK, SENDTCP_KEEP_ALIVE);
    2766:	2202      	movs	r2, #2
    2768:	2110      	movs	r1, #16
    276a:	4620      	mov	r0, r4
    276c:	f005 fbe8 	bl	7f40 <_TcpSend>
                        pSkt->eventTime = SYS_TMR_TickCountGet() + (pSkt->keepAliveTmo * SYS_TMR_TickCounterFrequencyGet())/1000;
    2770:	f01f fd64 	bl	2223c <SYS_TMR_TickCountGet>
    2774:	4607      	mov	r7, r0
    2776:	f8b4 6068 	ldrh.w	r6, [r4, #104]	; 0x68
    277a:	f01f fd87 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    277e:	fb00 f006 	mul.w	r0, r0, r6
    2782:	fbaa 3000 	umull	r3, r0, sl, r0
    2786:	eb07 1090 	add.w	r0, r7, r0, lsr #6
    278a:	6260      	str	r0, [r4, #36]	; 0x24
    278c:	e7a2      	b.n	26d4 <__ext_attr_.config_00804000+0x6d0>
            if(vFlags)
    278e:	4631      	mov	r1, r6
            bCloseSocket = false;
    2790:	2600      	movs	r6, #0
    2792:	e773      	b.n	267c <__ext_attr_.config_00804000+0x678>
        return TCPIP_MAC_PKT_ACK_CHKSUM_ERR;
    2794:	f06f 0109 	mvn.w	r1, #9
    2798:	e68f      	b.n	24ba <__ext_attr_.config_00804000+0x4b6>
            ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    279a:	f06f 010e 	mvn.w	r1, #14
    279e:	e68c      	b.n	24ba <__ext_attr_.config_00804000+0x4b6>
    27a0:	f06f 010e 	mvn.w	r1, #14
    27a4:	e689      	b.n	24ba <__ext_attr_.config_00804000+0x4b6>
        ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    27a6:	2102      	movs	r1, #2
    27a8:	e687      	b.n	24ba <__ext_attr_.config_00804000+0x4b6>
    27aa:	2102      	movs	r1, #2
        if(ackRes != TCPIP_MAC_PKT_ACK_NONE)
    27ac:	e685      	b.n	24ba <__ext_attr_.config_00804000+0x4b6>
            if(localHeaderFlags & SYN)
    27ae:	f014 0f02 	tst.w	r4, #2
    27b2:	f43f aab4 	beq.w	1d1e <TCPIP_TCP_Task+0x2ca>
                pSkt->RemoteSEQ = localSeqNumber + 1;
    27b6:	3601      	adds	r6, #1
    27b8:	f8ca 6050 	str.w	r6, [sl, #80]	; 0x50
                pSkt->remoteWindow = pSkt->maxRemoteWindow = h->Window;
    27bc:	f8b8 300e 	ldrh.w	r3, [r8, #14]
    27c0:	f8aa 3066 	strh.w	r3, [sl, #102]	; 0x66
    27c4:	f8aa 305c 	strh.w	r3, [sl, #92]	; 0x5c
                pSkt->wRemoteMSS = _GetMaxSegSizeOption(h);
    27c8:	4640      	mov	r0, r8
    27ca:	f015 fbe5 	bl	17f98 <_GetMaxSegSizeOption>
    27ce:	f8aa 0062 	strh.w	r0, [sl, #98]	; 0x62
                _TCPSetHalfFlushFlag(pSkt);
    27d2:	4650      	mov	r0, sl
    27d4:	f01d fae6 	bl	1fda4 <_TCPSetHalfFlushFlag>
                    _TcpSend(pSkt, SYN | ACK, SENDTCP_RESET_TIMERS);
    27d8:	2201      	movs	r2, #1
    27da:	2112      	movs	r1, #18
    27dc:	4650      	mov	r0, sl
    27de:	f005 fbaf 	bl	7f40 <_TcpSend>
    pSkt->smState = newState;
    27e2:	2302      	movs	r3, #2
    27e4:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
    27e8:	f7ff ba99 	b.w	1d1e <TCPIP_TCP_Task+0x2ca>
                        vFlags = SYN | ACK;
    27ec:	2112      	movs	r1, #18
    27ee:	e700      	b.n	25f2 <__ext_attr_.config_00804000+0x5ee>
                        vFlags = ACK;
    27f0:	2110      	movs	r1, #16
    27f2:	e6fe      	b.n	25f2 <__ext_attr_.config_00804000+0x5ee>
                        vFlags = FIN | ACK;
    27f4:	2111      	movs	r1, #17
    27f6:	e6fc      	b.n	25f2 <__ext_attr_.config_00804000+0x5ee>
                        vFlags = ACK;
    27f8:	2110      	movs	r1, #16
    27fa:	e6fa      	b.n	25f2 <__ext_attr_.config_00804000+0x5ee>
                        vFlags = FIN | ACK;
    27fc:	2111      	movs	r1, #17
    27fe:	e6f8      	b.n	25f2 <__ext_attr_.config_00804000+0x5ee>
    2800:	2000edc4 	.word	0x2000edc4
    2804:	2000edc0 	.word	0x2000edc0
    2808:	10624dd3 	.word	0x10624dd3
                pSkt->flags.bRXNoneACKed1 = 0;
    280c:	f89a 106c 	ldrb.w	r1, [sl, #108]	; 0x6c
                pSkt->flags.bRXNoneACKed2 = 0;
    2810:	f001 01ef 	and.w	r1, r1, #239	; 0xef
    2814:	f36f 1145 	bfc	r1, #5, #1
    2818:	f88a 106c 	strb.w	r1, [sl, #108]	; 0x6c
                pSkt->Flags.bHalfFullFlush = false;
    281c:	f89a 1036 	ldrb.w	r1, [sl, #54]	; 0x36
    2820:	f36f 1145 	bfc	r1, #5, #1
    2824:	f88a 1036 	strb.w	r1, [sl, #54]	; 0x36
                pSkt->txTail += dwTemp;
    2828:	9a08      	ldr	r2, [sp, #32]
    282a:	4402      	add	r2, r0
    282c:	f8ca 200c 	str.w	r2, [sl, #12]
                    if(pSkt->txUnackedTail < pSkt->txTail)
    2830:	4293      	cmp	r3, r2
    2832:	f4bf abb5 	bcs.w	1fa0 <TCPIP_TCP_Task+0x54c>
                        pSkt->MySEQ += pSkt->txTail - pSkt->txUnackedTail;
    2836:	1ad3      	subs	r3, r2, r3
    2838:	9909      	ldr	r1, [sp, #36]	; 0x24
    283a:	440b      	add	r3, r1
    283c:	f8ca 304c 	str.w	r3, [sl, #76]	; 0x4c
                        pSkt->txUnackedTail = pSkt->txTail;
    2840:	f8ca 2010 	str.w	r2, [sl, #16]
                if(pSkt->txTail >= pSkt->txEnd)
    2844:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    2846:	4293      	cmp	r3, r2
    2848:	d80c      	bhi.n	2864 <__ext_attr_.config_00804000+0x860>
                    pSkt->txTail -= pSkt->txEnd - pSkt->txStart;
    284a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    284c:	1ad2      	subs	r2, r2, r3
    284e:	f8ca 200c 	str.w	r2, [sl, #12]
                if(pSkt->txUnackedTail >= pSkt->txEnd)
    2852:	f8da 3010 	ldr.w	r3, [sl, #16]
    2856:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    2858:	429a      	cmp	r2, r3
    285a:	d803      	bhi.n	2864 <__ext_attr_.config_00804000+0x860>
                    pSkt->txUnackedTail -= pSkt->txEnd - pSkt->txStart;
    285c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    285e:	1a9b      	subs	r3, r3, r2
    2860:	f8ca 3010 	str.w	r3, [sl, #16]
                if(pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT)
    2864:	f89a 306e 	ldrb.w	r3, [sl, #110]	; 0x6e
    2868:	2b03      	cmp	r3, #3
    286a:	d002      	beq.n	2872 <__ext_attr_.config_00804000+0x86e>
    286c:	2b08      	cmp	r3, #8
    286e:	f47f abdd 	bne.w	202c <__ext_attr_.config_00804000+0x28>
                    *pSktEvent |= TCPIP_TCP_SIGNAL_TX_SPACE; 
    2872:	9b04      	ldr	r3, [sp, #16]
    2874:	f043 0204 	orr.w	r2, r3, #4
    2878:	b293      	uxth	r3, r2
    287a:	9304      	str	r3, [sp, #16]
    287c:	f7ff bbd6 	b.w	202c <__ext_attr_.config_00804000+0x28>
                if((int32_t)(SYS_TMR_TickCountGet() - pSkt->closeWaitTime) >= 0)
    2880:	f01f fcdc 	bl	2223c <SYS_TMR_TickCountGet>
    2884:	6b23      	ldr	r3, [r4, #48]	; 0x30
    2886:	1ac0      	subs	r0, r0, r3
    2888:	2800      	cmp	r0, #0
    288a:	f6bf ae6f 	bge.w	256c <__ext_attr_.config_00804000+0x568>
                    vFlags = ACK;
    288e:	2610      	movs	r6, #16
    2890:	e65e      	b.n	2550 <__ext_attr_.config_00804000+0x54c>
    2892:	bf00      	nop

Disassembly of section .text.TCPIP_IPERF_Task%213:

00002894 <TCPIP_IPERF_Task>:

}
#endif  // (TCPIP_STACK_DOWN_OPERATION != 0)

void TCPIP_IPERF_Task(void)
{
    2894:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2898:	ed2d 8b02 	vpush	{d8}
    289c:	b09b      	sub	sp, #108	; 0x6c
    TCPIP_MODULE_SIGNAL sigPend;

    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    289e:	210f      	movs	r1, #15
    28a0:	2020      	movs	r0, #32
    28a2:	f01d fc47 	bl	20134 <_TCPIPStackModuleSignalGet>

    if(sigPend != 0)
    28a6:	2800      	cmp	r0, #0
    28a8:	f000 8688 	beq.w	35bc <TCPIP_IPERF_Task+0xd28>
    {
		int i = 0;
		// ASYNC or RX signals occurred
	    tIperfState* pIState;	
        for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
    28ac:	4b82      	ldr	r3, [pc, #520]	; (2ab8 <TCPIP_IPERF_Task+0x224>)
    28ae:	681b      	ldr	r3, [r3, #0]
    28b0:	2b00      	cmp	r3, #0
    28b2:	f340 8683 	ble.w	35bc <TCPIP_IPERF_Task+0xd28>
    28b6:	4c81      	ldr	r4, [pc, #516]	; (2abc <TCPIP_IPERF_Task+0x228>)
    28b8:	2600      	movs	r6, #0
    uint16_t chunk;
    uint16_t remainingTxData;
    uint16_t txData = 0;

    /* Fill the buffer with ASCII char U */
    memset( g_bfr, 0x55, MAX_BUFFER);
    28ba:	4f81      	ldr	r7, [pc, #516]	; (2ac0 <TCPIP_IPERF_Task+0x22c>)
            (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: TCP Client connection timeout\r\n");
    28bc:	f8df 8210 	ldr.w	r8, [pc, #528]	; 2ad0 <TCPIP_IPERF_Task+0x23c>

      /* get the remainder of the ticks using modulus */
      tmp2 = ((pIState->stopTime - pIState->startTime) % tickFreq);

      /* normalize  to uSecs */
      tmp2 =  tmp2 * 1000 / tickFreq; /* Convert to mSec */
    28c0:	ed9f 8a80 	vldr	s16, [pc, #512]	; 2ac4 <TCPIP_IPERF_Task+0x230>
      }

      // never decrease pktId (e.g. if we get an out-of-order packet)
      if ( pIState->pktId == pIState->lastPktId )
      {
         (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Recv duplicated pkt\r\n");
    28c4:	f508 63ee 	add.w	r3, r8, #1904	; 0x770
    28c8:	9305      	str	r3, [sp, #20]
    28ca:	e3a3      	b.n	3014 <TCPIP_IPERF_Task+0x780>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    28cc:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    28d0:	685d      	ldr	r5, [r3, #4]
    if ( !pIState->mServerMode )
    28d2:	f894 20d1 	ldrb.w	r2, [r4, #209]	; 0xd1
    28d6:	b332      	cbz	r2, 2926 <TCPIP_IPERF_Task+0x92>
    switch ( pIState->mProtocol )
    28d8:	7c22      	ldrb	r2, [r4, #16]
    28da:	2a01      	cmp	r2, #1
    28dc:	d045      	beq.n	296a <TCPIP_IPERF_Task+0xd6>
    28de:	2a02      	cmp	r2, #2
    28e0:	d165      	bne.n	29ae <TCPIP_IPERF_Task+0x11a>
        if ( (pIState->tcpServerSock == INVALID_SOCKET) &&
    28e2:	f9b4 3038 	ldrsh.w	r3, [r4, #56]	; 0x38
    28e6:	f1b3 3fff 	cmp.w	r3, #4294967295
    28ea:	d027      	beq.n	293c <TCPIP_IPERF_Task+0xa8>
        TCPIP_TCP_SignalHandlerRegister(pIState->tcpServerSock, TCPIP_TCP_SIGNAL_RX_DATA, _IperfTCPRxSignalHandler, 0);
    28ec:	2300      	movs	r3, #0
    28ee:	4a76      	ldr	r2, [pc, #472]	; (2ac8 <TCPIP_IPERF_Task+0x234>)
    28f0:	f44f 7100 	mov.w	r1, #512	; 0x200
    28f4:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    28f8:	f01c fd38 	bl	1f36c <TCPIP_TCP_SignalHandlerRegister>
        if(!TCPIP_TCP_OptionsSet(pIState->tcpServerSock, TCP_OPTION_RX_BUFF, (void*)pIState->rxBuffSize))
    28fc:	f8d4 20bc 	ldr.w	r2, [r4, #188]	; 0xbc
    2900:	2102      	movs	r1, #2
    2902:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2906:	f012 fea0 	bl	1564a <TCPIP_TCP_OptionsSet>
    290a:	b938      	cbnz	r0, 291c <TCPIP_IPERF_Task+0x88>
            (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Set of RX buffer size failed\r\n");
    290c:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2910:	681b      	ldr	r3, [r3, #0]
    2912:	681b      	ldr	r3, [r3, #0]
    2914:	f508 61d8 	add.w	r1, r8, #1728	; 0x6c0
    2918:	4628      	mov	r0, r5
    291a:	4798      	blx	r3
        IperfSetState(pIState, IPERF_TCP_RX_LISTEN_STATE);
    291c:	2106      	movs	r1, #6
    291e:	4620      	mov	r0, r4
    2920:	f01b f9d0 	bl	1dcc4 <IperfSetState>
        break;
    2924:	e36f      	b.n	3006 <TCPIP_IPERF_Task+0x772>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Unsupported Configuration\r\n");
    2926:	681b      	ldr	r3, [r3, #0]
    2928:	681b      	ldr	r3, [r3, #0]
    292a:	f508 61cf 	add.w	r1, r8, #1656	; 0x678
    292e:	4628      	mov	r0, r5
    2930:	4798      	blx	r3
        IperfSetState(pIState, IPERF_STANDBY_STATE);
    2932:	2101      	movs	r1, #1
    2934:	4620      	mov	r0, r4
    2936:	f01b f9c5 	bl	1dcc4 <IperfSetState>
        return;
    293a:	e364      	b.n	3006 <TCPIP_IPERF_Task+0x772>
            (pIState->tcpServerSock = TCPIP_TCP_ServerOpen(IP_ADDRESS_TYPE_IPV4, pIState->mServerPort, (IP_MULTI_ADDRESS*)&pIState->localAddr)) == INVALID_SOCKET )
    293c:	f104 0280 	add.w	r2, r4, #128	; 0x80
    2940:	8a61      	ldrh	r1, [r4, #18]
    2942:	2001      	movs	r0, #1
    2944:	f016 fa1c 	bl	18d80 <TCPIP_TCP_ServerOpen>
    2948:	8720      	strh	r0, [r4, #56]	; 0x38
        if ( (pIState->tcpServerSock == INVALID_SOCKET) &&
    294a:	f1b0 3fff 	cmp.w	r0, #4294967295
    294e:	d1cd      	bne.n	28ec <TCPIP_IPERF_Task+0x58>
            (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Create TCP socket failed\r\n");
    2950:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2954:	681b      	ldr	r3, [r3, #0]
    2956:	681b      	ldr	r3, [r3, #0]
    2958:	f208 619c 	addw	r1, r8, #1692	; 0x69c
    295c:	4628      	mov	r0, r5
    295e:	4798      	blx	r3
            IperfSetState(pIState, IPERF_STANDBY_STATE);
    2960:	2101      	movs	r1, #1
    2962:	4620      	mov	r0, r4
    2964:	f01b f9ae 	bl	1dcc4 <IperfSetState>
            return;
    2968:	e34d      	b.n	3006 <TCPIP_IPERF_Task+0x772>
        if ( (pIState->udpSock = TCPIP_UDP_ServerOpen(IP_ADDRESS_TYPE_IPV4, pIState->mServerPort, (IP_MULTI_ADDRESS*)&pIState->localAddr)) == INVALID_UDP_SOCKET )
    296a:	f104 0280 	add.w	r2, r4, #128	; 0x80
    296e:	8a61      	ldrh	r1, [r4, #18]
    2970:	2001      	movs	r0, #1
    2972:	f021 fcf4 	bl	2435e <TCPIP_UDP_ServerOpen>
    2976:	87a0      	strh	r0, [r4, #60]	; 0x3c
    2978:	f1b0 3fff 	cmp.w	r0, #4294967295
    297c:	d00a      	beq.n	2994 <TCPIP_IPERF_Task+0x100>
        TCPIP_UDP_SignalHandlerRegister(pIState->udpSock, TCPIP_UDP_SIGNAL_RX_DATA, _IperfUDPRxSignalHandler, 0);
    297e:	2300      	movs	r3, #0
    2980:	4a52      	ldr	r2, [pc, #328]	; (2acc <TCPIP_IPERF_Task+0x238>)
    2982:	f44f 7180 	mov.w	r1, #256	; 0x100
    2986:	f01c fc68 	bl	1f25a <TCPIP_UDP_SignalHandlerRegister>
        IperfSetState(pIState, IPERF_UDP_RX_STATE);
    298a:	2103      	movs	r1, #3
    298c:	4620      	mov	r0, r4
    298e:	f01b f999 	bl	1dcc4 <IperfSetState>
        break;
    2992:	e338      	b.n	3006 <TCPIP_IPERF_Task+0x772>
            (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Create UDP socket failed\r\n");
    2994:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2998:	681b      	ldr	r3, [r3, #0]
    299a:	681b      	ldr	r3, [r3, #0]
    299c:	f508 61dd 	add.w	r1, r8, #1768	; 0x6e8
    29a0:	4628      	mov	r0, r5
    29a2:	4798      	blx	r3
             IperfSetState(pIState, IPERF_STANDBY_STATE);
    29a4:	2101      	movs	r1, #1
    29a6:	4620      	mov	r0, r4
    29a8:	f01b f98c 	bl	1dcc4 <IperfSetState>
            return;
    29ac:	e32b      	b.n	3006 <TCPIP_IPERF_Task+0x772>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Protocol error\r\n");
    29ae:	681b      	ldr	r3, [r3, #0]
    29b0:	681b      	ldr	r3, [r3, #0]
    29b2:	f208 710c 	addw	r1, r8, #1804	; 0x70c
    29b6:	4628      	mov	r0, r5
    29b8:	4798      	blx	r3
        IperfSetState(pIState, IPERF_STANDBY_STATE);
    29ba:	2101      	movs	r1, #1
    29bc:	4620      	mov	r0, r4
    29be:	f01b f981 	bl	1dcc4 <IperfSetState>
        return;
    29c2:	e320      	b.n	3006 <TCPIP_IPERF_Task+0x772>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    29c4:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    29c8:	f8d3 b004 	ldr.w	fp, [r3, #4]
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: instance %d session started ...\r\n", pIState - gIperfState);
    29cc:	4b3b      	ldr	r3, [pc, #236]	; (2abc <TCPIP_IPERF_Task+0x228>)
    29ce:	1ae3      	subs	r3, r4, r3
    29d0:	10db      	asrs	r3, r3, #3
    29d2:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
    29d6:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    29da:	ebc3 2343 	rsb	r3, r3, r3, lsl #9
    29de:	eb03 4383 	add.w	r3, r3, r3, lsl #18
    29e2:	f1c3 0a00 	rsb	sl, r3, #0
    29e6:	e086      	b.n	2af6 <TCPIP_IPERF_Task+0x262>
          (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: UDP Get Array Failed\r\n");
    29e8:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    29ec:	681b      	ldr	r3, [r3, #0]
    29ee:	681b      	ldr	r3, [r3, #0]
    29f0:	f208 7124 	addw	r1, r8, #1828	; 0x724
    29f4:	4658      	mov	r0, fp
    29f6:	4798      	blx	r3
          IperfSetState(pIState, IPERF_UDP_RX_DRAIN_STATE);
    29f8:	2104      	movs	r1, #4
    29fa:	4620      	mov	r0, r4
    29fc:	f01b f962 	bl	1dcc4 <IperfSetState>
          return;
    2a00:	e301      	b.n	3006 <TCPIP_IPERF_Task+0x772>
          TCPIP_UDP_Discard(pIState->udpSock);
    2a02:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2a06:	f01f ff98 	bl	2293a <TCPIP_UDP_Discard>
          return;
    2a0a:	e2fc      	b.n	3006 <TCPIP_IPERF_Task+0x772>
       pIState->pktCount++;
    2a0c:	3301      	adds	r3, #1
    2a0e:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      pIState->totalLen += length;
    2a12:	4628      	mov	r0, r5
    2a14:	f009 f84c 	bl	bab0 <__aeabi_i2d>
    2a18:	4602      	mov	r2, r0
    2a1a:	460b      	mov	r3, r1
    2a1c:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    2a20:	f008 fefa 	bl	b818 <__adddf3>
    2a24:	e9c4 0108 	strd	r0, r1, [r4, #32]
      if ( pIState->pktId < 0 )
    2a28:	f1b9 0f00 	cmp.w	r9, #0
    2a2c:	db1a      	blt.n	2a64 <TCPIP_IPERF_Task+0x1d0>
      if ( pIState->pktId != pIState->lastPktId+1 )
    2a2e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2a30:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    2a32:	1c51      	adds	r1, r2, #1
    2a34:	428b      	cmp	r3, r1
    2a36:	d030      	beq.n	2a9a <TCPIP_IPERF_Task+0x206>
         if ( pIState->pktId < pIState->lastPktId+1 )
    2a38:	4293      	cmp	r3, r2
    2a3a:	dc22      	bgt.n	2a82 <TCPIP_IPERF_Task+0x1ee>
            pIState->outofOrder++;
    2a3c:	6b61      	ldr	r1, [r4, #52]	; 0x34
    2a3e:	f101 0101 	add.w	r1, r1, #1
    2a42:	6361      	str	r1, [r4, #52]	; 0x34
      if ( pIState->pktId == pIState->lastPktId )
    2a44:	d02b      	beq.n	2a9e <TCPIP_IPERF_Task+0x20a>
    2a46:	e022      	b.n	2a8e <TCPIP_IPERF_Task+0x1fa>
             (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf: - First pkt id = %ld (should be 0)\r\n",
    2a48:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2a4c:	681b      	ldr	r3, [r3, #0]
    2a4e:	685b      	ldr	r3, [r3, #4]
    2a50:	f208 7144 	addw	r1, r8, #1860	; 0x744
    2a54:	4658      	mov	r0, fp
    2a56:	4798      	blx	r3
             pIState->errorCount	+= 	pIState->pktId - 1;
    2a58:	6b23      	ldr	r3, [r4, #48]	; 0x30
    2a5a:	3b01      	subs	r3, #1
    2a5c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    2a5e:	4413      	add	r3, r2
    2a60:	6323      	str	r3, [r4, #48]	; 0x30
    2a62:	e083      	b.n	2b6c <TCPIP_IPERF_Task+0x2d8>
         pIState->pktId = - pIState->pktId;
    2a64:	f1c9 0300 	rsb	r3, r9, #0
    2a68:	62a3      	str	r3, [r4, #40]	; 0x28
         pIState->stopTime = SYS_TMR_TickCountGet();
    2a6a:	f01f fbe7 	bl	2223c <SYS_TMR_TickCountGet>
    2a6e:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
        pIState->nAttempts = 0;
    2a72:	2300      	movs	r3, #0
    2a74:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
        IperfSetState(pIState, IPERF_UDP_RX_DRAIN_STATE);
    2a78:	2104      	movs	r1, #4
    2a7a:	4620      	mov	r0, r4
    2a7c:	f01b f922 	bl	1dcc4 <IperfSetState>
    2a80:	e7d5      	b.n	2a2e <TCPIP_IPERF_Task+0x19a>
            pIState->errorCount += pIState->pktId - (pIState->lastPktId+1);
    2a82:	1a5b      	subs	r3, r3, r1
    2a84:	6b22      	ldr	r2, [r4, #48]	; 0x30
    2a86:	4413      	add	r3, r2
    2a88:	6323      	str	r3, [r4, #48]	; 0x30
      }

      if ( pIState->pktId > pIState->lastPktId )
    2a8a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      {
         pIState->lastPktId = pIState->pktId;
    2a8c:	62e3      	str	r3, [r4, #44]	; 0x2c
      }

      /* read the remaining datagram payload - the full payload */
      /* a UdpDiscard would be disingenuous, because it would not reflect the bandwidth at L7 */
      length -=  sizeof(tIperfPktInfo);
    2a8e:	3d0c      	subs	r5, #12
    2a90:	b2ad      	uxth	r5, r5
      while ( length > 0 )
    2a92:	b385      	cbz	r5, 2af6 <TCPIP_IPERF_Task+0x262>
         if ( length <  (uint16_t)MAX_BUFFER )
            chunk = length;
         else
            chunk = MAX_BUFFER;

         TCPIP_UDP_ArrayGet(pIState->udpSock, (uint8_t*)g_bfr, chunk);
    2a94:	f04f 0934 	mov.w	r9, #52	; 0x34
    2a98:	e025      	b.n	2ae6 <TCPIP_IPERF_Task+0x252>
      if ( pIState->pktId == pIState->lastPktId )
    2a9a:	4293      	cmp	r3, r2
    2a9c:	d106      	bne.n	2aac <TCPIP_IPERF_Task+0x218>
         (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Recv duplicated pkt\r\n");
    2a9e:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2aa2:	681b      	ldr	r3, [r3, #0]
    2aa4:	681b      	ldr	r3, [r3, #0]
    2aa6:	9905      	ldr	r1, [sp, #20]
    2aa8:	4658      	mov	r0, fp
    2aaa:	4798      	blx	r3
      if ( pIState->pktId > pIState->lastPktId )
    2aac:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2aae:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    2ab0:	4293      	cmp	r3, r2
    2ab2:	ddec      	ble.n	2a8e <TCPIP_IPERF_Task+0x1fa>
    2ab4:	e7ea      	b.n	2a8c <TCPIP_IPERF_Task+0x1f8>
    2ab6:	bf00      	nop
    2ab8:	2000ee24 	.word	0x2000ee24
    2abc:	2000e380 	.word	0x2000e380
    2ac0:	2000ea38 	.word	0x2000ea38
    2ac4:	447a0000 	.word	0x447a0000
    2ac8:	0002394f 	.word	0x0002394f
    2acc:	00023939 	.word	0x00023939
    2ad0:	00005afc 	.word	0x00005afc
         TCPIP_UDP_ArrayGet(pIState->udpSock, (uint8_t*)g_bfr, chunk);
    2ad4:	464a      	mov	r2, r9
    2ad6:	4639      	mov	r1, r7
    2ad8:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2adc:	f013 ffae 	bl	16a3c <TCPIP_UDP_ArrayGet>
         length -= chunk;
    2ae0:	3d34      	subs	r5, #52	; 0x34
    2ae2:	b2ad      	uxth	r5, r5
      while ( length > 0 )
    2ae4:	b13d      	cbz	r5, 2af6 <TCPIP_IPERF_Task+0x262>
         if ( length <  (uint16_t)MAX_BUFFER )
    2ae6:	2d33      	cmp	r5, #51	; 0x33
    2ae8:	d8f4      	bhi.n	2ad4 <TCPIP_IPERF_Task+0x240>
         TCPIP_UDP_ArrayGet(pIState->udpSock, (uint8_t*)g_bfr, chunk);
    2aea:	462a      	mov	r2, r5
    2aec:	4639      	mov	r1, r7
    2aee:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2af2:	f013 ffa3 	bl	16a3c <TCPIP_UDP_ArrayGet>
    while( (length = TCPIP_UDP_GetIsReady(pIState->udpSock)) >= (uint16_t)(sizeof(tIperfPktInfo)) )
    2af6:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2afa:	f01f fb4f 	bl	2219c <TCPIP_UDP_GetIsReady>
    2afe:	4605      	mov	r5, r0
    2b00:	280b      	cmp	r0, #11
    2b02:	f240 8082 	bls.w	2c0a <TCPIP_IPERF_Task+0x376>
       if ( TCPIP_UDP_ArrayGet(pIState->udpSock, (uint8_t*)g_bfr, sizeof(tIperfPktInfo)) != sizeof(tIperfPktInfo) )
    2b06:	220c      	movs	r2, #12
    2b08:	4639      	mov	r1, r7
    2b0a:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2b0e:	f013 ff95 	bl	16a3c <TCPIP_UDP_ArrayGet>
    2b12:	280c      	cmp	r0, #12
    2b14:	f47f af68 	bne.w	29e8 <TCPIP_IPERF_Task+0x154>
       pIState->pktId = TCPIP_Helper_htonl(pPktInfo->id);
    2b18:	683b      	ldr	r3, [r7, #0]
    return (((hLong & 0x000000ff) << 24) | ((hLong & 0x0000ff00) << 8) | ((hLong & 0x00ff0000) >> 8) | ((hLong & 0xff000000) >> 24));
    2b1a:	ea4f 6913 	mov.w	r9, r3, lsr #24
    2b1e:	ea49 6903 	orr.w	r9, r9, r3, lsl #24
    2b22:	021a      	lsls	r2, r3, #8
    2b24:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
    2b28:	ea49 0902 	orr.w	r9, r9, r2
    2b2c:	0a1b      	lsrs	r3, r3, #8
    2b2e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2b32:	ea49 0903 	orr.w	r9, r9, r3
    2b36:	f8c4 9028 	str.w	r9, [r4, #40]	; 0x28
       if ( (pIState->pktCount == (uint32_t)0) && (pIState->pktId < (long)0) )
    2b3a:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    2b3e:	2b00      	cmp	r3, #0
    2b40:	f47f af64 	bne.w	2a0c <TCPIP_IPERF_Task+0x178>
    2b44:	f1b9 0f00 	cmp.w	r9, #0
    2b48:	f6ff af5b 	blt.w	2a02 <TCPIP_IPERF_Task+0x16e>
       pIState->pktCount++;
    2b4c:	2301      	movs	r3, #1
    2b4e:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: instance %d session started ...\r\n", pIState - gIperfState);
    2b52:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2b56:	681b      	ldr	r3, [r3, #0]
    2b58:	685b      	ldr	r3, [r3, #4]
    2b5a:	4652      	mov	r2, sl
    2b5c:	f508 61f5 	add.w	r1, r8, #1960	; 0x7a8
    2b60:	4658      	mov	r0, fp
    2b62:	4798      	blx	r3
          if ( pIState->pktId != 0 )
    2b64:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    2b66:	2a00      	cmp	r2, #0
    2b68:	f47f af6e 	bne.w	2a48 <TCPIP_IPERF_Task+0x1b4>
          pIState->lastPktId = pIState->pktId;
    2b6c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2b6e:	62e3      	str	r3, [r4, #44]	; 0x2c
		  TCPIP_UDP_SocketInfoGet(pIState->udpSock, &UdpSkt);
    2b70:	a906      	add	r1, sp, #24
    2b72:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2b76:	f01a f969 	bl	1ce4c <TCPIP_UDP_SocketInfoGet>
          lclIpAddr.Val = TCPIP_STACK_NetAddress(TCPIP_UDP_SocketNetGet(pIState->udpSock));
    2b7a:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2b7e:	f021 f90f 	bl	23da0 <TCPIP_UDP_SocketNetGet>
    2b82:	f020 f98a 	bl	22e9a <TCPIP_STACK_NetAddress>
          remIpAddr.Val = UdpSkt.remoteIPaddress.v4Add.Val;
    2b86:	9d07      	ldr	r5, [sp, #28]
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Local  %u.%u.%u.%u port %u connected with\r\n",
    2b88:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2b8c:	681b      	ldr	r3, [r3, #0]
    2b8e:	8a62      	ldrh	r2, [r4, #18]
    2b90:	9202      	str	r2, [sp, #8]
    2b92:	0e02      	lsrs	r2, r0, #24
    2b94:	9201      	str	r2, [sp, #4]
    2b96:	f3c0 4207 	ubfx	r2, r0, #16, #8
    2b9a:	9200      	str	r2, [sp, #0]
    2b9c:	f8d3 9004 	ldr.w	r9, [r3, #4]
    2ba0:	f3c0 2307 	ubfx	r3, r0, #8, #8
    2ba4:	b2c2      	uxtb	r2, r0
    2ba6:	f208 515c 	addw	r1, r8, #1372	; 0x55c
    2baa:	4658      	mov	r0, fp
    2bac:	47c8      	blx	r9
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Remote %u.%u.%u.%u port %u\r\n",      
    2bae:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2bb2:	681b      	ldr	r3, [r3, #0]
    2bb4:	f8bd 205c 	ldrh.w	r2, [sp, #92]	; 0x5c
    2bb8:	9202      	str	r2, [sp, #8]
    2bba:	0e2a      	lsrs	r2, r5, #24
    2bbc:	9201      	str	r2, [sp, #4]
    2bbe:	f3c5 4207 	ubfx	r2, r5, #16, #8
    2bc2:	9200      	str	r2, [sp, #0]
    2bc4:	f8d3 9004 	ldr.w	r9, [r3, #4]
    2bc8:	f3c5 2307 	ubfx	r3, r5, #8, #8
    2bcc:	b2ea      	uxtb	r2, r5
    2bce:	f508 61b2 	add.w	r1, r8, #1424	; 0x590
    2bd2:	4658      	mov	r0, fp
    2bd4:	47c8      	blx	r9
          pIState->remoteSide.remoteIPaddress.v4Add.Val = remIpAddr.Val;
    2bd6:	6465      	str	r5, [r4, #68]	; 0x44
          pIState->remoteSide.remotePort =  UdpSkt.remotePort;
    2bd8:	f8bd 305c 	ldrh.w	r3, [sp, #92]	; 0x5c
    2bdc:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
          pIState->startTime = SYS_TMR_TickCountGet();
    2be0:	f01f fb2c 	bl	2223c <SYS_TMR_TickCountGet>
    2be4:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
          pIState->lastCheckTime = 	pIState->startTime;
    2be8:	f8c4 00a8 	str.w	r0, [r4, #168]	; 0xa8
          pIState->lastCheckPktId = pIState->pktId;
    2bec:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2bee:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
          pIState->lastCheckPktCount = pIState->pktCount;
    2bf2:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    2bf6:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
          pIState->lastCheckErrorCount = pIState->errorCount;
    2bfa:	6b23      	ldr	r3, [r4, #48]	; 0x30
    2bfc:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
          TCPIP_UDP_Discard(pIState->udpSock);
    2c00:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2c04:	f01f fe99 	bl	2293a <TCPIP_UDP_Discard>
          continue;
    2c08:	e775      	b.n	2af6 <TCPIP_IPERF_Task+0x262>
      }


    }  /* end got a datagram */

    if ( (pIState->pktCount != (uint32_t)0) &&
    2c0a:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    2c0e:	b94b      	cbnz	r3, 2c24 <TCPIP_IPERF_Task+0x390>
        {
          ReportBW_Jitter_Loss(pIState, INTERVAL_REPORT);
        }
    }

    if ( pIState->stopRequested == true )
    2c10:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
    2c14:	2b01      	cmp	r3, #1
    2c16:	f040 81f6 	bne.w	3006 <TCPIP_IPERF_Task+0x772>
    {
        IperfSetState(pIState, IPERF_UDP_RX_DRAIN_STATE);
    2c1a:	2104      	movs	r1, #4
    2c1c:	4620      	mov	r0, r4
    2c1e:	f01b f851 	bl	1dcc4 <IperfSetState>
        return;
    2c22:	e1f0      	b.n	3006 <TCPIP_IPERF_Task+0x772>
         ((int32_t)(SYS_TMR_TickCountGet() - pIState->lastCheckTime) > pIState->mInterval) )
    2c24:	f01f fb0a 	bl	2223c <SYS_TMR_TickCountGet>
    2c28:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
    2c2c:	1ac3      	subs	r3, r0, r3
    if ( (pIState->pktCount != (uint32_t)0) &&
    2c2e:	6822      	ldr	r2, [r4, #0]
    2c30:	4293      	cmp	r3, r2
    2c32:	d9ed      	bls.n	2c10 <TCPIP_IPERF_Task+0x37c>
        if ( pIState->pktCount == pIState->lastCheckPktCount )
    2c34:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
    2c38:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
    2c3c:	429a      	cmp	r2, r3
    2c3e:	d113      	bne.n	2c68 <TCPIP_IPERF_Task+0x3d4>
          (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Rx timed out\r\n");
    2c40:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2c44:	681b      	ldr	r3, [r3, #0]
    2c46:	681b      	ldr	r3, [r3, #0]
    2c48:	f508 61f2 	add.w	r1, r8, #1936	; 0x790
    2c4c:	4658      	mov	r0, fp
    2c4e:	4798      	blx	r3
          pIState->stopTime = SYS_TMR_TickCountGet();
    2c50:	f01f faf4 	bl	2223c <SYS_TMR_TickCountGet>
    2c54:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
          pIState->nAttempts = 0;
    2c58:	2300      	movs	r3, #0
    2c5a:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
          IperfSetState(pIState, IPERF_UDP_RX_DRAIN_STATE);
    2c5e:	2104      	movs	r1, #4
    2c60:	4620      	mov	r0, r4
    2c62:	f01b f82f 	bl	1dcc4 <IperfSetState>
    2c66:	e7d3      	b.n	2c10 <TCPIP_IPERF_Task+0x37c>
          ReportBW_Jitter_Loss(pIState, INTERVAL_REPORT);
    2c68:	2100      	movs	r1, #0
    2c6a:	4620      	mov	r0, r4
    2c6c:	f00b fc18 	bl	e4a0 <ReportBW_Jitter_Loss>
    2c70:	e7ce      	b.n	2c10 <TCPIP_IPERF_Task+0x37c>
    if( TCPIP_UDP_GetIsReady(pIState->udpSock) > (uint8_t)0 )
    2c72:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2c76:	f01f fa91 	bl	2219c <TCPIP_UDP_GetIsReady>
    2c7a:	b938      	cbnz	r0, 2c8c <TCPIP_IPERF_Task+0x3f8>
   if ( pIState->stopRequested )
    2c7c:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
    2c80:	b14b      	cbz	r3, 2c96 <TCPIP_IPERF_Task+0x402>
       IperfSetState(pIState, IPERF_RX_DONE_STATE);
    2c82:	2109      	movs	r1, #9
    2c84:	4620      	mov	r0, r4
    2c86:	f01b f81d 	bl	1dcc4 <IperfSetState>
    2c8a:	e1bc      	b.n	3006 <TCPIP_IPERF_Task+0x772>
         TCPIP_UDP_Discard(pIState->udpSock);
    2c8c:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2c90:	f01f fe53 	bl	2293a <TCPIP_UDP_Discard>
         return;
    2c94:	e1b7      	b.n	3006 <TCPIP_IPERF_Task+0x772>
       IperfSetState(pIState, IPERF_UDP_RX_DONE_STATE);
    2c96:	2105      	movs	r1, #5
    2c98:	4620      	mov	r0, r4
    2c9a:	f01b f813 	bl	1dcc4 <IperfSetState>
    2c9e:	e1b2      	b.n	3006 <TCPIP_IPERF_Task+0x772>
    if ( pIState->statusReported == 0u )
    2ca0:	f894 30cd 	ldrb.w	r3, [r4, #205]	; 0xcd
    2ca4:	2b00      	cmp	r3, #0
    2ca6:	f000 80b5 	beq.w	2e14 <TCPIP_IPERF_Task+0x580>
    if (  TCPIP_UDP_GetIsReady(pIState->udpSock)  )
    2caa:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2cae:	f01f fa75 	bl	2219c <TCPIP_UDP_GetIsReady>
    2cb2:	2800      	cmp	r0, #0
    2cb4:	f040 80b6 	bne.w	2e24 <TCPIP_IPERF_Task+0x590>
    if ( pIState->nAttempts++ > 10u )
    2cb8:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
    2cbc:	1c5a      	adds	r2, r3, #1
    2cbe:	f884 20cc 	strb.w	r2, [r4, #204]	; 0xcc
    2cc2:	2b0a      	cmp	r3, #10
    2cc4:	f200 80b3 	bhi.w	2e2e <TCPIP_IPERF_Task+0x59a>
    if ( TCPIP_UDP_TxPutIsReady(pIState->udpSock, 128 ) > 0u )
    2cc8:	2180      	movs	r1, #128	; 0x80
    2cca:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2cce:	f021 fb83 	bl	243d8 <TCPIP_UDP_TxPutIsReady>
    2cd2:	2800      	cmp	r0, #0
    2cd4:	f000 8197 	beq.w	3006 <TCPIP_IPERF_Task+0x772>
      pPktInfo->id = TCPIP_Helper_htonl( -pIState->lastPktId );
    2cd8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2cda:	425b      	negs	r3, r3
    2cdc:	0e1a      	lsrs	r2, r3, #24
    2cde:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    2ce2:	0219      	lsls	r1, r3, #8
    2ce4:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    2ce8:	430a      	orrs	r2, r1
    2cea:	0a1b      	lsrs	r3, r3, #8
    2cec:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2cf0:	4313      	orrs	r3, r2
    2cf2:	603b      	str	r3, [r7, #0]
      pPktInfo->tv_sec = 0;
    2cf4:	2500      	movs	r5, #0
    2cf6:	607d      	str	r5, [r7, #4]
      pPktInfo->tv_usec = 0;
    2cf8:	60bd      	str	r5, [r7, #8]
      pServer_hdr->flags = TCPIP_Helper_htonl(HEADER_VERSION1);
    2cfa:	2380      	movs	r3, #128	; 0x80
    2cfc:	60fb      	str	r3, [r7, #12]
      pServer_hdr->total_len1 = 0;
    2cfe:	613d      	str	r5, [r7, #16]
      pServer_hdr->total_len2 = TCPIP_Helper_htonl( (uint32_t) pIState->totalLen);
    2d00:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    2d04:	f01c ffee 	bl	1fce4 <__aeabi_d2uiz>
    2d08:	0e02      	lsrs	r2, r0, #24
    2d0a:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    2d0e:	0203      	lsls	r3, r0, #8
    2d10:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    2d14:	431a      	orrs	r2, r3
    2d16:	0a03      	lsrs	r3, r0, #8
    2d18:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2d1c:	4313      	orrs	r3, r2
    2d1e:	617b      	str	r3, [r7, #20]
      uint32_t tickFreq = SYS_TMR_TickCounterFrequencyGet(); 
    2d20:	f01f fab4 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
      pServer_hdr->stop_sec =  TCPIP_Helper_htonl( (uint32_t) (pIState->stopTime - pIState->startTime) / tickFreq);
    2d24:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
    2d28:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    2d2c:	1ac9      	subs	r1, r1, r3
    2d2e:	fbb1 f3f0 	udiv	r3, r1, r0
    2d32:	0e1a      	lsrs	r2, r3, #24
    2d34:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    2d38:	ea4f 2c03 	mov.w	ip, r3, lsl #8
    2d3c:	f40c 0c7f 	and.w	ip, ip, #16711680	; 0xff0000
    2d40:	ea42 020c 	orr.w	r2, r2, ip
    2d44:	ea4f 2c13 	mov.w	ip, r3, lsr #8
    2d48:	f40c 4c7f 	and.w	ip, ip, #65280	; 0xff00
    2d4c:	ea42 020c 	orr.w	r2, r2, ip
    2d50:	61ba      	str	r2, [r7, #24]
      tmp2 = ((pIState->stopTime - pIState->startTime) % tickFreq);
    2d52:	fb00 1313 	mls	r3, r0, r3, r1
    2d56:	ee07 3a10 	vmov	s14, r3
    2d5a:	eeb8 7a47 	vcvt.f32.u32	s14, s14
      tmp2 =  tmp2 * 1000 / tickFreq; /* Convert to mSec */
    2d5e:	ee27 7a08 	vmul.f32	s14, s14, s16
    2d62:	ee07 0a90 	vmov	s15, r0
    2d66:	eef8 6a67 	vcvt.f32.u32	s13, s15
    2d6a:	eec7 7a26 	vdiv.f32	s15, s14, s13
      tmp2 *= 1000;   /* 1000 uSecs per mSec */
    2d6e:	ee67 7a88 	vmul.f32	s15, s15, s16
      pServer_hdr->stop_usec = TCPIP_Helper_htonl( (uint32_t) tmp2 );
    2d72:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    2d76:	ee17 3a90 	vmov	r3, s15
    2d7a:	0e1a      	lsrs	r2, r3, #24
    2d7c:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    2d80:	0219      	lsls	r1, r3, #8
    2d82:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    2d86:	430a      	orrs	r2, r1
    2d88:	0a1b      	lsrs	r3, r3, #8
    2d8a:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2d8e:	4313      	orrs	r3, r2
    2d90:	61fb      	str	r3, [r7, #28]
      pServer_hdr->error_cnt = TCPIP_Helper_htonl( (uint32_t)  pIState->errorCount);;
    2d92:	6b23      	ldr	r3, [r4, #48]	; 0x30
    2d94:	0e1a      	lsrs	r2, r3, #24
    2d96:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    2d9a:	0219      	lsls	r1, r3, #8
    2d9c:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    2da0:	430a      	orrs	r2, r1
    2da2:	0a1b      	lsrs	r3, r3, #8
    2da4:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2da8:	4313      	orrs	r3, r2
    2daa:	623b      	str	r3, [r7, #32]
      pServer_hdr->outorder_cnt = TCPIP_Helper_htonl( (uint32_t) pIState->outofOrder);
    2dac:	6b63      	ldr	r3, [r4, #52]	; 0x34
    2dae:	0e1a      	lsrs	r2, r3, #24
    2db0:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    2db4:	0219      	lsls	r1, r3, #8
    2db6:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    2dba:	430a      	orrs	r2, r1
    2dbc:	0a1b      	lsrs	r3, r3, #8
    2dbe:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2dc2:	4313      	orrs	r3, r2
    2dc4:	627b      	str	r3, [r7, #36]	; 0x24
      pServer_hdr->datagrams = TCPIP_Helper_htonl( (uint32_t) pIState->lastPktId);
    2dc6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2dc8:	0e1a      	lsrs	r2, r3, #24
    2dca:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    2dce:	0219      	lsls	r1, r3, #8
    2dd0:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    2dd4:	430a      	orrs	r2, r1
    2dd6:	0a1b      	lsrs	r3, r3, #8
    2dd8:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2ddc:	4313      	orrs	r3, r2
    2dde:	62bb      	str	r3, [r7, #40]	; 0x28
      pServer_hdr->jitter1 = 0;
    2de0:	62fd      	str	r5, [r7, #44]	; 0x2c
      pServer_hdr->jitter2 = 0;
    2de2:	633d      	str	r5, [r7, #48]	; 0x30
      TCPIP_UDP_ArrayPut(pIState->udpSock, (uint8_t*)g_bfr, MAX_BUFFER);
    2de4:	2234      	movs	r2, #52	; 0x34
    2de6:	4639      	mov	r1, r7
    2de8:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2dec:	f01b fe25 	bl	1ea3a <TCPIP_UDP_ArrayPut>
      memset(tmpBuffer, 0, sizeof(tmpBuffer));
    2df0:	f04f 094c 	mov.w	r9, #76	; 0x4c
    2df4:	464a      	mov	r2, r9
    2df6:	4629      	mov	r1, r5
    2df8:	a806      	add	r0, sp, #24
    2dfa:	f021 f851 	bl	23ea0 <memset>
      TCPIP_UDP_ArrayPut(pIState->udpSock, tmpBuffer, sizeof(tmpBuffer));
    2dfe:	464a      	mov	r2, r9
    2e00:	a906      	add	r1, sp, #24
    2e02:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2e06:	f01b fe18 	bl	1ea3a <TCPIP_UDP_ArrayPut>
      TCPIP_UDP_Flush(pIState->udpSock );
    2e0a:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2e0e:	f00c fc93 	bl	f738 <TCPIP_UDP_Flush>
    2e12:	e0f8      	b.n	3006 <TCPIP_IPERF_Task+0x772>
        ReportBW_Jitter_Loss(pIState, SESSION_REPORT);
    2e14:	2102      	movs	r1, #2
    2e16:	4620      	mov	r0, r4
    2e18:	f00b fb42 	bl	e4a0 <ReportBW_Jitter_Loss>
        pIState->statusReported = 1;
    2e1c:	2301      	movs	r3, #1
    2e1e:	f884 30cd 	strb.w	r3, [r4, #205]	; 0xcd
    2e22:	e742      	b.n	2caa <TCPIP_IPERF_Task+0x416>
        TCPIP_UDP_Discard(pIState->udpSock);
    2e24:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2e28:	f01f fd87 	bl	2293a <TCPIP_UDP_Discard>
        return;
    2e2c:	e0eb      	b.n	3006 <TCPIP_IPERF_Task+0x772>
        IperfSetState(pIState, IPERF_RX_DONE_STATE);
    2e2e:	2109      	movs	r1, #9
    2e30:	4620      	mov	r0, r4
    2e32:	f01a ff47 	bl	1dcc4 <IperfSetState>
        return;
    2e36:	e0e6      	b.n	3006 <TCPIP_IPERF_Task+0x772>
   if ( pIState->stopRequested == true )
    2e38:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
    2e3c:	2b01      	cmp	r3, #1
    2e3e:	d024      	beq.n	2e8a <TCPIP_IPERF_Task+0x5f6>
   if( TCPIP_TCP_IsConnected(pIState->tcpServerSock) )
    2e40:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2e44:	f01f fac2 	bl	223cc <TCPIP_TCP_IsConnected>
    2e48:	2800      	cmp	r0, #0
    2e4a:	f000 80dc 	beq.w	3006 <TCPIP_IPERF_Task+0x772>
	  TCPIP_TCP_SocketInfoGet( pIState->tcpServerSock, &tcpSocketInfo);
    2e4e:	a906      	add	r1, sp, #24
    2e50:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2e54:	f018 fbd2 	bl	1b5fc <TCPIP_TCP_SocketInfoGet>
      memcpy ( (void *) &pIState->remoteSide, &tcpSocketInfo, sizeof ( TCP_SOCKET_INFO) );
    2e58:	f104 0c40 	add.w	ip, r4, #64	; 0x40
    2e5c:	ad06      	add	r5, sp, #24
    2e5e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2e60:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2e64:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2e66:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2e6a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2e6c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2e70:	e895 0003 	ldmia.w	r5, {r0, r1}
    2e74:	e88c 0003 	stmia.w	ip, {r0, r1}
      IperfSetState(pIState, IPERF_TCP_RX_STATE);
    2e78:	2107      	movs	r1, #7
    2e7a:	4620      	mov	r0, r4
    2e7c:	f01a ff22 	bl	1dcc4 <IperfSetState>
      TCPIP_TCP_WasReset(pIState->tcpServerSock);
    2e80:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2e84:	f01e ff41 	bl	21d0a <TCPIP_TCP_WasReset>
    2e88:	e0bd      	b.n	3006 <TCPIP_IPERF_Task+0x772>
        IperfSetState(pIState, IPERF_RX_DONE_STATE);
    2e8a:	2109      	movs	r1, #9
    2e8c:	4620      	mov	r0, r4
    2e8e:	f01a ff19 	bl	1dcc4 <IperfSetState>
        return;
    2e92:	e0b8      	b.n	3006 <TCPIP_IPERF_Task+0x772>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    2e94:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2e98:	f8d3 9004 	ldr.w	r9, [r3, #4]
    if( (length = TCPIP_TCP_GetIsReady(pIState->tcpServerSock)) == 0 )
    2e9c:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2ea0:	f020 fec9 	bl	23c36 <TCPIP_TCP_GetIsReady>
    2ea4:	4605      	mov	r5, r0
    2ea6:	2800      	cmp	r0, #0
    2ea8:	d066      	beq.n	2f78 <TCPIP_IPERF_Task+0x6e4>
       if ( pIState->pktId == 0)
    2eaa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2eac:	2b00      	cmp	r3, #0
    2eae:	d14c      	bne.n	2f4a <TCPIP_IPERF_Task+0x6b6>
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: instance %d session started ...\r\n", pIState - gIperfState);
    2eb0:	4bc7      	ldr	r3, [pc, #796]	; (31d0 <TCPIP_IPERF_Task+0x93c>)
    2eb2:	1ae3      	subs	r3, r4, r3
    2eb4:	10db      	asrs	r3, r3, #3
    2eb6:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
    2eba:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    2ebe:	ebc3 2343 	rsb	r3, r3, r3, lsl #9
    2ec2:	eb03 4383 	add.w	r3, r3, r3, lsl #18
    2ec6:	f8d4 20c4 	ldr.w	r2, [r4, #196]	; 0xc4
    2eca:	6812      	ldr	r2, [r2, #0]
    2ecc:	f8d2 a004 	ldr.w	sl, [r2, #4]
    2ed0:	425a      	negs	r2, r3
    2ed2:	f508 61f5 	add.w	r1, r8, #1960	; 0x7a8
    2ed6:	4648      	mov	r0, r9
    2ed8:	47d0      	blx	sl
          pIState->startTime = SYS_TMR_TickCountGet();
    2eda:	f01f f9af 	bl	2223c <SYS_TMR_TickCountGet>
    2ede:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
          pIState->lastCheckTime = 	pIState->startTime;
    2ee2:	f8c4 00a8 	str.w	r0, [r4, #168]	; 0xa8
          pIState->lastCheckPktId = pIState->pktId;
    2ee6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2ee8:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
          lclAddress.Val = TCPIP_STACK_NetAddress(TCPIP_TCP_SocketNetGet(pIState->tcpServerSock));
    2eec:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2ef0:	f020 ff2e 	bl	23d50 <TCPIP_TCP_SocketNetGet>
    2ef4:	f01f ffd1 	bl	22e9a <TCPIP_STACK_NetAddress>
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Local  %u.%u.%u.%u port %u connected with\r\n",
    2ef8:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2efc:	681b      	ldr	r3, [r3, #0]
    2efe:	8a62      	ldrh	r2, [r4, #18]
    2f00:	9202      	str	r2, [sp, #8]
    2f02:	0e02      	lsrs	r2, r0, #24
    2f04:	9201      	str	r2, [sp, #4]
    2f06:	f3c0 4207 	ubfx	r2, r0, #16, #8
    2f0a:	9200      	str	r2, [sp, #0]
    2f0c:	f8d3 a004 	ldr.w	sl, [r3, #4]
    2f10:	f3c0 2307 	ubfx	r3, r0, #8, #8
    2f14:	b2c2      	uxtb	r2, r0
    2f16:	f208 515c 	addw	r1, r8, #1372	; 0x55c
    2f1a:	4648      	mov	r0, r9
    2f1c:	47d0      	blx	sl
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Remote %u.%u.%u.%u port %u\r\n",
    2f1e:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2f22:	681b      	ldr	r3, [r3, #0]
    2f24:	f8b4 2064 	ldrh.w	r2, [r4, #100]	; 0x64
    2f28:	9202      	str	r2, [sp, #8]
    2f2a:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
    2f2e:	9201      	str	r2, [sp, #4]
    2f30:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
    2f34:	9200      	str	r2, [sp, #0]
    2f36:	f8d3 a004 	ldr.w	sl, [r3, #4]
    2f3a:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    2f3e:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
    2f42:	f508 61b2 	add.w	r1, r8, #1424	; 0x590
    2f46:	4648      	mov	r0, r9
    2f48:	47d0      	blx	sl
       pIState->pktId++;
    2f4a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2f4c:	3301      	adds	r3, #1
    2f4e:	62a3      	str	r3, [r4, #40]	; 0x28
       pIState->pktCount++;
    2f50:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
    2f54:	3201      	adds	r2, #1
    2f56:	f8c4 2094 	str.w	r2, [r4, #148]	; 0x94
       pIState->lastPktId = pIState->pktId;
    2f5a:	62e3      	str	r3, [r4, #44]	; 0x2c
       pIState->totalLen += length;
    2f5c:	4628      	mov	r0, r5
    2f5e:	f008 fda7 	bl	bab0 <__aeabi_i2d>
    2f62:	4602      	mov	r2, r0
    2f64:	460b      	mov	r3, r1
    2f66:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    2f6a:	f008 fc55 	bl	b818 <__adddf3>
    2f6e:	e9c4 0108 	strd	r0, r1, [r4, #32]
          TCPIP_TCP_ArrayGet( pIState->tcpServerSock, (uint8_t*)g_bfr, chunk);
    2f72:	f04f 0934 	mov.w	r9, #52	; 0x34
    2f76:	e01b      	b.n	2fb0 <TCPIP_IPERF_Task+0x71c>
      if ( TCPIP_TCP_WasReset(pIState->tcpServerSock) || TCPIP_TCP_WasDisconnected(pIState->tcpServerSock)  )
    2f78:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2f7c:	f01e fec5 	bl	21d0a <TCPIP_TCP_WasReset>
    2f80:	b920      	cbnz	r0, 2f8c <TCPIP_IPERF_Task+0x6f8>
    2f82:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2f86:	f020 fccc 	bl	23922 <TCPIP_TCP_WasDisconnected>
    2f8a:	b1c8      	cbz	r0, 2fc0 <TCPIP_IPERF_Task+0x72c>
          pIState->stopTime = SYS_TMR_TickCountGet();
    2f8c:	f01f f956 	bl	2223c <SYS_TMR_TickCountGet>
    2f90:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
          IperfSetState(pIState, IPERF_TCP_RX_DONE_STATE);
    2f94:	2108      	movs	r1, #8
    2f96:	4620      	mov	r0, r4
    2f98:	f01a fe94 	bl	1dcc4 <IperfSetState>
          return;
    2f9c:	e033      	b.n	3006 <TCPIP_IPERF_Task+0x772>
          TCPIP_TCP_ArrayGet( pIState->tcpServerSock, (uint8_t*)g_bfr, chunk);
    2f9e:	464a      	mov	r2, r9
    2fa0:	4639      	mov	r1, r7
    2fa2:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2fa6:	f014 f90d 	bl	171c4 <TCPIP_TCP_ArrayGet>
          length -= chunk;
    2faa:	3d34      	subs	r5, #52	; 0x34
    2fac:	b2ad      	uxth	r5, r5
       while ( length > 0 )
    2fae:	b13d      	cbz	r5, 2fc0 <TCPIP_IPERF_Task+0x72c>
          if ( length <  (uint16_t)MAX_BUFFER )
    2fb0:	2d33      	cmp	r5, #51	; 0x33
    2fb2:	d8f4      	bhi.n	2f9e <TCPIP_IPERF_Task+0x70a>
          TCPIP_TCP_ArrayGet( pIState->tcpServerSock, (uint8_t*)g_bfr, chunk);
    2fb4:	462a      	mov	r2, r5
    2fb6:	4639      	mov	r1, r7
    2fb8:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2fbc:	f014 f902 	bl	171c4 <TCPIP_TCP_ArrayGet>
    if ((pIState->pktId != (long)0) &&
    2fc0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2fc2:	b963      	cbnz	r3, 2fde <TCPIP_IPERF_Task+0x74a>
    if ( pIState->stopRequested == true )
    2fc4:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
    2fc8:	2b01      	cmp	r3, #1
    2fca:	d11c      	bne.n	3006 <TCPIP_IPERF_Task+0x772>
       IperfSetState(pIState, IPERF_TCP_RX_DONE_STATE);
    2fcc:	2108      	movs	r1, #8
    2fce:	4620      	mov	r0, r4
    2fd0:	f01a fe78 	bl	1dcc4 <IperfSetState>
       pIState->stopTime = SYS_TMR_TickCountGet();
    2fd4:	f01f f932 	bl	2223c <SYS_TMR_TickCountGet>
    2fd8:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
       return;
    2fdc:	e013      	b.n	3006 <TCPIP_IPERF_Task+0x772>
       ((int32_t)(SYS_TMR_TickCountGet() - pIState->lastCheckTime) > pIState->mInterval) )
    2fde:	f01f f92d 	bl	2223c <SYS_TMR_TickCountGet>
    2fe2:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
    2fe6:	1ac3      	subs	r3, r0, r3
    if ((pIState->pktId != (long)0) &&
    2fe8:	6822      	ldr	r2, [r4, #0]
    2fea:	4293      	cmp	r3, r2
    2fec:	d9ea      	bls.n	2fc4 <TCPIP_IPERF_Task+0x730>
         ReportBW_Jitter_Loss(pIState, INTERVAL_REPORT);
    2fee:	2100      	movs	r1, #0
    2ff0:	4620      	mov	r0, r4
    2ff2:	f00b fa55 	bl	e4a0 <ReportBW_Jitter_Loss>
    2ff6:	e7e5      	b.n	2fc4 <TCPIP_IPERF_Task+0x730>
    if ( pIState->statusReported == 0u )
    2ff8:	f894 30cd 	ldrb.w	r3, [r4, #205]	; 0xcd
    2ffc:	b3c3      	cbz	r3, 3070 <TCPIP_IPERF_Task+0x7dc>
    IperfSetState(pIState, IPERF_RX_DONE_STATE);
    2ffe:	2109      	movs	r1, #9
    3000:	4620      	mov	r0, r4
    3002:	f01a fe5f 	bl	1dcc4 <IperfSetState>
        for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
    3006:	3601      	adds	r6, #1
    3008:	34d8      	adds	r4, #216	; 0xd8
    300a:	4b72      	ldr	r3, [pc, #456]	; (31d4 <TCPIP_IPERF_Task+0x940>)
    300c:	681b      	ldr	r3, [r3, #0]
    300e:	42b3      	cmp	r3, r6
    3010:	f340 82d4 	ble.w	35bc <TCPIP_IPERF_Task+0xd28>
	if (pIState->state == IPERF_STANDBY_STATE)
    3014:	f894 30ce 	ldrb.w	r3, [r4, #206]	; 0xce
    3018:	2b01      	cmp	r3, #1
    301a:	d0f4      	beq.n	3006 <TCPIP_IPERF_Task+0x772>
    switch ( pIState->state )
    301c:	3b02      	subs	r3, #2
    301e:	2b10      	cmp	r3, #16
    3020:	f200 82b1 	bhi.w	3586 <TCPIP_IPERF_Task+0xcf2>
    3024:	a201      	add	r2, pc, #4	; (adr r2, 302c <TCPIP_IPERF_Task+0x798>)
    3026:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    302a:	bf00      	nop
    302c:	000028cd 	.word	0x000028cd
    3030:	000029c5 	.word	0x000029c5
    3034:	00002c73 	.word	0x00002c73
    3038:	00002ca1 	.word	0x00002ca1
    303c:	00002e39 	.word	0x00002e39
    3040:	00002e95 	.word	0x00002e95
    3044:	00002ff9 	.word	0x00002ff9
    3048:	00003081 	.word	0x00003081
    304c:	00003125 	.word	0x00003125
    3050:	00003143 	.word	0x00003143
    3054:	00003307 	.word	0x00003307
    3058:	000033eb 	.word	0x000033eb
    305c:	00003473 	.word	0x00003473
    3060:	00003561 	.word	0x00003561
    3064:	00003217 	.word	0x00003217
    3068:	000034d3 	.word	0x000034d3
    306c:	00003577 	.word	0x00003577
        ReportBW_Jitter_Loss(pIState, SESSION_REPORT);
    3070:	2102      	movs	r1, #2
    3072:	4620      	mov	r0, r4
    3074:	f00b fa14 	bl	e4a0 <ReportBW_Jitter_Loss>
        pIState->statusReported = 1;
    3078:	2301      	movs	r3, #1
    307a:	f884 30cd 	strb.w	r3, [r4, #205]	; 0xcd
    307e:	e7be      	b.n	2ffe <TCPIP_IPERF_Task+0x76a>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    3080:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    3084:	685d      	ldr	r5, [r3, #4]
   switch( pIState->mProtocol)
    3086:	7c23      	ldrb	r3, [r4, #16]
    3088:	2b01      	cmp	r3, #1
    308a:	d02c      	beq.n	30e6 <TCPIP_IPERF_Task+0x852>
    308c:	2b02      	cmp	r3, #2
    308e:	d02f      	beq.n	30f0 <TCPIP_IPERF_Task+0x85c>
    (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf instance %d: Rx done. Socket closed.\r\n", pIState - gIperfState);
    3090:	4b4f      	ldr	r3, [pc, #316]	; (31d0 <TCPIP_IPERF_Task+0x93c>)
    3092:	1ae3      	subs	r3, r4, r3
    3094:	10db      	asrs	r3, r3, #3
    3096:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
    309a:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    309e:	ebc3 2343 	rsb	r3, r3, r3, lsl #9
    30a2:	eb03 4383 	add.w	r3, r3, r3, lsl #18
    30a6:	f1c3 0900 	rsb	r9, r3, #0
    30aa:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    30ae:	681b      	ldr	r3, [r3, #0]
    30b0:	685b      	ldr	r3, [r3, #4]
    30b2:	464a      	mov	r2, r9
    30b4:	f208 71d4 	addw	r1, r8, #2004	; 0x7d4
    30b8:	4628      	mov	r0, r5
    30ba:	4798      	blx	r3
    ResetIperfCounters(pIState);
    30bc:	4620      	mov	r0, r4
    30be:	f01b fb8d 	bl	1e7dc <ResetIperfCounters>
    if ((pIState->mServerMode == true) 	&&
    30c2:	f894 30d1 	ldrb.w	r3, [r4, #209]	; 0xd1
    30c6:	2b01      	cmp	r3, #1
    30c8:	d01a      	beq.n	3100 <TCPIP_IPERF_Task+0x86c>
        (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf instance %d: completed.\r\n", pIState - gIperfState);
    30ca:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    30ce:	681b      	ldr	r3, [r3, #0]
    30d0:	685b      	ldr	r3, [r3, #4]
    30d2:	464a      	mov	r2, r9
    30d4:	f608 0138 	addw	r1, r8, #2104	; 0x838
    30d8:	4628      	mov	r0, r5
    30da:	4798      	blx	r3
        IperfSetState(pIState, IPERF_STANDBY_STATE);
    30dc:	2101      	movs	r1, #1
    30de:	4620      	mov	r0, r4
    30e0:	f01a fdf0 	bl	1dcc4 <IperfSetState>
    30e4:	e78f      	b.n	3006 <TCPIP_IPERF_Task+0x772>
           TCPIP_UDP_Close(  pIState->udpSock );
    30e6:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    30ea:	f01e f957 	bl	2139c <TCPIP_UDP_Close>
           break;
    30ee:	e7cf      	b.n	3090 <TCPIP_IPERF_Task+0x7fc>
           TCPIP_TCP_Close( pIState->tcpServerSock );
    30f0:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    30f4:	f01c ff69 	bl	1ffca <TCPIP_TCP_Close>
           pIState->tcpServerSock = INVALID_SOCKET;
    30f8:	f64f 73ff 	movw	r3, #65535	; 0xffff
    30fc:	8723      	strh	r3, [r4, #56]	; 0x38
           break;
    30fe:	e7c7      	b.n	3090 <TCPIP_IPERF_Task+0x7fc>
    if ((pIState->mServerMode == true) 	&&
    3100:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
    3104:	2b00      	cmp	r3, #0
    3106:	d1e0      	bne.n	30ca <TCPIP_IPERF_Task+0x836>
        (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf instance %d: Ready for the next session.\r\n", pIState - gIperfState);
    3108:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    310c:	681b      	ldr	r3, [r3, #0]
    310e:	685b      	ldr	r3, [r3, #4]
    3110:	464a      	mov	r2, r9
    3112:	f608 0104 	addw	r1, r8, #2052	; 0x804
    3116:	4628      	mov	r0, r5
    3118:	4798      	blx	r3
        IperfSetState(pIState, IPERF_RX_START_STATE);
    311a:	2102      	movs	r1, #2
    311c:	4620      	mov	r0, r4
    311e:	f01a fdd1 	bl	1dcc4 <IperfSetState>
    3122:	e770      	b.n	3006 <TCPIP_IPERF_Task+0x772>
   TCPIP_ARP_Resolve(pIState->pNetIf, &pIState->remoteSide.remoteIPaddress.v4Add);
    3124:	f104 0144 	add.w	r1, r4, #68	; 0x44
    3128:	f8d4 00c8 	ldr.w	r0, [r4, #200]	; 0xc8
    312c:	f01c f809 	bl	1f142 <TCPIP_ARP_Resolve>
   IperfSetState(pIState, IPERF_TX_ARP_RESOLVE_STATE);
    3130:	210b      	movs	r1, #11
    3132:	4620      	mov	r0, r4
    3134:	f01a fdc6 	bl	1dcc4 <IperfSetState>
   pIState->timer = SYS_TMR_TickCountGet();
    3138:	f01f f880 	bl	2223c <SYS_TMR_TickCountGet>
    313c:	f8c4 00ac 	str.w	r0, [r4, #172]	; 0xac
    3140:	e761      	b.n	3006 <TCPIP_IPERF_Task+0x772>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    3142:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    3146:	685d      	ldr	r5, [r3, #4]
  if ( pIState->stopRequested == true )
    3148:	f894 20cf 	ldrb.w	r2, [r4, #207]	; 0xcf
    314c:	2a01      	cmp	r2, #1
    314e:	d011      	beq.n	3174 <TCPIP_IPERF_Task+0x8e0>
  if(!(TCPIP_Helper_IsMcastAddress(&pIState->remoteSide.remoteIPaddress.v4Add)))
    3150:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    3154:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    3158:	2be0      	cmp	r3, #224	; 0xe0
    315a:	d116      	bne.n	318a <TCPIP_IPERF_Task+0x8f6>
  if ( pIState->mProtocol == UDP_PROTOCOL )
    315c:	7c23      	ldrb	r3, [r4, #16]
    315e:	2b01      	cmp	r3, #1
    3160:	d054      	beq.n	320c <TCPIP_IPERF_Task+0x978>
  if ( pIState->mProtocol == TCP_PROTOCOL )
    3162:	7c23      	ldrb	r3, [r4, #16]
    3164:	2b02      	cmp	r3, #2
    3166:	f47f af4e 	bne.w	3006 <TCPIP_IPERF_Task+0x772>
     IperfSetState(pIState, IPERF_TCP_TX_OPEN_STATE);
    316a:	210c      	movs	r1, #12
    316c:	4620      	mov	r0, r4
    316e:	f01a fda9 	bl	1dcc4 <IperfSetState>
    3172:	e748      	b.n	3006 <TCPIP_IPERF_Task+0x772>
     (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: client session closed.\r\n");
    3174:	681b      	ldr	r3, [r3, #0]
    3176:	681b      	ldr	r3, [r3, #0]
    3178:	f608 0158 	addw	r1, r8, #2136	; 0x858
    317c:	4628      	mov	r0, r5
    317e:	4798      	blx	r3
     IperfSetState(pIState, IPERF_STANDBY_STATE);
    3180:	2101      	movs	r1, #1
    3182:	4620      	mov	r0, r4
    3184:	f01a fd9e 	bl	1dcc4 <IperfSetState>
     return;
    3188:	e73d      	b.n	3006 <TCPIP_IPERF_Task+0x772>
    if(!TCPIP_ARP_IsResolved(pIState->pNetIf, &pIState->remoteSide.remoteIPaddress.v4Add, &pIState->remoteMACAddr))
    318a:	f104 0278 	add.w	r2, r4, #120	; 0x78
    318e:	f104 0144 	add.w	r1, r4, #68	; 0x44
    3192:	f8d4 00c8 	ldr.w	r0, [r4, #200]	; 0xc8
    3196:	f016 fef5 	bl	19f84 <TCPIP_ARP_IsResolved>
    319a:	b1e8      	cbz	r0, 31d8 <TCPIP_IPERF_Task+0x944>
    (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - RemoteNode MAC: %x %x %x %x %x %x\r\n",
    319c:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    31a0:	681b      	ldr	r3, [r3, #0]
    31a2:	f894 207d 	ldrb.w	r2, [r4, #125]	; 0x7d
    31a6:	9203      	str	r2, [sp, #12]
    31a8:	f894 207c 	ldrb.w	r2, [r4, #124]	; 0x7c
    31ac:	9202      	str	r2, [sp, #8]
    31ae:	f894 207b 	ldrb.w	r2, [r4, #123]	; 0x7b
    31b2:	9201      	str	r2, [sp, #4]
    31b4:	f894 207a 	ldrb.w	r2, [r4, #122]	; 0x7a
    31b8:	9200      	str	r2, [sp, #0]
    31ba:	f8d3 9004 	ldr.w	r9, [r3, #4]
    31be:	f894 3079 	ldrb.w	r3, [r4, #121]	; 0x79
    31c2:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
    31c6:	f608 01b8 	addw	r1, r8, #2232	; 0x8b8
    31ca:	4628      	mov	r0, r5
    31cc:	47c8      	blx	r9
    31ce:	e7c5      	b.n	315c <TCPIP_IPERF_Task+0x8c8>
    31d0:	2000e380 	.word	0x2000e380
    31d4:	2000ee24 	.word	0x2000ee24
        if( SYS_TMR_TickCountGet() - pIState->timer > 5 * SYS_TMR_TickCounterFrequencyGet() )
    31d8:	f01f f830 	bl	2223c <SYS_TMR_TickCountGet>
    31dc:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
    31e0:	eba0 0903 	sub.w	r9, r0, r3
    31e4:	f01f f852 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    31e8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    31ec:	4581      	cmp	r9, r0
    31ee:	f67f af0a 	bls.w	3006 <TCPIP_IPERF_Task+0x772>
            (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: ARP unable to resolve the MAC address of remote side.\r\n");
    31f2:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    31f6:	681b      	ldr	r3, [r3, #0]
    31f8:	681b      	ldr	r3, [r3, #0]
    31fa:	f608 0178 	addw	r1, r8, #2168	; 0x878
    31fe:	4628      	mov	r0, r5
    3200:	4798      	blx	r3
            pIState->timer = SYS_TMR_TickCountGet();
    3202:	f01f f81b 	bl	2223c <SYS_TMR_TickCountGet>
    3206:	f8c4 00ac 	str.w	r0, [r4, #172]	; 0xac
    320a:	e6fc      	b.n	3006 <TCPIP_IPERF_Task+0x772>
     IperfSetState(pIState, IPERF_UDP_TX_OPEN_STATE);
    320c:	2110      	movs	r1, #16
    320e:	4620      	mov	r0, r4
    3210:	f01a fd58 	bl	1dcc4 <IperfSetState>
    3214:	e7a5      	b.n	3162 <TCPIP_IPERF_Task+0x8ce>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    3216:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    321a:	685d      	ldr	r5, [r3, #4]
    if ( (pIState->udpSock = TCPIP_UDP_ClientOpen(IP_ADDRESS_TYPE_IPV4, pIState->mServerPort, (IP_MULTI_ADDRESS*)&pIState->remoteSide.remoteIPaddress.v4Add)) == INVALID_UDP_SOCKET )
    321c:	f104 0244 	add.w	r2, r4, #68	; 0x44
    3220:	8a61      	ldrh	r1, [r4, #18]
    3222:	2001      	movs	r0, #1
    3224:	f021 f8a0 	bl	24368 <TCPIP_UDP_ClientOpen>
    3228:	87a0      	strh	r0, [r4, #60]	; 0x3c
    322a:	f1b0 3fff 	cmp.w	r0, #4294967295
    322e:	d05d      	beq.n	32ec <TCPIP_IPERF_Task+0xa58>
    TCPIP_UDP_SignalHandlerRegister(pIState->udpSock, TCPIP_UDP_SIGNAL_RX_DATA, _IperfUDPRxSignalHandler, 0);
    3230:	2300      	movs	r3, #0
    3232:	4ac9      	ldr	r2, [pc, #804]	; (3558 <TCPIP_IPERF_Task+0xcc4>)
    3234:	f44f 7180 	mov.w	r1, #256	; 0x100
    3238:	f01c f80f 	bl	1f25a <TCPIP_UDP_SignalHandlerRegister>
    if(!TCPIP_UDP_OptionsSet(pIState->udpSock, UDP_OPTION_TX_BUFF, (void*)pIState->mDatagramSize))
    323c:	68e2      	ldr	r2, [r4, #12]
    323e:	2105      	movs	r1, #5
    3240:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    3244:	f00c fea4 	bl	ff90 <TCPIP_UDP_OptionsSet>
    3248:	b938      	cbnz	r0, 325a <TCPIP_IPERF_Task+0x9c6>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Set of TX buffer size failed\r\n");
    324a:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    324e:	681b      	ldr	r3, [r3, #0]
    3250:	681b      	ldr	r3, [r3, #0]
    3252:	f608 01e4 	addw	r1, r8, #2276	; 0x8e4
    3256:	4628      	mov	r0, r5
    3258:	4798      	blx	r3
    if(!TCPIP_UDP_OptionsSet(pIState->udpSock, UDP_OPTION_TX_QUEUE_LIMIT, (void*)TCPIP_IPERF_TX_QUEUE_LIMIT))
    325a:	2202      	movs	r2, #2
    325c:	2106      	movs	r1, #6
    325e:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    3262:	f00c fe95 	bl	ff90 <TCPIP_UDP_OptionsSet>
    3266:	b938      	cbnz	r0, 3278 <TCPIP_IPERF_Task+0x9e4>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Set of TX queuing limit failed\r\n");
    3268:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    326c:	681b      	ldr	r3, [r3, #0]
    326e:	681b      	ldr	r3, [r3, #0]
    3270:	f608 110c 	addw	r1, r8, #2316	; 0x90c
    3274:	4628      	mov	r0, r5
    3276:	4798      	blx	r3
    TCPIP_UDP_SocketNetSet(pIState->udpSock, pIState->pNetIf);
    3278:	f8d4 10c8 	ldr.w	r1, [r4, #200]	; 0xc8
    327c:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    3280:	f01c fc50 	bl	1fb24 <TCPIP_UDP_SocketNetSet>
	TCPIP_UDP_SocketInfoGet(pIState->udpSock, &UdpSkt);
    3284:	a906      	add	r1, sp, #24
    3286:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    328a:	f019 fddf 	bl	1ce4c <TCPIP_UDP_SocketInfoGet>
    pIState->localPort = UdpSkt.localPort;
    328e:	f8bd 305e 	ldrh.w	r3, [sp, #94]	; 0x5e
    3292:	f8a4 307e 	strh.w	r3, [r4, #126]	; 0x7e
    (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "---------------------------------------------------------\r\n");
    3296:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    329a:	681b      	ldr	r3, [r3, #0]
    329c:	681b      	ldr	r3, [r3, #0]
    329e:	f508 7167 	add.w	r1, r8, #924	; 0x39c
    32a2:	4628      	mov	r0, r5
    32a4:	4798      	blx	r3
    (pIState->pCmdIO->pCmdApi->print)(cmdIoParam,  "iperf: Client connecting to %u.%u.%u.%u, UDP port %u\r\n",
    32a6:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    32aa:	681b      	ldr	r3, [r3, #0]
    32ac:	8a62      	ldrh	r2, [r4, #18]
    32ae:	9202      	str	r2, [sp, #8]
    32b0:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
    32b4:	9201      	str	r2, [sp, #4]
    32b6:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
    32ba:	9200      	str	r2, [sp, #0]
    32bc:	f8d3 9004 	ldr.w	r9, [r3, #4]
    32c0:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    32c4:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
    32c8:	f608 1134 	addw	r1, r8, #2356	; 0x934
    32cc:	4628      	mov	r0, r5
    32ce:	47c8      	blx	r9
    IperfSetState(pIState, IPERF_UDP_TX_DATAGRAM_STATE);
    32d0:	2111      	movs	r1, #17
    32d2:	4620      	mov	r0, r4
    32d4:	f01a fcf6 	bl	1dcc4 <IperfSetState>
    pIState->startTime = SYS_TMR_TickCountGet();
    32d8:	f01e ffb0 	bl	2223c <SYS_TMR_TickCountGet>
    32dc:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
    pIState->nextTxTime = pIState->startTime + pIState->mPktPeriod;
    32e0:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
    32e4:	4403      	add	r3, r0
    32e6:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
    32ea:	e68c      	b.n	3006 <TCPIP_IPERF_Task+0x772>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Create UDP socket failed\r\n");
    32ec:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    32f0:	681b      	ldr	r3, [r3, #0]
    32f2:	681b      	ldr	r3, [r3, #0]
    32f4:	f508 61dd 	add.w	r1, r8, #1768	; 0x6e8
    32f8:	4628      	mov	r0, r5
    32fa:	4798      	blx	r3
        IperfSetState(pIState, IPERF_STANDBY_STATE);
    32fc:	2101      	movs	r1, #1
    32fe:	4620      	mov	r0, r4
    3300:	f01a fce0 	bl	1dcc4 <IperfSetState>
        return;
    3304:	e67f      	b.n	3006 <TCPIP_IPERF_Task+0x772>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    3306:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    330a:	685d      	ldr	r5, [r3, #4]
   if  ( (pIState->tcpClientSock = TCPIP_TCP_ClientOpen(IP_ADDRESS_TYPE_IPV4, pIState->mServerPort, 0)) == INVALID_SOCKET )
    330c:	2200      	movs	r2, #0
    330e:	8a61      	ldrh	r1, [r4, #18]
    3310:	2001      	movs	r0, #1
    3312:	f020 f864 	bl	233de <TCPIP_TCP_ClientOpen>
    3316:	8760      	strh	r0, [r4, #58]	; 0x3a
    3318:	f1b0 3fff 	cmp.w	r0, #4294967295
    331c:	d04f      	beq.n	33be <TCPIP_IPERF_Task+0xb2a>
   TCPIP_TCP_SignalHandlerRegister(pIState->tcpClientSock, TCPIP_TCP_SIGNAL_RX_DATA, _IperfTCPRxSignalHandler, 0);
    331e:	2300      	movs	r3, #0
    3320:	4a8e      	ldr	r2, [pc, #568]	; (355c <TCPIP_IPERF_Task+0xcc8>)
    3322:	f44f 7100 	mov.w	r1, #512	; 0x200
    3326:	f01c f821 	bl	1f36c <TCPIP_TCP_SignalHandlerRegister>
   if(pIState->localAddr.Val != 0)
    332a:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
    332e:	2b00      	cmp	r3, #0
    3330:	d152      	bne.n	33d8 <TCPIP_IPERF_Task+0xb44>
   TCPIP_TCP_RemoteBind(pIState->tcpClientSock, IP_ADDRESS_TYPE_IPV4, 0,  (IP_MULTI_ADDRESS*)&pIState->remoteSide.remoteIPaddress);
    3332:	f104 0344 	add.w	r3, r4, #68	; 0x44
    3336:	2200      	movs	r2, #0
    3338:	2101      	movs	r1, #1
    333a:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    333e:	f01a fee2 	bl	1e106 <TCPIP_TCP_RemoteBind>
    pIState->localPort = TCPIP_IPERF_TCP_LOCAL_PORT_START_NUMBER;
    3342:	f44f 6380 	mov.w	r3, #1024	; 0x400
    3346:	f8a4 307e 	strh.w	r3, [r4, #126]	; 0x7e
    (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "---------------------------------------------------------\r\n");
    334a:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    334e:	681b      	ldr	r3, [r3, #0]
    3350:	681b      	ldr	r3, [r3, #0]
    3352:	f508 7167 	add.w	r1, r8, #924	; 0x39c
    3356:	4628      	mov	r0, r5
    3358:	4798      	blx	r3
    (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf: Client connecting to %u.%u.%u.%u, TCP port %u\r\n",
    335a:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    335e:	681b      	ldr	r3, [r3, #0]
    3360:	8a62      	ldrh	r2, [r4, #18]
    3362:	9202      	str	r2, [sp, #8]
    3364:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
    3368:	9201      	str	r2, [sp, #4]
    336a:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
    336e:	9200      	str	r2, [sp, #0]
    3370:	f8d3 9004 	ldr.w	r9, [r3, #4]
    3374:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    3378:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
    337c:	f608 116c 	addw	r1, r8, #2412	; 0x96c
    3380:	4628      	mov	r0, r5
    3382:	47c8      	blx	r9
    IperfSetState(pIState, IPERF_TCP_TX_CONNECT_STATE);
    3384:	210d      	movs	r1, #13
    3386:	4620      	mov	r0, r4
    3388:	f01a fc9c 	bl	1dcc4 <IperfSetState>
    if(!TCPIP_TCP_OptionsSet(pIState->tcpClientSock, TCP_OPTION_TX_BUFF, (void*)pIState->txBuffSize))
    338c:	f8d4 20b8 	ldr.w	r2, [r4, #184]	; 0xb8
    3390:	2103      	movs	r1, #3
    3392:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    3396:	f012 f958 	bl	1564a <TCPIP_TCP_OptionsSet>
    339a:	b938      	cbnz	r0, 33ac <TCPIP_IPERF_Task+0xb18>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Set of TX buffer size failed\r\n");
    339c:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    33a0:	681b      	ldr	r3, [r3, #0]
    33a2:	681b      	ldr	r3, [r3, #0]
    33a4:	f608 01e4 	addw	r1, r8, #2276	; 0x8e4
    33a8:	4628      	mov	r0, r5
    33aa:	4798      	blx	r3
    TCPIP_TCP_Connect(pIState->tcpClientSock);
    33ac:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    33b0:	f01e f971 	bl	21696 <TCPIP_TCP_Connect>
    pIState->timer = SYS_TMR_TickCountGet();
    33b4:	f01e ff42 	bl	2223c <SYS_TMR_TickCountGet>
    33b8:	f8c4 00ac 	str.w	r0, [r4, #172]	; 0xac
    33bc:	e623      	b.n	3006 <TCPIP_IPERF_Task+0x772>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Create TCP socket failed\r\n");
    33be:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    33c2:	681b      	ldr	r3, [r3, #0]
    33c4:	681b      	ldr	r3, [r3, #0]
    33c6:	f208 619c 	addw	r1, r8, #1692	; 0x69c
    33ca:	4628      	mov	r0, r5
    33cc:	4798      	blx	r3
        IperfSetState(pIState, IPERF_STANDBY_STATE);
    33ce:	2101      	movs	r1, #1
    33d0:	4620      	mov	r0, r4
    33d2:	f01a fc77 	bl	1dcc4 <IperfSetState>
        return;
    33d6:	e616      	b.n	3006 <TCPIP_IPERF_Task+0x772>
       TCPIP_TCP_Bind(pIState->tcpClientSock, IP_ADDRESS_TYPE_IPV4, pIState->mServerPort, (IP_MULTI_ADDRESS*)&pIState->localAddr);
    33d8:	f104 0380 	add.w	r3, r4, #128	; 0x80
    33dc:	8a62      	ldrh	r2, [r4, #18]
    33de:	2101      	movs	r1, #1
    33e0:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    33e4:	f014 fb40 	bl	17a68 <TCPIP_TCP_Bind>
    33e8:	e7a3      	b.n	3332 <TCPIP_IPERF_Task+0xa9e>
    if ( pIState->stopRequested == true )
    33ea:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
    33ee:	2b01      	cmp	r3, #1
    33f0:	d01a      	beq.n	3428 <TCPIP_IPERF_Task+0xb94>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    33f2:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    33f6:	f8d3 9004 	ldr.w	r9, [r3, #4]
    if( !TCPIP_TCP_IsConnected(pIState->tcpClientSock) )
    33fa:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    33fe:	f01e ffe5 	bl	223cc <TCPIP_TCP_IsConnected>
    3402:	b1b0      	cbz	r0, 3432 <TCPIP_IPERF_Task+0xb9e>
    TCPIP_TCP_WasReset(pIState->tcpClientSock);
    3404:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    3408:	f01e fc7f 	bl	21d0a <TCPIP_TCP_WasReset>
    pIState->startTime = SYS_TMR_TickCountGet();
    340c:	f01e ff16 	bl	2223c <SYS_TMR_TickCountGet>
    3410:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
    pIState->nextTxTime = pIState->startTime + pIState->mPktPeriod;
    3414:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
    3418:	4403      	add	r3, r0
    341a:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
    IperfSetState(pIState, IPERF_TCP_TX_SEGMENT_STATE);
    341e:	210e      	movs	r1, #14
    3420:	4620      	mov	r0, r4
    3422:	f01a fc4f 	bl	1dcc4 <IperfSetState>
    3426:	e5ee      	b.n	3006 <TCPIP_IPERF_Task+0x772>
        IperfSetState(pIState, IPERF_TCP_TX_DONE_STATE);
    3428:	210f      	movs	r1, #15
    342a:	4620      	mov	r0, r4
    342c:	f01a fc4a 	bl	1dcc4 <IperfSetState>
        return;
    3430:	e5e9      	b.n	3006 <TCPIP_IPERF_Task+0x772>
        if(SYS_TMR_TickCountGet()- pIState->timer > 5*SYS_TMR_TickCounterFrequencyGet())
    3432:	f01e ff03 	bl	2223c <SYS_TMR_TickCountGet>
    3436:	f8d4 50ac 	ldr.w	r5, [r4, #172]	; 0xac
    343a:	1b45      	subs	r5, r0, r5
    343c:	f01e ff26 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    3440:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    3444:	4285      	cmp	r5, r0
    3446:	f67f adde 	bls.w	3006 <TCPIP_IPERF_Task+0x772>
            TCPIP_TCP_Close(pIState->tcpClientSock);
    344a:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    344e:	f01c fdbc 	bl	1ffca <TCPIP_TCP_Close>
            pIState->tcpClientSock = INVALID_SOCKET;
    3452:	f64f 73ff 	movw	r3, #65535	; 0xffff
    3456:	8763      	strh	r3, [r4, #58]	; 0x3a
            (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: TCP Client connection timeout\r\n");
    3458:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    345c:	681b      	ldr	r3, [r3, #0]
    345e:	681b      	ldr	r3, [r3, #0]
    3460:	f608 11a4 	addw	r1, r8, #2468	; 0x9a4
    3464:	4648      	mov	r0, r9
    3466:	4798      	blx	r3
            IperfSetState(pIState, IPERF_TCP_TX_DONE_STATE);
    3468:	210f      	movs	r1, #15
    346a:	4620      	mov	r0, r4
    346c:	f01a fc2a 	bl	1dcc4 <IperfSetState>
    3470:	e5c9      	b.n	3006 <TCPIP_IPERF_Task+0x772>
    tIperfTxResult txRes = GenericTxStart(pIState);
    3472:	4620      	mov	r0, r4
    3474:	f007 fe24 	bl	b0c0 <GenericTxStart>
    if(txRes == IPERF_TX_OK)
    3478:	2801      	cmp	r0, #1
    347a:	d00b      	beq.n	3494 <TCPIP_IPERF_Task+0xc00>
    else if(txRes == IPERF_TX_FAIL)
    347c:	2802      	cmp	r0, #2
    347e:	f47f adc2 	bne.w	3006 <TCPIP_IPERF_Task+0x772>
        IperfSetState(pIState, IPERF_TCP_TX_DONE_STATE);
    3482:	210f      	movs	r1, #15
    3484:	4620      	mov	r0, r4
    3486:	f01a fc1d 	bl	1dcc4 <IperfSetState>
        pIState->stopTime = SYS_TMR_TickCountGet();
    348a:	f01e fed7 	bl	2223c <SYS_TMR_TickCountGet>
    348e:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    3492:	e5b8      	b.n	3006 <TCPIP_IPERF_Task+0x772>
  memset( g_bfr, 0x54, MAX_BUFFER);
    3494:	2234      	movs	r2, #52	; 0x34
    3496:	2154      	movs	r1, #84	; 0x54
    3498:	4638      	mov	r0, r7
    349a:	f020 fd01 	bl	23ea0 <memset>
  while( pIState->remainingTxData > 0u )
    349e:	f8b4 30b0 	ldrh.w	r3, [r4, #176]	; 0xb0
    34a2:	b173      	cbz	r3, 34c2 <TCPIP_IPERF_Task+0xc2e>
      chunk = pIState->remainingTxData;
    34a4:	2b33      	cmp	r3, #51	; 0x33
    34a6:	bf94      	ite	ls
    34a8:	461d      	movls	r5, r3
    34aa:	2534      	movhi	r5, #52	; 0x34
    pIState->remainingTxData -= chunk;
    34ac:	1b5b      	subs	r3, r3, r5
    34ae:	f8a4 30b0 	strh.w	r3, [r4, #176]	; 0xb0
    if ( TCPIP_TCP_ArrayPut( pIState->tcpClientSock, (uint8_t *) g_bfr, chunk) != chunk )
    34b2:	462a      	mov	r2, r5
    34b4:	4639      	mov	r1, r7
    34b6:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    34ba:	f00e ff81 	bl	123c0 <TCPIP_TCP_ArrayPut>
    34be:	4285      	cmp	r5, r0
    34c0:	d0ed      	beq.n	349e <TCPIP_IPERF_Task+0xc0a>
       TCPIP_TCP_Flush(pIState->tcpClientSock);
    34c2:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    34c6:	f01e ff94 	bl	223f2 <TCPIP_TCP_Flush>
       GenericTxEnd(pIState);
    34ca:	4620      	mov	r0, r4
    34cc:	f00d fc16 	bl	10cfc <GenericTxEnd>
    34d0:	e599      	b.n	3006 <TCPIP_IPERF_Task+0x772>
    TCPIP_UDP_OptionsSet(pIState->udpSock, UDP_OPTION_TOS, (void*)(unsigned int)pIState->mTypeOfService);   
    34d2:	7d22      	ldrb	r2, [r4, #20]
    34d4:	210b      	movs	r1, #11
    34d6:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    34da:	f00c fd59 	bl	ff90 <TCPIP_UDP_OptionsSet>
    tIperfTxResult txRes = GenericTxStart(pIState);
    34de:	4620      	mov	r0, r4
    34e0:	f007 fdee 	bl	b0c0 <GenericTxStart>
    if ( txRes == IPERF_TX_OK )
    34e4:	2801      	cmp	r0, #1
    34e6:	d00b      	beq.n	3500 <TCPIP_IPERF_Task+0xc6c>
    else if(txRes == IPERF_TX_FAIL)
    34e8:	2802      	cmp	r0, #2
    34ea:	f47f ad8c 	bne.w	3006 <TCPIP_IPERF_Task+0x772>
        IperfSetState(pIState, IPERF_UDP_TX_DONE_STATE);
    34ee:	2112      	movs	r1, #18
    34f0:	4620      	mov	r0, r4
    34f2:	f01a fbe7 	bl	1dcc4 <IperfSetState>
        pIState->stopTime = SYS_TMR_TickCountGet();
    34f6:	f01e fea1 	bl	2223c <SYS_TMR_TickCountGet>
    34fa:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    34fe:	e582      	b.n	3006 <TCPIP_IPERF_Task+0x772>
    memset( g_bfr, 0x55, MAX_BUFFER);
    3500:	2234      	movs	r2, #52	; 0x34
    3502:	2155      	movs	r1, #85	; 0x55
    3504:	4638      	mov	r0, r7
    3506:	f020 fccb 	bl	23ea0 <memset>
    remainingTxData = pIState->remainingTxData;
    350a:	f8b4 50b0 	ldrh.w	r5, [r4, #176]	; 0xb0
    while( remainingTxData > 0u )
    350e:	b1bd      	cbz	r5, 3540 <TCPIP_IPERF_Task+0xcac>
    uint16_t txData = 0;
    3510:	f04f 0900 	mov.w	r9, #0
        if (  TCPIP_UDP_ArrayPut(pIState->udpSock, (uint8_t *) g_bfr, chunk) != chunk )
    3514:	f04f 0a34 	mov.w	sl, #52	; 0x34
    3518:	e001      	b.n	351e <TCPIP_IPERF_Task+0xc8a>
    while( remainingTxData > 0u )
    351a:	2d00      	cmp	r5, #0
    351c:	d041      	beq.n	35a2 <TCPIP_IPERF_Task+0xd0e>
        if ( remainingTxData < MAX_BUFFER )
    351e:	2d33      	cmp	r5, #51	; 0x33
    3520:	d936      	bls.n	3590 <TCPIP_IPERF_Task+0xcfc>
        remainingTxData -= chunk;
    3522:	3d34      	subs	r5, #52	; 0x34
    3524:	b2ad      	uxth	r5, r5
        txData += chunk;
    3526:	f109 0934 	add.w	r9, r9, #52	; 0x34
    352a:	fa1f f989 	uxth.w	r9, r9
        if (  TCPIP_UDP_ArrayPut(pIState->udpSock, (uint8_t *) g_bfr, chunk) != chunk )
    352e:	4652      	mov	r2, sl
    3530:	4639      	mov	r1, r7
    3532:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    3536:	f01b fa80 	bl	1ea3a <TCPIP_UDP_ArrayPut>
    353a:	2834      	cmp	r0, #52	; 0x34
    353c:	d0ed      	beq.n	351a <TCPIP_IPERF_Task+0xc86>
    353e:	e030      	b.n	35a2 <TCPIP_IPERF_Task+0xd0e>
    uint16_t txData = 0;
    3540:	46a9      	mov	r9, r5
    3542:	e02e      	b.n	35a2 <TCPIP_IPERF_Task+0xd0e>
           pIState->remainingTxData -= txData;
    3544:	f8b4 30b0 	ldrh.w	r3, [r4, #176]	; 0xb0
    3548:	eba3 0909 	sub.w	r9, r3, r9
    354c:	f8a4 90b0 	strh.w	r9, [r4, #176]	; 0xb0
           GenericTxEnd(pIState);
    3550:	4620      	mov	r0, r4
    3552:	f00d fbd3 	bl	10cfc <GenericTxEnd>
    3556:	e556      	b.n	3006 <TCPIP_IPERF_Task+0x772>
    3558:	00023939 	.word	0x00023939
    355c:	0002394f 	.word	0x0002394f
    GenericTxDone(pIState);
    3560:	4620      	mov	r0, r4
    3562:	f01e fd17 	bl	21f94 <GenericTxDone>
    TCPIP_TCP_Close(pIState->tcpClientSock);
    3566:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    356a:	f01c fd2e 	bl	1ffca <TCPIP_TCP_Close>
    pIState->tcpClientSock = INVALID_SOCKET;
    356e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    3572:	8763      	strh	r3, [r4, #58]	; 0x3a
    3574:	e547      	b.n	3006 <TCPIP_IPERF_Task+0x772>
    GenericTxDone(pIState);
    3576:	4620      	mov	r0, r4
    3578:	f01e fd0c 	bl	21f94 <GenericTxDone>
    TCPIP_UDP_Close(pIState->udpSock );
    357c:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    3580:	f01d ff0c 	bl	2139c <TCPIP_UDP_Close>
    3584:	e53f      	b.n	3006 <TCPIP_IPERF_Task+0x772>
			IperfSetState(pIState, IPERF_STANDBY_STATE);
    3586:	2101      	movs	r1, #1
    3588:	4620      	mov	r0, r4
    358a:	f01a fb9b 	bl	1dcc4 <IperfSetState>
			break;
    358e:	e53a      	b.n	3006 <TCPIP_IPERF_Task+0x772>
        txData += chunk;
    3590:	44a9      	add	r9, r5
    3592:	fa1f f989 	uxth.w	r9, r9
        if (  TCPIP_UDP_ArrayPut(pIState->udpSock, (uint8_t *) g_bfr, chunk) != chunk )
    3596:	462a      	mov	r2, r5
    3598:	4639      	mov	r1, r7
    359a:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    359e:	f01b fa4c 	bl	1ea3a <TCPIP_UDP_ArrayPut>
       if(TCPIP_UDP_Flush(pIState->udpSock) == 0)
    35a2:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    35a6:	f00c f8c7 	bl	f738 <TCPIP_UDP_Flush>
    35aa:	2800      	cmp	r0, #0
    35ac:	d1ca      	bne.n	3544 <TCPIP_IPERF_Task+0xcb0>
           TCPIP_UDP_TxOffsetSet(pIState->udpSock, 0, 0);
    35ae:	2200      	movs	r2, #0
    35b0:	4611      	mov	r1, r2
    35b2:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    35b6:	f01c fc52 	bl	1fe5e <TCPIP_UDP_TxOffsetSet>
    35ba:	e524      	b.n	3006 <TCPIP_IPERF_Task+0x772>
}
    35bc:	b01b      	add	sp, #108	; 0x6c
    35be:	ecbd 8b02 	vpop	{d8}
    35c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    35c6:	bf00      	nop

Disassembly of section .dinit%214:

000035c8 <.dinit>:
    35c8:	2000ebc4 	.word	0x2000ebc4
    35cc:	0000001c 	.word	0x0000001c
    35d0:	00000000 	.word	0x00000000
    35d4:	2000e7e8 	.word	0x2000e7e8
    35d8:	00000068 	.word	0x00000068
    35dc:	00000000 	.word	0x00000000
    35e0:	2000e6e4 	.word	0x2000e6e4
    35e4:	00000004 	.word	0x00000004
    35e8:	00000000 	.word	0x00000000
    35ec:	2000e288 	.word	0x2000e288
    35f0:	000000f8 	.word	0x000000f8
    35f4:	00000001 	.word	0x00000001
    35f8:	0001d9b8 	.word	0x0001d9b8
	...
    36f0:	2000eba3 	.word	0x2000eba3
    36f4:	00000001 	.word	0x00000001
    36f8:	00000001 	.word	0x00000001
    36fc:	000000ff 	.word	0x000000ff
    3700:	2000eda4 	.word	0x2000eda4
    3704:	00000004 	.word	0x00000004
    3708:	00000000 	.word	0x00000000
    370c:	2000e6e8 	.word	0x2000e6e8
    3710:	00000080 	.word	0x00000080
    3714:	00000000 	.word	0x00000000
    3718:	2000ef74 	.word	0x2000ef74
    371c:	00000002 	.word	0x00000002
    3720:	00000001 	.word	0x00000001
    3724:	00000054 	.word	0x00000054
    3728:	2000e5c0 	.word	0x2000e5c0
    372c:	00000094 	.word	0x00000094
    3730:	00000000 	.word	0x00000000
    3734:	2000ebe0 	.word	0x2000ebe0
    3738:	00000018 	.word	0x00000018
    373c:	00000000 	.word	0x00000000
    3740:	2000eda8 	.word	0x2000eda8
    3744:	00000004 	.word	0x00000004
    3748:	00000000 	.word	0x00000000
    374c:	2000edac 	.word	0x2000edac
    3750:	00000004 	.word	0x00000004
    3754:	00000000 	.word	0x00000000
    3758:	2000edb0 	.word	0x2000edb0
    375c:	00000004 	.word	0x00000004
    3760:	00000000 	.word	0x00000000
    3764:	2000edb4 	.word	0x2000edb4
    3768:	00000004 	.word	0x00000004
    376c:	00000000 	.word	0x00000000
    3770:	2000ec28 	.word	0x2000ec28
    3774:	00000014 	.word	0x00000014
    3778:	00000000 	.word	0x00000000
    377c:	2000edb8 	.word	0x2000edb8
    3780:	00000004 	.word	0x00000004
    3784:	00000000 	.word	0x00000000
    3788:	2000edbc 	.word	0x2000edbc
    378c:	00000004 	.word	0x00000004
    3790:	00000000 	.word	0x00000000
    3794:	2000edc0 	.word	0x2000edc0
    3798:	00000004 	.word	0x00000004
    379c:	00000000 	.word	0x00000000
    37a0:	2000edc4 	.word	0x2000edc4
    37a4:	00000004 	.word	0x00000004
    37a8:	00000000 	.word	0x00000000
    37ac:	2000eda2 	.word	0x2000eda2
    37b0:	00000002 	.word	0x00000002
    37b4:	00000000 	.word	0x00000000
    37b8:	2000ed2a 	.word	0x2000ed2a
    37bc:	00000002 	.word	0x00000002
    37c0:	00000000 	.word	0x00000000
    37c4:	2000edc8 	.word	0x2000edc8
    37c8:	00000004 	.word	0x00000004
    37cc:	00000000 	.word	0x00000000
    37d0:	2000edcc 	.word	0x2000edcc
    37d4:	00000004 	.word	0x00000004
    37d8:	00000000 	.word	0x00000000
    37dc:	2000edd0 	.word	0x2000edd0
    37e0:	00000004 	.word	0x00000004
    37e4:	00000000 	.word	0x00000000
    37e8:	2000edd4 	.word	0x2000edd4
    37ec:	00000004 	.word	0x00000004
    37f0:	00000000 	.word	0x00000000
    37f4:	2000edd8 	.word	0x2000edd8
    37f8:	00000004 	.word	0x00000004
    37fc:	00000000 	.word	0x00000000
    3800:	2000e974 	.word	0x2000e974
    3804:	0000004c 	.word	0x0000004c
    3808:	00000000 	.word	0x00000000
    380c:	2000ed9c 	.word	0x2000ed9c
    3810:	00000006 	.word	0x00000006
    3814:	00000001 	.word	0x00000001
    3818:	ffffffff 	.word	0xffffffff
    381c:	0000ffff 	.word	0x0000ffff
    3820:	2000ebf8 	.word	0x2000ebf8
    3824:	00000018 	.word	0x00000018
    3828:	00000000 	.word	0x00000000
    382c:	2000eddc 	.word	0x2000eddc
    3830:	00000004 	.word	0x00000004
    3834:	00000000 	.word	0x00000000
    3838:	2000ede0 	.word	0x2000ede0
    383c:	00000004 	.word	0x00000004
    3840:	00000000 	.word	0x00000000
    3844:	2000ede4 	.word	0x2000ede4
    3848:	00000004 	.word	0x00000004
    384c:	00000000 	.word	0x00000000
    3850:	2000eb84 	.word	0x2000eb84
    3854:	0000001f 	.word	0x0000001f
    3858:	00000000 	.word	0x00000000
    385c:	2000ede8 	.word	0x2000ede8
    3860:	00000004 	.word	0x00000004
    3864:	00000000 	.word	0x00000000
    3868:	2000edec 	.word	0x2000edec
    386c:	00000004 	.word	0x00000004
    3870:	00000000 	.word	0x00000000
    3874:	2000ef72 	.word	0x2000ef72
    3878:	00000002 	.word	0x00000002
    387c:	00000000 	.word	0x00000000
    3880:	2000edf0 	.word	0x2000edf0
    3884:	00000004 	.word	0x00000004
    3888:	00000000 	.word	0x00000000
    388c:	2000ca04 	.word	0x2000ca04
    3890:	000007d0 	.word	0x000007d0
    3894:	00000000 	.word	0x00000000
    3898:	2000edf4 	.word	0x2000edf4
    389c:	00000004 	.word	0x00000004
    38a0:	00000000 	.word	0x00000000
    38a4:	2000edf8 	.word	0x2000edf8
    38a8:	00000004 	.word	0x00000004
    38ac:	00000000 	.word	0x00000000
    38b0:	2000edfc 	.word	0x2000edfc
    38b4:	00000004 	.word	0x00000004
    38b8:	00000000 	.word	0x00000000
    38bc:	2000ee00 	.word	0x2000ee00
    38c0:	00000004 	.word	0x00000004
    38c4:	00000000 	.word	0x00000000
    38c8:	2000ef76 	.word	0x2000ef76
    38cc:	00000002 	.word	0x00000002
    38d0:	00000000 	.word	0x00000000
    38d4:	2000ee04 	.word	0x2000ee04
    38d8:	00000004 	.word	0x00000004
    38dc:	00000000 	.word	0x00000000
    38e0:	2000ee08 	.word	0x2000ee08
    38e4:	00000004 	.word	0x00000004
    38e8:	00000000 	.word	0x00000000
    38ec:	2000ed18 	.word	0x2000ed18
    38f0:	00000011 	.word	0x00000011
    38f4:	00000000 	.word	0x00000000
    38f8:	2000eba4 	.word	0x2000eba4
    38fc:	0000001f 	.word	0x0000001f
    3900:	00000000 	.word	0x00000000
    3904:	2000ee0c 	.word	0x2000ee0c
    3908:	00000004 	.word	0x00000004
    390c:	00000000 	.word	0x00000000
    3910:	2000ee10 	.word	0x2000ee10
    3914:	00000004 	.word	0x00000004
    3918:	00000000 	.word	0x00000000
    391c:	2000ee14 	.word	0x2000ee14
    3920:	00000004 	.word	0x00000004
    3924:	00000000 	.word	0x00000000
    3928:	2000ee18 	.word	0x2000ee18
    392c:	00000004 	.word	0x00000004
    3930:	00000000 	.word	0x00000000
    3934:	2000ebc3 	.word	0x2000ebc3
    3938:	00000001 	.word	0x00000001
    393c:	00000000 	.word	0x00000000
    3940:	2000ed29 	.word	0x2000ed29
    3944:	00000001 	.word	0x00000001
    3948:	00000001 	.word	0x00000001
    394c:	00000001 	.word	0x00000001
    3950:	2000ee1c 	.word	0x2000ee1c
    3954:	00000004 	.word	0x00000004
    3958:	00000001 	.word	0x00000001
    395c:	00000064 	.word	0x00000064
    3960:	2000e380 	.word	0x2000e380
    3964:	000000d8 	.word	0x000000d8
    3968:	00000000 	.word	0x00000000
    396c:	2000ea38 	.word	0x2000ea38
    3970:	00000034 	.word	0x00000034
    3974:	00000000 	.word	0x00000000
    3978:	2000ee20 	.word	0x2000ee20
    397c:	00000004 	.word	0x00000004
    3980:	00000000 	.word	0x00000000
    3984:	2000ef71 	.word	0x2000ef71
    3988:	00000001 	.word	0x00000001
    398c:	00000000 	.word	0x00000000
    3990:	2000ee24 	.word	0x2000ee24
    3994:	00000004 	.word	0x00000004
    3998:	00000000 	.word	0x00000000
    399c:	2000ee28 	.word	0x2000ee28
    39a0:	00000004 	.word	0x00000004
    39a4:	00000000 	.word	0x00000000
    39a8:	2000ee2c 	.word	0x2000ee2c
    39ac:	00000004 	.word	0x00000004
    39b0:	00000000 	.word	0x00000000
    39b4:	2000ee30 	.word	0x2000ee30
    39b8:	00000004 	.word	0x00000004
    39bc:	00000000 	.word	0x00000000
    39c0:	2000ed4c 	.word	0x2000ed4c
    39c4:	0000000c 	.word	0x0000000c
    39c8:	00000000 	.word	0x00000000
    39cc:	2000ec3c 	.word	0x2000ec3c
    39d0:	00000014 	.word	0x00000014
    39d4:	00000000 	.word	0x00000000
    39d8:	2000ef8a 	.word	0x2000ef8a
    39dc:	00000001 	.word	0x00000001
    39e0:	00000000 	.word	0x00000000
    39e4:	2000ef78 	.word	0x2000ef78
    39e8:	00000002 	.word	0x00000002
    39ec:	00000000 	.word	0x00000000
    39f0:	2000ef7a 	.word	0x2000ef7a
    39f4:	00000002 	.word	0x00000002
    39f8:	00000000 	.word	0x00000000
    39fc:	2000ee34 	.word	0x2000ee34
    3a00:	00000004 	.word	0x00000004
    3a04:	00000000 	.word	0x00000000
    3a08:	2000ec50 	.word	0x2000ec50
    3a0c:	00000014 	.word	0x00000014
    3a10:	00000000 	.word	0x00000000
    3a14:	2000ee38 	.word	0x2000ee38
    3a18:	00000004 	.word	0x00000004
    3a1c:	00000000 	.word	0x00000000
    3a20:	2000ee3c 	.word	0x2000ee3c
    3a24:	00000004 	.word	0x00000004
    3a28:	00000000 	.word	0x00000000
    3a2c:	2000ef7c 	.word	0x2000ef7c
    3a30:	00000002 	.word	0x00000002
    3a34:	00000000 	.word	0x00000000
    3a38:	2000ef7e 	.word	0x2000ef7e
    3a3c:	00000002 	.word	0x00000002
    3a40:	00000000 	.word	0x00000000
    3a44:	2000ee40 	.word	0x2000ee40
    3a48:	00000004 	.word	0x00000004
    3a4c:	00000000 	.word	0x00000000
    3a50:	2000ee44 	.word	0x2000ee44
    3a54:	00000004 	.word	0x00000004
    3a58:	00000000 	.word	0x00000000
    3a5c:	2000ee48 	.word	0x2000ee48
    3a60:	00000004 	.word	0x00000004
    3a64:	00000000 	.word	0x00000000
    3a68:	2000ec64 	.word	0x2000ec64
    3a6c:	00000014 	.word	0x00000014
    3a70:	00000000 	.word	0x00000000
    3a74:	2000ee4c 	.word	0x2000ee4c
    3a78:	00000004 	.word	0x00000004
    3a7c:	00000000 	.word	0x00000000
    3a80:	2000ef80 	.word	0x2000ef80
    3a84:	00000002 	.word	0x00000002
    3a88:	00000000 	.word	0x00000000
    3a8c:	2000ee50 	.word	0x2000ee50
    3a90:	00000004 	.word	0x00000004
    3a94:	00000000 	.word	0x00000000
    3a98:	2000ee54 	.word	0x2000ee54
    3a9c:	00000004 	.word	0x00000004
    3aa0:	00000000 	.word	0x00000000
    3aa4:	2000ea98 	.word	0x2000ea98
    3aa8:	00000028 	.word	0x00000028
    3aac:	00000000 	.word	0x00000000
    3ab0:	2000ee58 	.word	0x2000ee58
    3ab4:	00000004 	.word	0x00000004
    3ab8:	00000000 	.word	0x00000000
    3abc:	2000e654 	.word	0x2000e654
    3ac0:	00000090 	.word	0x00000090
    3ac4:	00000000 	.word	0x00000000
    3ac8:	2000d9a4 	.word	0x2000d9a4
    3acc:	00000270 	.word	0x00000270
    3ad0:	00000000 	.word	0x00000000
    3ad4:	2000ee5c 	.word	0x2000ee5c
    3ad8:	00000004 	.word	0x00000004
    3adc:	00000000 	.word	0x00000000
    3ae0:	2000ee60 	.word	0x2000ee60
    3ae4:	00000004 	.word	0x00000004
    3ae8:	00000000 	.word	0x00000000
    3aec:	2000ee64 	.word	0x2000ee64
    3af0:	00000004 	.word	0x00000004
    3af4:	00000000 	.word	0x00000000
    3af8:	2000ee68 	.word	0x2000ee68
    3afc:	00000004 	.word	0x00000004
    3b00:	00000000 	.word	0x00000000
    3b04:	2000ee6c 	.word	0x2000ee6c
    3b08:	00000004 	.word	0x00000004
    3b0c:	00000000 	.word	0x00000000
    3b10:	2000ee70 	.word	0x2000ee70
    3b14:	00000004 	.word	0x00000004
    3b18:	00000000 	.word	0x00000000
    3b1c:	2000ee74 	.word	0x2000ee74
    3b20:	00000004 	.word	0x00000004
    3b24:	00000000 	.word	0x00000000
    3b28:	2000ed2c 	.word	0x2000ed2c
    3b2c:	00000010 	.word	0x00000010
    3b30:	00000000 	.word	0x00000000
    3b34:	2000ec10 	.word	0x2000ec10
    3b38:	00000018 	.word	0x00000018
    3b3c:	00000000 	.word	0x00000000
    3b40:	2000eae4 	.word	0x2000eae4
    3b44:	00000020 	.word	0x00000020
    3b48:	00000000 	.word	0x00000000
    3b4c:	2000ee78 	.word	0x2000ee78
    3b50:	00000004 	.word	0x00000004
    3b54:	00000000 	.word	0x00000000
    3b58:	2000ef8b 	.word	0x2000ef8b
    3b5c:	00000001 	.word	0x00000001
    3b60:	00000000 	.word	0x00000000
    3b64:	2000ee7c 	.word	0x2000ee7c
    3b68:	00000004 	.word	0x00000004
    3b6c:	00000000 	.word	0x00000000
    3b70:	2000ee80 	.word	0x2000ee80
    3b74:	00000004 	.word	0x00000004
    3b78:	00000001 	.word	0x00000001
    3b7c:	ffffffff 	.word	0xffffffff
    3b80:	2000ee84 	.word	0x2000ee84
    3b84:	00000004 	.word	0x00000004
    3b88:	00000000 	.word	0x00000000
    3b8c:	2000ee88 	.word	0x2000ee88
    3b90:	00000004 	.word	0x00000004
    3b94:	00000000 	.word	0x00000000
    3b98:	2000ee8c 	.word	0x2000ee8c
    3b9c:	00000004 	.word	0x00000004
    3ba0:	00000000 	.word	0x00000000
    3ba4:	2000ee90 	.word	0x2000ee90
    3ba8:	00000004 	.word	0x00000004
    3bac:	00000000 	.word	0x00000000
    3bb0:	2000ef82 	.word	0x2000ef82
    3bb4:	00000002 	.word	0x00000002
    3bb8:	00000000 	.word	0x00000000
    3bbc:	2000ee94 	.word	0x2000ee94
    3bc0:	00000004 	.word	0x00000004
    3bc4:	00000000 	.word	0x00000000
    3bc8:	2000ee98 	.word	0x2000ee98
    3bcc:	00000004 	.word	0x00000004
    3bd0:	00000000 	.word	0x00000000
    3bd4:	2000ee9c 	.word	0x2000ee9c
    3bd8:	00000004 	.word	0x00000004
    3bdc:	00000000 	.word	0x00000000
    3be0:	2000eea0 	.word	0x2000eea0
    3be4:	00000004 	.word	0x00000004
    3be8:	00000000 	.word	0x00000000
    3bec:	2000eea4 	.word	0x2000eea4
    3bf0:	00000004 	.word	0x00000004
    3bf4:	00000000 	.word	0x00000000
    3bf8:	2000ef8c 	.word	0x2000ef8c
    3bfc:	00000001 	.word	0x00000001
    3c00:	00000000 	.word	0x00000000
    3c04:	2000ed3c 	.word	0x2000ed3c
    3c08:	00000010 	.word	0x00000010
    3c0c:	00000000 	.word	0x00000000
    3c10:	2000eea8 	.word	0x2000eea8
    3c14:	00000004 	.word	0x00000004
    3c18:	00000000 	.word	0x00000000
    3c1c:	2000ef84 	.word	0x2000ef84
    3c20:	00000002 	.word	0x00000002
    3c24:	00000000 	.word	0x00000000
    3c28:	2000eeac 	.word	0x2000eeac
    3c2c:	00000004 	.word	0x00000004
    3c30:	00000000 	.word	0x00000000
    3c34:	2000d1d4 	.word	0x2000d1d4
    3c38:	000007d0 	.word	0x000007d0
    3c3c:	00000000 	.word	0x00000000
    3c40:	2000eeb0 	.word	0x2000eeb0
    3c44:	00000004 	.word	0x00000004
    3c48:	00000000 	.word	0x00000000
    3c4c:	2000eeb4 	.word	0x2000eeb4
    3c50:	00000004 	.word	0x00000004
    3c54:	00000000 	.word	0x00000000
    3c58:	2000eeb8 	.word	0x2000eeb8
    3c5c:	00000004 	.word	0x00000004
    3c60:	00000000 	.word	0x00000000
    3c64:	2000eebc 	.word	0x2000eebc
    3c68:	00000004 	.word	0x00000004
    3c6c:	00000000 	.word	0x00000000
    3c70:	2000ef86 	.word	0x2000ef86
    3c74:	00000002 	.word	0x00000002
    3c78:	00000000 	.word	0x00000000
    3c7c:	2000eec0 	.word	0x2000eec0
    3c80:	00000004 	.word	0x00000004
    3c84:	00000000 	.word	0x00000000
    3c88:	2000eec4 	.word	0x2000eec4
    3c8c:	00000004 	.word	0x00000004
    3c90:	00000000 	.word	0x00000000
    3c94:	2000eac0 	.word	0x2000eac0
    3c98:	00000022 	.word	0x00000022
    3c9c:	00000000 	.word	0x00000000
    3ca0:	2000eec8 	.word	0x2000eec8
    3ca4:	00000004 	.word	0x00000004
    3ca8:	00000000 	.word	0x00000000
    3cac:	2000ed7c 	.word	0x2000ed7c
    3cb0:	00000008 	.word	0x00000008
    3cb4:	00000000 	.word	0x00000000
    3cb8:	2000eecc 	.word	0x2000eecc
    3cbc:	00000004 	.word	0x00000004
    3cc0:	00000000 	.word	0x00000000
    3cc4:	2000ef8d 	.word	0x2000ef8d
    3cc8:	00000001 	.word	0x00000001
    3ccc:	00000001 	.word	0x00000001
    3cd0:	00000003 	.word	0x00000003
    3cd4:	2000ef8e 	.word	0x2000ef8e
    3cd8:	00000001 	.word	0x00000001
    3cdc:	00000001 	.word	0x00000001
    3ce0:	00000007 	.word	0x00000007
    3ce4:	2000ef8f 	.word	0x2000ef8f
    3ce8:	00000001 	.word	0x00000001
    3cec:	00000000 	.word	0x00000000
    3cf0:	2000ea6c 	.word	0x2000ea6c
    3cf4:	0000002c 	.word	0x0000002c
    3cf8:	00000000 	.word	0x00000000
    3cfc:	2000a004 	.word	0x2000a004
    3d00:	00001000 	.word	0x00001000
    3d04:	00000000 	.word	0x00000000
    3d08:	2000b004 	.word	0x2000b004
    3d0c:	00001000 	.word	0x00001000
    3d10:	00000000 	.word	0x00000000
    3d14:	2000e9c0 	.word	0x2000e9c0
    3d18:	00000040 	.word	0x00000040
    3d1c:	00000000 	.word	0x00000000
    3d20:	2000ed84 	.word	0x2000ed84
    3d24:	00000008 	.word	0x00000008
    3d28:	00000000 	.word	0x00000000
    3d2c:	2000eed0 	.word	0x2000eed0
    3d30:	00000004 	.word	0x00000004
    3d34:	00000000 	.word	0x00000000
    3d38:	2000e768 	.word	0x2000e768
    3d3c:	00000080 	.word	0x00000080
    3d40:	00000000 	.word	0x00000000
    3d44:	2000ed8c 	.word	0x2000ed8c
    3d48:	00000008 	.word	0x00000008
    3d4c:	00000000 	.word	0x00000000
    3d50:	2000c004 	.word	0x2000c004
    3d54:	00000a00 	.word	0x00000a00
    3d58:	00000000 	.word	0x00000000
    3d5c:	2000eed4 	.word	0x2000eed4
    3d60:	00000004 	.word	0x00000004
    3d64:	00000000 	.word	0x00000000
    3d68:	2000ed58 	.word	0x2000ed58
    3d6c:	0000000c 	.word	0x0000000c
    3d70:	00000000 	.word	0x00000000
    3d74:	2000ed64 	.word	0x2000ed64
    3d78:	0000000c 	.word	0x0000000c
    3d7c:	00000000 	.word	0x00000000
    3d80:	2000e458 	.word	0x2000e458
    3d84:	000000c8 	.word	0x000000c8
    3d88:	00000000 	.word	0x00000000
    3d8c:	2000eed8 	.word	0x2000eed8
    3d90:	00000004 	.word	0x00000004
    3d94:	00000000 	.word	0x00000000
    3d98:	2000ef90 	.word	0x2000ef90
    3d9c:	00000001 	.word	0x00000001
    3da0:	00000000 	.word	0x00000000
    3da4:	2000ef91 	.word	0x2000ef91
    3da8:	00000001 	.word	0x00000001
    3dac:	00000000 	.word	0x00000000
    3db0:	2000eedc 	.word	0x2000eedc
    3db4:	00000004 	.word	0x00000004
    3db8:	00000000 	.word	0x00000000
    3dbc:	2000ea00 	.word	0x2000ea00
    3dc0:	00000038 	.word	0x00000038
    3dc4:	00000000 	.word	0x00000000
    3dc8:	2000e520 	.word	0x2000e520
    3dcc:	000000a0 	.word	0x000000a0
    3dd0:	00000000 	.word	0x00000000
    3dd4:	2000ef88 	.word	0x2000ef88
    3dd8:	00000002 	.word	0x00000002
    3ddc:	00000001 	.word	0x00000001
    3de0:	00000001 	.word	0x00000001
    3de4:	2000eee0 	.word	0x2000eee0
    3de8:	00000004 	.word	0x00000004
    3dec:	00000000 	.word	0x00000000
    3df0:	2000eee4 	.word	0x2000eee4
    3df4:	00000004 	.word	0x00000004
    3df8:	00000000 	.word	0x00000000
    3dfc:	2000eee8 	.word	0x2000eee8
    3e00:	00000004 	.word	0x00000004
    3e04:	00000000 	.word	0x00000000
    3e08:	2000e180 	.word	0x2000e180
    3e0c:	00000108 	.word	0x00000108
    3e10:	00000000 	.word	0x00000000
    3e14:	2000eeec 	.word	0x2000eeec
    3e18:	00000004 	.word	0x00000004
    3e1c:	00000000 	.word	0x00000000
    3e20:	2000eef0 	.word	0x2000eef0
    3e24:	00000004 	.word	0x00000004
    3e28:	00000000 	.word	0x00000000
    3e2c:	2000ec78 	.word	0x2000ec78
    3e30:	00000014 	.word	0x00000014
    3e34:	00000000 	.word	0x00000000
    3e38:	2000eb04 	.word	0x2000eb04
    3e3c:	00000020 	.word	0x00000020
    3e40:	00000001 	.word	0x00000001
	...
    3e4c:	0001be2c 	.word	0x0001be2c
    3e50:	0001be48 	.word	0x0001be48
    3e54:	0001be1c 	.word	0x0001be1c
    3e58:	0001be2c 	.word	0x0001be2c
    3e5c:	0001be2c 	.word	0x0001be2c
    3e60:	00000001 	.word	0x00000001
    3e64:	2000ec8c 	.word	0x2000ec8c
    3e68:	00000014 	.word	0x00000014
    3e6c:	00000001 	.word	0x00000001
    3e70:	00000101 	.word	0x00000101
    3e74:	00023e81 	.word	0x00023e81
    3e78:	00023e71 	.word	0x00023e71
    3e7c:	00023e91 	.word	0x00023e91
    3e80:	00009952 	.word	0x00009952
    3e84:	2000eef4 	.word	0x2000eef4
    3e88:	00000004 	.word	0x00000004
    3e8c:	00000001 	.word	0x00000001
    3e90:	aaaaaaaa 	.word	0xaaaaaaaa
    3e94:	2000eef8 	.word	0x2000eef8
    3e98:	00000004 	.word	0x00000004
    3e9c:	00000000 	.word	0x00000000
    3ea0:	20000004 	.word	0x20000004
    3ea4:	0000a000 	.word	0x0000a000
    3ea8:	00000000 	.word	0x00000000
    3eac:	2000eefc 	.word	0x2000eefc
    3eb0:	00000004 	.word	0x00000004
    3eb4:	00000000 	.word	0x00000000
    3eb8:	2000ef00 	.word	0x2000ef00
    3ebc:	00000004 	.word	0x00000004
    3ec0:	00000000 	.word	0x00000000
    3ec4:	2000ef04 	.word	0x2000ef04
    3ec8:	00000004 	.word	0x00000004
    3ecc:	00000000 	.word	0x00000000
    3ed0:	2000ef08 	.word	0x2000ef08
    3ed4:	00000004 	.word	0x00000004
    3ed8:	00000000 	.word	0x00000000
    3edc:	2000e850 	.word	0x2000e850
    3ee0:	00000064 	.word	0x00000064
    3ee4:	00000000 	.word	0x00000000
    3ee8:	2000ef0c 	.word	0x2000ef0c
    3eec:	00000004 	.word	0x00000004
    3ef0:	00000000 	.word	0x00000000
    3ef4:	2000ef10 	.word	0x2000ef10
    3ef8:	00000004 	.word	0x00000004
    3efc:	00000000 	.word	0x00000000
    3f00:	2000ef14 	.word	0x2000ef14
    3f04:	00000004 	.word	0x00000004
    3f08:	00000000 	.word	0x00000000
    3f0c:	2000ef18 	.word	0x2000ef18
    3f10:	00000004 	.word	0x00000004
    3f14:	00000000 	.word	0x00000000
    3f18:	2000ef1c 	.word	0x2000ef1c
    3f1c:	00000004 	.word	0x00000004
    3f20:	00000000 	.word	0x00000000
    3f24:	2000eca0 	.word	0x2000eca0
    3f28:	00000014 	.word	0x00000014
    3f2c:	00000000 	.word	0x00000000
    3f30:	2000ecb4 	.word	0x2000ecb4
    3f34:	00000014 	.word	0x00000014
    3f38:	00000000 	.word	0x00000000
    3f3c:	2000ef20 	.word	0x2000ef20
    3f40:	00000004 	.word	0x00000004
    3f44:	00000000 	.word	0x00000000
    3f48:	2000ef24 	.word	0x2000ef24
    3f4c:	00000004 	.word	0x00000004
    3f50:	00000000 	.word	0x00000000
    3f54:	2000ef28 	.word	0x2000ef28
    3f58:	00000004 	.word	0x00000004
    3f5c:	00000000 	.word	0x00000000
    3f60:	2000ef2c 	.word	0x2000ef2c
    3f64:	00000004 	.word	0x00000004
    3f68:	00000000 	.word	0x00000000
    3f6c:	2000ecc8 	.word	0x2000ecc8
    3f70:	00000014 	.word	0x00000014
    3f74:	00000000 	.word	0x00000000
    3f78:	2000ef30 	.word	0x2000ef30
    3f7c:	00000004 	.word	0x00000004
    3f80:	00000000 	.word	0x00000000
    3f84:	2000ecdc 	.word	0x2000ecdc
    3f88:	00000014 	.word	0x00000014
    3f8c:	00000000 	.word	0x00000000
    3f90:	2000ecf0 	.word	0x2000ecf0
    3f94:	00000014 	.word	0x00000014
    3f98:	00000000 	.word	0x00000000
    3f9c:	2000ef34 	.word	0x2000ef34
    3fa0:	00000004 	.word	0x00000004
    3fa4:	00000000 	.word	0x00000000
    3fa8:	2000ef38 	.word	0x2000ef38
    3fac:	00000004 	.word	0x00000004
    3fb0:	00000000 	.word	0x00000000
    3fb4:	2000ef3c 	.word	0x2000ef3c
    3fb8:	00000004 	.word	0x00000004
    3fbc:	00000000 	.word	0x00000000
    3fc0:	2000dc14 	.word	0x2000dc14
    3fc4:	00000200 	.word	0x00000200
    3fc8:	00000000 	.word	0x00000000
    3fcc:	2000ed70 	.word	0x2000ed70
    3fd0:	0000000c 	.word	0x0000000c
    3fd4:	00000001 	.word	0x00000001
    3fd8:	00000000 	.word	0x00000000
    3fdc:	0000df7c 	.word	0x0000df7c
    3fe0:	7d200706 	.word	0x7d200706
    3fe4:	2000e8b4 	.word	0x2000e8b4
    3fe8:	00000060 	.word	0x00000060
    3fec:	00000000 	.word	0x00000000
    3ff0:	2000ef40 	.word	0x2000ef40
    3ff4:	00000004 	.word	0x00000004
    3ff8:	00000000 	.word	0x00000000
    3ffc:	2000ef44 	.word	0x2000ef44
    4000:	00000004 	.word	0x00000004
    4004:	00000000 	.word	0x00000000
    4008:	2000ef48 	.word	0x2000ef48
    400c:	00000004 	.word	0x00000004
    4010:	00000000 	.word	0x00000000
    4014:	2000ed94 	.word	0x2000ed94
    4018:	00000008 	.word	0x00000008
    401c:	00000001 	.word	0x00000001
    4020:	ffffffff 	.word	0xffffffff
    4024:	ffffffff 	.word	0xffffffff
    4028:	2000ef92 	.word	0x2000ef92
    402c:	00000001 	.word	0x00000001
    4030:	00000000 	.word	0x00000000
    4034:	2000ed04 	.word	0x2000ed04
    4038:	00000014 	.word	0x00000014
    403c:	00000000 	.word	0x00000000
    4040:	2000de14 	.word	0x2000de14
    4044:	00000200 	.word	0x00000200
    4048:	00000000 	.word	0x00000000
    404c:	2000ef4c 	.word	0x2000ef4c
    4050:	00000004 	.word	0x00000004
    4054:	00000000 	.word	0x00000000
    4058:	2000ef50 	.word	0x2000ef50
    405c:	00000004 	.word	0x00000004
    4060:	00000000 	.word	0x00000000
    4064:	2000ef70 	.word	0x2000ef70
    4068:	00000001 	.word	0x00000001
    406c:	00000000 	.word	0x00000000
    4070:	2000eae2 	.word	0x2000eae2
    4074:	00000002 	.word	0x00000002
    4078:	00000000 	.word	0x00000000
    407c:	2000ef54 	.word	0x2000ef54
    4080:	00000004 	.word	0x00000004
    4084:	00000000 	.word	0x00000000
    4088:	2000ef58 	.word	0x2000ef58
    408c:	00000004 	.word	0x00000004
    4090:	00000000 	.word	0x00000000
    4094:	2000ef5c 	.word	0x2000ef5c
    4098:	00000004 	.word	0x00000004
    409c:	00000000 	.word	0x00000000
    40a0:	2000ef60 	.word	0x2000ef60
    40a4:	00000004 	.word	0x00000004
    40a8:	00000001 	.word	0x00000001
    40ac:	2000e914 	.word	0x2000e914
    40b0:	2000e914 	.word	0x2000e914
    40b4:	00000060 	.word	0x00000060
    40b8:	00000001 	.word	0x00000001
    40bc:	00000000 	.word	0x00000000
    40c0:	2000eb44 	.word	0x2000eb44
    40c4:	2000eb64 	.word	0x2000eb64
    40c8:	2000eb24 	.word	0x2000eb24
	...
    411c:	2000ef64 	.word	0x2000ef64
    4120:	00000004 	.word	0x00000004
    4124:	00000000 	.word	0x00000000
    4128:	2000ef68 	.word	0x2000ef68
    412c:	00000004 	.word	0x00000004
    4130:	00000000 	.word	0x00000000
    4134:	2000eb24 	.word	0x2000eb24
    4138:	00000020 	.word	0x00000020
    413c:	00000000 	.word	0x00000000
    4140:	2000eb44 	.word	0x2000eb44
    4144:	00000020 	.word	0x00000020
    4148:	00000000 	.word	0x00000000
    414c:	2000eb64 	.word	0x2000eb64
    4150:	00000020 	.word	0x00000020
    4154:	00000000 	.word	0x00000000
    4158:	2000e014 	.word	0x2000e014
    415c:	0000016c 	.word	0x0000016c
    4160:	00000001 	.word	0x00000001
    4164:	00000043 	.word	0x00000043
	...
    4184:	00000043 	.word	0x00000043
	...
    41a4:	00000043 	.word	0x00000043
	...
    41c4:	00000043 	.word	0x00000043
	...
    41e4:	00000043 	.word	0x00000043
	...
    4204:	00000043 	.word	0x00000043
	...
    4224:	00000043 	.word	0x00000043
	...
    4244:	00023531 	.word	0x00023531
    4248:	000227d9 	.word	0x000227d9
    424c:	00000000 	.word	0x00000000
    4250:	00015854 	.word	0x00015854
    4254:	00024301 	.word	0x00024301
    4258:	00024300 	.word	0x00024300
    425c:	00024300 	.word	0x00024300
    4260:	00024300 	.word	0x00024300
    4264:	00024300 	.word	0x00024300
    4268:	00024300 	.word	0x00024300
    426c:	00024300 	.word	0x00024300
    4270:	00024300 	.word	0x00024300
    4274:	00024300 	.word	0x00024300
    4278:	00024300 	.word	0x00024300
    427c:	ffffffff 	.word	0xffffffff
    4280:	ffffffff 	.word	0xffffffff
    4284:	ffffffff 	.word	0xffffffff
    4288:	0000ffff 	.word	0x0000ffff
    428c:	53410001 	.word	0x53410001
    4290:	00494943 	.word	0x00494943
	...
    42ac:	53410000 	.word	0x53410000
    42b0:	00494943 	.word	0x00494943
	...
    42d0:	20000000 	.word	0x20000000
    42d4:	00000004 	.word	0x00000004
    42d8:	00000000 	.word	0x00000000
    42dc:	2000ef6c 	.word	0x2000ef6c
    42e0:	00000004 	.word	0x00000004
	...
    42f0:	22222222 	.word	0x22222222
    42f4:	22222222 	.word	0x22222222

Disassembly of section .text._DHCPS_ProcessGetPktandSendResponse%215:

000042f8 <_DHCPS_ProcessGetPktandSendResponse>:


void TriggerDHCPSRestart(void);

static bool _DHCPS_ProcessGetPktandSendResponse(void)
{
    42f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    42fc:	ed2d 8b04 	vpush	{d8-d9}
    4300:	f5ad 7d45 	sub.w	sp, sp, #788	; 0x314
    OA_HASH_ENTRY   	*hE;
    DHCPS_HASH_DCPT  	*pdhcpsHashDcpt;
    DHCP_SRVR_DCPT	*pDhcpsDcpt=NULL;
    UDP_SOCKET_INFO     udpSockInfo;
    TCPIP_NET_IF        *pNetIfFromDcpt=NULL;
    uint32_t            ix=0;
    4304:	2300      	movs	r3, #0
    4306:	93ad      	str	r3, [sp, #692]	; 0x2b4
    TCPIP_DHCPS_STATE_STATUS dhcpsSmSate;
    BOOTP_HEADER	   BOOTPHeader;
    
    s = dhcps_mod.uSkt;
    dhcpsSmSate = dhcps_mod.smState;
    if(gPdhcpSDcpt == NULL)
    4308:	4bb1      	ldr	r3, [pc, #708]	; (45d0 <_DHCPS_ProcessGetPktandSendResponse+0x2d8>)
    430a:	681b      	ldr	r3, [r3, #0]
    430c:	2b00      	cmp	r3, #0
    430e:	f000 857c 	beq.w	4e0a <_DHCPS_ProcessGetPktandSendResponse+0xb12>
    s = dhcps_mod.uSkt;
    4312:	4bb0      	ldr	r3, [pc, #704]	; (45d4 <_DHCPS_ProcessGetPktandSendResponse+0x2dc>)
    4314:	f9b3 2000 	ldrsh.w	r2, [r3]
    4318:	9200      	str	r2, [sp, #0]
    dhcpsSmSate = dhcps_mod.smState;
    431a:	78dd      	ldrb	r5, [r3, #3]
    TCPIP_NET_IF        *pNetIfFromDcpt=NULL;
    431c:	f04f 0900 	mov.w	r9, #0
    DHCP_SRVR_DCPT	*pDhcpsDcpt=NULL;
    4320:	46cb      	mov	fp, r9
    bool		bAccept=false, bRenew=false;
    4322:	f8cd 9004 	str.w	r9, [sp, #4]
    4326:	f8cd 9010 	str.w	r9, [sp, #16]
    uint32_t            buffsize=0;
    432a:	464c      	mov	r4, r9
                        break;
                    case TCPIP_DHCPS_START_ICMP_PROCESS: SYS_CONSOLE_PRINT("TCPIP_DHCPS_START_ICMP_PROCESS\n\r");
                        break;
                    case TCPIP_DHCPS_GET_NEW_ADDRESS: SYS_CONSOLE_PRINT("TCPIP_DHCPS_GET_NEW_ADDRESS\n\r");
                        break;
                    default: SYS_CONSOLE_PRINT("DHCPS State Unknown");
    432c:	f8df a2bc 	ldr.w	sl, [pc, #700]	; 45ec <_DHCPS_ProcessGetPktandSendResponse+0x2f4>
    4330:	f50a 7319 	add.w	r3, sl, #612	; 0x264
    4334:	9305      	str	r3, [sp, #20]
    }
     optionTypeTotalLen = sizeof(optionType.messageType);
     
    optionType.renewalTime_t1.optionType = DHCP_PARAM_RENEWAL_TIME_OPTION;
    optionType.renewalTime_t1.optionTypeLen = 4;
    optionType.renewalTime_t1.intVal = 0.5 * pdhcpsHashDcpt->leaseDuartion;
    4336:	ed9f 9ba2 	vldr	d9, [pc, #648]	; 45c0 <_DHCPS_ProcessGetPktandSendResponse+0x2c8>
    optionType.renewalTime_t1.intVal = TCPIP_Helper_htonl(optionType.renewalTime_t1.intVal);
    optionTypeTotalLen += sizeof(optionType.renewalTime_t1);
    
    optionType.rebindTime_t2.optionType = DHCP_PARAM_REBIND_TIME_OPTION;
    optionType.rebindTime_t2.optionTypeLen = 4;
    optionType.rebindTime_t2.intVal = 0.875 * pdhcpsHashDcpt->leaseDuartion;
    433a:	ed9f 8ba3 	vldr	d8, [pc, #652]	; 45c8 <_DHCPS_ProcessGetPktandSendResponse+0x2d0>
    433e:	e000      	b.n	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
                    dhcpsSmSate = TCPIP_DHCPS_START_RECV_NEW_PACKET;
    4340:	2501      	movs	r5, #1
            if (dhcpsSmSate_old != dhcpsSmSate) {
    4342:	4ea5      	ldr	r6, [pc, #660]	; (45d8 <_DHCPS_ProcessGetPktandSendResponse+0x2e0>)
    4344:	7833      	ldrb	r3, [r6, #0]
    4346:	42ab      	cmp	r3, r5
    4348:	d01a      	beq.n	4380 <_DHCPS_ProcessGetPktandSendResponse+0x88>
                switch (dhcpsSmSate) {
    434a:	2d08      	cmp	r5, #8
    434c:	d857      	bhi.n	43fe <_DHCPS_ProcessGetPktandSendResponse+0x106>
    434e:	e8df f005 	tbb	[pc, r5]
    4352:	2411      	.short	0x2411
    4354:	3c36302a 	.word	0x3c36302a
    4358:	4a42      	.short	0x4a42
    435a:	50          	.byte	0x50
    435b:	00          	.byte	0x00
                    dhcpsSmSate = TCPIP_DHCPS_START_RECV_NEW_PACKET;
    435c:	2501      	movs	r5, #1
    435e:	e7f0      	b.n	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
                    dhcpsSmSate = TCPIP_DHCPS_START_RECV_NEW_PACKET;
    4360:	4635      	mov	r5, r6
    4362:	e7ee      	b.n	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
                    dhcpsSmSate = TCPIP_DHCPS_START_RECV_NEW_PACKET;
    4364:	4635      	mov	r5, r6
    4366:	e7ec      	b.n	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
                    dhcpsSmSate = TCPIP_DHCPS_START_RECV_NEW_PACKET;
    4368:	4635      	mov	r5, r6
    436a:	e7ea      	b.n	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
                    dhcpsSmSate = TCPIP_DHCPS_START_RECV_NEW_PACKET;
    436c:	2501      	movs	r5, #1
    436e:	e7e8      	b.n	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
                            dhcpsSmSate = TCPIP_DHCPS_START_RECV_NEW_PACKET;
    4370:	2501      	movs	r5, #1
    4372:	e7e6      	b.n	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
                    case TCPIP_DHCPS_STATE_IDLE: SYS_CONSOLE_PRINT("TCPIP_DHCPS_STATE_IDLE\n\r");
    4374:	f50a 71a2 	add.w	r1, sl, #324	; 0x144
    4378:	2000      	movs	r0, #0
    437a:	f018 f98f 	bl	1c69c <SYS_CONSOLE_Print>
                dhcpsSmSate_old = dhcpsSmSate;
    437e:	7035      	strb	r5, [r6, #0]
        switch(dhcpsSmSate)
    4380:	1e6b      	subs	r3, r5, #1
    4382:	2b07      	cmp	r3, #7
    4384:	d8de      	bhi.n	4344 <_DHCPS_ProcessGetPktandSendResponse+0x4c>
    4386:	e8df f013 	tbh	[pc, r3, lsl #1]
    438a:	003f      	.short	0x003f
    438c:	00610053 	.word	0x00610053
    4390:	00d300e4 	.word	0x00d300e4
    4394:	047e04c0 	.word	0x047e04c0
    4398:	0493      	.short	0x0493
                    case TCPIP_DHCPS_START_RECV_NEW_PACKET: SYS_CONSOLE_PRINT("TCPIP_DHCPS_START_RECV_NEW_PACKET\n\r");
    439a:	f50a 71b0 	add.w	r1, sl, #352	; 0x160
    439e:	2000      	movs	r0, #0
    43a0:	f018 f97c 	bl	1c69c <SYS_CONSOLE_Print>
                        break;
    43a4:	e7eb      	b.n	437e <_DHCPS_ProcessGetPktandSendResponse+0x86>
                    case TCPIP_DHCPS_DETECT_VALID_INTF: SYS_CONSOLE_PRINT("TCPIP_DHCPS_DETECT_VALID_INTF\n\r");
    43a6:	f50a 71c2 	add.w	r1, sl, #388	; 0x184
    43aa:	2000      	movs	r0, #0
    43ac:	f018 f976 	bl	1c69c <SYS_CONSOLE_Print>
                        break;
    43b0:	e7e5      	b.n	437e <_DHCPS_ProcessGetPktandSendResponse+0x86>
                    case TCPIP_DHCPS_PARSE_RECVED_PACKET: SYS_CONSOLE_PRINT("TCPIP_DHCPS_PARSE_RECVED_PACKET\n\r");
    43b2:	f50a 71d2 	add.w	r1, sl, #420	; 0x1a4
    43b6:	2000      	movs	r0, #0
    43b8:	f018 f970 	bl	1c69c <SYS_CONSOLE_Print>
                        break;
    43bc:	e7df      	b.n	437e <_DHCPS_ProcessGetPktandSendResponse+0x86>
                    case TCPIP_DHCPS_MESSAGE_TYPE: SYS_CONSOLE_PRINT("TCPIP_DHCPS_MESSAGE_TYPE\n\r");
    43be:	f50a 71e4 	add.w	r1, sl, #456	; 0x1c8
    43c2:	2000      	movs	r0, #0
    43c4:	f018 f96a 	bl	1c69c <SYS_CONSOLE_Print>
                        break;
    43c8:	e7d9      	b.n	437e <_DHCPS_ProcessGetPktandSendResponse+0x86>
                    case TCPIP_DHCPS_FIND_DESCRIPTOR: SYS_CONSOLE_PRINT("TCPIP_DHCPS_FIND_DESCRIPTOR\n\r");
    43ca:	f50a 71f2 	add.w	r1, sl, #484	; 0x1e4
    43ce:	2000      	movs	r0, #0
    43d0:	f018 f964 	bl	1c69c <SYS_CONSOLE_Print>
                        break;
    43d4:	e7d3      	b.n	437e <_DHCPS_ProcessGetPktandSendResponse+0x86>
                        TriggerDHCPSRestart();
    43d6:	f01f ff71 	bl	242bc <TriggerDHCPSRestart>
                        SYS_CONSOLE_PRINT("TCPIP_DHCPS_SEND_OFFER\n\r");
    43da:	f50a 7101 	add.w	r1, sl, #516	; 0x204
    43de:	2000      	movs	r0, #0
    43e0:	f018 f95c 	bl	1c69c <SYS_CONSOLE_Print>
                        break;
    43e4:	e7cb      	b.n	437e <_DHCPS_ProcessGetPktandSendResponse+0x86>
                    case TCPIP_DHCPS_START_ICMP_PROCESS: SYS_CONSOLE_PRINT("TCPIP_DHCPS_START_ICMP_PROCESS\n\r");
    43e6:	f50a 7108 	add.w	r1, sl, #544	; 0x220
    43ea:	2000      	movs	r0, #0
    43ec:	f018 f956 	bl	1c69c <SYS_CONSOLE_Print>
                        break;
    43f0:	e7c5      	b.n	437e <_DHCPS_ProcessGetPktandSendResponse+0x86>
                    case TCPIP_DHCPS_GET_NEW_ADDRESS: SYS_CONSOLE_PRINT("TCPIP_DHCPS_GET_NEW_ADDRESS\n\r");
    43f2:	f50a 7111 	add.w	r1, sl, #580	; 0x244
    43f6:	2000      	movs	r0, #0
    43f8:	f018 f950 	bl	1c69c <SYS_CONSOLE_Print>
                        break;
    43fc:	e7bf      	b.n	437e <_DHCPS_ProcessGetPktandSendResponse+0x86>
                    default: SYS_CONSOLE_PRINT("DHCPS State Unknown");
    43fe:	9905      	ldr	r1, [sp, #20]
    4400:	2000      	movs	r0, #0
    4402:	f018 f94b 	bl	1c69c <SYS_CONSOLE_Print>
    4406:	e7ba      	b.n	437e <_DHCPS_ProcessGetPktandSendResponse+0x86>
                buffsize = TCPIP_UDP_GetIsReady(s);
    4408:	9800      	ldr	r0, [sp, #0]
    440a:	f01d fec7 	bl	2219c <TCPIP_UDP_GetIsReady>
    440e:	4604      	mov	r4, r0
                if(buffsize == 0) 
    4410:	2800      	cmp	r0, #0
    4412:	f000 84fc 	beq.w	4e0e <_DHCPS_ProcessGetPktandSendResponse+0xb16>
                if(buffsize < TCPIP_DHCPS_MIN_DISCOVERY_PKT_SIZE)
    4416:	f5b0 7f96 	cmp.w	r0, #300	; 0x12c
    441a:	d35a      	bcc.n	44d2 <_DHCPS_ProcessGetPktandSendResponse+0x1da>
                if(dhcps_mod.smServer == DHCP_SERVER_ICMP_PROCESS)
    441c:	4b6d      	ldr	r3, [pc, #436]	; (45d4 <_DHCPS_ProcessGetPktandSendResponse+0x2dc>)
    441e:	789d      	ldrb	r5, [r3, #2]
    4420:	2d01      	cmp	r5, #1
    4422:	d05a      	beq.n	44da <_DHCPS_ProcessGetPktandSendResponse+0x1e2>
                memset(getBuffer,0,sizeof(getBuffer));
    4424:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
    4428:	2100      	movs	r1, #0
    442a:	a835      	add	r0, sp, #212	; 0xd4
    442c:	f01f fd38 	bl	23ea0 <memset>
                TCPIP_UDP_SocketInfoGet(s, &udpSockInfo);
    4430:	a9ae      	add	r1, sp, #696	; 0x2b8
    4432:	9800      	ldr	r0, [sp, #0]
    4434:	f018 fd0a 	bl	1ce4c <TCPIP_UDP_SocketInfoGet>
                pNetIfFromDcpt = (TCPIP_NET_IF*)udpSockInfo.hNet;
    4438:	f8dd 9300 	ldr.w	r9, [sp, #768]	; 0x300
                if(!_DHCPS_ValidatePktReceivedIntf(pNetIfFromDcpt))
    443c:	4648      	mov	r0, r9
    443e:	f01c f8ac 	bl	2059a <_DHCPS_ValidatePktReceivedIntf>
    4442:	2800      	cmp	r0, #0
    4444:	d04d      	beq.n	44e2 <_DHCPS_ProcessGetPktandSendResponse+0x1ea>
                gpDhcpsNetH = pNetIfFromDcpt;
    4446:	4b65      	ldr	r3, [pc, #404]	; (45dc <_DHCPS_ProcessGetPktandSendResponse+0x2e4>)
    4448:	f8c3 9000 	str.w	r9, [r3]
                if(buffsize > sizeof(getBuffer))
    444c:	f5b4 7ff0 	cmp.w	r4, #480	; 0x1e0
    4450:	bf28      	it	cs
    4452:	f44f 74f0 	movcs.w	r4, #480	; 0x1e0
                udpGetBufferData.head = getBuffer;
    4456:	a935      	add	r1, sp, #212	; 0xd4
    4458:	9132      	str	r1, [sp, #200]	; 0xc8
                udpGetBufferData.wrPtr = udpGetBufferData.head;
    445a:	9133      	str	r1, [sp, #204]	; 0xcc
                udpGetBufferData.endPtr = udpGetBufferData.head+buffsize;
    445c:	190b      	adds	r3, r1, r4
    445e:	9334      	str	r3, [sp, #208]	; 0xd0
                TCPIP_UDP_ArrayGet(s,udpGetBufferData.head,buffsize);
    4460:	b2a2      	uxth	r2, r4
    4462:	9d00      	ldr	r5, [sp, #0]
    4464:	4628      	mov	r0, r5
    4466:	f012 fae9 	bl	16a3c <TCPIP_UDP_ArrayGet>
                TCPIP_UDP_Discard(s);
    446a:	4628      	mov	r0, r5
    446c:	f01e fa65 	bl	2293a <TCPIP_UDP_Discard>
                if(!TCPIP_DHCPS_GetArrayOfDataFromUDPBuff(&udpGetBufferData, (uint8_t*)&BOOTPHeader, sizeof(BOOTPHeader)))
    4470:	2222      	movs	r2, #34	; 0x22
    4472:	a928      	add	r1, sp, #160	; 0xa0
    4474:	a832      	add	r0, sp, #200	; 0xc8
    4476:	f01c ffa9 	bl	213cc <TCPIP_DHCPS_GetArrayOfDataFromUDPBuff>
    447a:	2800      	cmp	r0, #0
    447c:	f43f af60 	beq.w	4340 <_DHCPS_ProcessGetPktandSendResponse+0x48>
                memcpy(&gBOOTPHeader,&BOOTPHeader,sizeof(BOOTPHeader));
    4480:	4f57      	ldr	r7, [pc, #348]	; (45e0 <_DHCPS_ProcessGetPktandSendResponse+0x2e8>)
    4482:	463d      	mov	r5, r7
    4484:	ae28      	add	r6, sp, #160	; 0xa0
    4486:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    4488:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    448a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    448c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    448e:	6833      	ldr	r3, [r6, #0]
    4490:	802b      	strh	r3, [r5, #0]
                hE = TCPIP_OAHASH_EntryLookup(pdhcpsHashDcpt->hashDcpt, &gBOOTPHeader.ClientMAC);
    4492:	f107 011c 	add.w	r1, r7, #28
    4496:	4b53      	ldr	r3, [pc, #332]	; (45e4 <_DHCPS_ProcessGetPktandSendResponse+0x2ec>)
    4498:	6818      	ldr	r0, [r3, #0]
    449a:	f018 fa73 	bl	1c984 <TCPIP_OAHASH_EntryLookup>
                if(hE != 0)
    449e:	b328      	cbz	r0, 44ec <_DHCPS_ProcessGetPktandSendResponse+0x1f4>
                    ClientIP = gBOOTPHeader.ClientIP;
    44a0:	68fa      	ldr	r2, [r7, #12]
    44a2:	9231      	str	r2, [sp, #196]	; 0xc4
    return memcmp((void*)&((DHCPS_HASH_ENTRY*)hEntry)->hwAdd, key, DHCPS_HASH_KEY_SIZE);
}

int TCPIP_DHCPS_HashIPKeyCompare(OA_HASH_DCPT* pOH, OA_HASH_ENTRY* hEntry, const uint8_t* key)
{
    return memcmp(((DHCPS_HASH_ENTRY*)hEntry)->ipAddress.v, key, sizeof(((DHCPS_HASH_ENTRY*)hEntry)->ipAddress));
    44a4:	2204      	movs	r2, #4
    44a6:	a931      	add	r1, sp, #196	; 0xc4
    44a8:	300c      	adds	r0, #12
    44aa:	f01e ff11 	bl	232d0 <memcmp>
                    if(TCPIP_DHCPS_HashIPKeyCompare(pdhcpsHashDcpt->hashDcpt, hE, ClientIP.v) == 0)
    44ae:	b330      	cbz	r0, 44fe <_DHCPS_ProcessGetPktandSendResponse+0x206>
                        bRenew = false;
    44b0:	2300      	movs	r3, #0
    44b2:	9301      	str	r3, [sp, #4]
                        bAccept = false;
    44b4:	9304      	str	r3, [sp, #16]
                if((gBOOTPHeader.MessageType != 1u) || (gBOOTPHeader.HardwareType != 1u) || (gBOOTPHeader.HardwareLen != 6u))
    44b6:	4b4a      	ldr	r3, [pc, #296]	; (45e0 <_DHCPS_ProcessGetPktandSendResponse+0x2e8>)
    44b8:	781d      	ldrb	r5, [r3, #0]
    44ba:	2d01      	cmp	r5, #1
    44bc:	f47f af4e 	bne.w	435c <_DHCPS_ProcessGetPktandSendResponse+0x64>
    44c0:	785e      	ldrb	r6, [r3, #1]
    44c2:	2e01      	cmp	r6, #1
    44c4:	f47f af3d 	bne.w	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
    44c8:	789b      	ldrb	r3, [r3, #2]
    44ca:	2b06      	cmp	r3, #6
    44cc:	d01b      	beq.n	4506 <_DHCPS_ProcessGetPktandSendResponse+0x20e>
                    dhcpsSmSate = TCPIP_DHCPS_START_RECV_NEW_PACKET;
    44ce:	4635      	mov	r5, r6
    44d0:	e737      	b.n	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
                    TCPIP_UDP_Discard(s);
    44d2:	9800      	ldr	r0, [sp, #0]
    44d4:	f01e fa31 	bl	2293a <TCPIP_UDP_Discard>
                    continue;
    44d8:	e733      	b.n	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
                    TCPIP_UDP_Discard(s);
    44da:	9800      	ldr	r0, [sp, #0]
    44dc:	f01e fa2d 	bl	2293a <TCPIP_UDP_Discard>
                    continue;
    44e0:	e72f      	b.n	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
                    TCPIP_UDP_Discard(s);
    44e2:	9800      	ldr	r0, [sp, #0]
    44e4:	f01e fa29 	bl	2293a <TCPIP_UDP_Discard>
                    dhcpsSmSate = TCPIP_DHCPS_START_RECV_NEW_PACKET;
    44e8:	2501      	movs	r5, #1
                    continue;
    44ea:	e72a      	b.n	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
                else if(gBOOTPHeader.ClientIP.Val == 0x00000000u)
    44ec:	4b3c      	ldr	r3, [pc, #240]	; (45e0 <_DHCPS_ProcessGetPktandSendResponse+0x2e8>)
    44ee:	68db      	ldr	r3, [r3, #12]
    44f0:	fab3 f383 	clz	r3, r3
    44f4:	095b      	lsrs	r3, r3, #5
    44f6:	9304      	str	r3, [sp, #16]
                    bRenew = false;
    44f8:	2300      	movs	r3, #0
    44fa:	9301      	str	r3, [sp, #4]
    44fc:	e7db      	b.n	44b6 <_DHCPS_ProcessGetPktandSendResponse+0x1be>
                        bRenew= true;
    44fe:	2301      	movs	r3, #1
    4500:	9301      	str	r3, [sp, #4]
                        bAccept = true;
    4502:	9304      	str	r3, [sp, #16]
    4504:	e7d7      	b.n	44b6 <_DHCPS_ProcessGetPktandSendResponse+0x1be>
                if(!TCPIP_DHCPS_GetArrayOfDataFromUDPBuff(&udpGetBufferData,0,DHCPS_UNUSED_BYTES_FOR_TX))
    4506:	22ca      	movs	r2, #202	; 0xca
    4508:	2100      	movs	r1, #0
    450a:	a832      	add	r0, sp, #200	; 0xc8
    450c:	f01c ff5e 	bl	213cc <TCPIP_DHCPS_GetArrayOfDataFromUDPBuff>
    4510:	2800      	cmp	r0, #0
    4512:	f43f af25 	beq.w	4360 <_DHCPS_ProcessGetPktandSendResponse+0x68>
                if(!TCPIP_DHCPS_GetArrayOfDataFromUDPBuff(&udpGetBufferData,(uint8_t*)&dw, sizeof(uint32_t)))
    4516:	2204      	movs	r2, #4
    4518:	a9c2      	add	r1, sp, #776	; 0x308
    451a:	a832      	add	r0, sp, #200	; 0xc8
    451c:	f01c ff56 	bl	213cc <TCPIP_DHCPS_GetArrayOfDataFromUDPBuff>
    4520:	2800      	cmp	r0, #0
    4522:	f43f af1f 	beq.w	4364 <_DHCPS_ProcessGetPktandSendResponse+0x6c>
                if(dw != TCPIP_DHCPS_MAGIC_COOKIE)
    4526:	9bc2      	ldr	r3, [sp, #776]	; 0x308
    4528:	4a2f      	ldr	r2, [pc, #188]	; (45e8 <_DHCPS_ProcessGetPktandSendResponse+0x2f0>)
    452a:	4293      	cmp	r3, r2
    452c:	f47f af1c 	bne.w	4368 <_DHCPS_ProcessGetPktandSendResponse+0x70>
                ix=0;
    4530:	2300      	movs	r3, #0
    4532:	93ad      	str	r3, [sp, #692]	; 0x2b4
                if(_DHCPSDescriptorGetFromIntf(pNetIfFromDcpt,&ix) == false)
    4534:	a9ad      	add	r1, sp, #692	; 0x2b4
    4536:	4648      	mov	r0, r9
    4538:	f019 ff78 	bl	1e42c <_DHCPSDescriptorGetFromIntf>
    453c:	4603      	mov	r3, r0
    453e:	2800      	cmp	r0, #0
    4540:	f000 83af 	beq.w	4ca2 <_DHCPS_ProcessGetPktandSendResponse+0x9aa>
                pDhcpsDcpt = gPdhcpSDcpt+ix;
    4544:	9bad      	ldr	r3, [sp, #692]	; 0x2b4
    4546:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
    454a:	4a21      	ldr	r2, [pc, #132]	; (45d0 <_DHCPS_ProcessGetPktandSendResponse+0x2d8>)
    454c:	6812      	ldr	r2, [r2, #0]
    454e:	eb02 0b83 	add.w	fp, r2, r3, lsl #2
                if(_DHCPS_GetOptionLen(&udpGetBufferData,&Option,&Len)!= true)
    4552:	f20d 320d 	addw	r2, sp, #781	; 0x30d
    4556:	f20d 310e 	addw	r1, sp, #782	; 0x30e
    455a:	a832      	add	r0, sp, #200	; 0xc8
    455c:	f01d fe32 	bl	221c4 <_DHCPS_GetOptionLen>
    4560:	2800      	cmp	r0, #0
    4562:	f43f af03 	beq.w	436c <_DHCPS_ProcessGetPktandSendResponse+0x74>
                switch(Option)
    4566:	f89d 330e 	ldrb.w	r3, [sp, #782]	; 0x30e
    456a:	2b35      	cmp	r3, #53	; 0x35
    456c:	d00f      	beq.n	458e <_DHCPS_ProcessGetPktandSendResponse+0x296>
    456e:	2504      	movs	r5, #4
                if(!TCPIP_DHCPS_GetArrayOfDataFromUDPBuff(&udpGetBufferData,0,Len))
    4570:	f89d 230d 	ldrb.w	r2, [sp, #781]	; 0x30d
    4574:	2100      	movs	r1, #0
    4576:	a832      	add	r0, sp, #200	; 0xc8
    4578:	f01c ff28 	bl	213cc <TCPIP_DHCPS_GetArrayOfDataFromUDPBuff>
    457c:	2800      	cmp	r0, #0
    457e:	f43f aee0 	beq.w	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
                Len = 0;
    4582:	2300      	movs	r3, #0
    4584:	f88d 330d 	strb.w	r3, [sp, #781]	; 0x30d
    dhcps_mod.smState = newState;
    4588:	4b12      	ldr	r3, [pc, #72]	; (45d4 <_DHCPS_ProcessGetPktandSendResponse+0x2dc>)
    458a:	70dd      	strb	r5, [r3, #3]
    458c:	e6d9      	b.n	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
                        if(!TCPIP_DHCPS_GetDataFromUDPBuff(&udpGetBufferData,&i))
    458e:	f20d 310f 	addw	r1, sp, #783	; 0x30f
    4592:	a832      	add	r0, sp, #200	; 0xc8
    4594:	f01e ff98 	bl	234c8 <TCPIP_DHCPS_GetDataFromUDPBuff>
    4598:	2800      	cmp	r0, #0
    459a:	f43f aee9 	beq.w	4370 <_DHCPS_ProcessGetPktandSendResponse+0x78>
                        if(i == DHCP_DISCOVER_MESSAGE)
    459e:	f89d 530f 	ldrb.w	r5, [sp, #783]	; 0x30f
    45a2:	2d01      	cmp	r5, #1
    45a4:	d045      	beq.n	4632 <_DHCPS_ProcessGetPktandSendResponse+0x33a>
                        else if(i==DHCP_REQUEST_MESSAGE)
    45a6:	2d03      	cmp	r5, #3
    45a8:	d060      	beq.n	466c <_DHCPS_ProcessGetPktandSendResponse+0x374>
                        else if((i== DHCP_RELEASE_MESSAGE) ||(i==DHCP_DECLINE_MESSAGE))
    45aa:	2d07      	cmp	r5, #7
    45ac:	f000 8228 	beq.w	4a00 <_DHCPS_ProcessGetPktandSendResponse+0x708>
    45b0:	2d04      	cmp	r5, #4
    45b2:	f000 8225 	beq.w	4a00 <_DHCPS_ProcessGetPktandSendResponse+0x708>
                        else if(i==DHCP_INFORM_MESSAGE)
    45b6:	2d08      	cmp	r5, #8
    45b8:	f000 823f 	beq.w	4a3a <_DHCPS_ProcessGetPktandSendResponse+0x742>
    45bc:	2504      	movs	r5, #4
    45be:	e7d7      	b.n	4570 <_DHCPS_ProcessGetPktandSendResponse+0x278>
    45c0:	00000000 	.word	0x00000000
    45c4:	3fe00000 	.word	0x3fe00000
    45c8:	00000000 	.word	0x00000000
    45cc:	3fec0000 	.word	0x3fec0000
    45d0:	2000eec8 	.word	0x2000eec8
    45d4:	2000ed3c 	.word	0x2000ed3c
    45d8:	2000ef8c 	.word	0x2000ef8c
    45dc:	2000eecc 	.word	0x2000eecc
    45e0:	2000eac0 	.word	0x2000eac0
    45e4:	2000ed7c 	.word	0x2000ed7c
    45e8:	63538263 	.word	0x63538263
    45ec:	0000d18c 	.word	0x0000d18c
        switch(Option)
    45f0:	f89d 304c 	ldrb.w	r3, [sp, #76]	; 0x4c
    45f4:	2b32      	cmp	r3, #50	; 0x32
    45f6:	d016      	beq.n	4626 <_DHCPS_ProcessGetPktandSendResponse+0x32e>
        if(!TCPIP_DHCPS_GetArrayOfDataFromUDPBuff(inputBuf,NULL, Len))
    45f8:	f89d 2070 	ldrb.w	r2, [sp, #112]	; 0x70
    45fc:	2100      	movs	r1, #0
    45fe:	a832      	add	r0, sp, #200	; 0xc8
    4600:	f01c fee4 	bl	213cc <TCPIP_DHCPS_GetArrayOfDataFromUDPBuff>
    4604:	b1c8      	cbz	r0, 463a <_DHCPS_ProcessGetPktandSendResponse+0x342>
    while(inputBuf->endPtr-inputBuf->wrPtr)
    4606:	9a34      	ldr	r2, [sp, #208]	; 0xd0
    4608:	9b33      	ldr	r3, [sp, #204]	; 0xcc
    460a:	429a      	cmp	r2, r3
    460c:	d015      	beq.n	463a <_DHCPS_ProcessGetPktandSendResponse+0x342>
        if(_DHCPS_GetOptionLen(inputBuf,&Option,&Len) != true)
    460e:	aa1c      	add	r2, sp, #112	; 0x70
    4610:	a913      	add	r1, sp, #76	; 0x4c
    4612:	a832      	add	r0, sp, #200	; 0xc8
    4614:	f01d fdd6 	bl	221c4 <_DHCPS_GetOptionLen>
    4618:	2800      	cmp	r0, #0
    461a:	d1e9      	bne.n	45f0 <_DHCPS_ProcessGetPktandSendResponse+0x2f8>
            if(Option != 0xFF)
    461c:	f89d 304c 	ldrb.w	r3, [sp, #76]	; 0x4c
    4620:	2bff      	cmp	r3, #255	; 0xff
    4622:	d0e9      	beq.n	45f8 <_DHCPS_ProcessGetPktandSendResponse+0x300>
    4624:	e68d      	b.n	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
                if(!TCPIP_DHCPS_GetArrayOfDataFromUDPBuff(inputBuf,(uint8_t*)reqAddr,4))
    4626:	2204      	movs	r2, #4
    4628:	a931      	add	r1, sp, #196	; 0xc4
    462a:	a832      	add	r0, sp, #200	; 0xc8
    462c:	f01c fece 	bl	213cc <TCPIP_DHCPS_GetArrayOfDataFromUDPBuff>
    4630:	e7e2      	b.n	45f8 <_DHCPS_ProcessGetPktandSendResponse+0x300>
    while(inputBuf->endPtr-inputBuf->wrPtr)
    4632:	9a34      	ldr	r2, [sp, #208]	; 0xd0
    4634:	9b33      	ldr	r3, [sp, #204]	; 0xcc
    4636:	429a      	cmp	r2, r3
    4638:	d1e9      	bne.n	460e <_DHCPS_ProcessGetPktandSendResponse+0x316>
                                if(DHCPSLocateRequestedIpAddress((IPV4_ADDR *)&ClientIP) != DHCPS_RES_OK)
    463a:	a831      	add	r0, sp, #196	; 0xc4
    463c:	f019 fc92 	bl	1df64 <DHCPSLocateRequestedIpAddress>
    4640:	b908      	cbnz	r0, 4646 <_DHCPS_ProcessGetPktandSendResponse+0x34e>
                                    dhcps_mod.dhcpNextLease.Val = ClientIP.Val;
    4642:	9a31      	ldr	r2, [sp, #196]	; 0xc4
    4644:	e000      	b.n	4648 <_DHCPS_ProcessGetPktandSendResponse+0x350>
                                    dhcps_mod.dhcpNextLease.Val = 0;
    4646:	2200      	movs	r2, #0
    4648:	4b65      	ldr	r3, [pc, #404]	; (47e0 <_DHCPS_ProcessGetPktandSendResponse+0x4e8>)
    464a:	609a      	str	r2, [r3, #8]
                                if(_DHCPS_FindValidAddressFromPool(&gBOOTPHeader,pDhcpsDcpt,pdhcpsHashDcpt,(IPV4_ADDR*)NULL) != DHCPS_RES_OK)
    464c:	2300      	movs	r3, #0
    464e:	4a65      	ldr	r2, [pc, #404]	; (47e4 <_DHCPS_ProcessGetPktandSendResponse+0x4ec>)
    4650:	4659      	mov	r1, fp
    4652:	4865      	ldr	r0, [pc, #404]	; (47e8 <_DHCPS_ProcessGetPktandSendResponse+0x4f0>)
    4654:	f012 fb3e 	bl	16cd4 <_DHCPS_FindValidAddressFromPool>
    4658:	2800      	cmp	r0, #0
    465a:	f47f ae72 	bne.w	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
                                if(dhcps_mod.dhcpNextLease.Val != 0)
    465e:	4b60      	ldr	r3, [pc, #384]	; (47e0 <_DHCPS_ProcessGetPktandSendResponse+0x4e8>)
    4660:	689b      	ldr	r3, [r3, #8]
    4662:	2b00      	cmp	r3, #0
    4664:	f43f ae6d 	beq.w	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
                                    dhcpsSmSate = TCPIP_DHCPS_START_ICMP_PROCESS;
    4668:	2507      	movs	r5, #7
    466a:	e781      	b.n	4570 <_DHCPS_ProcessGetPktandSendResponse+0x278>
    uint32_t magicCookie = 0x63538263;
    466c:	4b5f      	ldr	r3, [pc, #380]	; (47ec <_DHCPS_ProcessGetPktandSendResponse+0x4f4>)
    466e:	930b      	str	r3, [sp, #44]	; 0x2c
    s =dhcps_mod.uSkt;
    4670:	4b5b      	ldr	r3, [pc, #364]	; (47e0 <_DHCPS_ProcessGetPktandSendResponse+0x4e8>)
    4672:	f9b3 6000 	ldrsh.w	r6, [r3]
    if(TCPIP_UDP_TxPutIsReady(s, DHCPS_MAX_REPONSE_PACKET_SIZE) < DHCPS_MAX_REPONSE_PACKET_SIZE)
    4676:	f44f 7196 	mov.w	r1, #300	; 0x12c
    467a:	4630      	mov	r0, r6
    467c:	f01f feac 	bl	243d8 <TCPIP_UDP_TxPutIsReady>
    4680:	f5b0 7f96 	cmp.w	r0, #300	; 0x12c
    4684:	d206      	bcs.n	4694 <_DHCPS_ProcessGetPktandSendResponse+0x39c>
                            memset(&gBOOTPHeader,0,sizeof(gBOOTPHeader));
    4686:	2222      	movs	r2, #34	; 0x22
    4688:	2100      	movs	r1, #0
    468a:	4857      	ldr	r0, [pc, #348]	; (47e8 <_DHCPS_ProcessGetPktandSendResponse+0x4f0>)
    468c:	f01f fc08 	bl	23ea0 <memset>
                            dhcpsSmSate = TCPIP_DHCPS_START_RECV_NEW_PACKET;
    4690:	2501      	movs	r5, #1
                            break;
    4692:	e76d      	b.n	4570 <_DHCPS_ProcessGetPktandSendResponse+0x278>
    TCPIP_UDP_TxOffsetSet(s,0,false);
    4694:	2200      	movs	r2, #0
    4696:	4611      	mov	r1, r2
    4698:	4630      	mov	r0, r6
    469a:	f01b fbe0 	bl	1fe5e <TCPIP_UDP_TxOffsetSet>
    469e:	f8dd 8010 	ldr.w	r8, [sp, #16]
                hE = TCPIP_OAHASH_EntryLookup(pdhcpsHashDcpt->hashDcpt, &boot_header->ClientMAC);
    46a2:	4f51      	ldr	r7, [pc, #324]	; (47e8 <_DHCPS_ProcessGetPktandSendResponse+0x4f0>)
    46a4:	f107 031c 	add.w	r3, r7, #28
    46a8:	9307      	str	r3, [sp, #28]
    46aa:	4d4e      	ldr	r5, [pc, #312]	; (47e4 <_DHCPS_ProcessGetPktandSendResponse+0x4ec>)
    46ac:	e013      	b.n	46d6 <_DHCPS_ProcessGetPktandSendResponse+0x3de>
                        TCPIP_OAHASH_EntryRemove(pdhcpsHashDcpt->hashDcpt,hE);
    46ae:	9902      	ldr	r1, [sp, #8]
    46b0:	6828      	ldr	r0, [r5, #0]
    46b2:	f01e ffff 	bl	236b4 <TCPIP_OAHASH_EntryRemove>
                        bAccept = false;
    46b6:	f04f 0800 	mov.w	r8, #0
    46ba:	e00c      	b.n	46d6 <_DHCPS_ProcessGetPktandSendResponse+0x3de>
            if((Option == DHCP_PARAM_REQUEST_IP_ADDRESS) && (Len == 4u))
    46bc:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
    46c0:	2b32      	cmp	r3, #50	; 0x32
    46c2:	d050      	beq.n	4766 <_DHCPS_ProcessGetPktandSendResponse+0x46e>
        if(!TCPIP_DHCPS_GetArrayOfDataFromUDPBuff(getBuf,NULL, Len))
    46c4:	f89d 203c 	ldrb.w	r2, [sp, #60]	; 0x3c
    46c8:	2100      	movs	r1, #0
    46ca:	a832      	add	r0, sp, #200	; 0xc8
    46cc:	f01c fe7e 	bl	213cc <TCPIP_DHCPS_GetArrayOfDataFromUDPBuff>
    46d0:	2800      	cmp	r0, #0
    46d2:	f000 808f 	beq.w	47f4 <_DHCPS_ProcessGetPktandSendResponse+0x4fc>
    while(getBuf->endPtr-getBuf->wrPtr)
    46d6:	9a34      	ldr	r2, [sp, #208]	; 0xd0
    46d8:	9b33      	ldr	r3, [sp, #204]	; 0xcc
    46da:	429a      	cmp	r2, r3
    46dc:	f000 808a 	beq.w	47f4 <_DHCPS_ProcessGetPktandSendResponse+0x4fc>
        if(!TCPIP_DHCPS_GetDataFromUDPBuff(getBuf,(uint8_t*)&Option))
    46e0:	a90c      	add	r1, sp, #48	; 0x30
    46e2:	a832      	add	r0, sp, #200	; 0xc8
    46e4:	f01e fef0 	bl	234c8 <TCPIP_DHCPS_GetDataFromUDPBuff>
    46e8:	2800      	cmp	r0, #0
    46ea:	d0cc      	beq.n	4686 <_DHCPS_ProcessGetPktandSendResponse+0x38e>
        if(Option == DHCP_END_OPTION)
    46ec:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
    46f0:	2bff      	cmp	r3, #255	; 0xff
    46f2:	d07f      	beq.n	47f4 <_DHCPS_ProcessGetPktandSendResponse+0x4fc>
        if(!TCPIP_DHCPS_GetDataFromUDPBuff(getBuf,(uint8_t*)&Len))
    46f4:	a90f      	add	r1, sp, #60	; 0x3c
    46f6:	a832      	add	r0, sp, #200	; 0xc8
    46f8:	f01e fee6 	bl	234c8 <TCPIP_DHCPS_GetDataFromUDPBuff>
    46fc:	9002      	str	r0, [sp, #8]
    46fe:	2800      	cmp	r0, #0
    4700:	d0c1      	beq.n	4686 <_DHCPS_ProcessGetPktandSendResponse+0x38e>
        if(bRenew)
    4702:	9b01      	ldr	r3, [sp, #4]
    4704:	2b00      	cmp	r3, #0
    4706:	d0d9      	beq.n	46bc <_DHCPS_ProcessGetPktandSendResponse+0x3c4>
            if((Option == DHCP_PARAM_REQUEST_CLIENT_ID) && (Len == 7u))
    4708:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
    470c:	2b3d      	cmp	r3, #61	; 0x3d
    470e:	d1d9      	bne.n	46c4 <_DHCPS_ProcessGetPktandSendResponse+0x3cc>
    4710:	f89d 303c 	ldrb.w	r3, [sp, #60]	; 0x3c
    4714:	2b07      	cmp	r3, #7
    4716:	d1d5      	bne.n	46c4 <_DHCPS_ProcessGetPktandSendResponse+0x3cc>
                if(!TCPIP_DHCPS_GetDataFromUDPBuff(getBuf,(uint8_t*)&i))
    4718:	a90a      	add	r1, sp, #40	; 0x28
    471a:	a832      	add	r0, sp, #200	; 0xc8
    471c:	f01e fed4 	bl	234c8 <TCPIP_DHCPS_GetDataFromUDPBuff>
    4720:	2800      	cmp	r0, #0
    4722:	d0b0      	beq.n	4686 <_DHCPS_ProcessGetPktandSendResponse+0x38e>
                if(!TCPIP_DHCPS_GetArrayOfDataFromUDPBuff(getBuf,(uint8_t*)&tmp_MacAddr, 6))
    4724:	2206      	movs	r2, #6
    4726:	a91c      	add	r1, sp, #112	; 0x70
    4728:	a832      	add	r0, sp, #200	; 0xc8
    472a:	f01c fe4f 	bl	213cc <TCPIP_DHCPS_GetArrayOfDataFromUDPBuff>
    472e:	2800      	cmp	r0, #0
    4730:	d0a9      	beq.n	4686 <_DHCPS_ProcessGetPktandSendResponse+0x38e>
                Len -= 7;
    4732:	f89d 303c 	ldrb.w	r3, [sp, #60]	; 0x3c
    4736:	3b07      	subs	r3, #7
    4738:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
                hE = TCPIP_OAHASH_EntryLookup(pdhcpsHashDcpt->hashDcpt, &tmp_MacAddr);
    473c:	a91c      	add	r1, sp, #112	; 0x70
    473e:	6828      	ldr	r0, [r5, #0]
    4740:	f018 f920 	bl	1c984 <TCPIP_OAHASH_EntryLookup>
                if(hE !=0)
    4744:	9002      	str	r0, [sp, #8]
    4746:	2800      	cmp	r0, #0
    4748:	f000 8146 	beq.w	49d8 <_DHCPS_ProcessGetPktandSendResponse+0x6e0>
                    IPV4_ADDR ClientIP = boot_header->ClientIP;
    474c:	68fb      	ldr	r3, [r7, #12]
    474e:	9313      	str	r3, [sp, #76]	; 0x4c
    return memcmp(((DHCPS_HASH_ENTRY*)hEntry)->ipAddress.v, key, sizeof(((DHCPS_HASH_ENTRY*)hEntry)->ipAddress));
    4750:	2204      	movs	r2, #4
    4752:	a913      	add	r1, sp, #76	; 0x4c
    4754:	300c      	adds	r0, #12
    4756:	f01e fdbb 	bl	232d0 <memcmp>
                    if(TCPIP_DHCPS_HashIPKeyCompare(pdhcpsHashDcpt->hashDcpt, hE, ClientIP.v) == 0)
    475a:	2800      	cmp	r0, #0
    475c:	d1a7      	bne.n	46ae <_DHCPS_ProcessGetPktandSendResponse+0x3b6>
                        _DHCPSUpdateEntry(dhcpsHE);
    475e:	9802      	ldr	r0, [sp, #8]
    4760:	f01e fd1c 	bl	2319c <_DHCPSUpdateEntry>
    4764:	e7b7      	b.n	46d6 <_DHCPS_ProcessGetPktandSendResponse+0x3de>
            if((Option == DHCP_PARAM_REQUEST_IP_ADDRESS) && (Len == 4u))
    4766:	f89d 303c 	ldrb.w	r3, [sp, #60]	; 0x3c
    476a:	2b04      	cmp	r3, #4
    476c:	d1aa      	bne.n	46c4 <_DHCPS_ProcessGetPktandSendResponse+0x3cc>
                if(!TCPIP_DHCPS_GetArrayOfDataFromUDPBuff(getBuf,(uint8_t*)&dw, 4))
    476e:	2204      	movs	r2, #4
    4770:	a91c      	add	r1, sp, #112	; 0x70
    4772:	a832      	add	r0, sp, #200	; 0xc8
    4774:	f01c fe2a 	bl	213cc <TCPIP_DHCPS_GetArrayOfDataFromUDPBuff>
    4778:	2800      	cmp	r0, #0
    477a:	d084      	beq.n	4686 <_DHCPS_ProcessGetPktandSendResponse+0x38e>
                Len -= 4;
    477c:	f89d 303c 	ldrb.w	r3, [sp, #60]	; 0x3c
    4780:	3b04      	subs	r3, #4
    4782:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
                hE = TCPIP_OAHASH_EntryLookup(pdhcpsHashDcpt->hashDcpt, &boot_header->ClientMAC);
    4786:	9907      	ldr	r1, [sp, #28]
    4788:	6828      	ldr	r0, [r5, #0]
    478a:	f018 f8fb 	bl	1c984 <TCPIP_OAHASH_EntryLookup>
                if(hE != 0)
    478e:	9006      	str	r0, [sp, #24]
    4790:	b190      	cbz	r0, 47b8 <_DHCPS_ProcessGetPktandSendResponse+0x4c0>
    return memcmp(((DHCPS_HASH_ENTRY*)hEntry)->ipAddress.v, key, sizeof(((DHCPS_HASH_ENTRY*)hEntry)->ipAddress));
    4792:	2204      	movs	r2, #4
    4794:	a91c      	add	r1, sp, #112	; 0x70
    4796:	300c      	adds	r0, #12
    4798:	f01e fd9a 	bl	232d0 <memcmp>
                    if(TCPIP_DHCPS_HashIPKeyCompare(pdhcpsHashDcpt->hashDcpt, hE, (uint8_t*)&dw) == 0)
    479c:	b928      	cbnz	r0, 47aa <_DHCPS_ProcessGetPktandSendResponse+0x4b2>
                        _DHCPSUpdateEntry(dhcpsHE);
    479e:	9806      	ldr	r0, [sp, #24]
    47a0:	f01e fcfc 	bl	2319c <_DHCPSUpdateEntry>
                        bAccept = true;
    47a4:	f8dd 8008 	ldr.w	r8, [sp, #8]
    47a8:	e795      	b.n	46d6 <_DHCPS_ProcessGetPktandSendResponse+0x3de>
                        TCPIP_OAHASH_EntryRemove(pdhcpsHashDcpt->hashDcpt,hE);
    47aa:	9906      	ldr	r1, [sp, #24]
    47ac:	6828      	ldr	r0, [r5, #0]
    47ae:	f01e ff81 	bl	236b4 <TCPIP_OAHASH_EntryRemove>
                        bAccept = false;
    47b2:	f8dd 8004 	ldr.w	r8, [sp, #4]
    47b6:	e78e      	b.n	46d6 <_DHCPS_ProcessGetPktandSendResponse+0x3de>
                    if((pNetIf->netIPAddr.Val & pNetIf->netMask.Val) != (dw & pNetIf->netMask.Val))
    47b8:	f8d9 3004 	ldr.w	r3, [r9, #4]
    47bc:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    47be:	4053      	eors	r3, r2
    47c0:	f8d9 2008 	ldr.w	r2, [r9, #8]
    47c4:	4213      	tst	r3, r2
    47c6:	d113      	bne.n	47f0 <_DHCPS_ProcessGetPktandSendResponse+0x4f8>
                    if(_DHCPSAddCompleteEntry(pNetIf->netIfIx, (uint8_t*)&dw, &boot_header->ClientMAC, DHCPS_FLAG_ENTRY_COMPLETE)!= DHCPS_RES_OK)
    47c8:	2380      	movs	r3, #128	; 0x80
    47ca:	9a07      	ldr	r2, [sp, #28]
    47cc:	a91c      	add	r1, sp, #112	; 0x70
    47ce:	f8b9 0058 	ldrh.w	r0, [r9, #88]	; 0x58
    47d2:	f018 fd85 	bl	1d2e0 <_DHCPSAddCompleteEntry>
    47d6:	2800      	cmp	r0, #0
    47d8:	f47f af55 	bne.w	4686 <_DHCPS_ProcessGetPktandSendResponse+0x38e>
    47dc:	e77b      	b.n	46d6 <_DHCPS_ProcessGetPktandSendResponse+0x3de>
    47de:	bf00      	nop
    47e0:	2000ed3c 	.word	0x2000ed3c
    47e4:	2000ed7c 	.word	0x2000ed7c
    47e8:	2000eac0 	.word	0x2000eac0
    47ec:	63538263 	.word	0x63538263
                        bAccept = false;
    47f0:	f8dd 8004 	ldr.w	r8, [sp, #4]
    putBuffer.head=putBuffer.wrPtr = TCPIP_UDP_TxPointerGet(s);
    47f4:	4630      	mov	r0, r6
    47f6:	f01e fe5a 	bl	234ae <TCPIP_UDP_TxPointerGet>
    47fa:	900d      	str	r0, [sp, #52]	; 0x34
    47fc:	900c      	str	r0, [sp, #48]	; 0x30
    putBuffer.endPtr = putBuffer.head+DHCPS_MAX_REPONSE_PACKET_SIZE;
    47fe:	f500 7096 	add.w	r0, r0, #300	; 0x12c
    4802:	900e      	str	r0, [sp, #56]	; 0x38
    memset((void*)&rxHeader,0,sizeof(BOOTP_HEADER));
    4804:	2300      	movs	r3, #0
    4806:	9315      	str	r3, [sp, #84]	; 0x54
    4808:	9316      	str	r3, [sp, #88]	; 0x58
    480a:	9317      	str	r3, [sp, #92]	; 0x5c
    480c:	9318      	str	r3, [sp, #96]	; 0x60
    480e:	9319      	str	r3, [sp, #100]	; 0x64
    4810:	931a      	str	r3, [sp, #104]	; 0x68
    4812:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
    rxHeader.MessageType = BOOT_REPLY;
    4816:	2302      	movs	r3, #2
    4818:	f88d 304c 	strb.w	r3, [sp, #76]	; 0x4c
    rxHeader.HardwareType = boot_header->HardwareType;
    481c:	4b91      	ldr	r3, [pc, #580]	; (4a64 <_DHCPS_ProcessGetPktandSendResponse+0x76c>)
    481e:	785a      	ldrb	r2, [r3, #1]
    4820:	f88d 204d 	strb.w	r2, [sp, #77]	; 0x4d
    rxHeader.HardwareLen = boot_header->HardwareLen;
    4824:	789a      	ldrb	r2, [r3, #2]
    4826:	f88d 204e 	strb.w	r2, [sp, #78]	; 0x4e
    rxHeader.Hops = boot_header->Hops;
    482a:	78da      	ldrb	r2, [r3, #3]
    482c:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
    rxHeader.TransactionID = boot_header->TransactionID;
    4830:	685a      	ldr	r2, [r3, #4]
    4832:	9214      	str	r2, [sp, #80]	; 0x50
    rxHeader.BootpFlags = boot_header->BootpFlags;
    4834:	895b      	ldrh	r3, [r3, #10]
    4836:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
    if(bAccept)
    483a:	f1b8 0f00 	cmp.w	r8, #0
    483e:	f040 80ce 	bne.w	49de <_DHCPS_ProcessGetPktandSendResponse+0x6e6>
        ipAddr.Val=0u;
    4842:	2200      	movs	r2, #0
    rxHeader.ClientIP.Val = boot_header->ClientIP.Val; // Not yet Assigned
    4844:	4b87      	ldr	r3, [pc, #540]	; (4a64 <_DHCPS_ProcessGetPktandSendResponse+0x76c>)
    4846:	68d9      	ldr	r1, [r3, #12]
    4848:	9116      	str	r1, [sp, #88]	; 0x58
    rxHeader.YourIP.Val = ipAddr.Val;
    484a:	9217      	str	r2, [sp, #92]	; 0x5c
    rxHeader.NextServerIP.Val = 0;
    484c:	2500      	movs	r5, #0
    484e:	9518      	str	r5, [sp, #96]	; 0x60
    rxHeader.RelayAgentIP.Val = 0;
    4850:	9519      	str	r5, [sp, #100]	; 0x64
    memcpy(&rxHeader.ClientMAC,&boot_header->ClientMAC,sizeof(TCPIP_MAC_ADDR));
    4852:	331c      	adds	r3, #28
    4854:	e893 0003 	ldmia.w	r3, {r0, r1}
    4858:	901a      	str	r0, [sp, #104]	; 0x68
    485a:	f8ad 106c 	strh.w	r1, [sp, #108]	; 0x6c
    TCPIP_DHCPS_CopyDataArrayToProcessBuff((uint8_t*)&rxHeader,&putBuffer,sizeof(BOOTP_HEADER));
    485e:	2222      	movs	r2, #34	; 0x22
    4860:	a90c      	add	r1, sp, #48	; 0x30
    4862:	a813      	add	r0, sp, #76	; 0x4c
    4864:	f01c f8aa 	bl	209bc <TCPIP_DHCPS_CopyDataArrayToProcessBuff>
    for(i = 0; i < DHCPS_UNUSED_BYTES_FOR_TX; i++)	// Remaining 10 bytes of client hardware address, server host name: Null string (not used)
    4868:	f88d 5028 	strb.w	r5, [sp, #40]	; 0x28
        TCPIP_DHCPS_DataCopyToProcessBuffer(0,&putBuffer); // Boot filename: Null string (not used)
    486c:	a90c      	add	r1, sp, #48	; 0x30
    486e:	4628      	mov	r0, r5
    4870:	f01f fa9e 	bl	23db0 <TCPIP_DHCPS_DataCopyToProcessBuffer>
    for(i = 0; i < DHCPS_UNUSED_BYTES_FOR_TX; i++)	// Remaining 10 bytes of client hardware address, server host name: Null string (not used)
    4874:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
    4878:	3301      	adds	r3, #1
    487a:	b2db      	uxtb	r3, r3
    487c:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
    4880:	2bc9      	cmp	r3, #201	; 0xc9
    4882:	d9f3      	bls.n	486c <_DHCPS_ProcessGetPktandSendResponse+0x574>
    TCPIP_DHCPS_CopyDataArrayToProcessBuff((uint8_t*)&magicCookie, &putBuffer, sizeof(magicCookie));
    4884:	2204      	movs	r2, #4
    4886:	a90c      	add	r1, sp, #48	; 0x30
    4888:	a80b      	add	r0, sp, #44	; 0x2c
    488a:	f01c f897 	bl	209bc <TCPIP_DHCPS_CopyDataArrayToProcessBuff>
    optionType.messageType.optionType = DHCP_OPTION_ACK_MESSAGE;
    488e:	2335      	movs	r3, #53	; 0x35
    4890:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
    optionType.messageType.optionTypeLen = 1;
    4894:	2301      	movs	r3, #1
    4896:	f88d 3071 	strb.w	r3, [sp, #113]	; 0x71
        optionType.messageType.byteVal = DHCP_NAK_MESSAGE;
    489a:	f1b8 0f00 	cmp.w	r8, #0
    489e:	bf14      	ite	ne
    48a0:	2305      	movne	r3, #5
    48a2:	2306      	moveq	r3, #6
    48a4:	f88d 3072 	strb.w	r3, [sp, #114]	; 0x72
    optionType.renewalTime_t1.optionType = DHCP_PARAM_RENEWAL_TIME_OPTION;
    48a8:	233a      	movs	r3, #58	; 0x3a
    48aa:	f88d 3091 	strb.w	r3, [sp, #145]	; 0x91
    optionType.renewalTime_t1.optionTypeLen = 4;
    48ae:	2704      	movs	r7, #4
    48b0:	f88d 7092 	strb.w	r7, [sp, #146]	; 0x92
    optionType.renewalTime_t1.intVal = 0.5 * pdhcpsHashDcpt->leaseDuartion;
    48b4:	4b6c      	ldr	r3, [pc, #432]	; (4a68 <_DHCPS_ProcessGetPktandSendResponse+0x770>)
    48b6:	685d      	ldr	r5, [r3, #4]
    48b8:	4628      	mov	r0, r5
    48ba:	f007 f8e9 	bl	ba90 <__aeabi_ui2d>
    48be:	e9cd 0102 	strd	r0, r1, [sp, #8]
    48c2:	ec53 2b19 	vmov	r2, r3, d9
    48c6:	f005 fc01 	bl	a0cc <__aeabi_dmul>
    48ca:	f01b fa0b 	bl	1fce4 <__aeabi_d2uiz>
    48ce:	0e02      	lsrs	r2, r0, #24
    48d0:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    48d4:	0203      	lsls	r3, r0, #8
    48d6:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    48da:	431a      	orrs	r2, r3
    48dc:	0a03      	lsrs	r3, r0, #8
    48de:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    48e2:	4313      	orrs	r3, r2
    optionType.renewalTime_t1.intVal = TCPIP_Helper_htonl(optionType.renewalTime_t1.intVal);
    48e4:	f8cd 3093 	str.w	r3, [sp, #147]	; 0x93
    optionType.rebindTime_t2.optionType = DHCP_PARAM_REBIND_TIME_OPTION;
    48e8:	233b      	movs	r3, #59	; 0x3b
    48ea:	f88d 3097 	strb.w	r3, [sp, #151]	; 0x97
    optionType.rebindTime_t2.optionTypeLen = 4;
    48ee:	f88d 7098 	strb.w	r7, [sp, #152]	; 0x98
    optionType.rebindTime_t2.intVal = 0.875 * pdhcpsHashDcpt->leaseDuartion;
    48f2:	ec53 2b18 	vmov	r2, r3, d8
    48f6:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    48fa:	f005 fbe7 	bl	a0cc <__aeabi_dmul>
    48fe:	f01b f9f1 	bl	1fce4 <__aeabi_d2uiz>
    4902:	0e02      	lsrs	r2, r0, #24
    4904:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    4908:	0203      	lsls	r3, r0, #8
    490a:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    490e:	431a      	orrs	r2, r3
    4910:	0a03      	lsrs	r3, r0, #8
    4912:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    4916:	4313      	orrs	r3, r2
    optionType.rebindTime_t2.intVal = TCPIP_Helper_htonl(optionType.rebindTime_t2.intVal);
    4918:	f8cd 3099 	str.w	r3, [sp, #153]	; 0x99
    optionType.subnetmaskType.optionType = DHCP_SUBNET_MASK;
    491c:	2301      	movs	r3, #1
    491e:	f88d 3073 	strb.w	r3, [sp, #115]	; 0x73
    optionType.subnetmaskType.optionTypeLen = sizeof(IPV4_ADDR);
    4922:	f88d 7074 	strb.w	r7, [sp, #116]	; 0x74
    optionType.subnetmaskType.intVal = pNetIf->netMask.Val;
    4926:	f8d9 3008 	ldr.w	r3, [r9, #8]
    492a:	f8cd 3075 	str.w	r3, [sp, #117]	; 0x75
    optionType.serverIdentifierType.optionType = DHCP_SERVER_IDENTIFIER;
    492e:	2336      	movs	r3, #54	; 0x36
    4930:	f88d 3079 	strb.w	r3, [sp, #121]	; 0x79
    optionType.serverIdentifierType.optionTypeLen = sizeof(IPV4_ADDR);
    4934:	f88d 707a 	strb.w	r7, [sp, #122]	; 0x7a
    optionType.serverIdentifierType.intVal = pNetIf->netIPAddr.Val;
    4938:	f8d9 3004 	ldr.w	r3, [r9, #4]
    493c:	f8cd 307b 	str.w	r3, [sp, #123]	; 0x7b
    optionType.routerType.optionType = DHCP_ROUTER;
    4940:	2203      	movs	r2, #3
    4942:	f88d 207f 	strb.w	r2, [sp, #127]	; 0x7f
    optionType.routerType.optionTypeLen = sizeof(IPV4_ADDR);
    4946:	f88d 7080 	strb.w	r7, [sp, #128]	; 0x80
    optionType.routerType.intVal = pNetIf->netIPAddr.Val;
    494a:	f8cd 3081 	str.w	r3, [sp, #129]	; 0x81
    optionType.dnsType.optionType = DHCP_DNS;
    494e:	2206      	movs	r2, #6
    4950:	f88d 2085 	strb.w	r2, [sp, #133]	; 0x85
    optionType.dnsType.optionTypeLen = sizeof(IPV4_ADDR);
    4954:	f88d 7086 	strb.w	r7, [sp, #134]	; 0x86
    optionType.dnsType.intVal = pNetIf->netIPAddr.Val;
    4958:	f8cd 3087 	str.w	r3, [sp, #135]	; 0x87
    optionType.ipLeaseTimeType.optionType = DHCP_IP_LEASE_TIME;
    495c:	2333      	movs	r3, #51	; 0x33
    495e:	f88d 308b 	strb.w	r3, [sp, #139]	; 0x8b
    optionType.ipLeaseTimeType.optionTypeLen = 4;
    4962:	f88d 708c 	strb.w	r7, [sp, #140]	; 0x8c
    4966:	0e2b      	lsrs	r3, r5, #24
    4968:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
    496c:	022a      	lsls	r2, r5, #8
    496e:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
    4972:	431a      	orrs	r2, r3
    4974:	0a2b      	lsrs	r3, r5, #8
    4976:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    497a:	4313      	orrs	r3, r2
    optionType.ipLeaseTimeType.intVal = TCPIP_Helper_htonl(optionType.ipLeaseTimeType.intVal);
    497c:	f8cd 308d 	str.w	r3, [sp, #141]	; 0x8d
    TCPIP_DHCPS_CopyDataArrayToProcessBuff((uint8_t*)&optionType,&putBuffer,optionTypeTotalLen);
    4980:	222d      	movs	r2, #45	; 0x2d
    4982:	a90c      	add	r1, sp, #48	; 0x30
    4984:	a81c      	add	r0, sp, #112	; 0x70
    4986:	f01c f819 	bl	209bc <TCPIP_DHCPS_CopyDataArrayToProcessBuff>
    TCPIP_DHCPS_DataCopyToProcessBuffer(DHCP_END_OPTION,&putBuffer);
    498a:	a90c      	add	r1, sp, #48	; 0x30
    498c:	20ff      	movs	r0, #255	; 0xff
    498e:	f01f fa0f 	bl	23db0 <TCPIP_DHCPS_DataCopyToProcessBuffer>
     while(putBuffer.wrPtr < putBuffer.endPtr)
    4992:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    4994:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    4996:	429a      	cmp	r2, r3
    4998:	d208      	bcs.n	49ac <_DHCPS_ProcessGetPktandSendResponse+0x6b4>
        TCPIP_DHCPS_DataCopyToProcessBuffer(0,&putBuffer);
    499a:	2500      	movs	r5, #0
    499c:	a90c      	add	r1, sp, #48	; 0x30
    499e:	4628      	mov	r0, r5
    49a0:	f01f fa06 	bl	23db0 <TCPIP_DHCPS_DataCopyToProcessBuffer>
     while(putBuffer.wrPtr < putBuffer.endPtr)
    49a4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    49a6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    49a8:	429a      	cmp	r2, r3
    49aa:	d3f7      	bcc.n	499c <_DHCPS_ProcessGetPktandSendResponse+0x6a4>
    if(false == bRenew)
    49ac:	9b01      	ldr	r3, [sp, #4]
    49ae:	b30b      	cbz	r3, 49f4 <_DHCPS_ProcessGetPktandSendResponse+0x6fc>
    IP_MULTI_ADDRESS tmp_MultiAddr; tmp_MultiAddr.v4Add = pNetIf->netIPAddr;
    49b0:	f8d9 3004 	ldr.w	r3, [r9, #4]
    49b4:	930f      	str	r3, [sp, #60]	; 0x3c
    TCPIP_UDP_SourceIPAddressSet(s,IP_ADDRESS_TYPE_IPV4,&tmp_MultiAddr);
    49b6:	aa0f      	add	r2, sp, #60	; 0x3c
    49b8:	2101      	movs	r1, #1
    49ba:	4630      	mov	r0, r6
    49bc:	f01a fed1 	bl	1f762 <TCPIP_UDP_SourceIPAddressSet>
    TCPIP_UDP_TxOffsetSet(s,(uint16_t)(putBuffer.wrPtr - putBuffer.head), false);
    49c0:	990d      	ldr	r1, [sp, #52]	; 0x34
    49c2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    49c4:	1ac9      	subs	r1, r1, r3
    49c6:	2200      	movs	r2, #0
    49c8:	b289      	uxth	r1, r1
    49ca:	4630      	mov	r0, r6
    49cc:	f01b fa47 	bl	1fe5e <TCPIP_UDP_TxOffsetSet>
    TCPIP_UDP_Flush(s);
    49d0:	4630      	mov	r0, r6
    49d2:	f00a feb1 	bl	f738 <TCPIP_UDP_Flush>
    49d6:	e656      	b.n	4686 <_DHCPS_ProcessGetPktandSendResponse+0x38e>
                    bAccept = false;
    49d8:	f04f 0800 	mov.w	r8, #0
    49dc:	e67b      	b.n	46d6 <_DHCPS_ProcessGetPktandSendResponse+0x3de>
        hE = TCPIP_OAHASH_EntryLookup(pdhcpsHashDcpt->hashDcpt, &boot_header->ClientMAC);
    49de:	4923      	ldr	r1, [pc, #140]	; (4a6c <_DHCPS_ProcessGetPktandSendResponse+0x774>)
    49e0:	4b21      	ldr	r3, [pc, #132]	; (4a68 <_DHCPS_ProcessGetPktandSendResponse+0x770>)
    49e2:	6818      	ldr	r0, [r3, #0]
    49e4:	f017 ffce 	bl	1c984 <TCPIP_OAHASH_EntryLookup>
        if(hE != 0)
    49e8:	b108      	cbz	r0, 49ee <_DHCPS_ProcessGetPktandSendResponse+0x6f6>
            ipAddr = ((DHCPS_HASH_ENTRY*)hE)->ipAddress;
    49ea:	68c2      	ldr	r2, [r0, #12]
    49ec:	e72a      	b.n	4844 <_DHCPS_ProcessGetPktandSendResponse+0x54c>
            ipAddr.Val = 0;
    49ee:	2200      	movs	r2, #0
            bAccept =  false;
    49f0:	4690      	mov	r8, r2
    49f2:	e727      	b.n	4844 <_DHCPS_ProcessGetPktandSendResponse+0x54c>
        TCPIP_UDP_BcastIPV4AddressSet( s,UDP_BCAST_NETWORK_LIMITED,pNetIf);
    49f4:	464a      	mov	r2, r9
    49f6:	2101      	movs	r1, #1
    49f8:	4630      	mov	r0, r6
    49fa:	f018 ff58 	bl	1d8ae <TCPIP_UDP_BcastIPV4AddressSet>
    49fe:	e7d7      	b.n	49b0 <_DHCPS_ProcessGetPktandSendResponse+0x6b8>
                            ClientIP = gBOOTPHeader.ClientIP;
    4a00:	4918      	ldr	r1, [pc, #96]	; (4a64 <_DHCPS_ProcessGetPktandSendResponse+0x76c>)
    4a02:	68cb      	ldr	r3, [r1, #12]
    4a04:	9331      	str	r3, [sp, #196]	; 0xc4
    	hE = TCPIP_OAHASH_EntryLookup(pDhcpsHashDcpt->hashDcpt,hwAdd);
    4a06:	311c      	adds	r1, #28
    4a08:	4b17      	ldr	r3, [pc, #92]	; (4a68 <_DHCPS_ProcessGetPktandSendResponse+0x770>)
    4a0a:	6818      	ldr	r0, [r3, #0]
    4a0c:	f017 ffba 	bl	1c984 <TCPIP_OAHASH_EntryLookup>
        if(hE != 0)
    4a10:	4605      	mov	r5, r0
    4a12:	b158      	cbz	r0, 4a2c <_DHCPS_ProcessGetPktandSendResponse+0x734>
            if(TCPIP_DHCPS_HashIPKeyCompare(pDhcpsHashDcpt->hashDcpt, hE, pIPAddr)== 0)
    4a14:	4b14      	ldr	r3, [pc, #80]	; (4a68 <_DHCPS_ProcessGetPktandSendResponse+0x770>)
    4a16:	681e      	ldr	r6, [r3, #0]
    return memcmp(((DHCPS_HASH_ENTRY*)hEntry)->ipAddress.v, key, sizeof(((DHCPS_HASH_ENTRY*)hEntry)->ipAddress));
    4a18:	2204      	movs	r2, #4
    4a1a:	a931      	add	r1, sp, #196	; 0xc4
    4a1c:	300c      	adds	r0, #12
    4a1e:	f01e fc57 	bl	232d0 <memcmp>
            if(TCPIP_DHCPS_HashIPKeyCompare(pDhcpsHashDcpt->hashDcpt, hE, pIPAddr)== 0)
    4a22:	b918      	cbnz	r0, 4a2c <_DHCPS_ProcessGetPktandSendResponse+0x734>
                TCPIP_OAHASH_EntryRemove(pDhcpsHashDcpt->hashDcpt, hE);
    4a24:	4629      	mov	r1, r5
    4a26:	4630      	mov	r0, r6
    4a28:	f01e fe44 	bl	236b4 <TCPIP_OAHASH_EntryRemove>
                            memset(&gBOOTPHeader,0,sizeof(gBOOTPHeader));
    4a2c:	2222      	movs	r2, #34	; 0x22
    4a2e:	2100      	movs	r1, #0
    4a30:	480c      	ldr	r0, [pc, #48]	; (4a64 <_DHCPS_ProcessGetPktandSendResponse+0x76c>)
    4a32:	f01f fa35 	bl	23ea0 <memset>
                            dhcpsSmSate = TCPIP_DHCPS_START_RECV_NEW_PACKET;
    4a36:	2501      	movs	r5, #1
                            break;
    4a38:	e59a      	b.n	4570 <_DHCPS_ProcessGetPktandSendResponse+0x278>
    uint32_t magicCookie = 0x63538263;
    4a3a:	4b0d      	ldr	r3, [pc, #52]	; (4a70 <_DHCPS_ProcessGetPktandSendResponse+0x778>)
    4a3c:	930a      	str	r3, [sp, #40]	; 0x28
    s = dhcps_mod.uSkt;
    4a3e:	4b0d      	ldr	r3, [pc, #52]	; (4a74 <_DHCPS_ProcessGetPktandSendResponse+0x77c>)
    4a40:	f9b3 5000 	ldrsh.w	r5, [r3]
    if(TCPIP_UDP_TxPutIsReady(s, DHCPS_MAX_REPONSE_PACKET_SIZE) < DHCPS_MAX_REPONSE_PACKET_SIZE)
    4a44:	f44f 7196 	mov.w	r1, #300	; 0x12c
    4a48:	4628      	mov	r0, r5
    4a4a:	f01f fcc5 	bl	243d8 <TCPIP_UDP_TxPutIsReady>
    4a4e:	f5b0 7f96 	cmp.w	r0, #300	; 0x12c
    4a52:	d211      	bcs.n	4a78 <_DHCPS_ProcessGetPktandSendResponse+0x780>
                            memset(&gBOOTPHeader,0,sizeof(gBOOTPHeader));
    4a54:	2222      	movs	r2, #34	; 0x22
    4a56:	2100      	movs	r1, #0
    4a58:	4802      	ldr	r0, [pc, #8]	; (4a64 <_DHCPS_ProcessGetPktandSendResponse+0x76c>)
    4a5a:	f01f fa21 	bl	23ea0 <memset>
                            dhcpsSmSate = TCPIP_DHCPS_START_RECV_NEW_PACKET;
    4a5e:	2501      	movs	r5, #1
                            break;
    4a60:	e586      	b.n	4570 <_DHCPS_ProcessGetPktandSendResponse+0x278>
    4a62:	bf00      	nop
    4a64:	2000eac0 	.word	0x2000eac0
    4a68:	2000ed7c 	.word	0x2000ed7c
    4a6c:	2000eadc 	.word	0x2000eadc
    4a70:	63538263 	.word	0x63538263
    4a74:	2000ed3c 	.word	0x2000ed3c
    TCPIP_UDP_TxOffsetSet(s,0,false);
    4a78:	2200      	movs	r2, #0
    4a7a:	4611      	mov	r1, r2
    4a7c:	4628      	mov	r0, r5
    4a7e:	f01b f9ee 	bl	1fe5e <TCPIP_UDP_TxOffsetSet>
    while(getBuf->endPtr-getBuf->wrPtr)
    4a82:	9a34      	ldr	r2, [sp, #208]	; 0xd0
    4a84:	9b33      	ldr	r3, [sp, #204]	; 0xcc
    4a86:	429a      	cmp	r2, r3
    4a88:	f040 80ba 	bne.w	4c00 <_DHCPS_ProcessGetPktandSendResponse+0x908>
     if(!bAccept)
    4a8c:	9b04      	ldr	r3, [sp, #16]
    4a8e:	2b00      	cmp	r3, #0
    4a90:	d0e0      	beq.n	4a54 <_DHCPS_ProcessGetPktandSendResponse+0x75c>
    putBuffer.head=putBuffer.wrPtr = TCPIP_UDP_TxPointerGet(s);
    4a92:	4628      	mov	r0, r5
    4a94:	f01e fd0b 	bl	234ae <TCPIP_UDP_TxPointerGet>
    4a98:	900d      	str	r0, [sp, #52]	; 0x34
    4a9a:	900c      	str	r0, [sp, #48]	; 0x30
    putBuffer.endPtr = putBuffer.head+DHCPS_MAX_REPONSE_PACKET_SIZE;
    4a9c:	f500 7096 	add.w	r0, r0, #300	; 0x12c
    4aa0:	900e      	str	r0, [sp, #56]	; 0x38
    memset((void*)&rxHeader,0,sizeof(BOOTP_HEADER));
    4aa2:	2600      	movs	r6, #0
    4aa4:	9615      	str	r6, [sp, #84]	; 0x54
    4aa6:	9617      	str	r6, [sp, #92]	; 0x5c
    4aa8:	9618      	str	r6, [sp, #96]	; 0x60
    4aaa:	9619      	str	r6, [sp, #100]	; 0x64
    4aac:	961a      	str	r6, [sp, #104]	; 0x68
    4aae:	f8ad 606c 	strh.w	r6, [sp, #108]	; 0x6c
    rxHeader.MessageType = BOOT_REPLY;
    4ab2:	2302      	movs	r3, #2
    4ab4:	f88d 304c 	strb.w	r3, [sp, #76]	; 0x4c
    rxHeader.HardwareType = boot_header->HardwareType;
    4ab8:	4bb4      	ldr	r3, [pc, #720]	; (4d8c <_DHCPS_ProcessGetPktandSendResponse+0xa94>)
    4aba:	785a      	ldrb	r2, [r3, #1]
    4abc:	f88d 204d 	strb.w	r2, [sp, #77]	; 0x4d
    rxHeader.HardwareLen = boot_header->HardwareLen;
    4ac0:	789a      	ldrb	r2, [r3, #2]
    4ac2:	f88d 204e 	strb.w	r2, [sp, #78]	; 0x4e
    rxHeader.Hops = boot_header->Hops;
    4ac6:	78da      	ldrb	r2, [r3, #3]
    4ac8:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
    rxHeader.TransactionID = boot_header->TransactionID;
    4acc:	685a      	ldr	r2, [r3, #4]
    4ace:	9214      	str	r2, [sp, #80]	; 0x50
    rxHeader.BootpFlags = boot_header->BootpFlags;
    4ad0:	895a      	ldrh	r2, [r3, #10]
    4ad2:	f8ad 2056 	strh.w	r2, [sp, #86]	; 0x56
        rxHeader.ClientIP.Val = boot_header->ClientIP.Val; // Not yet Assigned
    4ad6:	68da      	ldr	r2, [r3, #12]
    4ad8:	9216      	str	r2, [sp, #88]	; 0x58
        rxHeader.NextServerIP.Val = pNetIf->netIPAddr.Val;
    4ada:	f8d9 2004 	ldr.w	r2, [r9, #4]
    4ade:	9218      	str	r2, [sp, #96]	; 0x60
    memcpy(&rxHeader.ClientMAC,&boot_header->ClientMAC,sizeof(TCPIP_MAC_ADDR));
    4ae0:	331c      	adds	r3, #28
    4ae2:	e893 0003 	ldmia.w	r3, {r0, r1}
    4ae6:	901a      	str	r0, [sp, #104]	; 0x68
    4ae8:	f8ad 106c 	strh.w	r1, [sp, #108]	; 0x6c
    TCPIP_DHCPS_CopyDataArrayToProcessBuff((uint8_t*)&rxHeader,&putBuffer,sizeof(BOOTP_HEADER));
    4aec:	2222      	movs	r2, #34	; 0x22
    4aee:	a90c      	add	r1, sp, #48	; 0x30
    4af0:	a813      	add	r0, sp, #76	; 0x4c
    4af2:	f01b ff63 	bl	209bc <TCPIP_DHCPS_CopyDataArrayToProcessBuff>
    for(i = 0; i < DHCPS_UNUSED_BYTES_FOR_TX; i++)	// Remaining 10 bytes of client hardware address, server host name: Null string (not used)
    4af6:	f88d 6027 	strb.w	r6, [sp, #39]	; 0x27
        TCPIP_DHCPS_DataCopyToProcessBuffer(0,&putBuffer); // Boot filename: Null string (not used)
    4afa:	a90c      	add	r1, sp, #48	; 0x30
    4afc:	4630      	mov	r0, r6
    4afe:	f01f f957 	bl	23db0 <TCPIP_DHCPS_DataCopyToProcessBuffer>
    for(i = 0; i < DHCPS_UNUSED_BYTES_FOR_TX; i++)	// Remaining 10 bytes of client hardware address, server host name: Null string (not used)
    4b02:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    4b06:	3301      	adds	r3, #1
    4b08:	b2db      	uxtb	r3, r3
    4b0a:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    4b0e:	2bc9      	cmp	r3, #201	; 0xc9
    4b10:	d9f3      	bls.n	4afa <_DHCPS_ProcessGetPktandSendResponse+0x802>
    TCPIP_DHCPS_CopyDataArrayToProcessBuff((uint8_t*)&magicCookie, &putBuffer, sizeof(magicCookie));
    4b12:	2204      	movs	r2, #4
    4b14:	a90c      	add	r1, sp, #48	; 0x30
    4b16:	a80a      	add	r0, sp, #40	; 0x28
    4b18:	f01b ff50 	bl	209bc <TCPIP_DHCPS_CopyDataArrayToProcessBuff>
    optionType.messageType.optionType = DHCP_OPTION_ACK_MESSAGE;
    4b1c:	2335      	movs	r3, #53	; 0x35
    4b1e:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
    optionType.messageType.optionTypeLen = 1;
    4b22:	2301      	movs	r3, #1
    4b24:	f88d 3071 	strb.w	r3, [sp, #113]	; 0x71
        optionType.messageType.byteVal = DHCP_ACK_MESSAGE;
    4b28:	2205      	movs	r2, #5
    4b2a:	f88d 2072 	strb.w	r2, [sp, #114]	; 0x72
    optionType.subnetmaskType.optionType = DHCP_SUBNET_MASK;
    4b2e:	f88d 3073 	strb.w	r3, [sp, #115]	; 0x73
    optionType.subnetmaskType.optionTypeLen = sizeof(IPV4_ADDR);
    4b32:	2304      	movs	r3, #4
    4b34:	f88d 3074 	strb.w	r3, [sp, #116]	; 0x74
    optionType.subnetmaskType.intVal = pNetIf->netMask.Val;
    4b38:	f8d9 2008 	ldr.w	r2, [r9, #8]
    4b3c:	f8cd 2075 	str.w	r2, [sp, #117]	; 0x75
    optionType.serverIdentifierType.optionType = DHCP_SERVER_IDENTIFIER;
    4b40:	2236      	movs	r2, #54	; 0x36
    4b42:	f88d 2079 	strb.w	r2, [sp, #121]	; 0x79
    optionType.serverIdentifierType.optionTypeLen = sizeof(IPV4_ADDR);
    4b46:	f88d 307a 	strb.w	r3, [sp, #122]	; 0x7a
    optionType.serverIdentifierType.intVal = pNetIf->netIPAddr.Val;
    4b4a:	f8d9 2004 	ldr.w	r2, [r9, #4]
    4b4e:	f8cd 207b 	str.w	r2, [sp, #123]	; 0x7b
    optionType.routerType.optionType = DHCP_ROUTER;
    4b52:	2103      	movs	r1, #3
    4b54:	f88d 107f 	strb.w	r1, [sp, #127]	; 0x7f
    optionType.routerType.optionTypeLen = sizeof(IPV4_ADDR);
    4b58:	f88d 3080 	strb.w	r3, [sp, #128]	; 0x80
    optionType.routerType.intVal = pNetIf->netIPAddr.Val;
    4b5c:	f8cd 2081 	str.w	r2, [sp, #129]	; 0x81
    optionType.dnsType.optionType = DHCP_DNS;
    4b60:	2106      	movs	r1, #6
    4b62:	f88d 1085 	strb.w	r1, [sp, #133]	; 0x85
    optionType.dnsType.optionTypeLen = sizeof(IPV4_ADDR);
    4b66:	f88d 3086 	strb.w	r3, [sp, #134]	; 0x86
    optionType.dnsType.intVal = pNetIf->netIPAddr.Val;
    4b6a:	f8cd 2087 	str.w	r2, [sp, #135]	; 0x87
    TCPIP_DHCPS_CopyDataArrayToProcessBuff((uint8_t*)&optionType,&putBuffer,optionTypeTotalLen);
    4b6e:	221b      	movs	r2, #27
    4b70:	a90c      	add	r1, sp, #48	; 0x30
    4b72:	a81c      	add	r0, sp, #112	; 0x70
    4b74:	f01b ff22 	bl	209bc <TCPIP_DHCPS_CopyDataArrayToProcessBuff>
    TCPIP_DHCPS_DataCopyToProcessBuffer(DHCP_END_OPTION,&putBuffer);
    4b78:	a90c      	add	r1, sp, #48	; 0x30
    4b7a:	20ff      	movs	r0, #255	; 0xff
    4b7c:	f01f f918 	bl	23db0 <TCPIP_DHCPS_DataCopyToProcessBuffer>
    while(putBuffer.wrPtr < putBuffer.endPtr)
    4b80:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    4b82:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    4b84:	429a      	cmp	r2, r3
    4b86:	d908      	bls.n	4b9a <_DHCPS_ProcessGetPktandSendResponse+0x8a2>
        TCPIP_DHCPS_DataCopyToProcessBuffer(0,&putBuffer);
    4b88:	2600      	movs	r6, #0
    4b8a:	a90c      	add	r1, sp, #48	; 0x30
    4b8c:	4630      	mov	r0, r6
    4b8e:	f01f f90f 	bl	23db0 <TCPIP_DHCPS_DataCopyToProcessBuffer>
    while(putBuffer.wrPtr < putBuffer.endPtr)
    4b92:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    4b94:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    4b96:	429a      	cmp	r2, r3
    4b98:	d3f7      	bcc.n	4b8a <_DHCPS_ProcessGetPktandSendResponse+0x892>
    IP_MULTI_ADDRESS tmp_MultiAddr; tmp_MultiAddr.v4Add = pNetIf->netIPAddr;
    4b9a:	f8d9 3004 	ldr.w	r3, [r9, #4]
    4b9e:	930f      	str	r3, [sp, #60]	; 0x3c
    TCPIP_UDP_SourceIPAddressSet(s,IP_ADDRESS_TYPE_IPV4,&tmp_MultiAddr);
    4ba0:	aa0f      	add	r2, sp, #60	; 0x3c
    4ba2:	2101      	movs	r1, #1
    4ba4:	4628      	mov	r0, r5
    4ba6:	f01a fddc 	bl	1f762 <TCPIP_UDP_SourceIPAddressSet>
    TCPIP_UDP_TxOffsetSet(s,(uint16_t)(putBuffer.wrPtr - putBuffer.head), false);
    4baa:	990d      	ldr	r1, [sp, #52]	; 0x34
    4bac:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    4bae:	1ac9      	subs	r1, r1, r3
    4bb0:	2200      	movs	r2, #0
    4bb2:	b289      	uxth	r1, r1
    4bb4:	4628      	mov	r0, r5
    4bb6:	f01b f952 	bl	1fe5e <TCPIP_UDP_TxOffsetSet>
    TCPIP_UDP_Flush(s);
    4bba:	4628      	mov	r0, r5
    4bbc:	f00a fdbc 	bl	f738 <TCPIP_UDP_Flush>
    4bc0:	e748      	b.n	4a54 <_DHCPS_ProcessGetPktandSendResponse+0x75c>
                if((pNetIf->netIPAddr.Val & pNetIf->netMask.Val)==
    4bc2:	f8d9 3004 	ldr.w	r3, [r9, #4]
    4bc6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    4bc8:	4053      	eors	r3, r2
    4bca:	f8d9 2008 	ldr.w	r2, [r9, #8]
    4bce:	4213      	tst	r3, r2
    4bd0:	f47f af40 	bne.w	4a54 <_DHCPS_ProcessGetPktandSendResponse+0x75c>
                    if(_DHCPSAddCompleteEntry(pDhcpsDcpt->netIx, ClientIP.v, &boot_header->ClientMAC,DHCPS_FLAG_ENTRY_COMPLETE) != DHCPS_RES_OK)
    4bd4:	2380      	movs	r3, #128	; 0x80
    4bd6:	4a6e      	ldr	r2, [pc, #440]	; (4d90 <_DHCPS_ProcessGetPktandSendResponse+0xa98>)
    4bd8:	a90b      	add	r1, sp, #44	; 0x2c
    4bda:	f8db 0018 	ldr.w	r0, [fp, #24]
    4bde:	f018 fb7f 	bl	1d2e0 <_DHCPSAddCompleteEntry>
    4be2:	e737      	b.n	4a54 <_DHCPS_ProcessGetPktandSendResponse+0x75c>
        if(!TCPIP_DHCPS_GetArrayOfDataFromUDPBuff(getBuf,NULL, Len))
    4be4:	f89d 204c 	ldrb.w	r2, [sp, #76]	; 0x4c
    4be8:	2100      	movs	r1, #0
    4bea:	a832      	add	r0, sp, #200	; 0xc8
    4bec:	f01c fbee 	bl	213cc <TCPIP_DHCPS_GetArrayOfDataFromUDPBuff>
    4bf0:	2800      	cmp	r0, #0
    4bf2:	f43f af4b 	beq.w	4a8c <_DHCPS_ProcessGetPktandSendResponse+0x794>
    while(getBuf->endPtr-getBuf->wrPtr)
    4bf6:	9a34      	ldr	r2, [sp, #208]	; 0xd0
    4bf8:	9b33      	ldr	r3, [sp, #204]	; 0xcc
    4bfa:	429a      	cmp	r2, r3
    4bfc:	f43f af46 	beq.w	4a8c <_DHCPS_ProcessGetPktandSendResponse+0x794>
        if(!TCPIP_DHCPS_GetDataFromUDPBuff(getBuf,(uint8_t *)&Option))
    4c00:	a90f      	add	r1, sp, #60	; 0x3c
    4c02:	a832      	add	r0, sp, #200	; 0xc8
    4c04:	f01e fc60 	bl	234c8 <TCPIP_DHCPS_GetDataFromUDPBuff>
    4c08:	2800      	cmp	r0, #0
    4c0a:	f43f af23 	beq.w	4a54 <_DHCPS_ProcessGetPktandSendResponse+0x75c>
        if(Option == DHCP_END_OPTION)
    4c0e:	f89d 303c 	ldrb.w	r3, [sp, #60]	; 0x3c
    4c12:	2bff      	cmp	r3, #255	; 0xff
    4c14:	f43f af3a 	beq.w	4a8c <_DHCPS_ProcessGetPktandSendResponse+0x794>
        if(!TCPIP_DHCPS_GetDataFromUDPBuff(getBuf,(uint8_t *)&Len))
    4c18:	a913      	add	r1, sp, #76	; 0x4c
    4c1a:	a832      	add	r0, sp, #200	; 0xc8
    4c1c:	f01e fc54 	bl	234c8 <TCPIP_DHCPS_GetDataFromUDPBuff>
    4c20:	2800      	cmp	r0, #0
    4c22:	f43f af17 	beq.w	4a54 <_DHCPS_ProcessGetPktandSendResponse+0x75c>
        if((Option == DHCP_PARAM_REQUEST_CLIENT_ID) && (Len == 7u))
    4c26:	f89d 303c 	ldrb.w	r3, [sp, #60]	; 0x3c
    4c2a:	2b3d      	cmp	r3, #61	; 0x3d
    4c2c:	d1da      	bne.n	4be4 <_DHCPS_ProcessGetPktandSendResponse+0x8ec>
    4c2e:	f89d 304c 	ldrb.w	r3, [sp, #76]	; 0x4c
    4c32:	2b07      	cmp	r3, #7
    4c34:	d1d6      	bne.n	4be4 <_DHCPS_ProcessGetPktandSendResponse+0x8ec>
            if(!TCPIP_DHCPS_GetDataFromUDPBuff(getBuf,(uint8_t *)&i))
    4c36:	f10d 0127 	add.w	r1, sp, #39	; 0x27
    4c3a:	a832      	add	r0, sp, #200	; 0xc8
    4c3c:	f01e fc44 	bl	234c8 <TCPIP_DHCPS_GetDataFromUDPBuff>
    4c40:	2800      	cmp	r0, #0
    4c42:	f43f af07 	beq.w	4a54 <_DHCPS_ProcessGetPktandSendResponse+0x75c>
            if(!TCPIP_DHCPS_GetArrayOfDataFromUDPBuff(getBuf,(uint8_t*)&tmp_MacAddr, 6))
    4c46:	2206      	movs	r2, #6
    4c48:	a91c      	add	r1, sp, #112	; 0x70
    4c4a:	a832      	add	r0, sp, #200	; 0xc8
    4c4c:	f01c fbbe 	bl	213cc <TCPIP_DHCPS_GetArrayOfDataFromUDPBuff>
    4c50:	2800      	cmp	r0, #0
    4c52:	f43f aeff 	beq.w	4a54 <_DHCPS_ProcessGetPktandSendResponse+0x75c>
            Len -= 7;
    4c56:	f89d 304c 	ldrb.w	r3, [sp, #76]	; 0x4c
    4c5a:	3b07      	subs	r3, #7
    4c5c:	f88d 304c 	strb.w	r3, [sp, #76]	; 0x4c
            hE = TCPIP_OAHASH_EntryLookup(pdhcpsHashDcpt->hashDcpt, &tmp_MacAddr);
    4c60:	a91c      	add	r1, sp, #112	; 0x70
    4c62:	4b4c      	ldr	r3, [pc, #304]	; (4d94 <_DHCPS_ProcessGetPktandSendResponse+0xa9c>)
    4c64:	6818      	ldr	r0, [r3, #0]
    4c66:	f017 fe8d 	bl	1c984 <TCPIP_OAHASH_EntryLookup>
            ClientIP = boot_header->ClientIP;
    4c6a:	4b48      	ldr	r3, [pc, #288]	; (4d8c <_DHCPS_ProcessGetPktandSendResponse+0xa94>)
    4c6c:	68db      	ldr	r3, [r3, #12]
    4c6e:	930b      	str	r3, [sp, #44]	; 0x2c
            if(hE !=0)
    4c70:	2800      	cmp	r0, #0
    4c72:	d0a6      	beq.n	4bc2 <_DHCPS_ProcessGetPktandSendResponse+0x8ca>
    return memcmp(((DHCPS_HASH_ENTRY*)hEntry)->ipAddress.v, key, sizeof(((DHCPS_HASH_ENTRY*)hEntry)->ipAddress));
    4c74:	2204      	movs	r2, #4
    4c76:	a90b      	add	r1, sp, #44	; 0x2c
    4c78:	300c      	adds	r0, #12
    4c7a:	f01e fb29 	bl	232d0 <memcmp>
                if(TCPIP_DHCPS_HashIPKeyCompare(pdhcpsHashDcpt->hashDcpt, hE, ClientIP.v) == 0)
    4c7e:	2800      	cmp	r0, #0
    4c80:	f43f af07 	beq.w	4a92 <_DHCPS_ProcessGetPktandSendResponse+0x79a>
    4c84:	e6e6      	b.n	4a54 <_DHCPS_ProcessGetPktandSendResponse+0x75c>
                if(_DHCPS_EchoRequestInit((TCPIP_NET_IF *)gpDhcpsNetH,(IPV4_ADDR *)&dhcps_mod.dhcpNextLease) == DHCPS_RES_ECHO_IN_PROCESS)
    4c86:	4b44      	ldr	r3, [pc, #272]	; (4d98 <_DHCPS_ProcessGetPktandSendResponse+0xaa0>)
    4c88:	681a      	ldr	r2, [r3, #0]
}

static DHCPS_RESULT _DHCPS_EchoRequestInit(TCPIP_NET_IF *pNetIf,IPV4_ADDR *requestedIpAddr)
{
    // Initialize all the echo request parameters
    dhcpsEchoRequestState = TCPIP_DHCPS_START_ECHO_REQUEST;
    4c8a:	4b44      	ldr	r3, [pc, #272]	; (4d9c <_DHCPS_ProcessGetPktandSendResponse+0xaa4>)
    4c8c:	2100      	movs	r1, #0
    4c8e:	7019      	strb	r1, [r3, #0]
    dhcpsicmpNetH = (TCPIP_NET_HANDLE)pNetIf;
    4c90:	4b43      	ldr	r3, [pc, #268]	; (4da0 <_DHCPS_ProcessGetPktandSendResponse+0xaa8>)
    4c92:	601a      	str	r2, [r3, #0]
    dhcpsicmpTargetAddr = *requestedIpAddr;
    4c94:	4a43      	ldr	r2, [pc, #268]	; (4da4 <_DHCPS_ProcessGetPktandSendResponse+0xaac>)
    4c96:	6891      	ldr	r1, [r2, #8]
    4c98:	4b43      	ldr	r3, [pc, #268]	; (4da8 <_DHCPS_ProcessGetPktandSendResponse+0xab0>)
    4c9a:	6019      	str	r1, [r3, #0]
                    dhcps_mod.smServer = DHCP_SERVER_ICMP_PROCESS;
    4c9c:	2301      	movs	r3, #1
    4c9e:	7093      	strb	r3, [r2, #2]
    dhcps_mod.smState = newState;
    4ca0:	70d3      	strb	r3, [r2, #3]
}
    4ca2:	4618      	mov	r0, r3
    4ca4:	f50d 7d45 	add.w	sp, sp, #788	; 0x314
    4ca8:	ecbd 8b04 	vpop	{d8-d9}
    4cac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                ix=0;
    4cb0:	2300      	movs	r3, #0
    4cb2:	93ad      	str	r3, [sp, #692]	; 0x2b4
                if(_DHCPSDescriptorGetFromIntf(gpDhcpsNetH,&ix) == false)
    4cb4:	a9ad      	add	r1, sp, #692	; 0x2b4
    4cb6:	4b38      	ldr	r3, [pc, #224]	; (4d98 <_DHCPS_ProcessGetPktandSendResponse+0xaa0>)
    4cb8:	6818      	ldr	r0, [r3, #0]
    4cba:	f019 fbb7 	bl	1e42c <_DHCPSDescriptorGetFromIntf>
    4cbe:	4603      	mov	r3, r0
    4cc0:	b1a8      	cbz	r0, 4cee <_DHCPS_ProcessGetPktandSendResponse+0x9f6>
                pDhcpsDcpt = gPdhcpSDcpt+ix;
    4cc2:	9bad      	ldr	r3, [sp, #692]	; 0x2b4
    4cc4:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
    4cc8:	4a38      	ldr	r2, [pc, #224]	; (4dac <_DHCPS_ProcessGetPktandSendResponse+0xab4>)
    4cca:	6812      	ldr	r2, [r2, #0]
    4ccc:	eb02 0b83 	add.w	fp, r2, r3, lsl #2
                if(_DHCPS_FindValidAddressFromPool(&gBOOTPHeader,pDhcpsDcpt,pdhcpsHashDcpt,(IPV4_ADDR*)&dhcps_mod.dhcpNextLease) != DHCPS_RES_OK)
    4cd0:	4b37      	ldr	r3, [pc, #220]	; (4db0 <_DHCPS_ProcessGetPktandSendResponse+0xab8>)
    4cd2:	4a30      	ldr	r2, [pc, #192]	; (4d94 <_DHCPS_ProcessGetPktandSendResponse+0xa9c>)
    4cd4:	4659      	mov	r1, fp
    4cd6:	482d      	ldr	r0, [pc, #180]	; (4d8c <_DHCPS_ProcessGetPktandSendResponse+0xa94>)
    4cd8:	f011 fffc 	bl	16cd4 <_DHCPS_FindValidAddressFromPool>
    4cdc:	b958      	cbnz	r0, 4cf6 <_DHCPS_ProcessGetPktandSendResponse+0x9fe>
                if(dhcps_mod.dhcpNextLease.Val != 0)
    4cde:	4b31      	ldr	r3, [pc, #196]	; (4da4 <_DHCPS_ProcessGetPktandSendResponse+0xaac>)
    4ce0:	689b      	ldr	r3, [r3, #8]
    4ce2:	b16b      	cbz	r3, 4d00 <_DHCPS_ProcessGetPktandSendResponse+0xa08>
    dhcps_mod.smState = newState;
    4ce4:	2507      	movs	r5, #7
    4ce6:	4b2f      	ldr	r3, [pc, #188]	; (4da4 <_DHCPS_ProcessGetPktandSendResponse+0xaac>)
    4ce8:	70dd      	strb	r5, [r3, #3]
    4cea:	f7ff bb2a 	b.w	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
    4cee:	4a2d      	ldr	r2, [pc, #180]	; (4da4 <_DHCPS_ProcessGetPktandSendResponse+0xaac>)
    4cf0:	2101      	movs	r1, #1
    4cf2:	70d1      	strb	r1, [r2, #3]
                    return false;
    4cf4:	e7d5      	b.n	4ca2 <_DHCPS_ProcessGetPktandSendResponse+0x9aa>
    dhcps_mod.smState = newState;
    4cf6:	2501      	movs	r5, #1
    4cf8:	4b2a      	ldr	r3, [pc, #168]	; (4da4 <_DHCPS_ProcessGetPktandSendResponse+0xaac>)
    4cfa:	70dd      	strb	r5, [r3, #3]
                    continue;
    4cfc:	f7ff bb21 	b.w	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
    dhcps_mod.smState = newState;
    4d00:	2501      	movs	r5, #1
    4d02:	4b28      	ldr	r3, [pc, #160]	; (4da4 <_DHCPS_ProcessGetPktandSendResponse+0xaac>)
    4d04:	70dd      	strb	r5, [r3, #3]
                    continue;
    4d06:	f7ff bb1c 	b.w	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
                 ix=0;
    4d0a:	2300      	movs	r3, #0
    4d0c:	93ad      	str	r3, [sp, #692]	; 0x2b4
                if(_DHCPSDescriptorGetFromIntf(gpDhcpsNetH,&ix) == false)
    4d0e:	4b22      	ldr	r3, [pc, #136]	; (4d98 <_DHCPS_ProcessGetPktandSendResponse+0xaa0>)
    4d10:	681d      	ldr	r5, [r3, #0]
    4d12:	a9ad      	add	r1, sp, #692	; 0x2b4
    4d14:	4628      	mov	r0, r5
    4d16:	f019 fb89 	bl	1e42c <_DHCPSDescriptorGetFromIntf>
    4d1a:	4603      	mov	r3, r0
    4d1c:	b1c0      	cbz	r0, 4d50 <_DHCPS_ProcessGetPktandSendResponse+0xa58>
                pDhcpsDcpt = gPdhcpSDcpt+ix;
    4d1e:	9bad      	ldr	r3, [sp, #692]	; 0x2b4
    4d20:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
    4d24:	4a21      	ldr	r2, [pc, #132]	; (4dac <_DHCPS_ProcessGetPktandSendResponse+0xab4>)
    4d26:	6812      	ldr	r2, [r2, #0]
    4d28:	eb02 0b83 	add.w	fp, r2, r3, lsl #2
    uint32_t magicCookie = 0x63538263;
    4d2c:	4b21      	ldr	r3, [pc, #132]	; (4db4 <_DHCPS_ProcessGetPktandSendResponse+0xabc>)
    4d2e:	930b      	str	r3, [sp, #44]	; 0x2c
    s =dhcps_mod.uSkt;
    4d30:	4b1c      	ldr	r3, [pc, #112]	; (4da4 <_DHCPS_ProcessGetPktandSendResponse+0xaac>)
    4d32:	f9b3 8000 	ldrsh.w	r8, [r3]
    if(TCPIP_UDP_TxPutIsReady(s, DHCPS_MAX_REPONSE_PACKET_SIZE) < DHCPS_MAX_REPONSE_PACKET_SIZE)
    4d36:	f44f 7196 	mov.w	r1, #300	; 0x12c
    4d3a:	4640      	mov	r0, r8
    4d3c:	f01f fb4c 	bl	243d8 <TCPIP_UDP_TxPutIsReady>
    4d40:	f5b0 7f96 	cmp.w	r0, #300	; 0x12c
    4d44:	d208      	bcs.n	4d58 <_DHCPS_ProcessGetPktandSendResponse+0xa60>
    dhcps_mod.smState = newState;
    4d46:	2501      	movs	r5, #1
    4d48:	4b16      	ldr	r3, [pc, #88]	; (4da4 <_DHCPS_ProcessGetPktandSendResponse+0xaac>)
    4d4a:	70dd      	strb	r5, [r3, #3]
    4d4c:	f7ff baf9 	b.w	4342 <_DHCPS_ProcessGetPktandSendResponse+0x4a>
    4d50:	4a14      	ldr	r2, [pc, #80]	; (4da4 <_DHCPS_ProcessGetPktandSendResponse+0xaac>)
    4d52:	2101      	movs	r1, #1
    4d54:	70d1      	strb	r1, [r2, #3]
                    return false;
    4d56:	e7a4      	b.n	4ca2 <_DHCPS_ProcessGetPktandSendResponse+0x9aa>
    TCPIP_UDP_TxOffsetSet(s,0,false);
    4d58:	2200      	movs	r2, #0
    4d5a:	4611      	mov	r1, r2
    4d5c:	4640      	mov	r0, r8
    4d5e:	f01b f87e 	bl	1fe5e <TCPIP_UDP_TxOffsetSet>
    memset((void*)&rxHeader,0,sizeof(BOOTP_HEADER));
    4d62:	2222      	movs	r2, #34	; 0x22
    4d64:	2100      	movs	r1, #0
    4d66:	a813      	add	r0, sp, #76	; 0x4c
    4d68:	f01f f89a 	bl	23ea0 <memset>
        if(macAddr->v[i] != 0) return true;
    4d6c:	4b07      	ldr	r3, [pc, #28]	; (4d8c <_DHCPS_ProcessGetPktandSendResponse+0xa94>)
    4d6e:	7f1b      	ldrb	r3, [r3, #28]
    4d70:	2b00      	cmp	r3, #0
    4d72:	d14e      	bne.n	4e12 <_DHCPS_ProcessGetPktandSendResponse+0xb1a>
    4d74:	4905      	ldr	r1, [pc, #20]	; (4d8c <_DHCPS_ProcessGetPktandSendResponse+0xa94>)
    4d76:	f101 031d 	add.w	r3, r1, #29
    4d7a:	3122      	adds	r1, #34	; 0x22
    4d7c:	f813 2b01 	ldrb.w	r2, [r3], #1
    4d80:	2a00      	cmp	r2, #0
    4d82:	d146      	bne.n	4e12 <_DHCPS_ProcessGetPktandSendResponse+0xb1a>
    for(i=0;i<6;i++)
    4d84:	4299      	cmp	r1, r3
    4d86:	d1f9      	bne.n	4d7c <_DHCPS_ProcessGetPktandSendResponse+0xa84>
    4d88:	e7dd      	b.n	4d46 <_DHCPS_ProcessGetPktandSendResponse+0xa4e>
    4d8a:	bf00      	nop
    4d8c:	2000eac0 	.word	0x2000eac0
    4d90:	2000eadc 	.word	0x2000eadc
    4d94:	2000ed7c 	.word	0x2000ed7c
    4d98:	2000eecc 	.word	0x2000eecc
    4d9c:	2000ef8d 	.word	0x2000ef8d
    4da0:	2000eeac 	.word	0x2000eeac
    4da4:	2000ed3c 	.word	0x2000ed3c
    4da8:	2000eec4 	.word	0x2000eec4
    4dac:	2000eec8 	.word	0x2000eec8
    4db0:	2000ed44 	.word	0x2000ed44
    4db4:	63538263 	.word	0x63538263
        if(dhcps_mod.dhcpNextLease.Val == 0)
    4db8:	4b70      	ldr	r3, [pc, #448]	; (4f7c <_DHCPS_ProcessGetPktandSendResponse+0xc84>)
    4dba:	689b      	ldr	r3, [r3, #8]
    4dbc:	b14b      	cbz	r3, 4dd2 <_DHCPS_ProcessGetPktandSendResponse+0xada>
            tempIpv4Addr.Val = dhcps_mod.dhcpNextLease.Val;
    4dbe:	931c      	str	r3, [sp, #112]	; 0x70
        if(_DHCPSAddCompleteEntry(pNetIf->netIfIx, tempIpv4Addr.v, &Header->ClientMAC, DHCPS_FLAG_ENTRY_INCOMPLETE) != DHCPS_RES_OK)
    4dc0:	2340      	movs	r3, #64	; 0x40
    4dc2:	4a6f      	ldr	r2, [pc, #444]	; (4f80 <_DHCPS_ProcessGetPktandSendResponse+0xc88>)
    4dc4:	a91c      	add	r1, sp, #112	; 0x70
    4dc6:	f8b5 0058 	ldrh.w	r0, [r5, #88]	; 0x58
    4dca:	f018 fa89 	bl	1d2e0 <_DHCPSAddCompleteEntry>
    4dce:	b338      	cbz	r0, 4e20 <_DHCPS_ProcessGetPktandSendResponse+0xb28>
    4dd0:	e7b9      	b.n	4d46 <_DHCPS_ProcessGetPktandSendResponse+0xa4e>
            bktIx = DHCPSgetFreeHashIndex(pdhcpsHashDcpt->hashDcpt, &Header->ClientMAC,&pDhcpsDcpt->intfAddrsConf.startIPAddress,(IPV4_ADDR*)NULL);
    4dd2:	f10b 0208 	add.w	r2, fp, #8
    4dd6:	496a      	ldr	r1, [pc, #424]	; (4f80 <_DHCPS_ProcessGetPktandSendResponse+0xc88>)
    4dd8:	486a      	ldr	r0, [pc, #424]	; (4f84 <_DHCPS_ProcessGetPktandSendResponse+0xc8c>)
    4dda:	6800      	ldr	r0, [r0, #0]
    4ddc:	f015 fa3e 	bl	1a25c <DHCPSgetFreeHashIndex>
            if(bktIx == -1)
    4de0:	f1b0 3fff 	cmp.w	r0, #4294967295
    4de4:	d0af      	beq.n	4d46 <_DHCPS_ProcessGetPktandSendResponse+0xa4e>
            tempIpv4Addr.v[0] = pDhcpsDcpt->intfAddrsConf.startIPAddress.v[0] & 0xFF;
    4de6:	f89b 3008 	ldrb.w	r3, [fp, #8]
    4dea:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
            tempIpv4Addr.v[1] = pDhcpsDcpt->intfAddrsConf.startIPAddress.v[1] & 0xFF;
    4dee:	f89b 3009 	ldrb.w	r3, [fp, #9]
    4df2:	f88d 3071 	strb.w	r3, [sp, #113]	; 0x71
            tempIpv4Addr.v[2] = pDhcpsDcpt->intfAddrsConf.startIPAddress.v[2] & 0xFF;
    4df6:	f89b 300a 	ldrb.w	r3, [fp, #10]
    4dfa:	f88d 3072 	strb.w	r3, [sp, #114]	; 0x72
            tempIpv4Addr.v[3] = (pDhcpsDcpt->intfAddrsConf.startIPAddress.v[3] & 0xFF) + bktIx;
    4dfe:	f89b 300b 	ldrb.w	r3, [fp, #11]
    4e02:	4403      	add	r3, r0
    4e04:	f88d 3073 	strb.w	r3, [sp, #115]	; 0x73
    4e08:	e7da      	b.n	4dc0 <_DHCPS_ProcessGetPktandSendResponse+0xac8>
        return false;
    4e0a:	2300      	movs	r3, #0
    4e0c:	e749      	b.n	4ca2 <_DHCPS_ProcessGetPktandSendResponse+0x9aa>
                    return false;
    4e0e:	2300      	movs	r3, #0
    4e10:	e747      	b.n	4ca2 <_DHCPS_ProcessGetPktandSendResponse+0x9aa>
    hE = TCPIP_OAHASH_EntryLookup(pdhcpsHashDcpt->hashDcpt, &Header->ClientMAC);
    4e12:	495b      	ldr	r1, [pc, #364]	; (4f80 <_DHCPS_ProcessGetPktandSendResponse+0xc88>)
    4e14:	4b5b      	ldr	r3, [pc, #364]	; (4f84 <_DHCPS_ProcessGetPktandSendResponse+0xc8c>)
    4e16:	6818      	ldr	r0, [r3, #0]
    4e18:	f017 fdb4 	bl	1c984 <TCPIP_OAHASH_EntryLookup>
    if(hE !=0)
    4e1c:	2800      	cmp	r0, #0
    4e1e:	d0cb      	beq.n	4db8 <_DHCPS_ProcessGetPktandSendResponse+0xac0>
    hE = TCPIP_OAHASH_EntryLookup(pdhcpsHashDcpt->hashDcpt, &Header->ClientMAC);
    4e20:	4e59      	ldr	r6, [pc, #356]	; (4f88 <_DHCPS_ProcessGetPktandSendResponse+0xc90>)
    4e22:	f106 071c 	add.w	r7, r6, #28
    4e26:	4639      	mov	r1, r7
    4e28:	4b56      	ldr	r3, [pc, #344]	; (4f84 <_DHCPS_ProcessGetPktandSendResponse+0xc8c>)
    4e2a:	6818      	ldr	r0, [r3, #0]
    4e2c:	f017 fdaa 	bl	1c984 <TCPIP_OAHASH_EntryLookup>
    4e30:	9002      	str	r0, [sp, #8]
    putBuffer.head=putBuffer.wrPtr = TCPIP_UDP_TxPointerGet(s);
    4e32:	4640      	mov	r0, r8
    4e34:	f01e fb3b 	bl	234ae <TCPIP_UDP_TxPointerGet>
    4e38:	900d      	str	r0, [sp, #52]	; 0x34
    4e3a:	900c      	str	r0, [sp, #48]	; 0x30
    putBuffer.endPtr = putBuffer.head+DHCPS_MAX_REPONSE_PACKET_SIZE;
    4e3c:	f500 7096 	add.w	r0, r0, #300	; 0x12c
    4e40:	900e      	str	r0, [sp, #56]	; 0x38
    rxHeader.MessageType = BOOT_REPLY;
    4e42:	2302      	movs	r3, #2
    4e44:	f88d 304c 	strb.w	r3, [sp, #76]	; 0x4c
    rxHeader.HardwareType = Header->HardwareType;
    4e48:	7873      	ldrb	r3, [r6, #1]
    4e4a:	f88d 304d 	strb.w	r3, [sp, #77]	; 0x4d
    rxHeader.HardwareLen = Header->HardwareLen;
    4e4e:	78b3      	ldrb	r3, [r6, #2]
    4e50:	f88d 304e 	strb.w	r3, [sp, #78]	; 0x4e
    rxHeader.Hops = Header->Hops;
    4e54:	78f3      	ldrb	r3, [r6, #3]
    4e56:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    rxHeader.TransactionID = Header->TransactionID;
    4e5a:	6873      	ldr	r3, [r6, #4]
    4e5c:	9314      	str	r3, [sp, #80]	; 0x50
    rxHeader.SecondsElapsed = 0; // NOT USED
    4e5e:	2300      	movs	r3, #0
    4e60:	f8ad 3054 	strh.w	r3, [sp, #84]	; 0x54
    rxHeader.BootpFlags = Header->BootpFlags;
    4e64:	8972      	ldrh	r2, [r6, #10]
    4e66:	f8ad 2056 	strh.w	r2, [sp, #86]	; 0x56
    rxHeader.ClientIP.Val = 0; // Not yet Assigned
    4e6a:	9316      	str	r3, [sp, #88]	; 0x58
    rxHeader.YourIP.Val = dhcpsHE->ipAddress.Val;
    4e6c:	9a02      	ldr	r2, [sp, #8]
    4e6e:	68d2      	ldr	r2, [r2, #12]
    4e70:	9217      	str	r2, [sp, #92]	; 0x5c
    rxHeader.NextServerIP.Val = pNetIf->netIPAddr.Val;
    4e72:	686a      	ldr	r2, [r5, #4]
    4e74:	9218      	str	r2, [sp, #96]	; 0x60
    rxHeader.RelayAgentIP.Val = 0;
    4e76:	9319      	str	r3, [sp, #100]	; 0x64
    memcpy(&rxHeader.ClientMAC,&Header->ClientMAC,sizeof(TCPIP_MAC_ADDR));
    4e78:	e897 0003 	ldmia.w	r7, {r0, r1}
    4e7c:	901a      	str	r0, [sp, #104]	; 0x68
    4e7e:	f8ad 106c 	strh.w	r1, [sp, #108]	; 0x6c
    TCPIP_DHCPS_CopyDataArrayToProcessBuff((uint8_t*)&rxHeader,&putBuffer,sizeof(BOOTP_HEADER));
    4e82:	2222      	movs	r2, #34	; 0x22
    4e84:	a90c      	add	r1, sp, #48	; 0x30
    4e86:	a813      	add	r0, sp, #76	; 0x4c
    4e88:	f01b fd98 	bl	209bc <TCPIP_DHCPS_CopyDataArrayToProcessBuff>
    4e8c:	27ca      	movs	r7, #202	; 0xca
        TCPIP_DHCPS_DataCopyToProcessBuffer(0,&putBuffer);
    4e8e:	2600      	movs	r6, #0
    4e90:	a90c      	add	r1, sp, #48	; 0x30
    4e92:	4630      	mov	r0, r6
    4e94:	f01e ff8c 	bl	23db0 <TCPIP_DHCPS_DataCopyToProcessBuffer>
    4e98:	3f01      	subs	r7, #1
    for(i = 0; i < DHCPS_UNUSED_BYTES_FOR_TX; i++)	
    4e9a:	f017 07ff 	ands.w	r7, r7, #255	; 0xff
    4e9e:	d1f7      	bne.n	4e90 <_DHCPS_ProcessGetPktandSendResponse+0xb98>
    TCPIP_DHCPS_CopyDataArrayToProcessBuff((uint8_t *)&magicCookie, &putBuffer, sizeof(magicCookie));
    4ea0:	2204      	movs	r2, #4
    4ea2:	a90c      	add	r1, sp, #48	; 0x30
    4ea4:	a80b      	add	r0, sp, #44	; 0x2c
    4ea6:	f01b fd89 	bl	209bc <TCPIP_DHCPS_CopyDataArrayToProcessBuff>
    optionType.messageType.optionType = DHCP_MESSAGE_TYPE;
    4eaa:	2335      	movs	r3, #53	; 0x35
    4eac:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
    optionType.messageType.optionTypeLen = 1;
    4eb0:	2301      	movs	r3, #1
    4eb2:	f88d 3071 	strb.w	r3, [sp, #113]	; 0x71
    optionType.messageType.byteVal = DHCP_OFFER_MESSAGE;
    4eb6:	2202      	movs	r2, #2
    4eb8:	f88d 2072 	strb.w	r2, [sp, #114]	; 0x72
    optionType.subnetmaskType.optionType = DHCP_SUBNET_MASK;
    4ebc:	f88d 3073 	strb.w	r3, [sp, #115]	; 0x73
    optionType.subnetmaskType.optionTypeLen = sizeof(IPV4_ADDR);
    4ec0:	2304      	movs	r3, #4
    4ec2:	f88d 3074 	strb.w	r3, [sp, #116]	; 0x74
    optionType.subnetmaskType.intVal = pNetIf->netMask.Val;
    4ec6:	68aa      	ldr	r2, [r5, #8]
    4ec8:	f8cd 2075 	str.w	r2, [sp, #117]	; 0x75
    optionType.serverIdentifierType.optionType = DHCP_SERVER_IDENTIFIER;
    4ecc:	2236      	movs	r2, #54	; 0x36
    4ece:	f88d 2079 	strb.w	r2, [sp, #121]	; 0x79
    optionType.serverIdentifierType.optionTypeLen = sizeof(IPV4_ADDR);
    4ed2:	f88d 307a 	strb.w	r3, [sp, #122]	; 0x7a
    optionType.serverIdentifierType.intVal = pNetIf->netIPAddr.Val;
    4ed6:	686a      	ldr	r2, [r5, #4]
    4ed8:	f8cd 207b 	str.w	r2, [sp, #123]	; 0x7b
    optionType.routerType.optionType = DHCP_ROUTER;
    4edc:	2103      	movs	r1, #3
    4ede:	f88d 107f 	strb.w	r1, [sp, #127]	; 0x7f
    optionType.routerType.optionTypeLen = sizeof(IPV4_ADDR);
    4ee2:	f88d 3080 	strb.w	r3, [sp, #128]	; 0x80
    optionType.routerType.intVal = pNetIf->netIPAddr.Val;
    4ee6:	f8cd 2081 	str.w	r2, [sp, #129]	; 0x81
    optionType.dnsType.optionType = DHCP_DNS;
    4eea:	2106      	movs	r1, #6
    4eec:	f88d 1085 	strb.w	r1, [sp, #133]	; 0x85
    optionType.dnsType.optionTypeLen = sizeof(IPV4_ADDR);
    4ef0:	f88d 3086 	strb.w	r3, [sp, #134]	; 0x86
    optionType.dnsType.intVal = pNetIf->netIPAddr.Val;
    4ef4:	f8cd 2087 	str.w	r2, [sp, #135]	; 0x87
    optionType.ipLeaseTimeType.optionType = DHCP_IP_LEASE_TIME;
    4ef8:	2233      	movs	r2, #51	; 0x33
    4efa:	f88d 208b 	strb.w	r2, [sp, #139]	; 0x8b
    optionType.ipLeaseTimeType.optionTypeLen = 4;
    4efe:	f88d 308c 	strb.w	r3, [sp, #140]	; 0x8c
    optionType.ipLeaseTimeType.intVal = pdhcpsHashDcpt->leaseDuartion;
    4f02:	4b20      	ldr	r3, [pc, #128]	; (4f84 <_DHCPS_ProcessGetPktandSendResponse+0xc8c>)
    4f04:	685b      	ldr	r3, [r3, #4]
    4f06:	0e1a      	lsrs	r2, r3, #24
    4f08:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    4f0c:	0219      	lsls	r1, r3, #8
    4f0e:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    4f12:	430a      	orrs	r2, r1
    4f14:	0a1b      	lsrs	r3, r3, #8
    4f16:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    4f1a:	4313      	orrs	r3, r2
    optionType.ipLeaseTimeType.intVal = TCPIP_Helper_htonl(optionType.ipLeaseTimeType.intVal);
    4f1c:	f8cd 308d 	str.w	r3, [sp, #141]	; 0x8d
    TCPIP_DHCPS_CopyDataArrayToProcessBuff((uint8_t*)&optionType,&putBuffer,optionTypeTotalLen);
    4f20:	2221      	movs	r2, #33	; 0x21
    4f22:	a90c      	add	r1, sp, #48	; 0x30
    4f24:	a81c      	add	r0, sp, #112	; 0x70
    4f26:	f01b fd49 	bl	209bc <TCPIP_DHCPS_CopyDataArrayToProcessBuff>
    TCPIP_DHCPS_DataCopyToProcessBuffer(DHCP_END_OPTION,&putBuffer);
    4f2a:	a90c      	add	r1, sp, #48	; 0x30
    4f2c:	20ff      	movs	r0, #255	; 0xff
    4f2e:	f01e ff3f 	bl	23db0 <TCPIP_DHCPS_DataCopyToProcessBuffer>
    while(putBuffer.wrPtr < putBuffer.endPtr)
    4f32:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    4f34:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    4f36:	429a      	cmp	r2, r3
    4f38:	d908      	bls.n	4f4c <_DHCPS_ProcessGetPktandSendResponse+0xc54>
        TCPIP_DHCPS_DataCopyToProcessBuffer(0,&putBuffer);
    4f3a:	2600      	movs	r6, #0
    4f3c:	a90c      	add	r1, sp, #48	; 0x30
    4f3e:	4630      	mov	r0, r6
    4f40:	f01e ff36 	bl	23db0 <TCPIP_DHCPS_DataCopyToProcessBuffer>
    while(putBuffer.wrPtr < putBuffer.endPtr)
    4f44:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    4f46:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    4f48:	429a      	cmp	r2, r3
    4f4a:	d3f7      	bcc.n	4f3c <_DHCPS_ProcessGetPktandSendResponse+0xc44>
    TCPIP_UDP_BcastIPV4AddressSet( s,UDP_BCAST_NETWORK_LIMITED,pNetIf);
    4f4c:	462a      	mov	r2, r5
    4f4e:	2101      	movs	r1, #1
    4f50:	4640      	mov	r0, r8
    4f52:	f018 fcac 	bl	1d8ae <TCPIP_UDP_BcastIPV4AddressSet>
    IP_MULTI_ADDRESS tmp_MultiAddr; tmp_MultiAddr.v4Add = pNetIf->netIPAddr;
    4f56:	686b      	ldr	r3, [r5, #4]
    4f58:	930f      	str	r3, [sp, #60]	; 0x3c
    TCPIP_UDP_SourceIPAddressSet(s,IP_ADDRESS_TYPE_IPV4,&tmp_MultiAddr);
    4f5a:	aa0f      	add	r2, sp, #60	; 0x3c
    4f5c:	2101      	movs	r1, #1
    4f5e:	4640      	mov	r0, r8
    4f60:	f01a fbff 	bl	1f762 <TCPIP_UDP_SourceIPAddressSet>
    TCPIP_UDP_TxOffsetSet(s,(uint16_t)(putBuffer.wrPtr - putBuffer.head), false);
    4f64:	990d      	ldr	r1, [sp, #52]	; 0x34
    4f66:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    4f68:	1ac9      	subs	r1, r1, r3
    4f6a:	2200      	movs	r2, #0
    4f6c:	b289      	uxth	r1, r1
    4f6e:	4640      	mov	r0, r8
    4f70:	f01a ff75 	bl	1fe5e <TCPIP_UDP_TxOffsetSet>
    TCPIP_UDP_Flush(s);
    4f74:	4640      	mov	r0, r8
    4f76:	f00a fbdf 	bl	f738 <TCPIP_UDP_Flush>
    4f7a:	e6e4      	b.n	4d46 <_DHCPS_ProcessGetPktandSendResponse+0xa4e>
    4f7c:	2000ed3c 	.word	0x2000ed3c
    4f80:	2000eadc 	.word	0x2000eadc
    4f84:	2000ed7c 	.word	0x2000ed7c
    4f88:	2000eac0 	.word	0x2000eac0

Disassembly of section .text._dtoa_r%216:

00004f90 <_dtoa_r>:
    4f90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4f94:	ec55 4b10 	vmov	r4, r5, d0
    4f98:	b099      	sub	sp, #100	; 0x64
    4f9a:	6a47      	ldr	r7, [r0, #36]	; 0x24
    4f9c:	9108      	str	r1, [sp, #32]
    4f9e:	4683      	mov	fp, r0
    4fa0:	920d      	str	r2, [sp, #52]	; 0x34
    4fa2:	9314      	str	r3, [sp, #80]	; 0x50
    4fa4:	9e22      	ldr	r6, [sp, #136]	; 0x88
    4fa6:	e9cd 4504 	strd	r4, r5, [sp, #16]
    4faa:	b947      	cbnz	r7, 4fbe <_dtoa_r+0x2e>
    4fac:	2010      	movs	r0, #16
    4fae:	f01e ff67 	bl	23e80 <malloc>
    4fb2:	e9c0 7701 	strd	r7, r7, [r0, #4]
    4fb6:	f8cb 0024 	str.w	r0, [fp, #36]	; 0x24
    4fba:	6007      	str	r7, [r0, #0]
    4fbc:	60c7      	str	r7, [r0, #12]
    4fbe:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
    4fc2:	6819      	ldr	r1, [r3, #0]
    4fc4:	b159      	cbz	r1, 4fde <_dtoa_r+0x4e>
    4fc6:	685a      	ldr	r2, [r3, #4]
    4fc8:	604a      	str	r2, [r1, #4]
    4fca:	2301      	movs	r3, #1
    4fcc:	4093      	lsls	r3, r2
    4fce:	608b      	str	r3, [r1, #8]
    4fd0:	4658      	mov	r0, fp
    4fd2:	f01c fc74 	bl	218be <_Bfree>
    4fd6:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
    4fda:	2200      	movs	r2, #0
    4fdc:	601a      	str	r2, [r3, #0]
    4fde:	2d00      	cmp	r5, #0
    4fe0:	bfbf      	itttt	lt
    4fe2:	2301      	movlt	r3, #1
    4fe4:	6033      	strlt	r3, [r6, #0]
    4fe6:	f025 4300 	biclt.w	r3, r5, #2147483648	; 0x80000000
    4fea:	9305      	strlt	r3, [sp, #20]
    4fec:	bfa4      	itt	ge
    4fee:	2300      	movge	r3, #0
    4ff0:	6033      	strge	r3, [r6, #0]
    4ff2:	9c05      	ldr	r4, [sp, #20]
    4ff4:	4bb2      	ldr	r3, [pc, #712]	; (52c0 <_dtoa_r+0x330>)
    4ff6:	43a3      	bics	r3, r4
    4ff8:	d11a      	bne.n	5030 <_dtoa_r+0xa0>
    4ffa:	9a14      	ldr	r2, [sp, #80]	; 0x50
    4ffc:	f242 730f 	movw	r3, #9999	; 0x270f
    5000:	6013      	str	r3, [r2, #0]
    5002:	9b04      	ldr	r3, [sp, #16]
    5004:	f3c4 0413 	ubfx	r4, r4, #0, #20
    5008:	4323      	orrs	r3, r4
    500a:	f000 854f 	beq.w	5aac <_dtoa_r+0xb1c>
    500e:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    5010:	b953      	cbnz	r3, 5028 <_dtoa_r+0x98>
    5012:	4bac      	ldr	r3, [pc, #688]	; (52c4 <_dtoa_r+0x334>)
    5014:	e023      	b.n	505e <_dtoa_r+0xce>
    5016:	4bac      	ldr	r3, [pc, #688]	; (52c8 <_dtoa_r+0x338>)
    5018:	9301      	str	r3, [sp, #4]
    501a:	3308      	adds	r3, #8
    501c:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    501e:	6013      	str	r3, [r2, #0]
    5020:	9801      	ldr	r0, [sp, #4]
    5022:	b019      	add	sp, #100	; 0x64
    5024:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5028:	4ba6      	ldr	r3, [pc, #664]	; (52c4 <_dtoa_r+0x334>)
    502a:	9301      	str	r3, [sp, #4]
    502c:	3303      	adds	r3, #3
    502e:	e7f5      	b.n	501c <_dtoa_r+0x8c>
    5030:	ed9d 7b04 	vldr	d7, [sp, #16]
    5034:	2200      	movs	r2, #0
    5036:	2300      	movs	r3, #0
    5038:	ec51 0b17 	vmov	r0, r1, d7
    503c:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
    5040:	f010 f940 	bl	152c4 <__aeabi_dcmpeq>
    5044:	4607      	mov	r7, r0
    5046:	b160      	cbz	r0, 5062 <_dtoa_r+0xd2>
    5048:	9a14      	ldr	r2, [sp, #80]	; 0x50
    504a:	2301      	movs	r3, #1
    504c:	6013      	str	r3, [r2, #0]
    504e:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    5050:	2b00      	cmp	r3, #0
    5052:	f000 8528 	beq.w	5aa6 <_dtoa_r+0xb16>
    5056:	4b9d      	ldr	r3, [pc, #628]	; (52cc <_dtoa_r+0x33c>)
    5058:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    505a:	6013      	str	r3, [r2, #0]
    505c:	3b01      	subs	r3, #1
    505e:	9301      	str	r3, [sp, #4]
    5060:	e7de      	b.n	5020 <_dtoa_r+0x90>
    5062:	aa16      	add	r2, sp, #88	; 0x58
    5064:	a917      	add	r1, sp, #92	; 0x5c
    5066:	ed9d 0b0e 	vldr	d0, [sp, #56]	; 0x38
    506a:	4658      	mov	r0, fp
    506c:	f014 fb57 	bl	1971e <__d2b>
    5070:	f3c4 560a 	ubfx	r6, r4, #20, #11
    5074:	4680      	mov	r8, r0
    5076:	2e00      	cmp	r6, #0
    5078:	d07f      	beq.n	517a <_dtoa_r+0x1ea>
    507a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    507c:	9715      	str	r7, [sp, #84]	; 0x54
    507e:	f3c3 0313 	ubfx	r3, r3, #0, #20
    5082:	e9dd 450e 	ldrd	r4, r5, [sp, #56]	; 0x38
    5086:	f043 557f 	orr.w	r5, r3, #1069547520	; 0x3fc00000
    508a:	f445 1540 	orr.w	r5, r5, #3145728	; 0x300000
    508e:	f2a6 36ff 	subw	r6, r6, #1023	; 0x3ff
    5092:	2200      	movs	r2, #0
    5094:	4b8e      	ldr	r3, [pc, #568]	; (52d0 <_dtoa_r+0x340>)
    5096:	4620      	mov	r0, r4
    5098:	4629      	mov	r1, r5
    509a:	f006 fbbb 	bl	b814 <__aeabi_dsub>
    509e:	a382      	add	r3, pc, #520	; (adr r3, 52a8 <_dtoa_r+0x318>)
    50a0:	e9d3 2300 	ldrd	r2, r3, [r3]
    50a4:	f005 f812 	bl	a0cc <__aeabi_dmul>
    50a8:	a381      	add	r3, pc, #516	; (adr r3, 52b0 <_dtoa_r+0x320>)
    50aa:	e9d3 2300 	ldrd	r2, r3, [r3]
    50ae:	f006 fbb3 	bl	b818 <__adddf3>
    50b2:	4604      	mov	r4, r0
    50b4:	4630      	mov	r0, r6
    50b6:	460d      	mov	r5, r1
    50b8:	f006 fcfa 	bl	bab0 <__aeabi_i2d>
    50bc:	a37e      	add	r3, pc, #504	; (adr r3, 52b8 <_dtoa_r+0x328>)
    50be:	e9d3 2300 	ldrd	r2, r3, [r3]
    50c2:	f005 f803 	bl	a0cc <__aeabi_dmul>
    50c6:	4602      	mov	r2, r0
    50c8:	460b      	mov	r3, r1
    50ca:	4620      	mov	r0, r4
    50cc:	4629      	mov	r1, r5
    50ce:	f006 fba3 	bl	b818 <__adddf3>
    50d2:	4604      	mov	r4, r0
    50d4:	460d      	mov	r5, r1
    50d6:	f019 fa71 	bl	1e5bc <__aeabi_d2iz>
    50da:	2200      	movs	r2, #0
    50dc:	4682      	mov	sl, r0
    50de:	2300      	movs	r3, #0
    50e0:	4620      	mov	r0, r4
    50e2:	4629      	mov	r1, r5
    50e4:	f010 f8f8 	bl	152d8 <__aeabi_dcmplt>
    50e8:	b148      	cbz	r0, 50fe <_dtoa_r+0x16e>
    50ea:	4650      	mov	r0, sl
    50ec:	f006 fce0 	bl	bab0 <__aeabi_i2d>
    50f0:	4622      	mov	r2, r4
    50f2:	462b      	mov	r3, r5
    50f4:	f010 f8e6 	bl	152c4 <__aeabi_dcmpeq>
    50f8:	b908      	cbnz	r0, 50fe <_dtoa_r+0x16e>
    50fa:	f10a 3aff 	add.w	sl, sl, #4294967295
    50fe:	f1ba 0f16 	cmp.w	sl, #22
    5102:	d859      	bhi.n	51b8 <_dtoa_r+0x228>
    5104:	4b73      	ldr	r3, [pc, #460]	; (52d4 <_dtoa_r+0x344>)
    5106:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
    510a:	e9d3 2300 	ldrd	r2, r3, [r3]
    510e:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
    5112:	f010 f8e1 	bl	152d8 <__aeabi_dcmplt>
    5116:	2800      	cmp	r0, #0
    5118:	d050      	beq.n	51bc <_dtoa_r+0x22c>
    511a:	f10a 3aff 	add.w	sl, sl, #4294967295
    511e:	2300      	movs	r3, #0
    5120:	9311      	str	r3, [sp, #68]	; 0x44
    5122:	9b16      	ldr	r3, [sp, #88]	; 0x58
    5124:	1b9e      	subs	r6, r3, r6
    5126:	1e73      	subs	r3, r6, #1
    5128:	9307      	str	r3, [sp, #28]
    512a:	bf45      	ittet	mi
    512c:	f1c6 0301 	rsbmi	r3, r6, #1
    5130:	9306      	strmi	r3, [sp, #24]
    5132:	2300      	movpl	r3, #0
    5134:	2300      	movmi	r3, #0
    5136:	bf4c      	ite	mi
    5138:	9307      	strmi	r3, [sp, #28]
    513a:	9306      	strpl	r3, [sp, #24]
    513c:	f1ba 0f00 	cmp.w	sl, #0
    5140:	db3e      	blt.n	51c0 <_dtoa_r+0x230>
    5142:	9b07      	ldr	r3, [sp, #28]
    5144:	f8cd a040 	str.w	sl, [sp, #64]	; 0x40
    5148:	4453      	add	r3, sl
    514a:	9307      	str	r3, [sp, #28]
    514c:	2300      	movs	r3, #0
    514e:	9309      	str	r3, [sp, #36]	; 0x24
    5150:	9b08      	ldr	r3, [sp, #32]
    5152:	2b09      	cmp	r3, #9
    5154:	f200 808e 	bhi.w	5274 <_dtoa_r+0x2e4>
    5158:	2b05      	cmp	r3, #5
    515a:	bfc4      	itt	gt
    515c:	3b04      	subgt	r3, #4
    515e:	9308      	strgt	r3, [sp, #32]
    5160:	9b08      	ldr	r3, [sp, #32]
    5162:	f1a3 0302 	sub.w	r3, r3, #2
    5166:	bfcc      	ite	gt
    5168:	2400      	movgt	r4, #0
    516a:	2401      	movle	r4, #1
    516c:	2b03      	cmp	r3, #3
    516e:	f200 808c 	bhi.w	528a <_dtoa_r+0x2fa>
    5172:	e8df f003 	tbb	[pc, r3]
    5176:	712f      	.short	0x712f
    5178:	7d6f      	.short	0x7d6f
    517a:	e9dd 6316 	ldrd	r6, r3, [sp, #88]	; 0x58
    517e:	441e      	add	r6, r3
    5180:	f206 4032 	addw	r0, r6, #1074	; 0x432
    5184:	2820      	cmp	r0, #32
    5186:	dd11      	ble.n	51ac <_dtoa_r+0x21c>
    5188:	f1c0 0040 	rsb	r0, r0, #64	; 0x40
    518c:	9b04      	ldr	r3, [sp, #16]
    518e:	4084      	lsls	r4, r0
    5190:	f206 4012 	addw	r0, r6, #1042	; 0x412
    5194:	fa23 f000 	lsr.w	r0, r3, r0
    5198:	4320      	orrs	r0, r4
    519a:	f006 fc79 	bl	ba90 <__aeabi_ui2d>
    519e:	2301      	movs	r3, #1
    51a0:	4604      	mov	r4, r0
    51a2:	f1a1 75f8 	sub.w	r5, r1, #32505856	; 0x1f00000
    51a6:	3e01      	subs	r6, #1
    51a8:	9315      	str	r3, [sp, #84]	; 0x54
    51aa:	e772      	b.n	5092 <_dtoa_r+0x102>
    51ac:	9b04      	ldr	r3, [sp, #16]
    51ae:	f1c0 0020 	rsb	r0, r0, #32
    51b2:	fa03 f000 	lsl.w	r0, r3, r0
    51b6:	e7f0      	b.n	519a <_dtoa_r+0x20a>
    51b8:	2301      	movs	r3, #1
    51ba:	e7b1      	b.n	5120 <_dtoa_r+0x190>
    51bc:	9011      	str	r0, [sp, #68]	; 0x44
    51be:	e7b0      	b.n	5122 <_dtoa_r+0x192>
    51c0:	9b06      	ldr	r3, [sp, #24]
    51c2:	eba3 030a 	sub.w	r3, r3, sl
    51c6:	9306      	str	r3, [sp, #24]
    51c8:	f1ca 0300 	rsb	r3, sl, #0
    51cc:	9309      	str	r3, [sp, #36]	; 0x24
    51ce:	2300      	movs	r3, #0
    51d0:	9310      	str	r3, [sp, #64]	; 0x40
    51d2:	e7bd      	b.n	5150 <_dtoa_r+0x1c0>
    51d4:	2300      	movs	r3, #0
    51d6:	930c      	str	r3, [sp, #48]	; 0x30
    51d8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    51da:	2b00      	cmp	r3, #0
    51dc:	dc59      	bgt.n	5292 <_dtoa_r+0x302>
    51de:	2301      	movs	r3, #1
    51e0:	9302      	str	r3, [sp, #8]
    51e2:	4699      	mov	r9, r3
    51e4:	930d      	str	r3, [sp, #52]	; 0x34
    51e6:	f8db 5024 	ldr.w	r5, [fp, #36]	; 0x24
    51ea:	2200      	movs	r2, #0
    51ec:	606a      	str	r2, [r5, #4]
    51ee:	2204      	movs	r2, #4
    51f0:	f102 0014 	add.w	r0, r2, #20
    51f4:	4298      	cmp	r0, r3
    51f6:	6869      	ldr	r1, [r5, #4]
    51f8:	d94f      	bls.n	529a <_dtoa_r+0x30a>
    51fa:	4658      	mov	r0, fp
    51fc:	f017 fcc6 	bl	1cb8c <_Balloc>
    5200:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
    5204:	6028      	str	r0, [r5, #0]
    5206:	681b      	ldr	r3, [r3, #0]
    5208:	9301      	str	r3, [sp, #4]
    520a:	f1b9 0f0e 	cmp.w	r9, #14
    520e:	f200 80e6 	bhi.w	53de <_dtoa_r+0x44e>
    5212:	2c00      	cmp	r4, #0
    5214:	f000 80e3 	beq.w	53de <_dtoa_r+0x44e>
    5218:	f1ba 0f00 	cmp.w	sl, #0
    521c:	dd78      	ble.n	5310 <_dtoa_r+0x380>
    521e:	4a2d      	ldr	r2, [pc, #180]	; (52d4 <_dtoa_r+0x344>)
    5220:	f00a 030f 	and.w	r3, sl, #15
    5224:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    5228:	ed93 7b00 	vldr	d7, [r3]
    522c:	ea4f 142a 	mov.w	r4, sl, asr #4
    5230:	06e2      	lsls	r2, r4, #27
    5232:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
    5236:	d569      	bpl.n	530c <_dtoa_r+0x37c>
    5238:	4b27      	ldr	r3, [pc, #156]	; (52d8 <_dtoa_r+0x348>)
    523a:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
    523e:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
    5242:	f005 f86d 	bl	a320 <__aeabi_ddiv>
    5246:	e9cd 0104 	strd	r0, r1, [sp, #16]
    524a:	f004 040f 	and.w	r4, r4, #15
    524e:	2603      	movs	r6, #3
    5250:	4d21      	ldr	r5, [pc, #132]	; (52d8 <_dtoa_r+0x348>)
    5252:	e050      	b.n	52f6 <_dtoa_r+0x366>
    5254:	2301      	movs	r3, #1
    5256:	e7be      	b.n	51d6 <_dtoa_r+0x246>
    5258:	2300      	movs	r3, #0
    525a:	930c      	str	r3, [sp, #48]	; 0x30
    525c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    525e:	4453      	add	r3, sl
    5260:	f103 0901 	add.w	r9, r3, #1
    5264:	9302      	str	r3, [sp, #8]
    5266:	464b      	mov	r3, r9
    5268:	2b01      	cmp	r3, #1
    526a:	bfb8      	it	lt
    526c:	2301      	movlt	r3, #1
    526e:	e7ba      	b.n	51e6 <_dtoa_r+0x256>
    5270:	2301      	movs	r3, #1
    5272:	e7f2      	b.n	525a <_dtoa_r+0x2ca>
    5274:	2300      	movs	r3, #0
    5276:	2401      	movs	r4, #1
    5278:	9308      	str	r3, [sp, #32]
    527a:	940c      	str	r4, [sp, #48]	; 0x30
    527c:	3b01      	subs	r3, #1
    527e:	2200      	movs	r2, #0
    5280:	9302      	str	r3, [sp, #8]
    5282:	4699      	mov	r9, r3
    5284:	920d      	str	r2, [sp, #52]	; 0x34
    5286:	2312      	movs	r3, #18
    5288:	e7ad      	b.n	51e6 <_dtoa_r+0x256>
    528a:	2301      	movs	r3, #1
    528c:	930c      	str	r3, [sp, #48]	; 0x30
    528e:	3b02      	subs	r3, #2
    5290:	e7f5      	b.n	527e <_dtoa_r+0x2ee>
    5292:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    5294:	9302      	str	r3, [sp, #8]
    5296:	4699      	mov	r9, r3
    5298:	e7a5      	b.n	51e6 <_dtoa_r+0x256>
    529a:	3101      	adds	r1, #1
    529c:	6069      	str	r1, [r5, #4]
    529e:	0052      	lsls	r2, r2, #1
    52a0:	e7a6      	b.n	51f0 <_dtoa_r+0x260>
    52a2:	bf00      	nop
    52a4:	f3af 8000 	nop.w
    52a8:	636f4361 	.word	0x636f4361
    52ac:	3fd287a7 	.word	0x3fd287a7
    52b0:	8b60c8b3 	.word	0x8b60c8b3
    52b4:	3fc68a28 	.word	0x3fc68a28
    52b8:	509f79fb 	.word	0x509f79fb
    52bc:	3fd34413 	.word	0x3fd34413
    52c0:	7ff00000 	.word	0x7ff00000
    52c4:	00023ef9 	.word	0x00023ef9
    52c8:	00023ef0 	.word	0x00023ef0
    52cc:	00023efe 	.word	0x00023efe
    52d0:	3ff80000 	.word	0x3ff80000
    52d4:	00017818 	.word	0x00017818
    52d8:	00022330 	.word	0x00022330
    52dc:	07e3      	lsls	r3, r4, #31
    52de:	d508      	bpl.n	52f2 <_dtoa_r+0x362>
    52e0:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    52e4:	e9d5 2300 	ldrd	r2, r3, [r5]
    52e8:	f004 fef0 	bl	a0cc <__aeabi_dmul>
    52ec:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
    52f0:	3601      	adds	r6, #1
    52f2:	1064      	asrs	r4, r4, #1
    52f4:	3508      	adds	r5, #8
    52f6:	2c00      	cmp	r4, #0
    52f8:	d1f0      	bne.n	52dc <_dtoa_r+0x34c>
    52fa:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
    52fe:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    5302:	f005 f80d 	bl	a320 <__aeabi_ddiv>
    5306:	e9cd 0104 	strd	r0, r1, [sp, #16]
    530a:	e01a      	b.n	5342 <_dtoa_r+0x3b2>
    530c:	2602      	movs	r6, #2
    530e:	e79f      	b.n	5250 <_dtoa_r+0x2c0>
    5310:	f000 809f 	beq.w	5452 <_dtoa_r+0x4c2>
    5314:	f1ca 0400 	rsb	r4, sl, #0
    5318:	4b9f      	ldr	r3, [pc, #636]	; (5598 <_dtoa_r+0x608>)
    531a:	4da0      	ldr	r5, [pc, #640]	; (559c <_dtoa_r+0x60c>)
    531c:	f004 020f 	and.w	r2, r4, #15
    5320:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    5324:	e9d3 2300 	ldrd	r2, r3, [r3]
    5328:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
    532c:	f004 fece 	bl	a0cc <__aeabi_dmul>
    5330:	e9cd 0104 	strd	r0, r1, [sp, #16]
    5334:	1124      	asrs	r4, r4, #4
    5336:	2300      	movs	r3, #0
    5338:	2602      	movs	r6, #2
    533a:	2c00      	cmp	r4, #0
    533c:	d17e      	bne.n	543c <_dtoa_r+0x4ac>
    533e:	2b00      	cmp	r3, #0
    5340:	d1e1      	bne.n	5306 <_dtoa_r+0x376>
    5342:	9b11      	ldr	r3, [sp, #68]	; 0x44
    5344:	2b00      	cmp	r3, #0
    5346:	f000 8086 	beq.w	5456 <_dtoa_r+0x4c6>
    534a:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
    534e:	2200      	movs	r2, #0
    5350:	4b93      	ldr	r3, [pc, #588]	; (55a0 <_dtoa_r+0x610>)
    5352:	4620      	mov	r0, r4
    5354:	4629      	mov	r1, r5
    5356:	f00f ffbf 	bl	152d8 <__aeabi_dcmplt>
    535a:	2800      	cmp	r0, #0
    535c:	d07b      	beq.n	5456 <_dtoa_r+0x4c6>
    535e:	f1b9 0f00 	cmp.w	r9, #0
    5362:	d078      	beq.n	5456 <_dtoa_r+0x4c6>
    5364:	9b02      	ldr	r3, [sp, #8]
    5366:	2b00      	cmp	r3, #0
    5368:	dd35      	ble.n	53d6 <_dtoa_r+0x446>
    536a:	f10a 33ff 	add.w	r3, sl, #4294967295
    536e:	930a      	str	r3, [sp, #40]	; 0x28
    5370:	4620      	mov	r0, r4
    5372:	2200      	movs	r2, #0
    5374:	4b8b      	ldr	r3, [pc, #556]	; (55a4 <_dtoa_r+0x614>)
    5376:	4629      	mov	r1, r5
    5378:	f004 fea8 	bl	a0cc <__aeabi_dmul>
    537c:	e9cd 0104 	strd	r0, r1, [sp, #16]
    5380:	9c02      	ldr	r4, [sp, #8]
    5382:	3601      	adds	r6, #1
    5384:	4630      	mov	r0, r6
    5386:	f006 fb93 	bl	bab0 <__aeabi_i2d>
    538a:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    538e:	f004 fe9d 	bl	a0cc <__aeabi_dmul>
    5392:	2200      	movs	r2, #0
    5394:	4b84      	ldr	r3, [pc, #528]	; (55a8 <_dtoa_r+0x618>)
    5396:	f006 fa3f 	bl	b818 <__adddf3>
    539a:	4606      	mov	r6, r0
    539c:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
    53a0:	2c00      	cmp	r4, #0
    53a2:	d15c      	bne.n	545e <_dtoa_r+0x4ce>
    53a4:	2200      	movs	r2, #0
    53a6:	4b81      	ldr	r3, [pc, #516]	; (55ac <_dtoa_r+0x61c>)
    53a8:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    53ac:	f006 fa32 	bl	b814 <__aeabi_dsub>
    53b0:	4632      	mov	r2, r6
    53b2:	463b      	mov	r3, r7
    53b4:	e9cd 0104 	strd	r0, r1, [sp, #16]
    53b8:	f00f ffac 	bl	15314 <__aeabi_dcmpgt>
    53bc:	2800      	cmp	r0, #0
    53be:	f040 8289 	bne.w	58d4 <_dtoa_r+0x944>
    53c2:	4632      	mov	r2, r6
    53c4:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
    53c8:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    53cc:	f00f ff84 	bl	152d8 <__aeabi_dcmplt>
    53d0:	2800      	cmp	r0, #0
    53d2:	f040 827d 	bne.w	58d0 <_dtoa_r+0x940>
    53d6:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
    53da:	e9cd 3404 	strd	r3, r4, [sp, #16]
    53de:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    53e0:	2b00      	cmp	r3, #0
    53e2:	f2c0 814f 	blt.w	5684 <_dtoa_r+0x6f4>
    53e6:	f1ba 0f0e 	cmp.w	sl, #14
    53ea:	f300 814b 	bgt.w	5684 <_dtoa_r+0x6f4>
    53ee:	4b6a      	ldr	r3, [pc, #424]	; (5598 <_dtoa_r+0x608>)
    53f0:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
    53f4:	ed93 7b00 	vldr	d7, [r3]
    53f8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    53fa:	2b00      	cmp	r3, #0
    53fc:	ed8d 7b02 	vstr	d7, [sp, #8]
    5400:	f280 80d8 	bge.w	55b4 <_dtoa_r+0x624>
    5404:	f1b9 0f00 	cmp.w	r9, #0
    5408:	f300 80d4 	bgt.w	55b4 <_dtoa_r+0x624>
    540c:	f040 825f 	bne.w	58ce <_dtoa_r+0x93e>
    5410:	2200      	movs	r2, #0
    5412:	4b66      	ldr	r3, [pc, #408]	; (55ac <_dtoa_r+0x61c>)
    5414:	ec51 0b17 	vmov	r0, r1, d7
    5418:	f004 fe58 	bl	a0cc <__aeabi_dmul>
    541c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    5420:	f00f ff6e 	bl	15300 <__aeabi_dcmpge>
    5424:	464c      	mov	r4, r9
    5426:	464e      	mov	r6, r9
    5428:	2800      	cmp	r0, #0
    542a:	f040 8238 	bne.w	589e <_dtoa_r+0x90e>
    542e:	9d01      	ldr	r5, [sp, #4]
    5430:	2331      	movs	r3, #49	; 0x31
    5432:	f805 3b01 	strb.w	r3, [r5], #1
    5436:	f10a 0a01 	add.w	sl, sl, #1
    543a:	e234      	b.n	58a6 <_dtoa_r+0x916>
    543c:	07e7      	lsls	r7, r4, #31
    543e:	d505      	bpl.n	544c <_dtoa_r+0x4bc>
    5440:	e9d5 2300 	ldrd	r2, r3, [r5]
    5444:	f004 fe42 	bl	a0cc <__aeabi_dmul>
    5448:	3601      	adds	r6, #1
    544a:	2301      	movs	r3, #1
    544c:	1064      	asrs	r4, r4, #1
    544e:	3508      	adds	r5, #8
    5450:	e773      	b.n	533a <_dtoa_r+0x3aa>
    5452:	2602      	movs	r6, #2
    5454:	e775      	b.n	5342 <_dtoa_r+0x3b2>
    5456:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
    545a:	464c      	mov	r4, r9
    545c:	e792      	b.n	5384 <_dtoa_r+0x3f4>
    545e:	4b4e      	ldr	r3, [pc, #312]	; (5598 <_dtoa_r+0x608>)
    5460:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
    5464:	e953 0102 	ldrd	r0, r1, [r3, #-8]
    5468:	9b01      	ldr	r3, [sp, #4]
    546a:	441c      	add	r4, r3
    546c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    546e:	2b00      	cmp	r3, #0
    5470:	d046      	beq.n	5500 <_dtoa_r+0x570>
    5472:	4602      	mov	r2, r0
    5474:	460b      	mov	r3, r1
    5476:	2000      	movs	r0, #0
    5478:	494d      	ldr	r1, [pc, #308]	; (55b0 <_dtoa_r+0x620>)
    547a:	f004 ff51 	bl	a320 <__aeabi_ddiv>
    547e:	4632      	mov	r2, r6
    5480:	463b      	mov	r3, r7
    5482:	f006 f9c7 	bl	b814 <__aeabi_dsub>
    5486:	9d01      	ldr	r5, [sp, #4]
    5488:	4606      	mov	r6, r0
    548a:	460f      	mov	r7, r1
    548c:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    5490:	f019 f894 	bl	1e5bc <__aeabi_d2iz>
    5494:	9012      	str	r0, [sp, #72]	; 0x48
    5496:	f006 fb0b 	bl	bab0 <__aeabi_i2d>
    549a:	4602      	mov	r2, r0
    549c:	460b      	mov	r3, r1
    549e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    54a2:	f006 f9b7 	bl	b814 <__aeabi_dsub>
    54a6:	9b12      	ldr	r3, [sp, #72]	; 0x48
    54a8:	3330      	adds	r3, #48	; 0x30
    54aa:	f805 3b01 	strb.w	r3, [r5], #1
    54ae:	4632      	mov	r2, r6
    54b0:	463b      	mov	r3, r7
    54b2:	e9cd 0104 	strd	r0, r1, [sp, #16]
    54b6:	f00f ff0f 	bl	152d8 <__aeabi_dcmplt>
    54ba:	2800      	cmp	r0, #0
    54bc:	d160      	bne.n	5580 <_dtoa_r+0x5f0>
    54be:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    54c2:	2000      	movs	r0, #0
    54c4:	4936      	ldr	r1, [pc, #216]	; (55a0 <_dtoa_r+0x610>)
    54c6:	f006 f9a5 	bl	b814 <__aeabi_dsub>
    54ca:	4632      	mov	r2, r6
    54cc:	463b      	mov	r3, r7
    54ce:	f00f ff03 	bl	152d8 <__aeabi_dcmplt>
    54d2:	2800      	cmp	r0, #0
    54d4:	f040 80b4 	bne.w	5640 <_dtoa_r+0x6b0>
    54d8:	42a5      	cmp	r5, r4
    54da:	f43f af7c 	beq.w	53d6 <_dtoa_r+0x446>
    54de:	2200      	movs	r2, #0
    54e0:	4b30      	ldr	r3, [pc, #192]	; (55a4 <_dtoa_r+0x614>)
    54e2:	4630      	mov	r0, r6
    54e4:	4639      	mov	r1, r7
    54e6:	f004 fdf1 	bl	a0cc <__aeabi_dmul>
    54ea:	2200      	movs	r2, #0
    54ec:	4606      	mov	r6, r0
    54ee:	460f      	mov	r7, r1
    54f0:	4b2c      	ldr	r3, [pc, #176]	; (55a4 <_dtoa_r+0x614>)
    54f2:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    54f6:	f004 fde9 	bl	a0cc <__aeabi_dmul>
    54fa:	e9cd 0104 	strd	r0, r1, [sp, #16]
    54fe:	e7c5      	b.n	548c <_dtoa_r+0x4fc>
    5500:	4632      	mov	r2, r6
    5502:	463b      	mov	r3, r7
    5504:	f004 fde2 	bl	a0cc <__aeabi_dmul>
    5508:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
    550c:	9e01      	ldr	r6, [sp, #4]
    550e:	4625      	mov	r5, r4
    5510:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    5514:	f019 f852 	bl	1e5bc <__aeabi_d2iz>
    5518:	4607      	mov	r7, r0
    551a:	f006 fac9 	bl	bab0 <__aeabi_i2d>
    551e:	3730      	adds	r7, #48	; 0x30
    5520:	4602      	mov	r2, r0
    5522:	460b      	mov	r3, r1
    5524:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    5528:	f006 f974 	bl	b814 <__aeabi_dsub>
    552c:	f806 7b01 	strb.w	r7, [r6], #1
    5530:	42a6      	cmp	r6, r4
    5532:	e9cd 0104 	strd	r0, r1, [sp, #16]
    5536:	f04f 0200 	mov.w	r2, #0
    553a:	d126      	bne.n	558a <_dtoa_r+0x5fa>
    553c:	4b1c      	ldr	r3, [pc, #112]	; (55b0 <_dtoa_r+0x620>)
    553e:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
    5542:	f006 f969 	bl	b818 <__adddf3>
    5546:	4602      	mov	r2, r0
    5548:	460b      	mov	r3, r1
    554a:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    554e:	f00f fee1 	bl	15314 <__aeabi_dcmpgt>
    5552:	2800      	cmp	r0, #0
    5554:	d174      	bne.n	5640 <_dtoa_r+0x6b0>
    5556:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
    555a:	2000      	movs	r0, #0
    555c:	4914      	ldr	r1, [pc, #80]	; (55b0 <_dtoa_r+0x620>)
    555e:	f006 f959 	bl	b814 <__aeabi_dsub>
    5562:	4602      	mov	r2, r0
    5564:	460b      	mov	r3, r1
    5566:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    556a:	f00f feb5 	bl	152d8 <__aeabi_dcmplt>
    556e:	2800      	cmp	r0, #0
    5570:	f43f af31 	beq.w	53d6 <_dtoa_r+0x446>
    5574:	f815 3c01 	ldrb.w	r3, [r5, #-1]
    5578:	2b30      	cmp	r3, #48	; 0x30
    557a:	f105 32ff 	add.w	r2, r5, #4294967295
    557e:	d002      	beq.n	5586 <_dtoa_r+0x5f6>
    5580:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
    5584:	e04a      	b.n	561c <_dtoa_r+0x68c>
    5586:	4615      	mov	r5, r2
    5588:	e7f4      	b.n	5574 <_dtoa_r+0x5e4>
    558a:	4b06      	ldr	r3, [pc, #24]	; (55a4 <_dtoa_r+0x614>)
    558c:	f004 fd9e 	bl	a0cc <__aeabi_dmul>
    5590:	e9cd 0104 	strd	r0, r1, [sp, #16]
    5594:	e7bc      	b.n	5510 <_dtoa_r+0x580>
    5596:	bf00      	nop
    5598:	00017818 	.word	0x00017818
    559c:	00022330 	.word	0x00022330
    55a0:	3ff00000 	.word	0x3ff00000
    55a4:	40240000 	.word	0x40240000
    55a8:	401c0000 	.word	0x401c0000
    55ac:	40140000 	.word	0x40140000
    55b0:	3fe00000 	.word	0x3fe00000
    55b4:	e9dd 6704 	ldrd	r6, r7, [sp, #16]
    55b8:	9d01      	ldr	r5, [sp, #4]
    55ba:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    55be:	4630      	mov	r0, r6
    55c0:	4639      	mov	r1, r7
    55c2:	f004 fead 	bl	a320 <__aeabi_ddiv>
    55c6:	f018 fff9 	bl	1e5bc <__aeabi_d2iz>
    55ca:	4604      	mov	r4, r0
    55cc:	f006 fa70 	bl	bab0 <__aeabi_i2d>
    55d0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    55d4:	f004 fd7a 	bl	a0cc <__aeabi_dmul>
    55d8:	4602      	mov	r2, r0
    55da:	460b      	mov	r3, r1
    55dc:	4630      	mov	r0, r6
    55de:	4639      	mov	r1, r7
    55e0:	f104 0630 	add.w	r6, r4, #48	; 0x30
    55e4:	f006 f916 	bl	b814 <__aeabi_dsub>
    55e8:	f805 6b01 	strb.w	r6, [r5], #1
    55ec:	9e01      	ldr	r6, [sp, #4]
    55ee:	1bae      	subs	r6, r5, r6
    55f0:	45b1      	cmp	r9, r6
    55f2:	4602      	mov	r2, r0
    55f4:	460b      	mov	r3, r1
    55f6:	d138      	bne.n	566a <_dtoa_r+0x6da>
    55f8:	f006 f90e 	bl	b818 <__adddf3>
    55fc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    5600:	4606      	mov	r6, r0
    5602:	460f      	mov	r7, r1
    5604:	f00f fe86 	bl	15314 <__aeabi_dcmpgt>
    5608:	b9c0      	cbnz	r0, 563c <_dtoa_r+0x6ac>
    560a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    560e:	4630      	mov	r0, r6
    5610:	4639      	mov	r1, r7
    5612:	f00f fe57 	bl	152c4 <__aeabi_dcmpeq>
    5616:	b108      	cbz	r0, 561c <_dtoa_r+0x68c>
    5618:	07e1      	lsls	r1, r4, #31
    561a:	d40f      	bmi.n	563c <_dtoa_r+0x6ac>
    561c:	4641      	mov	r1, r8
    561e:	4658      	mov	r0, fp
    5620:	f01c f94d 	bl	218be <_Bfree>
    5624:	2300      	movs	r3, #0
    5626:	9a14      	ldr	r2, [sp, #80]	; 0x50
    5628:	702b      	strb	r3, [r5, #0]
    562a:	f10a 0301 	add.w	r3, sl, #1
    562e:	6013      	str	r3, [r2, #0]
    5630:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    5632:	2b00      	cmp	r3, #0
    5634:	f43f acf4 	beq.w	5020 <_dtoa_r+0x90>
    5638:	601d      	str	r5, [r3, #0]
    563a:	e4f1      	b.n	5020 <_dtoa_r+0x90>
    563c:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
    5640:	f815 2c01 	ldrb.w	r2, [r5, #-1]
    5644:	2a39      	cmp	r2, #57	; 0x39
    5646:	f105 33ff 	add.w	r3, r5, #4294967295
    564a:	d108      	bne.n	565e <_dtoa_r+0x6ce>
    564c:	9a01      	ldr	r2, [sp, #4]
    564e:	429a      	cmp	r2, r3
    5650:	d109      	bne.n	5666 <_dtoa_r+0x6d6>
    5652:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    5654:	9901      	ldr	r1, [sp, #4]
    5656:	3201      	adds	r2, #1
    5658:	920a      	str	r2, [sp, #40]	; 0x28
    565a:	2230      	movs	r2, #48	; 0x30
    565c:	700a      	strb	r2, [r1, #0]
    565e:	781a      	ldrb	r2, [r3, #0]
    5660:	3201      	adds	r2, #1
    5662:	701a      	strb	r2, [r3, #0]
    5664:	e78c      	b.n	5580 <_dtoa_r+0x5f0>
    5666:	461d      	mov	r5, r3
    5668:	e7ea      	b.n	5640 <_dtoa_r+0x6b0>
    566a:	2200      	movs	r2, #0
    566c:	4b9b      	ldr	r3, [pc, #620]	; (58dc <_dtoa_r+0x94c>)
    566e:	f004 fd2d 	bl	a0cc <__aeabi_dmul>
    5672:	2200      	movs	r2, #0
    5674:	2300      	movs	r3, #0
    5676:	4606      	mov	r6, r0
    5678:	460f      	mov	r7, r1
    567a:	f00f fe23 	bl	152c4 <__aeabi_dcmpeq>
    567e:	2800      	cmp	r0, #0
    5680:	d09b      	beq.n	55ba <_dtoa_r+0x62a>
    5682:	e7cb      	b.n	561c <_dtoa_r+0x68c>
    5684:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    5686:	2a00      	cmp	r2, #0
    5688:	f000 80cb 	beq.w	5822 <_dtoa_r+0x892>
    568c:	9a08      	ldr	r2, [sp, #32]
    568e:	2a01      	cmp	r2, #1
    5690:	f300 80ae 	bgt.w	57f0 <_dtoa_r+0x860>
    5694:	9a15      	ldr	r2, [sp, #84]	; 0x54
    5696:	2a00      	cmp	r2, #0
    5698:	f000 80a6 	beq.w	57e8 <_dtoa_r+0x858>
    569c:	f203 4333 	addw	r3, r3, #1075	; 0x433
    56a0:	9c09      	ldr	r4, [sp, #36]	; 0x24
    56a2:	9d06      	ldr	r5, [sp, #24]
    56a4:	9a06      	ldr	r2, [sp, #24]
    56a6:	441a      	add	r2, r3
    56a8:	9206      	str	r2, [sp, #24]
    56aa:	9a07      	ldr	r2, [sp, #28]
    56ac:	2101      	movs	r1, #1
    56ae:	441a      	add	r2, r3
    56b0:	4658      	mov	r0, fp
    56b2:	9207      	str	r2, [sp, #28]
    56b4:	f01e fb19 	bl	23cea <__i2b>
    56b8:	4606      	mov	r6, r0
    56ba:	2d00      	cmp	r5, #0
    56bc:	dd0c      	ble.n	56d8 <_dtoa_r+0x748>
    56be:	9b07      	ldr	r3, [sp, #28]
    56c0:	2b00      	cmp	r3, #0
    56c2:	dd09      	ble.n	56d8 <_dtoa_r+0x748>
    56c4:	42ab      	cmp	r3, r5
    56c6:	9a06      	ldr	r2, [sp, #24]
    56c8:	bfa8      	it	ge
    56ca:	462b      	movge	r3, r5
    56cc:	1ad2      	subs	r2, r2, r3
    56ce:	9206      	str	r2, [sp, #24]
    56d0:	9a07      	ldr	r2, [sp, #28]
    56d2:	1aed      	subs	r5, r5, r3
    56d4:	1ad3      	subs	r3, r2, r3
    56d6:	9307      	str	r3, [sp, #28]
    56d8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    56da:	b1f3      	cbz	r3, 571a <_dtoa_r+0x78a>
    56dc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    56de:	2b00      	cmp	r3, #0
    56e0:	f000 80a3 	beq.w	582a <_dtoa_r+0x89a>
    56e4:	2c00      	cmp	r4, #0
    56e6:	dd10      	ble.n	570a <_dtoa_r+0x77a>
    56e8:	4631      	mov	r1, r6
    56ea:	4622      	mov	r2, r4
    56ec:	4658      	mov	r0, fp
    56ee:	f014 f94f 	bl	19990 <__pow5mult>
    56f2:	4642      	mov	r2, r8
    56f4:	4601      	mov	r1, r0
    56f6:	4606      	mov	r6, r0
    56f8:	4658      	mov	r0, fp
    56fa:	f00e fb69 	bl	13dd0 <__multiply>
    56fe:	4641      	mov	r1, r8
    5700:	4607      	mov	r7, r0
    5702:	4658      	mov	r0, fp
    5704:	f01c f8db 	bl	218be <_Bfree>
    5708:	46b8      	mov	r8, r7
    570a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    570c:	1b1a      	subs	r2, r3, r4
    570e:	d004      	beq.n	571a <_dtoa_r+0x78a>
    5710:	4641      	mov	r1, r8
    5712:	4658      	mov	r0, fp
    5714:	f014 f93c 	bl	19990 <__pow5mult>
    5718:	4680      	mov	r8, r0
    571a:	2101      	movs	r1, #1
    571c:	4658      	mov	r0, fp
    571e:	f01e fae4 	bl	23cea <__i2b>
    5722:	9b10      	ldr	r3, [sp, #64]	; 0x40
    5724:	2b00      	cmp	r3, #0
    5726:	4604      	mov	r4, r0
    5728:	f340 8081 	ble.w	582e <_dtoa_r+0x89e>
    572c:	461a      	mov	r2, r3
    572e:	4601      	mov	r1, r0
    5730:	4658      	mov	r0, fp
    5732:	f014 f92d 	bl	19990 <__pow5mult>
    5736:	9b08      	ldr	r3, [sp, #32]
    5738:	2b01      	cmp	r3, #1
    573a:	4604      	mov	r4, r0
    573c:	dd7a      	ble.n	5834 <_dtoa_r+0x8a4>
    573e:	2700      	movs	r7, #0
    5740:	6923      	ldr	r3, [r4, #16]
    5742:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    5746:	6918      	ldr	r0, [r3, #16]
    5748:	f01a faec 	bl	1fd24 <__hi0bits>
    574c:	f1c0 0020 	rsb	r0, r0, #32
    5750:	9b07      	ldr	r3, [sp, #28]
    5752:	4418      	add	r0, r3
    5754:	f010 001f 	ands.w	r0, r0, #31
    5758:	f000 8088 	beq.w	586c <_dtoa_r+0x8dc>
    575c:	f1c0 0320 	rsb	r3, r0, #32
    5760:	2b04      	cmp	r3, #4
    5762:	f340 8081 	ble.w	5868 <_dtoa_r+0x8d8>
    5766:	f1c0 001c 	rsb	r0, r0, #28
    576a:	9b06      	ldr	r3, [sp, #24]
    576c:	4403      	add	r3, r0
    576e:	9306      	str	r3, [sp, #24]
    5770:	9b07      	ldr	r3, [sp, #28]
    5772:	4403      	add	r3, r0
    5774:	4405      	add	r5, r0
    5776:	9307      	str	r3, [sp, #28]
    5778:	9b06      	ldr	r3, [sp, #24]
    577a:	2b00      	cmp	r3, #0
    577c:	dd05      	ble.n	578a <_dtoa_r+0x7fa>
    577e:	4641      	mov	r1, r8
    5780:	461a      	mov	r2, r3
    5782:	4658      	mov	r0, fp
    5784:	f013 fca0 	bl	190c8 <__lshift>
    5788:	4680      	mov	r8, r0
    578a:	9b07      	ldr	r3, [sp, #28]
    578c:	2b00      	cmp	r3, #0
    578e:	dd05      	ble.n	579c <_dtoa_r+0x80c>
    5790:	4621      	mov	r1, r4
    5792:	461a      	mov	r2, r3
    5794:	4658      	mov	r0, fp
    5796:	f013 fc97 	bl	190c8 <__lshift>
    579a:	4604      	mov	r4, r0
    579c:	9b11      	ldr	r3, [sp, #68]	; 0x44
    579e:	2b00      	cmp	r3, #0
    57a0:	d066      	beq.n	5870 <_dtoa_r+0x8e0>
    57a2:	4621      	mov	r1, r4
    57a4:	4640      	mov	r0, r8
    57a6:	f01b fbc9 	bl	20f3c <__mcmp>
    57aa:	2800      	cmp	r0, #0
    57ac:	da60      	bge.n	5870 <_dtoa_r+0x8e0>
    57ae:	2300      	movs	r3, #0
    57b0:	4641      	mov	r1, r8
    57b2:	220a      	movs	r2, #10
    57b4:	4658      	mov	r0, fp
    57b6:	f015 fdac 	bl	1b312 <__multadd>
    57ba:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    57bc:	f10a 3aff 	add.w	sl, sl, #4294967295
    57c0:	4680      	mov	r8, r0
    57c2:	2b00      	cmp	r3, #0
    57c4:	f000 8179 	beq.w	5aba <_dtoa_r+0xb2a>
    57c8:	2300      	movs	r3, #0
    57ca:	4631      	mov	r1, r6
    57cc:	220a      	movs	r2, #10
    57ce:	4658      	mov	r0, fp
    57d0:	f015 fd9f 	bl	1b312 <__multadd>
    57d4:	9b02      	ldr	r3, [sp, #8]
    57d6:	2b00      	cmp	r3, #0
    57d8:	4606      	mov	r6, r0
    57da:	f300 8089 	bgt.w	58f0 <_dtoa_r+0x960>
    57de:	9b08      	ldr	r3, [sp, #32]
    57e0:	2b02      	cmp	r3, #2
    57e2:	f340 8085 	ble.w	58f0 <_dtoa_r+0x960>
    57e6:	e04b      	b.n	5880 <_dtoa_r+0x8f0>
    57e8:	9b16      	ldr	r3, [sp, #88]	; 0x58
    57ea:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
    57ee:	e757      	b.n	56a0 <_dtoa_r+0x710>
    57f0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    57f2:	f109 34ff 	add.w	r4, r9, #4294967295
    57f6:	42a3      	cmp	r3, r4
    57f8:	bfbf      	itttt	lt
    57fa:	9b09      	ldrlt	r3, [sp, #36]	; 0x24
    57fc:	9409      	strlt	r4, [sp, #36]	; 0x24
    57fe:	1ae2      	sublt	r2, r4, r3
    5800:	9b10      	ldrlt	r3, [sp, #64]	; 0x40
    5802:	bfbb      	ittet	lt
    5804:	189b      	addlt	r3, r3, r2
    5806:	9310      	strlt	r3, [sp, #64]	; 0x40
    5808:	1b1c      	subge	r4, r3, r4
    580a:	2400      	movlt	r4, #0
    580c:	f1b9 0f00 	cmp.w	r9, #0
    5810:	bfb5      	itete	lt
    5812:	9b06      	ldrlt	r3, [sp, #24]
    5814:	9d06      	ldrge	r5, [sp, #24]
    5816:	eba3 0509 	sublt.w	r5, r3, r9
    581a:	464b      	movge	r3, r9
    581c:	bfb8      	it	lt
    581e:	2300      	movlt	r3, #0
    5820:	e740      	b.n	56a4 <_dtoa_r+0x714>
    5822:	9c09      	ldr	r4, [sp, #36]	; 0x24
    5824:	9d06      	ldr	r5, [sp, #24]
    5826:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    5828:	e747      	b.n	56ba <_dtoa_r+0x72a>
    582a:	9a09      	ldr	r2, [sp, #36]	; 0x24
    582c:	e770      	b.n	5710 <_dtoa_r+0x780>
    582e:	9b08      	ldr	r3, [sp, #32]
    5830:	2b01      	cmp	r3, #1
    5832:	dc15      	bgt.n	5860 <_dtoa_r+0x8d0>
    5834:	9b04      	ldr	r3, [sp, #16]
    5836:	b99b      	cbnz	r3, 5860 <_dtoa_r+0x8d0>
    5838:	9b05      	ldr	r3, [sp, #20]
    583a:	f3c3 0213 	ubfx	r2, r3, #0, #20
    583e:	b98a      	cbnz	r2, 5864 <_dtoa_r+0x8d4>
    5840:	4f27      	ldr	r7, [pc, #156]	; (58e0 <_dtoa_r+0x950>)
    5842:	401f      	ands	r7, r3
    5844:	b137      	cbz	r7, 5854 <_dtoa_r+0x8c4>
    5846:	9b06      	ldr	r3, [sp, #24]
    5848:	3301      	adds	r3, #1
    584a:	9306      	str	r3, [sp, #24]
    584c:	9b07      	ldr	r3, [sp, #28]
    584e:	3301      	adds	r3, #1
    5850:	9307      	str	r3, [sp, #28]
    5852:	2701      	movs	r7, #1
    5854:	9b10      	ldr	r3, [sp, #64]	; 0x40
    5856:	2b00      	cmp	r3, #0
    5858:	f47f af72 	bne.w	5740 <_dtoa_r+0x7b0>
    585c:	2001      	movs	r0, #1
    585e:	e777      	b.n	5750 <_dtoa_r+0x7c0>
    5860:	2700      	movs	r7, #0
    5862:	e7f7      	b.n	5854 <_dtoa_r+0x8c4>
    5864:	9f04      	ldr	r7, [sp, #16]
    5866:	e7f5      	b.n	5854 <_dtoa_r+0x8c4>
    5868:	d086      	beq.n	5778 <_dtoa_r+0x7e8>
    586a:	4618      	mov	r0, r3
    586c:	301c      	adds	r0, #28
    586e:	e77c      	b.n	576a <_dtoa_r+0x7da>
    5870:	f1b9 0f00 	cmp.w	r9, #0
    5874:	dc36      	bgt.n	58e4 <_dtoa_r+0x954>
    5876:	9b08      	ldr	r3, [sp, #32]
    5878:	2b02      	cmp	r3, #2
    587a:	dd33      	ble.n	58e4 <_dtoa_r+0x954>
    587c:	f8cd 9008 	str.w	r9, [sp, #8]
    5880:	9b02      	ldr	r3, [sp, #8]
    5882:	b963      	cbnz	r3, 589e <_dtoa_r+0x90e>
    5884:	4621      	mov	r1, r4
    5886:	2205      	movs	r2, #5
    5888:	4658      	mov	r0, fp
    588a:	f015 fd42 	bl	1b312 <__multadd>
    588e:	4601      	mov	r1, r0
    5890:	4604      	mov	r4, r0
    5892:	4640      	mov	r0, r8
    5894:	f01b fb52 	bl	20f3c <__mcmp>
    5898:	2800      	cmp	r0, #0
    589a:	f73f adc8 	bgt.w	542e <_dtoa_r+0x49e>
    589e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    58a0:	9d01      	ldr	r5, [sp, #4]
    58a2:	ea6f 0a03 	mvn.w	sl, r3
    58a6:	2700      	movs	r7, #0
    58a8:	4621      	mov	r1, r4
    58aa:	4658      	mov	r0, fp
    58ac:	f01c f807 	bl	218be <_Bfree>
    58b0:	2e00      	cmp	r6, #0
    58b2:	f43f aeb3 	beq.w	561c <_dtoa_r+0x68c>
    58b6:	b12f      	cbz	r7, 58c4 <_dtoa_r+0x934>
    58b8:	42b7      	cmp	r7, r6
    58ba:	d003      	beq.n	58c4 <_dtoa_r+0x934>
    58bc:	4639      	mov	r1, r7
    58be:	4658      	mov	r0, fp
    58c0:	f01b fffd 	bl	218be <_Bfree>
    58c4:	4631      	mov	r1, r6
    58c6:	4658      	mov	r0, fp
    58c8:	f01b fff9 	bl	218be <_Bfree>
    58cc:	e6a6      	b.n	561c <_dtoa_r+0x68c>
    58ce:	2400      	movs	r4, #0
    58d0:	4626      	mov	r6, r4
    58d2:	e7e4      	b.n	589e <_dtoa_r+0x90e>
    58d4:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
    58d8:	4626      	mov	r6, r4
    58da:	e5a8      	b.n	542e <_dtoa_r+0x49e>
    58dc:	40240000 	.word	0x40240000
    58e0:	7ff00000 	.word	0x7ff00000
    58e4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    58e6:	f8cd 9008 	str.w	r9, [sp, #8]
    58ea:	2b00      	cmp	r3, #0
    58ec:	f000 80ec 	beq.w	5ac8 <_dtoa_r+0xb38>
    58f0:	2d00      	cmp	r5, #0
    58f2:	dd05      	ble.n	5900 <_dtoa_r+0x970>
    58f4:	4631      	mov	r1, r6
    58f6:	462a      	mov	r2, r5
    58f8:	4658      	mov	r0, fp
    58fa:	f013 fbe5 	bl	190c8 <__lshift>
    58fe:	4606      	mov	r6, r0
    5900:	2f00      	cmp	r7, #0
    5902:	d056      	beq.n	59b2 <_dtoa_r+0xa22>
    5904:	6871      	ldr	r1, [r6, #4]
    5906:	4658      	mov	r0, fp
    5908:	f017 f940 	bl	1cb8c <_Balloc>
    590c:	6932      	ldr	r2, [r6, #16]
    590e:	3202      	adds	r2, #2
    5910:	4605      	mov	r5, r0
    5912:	0092      	lsls	r2, r2, #2
    5914:	f106 010c 	add.w	r1, r6, #12
    5918:	300c      	adds	r0, #12
    591a:	f01d fce7 	bl	232ec <memcpy>
    591e:	2201      	movs	r2, #1
    5920:	4629      	mov	r1, r5
    5922:	4658      	mov	r0, fp
    5924:	f013 fbd0 	bl	190c8 <__lshift>
    5928:	9b01      	ldr	r3, [sp, #4]
    592a:	f103 0901 	add.w	r9, r3, #1
    592e:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
    5932:	4413      	add	r3, r2
    5934:	9309      	str	r3, [sp, #36]	; 0x24
    5936:	9b04      	ldr	r3, [sp, #16]
    5938:	f003 0301 	and.w	r3, r3, #1
    593c:	4637      	mov	r7, r6
    593e:	9307      	str	r3, [sp, #28]
    5940:	4606      	mov	r6, r0
    5942:	f109 33ff 	add.w	r3, r9, #4294967295
    5946:	4621      	mov	r1, r4
    5948:	4640      	mov	r0, r8
    594a:	9302      	str	r3, [sp, #8]
    594c:	f00e fad8 	bl	13f00 <quorem>
    5950:	4603      	mov	r3, r0
    5952:	3330      	adds	r3, #48	; 0x30
    5954:	9004      	str	r0, [sp, #16]
    5956:	4639      	mov	r1, r7
    5958:	4640      	mov	r0, r8
    595a:	930a      	str	r3, [sp, #40]	; 0x28
    595c:	f01b faee 	bl	20f3c <__mcmp>
    5960:	4632      	mov	r2, r6
    5962:	9006      	str	r0, [sp, #24]
    5964:	4621      	mov	r1, r4
    5966:	4658      	mov	r0, fp
    5968:	f011 fef0 	bl	1774c <__mdiff>
    596c:	68c2      	ldr	r2, [r0, #12]
    596e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    5970:	4605      	mov	r5, r0
    5972:	bb02      	cbnz	r2, 59b6 <_dtoa_r+0xa26>
    5974:	4601      	mov	r1, r0
    5976:	4640      	mov	r0, r8
    5978:	f01b fae0 	bl	20f3c <__mcmp>
    597c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    597e:	4602      	mov	r2, r0
    5980:	4629      	mov	r1, r5
    5982:	4658      	mov	r0, fp
    5984:	920c      	str	r2, [sp, #48]	; 0x30
    5986:	930a      	str	r3, [sp, #40]	; 0x28
    5988:	f01b ff99 	bl	218be <_Bfree>
    598c:	9b08      	ldr	r3, [sp, #32]
    598e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    5990:	ea43 0102 	orr.w	r1, r3, r2
    5994:	9b07      	ldr	r3, [sp, #28]
    5996:	430b      	orrs	r3, r1
    5998:	464d      	mov	r5, r9
    599a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    599c:	d10d      	bne.n	59ba <_dtoa_r+0xa2a>
    599e:	2b39      	cmp	r3, #57	; 0x39
    59a0:	d027      	beq.n	59f2 <_dtoa_r+0xa62>
    59a2:	9a06      	ldr	r2, [sp, #24]
    59a4:	2a00      	cmp	r2, #0
    59a6:	dd01      	ble.n	59ac <_dtoa_r+0xa1c>
    59a8:	9b04      	ldr	r3, [sp, #16]
    59aa:	3331      	adds	r3, #49	; 0x31
    59ac:	9a02      	ldr	r2, [sp, #8]
    59ae:	7013      	strb	r3, [r2, #0]
    59b0:	e77a      	b.n	58a8 <_dtoa_r+0x918>
    59b2:	4630      	mov	r0, r6
    59b4:	e7b8      	b.n	5928 <_dtoa_r+0x998>
    59b6:	2201      	movs	r2, #1
    59b8:	e7e2      	b.n	5980 <_dtoa_r+0x9f0>
    59ba:	9906      	ldr	r1, [sp, #24]
    59bc:	2900      	cmp	r1, #0
    59be:	db04      	blt.n	59ca <_dtoa_r+0xa3a>
    59c0:	9808      	ldr	r0, [sp, #32]
    59c2:	4301      	orrs	r1, r0
    59c4:	9807      	ldr	r0, [sp, #28]
    59c6:	4301      	orrs	r1, r0
    59c8:	d11e      	bne.n	5a08 <_dtoa_r+0xa78>
    59ca:	2a00      	cmp	r2, #0
    59cc:	ddee      	ble.n	59ac <_dtoa_r+0xa1c>
    59ce:	4641      	mov	r1, r8
    59d0:	2201      	movs	r2, #1
    59d2:	4658      	mov	r0, fp
    59d4:	9306      	str	r3, [sp, #24]
    59d6:	f013 fb77 	bl	190c8 <__lshift>
    59da:	4621      	mov	r1, r4
    59dc:	4680      	mov	r8, r0
    59de:	f01b faad 	bl	20f3c <__mcmp>
    59e2:	2800      	cmp	r0, #0
    59e4:	9b06      	ldr	r3, [sp, #24]
    59e6:	dc02      	bgt.n	59ee <_dtoa_r+0xa5e>
    59e8:	d1e0      	bne.n	59ac <_dtoa_r+0xa1c>
    59ea:	07da      	lsls	r2, r3, #31
    59ec:	d5de      	bpl.n	59ac <_dtoa_r+0xa1c>
    59ee:	2b39      	cmp	r3, #57	; 0x39
    59f0:	d1da      	bne.n	59a8 <_dtoa_r+0xa18>
    59f2:	9a02      	ldr	r2, [sp, #8]
    59f4:	2339      	movs	r3, #57	; 0x39
    59f6:	7013      	strb	r3, [r2, #0]
    59f8:	f815 3c01 	ldrb.w	r3, [r5, #-1]
    59fc:	2b39      	cmp	r3, #57	; 0x39
    59fe:	f105 32ff 	add.w	r2, r5, #4294967295
    5a02:	d046      	beq.n	5a92 <_dtoa_r+0xb02>
    5a04:	3301      	adds	r3, #1
    5a06:	e7d2      	b.n	59ae <_dtoa_r+0xa1e>
    5a08:	2a00      	cmp	r2, #0
    5a0a:	dd03      	ble.n	5a14 <_dtoa_r+0xa84>
    5a0c:	2b39      	cmp	r3, #57	; 0x39
    5a0e:	d0f0      	beq.n	59f2 <_dtoa_r+0xa62>
    5a10:	3301      	adds	r3, #1
    5a12:	e7cb      	b.n	59ac <_dtoa_r+0xa1c>
    5a14:	9a09      	ldr	r2, [sp, #36]	; 0x24
    5a16:	f809 3c01 	strb.w	r3, [r9, #-1]
    5a1a:	4591      	cmp	r9, r2
    5a1c:	d020      	beq.n	5a60 <_dtoa_r+0xad0>
    5a1e:	4641      	mov	r1, r8
    5a20:	2300      	movs	r3, #0
    5a22:	220a      	movs	r2, #10
    5a24:	4658      	mov	r0, fp
    5a26:	f015 fc74 	bl	1b312 <__multadd>
    5a2a:	42b7      	cmp	r7, r6
    5a2c:	4680      	mov	r8, r0
    5a2e:	f04f 0300 	mov.w	r3, #0
    5a32:	f04f 020a 	mov.w	r2, #10
    5a36:	4639      	mov	r1, r7
    5a38:	4658      	mov	r0, fp
    5a3a:	d106      	bne.n	5a4a <_dtoa_r+0xaba>
    5a3c:	f015 fc69 	bl	1b312 <__multadd>
    5a40:	4607      	mov	r7, r0
    5a42:	4606      	mov	r6, r0
    5a44:	f109 0901 	add.w	r9, r9, #1
    5a48:	e77b      	b.n	5942 <_dtoa_r+0x9b2>
    5a4a:	f015 fc62 	bl	1b312 <__multadd>
    5a4e:	2300      	movs	r3, #0
    5a50:	4607      	mov	r7, r0
    5a52:	220a      	movs	r2, #10
    5a54:	4631      	mov	r1, r6
    5a56:	4658      	mov	r0, fp
    5a58:	f015 fc5b 	bl	1b312 <__multadd>
    5a5c:	e7f1      	b.n	5a42 <_dtoa_r+0xab2>
    5a5e:	2700      	movs	r7, #0
    5a60:	4641      	mov	r1, r8
    5a62:	2201      	movs	r2, #1
    5a64:	4658      	mov	r0, fp
    5a66:	9302      	str	r3, [sp, #8]
    5a68:	f013 fb2e 	bl	190c8 <__lshift>
    5a6c:	4621      	mov	r1, r4
    5a6e:	4680      	mov	r8, r0
    5a70:	f01b fa64 	bl	20f3c <__mcmp>
    5a74:	2800      	cmp	r0, #0
    5a76:	dcbf      	bgt.n	59f8 <_dtoa_r+0xa68>
    5a78:	d102      	bne.n	5a80 <_dtoa_r+0xaf0>
    5a7a:	9b02      	ldr	r3, [sp, #8]
    5a7c:	07db      	lsls	r3, r3, #31
    5a7e:	d4bb      	bmi.n	59f8 <_dtoa_r+0xa68>
    5a80:	f815 3c01 	ldrb.w	r3, [r5, #-1]
    5a84:	2b30      	cmp	r3, #48	; 0x30
    5a86:	f105 32ff 	add.w	r2, r5, #4294967295
    5a8a:	f47f af0d 	bne.w	58a8 <_dtoa_r+0x918>
    5a8e:	4615      	mov	r5, r2
    5a90:	e7f6      	b.n	5a80 <_dtoa_r+0xaf0>
    5a92:	9b01      	ldr	r3, [sp, #4]
    5a94:	4293      	cmp	r3, r2
    5a96:	d104      	bne.n	5aa2 <_dtoa_r+0xb12>
    5a98:	f10a 0a01 	add.w	sl, sl, #1
    5a9c:	2331      	movs	r3, #49	; 0x31
    5a9e:	9a01      	ldr	r2, [sp, #4]
    5aa0:	e785      	b.n	59ae <_dtoa_r+0xa1e>
    5aa2:	4615      	mov	r5, r2
    5aa4:	e7a8      	b.n	59f8 <_dtoa_r+0xa68>
    5aa6:	4b13      	ldr	r3, [pc, #76]	; (5af4 <_dtoa_r+0xb64>)
    5aa8:	f7ff bad9 	b.w	505e <_dtoa_r+0xce>
    5aac:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    5aae:	2b00      	cmp	r3, #0
    5ab0:	f47f aab1 	bne.w	5016 <_dtoa_r+0x86>
    5ab4:	4b10      	ldr	r3, [pc, #64]	; (5af8 <_dtoa_r+0xb68>)
    5ab6:	f7ff bad2 	b.w	505e <_dtoa_r+0xce>
    5aba:	9b02      	ldr	r3, [sp, #8]
    5abc:	2b00      	cmp	r3, #0
    5abe:	dc03      	bgt.n	5ac8 <_dtoa_r+0xb38>
    5ac0:	9b08      	ldr	r3, [sp, #32]
    5ac2:	2b02      	cmp	r3, #2
    5ac4:	f73f aedc 	bgt.w	5880 <_dtoa_r+0x8f0>
    5ac8:	9d01      	ldr	r5, [sp, #4]
    5aca:	4621      	mov	r1, r4
    5acc:	4640      	mov	r0, r8
    5ace:	f00e fa17 	bl	13f00 <quorem>
    5ad2:	f100 0330 	add.w	r3, r0, #48	; 0x30
    5ad6:	f805 3b01 	strb.w	r3, [r5], #1
    5ada:	9a01      	ldr	r2, [sp, #4]
    5adc:	9902      	ldr	r1, [sp, #8]
    5ade:	1aaa      	subs	r2, r5, r2
    5ae0:	4291      	cmp	r1, r2
    5ae2:	ddbc      	ble.n	5a5e <_dtoa_r+0xace>
    5ae4:	4641      	mov	r1, r8
    5ae6:	2300      	movs	r3, #0
    5ae8:	220a      	movs	r2, #10
    5aea:	4658      	mov	r0, fp
    5aec:	f015 fc11 	bl	1b312 <__multadd>
    5af0:	4680      	mov	r8, r0
    5af2:	e7ea      	b.n	5aca <_dtoa_r+0xb3a>
    5af4:	00023efd 	.word	0x00023efd
    5af8:	00023ef0 	.word	0x00023ef0

Disassembly of section .rodata%217:

00005afc <.rodata%217>:
    5afc:	67617355 	.word	0x67617355
    5b00:	69203a65 	.word	0x69203a65
    5b04:	66726570 	.word	0x66726570
    5b08:	2d3c2073 	.word	0x2d3c2073
    5b0c:	73207874 	.word	0x73207874
    5b10:	3e657a69 	.word	0x3e657a69
    5b14:	722d3c20 	.word	0x722d3c20
    5b18:	69732078 	.word	0x69732078
    5b1c:	203e657a 	.word	0x203e657a
    5b20:	20692d3c 	.word	0x20692d3c
    5b24:	65646e69 	.word	0x65646e69
    5b28:	0a0d3e78 	.word	0x0a0d3e78
    5b2c:	00000000 	.word	0x00000000
    5b30:	0078742d 	.word	0x0078742d
    5b34:	0078722d 	.word	0x0078722d
    5b38:	0000692d 	.word	0x0000692d
    5b3c:	6e692d2d 	.word	0x6e692d2d
    5b40:	00786564 	.word	0x00786564
    5b44:	72657069 	.word	0x72657069
    5b48:	203a6966 	.word	0x203a6966
    5b4c:	6e6b6e55 	.word	0x6e6b6e55
    5b50:	206e776f 	.word	0x206e776f
    5b54:	61726170 	.word	0x61726170
    5b58:	6574656d 	.word	0x6574656d
    5b5c:	000a0d72 	.word	0x000a0d72
    5b60:	70690a0d 	.word	0x70690a0d
    5b64:	3a667265 	.word	0x3a667265
    5b68:	766e4920 	.word	0x766e4920
    5b6c:	64696c61 	.word	0x64696c61
    5b70:	73657320 	.word	0x73657320
    5b74:	6e6f6973 	.word	0x6e6f6973
    5b78:	6d756e20 	.word	0x6d756e20
    5b7c:	2e726562 	.word	0x2e726562
    5b80:	6e694d20 	.word	0x6e694d20
    5b84:	2c30203a 	.word	0x2c30203a
    5b88:	78614d20 	.word	0x78614d20
    5b8c:	6425203a 	.word	0x6425203a
    5b90:	00000a0d 	.word	0x00000a0d
    5b94:	72657069 	.word	0x72657069
    5b98:	203a7366 	.word	0x203a7366
    5b9c:	203c2030 	.word	0x203c2030
    5ba0:	657a6973 	.word	0x657a6973
    5ba4:	36203c20 	.word	0x36203c20
    5ba8:	36333535 	.word	0x36333535
    5bac:	00000a0d 	.word	0x00000a0d
    5bb0:	72657069 	.word	0x72657069
    5bb4:	203a7366 	.word	0x203a7366
    5bb8:	202c4b4f 	.word	0x202c4b4f
    5bbc:	20746573 	.word	0x20746573
    5bc0:	74736e69 	.word	0x74736e69
    5bc4:	65636e61 	.word	0x65636e61
    5bc8:	20642520 	.word	0x20642520
    5bcc:	73207872 	.word	0x73207872
    5bd0:	20657a69 	.word	0x20657a69
    5bd4:	25206f74 	.word	0x25206f74
    5bd8:	000a0d64 	.word	0x000a0d64
    5bdc:	72657069 	.word	0x72657069
    5be0:	203a7366 	.word	0x203a7366
    5be4:	202c4b4f 	.word	0x202c4b4f
    5be8:	20746573 	.word	0x20746573
    5bec:	74736e69 	.word	0x74736e69
    5bf0:	65636e61 	.word	0x65636e61
    5bf4:	20642520 	.word	0x20642520
    5bf8:	73207874 	.word	0x73207874
    5bfc:	20657a69 	.word	0x20657a69
    5c00:	25206f74 	.word	0x25206f74
    5c04:	000a0d64 	.word	0x000a0d64
    5c08:	72657069 	.word	0x72657069
    5c0c:	203a6b66 	.word	0x203a6b66
    5c10:	6e697355 	.word	0x6e697355
    5c14:	6e692067 	.word	0x6e692067
    5c18:	20786564 	.word	0x20786564
    5c1c:	000a0d30 	.word	0x000a0d30
    5c20:	70690a0d 	.word	0x70690a0d
    5c24:	20667265 	.word	0x20667265
    5c28:	73736573 	.word	0x73736573
    5c2c:	3a6e6f69 	.word	0x3a6e6f69
    5c30:	746f6e20 	.word	0x746f6e20
    5c34:	61747320 	.word	0x61747320
    5c38:	64657472 	.word	0x64657472
    5c3c:	000a0d21 	.word	0x000a0d21
    5c40:	70690a0d 	.word	0x70690a0d
    5c44:	3a667265 	.word	0x3a667265
    5c48:	79727420 	.word	0x79727420
    5c4c:	20676e69 	.word	0x20676e69
    5c50:	73206f74 	.word	0x73206f74
    5c54:	20706f74 	.word	0x20706f74
    5c58:	72657069 	.word	0x72657069
    5c5c:	6e692066 	.word	0x6e692066
    5c60:	6e617473 	.word	0x6e617473
    5c64:	25206563 	.word	0x25206563
    5c68:	2e2e2e64 	.word	0x2e2e2e64
    5c6c:	00000a0d 	.word	0x00000a0d
    5c70:	67617355 	.word	0x67617355
    5c74:	69203a65 	.word	0x69203a65
    5c78:	66726570 	.word	0x66726570
    5c7c:	2d3c206b 	.word	0x2d3c206b
    5c80:	6e692069 	.word	0x6e692069
    5c84:	3e786564 	.word	0x3e786564
    5c88:	00000a0d 	.word	0x00000a0d
    5c8c:	0000612d 	.word	0x0000612d
    5c90:	72657069 	.word	0x72657069
    5c94:	203a6966 	.word	0x203a6966
    5c98:	20657375 	.word	0x20657375
    5c9c:	61762061 	.word	0x61762061
    5ca0:	2064696c 	.word	0x2064696c
    5ca4:	61205049 	.word	0x61205049
    5ca8:	65726464 	.word	0x65726464
    5cac:	0d217373 	.word	0x0d217373
    5cb0:	0000000a 	.word	0x0000000a
    5cb4:	67617355 	.word	0x67617355
    5cb8:	69203a65 	.word	0x69203a65
    5cbc:	66726570 	.word	0x66726570
    5cc0:	612d2069 	.word	0x612d2069
    5cc4:	64646120 	.word	0x64646120
    5cc8:	73736572 	.word	0x73736572
    5ccc:	692d3c20 	.word	0x692d3c20
    5cd0:	646e6920 	.word	0x646e6920
    5cd4:	0d3e7865 	.word	0x0d3e7865
    5cd8:	0000000a 	.word	0x0000000a
    5cdc:	70690a0d 	.word	0x70690a0d
    5ce0:	69667265 	.word	0x69667265
    5ce4:	6163203a 	.word	0x6163203a
    5ce8:	746f6e6e 	.word	0x746f6e6e
    5cec:	61686320 	.word	0x61686320
    5cf0:	2065676e 	.word	0x2065676e
    5cf4:	20656874 	.word	0x20656874
    5cf8:	61207069 	.word	0x61207069
    5cfc:	65726464 	.word	0x65726464
    5d00:	77207373 	.word	0x77207373
    5d04:	656c6968 	.word	0x656c6968
    5d08:	73657320 	.word	0x73657320
    5d0c:	6e6f6973 	.word	0x6e6f6973
    5d10:	6425203a 	.word	0x6425203a
    5d14:	6e757220 	.word	0x6e757220
    5d18:	676e696e 	.word	0x676e696e
    5d1c:	000a0d21 	.word	0x000a0d21
    5d20:	72657069 	.word	0x72657069
    5d24:	203a6966 	.word	0x203a6966
    5d28:	202c4b4f 	.word	0x202c4b4f
    5d2c:	20746573 	.word	0x20746573
    5d30:	20656874 	.word	0x20656874
    5d34:	61205049 	.word	0x61205049
    5d38:	65726464 	.word	0x65726464
    5d3c:	74207373 	.word	0x74207373
    5d40:	6e69206f 	.word	0x6e69206f
    5d44:	6e617473 	.word	0x6e617473
    5d48:	203a6563 	.word	0x203a6563
    5d4c:	0a0d6425 	.word	0x0a0d6425
    5d50:	00000000 	.word	0x00000000
    5d54:	0000732d 	.word	0x0000732d
    5d58:	65732d2d 	.word	0x65732d2d
    5d5c:	72657672 	.word	0x72657672
    5d60:	00000000 	.word	0x00000000
    5d64:	0000752d 	.word	0x0000752d
    5d68:	64752d2d 	.word	0x64752d2d
    5d6c:	00000070 	.word	0x00000070
    5d70:	0000622d 	.word	0x0000622d
    5d74:	61622d2d 	.word	0x61622d2d
    5d78:	6977646e 	.word	0x6977646e
    5d7c:	00687464 	.word	0x00687464
    5d80:	0000004d 	.word	0x0000004d
    5d84:	0000004b 	.word	0x0000004b
    5d88:	7669470a 	.word	0x7669470a
    5d8c:	69206e65 	.word	0x69206e65
    5d90:	5742206e 	.word	0x5742206e
    5d94:	6c25203a 	.word	0x6c25203a
    5d98:	6c252b75 	.word	0x6c252b75
    5d9c:	6c253d75 	.word	0x6c253d75
    5da0:	00000075 	.word	0x00000075
    5da4:	0000782d 	.word	0x0000782d
    5da8:	6d782d2d 	.word	0x6d782d2d
    5dac:	61727469 	.word	0x61727469
    5db0:	00006574 	.word	0x00006574
    5db4:	0000632d 	.word	0x0000632d
    5db8:	6c632d2d 	.word	0x6c632d2d
    5dbc:	746e6569 	.word	0x746e6569
    5dc0:	00000000 	.word	0x00000000
    5dc4:	0000742d 	.word	0x0000742d
    5dc8:	69742d2d 	.word	0x69742d2d
    5dcc:	0000656d 	.word	0x0000656d
    5dd0:	00006e2d 	.word	0x00006e2d
    5dd4:	756e2d2d 	.word	0x756e2d2d
    5dd8:	0000006d 	.word	0x0000006d
    5ddc:	0000532d 	.word	0x0000532d
    5de0:	6f742d2d 	.word	0x6f742d2d
    5de4:	00000073 	.word	0x00000073
    5de8:	7669470a 	.word	0x7669470a
    5dec:	54206e65 	.word	0x54206e65
    5df0:	7620534f 	.word	0x7620534f
    5df4:	65756c61 	.word	0x65756c61
    5df8:	20736920 	.word	0x20736920
    5dfc:	202c6425 	.word	0x202c6425
    5e00:	7079546d 	.word	0x7079546d
    5e04:	53664f65 	.word	0x53664f65
    5e08:	69767265 	.word	0x69767265
    5e0c:	253a6563 	.word	0x253a6563
    5e10:	00000064 	.word	0x00000064
    5e14:	00004d2d 	.word	0x00004d2d
    5e18:	736d2d2d 	.word	0x736d2d2d
    5e1c:	00000073 	.word	0x00000073
    5e20:	6e692d2d 	.word	0x6e692d2d
    5e24:	76726574 	.word	0x76726574
    5e28:	00006c61 	.word	0x00006c61
    5e2c:	0000702d 	.word	0x0000702d
    5e30:	6f702d2d 	.word	0x6f702d2d
    5e34:	00007472 	.word	0x00007472
    5e38:	00006c2d 	.word	0x00006c2d
    5e3c:	656c2d2d 	.word	0x656c2d2d
    5e40:	0000006e 	.word	0x0000006e
    5e44:	72657069 	.word	0x72657069
    5e48:	54203a66 	.word	0x54203a66
    5e4c:	6d206568 	.word	0x6d206568
    5e50:	6d696e69 	.word	0x6d696e69
    5e54:	64206d75 	.word	0x64206d75
    5e58:	67617461 	.word	0x67617461
    5e5c:	206d6172 	.word	0x206d6172
    5e60:	657a6973 	.word	0x657a6973
    5e64:	20736920 	.word	0x20736920
    5e68:	0a0d6425 	.word	0x0a0d6425
    5e6c:	00000000 	.word	0x00000000
    5e70:	72657069 	.word	0x72657069
    5e74:	55203a66 	.word	0x55203a66
    5e78:	676e6973 	.word	0x676e6973
    5e7c:	65687420 	.word	0x65687420
    5e80:	66656420 	.word	0x66656420
    5e84:	746c7561 	.word	0x746c7561
    5e88:	746e6920 	.word	0x746e6920
    5e8c:	61667265 	.word	0x61667265
    5e90:	0d216563 	.word	0x0d216563
    5e94:	0000000a 	.word	0x0000000a
    5e98:	2d2d2d2d 	.word	0x2d2d2d2d
    5e9c:	2d2d2d2d 	.word	0x2d2d2d2d
    5ea0:	2d2d2d2d 	.word	0x2d2d2d2d
    5ea4:	2d2d2d2d 	.word	0x2d2d2d2d
    5ea8:	2d2d2d2d 	.word	0x2d2d2d2d
    5eac:	2d2d2d2d 	.word	0x2d2d2d2d
    5eb0:	2d2d2d2d 	.word	0x2d2d2d2d
    5eb4:	2d2d2d2d 	.word	0x2d2d2d2d
    5eb8:	2d2d2d2d 	.word	0x2d2d2d2d
    5ebc:	2d2d2d2d 	.word	0x2d2d2d2d
    5ec0:	2d2d2d2d 	.word	0x2d2d2d2d
    5ec4:	2d2d2d2d 	.word	0x2d2d2d2d
    5ec8:	2d2d2d2d 	.word	0x2d2d2d2d
    5ecc:	2d2d2d2d 	.word	0x2d2d2d2d
    5ed0:	000a0d2d 	.word	0x000a0d2d
    5ed4:	72657069 	.word	0x72657069
    5ed8:	53203a66 	.word	0x53203a66
    5edc:	65767265 	.word	0x65767265
    5ee0:	696c2072 	.word	0x696c2072
    5ee4:	6e657473 	.word	0x6e657473
    5ee8:	20676e69 	.word	0x20676e69
    5eec:	00206e6f 	.word	0x00206e6f
    5ef0:	00504455 	.word	0x00504455
    5ef4:	00504354 	.word	0x00504354
    5ef8:	726f7020 	.word	0x726f7020
    5efc:	64252074 	.word	0x64252074
    5f00:	00000a0d 	.word	0x00000a0d
    5f04:	70690a0d 	.word	0x70690a0d
    5f08:	3a667265 	.word	0x3a667265
    5f0c:	6c6c4120 	.word	0x6c6c4120
    5f10:	736e6920 	.word	0x736e6920
    5f14:	636e6174 	.word	0x636e6174
    5f18:	62207365 	.word	0x62207365
    5f1c:	2e797375 	.word	0x2e797375
    5f20:	74655220 	.word	0x74655220
    5f24:	6c207972 	.word	0x6c207972
    5f28:	72657461 	.word	0x72657461
    5f2c:	000a0d21 	.word	0x000a0d21
    5f30:	70690a0d 	.word	0x70690a0d
    5f34:	3a667265 	.word	0x3a667265
    5f38:	61745320 	.word	0x61745320
    5f3c:	6e697472 	.word	0x6e697472
    5f40:	65732067 	.word	0x65732067
    5f44:	6f697373 	.word	0x6f697373
    5f48:	6e69206e 	.word	0x6e69206e
    5f4c:	6e617473 	.word	0x6e617473
    5f50:	25206563 	.word	0x25206563
    5f54:	000a0d64 	.word	0x000a0d64
    5f58:	756c3425 	.word	0x756c3425
    5f5c:	70624b20 	.word	0x70624b20
    5f60:	00000073 	.word	0x00000073
    5f64:	20202020 	.word	0x20202020
    5f68:	255b202d 	.word	0x255b202d
    5f6c:	2d756c32 	.word	0x2d756c32
    5f70:	6c322520 	.word	0x6c322520
    5f74:	65732075 	.word	0x65732075
    5f78:	25205d63 	.word	0x25205d63
    5f7c:	2f756c33 	.word	0x2f756c33
    5f80:	6c332520 	.word	0x6c332520
    5f84:	25282075 	.word	0x25282075
    5f88:	25756c32 	.word	0x25756c32
    5f8c:	20202925 	.word	0x20202925
    5f90:	34252020 	.word	0x34252020
    5f94:	4b20756c 	.word	0x4b20756c
    5f98:	0d737062 	.word	0x0d737062
    5f9c:	0000000a 	.word	0x0000000a
    5fa0:	3a475641 	.word	0x3a475641
    5fa4:	6c342520 	.word	0x6c342520
    5fa8:	624b2075 	.word	0x624b2075
    5fac:	00007370 	.word	0x00007370
    5fb0:	72657069 	.word	0x72657069
    5fb4:	6f642066 	.word	0x6f642066
    5fb8:	0000656e 	.word	0x0000656e
    5fbc:	20202020 	.word	0x20202020
    5fc0:	305b202d 	.word	0x305b202d
    5fc4:	202d302e 	.word	0x202d302e
    5fc8:	2e756c25 	.word	0x2e756c25
    5fcc:	20756c25 	.word	0x20756c25
    5fd0:	5d636573 	.word	0x5d636573
    5fd4:	6c332520 	.word	0x6c332520
    5fd8:	25202f75 	.word	0x25202f75
    5fdc:	20756c33 	.word	0x20756c33
    5fe0:	6c322528 	.word	0x6c322528
    5fe4:	29252575 	.word	0x29252575
    5fe8:	20202020 	.word	0x20202020
    5fec:	756c3425 	.word	0x756c3425
    5ff0:	70624b20 	.word	0x70624b20
    5ff4:	000a0d73 	.word	0x000a0d73
    5ff8:	72657069 	.word	0x72657069
    5ffc:	69203a66 	.word	0x69203a66
    6000:	6174736e 	.word	0x6174736e
    6004:	2065636e 	.word	0x2065636e
    6008:	63206425 	.word	0x63206425
    600c:	6c706d6f 	.word	0x6c706d6f
    6010:	64657465 	.word	0x64657465
    6014:	00000d0a 	.word	0x00000d0a
    6018:	72657069 	.word	0x72657069
    601c:	53203a66 	.word	0x53203a66
    6020:	656b636f 	.word	0x656b636f
    6024:	65732074 	.word	0x65732074
    6028:	6620646e 	.word	0x6620646e
    602c:	656c6961 	.word	0x656c6961
    6030:	000a0d64 	.word	0x000a0d64
    6034:	70690a0d 	.word	0x70690a0d
    6038:	3a667265 	.word	0x3a667265
    603c:	736e6920 	.word	0x736e6920
    6040:	636e6174 	.word	0x636e6174
    6044:	64252065 	.word	0x64252065
    6048:	61747320 	.word	0x61747320
    604c:	64657472 	.word	0x64657472
    6050:	2e2e2e20 	.word	0x2e2e2e20
    6054:	00000a0d 	.word	0x00000a0d
    6058:	20202020 	.word	0x20202020
    605c:	6f4c202d 	.word	0x6f4c202d
    6060:	206c6163 	.word	0x206c6163
    6064:	2e752520 	.word	0x2e752520
    6068:	252e7525 	.word	0x252e7525
    606c:	75252e75 	.word	0x75252e75
    6070:	726f7020 	.word	0x726f7020
    6074:	75252074 	.word	0x75252074
    6078:	6e6f6320 	.word	0x6e6f6320
    607c:	7463656e 	.word	0x7463656e
    6080:	77206465 	.word	0x77206465
    6084:	0d687469 	.word	0x0d687469
    6088:	0000000a 	.word	0x0000000a
    608c:	20202020 	.word	0x20202020
    6090:	6552202d 	.word	0x6552202d
    6094:	65746f6d 	.word	0x65746f6d
    6098:	2e752520 	.word	0x2e752520
    609c:	252e7525 	.word	0x252e7525
    60a0:	75252e75 	.word	0x75252e75
    60a4:	726f7020 	.word	0x726f7020
    60a8:	75252074 	.word	0x75252074
    60ac:	00000a0d 	.word	0x00000a0d
    60b0:	20202020 	.word	0x20202020
    60b4:	6154202d 	.word	0x6154202d
    60b8:	74656772 	.word	0x74656772
    60bc:	74617220 	.word	0x74617220
    60c0:	203d2065 	.word	0x203d2065
    60c4:	20646c25 	.word	0x20646c25
    60c8:	2c737062 	.word	0x2c737062
    60cc:	72657020 	.word	0x72657020
    60d0:	20646f69 	.word	0x20646f69
    60d4:	6c25203d 	.word	0x6c25203d
    60d8:	736d2064 	.word	0x736d2064
    60dc:	00000a0d 	.word	0x00000a0d
    60e0:	20202020 	.word	0x20202020
    60e4:	2d2d2d2d 	.word	0x2d2d2d2d
    60e8:	2d2d2d2d 	.word	0x2d2d2d2d
    60ec:	2d2d2d2d 	.word	0x2d2d2d2d
    60f0:	2d2d2d2d 	.word	0x2d2d2d2d
    60f4:	2d2d2d2d 	.word	0x2d2d2d2d
    60f8:	2d2d2d2d 	.word	0x2d2d2d2d
    60fc:	2d2d2d2d 	.word	0x2d2d2d2d
    6100:	2d2d2d2d 	.word	0x2d2d2d2d
    6104:	2d2d2d2d 	.word	0x2d2d2d2d
    6108:	2d2d2d2d 	.word	0x2d2d2d2d
    610c:	000a0d2d 	.word	0x000a0d2d
    6110:	70690a0d 	.word	0x70690a0d
    6114:	3a667265 	.word	0x3a667265
    6118:	72615720 	.word	0x72615720
    611c:	676e696e 	.word	0x676e696e
    6120:	4354202c 	.word	0x4354202c
    6124:	65732050 	.word	0x65732050
    6128:	72657672 	.word	0x72657672
    612c:	73696420 	.word	0x73696420
    6130:	6e6e6f63 	.word	0x6e6e6f63
    6134:	20746365 	.word	0x20746365
    6138:	65746564 	.word	0x65746564
    613c:	64657463 	.word	0x64657463
    6140:	00000a0d 	.word	0x00000a0d
    6144:	72657069 	.word	0x72657069
    6148:	46203a66 	.word	0x46203a66
    614c:	656c6961 	.word	0x656c6961
    6150:	6f742064 	.word	0x6f742064
    6154:	74656720 	.word	0x74656720
    6158:	20642520 	.word	0x20642520
    615c:	65747962 	.word	0x65747962
    6160:	6f732073 	.word	0x6f732073
    6164:	74656b63 	.word	0x74656b63
    6168:	20585420 	.word	0x20585420
    616c:	63617073 	.word	0x63617073
    6170:	000a0d65 	.word	0x000a0d65
    6174:	72657069 	.word	0x72657069
    6178:	55203a66 	.word	0x55203a66
    617c:	7075736e 	.word	0x7075736e
    6180:	74726f70 	.word	0x74726f70
    6184:	43206465 	.word	0x43206465
    6188:	69666e6f 	.word	0x69666e6f
    618c:	61727567 	.word	0x61727567
    6190:	6e6f6974 	.word	0x6e6f6974
    6194:	00000a0d 	.word	0x00000a0d
    6198:	72657069 	.word	0x72657069
    619c:	43203a66 	.word	0x43203a66
    61a0:	74616572 	.word	0x74616572
    61a4:	43542065 	.word	0x43542065
    61a8:	6f732050 	.word	0x6f732050
    61ac:	74656b63 	.word	0x74656b63
    61b0:	69616620 	.word	0x69616620
    61b4:	0d64656c 	.word	0x0d64656c
    61b8:	0000000a 	.word	0x0000000a
    61bc:	72657069 	.word	0x72657069
    61c0:	53203a66 	.word	0x53203a66
    61c4:	6f207465 	.word	0x6f207465
    61c8:	58522066 	.word	0x58522066
    61cc:	66756220 	.word	0x66756220
    61d0:	20726566 	.word	0x20726566
    61d4:	657a6973 	.word	0x657a6973
    61d8:	69616620 	.word	0x69616620
    61dc:	0d64656c 	.word	0x0d64656c
    61e0:	0000000a 	.word	0x0000000a
    61e4:	72657069 	.word	0x72657069
    61e8:	43203a66 	.word	0x43203a66
    61ec:	74616572 	.word	0x74616572
    61f0:	44552065 	.word	0x44552065
    61f4:	6f732050 	.word	0x6f732050
    61f8:	74656b63 	.word	0x74656b63
    61fc:	69616620 	.word	0x69616620
    6200:	0d64656c 	.word	0x0d64656c
    6204:	0000000a 	.word	0x0000000a
    6208:	72657069 	.word	0x72657069
    620c:	50203a66 	.word	0x50203a66
    6210:	6f746f72 	.word	0x6f746f72
    6214:	206c6f63 	.word	0x206c6f63
    6218:	6f727265 	.word	0x6f727265
    621c:	000a0d72 	.word	0x000a0d72
    6220:	72657069 	.word	0x72657069
    6224:	55203a66 	.word	0x55203a66
    6228:	47205044 	.word	0x47205044
    622c:	41207465 	.word	0x41207465
    6230:	79617272 	.word	0x79617272
    6234:	69614620 	.word	0x69614620
    6238:	0d64656c 	.word	0x0d64656c
    623c:	0000000a 	.word	0x0000000a
    6240:	72657069 	.word	0x72657069
    6244:	2d203a66 	.word	0x2d203a66
    6248:	72694620 	.word	0x72694620
    624c:	70207473 	.word	0x70207473
    6250:	6920746b 	.word	0x6920746b
    6254:	203d2064 	.word	0x203d2064
    6258:	20646c25 	.word	0x20646c25
    625c:	6f687328 	.word	0x6f687328
    6260:	20646c75 	.word	0x20646c75
    6264:	30206562 	.word	0x30206562
    6268:	000a0d29 	.word	0x000a0d29
    626c:	72657069 	.word	0x72657069
    6270:	52203a66 	.word	0x52203a66
    6274:	20766365 	.word	0x20766365
    6278:	6c707564 	.word	0x6c707564
    627c:	74616369 	.word	0x74616369
    6280:	70206465 	.word	0x70206465
    6284:	0a0d746b 	.word	0x0a0d746b
    6288:	00000000 	.word	0x00000000
    628c:	72657069 	.word	0x72657069
    6290:	52203a66 	.word	0x52203a66
    6294:	69742078 	.word	0x69742078
    6298:	2064656d 	.word	0x2064656d
    629c:	0d74756f 	.word	0x0d74756f
    62a0:	0000000a 	.word	0x0000000a
    62a4:	70690a0d 	.word	0x70690a0d
    62a8:	3a667265 	.word	0x3a667265
    62ac:	736e6920 	.word	0x736e6920
    62b0:	636e6174 	.word	0x636e6174
    62b4:	64252065 	.word	0x64252065
    62b8:	73657320 	.word	0x73657320
    62bc:	6e6f6973 	.word	0x6e6f6973
    62c0:	61747320 	.word	0x61747320
    62c4:	64657472 	.word	0x64657472
    62c8:	2e2e2e20 	.word	0x2e2e2e20
    62cc:	00000a0d 	.word	0x00000a0d
    62d0:	70690a0d 	.word	0x70690a0d
    62d4:	20667265 	.word	0x20667265
    62d8:	74736e69 	.word	0x74736e69
    62dc:	65636e61 	.word	0x65636e61
    62e0:	3a642520 	.word	0x3a642520
    62e4:	20785220 	.word	0x20785220
    62e8:	656e6f64 	.word	0x656e6f64
    62ec:	6f53202e 	.word	0x6f53202e
    62f0:	74656b63 	.word	0x74656b63
    62f4:	6f6c6320 	.word	0x6f6c6320
    62f8:	2e646573 	.word	0x2e646573
    62fc:	00000a0d 	.word	0x00000a0d
    6300:	72657069 	.word	0x72657069
    6304:	6e692066 	.word	0x6e692066
    6308:	6e617473 	.word	0x6e617473
    630c:	25206563 	.word	0x25206563
    6310:	52203a64 	.word	0x52203a64
    6314:	79646165 	.word	0x79646165
    6318:	726f6620 	.word	0x726f6620
    631c:	65687420 	.word	0x65687420
    6320:	78656e20 	.word	0x78656e20
    6324:	65732074 	.word	0x65732074
    6328:	6f697373 	.word	0x6f697373
    632c:	0a0d2e6e 	.word	0x0a0d2e6e
    6330:	00000000 	.word	0x00000000
    6334:	72657069 	.word	0x72657069
    6338:	6e692066 	.word	0x6e692066
    633c:	6e617473 	.word	0x6e617473
    6340:	25206563 	.word	0x25206563
    6344:	63203a64 	.word	0x63203a64
    6348:	6c706d6f 	.word	0x6c706d6f
    634c:	64657465 	.word	0x64657465
    6350:	000a0d2e 	.word	0x000a0d2e
    6354:	72657069 	.word	0x72657069
    6358:	63203a66 	.word	0x63203a66
    635c:	6e65696c 	.word	0x6e65696c
    6360:	65732074 	.word	0x65732074
    6364:	6f697373 	.word	0x6f697373
    6368:	6c63206e 	.word	0x6c63206e
    636c:	6465736f 	.word	0x6465736f
    6370:	000a0d2e 	.word	0x000a0d2e
    6374:	72657069 	.word	0x72657069
    6378:	41203a66 	.word	0x41203a66
    637c:	75205052 	.word	0x75205052
    6380:	6c62616e 	.word	0x6c62616e
    6384:	6f742065 	.word	0x6f742065
    6388:	73657220 	.word	0x73657220
    638c:	65766c6f 	.word	0x65766c6f
    6390:	65687420 	.word	0x65687420
    6394:	43414d20 	.word	0x43414d20
    6398:	64646120 	.word	0x64646120
    639c:	73736572 	.word	0x73736572
    63a0:	20666f20 	.word	0x20666f20
    63a4:	6f6d6572 	.word	0x6f6d6572
    63a8:	73206574 	.word	0x73206574
    63ac:	2e656469 	.word	0x2e656469
    63b0:	00000a0d 	.word	0x00000a0d
    63b4:	20202020 	.word	0x20202020
    63b8:	6552202d 	.word	0x6552202d
    63bc:	65746f6d 	.word	0x65746f6d
    63c0:	65646f4e 	.word	0x65646f4e
    63c4:	43414d20 	.word	0x43414d20
    63c8:	7825203a 	.word	0x7825203a
    63cc:	20782520 	.word	0x20782520
    63d0:	25207825 	.word	0x25207825
    63d4:	78252078 	.word	0x78252078
    63d8:	0d782520 	.word	0x0d782520
    63dc:	0000000a 	.word	0x0000000a
    63e0:	72657069 	.word	0x72657069
    63e4:	53203a66 	.word	0x53203a66
    63e8:	6f207465 	.word	0x6f207465
    63ec:	58542066 	.word	0x58542066
    63f0:	66756220 	.word	0x66756220
    63f4:	20726566 	.word	0x20726566
    63f8:	657a6973 	.word	0x657a6973
    63fc:	69616620 	.word	0x69616620
    6400:	0d64656c 	.word	0x0d64656c
    6404:	0000000a 	.word	0x0000000a
    6408:	72657069 	.word	0x72657069
    640c:	53203a66 	.word	0x53203a66
    6410:	6f207465 	.word	0x6f207465
    6414:	58542066 	.word	0x58542066
    6418:	65757120 	.word	0x65757120
    641c:	676e6975 	.word	0x676e6975
    6420:	6d696c20 	.word	0x6d696c20
    6424:	66207469 	.word	0x66207469
    6428:	656c6961 	.word	0x656c6961
    642c:	000a0d64 	.word	0x000a0d64
    6430:	72657069 	.word	0x72657069
    6434:	43203a66 	.word	0x43203a66
    6438:	6e65696c 	.word	0x6e65696c
    643c:	6f632074 	.word	0x6f632074
    6440:	63656e6e 	.word	0x63656e6e
    6444:	676e6974 	.word	0x676e6974
    6448:	206f7420 	.word	0x206f7420
    644c:	252e7525 	.word	0x252e7525
    6450:	75252e75 	.word	0x75252e75
    6454:	2c75252e 	.word	0x2c75252e
    6458:	50445520 	.word	0x50445520
    645c:	726f7020 	.word	0x726f7020
    6460:	75252074 	.word	0x75252074
    6464:	00000a0d 	.word	0x00000a0d
    6468:	72657069 	.word	0x72657069
    646c:	43203a66 	.word	0x43203a66
    6470:	6e65696c 	.word	0x6e65696c
    6474:	6f632074 	.word	0x6f632074
    6478:	63656e6e 	.word	0x63656e6e
    647c:	676e6974 	.word	0x676e6974
    6480:	206f7420 	.word	0x206f7420
    6484:	252e7525 	.word	0x252e7525
    6488:	75252e75 	.word	0x75252e75
    648c:	2c75252e 	.word	0x2c75252e
    6490:	50435420 	.word	0x50435420
    6494:	726f7020 	.word	0x726f7020
    6498:	75252074 	.word	0x75252074
    649c:	00000a0d 	.word	0x00000a0d
    64a0:	72657069 	.word	0x72657069
    64a4:	54203a66 	.word	0x54203a66
    64a8:	43205043 	.word	0x43205043
    64ac:	6e65696c 	.word	0x6e65696c
    64b0:	6f632074 	.word	0x6f632074
    64b4:	63656e6e 	.word	0x63656e6e
    64b8:	6e6f6974 	.word	0x6e6f6974
    64bc:	6d697420 	.word	0x6d697420
    64c0:	74756f65 	.word	0x74756f65
    64c4:	00000a0d 	.word	0x00000a0d
    64c8:	7069203a 	.word	0x7069203a
    64cc:	20667265 	.word	0x20667265
    64d0:	6d6d6f63 	.word	0x6d6d6f63
    64d4:	73646e61 	.word	0x73646e61
    64d8:	00000000 	.word	0x00000000
    64dc:	72657069 	.word	0x72657069
    64e0:	00000066 	.word	0x00000066
    64e4:	3c20203a 	.word	0x3c20203a
    64e8:	72657069 	.word	0x72657069
    64ec:	73203e66 	.word	0x73203e66
    64f0:	74726174 	.word	0x74726174
    64f4:	646d6320 	.word	0x646d6320
    64f8:	00000000 	.word	0x00000000
    64fc:	72657069 	.word	0x72657069
    6500:	00006b66 	.word	0x00006b66
    6504:	693c203a 	.word	0x693c203a
    6508:	66726570 	.word	0x66726570
    650c:	6b203e6b 	.word	0x6b203e6b
    6510:	206c6c69 	.word	0x206c6c69
    6514:	00646d63 	.word	0x00646d63
    6518:	72657069 	.word	0x72657069
    651c:	00006966 	.word	0x00006966
    6520:	693c203a 	.word	0x693c203a
    6524:	66726570 	.word	0x66726570
    6528:	64612069 	.word	0x64612069
    652c:	73657264 	.word	0x73657264
    6530:	20203e73 	.word	0x20203e73
    6534:	65746e69 	.word	0x65746e69
    6538:	63616672 	.word	0x63616672
    653c:	6d632065 	.word	0x6d632065
    6540:	00000064 	.word	0x00000064
    6544:	72657069 	.word	0x72657069
    6548:	00007366 	.word	0x00007366
    654c:	693c203a 	.word	0x693c203a
    6550:	66726570 	.word	0x66726570
    6554:	78742073 	.word	0x78742073
    6558:	2078722f 	.word	0x2078722f
    655c:	657a6973 	.word	0x657a6973
    6560:	7874203e 	.word	0x7874203e
    6564:	2078722f 	.word	0x2078722f
    6568:	657a6973 	.word	0x657a6973
    656c:	646d6320 	.word	0x646d6320
    6570:	00          	.byte	0x00
    6571:	00          	.byte	0x00
    6572:	bf00      	nop

Disassembly of section .rodata.macPIC32CHwRegDcpt%218:

00006574 <macPIC32CHwRegDcpt>:
    6574:	7854 4220 7479 2065 6f43 6e75 2d74 6f6c     Tx Byte Count-lo
    6584:	6577 2072 3233 6962 7374 5428 4f78 4c54     wer 32bits(TxOTL
    6594:	294f 0000 3f99 0002 7854 4220 7479 2065     O)...?..Tx Byte 
    65a4:	6f43 6e75 2d74 7075 6570 2072 3631 6962     Count-upper 16bi
    65b4:	7374 5428 4f78 4854 2949 0000 3fa5 0002     ts(TxOTHI)...?..
    65c4:	7854 4620 6172 656d 2073 2f77 206f 7265     Tx Frames w/o er
    65d4:	6f72 2872 7854 5446 4e43 2954 0000 0000     ror(TxFTCNT)....
    65e4:	0000 0000 3fb1 0002 7854 4220 6f72 6461     .....?..Tx Broad
    65f4:	6163 7473 4620 6172 656d 2873 7854 4342     cast Frames(TxBC
    6604:	5446 0029 0000 0000 0000 0000 3fbd 0002     FT)..........?..
    6614:	7854 4d20 6c75 6974 6163 7473 4620 6172     Tx Multicast Fra
    6624:	656d 2873 7854 464d 2954 0000 0000 0000     mes(TxMFT)......
    6634:	0000 0000 3fc9 0002 7854 5020 7561 6573     .....?..Tx Pause
    6644:	4620 6172 656d 2873 7854 4650 2954 0000      Frames(TxPFT)..
	...
    6660:	3fd5 0002 7854 3620 2d34 7962 6574 4620     .?..Tx 64-byte F
    6670:	6172 656d 2873 7854 4642 3654 2934 0000     rames(TxBFT64)..
	...
    6688:	3fe1 0002 7854 3620 2d35 3231 2037 7962     .?..Tx 65-127 by
    6698:	6574 4620 6172 656d 2873 4254 5446 3231     te Frames(TBFT12
    66a8:	2937 0000 0000 0000 3fed 0002 7854 3120     7).......?..Tx 1
    66b8:	3832 322d 3535 6220 7479 2065 7246 6d61     28-255 byte Fram
    66c8:	7365 5428 4642 3254 3535 0029 0000 0000     es(TBFT255).....
    66d8:	3ff9 0002 7854 3220 3635 352d 3131 6220     .?..Tx 256-511 b
    66e8:	7479 2065 7246 6d61 7365 5428 4642 3554     yte Frames(TBFT5
    66f8:	3131 0029 0000 0000 4005 0002 7854 3520     11)......@..Tx 5
    6708:	3231 312d 3230 2033 7962 6574 4620 6172     12-1023 byte Fra
    6718:	656d 2873 4254 5446 3031 3332 0029 0000     mes(TBFT1023)...
    6728:	4011 0002 7854 3120 3230 2d34 3531 3831     .@..Tx 1024-1518
    6738:	6220 7479 2065 7246 6d61 7365 5428 4642      byte Frames(TBF
    6748:	3154 3135 2938 0000 401d 0002 7854 4620     T1518)...@..Tx F
    6758:	6172 656d 2073 3d3e 3120 3135 2038 7962     rames >= 1518 by
    6768:	6574 4728 4254 3146 3135 2938 0000 0000     te(GTBF1518)....
    6778:	4029 0002 7854 5520 646e 7265 7572 206e     )@..Tx Underrun 
    6788:	7246 6d61 7365 6e20 746f 5420 6558 2864     Frames not TXed(
    6798:	7854 5554 2952 0000 4035 0002 7854 5320     TxTUR)..5@..Tx S
    67a8:	6e69 6c67 2065 6f43 6c6c 7369 6f69 206e     ingle Collision 
    67b8:	7246 6d61 7365 5428 5378 4643 0029 0000     Frames(TxSCF)...
    67c8:	4041 0002 7854 3220 312d 2035 6f43 6c6c     A@..Tx 2-15 Coll
    67d8:	7369 6f69 206e 7246 6d61 7365 5428 4d78     ision Frames(TxM
    67e8:	4643 0029 0000 0000 404d 0002 7854 3120     CF).....M@..Tx 1
    67f8:	2036 6f43 6c6c 7369 6f69 206e 7246 6d61     6 Collision Fram
    6808:	7365 5428 4578 4343 544e 0029 0000 0000     es(TxECCNT).....
    6818:	4059 0002 7854 6c20 7461 2065 6f43 6c6c     Y@..Tx late Coll
    6828:	7369 6f69 206e 7246 6d61 7365 5428 4c78     ision Frames(TxL
    6838:	4343 544e 0029 0000 4065 0002 7854 4420     CCNT)...e@..Tx D
    6848:	6665 7265 6572 2064 7246 6d61 7365 5428     eferred Frames(T
    6858:	4478 4654 0029 0000 0000 0000 0000 0000     xDTF)...........
    6868:	4071 0002 7854 4320 7261 6972 7265 5320     q@..Tx Carrier S
    6878:	6e65 6573 6520 7272 726f 4620 6172 656d     ense error Frame
    6888:	2873 7854 5343 2945 407d 0002 7852 4220     s(TxCSE)}@..Rx B
    6898:	7479 2065 6f43 6e75 2d74 6f6c 6577 2072     yte Count-lower 
    68a8:	3233 6962 7374 5228 4f78 4c52 294f 0000     32bits(RxORLO)..
    68b8:	4089 0002 7852 4220 7479 2065 6f43 6e75     .@..Rx Byte Coun
    68c8:	2d74 7075 6570 2072 3631 6962 7374 5228     t-upper 16bits(R
    68d8:	4f78 4852 2949 0000 4095 0002 7852 4620     xORHI)...@..Rx F
    68e8:	6172 656d 2073 2f77 206f 7265 6f72 2872     rames w/o error(
    68f8:	7852 5246 4e43 2954 0000 0000 0000 0000     RxFRCNT)........
    6908:	40a1 0002 7852 4220 6f72 6461 6163 7473     .@..Rx Broadcast
    6918:	4620 6172 656d 2873 7852 4342 5246 0029      Frames(RxBCFR).
	...
    6930:	40ad 0002 7852 4d20 6c75 6974 6163 7473     .@..Rx Multicast
    6940:	4620 6172 656d 2073 5228 4d78 5246 0029      Frames (RxMFR).
	...
    6958:	40b9 0002 7852 5020 7561 6573 4620 6172     .@..Rx Pause Fra
    6968:	656d 2873 7852 4650 2952 0000 0000 0000     mes(RxPFR)......
	...
    6980:	40c5 0002 7852 3620 2d34 7962 6574 4620     .@..Rx 64-byte F
    6990:	6172 656d 2873 7852 4642 3652 2934 0000     rames(RxBFR64)..
	...
    69a8:	40d1 0002 7852 3620 2d35 3231 2037 7962     .@..Rx 65-127 by
    69b8:	6574 4620 6172 656d 2873 4254 5246 3231     te Frames(TBFR12
    69c8:	2937 0000 0000 0000 40dd 0002 7852 3120     7).......@..Rx 1
    69d8:	3832 322d 3535 6220 7479 2065 7246 6d61     28-255 byte Fram
    69e8:	7365 5428 4642 3252 3535 0029 0000 0000     es(TBFR255).....
    69f8:	40e9 0002 7852 3220 3635 352d 3131 6220     .@..Rx 256-511 b
    6a08:	7479 2065 7246 6d61 7365 5428 4642 3552     yte Frames(TBFR5
    6a18:	3131 0029 0000 0000 40f5 0002 7852 3520     11)......@..Rx 5
    6a28:	3231 312d 3230 2033 7962 6574 4620 6172     12-1023 byte Fra
    6a38:	656d 2873 4254 5246 3031 3332 0029 0000     mes(TBFR1023)...
    6a48:	4101 0002 7852 3120 3230 2d34 3531 3831     .A..Rx 1024-1518
    6a58:	6220 7479 2065 7246 6d61 7365 5428 4642      byte Frames(TBF
    6a68:	3152 3135 2938 0000 410d 0002 7852 4620     R1518)...A..Rx F
    6a78:	6172 656d 2073 3d3e 3120 3135 2039 7962     rames >= 1519 by
    6a88:	6574 2873 4d54 4258 5246 0029 0000 0000     tes(TMXBFR).....
    6a98:	4119 0002 7852 4620 6172 656d 2073 203c     .A..Rx Frames < 
    6aa8:	3436 6220 7479 7365 5228 5578 5246 0029     64 bytes(RxUFR).
	...
    6ac0:	4125 0002 7852 4620 6172 656d 2073 203e     %A..Rx Frames > 
    6ad0:	3531 3831 6220 7479 7365 5228 4f78 5246     1518 bytes(RxOFR
    6ae0:	0029 0000 0000 0000 4131 0002 7852 6520     ).......1A..Rx e
    6af0:	7272 726f 4620 6172 656d 2073 203e 3531     rror Frames > 15
    6b00:	3831 6220 7479 7365 5228 4a78 2952 0000     18 bytes(RxJR)..
    6b10:	413d 0002 7852 4320 4352 6520 7272 726f     =A..Rx CRC error
    6b20:	4620 6172 656d 2873 7852 4346 4553 0029      Frames(RxFCSE).
	...
    6b38:	4149 0002 7852 4c20 6e65 7467 2068 6966     IA..Rx Length fi
    6b48:	6c65 2064 7265 6f72 2072 7246 6d61 7365     eld error Frames
    6b58:	5228 4c78 4646 2945 4155 0002 7852 7320     (RxLFFE)UA..Rx s
    6b68:	6d79 6f62 206c 7265 6f72 2072 7246 6d61     ymbol error Fram
    6b78:	7365 5228 5278 4553 0029 0000 0000 0000     es(RxRSE).......
    6b88:	4161 0002 7852 6120 696c 6e67 656d 746e     aA..Rx alignment
    6b98:	6520 7272 726f 4620 6172 656d 2873 7852      error Frames(Rx
    6ba8:	4541 0029 0000 0000 416d 0002 7852 5220     AE).....mA..Rx R
    6bb8:	7365 756f 6372 2065 7245 6f72 2072 5228     esource Error (R
    6bc8:	5278 4552 0029 0000 0000 0000 0000 0000     xRRE)...........
    6bd8:	4179 0002 7852 6f20 6576 7272 6e75 6520     yA..Rx overrun e
    6be8:	7272 726f 4620 6172 656d 2873 7852 4f52     rror Frames(RxRO
    6bf8:	2945 0000 0000 0000 4185 0002 7852 4920     E).......A..Rx I
    6c08:	4850 7264 4320 6b68 7573 206d 7265 6f72     PHdr Chksum erro
    6c18:	2072 7246 6d61 7365 5228 4978 4348 2945     r Frames(RxIHCE)
    6c28:	4191 0002 7852 5420 5043 4320 6b68 7573     .A..Rx TCP Chksu
    6c38:	206d 7265 6f72 2072 7246 6d61 7365 5228     m error Frames(R
    6c48:	5478 4543 0029 0000 419d 0002 7852 5520     xTCE)....A..Rx U
    6c58:	5044 4320 6b68 7573 206d 7265 6f72 2072     DP Chksum error 
    6c68:	7246 6d61 7365 5228 5578 4543 0029 0000     Frames(RxUCE)...
    6c78:	41a9 0002                                   .A..

Disassembly of section .text.Transform%219:

00006c7c <Transform>:

#define MD5STEP(f, w, x, y, z, data, s) \
        w = rotlFixed(w + f(x, y, z) + data, s) + x

static int Transform(wc_Md5* md5, const byte* data)
{
    6c7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6c80:	b08d      	sub	sp, #52	; 0x34
    word32* buffer = (word32*)data;
    /* Copy context->state[] to working vars  */
    word32 a = md5->digest[0];
    word32 b = md5->digest[1];
    6c82:	f8d0 a050 	ldr.w	sl, [r0, #80]	; 0x50
    word32 c = md5->digest[2];
    word32 d = md5->digest[3];

    MD5STEP(F1, a, b, c, d, buffer[0]  + 0xd76aa478,  7);
    6c86:	680a      	ldr	r2, [r1, #0]
    6c88:	6d43      	ldr	r3, [r0, #84]	; 0x54
    6c8a:	6d84      	ldr	r4, [r0, #88]	; 0x58
    6c8c:	ea83 0e04 	eor.w	lr, r3, r4
    6c90:	ea0e 0e0a 	and.w	lr, lr, sl
    6c94:	ea8e 0e04 	eor.w	lr, lr, r4
    6c98:	4bd8      	ldr	r3, [pc, #864]	; (6ffc <Transform+0x380>)
    6c9a:	6cc4      	ldr	r4, [r0, #76]	; 0x4c
    6c9c:	4423      	add	r3, r4
    6c9e:	920a      	str	r2, [sp, #40]	; 0x28
    6ca0:	4413      	add	r3, r2
    6ca2:	449e      	add	lr, r3
    6ca4:	eb0a 6e7e 	add.w	lr, sl, lr, ror #25
    MD5STEP(F1, d, a, b, c, buffer[1]  + 0xe8c7b756, 12);
    6ca8:	684e      	ldr	r6, [r1, #4]
    6caa:	6d43      	ldr	r3, [r0, #84]	; 0x54
    6cac:	ea8a 0703 	eor.w	r7, sl, r3
    6cb0:	ea07 070e 	and.w	r7, r7, lr
    6cb4:	405f      	eors	r7, r3
    6cb6:	4bd2      	ldr	r3, [pc, #840]	; (7000 <Transform+0x384>)
    6cb8:	6d85      	ldr	r5, [r0, #88]	; 0x58
    6cba:	442b      	add	r3, r5
    6cbc:	9600      	str	r6, [sp, #0]
    6cbe:	4433      	add	r3, r6
    6cc0:	441f      	add	r7, r3
    6cc2:	eb0e 5737 	add.w	r7, lr, r7, ror #20
    MD5STEP(F1, c, d, a, b, buffer[2]  + 0x242070db, 17);
    6cc6:	688b      	ldr	r3, [r1, #8]
    6cc8:	461a      	mov	r2, r3
    6cca:	ea8a 050e 	eor.w	r5, sl, lr
    6cce:	403d      	ands	r5, r7
    6cd0:	ea85 050a 	eor.w	r5, r5, sl
    6cd4:	4bcb      	ldr	r3, [pc, #812]	; (7004 <Transform+0x388>)
    6cd6:	6d44      	ldr	r4, [r0, #84]	; 0x54
    6cd8:	4423      	add	r3, r4
    6cda:	9201      	str	r2, [sp, #4]
    6cdc:	4413      	add	r3, r2
    6cde:	441d      	add	r5, r3
    6ce0:	eb07 35f5 	add.w	r5, r7, r5, ror #15
    MD5STEP(F1, b, c, d, a, buffer[3]  + 0xc1bdceee, 22);
    6ce4:	68cb      	ldr	r3, [r1, #12]
    6ce6:	461c      	mov	r4, r3
    6ce8:	ea8e 0607 	eor.w	r6, lr, r7
    6cec:	402e      	ands	r6, r5
    6cee:	ea86 060e 	eor.w	r6, r6, lr
    6cf2:	4bc5      	ldr	r3, [pc, #788]	; (7008 <Transform+0x38c>)
    6cf4:	4453      	add	r3, sl
    6cf6:	9402      	str	r4, [sp, #8]
    6cf8:	4423      	add	r3, r4
    6cfa:	441e      	add	r6, r3
    6cfc:	eb05 26b6 	add.w	r6, r5, r6, ror #10
    MD5STEP(F1, a, b, c, d, buffer[4]  + 0xf57c0faf,  7);
    6d00:	690b      	ldr	r3, [r1, #16]
    6d02:	461c      	mov	r4, r3
    6d04:	ea87 0305 	eor.w	r3, r7, r5
    6d08:	4033      	ands	r3, r6
    6d0a:	407b      	eors	r3, r7
    6d0c:	4abf      	ldr	r2, [pc, #764]	; (700c <Transform+0x390>)
    6d0e:	9403      	str	r4, [sp, #12]
    6d10:	4422      	add	r2, r4
    6d12:	4496      	add	lr, r2
    6d14:	4473      	add	r3, lr
    6d16:	eb06 6973 	add.w	r9, r6, r3, ror #25
    MD5STEP(F1, d, a, b, c, buffer[5]  + 0x4787c62a, 12);
    6d1a:	694a      	ldr	r2, [r1, #20]
    6d1c:	4613      	mov	r3, r2
    6d1e:	ea85 0406 	eor.w	r4, r5, r6
    6d22:	ea04 0409 	and.w	r4, r4, r9
    6d26:	406c      	eors	r4, r5
    6d28:	4ab9      	ldr	r2, [pc, #740]	; (7010 <Transform+0x394>)
    6d2a:	9304      	str	r3, [sp, #16]
    6d2c:	441a      	add	r2, r3
    6d2e:	4417      	add	r7, r2
    6d30:	443c      	add	r4, r7
    6d32:	eb09 5434 	add.w	r4, r9, r4, ror #20
    MD5STEP(F1, c, d, a, b, buffer[6]  + 0xa8304613, 17);
    6d36:	698b      	ldr	r3, [r1, #24]
    6d38:	ea86 0209 	eor.w	r2, r6, r9
    6d3c:	4022      	ands	r2, r4
    6d3e:	4072      	eors	r2, r6
    6d40:	4fb4      	ldr	r7, [pc, #720]	; (7014 <Transform+0x398>)
    6d42:	9305      	str	r3, [sp, #20]
    6d44:	441f      	add	r7, r3
    6d46:	443d      	add	r5, r7
    6d48:	442a      	add	r2, r5
    6d4a:	eb04 32f2 	add.w	r2, r4, r2, ror #15
    MD5STEP(F1, b, c, d, a, buffer[7]  + 0xfd469501, 22);
    6d4e:	69cf      	ldr	r7, [r1, #28]
    6d50:	ea89 0804 	eor.w	r8, r9, r4
    6d54:	ea08 0802 	and.w	r8, r8, r2
    6d58:	ea88 0809 	eor.w	r8, r8, r9
    6d5c:	4dae      	ldr	r5, [pc, #696]	; (7018 <Transform+0x39c>)
    6d5e:	9706      	str	r7, [sp, #24]
    6d60:	443d      	add	r5, r7
    6d62:	442e      	add	r6, r5
    6d64:	44b0      	add	r8, r6
    6d66:	eb02 28b8 	add.w	r8, r2, r8, ror #10
    MD5STEP(F1, a, b, c, d, buffer[8]  + 0x698098d8,  7);
    6d6a:	6a0f      	ldr	r7, [r1, #32]
    6d6c:	ea84 0c02 	eor.w	ip, r4, r2
    6d70:	ea0c 0c08 	and.w	ip, ip, r8
    6d74:	ea8c 0c04 	eor.w	ip, ip, r4
    6d78:	4da8      	ldr	r5, [pc, #672]	; (701c <Transform+0x3a0>)
    6d7a:	9707      	str	r7, [sp, #28]
    6d7c:	443d      	add	r5, r7
    6d7e:	eb09 0305 	add.w	r3, r9, r5
    6d82:	449c      	add	ip, r3
    6d84:	eb08 6c7c 	add.w	ip, r8, ip, ror #25
    MD5STEP(F1, d, a, b, c, buffer[9]  + 0x8b44f7af, 12);
    6d88:	6a4d      	ldr	r5, [r1, #36]	; 0x24
    6d8a:	ea82 0908 	eor.w	r9, r2, r8
    6d8e:	ea09 090c 	and.w	r9, r9, ip
    6d92:	ea89 0902 	eor.w	r9, r9, r2
    6d96:	4ba2      	ldr	r3, [pc, #648]	; (7020 <Transform+0x3a4>)
    6d98:	9508      	str	r5, [sp, #32]
    6d9a:	442b      	add	r3, r5
    6d9c:	441c      	add	r4, r3
    6d9e:	44a1      	add	r9, r4
    6da0:	eb0c 5939 	add.w	r9, ip, r9, ror #20
    MD5STEP(F1, c, d, a, b, buffer[10] + 0xffff5bb1, 17);
    6da4:	6a8b      	ldr	r3, [r1, #40]	; 0x28
    6da6:	ea88 0e0c 	eor.w	lr, r8, ip
    6daa:	ea0e 0e09 	and.w	lr, lr, r9
    6dae:	ea8e 0e08 	eor.w	lr, lr, r8
    6db2:	9309      	str	r3, [sp, #36]	; 0x24
    6db4:	f5a3 4324 	sub.w	r3, r3, #41984	; 0xa400
    6db8:	3b4f      	subs	r3, #79	; 0x4f
    6dba:	441a      	add	r2, r3
    6dbc:	4496      	add	lr, r2
    6dbe:	eb09 3efe 	add.w	lr, r9, lr, ror #15
    MD5STEP(F1, b, c, d, a, buffer[11] + 0x895cd7be, 22);
    6dc2:	6aca      	ldr	r2, [r1, #44]	; 0x2c
    6dc4:	4616      	mov	r6, r2
    6dc6:	ea8c 0509 	eor.w	r5, ip, r9
    6dca:	ea05 050e 	and.w	r5, r5, lr
    6dce:	ea85 050c 	eor.w	r5, r5, ip
    6dd2:	4b94      	ldr	r3, [pc, #592]	; (7024 <Transform+0x3a8>)
    6dd4:	4413      	add	r3, r2
    6dd6:	4498      	add	r8, r3
    6dd8:	4445      	add	r5, r8
    6dda:	eb0e 25b5 	add.w	r5, lr, r5, ror #10
    MD5STEP(F1, a, b, c, d, buffer[12] + 0x6b901122,  7);
    6dde:	f8d1 8030 	ldr.w	r8, [r1, #48]	; 0x30
    6de2:	ea89 070e 	eor.w	r7, r9, lr
    6de6:	402f      	ands	r7, r5
    6de8:	ea87 0709 	eor.w	r7, r7, r9
    6dec:	4b8e      	ldr	r3, [pc, #568]	; (7028 <Transform+0x3ac>)
    6dee:	4443      	add	r3, r8
    6df0:	449c      	add	ip, r3
    6df2:	4467      	add	r7, ip
    6df4:	eb05 6777 	add.w	r7, r5, r7, ror #25
    MD5STEP(F1, d, a, b, c, buffer[13] + 0xfd987193, 12);
    6df8:	f8d1 c034 	ldr.w	ip, [r1, #52]	; 0x34
    6dfc:	ea8e 0305 	eor.w	r3, lr, r5
    6e00:	403b      	ands	r3, r7
    6e02:	ea83 030e 	eor.w	r3, r3, lr
    6e06:	4a89      	ldr	r2, [pc, #548]	; (702c <Transform+0x3b0>)
    6e08:	4462      	add	r2, ip
    6e0a:	4491      	add	r9, r2
    6e0c:	444b      	add	r3, r9
    6e0e:	eb07 5333 	add.w	r3, r7, r3, ror #20
    MD5STEP(F1, c, d, a, b, buffer[14] + 0xa679438e, 17);
    6e12:	f8d1 9038 	ldr.w	r9, [r1, #56]	; 0x38
    6e16:	ea85 0407 	eor.w	r4, r5, r7
    6e1a:	401c      	ands	r4, r3
    6e1c:	406c      	eors	r4, r5
    6e1e:	4a84      	ldr	r2, [pc, #528]	; (7030 <Transform+0x3b4>)
    6e20:	444a      	add	r2, r9
    6e22:	4496      	add	lr, r2
    6e24:	4474      	add	r4, lr
    6e26:	eb03 34f4 	add.w	r4, r3, r4, ror #15
    MD5STEP(F1, b, c, d, a, buffer[15] + 0x49b40821, 22);
    6e2a:	f8d1 e03c 	ldr.w	lr, [r1, #60]	; 0x3c
    6e2e:	ea87 0203 	eor.w	r2, r7, r3
    6e32:	4022      	ands	r2, r4
    6e34:	407a      	eors	r2, r7
    6e36:	497f      	ldr	r1, [pc, #508]	; (7034 <Transform+0x3b8>)
    6e38:	4471      	add	r1, lr
    6e3a:	440d      	add	r5, r1
    6e3c:	442a      	add	r2, r5
    6e3e:	eb04 22b2 	add.w	r2, r4, r2, ror #10

    MD5STEP(F2, a, b, c, d, buffer[1]  + 0xf61e2562,  5);
    6e42:	ea84 0b02 	eor.w	fp, r4, r2
    6e46:	ea0b 0b03 	and.w	fp, fp, r3
    6e4a:	ea8b 0b04 	eor.w	fp, fp, r4
    6e4e:	497a      	ldr	r1, [pc, #488]	; (7038 <Transform+0x3bc>)
    6e50:	9d00      	ldr	r5, [sp, #0]
    6e52:	4429      	add	r1, r5
    6e54:	440f      	add	r7, r1
    6e56:	44bb      	add	fp, r7
    6e58:	eb02 6bfb 	add.w	fp, r2, fp, ror #27
    MD5STEP(F2, d, a, b, c, buffer[6]  + 0xc040b340,  9);
    6e5c:	ea82 070b 	eor.w	r7, r2, fp
    6e60:	4027      	ands	r7, r4
    6e62:	4057      	eors	r7, r2
    6e64:	4975      	ldr	r1, [pc, #468]	; (703c <Transform+0x3c0>)
    6e66:	9d05      	ldr	r5, [sp, #20]
    6e68:	4429      	add	r1, r5
    6e6a:	440b      	add	r3, r1
    6e6c:	441f      	add	r7, r3
    6e6e:	eb0b 57f7 	add.w	r7, fp, r7, ror #23
    MD5STEP(F2, c, d, a, b, buffer[11] + 0x265e5a51, 14);
    6e72:	ea8b 0307 	eor.w	r3, fp, r7
    6e76:	4013      	ands	r3, r2
    6e78:	ea83 030b 	eor.w	r3, r3, fp
    6e7c:	4970      	ldr	r1, [pc, #448]	; (7040 <Transform+0x3c4>)
    6e7e:	960b      	str	r6, [sp, #44]	; 0x2c
    6e80:	4431      	add	r1, r6
    6e82:	440c      	add	r4, r1
    6e84:	4423      	add	r3, r4
    6e86:	eb07 43b3 	add.w	r3, r7, r3, ror #18
    MD5STEP(F2, b, c, d, a, buffer[0]  + 0xe9b6c7aa, 20);
    6e8a:	ea87 0503 	eor.w	r5, r7, r3
    6e8e:	ea05 050b 	and.w	r5, r5, fp
    6e92:	407d      	eors	r5, r7
    6e94:	496b      	ldr	r1, [pc, #428]	; (7044 <Transform+0x3c8>)
    6e96:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    6e98:	4421      	add	r1, r4
    6e9a:	440a      	add	r2, r1
    6e9c:	4415      	add	r5, r2
    6e9e:	eb03 3535 	add.w	r5, r3, r5, ror #12
    MD5STEP(F2, a, b, c, d, buffer[5]  + 0xd62f105d,  5);
    6ea2:	ea83 0205 	eor.w	r2, r3, r5
    6ea6:	403a      	ands	r2, r7
    6ea8:	405a      	eors	r2, r3
    6eaa:	4967      	ldr	r1, [pc, #412]	; (7048 <Transform+0x3cc>)
    6eac:	9e04      	ldr	r6, [sp, #16]
    6eae:	4431      	add	r1, r6
    6eb0:	448b      	add	fp, r1
    6eb2:	445a      	add	r2, fp
    6eb4:	eb05 62f2 	add.w	r2, r5, r2, ror #27
    MD5STEP(F2, d, a, b, c, buffer[10] + 0x02441453,  9);
    6eb8:	ea85 0102 	eor.w	r1, r5, r2
    6ebc:	4019      	ands	r1, r3
    6ebe:	4069      	eors	r1, r5
    6ec0:	4c62      	ldr	r4, [pc, #392]	; (704c <Transform+0x3d0>)
    6ec2:	9e09      	ldr	r6, [sp, #36]	; 0x24
    6ec4:	4434      	add	r4, r6
    6ec6:	4427      	add	r7, r4
    6ec8:	4439      	add	r1, r7
    6eca:	eb02 51f1 	add.w	r1, r2, r1, ror #23
    MD5STEP(F2, c, d, a, b, buffer[15] + 0xd8a1e681, 14);
    6ece:	ea82 0401 	eor.w	r4, r2, r1
    6ed2:	402c      	ands	r4, r5
    6ed4:	4054      	eors	r4, r2
    6ed6:	4f5e      	ldr	r7, [pc, #376]	; (7050 <Transform+0x3d4>)
    6ed8:	4477      	add	r7, lr
    6eda:	443b      	add	r3, r7
    6edc:	441c      	add	r4, r3
    6ede:	eb01 44b4 	add.w	r4, r1, r4, ror #18
    MD5STEP(F2, b, c, d, a, buffer[4]  + 0xe7d3fbc8, 20);
    6ee2:	ea81 0304 	eor.w	r3, r1, r4
    6ee6:	4013      	ands	r3, r2
    6ee8:	404b      	eors	r3, r1
    6eea:	4f5a      	ldr	r7, [pc, #360]	; (7054 <Transform+0x3d8>)
    6eec:	9e03      	ldr	r6, [sp, #12]
    6eee:	4437      	add	r7, r6
    6ef0:	443d      	add	r5, r7
    6ef2:	442b      	add	r3, r5
    6ef4:	eb04 3333 	add.w	r3, r4, r3, ror #12
    MD5STEP(F2, a, b, c, d, buffer[9]  + 0x21e1cde6,  5);
    6ef8:	ea84 0b03 	eor.w	fp, r4, r3
    6efc:	ea0b 0b01 	and.w	fp, fp, r1
    6f00:	ea8b 0b04 	eor.w	fp, fp, r4
    6f04:	4d54      	ldr	r5, [pc, #336]	; (7058 <Transform+0x3dc>)
    6f06:	9e08      	ldr	r6, [sp, #32]
    6f08:	4435      	add	r5, r6
    6f0a:	442a      	add	r2, r5
    6f0c:	4493      	add	fp, r2
    6f0e:	eb03 6bfb 	add.w	fp, r3, fp, ror #27
    MD5STEP(F2, d, a, b, c, buffer[14] + 0xc33707d6,  9);
    6f12:	ea83 070b 	eor.w	r7, r3, fp
    6f16:	4027      	ands	r7, r4
    6f18:	405f      	eors	r7, r3
    6f1a:	4a50      	ldr	r2, [pc, #320]	; (705c <Transform+0x3e0>)
    6f1c:	444a      	add	r2, r9
    6f1e:	4411      	add	r1, r2
    6f20:	440f      	add	r7, r1
    6f22:	eb0b 57f7 	add.w	r7, fp, r7, ror #23
    MD5STEP(F2, c, d, a, b, buffer[3]  + 0xf4d50d87, 14);
    6f26:	ea8b 0507 	eor.w	r5, fp, r7
    6f2a:	401d      	ands	r5, r3
    6f2c:	ea85 050b 	eor.w	r5, r5, fp
    6f30:	4a4b      	ldr	r2, [pc, #300]	; (7060 <Transform+0x3e4>)
    6f32:	9902      	ldr	r1, [sp, #8]
    6f34:	440a      	add	r2, r1
    6f36:	4414      	add	r4, r2
    6f38:	4425      	add	r5, r4
    6f3a:	eb07 45b5 	add.w	r5, r7, r5, ror #18
    MD5STEP(F2, b, c, d, a, buffer[8]  + 0x455a14ed, 20);
    6f3e:	ea87 0205 	eor.w	r2, r7, r5
    6f42:	ea02 020b 	and.w	r2, r2, fp
    6f46:	407a      	eors	r2, r7
    6f48:	4946      	ldr	r1, [pc, #280]	; (7064 <Transform+0x3e8>)
    6f4a:	9e07      	ldr	r6, [sp, #28]
    6f4c:	4431      	add	r1, r6
    6f4e:	440b      	add	r3, r1
    6f50:	441a      	add	r2, r3
    6f52:	eb05 3232 	add.w	r2, r5, r2, ror #12
    MD5STEP(F2, a, b, c, d, buffer[13] + 0xa9e3e905,  5);
    6f56:	ea85 0302 	eor.w	r3, r5, r2
    6f5a:	403b      	ands	r3, r7
    6f5c:	406b      	eors	r3, r5
    6f5e:	4942      	ldr	r1, [pc, #264]	; (7068 <Transform+0x3ec>)
    6f60:	4461      	add	r1, ip
    6f62:	448b      	add	fp, r1
    6f64:	445b      	add	r3, fp
    6f66:	eb02 63f3 	add.w	r3, r2, r3, ror #27
    MD5STEP(F2, d, a, b, c, buffer[2]  + 0xfcefa3f8,  9);
    6f6a:	ea82 0103 	eor.w	r1, r2, r3
    6f6e:	4029      	ands	r1, r5
    6f70:	4051      	eors	r1, r2
    6f72:	4c3e      	ldr	r4, [pc, #248]	; (706c <Transform+0x3f0>)
    6f74:	9e01      	ldr	r6, [sp, #4]
    6f76:	4434      	add	r4, r6
    6f78:	4427      	add	r7, r4
    6f7a:	4439      	add	r1, r7
    6f7c:	eb03 51f1 	add.w	r1, r3, r1, ror #23
    MD5STEP(F2, c, d, a, b, buffer[7]  + 0x676f02d9, 14);
    6f80:	ea83 0401 	eor.w	r4, r3, r1
    6f84:	4014      	ands	r4, r2
    6f86:	405c      	eors	r4, r3
    6f88:	4f39      	ldr	r7, [pc, #228]	; (7070 <Transform+0x3f4>)
    6f8a:	9e06      	ldr	r6, [sp, #24]
    6f8c:	4437      	add	r7, r6
    6f8e:	443d      	add	r5, r7
    6f90:	442c      	add	r4, r5
    6f92:	eb01 44b4 	add.w	r4, r1, r4, ror #18
    MD5STEP(F2, b, c, d, a, buffer[12] + 0x8d2a4c8a, 20);
    6f96:	ea81 0b04 	eor.w	fp, r1, r4
    6f9a:	ea0b 0503 	and.w	r5, fp, r3
    6f9e:	404d      	eors	r5, r1
    6fa0:	4f34      	ldr	r7, [pc, #208]	; (7074 <Transform+0x3f8>)
    6fa2:	4447      	add	r7, r8
    6fa4:	443a      	add	r2, r7
    6fa6:	4415      	add	r5, r2
    6fa8:	eb04 3535 	add.w	r5, r4, r5, ror #12

    MD5STEP(F3, a, b, c, d, buffer[5]  + 0xfffa3942,  4);
    6fac:	9f04      	ldr	r7, [sp, #16]
    6fae:	f5a7 22b8 	sub.w	r2, r7, #376832	; 0x5c000
    6fb2:	f2a2 62be 	subw	r2, r2, #1726	; 0x6be
    6fb6:	4413      	add	r3, r2
    6fb8:	ea8b 0b05 	eor.w	fp, fp, r5
    6fbc:	445b      	add	r3, fp
    6fbe:	eb05 7333 	add.w	r3, r5, r3, ror #28
    MD5STEP(F3, d, a, b, c, buffer[8]  + 0x8771f681, 11);
    6fc2:	ea84 0205 	eor.w	r2, r4, r5
    6fc6:	405a      	eors	r2, r3
    6fc8:	4f2b      	ldr	r7, [pc, #172]	; (7078 <Transform+0x3fc>)
    6fca:	9e07      	ldr	r6, [sp, #28]
    6fcc:	4437      	add	r7, r6
    6fce:	4439      	add	r1, r7
    6fd0:	4411      	add	r1, r2
    6fd2:	eb03 5171 	add.w	r1, r3, r1, ror #21
    MD5STEP(F3, c, d, a, b, buffer[11] + 0x6d9d6122, 16);
    6fd6:	ea85 0b03 	eor.w	fp, r5, r3
    6fda:	ea8b 0b01 	eor.w	fp, fp, r1
    6fde:	4a27      	ldr	r2, [pc, #156]	; (707c <Transform+0x400>)
    6fe0:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    6fe2:	443a      	add	r2, r7
    6fe4:	4414      	add	r4, r2
    6fe6:	445c      	add	r4, fp
    6fe8:	eb01 4434 	add.w	r4, r1, r4, ror #16
    MD5STEP(F3, b, c, d, a, buffer[14] + 0xfde5380c, 23);
    6fec:	ea83 0701 	eor.w	r7, r3, r1
    6ff0:	4067      	eors	r7, r4
    6ff2:	4a23      	ldr	r2, [pc, #140]	; (7080 <Transform+0x404>)
    6ff4:	444a      	add	r2, r9
    6ff6:	4415      	add	r5, r2
    6ff8:	442f      	add	r7, r5
    6ffa:	e043      	b.n	7084 <Transform+0x408>
    6ffc:	d76aa478 	.word	0xd76aa478
    7000:	e8c7b756 	.word	0xe8c7b756
    7004:	242070db 	.word	0x242070db
    7008:	c1bdceee 	.word	0xc1bdceee
    700c:	f57c0faf 	.word	0xf57c0faf
    7010:	4787c62a 	.word	0x4787c62a
    7014:	a8304613 	.word	0xa8304613
    7018:	fd469501 	.word	0xfd469501
    701c:	698098d8 	.word	0x698098d8
    7020:	8b44f7af 	.word	0x8b44f7af
    7024:	895cd7be 	.word	0x895cd7be
    7028:	6b901122 	.word	0x6b901122
    702c:	fd987193 	.word	0xfd987193
    7030:	a679438e 	.word	0xa679438e
    7034:	49b40821 	.word	0x49b40821
    7038:	f61e2562 	.word	0xf61e2562
    703c:	c040b340 	.word	0xc040b340
    7040:	265e5a51 	.word	0x265e5a51
    7044:	e9b6c7aa 	.word	0xe9b6c7aa
    7048:	d62f105d 	.word	0xd62f105d
    704c:	02441453 	.word	0x02441453
    7050:	d8a1e681 	.word	0xd8a1e681
    7054:	e7d3fbc8 	.word	0xe7d3fbc8
    7058:	21e1cde6 	.word	0x21e1cde6
    705c:	c33707d6 	.word	0xc33707d6
    7060:	f4d50d87 	.word	0xf4d50d87
    7064:	455a14ed 	.word	0x455a14ed
    7068:	a9e3e905 	.word	0xa9e3e905
    706c:	fcefa3f8 	.word	0xfcefa3f8
    7070:	676f02d9 	.word	0x676f02d9
    7074:	8d2a4c8a 	.word	0x8d2a4c8a
    7078:	8771f681 	.word	0x8771f681
    707c:	6d9d6122 	.word	0x6d9d6122
    7080:	fde5380c 	.word	0xfde5380c
    7084:	eb04 2777 	add.w	r7, r4, r7, ror #9
    MD5STEP(F3, a, b, c, d, buffer[1]  + 0xa4beea44,  4);
    7088:	ea81 0204 	eor.w	r2, r1, r4
    708c:	407a      	eors	r2, r7
    708e:	4d94      	ldr	r5, [pc, #592]	; (72e0 <Transform+0x664>)
    7090:	9e00      	ldr	r6, [sp, #0]
    7092:	4435      	add	r5, r6
    7094:	442b      	add	r3, r5
    7096:	4413      	add	r3, r2
    7098:	eb07 7333 	add.w	r3, r7, r3, ror #28
    MD5STEP(F3, d, a, b, c, buffer[4]  + 0x4bdecfa9, 11);
    709c:	ea84 0207 	eor.w	r2, r4, r7
    70a0:	405a      	eors	r2, r3
    70a2:	4d90      	ldr	r5, [pc, #576]	; (72e4 <Transform+0x668>)
    70a4:	9e03      	ldr	r6, [sp, #12]
    70a6:	4435      	add	r5, r6
    70a8:	4429      	add	r1, r5
    70aa:	4411      	add	r1, r2
    70ac:	eb03 5171 	add.w	r1, r3, r1, ror #21
    MD5STEP(F3, c, d, a, b, buffer[7]  + 0xf6bb4b60, 16);
    70b0:	ea87 0b03 	eor.w	fp, r7, r3
    70b4:	ea8b 0b01 	eor.w	fp, fp, r1
    70b8:	4a8b      	ldr	r2, [pc, #556]	; (72e8 <Transform+0x66c>)
    70ba:	9d06      	ldr	r5, [sp, #24]
    70bc:	442a      	add	r2, r5
    70be:	4414      	add	r4, r2
    70c0:	44a3      	add	fp, r4
    70c2:	eb01 4b3b 	add.w	fp, r1, fp, ror #16
    MD5STEP(F3, b, c, d, a, buffer[10] + 0xbebfbc70, 23);
    70c6:	ea83 0201 	eor.w	r2, r3, r1
    70ca:	ea82 020b 	eor.w	r2, r2, fp
    70ce:	4c87      	ldr	r4, [pc, #540]	; (72ec <Transform+0x670>)
    70d0:	9d09      	ldr	r5, [sp, #36]	; 0x24
    70d2:	442c      	add	r4, r5
    70d4:	4427      	add	r7, r4
    70d6:	443a      	add	r2, r7
    70d8:	eb0b 2272 	add.w	r2, fp, r2, ror #9
    MD5STEP(F3, a, b, c, d, buffer[13] + 0x289b7ec6,  4);
    70dc:	ea81 040b 	eor.w	r4, r1, fp
    70e0:	4054      	eors	r4, r2
    70e2:	4d83      	ldr	r5, [pc, #524]	; (72f0 <Transform+0x674>)
    70e4:	4465      	add	r5, ip
    70e6:	442b      	add	r3, r5
    70e8:	4423      	add	r3, r4
    70ea:	eb02 7333 	add.w	r3, r2, r3, ror #28
    MD5STEP(F3, d, a, b, c, buffer[0]  + 0xeaa127fa, 11);
    70ee:	ea8b 0702 	eor.w	r7, fp, r2
    70f2:	405f      	eors	r7, r3
    70f4:	4c7f      	ldr	r4, [pc, #508]	; (72f4 <Transform+0x678>)
    70f6:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    70f8:	4434      	add	r4, r6
    70fa:	4421      	add	r1, r4
    70fc:	440f      	add	r7, r1
    70fe:	eb03 5777 	add.w	r7, r3, r7, ror #21
    MD5STEP(F3, c, d, a, b, buffer[3]  + 0xd4ef3085, 16);
    7102:	ea82 0503 	eor.w	r5, r2, r3
    7106:	407d      	eors	r5, r7
    7108:	497b      	ldr	r1, [pc, #492]	; (72f8 <Transform+0x67c>)
    710a:	9c02      	ldr	r4, [sp, #8]
    710c:	4421      	add	r1, r4
    710e:	448b      	add	fp, r1
    7110:	445d      	add	r5, fp
    7112:	eb07 4535 	add.w	r5, r7, r5, ror #16
    MD5STEP(F3, b, c, d, a, buffer[6]  + 0x04881d05, 23);
    7116:	ea83 0b07 	eor.w	fp, r3, r7
    711a:	ea8b 0b05 	eor.w	fp, fp, r5
    711e:	4977      	ldr	r1, [pc, #476]	; (72fc <Transform+0x680>)
    7120:	9c05      	ldr	r4, [sp, #20]
    7122:	4421      	add	r1, r4
    7124:	440a      	add	r2, r1
    7126:	4493      	add	fp, r2
    7128:	eb05 2b7b 	add.w	fp, r5, fp, ror #9
    MD5STEP(F3, a, b, c, d, buffer[9]  + 0xd9d4d039,  4);
    712c:	ea87 0405 	eor.w	r4, r7, r5
    7130:	ea84 040b 	eor.w	r4, r4, fp
    7134:	4a72      	ldr	r2, [pc, #456]	; (7300 <Transform+0x684>)
    7136:	9908      	ldr	r1, [sp, #32]
    7138:	440a      	add	r2, r1
    713a:	4413      	add	r3, r2
    713c:	441c      	add	r4, r3
    713e:	eb0b 7434 	add.w	r4, fp, r4, ror #28
    MD5STEP(F3, d, a, b, c, buffer[12] + 0xe6db99e5, 11);
    7142:	ea85 010b 	eor.w	r1, r5, fp
    7146:	4061      	eors	r1, r4
    7148:	4b6e      	ldr	r3, [pc, #440]	; (7304 <Transform+0x688>)
    714a:	4443      	add	r3, r8
    714c:	441f      	add	r7, r3
    714e:	4439      	add	r1, r7
    7150:	eb04 5171 	add.w	r1, r4, r1, ror #21
    MD5STEP(F3, c, d, a, b, buffer[15] + 0x1fa27cf8, 16);
    7154:	ea8b 0304 	eor.w	r3, fp, r4
    7158:	404b      	eors	r3, r1
    715a:	4a6b      	ldr	r2, [pc, #428]	; (7308 <Transform+0x68c>)
    715c:	4472      	add	r2, lr
    715e:	4415      	add	r5, r2
    7160:	441d      	add	r5, r3
    7162:	eb01 4535 	add.w	r5, r1, r5, ror #16
    MD5STEP(F3, b, c, d, a, buffer[2]  + 0xc4ac5665, 23);
    7166:	ea84 0201 	eor.w	r2, r4, r1
    716a:	406a      	eors	r2, r5
    716c:	4b67      	ldr	r3, [pc, #412]	; (730c <Transform+0x690>)
    716e:	9f01      	ldr	r7, [sp, #4]
    7170:	443b      	add	r3, r7
    7172:	449b      	add	fp, r3
    7174:	445a      	add	r2, fp
    7176:	eb05 2272 	add.w	r2, r5, r2, ror #9

    MD5STEP(F4, a, b, c, d, buffer[0]  + 0xf4292244,  6);
    717a:	ea62 0301 	orn	r3, r2, r1
    717e:	406b      	eors	r3, r5
    7180:	4f63      	ldr	r7, [pc, #396]	; (7310 <Transform+0x694>)
    7182:	4437      	add	r7, r6
    7184:	443c      	add	r4, r7
    7186:	4423      	add	r3, r4
    7188:	eb02 63b3 	add.w	r3, r2, r3, ror #26
    MD5STEP(F4, d, a, b, c, buffer[7]  + 0x432aff97, 10);
    718c:	ea63 0b05 	orn	fp, r3, r5
    7190:	ea8b 0b02 	eor.w	fp, fp, r2
    7194:	4c5f      	ldr	r4, [pc, #380]	; (7314 <Transform+0x698>)
    7196:	9f06      	ldr	r7, [sp, #24]
    7198:	443c      	add	r4, r7
    719a:	4421      	add	r1, r4
    719c:	448b      	add	fp, r1
    719e:	eb03 5bbb 	add.w	fp, r3, fp, ror #22
    MD5STEP(F4, c, d, a, b, buffer[14] + 0xab9423a7, 15);
    71a2:	ea6b 0702 	orn	r7, fp, r2
    71a6:	405f      	eors	r7, r3
    71a8:	495b      	ldr	r1, [pc, #364]	; (7318 <Transform+0x69c>)
    71aa:	4449      	add	r1, r9
    71ac:	440d      	add	r5, r1
    71ae:	442f      	add	r7, r5
    71b0:	eb0b 4777 	add.w	r7, fp, r7, ror #17
    MD5STEP(F4, b, c, d, a, buffer[5]  + 0xfc93a039, 21);
    71b4:	ea67 0403 	orn	r4, r7, r3
    71b8:	ea84 040b 	eor.w	r4, r4, fp
    71bc:	4957      	ldr	r1, [pc, #348]	; (731c <Transform+0x6a0>)
    71be:	9d04      	ldr	r5, [sp, #16]
    71c0:	4429      	add	r1, r5
    71c2:	440a      	add	r2, r1
    71c4:	4414      	add	r4, r2
    71c6:	eb07 24f4 	add.w	r4, r7, r4, ror #11
    MD5STEP(F4, a, b, c, d, buffer[12] + 0x655b59c3,  6);
    71ca:	ea64 050b 	orn	r5, r4, fp
    71ce:	407d      	eors	r5, r7
    71d0:	4a53      	ldr	r2, [pc, #332]	; (7320 <Transform+0x6a4>)
    71d2:	4442      	add	r2, r8
    71d4:	4413      	add	r3, r2
    71d6:	441d      	add	r5, r3
    71d8:	eb04 65b5 	add.w	r5, r4, r5, ror #26
    MD5STEP(F4, d, a, b, c, buffer[3]  + 0x8f0ccc92, 10);
    71dc:	ea65 0807 	orn	r8, r5, r7
    71e0:	ea88 0804 	eor.w	r8, r8, r4
    71e4:	4b4f      	ldr	r3, [pc, #316]	; (7324 <Transform+0x6a8>)
    71e6:	9902      	ldr	r1, [sp, #8]
    71e8:	440b      	add	r3, r1
    71ea:	449b      	add	fp, r3
    71ec:	44d8      	add	r8, fp
    71ee:	eb05 58b8 	add.w	r8, r5, r8, ror #22
    MD5STEP(F4, c, d, a, b, buffer[10] + 0xffeff47d, 15);
    71f2:	ea68 0304 	orn	r3, r8, r4
    71f6:	406b      	eors	r3, r5
    71f8:	9a09      	ldr	r2, [sp, #36]	; 0x24
    71fa:	f5a2 1680 	sub.w	r6, r2, #1048576	; 0x100000
    71fe:	f6a6 3683 	subw	r6, r6, #2947	; 0xb83
    7202:	443e      	add	r6, r7
    7204:	4433      	add	r3, r6
    7206:	eb08 4373 	add.w	r3, r8, r3, ror #17
    MD5STEP(F4, b, c, d, a, buffer[1]  + 0x85845dd1, 21);
    720a:	ea63 0905 	orn	r9, r3, r5
    720e:	ea89 0908 	eor.w	r9, r9, r8
    7212:	4945      	ldr	r1, [pc, #276]	; (7328 <Transform+0x6ac>)
    7214:	9e00      	ldr	r6, [sp, #0]
    7216:	4431      	add	r1, r6
    7218:	440c      	add	r4, r1
    721a:	44a1      	add	r9, r4
    721c:	eb03 29f9 	add.w	r9, r3, r9, ror #11
    MD5STEP(F4, a, b, c, d, buffer[8]  + 0x6fa87e4f,  6);
    7220:	ea69 0608 	orn	r6, r9, r8
    7224:	405e      	eors	r6, r3
    7226:	4a41      	ldr	r2, [pc, #260]	; (732c <Transform+0x6b0>)
    7228:	9907      	ldr	r1, [sp, #28]
    722a:	440a      	add	r2, r1
    722c:	4415      	add	r5, r2
    722e:	442e      	add	r6, r5
    7230:	eb09 66b6 	add.w	r6, r9, r6, ror #26
    MD5STEP(F4, d, a, b, c, buffer[15] + 0xfe2ce6e0, 10);
    7234:	ea66 0103 	orn	r1, r6, r3
    7238:	ea81 0109 	eor.w	r1, r1, r9
    723c:	4a3c      	ldr	r2, [pc, #240]	; (7330 <Transform+0x6b4>)
    723e:	4472      	add	r2, lr
    7240:	4490      	add	r8, r2
    7242:	4441      	add	r1, r8
    7244:	eb06 51b1 	add.w	r1, r6, r1, ror #22
    MD5STEP(F4, c, d, a, b, buffer[6]  + 0xa3014314, 15);
    7248:	ea61 0409 	orn	r4, r1, r9
    724c:	4074      	eors	r4, r6
    724e:	4a39      	ldr	r2, [pc, #228]	; (7334 <Transform+0x6b8>)
    7250:	9d05      	ldr	r5, [sp, #20]
    7252:	442a      	add	r2, r5
    7254:	4413      	add	r3, r2
    7256:	441c      	add	r4, r3
    7258:	eb01 4474 	add.w	r4, r1, r4, ror #17
    MD5STEP(F4, b, c, d, a, buffer[13] + 0x4e0811a1, 21);
    725c:	ea64 0506 	orn	r5, r4, r6
    7260:	404d      	eors	r5, r1
    7262:	4b35      	ldr	r3, [pc, #212]	; (7338 <Transform+0x6bc>)
    7264:	4463      	add	r3, ip
    7266:	4499      	add	r9, r3
    7268:	444d      	add	r5, r9
    726a:	eb04 25f5 	add.w	r5, r4, r5, ror #11
    MD5STEP(F4, a, b, c, d, buffer[4]  + 0xf7537e82,  6);
    726e:	ea65 0701 	orn	r7, r5, r1
    7272:	4067      	eors	r7, r4
    7274:	4a31      	ldr	r2, [pc, #196]	; (733c <Transform+0x6c0>)
    7276:	9b03      	ldr	r3, [sp, #12]
    7278:	441a      	add	r2, r3
    727a:	4416      	add	r6, r2
    727c:	4437      	add	r7, r6
    727e:	eb05 67b7 	add.w	r7, r5, r7, ror #26
    MD5STEP(F4, d, a, b, c, buffer[11] + 0xbd3af235, 10);
    7282:	ea67 0304 	orn	r3, r7, r4
    7286:	406b      	eors	r3, r5
    7288:	4a2d      	ldr	r2, [pc, #180]	; (7340 <Transform+0x6c4>)
    728a:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    728c:	4432      	add	r2, r6
    728e:	4411      	add	r1, r2
    7290:	4419      	add	r1, r3
    7292:	eb07 51b1 	add.w	r1, r7, r1, ror #22
    MD5STEP(F4, c, d, a, b, buffer[2]  + 0x2ad7d2bb, 15);
    7296:	ea61 0605 	orn	r6, r1, r5
    729a:	407e      	eors	r6, r7
    729c:	4a29      	ldr	r2, [pc, #164]	; (7344 <Transform+0x6c8>)
    729e:	9b01      	ldr	r3, [sp, #4]
    72a0:	441a      	add	r2, r3
    72a2:	4414      	add	r4, r2
    72a4:	4434      	add	r4, r6
    72a6:	eb01 4474 	add.w	r4, r1, r4, ror #17
    MD5STEP(F4, b, c, d, a, buffer[9]  + 0xeb86d391, 21);

    /* Add the working vars back into digest state[]  */
    md5->digest[0] += a;
    72aa:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    72ac:	443b      	add	r3, r7
    72ae:	64c3      	str	r3, [r0, #76]	; 0x4c
    MD5STEP(F4, b, c, d, a, buffer[9]  + 0xeb86d391, 21);
    72b0:	ea64 0707 	orn	r7, r4, r7
    72b4:	404f      	eors	r7, r1
    72b6:	4b24      	ldr	r3, [pc, #144]	; (7348 <Transform+0x6cc>)
    72b8:	9a08      	ldr	r2, [sp, #32]
    72ba:	4413      	add	r3, r2
    72bc:	441d      	add	r5, r3
    72be:	442f      	add	r7, r5
    md5->digest[1] += b;
    72c0:	eb0a 0504 	add.w	r5, sl, r4
    72c4:	eb05 25f7 	add.w	r5, r5, r7, ror #11
    72c8:	6505      	str	r5, [r0, #80]	; 0x50
    md5->digest[2] += c;
    72ca:	6d43      	ldr	r3, [r0, #84]	; 0x54
    72cc:	441c      	add	r4, r3
    72ce:	6544      	str	r4, [r0, #84]	; 0x54
    md5->digest[3] += d;
    72d0:	6d83      	ldr	r3, [r0, #88]	; 0x58
    72d2:	4419      	add	r1, r3
    72d4:	6581      	str	r1, [r0, #88]	; 0x58

    return 0;
}
    72d6:	2000      	movs	r0, #0
    72d8:	b00d      	add	sp, #52	; 0x34
    72da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    72de:	bf00      	nop
    72e0:	a4beea44 	.word	0xa4beea44
    72e4:	4bdecfa9 	.word	0x4bdecfa9
    72e8:	f6bb4b60 	.word	0xf6bb4b60
    72ec:	bebfbc70 	.word	0xbebfbc70
    72f0:	289b7ec6 	.word	0x289b7ec6
    72f4:	eaa127fa 	.word	0xeaa127fa
    72f8:	d4ef3085 	.word	0xd4ef3085
    72fc:	04881d05 	.word	0x04881d05
    7300:	d9d4d039 	.word	0xd9d4d039
    7304:	e6db99e5 	.word	0xe6db99e5
    7308:	1fa27cf8 	.word	0x1fa27cf8
    730c:	c4ac5665 	.word	0xc4ac5665
    7310:	f4292244 	.word	0xf4292244
    7314:	432aff97 	.word	0x432aff97
    7318:	ab9423a7 	.word	0xab9423a7
    731c:	fc93a039 	.word	0xfc93a039
    7320:	655b59c3 	.word	0x655b59c3
    7324:	8f0ccc92 	.word	0x8f0ccc92
    7328:	85845dd1 	.word	0x85845dd1
    732c:	6fa87e4f 	.word	0x6fa87e4f
    7330:	fe2ce6e0 	.word	0xfe2ce6e0
    7334:	a3014314 	.word	0xa3014314
    7338:	4e0811a1 	.word	0x4e0811a1
    733c:	f7537e82 	.word	0xf7537e82
    7340:	bd3af235 	.word	0xbd3af235
    7344:	2ad7d2bb 	.word	0x2ad7d2bb
    7348:	eb86d391 	.word	0xeb86d391

Disassembly of section .text.TCPIP_STACK_Task%220:

0000734c <TCPIP_STACK_Task>:
#if defined(TCPIP_STACK_USE_EVENT_NOTIFICATION) && (TCPIP_STACK_USER_NOTIFICATION != 0)
    TCPIP_EVENT         tcpipEvent;
    TCPIP_EVENT_LIST_NODE* tNode;
#endif  // defined(TCPIP_STACK_USE_EVENT_NOTIFICATION) && (TCPIP_STACK_USER_NOTIFICATION != 0)   

    if(object != (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data)
    734c:	4bb2      	ldr	r3, [pc, #712]	; (7618 <TCPIP_STACK_Task+0x2cc>)
    734e:	4283      	cmp	r3, r0
    7350:	f040 82f9 	bne.w	7946 <TCPIP_STACK_Task+0x5fa>
    {   // invalid handle/nothing to do
        return;
    }

    if(tcpip_stack_status != SYS_STATUS_BUSY && tcpip_stack_status != SYS_STATUS_READY)
    7354:	4bb1      	ldr	r3, [pc, #708]	; (761c <TCPIP_STACK_Task+0x2d0>)
    7356:	f993 2000 	ldrsb.w	r2, [r3]
    735a:	1e53      	subs	r3, r2, #1
    735c:	b2db      	uxtb	r3, r3
    735e:	2b01      	cmp	r3, #1
    7360:	f200 82f1 	bhi.w	7946 <TCPIP_STACK_Task+0x5fa>
{
    7364:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7368:	b084      	sub	sp, #16
    {   // some error state
        return;
    }

    if(tcpipNetIf == 0)
    736a:	4bad      	ldr	r3, [pc, #692]	; (7620 <TCPIP_STACK_Task+0x2d4>)
    736c:	681b      	ldr	r3, [r3, #0]
    736e:	b163      	cbz	r3, 738a <TCPIP_STACK_Task+0x3e>
    int             aliasIx;
    TCPIP_NET_IF   *pAliasIf;
#endif  // (_TCPIP_STACK_ALIAS_INTERFACE_SUPPORT)

    // check that we've created the needed timer
    if(tcpip_stack_status == SYS_STATUS_BUSY && tcpip_stack_tickH == SYS_TMR_HANDLE_INVALID)
    7370:	2a01      	cmp	r2, #1
    7372:	d01b      	beq.n	73ac <TCPIP_STACK_Task+0x60>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Initialization SYS TMR failed: %d - Aborting! \r\n", tmrStat);
            return false;
        }
    }

    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    7374:	4baa      	ldr	r3, [pc, #680]	; (7620 <TCPIP_STACK_Task+0x2d4>)
    7376:	681c      	ldr	r4, [r3, #0]
    7378:	4ba7      	ldr	r3, [pc, #668]	; (7618 <TCPIP_STACK_Task+0x2cc>)
    737a:	681b      	ldr	r3, [r3, #0]
    737c:	2b00      	cmp	r3, #0
    737e:	f340 82d4 	ble.w	792a <TCPIP_STACK_Task+0x5de>
    7382:	2500      	movs	r5, #0
                    pNetIf->Flags.bMacInitDone = true;
                }
                else if(macStat == SYS_STATUS_READY)
                {   // get the MAC address and MAC processing flags
                    // set the default MTU; MAC driver will override if needed
                    TCPIP_MAC_PARAMETERS macParams = {{{0}}};
    7384:	462f      	mov	r7, r5
                    TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pNetIf, TCPIP_STACK_ACTION_IF_DOWN, TCPIP_MAC_POWER_DOWN);
    7386:	4ea4      	ldr	r6, [pc, #656]	; (7618 <TCPIP_STACK_Task+0x2cc>)
    7388:	e072      	b.n	7470 <TCPIP_STACK_Task+0x124>
        _TCPIP_InitCallback(tcpip_stack_init_cb);
    738a:	4ba6      	ldr	r3, [pc, #664]	; (7624 <TCPIP_STACK_Task+0x2d8>)
    int cRes = (*cback)(&pInit);
    738c:	681b      	ldr	r3, [r3, #0]
    738e:	4668      	mov	r0, sp
    7390:	4798      	blx	r3
    if(cRes > 0)
    7392:	2800      	cmp	r0, #0
    7394:	f300 82b4 	bgt.w	7900 <TCPIP_STACK_Task+0x5b4>
    if (cRes == 0 && pInit != 0)
    7398:	b920      	cbnz	r0, 73a4 <TCPIP_STACK_Task+0x58>
    739a:	9800      	ldr	r0, [sp, #0]
    739c:	b110      	cbz	r0, 73a4 <TCPIP_STACK_Task+0x58>
        _TCPIP_DoInitialize(pInit);
    739e:	f002 fa71 	bl	9884 <_TCPIP_DoInitialize>
    73a2:	e2ad      	b.n	7900 <TCPIP_STACK_Task+0x5b4>
        tcpip_stack_status = SYS_STATUS_UNINITIALIZED;
    73a4:	4b9d      	ldr	r3, [pc, #628]	; (761c <TCPIP_STACK_Task+0x2d0>)
    73a6:	2200      	movs	r2, #0
    73a8:	701a      	strb	r2, [r3, #0]
    73aa:	e2a9      	b.n	7900 <TCPIP_STACK_Task+0x5b4>
    if(tcpip_stack_status == SYS_STATUS_BUSY && tcpip_stack_tickH == SYS_TMR_HANDLE_INVALID)
    73ac:	4b9e      	ldr	r3, [pc, #632]	; (7628 <TCPIP_STACK_Task+0x2dc>)
    73ae:	681b      	ldr	r3, [r3, #0]
    73b0:	f1b3 3fff 	cmp.w	r3, #4294967295
    73b4:	d1de      	bne.n	7374 <TCPIP_STACK_Task+0x28>
    tcpip_stack_tickH = SYS_TMR_CallbackPeriodic(TCPIP_STACK_TICK_RATE, 0, _TCPIP_STACK_TickHandler);
    73b6:	4a9d      	ldr	r2, [pc, #628]	; (762c <TCPIP_STACK_Task+0x2e0>)
    73b8:	2100      	movs	r1, #0
    73ba:	2005      	movs	r0, #5
    73bc:	f01b ff50 	bl	23260 <SYS_TMR_CallbackPeriodic>
    73c0:	4b99      	ldr	r3, [pc, #612]	; (7628 <TCPIP_STACK_Task+0x2dc>)
    73c2:	6018      	str	r0, [r3, #0]
    if(tcpip_stack_tickH != SYS_TMR_HANDLE_INVALID)
    73c4:	f1b0 3fff 	cmp.w	r0, #4294967295
    73c8:	d025      	beq.n	7416 <TCPIP_STACK_Task+0xca>
        uint32_t sysRes = SYS_TMR_TickCounterFrequencyGet();
    73ca:	f01a ff5f 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
        uint32_t rateMs = ((sysRes * TCPIP_STACK_TICK_RATE) + 999 )/1000;    // round up
    73ce:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    73d2:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
    73d6:	4a96      	ldr	r2, [pc, #600]	; (7630 <TCPIP_STACK_Task+0x2e4>)
    73d8:	fba2 2303 	umull	r2, r3, r2, r3
    73dc:	099b      	lsrs	r3, r3, #6
        stackTaskRate = (rateMs * 1000) / sysRes;
    73de:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    73e2:	fb02 f303 	mul.w	r3, r2, r3
    73e6:	fbb3 f3f0 	udiv	r3, r3, r0
    73ea:	4a92      	ldr	r2, [pc, #584]	; (7634 <TCPIP_STACK_Task+0x2e8>)
    73ec:	6013      	str	r3, [r2, #0]
    for(modIx = TCPIP_MODULE_LAYER1; modIx < sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL)/sizeof(*TCPIP_STACK_MODULE_SIGNAL_TBL); modIx++, pSigEntry++)
    73ee:	2502      	movs	r5, #2
    pSigEntry = TCPIP_STACK_MODULE_SIGNAL_TBL + TCPIP_MODULE_LAYER1;
    73f0:	4c91      	ldr	r4, [pc, #580]	; (7638 <TCPIP_STACK_Task+0x2ec>)
    73f2:	e003      	b.n	73fc <TCPIP_STACK_Task+0xb0>
    for(modIx = TCPIP_MODULE_LAYER1; modIx < sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL)/sizeof(*TCPIP_STACK_MODULE_SIGNAL_TBL); modIx++, pSigEntry++)
    73f4:	3501      	adds	r5, #1
    73f6:	3410      	adds	r4, #16
    73f8:	2d27      	cmp	r5, #39	; 0x27
    73fa:	d0bb      	beq.n	7374 <TCPIP_STACK_Task+0x28>
        if(pSigEntry->signalHandler != 0 && pSigEntry->asyncTmo != 0)
    73fc:	6823      	ldr	r3, [r4, #0]
    73fe:	2b00      	cmp	r3, #0
    7400:	d0f8      	beq.n	73f4 <TCPIP_STACK_Task+0xa8>
    7402:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
    7406:	2a00      	cmp	r2, #0
    7408:	d0f4      	beq.n	73f4 <TCPIP_STACK_Task+0xa8>
            if(!_TCPIPStackSignalHandlerSetParams((TCPIP_STACK_MODULE)modIx, pSigEntry, pSigEntry->asyncTmo))
    740a:	4621      	mov	r1, r4
    740c:	b2a8      	uxth	r0, r5
    740e:	f01a fe89 	bl	22124 <_TCPIPStackSignalHandlerSetParams>
    7412:	2800      	cmp	r0, #0
    7414:	d1ee      	bne.n	73f4 <TCPIP_STACK_Task+0xa8>
        SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Tick registration failed: %d\r\n", TCPIP_STACK_TICK_RATE);
    7416:	f01c ff33 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    741a:	b988      	cbnz	r0, 7440 <TCPIP_STACK_Task+0xf4>
            TCPIP_STACK_KillStack();
    741c:	f010 fd00 	bl	17e20 <TCPIP_STACK_KillStack>
            tcpip_stack_status = SYS_STATUS_ERROR;
    7420:	4b7e      	ldr	r3, [pc, #504]	; (761c <TCPIP_STACK_Task+0x2d0>)
    7422:	22ff      	movs	r2, #255	; 0xff
    7424:	701a      	strb	r2, [r3, #0]
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Initialization SYS TMR failed: %d - Aborting! \r\n", tmrStat);
    7426:	f01c ff2b 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    742a:	2800      	cmp	r0, #0
    742c:	f000 8268 	beq.w	7900 <TCPIP_STACK_Task+0x5b4>
    7430:	f01c ff20 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    7434:	f04f 32ff 	mov.w	r2, #4294967295
    7438:	4980      	ldr	r1, [pc, #512]	; (763c <TCPIP_STACK_Task+0x2f0>)
    743a:	f015 f92f 	bl	1c69c <SYS_CONSOLE_Print>
    743e:	e25f      	b.n	7900 <TCPIP_STACK_Task+0x5b4>
        SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Tick registration failed: %d\r\n", TCPIP_STACK_TICK_RATE);
    7440:	f01c ff18 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    7444:	2205      	movs	r2, #5
    7446:	497e      	ldr	r1, [pc, #504]	; (7640 <TCPIP_STACK_Task+0x2f4>)
    7448:	f015 f928 	bl	1c69c <SYS_CONSOLE_Print>
    744c:	e7e6      	b.n	741c <TCPIP_STACK_Task+0xd0>
                    TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pNetIf, TCPIP_STACK_ACTION_IF_DOWN, TCPIP_MAC_POWER_DOWN);
    744e:	2303      	movs	r3, #3
    7450:	2204      	movs	r2, #4
    7452:	4621      	mov	r1, r4
    7454:	4630      	mov	r0, r6
    7456:	f015 fcc7 	bl	1cde8 <TCPIP_STACK_BringNetDown>
                    pNetIf->Flags.bMacInitDone = true;
    745a:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    745e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    7462:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    7466:	3501      	adds	r5, #1
    7468:	346c      	adds	r4, #108	; 0x6c
    746a:	6833      	ldr	r3, [r6, #0]
    746c:	429d      	cmp	r5, r3
    746e:	da42      	bge.n	74f6 <TCPIP_STACK_Task+0x1aa>
        if(pNetIf->macObjHandle != 0 && _TCPIPStackNetIsPrimary(pNetIf))
    7470:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    7472:	2800      	cmp	r0, #0
    7474:	d0f7      	beq.n	7466 <TCPIP_STACK_Task+0x11a>
            (*pNetIf->pMacObj->TCPIP_MAC_Tasks)(pNetIf->macObjHandle);
    7476:	6c63      	ldr	r3, [r4, #68]	; 0x44
    7478:	699b      	ldr	r3, [r3, #24]
    747a:	4798      	blx	r3
            if(pNetIf->Flags.bMacInitialize)
    747c:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    7480:	f013 0f40 	tst.w	r3, #64	; 0x40
    7484:	d0ef      	beq.n	7466 <TCPIP_STACK_Task+0x11a>
                SYS_STATUS macStat = (*pNetIf->pMacObj->TCPIP_MAC_Status)(pNetIf->macObjHandle);
    7486:	6c63      	ldr	r3, [r4, #68]	; 0x44
    7488:	695b      	ldr	r3, [r3, #20]
    748a:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    748c:	4798      	blx	r3
                if(macStat < 0)
    748e:	2800      	cmp	r0, #0
    7490:	dbdd      	blt.n	744e <TCPIP_STACK_Task+0x102>
                else if(macStat == SYS_STATUS_READY)
    7492:	2802      	cmp	r0, #2
    7494:	d1e7      	bne.n	7466 <TCPIP_STACK_Task+0x11a>
                    TCPIP_MAC_PARAMETERS macParams = {{{0}}};
    7496:	9700      	str	r7, [sp, #0]
    7498:	9701      	str	r7, [sp, #4]
    749a:	9702      	str	r7, [sp, #8]
    749c:	9703      	str	r7, [sp, #12]
                    macParams.linkMtu = TCPIP_MAC_LINK_MTU_DEFAULT; 
    749e:	f240 53dc 	movw	r3, #1500	; 0x5dc
    74a2:	f8ad 300a 	strh.w	r3, [sp, #10]
                    (*pNetIf->pMacObj->TCPIP_MAC_ParametersGet)(pNetIf->hIfMac, &macParams);
    74a6:	6c63      	ldr	r3, [r4, #68]	; 0x44
    74a8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    74aa:	4669      	mov	r1, sp
    74ac:	6d20      	ldr	r0, [r4, #80]	; 0x50
    74ae:	4798      	blx	r3
                    memcpy(pNetIf->netMACAddr.v, macParams.ifPhyAddress.v, sizeof(pNetIf->netMACAddr));
    74b0:	9800      	ldr	r0, [sp, #0]
    74b2:	63e0      	str	r0, [r4, #60]	; 0x3c
    74b4:	f8bd 3004 	ldrh.w	r3, [sp, #4]
    74b8:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
                    pNetIf->Flags.bMacProcessOnEvent = macParams.processFlags != TCPIP_MAC_PROCESS_FLAG_NONE;
    74bc:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    74c0:	3300      	adds	r3, #0
    74c2:	bf18      	it	ne
    74c4:	2301      	movne	r3, #1
    74c6:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
    74ca:	f363 1245 	bfi	r2, r3, #5, #1
    74ce:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
                    pNetIf->linkMtu = macParams.linkMtu;
    74d2:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    74d6:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
                    // enable this interface
                    pNetIf->Flags.bInterfaceEnabled = true;
    74da:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
    74de:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    74e2:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
                    pNetIf->Flags.bMacInitialize = false;
    74e6:	b2d3      	uxtb	r3, r2
                    pNetIf->Flags.bMacInitDone = true;
    74e8:	f003 03bf 	and.w	r3, r3, #191	; 0xbf
    74ec:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    74f0:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    74f4:	e7b7      	b.n	7466 <TCPIP_STACK_Task+0x11a>
            }
        }
    }

    // check we're getting out of Initialize procedure
    if(tcpip_stack_status == SYS_STATUS_BUSY)
    74f6:	4a49      	ldr	r2, [pc, #292]	; (761c <TCPIP_STACK_Task+0x2d0>)
    74f8:	f992 2000 	ldrsb.w	r2, [r2]
    74fc:	2a01      	cmp	r2, #1
    74fe:	d027      	beq.n	7550 <TCPIP_STACK_Task+0x204>
    _TCPIP_SelectDefaultNet(0);
    7500:	2000      	movs	r0, #0
    7502:	f015 febd 	bl	1d280 <_TCPIP_SelectDefaultNet>

// returns true if the stack needs processing time because of events
static bool TCPIP_STACK_CheckEventsPending(void)
{
#if defined(TCPIP_STACK_USE_EVENT_NOTIFICATION)
    return (newTcpipTickAvlbl != 0 || totTcpipEventsCnt != 0);
    7506:	4b4f      	ldr	r3, [pc, #316]	; (7644 <TCPIP_STACK_Task+0x2f8>)
    7508:	681b      	ldr	r3, [r3, #0]
    750a:	b933      	cbnz	r3, 751a <TCPIP_STACK_Task+0x1ce>
    750c:	4b4e      	ldr	r3, [pc, #312]	; (7648 <TCPIP_STACK_Task+0x2fc>)
    750e:	681a      	ldr	r2, [r3, #0]
    if(eventPending == 0 && stackAsyncSignalCount == 0)
    7510:	4b4e      	ldr	r3, [pc, #312]	; (764c <TCPIP_STACK_Task+0x300>)
    7512:	681b      	ldr	r3, [r3, #0]
    7514:	4313      	orrs	r3, r2
    7516:	f000 81f3 	beq.w	7900 <TCPIP_STACK_Task+0x5b4>
    if(newTcpipTickAvlbl != 0)
    751a:	4b4a      	ldr	r3, [pc, #296]	; (7644 <TCPIP_STACK_Task+0x2f8>)
    751c:	681b      	ldr	r3, [r3, #0]
    751e:	2b00      	cmp	r3, #0
    7520:	d16c      	bne.n	75fc <TCPIP_STACK_Task+0x2b0>
        wasTickEvent = false;
    7522:	2600      	movs	r6, #0
    if( totTcpipEventsCnt)
    7524:	4b48      	ldr	r3, [pc, #288]	; (7648 <TCPIP_STACK_Task+0x2fc>)
    7526:	681b      	ldr	r3, [r3, #0]
    7528:	2b00      	cmp	r3, #0
    752a:	f000 8166 	beq.w	77fa <TCPIP_STACK_Task+0x4ae>
        totTcpipEventsCnt = 0;
    752e:	4b46      	ldr	r3, [pc, #280]	; (7648 <TCPIP_STACK_Task+0x2fc>)
    7530:	2200      	movs	r2, #0
    7532:	601a      	str	r2, [r3, #0]
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    7534:	4b3a      	ldr	r3, [pc, #232]	; (7620 <TCPIP_STACK_Task+0x2d4>)
    7536:	681c      	ldr	r4, [r3, #0]
    7538:	4b37      	ldr	r3, [pc, #220]	; (7618 <TCPIP_STACK_Task+0x2cc>)
    753a:	681b      	ldr	r3, [r3, #0]
    753c:	4293      	cmp	r3, r2
    753e:	f340 80fc 	ble.w	773a <TCPIP_STACK_Task+0x3ee>
    7542:	4690      	mov	r8, r2
    return OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
    7544:	2701      	movs	r7, #1
                newTcpipStackEventCnt++;
    7546:	f8df a10c 	ldr.w	sl, [pc, #268]	; 7654 <TCPIP_STACK_Task+0x308>
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    754a:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 7618 <TCPIP_STACK_Task+0x2cc>
    754e:	e0c7      	b.n	76e0 <TCPIP_STACK_Task+0x394>
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    7550:	4a33      	ldr	r2, [pc, #204]	; (7620 <TCPIP_STACK_Task+0x2d4>)
    7552:	6816      	ldr	r6, [r2, #0]
    7554:	2b00      	cmp	r3, #0
    7556:	f340 81ee 	ble.w	7936 <TCPIP_STACK_Task+0x5ea>
    755a:	4631      	mov	r1, r6
        uint32_t    ifUpMask = 0;   // masks of interfaces that are up;
    755c:	2500      	movs	r5, #0
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    755e:	462a      	mov	r2, r5
                ifUpMask |= (1 << netIx);
    7560:	2701      	movs	r7, #1
    7562:	e006      	b.n	7572 <TCPIP_STACK_Task+0x226>
    7564:	fa07 f002 	lsl.w	r0, r7, r2
    7568:	4305      	orrs	r5, r0
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    756a:	3201      	adds	r2, #1
    756c:	316c      	adds	r1, #108	; 0x6c
    756e:	4293      	cmp	r3, r2
    7570:	d012      	beq.n	7598 <TCPIP_STACK_Task+0x24c>
            if(pPriIf->Flags.powerMode == TCPIP_MAC_POWER_FULL)
    7572:	f891 0043 	ldrb.w	r0, [r1, #67]	; 0x43
    7576:	f000 040c 	and.w	r4, r0, #12
    757a:	2c04      	cmp	r4, #4
    757c:	d1f2      	bne.n	7564 <TCPIP_STACK_Task+0x218>
                if(pPriIf->Flags.bMacInitDone == 0)
    757e:	f010 0f80 	tst.w	r0, #128	; 0x80
    7582:	f000 81bd 	beq.w	7900 <TCPIP_STACK_Task+0x5b4>
                else if(pPriIf->Flags.bInterfaceEnabled != 0)
    7586:	f891 0042 	ldrb.w	r0, [r1, #66]	; 0x42
    758a:	f010 0f40 	tst.w	r0, #64	; 0x40
    758e:	d0ec      	beq.n	756a <TCPIP_STACK_Task+0x21e>
                    ifUpMask |= (1 << netIx);
    7590:	fa07 f002 	lsl.w	r0, r7, r2
    7594:	4305      	orrs	r5, r0
    7596:	e7e8      	b.n	756a <TCPIP_STACK_Task+0x21e>
        if(ifUpMask == ((1 << netIx) - 1))
    7598:	2201      	movs	r2, #1
    759a:	fa02 f303 	lsl.w	r3, r2, r3
    759e:	3b01      	subs	r3, #1
    75a0:	42ab      	cmp	r3, r5
    75a2:	f000 81c8 	beq.w	7936 <TCPIP_STACK_Task+0x5ea>
            for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    75a6:	4b1c      	ldr	r3, [pc, #112]	; (7618 <TCPIP_STACK_Task+0x2cc>)
    75a8:	681b      	ldr	r3, [r3, #0]
    75aa:	2b00      	cmp	r3, #0
    75ac:	dd17      	ble.n	75de <TCPIP_STACK_Task+0x292>
    75ae:	2400      	movs	r4, #0
                if(pNetIf->Flags.bInterfaceEnabled || pNetIf->Flags.bMacInitialize)
    75b0:	f244 0840 	movw	r8, #16448	; 0x4040
                    TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pNetIf, TCPIP_STACK_ACTION_IF_DOWN, TCPIP_MAC_POWER_DOWN);
    75b4:	4f18      	ldr	r7, [pc, #96]	; (7618 <TCPIP_STACK_Task+0x2cc>)
    75b6:	f04f 0903 	mov.w	r9, #3
    75ba:	e004      	b.n	75c6 <TCPIP_STACK_Task+0x27a>
            for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    75bc:	3401      	adds	r4, #1
    75be:	366c      	adds	r6, #108	; 0x6c
    75c0:	683b      	ldr	r3, [r7, #0]
    75c2:	429c      	cmp	r4, r3
    75c4:	da0b      	bge.n	75de <TCPIP_STACK_Task+0x292>
                if(pNetIf->Flags.bInterfaceEnabled || pNetIf->Flags.bMacInitialize)
    75c6:	f8b6 3042 	ldrh.w	r3, [r6, #66]	; 0x42
    75ca:	ea18 0f03 	tst.w	r8, r3
    75ce:	d0f5      	beq.n	75bc <TCPIP_STACK_Task+0x270>
                    TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pNetIf, TCPIP_STACK_ACTION_IF_DOWN, TCPIP_MAC_POWER_DOWN);
    75d0:	464b      	mov	r3, r9
    75d2:	2204      	movs	r2, #4
    75d4:	4631      	mov	r1, r6
    75d6:	4638      	mov	r0, r7
    75d8:	f015 fc06 	bl	1cde8 <TCPIP_STACK_BringNetDown>
    75dc:	e7ee      	b.n	75bc <TCPIP_STACK_Task+0x270>
            tcpip_stack_status = SYS_STATUS_ERROR;
    75de:	4b0f      	ldr	r3, [pc, #60]	; (761c <TCPIP_STACK_Task+0x2d0>)
    75e0:	22ff      	movs	r2, #255	; 0xff
    75e2:	701a      	strb	r2, [r3, #0]
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Initialization failed: 0x%x - Aborting! \r\n", ifUpMask);
    75e4:	f01c fe4c 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    75e8:	2800      	cmp	r0, #0
    75ea:	f000 8189 	beq.w	7900 <TCPIP_STACK_Task+0x5b4>
    75ee:	f01c fe41 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    75f2:	462a      	mov	r2, r5
    75f4:	4916      	ldr	r1, [pc, #88]	; (7650 <TCPIP_STACK_Task+0x304>)
    75f6:	f015 f851 	bl	1c69c <SYS_CONSOLE_Print>
    75fa:	e181      	b.n	7900 <TCPIP_STACK_Task+0x5b4>
    newTcpipTickAvlbl = 0;
    75fc:	4b11      	ldr	r3, [pc, #68]	; (7644 <TCPIP_STACK_Task+0x2f8>)
    75fe:	2200      	movs	r2, #0
    7600:	601a      	str	r2, [r3, #0]
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    7602:	4b07      	ldr	r3, [pc, #28]	; (7620 <TCPIP_STACK_Task+0x2d4>)
    7604:	681c      	ldr	r4, [r3, #0]
    7606:	4b04      	ldr	r3, [pc, #16]	; (7618 <TCPIP_STACK_Task+0x2cc>)
    7608:	681b      	ldr	r3, [r3, #0]
    760a:	4293      	cmp	r3, r2
    760c:	f340 8182 	ble.w	7914 <TCPIP_STACK_Task+0x5c8>
    7610:	4615      	mov	r5, r2
    7612:	4e01      	ldr	r6, [pc, #4]	; (7618 <TCPIP_STACK_Task+0x2cc>)
    7614:	e025      	b.n	7662 <TCPIP_STACK_Task+0x316>
    7616:	bf00      	nop
    7618:	2000eae4 	.word	0x2000eae4
    761c:	2000ef8b 	.word	0x2000ef8b
    7620:	2000ee74 	.word	0x2000ee74
    7624:	2000ee78 	.word	0x2000ee78
    7628:	2000ee80 	.word	0x2000ee80
    762c:	00022035 	.word	0x00022035
    7630:	10624dd3 	.word	0x10624dd3
    7634:	2000ee6c 	.word	0x2000ee6c
    7638:	2000d9c4 	.word	0x2000d9c4
    763c:	000097bc 	.word	0x000097bc
    7640:	0000978c 	.word	0x0000978c
    7644:	2000ee64 	.word	0x2000ee64
    7648:	2000ee7c 	.word	0x2000ee7c
    764c:	2000ee68 	.word	0x2000ee68
    7650:	0000982c 	.word	0x0000982c
    7654:	2000ee60 	.word	0x2000ee60
    7658:	3501      	adds	r5, #1
    765a:	346c      	adds	r4, #108	; 0x6c
    765c:	6833      	ldr	r3, [r6, #0]
    765e:	429d      	cmp	r5, r3
    7660:	da19      	bge.n	7696 <TCPIP_STACK_Task+0x34a>
        if(pNetIf->Flags.bInterfaceEnabled)
    7662:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
    7666:	f013 0f40 	tst.w	r3, #64	; 0x40
    766a:	d0f5      	beq.n	7658 <TCPIP_STACK_Task+0x30c>
            linkCurr = (*pNetIf->pMacObj->TCPIP_MAC_LinkCheck)(pNetIf->hIfMac);     // check link status
    766c:	6c63      	ldr	r3, [r4, #68]	; 0x44
    766e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    7670:	6d20      	ldr	r0, [r4, #80]	; 0x50
    7672:	4798      	blx	r3
            linkPrev = pNetIf->exFlags.linkPrev != 0;
    7674:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
            if(linkPrev != linkCurr)
    7678:	f003 0301 	and.w	r3, r3, #1
    767c:	4298      	cmp	r0, r3
    767e:	d0eb      	beq.n	7658 <TCPIP_STACK_Task+0x30c>
                pNetIf->exFlags.connEvent = 1;
    7680:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
                pNetIf->exFlags.connEventType = linkCurr ? 1 : 0 ;
    7684:	f043 0302 	orr.w	r3, r3, #2
    7688:	f360 0382 	bfi	r3, r0, #2, #1
                pNetIf->exFlags.linkPrev = linkCurr;
    768c:	f360 0300 	bfi	r3, r0, #0, #1
    7690:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
    7694:	e7e0      	b.n	7658 <TCPIP_STACK_Task+0x30c>
        wasTickEvent = true;
    7696:	2601      	movs	r6, #1
    7698:	e744      	b.n	7524 <TCPIP_STACK_Task+0x1d8>
    769a:	2601      	movs	r6, #1
    769c:	e747      	b.n	752e <TCPIP_STACK_Task+0x1e2>
    while((pRxPkt = (*pNetIf->pMacObj->TCPIP_MAC_PacketRx)(pNetIf->hIfMac, 0, 0)) != 0)
    769e:	2500      	movs	r5, #0
    76a0:	e004      	b.n	76ac <TCPIP_STACK_Task+0x360>
    pRxPkt->pktIf = pNetIf;
    76a2:	628c      	str	r4, [r1, #40]	; 0x28
    _TCPIPStackModuleRxInsert(TCPIP_MODULE_MANAGER, pRxPkt, 0);
    76a4:	462a      	mov	r2, r5
    76a6:	4638      	mov	r0, r7
    76a8:	f017 fee8 	bl	1f47c <_TCPIPStackModuleRxInsert>
    while((pRxPkt = (*pNetIf->pMacObj->TCPIP_MAC_PacketRx)(pNetIf->hIfMac, 0, 0)) != 0)
    76ac:	6c63      	ldr	r3, [r4, #68]	; 0x44
    76ae:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    76b0:	462a      	mov	r2, r5
    76b2:	4629      	mov	r1, r5
    76b4:	6d20      	ldr	r0, [r4, #80]	; 0x50
    76b6:	4798      	blx	r3
    76b8:	4601      	mov	r1, r0
    76ba:	2800      	cmp	r0, #0
    76bc:	d1f1      	bne.n	76a2 <TCPIP_STACK_Task+0x356>
                newTcpipStackEventCnt++;
    76be:	f8da 3000 	ldr.w	r3, [sl]
    76c2:	3301      	adds	r3, #1
    76c4:	f8ca 3000 	str.w	r3, [sl]
    76c8:	e031      	b.n	772e <TCPIP_STACK_Task+0x3e2>
                (*pNetIf->pMacObj->TCPIP_MAC_Process)(pNetIf->hIfMac);
    76ca:	6c63      	ldr	r3, [r4, #68]	; 0x44
    76cc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    76ce:	6d20      	ldr	r0, [r4, #80]	; 0x50
    76d0:	4798      	blx	r3
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    76d2:	f108 0801 	add.w	r8, r8, #1
    76d6:	346c      	adds	r4, #108	; 0x6c
    76d8:	f8d9 3000 	ldr.w	r3, [r9]
    76dc:	4543      	cmp	r3, r8
    76de:	dd2c      	ble.n	773a <TCPIP_STACK_Task+0x3ee>
            if (!pNetIf->Flags.bInterfaceEnabled || !_TCPIPStackNetIsPrimary(pNetIf))
    76e0:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
    76e4:	f013 0f40 	tst.w	r3, #64	; 0x40
    76e8:	d0f3      	beq.n	76d2 <TCPIP_STACK_Task+0x386>
            activeEvents =  pNetIf->activeEvents;
    76ea:	f8b4 505a 	ldrh.w	r5, [r4, #90]	; 0x5a
            activeEvents |= (*pNetIf->pMacObj->TCPIP_MAC_EventPendingGet)(pNetIf->hIfMac);
    76ee:	6c63      	ldr	r3, [r4, #68]	; 0x44
    76f0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    76f2:	6d20      	ldr	r0, [r4, #80]	; 0x50
    76f4:	4798      	blx	r3
    76f6:	4305      	orrs	r5, r0
    76f8:	b2ad      	uxth	r5, r5
    return OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
    76fa:	4638      	mov	r0, r7
    76fc:	f01c f83a 	bl	23774 <OSAL_CRIT_Enter>
    pNetIf->activeEvents &= ~event;
    7700:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
    7704:	ea23 0305 	bic.w	r3, r3, r5
    7708:	f8a4 305a 	strh.w	r3, [r4, #90]	; 0x5a
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, suspLevel);
    770c:	4601      	mov	r1, r0
    770e:	4638      	mov	r0, r7
    7710:	f01c f96a 	bl	239e8 <OSAL_CRIT_Leave>
            pNetIf->currEvents |= activeEvents;     // store all the processed events
    7714:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
    7718:	432b      	orrs	r3, r5
    771a:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
            (*pNetIf->pMacObj->TCPIP_MAC_EventAcknowledge)(pNetIf->hIfMac, activeEvents);
    771e:	6c63      	ldr	r3, [r4, #68]	; 0x44
    7720:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    7722:	4629      	mov	r1, r5
    7724:	6d20      	ldr	r0, [r4, #80]	; 0x50
    7726:	4798      	blx	r3
            if((activeEvents & (TCPIP_STACK_MAC_ACTIVE_RX_EVENTS)) != 0)
    7728:	f015 0f16 	tst.w	r5, #22
    772c:	d1b7      	bne.n	769e <TCPIP_STACK_Task+0x352>
            if(pNetIf->Flags.bMacProcessOnEvent != 0)
    772e:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    7732:	f013 0f20 	tst.w	r3, #32
    7736:	d0cc      	beq.n	76d2 <TCPIP_STACK_Task+0x386>
    7738:	e7c7      	b.n	76ca <TCPIP_STACK_Task+0x37e>
    uint32_t                    procFrameMask = 0;
    773a:	2500      	movs	r5, #0
    while((pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(pPktQueue)))
    773c:	4c82      	ldr	r4, [pc, #520]	; (7948 <TCPIP_STACK_Task+0x5fc>)
        pFrameEntry = TCPIP_FRAME_PROCESS_TBL;
    773e:	4f83      	ldr	r7, [pc, #524]	; (794c <TCPIP_STACK_Task+0x600>)
        for(frameIx = 0; frameIx < sizeof(TCPIP_FRAME_PROCESS_TBL) / sizeof(*TCPIP_FRAME_PROCESS_TBL); frameIx++, pFrameEntry++)
    7740:	f107 0806 	add.w	r8, r7, #6
    while((pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(pPktQueue)))
    7744:	4620      	mov	r0, r4
    7746:	f01b fc8f 	bl	23068 <TCPIP_Helper_SingleListHeadRemove>
    774a:	4684      	mov	ip, r0
    774c:	2800      	cmp	r0, #0
    774e:	d048      	beq.n	77e2 <TCPIP_STACK_Task+0x496>
        frameType = TCPIP_Helper_ntohs(pMacHdr->Type);
    7750:	f8dc 3014 	ldr.w	r3, [ip, #20]
    7754:	899a      	ldrh	r2, [r3, #12]
       return (((hShort) << 8) | ((hShort) >> 8));
    7756:	0a13      	lsrs	r3, r2, #8
    7758:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    775c:	b29b      	uxth	r3, r3
            if(pFrameEntry->frameType == frameType)
    775e:	f640 0206 	movw	r2, #2054	; 0x806
    7762:	4293      	cmp	r3, r2
    7764:	d016      	beq.n	7794 <TCPIP_STACK_Task+0x448>
    7766:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
    776a:	d00a      	beq.n	7782 <TCPIP_STACK_Task+0x436>
    776c:	f64f 72ff 	movw	r2, #65535	; 0xffff
    7770:	4293      	cmp	r3, r2
    7772:	d00a      	beq.n	778a <TCPIP_STACK_Task+0x43e>
            TCPIP_PKT_PacketAcknowledge(pRxPkt, TCPIP_MAC_PKT_ACK_TYPE_ERR); 
    7774:	2201      	movs	r2, #1
    7776:	f06f 010c 	mvn.w	r1, #12
    777a:	4660      	mov	r0, ip
    777c:	f018 f992 	bl	1faa4 <_TCPIP_PKT_PacketAcknowledge>
    7780:	e7e0      	b.n	7744 <TCPIP_STACK_Task+0x3f8>
        for(frameIx = 0; frameIx < sizeof(TCPIP_FRAME_PROCESS_TBL) / sizeof(*TCPIP_FRAME_PROCESS_TBL); frameIx++, pFrameEntry++)
    7782:	46c1      	mov	r9, r8
    7784:	f04f 0a01 	mov.w	sl, #1
    7788:	e007      	b.n	779a <TCPIP_STACK_Task+0x44e>
    778a:	f107 090c 	add.w	r9, r7, #12
    778e:	f04f 0a02 	mov.w	sl, #2
    7792:	e002      	b.n	779a <TCPIP_STACK_Task+0x44e>
    7794:	f04f 0a00 	mov.w	sl, #0
        pFrameEntry = TCPIP_FRAME_PROCESS_TBL;
    7798:	46b9      	mov	r9, r7
                pRxPkt->pktFlags &= ~TCPIP_MAC_PKT_FLAG_TYPE_MASK;
    779a:	f8bc 3022 	ldrh.w	r3, [ip, #34]	; 0x22
    779e:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
    77a2:	b29b      	uxth	r3, r3
    77a4:	f8ac 3022 	strh.w	r3, [ip, #34]	; 0x22
                pRxPkt->pktFlags |= pFrameEntry->pktTypeFlags;
    77a8:	f8b9 2002 	ldrh.w	r2, [r9, #2]
    77ac:	4313      	orrs	r3, r2
    77ae:	f8ac 3022 	strh.w	r3, [ip, #34]	; 0x22
                _TCPIPStackModuleRxInsert(pFrameEntry->moduleId, pRxPkt, 0);
    77b2:	2200      	movs	r2, #0
    77b4:	4661      	mov	r1, ip
    77b6:	f8b9 0004 	ldrh.w	r0, [r9, #4]
    77ba:	f017 fe5f 	bl	1f47c <_TCPIPStackModuleRxInsert>
                    if((procFrameMask & (1 << frameIx)) == 0)
    77be:	2301      	movs	r3, #1
    77c0:	fa03 fa0a 	lsl.w	sl, r3, sl
    77c4:	ea1a 0f05 	tst.w	sl, r5
    77c8:	d1bc      	bne.n	7744 <TCPIP_STACK_Task+0x3f8>
                        procFrameMask |= 1 << frameIx;
    77ca:	ea45 050a 	orr.w	r5, r5, sl
    return TCPIP_STACK_MODULE_SIGNAL_TBL + modId;
    77ce:	f8b9 0004 	ldrh.w	r0, [r9, #4]
    _TCPIPSignalEntrySetNotify(_TCPIPModuleToSignalEntry(modId), signals, 0);
    77d2:	2200      	movs	r2, #0
    77d4:	4619      	mov	r1, r3
    77d6:	4b5e      	ldr	r3, [pc, #376]	; (7950 <TCPIP_STACK_Task+0x604>)
    77d8:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    77dc:	f01a fc3e 	bl	2205c <_TCPIPSignalEntrySetNotify>
    77e0:	e7b0      	b.n	7744 <TCPIP_STACK_Task+0x3f8>
    tmoMask = clrMask & TCPIP_MODULE_SIGNAL_TMO;
    rxMask = clrMask & TCPIP_MODULE_SIGNAL_RX_PENDING;


    // protect against ISRs (MAC + TMR) and other threads too!
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
    77e2:	2001      	movs	r0, #1
    77e4:	f01b ffc6 	bl	23774 <OSAL_CRIT_Enter>
    {
        pTmoEntry->signalVal &= (uint16_t)(~TCPIP_MODULE_SIGNAL_TMO);
    }
    if(rxMask)
    {
        pMgrEntry->signalVal &= (uint16_t)(~TCPIP_MODULE_SIGNAL_RX_PENDING);
    77e8:	4a59      	ldr	r2, [pc, #356]	; (7950 <TCPIP_STACK_Task+0x604>)
    77ea:	8b13      	ldrh	r3, [r2, #24]
    77ec:	f023 0301 	bic.w	r3, r3, #1
    77f0:	8313      	strh	r3, [r2, #24]
    }
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, critSect);
    77f2:	4601      	mov	r1, r0
    77f4:	2001      	movs	r0, #1
    77f6:	f01c f8f7 	bl	239e8 <OSAL_CRIT_Leave>
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    77fa:	4b56      	ldr	r3, [pc, #344]	; (7954 <TCPIP_STACK_Task+0x608>)
    77fc:	681c      	ldr	r4, [r3, #0]
    77fe:	4b56      	ldr	r3, [pc, #344]	; (7958 <TCPIP_STACK_Task+0x60c>)
    7800:	681b      	ldr	r3, [r3, #0]
    7802:	2b00      	cmp	r3, #0
    7804:	dd35      	ble.n	7872 <TCPIP_STACK_Task+0x526>
    7806:	2500      	movs	r5, #0
        if((activeEvents & TCPIP_MAC_EV_RXTX_ERRORS) != 0)
    7808:	f240 6886 	movw	r8, #1670	; 0x686
    newTcpipErrorEventCnt++;
    780c:	f8df 9168 	ldr.w	r9, [pc, #360]	; 7978 <TCPIP_STACK_Task+0x62c>
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    7810:	4f51      	ldr	r7, [pc, #324]	; (7958 <TCPIP_STACK_Task+0x60c>)
    7812:	e00c      	b.n	782e <TCPIP_STACK_Task+0x4e2>
        if(pNetIf->exFlags.connEvent != 0)
    7814:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
    7818:	f012 0f02 	tst.w	r2, #2
    781c:	d117      	bne.n	784e <TCPIP_STACK_Task+0x502>
        pNetIf->currEvents = 0;
    781e:	2300      	movs	r3, #0
    7820:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    7824:	3501      	adds	r5, #1
    7826:	346c      	adds	r4, #108	; 0x6c
    7828:	683b      	ldr	r3, [r7, #0]
    782a:	42ab      	cmp	r3, r5
    782c:	dd21      	ble.n	7872 <TCPIP_STACK_Task+0x526>
        if (!pNetIf->Flags.bInterfaceEnabled || !_TCPIPStackNetIsPrimary(pNetIf))
    782e:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
    7832:	f013 0f40 	tst.w	r3, #64	; 0x40
    7836:	d0f5      	beq.n	7824 <TCPIP_STACK_Task+0x4d8>
        activeEvents = pNetIf->currEvents;
    7838:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
        if((activeEvents & TCPIP_MAC_EV_RXTX_ERRORS) != 0)
    783c:	ea13 0f08 	tst.w	r3, r8
    7840:	d0e8      	beq.n	7814 <TCPIP_STACK_Task+0x4c8>
    newTcpipErrorEventCnt++;
    7842:	f8d9 2000 	ldr.w	r2, [r9]
    7846:	3201      	adds	r2, #1
    7848:	f8c9 2000 	str.w	r2, [r9]
    784c:	e7e2      	b.n	7814 <TCPIP_STACK_Task+0x4c8>
            activeEvents |= pNetIf->exFlags.connEventType ? TCPIP_MAC_EV_CONN_ESTABLISHED : TCPIP_MAC_EV_CONN_LOST;
    784e:	f012 0f04 	tst.w	r2, #4
    7852:	bf14      	ite	ne
    7854:	f44f 6100 	movne.w	r1, #2048	; 0x800
    7858:	f44f 5180 	moveq.w	r1, #4096	; 0x1000
            pNetIf->exFlags.connEvent = 0;
    785c:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
    7860:	f36f 0241 	bfc	r2, #1, #1
    7864:	f884 2060 	strb.w	r2, [r4, #96]	; 0x60
                    (*TCPIP_STACK_CONN_EVENT_TBL[modIx])(pAliasIf, activeEvents);
    7868:	4319      	orrs	r1, r3
    786a:	4620      	mov	r0, r4
    786c:	f014 fa80 	bl	1bd70 <TCPIP_DHCP_ConnectionHandler>
    7870:	e7d5      	b.n	781e <TCPIP_STACK_Task+0x4d2>
    if(wasTickEvent)
    7872:	2e00      	cmp	r6, #0
    7874:	d153      	bne.n	791e <TCPIP_STACK_Task+0x5d2>
    7876:	4b36      	ldr	r3, [pc, #216]	; (7950 <TCPIP_STACK_Task+0x604>)
    7878:	f103 0430 	add.w	r4, r3, #48	; 0x30
    787c:	f503 7820 	add.w	r8, r3, #640	; 0x280
        critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    7880:	2600      	movs	r6, #0
    7882:	e029      	b.n	78d8 <TCPIP_STACK_Task+0x58c>
            continue;
        }

        if((pSigEntry->currTmo -= stackTaskRate) <= 0)
        {   // timeout: send a signal to this module
            pSigEntry->currTmo += pSigEntry->asyncTmo;
    7884:	4413      	add	r3, r2
    7886:	81a3      	strh	r3, [r4, #12]
            _TCPIPSignalEntrySetNotify(pSigEntry, TCPIP_MODULE_SIGNAL_TMO, 0); 
    7888:	463a      	mov	r2, r7
    788a:	2102      	movs	r1, #2
    788c:	4620      	mov	r0, r4
    788e:	f01a fbe5 	bl	2205c <_TCPIPSignalEntrySetNotify>
    for(ix = TCPIP_MODULE_LAYER1; ix < sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL)/sizeof(*TCPIP_STACK_MODULE_SIGNAL_TBL); ix++, pSigEntry++)
    7892:	3410      	adds	r4, #16
    7894:	42ac      	cmp	r4, r5
    7896:	d00f      	beq.n	78b8 <TCPIP_STACK_Task+0x56c>
        if(pSigEntry->signalHandler == 0 || pSigEntry->asyncTmo == 0)
    7898:	6823      	ldr	r3, [r4, #0]
    789a:	2b00      	cmp	r3, #0
    789c:	d0f9      	beq.n	7892 <TCPIP_STACK_Task+0x546>
    789e:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
    78a2:	2a00      	cmp	r2, #0
    78a4:	d0f5      	beq.n	7892 <TCPIP_STACK_Task+0x546>
        if((pSigEntry->currTmo -= stackTaskRate) <= 0)
    78a6:	6831      	ldr	r1, [r6, #0]
    78a8:	89a3      	ldrh	r3, [r4, #12]
    78aa:	1a5b      	subs	r3, r3, r1
    78ac:	b29b      	uxth	r3, r3
    78ae:	b219      	sxth	r1, r3
    78b0:	2900      	cmp	r1, #0
    78b2:	dde7      	ble.n	7884 <TCPIP_STACK_Task+0x538>
    78b4:	81a1      	strh	r1, [r4, #12]
    78b6:	e7ec      	b.n	7892 <TCPIP_STACK_Task+0x546>
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
    78b8:	2001      	movs	r0, #1
    78ba:	f01b ff5b 	bl	23774 <OSAL_CRIT_Enter>
        pTmoEntry->signalVal &= (uint16_t)(~TCPIP_MODULE_SIGNAL_TMO);
    78be:	4a24      	ldr	r2, [pc, #144]	; (7950 <TCPIP_STACK_Task+0x604>)
    78c0:	8913      	ldrh	r3, [r2, #8]
    78c2:	f023 0302 	bic.w	r3, r3, #2
    78c6:	8113      	strh	r3, [r2, #8]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, critSect);
    78c8:	4601      	mov	r1, r0
    78ca:	2001      	movs	r0, #1
    78cc:	f01c f88c 	bl	239e8 <OSAL_CRIT_Leave>
    return mgrSignal;
    78d0:	e7d1      	b.n	7876 <TCPIP_STACK_Task+0x52a>
    78d2:	3410      	adds	r4, #16
    for(modIx = TCPIP_MODULE_LAYER1; modIx < sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL)/sizeof(*TCPIP_STACK_MODULE_SIGNAL_TBL); modIx++, pSigEntry++)
    78d4:	4544      	cmp	r4, r8
    78d6:	d010      	beq.n	78fa <TCPIP_STACK_Task+0x5ae>
        critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    78d8:	4630      	mov	r0, r6
    78da:	f01b ff4b 	bl	23774 <OSAL_CRIT_Enter>
        signalHandler = pSigEntry->signalHandler;
    78de:	f854 5c10 	ldr.w	r5, [r4, #-16]
        signalVal = pSigEntry->signalVal;
    78e2:	f834 7c08 	ldrh.w	r7, [r4, #-8]
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
    78e6:	4601      	mov	r1, r0
    78e8:	4630      	mov	r0, r6
    78ea:	f01c f87d 	bl	239e8 <OSAL_CRIT_Leave>
        if(signalHandler == 0 || signalVal == 0)
    78ee:	2d00      	cmp	r5, #0
    78f0:	d0ef      	beq.n	78d2 <TCPIP_STACK_Task+0x586>
    78f2:	2f00      	cmp	r7, #0
    78f4:	d0ed      	beq.n	78d2 <TCPIP_STACK_Task+0x586>
        (*signalHandler)();
    78f6:	47a8      	blx	r5
    78f8:	e7eb      	b.n	78d2 <TCPIP_STACK_Task+0x586>
    if(stackAsyncSignalCount != 0)
    78fa:	4b18      	ldr	r3, [pc, #96]	; (795c <TCPIP_STACK_Task+0x610>)
    78fc:	681b      	ldr	r3, [r3, #0]
    78fe:	b913      	cbnz	r3, 7906 <TCPIP_STACK_Task+0x5ba>
}
    7900:	b004      	add	sp, #16
    7902:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        _TCPIPSignalEntryNotify(_TCPIPModuleToSignalEntry(TCPIP_MODULE_MANAGER), TCPIP_MODULE_SIGNAL_ASYNC, 0);
    7906:	2200      	movs	r2, #0
    7908:	f44f 7180 	mov.w	r1, #256	; 0x100
    790c:	4814      	ldr	r0, [pc, #80]	; (7960 <TCPIP_STACK_Task+0x614>)
    790e:	f01b fbc7 	bl	230a0 <_TCPIPSignalEntryNotify>
    7912:	e7f5      	b.n	7900 <TCPIP_STACK_Task+0x5b4>
    if( totTcpipEventsCnt)
    7914:	4b13      	ldr	r3, [pc, #76]	; (7964 <TCPIP_STACK_Task+0x618>)
    7916:	681b      	ldr	r3, [r3, #0]
    7918:	2b00      	cmp	r3, #0
    791a:	f47f aebe 	bne.w	769a <TCPIP_STACK_Task+0x34e>
    pSigEntry = TCPIP_STACK_MODULE_SIGNAL_TBL + TCPIP_MODULE_LAYER1;
    791e:	4c12      	ldr	r4, [pc, #72]	; (7968 <TCPIP_STACK_Task+0x61c>)
        if((pSigEntry->currTmo -= stackTaskRate) <= 0)
    7920:	4e12      	ldr	r6, [pc, #72]	; (796c <TCPIP_STACK_Task+0x620>)
            _TCPIPSignalEntrySetNotify(pSigEntry, TCPIP_MODULE_SIGNAL_TMO, 0); 
    7922:	2700      	movs	r7, #0
    for(ix = TCPIP_MODULE_LAYER1; ix < sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL)/sizeof(*TCPIP_STACK_MODULE_SIGNAL_TBL); ix++, pSigEntry++)
    7924:	f504 7514 	add.w	r5, r4, #592	; 0x250
    7928:	e7b6      	b.n	7898 <TCPIP_STACK_Task+0x54c>
    if(tcpip_stack_status == SYS_STATUS_BUSY)
    792a:	4b11      	ldr	r3, [pc, #68]	; (7970 <TCPIP_STACK_Task+0x624>)
    792c:	f993 3000 	ldrsb.w	r3, [r3]
    7930:	2b01      	cmp	r3, #1
    7932:	f47f ade5 	bne.w	7500 <TCPIP_STACK_Task+0x1b4>
            tcpip_stack_status = SYS_STATUS_READY;
    7936:	4b0e      	ldr	r3, [pc, #56]	; (7970 <TCPIP_STACK_Task+0x624>)
    7938:	2202      	movs	r2, #2
    793a:	701a      	strb	r2, [r3, #0]
            SYS_CONSOLE_MESSAGE(TCPIP_STACK_HDR_MESSAGE "Initialization Ended - success \r\n");
    793c:	490d      	ldr	r1, [pc, #52]	; (7974 <TCPIP_STACK_Task+0x628>)
    793e:	2000      	movs	r0, #0
    7940:	f019 fda4 	bl	2148c <SYS_CONSOLE_Message>
    7944:	e5dc      	b.n	7500 <TCPIP_STACK_Task+0x1b4>
    7946:	4770      	bx	lr
    7948:	2000e660 	.word	0x2000e660
    794c:	00023744 	.word	0x00023744
    7950:	2000d9a4 	.word	0x2000d9a4
    7954:	2000ee74 	.word	0x2000ee74
    7958:	2000eae4 	.word	0x2000eae4
    795c:	2000ee68 	.word	0x2000ee68
    7960:	2000d9b4 	.word	0x2000d9b4
    7964:	2000ee7c 	.word	0x2000ee7c
    7968:	2000d9c4 	.word	0x2000d9c4
    796c:	2000ee6c 	.word	0x2000ee6c
    7970:	2000ef8b 	.word	0x2000ef8b
    7974:	000097fc 	.word	0x000097fc
    7978:	2000ee5c 	.word	0x2000ee5c

Disassembly of section .text.CommandIperfStart%221:

0000797c <CommandIperfStart>:
	}
	return 0;
}

static void CommandIperfStart(SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char** argv)
{
    797c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7980:	b08d      	sub	sp, #52	; 0x34
    7982:	4682      	mov	sl, r0
    7984:	468b      	mov	fp, r1
    uint32_t tickFreq;
    uint32_t values[4], bw=0;
    
    float pktRate;
    uint16_t payloadSize = 0, asciTos;
    const void* cmdIoParam = pCmdIO->cmdIoParam;
    7986:	6843      	ldr	r3, [r0, #4]
    7988:	9302      	str	r3, [sp, #8]
    for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
    798a:	4bae      	ldr	r3, [pc, #696]	; (7c44 <CommandIperfStart+0x2c8>)
    798c:	6819      	ldr	r1, [r3, #0]
    798e:	2900      	cmp	r1, #0
    7990:	f340 82ba 	ble.w	7f08 <CommandIperfStart+0x58c>
    7994:	4691      	mov	r9, r2
		if(pIState->state == (uint8_t)IPERF_STANDBY_STATE)
    7996:	4bac      	ldr	r3, [pc, #688]	; (7c48 <CommandIperfStart+0x2cc>)
    7998:	f893 30ce 	ldrb.w	r3, [r3, #206]	; 0xce
    799c:	2b01      	cmp	r3, #1
    799e:	f000 82ba 	beq.w	7f16 <CommandIperfStart+0x59a>
    for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
    79a2:	2300      	movs	r3, #0
    79a4:	4da8      	ldr	r5, [pc, #672]	; (7c48 <CommandIperfStart+0x2cc>)
    79a6:	3301      	adds	r3, #1
    79a8:	35d8      	adds	r5, #216	; 0xd8
    79aa:	428b      	cmp	r3, r1
    79ac:	f000 82ac 	beq.w	7f08 <CommandIperfStart+0x58c>
		if(pIState->state == (uint8_t)IPERF_STANDBY_STATE)
    79b0:	f895 20ce 	ldrb.w	r2, [r5, #206]	; 0xce
    79b4:	2a01      	cmp	r2, #1
    79b6:	d1f6      	bne.n	79a6 <CommandIperfStart+0x2a>
    {
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "\r\niperf: All instances busy. Retry later!\r\n");
        return;
    }

    (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: Starting session instance %d\r\n", pIState - gIperfState);
    79b8:	4ba3      	ldr	r3, [pc, #652]	; (7c48 <CommandIperfStart+0x2cc>)
    79ba:	1aeb      	subs	r3, r5, r3
    79bc:	10db      	asrs	r3, r3, #3
    79be:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
    79c2:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    79c6:	ebc3 2343 	rsb	r3, r3, r3, lsl #9
    79ca:	eb03 4383 	add.w	r3, r3, r3, lsl #18
    79ce:	f8da 2000 	ldr.w	r2, [sl]
    79d2:	6854      	ldr	r4, [r2, #4]
    79d4:	425a      	negs	r2, r3
    79d6:	499d      	ldr	r1, [pc, #628]	; (7c4c <CommandIperfStart+0x2d0>)
    79d8:	9802      	ldr	r0, [sp, #8]
    79da:	47a0      	blx	r4

	// preparation for new iperf test
    pIState->mServerMode = false;
    79dc:	2400      	movs	r4, #0
    79de:	f885 40d1 	strb.w	r4, [r5, #209]	; 0xd1
#if defined(TCPIP_STACK_USE_TCP)
    pIState->mProtocol = TCP_PROTOCOL;   			// default is TCP mode.
    79e2:	2302      	movs	r3, #2
    79e4:	742b      	strb	r3, [r5, #16]
#else
    pIState->mProtocol = UDP_PROTOCOL;
#endif  // defined(TCPIP_STACK_USE_TCP)
    pIState->stopRequested = false;
    79e6:	f885 40cf 	strb.w	r4, [r5, #207]	; 0xcf

    pIState->mServerPort = TCPIP_IPERF_SERVER_PORT;		// -p. default: server port 5001
    79ea:	f241 3389 	movw	r3, #5001	; 0x1389
    79ee:	826b      	strh	r3, [r5, #18]

    pIState->mTxRate = ((uint32_t) TCPIP_IPERF_TX_BW_LIMIT*1000)*((uint32_t) 1000);		// -b or -x. Target tx rate.
    79f0:	4b97      	ldr	r3, [pc, #604]	; (7c50 <CommandIperfStart+0x2d4>)
    79f2:	61ab      	str	r3, [r5, #24]
    // KS: default tx rate for iperf is actually 1Mbps.

    tickFreq = SYS_TMR_TickCounterFrequencyGet(); 
    79f4:	f01a fc4a 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    79f8:	9004      	str	r0, [sp, #16]
    pIState->mAmount = 0;			// -n: default 0.
    79fa:	606c      	str	r4, [r5, #4]
    pIState->mDuration = ((uint32_t) 10)*(tickFreq); // -t: default 10 sec.
    79fc:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    7a00:	005b      	lsls	r3, r3, #1
    7a02:	60ab      	str	r3, [r5, #8]
    pIState->mInterval =  tickFreq; 	// -i: default 1 sec.
    7a04:	6028      	str	r0, [r5, #0]

    pIState->mTypeOfService = 0;       //-S, --tos (Type Of Service): default 0: BestEffort
    7a06:	752c      	strb	r4, [r5, #20]
    // remember the console we've been invoked from
    pIState->pCmdIO = pCmdIO;
    7a08:	f8c5 a0c4 	str.w	sl, [r5, #196]	; 0xc4

    
    // Initialize statistics

    ResetIperfCounters(pIState);
    7a0c:	4628      	mov	r0, r5
    7a0e:	f016 fee5 	bl	1e7dc <ResetIperfCounters>

    for (i = 1; i < argc; i++)
    7a12:	f1bb 0f01 	cmp.w	fp, #1
    7a16:	f340 81e1 	ble.w	7ddc <CommandIperfStart+0x460>
    7a1a:	2401      	movs	r4, #1
    {
        if ((memcmp(argv[i], "-s", 2) == 0) || (memcmp(argv[i], "--server", 5) == 0) )
    7a1c:	4e8d      	ldr	r6, [pc, #564]	; (7c54 <CommandIperfStart+0x2d8>)
                 mpf2 = mpf2/10;
    7a1e:	f8cd a00c 	str.w	sl, [sp, #12]
    7a22:	e007      	b.n	7a34 <CommandIperfStart+0xb8>
        {
            // Function as an iperf server.

            pIState->mServerMode = true;
    7a24:	2301      	movs	r3, #1
    7a26:	f885 30d1 	strb.w	r3, [r5, #209]	; 0xd1
    for (i = 1; i < argc; i++)
    7a2a:	3401      	adds	r4, #1
    7a2c:	b2e4      	uxtb	r4, r4
    7a2e:	455c      	cmp	r4, fp
    7a30:	f280 81d2 	bge.w	7dd8 <CommandIperfStart+0x45c>
        if ((memcmp(argv[i], "-s", 2) == 0) || (memcmp(argv[i], "--server", 5) == 0) )
    7a34:	f859 7024 	ldr.w	r7, [r9, r4, lsl #2]
    7a38:	2202      	movs	r2, #2
    7a3a:	4987      	ldr	r1, [pc, #540]	; (7c58 <CommandIperfStart+0x2dc>)
    7a3c:	4638      	mov	r0, r7
    7a3e:	f01b fc47 	bl	232d0 <memcmp>
    7a42:	2800      	cmp	r0, #0
    7a44:	d0ee      	beq.n	7a24 <CommandIperfStart+0xa8>
    7a46:	2205      	movs	r2, #5
    7a48:	f506 7117 	add.w	r1, r6, #604	; 0x25c
    7a4c:	4638      	mov	r0, r7
    7a4e:	f01b fc3f 	bl	232d0 <memcmp>
    7a52:	2800      	cmp	r0, #0
    7a54:	d0e6      	beq.n	7a24 <CommandIperfStart+0xa8>
        }
#if defined(TCPIP_STACK_USE_UDP)
        else if ((memcmp(argv[i], "-u", 2) == 0) || (memcmp(argv[i], "--udp", 5) == 0) )
    7a56:	2202      	movs	r2, #2
    7a58:	f506 711a 	add.w	r1, r6, #616	; 0x268
    7a5c:	4638      	mov	r0, r7
    7a5e:	f01b fc37 	bl	232d0 <memcmp>
    7a62:	b130      	cbz	r0, 7a72 <CommandIperfStart+0xf6>
    7a64:	2205      	movs	r2, #5
    7a66:	f506 711b 	add.w	r1, r6, #620	; 0x26c
    7a6a:	4638      	mov	r0, r7
    7a6c:	f01b fc30 	bl	232d0 <memcmp>
    7a70:	b910      	cbnz	r0, 7a78 <CommandIperfStart+0xfc>
        {
            // iperf UDP mode.
            pIState->mProtocol = UDP_PROTOCOL;
    7a72:	2301      	movs	r3, #1
    7a74:	742b      	strb	r3, [r5, #16]
    7a76:	e7d8      	b.n	7a2a <CommandIperfStart+0xae>
        }
        else if ((memcmp(argv[i], "-b", 2) == 0) || (memcmp(argv[i], "--bandwidth", 5) == 0) )
    7a78:	2202      	movs	r2, #2
    7a7a:	f506 711d 	add.w	r1, r6, #628	; 0x274
    7a7e:	4638      	mov	r0, r7
    7a80:	f01b fc26 	bl	232d0 <memcmp>
    7a84:	b138      	cbz	r0, 7a96 <CommandIperfStart+0x11a>
    7a86:	2205      	movs	r2, #5
    7a88:	f506 711e 	add.w	r1, r6, #632	; 0x278
    7a8c:	4638      	mov	r0, r7
    7a8e:	f01b fc1f 	bl	232d0 <memcmp>
    7a92:	2800      	cmp	r0, #0
    7a94:	d15d      	bne.n	7b52 <CommandIperfStart+0x1d6>
        {
            // iperf UDP mode.
            pIState->mProtocol = UDP_PROTOCOL;
    7a96:	2301      	movs	r3, #1
    7a98:	742b      	strb	r3, [r5, #16]

            // Next argument should be the target rate, in bps.
            i++;
    7a9a:	441c      	add	r4, r3
    7a9c:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
    7a9e:	f859 8024 	ldr.w	r8, [r9, r4, lsl #2]
            len = strlen(ptr);
    7aa2:	4640      	mov	r0, r8
    7aa4:	f01c fa0c 	bl	23ec0 <strlen>
            
            if((strcmp((ptr+(len-1)),"M")==0) || (strcmp((ptr+(len-1)),"K")==0))
    7aa8:	b2c7      	uxtb	r7, r0
    7aaa:	f107 3aff 	add.w	sl, r7, #4294967295
    7aae:	44c2      	add	sl, r8
    7ab0:	f506 7121 	add.w	r1, r6, #644	; 0x284
    7ab4:	4650      	mov	r0, sl
    7ab6:	f01c f8a1 	bl	23bfc <strcmp>
    7aba:	b1a8      	cbz	r0, 7ae8 <CommandIperfStart+0x16c>
    7abc:	f506 7122 	add.w	r1, r6, #648	; 0x288
    7ac0:	4650      	mov	r0, sl
    7ac2:	f01c f89b 	bl	23bfc <strcmp>
    7ac6:	2800      	cmp	r0, #0
    7ac8:	d13c      	bne.n	7b44 <CommandIperfStart+0x1c8>
        mpf1 = 100 * 10;
    7aca:	f44f 7a7a 	mov.w	sl, #1000	; 0x3e8
        for(j=0;j<len-1;j++)
    7ace:	f107 3eff 	add.w	lr, r7, #4294967295
    7ad2:	f1be 0f00 	cmp.w	lr, #0
    7ad6:	dd32      	ble.n	7b3e <CommandIperfStart+0x1c2>
    uint32_t bw1=0, bw2=0,  mpf1=0, mpf2 = 1000000;
    7ad8:	f04f 0c00 	mov.w	ip, #0
    7adc:	4662      	mov	r2, ip
    uint8_t j, len, decimal=1;
    7ade:	2701      	movs	r7, #1
        for(j=0;j<len-1;j++)
    7ae0:	4663      	mov	r3, ip
                decimal = 0;
    7ae2:	9405      	str	r4, [sp, #20]
    7ae4:	4654      	mov	r4, sl
    7ae6:	e1f8      	b.n	7eda <CommandIperfStart+0x55e>
    if(strcmp((ptr+(len-1)),"K")==0)
    7ae8:	f506 7122 	add.w	r1, r6, #648	; 0x288
    7aec:	4650      	mov	r0, sl
    7aee:	f01c f885 	bl	23bfc <strcmp>
    7af2:	2800      	cmp	r0, #0
        mpf1 = 1000 * 1000;
    7af4:	4b59      	ldr	r3, [pc, #356]	; (7c5c <CommandIperfStart+0x2e0>)
    7af6:	bf0c      	ite	eq
    7af8:	f44f 7a7a 	moveq.w	sl, #1000	; 0x3e8
    7afc:	469a      	movne	sl, r3
    7afe:	e7e6      	b.n	7ace <CommandIperfStart+0x152>
                bw1 = bw1*10 + *(ptr+j) - '0';
    7b00:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    7b04:	eb00 0242 	add.w	r2, r0, r2, lsl #1
    7b08:	3a30      	subs	r2, #48	; 0x30
    7b0a:	e1f0      	b.n	7eee <CommandIperfStart+0x572>
    7b0c:	4623      	mov	r3, r4
    7b0e:	9c05      	ldr	r4, [sp, #20]
        bw2 = bw2 * mpf2;
    7b10:	fb03 f30c 	mul.w	r3, r3, ip
        if(bw1 < mpf1)
    7b14:	4552      	cmp	r2, sl
    7b16:	d201      	bcs.n	7b1c <CommandIperfStart+0x1a0>
            bw1 = bw1 * mpf1;
    7b18:	fb0a f202 	mul.w	r2, sl, r2
        values[0] = bw1;
    7b1c:	9208      	str	r2, [sp, #32]
        values[1] = bw2;
    7b1e:	9309      	str	r3, [sp, #36]	; 0x24
        (*pCmdIO->pCmdApi->print)(pCmdIO->cmdIoParam, "\nGiven in BW: %lu+%lu=%lu",bw1,bw2,bw1+bw2);
    7b20:	9903      	ldr	r1, [sp, #12]
    7b22:	6809      	ldr	r1, [r1, #0]
    7b24:	1898      	adds	r0, r3, r2
    7b26:	9000      	str	r0, [sp, #0]
    7b28:	684f      	ldr	r7, [r1, #4]
    7b2a:	f506 7123 	add.w	r1, r6, #652	; 0x28c
    7b2e:	9803      	ldr	r0, [sp, #12]
    7b30:	6840      	ldr	r0, [r0, #4]
    7b32:	47b8      	blx	r7
            {  
                bw_conversion(pCmdIO, ptr, values);
                bw = values[0]+values[1];
    7b34:	9b08      	ldr	r3, [sp, #32]
    7b36:	9a09      	ldr	r2, [sp, #36]	; 0x24
    7b38:	4413      	add	r3, r2
                ascii_to_u32s(ptr, values, 1);
                bw = values[0];
            }

            //(*pCmdIO->pCmdApi->print)(cmdIoParam, "\nGiven BW:%d",bw);            
            pIState->mTxRate = bw;
    7b3a:	61ab      	str	r3, [r5, #24]
    7b3c:	e775      	b.n	7a2a <CommandIperfStart+0xae>
    uint32_t bw1=0, bw2=0,  mpf1=0, mpf2 = 1000000;
    7b3e:	2200      	movs	r2, #0
        bw2 = bw2 * mpf2;
    7b40:	4613      	mov	r3, r2
    7b42:	e7e9      	b.n	7b18 <CommandIperfStart+0x19c>
                ascii_to_u32s(ptr, values, 1);
    7b44:	2201      	movs	r2, #1
    7b46:	a908      	add	r1, sp, #32
    7b48:	4640      	mov	r0, r8
    7b4a:	f012 fa65 	bl	1a018 <ascii_to_u32s>
                bw = values[0];
    7b4e:	9b08      	ldr	r3, [sp, #32]
    7b50:	e7f3      	b.n	7b3a <CommandIperfStart+0x1be>
        }
#endif  // defined(TCPIP_STACK_USE_UDP)
#if defined(TCPIP_STACK_USE_TCP)
        else if ((memcmp(argv[i], "-x", 2) == 0) || (memcmp(argv[i], "--xmitrate", 5) == 0) )
    7b52:	2202      	movs	r2, #2
    7b54:	f506 712a 	add.w	r1, r6, #680	; 0x2a8
    7b58:	4638      	mov	r0, r7
    7b5a:	f01b fbb9 	bl	232d0 <memcmp>
    7b5e:	b130      	cbz	r0, 7b6e <CommandIperfStart+0x1f2>
    7b60:	2205      	movs	r2, #5
    7b62:	f506 712b 	add.w	r1, r6, #684	; 0x2ac
    7b66:	4638      	mov	r0, r7
    7b68:	f01b fbb2 	bl	232d0 <memcmp>
    7b6c:	b950      	cbnz	r0, 7b84 <CommandIperfStart+0x208>
        {
            // NON-STANDARD IPERF OPTION. Set the max TCP tx rate.
            // Next argument should be the target rate, in bps.
            i++;
    7b6e:	3401      	adds	r4, #1
    7b70:	b2e4      	uxtb	r4, r4
            ptr = argv[i];

            ascii_to_u32s(ptr, values, 1);
    7b72:	2201      	movs	r2, #1
    7b74:	a908      	add	r1, sp, #32
    7b76:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    7b7a:	f012 fa4d 	bl	1a018 <ascii_to_u32s>

            pIState->mTxRate = values[0];
    7b7e:	9b08      	ldr	r3, [sp, #32]
    7b80:	61ab      	str	r3, [r5, #24]
    7b82:	e752      	b.n	7a2a <CommandIperfStart+0xae>
        }
#endif  // defined(TCPIP_STACK_USE_TCP)
        else if ((memcmp(argv[i], "-c", 2) == 0) || (memcmp(argv[i], "--client", 5) == 0) )
    7b84:	2202      	movs	r2, #2
    7b86:	f506 712e 	add.w	r1, r6, #696	; 0x2b8
    7b8a:	4638      	mov	r0, r7
    7b8c:	f01b fba0 	bl	232d0 <memcmp>
    7b90:	b130      	cbz	r0, 7ba0 <CommandIperfStart+0x224>
    7b92:	2205      	movs	r2, #5
    7b94:	f506 712f 	add.w	r1, r6, #700	; 0x2bc
    7b98:	4638      	mov	r0, r7
    7b9a:	f01b fb99 	bl	232d0 <memcmp>
    7b9e:	b9b8      	cbnz	r0, 7bd0 <CommandIperfStart+0x254>
        {
            // Function as an iperf client.
            pIState->mServerMode = false;
    7ba0:	2300      	movs	r3, #0
    7ba2:	f885 30d1 	strb.w	r3, [r5, #209]	; 0xd1

            // Next argument should be the server IP, such as "192.168.1.100".
            i++;
    7ba6:	3401      	adds	r4, #1
    7ba8:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
            ascii_to_u32s(ptr, values, 4);
    7baa:	2204      	movs	r2, #4
    7bac:	a908      	add	r1, sp, #32
    7bae:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    7bb2:	f012 fa31 	bl	1a018 <ascii_to_u32s>

            pIState->remoteSide.remoteIPaddress.v4Add.v[0] = values[0];
    7bb6:	9b08      	ldr	r3, [sp, #32]
    7bb8:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
            pIState->remoteSide.remoteIPaddress.v4Add.v[1] = values[1];
    7bbc:	9b09      	ldr	r3, [sp, #36]	; 0x24
    7bbe:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
            pIState->remoteSide.remoteIPaddress.v4Add.v[2] = values[2];
    7bc2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    7bc4:	f885 3046 	strb.w	r3, [r5, #70]	; 0x46
            pIState->remoteSide.remoteIPaddress.v4Add.v[3] = values[3]; 
    7bc8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    7bca:	f885 3047 	strb.w	r3, [r5, #71]	; 0x47
    7bce:	e72c      	b.n	7a2a <CommandIperfStart+0xae>
        }
        else if ((memcmp(argv[i], "-t", 2) == 0) || (memcmp(argv[i], "--time", 5) == 0) )
    7bd0:	2202      	movs	r2, #2
    7bd2:	f506 7132 	add.w	r1, r6, #712	; 0x2c8
    7bd6:	4638      	mov	r0, r7
    7bd8:	f01b fb7a 	bl	232d0 <memcmp>
    7bdc:	b130      	cbz	r0, 7bec <CommandIperfStart+0x270>
    7bde:	2205      	movs	r2, #5
    7be0:	f506 7133 	add.w	r1, r6, #716	; 0x2cc
    7be4:	4638      	mov	r0, r7
    7be6:	f01b fb73 	bl	232d0 <memcmp>
    7bea:	b978      	cbnz	r0, 7c0c <CommandIperfStart+0x290>
        {
            // Next argument should be the (client tx) duration, in seconds.
            i++;
    7bec:	3401      	adds	r4, #1
    7bee:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
            ascii_to_u32s(ptr, values, 1);
    7bf0:	2201      	movs	r2, #1
    7bf2:	a908      	add	r1, sp, #32
    7bf4:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    7bf8:	f012 fa0e 	bl	1a018 <ascii_to_u32s>

            pIState->mDuration = values[0] * tickFreq;
    7bfc:	9b08      	ldr	r3, [sp, #32]
    7bfe:	9a04      	ldr	r2, [sp, #16]
    7c00:	fb02 f303 	mul.w	r3, r2, r3
    7c04:	60ab      	str	r3, [r5, #8]
            pIState->mAmount = 0;
    7c06:	2300      	movs	r3, #0
    7c08:	606b      	str	r3, [r5, #4]
    7c0a:	e70e      	b.n	7a2a <CommandIperfStart+0xae>
        }
        else if ((memcmp(argv[i], "-n", 2) == 0) || (memcmp(argv[i], "--num", 5) == 0) )
    7c0c:	2202      	movs	r2, #2
    7c0e:	f506 7135 	add.w	r1, r6, #724	; 0x2d4
    7c12:	4638      	mov	r0, r7
    7c14:	f01b fb5c 	bl	232d0 <memcmp>
    7c18:	b130      	cbz	r0, 7c28 <CommandIperfStart+0x2ac>
    7c1a:	2205      	movs	r2, #5
    7c1c:	f506 7136 	add.w	r1, r6, #728	; 0x2d8
    7c20:	4638      	mov	r0, r7
    7c22:	f01b fb55 	bl	232d0 <memcmp>
    7c26:	b9d8      	cbnz	r0, 7c60 <CommandIperfStart+0x2e4>
        {
            // Next argument should be the (client tx) size, in bytes.
            i++;
    7c28:	3401      	adds	r4, #1
    7c2a:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
            ascii_to_u32s(ptr, values, 1);
    7c2c:	2201      	movs	r2, #1
    7c2e:	a908      	add	r1, sp, #32
    7c30:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    7c34:	f012 f9f0 	bl	1a018 <ascii_to_u32s>

            pIState->mAmount = values[0];
    7c38:	9b08      	ldr	r3, [sp, #32]
    7c3a:	606b      	str	r3, [r5, #4]
            pIState->mDuration = 0;
    7c3c:	2300      	movs	r3, #0
    7c3e:	60ab      	str	r3, [r5, #8]
    7c40:	e6f3      	b.n	7a2a <CommandIperfStart+0xae>
    7c42:	bf00      	nop
    7c44:	2000ee24 	.word	0x2000ee24
    7c48:	2000e380 	.word	0x2000e380
    7c4c:	00005f30 	.word	0x00005f30
    7c50:	00989680 	.word	0x00989680
    7c54:	00005afc 	.word	0x00005afc
    7c58:	00005d54 	.word	0x00005d54
    7c5c:	000f4240 	.word	0x000f4240
        }
        else if ((memcmp(argv[i], "-S", 2) == 0) || (memcmp(argv[i], "--tos", 5) == 0) )
    7c60:	2202      	movs	r2, #2
    7c62:	f506 7138 	add.w	r1, r6, #736	; 0x2e0
    7c66:	4638      	mov	r0, r7
    7c68:	f01b fb32 	bl	232d0 <memcmp>
    7c6c:	b138      	cbz	r0, 7c7e <CommandIperfStart+0x302>
    7c6e:	2205      	movs	r2, #5
    7c70:	f506 7139 	add.w	r1, r6, #740	; 0x2e4
    7c74:	4638      	mov	r0, r7
    7c76:	f01b fb2b 	bl	232d0 <memcmp>
    7c7a:	2800      	cmp	r0, #0
    7c7c:	d137      	bne.n	7cee <CommandIperfStart+0x372>
        {
            // Next argument should be the (client tx) TOS
            i++;
    7c7e:	3401      	adds	r4, #1
    7c80:	b2e4      	uxtb	r4, r4
            if(argv[i][1] == 'x')
    7c82:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    7c86:	7843      	ldrb	r3, [r0, #1]
    7c88:	2b78      	cmp	r3, #120	; 0x78
    7c8a:	d018      	beq.n	7cbe <CommandIperfStart+0x342>
                tos = hexatob(asciTos);
            }
            else
            {
                ptr = argv[i];
                ascii_to_u32s(ptr, values, 1);
    7c8c:	2201      	movs	r2, #1
    7c8e:	a908      	add	r1, sp, #32
    7c90:	f012 f9c2 	bl	1a018 <ascii_to_u32s>
                tos = values[0];                
    7c94:	f89d 0020 	ldrb.w	r0, [sp, #32]
            }

            switch(tos)
    7c98:	4602      	mov	r2, r0
    7c9a:	2820      	cmp	r0, #32
    7c9c:	d021      	beq.n	7ce2 <CommandIperfStart+0x366>
    7c9e:	d919      	bls.n	7cd4 <CommandIperfStart+0x358>
    7ca0:	28a0      	cmp	r0, #160	; 0xa0
    7ca2:	d01b      	beq.n	7cdc <CommandIperfStart+0x360>
    7ca4:	28c0      	cmp	r0, #192	; 0xc0
    7ca6:	d11f      	bne.n	7ce8 <CommandIperfStart+0x36c>
            {
                case IPERF_TOS_VO:
                    pIState->mTypeOfService = TCPIP_IPV4_THROUGHPUT_HIGH;                  
    7ca8:	2310      	movs	r3, #16
    7caa:	752b      	strb	r3, [r5, #20]
                    break;
                 default:   
                    pIState->mTypeOfService = TCPIP_IPV4_TOS_DEFAULT;                                                          
            }

            (*pCmdIO->pCmdApi->print)(cmdIoParam, "\nGiven TOS value is %d, mTypeOfService:%d",tos,pIState->mTypeOfService);
    7cac:	9b03      	ldr	r3, [sp, #12]
    7cae:	681b      	ldr	r3, [r3, #0]
    7cb0:	685f      	ldr	r7, [r3, #4]
    7cb2:	7d2b      	ldrb	r3, [r5, #20]
    7cb4:	f506 713b 	add.w	r1, r6, #748	; 0x2ec
    7cb8:	9802      	ldr	r0, [sp, #8]
    7cba:	47b8      	blx	r7
    7cbc:	e6b5      	b.n	7a2a <CommandIperfStart+0xae>
                ((uint8_t*)&asciTos)[1] = argv[i][2];
    7cbe:	7883      	ldrb	r3, [r0, #2]
    7cc0:	f88d 301f 	strb.w	r3, [sp, #31]
                ((uint8_t*)&asciTos)[0] = argv[i][3];                    
    7cc4:	78c3      	ldrb	r3, [r0, #3]
    7cc6:	f88d 301e 	strb.w	r3, [sp, #30]
                tos = hexatob(asciTos);
    7cca:	f8bd 001e 	ldrh.w	r0, [sp, #30]
    7cce:	f018 f95e 	bl	1ff8e <hexatob>
    7cd2:	e7e1      	b.n	7c98 <CommandIperfStart+0x31c>
            switch(tos)
    7cd4:	b940      	cbnz	r0, 7ce8 <CommandIperfStart+0x36c>
                    pIState->mTypeOfService = TCPIP_IPV4_TOS_DEFAULT;                                      
    7cd6:	2300      	movs	r3, #0
    7cd8:	752b      	strb	r3, [r5, #20]
                    break;
    7cda:	e7e7      	b.n	7cac <CommandIperfStart+0x330>
                    pIState->mTypeOfService = TCPIP_IPV4_RELIABILITY_HIGH;                                      
    7cdc:	2320      	movs	r3, #32
    7cde:	752b      	strb	r3, [r5, #20]
                    break;
    7ce0:	e7e4      	b.n	7cac <CommandIperfStart+0x330>
                    pIState->mTypeOfService = TCPIP_IPV4_DELAY_LOW;                                      
    7ce2:	2308      	movs	r3, #8
    7ce4:	752b      	strb	r3, [r5, #20]
                    break;
    7ce6:	e7e1      	b.n	7cac <CommandIperfStart+0x330>
                    pIState->mTypeOfService = TCPIP_IPV4_TOS_DEFAULT;                                                          
    7ce8:	2300      	movs	r3, #0
    7cea:	752b      	strb	r3, [r5, #20]
    7cec:	e7de      	b.n	7cac <CommandIperfStart+0x330>
            
        }
        
#if defined(TCPIP_STACK_USE_TCP)
        else if ((memcmp(argv[i], "-M", 2) == 0) ||
    7cee:	2202      	movs	r2, #2
    7cf0:	f506 7146 	add.w	r1, r6, #792	; 0x318
    7cf4:	4638      	mov	r0, r7
    7cf6:	f01b faeb 	bl	232d0 <memcmp>
    7cfa:	b130      	cbz	r0, 7d0a <CommandIperfStart+0x38e>
                (memcmp(argv[i], "--mss", 5) == 0) )
    7cfc:	2205      	movs	r2, #5
    7cfe:	f506 7147 	add.w	r1, r6, #796	; 0x31c
    7d02:	4638      	mov	r0, r7
    7d04:	f01b fae4 	bl	232d0 <memcmp>
        else if ((memcmp(argv[i], "-M", 2) == 0) ||
    7d08:	b958      	cbnz	r0, 7d22 <CommandIperfStart+0x3a6>
        {
            // Next argument should be the (client tcp tx) MSS size, in bytes.

            i++;
    7d0a:	3401      	adds	r4, #1
    7d0c:	b2e4      	uxtb	r4, r4
            ptr = argv[i];

            ascii_to_u32s(ptr, values, 1);
    7d0e:	2201      	movs	r2, #1
    7d10:	a908      	add	r1, sp, #32
    7d12:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    7d16:	f012 f97f 	bl	1a018 <ascii_to_u32s>

            pIState->mMSS = values[0];
    7d1a:	9b08      	ldr	r3, [sp, #32]
    7d1c:	f8a5 30d2 	strh.w	r3, [r5, #210]	; 0xd2
    7d20:	e683      	b.n	7a2a <CommandIperfStart+0xae>
        }
#endif  // defined(TCPIP_STACK_USE_TCP)

        else if ((memcmp(argv[i], "-i", 2) == 0) || (memcmp(argv[i], "--interval", 5) == 0) )
    7d22:	2202      	movs	r2, #2
    7d24:	f106 013c 	add.w	r1, r6, #60	; 0x3c
    7d28:	4638      	mov	r0, r7
    7d2a:	f01b fad1 	bl	232d0 <memcmp>
    7d2e:	b130      	cbz	r0, 7d3e <CommandIperfStart+0x3c2>
    7d30:	2205      	movs	r2, #5
    7d32:	f506 7149 	add.w	r1, r6, #804	; 0x324
    7d36:	4638      	mov	r0, r7
    7d38:	f01b faca 	bl	232d0 <memcmp>
    7d3c:	b968      	cbnz	r0, 7d5a <CommandIperfStart+0x3de>
        {
            // Next argument should be the report interval, in seconds.
            i++;
    7d3e:	3401      	adds	r4, #1
    7d40:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
            ascii_to_u32s(ptr, values, 1);
    7d42:	2201      	movs	r2, #1
    7d44:	a908      	add	r1, sp, #32
    7d46:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    7d4a:	f012 f965 	bl	1a018 <ascii_to_u32s>

            pIState->mInterval = values[0] * tickFreq; // Convert to msec
    7d4e:	9b08      	ldr	r3, [sp, #32]
    7d50:	9a04      	ldr	r2, [sp, #16]
    7d52:	fb02 f303 	mul.w	r3, r2, r3
    7d56:	602b      	str	r3, [r5, #0]
    7d58:	e667      	b.n	7a2a <CommandIperfStart+0xae>
        }
        else if ((memcmp(argv[i], "-p", 2) == 0) || (memcmp(argv[i], "--port", 6) == 0) )
    7d5a:	2202      	movs	r2, #2
    7d5c:	f506 714c 	add.w	r1, r6, #816	; 0x330
    7d60:	4638      	mov	r0, r7
    7d62:	f01b fab5 	bl	232d0 <memcmp>
    7d66:	b130      	cbz	r0, 7d76 <CommandIperfStart+0x3fa>
    7d68:	2206      	movs	r2, #6
    7d6a:	f506 714d 	add.w	r1, r6, #820	; 0x334
    7d6e:	4638      	mov	r0, r7
    7d70:	f01b faae 	bl	232d0 <memcmp>
    7d74:	b950      	cbnz	r0, 7d8c <CommandIperfStart+0x410>
        {
            // Next argument should be the port number.
            i++;
    7d76:	3401      	adds	r4, #1
    7d78:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
            ascii_to_u32s(ptr, values, 1);
    7d7a:	2201      	movs	r2, #1
    7d7c:	a908      	add	r1, sp, #32
    7d7e:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    7d82:	f012 f949 	bl	1a018 <ascii_to_u32s>

		    pIState->mServerPort = values[0];		// -p. default: server port 5001
    7d86:	9b08      	ldr	r3, [sp, #32]
    7d88:	826b      	strh	r3, [r5, #18]
    7d8a:	e64e      	b.n	7a2a <CommandIperfStart+0xae>
        }
#if defined(TCPIP_STACK_USE_UDP)
        else if ((memcmp(argv[i], "-l", 2) == 0) || (memcmp(argv[i], "--len", 5) == 0) )
    7d8c:	2202      	movs	r2, #2
    7d8e:	f506 714f 	add.w	r1, r6, #828	; 0x33c
    7d92:	4638      	mov	r0, r7
    7d94:	f01b fa9c 	bl	232d0 <memcmp>
    7d98:	b140      	cbz	r0, 7dac <CommandIperfStart+0x430>
    7d9a:	2205      	movs	r2, #5
    7d9c:	f506 7150 	add.w	r1, r6, #832	; 0x340
    7da0:	4638      	mov	r0, r7
    7da2:	f01b fa95 	bl	232d0 <memcmp>
    7da6:	2800      	cmp	r0, #0
    7da8:	f47f ae3f 	bne.w	7a2a <CommandIperfStart+0xae>
        {
            // Next argument should be the buffer length, in bytes.
            // This is used as the UDP datagram size.
            i++;
    7dac:	3401      	adds	r4, #1
    7dae:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
            ascii_to_u32s(ptr, values, 1);
    7db0:	2201      	movs	r2, #1
    7db2:	a908      	add	r1, sp, #32
    7db4:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    7db8:	f012 f92e 	bl	1a018 <ascii_to_u32s>

            if ( values[0] <  MAX_BUFFER  )
    7dbc:	9b08      	ldr	r3, [sp, #32]
    7dbe:	2b33      	cmp	r3, #51	; 0x33
    7dc0:	d901      	bls.n	7dc6 <CommandIperfStart+0x44a>
            {
               (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf: The minimum datagram size is %d\r\n", (int)MAX_BUFFER);
               return;
            }

            pIState->mDatagramSize = values[0];
    7dc2:	60eb      	str	r3, [r5, #12]
    7dc4:	e631      	b.n	7a2a <CommandIperfStart+0xae>
               (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf: The minimum datagram size is %d\r\n", (int)MAX_BUFFER);
    7dc6:	f8d5 30c4 	ldr.w	r3, [r5, #196]	; 0xc4
    7dca:	681b      	ldr	r3, [r3, #0]
    7dcc:	685b      	ldr	r3, [r3, #4]
    7dce:	2234      	movs	r2, #52	; 0x34
    7dd0:	4952      	ldr	r1, [pc, #328]	; (7f1c <CommandIperfStart+0x5a0>)
    7dd2:	9802      	ldr	r0, [sp, #8]
    7dd4:	4798      	blx	r3
               return;
    7dd6:	e006      	b.n	7de6 <CommandIperfStart+0x46a>
    7dd8:	f8dd a00c 	ldr.w	sl, [sp, #12]
        }
#endif  // defined(TCPIP_STACK_USE_UDP)
    }

    switch (pIState->mServerMode)
    7ddc:	f895 30d1 	ldrb.w	r3, [r5, #209]	; 0xd1
    7de0:	b123      	cbz	r3, 7dec <CommandIperfStart+0x470>
    7de2:	2b01      	cmp	r3, #1
    7de4:	d03d      	beq.n	7e62 <CommandIperfStart+0x4e6>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, " port %d\r\n", pIState->mServerPort);
            IperfSetState(pIState, IPERF_RX_START_STATE);
            break;
    }
    
}
    7de6:	b00d      	add	sp, #52	; 0x34
    7de8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if((pIState->pNetIf = TCPIP_STACK_IPAddToNet(&pIState->localAddr, false)) == 0)
    7dec:	2100      	movs	r1, #0
    7dee:	f105 0080 	add.w	r0, r5, #128	; 0x80
    7df2:	f01a fc25 	bl	22640 <TCPIP_STACK_IPAddToNet>
    7df6:	f8c5 00c8 	str.w	r0, [r5, #200]	; 0xc8
    7dfa:	b310      	cbz	r0, 7e42 <CommandIperfStart+0x4c6>
            if(pIState->mProtocol == TCP_PROTOCOL)
    7dfc:	7c2b      	ldrb	r3, [r5, #16]
    7dfe:	2b02      	cmp	r3, #2
    7e00:	d02a      	beq.n	7e58 <CommandIperfStart+0x4dc>
            if(pIState->mProtocol == UDP_PROTOCOL)
    7e02:	2b01      	cmp	r3, #1
                payloadSize = 	pIState->mDatagramSize;
    7e04:	bf06      	itte	eq
    7e06:	89ab      	ldrheq	r3, [r5, #12]
    7e08:	ee07 3a10 	vmoveq	s14, r3
    uint16_t payloadSize = 0, asciTos;
    7e0c:	ed9f 7a44 	vldrne	s14, [pc, #272]	; 7f20 <CommandIperfStart+0x5a4>
            pIState->mPktPeriod =  (uint32_t) ( (float) tickFreq / pktRate );
    7e10:	eddd 7a04 	vldr	s15, [sp, #16]
    7e14:	eeb8 6a67 	vcvt.f32.u32	s12, s15
            pktRate =  (float) (pIState->mTxRate / 8) / (float) payloadSize;
    7e18:	69ab      	ldr	r3, [r5, #24]
    7e1a:	08db      	lsrs	r3, r3, #3
    7e1c:	ee07 3a90 	vmov	s15, r3
    7e20:	eef8 7a67 	vcvt.f32.u32	s15, s15
    7e24:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    7e28:	eec7 6a87 	vdiv.f32	s13, s15, s14
            pIState->mPktPeriod =  (uint32_t) ( (float) tickFreq / pktRate );
    7e2c:	eec6 7a26 	vdiv.f32	s15, s12, s13
    7e30:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    7e34:	edc5 7a21 	vstr	s15, [r5, #132]	; 0x84
            IperfSetState(pIState, IPERF_TX_START_STATE);
    7e38:	210a      	movs	r1, #10
    7e3a:	4628      	mov	r0, r5
    7e3c:	f015 ff42 	bl	1dcc4 <IperfSetState>
            break;
    7e40:	e7d1      	b.n	7de6 <CommandIperfStart+0x46a>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Using the default interface!\r\n");
    7e42:	f8da 3000 	ldr.w	r3, [sl]
    7e46:	681b      	ldr	r3, [r3, #0]
    7e48:	4936      	ldr	r1, [pc, #216]	; (7f24 <CommandIperfStart+0x5a8>)
    7e4a:	9802      	ldr	r0, [sp, #8]
    7e4c:	4798      	blx	r3
                pIState->pNetIf = TCPIP_STACK_NetDefaultGet();
    7e4e:	f01c f9ed 	bl	2422c <TCPIP_STACK_NetDefaultGet>
    7e52:	f8c5 00c8 	str.w	r0, [r5, #200]	; 0xc8
    7e56:	e7d1      	b.n	7dfc <CommandIperfStart+0x480>
                payloadSize = 	pIState->mMSS;
    7e58:	f8b5 30d2 	ldrh.w	r3, [r5, #210]	; 0xd2
    7e5c:	ee07 3a10 	vmov	s14, r3
            if(pIState->mProtocol == UDP_PROTOCOL)
    7e60:	e7d6      	b.n	7e10 <CommandIperfStart+0x494>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "---------------------------------------------------------\r\n");
    7e62:	4c31      	ldr	r4, [pc, #196]	; (7f28 <CommandIperfStart+0x5ac>)
    7e64:	f8da 3000 	ldr.w	r3, [sl]
    7e68:	681b      	ldr	r3, [r3, #0]
    7e6a:	f504 7167 	add.w	r1, r4, #924	; 0x39c
    7e6e:	9e02      	ldr	r6, [sp, #8]
    7e70:	4630      	mov	r0, r6
    7e72:	4798      	blx	r3
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Server listening on ");
    7e74:	f8da 3000 	ldr.w	r3, [sl]
    7e78:	681b      	ldr	r3, [r3, #0]
    7e7a:	f504 7176 	add.w	r1, r4, #984	; 0x3d8
    7e7e:	4630      	mov	r0, r6
    7e80:	4798      	blx	r3
            if (pIState->mProtocol == UDP_PROTOCOL)
    7e82:	7c2b      	ldrb	r3, [r5, #16]
    7e84:	2b01      	cmp	r3, #1
    7e86:	d00f      	beq.n	7ea8 <CommandIperfStart+0x52c>
            if (pIState->mProtocol == TCP_PROTOCOL)
    7e88:	7c2b      	ldrb	r3, [r5, #16]
    7e8a:	2b02      	cmp	r3, #2
    7e8c:	d014      	beq.n	7eb8 <CommandIperfStart+0x53c>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, " port %d\r\n", pIState->mServerPort);
    7e8e:	f8d5 30c4 	ldr.w	r3, [r5, #196]	; 0xc4
    7e92:	681b      	ldr	r3, [r3, #0]
    7e94:	685b      	ldr	r3, [r3, #4]
    7e96:	8a6a      	ldrh	r2, [r5, #18]
    7e98:	4924      	ldr	r1, [pc, #144]	; (7f2c <CommandIperfStart+0x5b0>)
    7e9a:	9802      	ldr	r0, [sp, #8]
    7e9c:	4798      	blx	r3
            IperfSetState(pIState, IPERF_RX_START_STATE);
    7e9e:	2102      	movs	r1, #2
    7ea0:	4628      	mov	r0, r5
    7ea2:	f015 ff0f 	bl	1dcc4 <IperfSetState>
            break;
    7ea6:	e79e      	b.n	7de6 <CommandIperfStart+0x46a>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, (const char *)"UDP");
    7ea8:	f8da 3000 	ldr.w	r3, [sl]
    7eac:	681b      	ldr	r3, [r3, #0]
    7eae:	f504 717d 	add.w	r1, r4, #1012	; 0x3f4
    7eb2:	9802      	ldr	r0, [sp, #8]
    7eb4:	4798      	blx	r3
    7eb6:	e7e7      	b.n	7e88 <CommandIperfStart+0x50c>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, (const char *)"TCP");
    7eb8:	f8da 3000 	ldr.w	r3, [sl]
    7ebc:	681b      	ldr	r3, [r3, #0]
    7ebe:	491c      	ldr	r1, [pc, #112]	; (7f30 <CommandIperfStart+0x5b4>)
    7ec0:	9802      	ldr	r0, [sp, #8]
    7ec2:	4798      	blx	r3
    7ec4:	e7e3      	b.n	7e8e <CommandIperfStart+0x512>
            if(*(ptr+j) == (int8_t)'.')
    7ec6:	282e      	cmp	r0, #46	; 0x2e
    7ec8:	d102      	bne.n	7ed0 <CommandIperfStart+0x554>
                bw1 = bw1 * mpf1;
    7eca:	fb0a f202 	mul.w	r2, sl, r2
                decimal = 0;
    7ece:	2700      	movs	r7, #0
        for(j=0;j<len-1;j++)
    7ed0:	3301      	adds	r3, #1
    7ed2:	b2db      	uxtb	r3, r3
    7ed4:	4573      	cmp	r3, lr
    7ed6:	f6bf ae19 	bge.w	7b0c <CommandIperfStart+0x190>
            if ( (*(ptr+j) <= (int8_t)'9') && (*(ptr+j) >= (int8_t)'0') && (decimal == 1) )
    7eda:	f818 0003 	ldrb.w	r0, [r8, r3]
    7ede:	f1a0 0130 	sub.w	r1, r0, #48	; 0x30
    7ee2:	b2c9      	uxtb	r1, r1
    7ee4:	2909      	cmp	r1, #9
    7ee6:	d8ee      	bhi.n	7ec6 <CommandIperfStart+0x54a>
    7ee8:	2f00      	cmp	r7, #0
    7eea:	f47f ae09 	bne.w	7b00 <CommandIperfStart+0x184>
            if ( (*(ptr+j) <= (int8_t)'9') && (*(ptr+j) >= (int8_t)'0') && (decimal == 0) )
    7eee:	2f00      	cmp	r7, #0
    7ef0:	d1ee      	bne.n	7ed0 <CommandIperfStart+0x554>
                 bw2 = bw2*10 + *(ptr+j) - '0';
    7ef2:	eb0c 0c8c 	add.w	ip, ip, ip, lsl #2
    7ef6:	eb00 004c 	add.w	r0, r0, ip, lsl #1
    7efa:	f1a0 0c30 	sub.w	ip, r0, #48	; 0x30
                 mpf2 = mpf2/10;
    7efe:	490d      	ldr	r1, [pc, #52]	; (7f34 <CommandIperfStart+0x5b8>)
    7f00:	fba1 0104 	umull	r0, r1, r1, r4
    7f04:	08cc      	lsrs	r4, r1, #3
    7f06:	e7e3      	b.n	7ed0 <CommandIperfStart+0x554>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "\r\niperf: All instances busy. Retry later!\r\n");
    7f08:	f8da 3000 	ldr.w	r3, [sl]
    7f0c:	681b      	ldr	r3, [r3, #0]
    7f0e:	490a      	ldr	r1, [pc, #40]	; (7f38 <CommandIperfStart+0x5bc>)
    7f10:	9802      	ldr	r0, [sp, #8]
    7f12:	4798      	blx	r3
        return;
    7f14:	e767      	b.n	7de6 <CommandIperfStart+0x46a>
    for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
    7f16:	4d09      	ldr	r5, [pc, #36]	; (7f3c <CommandIperfStart+0x5c0>)
    7f18:	e54e      	b.n	79b8 <CommandIperfStart+0x3c>
    7f1a:	bf00      	nop
    7f1c:	00005e44 	.word	0x00005e44
    7f20:	00000000 	.word	0x00000000
    7f24:	00005e70 	.word	0x00005e70
    7f28:	00005afc 	.word	0x00005afc
    7f2c:	00005ef8 	.word	0x00005ef8
    7f30:	00005ef4 	.word	0x00005ef4
    7f34:	cccccccd 	.word	0xcccccccd
    7f38:	00005f04 	.word	0x00005f04
    7f3c:	2000e380 	.word	0x2000e380

Disassembly of section .text._TcpSend%222:

00007f40 <_TcpSend>:
    switch(pSkt->addType)
    7f40:	f890 306f 	ldrb.w	r3, [r0, #111]	; 0x6f
    7f44:	2b01      	cmp	r3, #1
    7f46:	f040 828d 	bne.w	8464 <_TcpSend+0x524>
{
    7f4a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7f4e:	b087      	sub	sp, #28
    7f50:	4604      	mov	r4, r0
    7f52:	460f      	mov	r7, r1
    7f54:	4692      	mov	sl, r2
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    7f56:	2000      	movs	r0, #0
    7f58:	f01b fc0c 	bl	23774 <OSAL_CRIT_Enter>
    if(pSkt->pV4Pkt != 0)
    7f5c:	6c62      	ldr	r2, [r4, #68]	; 0x44
    7f5e:	2a00      	cmp	r2, #0
    7f60:	f000 8292 	beq.w	8488 <_TcpSend+0x548>
        if((pSkt->pV4Pkt->macPkt.pktFlags & TCPIP_MAC_PKT_FLAG_QUEUED) == 0)
    7f64:	8c53      	ldrh	r3, [r2, #34]	; 0x22
    7f66:	f013 0f08 	tst.w	r3, #8
    7f6a:	f040 828d 	bne.w	8488 <_TcpSend+0x548>
            pSkt->pV4Pkt->macPkt.pktFlags |= TCPIP_MAC_PKT_FLAG_QUEUED;
    7f6e:	f043 0308 	orr.w	r3, r3, #8
    7f72:	8453      	strh	r3, [r2, #34]	; 0x22
            pktValid = (TCP_V4_PACKET*)pSkt->pV4Pkt;
    7f74:	6c66      	ldr	r6, [r4, #68]	; 0x44
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
    7f76:	4601      	mov	r1, r0
    7f78:	2000      	movs	r0, #0
    7f7a:	f01b fd35 	bl	239e8 <OSAL_CRIT_Leave>
    if(!oldPkt)
    7f7e:	2e00      	cmp	r6, #0
    7f80:	f000 8286 	beq.w	8490 <_TcpSend+0x550>
    pSeg->segLen = pSeg->segSize = 0;
    7f84:	2300      	movs	r3, #0
    7f86:	f8a6 3052 	strh.w	r3, [r6, #82]	; 0x52
    7f8a:	f8a6 3050 	strh.w	r3, [r6, #80]	; 0x50
    pSeg->next = 0;
    7f8e:	6473      	str	r3, [r6, #68]	; 0x44
    pSeg->segLen = pSeg->segSize = 0;
    7f90:	f8a6 306a 	strh.w	r3, [r6, #106]	; 0x6a
    7f94:	f8a6 3068 	strh.w	r3, [r6, #104]	; 0x68
    pSeg->next = 0;
    7f98:	65f3      	str	r3, [r6, #92]	; 0x5c
    pTcpPkt->v4Pkt.macPkt.pDSeg->next = 0;    // unlink to the 1st data seg; leave header only
    7f9a:	6932      	ldr	r2, [r6, #16]
    7f9c:	6013      	str	r3, [r2, #0]
    pTcpPkt->v4Pkt.macPkt.pDSeg->segLen = 0;  // clear the payload
    7f9e:	6932      	ldr	r2, [r6, #16]
    7fa0:	8193      	strh	r3, [r2, #12]
        if(vTCPFlags & FIN)
    7fa2:	f017 0f01 	tst.w	r7, #1
    7fa6:	d007      	beq.n	7fb8 <_TcpSend+0x78>
            pSkt->Flags.bTXFIN = 1;
    7fa8:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
    7fac:	f043 0301 	orr.w	r3, r3, #1
    7fb0:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37
            vTCPFlags &= ~FIN;
    7fb4:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
        pSkt->Flags.bTimer2Enabled = 0;
    7fb8:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
        pSkt->Flags.bHalfFullFlush = 0;
    7fbc:	f003 0323 	and.w	r3, r3, #35	; 0x23
    7fc0:	f36f 1345 	bfc	r3, #5, #1
    7fc4:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
        if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
    7fc8:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    7fcc:	2b01      	cmp	r3, #1
            header = (TCP_HEADER*)((TCP_V4_PACKET*)pSendPkt)->v4Pkt.macPkt.pTransportLayer;
    7fce:	bf0c      	ite	eq
    7fd0:	69f5      	ldreq	r5, [r6, #28]
    TCP_HEADER *    header = 0;
    7fd2:	2500      	movne	r5, #0
        header->DataOffset.Val = 0;
    7fd4:	7b2b      	ldrb	r3, [r5, #12]
    7fd6:	f36f 1307 	bfc	r3, #4, #4
    7fda:	732b      	strb	r3, [r5, #12]
        if(vTCPFlags & (SYN | RST))
    7fdc:	f017 0f06 	tst.w	r7, #6
    7fe0:	d049      	beq.n	8076 <_TcpSend+0x136>
            if(vTCPFlags & SYN)
    7fe2:	f017 0f02 	tst.w	r7, #2
    7fe6:	f000 8100 	beq.w	81ea <_TcpSend+0x2aa>
                options.Kind = TCP_OPTIONS_MAX_SEG_SIZE;
    7fea:	2302      	movs	r3, #2
    7fec:	f88d 3014 	strb.w	r3, [sp, #20]
                options.Length = 0x04;
    7ff0:	2304      	movs	r3, #4
    7ff2:	f88d 3015 	strb.w	r3, [sp, #21]
                if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
    7ff6:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    7ffa:	2b01      	cmp	r3, #1
    7ffc:	d01b      	beq.n	8036 <_TcpSend+0xf6>
    uint16_t 		mss = 0;
    7ffe:	2000      	movs	r0, #0
                options.MaxSegSize.Val = (((mss)&0x00FF)<<8) | (((mss)&0xFF00)>>8);
    8000:	0a03      	lsrs	r3, r0, #8
    8002:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
    8006:	f8ad 3016 	strh.w	r3, [sp, #22]
                pSkt->localMSS = mss;
    800a:	f8a4 0064 	strh.w	r0, [r4, #100]	; 0x64
                header->DataOffset.Val   += sizeof(options) >> 2;
    800e:	7b2b      	ldrb	r3, [r5, #12]
    8010:	f3c3 1203 	ubfx	r2, r3, #4, #4
    8014:	3201      	adds	r2, #1
    8016:	f362 1307 	bfi	r3, r2, #4, #4
    801a:	732b      	strb	r3, [r5, #12]
                if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
    801c:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    8020:	2b01      	cmp	r3, #1
                    memcpy(header + 1, &options, sizeof(options));
    8022:	bf04      	itt	eq
    8024:	9b05      	ldreq	r3, [sp, #20]
    8026:	616b      	streq	r3, [r5, #20]
                if(pSkt->MySEQ == 0)
    8028:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    802a:	b1eb      	cbz	r3, 8068 <_TcpSend+0x128>
    loadLen = (uint16_t)len;  // save the TCP payload size
    802c:	f04f 0800 	mov.w	r8, #0
    8030:	e0dd      	b.n	81ee <_TcpSend+0x2ae>
                pSkt->pTxPkt = pPkt;
    8032:	6466      	str	r6, [r4, #68]	; 0x44
    8034:	e249      	b.n	84ca <_TcpSend+0x58a>
                    if(pSkt->pSktNet == 0)
    8036:	6c23      	ldr	r3, [r4, #64]	; 0x40
    8038:	b12b      	cbz	r3, 8046 <_TcpSend+0x106>
                    mss = TCPIP_IPV4_MaxDatagramDataSizeGet(pSkt->pSktNet) - sizeof(TCP_HEADER);
    803a:	6c20      	ldr	r0, [r4, #64]	; 0x40
    803c:	f01a ffea 	bl	23014 <TCPIP_IPV4_MaxDatagramDataSizeGet>
    8040:	3814      	subs	r0, #20
    8042:	b280      	uxth	r0, r0
    8044:	e7dc      	b.n	8000 <_TcpSend+0xc0>
                        if(!_TcpSocketSetSourceInterface(pSkt))
    8046:	4620      	mov	r0, r4
    8048:	f017 fb49 	bl	1f6de <_TcpSocketSetSourceInterface>
    804c:	2800      	cmp	r0, #0
    804e:	d1f4      	bne.n	803a <_TcpSend+0xfa>
                            sendRes = _TCP_SEND_NO_IF;
    8050:	f06f 0003 	mvn.w	r0, #3
    if(sendRes != _TCP_SEND_OK && pSkt->addType == IP_ADDRESS_TYPE_IPV4)
    8054:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    8058:	2b01      	cmp	r3, #1
    805a:	f040 8179 	bne.w	8350 <_TcpSend+0x410>
        ((TCP_V4_PACKET*)pSendPkt)->v4Pkt.macPkt.pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED ;
    805e:	8c73      	ldrh	r3, [r6, #34]	; 0x22
    8060:	f023 0308 	bic.w	r3, r3, #8
    8064:	8473      	strh	r3, [r6, #34]	; 0x22
    if(sendRes == _TCP_SEND_OK && (vTCPFlags & RST) != 0 )
    8066:	e173      	b.n	8350 <_TcpSend+0x410>
                    pSkt->MySEQ = _TCP_SktSetSequenceNo(pSkt);
    8068:	4620      	mov	r0, r4
    806a:	f010 fe35 	bl	18cd8 <_TCP_SktSetSequenceNo>
    806e:	64e0      	str	r0, [r4, #76]	; 0x4c
    loadLen = (uint16_t)len;  // save the TCP payload size
    8070:	f04f 0800 	mov.w	r8, #0
    8074:	e0bb      	b.n	81ee <_TcpSend+0x2ae>
            maxPayload = pSkt->wRemoteMSS;
    8076:	f8b4 b062 	ldrh.w	fp, [r4, #98]	; 0x62
            if(pSkt->txHead == pSkt->txUnackedTail)
    807a:	68a2      	ldr	r2, [r4, #8]
    807c:	6923      	ldr	r3, [r4, #16]
    807e:	429a      	cmp	r2, r3
    8080:	f000 81fa 	beq.w	8478 <_TcpSend+0x538>
                if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
    8084:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    8088:	2b01      	cmp	r3, #1
    808a:	d039      	beq.n	8100 <_TcpSend+0x1c0>
                    if(pSkt->localMSS < maxPayload)
    808c:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    8090:	459b      	cmp	fp, r3
    8092:	bf28      	it	cs
    8094:	469b      	movcs	fp, r3
                if(pSkt->txHead > pSkt->txUnackedTail)
    8096:	68a3      	ldr	r3, [r4, #8]
    8098:	6921      	ldr	r1, [r4, #16]
    809a:	428b      	cmp	r3, r1
    809c:	d948      	bls.n	8130 <_TcpSend+0x1f0>
                    len = pSkt->txHead - pSkt->txUnackedTail;
    809e:	1a5b      	subs	r3, r3, r1
                    if(len > pSkt->remoteWindow)
    80a0:	f8b4 905c 	ldrh.w	r9, [r4, #92]	; 0x5c
    80a4:	4599      	cmp	r9, r3
    80a6:	bf28      	it	cs
    80a8:	4699      	movcs	r9, r3
                    if(len > maxPayload)
    80aa:	45cb      	cmp	fp, r9
    80ac:	d206      	bcs.n	80bc <_TcpSend+0x17c>
                        pSkt->Flags.bTXASAPWithoutTimerReset = 1;
    80ae:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    80b2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    80b6:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
                        len = maxPayload;
    80ba:	46d9      	mov	r9, fp
}


static void _TCP_PayloadSet(TCB_STUB * pSkt, void* pPkt, uint8_t* payload1, uint16_t len1, uint8_t* payload2, uint16_t len2)
{
    switch(pSkt->addType)
    80bc:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    80c0:	2b01      	cmp	r3, #1
    80c2:	d022      	beq.n	810a <_TcpSend+0x1ca>
                    pSkt->txUnackedTail += len;
    80c4:	6923      	ldr	r3, [r4, #16]
    80c6:	444b      	add	r3, r9
    80c8:	6123      	str	r3, [r4, #16]
            if(pSkt->Flags.bTXFIN)
    80ca:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
    80ce:	f013 0f01 	tst.w	r3, #1
    80d2:	d007      	beq.n	80e4 <_TcpSend+0x1a4>
                if((len != pSkt->remoteWindow) && (len != maxPayload))
    80d4:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
    80d8:	454b      	cmp	r3, r9
    80da:	d003      	beq.n	80e4 <_TcpSend+0x1a4>
    80dc:	45cb      	cmp	fp, r9
                    vTCPFlags |= FIN;
    80de:	bf18      	it	ne
    80e0:	f047 0701 	orrne.w	r7, r7, #1
    loadLen = (uint16_t)len;  // save the TCP payload size
    80e4:	fa1f f889 	uxth.w	r8, r9
        if(len || (vTCPFlags & (SYN | FIN)))
    80e8:	f1b9 0f00 	cmp.w	r9, #0
    80ec:	d07f      	beq.n	81ee <_TcpSend+0x2ae>
            pSkt->remoteWindow -= len;
    80ee:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
    80f2:	eba3 0308 	sub.w	r3, r3, r8
    80f6:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
                vTCPFlags |= PSH;
    80fa:	f047 0708 	orr.w	r7, r7, #8
    80fe:	e07b      	b.n	81f8 <_TcpSend+0x2b8>
                    isFragmSupported = TCPIP_IPV4_IsFragmentationEnabled();
    8100:	f01c f9c1 	bl	24486 <TCPIP_IPV4_IsFragmentationEnabled>
                if(!isFragmSupported)
    8104:	2800      	cmp	r0, #0
    8106:	d1c6      	bne.n	8096 <_TcpSend+0x156>
    8108:	e7c0      	b.n	808c <_TcpSend+0x14c>
        pSeg0->next = 0;
    810a:	2300      	movs	r3, #0
    810c:	6473      	str	r3, [r6, #68]	; 0x44
    if(pBuff1)
    810e:	b159      	cbz	r1, 8128 <_TcpSend+0x1e8>
                    _TCP_PayloadSet(pSkt, pSendPkt, pSkt->txUnackedTail, len, 0, 0);
    8110:	fa1f f389 	uxth.w	r3, r9
        pSeg0->segLen = pSeg0->segSize = bSize1;
    8114:	f8a6 3052 	strh.w	r3, [r6, #82]	; 0x52
    8118:	f8a6 3050 	strh.w	r3, [r6, #80]	; 0x50
        pSeg0->segLoad = pBuff1;
    811c:	64f1      	str	r1, [r6, #76]	; 0x4c
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = pSeg0;  // link to the 1st data seg to be transmitted
    811e:	6933      	ldr	r3, [r6, #16]
    TCPIP_MAC_DATA_SEGMENT* pSeg0 = pTcpPkt->tcpSeg + 0;
    8120:	f106 0244 	add.w	r2, r6, #68	; 0x44
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = pSeg0;  // link to the 1st data seg to be transmitted
    8124:	601a      	str	r2, [r3, #0]
    8126:	e7cd      	b.n	80c4 <_TcpSend+0x184>
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = 0;  // link to the 1st data seg to be transmitted
    8128:	6933      	ldr	r3, [r6, #16]
    812a:	2200      	movs	r2, #0
    812c:	601a      	str	r2, [r3, #0]
    812e:	e7c9      	b.n	80c4 <_TcpSend+0x184>
                    lenEnd = pSkt->txEnd - pSkt->txUnackedTail;
    8130:	6862      	ldr	r2, [r4, #4]
    8132:	1a52      	subs	r2, r2, r1
                    len = lenEnd + pSkt->txHead - pSkt->txStart;
    8134:	6820      	ldr	r0, [r4, #0]
    8136:	4413      	add	r3, r2
    8138:	1a1b      	subs	r3, r3, r0
                    if(len > pSkt->remoteWindow)
    813a:	f8b4 905c 	ldrh.w	r9, [r4, #92]	; 0x5c
    813e:	4599      	cmp	r9, r3
    8140:	bf28      	it	cs
    8142:	4699      	movcs	r9, r3
                    if(len > maxPayload)
    8144:	45cb      	cmp	fp, r9
    8146:	d206      	bcs.n	8156 <_TcpSend+0x216>
                        pSkt->Flags.bTXASAPWithoutTimerReset = 1;
    8148:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    814c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    8150:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
                        len = maxPayload;
    8154:	46d9      	mov	r9, fp
                    if (lenEnd > len)
    8156:	4613      	mov	r3, r2
    8158:	454a      	cmp	r2, r9
    815a:	bf28      	it	cs
    815c:	464b      	movcs	r3, r9
                    if(lenStart)
    815e:	ebb9 0203 	subs.w	r2, r9, r3
    8162:	d02c      	beq.n	81be <_TcpSend+0x27e>
    switch(pSkt->addType)
    8164:	f894 c06f 	ldrb.w	ip, [r4, #111]	; 0x6f
    8168:	f1bc 0f01 	cmp.w	ip, #1
    816c:	d00a      	beq.n	8184 <_TcpSend+0x244>
                    pSkt->txUnackedTail += len;
    816e:	6923      	ldr	r3, [r4, #16]
    8170:	444b      	add	r3, r9
    8172:	6123      	str	r3, [r4, #16]
                    if(pSkt->txUnackedTail >= pSkt->txEnd)
    8174:	6862      	ldr	r2, [r4, #4]
    8176:	4293      	cmp	r3, r2
    8178:	d3a7      	bcc.n	80ca <_TcpSend+0x18a>
                        pSkt->txUnackedTail -= pSkt->txEnd-pSkt->txStart;
    817a:	6821      	ldr	r1, [r4, #0]
    817c:	1a52      	subs	r2, r2, r1
    817e:	1a9b      	subs	r3, r3, r2
    8180:	6123      	str	r3, [r4, #16]
    8182:	e7a2      	b.n	80ca <_TcpSend+0x18a>
    if(pBuff2)
    8184:	b1a0      	cbz	r0, 81b0 <_TcpSend+0x270>
                        _TCP_PayloadSet(pSkt, pSendPkt, pSkt->txUnackedTail, lenEnd, pSkt->txStart, lenStart);
    8186:	b292      	uxth	r2, r2
        pSeg1->segLen = pSeg1->segSize = bSize2;
    8188:	f8a6 206a 	strh.w	r2, [r6, #106]	; 0x6a
    818c:	f8a6 2068 	strh.w	r2, [r6, #104]	; 0x68
        pSeg1->segLoad = pBuff2;
    8190:	6670      	str	r0, [r6, #100]	; 0x64
    TCPIP_MAC_DATA_SEGMENT* pSeg1 = pTcpPkt->tcpSeg + 1;
    8192:	f106 025c 	add.w	r2, r6, #92	; 0x5c
        pSeg0->next = pSeg1;
    8196:	6472      	str	r2, [r6, #68]	; 0x44
    if(pBuff1)
    8198:	b169      	cbz	r1, 81b6 <_TcpSend+0x276>
                        _TCP_PayloadSet(pSkt, pSendPkt, pSkt->txUnackedTail, lenEnd, pSkt->txStart, lenStart);
    819a:	b29b      	uxth	r3, r3
        pSeg0->segLen = pSeg0->segSize = bSize1;
    819c:	f8a6 3052 	strh.w	r3, [r6, #82]	; 0x52
    81a0:	f8a6 3050 	strh.w	r3, [r6, #80]	; 0x50
        pSeg0->segLoad = pBuff1;
    81a4:	64f1      	str	r1, [r6, #76]	; 0x4c
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = pSeg0;  // link to the 1st data seg to be transmitted
    81a6:	6933      	ldr	r3, [r6, #16]
    TCPIP_MAC_DATA_SEGMENT* pSeg0 = pTcpPkt->tcpSeg + 0;
    81a8:	f106 0244 	add.w	r2, r6, #68	; 0x44
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = pSeg0;  // link to the 1st data seg to be transmitted
    81ac:	601a      	str	r2, [r3, #0]
    81ae:	e7de      	b.n	816e <_TcpSend+0x22e>
        pSeg0->next = 0;
    81b0:	2200      	movs	r2, #0
    81b2:	6472      	str	r2, [r6, #68]	; 0x44
    81b4:	e7f0      	b.n	8198 <_TcpSend+0x258>
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = 0;  // link to the 1st data seg to be transmitted
    81b6:	6933      	ldr	r3, [r6, #16]
    81b8:	2200      	movs	r2, #0
    81ba:	601a      	str	r2, [r3, #0]
    81bc:	e7d7      	b.n	816e <_TcpSend+0x22e>
    switch(pSkt->addType)
    81be:	f894 206f 	ldrb.w	r2, [r4, #111]	; 0x6f
    81c2:	2a01      	cmp	r2, #1
    81c4:	d1d3      	bne.n	816e <_TcpSend+0x22e>
        pSeg0->next = 0;
    81c6:	2200      	movs	r2, #0
    81c8:	6472      	str	r2, [r6, #68]	; 0x44
    if(pBuff1)
    81ca:	b151      	cbz	r1, 81e2 <_TcpSend+0x2a2>
                        _TCP_PayloadSet(pSkt, pSendPkt, pSkt->txUnackedTail, lenEnd, 0, 0);
    81cc:	b29b      	uxth	r3, r3
        pSeg0->segLen = pSeg0->segSize = bSize1;
    81ce:	f8a6 3052 	strh.w	r3, [r6, #82]	; 0x52
    81d2:	f8a6 3050 	strh.w	r3, [r6, #80]	; 0x50
        pSeg0->segLoad = pBuff1;
    81d6:	64f1      	str	r1, [r6, #76]	; 0x4c
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = pSeg0;  // link to the 1st data seg to be transmitted
    81d8:	6933      	ldr	r3, [r6, #16]
    TCPIP_MAC_DATA_SEGMENT* pSeg0 = pTcpPkt->tcpSeg + 0;
    81da:	f106 0244 	add.w	r2, r6, #68	; 0x44
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = pSeg0;  // link to the 1st data seg to be transmitted
    81de:	601a      	str	r2, [r3, #0]
    81e0:	e7c5      	b.n	816e <_TcpSend+0x22e>
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = 0;  // link to the 1st data seg to be transmitted
    81e2:	6933      	ldr	r3, [r6, #16]
    81e4:	2200      	movs	r2, #0
    81e6:	601a      	str	r2, [r3, #0]
    81e8:	e7c1      	b.n	816e <_TcpSend+0x22e>
    loadLen = (uint16_t)len;  // save the TCP payload size
    81ea:	f04f 0800 	mov.w	r8, #0
        if(len || (vTCPFlags & (SYN | FIN)))
    81ee:	f017 0f03 	tst.w	r7, #3
    81f2:	d046      	beq.n	8282 <_TcpSend+0x342>
    81f4:	f04f 0900 	mov.w	r9, #0
            if(vSendFlags & SENDTCP_RESET_TIMERS)
    81f8:	f01a 0f01 	tst.w	sl, #1
    81fc:	d132      	bne.n	8264 <_TcpSend+0x324>
            pSkt->eventTime = SYS_TMR_TickCountGet() + pSkt->retryInterval;
    81fe:	f01a f81d 	bl	2223c <SYS_TMR_TickCountGet>
    8202:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    8204:	4418      	add	r0, r3
    8206:	6260      	str	r0, [r4, #36]	; 0x24
            pSkt->Flags.bTimerEnabled = 1;
    8208:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    820c:	f043 0302 	orr.w	r3, r3, #2
    8210:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
        header->SourcePort			= pSkt->localPort;
    8214:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
    8218:	802b      	strh	r3, [r5, #0]
        header->DestPort			= pSkt->remotePort;
    821a:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
    821e:	806b      	strh	r3, [r5, #2]
        header->SeqNumber			= pSkt->MySEQ;
    8220:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    8222:	606b      	str	r3, [r5, #4]
        header->AckNumber			= pSkt->RemoteSEQ;
    8224:	6d23      	ldr	r3, [r4, #80]	; 0x50
    8226:	60ab      	str	r3, [r5, #8]
        header->DataOffset.Reserved3	= 0;
    8228:	7b2b      	ldrb	r3, [r5, #12]
    822a:	f36f 0303 	bfc	r3, #0, #4
    822e:	732b      	strb	r3, [r5, #12]
        header->Flags.byte			= vTCPFlags;
    8230:	736f      	strb	r7, [r5, #13]
        header->UrgentPointer       = 0;
    8232:	2300      	movs	r3, #0
    8234:	826b      	strh	r3, [r5, #18]
        header->Checksum            = 0;
    8236:	822b      	strh	r3, [r5, #16]
        pSkt->MySEQ += (uint32_t)len;
    8238:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    823a:	444b      	add	r3, r9
    823c:	64e3      	str	r3, [r4, #76]	; 0x4c
        if(vTCPFlags & SYN)
    823e:	f017 0f02 	tst.w	r7, #2
    8242:	d054      	beq.n	82ee <_TcpSend+0x3ae>
            if(!(vTCPFlags & ACK))
    8244:	f017 0f10 	tst.w	r7, #16
                header->AckNumber = 0;
    8248:	bf04      	itt	eq
    824a:	2300      	moveq	r3, #0
    824c:	60ab      	streq	r3, [r5, #8]
            if(pSkt->flags.bSYNSent)
    824e:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
    8252:	f013 0f08 	tst.w	r3, #8
    8256:	d03e      	beq.n	82d6 <_TcpSend+0x396>
                header->SeqNumber--;
    8258:	686b      	ldr	r3, [r5, #4]
    825a:	3b01      	subs	r3, #1
    825c:	606b      	str	r3, [r5, #4]
            hdrLen = sizeof(options);
    825e:	f04f 0904 	mov.w	r9, #4
    8262:	e046      	b.n	82f2 <_TcpSend+0x3b2>
                pSkt->retryCount = 0;
    8264:	2300      	movs	r3, #0
    8266:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
                pSkt->retryInterval = (TCPIP_TCP_START_TIMEOUT_VAL * SYS_TMR_TickCounterFrequencyGet())/1000;
    826a:	f01a f80f 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    826e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    8272:	fb03 f300 	mul.w	r3, r3, r0
    8276:	489c      	ldr	r0, [pc, #624]	; (84e8 <_TcpSend+0x5a8>)
    8278:	fba0 2303 	umull	r2, r3, r0, r3
    827c:	099b      	lsrs	r3, r3, #6
    827e:	64a3      	str	r3, [r4, #72]	; 0x48
    8280:	e7bd      	b.n	81fe <_TcpSend+0x2be>
        else if(vSendFlags & SENDTCP_KEEP_ALIVE)
    8282:	f01a 0f02 	tst.w	sl, #2
    8286:	d00a      	beq.n	829e <_TcpSend+0x35e>
            pSkt->keepAliveCount++;
    8288:	f894 3071 	ldrb.w	r3, [r4, #113]	; 0x71
    828c:	3301      	adds	r3, #1
    828e:	f884 3071 	strb.w	r3, [r4, #113]	; 0x71
            pSkt->MySEQ -= 1;
    8292:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    8294:	3b01      	subs	r3, #1
    8296:	64e3      	str	r3, [r4, #76]	; 0x4c
            len = 1;
    8298:	f04f 0901 	mov.w	r9, #1
    829c:	e7ba      	b.n	8214 <_TcpSend+0x2d4>
        else if(pSkt->Flags.bTimerEnabled) 
    829e:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    82a2:	f013 0f02 	tst.w	r3, #2
    82a6:	d013      	beq.n	82d0 <_TcpSend+0x390>
            if(!(vSendFlags & SENDTCP_RESET_TIMERS))
    82a8:	f01a 0f01 	tst.w	sl, #1
    82ac:	d108      	bne.n	82c0 <_TcpSend+0x380>
                if(pSkt->retryCount)
    82ae:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    82b2:	b12b      	cbz	r3, 82c0 <_TcpSend+0x380>
                    pSkt->retryCount--;
    82b4:	3b01      	subs	r3, #1
    82b6:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
                    pSkt->retryInterval >>= 1;
    82ba:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    82bc:	085b      	lsrs	r3, r3, #1
    82be:	64a3      	str	r3, [r4, #72]	; 0x48
            pSkt->eventTime = SYS_TMR_TickCountGet() + pSkt->retryInterval;
    82c0:	f019 ffbc 	bl	2223c <SYS_TMR_TickCountGet>
    82c4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    82c6:	4418      	add	r0, r3
    82c8:	6260      	str	r0, [r4, #36]	; 0x24
    82ca:	f04f 0900 	mov.w	r9, #0
    82ce:	e7a1      	b.n	8214 <_TcpSend+0x2d4>
    82d0:	f04f 0900 	mov.w	r9, #0
    82d4:	e79e      	b.n	8214 <_TcpSend+0x2d4>
                pSkt->MySEQ++;
    82d6:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    82d8:	3301      	adds	r3, #1
    82da:	64e3      	str	r3, [r4, #76]	; 0x4c
                pSkt->flags.bSYNSent = 1;
    82dc:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
    82e0:	f043 0308 	orr.w	r3, r3, #8
    82e4:	f884 306c 	strb.w	r3, [r4, #108]	; 0x6c
            hdrLen = sizeof(options);
    82e8:	f04f 0904 	mov.w	r9, #4
    82ec:	e001      	b.n	82f2 <_TcpSend+0x3b2>
            hdrLen = 0;
    82ee:	f04f 0900 	mov.w	r9, #0
        if(vTCPFlags & FIN)
    82f2:	f017 0f01 	tst.w	r7, #1
    82f6:	d005      	beq.n	8304 <_TcpSend+0x3c4>
            pSkt->flags.bFINSent = 1;   // do not advance the seq no for FIN!
    82f8:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
    82fc:	f043 0304 	orr.w	r3, r3, #4
    8300:	f884 306c 	strb.w	r3, [r4, #108]	; 0x6c
        if(vTCPFlags & ACK)
    8304:	f017 0f10 	tst.w	r7, #16
    8308:	d005      	beq.n	8316 <_TcpSend+0x3d6>
            pSkt->flags.ackSent = 1;   // store the ACK already sent
    830a:	f894 306d 	ldrb.w	r3, [r4, #109]	; 0x6d
    830e:	f043 0301 	orr.w	r3, r3, #1
    8312:	f884 306d 	strb.w	r3, [r4, #109]	; 0x6d
        if(pSkt->rxHead >= pSkt->rxTail)
    8316:	69e3      	ldr	r3, [r4, #28]
    8318:	6a22      	ldr	r2, [r4, #32]
    831a:	4293      	cmp	r3, r2
    831c:	d31b      	bcc.n	8356 <_TcpSend+0x416>
            header->Window = (pSkt->rxEnd - pSkt->rxStart) - (pSkt->rxHead - pSkt->rxTail);
    831e:	69a1      	ldr	r1, [r4, #24]
    8320:	6960      	ldr	r0, [r4, #20]
    8322:	1a09      	subs	r1, r1, r0
    8324:	1a9b      	subs	r3, r3, r2
    8326:	1acb      	subs	r3, r1, r3
    8328:	b29b      	uxth	r3, r3
    832a:	81eb      	strh	r3, [r5, #14]
        pSkt->localWindow = header->Window; // store the last advertised window
    832c:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
        _TcpSwapHeader(header);
    8330:	4628      	mov	r0, r5
    8332:	f014 fabf 	bl	1c8b4 <_TcpSwapHeader>
        header->DataOffset.Val   += sizeof(TCP_HEADER) >> 2;
    8336:	7b2b      	ldrb	r3, [r5, #12]
    8338:	f3c3 1203 	ubfx	r2, r3, #4, #4
    833c:	3205      	adds	r2, #5
    833e:	f362 1307 	bfi	r3, r2, #4, #4
    8342:	732b      	strb	r3, [r5, #12]
}


static bool _TCP_Flush(TCB_STUB * pSkt, void* pPkt, uint16_t hdrLen, uint16_t loadLen)
{
    switch(pSkt->addType)
    8344:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    8348:	2b01      	cmp	r3, #1
    834a:	d008      	beq.n	835e <_TcpSend+0x41e>
        sendRes = _TCP_Flush (pSkt, pSendPkt, hdrLen, loadLen) ? _TCP_SEND_OK : _TCP_SEND_IP_FAIL;
    834c:	f04f 30ff 	mov.w	r0, #4294967295
}
    8350:	b007      	add	sp, #28
    8352:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            header->Window = pSkt->rxTail - pSkt->rxHead - 1;
    8356:	1ad3      	subs	r3, r2, r3
    8358:	3b01      	subs	r3, #1
    835a:	b29b      	uxth	r3, r3
    835c:	e7e5      	b.n	832a <_TcpSend+0x3ea>
    if(pSkt->destAddress.Val == 0)
    835e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    8360:	b913      	cbnz	r3, 8368 <_TcpSend+0x428>
        sendRes = _TCP_Flush (pSkt, pSendPkt, hdrLen, loadLen) ? _TCP_SEND_OK : _TCP_SEND_IP_FAIL;
    8362:	f04f 30ff 	mov.w	r0, #4294967295
    8366:	e675      	b.n	8054 <_TcpSend+0x114>
    if(!_TcpSocketSetSourceInterface(pSkt))
    8368:	4620      	mov	r0, r4
    836a:	f017 f9b8 	bl	1f6de <_TcpSocketSetSourceInterface>
    836e:	2800      	cmp	r0, #0
    8370:	d0f7      	beq.n	8362 <_TcpSend+0x422>
        hdrLen += sizeof(TCP_HEADER);
    8372:	f109 0914 	add.w	r9, r9, #20
    pv4Pkt->srcAddress.Val = pSkt->srcAddress.Val;
    8376:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    8378:	6373      	str	r3, [r6, #52]	; 0x34
    pv4Pkt->destAddress.Val = pSkt->destAddress.Val;
    837a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    837c:	63b3      	str	r3, [r6, #56]	; 0x38
    pv4Pkt->netIfH = pSkt->pSktNet;
    837e:	6c23      	ldr	r3, [r4, #64]	; 0x40
    8380:	63f3      	str	r3, [r6, #60]	; 0x3c
    pv4Pkt->macPkt.pDSeg->segLen += hdrLen;
    8382:	6932      	ldr	r2, [r6, #16]
    8384:	8993      	ldrh	r3, [r2, #12]
    8386:	444b      	add	r3, r9
    8388:	8193      	strh	r3, [r2, #12]
    pseudoHdr.SourceAddress.Val = pv4Pkt->srcAddress.Val;
    838a:	6b73      	ldr	r3, [r6, #52]	; 0x34
    838c:	9302      	str	r3, [sp, #8]
    pseudoHdr.DestAddress.Val = pv4Pkt->destAddress.Val;
    838e:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    8390:	9303      	str	r3, [sp, #12]
    pseudoHdr.Zero = 0;
    8392:	2200      	movs	r2, #0
    8394:	f88d 2010 	strb.w	r2, [sp, #16]
    pseudoHdr.Protocol = IP_PROT_TCP;
    8398:	2306      	movs	r3, #6
    839a:	f88d 3011 	strb.w	r3, [sp, #17]
    pseudoHdr.Length = TCPIP_Helper_htons(hdrLen + loadLen);
    839e:	eb09 0508 	add.w	r5, r9, r8
    83a2:	b2ad      	uxth	r5, r5
    83a4:	0a2b      	lsrs	r3, r5, #8
    83a6:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    83aa:	f8ad 3012 	strh.w	r3, [sp, #18]
    checksum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)&pseudoHdr, sizeof(pseudoHdr), 0);
    83ae:	210c      	movs	r1, #12
    83b0:	a802      	add	r0, sp, #8
    83b2:	f013 ff51 	bl	1c258 <TCPIP_Helper_CalcIPChecksum>
    pTCPHdr = (TCP_HEADER*)pv4Pkt->macPkt.pTransportLayer;
    83b6:	f8d6 a01c 	ldr.w	sl, [r6, #28]
    checksum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)&pseudoHdr, sizeof(pseudoHdr), 0);
    83ba:	43c2      	mvns	r2, r0
    checksum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)pTCPHdr, hdrLen, checksum);
    83bc:	b292      	uxth	r2, r2
    83be:	4649      	mov	r1, r9
    83c0:	4650      	mov	r0, sl
    83c2:	f013 ff49 	bl	1c258 <TCPIP_Helper_CalcIPChecksum>
    83c6:	43c3      	mvns	r3, r0
    83c8:	b29b      	uxth	r3, r3
    if(loadLen)
    83ca:	f1b8 0f00 	cmp.w	r8, #0
    83ce:	d125      	bne.n	841c <_TcpSend+0x4dc>
        pv4Pkt->macPkt.pDSeg->segFlags &= ~TCPIP_MAC_SEG_FLAG_USER_PAYLOAD;
    83d0:	6931      	ldr	r1, [r6, #16]
    83d2:	8a0a      	ldrh	r2, [r1, #16]
    83d4:	f022 0208 	bic.w	r2, r2, #8
    83d8:	820a      	strh	r2, [r1, #16]
    pTCPHdr->Checksum = ~checksum;
    83da:	43db      	mvns	r3, r3
    83dc:	f8aa 3010 	strh.w	r3, [sl, #16]
    pktParams.ttl = pSkt->ttl;
    83e0:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
    83e4:	f88d 3005 	strb.w	r3, [sp, #5]
    pktParams.tosFlags = pSkt->tos;
    83e8:	f894 307f 	ldrb.w	r3, [r4, #127]	; 0x7f
    83ec:	f88d 3004 	strb.w	r3, [sp, #4]
    pktParams.df = 0;
    83f0:	f04f 0800 	mov.w	r8, #0
    83f4:	f88d 8006 	strb.w	r8, [sp, #6]
    TCPIP_IPV4_PacketFormatTx(pv4Pkt, IP_PROT_TCP, hdrLen + loadLen, &pktParams);
    83f8:	ab01      	add	r3, sp, #4
    83fa:	462a      	mov	r2, r5
    83fc:	2106      	movs	r1, #6
    83fe:	4630      	mov	r0, r6
    8400:	f00c faa6 	bl	14950 <TCPIP_IPV4_PacketFormatTx>
    pv4Pkt->macPkt.next = 0;    // single packet
    8404:	f8c6 8000 	str.w	r8, [r6]
    if(TCPIP_IPV4_PacketTransmit(pv4Pkt))
    8408:	4630      	mov	r0, r6
    840a:	f01b fef1 	bl	241f0 <TCPIP_IPV4_PacketTransmit>
    if(sendRes != _TCP_SEND_OK && pSkt->addType == IP_ADDRESS_TYPE_IPV4)
    840e:	2800      	cmp	r0, #0
    8410:	d0a7      	beq.n	8362 <_TcpSend+0x422>
    if(sendRes == _TCP_SEND_OK && (vTCPFlags & RST) != 0 )
    8412:	f017 0f04 	tst.w	r7, #4
    8416:	d10e      	bne.n	8436 <_TcpSend+0x4f6>
    8418:	2000      	movs	r0, #0
    841a:	e799      	b.n	8350 <_TcpSend+0x410>
        pv4Pkt->macPkt.pDSeg->segFlags |= TCPIP_MAC_SEG_FLAG_USER_PAYLOAD;
    841c:	6931      	ldr	r1, [r6, #16]
    841e:	8a0a      	ldrh	r2, [r1, #16]
    8420:	f042 0208 	orr.w	r2, r2, #8
    8424:	820a      	strh	r2, [r1, #16]
        checksum = ~TCPIP_Helper_PacketChecksum(&pv4Pkt->macPkt, ((TCP_V4_PACKET*)pv4Pkt)->tcpSeg[0].segLoad, loadLen, checksum);
    8426:	4642      	mov	r2, r8
    8428:	6cf1      	ldr	r1, [r6, #76]	; 0x4c
    842a:	4630      	mov	r0, r6
    842c:	f012 fc70 	bl	1ad10 <TCPIP_Helper_PacketChecksum>
    8430:	43c3      	mvns	r3, r0
    8432:	b29b      	uxth	r3, r3
    8434:	e7d1      	b.n	83da <_TcpSend+0x49a>
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    8436:	2000      	movs	r0, #0
    8438:	f01b f99c 	bl	23774 <OSAL_CRIT_Enter>
    *pSigHandler = pSkt->sigHandler;
    843c:	6f65      	ldr	r5, [r4, #116]	; 0x74
    *pSigParam = pSkt->sigParam;
    843e:	6fa7      	ldr	r7, [r4, #120]	; 0x78
    uint16_t sigMask = pSkt->sigMask;
    8440:	f8b4 6072 	ldrh.w	r6, [r4, #114]	; 0x72
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
    8444:	4601      	mov	r1, r0
    8446:	2000      	movs	r0, #0
    8448:	f01b face 	bl	239e8 <OSAL_CRIT_Leave>
        if(sigHandler != 0 && (sigMask & TCPIP_TCP_SIGNAL_TX_RST) != 0)
    844c:	b185      	cbz	r5, 8470 <_TcpSend+0x530>
    844e:	f016 0f08 	tst.w	r6, #8
    8452:	d00f      	beq.n	8474 <_TcpSend+0x534>
            (*sigHandler)(pSkt->sktIx, pSkt->pSktNet, TCPIP_TCP_SIGNAL_TX_RST, sigParam);
    8454:	463b      	mov	r3, r7
    8456:	2208      	movs	r2, #8
    8458:	6c21      	ldr	r1, [r4, #64]	; 0x40
    845a:	f9b4 0034 	ldrsh.w	r0, [r4, #52]	; 0x34
    845e:	47a8      	blx	r5
    8460:	2000      	movs	r0, #0
    8462:	e775      	b.n	8350 <_TcpSend+0x410>
            return _TCP_SEND_NO_PKT; 
    8464:	f06f 0001 	mvn.w	r0, #1
}
    8468:	4770      	bx	lr
        return _TCP_SEND_NO_MEMORY;
    846a:	f06f 0002 	mvn.w	r0, #2
    846e:	e76f      	b.n	8350 <_TcpSend+0x410>
    8470:	2000      	movs	r0, #0
    8472:	e76d      	b.n	8350 <_TcpSend+0x410>
    8474:	2000      	movs	r0, #0
    8476:	e76b      	b.n	8350 <_TcpSend+0x410>
            if(pSkt->Flags.bTXFIN)
    8478:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
    847c:	f013 0f01 	tst.w	r3, #1
    8480:	d128      	bne.n	84d4 <_TcpSend+0x594>
    loadLen = (uint16_t)len;  // save the TCP payload size
    8482:	f04f 0800 	mov.w	r8, #0
    8486:	e6b2      	b.n	81ee <_TcpSend+0x2ae>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
    8488:	4601      	mov	r1, r0
    848a:	2000      	movs	r0, #0
    848c:	f01b faac 	bl	239e8 <OSAL_CRIT_Leave>
    pv4Pkt = (TCP_V4_PACKET*)TCPIP_PKT_SocketAlloc(sizeof(TCP_V4_PACKET), sizeof(TCP_HEADER), sizeof(TCP_OPTIONS), allocFlags);
    8490:	f242 0306 	movw	r3, #8198	; 0x2006
    8494:	2204      	movs	r2, #4
    8496:	2114      	movs	r1, #20
    8498:	2074      	movs	r0, #116	; 0x74
    849a:	f019 fad7 	bl	21a4c <_TCPIP_PKT_SocketAlloc>
    if(pv4Pkt)
    849e:	4606      	mov	r6, r0
    84a0:	2800      	cmp	r0, #0
    84a2:	d0e2      	beq.n	846a <_TcpSend+0x52a>
// will be automatically freed by this function.
void            TCPIP_PKT_PacketFree(TCPIP_MAC_PACKET* pPkt);

static __inline__ void __attribute__((always_inline)) TCPIP_PKT_PacketAcknowledgeSet(TCPIP_MAC_PACKET* pPkt, TCPIP_MAC_PACKET_ACK_FUNC ackFunc, const void* ackParam)
{
    pPkt->ackFunc = ackFunc;
    84a4:	4b11      	ldr	r3, [pc, #68]	; (84ec <_TcpSend+0x5ac>)
    84a6:	6083      	str	r3, [r0, #8]
    pPkt->ackParam = ackParam;
    84a8:	60c4      	str	r4, [r0, #12]
        pv4Pkt->tcpSeg[0].segFlags = pv4Pkt->tcpSeg[1].segFlags = TCPIP_MAC_SEG_FLAG_STATIC; // embedded in packet itself
    84aa:	2301      	movs	r3, #1
    84ac:	f8a0 306c 	strh.w	r3, [r0, #108]	; 0x6c
    84b0:	f8a0 3054 	strh.w	r3, [r0, #84]	; 0x54
            pPkt->v4Pkt.macPkt.pktFlags |= TCPIP_MAC_PKT_FLAG_QUEUED;
    84b4:	8c43      	ldrh	r3, [r0, #34]	; 0x22
    84b6:	f043 0308 	orr.w	r3, r3, #8
    84ba:	8443      	strh	r3, [r0, #34]	; 0x22
            OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    84bc:	2000      	movs	r0, #0
    84be:	f01b f959 	bl	23774 <OSAL_CRIT_Enter>
            if(pSkt->pV4Pkt == 0)
    84c2:	6c63      	ldr	r3, [r4, #68]	; 0x44
    84c4:	2b00      	cmp	r3, #0
    84c6:	f43f adb4 	beq.w	8032 <_TcpSend+0xf2>
            OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
    84ca:	4601      	mov	r1, r0
    84cc:	2000      	movs	r0, #0
    84ce:	f01b fa8b 	bl	239e8 <OSAL_CRIT_Leave>
    84d2:	e566      	b.n	7fa2 <_TcpSend+0x62>
                if((len != pSkt->remoteWindow) && (len != maxPayload))
    84d4:	f8b4 805c 	ldrh.w	r8, [r4, #92]	; 0x5c
    84d8:	f1b8 0f00 	cmp.w	r8, #0
    84dc:	f43f ae87 	beq.w	81ee <_TcpSend+0x2ae>
                len = 0;
    84e0:	f04f 0900 	mov.w	r9, #0
    84e4:	e5fa      	b.n	80dc <_TcpSend+0x19c>
    84e6:	bf00      	nop
    84e8:	10624dd3 	.word	0x10624dd3
    84ec:	00015329 	.word	0x00015329

Disassembly of section .text._printf_float%223:

000084f0 <_printf_float>:
    84f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    84f4:	b08d      	sub	sp, #52	; 0x34
    84f6:	460c      	mov	r4, r1
    84f8:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
    84fc:	4693      	mov	fp, r2
    84fe:	461f      	mov	r7, r3
    8500:	4606      	mov	r6, r0
    8502:	f01b ffa5 	bl	24450 <_localeconv_r>
    8506:	6803      	ldr	r3, [r0, #0]
    8508:	9305      	str	r3, [sp, #20]
    850a:	4618      	mov	r0, r3
    850c:	f01b fcd8 	bl	23ec0 <strlen>
    8510:	f8d8 3000 	ldr.w	r3, [r8]
    8514:	9006      	str	r0, [sp, #24]
    8516:	3307      	adds	r3, #7
    8518:	f023 0307 	bic.w	r3, r3, #7
    851c:	f103 0208 	add.w	r2, r3, #8
    8520:	f894 a018 	ldrb.w	sl, [r4, #24]
    8524:	6825      	ldr	r5, [r4, #0]
    8526:	f8c8 2000 	str.w	r2, [r8]
    852a:	e9d3 2300 	ldrd	r2, r3, [r3]
    852e:	e9c4 2312 	strd	r2, r3, [r4, #72]	; 0x48
    8532:	ed94 7b12 	vldr	d7, [r4, #72]	; 0x48
    8536:	ed8d 7b02 	vstr	d7, [sp, #8]
    853a:	e9dd 8302 	ldrd	r8, r3, [sp, #8]
    853e:	f023 4900 	bic.w	r9, r3, #2147483648	; 0x80000000
    8542:	f04f 32ff 	mov.w	r2, #4294967295
    8546:	4ba2      	ldr	r3, [pc, #648]	; (87d0 <_printf_float+0x2e0>)
    8548:	4640      	mov	r0, r8
    854a:	4649      	mov	r1, r9
    854c:	f019 fbb2 	bl	21cb4 <__aeabi_dcmpun>
    8550:	bb70      	cbnz	r0, 85b0 <_printf_float+0xc0>
    8552:	f04f 32ff 	mov.w	r2, #4294967295
    8556:	4b9e      	ldr	r3, [pc, #632]	; (87d0 <_printf_float+0x2e0>)
    8558:	4640      	mov	r0, r8
    855a:	4649      	mov	r1, r9
    855c:	f00c fec6 	bl	152ec <__aeabi_dcmple>
    8560:	bb30      	cbnz	r0, 85b0 <_printf_float+0xc0>
    8562:	2200      	movs	r2, #0
    8564:	2300      	movs	r3, #0
    8566:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    856a:	f00c feb5 	bl	152d8 <__aeabi_dcmplt>
    856e:	b110      	cbz	r0, 8576 <_printf_float+0x86>
    8570:	232d      	movs	r3, #45	; 0x2d
    8572:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    8576:	4b97      	ldr	r3, [pc, #604]	; (87d4 <_printf_float+0x2e4>)
    8578:	1d1a      	adds	r2, r3, #4
    857a:	f025 0504 	bic.w	r5, r5, #4
    857e:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
    8582:	bf94      	ite	ls
    8584:	4699      	movls	r9, r3
    8586:	4691      	movhi	r9, r2
    8588:	6025      	str	r5, [r4, #0]
    858a:	2303      	movs	r3, #3
    858c:	2500      	movs	r5, #0
    858e:	6123      	str	r3, [r4, #16]
    8590:	46a8      	mov	r8, r5
    8592:	9700      	str	r7, [sp, #0]
    8594:	465b      	mov	r3, fp
    8596:	aa0a      	add	r2, sp, #40	; 0x28
    8598:	4621      	mov	r1, r4
    859a:	4630      	mov	r0, r6
    859c:	f00e f80e 	bl	165bc <_printf_common>
    85a0:	3001      	adds	r0, #1
    85a2:	f040 8109 	bne.w	87b8 <_printf_float+0x2c8>
    85a6:	f04f 30ff 	mov.w	r0, #4294967295
    85aa:	b00d      	add	sp, #52	; 0x34
    85ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    85b0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    85b4:	4610      	mov	r0, r2
    85b6:	4619      	mov	r1, r3
    85b8:	f019 fb7c 	bl	21cb4 <__aeabi_dcmpun>
    85bc:	b138      	cbz	r0, 85ce <_printf_float+0xde>
    85be:	9b03      	ldr	r3, [sp, #12]
    85c0:	2b00      	cmp	r3, #0
    85c2:	bfbc      	itt	lt
    85c4:	232d      	movlt	r3, #45	; 0x2d
    85c6:	f884 3043 	strblt.w	r3, [r4, #67]	; 0x43
    85ca:	4b83      	ldr	r3, [pc, #524]	; (87d8 <_printf_float+0x2e8>)
    85cc:	e7d4      	b.n	8578 <_printf_float+0x88>
    85ce:	6863      	ldr	r3, [r4, #4]
    85d0:	1c59      	adds	r1, r3, #1
    85d2:	f00a 08df 	and.w	r8, sl, #223	; 0xdf
    85d6:	d11c      	bne.n	8612 <_printf_float+0x122>
    85d8:	2306      	movs	r3, #6
    85da:	6063      	str	r3, [r4, #4]
    85dc:	f445 6380 	orr.w	r3, r5, #1024	; 0x400
    85e0:	6023      	str	r3, [r4, #0]
    85e2:	6863      	ldr	r3, [r4, #4]
    85e4:	9304      	str	r3, [sp, #16]
    85e6:	9b03      	ldr	r3, [sp, #12]
    85e8:	2b00      	cmp	r3, #0
    85ea:	da19      	bge.n	8620 <_printf_float+0x130>
    85ec:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
    85f0:	f081 4300 	eor.w	r3, r1, #2147483648	; 0x80000000
    85f4:	e9cd 2302 	strd	r2, r3, [sp, #8]
    85f8:	232d      	movs	r3, #45	; 0x2d
    85fa:	f1b8 0f46 	cmp.w	r8, #70	; 0x46
    85fe:	9307      	str	r3, [sp, #28]
    8600:	d010      	beq.n	8624 <_printf_float+0x134>
    8602:	f1b8 0f45 	cmp.w	r8, #69	; 0x45
    8606:	d102      	bne.n	860e <_printf_float+0x11e>
    8608:	9b04      	ldr	r3, [sp, #16]
    860a:	3301      	adds	r3, #1
    860c:	9304      	str	r3, [sp, #16]
    860e:	2102      	movs	r1, #2
    8610:	e009      	b.n	8626 <_printf_float+0x136>
    8612:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
    8616:	d1e1      	bne.n	85dc <_printf_float+0xec>
    8618:	2b00      	cmp	r3, #0
    861a:	d1df      	bne.n	85dc <_printf_float+0xec>
    861c:	2301      	movs	r3, #1
    861e:	e7dc      	b.n	85da <_printf_float+0xea>
    8620:	2300      	movs	r3, #0
    8622:	e7ea      	b.n	85fa <_printf_float+0x10a>
    8624:	2103      	movs	r1, #3
    8626:	ab0a      	add	r3, sp, #40	; 0x28
    8628:	9301      	str	r3, [sp, #4]
    862a:	ab09      	add	r3, sp, #36	; 0x24
    862c:	9300      	str	r3, [sp, #0]
    862e:	9a04      	ldr	r2, [sp, #16]
    8630:	ab08      	add	r3, sp, #32
    8632:	ed9d 0b02 	vldr	d0, [sp, #8]
    8636:	4630      	mov	r0, r6
    8638:	f7fc fcaa 	bl	4f90 <_dtoa_r>
    863c:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
    8640:	4681      	mov	r9, r0
    8642:	d150      	bne.n	86e6 <_printf_float+0x1f6>
    8644:	07ea      	lsls	r2, r5, #31
    8646:	d44e      	bmi.n	86e6 <_printf_float+0x1f6>
    8648:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    864a:	9a08      	ldr	r2, [sp, #32]
    864c:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
    8650:	eba5 0509 	sub.w	r5, r5, r9
    8654:	d171      	bne.n	873a <_printf_float+0x24a>
    8656:	1cd3      	adds	r3, r2, #3
    8658:	db03      	blt.n	8662 <_printf_float+0x172>
    865a:	6863      	ldr	r3, [r4, #4]
    865c:	4293      	cmp	r3, r2
    865e:	f280 809a 	bge.w	8796 <_printf_float+0x2a6>
    8662:	f1aa 0a02 	sub.w	sl, sl, #2
    8666:	fa5f fa8a 	uxtb.w	sl, sl
    866a:	1e53      	subs	r3, r2, #1
    866c:	2b00      	cmp	r3, #0
    866e:	9308      	str	r3, [sp, #32]
    8670:	bfb6      	itet	lt
    8672:	f1c2 0301 	rsblt	r3, r2, #1
    8676:	222b      	movge	r2, #43	; 0x2b
    8678:	222d      	movlt	r2, #45	; 0x2d
    867a:	2b09      	cmp	r3, #9
    867c:	f104 0850 	add.w	r8, r4, #80	; 0x50
    8680:	f884 a050 	strb.w	sl, [r4, #80]	; 0x50
    8684:	f884 2051 	strb.w	r2, [r4, #81]	; 0x51
    8688:	dd74      	ble.n	8774 <_printf_float+0x284>
    868a:	f10d 022f 	add.w	r2, sp, #47	; 0x2f
    868e:	f04f 0e0a 	mov.w	lr, #10
    8692:	fb93 f1fe 	sdiv	r1, r3, lr
    8696:	fb0e 3011 	mls	r0, lr, r1, r3
    869a:	3030      	adds	r0, #48	; 0x30
    869c:	2b63      	cmp	r3, #99	; 0x63
    869e:	f102 3cff 	add.w	ip, r2, #4294967295
    86a2:	f802 0c01 	strb.w	r0, [r2, #-1]
    86a6:	dc5d      	bgt.n	8764 <_printf_float+0x274>
    86a8:	3130      	adds	r1, #48	; 0x30
    86aa:	3a02      	subs	r2, #2
    86ac:	f80c 1c01 	strb.w	r1, [ip, #-1]
    86b0:	f104 0352 	add.w	r3, r4, #82	; 0x52
    86b4:	f10d 002f 	add.w	r0, sp, #47	; 0x2f
    86b8:	4282      	cmp	r2, r0
    86ba:	4619      	mov	r1, r3
    86bc:	d355      	bcc.n	876a <_printf_float+0x27a>
    86be:	eba1 0808 	sub.w	r8, r1, r8
    86c2:	eb05 0308 	add.w	r3, r5, r8
    86c6:	2d01      	cmp	r5, #1
    86c8:	6123      	str	r3, [r4, #16]
    86ca:	dc02      	bgt.n	86d2 <_printf_float+0x1e2>
    86cc:	6822      	ldr	r2, [r4, #0]
    86ce:	07d0      	lsls	r0, r2, #31
    86d0:	d501      	bpl.n	86d6 <_printf_float+0x1e6>
    86d2:	3301      	adds	r3, #1
    86d4:	6123      	str	r3, [r4, #16]
    86d6:	9b07      	ldr	r3, [sp, #28]
    86d8:	2b00      	cmp	r3, #0
    86da:	f43f af5a 	beq.w	8592 <_printf_float+0xa2>
    86de:	232d      	movs	r3, #45	; 0x2d
    86e0:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    86e4:	e755      	b.n	8592 <_printf_float+0xa2>
    86e6:	9b04      	ldr	r3, [sp, #16]
    86e8:	f1b8 0f46 	cmp.w	r8, #70	; 0x46
    86ec:	eb09 0503 	add.w	r5, r9, r3
    86f0:	d110      	bne.n	8714 <_printf_float+0x224>
    86f2:	f899 3000 	ldrb.w	r3, [r9]
    86f6:	2b30      	cmp	r3, #48	; 0x30
    86f8:	d10a      	bne.n	8710 <_printf_float+0x220>
    86fa:	2200      	movs	r2, #0
    86fc:	2300      	movs	r3, #0
    86fe:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    8702:	f00c fddf 	bl	152c4 <__aeabi_dcmpeq>
    8706:	b918      	cbnz	r0, 8710 <_printf_float+0x220>
    8708:	9b04      	ldr	r3, [sp, #16]
    870a:	f1c3 0301 	rsb	r3, r3, #1
    870e:	9308      	str	r3, [sp, #32]
    8710:	9b08      	ldr	r3, [sp, #32]
    8712:	441d      	add	r5, r3
    8714:	2200      	movs	r2, #0
    8716:	2300      	movs	r3, #0
    8718:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    871c:	f00c fdd2 	bl	152c4 <__aeabi_dcmpeq>
    8720:	b100      	cbz	r0, 8724 <_printf_float+0x234>
    8722:	950a      	str	r5, [sp, #40]	; 0x28
    8724:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8726:	429d      	cmp	r5, r3
    8728:	d98e      	bls.n	8648 <_printf_float+0x158>
    872a:	2230      	movs	r2, #48	; 0x30
    872c:	1c59      	adds	r1, r3, #1
    872e:	910a      	str	r1, [sp, #40]	; 0x28
    8730:	701a      	strb	r2, [r3, #0]
    8732:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8734:	429d      	cmp	r5, r3
    8736:	d8f9      	bhi.n	872c <_printf_float+0x23c>
    8738:	e786      	b.n	8648 <_printf_float+0x158>
    873a:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
    873e:	d994      	bls.n	866a <_printf_float+0x17a>
    8740:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
    8744:	d129      	bne.n	879a <_printf_float+0x2aa>
    8746:	2a00      	cmp	r2, #0
    8748:	6863      	ldr	r3, [r4, #4]
    874a:	dd1c      	ble.n	8786 <_printf_float+0x296>
    874c:	6122      	str	r2, [r4, #16]
    874e:	b913      	cbnz	r3, 8756 <_printf_float+0x266>
    8750:	6821      	ldr	r1, [r4, #0]
    8752:	07c9      	lsls	r1, r1, #31
    8754:	d502      	bpl.n	875c <_printf_float+0x26c>
    8756:	3301      	adds	r3, #1
    8758:	4413      	add	r3, r2
    875a:	6123      	str	r3, [r4, #16]
    875c:	65a2      	str	r2, [r4, #88]	; 0x58
    875e:	f04f 0800 	mov.w	r8, #0
    8762:	e7b8      	b.n	86d6 <_printf_float+0x1e6>
    8764:	4662      	mov	r2, ip
    8766:	460b      	mov	r3, r1
    8768:	e793      	b.n	8692 <_printf_float+0x1a2>
    876a:	f812 1b01 	ldrb.w	r1, [r2], #1
    876e:	f803 1b01 	strb.w	r1, [r3], #1
    8772:	e7a1      	b.n	86b8 <_printf_float+0x1c8>
    8774:	2230      	movs	r2, #48	; 0x30
    8776:	4413      	add	r3, r2
    8778:	f884 2052 	strb.w	r2, [r4, #82]	; 0x52
    877c:	f104 0154 	add.w	r1, r4, #84	; 0x54
    8780:	f884 3053 	strb.w	r3, [r4, #83]	; 0x53
    8784:	e79b      	b.n	86be <_printf_float+0x1ce>
    8786:	b913      	cbnz	r3, 878e <_printf_float+0x29e>
    8788:	6821      	ldr	r1, [r4, #0]
    878a:	07c8      	lsls	r0, r1, #31
    878c:	d501      	bpl.n	8792 <_printf_float+0x2a2>
    878e:	3302      	adds	r3, #2
    8790:	e7e3      	b.n	875a <_printf_float+0x26a>
    8792:	2301      	movs	r3, #1
    8794:	e7e1      	b.n	875a <_printf_float+0x26a>
    8796:	f04f 0a67 	mov.w	sl, #103	; 0x67
    879a:	42aa      	cmp	r2, r5
    879c:	db05      	blt.n	87aa <_printf_float+0x2ba>
    879e:	6823      	ldr	r3, [r4, #0]
    87a0:	6122      	str	r2, [r4, #16]
    87a2:	07d9      	lsls	r1, r3, #31
    87a4:	d5da      	bpl.n	875c <_printf_float+0x26c>
    87a6:	1c53      	adds	r3, r2, #1
    87a8:	e7d7      	b.n	875a <_printf_float+0x26a>
    87aa:	2a00      	cmp	r2, #0
    87ac:	bfd4      	ite	le
    87ae:	f1c2 0302 	rsble	r3, r2, #2
    87b2:	2301      	movgt	r3, #1
    87b4:	442b      	add	r3, r5
    87b6:	e7d0      	b.n	875a <_printf_float+0x26a>
    87b8:	6823      	ldr	r3, [r4, #0]
    87ba:	055a      	lsls	r2, r3, #21
    87bc:	d40e      	bmi.n	87dc <_printf_float+0x2ec>
    87be:	6923      	ldr	r3, [r4, #16]
    87c0:	464a      	mov	r2, r9
    87c2:	4659      	mov	r1, fp
    87c4:	4630      	mov	r0, r6
    87c6:	47b8      	blx	r7
    87c8:	3001      	adds	r0, #1
    87ca:	d12f      	bne.n	882c <_printf_float+0x33c>
    87cc:	e6eb      	b.n	85a6 <_printf_float+0xb6>
    87ce:	bf00      	nop
    87d0:	7fefffff 	.word	0x7fefffff
    87d4:	00023cd8 	.word	0x00023cd8
    87d8:	00023ce0 	.word	0x00023ce0
    87dc:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
    87e0:	f240 80c9 	bls.w	8976 <_printf_float+0x486>
    87e4:	2200      	movs	r2, #0
    87e6:	2300      	movs	r3, #0
    87e8:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
    87ec:	f00c fd6a 	bl	152c4 <__aeabi_dcmpeq>
    87f0:	b388      	cbz	r0, 8856 <_printf_float+0x366>
    87f2:	2301      	movs	r3, #1
    87f4:	4a88      	ldr	r2, [pc, #544]	; (8a18 <_printf_float+0x528>)
    87f6:	4659      	mov	r1, fp
    87f8:	4630      	mov	r0, r6
    87fa:	47b8      	blx	r7
    87fc:	3001      	adds	r0, #1
    87fe:	f43f aed2 	beq.w	85a6 <_printf_float+0xb6>
    8802:	9b08      	ldr	r3, [sp, #32]
    8804:	42ab      	cmp	r3, r5
    8806:	db02      	blt.n	880e <_printf_float+0x31e>
    8808:	6823      	ldr	r3, [r4, #0]
    880a:	07d8      	lsls	r0, r3, #31
    880c:	d50e      	bpl.n	882c <_printf_float+0x33c>
    880e:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
    8812:	4659      	mov	r1, fp
    8814:	4630      	mov	r0, r6
    8816:	47b8      	blx	r7
    8818:	3001      	adds	r0, #1
    881a:	f43f aec4 	beq.w	85a6 <_printf_float+0xb6>
    881e:	f04f 0800 	mov.w	r8, #0
    8822:	3d01      	subs	r5, #1
    8824:	f104 091a 	add.w	r9, r4, #26
    8828:	4545      	cmp	r5, r8
    882a:	dc09      	bgt.n	8840 <_printf_float+0x350>
    882c:	6823      	ldr	r3, [r4, #0]
    882e:	079d      	lsls	r5, r3, #30
    8830:	f100 80ed 	bmi.w	8a0e <_printf_float+0x51e>
    8834:	68e0      	ldr	r0, [r4, #12]
    8836:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8838:	4298      	cmp	r0, r3
    883a:	bfb8      	it	lt
    883c:	4618      	movlt	r0, r3
    883e:	e6b4      	b.n	85aa <_printf_float+0xba>
    8840:	2301      	movs	r3, #1
    8842:	464a      	mov	r2, r9
    8844:	4659      	mov	r1, fp
    8846:	4630      	mov	r0, r6
    8848:	47b8      	blx	r7
    884a:	3001      	adds	r0, #1
    884c:	f43f aeab 	beq.w	85a6 <_printf_float+0xb6>
    8850:	f108 0801 	add.w	r8, r8, #1
    8854:	e7e8      	b.n	8828 <_printf_float+0x338>
    8856:	9b08      	ldr	r3, [sp, #32]
    8858:	2b00      	cmp	r3, #0
    885a:	dc2a      	bgt.n	88b2 <_printf_float+0x3c2>
    885c:	2301      	movs	r3, #1
    885e:	4a6e      	ldr	r2, [pc, #440]	; (8a18 <_printf_float+0x528>)
    8860:	4659      	mov	r1, fp
    8862:	4630      	mov	r0, r6
    8864:	47b8      	blx	r7
    8866:	3001      	adds	r0, #1
    8868:	f43f ae9d 	beq.w	85a6 <_printf_float+0xb6>
    886c:	9b08      	ldr	r3, [sp, #32]
    886e:	432b      	orrs	r3, r5
    8870:	d102      	bne.n	8878 <_printf_float+0x388>
    8872:	6823      	ldr	r3, [r4, #0]
    8874:	07d9      	lsls	r1, r3, #31
    8876:	d5d9      	bpl.n	882c <_printf_float+0x33c>
    8878:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
    887c:	4659      	mov	r1, fp
    887e:	4630      	mov	r0, r6
    8880:	47b8      	blx	r7
    8882:	3001      	adds	r0, #1
    8884:	f43f ae8f 	beq.w	85a6 <_printf_float+0xb6>
    8888:	f04f 0800 	mov.w	r8, #0
    888c:	f104 0a1a 	add.w	sl, r4, #26
    8890:	9b08      	ldr	r3, [sp, #32]
    8892:	425b      	negs	r3, r3
    8894:	4543      	cmp	r3, r8
    8896:	dc01      	bgt.n	889c <_printf_float+0x3ac>
    8898:	462b      	mov	r3, r5
    889a:	e791      	b.n	87c0 <_printf_float+0x2d0>
    889c:	2301      	movs	r3, #1
    889e:	4652      	mov	r2, sl
    88a0:	4659      	mov	r1, fp
    88a2:	4630      	mov	r0, r6
    88a4:	47b8      	blx	r7
    88a6:	3001      	adds	r0, #1
    88a8:	f43f ae7d 	beq.w	85a6 <_printf_float+0xb6>
    88ac:	f108 0801 	add.w	r8, r8, #1
    88b0:	e7ee      	b.n	8890 <_printf_float+0x3a0>
    88b2:	6da3      	ldr	r3, [r4, #88]	; 0x58
    88b4:	42ab      	cmp	r3, r5
    88b6:	bfa8      	it	ge
    88b8:	462b      	movge	r3, r5
    88ba:	2b00      	cmp	r3, #0
    88bc:	4698      	mov	r8, r3
    88be:	dd06      	ble.n	88ce <_printf_float+0x3de>
    88c0:	464a      	mov	r2, r9
    88c2:	4659      	mov	r1, fp
    88c4:	4630      	mov	r0, r6
    88c6:	47b8      	blx	r7
    88c8:	3001      	adds	r0, #1
    88ca:	f43f ae6c 	beq.w	85a6 <_printf_float+0xb6>
    88ce:	2300      	movs	r3, #0
    88d0:	9302      	str	r3, [sp, #8]
    88d2:	f104 031a 	add.w	r3, r4, #26
    88d6:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
    88da:	9304      	str	r3, [sp, #16]
    88dc:	e00a      	b.n	88f4 <_printf_float+0x404>
    88de:	2301      	movs	r3, #1
    88e0:	9a04      	ldr	r2, [sp, #16]
    88e2:	4659      	mov	r1, fp
    88e4:	4630      	mov	r0, r6
    88e6:	47b8      	blx	r7
    88e8:	3001      	adds	r0, #1
    88ea:	f43f ae5c 	beq.w	85a6 <_printf_float+0xb6>
    88ee:	9b02      	ldr	r3, [sp, #8]
    88f0:	3301      	adds	r3, #1
    88f2:	9302      	str	r3, [sp, #8]
    88f4:	f8d4 a058 	ldr.w	sl, [r4, #88]	; 0x58
    88f8:	9a02      	ldr	r2, [sp, #8]
    88fa:	ebaa 0308 	sub.w	r3, sl, r8
    88fe:	4293      	cmp	r3, r2
    8900:	dced      	bgt.n	88de <_printf_float+0x3ee>
    8902:	9b08      	ldr	r3, [sp, #32]
    8904:	42ab      	cmp	r3, r5
    8906:	db1a      	blt.n	893e <_printf_float+0x44e>
    8908:	6823      	ldr	r3, [r4, #0]
    890a:	07da      	lsls	r2, r3, #31
    890c:	d417      	bmi.n	893e <_printf_float+0x44e>
    890e:	9b08      	ldr	r3, [sp, #32]
    8910:	459a      	cmp	sl, r3
    8912:	db1c      	blt.n	894e <_printf_float+0x45e>
    8914:	eba5 080a 	sub.w	r8, r5, sl
    8918:	f1b8 0f00 	cmp.w	r8, #0
    891c:	dd08      	ble.n	8930 <_printf_float+0x440>
    891e:	4643      	mov	r3, r8
    8920:	eb09 020a 	add.w	r2, r9, sl
    8924:	4659      	mov	r1, fp
    8926:	4630      	mov	r0, r6
    8928:	47b8      	blx	r7
    892a:	3001      	adds	r0, #1
    892c:	f43f ae3b 	beq.w	85a6 <_printf_float+0xb6>
    8930:	f04f 0900 	mov.w	r9, #0
    8934:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
    8938:	f104 0a1a 	add.w	sl, r4, #26
    893c:	e014      	b.n	8968 <_printf_float+0x478>
    893e:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
    8942:	4659      	mov	r1, fp
    8944:	4630      	mov	r0, r6
    8946:	47b8      	blx	r7
    8948:	3001      	adds	r0, #1
    894a:	d1e0      	bne.n	890e <_printf_float+0x41e>
    894c:	e62b      	b.n	85a6 <_printf_float+0xb6>
    894e:	eba5 0803 	sub.w	r8, r5, r3
    8952:	e7e1      	b.n	8918 <_printf_float+0x428>
    8954:	2301      	movs	r3, #1
    8956:	4652      	mov	r2, sl
    8958:	4659      	mov	r1, fp
    895a:	4630      	mov	r0, r6
    895c:	47b8      	blx	r7
    895e:	3001      	adds	r0, #1
    8960:	f43f ae21 	beq.w	85a6 <_printf_float+0xb6>
    8964:	f109 0901 	add.w	r9, r9, #1
    8968:	9b08      	ldr	r3, [sp, #32]
    896a:	1aeb      	subs	r3, r5, r3
    896c:	eba3 0308 	sub.w	r3, r3, r8
    8970:	454b      	cmp	r3, r9
    8972:	dcef      	bgt.n	8954 <_printf_float+0x464>
    8974:	e75a      	b.n	882c <_printf_float+0x33c>
    8976:	2d01      	cmp	r5, #1
    8978:	dc01      	bgt.n	897e <_printf_float+0x48e>
    897a:	07db      	lsls	r3, r3, #31
    897c:	d535      	bpl.n	89ea <_printf_float+0x4fa>
    897e:	2301      	movs	r3, #1
    8980:	464a      	mov	r2, r9
    8982:	4659      	mov	r1, fp
    8984:	4630      	mov	r0, r6
    8986:	47b8      	blx	r7
    8988:	3001      	adds	r0, #1
    898a:	f43f ae0c 	beq.w	85a6 <_printf_float+0xb6>
    898e:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
    8992:	4659      	mov	r1, fp
    8994:	4630      	mov	r0, r6
    8996:	47b8      	blx	r7
    8998:	3001      	adds	r0, #1
    899a:	f43f ae04 	beq.w	85a6 <_printf_float+0xb6>
    899e:	2200      	movs	r2, #0
    89a0:	2300      	movs	r3, #0
    89a2:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
    89a6:	3d01      	subs	r5, #1
    89a8:	f00c fc8c 	bl	152c4 <__aeabi_dcmpeq>
    89ac:	b9c0      	cbnz	r0, 89e0 <_printf_float+0x4f0>
    89ae:	462b      	mov	r3, r5
    89b0:	f109 0201 	add.w	r2, r9, #1
    89b4:	4659      	mov	r1, fp
    89b6:	4630      	mov	r0, r6
    89b8:	47b8      	blx	r7
    89ba:	3001      	adds	r0, #1
    89bc:	d10c      	bne.n	89d8 <_printf_float+0x4e8>
    89be:	e5f2      	b.n	85a6 <_printf_float+0xb6>
    89c0:	2301      	movs	r3, #1
    89c2:	4652      	mov	r2, sl
    89c4:	4659      	mov	r1, fp
    89c6:	4630      	mov	r0, r6
    89c8:	47b8      	blx	r7
    89ca:	3001      	adds	r0, #1
    89cc:	f43f adeb 	beq.w	85a6 <_printf_float+0xb6>
    89d0:	f109 0901 	add.w	r9, r9, #1
    89d4:	454d      	cmp	r5, r9
    89d6:	dcf3      	bgt.n	89c0 <_printf_float+0x4d0>
    89d8:	4643      	mov	r3, r8
    89da:	f104 0250 	add.w	r2, r4, #80	; 0x50
    89de:	e6f0      	b.n	87c2 <_printf_float+0x2d2>
    89e0:	f04f 0900 	mov.w	r9, #0
    89e4:	f104 0a1a 	add.w	sl, r4, #26
    89e8:	e7f4      	b.n	89d4 <_printf_float+0x4e4>
    89ea:	2301      	movs	r3, #1
    89ec:	464a      	mov	r2, r9
    89ee:	e7e1      	b.n	89b4 <_printf_float+0x4c4>
    89f0:	2301      	movs	r3, #1
    89f2:	4642      	mov	r2, r8
    89f4:	4659      	mov	r1, fp
    89f6:	4630      	mov	r0, r6
    89f8:	47b8      	blx	r7
    89fa:	3001      	adds	r0, #1
    89fc:	f43f add3 	beq.w	85a6 <_printf_float+0xb6>
    8a00:	3501      	adds	r5, #1
    8a02:	68e3      	ldr	r3, [r4, #12]
    8a04:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    8a06:	1a9b      	subs	r3, r3, r2
    8a08:	42ab      	cmp	r3, r5
    8a0a:	dcf1      	bgt.n	89f0 <_printf_float+0x500>
    8a0c:	e712      	b.n	8834 <_printf_float+0x344>
    8a0e:	2500      	movs	r5, #0
    8a10:	f104 0819 	add.w	r8, r4, #25
    8a14:	e7f5      	b.n	8a02 <_printf_float+0x512>
    8a16:	bf00      	nop
    8a18:	00023ce8 	.word	0x00023ce8

Disassembly of section .text._Command_DNS_Service%224:

00008a1c <_Command_DNS_Service>:
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Failed to %s %s\r\n", msgFail, argv[0]);
    }
    return true;
}
static int _Command_DNS_Service(SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char** argv)
{
    8a1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8a20:	b0c3      	sub	sp, #268	; 0x10c
    8a22:	4605      	mov	r5, r0
    8a24:	4688      	mov	r8, r1
    8a26:	4691      	mov	r9, r2
    uint8_t             *hostName;
    const void* cmdIoParam = pCmdIO->cmdIoParam;
    8a28:	6846      	ldr	r6, [r0, #4]
    TCPIP_DNS_RESULT res;
    DNS_SERVICE_COMD_TYPE val=DNS_SERVICE_COMD_NONE;
    DNSS_COMMAND_MAP dnssComnd[]=
    8a2a:	ac38      	add	r4, sp, #224	; 0xe0
    8a2c:	4fa0      	ldr	r7, [pc, #640]	; (8cb0 <_Command_DNS_Service+0x294>)
    8a2e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    8a30:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    8a32:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    8a34:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    8a36:	e897 0003 	ldmia.w	r7, {r0, r1}
    8a3a:	e884 0003 	stmia.w	r4, {r0, r1}
                {"off",         DNS_SERVICE_COMD_ENABLE_INTF},
                {"lookup",      DNS_SERVICE_COMD_LOOKUP},
            };
    int i=0;

    if (argc < 2) {
    8a3e:	f1b8 0f01 	cmp.w	r8, #1
    8a42:	dd16      	ble.n	8a72 <_Command_DNS_Service+0x56>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: dnsc <del/info/on/off/lookup> \r\n");
        return false;
    }
    for(i=0;i<(sizeof(dnssComnd)/sizeof(DNSS_COMMAND_MAP));i++)
    {
        if(strcmp(argv[1],dnssComnd[i].command) ==0)
    8a44:	f8d9 a004 	ldr.w	sl, [r9, #4]
    for(i=0;i<(sizeof(dnssComnd)/sizeof(DNSS_COMMAND_MAP));i++)
    8a48:	2700      	movs	r7, #0
        if(strcmp(argv[1],dnssComnd[i].command) ==0)
    8a4a:	f10d 0be0 	add.w	fp, sp, #224	; 0xe0
    8a4e:	f85b 1037 	ldr.w	r1, [fp, r7, lsl #3]
    8a52:	4650      	mov	r0, sl
    8a54:	f01b f8d2 	bl	23bfc <strcmp>
    8a58:	4604      	mov	r4, r0
    8a5a:	b1a8      	cbz	r0, 8a88 <_Command_DNS_Service+0x6c>
    for(i=0;i<(sizeof(dnssComnd)/sizeof(DNSS_COMMAND_MAP));i++)
    8a5c:	3701      	adds	r7, #1
    8a5e:	2f05      	cmp	r7, #5
    8a60:	d1f5      	bne.n	8a4e <_Command_DNS_Service+0x32>
            break;
        case DNS_SERVICE_COMD_INFO:
            _Command_ShowDNSResolvedInfo(pCmdIO,argc,argv);
            break;
        default:
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Invalid Input Command :[ %s ] \r\n", argv[1]);
    8a62:	682b      	ldr	r3, [r5, #0]
    8a64:	685b      	ldr	r3, [r3, #4]
    8a66:	4652      	mov	r2, sl
    8a68:	4992      	ldr	r1, [pc, #584]	; (8cb4 <_Command_DNS_Service+0x298>)
    8a6a:	4630      	mov	r0, r6
    8a6c:	4798      	blx	r3
            return false;
    8a6e:	2400      	movs	r4, #0
    8a70:	e006      	b.n	8a80 <_Command_DNS_Service+0x64>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: dnsc <del/info/on/off/lookup> \r\n");
    8a72:	682b      	ldr	r3, [r5, #0]
    8a74:	681b      	ldr	r3, [r3, #0]
    8a76:	f107 0108 	add.w	r1, r7, #8
    8a7a:	4630      	mov	r0, r6
    8a7c:	4798      	blx	r3
        return false;
    8a7e:	2400      	movs	r4, #0
    }
    return true;
}
    8a80:	4620      	mov	r0, r4
    8a82:	b043      	add	sp, #268	; 0x10c
    8a84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            val = dnssComnd[i].val;
    8a88:	ab42      	add	r3, sp, #264	; 0x108
    8a8a:	eb03 07c7 	add.w	r7, r3, r7, lsl #3
    switch(val)
    8a8e:	f817 3c24 	ldrb.w	r3, [r7, #-36]
    8a92:	3b01      	subs	r3, #1
    8a94:	2b03      	cmp	r3, #3
    8a96:	d8e4      	bhi.n	8a62 <_Command_DNS_Service+0x46>
    8a98:	e8df f013 	tbh	[pc, r3, lsl #1]
    8a9c:	016a00f3 	.word	0x016a00f3
    8aa0:	00680004 	.word	0x00680004
    if (argc < 3)
    8aa4:	f1b8 0f02 	cmp.w	r8, #2
    8aa8:	dc12      	bgt.n	8ad0 <_Command_DNS_Service+0xb4>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Usage: %s <on/off> <interface> <strict/pref>/<clear> \r\n", argv[0]);
    8aaa:	4c83      	ldr	r4, [pc, #524]	; (8cb8 <_Command_DNS_Service+0x29c>)
    8aac:	682b      	ldr	r3, [r5, #0]
    8aae:	685b      	ldr	r3, [r3, #4]
    8ab0:	f8d9 2000 	ldr.w	r2, [r9]
    8ab4:	f504 7134 	add.w	r1, r4, #720	; 0x2d0
    8ab8:	4630      	mov	r0, r6
    8aba:	4798      	blx	r3
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Ex: %s on eth0\r\n", argv[0]);
    8abc:	682b      	ldr	r3, [r5, #0]
    8abe:	685b      	ldr	r3, [r3, #4]
    8ac0:	f8d9 2000 	ldr.w	r2, [r9]
    8ac4:	f504 7142 	add.w	r1, r4, #776	; 0x308
    8ac8:	4630      	mov	r0, r6
    8aca:	4798      	blx	r3
    return true;
    8acc:	2401      	movs	r4, #1
    8ace:	e7d7      	b.n	8a80 <_Command_DNS_Service+0x64>
    netH = TCPIP_STACK_NetHandleGet(argv[2]);
    8ad0:	f8d9 0008 	ldr.w	r0, [r9, #8]
    8ad4:	f016 ffc6 	bl	1fa64 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
    8ad8:	4607      	mov	r7, r0
    8ada:	b1e8      	cbz	r0, 8b18 <_Command_DNS_Service+0xfc>
    if (memcmp(argv[1], "on", 2) == 0)
    8adc:	f8d9 4004 	ldr.w	r4, [r9, #4]
    8ae0:	2202      	movs	r2, #2
    8ae2:	4976      	ldr	r1, [pc, #472]	; (8cbc <_Command_DNS_Service+0x2a0>)
    8ae4:	4620      	mov	r0, r4
    8ae6:	f01a fbf3 	bl	232d0 <memcmp>
    8aea:	b9e0      	cbnz	r0, 8b26 <_Command_DNS_Service+0x10a>
        if(argc > 3)
    8aec:	f1b8 0f03 	cmp.w	r8, #3
    8af0:	f340 81ed 	ble.w	8ece <_Command_DNS_Service+0x4b2>
            if(strcmp(argv[3], "strict") == 0)
    8af4:	f8d9 400c 	ldr.w	r4, [r9, #12]
    8af8:	4971      	ldr	r1, [pc, #452]	; (8cc0 <_Command_DNS_Service+0x2a4>)
    8afa:	4620      	mov	r0, r4
    8afc:	f01b f87e 	bl	23bfc <strcmp>
    8b00:	2800      	cmp	r0, #0
    8b02:	f000 81f9 	beq.w	8ef8 <_Command_DNS_Service+0x4dc>
            else if(strcmp(argv[3], "pref") == 0)
    8b06:	496f      	ldr	r1, [pc, #444]	; (8cc4 <_Command_DNS_Service+0x2a8>)
    8b08:	4620      	mov	r0, r4
    8b0a:	f01b f877 	bl	23bfc <strcmp>
    8b0e:	2800      	cmp	r0, #0
                enableFlags = TCPIP_DNS_ENABLE_PREFERRED;
    8b10:	bf14      	ite	ne
    8b12:	2100      	movne	r1, #0
    8b14:	2102      	moveq	r1, #2
    8b16:	e1db      	b.n	8ed0 <_Command_DNS_Service+0x4b4>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface\r\n");
    8b18:	682b      	ldr	r3, [r5, #0]
    8b1a:	681b      	ldr	r3, [r3, #0]
    8b1c:	496a      	ldr	r1, [pc, #424]	; (8cc8 <_Command_DNS_Service+0x2ac>)
    8b1e:	4630      	mov	r0, r6
    8b20:	4798      	blx	r3
    return true;
    8b22:	2401      	movs	r4, #1
    8b24:	e7ac      	b.n	8a80 <_Command_DNS_Service+0x64>
    else if (memcmp(argv[1], "off", 2) == 0)
    8b26:	2202      	movs	r2, #2
    8b28:	4968      	ldr	r1, [pc, #416]	; (8ccc <_Command_DNS_Service+0x2b0>)
    8b2a:	4620      	mov	r0, r4
    8b2c:	f01a fbd0 	bl	232d0 <memcmp>
    8b30:	b960      	cbnz	r0, 8b4c <_Command_DNS_Service+0x130>
        if(argc > 3)
    8b32:	f1b8 0f03 	cmp.w	r8, #3
    8b36:	f340 81e1 	ble.w	8efc <_Command_DNS_Service+0x4e0>
            if(strcmp(argv[3], "clear") == 0)
    8b3a:	4965      	ldr	r1, [pc, #404]	; (8cd0 <_Command_DNS_Service+0x2b4>)
    8b3c:	f8d9 000c 	ldr.w	r0, [r9, #12]
    8b40:	f01b f85c 	bl	23bfc <strcmp>
    8b44:	fab0 f180 	clz	r1, r0
    8b48:	0949      	lsrs	r1, r1, #5
    8b4a:	e1d8      	b.n	8efe <_Command_DNS_Service+0x4e2>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown option\r\n");
    8b4c:	682b      	ldr	r3, [r5, #0]
    8b4e:	681b      	ldr	r3, [r3, #0]
    8b50:	4960      	ldr	r1, [pc, #384]	; (8cd4 <_Command_DNS_Service+0x2b8>)
    8b52:	4630      	mov	r0, r6
    8b54:	4798      	blx	r3
    return true;
    8b56:	2401      	movs	r4, #1
    8b58:	e792      	b.n	8a80 <_Command_DNS_Service+0x64>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Failed to %s %s\r\n", msgFail, argv[0]);
    8b5a:	682b      	ldr	r3, [r5, #0]
    8b5c:	685c      	ldr	r4, [r3, #4]
    8b5e:	f8d9 3000 	ldr.w	r3, [r9]
    8b62:	495d      	ldr	r1, [pc, #372]	; (8cd8 <_Command_DNS_Service+0x2bc>)
    8b64:	4630      	mov	r0, r6
    8b66:	47a0      	blx	r4
    return true;
    8b68:	2401      	movs	r4, #1
    8b6a:	e789      	b.n	8a80 <_Command_DNS_Service+0x64>
            if (argc != 4) {
    8b6c:	f1b8 0f04 	cmp.w	r8, #4
    8b70:	d01f      	beq.n	8bb2 <_Command_DNS_Service+0x196>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: dnsc lookup <type> <hostName> \r\n");
    8b72:	4f51      	ldr	r7, [pc, #324]	; (8cb8 <_Command_DNS_Service+0x29c>)
    8b74:	682b      	ldr	r3, [r5, #0]
    8b76:	681b      	ldr	r3, [r3, #0]
    8b78:	f507 714d 	add.w	r1, r7, #820	; 0x334
    8b7c:	4630      	mov	r0, r6
    8b7e:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: <hostName>(URL) - look up for hostname\r\n");
    8b80:	682b      	ldr	r3, [r5, #0]
    8b82:	681b      	ldr	r3, [r3, #0]
    8b84:	f507 7157 	add.w	r1, r7, #860	; 0x35c
    8b88:	4630      	mov	r0, r6
    8b8a:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: <type> : a or A for IPv4 address lookup\r\n");
    8b8c:	682b      	ldr	r3, [r5, #0]
    8b8e:	681b      	ldr	r3, [r3, #0]
    8b90:	f507 7163 	add.w	r1, r7, #908	; 0x38c
    8b94:	4630      	mov	r0, r6
    8b96:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: <type> : aaaa or AAAA for IPv6 address lookup\r\n");
    8b98:	682b      	ldr	r3, [r5, #0]
    8b9a:	681b      	ldr	r3, [r3, #0]
    8b9c:	f507 716f 	add.w	r1, r7, #956	; 0x3bc
    8ba0:	4630      	mov	r0, r6
    8ba2:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: <type> : any for both IPv4 and IPv6 address lookup\r\n");
    8ba4:	682b      	ldr	r3, [r5, #0]
    8ba6:	681b      	ldr	r3, [r3, #0]
    8ba8:	f507 717d 	add.w	r1, r7, #1012	; 0x3f4
    8bac:	4630      	mov	r0, r6
    8bae:	4798      	blx	r3
                return false;
    8bb0:	e766      	b.n	8a80 <_Command_DNS_Service+0x64>


static int _Command_DNSLookUP(SYS_CMD_DEVICE_NODE* pCmdIO, char** argv)
{
    if(tcpipCmdStat != TCPIP_CMD_STAT_IDLE)
    8bb2:	4b4a      	ldr	r3, [pc, #296]	; (8cdc <_Command_DNS_Service+0x2c0>)
    8bb4:	781b      	ldrb	r3, [r3, #0]
    8bb6:	b9e3      	cbnz	r3, 8bf2 <_Command_DNS_Service+0x1d6>
    {
        (*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, "dnsc lookup: command in progress. Retry later.\r\n");
        return true;
    }

    if((strcmp(argv[2], "A") == 0) || (strcmp(argv[2], "a") == 0))
    8bb8:	f8d9 4008 	ldr.w	r4, [r9, #8]
    8bbc:	4948      	ldr	r1, [pc, #288]	; (8ce0 <_Command_DNS_Service+0x2c4>)
    8bbe:	4620      	mov	r0, r4
    8bc0:	f01b f81c 	bl	23bfc <strcmp>
    8bc4:	b120      	cbz	r0, 8bd0 <_Command_DNS_Service+0x1b4>
    8bc6:	4947      	ldr	r1, [pc, #284]	; (8ce4 <_Command_DNS_Service+0x2c8>)
    8bc8:	4620      	mov	r0, r4
    8bca:	f01b f817 	bl	23bfc <strcmp>
    8bce:	b9b8      	cbnz	r0, 8c00 <_Command_DNS_Service+0x1e4>
    {
        dnsType=TCPIP_DNS_TYPE_A;
    8bd0:	4b45      	ldr	r3, [pc, #276]	; (8ce8 <_Command_DNS_Service+0x2cc>)
    8bd2:	2201      	movs	r2, #1
    8bd4:	701a      	strb	r2, [r3, #0]
    {
        (*pCmdIO->pCmdApi->print)(pCmdIO->cmdIoParam, "dnsc lookup: [%s] Lookup Type not supported.\r\n",argv[2]);
        return true;
    }

    if(strlen(argv[3]) > sizeof(dnslookupTargetHost) - 1)
    8bd6:	f8d9 400c 	ldr.w	r4, [r9, #12]
    8bda:	4620      	mov	r0, r4
    8bdc:	f01b f970 	bl	23ec0 <strlen>
    8be0:	281e      	cmp	r0, #30
    8be2:	d931      	bls.n	8c48 <_Command_DNS_Service+0x22c>
    {
        (*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, "dnsc lookup: Host name too long. Retry.\r\n");
    8be4:	682b      	ldr	r3, [r5, #0]
    8be6:	681b      	ldr	r3, [r3, #0]
    8be8:	4940      	ldr	r1, [pc, #256]	; (8cec <_Command_DNS_Service+0x2d0>)
    8bea:	4630      	mov	r0, r6
    8bec:	4798      	blx	r3
    return true;
    8bee:	2401      	movs	r4, #1
    8bf0:	e746      	b.n	8a80 <_Command_DNS_Service+0x64>
        (*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, "dnsc lookup: command in progress. Retry later.\r\n");
    8bf2:	682b      	ldr	r3, [r5, #0]
    8bf4:	681b      	ldr	r3, [r3, #0]
    8bf6:	493e      	ldr	r1, [pc, #248]	; (8cf0 <_Command_DNS_Service+0x2d4>)
    8bf8:	4630      	mov	r0, r6
    8bfa:	4798      	blx	r3
    return true;
    8bfc:	2401      	movs	r4, #1
    8bfe:	e73f      	b.n	8a80 <_Command_DNS_Service+0x64>
    else if((strcmp(argv[2], "AAAA") == 0) || (strcmp(argv[2], "aaaa") == 0))
    8c00:	493c      	ldr	r1, [pc, #240]	; (8cf4 <_Command_DNS_Service+0x2d8>)
    8c02:	4620      	mov	r0, r4
    8c04:	f01a fffa 	bl	23bfc <strcmp>
    8c08:	b120      	cbz	r0, 8c14 <_Command_DNS_Service+0x1f8>
    8c0a:	493b      	ldr	r1, [pc, #236]	; (8cf8 <_Command_DNS_Service+0x2dc>)
    8c0c:	4620      	mov	r0, r4
    8c0e:	f01a fff5 	bl	23bfc <strcmp>
    8c12:	b918      	cbnz	r0, 8c1c <_Command_DNS_Service+0x200>
        dnsType=TCPIP_DNS_TYPE_AAAA;
    8c14:	4b34      	ldr	r3, [pc, #208]	; (8ce8 <_Command_DNS_Service+0x2cc>)
    8c16:	221c      	movs	r2, #28
    8c18:	701a      	strb	r2, [r3, #0]
    8c1a:	e7dc      	b.n	8bd6 <_Command_DNS_Service+0x1ba>
    else if((strcmp(argv[2], "ANY") == 0) || (strcmp(argv[2], "any") == 0))
    8c1c:	4937      	ldr	r1, [pc, #220]	; (8cfc <_Command_DNS_Service+0x2e0>)
    8c1e:	4620      	mov	r0, r4
    8c20:	f01a ffec 	bl	23bfc <strcmp>
    8c24:	b120      	cbz	r0, 8c30 <_Command_DNS_Service+0x214>
    8c26:	4936      	ldr	r1, [pc, #216]	; (8d00 <_Command_DNS_Service+0x2e4>)
    8c28:	4620      	mov	r0, r4
    8c2a:	f01a ffe7 	bl	23bfc <strcmp>
    8c2e:	b918      	cbnz	r0, 8c38 <_Command_DNS_Service+0x21c>
        dnsType=TCPIP_DNS_TYPE_ANY;
    8c30:	4b2d      	ldr	r3, [pc, #180]	; (8ce8 <_Command_DNS_Service+0x2cc>)
    8c32:	22ff      	movs	r2, #255	; 0xff
    8c34:	701a      	strb	r2, [r3, #0]
    8c36:	e7ce      	b.n	8bd6 <_Command_DNS_Service+0x1ba>
        (*pCmdIO->pCmdApi->print)(pCmdIO->cmdIoParam, "dnsc lookup: [%s] Lookup Type not supported.\r\n",argv[2]);
    8c38:	682b      	ldr	r3, [r5, #0]
    8c3a:	685b      	ldr	r3, [r3, #4]
    8c3c:	4622      	mov	r2, r4
    8c3e:	4931      	ldr	r1, [pc, #196]	; (8d04 <_Command_DNS_Service+0x2e8>)
    8c40:	4630      	mov	r0, r6
    8c42:	4798      	blx	r3
    return true;
    8c44:	2401      	movs	r4, #1
    8c46:	e71b      	b.n	8a80 <_Command_DNS_Service+0x64>
        return true;
    }
    strcpy(dnslookupTargetHost, argv[3]);
    8c48:	4e2f      	ldr	r6, [pc, #188]	; (8d08 <_Command_DNS_Service+0x2ec>)
    8c4a:	4621      	mov	r1, r4
    8c4c:	4630      	mov	r0, r6
    8c4e:	f01b f92f 	bl	23eb0 <strcpy>

    dnsLookupCmdIoParam = pCmdIO->cmdIoParam;
    8c52:	686a      	ldr	r2, [r5, #4]
    8c54:	4b2d      	ldr	r3, [pc, #180]	; (8d0c <_Command_DNS_Service+0x2f0>)
    8c56:	601a      	str	r2, [r3, #0]
    (*pCmdIO->pCmdApi->print)(pCmdIO, "dnsc lookup: resolving host: %s for type:%s \r\n", dnslookupTargetHost,argv[2]);
    8c58:	682b      	ldr	r3, [r5, #0]
    8c5a:	685c      	ldr	r4, [r3, #4]
    8c5c:	f8d9 3008 	ldr.w	r3, [r9, #8]
    8c60:	4632      	mov	r2, r6
    8c62:	492b      	ldr	r1, [pc, #172]	; (8d10 <_Command_DNS_Service+0x2f4>)
    8c64:	4628      	mov	r0, r5
    8c66:	47a0      	blx	r4
    tcpipCmdStat = TCPIP_DNS_LOOKUP_CMD_GET;
    8c68:	4b1c      	ldr	r3, [pc, #112]	; (8cdc <_Command_DNS_Service+0x2c0>)
    8c6a:	2208      	movs	r2, #8
    8c6c:	701a      	strb	r2, [r3, #0]
    pTcpipCmdDevice = pCmdIO;
    8c6e:	4b29      	ldr	r3, [pc, #164]	; (8d14 <_Command_DNS_Service+0x2f8>)
    8c70:	601d      	str	r5, [r3, #0]
    _TCPIPStackSignalHandlerSetParams(TCPIP_THIS_MODULE_ID, tcpipCmdSignalHandle, TCPIP_DNS_CLIENT_TASK_PROCESS_RATE);
    8c72:	22c8      	movs	r2, #200	; 0xc8
    8c74:	4b28      	ldr	r3, [pc, #160]	; (8d18 <_Command_DNS_Service+0x2fc>)
    8c76:	6819      	ldr	r1, [r3, #0]
    8c78:	201f      	movs	r0, #31
    8c7a:	f019 fa53 	bl	22124 <_TCPIPStackSignalHandlerSetParams>
    return true;
    8c7e:	2401      	movs	r4, #1
    8c80:	e6fe      	b.n	8a80 <_Command_DNS_Service+0x64>
            if (argc != 3) {
    8c82:	f1b8 0f03 	cmp.w	r8, #3
    8c86:	d049      	beq.n	8d1c <_Command_DNS_Service+0x300>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: dnsc del <hostName>|all \r\n");
    8c88:	4f0b      	ldr	r7, [pc, #44]	; (8cb8 <_Command_DNS_Service+0x29c>)
    8c8a:	682b      	ldr	r3, [r5, #0]
    8c8c:	681b      	ldr	r3, [r3, #0]
    8c8e:	f507 61a2 	add.w	r1, r7, #1296	; 0x510
    8c92:	4630      	mov	r0, r6
    8c94:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: <hostName>(URL) - Remove the entry if exists \r\n");
    8c96:	682b      	ldr	r3, [r5, #0]
    8c98:	681b      	ldr	r3, [r3, #0]
    8c9a:	f207 5134 	addw	r1, r7, #1332	; 0x534
    8c9e:	4630      	mov	r0, r6
    8ca0:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: all - Remove all the resolved entry \r\n");
    8ca2:	682b      	ldr	r3, [r5, #0]
    8ca4:	681b      	ldr	r3, [r3, #0]
    8ca6:	f207 516c 	addw	r1, r7, #1388	; 0x56c
    8caa:	4630      	mov	r0, r6
    8cac:	4798      	blx	r3
                return false;
    8cae:	e6e7      	b.n	8a80 <_Command_DNS_Service+0x64>
    8cb0:	0000050c 	.word	0x0000050c
    8cb4:	000009c4 	.word	0x000009c4
    8cb8:	0000028c 	.word	0x0000028c
    8cbc:	000004b4 	.word	0x000004b4
    8cc0:	000005a8 	.word	0x000005a8
    8cc4:	000005b0 	.word	0x000005b0
    8cc8:	000004a0 	.word	0x000004a0
    8ccc:	000004b8 	.word	0x000004b8
    8cd0:	000005b8 	.word	0x000005b8
    8cd4:	000004bc 	.word	0x000004bc
    8cd8:	000004d8 	.word	0x000004d8
    8cdc:	2000ebc3 	.word	0x2000ebc3
    8ce0:	000006f0 	.word	0x000006f0
    8ce4:	000006f4 	.word	0x000006f4
    8ce8:	2000ed29 	.word	0x2000ed29
    8cec:	00000740 	.word	0x00000740
    8cf0:	000006bc 	.word	0x000006bc
    8cf4:	000006f8 	.word	0x000006f8
    8cf8:	00000700 	.word	0x00000700
    8cfc:	00000708 	.word	0x00000708
    8d00:	0000070c 	.word	0x0000070c
    8d04:	00000710 	.word	0x00000710
    8d08:	2000eb84 	.word	0x2000eb84
    8d0c:	2000ede4 	.word	0x2000ede4
    8d10:	0000076c 	.word	0x0000076c
    8d14:	2000ee14 	.word	0x2000ee14
    8d18:	2000ee18 	.word	0x2000ee18
            hostName = (uint8_t*)argv[2];
    8d1c:	f8d9 7008 	ldr.w	r7, [r9, #8]
            if (hostName == 0)
    8d20:	b14f      	cbz	r7, 8d36 <_Command_DNS_Service+0x31a>
            if(strcmp((char*)hostName,(char*)"all")==0)
    8d22:	497b      	ldr	r1, [pc, #492]	; (8f10 <_Command_DNS_Service+0x4f4>)
    8d24:	4638      	mov	r0, r7
    8d26:	f01a ff69 	bl	23bfc <strcmp>
    8d2a:	4680      	mov	r8, r0
    8d2c:	b948      	cbnz	r0, 8d42 <_Command_DNS_Service+0x326>
                TCPIP_DNS_RemoveAll();
    8d2e:	f015 f89b 	bl	1de68 <TCPIP_DNS_RemoveAll>
                    return false;
    8d32:	4644      	mov	r4, r8
    8d34:	e6a4      	b.n	8a80 <_Command_DNS_Service+0x64>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown option\r\n");
    8d36:	682b      	ldr	r3, [r5, #0]
    8d38:	681b      	ldr	r3, [r3, #0]
    8d3a:	4976      	ldr	r1, [pc, #472]	; (8f14 <_Command_DNS_Service+0x4f8>)
    8d3c:	4630      	mov	r0, r6
    8d3e:	4798      	blx	r3
                return false;
    8d40:	e69e      	b.n	8a80 <_Command_DNS_Service+0x64>
                res = TCPIP_DNS_RemoveEntry((const char*)hostName);
    8d42:	4638      	mov	r0, r7
    8d44:	f016 fe4e 	bl	1f9e4 <TCPIP_DNS_RemoveEntry>
            switch(res)
    8d48:	f110 0f06 	cmn.w	r0, #6
    8d4c:	d00a      	beq.n	8d64 <_Command_DNS_Service+0x348>
    8d4e:	f1b0 3fff 	cmp.w	r0, #4294967295
    8d52:	f47f ae95 	bne.w	8a80 <_Command_DNS_Service+0x64>
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "[%s] not part of the DNS Cache entry \r\n",hostName);
    8d56:	682b      	ldr	r3, [r5, #0]
    8d58:	685b      	ldr	r3, [r3, #4]
    8d5a:	463a      	mov	r2, r7
    8d5c:	496e      	ldr	r1, [pc, #440]	; (8f18 <_Command_DNS_Service+0x4fc>)
    8d5e:	4630      	mov	r0, r6
    8d60:	4798      	blx	r3
                    return false;
    8d62:	e68d      	b.n	8a80 <_Command_DNS_Service+0x64>
                    (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Incomplete command \r\n");
    8d64:	682b      	ldr	r3, [r5, #0]
    8d66:	681b      	ldr	r3, [r3, #0]
    8d68:	496c      	ldr	r1, [pc, #432]	; (8f1c <_Command_DNS_Service+0x500>)
    8d6a:	4630      	mov	r0, r6
    8d6c:	4798      	blx	r3
                    return false;
    8d6e:	e687      	b.n	8a80 <_Command_DNS_Service+0x64>
    bool entryPresent= false;
    IPV6_ADDR   ipv6Addr[TCPIP_DNS_CLIENT_CACHE_PER_IPV6_ADDRESS];
    char        addrPrintBuff[44];
    const char* strictName, *prefName;

    if (argc != 2) {
    8d70:	f1b8 0f02 	cmp.w	r8, #2
    8d74:	d00e      	beq.n	8d94 <_Command_DNS_Service+0x378>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: dnsc info \r\n");
    8d76:	4c6a      	ldr	r4, [pc, #424]	; (8f20 <_Command_DNS_Service+0x504>)
    8d78:	682b      	ldr	r3, [r5, #0]
    8d7a:	681b      	ldr	r3, [r3, #0]
    8d7c:	f504 61bc 	add.w	r1, r4, #1504	; 0x5e0
    8d80:	4630      	mov	r0, r6
    8d82:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: display the DNS cache entry details \r\n");
    8d84:	682b      	ldr	r3, [r5, #0]
    8d86:	681b      	ldr	r3, [r3, #0]
    8d88:	f204 51f4 	addw	r1, r4, #1524	; 0x5f4
    8d8c:	4630      	mov	r0, r6
    8d8e:	4798      	blx	r3
    return true;
    8d90:	2401      	movs	r4, #1
    8d92:	e675      	b.n	8a80 <_Command_DNS_Service+0x64>
        return false;
    }


    dnsQuery.hostName = hostName;
    8d94:	ab27      	add	r3, sp, #156	; 0x9c
    8d96:	931b      	str	r3, [sp, #108]	; 0x6c
    dnsQuery.nameLen = sizeof(hostName);
    8d98:	2341      	movs	r3, #65	; 0x41
    8d9a:	931c      	str	r3, [sp, #112]	; 0x70
    dnsQuery.ipv4Entry = ipv4Addr;
    8d9c:	ab0b      	add	r3, sp, #44	; 0x2c
    8d9e:	931d      	str	r3, [sp, #116]	; 0x74
    dnsQuery.nIPv4Entries = sizeof(ipv4Addr) / sizeof(*ipv4Addr);
    8da0:	2305      	movs	r3, #5
    8da2:	931e      	str	r3, [sp, #120]	; 0x78

    dnsQuery.ipv6Entry = ipv6Addr;
    8da4:	ab02      	add	r3, sp, #8
    8da6:	931f      	str	r3, [sp, #124]	; 0x7c
    dnsQuery.nIPv6Entries = sizeof(ipv6Addr) / sizeof(*ipv6Addr);
    8da8:	2301      	movs	r3, #1
    8daa:	9320      	str	r3, [sp, #128]	; 0x80

    res = TCPIP_DNS_ClientInfoGet(&clientInfo);
    8dac:	a806      	add	r0, sp, #24
    8dae:	f017 fcb9 	bl	20724 <TCPIP_DNS_ClientInfoGet>
    if(res != TCPIP_DNS_RES_OK)
    8db2:	b128      	cbz	r0, 8dc0 <_Command_DNS_Service+0x3a4>
    {
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "DNS Client is down!\r\n");
    8db4:	682b      	ldr	r3, [r5, #0]
    8db6:	681b      	ldr	r3, [r3, #0]
    8db8:	495a      	ldr	r1, [pc, #360]	; (8f24 <_Command_DNS_Service+0x508>)
    8dba:	4630      	mov	r0, r6
    8dbc:	4798      	blx	r3
        return false;
    8dbe:	e7e7      	b.n	8d90 <_Command_DNS_Service+0x374>
    }

    strictName = TCPIP_STACK_NetNameGet(clientInfo.strictNet);
    8dc0:	9806      	ldr	r0, [sp, #24]
    8dc2:	f01b fac2 	bl	2434a <TCPIP_STACK_NetNameGet>
    if(strictName == 0)
    {
        strictName = "none";
    8dc6:	2800      	cmp	r0, #0
    8dc8:	4f57      	ldr	r7, [pc, #348]	; (8f28 <_Command_DNS_Service+0x50c>)
    8dca:	bf18      	it	ne
    8dcc:	4607      	movne	r7, r0
    }
    prefName = TCPIP_STACK_NetNameGet(clientInfo.prefNet);
    8dce:	9807      	ldr	r0, [sp, #28]
    8dd0:	f01b fabb 	bl	2434a <TCPIP_STACK_NetNameGet>
    if(prefName == 0)
    {
        prefName = "none";
    8dd4:	2800      	cmp	r0, #0
    8dd6:	4b54      	ldr	r3, [pc, #336]	; (8f28 <_Command_DNS_Service+0x50c>)
    8dd8:	bf18      	it	ne
    8dda:	4603      	movne	r3, r0
    }

    (*pCmdIO->pCmdApi->print)(cmdIoParam, "DNS Client IF - Strict: %s, Preferred: %s\r\n", strictName, prefName);
    8ddc:	f8df 8140 	ldr.w	r8, [pc, #320]	; 8f20 <_Command_DNS_Service+0x504>
    8de0:	682a      	ldr	r2, [r5, #0]
    8de2:	f8d2 9004 	ldr.w	r9, [r2, #4]
    8de6:	463a      	mov	r2, r7
    8de8:	f208 613c 	addw	r1, r8, #1596	; 0x63c
    8dec:	4630      	mov	r0, r6
    8dee:	47c8      	blx	r9
    (*pCmdIO->pCmdApi->print)(cmdIoParam, "DNS Client - time: %d, pending: %d, current: %d, total: %d\r\n", clientInfo.dnsTime, clientInfo.pendingEntries, clientInfo.currentEntries, clientInfo.totalEntries);
    8df0:	682b      	ldr	r3, [r5, #0]
    8df2:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
    8df6:	9201      	str	r2, [sp, #4]
    8df8:	f8bd 2026 	ldrh.w	r2, [sp, #38]	; 0x26
    8dfc:	9200      	str	r2, [sp, #0]
    8dfe:	685f      	ldr	r7, [r3, #4]
    8e00:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    8e04:	9a08      	ldr	r2, [sp, #32]
    8e06:	f508 61cd 	add.w	r1, r8, #1640	; 0x668
    8e0a:	4630      	mov	r0, r6
    8e0c:	47b8      	blx	r7

    index = 0;
    8e0e:	46a0      	mov	r8, r4
    bool entryPresent= false;
    8e10:	2700      	movs	r7, #0
    {
        res = TCPIP_DNS_EntryQuery(&dnsQuery, index);
        if(res == TCPIP_DNS_RES_OK)
        {
            entryPresent = true;
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Hostname = %s \r\nTimeout = %d \r\n", hostName, dnsQuery.ttlTime);
    8e12:	f8df 910c 	ldr.w	r9, [pc, #268]	; 8f20 <_Command_DNS_Service+0x504>
    8e16:	f509 6bd5 	add.w	fp, r9, #1704	; 0x6a8
        res = TCPIP_DNS_EntryQuery(&dnsQuery, index);
    8e1a:	4641      	mov	r1, r8
    8e1c:	a81b      	add	r0, sp, #108	; 0x6c
    8e1e:	f009 ffb9 	bl	12d94 <TCPIP_DNS_EntryQuery>
        if(res == TCPIP_DNS_RES_OK)
    8e22:	2800      	cmp	r0, #0
    8e24:	d144      	bne.n	8eb0 <_Command_DNS_Service+0x494>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Hostname = %s \r\nTimeout = %d \r\n", hostName, dnsQuery.ttlTime);
    8e26:	682b      	ldr	r3, [r5, #0]
    8e28:	685f      	ldr	r7, [r3, #4]
    8e2a:	9b22      	ldr	r3, [sp, #136]	; 0x88
    8e2c:	aa27      	add	r2, sp, #156	; 0x9c
    8e2e:	4659      	mov	r1, fp
    8e30:	4630      	mov	r0, r6
    8e32:	47b8      	blx	r7
            if(dnsQuery.nIPv4ValidEntries > 0)
    8e34:	9b25      	ldr	r3, [sp, #148]	; 0x94
    8e36:	2b00      	cmp	r3, #0
    8e38:	dc0d      	bgt.n	8e56 <_Command_DNS_Service+0x43a>
                {                    
                    TCPIP_Helper_IPAddressToString(dnsQuery.ipv4Entry + ix, addrPrintBuff, sizeof(addrPrintBuff)); 
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv4 =%s\r\n", addrPrintBuff);
                }
            }
            if(dnsQuery.nIPv6Entries > 0)
    8e3a:	9b20      	ldr	r3, [sp, #128]	; 0x80
    8e3c:	2b00      	cmp	r3, #0
    8e3e:	dc1f      	bgt.n	8e80 <_Command_DNS_Service+0x464>
                {
                    TCPIP_Helper_IPv6AddressToString(dnsQuery.ipv6Entry + ix, addrPrintBuff, sizeof(addrPrintBuff));                   
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv6 = %s\r\n",addrPrintBuff);
                }
            }
            (*pCmdIO->pCmdApi->print)(cmdIoParam,"----------------------------------------------------\r\n",0);
    8e40:	682b      	ldr	r3, [r5, #0]
    8e42:	685b      	ldr	r3, [r3, #4]
    8e44:	2200      	movs	r2, #0
    8e46:	f509 61dc 	add.w	r1, r9, #1760	; 0x6e0
    8e4a:	4630      	mov	r0, r6
    8e4c:	4798      	blx	r3
            entryPresent = true;
    8e4e:	2701      	movs	r7, #1
        }
        if(res == TCPIP_DNS_RES_OK || res == TCPIP_DNS_RES_PENDING || res == TCPIP_DNS_RES_EMPTY_IX_ENTRY)
        {
            index++;
    8e50:	f108 0801 	add.w	r8, r8, #1
            continue;
    8e54:	e7e1      	b.n	8e1a <_Command_DNS_Service+0x3fe>
                for(ix = 0; ix < dnsQuery.nIPv4ValidEntries; ix++)
    8e56:	4627      	mov	r7, r4
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv4 =%s\r\n", addrPrintBuff);
    8e58:	f509 6ad9 	add.w	sl, r9, #1736	; 0x6c8
                    TCPIP_Helper_IPAddressToString(dnsQuery.ipv4Entry + ix, addrPrintBuff, sizeof(addrPrintBuff)); 
    8e5c:	222c      	movs	r2, #44	; 0x2c
    8e5e:	a910      	add	r1, sp, #64	; 0x40
    8e60:	981d      	ldr	r0, [sp, #116]	; 0x74
    8e62:	eb00 0087 	add.w	r0, r0, r7, lsl #2
    8e66:	f015 fd05 	bl	1e874 <TCPIP_Helper_IPAddressToString>
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv4 =%s\r\n", addrPrintBuff);
    8e6a:	682b      	ldr	r3, [r5, #0]
    8e6c:	685b      	ldr	r3, [r3, #4]
    8e6e:	aa10      	add	r2, sp, #64	; 0x40
    8e70:	4651      	mov	r1, sl
    8e72:	4630      	mov	r0, r6
    8e74:	4798      	blx	r3
                for(ix = 0; ix < dnsQuery.nIPv4ValidEntries; ix++)
    8e76:	3701      	adds	r7, #1
    8e78:	9b25      	ldr	r3, [sp, #148]	; 0x94
    8e7a:	429f      	cmp	r7, r3
    8e7c:	dbee      	blt.n	8e5c <_Command_DNS_Service+0x440>
    8e7e:	e7dc      	b.n	8e3a <_Command_DNS_Service+0x41e>
                for(ix = 0; ix < dnsQuery.nIPv6ValidEntries; ix++)
    8e80:	9b26      	ldr	r3, [sp, #152]	; 0x98
    8e82:	2b00      	cmp	r3, #0
    8e84:	dddc      	ble.n	8e40 <_Command_DNS_Service+0x424>
    8e86:	4627      	mov	r7, r4
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv6 = %s\r\n",addrPrintBuff);
    8e88:	f209 6ad4 	addw	sl, r9, #1748	; 0x6d4
                    TCPIP_Helper_IPv6AddressToString(dnsQuery.ipv6Entry + ix, addrPrintBuff, sizeof(addrPrintBuff));                   
    8e8c:	222c      	movs	r2, #44	; 0x2c
    8e8e:	a910      	add	r1, sp, #64	; 0x40
    8e90:	981f      	ldr	r0, [sp, #124]	; 0x7c
    8e92:	eb00 1007 	add.w	r0, r0, r7, lsl #4
    8e96:	f010 fa0e 	bl	192b6 <TCPIP_Helper_IPv6AddressToString>
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv6 = %s\r\n",addrPrintBuff);
    8e9a:	682b      	ldr	r3, [r5, #0]
    8e9c:	685b      	ldr	r3, [r3, #4]
    8e9e:	aa10      	add	r2, sp, #64	; 0x40
    8ea0:	4651      	mov	r1, sl
    8ea2:	4630      	mov	r0, r6
    8ea4:	4798      	blx	r3
                for(ix = 0; ix < dnsQuery.nIPv6ValidEntries; ix++)
    8ea6:	3701      	adds	r7, #1
    8ea8:	9b26      	ldr	r3, [sp, #152]	; 0x98
    8eaa:	429f      	cmp	r7, r3
    8eac:	dbee      	blt.n	8e8c <_Command_DNS_Service+0x470>
    8eae:	e7c7      	b.n	8e40 <_Command_DNS_Service+0x424>
        if(res == TCPIP_DNS_RES_OK || res == TCPIP_DNS_RES_PENDING || res == TCPIP_DNS_RES_EMPTY_IX_ENTRY)
    8eb0:	b2c2      	uxtb	r2, r0
    8eb2:	2a01      	cmp	r2, #1
    8eb4:	d9cc      	bls.n	8e50 <_Command_DNS_Service+0x434>
    8eb6:	f110 0f04 	cmn.w	r0, #4
    8eba:	d0c9      	beq.n	8e50 <_Command_DNS_Service+0x434>
        }

        // some error
        if(entryPresent == false)
    8ebc:	2f00      	cmp	r7, #0
    8ebe:	f47f af67 	bne.w	8d90 <_Command_DNS_Service+0x374>
        {
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "No DNS Client Cache entries \r\n");
    8ec2:	682b      	ldr	r3, [r5, #0]
    8ec4:	681b      	ldr	r3, [r3, #0]
    8ec6:	4919      	ldr	r1, [pc, #100]	; (8f2c <_Command_DNS_Service+0x510>)
    8ec8:	4630      	mov	r0, r6
    8eca:	4798      	blx	r3
    8ecc:	e760      	b.n	8d90 <_Command_DNS_Service+0x374>
    TCPIP_DNS_ENABLE_FLAGS enableFlags = TCPIP_DNS_ENABLE_DEFAULT;
    8ece:	2100      	movs	r1, #0
        addRes = TCPIP_DNS_Enable(netH, enableFlags);
    8ed0:	4638      	mov	r0, r7
    8ed2:	f01b f9a5 	bl	24220 <TCPIP_DNS_Enable>
        msgFail = "enable";
    8ed6:	4b12      	ldr	r3, [pc, #72]	; (8f20 <_Command_DNS_Service+0x504>)
    8ed8:	f503 72de 	add.w	r2, r3, #444	; 0x1bc
        msgOK   = "enabled";
    8edc:	f503 73da 	add.w	r3, r3, #436	; 0x1b4
    if(addRes)
    8ee0:	2800      	cmp	r0, #0
    8ee2:	f43f ae3a 	beq.w	8b5a <_Command_DNS_Service+0x13e>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "%s %s\r\n", argv[0], msgOK);
    8ee6:	682a      	ldr	r2, [r5, #0]
    8ee8:	6854      	ldr	r4, [r2, #4]
    8eea:	f8d9 2000 	ldr.w	r2, [r9]
    8eee:	4910      	ldr	r1, [pc, #64]	; (8f30 <_Command_DNS_Service+0x514>)
    8ef0:	4630      	mov	r0, r6
    8ef2:	47a0      	blx	r4
    return true;
    8ef4:	2401      	movs	r4, #1
    8ef6:	e5c3      	b.n	8a80 <_Command_DNS_Service+0x64>
                enableFlags = TCPIP_DNS_ENABLE_STRICT;
    8ef8:	2101      	movs	r1, #1
    8efa:	e7e9      	b.n	8ed0 <_Command_DNS_Service+0x4b4>
    bool             clearCache = false;
    8efc:	2100      	movs	r1, #0
        addRes = TCPIP_DNS_Disable(netH, clearCache);
    8efe:	4638      	mov	r0, r7
    8f00:	f013 fb60 	bl	1c5c4 <TCPIP_DNS_Disable>
        msgFail = "disable";
    8f04:	4b06      	ldr	r3, [pc, #24]	; (8f20 <_Command_DNS_Service+0x504>)
    8f06:	f503 72e8 	add.w	r2, r3, #464	; 0x1d0
        msgOK   = "disabled";
    8f0a:	f503 73e2 	add.w	r3, r3, #452	; 0x1c4
    8f0e:	e7e7      	b.n	8ee0 <_Command_DNS_Service+0x4c4>
    8f10:	00000828 	.word	0x00000828
    8f14:	000004bc 	.word	0x000004bc
    8f18:	0000082c 	.word	0x0000082c
    8f1c:	00000854 	.word	0x00000854
    8f20:	0000028c 	.word	0x0000028c
    8f24:	000008b0 	.word	0x000008b0
    8f28:	00000504 	.word	0x00000504
    8f2c:	000009a4 	.word	0x000009a4
    8f30:	000004d0 	.word	0x000004d0

Disassembly of section .text.TCPIP_DHCP_Task%225:

00008f34 <TCPIP_DHCP_Task>:
    return false;
}


void TCPIP_DHCP_Task(void)
{
    8f34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8f38:	b087      	sub	sp, #28
    TCPIP_MODULE_SIGNAL sigPend;
    bool                isTmo = false;

    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    8f3a:	210f      	movs	r1, #15
    8f3c:	200c      	movs	r0, #12
    8f3e:	f017 f8f9 	bl	20134 <_TCPIPStackModuleSignalGet>

    if((sigPend & TCPIP_MODULE_SIGNAL_TMO) != 0)
    8f42:	f010 0f02 	tst.w	r0, #2
    8f46:	f040 822c 	bne.w	93a2 <TCPIP_DHCP_Task+0x46e>
    { // regular TMO occurred
        isTmo = true;
    }

    if(isTmo || (sigPend & TCPIP_MODULE_SIGNAL_RX_PENDING) != 0)
    8f4a:	f010 0f01 	tst.w	r0, #1
    8f4e:	f000 8225 	beq.w	939c <TCPIP_DHCP_Task+0x468>
    if(isTmo)
    {   // update DHCP time keeping
        _DHCPSecondCountSet();
    }

    nNets = TCPIP_STACK_NumberOfNetworksGet();
    8f52:	f01b f971 	bl	24238 <TCPIP_STACK_NumberOfNetworksGet>
    for(netIx = 0; netIx < nNets; netIx++) 
    8f56:	f1b0 0900 	subs.w	r9, r0, #0
    8f5a:	f340 821a 	ble.w	9392 <TCPIP_DHCP_Task+0x45e>
    8f5e:	2500      	movs	r5, #0
        if(!TCPIP_STACK_NetworkIsUp(pNetIf))
        {   // inactive interface
            continue;
        }

        pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf); 
    8f60:	f8df a3e8 	ldr.w	sl, [pc, #1000]	; 934c <TCPIP_DHCP_Task+0x418>
    8f64:	f04f 0b5c 	mov.w	fp, #92	; 0x5c
    8f68:	e13d      	b.n	91e6 <TCPIP_DHCP_Task+0x2b2>
    {   // don't have a current lease
        if(pClient->flags.bReportFail && pClient->tOpStart != 0)
        {
            if((_DHCPSecondCountGet() - pClient->tOpStart) >= pClient->tOpFailTmo)
            {   // initialization time out
                TCPIP_STACK_AddressServiceEvent(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_DHCPC, TCPIP_STACK_ADDRESS_SERVICE_EVENT_RUN_FAIL);
    8f6a:	2201      	movs	r2, #1
    8f6c:	4611      	mov	r1, r2
    8f6e:	4630      	mov	r0, r6
    8f70:	f016 fa62 	bl	1f438 <TCPIP_STACK_AddressServiceEvent>
                _DHCPDbgAddServiceEvent(pClient, TCPIP_STACK_ADDRESS_SERVICE_EVENT_RUN_FAIL, "init tmo");
                pClient->flags.bReportFail = 0;   // reported
    8f74:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
    8f78:	f36f 1345 	bfc	r3, #5, #1
    8f7c:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    8f80:	e15d      	b.n	923e <TCPIP_DHCP_Task+0x30a>
                if(!TCPIP_STACK_NetworkIsLinked(pNetIf))
    8f82:	4630      	mov	r0, r6
    8f84:	f019 ff98 	bl	22eb8 <TCPIP_STACK_NetworkIsLinked>
    8f88:	2800      	cmp	r0, #0
    8f8a:	f000 8128 	beq.w	91de <TCPIP_DHCP_Task+0x2aa>
                if(pClient->dhcpOp == TCPIP_DHCP_OPER_INIT_REBOOT)
    8f8e:	f8b4 3054 	ldrh.w	r3, [r4, #84]	; 0x54
    8f92:	2b02      	cmp	r3, #2
    8f94:	d00d      	beq.n	8fb2 <TCPIP_DHCP_Task+0x7e>
                else if(pClient->dhcpOp == TCPIP_DHCP_OPER_RENEW)
    8f96:	2b03      	cmp	r3, #3
    pClient->smState = newState;
    8f98:	bf0c      	ite	eq
    8f9a:	2309      	moveq	r3, #9
    8f9c:	2302      	movne	r3, #2
    8f9e:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    if(pClient->dhcpFilterHandle != 0)
    8fa2:	6ca0      	ldr	r0, [r4, #72]	; 0x48
    8fa4:	2800      	cmp	r0, #0
    8fa6:	f000 811a 	beq.w	91de <TCPIP_DHCP_Task+0x2aa>
        Ipv4FilterSetActive(pClient->dhcpFilterHandle, active);
    8faa:	2101      	movs	r1, #1
    8fac:	f014 f878 	bl	1d0a0 <Ipv4FilterSetActive>
    8fb0:	e115      	b.n	91de <TCPIP_DHCP_Task+0x2aa>
    pClient->smState = newState;
    8fb2:	2304      	movs	r3, #4
    8fb4:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    8fb8:	e7f3      	b.n	8fa2 <TCPIP_DHCP_Task+0x6e>
                _DHCPSetLeaseTimeParams(pClient, 0);
    8fba:	2100      	movs	r1, #0
    8fbc:	4620      	mov	r0, r4
    8fbe:	f011 fc0d 	bl	1a7dc <_DHCPSetLeaseTimeParams>
                pClient->validValues.val = 0x00;
    8fc2:	2200      	movs	r2, #0
    8fc4:	f884 2059 	strb.w	r2, [r4, #89]	; 0x59
                pClient->flags.bIsBound = false;	
    8fc8:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
                pClient->flags.bOfferReceived = false;
    8fcc:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    8fd0:	f362 0382 	bfi	r3, r2, #2, #1
    8fd4:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
                pClient->serverAddress.Val = 0;
    8fd8:	62a2      	str	r2, [r4, #40]	; 0x28
                if(!_DHCPSend(pClient, pNetIf, TCPIP_DHCP_DISCOVER_MESSAGE, TCPIP_DHCP_FLAG_SEND_ZERO_ADD | TCPIP_DHCP_FLAG_SEND_BCAST))
    8fda:	2303      	movs	r3, #3
    8fdc:	2201      	movs	r2, #1
    8fde:	4631      	mov	r1, r6
    8fe0:	4620      	mov	r0, r4
    8fe2:	f008 f939 	bl	11258 <_DHCPSend>
    8fe6:	2800      	cmp	r0, #0
    8fe8:	f000 80f9 	beq.w	91de <TCPIP_DHCP_Task+0x2aa>
                _DHCPNotifyClients(pNetIf, DHCP_EVENT_DISCOVER);
    8fec:	2101      	movs	r1, #1
    8fee:	4630      	mov	r0, r6
    8ff0:	f017 f828 	bl	20044 <_DHCPNotifyClients>
                _DHCPSetTimeout(pClient);
    8ff4:	4620      	mov	r0, r4
    8ff6:	f018 fbc1 	bl	2177c <_DHCPSetTimeout>
    pClient->smState = newState;
    8ffa:	2303      	movs	r3, #3
    8ffc:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    9000:	e0ed      	b.n	91de <TCPIP_DHCP_Task+0x2aa>
                recvMsg = _DHCPProcessReceiveData(pClient, pNetIf);
    9002:	4631      	mov	r1, r6
    9004:	4620      	mov	r0, r4
    9006:	f010 f8b3 	bl	19170 <_DHCPProcessReceiveData>
                if(recvMsg == TCPIP_DHCP_TIMEOUT_MESSAGE)
    900a:	280a      	cmp	r0, #10
    900c:	d02a      	beq.n	9064 <TCPIP_DHCP_Task+0x130>
                else if(recvMsg != TCPIP_DHCP_UNKNOWN_MESSAGE)
    900e:	2800      	cmp	r0, #0
    9010:	f000 80e5 	beq.w	91de <TCPIP_DHCP_Task+0x2aa>
                    pClient->flags.bDHCPServerDetected = true;
    9014:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
    9018:	f043 0308 	orr.w	r3, r3, #8
    901c:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
                if(recvMsg != TCPIP_DHCP_OFFER_MESSAGE)
    9020:	2802      	cmp	r0, #2
    9022:	f040 80dc 	bne.w	91de <TCPIP_DHCP_Task+0x2aa>
    pClient->smState = newState;
    9026:	2304      	movs	r3, #4
    9028:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
                if(!_DHCPSend(pClient, pNetIf, TCPIP_DHCP_REQUEST_MESSAGE, (pClient->dhcpOp == TCPIP_DHCP_OPER_INIT_REBOOT) ? TCPIP_DHCP_FLAG_SEND_BCAST : TCPIP_DHCP_FLAG_SEND_ZERO_ADD | TCPIP_DHCP_FLAG_SEND_BCAST))
    902c:	f8b4 3054 	ldrh.w	r3, [r4, #84]	; 0x54
    9030:	2b02      	cmp	r3, #2
    9032:	9b01      	ldr	r3, [sp, #4]
    9034:	bf18      	it	ne
    9036:	2303      	movne	r3, #3
    9038:	2203      	movs	r2, #3
    903a:	4631      	mov	r1, r6
    903c:	4620      	mov	r0, r4
    903e:	f008 f90b 	bl	11258 <_DHCPSend>
    9042:	2800      	cmp	r0, #0
    9044:	f000 80cb 	beq.w	91de <TCPIP_DHCP_Task+0x2aa>
                pClient->tRequest = _DHCPSecondCountGet();
    9048:	4bbf      	ldr	r3, [pc, #764]	; (9348 <TCPIP_DHCP_Task+0x414>)
    904a:	681b      	ldr	r3, [r3, #0]
    904c:	60a3      	str	r3, [r4, #8]
                _DHCPNotifyClients(pNetIf, DHCP_EVENT_REQUEST);
    904e:	2102      	movs	r1, #2
    9050:	4630      	mov	r0, r6
    9052:	f016 fff7 	bl	20044 <_DHCPNotifyClients>
                _DHCPSetTimeout(pClient);
    9056:	4620      	mov	r0, r4
    9058:	f018 fb90 	bl	2177c <_DHCPSetTimeout>
    pClient->smState = newState;
    905c:	2305      	movs	r3, #5
    905e:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    9062:	e0bc      	b.n	91de <TCPIP_DHCP_Task+0x2aa>
                    if((SYS_TMR_TickCountGet() - pClient->startWait) >= pClient->waitTicks)
    9064:	f019 f8ea 	bl	2223c <SYS_TMR_TickCountGet>
    9068:	6863      	ldr	r3, [r4, #4]
    906a:	1ac3      	subs	r3, r0, r3
    906c:	f858 2007 	ldr.w	r2, [r8, r7]
    9070:	4293      	cmp	r3, r2
    9072:	f0c0 80b4 	bcc.w	91de <TCPIP_DHCP_Task+0x2aa>
                        _DHCPSetRunFail(pClient, TCPIP_DHCP_SEND_DISCOVERY, true);  
    9076:	2201      	movs	r2, #1
    9078:	2102      	movs	r1, #2
    907a:	4620      	mov	r0, r4
    907c:	f015 fbd4 	bl	1e828 <_DHCPSetRunFail>
                        _DHCPNotifyClients(pNetIf, DHCP_EVENT_TIMEOUT);
    9080:	2107      	movs	r1, #7
    9082:	4630      	mov	r0, r6
    9084:	f016 ffde 	bl	20044 <_DHCPNotifyClients>
    9088:	e0a9      	b.n	91de <TCPIP_DHCP_Task+0x2aa>
                if(_DHCPProcessReceiveData(pClient, pNetIf) == TCPIP_DHCP_TIMEOUT_MESSAGE)
    908a:	4631      	mov	r1, r6
    908c:	4620      	mov	r0, r4
    908e:	f010 f86f 	bl	19170 <_DHCPProcessReceiveData>
    9092:	280a      	cmp	r0, #10
    9094:	f040 80a3 	bne.w	91de <TCPIP_DHCP_Task+0x2aa>
                    if((SYS_TMR_TickCountGet() - pClient->startWait) >= pClient->waitTicks)
    9098:	f019 f8d0 	bl	2223c <SYS_TMR_TickCountGet>
    909c:	6863      	ldr	r3, [r4, #4]
    909e:	1ac3      	subs	r3, r0, r3
    90a0:	f858 2007 	ldr.w	r2, [r8, r7]
    90a4:	4293      	cmp	r3, r2
    90a6:	f0c0 809a 	bcc.w	91de <TCPIP_DHCP_Task+0x2aa>
                        _DHCPSetRunFail(pClient, TCPIP_DHCP_SEND_DISCOVERY, true);
    90aa:	2201      	movs	r2, #1
    90ac:	2102      	movs	r1, #2
    90ae:	4620      	mov	r0, r4
    90b0:	f015 fbba 	bl	1e828 <_DHCPSetRunFail>
                        _DHCPNotifyClients(pNetIf, DHCP_EVENT_TIMEOUT);
    90b4:	2107      	movs	r1, #7
    90b6:	4630      	mov	r0, r6
    90b8:	f016 ffc4 	bl	20044 <_DHCPNotifyClients>
    90bc:	e08f      	b.n	91de <TCPIP_DHCP_Task+0x2aa>
                    arpCheck.Val = pClient->dhcpIPAddress.Val;
    90be:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    90c0:	9302      	str	r3, [sp, #8]
                    if(TCPIP_ARP_IsResolved(pNetIf, &arpCheck, 0))
    90c2:	2200      	movs	r2, #0
    90c4:	a902      	add	r1, sp, #8
    90c6:	4630      	mov	r0, r6
    90c8:	f010 ff5c 	bl	19f84 <TCPIP_ARP_IsResolved>
    90cc:	2800      	cmp	r0, #0
    90ce:	f040 8177 	bne.w	93c0 <TCPIP_DHCP_Task+0x48c>
                    else if((_DHCPSecondCountGet() - pClient->startWait) >= pClient->tLeaseCheck)
    90d2:	4b9d      	ldr	r3, [pc, #628]	; (9348 <TCPIP_DHCP_Task+0x414>)
    90d4:	681b      	ldr	r3, [r3, #0]
    90d6:	6862      	ldr	r2, [r4, #4]
    90d8:	1a9b      	subs	r3, r3, r2
    90da:	f8b4 2052 	ldrh.w	r2, [r4, #82]	; 0x52
    90de:	4293      	cmp	r3, r2
    90e0:	d37d      	bcc.n	91de <TCPIP_DHCP_Task+0x2aa>
    oldNetIp.Val = TCPIP_STACK_NetAddressGet(pNetIf);
    90e2:	4630      	mov	r0, r6
    90e4:	f01a fb16 	bl	23714 <TCPIP_STACK_NetAddressGet>
    90e8:	9003      	str	r0, [sp, #12]
    oldNetMask.Val = TCPIP_STACK_NetMaskGet(pNetIf);
    90ea:	4630      	mov	r0, r6
    90ec:	f01a fb1e 	bl	2372c <TCPIP_STACK_NetMaskGet>
    90f0:	9004      	str	r0, [sp, #16]
    _TCPIPStackSetConfigAddress(pNetIf, &pClient->dhcpIPAddress, &pClient->dhcpMask, false);
    90f2:	f104 072c 	add.w	r7, r4, #44	; 0x2c
    90f6:	2300      	movs	r3, #0
    90f8:	f104 0234 	add.w	r2, r4, #52	; 0x34
    90fc:	4639      	mov	r1, r7
    90fe:	4630      	mov	r0, r6
    9100:	f017 fc41 	bl	20986 <_TCPIPStackSetConfigAddress>
    if(pClient->validValues.Gateway)
    9104:	f894 3059 	ldrb.w	r3, [r4, #89]	; 0x59
    9108:	f013 0f02 	tst.w	r3, #2
    910c:	d136      	bne.n	917c <TCPIP_DHCP_Task+0x248>
    if(pNetIf->Flags.bIsDNSServerAuto != 0)
    910e:	f896 3042 	ldrb.w	r3, [r6, #66]	; 0x42
    9112:	f013 0f20 	tst.w	r3, #32
    9116:	d011      	beq.n	913c <TCPIP_DHCP_Task+0x208>
        if(pClient->validValues.DNS)
    9118:	f894 3059 	ldrb.w	r3, [r4, #89]	; 0x59
    911c:	f013 0f08 	tst.w	r3, #8
    9120:	d132      	bne.n	9188 <TCPIP_DHCP_Task+0x254>
        if(pClient->validValues.DNS2)
    9122:	f894 3059 	ldrb.w	r3, [r4, #89]	; 0x59
    9126:	f013 0f10 	tst.w	r3, #16
            TCPIP_STACK_SecondaryDNSAddressSet(pNetIf, &pClient->dhcpDNS2);
    912a:	bf11      	iteee	ne
    912c:	f104 013c 	addne.w	r1, r4, #60	; 0x3c
            IPV4_ADDR zeroAdd = {0};
    9130:	2300      	moveq	r3, #0
    9132:	9305      	streq	r3, [sp, #20]
            TCPIP_STACK_SecondaryDNSAddressSet(pNetIf, &zeroAdd);
    9134:	a905      	addeq	r1, sp, #20
    9136:	4630      	mov	r0, r6
    9138:	f01b f93e 	bl	243b8 <TCPIP_STACK_SecondaryDNSAddressSet>
    TCPIP_STACK_AddressServiceEvent(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_DHCPC, TCPIP_STACK_ADDRESS_SERVICE_EVENT_RUN_RESTORE); 
    913c:	2204      	movs	r2, #4
    913e:	2101      	movs	r1, #1
    9140:	4630      	mov	r0, r6
    9142:	f016 f979 	bl	1f438 <TCPIP_STACK_AddressServiceEvent>
    TCPIP_ARP_Probe(pNetIf, &pClient->dhcpIPAddress, &pClient->dhcpIPAddress, ARP_OPERATION_RESP | ARP_OPERATION_CONFIGURE | ARP_OPERATION_PROBE_ONLY);
    9146:	f245 0302 	movw	r3, #20482	; 0x5002
    914a:	463a      	mov	r2, r7
    914c:	4639      	mov	r1, r7
    914e:	4630      	mov	r0, r6
    9150:	f014 fa10 	bl	1d574 <TCPIP_ARP_Probe>
    if((pClient->dhcpIPAddress.Val & pClient->dhcpMask.Val) != (oldNetIp.Val & oldNetMask.Val))
    9154:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    9156:	6b62      	ldr	r2, [r4, #52]	; 0x34
    9158:	401a      	ands	r2, r3
    915a:	9b03      	ldr	r3, [sp, #12]
    915c:	9904      	ldr	r1, [sp, #16]
    915e:	400b      	ands	r3, r1
    9160:	429a      	cmp	r2, r3
    9162:	d117      	bne.n	9194 <TCPIP_DHCP_Task+0x260>
    _DHCPSetBoundState(pClient);
    9164:	4620      	mov	r0, r4
    9166:	f016 fbfd 	bl	1f964 <_DHCPSetBoundState>
    _DHCPNotifyClients(pNetIf, DHCP_EVENT_BOUND);
    916a:	2108      	movs	r1, #8
    916c:	4630      	mov	r0, r6
    916e:	f016 ff69 	bl	20044 <_DHCPNotifyClients>
                        TCPIP_ARP_EntryRemove(pNetIf,  &arpCheck);
    9172:	a902      	add	r1, sp, #8
    9174:	4630      	mov	r0, r6
    9176:	f012 fdc1 	bl	1bcfc <TCPIP_ARP_EntryRemove>
                break;
    917a:	e030      	b.n	91de <TCPIP_DHCP_Task+0x2aa>
        TCPIP_STACK_GatewayAddressSet(pNetIf, &pClient->dhcpGateway);
    917c:	f104 0130 	add.w	r1, r4, #48	; 0x30
    9180:	4630      	mov	r0, r6
    9182:	f01b f911 	bl	243a8 <TCPIP_STACK_GatewayAddressSet>
    9186:	e7c2      	b.n	910e <TCPIP_DHCP_Task+0x1da>
            TCPIP_STACK_PrimaryDNSAddressSet(pNetIf, &pClient->dhcpDNS);
    9188:	f104 0138 	add.w	r1, r4, #56	; 0x38
    918c:	4630      	mov	r0, r6
    918e:	f01b f90f 	bl	243b0 <TCPIP_STACK_PrimaryDNSAddressSet>
    9192:	e7c6      	b.n	9122 <TCPIP_DHCP_Task+0x1ee>
        TCPIP_ARP_EntryRemoveNet(pNetIf, &oldNetIp, &oldNetMask, ARP_ENTRY_TYPE_ANY);
    9194:	2304      	movs	r3, #4
    9196:	aa04      	add	r2, sp, #16
    9198:	a903      	add	r1, sp, #12
    919a:	4630      	mov	r0, r6
    919c:	f00c fecc 	bl	15f38 <TCPIP_ARP_EntryRemoveNet>
    91a0:	e7e0      	b.n	9164 <TCPIP_DHCP_Task+0x230>
                if((_DHCPSecondCountGet() - pClient->startWait) >= TCPIP_DHCP_WAIT_FAIL_CHECK_TMO)
    91a2:	4b69      	ldr	r3, [pc, #420]	; (9348 <TCPIP_DHCP_Task+0x414>)
    91a4:	681b      	ldr	r3, [r3, #0]
    91a6:	6862      	ldr	r2, [r4, #4]
    91a8:	1a9b      	subs	r3, r3, r2
    91aa:	2b09      	cmp	r3, #9
    91ac:	d917      	bls.n	91de <TCPIP_DHCP_Task+0x2aa>
                    _DHCPSetRunFail(pClient, TCPIP_DHCP_SEND_DISCOVERY, false);
    91ae:	2200      	movs	r2, #0
    91b0:	2102      	movs	r1, #2
    91b2:	4620      	mov	r0, r4
    91b4:	f015 fb38 	bl	1e828 <_DHCPSetRunFail>
    91b8:	e011      	b.n	91de <TCPIP_DHCP_Task+0x2aa>
                if((_DHCPSecondCountGet() - pClient->tRequest) < pClient->t1Seconds)
    91ba:	4b63      	ldr	r3, [pc, #396]	; (9348 <TCPIP_DHCP_Task+0x414>)
    91bc:	681b      	ldr	r3, [r3, #0]
    91be:	68a2      	ldr	r2, [r4, #8]
    91c0:	1a9b      	subs	r3, r3, r2
    91c2:	6922      	ldr	r2, [r4, #16]
    91c4:	4293      	cmp	r3, r2
    91c6:	d30a      	bcc.n	91de <TCPIP_DHCP_Task+0x2aa>
    pClient->smState = newState;
    91c8:	2309      	movs	r3, #9
    91ca:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
                if(!_DHCPSend(pClient, pNetIf, TCPIP_DHCP_REQUEST_RENEW_MESSAGE, 0))
    91ce:	2300      	movs	r3, #0
    91d0:	2209      	movs	r2, #9
    91d2:	4631      	mov	r1, r6
    91d4:	4620      	mov	r0, r4
    91d6:	f008 f83f 	bl	11258 <_DHCPSend>
    91da:	2800      	cmp	r0, #0
    91dc:	d150      	bne.n	9280 <TCPIP_DHCP_Task+0x34c>
    for(netIx = 0; netIx < nNets; netIx++) 
    91de:	3501      	adds	r5, #1
    91e0:	45a9      	cmp	r9, r5
    91e2:	f000 80d6 	beq.w	9392 <TCPIP_DHCP_Task+0x45e>
        pNetIf = (TCPIP_NET_IF*)TCPIP_STACK_IndexToNet (netIx);
    91e6:	4628      	mov	r0, r5
    91e8:	f018 ff4c 	bl	22084 <TCPIP_STACK_IndexToNet>
TCPIP_NET_IF*  TCPIP_Stack_UserHandleToNet(TCPIP_NET_HANDLE hNet);


static __inline__ bool  __attribute__((always_inline)) TCPIP_STACK_NetworkIsUp(TCPIP_NET_IF* pNetIf)
{
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
    91ec:	4606      	mov	r6, r0
    91ee:	2800      	cmp	r0, #0
    91f0:	d0f5      	beq.n	91de <TCPIP_DHCP_Task+0x2aa>
    91f2:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
    91f6:	f013 0f40 	tst.w	r3, #64	; 0x40
    91fa:	d0f0      	beq.n	91de <TCPIP_DHCP_Task+0x2aa>
        pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf); 
    91fc:	f8da 8000 	ldr.w	r8, [sl]
    9200:	f01a fe9a 	bl	23f38 <TCPIP_STACK_NetIxGet>
    9204:	fb0b f700 	mul.w	r7, fp, r0
    9208:	eb08 0407 	add.w	r4, r8, r7
        if(pClient->flags.bDHCPEnabled == false)
    920c:	f894 2058 	ldrb.w	r2, [r4, #88]	; 0x58
    9210:	f012 0301 	ands.w	r3, r2, #1
    9214:	9301      	str	r3, [sp, #4]
    9216:	d0e2      	beq.n	91de <TCPIP_DHCP_Task+0x2aa>
    if(pClient->smState > TCPIP_DHCP_WAIT_LINK && pClient->smState < TCPIP_DHCP_BOUND)
    9218:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
    921c:	3b02      	subs	r3, #2
    921e:	b29b      	uxth	r3, r3
    9220:	2b05      	cmp	r3, #5
    9222:	d80c      	bhi.n	923e <TCPIP_DHCP_Task+0x30a>
        if(pClient->flags.bReportFail && pClient->tOpStart != 0)
    9224:	f012 0f20 	tst.w	r2, #32
    9228:	d009      	beq.n	923e <TCPIP_DHCP_Task+0x30a>
    922a:	6a23      	ldr	r3, [r4, #32]
    922c:	b13b      	cbz	r3, 923e <TCPIP_DHCP_Task+0x30a>
            if((_DHCPSecondCountGet() - pClient->tOpStart) >= pClient->tOpFailTmo)
    922e:	4a46      	ldr	r2, [pc, #280]	; (9348 <TCPIP_DHCP_Task+0x414>)
    9230:	6812      	ldr	r2, [r2, #0]
    9232:	1ad3      	subs	r3, r2, r3
    9234:	f8b4 2050 	ldrh.w	r2, [r4, #80]	; 0x50
    9238:	4293      	cmp	r3, r2
    923a:	f4bf ae96 	bcs.w	8f6a <TCPIP_DHCP_Task+0x36>
        switch(pClient->smState)
    923e:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
    9242:	3b01      	subs	r3, #1
    9244:	2b0b      	cmp	r3, #11
    9246:	d8ca      	bhi.n	91de <TCPIP_DHCP_Task+0x2aa>
    9248:	a201      	add	r2, pc, #4	; (adr r2, 9250 <TCPIP_DHCP_Task+0x31c>)
    924a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    924e:	bf00      	nop
    9250:	00008f83 	.word	0x00008f83
    9254:	00008fbb 	.word	0x00008fbb
    9258:	00009003 	.word	0x00009003
    925c:	0000902d 	.word	0x0000902d
    9260:	0000908b 	.word	0x0000908b
    9264:	000090bf 	.word	0x000090bf
    9268:	000091a3 	.word	0x000091a3
    926c:	000091bb 	.word	0x000091bb
    9270:	000091cf 	.word	0x000091cf
    9274:	000092c1 	.word	0x000092c1
    9278:	000092f7 	.word	0x000092f7
    927c:	00009351 	.word	0x00009351
                pClient->tRenewRequest = _DHCPSecondCountGet();
    9280:	4b31      	ldr	r3, [pc, #196]	; (9348 <TCPIP_DHCP_Task+0x414>)
    9282:	681b      	ldr	r3, [r3, #0]
    9284:	60e3      	str	r3, [r4, #12]
                _DHCPNotifyClients(pNetIf, DHCP_EVENT_REQUEST_RENEW);
    9286:	2109      	movs	r1, #9
    9288:	4630      	mov	r0, r6
    928a:	f016 fedb 	bl	20044 <_DHCPNotifyClients>
                pClient->flags.bOfferReceived = false;
    928e:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
    9292:	f36f 0382 	bfc	r3, #2, #1
    9296:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
                pClient->t3Seconds = ((pClient->t2Seconds - pClient->t1Seconds) - (pClient->tRenewRequest - pClient->tRequest)) >> 1;
    929a:	6963      	ldr	r3, [r4, #20]
    929c:	68a2      	ldr	r2, [r4, #8]
    929e:	4413      	add	r3, r2
    92a0:	6922      	ldr	r2, [r4, #16]
    92a2:	1a9b      	subs	r3, r3, r2
    92a4:	68e2      	ldr	r2, [r4, #12]
    92a6:	1a9b      	subs	r3, r3, r2
    92a8:	085b      	lsrs	r3, r3, #1
                if( pClient->t3Seconds < TCPIP_DHCP_RENEW_RETRY_TIMEOUT)
    92aa:	2b3b      	cmp	r3, #59	; 0x3b
                    pClient->t3Seconds = TCPIP_DHCP_RENEW_RETRY_TIMEOUT;
    92ac:	bf98      	it	ls
    92ae:	233c      	movls	r3, #60	; 0x3c
    92b0:	61e3      	str	r3, [r4, #28]
                pClient->startWait = _DHCPSecondCountGet();
    92b2:	4b25      	ldr	r3, [pc, #148]	; (9348 <TCPIP_DHCP_Task+0x414>)
    92b4:	681b      	ldr	r3, [r3, #0]
    92b6:	6063      	str	r3, [r4, #4]
    pClient->smState = newState;
    92b8:	230a      	movs	r3, #10
    92ba:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    92be:	e78e      	b.n	91de <TCPIP_DHCP_Task+0x2aa>
                if(_DHCPProcessReceiveData(pClient, pNetIf) == TCPIP_DHCP_TIMEOUT_MESSAGE)
    92c0:	4631      	mov	r1, r6
    92c2:	4620      	mov	r0, r4
    92c4:	f00f ff54 	bl	19170 <_DHCPProcessReceiveData>
    92c8:	280a      	cmp	r0, #10
    92ca:	d188      	bne.n	91de <TCPIP_DHCP_Task+0x2aa>
    return dhcpSecondCount;
    92cc:	4b1e      	ldr	r3, [pc, #120]	; (9348 <TCPIP_DHCP_Task+0x414>)
    92ce:	681a      	ldr	r2, [r3, #0]
                    if((_DHCPSecondCountGet() - pClient->tRequest) >= pClient->t2Seconds)
    92d0:	68a3      	ldr	r3, [r4, #8]
    92d2:	1ad3      	subs	r3, r2, r3
    92d4:	6961      	ldr	r1, [r4, #20]
    92d6:	428b      	cmp	r3, r1
    92d8:	d303      	bcc.n	92e2 <TCPIP_DHCP_Task+0x3ae>
    pClient->smState = newState;
    92da:	230b      	movs	r3, #11
    92dc:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    92e0:	e77d      	b.n	91de <TCPIP_DHCP_Task+0x2aa>
                    else if((_DHCPSecondCountGet() - pClient->startWait) >= pClient->t3Seconds)
    92e2:	6863      	ldr	r3, [r4, #4]
    92e4:	1ad2      	subs	r2, r2, r3
    92e6:	69e3      	ldr	r3, [r4, #28]
    92e8:	429a      	cmp	r2, r3
    92ea:	f4ff af78 	bcc.w	91de <TCPIP_DHCP_Task+0x2aa>
    pClient->smState = newState;
    92ee:	2309      	movs	r3, #9
    92f0:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    92f4:	e773      	b.n	91de <TCPIP_DHCP_Task+0x2aa>
                if(!_DHCPSend(pClient, pNetIf, TCPIP_DHCP_REQUEST_RENEW_MESSAGE, TCPIP_DHCP_FLAG_SEND_BCAST))
    92f6:	2301      	movs	r3, #1
    92f8:	2209      	movs	r2, #9
    92fa:	4631      	mov	r1, r6
    92fc:	4620      	mov	r0, r4
    92fe:	f007 ffab 	bl	11258 <_DHCPSend>
    9302:	2800      	cmp	r0, #0
    9304:	f43f af6b 	beq.w	91de <TCPIP_DHCP_Task+0x2aa>
                pClient->tRenewRequest = _DHCPSecondCountGet();
    9308:	4b0f      	ldr	r3, [pc, #60]	; (9348 <TCPIP_DHCP_Task+0x414>)
    930a:	681b      	ldr	r3, [r3, #0]
    930c:	60e3      	str	r3, [r4, #12]
                _DHCPNotifyClients(pNetIf, DHCP_EVENT_REQUEST_REBIND);
    930e:	210a      	movs	r1, #10
    9310:	4630      	mov	r0, r6
    9312:	f016 fe97 	bl	20044 <_DHCPNotifyClients>
                pClient->flags.bOfferReceived = false;
    9316:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
    931a:	f36f 0382 	bfc	r3, #2, #1
    931e:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
                pClient->t3Seconds = ((pClient->tExpSeconds - pClient->t2Seconds) - (pClient->tRenewRequest - pClient->tRequest)) >> 1;
    9322:	69a3      	ldr	r3, [r4, #24]
    9324:	68a2      	ldr	r2, [r4, #8]
    9326:	4413      	add	r3, r2
    9328:	6962      	ldr	r2, [r4, #20]
    932a:	1a9b      	subs	r3, r3, r2
    932c:	68e2      	ldr	r2, [r4, #12]
    932e:	1a9b      	subs	r3, r3, r2
    9330:	085b      	lsrs	r3, r3, #1
                if( pClient->t3Seconds < TCPIP_DHCP_REBIND_RETRY_TIMEOUT)
    9332:	2b3b      	cmp	r3, #59	; 0x3b
                    pClient->t3Seconds = TCPIP_DHCP_REBIND_RETRY_TIMEOUT;
    9334:	bf98      	it	ls
    9336:	233c      	movls	r3, #60	; 0x3c
    9338:	61e3      	str	r3, [r4, #28]
                pClient->startWait = _DHCPSecondCountGet();
    933a:	4b03      	ldr	r3, [pc, #12]	; (9348 <TCPIP_DHCP_Task+0x414>)
    933c:	681b      	ldr	r3, [r3, #0]
    933e:	6063      	str	r3, [r4, #4]
    pClient->smState = newState;
    9340:	230c      	movs	r3, #12
    9342:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    9346:	e74a      	b.n	91de <TCPIP_DHCP_Task+0x2aa>
    9348:	2000ee4c 	.word	0x2000ee4c
    934c:	2000ee3c 	.word	0x2000ee3c
                if(_DHCPProcessReceiveData(pClient, pNetIf) == TCPIP_DHCP_TIMEOUT_MESSAGE)
    9350:	4631      	mov	r1, r6
    9352:	4620      	mov	r0, r4
    9354:	f00f ff0c 	bl	19170 <_DHCPProcessReceiveData>
    9358:	280a      	cmp	r0, #10
    935a:	f47f af40 	bne.w	91de <TCPIP_DHCP_Task+0x2aa>
    return dhcpSecondCount;
    935e:	4b23      	ldr	r3, [pc, #140]	; (93ec <TCPIP_DHCP_Task+0x4b8>)
    9360:	681b      	ldr	r3, [r3, #0]
                    if((_DHCPSecondCountGet() - pClient->tRequest) >= pClient->tExpSeconds)
    9362:	68a2      	ldr	r2, [r4, #8]
    9364:	1a9a      	subs	r2, r3, r2
    9366:	69a1      	ldr	r1, [r4, #24]
    9368:	428a      	cmp	r2, r1
    936a:	d208      	bcs.n	937e <TCPIP_DHCP_Task+0x44a>
                    else if((_DHCPSecondCountGet() - pClient->startWait) >= pClient->t3Seconds)
    936c:	6862      	ldr	r2, [r4, #4]
    936e:	1a9b      	subs	r3, r3, r2
    9370:	69e2      	ldr	r2, [r4, #28]
    9372:	4293      	cmp	r3, r2
    pClient->smState = newState;
    9374:	bf24      	itt	cs
    9376:	230b      	movcs	r3, #11
    9378:	f8a4 3056 	strhcs.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    937c:	e72f      	b.n	91de <TCPIP_DHCP_Task+0x2aa>
                        _DHCPSetRunFail(pClient, TCPIP_DHCP_SEND_DISCOVERY, false);
    937e:	2200      	movs	r2, #0
    9380:	2102      	movs	r1, #2
    9382:	4620      	mov	r0, r4
    9384:	f015 fa50 	bl	1e828 <_DHCPSetRunFail>
                        _DHCPNotifyClients(pNetIf, DHCP_EVENT_TIMEOUT);
    9388:	2107      	movs	r1, #7
    938a:	4630      	mov	r0, r6
    938c:	f016 fe5a 	bl	20044 <_DHCPNotifyClients>
    9390:	e725      	b.n	91de <TCPIP_DHCP_Task+0x2aa>
    TCPIP_UDP_Discard(dhcpClientSocket);
    9392:	4b17      	ldr	r3, [pc, #92]	; (93f0 <TCPIP_DHCP_Task+0x4bc>)
    9394:	f9b3 0000 	ldrsh.w	r0, [r3]
    9398:	f019 facf 	bl	2293a <TCPIP_UDP_Discard>
}
    939c:	b007      	add	sp, #28
    939e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    None.
*/

static __inline__ uint64_t __attribute__((always_inline)) SYS_TMR_SystemCountGet(void)
{
	return SYS_TIME_Counter64Get();
    93a2:	f016 ff99 	bl	202d8 <SYS_TIME_Counter64Get>
    93a6:	4604      	mov	r4, r0
    93a8:	460d      	mov	r5, r1
	return SYS_TIME_FrequencyGet();
    93aa:	f01a ff6f 	bl	2428c <SYS_TIME_FrequencyGet>
    dhcpSecondCount = SYS_TMR_SystemCountGet() / SYS_TMR_SystemCountFrequencyGet(); 
    93ae:	4602      	mov	r2, r0
    93b0:	2300      	movs	r3, #0
    93b2:	4620      	mov	r0, r4
    93b4:	4629      	mov	r1, r5
    93b6:	f018 f911 	bl	215dc <__aeabi_uldivmod>
    93ba:	4b0c      	ldr	r3, [pc, #48]	; (93ec <TCPIP_DHCP_Task+0x4b8>)
    93bc:	6018      	str	r0, [r3, #0]
    93be:	e5c8      	b.n	8f52 <TCPIP_DHCP_Task+0x1e>
                        TCPIP_ARP_EntryRemove(pNetIf,  &arpCheck);
    93c0:	a902      	add	r1, sp, #8
    93c2:	4630      	mov	r0, r6
    93c4:	f012 fc9a 	bl	1bcfc <TCPIP_ARP_EntryRemove>
                        _DHCPSend(pClient, pNetIf, TCPIP_DHCP_DECLINE_MESSAGE, TCPIP_DHCP_FLAG_SEND_ZERO_ADD | TCPIP_DHCP_FLAG_SEND_BCAST);
    93c8:	2303      	movs	r3, #3
    93ca:	2204      	movs	r2, #4
    93cc:	4631      	mov	r1, r6
    93ce:	4620      	mov	r0, r4
    93d0:	f007 ff42 	bl	11258 <_DHCPSend>
    pClient->smState = newState;
    93d4:	2307      	movs	r3, #7
    93d6:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
                        pClient->startWait = _DHCPSecondCountGet();
    93da:	4b04      	ldr	r3, [pc, #16]	; (93ec <TCPIP_DHCP_Task+0x4b8>)
    93dc:	681b      	ldr	r3, [r3, #0]
    93de:	6063      	str	r3, [r4, #4]
                        _DHCPNotifyClients(pNetIf, DHCP_EVENT_DECLINE);
    93e0:	2105      	movs	r1, #5
    93e2:	4630      	mov	r0, r6
    93e4:	f016 fe2e 	bl	20044 <_DHCPNotifyClients>
    93e8:	e6f9      	b.n	91de <TCPIP_DHCP_Task+0x2aa>
    93ea:	bf00      	nop
    93ec:	2000ee4c 	.word	0x2000ee4c
    93f0:	2000ef7e 	.word	0x2000ef7e

Disassembly of section .rodata%226:

000093f4 <.rodata%226>:
    93f4:	2f504354 	.word	0x2f504354
    93f8:	53205049 	.word	0x53205049
    93fc:	6b636174 	.word	0x6b636174
    9400:	7325203a 	.word	0x7325203a
    9404:	43414d20 	.word	0x43414d20
    9408:	696e6920 	.word	0x696e6920
    940c:	6c616974 	.word	0x6c616974
    9410:	74617a69 	.word	0x74617a69
    9414:	206e6f69 	.word	0x206e6f69
    9418:	6c696166 	.word	0x6c696166
    941c:	0a0d6465 	.word	0x0a0d6465
    9420:	00000000 	.word	0x00000000
    9424:	2f504354 	.word	0x2f504354
    9428:	53205049 	.word	0x53205049
    942c:	6b636174 	.word	0x6b636174
    9430:	7325203a 	.word	0x7325203a
    9434:	43414d20 	.word	0x43414d20
    9438:	65704f20 	.word	0x65704f20
    943c:	6166206e 	.word	0x6166206e
    9440:	64656c69 	.word	0x64656c69
    9444:	00000a0d 	.word	0x00000a0d
    9448:	2f504354 	.word	0x2f504354
    944c:	53205049 	.word	0x53205049
    9450:	6b636174 	.word	0x6b636174
    9454:	6f4d203a 	.word	0x6f4d203a
    9458:	656c7564 	.word	0x656c7564
    945c:	3a6f6e20 	.word	0x3a6f6e20
    9460:	20642520 	.word	0x20642520
    9464:	74696e49 	.word	0x74696e49
    9468:	696c6169 	.word	0x696c6169
    946c:	6974617a 	.word	0x6974617a
    9470:	66206e6f 	.word	0x66206e6f
    9474:	656c6961 	.word	0x656c6961
    9478:	000a0d64 	.word	0x000a0d64
    947c:	2f504354 	.word	0x2f504354
    9480:	53205049 	.word	0x53205049
    9484:	6b636174 	.word	0x6b636174
    9488:	7325203a 	.word	0x7325203a
    948c:	43414d20 	.word	0x43414d20
    9490:	65766520 	.word	0x65766520
    9494:	6e20746e 	.word	0x6e20746e
    9498:	6669746f 	.word	0x6669746f
    949c:	74616369 	.word	0x74616369
    94a0:	206e6f69 	.word	0x206e6f69
    94a4:	74746573 	.word	0x74746573
    94a8:	20676e69 	.word	0x20676e69
    94ac:	6c696166 	.word	0x6c696166
    94b0:	0a0d6465 	.word	0x0a0d6465
    94b4:	00000000 	.word	0x00000000
    94b8:	2f504354 	.word	0x2f504354
    94bc:	53205049 	.word	0x53205049
    94c0:	6b636174 	.word	0x6b636174
    94c4:	6548203a 	.word	0x6548203a
    94c8:	44207061 	.word	0x44207061
    94cc:	74656c65 	.word	0x74656c65
    94d0:	61662065 	.word	0x61662065
    94d4:	0d216c69 	.word	0x0d216c69
    94d8:	0000000a 	.word	0x0000000a
    94dc:	2f504354 	.word	0x2f504354
    94e0:	53205049 	.word	0x53205049
    94e4:	6b636174 	.word	0x6b636174
    94e8:	6548203a 	.word	0x6548203a
    94ec:	63207061 	.word	0x63207061
    94f0:	74616572 	.word	0x74616572
    94f4:	206e6f69 	.word	0x206e6f69
    94f8:	6c696166 	.word	0x6c696166
    94fc:	202c6465 	.word	0x202c6465
    9500:	65707974 	.word	0x65707974
    9504:	6425203a 	.word	0x6425203a
    9508:	00000a0d 	.word	0x00000a0d
    950c:	2f504354 	.word	0x2f504354
    9510:	53205049 	.word	0x53205049
    9514:	6b636174 	.word	0x6b636174
    9518:	654e203a 	.word	0x654e203a
    951c:	726f7774 	.word	0x726f7774
    9520:	6f63206b 	.word	0x6f63206b
    9524:	6769666e 	.word	0x6769666e
    9528:	74617275 	.word	0x74617275
    952c:	206e6f69 	.word	0x206e6f69
    9530:	6f6c6c61 	.word	0x6f6c6c61
    9534:	69746163 	.word	0x69746163
    9538:	66206e6f 	.word	0x66206e6f
    953c:	656c6961 	.word	0x656c6961
    9540:	25203a64 	.word	0x25203a64
    9544:	0a0d756c 	.word	0x0a0d756c
    9548:	00000000 	.word	0x00000000
    954c:	2f504354 	.word	0x2f504354
    9550:	53205049 	.word	0x53205049
    9554:	6b636174 	.word	0x6b636174
    9558:	6150203a 	.word	0x6150203a
    955c:	74656b63 	.word	0x74656b63
    9560:	696e6920 	.word	0x696e6920
    9564:	6c616974 	.word	0x6c616974
    9568:	74617a69 	.word	0x74617a69
    956c:	206e6f69 	.word	0x206e6f69
    9570:	6c696166 	.word	0x6c696166
    9574:	203a6465 	.word	0x203a6465
    9578:	78257830 	.word	0x78257830
    957c:	00000a0d 	.word	0x00000a0d
    9580:	2f504354 	.word	0x2f504354
    9584:	53205049 	.word	0x53205049
    9588:	6b636174 	.word	0x6b636174
    958c:	6544203a 	.word	0x6544203a
    9590:	6c756166 	.word	0x6c756166
    9594:	6c462074 	.word	0x6c462074
    9598:	20687361 	.word	0x20687361
    959c:	7774654e 	.word	0x7774654e
    95a0:	206b726f 	.word	0x206b726f
    95a4:	666e6f63 	.word	0x666e6f63
    95a8:	72756769 	.word	0x72756769
    95ac:	6f697461 	.word	0x6f697461
    95b0:	6f6c206e 	.word	0x6f6c206e
    95b4:	66206461 	.word	0x66206461
    95b8:	656c6961 	.word	0x656c6961
    95bc:	64252064 	.word	0x64252064
    95c0:	00000a0d 	.word	0x00000a0d
    95c4:	2f504354 	.word	0x2f504354
    95c8:	53205049 	.word	0x53205049
    95cc:	6b636174 	.word	0x6b636174
    95d0:	654e203a 	.word	0x654e203a
    95d4:	726f7774 	.word	0x726f7774
    95d8:	6f63206b 	.word	0x6f63206b
    95dc:	6769666e 	.word	0x6769666e
    95e0:	74617275 	.word	0x74617275
    95e4:	206e6f69 	.word	0x206e6f69
    95e8:	74696e69 	.word	0x74696e69
    95ec:	696c6169 	.word	0x696c6169
    95f0:	6974617a 	.word	0x6974617a
    95f4:	66206e6f 	.word	0x66206e6f
    95f8:	656c6961 	.word	0x656c6961
    95fc:	25203a64 	.word	0x25203a64
    9600:	000a0d64 	.word	0x000a0d64
    9604:	2f504354 	.word	0x2f504354
    9608:	53205049 	.word	0x53205049
    960c:	6b636174 	.word	0x6b636174
    9610:	654e203a 	.word	0x654e203a
    9614:	726f7774 	.word	0x726f7774
    9618:	6f63206b 	.word	0x6f63206b
    961c:	6769666e 	.word	0x6769666e
    9620:	74617275 	.word	0x74617275
    9624:	3a6e6f69 	.word	0x3a6e6f69
    9628:	696c4120 	.word	0x696c4120
    962c:	73657361 	.word	0x73657361
    9630:	746f6e20 	.word	0x746f6e20
    9634:	70757320 	.word	0x70757320
    9638:	74726f70 	.word	0x74726f70
    963c:	203a6465 	.word	0x203a6465
    9640:	0a0d6425 	.word	0x0a0d6425
    9644:	00000000 	.word	0x00000000
    9648:	2f504354 	.word	0x2f504354
    964c:	53205049 	.word	0x53205049
    9650:	6b636174 	.word	0x6b636174
    9654:	654e203a 	.word	0x654e203a
    9658:	726f7774 	.word	0x726f7774
    965c:	6f63206b 	.word	0x6f63206b
    9660:	6769666e 	.word	0x6769666e
    9664:	74617275 	.word	0x74617275
    9668:	3a6e6f69 	.word	0x3a6e6f69
    966c:	766e6920 	.word	0x766e6920
    9670:	64696c61 	.word	0x64696c61
    9674:	20504920 	.word	0x20504920
    9678:	72646461 	.word	0x72646461
    967c:	3a737365 	.word	0x3a737365
    9680:	25783020 	.word	0x25783020
    9684:	0a0d7838 	.word	0x0a0d7838
    9688:	00000000 	.word	0x00000000
    968c:	64257325 	.word	0x64257325
    9690:	00000000 	.word	0x00000000
    9694:	2f504354 	.word	0x2f504354
    9698:	53205049 	.word	0x53205049
    969c:	6b636174 	.word	0x6b636174
    96a0:	6f50203a 	.word	0x6f50203a
    96a4:	20726577 	.word	0x20726577
    96a8:	65646f4d 	.word	0x65646f4d
    96ac:	696e6920 	.word	0x696e6920
    96b0:	6c616974 	.word	0x6c616974
    96b4:	74617a69 	.word	0x74617a69
    96b8:	206e6f69 	.word	0x206e6f69
    96bc:	6c696166 	.word	0x6c696166
    96c0:	6425203a 	.word	0x6425203a
    96c4:	00000a0d 	.word	0x00000a0d
    96c8:	2f504354 	.word	0x2f504354
    96cc:	53205049 	.word	0x53205049
    96d0:	6b636174 	.word	0x6b636174
    96d4:	7944203a 	.word	0x7944203a
    96d8:	696d616e 	.word	0x696d616e
    96dc:	656d2063 	.word	0x656d2063
    96e0:	79726f6d 	.word	0x79726f6d
    96e4:	20736920 	.word	0x20736920
    96e8:	3a776f6c 	.word	0x3a776f6c
    96ec:	756c2520 	.word	0x756c2520
    96f0:	00000a0d 	.word	0x00000a0d
    96f4:	2f504354 	.word	0x2f504354
    96f8:	53205049 	.word	0x53205049
    96fc:	6b636174 	.word	0x6b636174
    9700:	6e49203a 	.word	0x6e49203a
    9704:	61697469 	.word	0x61697469
    9708:	617a696c 	.word	0x617a696c
    970c:	6e6f6974 	.word	0x6e6f6974
    9710:	69616620 	.word	0x69616620
    9714:	2064656c 	.word	0x2064656c
    9718:	2d206425 	.word	0x2d206425
    971c:	6f624120 	.word	0x6f624120
    9720:	6e697472 	.word	0x6e697472
    9724:	0d202167 	.word	0x0d202167
    9728:	0000000a 	.word	0x0000000a
    972c:	2f504354 	.word	0x2f504354
    9730:	53205049 	.word	0x53205049
    9734:	6b636174 	.word	0x6b636174
    9738:	6e49203a 	.word	0x6e49203a
    973c:	61697469 	.word	0x61697469
    9740:	617a696c 	.word	0x617a696c
    9744:	6e6f6974 	.word	0x6e6f6974
    9748:	61745320 	.word	0x61745320
    974c:	64657472 	.word	0x64657472
    9750:	000a0d20 	.word	0x000a0d20
    9754:	2f504354 	.word	0x2f504354
    9758:	53205049 	.word	0x53205049
    975c:	6b636174 	.word	0x6b636174
    9760:	654e203a 	.word	0x654e203a
    9764:	726f7774 	.word	0x726f7774
    9768:	6f63206b 	.word	0x6f63206b
    976c:	6769666e 	.word	0x6769666e
    9770:	74617275 	.word	0x74617275
    9774:	206e6f69 	.word	0x206e6f69
    9778:	64616f6c 	.word	0x64616f6c
    977c:	69616620 	.word	0x69616620
    9780:	3a64656c 	.word	0x3a64656c
    9784:	0d642520 	.word	0x0d642520
    9788:	0000000a 	.word	0x0000000a
    978c:	2f504354 	.word	0x2f504354
    9790:	53205049 	.word	0x53205049
    9794:	6b636174 	.word	0x6b636174
    9798:	6954203a 	.word	0x6954203a
    979c:	72206b63 	.word	0x72206b63
    97a0:	73696765 	.word	0x73696765
    97a4:	74617274 	.word	0x74617274
    97a8:	206e6f69 	.word	0x206e6f69
    97ac:	6c696166 	.word	0x6c696166
    97b0:	203a6465 	.word	0x203a6465
    97b4:	0a0d6425 	.word	0x0a0d6425
    97b8:	00000000 	.word	0x00000000
    97bc:	2f504354 	.word	0x2f504354
    97c0:	53205049 	.word	0x53205049
    97c4:	6b636174 	.word	0x6b636174
    97c8:	6e49203a 	.word	0x6e49203a
    97cc:	61697469 	.word	0x61697469
    97d0:	617a696c 	.word	0x617a696c
    97d4:	6e6f6974 	.word	0x6e6f6974
    97d8:	53595320 	.word	0x53595320
    97dc:	524d5420 	.word	0x524d5420
    97e0:	69616620 	.word	0x69616620
    97e4:	3a64656c 	.word	0x3a64656c
    97e8:	20642520 	.word	0x20642520
    97ec:	6241202d 	.word	0x6241202d
    97f0:	6974726f 	.word	0x6974726f
    97f4:	2021676e 	.word	0x2021676e
    97f8:	00000a0d 	.word	0x00000a0d
    97fc:	2f504354 	.word	0x2f504354
    9800:	53205049 	.word	0x53205049
    9804:	6b636174 	.word	0x6b636174
    9808:	6e49203a 	.word	0x6e49203a
    980c:	61697469 	.word	0x61697469
    9810:	617a696c 	.word	0x617a696c
    9814:	6e6f6974 	.word	0x6e6f6974
    9818:	646e4520 	.word	0x646e4520
    981c:	2d206465 	.word	0x2d206465
    9820:	63757320 	.word	0x63757320
    9824:	73736563 	.word	0x73736563
    9828:	000a0d20 	.word	0x000a0d20
    982c:	2f504354 	.word	0x2f504354
    9830:	53205049 	.word	0x53205049
    9834:	6b636174 	.word	0x6b636174
    9838:	6e49203a 	.word	0x6e49203a
    983c:	61697469 	.word	0x61697469
    9840:	617a696c 	.word	0x617a696c
    9844:	6e6f6974 	.word	0x6e6f6974
    9848:	69616620 	.word	0x69616620
    984c:	3a64656c 	.word	0x3a64656c
    9850:	25783020 	.word	0x25783020
    9854:	202d2078 	.word	0x202d2078
    9858:	726f6241 	.word	0x726f6241
    985c:	676e6974 	.word	0x676e6974
    9860:	0a0d2021 	.word	0x0a0d2021
    9864:	00000000 	.word	0x00000000
    9868:	30312e38 	.word	0x30312e38
    986c:	48202d20 	.word	0x48202d20
    9870:	00000033 	.word	0x00000033
    9874:	006b6e75 	.word	0x006b6e75
    9878:	00687465 	.word	0x00687465
    987c:	6e616c77 	.word	0x6e616c77
    9880:	00          	.byte	0x00
    9881:	00          	.byte	0x00
    9882:	bf00      	nop

Disassembly of section .text._TCPIP_DoInitialize%227:

00009884 <_TCPIP_DoInitialize>:
{
    9884:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9888:	b08b      	sub	sp, #44	; 0x2c
    nNets = init->nNets;
    988a:	6884      	ldr	r4, [r0, #8]
    if(nNets == 0 || pUsrConfig == 0 || pUsrConfig->pMacObject == 0 || pModConfig == 0 || nModules == 0)
    988c:	2c00      	cmp	r4, #0
    988e:	f000 81c3 	beq.w	9c18 <_TCPIP_DoInitialize+0x394>
    pUsrConfig = init->pNetConf;
    9892:	6845      	ldr	r5, [r0, #4]
    if(nNets == 0 || pUsrConfig == 0 || pUsrConfig->pMacObject == 0 || pModConfig == 0 || nModules == 0)
    9894:	2d00      	cmp	r5, #0
    9896:	f000 81c5 	beq.w	9c24 <_TCPIP_DoInitialize+0x3a0>
    989a:	6aab      	ldr	r3, [r5, #40]	; 0x28
    989c:	2b00      	cmp	r3, #0
    989e:	f000 81c4 	beq.w	9c2a <_TCPIP_DoInitialize+0x3a6>
    pModConfig = init->pModConfig;
    98a2:	f8d0 900c 	ldr.w	r9, [r0, #12]
    if(nNets == 0 || pUsrConfig == 0 || pUsrConfig->pMacObject == 0 || pModConfig == 0 || nModules == 0)
    98a6:	f1b9 0f00 	cmp.w	r9, #0
    98aa:	f000 81c1 	beq.w	9c30 <_TCPIP_DoInitialize+0x3ac>
    nModules = init->nModules;
    98ae:	f8d0 b010 	ldr.w	fp, [r0, #16]
    if(nNets == 0 || pUsrConfig == 0 || pUsrConfig->pMacObject == 0 || pModConfig == 0 || nModules == 0)
    98b2:	f1bb 0f00 	cmp.w	fp, #0
    98b6:	f000 81be 	beq.w	9c36 <_TCPIP_DoInitialize+0x3b2>
    tcpip_init_data = *init;
    98ba:	4fb3      	ldr	r7, [pc, #716]	; (9b88 <_TCPIP_DoInitialize+0x304>)
    98bc:	4606      	mov	r6, r0
    98be:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    98c0:	c70f      	stmia	r7!, {r0, r1, r2, r3}
    98c2:	e896 0003 	ldmia.w	r6, {r0, r1}
    98c6:	e887 0003 	stmia.w	r7, {r0, r1}
        if(pModConfig->moduleId == moduleId)
    98ca:	f8b9 3000 	ldrh.w	r3, [r9]
    98ce:	2b01      	cmp	r3, #1
    98d0:	f000 81c8 	beq.w	9c64 <_TCPIP_DoInitialize+0x3e0>
    98d4:	f1ab 0202 	sub.w	r2, fp, #2
    98d8:	464b      	mov	r3, r9
        pModConfig++;
    98da:	3308      	adds	r3, #8
    while(nModules--)
    98dc:	f1b2 3fff 	cmp.w	r2, #4294967295
    98e0:	d03f      	beq.n	9962 <_TCPIP_DoInitialize+0xde>
        if(pModConfig->moduleId == moduleId)
    98e2:	3a01      	subs	r2, #1
    98e4:	8819      	ldrh	r1, [r3, #0]
    98e6:	2901      	cmp	r1, #1
    98e8:	d1f7      	bne.n	98da <_TCPIP_DoInitialize+0x56>
        heapData = (pHeapConfig != 0) ? (const TCPIP_STACK_HEAP_CONFIG*)pHeapConfig->configData : 0;
    98ea:	f8d3 a004 	ldr.w	sl, [r3, #4]
        if( heapData == 0 || heapData->malloc_fnc == 0 || heapData->calloc_fnc == 0 || heapData->free_fnc == 0)
    98ee:	f1ba 0f00 	cmp.w	sl, #0
    98f2:	d038      	beq.n	9966 <_TCPIP_DoInitialize+0xe2>
    98f4:	f8da 3004 	ldr.w	r3, [sl, #4]
    98f8:	2b00      	cmp	r3, #0
    98fa:	d034      	beq.n	9966 <_TCPIP_DoInitialize+0xe2>
    98fc:	f8da 3008 	ldr.w	r3, [sl, #8]
    9900:	2b00      	cmp	r3, #0
    9902:	d030      	beq.n	9966 <_TCPIP_DoInitialize+0xe2>
    9904:	f8da 300c 	ldr.w	r3, [sl, #12]
    9908:	b36b      	cbz	r3, 9966 <_TCPIP_DoInitialize+0xe2>
            heapH = TCPIP_HEAP_Create(heapData, 0);
    990a:	2100      	movs	r1, #0
    990c:	4650      	mov	r0, sl
    990e:	f01a f8df 	bl	23ad0 <TCPIP_HEAP_Create>
    9912:	9005      	str	r0, [sp, #20]
        if((tcpip_stack_ctrl_data.memH = heapH) == 0)
    9914:	4b9d      	ldr	r3, [pc, #628]	; (9b8c <_TCPIP_DoInitialize+0x308>)
    9916:	60d8      	str	r0, [r3, #12]
    9918:	2800      	cmp	r0, #0
    991a:	f000 81a8 	beq.w	9c6e <_TCPIP_DoInitialize+0x3ea>
        tcpip_stack_ctrl_data.heapType = heapData->heapType;
    991e:	f89a 2000 	ldrb.w	r2, [sl]
    9922:	4b9a      	ldr	r3, [pc, #616]	; (9b8c <_TCPIP_DoInitialize+0x308>)
    9924:	741a      	strb	r2, [r3, #16]
// out of line version
void*   TCPIP_HEAP_MallocOutline(TCPIP_STACK_HEAP_HANDLE heapH, size_t nBytes);

static __inline__ void* __attribute__((always_inline)) TCPIP_HEAP_CallocInline(TCPIP_STACK_HEAP_HANDLE h, size_t nElems, size_t elemSize)
{
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Calloc)(h, nElems, elemSize);
    9926:	9805      	ldr	r0, [sp, #20]
    9928:	6883      	ldr	r3, [r0, #8]
    992a:	226c      	movs	r2, #108	; 0x6c
    992c:	4621      	mov	r1, r4
    992e:	4798      	blx	r3
        tcpipNetIf = (TCPIP_NET_IF*)TCPIP_HEAP_Calloc(heapH, nNets, sizeof(TCPIP_NET_IF)); // allocate for each network interface
    9930:	4b97      	ldr	r3, [pc, #604]	; (9b90 <_TCPIP_DoInitialize+0x30c>)
    9932:	6018      	str	r0, [r3, #0]
        if(tcpipNetIf == 0)
    9934:	b368      	cbz	r0, 9992 <_TCPIP_DoInitialize+0x10e>
        if(TCPIP_PKT_Initialize(heapH, pUsrConfig, nNets) == false)
    9936:	4622      	mov	r2, r4
    9938:	4629      	mov	r1, r5
    993a:	9805      	ldr	r0, [sp, #20]
    993c:	f017 fd16 	bl	2136c <TCPIP_PKT_Initialize>
    9940:	9003      	str	r0, [sp, #12]
    9942:	2800      	cmp	r0, #0
    9944:	d13c      	bne.n	99c0 <_TCPIP_DoInitialize+0x13c>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Packet initialization failed: 0x%x\r\n", (uint32_t)heapH);
    9946:	f01a fc9b 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    994a:	bb88      	cbnz	r0, 99b0 <_TCPIP_DoInitialize+0x12c>
            initFail = 3;
    994c:	2403      	movs	r4, #3
    SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Initialization failed %d - Aborting! \r\n", initFail);
    994e:	f01a fc97 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    9952:	2800      	cmp	r0, #0
    9954:	f040 8159 	bne.w	9c0a <_TCPIP_DoInitialize+0x386>
    TCPIP_STACK_KillStack();
    9958:	f00e fa62 	bl	17e20 <TCPIP_STACK_KillStack>
    return false;
    995c:	2300      	movs	r3, #0
    995e:	9303      	str	r3, [sp, #12]
    9960:	e15c      	b.n	9c1c <_TCPIP_DoInitialize+0x398>
        heapData = (pHeapConfig != 0) ? (const TCPIP_STACK_HEAP_CONFIG*)pHeapConfig->configData : 0;
    9962:	f04f 0a00 	mov.w	sl, #0
        if((tcpip_stack_ctrl_data.memH = heapH) == 0)
    9966:	4b89      	ldr	r3, [pc, #548]	; (9b8c <_TCPIP_DoInitialize+0x308>)
    9968:	2200      	movs	r2, #0
    996a:	60da      	str	r2, [r3, #12]
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Heap creation failed, type: %d\r\n", heapData ? heapData->heapType : TCPIP_STACK_HEAP_TYPE_NONE);
    996c:	f01a fc88 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    9970:	b908      	cbnz	r0, 9976 <_TCPIP_DoInitialize+0xf2>
            initFail = 1;
    9972:	2401      	movs	r4, #1
    9974:	e7eb      	b.n	994e <_TCPIP_DoInitialize+0xca>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Heap creation failed, type: %d\r\n", heapData ? heapData->heapType : TCPIP_STACK_HEAP_TYPE_NONE);
    9976:	f01a fc7d 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    997a:	f1ba 0f00 	cmp.w	sl, #0
    997e:	d006      	beq.n	998e <_TCPIP_DoInitialize+0x10a>
    9980:	f89a 2000 	ldrb.w	r2, [sl]
    9984:	4983      	ldr	r1, [pc, #524]	; (9b94 <_TCPIP_DoInitialize+0x310>)
    9986:	f012 fe89 	bl	1c69c <SYS_CONSOLE_Print>
            initFail = 1;
    998a:	2401      	movs	r4, #1
    998c:	e7df      	b.n	994e <_TCPIP_DoInitialize+0xca>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Heap creation failed, type: %d\r\n", heapData ? heapData->heapType : TCPIP_STACK_HEAP_TYPE_NONE);
    998e:	2200      	movs	r2, #0
    9990:	e7f8      	b.n	9984 <_TCPIP_DoInitialize+0x100>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration allocation failed: %lu\r\n", nNets * sizeof(TCPIP_NET_IF));
    9992:	f01a fc75 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    9996:	b908      	cbnz	r0, 999c <_TCPIP_DoInitialize+0x118>
            initFail = 2;
    9998:	2402      	movs	r4, #2
    999a:	e7d8      	b.n	994e <_TCPIP_DoInitialize+0xca>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration allocation failed: %lu\r\n", nNets * sizeof(TCPIP_NET_IF));
    999c:	f01a fc6a 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    99a0:	226c      	movs	r2, #108	; 0x6c
    99a2:	fb02 f204 	mul.w	r2, r2, r4
    99a6:	497c      	ldr	r1, [pc, #496]	; (9b98 <_TCPIP_DoInitialize+0x314>)
    99a8:	f012 fe78 	bl	1c69c <SYS_CONSOLE_Print>
            initFail = 2;
    99ac:	2402      	movs	r4, #2
    99ae:	e7ce      	b.n	994e <_TCPIP_DoInitialize+0xca>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Packet initialization failed: 0x%x\r\n", (uint32_t)heapH);
    99b0:	f01a fc60 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    99b4:	9a05      	ldr	r2, [sp, #20]
    99b6:	4979      	ldr	r1, [pc, #484]	; (9b9c <_TCPIP_DoInitialize+0x318>)
    99b8:	f012 fe70 	bl	1c69c <SYS_CONSOLE_Print>
            initFail = 3;
    99bc:	2403      	movs	r4, #3
    99be:	e7c6      	b.n	994e <_TCPIP_DoInitialize+0xca>
        tcpip_stack_ctrl_data.nIfs = nNets;
    99c0:	4b72      	ldr	r3, [pc, #456]	; (9b8c <_TCPIP_DoInitialize+0x308>)
    99c2:	601c      	str	r4, [r3, #0]
        tcpip_stack_ctrl_data.nModules = nModules;
    99c4:	f8c3 b008 	str.w	fp, [r3, #8]
    for(ix =0, pConfigIf = tcpipNetIf; ix < nNets; ix++, pConfigIf++, pUsrConfig++)
    99c8:	4b71      	ldr	r3, [pc, #452]	; (9b90 <_TCPIP_DoInitialize+0x30c>)
    99ca:	681e      	ldr	r6, [r3, #0]
    99cc:	2c00      	cmp	r4, #0
    99ce:	f340 8154 	ble.w	9c7a <_TCPIP_DoInitialize+0x3f6>
    99d2:	462f      	mov	r7, r5
    99d4:	f04f 0800 	mov.w	r8, #0
        if(!_LoadNetworkConfig(pUsrConfig, pConfigIf, false))
    99d8:	2200      	movs	r2, #0
    99da:	4631      	mov	r1, r6
    99dc:	4638      	mov	r0, r7
    99de:	f009 fefb 	bl	137d8 <_LoadNetworkConfig>
    99e2:	b328      	cbz	r0, 9a30 <_TCPIP_DoInitialize+0x1ac>
    for(ix =0, pConfigIf = tcpipNetIf; ix < nNets; ix++, pConfigIf++, pUsrConfig++)
    99e4:	f108 0801 	add.w	r8, r8, #1
    99e8:	366c      	adds	r6, #108	; 0x6c
    99ea:	3738      	adds	r7, #56	; 0x38
    99ec:	4544      	cmp	r4, r8
    99ee:	d1f3      	bne.n	99d8 <_TCPIP_DoInitialize+0x154>
        for(netIx = 0, pIf = tcpipNetIf; netIx < nNets; netIx++, pIf++)
    99f0:	4a67      	ldr	r2, [pc, #412]	; (9b90 <_TCPIP_DoInitialize+0x30c>)
    99f2:	f8d2 e000 	ldr.w	lr, [r2]
    99f6:	4a65      	ldr	r2, [pc, #404]	; (9b8c <_TCPIP_DoInitialize+0x308>)
    99f8:	6856      	ldr	r6, [r2, #4]
    99fa:	46f4      	mov	ip, lr
    99fc:	2100      	movs	r1, #0
                    tcpip_stack_ctrl_data.nAliases++;
    99fe:	4680      	mov	r8, r0
    9a00:	4670      	mov	r0, lr
    9a02:	468e      	mov	lr, r1
            pPriMac = pIf->pMacObj;
    9a04:	f8dc 7044 	ldr.w	r7, [ip, #68]	; 0x44
            for(ix = netIx + 1, pScanIf = pIf + 1; ix < nNets; ix++, pScanIf++)
    9a08:	f10e 0e01 	add.w	lr, lr, #1
    9a0c:	f10c 0c6c 	add.w	ip, ip, #108	; 0x6c
    9a10:	4574      	cmp	r4, lr
    9a12:	d024      	beq.n	9a5e <_TCPIP_DoInitialize+0x1da>
    9a14:	4662      	mov	r2, ip
    9a16:	4673      	mov	r3, lr
    9a18:	9004      	str	r0, [sp, #16]
                if(pScanIf->pMacObj == pPriMac)
    9a1a:	6c50      	ldr	r0, [r2, #68]	; 0x44
    9a1c:	42b8      	cmp	r0, r7
                    tcpip_stack_ctrl_data.nAliases++;
    9a1e:	bf04      	itt	eq
    9a20:	3601      	addeq	r6, #1
    9a22:	4641      	moveq	r1, r8
            for(ix = netIx + 1, pScanIf = pIf + 1; ix < nNets; ix++, pScanIf++)
    9a24:	3301      	adds	r3, #1
    9a26:	326c      	adds	r2, #108	; 0x6c
    9a28:	429c      	cmp	r4, r3
    9a2a:	d1f6      	bne.n	9a1a <_TCPIP_DoInitialize+0x196>
    9a2c:	9804      	ldr	r0, [sp, #16]
    9a2e:	e7e9      	b.n	9a04 <_TCPIP_DoInitialize+0x180>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Default Flash Network configuration load failed %d\r\n", ix);
    9a30:	f01a fc26 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    9a34:	b920      	cbnz	r0, 9a40 <_TCPIP_DoInitialize+0x1bc>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration initialization failed: %d\r\n", nNets);
    9a36:	f01a fc23 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    9a3a:	b940      	cbnz	r0, 9a4e <_TCPIP_DoInitialize+0x1ca>
            initFail = 4;   // failed the initialization
    9a3c:	2404      	movs	r4, #4
    9a3e:	e786      	b.n	994e <_TCPIP_DoInitialize+0xca>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Default Flash Network configuration load failed %d\r\n", ix);
    9a40:	f01a fc18 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    9a44:	4642      	mov	r2, r8
    9a46:	4956      	ldr	r1, [pc, #344]	; (9ba0 <_TCPIP_DoInitialize+0x31c>)
    9a48:	f012 fe28 	bl	1c69c <SYS_CONSOLE_Print>
    9a4c:	e7f3      	b.n	9a36 <_TCPIP_DoInitialize+0x1b2>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration initialization failed: %d\r\n", nNets);
    9a4e:	f01a fc11 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    9a52:	4622      	mov	r2, r4
    9a54:	4953      	ldr	r1, [pc, #332]	; (9ba4 <_TCPIP_DoInitialize+0x320>)
    9a56:	f012 fe21 	bl	1c69c <SYS_CONSOLE_Print>
            initFail = 4;   // failed the initialization
    9a5a:	2404      	movs	r4, #4
    9a5c:	e777      	b.n	994e <_TCPIP_DoInitialize+0xca>
    9a5e:	4686      	mov	lr, r0
    9a60:	b109      	cbz	r1, 9a66 <_TCPIP_DoInitialize+0x1e2>
    9a62:	4b4a      	ldr	r3, [pc, #296]	; (9b8c <_TCPIP_DoInitialize+0x308>)
    9a64:	605e      	str	r6, [r3, #4]
        if(tcpip_stack_ctrl_data.nAliases != 0)
    9a66:	4b49      	ldr	r3, [pc, #292]	; (9b8c <_TCPIP_DoInitialize+0x308>)
    9a68:	685b      	ldr	r3, [r3, #4]
    9a6a:	2b00      	cmp	r3, #0
    9a6c:	f040 810d 	bne.w	9c8a <_TCPIP_DoInitialize+0x406>
    9a70:	f10e 006c 	add.w	r0, lr, #108	; 0x6c
    9a74:	2701      	movs	r7, #1
    9a76:	e00c      	b.n	9a92 <_TCPIP_DoInitialize+0x20e>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration: Aliases not supported: %d\r\n", tcpip_stack_ctrl_data.nAliases);
    9a78:	f01a fbfc 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    9a7c:	4b43      	ldr	r3, [pc, #268]	; (9b8c <_TCPIP_DoInitialize+0x308>)
    9a7e:	685a      	ldr	r2, [r3, #4]
    9a80:	4949      	ldr	r1, [pc, #292]	; (9ba8 <_TCPIP_DoInitialize+0x324>)
    9a82:	f012 fe0b 	bl	1c69c <SYS_CONSOLE_Print>
            initFail = 5;
    9a86:	2405      	movs	r4, #5
    9a88:	e761      	b.n	994e <_TCPIP_DoInitialize+0xca>
        for(netIx = 0, pIf = tcpipNetIf; netIx < nNets && !initFail; netIx++, pIf++)
    9a8a:	42bc      	cmp	r4, r7
    9a8c:	dd20      	ble.n	9ad0 <_TCPIP_DoInitialize+0x24c>
    9a8e:	3701      	adds	r7, #1
    9a90:	306c      	adds	r0, #108	; 0x6c
            if((dupIpAddr.Val = pIf->DefaultIPAddr.Val) != 0)
    9a92:	4603      	mov	r3, r0
    9a94:	f850 1c54 	ldr.w	r1, [r0, #-84]
    9a98:	2900      	cmp	r1, #0
    9a9a:	d0f6      	beq.n	9a8a <_TCPIP_DoInitialize+0x206>
                for(ix = netIx + 1, pScanIf = pIf + 1; ix < nNets; ix++, pScanIf++)
    9a9c:	463a      	mov	r2, r7
    9a9e:	42bc      	cmp	r4, r7
    9aa0:	dd16      	ble.n	9ad0 <_TCPIP_DoInitialize+0x24c>
                    if(pScanIf->DefaultIPAddr.Val == dupIpAddr.Val)
    9aa2:	6986      	ldr	r6, [r0, #24]
    9aa4:	42b1      	cmp	r1, r6
    9aa6:	d006      	beq.n	9ab6 <_TCPIP_DoInitialize+0x232>
                for(ix = netIx + 1, pScanIf = pIf + 1; ix < nNets; ix++, pScanIf++)
    9aa8:	3201      	adds	r2, #1
    9aaa:	336c      	adds	r3, #108	; 0x6c
    9aac:	4294      	cmp	r4, r2
    9aae:	d0ee      	beq.n	9a8e <_TCPIP_DoInitialize+0x20a>
                    if(pScanIf->DefaultIPAddr.Val == dupIpAddr.Val)
    9ab0:	699e      	ldr	r6, [r3, #24]
    9ab2:	42b1      	cmp	r1, r6
    9ab4:	d1f8      	bne.n	9aa8 <_TCPIP_DoInitialize+0x224>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration: invalid IP address: 0x%8x\r\n", dupIpAddr.Val);
    9ab6:	f01a fbe3 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    9aba:	b908      	cbnz	r0, 9ac0 <_TCPIP_DoInitialize+0x23c>
    9abc:	2406      	movs	r4, #6
    9abe:	e746      	b.n	994e <_TCPIP_DoInitialize+0xca>
    9ac0:	f01a fbd8 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    9ac4:	4632      	mov	r2, r6
    9ac6:	4939      	ldr	r1, [pc, #228]	; (9bac <_TCPIP_DoInitialize+0x328>)
    9ac8:	f012 fde8 	bl	1c69c <SYS_CONSOLE_Print>
    9acc:	2406      	movs	r4, #6
    9ace:	e73e      	b.n	994e <_TCPIP_DoInitialize+0xca>
        tcpipDefIf.defaultNet = 0;
    9ad0:	2300      	movs	r3, #0
    9ad2:	4a37      	ldr	r2, [pc, #220]	; (9bb0 <_TCPIP_DoInitialize+0x32c>)
    9ad4:	6013      	str	r3, [r2, #0]
    memset(ifNumber, 0, sizeof(ifNumber));
    9ad6:	9307      	str	r3, [sp, #28]
    9ad8:	9308      	str	r3, [sp, #32]
    9ada:	9309      	str	r3, [sp, #36]	; 0x24
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    9adc:	4b2b      	ldr	r3, [pc, #172]	; (9b8c <_TCPIP_DoInitialize+0x308>)
    9ade:	681b      	ldr	r3, [r3, #0]
    9ae0:	2b00      	cmp	r3, #0
    9ae2:	dd24      	ble.n	9b2e <_TCPIP_DoInitialize+0x2aa>
    9ae4:	f10e 0662 	add.w	r6, lr, #98	; 0x62
    9ae8:	f04f 0800 	mov.w	r8, #0
    9aec:	f8cd a010 	str.w	sl, [sp, #16]
        pNetIf->netIfIx = netIx;
    9af0:	f826 8c0a 	strh.w	r8, [r6, #-10]
            const char* ifName = TCPIP_STACK_IF_ALIAS_NAME_TBL[macType]; 
    9af4:	79f3      	ldrb	r3, [r6, #7]
            snprintf(pNetIf->ifName, sizeof(pNetIf->ifName), "%s%d", ifName, ifNumber[macType]);
    9af6:	aa0a      	add	r2, sp, #40	; 0x28
    9af8:	eb02 0a83 	add.w	sl, r2, r3, lsl #2
    9afc:	f85a 7c0c 	ldr.w	r7, [sl, #-12]
    9b00:	9700      	str	r7, [sp, #0]
    9b02:	4a2c      	ldr	r2, [pc, #176]	; (9bb4 <_TCPIP_DoInitialize+0x330>)
    9b04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b08:	4a2b      	ldr	r2, [pc, #172]	; (9bb8 <_TCPIP_DoInitialize+0x334>)
    9b0a:	2107      	movs	r1, #7
    9b0c:	4630      	mov	r0, r6
    9b0e:	f012 fe31 	bl	1c774 <sniprintf>
            pNetIf->ifName[sizeof(pNetIf->ifName) - 1] = 0;
    9b12:	2300      	movs	r3, #0
    9b14:	71b3      	strb	r3, [r6, #6]
            ifNumber[macType]++;
    9b16:	3701      	adds	r7, #1
    9b18:	f84a 7c0c 	str.w	r7, [sl, #-12]
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    9b1c:	f108 0801 	add.w	r8, r8, #1
    9b20:	366c      	adds	r6, #108	; 0x6c
    9b22:	4b1a      	ldr	r3, [pc, #104]	; (9b8c <_TCPIP_DoInitialize+0x308>)
    9b24:	681b      	ldr	r3, [r3, #0]
    9b26:	4598      	cmp	r8, r3
    9b28:	dbe2      	blt.n	9af0 <_TCPIP_DoInitialize+0x26c>
    9b2a:	f8dd a010 	ldr.w	sl, [sp, #16]
        memset(TCPIP_STACK_MODULE_SIGNAL_TBL, 0x0, sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL));
    9b2e:	f44f 721c 	mov.w	r2, #624	; 0x270
    9b32:	2100      	movs	r1, #0
    9b34:	4821      	ldr	r0, [pc, #132]	; (9bbc <_TCPIP_DoInitialize+0x338>)
    9b36:	f01a f9b3 	bl	23ea0 <memset>
        stackAsyncSignalCount = 0;
    9b3a:	4b21      	ldr	r3, [pc, #132]	; (9bc0 <_TCPIP_DoInitialize+0x33c>)
    9b3c:	2200      	movs	r2, #0
    9b3e:	601a      	str	r2, [r3, #0]
        tcpip_heap_config = *heapData; 
    9b40:	4e20      	ldr	r6, [pc, #128]	; (9bc4 <_TCPIP_DoInitialize+0x340>)
    9b42:	e89a 000f 	ldmia.w	sl, {r0, r1, r2, r3}
    9b46:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
        for(ix = 0; ix < sizeof(TCPIP_MODULES_QUEUE_TBL)/sizeof(*TCPIP_MODULES_QUEUE_TBL); ix++)
    9b4a:	4e1f      	ldr	r6, [pc, #124]	; (9bc8 <_TCPIP_DoInitialize+0x344>)
    9b4c:	f106 0790 	add.w	r7, r6, #144	; 0x90
            TCPIP_Helper_SingleListInitialize(TCPIP_MODULES_QUEUE_TBL + ix);
    9b50:	4630      	mov	r0, r6
    9b52:	f01a fbf5 	bl	24340 <TCPIP_Helper_SingleListInitialize>
    9b56:	360c      	adds	r6, #12
        for(ix = 0; ix < sizeof(TCPIP_MODULES_QUEUE_TBL)/sizeof(*TCPIP_MODULES_QUEUE_TBL); ix++)
    9b58:	42be      	cmp	r6, r7
    9b5a:	d1f9      	bne.n	9b50 <_TCPIP_DoInitialize+0x2cc>
        tcpip_stack_ctrl_data.stackAction = TCPIP_STACK_ACTION_INIT;
    9b5c:	4b0b      	ldr	r3, [pc, #44]	; (9b8c <_TCPIP_DoInitialize+0x308>)
    9b5e:	2200      	movs	r2, #0
    9b60:	771a      	strb	r2, [r3, #28]
        for(netIx = 0, pIf = tcpipNetIf; netIx < nNets; netIx++, pIf++, pUsrConfig++)
    9b62:	4b0b      	ldr	r3, [pc, #44]	; (9b90 <_TCPIP_DoInitialize+0x30c>)
    9b64:	f8d3 a000 	ldr.w	sl, [r3]
    9b68:	4294      	cmp	r4, r2
    9b6a:	dd69      	ble.n	9c40 <_TCPIP_DoInitialize+0x3bc>
    9b6c:	4617      	mov	r7, r2
            tcpip_stack_ctrl_data.powerMode = powerMode;
    9b6e:	4e07      	ldr	r6, [pc, #28]	; (9b8c <_TCPIP_DoInitialize+0x308>)
    9b70:	46a0      	mov	r8, r4
    9b72:	4654      	mov	r4, sl
    9b74:	e03b      	b.n	9bee <_TCPIP_DoInitialize+0x36a>
                SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Power Mode initialization fail: %d\r\n", powerMode);
    9b76:	f01a fb7d 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    9b7a:	4642      	mov	r2, r8
    9b7c:	4913      	ldr	r1, [pc, #76]	; (9bcc <_TCPIP_DoInitialize+0x348>)
    9b7e:	f012 fd8d 	bl	1c69c <SYS_CONSOLE_Print>
                initFail = 7;
    9b82:	2407      	movs	r4, #7
    9b84:	e6e3      	b.n	994e <_TCPIP_DoInitialize+0xca>
    9b86:	bf00      	nop
    9b88:	2000ec10 	.word	0x2000ec10
    9b8c:	2000eae4 	.word	0x2000eae4
    9b90:	2000ee74 	.word	0x2000ee74
    9b94:	000094dc 	.word	0x000094dc
    9b98:	0000950c 	.word	0x0000950c
    9b9c:	0000954c 	.word	0x0000954c
    9ba0:	00009580 	.word	0x00009580
    9ba4:	000095c4 	.word	0x000095c4
    9ba8:	00009604 	.word	0x00009604
    9bac:	00009648 	.word	0x00009648
    9bb0:	2000ee70 	.word	0x2000ee70
    9bb4:	00024244 	.word	0x00024244
    9bb8:	0000968c 	.word	0x0000968c
    9bbc:	2000d9a4 	.word	0x2000d9a4
    9bc0:	2000ee68 	.word	0x2000ee68
    9bc4:	2000ed2c 	.word	0x2000ed2c
    9bc8:	2000e654 	.word	0x2000e654
    9bcc:	00009694 	.word	0x00009694
            tcpip_stack_ctrl_data.powerMode = powerMode;
    9bd0:	7770      	strb	r0, [r6, #29]
            tcpip_stack_ctrl_data.pNetIf = pIf;
    9bd2:	6174      	str	r4, [r6, #20]
            tcpip_stack_ctrl_data.netIx = netIx;
    9bd4:	61b7      	str	r7, [r6, #24]
            if(!TCPIP_STACK_BringNetUp(&tcpip_stack_ctrl_data, pUsrConfig, pModConfig, nModules))
    9bd6:	465b      	mov	r3, fp
    9bd8:	464a      	mov	r2, r9
    9bda:	4629      	mov	r1, r5
    9bdc:	4630      	mov	r0, r6
    9bde:	f005 fa5f 	bl	f0a0 <TCPIP_STACK_BringNetUp>
    9be2:	b358      	cbz	r0, 9c3c <_TCPIP_DoInitialize+0x3b8>
        for(netIx = 0, pIf = tcpipNetIf; netIx < nNets; netIx++, pIf++, pUsrConfig++)
    9be4:	3701      	adds	r7, #1
    9be6:	346c      	adds	r4, #108	; 0x6c
    9be8:	3538      	adds	r5, #56	; 0x38
    9bea:	45b8      	cmp	r8, r7
    9bec:	d028      	beq.n	9c40 <_TCPIP_DoInitialize+0x3bc>
            powerMode = TCPIP_Helper_StringToPowerMode(pUsrConfig->powerMode);
    9bee:	6a28      	ldr	r0, [r5, #32]
    9bf0:	f017 fb5c 	bl	212ac <TCPIP_Helper_StringToPowerMode>
            if(powerMode != TCPIP_MAC_POWER_FULL && powerMode != TCPIP_MAC_POWER_DOWN)
    9bf4:	f000 03fd 	and.w	r3, r0, #253	; 0xfd
    9bf8:	2b01      	cmp	r3, #1
    9bfa:	d0e9      	beq.n	9bd0 <_TCPIP_DoInitialize+0x34c>
    9bfc:	4680      	mov	r8, r0
                SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Power Mode initialization fail: %d\r\n", powerMode);
    9bfe:	f01a fb3f 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    9c02:	2800      	cmp	r0, #0
    9c04:	d1b7      	bne.n	9b76 <_TCPIP_DoInitialize+0x2f2>
                initFail = 7;
    9c06:	2407      	movs	r4, #7
    9c08:	e6a1      	b.n	994e <_TCPIP_DoInitialize+0xca>
    SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Initialization failed %d - Aborting! \r\n", initFail);
    9c0a:	f01a fb33 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    9c0e:	4622      	mov	r2, r4
    9c10:	4921      	ldr	r1, [pc, #132]	; (9c98 <_TCPIP_DoInitialize+0x414>)
    9c12:	f012 fd43 	bl	1c69c <SYS_CONSOLE_Print>
    9c16:	e69f      	b.n	9958 <_TCPIP_DoInitialize+0xd4>
        return false;
    9c18:	2300      	movs	r3, #0
    9c1a:	9303      	str	r3, [sp, #12]
}
    9c1c:	9803      	ldr	r0, [sp, #12]
    9c1e:	b00b      	add	sp, #44	; 0x2c
    9c20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return false;
    9c24:	2300      	movs	r3, #0
    9c26:	9303      	str	r3, [sp, #12]
    9c28:	e7f8      	b.n	9c1c <_TCPIP_DoInitialize+0x398>
    9c2a:	2300      	movs	r3, #0
    9c2c:	9303      	str	r3, [sp, #12]
    9c2e:	e7f5      	b.n	9c1c <_TCPIP_DoInitialize+0x398>
    9c30:	2300      	movs	r3, #0
    9c32:	9303      	str	r3, [sp, #12]
    9c34:	e7f2      	b.n	9c1c <_TCPIP_DoInitialize+0x398>
    9c36:	2300      	movs	r3, #0
    9c38:	9303      	str	r3, [sp, #12]
    9c3a:	e7ef      	b.n	9c1c <_TCPIP_DoInitialize+0x398>
                initFail = 8;
    9c3c:	2408      	movs	r4, #8
    if(!initFail)
    9c3e:	e686      	b.n	994e <_TCPIP_DoInitialize+0xca>
}
#define TCPIP_HEAP_MaxSize(h) TCPIP_HEAP_MaxSizeInline(h)

static __inline__ size_t __attribute__((always_inline)) TCPIP_HEAP_FreeSizeInline(TCPIP_STACK_HEAP_HANDLE h)
{
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_FreeSize)(h);
    9c40:	9805      	ldr	r0, [sp, #20]
    9c42:	6983      	ldr	r3, [r0, #24]
    9c44:	4798      	blx	r3
    9c46:	4604      	mov	r4, r0
        if(heapLeft < TCPIP_STACK_DRAM_RUN_LIMIT)
    9c48:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
    9c4c:	d2e6      	bcs.n	9c1c <_TCPIP_DoInitialize+0x398>
            SYS_ERROR_PRINT(SYS_ERROR_WARNING, TCPIP_STACK_HDR_MESSAGE "Dynamic memory is low: %lu\r\n", heapLeft);
    9c4e:	f01a fb17 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    9c52:	2801      	cmp	r0, #1
    9c54:	d9e2      	bls.n	9c1c <_TCPIP_DoInitialize+0x398>
    9c56:	f01a fb0d 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    9c5a:	4622      	mov	r2, r4
    9c5c:	490f      	ldr	r1, [pc, #60]	; (9c9c <_TCPIP_DoInitialize+0x418>)
    9c5e:	f012 fd1d 	bl	1c69c <SYS_CONSOLE_Print>
    9c62:	e7db      	b.n	9c1c <_TCPIP_DoInitialize+0x398>
        if(pModConfig->moduleId == moduleId)
    9c64:	464b      	mov	r3, r9
    9c66:	e640      	b.n	98ea <_TCPIP_DoInitialize+0x66>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Heap creation failed, type: %d\r\n", heapData ? heapData->heapType : TCPIP_STACK_HEAP_TYPE_NONE);
    9c68:	f01a fb04 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    9c6c:	e688      	b.n	9980 <_TCPIP_DoInitialize+0xfc>
    9c6e:	f01a fb07 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    9c72:	2800      	cmp	r0, #0
    9c74:	d1f8      	bne.n	9c68 <_TCPIP_DoInitialize+0x3e4>
            initFail = 1;
    9c76:	2401      	movs	r4, #1
    9c78:	e669      	b.n	994e <_TCPIP_DoInitialize+0xca>
        for(netIx = 0, pIf = tcpipNetIf; netIx < nNets; netIx++, pIf++)
    9c7a:	4b09      	ldr	r3, [pc, #36]	; (9ca0 <_TCPIP_DoInitialize+0x41c>)
    9c7c:	f8d3 e000 	ldr.w	lr, [r3]
        if(tcpip_stack_ctrl_data.nAliases != 0)
    9c80:	4b08      	ldr	r3, [pc, #32]	; (9ca4 <_TCPIP_DoInitialize+0x420>)
    9c82:	685b      	ldr	r3, [r3, #4]
    9c84:	2b00      	cmp	r3, #0
    9c86:	f43f af23 	beq.w	9ad0 <_TCPIP_DoInitialize+0x24c>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration: Aliases not supported: %d\r\n", tcpip_stack_ctrl_data.nAliases);
    9c8a:	f01a faf9 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    9c8e:	2800      	cmp	r0, #0
    9c90:	f47f aef2 	bne.w	9a78 <_TCPIP_DoInitialize+0x1f4>
            initFail = 5;
    9c94:	2405      	movs	r4, #5
    9c96:	e65a      	b.n	994e <_TCPIP_DoInitialize+0xca>
    9c98:	000096f4 	.word	0x000096f4
    9c9c:	000096c8 	.word	0x000096c8
    9ca0:	2000ee74 	.word	0x2000ee74
    9ca4:	2000eae4 	.word	0x2000eae4

Disassembly of section .text.SYS_CMD_Tasks%228:

00009ca8 <SYS_CMD_Tasks>:

}

// Maintains the Command Processor System Service's internal state machine.
bool SYS_CMD_Tasks(void)
{
    9ca8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9cac:	b0a3      	sub	sp, #140	; 0x8c
    SYS_CMD_IO_DCPT* pCmdIO;
    for(pCmdIO = cmdIODevList.head; pCmdIO != 0; pCmdIO = pCmdIO->next)
    9cae:	4bb4      	ldr	r3, [pc, #720]	; (9f80 <SYS_CMD_Tasks+0x2d8>)
    9cb0:	f8d3 b000 	ldr.w	fp, [r3]
    9cb4:	f1bb 0f00 	cmp.w	fp, #0
    9cb8:	f000 81f9 	beq.w	a0ae <SYS_CMD_Tasks+0x406>
        if(pCmdIO->seqChars == VT100_DETECT_SEQ_SIZE)
        {   // detect the exact escape sequence
            pCmdIO->seqBuff[pCmdIO->seqChars] = 0;
            pKeyDcpt = keySeqTbl;
            pFoundSeq = 0;
            for(ix = 0; ix < sizeof(keySeqTbl) / sizeof(*keySeqTbl); ix++, pKeyDcpt++)
    9cbc:	465e      	mov	r6, fp
    9cbe:	e0be      	b.n	9e3e <SYS_CMD_Tasks+0x196>
            pCmdIO->seqBuff[pCmdIO->seqChars] = 0;
    9cc0:	2300      	movs	r3, #0
    9cc2:	7573      	strb	r3, [r6, #21]
            pKeyDcpt = keySeqTbl;
    9cc4:	4daf      	ldr	r5, [pc, #700]	; (9f84 <SYS_CMD_Tasks+0x2dc>)
            {
                if(strncmp(pCmdIO->seqBuff, pKeyDcpt->keyCode, VT100_DETECT_SEQ_SIZE) == 0)
    9cc6:	f106 0812 	add.w	r8, r6, #18
    9cca:	2703      	movs	r7, #3
    9ccc:	463a      	mov	r2, r7
    9cce:	6829      	ldr	r1, [r5, #0]
    9cd0:	4640      	mov	r0, r8
    9cd2:	f018 fd6f 	bl	227b4 <strncmp>
    9cd6:	2800      	cmp	r0, #0
    9cd8:	f000 81e7 	beq.w	a0aa <SYS_CMD_Tasks+0x402>
            for(ix = 0; ix < sizeof(keySeqTbl) / sizeof(*keySeqTbl); ix++, pKeyDcpt++)
    9cdc:	350c      	adds	r5, #12
    9cde:	4baa      	ldr	r3, [pc, #680]	; (9f88 <SYS_CMD_Tasks+0x2e0>)
    9ce0:	429d      	cmp	r5, r3
    9ce2:	d1f3      	bne.n	9ccc <SYS_CMD_Tasks+0x24>
                }
            }

            if(pFoundSeq == 0)
            {   // unknown escape sequence
                pCmdIO->seqChars = 0;
    9ce4:	2300      	movs	r3, #0
    9ce6:	8233      	strh	r3, [r6, #16]
                return;
    9ce8:	e0a5      	b.n	9e36 <SYS_CMD_Tasks+0x18e>
        }

        return;

    }
    else if((newCh == '\r') || (newCh == '\n'))
    9cea:	280d      	cmp	r0, #13
    9cec:	d03a      	beq.n	9d64 <SYS_CMD_Tasks+0xbc>
    9cee:	280a      	cmp	r0, #10
    9cf0:	d038      	beq.n	9d64 <SYS_CMD_Tasks+0xbc>
        pCmdIO->cmdPnt = pCmdIO->cmdEnd = pCmdIO->cmdBuff;

        ParseCmdBuffer(pCmdIO);
        (*pCmdApi->msg)(cmdIoParam, _promptStr);
    }
    else if(newCh == '\b')
    9cf2:	2808      	cmp	r0, #8
    9cf4:	f000 8166 	beq.w	9fc4 <SYS_CMD_Tasks+0x31c>
                (*pCmdApi->msg)(cmdIoParam, "\b\x1b[K");
                pCmdIO->cmdPnt--; pCmdIO->cmdEnd--;
            }
        }
    }
    else if(newCh == 0x7f)
    9cf8:	287f      	cmp	r0, #127	; 0x7f
    9cfa:	f000 819a 	beq.w	a032 <SYS_CMD_Tasks+0x38a>
            *pCmdIO->cmdEnd = '\0';
            sprintf(pCmdIO->ctrlBuff, "\x1b[K%s\x1b[%dD", pCmdIO->cmdPnt, len);
            (*pCmdApi->msg)(cmdIoParam, pCmdIO->ctrlBuff);
        }
    }
    else if(newCh == 0x1b)
    9cfe:	281b      	cmp	r0, #27
    9d00:	f000 81ba 	beq.w	a078 <SYS_CMD_Tasks+0x3d0>
    {   // start escape sequence... wait for complete sequence
        pCmdIO->seqBuff[0] = newCh;
        pCmdIO->seqChars = 1;
    }
    else if(pCmdIO->cmdEnd - pCmdIO->cmdBuff < sizeof(pCmdIO->cmdBuff) - 1)
    9d04:	69f2      	ldr	r2, [r6, #28]
    9d06:	f106 0520 	add.w	r5, r6, #32
    9d0a:	1b53      	subs	r3, r2, r5
    9d0c:	2b4f      	cmp	r3, #79	; 0x4f
    9d0e:	f200 81bc 	bhi.w	a08a <SYS_CMD_Tasks+0x3e2>
    {   // valid char; insert and echo it back
        int n_chars = pCmdIO->cmdEnd - pCmdIO->cmdPnt;  // existent chars
    9d12:	69b3      	ldr	r3, [r6, #24]
        if(n_chars != 0)
    9d14:	1ad3      	subs	r3, r2, r3
    9d16:	f000 81b4 	beq.w	a082 <SYS_CMD_Tasks+0x3da>
        {   // move the existing chars to the right, for insertion...
            char* pSrc = pCmdIO->cmdEnd - 1;
            char* pDst = pCmdIO->cmdEnd;
            for(ix = 0; ix < n_chars; ix++)
    9d1a:	2b00      	cmp	r3, #0
    9d1c:	dd05      	ble.n	9d2a <SYS_CMD_Tasks+0x82>
    9d1e:	1ad0      	subs	r0, r2, r3
            {
                *pDst-- = *pSrc--;
    9d20:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
    9d24:	7051      	strb	r1, [r2, #1]
            for(ix = 0; ix < n_chars; ix++)
    9d26:	4282      	cmp	r2, r0
    9d28:	d1fa      	bne.n	9d20 <SYS_CMD_Tasks+0x78>
            }
            pCmdIO->cmdEnd++;
    9d2a:	69f2      	ldr	r2, [r6, #28]
    9d2c:	1c51      	adds	r1, r2, #1
    9d2e:	61f1      	str	r1, [r6, #28]
            *pCmdIO->cmdEnd = '\0';
    9d30:	2100      	movs	r1, #0
    9d32:	7051      	strb	r1, [r2, #1]
            sprintf(pCmdIO->ctrlBuff + 1, "%s\x1b[%dD", pCmdIO->cmdPnt + 1, n_chars);
    9d34:	69b2      	ldr	r2, [r6, #24]
    9d36:	3201      	adds	r2, #1
    9d38:	4994      	ldr	r1, [pc, #592]	; (9f8c <SYS_CMD_Tasks+0x2e4>)
    9d3a:	f106 0072 	add.w	r0, r6, #114	; 0x72
    9d3e:	f015 fc8b 	bl	1f658 <siprintf>
        }
        else
        {
            pCmdIO->ctrlBuff[1] = 0;
        }
        pCmdIO->ctrlBuff[0] = newCh;
    9d42:	4631      	mov	r1, r6
    9d44:	f801 4f71 	strb.w	r4, [r1, #113]!

        (*pCmdApi->msg)(cmdIoParam, pCmdIO->ctrlBuff);
    9d48:	f8da 3000 	ldr.w	r3, [sl]
    9d4c:	4648      	mov	r0, r9
    9d4e:	4798      	blx	r3
        *pCmdIO->cmdPnt++ = newCh;
    9d50:	69b3      	ldr	r3, [r6, #24]
    9d52:	1c5a      	adds	r2, r3, #1
    9d54:	61b2      	str	r2, [r6, #24]
    9d56:	701c      	strb	r4, [r3, #0]
    return pN;
}

static void CmdAdjustPointers(SYS_CMD_IO_DCPT* pCmdIO)
{
    if(pCmdIO->cmdPnt > pCmdIO->cmdEnd)
    9d58:	69b3      	ldr	r3, [r6, #24]
    9d5a:	69f2      	ldr	r2, [r6, #28]
    9d5c:	4293      	cmp	r3, r2
    9d5e:	d96a      	bls.n	9e36 <SYS_CMD_Tasks+0x18e>
    {
        pCmdIO->cmdEnd = pCmdIO->cmdPnt;
    9d60:	61f3      	str	r3, [r6, #28]
    9d62:	e068      	b.n	9e36 <SYS_CMD_Tasks+0x18e>
        if(pCmdIO->cmdEnd ==  pCmdIO->cmdBuff)
    9d64:	f106 0320 	add.w	r3, r6, #32
    9d68:	461a      	mov	r2, r3
    9d6a:	9302      	str	r3, [sp, #8]
    9d6c:	69f3      	ldr	r3, [r6, #28]
    9d6e:	4293      	cmp	r3, r2
    9d70:	d01a      	beq.n	9da8 <SYS_CMD_Tasks+0x100>
        (*pCmdApi->msg)(cmdIoParam, LINE_TERM);
    9d72:	f8da 3000 	ldr.w	r3, [sl]
    9d76:	4986      	ldr	r1, [pc, #536]	; (9f90 <SYS_CMD_Tasks+0x2e8>)
    9d78:	4648      	mov	r0, r9
    9d7a:	4798      	blx	r3
        *pCmdIO->cmdEnd = 0;
    9d7c:	69f3      	ldr	r3, [r6, #28]
    9d7e:	2500      	movs	r5, #0
    9d80:	701d      	strb	r5, [r3, #0]
        pCmdIO->cmdPnt = pCmdIO->cmdEnd = pCmdIO->cmdBuff;
    9d82:	9c02      	ldr	r4, [sp, #8]
    9d84:	61f4      	str	r4, [r6, #28]
    9d86:	61b4      	str	r4, [r6, #24]
    char *argv[MAX_CMD_ARGS] = {0};
    9d88:	2220      	movs	r2, #32
    9d8a:	4629      	mov	r1, r5
    9d8c:	a805      	add	r0, sp, #20
    9d8e:	f01a f887 	bl	23ea0 <memset>
    const void* cmdIoParam = pCmdIO->devNode.cmdIoParam;
    9d92:	6873      	ldr	r3, [r6, #4]
    9d94:	9303      	str	r3, [sp, #12]
    strncpy(saveCmd, pCmdIO->cmdBuff, sizeof(saveCmd));     // make a copy of the command
    9d96:	2251      	movs	r2, #81	; 0x51
    9d98:	4621      	mov	r1, r4
    9d9a:	a80d      	add	r0, sp, #52	; 0x34
    9d9c:	f018 fb88 	bl	224b0 <strncpy>
    9da0:	ac0d      	add	r4, sp, #52	; 0x34
            *qStart = 0;
    9da2:	46ab      	mov	fp, r5
            str = 0;
    9da4:	9501      	str	r5, [sp, #4]
    9da6:	e01e      	b.n	9de6 <SYS_CMD_Tasks+0x13e>
            (*pCmdApi->msg)(cmdIoParam, LINE_TERM _promptStr);
    9da8:	f8da 3000 	ldr.w	r3, [sl]
    9dac:	4979      	ldr	r1, [pc, #484]	; (9f94 <SYS_CMD_Tasks+0x2ec>)
    9dae:	4648      	mov	r0, r9
    9db0:	4798      	blx	r3
            return;
    9db2:	e040      	b.n	9e36 <SYS_CMD_Tasks+0x18e>
        if(qStart == 0)
    9db4:	b397      	cbz	r7, 9e1c <SYS_CMD_Tasks+0x174>
        qStart++;
    9db6:	3701      	adds	r7, #1
        qEnd = strchr(qStart, '"');
    9db8:	2122      	movs	r1, #34	; 0x22
    9dba:	4638      	mov	r0, r7
    9dbc:	f019 fbab 	bl	23516 <strchr>
        if(qEnd == 0 || qEnd - qStart == 0)
    9dc0:	4604      	mov	r4, r0
    9dc2:	2800      	cmp	r0, #0
    9dc4:	f000 80f8 	beq.w	9fb8 <SYS_CMD_Tasks+0x310>
    9dc8:	4287      	cmp	r7, r0
    9dca:	f000 80f5 	beq.w	9fb8 <SYS_CMD_Tasks+0x310>
        *qEnd = 0;
    9dce:	f880 b000 	strb.w	fp, [r0]
        if(nArgs < argvSize)
    9dd2:	2d07      	cmp	r5, #7
    9dd4:	d804      	bhi.n	9de0 <SYS_CMD_Tasks+0x138>
            argv[nArgs] = qStart;
    9dd6:	ab22      	add	r3, sp, #136	; 0x88
    9dd8:	eb03 0385 	add.w	r3, r3, r5, lsl #2
    9ddc:	f843 7c74 	str.w	r7, [r3, #-116]
        nArgs++;
    9de0:	3501      	adds	r5, #1
    while(str)
    9de2:	3401      	adds	r4, #1
    9de4:	d01a      	beq.n	9e1c <SYS_CMD_Tasks+0x174>
        qStart = strchr(str, '"');
    9de6:	2122      	movs	r1, #34	; 0x22
    9de8:	4620      	mov	r0, r4
    9dea:	f019 fb94 	bl	23516 <strchr>
        if(qStart != 0)
    9dee:	4607      	mov	r7, r0
    9df0:	b108      	cbz	r0, 9df6 <SYS_CMD_Tasks+0x14e>
            *qStart = 0;
    9df2:	f880 b000 	strb.w	fp, [r0]
    9df6:	ab05      	add	r3, sp, #20
    9df8:	eb03 0885 	add.w	r8, r3, r5, lsl #2
    9dfc:	4620      	mov	r0, r4
        while((pTkn = strtok(str, " \t,")) != 0)
    9dfe:	4966      	ldr	r1, [pc, #408]	; (9f98 <SYS_CMD_Tasks+0x2f0>)
    9e00:	f014 f904 	bl	1e00c <strtok>
    9e04:	4603      	mov	r3, r0
    9e06:	2800      	cmp	r0, #0
    9e08:	d0d4      	beq.n	9db4 <SYS_CMD_Tasks+0x10c>
            if(nArgs < argvSize)
    9e0a:	2d07      	cmp	r5, #7
                argv[nArgs] = pTkn;
    9e0c:	bf98      	it	ls
    9e0e:	f8c8 3000 	strls.w	r3, [r8]
            nArgs++;
    9e12:	3501      	adds	r5, #1
    9e14:	f108 0804 	add.w	r8, r8, #4
            str = 0;
    9e18:	9801      	ldr	r0, [sp, #4]
    9e1a:	e7f0      	b.n	9dfe <SYS_CMD_Tasks+0x156>
    if(argc > MAX_CMD_ARGS)
    9e1c:	2d08      	cmp	r5, #8
    9e1e:	dd3d      	ble.n	9e9c <SYS_CMD_Tasks+0x1f4>
        (*pCmdIO->devNode.pCmdApi->print)(cmdIoParam, "\n\r Too many arguments. Maximum args supported: %d!\r\n", MAX_CMD_ARGS);
    9e20:	6833      	ldr	r3, [r6, #0]
    9e22:	685b      	ldr	r3, [r3, #4]
    9e24:	2208      	movs	r2, #8
    9e26:	495d      	ldr	r1, [pc, #372]	; (9f9c <SYS_CMD_Tasks+0x2f4>)
    9e28:	9803      	ldr	r0, [sp, #12]
    9e2a:	4798      	blx	r3
        (*pCmdApi->msg)(cmdIoParam, _promptStr);
    9e2c:	f8da 3000 	ldr.w	r3, [sl]
    9e30:	495b      	ldr	r1, [pc, #364]	; (9fa0 <SYS_CMD_Tasks+0x2f8>)
    9e32:	4648      	mov	r0, r9
    9e34:	4798      	blx	r3
    for(pCmdIO = cmdIODevList.head; pCmdIO != 0; pCmdIO = pCmdIO->next)
    9e36:	68b6      	ldr	r6, [r6, #8]
    9e38:	2e00      	cmp	r6, #0
    9e3a:	f000 8138 	beq.w	a0ae <SYS_CMD_Tasks+0x406>
    const SYS_CMD_API* pCmdApi = pCmdIO->devNode.pCmdApi;
    9e3e:	f8d6 a000 	ldr.w	sl, [r6]
    const void* cmdIoParam = pCmdIO->devNode.cmdIoParam;
    9e42:	f8d6 9004 	ldr.w	r9, [r6, #4]
    if(!(*pCmdApi->isRdy)(cmdIoParam))
    9e46:	f8da 300c 	ldr.w	r3, [sl, #12]
    9e4a:	4648      	mov	r0, r9
    9e4c:	4798      	blx	r3
    9e4e:	2800      	cmp	r0, #0
    9e50:	d0f1      	beq.n	9e36 <SYS_CMD_Tasks+0x18e>
    newCh = (*pCmdApi->getc)(cmdIoParam); /* Read data from console. */
    9e52:	f8da 3010 	ldr.w	r3, [sl, #16]
    9e56:	4648      	mov	r0, r9
    9e58:	4798      	blx	r3
    9e5a:	4604      	mov	r4, r0
    if(pCmdIO->seqChars != 0)
    9e5c:	f9b6 3010 	ldrsh.w	r3, [r6, #16]
    9e60:	2b00      	cmp	r3, #0
    9e62:	f43f af42 	beq.w	9cea <SYS_CMD_Tasks+0x42>
        pCmdIO->seqBuff[pCmdIO->seqChars] = newCh;
    9e66:	18f2      	adds	r2, r6, r3
    9e68:	7490      	strb	r0, [r2, #18]
        pCmdIO->seqChars++;
    9e6a:	3301      	adds	r3, #1
    9e6c:	b21c      	sxth	r4, r3
    9e6e:	8234      	strh	r4, [r6, #16]
        if(pCmdIO->seqChars == VT100_DETECT_SEQ_SIZE)
    9e70:	2c03      	cmp	r4, #3
    9e72:	f43f af25 	beq.w	9cc0 <SYS_CMD_Tasks+0x18>
        if(pCmdIO->seqChars >= VT100_DETECT_SEQ_SIZE && pCmdIO->seqChars == pCmdIO->pSeqDcpt->keySize)
    9e76:	2c02      	cmp	r4, #2
    9e78:	dddd      	ble.n	9e36 <SYS_CMD_Tasks+0x18e>
    9e7a:	68f5      	ldr	r5, [r6, #12]
    9e7c:	68ab      	ldr	r3, [r5, #8]
    9e7e:	429c      	cmp	r4, r3
    9e80:	d1d9      	bne.n	9e36 <SYS_CMD_Tasks+0x18e>
            if(strcmp(pCmdIO->seqBuff, pCmdIO->pSeqDcpt->keyCode) == 0)
    9e82:	6829      	ldr	r1, [r5, #0]
    9e84:	f106 0012 	add.w	r0, r6, #18
    9e88:	f019 feb8 	bl	23bfc <strcmp>
    9e8c:	b918      	cbnz	r0, 9e96 <SYS_CMD_Tasks+0x1ee>
                (*pCmdIO->pSeqDcpt->keyFnc)(pCmdIO, pCmdIO->pSeqDcpt);
    9e8e:	686b      	ldr	r3, [r5, #4]
    9e90:	4629      	mov	r1, r5
    9e92:	4630      	mov	r0, r6
    9e94:	4798      	blx	r3
            pCmdIO->seqChars = 0;
    9e96:	2300      	movs	r3, #0
    9e98:	8233      	strh	r3, [r6, #16]
            return;
    9e9a:	e7cc      	b.n	9e36 <SYS_CMD_Tasks+0x18e>
    else if(argc == 0)
    9e9c:	b92d      	cbnz	r5, 9eaa <SYS_CMD_Tasks+0x202>
        (*pCmdIO->devNode.pCmdApi->msg)(cmdIoParam, " *** Command Processor: Please type in a command***" LINE_TERM);
    9e9e:	6833      	ldr	r3, [r6, #0]
    9ea0:	681b      	ldr	r3, [r3, #0]
    9ea2:	4940      	ldr	r1, [pc, #256]	; (9fa4 <SYS_CMD_Tasks+0x2fc>)
    9ea4:	9803      	ldr	r0, [sp, #12]
    9ea6:	4798      	blx	r3
    9ea8:	e7c0      	b.n	9e2c <SYS_CMD_Tasks+0x184>
        if(argc > 0)
    9eaa:	2d00      	cmp	r5, #0
    9eac:	f340 8084 	ble.w	9fb8 <SYS_CMD_Tasks+0x310>
    if(pL->head == pL->tail)
    9eb0:	f8d6 30cc 	ldr.w	r3, [r6, #204]	; 0xcc
    9eb4:	f8d6 40d0 	ldr.w	r4, [r6, #208]	; 0xd0
    9eb8:	42a3      	cmp	r3, r4
    9eba:	d02e      	beq.n	9f1a <SYS_CMD_Tasks+0x272>
        pL->tail = pN->prev;
    9ebc:	6862      	ldr	r2, [r4, #4]
    9ebe:	f8c6 20d0 	str.w	r2, [r6, #208]	; 0xd0
        pL->tail->next = pL->head;
    9ec2:	6013      	str	r3, [r2, #0]
        pL->head->prev = pL->tail;
    9ec4:	f8d6 30cc 	ldr.w	r3, [r6, #204]	; 0xcc
    9ec8:	f8d6 20d0 	ldr.w	r2, [r6, #208]	; 0xd0
    9ecc:	605a      	str	r2, [r3, #4]
            strncpy(pN->cmdBuff, pCmdIO->cmdBuff, sizeof(saveCmd)); // Need save non-parsed string
    9ece:	2251      	movs	r2, #81	; 0x51
    9ed0:	9902      	ldr	r1, [sp, #8]
    9ed2:	f104 0008 	add.w	r0, r4, #8
    9ed6:	f018 faeb 	bl	224b0 <strncpy>
    if(pL->head == 0)
    9eda:	f8d6 30cc 	ldr.w	r3, [r6, #204]	; 0xcc
    9ede:	b31b      	cbz	r3, 9f28 <SYS_CMD_Tasks+0x280>
        pN->next = pL->head;
    9ee0:	6023      	str	r3, [r4, #0]
        pN->prev = pL->tail;
    9ee2:	f8d6 30d0 	ldr.w	r3, [r6, #208]	; 0xd0
    9ee6:	6063      	str	r3, [r4, #4]
        pL->tail->next = pN;
    9ee8:	601c      	str	r4, [r3, #0]
        pL->head->prev = pN;
    9eea:	f8d6 30cc 	ldr.w	r3, [r6, #204]	; 0xcc
    9eee:	605c      	str	r4, [r3, #4]
        pL->head = pN;
    9ef0:	f8c6 40cc 	str.w	r4, [r6, #204]	; 0xcc
            pCmdIO->currHistN = 0;
    9ef4:	2300      	movs	r3, #0
    9ef6:	f8c6 30d4 	str.w	r3, [r6, #212]	; 0xd4
                if(!strcmp(argv[0], pDcpt->cmdStr))
    9efa:	9b05      	ldr	r3, [sp, #20]
    9efc:	9301      	str	r3, [sp, #4]
            for(ix = 0, pDcpt = _builtinCmdTbl; ix < sizeof(_builtinCmdTbl)/sizeof(*_builtinCmdTbl); ix++, pDcpt++)
    9efe:	4c2a      	ldr	r4, [pc, #168]	; (9fa8 <SYS_CMD_Tasks+0x300>)
                if(!strcmp(argv[0], pDcpt->cmdStr))
    9f00:	6821      	ldr	r1, [r4, #0]
    9f02:	9801      	ldr	r0, [sp, #4]
    9f04:	f019 fe7a 	bl	23bfc <strcmp>
    9f08:	b1a8      	cbz	r0, 9f36 <SYS_CMD_Tasks+0x28e>
            for(ix = 0, pDcpt = _builtinCmdTbl; ix < sizeof(_builtinCmdTbl)/sizeof(*_builtinCmdTbl); ix++, pDcpt++)
    9f0a:	340c      	adds	r4, #12
    9f0c:	4b27      	ldr	r3, [pc, #156]	; (9fac <SYS_CMD_Tasks+0x304>)
    9f0e:	429c      	cmp	r4, r3
    9f10:	d1f6      	bne.n	9f00 <SYS_CMD_Tasks+0x258>
    9f12:	f8df b0a0 	ldr.w	fp, [pc, #160]	; 9fb4 <SYS_CMD_Tasks+0x30c>
    9f16:	46a8      	mov	r8, r5
    9f18:	e01e      	b.n	9f58 <SYS_CMD_Tasks+0x2b0>
        pL->head = pL->tail = 0;
    9f1a:	2200      	movs	r2, #0
    9f1c:	f8c6 20d0 	str.w	r2, [r6, #208]	; 0xd0
    9f20:	f8c6 20cc 	str.w	r2, [r6, #204]	; 0xcc
        pN = pL->head;
    9f24:	461c      	mov	r4, r3
    9f26:	e7d2      	b.n	9ece <SYS_CMD_Tasks+0x226>
        pL->head = pL->tail = pN;
    9f28:	f8c6 40d0 	str.w	r4, [r6, #208]	; 0xd0
    9f2c:	f8c6 40cc 	str.w	r4, [r6, #204]	; 0xcc
        pN->next = pN->prev = pN;
    9f30:	6064      	str	r4, [r4, #4]
    9f32:	6024      	str	r4, [r4, #0]
    9f34:	e7de      	b.n	9ef4 <SYS_CMD_Tasks+0x24c>
                    (*pDcpt->cmdFnc)(&pCmdIO->devNode, argc, argv);     // call command handler
    9f36:	6863      	ldr	r3, [r4, #4]
    9f38:	aa05      	add	r2, sp, #20
    9f3a:	4629      	mov	r1, r5
    9f3c:	4630      	mov	r0, r6
    9f3e:	4798      	blx	r3
                    return;
    9f40:	e774      	b.n	9e2c <SYS_CMD_Tasks+0x184>
                        (*pDcpt->cmdFnc)(&pCmdIO->devNode, argc, argv);
    9f42:	6863      	ldr	r3, [r4, #4]
    9f44:	aa05      	add	r2, sp, #20
    9f46:	4641      	mov	r1, r8
    9f48:	4630      	mov	r0, r6
    9f4a:	4798      	blx	r3
                        return;
    9f4c:	e76e      	b.n	9e2c <SYS_CMD_Tasks+0x184>
    9f4e:	f10b 0b10 	add.w	fp, fp, #16
            for (grp_ix=0; grp_ix < MAX_CMD_GROUP; grp_ix++)
    9f52:	4b17      	ldr	r3, [pc, #92]	; (9fb0 <SYS_CMD_Tasks+0x308>)
    9f54:	459b      	cmp	fp, r3
    9f56:	d02f      	beq.n	9fb8 <SYS_CMD_Tasks+0x310>
                if (_usrCmdTbl[grp_ix].pCmd == 0)
    9f58:	f8db 4004 	ldr.w	r4, [fp, #4]
    9f5c:	2c00      	cmp	r4, #0
    9f5e:	d0f6      	beq.n	9f4e <SYS_CMD_Tasks+0x2a6>
                for(ix = 0, pDcpt = _usrCmdTbl[grp_ix].pCmd; ix < _usrCmdTbl[grp_ix].nCmds; ix++, pDcpt++)
    9f60:	f8db 5000 	ldr.w	r5, [fp]
    9f64:	2d00      	cmp	r5, #0
    9f66:	ddf2      	ble.n	9f4e <SYS_CMD_Tasks+0x2a6>
    9f68:	2700      	movs	r7, #0
                    if(!strcmp(argv[0], pDcpt->cmdStr))
    9f6a:	6821      	ldr	r1, [r4, #0]
    9f6c:	9801      	ldr	r0, [sp, #4]
    9f6e:	f019 fe45 	bl	23bfc <strcmp>
    9f72:	2800      	cmp	r0, #0
    9f74:	d0e5      	beq.n	9f42 <SYS_CMD_Tasks+0x29a>
                for(ix = 0, pDcpt = _usrCmdTbl[grp_ix].pCmd; ix < _usrCmdTbl[grp_ix].nCmds; ix++, pDcpt++)
    9f76:	3701      	adds	r7, #1
    9f78:	340c      	adds	r4, #12
    9f7a:	42af      	cmp	r7, r5
    9f7c:	d1f5      	bne.n	9f6a <SYS_CMD_Tasks+0x2c2>
    9f7e:	e7e6      	b.n	9f4e <SYS_CMD_Tasks+0x2a6>
    9f80:	2000ed8c 	.word	0x2000ed8c
    9f84:	0001ee78 	.word	0x0001ee78
    9f88:	0001eec0 	.word	0x0001eec0
    9f8c:	0000eb58 	.word	0x0000eb58
    9f90:	0000ea08 	.word	0x0000ea08
    9f94:	0000e99c 	.word	0x0000e99c
    9f98:	0000ea90 	.word	0x0000ea90
    9f9c:	0000ea94 	.word	0x0000ea94
    9fa0:	0000eb34 	.word	0x0000eb34
    9fa4:	0000eacc 	.word	0x0000eacc
    9fa8:	00022688 	.word	0x00022688
    9fac:	000226ac 	.word	0x000226ac
    9fb0:	2000e7e8 	.word	0x2000e7e8
    9fb4:	2000e768 	.word	0x2000e768
        (*pCmdIO->devNode.pCmdApi->msg)(cmdIoParam, " *** Command Processor: unknown command. ***\r\n");
    9fb8:	6833      	ldr	r3, [r6, #0]
    9fba:	681b      	ldr	r3, [r3, #0]
    9fbc:	493e      	ldr	r1, [pc, #248]	; (a0b8 <SYS_CMD_Tasks+0x410>)
    9fbe:	9803      	ldr	r0, [sp, #12]
    9fc0:	4798      	blx	r3
    9fc2:	e733      	b.n	9e2c <SYS_CMD_Tasks+0x184>
        if(pCmdIO->cmdPnt > pCmdIO->cmdBuff)
    9fc4:	69b1      	ldr	r1, [r6, #24]
    9fc6:	f106 0320 	add.w	r3, r6, #32
    9fca:	4299      	cmp	r1, r3
    9fcc:	f67f af33 	bls.w	9e36 <SYS_CMD_Tasks+0x18e>
            if(pCmdIO->cmdEnd > pCmdIO->cmdPnt)
    9fd0:	69f3      	ldr	r3, [r6, #28]
    9fd2:	4299      	cmp	r1, r3
    9fd4:	d221      	bcs.n	a01a <SYS_CMD_Tasks+0x372>
                char* pDst = pCmdIO->cmdPnt - 1;
    9fd6:	1e4a      	subs	r2, r1, #1
                len = pCmdIO->cmdEnd - pSrc;
    9fd8:	1a5b      	subs	r3, r3, r1
                for(ix = 0; ix < len; ix++)
    9fda:	2b00      	cmp	r3, #0
    9fdc:	dd07      	ble.n	9fee <SYS_CMD_Tasks+0x346>
    9fde:	1e58      	subs	r0, r3, #1
    9fe0:	4401      	add	r1, r0
                    *pDst++ = *pSrc++;
    9fe2:	f812 0f01 	ldrb.w	r0, [r2, #1]!
    9fe6:	f802 0c01 	strb.w	r0, [r2, #-1]
                for(ix = 0; ix < len; ix++)
    9fea:	428a      	cmp	r2, r1
    9fec:	d1f9      	bne.n	9fe2 <SYS_CMD_Tasks+0x33a>
                pCmdIO->cmdPnt--; pCmdIO->cmdEnd--;
    9fee:	69b2      	ldr	r2, [r6, #24]
    9ff0:	3a01      	subs	r2, #1
    9ff2:	61b2      	str	r2, [r6, #24]
    9ff4:	69f2      	ldr	r2, [r6, #28]
    9ff6:	1e51      	subs	r1, r2, #1
    9ff8:	61f1      	str	r1, [r6, #28]
                *pCmdIO->cmdEnd = '\0';
    9ffa:	2100      	movs	r1, #0
    9ffc:	f802 1c01 	strb.w	r1, [r2, #-1]
                sprintf(pCmdIO->ctrlBuff, "\b\x1b[K%s\x1b[%dD", pCmdIO->cmdPnt, len);
    a000:	f106 0471 	add.w	r4, r6, #113	; 0x71
    a004:	69b2      	ldr	r2, [r6, #24]
    a006:	492d      	ldr	r1, [pc, #180]	; (a0bc <SYS_CMD_Tasks+0x414>)
    a008:	4620      	mov	r0, r4
    a00a:	f015 fb25 	bl	1f658 <siprintf>
                (*pCmdApi->msg)(cmdIoParam, pCmdIO->ctrlBuff);
    a00e:	f8da 3000 	ldr.w	r3, [sl]
    a012:	4621      	mov	r1, r4
    a014:	4648      	mov	r0, r9
    a016:	4798      	blx	r3
    a018:	e70d      	b.n	9e36 <SYS_CMD_Tasks+0x18e>
                (*pCmdApi->msg)(cmdIoParam, "\b\x1b[K");
    a01a:	f8da 3000 	ldr.w	r3, [sl]
    a01e:	4928      	ldr	r1, [pc, #160]	; (a0c0 <SYS_CMD_Tasks+0x418>)
    a020:	4648      	mov	r0, r9
    a022:	4798      	blx	r3
                pCmdIO->cmdPnt--; pCmdIO->cmdEnd--;
    a024:	69b3      	ldr	r3, [r6, #24]
    a026:	3b01      	subs	r3, #1
    a028:	61b3      	str	r3, [r6, #24]
    a02a:	69f3      	ldr	r3, [r6, #28]
    a02c:	3b01      	subs	r3, #1
    a02e:	61f3      	str	r3, [r6, #28]
    a030:	e701      	b.n	9e36 <SYS_CMD_Tasks+0x18e>
        if(pCmdIO->cmdEnd > pCmdIO->cmdPnt)
    a032:	69f3      	ldr	r3, [r6, #28]
    a034:	69b2      	ldr	r2, [r6, #24]
    a036:	4293      	cmp	r3, r2
    a038:	f67f aefd 	bls.w	9e36 <SYS_CMD_Tasks+0x18e>
            char* pSrc = pCmdIO->cmdPnt + 1;
    a03c:	1c51      	adds	r1, r2, #1
            len = pCmdIO->cmdEnd - pSrc;
    a03e:	1a5b      	subs	r3, r3, r1
            for(ix = 0; ix < len; ix++)
    a040:	2b00      	cmp	r3, #0
    a042:	dd06      	ble.n	a052 <SYS_CMD_Tasks+0x3aa>
    a044:	18d0      	adds	r0, r2, r3
                *pDst++ = *pSrc++;
    a046:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    a04a:	f802 1c01 	strb.w	r1, [r2, #-1]
            for(ix = 0; ix < len; ix++)
    a04e:	4282      	cmp	r2, r0
    a050:	d1f9      	bne.n	a046 <SYS_CMD_Tasks+0x39e>
            pCmdIO->cmdEnd--;
    a052:	69f2      	ldr	r2, [r6, #28]
    a054:	1e51      	subs	r1, r2, #1
    a056:	61f1      	str	r1, [r6, #28]
            *pCmdIO->cmdEnd = '\0';
    a058:	2100      	movs	r1, #0
    a05a:	f802 1c01 	strb.w	r1, [r2, #-1]
            sprintf(pCmdIO->ctrlBuff, "\x1b[K%s\x1b[%dD", pCmdIO->cmdPnt, len);
    a05e:	f106 0471 	add.w	r4, r6, #113	; 0x71
    a062:	69b2      	ldr	r2, [r6, #24]
    a064:	4917      	ldr	r1, [pc, #92]	; (a0c4 <SYS_CMD_Tasks+0x41c>)
    a066:	4620      	mov	r0, r4
    a068:	f015 faf6 	bl	1f658 <siprintf>
            (*pCmdApi->msg)(cmdIoParam, pCmdIO->ctrlBuff);
    a06c:	f8da 3000 	ldr.w	r3, [sl]
    a070:	4621      	mov	r1, r4
    a072:	4648      	mov	r0, r9
    a074:	4798      	blx	r3
    a076:	e6de      	b.n	9e36 <SYS_CMD_Tasks+0x18e>
        pCmdIO->seqBuff[0] = newCh;
    a078:	231b      	movs	r3, #27
    a07a:	74b3      	strb	r3, [r6, #18]
        pCmdIO->seqChars = 1;
    a07c:	2301      	movs	r3, #1
    a07e:	8233      	strh	r3, [r6, #16]
    a080:	e6d9      	b.n	9e36 <SYS_CMD_Tasks+0x18e>
            pCmdIO->ctrlBuff[1] = 0;
    a082:	2300      	movs	r3, #0
    a084:	f886 3072 	strb.w	r3, [r6, #114]	; 0x72
    a088:	e65b      	b.n	9d42 <SYS_CMD_Tasks+0x9a>
        (*pCmdApi->msg)(cmdIoParam, " *** Command Processor buffer exceeded. Retry. ***" LINE_TERM);
    a08a:	4c0f      	ldr	r4, [pc, #60]	; (a0c8 <SYS_CMD_Tasks+0x420>)
    a08c:	f8da 3000 	ldr.w	r3, [sl]
    a090:	f504 71e6 	add.w	r1, r4, #460	; 0x1cc
    a094:	4648      	mov	r0, r9
    a096:	4798      	blx	r3
        pCmdIO->cmdPnt = pCmdIO->cmdEnd = pCmdIO->cmdBuff;
    a098:	61f5      	str	r5, [r6, #28]
    a09a:	61b5      	str	r5, [r6, #24]
        (*pCmdApi->msg)(cmdIoParam, _promptStr);
    a09c:	f8da 3000 	ldr.w	r3, [sl]
    a0a0:	f504 71d0 	add.w	r1, r4, #416	; 0x1a0
    a0a4:	4648      	mov	r0, r9
    a0a6:	4798      	blx	r3
    a0a8:	e6c5      	b.n	9e36 <SYS_CMD_Tasks+0x18e>
            pCmdIO->pSeqDcpt = pFoundSeq;
    a0aa:	60f5      	str	r5, [r6, #12]
        if(pCmdIO->seqChars >= VT100_DETECT_SEQ_SIZE && pCmdIO->seqChars == pCmdIO->pSeqDcpt->keySize)
    a0ac:	e6e5      	b.n	9e7a <SYS_CMD_Tasks+0x1d2>
}
    a0ae:	2001      	movs	r0, #1
    a0b0:	b023      	add	sp, #140	; 0x8c
    a0b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a0b6:	bf00      	nop
    a0b8:	0000eb04 	.word	0x0000eb04
    a0bc:	0000eb38 	.word	0x0000eb38
    a0c0:	0000eb44 	.word	0x0000eb44
    a0c4:	0000eb4c 	.word	0x0000eb4c
    a0c8:	0000e994 	.word	0x0000e994

Disassembly of section .text%229:

0000a0cc <__aeabi_dmul>:
    a0cc:	b570      	push	{r4, r5, r6, lr}
    a0ce:	f04f 0cff 	mov.w	ip, #255	; 0xff
    a0d2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    a0d6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    a0da:	bf1d      	ittte	ne
    a0dc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    a0e0:	ea94 0f0c 	teqne	r4, ip
    a0e4:	ea95 0f0c 	teqne	r5, ip
    a0e8:	f000 f8de 	bleq	a2a8 <__aeabi_dmul+0x1dc>
    a0ec:	442c      	add	r4, r5
    a0ee:	ea81 0603 	eor.w	r6, r1, r3
    a0f2:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
    a0f6:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
    a0fa:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
    a0fe:	bf18      	it	ne
    a100:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
    a104:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    a108:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    a10c:	d038      	beq.n	a180 <__aeabi_dmul+0xb4>
    a10e:	fba0 ce02 	umull	ip, lr, r0, r2
    a112:	f04f 0500 	mov.w	r5, #0
    a116:	fbe1 e502 	umlal	lr, r5, r1, r2
    a11a:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
    a11e:	fbe0 e503 	umlal	lr, r5, r0, r3
    a122:	f04f 0600 	mov.w	r6, #0
    a126:	fbe1 5603 	umlal	r5, r6, r1, r3
    a12a:	f09c 0f00 	teq	ip, #0
    a12e:	bf18      	it	ne
    a130:	f04e 0e01 	orrne.w	lr, lr, #1
    a134:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
    a138:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
    a13c:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
    a140:	d204      	bcs.n	a14c <__aeabi_dmul+0x80>
    a142:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
    a146:	416d      	adcs	r5, r5
    a148:	eb46 0606 	adc.w	r6, r6, r6
    a14c:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
    a150:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
    a154:	ea4f 20c5 	mov.w	r0, r5, lsl #11
    a158:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
    a15c:	ea4f 2ece 	mov.w	lr, lr, lsl #11
    a160:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    a164:	bf88      	it	hi
    a166:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    a16a:	d81e      	bhi.n	a1aa <__aeabi_dmul+0xde>
    a16c:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
    a170:	bf08      	it	eq
    a172:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
    a176:	f150 0000 	adcs.w	r0, r0, #0
    a17a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    a17e:	bd70      	pop	{r4, r5, r6, pc}
    a180:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
    a184:	ea46 0101 	orr.w	r1, r6, r1
    a188:	ea40 0002 	orr.w	r0, r0, r2
    a18c:	ea81 0103 	eor.w	r1, r1, r3
    a190:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
    a194:	bfc2      	ittt	gt
    a196:	ebd4 050c 	rsbsgt	r5, r4, ip
    a19a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    a19e:	bd70      	popgt	{r4, r5, r6, pc}
    a1a0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    a1a4:	f04f 0e00 	mov.w	lr, #0
    a1a8:	3c01      	subs	r4, #1
    a1aa:	f300 80ab 	bgt.w	a304 <__aeabi_dmul+0x238>
    a1ae:	f114 0f36 	cmn.w	r4, #54	; 0x36
    a1b2:	bfde      	ittt	le
    a1b4:	2000      	movle	r0, #0
    a1b6:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
    a1ba:	bd70      	pople	{r4, r5, r6, pc}
    a1bc:	f1c4 0400 	rsb	r4, r4, #0
    a1c0:	3c20      	subs	r4, #32
    a1c2:	da35      	bge.n	a230 <__aeabi_dmul+0x164>
    a1c4:	340c      	adds	r4, #12
    a1c6:	dc1b      	bgt.n	a200 <__aeabi_dmul+0x134>
    a1c8:	f104 0414 	add.w	r4, r4, #20
    a1cc:	f1c4 0520 	rsb	r5, r4, #32
    a1d0:	fa00 f305 	lsl.w	r3, r0, r5
    a1d4:	fa20 f004 	lsr.w	r0, r0, r4
    a1d8:	fa01 f205 	lsl.w	r2, r1, r5
    a1dc:	ea40 0002 	orr.w	r0, r0, r2
    a1e0:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
    a1e4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    a1e8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    a1ec:	fa21 f604 	lsr.w	r6, r1, r4
    a1f0:	eb42 0106 	adc.w	r1, r2, r6
    a1f4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    a1f8:	bf08      	it	eq
    a1fa:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    a1fe:	bd70      	pop	{r4, r5, r6, pc}
    a200:	f1c4 040c 	rsb	r4, r4, #12
    a204:	f1c4 0520 	rsb	r5, r4, #32
    a208:	fa00 f304 	lsl.w	r3, r0, r4
    a20c:	fa20 f005 	lsr.w	r0, r0, r5
    a210:	fa01 f204 	lsl.w	r2, r1, r4
    a214:	ea40 0002 	orr.w	r0, r0, r2
    a218:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    a21c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    a220:	f141 0100 	adc.w	r1, r1, #0
    a224:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    a228:	bf08      	it	eq
    a22a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    a22e:	bd70      	pop	{r4, r5, r6, pc}
    a230:	f1c4 0520 	rsb	r5, r4, #32
    a234:	fa00 f205 	lsl.w	r2, r0, r5
    a238:	ea4e 0e02 	orr.w	lr, lr, r2
    a23c:	fa20 f304 	lsr.w	r3, r0, r4
    a240:	fa01 f205 	lsl.w	r2, r1, r5
    a244:	ea43 0302 	orr.w	r3, r3, r2
    a248:	fa21 f004 	lsr.w	r0, r1, r4
    a24c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    a250:	fa21 f204 	lsr.w	r2, r1, r4
    a254:	ea20 0002 	bic.w	r0, r0, r2
    a258:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
    a25c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    a260:	bf08      	it	eq
    a262:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    a266:	bd70      	pop	{r4, r5, r6, pc}
    a268:	f094 0f00 	teq	r4, #0
    a26c:	d10f      	bne.n	a28e <__aeabi_dmul+0x1c2>
    a26e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
    a272:	0040      	lsls	r0, r0, #1
    a274:	eb41 0101 	adc.w	r1, r1, r1
    a278:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    a27c:	bf08      	it	eq
    a27e:	3c01      	subeq	r4, #1
    a280:	d0f7      	beq.n	a272 <__aeabi_dmul+0x1a6>
    a282:	ea41 0106 	orr.w	r1, r1, r6
    a286:	f095 0f00 	teq	r5, #0
    a28a:	bf18      	it	ne
    a28c:	4770      	bxne	lr
    a28e:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
    a292:	0052      	lsls	r2, r2, #1
    a294:	eb43 0303 	adc.w	r3, r3, r3
    a298:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    a29c:	bf08      	it	eq
    a29e:	3d01      	subeq	r5, #1
    a2a0:	d0f7      	beq.n	a292 <__aeabi_dmul+0x1c6>
    a2a2:	ea43 0306 	orr.w	r3, r3, r6
    a2a6:	4770      	bx	lr
    a2a8:	ea94 0f0c 	teq	r4, ip
    a2ac:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    a2b0:	bf18      	it	ne
    a2b2:	ea95 0f0c 	teqne	r5, ip
    a2b6:	d00c      	beq.n	a2d2 <__aeabi_dmul+0x206>
    a2b8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    a2bc:	bf18      	it	ne
    a2be:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    a2c2:	d1d1      	bne.n	a268 <__aeabi_dmul+0x19c>
    a2c4:	ea81 0103 	eor.w	r1, r1, r3
    a2c8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    a2cc:	f04f 0000 	mov.w	r0, #0
    a2d0:	bd70      	pop	{r4, r5, r6, pc}
    a2d2:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    a2d6:	bf06      	itte	eq
    a2d8:	4610      	moveq	r0, r2
    a2da:	4619      	moveq	r1, r3
    a2dc:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    a2e0:	d019      	beq.n	a316 <__aeabi_dmul+0x24a>
    a2e2:	ea94 0f0c 	teq	r4, ip
    a2e6:	d102      	bne.n	a2ee <__aeabi_dmul+0x222>
    a2e8:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
    a2ec:	d113      	bne.n	a316 <__aeabi_dmul+0x24a>
    a2ee:	ea95 0f0c 	teq	r5, ip
    a2f2:	d105      	bne.n	a300 <__aeabi_dmul+0x234>
    a2f4:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
    a2f8:	bf1c      	itt	ne
    a2fa:	4610      	movne	r0, r2
    a2fc:	4619      	movne	r1, r3
    a2fe:	d10a      	bne.n	a316 <__aeabi_dmul+0x24a>
    a300:	ea81 0103 	eor.w	r1, r1, r3
    a304:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    a308:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    a30c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    a310:	f04f 0000 	mov.w	r0, #0
    a314:	bd70      	pop	{r4, r5, r6, pc}
    a316:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    a31a:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
    a31e:	bd70      	pop	{r4, r5, r6, pc}

0000a320 <__aeabi_ddiv>:
    a320:	b570      	push	{r4, r5, r6, lr}
    a322:	f04f 0cff 	mov.w	ip, #255	; 0xff
    a326:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    a32a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    a32e:	bf1d      	ittte	ne
    a330:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    a334:	ea94 0f0c 	teqne	r4, ip
    a338:	ea95 0f0c 	teqne	r5, ip
    a33c:	f000 f8a7 	bleq	a48e <__aeabi_ddiv+0x16e>
    a340:	eba4 0405 	sub.w	r4, r4, r5
    a344:	ea81 0e03 	eor.w	lr, r1, r3
    a348:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    a34c:	ea4f 3101 	mov.w	r1, r1, lsl #12
    a350:	f000 8088 	beq.w	a464 <__aeabi_ddiv+0x144>
    a354:	ea4f 3303 	mov.w	r3, r3, lsl #12
    a358:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
    a35c:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
    a360:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    a364:	ea4f 2202 	mov.w	r2, r2, lsl #8
    a368:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
    a36c:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
    a370:	ea4f 2600 	mov.w	r6, r0, lsl #8
    a374:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
    a378:	429d      	cmp	r5, r3
    a37a:	bf08      	it	eq
    a37c:	4296      	cmpeq	r6, r2
    a37e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
    a382:	f504 7440 	add.w	r4, r4, #768	; 0x300
    a386:	d202      	bcs.n	a38e <__aeabi_ddiv+0x6e>
    a388:	085b      	lsrs	r3, r3, #1
    a38a:	ea4f 0232 	mov.w	r2, r2, rrx
    a38e:	1ab6      	subs	r6, r6, r2
    a390:	eb65 0503 	sbc.w	r5, r5, r3
    a394:	085b      	lsrs	r3, r3, #1
    a396:	ea4f 0232 	mov.w	r2, r2, rrx
    a39a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    a39e:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
    a3a2:	ebb6 0e02 	subs.w	lr, r6, r2
    a3a6:	eb75 0e03 	sbcs.w	lr, r5, r3
    a3aa:	bf22      	ittt	cs
    a3ac:	1ab6      	subcs	r6, r6, r2
    a3ae:	4675      	movcs	r5, lr
    a3b0:	ea40 000c 	orrcs.w	r0, r0, ip
    a3b4:	085b      	lsrs	r3, r3, #1
    a3b6:	ea4f 0232 	mov.w	r2, r2, rrx
    a3ba:	ebb6 0e02 	subs.w	lr, r6, r2
    a3be:	eb75 0e03 	sbcs.w	lr, r5, r3
    a3c2:	bf22      	ittt	cs
    a3c4:	1ab6      	subcs	r6, r6, r2
    a3c6:	4675      	movcs	r5, lr
    a3c8:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    a3cc:	085b      	lsrs	r3, r3, #1
    a3ce:	ea4f 0232 	mov.w	r2, r2, rrx
    a3d2:	ebb6 0e02 	subs.w	lr, r6, r2
    a3d6:	eb75 0e03 	sbcs.w	lr, r5, r3
    a3da:	bf22      	ittt	cs
    a3dc:	1ab6      	subcs	r6, r6, r2
    a3de:	4675      	movcs	r5, lr
    a3e0:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    a3e4:	085b      	lsrs	r3, r3, #1
    a3e6:	ea4f 0232 	mov.w	r2, r2, rrx
    a3ea:	ebb6 0e02 	subs.w	lr, r6, r2
    a3ee:	eb75 0e03 	sbcs.w	lr, r5, r3
    a3f2:	bf22      	ittt	cs
    a3f4:	1ab6      	subcs	r6, r6, r2
    a3f6:	4675      	movcs	r5, lr
    a3f8:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    a3fc:	ea55 0e06 	orrs.w	lr, r5, r6
    a400:	d018      	beq.n	a434 <__aeabi_ddiv+0x114>
    a402:	ea4f 1505 	mov.w	r5, r5, lsl #4
    a406:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
    a40a:	ea4f 1606 	mov.w	r6, r6, lsl #4
    a40e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    a412:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
    a416:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    a41a:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
    a41e:	d1c0      	bne.n	a3a2 <__aeabi_ddiv+0x82>
    a420:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    a424:	d10b      	bne.n	a43e <__aeabi_ddiv+0x11e>
    a426:	ea41 0100 	orr.w	r1, r1, r0
    a42a:	f04f 0000 	mov.w	r0, #0
    a42e:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
    a432:	e7b6      	b.n	a3a2 <__aeabi_ddiv+0x82>
    a434:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    a438:	bf04      	itt	eq
    a43a:	4301      	orreq	r1, r0
    a43c:	2000      	moveq	r0, #0
    a43e:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    a442:	bf88      	it	hi
    a444:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    a448:	f63f aeaf 	bhi.w	a1aa <__aeabi_dmul+0xde>
    a44c:	ebb5 0c03 	subs.w	ip, r5, r3
    a450:	bf04      	itt	eq
    a452:	ebb6 0c02 	subseq.w	ip, r6, r2
    a456:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    a45a:	f150 0000 	adcs.w	r0, r0, #0
    a45e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    a462:	bd70      	pop	{r4, r5, r6, pc}
    a464:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
    a468:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
    a46c:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
    a470:	bfc2      	ittt	gt
    a472:	ebd4 050c 	rsbsgt	r5, r4, ip
    a476:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    a47a:	bd70      	popgt	{r4, r5, r6, pc}
    a47c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    a480:	f04f 0e00 	mov.w	lr, #0
    a484:	3c01      	subs	r4, #1
    a486:	e690      	b.n	a1aa <__aeabi_dmul+0xde>
    a488:	ea45 0e06 	orr.w	lr, r5, r6
    a48c:	e68d      	b.n	a1aa <__aeabi_dmul+0xde>
    a48e:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    a492:	ea94 0f0c 	teq	r4, ip
    a496:	bf08      	it	eq
    a498:	ea95 0f0c 	teqeq	r5, ip
    a49c:	f43f af3b 	beq.w	a316 <__aeabi_dmul+0x24a>
    a4a0:	ea94 0f0c 	teq	r4, ip
    a4a4:	d10a      	bne.n	a4bc <__aeabi_ddiv+0x19c>
    a4a6:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    a4aa:	f47f af34 	bne.w	a316 <__aeabi_dmul+0x24a>
    a4ae:	ea95 0f0c 	teq	r5, ip
    a4b2:	f47f af25 	bne.w	a300 <__aeabi_dmul+0x234>
    a4b6:	4610      	mov	r0, r2
    a4b8:	4619      	mov	r1, r3
    a4ba:	e72c      	b.n	a316 <__aeabi_dmul+0x24a>
    a4bc:	ea95 0f0c 	teq	r5, ip
    a4c0:	d106      	bne.n	a4d0 <__aeabi_ddiv+0x1b0>
    a4c2:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    a4c6:	f43f aefd 	beq.w	a2c4 <__aeabi_dmul+0x1f8>
    a4ca:	4610      	mov	r0, r2
    a4cc:	4619      	mov	r1, r3
    a4ce:	e722      	b.n	a316 <__aeabi_dmul+0x24a>
    a4d0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    a4d4:	bf18      	it	ne
    a4d6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    a4da:	f47f aec5 	bne.w	a268 <__aeabi_dmul+0x19c>
    a4de:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
    a4e2:	f47f af0d 	bne.w	a300 <__aeabi_dmul+0x234>
    a4e6:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
    a4ea:	f47f aeeb 	bne.w	a2c4 <__aeabi_dmul+0x1f8>
    a4ee:	e712      	b.n	a316 <__aeabi_dmul+0x24a>

Disassembly of section .text.APP_Tasks%230:

0000a4f0 <APP_Tasks>:


//                     vTaskDelay( pdMS_TO_TICKS( 1000 ) );

void __attribute__((optimize("-O0"))) APP_Tasks(void)
{
    a4f0:	b590      	push	{r4, r7, lr}
    a4f2:	b0a5      	sub	sp, #148	; 0x94
    a4f4:	af02      	add	r7, sp, #8
	DRV_MIIM_RESULT opRes = DRV_MIIM_RES_OK;
    a4f6:	2300      	movs	r3, #0
    a4f8:	f887 3083 	strb.w	r3, [r7, #131]	; 0x83
    IPV4_ADDR ipAddr;
    TCPIP_NET_HANDLE netH;
    
    {
        static int old_but1 = 0;
        int temp_but1 = BUTTON1_Get();
    a4fc:	4ba8      	ldr	r3, [pc, #672]	; (a7a0 <APP_Tasks+0x2b0>)
    a4fe:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
    a502:	0adb      	lsrs	r3, r3, #11
    a504:	f003 0301 	and.w	r3, r3, #1
    a508:	67fb      	str	r3, [r7, #124]	; 0x7c
        if (temp_but1 && !old_but1) {
    a50a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
    a50c:	2b00      	cmp	r3, #0
    a50e:	d008      	beq.n	a522 <APP_Tasks+0x32>
    a510:	4ba4      	ldr	r3, [pc, #656]	; (a7a4 <APP_Tasks+0x2b4>)
    a512:	681b      	ldr	r3, [r3, #0]
    a514:	2b00      	cmp	r3, #0
    a516:	d104      	bne.n	a522 <APP_Tasks+0x32>
            LED1_Set();
    a518:	4ba1      	ldr	r3, [pc, #644]	; (a7a0 <APP_Tasks+0x2b0>)
    a51a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    a51e:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        }
        if (!temp_but1 && old_but1) {
    a522:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
    a524:	2b00      	cmp	r3, #0
    a526:	d10e      	bne.n	a546 <APP_Tasks+0x56>
    a528:	4b9e      	ldr	r3, [pc, #632]	; (a7a4 <APP_Tasks+0x2b4>)
    a52a:	681b      	ldr	r3, [r3, #0]
    a52c:	2b00      	cmp	r3, #0
    a52e:	d00a      	beq.n	a546 <APP_Tasks+0x56>
            LED1_Clear();
    a530:	4b9b      	ldr	r3, [pc, #620]	; (a7a0 <APP_Tasks+0x2b0>)
    a532:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    a536:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
            SERCOM1_USART_Virtual_Receive("iperf -s\n");
    a53a:	489b      	ldr	r0, [pc, #620]	; (a7a8 <APP_Tasks+0x2b8>)
    a53c:	f011 fa7c 	bl	1ba38 <SERCOM1_USART_Virtual_Receive>
            gfx_mono_print_scroll("iperf TCP server");
    a540:	489a      	ldr	r0, [pc, #616]	; (a7ac <APP_Tasks+0x2bc>)
    a542:	f010 fb21 	bl	1ab88 <gfx_mono_print_scroll>
        }
        old_but1 = temp_but1;
    a546:	4a97      	ldr	r2, [pc, #604]	; (a7a4 <APP_Tasks+0x2b4>)
    a548:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
    a54a:	6013      	str	r3, [r2, #0]


        static int old_but2 = 0;
        int temp_but2 = BUTTON2_Get();
    a54c:	4b94      	ldr	r3, [pc, #592]	; (a7a0 <APP_Tasks+0x2b0>)
    a54e:	6a1b      	ldr	r3, [r3, #32]
    a550:	0a1b      	lsrs	r3, r3, #8
    a552:	f003 0301 	and.w	r3, r3, #1
    a556:	67bb      	str	r3, [r7, #120]	; 0x78
        if (temp_but2 && !old_but2) {
    a558:	6fbb      	ldr	r3, [r7, #120]	; 0x78
    a55a:	2b00      	cmp	r3, #0
    a55c:	d008      	beq.n	a570 <APP_Tasks+0x80>
    a55e:	4b94      	ldr	r3, [pc, #592]	; (a7b0 <APP_Tasks+0x2c0>)
    a560:	681b      	ldr	r3, [r3, #0]
    a562:	2b00      	cmp	r3, #0
    a564:	d104      	bne.n	a570 <APP_Tasks+0x80>
            LED2_Set();
    a566:	4b8e      	ldr	r3, [pc, #568]	; (a7a0 <APP_Tasks+0x2b0>)
    a568:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    a56c:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        }
        if (!temp_but2 && old_but2) {
    a570:	6fbb      	ldr	r3, [r7, #120]	; 0x78
    a572:	2b00      	cmp	r3, #0
    a574:	d10e      	bne.n	a594 <APP_Tasks+0xa4>
    a576:	4b8e      	ldr	r3, [pc, #568]	; (a7b0 <APP_Tasks+0x2c0>)
    a578:	681b      	ldr	r3, [r3, #0]
    a57a:	2b00      	cmp	r3, #0
    a57c:	d00a      	beq.n	a594 <APP_Tasks+0xa4>
            LED2_Clear();
    a57e:	4b88      	ldr	r3, [pc, #544]	; (a7a0 <APP_Tasks+0x2b0>)
    a580:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    a584:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
            SERCOM1_USART_Virtual_Receive("iperf -s -u\n");
    a588:	488a      	ldr	r0, [pc, #552]	; (a7b4 <APP_Tasks+0x2c4>)
    a58a:	f011 fa55 	bl	1ba38 <SERCOM1_USART_Virtual_Receive>
            gfx_mono_print_scroll("iperf UDP server");
    a58e:	488a      	ldr	r0, [pc, #552]	; (a7b8 <APP_Tasks+0x2c8>)
    a590:	f010 fafa 	bl	1ab88 <gfx_mono_print_scroll>
        }
        old_but2 = temp_but2;
    a594:	4a86      	ldr	r2, [pc, #536]	; (a7b0 <APP_Tasks+0x2c0>)
    a596:	6fbb      	ldr	r3, [r7, #120]	; 0x78
    a598:	6013      	str	r3, [r2, #0]

        static int old_but3 = 0;
        int temp_but3 = BUTTON3_Get();
    a59a:	4b81      	ldr	r3, [pc, #516]	; (a7a0 <APP_Tasks+0x2b0>)
    a59c:	6a1b      	ldr	r3, [r3, #32]
    a59e:	0a5b      	lsrs	r3, r3, #9
    a5a0:	f003 0301 	and.w	r3, r3, #1
    a5a4:	677b      	str	r3, [r7, #116]	; 0x74
        if (temp_but3 && !old_but3) {
    a5a6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    a5a8:	2b00      	cmp	r3, #0
    a5aa:	d008      	beq.n	a5be <APP_Tasks+0xce>
    a5ac:	4b83      	ldr	r3, [pc, #524]	; (a7bc <APP_Tasks+0x2cc>)
    a5ae:	681b      	ldr	r3, [r3, #0]
    a5b0:	2b00      	cmp	r3, #0
    a5b2:	d104      	bne.n	a5be <APP_Tasks+0xce>
            LED3_Set();
    a5b4:	4b7a      	ldr	r3, [pc, #488]	; (a7a0 <APP_Tasks+0x2b0>)
    a5b6:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    a5ba:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
        }
        if (!temp_but3 && old_but3) {
    a5be:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    a5c0:	2b00      	cmp	r3, #0
    a5c2:	d10e      	bne.n	a5e2 <APP_Tasks+0xf2>
    a5c4:	4b7d      	ldr	r3, [pc, #500]	; (a7bc <APP_Tasks+0x2cc>)
    a5c6:	681b      	ldr	r3, [r3, #0]
    a5c8:	2b00      	cmp	r3, #0
    a5ca:	d00a      	beq.n	a5e2 <APP_Tasks+0xf2>
            LED3_Clear();
    a5cc:	4b74      	ldr	r3, [pc, #464]	; (a7a0 <APP_Tasks+0x2b0>)
    a5ce:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    a5d2:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194
            SERCOM1_USART_Virtual_Receive("iperfk\n");
    a5d6:	487a      	ldr	r0, [pc, #488]	; (a7c0 <APP_Tasks+0x2d0>)
    a5d8:	f011 fa2e 	bl	1ba38 <SERCOM1_USART_Virtual_Receive>
            gfx_mono_print_scroll("iperf kill server");
    a5dc:	4879      	ldr	r0, [pc, #484]	; (a7c4 <APP_Tasks+0x2d4>)
    a5de:	f010 fad3 	bl	1ab88 <gfx_mono_print_scroll>
        }
        old_but3 = temp_but3;
    a5e2:	4a76      	ldr	r2, [pc, #472]	; (a7bc <APP_Tasks+0x2cc>)
    a5e4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    a5e6:	6013      	str	r3, [r2, #0]
    }
    
    if(DHCPS_Restart){
    a5e8:	4b77      	ldr	r3, [pc, #476]	; (a7c8 <APP_Tasks+0x2d8>)
    a5ea:	781b      	ldrb	r3, [r3, #0]
    a5ec:	b2db      	uxtb	r3, r3
    a5ee:	2b00      	cmp	r3, #0
    a5f0:	d00f      	beq.n	a612 <APP_Tasks+0x122>
        DHCPS_Restart = false;
    a5f2:	4b75      	ldr	r3, [pc, #468]	; (a7c8 <APP_Tasks+0x2d8>)
    a5f4:	2200      	movs	r2, #0
    a5f6:	701a      	strb	r2, [r3, #0]
        vTaskDelay( pdMS_TO_TICKS( 4000 ) );
    a5f8:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
    a5fc:	f016 fc02 	bl	20e04 <vTaskDelay>
        SERCOM1_USART_Virtual_Receive("dhcps eth0 off\n");
    a600:	4872      	ldr	r0, [pc, #456]	; (a7cc <APP_Tasks+0x2dc>)
    a602:	f011 fa19 	bl	1ba38 <SERCOM1_USART_Virtual_Receive>
        vTaskDelay( pdMS_TO_TICKS( 100 ) );
    a606:	2064      	movs	r0, #100	; 0x64
    a608:	f016 fbfc 	bl	20e04 <vTaskDelay>
        SERCOM1_USART_Virtual_Receive("dhcps eth0 on\n");
    a60c:	4870      	ldr	r0, [pc, #448]	; (a7d0 <APP_Tasks+0x2e0>)
    a60e:	f011 fa13 	bl	1ba38 <SERCOM1_USART_Virtual_Receive>
    }
	/* Check the application's current state. */
	switch (appData.state)
    a612:	4b70      	ldr	r3, [pc, #448]	; (a7d4 <APP_Tasks+0x2e4>)
    a614:	781b      	ldrb	r3, [r3, #0]
    a616:	2b08      	cmp	r3, #8
    a618:	f200 8156 	bhi.w	a8c8 <APP_Tasks+0x3d8>
    a61c:	a201      	add	r2, pc, #4	; (adr r2, a624 <APP_Tasks+0x134>)
    a61e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    a622:	bf00      	nop
    a624:	0000a681 	.word	0x0000a681
    a628:	0000a649 	.word	0x0000a649
    a62c:	0000a655 	.word	0x0000a655
    a630:	0000a69b 	.word	0x0000a69b
    a634:	0000a70d 	.word	0x0000a70d
    a638:	0000a8c9 	.word	0x0000a8c9
    a63c:	0000a787 	.word	0x0000a787
    a640:	0000a793 	.word	0x0000a793
    a644:	0000a8c9 	.word	0x0000a8c9
    {
        
        case APP_DISPLAY_INIT:
        {
            gfx_mono_ssd1306_init();
    a648:	f014 f986 	bl	1e958 <gfx_mono_ssd1306_init>
            appData.state = APP_WAIT_STACK_INIT;
    a64c:	4b61      	ldr	r3, [pc, #388]	; (a7d4 <APP_Tasks+0x2e4>)
    a64e:	2202      	movs	r2, #2
    a650:	701a      	strb	r2, [r3, #0]
            break;
    a652:	e140      	b.n	a8d6 <APP_Tasks+0x3e6>
        }
        
        /* Wait till TCP stack is initialized. */
        case APP_WAIT_STACK_INIT:
        {
            if (TCPIP_STACK_Status(sysObj.tcpip) == SYS_STATUS_READY)
    a654:	4b60      	ldr	r3, [pc, #384]	; (a7d8 <APP_Tasks+0x2e8>)
    a656:	689b      	ldr	r3, [r3, #8]
    a658:	4618      	mov	r0, r3
    a65a:	f018 fd2f 	bl	230bc <TCPIP_STACK_Status>
    a65e:	4603      	mov	r3, r0
    a660:	2b02      	cmp	r3, #2
    a662:	f040 8133 	bne.w	a8cc <APP_Tasks+0x3dc>
            {
                TCPIP_DHCP_HandlerRegister(TCPIP_STACK_IndexToNet(0), MONITOR_DHCP_eth_Handler, &dhcp_eth_hParam);
    a666:	2000      	movs	r0, #0
    a668:	f017 fd0c 	bl	22084 <TCPIP_STACK_IndexToNet>
    a66c:	4603      	mov	r3, r0
    a66e:	4a5b      	ldr	r2, [pc, #364]	; (a7dc <APP_Tasks+0x2ec>)
    a670:	495b      	ldr	r1, [pc, #364]	; (a7e0 <APP_Tasks+0x2f0>)
    a672:	4618      	mov	r0, r3
    a674:	f016 fa40 	bl	20af8 <TCPIP_DHCP_HandlerRegister>
                appData.state = APP_MIIM_INIT;
    a678:	4b56      	ldr	r3, [pc, #344]	; (a7d4 <APP_Tasks+0x2e4>)
    a67a:	2200      	movs	r2, #0
    a67c:	701a      	strb	r2, [r3, #0]
            }
            break;
    a67e:	e125      	b.n	a8cc <APP_Tasks+0x3dc>

        /* Initialize the MIIM instance. */
        case APP_MIIM_INIT:
        {
            /*  Setup the MIIM driver instance. */
            if (local_miim_init() < 0)
    a680:	f010 fdc8 	bl	1b214 <local_miim_init>
    a684:	4603      	mov	r3, r0
    a686:	2b00      	cmp	r3, #0
    a688:	da03      	bge.n	a692 <APP_Tasks+0x1a2>
            {
                SYS_CONSOLE_PRINT("App: miim setup failed !\r\n");
    a68a:	4956      	ldr	r1, [pc, #344]	; (a7e4 <APP_Tasks+0x2f4>)
    a68c:	2000      	movs	r0, #0
    a68e:	f012 f805 	bl	1c69c <SYS_CONSOLE_Print>
            }

            appData.state = APP_READ_OPERATION_MODE;
    a692:	4b50      	ldr	r3, [pc, #320]	; (a7d4 <APP_Tasks+0x2e4>)
    a694:	2203      	movs	r2, #3
    a696:	701a      	strb	r2, [r3, #0]
            break;
    a698:	e11d      	b.n	a8d6 <APP_Tasks+0x3e6>

        /* Read in which mode of 10BaseT1s is working, CSMA/CD or PLCA. */
        case APP_READ_OPERATION_MODE:
        {
            // Example for Read register.
            opRes = Read_Phy_Register(&clientObj, 0, PHY_PLCA_CONTROL_0, &data);
    a69a:	4b53      	ldr	r3, [pc, #332]	; (a7e8 <APP_Tasks+0x2f8>)
    a69c:	4a53      	ldr	r2, [pc, #332]	; (a7ec <APP_Tasks+0x2fc>)
    a69e:	2100      	movs	r1, #0
    a6a0:	4853      	ldr	r0, [pc, #332]	; (a7f0 <APP_Tasks+0x300>)
    a6a2:	f019 fbdd 	bl	23e60 <Read_Phy_Register>
    a6a6:	4603      	mov	r3, r0
    a6a8:	f887 3083 	strb.w	r3, [r7, #131]	; 0x83

            if (opRes < 0)
    a6ac:	f997 3083 	ldrsb.w	r3, [r7, #131]	; 0x83
    a6b0:	2b00      	cmp	r3, #0
    a6b2:	da0a      	bge.n	a6ca <APP_Tasks+0x1da>
            {
                /* In case of an error, report and close miim instance. */
                SYS_CONSOLE_PRINT("Error occured:%d\r\n", opRes);
    a6b4:	f997 3083 	ldrsb.w	r3, [r7, #131]	; 0x83
    a6b8:	461a      	mov	r2, r3
    a6ba:	494e      	ldr	r1, [pc, #312]	; (a7f4 <APP_Tasks+0x304>)
    a6bc:	2000      	movs	r0, #0
    a6be:	f011 ffed 	bl	1c69c <SYS_CONSOLE_Print>
                appData.state = APP_MIIM_CLOSE;
    a6c2:	4b44      	ldr	r3, [pc, #272]	; (a7d4 <APP_Tasks+0x2e4>)
    a6c4:	2206      	movs	r2, #6
    a6c6:	701a      	strb	r2, [r3, #0]
                {
                    SYS_CONSOLE_PRINT(" Lan867x is in CSMA mode. \r\n", data);
                    appData.state = APP_MIIM_CLOSE;
                }
            }
            break;
    a6c8:	e102      	b.n	a8d0 <APP_Tasks+0x3e0>
            else if (opRes == DRV_MIIM_RES_OK) /* Check operation is completed. */
    a6ca:	f997 3083 	ldrsb.w	r3, [r7, #131]	; 0x83
    a6ce:	2b00      	cmp	r3, #0
    a6d0:	f040 80fe 	bne.w	a8d0 <APP_Tasks+0x3e0>
                if(1 == R2F(data, PHY_PLCA_CTRL0_EN))
    a6d4:	4b44      	ldr	r3, [pc, #272]	; (a7e8 <APP_Tasks+0x2f8>)
    a6d6:	881b      	ldrh	r3, [r3, #0]
    a6d8:	0bdb      	lsrs	r3, r3, #15
    a6da:	b29b      	uxth	r3, r3
    a6dc:	2b01      	cmp	r3, #1
    a6de:	d10a      	bne.n	a6f6 <APP_Tasks+0x206>
                    SYS_CONSOLE_PRINT(" Lan867x is in PLCA mode. \r\n", data);
    a6e0:	4b41      	ldr	r3, [pc, #260]	; (a7e8 <APP_Tasks+0x2f8>)
    a6e2:	881b      	ldrh	r3, [r3, #0]
    a6e4:	461a      	mov	r2, r3
    a6e6:	4944      	ldr	r1, [pc, #272]	; (a7f8 <APP_Tasks+0x308>)
    a6e8:	2000      	movs	r0, #0
    a6ea:	f011 ffd7 	bl	1c69c <SYS_CONSOLE_Print>
                    appData.state = APP_READ_PLCA_CONFIGURATION;
    a6ee:	4b39      	ldr	r3, [pc, #228]	; (a7d4 <APP_Tasks+0x2e4>)
    a6f0:	2204      	movs	r2, #4
    a6f2:	701a      	strb	r2, [r3, #0]
            break;
    a6f4:	e0ec      	b.n	a8d0 <APP_Tasks+0x3e0>
                    SYS_CONSOLE_PRINT(" Lan867x is in CSMA mode. \r\n", data);
    a6f6:	4b3c      	ldr	r3, [pc, #240]	; (a7e8 <APP_Tasks+0x2f8>)
    a6f8:	881b      	ldrh	r3, [r3, #0]
    a6fa:	461a      	mov	r2, r3
    a6fc:	493f      	ldr	r1, [pc, #252]	; (a7fc <APP_Tasks+0x30c>)
    a6fe:	2000      	movs	r0, #0
    a700:	f011 ffcc 	bl	1c69c <SYS_CONSOLE_Print>
                    appData.state = APP_MIIM_CLOSE;
    a704:	4b33      	ldr	r3, [pc, #204]	; (a7d4 <APP_Tasks+0x2e4>)
    a706:	2206      	movs	r2, #6
    a708:	701a      	strb	r2, [r3, #0]
            break;
    a70a:	e0e1      	b.n	a8d0 <APP_Tasks+0x3e0>
#endif

        /* Read the PLCA configuration. */
        case APP_READ_PLCA_CONFIGURATION:
        {
            opRes = Read_Phy_Register(&clientObj, 0, PHY_PLCA_CONTROL_1, &data);
    a70c:	4b36      	ldr	r3, [pc, #216]	; (a7e8 <APP_Tasks+0x2f8>)
    a70e:	4a3c      	ldr	r2, [pc, #240]	; (a800 <APP_Tasks+0x310>)
    a710:	2100      	movs	r1, #0
    a712:	4837      	ldr	r0, [pc, #220]	; (a7f0 <APP_Tasks+0x300>)
    a714:	f019 fba4 	bl	23e60 <Read_Phy_Register>
    a718:	4603      	mov	r3, r0
    a71a:	f887 3083 	strb.w	r3, [r7, #131]	; 0x83
            if (opRes < 0)
    a71e:	f997 3083 	ldrsb.w	r3, [r7, #131]	; 0x83
    a722:	2b00      	cmp	r3, #0
    a724:	da0a      	bge.n	a73c <APP_Tasks+0x24c>
            {
                /* In case of an error, report and close miim instance. */
                SYS_CONSOLE_PRINT("Error occured:%d\r\n", opRes);
    a726:	f997 3083 	ldrsb.w	r3, [r7, #131]	; 0x83
    a72a:	461a      	mov	r2, r3
    a72c:	4931      	ldr	r1, [pc, #196]	; (a7f4 <APP_Tasks+0x304>)
    a72e:	2000      	movs	r0, #0
    a730:	f011 ffb4 	bl	1c69c <SYS_CONSOLE_Print>
                appData.state = APP_MIIM_CLOSE;
    a734:	4b27      	ldr	r3, [pc, #156]	; (a7d4 <APP_Tasks+0x2e4>)
    a736:	2206      	movs	r2, #6
    a738:	701a      	strb	r2, [r3, #0]
                    gfx_mono_print_scroll(TCPIP_NETWORK_DEFAULT_IP_ADDRESS_IDX0);
                    gfx_mono_print_scroll("Id: %d Count: %d", R2F(data, PHY_PLCA_CTRL1_ID0), R2F(data, PHY_PLCA_CTRL1_NCNT));                  
                }
                appData.state = APP_MIIM_CLOSE;
            }
            break;
    a73a:	e0cb      	b.n	a8d4 <APP_Tasks+0x3e4>
            else if (opRes == DRV_MIIM_RES_OK) /* Check operation is completed. */
    a73c:	f997 3083 	ldrsb.w	r3, [r7, #131]	; 0x83
    a740:	2b00      	cmp	r3, #0
    a742:	f040 80c7 	bne.w	a8d4 <APP_Tasks+0x3e4>
                SYS_CONSOLE_PRINT(" Node Id: %d, Node count: %d. \r\n", R2F(data, PHY_PLCA_CTRL1_ID0), R2F(data, PHY_PLCA_CTRL1_NCNT));
    a746:	4b28      	ldr	r3, [pc, #160]	; (a7e8 <APP_Tasks+0x2f8>)
    a748:	881b      	ldrh	r3, [r3, #0]
    a74a:	b2da      	uxtb	r2, r3
    a74c:	4b26      	ldr	r3, [pc, #152]	; (a7e8 <APP_Tasks+0x2f8>)
    a74e:	881b      	ldrh	r3, [r3, #0]
    a750:	0a1b      	lsrs	r3, r3, #8
    a752:	b29b      	uxth	r3, r3
    a754:	492b      	ldr	r1, [pc, #172]	; (a804 <APP_Tasks+0x314>)
    a756:	2000      	movs	r0, #0
    a758:	f011 ffa0 	bl	1c69c <SYS_CONSOLE_Print>
                    gfx_mono_print_scroll("LAN867x PLCA"); 
    a75c:	482a      	ldr	r0, [pc, #168]	; (a808 <APP_Tasks+0x318>)
    a75e:	f010 fa13 	bl	1ab88 <gfx_mono_print_scroll>
                    gfx_mono_print_scroll(TCPIP_NETWORK_DEFAULT_IP_ADDRESS_IDX0);
    a762:	482a      	ldr	r0, [pc, #168]	; (a80c <APP_Tasks+0x31c>)
    a764:	f010 fa10 	bl	1ab88 <gfx_mono_print_scroll>
                    gfx_mono_print_scroll("Id: %d Count: %d", R2F(data, PHY_PLCA_CTRL1_ID0), R2F(data, PHY_PLCA_CTRL1_NCNT));                  
    a768:	4b1f      	ldr	r3, [pc, #124]	; (a7e8 <APP_Tasks+0x2f8>)
    a76a:	881b      	ldrh	r3, [r3, #0]
    a76c:	b2d9      	uxtb	r1, r3
    a76e:	4b1e      	ldr	r3, [pc, #120]	; (a7e8 <APP_Tasks+0x2f8>)
    a770:	881b      	ldrh	r3, [r3, #0]
    a772:	0a1b      	lsrs	r3, r3, #8
    a774:	b29b      	uxth	r3, r3
    a776:	461a      	mov	r2, r3
    a778:	4825      	ldr	r0, [pc, #148]	; (a810 <APP_Tasks+0x320>)
    a77a:	f010 fa05 	bl	1ab88 <gfx_mono_print_scroll>
                appData.state = APP_MIIM_CLOSE;
    a77e:	4b15      	ldr	r3, [pc, #84]	; (a7d4 <APP_Tasks+0x2e4>)
    a780:	2206      	movs	r2, #6
    a782:	701a      	strb	r2, [r3, #0]
            break;
    a784:	e0a6      	b.n	a8d4 <APP_Tasks+0x3e4>

        /* Close miim driver instance. */
        case APP_MIIM_CLOSE:
        {
            /* Close and release the handle(instance) to miim, as I do not need access to miim register anymore. */
            local_miim_close();
    a786:	f018 fb1b 	bl	22dc0 <local_miim_close>

            appData.state = APP_TCPIP_WAIT_FOR_IP;
    a78a:	4b12      	ldr	r3, [pc, #72]	; (a7d4 <APP_Tasks+0x2e4>)
    a78c:	2207      	movs	r2, #7
    a78e:	701a      	strb	r2, [r3, #0]
            break;
    a790:	e0a1      	b.n	a8d6 <APP_Tasks+0x3e6>

        case APP_TCPIP_WAIT_FOR_IP:

            // if the IP address of an interface has changed
            // display the new value on the system console
            nNets = TCPIP_STACK_NumberOfNetworksGet();
    a792:	f019 fd51 	bl	24238 <TCPIP_STACK_NumberOfNetworksGet>
    a796:	6738      	str	r0, [r7, #112]	; 0x70

            for (i = 0; i < nNets; i++) {
    a798:	2300      	movs	r3, #0
    a79a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
    a79e:	e08d      	b.n	a8bc <APP_Tasks+0x3cc>
    a7a0:	41008000 	.word	0x41008000
    a7a4:	2000ef40 	.word	0x2000ef40
    a7a8:	0000c248 	.word	0x0000c248
    a7ac:	0000c254 	.word	0x0000c254
    a7b0:	2000ef44 	.word	0x2000ef44
    a7b4:	0000c268 	.word	0x0000c268
    a7b8:	0000c278 	.word	0x0000c278
    a7bc:	2000ef48 	.word	0x2000ef48
    a7c0:	0000c28c 	.word	0x0000c28c
    a7c4:	0000c294 	.word	0x0000c294
    a7c8:	2000ef92 	.word	0x2000ef92
    a7cc:	0000c2a8 	.word	0x0000c2a8
    a7d0:	0000c2b8 	.word	0x0000c2b8
    a7d4:	2000ef70 	.word	0x2000ef70
    a7d8:	2000ec78 	.word	0x2000ec78
    a7dc:	2000ef54 	.word	0x2000ef54
    a7e0:	00016209 	.word	0x00016209
    a7e4:	0000c2c8 	.word	0x0000c2c8
    a7e8:	2000eae2 	.word	0x2000eae2
    a7ec:	001fca01 	.word	0x001fca01
    a7f0:	2000ed04 	.word	0x2000ed04
    a7f4:	0000c2e4 	.word	0x0000c2e4
    a7f8:	0000c2f8 	.word	0x0000c2f8
    a7fc:	0000c318 	.word	0x0000c318
    a800:	001fca02 	.word	0x001fca02
    a804:	0000c338 	.word	0x0000c338
    a808:	0000c35c 	.word	0x0000c35c
    a80c:	0000c36c 	.word	0x0000c36c
    a810:	0000c37c 	.word	0x0000c37c
                netH = TCPIP_STACK_IndexToNet(i);
    a814:	f8d7 0084 	ldr.w	r0, [r7, #132]	; 0x84
    a818:	f017 fc34 	bl	22084 <TCPIP_STACK_IndexToNet>
    a81c:	66f8      	str	r0, [r7, #108]	; 0x6c
                if (!TCPIP_STACK_NetIsReady(netH)) {
    a81e:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
    a820:	f018 fe1e 	bl	23460 <TCPIP_STACK_NetIsReady>
    a824:	4603      	mov	r3, r0
    a826:	f083 0301 	eor.w	r3, r3, #1
    a82a:	b2db      	uxtb	r3, r3
    a82c:	2b00      	cmp	r3, #0
    a82e:	d13f      	bne.n	a8b0 <APP_Tasks+0x3c0>
                    continue; // interface not ready yet! , 
                    //looking for another interface, that can be used for communication.
                }
                // Now. there is a ready interface that we can use
                ipAddr.Val = TCPIP_STACK_NetAddress(netH);
    a830:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
    a832:	f018 fb32 	bl	22e9a <TCPIP_STACK_NetAddress>
    a836:	4603      	mov	r3, r0
    a838:	66bb      	str	r3, [r7, #104]	; 0x68
                // display the changed IP address
                if (dwLastIP[i].Val != ipAddr.Val) {
    a83a:	4a29      	ldr	r2, [pc, #164]	; (a8e0 <APP_Tasks+0x3f0>)
    a83c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
    a840:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    a844:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    a846:	429a      	cmp	r2, r3
    a848:	d02e      	beq.n	a8a8 <APP_Tasks+0x3b8>
                    dwLastIP[i].Val = ipAddr.Val;
    a84a:	6eba      	ldr	r2, [r7, #104]	; 0x68
    a84c:	4924      	ldr	r1, [pc, #144]	; (a8e0 <APP_Tasks+0x3f0>)
    a84e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
    a852:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

                    SYS_CONSOLE_PRINT(TCPIP_STACK_NetNameGet(netH));
    a856:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
    a858:	f019 fd77 	bl	2434a <TCPIP_STACK_NetNameGet>
    a85c:	4603      	mov	r3, r0
    a85e:	4619      	mov	r1, r3
    a860:	2000      	movs	r0, #0
    a862:	f011 ff1b 	bl	1c69c <SYS_CONSOLE_Print>
                    SYS_CONSOLE_PRINT(" IP Address: ");
    a866:	491f      	ldr	r1, [pc, #124]	; (a8e4 <APP_Tasks+0x3f4>)
    a868:	2000      	movs	r0, #0
    a86a:	f011 ff17 	bl	1c69c <SYS_CONSOLE_Print>
                    char str[100];
                    sprintf(str,"%d.%d.%d.%d", ipAddr.v[0], ipAddr.v[1], ipAddr.v[2], ipAddr.v[3]);
    a86e:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
    a872:	4619      	mov	r1, r3
    a874:	f897 3069 	ldrb.w	r3, [r7, #105]	; 0x69
    a878:	461c      	mov	r4, r3
    a87a:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
    a87e:	f897 206b 	ldrb.w	r2, [r7, #107]	; 0x6b
    a882:	1d38      	adds	r0, r7, #4
    a884:	9201      	str	r2, [sp, #4]
    a886:	9300      	str	r3, [sp, #0]
    a888:	4623      	mov	r3, r4
    a88a:	460a      	mov	r2, r1
    a88c:	4916      	ldr	r1, [pc, #88]	; (a8e8 <APP_Tasks+0x3f8>)
    a88e:	f014 fee3 	bl	1f658 <siprintf>
                    SYS_CONSOLE_PRINT("%s\r\n", str);
    a892:	1d3b      	adds	r3, r7, #4
    a894:	461a      	mov	r2, r3
    a896:	4915      	ldr	r1, [pc, #84]	; (a8ec <APP_Tasks+0x3fc>)
    a898:	2000      	movs	r0, #0
    a89a:	f011 feff 	bl	1c69c <SYS_CONSOLE_Print>
                    gfx_mono_print_scroll("new:%s",str);
    a89e:	1d3b      	adds	r3, r7, #4
    a8a0:	4619      	mov	r1, r3
    a8a2:	4813      	ldr	r0, [pc, #76]	; (a8f0 <APP_Tasks+0x400>)
    a8a4:	f010 f970 	bl	1ab88 <gfx_mono_print_scroll>
                }
                appData.state = APP_STATE_SERVICE_TASKS;
    a8a8:	4b12      	ldr	r3, [pc, #72]	; (a8f4 <APP_Tasks+0x404>)
    a8aa:	2208      	movs	r2, #8
    a8ac:	701a      	strb	r2, [r3, #0]
    a8ae:	e000      	b.n	a8b2 <APP_Tasks+0x3c2>
                    continue; // interface not ready yet! , 
    a8b0:	bf00      	nop
            for (i = 0; i < nNets; i++) {
    a8b2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
    a8b6:	3301      	adds	r3, #1
    a8b8:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
    a8bc:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
    a8c0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
    a8c2:	429a      	cmp	r2, r3
    a8c4:	dba6      	blt.n	a814 <APP_Tasks+0x324>
            }
            break;
    a8c6:	e006      	b.n	a8d6 <APP_Tasks+0x3e6>

        /* The default state should never be executed. */
        default:
        {
            /* TODO: Handle error in application's state machine. */
            break;
    a8c8:	bf00      	nop
    a8ca:	e004      	b.n	a8d6 <APP_Tasks+0x3e6>
            break;
    a8cc:	bf00      	nop
    a8ce:	e002      	b.n	a8d6 <APP_Tasks+0x3e6>
            break;
    a8d0:	bf00      	nop
    a8d2:	e000      	b.n	a8d6 <APP_Tasks+0x3e6>
            break;
    a8d4:	bf00      	nop
        }
	}
}
    a8d6:	bf00      	nop
    a8d8:	378c      	adds	r7, #140	; 0x8c
    a8da:	46bd      	mov	sp, r7
    a8dc:	bd90      	pop	{r4, r7, pc}
    a8de:	bf00      	nop
    a8e0:	2000ed94 	.word	0x2000ed94
    a8e4:	0000c390 	.word	0x0000c390
    a8e8:	0000c3a0 	.word	0x0000c3a0
    a8ec:	0000c3ac 	.word	0x0000c3ac
    a8f0:	0000c3b4 	.word	0x0000c3b4
    a8f4:	2000ef70 	.word	0x2000ef70

Disassembly of section .text._DNS_ProcessPacket%231:

0000a8f8 <_DNS_ProcessPacket>:

// process a DNS packet
// returns true if info updated
// false if no entry was completed
static bool _DNS_ProcessPacket(TCPIP_DNS_DCPT* pDnsDcpt)
{
    a8f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a8fc:	f5ad 7d29 	sub.w	sp, sp, #676	; 0x2a4
    a900:	9004      	str	r0, [sp, #16]
    TCPIP_DNS_DBG_EVENT_TYPE evDbgType = TCPIP_DNS_DBG_EVENT_NONE;
    TCPIP_DNS_RR_PROCESS    procRR;


    // Get DNS Reply packet
    dnsPacketSize = TCPIP_UDP_ArrayGet(pDnsDcpt->dnsSocket, dnsRxBuffer, sizeof(dnsRxBuffer));
    a902:	ae22      	add	r6, sp, #136	; 0x88
    a904:	f44f 7200 	mov.w	r2, #512	; 0x200
    a908:	4631      	mov	r1, r6
    a90a:	f9b0 0024 	ldrsh.w	r0, [r0, #36]	; 0x24
    a90e:	f00c f895 	bl	16a3c <TCPIP_UDP_ArrayGet>
    rxData->head = rxData->rdPtr = buffer;
    a912:	96a3      	str	r6, [sp, #652]	; 0x28c
    a914:	96a2      	str	r6, [sp, #648]	; 0x288
    rxData->endPtr = buffer + bufferSize;
    a916:	4406      	add	r6, r0
    a918:	96a4      	str	r6, [sp, #656]	; 0x290

    _DNSInitRxData(&dnsRxData, dnsRxBuffer, dnsPacketSize);

    // Retrieve the DNS header and de-big-endian it
    if(!_DNSGetData(&dnsRxData, &DNSHeader, sizeof(DNSHeader)))
    a91a:	220c      	movs	r2, #12
    a91c:	a9a5      	add	r1, sp, #660	; 0x294
    a91e:	a8a2      	add	r0, sp, #648	; 0x288
    a920:	f016 f91e 	bl	20b60 <_DNSGetData>
    a924:	9001      	str	r0, [sp, #4]
    a926:	b920      	cbnz	r0, a932 <_DNS_ProcessPacket+0x3a>
    {
        _DNS_DbgEvent(pDnsDcpt, dnsHE, evDbgType);
    }

    return !procFail;
}
    a928:	9801      	ldr	r0, [sp, #4]
    a92a:	f50d 7d29 	add.w	sp, sp, #676	; 0x2a4
    a92e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    p->TransactionID.Val = TCPIP_Helper_htons(p->TransactionID.Val);
    a932:	f8bd 2294 	ldrh.w	r2, [sp, #660]	; 0x294
    a936:	0a13      	lsrs	r3, r2, #8
    a938:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    a93c:	f8ad 3294 	strh.w	r3, [sp, #660]	; 0x294
    p->Flags.Val = TCPIP_Helper_htons(p->Flags.Val);
    a940:	f8bd 2296 	ldrh.w	r2, [sp, #662]	; 0x296
    a944:	0a13      	lsrs	r3, r2, #8
    a946:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    a94a:	b21b      	sxth	r3, r3
    a94c:	f8ad 3296 	strh.w	r3, [sp, #662]	; 0x296
    p->AdditionalRecords.Val = TCPIP_Helper_htons(p->AdditionalRecords.Val);
    a950:	f8bd 129e 	ldrh.w	r1, [sp, #670]	; 0x29e
    a954:	0a0a      	lsrs	r2, r1, #8
    a956:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    a95a:	f8ad 229e 	strh.w	r2, [sp, #670]	; 0x29e
    p->Answers.Val = TCPIP_Helper_htons(p->Answers.Val);
    a95e:	f8bd 129a 	ldrh.w	r1, [sp, #666]	; 0x29a
    a962:	0a0a      	lsrs	r2, r1, #8
    a964:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    a968:	f8ad 229a 	strh.w	r2, [sp, #666]	; 0x29a
    p->AuthoritativeRecords.Val = TCPIP_Helper_htons(p->AuthoritativeRecords.Val);
    a96c:	f8bd 129c 	ldrh.w	r1, [sp, #668]	; 0x29c
    a970:	0a0a      	lsrs	r2, r1, #8
    a972:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    a976:	f8ad 229c 	strh.w	r2, [sp, #668]	; 0x29c
    p->Questions.Val = TCPIP_Helper_htons(p->Questions.Val);
    a97a:	f8bd 1298 	ldrh.w	r1, [sp, #664]	; 0x298
    a97e:	0a0a      	lsrs	r2, r1, #8
    a980:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    a984:	f8ad 2298 	strh.w	r2, [sp, #664]	; 0x298
        if((DNSHeader.Flags.v[0] & 0x03) != 0)
    a988:	f013 0f03 	tst.w	r3, #3
    a98c:	d13c      	bne.n	aa08 <_DNS_ProcessPacket+0x110>
    procRR.dnsHE = 0;
    a98e:	f04f 0b00 	mov.w	fp, #0
        for(ix = TCPIP_DNS_RR_TYPE_QUESTION; ix < TCPIP_DNS_RR_TYPES; ix++) 
    a992:	f8cd b00c 	str.w	fp, [sp, #12]
                nameLen++;
            }
        }
        if(discardLen != 0)
        {
            if(!_DNSGetData(xtractBuff, 0, discardLen))
    a996:	f8cd b000 	str.w	fp, [sp]
    a99a:	9607      	str	r6, [sp, #28]
    a99c:	e116      	b.n	abcc <_DNS_ProcessPacket+0x2d4>
           nRR = pProc->dnsHeader->Questions.Val;
    a99e:	f8bd 3298 	ldrh.w	r3, [sp, #664]	; 0x298
    a9a2:	9305      	str	r3, [sp, #20]
    while(nRR--)
    a9a4:	b93b      	cbnz	r3, a9b6 <_DNS_ProcessPacket+0xbe>
    a9a6:	e02f      	b.n	aa08 <_DNS_ProcessPacket+0x110>
           nRR = pProc->dnsHeader->Answers.Val;
    a9a8:	f8bd 329a 	ldrh.w	r3, [sp, #666]	; 0x29a
    a9ac:	9305      	str	r3, [sp, #20]
    while(nRR--)
    a9ae:	9b05      	ldr	r3, [sp, #20]
    a9b0:	2b00      	cmp	r3, #0
    a9b2:	f000 8106 	beq.w	abc2 <_DNS_ProcessPacket+0x2ca>
        for(ix = TCPIP_DNS_RR_TYPE_QUESTION; ix < TCPIP_DNS_RR_TYPES; ix++) 
    a9b6:	f04f 0900 	mov.w	r9, #0
        *wPtr = 0;
    a9ba:	f04f 0300 	mov.w	r3, #0
    a9be:	f88d 301b 	strb.w	r3, [sp, #27]
    a9c2:	e167      	b.n	ac94 <_DNS_ProcessPacket+0x39c>
           nRR = pProc->dnsHeader->AuthoritativeRecords.Val;
    a9c4:	f8bd 329c 	ldrh.w	r3, [sp, #668]	; 0x29c
    a9c8:	9305      	str	r3, [sp, #20]
           break;
    a9ca:	e7f0      	b.n	a9ae <_DNS_ProcessPacket+0xb6>
           nRR = pProc->dnsHeader->AdditionalRecords.Val;
    a9cc:	f8bd 329e 	ldrh.w	r3, [sp, #670]	; 0x29e
    a9d0:	9305      	str	r3, [sp, #20]
           break;
    a9d2:	e7ec      	b.n	a9ae <_DNS_ProcessPacket+0xb6>
            xtractBuff = &pktBuff;
    a9d4:	f10d 0834 	add.w	r8, sp, #52	; 0x34
    a9d8:	e022      	b.n	aa20 <_DNS_ProcessPacket+0x128>
            labelOffset = (uint16_t)(labelLen & 0x3f) << 8;
    a9da:	022d      	lsls	r5, r5, #8
    a9dc:	f405 557c 	and.w	r5, r5, #16128	; 0x3f00
            if(!_DNSGetData(xtractBuff, &offset, sizeof(offset)))
    a9e0:	2201      	movs	r2, #1
    a9e2:	a90a      	add	r1, sp, #40	; 0x28
    a9e4:	4640      	mov	r0, r8
    a9e6:	f016 f8bb 	bl	20b60 <_DNSGetData>
    a9ea:	b168      	cbz	r0, aa08 <_DNS_ProcessPacket+0x110>
            labelOffset += offset; 
    a9ec:	f89d 2028 	ldrb.w	r2, [sp, #40]	; 0x28
    rxData->head = rxData->rdPtr = buffer;
    a9f0:	ab22      	add	r3, sp, #136	; 0x88
    a9f2:	930e      	str	r3, [sp, #56]	; 0x38
    a9f4:	930d      	str	r3, [sp, #52]	; 0x34
    rxData->endPtr = buffer + bufferSize;
    a9f6:	9b07      	ldr	r3, [sp, #28]
    a9f8:	930f      	str	r3, [sp, #60]	; 0x3c
            if(!_DNSGetData(xtractBuff, 0, labelOffset))
    a9fa:	442a      	add	r2, r5
    a9fc:	9900      	ldr	r1, [sp, #0]
    a9fe:	a80d      	add	r0, sp, #52	; 0x34
    aa00:	f016 f8ae 	bl	20b60 <_DNSGetData>
    aa04:	2800      	cmp	r0, #0
    aa06:	d1e5      	bne.n	a9d4 <_DNS_ProcessPacket+0xdc>
    return !procFail;
    aa08:	9b01      	ldr	r3, [sp, #4]
    aa0a:	f083 0301 	eor.w	r3, r3, #1
    aa0e:	b2db      	uxtb	r3, r3
    aa10:	9301      	str	r3, [sp, #4]
    aa12:	e789      	b.n	a928 <_DNS_ProcessPacket+0x30>
                discardLen = labelLen - avlblLen;
    aa14:	1aed      	subs	r5, r5, r3
                copyLen = avlblLen;
    aa16:	461e      	mov	r6, r3
        if(copyLen != 0)
    aa18:	b9d3      	cbnz	r3, aa50 <_DNS_ProcessPacket+0x158>
        if(discardLen != 0)
    aa1a:	bb4d      	cbnz	r5, aa70 <_DNS_ProcessPacket+0x178>
                nameFail = true;
                break;
            }
        }

        nameLen += copyLen + discardLen;
    aa1c:	4435      	add	r5, r6
    aa1e:	442f      	add	r7, r5
        if(!_DNSGetData(xtractBuff, &labelLen, sizeof(labelLen)))
    aa20:	2201      	movs	r2, #1
    aa22:	f10d 0127 	add.w	r1, sp, #39	; 0x27
    aa26:	4640      	mov	r0, r8
    aa28:	f016 f89a 	bl	20b60 <_DNSGetData>
    aa2c:	2800      	cmp	r0, #0
    aa2e:	d0eb      	beq.n	aa08 <_DNS_ProcessPacket+0x110>
        if(labelLen == 0)
    aa30:	f89d 5027 	ldrb.w	r5, [sp, #39]	; 0x27
    aa34:	2d00      	cmp	r5, #0
    aa36:	f000 8136 	beq.w	aca6 <_DNS_ProcessPacket+0x3ae>
        if((labelLen & 0xc0) == 0xc0)
    aa3a:	462e      	mov	r6, r5
    aa3c:	f005 03c0 	and.w	r3, r5, #192	; 0xc0
    aa40:	2bc0      	cmp	r3, #192	; 0xc0
    aa42:	d0ca      	beq.n	a9da <_DNS_ProcessPacket+0xe2>
        if(wPtr != 0)
    aa44:	b1bc      	cbz	r4, aa76 <_DNS_ProcessPacket+0x17e>
            avlblLen = ePtr - wPtr;
    aa46:	ab21      	add	r3, sp, #132	; 0x84
    aa48:	1b1b      	subs	r3, r3, r4
            if(labelLen > avlblLen)
    aa4a:	429d      	cmp	r5, r3
    aa4c:	dce2      	bgt.n	aa14 <_DNS_ProcessPacket+0x11c>
                discardLen = 0;
    aa4e:	9d00      	ldr	r5, [sp, #0]
            if(!_DNSGetData(xtractBuff, wPtr, copyLen))
    aa50:	4632      	mov	r2, r6
    aa52:	4621      	mov	r1, r4
    aa54:	4640      	mov	r0, r8
    aa56:	f016 f883 	bl	20b60 <_DNSGetData>
    aa5a:	2800      	cmp	r0, #0
    aa5c:	d0d4      	beq.n	aa08 <_DNS_ProcessPacket+0x110>
            wPtr += copyLen;
    aa5e:	4434      	add	r4, r6
            if(wPtr < ePtr)
    aa60:	ab21      	add	r3, sp, #132	; 0x84
    aa62:	429c      	cmp	r4, r3
    aa64:	d2d9      	bcs.n	aa1a <_DNS_ProcessPacket+0x122>
                *wPtr++ = '.';
    aa66:	232e      	movs	r3, #46	; 0x2e
    aa68:	f804 3b01 	strb.w	r3, [r4], #1
                nameLen++;
    aa6c:	3701      	adds	r7, #1
    aa6e:	e7d4      	b.n	aa1a <_DNS_ProcessPacket+0x122>
        if(discardLen != 0)
    aa70:	9602      	str	r6, [sp, #8]
    aa72:	462e      	mov	r6, r5
    aa74:	e001      	b.n	aa7a <_DNS_ProcessPacket+0x182>
            copyLen = 0;
    aa76:	9b00      	ldr	r3, [sp, #0]
    aa78:	9302      	str	r3, [sp, #8]
            if(!_DNSGetData(xtractBuff, 0, discardLen))
    aa7a:	4632      	mov	r2, r6
    aa7c:	9900      	ldr	r1, [sp, #0]
    aa7e:	4640      	mov	r0, r8
    aa80:	f016 f86e 	bl	20b60 <_DNSGetData>
    aa84:	2800      	cmp	r0, #0
    aa86:	d0bf      	beq.n	aa08 <_DNS_ProcessPacket+0x110>
    aa88:	4635      	mov	r5, r6
    aa8a:	9e02      	ldr	r6, [sp, #8]
    aa8c:	e7c6      	b.n	aa1c <_DNS_ProcessPacket+0x124>

    if(wPtr != 0)
    {
        if(wPtr != nameBuff && *(wPtr - 1) == '.')
        {
            wPtr--; // remove the last '.' 
    aa8e:	3c01      	subs	r4, #1
            nameLen--;
    aa90:	3f01      	subs	r7, #1
    aa92:	e112      	b.n	acba <_DNS_ProcessPacket+0x3c2>
        if(wPtr != nameBuff && *(wPtr - 1) == '.')
    aa94:	ac11      	add	r4, sp, #68	; 0x44
    aa96:	e110      	b.n	acba <_DNS_ProcessPacket+0x3c2>
            return pDnsHE;
    aa98:	469b      	mov	fp, r3
    aa9a:	e0ea      	b.n	ac72 <_DNS_ProcessPacket+0x37a>
    if(!_DNSGetData(dnsRxData, (uint8_t *)&DNSAnswerHeader, sizeof(TCPIP_DNS_ANSWER_HEADER)))
    aa9c:	220a      	movs	r2, #10
    aa9e:	a90a      	add	r1, sp, #40	; 0x28
    aaa0:	a8a2      	add	r0, sp, #648	; 0x288
    aaa2:	f016 f85d 	bl	20b60 <_DNSGetData>
    aaa6:	2800      	cmp	r0, #0
    aaa8:	d0ae      	beq.n	aa08 <_DNS_ProcessPacket+0x110>
    p->ResponseClass.Val = TCPIP_Helper_htons(p->ResponseClass.Val);
    aaaa:	f8bd 302a 	ldrh.w	r3, [sp, #42]	; 0x2a
    aaae:	0a18      	lsrs	r0, r3, #8
    aab0:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
    aab4:	b280      	uxth	r0, r0
    aab6:	f8ad 002a 	strh.w	r0, [sp, #42]	; 0x2a
    p->ResponseLen.Val = TCPIP_Helper_htons(p->ResponseLen.Val);
    aaba:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
    aabe:	0a1a      	lsrs	r2, r3, #8
    aac0:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
    aac4:	b292      	uxth	r2, r2
    aac6:	f8ad 2030 	strh.w	r2, [sp, #48]	; 0x30
    p->ResponseTTL.Val = TCPIP_Helper_htonl(p->ResponseTTL.Val);
    aaca:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    return (((hLong & 0x000000ff) << 24) | ((hLong & 0x0000ff00) << 8) | ((hLong & 0x00ff0000) >> 8) | ((hLong & 0xff000000) >> 24));
    aacc:	0e19      	lsrs	r1, r3, #24
    aace:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
    aad2:	021c      	lsls	r4, r3, #8
    aad4:	f404 047f 	and.w	r4, r4, #16711680	; 0xff0000
    aad8:	4321      	orrs	r1, r4
    aada:	0a1b      	lsrs	r3, r3, #8
    aadc:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    aae0:	430b      	orrs	r3, r1
    aae2:	930b      	str	r3, [sp, #44]	; 0x2c
    p->ResponseType.Val = TCPIP_Helper_htons(p->ResponseType.Val);
    aae4:	f8bd 1028 	ldrh.w	r1, [sp, #40]	; 0x28
       return (((hShort) << 8) | ((hShort) >> 8));
    aae8:	0a0b      	lsrs	r3, r1, #8
    aaea:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    aaee:	b29b      	uxth	r3, r3
    aaf0:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
    while( dnsHE != 0 && (DNSAnswerHeader.ResponseClass.Val == 1)) // Internet class
    aaf4:	f1bb 0f00 	cmp.w	fp, #0
    aaf8:	d001      	beq.n	aafe <_DNS_ProcessPacket+0x206>
    aafa:	2801      	cmp	r0, #1
    aafc:	d007      	beq.n	ab0e <_DNS_ProcessPacket+0x216>
        if(!_DNSGetData(dnsRxData, 0, DNSAnswerHeader.ResponseLen.Val))
    aafe:	9900      	ldr	r1, [sp, #0]
    ab00:	a8a2      	add	r0, sp, #648	; 0x288
    ab02:	f016 f82d 	bl	20b60 <_DNSGetData>
            if(entryUpdate == false)
    ab06:	2800      	cmp	r0, #0
    ab08:	f040 80bf 	bne.w	ac8a <_DNS_ProcessPacket+0x392>
    ab0c:	e77c      	b.n	aa08 <_DNS_ProcessPacket+0x110>
        if (DNSAnswerHeader.ResponseType.Val == TCPIP_DNS_TYPE_A && DNSAnswerHeader.ResponseLen.Val == 4)
    ab0e:	2b01      	cmp	r3, #1
    ab10:	d02f      	beq.n	ab72 <_DNS_ProcessPacket+0x27a>
        if (DNSAnswerHeader.ResponseType.Val == TCPIP_DNS_TYPE_AAAA && DNSAnswerHeader.ResponseLen.Val == 16)
    ab12:	2b1c      	cmp	r3, #28
    ab14:	d1f3      	bne.n	aafe <_DNS_ProcessPacket+0x206>
    ab16:	2a10      	cmp	r2, #16
    ab18:	d1f1      	bne.n	aafe <_DNS_ProcessPacket+0x206>
            if((dnsHE->recordMask & TCPIP_DNS_ADDRESS_REC_IPV6) == 0 || (dnsHE->nIPv6Entries >= pDnsDcpt->nIPv6Entries))
    ab1a:	f89b 302a 	ldrb.w	r3, [fp, #42]	; 0x2a
    ab1e:	f013 0f02 	tst.w	r3, #2
    ab22:	d0ec      	beq.n	aafe <_DNS_ProcessPacket+0x206>
    ab24:	f89b 1027 	ldrb.w	r1, [fp, #39]	; 0x27
    ab28:	9b04      	ldr	r3, [sp, #16]
    ab2a:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
    ab2c:	4299      	cmp	r1, r3
    ab2e:	d2e6      	bcs.n	aafe <_DNS_ProcessPacket+0x206>
            if(!_DNSGetData(dnsRxData, ipAddr.v6Add.v, sizeof (IPV6_ADDR)))
    ab30:	a90d      	add	r1, sp, #52	; 0x34
    ab32:	a8a2      	add	r0, sp, #648	; 0x288
    ab34:	f016 f814 	bl	20b60 <_DNSGetData>
    ab38:	2800      	cmp	r0, #0
    ab3a:	f43f af65 	beq.w	aa08 <_DNS_ProcessPacket+0x110>
            memcpy( &dnsHE->pip6Address[dnsHE->nIPv6Entries], ipAddr.v6Add.v, sizeof(IPV6_ADDR));
    ab3e:	f89b 5027 	ldrb.w	r5, [fp, #39]	; 0x27
    ab42:	012d      	lsls	r5, r5, #4
    ab44:	f8db 7014 	ldr.w	r7, [fp, #20]
    ab48:	197e      	adds	r6, r7, r5
    ab4a:	ac0d      	add	r4, sp, #52	; 0x34
    ab4c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    ab4e:	5178      	str	r0, [r7, r5]
    ab50:	6071      	str	r1, [r6, #4]
    ab52:	60b2      	str	r2, [r6, #8]
    ab54:	60f3      	str	r3, [r6, #12]
            if((DNSAnswerHeader.ResponseTTL.Val < dnsHE->ipTTL.Val) || (dnsHE->ipTTL.Val == 0))
    ab56:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ab58:	f8db 2018 	ldr.w	r2, [fp, #24]
    ab5c:	4293      	cmp	r3, r2
    ab5e:	d300      	bcc.n	ab62 <_DNS_ProcessPacket+0x26a>
    ab60:	b90a      	cbnz	r2, ab66 <_DNS_ProcessPacket+0x26e>
                dnsHE->ipTTL.Val = DNSAnswerHeader.ResponseTTL.Val;
    ab62:	f8cb 3018 	str.w	r3, [fp, #24]
            dnsHE->nIPv6Entries++;
    ab66:	f89b 3027 	ldrb.w	r3, [fp, #39]	; 0x27
    ab6a:	3301      	adds	r3, #1
    ab6c:	f88b 3027 	strb.w	r3, [fp, #39]	; 0x27
    if(discardData)
    ab70:	e08b      	b.n	ac8a <_DNS_ProcessPacket+0x392>
        if (DNSAnswerHeader.ResponseType.Val == TCPIP_DNS_TYPE_A && DNSAnswerHeader.ResponseLen.Val == 4)
    ab72:	2a04      	cmp	r2, #4
    ab74:	d1c3      	bne.n	aafe <_DNS_ProcessPacket+0x206>
            if(dnsHE->nIPv4Entries >= pDnsDcpt->nIPv4Entries)
    ab76:	f89b 1026 	ldrb.w	r1, [fp, #38]	; 0x26
    ab7a:	9b04      	ldr	r3, [sp, #16]
    ab7c:	8c1b      	ldrh	r3, [r3, #32]
    ab7e:	4299      	cmp	r1, r3
    ab80:	d2bd      	bcs.n	aafe <_DNS_ProcessPacket+0x206>
            if(!_DNSGetData(dnsRxData, ipAddr.v4Add.v, sizeof(IPV4_ADDR)))
    ab82:	a90d      	add	r1, sp, #52	; 0x34
    ab84:	a8a2      	add	r0, sp, #648	; 0x288
    ab86:	f015 ffeb 	bl	20b60 <_DNSGetData>
    ab8a:	2800      	cmp	r0, #0
    ab8c:	f43f af3c 	beq.w	aa08 <_DNS_ProcessPacket+0x110>
            dnsHE->pip4Address[dnsHE->nIPv4Entries].Val = ipAddr.v4Add.Val;
    ab90:	990d      	ldr	r1, [sp, #52]	; 0x34
    ab92:	f89b 2026 	ldrb.w	r2, [fp, #38]	; 0x26
    ab96:	f8db 3010 	ldr.w	r3, [fp, #16]
    ab9a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            if((DNSAnswerHeader.ResponseTTL.Val < dnsHE->ipTTL.Val) || (dnsHE->ipTTL.Val == 0))
    ab9e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    aba0:	f8db 2018 	ldr.w	r2, [fp, #24]
    aba4:	4293      	cmp	r3, r2
    aba6:	d300      	bcc.n	abaa <_DNS_ProcessPacket+0x2b2>
    aba8:	b90a      	cbnz	r2, abae <_DNS_ProcessPacket+0x2b6>
                dnsHE->ipTTL.Val = DNSAnswerHeader.ResponseTTL.Val;
    abaa:	f8cb 3018 	str.w	r3, [fp, #24]
            dnsHE->nIPv4Entries++;
    abae:	f89b 3026 	ldrb.w	r3, [fp, #38]	; 0x26
    abb2:	3301      	adds	r3, #1
    abb4:	f88b 3026 	strb.w	r3, [fp, #38]	; 0x26
    if(discardData)
    abb8:	e067      	b.n	ac8a <_DNS_ProcessPacket+0x392>
        if(rrType == TCPIP_DNS_RR_TYPE_QUESTION)
    abba:	f1ba 0f00 	cmp.w	sl, #0
    abbe:	f43f af23 	beq.w	aa08 <_DNS_ProcessPacket+0x110>
        for(ix = TCPIP_DNS_RR_TYPE_QUESTION; ix < TCPIP_DNS_RR_TYPES; ix++) 
    abc2:	9b03      	ldr	r3, [sp, #12]
    abc4:	3301      	adds	r3, #1
    abc6:	9303      	str	r3, [sp, #12]
    abc8:	2b04      	cmp	r3, #4
    abca:	d00f      	beq.n	abec <_DNS_ProcessPacket+0x2f4>
            _DNS_ProcessRR(pDnsDcpt, &procRR, (TCPIP_DNS_RR_TYPE)ix);
    abcc:	f89d a00c 	ldrb.w	sl, [sp, #12]
    switch(rrType)
    abd0:	f1ba 0f03 	cmp.w	sl, #3
    abd4:	d8f1      	bhi.n	abba <_DNS_ProcessPacket+0x2c2>
    abd6:	a301      	add	r3, pc, #4	; (adr r3, abdc <_DNS_ProcessPacket+0x2e4>)
    abd8:	f853 f02a 	ldr.w	pc, [r3, sl, lsl #2]
    abdc:	0000a99f 	.word	0x0000a99f
    abe0:	0000a9a9 	.word	0x0000a9a9
    abe4:	0000a9c5 	.word	0x0000a9c5
    abe8:	0000a9cd 	.word	0x0000a9cd
        if(dnsHE != 0 && (dnsHE->nIPv4Entries > 0 || dnsHE->nIPv6Entries > 0))
    abec:	f1bb 0f00 	cmp.w	fp, #0
    abf0:	f43f af0a 	beq.w	aa08 <_DNS_ProcessPacket+0x110>
    abf4:	f8bb 3026 	ldrh.w	r3, [fp, #38]	; 0x26
    abf8:	2b00      	cmp	r3, #0
    abfa:	f43f af05 	beq.w	aa08 <_DNS_ProcessPacket+0x110>
    dnsHE->hEntry.flags.value &= ~TCPIP_DNS_FLAG_ENTRY_TIMEOUT;
    abfe:	f8bb 3000 	ldrh.w	r3, [fp]
    ac02:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    dnsHE->hEntry.flags.value |= TCPIP_DNS_FLAG_ENTRY_COMPLETE;
    ac06:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    ac0a:	f8ab 3000 	strh.w	r3, [fp]
    dnsHE->recordMask = TCPIP_DNS_ADDRESS_REC_NONE;
    ac0e:	2300      	movs	r3, #0
    ac10:	f88b 302a 	strb.w	r3, [fp, #42]	; 0x2a
    if(dnsHE->nIPv4Entries != 0)
    ac14:	f89b 3026 	ldrb.w	r3, [fp, #38]	; 0x26
    ac18:	b113      	cbz	r3, ac20 <_DNS_ProcessPacket+0x328>
        dnsHE->recordMask |= TCPIP_DNS_ADDRESS_REC_IPV4;
    ac1a:	2301      	movs	r3, #1
    ac1c:	f88b 302a 	strb.w	r3, [fp, #42]	; 0x2a
    if(dnsHE->nIPv6Entries != 0)
    ac20:	f89b 3027 	ldrb.w	r3, [fp, #39]	; 0x27
    ac24:	b12b      	cbz	r3, ac32 <_DNS_ProcessPacket+0x33a>
        dnsHE->recordMask |= TCPIP_DNS_ADDRESS_REC_IPV6;
    ac26:	f89b 302a 	ldrb.w	r3, [fp, #42]	; 0x2a
    ac2a:	f043 0302 	orr.w	r3, r3, #2
    ac2e:	f88b 302a 	strb.w	r3, [fp, #42]	; 0x2a
    if(dnsHE->ipTTL.Val == 0)
    ac32:	f8db 3018 	ldr.w	r3, [fp, #24]
    ac36:	b91b      	cbnz	r3, ac40 <_DNS_ProcessPacket+0x348>
        dnsHE->ipTTL.Val = TCPIP_DNS_CLIENT_CACHE_DEFAULT_TTL_VAL;
    ac38:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
    ac3c:	f8cb 3018 	str.w	r3, [fp, #24]
    dnsHE->tRetry = dnsHE->tInsert = pDnsDcpt->dnsTime; 
    ac40:	9a04      	ldr	r2, [sp, #16]
    ac42:	69d3      	ldr	r3, [r2, #28]
    ac44:	f8cb 3008 	str.w	r3, [fp, #8]
    ac48:	f8cb 300c 	str.w	r3, [fp, #12]
    pDnsDcpt->unsolvedEntries--;
    ac4c:	8cd3      	ldrh	r3, [r2, #38]	; 0x26
    ac4e:	3b01      	subs	r3, #1
    ac50:	84d3      	strh	r3, [r2, #38]	; 0x26
        procFail = false;
    ac52:	2300      	movs	r3, #0
    ac54:	9301      	str	r3, [sp, #4]
    ac56:	e6d7      	b.n	aa08 <_DNS_ProcessPacket+0x110>
            if((dnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) != 0)
    ac58:	8802      	ldrh	r2, [r0, #0]
    ac5a:	f012 0f80 	tst.w	r2, #128	; 0x80
    ac5e:	f47f aed3 	bne.w	aa08 <_DNS_ProcessPacket+0x110>
            if(pProc->dnsHE == 0)
    ac62:	f1bb 0f00 	cmp.w	fp, #0
    ac66:	f43f af17 	beq.w	aa98 <_DNS_ProcessPacket+0x1a0>
            else if(pProc->dnsHE != dnsHE)
    ac6a:	459b      	cmp	fp, r3
    ac6c:	f47f aecc 	bne.w	aa08 <_DNS_ProcessPacket+0x110>
            return pDnsHE;
    ac70:	469b      	mov	fp, r3
        if(rrType == TCPIP_DNS_RR_TYPE_QUESTION)
    ac72:	f1ba 0f00 	cmp.w	sl, #0
    ac76:	f47f af11 	bne.w	aa9c <_DNS_ProcessPacket+0x1a4>
            if(!_DNSGetData(pProc->dnsRxData, 0, 4))
    ac7a:	2204      	movs	r2, #4
    ac7c:	9900      	ldr	r1, [sp, #0]
    ac7e:	a8a2      	add	r0, sp, #648	; 0x288
    ac80:	f015 ff6e 	bl	20b60 <_DNSGetData>
    ac84:	2800      	cmp	r0, #0
    ac86:	f43f aebf 	beq.w	aa08 <_DNS_ProcessPacket+0x110>
        nRecords++;
    ac8a:	f109 0901 	add.w	r9, r9, #1
    while(nRR--)
    ac8e:	9b05      	ldr	r3, [sp, #20]
    ac90:	4599      	cmp	r9, r3
    ac92:	d096      	beq.n	abc2 <_DNS_ProcessPacket+0x2ca>
        *wPtr = 0;
    ac94:	f89d 301b 	ldrb.w	r3, [sp, #27]
    ac98:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
    TCPIP_DNS_RX_DATA* xtractBuff = pProc->dnsRxData;
    ac9c:	f50d 7822 	add.w	r8, sp, #648	; 0x288
        *wPtr = 0;
    aca0:	ac11      	add	r4, sp, #68	; 0x44
    nameLen = 0;
    aca2:	2700      	movs	r7, #0
    aca4:	e6bc      	b.n	aa20 <_DNS_ProcessPacket+0x128>
    if(wPtr != 0)
    aca6:	b15c      	cbz	r4, acc0 <_DNS_ProcessPacket+0x3c8>
        if(wPtr != nameBuff && *(wPtr - 1) == '.')
    aca8:	ab11      	add	r3, sp, #68	; 0x44
    acaa:	429c      	cmp	r4, r3
    acac:	f43f aef2 	beq.w	aa94 <_DNS_ProcessPacket+0x19c>
    acb0:	f814 3c01 	ldrb.w	r3, [r4, #-1]
    acb4:	2b2e      	cmp	r3, #46	; 0x2e
    acb6:	f43f aeea 	beq.w	aa8e <_DNS_ProcessPacket+0x196>
        }

        *wPtr = 0;  // end the nameBuff properly
    acba:	f04f 0300 	mov.w	r3, #0
    acbe:	7023      	strb	r3, [r4, #0]
        if(nameLen <= 0)
    acc0:	2f00      	cmp	r7, #0
    acc2:	f77f aea1 	ble.w	aa08 <_DNS_ProcessPacket+0x110>
        dnsHE = _DNSHashEntryFromTransactionId(pDnsDcpt, nameBuffer, pProc->dnsHeader->TransactionID.Val);
    acc6:	f8bd 4294 	ldrh.w	r4, [sp, #660]	; 0x294
    pDnsHE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryLookup(pDnsDcpt->hashDcpt, hostName);
    acca:	a911      	add	r1, sp, #68	; 0x44
    accc:	9b04      	ldr	r3, [sp, #16]
    acce:	6818      	ldr	r0, [r3, #0]
    acd0:	f011 fe58 	bl	1c984 <TCPIP_OAHASH_EntryLookup>
    if(pDnsHE != 0)
    acd4:	4603      	mov	r3, r0
    acd6:	b110      	cbz	r0, acde <_DNS_ProcessPacket+0x3e6>
        if(pDnsHE->transactionId.Val == transactionId)
    acd8:	8c82      	ldrh	r2, [r0, #36]	; 0x24
    acda:	42a2      	cmp	r2, r4
    acdc:	d0bc      	beq.n	ac58 <_DNS_ProcessPacket+0x360>
            if(pProc->dnsHE != 0)
    acde:	f1bb 0f00 	cmp.w	fp, #0
    ace2:	d0c6      	beq.n	ac72 <_DNS_ProcessPacket+0x37a>
            if((dnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) != 0)
    ace4:	f8bb 3000 	ldrh.w	r3, [fp]
    ace8:	f013 0f80 	tst.w	r3, #128	; 0x80
    acec:	d0c1      	beq.n	ac72 <_DNS_ProcessPacket+0x37a>
    acee:	e68b      	b.n	aa08 <_DNS_ProcessPacket+0x110>

Disassembly of section .text.TCPIP_COMMAND_Task%232:

0000acf0 <TCPIP_COMMAND_Task>:
}

#endif  // defined(_TCPIP_COMMAND_PING4) || defined(_TCPIP_COMMAND_PING6)

void TCPIP_COMMAND_Task(void)
{
    acf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    acf4:	b095      	sub	sp, #84	; 0x54
    TCPIP_MODULE_SIGNAL sigPend;

    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    acf6:	210f      	movs	r1, #15
    acf8:	201f      	movs	r0, #31
    acfa:	f015 fa1b 	bl	20134 <_TCPIPStackModuleSignalGet>

    if((sigPend & TCPIP_MODULE_SIGNAL_TMO) != 0)
    acfe:	f010 0f02 	tst.w	r0, #2
    ad02:	d00d      	beq.n	ad20 <TCPIP_COMMAND_Task+0x30>
    { // regular TMO occurred

#if  defined(_TCPIP_COMMAND_PING4) || defined(_TCPIP_COMMAND_PING6)
        if(TCPIP_CMD_STAT_PING_START <= tcpipCmdStat && tcpipCmdStat <= TCPIP_CMD_STAT_PING_STOP)
    ad04:	4b93      	ldr	r3, [pc, #588]	; (af54 <TCPIP_COMMAND_Task+0x264>)
    ad06:	781a      	ldrb	r2, [r3, #0]
    ad08:	1e53      	subs	r3, r2, #1
    ad0a:	b2db      	uxtb	r3, r3
    ad0c:	2b06      	cmp	r3, #6
    ad0e:	d90a      	bls.n	ad26 <TCPIP_COMMAND_Task+0x36>
            TCPIPCmdPingTask();
        }
#endif  // defined(_TCPIP_COMMAND_PING4) || defined(_TCPIP_COMMAND_PING6)

#if defined(TCPIP_STACK_USE_DNS)
        if(TCPIP_CMD_STAT_DNS_START <= tcpipCmdStat && tcpipCmdStat <= TCPIP_CMD_STAT_DNS_STOP)
    ad10:	4b90      	ldr	r3, [pc, #576]	; (af54 <TCPIP_COMMAND_Task+0x264>)
    ad12:	781a      	ldrb	r2, [r3, #0]
    ad14:	f1a2 0308 	sub.w	r3, r2, #8
    ad18:	b2db      	uxtb	r3, r3
    ad1a:	2b01      	cmp	r3, #1
    ad1c:	f240 80c7 	bls.w	aeae <TCPIP_COMMAND_Task+0x1be>
        {
            TCPIPCmdMiimTask();
        }
#endif  // defined(_TCPIP_COMMANDS_MIIM)
    }
}
    ad20:	b015      	add	sp, #84	; 0x54
    ad22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    switch(tcpipCmdStat)
    ad26:	3a01      	subs	r2, #1
    ad28:	2a03      	cmp	r2, #3
    ad2a:	d840      	bhi.n	adae <TCPIP_COMMAND_Task+0xbe>
    ad2c:	e8df f002 	tbb	[pc, r2]
    ad30:	39331702 	.word	0x39331702
            dnsRes = TCPIP_DNS_Resolve(icmpTargetHost, TCPIP_DNS_TYPE_A);
    ad34:	2101      	movs	r1, #1
    ad36:	4888      	ldr	r0, [pc, #544]	; (af58 <TCPIP_COMMAND_Task+0x268>)
    ad38:	f019 faf8 	bl	2432c <TCPIP_DNS_Resolve>
            if(dnsRes != TCPIP_DNS_RES_OK && dnsRes != TCPIP_DNS_RES_PENDING && dnsRes != TCPIP_DNS_RES_NAME_IS_IPADDRESS)
    ad3c:	b2c0      	uxtb	r0, r0
    ad3e:	2802      	cmp	r0, #2
    ad40:	d909      	bls.n	ad56 <TCPIP_COMMAND_Task+0x66>
                (*pTcpipCmdDevice->pCmdApi->print)(icmpCmdIoParam, "Ping: DNS failure for %s\r\n", icmpTargetHost);
    ad42:	4b86      	ldr	r3, [pc, #536]	; (af5c <TCPIP_COMMAND_Task+0x26c>)
    ad44:	681b      	ldr	r3, [r3, #0]
    ad46:	681b      	ldr	r3, [r3, #0]
    ad48:	685b      	ldr	r3, [r3, #4]
    ad4a:	4a83      	ldr	r2, [pc, #524]	; (af58 <TCPIP_COMMAND_Task+0x268>)
    ad4c:	4984      	ldr	r1, [pc, #528]	; (af60 <TCPIP_COMMAND_Task+0x270>)
    ad4e:	4885      	ldr	r0, [pc, #532]	; (af64 <TCPIP_COMMAND_Task+0x274>)
    ad50:	6800      	ldr	r0, [r0, #0]
    ad52:	4798      	blx	r3
    if(killIcmp)
    ad54:	e02b      	b.n	adae <TCPIP_COMMAND_Task+0xbe>
            tcpipCmdStat = TCPIP_PING_CMD_DNS_WAIT;
    ad56:	4b7f      	ldr	r3, [pc, #508]	; (af54 <TCPIP_COMMAND_Task+0x264>)
    ad58:	2202      	movs	r2, #2
    ad5a:	701a      	strb	r2, [r3, #0]
    if(killIcmp)
    ad5c:	e7d8      	b.n	ad10 <TCPIP_COMMAND_Task+0x20>
            dnsRes = TCPIP_DNS_IsNameResolved(icmpTargetHost, &icmpTargetAddr, 0);
    ad5e:	2200      	movs	r2, #0
    ad60:	4981      	ldr	r1, [pc, #516]	; (af68 <TCPIP_COMMAND_Task+0x278>)
    ad62:	487d      	ldr	r0, [pc, #500]	; (af58 <TCPIP_COMMAND_Task+0x268>)
    ad64:	f019 fae7 	bl	24336 <TCPIP_DNS_IsNameResolved>
            if(dnsRes == TCPIP_DNS_RES_PENDING)
    ad68:	2801      	cmp	r0, #1
    ad6a:	d0d1      	beq.n	ad10 <TCPIP_COMMAND_Task+0x20>
            else if(dnsRes < 0 )
    ad6c:	2800      	cmp	r0, #0
    ad6e:	da09      	bge.n	ad84 <TCPIP_COMMAND_Task+0x94>
                (*pTcpipCmdDevice->pCmdApi->print)(icmpCmdIoParam, "Ping: DNS failure for %s\r\n", icmpTargetHost);
    ad70:	4b7a      	ldr	r3, [pc, #488]	; (af5c <TCPIP_COMMAND_Task+0x26c>)
    ad72:	681b      	ldr	r3, [r3, #0]
    ad74:	681b      	ldr	r3, [r3, #0]
    ad76:	685b      	ldr	r3, [r3, #4]
    ad78:	4a77      	ldr	r2, [pc, #476]	; (af58 <TCPIP_COMMAND_Task+0x268>)
    ad7a:	4979      	ldr	r1, [pc, #484]	; (af60 <TCPIP_COMMAND_Task+0x270>)
    ad7c:	4879      	ldr	r0, [pc, #484]	; (af64 <TCPIP_COMMAND_Task+0x274>)
    ad7e:	6800      	ldr	r0, [r0, #0]
    ad80:	4798      	blx	r3
    if(killIcmp)
    ad82:	e014      	b.n	adae <TCPIP_COMMAND_Task+0xbe>
            TCPIP_Helper_IPAddressToString(&icmpTargetAddr, icmpTargetAddrStr, sizeof(icmpTargetAddrStr));
    ad84:	2211      	movs	r2, #17
    ad86:	4979      	ldr	r1, [pc, #484]	; (af6c <TCPIP_COMMAND_Task+0x27c>)
    ad88:	4877      	ldr	r0, [pc, #476]	; (af68 <TCPIP_COMMAND_Task+0x278>)
    ad8a:	f013 fd73 	bl	1e874 <TCPIP_Helper_IPAddressToString>
            tcpipCmdStat = TCPIP_PING_CMD_START_PING;            
    ad8e:	4b71      	ldr	r3, [pc, #452]	; (af54 <TCPIP_COMMAND_Task+0x264>)
    ad90:	2203      	movs	r2, #3
    ad92:	701a      	strb	r2, [r3, #0]
    if(killIcmp)
    ad94:	e7bc      	b.n	ad10 <TCPIP_COMMAND_Task+0x20>
            icmpStartTick = 0;  // try to start as quickly as possible
    ad96:	4b76      	ldr	r3, [pc, #472]	; (af70 <TCPIP_COMMAND_Task+0x280>)
    ad98:	2200      	movs	r2, #0
    ad9a:	601a      	str	r2, [r3, #0]
            tcpipCmdStat = TCPIP_PING_CMD_DO_PING;            
    ad9c:	4b6d      	ldr	r3, [pc, #436]	; (af54 <TCPIP_COMMAND_Task+0x264>)
    ad9e:	2204      	movs	r2, #4
    ada0:	701a      	strb	r2, [r3, #0]
            if(icmpReqCount == icmpReqNo)
    ada2:	4b74      	ldr	r3, [pc, #464]	; (af74 <TCPIP_COMMAND_Task+0x284>)
    ada4:	681a      	ldr	r2, [r3, #0]
    ada6:	4b74      	ldr	r3, [pc, #464]	; (af78 <TCPIP_COMMAND_Task+0x288>)
    ada8:	681b      	ldr	r3, [r3, #0]
    adaa:	429a      	cmp	r2, r3
    adac:	d106      	bne.n	adbc <TCPIP_COMMAND_Task+0xcc>
        _PingStop(pTcpipCmdDevice, icmpCmdIoParam);
    adae:	4b6d      	ldr	r3, [pc, #436]	; (af64 <TCPIP_COMMAND_Task+0x274>)
    adb0:	6819      	ldr	r1, [r3, #0]
    adb2:	4b6a      	ldr	r3, [pc, #424]	; (af5c <TCPIP_COMMAND_Task+0x26c>)
    adb4:	6818      	ldr	r0, [r3, #0]
    adb6:	f012 f943 	bl	1d040 <_PingStop>
    adba:	e7a9      	b.n	ad10 <TCPIP_COMMAND_Task+0x20>
            if(SYS_TMR_TickCountGet() - icmpStartTick > (SYS_TMR_TickCounterFrequencyGet() * icmpReqDelay) / 1000)
    adbc:	f017 fa3e 	bl	2223c <SYS_TMR_TickCountGet>
    adc0:	4b6b      	ldr	r3, [pc, #428]	; (af70 <TCPIP_COMMAND_Task+0x280>)
    adc2:	681c      	ldr	r4, [r3, #0]
    adc4:	1b04      	subs	r4, r0, r4
    adc6:	f017 fa61 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    adca:	4b6c      	ldr	r3, [pc, #432]	; (af7c <TCPIP_COMMAND_Task+0x28c>)
    adcc:	681b      	ldr	r3, [r3, #0]
    adce:	fb03 f300 	mul.w	r3, r3, r0
    add2:	486b      	ldr	r0, [pc, #428]	; (af80 <TCPIP_COMMAND_Task+0x290>)
    add4:	fba0 2303 	umull	r2, r3, r0, r3
    add8:	ebb4 1f93 	cmp.w	r4, r3, lsr #6
    addc:	d943      	bls.n	ae66 <TCPIP_COMMAND_Task+0x176>
                cancelReq = icmpReqCount != icmpAckRecv && icmpReqHandle != 0;    // cancel if there is another one ongoing
    adde:	4b65      	ldr	r3, [pc, #404]	; (af74 <TCPIP_COMMAND_Task+0x284>)
    ade0:	681a      	ldr	r2, [r3, #0]
    ade2:	4b68      	ldr	r3, [pc, #416]	; (af84 <TCPIP_COMMAND_Task+0x294>)
    ade4:	681b      	ldr	r3, [r3, #0]
    ade6:	429a      	cmp	r2, r3
    ade8:	d03b      	beq.n	ae62 <TCPIP_COMMAND_Task+0x172>
    adea:	4b67      	ldr	r3, [pc, #412]	; (af88 <TCPIP_COMMAND_Task+0x298>)
    adec:	681b      	ldr	r3, [r3, #0]
    adee:	3300      	adds	r3, #0
    adf0:	bf18      	it	ne
    adf2:	2301      	movne	r3, #1
            if(cancelReq)
    adf4:	2b00      	cmp	r3, #0
    adf6:	d155      	bne.n	aea4 <TCPIP_COMMAND_Task+0x1b4>
            echoRequest.netH = icmpNetH;
    adf8:	4b64      	ldr	r3, [pc, #400]	; (af8c <TCPIP_COMMAND_Task+0x29c>)
    adfa:	681b      	ldr	r3, [r3, #0]
    adfc:	9309      	str	r3, [sp, #36]	; 0x24
            echoRequest.targetAddr = icmpTargetAddr;
    adfe:	4b5a      	ldr	r3, [pc, #360]	; (af68 <TCPIP_COMMAND_Task+0x278>)
    ae00:	681b      	ldr	r3, [r3, #0]
    ae02:	930a      	str	r3, [sp, #40]	; 0x28
            echoRequest.sequenceNumber = ++icmpSequenceNo;
    ae04:	4a62      	ldr	r2, [pc, #392]	; (af90 <TCPIP_COMMAND_Task+0x2a0>)
    ae06:	8813      	ldrh	r3, [r2, #0]
    ae08:	3301      	adds	r3, #1
    ae0a:	b29b      	uxth	r3, r3
    ae0c:	8013      	strh	r3, [r2, #0]
    ae0e:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
            echoRequest.identifier = icmpIdentifier;
    ae12:	4b60      	ldr	r3, [pc, #384]	; (af94 <TCPIP_COMMAND_Task+0x2a4>)
    ae14:	881b      	ldrh	r3, [r3, #0]
    ae16:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
            echoRequest.pData = icmpPingBuff;
    ae1a:	4b5f      	ldr	r3, [pc, #380]	; (af98 <TCPIP_COMMAND_Task+0x2a8>)
    ae1c:	930c      	str	r3, [sp, #48]	; 0x30
            echoRequest.dataSize = icmpPingSize;
    ae1e:	4b5f      	ldr	r3, [pc, #380]	; (af9c <TCPIP_COMMAND_Task+0x2ac>)
    ae20:	681b      	ldr	r3, [r3, #0]
    ae22:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
            echoRequest.callback = CommandPingHandler;
    ae26:	4a5e      	ldr	r2, [pc, #376]	; (afa0 <TCPIP_COMMAND_Task+0x2b0>)
    ae28:	920e      	str	r2, [sp, #56]	; 0x38
                for(ix = 0; ix < icmpPingSize; ix++)
    ae2a:	2b00      	cmp	r3, #0
    ae2c:	dd0a      	ble.n	ae44 <TCPIP_COMMAND_Task+0x154>
    ae2e:	2400      	movs	r4, #0
                uint8_t* pBuff = icmpPingBuff;
    ae30:	4d59      	ldr	r5, [pc, #356]	; (af98 <TCPIP_COMMAND_Task+0x2a8>)
                for(ix = 0; ix < icmpPingSize; ix++)
    ae32:	4e5a      	ldr	r6, [pc, #360]	; (af9c <TCPIP_COMMAND_Task+0x2ac>)
    srand(seed);
}

static __inline__ uint32_t __attribute__((always_inline)) SYS_RANDOM_PseudoGet( void )
{
    return (uint32_t)rand();
    ae34:	f011 fe76 	bl	1cb24 <rand>
                    *pBuff++ = SYS_RANDOM_PseudoGet();
    ae38:	f805 0b01 	strb.w	r0, [r5], #1
                for(ix = 0; ix < icmpPingSize; ix++)
    ae3c:	3401      	adds	r4, #1
    ae3e:	6833      	ldr	r3, [r6, #0]
    ae40:	429c      	cmp	r4, r3
    ae42:	dbf7      	blt.n	ae34 <TCPIP_COMMAND_Task+0x144>
            echoRes = TCPIP_ICMP_EchoRequest (&echoRequest, &icmpReqHandle);
    ae44:	4950      	ldr	r1, [pc, #320]	; (af88 <TCPIP_COMMAND_Task+0x298>)
    ae46:	a809      	add	r0, sp, #36	; 0x24
    ae48:	f00a fe86 	bl	15b58 <TCPIP_ICMP_EchoRequest>
            if(echoRes >= 0 )
    ae4c:	2800      	cmp	r0, #0
    ae4e:	dbae      	blt.n	adae <TCPIP_COMMAND_Task+0xbe>
                icmpStartTick = SYS_TMR_TickCountGet();
    ae50:	f017 f9f4 	bl	2223c <SYS_TMR_TickCountGet>
    ae54:	4b46      	ldr	r3, [pc, #280]	; (af70 <TCPIP_COMMAND_Task+0x280>)
    ae56:	6018      	str	r0, [r3, #0]
                icmpReqCount++;
    ae58:	4a46      	ldr	r2, [pc, #280]	; (af74 <TCPIP_COMMAND_Task+0x284>)
    ae5a:	6813      	ldr	r3, [r2, #0]
    ae5c:	3301      	adds	r3, #1
    ae5e:	6013      	str	r3, [r2, #0]
    if(killIcmp)
    ae60:	e756      	b.n	ad10 <TCPIP_COMMAND_Task+0x20>
                cancelReq = icmpReqCount != icmpAckRecv && icmpReqHandle != 0;    // cancel if there is another one ongoing
    ae62:	2300      	movs	r3, #0
                newReq = true;
    ae64:	e7c6      	b.n	adf4 <TCPIP_COMMAND_Task+0x104>
            else if(icmpReqCount != icmpAckRecv)
    ae66:	4b43      	ldr	r3, [pc, #268]	; (af74 <TCPIP_COMMAND_Task+0x284>)
    ae68:	681a      	ldr	r2, [r3, #0]
    ae6a:	4b46      	ldr	r3, [pc, #280]	; (af84 <TCPIP_COMMAND_Task+0x294>)
    ae6c:	681b      	ldr	r3, [r3, #0]
    ae6e:	429a      	cmp	r2, r3
    ae70:	f43f af4e 	beq.w	ad10 <TCPIP_COMMAND_Task+0x20>
                if(SYS_TMR_TickCountGet() - icmpStartTick > (SYS_TMR_TickCounterFrequencyGet() * TCPIP_STACK_COMMANDS_ICMP_ECHO_TIMEOUT) / 1000)
    ae74:	f017 f9e2 	bl	2223c <SYS_TMR_TickCountGet>
    ae78:	4b3d      	ldr	r3, [pc, #244]	; (af70 <TCPIP_COMMAND_Task+0x280>)
    ae7a:	681c      	ldr	r4, [r3, #0]
    ae7c:	1b04      	subs	r4, r0, r4
    ae7e:	f017 fa05 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    ae82:	f241 3388 	movw	r3, #5000	; 0x1388
    ae86:	fb03 f300 	mul.w	r3, r3, r0
    ae8a:	4a3d      	ldr	r2, [pc, #244]	; (af80 <TCPIP_COMMAND_Task+0x290>)
    ae8c:	fba2 2303 	umull	r2, r3, r2, r3
    ae90:	ebb4 1f93 	cmp.w	r4, r3, lsr #6
    ae94:	f67f af3c 	bls.w	ad10 <TCPIP_COMMAND_Task+0x20>
                    cancelReq = icmpReqHandle != 0;    // cancel if there is another one ongoing
    ae98:	4b3b      	ldr	r3, [pc, #236]	; (af88 <TCPIP_COMMAND_Task+0x298>)
    ae9a:	681b      	ldr	r3, [r3, #0]
    ae9c:	3300      	adds	r3, #0
    ae9e:	bf18      	it	ne
    aea0:	2301      	movne	r3, #1
                    newReq = true;
    aea2:	e7a7      	b.n	adf4 <TCPIP_COMMAND_Task+0x104>
                TCPIP_ICMP_EchoRequestCancel(icmpReqHandle);
    aea4:	4b38      	ldr	r3, [pc, #224]	; (af88 <TCPIP_COMMAND_Task+0x298>)
    aea6:	6818      	ldr	r0, [r3, #0]
    aea8:	f017 fb5e 	bl	22568 <TCPIP_ICMP_EchoRequestCancel>
    aeac:	e7a4      	b.n	adf8 <TCPIP_COMMAND_Task+0x108>
    switch(tcpipCmdStat)
    aeae:	2a08      	cmp	r2, #8
    aeb0:	d01f      	beq.n	aef2 <TCPIP_COMMAND_Task+0x202>
    aeb2:	2a09      	cmp	r2, #9
    aeb4:	f47f af34 	bne.w	ad20 <TCPIP_COMMAND_Task+0x30>
            dnsRes = TCPIP_DNS_IsResolved(dnslookupTargetHost, 0, IP_ADDRESS_TYPE_ANY);
    aeb8:	2200      	movs	r2, #0
    aeba:	4611      	mov	r1, r2
    aebc:	4839      	ldr	r0, [pc, #228]	; (afa4 <TCPIP_COMMAND_Task+0x2b4>)
    aebe:	f018 faa8 	bl	23412 <TCPIP_DNS_IsResolved>
    aec2:	4605      	mov	r5, r0
            timeout = (SYS_TMR_TickCountGet() - dnsLookUpStartTick)/SYS_TMR_TickCounterFrequencyGet();
    aec4:	f017 f9ba 	bl	2223c <SYS_TMR_TickCountGet>
    aec8:	4b37      	ldr	r3, [pc, #220]	; (afa8 <TCPIP_COMMAND_Task+0x2b8>)
    aeca:	681c      	ldr	r4, [r3, #0]
    aecc:	1b04      	subs	r4, r0, r4
    aece:	f017 f9dd 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    aed2:	fbb4 f0f0 	udiv	r0, r4, r0
            if(timeout >= (TCPIP_DNS_CLIENT_SERVER_TMO/2))
    aed6:	281d      	cmp	r0, #29
    aed8:	d929      	bls.n	af2e <TCPIP_COMMAND_Task+0x23e>
                (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "DNS Lookup: request timeout.\r\n");
    aeda:	4b20      	ldr	r3, [pc, #128]	; (af5c <TCPIP_COMMAND_Task+0x26c>)
    aedc:	681b      	ldr	r3, [r3, #0]
    aede:	681b      	ldr	r3, [r3, #0]
    aee0:	685b      	ldr	r3, [r3, #4]
    aee2:	4932      	ldr	r1, [pc, #200]	; (afac <TCPIP_COMMAND_Task+0x2bc>)
    aee4:	4a32      	ldr	r2, [pc, #200]	; (afb0 <TCPIP_COMMAND_Task+0x2c0>)
    aee6:	6810      	ldr	r0, [r2, #0]
    aee8:	4798      	blx	r3
                tcpipCmdStat = TCPIP_CMD_STAT_IDLE;
    aeea:	4b1a      	ldr	r3, [pc, #104]	; (af54 <TCPIP_COMMAND_Task+0x264>)
    aeec:	2200      	movs	r2, #0
    aeee:	701a      	strb	r2, [r3, #0]
                break;
    aef0:	e716      	b.n	ad20 <TCPIP_COMMAND_Task+0x30>
            dnsRes = TCPIP_DNS_Resolve(dnslookupTargetHost, dnsType);
    aef2:	4b30      	ldr	r3, [pc, #192]	; (afb4 <TCPIP_COMMAND_Task+0x2c4>)
    aef4:	7819      	ldrb	r1, [r3, #0]
    aef6:	482b      	ldr	r0, [pc, #172]	; (afa4 <TCPIP_COMMAND_Task+0x2b4>)
    aef8:	f019 fa18 	bl	2432c <TCPIP_DNS_Resolve>
            if(dnsRes != TCPIP_DNS_RES_OK && dnsRes != TCPIP_DNS_RES_PENDING && dnsRes != TCPIP_DNS_RES_NAME_IS_IPADDRESS)
    aefc:	b2c3      	uxtb	r3, r0
    aefe:	2b02      	cmp	r3, #2
    af00:	d90d      	bls.n	af1e <TCPIP_COMMAND_Task+0x22e>
                (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "DNS Lookup: DNS failure for %s, err: %d\r\n", dnslookupTargetHost, dnsRes);
    af02:	4b16      	ldr	r3, [pc, #88]	; (af5c <TCPIP_COMMAND_Task+0x26c>)
    af04:	681b      	ldr	r3, [r3, #0]
    af06:	681b      	ldr	r3, [r3, #0]
    af08:	685c      	ldr	r4, [r3, #4]
    af0a:	4603      	mov	r3, r0
    af0c:	4a25      	ldr	r2, [pc, #148]	; (afa4 <TCPIP_COMMAND_Task+0x2b4>)
    af0e:	492a      	ldr	r1, [pc, #168]	; (afb8 <TCPIP_COMMAND_Task+0x2c8>)
    af10:	4827      	ldr	r0, [pc, #156]	; (afb0 <TCPIP_COMMAND_Task+0x2c0>)
    af12:	6800      	ldr	r0, [r0, #0]
    af14:	47a0      	blx	r4
                tcpipCmdStat = TCPIP_CMD_STAT_IDLE;
    af16:	4b0f      	ldr	r3, [pc, #60]	; (af54 <TCPIP_COMMAND_Task+0x264>)
    af18:	2200      	movs	r2, #0
    af1a:	701a      	strb	r2, [r3, #0]
                break;
    af1c:	e700      	b.n	ad20 <TCPIP_COMMAND_Task+0x30>
            tcpipCmdStat = TCPIP_DNS_LOOKUP_CMD_WAIT;
    af1e:	4b0d      	ldr	r3, [pc, #52]	; (af54 <TCPIP_COMMAND_Task+0x264>)
    af20:	2209      	movs	r2, #9
    af22:	701a      	strb	r2, [r3, #0]
            dnsLookUpStartTick = SYS_TMR_TickCountGet();
    af24:	f017 f98a 	bl	2223c <SYS_TMR_TickCountGet>
    af28:	4b1f      	ldr	r3, [pc, #124]	; (afa8 <TCPIP_COMMAND_Task+0x2b8>)
    af2a:	6018      	str	r0, [r3, #0]
            break;
    af2c:	e6f8      	b.n	ad20 <TCPIP_COMMAND_Task+0x30>
            if(dnsRes == TCPIP_DNS_RES_PENDING)
    af2e:	2d01      	cmp	r5, #1
    af30:	f43f aef6 	beq.w	ad20 <TCPIP_COMMAND_Task+0x30>
            else if(dnsRes < 0 )
    af34:	2d00      	cmp	r5, #0
    af36:	da41      	bge.n	afbc <TCPIP_COMMAND_Task+0x2cc>
                (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "DNS Lookup: DNS failure for %s, err: %d\r\n", dnslookupTargetHost, dnsRes);
    af38:	4b08      	ldr	r3, [pc, #32]	; (af5c <TCPIP_COMMAND_Task+0x26c>)
    af3a:	681b      	ldr	r3, [r3, #0]
    af3c:	681b      	ldr	r3, [r3, #0]
    af3e:	685c      	ldr	r4, [r3, #4]
    af40:	462b      	mov	r3, r5
    af42:	4a18      	ldr	r2, [pc, #96]	; (afa4 <TCPIP_COMMAND_Task+0x2b4>)
    af44:	491c      	ldr	r1, [pc, #112]	; (afb8 <TCPIP_COMMAND_Task+0x2c8>)
    af46:	481a      	ldr	r0, [pc, #104]	; (afb0 <TCPIP_COMMAND_Task+0x2c0>)
    af48:	6800      	ldr	r0, [r0, #0]
    af4a:	47a0      	blx	r4
                tcpipCmdStat = TCPIP_CMD_STAT_IDLE;
    af4c:	4b01      	ldr	r3, [pc, #4]	; (af54 <TCPIP_COMMAND_Task+0x264>)
    af4e:	2200      	movs	r2, #0
    af50:	701a      	strb	r2, [r3, #0]
                break;
    af52:	e6e5      	b.n	ad20 <TCPIP_COMMAND_Task+0x30>
    af54:	2000ebc3 	.word	0x2000ebc3
    af58:	2000eba4 	.word	0x2000eba4
    af5c:	2000ee14 	.word	0x2000ee14
    af60:	000016a0 	.word	0x000016a0
    af64:	2000edec 	.word	0x2000edec
    af68:	2000ee08 	.word	0x2000ee08
    af6c:	2000ed18 	.word	0x2000ed18
    af70:	2000ee04 	.word	0x2000ee04
    af74:	2000edf4 	.word	0x2000edf4
    af78:	2000ee00 	.word	0x2000ee00
    af7c:	2000edf8 	.word	0x2000edf8
    af80:	10624dd3 	.word	0x10624dd3
    af84:	2000ede8 	.word	0x2000ede8
    af88:	2000edfc 	.word	0x2000edfc
    af8c:	2000edf0 	.word	0x2000edf0
    af90:	2000ef76 	.word	0x2000ef76
    af94:	2000ef72 	.word	0x2000ef72
    af98:	2000ca04 	.word	0x2000ca04
    af9c:	2000ee1c 	.word	0x2000ee1c
    afa0:	00014ff9 	.word	0x00014ff9
    afa4:	2000eb84 	.word	0x2000eb84
    afa8:	2000ede0 	.word	0x2000ede0
    afac:	000016e8 	.word	0x000016e8
    afb0:	2000ede4 	.word	0x2000ede4
    afb4:	2000ed29 	.word	0x2000ed29
    afb8:	000016bc 	.word	0x000016bc
            _TCPIPStackSignalHandlerSetParams(TCPIP_THIS_MODULE_ID, tcpipCmdSignalHandle, 0);
    afbc:	2200      	movs	r2, #0
    afbe:	4b38      	ldr	r3, [pc, #224]	; (b0a0 <TCPIP_COMMAND_Task+0x3b0>)
    afc0:	6819      	ldr	r1, [r3, #0]
    afc2:	201f      	movs	r0, #31
    afc4:	f017 f8ae 	bl	22124 <_TCPIPStackSignalHandlerSetParams>
            tcpipCmdStat = TCPIP_CMD_STAT_IDLE;
    afc8:	4b36      	ldr	r3, [pc, #216]	; (b0a4 <TCPIP_COMMAND_Task+0x3b4>)
    afca:	2200      	movs	r2, #0
    afcc:	701a      	strb	r2, [r3, #0]
            (*pTcpipCmdDevice->pCmdApi->msg)(dnsLookupCmdIoParam, "Lookup Answer:\r\n----------------------\r\n");
    afce:	4b36      	ldr	r3, [pc, #216]	; (b0a8 <TCPIP_COMMAND_Task+0x3b8>)
    afd0:	681b      	ldr	r3, [r3, #0]
    afd2:	681b      	ldr	r3, [r3, #0]
    afd4:	681b      	ldr	r3, [r3, #0]
    afd6:	4935      	ldr	r1, [pc, #212]	; (b0ac <TCPIP_COMMAND_Task+0x3bc>)
    afd8:	4a35      	ldr	r2, [pc, #212]	; (b0b0 <TCPIP_COMMAND_Task+0x3c0>)
    afda:	6810      	ldr	r0, [r2, #0]
    afdc:	4798      	blx	r3
            nIPv4Entries = TCPIP_DNS_GetIPAddressesNumber(dnslookupTargetHost,IP_ADDRESS_TYPE_IPV4);
    afde:	4c35      	ldr	r4, [pc, #212]	; (b0b4 <TCPIP_COMMAND_Task+0x3c4>)
    afe0:	2101      	movs	r1, #1
    afe2:	4620      	mov	r0, r4
    afe4:	f012 f91c 	bl	1d220 <TCPIP_DNS_GetIPAddressesNumber>
    afe8:	4680      	mov	r8, r0
            nIPv6Entries = TCPIP_DNS_GetIPAddressesNumber(dnslookupTargetHost,IP_ADDRESS_TYPE_IPV6);
    afea:	2102      	movs	r1, #2
    afec:	4620      	mov	r0, r4
    afee:	f012 f917 	bl	1d220 <TCPIP_DNS_GetIPAddressesNumber>
    aff2:	4681      	mov	r9, r0
            if((nIPv4Entries == 0) && (nIPv6Entries == 0))
    aff4:	ea58 0300 	orrs.w	r3, r8, r0
    aff8:	d109      	bne.n	b00e <TCPIP_COMMAND_Task+0x31e>
                (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "No Lookup entry for [%s]\r\n",dnslookupTargetHost);
    affa:	4b2b      	ldr	r3, [pc, #172]	; (b0a8 <TCPIP_COMMAND_Task+0x3b8>)
    affc:	681b      	ldr	r3, [r3, #0]
    affe:	681b      	ldr	r3, [r3, #0]
    b000:	685b      	ldr	r3, [r3, #4]
    b002:	4622      	mov	r2, r4
    b004:	492c      	ldr	r1, [pc, #176]	; (b0b8 <TCPIP_COMMAND_Task+0x3c8>)
    b006:	482a      	ldr	r0, [pc, #168]	; (b0b0 <TCPIP_COMMAND_Task+0x3c0>)
    b008:	6800      	ldr	r0, [r0, #0]
    b00a:	4798      	blx	r3
                break;
    b00c:	e688      	b.n	ad20 <TCPIP_COMMAND_Task+0x30>
            if((nIPv4Entries == 0) && (nIPv6Entries == 0))
    b00e:	2400      	movs	r4, #0
    b010:	4625      	mov	r5, r4
                    TCPIP_DNS_GetIPv6Addresses(dnslookupTargetHost, ipv6Index, &ip6Address, 1);
    b012:	4e28      	ldr	r6, [pc, #160]	; (b0b4 <TCPIP_COMMAND_Task+0x3c4>)
                    (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "[%s] AAAA IPv6 Address :%s\r\n",dnslookupTargetHost,addrBuf);
    b014:	f8df b0a4 	ldr.w	fp, [pc, #164]	; b0bc <TCPIP_COMMAND_Task+0x3cc>
    b018:	f50b 7a7c 	add.w	sl, fp, #1008	; 0x3f0
    b01c:	e01c      	b.n	b058 <TCPIP_COMMAND_Task+0x368>
                    TCPIP_DNS_GetIPv4Addresses(dnslookupTargetHost, ipv4Index, &ip4Address, 1);
    b01e:	2301      	movs	r3, #1
    b020:	aa04      	add	r2, sp, #16
    b022:	4629      	mov	r1, r5
    b024:	4630      	mov	r0, r6
    b026:	f018 fea3 	bl	23d70 <TCPIP_DNS_GetIPv4Addresses>
                    (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "[%s] A IPv4 Address : %d.%d.%d.%d\r\n",dnslookupTargetHost,ip4Address.v[0],
    b02a:	4b1f      	ldr	r3, [pc, #124]	; (b0a8 <TCPIP_COMMAND_Task+0x3b8>)
    b02c:	681b      	ldr	r3, [r3, #0]
    b02e:	681b      	ldr	r3, [r3, #0]
    b030:	f89d 2013 	ldrb.w	r2, [sp, #19]
    b034:	9202      	str	r2, [sp, #8]
    b036:	f89d 2012 	ldrb.w	r2, [sp, #18]
    b03a:	9201      	str	r2, [sp, #4]
    b03c:	f89d 2011 	ldrb.w	r2, [sp, #17]
    b040:	9200      	str	r2, [sp, #0]
    b042:	685f      	ldr	r7, [r3, #4]
    b044:	f89d 3010 	ldrb.w	r3, [sp, #16]
    b048:	4632      	mov	r2, r6
    b04a:	f50b 7173 	add.w	r1, fp, #972	; 0x3cc
    b04e:	4818      	ldr	r0, [pc, #96]	; (b0b0 <TCPIP_COMMAND_Task+0x3c0>)
    b050:	6800      	ldr	r0, [r0, #0]
    b052:	47b8      	blx	r7
                    ipv4Index++;
    b054:	3501      	adds	r5, #1
    b056:	b2ed      	uxtb	r5, r5
                if(ipv4Index<nIPv4Entries)
    b058:	45a8      	cmp	r8, r5
    b05a:	dce0      	bgt.n	b01e <TCPIP_COMMAND_Task+0x32e>
                else if(ipv6Index<nIPv6Entries)
    b05c:	45a1      	cmp	r9, r4
    b05e:	f77f ae5f 	ble.w	ad20 <TCPIP_COMMAND_Task+0x30>
                    TCPIP_DNS_GetIPv6Addresses(dnslookupTargetHost, ipv6Index, &ip6Address, 1);
    b062:	2301      	movs	r3, #1
    b064:	aa05      	add	r2, sp, #20
    b066:	4621      	mov	r1, r4
    b068:	4630      	mov	r0, r6
    b06a:	f018 fe89 	bl	23d80 <TCPIP_DNS_GetIPv6Addresses>
                    memset(addrBuf,0,sizeof(addrBuf));
    b06e:	272c      	movs	r7, #44	; 0x2c
    b070:	463a      	mov	r2, r7
    b072:	2100      	movs	r1, #0
    b074:	a809      	add	r0, sp, #36	; 0x24
    b076:	f018 ff13 	bl	23ea0 <memset>
                    TCPIP_Helper_IPv6AddressToString(&ip6Address,(char*)addrBuf,sizeof(addrBuf));
    b07a:	463a      	mov	r2, r7
    b07c:	a909      	add	r1, sp, #36	; 0x24
    b07e:	a805      	add	r0, sp, #20
    b080:	f00e f919 	bl	192b6 <TCPIP_Helper_IPv6AddressToString>
                    (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "[%s] AAAA IPv6 Address :%s\r\n",dnslookupTargetHost,addrBuf);
    b084:	4b08      	ldr	r3, [pc, #32]	; (b0a8 <TCPIP_COMMAND_Task+0x3b8>)
    b086:	681b      	ldr	r3, [r3, #0]
    b088:	681b      	ldr	r3, [r3, #0]
    b08a:	685f      	ldr	r7, [r3, #4]
    b08c:	ab09      	add	r3, sp, #36	; 0x24
    b08e:	4632      	mov	r2, r6
    b090:	4651      	mov	r1, sl
    b092:	4807      	ldr	r0, [pc, #28]	; (b0b0 <TCPIP_COMMAND_Task+0x3c0>)
    b094:	6800      	ldr	r0, [r0, #0]
    b096:	47b8      	blx	r7
                    ipv6Index++;
    b098:	3401      	adds	r4, #1
    b09a:	b2e4      	uxtb	r4, r4
    b09c:	e7dc      	b.n	b058 <TCPIP_COMMAND_Task+0x368>
    b09e:	bf00      	nop
    b0a0:	2000ee18 	.word	0x2000ee18
    b0a4:	2000ebc3 	.word	0x2000ebc3
    b0a8:	2000ee14 	.word	0x2000ee14
    b0ac:	00001708 	.word	0x00001708
    b0b0:	2000ede4 	.word	0x2000ede4
    b0b4:	2000eb84 	.word	0x2000eb84
    b0b8:	00001734 	.word	0x00001734
    b0bc:	00001384 	.word	0x00001384

Disassembly of section .text.GenericTxStart%233:

0000b0c0 <GenericTxStart>:
{
    b0c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b0c4:	4604      	mov	r4, r0
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;    
    b0c6:	f8d0 30c4 	ldr.w	r3, [r0, #196]	; 0xc4
    b0ca:	685f      	ldr	r7, [r3, #4]
    currentTime = SYS_TMR_TickCountGet();
    b0cc:	f017 f8b6 	bl	2223c <SYS_TMR_TickCountGet>
   	if ( currentTime < (pIState->nextTxTime - TCPIP_IPERF_TIMING_ERROR_MARGIN))
    b0d0:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
    b0d4:	4283      	cmp	r3, r0
    b0d6:	f200 81c0 	bhi.w	b45a <GenericTxStart+0x39a>
    b0da:	4605      	mov	r5, r0
    iperfKilled = pIState->stopRequested;
    b0dc:	f894 60cf 	ldrb.w	r6, [r4, #207]	; 0xcf
    if ((iperfKilled == true) ||
    b0e0:	b98e      	cbnz	r6, b106 <GenericTxStart+0x46>
            ((pIState->mDuration != 0u) &&
    b0e2:	68a3      	ldr	r3, [r4, #8]
    if ((iperfKilled == true) ||
    b0e4:	b123      	cbz	r3, b0f0 <GenericTxStart+0x30>
             (currentTime > (pIState->startTime + pIState->mDuration))) ||
    b0e6:	f8d4 2088 	ldr.w	r2, [r4, #136]	; 0x88
    b0ea:	4413      	add	r3, r2
            ((pIState->mDuration != 0u) &&
    b0ec:	4283      	cmp	r3, r0
    b0ee:	d30a      	bcc.n	b106 <GenericTxStart+0x46>
            ((pIState->mAmount != 0u) &&
    b0f0:	6860      	ldr	r0, [r4, #4]
             (currentTime > (pIState->startTime + pIState->mDuration))) ||
    b0f2:	b158      	cbz	r0, b10c <GenericTxStart+0x4c>
             (pIState->totalLen > pIState->mAmount)))
    b0f4:	f000 fccc 	bl	ba90 <__aeabi_ui2d>
            ((pIState->mAmount != 0u) &&
    b0f8:	4602      	mov	r2, r0
    b0fa:	460b      	mov	r3, r1
    b0fc:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    b100:	f00a f908 	bl	15314 <__aeabi_dcmpgt>
    b104:	b110      	cbz	r0, b10c <GenericTxStart+0x4c>
        pIState->isLastTransmit = true;
    b106:	2301      	movs	r3, #1
    b108:	f884 30d0 	strb.w	r3, [r4, #208]	; 0xd0
    if ( pIState->pktId == 0 )
    b10c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    b10e:	b973      	cbnz	r3, b12e <GenericTxStart+0x6e>
        pIState->startTime = currentTime;
    b110:	f8c4 5088 	str.w	r5, [r4, #136]	; 0x88
        pIState->lastCheckTime = 	pIState->startTime;
    b114:	f8c4 50a8 	str.w	r5, [r4, #168]	; 0xa8
        pIState->lastCheckPktId = pIState->pktId;
    b118:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
        pIState->lastCheckPktCount = pIState->pktCount;
    b11c:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
    b120:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
        pIState->lastCheckErrorCount = pIState->errorCount;
    b124:	6b22      	ldr	r2, [r4, #48]	; 0x30
    b126:	f8c4 20a0 	str.w	r2, [r4, #160]	; 0xa0
        pIState->nAttempts = 0;
    b12a:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
    pIState->nextTxTime = currentTime + pIState->mPktPeriod;
    b12e:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
    b132:	441d      	add	r5, r3
    b134:	f8c4 5090 	str.w	r5, [r4, #144]	; 0x90
    switch(pIState->mProtocol)
    b138:	7c23      	ldrb	r3, [r4, #16]
    b13a:	2b01      	cmp	r3, #1
    b13c:	d02a      	beq.n	b194 <GenericTxStart+0xd4>
    b13e:	2b02      	cmp	r3, #2
    b140:	f040 80b9 	bne.w	b2b6 <GenericTxStart+0x1f6>
            if( TCPIP_TCP_GetIsReady(pIState->tcpClientSock) > 0u )
    b144:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    b148:	f018 fd75 	bl	23c36 <TCPIP_TCP_GetIsReady>
    b14c:	b9e0      	cbnz	r0, b188 <GenericTxStart+0xc8>
            if ( TCPIP_TCP_WasReset(pIState->tcpClientSock) )
    b14e:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    b152:	f016 fdda 	bl	21d0a <TCPIP_TCP_WasReset>
    b156:	b148      	cbz	r0, b16c <GenericTxStart+0xac>
                (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "\r\niperf: Warning, TCP server disconnect detected\r\n");
    b158:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    b15c:	681b      	ldr	r3, [r3, #0]
    b15e:	681b      	ldr	r3, [r3, #0]
    b160:	49c2      	ldr	r1, [pc, #776]	; (b46c <GenericTxStart+0x3ac>)
    b162:	4638      	mov	r0, r7
    b164:	4798      	blx	r3
                pIState->stopRequested = 1;
    b166:	2301      	movs	r3, #1
    b168:	f884 30cf 	strb.w	r3, [r4, #207]	; 0xcf
            if  (( TCPIP_TCP_PutIsReady(pIState->tcpClientSock) <= pIState->mMSS ) && (!iperfKilled))
    b16c:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    b170:	f018 f942 	bl	233f8 <TCPIP_TCP_PutIsReady>
    b174:	f8b4 30d2 	ldrh.w	r3, [r4, #210]	; 0xd2
    b178:	4283      	cmp	r3, r0
    b17a:	f0c0 809c 	bcc.w	b2b6 <GenericTxStart+0x1f6>
    b17e:	2e00      	cmp	r6, #0
    b180:	f040 8099 	bne.w	b2b6 <GenericTxStart+0x1f6>
                return IPERF_TX_WAIT;
    b184:	4635      	mov	r5, r6
    b186:	e169      	b.n	b45c <GenericTxStart+0x39c>
                TCPIP_TCP_Discard(pIState->tcpClientSock);
    b188:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    b18c:	f017 f944 	bl	22418 <TCPIP_TCP_Discard>
                return IPERF_TX_WAIT;
    b190:	2500      	movs	r5, #0
    b192:	e163      	b.n	b45c <GenericTxStart+0x39c>
            if( TCPIP_UDP_GetIsReady(pIState->udpSock) > 0u )
    b194:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    b198:	f017 f800 	bl	2219c <TCPIP_UDP_GetIsReady>
    b19c:	b938      	cbnz	r0, b1ae <GenericTxStart+0xee>
            for(i = 0, mpIState = gIperfState; i < nIperfSessions; i++, mpIState++)
    b19e:	4bb4      	ldr	r3, [pc, #720]	; (b470 <GenericTxStart+0x3b0>)
    b1a0:	6818      	ldr	r0, [r3, #0]
    b1a2:	2800      	cmp	r0, #0
    b1a4:	dd49      	ble.n	b23a <GenericTxStart+0x17a>
    b1a6:	2300      	movs	r3, #0
    b1a8:	49b2      	ldr	r1, [pc, #712]	; (b474 <GenericTxStart+0x3b4>)
                if(mpIState->waitCount == 3) mpIState->waitCount = 0;
    b1aa:	469c      	mov	ip, r3
    b1ac:	e027      	b.n	b1fe <GenericTxStart+0x13e>
                TCPIP_UDP_Discard(pIState->udpSock);
    b1ae:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    b1b2:	f017 fbc2 	bl	2293a <TCPIP_UDP_Discard>
                return IPERF_TX_WAIT;
    b1b6:	2500      	movs	r5, #0
    b1b8:	e150      	b.n	b45c <GenericTxStart+0x39c>
                        if(mpIState->mTypeOfService == TCPIP_IPV4_RELIABILITY_HIGH || mpIState->mTypeOfService == TCPIP_IPV4_THROUGHPUT_HIGH || mpIState->mTypeOfService == TCPIP_IPV4_TOS_DEFAULT)
    b1ba:	7d0d      	ldrb	r5, [r1, #20]
    b1bc:	2d20      	cmp	r5, #32
    b1be:	d002      	beq.n	b1c6 <GenericTxStart+0x106>
    b1c0:	f015 0fef 	tst.w	r5, #239	; 0xef
    b1c4:	d116      	bne.n	b1f4 <GenericTxStart+0x134>
                            if(mpIState->sockWaitToSend)
    b1c6:	f891 50d4 	ldrb.w	r5, [r1, #212]	; 0xd4
    b1ca:	b19d      	cbz	r5, b1f4 <GenericTxStart+0x134>
                                mpIState->waitCount += 1;
    b1cc:	3201      	adds	r2, #1
    b1ce:	f881 20d5 	strb.w	r2, [r1, #213]	; 0xd5
                                return IPERF_TX_WAIT;
    b1d2:	2500      	movs	r5, #0
    b1d4:	e142      	b.n	b45c <GenericTxStart+0x39c>
                        if(mpIState->mTypeOfService == TCPIP_IPV4_THROUGHPUT_HIGH)
    b1d6:	7d0d      	ldrb	r5, [r1, #20]
    b1d8:	2d10      	cmp	r5, #16
    b1da:	d10b      	bne.n	b1f4 <GenericTxStart+0x134>
                            if(mpIState->sockWaitToSend)
    b1dc:	f891 50d4 	ldrb.w	r5, [r1, #212]	; 0xd4
    b1e0:	b145      	cbz	r5, b1f4 <GenericTxStart+0x134>
                                mpIState->waitCount += 1;
    b1e2:	3201      	adds	r2, #1
    b1e4:	f881 20d5 	strb.w	r2, [r1, #213]	; 0xd5
                                return IPERF_TX_WAIT;
    b1e8:	2500      	movs	r5, #0
    b1ea:	e137      	b.n	b45c <GenericTxStart+0x39c>
                if(mpIState->waitCount == 3) mpIState->waitCount = 0;
    b1ec:	2a03      	cmp	r2, #3
    b1ee:	bf08      	it	eq
    b1f0:	f881 c0d5 	strbeq.w	ip, [r1, #213]	; 0xd5
            for(i = 0, mpIState = gIperfState; i < nIperfSessions; i++, mpIState++)
    b1f4:	3301      	adds	r3, #1
    b1f6:	b2db      	uxtb	r3, r3
    b1f8:	31d8      	adds	r1, #216	; 0xd8
    b1fa:	4283      	cmp	r3, r0
    b1fc:	da1d      	bge.n	b23a <GenericTxStart+0x17a>
    	        if(mpIState == pIState) continue;
    b1fe:	428c      	cmp	r4, r1
    b200:	d0f8      	beq.n	b1f4 <GenericTxStart+0x134>
                if(mpIState->waitCount < 3)    
    b202:	f891 20d5 	ldrb.w	r2, [r1, #213]	; 0xd5
    b206:	2a02      	cmp	r2, #2
    b208:	d8f0      	bhi.n	b1ec <GenericTxStart+0x12c>
                switch(pIState->mTypeOfService)
    b20a:	7d25      	ldrb	r5, [r4, #20]
    b20c:	2d08      	cmp	r5, #8
    b20e:	d0d4      	beq.n	b1ba <GenericTxStart+0xfa>
    b210:	2d20      	cmp	r5, #32
    b212:	d0e0      	beq.n	b1d6 <GenericTxStart+0x116>
    b214:	2d00      	cmp	r5, #0
    b216:	d1e9      	bne.n	b1ec <GenericTxStart+0x12c>
                        if(mpIState->mTypeOfService == TCPIP_IPV4_RELIABILITY_HIGH || mpIState->mTypeOfService == TCPIP_IPV4_THROUGHPUT_HIGH )
    b218:	f891 e014 	ldrb.w	lr, [r1, #20]
    b21c:	f1be 0f20 	cmp.w	lr, #32
    b220:	d002      	beq.n	b228 <GenericTxStart+0x168>
    b222:	f1be 0f10 	cmp.w	lr, #16
    b226:	d1e5      	bne.n	b1f4 <GenericTxStart+0x134>
                            if(mpIState->sockWaitToSend)
    b228:	f891 e0d4 	ldrb.w	lr, [r1, #212]	; 0xd4
    b22c:	f1be 0f00 	cmp.w	lr, #0
    b230:	d0e0      	beq.n	b1f4 <GenericTxStart+0x134>
                                mpIState->waitCount += 1;
    b232:	3201      	adds	r2, #1
    b234:	f881 20d5 	strb.w	r2, [r1, #213]	; 0xd5
                                return IPERF_TX_WAIT;
    b238:	e110      	b.n	b45c <GenericTxStart+0x39c>
            if ( TCPIP_UDP_TxPutIsReady(pIState->udpSock, pIState->mDatagramSize) < pIState->mDatagramSize )
    b23a:	89a1      	ldrh	r1, [r4, #12]
    b23c:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    b240:	f019 f8ca 	bl	243d8 <TCPIP_UDP_TxPutIsReady>
    b244:	68e3      	ldr	r3, [r4, #12]
    b246:	4298      	cmp	r0, r3
    b248:	d22d      	bcs.n	b2a6 <GenericTxStart+0x1e6>
                pIState->sockWaitToSend += 1;
    b24a:	f894 30d4 	ldrb.w	r3, [r4, #212]	; 0xd4
    b24e:	3301      	adds	r3, #1
    b250:	f884 30d4 	strb.w	r3, [r4, #212]	; 0xd4
                if(pIState->txWaitTick == 0)
    b254:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
    b258:	b143      	cbz	r3, b26c <GenericTxStart+0x1ac>
                else if((int32_t)(SYS_TMR_TickCountGet() - pIState->txWaitTick) < 0)
    b25a:	f016 ffef 	bl	2223c <SYS_TMR_TickCountGet>
    b25e:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
    b262:	1ac3      	subs	r3, r0, r3
    b264:	2b00      	cmp	r3, #0
    b266:	da14      	bge.n	b292 <GenericTxStart+0x1d2>
					return IPERF_TX_WAIT;
    b268:	2500      	movs	r5, #0
    b26a:	e0f7      	b.n	b45c <GenericTxStart+0x39c>
                    pIState->txWaitTick = SYS_TMR_TickCountGet() + ((TCPIP_IPERF_TX_WAIT_TMO * SYS_TMR_TickCounterFrequencyGet()) + 999)/1000;
    b26c:	f016 ffe6 	bl	2223c <SYS_TMR_TickCountGet>
    b270:	4605      	mov	r5, r0
    b272:	f017 f80b 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    b276:	2364      	movs	r3, #100	; 0x64
    b278:	fb03 f300 	mul.w	r3, r3, r0
    b27c:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
    b280:	4a7d      	ldr	r2, [pc, #500]	; (b478 <GenericTxStart+0x3b8>)
    b282:	fba2 2303 	umull	r2, r3, r2, r3
    b286:	eb05 1393 	add.w	r3, r5, r3, lsr #6
    b28a:	f8c4 30b4 	str.w	r3, [r4, #180]	; 0xb4
                    return IPERF_TX_WAIT;
    b28e:	2500      	movs	r5, #0
    b290:	e0e4      	b.n	b45c <GenericTxStart+0x39c>
                (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf: Failed to get %d bytes socket TX space\r\n", pIState->mDatagramSize);
    b292:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    b296:	681b      	ldr	r3, [r3, #0]
    b298:	685b      	ldr	r3, [r3, #4]
    b29a:	68e2      	ldr	r2, [r4, #12]
    b29c:	4977      	ldr	r1, [pc, #476]	; (b47c <GenericTxStart+0x3bc>)
    b29e:	4638      	mov	r0, r7
    b2a0:	4798      	blx	r3
                return IPERF_TX_FAIL;
    b2a2:	2502      	movs	r5, #2
    b2a4:	e0da      	b.n	b45c <GenericTxStart+0x39c>
                pIState->txWaitTick = 0;
    b2a6:	2300      	movs	r3, #0
    b2a8:	f8c4 30b4 	str.w	r3, [r4, #180]	; 0xb4
                pIState->sockWaitToSend -= 1;                
    b2ac:	f894 30d4 	ldrb.w	r3, [r4, #212]	; 0xd4
    b2b0:	3b01      	subs	r3, #1
    b2b2:	f884 30d4 	strb.w	r3, [r4, #212]	; 0xd4
    GenericTxHeaderPreparation(pIState, g_bfr, pIState->isLastTransmit);
    b2b6:	f894 10d0 	ldrb.w	r1, [r4, #208]	; 0xd0
    switch ( pIState->mProtocol )
    b2ba:	7c23      	ldrb	r3, [r4, #16]
    b2bc:	2b01      	cmp	r3, #1
    b2be:	f000 808b 	beq.w	b3d8 <GenericTxStart+0x318>
    b2c2:	2b02      	cmp	r3, #2
    b2c4:	f000 808c 	beq.w	b3e0 <GenericTxStart+0x320>
    tClientHdr *pClientHdr = NULL;
    b2c8:	2300      	movs	r3, #0
    tIperfPktInfo *pPktInfo = NULL;
    b2ca:	461d      	mov	r5, r3
    pClientHdr->flags = TCPIP_Helper_htonl( (uint32_t) 0);
    b2cc:	2000      	movs	r0, #0
    b2ce:	6018      	str	r0, [r3, #0]
    pClientHdr->numThreads = TCPIP_Helper_htonl((uint32_t) 1);
    b2d0:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    b2d4:	605a      	str	r2, [r3, #4]
    pClientHdr->mPort = TCPIP_Helper_htonl((uint32_t) pIState->mServerPort);
    b2d6:	f8b4 c012 	ldrh.w	ip, [r4, #18]
    return (((hLong & 0x000000ff) << 24) | ((hLong & 0x0000ff00) << 8) | ((hLong & 0x00ff0000) >> 8) | ((hLong & 0xff000000) >> 24));
    b2da:	ea4f 220c 	mov.w	r2, ip, lsl #8
    b2de:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
    b2e2:	ea42 620c 	orr.w	r2, r2, ip, lsl #24
    b2e6:	609a      	str	r2, [r3, #8]
    pClientHdr->bufferlen = TCPIP_Helper_htonl( (uint32_t) 0);
    b2e8:	60d8      	str	r0, [r3, #12]
    pClientHdr->mWinBand = TCPIP_Helper_htonl(pIState->mTxRate);
    b2ea:	69a2      	ldr	r2, [r4, #24]
    b2ec:	0e10      	lsrs	r0, r2, #24
    b2ee:	ea40 6002 	orr.w	r0, r0, r2, lsl #24
    b2f2:	ea4f 2c02 	mov.w	ip, r2, lsl #8
    b2f6:	f40c 0c7f 	and.w	ip, ip, #16711680	; 0xff0000
    b2fa:	ea40 000c 	orr.w	r0, r0, ip
    b2fe:	0a12      	lsrs	r2, r2, #8
    b300:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
    b304:	4302      	orrs	r2, r0
    b306:	611a      	str	r2, [r3, #16]
    if ( pIState->mAmount != 0u )
    b308:	6860      	ldr	r0, [r4, #4]
    b30a:	2800      	cmp	r0, #0
    b30c:	d06c      	beq.n	b3e8 <GenericTxStart+0x328>
    b30e:	0e02      	lsrs	r2, r0, #24
    b310:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    b314:	ea4f 2c00 	mov.w	ip, r0, lsl #8
    b318:	f40c 0c7f 	and.w	ip, ip, #16711680	; 0xff0000
    b31c:	ea42 020c 	orr.w	r2, r2, ip
    b320:	0a00      	lsrs	r0, r0, #8
    b322:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
    b326:	4302      	orrs	r2, r0
    b328:	615a      	str	r2, [r3, #20]
    if ( isTheLastTransmit == true )
    b32a:	2900      	cmp	r1, #0
    b32c:	d070      	beq.n	b410 <GenericTxStart+0x350>
        pPktInfo->id = - ( (long) (pIState->pktId - pIState->nAttempts) );
    b32e:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
    b332:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    b334:	1a9b      	subs	r3, r3, r2
    b336:	0e1a      	lsrs	r2, r3, #24
    b338:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    b33c:	0219      	lsls	r1, r3, #8
    b33e:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    b342:	430a      	orrs	r2, r1
    b344:	0a1b      	lsrs	r3, r3, #8
    b346:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    b34a:	4313      	orrs	r3, r2
    pPktInfo->id = TCPIP_Helper_htonl(pPktInfo->id);
    b34c:	602b      	str	r3, [r5, #0]
    currentTime = SYS_TMR_TickCountGet();
    b34e:	f016 ff75 	bl	2223c <SYS_TMR_TickCountGet>
    b352:	4680      	mov	r8, r0
    uint32_t tickFreq = SYS_TMR_TickCounterFrequencyGet(); 
    b354:	f016 ff9a 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    pPktInfo->tv_sec = TCPIP_Helper_htonl(currentTime / tickFreq);
    b358:	fbb8 f3f0 	udiv	r3, r8, r0
    b35c:	0e1a      	lsrs	r2, r3, #24
    b35e:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    b362:	0219      	lsls	r1, r3, #8
    b364:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    b368:	430a      	orrs	r2, r1
    b36a:	0a1b      	lsrs	r3, r3, #8
    b36c:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    b370:	4313      	orrs	r3, r2
    b372:	606b      	str	r3, [r5, #4]
    tmp2 = ((pIState->stopTime - pIState->startTime) % tickFreq);
    b374:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
    b378:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    b37c:	1ad3      	subs	r3, r2, r3
    b37e:	fbb3 f2f0 	udiv	r2, r3, r0
    b382:	fb00 3212 	mls	r2, r0, r2, r3
    tmp2 =  tmp2 * 1000 / tickFreq; /* Convert to mSec */
    b386:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    b38a:	fb03 f202 	mul.w	r2, r3, r2
    b38e:	fbb2 f0f0 	udiv	r0, r2, r0
    tmp2 *= 1000;   /* 1000 uSecs per mSec */
    b392:	fb03 f000 	mul.w	r0, r3, r0
    b396:	0e03      	lsrs	r3, r0, #24
    b398:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
    b39c:	0202      	lsls	r2, r0, #8
    b39e:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
    b3a2:	4313      	orrs	r3, r2
    b3a4:	0a00      	lsrs	r0, r0, #8
    b3a6:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
    b3aa:	4318      	orrs	r0, r3
    pPktInfo->tv_usec = TCPIP_Helper_htonl( tmp2 );
    b3ac:	60a8      	str	r0, [r5, #8]
    switch( pIState->mProtocol)
    b3ae:	7c25      	ldrb	r5, [r4, #16]
    b3b0:	2d01      	cmp	r5, #1
    b3b2:	d03a      	beq.n	b42a <GenericTxStart+0x36a>
    b3b4:	2d02      	cmp	r5, #2
    b3b6:	d154      	bne.n	b462 <GenericTxStart+0x3a2>
            pIState->remainingTxData = (pIState->mMSS - MAX_BUFFER);
    b3b8:	f8b4 30d2 	ldrh.w	r3, [r4, #210]	; 0xd2
    b3bc:	3b34      	subs	r3, #52	; 0x34
    b3be:	f8a4 30b0 	strh.w	r3, [r4, #176]	; 0xb0
            if (( TCPIP_TCP_ArrayPut(pIState->tcpClientSock, (uint8_t*) g_bfr, MAX_BUFFER) != MAX_BUFFER ) && (!iperfKilled))
    b3c2:	2234      	movs	r2, #52	; 0x34
    b3c4:	492e      	ldr	r1, [pc, #184]	; (b480 <GenericTxStart+0x3c0>)
    b3c6:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    b3ca:	f006 fff9 	bl	123c0 <TCPIP_TCP_ArrayPut>
    b3ce:	2834      	cmp	r0, #52	; 0x34
    b3d0:	d049      	beq.n	b466 <GenericTxStart+0x3a6>
    b3d2:	b1fe      	cbz	r6, b414 <GenericTxStart+0x354>
    return IPERF_TX_OK;
    b3d4:	2501      	movs	r5, #1
    b3d6:	e041      	b.n	b45c <GenericTxStart+0x39c>
            pClientHdr = (tClientHdr *) (pPktInfo + 1);
    b3d8:	4d29      	ldr	r5, [pc, #164]	; (b480 <GenericTxStart+0x3c0>)
    b3da:	f105 030c 	add.w	r3, r5, #12
    b3de:	e775      	b.n	b2cc <GenericTxStart+0x20c>
            pClientHdr = (tClientHdr *) pData;
    b3e0:	4b27      	ldr	r3, [pc, #156]	; (b480 <GenericTxStart+0x3c0>)
            pPktInfo = (tIperfPktInfo *) (pClientHdr + 1);
    b3e2:	f103 0518 	add.w	r5, r3, #24
    b3e6:	e771      	b.n	b2cc <GenericTxStart+0x20c>
        pClientHdr->mAmount = TCPIP_Helper_htonl( - (long) (pIState->mDuration/10) );
    b3e8:	68a2      	ldr	r2, [r4, #8]
    b3ea:	4826      	ldr	r0, [pc, #152]	; (b484 <GenericTxStart+0x3c4>)
    b3ec:	fba0 2002 	umull	r2, r0, r0, r2
    b3f0:	08c0      	lsrs	r0, r0, #3
    b3f2:	4240      	negs	r0, r0
    b3f4:	0e02      	lsrs	r2, r0, #24
    b3f6:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    b3fa:	ea4f 2c00 	mov.w	ip, r0, lsl #8
    b3fe:	f40c 0c7f 	and.w	ip, ip, #16711680	; 0xff0000
    b402:	ea42 020c 	orr.w	r2, r2, ip
    b406:	0a00      	lsrs	r0, r0, #8
    b408:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
    b40c:	4302      	orrs	r2, r0
    b40e:	e78b      	b.n	b328 <GenericTxStart+0x268>
        pPktInfo->id = pIState->pktId;
    b410:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    b412:	e790      	b.n	b336 <GenericTxStart+0x276>
                (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Socket send failed\r\n");
    b414:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    b418:	681b      	ldr	r3, [r3, #0]
    b41a:	681b      	ldr	r3, [r3, #0]
    b41c:	491a      	ldr	r1, [pc, #104]	; (b488 <GenericTxStart+0x3c8>)
    b41e:	4638      	mov	r0, r7
    b420:	4798      	blx	r3
                pIState->errorCount++;
    b422:	6b23      	ldr	r3, [r4, #48]	; 0x30
    b424:	3301      	adds	r3, #1
    b426:	6323      	str	r3, [r4, #48]	; 0x30
                return IPERF_TX_FAIL;
    b428:	e018      	b.n	b45c <GenericTxStart+0x39c>
            pIState->remainingTxData = (pIState->mDatagramSize - MAX_BUFFER);
    b42a:	68e3      	ldr	r3, [r4, #12]
    b42c:	3b34      	subs	r3, #52	; 0x34
    b42e:	f8a4 30b0 	strh.w	r3, [r4, #176]	; 0xb0
            if ( TCPIP_UDP_ArrayPut(pIState->udpSock, g_bfr, MAX_BUFFER) != MAX_BUFFER )
    b432:	2234      	movs	r2, #52	; 0x34
    b434:	4912      	ldr	r1, [pc, #72]	; (b480 <GenericTxStart+0x3c0>)
    b436:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    b43a:	f013 fafe 	bl	1ea3a <TCPIP_UDP_ArrayPut>
    b43e:	2834      	cmp	r0, #52	; 0x34
    b440:	d00c      	beq.n	b45c <GenericTxStart+0x39c>
                (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Socket send failed\r\n");
    b442:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    b446:	681b      	ldr	r3, [r3, #0]
    b448:	681b      	ldr	r3, [r3, #0]
    b44a:	490f      	ldr	r1, [pc, #60]	; (b488 <GenericTxStart+0x3c8>)
    b44c:	4638      	mov	r0, r7
    b44e:	4798      	blx	r3
                pIState->errorCount++;
    b450:	6b23      	ldr	r3, [r4, #48]	; 0x30
    b452:	3301      	adds	r3, #1
    b454:	6323      	str	r3, [r4, #48]	; 0x30
                return IPERF_TX_FAIL;
    b456:	2502      	movs	r5, #2
    b458:	e000      	b.n	b45c <GenericTxStart+0x39c>
       	return IPERF_TX_WAIT;
    b45a:	2500      	movs	r5, #0
}
    b45c:	4628      	mov	r0, r5
    b45e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return IPERF_TX_OK;
    b462:	2501      	movs	r5, #1
    b464:	e7fa      	b.n	b45c <GenericTxStart+0x39c>
    b466:	2501      	movs	r5, #1
    b468:	e7f8      	b.n	b45c <GenericTxStart+0x39c>
    b46a:	bf00      	nop
    b46c:	00006110 	.word	0x00006110
    b470:	2000ee24 	.word	0x2000ee24
    b474:	2000e380 	.word	0x2000e380
    b478:	10624dd3 	.word	0x10624dd3
    b47c:	00006144 	.word	0x00006144
    b480:	2000ea38 	.word	0x2000ea38
    b484:	cccccccd 	.word	0xcccccccd
    b488:	00006018 	.word	0x00006018

Disassembly of section .text.DRV_PIC32CGMAC_LibRxGetPacket%234:

0000b48c <DRV_PIC32CGMAC_LibRxGetPacket>:
/****************************************************************************
 * Function: DRV_PIC32CGMAC_LibRxGetPacket
 * Summary: extract  RX packet from the RX descriptor
 *****************************************************************************/
DRV_PIC32CGMAC_RESULT DRV_PIC32CGMAC_LibRxGetPacket(DRV_GMAC_DRIVER * pMACDrv, TCPIP_MAC_PACKET** pRxPkt, int* pnBuffs, DRV_GMAC_RXDCPT_STATUS* pRxStat, GMAC_QUE_LIST queueIdx)  
{	
    b48c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b490:	b08b      	sub	sp, #44	; 0x2c
    b492:	f89d 4050 	ldrb.w	r4, [sp, #80]	; 0x50
    b496:	9402      	str	r4, [sp, #8]
 * Summary: Check if 'Buffer Not Available' set by GMAC; if set, clear the BNA status bit
 * Return : True if BNA is set; False for no BNA status
 *****************************************************************************/
static bool _IsBufferNotAvailable(DRV_GMAC_DRIVER * pMACDrv)
{
    if(GMAC_REGS->GMAC_RSR & GMAC_RSR_BNA_Msk ) //Check for BNA error due to shortage of Rx Buffers
    b498:	4cac      	ldr	r4, [pc, #688]	; (b74c <DRV_PIC32CGMAC_LibRxGetPacket+0x2c0>)
    b49a:	6a24      	ldr	r4, [r4, #32]
    b49c:	f014 0f01 	tst.w	r4, #1
    b4a0:	d028      	beq.n	b4f4 <DRV_PIC32CGMAC_LibRxGetPacket+0x68>
    {       
		//Clear GMAC 'Buffer Not Available' Flag			
		GMAC_REGS->GMAC_RSR = GMAC_RSR_BNA_Msk ;             
    b4a2:	2401      	movs	r4, #1
    b4a4:	4da9      	ldr	r5, [pc, #676]	; (b74c <DRV_PIC32CGMAC_LibRxGetPacket+0x2c0>)
    b4a6:	622c      	str	r4, [r5, #32]
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    b4a8:	f3bf 8f5f 	dmb	sy
		__DMB();  
		return true;
    b4ac:	9404      	str	r4, [sp, #16]
	if(!pRxPkt)
    b4ae:	2900      	cmp	r1, #0
    b4b0:	f000 815a 	beq.w	b768 <DRV_PIC32CGMAC_LibRxGetPacket+0x2dc>
    b4b4:	9308      	str	r3, [sp, #32]
    b4b6:	9207      	str	r2, [sp, #28]
    b4b8:	9106      	str	r1, [sp, #24]
    b4ba:	4606      	mov	r6, r0
 * end rx descriptor indexes of valid rx data packet  
 * Return : frame search status
 *****************************************************************************/
static GMAC_RXFRAME_STATE _SearchRxPacket(DRV_GMAC_DRIVER * pMACDrv,DRV_PIC32CGMAC_RX_FRAME_INFO *rx_frame_state, GMAC_QUE_LIST queueIdx)  
{
    DRV_PIC32CGMAC_HW_RXDCPT *pRxDesc = pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc;
    b4bc:	9a02      	ldr	r2, [sp, #8]
    b4be:	4691      	mov	r9, r2
    b4c0:	232c      	movs	r3, #44	; 0x2c
    b4c2:	fb03 0302 	mla	r3, r3, r2, r0
    b4c6:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
    b4ca:	9105      	str	r1, [sp, #20]
    TCPIP_MAC_PACKET* pRxPkt;
    GMAC_RXFRAME_STATE frameState = GMAC_RX_NO_FRAME_STATE;
    uint16_t search_count = 0;
	uint16_t nRxDscCnt =  pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxDescCnt;
    b4cc:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
    b4d0:	eb00 0242 	add.w	r2, r0, r2, lsl #1
    b4d4:	f8b2 70be 	ldrh.w	r7, [r2, #190]	; 0xbe
	uint16_t nRxDescIndex = pMACDrv->sGmacData.gmac_queue[queueIdx].nRxDescIndex;		
    b4d8:	f8b3 40b0 	ldrh.w	r4, [r3, #176]	; 0xb0
	uint16_t rx_index;
	uint16_t nRx_buffer;	
	
	//search the descriptors for valid data frame; search maximum of descriptor count
	while ( search_count < nRxDscCnt)
    b4dc:	2f00      	cmp	r7, #0
    b4de:	f000 8145 	beq.w	b76c <DRV_PIC32CGMAC_LibRxGetPacket+0x2e0>
	DRV_PIC32CGMAC_RX_FRAME_INFO rx_frame_state = {0,0,0};
    b4e2:	2300      	movs	r3, #0
    b4e4:	9301      	str	r3, [sp, #4]
    b4e6:	9303      	str	r3, [sp, #12]
    uint16_t search_count = 0;
    b4e8:	4698      	mov	r8, r3
    GMAC_RXFRAME_STATE frameState = GMAC_RX_NO_FRAME_STATE;
    b4ea:	461d      	mov	r5, r3
                
				//clear all the descriptors before the error				
				while(nRx_buffer--)
				{                  
                    //Get Rx Packet assigned to Rx Descriptor with error
                    pRxPkt = pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[rx_index];
    b4ec:	232c      	movs	r3, #44	; 0x2c
    b4ee:	fb03 0909 	mla	r9, r3, r9, r0
    b4f2:	e078      	b.n	b5e6 <DRV_PIC32CGMAC_LibRxGetPacket+0x15a>
		return false; 
    b4f4:	2400      	movs	r4, #0
    b4f6:	9404      	str	r4, [sp, #16]
    b4f8:	e7d9      	b.n	b4ae <DRV_PIC32CGMAC_LibRxGetPacket+0x22>
                    if(GMAC_RX_SOF_BIT == ((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_status.val) & GMAC_RX_SOF_BIT))
    b4fa:	6859      	ldr	r1, [r3, #4]
    b4fc:	f411 4f80 	tst.w	r1, #16384	; 0x4000
    b500:	d108      	bne.n	b514 <DRV_PIC32CGMAC_LibRxGetPacket+0x88>
                        rx_frame_state->buffer_count++; 
    b502:	9901      	ldr	r1, [sp, #4]
    b504:	3101      	adds	r1, #1
    b506:	b289      	uxth	r1, r1
    b508:	9101      	str	r1, [sp, #4]
                        if(GMAC_RX_EOF_BIT == ((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_status.val) & GMAC_RX_EOF_BIT))
    b50a:	685b      	ldr	r3, [r3, #4]
    b50c:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    b510:	d05a      	beq.n	b5c8 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
    b512:	e13d      	b.n	b790 <DRV_PIC32CGMAC_LibRxGetPacket+0x304>
                        rx_index =  fixed_mod(((rx_frame_state->startIndex) + (rx_frame_state->buffer_count) -1),nRxDscCnt);	
    b514:	9b03      	ldr	r3, [sp, #12]
    b516:	9a01      	ldr	r2, [sp, #4]
    b518:	189d      	adds	r5, r3, r2
    b51a:	1e6b      	subs	r3, r5, #1
 * If both operands are non-negative then the remainder is non-negative;
 * if not, the sign of the remainder is implementation-defined 74).
 */
__STATIC_INLINE int fixed_mod(int a, int b)
{
	int rem = a % b;
    b51c:	fb93 f5f7 	sdiv	r5, r3, r7
    b520:	fb07 3515 	mls	r5, r7, r5, r3

	while (rem < 0)
    b524:	2d00      	cmp	r5, #0
		rem += b;
    b526:	bfb8      	it	lt
    b528:	19ed      	addlt	r5, r5, r7
    b52a:	b2ad      	uxth	r5, r5
                        nRx_buffer = rx_frame_state->buffer_count;
    b52c:	f8dd a004 	ldr.w	sl, [sp, #4]
    b530:	e001      	b.n	b536 <DRV_PIC32CGMAC_LibRxGetPacket+0xaa>
                            GCIRC_DEC(rx_index, nRxDscCnt); 
    b532:	3d01      	subs	r5, #1
    b534:	b2ad      	uxth	r5, r5
                        while(nRx_buffer--)
    b536:	f10a 3aff 	add.w	sl, sl, #4294967295
    b53a:	fa1f fa8a 	uxth.w	sl, sl
    b53e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    b542:	459a      	cmp	sl, r3
    b544:	d025      	beq.n	b592 <DRV_PIC32CGMAC_LibRxGetPacket+0x106>
                            pRxPkt = pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[rx_index];
    b546:	46ab      	mov	fp, r5
    b548:	f8d9 308c 	ldr.w	r3, [r9, #140]	; 0x8c
    b54c:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
                            (pRxPkt->ackFunc)(pRxPkt, pRxPkt->ackParam);
    b550:	6883      	ldr	r3, [r0, #8]
    b552:	68c1      	ldr	r1, [r0, #12]
    b554:	4798      	blx	r3
                            pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[rx_index] = 0; 
    b556:	f8d9 308c 	ldr.w	r3, [r9, #140]	; 0x8c
    b55a:	2200      	movs	r2, #0
    b55c:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
	if(pMACDrv->sGmacData._synchF != 0)
    b560:	6b33      	ldr	r3, [r6, #48]	; 0x30
    b562:	b11b      	cbz	r3, b56c <DRV_PIC32CGMAC_LibRxGetPacket+0xe0>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
    b564:	2105      	movs	r1, #5
    b566:	f106 005c 	add.w	r0, r6, #92	; 0x5c
    b56a:	4798      	blx	r3
                            pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc[rx_index].rx_desc_buffaddr.val &= ~GMAC_RX_ADDRESS_MASK; 
    b56c:	f8d9 2090 	ldr.w	r2, [r9, #144]	; 0x90
    b570:	f852 303b 	ldr.w	r3, [r2, fp, lsl #3]
    b574:	f003 0303 	and.w	r3, r3, #3
    b578:	f842 303b 	str.w	r3, [r2, fp, lsl #3]
	if(pMACDrv->sGmacData._synchF != 0)
    b57c:	6b33      	ldr	r3, [r6, #48]	; 0x30
    b57e:	b11b      	cbz	r3, b588 <DRV_PIC32CGMAC_LibRxGetPacket+0xfc>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_LEAVE);
    b580:	2106      	movs	r1, #6
    b582:	f106 005c 	add.w	r0, r6, #92	; 0x5c
    b586:	4798      	blx	r3
                            GCIRC_DEC(rx_index, nRxDscCnt); 
    b588:	2d00      	cmp	r5, #0
    b58a:	d1d2      	bne.n	b532 <DRV_PIC32CGMAC_LibRxGetPacket+0xa6>
    b58c:	1e7d      	subs	r5, r7, #1
    b58e:	b2ad      	uxth	r5, r5
    b590:	e7d1      	b.n	b536 <DRV_PIC32CGMAC_LibRxGetPacket+0xaa>
                        DRV_PIC32CGMAC_LibRxBuffersAppend(pMACDrv, queueIdx, (rx_frame_state->startIndex), (rx_frame_state->buffer_count));
    b592:	9b01      	ldr	r3, [sp, #4]
    b594:	9a03      	ldr	r2, [sp, #12]
    b596:	9902      	ldr	r1, [sp, #8]
    b598:	4630      	mov	r0, r6
    b59a:	f009 f8b9 	bl	14710 <DRV_PIC32CGMAC_LibRxBuffersAppend>
                        search_count--; 
    b59e:	f108 38ff 	add.w	r8, r8, #4294967295
    b5a2:	fa1f f888 	uxth.w	r8, r8
                        GCIRC_DEC(nRxDescIndex, nRxDscCnt); 
    b5a6:	b91c      	cbnz	r4, b5b0 <DRV_PIC32CGMAC_LibRxGetPacket+0x124>
    b5a8:	1e7c      	subs	r4, r7, #1
    b5aa:	b2a4      	uxth	r4, r4
                        frameState = GMAC_RX_NO_FRAME_STATE;
    b5ac:	2500      	movs	r5, #0
    b5ae:	e00b      	b.n	b5c8 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
                        GCIRC_DEC(nRxDescIndex, nRxDscCnt); 
    b5b0:	3c01      	subs	r4, #1
    b5b2:	b2a4      	uxth	r4, r4
                        frameState = GMAC_RX_NO_FRAME_STATE;
    b5b4:	2500      	movs	r5, #0
    b5b6:	e007      	b.n	b5c8 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
                DRV_PIC32CGMAC_LibRxBuffersAppend(pMACDrv, queueIdx, nRxDescIndex, 1);
    b5b8:	2301      	movs	r3, #1
    b5ba:	4622      	mov	r2, r4
    b5bc:	9902      	ldr	r1, [sp, #8]
    b5be:	4630      	mov	r0, r6
    b5c0:	f009 f8a6 	bl	14710 <DRV_PIC32CGMAC_LibRxBuffersAppend>
    b5c4:	e000      	b.n	b5c8 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
			if(frameState == GMAC_RX_SOF_DETECTED_STATE)
    b5c6:	bb6d      	cbnz	r5, b624 <DRV_PIC32CGMAC_LibRxGetPacket+0x198>
				GCIRC_DEC(nRxDescIndex, nRxDscCnt); 		
			}
		}
		
        // increment rx index and continue search
		GCIRC_INC(nRxDescIndex, nRxDscCnt);
    b5c8:	3401      	adds	r4, #1
    b5ca:	b2a4      	uxth	r4, r4
    b5cc:	42a7      	cmp	r7, r4
    b5ce:	bf98      	it	ls
    b5d0:	2400      	movls	r4, #0
        // when search count exceeded number of rx descriptors, exit the search
		if ((search_count++) >  nRxDscCnt)
    b5d2:	f108 0301 	add.w	r3, r8, #1
    b5d6:	b29b      	uxth	r3, r3
    b5d8:	4547      	cmp	r7, r8
    b5da:	f0c0 80c7 	bcc.w	b76c <DRV_PIC32CGMAC_LibRxGetPacket+0x2e0>
	while ( search_count < nRxDscCnt)
    b5de:	429f      	cmp	r7, r3
    b5e0:	f240 80c4 	bls.w	b76c <DRV_PIC32CGMAC_LibRxGetPacket+0x2e0>
		if ((search_count++) >  nRxDscCnt)
    b5e4:	4698      	mov	r8, r3
		if ((((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_buffaddr.val) & GMAC_RX_OWNERSHIP_BIT) == GMAC_RX_OWNERSHIP_BIT))
    b5e6:	00e2      	lsls	r2, r4, #3
    b5e8:	9805      	ldr	r0, [sp, #20]
    b5ea:	1883      	adds	r3, r0, r2
    b5ec:	f850 1034 	ldr.w	r1, [r0, r4, lsl #3]
    b5f0:	f011 0f01 	tst.w	r1, #1
    b5f4:	d0e7      	beq.n	b5c6 <DRV_PIC32CGMAC_LibRxGetPacket+0x13a>
            if(((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_buffaddr.val) & GMAC_RX_ADDRESS_MASK) != (uint32_t)0)
    b5f6:	f850 1034 	ldr.w	r1, [r0, r4, lsl #3]
    b5fa:	f031 0103 	bics.w	r1, r1, #3
    b5fe:	d0db      	beq.n	b5b8 <DRV_PIC32CGMAC_LibRxGetPacket+0x12c>
                if(frameState == GMAC_RX_NO_FRAME_STATE)
    b600:	2d00      	cmp	r5, #0
    b602:	f47f af7a 	bne.w	b4fa <DRV_PIC32CGMAC_LibRxGetPacket+0x6e>
                    if(GMAC_RX_SOF_BIT == ((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_status.val) & GMAC_RX_SOF_BIT))
    b606:	6859      	ldr	r1, [r3, #4]
    b608:	f411 4f80 	tst.w	r1, #16384	; 0x4000
    b60c:	d0dc      	beq.n	b5c8 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
                        if(GMAC_RX_EOF_BIT == ((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_status.val) & GMAC_RX_EOF_BIT))
    b60e:	685b      	ldr	r3, [r3, #4]
    b610:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    b614:	f040 80b9 	bne.w	b78a <DRV_PIC32CGMAC_LibRxGetPacket+0x2fe>
    b618:	9403      	str	r4, [sp, #12]
                        rx_frame_state->buffer_count = 1; 
    b61a:	2301      	movs	r3, #1
    b61c:	9301      	str	r3, [sp, #4]
                        search_count = 1;  
    b61e:	4698      	mov	r8, r3
                        frameState = GMAC_RX_SOF_DETECTED_STATE;
    b620:	461d      	mov	r5, r3
    b622:	e7d1      	b.n	b5c8 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
				rx_index = fixed_mod(((rx_frame_state->startIndex) + (rx_frame_state->buffer_count) -1),nRxDscCnt);	
    b624:	9b03      	ldr	r3, [sp, #12]
    b626:	9a01      	ldr	r2, [sp, #4]
    b628:	189d      	adds	r5, r3, r2
    b62a:	1e6b      	subs	r3, r5, #1
	int rem = a % b;
    b62c:	fb93 f5f7 	sdiv	r5, r3, r7
    b630:	fb07 3515 	mls	r5, r7, r5, r3
	while (rem < 0)
    b634:	2d00      	cmp	r5, #0
		rem += b;
    b636:	bfb8      	it	lt
    b638:	19ed      	addlt	r5, r5, r7
    b63a:	b2ad      	uxth	r5, r5
				nRx_buffer = rx_frame_state->buffer_count;
    b63c:	f8dd a004 	ldr.w	sl, [sp, #4]
    b640:	e001      	b.n	b646 <DRV_PIC32CGMAC_LibRxGetPacket+0x1ba>
                    GCIRC_DEC(rx_index, nRxDscCnt);
    b642:	3d01      	subs	r5, #1
    b644:	b2ad      	uxth	r5, r5
				while(nRx_buffer--)
    b646:	f10a 3aff 	add.w	sl, sl, #4294967295
    b64a:	fa1f fa8a 	uxth.w	sl, sl
    b64e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    b652:	459a      	cmp	sl, r3
    b654:	d025      	beq.n	b6a2 <DRV_PIC32CGMAC_LibRxGetPacket+0x216>
                    pRxPkt = pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[rx_index];
    b656:	46ab      	mov	fp, r5
    b658:	f8d9 308c 	ldr.w	r3, [r9, #140]	; 0x8c
    b65c:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
                    (pRxPkt->ackFunc)(pRxPkt, pRxPkt->ackParam);	
    b660:	6883      	ldr	r3, [r0, #8]
    b662:	68c1      	ldr	r1, [r0, #12]
    b664:	4798      	blx	r3
					pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[rx_index] = 0;
    b666:	f8d9 308c 	ldr.w	r3, [r9, #140]	; 0x8c
    b66a:	2200      	movs	r2, #0
    b66c:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
	if(pMACDrv->sGmacData._synchF != 0)
    b670:	6b33      	ldr	r3, [r6, #48]	; 0x30
    b672:	b11b      	cbz	r3, b67c <DRV_PIC32CGMAC_LibRxGetPacket+0x1f0>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
    b674:	2105      	movs	r1, #5
    b676:	f106 005c 	add.w	r0, r6, #92	; 0x5c
    b67a:	4798      	blx	r3
					pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc[rx_index].rx_desc_buffaddr.val &= ~GMAC_RX_ADDRESS_MASK; 
    b67c:	f8d9 2090 	ldr.w	r2, [r9, #144]	; 0x90
    b680:	f852 303b 	ldr.w	r3, [r2, fp, lsl #3]
    b684:	f003 0303 	and.w	r3, r3, #3
    b688:	f842 303b 	str.w	r3, [r2, fp, lsl #3]
	if(pMACDrv->sGmacData._synchF != 0)
    b68c:	6b33      	ldr	r3, [r6, #48]	; 0x30
    b68e:	b11b      	cbz	r3, b698 <DRV_PIC32CGMAC_LibRxGetPacket+0x20c>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_LEAVE);
    b690:	2106      	movs	r1, #6
    b692:	f106 005c 	add.w	r0, r6, #92	; 0x5c
    b696:	4798      	blx	r3
                    GCIRC_DEC(rx_index, nRxDscCnt);
    b698:	2d00      	cmp	r5, #0
    b69a:	d1d2      	bne.n	b642 <DRV_PIC32CGMAC_LibRxGetPacket+0x1b6>
    b69c:	1e7d      	subs	r5, r7, #1
    b69e:	b2ad      	uxth	r5, r5
    b6a0:	e7d1      	b.n	b646 <DRV_PIC32CGMAC_LibRxGetPacket+0x1ba>
				DRV_PIC32CGMAC_LibRxBuffersAppend(pMACDrv, queueIdx, (rx_frame_state->startIndex), (rx_frame_state->buffer_count));
    b6a2:	9b01      	ldr	r3, [sp, #4]
    b6a4:	9a03      	ldr	r2, [sp, #12]
    b6a6:	9902      	ldr	r1, [sp, #8]
    b6a8:	4630      	mov	r0, r6
    b6aa:	f009 f831 	bl	14710 <DRV_PIC32CGMAC_LibRxBuffersAppend>
                search_count--; 
    b6ae:	f108 38ff 	add.w	r8, r8, #4294967295
    b6b2:	fa1f f888 	uxth.w	r8, r8
				GCIRC_DEC(nRxDescIndex, nRxDscCnt); 		
    b6b6:	b91c      	cbnz	r4, b6c0 <DRV_PIC32CGMAC_LibRxGetPacket+0x234>
    b6b8:	1e7c      	subs	r4, r7, #1
    b6ba:	b2a4      	uxth	r4, r4
				frameState = GMAC_RX_NO_FRAME_STATE;
    b6bc:	2500      	movs	r5, #0
    b6be:	e783      	b.n	b5c8 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
				GCIRC_DEC(nRxDescIndex, nRxDscCnt); 		
    b6c0:	3c01      	subs	r4, #1
    b6c2:	b2a4      	uxth	r4, r4
				frameState = GMAC_RX_NO_FRAME_STATE;
    b6c4:	2500      	movs	r5, #0
    b6c6:	e77f      	b.n	b5c8 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
	pDseg = (*pRxPkt)->pDSeg; 
	
	if(nRx_buffer)
    {
		//process all the packet buffers
		while(nRx_buffer--) 
    b6c8:	3d01      	subs	r5, #1
    b6ca:	b2ad      	uxth	r5, r5
    b6cc:	f64f 73ff 	movw	r3, #65535	; 0xffff
    b6d0:	429d      	cmp	r5, r3
    b6d2:	d03d      	beq.n	b750 <DRV_PIC32CGMAC_LibRxGetPacket+0x2c4>
		{
            // Segment length based on received frame length and Rx buffer size
			(*pRxPkt)->pDSeg->segLen = (frameSize >= gmac_queue_config.rxBufferSize) ?
    b6d4:	f8da 3000 	ldr.w	r3, [sl]
    b6d8:	691b      	ldr	r3, [r3, #16]
												gmac_queue_config.rxBufferSize :frameSize;
    b6da:	4642      	mov	r2, r8
    b6dc:	45b8      	cmp	r8, r7
    b6de:	bf28      	it	cs
    b6e0:	463a      	movcs	r2, r7
			(*pRxPkt)->pDSeg->segLen = (frameSize >= gmac_queue_config.rxBufferSize) ?
    b6e2:	819a      	strh	r2, [r3, #12]
													
			(*pRxPkt)->pDSeg->segSize = gmac_queue_config.rxBufferSize;
    b6e4:	f8da 3000 	ldr.w	r3, [sl]
    b6e8:	691b      	ldr	r3, [r3, #16]
    b6ea:	f8a3 800e 	strh.w	r8, [r3, #14]
			
			// RX frame bigger than GMAC RX buffer?
			if(frameSize >= gmac_queue_config.rxBufferSize)
    b6ee:	45b8      	cmp	r8, r7
            {
                //more Rx buffers used for Rx packet
				frameSize = frameSize - gmac_queue_config.rxBufferSize;
    b6f0:	bf94      	ite	ls
    b6f2:	eba7 0708 	subls.w	r7, r7, r8
            }
			else
            {   // last Rx buffer of Rx Packet
				frameSize = 0;		
    b6f6:	2700      	movhi	r7, #0
            }
			
			//release the rx packets from GMAC queue
			gmac_queue.pRxPckt[rx_index] = 0; 
    b6f8:	9405      	str	r4, [sp, #20]
    b6fa:	2300      	movs	r3, #0
    b6fc:	f849 3024 	str.w	r3, [r9, r4, lsl #2]
	if(pMACDrv->sGmacData._synchF != 0)
    b700:	6b33      	ldr	r3, [r6, #48]	; 0x30
    b702:	b113      	cbz	r3, b70a <DRV_PIC32CGMAC_LibRxGetPacket+0x27e>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
    b704:	2105      	movs	r1, #5
    b706:	9807      	ldr	r0, [sp, #28]
    b708:	4798      	blx	r3
			
			_DRV_GMAC_RxLock(pMACDrv);
			//clear the buffer address bit-fields
			gmac_queue.pRxDesc[rx_index].rx_desc_buffaddr.val &= ~GMAC_RX_ADDRESS_MASK; 
    b70a:	9a05      	ldr	r2, [sp, #20]
    b70c:	f85b 3032 	ldr.w	r3, [fp, r2, lsl #3]
    b710:	f003 0303 	and.w	r3, r3, #3
    b714:	f84b 3032 	str.w	r3, [fp, r2, lsl #3]
	if(pMACDrv->sGmacData._synchF != 0)
    b718:	6b33      	ldr	r3, [r6, #48]	; 0x30
    b71a:	b113      	cbz	r3, b722 <DRV_PIC32CGMAC_LibRxGetPacket+0x296>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_LEAVE);
    b71c:	2106      	movs	r1, #6
    b71e:	9807      	ldr	r0, [sp, #28]
    b720:	4798      	blx	r3
			_DRV_GMAC_RxUnlock(pMACDrv);

			//more Rx buffers needed for Rx packet
			if(frameSize)
    b722:	2f00      	cmp	r7, #0
    b724:	d0d0      	beq.n	b6c8 <DRV_PIC32CGMAC_LibRxGetPacket+0x23c>
			{
				GCIRC_INC(rx_index, gmac_queue_config.nRxDescCnt);
    b726:	3401      	adds	r4, #1
    b728:	b2a4      	uxth	r4, r4
    b72a:	9b08      	ldr	r3, [sp, #32]
    b72c:	42a3      	cmp	r3, r4
    b72e:	bf98      	it	ls
    b730:	2400      	movls	r4, #0
				
				(*pRxPkt)->pDSeg->next = gmac_queue.pRxPckt[rx_index]->pDSeg;
    b732:	f8da 3000 	ldr.w	r3, [sl]
    b736:	691b      	ldr	r3, [r3, #16]
    b738:	f859 2024 	ldr.w	r2, [r9, r4, lsl #2]
    b73c:	6912      	ldr	r2, [r2, #16]
    b73e:	601a      	str	r2, [r3, #0]
				(*pRxPkt)->pDSeg = (*pRxPkt)->pDSeg->next;	
    b740:	f8da 3000 	ldr.w	r3, [sl]
    b744:	691a      	ldr	r2, [r3, #16]
    b746:	6812      	ldr	r2, [r2, #0]
    b748:	611a      	str	r2, [r3, #16]
    b74a:	e7bd      	b.n	b6c8 <DRV_PIC32CGMAC_LibRxGetPacket+0x23c>
    b74c:	42000800 	.word	0x42000800
			}			
			
		}
			
		// restore to first data segment
		(*pRxPkt)->pDSeg = (TCPIP_MAC_DATA_SEGMENT*)pDseg; 
    b750:	9b06      	ldr	r3, [sp, #24]
    b752:	681b      	ldr	r3, [r3, #0]
    b754:	9a09      	ldr	r2, [sp, #36]	; 0x24
    b756:	611a      	str	r2, [r3, #16]
		
		//allocate new packets in place of used buffers
		DRV_PIC32CGMAC_LibRxBuffersAppend(pMACDrv, queueIdx, rx_frame_state->startIndex, rx_frame_state->buffer_count); 
    b758:	9b01      	ldr	r3, [sp, #4]
    b75a:	9a03      	ldr	r2, [sp, #12]
    b75c:	9902      	ldr	r1, [sp, #8]
    b75e:	4630      	mov	r0, r6
    b760:	f008 ffd6 	bl	14710 <DRV_PIC32CGMAC_LibRxBuffersAppend>
		res = DRV_PIC32CGMAC_RES_OK;
    b764:	2000      	movs	r0, #0
    b766:	e008      	b.n	b77a <DRV_PIC32CGMAC_LibRxGetPacket+0x2ee>
		return res;
    b768:	2001      	movs	r0, #1
    b76a:	e00b      	b.n	b784 <DRV_PIC32CGMAC_LibRxGetPacket+0x2f8>
	pMACDrv->sGmacData.gmac_queue[queueIdx].nRxDescIndex = nRxDescIndex;	
    b76c:	202c      	movs	r0, #44	; 0x2c
    b76e:	9b02      	ldr	r3, [sp, #8]
    b770:	fb00 6603 	mla	r6, r0, r3, r6
    b774:	f8a6 40b0 	strh.w	r4, [r6, #176]	; 0xb0
    DRV_PIC32CGMAC_RESULT   res = DRV_PIC32CGMAC_RES_NO_PACKET;
    b778:	2001      	movs	r0, #1
    if(bna_flag == true)
    b77a:	9b04      	ldr	r3, [sp, #16]
    b77c:	b113      	cbz	r3, b784 <DRV_PIC32CGMAC_LibRxGetPacket+0x2f8>
        GMAC_REGS->GMAC_RSR = GMAC_RSR_BNA_Msk ; 
    b77e:	4b22      	ldr	r3, [pc, #136]	; (b808 <DRV_PIC32CGMAC_LibRxGetPacket+0x37c>)
    b780:	2201      	movs	r2, #1
    b782:	621a      	str	r2, [r3, #32]
} //DRV_PIC32CGMAC_LibRxGetPacket
    b784:	b00b      	add	sp, #44	; 0x2c
    b786:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                        if(GMAC_RX_EOF_BIT == ((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_status.val) & GMAC_RX_EOF_BIT))
    b78a:	9403      	str	r4, [sp, #12]
                        rx_frame_state->buffer_count = 1; 
    b78c:	2301      	movs	r3, #1
    b78e:	9301      	str	r3, [sp, #4]
	pMACDrv->sGmacData.gmac_queue[queueIdx].nRxDescIndex = nRxDescIndex;	
    b790:	232c      	movs	r3, #44	; 0x2c
    b792:	9d02      	ldr	r5, [sp, #8]
    b794:	fb03 6105 	mla	r1, r3, r5, r6
    b798:	f8a1 40b0 	strh.w	r4, [r1, #176]	; 0xb0
		*pRxStat = (pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc[rx_frame_state.endIndex].rx_desc_status);		
    b79c:	f8d1 0090 	ldr.w	r0, [r1, #144]	; 0x90
    b7a0:	4410      	add	r0, r2
    b7a2:	6840      	ldr	r0, [r0, #4]
    b7a4:	9c08      	ldr	r4, [sp, #32]
    b7a6:	6020      	str	r0, [r4, #0]
		*pnBuffs = rx_frame_state.buffer_count;		
    b7a8:	9807      	ldr	r0, [sp, #28]
    b7aa:	9c01      	ldr	r4, [sp, #4]
    b7ac:	6004      	str	r4, [r0, #0]
    DRV_PIC32CGMAC_HW_RXDCPT *pRxDesc = pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc;
    b7ae:	f8d1 1090 	ldr.w	r1, [r1, #144]	; 0x90
    DRV_GMAC_QUEUE gmac_queue = pMACDrv->sGmacData.gmac_queue[queueIdx];
    b7b2:	fb03 f305 	mul.w	r3, r3, r5
    b7b6:	338c      	adds	r3, #140	; 0x8c
    b7b8:	18f0      	adds	r0, r6, r3
    b7ba:	f856 a003 	ldr.w	sl, [r6, r3]
    b7be:	f8d0 b004 	ldr.w	fp, [r0, #4]
    TCPIP_MODULE_GMAC_QUEUE_CONFIG gmac_queue_config = pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx];
    b7c2:	eb05 03c5 	add.w	r3, r5, r5, lsl #3
    b7c6:	005b      	lsls	r3, r3, #1
    b7c8:	33be      	adds	r3, #190	; 0xbe
    b7ca:	18f0      	adds	r0, r6, r3
    b7cc:	5af3      	ldrh	r3, [r6, r3]
    b7ce:	9308      	str	r3, [sp, #32]
    b7d0:	f8b0 800e 	ldrh.w	r8, [r0, #14]
	*pRxPkt = gmac_queue.pRxPckt[rx_frame_state->startIndex]; 
    b7d4:	9b03      	ldr	r3, [sp, #12]
    b7d6:	f85a 3023 	ldr.w	r3, [sl, r3, lsl #2]
    b7da:	9806      	ldr	r0, [sp, #24]
    b7dc:	6003      	str	r3, [r0, #0]
	frameSize = (pRxDesc[rx_frame_state->endIndex].rx_desc_status.val & GMAC_LENGTH_FRAME); 
    b7de:	440a      	add	r2, r1
    b7e0:	6857      	ldr	r7, [r2, #4]
	if(nRx_buffer)
    b7e2:	b90c      	cbnz	r4, b7e8 <DRV_PIC32CGMAC_LibRxGetPacket+0x35c>
	}
	else
    {
        res = DRV_PIC32CGMAC_RES_NO_PACKET;
    b7e4:	2001      	movs	r0, #1
    b7e6:	e7c8      	b.n	b77a <DRV_PIC32CGMAC_LibRxGetPacket+0x2ee>
	frameSize = (pRxDesc[rx_frame_state->endIndex].rx_desc_status.val & GMAC_LENGTH_FRAME); 
    b7e8:	f3c7 070d 	ubfx	r7, r7, #0, #14
	pDseg = (*pRxPkt)->pDSeg; 
    b7ec:	691b      	ldr	r3, [r3, #16]
    b7ee:	9309      	str	r3, [sp, #36]	; 0x24
		while(nRx_buffer--) 
    b7f0:	9b01      	ldr	r3, [sp, #4]
    b7f2:	1e5d      	subs	r5, r3, #1
    b7f4:	b2ad      	uxth	r5, r5
    b7f6:	9c03      	ldr	r4, [sp, #12]
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
    b7f8:	f106 035c 	add.w	r3, r6, #92	; 0x5c
    b7fc:	9307      	str	r3, [sp, #28]
    b7fe:	46d1      	mov	r9, sl
    b800:	f8dd a018 	ldr.w	sl, [sp, #24]
    b804:	e766      	b.n	b6d4 <DRV_PIC32CGMAC_LibRxGetPacket+0x248>
    b806:	bf00      	nop
    b808:	42000800 	.word	0x42000800

Disassembly of section .text%235:

0000b80c <__aeabi_drsub>:
    b80c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
    b810:	e002      	b.n	b818 <__adddf3>
    b812:	bf00      	nop

0000b814 <__aeabi_dsub>:
    b814:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0000b818 <__adddf3>:
    b818:	b530      	push	{r4, r5, lr}
    b81a:	ea4f 0441 	mov.w	r4, r1, lsl #1
    b81e:	ea4f 0543 	mov.w	r5, r3, lsl #1
    b822:	ea94 0f05 	teq	r4, r5
    b826:	bf08      	it	eq
    b828:	ea90 0f02 	teqeq	r0, r2
    b82c:	bf1f      	itttt	ne
    b82e:	ea54 0c00 	orrsne.w	ip, r4, r0
    b832:	ea55 0c02 	orrsne.w	ip, r5, r2
    b836:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
    b83a:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    b83e:	f000 80e2 	beq.w	ba06 <__adddf3+0x1ee>
    b842:	ea4f 5454 	mov.w	r4, r4, lsr #21
    b846:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
    b84a:	bfb8      	it	lt
    b84c:	426d      	neglt	r5, r5
    b84e:	dd0c      	ble.n	b86a <__adddf3+0x52>
    b850:	442c      	add	r4, r5
    b852:	ea80 0202 	eor.w	r2, r0, r2
    b856:	ea81 0303 	eor.w	r3, r1, r3
    b85a:	ea82 0000 	eor.w	r0, r2, r0
    b85e:	ea83 0101 	eor.w	r1, r3, r1
    b862:	ea80 0202 	eor.w	r2, r0, r2
    b866:	ea81 0303 	eor.w	r3, r1, r3
    b86a:	2d36      	cmp	r5, #54	; 0x36
    b86c:	bf88      	it	hi
    b86e:	bd30      	pophi	{r4, r5, pc}
    b870:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    b874:	ea4f 3101 	mov.w	r1, r1, lsl #12
    b878:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
    b87c:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
    b880:	d002      	beq.n	b888 <__adddf3+0x70>
    b882:	4240      	negs	r0, r0
    b884:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    b888:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
    b88c:	ea4f 3303 	mov.w	r3, r3, lsl #12
    b890:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
    b894:	d002      	beq.n	b89c <__adddf3+0x84>
    b896:	4252      	negs	r2, r2
    b898:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    b89c:	ea94 0f05 	teq	r4, r5
    b8a0:	f000 80a7 	beq.w	b9f2 <__adddf3+0x1da>
    b8a4:	f1a4 0401 	sub.w	r4, r4, #1
    b8a8:	f1d5 0e20 	rsbs	lr, r5, #32
    b8ac:	db0d      	blt.n	b8ca <__adddf3+0xb2>
    b8ae:	fa02 fc0e 	lsl.w	ip, r2, lr
    b8b2:	fa22 f205 	lsr.w	r2, r2, r5
    b8b6:	1880      	adds	r0, r0, r2
    b8b8:	f141 0100 	adc.w	r1, r1, #0
    b8bc:	fa03 f20e 	lsl.w	r2, r3, lr
    b8c0:	1880      	adds	r0, r0, r2
    b8c2:	fa43 f305 	asr.w	r3, r3, r5
    b8c6:	4159      	adcs	r1, r3
    b8c8:	e00e      	b.n	b8e8 <__adddf3+0xd0>
    b8ca:	f1a5 0520 	sub.w	r5, r5, #32
    b8ce:	f10e 0e20 	add.w	lr, lr, #32
    b8d2:	2a01      	cmp	r2, #1
    b8d4:	fa03 fc0e 	lsl.w	ip, r3, lr
    b8d8:	bf28      	it	cs
    b8da:	f04c 0c02 	orrcs.w	ip, ip, #2
    b8de:	fa43 f305 	asr.w	r3, r3, r5
    b8e2:	18c0      	adds	r0, r0, r3
    b8e4:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
    b8e8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    b8ec:	d507      	bpl.n	b8fe <__adddf3+0xe6>
    b8ee:	f04f 0e00 	mov.w	lr, #0
    b8f2:	f1dc 0c00 	rsbs	ip, ip, #0
    b8f6:	eb7e 0000 	sbcs.w	r0, lr, r0
    b8fa:	eb6e 0101 	sbc.w	r1, lr, r1
    b8fe:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    b902:	d31b      	bcc.n	b93c <__adddf3+0x124>
    b904:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    b908:	d30c      	bcc.n	b924 <__adddf3+0x10c>
    b90a:	0849      	lsrs	r1, r1, #1
    b90c:	ea5f 0030 	movs.w	r0, r0, rrx
    b910:	ea4f 0c3c 	mov.w	ip, ip, rrx
    b914:	f104 0401 	add.w	r4, r4, #1
    b918:	ea4f 5244 	mov.w	r2, r4, lsl #21
    b91c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
    b920:	f080 809a 	bcs.w	ba58 <__adddf3+0x240>
    b924:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    b928:	bf08      	it	eq
    b92a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    b92e:	f150 0000 	adcs.w	r0, r0, #0
    b932:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    b936:	ea41 0105 	orr.w	r1, r1, r5
    b93a:	bd30      	pop	{r4, r5, pc}
    b93c:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
    b940:	4140      	adcs	r0, r0
    b942:	eb41 0101 	adc.w	r1, r1, r1
    b946:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    b94a:	f1a4 0401 	sub.w	r4, r4, #1
    b94e:	d1e9      	bne.n	b924 <__adddf3+0x10c>
    b950:	f091 0f00 	teq	r1, #0
    b954:	bf04      	itt	eq
    b956:	4601      	moveq	r1, r0
    b958:	2000      	moveq	r0, #0
    b95a:	fab1 f381 	clz	r3, r1
    b95e:	bf08      	it	eq
    b960:	3320      	addeq	r3, #32
    b962:	f1a3 030b 	sub.w	r3, r3, #11
    b966:	f1b3 0220 	subs.w	r2, r3, #32
    b96a:	da0c      	bge.n	b986 <__adddf3+0x16e>
    b96c:	320c      	adds	r2, #12
    b96e:	dd08      	ble.n	b982 <__adddf3+0x16a>
    b970:	f102 0c14 	add.w	ip, r2, #20
    b974:	f1c2 020c 	rsb	r2, r2, #12
    b978:	fa01 f00c 	lsl.w	r0, r1, ip
    b97c:	fa21 f102 	lsr.w	r1, r1, r2
    b980:	e00c      	b.n	b99c <__adddf3+0x184>
    b982:	f102 0214 	add.w	r2, r2, #20
    b986:	bfd8      	it	le
    b988:	f1c2 0c20 	rsble	ip, r2, #32
    b98c:	fa01 f102 	lsl.w	r1, r1, r2
    b990:	fa20 fc0c 	lsr.w	ip, r0, ip
    b994:	bfdc      	itt	le
    b996:	ea41 010c 	orrle.w	r1, r1, ip
    b99a:	4090      	lslle	r0, r2
    b99c:	1ae4      	subs	r4, r4, r3
    b99e:	bfa2      	ittt	ge
    b9a0:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
    b9a4:	4329      	orrge	r1, r5
    b9a6:	bd30      	popge	{r4, r5, pc}
    b9a8:	ea6f 0404 	mvn.w	r4, r4
    b9ac:	3c1f      	subs	r4, #31
    b9ae:	da1c      	bge.n	b9ea <__adddf3+0x1d2>
    b9b0:	340c      	adds	r4, #12
    b9b2:	dc0e      	bgt.n	b9d2 <__adddf3+0x1ba>
    b9b4:	f104 0414 	add.w	r4, r4, #20
    b9b8:	f1c4 0220 	rsb	r2, r4, #32
    b9bc:	fa20 f004 	lsr.w	r0, r0, r4
    b9c0:	fa01 f302 	lsl.w	r3, r1, r2
    b9c4:	ea40 0003 	orr.w	r0, r0, r3
    b9c8:	fa21 f304 	lsr.w	r3, r1, r4
    b9cc:	ea45 0103 	orr.w	r1, r5, r3
    b9d0:	bd30      	pop	{r4, r5, pc}
    b9d2:	f1c4 040c 	rsb	r4, r4, #12
    b9d6:	f1c4 0220 	rsb	r2, r4, #32
    b9da:	fa20 f002 	lsr.w	r0, r0, r2
    b9de:	fa01 f304 	lsl.w	r3, r1, r4
    b9e2:	ea40 0003 	orr.w	r0, r0, r3
    b9e6:	4629      	mov	r1, r5
    b9e8:	bd30      	pop	{r4, r5, pc}
    b9ea:	fa21 f004 	lsr.w	r0, r1, r4
    b9ee:	4629      	mov	r1, r5
    b9f0:	bd30      	pop	{r4, r5, pc}
    b9f2:	f094 0f00 	teq	r4, #0
    b9f6:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
    b9fa:	bf06      	itte	eq
    b9fc:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
    ba00:	3401      	addeq	r4, #1
    ba02:	3d01      	subne	r5, #1
    ba04:	e74e      	b.n	b8a4 <__adddf3+0x8c>
    ba06:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    ba0a:	bf18      	it	ne
    ba0c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    ba10:	d029      	beq.n	ba66 <__adddf3+0x24e>
    ba12:	ea94 0f05 	teq	r4, r5
    ba16:	bf08      	it	eq
    ba18:	ea90 0f02 	teqeq	r0, r2
    ba1c:	d005      	beq.n	ba2a <__adddf3+0x212>
    ba1e:	ea54 0c00 	orrs.w	ip, r4, r0
    ba22:	bf04      	itt	eq
    ba24:	4619      	moveq	r1, r3
    ba26:	4610      	moveq	r0, r2
    ba28:	bd30      	pop	{r4, r5, pc}
    ba2a:	ea91 0f03 	teq	r1, r3
    ba2e:	bf1e      	ittt	ne
    ba30:	2100      	movne	r1, #0
    ba32:	2000      	movne	r0, #0
    ba34:	bd30      	popne	{r4, r5, pc}
    ba36:	ea5f 5c54 	movs.w	ip, r4, lsr #21
    ba3a:	d105      	bne.n	ba48 <__adddf3+0x230>
    ba3c:	0040      	lsls	r0, r0, #1
    ba3e:	4149      	adcs	r1, r1
    ba40:	bf28      	it	cs
    ba42:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
    ba46:	bd30      	pop	{r4, r5, pc}
    ba48:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
    ba4c:	bf3c      	itt	cc
    ba4e:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
    ba52:	bd30      	popcc	{r4, r5, pc}
    ba54:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    ba58:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
    ba5c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    ba60:	f04f 0000 	mov.w	r0, #0
    ba64:	bd30      	pop	{r4, r5, pc}
    ba66:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    ba6a:	bf1a      	itte	ne
    ba6c:	4619      	movne	r1, r3
    ba6e:	4610      	movne	r0, r2
    ba70:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
    ba74:	bf1c      	itt	ne
    ba76:	460b      	movne	r3, r1
    ba78:	4602      	movne	r2, r0
    ba7a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    ba7e:	bf06      	itte	eq
    ba80:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
    ba84:	ea91 0f03 	teqeq	r1, r3
    ba88:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
    ba8c:	bd30      	pop	{r4, r5, pc}
    ba8e:	bf00      	nop

0000ba90 <__aeabi_ui2d>:
    ba90:	f090 0f00 	teq	r0, #0
    ba94:	bf04      	itt	eq
    ba96:	2100      	moveq	r1, #0
    ba98:	4770      	bxeq	lr
    ba9a:	b530      	push	{r4, r5, lr}
    ba9c:	f44f 6480 	mov.w	r4, #1024	; 0x400
    baa0:	f104 0432 	add.w	r4, r4, #50	; 0x32
    baa4:	f04f 0500 	mov.w	r5, #0
    baa8:	f04f 0100 	mov.w	r1, #0
    baac:	e750      	b.n	b950 <__adddf3+0x138>
    baae:	bf00      	nop

0000bab0 <__aeabi_i2d>:
    bab0:	f090 0f00 	teq	r0, #0
    bab4:	bf04      	itt	eq
    bab6:	2100      	moveq	r1, #0
    bab8:	4770      	bxeq	lr
    baba:	b530      	push	{r4, r5, lr}
    babc:	f44f 6480 	mov.w	r4, #1024	; 0x400
    bac0:	f104 0432 	add.w	r4, r4, #50	; 0x32
    bac4:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
    bac8:	bf48      	it	mi
    baca:	4240      	negmi	r0, r0
    bacc:	f04f 0100 	mov.w	r1, #0
    bad0:	e73e      	b.n	b950 <__adddf3+0x138>
    bad2:	bf00      	nop

0000bad4 <__aeabi_f2d>:
    bad4:	0042      	lsls	r2, r0, #1
    bad6:	ea4f 01e2 	mov.w	r1, r2, asr #3
    bada:	ea4f 0131 	mov.w	r1, r1, rrx
    bade:	ea4f 7002 	mov.w	r0, r2, lsl #28
    bae2:	bf1f      	itttt	ne
    bae4:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
    bae8:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    baec:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
    baf0:	4770      	bxne	lr
    baf2:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
    baf6:	bf08      	it	eq
    baf8:	4770      	bxeq	lr
    bafa:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
    bafe:	bf04      	itt	eq
    bb00:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
    bb04:	4770      	bxeq	lr
    bb06:	b530      	push	{r4, r5, lr}
    bb08:	f44f 7460 	mov.w	r4, #896	; 0x380
    bb0c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    bb10:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    bb14:	e71c      	b.n	b950 <__adddf3+0x138>
    bb16:	bf00      	nop

0000bb18 <__aeabi_ul2d>:
    bb18:	ea50 0201 	orrs.w	r2, r0, r1
    bb1c:	bf08      	it	eq
    bb1e:	4770      	bxeq	lr
    bb20:	b530      	push	{r4, r5, lr}
    bb22:	f04f 0500 	mov.w	r5, #0
    bb26:	e00a      	b.n	bb3e <__aeabi_l2d+0x16>

0000bb28 <__aeabi_l2d>:
    bb28:	ea50 0201 	orrs.w	r2, r0, r1
    bb2c:	bf08      	it	eq
    bb2e:	4770      	bxeq	lr
    bb30:	b530      	push	{r4, r5, lr}
    bb32:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
    bb36:	d502      	bpl.n	bb3e <__aeabi_l2d+0x16>
    bb38:	4240      	negs	r0, r0
    bb3a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    bb3e:	f44f 6480 	mov.w	r4, #1024	; 0x400
    bb42:	f104 0432 	add.w	r4, r4, #50	; 0x32
    bb46:	ea5f 5c91 	movs.w	ip, r1, lsr #22
    bb4a:	f43f aed8 	beq.w	b8fe <__adddf3+0xe6>
    bb4e:	f04f 0203 	mov.w	r2, #3
    bb52:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    bb56:	bf18      	it	ne
    bb58:	3203      	addne	r2, #3
    bb5a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    bb5e:	bf18      	it	ne
    bb60:	3203      	addne	r2, #3
    bb62:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
    bb66:	f1c2 0320 	rsb	r3, r2, #32
    bb6a:	fa00 fc03 	lsl.w	ip, r0, r3
    bb6e:	fa20 f002 	lsr.w	r0, r0, r2
    bb72:	fa01 fe03 	lsl.w	lr, r1, r3
    bb76:	ea40 000e 	orr.w	r0, r0, lr
    bb7a:	fa21 f102 	lsr.w	r1, r1, r2
    bb7e:	4414      	add	r4, r2
    bb80:	e6bd      	b.n	b8fe <__adddf3+0xe6>
    bb82:	bf00      	nop

Disassembly of section .text.TCPIP_Helper_StringToIPv6Address%236:

0000bb84 <TCPIP_Helper_StringToIPv6Address>:
  Return Values:
  	true - an IP address was successfully decoded
  	false - no IP address could be found, or the format was incorrect
  ***************************************************************************/
bool TCPIP_Helper_StringToIPv6Address(const char * addStr, IPV6_ADDR * addr)
{
    bb84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bb88:	b099      	sub	sp, #100	; 0x64
    char * endPtr;
    char*  str;
    IPV6_ADDR   convAddr;
    char   str_buff[64 + 1];     // enough space for longest address: 1111:2222:3333:4444:5555:6666:192.250.250.250

    if(addr)
    bb8a:	460d      	mov	r5, r1
    bb8c:	b121      	cbz	r1, bb98 <TCPIP_Helper_StringToIPv6Address+0x14>
    {
        memset(addr, 0, sizeof(*addr));
    bb8e:	2300      	movs	r3, #0
    bb90:	600b      	str	r3, [r1, #0]
    bb92:	604b      	str	r3, [r1, #4]
    bb94:	608b      	str	r3, [r1, #8]
    bb96:	60cb      	str	r3, [r1, #12]
    }

    if(addStr == 0 || (len = strlen(addStr)) == 0)
    bb98:	2800      	cmp	r0, #0
    bb9a:	f000 812f 	beq.w	bdfc <TCPIP_Helper_StringToIPv6Address+0x278>
    bb9e:	4604      	mov	r4, r0
    bba0:	f018 f98e 	bl	23ec0 <strlen>
    bba4:	4603      	mov	r3, r0
    bba6:	b918      	cbnz	r0, bbb0 <TCPIP_Helper_StringToIPv6Address+0x2c>
    {
        return true;
    bba8:	2001      	movs	r0, #1
    {
        memcpy(addr, convAddr.v, sizeof(*addr));
    }

    return true;
}
    bbaa:	b019      	add	sp, #100	; 0x64
    bbac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memset(convAddr.v, 0, sizeof(convAddr));
    bbb0:	2200      	movs	r2, #0
    bbb2:	9211      	str	r2, [sp, #68]	; 0x44
    bbb4:	9212      	str	r2, [sp, #72]	; 0x48
    bbb6:	9213      	str	r2, [sp, #76]	; 0x4c
    bbb8:	9214      	str	r2, [sp, #80]	; 0x50
    while(isspace(*addStr))
    bbba:	7821      	ldrb	r1, [r4, #0]
    bbbc:	4abf      	ldr	r2, [pc, #764]	; (bebc <TCPIP_Helper_StringToIPv6Address+0x338>)
    bbbe:	5c8a      	ldrb	r2, [r1, r2]
    bbc0:	f012 0f08 	tst.w	r2, #8
    bbc4:	d024      	beq.n	bc10 <TCPIP_Helper_StringToIPv6Address+0x8c>
    bbc6:	1c62      	adds	r2, r4, #1
    bbc8:	4420      	add	r0, r4
    bbca:	4ebc      	ldr	r6, [pc, #752]	; (bebc <TCPIP_Helper_StringToIPv6Address+0x338>)
        addStr++;
    bbcc:	4611      	mov	r1, r2
        len--;
    bbce:	1a83      	subs	r3, r0, r2
    bbd0:	3201      	adds	r2, #1
    while(isspace(*addStr))
    bbd2:	780c      	ldrb	r4, [r1, #0]
    bbd4:	5da4      	ldrb	r4, [r4, r6]
    bbd6:	f014 0f08 	tst.w	r4, #8
    bbda:	d1f7      	bne.n	bbcc <TCPIP_Helper_StringToIPv6Address+0x48>
    while(isspace(*(addStr + len - 1)))
    bbdc:	461a      	mov	r2, r3
    bbde:	1e5f      	subs	r7, r3, #1
    bbe0:	19c8      	adds	r0, r1, r7
    bbe2:	5dce      	ldrb	r6, [r1, r7]
    bbe4:	4cb5      	ldr	r4, [pc, #724]	; (bebc <TCPIP_Helper_StringToIPv6Address+0x338>)
    bbe6:	5d34      	ldrb	r4, [r6, r4]
    bbe8:	f014 0f08 	tst.w	r4, #8
    bbec:	d012      	beq.n	bc14 <TCPIP_Helper_StringToIPv6Address+0x90>
    bbee:	f8df c2cc 	ldr.w	ip, [pc, #716]	; bebc <TCPIP_Helper_StringToIPv6Address+0x338>
        len--;
    bbf2:	1e5e      	subs	r6, r3, #1
    bbf4:	4632      	mov	r2, r6
    while(isspace(*(addStr + len - 1)))
    bbf6:	1e9f      	subs	r7, r3, #2
        len--;
    bbf8:	4633      	mov	r3, r6
    while(isspace(*(addStr + len - 1)))
    bbfa:	f810 4d01 	ldrb.w	r4, [r0, #-1]!
    bbfe:	f814 400c 	ldrb.w	r4, [r4, ip]
    bc02:	f014 0f08 	tst.w	r4, #8
    bc06:	d1f4      	bne.n	bbf2 <TCPIP_Helper_StringToIPv6Address+0x6e>
    if(len > sizeof(str_buff) - 1)
    bc08:	2a40      	cmp	r2, #64	; 0x40
    bc0a:	d905      	bls.n	bc18 <TCPIP_Helper_StringToIPv6Address+0x94>
        return false;
    bc0c:	2000      	movs	r0, #0
    bc0e:	e7cc      	b.n	bbaa <TCPIP_Helper_StringToIPv6Address+0x26>
    while(isspace(*addStr))
    bc10:	4621      	mov	r1, r4
    bc12:	e7e3      	b.n	bbdc <TCPIP_Helper_StringToIPv6Address+0x58>
    while(isspace(*(addStr + len - 1)))
    bc14:	461e      	mov	r6, r3
    bc16:	e7f7      	b.n	bc08 <TCPIP_Helper_StringToIPv6Address+0x84>
    strncpy(str_buff, addStr, len);
    bc18:	4668      	mov	r0, sp
    bc1a:	f016 fc49 	bl	224b0 <strncpy>
    str_buff[len] = 0;
    bc1e:	2200      	movs	r2, #0
    bc20:	ab18      	add	r3, sp, #96	; 0x60
    bc22:	4433      	add	r3, r6
    bc24:	f803 2c60 	strb.w	r2, [r3, #-96]
    if (*str == '[')
    bc28:	f89d 3000 	ldrb.w	r3, [sp]
    bc2c:	2b5b      	cmp	r3, #91	; 0x5b
    bc2e:	f000 8086 	beq.w	bd3e <TCPIP_Helper_StringToIPv6Address+0x1ba>
    str = str_buff;
    bc32:	466c      	mov	r4, sp
    while(isspace(*str))
    bc34:	7822      	ldrb	r2, [r4, #0]
    bc36:	4ba1      	ldr	r3, [pc, #644]	; (bebc <TCPIP_Helper_StringToIPv6Address+0x338>)
    bc38:	5cd3      	ldrb	r3, [r2, r3]
    bc3a:	f013 0f08 	tst.w	r3, #8
    bc3e:	d00a      	beq.n	bc56 <TCPIP_Helper_StringToIPv6Address+0xd2>
    bc40:	1c63      	adds	r3, r4, #1
    bc42:	19a1      	adds	r1, r4, r6
    bc44:	489d      	ldr	r0, [pc, #628]	; (bebc <TCPIP_Helper_StringToIPv6Address+0x338>)
        str++;
    bc46:	461c      	mov	r4, r3
        len--;
    bc48:	1ace      	subs	r6, r1, r3
    bc4a:	3301      	adds	r3, #1
    while(isspace(*str))
    bc4c:	7822      	ldrb	r2, [r4, #0]
    bc4e:	5c12      	ldrb	r2, [r2, r0]
    bc50:	f012 0f08 	tst.w	r2, #8
    bc54:	d1f7      	bne.n	bc46 <TCPIP_Helper_StringToIPv6Address+0xc2>
    endPtr = str + len;
    bc56:	4426      	add	r6, r4
    bc58:	9615      	str	r6, [sp, #84]	; 0x54
    while(isspace(*(endPtr - 1)))
    bc5a:	f816 2c01 	ldrb.w	r2, [r6, #-1]
    bc5e:	4b97      	ldr	r3, [pc, #604]	; (bebc <TCPIP_Helper_StringToIPv6Address+0x338>)
    bc60:	5cd3      	ldrb	r3, [r2, r3]
    bc62:	f013 0f08 	tst.w	r3, #8
    bc66:	d009      	beq.n	bc7c <TCPIP_Helper_StringToIPv6Address+0xf8>
    bc68:	1e73      	subs	r3, r6, #1
    bc6a:	4994      	ldr	r1, [pc, #592]	; (bebc <TCPIP_Helper_StringToIPv6Address+0x338>)
        endPtr--;
    bc6c:	461e      	mov	r6, r3
    bc6e:	9315      	str	r3, [sp, #84]	; 0x54
    while(isspace(*(endPtr - 1)))
    bc70:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
    bc74:	5c52      	ldrb	r2, [r2, r1]
    bc76:	f012 0f08 	tst.w	r2, #8
    bc7a:	d1f7      	bne.n	bc6c <TCPIP_Helper_StringToIPv6Address+0xe8>
    *endPtr = 0;
    bc7c:	2300      	movs	r3, #0
    bc7e:	7033      	strb	r3, [r6, #0]
    if(*str == ':')
    bc80:	7823      	ldrb	r3, [r4, #0]
    bc82:	2b3a      	cmp	r3, #58	; 0x3a
    bc84:	d065      	beq.n	bd52 <TCPIP_Helper_StringToIPv6Address+0x1ce>
    uint8_t shiftIndex = 0xFF;
    bc86:	27ff      	movs	r7, #255	; 0xff
    if(!isxdigit(*str))
    bc88:	7826      	ldrb	r6, [r4, #0]
    bc8a:	4b8c      	ldr	r3, [pc, #560]	; (bebc <TCPIP_Helper_StringToIPv6Address+0x338>)
    bc8c:	5cf3      	ldrb	r3, [r6, r3]
    bc8e:	f013 0f44 	tst.w	r3, #68	; 0x44
    bc92:	f000 80b9 	beq.w	be08 <TCPIP_Helper_StringToIPv6Address+0x284>
    i = *str++;
    bc96:	3401      	adds	r4, #1
    while (i != ':' && i != 0u && i != '.' && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
    bc98:	2e3a      	cmp	r6, #58	; 0x3a
    bc9a:	d074      	beq.n	bd86 <TCPIP_Helper_StringToIPv6Address+0x202>
    bc9c:	f016 02df 	ands.w	r2, r6, #223	; 0xdf
    bca0:	d072      	beq.n	bd88 <TCPIP_Helper_StringToIPv6Address+0x204>
    bca2:	f1a6 032e 	sub.w	r3, r6, #46	; 0x2e
    bca6:	b2db      	uxtb	r3, r3
    bca8:	2b01      	cmp	r3, #1
    bcaa:	f240 80a3 	bls.w	bdf4 <TCPIP_Helper_StringToIPv6Address+0x270>
    bcae:	2e0d      	cmp	r6, #13
    bcb0:	f000 80a2 	beq.w	bdf8 <TCPIP_Helper_StringToIPv6Address+0x274>
    bcb4:	f1a6 0309 	sub.w	r3, r6, #9
    bcb8:	b2db      	uxtb	r3, r3
    bcba:	2b01      	cmp	r3, #1
    bcbc:	bf98      	it	ls
    bcbe:	2200      	movls	r2, #0
    bcc0:	d962      	bls.n	bd88 <TCPIP_Helper_StringToIPv6Address+0x204>
    currentWord = 0;
    bcc2:	f04f 0900 	mov.w	r9, #0
    int conv_base = 16;
    bcc6:	f04f 0b10 	mov.w	fp, #16
        subString[j] = 0;
    bcca:	46ca      	mov	sl, r9
        while (i != ':' && i != 0u && i != '.' && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
    bccc:	2e3a      	cmp	r6, #58	; 0x3a
    bcce:	f000 8100 	beq.w	bed2 <TCPIP_Helper_StringToIPv6Address+0x34e>
    bcd2:	2e00      	cmp	r6, #0
    bcd4:	f000 80a6 	beq.w	be24 <TCPIP_Helper_StringToIPv6Address+0x2a0>
    bcd8:	2e2e      	cmp	r6, #46	; 0x2e
    bcda:	f000 80f1 	beq.w	bec0 <TCPIP_Helper_StringToIPv6Address+0x33c>
    bcde:	2e2f      	cmp	r6, #47	; 0x2f
    bce0:	f000 80e1 	beq.w	bea6 <TCPIP_Helper_StringToIPv6Address+0x322>
    bce4:	2e0d      	cmp	r6, #13
    bce6:	f000 80e0 	beq.w	beaa <TCPIP_Helper_StringToIPv6Address+0x326>
    bcea:	2e0a      	cmp	r6, #10
    bcec:	f000 80df 	beq.w	beae <TCPIP_Helper_StringToIPv6Address+0x32a>
    bcf0:	2e20      	cmp	r6, #32
    bcf2:	f000 80de 	beq.w	beb2 <TCPIP_Helper_StringToIPv6Address+0x32e>
    bcf6:	2e09      	cmp	r6, #9
    bcf8:	f000 80dd 	beq.w	beb6 <TCPIP_Helper_StringToIPv6Address+0x332>
    bcfc:	aa16      	add	r2, sp, #88	; 0x58
    bcfe:	2301      	movs	r3, #1
            subString[j++] = i;
    bd00:	fa5f f883 	uxtb.w	r8, r3
    bd04:	f802 6b01 	strb.w	r6, [r2], #1
            i = *str++;
    bd08:	f814 6b01 	ldrb.w	r6, [r4], #1
        while (i != ':' && i != 0u && i != '.' && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
    bd0c:	2e3a      	cmp	r6, #58	; 0x3a
    bd0e:	f000 80e1 	beq.w	bed4 <TCPIP_Helper_StringToIPv6Address+0x350>
    bd12:	2e00      	cmp	r6, #0
    bd14:	f000 8087 	beq.w	be26 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    bd18:	2e2e      	cmp	r6, #46	; 0x2e
    bd1a:	f000 80d2 	beq.w	bec2 <TCPIP_Helper_StringToIPv6Address+0x33e>
    bd1e:	2e2f      	cmp	r6, #47	; 0x2f
    bd20:	f000 8081 	beq.w	be26 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    bd24:	2e0d      	cmp	r6, #13
    bd26:	d07e      	beq.n	be26 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    bd28:	2e0a      	cmp	r6, #10
    bd2a:	d07c      	beq.n	be26 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    bd2c:	2e20      	cmp	r6, #32
    bd2e:	d07a      	beq.n	be26 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    bd30:	2e09      	cmp	r6, #9
    bd32:	d078      	beq.n	be26 <TCPIP_Helper_StringToIPv6Address+0x2a2>
            if (j == 4)
    bd34:	3301      	adds	r3, #1
    bd36:	2b05      	cmp	r3, #5
    bd38:	d1e2      	bne.n	bd00 <TCPIP_Helper_StringToIPv6Address+0x17c>
                return false;
    bd3a:	2000      	movs	r0, #0
    bd3c:	e735      	b.n	bbaa <TCPIP_Helper_StringToIPv6Address+0x26>
        if(str[len - 1] != ']')
    bd3e:	f81d 3007 	ldrb.w	r3, [sp, r7]
    bd42:	2b5d      	cmp	r3, #93	; 0x5d
    bd44:	d15c      	bne.n	be00 <TCPIP_Helper_StringToIPv6Address+0x27c>
        str[len - 1] = 0;   // delete trailing ]
    bd46:	f80d 2007 	strb.w	r2, [sp, r7]
        len--;
    bd4a:	3e02      	subs	r6, #2
        str++;  // skip leading [
    bd4c:	f10d 0401 	add.w	r4, sp, #1
    bd50:	e770      	b.n	bc34 <TCPIP_Helper_StringToIPv6Address+0xb0>
        if(*++str != ':')
    bd52:	7863      	ldrb	r3, [r4, #1]
    bd54:	2b3a      	cmp	r3, #58	; 0x3a
    bd56:	d155      	bne.n	be04 <TCPIP_Helper_StringToIPv6Address+0x280>
        str++;
    bd58:	3402      	adds	r4, #2
        shiftIndex = 0;
    bd5a:	2700      	movs	r7, #0
    bd5c:	e794      	b.n	bc88 <TCPIP_Helper_StringToIPv6Address+0x104>
            if (*str == ':')
    bd5e:	7823      	ldrb	r3, [r4, #0]
    bd60:	2b3a      	cmp	r3, #58	; 0x3a
    bd62:	d002      	beq.n	bd6a <TCPIP_Helper_StringToIPv6Address+0x1e6>
        i = *str++;
    bd64:	f814 6b01 	ldrb.w	r6, [r4], #1
    bd68:	e088      	b.n	be7c <TCPIP_Helper_StringToIPv6Address+0x2f8>
                if (shiftIndex == 0xFF)
    bd6a:	2fff      	cmp	r7, #255	; 0xff
    bd6c:	d150      	bne.n	be10 <TCPIP_Helper_StringToIPv6Address+0x28c>
                i = *str++;
    bd6e:	3401      	adds	r4, #1
        convAddr.w[currentWord++] = TCPIP_Helper_htons(convertedValue);
    bd70:	4617      	mov	r7, r2
    bd72:	e07e      	b.n	be72 <TCPIP_Helper_StringToIPv6Address+0x2ee>
    if(currentWord > 8 || (currentWord < 8 && shiftIndex == 0xff))
    bd74:	2a08      	cmp	r2, #8
    bd76:	d901      	bls.n	bd7c <TCPIP_Helper_StringToIPv6Address+0x1f8>
        return false;
    bd78:	2000      	movs	r0, #0
    bd7a:	e716      	b.n	bbaa <TCPIP_Helper_StringToIPv6Address+0x26>
    if(currentWord > 8 || (currentWord < 8 && shiftIndex == 0xff))
    bd7c:	2a07      	cmp	r2, #7
    bd7e:	d903      	bls.n	bd88 <TCPIP_Helper_StringToIPv6Address+0x204>
    if (shiftIndex != 0xFF)
    bd80:	2fff      	cmp	r7, #255	; 0xff
    bd82:	d02e      	beq.n	bde2 <TCPIP_Helper_StringToIPv6Address+0x25e>
    bd84:	e002      	b.n	bd8c <TCPIP_Helper_StringToIPv6Address+0x208>
    while (i != ':' && i != 0u && i != '.' && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
    bd86:	2200      	movs	r2, #0
    if(currentWord > 8 || (currentWord < 8 && shiftIndex == 0xff))
    bd88:	2fff      	cmp	r7, #255	; 0xff
    bd8a:	d045      	beq.n	be18 <TCPIP_Helper_StringToIPv6Address+0x294>
        for (i = 7, j = currentWord - 1; (int8_t)j >= (int8_t)shiftIndex; i--, j--)
    bd8c:	1e53      	subs	r3, r2, #1
    bd8e:	b2db      	uxtb	r3, r3
    bd90:	b27c      	sxtb	r4, r7
    bd92:	b259      	sxtb	r1, r3
    bd94:	42a1      	cmp	r1, r4
    bd96:	db13      	blt.n	bdc0 <TCPIP_Helper_StringToIPv6Address+0x23c>
            convAddr.w[i] = convAddr.w[j];
    bd98:	f1c2 0608 	rsb	r6, r2, #8
    bd9c:	a918      	add	r1, sp, #96	; 0x60
    bd9e:	eb01 0143 	add.w	r1, r1, r3, lsl #1
    bda2:	f831 0c1c 	ldrh.w	r0, [r1, #-28]
    bda6:	1999      	adds	r1, r3, r6
    bda8:	b2c9      	uxtb	r1, r1
    bdaa:	f10d 0c60 	add.w	ip, sp, #96	; 0x60
    bdae:	eb0c 0141 	add.w	r1, ip, r1, lsl #1
    bdb2:	f821 0c1c 	strh.w	r0, [r1, #-28]
        for (i = 7, j = currentWord - 1; (int8_t)j >= (int8_t)shiftIndex; i--, j--)
    bdb6:	3b01      	subs	r3, #1
    bdb8:	b2db      	uxtb	r3, r3
    bdba:	b259      	sxtb	r1, r3
    bdbc:	428c      	cmp	r4, r1
    bdbe:	dded      	ble.n	bd9c <TCPIP_Helper_StringToIPv6Address+0x218>
        for (i = shiftIndex; i <= 7 - (currentWord - shiftIndex); i++)
    bdc0:	4639      	mov	r1, r7
    bdc2:	1bd3      	subs	r3, r2, r7
    bdc4:	f1c3 0307 	rsb	r3, r3, #7
    bdc8:	429f      	cmp	r7, r3
    bdca:	dc0a      	bgt.n	bde2 <TCPIP_Helper_StringToIPv6Address+0x25e>
            convAddr.w[i] = 0x0000;
    bdcc:	2200      	movs	r2, #0
    bdce:	a818      	add	r0, sp, #96	; 0x60
    bdd0:	eb00 0141 	add.w	r1, r0, r1, lsl #1
    bdd4:	f821 2c1c 	strh.w	r2, [r1, #-28]
        for (i = shiftIndex; i <= 7 - (currentWord - shiftIndex); i++)
    bdd8:	3701      	adds	r7, #1
    bdda:	b2ff      	uxtb	r7, r7
    bddc:	4639      	mov	r1, r7
    bdde:	429f      	cmp	r7, r3
    bde0:	ddf5      	ble.n	bdce <TCPIP_Helper_StringToIPv6Address+0x24a>
    if(addr)
    bde2:	b1dd      	cbz	r5, be1c <TCPIP_Helper_StringToIPv6Address+0x298>
        memcpy(addr, convAddr.v, sizeof(*addr));
    bde4:	ac11      	add	r4, sp, #68	; 0x44
    bde6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    bde8:	6028      	str	r0, [r5, #0]
    bdea:	6069      	str	r1, [r5, #4]
    bdec:	60aa      	str	r2, [r5, #8]
    bdee:	60eb      	str	r3, [r5, #12]
    return true;
    bdf0:	2001      	movs	r0, #1
    bdf2:	e6da      	b.n	bbaa <TCPIP_Helper_StringToIPv6Address+0x26>
    while (i != ':' && i != 0u && i != '.' && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
    bdf4:	2200      	movs	r2, #0
    bdf6:	e7c7      	b.n	bd88 <TCPIP_Helper_StringToIPv6Address+0x204>
    bdf8:	2200      	movs	r2, #0
    bdfa:	e7c5      	b.n	bd88 <TCPIP_Helper_StringToIPv6Address+0x204>
        return true;
    bdfc:	2001      	movs	r0, #1
    bdfe:	e6d4      	b.n	bbaa <TCPIP_Helper_StringToIPv6Address+0x26>
            return false;
    be00:	2000      	movs	r0, #0
    be02:	e6d2      	b.n	bbaa <TCPIP_Helper_StringToIPv6Address+0x26>
            return false;
    be04:	2000      	movs	r0, #0
    be06:	e6d0      	b.n	bbaa <TCPIP_Helper_StringToIPv6Address+0x26>
        return false;
    be08:	2000      	movs	r0, #0
    be0a:	e6ce      	b.n	bbaa <TCPIP_Helper_StringToIPv6Address+0x26>
            return false;
    be0c:	2000      	movs	r0, #0
    be0e:	e6cc      	b.n	bbaa <TCPIP_Helper_StringToIPv6Address+0x26>
                    return false;
    be10:	2000      	movs	r0, #0
    be12:	e6ca      	b.n	bbaa <TCPIP_Helper_StringToIPv6Address+0x26>
            return false;
    be14:	2000      	movs	r0, #0
    be16:	e6c8      	b.n	bbaa <TCPIP_Helper_StringToIPv6Address+0x26>
        return false;
    be18:	2000      	movs	r0, #0
    be1a:	e6c6      	b.n	bbaa <TCPIP_Helper_StringToIPv6Address+0x26>
    return true;
    be1c:	2001      	movs	r0, #1
    be1e:	e6c4      	b.n	bbaa <TCPIP_Helper_StringToIPv6Address+0x26>
            return false;
    be20:	2000      	movs	r0, #0
    be22:	e6c2      	b.n	bbaa <TCPIP_Helper_StringToIPv6Address+0x26>
        j = 0;
    be24:	46b0      	mov	r8, r6
        subString[j] = 0;
    be26:	ab18      	add	r3, sp, #96	; 0x60
    be28:	4443      	add	r3, r8
    be2a:	f803 ac08 	strb.w	sl, [r3, #-8]
        convertedValue = (uint16_t)strtol((const char *)subString, &endPtr, conv_base);
    be2e:	465a      	mov	r2, fp
    be30:	a915      	add	r1, sp, #84	; 0x54
    be32:	a816      	add	r0, sp, #88	; 0x58
    be34:	f017 feec 	bl	23c10 <strtol>
    be38:	b281      	uxth	r1, r0
        if(convertedValue == 0 && endPtr != (char*)subString + j)
    be3a:	b921      	cbnz	r1, be46 <TCPIP_Helper_StringToIPv6Address+0x2c2>
    be3c:	ab16      	add	r3, sp, #88	; 0x58
    be3e:	4498      	add	r8, r3
    be40:	9b15      	ldr	r3, [sp, #84]	; 0x54
    be42:	4543      	cmp	r3, r8
    be44:	d1e2      	bne.n	be0c <TCPIP_Helper_StringToIPv6Address+0x288>
        convAddr.w[currentWord++] = TCPIP_Helper_htons(convertedValue);
    be46:	f109 0201 	add.w	r2, r9, #1
    be4a:	b2d2      	uxtb	r2, r2
    be4c:	ab18      	add	r3, sp, #96	; 0x60
    be4e:	eb03 0949 	add.w	r9, r3, r9, lsl #1
       return (((hShort) << 8) | ((hShort) >> 8));
    be52:	0203      	lsls	r3, r0, #8
    be54:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    be58:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    be5c:	ea43 2311 	orr.w	r3, r3, r1, lsr #8
    be60:	f829 3c1c 	strh.w	r3, [r9, #-28]
        if(i == 0)
    be64:	2e00      	cmp	r6, #0
    be66:	d085      	beq.n	bd74 <TCPIP_Helper_StringToIPv6Address+0x1f0>
        if (i == ':')
    be68:	2e3a      	cmp	r6, #58	; 0x3a
    be6a:	f43f af78 	beq.w	bd5e <TCPIP_Helper_StringToIPv6Address+0x1da>
        if (i == ',')
    be6e:	2e2c      	cmp	r6, #44	; 0x2c
    be70:	d0d0      	beq.n	be14 <TCPIP_Helper_StringToIPv6Address+0x290>
        i = *str++;
    be72:	f814 6b01 	ldrb.w	r6, [r4], #1
    while (i != ':' && i != 0u && i != '.' && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
    be76:	2e3a      	cmp	r6, #58	; 0x3a
    be78:	f43f af7c 	beq.w	bd74 <TCPIP_Helper_StringToIPv6Address+0x1f0>
    be7c:	f016 0fdf 	tst.w	r6, #223	; 0xdf
    be80:	f43f af78 	beq.w	bd74 <TCPIP_Helper_StringToIPv6Address+0x1f0>
    be84:	f1a6 032e 	sub.w	r3, r6, #46	; 0x2e
    be88:	b2db      	uxtb	r3, r3
    be8a:	2b01      	cmp	r3, #1
    be8c:	f67f af72 	bls.w	bd74 <TCPIP_Helper_StringToIPv6Address+0x1f0>
    be90:	2e0d      	cmp	r6, #13
    be92:	f43f af6f 	beq.w	bd74 <TCPIP_Helper_StringToIPv6Address+0x1f0>
    be96:	f1a6 0309 	sub.w	r3, r6, #9
    be9a:	b2db      	uxtb	r3, r3
    be9c:	2b01      	cmp	r3, #1
    be9e:	f67f af69 	bls.w	bd74 <TCPIP_Helper_StringToIPv6Address+0x1f0>
        convAddr.w[currentWord++] = TCPIP_Helper_htons(convertedValue);
    bea2:	4691      	mov	r9, r2
    bea4:	e712      	b.n	bccc <TCPIP_Helper_StringToIPv6Address+0x148>
        j = 0;
    bea6:	46d0      	mov	r8, sl
    bea8:	e7bd      	b.n	be26 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    beaa:	46d0      	mov	r8, sl
    beac:	e7bb      	b.n	be26 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    beae:	46d0      	mov	r8, sl
    beb0:	e7b9      	b.n	be26 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    beb2:	46d0      	mov	r8, sl
    beb4:	e7b7      	b.n	be26 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    beb6:	46d0      	mov	r8, sl
    beb8:	e7b5      	b.n	be26 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    beba:	bf00      	nop
    bebc:	00015855 	.word	0x00015855
    bec0:	46d0      	mov	r8, sl
        subString[j] = 0;
    bec2:	ab18      	add	r3, sp, #96	; 0x60
    bec4:	4443      	add	r3, r8
    bec6:	f803 ac08 	strb.w	sl, [r3, #-8]
    beca:	262e      	movs	r6, #46	; 0x2e
            conv_base = 10;
    becc:	f04f 0b0a 	mov.w	fp, #10
    bed0:	e7ad      	b.n	be2e <TCPIP_Helper_StringToIPv6Address+0x2aa>
        j = 0;
    bed2:	46d0      	mov	r8, sl
        subString[j] = 0;
    bed4:	ab18      	add	r3, sp, #96	; 0x60
    bed6:	4443      	add	r3, r8
    bed8:	f803 ac08 	strb.w	sl, [r3, #-8]
        else if(i == ':' && conv_base == 10)
    bedc:	f1bb 0f0a 	cmp.w	fp, #10
    bee0:	d09e      	beq.n	be20 <TCPIP_Helper_StringToIPv6Address+0x29c>
    bee2:	263a      	movs	r6, #58	; 0x3a
    bee4:	e7a3      	b.n	be2e <TCPIP_Helper_StringToIPv6Address+0x2aa>
    bee6:	bf00      	nop

Disassembly of section .text.TCPIP_DHCPS_Task%237:

0000bee8 <TCPIP_DHCPS_Task>:
{
    bee8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    beec:	b0a9      	sub	sp, #164	; 0xa4
    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    beee:	210f      	movs	r1, #15
    bef0:	200d      	movs	r0, #13
    bef2:	f014 f91f 	bl	20134 <_TCPIPStackModuleSignalGet>
    if(dhcps_mod.uSkt == INVALID_UDP_SOCKET) 
    bef6:	4b9a      	ldr	r3, [pc, #616]	; (c160 <TCPIP_DHCPS_Task+0x278>)
    bef8:	f9b3 3000 	ldrsh.w	r3, [r3]
    befc:	f1b3 3fff 	cmp.w	r3, #4294967295
    bf00:	d00b      	beq.n	bf1a <TCPIP_DHCPS_Task+0x32>
    bf02:	4604      	mov	r4, r0
    if((sigPend & TCPIP_MODULE_SIGNAL_RX_PENDING) != 0)
    bf04:	f010 0f01 	tst.w	r0, #1
    bf08:	d10a      	bne.n	bf20 <TCPIP_DHCPS_Task+0x38>
    if(dhcps_mod.smServer == DHCP_SERVER_ICMP_PROCESS)
    bf0a:	4b95      	ldr	r3, [pc, #596]	; (c160 <TCPIP_DHCPS_Task+0x278>)
    bf0c:	789b      	ldrb	r3, [r3, #2]
    bf0e:	2b01      	cmp	r3, #1
    bf10:	d009      	beq.n	bf26 <TCPIP_DHCPS_Task+0x3e>
    if((sigPend & TCPIP_MODULE_SIGNAL_TMO) != 0)
    bf12:	f014 0f02 	tst.w	r4, #2
    bf16:	f040 810b 	bne.w	c130 <TCPIP_DHCPS_Task+0x248>
}
    bf1a:	b029      	add	sp, #164	; 0xa4
    bf1c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    _DHCPS_ProcessGetPktandSendResponse();   
    bf20:	f7f8 f9ea 	bl	42f8 <_DHCPS_ProcessGetPktandSendResponse>
    bf24:	e7f1      	b.n	bf0a <TCPIP_DHCPS_Task+0x22>
    bool cancelReq, newReq;
    bool killIcmp = false;
    char debugBuf[128];
    uint32_t    currentTime=0;
       
    switch(dhcpsEchoRequestState)
    bf26:	4b8f      	ldr	r3, [pc, #572]	; (c164 <TCPIP_DHCPS_Task+0x27c>)
    bf28:	781b      	ldrb	r3, [r3, #0]
    bf2a:	2b03      	cmp	r3, #3
    bf2c:	d826      	bhi.n	bf7c <TCPIP_DHCPS_Task+0x94>
    bf2e:	e8df f013 	tbh	[pc, r3, lsl #1]
    bf32:	0004      	.short	0x0004
    bf34:	00c9001f 	.word	0x00c9001f
    bf38:	00da      	.short	0x00da
    {
        case TCPIP_DHCPS_START_ECHO_REQUEST:
            dhcpsicmpStartTick = 0;  // try to start as quickly as possible
    bf3a:	4b8b      	ldr	r3, [pc, #556]	; (c168 <TCPIP_DHCPS_Task+0x280>)
    bf3c:	2200      	movs	r2, #0
    bf3e:	601a      	str	r2, [r3, #0]
    bf40:	f010 fdf0 	bl	1cb24 <rand>
            dhcpsicmpSequenceNo = SYS_RANDOM_PseudoGet();
    bf44:	4b89      	ldr	r3, [pc, #548]	; (c16c <TCPIP_DHCPS_Task+0x284>)
    bf46:	8018      	strh	r0, [r3, #0]
    bf48:	f010 fdec 	bl	1cb24 <rand>
            dhcpsicmpIdentifier = SYS_RANDOM_PseudoGet();
    bf4c:	4b88      	ldr	r3, [pc, #544]	; (c170 <TCPIP_DHCPS_Task+0x288>)
    bf4e:	8018      	strh	r0, [r3, #0]
            dhcpsEchoRequestState = TCPIP_DHCPS_DO_ECHO_REQUEST;
    bf50:	4b84      	ldr	r3, [pc, #528]	; (c164 <TCPIP_DHCPS_Task+0x27c>)
    bf52:	2201      	movs	r2, #1
    bf54:	701a      	strb	r2, [r3, #0]
            if(dhcpsicmpReqNo == 0)
    bf56:	4b87      	ldr	r3, [pc, #540]	; (c174 <TCPIP_DHCPS_Task+0x28c>)
    bf58:	681b      	ldr	r3, [r3, #0]
    bf5a:	b913      	cbnz	r3, bf62 <TCPIP_DHCPS_Task+0x7a>
            {
                dhcpsicmpReqNo = TCPIP_DHCPS_ICMP_ECHO_REQUESTS;
    bf5c:	4b85      	ldr	r3, [pc, #532]	; (c174 <TCPIP_DHCPS_Task+0x28c>)
    bf5e:	2202      	movs	r2, #2
    bf60:	601a      	str	r2, [r3, #0]
            }
            if(dhcpsicmpReqDelay == 0)
    bf62:	4b85      	ldr	r3, [pc, #532]	; (c178 <TCPIP_DHCPS_Task+0x290>)
    bf64:	681b      	ldr	r3, [r3, #0]
    bf66:	b91b      	cbnz	r3, bf70 <TCPIP_DHCPS_Task+0x88>
            {
                dhcpsicmpReqDelay = TCPIP_DHCPS_ICMP_ECHO_REQUEST_DELAY;
    bf68:	4b83      	ldr	r3, [pc, #524]	; (c178 <TCPIP_DHCPS_Task+0x290>)
    bf6a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    bf6e:	601a      	str	r2, [r3, #0]
            }

            // no break needed here!

        case TCPIP_DHCPS_DO_ECHO_REQUEST:
            if(dhcpsicmpReqCount == dhcpsicmpReqNo)
    bf70:	4b82      	ldr	r3, [pc, #520]	; (c17c <TCPIP_DHCPS_Task+0x294>)
    bf72:	681a      	ldr	r2, [r3, #0]
    bf74:	4b7f      	ldr	r3, [pc, #508]	; (c174 <TCPIP_DHCPS_Task+0x28c>)
    bf76:	681b      	ldr	r3, [r3, #0]
    bf78:	429a      	cmp	r2, r3
    bf7a:	d119      	bne.n	bfb0 <TCPIP_DHCPS_Task+0xc8>
                break;
    }
    if(killIcmp)
    {
        // Stop PING echo request 
        dhcpsEchoRequestState = TCPIP_DHCPS_STOP_ECHO_REQUEST;
    bf7c:	4b79      	ldr	r3, [pc, #484]	; (c164 <TCPIP_DHCPS_Task+0x27c>)
    bf7e:	2202      	movs	r2, #2
    bf80:	701a      	strb	r2, [r3, #0]
    switch(dhcpsicmpProcessSteps)
    bf82:	4b7f      	ldr	r3, [pc, #508]	; (c180 <TCPIP_DHCPS_Task+0x298>)
    bf84:	781b      	ldrb	r3, [r3, #0]
    bf86:	2b07      	cmp	r3, #7
    bf88:	d8c3      	bhi.n	bf12 <TCPIP_DHCPS_Task+0x2a>
    bf8a:	a201      	add	r2, pc, #4	; (adr r2, bf90 <TCPIP_DHCPS_Task+0xa8>)
    bf8c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    bf90:	0000bf1b 	.word	0x0000bf1b
    bf94:	0000c125 	.word	0x0000c125
    bf98:	0000bf1b 	.word	0x0000bf1b
    bf9c:	0000c125 	.word	0x0000c125
    bfa0:	0000c119 	.word	0x0000c119
    bfa4:	0000bf1b 	.word	0x0000bf1b
    bfa8:	0000c125 	.word	0x0000c125
    bfac:	0000bf13 	.word	0x0000bf13
            currentTime = SYS_TMR_TickCountGet();
    bfb0:	f016 f944 	bl	2223c <SYS_TMR_TickCountGet>
    bfb4:	4606      	mov	r6, r0
            if(currentTime - dhcpsicmpStartTick > (SYS_TMR_TickCounterFrequencyGet() * dhcpsicmpReqDelay) / 1000)
    bfb6:	4b6c      	ldr	r3, [pc, #432]	; (c168 <TCPIP_DHCPS_Task+0x280>)
    bfb8:	681d      	ldr	r5, [r3, #0]
    bfba:	1b45      	subs	r5, r0, r5
    bfbc:	f016 f966 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    bfc0:	4b6d      	ldr	r3, [pc, #436]	; (c178 <TCPIP_DHCPS_Task+0x290>)
    bfc2:	681b      	ldr	r3, [r3, #0]
    bfc4:	fb03 f300 	mul.w	r3, r3, r0
    bfc8:	486e      	ldr	r0, [pc, #440]	; (c184 <TCPIP_DHCPS_Task+0x29c>)
    bfca:	fba0 2303 	umull	r2, r3, r0, r3
    bfce:	ebb5 1f93 	cmp.w	r5, r3, lsr #6
    bfd2:	d941      	bls.n	c058 <TCPIP_DHCPS_Task+0x170>
                cancelReq = dhcpsicmpReqCount != dhcpsicmpAckRecv && dhcpsicmpReqHandle != 0;    // cancel if there is another one ongoing
    bfd4:	4b69      	ldr	r3, [pc, #420]	; (c17c <TCPIP_DHCPS_Task+0x294>)
    bfd6:	681a      	ldr	r2, [r3, #0]
    bfd8:	4b6b      	ldr	r3, [pc, #428]	; (c188 <TCPIP_DHCPS_Task+0x2a0>)
    bfda:	681b      	ldr	r3, [r3, #0]
    bfdc:	429a      	cmp	r2, r3
    bfde:	d039      	beq.n	c054 <TCPIP_DHCPS_Task+0x16c>
    bfe0:	4b6a      	ldr	r3, [pc, #424]	; (c18c <TCPIP_DHCPS_Task+0x2a4>)
    bfe2:	681b      	ldr	r3, [r3, #0]
    bfe4:	3300      	adds	r3, #0
    bfe6:	bf18      	it	ne
    bfe8:	2301      	movne	r3, #1
            if(cancelReq)
    bfea:	2b00      	cmp	r3, #0
    bfec:	d153      	bne.n	c096 <TCPIP_DHCPS_Task+0x1ae>
            echoRequest.netH = dhcpsicmpNetH;
    bfee:	4b68      	ldr	r3, [pc, #416]	; (c190 <TCPIP_DHCPS_Task+0x2a8>)
    bff0:	681b      	ldr	r3, [r3, #0]
    bff2:	9302      	str	r3, [sp, #8]
            echoRequest.targetAddr = dhcpsicmpTargetAddr;
    bff4:	4b67      	ldr	r3, [pc, #412]	; (c194 <TCPIP_DHCPS_Task+0x2ac>)
    bff6:	681b      	ldr	r3, [r3, #0]
    bff8:	9303      	str	r3, [sp, #12]
            echoRequest.sequenceNumber = ++dhcpsicmpSequenceNo;
    bffa:	4a5c      	ldr	r2, [pc, #368]	; (c16c <TCPIP_DHCPS_Task+0x284>)
    bffc:	8813      	ldrh	r3, [r2, #0]
    bffe:	3301      	adds	r3, #1
    c000:	b29b      	uxth	r3, r3
    c002:	8013      	strh	r3, [r2, #0]
    c004:	f8ad 3010 	strh.w	r3, [sp, #16]
            echoRequest.identifier = dhcpsicmpIdentifier;
    c008:	4b59      	ldr	r3, [pc, #356]	; (c170 <TCPIP_DHCPS_Task+0x288>)
    c00a:	881b      	ldrh	r3, [r3, #0]
    c00c:	f8ad 3012 	strh.w	r3, [sp, #18]
            echoRequest.pData = dhcpsicmpPingBuff;
    c010:	4d61      	ldr	r5, [pc, #388]	; (c198 <TCPIP_DHCPS_Task+0x2b0>)
    c012:	9505      	str	r5, [sp, #20]
            echoRequest.dataSize = dhcpsicmpPingSize;
    c014:	2364      	movs	r3, #100	; 0x64
    c016:	f8ad 3018 	strh.w	r3, [sp, #24]
            echoRequest.callback = DHCPSPingHandler;
    c01a:	4b60      	ldr	r3, [pc, #384]	; (c19c <TCPIP_DHCPS_Task+0x2b4>)
    c01c:	9307      	str	r3, [sp, #28]
                for(ix = 0; ix < dhcpsicmpPingSize; ix++)
    c01e:	f105 0664 	add.w	r6, r5, #100	; 0x64
    c022:	f010 fd7f 	bl	1cb24 <rand>
                    *pBuff++ = SYS_RANDOM_PseudoGet();
    c026:	f805 0b01 	strb.w	r0, [r5], #1
                for(ix = 0; ix < dhcpsicmpPingSize; ix++)
    c02a:	42b5      	cmp	r5, r6
    c02c:	d1f9      	bne.n	c022 <TCPIP_DHCPS_Task+0x13a>
            echoRes = TCPIP_ICMP_EchoRequest (&echoRequest, &dhcpsicmpReqHandle);
    c02e:	4957      	ldr	r1, [pc, #348]	; (c18c <TCPIP_DHCPS_Task+0x2a4>)
    c030:	a802      	add	r0, sp, #8
    c032:	f009 fd91 	bl	15b58 <TCPIP_ICMP_EchoRequest>
            if(echoRes >= 0 )
    c036:	2800      	cmp	r0, #0
    c038:	da32      	bge.n	c0a0 <TCPIP_DHCPS_Task+0x1b8>
                sprintf(debugBuf,"Ping: failed to send request %d to: %x, error %d\r\n", dhcpsicmpReqCount, (unsigned int)dhcpsicmpTargetAddr.Val, echoRes);
    c03a:	9000      	str	r0, [sp, #0]
    c03c:	4b55      	ldr	r3, [pc, #340]	; (c194 <TCPIP_DHCPS_Task+0x2ac>)
    c03e:	681b      	ldr	r3, [r3, #0]
    c040:	4a4e      	ldr	r2, [pc, #312]	; (c17c <TCPIP_DHCPS_Task+0x294>)
    c042:	6812      	ldr	r2, [r2, #0]
    c044:	4956      	ldr	r1, [pc, #344]	; (c1a0 <TCPIP_DHCPS_Task+0x2b8>)
    c046:	a808      	add	r0, sp, #32
    c048:	f013 fb06 	bl	1f658 <siprintf>
                dhcpsicmpProcessSteps = DHCPS_ICMP_REQUEST_CANCEL;
    c04c:	4b4c      	ldr	r3, [pc, #304]	; (c180 <TCPIP_DHCPS_Task+0x298>)
    c04e:	2201      	movs	r2, #1
    c050:	701a      	strb	r2, [r3, #0]
    if(killIcmp)
    c052:	e793      	b.n	bf7c <TCPIP_DHCPS_Task+0x94>
                cancelReq = dhcpsicmpReqCount != dhcpsicmpAckRecv && dhcpsicmpReqHandle != 0;    // cancel if there is another one ongoing
    c054:	2300      	movs	r3, #0
                newReq = true;
    c056:	e7c8      	b.n	bfea <TCPIP_DHCPS_Task+0x102>
            else if(dhcpsicmpReqCount != dhcpsicmpAckRecv)
    c058:	4b48      	ldr	r3, [pc, #288]	; (c17c <TCPIP_DHCPS_Task+0x294>)
    c05a:	681a      	ldr	r2, [r3, #0]
    c05c:	4b4a      	ldr	r3, [pc, #296]	; (c188 <TCPIP_DHCPS_Task+0x2a0>)
    c05e:	681b      	ldr	r3, [r3, #0]
    c060:	429a      	cmp	r2, r3
    c062:	d08e      	beq.n	bf82 <TCPIP_DHCPS_Task+0x9a>
                if(currentTime - dhcpsicmpStartTick > (SYS_TMR_TickCounterFrequencyGet() * TCPIP_DHCPS_ICMP_ECHO_TIMEOUT) / 1000)
    c064:	4b40      	ldr	r3, [pc, #256]	; (c168 <TCPIP_DHCPS_Task+0x280>)
    c066:	681b      	ldr	r3, [r3, #0]
    c068:	1af6      	subs	r6, r6, r3
    c06a:	f016 f90f 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    c06e:	f241 3388 	movw	r3, #5000	; 0x1388
    c072:	fb03 f300 	mul.w	r3, r3, r0
    c076:	4a43      	ldr	r2, [pc, #268]	; (c184 <TCPIP_DHCPS_Task+0x29c>)
    c078:	fba2 2303 	umull	r2, r3, r2, r3
    c07c:	ebb6 1f93 	cmp.w	r6, r3, lsr #6
    c080:	f67f af7f 	bls.w	bf82 <TCPIP_DHCPS_Task+0x9a>
                    cancelReq = dhcpsicmpReqHandle != 0;    // cancel if there is another one ongoing
    c084:	4b41      	ldr	r3, [pc, #260]	; (c18c <TCPIP_DHCPS_Task+0x2a4>)
    c086:	681b      	ldr	r3, [r3, #0]
    c088:	3300      	adds	r3, #0
    c08a:	bf18      	it	ne
    c08c:	2301      	movne	r3, #1
                    dhcpsicmpProcessSteps = DHCPS_ICMP_REQUEST_TIMEDOUT;
    c08e:	4a3c      	ldr	r2, [pc, #240]	; (c180 <TCPIP_DHCPS_Task+0x298>)
    c090:	2106      	movs	r1, #6
    c092:	7011      	strb	r1, [r2, #0]
    c094:	e7a9      	b.n	bfea <TCPIP_DHCPS_Task+0x102>
                if(TCPIP_ICMP_EchoRequestCancel(dhcpsicmpReqHandle) != ICMP_ECHO_OK)
    c096:	4b3d      	ldr	r3, [pc, #244]	; (c18c <TCPIP_DHCPS_Task+0x2a4>)
    c098:	6818      	ldr	r0, [r3, #0]
    c09a:	f016 fa65 	bl	22568 <TCPIP_ICMP_EchoRequestCancel>
    c09e:	e7a6      	b.n	bfee <TCPIP_DHCPS_Task+0x106>
                dhcpsicmpStartTick = SYS_TMR_TickCountGet();
    c0a0:	f016 f8cc 	bl	2223c <SYS_TMR_TickCountGet>
    c0a4:	4b30      	ldr	r3, [pc, #192]	; (c168 <TCPIP_DHCPS_Task+0x280>)
    c0a6:	6018      	str	r0, [r3, #0]
                dhcpsicmpReqCount++;
    c0a8:	4b34      	ldr	r3, [pc, #208]	; (c17c <TCPIP_DHCPS_Task+0x294>)
    c0aa:	681a      	ldr	r2, [r3, #0]
    c0ac:	3201      	adds	r2, #1
    c0ae:	601a      	str	r2, [r3, #0]
                sprintf(debugBuf,"Ping: sent request %d to: [%x]\r\n", dhcpsicmpReqCount, (unsigned int)dhcpsicmpTargetAddr.Val);
    c0b0:	4b38      	ldr	r3, [pc, #224]	; (c194 <TCPIP_DHCPS_Task+0x2ac>)
    c0b2:	681b      	ldr	r3, [r3, #0]
    c0b4:	493b      	ldr	r1, [pc, #236]	; (c1a4 <TCPIP_DHCPS_Task+0x2bc>)
    c0b6:	a808      	add	r0, sp, #32
    c0b8:	f013 face 	bl	1f658 <siprintf>
                dhcpsicmpProcessSteps = DHCPS_ICMP_REQUEST_SENT;
    c0bc:	4b30      	ldr	r3, [pc, #192]	; (c180 <TCPIP_DHCPS_Task+0x298>)
    c0be:	2200      	movs	r2, #0
    c0c0:	701a      	strb	r2, [r3, #0]
    if(killIcmp)
    c0c2:	e75e      	b.n	bf82 <TCPIP_DHCPS_Task+0x9a>
                 if(TCPIP_ICMP_EchoRequestCancel(dhcpsicmpReqHandle) == ICMP_ECHO_OK)
    c0c4:	4b31      	ldr	r3, [pc, #196]	; (c18c <TCPIP_DHCPS_Task+0x2a4>)
    c0c6:	6818      	ldr	r0, [r3, #0]
    c0c8:	f016 fa4e 	bl	22568 <TCPIP_ICMP_EchoRequestCancel>
    c0cc:	b910      	cbnz	r0, c0d4 <TCPIP_DHCPS_Task+0x1ec>
                     dhcpsicmpProcessSteps = DHCPS_ICMP_REQUEST_CANCEL;
    c0ce:	4b2c      	ldr	r3, [pc, #176]	; (c180 <TCPIP_DHCPS_Task+0x298>)
    c0d0:	2201      	movs	r2, #1
    c0d2:	701a      	strb	r2, [r3, #0]
                dhcpsicmpReqHandle = 0;
    c0d4:	2300      	movs	r3, #0
    c0d6:	4a2d      	ldr	r2, [pc, #180]	; (c18c <TCPIP_DHCPS_Task+0x2a4>)
    c0d8:	6013      	str	r3, [r2, #0]
                dhcpsicmpReqCount = 0;
    c0da:	4a28      	ldr	r2, [pc, #160]	; (c17c <TCPIP_DHCPS_Task+0x294>)
    c0dc:	6013      	str	r3, [r2, #0]
                dhcpsEchoRequestState = TCPIP_DHCPS_ECHO_REQUEST_IDLE;
    c0de:	4b21      	ldr	r3, [pc, #132]	; (c164 <TCPIP_DHCPS_Task+0x27c>)
    c0e0:	2203      	movs	r2, #3
    c0e2:	701a      	strb	r2, [r3, #0]
    if(killIcmp)
    c0e4:	e74d      	b.n	bf82 <TCPIP_DHCPS_Task+0x9a>
    switch(dhcpsicmpProcessSteps)
    c0e6:	4b26      	ldr	r3, [pc, #152]	; (c180 <TCPIP_DHCPS_Task+0x298>)
    c0e8:	781b      	ldrb	r3, [r3, #0]
    c0ea:	2b07      	cmp	r3, #7
    c0ec:	f63f af11 	bhi.w	bf12 <TCPIP_DHCPS_Task+0x2a>
    c0f0:	a201      	add	r2, pc, #4	; (adr r2, c0f8 <TCPIP_DHCPS_Task+0x210>)
    c0f2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    c0f6:	bf00      	nop
    c0f8:	0000bf1b 	.word	0x0000bf1b
    c0fc:	0000c125 	.word	0x0000c125
    c100:	0000bf1b 	.word	0x0000bf1b
    c104:	0000c125 	.word	0x0000c125
    c108:	0000c119 	.word	0x0000c119
    c10c:	0000bf1b 	.word	0x0000bf1b
    c110:	0000c125 	.word	0x0000c125
    c114:	0000bf13 	.word	0x0000bf13
            dhcps_mod.smState = TCPIP_DHCPS_GET_NEW_ADDRESS;
    c118:	4b11      	ldr	r3, [pc, #68]	; (c160 <TCPIP_DHCPS_Task+0x278>)
    c11a:	2208      	movs	r2, #8
    c11c:	70da      	strb	r2, [r3, #3]
            dhcps_mod.smServer = DHCP_SERVER_LISTEN;
    c11e:	2200      	movs	r2, #0
    c120:	709a      	strb	r2, [r3, #2]
            return;
    c122:	e6fa      	b.n	bf1a <TCPIP_DHCPS_Task+0x32>
            dhcps_mod.smState = TCPIP_DHCPS_SEND_OFFER;
    c124:	4b0e      	ldr	r3, [pc, #56]	; (c160 <TCPIP_DHCPS_Task+0x278>)
    c126:	2206      	movs	r2, #6
    c128:	70da      	strb	r2, [r3, #3]
            dhcps_mod.smServer = DHCP_SERVER_LISTEN;
    c12a:	2200      	movs	r2, #0
    c12c:	709a      	strb	r2, [r3, #2]
    c12e:	e6f0      	b.n	bf12 <TCPIP_DHCPS_Task+0x2a>
    uint32_t current_timer = SYS_TMR_TickCountGet();
    c130:	f016 f884 	bl	2223c <SYS_TMR_TickCountGet>
    c134:	4607      	mov	r7, r0
    if(gPdhcpSDcpt == NULL)
    c136:	4b1c      	ldr	r3, [pc, #112]	; (c1a8 <TCPIP_DHCPS_Task+0x2c0>)
    c138:	681b      	ldr	r3, [r3, #0]
    c13a:	2b00      	cmp	r3, #0
    c13c:	f43f aeed 	beq.w	bf1a <TCPIP_DHCPS_Task+0x32>
    pOH = pdhcpsDcpt->hashDcpt;
    c140:	4b1a      	ldr	r3, [pc, #104]	; (c1ac <TCPIP_DHCPS_Task+0x2c4>)
    c142:	681e      	ldr	r6, [r3, #0]
    pNetIf = (TCPIP_NET_IF*)TCPIP_UDP_SocketNetGet(dhcps_mod.uSkt);
    c144:	4b06      	ldr	r3, [pc, #24]	; (c160 <TCPIP_DHCPS_Task+0x278>)
    c146:	f9b3 0000 	ldrsh.w	r0, [r3]
    c14a:	f017 fe29 	bl	23da0 <TCPIP_UDP_SocketNetGet>
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
    c14e:	68f3      	ldr	r3, [r6, #12]
    c150:	2b00      	cmp	r3, #0
    c152:	f43f aee2 	beq.w	bf1a <TCPIP_DHCPS_Task+0x32>
    c156:	2500      	movs	r5, #0
                dhcpsHE->pendingTime = 0;
    c158:	46a9      	mov	r9, r5
            if((current_timer - dhcpsHE->Client_Lease_Time) >= pdhcpsDcpt->leaseDuartion* SYS_TMR_TickCounterFrequencyGet())
    c15a:	f8df 8050 	ldr.w	r8, [pc, #80]	; c1ac <TCPIP_DHCPS_Task+0x2c4>
    c15e:	e03b      	b.n	c1d8 <TCPIP_DHCPS_Task+0x2f0>
    c160:	2000ed3c 	.word	0x2000ed3c
    c164:	2000ef8d 	.word	0x2000ef8d
    c168:	2000eec0 	.word	0x2000eec0
    c16c:	2000ef86 	.word	0x2000ef86
    c170:	2000ef84 	.word	0x2000ef84
    c174:	2000eebc 	.word	0x2000eebc
    c178:	2000eeb4 	.word	0x2000eeb4
    c17c:	2000eeb0 	.word	0x2000eeb0
    c180:	2000ef8e 	.word	0x2000ef8e
    c184:	10624dd3 	.word	0x10624dd3
    c188:	2000eea8 	.word	0x2000eea8
    c18c:	2000eeb8 	.word	0x2000eeb8
    c190:	2000eeac 	.word	0x2000eeac
    c194:	2000eec4 	.word	0x2000eec4
    c198:	2000d1d4 	.word	0x2000d1d4
    c19c:	00015109 	.word	0x00015109
    c1a0:	0000d428 	.word	0x0000d428
    c1a4:	0000d404 	.word	0x0000d404
    c1a8:	2000eec8 	.word	0x2000eec8
    c1ac:	2000ed7c 	.word	0x2000ed7c
    c1b0:	6843      	ldr	r3, [r0, #4]
    c1b2:	eba7 0b03 	sub.w	fp, r7, r3
    c1b6:	f8d8 a004 	ldr.w	sl, [r8, #4]
    c1ba:	f016 f867 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    c1be:	fb00 f00a 	mul.w	r0, r0, sl
    c1c2:	4583      	cmp	fp, r0
    c1c4:	d228      	bcs.n	c218 <TCPIP_DHCPS_Task+0x330>
        if(hE->flags.busy != 0)
    c1c6:	7823      	ldrb	r3, [r4, #0]
    c1c8:	f013 0f01 	tst.w	r3, #1
    c1cc:	d114      	bne.n	c1f8 <TCPIP_DHCPS_Task+0x310>
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
    c1ce:	3501      	adds	r5, #1
    c1d0:	68f3      	ldr	r3, [r6, #12]
    c1d2:	42ab      	cmp	r3, r5
    c1d4:	f67f aea1 	bls.w	bf1a <TCPIP_DHCPS_Task+0x32>
        hE = TCPIP_OAHASH_EntryGet(pOH, bktIx);        
    c1d8:	4629      	mov	r1, r5
    c1da:	4630      	mov	r0, r6
    c1dc:	f017 fd3d 	bl	23c5a <TCPIP_OAHASH_EntryGet>
    c1e0:	4604      	mov	r4, r0
    	if((hE->flags.busy != 0) && (hE->flags.value & DHCPS_FLAG_ENTRY_COMPLETE))
    c1e2:	7803      	ldrb	r3, [r0, #0]
    c1e4:	f013 0f01 	tst.w	r3, #1
    c1e8:	d0f1      	beq.n	c1ce <TCPIP_DHCPS_Task+0x2e6>
    c1ea:	8803      	ldrh	r3, [r0, #0]
    c1ec:	f013 0f80 	tst.w	r3, #128	; 0x80
    c1f0:	d1de      	bne.n	c1b0 <TCPIP_DHCPS_Task+0x2c8>
        else if((hE->flags.busy != 0) && (hE->flags.value & DHCPS_FLAG_ENTRY_INCOMPLETE))
    c1f2:	f013 0f40 	tst.w	r3, #64	; 0x40
    c1f6:	d116      	bne.n	c226 <TCPIP_DHCPS_Task+0x33e>
            pNetIf = (TCPIP_NET_IF*)TCPIP_STACK_IndexToNet(dhcpsHE->intfIdx);
    c1f8:	69a0      	ldr	r0, [r4, #24]
    c1fa:	f015 ff43 	bl	22084 <TCPIP_STACK_IndexToNet>
            if(pNetIf && !TCPIP_STACK_NetworkIsLinked(pNetIf))
    c1fe:	2800      	cmp	r0, #0
    c200:	d0e5      	beq.n	c1ce <TCPIP_DHCPS_Task+0x2e6>
    c202:	f016 fe59 	bl	22eb8 <TCPIP_STACK_NetworkIsLinked>
    c206:	2800      	cmp	r0, #0
    c208:	d1e1      	bne.n	c1ce <TCPIP_DHCPS_Task+0x2e6>
                dhcpsHE->pendingTime = 0;
    c20a:	f8c4 9008 	str.w	r9, [r4, #8]
                TCPIP_OAHASH_EntryRemove(pOH,hE);
    c20e:	4621      	mov	r1, r4
    c210:	4630      	mov	r0, r6
    c212:	f017 fa4f 	bl	236b4 <TCPIP_OAHASH_EntryRemove>
    c216:	e7da      	b.n	c1ce <TCPIP_DHCPS_Task+0x2e6>
                dhcpsHE->Client_Lease_Time = 0;
    c218:	f8c4 9004 	str.w	r9, [r4, #4]
                TCPIP_OAHASH_EntryRemove(pOH,hE);
    c21c:	4621      	mov	r1, r4
    c21e:	4630      	mov	r0, r6
    c220:	f017 fa48 	bl	236b4 <TCPIP_OAHASH_EntryRemove>
    c224:	e7cf      	b.n	c1c6 <TCPIP_DHCPS_Task+0x2de>
            if((current_timer - dhcpsHE->pendingTime) >= TCPIP_DHCPS_LEASE_REMOVED_BEFORE_ACK* SYS_TMR_TickCounterFrequencyGet())
    c226:	6883      	ldr	r3, [r0, #8]
    c228:	eba7 0a03 	sub.w	sl, r7, r3
    c22c:	f016 f82e 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    c230:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    c234:	4582      	cmp	sl, r0
    c236:	d3c6      	bcc.n	c1c6 <TCPIP_DHCPS_Task+0x2de>
                dhcpsHE->pendingTime = 0;
    c238:	f8c4 9008 	str.w	r9, [r4, #8]
                TCPIP_OAHASH_EntryRemove(pOH,hE);
    c23c:	4621      	mov	r1, r4
    c23e:	4630      	mov	r0, r6
    c240:	f017 fa38 	bl	236b4 <TCPIP_OAHASH_EntryRemove>
    c244:	e7bf      	b.n	c1c6 <TCPIP_DHCPS_Task+0x2de>
    c246:	bf00      	nop

Disassembly of section .rodata%238:

0000c248 <.rodata%238>:
    c248:	72657069 	.word	0x72657069
    c24c:	732d2066 	.word	0x732d2066
    c250:	000a      	.short	0x000a
    c252:	bf00      	nop
    c254:	72657069 	.word	0x72657069
    c258:	43542066 	.word	0x43542066
    c25c:	65732050 	.word	0x65732050
    c260:	72657672 	.word	0x72657672
    c264:	00          	.byte	0x00
    c265:	00          	.byte	0x00
    c266:	bf00      	nop
    c268:	72657069 	.word	0x72657069
    c26c:	732d2066 	.word	0x732d2066
    c270:	0a752d20 	.word	0x0a752d20
    c274:	00          	.byte	0x00
    c275:	00          	.byte	0x00
    c276:	bf00      	nop
    c278:	72657069 	.word	0x72657069
    c27c:	44552066 	.word	0x44552066
    c280:	65732050 	.word	0x65732050
    c284:	72657672 	.word	0x72657672
    c288:	00          	.byte	0x00
    c289:	00          	.byte	0x00
    c28a:	bf00      	nop
    c28c:	72657069 	.word	0x72657069
    c290:	000a6b66 	.word	0x000a6b66
    c294:	72657069 	.word	0x72657069
    c298:	696b2066 	.word	0x696b2066
    c29c:	73206c6c 	.word	0x73206c6c
    c2a0:	65767265 	.word	0x65767265
    c2a4:	0072      	.short	0x0072
    c2a6:	bf00      	nop
    c2a8:	70636864 	.word	0x70636864
    c2ac:	74652073 	.word	0x74652073
    c2b0:	6f203068 	.word	0x6f203068
    c2b4:	000a6666 	.word	0x000a6666
    c2b8:	70636864 	.word	0x70636864
    c2bc:	74652073 	.word	0x74652073
    c2c0:	6f203068 	.word	0x6f203068
    c2c4:	0a6e      	.short	0x0a6e
    c2c6:	00          	.byte	0x00
    c2c7:	00          	.byte	0x00
    c2c8:	3a707041 	.word	0x3a707041
    c2cc:	69696d20 	.word	0x69696d20
    c2d0:	6573206d 	.word	0x6573206d
    c2d4:	20707574 	.word	0x20707574
    c2d8:	6c696166 	.word	0x6c696166
    c2dc:	21206465 	.word	0x21206465
    c2e0:	0a0d      	.short	0x0a0d
    c2e2:	00          	.byte	0x00
    c2e3:	00          	.byte	0x00
    c2e4:	6f727245 	.word	0x6f727245
    c2e8:	636f2072 	.word	0x636f2072
    c2ec:	65727563 	.word	0x65727563
    c2f0:	64253a64 	.word	0x64253a64
    c2f4:	0a0d      	.short	0x0a0d
    c2f6:	00          	.byte	0x00
    c2f7:	00          	.byte	0x00
    c2f8:	6e614c20 	.word	0x6e614c20
    c2fc:	78373638 	.word	0x78373638
    c300:	20736920 	.word	0x20736920
    c304:	50206e69 	.word	0x50206e69
    c308:	2041434c 	.word	0x2041434c
    c30c:	65646f6d 	.word	0x65646f6d
    c310:	0a0d202e 	.word	0x0a0d202e
    c314:	00          	.byte	0x00
    c315:	00          	.byte	0x00
    c316:	bf00      	nop
    c318:	6e614c20 	.word	0x6e614c20
    c31c:	78373638 	.word	0x78373638
    c320:	20736920 	.word	0x20736920
    c324:	43206e69 	.word	0x43206e69
    c328:	20414d53 	.word	0x20414d53
    c32c:	65646f6d 	.word	0x65646f6d
    c330:	0a0d202e 	.word	0x0a0d202e
    c334:	00          	.byte	0x00
    c335:	00          	.byte	0x00
    c336:	bf00      	nop
    c338:	646f4e20 	.word	0x646f4e20
    c33c:	64492065 	.word	0x64492065
    c340:	6425203a 	.word	0x6425203a
    c344:	6f4e202c 	.word	0x6f4e202c
    c348:	63206564 	.word	0x63206564
    c34c:	746e756f 	.word	0x746e756f
    c350:	6425203a 	.word	0x6425203a
    c354:	0a0d202e 	.word	0x0a0d202e
    c358:	00          	.byte	0x00
    c359:	00          	.byte	0x00
    c35a:	bf00      	nop
    c35c:	384e414c 	.word	0x384e414c
    c360:	20783736 	.word	0x20783736
    c364:	41434c50 	.word	0x41434c50
    c368:	00          	.byte	0x00
    c369:	00          	.byte	0x00
    c36a:	bf00      	nop
    c36c:	2e323931 	.word	0x2e323931
    c370:	2e383631 	.word	0x2e383631
    c374:	39392e31 	.word	0x39392e31
    c378:	00          	.byte	0x00
    c379:	00          	.byte	0x00
    c37a:	bf00      	nop
    c37c:	203a6449 	.word	0x203a6449
    c380:	43206425 	.word	0x43206425
    c384:	746e756f 	.word	0x746e756f
    c388:	6425203a 	.word	0x6425203a
    c38c:	00          	.byte	0x00
    c38d:	00          	.byte	0x00
    c38e:	bf00      	nop
    c390:	20504920 	.word	0x20504920
    c394:	72646441 	.word	0x72646441
    c398:	3a737365 	.word	0x3a737365
    c39c:	0020      	.short	0x0020
    c39e:	bf00      	nop
    c3a0:	252e6425 	.word	0x252e6425
    c3a4:	64252e64 	.word	0x64252e64
    c3a8:	0064252e 	.word	0x0064252e
    c3ac:	0a0d7325 	.word	0x0a0d7325
    c3b0:	00          	.byte	0x00
    c3b1:	00          	.byte	0x00
    c3b2:	bf00      	nop
    c3b4:	3a77656e 	.word	0x3a77656e
    c3b8:	7325      	.short	0x7325
    c3ba:	00          	.byte	0x00
    c3bb:	00          	.byte	0x00
    c3bc:	6f4c203e 	.word	0x6f4c203e
    c3c0:	206c6163 	.word	0x206c6163
    c3c4:	6d69696d 	.word	0x6d69696d
    c3c8:	65706f20 	.word	0x65706f20
    c3cc:	66203a6e 	.word	0x66203a6e
    c3d0:	656c6961 	.word	0x656c6961
    c3d4:	0a0d2164 	.word	0x0a0d2164
    c3d8:	00000000 	.word	0x00000000
    c3dc:	6f4c203e 	.word	0x6f4c203e
    c3e0:	206c6163 	.word	0x206c6163
    c3e4:	6d69696d 	.word	0x6d69696d
    c3e8:	74657320 	.word	0x74657320
    c3ec:	203a7075 	.word	0x203a7075
    c3f0:	6c696166 	.word	0x6c696166
    c3f4:	0d216465 	.word	0x0d216465
    c3f8:	0000000a 	.word	0x0000000a
    c3fc:	694d203e 	.word	0x694d203e
    c400:	53206d69 	.word	0x53206d69
    c404:	65636375 	.word	0x65636375
    c408:	75667373 	.word	0x75667373
    c40c:	20796c6c 	.word	0x20796c6c
    c410:	6e65706f 	.word	0x6e65706f
    c414:	202e6465 	.word	0x202e6465
    c418:	00000a0d 	.word	0x00000a0d
    c41c:	694d203e 	.word	0x694d203e
    c420:	63206d69 	.word	0x63206d69
    c424:	65736f6c 	.word	0x65736f6c
    c428:	0d202e64 	.word	0x0d202e64
    c42c:	0000000a 	.word	0x0000000a
    c430:	2d207325 	.word	0x2d207325
    c434:	00000020 	.word	0x00000020
    c438:	50434844 	.word	0x50434844
    c43c:	4556455f 	.word	0x4556455f
    c440:	4e5f544e 	.word	0x4e5f544e
    c444:	0a454e4f 	.word	0x0a454e4f
    c448:	0000000d 	.word	0x0000000d
    c44c:	50434844 	.word	0x50434844
    c450:	4556455f 	.word	0x4556455f
    c454:	445f544e 	.word	0x445f544e
    c458:	4f435349 	.word	0x4f435349
    c45c:	0a524556 	.word	0x0a524556
    c460:	0000000d 	.word	0x0000000d
    c464:	50434844 	.word	0x50434844
    c468:	4556455f 	.word	0x4556455f
    c46c:	525f544e 	.word	0x525f544e
    c470:	45555145 	.word	0x45555145
    c474:	0d0a5453 	.word	0x0d0a5453
    c478:	00000000 	.word	0x00000000
    c47c:	50434844 	.word	0x50434844
    c480:	4556455f 	.word	0x4556455f
    c484:	415f544e 	.word	0x415f544e
    c488:	0d0a4b43 	.word	0x0d0a4b43
    c48c:	00000000 	.word	0x00000000
    c490:	50434844 	.word	0x50434844
    c494:	4556455f 	.word	0x4556455f
    c498:	415f544e 	.word	0x415f544e
    c49c:	495f4b43 	.word	0x495f4b43
    c4a0:	4c41564e 	.word	0x4c41564e
    c4a4:	0d0a4449 	.word	0x0d0a4449
    c4a8:	00000000 	.word	0x00000000
    c4ac:	50434844 	.word	0x50434844
    c4b0:	4556455f 	.word	0x4556455f
    c4b4:	445f544e 	.word	0x445f544e
    c4b8:	494c4345 	.word	0x494c4345
    c4bc:	0d0a454e 	.word	0x0d0a454e
    c4c0:	00000000 	.word	0x00000000
    c4c4:	50434844 	.word	0x50434844
    c4c8:	4556455f 	.word	0x4556455f
    c4cc:	4e5f544e 	.word	0x4e5f544e
    c4d0:	0a4b4341 	.word	0x0a4b4341
    c4d4:	0000000d 	.word	0x0000000d
    c4d8:	50434844 	.word	0x50434844
    c4dc:	4556455f 	.word	0x4556455f
    c4e0:	545f544e 	.word	0x545f544e
    c4e4:	4f454d49 	.word	0x4f454d49
    c4e8:	0d0a5455 	.word	0x0d0a5455
    c4ec:	00000000 	.word	0x00000000
    c4f0:	50434844 	.word	0x50434844
    c4f4:	4556455f 	.word	0x4556455f
    c4f8:	425f544e 	.word	0x425f544e
    c4fc:	444e554f 	.word	0x444e554f
    c500:	00000d0a 	.word	0x00000d0a
    c504:	50434844 	.word	0x50434844
    c508:	4556455f 	.word	0x4556455f
    c50c:	525f544e 	.word	0x525f544e
    c510:	45555145 	.word	0x45555145
    c514:	525f5453 	.word	0x525f5453
    c518:	57454e45 	.word	0x57454e45
    c51c:	00000d0a 	.word	0x00000d0a
    c520:	50434844 	.word	0x50434844
    c524:	4556455f 	.word	0x4556455f
    c528:	525f544e 	.word	0x525f544e
    c52c:	45555145 	.word	0x45555145
    c530:	525f5453 	.word	0x525f5453
    c534:	4e494245 	.word	0x4e494245
    c538:	000d0a44 	.word	0x000d0a44
    c53c:	50434844 	.word	0x50434844
    c540:	4556455f 	.word	0x4556455f
    c544:	435f544e 	.word	0x435f544e
    c548:	5f4e4e4f 	.word	0x5f4e4e4f
    c54c:	54534f4c 	.word	0x54534f4c
    c550:	00000d0a 	.word	0x00000d0a
    c554:	50434844 	.word	0x50434844
    c558:	4556455f 	.word	0x4556455f
    c55c:	435f544e 	.word	0x435f544e
    c560:	5f4e4e4f 	.word	0x5f4e4e4f
    c564:	41545345 	.word	0x41545345
    c568:	53494c42 	.word	0x53494c42
    c56c:	0a444548 	.word	0x0a444548
    c570:	0000000d 	.word	0x0000000d
    c574:	50434844 	.word	0x50434844
    c578:	4556455f 	.word	0x4556455f
    c57c:	535f544e 	.word	0x535f544e
    c580:	49565245 	.word	0x49565245
    c584:	445f4543 	.word	0x445f4543
    c588:	42415349 	.word	0x42415349
    c58c:	0a44454c 	.word	0x0a44454c
    c590:	000d      	.short	0x000d
    c592:	bf00      	nop

Disassembly of section .text.Transform_Sha256%239:

0000c594 <Transform_Sha256>:
         t1 = Sigma0(a(j)) + Maj(a(j), b(j), c(j)); \
         d(j) += t0; \
         h(j)  = t0 + t1

    static int Transform_Sha256(wc_Sha256* sha256, const byte* data)
    {
    c594:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c598:	b0cb      	sub	sp, #300	; 0x12c
    #else
        word32 W[WC_SHA256_BLOCK_SIZE];
    #endif

        /* Copy context->state[] to working vars */
        for (i = 0; i < 8; i++)
    c59a:	f1a0 0a04 	sub.w	sl, r0, #4
    c59e:	aa41      	add	r2, sp, #260	; 0x104
    c5a0:	9200      	str	r2, [sp, #0]
    c5a2:	f100 041c 	add.w	r4, r0, #28
    c5a6:	9401      	str	r4, [sp, #4]
    {
    c5a8:	4653      	mov	r3, sl
            S[i] = sha256->digest[i];
    c5aa:	f853 0f04 	ldr.w	r0, [r3, #4]!
    c5ae:	f842 0f04 	str.w	r0, [r2, #4]!
        for (i = 0; i < 8; i++)
    c5b2:	42a3      	cmp	r3, r4
    c5b4:	d1f9      	bne.n	c5aa <Transform_Sha256+0x16>
    c5b6:	3904      	subs	r1, #4
    c5b8:	f10d 0908 	add.w	r9, sp, #8
    c5bc:	a812      	add	r0, sp, #72	; 0x48
    c5be:	464b      	mov	r3, r9

        for (i = 0; i < 16; i++)
            W[i] = *((word32*)&data[i*sizeof(word32)]);
    c5c0:	f851 2f04 	ldr.w	r2, [r1, #4]!
    c5c4:	f843 2b04 	str.w	r2, [r3], #4
        for (i = 0; i < 16; i++)
    c5c8:	4283      	cmp	r3, r0
    c5ca:	d1f9      	bne.n	c5c0 <Transform_Sha256+0x2c>
    c5cc:	f109 00c0 	add.w	r0, r9, #192	; 0xc0
    c5d0:	464a      	mov	r2, r9

        for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
            W[i] = Gamma1(W[i-2]) + W[i-7] + Gamma0(W[i-15]) + W[i-16];
    c5d2:	4615      	mov	r5, r2
    c5d4:	6b91      	ldr	r1, [r2, #56]	; 0x38
    c5d6:	f852 4f04 	ldr.w	r4, [r2, #4]!
    }

/* This routine performs a right circular arithmetic shift of <x> by <y> value. */
    WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
    {
        return (x >> y) | (x << (sizeof(y) * 8 - y));
    c5da:	ea4f 43f1 	mov.w	r3, r1, ror #19
    c5de:	ea83 4371 	eor.w	r3, r3, r1, ror #17
    c5e2:	ea83 2391 	eor.w	r3, r3, r1, lsr #10
    c5e6:	6a69      	ldr	r1, [r5, #36]	; 0x24
    c5e8:	682d      	ldr	r5, [r5, #0]
    c5ea:	4429      	add	r1, r5
    c5ec:	440b      	add	r3, r1
    c5ee:	ea4f 41b4 	mov.w	r1, r4, ror #18
    c5f2:	ea81 11f4 	eor.w	r1, r1, r4, ror #7
    c5f6:	ea81 01d4 	eor.w	r1, r1, r4, lsr #3
    c5fa:	440b      	add	r3, r1
    c5fc:	63d3      	str	r3, [r2, #60]	; 0x3c
        for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
    c5fe:	4282      	cmp	r2, r0
    c600:	d1e7      	bne.n	c5d2 <Transform_Sha256+0x3e>
    c602:	f8dd e124 	ldr.w	lr, [sp, #292]	; 0x124
    c606:	9a45      	ldr	r2, [sp, #276]	; 0x114
    c608:	f8dd c120 	ldr.w	ip, [sp, #288]	; 0x120
    c60c:	9944      	ldr	r1, [sp, #272]	; 0x110
    c60e:	9f47      	ldr	r7, [sp, #284]	; 0x11c
    c610:	9843      	ldr	r0, [sp, #268]	; 0x10c
    c612:	9b46      	ldr	r3, [sp, #280]	; 0x118
    c614:	9c42      	ldr	r4, [sp, #264]	; 0x108
    c616:	f8df 8284 	ldr.w	r8, [pc, #644]	; c89c <Transform_Sha256+0x308>
    c61a:	46d3      	mov	fp, sl
    c61c:	46ca      	mov	sl, r9
    c61e:	46c1      	mov	r9, r8
    c620:	ea4f 25f3 	mov.w	r5, r3, ror #11
            }
        }
    #else
        /* partially loop unrolled */
        for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
            RND(0); RND(1); RND(2); RND(3);
    c624:	ea85 15b3 	eor.w	r5, r5, r3, ror #6
    c628:	ea85 6873 	eor.w	r8, r5, r3, ror #25
    c62c:	f8d9 5000 	ldr.w	r5, [r9]
    c630:	f8da 6000 	ldr.w	r6, [sl]
    c634:	4435      	add	r5, r6
    c636:	4445      	add	r5, r8
    c638:	ea8c 0607 	eor.w	r6, ip, r7
    c63c:	401e      	ands	r6, r3
    c63e:	ea86 060c 	eor.w	r6, r6, ip
    c642:	4435      	add	r5, r6
    c644:	44ae      	add	lr, r5
    c646:	4472      	add	r2, lr
    c648:	ea4f 3574 	mov.w	r5, r4, ror #13
    c64c:	ea85 05b4 	eor.w	r5, r5, r4, ror #2
    c650:	ea85 55b4 	eor.w	r5, r5, r4, ror #22
    c654:	ea44 0600 	orr.w	r6, r4, r0
    c658:	400e      	ands	r6, r1
    c65a:	ea04 0800 	and.w	r8, r4, r0
    c65e:	ea46 0608 	orr.w	r6, r6, r8
    c662:	4435      	add	r5, r6
    c664:	44ae      	add	lr, r5
    c666:	f8d9 5004 	ldr.w	r5, [r9, #4]
    c66a:	f8da 6004 	ldr.w	r6, [sl, #4]
    c66e:	4435      	add	r5, r6
    c670:	4465      	add	r5, ip
    c672:	ea83 0c07 	eor.w	ip, r3, r7
    c676:	ea0c 0c02 	and.w	ip, ip, r2
    c67a:	ea8c 0c07 	eor.w	ip, ip, r7
    c67e:	4465      	add	r5, ip
    c680:	ea4f 2cf2 	mov.w	ip, r2, ror #11
    c684:	ea8c 1cb2 	eor.w	ip, ip, r2, ror #6
    c688:	ea8c 6c72 	eor.w	ip, ip, r2, ror #25
    c68c:	4465      	add	r5, ip
    c68e:	eb01 0c05 	add.w	ip, r1, r5
    c692:	ea4f 317e 	mov.w	r1, lr, ror #13
    c696:	ea81 01be 	eor.w	r1, r1, lr, ror #2
    c69a:	ea81 51be 	eor.w	r1, r1, lr, ror #22
    c69e:	ea4e 0604 	orr.w	r6, lr, r4
    c6a2:	4006      	ands	r6, r0
    c6a4:	ea0e 0804 	and.w	r8, lr, r4
    c6a8:	ea46 0608 	orr.w	r6, r6, r8
    c6ac:	4431      	add	r1, r6
    c6ae:	4429      	add	r1, r5
    c6b0:	f8d9 5008 	ldr.w	r5, [r9, #8]
    c6b4:	f8da 6008 	ldr.w	r6, [sl, #8]
    c6b8:	4435      	add	r5, r6
    c6ba:	442f      	add	r7, r5
    c6bc:	ea83 0502 	eor.w	r5, r3, r2
    c6c0:	ea05 050c 	and.w	r5, r5, ip
    c6c4:	405d      	eors	r5, r3
    c6c6:	442f      	add	r7, r5
    c6c8:	ea4f 25fc 	mov.w	r5, ip, ror #11
    c6cc:	ea85 15bc 	eor.w	r5, r5, ip, ror #6
    c6d0:	ea85 657c 	eor.w	r5, r5, ip, ror #25
    c6d4:	442f      	add	r7, r5
    c6d6:	eb00 0807 	add.w	r8, r0, r7
    c6da:	ea4f 3071 	mov.w	r0, r1, ror #13
    c6de:	ea80 00b1 	eor.w	r0, r0, r1, ror #2
    c6e2:	ea80 50b1 	eor.w	r0, r0, r1, ror #22
    c6e6:	ea4e 0501 	orr.w	r5, lr, r1
    c6ea:	4025      	ands	r5, r4
    c6ec:	ea0e 0601 	and.w	r6, lr, r1
    c6f0:	4335      	orrs	r5, r6
    c6f2:	4428      	add	r0, r5
    c6f4:	4438      	add	r0, r7
    c6f6:	f8d9 500c 	ldr.w	r5, [r9, #12]
    c6fa:	f8da 600c 	ldr.w	r6, [sl, #12]
    c6fe:	4435      	add	r5, r6
    c700:	442b      	add	r3, r5
    c702:	ea82 050c 	eor.w	r5, r2, ip
    c706:	ea05 0508 	and.w	r5, r5, r8
    c70a:	4055      	eors	r5, r2
    c70c:	442b      	add	r3, r5
    c70e:	ea4f 25f8 	mov.w	r5, r8, ror #11
    c712:	ea85 15b8 	eor.w	r5, r5, r8, ror #6
    c716:	ea85 6578 	eor.w	r5, r5, r8, ror #25
    c71a:	441d      	add	r5, r3
    c71c:	1966      	adds	r6, r4, r5
    c71e:	ea4f 3370 	mov.w	r3, r0, ror #13
    c722:	ea83 03b0 	eor.w	r3, r3, r0, ror #2
    c726:	ea83 53b0 	eor.w	r3, r3, r0, ror #22
    c72a:	ea41 0400 	orr.w	r4, r1, r0
    c72e:	ea04 040e 	and.w	r4, r4, lr
    c732:	ea01 0700 	and.w	r7, r1, r0
    c736:	433c      	orrs	r4, r7
    c738:	4423      	add	r3, r4
    c73a:	442b      	add	r3, r5
            RND(4); RND(5); RND(6); RND(7);
    c73c:	f8d9 4010 	ldr.w	r4, [r9, #16]
    c740:	f8da 5010 	ldr.w	r5, [sl, #16]
    c744:	442c      	add	r4, r5
    c746:	4422      	add	r2, r4
    c748:	ea8c 0408 	eor.w	r4, ip, r8
    c74c:	4034      	ands	r4, r6
    c74e:	ea84 040c 	eor.w	r4, r4, ip
    c752:	4422      	add	r2, r4
    c754:	ea4f 24f6 	mov.w	r4, r6, ror #11
    c758:	ea84 14b6 	eor.w	r4, r4, r6, ror #6
    c75c:	ea84 6476 	eor.w	r4, r4, r6, ror #25
    c760:	4414      	add	r4, r2
    c762:	44a6      	add	lr, r4
    c764:	ea4f 3273 	mov.w	r2, r3, ror #13
    c768:	ea82 02b3 	eor.w	r2, r2, r3, ror #2
    c76c:	ea82 52b3 	eor.w	r2, r2, r3, ror #22
    c770:	ea40 0503 	orr.w	r5, r0, r3
    c774:	400d      	ands	r5, r1
    c776:	ea00 0703 	and.w	r7, r0, r3
    c77a:	433d      	orrs	r5, r7
    c77c:	442a      	add	r2, r5
    c77e:	4422      	add	r2, r4
    c780:	f8d9 4014 	ldr.w	r4, [r9, #20]
    c784:	f8da 5014 	ldr.w	r5, [sl, #20]
    c788:	442c      	add	r4, r5
    c78a:	4464      	add	r4, ip
    c78c:	ea88 0c06 	eor.w	ip, r8, r6
    c790:	ea0c 0c0e 	and.w	ip, ip, lr
    c794:	ea8c 0c08 	eor.w	ip, ip, r8
    c798:	4464      	add	r4, ip
    c79a:	ea4f 2cfe 	mov.w	ip, lr, ror #11
    c79e:	ea8c 1cbe 	eor.w	ip, ip, lr, ror #6
    c7a2:	ea8c 6c7e 	eor.w	ip, ip, lr, ror #25
    c7a6:	4464      	add	r4, ip
    c7a8:	eb01 0c04 	add.w	ip, r1, r4
    c7ac:	ea4f 3172 	mov.w	r1, r2, ror #13
    c7b0:	ea81 01b2 	eor.w	r1, r1, r2, ror #2
    c7b4:	ea81 51b2 	eor.w	r1, r1, r2, ror #22
    c7b8:	ea43 0502 	orr.w	r5, r3, r2
    c7bc:	4005      	ands	r5, r0
    c7be:	ea03 0702 	and.w	r7, r3, r2
    c7c2:	433d      	orrs	r5, r7
    c7c4:	4429      	add	r1, r5
    c7c6:	4421      	add	r1, r4
    c7c8:	f8d9 4018 	ldr.w	r4, [r9, #24]
    c7cc:	f8da 5018 	ldr.w	r5, [sl, #24]
    c7d0:	442c      	add	r4, r5
    c7d2:	44a0      	add	r8, r4
    c7d4:	ea86 040e 	eor.w	r4, r6, lr
    c7d8:	ea04 040c 	and.w	r4, r4, ip
    c7dc:	4074      	eors	r4, r6
    c7de:	44a0      	add	r8, r4
    c7e0:	ea4f 24fc 	mov.w	r4, ip, ror #11
    c7e4:	ea84 14bc 	eor.w	r4, r4, ip, ror #6
    c7e8:	ea84 647c 	eor.w	r4, r4, ip, ror #25
    c7ec:	44a0      	add	r8, r4
    c7ee:	eb00 0708 	add.w	r7, r0, r8
    c7f2:	ea4f 3071 	mov.w	r0, r1, ror #13
    c7f6:	ea80 00b1 	eor.w	r0, r0, r1, ror #2
    c7fa:	ea80 50b1 	eor.w	r0, r0, r1, ror #22
    c7fe:	ea42 0401 	orr.w	r4, r2, r1
    c802:	401c      	ands	r4, r3
    c804:	ea02 0501 	and.w	r5, r2, r1
    c808:	432c      	orrs	r4, r5
    c80a:	4420      	add	r0, r4
    c80c:	4440      	add	r0, r8
    c80e:	f8d9 401c 	ldr.w	r4, [r9, #28]
    c812:	f8da 501c 	ldr.w	r5, [sl, #28]
    c816:	442c      	add	r4, r5
    c818:	4434      	add	r4, r6
    c81a:	ea8e 060c 	eor.w	r6, lr, ip
    c81e:	403e      	ands	r6, r7
    c820:	ea86 060e 	eor.w	r6, r6, lr
    c824:	4434      	add	r4, r6
    c826:	ea4f 26f7 	mov.w	r6, r7, ror #11
    c82a:	ea86 16b7 	eor.w	r6, r6, r7, ror #6
    c82e:	ea86 6677 	eor.w	r6, r6, r7, ror #25
    c832:	4426      	add	r6, r4
    c834:	4433      	add	r3, r6
    c836:	ea4f 3470 	mov.w	r4, r0, ror #13
    c83a:	ea84 04b0 	eor.w	r4, r4, r0, ror #2
    c83e:	ea84 54b0 	eor.w	r4, r4, r0, ror #22
    c842:	ea41 0500 	orr.w	r5, r1, r0
    c846:	4015      	ands	r5, r2
    c848:	ea01 0800 	and.w	r8, r1, r0
    c84c:	ea45 0508 	orr.w	r5, r5, r8
    c850:	442c      	add	r4, r5
    c852:	4434      	add	r4, r6
    c854:	f109 0920 	add.w	r9, r9, #32
    c858:	f10a 0a20 	add.w	sl, sl, #32
        for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
    c85c:	4d0e      	ldr	r5, [pc, #56]	; (c898 <Transform_Sha256+0x304>)
    c85e:	45a9      	cmp	r9, r5
    c860:	f47f aede 	bne.w	c620 <Transform_Sha256+0x8c>
    c864:	46da      	mov	sl, fp
    c866:	f8cd e124 	str.w	lr, [sp, #292]	; 0x124
    c86a:	9346      	str	r3, [sp, #280]	; 0x118
    c86c:	f8cd c120 	str.w	ip, [sp, #288]	; 0x120
    c870:	9747      	str	r7, [sp, #284]	; 0x11c
    c872:	9442      	str	r4, [sp, #264]	; 0x108
    c874:	9043      	str	r0, [sp, #268]	; 0x10c
    c876:	9144      	str	r1, [sp, #272]	; 0x110
    c878:	9245      	str	r2, [sp, #276]	; 0x114
    c87a:	9a00      	ldr	r2, [sp, #0]
    c87c:	9801      	ldr	r0, [sp, #4]
        }
    #endif /* USE_SLOW_SHA256 */

        /* Add the working vars back into digest state[] */
        for (i = 0; i < 8; i++) {
            sha256->digest[i] += S[i];
    c87e:	f85a 3f04 	ldr.w	r3, [sl, #4]!
    c882:	f852 1f04 	ldr.w	r1, [r2, #4]!
    c886:	440b      	add	r3, r1
    c888:	f8ca 3000 	str.w	r3, [sl]
        for (i = 0; i < 8; i++) {
    c88c:	4582      	cmp	sl, r0
    c88e:	d1f6      	bne.n	c87e <Transform_Sha256+0x2ea>

    #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SMALL_STACK_CACHE)
        XFREE(W, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    #endif
        return 0;
    }
    c890:	2000      	movs	r0, #0
    c892:	b04b      	add	sp, #300	; 0x12c
    c894:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c898:	00015a58 	.word	0x00015a58
    c89c:	00015958 	.word	0x00015958

Disassembly of section .text.DRV_GMAC_Initialize%240:

0000c8a0 <DRV_GMAC_Initialize>:
 *                  It should be called to be able to schedule any MAC transmit or receive operation.
 *
 * Note:            Only one client per MAC supported. 
 *****************************************************************************/
SYS_MODULE_OBJ DRV_GMAC_Initialize(const SYS_MODULE_INDEX index, const SYS_MODULE_INIT * const init)
{
    c8a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c8a4:	b084      	sub	sp, #16
    if(macIx >= 0 && macIx < sizeof(_gmac_drv_dcpt)/sizeof(*_gmac_drv_dcpt))
    c8a6:	f241 0350 	movw	r3, #4176	; 0x1050
    c8aa:	4298      	cmp	r0, r3
    c8ac:	f040 8142 	bne.w	cb34 <DRV_GMAC_Initialize+0x294>
		return SYS_MODULE_OBJ_INVALID;      // no such type supported
	}
   
    pMACDrv = _gmac_drv_dcpt + macIx;

	if(pMACDrv->sGmacData._macFlags._init != 0)
    c8b0:	4bb9      	ldr	r3, [pc, #740]	; (cb98 <DRV_GMAC_Initialize+0x2f8>)
    c8b2:	7d9b      	ldrb	r3, [r3, #22]
    c8b4:	f013 0f01 	tst.w	r3, #1
    c8b8:	f040 8131 	bne.w	cb1e <DRV_GMAC_Initialize+0x27e>
	{   // already initialized	
		return (SYS_MODULE_OBJ)pMACDrv;
	}
	    	
	if(pMACDrv->sGmacData._macFlags._open != 0)
    c8bc:	f013 0602 	ands.w	r6, r3, #2
    c8c0:	f040 813b 	bne.w	cb3a <DRV_GMAC_Initialize+0x29a>
	const TCPIP_MAC_MODULE_CTRL* const macControl = ((TCPIP_MAC_INIT*)init)->macControl;	
    c8c4:	684f      	ldr	r7, [r1, #4]
	{
		return SYS_MODULE_OBJ_INVALID;     // have a client connected
	}

	if(macControl->memH == 0)
    c8c6:	68fb      	ldr	r3, [r7, #12]
    c8c8:	2b00      	cmp	r3, #0
    c8ca:	f000 8139 	beq.w	cb40 <DRV_GMAC_Initialize+0x2a0>
    const TCPIP_MODULE_MAC_PIC32C_CONFIG* initData = (const TCPIP_MODULE_MAC_PIC32C_CONFIG*)((TCPIP_MAC_INIT*)init)->moduleData;
    c8ce:	688c      	ldr	r4, [r1, #8]
	{
		return SYS_MODULE_OBJ_INVALID;     // not possible without dynamic memory!
	}

	if(initData == 0)
    c8d0:	2c00      	cmp	r4, #0
    c8d2:	f000 8138 	beq.w	cb46 <DRV_GMAC_Initialize+0x2a6>
	{
		return SYS_MODULE_OBJ_INVALID;     // not possible without init data!
	}

	if(initData->pPhyBase == 0 || initData->pPhyInit == 0)
    c8d6:	6a23      	ldr	r3, [r4, #32]
    c8d8:	2b00      	cmp	r3, #0
    c8da:	f000 8137 	beq.w	cb4c <DRV_GMAC_Initialize+0x2ac>
    c8de:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c8e0:	2b00      	cmp	r3, #0
    c8e2:	f000 8136 	beq.w	cb52 <DRV_GMAC_Initialize+0x2b2>
	{
		return SYS_MODULE_OBJ_INVALID;     // not possible without a PHY!
	}
	
	// init the MAC object
    memset(&pMACDrv->sGmacData, 0x0, sizeof(pMACDrv->sGmacData)); 
    c8e6:	4dac      	ldr	r5, [pc, #688]	; (cb98 <DRV_GMAC_Initialize+0x2f8>)
    c8e8:	22e4      	movs	r2, #228	; 0xe4
    c8ea:	2100      	movs	r1, #0
    c8ec:	f105 0014 	add.w	r0, r5, #20
    c8f0:	f017 fad6 	bl	23ea0 <memset>
    pMACDrv->sGmacData.hPhyClient = DRV_HANDLE_INVALID;
    c8f4:	f04f 33ff 	mov.w	r3, #4294967295
    c8f8:	612b      	str	r3, [r5, #16]
    pMACDrv->sGmacData.hPhySysObject = SYS_MODULE_OBJ_INVALID;
    c8fa:	60eb      	str	r3, [r5, #12]
    pMACDrv->sGmacData.sysStat = SYS_STATUS_UNINITIALIZED;
    c8fc:	2300      	movs	r3, #0
    c8fe:	752b      	strb	r3, [r5, #20]
	
    pMACDrv->sGmacData._macIx = macIx;
    c900:	606b      	str	r3, [r5, #4]
    pMACDrv->sGmacData._phyIx = macIx;    // use the same index for the associated PHY
    c902:	60ab      	str	r3, [r5, #8]
    pMACDrv->sGmacData._macFlags._linkPrev = 0;	
    c904:	f04f 0200 	mov.w	r2, #0
    c908:	f363 1204 	bfi	r2, r3, #4, #1
    c90c:	75aa      	strb	r2, [r5, #22]

    // update interrupt source for GMAC priority queues
	DRV_PIC32CGMAC_LibSetInterruptSrc(pMACDrv);
    c90e:	4628      	mov	r0, r5
    c910:	f017 fa16 	bl	23d40 <DRV_PIC32CGMAC_LibSetInterruptSrc>
    // use initialization data
    pMACDrv->sGmacData._AllocH = macControl->memH;
    c914:	68fb      	ldr	r3, [r7, #12]
    c916:	61ab      	str	r3, [r5, #24]
    pMACDrv->sGmacData._callocF = macControl->callocF;
    c918:	687b      	ldr	r3, [r7, #4]
    c91a:	61eb      	str	r3, [r5, #28]
    pMACDrv->sGmacData._freeF = macControl->freeF;
    c91c:	68bb      	ldr	r3, [r7, #8]
    c91e:	622b      	str	r3, [r5, #32]
    pMACDrv->sGmacData._dcptOffset = macControl->gapDcptOffset;
    c920:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
    c924:	f8a5 30ec 	strh.w	r3, [r5, #236]	; 0xec


    pMACDrv->sGmacData.pktAllocF = macControl->pktAllocF;
    c928:	693b      	ldr	r3, [r7, #16]
    c92a:	626b      	str	r3, [r5, #36]	; 0x24
    pMACDrv->sGmacData.pktFreeF = macControl->pktFreeF;
    c92c:	697b      	ldr	r3, [r7, #20]
    c92e:	62ab      	str	r3, [r5, #40]	; 0x28
    pMACDrv->sGmacData.pktAckF = macControl->pktAckF;
    c930:	69bb      	ldr	r3, [r7, #24]
    c932:	62eb      	str	r3, [r5, #44]	; 0x2c

    pMACDrv->sGmacData._synchF = macControl->synchF;
    c934:	69fb      	ldr	r3, [r7, #28]
    c936:	632b      	str	r3, [r5, #48]	; 0x30
	
    pMACDrv->sGmacData._controlFlags = macControl->controlFlags;
    c938:	8efb      	ldrh	r3, [r7, #54]	; 0x36
    c93a:	f8a5 30f4 	strh.w	r3, [r5, #244]	; 0xf4
    pMACDrv->sGmacData._dataOffset = (macControl->controlFlags & TCPIP_MAC_CONTROL_PAYLOAD_OFFSET_2) == 0 ? 0 : 2;
    c93e:	f013 0f01 	tst.w	r3, #1
    c942:	bf18      	it	ne
    c944:	2602      	movne	r6, #2
    c946:	f885 60f6 	strb.w	r6, [r5, #246]	; 0xf6
    pMACDrv->sGmacData._dataOffsetMask = (macControl->controlFlags & TCPIP_MAC_CONTROL_PAYLOAD_OFFSET_2) != 0 ? 0xfffffffc : 0xffffffff;
    c94a:	8efb      	ldrh	r3, [r7, #54]	; 0x36
    c94c:	f013 0f01 	tst.w	r3, #1
    c950:	bf14      	ite	ne
    c952:	f06f 0303 	mvnne.w	r3, #3
    c956:	f04f 33ff 	moveq.w	r3, #4294967295
    c95a:	462e      	mov	r6, r5
    c95c:	f8c5 30f0 	str.w	r3, [r5, #240]	; 0xf0
    pMACDrv->sGmacData._txDiscard = false;
    c960:	2300      	movs	r3, #0
    c962:	f885 30f7 	strb.w	r3, [r5, #247]	; 0xf7
	// copy the configuration data
	pMACDrv->sGmacData.gmacConfig = *initData;	
    c966:	35b8      	adds	r5, #184	; 0xb8
    c968:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    c96a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    c96c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    c96e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    c970:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    c972:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    c974:	6823      	ldr	r3, [r4, #0]
    c976:	602b      	str	r3, [r5, #0]
	
    DRV_GMAC_LibDescriptorsPoolAdd (pMACDrv, DRV_GMAC_DCPT_TYPE_RX);
    c978:	2101      	movs	r1, #1
    c97a:	4630      	mov	r0, r6
    c97c:	f016 f900 	bl	22b80 <DRV_GMAC_LibDescriptorsPoolAdd>
    DRV_GMAC_LibDescriptorsPoolAdd (pMACDrv, DRV_GMAC_DCPT_TYPE_TX);
    c980:	2102      	movs	r1, #2
    c982:	4630      	mov	r0, r6
    c984:	f016 f8fc 	bl	22b80 <DRV_GMAC_LibDescriptorsPoolAdd>
    
	for(queueIdx = GMAC_QUE_0; queueIdx < DRV_GMAC_NUMBER_OF_QUEUES; queueIdx++)
	{
		if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt < DRV_GMAC_MIN_TX_DESCRIPTORS)
    c988:	f8b6 30c8 	ldrh.w	r3, [r6, #200]	; 0xc8
    c98c:	2b00      	cmp	r3, #0
    c98e:	f000 80e3 	beq.w	cb58 <DRV_GMAC_Initialize+0x2b8>
		{
			return SYS_MODULE_OBJ_INVALID; //return invalid than setting min dscp count
		}
        
        uint16_t rxBufferSize = pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].rxBufferSize;
    c992:	f8b6 30cc 	ldrh.w	r3, [r6, #204]	; 0xcc

		if(rxBufferSize < DRV_GMAC_MIN_RX_SIZE)
    c996:	2b3f      	cmp	r3, #63	; 0x3f
    c998:	f240 80e1 	bls.w	cb5e <DRV_GMAC_Initialize+0x2be>
        if(rxBufferSize > TCPIP_GMAC_RX_MAX_FRAME)
        {   // no need to exceed the max allowed RX frame
            rxBufferSize = TCPIP_GMAC_RX_MAX_FRAME;
        }
        // GMAC RX buffer size needs to be multiple of 64
        rxBufferSize = ((rxBufferSize + 63) / 64) * 64;
    c99c:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
    c9a0:	bf28      	it	cs
    c9a2:	f44f 63c0 	movcs.w	r3, #1536	; 0x600
    c9a6:	333f      	adds	r3, #63	; 0x3f
        pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].rxBufferSize = rxBufferSize;
    c9a8:	487b      	ldr	r0, [pc, #492]	; (cb98 <DRV_GMAC_Initialize+0x2f8>)
        rxBufferSize = ((rxBufferSize + 63) / 64) * 64;
    c9aa:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
        pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].rxBufferSize = rxBufferSize;
    c9ae:	f8a0 30cc 	strh.w	r3, [r0, #204]	; 0xcc
	}
	
    if(!DRV_PIC32CGMAC_LibSetPriorityToQueueNum(pMACDrv))
    c9b2:	f017 faa5 	bl	23f00 <DRV_PIC32CGMAC_LibSetPriorityToQueueNum>
    c9b6:	2800      	cmp	r0, #0
    c9b8:	f000 80d7 	beq.w	cb6a <DRV_GMAC_Initialize+0x2ca>
    {
        return SYS_MODULE_OBJ_INVALID; //return invalid
    }
        
	//set the MAC address received from system config
	memcpy((pMACDrv->sGmacData.gmacConfig.macAddress.v), (macControl->ifPhyAddress.v),sizeof(macControl->ifPhyAddress));	
    c9bc:	4b76      	ldr	r3, [pc, #472]	; (cb98 <DRV_GMAC_Initialize+0x2f8>)
    c9be:	463a      	mov	r2, r7
    c9c0:	f852 0f38 	ldr.w	r0, [r2, #56]!
    c9c4:	f8c3 00b8 	str.w	r0, [r3, #184]	; 0xb8
    c9c8:	8892      	ldrh	r2, [r2, #4]
    c9ca:	f8a3 20bc 	strh.w	r2, [r3, #188]	; 0xbc
	return (pMACDrv->sGmacData._synchF == 0) ? true : (*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_CREATE);
    c9ce:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    c9d0:	b12b      	cbz	r3, c9de <DRV_GMAC_Initialize+0x13e>
    c9d2:	2101      	movs	r1, #1
    c9d4:	4871      	ldr	r0, [pc, #452]	; (cb9c <DRV_GMAC_Initialize+0x2fc>)
    c9d6:	4798      	blx	r3
    c9d8:	2800      	cmp	r0, #0
    c9da:	f000 80c3 	beq.w	cb64 <DRV_GMAC_Initialize+0x2c4>
	while(1)
	{
		uint32_t rxfilter= 0;

		// start the initialization sequence
		DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, NULL);
    c9de:	4c6e      	ldr	r4, [pc, #440]	; (cb98 <DRV_GMAC_Initialize+0x2f8>)
    c9e0:	2200      	movs	r2, #0
    c9e2:	213f      	movs	r1, #63	; 0x3f
    c9e4:	4620      	mov	r0, r4
    c9e6:	f015 fd9b 	bl	22520 <DRV_PIC32CGMAC_LibSysInt_Disable>
	const DRV_ETHPHY_OBJECT_BASE* pPhyBase;	
	int phyIx = pMACDrv->sGmacData._phyIx;
	TCPIP_MAC_RES   initRes;
	DRV_ETHPHY_RESULT   phyInitRes;	

	pPhyBase =  pMACDrv->sGmacData.gmacConfig.pPhyBase; 
    c9ea:	f8d4 50d8 	ldr.w	r5, [r4, #216]	; 0xd8

	hPhySysObject = pPhyBase->DRV_ETHPHY_Initialize(phyIx,  (SYS_MODULE_INIT *)pMACDrv->sGmacData.gmacConfig.pPhyInit);
    c9ee:	8926      	ldrh	r6, [r4, #8]
    c9f0:	682b      	ldr	r3, [r5, #0]
    c9f2:	f8d4 10dc 	ldr.w	r1, [r4, #220]	; 0xdc
    c9f6:	4630      	mov	r0, r6
    c9f8:	4798      	blx	r3
	if ( hPhySysObject == SYS_MODULE_OBJ_INVALID )
    c9fa:	f1b0 3fff 	cmp.w	r0, #4294967295
    c9fe:	f000 8093 	beq.w	cb28 <DRV_GMAC_Initialize+0x288>
	{
		initRes = TCPIP_MAC_RES_PHY_INIT_FAIL;
		return initRes;
	}

	pMACDrv->sGmacData.hPhySysObject = hPhySysObject;
    ca02:	60e0      	str	r0, [r4, #12]
	hPhyClient = pPhyBase->DRV_ETHPHY_Open(phyIx, DRV_IO_INTENT_READWRITE);
    ca04:	696b      	ldr	r3, [r5, #20]
    ca06:	2103      	movs	r1, #3
    ca08:	4630      	mov	r0, r6
    ca0a:	4798      	blx	r3
	if ( DRV_HANDLE_INVALID == hPhyClient )
    ca0c:	f1b0 3fff 	cmp.w	r0, #4294967295
    ca10:	f000 808a 	beq.w	cb28 <DRV_GMAC_Initialize+0x288>
	{
		initRes = TCPIP_MAC_RES_PHY_INIT_FAIL;
		return initRes;
	}
	
	pMACDrv->sGmacData.hPhyClient = hPhyClient;
    ca14:	4622      	mov	r2, r4
    ca16:	6120      	str	r0, [r4, #16]
	phySetup.phyAddress = pMACDrv->sGmacData.gmacConfig.pPhyInit->phyAddress;
    ca18:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
    ca1c:	8919      	ldrh	r1, [r3, #8]
    ca1e:	9100      	str	r1, [sp, #0]
	phySetup.openFlags = pMACDrv->sGmacData.gmacConfig.ethFlags;
    ca20:	f8b4 10d2 	ldrh.w	r1, [r4, #210]	; 0xd2
    ca24:	f8ad 1004 	strh.w	r1, [sp, #4]
	phySetup.configFlags = pMACDrv->sGmacData.gmacConfig.pPhyInit->phyFlags;
    ca28:	7a99      	ldrb	r1, [r3, #10]
    ca2a:	f88d 1006 	strb.w	r1, [sp, #6]
	phySetup.macPauseType = DRV_GMAC_PAUSE_CPBL_MASK;
    ca2e:	210f      	movs	r1, #15
    ca30:	f88d 1007 	strb.w	r1, [sp, #7]
	phySetup.resetFunction = pMACDrv->sGmacData.gmacConfig.pPhyInit->resetFunction;
    ca34:	691b      	ldr	r3, [r3, #16]
    ca36:	9302      	str	r3, [sp, #8]
		
	phyInitRes = pPhyBase->DRV_ETHPHY_Setup(hPhyClient, &phySetup, &pMACDrv->sGmacData._linkResFlags);
    ca38:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    ca3a:	3234      	adds	r2, #52	; 0x34
    ca3c:	4669      	mov	r1, sp
    ca3e:	4798      	blx	r3
	
	if(phyInitRes < 0)
    ca40:	2800      	cmp	r0, #0
    ca42:	db71      	blt.n	cb28 <DRV_GMAC_Initialize+0x288>
		DRV_PIC32CGMAC_LibInit(pMACDrv);
    ca44:	4c54      	ldr	r4, [pc, #336]	; (cb98 <DRV_GMAC_Initialize+0x2f8>)
    ca46:	4620      	mov	r0, r4
    ca48:	f00e fce0 	bl	1b40c <DRV_PIC32CGMAC_LibInit>
            hash.hash_value = -1; //Set 64-bit Hash value to all 1s, to receive all multi-cast
    ca4c:	f04f 32ff 	mov.w	r2, #4294967295
    ca50:	f04f 33ff 	mov.w	r3, #4294967295
    ca54:	e9cd 2300 	strd	r2, r3, [sp]
            hash.calculate_hash = false; // No hash calculation; directly set hash register
    ca58:	2300      	movs	r3, #0
    ca5a:	f88d 300c 	strb.w	r3, [sp, #12]
            DRV_PIC32CGMAC_LibRxFilterHash_Calculate(pMACDrv, &hash);
    ca5e:	4669      	mov	r1, sp
    ca60:	4620      	mov	r0, r4
    ca62:	f004 fdaf 	bl	115c4 <DRV_PIC32CGMAC_LibRxFilterHash_Calculate>
		rxfilter = (uint32_t)(GMAC_REGS->GMAC_NCFGR) & (~GMAC_FILT_ALL_FILTERS); 
    ca66:	4a4e      	ldr	r2, [pc, #312]	; (cba0 <DRV_GMAC_Initialize+0x300>)
    ca68:	6853      	ldr	r3, [r2, #4]
    ca6a:	f023 5310 	bic.w	r3, r3, #603979776	; 0x24000000
    ca6e:	f423 73fc 	bic.w	r3, r3, #504	; 0x1f8
		GMAC_REGS->GMAC_NCFGR  = (rxfilter|gmacRxFilt) ;
    ca72:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    ca76:	6053      	str	r3, [r2, #4]
        if(DRV_PIC32CGMAC_LibRxQueFilterInit(pMACDrv) != DRV_PIC32CGMAC_RES_OK)
    ca78:	4620      	mov	r0, r4
    ca7a:	f00c fdaf 	bl	195dc <DRV_PIC32CGMAC_LibRxQueFilterInit>
    ca7e:	2800      	cmp	r0, #0
    ca80:	d152      	bne.n	cb28 <DRV_GMAC_Initialize+0x288>
		if(DRV_PIC32CGMAC_LibRxInit(pMACDrv) != DRV_PIC32CGMAC_RES_OK)
    ca82:	4845      	ldr	r0, [pc, #276]	; (cb98 <DRV_GMAC_Initialize+0x2f8>)
    ca84:	f00a fd36 	bl	174f4 <DRV_PIC32CGMAC_LibRxInit>
    ca88:	2800      	cmp	r0, #0
    ca8a:	d14d      	bne.n	cb28 <DRV_GMAC_Initialize+0x288>
		if(DRV_PIC32CGMAC_LibTxInit(pMACDrv) != DRV_PIC32CGMAC_RES_OK)
    ca8c:	4842      	ldr	r0, [pc, #264]	; (cb98 <DRV_GMAC_Initialize+0x2f8>)
    ca8e:	f00e fe2f 	bl	1b6f0 <DRV_PIC32CGMAC_LibTxInit>
    ca92:	2800      	cmp	r0, #0
    ca94:	d148      	bne.n	cb28 <DRV_GMAC_Initialize+0x288>
            if(DRV_PIC32CGMAC_LibInitTransfer(pMACDrv,queueIdx) != DRV_PIC32CGMAC_RES_OK)
    ca96:	2100      	movs	r1, #0
    ca98:	483f      	ldr	r0, [pc, #252]	; (cb98 <DRV_GMAC_Initialize+0x2f8>)
    ca9a:	f00d fa29 	bl	19ef0 <DRV_PIC32CGMAC_LibInitTransfer>
    ca9e:	4606      	mov	r6, r0
    caa0:	2800      	cmp	r0, #0
    caa2:	d165      	bne.n	cb70 <DRV_GMAC_Initialize+0x2d0>
        DRV_PIC32CGMAC_LibSysIntStatus_Clear(pMACDrv, GMAC_ALL_QUE_MASK);
    caa4:	4d3c      	ldr	r5, [pc, #240]	; (cb98 <DRV_GMAC_Initialize+0x2f8>)
    caa6:	213f      	movs	r1, #63	; 0x3f
    caa8:	4628      	mov	r0, r5
    caaa:	f015 f9e7 	bl	21e7c <DRV_PIC32CGMAC_LibSysIntStatus_Clear>
        DRV_PIC32CGMAC_LibSysInt_Enable(pMACDrv, GMAC_ALL_QUE_MASK);
    caae:	213f      	movs	r1, #63	; 0x3f
    cab0:	4628      	mov	r0, r5
    cab2:	f015 f9f7 	bl	21ea4 <DRV_PIC32CGMAC_LibSysInt_Enable>
		DRV_PIC32CGMAC_LibTransferEnable(pMACDrv); //enable Transmit and Receive of GMAC
    cab6:	4628      	mov	r0, r5
    cab8:	f016 f852 	bl	22b60 <DRV_PIC32CGMAC_LibTransferEnable>
        if(DRV_GMAC_EventInit((DRV_HANDLE)pMACDrv, macControl->eventF, macControl->eventParam) != TCPIP_MAC_RES_OK)
    cabc:	462c      	mov	r4, r5
	if(_hEventMac == hMac)
    cabe:	4b39      	ldr	r3, [pc, #228]	; (cba4 <DRV_GMAC_Initialize+0x304>)
    cac0:	681b      	ldr	r3, [r3, #0]
    cac2:	42ab      	cmp	r3, r5
    cac4:	d01c      	beq.n	cb00 <DRV_GMAC_Initialize+0x260>
	else if(_hEventMac != 0)
    cac6:	bb7b      	cbnz	r3, cb28 <DRV_GMAC_Initialize+0x288>
        if(DRV_GMAC_EventInit((DRV_HANDLE)pMACDrv, macControl->eventF, macControl->eventParam) != TCPIP_MAC_RES_OK)
    cac8:	f8d7 8020 	ldr.w	r8, [r7, #32]
    cacc:	6a7f      	ldr	r7, [r7, #36]	; 0x24
    DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, NULL);
    cace:	4d32      	ldr	r5, [pc, #200]	; (cb98 <DRV_GMAC_Initialize+0x2f8>)
    cad0:	2200      	movs	r2, #0
    cad2:	213f      	movs	r1, #63	; 0x3f
    cad4:	4628      	mov	r0, r5
    cad6:	f015 fd23 	bl	22520 <DRV_PIC32CGMAC_LibSysInt_Disable>
    DRV_PIC32CGMAC_LibSysIntStatus_Clear(pMACDrv, GMAC_ALL_QUE_MASK);
    cada:	213f      	movs	r1, #63	; 0x3f
    cadc:	4628      	mov	r0, r5
    cade:	f015 f9cd 	bl	21e7c <DRV_PIC32CGMAC_LibSysIntStatus_Clear>
	pDcpt->_TcpEnabledEvents = pDcpt->_TcpPendingEvents = TCPIP_MAC_EV_NONE;
    cae2:	2300      	movs	r3, #0
    cae4:	f8a5 304e 	strh.w	r3, [r5, #78]	; 0x4e
    cae8:	f8a5 304c 	strh.w	r3, [r5, #76]	; 0x4c
	pDcpt->_EthEnabledEvents = pDcpt->_EthPendingEvents = 0;
    caec:	f8a5 3052 	strh.w	r3, [r5, #82]	; 0x52
    caf0:	f8a5 3050 	strh.w	r3, [r5, #80]	; 0x50
	pDcpt->_TcpNotifyFnc = eventF;
    caf4:	f8c5 8054 	str.w	r8, [r5, #84]	; 0x54
	pDcpt->_TcpNotifyParam = eventParam;
    caf8:	65af      	str	r7, [r5, #88]	; 0x58
	_hEventMac = hMac;
    cafa:	4b2a      	ldr	r3, [pc, #168]	; (cba4 <DRV_GMAC_Initialize+0x304>)
    cafc:	601c      	str	r4, [r3, #0]
	if(initRes != TCPIP_MAC_RES_OK)
    cafe:	b99e      	cbnz	r6, cb28 <DRV_GMAC_Initialize+0x288>
	pMACDrv->sGmacData._macFlags._init = 1;	
    cb00:	4b25      	ldr	r3, [pc, #148]	; (cb98 <DRV_GMAC_Initialize+0x2f8>)
    cb02:	7d9a      	ldrb	r2, [r3, #22]
    cb04:	f042 0201 	orr.w	r2, r2, #1
    cb08:	759a      	strb	r2, [r3, #22]
	pMACDrv->sGmacData.sysStat = SYS_STATUS_BUSY;
    cb0a:	2201      	movs	r2, #1
    cb0c:	751a      	strb	r2, [r3, #20]
    pMACDrv->sGmacData._rxStat.nRxErrorPackets = 0;
    cb0e:	2200      	movs	r2, #0
    cb10:	671a      	str	r2, [r3, #112]	; 0x70
    pMACDrv->sGmacData._rxStat.nRxFragmentErrors = -1;
    cb12:	f04f 31ff 	mov.w	r1, #4294967295
    cb16:	6759      	str	r1, [r3, #116]	; 0x74
    pMACDrv->sGmacData._rxStat.nRxPendBuffers = 0;
    cb18:	669a      	str	r2, [r3, #104]	; 0x68
    pMACDrv->sGmacData._rxStat.nRxSchedBuffers = 0;
    cb1a:	66da      	str	r2, [r3, #108]	; 0x6c
	return (SYS_MODULE_OBJ)pMACDrv;
    cb1c:	e000      	b.n	cb20 <DRV_GMAC_Initialize+0x280>
		return (SYS_MODULE_OBJ)pMACDrv;
    cb1e:	4c1e      	ldr	r4, [pc, #120]	; (cb98 <DRV_GMAC_Initialize+0x2f8>)
}
    cb20:	4620      	mov	r0, r4
    cb22:	b004      	add	sp, #16
    cb24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		_MACDeinit(pMACDrv);
    cb28:	481b      	ldr	r0, [pc, #108]	; (cb98 <DRV_GMAC_Initialize+0x2f8>)
    cb2a:	f006 fd19 	bl	13560 <_MACDeinit>
		return SYS_MODULE_OBJ_INVALID;
    cb2e:	f04f 34ff 	mov.w	r4, #4294967295
    cb32:	e7f5      	b.n	cb20 <DRV_GMAC_Initialize+0x280>
		return SYS_MODULE_OBJ_INVALID;      // no such type supported
    cb34:	f04f 34ff 	mov.w	r4, #4294967295
    cb38:	e7f2      	b.n	cb20 <DRV_GMAC_Initialize+0x280>
		return SYS_MODULE_OBJ_INVALID;     // have a client connected
    cb3a:	f04f 34ff 	mov.w	r4, #4294967295
    cb3e:	e7ef      	b.n	cb20 <DRV_GMAC_Initialize+0x280>
		return SYS_MODULE_OBJ_INVALID;     // not possible without dynamic memory!
    cb40:	f04f 34ff 	mov.w	r4, #4294967295
    cb44:	e7ec      	b.n	cb20 <DRV_GMAC_Initialize+0x280>
		return SYS_MODULE_OBJ_INVALID;     // not possible without init data!
    cb46:	f04f 34ff 	mov.w	r4, #4294967295
    cb4a:	e7e9      	b.n	cb20 <DRV_GMAC_Initialize+0x280>
		return SYS_MODULE_OBJ_INVALID;     // not possible without a PHY!
    cb4c:	f04f 34ff 	mov.w	r4, #4294967295
    cb50:	e7e6      	b.n	cb20 <DRV_GMAC_Initialize+0x280>
    cb52:	f04f 34ff 	mov.w	r4, #4294967295
    cb56:	e7e3      	b.n	cb20 <DRV_GMAC_Initialize+0x280>
			return SYS_MODULE_OBJ_INVALID; //return invalid than setting min dscp count
    cb58:	f04f 34ff 	mov.w	r4, #4294967295
    cb5c:	e7e0      	b.n	cb20 <DRV_GMAC_Initialize+0x280>
			return SYS_MODULE_OBJ_INVALID; //return invalid than setting min Rx buffer size
    cb5e:	f04f 34ff 	mov.w	r4, #4294967295
    cb62:	e7dd      	b.n	cb20 <DRV_GMAC_Initialize+0x280>
        return SYS_MODULE_OBJ_INVALID;     // failed to create synch lock
    cb64:	f04f 34ff 	mov.w	r4, #4294967295
    cb68:	e7da      	b.n	cb20 <DRV_GMAC_Initialize+0x280>
        return SYS_MODULE_OBJ_INVALID; //return invalid
    cb6a:	f04f 34ff 	mov.w	r4, #4294967295
    cb6e:	e7d7      	b.n	cb20 <DRV_GMAC_Initialize+0x280>
        DRV_PIC32CGMAC_LibSysIntStatus_Clear(pMACDrv, GMAC_ALL_QUE_MASK);
    cb70:	4d09      	ldr	r5, [pc, #36]	; (cb98 <DRV_GMAC_Initialize+0x2f8>)
    cb72:	213f      	movs	r1, #63	; 0x3f
    cb74:	4628      	mov	r0, r5
    cb76:	f015 f981 	bl	21e7c <DRV_PIC32CGMAC_LibSysIntStatus_Clear>
        DRV_PIC32CGMAC_LibSysInt_Enable(pMACDrv, GMAC_ALL_QUE_MASK);
    cb7a:	213f      	movs	r1, #63	; 0x3f
    cb7c:	4628      	mov	r0, r5
    cb7e:	f015 f991 	bl	21ea4 <DRV_PIC32CGMAC_LibSysInt_Enable>
		DRV_PIC32CGMAC_LibTransferEnable(pMACDrv); //enable Transmit and Receive of GMAC
    cb82:	4628      	mov	r0, r5
    cb84:	f015 ffec 	bl	22b60 <DRV_PIC32CGMAC_LibTransferEnable>
        if(DRV_GMAC_EventInit((DRV_HANDLE)pMACDrv, macControl->eventF, macControl->eventParam) != TCPIP_MAC_RES_OK)
    cb88:	462c      	mov	r4, r5
	if(_hEventMac == hMac)
    cb8a:	4b06      	ldr	r3, [pc, #24]	; (cba4 <DRV_GMAC_Initialize+0x304>)
    cb8c:	681b      	ldr	r3, [r3, #0]
    cb8e:	42ab      	cmp	r3, r5
    cb90:	d0ca      	beq.n	cb28 <DRV_GMAC_Initialize+0x288>
                initRes = TCPIP_MAC_RES_INIT_FAIL;
    cb92:	f06f 0602 	mvn.w	r6, #2
    cb96:	e796      	b.n	cac6 <DRV_GMAC_Initialize+0x226>
    cb98:	2000e288 	.word	0x2000e288
    cb9c:	2000e2e8 	.word	0x2000e2e8
    cba0:	42000800 	.word	0x42000800
    cba4:	2000e6e4 	.word	0x2000e6e4

Disassembly of section .text.TCPIP_DHCPS_Initialize%241:

0000cba8 <TCPIP_DHCPS_Initialize>:
{    
    cba8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cbac:	b087      	sub	sp, #28
    cbae:	4680      	mov	r8, r0
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_UP)
    cbb0:	7f03      	ldrb	r3, [r0, #28]
    cbb2:	2b03      	cmp	r3, #3
    cbb4:	d01a      	beq.n	cbec <TCPIP_DHCPS_Initialize+0x44>
    cbb6:	460c      	mov	r4, r1
    if(dhcpSInitCount == 0)
    cbb8:	4bab      	ldr	r3, [pc, #684]	; (ce68 <TCPIP_DHCPS_Initialize+0x2c0>)
    cbba:	681d      	ldr	r5, [r3, #0]
    cbbc:	2d00      	cmp	r5, #0
    cbbe:	f040 80cd 	bne.w	cd5c <TCPIP_DHCPS_Initialize+0x1b4>
        if(pDhcpsConfig == 0)
    cbc2:	2900      	cmp	r1, #0
    cbc4:	f000 80ec 	beq.w	cda0 <TCPIP_DHCPS_Initialize+0x1f8>
        dhcpSMemH = stackCtrl->memH;
    cbc8:	68c2      	ldr	r2, [r0, #12]
    cbca:	4ba8      	ldr	r3, [pc, #672]	; (ce6c <TCPIP_DHCPS_Initialize+0x2c4>)
    cbcc:	601a      	str	r2, [r3, #0]
        dhcpServPoolAddressValidation(pDhcpsConfig,stackCtrl->nIfs,&poolCnt);
    cbce:	6802      	ldr	r2, [r0, #0]
    for(ix=0;ix<pDhcpsConfig->dhcpServerCnt;ix++)
    cbd0:	684b      	ldr	r3, [r1, #4]
    cbd2:	2b00      	cmp	r3, #0
    cbd4:	f000 80e8 	beq.w	cda8 <TCPIP_DHCPS_Initialize+0x200>
        if(pDhcpsConfig->dhcpServer == NULL) 
    cbd8:	690b      	ldr	r3, [r1, #16]
    cbda:	2b00      	cmp	r3, #0
    cbdc:	f000 80e4 	beq.w	cda8 <TCPIP_DHCPS_Initialize+0x200>
    for(ix=0;ix<pDhcpsConfig->dhcpServerCnt;ix++)
    cbe0:	462f      	mov	r7, r5
    int tempPoolCnt=0;    
    cbe2:	9500      	str	r5, [sp, #0]
    cbe4:	46ab      	mov	fp, r5
    cbe6:	9001      	str	r0, [sp, #4]
    cbe8:	4690      	mov	r8, r2
    cbea:	e015      	b.n	cc18 <TCPIP_DHCPS_Initialize+0x70>
        if(stackCtrl->pNetIf->Flags.bIsDHCPSrvEnabled != 0)
    cbec:	6940      	ldr	r0, [r0, #20]
    cbee:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
    cbf2:	f013 0f04 	tst.w	r3, #4
    cbf6:	d105      	bne.n	cc04 <TCPIP_DHCPS_Initialize+0x5c>
        dhcpSMemH = stackCtrl->memH;
    cbf8:	f8d8 200c 	ldr.w	r2, [r8, #12]
    cbfc:	4b9b      	ldr	r3, [pc, #620]	; (ce6c <TCPIP_DHCPS_Initialize+0x2c4>)
    cbfe:	601a      	str	r2, [r3, #0]
        return true;
    cc00:	2001      	movs	r0, #1
    cc02:	e0b7      	b.n	cd74 <TCPIP_DHCPS_Initialize+0x1cc>
            TCPIP_DHCPS_Enable(stackCtrl->pNetIf);
    cc04:	f017 fbba 	bl	2437c <TCPIP_DHCPS_Enable>
    cc08:	e7f6      	b.n	cbf8 <TCPIP_DHCPS_Initialize+0x50>
    for(ix=0;ix<pDhcpsConfig->dhcpServerCnt;ix++)
    cc0a:	3701      	adds	r7, #1
    cc0c:	6863      	ldr	r3, [r4, #4]
    cc0e:	42bb      	cmp	r3, r7
    cc10:	d94d      	bls.n	ccae <TCPIP_DHCPS_Initialize+0x106>
        if(pDhcpsConfig->dhcpServer == NULL) 
    cc12:	6923      	ldr	r3, [r4, #16]
    cc14:	2b00      	cmp	r3, #0
    cc16:	d04a      	beq.n	ccae <TCPIP_DHCPS_Initialize+0x106>
        pServer = pDhcpsConfig->dhcpServer+ix;
    cc18:	017e      	lsls	r6, r7, #5
        if(pServer == NULL)
    cc1a:	199b      	adds	r3, r3, r6
    cc1c:	d0f5      	beq.n	cc0a <TCPIP_DHCPS_Initialize+0x62>
        pDhcpsConfig->dhcpServer[ix].poolEnabled = false;
    cc1e:	f04f 0200 	mov.w	r2, #0
    cc22:	771a      	strb	r2, [r3, #28]
        if(pDhcpsConfig->dhcpServer[ix].interfaceIndex >= nIfx)
    cc24:	6922      	ldr	r2, [r4, #16]
    cc26:	1993      	adds	r3, r2, r6
    cc28:	5992      	ldr	r2, [r2, r6]
    cc2a:	4590      	cmp	r8, r2
    cc2c:	dded      	ble.n	cc0a <TCPIP_DHCPS_Initialize+0x62>
        if((pDhcpsConfig->dhcpServer[ix].serverIPAddress == NULL)||
    cc2e:	689d      	ldr	r5, [r3, #8]
    cc30:	2d00      	cmp	r5, #0
    cc32:	d0ea      	beq.n	cc0a <TCPIP_DHCPS_Initialize+0x62>
            (pDhcpsConfig->dhcpServer[ix].startIPAddRange == NULL) ||
    cc34:	f8d3 900c 	ldr.w	r9, [r3, #12]
        if((pDhcpsConfig->dhcpServer[ix].serverIPAddress == NULL)||
    cc38:	f1b9 0f00 	cmp.w	r9, #0
    cc3c:	d0e5      	beq.n	cc0a <TCPIP_DHCPS_Initialize+0x62>
              (pDhcpsConfig->dhcpServer[ix].ipMaskAddress == NULL) )
    cc3e:	f8d3 a010 	ldr.w	sl, [r3, #16]
            (pDhcpsConfig->dhcpServer[ix].startIPAddRange == NULL) ||
    cc42:	f1ba 0f00 	cmp.w	sl, #0
    cc46:	d0e0      	beq.n	cc0a <TCPIP_DHCPS_Initialize+0x62>
        if((strcmp(pDhcpsConfig->dhcpServer[ix].serverIPAddress,tempStr)==0)||
    cc48:	4989      	ldr	r1, [pc, #548]	; (ce70 <TCPIP_DHCPS_Initialize+0x2c8>)
    cc4a:	4628      	mov	r0, r5
    cc4c:	f016 ffd6 	bl	23bfc <strcmp>
    cc50:	2800      	cmp	r0, #0
    cc52:	d0da      	beq.n	cc0a <TCPIP_DHCPS_Initialize+0x62>
           (strcmp(pDhcpsConfig->dhcpServer[ix].startIPAddRange,tempStr)==0) ||
    cc54:	4986      	ldr	r1, [pc, #536]	; (ce70 <TCPIP_DHCPS_Initialize+0x2c8>)
    cc56:	4648      	mov	r0, r9
    cc58:	f016 ffd0 	bl	23bfc <strcmp>
        if((strcmp(pDhcpsConfig->dhcpServer[ix].serverIPAddress,tempStr)==0)||
    cc5c:	2800      	cmp	r0, #0
    cc5e:	d0d4      	beq.n	cc0a <TCPIP_DHCPS_Initialize+0x62>
           (strcmp(pDhcpsConfig->dhcpServer[ix].ipMaskAddress,tempStr)==0))
    cc60:	4983      	ldr	r1, [pc, #524]	; (ce70 <TCPIP_DHCPS_Initialize+0x2c8>)
    cc62:	4650      	mov	r0, sl
    cc64:	f016 ffca 	bl	23bfc <strcmp>
           (strcmp(pDhcpsConfig->dhcpServer[ix].startIPAddRange,tempStr)==0) ||
    cc68:	2800      	cmp	r0, #0
    cc6a:	d0ce      	beq.n	cc0a <TCPIP_DHCPS_Initialize+0x62>
        TCPIP_Helper_StringToIPAddress((char*)pDhcpsConfig->dhcpServer[ix].serverIPAddress,&serverIPAddress);
    cc6c:	a903      	add	r1, sp, #12
    cc6e:	4628      	mov	r0, r5
    cc70:	f007 fefe 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
        TCPIP_Helper_StringToIPAddress((char*)pDhcpsConfig->dhcpServer[ix].startIPAddRange,&startIPv4PoolAddress);
    cc74:	6923      	ldr	r3, [r4, #16]
    cc76:	4433      	add	r3, r6
    cc78:	a904      	add	r1, sp, #16
    cc7a:	68d8      	ldr	r0, [r3, #12]
    cc7c:	f007 fef8 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
        TCPIP_Helper_StringToIPAddress((char*)pDhcpsConfig->dhcpServer[ix].ipMaskAddress,&netMask);        
    cc80:	6923      	ldr	r3, [r4, #16]
    cc82:	4433      	add	r3, r6
    cc84:	a905      	add	r1, sp, #20
    cc86:	6918      	ldr	r0, [r3, #16]
    cc88:	f007 fef2 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
        if((serverIPAddress.Val & netMask.Val) != (startIPv4PoolAddress.Val & netMask.Val))
    cc8c:	9a03      	ldr	r2, [sp, #12]
    cc8e:	9b04      	ldr	r3, [sp, #16]
    cc90:	ea82 0003 	eor.w	r0, r2, r3
    cc94:	9905      	ldr	r1, [sp, #20]
    cc96:	4208      	tst	r0, r1
    cc98:	d1b7      	bne.n	cc0a <TCPIP_DHCPS_Initialize+0x62>
        if(startIPv4PoolAddress.Val>serverIPAddress.Val)
    cc9a:	429a      	cmp	r2, r3
    cc9c:	d2b5      	bcs.n	cc0a <TCPIP_DHCPS_Initialize+0x62>
            tempPoolCnt++;
    cc9e:	9b00      	ldr	r3, [sp, #0]
    cca0:	3301      	adds	r3, #1
    cca2:	9300      	str	r3, [sp, #0]
            pDhcpsConfig->dhcpServer[ix].poolEnabled = true;
    cca4:	6923      	ldr	r3, [r4, #16]
    cca6:	441e      	add	r6, r3
    cca8:	2301      	movs	r3, #1
    ccaa:	7733      	strb	r3, [r6, #28]
    ccac:	e7ad      	b.n	cc0a <TCPIP_DHCPS_Initialize+0x62>
    ccae:	465d      	mov	r5, fp
    ccb0:	f8dd 8004 	ldr.w	r8, [sp, #4]
    if(tempPoolCnt==0)  
    ccb4:	9b00      	ldr	r3, [sp, #0]
    ccb6:	2b00      	cmp	r3, #0
    ccb8:	d076      	beq.n	cda8 <TCPIP_DHCPS_Initialize+0x200>
        if(poolCnt > 0)
    ccba:	2b00      	cmp	r3, #0
    ccbc:	dc76      	bgt.n	cdac <TCPIP_DHCPS_Initialize+0x204>
            SYS_ERROR(SYS_ERROR_WARNING, "DHCPS: Initialization failed! \r\n");
    ccbe:	f017 fadf 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    ccc2:	2801      	cmp	r0, #1
    ccc4:	d801      	bhi.n	ccca <TCPIP_DHCPS_Initialize+0x122>
            return false;
    ccc6:	2000      	movs	r0, #0
    ccc8:	e054      	b.n	cd74 <TCPIP_DHCPS_Initialize+0x1cc>
            SYS_ERROR(SYS_ERROR_WARNING, "DHCPS: Initialization failed! \r\n");
    ccca:	f017 fad3 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    ccce:	4969      	ldr	r1, [pc, #420]	; (ce74 <TCPIP_DHCPS_Initialize+0x2cc>)
    ccd0:	f00f fce4 	bl	1c69c <SYS_CONSOLE_Print>
            return false;
    ccd4:	2000      	movs	r0, #0
    ccd6:	e04d      	b.n	cd74 <TCPIP_DHCPS_Initialize+0x1cc>
            TCPIP_HEAP_Free(dhcpSMemH,gPdhcpSDcpt);
    ccd8:	4b64      	ldr	r3, [pc, #400]	; (ce6c <TCPIP_DHCPS_Initialize+0x2c4>)
    ccda:	6818      	ldr	r0, [r3, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
    ccdc:	68c3      	ldr	r3, [r0, #12]
    ccde:	4a66      	ldr	r2, [pc, #408]	; (ce78 <TCPIP_DHCPS_Initialize+0x2d0>)
    cce0:	6811      	ldr	r1, [r2, #0]
    cce2:	4798      	blx	r3
            return false;
    cce4:	2000      	movs	r0, #0
    cce6:	e045      	b.n	cd74 <TCPIP_DHCPS_Initialize+0x1cc>
            _DHCPSRemoveCacheEntries(&gPdhcpsHashDcpt);
    cce8:	4648      	mov	r0, r9
    ccea:	f017 f933 	bl	23f54 <_DHCPSRemoveCacheEntries>
    ccee:	e095      	b.n	ce1c <TCPIP_DHCPS_Initialize+0x274>
            _DHCPServerCleanup();
    ccf0:	f011 fbc4 	bl	1e47c <_DHCPServerCleanup>
            return false;
    ccf4:	2000      	movs	r0, #0
    ccf6:	e03d      	b.n	cd74 <TCPIP_DHCPS_Initialize+0x1cc>
    for(ix=0;ix<poolCount;ix++)
    ccf8:	3501      	adds	r5, #1
    ccfa:	45aa      	cmp	sl, r5
    ccfc:	dd2d      	ble.n	cd5a <TCPIP_DHCPS_Initialize+0x1b2>
        if(pDhcpsConfig->dhcpServer == NULL)
    ccfe:	6926      	ldr	r6, [r4, #16]
    cd00:	b35e      	cbz	r6, cd5a <TCPIP_DHCPS_Initialize+0x1b2>
        if(pPoolServer == NULL)
    cd02:	eb16 1645 	adds.w	r6, r6, r5, lsl #5
    cd06:	d0f7      	beq.n	ccf8 <TCPIP_DHCPS_Initialize+0x150>
        if(pPoolServer->poolEnabled == false)
    cd08:	7f33      	ldrb	r3, [r6, #28]
    cd0a:	2b00      	cmp	r3, #0
    cd0c:	d0f4      	beq.n	ccf8 <TCPIP_DHCPS_Initialize+0x150>
        pServerDcpt = gPdhcpSDcpt+ix;
    cd0e:	ebc5 0bc5 	rsb	fp, r5, r5, lsl #3
    cd12:	f8d9 3000 	ldr.w	r3, [r9]
        if(pServerDcpt == NULL)
    cd16:	eb13 0b8b 	adds.w	fp, r3, fp, lsl #2
    cd1a:	d0ed      	beq.n	ccf8 <TCPIP_DHCPS_Initialize+0x150>
        TCPIP_Helper_StringToIPAddress((char*)pPoolServer->serverIPAddress,&pServerDcpt->intfAddrsConf.serverIPAddress);
    cd1c:	4659      	mov	r1, fp
    cd1e:	68b0      	ldr	r0, [r6, #8]
    cd20:	f007 fea6 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
        TCPIP_Helper_StringToIPAddress((char*)pPoolServer->ipMaskAddress,&pServerDcpt->intfAddrsConf.serverMask);
    cd24:	f10b 0104 	add.w	r1, fp, #4
    cd28:	6930      	ldr	r0, [r6, #16]
    cd2a:	f007 fea1 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
        TCPIP_Helper_StringToIPAddress((char*)pPoolServer->startIPAddRange,&pServerDcpt->intfAddrsConf.startIPAddress);
    cd2e:	f10b 0108 	add.w	r1, fp, #8
    cd32:	68f0      	ldr	r0, [r6, #12]
    cd34:	f007 fe9c 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
        TCPIP_Helper_StringToIPAddress((char*)pPoolServer->priDNS,&pServerDcpt->intfAddrsConf.serverDNS);
    cd38:	f10b 010c 	add.w	r1, fp, #12
    cd3c:	6970      	ldr	r0, [r6, #20]
    cd3e:	f007 fe97 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
        TCPIP_Helper_StringToIPAddress((char*)pPoolServer->secondDNS,&pServerDcpt->intfAddrsConf.serverDNS2);
    cd42:	f10b 0110 	add.w	r1, fp, #16
    cd46:	69b0      	ldr	r0, [r6, #24]
    cd48:	f007 fe92 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
        pServerDcpt->intfAddrsConf.poolIndex = localPoolIndex;
    cd4c:	f8cb 7014 	str.w	r7, [fp, #20]
        pServerDcpt->netIx = pPoolServer->interfaceIndex;
    cd50:	6833      	ldr	r3, [r6, #0]
    cd52:	f8cb 3018 	str.w	r3, [fp, #24]
        localPoolIndex++;
    cd56:	3701      	adds	r7, #1
    cd58:	e7ce      	b.n	ccf8 <TCPIP_DHCPS_Initialize+0x150>
    if(localPoolIndex == 0)
    cd5a:	b177      	cbz	r7, cd7a <TCPIP_DHCPS_Initialize+0x1d2>
    if(stackCtrl->pNetIf->Flags.bIsDHCPSrvEnabled != 0)
    cd5c:	f8d8 0014 	ldr.w	r0, [r8, #20]
    cd60:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
    cd64:	f013 0f04 	tst.w	r3, #4
    cd68:	d116      	bne.n	cd98 <TCPIP_DHCPS_Initialize+0x1f0>
    dhcpSInitCount++;
    cd6a:	4a3f      	ldr	r2, [pc, #252]	; (ce68 <TCPIP_DHCPS_Initialize+0x2c0>)
    cd6c:	6813      	ldr	r3, [r2, #0]
    cd6e:	3301      	adds	r3, #1
    cd70:	6013      	str	r3, [r2, #0]
    return true;
    cd72:	2001      	movs	r0, #1
}
    cd74:	b007      	add	sp, #28
    cd76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        pServerDcpt = gPdhcpSDcpt+localPoolIndex;
    cd7a:	4b3f      	ldr	r3, [pc, #252]	; (ce78 <TCPIP_DHCPS_Initialize+0x2d0>)
    cd7c:	681c      	ldr	r4, [r3, #0]
        memset(&pServerDcpt->intfAddrsConf,0,sizeof(pServerDcpt->intfAddrsConf));
    cd7e:	2300      	movs	r3, #0
    cd80:	6023      	str	r3, [r4, #0]
    cd82:	6063      	str	r3, [r4, #4]
    cd84:	60a3      	str	r3, [r4, #8]
    cd86:	60e3      	str	r3, [r4, #12]
    cd88:	6123      	str	r3, [r4, #16]
    cd8a:	6163      	str	r3, [r4, #20]
        pServerDcpt->netIx = TCPIP_STACK_NetIndexGet(TCPIP_STACK_NetDefaultGet());
    cd8c:	f017 fa4e 	bl	2422c <TCPIP_STACK_NetDefaultGet>
    cd90:	f017 f8cb 	bl	23f2a <TCPIP_STACK_NetIndexGet>
    cd94:	61a0      	str	r0, [r4, #24]
    cd96:	e7e1      	b.n	cd5c <TCPIP_DHCPS_Initialize+0x1b4>
        _DHCPS_Enable(stackCtrl->pNetIf,false);
    cd98:	2100      	movs	r1, #0
    cd9a:	f00c f845 	bl	18e28 <_DHCPS_Enable>
    cd9e:	e7e4      	b.n	cd6a <TCPIP_DHCPS_Initialize+0x1c2>
            return false;
    cda0:	2000      	movs	r0, #0
    cda2:	e7e7      	b.n	cd74 <TCPIP_DHCPS_Initialize+0x1cc>
                return false;
    cda4:	2000      	movs	r0, #0
    cda6:	e7e5      	b.n	cd74 <TCPIP_DHCPS_Initialize+0x1cc>
        if(poolCnt > 0)
    cda8:	2301      	movs	r3, #1
    cdaa:	9300      	str	r3, [sp, #0]
            gPdhcpSDcpt = (DHCP_SRVR_DCPT*)TCPIP_HEAP_Calloc(dhcpSMemH, poolCnt, sizeof(DHCP_SRVR_DCPT));
    cdac:	4b2f      	ldr	r3, [pc, #188]	; (ce6c <TCPIP_DHCPS_Initialize+0x2c4>)
    cdae:	6818      	ldr	r0, [r3, #0]
    cdb0:	9900      	ldr	r1, [sp, #0]
    cdb2:	460f      	mov	r7, r1
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Calloc)(h, nElems, elemSize);
    cdb4:	6883      	ldr	r3, [r0, #8]
    cdb6:	221c      	movs	r2, #28
    cdb8:	4798      	blx	r3
    cdba:	4b2f      	ldr	r3, [pc, #188]	; (ce78 <TCPIP_DHCPS_Initialize+0x2d0>)
    cdbc:	6018      	str	r0, [r3, #0]
            if(gPdhcpSDcpt == 0)
    cdbe:	2800      	cmp	r0, #0
    cdc0:	d0f0      	beq.n	cda4 <TCPIP_DHCPS_Initialize+0x1fc>
        hashDcpt = (OA_HASH_DCPT*)TCPIP_HEAP_Malloc(dhcpSMemH, hashMemSize);
    cdc2:	4b2a      	ldr	r3, [pc, #168]	; (ce6c <TCPIP_DHCPS_Initialize+0x2c4>)
    cdc4:	6818      	ldr	r0, [r3, #0]
        hashMemSize = sizeof(OA_HASH_DCPT) + pDhcpsConfig->leaseEntries * sizeof(DHCPS_HASH_ENTRY);
    cdc6:	68a1      	ldr	r1, [r4, #8]
    cdc8:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
    cdcc:	0089      	lsls	r1, r1, #2
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
    cdce:	6843      	ldr	r3, [r0, #4]
    cdd0:	3128      	adds	r1, #40	; 0x28
    cdd2:	4798      	blx	r3
        if(hashDcpt == 0)
    cdd4:	4606      	mov	r6, r0
    cdd6:	2800      	cmp	r0, #0
    cdd8:	f43f af7e 	beq.w	ccd8 <TCPIP_DHCPS_Initialize+0x130>
        hashDcpt->memBlk = hashDcpt+1;
    cddc:	f100 0328 	add.w	r3, r0, #40	; 0x28
    cde0:	6003      	str	r3, [r0, #0]
        hashDcpt->hParam = &gPdhcpsHashDcpt;
    cde2:	f8df 90b4 	ldr.w	r9, [pc, #180]	; ce98 <TCPIP_DHCPS_Initialize+0x2f0>
    cde6:	f8c0 9004 	str.w	r9, [r0, #4]
        hashDcpt->hEntrySize = sizeof(DHCPS_HASH_ENTRY);
    cdea:	231c      	movs	r3, #28
    cdec:	6083      	str	r3, [r0, #8]
        hashDcpt->hEntries = pDhcpsConfig->leaseEntries;
    cdee:	68a3      	ldr	r3, [r4, #8]
    cdf0:	60c3      	str	r3, [r0, #12]
        hashDcpt->probeStep = DHCPS_HASH_PROBE_STEP;
    cdf2:	2301      	movs	r3, #1
    cdf4:	6103      	str	r3, [r0, #16]
        hashDcpt->hashF= TCPIP_DHCPS_MACHashKeyHash;
    cdf6:	4b21      	ldr	r3, [pc, #132]	; (ce7c <TCPIP_DHCPS_Initialize+0x2d4>)
    cdf8:	6143      	str	r3, [r0, #20]
        hashDcpt->cpyF = TCPIP_DHCPS_HashMACKeyCopy;
    cdfa:	4b21      	ldr	r3, [pc, #132]	; (ce80 <TCPIP_DHCPS_Initialize+0x2d8>)
    cdfc:	6203      	str	r3, [r0, #32]
        hashDcpt->delF = TCPIP_DHCPS_HashDeleteEntry;
    cdfe:	4b21      	ldr	r3, [pc, #132]	; (ce84 <TCPIP_DHCPS_Initialize+0x2dc>)
    ce00:	6183      	str	r3, [r0, #24]
        hashDcpt->cmpF = TCPIP_DHCPS_HashMACKeyCompare;
    ce02:	4b21      	ldr	r3, [pc, #132]	; (ce88 <TCPIP_DHCPS_Initialize+0x2e0>)
    ce04:	61c3      	str	r3, [r0, #28]
        TCPIP_OAHASH_Initialize(hashDcpt);
    ce06:	f015 fb1a 	bl	2243e <TCPIP_OAHASH_Initialize>
        gPdhcpsHashDcpt.hashDcpt = hashDcpt;
    ce0a:	f8c9 6000 	str.w	r6, [r9]
        gPdhcpsHashDcpt.leaseDuartion = pDhcpsConfig->entrySolvedTmo;
    ce0e:	68e3      	ldr	r3, [r4, #12]
    ce10:	f8c9 3004 	str.w	r3, [r9, #4]
        if(pDhcpsConfig->deleteOldLease)
    ce14:	7863      	ldrb	r3, [r4, #1]
    ce16:	2b00      	cmp	r3, #0
    ce18:	f47f af66 	bne.w	cce8 <TCPIP_DHCPS_Initialize+0x140>
        dhcps_mod.signalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_DHCPS_Task, TCPIP_DHCPS_TASK_PROCESS_RATE);
    ce1c:	22c8      	movs	r2, #200	; 0xc8
    ce1e:	491b      	ldr	r1, [pc, #108]	; (ce8c <TCPIP_DHCPS_Initialize+0x2e4>)
    ce20:	200d      	movs	r0, #13
    ce22:	f011 ffbd 	bl	1eda0 <_TCPIPStackSignalHandlerRegister>
    ce26:	4b1a      	ldr	r3, [pc, #104]	; (ce90 <TCPIP_DHCPS_Initialize+0x2e8>)
    ce28:	60d8      	str	r0, [r3, #12]
        if(dhcps_mod.signalHandle == 0)
    ce2a:	2800      	cmp	r0, #0
    ce2c:	f43f af60 	beq.w	ccf0 <TCPIP_DHCPS_Initialize+0x148>
        dhcps_mod.smServer = DHCP_SERVER_IDLE;
    ce30:	4b17      	ldr	r3, [pc, #92]	; (ce90 <TCPIP_DHCPS_Initialize+0x2e8>)
    ce32:	2202      	movs	r2, #2
    ce34:	709a      	strb	r2, [r3, #2]
        dhcps_mod.uSkt = INVALID_UDP_SOCKET;
    ce36:	f64f 72ff 	movw	r2, #65535	; 0xffff
    ce3a:	801a      	strh	r2, [r3, #0]
        dhcps_mod.poolCount = poolCnt;
    ce3c:	605f      	str	r7, [r3, #4]
        dhcps_mod.dhcpNextLease.Val = 0;
    ce3e:	2100      	movs	r1, #0
    ce40:	6099      	str	r1, [r3, #8]
        dhcps_mod.smState = TCPIP_DHCPS_STATE_IDLE;
    ce42:	70d9      	strb	r1, [r3, #3]
        memset(&gBOOTPHeader,0,sizeof(gBOOTPHeader));
    ce44:	2222      	movs	r2, #34	; 0x22
    ce46:	4813      	ldr	r0, [pc, #76]	; (ce94 <TCPIP_DHCPS_Initialize+0x2ec>)
    ce48:	f017 f82a 	bl	23ea0 <memset>
    if(gPdhcpSDcpt == NULL)
    ce4c:	4b0a      	ldr	r3, [pc, #40]	; (ce78 <TCPIP_DHCPS_Initialize+0x2d0>)
    ce4e:	681b      	ldr	r3, [r3, #0]
    ce50:	2b00      	cmp	r3, #0
    ce52:	d083      	beq.n	cd5c <TCPIP_DHCPS_Initialize+0x1b4>
        if(pDhcpsConfig->dhcpServer == NULL)
    ce54:	6926      	ldr	r6, [r4, #16]
    ce56:	2e00      	cmp	r6, #0
    ce58:	d08f      	beq.n	cd7a <TCPIP_DHCPS_Initialize+0x1d2>
    int ix=0,localPoolIndex=0;
    ce5a:	462f      	mov	r7, r5
        pServerDcpt = gPdhcpSDcpt+ix;
    ce5c:	f8df 9018 	ldr.w	r9, [pc, #24]	; ce78 <TCPIP_DHCPS_Initialize+0x2d0>
    ce60:	f8dd a000 	ldr.w	sl, [sp]
    ce64:	e74d      	b.n	cd02 <TCPIP_DHCPS_Initialize+0x15a>
    ce66:	bf00      	nop
    ce68:	2000eea0 	.word	0x2000eea0
    ce6c:	2000eea4 	.word	0x2000eea4
    ce70:	0000d2a4 	.word	0x0000d2a4
    ce74:	0000d2ac 	.word	0x0000d2ac
    ce78:	2000eec8 	.word	0x2000eec8
    ce7c:	0002375d 	.word	0x0002375d
    ce80:	00024373 	.word	0x00024373
    ce84:	0001e159 	.word	0x0001e159
    ce88:	00023c6d 	.word	0x00023c6d
    ce8c:	0000bee9 	.word	0x0000bee9
    ce90:	2000ed3c 	.word	0x2000ed3c
    ce94:	2000eac0 	.word	0x2000eac0
    ce98:	2000ed7c 	.word	0x2000ed7c

Disassembly of section .text.TCPIP_TCP_FifoSizeAdjust%242:

0000ce9c <TCPIP_TCP_FifoSizeAdjust>:
{
    ce9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cea0:	b085      	sub	sp, #20
    if((vFlags & (TCP_ADJUST_TX_ONLY | TCP_ADJUST_RX_ONLY)) == (TCP_ADJUST_TX_ONLY | TCP_ADJUST_RX_ONLY))
    cea2:	f003 0430 	and.w	r4, r3, #48	; 0x30
    cea6:	2c30      	cmp	r4, #48	; 0x30
    cea8:	f000 80d2 	beq.w	d050 <TCPIP_TCP_FifoSizeAdjust+0x1b4>
    ceac:	461f      	mov	r7, r3
    ceae:	4615      	mov	r5, r2
    ceb0:	460e      	mov	r6, r1
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
    ceb2:	f015 f833 	bl	21f1c <_TcpSocketChk>
    if(pSkt == 0)
    ceb6:	4604      	mov	r4, r0
    ceb8:	2800      	cmp	r0, #0
    ceba:	f000 80cb 	beq.w	d054 <TCPIP_TCP_FifoSizeAdjust+0x1b8>
    if(wMinTXSize < TCP_MIN_TX_BUFF_SIZE)
    cebe:	2d19      	cmp	r5, #25
    cec0:	bf38      	it	cc
    cec2:	2519      	movcc	r5, #25
    oldTxSize = pSkt->txEnd - pSkt->txStart -1;
    cec4:	6843      	ldr	r3, [r0, #4]
    cec6:	6802      	ldr	r2, [r0, #0]
    cec8:	1a9b      	subs	r3, r3, r2
    ceca:	3b01      	subs	r3, #1
    cecc:	b29b      	uxth	r3, r3
    oldRxSize = pSkt->rxEnd - pSkt->rxStart;
    cece:	6982      	ldr	r2, [r0, #24]
    ced0:	6941      	ldr	r1, [r0, #20]
    ced2:	1a52      	subs	r2, r2, r1
    ced4:	fa1f f982 	uxth.w	r9, r2
    if((vFlags & TCP_ADJUST_TX_ONLY) != 0)
    ced8:	f017 0f10 	tst.w	r7, #16
    cedc:	d121      	bne.n	cf22 <TCPIP_TCP_FifoSizeAdjust+0x86>
    cede:	2e19      	cmp	r6, #25
    cee0:	bf38      	it	cc
    cee2:	2619      	movcc	r6, #25
    else if((vFlags & TCP_ADJUST_RX_ONLY) != 0)
    cee4:	f017 0f20 	tst.w	r7, #32
    cee8:	d121      	bne.n	cf2e <TCPIP_TCP_FifoSizeAdjust+0x92>
    else if(oldTxSize + oldRxSize > wMinRXSize + wMinTXSize)
    ceea:	fa13 f282 	uxtah	r2, r3, r2
    ceee:	1971      	adds	r1, r6, r5
    cef0:	428a      	cmp	r2, r1
    cef2:	dd17      	ble.n	cf24 <TCPIP_TCP_FifoSizeAdjust+0x88>
        uint16_t leftSpace = (oldTxSize + oldRxSize) - (wMinRXSize + wMinTXSize);
    cef4:	eba9 0201 	sub.w	r2, r9, r1
    cef8:	441a      	add	r2, r3
    cefa:	b292      	uxth	r2, r2
        if((vFlags & equalMask) == 0 || (vFlags & equalMask) == equalMask)
    cefc:	f017 0103 	ands.w	r1, r7, #3
    cf00:	d008      	beq.n	cf14 <TCPIP_TCP_FifoSizeAdjust+0x78>
    cf02:	2903      	cmp	r1, #3
    cf04:	d006      	beq.n	cf14 <TCPIP_TCP_FifoSizeAdjust+0x78>
        else if((vFlags & equalMask) == TCP_ADJUST_GIVE_REST_TO_TX)
    cf06:	2902      	cmp	r1, #2
            wMinTXSize += leftSpace;
    cf08:	bf07      	ittee	eq
    cf0a:	18ad      	addeq	r5, r5, r2
    cf0c:	b2ad      	uxtheq	r5, r5
            wMinRXSize += leftSpace;
    cf0e:	18b6      	addne	r6, r6, r2
    cf10:	b2b6      	uxthne	r6, r6
    cf12:	e007      	b.n	cf24 <TCPIP_TCP_FifoSizeAdjust+0x88>
            wMinRXSize += (leftSpace + 1) >> 1;
    cf14:	3201      	adds	r2, #1
    cf16:	0852      	lsrs	r2, r2, #1
    cf18:	4416      	add	r6, r2
    cf1a:	b2b6      	uxth	r6, r6
            wMinTXSize += (leftSpace +1) >> 1;
    cf1c:	4415      	add	r5, r2
    cf1e:	b2ad      	uxth	r5, r5
    cf20:	e000      	b.n	cf24 <TCPIP_TCP_FifoSizeAdjust+0x88>
        wMinRXSize = oldRxSize;
    cf22:	464e      	mov	r6, r9
    if(wMinTXSize >= oldTxSize)
    cf24:	429d      	cmp	r5, r3
    cf26:	d203      	bcs.n	cf30 <TCPIP_TCP_FifoSizeAdjust+0x94>
        diffChange = oldTxSize - wMinTXSize;
    cf28:	1b5b      	subs	r3, r3, r5
    cf2a:	b29b      	uxth	r3, r3
    cf2c:	e002      	b.n	cf34 <TCPIP_TCP_FifoSizeAdjust+0x98>
        wMinTXSize = oldTxSize;
    cf2e:	461d      	mov	r5, r3
        diffChange = wMinTXSize - oldTxSize;
    cf30:	1aeb      	subs	r3, r5, r3
    cf32:	b29b      	uxth	r3, r3
    if(diffChange >= TCP_MIN_BUFF_CHANGE)
    cf34:	2b1f      	cmp	r3, #31
    cf36:	d908      	bls.n	cf4a <TCPIP_TCP_FifoSizeAdjust+0xae>
        newTxBuff = (uint8_t*)TCPIP_HEAP_Malloc(tcpHeapH, wMinTXSize + 1);
    cf38:	4b93      	ldr	r3, [pc, #588]	; (d188 <TCPIP_TCP_FifoSizeAdjust+0x2ec>)
    cf3a:	6818      	ldr	r0, [r3, #0]
    cf3c:	6843      	ldr	r3, [r0, #4]
    cf3e:	1c69      	adds	r1, r5, #1
    cf40:	4798      	blx	r3
        if(newTxBuff == 0)
    cf42:	4680      	mov	r8, r0
    cf44:	b918      	cbnz	r0, cf4e <TCPIP_TCP_FifoSizeAdjust+0xb2>
            return false;
    cf46:	2000      	movs	r0, #0
    cf48:	e0b9      	b.n	d0be <TCPIP_TCP_FifoSizeAdjust+0x222>
        newTxBuff = 0;
    cf4a:	f04f 0800 	mov.w	r8, #0
    if(wMinRXSize >= oldRxSize)
    cf4e:	45b1      	cmp	r9, r6
        diffChange = wMinRXSize - oldRxSize;
    cf50:	bf94      	ite	ls
    cf52:	eba6 0909 	subls.w	r9, r6, r9
        diffChange = oldRxSize - wMinRXSize;
    cf56:	eba9 0906 	subhi.w	r9, r9, r6
    cf5a:	fa1f f989 	uxth.w	r9, r9
    if(diffChange >= TCP_MIN_BUFF_CHANGE)
    cf5e:	f1b9 0f1f 	cmp.w	r9, #31
    cf62:	d90d      	bls.n	cf80 <TCPIP_TCP_FifoSizeAdjust+0xe4>
        newRxBuff = (uint8_t*)TCPIP_HEAP_Malloc(tcpHeapH, wMinRXSize + 1);
    cf64:	4b88      	ldr	r3, [pc, #544]	; (d188 <TCPIP_TCP_FifoSizeAdjust+0x2ec>)
    cf66:	6818      	ldr	r0, [r3, #0]
    cf68:	6843      	ldr	r3, [r0, #4]
    cf6a:	1c71      	adds	r1, r6, #1
    cf6c:	4798      	blx	r3
        if(newRxBuff == 0)
    cf6e:	4682      	mov	sl, r0
    cf70:	b940      	cbnz	r0, cf84 <TCPIP_TCP_FifoSizeAdjust+0xe8>
            TCPIP_HEAP_Free(tcpHeapH, newTxBuff);
    cf72:	4b85      	ldr	r3, [pc, #532]	; (d188 <TCPIP_TCP_FifoSizeAdjust+0x2ec>)
    cf74:	6818      	ldr	r0, [r3, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
    cf76:	68c3      	ldr	r3, [r0, #12]
    cf78:	4641      	mov	r1, r8
    cf7a:	4798      	blx	r3
            return false;
    cf7c:	2000      	movs	r0, #0
    cf7e:	e09e      	b.n	d0be <TCPIP_TCP_FifoSizeAdjust+0x222>
        newRxBuff = 0;
    cf80:	f04f 0a00 	mov.w	sl, #0
    while(newTxBuff != 0)
    cf84:	f1b8 0f00 	cmp.w	r8, #0
    cf88:	f000 80aa 	beq.w	d0e0 <TCPIP_TCP_FifoSizeAdjust+0x244>
        if((vFlags & TCP_ADJUST_PRESERVE_TX) != 0)
    cf8c:	f017 0f08 	tst.w	r7, #8
    cf90:	f000 80b7 	beq.w	d102 <TCPIP_TCP_FifoSizeAdjust+0x266>
            txHead = pSkt->txHead;
    cf94:	68a3      	ldr	r3, [r4, #8]
            if(txHead < pSkt->txTail)
    cf96:	68e1      	ldr	r1, [r4, #12]
    cf98:	4299      	cmp	r1, r3
    cf9a:	d925      	bls.n	cfe8 <TCPIP_TCP_FifoSizeAdjust+0x14c>
                pendTxEnd = pSkt->txEnd - pSkt->txTail;
    cf9c:	6862      	ldr	r2, [r4, #4]
    cf9e:	1a52      	subs	r2, r2, r1
    cfa0:	b292      	uxth	r2, r2
    cfa2:	9201      	str	r2, [sp, #4]
                pendTxBeg = txHead - pSkt->txStart;
    cfa4:	f8d4 b000 	ldr.w	fp, [r4]
    cfa8:	eba3 090b 	sub.w	r9, r3, fp
    cfac:	fa1f f989 	uxth.w	r9, r9
            if((pendTxEnd + pendTxBeg) != 0)
    cfb0:	9a01      	ldr	r2, [sp, #4]
    cfb2:	eb12 0309 	adds.w	r3, r2, r9
    cfb6:	f000 80e1 	beq.w	d17c <TCPIP_TCP_FifoSizeAdjust+0x2e0>
                if(pendTxEnd + pendTxBeg > wMinTXSize)
    cfba:	42ab      	cmp	r3, r5
    cfbc:	f300 8085 	bgt.w	d0ca <TCPIP_TCP_FifoSizeAdjust+0x22e>
                if(pendTxEnd)
    cfc0:	b9ea      	cbnz	r2, cffe <TCPIP_TCP_FifoSizeAdjust+0x162>
                if(pendTxBeg)
    cfc2:	f1b9 0f00 	cmp.w	r9, #0
    cfc6:	d11e      	bne.n	d006 <TCPIP_TCP_FifoSizeAdjust+0x16a>
                txUnackOffs = pSkt->txUnackedTail - pSkt->txTail;
    cfc8:	6922      	ldr	r2, [r4, #16]
    cfca:	68e3      	ldr	r3, [r4, #12]
    cfcc:	eba2 0b03 	sub.w	fp, r2, r3
    cfd0:	fa1f fb8b 	uxth.w	fp, fp
                if(pSkt->txUnackedTail < pSkt->txTail)
    cfd4:	429a      	cmp	r2, r3
    cfd6:	f080 8099 	bcs.w	d10c <TCPIP_TCP_FifoSizeAdjust+0x270>
                    txUnackOffs += pSkt->txEnd - pSkt->txStart;
    cfda:	6863      	ldr	r3, [r4, #4]
    cfdc:	6822      	ldr	r2, [r4, #0]
    cfde:	1a9b      	subs	r3, r3, r2
    cfe0:	449b      	add	fp, r3
    cfe2:	fa1f fb8b 	uxth.w	fp, fp
    cfe6:	e091      	b.n	d10c <TCPIP_TCP_FifoSizeAdjust+0x270>
            else if(txHead > pSkt->txTail)
    cfe8:	4299      	cmp	r1, r3
    cfea:	f080 80c1 	bcs.w	d170 <TCPIP_TCP_FifoSizeAdjust+0x2d4>
                pendTxBeg = txHead - pSkt->txTail;
    cfee:	eba3 0901 	sub.w	r9, r3, r1
    cff2:	fa1f f989 	uxth.w	r9, r9
                srcOffs = pSkt->txTail;
    cff6:	468b      	mov	fp, r1
                pendTxEnd = 0;
    cff8:	2300      	movs	r3, #0
    cffa:	9301      	str	r3, [sp, #4]
    cffc:	e7d8      	b.n	cfb0 <TCPIP_TCP_FifoSizeAdjust+0x114>
                    memcpy(newTxBuff, pSkt->txTail, pendTxEnd);
    cffe:	4640      	mov	r0, r8
    d000:	f016 f974 	bl	232ec <memcpy>
    d004:	e7dd      	b.n	cfc2 <TCPIP_TCP_FifoSizeAdjust+0x126>
                    memcpy(newTxBuff + pendTxEnd,  srcOffs, pendTxBeg);
    d006:	464a      	mov	r2, r9
    d008:	4659      	mov	r1, fp
    d00a:	9b01      	ldr	r3, [sp, #4]
    d00c:	eb08 0003 	add.w	r0, r8, r3
    d010:	f016 f96c 	bl	232ec <memcpy>
    d014:	e7d8      	b.n	cfc8 <TCPIP_TCP_FifoSizeAdjust+0x12c>
    txUnackOffs = 0;
    d016:	f04f 0b00 	mov.w	fp, #0
    pendTxEnd = pendTxBeg = 0;
    d01a:	46d9      	mov	r9, fp
    d01c:	f8cd b004 	str.w	fp, [sp, #4]
    d020:	e077      	b.n	d112 <TCPIP_TCP_FifoSizeAdjust+0x276>
            else if(rxHead < pSkt->rxTail)
    d022:	42b9      	cmp	r1, r7
    d024:	d94e      	bls.n	d0c4 <TCPIP_TCP_FifoSizeAdjust+0x228>
                avlblRxEnd = pSkt->rxEnd + 1 - pSkt->rxTail;
    d026:	69a3      	ldr	r3, [r4, #24]
    d028:	3301      	adds	r3, #1
    d02a:	1a5b      	subs	r3, r3, r1
    d02c:	b29b      	uxth	r3, r3
    d02e:	9302      	str	r3, [sp, #8]
                avlblRxBeg = rxHead - pSkt->rxStart;
    d030:	6963      	ldr	r3, [r4, #20]
    d032:	9303      	str	r3, [sp, #12]
    d034:	1aff      	subs	r7, r7, r3
    d036:	b2bf      	uxth	r7, r7
                srcOffs = pSkt->rxStart;
    d038:	e087      	b.n	d14a <TCPIP_TCP_FifoSizeAdjust+0x2ae>
                    memcpy(newRxBuff, pSkt->rxTail, avlblRxEnd);
    d03a:	4650      	mov	r0, sl
    d03c:	f016 f956 	bl	232ec <memcpy>
    d040:	e08b      	b.n	d15a <TCPIP_TCP_FifoSizeAdjust+0x2be>
            _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
    d042:	2201      	movs	r2, #1
    d044:	2110      	movs	r1, #16
    d046:	4620      	mov	r0, r4
    d048:	f7fa ff7a 	bl	7f40 <_TcpSend>
    return true;
    d04c:	2001      	movs	r0, #1
    d04e:	e036      	b.n	d0be <TCPIP_TCP_FifoSizeAdjust+0x222>
        return false;
    d050:	2000      	movs	r0, #0
    d052:	e034      	b.n	d0be <TCPIP_TCP_FifoSizeAdjust+0x222>
        return false;
    d054:	2000      	movs	r0, #0
    d056:	e032      	b.n	d0be <TCPIP_TCP_FifoSizeAdjust+0x222>
    avlblRxEnd = avlblRxBeg = 0;
    d058:	2700      	movs	r7, #0
    d05a:	9702      	str	r7, [sp, #8]
    if(newTxBuff)
    d05c:	f1b8 0f00 	cmp.w	r8, #0
    d060:	d04a      	beq.n	d0f8 <TCPIP_TCP_FifoSizeAdjust+0x25c>
        TCPIP_HEAP_Free(tcpHeapH, (void*)pSkt->txStart);
    d062:	4b49      	ldr	r3, [pc, #292]	; (d188 <TCPIP_TCP_FifoSizeAdjust+0x2ec>)
    d064:	6818      	ldr	r0, [r3, #0]
    d066:	68c3      	ldr	r3, [r0, #12]
    d068:	6821      	ldr	r1, [r4, #0]
    d06a:	4798      	blx	r3
        pSkt->txStart =  newTxBuff;
    d06c:	f8c4 8000 	str.w	r8, [r4]
        pSkt->txEnd = newTxBuff + wMinTXSize + 1;
    d070:	3501      	adds	r5, #1
    d072:	4445      	add	r5, r8
    d074:	6065      	str	r5, [r4, #4]
        pSkt->txTail = pSkt->txStart;
    d076:	f8c4 800c 	str.w	r8, [r4, #12]
        pSkt->txHead = pSkt->txStart + (pendTxEnd + pendTxBeg);
    d07a:	9b01      	ldr	r3, [sp, #4]
    d07c:	444b      	add	r3, r9
    d07e:	4443      	add	r3, r8
    d080:	60a3      	str	r3, [r4, #8]
        pSkt->txUnackedTail = pSkt->txTail + txUnackOffs;
    d082:	eb08 030b 	add.w	r3, r8, fp
    d086:	6123      	str	r3, [r4, #16]
        _TCPSetHalfFlushFlag(pSkt);
    d088:	4620      	mov	r0, r4
    d08a:	f012 fe8b 	bl	1fda4 <_TCPSetHalfFlushFlag>
    if(newRxBuff)
    d08e:	f1ba 0f00 	cmp.w	sl, #0
    d092:	d00f      	beq.n	d0b4 <TCPIP_TCP_FifoSizeAdjust+0x218>
        TCPIP_HEAP_Free(tcpHeapH, (void*)pSkt->rxStart);
    d094:	4b3c      	ldr	r3, [pc, #240]	; (d188 <TCPIP_TCP_FifoSizeAdjust+0x2ec>)
    d096:	6818      	ldr	r0, [r3, #0]
    d098:	68c3      	ldr	r3, [r0, #12]
    d09a:	6961      	ldr	r1, [r4, #20]
    d09c:	4798      	blx	r3
        pSkt->rxStart = newRxBuff;
    d09e:	f8c4 a014 	str.w	sl, [r4, #20]
        pSkt->rxEnd = newRxBuff + wMinRXSize;
    d0a2:	4456      	add	r6, sl
    d0a4:	61a6      	str	r6, [r4, #24]
        pSkt->rxTail = pSkt->rxStart;
    d0a6:	f8c4 a020 	str.w	sl, [r4, #32]
        pSkt->rxHead = pSkt->rxStart + (avlblRxEnd + avlblRxBeg);
    d0aa:	9b02      	ldr	r3, [sp, #8]
    d0ac:	443b      	add	r3, r7
    d0ae:	461f      	mov	r7, r3
    d0b0:	4457      	add	r7, sl
    d0b2:	61e7      	str	r7, [r4, #28]
        if(pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED)
    d0b4:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
    d0b8:	2b03      	cmp	r3, #3
    d0ba:	d0c2      	beq.n	d042 <TCPIP_TCP_FifoSizeAdjust+0x1a6>
    return true;
    d0bc:	2001      	movs	r0, #1
}
    d0be:	b005      	add	sp, #20
    d0c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    avlblRxEnd = avlblRxBeg = 0;
    d0c4:	2700      	movs	r7, #0
    d0c6:	9702      	str	r7, [sp, #8]
    d0c8:	e7c8      	b.n	d05c <TCPIP_TCP_FifoSizeAdjust+0x1c0>
        TCPIP_HEAP_Free(tcpHeapH, newRxBuff);
    d0ca:	4c2f      	ldr	r4, [pc, #188]	; (d188 <TCPIP_TCP_FifoSizeAdjust+0x2ec>)
    d0cc:	6820      	ldr	r0, [r4, #0]
    d0ce:	68c3      	ldr	r3, [r0, #12]
    d0d0:	4651      	mov	r1, sl
    d0d2:	4798      	blx	r3
        TCPIP_HEAP_Free(tcpHeapH, newTxBuff);
    d0d4:	6820      	ldr	r0, [r4, #0]
    d0d6:	68c3      	ldr	r3, [r0, #12]
    d0d8:	4641      	mov	r1, r8
    d0da:	4798      	blx	r3
        return false;
    d0dc:	2000      	movs	r0, #0
    d0de:	e7ee      	b.n	d0be <TCPIP_TCP_FifoSizeAdjust+0x222>
    while(adjustFail != true && newRxBuff != 0)
    d0e0:	f1ba 0f00 	cmp.w	sl, #0
    d0e4:	d197      	bne.n	d016 <TCPIP_TCP_FifoSizeAdjust+0x17a>
    txUnackOffs = 0;
    d0e6:	f04f 0b00 	mov.w	fp, #0
    pendTxEnd = pendTxBeg = 0;
    d0ea:	46d9      	mov	r9, fp
    d0ec:	f8cd b004 	str.w	fp, [sp, #4]
    avlblRxEnd = avlblRxBeg = 0;
    d0f0:	465f      	mov	r7, fp
    d0f2:	f8cd b008 	str.w	fp, [sp, #8]
    d0f6:	e7b1      	b.n	d05c <TCPIP_TCP_FifoSizeAdjust+0x1c0>
    if(newRxBuff)
    d0f8:	f1ba 0f00 	cmp.w	sl, #0
    d0fc:	d1ca      	bne.n	d094 <TCPIP_TCP_FifoSizeAdjust+0x1f8>
    return true;
    d0fe:	2001      	movs	r0, #1
    d100:	e7dd      	b.n	d0be <TCPIP_TCP_FifoSizeAdjust+0x222>
    txUnackOffs = 0;
    d102:	f04f 0b00 	mov.w	fp, #0
    pendTxEnd = pendTxBeg = 0;
    d106:	46d9      	mov	r9, fp
    d108:	f8cd b004 	str.w	fp, [sp, #4]
    while(adjustFail != true && newRxBuff != 0)
    d10c:	f1ba 0f00 	cmp.w	sl, #0
    d110:	d037      	beq.n	d182 <TCPIP_TCP_FifoSizeAdjust+0x2e6>
        if((vFlags & TCP_ADJUST_PRESERVE_RX) != 0)
    d112:	f017 0f04 	tst.w	r7, #4
    d116:	d09f      	beq.n	d058 <TCPIP_TCP_FifoSizeAdjust+0x1bc>
            rxHead = pSkt->rxHead;
    d118:	69e7      	ldr	r7, [r4, #28]
            if(pSkt->sHoleSize != -1)
    d11a:	6d63      	ldr	r3, [r4, #84]	; 0x54
    d11c:	f1b3 3fff 	cmp.w	r3, #4294967295
    d120:	d00a      	beq.n	d138 <TCPIP_TCP_FifoSizeAdjust+0x29c>
                rxHead += pSkt->sHoleSize + pSkt->wFutureDataSize;
    d122:	f8b4 2060 	ldrh.w	r2, [r4, #96]	; 0x60
    d126:	4413      	add	r3, r2
    d128:	441f      	add	r7, r3
                if(rxHead > pSkt->rxEnd)
    d12a:	69a3      	ldr	r3, [r4, #24]
    d12c:	42bb      	cmp	r3, r7
    d12e:	d203      	bcs.n	d138 <TCPIP_TCP_FifoSizeAdjust+0x29c>
                    rxHead -= pSkt->rxEnd - pSkt->rxStart + 1;
    d130:	6962      	ldr	r2, [r4, #20]
    d132:	1a9b      	subs	r3, r3, r2
    d134:	43db      	mvns	r3, r3
    d136:	441f      	add	r7, r3
            if(rxHead > pSkt->rxTail)
    d138:	6a21      	ldr	r1, [r4, #32]
    d13a:	42b9      	cmp	r1, r7
    d13c:	f4bf af71 	bcs.w	d022 <TCPIP_TCP_FifoSizeAdjust+0x186>
                avlblRxBeg = rxHead - pSkt->rxTail;
    d140:	1a7f      	subs	r7, r7, r1
    d142:	b2bf      	uxth	r7, r7
                srcOffs = pSkt->rxTail;
    d144:	9103      	str	r1, [sp, #12]
                avlblRxEnd = 0;
    d146:	2300      	movs	r3, #0
    d148:	9302      	str	r3, [sp, #8]
            if((avlblRxEnd + avlblRxBeg) != 0)
    d14a:	9a02      	ldr	r2, [sp, #8]
    d14c:	19d3      	adds	r3, r2, r7
    d14e:	d085      	beq.n	d05c <TCPIP_TCP_FifoSizeAdjust+0x1c0>
                if(avlblRxEnd + avlblRxBeg > wMinRXSize)
    d150:	42b3      	cmp	r3, r6
    d152:	dcba      	bgt.n	d0ca <TCPIP_TCP_FifoSizeAdjust+0x22e>
                if(avlblRxEnd)
    d154:	2a00      	cmp	r2, #0
    d156:	f47f af70 	bne.w	d03a <TCPIP_TCP_FifoSizeAdjust+0x19e>
                if(avlblRxBeg)
    d15a:	2f00      	cmp	r7, #0
    d15c:	f43f af7e 	beq.w	d05c <TCPIP_TCP_FifoSizeAdjust+0x1c0>
                    memcpy(newRxBuff + avlblRxEnd, srcOffs, avlblRxBeg);
    d160:	463a      	mov	r2, r7
    d162:	9903      	ldr	r1, [sp, #12]
    d164:	9b02      	ldr	r3, [sp, #8]
    d166:	eb0a 0003 	add.w	r0, sl, r3
    d16a:	f016 f8bf 	bl	232ec <memcpy>
    d16e:	e775      	b.n	d05c <TCPIP_TCP_FifoSizeAdjust+0x1c0>
    txUnackOffs = 0;
    d170:	f04f 0b00 	mov.w	fp, #0
    pendTxEnd = pendTxBeg = 0;
    d174:	46d9      	mov	r9, fp
    d176:	f8cd b004 	str.w	fp, [sp, #4]
    d17a:	e7c7      	b.n	d10c <TCPIP_TCP_FifoSizeAdjust+0x270>
    txUnackOffs = 0;
    d17c:	f04f 0b00 	mov.w	fp, #0
    d180:	e7c4      	b.n	d10c <TCPIP_TCP_FifoSizeAdjust+0x270>
    avlblRxEnd = avlblRxBeg = 0;
    d182:	2700      	movs	r7, #0
    d184:	9702      	str	r7, [sp, #8]
    d186:	e76c      	b.n	d062 <TCPIP_TCP_FifoSizeAdjust+0x1c6>
    d188:	2000edc8 	.word	0x2000edc8

Disassembly of section .rodata%243:

0000d18c <.rodata%243>:
    d18c:	50434844 	.word	0x50434844
    d190:	44203a53 	.word	0x44203a53
    d194:	20504348 	.word	0x20504348
    d198:	76726573 	.word	0x76726573
    d19c:	6e207265 	.word	0x6e207265
    d1a0:	73646565 	.word	0x73646565
    d1a4:	6c746120 	.word	0x6c746120
    d1a8:	74736165 	.word	0x74736165
    d1ac:	656e6f20 	.word	0x656e6f20
    d1b0:	64646120 	.word	0x64646120
    d1b4:	73736572 	.word	0x73736572
    d1b8:	6f6f7020 	.word	0x6f6f7020
    d1bc:	0d20216c 	.word	0x0d20216c
    d1c0:	0000000a 	.word	0x0000000a
    d1c4:	50434844 	.word	0x50434844
    d1c8:	4f203a53 	.word	0x4f203a53
    d1cc:	72656874 	.word	0x72656874
    d1d0:	72655320 	.word	0x72655320
    d1d4:	65636976 	.word	0x65636976
    d1d8:	72612073 	.word	0x72612073
    d1dc:	6e652065 	.word	0x6e652065
    d1e0:	656c6261 	.word	0x656c6261
    d1e4:	6f662064 	.word	0x6f662064
    d1e8:	68742072 	.word	0x68742072
    d1ec:	69207369 	.word	0x69207369
    d1f0:	7265746e 	.word	0x7265746e
    d1f4:	65636166 	.word	0x65636166
    d1f8:	000a0d20 	.word	0x000a0d20
    d1fc:	676e6950 	.word	0x676e6950
    d200:	7277203a 	.word	0x7277203a
    d204:	20676e6f 	.word	0x20676e6f
    d208:	6c706572 	.word	0x6c706572
    d20c:	65722079 	.word	0x65722079
    d210:	76696563 	.word	0x76696563
    d214:	202e6465 	.word	0x202e6465
    d218:	6b73614d 	.word	0x6b73614d
    d21c:	7830203a 	.word	0x7830203a
    d220:	0d783225 	.word	0x0d783225
    d224:	0000000a 	.word	0x0000000a
    d228:	676e6950 	.word	0x676e6950
    d22c:	6f47203a 	.word	0x6f47203a
    d230:	7220646f 	.word	0x7220646f
    d234:	796c7065 	.word	0x796c7065
    d238:	63657220 	.word	0x63657220
    d23c:	65766965 	.word	0x65766965
    d240:	30203a64 	.word	0x30203a64
    d244:	78322578 	.word	0x78322578
    d248:	00000a0d 	.word	0x00000a0d
    d24c:	676e6950 	.word	0x676e6950
    d250:	754e203a 	.word	0x754e203a
    d254:	7265626d 	.word	0x7265626d
    d258:	20666f20 	.word	0x20666f20
    d25c:	75716572 	.word	0x75716572
    d260:	20747365 	.word	0x20747365
    d264:	65747461 	.word	0x65747461
    d268:	6574706d 	.word	0x6574706d
    d26c:	64252064 	.word	0x64252064
    d270:	00000a0d 	.word	0x00000a0d
    d274:	676e6950 	.word	0x676e6950
    d278:	6572203a 	.word	0x6572203a
    d27c:	73657571 	.word	0x73657571
    d280:	62612074 	.word	0x62612074
    d284:	6574726f 	.word	0x6574726f
    d288:	79622064 	.word	0x79622064
    d28c:	4d434920 	.word	0x4d434920
    d290:	69772050 	.word	0x69772050
    d294:	72206874 	.word	0x72206874
    d298:	6c757365 	.word	0x6c757365
    d29c:	64252074 	.word	0x64252074
    d2a0:	00000a0d 	.word	0x00000a0d
    d2a4:	2e302e30 	.word	0x2e302e30
    d2a8:	00302e30 	.word	0x00302e30
    d2ac:	50434844 	.word	0x50434844
    d2b0:	49203a53 	.word	0x49203a53
    d2b4:	6974696e 	.word	0x6974696e
    d2b8:	7a696c61 	.word	0x7a696c61
    d2bc:	6f697461 	.word	0x6f697461
    d2c0:	6166206e 	.word	0x6166206e
    d2c4:	64656c69 	.word	0x64656c69
    d2c8:	0a0d2021 	.word	0x0a0d2021
    d2cc:	00000000 	.word	0x00000000
    d2d0:	49504354 	.word	0x49504354
    d2d4:	48445f50 	.word	0x48445f50
    d2d8:	5f535043 	.word	0x5f535043
    d2dc:	54415453 	.word	0x54415453
    d2e0:	44495f45 	.word	0x44495f45
    d2e4:	0d0a454c 	.word	0x0d0a454c
    d2e8:	00000000 	.word	0x00000000
    d2ec:	49504354 	.word	0x49504354
    d2f0:	48445f50 	.word	0x48445f50
    d2f4:	5f535043 	.word	0x5f535043
    d2f8:	52415453 	.word	0x52415453
    d2fc:	45525f54 	.word	0x45525f54
    d300:	4e5f5643 	.word	0x4e5f5643
    d304:	505f5745 	.word	0x505f5745
    d308:	454b4341 	.word	0x454b4341
    d30c:	000d0a54 	.word	0x000d0a54
    d310:	49504354 	.word	0x49504354
    d314:	48445f50 	.word	0x48445f50
    d318:	5f535043 	.word	0x5f535043
    d31c:	45544544 	.word	0x45544544
    d320:	565f5443 	.word	0x565f5443
    d324:	44494c41 	.word	0x44494c41
    d328:	544e495f 	.word	0x544e495f
    d32c:	000d0a46 	.word	0x000d0a46
    d330:	49504354 	.word	0x49504354
    d334:	48445f50 	.word	0x48445f50
    d338:	5f535043 	.word	0x5f535043
    d33c:	53524150 	.word	0x53524150
    d340:	45525f45 	.word	0x45525f45
    d344:	44455643 	.word	0x44455643
    d348:	4341505f 	.word	0x4341505f
    d34c:	0a54454b 	.word	0x0a54454b
    d350:	0000000d 	.word	0x0000000d
    d354:	49504354 	.word	0x49504354
    d358:	48445f50 	.word	0x48445f50
    d35c:	5f535043 	.word	0x5f535043
    d360:	5353454d 	.word	0x5353454d
    d364:	5f454741 	.word	0x5f454741
    d368:	45505954 	.word	0x45505954
    d36c:	00000d0a 	.word	0x00000d0a
    d370:	49504354 	.word	0x49504354
    d374:	48445f50 	.word	0x48445f50
    d378:	5f535043 	.word	0x5f535043
    d37c:	444e4946 	.word	0x444e4946
    d380:	5345445f 	.word	0x5345445f
    d384:	50495243 	.word	0x50495243
    d388:	0a524f54 	.word	0x0a524f54
    d38c:	0000000d 	.word	0x0000000d
    d390:	49504354 	.word	0x49504354
    d394:	48445f50 	.word	0x48445f50
    d398:	5f535043 	.word	0x5f535043
    d39c:	444e4553 	.word	0x444e4553
    d3a0:	46464f5f 	.word	0x46464f5f
    d3a4:	0d0a5245 	.word	0x0d0a5245
    d3a8:	00000000 	.word	0x00000000
    d3ac:	49504354 	.word	0x49504354
    d3b0:	48445f50 	.word	0x48445f50
    d3b4:	5f535043 	.word	0x5f535043
    d3b8:	52415453 	.word	0x52415453
    d3bc:	43495f54 	.word	0x43495f54
    d3c0:	505f504d 	.word	0x505f504d
    d3c4:	45434f52 	.word	0x45434f52
    d3c8:	0d0a5353 	.word	0x0d0a5353
    d3cc:	00000000 	.word	0x00000000
    d3d0:	49504354 	.word	0x49504354
    d3d4:	48445f50 	.word	0x48445f50
    d3d8:	5f535043 	.word	0x5f535043
    d3dc:	5f544547 	.word	0x5f544547
    d3e0:	5f57454e 	.word	0x5f57454e
    d3e4:	52444441 	.word	0x52444441
    d3e8:	0a535345 	.word	0x0a535345
    d3ec:	0000000d 	.word	0x0000000d
    d3f0:	50434844 	.word	0x50434844
    d3f4:	74532053 	.word	0x74532053
    d3f8:	20657461 	.word	0x20657461
    d3fc:	6e6b6e55 	.word	0x6e6b6e55
    d400:	006e776f 	.word	0x006e776f
    d404:	676e6950 	.word	0x676e6950
    d408:	6573203a 	.word	0x6573203a
    d40c:	7220746e 	.word	0x7220746e
    d410:	65757165 	.word	0x65757165
    d414:	25207473 	.word	0x25207473
    d418:	6f742064 	.word	0x6f742064
    d41c:	255b203a 	.word	0x255b203a
    d420:	0a0d5d78 	.word	0x0a0d5d78
    d424:	00000000 	.word	0x00000000
    d428:	676e6950 	.word	0x676e6950
    d42c:	6166203a 	.word	0x6166203a
    d430:	64656c69 	.word	0x64656c69
    d434:	206f7420 	.word	0x206f7420
    d438:	646e6573 	.word	0x646e6573
    d43c:	71657220 	.word	0x71657220
    d440:	74736575 	.word	0x74736575
    d444:	20642520 	.word	0x20642520
    d448:	203a6f74 	.word	0x203a6f74
    d44c:	202c7825 	.word	0x202c7825
    d450:	6f727265 	.word	0x6f727265
    d454:	64252072 	.word	0x64252072
    d458:	0a0d      	.short	0x0a0d
	...

Disassembly of section .text.Hash_DRBG_Generate%244:

0000d45c <Hash_DRBG_Generate>:
    }
}

/* Returns: DRBG_SUCCESS, DRBG_NEED_RESEED, or DRBG_FAILURE */
static int Hash_DRBG_Generate(DRBG_internal* drbg, byte* out, word32 outSz)
{
    d45c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d460:	b0d7      	sub	sp, #348	; 0x15c
    wc_Sha256 sha[1];
#endif
    byte type;
    word32 reseedCtr;

    if (drbg->reseedCtr == RESEED_INTERVAL) {
    d462:	f8d0 b000 	ldr.w	fp, [r0]
    d466:	4bb0      	ldr	r3, [pc, #704]	; (d728 <Hash_DRBG_Generate+0x2cc>)
    d468:	459b      	cmp	fp, r3
    d46a:	f000 813c 	beq.w	d6e6 <Hash_DRBG_Generate+0x28a>
    d46e:	4604      	mov	r4, r0
    d470:	460f      	mov	r7, r1
    d472:	4690      	mov	r8, r2
        if (digest == NULL)
            return MEMORY_E;
    #else
        byte digest[WC_SHA256_DIGEST_SIZE];
    #endif
        type = drbgGenerateH;
    d474:	2303      	movs	r3, #3
    d476:	f88d 30db 	strb.w	r3, [sp, #219]	; 0xdb
        reseedCtr = drbg->reseedCtr;
    d47a:	f8cd b0d4 	str.w	fp, [sp, #212]	; 0xd4
    if (outSz == 0) outSz = 1;
    d47e:	2a00      	cmp	r2, #0
    d480:	f000 8135 	beq.w	d6ee <Hash_DRBG_Generate+0x292>
    len = (outSz / OUTPUT_BLOCK_LEN) + ((outSz % OUTPUT_BLOCK_LEN) ? 1 : 0);
    d484:	f012 091f 	ands.w	r9, r2, #31
    d488:	bf18      	it	ne
    d48a:	f04f 0901 	movne.w	r9, #1
    d48e:	eb09 1952 	add.w	r9, r9, r2, lsr #5
    XMEMCPY(data, V, sizeof(data));
    d492:	f100 0508 	add.w	r5, r0, #8
    d496:	f10d 0c20 	add.w	ip, sp, #32
    d49a:	f100 0e38 	add.w	lr, r0, #56	; 0x38
    d49e:	4666      	mov	r6, ip
    d4a0:	6828      	ldr	r0, [r5, #0]
    d4a2:	6869      	ldr	r1, [r5, #4]
    d4a4:	68aa      	ldr	r2, [r5, #8]
    d4a6:	68eb      	ldr	r3, [r5, #12]
    d4a8:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    d4aa:	3510      	adds	r5, #16
    d4ac:	46b4      	mov	ip, r6
    d4ae:	4575      	cmp	r5, lr
    d4b0:	d1f5      	bne.n	d49e <Hash_DRBG_Generate+0x42>
    d4b2:	6828      	ldr	r0, [r5, #0]
    d4b4:	6030      	str	r0, [r6, #0]
    d4b6:	88aa      	ldrh	r2, [r5, #4]
    d4b8:	79ab      	ldrb	r3, [r5, #6]
    d4ba:	80b2      	strh	r2, [r6, #4]
    d4bc:	71b3      	strb	r3, [r6, #6]
    for (i = 0; i < len; i++) {
    d4be:	f1b9 0f00 	cmp.w	r9, #0
    d4c2:	f300 812d 	bgt.w	d720 <Hash_DRBG_Generate+0x2c4>
    int ret = DRBG_FAILURE;
    d4c6:	2501      	movs	r5, #1
    d4c8:	e036      	b.n	d538 <Hash_DRBG_Generate+0xdc>
            ret = wc_Sha256Update(sha, data, sizeof(data));
    d4ca:	2237      	movs	r2, #55	; 0x37
    d4cc:	4651      	mov	r1, sl
    d4ce:	a816      	add	r0, sp, #88	; 0x58
    d4d0:	f005 ff04 	bl	132dc <wc_Sha256Update>
        if (ret == 0)
    d4d4:	4605      	mov	r5, r0
    d4d6:	bb60      	cbnz	r0, d532 <Hash_DRBG_Generate+0xd6>
            ret = wc_Sha256Final(sha, digest);
    d4d8:	4669      	mov	r1, sp
    d4da:	a816      	add	r0, sp, #88	; 0x58
    d4dc:	f004 fc72 	bl	11dc4 <wc_Sha256Final>
    d4e0:	4605      	mov	r5, r0
        wc_Sha256Free(sha);
    d4e2:	a816      	add	r0, sp, #88	; 0x58
    d4e4:	f010 fbc3 	bl	1dc6e <wc_Sha256Free>
        if (ret == 0) {
    d4e8:	bb35      	cbnz	r5, d538 <Hash_DRBG_Generate+0xdc>
            XMEMCPY(&checkBlock, digest, sizeof(word32));
    d4ea:	9b00      	ldr	r3, [sp, #0]
            if (drbg->reseedCtr > 1 && checkBlock == drbg->lastBlock) {
    d4ec:	6822      	ldr	r2, [r4, #0]
    d4ee:	2a01      	cmp	r2, #1
    d4f0:	d902      	bls.n	d4f8 <Hash_DRBG_Generate+0x9c>
    d4f2:	6862      	ldr	r2, [r4, #4]
    d4f4:	4293      	cmp	r3, r2
    d4f6:	d03b      	beq.n	d570 <Hash_DRBG_Generate+0x114>
                drbg->matchCount = 0;
    d4f8:	2200      	movs	r2, #0
    d4fa:	f884 2080 	strb.w	r2, [r4, #128]	; 0x80
                drbg->lastBlock = checkBlock;
    d4fe:	6063      	str	r3, [r4, #4]
            if (out != NULL && outSz != 0) {
    d500:	b167      	cbz	r7, d51c <Hash_DRBG_Generate+0xc0>
    d502:	f1b8 0f00 	cmp.w	r8, #0
    d506:	d009      	beq.n	d51c <Hash_DRBG_Generate+0xc0>
                if (outSz >= OUTPUT_BLOCK_LEN) {
    d508:	f1b8 0f1f 	cmp.w	r8, #31
    d50c:	d83f      	bhi.n	d58e <Hash_DRBG_Generate+0x132>
                    XMEMCPY(out, digest, outSz);
    d50e:	4642      	mov	r2, r8
    d510:	4669      	mov	r1, sp
    d512:	4638      	mov	r0, r7
    d514:	f015 feea 	bl	232ec <memcpy>
                    outSz = 0;
    d518:	f04f 0800 	mov.w	r8, #0
    for (i = 0; i < len; i++) {
    d51c:	3601      	adds	r6, #1
    d51e:	454e      	cmp	r6, r9
    d520:	da0a      	bge.n	d538 <Hash_DRBG_Generate+0xdc>
        ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
    d522:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
    d524:	6fa1      	ldr	r1, [r4, #120]	; 0x78
    d526:	a816      	add	r0, sp, #88	; 0x58
    d528:	f00f fd26 	bl	1cf78 <wc_InitSha256_ex>
        if (ret == 0)
    d52c:	4605      	mov	r5, r0
    d52e:	2800      	cmp	r0, #0
    d530:	d0cb      	beq.n	d4ca <Hash_DRBG_Generate+0x6e>
        wc_Sha256Free(sha);
    d532:	a816      	add	r0, sp, #88	; 0x58
    d534:	f010 fb9b 	bl	1dc6e <wc_Sha256Free>
#ifndef WOLFSSL_NO_FORCE_ZERO
/* This routine fills the first len bytes of the memory area pointed by mem
   with zeros. It ensures compiler optimizations doesn't skip it  */
WC_STATIC WC_INLINE void ForceZero(const void* mem, word32 len)
{
    volatile byte* z = (volatile byte*)mem;
    d538:	aa08      	add	r2, sp, #32
    for (w = (volatile word64*)z; len >= sizeof(*w); len -= sizeof(*w))
        *w++ = 0;
    z = (volatile byte*)w;
#endif

    while (len--) *z++ = 0;
    d53a:	2000      	movs	r0, #0
    d53c:	f10d 0157 	add.w	r1, sp, #87	; 0x57
    d540:	4613      	mov	r3, r2
    d542:	f803 0b01 	strb.w	r0, [r3], #1
    d546:	461a      	mov	r2, r3
    d548:	428b      	cmp	r3, r1
    d54a:	d1f9      	bne.n	d540 <Hash_DRBG_Generate+0xe4>

        ret = Hash_gen(drbg, out, outSz, drbg->V);
        if (ret == DRBG_SUCCESS) {
    d54c:	2d00      	cmp	r5, #0
    d54e:	d043      	beq.n	d5d8 <Hash_DRBG_Generate+0x17c>
    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
    d550:	2501      	movs	r5, #1
    volatile byte* z = (volatile byte*)mem;
    d552:	aa16      	add	r2, sp, #88	; 0x58
    while (len--) *z++ = 0;
    d554:	2000      	movs	r0, #0
    d556:	a91e      	add	r1, sp, #120	; 0x78
    d558:	4613      	mov	r3, r2
    d55a:	f803 0b01 	strb.w	r0, [r3], #1
    d55e:	461a      	mov	r2, r3
    d560:	428b      	cmp	r3, r1
    d562:	d1f9      	bne.n	d558 <Hash_DRBG_Generate+0xfc>
    #ifdef WC_ASYNC_ENABLE_SHA256
        FREE_VAR(digest, drbg->heap);
    #endif
    }

    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
    d564:	1c28      	adds	r0, r5, #0
    d566:	bf18      	it	ne
    d568:	2001      	movne	r0, #1
}
    d56a:	b057      	add	sp, #348	; 0x15c
    d56c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if (drbg->matchCount == 1) {
    d570:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
    d574:	2b01      	cmp	r3, #1
    d576:	f000 80b8 	beq.w	d6ea <Hash_DRBG_Generate+0x28e>
                    if (i == (len-1)) {
    d57a:	f109 33ff 	add.w	r3, r9, #4294967295
    d57e:	42b3      	cmp	r3, r6
                        len++;
    d580:	bf08      	it	eq
    d582:	f109 0901 	addeq.w	r9, r9, #1
                    drbg->matchCount = 1;
    d586:	2301      	movs	r3, #1
    d588:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
    d58c:	e7b8      	b.n	d500 <Hash_DRBG_Generate+0xa4>
                    XMEMCPY(out, digest, OUTPUT_BLOCK_LEN);
    d58e:	46ec      	mov	ip, sp
    d590:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    d594:	6038      	str	r0, [r7, #0]
    d596:	6079      	str	r1, [r7, #4]
    d598:	60ba      	str	r2, [r7, #8]
    d59a:	60fb      	str	r3, [r7, #12]
    d59c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    d5a0:	6138      	str	r0, [r7, #16]
    d5a2:	6179      	str	r1, [r7, #20]
    d5a4:	61ba      	str	r2, [r7, #24]
    d5a6:	61fb      	str	r3, [r7, #28]
                    outSz -= OUTPUT_BLOCK_LEN;
    d5a8:	f1a8 0820 	sub.w	r8, r8, #32
                    out += OUTPUT_BLOCK_LEN;
    d5ac:	3720      	adds	r7, #32
        data[i]++;
    d5ae:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    d5b2:	3301      	adds	r3, #1
    d5b4:	b2db      	uxtb	r3, r3
    d5b6:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36
        if (data[i] != 0) break;
    d5ba:	2b00      	cmp	r3, #0
    d5bc:	d1ae      	bne.n	d51c <Hash_DRBG_Generate+0xc0>
    d5be:	f10d 0256 	add.w	r2, sp, #86	; 0x56
    d5c2:	4651      	mov	r1, sl
        data[i]++;
    d5c4:	f812 3d01 	ldrb.w	r3, [r2, #-1]!
    d5c8:	3301      	adds	r3, #1
    d5ca:	b2db      	uxtb	r3, r3
    d5cc:	7013      	strb	r3, [r2, #0]
        if (data[i] != 0) break;
    d5ce:	2b00      	cmp	r3, #0
    d5d0:	d1a4      	bne.n	d51c <Hash_DRBG_Generate+0xc0>
    for (i = dataSz - 1; i >= 0; i--)
    d5d2:	428a      	cmp	r2, r1
    d5d4:	d1f6      	bne.n	d5c4 <Hash_DRBG_Generate+0x168>
    d5d6:	e7a1      	b.n	d51c <Hash_DRBG_Generate+0xc0>
            ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
    d5d8:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
    d5da:	6fa1      	ldr	r1, [r4, #120]	; 0x78
    d5dc:	a837      	add	r0, sp, #220	; 0xdc
    d5de:	f00f fccb 	bl	1cf78 <wc_InitSha256_ex>
            if (ret == 0)
    d5e2:	4605      	mov	r5, r0
    d5e4:	b130      	cbz	r0, d5f4 <Hash_DRBG_Generate+0x198>
            wc_Sha256Free(sha);
    d5e6:	a837      	add	r0, sp, #220	; 0xdc
    d5e8:	f010 fb41 	bl	1dc6e <wc_Sha256Free>
            drbg->reseedCtr++;
    d5ec:	6823      	ldr	r3, [r4, #0]
    d5ee:	3301      	adds	r3, #1
    d5f0:	6023      	str	r3, [r4, #0]
    d5f2:	e7ae      	b.n	d552 <Hash_DRBG_Generate+0xf6>
                ret = wc_Sha256Update(sha, &type, sizeof(type));
    d5f4:	2201      	movs	r2, #1
    d5f6:	f10d 01db 	add.w	r1, sp, #219	; 0xdb
    d5fa:	a837      	add	r0, sp, #220	; 0xdc
    d5fc:	f005 fe6e 	bl	132dc <wc_Sha256Update>
            if (ret == 0)
    d600:	4605      	mov	r5, r0
    d602:	2800      	cmp	r0, #0
    d604:	d1ef      	bne.n	d5e6 <Hash_DRBG_Generate+0x18a>
                ret = wc_Sha256Update(sha, drbg->V, sizeof(drbg->V));
    d606:	2237      	movs	r2, #55	; 0x37
    d608:	f104 0108 	add.w	r1, r4, #8
    d60c:	a837      	add	r0, sp, #220	; 0xdc
    d60e:	f005 fe65 	bl	132dc <wc_Sha256Update>
            if (ret == 0)
    d612:	4605      	mov	r5, r0
    d614:	2800      	cmp	r0, #0
    d616:	d1e6      	bne.n	d5e6 <Hash_DRBG_Generate+0x18a>
                ret = wc_Sha256Final(sha, digest);
    d618:	a916      	add	r1, sp, #88	; 0x58
    d61a:	a837      	add	r0, sp, #220	; 0xdc
    d61c:	f004 fbd2 	bl	11dc4 <wc_Sha256Final>
    d620:	4605      	mov	r5, r0
            wc_Sha256Free(sha);
    d622:	a837      	add	r0, sp, #220	; 0xdc
    d624:	f010 fb23 	bl	1dc6e <wc_Sha256Free>
            if (ret == 0) {
    d628:	2d00      	cmp	r5, #0
    d62a:	d1df      	bne.n	d5ec <Hash_DRBG_Generate+0x190>
    d62c:	f104 023f 	add.w	r2, r4, #63	; 0x3f
    d630:	f10d 0777 	add.w	r7, sp, #119	; 0x77
    d634:	f10d 0e58 	add.w	lr, sp, #88	; 0x58
    d638:	4616      	mov	r6, r2
    word16 carry = 0;
    d63a:	2100      	movs	r1, #0
    d63c:	e000      	b.n	d640 <Hash_DRBG_Generate+0x1e4>
        for (sIdx = sLen - 1, dIdx = dLen - 1; sIdx >= 0; dIdx--, sIdx--) {
    d63e:	4607      	mov	r7, r0
            carry += (word16)d[dIdx] + (word16)s[sIdx];
    d640:	4638      	mov	r0, r7
    d642:	f816 3d01 	ldrb.w	r3, [r6, #-1]!
    d646:	f810 c901 	ldrb.w	ip, [r0], #-1
    d64a:	4463      	add	r3, ip
    d64c:	440b      	add	r3, r1
            d[dIdx] = (byte)carry;
    d64e:	7033      	strb	r3, [r6, #0]
            carry >>= 8;
    d650:	f3c3 210f 	ubfx	r1, r3, #8, #16
        for (sIdx = sLen - 1, dIdx = dLen - 1; sIdx >= 0; dIdx--, sIdx--) {
    d654:	4577      	cmp	r7, lr
    d656:	d1f2      	bne.n	d63e <Hash_DRBG_Generate+0x1e2>
        for (; carry != 0 && dIdx >= 0; dIdx--) {
    d658:	b161      	cbz	r1, d674 <Hash_DRBG_Generate+0x218>
    d65a:	f104 001f 	add.w	r0, r4, #31
    d65e:	f104 0608 	add.w	r6, r4, #8
            carry += (word16)d[dIdx];
    d662:	f810 3d01 	ldrb.w	r3, [r0, #-1]!
    d666:	440b      	add	r3, r1
    d668:	b29b      	uxth	r3, r3
            d[dIdx] = (byte)carry;
    d66a:	7003      	strb	r3, [r0, #0]
        for (; carry != 0 && dIdx >= 0; dIdx--) {
    d66c:	0a19      	lsrs	r1, r3, #8
    d66e:	d001      	beq.n	d674 <Hash_DRBG_Generate+0x218>
    d670:	42b0      	cmp	r0, r6
    d672:	d1f6      	bne.n	d662 <Hash_DRBG_Generate+0x206>
        for (sIdx = sLen - 1, dIdx = dLen - 1; sIdx >= 0; dIdx--, sIdx--) {
    d674:	f104 0008 	add.w	r0, r4, #8
    d678:	4611      	mov	r1, r2
    word16 carry = 0;
    d67a:	2300      	movs	r3, #0
            carry += (word16)d[dIdx] + (word16)s[sIdx];
    d67c:	f811 6c01 	ldrb.w	r6, [r1, #-1]
    d680:	f891 7036 	ldrb.w	r7, [r1, #54]	; 0x36
    d684:	443e      	add	r6, r7
    d686:	4433      	add	r3, r6
            d[dIdx] = (byte)carry;
    d688:	f801 3d01 	strb.w	r3, [r1, #-1]!
            carry >>= 8;
    d68c:	f3c3 230f 	ubfx	r3, r3, #8, #16
        for (sIdx = sLen - 1, dIdx = dLen - 1; sIdx >= 0; dIdx--, sIdx--) {
    d690:	4281      	cmp	r1, r0
    d692:	d1f3      	bne.n	d67c <Hash_DRBG_Generate+0x220>
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
    d694:	ea4f 231b 	mov.w	r3, fp, lsr #8
    d698:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
    d69c:	ea4f 210b 	mov.w	r1, fp, lsl #8
    d6a0:	f001 21ff 	and.w	r1, r1, #4278255360	; 0xff00ff00
    d6a4:	430b      	orrs	r3, r1
        return (x << y) | (x >> (sizeof(y) * 8 - y));
    d6a6:	ea4f 4333 	mov.w	r3, r3, ror #16
                reseedCtr = ByteReverseWord32(reseedCtr);
    d6aa:	9335      	str	r3, [sp, #212]	; 0xd4
        for (sIdx = sLen - 1, dIdx = dLen - 1; sIdx >= 0; dIdx--, sIdx--) {
    d6ac:	ae36      	add	r6, sp, #216	; 0xd8
    d6ae:	f104 0c3b 	add.w	ip, r4, #59	; 0x3b
    word16 carry = 0;
    d6b2:	2300      	movs	r3, #0
            carry += (word16)d[dIdx] + (word16)s[sIdx];
    d6b4:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
    d6b8:	f816 7d01 	ldrb.w	r7, [r6, #-1]!
    d6bc:	4439      	add	r1, r7
    d6be:	440b      	add	r3, r1
            d[dIdx] = (byte)carry;
    d6c0:	7013      	strb	r3, [r2, #0]
            carry >>= 8;
    d6c2:	f3c3 230f 	ubfx	r3, r3, #8, #16
        for (sIdx = sLen - 1, dIdx = dLen - 1; sIdx >= 0; dIdx--, sIdx--) {
    d6c6:	4594      	cmp	ip, r2
    d6c8:	d1f4      	bne.n	d6b4 <Hash_DRBG_Generate+0x258>
        for (; carry != 0 && dIdx >= 0; dIdx--) {
    d6ca:	2b00      	cmp	r3, #0
    d6cc:	d08e      	beq.n	d5ec <Hash_DRBG_Generate+0x190>
    d6ce:	f104 023b 	add.w	r2, r4, #59	; 0x3b
            carry += (word16)d[dIdx];
    d6d2:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
    d6d6:	440b      	add	r3, r1
    d6d8:	b29b      	uxth	r3, r3
            d[dIdx] = (byte)carry;
    d6da:	7013      	strb	r3, [r2, #0]
        for (; carry != 0 && dIdx >= 0; dIdx--) {
    d6dc:	0a1b      	lsrs	r3, r3, #8
    d6de:	d085      	beq.n	d5ec <Hash_DRBG_Generate+0x190>
    d6e0:	4282      	cmp	r2, r0
    d6e2:	d1f6      	bne.n	d6d2 <Hash_DRBG_Generate+0x276>
    d6e4:	e782      	b.n	d5ec <Hash_DRBG_Generate+0x190>
        return DRBG_NEED_RESEED;
    d6e6:	2002      	movs	r0, #2
    d6e8:	e73f      	b.n	d56a <Hash_DRBG_Generate+0x10e>
                    return DRBG_CONT_FAILURE;
    d6ea:	2503      	movs	r5, #3
    d6ec:	e731      	b.n	d552 <Hash_DRBG_Generate+0xf6>
    XMEMCPY(data, V, sizeof(data));
    d6ee:	f100 0508 	add.w	r5, r0, #8
    d6f2:	f10d 0c20 	add.w	ip, sp, #32
    d6f6:	f100 0e38 	add.w	lr, r0, #56	; 0x38
    d6fa:	4666      	mov	r6, ip
    d6fc:	6828      	ldr	r0, [r5, #0]
    d6fe:	6869      	ldr	r1, [r5, #4]
    d700:	68aa      	ldr	r2, [r5, #8]
    d702:	68eb      	ldr	r3, [r5, #12]
    d704:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    d706:	3510      	adds	r5, #16
    d708:	46b4      	mov	ip, r6
    d70a:	4575      	cmp	r5, lr
    d70c:	d1f5      	bne.n	d6fa <Hash_DRBG_Generate+0x29e>
    d70e:	6828      	ldr	r0, [r5, #0]
    d710:	6030      	str	r0, [r6, #0]
    d712:	88aa      	ldrh	r2, [r5, #4]
    d714:	79ab      	ldrb	r3, [r5, #6]
    d716:	80b2      	strh	r2, [r6, #4]
    d718:	71b3      	strb	r3, [r6, #6]
    if (outSz == 0) outSz = 1;
    d71a:	f04f 0801 	mov.w	r8, #1
    len = (outSz / OUTPUT_BLOCK_LEN) + ((outSz % OUTPUT_BLOCK_LEN) ? 1 : 0);
    d71e:	46c1      	mov	r9, r8
    d720:	2600      	movs	r6, #0
            ret = wc_Sha256Update(sha, data, sizeof(data));
    d722:	f10d 0a20 	add.w	sl, sp, #32
    d726:	e6fc      	b.n	d522 <Hash_DRBG_Generate+0xc6>
    d728:	000f4240 	.word	0x000f4240

Disassembly of section .text%245:

0000d72c <__udivmoddi4>:
    d72c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    d730:	9e08      	ldr	r6, [sp, #32]
    d732:	4604      	mov	r4, r0
    d734:	4688      	mov	r8, r1
    d736:	2b00      	cmp	r3, #0
    d738:	f040 8085 	bne.w	d846 <__udivmoddi4+0x11a>
    d73c:	428a      	cmp	r2, r1
    d73e:	4615      	mov	r5, r2
    d740:	d948      	bls.n	d7d4 <__udivmoddi4+0xa8>
    d742:	fab2 f282 	clz	r2, r2
    d746:	b14a      	cbz	r2, d75c <__udivmoddi4+0x30>
    d748:	f1c2 0720 	rsb	r7, r2, #32
    d74c:	fa01 f302 	lsl.w	r3, r1, r2
    d750:	fa20 f707 	lsr.w	r7, r0, r7
    d754:	4095      	lsls	r5, r2
    d756:	ea47 0803 	orr.w	r8, r7, r3
    d75a:	4094      	lsls	r4, r2
    d75c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    d760:	0c23      	lsrs	r3, r4, #16
    d762:	fbb8 f7fe 	udiv	r7, r8, lr
    d766:	fa1f fc85 	uxth.w	ip, r5
    d76a:	fb0e 8817 	mls	r8, lr, r7, r8
    d76e:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
    d772:	fb07 f10c 	mul.w	r1, r7, ip
    d776:	4299      	cmp	r1, r3
    d778:	d909      	bls.n	d78e <__udivmoddi4+0x62>
    d77a:	18eb      	adds	r3, r5, r3
    d77c:	f107 30ff 	add.w	r0, r7, #4294967295
    d780:	f080 80e3 	bcs.w	d94a <__udivmoddi4+0x21e>
    d784:	4299      	cmp	r1, r3
    d786:	f240 80e0 	bls.w	d94a <__udivmoddi4+0x21e>
    d78a:	3f02      	subs	r7, #2
    d78c:	442b      	add	r3, r5
    d78e:	1a5b      	subs	r3, r3, r1
    d790:	b2a4      	uxth	r4, r4
    d792:	fbb3 f0fe 	udiv	r0, r3, lr
    d796:	fb0e 3310 	mls	r3, lr, r0, r3
    d79a:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
    d79e:	fb00 fc0c 	mul.w	ip, r0, ip
    d7a2:	45a4      	cmp	ip, r4
    d7a4:	d909      	bls.n	d7ba <__udivmoddi4+0x8e>
    d7a6:	192c      	adds	r4, r5, r4
    d7a8:	f100 33ff 	add.w	r3, r0, #4294967295
    d7ac:	f080 80cb 	bcs.w	d946 <__udivmoddi4+0x21a>
    d7b0:	45a4      	cmp	ip, r4
    d7b2:	f240 80c8 	bls.w	d946 <__udivmoddi4+0x21a>
    d7b6:	3802      	subs	r0, #2
    d7b8:	442c      	add	r4, r5
    d7ba:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
    d7be:	eba4 040c 	sub.w	r4, r4, ip
    d7c2:	2700      	movs	r7, #0
    d7c4:	b11e      	cbz	r6, d7ce <__udivmoddi4+0xa2>
    d7c6:	40d4      	lsrs	r4, r2
    d7c8:	2300      	movs	r3, #0
    d7ca:	e9c6 4300 	strd	r4, r3, [r6]
    d7ce:	4639      	mov	r1, r7
    d7d0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    d7d4:	2a00      	cmp	r2, #0
    d7d6:	d053      	beq.n	d880 <__udivmoddi4+0x154>
    d7d8:	fab2 f282 	clz	r2, r2
    d7dc:	2a00      	cmp	r2, #0
    d7de:	f040 80b6 	bne.w	d94e <__udivmoddi4+0x222>
    d7e2:	1b49      	subs	r1, r1, r5
    d7e4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    d7e8:	fa1f f885 	uxth.w	r8, r5
    d7ec:	2701      	movs	r7, #1
    d7ee:	fbb1 fcfe 	udiv	ip, r1, lr
    d7f2:	0c23      	lsrs	r3, r4, #16
    d7f4:	fb0e 111c 	mls	r1, lr, ip, r1
    d7f8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    d7fc:	fb08 f10c 	mul.w	r1, r8, ip
    d800:	4299      	cmp	r1, r3
    d802:	d907      	bls.n	d814 <__udivmoddi4+0xe8>
    d804:	18eb      	adds	r3, r5, r3
    d806:	f10c 30ff 	add.w	r0, ip, #4294967295
    d80a:	d202      	bcs.n	d812 <__udivmoddi4+0xe6>
    d80c:	4299      	cmp	r1, r3
    d80e:	f200 80ec 	bhi.w	d9ea <__udivmoddi4+0x2be>
    d812:	4684      	mov	ip, r0
    d814:	1a59      	subs	r1, r3, r1
    d816:	b2a3      	uxth	r3, r4
    d818:	fbb1 f0fe 	udiv	r0, r1, lr
    d81c:	fb0e 1410 	mls	r4, lr, r0, r1
    d820:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
    d824:	fb08 f800 	mul.w	r8, r8, r0
    d828:	45a0      	cmp	r8, r4
    d82a:	d907      	bls.n	d83c <__udivmoddi4+0x110>
    d82c:	192c      	adds	r4, r5, r4
    d82e:	f100 33ff 	add.w	r3, r0, #4294967295
    d832:	d202      	bcs.n	d83a <__udivmoddi4+0x10e>
    d834:	45a0      	cmp	r8, r4
    d836:	f200 80dc 	bhi.w	d9f2 <__udivmoddi4+0x2c6>
    d83a:	4618      	mov	r0, r3
    d83c:	eba4 0408 	sub.w	r4, r4, r8
    d840:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
    d844:	e7be      	b.n	d7c4 <__udivmoddi4+0x98>
    d846:	428b      	cmp	r3, r1
    d848:	d908      	bls.n	d85c <__udivmoddi4+0x130>
    d84a:	2e00      	cmp	r6, #0
    d84c:	d078      	beq.n	d940 <__udivmoddi4+0x214>
    d84e:	2700      	movs	r7, #0
    d850:	e9c6 0100 	strd	r0, r1, [r6]
    d854:	4638      	mov	r0, r7
    d856:	4639      	mov	r1, r7
    d858:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    d85c:	fab3 f783 	clz	r7, r3
    d860:	b97f      	cbnz	r7, d882 <__udivmoddi4+0x156>
    d862:	428b      	cmp	r3, r1
    d864:	d302      	bcc.n	d86c <__udivmoddi4+0x140>
    d866:	4282      	cmp	r2, r0
    d868:	f200 80bd 	bhi.w	d9e6 <__udivmoddi4+0x2ba>
    d86c:	1a84      	subs	r4, r0, r2
    d86e:	eb61 0303 	sbc.w	r3, r1, r3
    d872:	2001      	movs	r0, #1
    d874:	4698      	mov	r8, r3
    d876:	2e00      	cmp	r6, #0
    d878:	d0a9      	beq.n	d7ce <__udivmoddi4+0xa2>
    d87a:	e9c6 4800 	strd	r4, r8, [r6]
    d87e:	e7a6      	b.n	d7ce <__udivmoddi4+0xa2>
    d880:	deff      	udf	#255	; 0xff
    d882:	f1c7 0520 	rsb	r5, r7, #32
    d886:	40bb      	lsls	r3, r7
    d888:	fa22 fc05 	lsr.w	ip, r2, r5
    d88c:	ea4c 0c03 	orr.w	ip, ip, r3
    d890:	fa01 f407 	lsl.w	r4, r1, r7
    d894:	fa20 f805 	lsr.w	r8, r0, r5
    d898:	fa21 f305 	lsr.w	r3, r1, r5
    d89c:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
    d8a0:	ea48 0404 	orr.w	r4, r8, r4
    d8a4:	fbb3 f9fe 	udiv	r9, r3, lr
    d8a8:	0c21      	lsrs	r1, r4, #16
    d8aa:	fb0e 3319 	mls	r3, lr, r9, r3
    d8ae:	fa1f f88c 	uxth.w	r8, ip
    d8b2:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
    d8b6:	fb09 fa08 	mul.w	sl, r9, r8
    d8ba:	459a      	cmp	sl, r3
    d8bc:	fa02 f207 	lsl.w	r2, r2, r7
    d8c0:	fa00 f107 	lsl.w	r1, r0, r7
    d8c4:	d90b      	bls.n	d8de <__udivmoddi4+0x1b2>
    d8c6:	eb1c 0303 	adds.w	r3, ip, r3
    d8ca:	f109 30ff 	add.w	r0, r9, #4294967295
    d8ce:	f080 8088 	bcs.w	d9e2 <__udivmoddi4+0x2b6>
    d8d2:	459a      	cmp	sl, r3
    d8d4:	f240 8085 	bls.w	d9e2 <__udivmoddi4+0x2b6>
    d8d8:	f1a9 0902 	sub.w	r9, r9, #2
    d8dc:	4463      	add	r3, ip
    d8de:	eba3 030a 	sub.w	r3, r3, sl
    d8e2:	b2a4      	uxth	r4, r4
    d8e4:	fbb3 f0fe 	udiv	r0, r3, lr
    d8e8:	fb0e 3310 	mls	r3, lr, r0, r3
    d8ec:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
    d8f0:	fb00 f808 	mul.w	r8, r0, r8
    d8f4:	45a0      	cmp	r8, r4
    d8f6:	d908      	bls.n	d90a <__udivmoddi4+0x1de>
    d8f8:	eb1c 0404 	adds.w	r4, ip, r4
    d8fc:	f100 33ff 	add.w	r3, r0, #4294967295
    d900:	d26b      	bcs.n	d9da <__udivmoddi4+0x2ae>
    d902:	45a0      	cmp	r8, r4
    d904:	d969      	bls.n	d9da <__udivmoddi4+0x2ae>
    d906:	3802      	subs	r0, #2
    d908:	4464      	add	r4, ip
    d90a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
    d90e:	eba4 0408 	sub.w	r4, r4, r8
    d912:	fba0 8902 	umull	r8, r9, r0, r2
    d916:	454c      	cmp	r4, r9
    d918:	46c6      	mov	lr, r8
    d91a:	464b      	mov	r3, r9
    d91c:	d354      	bcc.n	d9c8 <__udivmoddi4+0x29c>
    d91e:	d051      	beq.n	d9c4 <__udivmoddi4+0x298>
    d920:	2e00      	cmp	r6, #0
    d922:	d069      	beq.n	d9f8 <__udivmoddi4+0x2cc>
    d924:	ebb1 020e 	subs.w	r2, r1, lr
    d928:	eb64 0403 	sbc.w	r4, r4, r3
    d92c:	fa04 f505 	lsl.w	r5, r4, r5
    d930:	fa22 f307 	lsr.w	r3, r2, r7
    d934:	40fc      	lsrs	r4, r7
    d936:	431d      	orrs	r5, r3
    d938:	e9c6 5400 	strd	r5, r4, [r6]
    d93c:	2700      	movs	r7, #0
    d93e:	e746      	b.n	d7ce <__udivmoddi4+0xa2>
    d940:	4637      	mov	r7, r6
    d942:	4630      	mov	r0, r6
    d944:	e743      	b.n	d7ce <__udivmoddi4+0xa2>
    d946:	4618      	mov	r0, r3
    d948:	e737      	b.n	d7ba <__udivmoddi4+0x8e>
    d94a:	4607      	mov	r7, r0
    d94c:	e71f      	b.n	d78e <__udivmoddi4+0x62>
    d94e:	f1c2 0320 	rsb	r3, r2, #32
    d952:	fa20 f703 	lsr.w	r7, r0, r3
    d956:	4095      	lsls	r5, r2
    d958:	fa01 f002 	lsl.w	r0, r1, r2
    d95c:	fa21 f303 	lsr.w	r3, r1, r3
    d960:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    d964:	4338      	orrs	r0, r7
    d966:	0c01      	lsrs	r1, r0, #16
    d968:	fbb3 f7fe 	udiv	r7, r3, lr
    d96c:	fa1f f885 	uxth.w	r8, r5
    d970:	fb0e 3317 	mls	r3, lr, r7, r3
    d974:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    d978:	fb07 f308 	mul.w	r3, r7, r8
    d97c:	428b      	cmp	r3, r1
    d97e:	fa04 f402 	lsl.w	r4, r4, r2
    d982:	d907      	bls.n	d994 <__udivmoddi4+0x268>
    d984:	1869      	adds	r1, r5, r1
    d986:	f107 3cff 	add.w	ip, r7, #4294967295
    d98a:	d228      	bcs.n	d9de <__udivmoddi4+0x2b2>
    d98c:	428b      	cmp	r3, r1
    d98e:	d926      	bls.n	d9de <__udivmoddi4+0x2b2>
    d990:	3f02      	subs	r7, #2
    d992:	4429      	add	r1, r5
    d994:	1acb      	subs	r3, r1, r3
    d996:	b281      	uxth	r1, r0
    d998:	fbb3 f0fe 	udiv	r0, r3, lr
    d99c:	fb0e 3310 	mls	r3, lr, r0, r3
    d9a0:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    d9a4:	fb00 f308 	mul.w	r3, r0, r8
    d9a8:	428b      	cmp	r3, r1
    d9aa:	d907      	bls.n	d9bc <__udivmoddi4+0x290>
    d9ac:	1869      	adds	r1, r5, r1
    d9ae:	f100 3cff 	add.w	ip, r0, #4294967295
    d9b2:	d210      	bcs.n	d9d6 <__udivmoddi4+0x2aa>
    d9b4:	428b      	cmp	r3, r1
    d9b6:	d90e      	bls.n	d9d6 <__udivmoddi4+0x2aa>
    d9b8:	3802      	subs	r0, #2
    d9ba:	4429      	add	r1, r5
    d9bc:	1ac9      	subs	r1, r1, r3
    d9be:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
    d9c2:	e714      	b.n	d7ee <__udivmoddi4+0xc2>
    d9c4:	4541      	cmp	r1, r8
    d9c6:	d2ab      	bcs.n	d920 <__udivmoddi4+0x1f4>
    d9c8:	ebb8 0e02 	subs.w	lr, r8, r2
    d9cc:	eb69 020c 	sbc.w	r2, r9, ip
    d9d0:	3801      	subs	r0, #1
    d9d2:	4613      	mov	r3, r2
    d9d4:	e7a4      	b.n	d920 <__udivmoddi4+0x1f4>
    d9d6:	4660      	mov	r0, ip
    d9d8:	e7f0      	b.n	d9bc <__udivmoddi4+0x290>
    d9da:	4618      	mov	r0, r3
    d9dc:	e795      	b.n	d90a <__udivmoddi4+0x1de>
    d9de:	4667      	mov	r7, ip
    d9e0:	e7d8      	b.n	d994 <__udivmoddi4+0x268>
    d9e2:	4681      	mov	r9, r0
    d9e4:	e77b      	b.n	d8de <__udivmoddi4+0x1b2>
    d9e6:	4638      	mov	r0, r7
    d9e8:	e745      	b.n	d876 <__udivmoddi4+0x14a>
    d9ea:	f1ac 0c02 	sub.w	ip, ip, #2
    d9ee:	442b      	add	r3, r5
    d9f0:	e710      	b.n	d814 <__udivmoddi4+0xe8>
    d9f2:	3802      	subs	r0, #2
    d9f4:	442c      	add	r4, r5
    d9f6:	e721      	b.n	d83c <__udivmoddi4+0x110>
    d9f8:	4637      	mov	r7, r6
    d9fa:	e6e8      	b.n	d7ce <__udivmoddi4+0xa2>

Disassembly of section .text._TCP_Open%246:

0000d9fc <_TCP_Open>:
{
    d9fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    da00:	b083      	sub	sp, #12
    da02:	4680      	mov	r8, r0
    da04:	468a      	mov	sl, r1
    da06:	9200      	str	r2, [sp, #0]
    da08:	9301      	str	r3, [sp, #4]
    if(opType == TCP_OPEN_CLIENT)
    da0a:	2901      	cmp	r1, #1
    da0c:	d000      	beq.n	da10 <_TCP_Open+0x14>
    if(localPort == 0)
    da0e:	bb02      	cbnz	r2, da52 <_TCP_Open+0x56>
        localPort = _TCP_EphemeralPortAllocate();
    da10:	f012 fe50 	bl	206b4 <_TCP_EphemeralPortAllocate>
        if(localPort  == 0)
    da14:	4683      	mov	fp, r0
    da16:	2800      	cmp	r0, #0
    da18:	f000 8124 	beq.w	dc64 <_TCP_Open+0x268>
    if (OSAL_SEM_Pend(&tcpSemaphore, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
    da1c:	f64f 71ff 	movw	r1, #65535	; 0xffff
    da20:	489f      	ldr	r0, [pc, #636]	; (dca0 <_TCP_Open+0x2a4>)
    da22:	f015 fa67 	bl	22ef4 <OSAL_SEM_Pend>
    for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    da26:	4b9f      	ldr	r3, [pc, #636]	; (dca4 <_TCP_Open+0x2a8>)
    da28:	681a      	ldr	r2, [r3, #0]
    da2a:	2a00      	cmp	r2, #0
    da2c:	f000 80cc 	beq.w	dbc8 <_TCP_Open+0x1cc>
        pSkt = TCBStubs[hTCP];
    da30:	4b9d      	ldr	r3, [pc, #628]	; (dca8 <_TCP_Open+0x2ac>)
    da32:	6819      	ldr	r1, [r3, #0]
    da34:	680b      	ldr	r3, [r1, #0]
        if(pSkt == 0)
    da36:	2b00      	cmp	r3, #0
    da38:	f000 8117 	beq.w	dc6a <_TCP_Open+0x26e>
    for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    da3c:	2400      	movs	r4, #0
    da3e:	3401      	adds	r4, #1
    da40:	b224      	sxth	r4, r4
    da42:	4626      	mov	r6, r4
    da44:	4294      	cmp	r4, r2
    da46:	d209      	bcs.n	da5c <_TCP_Open+0x60>
        pSkt = TCBStubs[hTCP];
    da48:	f851 3024 	ldr.w	r3, [r1, r4, lsl #2]
        if(pSkt == 0)
    da4c:	2b00      	cmp	r3, #0
    da4e:	d1f6      	bne.n	da3e <_TCP_Open+0x42>
    da50:	e007      	b.n	da62 <_TCP_Open+0x66>
        localPort = port;
    da52:	f8dd b000 	ldr.w	fp, [sp]
        remotePort = 0;
    da56:	2300      	movs	r3, #0
    da58:	9300      	str	r3, [sp, #0]
    da5a:	e7df      	b.n	da1c <_TCP_Open+0x20>
    if(pSkt != 0)
    da5c:	2b00      	cmp	r3, #0
    da5e:	f040 80b3 	bne.w	dbc8 <_TCP_Open+0x1cc>
    pSkt = (TCB_STUB*)TCPIP_HEAP_Calloc(tcpHeapH, 1, sizeof(*pSkt));
    da62:	f8df 9250 	ldr.w	r9, [pc, #592]	; dcb4 <_TCP_Open+0x2b8>
    da66:	f8d9 0000 	ldr.w	r0, [r9]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Calloc)(h, nElems, elemSize);
    da6a:	6883      	ldr	r3, [r0, #8]
    da6c:	2280      	movs	r2, #128	; 0x80
    da6e:	2101      	movs	r1, #1
    da70:	4798      	blx	r3
    da72:	4605      	mov	r5, r0
    txBuff = (uint8_t*)TCPIP_HEAP_Malloc(tcpHeapH, tcpDefTxSize + 1);
    da74:	f8d9 0000 	ldr.w	r0, [r9]
    da78:	4b8c      	ldr	r3, [pc, #560]	; (dcac <_TCP_Open+0x2b0>)
    da7a:	8819      	ldrh	r1, [r3, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
    da7c:	6843      	ldr	r3, [r0, #4]
    da7e:	3101      	adds	r1, #1
    da80:	4798      	blx	r3
    da82:	4607      	mov	r7, r0
    rxBuff = (uint8_t*)TCPIP_HEAP_Malloc(tcpHeapH, tcpDefRxSize + 1);
    da84:	f8d9 0000 	ldr.w	r0, [r9]
    da88:	4b89      	ldr	r3, [pc, #548]	; (dcb0 <_TCP_Open+0x2b4>)
    da8a:	8819      	ldrh	r1, [r3, #0]
    da8c:	6843      	ldr	r3, [r0, #4]
    da8e:	3101      	adds	r1, #1
    da90:	4798      	blx	r3
    if(pSkt == 0 || txBuff == 0 || rxBuff == 0)
    da92:	2d00      	cmp	r5, #0
    da94:	f000 809e 	beq.w	dbd4 <_TCP_Open+0x1d8>
    da98:	2f00      	cmp	r7, #0
    da9a:	f000 809b 	beq.w	dbd4 <_TCP_Open+0x1d8>
    da9e:	2800      	cmp	r0, #0
    daa0:	f000 8098 	beq.w	dbd4 <_TCP_Open+0x1d8>
    _TcpSocketInitialize(pSkt, hTCP, txBuff, tcpDefTxSize, rxBuff, tcpDefRxSize);
    daa4:	4b81      	ldr	r3, [pc, #516]	; (dcac <_TCP_Open+0x2b0>)
    daa6:	881b      	ldrh	r3, [r3, #0]
    daa8:	4a81      	ldr	r2, [pc, #516]	; (dcb0 <_TCP_Open+0x2b4>)
    daaa:	8811      	ldrh	r1, [r2, #0]
    pSkt->sktIx = hTCP;     // hTCP is the index of this socket!
    daac:	86ac      	strh	r4, [r5, #52]	; 0x34
    pSkt->txStart	= txBuff;
    daae:	602f      	str	r7, [r5, #0]
    pSkt->txEnd	    = txBuff + txBuffSize + 1;
    dab0:	3301      	adds	r3, #1
    dab2:	441f      	add	r7, r3
    dab4:	606f      	str	r7, [r5, #4]
    pSkt->rxStart	= rxBuff;
    dab6:	6168      	str	r0, [r5, #20]
    pSkt->rxEnd		= rxBuff + rxBuffSize;
    dab8:	4408      	add	r0, r1
    daba:	61a8      	str	r0, [r5, #24]
    pSkt->wRemoteMSS = TCP_MIN_DEFAULT_MTU;
    dabc:	f44f 7306 	mov.w	r3, #536	; 0x218
    dac0:	f8a5 3062 	strh.w	r3, [r5, #98]	; 0x62
    TCBStubs[hTCP] = pSkt;  // store it
    dac4:	4b78      	ldr	r3, [pc, #480]	; (dca8 <_TCP_Open+0x2ac>)
    dac6:	681b      	ldr	r3, [r3, #0]
    dac8:	f843 5026 	str.w	r5, [r3, r6, lsl #2]
    if (OSAL_SEM_Post(&tcpSemaphore) != OSAL_RESULT_TRUE)
    dacc:	4874      	ldr	r0, [pc, #464]	; (dca0 <_TCP_Open+0x2a4>)
    dace:	f015 fe5d 	bl	2378c <OSAL_SEM_Post>
	pSkt->remoteHash = pSkt->localPort;
    dad2:	f8b5 305a 	ldrh.w	r3, [r5, #90]	; 0x5a
    dad6:	f8a5 306a 	strh.w	r3, [r5, #106]	; 0x6a
	pSkt->txHead = pSkt->txStart;
    dada:	682b      	ldr	r3, [r5, #0]
    dadc:	60ab      	str	r3, [r5, #8]
	pSkt->txTail = pSkt->txStart;
    dade:	60eb      	str	r3, [r5, #12]
	pSkt->txUnackedTail = pSkt->txStart;
    dae0:	612b      	str	r3, [r5, #16]
	pSkt->rxHead = pSkt->rxStart;
    dae2:	696b      	ldr	r3, [r5, #20]
    dae4:	61eb      	str	r3, [r5, #28]
	pSkt->rxTail = pSkt->rxStart;
    dae6:	622b      	str	r3, [r5, #32]
	pSkt->Flags.bTimerEnabled = 0;
    dae8:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
	pSkt->Flags.bTXASAPWithoutTimerReset = 0;
    daec:	f003 0381 	and.w	r3, r3, #129	; 0x81
    daf0:	f36f 13c7 	bfc	r3, #7, #1
    daf4:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
	pSkt->Flags.bTXFIN = 0;
    daf8:	f895 3037 	ldrb.w	r3, [r5, #55]	; 0x37
	pSkt->Flags.bSocketReset = 1;
    dafc:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	pSkt->Flags.bRxFin = 0;
    db00:	f043 0302 	orr.w	r3, r3, #2
    db04:	f36f 0382 	bfc	r3, #2, #1
    db08:	f885 3037 	strb.w	r3, [r5, #55]	; 0x37
	pSkt->flags.bFINSent = 0;
    db0c:	f895 306c 	ldrb.w	r3, [r5, #108]	; 0x6c
    pSkt->flags.seqInc = 0;
    db10:	f895 206d 	ldrb.w	r2, [r5, #109]	; 0x6d
    db14:	f36f 0241 	bfc	r2, #1, #1
    db18:	f885 206d 	strb.w	r2, [r5, #109]	; 0x6d
	pSkt->flags.bRXNoneACKed2 = 0;
    db1c:	f003 03e3 	and.w	r3, r3, #227	; 0xe3
    db20:	f36f 1345 	bfc	r3, #5, #1
    db24:	f885 306c 	strb.w	r3, [r5, #108]	; 0x6c
    pSkt->MySEQ = 0;
    db28:	2100      	movs	r1, #0
    db2a:	64e9      	str	r1, [r5, #76]	; 0x4c
	pSkt->sHoleSize = -1;
    db2c:	f04f 30ff 	mov.w	r0, #4294967295
    db30:	6568      	str	r0, [r5, #84]	; 0x54
	pSkt->remoteWindow = 1;
    db32:	2001      	movs	r0, #1
    db34:	f8a5 005c 	strh.w	r0, [r5, #92]	; 0x5c
    pSkt->maxRemoteWindow = 1;
    db38:	f8a5 0066 	strh.w	r0, [r5, #102]	; 0x66
    pSkt->remotePort = 0;
    db3c:	f8a5 1058 	strh.w	r1, [r5, #88]	; 0x58
    pSkt->destAddress.Val = 0;
    db40:	63a9      	str	r1, [r5, #56]	; 0x38
	pSkt->keepAliveCount = 0;
    db42:	f885 1071 	strb.w	r1, [r5, #113]	; 0x71
    pSkt->addType = (IP_ADDRESS_TYPE)pSkt->flags.openAddType;
    db46:	f003 0303 	and.w	r3, r3, #3
    db4a:	f885 306f 	strb.w	r3, [r5, #111]	; 0x6f
    if(pSkt->flags.openBindIf == 0)
    db4e:	b2d2      	uxtb	r2, r2
    db50:	f012 0f20 	tst.w	r2, #32
        pSkt->pSktNet = 0;
    db54:	bf04      	itt	eq
    db56:	460b      	moveq	r3, r1
    db58:	6429      	streq	r1, [r5, #64]	; 0x40
    if(pSkt->flags.openBindAdd == 0)
    db5a:	f012 0f40 	tst.w	r2, #64	; 0x40
        pSkt->srcAddress.Val = 0;
    db5e:	bf04      	itt	eq
    db60:	2300      	moveq	r3, #0
    db62:	63eb      	streq	r3, [r5, #60]	; 0x3c
    pSkt->dbgFlags.val = 0;
    db64:	2300      	movs	r3, #0
    db66:	f885 307d 	strb.w	r3, [r5, #125]	; 0x7d
    pSkt->addType = addType;
    db6a:	f885 806f 	strb.w	r8, [r5, #111]	; 0x6f
    switch(addType)
    db6e:	f1b8 0f01 	cmp.w	r8, #1
    db72:	d043      	beq.n	dbfc <_TCP_Open+0x200>
            pSkt->pTxPkt = 0;   // default for IP_ADDRESS_TYPE_ANY
    db74:	2300      	movs	r3, #0
    db76:	646b      	str	r3, [r5, #68]	; 0x44
    if (pSkt->pTxPkt == 0 && pSkt->addType != IP_ADDRESS_TYPE_ANY)
    db78:	f895 306f 	ldrb.w	r3, [r5, #111]	; 0x6f
    db7c:	2b00      	cmp	r3, #0
    db7e:	d16b      	bne.n	dc58 <_TCP_Open+0x25c>
    pSkt->flags.openAddType = addType;
    db80:	f895 306c 	ldrb.w	r3, [r5, #108]	; 0x6c
    db84:	f368 0301 	bfi	r3, r8, #0, #2
    db88:	f885 306c 	strb.w	r3, [r5, #108]	; 0x6c
    if(opType == TCP_OPEN_SERVER)
    db8c:	f1ba 0f00 	cmp.w	sl, #0
    db90:	d051      	beq.n	dc36 <_TCP_Open+0x23a>
        pSkt->localPort = localPort;
    db92:	f8a5 b05a 	strh.w	fp, [r5, #90]	; 0x5a
        pSkt->remotePort = remotePort;
    db96:	9b00      	ldr	r3, [sp, #0]
    db98:	f8a5 3058 	strh.w	r3, [r5, #88]	; 0x58
        pSkt->eventTime = SYS_TMR_TickCountGet();
    db9c:	f014 fb4e 	bl	2223c <SYS_TMR_TickCountGet>
    dba0:	6268      	str	r0, [r5, #36]	; 0x24
        pSkt->Flags.bTimerEnabled = 1;
    dba2:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
    dba6:	f043 0302 	orr.w	r3, r3, #2
    dbaa:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
        switch(addType)
    dbae:	f1b8 0f01 	cmp.w	r8, #1
    dbb2:	d06b      	beq.n	dc8c <_TCP_Open+0x290>
        _TcpSocketSetState(pSkt, (_TcpClientSocketConnect(pSkt) >= 0) ? TCPIP_TCP_STATE_SYN_SENT : TCPIP_TCP_STATE_CLIENT_WAIT_CONNECT);
    dbb4:	4628      	mov	r0, r5
    dbb6:	f00f fcaf 	bl	1d518 <_TcpClientSocketConnect>
    dbba:	2800      	cmp	r0, #0
    dbbc:	bfac      	ite	ge
    dbbe:	2301      	movge	r3, #1
    dbc0:	230b      	movlt	r3, #11
    pSkt->smState = newState;
    dbc2:	f885 306e 	strb.w	r3, [r5, #110]	; 0x6e
    dbc6:	e043      	b.n	dc50 <_TCP_Open+0x254>
        if (OSAL_SEM_Post(&tcpSemaphore) != OSAL_RESULT_TRUE)
    dbc8:	4835      	ldr	r0, [pc, #212]	; (dca0 <_TCP_Open+0x2a4>)
    dbca:	f015 fddf 	bl	2378c <OSAL_SEM_Post>
        return INVALID_SOCKET;
    dbce:	f04f 34ff 	mov.w	r4, #4294967295
    dbd2:	e03d      	b.n	dc50 <_TCP_Open+0x254>
        TCPIP_HEAP_Free(tcpHeapH, rxBuff);
    dbd4:	4c37      	ldr	r4, [pc, #220]	; (dcb4 <_TCP_Open+0x2b8>)
    dbd6:	6823      	ldr	r3, [r4, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
    dbd8:	68da      	ldr	r2, [r3, #12]
    dbda:	4601      	mov	r1, r0
    dbdc:	4618      	mov	r0, r3
    dbde:	4790      	blx	r2
        TCPIP_HEAP_Free(tcpHeapH, txBuff);
    dbe0:	6820      	ldr	r0, [r4, #0]
    dbe2:	68c3      	ldr	r3, [r0, #12]
    dbe4:	4639      	mov	r1, r7
    dbe6:	4798      	blx	r3
        TCPIP_HEAP_Free(tcpHeapH, pSkt);
    dbe8:	6820      	ldr	r0, [r4, #0]
    dbea:	68c3      	ldr	r3, [r0, #12]
    dbec:	4629      	mov	r1, r5
    dbee:	4798      	blx	r3
        if (OSAL_SEM_Post(&tcpSemaphore) != OSAL_RESULT_TRUE)
    dbf0:	482b      	ldr	r0, [pc, #172]	; (dca0 <_TCP_Open+0x2a4>)
    dbf2:	f015 fdcb 	bl	2378c <OSAL_SEM_Post>
        return INVALID_SOCKET;
    dbf6:	f04f 34ff 	mov.w	r4, #4294967295
    dbfa:	e029      	b.n	dc50 <_TCP_Open+0x254>
    pv4Pkt = (TCP_V4_PACKET*)TCPIP_PKT_SocketAlloc(sizeof(TCP_V4_PACKET), sizeof(TCP_HEADER), sizeof(TCP_OPTIONS), allocFlags);
    dbfc:	f242 0306 	movw	r3, #8198	; 0x2006
    dc00:	2204      	movs	r2, #4
    dc02:	2114      	movs	r1, #20
    dc04:	2074      	movs	r0, #116	; 0x74
    dc06:	f013 ff21 	bl	21a4c <_TCPIP_PKT_SocketAlloc>
    if(pv4Pkt)
    dc0a:	2800      	cmp	r0, #0
    dc0c:	d046      	beq.n	dc9c <_TCP_Open+0x2a0>
    pPkt->ackFunc = ackFunc;
    dc0e:	4a2a      	ldr	r2, [pc, #168]	; (dcb8 <_TCP_Open+0x2bc>)
    dc10:	6082      	str	r2, [r0, #8]
    pPkt->ackParam = ackParam;
    dc12:	60c5      	str	r5, [r0, #12]
        pv4Pkt->tcpSeg[0].segFlags = pv4Pkt->tcpSeg[1].segFlags = TCPIP_MAC_SEG_FLAG_STATIC; // embedded in packet itself
    dc14:	2201      	movs	r2, #1
    dc16:	f8a0 206c 	strh.w	r2, [r0, #108]	; 0x6c
    dc1a:	f8a0 2054 	strh.w	r2, [r0, #84]	; 0x54
            pSkt->pTxPkt = _TcpAllocateTxPacket (pSkt, IP_ADDRESS_TYPE_IPV4);
    dc1e:	6468      	str	r0, [r5, #68]	; 0x44
    if (pSkt->pTxPkt == 0 && pSkt->addType != IP_ADDRESS_TYPE_ANY)
    dc20:	2800      	cmp	r0, #0
    dc22:	d0a9      	beq.n	db78 <_TCP_Open+0x17c>
    pSkt->flags.openAddType = addType;
    dc24:	f895 306c 	ldrb.w	r3, [r5, #108]	; 0x6c
    dc28:	f368 0301 	bfi	r3, r8, #0, #2
    dc2c:	f885 306c 	strb.w	r3, [r5, #108]	; 0x6c
    if(opType == TCP_OPEN_SERVER)
    dc30:	f1ba 0f00 	cmp.w	sl, #0
    dc34:	d11c      	bne.n	dc70 <_TCP_Open+0x274>
        pSkt->localPort = localPort;
    dc36:	f8a5 b05a 	strh.w	fp, [r5, #90]	; 0x5a
        pSkt->Flags.bServer = true;
    dc3a:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
    dc3e:	f043 0301 	orr.w	r3, r3, #1
    dc42:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
    pSkt->smState = newState;
    dc46:	2300      	movs	r3, #0
    dc48:	f885 306e 	strb.w	r3, [r5, #110]	; 0x6e
        pSkt->remoteHash = localPort;
    dc4c:	f8a5 b06a 	strh.w	fp, [r5, #106]	; 0x6a
}
    dc50:	4620      	mov	r0, r4
    dc52:	b003      	add	sp, #12
    dc54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        _TcpSocketKill(pSkt);
    dc58:	4628      	mov	r0, r5
    dc5a:	f010 fd99 	bl	1e790 <_TcpSocketKill>
        return INVALID_SOCKET;
    dc5e:	f04f 34ff 	mov.w	r4, #4294967295
    dc62:	e7f5      	b.n	dc50 <_TCP_Open+0x254>
            return INVALID_SOCKET;
    dc64:	f04f 34ff 	mov.w	r4, #4294967295
    dc68:	e7f2      	b.n	dc50 <_TCP_Open+0x254>
    for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    dc6a:	2400      	movs	r4, #0
    dc6c:	4626      	mov	r6, r4
    if(pSkt != 0)
    dc6e:	e6f8      	b.n	da62 <_TCP_Open+0x66>
        pSkt->localPort = localPort;
    dc70:	f8a5 b05a 	strh.w	fp, [r5, #90]	; 0x5a
        pSkt->remotePort = remotePort;
    dc74:	9b00      	ldr	r3, [sp, #0]
    dc76:	f8a5 3058 	strh.w	r3, [r5, #88]	; 0x58
        pSkt->eventTime = SYS_TMR_TickCountGet();
    dc7a:	f014 fadf 	bl	2223c <SYS_TMR_TickCountGet>
    dc7e:	6268      	str	r0, [r5, #36]	; 0x24
        pSkt->Flags.bTimerEnabled = 1;
    dc80:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
    dc84:	f043 0302 	orr.w	r3, r3, #2
    dc88:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
                if(hostAddress != 0 && hostAddress->v4Add.Val != 0)
    dc8c:	9b01      	ldr	r3, [sp, #4]
    dc8e:	2b00      	cmp	r3, #0
    dc90:	d090      	beq.n	dbb4 <_TCP_Open+0x1b8>
    dc92:	681b      	ldr	r3, [r3, #0]
    dc94:	2b00      	cmp	r3, #0
    dc96:	d08d      	beq.n	dbb4 <_TCP_Open+0x1b8>
                    pSkt->destAddress.Val = hostAddress->v4Add.Val;
    dc98:	63ab      	str	r3, [r5, #56]	; 0x38
    dc9a:	e78b      	b.n	dbb4 <_TCP_Open+0x1b8>
            pSkt->pTxPkt = _TcpAllocateTxPacket (pSkt, IP_ADDRESS_TYPE_IPV4);
    dc9c:	6468      	str	r0, [r5, #68]	; 0x44
    if (pSkt->pTxPkt == 0 && pSkt->addType != IP_ADDRESS_TYPE_ANY)
    dc9e:	e76b      	b.n	db78 <_TCP_Open+0x17c>
    dca0:	2000edd4 	.word	0x2000edd4
    dca4:	2000edc4 	.word	0x2000edc4
    dca8:	2000edc0 	.word	0x2000edc0
    dcac:	2000ed2a 	.word	0x2000ed2a
    dcb0:	2000eda2 	.word	0x2000eda2
    dcb4:	2000edc8 	.word	0x2000edc8
    dcb8:	00015329 	.word	0x00015329

Disassembly of section .text.TCPIP_ARP_Task%247:

0000dcbc <TCPIP_ARP_Task>:

// called after service needed reported
// maintain the queues, processes, etc.

void TCPIP_ARP_Task(void)
{
    dcbc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    dcc0:	b087      	sub	sp, #28
               TCPIP_ARP_Probe(pIf, &pIf->netIPAddr, &pIf->netIPAddr, ARP_OPERATION_RESP | ARP_OPERATION_CONFIGURE | ARP_OPERATION_PROBE_ONLY);
           }
        }
    }
#else
    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    dcc2:	210f      	movs	r1, #15
    dcc4:	2002      	movs	r0, #2
    dcc6:	f012 fa35 	bl	20134 <_TCPIPStackModuleSignalGet>
    dcca:	4606      	mov	r6, r0
#endif  // (_TCPIP_STACK_INTERFACE_CHANGE_SIGNALING != 0)
    
    if((sigPend & TCPIP_MODULE_SIGNAL_RX_PENDING) != 0)
    dccc:	f010 0f01 	tst.w	r0, #1
    dcd0:	d106      	bne.n	dce0 <TCPIP_ARP_Task+0x24>
    { //  RX signal occurred
        TCPIP_ARP_Process();
    }

    if((sigPend & TCPIP_MODULE_SIGNAL_TMO) != 0)
    dcd2:	f016 0f02 	tst.w	r6, #2
    dcd6:	f040 8085 	bne.w	dde4 <TCPIP_ARP_Task+0x128>
    { // regular TMO occurred
        TCPIP_ARP_Timeout();
    }

}
    dcda:	b007      	add	sp, #28
    dcdc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    IPV4_ADDR targetAdd;
    IPV4_ADDR   algnSenderIpAddr;


    // extract queued ARP packets
    while((pPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
    dce0:	2702      	movs	r7, #2
        // Validate the ARP packet
        if ( pArpPkt->HardwareType != HW_ETHERNET     ||
                pArpPkt->MACAddrLen != sizeof(TCPIP_MAC_ADDR)  ||
                pArpPkt->ProtocolLen != sizeof(IPV4_ADDR) )
        {
            ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    dce2:	f06f 090d 	mvn.w	r9, #13
    dce6:	e009      	b.n	dcfc <TCPIP_ARP_Task+0x40>
                pArpPkt->MACAddrLen != sizeof(TCPIP_MAC_ADDR)  ||
    dce8:	88a2      	ldrh	r2, [r4, #4]
    dcea:	f240 4306 	movw	r3, #1030	; 0x406
    dcee:	429a      	cmp	r2, r3
    dcf0:	d013      	beq.n	dd1a <TCPIP_ARP_Task+0x5e>
            ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    dcf2:	4649      	mov	r1, r9

        if(arpReqRes != ARP_RES_OK)
        {
        }

        TCPIP_PKT_PacketAcknowledge(pPkt, ackRes); 
    dcf4:	463a      	mov	r2, r7
    dcf6:	4628      	mov	r0, r5
    dcf8:	f011 fed4 	bl	1faa4 <_TCPIP_PKT_PacketAcknowledge>
    while((pPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
    dcfc:	4638      	mov	r0, r7
    dcfe:	f013 fe8f 	bl	21a20 <_TCPIPStackModuleRxExtract>
    dd02:	4605      	mov	r5, r0
    dd04:	2800      	cmp	r0, #0
    dd06:	d0e4      	beq.n	dcd2 <TCPIP_ARP_Task+0x16>
        pArpPkt = (ARP_PACKET*)pPkt->pNetLayer;
    dd08:	69ac      	ldr	r4, [r5, #24]
        _SwapARPPacket(pArpPkt);
    dd0a:	4620      	mov	r0, r4
    dd0c:	f014 ff48 	bl	22ba0 <_SwapARPPacket>
        if ( pArpPkt->HardwareType != HW_ETHERNET     ||
    dd10:	8823      	ldrh	r3, [r4, #0]
    dd12:	2b01      	cmp	r3, #1
    dd14:	d0e8      	beq.n	dce8 <TCPIP_ARP_Task+0x2c>
            ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    dd16:	4649      	mov	r1, r9
    dd18:	e7ec      	b.n	dcf4 <TCPIP_ARP_Task+0x38>
            targetAdd.Val = pArpPkt->TargetIPAddr.Val;
    dd1a:	f8d4 a018 	ldr.w	sl, [r4, #24]
            pPkt->pktIf = pInIf = _TCPIPStackMapAliasInterface((TCPIP_NET_IF*)pPkt->pktIf, &targetAdd);
    dd1e:	f8d5 8028 	ldr.w	r8, [r5, #40]	; 0x28
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
    dd22:	4b93      	ldr	r3, [pc, #588]	; (df70 <TCPIP_ARP_Task+0x2b4>)
    dd24:	f8d3 b004 	ldr.w	fp, [r3, #4]
    dd28:	4640      	mov	r0, r8
    dd2a:	f016 f905 	bl	23f38 <TCPIP_STACK_NetIxGet>
            algnSenderIpAddr.Val = pArpPkt->SenderIPAddr.Val;
    dd2e:	f8d4 300e 	ldr.w	r3, [r4, #14]
    dd32:	9305      	str	r3, [sp, #20]
            hE = TCPIP_OAHASH_EntryLookup(pArpDcpt->hashDcpt, &algnSenderIpAddr.Val);
    dd34:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
    dd38:	a905      	add	r1, sp, #20
    dd3a:	f85b 0030 	ldr.w	r0, [fp, r0, lsl #3]
    dd3e:	f00e fe21 	bl	1c984 <TCPIP_OAHASH_EntryLookup>
            if(hE != 0)
    dd42:	4683      	mov	fp, r0
    dd44:	b128      	cbz	r0, dd52 <TCPIP_ARP_Task+0x96>
                _ARPUpdateEntry(pInIf, (ARP_HASH_ENTRY*)hE, &pArpPkt->SenderMACAddr);
    dd46:	f104 0208 	add.w	r2, r4, #8
    dd4a:	4601      	mov	r1, r0
    dd4c:	4640      	mov	r0, r8
    dd4e:	f00d ff9b 	bl	1bc88 <_ARPUpdateEntry>
            if(targetAdd.Val == pInIf->netIPAddr.Val)
    dd52:	f8d8 3004 	ldr.w	r3, [r8, #4]
    dd56:	459a      	cmp	sl, r3
    dd58:	d03d      	beq.n	ddd6 <TCPIP_ARP_Task+0x11a>
            ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    dd5a:	4639      	mov	r1, r7
    dd5c:	e7ca      	b.n	dcf4 <TCPIP_ARP_Task+0x38>
                if(hE == 0)
    dd5e:	f1bb 0f00 	cmp.w	fp, #0
    dd62:	d004      	beq.n	dd6e <TCPIP_ARP_Task+0xb2>
                if(pArpPkt->Operation == ARP_OPERATION_REQ)
    dd64:	88e3      	ldrh	r3, [r4, #6]
    dd66:	2b01      	cmp	r3, #1
    dd68:	d026      	beq.n	ddb8 <TCPIP_ARP_Task+0xfc>
            ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    dd6a:	4639      	mov	r1, r7
    dd6c:	e7c2      	b.n	dcf4 <TCPIP_ARP_Task+0x38>
                    arpReqRes = _ARPAddCompleteEntry(pInIf, &algnSenderIpAddr, &pArpPkt->SenderMACAddr);
    dd6e:	f104 0308 	add.w	r3, r4, #8
    dd72:	9302      	str	r3, [sp, #8]
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
    dd74:	497e      	ldr	r1, [pc, #504]	; (df70 <TCPIP_ARP_Task+0x2b4>)
    dd76:	f8d1 a004 	ldr.w	sl, [r1, #4]
    dd7a:	4640      	mov	r0, r8
    dd7c:	f016 f8dc 	bl	23f38 <TCPIP_STACK_NetIxGet>
    dd80:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
    dd84:	eb0a 0bc0 	add.w	fp, sl, r0, lsl #3
    hE = TCPIP_OAHASH_EntryLookupOrInsert(pArpDcpt->hashDcpt, pIPAddr);
    dd88:	a905      	add	r1, sp, #20
    dd8a:	f85a 0030 	ldr.w	r0, [sl, r0, lsl #3]
    dd8e:	f00e fff9 	bl	1cd84 <TCPIP_OAHASH_EntryLookupOrInsert>
    if(hE == 0)
    dd92:	2800      	cmp	r0, #0
    dd94:	d0e6      	beq.n	dd64 <TCPIP_ARP_Task+0xa8>
    if(arpHE->hEntry.flags.newEntry != 0)
    dd96:	7803      	ldrb	r3, [r0, #0]
    dd98:	f013 0f02 	tst.w	r3, #2
    dd9c:	d006      	beq.n	ddac <TCPIP_ARP_Task+0xf0>
        _ARPSetEntry(arpHE, ARP_FLAG_ENTRY_COMPLETE, hwAdd, &pArpDcpt->completeList);
    dd9e:	f10b 0318 	add.w	r3, fp, #24
    dda2:	9a02      	ldr	r2, [sp, #8]
    dda4:	2180      	movs	r1, #128	; 0x80
    dda6:	f012 fe73 	bl	20a90 <_ARPSetEntry>
    ddaa:	e7db      	b.n	dd64 <TCPIP_ARP_Task+0xa8>
        _ARPUpdateEntry(pIf, arpHE, hwAdd);
    ddac:	9a02      	ldr	r2, [sp, #8]
    ddae:	4601      	mov	r1, r0
    ddb0:	4640      	mov	r0, r8
    ddb2:	f00d ff69 	bl	1bc88 <_ARPUpdateEntry>
    ddb6:	e7d5      	b.n	dd64 <TCPIP_ARP_Task+0xa8>
                    if(!_ARPSendIfPkt(pInIf, ARP_OPERATION_RESP, (uint32_t)pTgtIf->netIPAddr.Val, (uint32_t)pArpPkt->SenderIPAddr.Val, &pArpPkt->SenderMACAddr, &pTgtIf->netMACAddr))
    ddb8:	f8d4 300e 	ldr.w	r3, [r4, #14]
    ddbc:	f8d8 2004 	ldr.w	r2, [r8, #4]
    ddc0:	f108 013c 	add.w	r1, r8, #60	; 0x3c
    ddc4:	9101      	str	r1, [sp, #4]
    ddc6:	3408      	adds	r4, #8
    ddc8:	9400      	str	r4, [sp, #0]
    ddca:	4639      	mov	r1, r7
    ddcc:	4640      	mov	r0, r8
    ddce:	f00a fb69 	bl	184a4 <_ARPSendIfPkt>
            ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    ddd2:	4639      	mov	r1, r7
    ddd4:	e78e      	b.n	dcf4 <TCPIP_ARP_Task+0x38>
// helper to check if an address service is running
TCPIP_STACK_ADDRESS_SERVICE_TYPE _TCPIPStackAddressServiceIsRunning(TCPIP_NET_IF* pNetIf);

static __inline__ bool __attribute__((always_inline)) _TCPIPStackIsConfig(TCPIP_NET_IF* pNetIf)
{
    return pNetIf->Flags.bInConfig != 0;
    ddd6:	f898 3043 	ldrb.w	r3, [r8, #67]	; 0x43
            while( pTgtIf != 0 && !_TCPIPStackIsConfig(pTgtIf))
    ddda:	f013 0f10 	tst.w	r3, #16
    ddde:	d0be      	beq.n	dd5e <TCPIP_ARP_Task+0xa2>
            ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    dde0:	4639      	mov	r1, r7
    dde2:	e787      	b.n	dcf4 <TCPIP_ARP_Task+0x38>
    arpMod.timeMs += TCPIP_ARP_TASK_PROCESS_RATE;
    dde4:	4c62      	ldr	r4, [pc, #392]	; (df70 <TCPIP_ARP_Task+0x2b4>)
    dde6:	69a3      	ldr	r3, [r4, #24]
    dde8:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
    ddec:	61a3      	str	r3, [r4, #24]
    arpMod.timeSeconds = arpMod.timeMs / 1000;
    ddee:	4a61      	ldr	r2, [pc, #388]	; (df74 <TCPIP_ARP_Task+0x2b8>)
    ddf0:	fba2 2303 	umull	r2, r3, r2, r3
    ddf4:	099b      	lsrs	r3, r3, #6
    ddf6:	6163      	str	r3, [r4, #20]
    nArpIfs = TCPIP_STACK_NumberOfNetworksGet();
    ddf8:	f016 fa1e 	bl	24238 <TCPIP_STACK_NumberOfNetworksGet>
    pArpDcpt = arpMod.arpCacheDcpt;
    ddfc:	6867      	ldr	r7, [r4, #4]
    for(netIx = 0; netIx < nArpIfs; netIx++)
    ddfe:	1e03      	subs	r3, r0, #0
    de00:	9303      	str	r3, [sp, #12]
    de02:	f77f af6a 	ble.w	dcda <TCPIP_ARP_Task+0x1e>
    de06:	f107 0648 	add.w	r6, r7, #72	; 0x48
    de0a:	3718      	adds	r7, #24
    de0c:	f04f 0b00 	mov.w	fp, #0
    de10:	e05c      	b.n	decc <TCPIP_ARP_Task+0x210>
                    _ARPSendIfPkt(pIf, ARP_OPERATION_REQ, (uint32_t)pIf->netIPAddr.Val, pE->ipAddress.Val, &arpBcastAdd, 0);
    de12:	686b      	ldr	r3, [r5, #4]
    de14:	9802      	ldr	r0, [sp, #8]
    de16:	6842      	ldr	r2, [r0, #4]
    de18:	f8cd a004 	str.w	sl, [sp, #4]
    de1c:	4956      	ldr	r1, [pc, #344]	; (df78 <TCPIP_ARP_Task+0x2bc>)
    de1e:	9100      	str	r1, [sp, #0]
    de20:	2101      	movs	r1, #1
    de22:	f00a fb3f 	bl	184a4 <_ARPSendIfPkt>
                    pE->nRetries++;
    de26:	8a6b      	ldrh	r3, [r5, #18]
    de28:	3301      	adds	r3, #1
    de2a:	826b      	strh	r3, [r5, #18]
        for(pN = pArpDcpt->incompleteList.list.head; pN != 0; pN = pN->next)
    de2c:	682d      	ldr	r5, [r5, #0]
    de2e:	b1d5      	cbz	r5, de66 <TCPIP_ARP_Task+0x1aa>
            if((pE->hEntry.flags.value & ARP_FLAG_ENTRY_GRATUITOUS) != 0)
    de30:	f835 1c04 	ldrh.w	r1, [r5, #-4]
    de34:	f411 7f00 	tst.w	r1, #512	; 0x200
                maxRetries = arpMod.entryGratRetries;
    de38:	bf14      	ite	ne
    de3a:	f8b4 3046 	ldrhne.w	r3, [r4, #70]	; 0x46
                maxRetries = arpMod.entryRetries;
    de3e:	f8b4 3044 	ldrheq.w	r3, [r4, #68]	; 0x44
            if( pE->nRetries < maxRetries && (arpMod.timeSeconds - pE->tInsert) >= pE->nRetries * arpMod.entryRetryTmo)
    de42:	8a68      	ldrh	r0, [r5, #18]
    de44:	4298      	cmp	r0, r3
    de46:	d2f1      	bcs.n	de2c <TCPIP_ARP_Task+0x170>
    de48:	6962      	ldr	r2, [r4, #20]
    de4a:	68ab      	ldr	r3, [r5, #8]
    de4c:	1ad2      	subs	r2, r2, r3
    de4e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    de50:	fb03 f300 	mul.w	r3, r3, r0
    de54:	429a      	cmp	r2, r3
    de56:	d3e9      	bcc.n	de2c <TCPIP_ARP_Task+0x170>
                if(isConfig == false || (pE->hEntry.flags.value & ARP_FLAG_ENTRY_CONFIGURE) != 0 )
    de58:	f1b9 0f00 	cmp.w	r9, #0
    de5c:	d0d9      	beq.n	de12 <TCPIP_ARP_Task+0x156>
    de5e:	f411 7f80 	tst.w	r1, #256	; 0x100
    de62:	d0e3      	beq.n	de2c <TCPIP_ARP_Task+0x170>
    de64:	e7d5      	b.n	de12 <TCPIP_ARP_Task+0x156>
        while( (pN = pArpDcpt->completeList.list.head) != 0)
    de66:	f858 5c30 	ldr.w	r5, [r8, #-48]
    de6a:	b305      	cbz	r5, deae <TCPIP_ARP_Task+0x1f2>
            if( (arpMod.timeSeconds - pE->tInsert) >= arpMod.entrySolvedTmo)
    de6c:	6963      	ldr	r3, [r4, #20]
    de6e:	68aa      	ldr	r2, [r5, #8]
    de70:	1a9b      	subs	r3, r3, r2
    de72:	6b62      	ldr	r2, [r4, #52]	; 0x34
    de74:	4293      	cmp	r3, r2
    de76:	d31a      	bcc.n	deae <TCPIP_ARP_Task+0x1f2>
                _ARPNotifyClients(pIf, &pE->ipAddress, 0, ARP_EVENT_REMOVED_EXPIRED);
    de78:	f06f 0a02 	mvn.w	sl, #2
    de7c:	f04f 0900 	mov.w	r9, #0
                TCPIP_OAHASH_EntryRemove(pArpDcpt->hashDcpt, &pE->hEntry);
    de80:	1f29      	subs	r1, r5, #4
    de82:	f858 0c48 	ldr.w	r0, [r8, #-72]
    de86:	f015 fc15 	bl	236b4 <TCPIP_OAHASH_EntryRemove>
                TCPIP_Helper_ProtectedSingleListHeadRemove(&pArpDcpt->completeList);
    de8a:	4638      	mov	r0, r7
    de8c:	f013 fd9c 	bl	219c8 <TCPIP_Helper_ProtectedSingleListHeadRemove>
                _ARPNotifyClients(pIf, &pE->ipAddress, 0, ARP_EVENT_REMOVED_EXPIRED);
    de90:	4653      	mov	r3, sl
    de92:	464a      	mov	r2, r9
    de94:	1d29      	adds	r1, r5, #4
    de96:	9802      	ldr	r0, [sp, #8]
    de98:	f00f feea 	bl	1dc70 <_ARPNotifyClients>
        while( (pN = pArpDcpt->completeList.list.head) != 0)
    de9c:	f858 5c30 	ldr.w	r5, [r8, #-48]
    dea0:	b12d      	cbz	r5, deae <TCPIP_ARP_Task+0x1f2>
            if( (arpMod.timeSeconds - pE->tInsert) >= arpMod.entrySolvedTmo)
    dea2:	6963      	ldr	r3, [r4, #20]
    dea4:	68aa      	ldr	r2, [r5, #8]
    dea6:	1a9b      	subs	r3, r3, r2
    dea8:	6b62      	ldr	r2, [r4, #52]	; 0x34
    deaa:	4293      	cmp	r3, r2
    deac:	d2e8      	bcs.n	de80 <TCPIP_ARP_Task+0x1c4>
        if(pArpDcpt->hashDcpt->fullSlots >= pArpDcpt->purgeThres)
    deae:	f858 3c48 	ldr.w	r3, [r8, #-72]
    deb2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    deb4:	f858 3c08 	ldr.w	r3, [r8, #-8]
    deb8:	429a      	cmp	r2, r3
    deba:	d23a      	bcs.n	df32 <TCPIP_ARP_Task+0x276>
    for(netIx = 0; netIx < nArpIfs; netIx++)
    debc:	f10b 0b01 	add.w	fp, fp, #1
    dec0:	3648      	adds	r6, #72	; 0x48
    dec2:	3748      	adds	r7, #72	; 0x48
    dec4:	9b03      	ldr	r3, [sp, #12]
    dec6:	455b      	cmp	r3, fp
    dec8:	f43f af07 	beq.w	dcda <TCPIP_ARP_Task+0x1e>
        pIf = (TCPIP_NET_IF*)TCPIP_STACK_IndexToNet(netIx);
    decc:	4658      	mov	r0, fp
    dece:	f014 f8d9 	bl	22084 <TCPIP_STACK_IndexToNet>
    ded2:	9002      	str	r0, [sp, #8]
TCPIP_NET_IF* _TCPIPStackMapAliasInterface(TCPIP_NET_IF* pNetIf, const IPV4_ADDR* pDestAddress);

#else
static __inline__ bool  __attribute__((always_inline)) _TCPIPStackNetIsPrimary(TCPIP_NET_IF* pNetIf)
{
    return true;
    ded4:	46b0      	mov	r8, r6
        while( (pN = pArpDcpt->incompleteList.list.head) != 0)
    ded6:	f856 5c1c 	ldr.w	r5, [r6, #-28]
    deda:	2d00      	cmp	r5, #0
    dedc:	d0c3      	beq.n	de66 <TCPIP_ARP_Task+0x1aa>
            if( (arpMod.timeSeconds - pE->tInsert) >= arpMod.entryPendingTmo)
    dede:	6963      	ldr	r3, [r4, #20]
    dee0:	68aa      	ldr	r2, [r5, #8]
    dee2:	1a9b      	subs	r3, r3, r2
    dee4:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    dee6:	4293      	cmp	r3, r2
    dee8:	d31b      	bcc.n	df22 <TCPIP_ARP_Task+0x266>
                TCPIP_Helper_ProtectedSingleListHeadRemove(&pArpDcpt->incompleteList);
    deea:	f107 0a14 	add.w	sl, r7, #20
                _ARPNotifyClients(pIf, &pE->ipAddress, 0, ARP_EVENT_REMOVED_TMO);
    deee:	f04f 39ff 	mov.w	r9, #4294967295
                TCPIP_OAHASH_EntryRemove(pArpDcpt->hashDcpt, &pE->hEntry);
    def2:	1f29      	subs	r1, r5, #4
    def4:	f858 0c48 	ldr.w	r0, [r8, #-72]
    def8:	f015 fbdc 	bl	236b4 <TCPIP_OAHASH_EntryRemove>
                TCPIP_Helper_ProtectedSingleListHeadRemove(&pArpDcpt->incompleteList);
    defc:	4650      	mov	r0, sl
    defe:	f013 fd63 	bl	219c8 <TCPIP_Helper_ProtectedSingleListHeadRemove>
                _ARPNotifyClients(pIf, &pE->ipAddress, 0, ARP_EVENT_REMOVED_TMO);
    df02:	464b      	mov	r3, r9
    df04:	2200      	movs	r2, #0
    df06:	1d29      	adds	r1, r5, #4
    df08:	9802      	ldr	r0, [sp, #8]
    df0a:	f00f feb1 	bl	1dc70 <_ARPNotifyClients>
        while( (pN = pArpDcpt->incompleteList.list.head) != 0)
    df0e:	f858 5c1c 	ldr.w	r5, [r8, #-28]
    df12:	2d00      	cmp	r5, #0
    df14:	d0a7      	beq.n	de66 <TCPIP_ARP_Task+0x1aa>
            if( (arpMod.timeSeconds - pE->tInsert) >= arpMod.entryPendingTmo)
    df16:	6963      	ldr	r3, [r4, #20]
    df18:	68aa      	ldr	r2, [r5, #8]
    df1a:	1a9b      	subs	r3, r3, r2
    df1c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    df1e:	4293      	cmp	r3, r2
    df20:	d2e7      	bcs.n	def2 <TCPIP_ARP_Task+0x236>
    return pNetIf->Flags.bInConfig != 0;
    df22:	9b02      	ldr	r3, [sp, #8]
    df24:	f893 9043 	ldrb.w	r9, [r3, #67]	; 0x43
    df28:	f009 0910 	and.w	r9, r9, #16
                    _ARPSendIfPkt(pIf, ARP_OPERATION_REQ, (uint32_t)pIf->netIPAddr.Val, pE->ipAddress.Val, &arpBcastAdd, 0);
    df2c:	f04f 0a00 	mov.w	sl, #0
    df30:	e77e      	b.n	de30 <TCPIP_ARP_Task+0x174>
            for(purgeIx = 0; purgeIx < pArpDcpt->purgeQuanta; purgeIx++)
    df32:	f858 3c04 	ldr.w	r3, [r8, #-4]
    df36:	2b00      	cmp	r3, #0
    df38:	d0c0      	beq.n	debc <TCPIP_ARP_Task+0x200>
    df3a:	2500      	movs	r5, #0
                    _ARPNotifyClients(pIf, &pE->ipAddress, 0, ARP_EVENT_REMOVED_PURGED);
    df3c:	f06f 0a03 	mvn.w	sl, #3
                pN = TCPIP_Helper_ProtectedSingleListHeadRemove(&pArpDcpt->completeList);
    df40:	4638      	mov	r0, r7
    df42:	f013 fd41 	bl	219c8 <TCPIP_Helper_ProtectedSingleListHeadRemove>
                if(pN)
    df46:	4681      	mov	r9, r0
    df48:	2800      	cmp	r0, #0
    df4a:	d0b7      	beq.n	debc <TCPIP_ARP_Task+0x200>
                    TCPIP_OAHASH_EntryRemove(pArpDcpt->hashDcpt, &pE->hEntry);
    df4c:	1f01      	subs	r1, r0, #4
    df4e:	f858 0c48 	ldr.w	r0, [r8, #-72]
    df52:	f015 fbaf 	bl	236b4 <TCPIP_OAHASH_EntryRemove>
                    _ARPNotifyClients(pIf, &pE->ipAddress, 0, ARP_EVENT_REMOVED_PURGED);
    df56:	4653      	mov	r3, sl
    df58:	2200      	movs	r2, #0
    df5a:	f109 0104 	add.w	r1, r9, #4
    df5e:	9802      	ldr	r0, [sp, #8]
    df60:	f00f fe86 	bl	1dc70 <_ARPNotifyClients>
            for(purgeIx = 0; purgeIx < pArpDcpt->purgeQuanta; purgeIx++)
    df64:	3501      	adds	r5, #1
    df66:	f858 3c04 	ldr.w	r3, [r8, #-4]
    df6a:	429d      	cmp	r5, r3
    df6c:	d3e8      	bcc.n	df40 <TCPIP_ARP_Task+0x284>
    df6e:	e7a5      	b.n	debc <TCPIP_ARP_Task+0x200>
    df70:	2000e974 	.word	0x2000e974
    df74:	10624dd3 	.word	0x10624dd3
    df78:	2000ed9c 	.word	0x2000ed9c

Disassembly of section .rodata.sysfont_glyphs%248:

0000df7c <sysfont_glyphs>:
    df7c:	00000000 20000000 20202020 50502000     .......     . PP
    df8c:	00000050 f8505000 5050f850 70a07820     P....PP.P.PP x.p
    df9c:	c020f028 402010c8 90601898 90a840a0     (. ... @..`..@..
    dfac:	40206068 00000000 40402010 40102040     h` @..... @@@ .@
    dfbc:	10101020 50004020 5020f820 20200000      ... @.P . P..  
    dfcc:	002020f8 00000000 00402060 00f80000     .  .....` @.....
    dfdc:	00000000 60000000 10080060 00804020     .......``... @..
    dfec:	a8988870 207088c8 20202060 88707020     p.....p `    pp.
    dffc:	40201008 2010f8f8 70880810 90503010     .. @... ...p.0P.
    e00c:	f81010f8 0808f080 40307088 8888f080     .........p0@....
    e01c:	1008f870 40404020 70888870 70708888     p... @@@p..p..pp
    e02c:	08788888 60006010 60600060 60600000     ..x..`.``.``..``
    e03c:	40206000 40201008 00081020 f800f800     .` @.. @ .......
    e04c:	40800000 40201020 08887080 20002010     ...@ . @.p... . 
    e05c:	68088870 7070a8a8 f8888888 88f08888     p..h..pp........
    e06c:	8888f088 808870f0 70888080 888890e0     .....p.....p....
    e07c:	f8e09088 80f08080 80f8f880 8080e080     ................
    e08c:	80887080 70889880 f8888888 70888888     .p.....p.......p
    e09c:	20202020 10387020 90101010 a0908860          p8.....`...
    e0ac:	8890a0c0 80808080 88f88080 8888a8d8     ................
    e0bc:	88888888 8898a8c8 88887088 70888888     .........p.....p
    e0cc:	f08888f0 70808080 a8888888 88f06890     .......p.....h..
    e0dc:	90a0f088 80807888 f0080870 202020f8     .....x..p....   
    e0ec:	88202020 88888888 88887088 50888888        ......p.....P
    e0fc:	88888820 88d8a8a8 20508888 88888850      .........P P...
    e10c:	20205088 08f82020 80402010 202038f8     .P    ... @..8  
    e11c:	38202020 20408000 e0000810 20202020        8..@ ....    
    e12c:	5020e020 00000088 00000000 f8000000      . P............
    e13c:	00102040 00000000 78087000 80807888     @ .......p.x.x..
    e14c:	8888c8b0 700000f0 70888080 98680808     .......p...p..h.
    e15c:	00788888 f8887000 48307080 4040e040     ..x..p...p0H@.@@
    e16c:	78000040 30087888 c8b08080 20888888     @..x.x.0....... 
    e17c:	20206000 00107020 90101030 48404060     .`   p..0...`@@H
    e18c:	48506050 20202060 00702020 a8a8d000     P`PH`     p.....
    e19c:	00008888 8888c8b0 70000088 70888888     ...........p...p
    e1ac:	88f00000 008080f0 78986800 00000808     .........h.x....
    e1bc:	8080c8b0 70000080 f0087080 40e04040     .......p.p..@@.@
    e1cc:	00304840 88888800 00006898 50888888     @H0......h.....P
    e1dc:	88000020 50a8a888 50880000 00885020      ......P...P P..
    e1ec:	78888800 00007008 402010f8 202010f8     ...x.p.... @..  
    e1fc:	10202040 20202020 40202020 20102020     @  .       @  . 
    e20c:	bf004020                                 @..

Disassembly of section .text._DNS_Send_Query%249:

0000e210 <_DNS_Send_Query>:
{
    e210:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e214:	b089      	sub	sp, #36	; 0x24
    e216:	4680      	mov	r8, r0
    e218:	460c      	mov	r4, r1
    UDP_SOCKET          dnsSocket = pDnsDcpt->dnsSocket;
    e21a:	f9b0 6024 	ldrsh.w	r6, [r0, #36]	; 0x24
    pDnsHE->hEntry.flags.value &= ~TCPIP_DNS_FLAG_ENTRY_COMPLETE;
    e21e:	880b      	ldrh	r3, [r1, #0]
    e220:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    e224:	800b      	strh	r3, [r1, #0]
        int oldServerIx = pDnsHE->currServerIx; // store the previously used DNS server index
    e226:	f891 5029 	ldrb.w	r5, [r1, #41]	; 0x29
        TCPIP_NET_IF* oldIf = pDnsHE->currNet;
    e22a:	f8d1 901c 	ldr.w	r9, [r1, #28]
    if(pDnsDcpt->strictNet != 0)
    e22e:	6840      	ldr	r0, [r0, #4]
    e230:	2800      	cmp	r0, #0
    e232:	d065      	beq.n	e300 <_DNS_Send_Query+0xf0>
        return _DNS_ValidateIf(pDnsDcpt->strictNet, pDnsHE, true);
    e234:	2201      	movs	r2, #1
    e236:	f00c fd2a 	bl	1ac8e <_DNS_ValidateIf>
        if(!_DNS_SelectIntf(pDnsDcpt, pDnsHE))
    e23a:	2800      	cmp	r0, #0
    e23c:	d05e      	beq.n	e2fc <_DNS_Send_Query+0xec>
        if(oldIf == 0)
    e23e:	f1b9 0f00 	cmp.w	r9, #0
    e242:	f000 80af 	beq.w	e3a4 <_DNS_Send_Query+0x194>
        if(pDnsHE->currServerIx != oldServerIx || pDnsHE->currNet != oldIf )
    e246:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
    e24a:	42ab      	cmp	r3, r5
    e24c:	f000 80b2 	beq.w	e3b4 <_DNS_Send_Query+0x1a4>
            IPV4_ADDR oldDns = oldIf->dnsServer[oldServerIx];
    e250:	3504      	adds	r5, #4
    e252:	f859 3025 	ldr.w	r3, [r9, r5, lsl #2]
    e256:	9300      	str	r3, [sp, #0]
            if(oldDns.Val != 0)
    e258:	2b00      	cmp	r3, #0
    e25a:	f040 80b0 	bne.w	e3be <_DNS_Send_Query+0x1ae>
        if(!TCPIP_UDP_PutIsReady(dnsSocket))
    e25e:	4630      	mov	r0, r6
    e260:	f010 fa49 	bl	1e6f6 <TCPIP_UDP_PutIsReady>
    e264:	2800      	cmp	r0, #0
    e266:	f000 80af 	beq.w	e3c8 <_DNS_Send_Query+0x1b8>
        TCPIP_UDP_TxOffsetSet(dnsSocket, 0, false);    
    e26a:	2200      	movs	r2, #0
    e26c:	4611      	mov	r1, r2
    e26e:	4630      	mov	r0, r6
    e270:	f011 fdf5 	bl	1fe5e <TCPIP_UDP_TxOffsetSet>
        wrPtr = TCPIP_UDP_TxPointerGet(dnsSocket);
    e274:	4630      	mov	r0, r6
    e276:	f015 f91a 	bl	234ae <TCPIP_UDP_TxPointerGet>
        if(wrPtr == 0)
    e27a:	4607      	mov	r7, r0
    e27c:	2800      	cmp	r0, #0
    e27e:	f000 80a6 	beq.w	e3ce <_DNS_Send_Query+0x1be>
        TCPIP_UDP_Bind(dnsSocket, IP_ADDRESS_TYPE_IPV4, 0, (IP_MULTI_ADDRESS*)&pDnsHE->currNet->netIPAddr);
    e282:	69e3      	ldr	r3, [r4, #28]
    e284:	3304      	adds	r3, #4
    e286:	2200      	movs	r2, #0
    e288:	2101      	movs	r1, #1
    e28a:	4630      	mov	r0, r6
    e28c:	f006 f88c 	bl	143a8 <TCPIP_UDP_Bind>
        dnsServerAdd.Val = pDnsHE->currNet->dnsServer[pDnsHE->currServerIx].Val;
    e290:	69e2      	ldr	r2, [r4, #28]
    e292:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
    e296:	3304      	adds	r3, #4
    e298:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e29c:	9304      	str	r3, [sp, #16]
        TCPIP_UDP_DestinationIPAddressSet(dnsSocket, pDnsDcpt->ipAddressType, (IP_MULTI_ADDRESS*)&dnsServerAdd);
    e29e:	aa04      	add	r2, sp, #16
    e2a0:	f898 1018 	ldrb.w	r1, [r8, #24]
    e2a4:	4630      	mov	r0, r6
    e2a6:	f010 fbed 	bl	1ea84 <TCPIP_UDP_DestinationIPAddressSet>
        TCPIP_UDP_DestinationPortSet(dnsSocket, TCPIP_DNS_SERVER_PORT);
    e2aa:	2135      	movs	r1, #53	; 0x35
    e2ac:	4630      	mov	r0, r6
    e2ae:	f014 fcf7 	bl	22ca0 <TCPIP_UDP_DestinationPortSet>
    e2b2:	f00e fc37 	bl	1cb24 <rand>
        pDnsHE->transactionId.Val = (uint16_t)SYS_RANDOM_PseudoGet();
    e2b6:	b283      	uxth	r3, r0
    e2b8:	84a3      	strh	r3, [r4, #36]	; 0x24
    e2ba:	0200      	lsls	r0, r0, #8
    e2bc:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    e2c0:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
    e2c4:	ea40 2013 	orr.w	r0, r0, r3, lsr #8
        DNSPutHeader.TransactionID.Val = TCPIP_Helper_htons(pDnsHE->transactionId.Val);
    e2c8:	f8ad 0014 	strh.w	r0, [sp, #20]
        DNSPutHeader.Flags.Val = TCPIP_Helper_htons(0x0100); // Standard query with recursion
    e2cc:	2301      	movs	r3, #1
    e2ce:	f8ad 3016 	strh.w	r3, [sp, #22]
        DNSPutHeader.Questions.Val = TCPIP_Helper_htons(0x0001); // questions
    e2d2:	f44f 7380 	mov.w	r3, #256	; 0x100
    e2d6:	f8ad 3018 	strh.w	r3, [sp, #24]
        DNSPutHeader.Answers.Val = DNSPutHeader.AuthoritativeRecords.Val = DNSPutHeader.AdditionalRecords.Val = 0;
    e2da:	2300      	movs	r3, #0
    e2dc:	f8ad 301e 	strh.w	r3, [sp, #30]
    e2e0:	f8ad 301c 	strh.w	r3, [sp, #28]
    e2e4:	f8ad 301a 	strh.w	r3, [sp, #26]
        memcpy(wrPtr, &DNSPutHeader, sizeof(TCPIP_DNS_HEADER));
    e2e8:	ab05      	add	r3, sp, #20
    e2ea:	cb07      	ldmia	r3!, {r0, r1, r2}
    e2ec:	6038      	str	r0, [r7, #0]
    e2ee:	6079      	str	r1, [r7, #4]
    e2f0:	60ba      	str	r2, [r7, #8]
        wrPtr += sizeof(TCPIP_DNS_HEADER);
    e2f2:	f107 050c 	add.w	r5, r7, #12
        _DNSPutString(&wrPtr, pDnsHE->pHostName);
    e2f6:	6a21      	ldr	r1, [r4, #32]
    rightPtr = string;
    e2f8:	4688      	mov	r8, r1
    e2fa:	e0b8      	b.n	e46e <_DNS_Send_Query+0x25e>
            res = TCPIP_DNS_RES_NO_INTERFACE;
    e2fc:	3807      	subs	r0, #7
    e2fe:	e09a      	b.n	e436 <_DNS_Send_Query+0x226>
    memset(dnsSelectIfs, 0, sizeof(dnsSelectIfs));
    e300:	2300      	movs	r3, #0
    e302:	9300      	str	r3, [sp, #0]
    e304:	9301      	str	r3, [sp, #4]
    e306:	9302      	str	r3, [sp, #8]
    e308:	9303      	str	r3, [sp, #12]
    _DNS_AddSelectionIf(pDnsDcpt->prefNet, dnsSelectIfs, sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs));
    e30a:	2204      	movs	r2, #4
    e30c:	4669      	mov	r1, sp
    e30e:	f8d8 0008 	ldr.w	r0, [r8, #8]
    e312:	f00e fb03 	bl	1c91c <_DNS_AddSelectionIf>
    _DNS_AddSelectionIf(pDnsHE->currNet, dnsSelectIfs, sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs));
    e316:	2204      	movs	r2, #4
    e318:	4669      	mov	r1, sp
    e31a:	69e0      	ldr	r0, [r4, #28]
    e31c:	f00e fafe 	bl	1c91c <_DNS_AddSelectionIf>
    _DNS_AddSelectionIf((TCPIP_NET_IF*)TCPIP_STACK_NetDefaultGet(), dnsSelectIfs, sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs));
    e320:	f015 ff84 	bl	2422c <TCPIP_STACK_NetDefaultGet>
    e324:	2204      	movs	r2, #4
    e326:	4669      	mov	r1, sp
    e328:	f00e faf8 	bl	1c91c <_DNS_AddSelectionIf>
    nIfs = TCPIP_STACK_NumberOfNetworksGet();
    e32c:	f015 ff84 	bl	24238 <TCPIP_STACK_NumberOfNetworksGet>
    for(ix = 0; ix < nIfs; ix++)
    e330:	f1b0 0a00 	subs.w	sl, r0, #0
    e334:	dd0d      	ble.n	e352 <_DNS_Send_Query+0x142>
    e336:	2700      	movs	r7, #0
       if(!_DNS_AddSelectionIf((TCPIP_NET_IF*)TCPIP_STACK_IndexToNet(ix), dnsSelectIfs, sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs)))
    e338:	f04f 0b04 	mov.w	fp, #4
    e33c:	4638      	mov	r0, r7
    e33e:	f013 fea1 	bl	22084 <TCPIP_STACK_IndexToNet>
    e342:	465a      	mov	r2, fp
    e344:	4669      	mov	r1, sp
    e346:	f00e fae9 	bl	1c91c <_DNS_AddSelectionIf>
    e34a:	b110      	cbz	r0, e352 <_DNS_Send_Query+0x142>
    for(ix = 0; ix < nIfs; ix++)
    e34c:	3701      	adds	r7, #1
    e34e:	45ba      	cmp	sl, r7
    e350:	d1f4      	bne.n	e33c <_DNS_Send_Query+0x12c>
    for(ix = 0; ix < sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs); ix++)
    e352:	46eb      	mov	fp, sp
    e354:	a904      	add	r1, sp, #16
    for(ix = 0; ix < nIfs; ix++)
    e356:	465b      	mov	r3, fp
    nIfs = 0;
    e358:	f04f 0a00 	mov.w	sl, #0
    e35c:	e001      	b.n	e362 <_DNS_Send_Query+0x152>
    for(ix = 0; ix < sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs); ix++)
    e35e:	428b      	cmp	r3, r1
    e360:	d006      	beq.n	e370 <_DNS_Send_Query+0x160>
        if(dnsSelectIfs[ix] != 0)
    e362:	f853 2b04 	ldr.w	r2, [r3], #4
    e366:	2a00      	cmp	r2, #0
    e368:	d0f9      	beq.n	e35e <_DNS_Send_Query+0x14e>
            nIfs++;
    e36a:	f10a 0a01 	add.w	sl, sl, #1
    e36e:	e7f6      	b.n	e35e <_DNS_Send_Query+0x14e>
    for(ix = 0; ix < sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs); ix++)
    e370:	2700      	movs	r7, #0
            if(_DNS_ValidateIf(pDnsIf, pDnsHE, (ix == nIfs - 1)))
    e372:	f10a 3aff 	add.w	sl, sl, #4294967295
    e376:	e002      	b.n	e37e <_DNS_Send_Query+0x16e>
    for(ix = 0; ix < sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs); ix++)
    e378:	3701      	adds	r7, #1
    e37a:	2f04      	cmp	r7, #4
    e37c:	d00d      	beq.n	e39a <_DNS_Send_Query+0x18a>
        if((pDnsIf = dnsSelectIfs[ix]) != 0)
    e37e:	f85b 0b04 	ldr.w	r0, [fp], #4
    e382:	2800      	cmp	r0, #0
    e384:	d0f8      	beq.n	e378 <_DNS_Send_Query+0x168>
            if(_DNS_ValidateIf(pDnsIf, pDnsHE, (ix == nIfs - 1)))
    e386:	45ba      	cmp	sl, r7
    e388:	bf14      	ite	ne
    e38a:	2200      	movne	r2, #0
    e38c:	2201      	moveq	r2, #1
    e38e:	4621      	mov	r1, r4
    e390:	f00c fc7d 	bl	1ac8e <_DNS_ValidateIf>
    e394:	2800      	cmp	r0, #0
    e396:	d0ef      	beq.n	e378 <_DNS_Send_Query+0x168>
    e398:	e751      	b.n	e23e <_DNS_Send_Query+0x2e>
    pDnsHE->currNet = 0;    // make sure next time we start with a fresh interface
    e39a:	2300      	movs	r3, #0
    e39c:	61e3      	str	r3, [r4, #28]
            res = TCPIP_DNS_RES_NO_INTERFACE;
    e39e:	f06f 0006 	mvn.w	r0, #6
    e3a2:	e048      	b.n	e436 <_DNS_Send_Query+0x226>
            oldIf = pDnsHE->currNet; 
    e3a4:	f8d4 901c 	ldr.w	r9, [r4, #28]
        if(pDnsHE->currServerIx != oldServerIx || pDnsHE->currNet != oldIf )
    e3a8:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
    e3ac:	42ab      	cmp	r3, r5
    e3ae:	f47f af4f 	bne.w	e250 <_DNS_Send_Query+0x40>
    e3b2:	e754      	b.n	e25e <_DNS_Send_Query+0x4e>
    e3b4:	69e3      	ldr	r3, [r4, #28]
    e3b6:	454b      	cmp	r3, r9
    e3b8:	f47f af4a 	bne.w	e250 <_DNS_Send_Query+0x40>
    e3bc:	e74f      	b.n	e25e <_DNS_Send_Query+0x4e>
                TCPIP_ARP_EntryRemove(oldIf, &oldDns);
    e3be:	4669      	mov	r1, sp
    e3c0:	4648      	mov	r0, r9
    e3c2:	f00d fc9b 	bl	1bcfc <TCPIP_ARP_EntryRemove>
                _DNS_DbgArpFlush(oldIf, oldServerIx, pDnsHE->currNet, pDnsHE->currServerIx, &oldDns);
    e3c6:	e74a      	b.n	e25e <_DNS_Send_Query+0x4e>
            res = TCPIP_DNS_RES_SOCKET_ERROR;
    e3c8:	f06f 0009 	mvn.w	r0, #9
    e3cc:	e033      	b.n	e436 <_DNS_Send_Query+0x226>
            res = TCPIP_DNS_RES_SOCKET_ERROR;
    e3ce:	f06f 0009 	mvn.w	r0, #9
    e3d2:	e030      	b.n	e436 <_DNS_Send_Query+0x226>
        len = rightPtr - string - 1;
    e3d4:	eba8 0801 	sub.w	r8, r8, r1
    e3d8:	f108 38ff 	add.w	r8, r8, #4294967295
        *pPutDnsStr++ = (uint8_t)len;
    e3dc:	f805 8b01 	strb.w	r8, [r5], #1
        memcpy(pPutDnsStr, string, len);
    e3e0:	4642      	mov	r2, r8
    e3e2:	4628      	mov	r0, r5
    e3e4:	f014 ff82 	bl	232ec <memcpy>
        pPutDnsStr = pPutDnsStr + len;
    e3e8:	eb05 0008 	add.w	r0, r5, r8
        if(i == 0 || i == '/' || i == ',' || i == '>')
    e3ec:	e00b      	b.n	e406 <_DNS_Send_Query+0x1f6>
        len = rightPtr - string - 1;
    e3ee:	eba8 0801 	sub.w	r8, r8, r1
    e3f2:	f108 38ff 	add.w	r8, r8, #4294967295
        *pPutDnsStr++ = (uint8_t)len;
    e3f6:	f805 8b01 	strb.w	r8, [r5], #1
        memcpy(pPutDnsStr, string, len);
    e3fa:	4642      	mov	r2, r8
    e3fc:	4628      	mov	r0, r5
    e3fe:	f014 ff75 	bl	232ec <memcpy>
        pPutDnsStr = pPutDnsStr + len;
    e402:	eb05 0008 	add.w	r0, r5, r8
    *pPutDnsStr++ = 0;
    e406:	2200      	movs	r2, #0
    e408:	7002      	strb	r2, [r0, #0]
        *wrPtr++ = 0x00;
    e40a:	7042      	strb	r2, [r0, #1]
        *wrPtr++ = pDnsHE->resolve_type;
    e40c:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
    e410:	7083      	strb	r3, [r0, #2]
        *wrPtr++ = 0x00;
    e412:	70c2      	strb	r2, [r0, #3]
        *wrPtr++ = 0x01; // 0x0001
    e414:	2301      	movs	r3, #1
    e416:	7103      	strb	r3, [r0, #4]
    e418:	1d44      	adds	r4, r0, #5
        sktPayload = (uint16_t)(wrPtr - startPtr);
    e41a:	1be4      	subs	r4, r4, r7
    e41c:	b2a4      	uxth	r4, r4
        TCPIP_UDP_TxOffsetSet(dnsSocket, sktPayload, false);
    e41e:	4621      	mov	r1, r4
    e420:	4630      	mov	r0, r6
    e422:	f011 fd1c 	bl	1fe5e <TCPIP_UDP_TxOffsetSet>
        if(TCPIP_UDP_Flush(dnsSocket) != sktPayload)
    e426:	4630      	mov	r0, r6
    e428:	f001 f986 	bl	f738 <TCPIP_UDP_Flush>
            res = TCPIP_DNS_RES_PENDING;
    e42c:	42a0      	cmp	r0, r4
    e42e:	bf14      	ite	ne
    e430:	f06f 0009 	mvnne.w	r0, #9
    e434:	2001      	moveq	r0, #1
}
    e436:	b009      	add	sp, #36	; 0x24
    e438:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        len = rightPtr - string - 1;
    e43c:	eba8 0801 	sub.w	r8, r8, r1
    e440:	f108 38ff 	add.w	r8, r8, #4294967295
        *pPutDnsStr++ = (uint8_t)len;
    e444:	f805 8b01 	strb.w	r8, [r5], #1
        memcpy(pPutDnsStr, string, len);
    e448:	4642      	mov	r2, r8
    e44a:	4628      	mov	r0, r5
    e44c:	f014 ff4e 	bl	232ec <memcpy>
        pPutDnsStr = pPutDnsStr + len;
    e450:	eb05 0008 	add.w	r0, r5, r8
        if(i == 0 || i == '/' || i == ',' || i == '>')
    e454:	e7d7      	b.n	e406 <_DNS_Send_Query+0x1f6>
        len = rightPtr - string - 1;
    e456:	eba8 0901 	sub.w	r9, r8, r1
    e45a:	f109 39ff 	add.w	r9, r9, #4294967295
        *pPutDnsStr++ = (uint8_t)len;
    e45e:	f805 9b01 	strb.w	r9, [r5], #1
        memcpy(pPutDnsStr, string, len);
    e462:	464a      	mov	r2, r9
    e464:	4628      	mov	r0, r5
    e466:	f014 ff41 	bl	232ec <memcpy>
        pPutDnsStr = pPutDnsStr + len;
    e46a:	444d      	add	r5, r9
            i = *rightPtr++;
    e46c:	4641      	mov	r1, r8
    e46e:	f818 3b01 	ldrb.w	r3, [r8], #1
        }while((i != 0) && (i != '.') && (i != '/') && (i != ',') && (i != '>'));
    e472:	2b00      	cmp	r3, #0
    e474:	d0bb      	beq.n	e3ee <_DNS_Send_Query+0x1de>
    e476:	2b2e      	cmp	r3, #46	; 0x2e
    e478:	d0ed      	beq.n	e456 <_DNS_Send_Query+0x246>
    e47a:	2b2f      	cmp	r3, #47	; 0x2f
    e47c:	d0de      	beq.n	e43c <_DNS_Send_Query+0x22c>
    e47e:	2b2c      	cmp	r3, #44	; 0x2c
    e480:	d0a8      	beq.n	e3d4 <_DNS_Send_Query+0x1c4>
    e482:	2b3e      	cmp	r3, #62	; 0x3e
    e484:	d1f3      	bne.n	e46e <_DNS_Send_Query+0x25e>
        len = rightPtr - string - 1;
    e486:	eba8 0801 	sub.w	r8, r8, r1
    e48a:	f108 38ff 	add.w	r8, r8, #4294967295
        *pPutDnsStr++ = (uint8_t)len;
    e48e:	f805 8b01 	strb.w	r8, [r5], #1
        memcpy(pPutDnsStr, string, len);
    e492:	4642      	mov	r2, r8
    e494:	4628      	mov	r0, r5
    e496:	f014 ff29 	bl	232ec <memcpy>
        pPutDnsStr = pPutDnsStr + len;
    e49a:	eb05 0008 	add.w	r0, r5, r8
        if(i == 0 || i == '/' || i == ',' || i == '>')
    e49e:	e7b2      	b.n	e406 <_DNS_Send_Query+0x1f6>

Disassembly of section .text.ReportBW_Jitter_Loss%250:

0000e4a0 <ReportBW_Jitter_Loss>:
{
    e4a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e4a4:	b087      	sub	sp, #28
    e4a6:	4604      	mov	r4, r0
    e4a8:	460d      	mov	r5, r1
    uint32_t tickFreq = SYS_TMR_TickCounterFrequencyGet(); 
    e4aa:	f013 feef 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
    e4ae:	4607      	mov	r7, r0
    currentTime = SYS_TMR_TickCountGet();
    e4b0:	f013 fec4 	bl	2223c <SYS_TMR_TickCountGet>
    e4b4:	4606      	mov	r6, r0
    cmdIoParam = pIState->pCmdIO->cmdIoParam;
    e4b6:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    e4ba:	f8d3 9004 	ldr.w	r9, [r3, #4]
    switch ( reportType )
    e4be:	2d00      	cmp	r5, #0
    e4c0:	f000 809a 	beq.w	e5f8 <ReportBW_Jitter_Loss+0x158>
    e4c4:	2d02      	cmp	r5, #2
    e4c6:	d86d      	bhi.n	e5a4 <ReportBW_Jitter_Loss+0x104>
           nDropped = pIState->errorCount;
    e4c8:	f8d4 a030 	ldr.w	sl, [r4, #48]	; 0x30
           if (pIState->state == (uint8_t)IPERF_UDP_TX_DONE_STATE)
    e4cc:	f894 30ce 	ldrb.w	r3, [r4, #206]	; 0xce
    e4d0:	2b12      	cmp	r3, #18
               nAttempted = pIState->lastPktId + nDropped;
    e4d2:	bf06      	itte	eq
    e4d4:	6ae3      	ldreq	r3, [r4, #44]	; 0x2c
    e4d6:	eb0a 0803 	addeq.w	r8, sl, r3
                nAttempted = pIState->lastPktId;
    e4da:	f8d4 802c 	ldrne.w	r8, [r4, #44]	; 0x2c
			msec = (uint32_t)(((double) (pIState->stopTime - pIState->startTime)) / (((double)(tickFreq))/1000));
    e4de:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
    e4e2:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    e4e6:	1ac0      	subs	r0, r0, r3
    e4e8:	f7fd fad2 	bl	ba90 <__aeabi_ui2d>
    e4ec:	e9cd 0104 	strd	r0, r1, [sp, #16]
    e4f0:	4638      	mov	r0, r7
    e4f2:	f7fd facd 	bl	ba90 <__aeabi_ui2d>
    e4f6:	2200      	movs	r2, #0
    e4f8:	4b7f      	ldr	r3, [pc, #508]	; (e6f8 <ReportBW_Jitter_Loss+0x258>)
    e4fa:	f7fb ff11 	bl	a320 <__aeabi_ddiv>
    e4fe:	4602      	mov	r2, r0
    e500:	460b      	mov	r3, r1
    e502:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    e506:	f7fb ff0b 	bl	a320 <__aeabi_ddiv>
    e50a:	f011 fbeb 	bl	1fce4 <__aeabi_d2uiz>
			if ( msec == 0u )
    e50e:	4607      	mov	r7, r0
    e510:	2800      	cmp	r0, #0
    e512:	f000 80eb 	beq.w	e6ec <ReportBW_Jitter_Loss+0x24c>
   				kbps = (pIState->totalLen * ((double) 8)) / msec;
    e516:	2200      	movs	r2, #0
    e518:	4b78      	ldr	r3, [pc, #480]	; (e6fc <ReportBW_Jitter_Loss+0x25c>)
    e51a:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    e51e:	f7fb fdd5 	bl	a0cc <__aeabi_dmul>
    e522:	e9cd 0104 	strd	r0, r1, [sp, #16]
    e526:	4638      	mov	r0, r7
    e528:	f7fd fab2 	bl	ba90 <__aeabi_ui2d>
    e52c:	4602      	mov	r2, r0
    e52e:	460b      	mov	r3, r1
    e530:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    e534:	f7fb fef4 	bl	a320 <__aeabi_ddiv>
            gfx_mono_print_scroll("AVG: %4lu Kbps",(unsigned long) (kbps + ((double) 0.5)));
    e538:	2200      	movs	r2, #0
    e53a:	4b71      	ldr	r3, [pc, #452]	; (e700 <ReportBW_Jitter_Loss+0x260>)
    e53c:	f7fd f96c 	bl	b818 <__adddf3>
    e540:	f011 fbd0 	bl	1fce4 <__aeabi_d2uiz>
    e544:	4601      	mov	r1, r0
    e546:	9004      	str	r0, [sp, #16]
    e548:	f8df b1d4 	ldr.w	fp, [pc, #468]	; e720 <ReportBW_Jitter_Loss+0x280>
    e54c:	f20b 40a4 	addw	r0, fp, #1188	; 0x4a4
    e550:	f00c fb1a 	bl	1ab88 <gfx_mono_print_scroll>
            gfx_mono_print_scroll("iperf done");
    e554:	f20b 40b4 	addw	r0, fp, #1204	; 0x4b4
    e558:	f00c fb16 	bl	1ab88 <gfx_mono_print_scroll>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [0.0- %lu.%lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    e55c:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    e560:	681b      	ldr	r3, [r3, #0]
    e562:	f8d3 b004 	ldr.w	fp, [r3, #4]
    e566:	4a67      	ldr	r2, [pc, #412]	; (e704 <ReportBW_Jitter_Loss+0x264>)
    e568:	fba2 3207 	umull	r3, r2, r2, r7
    e56c:	0992      	lsrs	r2, r2, #6
                             (unsigned long)((msec%1000)/100),
    e56e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    e572:	fb03 7312 	mls	r3, r3, r2, r7
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [0.0- %lu.%lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    e576:	4f64      	ldr	r7, [pc, #400]	; (e708 <ReportBW_Jitter_Loss+0x268>)
    e578:	fba7 1303 	umull	r1, r3, r7, r3
    e57c:	095b      	lsrs	r3, r3, #5
    e57e:	f1b8 0f00 	cmp.w	r8, #0
    e582:	f000 80b6 	beq.w	e6f2 <ReportBW_Jitter_Loss+0x252>
                             (nAttempted == 0u) ? 0 : ((unsigned long)nDropped*100/(unsigned long)nAttempted),
    e586:	2164      	movs	r1, #100	; 0x64
    e588:	fb01 f10a 	mul.w	r1, r1, sl
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [0.0- %lu.%lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    e58c:	fbb1 f1f8 	udiv	r1, r1, r8
    e590:	9804      	ldr	r0, [sp, #16]
    e592:	9003      	str	r0, [sp, #12]
    e594:	9102      	str	r1, [sp, #8]
    e596:	f8cd 8004 	str.w	r8, [sp, #4]
    e59a:	f8cd a000 	str.w	sl, [sp]
    e59e:	495b      	ldr	r1, [pc, #364]	; (e70c <ReportBW_Jitter_Loss+0x26c>)
    e5a0:	4648      	mov	r0, r9
    e5a2:	47d8      	blx	fp
    if ( reportType == 	SESSION_REPORT )
    e5a4:	2d02      	cmp	r5, #2
    e5a6:	d112      	bne.n	e5ce <ReportBW_Jitter_Loss+0x12e>
      (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf: instance %d completed\n\r", pIState - gIperfState);
    e5a8:	4a59      	ldr	r2, [pc, #356]	; (e710 <ReportBW_Jitter_Loss+0x270>)
    e5aa:	1aa2      	subs	r2, r4, r2
    e5ac:	10d2      	asrs	r2, r2, #3
    e5ae:	eb02 03c2 	add.w	r3, r2, r2, lsl #3
    e5b2:	eb02 0243 	add.w	r2, r2, r3, lsl #1
    e5b6:	ebc2 2242 	rsb	r2, r2, r2, lsl #9
    e5ba:	eb02 4282 	add.w	r2, r2, r2, lsl #18
    e5be:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    e5c2:	681b      	ldr	r3, [r3, #0]
    e5c4:	685b      	ldr	r3, [r3, #4]
    e5c6:	4252      	negs	r2, r2
    e5c8:	4952      	ldr	r1, [pc, #328]	; (e714 <ReportBW_Jitter_Loss+0x274>)
    e5ca:	4648      	mov	r0, r9
    e5cc:	4798      	blx	r3
    pIState->lastCheckPktId = pIState->pktId;
    e5ce:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    e5d0:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
    pIState->lastCheckErrorCount = pIState->errorCount;
    e5d4:	6b23      	ldr	r3, [r4, #48]	; 0x30
    e5d6:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
    pIState->lastCheckPktCount = pIState->pktCount;
    e5da:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    e5de:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
    pIState->lastCheckTime = currentTime;
    e5e2:	f8c4 60a8 	str.w	r6, [r4, #168]	; 0xa8
    pIState->lastCheckTotalLen = (uint32_t)pIState->totalLen;
    e5e6:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    e5ea:	f011 fb7b 	bl	1fce4 <__aeabi_d2uiz>
    e5ee:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4
}
    e5f2:	b007      	add	sp, #28
    e5f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            nDropped = pIState->errorCount - pIState->lastCheckErrorCount;
    e5f8:	6b22      	ldr	r2, [r4, #48]	; 0x30
    e5fa:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    e5fe:	eba2 0a03 	sub.w	sl, r2, r3
            sec = (currentTime- pIState->lastCheckTime) / tickFreq;
    e602:	f8d4 50a8 	ldr.w	r5, [r4, #168]	; 0xa8
			msec = (uint32_t)(((double) (currentTime - pIState->lastCheckTime)) / (((double)(tickFreq))/1000));
    e606:	1b40      	subs	r0, r0, r5
    e608:	f7fd fa42 	bl	ba90 <__aeabi_ui2d>
    e60c:	e9cd 0104 	strd	r0, r1, [sp, #16]
    e610:	4638      	mov	r0, r7
    e612:	f7fd fa3d 	bl	ba90 <__aeabi_ui2d>
    e616:	2200      	movs	r2, #0
    e618:	4b37      	ldr	r3, [pc, #220]	; (e6f8 <ReportBW_Jitter_Loss+0x258>)
    e61a:	f7fb fe81 	bl	a320 <__aeabi_ddiv>
    e61e:	4602      	mov	r2, r0
    e620:	460b      	mov	r3, r1
    e622:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    e626:	f7fb fe7b 	bl	a320 <__aeabi_ddiv>
    e62a:	f011 fb5b 	bl	1fce4 <__aeabi_d2uiz>
    e62e:	4683      	mov	fp, r0
            if ( pIState->state == (uint8_t)IPERF_UDP_TX_DONE_STATE )
    e630:	f894 30ce 	ldrb.w	r3, [r4, #206]	; 0xce
    e634:	2b12      	cmp	r3, #18
    e636:	d04d      	beq.n	e6d4 <ReportBW_Jitter_Loss+0x234>
                nAttempted = pIState->pktId - pIState->lastCheckPktId;
    e638:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    e63a:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
    e63e:	eba2 0803 	sub.w	r8, r2, r3
			if ( msec == 0u )
    e642:	f1bb 0f00 	cmp.w	fp, #0
    e646:	d04c      	beq.n	e6e2 <ReportBW_Jitter_Loss+0x242>
				kbps = ((pIState->totalLen - pIState->lastCheckTotalLen)*((double) 8)) / msec;
    e648:	f8d4 00a4 	ldr.w	r0, [r4, #164]	; 0xa4
    e64c:	f7fd fa20 	bl	ba90 <__aeabi_ui2d>
    e650:	4602      	mov	r2, r0
    e652:	460b      	mov	r3, r1
    e654:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    e658:	f7fd f8dc 	bl	b814 <__aeabi_dsub>
    e65c:	2200      	movs	r2, #0
    e65e:	4b27      	ldr	r3, [pc, #156]	; (e6fc <ReportBW_Jitter_Loss+0x25c>)
    e660:	f7fb fd34 	bl	a0cc <__aeabi_dmul>
    e664:	e9cd 0104 	strd	r0, r1, [sp, #16]
    e668:	4658      	mov	r0, fp
    e66a:	f7fd fa11 	bl	ba90 <__aeabi_ui2d>
    e66e:	4602      	mov	r2, r0
    e670:	460b      	mov	r3, r1
    e672:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    e676:	f7fb fe53 	bl	a320 <__aeabi_ddiv>
            sec = (pIState->lastCheckTime - pIState->startTime) / tickFreq;
    e67a:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    e67e:	1aed      	subs	r5, r5, r3
    e680:	fbb5 f5f7 	udiv	r5, r5, r7
            gfx_mono_print_scroll("%4lu Kbps",(unsigned long) (kbps + ((double) 0.5)));
    e684:	2200      	movs	r2, #0
    e686:	4b1e      	ldr	r3, [pc, #120]	; (e700 <ReportBW_Jitter_Loss+0x260>)
    e688:	f7fd f8c6 	bl	b818 <__adddf3>
    e68c:	f011 fb2a 	bl	1fce4 <__aeabi_d2uiz>
    e690:	4601      	mov	r1, r0
    e692:	9004      	str	r0, [sp, #16]
    e694:	4820      	ldr	r0, [pc, #128]	; (e718 <ReportBW_Jitter_Loss+0x278>)
    e696:	f00c fa77 	bl	1ab88 <gfx_mono_print_scroll>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [%2lu- %2lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    e69a:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    e69e:	681b      	ldr	r3, [r3, #0]
    e6a0:	f8d3 b004 	ldr.w	fp, [r3, #4]
                      (unsigned long)sec + ( (unsigned long) (pIState->mInterval / tickFreq) ),
    e6a4:	6823      	ldr	r3, [r4, #0]
    e6a6:	fbb3 f3f7 	udiv	r3, r3, r7
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [%2lu- %2lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    e6aa:	442b      	add	r3, r5
    e6ac:	f1b8 0f00 	cmp.w	r8, #0
    e6b0:	d01a      	beq.n	e6e8 <ReportBW_Jitter_Loss+0x248>
                      (nAttempted == 0u) ? 0 : ((unsigned long)nDropped*100/(unsigned long)nAttempted),
    e6b2:	2264      	movs	r2, #100	; 0x64
    e6b4:	fb02 f20a 	mul.w	r2, r2, sl
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [%2lu- %2lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    e6b8:	fbb2 f2f8 	udiv	r2, r2, r8
    e6bc:	9904      	ldr	r1, [sp, #16]
    e6be:	9103      	str	r1, [sp, #12]
    e6c0:	9202      	str	r2, [sp, #8]
    e6c2:	f8cd 8004 	str.w	r8, [sp, #4]
    e6c6:	f8cd a000 	str.w	sl, [sp]
    e6ca:	462a      	mov	r2, r5
    e6cc:	4913      	ldr	r1, [pc, #76]	; (e71c <ReportBW_Jitter_Loss+0x27c>)
    e6ce:	4648      	mov	r0, r9
    e6d0:	47d8      	blx	fp
    if ( reportType == 	SESSION_REPORT )
    e6d2:	e77c      	b.n	e5ce <ReportBW_Jitter_Loss+0x12e>
               nAttempted = (pIState->lastPktId - pIState->lastCheckPktId) + nDropped;
    e6d4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    e6d6:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
    e6da:	1a9b      	subs	r3, r3, r2
    e6dc:	eb03 080a 	add.w	r8, r3, sl
    e6e0:	e7af      	b.n	e642 <ReportBW_Jitter_Loss+0x1a2>
                kbps = 0;
    e6e2:	2000      	movs	r0, #0
    e6e4:	2100      	movs	r1, #0
    e6e6:	e7c8      	b.n	e67a <ReportBW_Jitter_Loss+0x1da>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [%2lu- %2lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    e6e8:	4642      	mov	r2, r8
    e6ea:	e7e7      	b.n	e6bc <ReportBW_Jitter_Loss+0x21c>
                kbps = 0;
    e6ec:	2000      	movs	r0, #0
    e6ee:	2100      	movs	r1, #0
    e6f0:	e722      	b.n	e538 <ReportBW_Jitter_Loss+0x98>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [0.0- %lu.%lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    e6f2:	4641      	mov	r1, r8
    e6f4:	e74c      	b.n	e590 <ReportBW_Jitter_Loss+0xf0>
    e6f6:	bf00      	nop
    e6f8:	408f4000 	.word	0x408f4000
    e6fc:	40200000 	.word	0x40200000
    e700:	3fe00000 	.word	0x3fe00000
    e704:	10624dd3 	.word	0x10624dd3
    e708:	51eb851f 	.word	0x51eb851f
    e70c:	00005fbc 	.word	0x00005fbc
    e710:	2000e380 	.word	0x2000e380
    e714:	00005ff8 	.word	0x00005ff8
    e718:	00005f58 	.word	0x00005f58
    e71c:	00005f64 	.word	0x00005f64
    e720:	00005afc 	.word	0x00005afc

Disassembly of section .text._CommandDhcpOptions%251:

0000e724 <_CommandDhcpOptions>:
{
    e724:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    e728:	b096      	sub	sp, #88	; 0x58
    e72a:	4604      	mov	r4, r0
    e72c:	4615      	mov	r5, r2
    const void* cmdIoParam = pCmdIO->cmdIoParam;
    e72e:	6846      	ldr	r6, [r0, #4]
    if (argc < 3)
    e730:	2902      	cmp	r1, #2
    e732:	dc10      	bgt.n	e756 <_CommandDhcpOptions+0x32>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Usage: %s <interface> <on/off/renew/request/info> \r\n", argv[0]);
    e734:	6803      	ldr	r3, [r0, #0]
    e736:	685b      	ldr	r3, [r3, #4]
    e738:	6812      	ldr	r2, [r2, #0]
    e73a:	4981      	ldr	r1, [pc, #516]	; (e940 <_CommandDhcpOptions+0x21c>)
    e73c:	4630      	mov	r0, r6
    e73e:	4798      	blx	r3
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Ex: %s PIC32INT on \r\n", argv[0]);
    e740:	6823      	ldr	r3, [r4, #0]
    e742:	685b      	ldr	r3, [r3, #4]
    e744:	682a      	ldr	r2, [r5, #0]
    e746:	497f      	ldr	r1, [pc, #508]	; (e944 <_CommandDhcpOptions+0x220>)
    e748:	4630      	mov	r0, r6
    e74a:	4798      	blx	r3
        return false;
    e74c:	2700      	movs	r7, #0
}
    e74e:	4638      	mov	r0, r7
    e750:	b016      	add	sp, #88	; 0x58
    e752:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    e756:	4688      	mov	r8, r1
    reqIpAddr.Val = 0;
    e758:	2300      	movs	r3, #0
    e75a:	9315      	str	r3, [sp, #84]	; 0x54
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
    e75c:	6850      	ldr	r0, [r2, #4]
    e75e:	f011 f981 	bl	1fa64 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
    e762:	4682      	mov	sl, r0
    e764:	b328      	cbz	r0, e7b2 <_CommandDhcpOptions+0x8e>
    if (strcmp(argv[2], "on") == 0)
    e766:	f8d5 9008 	ldr.w	r9, [r5, #8]
    e76a:	4977      	ldr	r1, [pc, #476]	; (e948 <_CommandDhcpOptions+0x224>)
    e76c:	4648      	mov	r0, r9
    e76e:	f015 fa45 	bl	23bfc <strcmp>
    e772:	2800      	cmp	r0, #0
    e774:	f000 80c3 	beq.w	e8fe <_CommandDhcpOptions+0x1da>
    else if (strcmp(argv[2], "off") == 0)
    e778:	4974      	ldr	r1, [pc, #464]	; (e94c <_CommandDhcpOptions+0x228>)
    e77a:	4648      	mov	r0, r9
    e77c:	f015 fa3e 	bl	23bfc <strcmp>
    e780:	2800      	cmp	r0, #0
    e782:	f000 80d8 	beq.w	e936 <_CommandDhcpOptions+0x212>
    else if (strcmp(argv[2], "renew") == 0)
    e786:	4972      	ldr	r1, [pc, #456]	; (e950 <_CommandDhcpOptions+0x22c>)
    e788:	4648      	mov	r0, r9
    e78a:	f015 fa37 	bl	23bfc <strcmp>
    e78e:	2800      	cmp	r0, #0
    e790:	f000 80cd 	beq.w	e92e <_CommandDhcpOptions+0x20a>
    else if (strcmp(argv[2], "request") == 0)
    e794:	496f      	ldr	r1, [pc, #444]	; (e954 <_CommandDhcpOptions+0x230>)
    e796:	4648      	mov	r0, r9
    e798:	f015 fa30 	bl	23bfc <strcmp>
    e79c:	4607      	mov	r7, r0
    e79e:	b9e0      	cbnz	r0, e7da <_CommandDhcpOptions+0xb6>
        if(argc < 4)
    e7a0:	f1b8 0f03 	cmp.w	r8, #3
    e7a4:	dc0c      	bgt.n	e7c0 <_CommandDhcpOptions+0x9c>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Request needs an IP address\r\n");
    e7a6:	6823      	ldr	r3, [r4, #0]
    e7a8:	681b      	ldr	r3, [r3, #0]
    e7aa:	496b      	ldr	r1, [pc, #428]	; (e958 <_CommandDhcpOptions+0x234>)
    e7ac:	4630      	mov	r0, r6
    e7ae:	4798      	blx	r3
            return false;
    e7b0:	e7cd      	b.n	e74e <_CommandDhcpOptions+0x2a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface\r\n");
    e7b2:	6823      	ldr	r3, [r4, #0]
    e7b4:	681b      	ldr	r3, [r3, #0]
    e7b6:	4969      	ldr	r1, [pc, #420]	; (e95c <_CommandDhcpOptions+0x238>)
    e7b8:	4630      	mov	r0, r6
    e7ba:	4798      	blx	r3
        return false;
    e7bc:	2700      	movs	r7, #0
    e7be:	e7c6      	b.n	e74e <_CommandDhcpOptions+0x2a>
        if (!TCPIP_Helper_StringToIPAddress(argv[3], &reqIpAddr))
    e7c0:	a915      	add	r1, sp, #84	; 0x54
    e7c2:	68e8      	ldr	r0, [r5, #12]
    e7c4:	f006 f954 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
    e7c8:	2800      	cmp	r0, #0
    e7ca:	f040 80ab 	bne.w	e924 <_CommandDhcpOptions+0x200>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Invalid IP address string \r\n");
    e7ce:	6823      	ldr	r3, [r4, #0]
    e7d0:	681b      	ldr	r3, [r3, #0]
    e7d2:	4963      	ldr	r1, [pc, #396]	; (e960 <_CommandDhcpOptions+0x23c>)
    e7d4:	4630      	mov	r0, r6
    e7d6:	4798      	blx	r3
            return false;
    e7d8:	e7b9      	b.n	e74e <_CommandDhcpOptions+0x2a>
    else if (strcmp(argv[2], "info") == 0)
    e7da:	4962      	ldr	r1, [pc, #392]	; (e964 <_CommandDhcpOptions+0x240>)
    e7dc:	4648      	mov	r0, r9
    e7de:	f015 fa0d 	bl	23bfc <strcmp>
    e7e2:	4607      	mov	r7, r0
    e7e4:	b130      	cbz	r0, e7f4 <_CommandDhcpOptions+0xd0>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown option\r\n");
    e7e6:	6823      	ldr	r3, [r4, #0]
    e7e8:	681b      	ldr	r3, [r3, #0]
    e7ea:	495f      	ldr	r1, [pc, #380]	; (e968 <_CommandDhcpOptions+0x244>)
    e7ec:	4630      	mov	r0, r6
    e7ee:	4798      	blx	r3
        return false;
    e7f0:	2700      	movs	r7, #0
    e7f2:	e7ac      	b.n	e74e <_CommandDhcpOptions+0x2a>
        if(TCPIP_DHCP_InfoGet(netH, &dhcpInfo))
    e7f4:	a908      	add	r1, sp, #32
    e7f6:	4650      	mov	r0, sl
    e7f8:	f00b fa96 	bl	19d28 <TCPIP_DHCP_InfoGet>
    e7fc:	2800      	cmp	r0, #0
    e7fe:	d078      	beq.n	e8f2 <_CommandDhcpOptions+0x1ce>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP status: %d ( %d == Bound), time: %d\r\n", dhcpInfo.status, TCPIP_DHCP_BOUND, dhcpInfo.dhcpTime);
    e800:	6823      	ldr	r3, [r4, #0]
    e802:	9a09      	ldr	r2, [sp, #36]	; 0x24
    e804:	9200      	str	r2, [sp, #0]
    e806:	685d      	ldr	r5, [r3, #4]
    e808:	2308      	movs	r3, #8
    e80a:	f89d 2020 	ldrb.w	r2, [sp, #32]
    e80e:	4957      	ldr	r1, [pc, #348]	; (e96c <_CommandDhcpOptions+0x248>)
    e810:	4630      	mov	r0, r6
    e812:	47a8      	blx	r5
            if(dhcpInfo.status >= TCPIP_DHCP_BOUND)
    e814:	f89d 3020 	ldrb.w	r3, [sp, #32]
    e818:	2b07      	cmp	r3, #7
    e81a:	d998      	bls.n	e74e <_CommandDhcpOptions+0x2a>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP lease start: %d, duration: %ds\r\n", dhcpInfo.leaseStartTime, dhcpInfo.leaseDuration);
    e81c:	4d54      	ldr	r5, [pc, #336]	; (e970 <_CommandDhcpOptions+0x24c>)
    e81e:	6823      	ldr	r3, [r4, #0]
    e820:	f8d3 8004 	ldr.w	r8, [r3, #4]
    e824:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    e826:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    e828:	f1a5 011c 	sub.w	r1, r5, #28
    e82c:	4630      	mov	r0, r6
    e82e:	47c0      	blx	r8
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP renew time: %d, rebind time: %d\r\n", dhcpInfo.renewTime, dhcpInfo.rebindTime);
    e830:	6823      	ldr	r3, [r4, #0]
    e832:	f8d3 8004 	ldr.w	r8, [r3, #4]
    e836:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    e838:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    e83a:	f105 010c 	add.w	r1, r5, #12
    e83e:	4630      	mov	r0, r6
    e840:	47c0      	blx	r8
                TCPIP_Helper_IPAddressToString(&dhcpInfo.dhcpAddress, addBuff, sizeof(addBuff));
    e842:	2214      	movs	r2, #20
    e844:	a903      	add	r1, sp, #12
    e846:	a80e      	add	r0, sp, #56	; 0x38
    e848:	f010 f814 	bl	1e874 <TCPIP_Helper_IPAddressToString>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP address: %s\r\n", addBuff);
    e84c:	6823      	ldr	r3, [r4, #0]
    e84e:	685b      	ldr	r3, [r3, #4]
    e850:	aa03      	add	r2, sp, #12
    e852:	f105 0134 	add.w	r1, r5, #52	; 0x34
    e856:	4630      	mov	r0, r6
    e858:	4798      	blx	r3
                TCPIP_Helper_IPAddressToString(&dhcpInfo.serverAddress, addBuff, sizeof(addBuff));
    e85a:	2214      	movs	r2, #20
    e85c:	a903      	add	r1, sp, #12
    e85e:	a810      	add	r0, sp, #64	; 0x40
    e860:	f010 f808 	bl	1e874 <TCPIP_Helper_IPAddressToString>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP server: %s\r\n", addBuff);
    e864:	6823      	ldr	r3, [r4, #0]
    e866:	685b      	ldr	r3, [r3, #4]
    e868:	aa03      	add	r2, sp, #12
    e86a:	f105 0148 	add.w	r1, r5, #72	; 0x48
    e86e:	4630      	mov	r0, r6
    e870:	4798      	blx	r3
                if(dhcpInfo.bootFileName == 0 || strlen(dhcpInfo.bootFileName) == 0)
    e872:	9a11      	ldr	r2, [sp, #68]	; 0x44
    e874:	b192      	cbz	r2, e89c <_CommandDhcpOptions+0x178>
    e876:	7813      	ldrb	r3, [r2, #0]
                    bootName = "not given";
    e878:	2b00      	cmp	r3, #0
    e87a:	f1a5 03d4 	sub.w	r3, r5, #212	; 0xd4
    e87e:	bf08      	it	eq
    e880:	461a      	moveq	r2, r3
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP boot name: %s\r\n", bootName);
    e882:	6823      	ldr	r3, [r4, #0]
    e884:	685b      	ldr	r3, [r3, #4]
    e886:	493b      	ldr	r1, [pc, #236]	; (e974 <_CommandDhcpOptions+0x250>)
    e888:	4630      	mov	r0, r6
    e88a:	4798      	blx	r3
                if(dhcpInfo.timeServersNo)
    e88c:	f89d 3048 	ldrb.w	r3, [sp, #72]	; 0x48
    e890:	b933      	cbnz	r3, e8a0 <_CommandDhcpOptions+0x17c>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP Time servers: %d, %s\r\n", dhcpInfo.timeServersNo, dhcpInfo.timeServersNo ? addBuff: "None");
    e892:	6823      	ldr	r3, [r4, #0]
    e894:	685d      	ldr	r5, [r3, #4]
    e896:	463a      	mov	r2, r7
    e898:	4b37      	ldr	r3, [pc, #220]	; (e978 <_CommandDhcpOptions+0x254>)
    e89a:	e00c      	b.n	e8b6 <_CommandDhcpOptions+0x192>
                    bootName = "not given";
    e89c:	4a37      	ldr	r2, [pc, #220]	; (e97c <_CommandDhcpOptions+0x258>)
    e89e:	e7f0      	b.n	e882 <_CommandDhcpOptions+0x15e>
                    TCPIP_Helper_IPAddressToString(dhcpInfo.timeServers, addBuff, sizeof(addBuff));
    e8a0:	2214      	movs	r2, #20
    e8a2:	a903      	add	r1, sp, #12
    e8a4:	9813      	ldr	r0, [sp, #76]	; 0x4c
    e8a6:	f00f ffe5 	bl	1e874 <TCPIP_Helper_IPAddressToString>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP Time servers: %d, %s\r\n", dhcpInfo.timeServersNo, dhcpInfo.timeServersNo ? addBuff: "None");
    e8aa:	6823      	ldr	r3, [r4, #0]
    e8ac:	685d      	ldr	r5, [r3, #4]
    e8ae:	f89d 2048 	ldrb.w	r2, [sp, #72]	; 0x48
    e8b2:	ab03      	add	r3, sp, #12
    e8b4:	b152      	cbz	r2, e8cc <_CommandDhcpOptions+0x1a8>
    e8b6:	4932      	ldr	r1, [pc, #200]	; (e980 <_CommandDhcpOptions+0x25c>)
    e8b8:	4630      	mov	r0, r6
    e8ba:	47a8      	blx	r5
                if(dhcpInfo.ntpServersNo)
    e8bc:	f89d 3049 	ldrb.w	r3, [sp, #73]	; 0x49
    e8c0:	b933      	cbnz	r3, e8d0 <_CommandDhcpOptions+0x1ac>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP NTP servers: %d, %s\r\n", dhcpInfo.ntpServersNo, dhcpInfo.ntpServersNo ? addBuff :  "None");
    e8c2:	6823      	ldr	r3, [r4, #0]
    e8c4:	685c      	ldr	r4, [r3, #4]
    e8c6:	463a      	mov	r2, r7
    e8c8:	4b2b      	ldr	r3, [pc, #172]	; (e978 <_CommandDhcpOptions+0x254>)
    e8ca:	e00c      	b.n	e8e6 <_CommandDhcpOptions+0x1c2>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP Time servers: %d, %s\r\n", dhcpInfo.timeServersNo, dhcpInfo.timeServersNo ? addBuff: "None");
    e8cc:	4b2a      	ldr	r3, [pc, #168]	; (e978 <_CommandDhcpOptions+0x254>)
    e8ce:	e7f2      	b.n	e8b6 <_CommandDhcpOptions+0x192>
                    TCPIP_Helper_IPAddressToString(dhcpInfo.ntpServers, addBuff, sizeof(addBuff));
    e8d0:	2214      	movs	r2, #20
    e8d2:	a903      	add	r1, sp, #12
    e8d4:	9814      	ldr	r0, [sp, #80]	; 0x50
    e8d6:	f00f ffcd 	bl	1e874 <TCPIP_Helper_IPAddressToString>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP NTP servers: %d, %s\r\n", dhcpInfo.ntpServersNo, dhcpInfo.ntpServersNo ? addBuff :  "None");
    e8da:	6823      	ldr	r3, [r4, #0]
    e8dc:	685c      	ldr	r4, [r3, #4]
    e8de:	f89d 2049 	ldrb.w	r2, [sp, #73]	; 0x49
    e8e2:	ab03      	add	r3, sp, #12
    e8e4:	b11a      	cbz	r2, e8ee <_CommandDhcpOptions+0x1ca>
    e8e6:	4927      	ldr	r1, [pc, #156]	; (e984 <_CommandDhcpOptions+0x260>)
    e8e8:	4630      	mov	r0, r6
    e8ea:	47a0      	blx	r4
    e8ec:	e72f      	b.n	e74e <_CommandDhcpOptions+0x2a>
    e8ee:	4b22      	ldr	r3, [pc, #136]	; (e978 <_CommandDhcpOptions+0x254>)
    e8f0:	e7f9      	b.n	e8e6 <_CommandDhcpOptions+0x1c2>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "DHCP: failed to get info\r\n");
    e8f2:	6823      	ldr	r3, [r4, #0]
    e8f4:	681b      	ldr	r3, [r3, #0]
    e8f6:	4924      	ldr	r1, [pc, #144]	; (e988 <_CommandDhcpOptions+0x264>)
    e8f8:	4630      	mov	r0, r6
    e8fa:	4798      	blx	r3
        return false;
    e8fc:	e727      	b.n	e74e <_CommandDhcpOptions+0x2a>
            dhcpRes = TCPIP_DHCP_Enable(netH);
    e8fe:	4650      	mov	r0, sl
    e900:	f00e fe66 	bl	1d5d0 <TCPIP_DHCP_Enable>
    (*pCmdIO->pCmdApi->print)(cmdIoParam, "%s %s %s\r\n", argv[0], argv[2], dhcpRes ? "success" : "fail");
    e904:	6823      	ldr	r3, [r4, #0]
    e906:	685c      	ldr	r4, [r3, #4]
    e908:	682a      	ldr	r2, [r5, #0]
    e90a:	68ab      	ldr	r3, [r5, #8]
    e90c:	2800      	cmp	r0, #0
    e90e:	491f      	ldr	r1, [pc, #124]	; (e98c <_CommandDhcpOptions+0x268>)
    e910:	481f      	ldr	r0, [pc, #124]	; (e990 <_CommandDhcpOptions+0x26c>)
    e912:	bf08      	it	eq
    e914:	4601      	moveq	r1, r0
    e916:	9100      	str	r1, [sp, #0]
    e918:	f500 71c4 	add.w	r1, r0, #392	; 0x188
    e91c:	4630      	mov	r0, r6
    e91e:	47a0      	blx	r4
    return true;
    e920:	2701      	movs	r7, #1
    e922:	e714      	b.n	e74e <_CommandDhcpOptions+0x2a>
            dhcpRes = TCPIP_DHCP_Request(netH, reqIpAddr);
    e924:	9915      	ldr	r1, [sp, #84]	; 0x54
    e926:	4650      	mov	r0, sl
    e928:	f00b f9b2 	bl	19c90 <TCPIP_DHCP_Request>
            break;
    e92c:	e7ea      	b.n	e904 <_CommandDhcpOptions+0x1e0>
            dhcpRes = TCPIP_DHCP_Renew(netH);
    e92e:	4650      	mov	r0, sl
    e930:	f00f fd04 	bl	1e33c <TCPIP_DHCP_Renew>
            break;
    e934:	e7e6      	b.n	e904 <_CommandDhcpOptions+0x1e0>
            dhcpRes = TCPIP_DHCP_Disable(netH);
    e936:	4650      	mov	r0, sl
    e938:	f00e fc12 	bl	1d160 <TCPIP_DHCP_Disable>
            break;
    e93c:	e7e2      	b.n	e904 <_CommandDhcpOptions+0x1e0>
    e93e:	bf00      	nop
    e940:	000012cc 	.word	0x000012cc
    e944:	00000488 	.word	0x00000488
    e948:	000004b4 	.word	0x000004b4
    e94c:	000004b8 	.word	0x000004b8
    e950:	00001304 	.word	0x00001304
    e954:	0000130c 	.word	0x0000130c
    e958:	00001314 	.word	0x00001314
    e95c:	000004a0 	.word	0x000004a0
    e960:	000010e0 	.word	0x000010e0
    e964:	00001334 	.word	0x00001334
    e968:	000004bc 	.word	0x000004bc
    e96c:	0000133c 	.word	0x0000133c
    e970:	00001384 	.word	0x00001384
    e974:	000013e0 	.word	0x000013e0
    e978:	000012bc 	.word	0x000012bc
    e97c:	000012b0 	.word	0x000012b0
    e980:	000013f8 	.word	0x000013f8
    e984:	00001414 	.word	0x00001414
    e988:	00001430 	.word	0x00001430
    e98c:	00001224 	.word	0x00001224
    e990:	000012c4 	.word	0x000012c4

Disassembly of section .rodata%252:

0000e994 <.rodata%252>:
    e994:	00082008 	.word	0x00082008
    e998:	00000008 	.word	0x00000008
    e99c:	003e0a0d 	.word	0x003e0a0d
    e9a0:	2d2d0a0d 	.word	0x2d2d0a0d
    e9a4:	2d2d2d2d 	.word	0x2d2d2d2d
    e9a8:	7553202d 	.word	0x7553202d
    e9ac:	726f7070 	.word	0x726f7070
    e9b0:	20646574 	.word	0x20646574
    e9b4:	6d6d6f63 	.word	0x6d6d6f63
    e9b8:	20646e61 	.word	0x20646e61
    e9bc:	756f7267 	.word	0x756f7267
    e9c0:	2d207370 	.word	0x2d207370
    e9c4:	2d2d2d2d 	.word	0x2d2d2d2d
    e9c8:	0000002d 	.word	0x0000002d
    e9cc:	2a200a0d 	.word	0x2a200a0d
    e9d0:	00202a2a 	.word	0x00202a2a
    e9d4:	2a2a2a20 	.word	0x2a2a2a20
    e9d8:	00000000 	.word	0x00000000
    e9dc:	2d2d0a0d 	.word	0x2d2d0a0d
    e9e0:	2d2d2d2d 	.word	0x2d2d2d2d
    e9e4:	2d2d2d2d 	.word	0x2d2d2d2d
    e9e8:	69754220 	.word	0x69754220
    e9ec:	6920746c 	.word	0x6920746c
    e9f0:	6f63206e 	.word	0x6f63206e
    e9f4:	6e616d6d 	.word	0x6e616d6d
    e9f8:	2d207364 	.word	0x2d207364
    e9fc:	2d2d2d2d 	.word	0x2d2d2d2d
    ea00:	2d2d2d2d 	.word	0x2d2d2d2d
    ea04:	0000002d 	.word	0x0000002d
    ea08:	00000a0d 	.word	0x00000a0d
    ea0c:	6e550a0d 	.word	0x6e550a0d
    ea10:	776f6e6b 	.word	0x776f6e6b
    ea14:	6f63206e 	.word	0x6f63206e
    ea18:	6e616d6d 	.word	0x6e616d6d
    ea1c:	72672064 	.word	0x72672064
    ea20:	2e70756f 	.word	0x2e70756f
    ea24:	79725420 	.word	0x79725420
    ea28:	6c656820 	.word	0x6c656820
    ea2c:	000a0d70 	.word	0x000a0d70
    ea30:	64255b1b 	.word	0x64255b1b
    ea34:	00000043 	.word	0x00000043
    ea38:	64255b1b 	.word	0x64255b1b
    ea3c:	00000044 	.word	0x00000044
    ea40:	2a200a0d 	.word	0x2a200a0d
    ea44:	51202a2a 	.word	0x51202a2a
    ea48:	74746975 	.word	0x74746975
    ea4c:	20676e69 	.word	0x20676e69
    ea50:	20656874 	.word	0x20656874
    ea54:	6d6d6f43 	.word	0x6d6d6f43
    ea58:	20646e61 	.word	0x20646e61
    ea5c:	636f7250 	.word	0x636f7250
    ea60:	6f737365 	.word	0x6f737365
    ea64:	42202e72 	.word	0x42202e72
    ea68:	2a206579 	.word	0x2a206579
    ea6c:	0a0d2a2a 	.word	0x0a0d2a2a
    ea70:	00000000 	.word	0x00000000
    ea74:	2a200a0d 	.word	0x2a200a0d
    ea78:	53202a2a 	.word	0x53202a2a
    ea7c:	65747379 	.word	0x65747379
    ea80:	6552206d 	.word	0x6552206d
    ea84:	746f6f62 	.word	0x746f6f62
    ea88:	2a2a2a20 	.word	0x2a2a2a20
    ea8c:	00000a0d 	.word	0x00000a0d
    ea90:	002c0920 	.word	0x002c0920
    ea94:	54200d0a 	.word	0x54200d0a
    ea98:	6d206f6f 	.word	0x6d206f6f
    ea9c:	20796e61 	.word	0x20796e61
    eaa0:	75677261 	.word	0x75677261
    eaa4:	746e656d 	.word	0x746e656d
    eaa8:	4d202e73 	.word	0x4d202e73
    eaac:	6d697861 	.word	0x6d697861
    eab0:	61206d75 	.word	0x61206d75
    eab4:	20736772 	.word	0x20736772
    eab8:	70707573 	.word	0x70707573
    eabc:	6574726f 	.word	0x6574726f
    eac0:	25203a64 	.word	0x25203a64
    eac4:	0a0d2164 	.word	0x0a0d2164
    eac8:	00000000 	.word	0x00000000
    eacc:	2a2a2a20 	.word	0x2a2a2a20
    ead0:	6d6f4320 	.word	0x6d6f4320
    ead4:	646e616d 	.word	0x646e616d
    ead8:	6f725020 	.word	0x6f725020
    eadc:	73736563 	.word	0x73736563
    eae0:	203a726f 	.word	0x203a726f
    eae4:	61656c50 	.word	0x61656c50
    eae8:	74206573 	.word	0x74206573
    eaec:	20657079 	.word	0x20657079
    eaf0:	61206e69 	.word	0x61206e69
    eaf4:	6d6f6320 	.word	0x6d6f6320
    eaf8:	646e616d 	.word	0x646e616d
    eafc:	0d2a2a2a 	.word	0x0d2a2a2a
    eb00:	0000000a 	.word	0x0000000a
    eb04:	2a2a2a20 	.word	0x2a2a2a20
    eb08:	6d6f4320 	.word	0x6d6f4320
    eb0c:	646e616d 	.word	0x646e616d
    eb10:	6f725020 	.word	0x6f725020
    eb14:	73736563 	.word	0x73736563
    eb18:	203a726f 	.word	0x203a726f
    eb1c:	6e6b6e75 	.word	0x6e6b6e75
    eb20:	206e776f 	.word	0x206e776f
    eb24:	6d6d6f63 	.word	0x6d6d6f63
    eb28:	2e646e61 	.word	0x2e646e61
    eb2c:	2a2a2a20 	.word	0x2a2a2a20
    eb30:	00000a0d 	.word	0x00000a0d
    eb34:	0000003e 	.word	0x0000003e
    eb38:	4b5b1b08 	.word	0x4b5b1b08
    eb3c:	5b1b7325 	.word	0x5b1b7325
    eb40:	00446425 	.word	0x00446425
    eb44:	4b5b1b08 	.word	0x4b5b1b08
    eb48:	00000000 	.word	0x00000000
    eb4c:	254b5b1b 	.word	0x254b5b1b
    eb50:	255b1b73 	.word	0x255b1b73
    eb54:	00004464 	.word	0x00004464
    eb58:	5b1b7325 	.word	0x5b1b7325
    eb5c:	00446425 	.word	0x00446425
    eb60:	2a2a2a20 	.word	0x2a2a2a20
    eb64:	6d6f4320 	.word	0x6d6f4320
    eb68:	646e616d 	.word	0x646e616d
    eb6c:	6f725020 	.word	0x6f725020
    eb70:	73736563 	.word	0x73736563
    eb74:	6220726f 	.word	0x6220726f
    eb78:	65666675 	.word	0x65666675
    eb7c:	78652072 	.word	0x78652072
    eb80:	64656563 	.word	0x64656563
    eb84:	202e6465 	.word	0x202e6465
    eb88:	72746552 	.word	0x72746552
    eb8c:	2a202e79 	.word	0x2a202e79
    eb90:	0a0d2a2a 	.word	0x0a0d2a2a
    eb94:	00000000 	.word	0x00000000
    eb98:	65736572 	.word	0x65736572
    eb9c:	00000074 	.word	0x00000074
    eba0:	6552203a 	.word	0x6552203a
    eba4:	20746573 	.word	0x20746573
    eba8:	74736f68 	.word	0x74736f68
    ebac:	00000000 	.word	0x00000000
    ebb0:	00000071 	.word	0x00000071
    ebb4:	7571203a 	.word	0x7571203a
    ebb8:	63207469 	.word	0x63207469
    ebbc:	616d6d6f 	.word	0x616d6d6f
    ebc0:	7020646e 	.word	0x7020646e
    ebc4:	65636f72 	.word	0x65636f72
    ebc8:	726f7373 	.word	0x726f7373
    ebcc:	00000000 	.word	0x00000000
    ebd0:	706c6568 	.word	0x706c6568
    ebd4:	00000000 	.word	0x00000000
    ebd8:	6568203a 	.word	0x6568203a
    ebdc:	0000706c 	.word	0x0000706c
    ebe0:	00415b1b 	.word	0x00415b1b
    ebe4:	00425b1b 	.word	0x00425b1b
    ebe8:	00435b1b 	.word	0x00435b1b
    ebec:	00445b1b 	.word	0x00445b1b
    ebf0:	7e315b1b 	.word	0x7e315b1b
    ebf4:	00000000 	.word	0x00000000
    ebf8:	7e345b1b 	.word	0x7e345b1b
    ebfc:	00          	.byte	0x00
    ebfd:	00          	.byte	0x00
    ebfe:	bf00      	nop

Disassembly of section .text._CommandPing%253:

0000ec00 <_CommandPing>:
{
    ec00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ec04:	b083      	sub	sp, #12
    const void* cmdIoParam = pCmdIO->cmdIoParam;
    ec06:	f8d0 b004 	ldr.w	fp, [r0, #4]
    if (argc < 2)
    ec0a:	2901      	cmp	r1, #1
    ec0c:	dd12      	ble.n	ec34 <_CommandPing+0x34>
    ec0e:	4682      	mov	sl, r0
    ec10:	460f      	mov	r7, r1
    ec12:	4614      	mov	r4, r2
    if(strcmp(argv[1], "stop") == 0)
    ec14:	6856      	ldr	r6, [r2, #4]
    ec16:	4978      	ldr	r1, [pc, #480]	; (edf8 <_CommandPing+0x1f8>)
    ec18:	4630      	mov	r0, r6
    ec1a:	f014 ffef 	bl	23bfc <strcmp>
    ec1e:	b190      	cbz	r0, ec46 <_CommandPing+0x46>
    if(tcpipCmdStat != TCPIP_CMD_STAT_IDLE)
    ec20:	4b76      	ldr	r3, [pc, #472]	; (edfc <_CommandPing+0x1fc>)
    ec22:	781b      	ldrb	r3, [r3, #0]
    ec24:	b1c3      	cbz	r3, ec58 <_CommandPing+0x58>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ping: command in progress. Retry later.\r\n");
    ec26:	f8da 3000 	ldr.w	r3, [sl]
    ec2a:	681b      	ldr	r3, [r3, #0]
    ec2c:	4974      	ldr	r1, [pc, #464]	; (ee00 <_CommandPing+0x200>)
    ec2e:	4658      	mov	r0, fp
    ec30:	4798      	blx	r3
        return true;
    ec32:	e004      	b.n	ec3e <_CommandPing+0x3e>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ping Usage: ping <stop>/<name/address> <i interface> <n nPings> <t msPeriod> <s size>\r\n");
    ec34:	6803      	ldr	r3, [r0, #0]
    ec36:	681b      	ldr	r3, [r3, #0]
    ec38:	4972      	ldr	r1, [pc, #456]	; (ee04 <_CommandPing+0x204>)
    ec3a:	4658      	mov	r0, fp
    ec3c:	4798      	blx	r3
}
    ec3e:	2001      	movs	r0, #1
    ec40:	b003      	add	sp, #12
    ec42:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(tcpipCmdStat != TCPIP_CMD_STAT_IDLE)
    ec46:	4b6d      	ldr	r3, [pc, #436]	; (edfc <_CommandPing+0x1fc>)
    ec48:	781b      	ldrb	r3, [r3, #0]
    ec4a:	2b00      	cmp	r3, #0
    ec4c:	d0f7      	beq.n	ec3e <_CommandPing+0x3e>
            _PingStop(pCmdIO, cmdIoParam);
    ec4e:	4659      	mov	r1, fp
    ec50:	4650      	mov	r0, sl
    ec52:	f00e f9f5 	bl	1d040 <_PingStop>
    ec56:	e7f2      	b.n	ec3e <_CommandPing+0x3e>
    if(TCPIP_Helper_StringToIPAddress(argv[1], &icmpTargetAddr))
    ec58:	496b      	ldr	r1, [pc, #428]	; (ee08 <_CommandPing+0x208>)
    ec5a:	4630      	mov	r0, r6
    ec5c:	f005 ff08 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
    ec60:	b960      	cbnz	r0, ec7c <_CommandPing+0x7c>
        if(strlen(argv[1]) > sizeof(icmpTargetHost) - 1)
    ec62:	6866      	ldr	r6, [r4, #4]
    ec64:	4630      	mov	r0, r6
    ec66:	f015 f92b 	bl	23ec0 <strlen>
    ec6a:	281e      	cmp	r0, #30
    ec6c:	d922      	bls.n	ecb4 <_CommandPing+0xb4>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ping: Host name too long. Retry.\r\n");
    ec6e:	f8da 3000 	ldr.w	r3, [sl]
    ec72:	681b      	ldr	r3, [r3, #0]
    ec74:	4965      	ldr	r1, [pc, #404]	; (ee0c <_CommandPing+0x20c>)
    ec76:	4658      	mov	r0, fp
    ec78:	4798      	blx	r3
            return true;
    ec7a:	e7e0      	b.n	ec3e <_CommandPing+0x3e>
        strncpy(icmpTargetAddrStr, argv[1], sizeof(icmpTargetAddrStr) - 1);
    ec7c:	4e64      	ldr	r6, [pc, #400]	; (ee10 <_CommandPing+0x210>)
    ec7e:	2210      	movs	r2, #16
    ec80:	6861      	ldr	r1, [r4, #4]
    ec82:	4630      	mov	r0, r6
    ec84:	f013 fc14 	bl	224b0 <strncpy>
        icmpTargetAddrStr[sizeof(icmpTargetAddrStr) - 1] = 0;
    ec88:	2300      	movs	r3, #0
    ec8a:	7433      	strb	r3, [r6, #16]
        icmpTargetHost[0] = '\0';
    ec8c:	4a61      	ldr	r2, [pc, #388]	; (ee14 <_CommandPing+0x214>)
    ec8e:	7013      	strb	r3, [r2, #0]
    icmpReqNo = 0;
    ec90:	4a61      	ldr	r2, [pc, #388]	; (ee18 <_CommandPing+0x218>)
    ec92:	6013      	str	r3, [r2, #0]
    icmpReqDelay = 0;
    ec94:	4a61      	ldr	r2, [pc, #388]	; (ee1c <_CommandPing+0x21c>)
    ec96:	6013      	str	r3, [r2, #0]
    while(currIx + 1 < argc)
    ec98:	2f03      	cmp	r7, #3
    ec9a:	f340 80a8 	ble.w	edee <_CommandPing+0x1ee>
        newCmdStat = TCPIP_PING_CMD_START_PING;
    ec9e:	2303      	movs	r3, #3
    eca0:	9301      	str	r3, [sp, #4]
    eca2:	3f04      	subs	r7, #4
    eca4:	f027 0701 	bic.w	r7, r7, #1
    eca8:	3704      	adds	r7, #4
    currIx = 2;
    ecaa:	2602      	movs	r6, #2
        if(strcmp(param, "i") == 0)
    ecac:	f8df 91a0 	ldr.w	r9, [pc, #416]	; ee50 <_CommandPing+0x250>
            icmpReqDelay = atoi(paramVal);
    ecb0:	46b8      	mov	r8, r7
    ecb2:	e018      	b.n	ece6 <_CommandPing+0xe6>
        strcpy(icmpTargetHost, argv[1]);
    ecb4:	4631      	mov	r1, r6
    ecb6:	4857      	ldr	r0, [pc, #348]	; (ee14 <_CommandPing+0x214>)
    ecb8:	f015 f8fa 	bl	23eb0 <strcpy>
    icmpReqNo = 0;
    ecbc:	2300      	movs	r3, #0
    ecbe:	4a56      	ldr	r2, [pc, #344]	; (ee18 <_CommandPing+0x218>)
    ecc0:	6013      	str	r3, [r2, #0]
    icmpReqDelay = 0;
    ecc2:	4a56      	ldr	r2, [pc, #344]	; (ee1c <_CommandPing+0x21c>)
    ecc4:	6013      	str	r3, [r2, #0]
    while(currIx + 1 < argc)
    ecc6:	2f03      	cmp	r7, #3
    ecc8:	f340 8086 	ble.w	edd8 <_CommandPing+0x1d8>
        newCmdStat = TCPIP_PING_CMD_DNS_GET;
    eccc:	2301      	movs	r3, #1
    ecce:	9301      	str	r3, [sp, #4]
    ecd0:	e7e7      	b.n	eca2 <_CommandPing+0xa2>
            if((icmpNetH = TCPIP_STACK_NetHandleGet(paramVal)) == 0)
    ecd2:	4638      	mov	r0, r7
    ecd4:	f010 fec6 	bl	1fa64 <TCPIP_STACK_NetHandleGet>
    ecd8:	4b51      	ldr	r3, [pc, #324]	; (ee20 <_CommandPing+0x220>)
    ecda:	6018      	str	r0, [r3, #0]
    ecdc:	b328      	cbz	r0, ed2a <_CommandPing+0x12a>
        currIx += 2;
    ecde:	3602      	adds	r6, #2
    ece0:	3408      	adds	r4, #8
    while(currIx + 1 < argc)
    ece2:	4546      	cmp	r6, r8
    ece4:	d044      	beq.n	ed70 <_CommandPing+0x170>
        char* param = argv[currIx];
    ece6:	68a5      	ldr	r5, [r4, #8]
        char* paramVal = argv[currIx + 1];
    ece8:	68e7      	ldr	r7, [r4, #12]
        if(strcmp(param, "i") == 0)
    ecea:	494e      	ldr	r1, [pc, #312]	; (ee24 <_CommandPing+0x224>)
    ecec:	4628      	mov	r0, r5
    ecee:	f014 ff85 	bl	23bfc <strcmp>
    ecf2:	2800      	cmp	r0, #0
    ecf4:	d0ed      	beq.n	ecd2 <_CommandPing+0xd2>
        else if(strcmp(param, "n") == 0)
    ecf6:	f609 0148 	addw	r1, r9, #2120	; 0x848
    ecfa:	4628      	mov	r0, r5
    ecfc:	f014 ff7e 	bl	23bfc <strcmp>
    ed00:	b1c0      	cbz	r0, ed34 <_CommandPing+0x134>
        else if(strcmp(param, "t") == 0)
    ed02:	f609 014c 	addw	r1, r9, #2124	; 0x84c
    ed06:	4628      	mov	r0, r5
    ed08:	f014 ff78 	bl	23bfc <strcmp>
    ed0c:	b1c0      	cbz	r0, ed40 <_CommandPing+0x140>
        else if(strcmp(param, "s") == 0)
    ed0e:	f509 6105 	add.w	r1, r9, #2128	; 0x850
    ed12:	4628      	mov	r0, r5
    ed14:	f014 ff72 	bl	23bfc <strcmp>
    ed18:	b1c0      	cbz	r0, ed4c <_CommandPing+0x14c>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ping: Unknown parameter\r\n");
    ed1a:	f8da 3000 	ldr.w	r3, [sl]
    ed1e:	681b      	ldr	r3, [r3, #0]
    ed20:	f509 6108 	add.w	r1, r9, #2176	; 0x880
    ed24:	4658      	mov	r0, fp
    ed26:	4798      	blx	r3
    ed28:	e7d9      	b.n	ecde <_CommandPing+0xde>
                icmpNetH = TCPIP_STACK_NetDefaultGet();
    ed2a:	f015 fa7f 	bl	2422c <TCPIP_STACK_NetDefaultGet>
    ed2e:	4b3c      	ldr	r3, [pc, #240]	; (ee20 <_CommandPing+0x220>)
    ed30:	6018      	str	r0, [r3, #0]
    ed32:	e7d4      	b.n	ecde <_CommandPing+0xde>
            icmpReqNo = atoi(paramVal);
    ed34:	4638      	mov	r0, r7
    ed36:	f015 fb87 	bl	24448 <atoi>
    ed3a:	4b37      	ldr	r3, [pc, #220]	; (ee18 <_CommandPing+0x218>)
    ed3c:	6018      	str	r0, [r3, #0]
    ed3e:	e7ce      	b.n	ecde <_CommandPing+0xde>
            icmpReqDelay = atoi(paramVal);
    ed40:	4638      	mov	r0, r7
    ed42:	f015 fb81 	bl	24448 <atoi>
    ed46:	4b35      	ldr	r3, [pc, #212]	; (ee1c <_CommandPing+0x21c>)
    ed48:	6018      	str	r0, [r3, #0]
    ed4a:	e7c8      	b.n	ecde <_CommandPing+0xde>
            int pingSize = atoi(paramVal);
    ed4c:	4638      	mov	r0, r7
    ed4e:	f015 fb7b 	bl	24448 <atoi>
            if(pingSize <= sizeof(icmpPingBuff))
    ed52:	f5b0 6ffa 	cmp.w	r0, #2000	; 0x7d0
    ed56:	d802      	bhi.n	ed5e <_CommandPing+0x15e>
                icmpPingSize = pingSize;
    ed58:	4b33      	ldr	r3, [pc, #204]	; (ee28 <_CommandPing+0x228>)
    ed5a:	6018      	str	r0, [r3, #0]
    ed5c:	e7bf      	b.n	ecde <_CommandPing+0xde>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "Ping: Data size too big. Max: %d. Retry\r\n", sizeof(icmpPingBuff));
    ed5e:	f8da 3000 	ldr.w	r3, [sl]
    ed62:	685b      	ldr	r3, [r3, #4]
    ed64:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
    ed68:	4930      	ldr	r1, [pc, #192]	; (ee2c <_CommandPing+0x22c>)
    ed6a:	4658      	mov	r0, fp
    ed6c:	4798      	blx	r3
                return true;
    ed6e:	e766      	b.n	ec3e <_CommandPing+0x3e>
    tcpipCmdStat = newCmdStat;
    ed70:	4b22      	ldr	r3, [pc, #136]	; (edfc <_CommandPing+0x1fc>)
    ed72:	9a01      	ldr	r2, [sp, #4]
    ed74:	701a      	strb	r2, [r3, #0]
    if(tcpipCmdStat == TCPIP_PING_CMD_DNS_GET)
    ed76:	2a01      	cmp	r2, #1
    ed78:	d031      	beq.n	edde <_CommandPing+0x1de>
    ed7a:	f00d fed3 	bl	1cb24 <rand>
    icmpSequenceNo = SYS_RANDOM_PseudoGet();
    ed7e:	4b2c      	ldr	r3, [pc, #176]	; (ee30 <_CommandPing+0x230>)
    ed80:	8018      	strh	r0, [r3, #0]
    ed82:	f00d fecf 	bl	1cb24 <rand>
    icmpIdentifier = SYS_RANDOM_PseudoGet();
    ed86:	4b2b      	ldr	r3, [pc, #172]	; (ee34 <_CommandPing+0x234>)
    ed88:	8018      	strh	r0, [r3, #0]
    if(icmpReqNo == 0)
    ed8a:	4b23      	ldr	r3, [pc, #140]	; (ee18 <_CommandPing+0x218>)
    ed8c:	681b      	ldr	r3, [r3, #0]
    ed8e:	b913      	cbnz	r3, ed96 <_CommandPing+0x196>
        icmpReqNo = TCPIP_STACK_COMMANDS_ICMP_ECHO_REQUESTS;
    ed90:	4b21      	ldr	r3, [pc, #132]	; (ee18 <_CommandPing+0x218>)
    ed92:	2204      	movs	r2, #4
    ed94:	601a      	str	r2, [r3, #0]
    if(icmpReqDelay == 0)
    ed96:	4b21      	ldr	r3, [pc, #132]	; (ee1c <_CommandPing+0x21c>)
    ed98:	681b      	ldr	r3, [r3, #0]
    ed9a:	b9bb      	cbnz	r3, edcc <_CommandPing+0x1cc>
        icmpReqDelay = TCPIP_STACK_COMMANDS_ICMP_ECHO_REQUEST_DELAY;
    ed9c:	4b1f      	ldr	r3, [pc, #124]	; (ee1c <_CommandPing+0x21c>)
    ed9e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    eda2:	601a      	str	r2, [r3, #0]
    pTcpipCmdDevice = pCmdIO;
    eda4:	4b24      	ldr	r3, [pc, #144]	; (ee38 <_CommandPing+0x238>)
    eda6:	f8c3 a000 	str.w	sl, [r3]
    icmpCmdIoParam = cmdIoParam; 
    edaa:	4b24      	ldr	r3, [pc, #144]	; (ee3c <_CommandPing+0x23c>)
    edac:	f8c3 b000 	str.w	fp, [r3]
    icmpAckRecv = 0;
    edb0:	2300      	movs	r3, #0
    edb2:	4a23      	ldr	r2, [pc, #140]	; (ee40 <_CommandPing+0x240>)
    edb4:	6013      	str	r3, [r2, #0]
    icmpReqCount = 0;
    edb6:	4a23      	ldr	r2, [pc, #140]	; (ee44 <_CommandPing+0x244>)
    edb8:	6013      	str	r3, [r2, #0]
    _TCPIPStackSignalHandlerSetParams(TCPIP_THIS_MODULE_ID, tcpipCmdSignalHandle, icmpReqDelay);
    edba:	4b18      	ldr	r3, [pc, #96]	; (ee1c <_CommandPing+0x21c>)
    edbc:	f9b3 2000 	ldrsh.w	r2, [r3]
    edc0:	4b21      	ldr	r3, [pc, #132]	; (ee48 <_CommandPing+0x248>)
    edc2:	6819      	ldr	r1, [r3, #0]
    edc4:	201f      	movs	r0, #31
    edc6:	f013 f9ad 	bl	22124 <_TCPIPStackSignalHandlerSetParams>
    return true;
    edca:	e738      	b.n	ec3e <_CommandPing+0x3e>
    if(icmpReqDelay < TCPIP_COMMAND_ICMP_ECHO_REQUEST_MIN_DELAY)
    edcc:	2b04      	cmp	r3, #4
    edce:	dce9      	bgt.n	eda4 <_CommandPing+0x1a4>
        icmpReqDelay = TCPIP_COMMAND_ICMP_ECHO_REQUEST_MIN_DELAY;
    edd0:	4b12      	ldr	r3, [pc, #72]	; (ee1c <_CommandPing+0x21c>)
    edd2:	2205      	movs	r2, #5
    edd4:	601a      	str	r2, [r3, #0]
    edd6:	e7e5      	b.n	eda4 <_CommandPing+0x1a4>
    tcpipCmdStat = newCmdStat;
    edd8:	4b08      	ldr	r3, [pc, #32]	; (edfc <_CommandPing+0x1fc>)
    edda:	2201      	movs	r2, #1
    eddc:	701a      	strb	r2, [r3, #0]
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Ping: resolving host: %s\r\n", icmpTargetHost);
    edde:	f8da 3000 	ldr.w	r3, [sl]
    ede2:	685b      	ldr	r3, [r3, #4]
    ede4:	4a0b      	ldr	r2, [pc, #44]	; (ee14 <_CommandPing+0x214>)
    ede6:	4919      	ldr	r1, [pc, #100]	; (ee4c <_CommandPing+0x24c>)
    ede8:	4658      	mov	r0, fp
    edea:	4798      	blx	r3
    edec:	e7c5      	b.n	ed7a <_CommandPing+0x17a>
    tcpipCmdStat = newCmdStat;
    edee:	4b03      	ldr	r3, [pc, #12]	; (edfc <_CommandPing+0x1fc>)
    edf0:	2203      	movs	r2, #3
    edf2:	701a      	strb	r2, [r3, #0]
    if(tcpipCmdStat == TCPIP_PING_CMD_DNS_GET)
    edf4:	e7c1      	b.n	ed7a <_CommandPing+0x17a>
    edf6:	bf00      	nop
    edf8:	00000a78 	.word	0x00000a78
    edfc:	2000ebc3 	.word	0x2000ebc3
    ee00:	00000a80 	.word	0x00000a80
    ee04:	00000a20 	.word	0x00000a20
    ee08:	2000ee08 	.word	0x2000ee08
    ee0c:	00000aac 	.word	0x00000aac
    ee10:	2000ed18 	.word	0x2000ed18
    ee14:	2000eba4 	.word	0x2000eba4
    ee18:	2000ee00 	.word	0x2000ee00
    ee1c:	2000edf8 	.word	0x2000edf8
    ee20:	2000edf0 	.word	0x2000edf0
    ee24:	00000ad0 	.word	0x00000ad0
    ee28:	2000ee1c 	.word	0x2000ee1c
    ee2c:	00000ae0 	.word	0x00000ae0
    ee30:	2000ef76 	.word	0x2000ef76
    ee34:	2000ef72 	.word	0x2000ef72
    ee38:	2000ee14 	.word	0x2000ee14
    ee3c:	2000edec 	.word	0x2000edec
    ee40:	2000ede8 	.word	0x2000ede8
    ee44:	2000edf4 	.word	0x2000edf4
    ee48:	2000ee18 	.word	0x2000ee18
    ee4c:	00000b28 	.word	0x00000b28
    ee50:	0000028c 	.word	0x0000028c

Disassembly of section .text.TCPIP_UDP_Task%254:

0000ee54 <TCPIP_UDP_Task>:
    return TCPIP_PKT_SocketAlloc(pktSize, sizeof(UDP_HEADER), txBuffSize, allocFlags);
}
#endif // defined (TCPIP_STACK_USE_IPV4) || (TCPIP_UDP_USE_POOL_BUFFERS != 0)

void TCPIP_UDP_Task(void)
{
    ee54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ee58:	b08b      	sub	sp, #44	; 0x2c
    if((sigPend & (TCPIP_MODULE_SIGNAL_INTERFACE_CHANGE)) != 0)
    { // interface address change occurred
        _UDPAbortSockets(netMask, TCPIP_UDP_SIGNAL_IF_CHANGE); 
    }
#else
    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    ee5a:	210f      	movs	r1, #15
    ee5c:	2009      	movs	r0, #9
    ee5e:	f011 f969 	bl	20134 <_TCPIPStackModuleSignalGet>
#endif  // (_TCPIP_STACK_INTERFACE_CHANGE_SIGNALING != 0)

    if((sigPend & TCPIP_MODULE_SIGNAL_RX_PENDING) != 0)
    ee62:	f010 0f01 	tst.w	r0, #1
    ee66:	d102      	bne.n	ee6e <TCPIP_UDP_Task+0x1a>
    { //  RX signal occurred
        TCPIP_UDP_Process();
    }

}
    ee68:	b00b      	add	sp, #44	; 0x2c
    ee6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    // and (IPv4 only for now)
    // 5. packet source address matches the socket expected source address or looseRemAddress flag is set
    

    pPktIf = (TCPIP_NET_IF*)pRxPkt->pktIf;
    for(sktIx = 0; sktIx < nUdpSockets; sktIx++)
    ee6e:	f8df b22c 	ldr.w	fp, [pc, #556]	; f09c <TCPIP_UDP_Task+0x248>
    ee72:	e096      	b.n	efa2 <TCPIP_UDP_Task+0x14e>
    pUDPHdr = (UDP_HEADER*)pRxPkt->pTransportLayer;
    ee74:	f8d9 801c 	ldr.w	r8, [r9, #28]
    udpTotLength = TCPIP_Helper_ntohs(pUDPHdr->Length);
    ee78:	f8b8 2004 	ldrh.w	r2, [r8, #4]
    ee7c:	0a14      	lsrs	r4, r2, #8
    ee7e:	ea44 2402 	orr.w	r4, r4, r2, lsl #8
    ee82:	b2a4      	uxth	r4, r4
    if(udpTotLength != pRxPkt->totTransportLen)
    ee84:	42a3      	cmp	r3, r4
    ee86:	f040 80a0 	bne.w	efca <TCPIP_UDP_Task+0x176>
    return &((IPV4_HEADER*)pPkt->pNetLayer)->SourceAddress;
    ee8a:	f8d9 2018 	ldr.w	r2, [r9, #24]
    ee8e:	9205      	str	r2, [sp, #20]
	if((pUDPHdr->Checksum != 0))
    ee90:	f8b8 3006 	ldrh.w	r3, [r8, #6]
    ee94:	b30b      	cbz	r3, eeda <TCPIP_UDP_Task+0x86>
	    pseudoHdr.SourceAddress.Val = pPktSrcAdd->Val;
    ee96:	68d3      	ldr	r3, [r2, #12]
    ee98:	9307      	str	r3, [sp, #28]
	    pseudoHdr.DestAddress.Val = pPktDstAdd->Val;
    ee9a:	6913      	ldr	r3, [r2, #16]
    ee9c:	9308      	str	r3, [sp, #32]
	    pseudoHdr.Zero	= 0;
    ee9e:	2200      	movs	r2, #0
    eea0:	f88d 2024 	strb.w	r2, [sp, #36]	; 0x24
	    pseudoHdr.Protocol = IP_PROT_UDP;
    eea4:	2311      	movs	r3, #17
    eea6:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
	    pseudoHdr.Length = pUDPHdr->Length;
    eeaa:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    eeae:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
	    calcChkSum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)&pseudoHdr, sizeof(pseudoHdr), 0);
    eeb2:	210c      	movs	r1, #12
    eeb4:	a807      	add	r0, sp, #28
    eeb6:	f00d f9cf 	bl	1c258 <TCPIP_Helper_CalcIPChecksum>
    eeba:	43c0      	mvns	r0, r0
    eebc:	b283      	uxth	r3, r0
        if((pRxPkt->pktFlags & TCPIP_MAC_PKT_FLAG_SPLIT) != 0)
    eebe:	f8b9 2022 	ldrh.w	r2, [r9, #34]	; 0x22
    eec2:	f012 0f04 	tst.w	r2, #4
    eec6:	d023      	beq.n	ef10 <TCPIP_UDP_Task+0xbc>
            calcChkSum = TCPIP_Helper_PacketChecksum(pRxPkt, (uint8_t*)pUDPHdr, udpTotLength, calcChkSum);
    eec8:	4622      	mov	r2, r4
    eeca:	4641      	mov	r1, r8
    eecc:	4648      	mov	r0, r9
    eece:	f00b ff1f 	bl	1ad10 <TCPIP_Helper_PacketChecksum>
            return TCPIP_MAC_PKT_ACK_CHKSUM_ERR;
    eed2:	f06f 0109 	mvn.w	r1, #9
        if(calcChkSum != 0)
    eed6:	2800      	cmp	r0, #0
    eed8:	d15f      	bne.n	ef9a <TCPIP_UDP_Task+0x146>
    pUDPHdr->SourcePort = TCPIP_Helper_ntohs(pUDPHdr->SourcePort);
    eeda:	f8b8 2000 	ldrh.w	r2, [r8]
    eede:	0a13      	lsrs	r3, r2, #8
    eee0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    eee4:	f8a8 3000 	strh.w	r3, [r8]
    pUDPHdr->DestinationPort = TCPIP_Helper_ntohs(pUDPHdr->DestinationPort);
    eee8:	f8b8 2002 	ldrh.w	r2, [r8, #2]
    eeec:	0a13      	lsrs	r3, r2, #8
    eeee:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    eef2:	f8a8 3002 	strh.w	r3, [r8, #2]
    pUDPHdr->Length = udpTotLength - sizeof(UDP_HEADER);    
    eef6:	3c08      	subs	r4, #8
    eef8:	f8a8 4004 	strh.w	r4, [r8, #4]
    pPktIf = (TCPIP_NET_IF*)pRxPkt->pktIf;
    eefc:	f8d9 3028 	ldr.w	r3, [r9, #40]	; 0x28
    ef00:	9304      	str	r3, [sp, #16]
    for(sktIx = 0; sktIx < nUdpSockets; sktIx++)
    ef02:	f8db 3000 	ldr.w	r3, [fp]
    ef06:	2b00      	cmp	r3, #0
    ef08:	dd6a      	ble.n	efe0 <TCPIP_UDP_Task+0x18c>
    ef0a:	f04f 0a00 	mov.w	sl, #0
    ef0e:	e073      	b.n	eff8 <TCPIP_UDP_Task+0x1a4>
            calcChkSum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pUDPHdr, udpTotLength, calcChkSum);
    ef10:	461a      	mov	r2, r3
    ef12:	4621      	mov	r1, r4
    ef14:	4640      	mov	r0, r8
    ef16:	f00d f99f 	bl	1c258 <TCPIP_Helper_CalcIPChecksum>
    ef1a:	e7da      	b.n	eed2 <TCPIP_UDP_Task+0x7e>
        if(_localPort != h->DestinationPort)
        {   // cannot handle this port
            continue;
        }
       
        exactMatch = looseMatch = 0;
    ef1c:	2200      	movs	r2, #0

        // 2. packet address type
        if(_addType == addressType)
        {
            exactMatch = TCPIP_UDP_PKT_MATCH_IP_TYPE;
    ef1e:	2301      	movs	r3, #1
    ef20:	e097      	b.n	f052 <TCPIP_UDP_Task+0x1fe>
        }

        // 3. packet source port
        if(_remotePort == h->SourcePort)
        {
            exactMatch |= TCPIP_UDP_PKT_MATCH_SRC_PORT;
    ef22:	f043 0302 	orr.w	r3, r3, #2
    ef26:	e09f      	b.n	f068 <TCPIP_UDP_Task+0x214>
#if defined (TCPIP_STACK_USE_IPV4)
        if(addressType == IP_ADDRESS_TYPE_IPV4)
        {
            if(_pSktNet == pPktIf)
            {
                exactMatch |= TCPIP_UDP_PKT_MATCH_NET;
    ef28:	f043 0304 	orr.w	r3, r3, #4
    ef2c:	e0a6      	b.n	f07c <TCPIP_UDP_Task+0x228>
        {
            if(_pktSrcAddress.Val == 0 || _flags.looseRemAddress != 0)
            {
                looseMatch |= TCPIP_UDP_PKT_MACTH_SRC_ADD;
            }
            else if(_pktSrcAddress.Val == TCPIP_IPV4_PacketGetSourceAddress(pRxPkt)->Val)
    ef2e:	f8d9 1018 	ldr.w	r1, [r9, #24]
    ef32:	68c9      	ldr	r1, [r1, #12]
    ef34:	9801      	ldr	r0, [sp, #4]
    ef36:	4288      	cmp	r0, r1
    ef38:	d158      	bne.n	efec <TCPIP_UDP_Task+0x198>
            {
                exactMatch |= TCPIP_UDP_PKT_MACTH_SRC_ADD;
    ef3a:	f043 0308 	orr.w	r3, r3, #8
            exactMatch |= TCPIP_UDP_PKT_MACTH_SRC_ADD;
        }
#endif // defined(TCPIP_STACK_USE_IPV6)

        // finally check the match we got
        if(exactMatch == TCPIP_UDP_PKT_MACTH_MASK)
    ef3e:	2b0f      	cmp	r3, #15
    ef40:	f040 80a4 	bne.w	f08c <TCPIP_UDP_Task+0x238>
        if(pSkt->extFlags.mcastOnly != 0)
    ef44:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
    ef48:	f013 0f40 	tst.w	r3, #64	; 0x40
    ef4c:	d005      	beq.n	ef5a <TCPIP_UDP_Task+0x106>
            if(!TCPIP_Helper_IsMcastAddress(pPktDstAdd))
    ef4e:	9b05      	ldr	r3, [sp, #20]
    ef50:	7c1b      	ldrb	r3, [r3, #16]
    ef52:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    ef56:	2be0      	cmp	r3, #224	; 0xe0
    ef58:	d13a      	bne.n	efd0 <TCPIP_UDP_Task+0x17c>
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    ef5a:	2000      	movs	r0, #0
    ef5c:	f014 fc0a 	bl	23774 <OSAL_CRIT_Enter>
    ef60:	4606      	mov	r6, r0
    TCPIP_Helper_SingleListTailAdd(&pSkt->rxQueue, (SGL_LIST_NODE*)pNode);
    ef62:	4649      	mov	r1, r9
    ef64:	f104 0044 	add.w	r0, r4, #68	; 0x44
    ef68:	f014 fa60 	bl	2342c <TCPIP_Helper_SingleListTailAdd>
    if((pSkt->sigMask & TCPIP_UDP_SIGNAL_RX_DATA) != 0)
    ef6c:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
    ef70:	f413 7f80 	tst.w	r3, #256	; 0x100
    ef74:	d02f      	beq.n	efd6 <TCPIP_UDP_Task+0x182>
        sigHandler = pSkt->sigHandler;
    ef76:	6d25      	ldr	r5, [r4, #80]	; 0x50
        *pSigParam = pSkt->sigParam;
    ef78:	6d67      	ldr	r7, [r4, #84]	; 0x54
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
    ef7a:	4631      	mov	r1, r6
    ef7c:	2000      	movs	r0, #0
    ef7e:	f014 fd33 	bl	239e8 <OSAL_CRIT_Leave>
        if(sigHandler)
    ef82:	b175      	cbz	r5, efa2 <TCPIP_UDP_Task+0x14e>
            (*sigHandler)(pSkt->sktIx, pRxPkt->pktIf, TCPIP_UDP_SIGNAL_RX_DATA, sigParam);
    ef84:	463b      	mov	r3, r7
    ef86:	f44f 7280 	mov.w	r2, #256	; 0x100
    ef8a:	f8d9 1028 	ldr.w	r1, [r9, #40]	; 0x28
    ef8e:	f9b4 0012 	ldrsh.w	r0, [r4, #18]
    ef92:	47a8      	blx	r5
    ef94:	e005      	b.n	efa2 <TCPIP_UDP_Task+0x14e>
            ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    ef96:	f06f 010d 	mvn.w	r1, #13
    TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
    ef9a:	2209      	movs	r2, #9
    ef9c:	4648      	mov	r0, r9
    ef9e:	f010 fd81 	bl	1faa4 <_TCPIP_PKT_PacketAcknowledge>
    while((pRxPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
    efa2:	2009      	movs	r0, #9
    efa4:	f012 fd3c 	bl	21a20 <_TCPIPStackModuleRxExtract>
    efa8:	4681      	mov	r9, r0
    efaa:	2800      	cmp	r0, #0
    efac:	f43f af5c 	beq.w	ee68 <TCPIP_UDP_Task+0x14>
        if(pRxPkt->totTransportLen < sizeof(UDP_HEADER))
    efb0:	f8b9 3020 	ldrh.w	r3, [r9, #32]
    efb4:	2b07      	cmp	r3, #7
    efb6:	d9ee      	bls.n	ef96 <TCPIP_UDP_Task+0x142>
        else if((pRxPkt->pktFlags & TCPIP_MAC_PKT_FLAG_NET_TYPE) == TCPIP_MAC_PKT_FLAG_IPV4) 
    efb8:	f8b9 2022 	ldrh.w	r2, [r9, #34]	; 0x22
    efbc:	f412 7f00 	tst.w	r2, #512	; 0x200
    efc0:	f43f af58 	beq.w	ee74 <TCPIP_UDP_Task+0x20>
        ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    efc4:	f06f 010e 	mvn.w	r1, #14
    efc8:	e7e7      	b.n	ef9a <TCPIP_UDP_Task+0x146>
        return TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    efca:	f06f 010d 	mvn.w	r1, #13
    efce:	e7e4      	b.n	ef9a <TCPIP_UDP_Task+0x146>
                ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    efd0:	f06f 010e 	mvn.w	r1, #14
        if(ackRes != TCPIP_MAC_PKT_ACK_NONE)
    efd4:	e7e1      	b.n	ef9a <TCPIP_UDP_Task+0x146>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
    efd6:	4631      	mov	r1, r6
    efd8:	2000      	movs	r0, #0
    efda:	f014 fd05 	bl	239e8 <OSAL_CRIT_Leave>
        if(sigHandler)
    efde:	e7e0      	b.n	efa2 <TCPIP_UDP_Task+0x14e>
            ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    efe0:	f06f 010e 	mvn.w	r1, #14
    efe4:	e7d9      	b.n	ef9a <TCPIP_UDP_Task+0x146>
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critStatus);
    efe6:	2000      	movs	r0, #0
    efe8:	f014 fcfe 	bl	239e8 <OSAL_CRIT_Leave>
    for(sktIx = 0; sktIx < nUdpSockets; sktIx++)
    efec:	f10a 0a01 	add.w	sl, sl, #1
    eff0:	f8db 3000 	ldr.w	r3, [fp]
    eff4:	459a      	cmp	sl, r3
    eff6:	daf3      	bge.n	efe0 <TCPIP_UDP_Task+0x18c>
        critStatus = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    eff8:	2000      	movs	r0, #0
    effa:	f014 fbbb 	bl	23774 <OSAL_CRIT_Enter>
    effe:	4601      	mov	r1, r0
            pSkt = UDPSocketDcpt[sktIx];
    f000:	4b25      	ldr	r3, [pc, #148]	; (f098 <TCPIP_UDP_Task+0x244>)
    f002:	681b      	ldr	r3, [r3, #0]
    f004:	f853 402a 	ldr.w	r4, [r3, sl, lsl #2]
            if(pSkt == 0) 
    f008:	2c00      	cmp	r4, #0
    f00a:	d0ec      	beq.n	efe6 <TCPIP_UDP_Task+0x192>
    return (pSkt->extFlags.rxEnable == 0);
    f00c:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
            if(_RxSktIsLocked(pSkt)) 
    f010:	f013 0f02 	tst.w	r3, #2
    f014:	d0e7      	beq.n	efe6 <TCPIP_UDP_Task+0x192>
            if(TCPIP_Helper_SingleListCount(&pSkt->rxQueue) >= pSkt->rxQueueLimit)
    f016:	f894 305a 	ldrb.w	r3, [r4, #90]	; 0x5a
    f01a:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
    f01c:	429a      	cmp	r2, r3
    f01e:	dae2      	bge.n	efe6 <TCPIP_UDP_Task+0x192>
            _localPort = pSkt->localPort;
    f020:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    f022:	9302      	str	r3, [sp, #8]
            _addType = pSkt->addType;
    f024:	8fa6      	ldrh	r6, [r4, #60]	; 0x3c
            _remotePort = pSkt->remotePort;
    f026:	8d20      	ldrh	r0, [r4, #40]	; 0x28
    f028:	9003      	str	r0, [sp, #12]
            _flags.Val = pSkt->flags.Val;
    f02a:	f8b4 5040 	ldrh.w	r5, [r4, #64]	; 0x40
            _pSktNet = pSkt->pSktNet;
    f02e:	6a67      	ldr	r7, [r4, #36]	; 0x24
            _pktSrcAddress.Val = pSkt->pktSrcAddress.Val;
    f030:	69e0      	ldr	r0, [r4, #28]
    f032:	9001      	str	r0, [sp, #4]
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critStatus);
    f034:	2000      	movs	r0, #0
    f036:	f014 fcd7 	bl	239e8 <OSAL_CRIT_Leave>
        if(_localPort != h->DestinationPort)
    f03a:	f8b8 3002 	ldrh.w	r3, [r8, #2]
    f03e:	9a02      	ldr	r2, [sp, #8]
    f040:	4293      	cmp	r3, r2
    f042:	d1d3      	bne.n	efec <TCPIP_UDP_Task+0x198>
        if(_addType == addressType)
    f044:	2e01      	cmp	r6, #1
    f046:	f43f af69 	beq.w	ef1c <TCPIP_UDP_Task+0xc8>
        else if(_addType == IP_ADDRESS_TYPE_ANY)
    f04a:	2e00      	cmp	r6, #0
    f04c:	d1ce      	bne.n	efec <TCPIP_UDP_Task+0x198>
            looseMatch = TCPIP_UDP_PKT_MATCH_IP_TYPE;
    f04e:	2201      	movs	r2, #1
        exactMatch = looseMatch = 0;
    f050:	2300      	movs	r3, #0
        if(_remotePort == h->SourcePort)
    f052:	f8b8 1000 	ldrh.w	r1, [r8]
    f056:	9803      	ldr	r0, [sp, #12]
    f058:	4281      	cmp	r1, r0
    f05a:	f43f af62 	beq.w	ef22 <TCPIP_UDP_Task+0xce>
        else if(_flags.looseRemPort != 0)
    f05e:	f015 0f04 	tst.w	r5, #4
            looseMatch |= TCPIP_UDP_PKT_MATCH_SRC_PORT;
    f062:	bf18      	it	ne
    f064:	f042 0202 	orrne.w	r2, r2, #2
            if(_pSktNet == pPktIf)
    f068:	9904      	ldr	r1, [sp, #16]
    f06a:	42b9      	cmp	r1, r7
    f06c:	f43f af5c 	beq.w	ef28 <TCPIP_UDP_Task+0xd4>
            else if(_pSktNet == 0 || _flags.looseNetIf != 0)
    f070:	b117      	cbz	r7, f078 <TCPIP_UDP_Task+0x224>
    f072:	f015 0f08 	tst.w	r5, #8
    f076:	d001      	beq.n	f07c <TCPIP_UDP_Task+0x228>
                looseMatch |= TCPIP_UDP_PKT_MATCH_NET;
    f078:	f042 0204 	orr.w	r2, r2, #4
            if(_pktSrcAddress.Val == 0 || _flags.looseRemAddress != 0)
    f07c:	9901      	ldr	r1, [sp, #4]
    f07e:	b119      	cbz	r1, f088 <TCPIP_UDP_Task+0x234>
    f080:	f015 0f10 	tst.w	r5, #16
    f084:	f43f af53 	beq.w	ef2e <TCPIP_UDP_Task+0xda>
                looseMatch |= TCPIP_UDP_PKT_MACTH_SRC_ADD;
    f088:	f042 0208 	orr.w	r2, r2, #8
        {   // perfect match
            return pSkt;
        }
        else if( (looseMatch | exactMatch) == TCPIP_UDP_PKT_MACTH_MASK )
    f08c:	4313      	orrs	r3, r2
    f08e:	2b0f      	cmp	r3, #15
    f090:	d1ac      	bne.n	efec <TCPIP_UDP_Task+0x198>
                    }
                }
            }
#endif  // defined (TCPIP_STACK_USE_IPV6)
            
            pSkt->addType = addressType;
    f092:	2301      	movs	r3, #1
    f094:	87a3      	strh	r3, [r4, #60]	; 0x3c
        if(pSkt == 0)
    f096:	e755      	b.n	ef44 <TCPIP_UDP_Task+0xf0>
    f098:	2000ee88 	.word	0x2000ee88
    f09c:	2000ee8c 	.word	0x2000ee8c

Disassembly of section .text.TCPIP_STACK_BringNetUp%255:

0000f0a0 <TCPIP_STACK_BringNetUp>:
{
    f0a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f0a4:	b095      	sub	sp, #84	; 0x54
    f0a6:	4606      	mov	r6, r0
    f0a8:	461f      	mov	r7, r3
    pNetIf = stackCtrlData->pNetIf;
    f0aa:	f8d0 8014 	ldr.w	r8, [r0, #20]
    pNetIf->netIfIx = stackCtrlData->netIx;
    f0ae:	6983      	ldr	r3, [r0, #24]
    f0b0:	f8a8 3058 	strh.w	r3, [r8, #88]	; 0x58
    pNetIf->Flags.powerMode = stackCtrlData->powerMode;
    f0b4:	f898 3043 	ldrb.w	r3, [r8, #67]	; 0x43
    f0b8:	7f41      	ldrb	r1, [r0, #29]
    f0ba:	f361 0383 	bfi	r3, r1, #2, #2
    f0be:	f888 3043 	strb.w	r3, [r8, #67]	; 0x43
    pMacObj = pNetIf->pMacObj;
    f0c2:	f8d8 4044 	ldr.w	r4, [r8, #68]	; 0x44
            macConfig = pNetIf->pMacConfig;
    f0c6:	f8d8 9054 	ldr.w	r9, [r8, #84]	; 0x54
            if (pModConfig != 0)
    f0ca:	4615      	mov	r5, r2
    f0cc:	b19a      	cbz	r2, f0f6 <TCPIP_STACK_BringNetUp+0x56>
                pConfig = _TCPIP_STACK_FindModuleData(pMacObj->macId, pModConfig, nModules);
    f0ce:	8820      	ldrh	r0, [r4, #0]
    while(nModules--)
    f0d0:	b18f      	cbz	r7, f0f6 <TCPIP_STACK_BringNetUp+0x56>
        if(pModConfig->moduleId == moduleId)
    f0d2:	8813      	ldrh	r3, [r2, #0]
    f0d4:	4283      	cmp	r3, r0
    f0d6:	f000 80e4 	beq.w	f2a2 <TCPIP_STACK_BringNetUp+0x202>
    f0da:	1eba      	subs	r2, r7, #2
    f0dc:	462b      	mov	r3, r5
        pModConfig++;
    f0de:	3308      	adds	r3, #8
    while(nModules--)
    f0e0:	f1b2 3fff 	cmp.w	r2, #4294967295
    f0e4:	d007      	beq.n	f0f6 <TCPIP_STACK_BringNetUp+0x56>
        if(pModConfig->moduleId == moduleId)
    f0e6:	3a01      	subs	r2, #1
    f0e8:	8819      	ldrh	r1, [r3, #0]
    f0ea:	4281      	cmp	r1, r0
    f0ec:	d1f7      	bne.n	f0de <TCPIP_STACK_BringNetUp+0x3e>
                    pNetIf->pMacConfig = macConfig = pConfig->configData;
    f0ee:	f8d3 9004 	ldr.w	r9, [r3, #4]
    f0f2:	f8c8 9054 	str.w	r9, [r8, #84]	; 0x54
            if(stackCtrlData->powerMode == TCPIP_MAC_POWER_FULL)
    f0f6:	7f73      	ldrb	r3, [r6, #29]
    f0f8:	2b01      	cmp	r3, #1
    f0fa:	d004      	beq.n	f106 <TCPIP_STACK_BringNetUp+0x66>
        if(pModConfig->moduleId == moduleId)
    f0fc:	4c6a      	ldr	r4, [pc, #424]	; (f2a8 <TCPIP_STACK_BringNetUp+0x208>)
            configData = 0;
    f0fe:	46aa      	mov	sl, r5
        for(modIx = 0; modIx < sizeof(TCPIP_STACK_MODULE_ENTRY_TBL)/sizeof(*TCPIP_STACK_MODULE_ENTRY_TBL); modIx++)
    f100:	f104 0978 	add.w	r9, r4, #120	; 0x78
    f104:	e0ba      	b.n	f27c <TCPIP_STACK_BringNetUp+0x1dc>
    TCPIP_NET_IF* pNetIf = stackCtrlData->pNetIf;
    f106:	f8d6 b014 	ldr.w	fp, [r6, #20]
    memset(pMacCtrl, 0, sizeof(*pMacCtrl));
    f10a:	f04f 0a00 	mov.w	sl, #0
    f10e:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
    f112:	f8cd a040 	str.w	sl, [sp, #64]	; 0x40
    f116:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
    f11a:	f8cd a048 	str.w	sl, [sp, #72]	; 0x48
    f11e:	f8cd a04c 	str.w	sl, [sp, #76]	; 0x4c
    pMacCtrl->nIfs = stackCtrlData->nIfs;
    f122:	6833      	ldr	r3, [r6, #0]
    f124:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
    pMacCtrl->mallocF = TCPIP_HEAP_MallocOutline;
    f128:	4b60      	ldr	r3, [pc, #384]	; (f2ac <TCPIP_STACK_BringNetUp+0x20c>)
    f12a:	9304      	str	r3, [sp, #16]
    pMacCtrl->callocF = TCPIP_HEAP_CallocOutline;
    f12c:	4b60      	ldr	r3, [pc, #384]	; (f2b0 <TCPIP_STACK_BringNetUp+0x210>)
    f12e:	9305      	str	r3, [sp, #20]
    pMacCtrl->freeF = TCPIP_HEAP_FreeOutline;
    f130:	4b60      	ldr	r3, [pc, #384]	; (f2b4 <TCPIP_STACK_BringNetUp+0x214>)
    f132:	9306      	str	r3, [sp, #24]
    pMacCtrl->memH = stackCtrlData->memH;
    f134:	68f3      	ldr	r3, [r6, #12]
    f136:	9307      	str	r3, [sp, #28]
    pMacCtrl->pktAllocF = (TCPIP_MAC_PKT_AllocF)_TCPIP_PKT_ALLOC_FNC;
    f138:	4b5f      	ldr	r3, [pc, #380]	; (f2b8 <TCPIP_STACK_BringNetUp+0x218>)
    f13a:	9308      	str	r3, [sp, #32]
    pMacCtrl->pktFreeF = (TCPIP_MAC_PKT_FreeF)_TCPIP_PKT_FREE_FNC;
    f13c:	4b5f      	ldr	r3, [pc, #380]	; (f2bc <TCPIP_STACK_BringNetUp+0x21c>)
    f13e:	9309      	str	r3, [sp, #36]	; 0x24
    pMacCtrl->pktAckF = (TCPIP_MAC_PKT_AckF)_TCPIP_PKT_ACK_FNC;
    f140:	4b5f      	ldr	r3, [pc, #380]	; (f2c0 <TCPIP_STACK_BringNetUp+0x220>)
    f142:	930a      	str	r3, [sp, #40]	; 0x28
    pMacCtrl->synchF = _TCPIP_StackSyncFunction;
    f144:	4b5f      	ldr	r3, [pc, #380]	; (f2c4 <TCPIP_STACK_BringNetUp+0x224>)
    f146:	930b      	str	r3, [sp, #44]	; 0x2c
    pMacCtrl->eventF = _TCPIP_MacEventCB;
    f148:	4b5f      	ldr	r3, [pc, #380]	; (f2c8 <TCPIP_STACK_BringNetUp+0x228>)
    f14a:	930c      	str	r3, [sp, #48]	; 0x30
    pMacCtrl->eventParam = pNetIf;
    f14c:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
    pMacCtrl->netIx = stackCtrlData->netIx;
    f150:	69b3      	ldr	r3, [r6, #24]
    f152:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
    pMacCtrl->gapDcptOffset = TCPIP_PKT_GapDcptOffset();
    f156:	f015 f98d 	bl	24474 <TCPIP_PKT_GapDcptOffset>
    f15a:	f8ad 0040 	strh.w	r0, [sp, #64]	; 0x40
    pMacCtrl->gapDcptSize = TCPIP_PKT_GapDcptSize();
    f15e:	f015 f99b 	bl	24498 <TCPIP_PKT_GapDcptSize>
    f162:	f8ad 0042 	strh.w	r0, [sp, #66]	; 0x42
    pMacCtrl->macAction = TCPIP_STACK_StackToMacAction(stackCtrlData->stackAction);
    f166:	7f33      	ldrb	r3, [r6, #28]
    f168:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
    pMacCtrl->powerMode = stackCtrlData->powerMode;
    f16c:	7f73      	ldrb	r3, [r6, #29]
    f16e:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45
    pMacCtrl->controlFlags = TCPIP_MAC_CONTROL_PAYLOAD_OFFSET_2;
    f172:	2301      	movs	r3, #1
    f174:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
    memcpy(pMacCtrl->ifPhyAddress.v, pNetIf->netMACAddr.v, sizeof(pMacCtrl->ifPhyAddress));
    f178:	465b      	mov	r3, fp
    f17a:	f853 0f3c 	ldr.w	r0, [r3, #60]!
    f17e:	9012      	str	r0, [sp, #72]	; 0x48
    f180:	889b      	ldrh	r3, [r3, #4]
    f182:	f8ad 304c 	strh.w	r3, [sp, #76]	; 0x4c
                TCPIP_MAC_INIT macInit =
    f186:	f88d a004 	strb.w	sl, [sp, #4]
    f18a:	ab04      	add	r3, sp, #16
    f18c:	9302      	str	r3, [sp, #8]
    f18e:	f8cd 900c 	str.w	r9, [sp, #12]
                pNetIf->macObjHandle = (*pMacObj->TCPIP_MAC_Initialize)(pMacObj->macId, &macInit.moduleInit);
    f192:	68a3      	ldr	r3, [r4, #8]
    f194:	a901      	add	r1, sp, #4
    f196:	8820      	ldrh	r0, [r4, #0]
    f198:	4798      	blx	r3
    f19a:	f8c8 004c 	str.w	r0, [r8, #76]	; 0x4c
                if( pNetIf->macObjHandle == SYS_MODULE_OBJ_INVALID)
    f19e:	f1b0 3fff 	cmp.w	r0, #4294967295
    f1a2:	d017      	beq.n	f1d4 <TCPIP_STACK_BringNetUp+0x134>
                pNetIf->hIfMac = (*pMacObj->TCPIP_MAC_Open)(pMacObj->macId, DRV_IO_INTENT_READWRITE);
    f1a4:	69e3      	ldr	r3, [r4, #28]
    f1a6:	2103      	movs	r1, #3
    f1a8:	8820      	ldrh	r0, [r4, #0]
    f1aa:	4798      	blx	r3
    f1ac:	f8c8 0050 	str.w	r0, [r8, #80]	; 0x50
                if(pNetIf->hIfMac == DRV_HANDLE_INVALID)
    f1b0:	f1b0 3fff 	cmp.w	r0, #4294967295
    f1b4:	d1a2      	bne.n	f0fc <TCPIP_STACK_BringNetUp+0x5c>
                    pNetIf->hIfMac = 0;
    f1b6:	2300      	movs	r3, #0
    f1b8:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
                    pNetIf->macObjHandle = 0;
    f1bc:	f8c8 304c 	str.w	r3, [r8, #76]	; 0x4c
                    SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "%s MAC Open failed\r\n", pMacObj->macName);
    f1c0:	f015 f85e 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    f1c4:	b158      	cbz	r0, f1de <TCPIP_STACK_BringNetUp+0x13e>
    f1c6:	f015 f855 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    f1ca:	6862      	ldr	r2, [r4, #4]
    f1cc:	493f      	ldr	r1, [pc, #252]	; (f2cc <TCPIP_STACK_BringNetUp+0x22c>)
    f1ce:	f00d fa65 	bl	1c69c <SYS_CONSOLE_Print>
    f1d2:	e004      	b.n	f1de <TCPIP_STACK_BringNetUp+0x13e>
                    pNetIf->macObjHandle = 0;
    f1d4:	f8c8 a04c 	str.w	sl, [r8, #76]	; 0x4c
                    SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "%s MAC initialization failed\r\n", pMacObj->macName);
    f1d8:	f015 f852 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    f1dc:	b908      	cbnz	r0, f1e2 <TCPIP_STACK_BringNetUp+0x142>
        return false;
    f1de:	2400      	movs	r4, #0
    f1e0:	e03e      	b.n	f260 <TCPIP_STACK_BringNetUp+0x1c0>
                    SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "%s MAC initialization failed\r\n", pMacObj->macName);
    f1e2:	f015 f847 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    f1e6:	6862      	ldr	r2, [r4, #4]
    f1e8:	4939      	ldr	r1, [pc, #228]	; (f2d0 <TCPIP_STACK_BringNetUp+0x230>)
    f1ea:	f00d fa57 	bl	1c69c <SYS_CONSOLE_Print>
    f1ee:	e7f6      	b.n	f1de <TCPIP_STACK_BringNetUp+0x13e>
            configData = 0;
    f1f0:	2100      	movs	r1, #0
    f1f2:	e03b      	b.n	f26c <TCPIP_STACK_BringNetUp+0x1cc>
    f1f4:	4651      	mov	r1, sl
    f1f6:	e039      	b.n	f26c <TCPIP_STACK_BringNetUp+0x1cc>
    f1f8:	2100      	movs	r1, #0
    f1fa:	e037      	b.n	f26c <TCPIP_STACK_BringNetUp+0x1cc>
                SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Module no: %d Initialization failed\r\n", pEntry->moduleId);
    f1fc:	f015 f840 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    f200:	b908      	cbnz	r0, f206 <TCPIP_STACK_BringNetUp+0x166>
                netUpFail = 1;
    f202:	2401      	movs	r4, #1
    f204:	e02a      	b.n	f25c <TCPIP_STACK_BringNetUp+0x1bc>
                SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Module no: %d Initialization failed\r\n", pEntry->moduleId);
    f206:	f015 f835 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    f20a:	8822      	ldrh	r2, [r4, #0]
    f20c:	4931      	ldr	r1, [pc, #196]	; (f2d4 <TCPIP_STACK_BringNetUp+0x234>)
    f20e:	f00d fa45 	bl	1c69c <SYS_CONSOLE_Print>
                netUpFail = 1;
    f212:	2401      	movs	r4, #1
    f214:	e022      	b.n	f25c <TCPIP_STACK_BringNetUp+0x1bc>
        if(!netUpFail && pNetIf->hIfMac != 0)
    f216:	f8d8 0050 	ldr.w	r0, [r8, #80]	; 0x50
    f21a:	b1f0      	cbz	r0, f25a <TCPIP_STACK_BringNetUp+0x1ba>
                if(!(*pNetIf->pMacObj->TCPIP_MAC_EventMaskSet)(pNetIf->hIfMac, TCPIP_STACK_MAC_ALL_EVENTS, true))
    f21c:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
    f220:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    f222:	2201      	movs	r2, #1
    f224:	f240 7196 	movw	r1, #1942	; 0x796
    f228:	4798      	blx	r3
    f22a:	4604      	mov	r4, r0
    f22c:	b148      	cbz	r0, f242 <TCPIP_STACK_BringNetUp+0x1a2>
            pNetIf->Flags.bMacInitialize = true;
    f22e:	f898 3043 	ldrb.w	r3, [r8, #67]	; 0x43
            pNetIf->Flags.bMacInitDone = false;
    f232:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    f236:	f36f 13c7 	bfc	r3, #7, #1
    f23a:	f888 3043 	strb.w	r3, [r8, #67]	; 0x43
    netUpFail = false;
    f23e:	2400      	movs	r4, #0
    f240:	e00c      	b.n	f25c <TCPIP_STACK_BringNetUp+0x1bc>
                    SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "%s MAC event notification setting failed\r\n", pNetIf->pMacObj->macName);
    f242:	f015 f81d 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    f246:	b158      	cbz	r0, f260 <TCPIP_STACK_BringNetUp+0x1c0>
    f248:	f015 f814 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    f24c:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
    f250:	685a      	ldr	r2, [r3, #4]
    f252:	4921      	ldr	r1, [pc, #132]	; (f2d8 <TCPIP_STACK_BringNetUp+0x238>)
    f254:	f00d fa22 	bl	1c69c <SYS_CONSOLE_Print>
    f258:	e002      	b.n	f260 <TCPIP_STACK_BringNetUp+0x1c0>
    netUpFail = false;
    f25a:	2400      	movs	r4, #0
    if(netUpFail)
    f25c:	f084 0401 	eor.w	r4, r4, #1
}
    f260:	4620      	mov	r0, r4
    f262:	b015      	add	sp, #84	; 0x54
    f264:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(pModConfig->moduleId == moduleId)
    f268:	462b      	mov	r3, r5
                    configData = pConfig->configData;
    f26a:	6859      	ldr	r1, [r3, #4]
            if(!pEntry->initFunc(stackCtrlData, configData))
    f26c:	6863      	ldr	r3, [r4, #4]
    f26e:	4630      	mov	r0, r6
    f270:	4798      	blx	r3
    f272:	2800      	cmp	r0, #0
    f274:	d0c2      	beq.n	f1fc <TCPIP_STACK_BringNetUp+0x15c>
            pEntry++;
    f276:	340c      	adds	r4, #12
        for(modIx = 0; modIx < sizeof(TCPIP_STACK_MODULE_ENTRY_TBL)/sizeof(*TCPIP_STACK_MODULE_ENTRY_TBL); modIx++)
    f278:	454c      	cmp	r4, r9
    f27a:	d0cc      	beq.n	f216 <TCPIP_STACK_BringNetUp+0x176>
            if (pModConfig != 0)
    f27c:	2d00      	cmp	r5, #0
    f27e:	d0b9      	beq.n	f1f4 <TCPIP_STACK_BringNetUp+0x154>
                pConfig = _TCPIP_STACK_FindModuleData(pEntry->moduleId, pModConfig, nModules);
    f280:	8821      	ldrh	r1, [r4, #0]
    while(nModules--)
    f282:	2f00      	cmp	r7, #0
    f284:	d0b8      	beq.n	f1f8 <TCPIP_STACK_BringNetUp+0x158>
        if(pModConfig->moduleId == moduleId)
    f286:	882b      	ldrh	r3, [r5, #0]
    f288:	428b      	cmp	r3, r1
    f28a:	d0ed      	beq.n	f268 <TCPIP_STACK_BringNetUp+0x1c8>
    f28c:	1eba      	subs	r2, r7, #2
    f28e:	462b      	mov	r3, r5
        pModConfig++;
    f290:	3308      	adds	r3, #8
    while(nModules--)
    f292:	f1b2 3fff 	cmp.w	r2, #4294967295
    f296:	d0ab      	beq.n	f1f0 <TCPIP_STACK_BringNetUp+0x150>
        if(pModConfig->moduleId == moduleId)
    f298:	3a01      	subs	r2, #1
    f29a:	8818      	ldrh	r0, [r3, #0]
    f29c:	4288      	cmp	r0, r1
    f29e:	d1f7      	bne.n	f290 <TCPIP_STACK_BringNetUp+0x1f0>
    f2a0:	e7e3      	b.n	f26a <TCPIP_STACK_BringNetUp+0x1ca>
    f2a2:	4613      	mov	r3, r2
    f2a4:	e723      	b.n	f0ee <TCPIP_STACK_BringNetUp+0x4e>
    f2a6:	bf00      	nop
    f2a8:	0001b948 	.word	0x0001b948
    f2ac:	00024391 	.word	0x00024391
    f2b0:	00024399 	.word	0x00024399
    f2b4:	000243a1 	.word	0x000243a1
    f2b8:	0001ab05 	.word	0x0001ab05
    f2bc:	00020171 	.word	0x00020171
    f2c0:	0001faa5 	.word	0x0001faa5
    f2c4:	0001bfb3 	.word	0x0001bfb3
    f2c8:	0001e8c1 	.word	0x0001e8c1
    f2cc:	00009424 	.word	0x00009424
    f2d0:	000093f4 	.word	0x000093f4
    f2d4:	00009448 	.word	0x00009448
    f2d8:	0000947c 	.word	0x0000947c

Disassembly of section .text.TCPIP_IPV4_Task%256:

0000f2dc <TCPIP_IPV4_Task>:
    TCPIP_Helper_ProtectedSingleListUnlock(&ipv4ArpQueue);

}

void  TCPIP_IPV4_Task(void)
{
    f2dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f2e0:	b087      	sub	sp, #28
    TCPIP_MODULE_SIGNAL sigPend;

    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    f2e2:	210f      	movs	r1, #15
    f2e4:	2003      	movs	r0, #3
    f2e6:	f010 ff25 	bl	20134 <_TCPIPStackModuleSignalGet>

    if((sigPend & TCPIP_MODULE_SIGNAL_RX_PENDING) != 0)
    f2ea:	f010 0f01 	tst.w	r0, #1
    f2ee:	d102      	bne.n	f2f6 <TCPIP_IPV4_Task+0x1a>
    { // regular TMO occurred
        TCPIP_IPV4_Timeout();
    }
#endif  // (_TCPIP_IPV4_FRAGMENTATION != 0)

}
    f2f0:	b007      	add	sp, #28
    f2f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    uint32_t cnt1, cnt2;

    // get a consistent reading
    do
    {
        cnt1 = ipv4ActFilterCount;
    f2f6:	f8df 8214 	ldr.w	r8, [pc, #532]	; f50c <TCPIP_IPV4_Task+0x230>
  Remarks:
    None
*/
static __inline__ void __attribute__((always_inline)) TCPIP_Notification_Lock(PROTECTED_SINGLE_LIST* notifyList)
{
    TCPIP_Helper_ProtectedSingleListLock(notifyList);
    f2fa:	4f81      	ldr	r7, [pc, #516]	; (f500 <TCPIP_IPV4_Task+0x224>)
        return TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    f2fc:	f06f 090e 	mvn.w	r9, #14
    f300:	e0b8      	b.n	f474 <TCPIP_IPV4_Task+0x198>
            payloadLen = TCPIP_PKT_PayloadLen(pRxPkt);
    f302:	4628      	mov	r0, r5
    f304:	f013 fde7 	bl	22ed6 <TCPIP_PKT_PayloadLen>
            if(totalLength > payloadLen)
    f308:	4582      	cmp	sl, r0
    f30a:	f200 80df 	bhi.w	f4cc <TCPIP_IPV4_Task+0x1f0>
            pNetIf = _TCPIPStackMapAliasInterface((TCPIP_NET_IF*)pRxPkt->pktIf, &pHeader->DestAddress);
    f30e:	f8d5 a028 	ldr.w	sl, [r5, #40]	; 0x28
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
    f312:	f1ba 0f00 	cmp.w	sl, #0
    f316:	f000 80e8 	beq.w	f4ea <TCPIP_IPV4_Task+0x20e>
    f31a:	f89a 3042 	ldrb.w	r3, [sl, #66]	; 0x42
    f31e:	f013 0f40 	tst.w	r3, #64	; 0x40
    f322:	d102      	bne.n	f32a <TCPIP_IPV4_Task+0x4e>
                ackRes = TCPIP_MAC_PKT_ACK_IP_REJECT_ERR;
    f324:	f06f 0112 	mvn.w	r1, #18
    f328:	e0a0      	b.n	f46c <TCPIP_IPV4_Task+0x190>
    return (pIpAdd->Val == 0xFFFFFFFF) ||  (pIpAdd->Val == (pNetIf->netIPAddr.Val | ~pNetIf->netMask.Val));
    f32a:	68f3      	ldr	r3, [r6, #12]
    f32c:	f1b3 3fff 	cmp.w	r3, #4294967295
    f330:	f000 80cf 	beq.w	f4d2 <TCPIP_IPV4_Task+0x1f6>
    f334:	f8da 1008 	ldr.w	r1, [sl, #8]
    f338:	f8da 2004 	ldr.w	r2, [sl, #4]
    f33c:	ea62 0201 	orn	r2, r2, r1
            if(_TCPIPStack_IsBcastAddress(pNetIf, &pHeader->SourceAddress))
    f340:	4293      	cmp	r3, r2
    f342:	f000 80c9 	beq.w	f4d8 <TCPIP_IPV4_Task+0x1fc>
            if(pHeader->DestAddress.Val == 0)
    f346:	6933      	ldr	r3, [r6, #16]
    f348:	b913      	cbnz	r3, f350 <TCPIP_IPV4_Task+0x74>
                ackRes = TCPIP_MAC_PKT_ACK_DEST_ERR;
    f34a:	f06f 010b 	mvn.w	r1, #11
    f34e:	e08d      	b.n	f46c <TCPIP_IPV4_Task+0x190>
            headerChecksum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pHeader, headerLen, 0);
    f350:	2200      	movs	r2, #0
    f352:	4659      	mov	r1, fp
    f354:	4630      	mov	r0, r6
    f356:	f00c ff7f 	bl	1c258 <TCPIP_Helper_CalcIPChecksum>
            if(headerChecksum)
    f35a:	2800      	cmp	r0, #0
    f35c:	f040 80bf 	bne.w	f4de <TCPIP_IPV4_Task+0x202>
            cIpv4Hdr = *pHeader;
    f360:	f10d 0c04 	add.w	ip, sp, #4
    f364:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    f366:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    f36a:	6833      	ldr	r3, [r6, #0]
    f36c:	f8cc 3000 	str.w	r3, [ip]
            pCHeader->FragmentInfo.val = TCPIP_Helper_ntohs(pCHeader->FragmentInfo.val);
    f370:	f8bd 200a 	ldrh.w	r2, [sp, #10]
    f374:	0a13      	lsrs	r3, r2, #8
    f376:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
            if(pCHeader->FragmentInfo.MF != 0 || pCHeader->FragmentInfo.fragOffset != 0)
    f37a:	f3c3 030d 	ubfx	r3, r3, #0, #14
    f37e:	2b00      	cmp	r3, #0
    f380:	f040 80b0 	bne.w	f4e4 <TCPIP_IPV4_Task+0x208>
    return ((pIf->netIPAddr.Val ^ pIpAddress->Val) & pIf->netMask.Val) == 0;
    f384:	f8da 0004 	ldr.w	r0, [sl, #4]
    f388:	9b05      	ldr	r3, [sp, #20]
    f38a:	f8da 2008 	ldr.w	r2, [sl, #8]
            if(_TCPIPStackHostPartAddress(pNetIf, pktDestIP) == 0)
    f38e:	ea00 0102 	and.w	r1, r0, r2
    f392:	428b      	cmp	r3, r1
    f394:	d01a      	beq.n	f3cc <TCPIP_IPV4_Task+0xf0>
        currFilter = ipv4FilterType;
    f396:	495b      	ldr	r1, [pc, #364]	; (f504 <TCPIP_IPV4_Task+0x228>)
    f398:	7809      	ldrb	r1, [r1, #0]
    return (pIpAdd->Val == 0xFFFFFFFF) ||  (pIpAdd->Val == (pNetIf->netIPAddr.Val | ~pNetIf->netMask.Val));
    f39a:	f1b3 3fff 	cmp.w	r3, #4294967295
    f39e:	d012      	beq.n	f3c6 <TCPIP_IPV4_Task+0xea>
    f3a0:	ea60 0202 	orn	r2, r0, r2
        if(_TCPIPStack_IsBcastAddress(pNetIf, pktDestIP))
    f3a4:	4293      	cmp	r3, r2
    f3a6:	d00e      	beq.n	f3c6 <TCPIP_IPV4_Task+0xea>
        if(TCPIP_Helper_IsMcastAddress(pktDestIP))
    f3a8:	f89d 2014 	ldrb.w	r2, [sp, #20]
    f3ac:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
    f3b0:	2ae0      	cmp	r2, #224	; 0xe0
    f3b2:	d015      	beq.n	f3e0 <TCPIP_IPV4_Task+0x104>
    return (pIpAdd->Val == 0x0100007f || pNetIf->netIPAddr.Val == pIpAdd->Val);
    f3b4:	4a54      	ldr	r2, [pc, #336]	; (f508 <TCPIP_IPV4_Task+0x22c>)
    f3b6:	4293      	cmp	r3, r2
    f3b8:	d001      	beq.n	f3be <TCPIP_IPV4_Task+0xe2>
        if(TCPIP_STACK_AddressIsOfNet(pNetIf, pktDestIP))
    f3ba:	4298      	cmp	r0, r3
    f3bc:	d106      	bne.n	f3cc <TCPIP_IPV4_Task+0xf0>
            procType = ((currFilter & TCPIP_IPV4_FILTER_UNICAST) == 0) ? (IPV4_PKT_DEST_HOST | IPV4_PKT_TYPE_UNICAST) : (IPV4_PKT_TYPE_UNICAST);
    f3be:	f011 0f01 	tst.w	r1, #1
    f3c2:	d103      	bne.n	f3cc <TCPIP_IPV4_Task+0xf0>
    f3c4:	e00f      	b.n	f3e6 <TCPIP_IPV4_Task+0x10a>
            procType = ((currFilter & TCPIP_IPV4_FILTER_BROADCAST) == 0) ? (IPV4_PKT_DEST_HOST | IPV4_PKT_TYPE_BCAST) : (IPV4_PKT_TYPE_BCAST);
    f3c6:	f011 0f02 	tst.w	r1, #2
    f3ca:	d00c      	beq.n	f3e6 <TCPIP_IPV4_Task+0x10a>
        cnt1 = ipv4ActFilterCount;
    f3cc:	f8d8 2000 	ldr.w	r2, [r8]
        cnt2 = ipv4ActFilterCount;
    f3d0:	f8d8 3000 	ldr.w	r3, [r8]
    }while(cnt1 != cnt2);
    f3d4:	429a      	cmp	r2, r3
    f3d6:	d1f9      	bne.n	f3cc <TCPIP_IPV4_Task+0xf0>


    _IPv4FiltCountDbg("verify");
    if(cnt1 != 0)
    f3d8:	bb53      	cbnz	r3, f430 <TCPIP_IPV4_Task+0x154>
                ackRes = TCPIP_MAC_PKT_ACK_IP_REJECT_ERR;
    f3da:	f06f 0112 	mvn.w	r1, #18
    f3de:	e045      	b.n	f46c <TCPIP_IPV4_Task+0x190>
            procType = ((currFilter & TCPIP_IPV4_FILTER_MULTICAST) == 0) ? (IPV4_PKT_DEST_HOST | IPV4_PKT_TYPE_MCAST) : (IPV4_PKT_TYPE_MCAST);
    f3e0:	f011 0f04 	tst.w	r1, #4
    f3e4:	d1f2      	bne.n	f3cc <TCPIP_IPV4_Task+0xf0>
    pHeader = (IPV4_HEADER*)pRxPkt->pNetLayer;
    f3e6:	69a9      	ldr	r1, [r5, #24]
    headerLen = pHeader->IHL << 2;
    f3e8:	780b      	ldrb	r3, [r1, #0]
    f3ea:	009b      	lsls	r3, r3, #2
    f3ec:	f003 033c 	and.w	r3, r3, #60	; 0x3c
    pRxPkt->pTransportLayer = pRxPkt->pNetLayer + headerLen;
    f3f0:	18ca      	adds	r2, r1, r3
    f3f2:	61ea      	str	r2, [r5, #28]
    pRxPkt->pDSeg->segLen -= headerLen;
    f3f4:	6928      	ldr	r0, [r5, #16]
    f3f6:	b29b      	uxth	r3, r3
    f3f8:	8982      	ldrh	r2, [r0, #12]
    f3fa:	1ad2      	subs	r2, r2, r3
    f3fc:	8182      	strh	r2, [r0, #12]
    pHeader->TotalLength = TCPIP_Helper_ntohs(pHeader->TotalLength);
    f3fe:	8848      	ldrh	r0, [r1, #2]
    f400:	0a02      	lsrs	r2, r0, #8
    f402:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
    f406:	b292      	uxth	r2, r2
    f408:	804a      	strh	r2, [r1, #2]
    pRxPkt->totTransportLen = pHeader->TotalLength - headerLen;
    f40a:	1ad3      	subs	r3, r2, r3
    f40c:	842b      	strh	r3, [r5, #32]
    pHeader->FragmentInfo.val = TCPIP_Helper_ntohs(pHeader->FragmentInfo.val);
    f40e:	88ca      	ldrh	r2, [r1, #6]
    f410:	0a13      	lsrs	r3, r2, #8
    f412:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    f416:	b29b      	uxth	r3, r3
    f418:	80cb      	strh	r3, [r1, #6]
    isFragment = pHeader->FragmentInfo.MF != 0 || pHeader->FragmentInfo.fragOffset != 0;
    f41a:	f3c3 030d 	ubfx	r3, r3, #0, #14
    switch(pHeader->Protocol)
    f41e:	7a4a      	ldrb	r2, [r1, #9]
    f420:	2a06      	cmp	r2, #6
    f422:	d065      	beq.n	f4f0 <TCPIP_IPV4_Task+0x214>
    f424:	2a11      	cmp	r2, #17
    f426:	d065      	beq.n	f4f4 <TCPIP_IPV4_Task+0x218>
    f428:	2a01      	cmp	r2, #1
    f42a:	d016      	beq.n	f45a <TCPIP_IPV4_Task+0x17e>
        return TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    f42c:	4649      	mov	r1, r9
    f42e:	e01d      	b.n	f46c <TCPIP_IPV4_Task+0x190>
    f430:	4638      	mov	r0, r7
    f432:	f013 fbd5 	bl	22be0 <TCPIP_Helper_ProtectedSingleListLock>
    {   // active filters
        TCPIP_Notification_Lock(&ipv4PacketFilters);
        for(fNode = (IPV4_FILTER_LIST_NODE*)ipv4PacketFilters.list.head; fNode != 0; fNode = fNode->next)
    f436:	683e      	ldr	r6, [r7, #0]
    f438:	e000      	b.n	f43c <TCPIP_IPV4_Task+0x160>
    f43a:	6836      	ldr	r6, [r6, #0]
    f43c:	2e00      	cmp	r6, #0
    f43e:	d05b      	beq.n	f4f8 <TCPIP_IPV4_Task+0x21c>
        {
            if(fNode->active != 0)
    f440:	7a33      	ldrb	r3, [r6, #8]
    f442:	2b00      	cmp	r3, #0
    f444:	d0f9      	beq.n	f43a <TCPIP_IPV4_Task+0x15e>
            {
                if((*fNode->handler)(pRxPkt, hdrlen))
    f446:	6873      	ldr	r3, [r6, #4]
    f448:	4621      	mov	r1, r4
    f44a:	4628      	mov	r0, r5
    f44c:	4798      	blx	r3
    f44e:	2800      	cmp	r0, #0
    f450:	d0f3      	beq.n	f43a <TCPIP_IPV4_Task+0x15e>
  Remarks:
    None
*/
static __inline__ void __attribute__((always_inline)) TCPIP_Notification_Unlock(PROTECTED_SINGLE_LIST* notifyList)
{
    TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
    f452:	4638      	mov	r0, r7
    f454:	f013 fe16 	bl	23084 <TCPIP_Helper_ProtectedSingleListUnlock>
            }
        }
        TCPIP_Notification_Unlock(&ipv4PacketFilters);
    }
        
    return pktOk;
    f458:	e7c5      	b.n	f3e6 <TCPIP_IPV4_Task+0x10a>
            destId = TCPIP_MODULE_ICMP;
    f45a:	2006      	movs	r0, #6
    if(!isFragment)
    f45c:	b953      	cbnz	r3, f474 <TCPIP_IPV4_Task+0x198>
        _TCPIPStackModuleRxInsert(destId, pRxPkt, true);
    f45e:	2201      	movs	r2, #1
    f460:	4629      	mov	r1, r5
    f462:	f010 f80b 	bl	1f47c <_TCPIPStackModuleRxInsert>
    f466:	e005      	b.n	f474 <TCPIP_IPV4_Task+0x198>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    f468:	f06f 010d 	mvn.w	r1, #13
            TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes); 
    f46c:	2203      	movs	r2, #3
    f46e:	4628      	mov	r0, r5
    f470:	f010 fb18 	bl	1faa4 <_TCPIP_PKT_PacketAcknowledge>
    while((pRxPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
    f474:	2003      	movs	r0, #3
    f476:	f012 fad3 	bl	21a20 <_TCPIPStackModuleRxExtract>
    f47a:	4605      	mov	r5, r0
    f47c:	2800      	cmp	r0, #0
    f47e:	f43f af37 	beq.w	f2f0 <TCPIP_IPV4_Task+0x14>
            pHeader = (IPV4_HEADER*)pRxPkt->pNetLayer;
    f482:	69ae      	ldr	r6, [r5, #24]
            if((pHeader->Version) != IPv4_VERSION)
    f484:	7833      	ldrb	r3, [r6, #0]
    f486:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    f48a:	2b40      	cmp	r3, #64	; 0x40
    f48c:	d1ec      	bne.n	f468 <TCPIP_IPV4_Task+0x18c>
            headerLen = pHeader->IHL << 2;
    f48e:	7834      	ldrb	r4, [r6, #0]
    f490:	00a4      	lsls	r4, r4, #2
    f492:	f004 043c 	and.w	r4, r4, #60	; 0x3c
            if(headerLen < sizeof(IPV4_HEADER) || (uint16_t)headerLen > pRxPkt->pDSeg->segLen)
    f496:	2c13      	cmp	r4, #19
    f498:	d912      	bls.n	f4c0 <TCPIP_IPV4_Task+0x1e4>
    f49a:	fa1f fb84 	uxth.w	fp, r4
    f49e:	692b      	ldr	r3, [r5, #16]
    f4a0:	899b      	ldrh	r3, [r3, #12]
    f4a2:	455b      	cmp	r3, fp
    f4a4:	d30f      	bcc.n	f4c6 <TCPIP_IPV4_Task+0x1ea>
            totalLength = TCPIP_Helper_ntohs(pHeader->TotalLength);
    f4a6:	8873      	ldrh	r3, [r6, #2]
    f4a8:	ea4f 2a13 	mov.w	sl, r3, lsr #8
    f4ac:	ea4a 2a03 	orr.w	sl, sl, r3, lsl #8
    f4b0:	fa1f fa8a 	uxth.w	sl, sl
            if(totalLength < (uint16_t)headerLen)
    f4b4:	45d3      	cmp	fp, sl
    f4b6:	f67f af24 	bls.w	f302 <TCPIP_IPV4_Task+0x26>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    f4ba:	f06f 010d 	mvn.w	r1, #13
    f4be:	e7d5      	b.n	f46c <TCPIP_IPV4_Task+0x190>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    f4c0:	f06f 010d 	mvn.w	r1, #13
    f4c4:	e7d2      	b.n	f46c <TCPIP_IPV4_Task+0x190>
    f4c6:	f06f 010d 	mvn.w	r1, #13
    f4ca:	e7cf      	b.n	f46c <TCPIP_IPV4_Task+0x190>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    f4cc:	f06f 010d 	mvn.w	r1, #13
    f4d0:	e7cc      	b.n	f46c <TCPIP_IPV4_Task+0x190>
                ackRes = TCPIP_MAC_PKT_ACK_SOURCE_ERR;
    f4d2:	f06f 010a 	mvn.w	r1, #10
    f4d6:	e7c9      	b.n	f46c <TCPIP_IPV4_Task+0x190>
    f4d8:	f06f 010a 	mvn.w	r1, #10
    f4dc:	e7c6      	b.n	f46c <TCPIP_IPV4_Task+0x190>
                ackRes = TCPIP_MAC_PKT_ACK_CHKSUM_ERR;
    f4de:	f06f 0109 	mvn.w	r1, #9
    f4e2:	e7c3      	b.n	f46c <TCPIP_IPV4_Task+0x190>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    f4e4:	f06f 010d 	mvn.w	r1, #13
    f4e8:	e7c0      	b.n	f46c <TCPIP_IPV4_Task+0x190>
                ackRes = TCPIP_MAC_PKT_ACK_IP_REJECT_ERR;
    f4ea:	f06f 0112 	mvn.w	r1, #18
        if(ackRes != TCPIP_MAC_PKT_ACK_NONE)
    f4ee:	e7bd      	b.n	f46c <TCPIP_IPV4_Task+0x190>
            destId = TCPIP_MODULE_TCP;
    f4f0:	200a      	movs	r0, #10
    f4f2:	e7b3      	b.n	f45c <TCPIP_IPV4_Task+0x180>
            destId = TCPIP_MODULE_UDP;
    f4f4:	2009      	movs	r0, #9
    if(destId == TCPIP_MODULE_NONE)
    f4f6:	e7b1      	b.n	f45c <TCPIP_IPV4_Task+0x180>
    f4f8:	4638      	mov	r0, r7
    f4fa:	f013 fdc3 	bl	23084 <TCPIP_Helper_ProtectedSingleListUnlock>
    return pktOk;
    f4fe:	e76c      	b.n	f3da <TCPIP_IPV4_Task+0xfe>
    f500:	2000ec50 	.word	0x2000ec50
    f504:	2000ef8a 	.word	0x2000ef8a
    f508:	0100007f 	.word	0x0100007f
    f50c:	2000ee28 	.word	0x2000ee28

Disassembly of section .text._printf_i%257:

0000f510 <_printf_i>:
    f510:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    f514:	4606      	mov	r6, r0
    f516:	460c      	mov	r4, r1
    f518:	f101 0043 	add.w	r0, r1, #67	; 0x43
    f51c:	7e09      	ldrb	r1, [r1, #24]
    f51e:	b085      	sub	sp, #20
    f520:	296e      	cmp	r1, #110	; 0x6e
    f522:	4698      	mov	r8, r3
    f524:	4617      	mov	r7, r2
    f526:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    f528:	f000 80ba 	beq.w	f6a0 <_printf_i+0x190>
    f52c:	d824      	bhi.n	f578 <_printf_i+0x68>
    f52e:	2963      	cmp	r1, #99	; 0x63
    f530:	d039      	beq.n	f5a6 <_printf_i+0x96>
    f532:	d80a      	bhi.n	f54a <_printf_i+0x3a>
    f534:	2900      	cmp	r1, #0
    f536:	f000 80c3 	beq.w	f6c0 <_printf_i+0x1b0>
    f53a:	2958      	cmp	r1, #88	; 0x58
    f53c:	f000 8091 	beq.w	f662 <_printf_i+0x152>
    f540:	f104 0542 	add.w	r5, r4, #66	; 0x42
    f544:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
    f548:	e035      	b.n	f5b6 <_printf_i+0xa6>
    f54a:	2964      	cmp	r1, #100	; 0x64
    f54c:	d001      	beq.n	f552 <_printf_i+0x42>
    f54e:	2969      	cmp	r1, #105	; 0x69
    f550:	d1f6      	bne.n	f540 <_printf_i+0x30>
    f552:	6825      	ldr	r5, [r4, #0]
    f554:	681a      	ldr	r2, [r3, #0]
    f556:	f015 0f80 	tst.w	r5, #128	; 0x80
    f55a:	f102 0104 	add.w	r1, r2, #4
    f55e:	d02c      	beq.n	f5ba <_printf_i+0xaa>
    f560:	6812      	ldr	r2, [r2, #0]
    f562:	6019      	str	r1, [r3, #0]
    f564:	2a00      	cmp	r2, #0
    f566:	da03      	bge.n	f570 <_printf_i+0x60>
    f568:	232d      	movs	r3, #45	; 0x2d
    f56a:	4252      	negs	r2, r2
    f56c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    f570:	f8df c1bc 	ldr.w	ip, [pc, #444]	; f730 <_printf_i+0x220>
    f574:	230a      	movs	r3, #10
    f576:	e03f      	b.n	f5f8 <_printf_i+0xe8>
    f578:	2973      	cmp	r1, #115	; 0x73
    f57a:	f000 80a5 	beq.w	f6c8 <_printf_i+0x1b8>
    f57e:	d808      	bhi.n	f592 <_printf_i+0x82>
    f580:	296f      	cmp	r1, #111	; 0x6f
    f582:	d021      	beq.n	f5c8 <_printf_i+0xb8>
    f584:	2970      	cmp	r1, #112	; 0x70
    f586:	d1db      	bne.n	f540 <_printf_i+0x30>
    f588:	6822      	ldr	r2, [r4, #0]
    f58a:	f042 0220 	orr.w	r2, r2, #32
    f58e:	6022      	str	r2, [r4, #0]
    f590:	e003      	b.n	f59a <_printf_i+0x8a>
    f592:	2975      	cmp	r1, #117	; 0x75
    f594:	d018      	beq.n	f5c8 <_printf_i+0xb8>
    f596:	2978      	cmp	r1, #120	; 0x78
    f598:	d1d2      	bne.n	f540 <_printf_i+0x30>
    f59a:	2278      	movs	r2, #120	; 0x78
    f59c:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
    f5a0:	f8df c190 	ldr.w	ip, [pc, #400]	; f734 <_printf_i+0x224>
    f5a4:	e061      	b.n	f66a <_printf_i+0x15a>
    f5a6:	681a      	ldr	r2, [r3, #0]
    f5a8:	1d11      	adds	r1, r2, #4
    f5aa:	6019      	str	r1, [r3, #0]
    f5ac:	6813      	ldr	r3, [r2, #0]
    f5ae:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    f5b2:	f104 0542 	add.w	r5, r4, #66	; 0x42
    f5b6:	2301      	movs	r3, #1
    f5b8:	e093      	b.n	f6e2 <_printf_i+0x1d2>
    f5ba:	6812      	ldr	r2, [r2, #0]
    f5bc:	6019      	str	r1, [r3, #0]
    f5be:	f015 0f40 	tst.w	r5, #64	; 0x40
    f5c2:	bf18      	it	ne
    f5c4:	b212      	sxthne	r2, r2
    f5c6:	e7cd      	b.n	f564 <_printf_i+0x54>
    f5c8:	f8d4 c000 	ldr.w	ip, [r4]
    f5cc:	681a      	ldr	r2, [r3, #0]
    f5ce:	f01c 0f80 	tst.w	ip, #128	; 0x80
    f5d2:	f102 0504 	add.w	r5, r2, #4
    f5d6:	601d      	str	r5, [r3, #0]
    f5d8:	d001      	beq.n	f5de <_printf_i+0xce>
    f5da:	6812      	ldr	r2, [r2, #0]
    f5dc:	e003      	b.n	f5e6 <_printf_i+0xd6>
    f5de:	f01c 0f40 	tst.w	ip, #64	; 0x40
    f5e2:	d0fa      	beq.n	f5da <_printf_i+0xca>
    f5e4:	8812      	ldrh	r2, [r2, #0]
    f5e6:	f8df c148 	ldr.w	ip, [pc, #328]	; f730 <_printf_i+0x220>
    f5ea:	296f      	cmp	r1, #111	; 0x6f
    f5ec:	bf0c      	ite	eq
    f5ee:	2308      	moveq	r3, #8
    f5f0:	230a      	movne	r3, #10
    f5f2:	2100      	movs	r1, #0
    f5f4:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
    f5f8:	6865      	ldr	r5, [r4, #4]
    f5fa:	60a5      	str	r5, [r4, #8]
    f5fc:	2d00      	cmp	r5, #0
    f5fe:	bfa2      	ittt	ge
    f600:	6821      	ldrge	r1, [r4, #0]
    f602:	f021 0104 	bicge.w	r1, r1, #4
    f606:	6021      	strge	r1, [r4, #0]
    f608:	b90a      	cbnz	r2, f60e <_printf_i+0xfe>
    f60a:	2d00      	cmp	r5, #0
    f60c:	d046      	beq.n	f69c <_printf_i+0x18c>
    f60e:	4605      	mov	r5, r0
    f610:	fbb2 f1f3 	udiv	r1, r2, r3
    f614:	fb03 2e11 	mls	lr, r3, r1, r2
    f618:	4293      	cmp	r3, r2
    f61a:	f81c e00e 	ldrb.w	lr, [ip, lr]
    f61e:	f805 ed01 	strb.w	lr, [r5, #-1]!
    f622:	d939      	bls.n	f698 <_printf_i+0x188>
    f624:	2b08      	cmp	r3, #8
    f626:	d10b      	bne.n	f640 <_printf_i+0x130>
    f628:	6823      	ldr	r3, [r4, #0]
    f62a:	07da      	lsls	r2, r3, #31
    f62c:	d508      	bpl.n	f640 <_printf_i+0x130>
    f62e:	6923      	ldr	r3, [r4, #16]
    f630:	6862      	ldr	r2, [r4, #4]
    f632:	429a      	cmp	r2, r3
    f634:	bfde      	ittt	le
    f636:	2330      	movle	r3, #48	; 0x30
    f638:	f805 3c01 	strble.w	r3, [r5, #-1]
    f63c:	f105 35ff 	addle.w	r5, r5, #4294967295
    f640:	1b40      	subs	r0, r0, r5
    f642:	6120      	str	r0, [r4, #16]
    f644:	f8cd 8000 	str.w	r8, [sp]
    f648:	463b      	mov	r3, r7
    f64a:	aa03      	add	r2, sp, #12
    f64c:	4621      	mov	r1, r4
    f64e:	4630      	mov	r0, r6
    f650:	f006 ffb4 	bl	165bc <_printf_common>
    f654:	3001      	adds	r0, #1
    f656:	d149      	bne.n	f6ec <_printf_i+0x1dc>
    f658:	f04f 30ff 	mov.w	r0, #4294967295
    f65c:	b005      	add	sp, #20
    f65e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    f662:	f8df c0cc 	ldr.w	ip, [pc, #204]	; f730 <_printf_i+0x220>
    f666:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
    f66a:	681d      	ldr	r5, [r3, #0]
    f66c:	6821      	ldr	r1, [r4, #0]
    f66e:	f855 2b04 	ldr.w	r2, [r5], #4
    f672:	601d      	str	r5, [r3, #0]
    f674:	060d      	lsls	r5, r1, #24
    f676:	d50b      	bpl.n	f690 <_printf_i+0x180>
    f678:	07cd      	lsls	r5, r1, #31
    f67a:	bf44      	itt	mi
    f67c:	f041 0120 	orrmi.w	r1, r1, #32
    f680:	6021      	strmi	r1, [r4, #0]
    f682:	b91a      	cbnz	r2, f68c <_printf_i+0x17c>
    f684:	6823      	ldr	r3, [r4, #0]
    f686:	f023 0320 	bic.w	r3, r3, #32
    f68a:	6023      	str	r3, [r4, #0]
    f68c:	2310      	movs	r3, #16
    f68e:	e7b0      	b.n	f5f2 <_printf_i+0xe2>
    f690:	064b      	lsls	r3, r1, #25
    f692:	bf48      	it	mi
    f694:	b292      	uxthmi	r2, r2
    f696:	e7ef      	b.n	f678 <_printf_i+0x168>
    f698:	460a      	mov	r2, r1
    f69a:	e7b9      	b.n	f610 <_printf_i+0x100>
    f69c:	4605      	mov	r5, r0
    f69e:	e7c1      	b.n	f624 <_printf_i+0x114>
    f6a0:	681a      	ldr	r2, [r3, #0]
    f6a2:	f8d4 c000 	ldr.w	ip, [r4]
    f6a6:	6961      	ldr	r1, [r4, #20]
    f6a8:	1d15      	adds	r5, r2, #4
    f6aa:	601d      	str	r5, [r3, #0]
    f6ac:	f01c 0f80 	tst.w	ip, #128	; 0x80
    f6b0:	6813      	ldr	r3, [r2, #0]
    f6b2:	d001      	beq.n	f6b8 <_printf_i+0x1a8>
    f6b4:	6019      	str	r1, [r3, #0]
    f6b6:	e003      	b.n	f6c0 <_printf_i+0x1b0>
    f6b8:	f01c 0f40 	tst.w	ip, #64	; 0x40
    f6bc:	d0fa      	beq.n	f6b4 <_printf_i+0x1a4>
    f6be:	8019      	strh	r1, [r3, #0]
    f6c0:	2300      	movs	r3, #0
    f6c2:	6123      	str	r3, [r4, #16]
    f6c4:	4605      	mov	r5, r0
    f6c6:	e7bd      	b.n	f644 <_printf_i+0x134>
    f6c8:	681a      	ldr	r2, [r3, #0]
    f6ca:	1d11      	adds	r1, r2, #4
    f6cc:	6019      	str	r1, [r3, #0]
    f6ce:	6815      	ldr	r5, [r2, #0]
    f6d0:	6862      	ldr	r2, [r4, #4]
    f6d2:	2100      	movs	r1, #0
    f6d4:	4628      	mov	r0, r5
    f6d6:	f009 ff83 	bl	195e0 <memchr>
    f6da:	b108      	cbz	r0, f6e0 <_printf_i+0x1d0>
    f6dc:	1b40      	subs	r0, r0, r5
    f6de:	6060      	str	r0, [r4, #4]
    f6e0:	6863      	ldr	r3, [r4, #4]
    f6e2:	6123      	str	r3, [r4, #16]
    f6e4:	2300      	movs	r3, #0
    f6e6:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    f6ea:	e7ab      	b.n	f644 <_printf_i+0x134>
    f6ec:	6923      	ldr	r3, [r4, #16]
    f6ee:	462a      	mov	r2, r5
    f6f0:	4639      	mov	r1, r7
    f6f2:	4630      	mov	r0, r6
    f6f4:	47c0      	blx	r8
    f6f6:	3001      	adds	r0, #1
    f6f8:	d0ae      	beq.n	f658 <_printf_i+0x148>
    f6fa:	6823      	ldr	r3, [r4, #0]
    f6fc:	079b      	lsls	r3, r3, #30
    f6fe:	d413      	bmi.n	f728 <_printf_i+0x218>
    f700:	68e0      	ldr	r0, [r4, #12]
    f702:	9b03      	ldr	r3, [sp, #12]
    f704:	4298      	cmp	r0, r3
    f706:	bfb8      	it	lt
    f708:	4618      	movlt	r0, r3
    f70a:	e7a7      	b.n	f65c <_printf_i+0x14c>
    f70c:	2301      	movs	r3, #1
    f70e:	464a      	mov	r2, r9
    f710:	4639      	mov	r1, r7
    f712:	4630      	mov	r0, r6
    f714:	47c0      	blx	r8
    f716:	3001      	adds	r0, #1
    f718:	d09e      	beq.n	f658 <_printf_i+0x148>
    f71a:	3501      	adds	r5, #1
    f71c:	68e3      	ldr	r3, [r4, #12]
    f71e:	9a03      	ldr	r2, [sp, #12]
    f720:	1a9b      	subs	r3, r3, r2
    f722:	42ab      	cmp	r3, r5
    f724:	dcf2      	bgt.n	f70c <_printf_i+0x1fc>
    f726:	e7eb      	b.n	f700 <_printf_i+0x1f0>
    f728:	2500      	movs	r5, #0
    f72a:	f104 0919 	add.w	r9, r4, #25
    f72e:	e7f5      	b.n	f71c <_printf_i+0x20c>
    f730:	0002295c 	.word	0x0002295c
    f734:	0002296d 	.word	0x0002296d

Disassembly of section .text.TCPIP_UDP_Flush%258:

0000f738 <TCPIP_UDP_Flush>:
{
    f738:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    f73c:	b085      	sub	sp, #20
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
    f73e:	f012 fd05 	bl	2214c <_UDPSocketDcpt>
    if(pSkt && _UDPTxPktValid(pSkt))
    f742:	2800      	cmp	r0, #0
    f744:	f000 8101 	beq.w	f94a <TCPIP_UDP_Flush+0x212>
    f748:	4605      	mov	r5, r0
    f74a:	f013 fea3 	bl	23494 <_UDPTxPktValid>
    f74e:	2800      	cmp	r0, #0
    f750:	f000 8100 	beq.w	f954 <TCPIP_UDP_Flush+0x21c>
        if(pSkt->flags.txSplitAlloc == 0)
    f754:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    f758:	f013 0f02 	tst.w	r3, #2
    f75c:	f040 80b9 	bne.w	f8d2 <TCPIP_UDP_Flush+0x19a>
            payload = pSkt->txWrite - pSkt->txStart;
    f760:	68ac      	ldr	r4, [r5, #8]
    f762:	682b      	ldr	r3, [r5, #0]
    f764:	1ae4      	subs	r4, r4, r3
    f766:	b2a4      	uxth	r4, r4
        if(payload)
    f768:	2c00      	cmp	r4, #0
    f76a:	f000 80ef 	beq.w	f94c <TCPIP_UDP_Flush+0x214>
            switch(pSkt->addType)
    f76e:	8fab      	ldrh	r3, [r5, #60]	; 0x3c
    f770:	2b01      	cmp	r3, #1
    return 0;
    f772:	bf18      	it	ne
    f774:	2400      	movne	r4, #0
            switch(pSkt->addType)
    f776:	f040 80e9 	bne.w	f94c <TCPIP_UDP_Flush+0x214>
    if(pSkt->destAddress.Val == 0)
    f77a:	696b      	ldr	r3, [r5, #20]
    f77c:	2b00      	cmp	r3, #0
    f77e:	f000 80e0 	beq.w	f942 <TCPIP_UDP_Flush+0x20a>
    if(pSkt->flags.srcSolved == 0 || pSkt->pSktNet == 0)
    f782:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
    f786:	f013 0f80 	tst.w	r3, #128	; 0x80
    f78a:	d001      	beq.n	f790 <TCPIP_UDP_Flush+0x58>
    f78c:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    f78e:	b992      	cbnz	r2, f7b6 <TCPIP_UDP_Flush+0x7e>
        pSkt->pSktNet = (TCPIP_NET_IF*)TCPIP_IPV4_SelectSourceInterface(pSkt->pSktNet, &pSkt->destAddress, &pSkt->srcAddress, pSkt->flags.srcValid != 0);
    f790:	f3c3 1380 	ubfx	r3, r3, #6, #1
    f794:	f105 0218 	add.w	r2, r5, #24
    f798:	f105 0114 	add.w	r1, r5, #20
    f79c:	6a68      	ldr	r0, [r5, #36]	; 0x24
    f79e:	f00f f927 	bl	1e9f0 <TCPIP_IPV4_SelectSourceInterface>
    f7a2:	6268      	str	r0, [r5, #36]	; 0x24
        if(pSkt->pSktNet == 0)
    f7a4:	2800      	cmp	r0, #0
    f7a6:	f000 80ce 	beq.w	f946 <TCPIP_UDP_Flush+0x20e>
        pSkt->flags.srcSolved = 1;
    f7aa:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
        pSkt->flags.srcValid = 1;
    f7ae:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
    f7b2:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
    if(pSkt->flags.bcastForceType == UDP_BCAST_NETWORK_DIRECTED)
    f7b6:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
    f7ba:	f003 0303 	and.w	r3, r3, #3
    f7be:	2b02      	cmp	r3, #2
    f7c0:	f000 808b 	beq.w	f8da <TCPIP_UDP_Flush+0x1a2>
    pv4Pkt = pSkt->pV4Pkt;
    f7c4:	68ee      	ldr	r6, [r5, #12]
    pv4Pkt->srcAddress.Val = pSkt->srcAddress.Val;
    f7c6:	69ab      	ldr	r3, [r5, #24]
    f7c8:	6373      	str	r3, [r6, #52]	; 0x34
    pv4Pkt->destAddress.Val = pSkt->destAddress.Val;
    f7ca:	696b      	ldr	r3, [r5, #20]
    f7cc:	63b3      	str	r3, [r6, #56]	; 0x38
    pv4Pkt->netIfH = pSkt->pSktNet;
    f7ce:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    f7d0:	63f3      	str	r3, [r6, #60]	; 0x3c
    pUDPHdr = (UDP_HEADER*)pv4Pkt->macPkt.pTransportLayer;
    f7d2:	69f7      	ldr	r7, [r6, #28]
    if(pSkt->flags.txSplitAlloc != 0)
    f7d4:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    f7d8:	f013 0f02 	tst.w	r3, #2
    f7dc:	f000 8082 	beq.w	f8e4 <TCPIP_UDP_Flush+0x1ac>
        pZSeg = ((UDP_V4_PACKET*)pv4Pkt)->zcSeg;
    f7e0:	f106 0944 	add.w	r9, r6, #68	; 0x44
        udpLoadLen = pZSeg->segLen;
    f7e4:	f8b6 4050 	ldrh.w	r4, [r6, #80]	; 0x50
        rootLen = sizeof(UDP_HEADER);
    f7e8:	2308      	movs	r3, #8
    pv4Pkt->macPkt.pDSeg->segLen += rootLen;
    f7ea:	6932      	ldr	r2, [r6, #16]
    f7ec:	8991      	ldrh	r1, [r2, #12]
    f7ee:	440b      	add	r3, r1
    f7f0:	8193      	strh	r3, [r2, #12]
    udpTotLen = udpLoadLen + sizeof(UDP_HEADER);
    f7f2:	f104 0808 	add.w	r8, r4, #8
    f7f6:	fa1f f888 	uxth.w	r8, r8
    pUDPHdr->SourcePort = TCPIP_Helper_htons(pSkt->localPort);
    f7fa:	8d6a      	ldrh	r2, [r5, #42]	; 0x2a
    f7fc:	0a13      	lsrs	r3, r2, #8
    f7fe:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    f802:	803b      	strh	r3, [r7, #0]
    pUDPHdr->DestinationPort = TCPIP_Helper_htons(pSkt->remotePort);
    f804:	8d2a      	ldrh	r2, [r5, #40]	; 0x28
    f806:	0a13      	lsrs	r3, r2, #8
    f808:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    f80c:	807b      	strh	r3, [r7, #2]
    f80e:	ea4f 2318 	mov.w	r3, r8, lsr #8
    f812:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
    pUDPHdr->Length = TCPIP_Helper_htons(udpTotLen);
    f816:	80bb      	strh	r3, [r7, #4]
    pUDPHdr->Checksum = 0;
    f818:	2200      	movs	r2, #0
    f81a:	80fa      	strh	r2, [r7, #6]
    pseudoHdr.SourceAddress.Val = pv4Pkt->srcAddress.Val;
    f81c:	6b73      	ldr	r3, [r6, #52]	; 0x34
    f81e:	9301      	str	r3, [sp, #4]
    pseudoHdr.DestAddress.Val = pv4Pkt->destAddress.Val;
    f820:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    f822:	9302      	str	r3, [sp, #8]
    pseudoHdr.Zero = 0;
    f824:	f88d 200c 	strb.w	r2, [sp, #12]
    pseudoHdr.Protocol = IP_PROT_UDP;
    f828:	2311      	movs	r3, #17
    f82a:	f88d 300d 	strb.w	r3, [sp, #13]
    pseudoHdr.Length = pUDPHdr->Length;
    f82e:	88bb      	ldrh	r3, [r7, #4]
    f830:	f8ad 300e 	strh.w	r3, [sp, #14]
    checksum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)&pseudoHdr, sizeof(pseudoHdr), 0);
    f834:	210c      	movs	r1, #12
    f836:	a801      	add	r0, sp, #4
    f838:	f00c fd0e 	bl	1c258 <TCPIP_Helper_CalcIPChecksum>
    f83c:	43c0      	mvns	r0, r0
    f83e:	b282      	uxth	r2, r0
    if(pSkt->flags.txSplitAlloc != 0)
    f840:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    f844:	f013 0f02 	tst.w	r3, #2
    f848:	d056      	beq.n	f8f8 <TCPIP_UDP_Flush+0x1c0>
        checksum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)pUDPHdr, sizeof(UDP_HEADER), checksum);
    f84a:	2108      	movs	r1, #8
    f84c:	4638      	mov	r0, r7
    f84e:	f00c fd03 	bl	1c258 <TCPIP_Helper_CalcIPChecksum>
    f852:	43c2      	mvns	r2, r0
        checksum = ~TCPIP_Helper_CalcIPChecksum(pZSeg->segLoad, udpLoadLen, checksum);
    f854:	b292      	uxth	r2, r2
    f856:	4621      	mov	r1, r4
    f858:	f8d9 0008 	ldr.w	r0, [r9, #8]
    f85c:	f00c fcfc 	bl	1c258 <TCPIP_Helper_CalcIPChecksum>
    f860:	43c3      	mvns	r3, r0
    f862:	b29b      	uxth	r3, r3
    pUDPHdr->Checksum = ~checksum;
    f864:	43db      	mvns	r3, r3
    f866:	80fb      	strh	r3, [r7, #6]
    if(isMcastDest)
    f868:	f896 3038 	ldrb.w	r3, [r6, #56]	; 0x38
    f86c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    f870:	2be0      	cmp	r3, #224	; 0xe0
    f872:	d048      	beq.n	f906 <TCPIP_UDP_Flush+0x1ce>
        pktParams.ttl = pSkt->ttl;
    f874:	f895 305b 	ldrb.w	r3, [r5, #91]	; 0x5b
    f878:	f88d 3001 	strb.w	r3, [sp, #1]
    pktParams.tosFlags = pSkt->extFlags.tos;
    f87c:	f895 3043 	ldrb.w	r3, [r5, #67]	; 0x43
    f880:	f3c3 0205 	ubfx	r2, r3, #0, #6
    f884:	f88d 2000 	strb.w	r2, [sp]
    pktParams.df = pSkt->extFlags.df;
    f888:	f3c3 1380 	ubfx	r3, r3, #6, #1
    f88c:	f88d 3002 	strb.w	r3, [sp, #2]
    TCPIP_IPV4_PacketFormatTx(pv4Pkt, IP_PROT_UDP, udpTotLen, &pktParams);
    f890:	466b      	mov	r3, sp
    f892:	4642      	mov	r2, r8
    f894:	2111      	movs	r1, #17
    f896:	4630      	mov	r0, r6
    f898:	f005 f85a 	bl	14950 <TCPIP_IPV4_PacketFormatTx>
    pv4Pkt->macPkt.next = 0;    // single packet
    f89c:	2300      	movs	r3, #0
    f89e:	6033      	str	r3, [r6, #0]
    if(isMcastDest && pSkt->extFlags.mcastLoop)
    f8a0:	8673      	strh	r3, [r6, #50]	; 0x32
    if(TCPIP_IPV4_PacketTransmit(pv4Pkt))
    f8a2:	4630      	mov	r0, r6
    f8a4:	f014 fca4 	bl	241f0 <TCPIP_IPV4_PacketTransmit>
    f8a8:	2800      	cmp	r0, #0
    f8aa:	d14f      	bne.n	f94c <TCPIP_UDP_Flush+0x214>
    pPkt->macPkt.pDSeg->segLen = 0;
    f8ac:	6933      	ldr	r3, [r6, #16]
    f8ae:	2200      	movs	r2, #0
    f8b0:	819a      	strh	r2, [r3, #12]
    if(pSkt->flags.txSplitAlloc)
    f8b2:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    f8b6:	f013 0f02 	tst.w	r3, #2
        ((UDP_V4_PACKET*)pPkt)->zcSeg->segLen = 0;
    f8ba:	bf19      	ittee	ne
    f8bc:	4613      	movne	r3, r2
    f8be:	f8a6 2050 	strhne.w	r2, [r6, #80]	; 0x50
        pSkt->txWrite = pSkt->txStart;
    f8c2:	682b      	ldreq	r3, [r5, #0]
    f8c4:	60ab      	streq	r3, [r5, #8]
    pPkt->macPkt.pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED;
    f8c6:	8c73      	ldrh	r3, [r6, #34]	; 0x22
    f8c8:	f023 0308 	bic.w	r3, r3, #8
    f8cc:	8473      	strh	r3, [r6, #34]	; 0x22
    return 0;
    f8ce:	2400      	movs	r4, #0
    f8d0:	e03c      	b.n	f94c <TCPIP_UDP_Flush+0x214>
            payload = ((UDP_V4_PACKET*)pSkt->pPkt)->zcSeg->segLen;
    f8d2:	68eb      	ldr	r3, [r5, #12]
    f8d4:	f8b3 4050 	ldrh.w	r4, [r3, #80]	; 0x50
    f8d8:	e746      	b.n	f768 <TCPIP_UDP_Flush+0x30>
        pSkt->destAddress.Val = TCPIP_STACK_NetAddressBcast(pSkt->pSktNet);
    f8da:	6a68      	ldr	r0, [r5, #36]	; 0x24
    f8dc:	f013 face 	bl	22e7c <TCPIP_STACK_NetAddressBcast>
    f8e0:	6168      	str	r0, [r5, #20]
    f8e2:	e76f      	b.n	f7c4 <TCPIP_UDP_Flush+0x8c>
        udpLoadLen = pSkt->txWrite - pSkt->txStart;
    f8e4:	68ab      	ldr	r3, [r5, #8]
    f8e6:	682c      	ldr	r4, [r5, #0]
    f8e8:	1b1b      	subs	r3, r3, r4
    f8ea:	b29c      	uxth	r4, r3
        rootLen = udpLoadLen + sizeof(UDP_HEADER); 
    f8ec:	f104 0308 	add.w	r3, r4, #8
    f8f0:	b29b      	uxth	r3, r3
        pZSeg = 0;
    f8f2:	f04f 0900 	mov.w	r9, #0
    f8f6:	e778      	b.n	f7ea <TCPIP_UDP_Flush+0xb2>
        checksum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)pUDPHdr, udpTotLen, checksum);
    f8f8:	4641      	mov	r1, r8
    f8fa:	4638      	mov	r0, r7
    f8fc:	f00c fcac 	bl	1c258 <TCPIP_Helper_CalcIPChecksum>
    f900:	43c3      	mvns	r3, r0
    f902:	b29b      	uxth	r3, r3
    f904:	e7ae      	b.n	f864 <TCPIP_UDP_Flush+0x12c>
        pktParams.ttl = pSkt->ttl == 0 ? UDP_MULTICAST_DEFAULT_TTL : pSkt->ttl;
    f906:	f895 305b 	ldrb.w	r3, [r5, #91]	; 0x5b
    f90a:	2b00      	cmp	r3, #0
    f90c:	bf08      	it	eq
    f90e:	2301      	moveq	r3, #1
    f910:	f88d 3001 	strb.w	r3, [sp, #1]
    pktParams.tosFlags = pSkt->extFlags.tos;
    f914:	f895 3043 	ldrb.w	r3, [r5, #67]	; 0x43
    f918:	f3c3 0205 	ubfx	r2, r3, #0, #6
    f91c:	f88d 2000 	strb.w	r2, [sp]
    pktParams.df = pSkt->extFlags.df;
    f920:	f3c3 1380 	ubfx	r3, r3, #6, #1
    f924:	f88d 3002 	strb.w	r3, [sp, #2]
    TCPIP_IPV4_PacketFormatTx(pv4Pkt, IP_PROT_UDP, udpTotLen, &pktParams);
    f928:	466b      	mov	r3, sp
    f92a:	4642      	mov	r2, r8
    f92c:	2111      	movs	r1, #17
    f92e:	4630      	mov	r0, r6
    f930:	f005 f80e 	bl	14950 <TCPIP_IPV4_PacketFormatTx>
    pv4Pkt->macPkt.next = 0;    // single packet
    f934:	2300      	movs	r3, #0
    f936:	6033      	str	r3, [r6, #0]
    if(isMcastDest && pSkt->extFlags.mcastLoop)
    f938:	f895 3042 	ldrb.w	r3, [r5, #66]	; 0x42
        pv4Pkt->macPkt.modPktData = 1;
    f93c:	f3c3 0380 	ubfx	r3, r3, #2, #1
    f940:	e7ae      	b.n	f8a0 <TCPIP_UDP_Flush+0x168>
        return 0;
    f942:	2400      	movs	r4, #0
    f944:	e002      	b.n	f94c <TCPIP_UDP_Flush+0x214>
            return 0;
    f946:	2400      	movs	r4, #0
                    return _UDPv4Flush(pSkt);
    f948:	e000      	b.n	f94c <TCPIP_UDP_Flush+0x214>
    return 0;
    f94a:	2400      	movs	r4, #0
}
    f94c:	4620      	mov	r0, r4
    f94e:	b005      	add	sp, #20
    f950:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return 0;
    f954:	2400      	movs	r4, #0
    f956:	e7f9      	b.n	f94c <TCPIP_UDP_Flush+0x214>

Disassembly of section .text._Command_NetInfo%259:

0000f958 <_Command_NetInfo>:
{
    f958:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f95c:	b089      	sub	sp, #36	; 0x24
    f95e:	4606      	mov	r6, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
    f960:	6847      	ldr	r7, [r0, #4]
    if (argc > 2)
    f962:	2902      	cmp	r1, #2
    f964:	dc11      	bgt.n	f98a <_Command_NetInfo+0x32>
    for (i=0; i<initialNetIfs; i++)
    f966:	4b80      	ldr	r3, [pc, #512]	; (fb68 <_Command_NetInfo+0x210>)
    f968:	681b      	ldr	r3, [r3, #0]
    f96a:	2b00      	cmp	r3, #0
    return true;
    f96c:	bfd8      	it	le
    f96e:	2001      	movle	r0, #1
    for (i=0; i<initialNetIfs; i++)
    f970:	f340 80f4 	ble.w	fb5c <_Command_NetInfo+0x204>
    f974:	f04f 0800 	mov.w	r8, #0
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "---------- Interface <%s/%s> ---------- \r\n", addrBuff, TCPIP_STACK_NetNameGet(netH));
    f978:	4d7c      	ldr	r5, [pc, #496]	; (fb6c <_Command_NetInfo+0x214>)
    f97a:	f505 7ae2 	add.w	sl, r5, #452	; 0x1c4
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "dhcp is %s\r\n", TCPIP_DHCP_IsEnabled(netH) ? "enabled" : "disabled");
    f97e:	f8df b1f0 	ldr.w	fp, [pc, #496]	; fb70 <_Command_NetInfo+0x218>
    f982:	f50b 73da 	add.w	r3, fp, #436	; 0x1b4
    f986:	9301      	str	r3, [sp, #4]
    f988:	e0a5      	b.n	fad6 <_Command_NetInfo+0x17e>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: netinfo\r\n");
    f98a:	4c78      	ldr	r4, [pc, #480]	; (fb6c <_Command_NetInfo+0x214>)
    f98c:	6803      	ldr	r3, [r0, #0]
    f98e:	681b      	ldr	r3, [r3, #0]
    f990:	f504 71d0 	add.w	r1, r4, #416	; 0x1a0
    f994:	4638      	mov	r0, r7
    f996:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: netinfo\r\n");
    f998:	6833      	ldr	r3, [r6, #0]
    f99a:	681b      	ldr	r3, [r3, #0]
    f99c:	f504 71da 	add.w	r1, r4, #436	; 0x1b4
    f9a0:	4638      	mov	r0, r7
    f9a2:	4798      	blx	r3
        return false;
    f9a4:	2000      	movs	r0, #0
    f9a6:	e0d9      	b.n	fb5c <_Command_NetInfo+0x204>
        hostName = TCPIP_STACK_NetBIOSName(netH); 
    f9a8:	4620      	mov	r0, r4
    f9aa:	f014 fd60 	bl	2446e <TCPIP_STACK_NetBIOSName>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Host Name: %s - NBNS disabled \r\n", hostName);
    f9ae:	6833      	ldr	r3, [r6, #0]
    f9b0:	685b      	ldr	r3, [r3, #4]
    f9b2:	4602      	mov	r2, r0
    f9b4:	f505 7101 	add.w	r1, r5, #516	; 0x204
    f9b8:	4638      	mov	r0, r7
    f9ba:	4798      	blx	r3
        ipAddr.Val = TCPIP_STACK_NetAddress(netH);
    f9bc:	4620      	mov	r0, r4
    f9be:	f013 fa6c 	bl	22e9a <TCPIP_STACK_NetAddress>
    f9c2:	9007      	str	r0, [sp, #28]
        TCPIP_Helper_IPAddressToString(&ipAddr, addrBuff, sizeof(addrBuff));
    f9c4:	2214      	movs	r2, #20
    f9c6:	a902      	add	r1, sp, #8
    f9c8:	a807      	add	r0, sp, #28
    f9ca:	f00e ff53 	bl	1e874 <TCPIP_Helper_IPAddressToString>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv4 Address: %s\r\n", addrBuff);
    f9ce:	6833      	ldr	r3, [r6, #0]
    f9d0:	685b      	ldr	r3, [r3, #4]
    f9d2:	aa02      	add	r2, sp, #8
    f9d4:	f505 710a 	add.w	r1, r5, #552	; 0x228
    f9d8:	4638      	mov	r0, r7
    f9da:	4798      	blx	r3
        ipAddr.Val = TCPIP_STACK_NetMask(netH);
    f9dc:	4620      	mov	r0, r4
    f9de:	f013 fbb3 	bl	23148 <TCPIP_STACK_NetMask>
    f9e2:	9007      	str	r0, [sp, #28]
        TCPIP_Helper_IPAddressToString(&ipAddr, addrBuff, sizeof(addrBuff));
    f9e4:	2214      	movs	r2, #20
    f9e6:	a902      	add	r1, sp, #8
    f9e8:	a807      	add	r0, sp, #28
    f9ea:	f00e ff43 	bl	1e874 <TCPIP_Helper_IPAddressToString>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Mask: %s\r\n", addrBuff);
    f9ee:	6833      	ldr	r3, [r6, #0]
    f9f0:	685b      	ldr	r3, [r3, #4]
    f9f2:	aa02      	add	r2, sp, #8
    f9f4:	f505 710f 	add.w	r1, r5, #572	; 0x23c
    f9f8:	4638      	mov	r0, r7
    f9fa:	4798      	blx	r3
        ipAddr.Val = TCPIP_STACK_NetAddressGateway(netH);
    f9fc:	4620      	mov	r0, r4
    f9fe:	f013 fe65 	bl	236cc <TCPIP_STACK_NetAddressGateway>
    fa02:	9007      	str	r0, [sp, #28]
        TCPIP_Helper_IPAddressToString(&ipAddr, addrBuff, sizeof(addrBuff));
    fa04:	2214      	movs	r2, #20
    fa06:	a902      	add	r1, sp, #8
    fa08:	a807      	add	r0, sp, #28
    fa0a:	f00e ff33 	bl	1e874 <TCPIP_Helper_IPAddressToString>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Gateway: %s\r\n", addrBuff);
    fa0e:	6833      	ldr	r3, [r6, #0]
    fa10:	685b      	ldr	r3, [r3, #4]
    fa12:	aa02      	add	r2, sp, #8
    fa14:	f505 7112 	add.w	r1, r5, #584	; 0x248
    fa18:	4638      	mov	r0, r7
    fa1a:	4798      	blx	r3
        ipAddr.Val = TCPIP_STACK_NetAddressDnsPrimary(netH);
    fa1c:	4620      	mov	r0, r4
    fa1e:	f013 fe61 	bl	236e4 <TCPIP_STACK_NetAddressDnsPrimary>
    fa22:	9007      	str	r0, [sp, #28]
        TCPIP_Helper_IPAddressToString(&ipAddr, addrBuff, sizeof(addrBuff));
    fa24:	2214      	movs	r2, #20
    fa26:	a902      	add	r1, sp, #8
    fa28:	a807      	add	r0, sp, #28
    fa2a:	f00e ff23 	bl	1e874 <TCPIP_Helper_IPAddressToString>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "DNS1: %s\r\n", addrBuff);
    fa2e:	6833      	ldr	r3, [r6, #0]
    fa30:	685b      	ldr	r3, [r3, #4]
    fa32:	aa02      	add	r2, sp, #8
    fa34:	f505 7116 	add.w	r1, r5, #600	; 0x258
    fa38:	4638      	mov	r0, r7
    fa3a:	4798      	blx	r3
        ipAddr.Val = TCPIP_STACK_NetAddressDnsSecond(netH);
    fa3c:	4620      	mov	r0, r4
    fa3e:	f013 fe5d 	bl	236fc <TCPIP_STACK_NetAddressDnsSecond>
    fa42:	9007      	str	r0, [sp, #28]
        TCPIP_Helper_IPAddressToString(&ipAddr, addrBuff, sizeof(addrBuff));
    fa44:	2214      	movs	r2, #20
    fa46:	a902      	add	r1, sp, #8
    fa48:	a807      	add	r0, sp, #28
    fa4a:	f00e ff13 	bl	1e874 <TCPIP_Helper_IPAddressToString>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "DNS2: %s\r\n", addrBuff);
    fa4e:	6833      	ldr	r3, [r6, #0]
    fa50:	685b      	ldr	r3, [r3, #4]
    fa52:	aa02      	add	r2, sp, #8
    fa54:	f505 7119 	add.w	r1, r5, #612	; 0x264
    fa58:	4638      	mov	r0, r7
    fa5a:	4798      	blx	r3
        pMac = (const TCPIP_MAC_ADDR*)TCPIP_STACK_NetAddressMac(netH);
    fa5c:	4620      	mov	r0, r4
    fa5e:	f014 fcaf 	bl	243c0 <TCPIP_STACK_NetAddressMac>
        TCPIP_Helper_MACAddressToString(pMac, addrBuff, sizeof(addrBuff));
    fa62:	2214      	movs	r2, #20
    fa64:	a902      	add	r1, sp, #8
    fa66:	f00f fca3 	bl	1f3b0 <TCPIP_Helper_MACAddressToString>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "MAC Address: %s\r\n", addrBuff);
    fa6a:	6833      	ldr	r3, [r6, #0]
    fa6c:	685b      	ldr	r3, [r3, #4]
    fa6e:	aa02      	add	r2, sp, #8
    fa70:	f505 711c 	add.w	r1, r5, #624	; 0x270
    fa74:	4638      	mov	r0, r7
    fa76:	4798      	blx	r3
        if(TCPIP_DHCP_IsActive(netH))
    fa78:	4620      	mov	r0, r4
    fa7a:	f012 fac7 	bl	2200c <TCPIP_DHCP_IsActive>
    fa7e:	2800      	cmp	r0, #0
    fa80:	d049      	beq.n	fb16 <_Command_NetInfo+0x1be>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "%s is ON\r\n", msgAdd);
    fa82:	6833      	ldr	r3, [r6, #0]
    fa84:	685b      	ldr	r3, [r3, #4]
    fa86:	f505 722d 	add.w	r2, r5, #692	; 0x2b4
    fa8a:	f505 712f 	add.w	r1, r5, #700	; 0x2bc
    fa8e:	4638      	mov	r0, r7
    fa90:	4798      	blx	r3
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Link is %s\r\n", TCPIP_STACK_NetIsLinked(netH) ? "UP" : "DOWN");
    fa92:	6833      	ldr	r3, [r6, #0]
    fa94:	f8d3 9004 	ldr.w	r9, [r3, #4]
    fa98:	4620      	mov	r0, r4
    fa9a:	f013 fb63 	bl	23164 <TCPIP_STACK_NetIsLinked>
    fa9e:	2800      	cmp	r0, #0
    faa0:	d155      	bne.n	fb4e <_Command_NetInfo+0x1f6>
    faa2:	f505 72b4 	add.w	r2, r5, #360	; 0x168
    faa6:	f505 7125 	add.w	r1, r5, #660	; 0x294
    faaa:	4638      	mov	r0, r7
    faac:	47c8      	blx	r9
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Status: %s\r\n", TCPIP_STACK_NetIsReady(netH) ? "Ready" : "Not Ready");
    faae:	6833      	ldr	r3, [r6, #0]
    fab0:	f8d3 9004 	ldr.w	r9, [r3, #4]
    fab4:	4620      	mov	r0, r4
    fab6:	f013 fcd3 	bl	23460 <TCPIP_STACK_NetIsReady>
    faba:	2800      	cmp	r0, #0
    fabc:	d14a      	bne.n	fb54 <_Command_NetInfo+0x1fc>
    fabe:	f505 72bc 	add.w	r2, r5, #376	; 0x178
    fac2:	f505 7129 	add.w	r1, r5, #676	; 0x2a4
    fac6:	4638      	mov	r0, r7
    fac8:	47c8      	blx	r9
    for (i=0; i<initialNetIfs; i++)
    faca:	f108 0801 	add.w	r8, r8, #1
    face:	4b26      	ldr	r3, [pc, #152]	; (fb68 <_Command_NetInfo+0x210>)
    fad0:	681b      	ldr	r3, [r3, #0]
    fad2:	4543      	cmp	r3, r8
    fad4:	dd41      	ble.n	fb5a <_Command_NetInfo+0x202>
        netH = TCPIP_STACK_IndexToNet(i);
    fad6:	4640      	mov	r0, r8
    fad8:	f012 fad4 	bl	22084 <TCPIP_STACK_IndexToNet>
    fadc:	4604      	mov	r4, r0
        TCPIP_STACK_NetAliasNameGet(netH, addrBuff, sizeof(addrBuff));
    fade:	2214      	movs	r2, #20
    fae0:	a902      	add	r1, sp, #8
    fae2:	f010 fd3d 	bl	20560 <TCPIP_STACK_NetAliasNameGet>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "---------- Interface <%s/%s> ---------- \r\n", addrBuff, TCPIP_STACK_NetNameGet(netH));
    fae6:	6833      	ldr	r3, [r6, #0]
    fae8:	f8d3 9004 	ldr.w	r9, [r3, #4]
    faec:	4620      	mov	r0, r4
    faee:	f014 fc2c 	bl	2434a <TCPIP_STACK_NetNameGet>
    faf2:	4603      	mov	r3, r0
    faf4:	aa02      	add	r2, sp, #8
    faf6:	4651      	mov	r1, sl
    faf8:	4638      	mov	r0, r7
    fafa:	47c8      	blx	r9
        if(!TCPIP_STACK_NetIsUp(netH))
    fafc:	4620      	mov	r0, r4
    fafe:	f013 fb15 	bl	2312c <TCPIP_STACK_NetIsUp>
    fb02:	2800      	cmp	r0, #0
    fb04:	f47f af50 	bne.w	f9a8 <_Command_NetInfo+0x50>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Interface is down\r\n");
    fb08:	6833      	ldr	r3, [r6, #0]
    fb0a:	681b      	ldr	r3, [r3, #0]
    fb0c:	f505 71f8 	add.w	r1, r5, #496	; 0x1f0
    fb10:	4638      	mov	r0, r7
    fb12:	4798      	blx	r3
            continue;
    fb14:	e7d9      	b.n	faca <_Command_NetInfo+0x172>
        if(TCPIP_DHCPS_IsEnabled(netH))
    fb16:	4620      	mov	r0, r4
    fb18:	f013 fce3 	bl	234e2 <TCPIP_DHCPS_IsEnabled>
    fb1c:	bb08      	cbnz	r0, fb62 <_Command_NetInfo+0x20a>
            msgAdd = "default IP address";
    fb1e:	f505 72c6 	add.w	r2, r5, #396	; 0x18c
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "%s is ON\r\n", msgAdd);
    fb22:	6833      	ldr	r3, [r6, #0]
    fb24:	685b      	ldr	r3, [r3, #4]
    fb26:	f505 712f 	add.w	r1, r5, #700	; 0x2bc
    fb2a:	4638      	mov	r0, r7
    fb2c:	4798      	blx	r3
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "dhcp is %s\r\n", TCPIP_DHCP_IsEnabled(netH) ? "enabled" : "disabled");
    fb2e:	6833      	ldr	r3, [r6, #0]
    fb30:	f8d3 9004 	ldr.w	r9, [r3, #4]
    fb34:	4620      	mov	r0, r4
    fb36:	f010 faa3 	bl	20080 <TCPIP_DHCP_IsEnabled>
    fb3a:	b930      	cbnz	r0, fb4a <_Command_NetInfo+0x1f2>
    fb3c:	f50b 72e2 	add.w	r2, fp, #452	; 0x1c4
    fb40:	f505 7121 	add.w	r1, r5, #644	; 0x284
    fb44:	4638      	mov	r0, r7
    fb46:	47c8      	blx	r9
    fb48:	e7a3      	b.n	fa92 <_Command_NetInfo+0x13a>
    fb4a:	9a01      	ldr	r2, [sp, #4]
    fb4c:	e7f8      	b.n	fb40 <_Command_NetInfo+0x1e8>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Link is %s\r\n", TCPIP_STACK_NetIsLinked(netH) ? "UP" : "DOWN");
    fb4e:	f505 72b2 	add.w	r2, r5, #356	; 0x164
    fb52:	e7a8      	b.n	faa6 <_Command_NetInfo+0x14e>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Status: %s\r\n", TCPIP_STACK_NetIsReady(netH) ? "Ready" : "Not Ready");
    fb54:	f505 72b8 	add.w	r2, r5, #368	; 0x170
    fb58:	e7b3      	b.n	fac2 <_Command_NetInfo+0x16a>
    return true;
    fb5a:	2001      	movs	r0, #1
}
    fb5c:	b009      	add	sp, #36	; 0x24
    fb5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            msgAdd = "dhcps";
    fb62:	f505 72c2 	add.w	r2, r5, #388	; 0x184
    fb66:	e7dc      	b.n	fb22 <_Command_NetInfo+0x1ca>
    fb68:	2000ee0c 	.word	0x2000ee0c
    fb6c:	00001384 	.word	0x00001384
    fb70:	0000028c 	.word	0x0000028c

Disassembly of section .text.TCPIP_IPV4_PktTx%260:

0000fb74 <TCPIP_IPV4_PktTx>:
{
    fb74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    fb78:	b084      	sub	sp, #16
    if(isPersistent)
    fb7a:	bb9a      	cbnz	r2, fbe4 <TCPIP_IPV4_PktTx+0x70>
        arpPkt = pMacPkt; 
    fb7c:	460f      	mov	r7, r1
        arpType = IPV4_ARP_PKT_TYPE_MAC;
    fb7e:	f04f 0802 	mov.w	r8, #2
    pNetIf = _TCPIPStackHandleToNet(pPkt->netIfH);
    fb82:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
    if(pNetIf == 0)
    fb84:	2b00      	cmp	r3, #0
    fb86:	f000 80e5 	beq.w	fd54 <TCPIP_IPV4_PktTx+0x1e0>
    fb8a:	460d      	mov	r5, r1
    fb8c:	4604      	mov	r4, r0
    if((pHostIf = TCPIP_STACK_MatchNetAddress(pNetIf, &pPkt->destAddress)))
    fb8e:	f100 0138 	add.w	r1, r0, #56	; 0x38
    fb92:	4618      	mov	r0, r3
    fb94:	f00f f8e0 	bl	1ed58 <TCPIP_STACK_MatchNetAddress>
    fb98:	4606      	mov	r6, r0
    fb9a:	b338      	cbz	r0, fbec <TCPIP_IPV4_PktTx+0x78>
        memcpy(pMacDst, _TCPIPStack_NetMACAddressGet(pHostIf), sizeof(*pMacDst));
    fb9c:	4603      	mov	r3, r0
    fb9e:	f853 0f3c 	ldr.w	r0, [r3, #60]!
    fba2:	9002      	str	r0, [sp, #8]
    fba4:	889b      	ldrh	r3, [r3, #4]
    fba6:	f8ad 300c 	strh.w	r3, [sp, #12]
        pPkt->netIfH = pHostIf;
    fbaa:	63e6      	str	r6, [r4, #60]	; 0x3c
    pNetIf = TCPIP_IPV4_CheckPktTx(pPkt->netIfH, pMacPkt);
    fbac:	4629      	mov	r1, r5
    fbae:	4630      	mov	r0, r6
    fbb0:	f011 fb34 	bl	2121c <TCPIP_IPV4_CheckPktTx>
    if(pNetIf == 0)
    fbb4:	4604      	mov	r4, r0
    fbb6:	2800      	cmp	r0, #0
    fbb8:	f000 80d0 	beq.w	fd5c <TCPIP_IPV4_PktTx+0x1e8>
    pMacPkt->pktIf = pNetIf;
    fbbc:	62a8      	str	r0, [r5, #40]	; 0x28
    TCPIP_PKT_PacketMACFormat(pMacPkt, pMacDst, (const TCPIP_MAC_ADDR*)_TCPIPStack_NetMACAddressGet(pNetIf), TCPIP_ETHER_TYPE_IPV4);
    fbbe:	f44f 6300 	mov.w	r3, #2048	; 0x800
    fbc2:	f100 023c 	add.w	r2, r0, #60	; 0x3c
    fbc6:	a902      	add	r1, sp, #8
    fbc8:	4628      	mov	r0, r5
    fbca:	f010 fdc7 	bl	2075c <TCPIP_PKT_PacketMACFormat>
    pTxPkt->pktFlags |= flags;
    fbce:	8c6b      	ldrh	r3, [r5, #34]	; 0x22
    fbd0:	f043 0310 	orr.w	r3, r3, #16
    fbd4:	846b      	strh	r3, [r5, #34]	; 0x22
    _TCPIPStackInsertRxPacket(pNetIf, pTxPkt, signal);
    fbd6:	2201      	movs	r2, #1
    fbd8:	4629      	mov	r1, r5
    fbda:	4620      	mov	r0, r4
    fbdc:	f00c ff06 	bl	1c9ec <_TCPIPStackInsertRxPacket>
        return true;
    fbe0:	2001      	movs	r0, #1
    fbe2:	e0b8      	b.n	fd56 <TCPIP_IPV4_PktTx+0x1e2>
        arpPkt = pPkt;
    fbe4:	4607      	mov	r7, r0
        arpType = IPV4_ARP_PKT_TYPE_TX;
    fbe6:	f04f 0801 	mov.w	r8, #1
    fbea:	e7ca      	b.n	fb82 <TCPIP_IPV4_PktTx+0xe>
{
    TCPIP_ARP_RESULT  arpRes;
    TCPIP_MAC_ADDR*   pMacDst = *ppMacAdd;
    TCPIP_NET_IF* pNetIf = (TCPIP_NET_IF*)pPkt->netIfH;

    if(pIpAdd->Val == 0xffffffff || pIpAdd->Val == TCPIP_STACK_NetAddressBcast(pNetIf))
    fbec:	f8d4 a038 	ldr.w	sl, [r4, #56]	; 0x38
    fbf0:	f1ba 3fff 	cmp.w	sl, #4294967295
    fbf4:	d028      	beq.n	fc48 <TCPIP_IPV4_PktTx+0xd4>
    TCPIP_NET_IF* pNetIf = (TCPIP_NET_IF*)pPkt->netIfH;
    fbf6:	f8d4 903c 	ldr.w	r9, [r4, #60]	; 0x3c
    if(pIpAdd->Val == 0xffffffff || pIpAdd->Val == TCPIP_STACK_NetAddressBcast(pNetIf))
    fbfa:	4648      	mov	r0, r9
    fbfc:	f013 f93e 	bl	22e7c <TCPIP_STACK_NetAddressBcast>
    fc00:	4582      	cmp	sl, r0
    fc02:	d021      	beq.n	fc48 <TCPIP_IPV4_PktTx+0xd4>
        return TCPIP_IPV4_DEST_NETWORK;
    }

    // check IP multicast address range from 224.0.0.0 to 239.255.255.255
    // can be done locally; No need for an ARP request.
    if ((pIpAdd->v[0] >= 224) && (pIpAdd->v[0] <= 239))
    fc04:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
    fc08:	3320      	adds	r3, #32
    fc0a:	b2db      	uxtb	r3, r3
    fc0c:	2b0f      	cmp	r3, #15
    fc0e:	d943      	bls.n	fc98 <TCPIP_IPV4_PktTx+0x124>
    return ((pIf->netIPAddr.Val ^ pIpAddress->Val) & pIf->netMask.Val) == 0;
    fc10:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    fc12:	f8d9 3004 	ldr.w	r3, [r9, #4]
    fc16:	4053      	eors	r3, r2
    fc18:	f8d9 1008 	ldr.w	r1, [r9, #8]
        return TCPIP_IPV4_DEST_NETWORK;
    }

    TCPIP_IPV4_DEST_TYPE destType;

    if(_TCPIPStackIpAddFromLAN(pNetIf, pIpAdd))
    fc1c:	420b      	tst	r3, r1
        arpTarget->Val  = pIpAdd->Val;
        destType = TCPIP_IPV4_DEST_NETWORK;
    }
    else
    {   // not this LAN
        arpTarget->Val  = pNetIf->netGateway.Val;
    fc1e:	bf18      	it	ne
    fc20:	f8d9 200c 	ldrne.w	r2, [r9, #12]
        destType = TCPIP_IPV4_DEST_GW;
    fc24:	9201      	str	r2, [sp, #4]
    }

    arpRes = TCPIP_ARP_EntryGet(pNetIf, arpTarget, pMacDst, true);
    fc26:	2301      	movs	r3, #1
    fc28:	aa02      	add	r2, sp, #8
    fc2a:	a901      	add	r1, sp, #4
    fc2c:	4648      	mov	r0, r9
    fc2e:	f00d f9d5 	bl	1cfdc <TCPIP_ARP_EntryGet>
    if(arpRes == ARP_RES_ENTRY_SOLVED)
    fc32:	2802      	cmp	r0, #2
    fc34:	f000 8098 	beq.w	fd68 <TCPIP_IPV4_PktTx+0x1f4>
    {   // good to transmit
    }
    else if(arpRes == ARP_RES_ENTRY_QUEUED || arpRes == ARP_RES_ENTRY_NEW)
    fc38:	f020 0002 	bic.w	r0, r0, #2
    fc3c:	b240      	sxtb	r0, r0
    fc3e:	2801      	cmp	r0, #1
            return false;
    fc40:	bf18      	it	ne
    fc42:	2000      	movne	r0, #0
    else if(arpRes == ARP_RES_ENTRY_QUEUED || arpRes == ARP_RES_ENTRY_NEW)
    fc44:	d006      	beq.n	fc54 <TCPIP_IPV4_PktTx+0xe0>
    fc46:	e086      	b.n	fd56 <TCPIP_IPV4_PktTx+0x1e2>
        memset(pMacDst, 0xff, sizeof(*pMacDst));
    fc48:	f04f 33ff 	mov.w	r3, #4294967295
    fc4c:	9302      	str	r3, [sp, #8]
    fc4e:	f8ad 300c 	strh.w	r3, [sp, #12]
    pMacDst = &destMacAdd;
    fc52:	ae02      	add	r6, sp, #8
    pNetIf = TCPIP_IPV4_CheckPktTx(pPkt->netIfH, pMacPkt);
    fc54:	4629      	mov	r1, r5
    fc56:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    fc58:	f011 fae0 	bl	2121c <TCPIP_IPV4_CheckPktTx>
    if(pNetIf == 0)
    fc5c:	4604      	mov	r4, r0
    fc5e:	2800      	cmp	r0, #0
    fc60:	d07e      	beq.n	fd60 <TCPIP_IPV4_PktTx+0x1ec>
    pMacPkt->pktIf = pNetIf;
    fc62:	62a8      	str	r0, [r5, #40]	; 0x28
    TCPIP_PKT_PacketMACFormat(pMacPkt, pMacDst, (const TCPIP_MAC_ADDR*)_TCPIPStack_NetMACAddressGet(pNetIf), TCPIP_ETHER_TYPE_IPV4);
    fc64:	f44f 6300 	mov.w	r3, #2048	; 0x800
    fc68:	f100 023c 	add.w	r2, r0, #60	; 0x3c
    fc6c:	4631      	mov	r1, r6
    fc6e:	4628      	mov	r0, r5
    fc70:	f010 fd74 	bl	2075c <TCPIP_PKT_PacketMACFormat>
        pktPayload = TCPIP_PKT_PayloadLen(pMacPkt) - sizeof(TCPIP_MAC_ETHERNET_HEADER);
    fc74:	4628      	mov	r0, r5
    fc76:	f013 f92e 	bl	22ed6 <TCPIP_PKT_PayloadLen>
    fc7a:	380e      	subs	r0, #14
        if(pktPayload > linkMtu)
    fc7c:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
    fc80:	b280      	uxth	r0, r0
    fc82:	4283      	cmp	r3, r0
    fc84:	d36e      	bcc.n	fd64 <TCPIP_IPV4_PktTx+0x1f0>
    if(pMacDst == 0)
    fc86:	b306      	cbz	r6, fcca <TCPIP_IPV4_PktTx+0x156>
    return _TCPIPStackPacketTx(pNetIf, pPkt) == TCPIP_MAC_RES_OK;
    fc88:	4629      	mov	r1, r5
    fc8a:	4620      	mov	r0, r4
    fc8c:	f013 fe96 	bl	239bc <_TCPIPStackPacketTx>
    fc90:	fab0 f080 	clz	r0, r0
    fc94:	0940      	lsrs	r0, r0, #5
    return txRes;
    fc96:	e05e      	b.n	fd56 <TCPIP_IPV4_PktTx+0x1e2>
        pMacDst->v[0] = 0x01;
    fc98:	2301      	movs	r3, #1
    fc9a:	f88d 3008 	strb.w	r3, [sp, #8]
        pMacDst->v[1] = 0x00;
    fc9e:	2300      	movs	r3, #0
    fca0:	f88d 3009 	strb.w	r3, [sp, #9]
        pMacDst->v[2] = 0x5E;
    fca4:	235e      	movs	r3, #94	; 0x5e
    fca6:	f88d 300a 	strb.w	r3, [sp, #10]
        pMacDst->v[3] = 0x7f & pIpAdd->v[1];
    fcaa:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
    fcae:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    fcb2:	f88d 300b 	strb.w	r3, [sp, #11]
        pMacDst->v[4] = pIpAdd->v[2];
    fcb6:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
    fcba:	f88d 300c 	strb.w	r3, [sp, #12]
        pMacDst->v[5] = pIpAdd->v[3];
    fcbe:	f894 303b 	ldrb.w	r3, [r4, #59]	; 0x3b
    fcc2:	f88d 300d 	strb.w	r3, [sp, #13]
    pMacDst = &destMacAdd;
    fcc6:	ae02      	add	r6, sp, #8
    fcc8:	e7c4      	b.n	fc54 <TCPIP_IPV4_PktTx+0xe0>
        if(ipv4ArpHandle == 0)
    fcca:	4b28      	ldr	r3, [pc, #160]	; (fd6c <TCPIP_IPV4_PktTx+0x1f8>)
    fccc:	681b      	ldr	r3, [r3, #0]
    fcce:	b1e3      	cbz	r3, fd0a <TCPIP_IPV4_PktTx+0x196>
    return pIf->netIfIx;
    fcd0:	f8b4 4058 	ldrh.w	r4, [r4, #88]	; 0x58
    TCPIP_Helper_ProtectedSingleListLock(pList);
    fcd4:	4826      	ldr	r0, [pc, #152]	; (fd70 <TCPIP_IPV4_PktTx+0x1fc>)
    fcd6:	f012 ff83 	bl	22be0 <TCPIP_Helper_ProtectedSingleListLock>
    IPV4_ARP_ENTRY* pEntry = (IPV4_ARP_ENTRY*)TCPIP_Helper_SingleListHeadRemove(&ipv4ArpPool);
    fcda:	4826      	ldr	r0, [pc, #152]	; (fd74 <TCPIP_IPV4_PktTx+0x200>)
    fcdc:	f013 f9c4 	bl	23068 <TCPIP_Helper_SingleListHeadRemove>
    if(pEntry == 0)
    fce0:	4601      	mov	r1, r0
    fce2:	b340      	cbz	r0, fd36 <TCPIP_IPV4_PktTx+0x1c2>
    pEntry->type = (uint8_t)type;
    fce4:	f880 8004 	strb.w	r8, [r0, #4]
    pEntry->arpIfIx = (uint8_t)arpIfIx;
    fce8:	7144      	strb	r4, [r0, #5]
    pEntry->pPkt = pPkt;     
    fcea:	6087      	str	r7, [r0, #8]
    pEntry->arpTarget.Val = arpTarget->Val;
    fcec:	9b01      	ldr	r3, [sp, #4]
    fcee:	60c3      	str	r3, [r0, #12]
    TCPIP_Helper_SingleListTailAdd(&pList->list, (SGL_LIST_NODE*)pEntry);
    fcf0:	4c1f      	ldr	r4, [pc, #124]	; (fd70 <TCPIP_IPV4_PktTx+0x1fc>)
    fcf2:	4620      	mov	r0, r4
    fcf4:	f013 fb9a 	bl	2342c <TCPIP_Helper_SingleListTailAdd>
    TCPIP_Helper_ProtectedSingleListUnlock(pList);
    fcf8:	4620      	mov	r0, r4
    fcfa:	f013 f9c3 	bl	23084 <TCPIP_Helper_ProtectedSingleListUnlock>
       pMacPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_QUEUED;
    fcfe:	8c6b      	ldrh	r3, [r5, #34]	; 0x22
    fd00:	f043 0308 	orr.w	r3, r3, #8
    fd04:	846b      	strh	r3, [r5, #34]	; 0x22
        return true;
    fd06:	2001      	movs	r0, #1
    fd08:	e025      	b.n	fd56 <TCPIP_IPV4_PktTx+0x1e2>
            if((ipv4ArpHandle = TCPIP_ARP_HandlerRegister(0, TCPIP_IPV4_ArpHandler, 0)) == 0)
    fd0a:	2200      	movs	r2, #0
    fd0c:	491a      	ldr	r1, [pc, #104]	; (fd78 <TCPIP_IPV4_PktTx+0x204>)
    fd0e:	4610      	mov	r0, r2
    fd10:	f010 fed8 	bl	20ac4 <TCPIP_ARP_HandlerRegister>
    fd14:	4b15      	ldr	r3, [pc, #84]	; (fd6c <TCPIP_IPV4_PktTx+0x1f8>)
    fd16:	6018      	str	r0, [r3, #0]
    fd18:	2800      	cmp	r0, #0
    fd1a:	d1d9      	bne.n	fcd0 <TCPIP_IPV4_PktTx+0x15c>
                SYS_ERROR(SYS_ERROR_WARNING, "IPv4: Failed to register ARP notification! \r\n");
    fd1c:	f014 fab0 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    fd20:	2801      	cmp	r0, #1
    fd22:	d801      	bhi.n	fd28 <TCPIP_IPV4_PktTx+0x1b4>
                return false;
    fd24:	2000      	movs	r0, #0
    fd26:	e016      	b.n	fd56 <TCPIP_IPV4_PktTx+0x1e2>
                SYS_ERROR(SYS_ERROR_WARNING, "IPv4: Failed to register ARP notification! \r\n");
    fd28:	f014 faa4 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    fd2c:	4913      	ldr	r1, [pc, #76]	; (fd7c <TCPIP_IPV4_PktTx+0x208>)
    fd2e:	f00c fcb5 	bl	1c69c <SYS_CONSOLE_Print>
                return false;
    fd32:	2000      	movs	r0, #0
    fd34:	e00f      	b.n	fd56 <TCPIP_IPV4_PktTx+0x1e2>
        SYS_ERROR(SYS_ERROR_WARNING, "IPv4: ARP entries pool empty!\r\n");
    fd36:	f014 faa3 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
    fd3a:	2801      	cmp	r0, #1
    fd3c:	d804      	bhi.n	fd48 <TCPIP_IPV4_PktTx+0x1d4>
        TCPIP_Helper_ProtectedSingleListUnlock(pList);
    fd3e:	480c      	ldr	r0, [pc, #48]	; (fd70 <TCPIP_IPV4_PktTx+0x1fc>)
    fd40:	f013 f9a0 	bl	23084 <TCPIP_Helper_ProtectedSingleListUnlock>
            return false;
    fd44:	2000      	movs	r0, #0
    fd46:	e006      	b.n	fd56 <TCPIP_IPV4_PktTx+0x1e2>
        SYS_ERROR(SYS_ERROR_WARNING, "IPv4: ARP entries pool empty!\r\n");
    fd48:	f014 fa94 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
    fd4c:	490c      	ldr	r1, [pc, #48]	; (fd80 <TCPIP_IPV4_PktTx+0x20c>)
    fd4e:	f00c fca5 	bl	1c69c <SYS_CONSOLE_Print>
    fd52:	e7f4      	b.n	fd3e <TCPIP_IPV4_PktTx+0x1ca>
        return false;
    fd54:	2000      	movs	r0, #0
}
    fd56:	b004      	add	sp, #16
    fd58:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return false;
    fd5c:	2000      	movs	r0, #0
    fd5e:	e7fa      	b.n	fd56 <TCPIP_IPV4_PktTx+0x1e2>
    fd60:	2000      	movs	r0, #0
    fd62:	e7f8      	b.n	fd56 <TCPIP_IPV4_PktTx+0x1e2>
            return false;
    fd64:	2000      	movs	r0, #0
    fd66:	e7f6      	b.n	fd56 <TCPIP_IPV4_PktTx+0x1e2>
    pMacDst = &destMacAdd;
    fd68:	ae02      	add	r6, sp, #8
    fd6a:	e773      	b.n	fc54 <TCPIP_IPV4_PktTx+0xe0>
    fd6c:	2000ee30 	.word	0x2000ee30
    fd70:	2000ec3c 	.word	0x2000ec3c
    fd74:	2000ed4c 	.word	0x2000ed4c
    fd78:	000181c5 	.word	0x000181c5
    fd7c:	0001b880 	.word	0x0001b880
    fd80:	0001b8b0 	.word	0x0001b8b0

Disassembly of section .text.TCPIP_DNS_ClientInitialize%261:

0000fd84 <TCPIP_DNS_ClientInitialize>:
{
    fd84:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(stackData->stackAction == TCPIP_STACK_ACTION_IF_UP)
    fd88:	7f03      	ldrb	r3, [r0, #28]
    fd8a:	2b03      	cmp	r3, #3
    fd8c:	d013      	beq.n	fdb6 <TCPIP_DNS_ClientInitialize+0x32>
    fd8e:	4682      	mov	sl, r0
    fd90:	4689      	mov	r9, r1
    if(dnsInitCount == 0)
    fd92:	4b76      	ldr	r3, [pc, #472]	; (ff6c <TCPIP_DNS_ClientInitialize+0x1e8>)
    fd94:	681d      	ldr	r5, [r3, #0]
    fd96:	b1e5      	cbz	r5, fdd2 <TCPIP_DNS_ClientInitialize+0x4e>
    if(stackData->pNetIf->Flags.bIsDnsClientEnabled != 0)
    fd98:	f8da 0014 	ldr.w	r0, [sl, #20]
    fd9c:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
    fda0:	f013 0f08 	tst.w	r3, #8
    fda4:	f040 80d5 	bne.w	ff52 <TCPIP_DNS_ClientInitialize+0x1ce>
    dnsInitCount++;
    fda8:	4a70      	ldr	r2, [pc, #448]	; (ff6c <TCPIP_DNS_ClientInitialize+0x1e8>)
    fdaa:	6813      	ldr	r3, [r2, #0]
    fdac:	3301      	adds	r3, #1
    fdae:	6013      	str	r3, [r2, #0]
    return true;
    fdb0:	2001      	movs	r0, #1
}
    fdb2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(stackData->pNetIf->Flags.bIsDnsClientEnabled != 0)
    fdb6:	6940      	ldr	r0, [r0, #20]
    fdb8:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
    fdbc:	f013 0f08 	tst.w	r3, #8
    fdc0:	d101      	bne.n	fdc6 <TCPIP_DNS_ClientInitialize+0x42>
        return true;
    fdc2:	2001      	movs	r0, #1
    fdc4:	e7f5      	b.n	fdb2 <TCPIP_DNS_ClientInitialize+0x2e>
            _DNS_Enable(stackData->pNetIf, false, TCPIP_DNS_ENABLE_DEFAULT);
    fdc6:	2200      	movs	r2, #0
    fdc8:	4611      	mov	r1, r2
    fdca:	f00d fe21 	bl	1da10 <_DNS_Enable>
        return true;
    fdce:	2001      	movs	r0, #1
    fdd0:	e7ef      	b.n	fdb2 <TCPIP_DNS_ClientInitialize+0x2e>
        memset(pDnsDcpt, 0, sizeof(*pDnsDcpt));
    fdd2:	2228      	movs	r2, #40	; 0x28
    fdd4:	2100      	movs	r1, #0
    fdd6:	4866      	ldr	r0, [pc, #408]	; (ff70 <TCPIP_DNS_ClientInitialize+0x1ec>)
    fdd8:	f014 f862 	bl	23ea0 <memset>
        if(dnsData == 0 || TCPIP_DNS_CLIENT_MAX_HOSTNAME_LEN == 0)
    fddc:	f1b9 0f00 	cmp.w	r9, #0
    fde0:	f000 80bc 	beq.w	ff5c <TCPIP_DNS_ClientInitialize+0x1d8>
        pDnsDcpt->memH = stackData->memH;
    fde4:	f8da 000c 	ldr.w	r0, [sl, #12]
    fde8:	4b61      	ldr	r3, [pc, #388]	; (ff70 <TCPIP_DNS_ClientInitialize+0x1ec>)
    fdea:	6118      	str	r0, [r3, #16]
        hashMemSize = sizeof(OA_HASH_DCPT) + dnsData->cacheEntries * sizeof(TCPIP_DNS_HASH_ENTRY);
    fdec:	f8d9 3004 	ldr.w	r3, [r9, #4]
    fdf0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    fdf4:	011c      	lsls	r4, r3, #4
    fdf6:	3428      	adds	r4, #40	; 0x28
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
    fdf8:	6843      	ldr	r3, [r0, #4]
    fdfa:	4621      	mov	r1, r4
    fdfc:	4798      	blx	r3
        if(hashDcpt == 0)
    fdfe:	4680      	mov	r8, r0
    fe00:	2800      	cmp	r0, #0
    fe02:	f000 80ad 	beq.w	ff60 <TCPIP_DNS_ClientInitialize+0x1dc>
        memset(hashDcpt, 0, hashMemSize);
    fe06:	4622      	mov	r2, r4
    fe08:	2100      	movs	r1, #0
    fe0a:	f014 f849 	bl	23ea0 <memset>
        hashDcpt->memBlk = hashDcpt + 1;
    fe0e:	f108 0328 	add.w	r3, r8, #40	; 0x28
    fe12:	f8c8 3000 	str.w	r3, [r8]
        hashDcpt->hParam = hashDcpt;    // store the descriptor it belongs to
    fe16:	f8c8 8004 	str.w	r8, [r8, #4]
        hashDcpt->hEntrySize = sizeof(TCPIP_DNS_HASH_ENTRY);
    fe1a:	2330      	movs	r3, #48	; 0x30
    fe1c:	f8c8 3008 	str.w	r3, [r8, #8]
        hashDcpt->hEntries = dnsData->cacheEntries;
    fe20:	f8d9 3004 	ldr.w	r3, [r9, #4]
    fe24:	f8c8 300c 	str.w	r3, [r8, #12]
        hashDcpt->probeStep = TCPIP_DNS_HASH_PROBE_STEP;
    fe28:	2401      	movs	r4, #1
    fe2a:	f8c8 4010 	str.w	r4, [r8, #16]
        hashDcpt->hashF = TCPIP_DNS_OAHASH_KeyHash;
    fe2e:	4b51      	ldr	r3, [pc, #324]	; (ff74 <TCPIP_DNS_ClientInitialize+0x1f0>)
    fe30:	f8c8 3014 	str.w	r3, [r8, #20]
        hashDcpt->delF = TCPIP_DNS_OAHASH_DeleteEntry;
    fe34:	4b50      	ldr	r3, [pc, #320]	; (ff78 <TCPIP_DNS_ClientInitialize+0x1f4>)
    fe36:	f8c8 3018 	str.w	r3, [r8, #24]
        hashDcpt->cmpF = TCPIP_DNS_OAHASH_KeyCompare;
    fe3a:	4b50      	ldr	r3, [pc, #320]	; (ff7c <TCPIP_DNS_ClientInitialize+0x1f8>)
    fe3c:	f8c8 301c 	str.w	r3, [r8, #28]
        hashDcpt->cpyF = TCPIP_DNS_OAHASH_KeyCopy;
    fe40:	4b4f      	ldr	r3, [pc, #316]	; (ff80 <TCPIP_DNS_ClientInitialize+0x1fc>)
    fe42:	f8c8 3020 	str.w	r3, [r8, #32]
        TCPIP_OAHASH_Initialize(hashDcpt);
    fe46:	4640      	mov	r0, r8
    fe48:	f012 faf9 	bl	2243e <TCPIP_OAHASH_Initialize>
        pDnsDcpt->hashDcpt = hashDcpt;
    fe4c:	4a48      	ldr	r2, [pc, #288]	; (ff70 <TCPIP_DNS_ClientInitialize+0x1ec>)
    fe4e:	f8c2 8000 	str.w	r8, [r2]
        pDnsDcpt->dnsSocket =  INVALID_UDP_SOCKET;
    fe52:	f64f 73ff 	movw	r3, #65535	; 0xffff
    fe56:	8493      	strh	r3, [r2, #36]	; 0x24
        pDnsDcpt->cacheEntryTMO = dnsData->entrySolvedTmo;
    fe58:	f8d9 3008 	ldr.w	r3, [r9, #8]
    fe5c:	6153      	str	r3, [r2, #20]
        pDnsDcpt->nIPv4Entries= dnsData->nIPv4Entries;
    fe5e:	f8d9 300c 	ldr.w	r3, [r9, #12]
    fe62:	8413      	strh	r3, [r2, #32]
        pDnsDcpt->nIPv6Entries = dnsData->nIPv6Entries;
    fe64:	f8d9 1014 	ldr.w	r1, [r9, #20]
    fe68:	8451      	strh	r1, [r2, #34]	; 0x22
        pDnsDcpt->ipAddressType = IP_ADDRESS_TYPE_IPV4;     // dnsData->ipAddressType;
    fe6a:	7614      	strb	r4, [r2, #24]
            + pDnsDcpt->nIPv6Entries * sizeof(IPV6_ADDR)
    fe6c:	b289      	uxth	r1, r1
        memoryBlockSize = pDnsDcpt->nIPv4Entries * sizeof(IPV4_ADDR)
    fe6e:	fa1f fb83 	uxth.w	fp, r3
            + TCPIP_DNS_CLIENT_MAX_HOSTNAME_LEN ;
    fe72:	f10b 0b10 	add.w	fp, fp, #16
    fe76:	eb0b 0b81 	add.w	fp, fp, r1, lsl #2
        memoryBlockSize = pDnsDcpt->nIPv4Entries * sizeof(IPV4_ADDR)
    fe7a:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
        for(hashCnt = 0; hashCnt < dnsData->cacheEntries; hashCnt++)
    fe7e:	f8d9 3004 	ldr.w	r3, [r9, #4]
    fe82:	2b00      	cmp	r3, #0
    fe84:	dd2a      	ble.n	fedc <TCPIP_DNS_ClientInitialize+0x158>
            pMemoryBlock = (uint8_t *)TCPIP_HEAP_Malloc(pDnsDcpt->memH, memoryBlockSize);
    fe86:	4616      	mov	r6, r2
            pE->pHostName = 0;
    fe88:	2700      	movs	r7, #0
    fe8a:	e00a      	b.n	fea2 <TCPIP_DNS_ClientInitialize+0x11e>
                _DNS_DeleteHash(pDnsDcpt);
    fe8c:	4838      	ldr	r0, [pc, #224]	; (ff70 <TCPIP_DNS_ClientInitialize+0x1ec>)
    fe8e:	f00d ffc1 	bl	1de14 <_DNS_DeleteHash>
                return false;
    fe92:	2000      	movs	r0, #0
    fe94:	e78d      	b.n	fdb2 <TCPIP_DNS_ClientInitialize+0x2e>
            pE->pHostName = (char*)pMemoryBlock;
    fe96:	6220      	str	r0, [r4, #32]
        for(hashCnt = 0; hashCnt < dnsData->cacheEntries; hashCnt++)
    fe98:	3501      	adds	r5, #1
    fe9a:	f8d9 3004 	ldr.w	r3, [r9, #4]
    fe9e:	42ab      	cmp	r3, r5
    fea0:	dd1c      	ble.n	fedc <TCPIP_DNS_ClientInitialize+0x158>
            pBkt = TCPIP_OAHASH_EntryGet(hashDcpt, hashCnt);
    fea2:	4629      	mov	r1, r5
    fea4:	4640      	mov	r0, r8
    fea6:	f013 fed8 	bl	23c5a <TCPIP_OAHASH_EntryGet>
    feaa:	4604      	mov	r4, r0
            pMemoryBlock = (uint8_t *)TCPIP_HEAP_Malloc(pDnsDcpt->memH, memoryBlockSize);
    feac:	6930      	ldr	r0, [r6, #16]
    feae:	6843      	ldr	r3, [r0, #4]
    feb0:	4659      	mov	r1, fp
    feb2:	4798      	blx	r3
            if((pE->memblk = pMemoryBlock) == 0)
    feb4:	6060      	str	r0, [r4, #4]
    feb6:	2800      	cmp	r0, #0
    feb8:	d0e8      	beq.n	fe8c <TCPIP_DNS_ClientInitialize+0x108>
            pE->pHostName = 0;
    feba:	6227      	str	r7, [r4, #32]
            pE->pip4Address = 0;
    febc:	6127      	str	r7, [r4, #16]
            pE->pip6Address = 0;
    febe:	6167      	str	r7, [r4, #20]
            if(pDnsDcpt->nIPv4Entries)
    fec0:	8c33      	ldrh	r3, [r6, #32]
    fec2:	b11b      	cbz	r3, fecc <TCPIP_DNS_ClientInitialize+0x148>
                pE->pip4Address = (IPV4_ADDR *)pMemoryBlock;
    fec4:	6120      	str	r0, [r4, #16]
                pMemoryBlock += pDnsDcpt->nIPv4Entries * (sizeof(IPV4_ADDR));
    fec6:	8c33      	ldrh	r3, [r6, #32]
    fec8:	eb00 0083 	add.w	r0, r0, r3, lsl #2
            if(pDnsDcpt->nIPv6Entries)
    fecc:	8c73      	ldrh	r3, [r6, #34]	; 0x22
    fece:	2b00      	cmp	r3, #0
    fed0:	d0e1      	beq.n	fe96 <TCPIP_DNS_ClientInitialize+0x112>
                pE->pip6Address = (IPV6_ADDR *)pMemoryBlock;
    fed2:	6160      	str	r0, [r4, #20]
                pMemoryBlock += pDnsDcpt->nIPv6Entries * (sizeof(IPV6_ADDR));
    fed4:	8c73      	ldrh	r3, [r6, #34]	; 0x22
    fed6:	eb00 1003 	add.w	r0, r0, r3, lsl #4
    feda:	e7dc      	b.n	fe96 <TCPIP_DNS_ClientInitialize+0x112>
            if((pDnsDcpt->dnsSignalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_DNS_ClientTask, TCPIP_DNS_CLIENT_TASK_PROCESS_RATE)) == 0)
    fedc:	22c8      	movs	r2, #200	; 0xc8
    fede:	4929      	ldr	r1, [pc, #164]	; (ff84 <TCPIP_DNS_ClientInitialize+0x200>)
    fee0:	200f      	movs	r0, #15
    fee2:	f00e ff5d 	bl	1eda0 <_TCPIPStackSignalHandlerRegister>
    fee6:	4b22      	ldr	r3, [pc, #136]	; (ff70 <TCPIP_DNS_ClientInitialize+0x1ec>)
    fee8:	60d8      	str	r0, [r3, #12]
    feea:	b190      	cbz	r0, ff12 <TCPIP_DNS_ClientInitialize+0x18e>
    if(pDnsDcpt->dnsSocket != INVALID_UDP_SOCKET)
    feec:	f9b3 3024 	ldrsh.w	r3, [r3, #36]	; 0x24
    fef0:	f1b3 3fff 	cmp.w	r3, #4294967295
    fef4:	d003      	beq.n	fefe <TCPIP_DNS_ClientInitialize+0x17a>
        pgDnsDcpt = &gDnsDcpt;
    fef6:	4b24      	ldr	r3, [pc, #144]	; (ff88 <TCPIP_DNS_ClientInitialize+0x204>)
    fef8:	4a1d      	ldr	r2, [pc, #116]	; (ff70 <TCPIP_DNS_ClientInitialize+0x1ec>)
    fefa:	601a      	str	r2, [r3, #0]
    fefc:	e74c      	b.n	fd98 <TCPIP_DNS_ClientInitialize+0x14>
        dnsSocket = TCPIP_UDP_ClientOpen(pDnsDcpt->ipAddressType, TCPIP_DNS_SERVER_PORT, 0);
    fefe:	2200      	movs	r2, #0
    ff00:	2135      	movs	r1, #53	; 0x35
    ff02:	4b1b      	ldr	r3, [pc, #108]	; (ff70 <TCPIP_DNS_ClientInitialize+0x1ec>)
    ff04:	7e18      	ldrb	r0, [r3, #24]
    ff06:	f014 fa2f 	bl	24368 <TCPIP_UDP_ClientOpen>
    ff0a:	4604      	mov	r4, r0
        if(dnsSocket == INVALID_UDP_SOCKET)
    ff0c:	f1b0 3fff 	cmp.w	r0, #4294967295
    ff10:	d104      	bne.n	ff1c <TCPIP_DNS_ClientInitialize+0x198>
            _DNSClientCleanup(pDnsDcpt);
    ff12:	4817      	ldr	r0, [pc, #92]	; (ff70 <TCPIP_DNS_ClientInitialize+0x1ec>)
    ff14:	f011 fc60 	bl	217d8 <_DNSClientCleanup>
            return false;
    ff18:	2000      	movs	r0, #0
    ff1a:	e74a      	b.n	fdb2 <TCPIP_DNS_ClientInitialize+0x2e>
        bufferSize = TCPIP_UDP_TxPutIsReady(dnsSocket, minDnsTxSize);
    ff1c:	2153      	movs	r1, #83	; 0x53
    ff1e:	f014 fa5b 	bl	243d8 <TCPIP_UDP_TxPutIsReady>
        if(bufferSize < minDnsTxSize)
    ff22:	2852      	cmp	r0, #82	; 0x52
    ff24:	d805      	bhi.n	ff32 <TCPIP_DNS_ClientInitialize+0x1ae>
            if(!TCPIP_UDP_OptionsSet(dnsSocket, UDP_OPTION_TX_BUFF, (void*)minDnsTxSize))
    ff26:	2253      	movs	r2, #83	; 0x53
    ff28:	2105      	movs	r1, #5
    ff2a:	4620      	mov	r0, r4
    ff2c:	f000 f830 	bl	ff90 <TCPIP_UDP_OptionsSet>
    ff30:	b1c0      	cbz	r0, ff64 <TCPIP_DNS_ClientInitialize+0x1e0>
        TCPIP_UDP_OptionsSet(dnsSocket, UDP_OPTION_STRICT_ADDRESS, (void*)false);
    ff32:	2200      	movs	r2, #0
    ff34:	2102      	movs	r1, #2
    ff36:	4620      	mov	r0, r4
    ff38:	f000 f82a 	bl	ff90 <TCPIP_UDP_OptionsSet>
        if(TCPIP_UDP_SignalHandlerRegister(dnsSocket, TCPIP_UDP_SIGNAL_RX_DATA, _DNSSocketRxSignalHandler, 0) == 0)
    ff3c:	2300      	movs	r3, #0
    ff3e:	4a13      	ldr	r2, [pc, #76]	; (ff8c <TCPIP_DNS_ClientInitialize+0x208>)
    ff40:	f44f 7180 	mov.w	r1, #256	; 0x100
    ff44:	4620      	mov	r0, r4
    ff46:	f00f f988 	bl	1f25a <TCPIP_UDP_SignalHandlerRegister>
    ff4a:	b158      	cbz	r0, ff64 <TCPIP_DNS_ClientInitialize+0x1e0>
        pDnsDcpt->dnsSocket = dnsSocket;
    ff4c:	4b08      	ldr	r3, [pc, #32]	; (ff70 <TCPIP_DNS_ClientInitialize+0x1ec>)
    ff4e:	849c      	strh	r4, [r3, #36]	; 0x24
    if(!success && dnsSocket != INVALID_UDP_SOCKET)
    ff50:	e7d1      	b.n	fef6 <TCPIP_DNS_ClientInitialize+0x172>
        _DNS_Enable(stackData->pNetIf, false, TCPIP_DNS_ENABLE_DEFAULT);
    ff52:	2200      	movs	r2, #0
    ff54:	4611      	mov	r1, r2
    ff56:	f00d fd5b 	bl	1da10 <_DNS_Enable>
    ff5a:	e725      	b.n	fda8 <TCPIP_DNS_ClientInitialize+0x24>
            return false;
    ff5c:	2000      	movs	r0, #0
    ff5e:	e728      	b.n	fdb2 <TCPIP_DNS_ClientInitialize+0x2e>
            return false;
    ff60:	2000      	movs	r0, #0
    ff62:	e726      	b.n	fdb2 <TCPIP_DNS_ClientInitialize+0x2e>
        TCPIP_UDP_Close(dnsSocket);
    ff64:	4620      	mov	r0, r4
    ff66:	f011 fa19 	bl	2139c <TCPIP_UDP_Close>
    ff6a:	e7d2      	b.n	ff12 <TCPIP_DNS_ClientInitialize+0x18e>
    ff6c:	2000ee54 	.word	0x2000ee54
    ff70:	2000ea98 	.word	0x2000ea98
    ff74:	00022bc1 	.word	0x00022bc1
    ff78:	0001e38d 	.word	0x0001e38d
    ff7c:	00024215 	.word	0x00024215
    ff80:	00021d35 	.word	0x00021d35
    ff84:	00016119 	.word	0x00016119
    ff88:	2000ee58 	.word	0x2000ee58
    ff8c:	00023991 	.word	0x00023991

Disassembly of section .text.TCPIP_UDP_OptionsSet%262:

0000ff90 <TCPIP_UDP_OptionsSet>:
    return true;
}

// Allows setting options to a socket like enable broadcast, Rx/Tx buffer size, etc
bool TCPIP_UDP_OptionsSet(UDP_SOCKET hUDP, UDP_SOCKET_OPTION option, void* optParam)
{
    ff90:	b570      	push	{r4, r5, r6, lr}
    ff92:	460d      	mov	r5, r1
    ff94:	4614      	mov	r4, r2
    UDP_SOCKET_DCPT*  pSkt = _UDPSocketDcpt(hUDP);
    ff96:	f012 f8d9 	bl	2214c <_UDPSocketDcpt>

    if(pSkt)
    ff9a:	2800      	cmp	r0, #0
    ff9c:	f000 80f0 	beq.w	10180 <TCPIP_UDP_OptionsSet+0x1f0>
    ffa0:	4606      	mov	r6, r0
    {
        switch(option)
    ffa2:	2d0c      	cmp	r5, #12
    ffa4:	f200 80ee 	bhi.w	10184 <TCPIP_UDP_OptionsSet+0x1f4>
    ffa8:	e8df f005 	tbb	[pc, r5]
    ffac:	281d1207 	.word	0x281d1207
    ffb0:	68645f46 	.word	0x68645f46
    ffb4:	d77b776c 	.word	0xd77b776c
    ffb8:	df          	.byte	0xdf
    ffb9:	00          	.byte	0x00
        {
            case UDP_OPTION_STRICT_PORT:
                pSkt->flags.looseRemPort = (optParam == 0);
    ffba:	fab4 f484 	clz	r4, r4
    ffbe:	0964      	lsrs	r4, r4, #5
    ffc0:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    ffc4:	f364 0382 	bfi	r3, r4, #2, #1
    ffc8:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
                return true;
    ffcc:	2001      	movs	r0, #1
    ffce:	e0d8      	b.n	10182 <TCPIP_UDP_OptionsSet+0x1f2>


            case UDP_OPTION_STRICT_NET:
                pSkt->flags.looseNetIf = (optParam == 0);
    ffd0:	fab4 f484 	clz	r4, r4
    ffd4:	0964      	lsrs	r4, r4, #5
    ffd6:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    ffda:	f364 03c3 	bfi	r3, r4, #3, #1
    ffde:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
                return true;
    ffe2:	2001      	movs	r0, #1
    ffe4:	e0cd      	b.n	10182 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_STRICT_ADDRESS:
                pSkt->flags.looseRemAddress = (optParam == 0);
    ffe6:	fab4 f484 	clz	r4, r4
    ffea:	0964      	lsrs	r4, r4, #5
    ffec:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    fff0:	f364 1304 	bfi	r3, r4, #4, #1
    fff4:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
                return true;
    fff8:	2001      	movs	r0, #1
    fffa:	e0c2      	b.n	10182 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_BROADCAST:
                if((pSkt->flags.bcastForceType = (int)optParam) != UDP_BCAST_NONE)
    fffc:	f004 0403 	and.w	r4, r4, #3
   10000:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   10004:	f364 0301 	bfi	r3, r4, #0, #2
   10008:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
   1000c:	b154      	cbz	r4, 10024 <TCPIP_UDP_OptionsSet+0x94>
                {   // set limited broadcast address (for now)
                    pSkt->destAddress.Val = 0xffffffff;
   1000e:	f04f 33ff 	mov.w	r3, #4294967295
   10012:	6143      	str	r3, [r0, #20]
                    pSkt->flags.destSet = 1;
   10014:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
   10018:	f043 0301 	orr.w	r3, r3, #1
   1001c:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
                {   // the discrete address will have to be set and take effect
                    pSkt->destAddress.Val = 0;
                    pSkt->flags.destSet = 0;
                }

                return true;
   10020:	2001      	movs	r0, #1
   10022:	e0ae      	b.n	10182 <TCPIP_UDP_OptionsSet+0x1f2>
                    pSkt->destAddress.Val = 0;
   10024:	2200      	movs	r2, #0
   10026:	6142      	str	r2, [r0, #20]
                    pSkt->flags.destSet = 0;
   10028:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
   1002c:	f362 0300 	bfi	r3, r2, #0, #1
   10030:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
                return true;
   10034:	2001      	movs	r0, #1
   10036:	e0a4      	b.n	10182 <TCPIP_UDP_OptionsSet+0x1f2>
                if(pSkt->addType == IP_ADDRESS_TYPE_IPV6)
                {   
                    return false;
                }
#endif  // defined (TCPIP_STACK_USE_IPV6)
                if(pSkt->flags.txSplitAlloc != 0)
   10038:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
   1003c:	f013 0f02 	tst.w	r3, #2
   10040:	f040 80a2 	bne.w	10188 <TCPIP_UDP_OptionsSet+0x1f8>
                {   // no support for external payload sockets
                    return false;
                }

                if(pSkt->flags.usePool != (optParam != 0))
   10044:	3400      	adds	r4, #0
   10046:	bf18      	it	ne
   10048:	2401      	movne	r4, #1
   1004a:	f3c3 0380 	ubfx	r3, r3, #2, #1
   1004e:	42a3      	cmp	r3, r4
   10050:	d101      	bne.n	10056 <TCPIP_UDP_OptionsSet+0xc6>
                {   // changed the buffer type; just release the packet
                    _UDPFreeTxResources(pSkt);
                    pSkt->flags.usePool = (optParam != 0);
                }
                return true;
   10052:	2001      	movs	r0, #1
   10054:	e095      	b.n	10182 <TCPIP_UDP_OptionsSet+0x1f2>
                    _UDPFreeTxResources(pSkt);
   10056:	f011 fd0f 	bl	21a78 <_UDPFreeTxResources>
                    pSkt->flags.usePool = (optParam != 0);
   1005a:	f896 3041 	ldrb.w	r3, [r6, #65]	; 0x41
   1005e:	f364 0382 	bfi	r3, r4, #2, #1
   10062:	f886 3041 	strb.w	r3, [r6, #65]	; 0x41
                return true;
   10066:	2001      	movs	r0, #1
   10068:	e08b      	b.n	10182 <TCPIP_UDP_OptionsSet+0x1f2>


            case UDP_OPTION_TX_BUFF:
                // just release the packet
                _UDPFreeTxResources(pSkt);
   1006a:	f011 fd05 	bl	21a78 <_UDPFreeTxResources>
                pSkt->txSize = (uint16_t)(unsigned int)optParam;
   1006e:	8234      	strh	r4, [r6, #16]
                return true;
   10070:	2001      	movs	r0, #1
   10072:	e086      	b.n	10182 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_TX_QUEUE_LIMIT:
                pSkt->txAllocLimit = (uint8_t)(unsigned int)optParam;
   10074:	f880 403e 	strb.w	r4, [r0, #62]	; 0x3e
                return true;
   10078:	2001      	movs	r0, #1
   1007a:	e082      	b.n	10182 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_RX_QUEUE_LIMIT:
                pSkt->rxQueueLimit = (uint8_t)(unsigned int)optParam;
   1007c:	f880 405a 	strb.w	r4, [r0, #90]	; 0x5a
                return true;
   10080:	2001      	movs	r0, #1
   10082:	e07e      	b.n	10182 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_RX_AUTO_ADVANCE:
                pSkt->extFlags.rxAutoAdvance = (optParam != 0);
   10084:	3400      	adds	r4, #0
   10086:	bf18      	it	ne
   10088:	2401      	movne	r4, #1
   1008a:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   1008e:	f364 0300 	bfi	r3, r4, #0, #1
   10092:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
                return true;
   10096:	2001      	movs	r0, #1
   10098:	e073      	b.n	10182 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_TX_TTL:
                pSkt->ttl = (uint8_t)(unsigned int)optParam;
   1009a:	f880 405b 	strb.w	r4, [r0, #91]	; 0x5b
                return true;
   1009e:	2001      	movs	r0, #1
   100a0:	e06f      	b.n	10182 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_MULTICAST:
                {
                    UDP_OPTION_MULTICAST_DATA* pMcOpt = (UDP_OPTION_MULTICAST_DATA*)optParam;
                    if(pMcOpt!= 0)
   100a2:	2c00      	cmp	r4, #0
   100a4:	d072      	beq.n	1018c <TCPIP_UDP_OptionsSet+0x1fc>
                    {
                        if((pMcOpt->flagsMask & UDP_MCAST_FLAG_LOOSE_NET_SOURCE_PORT) != 0)
   100a6:	7823      	ldrb	r3, [r4, #0]
   100a8:	f013 0f01 	tst.w	r3, #1
   100ac:	d012      	beq.n	100d4 <TCPIP_UDP_OptionsSet+0x144>
                        {   // change the source/net/source/port value
                            pSkt->flags.looseNetIf = (pMcOpt->flagsValue & UDP_MCAST_FLAG_LOOSE_NET_SOURCE_PORT) != 0;
   100ae:	7862      	ldrb	r2, [r4, #1]
   100b0:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   100b4:	f362 03c3 	bfi	r3, r2, #3, #1
   100b8:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
                            pSkt->flags.looseRemAddress = (pMcOpt->flagsValue & UDP_MCAST_FLAG_LOOSE_NET_SOURCE_PORT) != 0;
   100bc:	7862      	ldrb	r2, [r4, #1]
   100be:	b2db      	uxtb	r3, r3
   100c0:	f362 1304 	bfi	r3, r2, #4, #1
   100c4:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
                            pSkt->flags.looseRemPort = (pMcOpt->flagsValue & UDP_MCAST_FLAG_LOOSE_NET_SOURCE_PORT) != 0;
   100c8:	7862      	ldrb	r2, [r4, #1]
   100ca:	b2db      	uxtb	r3, r3
   100cc:	f362 0382 	bfi	r3, r2, #2, #1
   100d0:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
                        }
                        if((pMcOpt->flagsMask & UDP_MCAST_FLAG_IGNORE_SOURCE_ADD) != 0)
   100d4:	7823      	ldrb	r3, [r4, #0]
   100d6:	f013 0f02 	tst.w	r3, #2
   100da:	d008      	beq.n	100ee <TCPIP_UDP_OptionsSet+0x15e>
                        {
                            pSkt->extFlags.ignoreSrcAdd = (pMcOpt->flagsValue & UDP_MCAST_FLAG_IGNORE_SOURCE_ADD) != 0;
   100dc:	7863      	ldrb	r3, [r4, #1]
   100de:	f3c3 0340 	ubfx	r3, r3, #1, #1
   100e2:	f896 2042 	ldrb.w	r2, [r6, #66]	; 0x42
   100e6:	f363 1204 	bfi	r2, r3, #4, #1
   100ea:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42
                        }
                        if((pMcOpt->flagsMask & UDP_MCAST_FLAG_IGNORE_SOURCE_PORT) != 0)
   100ee:	7823      	ldrb	r3, [r4, #0]
   100f0:	f013 0f04 	tst.w	r3, #4
   100f4:	d008      	beq.n	10108 <TCPIP_UDP_OptionsSet+0x178>
                        {
                            pSkt->extFlags.ignoreSrcPort = (pMcOpt->flagsValue & UDP_MCAST_FLAG_IGNORE_SOURCE_PORT) != 0;
   100f6:	7863      	ldrb	r3, [r4, #1]
   100f8:	f3c3 0380 	ubfx	r3, r3, #2, #1
   100fc:	f896 2042 	ldrb.w	r2, [r6, #66]	; 0x42
   10100:	f363 1245 	bfi	r2, r3, #5, #1
   10104:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42
                        }
                        if((pMcOpt->flagsMask & UDP_MCAST_FLAG_IGNORE_UNICAST) != 0)
   10108:	7823      	ldrb	r3, [r4, #0]
   1010a:	f013 0f08 	tst.w	r3, #8
   1010e:	d008      	beq.n	10122 <TCPIP_UDP_OptionsSet+0x192>
                        {
                            pSkt->extFlags.mcastOnly = (pMcOpt->flagsValue & UDP_MCAST_FLAG_IGNORE_UNICAST) != 0;
   10110:	7863      	ldrb	r3, [r4, #1]
   10112:	f3c3 03c0 	ubfx	r3, r3, #3, #1
   10116:	f896 2042 	ldrb.w	r2, [r6, #66]	; 0x42
   1011a:	f363 1286 	bfi	r2, r3, #6, #1
   1011e:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42
                        }
                        if((pMcOpt->flagsMask & UDP_MCAST_FLAG_LOOP) != 0)
   10122:	7823      	ldrb	r3, [r4, #0]
   10124:	f013 0f10 	tst.w	r3, #16
   10128:	d008      	beq.n	1013c <TCPIP_UDP_OptionsSet+0x1ac>
                        {
                            pSkt->extFlags.mcastLoop = (pMcOpt->flagsValue & UDP_MCAST_FLAG_LOOP) != 0;
   1012a:	7863      	ldrb	r3, [r4, #1]
   1012c:	f3c3 1300 	ubfx	r3, r3, #4, #1
   10130:	f896 2042 	ldrb.w	r2, [r6, #66]	; 0x42
   10134:	f363 0282 	bfi	r2, r3, #2, #1
   10138:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42
                        }
                        if((pMcOpt->flagsMask & UDP_MCAST_FLAG_DISABLE_SOURCE_CHECK) != 0)
   1013c:	7823      	ldrb	r3, [r4, #0]
   1013e:	f013 0f20 	tst.w	r3, #32
   10142:	d025      	beq.n	10190 <TCPIP_UDP_OptionsSet+0x200>
                        {
                            pSkt->extFlags.mcastSkipCheck = (pMcOpt->flagsValue & UDP_MCAST_FLAG_DISABLE_SOURCE_CHECK) != 0;
   10144:	7863      	ldrb	r3, [r4, #1]
   10146:	f3c3 1340 	ubfx	r3, r3, #5, #1
   1014a:	f896 2042 	ldrb.w	r2, [r6, #66]	; 0x42
   1014e:	f363 02c3 	bfi	r2, r3, #3, #1
   10152:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42
                        }

                        return true;
   10156:	2001      	movs	r0, #1
   10158:	e013      	b.n	10182 <TCPIP_UDP_OptionsSet+0x1f2>
                    }
                }
                return false;

            case UDP_OPTION_TOS:
                pSkt->extFlags.tos = (uint8_t)(unsigned int)optParam;
   1015a:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
   1015e:	f364 0305 	bfi	r3, r4, #0, #6
   10162:	f880 3043 	strb.w	r3, [r0, #67]	; 0x43
                return true;
   10166:	2001      	movs	r0, #1
   10168:	e00b      	b.n	10182 <TCPIP_UDP_OptionsSet+0x1f2>
                
            case UDP_OPTION_DF:
                pSkt->extFlags.df = (optParam != 0);
   1016a:	3400      	adds	r4, #0
   1016c:	bf18      	it	ne
   1016e:	2401      	movne	r4, #1
   10170:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
   10174:	f364 1386 	bfi	r3, r4, #6, #1
   10178:	f880 3043 	strb.w	r3, [r0, #67]	; 0x43
                return true;
   1017c:	2001      	movs	r0, #1
   1017e:	e000      	b.n	10182 <TCPIP_UDP_OptionsSet+0x1f2>
            default:
                break;
        }
    }    

    return false;
   10180:	2000      	movs	r0, #0
}
   10182:	bd70      	pop	{r4, r5, r6, pc}
    return false;
   10184:	2000      	movs	r0, #0
   10186:	e7fc      	b.n	10182 <TCPIP_UDP_OptionsSet+0x1f2>
                    return false;
   10188:	2000      	movs	r0, #0
   1018a:	e7fa      	b.n	10182 <TCPIP_UDP_OptionsSet+0x1f2>
                return false;
   1018c:	2000      	movs	r0, #0
   1018e:	e7f8      	b.n	10182 <TCPIP_UDP_OptionsSet+0x1f2>
                        return true;
   10190:	2001      	movs	r0, #1
   10192:	e7f6      	b.n	10182 <TCPIP_UDP_OptionsSet+0x1f2>

Disassembly of section .text._vfprintf_r%263:

00010194 <_vfiprintf_r>:
   10194:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10198:	460d      	mov	r5, r1
   1019a:	b09d      	sub	sp, #116	; 0x74
   1019c:	4614      	mov	r4, r2
   1019e:	461e      	mov	r6, r3
   101a0:	4607      	mov	r7, r0
   101a2:	b118      	cbz	r0, 101ac <_vfiprintf_r+0x18>
   101a4:	6983      	ldr	r3, [r0, #24]
   101a6:	b90b      	cbnz	r3, 101ac <_vfiprintf_r+0x18>
   101a8:	f00d f8fa 	bl	1d3a0 <__sinit>
   101ac:	4b70      	ldr	r3, [pc, #448]	; (10370 <_vfiprintf_r+0x1dc>)
   101ae:	429d      	cmp	r5, r3
   101b0:	d15c      	bne.n	1026c <_vfiprintf_r+0xd8>
   101b2:	687d      	ldr	r5, [r7, #4]
   101b4:	89ab      	ldrh	r3, [r5, #12]
   101b6:	071b      	lsls	r3, r3, #28
   101b8:	d562      	bpl.n	10280 <_vfiprintf_r+0xec>
   101ba:	692b      	ldr	r3, [r5, #16]
   101bc:	2b00      	cmp	r3, #0
   101be:	d05f      	beq.n	10280 <_vfiprintf_r+0xec>
   101c0:	2300      	movs	r3, #0
   101c2:	9309      	str	r3, [sp, #36]	; 0x24
   101c4:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 10374 <_vfiprintf_r+0x1e0>
   101c8:	9603      	str	r6, [sp, #12]
   101ca:	2320      	movs	r3, #32
   101cc:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
   101d0:	2330      	movs	r3, #48	; 0x30
   101d2:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
   101d6:	f04f 38ff 	mov.w	r8, #4294967295
   101da:	f109 0a06 	add.w	sl, r9, #6
   101de:	4623      	mov	r3, r4
   101e0:	461e      	mov	r6, r3
   101e2:	f813 2b01 	ldrb.w	r2, [r3], #1
   101e6:	b10a      	cbz	r2, 101ec <_vfiprintf_r+0x58>
   101e8:	2a25      	cmp	r2, #37	; 0x25
   101ea:	d1f9      	bne.n	101e0 <_vfiprintf_r+0x4c>
   101ec:	ebb6 0b04 	subs.w	fp, r6, r4
   101f0:	d00b      	beq.n	1020a <_vfiprintf_r+0x76>
   101f2:	465b      	mov	r3, fp
   101f4:	4622      	mov	r2, r4
   101f6:	4629      	mov	r1, r5
   101f8:	4638      	mov	r0, r7
   101fa:	f00e fc68 	bl	1eace <__ssfputs_r>
   101fe:	3001      	adds	r0, #1
   10200:	f000 80b0 	beq.w	10364 <_vfiprintf_r+0x1d0>
   10204:	9b09      	ldr	r3, [sp, #36]	; 0x24
   10206:	445b      	add	r3, fp
   10208:	9309      	str	r3, [sp, #36]	; 0x24
   1020a:	7833      	ldrb	r3, [r6, #0]
   1020c:	2b00      	cmp	r3, #0
   1020e:	f000 80a9 	beq.w	10364 <_vfiprintf_r+0x1d0>
   10212:	2300      	movs	r3, #0
   10214:	e9cd 8305 	strd	r8, r3, [sp, #20]
   10218:	3601      	adds	r6, #1
   1021a:	9304      	str	r3, [sp, #16]
   1021c:	9307      	str	r3, [sp, #28]
   1021e:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
   10222:	931a      	str	r3, [sp, #104]	; 0x68
   10224:	f04f 0b01 	mov.w	fp, #1
   10228:	4634      	mov	r4, r6
   1022a:	2205      	movs	r2, #5
   1022c:	f814 1b01 	ldrb.w	r1, [r4], #1
   10230:	4850      	ldr	r0, [pc, #320]	; (10374 <_vfiprintf_r+0x1e0>)
   10232:	f009 f9d5 	bl	195e0 <memchr>
   10236:	9b04      	ldr	r3, [sp, #16]
   10238:	bb68      	cbnz	r0, 10296 <_vfiprintf_r+0x102>
   1023a:	06d8      	lsls	r0, r3, #27
   1023c:	bf44      	itt	mi
   1023e:	2220      	movmi	r2, #32
   10240:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
   10244:	0719      	lsls	r1, r3, #28
   10246:	bf44      	itt	mi
   10248:	222b      	movmi	r2, #43	; 0x2b
   1024a:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
   1024e:	7832      	ldrb	r2, [r6, #0]
   10250:	2a2a      	cmp	r2, #42	; 0x2a
   10252:	d028      	beq.n	102a6 <_vfiprintf_r+0x112>
   10254:	9a07      	ldr	r2, [sp, #28]
   10256:	4634      	mov	r4, r6
   10258:	2000      	movs	r0, #0
   1025a:	260a      	movs	r6, #10
   1025c:	4621      	mov	r1, r4
   1025e:	f811 3b01 	ldrb.w	r3, [r1], #1
   10262:	3b30      	subs	r3, #48	; 0x30
   10264:	2b09      	cmp	r3, #9
   10266:	d960      	bls.n	1032a <_vfiprintf_r+0x196>
   10268:	bb18      	cbnz	r0, 102b2 <_vfiprintf_r+0x11e>
   1026a:	e029      	b.n	102c0 <_vfiprintf_r+0x12c>
   1026c:	4b42      	ldr	r3, [pc, #264]	; (10378 <_vfiprintf_r+0x1e4>)
   1026e:	429d      	cmp	r5, r3
   10270:	d101      	bne.n	10276 <_vfiprintf_r+0xe2>
   10272:	68bd      	ldr	r5, [r7, #8]
   10274:	e79e      	b.n	101b4 <_vfiprintf_r+0x20>
   10276:	4b41      	ldr	r3, [pc, #260]	; (1037c <_vfiprintf_r+0x1e8>)
   10278:	429d      	cmp	r5, r3
   1027a:	bf08      	it	eq
   1027c:	68fd      	ldreq	r5, [r7, #12]
   1027e:	e799      	b.n	101b4 <_vfiprintf_r+0x20>
   10280:	4629      	mov	r1, r5
   10282:	4638      	mov	r0, r7
   10284:	f006 fcb8 	bl	16bf8 <__swsetup_r>
   10288:	2800      	cmp	r0, #0
   1028a:	d099      	beq.n	101c0 <_vfiprintf_r+0x2c>
   1028c:	f04f 30ff 	mov.w	r0, #4294967295
   10290:	b01d      	add	sp, #116	; 0x74
   10292:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10296:	eba0 0009 	sub.w	r0, r0, r9
   1029a:	fa0b f000 	lsl.w	r0, fp, r0
   1029e:	4318      	orrs	r0, r3
   102a0:	9004      	str	r0, [sp, #16]
   102a2:	4626      	mov	r6, r4
   102a4:	e7c0      	b.n	10228 <_vfiprintf_r+0x94>
   102a6:	9a03      	ldr	r2, [sp, #12]
   102a8:	1d11      	adds	r1, r2, #4
   102aa:	6812      	ldr	r2, [r2, #0]
   102ac:	9103      	str	r1, [sp, #12]
   102ae:	2a00      	cmp	r2, #0
   102b0:	db01      	blt.n	102b6 <_vfiprintf_r+0x122>
   102b2:	9207      	str	r2, [sp, #28]
   102b4:	e004      	b.n	102c0 <_vfiprintf_r+0x12c>
   102b6:	4252      	negs	r2, r2
   102b8:	f043 0302 	orr.w	r3, r3, #2
   102bc:	9207      	str	r2, [sp, #28]
   102be:	9304      	str	r3, [sp, #16]
   102c0:	7823      	ldrb	r3, [r4, #0]
   102c2:	2b2e      	cmp	r3, #46	; 0x2e
   102c4:	d10b      	bne.n	102de <_vfiprintf_r+0x14a>
   102c6:	7863      	ldrb	r3, [r4, #1]
   102c8:	2b2a      	cmp	r3, #42	; 0x2a
   102ca:	d133      	bne.n	10334 <_vfiprintf_r+0x1a0>
   102cc:	9b03      	ldr	r3, [sp, #12]
   102ce:	1d1a      	adds	r2, r3, #4
   102d0:	681b      	ldr	r3, [r3, #0]
   102d2:	9203      	str	r2, [sp, #12]
   102d4:	2b00      	cmp	r3, #0
   102d6:	bfb8      	it	lt
   102d8:	4643      	movlt	r3, r8
   102da:	3402      	adds	r4, #2
   102dc:	9305      	str	r3, [sp, #20]
   102de:	2203      	movs	r2, #3
   102e0:	7821      	ldrb	r1, [r4, #0]
   102e2:	4827      	ldr	r0, [pc, #156]	; (10380 <_vfiprintf_r+0x1ec>)
   102e4:	f009 f97c 	bl	195e0 <memchr>
   102e8:	b140      	cbz	r0, 102fc <_vfiprintf_r+0x168>
   102ea:	2340      	movs	r3, #64	; 0x40
   102ec:	eba0 000a 	sub.w	r0, r0, sl
   102f0:	fa03 f000 	lsl.w	r0, r3, r0
   102f4:	9b04      	ldr	r3, [sp, #16]
   102f6:	4303      	orrs	r3, r0
   102f8:	3401      	adds	r4, #1
   102fa:	9304      	str	r3, [sp, #16]
   102fc:	f814 1b01 	ldrb.w	r1, [r4], #1
   10300:	4820      	ldr	r0, [pc, #128]	; (10384 <_vfiprintf_r+0x1f0>)
   10302:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
   10306:	2206      	movs	r2, #6
   10308:	f009 f96a 	bl	195e0 <memchr>
   1030c:	ab03      	add	r3, sp, #12
   1030e:	9300      	str	r3, [sp, #0]
   10310:	462a      	mov	r2, r5
   10312:	4b1d      	ldr	r3, [pc, #116]	; (10388 <_vfiprintf_r+0x1f4>)
   10314:	a904      	add	r1, sp, #16
   10316:	b308      	cbz	r0, 1035c <_vfiprintf_r+0x1c8>
   10318:	4638      	mov	r0, r7
   1031a:	f7f8 f8e9 	bl	84f0 <_printf_float>
   1031e:	1c42      	adds	r2, r0, #1
   10320:	d020      	beq.n	10364 <_vfiprintf_r+0x1d0>
   10322:	9b09      	ldr	r3, [sp, #36]	; 0x24
   10324:	4403      	add	r3, r0
   10326:	9309      	str	r3, [sp, #36]	; 0x24
   10328:	e759      	b.n	101de <_vfiprintf_r+0x4a>
   1032a:	fb06 3202 	mla	r2, r6, r2, r3
   1032e:	2001      	movs	r0, #1
   10330:	460c      	mov	r4, r1
   10332:	e793      	b.n	1025c <_vfiprintf_r+0xc8>
   10334:	2300      	movs	r3, #0
   10336:	3401      	adds	r4, #1
   10338:	9305      	str	r3, [sp, #20]
   1033a:	4619      	mov	r1, r3
   1033c:	260a      	movs	r6, #10
   1033e:	4620      	mov	r0, r4
   10340:	f810 2b01 	ldrb.w	r2, [r0], #1
   10344:	3a30      	subs	r2, #48	; 0x30
   10346:	2a09      	cmp	r2, #9
   10348:	d903      	bls.n	10352 <_vfiprintf_r+0x1be>
   1034a:	2b00      	cmp	r3, #0
   1034c:	d0c7      	beq.n	102de <_vfiprintf_r+0x14a>
   1034e:	9105      	str	r1, [sp, #20]
   10350:	e7c5      	b.n	102de <_vfiprintf_r+0x14a>
   10352:	fb06 2101 	mla	r1, r6, r1, r2
   10356:	2301      	movs	r3, #1
   10358:	4604      	mov	r4, r0
   1035a:	e7f0      	b.n	1033e <_vfiprintf_r+0x1aa>
   1035c:	4638      	mov	r0, r7
   1035e:	f7ff f8d7 	bl	f510 <_printf_i>
   10362:	e7dc      	b.n	1031e <_vfiprintf_r+0x18a>
   10364:	89ab      	ldrh	r3, [r5, #12]
   10366:	065b      	lsls	r3, r3, #25
   10368:	d490      	bmi.n	1028c <_vfiprintf_r+0xf8>
   1036a:	9809      	ldr	r0, [sp, #36]	; 0x24
   1036c:	e790      	b.n	10290 <_vfiprintf_r+0xfc>
   1036e:	bf00      	nop
   10370:	2000eb44 	.word	0x2000eb44
   10374:	00023cfc 	.word	0x00023cfc
   10378:	2000eb64 	.word	0x2000eb64
   1037c:	2000eb24 	.word	0x2000eb24
   10380:	00023d02 	.word	0x00023d02
   10384:	00023d06 	.word	0x00023d06
   10388:	0001eacf 	.word	0x0001eacf

Disassembly of section .text.Lan867x_Miim_Task%264:

0001038c <Lan867x_Miim_Task>:
 *
 * Note:
 *****************************************************************************/
static DRV_MIIM_RESULT Lan867x_Miim_Task(LAN867X_REG_OBJ *clientObj, DRV_MIIM_OP_TYPE opType,
                                         uint32_t regAddr, uint16_t *data)
{
   1038c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1038e:	b085      	sub	sp, #20
   10390:	4604      	mov	r4, r0
   10392:	460d      	mov	r5, r1
   10394:	4611      	mov	r1, r2
    uint16_t mmdData = 0;
    DRV_MIIM_RESULT opRes = DRV_MIIM_RES_OK;
   10396:	2000      	movs	r0, #0
   10398:	f88d 000f 	strb.w	r0, [sp, #15]

    switch (R2F(clientObj->vendorData, VENDOR_INTERNAL_STATE)) {
   1039c:	6860      	ldr	r0, [r4, #4]
   1039e:	0e40      	lsrs	r0, r0, #25
   103a0:	2808      	cmp	r0, #8
   103a2:	f200 80e3 	bhi.w	1056c <Lan867x_Miim_Task+0x1e0>
   103a6:	e8df f010 	tbh	[pc, r0, lsl #1]
   103aa:	0020      	.short	0x0020
   103ac:	00090024 	.word	0x00090024
   103b0:	0050003d 	.word	0x0050003d
   103b4:	0088006c 	.word	0x0088006c
   103b8:	00c600ab 	.word	0x00c600ab
    case WRITE_22_PHASE: /* Write to clause 22 register. */
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Write(
   103bc:	6925      	ldr	r5, [r4, #16]
   103be:	68e2      	ldr	r2, [r4, #12]
   103c0:	f10d 000f 	add.w	r0, sp, #15
   103c4:	9001      	str	r0, [sp, #4]
   103c6:	2001      	movs	r0, #1
   103c8:	9000      	str	r0, [sp, #0]
   103ca:	6b16      	ldr	r6, [r2, #48]	; 0x30
   103cc:	881b      	ldrh	r3, [r3, #0]
   103ce:	6822      	ldr	r2, [r4, #0]
   103d0:	68a0      	ldr	r0, [r4, #8]
   103d2:	47b0      	blx	r6
   103d4:	6028      	str	r0, [r5, #0]
            clientObj->miimHandle, regAddr, clientObj->phyAddress, *data,
            DRV_MIIM_OPERATION_FLAG_DISCARD, &opRes);
        /* If success in queuing the request, go to next state, else retry. */
        if (*clientObj->miimOpHandle != 0) {
   103d6:	6923      	ldr	r3, [r4, #16]
   103d8:	681b      	ldr	r3, [r3, #0]
   103da:	b133      	cbz	r3, 103ea <Lan867x_Miim_Task+0x5e>
            /* Operation successfully completed.*/
            clientObj->vendorData =
                F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   103dc:	6863      	ldr	r3, [r4, #4]
   103de:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
            clientObj->vendorData =
   103e2:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_OK;
   103e4:	2300      	movs	r3, #0
   103e6:	f88d 300f 	strb.w	r3, [sp, #15]
        /* shouldn't happen */
        opRes = DRV_MIIM_RES_OP_INTERNAL_ERR;
        break;
    }
    return opRes;
}
   103ea:	f99d 000f 	ldrsb.w	r0, [sp, #15]
   103ee:	b005      	add	sp, #20
   103f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Read(
   103f2:	6925      	ldr	r5, [r4, #16]
   103f4:	68e3      	ldr	r3, [r4, #12]
   103f6:	f10d 020f 	add.w	r2, sp, #15
   103fa:	9200      	str	r2, [sp, #0]
   103fc:	6ade      	ldr	r6, [r3, #44]	; 0x2c
   103fe:	2300      	movs	r3, #0
   10400:	6822      	ldr	r2, [r4, #0]
   10402:	68a0      	ldr	r0, [r4, #8]
   10404:	47b0      	blx	r6
   10406:	6028      	str	r0, [r5, #0]
        if (*clientObj->miimOpHandle != 0) {
   10408:	6923      	ldr	r3, [r4, #16]
   1040a:	681b      	ldr	r3, [r3, #0]
   1040c:	2b00      	cmp	r3, #0
   1040e:	d0ec      	beq.n	103ea <Lan867x_Miim_Task+0x5e>
                F2R(READ_RESULT_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   10410:	6863      	ldr	r3, [r4, #4]
   10412:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   10416:	f043 63c0 	orr.w	r3, r3, #100663296	; 0x6000000
            clientObj->vendorData =
   1041a:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_PENDING;
   1041c:	2301      	movs	r3, #1
   1041e:	f88d 300f 	strb.w	r3, [sp, #15]
   10422:	e7e2      	b.n	103ea <Lan867x_Miim_Task+0x5e>
        opRes = clientObj->miimBase->DRV_MIIM_OperationResult(clientObj->miimHandle,
   10424:	6921      	ldr	r1, [r4, #16]
   10426:	68e2      	ldr	r2, [r4, #12]
   10428:	6b95      	ldr	r5, [r2, #56]	; 0x38
   1042a:	461a      	mov	r2, r3
   1042c:	6809      	ldr	r1, [r1, #0]
   1042e:	68a0      	ldr	r0, [r4, #8]
   10430:	47a8      	blx	r5
   10432:	f88d 000f 	strb.w	r0, [sp, #15]
        if (opRes != DRV_MIIM_RES_PENDING) /* Check operation is in progress or not. */
   10436:	2801      	cmp	r0, #1
   10438:	d0d7      	beq.n	103ea <Lan867x_Miim_Task+0x5e>
                F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   1043a:	6863      	ldr	r3, [r4, #4]
   1043c:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
            clientObj->vendorData =
   10440:	6063      	str	r3, [r4, #4]
            *clientObj->miimOpHandle = 0;
   10442:	6923      	ldr	r3, [r4, #16]
   10444:	2200      	movs	r2, #0
   10446:	601a      	str	r2, [r3, #0]
   10448:	e7cf      	b.n	103ea <Lan867x_Miim_Task+0x5e>
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Write(
   1044a:	6925      	ldr	r5, [r4, #16]
   1044c:	68e3      	ldr	r3, [r4, #12]
   1044e:	f10d 020f 	add.w	r2, sp, #15
   10452:	9201      	str	r2, [sp, #4]
   10454:	2201      	movs	r2, #1
   10456:	9200      	str	r2, [sp, #0]
   10458:	6b1e      	ldr	r6, [r3, #48]	; 0x30
   1045a:	0c0b      	lsrs	r3, r1, #16
   1045c:	6822      	ldr	r2, [r4, #0]
   1045e:	210d      	movs	r1, #13
   10460:	68a0      	ldr	r0, [r4, #8]
   10462:	47b0      	blx	r6
   10464:	6028      	str	r0, [r5, #0]
        if (*clientObj->miimOpHandle != 0) {
   10466:	6923      	ldr	r3, [r4, #16]
   10468:	681b      	ldr	r3, [r3, #0]
   1046a:	2b00      	cmp	r3, #0
   1046c:	d0bd      	beq.n	103ea <Lan867x_Miim_Task+0x5e>
                F2R(MMD_ADDR_SET_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   1046e:	6863      	ldr	r3, [r4, #4]
   10470:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   10474:	f043 6320 	orr.w	r3, r3, #167772160	; 0xa000000
            clientObj->vendorData =
   10478:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_PENDING;
   1047a:	2301      	movs	r3, #1
   1047c:	f88d 300f 	strb.w	r3, [sp, #15]
   10480:	e7b3      	b.n	103ea <Lan867x_Miim_Task+0x5e>
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Write(
   10482:	6925      	ldr	r5, [r4, #16]
   10484:	68e3      	ldr	r3, [r4, #12]
   10486:	f10d 020f 	add.w	r2, sp, #15
   1048a:	9201      	str	r2, [sp, #4]
   1048c:	2201      	movs	r2, #1
   1048e:	9200      	str	r2, [sp, #0]
   10490:	6b1e      	ldr	r6, [r3, #48]	; 0x30
   10492:	b28b      	uxth	r3, r1
   10494:	6822      	ldr	r2, [r4, #0]
   10496:	210e      	movs	r1, #14
   10498:	68a0      	ldr	r0, [r4, #8]
   1049a:	47b0      	blx	r6
   1049c:	6028      	str	r0, [r5, #0]
        if (*clientObj->miimOpHandle != 0) {
   1049e:	6923      	ldr	r3, [r4, #16]
   104a0:	681b      	ldr	r3, [r3, #0]
   104a2:	2b00      	cmp	r3, #0
   104a4:	d0a1      	beq.n	103ea <Lan867x_Miim_Task+0x5e>
                F2R(MMD_DATA_CONFIG_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   104a6:	6863      	ldr	r3, [r4, #4]
   104a8:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   104ac:	f043 6340 	orr.w	r3, r3, #201326592	; 0xc000000
            clientObj->vendorData =
   104b0:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_PENDING;
   104b2:	2301      	movs	r3, #1
   104b4:	f88d 300f 	strb.w	r3, [sp, #15]
   104b8:	e797      	b.n	103ea <Lan867x_Miim_Task+0x5e>
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Write(
   104ba:	6926      	ldr	r6, [r4, #16]
        mmdData = (F2R_((regAddr >> 16), PHY_MMDCTRL_DEVAD) | F2R_(1, PHY_MMDCTRL_FNCTN));
   104bc:	f3c1 4304 	ubfx	r3, r1, #16, #5
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Write(
   104c0:	68e2      	ldr	r2, [r4, #12]
   104c2:	f10d 010f 	add.w	r1, sp, #15
   104c6:	9101      	str	r1, [sp, #4]
   104c8:	2101      	movs	r1, #1
   104ca:	9100      	str	r1, [sp, #0]
   104cc:	6b17      	ldr	r7, [r2, #48]	; 0x30
   104ce:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   104d2:	6822      	ldr	r2, [r4, #0]
   104d4:	210d      	movs	r1, #13
   104d6:	68a0      	ldr	r0, [r4, #8]
   104d8:	47b8      	blx	r7
   104da:	6030      	str	r0, [r6, #0]
        if (*clientObj->miimOpHandle != 0) {
   104dc:	6923      	ldr	r3, [r4, #16]
   104de:	681b      	ldr	r3, [r3, #0]
   104e0:	2b00      	cmp	r3, #0
   104e2:	d082      	beq.n	103ea <Lan867x_Miim_Task+0x5e>
            if (opType == DRV_MIIM_OP_READ) {
   104e4:	2d01      	cmp	r5, #1
                    F2R(MMD_DATA_READ_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   104e6:	6863      	ldr	r3, [r4, #4]
   104e8:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   104ec:	bf0c      	ite	eq
   104ee:	f043 6360 	orreq.w	r3, r3, #234881024	; 0xe000000
                    F2R(MMD_DATA_WRITE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   104f2:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
   104f6:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_PENDING;
   104f8:	2301      	movs	r3, #1
   104fa:	f88d 300f 	strb.w	r3, [sp, #15]
   104fe:	e774      	b.n	103ea <Lan867x_Miim_Task+0x5e>
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Read(
   10500:	6925      	ldr	r5, [r4, #16]
   10502:	68e3      	ldr	r3, [r4, #12]
   10504:	f10d 020f 	add.w	r2, sp, #15
   10508:	9200      	str	r2, [sp, #0]
   1050a:	6ade      	ldr	r6, [r3, #44]	; 0x2c
   1050c:	2300      	movs	r3, #0
   1050e:	6822      	ldr	r2, [r4, #0]
   10510:	210e      	movs	r1, #14
   10512:	68a0      	ldr	r0, [r4, #8]
   10514:	47b0      	blx	r6
   10516:	6028      	str	r0, [r5, #0]
        if (*clientObj->miimOpHandle != 0) {
   10518:	6923      	ldr	r3, [r4, #16]
   1051a:	681b      	ldr	r3, [r3, #0]
   1051c:	2b00      	cmp	r3, #0
   1051e:	f43f af64 	beq.w	103ea <Lan867x_Miim_Task+0x5e>
                F2R(READ_RESULT_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   10522:	6863      	ldr	r3, [r4, #4]
   10524:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   10528:	f043 63c0 	orr.w	r3, r3, #100663296	; 0x6000000
            clientObj->vendorData =
   1052c:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_PENDING;
   1052e:	2301      	movs	r3, #1
   10530:	f88d 300f 	strb.w	r3, [sp, #15]
   10534:	e759      	b.n	103ea <Lan867x_Miim_Task+0x5e>
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Write(
   10536:	6925      	ldr	r5, [r4, #16]
   10538:	68e2      	ldr	r2, [r4, #12]
   1053a:	f10d 010f 	add.w	r1, sp, #15
   1053e:	9101      	str	r1, [sp, #4]
   10540:	2101      	movs	r1, #1
   10542:	9100      	str	r1, [sp, #0]
   10544:	6b16      	ldr	r6, [r2, #48]	; 0x30
   10546:	881b      	ldrh	r3, [r3, #0]
   10548:	6822      	ldr	r2, [r4, #0]
   1054a:	210e      	movs	r1, #14
   1054c:	68a0      	ldr	r0, [r4, #8]
   1054e:	47b0      	blx	r6
   10550:	6028      	str	r0, [r5, #0]
        if (*clientObj->miimOpHandle != 0) {
   10552:	6923      	ldr	r3, [r4, #16]
   10554:	681b      	ldr	r3, [r3, #0]
   10556:	2b00      	cmp	r3, #0
   10558:	f43f af47 	beq.w	103ea <Lan867x_Miim_Task+0x5e>
                F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   1055c:	6863      	ldr	r3, [r4, #4]
   1055e:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
            clientObj->vendorData =
   10562:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_OK;
   10564:	2300      	movs	r3, #0
   10566:	f88d 300f 	strb.w	r3, [sp, #15]
   1056a:	e73e      	b.n	103ea <Lan867x_Miim_Task+0x5e>
        opRes = DRV_MIIM_RES_OP_INTERNAL_ERR;
   1056c:	23ec      	movs	r3, #236	; 0xec
   1056e:	f88d 300f 	strb.w	r3, [sp, #15]
        break;
   10572:	e73a      	b.n	103ea <Lan867x_Miim_Task+0x5e>

Disassembly of section .text.TCPIP_ICMP_Task%265:

00010574 <TCPIP_ICMP_Task>:


#endif

void  TCPIP_ICMP_Task(void)
{
   10574:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10578:	b093      	sub	sp, #76	; 0x4c
    TCPIP_MODULE_SIGNAL sigPend;

    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
   1057a:	210f      	movs	r1, #15
   1057c:	2006      	movs	r0, #6
   1057e:	f00f fdd9 	bl	20134 <_TCPIPStackModuleSignalGet>
   10582:	4606      	mov	r6, r0

    if((sigPend & TCPIP_MODULE_SIGNAL_RX_PENDING) != 0)
   10584:	f010 0f01 	tst.w	r0, #1
   10588:	d106      	bne.n	10598 <TCPIP_ICMP_Task+0x24>
    { //  RX signal occurred
        TCPIP_ICMP_Process();
    }

#if defined(TCPIP_STACK_USE_ICMP_CLIENT)
    if((sigPend & TCPIP_MODULE_SIGNAL_TMO) != 0)
   1058a:	f016 0f02 	tst.w	r6, #2
   1058e:	f040 80ac 	bne.w	106ea <TCPIP_ICMP_Task+0x176>
    { // regular TMO occurred
        TCPIP_ICMP_Timeout();
    }
#endif  // defined(TCPIP_STACK_USE_ICMP_CLIENT)

}
   10592:	b013      	add	sp, #76	; 0x4c
   10594:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    TCPIP_MAC_PKT_ACK_RES   ackRes;



    // extract queued ICMP packets
    while((pRxPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
   10598:	2706      	movs	r7, #6

#if defined(TCPIP_STACK_USE_ICMP_CLIENT)
            if(pRxHdr->vType == ICMP_TYPE_ECHO_REPLY && pRxHdr->vCode == ICMP_CODE_ECHO_REPLY)
            {   // echo reply; check if our own
                // Get the sequence number and identifier fields
                if(pIcmpEchoRequest != 0)
   1059a:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 10748 <TCPIP_ICMP_Task+0x1d4>
    TCPIP_Helper_ProtectedSingleListLock(notifyList);
   1059e:	f8df a1b4 	ldr.w	sl, [pc, #436]	; 10754 <TCPIP_ICMP_Task+0x1e0>
   105a2:	e077      	b.n	10694 <TCPIP_ICMP_Task+0x120>
                if(TCPIP_STACK_IsBcastAddress((TCPIP_NET_IF*)pRxPkt->pktIf, &pIpv4Header->DestAddress))
   105a4:	f108 0110 	add.w	r1, r8, #16
   105a8:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   105aa:	f011 fa23 	bl	219f4 <TCPIP_STACK_IsBcastAddress>
   105ae:	b110      	cbz	r0, 105b6 <TCPIP_ICMP_Task+0x42>
                    ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;  // ignore request
   105b0:	f06f 010e 	mvn.w	r1, #14
   105b4:	e06a      	b.n	1068c <TCPIP_ICMP_Task+0x118>
                _ICMPProcessEchoRequest((TCPIP_NET_IF*)pRxPkt->pktIf, pRxPkt, pIpv4Header->DestAddress.Val, srcAdd);
   105b6:	6aa5      	ldr	r5, [r4, #40]	; 0x28
    TCPIP_UINT16_VAL checksum;
    IPV4_PACKET ipv4Pkt;
    IPV4_HEADER* pIpv4Hdr;

    // adjust the checksum
    pTxHdr = (ICMP_PACKET*)pRxPkt->pTransportLayer;
   105b8:	69e2      	ldr	r2, [r4, #28]

    pTxHdr->vType = ICMP_TYPE_ECHO_REPLY;
   105ba:	2300      	movs	r3, #0
   105bc:	7013      	strb	r3, [r2, #0]
    pTxHdr->vCode = ICMP_CODE_ECHO_REPLY;
   105be:	7053      	strb	r3, [r2, #1]
    checksum.Val = pTxHdr->wChecksum;
   105c0:	8853      	ldrh	r3, [r2, #2]
   105c2:	4618      	mov	r0, r3
    checksum.v[0] += 8;	// Subtract 0x0800 from the checksum
   105c4:	fa5f fc83 	uxtb.w	ip, r3
   105c8:	f10c 0108 	add.w	r1, ip, #8
   105cc:	b2c9      	uxtb	r1, r1
   105ce:	f361 0007 	bfi	r0, r1, #0, #8
    if(checksum.v[0] < 8u)
   105d2:	2907      	cmp	r1, #7
   105d4:	d80a      	bhi.n	105ec <TCPIP_ICMP_Task+0x78>
    {
        checksum.v[1]++;
   105d6:	f3c3 2307 	ubfx	r3, r3, #8, #8
   105da:	3301      	adds	r3, #1
   105dc:	b2db      	uxtb	r3, r3
   105de:	f363 200f 	bfi	r0, r3, #8, #8
        if(checksum.v[1] == 0u)
   105e2:	b91b      	cbnz	r3, 105ec <TCPIP_ICMP_Task+0x78>
        {
            checksum.v[0]++;
   105e4:	f10c 0c09 	add.w	ip, ip, #9
   105e8:	f36c 0007 	bfi	r0, ip, #0, #8
        }
    }

    pTxHdr->wChecksum = checksum.Val;
   105ec:	8050      	strh	r0, [r2, #2]
    pRxPkt->next = 0; // single packet
   105ee:	f04f 0800 	mov.w	r8, #0
   105f2:	f8c4 8000 	str.w	r8, [r4]
            TCPIP_PKT_PacketAcknowledge(pFragPkt, TCPIP_MAC_PKT_ACK_MAC_REJECT_ERR);
        }
        return false;
    }
#else
    TCPIP_IPV4_MacPacketSwitchTxToRx(pRxPkt, true, false); 
   105f6:	4642      	mov	r2, r8
   105f8:	2101      	movs	r1, #1
   105fa:	4620      	mov	r0, r4
   105fc:	f00a f9fe 	bl	1a9fc <TCPIP_IPV4_MacPacketSwitchTxToRx>

    // set proper address fields
    pIpv4Hdr = (IPV4_HEADER*)pRxPkt->pNetLayer;
   10600:	69a3      	ldr	r3, [r4, #24]
    ipv4Pkt.srcAddress.Val = pIpv4Hdr->SourceAddress.Val;
   10602:	68da      	ldr	r2, [r3, #12]
   10604:	920e      	str	r2, [sp, #56]	; 0x38
    ipv4Pkt.destAddress.Val = pIpv4Hdr->DestAddress.Val;
   10606:	691b      	ldr	r3, [r3, #16]
   10608:	930f      	str	r3, [sp, #60]	; 0x3c
    ipv4Pkt.netIfH = pNetIf;
   1060a:	9510      	str	r5, [sp, #64]	; 0x40
    
    TCPIP_PKT_FlightLogTx(pRxPkt, TCPIP_THIS_MODULE_ID);
    if(!TCPIP_IPV4_PktTx(&ipv4Pkt, pRxPkt, false))
   1060c:	4642      	mov	r2, r8
   1060e:	4621      	mov	r1, r4
   10610:	a801      	add	r0, sp, #4
   10612:	f7ff faaf 	bl	fb74 <TCPIP_IPV4_PktTx>
   10616:	2800      	cmp	r0, #0
   10618:	d13c      	bne.n	10694 <TCPIP_ICMP_Task+0x120>
    {
        TCPIP_PKT_PacketAcknowledge(pRxPkt, TCPIP_MAC_PKT_ACK_MAC_REJECT_ERR);
   1061a:	463a      	mov	r2, r7
   1061c:	f06f 0105 	mvn.w	r1, #5
   10620:	4620      	mov	r0, r4
   10622:	f00f fa3f 	bl	1faa4 <_TCPIP_PKT_PacketAcknowledge>
        return false;
   10626:	e035      	b.n	10694 <TCPIP_ICMP_Task+0x120>
                    if(pIcmpEchoRequest->identifier == pRxHdr->wIdentifier && pIcmpEchoRequest->sequenceNumber == pRxHdr->wSequenceNumber)
   10628:	8902      	ldrh	r2, [r0, #8]
   1062a:	88eb      	ldrh	r3, [r5, #6]
   1062c:	429a      	cmp	r2, r3
   1062e:	d002      	beq.n	10636 <TCPIP_ICMP_Task+0xc2>
            ackRes = TCPIP_MAC_PKT_ACK_TYPE_ERR;
   10630:	f06f 010c 	mvn.w	r1, #12
   10634:	e02a      	b.n	1068c <TCPIP_ICMP_Task+0x118>
                        if(pIcmpEchoRequest->callback)
   10636:	6943      	ldr	r3, [r0, #20]
   10638:	b123      	cbz	r3, 10644 <TCPIP_ICMP_Task+0xd0>
                            pIcmpEchoRequest->targetAddr.Val = srcAdd; 
   1063a:	f8c0 b004 	str.w	fp, [r0, #4]
                            (*pIcmpEchoRequest->callback)(pIcmpEchoRequest, pIcmpEchoRequest, TCPIP_ICMP_ECHO_REQUEST_RES_OK);
   1063e:	2200      	movs	r2, #0
   10640:	4601      	mov	r1, r0
   10642:	4798      	blx	r3
                        pIcmpEchoRequest = 0;    // free
   10644:	2300      	movs	r3, #0
   10646:	f8c9 3000 	str.w	r3, [r9]
                        ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
   1064a:	2102      	movs	r1, #2
   1064c:	e01e      	b.n	1068c <TCPIP_ICMP_Task+0x118>
                    userData.w[0] = pRxHdr->wIdentifier;
   1064e:	88ab      	ldrh	r3, [r5, #4]
   10650:	f8ad 3000 	strh.w	r3, [sp]
                    userData.w[1] = pRxHdr->wSequenceNumber;
   10654:	88eb      	ldrh	r3, [r5, #6]
   10656:	f8ad 3002 	strh.w	r3, [sp, #2]
                    remoteIPAddr.Val = srcAdd;
   1065a:	f8cd b004 	str.w	fp, [sp, #4]
                    _ICMPNotifyClients((TCPIP_NET_IF*)pRxPkt->pktIf, &remoteIPAddr, (void *)userData.v);
   1065e:	f8d4 8028 	ldr.w	r8, [r4, #40]	; 0x28
   10662:	4650      	mov	r0, sl
   10664:	f012 fabc 	bl	22be0 <TCPIP_Helper_ProtectedSingleListLock>
static void _ICMPNotifyClients(TCPIP_NET_HANDLE hNetIf, IPV4_ADDR * remoteIP, void * data)
{
    ICMP_LIST_NODE* dNode;

    TCPIP_Notification_Lock(&icmpRegisteredUsers);
    for(dNode = (ICMP_LIST_NODE*)icmpRegisteredUsers.list.head; dNode != 0; dNode = dNode->next)
   10668:	f8da 5000 	ldr.w	r5, [sl]
   1066c:	b13d      	cbz	r5, 1067e <TCPIP_ICMP_Task+0x10a>
    {
        (*dNode->callback)(hNetIf, remoteIP, data);
   1066e:	686b      	ldr	r3, [r5, #4]
   10670:	466a      	mov	r2, sp
   10672:	a901      	add	r1, sp, #4
   10674:	4640      	mov	r0, r8
   10676:	4798      	blx	r3
    for(dNode = (ICMP_LIST_NODE*)icmpRegisteredUsers.list.head; dNode != 0; dNode = dNode->next)
   10678:	682d      	ldr	r5, [r5, #0]
   1067a:	2d00      	cmp	r5, #0
   1067c:	d1f7      	bne.n	1066e <TCPIP_ICMP_Task+0xfa>
    TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
   1067e:	4650      	mov	r0, sl
   10680:	f012 fd00 	bl	23084 <TCPIP_Helper_ProtectedSingleListUnlock>
                    ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
   10684:	2102      	movs	r1, #2
   10686:	e001      	b.n	1068c <TCPIP_ICMP_Task+0x118>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
   10688:	f06f 010d 	mvn.w	r1, #13
    TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
   1068c:	463a      	mov	r2, r7
   1068e:	4620      	mov	r0, r4
   10690:	f00f fa08 	bl	1faa4 <_TCPIP_PKT_PacketAcknowledge>
    while((pRxPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
   10694:	4638      	mov	r0, r7
   10696:	f011 f9c3 	bl	21a20 <_TCPIPStackModuleRxExtract>
   1069a:	4604      	mov	r4, r0
   1069c:	2800      	cmp	r0, #0
   1069e:	f43f af74 	beq.w	1058a <TCPIP_ICMP_Task+0x16>
            icmpTotLength = pRxPkt->totTransportLen;    // length of the 1st segment (if fragmented)
   106a2:	8c22      	ldrh	r2, [r4, #32]
            if(icmpTotLength < sizeof(*pRxHdr))
   106a4:	2a07      	cmp	r2, #7
   106a6:	d9ef      	bls.n	10688 <TCPIP_ICMP_Task+0x114>
        pRxHdr = (ICMP_PACKET*)pRxPkt->pTransportLayer;
   106a8:	69e5      	ldr	r5, [r4, #28]
        pIpv4Header = (IPV4_HEADER*)pRxPkt->pNetLayer;
   106aa:	f8d4 8018 	ldr.w	r8, [r4, #24]
        srcAdd =  pIpv4Header->SourceAddress.Val;
   106ae:	f8d8 b00c 	ldr.w	fp, [r8, #12]
            checksum = TCPIP_Helper_PacketChecksum(pRxPkt, (uint8_t*)pRxHdr, icmpTotLength, 0);
   106b2:	2300      	movs	r3, #0
   106b4:	4629      	mov	r1, r5
   106b6:	4620      	mov	r0, r4
   106b8:	f00a fb2a 	bl	1ad10 <TCPIP_Helper_PacketChecksum>
            if(checksum != 0)
   106bc:	b978      	cbnz	r0, 106de <TCPIP_ICMP_Task+0x16a>
            if(pRxHdr->vType == ICMP_TYPE_ECHO_REQUEST && pRxHdr->vCode == ICMP_CODE_ECHO_REQUEST)
   106be:	882b      	ldrh	r3, [r5, #0]
   106c0:	2b08      	cmp	r3, #8
   106c2:	f43f af6f 	beq.w	105a4 <TCPIP_ICMP_Task+0x30>
            if(pRxHdr->vType == ICMP_TYPE_ECHO_REPLY && pRxHdr->vCode == ICMP_CODE_ECHO_REPLY)
   106c6:	b96b      	cbnz	r3, 106e4 <TCPIP_ICMP_Task+0x170>
                if(pIcmpEchoRequest != 0)
   106c8:	f8d9 0000 	ldr.w	r0, [r9]
   106cc:	2800      	cmp	r0, #0
   106ce:	d0be      	beq.n	1064e <TCPIP_ICMP_Task+0xda>
                    if(pIcmpEchoRequest->identifier == pRxHdr->wIdentifier && pIcmpEchoRequest->sequenceNumber == pRxHdr->wSequenceNumber)
   106d0:	8942      	ldrh	r2, [r0, #10]
   106d2:	88ab      	ldrh	r3, [r5, #4]
   106d4:	429a      	cmp	r2, r3
   106d6:	d0a7      	beq.n	10628 <TCPIP_ICMP_Task+0xb4>
            ackRes = TCPIP_MAC_PKT_ACK_TYPE_ERR;
   106d8:	f06f 010c 	mvn.w	r1, #12
   106dc:	e7d6      	b.n	1068c <TCPIP_ICMP_Task+0x118>
                ackRes = TCPIP_MAC_PKT_ACK_CHKSUM_ERR;
   106de:	f06f 0109 	mvn.w	r1, #9
   106e2:	e7d3      	b.n	1068c <TCPIP_ICMP_Task+0x118>
            ackRes = TCPIP_MAC_PKT_ACK_TYPE_ERR;
   106e4:	f06f 010c 	mvn.w	r1, #12
   106e8:	e7d0      	b.n	1068c <TCPIP_ICMP_Task+0x118>
    if(icmpEchoTmo == 0)
   106ea:	4b16      	ldr	r3, [pc, #88]	; (10744 <TCPIP_ICMP_Task+0x1d0>)
   106ec:	681b      	ldr	r3, [r3, #0]
   106ee:	b1d3      	cbz	r3, 10726 <TCPIP_ICMP_Task+0x1b2>
    if(pIcmpEchoRequest != 0)
   106f0:	4b15      	ldr	r3, [pc, #84]	; (10748 <TCPIP_ICMP_Task+0x1d4>)
   106f2:	681b      	ldr	r3, [r3, #0]
   106f4:	2b00      	cmp	r3, #0
   106f6:	f43f af4c 	beq.w	10592 <TCPIP_ICMP_Task+0x1e>
        if((SYS_TMR_TickCountGet() - icmpEchoStart) >= icmpEchoTmo) 
   106fa:	f011 fd9f 	bl	2223c <SYS_TMR_TickCountGet>
   106fe:	4b13      	ldr	r3, [pc, #76]	; (1074c <TCPIP_ICMP_Task+0x1d8>)
   10700:	681b      	ldr	r3, [r3, #0]
   10702:	1ac0      	subs	r0, r0, r3
   10704:	4b0f      	ldr	r3, [pc, #60]	; (10744 <TCPIP_ICMP_Task+0x1d0>)
   10706:	681b      	ldr	r3, [r3, #0]
   10708:	4298      	cmp	r0, r3
   1070a:	f4ff af42 	bcc.w	10592 <TCPIP_ICMP_Task+0x1e>
            if(pIcmpEchoRequest->callback)
   1070e:	4b0e      	ldr	r3, [pc, #56]	; (10748 <TCPIP_ICMP_Task+0x1d4>)
   10710:	6818      	ldr	r0, [r3, #0]
   10712:	6943      	ldr	r3, [r0, #20]
   10714:	b11b      	cbz	r3, 1071e <TCPIP_ICMP_Task+0x1aa>
                (*pIcmpEchoRequest->callback)(pIcmpEchoRequest, pIcmpEchoRequest, TCPIP_ICMP_ECHO_REQUEST_RES_TMO);
   10716:	f04f 32ff 	mov.w	r2, #4294967295
   1071a:	4601      	mov	r1, r0
   1071c:	4798      	blx	r3
            pIcmpEchoRequest = 0;    // free
   1071e:	4b0a      	ldr	r3, [pc, #40]	; (10748 <TCPIP_ICMP_Task+0x1d4>)
   10720:	2200      	movs	r2, #0
   10722:	601a      	str	r2, [r3, #0]
}
   10724:	e735      	b.n	10592 <TCPIP_ICMP_Task+0x1e>
        icmpEchoTmo = (TCPIP_ICMP_ECHO_REQUEST_TIMEOUT * SYS_TMR_TickCounterFrequencyGet() + 999) / 1000;
   10726:	f011 fdb1 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
   1072a:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   1072e:	fb03 f300 	mul.w	r3, r3, r0
   10732:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
   10736:	4806      	ldr	r0, [pc, #24]	; (10750 <TCPIP_ICMP_Task+0x1dc>)
   10738:	fba0 2303 	umull	r2, r3, r0, r3
   1073c:	099b      	lsrs	r3, r3, #6
   1073e:	4a01      	ldr	r2, [pc, #4]	; (10744 <TCPIP_ICMP_Task+0x1d0>)
   10740:	6013      	str	r3, [r2, #0]
   10742:	e7d5      	b.n	106f0 <TCPIP_ICMP_Task+0x17c>
   10744:	2000edac 	.word	0x2000edac
   10748:	2000edb8 	.word	0x2000edb8
   1074c:	2000eda8 	.word	0x2000eda8
   10750:	10624dd3 	.word	0x10624dd3
   10754:	2000ec28 	.word	0x2000ec28

Disassembly of section .text.TCPIP_ARP_Initialize%266:

00010758 <TCPIP_ARP_Initialize>:
{
   10758:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1075c:	b083      	sub	sp, #12
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_UP)
   1075e:	7f03      	ldrb	r3, [r0, #28]
   10760:	2b03      	cmp	r3, #3
   10762:	d03e      	beq.n	107e2 <TCPIP_ARP_Initialize+0x8a>
   10764:	4681      	mov	r9, r0
   10766:	460d      	mov	r5, r1
    if(arpMod.initCount == 0)
   10768:	4b6d      	ldr	r3, [pc, #436]	; (10920 <TCPIP_ARP_Initialize+0x1c8>)
   1076a:	f8d3 800c 	ldr.w	r8, [r3, #12]
   1076e:	f1b8 0f00 	cmp.w	r8, #0
   10772:	d123      	bne.n	107bc <TCPIP_ARP_Initialize+0x64>
        if(arpData == 0)
   10774:	2900      	cmp	r1, #0
   10776:	f000 80cf 	beq.w	10918 <TCPIP_ARP_Initialize+0x1c0>
        arpMod.deleteOld = arpData->deleteOld;
   1077a:	790a      	ldrb	r2, [r1, #4]
   1077c:	741a      	strb	r2, [r3, #16]
        nArpIfs = stackCtrl->nIfs;
   1077e:	6804      	ldr	r4, [r0, #0]
        if(arpMod.arpCacheDcpt != 0 && (arpData->deleteOld || arpMod.nIfs != nArpIfs))
   10780:	685b      	ldr	r3, [r3, #4]
   10782:	b133      	cbz	r3, 10792 <TCPIP_ARP_Initialize+0x3a>
   10784:	b91a      	cbnz	r2, 1078e <TCPIP_ARP_Initialize+0x36>
   10786:	4b66      	ldr	r3, [pc, #408]	; (10920 <TCPIP_ARP_Initialize+0x1c8>)
   10788:	681b      	ldr	r3, [r3, #0]
   1078a:	42a3      	cmp	r3, r4
   1078c:	d001      	beq.n	10792 <TCPIP_ARP_Initialize+0x3a>
            _ARPDeleteResources();
   1078e:	f008 fe35 	bl	193fc <_ARPDeleteResources>
        arpMod.memH = stackCtrl->memH;
   10792:	f8d9 000c 	ldr.w	r0, [r9, #12]
   10796:	4b62      	ldr	r3, [pc, #392]	; (10920 <TCPIP_ARP_Initialize+0x1c8>)
   10798:	6098      	str	r0, [r3, #8]
        arpMod.nIfs =  nArpIfs;
   1079a:	601c      	str	r4, [r3, #0]
        arpMod.entrySolvedTmo = arpData->entrySolvedTmo;
   1079c:	68aa      	ldr	r2, [r5, #8]
   1079e:	635a      	str	r2, [r3, #52]	; 0x34
        arpMod.entryPendingTmo = arpData->entryPendingTmo;
   107a0:	68ea      	ldr	r2, [r5, #12]
   107a2:	639a      	str	r2, [r3, #56]	; 0x38
        arpMod.entryRetryTmo = arpData->entryRetryTmo;
   107a4:	692a      	ldr	r2, [r5, #16]
   107a6:	63da      	str	r2, [r3, #60]	; 0x3c
        arpMod.permQuota = arpData->permQuota;
   107a8:	696a      	ldr	r2, [r5, #20]
   107aa:	641a      	str	r2, [r3, #64]	; 0x40
        arpMod.entryRetries = arpData->retries;
   107ac:	6a2a      	ldr	r2, [r5, #32]
   107ae:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
        arpMod.entryGratRetries =  arpData->gratProbeCount;
   107b2:	6a6a      	ldr	r2, [r5, #36]	; 0x24
   107b4:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
        if(arpMod.arpCacheDcpt == 0)
   107b8:	685b      	ldr	r3, [r3, #4]
   107ba:	b313      	cbz	r3, 10802 <TCPIP_ARP_Initialize+0xaa>
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   107bc:	4c58      	ldr	r4, [pc, #352]	; (10920 <TCPIP_ARP_Initialize+0x1c8>)
   107be:	6865      	ldr	r5, [r4, #4]
   107c0:	f8d9 0014 	ldr.w	r0, [r9, #20]
   107c4:	f013 fbb8 	bl	23f38 <TCPIP_STACK_NetIxGet>
    if(arpMod.deleteOld)
   107c8:	7c23      	ldrb	r3, [r4, #16]
   107ca:	2b00      	cmp	r3, #0
   107cc:	f040 809d 	bne.w	1090a <TCPIP_ARP_Initialize+0x1b2>
    arpMod.initCount++;
   107d0:	4a53      	ldr	r2, [pc, #332]	; (10920 <TCPIP_ARP_Initialize+0x1c8>)
   107d2:	68d3      	ldr	r3, [r2, #12]
   107d4:	3301      	adds	r3, #1
   107d6:	60d3      	str	r3, [r2, #12]
    return true;
   107d8:	2401      	movs	r4, #1
}
   107da:	4620      	mov	r0, r4
   107dc:	b003      	add	sp, #12
   107de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(arpMod.deleteOld)
   107e2:	4b4f      	ldr	r3, [pc, #316]	; (10920 <TCPIP_ARP_Initialize+0x1c8>)
   107e4:	7c1c      	ldrb	r4, [r3, #16]
   107e6:	b90c      	cbnz	r4, 107ec <TCPIP_ARP_Initialize+0x94>
        return true;
   107e8:	2401      	movs	r4, #1
   107ea:	e7f6      	b.n	107da <TCPIP_ARP_Initialize+0x82>
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   107ec:	685d      	ldr	r5, [r3, #4]
   107ee:	6940      	ldr	r0, [r0, #20]
   107f0:	f013 fba2 	bl	23f38 <TCPIP_STACK_NetIxGet>
   107f4:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
            _ARPRemoveCacheEntries(pArpDcpt);
   107f8:	eb05 00c0 	add.w	r0, r5, r0, lsl #3
   107fc:	f011 fbb6 	bl	21f6c <_ARPRemoveCacheEntries>
   10800:	e7eb      	b.n	107da <TCPIP_ARP_Initialize+0x82>
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Calloc)(h, nElems, elemSize);
   10802:	6883      	ldr	r3, [r0, #8]
   10804:	2248      	movs	r2, #72	; 0x48
   10806:	4621      	mov	r1, r4
   10808:	4798      	blx	r3
            arpMod.arpCacheDcpt = (ARP_CACHE_DCPT*)TCPIP_HEAP_Calloc(arpMod.memH, arpMod.nIfs, sizeof(*arpMod.arpCacheDcpt)); 
   1080a:	4b45      	ldr	r3, [pc, #276]	; (10920 <TCPIP_ARP_Initialize+0x1c8>)
   1080c:	6058      	str	r0, [r3, #4]
            if(arpMod.arpCacheDcpt == 0)
   1080e:	2800      	cmp	r0, #0
   10810:	f000 8084 	beq.w	1091c <TCPIP_ARP_Initialize+0x1c4>
            hashMemSize = sizeof(OA_HASH_DCPT) + arpData->cacheEntries * sizeof(ARP_HASH_ENTRY);
   10814:	682b      	ldr	r3, [r5, #0]
   10816:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1081a:	00db      	lsls	r3, r3, #3
   1081c:	3328      	adds	r3, #40	; 0x28
   1081e:	9301      	str	r3, [sp, #4]
            for(ix = 0, pArpDcpt = arpMod.arpCacheDcpt; ix < arpMod.nIfs; ix++, pArpDcpt++)
   10820:	4b3f      	ldr	r3, [pc, #252]	; (10920 <TCPIP_ARP_Initialize+0x1c8>)
   10822:	681b      	ldr	r3, [r3, #0]
   10824:	2b00      	cmp	r3, #0
   10826:	dd53      	ble.n	108d0 <TCPIP_ARP_Initialize+0x178>
   10828:	f100 062c 	add.w	r6, r0, #44	; 0x2c
                hashDcpt = (OA_HASH_DCPT*)TCPIP_HEAP_Malloc(arpMod.memH, hashMemSize);
   1082c:	f8df a0f0 	ldr.w	sl, [pc, #240]	; 10920 <TCPIP_ARP_Initialize+0x1c8>
                pArpDcpt->purgeThres = (arpData->purgeThres * pArpDcpt->hashDcpt->hEntries + 99)/100;
   10830:	f8df b104 	ldr.w	fp, [pc, #260]	; 10938 <TCPIP_ARP_Initialize+0x1e0>
   10834:	e022      	b.n	1087c <TCPIP_ARP_Initialize+0x124>
                    _ARPDeleteResources();
   10836:	f008 fde1 	bl	193fc <_ARPDeleteResources>
                    return false;
   1083a:	2400      	movs	r4, #0
   1083c:	e7cd      	b.n	107da <TCPIP_ARP_Initialize+0x82>
                    if((iniRes = TCPIP_Helper_ProtectedSingleListInitialize(&pArpDcpt->completeList)) == false)
   1083e:	f1a6 0014 	sub.w	r0, r6, #20
   10842:	f012 f858 	bl	228f6 <TCPIP_Helper_ProtectedSingleListInitialize>
   10846:	2800      	cmp	r0, #0
   10848:	d03e      	beq.n	108c8 <TCPIP_ARP_Initialize+0x170>
                    iniRes = TCPIP_Helper_ProtectedSingleListInitialize(&pArpDcpt->incompleteList);
   1084a:	4630      	mov	r0, r6
   1084c:	f012 f853 	bl	228f6 <TCPIP_Helper_ProtectedSingleListInitialize>
                if(iniRes == false)
   10850:	2800      	cmp	r0, #0
   10852:	d039      	beq.n	108c8 <TCPIP_ARP_Initialize+0x170>
                pArpDcpt->purgeThres = (arpData->purgeThres * pArpDcpt->hashDcpt->hEntries + 99)/100;
   10854:	f856 3c2c 	ldr.w	r3, [r6, #-44]
   10858:	68da      	ldr	r2, [r3, #12]
   1085a:	69ab      	ldr	r3, [r5, #24]
   1085c:	fb03 f302 	mul.w	r3, r3, r2
   10860:	3363      	adds	r3, #99	; 0x63
   10862:	fbab 2303 	umull	r2, r3, fp, r3
   10866:	095b      	lsrs	r3, r3, #5
   10868:	6173      	str	r3, [r6, #20]
                pArpDcpt->purgeQuanta = arpData->purgeQuanta;
   1086a:	69eb      	ldr	r3, [r5, #28]
   1086c:	61b3      	str	r3, [r6, #24]
            for(ix = 0, pArpDcpt = arpMod.arpCacheDcpt; ix < arpMod.nIfs; ix++, pArpDcpt++)
   1086e:	f108 0801 	add.w	r8, r8, #1
   10872:	3648      	adds	r6, #72	; 0x48
   10874:	f8da 3000 	ldr.w	r3, [sl]
   10878:	4543      	cmp	r3, r8
   1087a:	dd29      	ble.n	108d0 <TCPIP_ARP_Initialize+0x178>
   1087c:	f1a6 072c 	sub.w	r7, r6, #44	; 0x2c
                hashDcpt = (OA_HASH_DCPT*)TCPIP_HEAP_Malloc(arpMod.memH, hashMemSize);
   10880:	f8da 0008 	ldr.w	r0, [sl, #8]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
   10884:	6843      	ldr	r3, [r0, #4]
   10886:	9901      	ldr	r1, [sp, #4]
   10888:	4798      	blx	r3
                if(hashDcpt == 0)
   1088a:	4604      	mov	r4, r0
   1088c:	2800      	cmp	r0, #0
   1088e:	d0d2      	beq.n	10836 <TCPIP_ARP_Initialize+0xde>
                hashDcpt->memBlk = hashDcpt + 1;
   10890:	f100 0328 	add.w	r3, r0, #40	; 0x28
   10894:	6003      	str	r3, [r0, #0]
                hashDcpt->hParam = pArpDcpt;    // store the descriptor it belongs to
   10896:	6047      	str	r7, [r0, #4]
                hashDcpt->hEntrySize = sizeof(ARP_HASH_ENTRY);
   10898:	2318      	movs	r3, #24
   1089a:	6083      	str	r3, [r0, #8]
                hashDcpt->hEntries = arpData->cacheEntries;
   1089c:	682b      	ldr	r3, [r5, #0]
   1089e:	60c3      	str	r3, [r0, #12]
                hashDcpt->probeStep = ARP_HASH_PROBE_STEP;
   108a0:	2301      	movs	r3, #1
   108a2:	6103      	str	r3, [r0, #16]
                hashDcpt->hashF = TCPIP_ARP_HashKeyHash;
   108a4:	4b1f      	ldr	r3, [pc, #124]	; (10924 <TCPIP_ARP_Initialize+0x1cc>)
   108a6:	6143      	str	r3, [r0, #20]
                hashDcpt->delF = TCPIP_ARP_HashEntryDelete;
   108a8:	4b1f      	ldr	r3, [pc, #124]	; (10928 <TCPIP_ARP_Initialize+0x1d0>)
   108aa:	6183      	str	r3, [r0, #24]
                hashDcpt->cmpF = TCPIP_ARP_HashKeyCompare;
   108ac:	4b1f      	ldr	r3, [pc, #124]	; (1092c <TCPIP_ARP_Initialize+0x1d4>)
   108ae:	61c3      	str	r3, [r0, #28]
                hashDcpt->cpyF = TCPIP_ARP_HashKeyCopy; 
   108b0:	4b1f      	ldr	r3, [pc, #124]	; (10930 <TCPIP_ARP_Initialize+0x1d8>)
   108b2:	6203      	str	r3, [r0, #32]
                TCPIP_OAHASH_Initialize(hashDcpt);
   108b4:	f011 fdc3 	bl	2243e <TCPIP_OAHASH_Initialize>
                pArpDcpt->hashDcpt = hashDcpt;
   108b8:	f846 4c2c 	str.w	r4, [r6, #-44]
                    if((iniRes = TCPIP_Helper_ProtectedSingleListInitialize(&pArpDcpt->permList)) == false)
   108bc:	f1a6 0028 	sub.w	r0, r6, #40	; 0x28
   108c0:	f012 f819 	bl	228f6 <TCPIP_Helper_ProtectedSingleListInitialize>
   108c4:	2800      	cmp	r0, #0
   108c6:	d1ba      	bne.n	1083e <TCPIP_ARP_Initialize+0xe6>
                    _ARPDeleteResources();
   108c8:	f008 fd98 	bl	193fc <_ARPDeleteResources>
                    return false;
   108cc:	2400      	movs	r4, #0
   108ce:	e784      	b.n	107da <TCPIP_ARP_Initialize+0x82>
            arpMod.pMacPkt = _ARPAllocateTxPacket();
   108d0:	f011 fe5c 	bl	2258c <_ARPAllocateTxPacket>
   108d4:	4c12      	ldr	r4, [pc, #72]	; (10920 <TCPIP_ARP_Initialize+0x1c8>)
   108d6:	64a0      	str	r0, [r4, #72]	; 0x48
            arpMod.timerHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_ARP_Task, TCPIP_ARP_TASK_PROCESS_RATE);
   108d8:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
   108dc:	4915      	ldr	r1, [pc, #84]	; (10934 <TCPIP_ARP_Initialize+0x1dc>)
   108de:	2002      	movs	r0, #2
   108e0:	f00e fa5e 	bl	1eda0 <_TCPIPStackSignalHandlerRegister>
   108e4:	61e0      	str	r0, [r4, #28]
            iniRes = TCPIP_Notification_Initialize(&arpMod.registeredUsers);
   108e6:	f104 0020 	add.w	r0, r4, #32
   108ea:	f013 fd71 	bl	243d0 <TCPIP_Notification_Initialize>
            if(arpMod.pMacPkt == 0 || arpMod.timerHandle == 0 || iniRes == false)
   108ee:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   108f0:	b13b      	cbz	r3, 10902 <TCPIP_ARP_Initialize+0x1aa>
   108f2:	69e3      	ldr	r3, [r4, #28]
   108f4:	b12b      	cbz	r3, 10902 <TCPIP_ARP_Initialize+0x1aa>
   108f6:	b120      	cbz	r0, 10902 <TCPIP_ARP_Initialize+0x1aa>
            arpMod.timeSeconds = arpMod.timeMs = 0;
   108f8:	4b09      	ldr	r3, [pc, #36]	; (10920 <TCPIP_ARP_Initialize+0x1c8>)
   108fa:	2200      	movs	r2, #0
   108fc:	619a      	str	r2, [r3, #24]
   108fe:	615a      	str	r2, [r3, #20]
   10900:	e75c      	b.n	107bc <TCPIP_ARP_Initialize+0x64>
                _ARPDeleteResources();
   10902:	f008 fd7b 	bl	193fc <_ARPDeleteResources>
                return false;
   10906:	2400      	movs	r4, #0
   10908:	e767      	b.n	107da <TCPIP_ARP_Initialize+0x82>
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   1090a:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
        _ARPRemoveCacheEntries(pArpDcpt);
   1090e:	eb05 00c0 	add.w	r0, r5, r0, lsl #3
   10912:	f011 fb2b 	bl	21f6c <_ARPRemoveCacheEntries>
   10916:	e75b      	b.n	107d0 <TCPIP_ARP_Initialize+0x78>
            return false;
   10918:	2400      	movs	r4, #0
   1091a:	e75e      	b.n	107da <TCPIP_ARP_Initialize+0x82>
                return false;
   1091c:	2400      	movs	r4, #0
   1091e:	e75c      	b.n	107da <TCPIP_ARP_Initialize+0x82>
   10920:	2000e974 	.word	0x2000e974
   10924:	0002369d 	.word	0x0002369d
   10928:	000211bd 	.word	0x000211bd
   1092c:	000241e5 	.word	0x000241e5
   10930:	00024469 	.word	0x00024469
   10934:	0000dcbd 	.word	0x0000dcbd
   10938:	51eb851f 	.word	0x51eb851f

Disassembly of section .text.xTaskCreate%267:

0001093c <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
   1093c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10940:	4680      	mov	r8, r0
   10942:	460e      	mov	r6, r1
   10944:	4699      	mov	r9, r3
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
   10946:	0095      	lsls	r5, r2, #2
   10948:	4628      	mov	r0, r5
   1094a:	f00b fedd 	bl	1c708 <pvPortMalloc>

			if( pxStack != NULL )
   1094e:	2800      	cmp	r0, #0
   10950:	f000 80c2 	beq.w	10ad8 <xTaskCreate+0x19c>
   10954:	4607      	mov	r7, r0
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
   10956:	2054      	movs	r0, #84	; 0x54
   10958:	f00b fed6 	bl	1c708 <pvPortMalloc>

				if( pxNewTCB != NULL )
   1095c:	4604      	mov	r4, r0
   1095e:	2800      	cmp	r0, #0
   10960:	f000 8081 	beq.w	10a66 <xTaskCreate+0x12a>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
   10964:	6307      	str	r7, [r0, #48]	; 0x30

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
   10966:	462a      	mov	r2, r5
   10968:	21a5      	movs	r1, #165	; 0xa5
   1096a:	4638      	mov	r0, r7
   1096c:	f013 fa98 	bl	23ea0 <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
   10970:	6b27      	ldr	r7, [r4, #48]	; 0x30
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
   10972:	2e00      	cmp	r6, #0
   10974:	d07d      	beq.n	10a72 <xTaskCreate+0x136>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
   10976:	7833      	ldrb	r3, [r6, #0]
   10978:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
   1097c:	b153      	cbz	r3, 10994 <xTaskCreate+0x58>
   1097e:	4633      	mov	r3, r6
   10980:	f104 0134 	add.w	r1, r4, #52	; 0x34
   10984:	360f      	adds	r6, #15
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
   10986:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   1098a:	f801 2f01 	strb.w	r2, [r1, #1]!
			if( pcName[ x ] == ( char ) 0x00 )
   1098e:	b10a      	cbz	r2, 10994 <xTaskCreate+0x58>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   10990:	42b3      	cmp	r3, r6
   10992:	d1f8      	bne.n	10986 <xTaskCreate+0x4a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   10994:	2300      	movs	r3, #0
   10996:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   1099a:	9e0a      	ldr	r6, [sp, #40]	; 0x28
   1099c:	2e04      	cmp	r6, #4
   1099e:	bf28      	it	cs
   109a0:	2604      	movcs	r6, #4
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
   109a2:	62e6      	str	r6, [r4, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
   109a4:	6466      	str	r6, [r4, #68]	; 0x44
		pxNewTCB->uxMutexesHeld = 0;
   109a6:	f04f 0b00 	mov.w	fp, #0
   109aa:	f8c4 b048 	str.w	fp, [r4, #72]	; 0x48
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
   109ae:	f104 0a04 	add.w	sl, r4, #4
   109b2:	4650      	mov	r0, sl
   109b4:	f013 fd61 	bl	2447a <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
   109b8:	f104 0018 	add.w	r0, r4, #24
   109bc:	f013 fd5d 	bl	2447a <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
   109c0:	6124      	str	r4, [r4, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   109c2:	f1c6 0605 	rsb	r6, r6, #5
   109c6:	61a6      	str	r6, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
   109c8:	6264      	str	r4, [r4, #36]	; 0x24
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
   109ca:	f8c4 b04c 	str.w	fp, [r4, #76]	; 0x4c
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   109ce:	f884 b050 	strb.w	fp, [r4, #80]	; 0x50
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
   109d2:	3d04      	subs	r5, #4
   109d4:	443d      	add	r5, r7
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   109d6:	464a      	mov	r2, r9
   109d8:	4641      	mov	r1, r8
   109da:	f025 0007 	bic.w	r0, r5, #7
   109de:	f011 f8b9 	bl	21b54 <pxPortInitialiseStack>
   109e2:	6020      	str	r0, [r4, #0]
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
   109e4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   109e6:	b103      	cbz	r3, 109ea <xTaskCreate+0xae>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   109e8:	601c      	str	r4, [r3, #0]

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
   109ea:	f012 f9c9 	bl	22d80 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
   109ee:	4a3e      	ldr	r2, [pc, #248]	; (10ae8 <xTaskCreate+0x1ac>)
   109f0:	6813      	ldr	r3, [r2, #0]
   109f2:	3301      	adds	r3, #1
   109f4:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
   109f6:	4b3d      	ldr	r3, [pc, #244]	; (10aec <xTaskCreate+0x1b0>)
   109f8:	681b      	ldr	r3, [r3, #0]
   109fa:	2b00      	cmp	r3, #0
   109fc:	d03d      	beq.n	10a7a <xTaskCreate+0x13e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
   109fe:	4b3c      	ldr	r3, [pc, #240]	; (10af0 <xTaskCreate+0x1b4>)
   10a00:	681b      	ldr	r3, [r3, #0]
   10a02:	b93b      	cbnz	r3, 10a14 <xTaskCreate+0xd8>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
   10a04:	4b39      	ldr	r3, [pc, #228]	; (10aec <xTaskCreate+0x1b0>)
   10a06:	681b      	ldr	r3, [r3, #0]
   10a08:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10a0a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   10a0c:	429a      	cmp	r2, r3
				{
					pxCurrentTCB = pxNewTCB;
   10a0e:	bf9c      	itt	ls
   10a10:	4b36      	ldrls	r3, [pc, #216]	; (10aec <xTaskCreate+0x1b0>)
   10a12:	601c      	strls	r4, [r3, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
   10a14:	4a37      	ldr	r2, [pc, #220]	; (10af4 <xTaskCreate+0x1b8>)
   10a16:	6813      	ldr	r3, [r2, #0]
   10a18:	3301      	adds	r3, #1
   10a1a:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
   10a1c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   10a1e:	4a36      	ldr	r2, [pc, #216]	; (10af8 <xTaskCreate+0x1bc>)
   10a20:	6811      	ldr	r1, [r2, #0]
   10a22:	2301      	movs	r3, #1
   10a24:	4083      	lsls	r3, r0
   10a26:	430b      	orrs	r3, r1
   10a28:	6013      	str	r3, [r2, #0]
   10a2a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   10a2e:	4651      	mov	r1, sl
   10a30:	4b32      	ldr	r3, [pc, #200]	; (10afc <xTaskCreate+0x1c0>)
   10a32:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   10a36:	f012 ffed 	bl	23a14 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
   10a3a:	f013 f8c1 	bl	23bc0 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
   10a3e:	4b2c      	ldr	r3, [pc, #176]	; (10af0 <xTaskCreate+0x1b4>)
   10a40:	681b      	ldr	r3, [r3, #0]
   10a42:	2b00      	cmp	r3, #0
   10a44:	d04c      	beq.n	10ae0 <xTaskCreate+0x1a4>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
   10a46:	4b29      	ldr	r3, [pc, #164]	; (10aec <xTaskCreate+0x1b0>)
   10a48:	681b      	ldr	r3, [r3, #0]
   10a4a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10a4c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   10a4e:	429a      	cmp	r2, r3
   10a50:	d248      	bcs.n	10ae4 <xTaskCreate+0x1a8>
		{
			taskYIELD_IF_USING_PREEMPTION();
   10a52:	4b2b      	ldr	r3, [pc, #172]	; (10b00 <xTaskCreate+0x1c4>)
   10a54:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   10a58:	601a      	str	r2, [r3, #0]
   10a5a:	f3bf 8f4f 	dsb	sy
   10a5e:	f3bf 8f6f 	isb	sy
			xReturn = pdPASS;
   10a62:	2001      	movs	r0, #1
   10a64:	e03a      	b.n	10adc <xTaskCreate+0x1a0>
					vPortFree( pxStack );
   10a66:	4638      	mov	r0, r7
   10a68:	f00c fae9 	bl	1d03e <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   10a6c:	f04f 30ff 	mov.w	r0, #4294967295
   10a70:	e034      	b.n	10adc <xTaskCreate+0x1a0>
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
   10a72:	2300      	movs	r3, #0
   10a74:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
   10a78:	e78f      	b.n	1099a <xTaskCreate+0x5e>
			pxCurrentTCB = pxNewTCB;
   10a7a:	4b1c      	ldr	r3, [pc, #112]	; (10aec <xTaskCreate+0x1b0>)
   10a7c:	601c      	str	r4, [r3, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   10a7e:	6813      	ldr	r3, [r2, #0]
   10a80:	2b01      	cmp	r3, #1
   10a82:	d1c7      	bne.n	10a14 <xTaskCreate+0xd8>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   10a84:	4d1d      	ldr	r5, [pc, #116]	; (10afc <xTaskCreate+0x1c0>)
   10a86:	4628      	mov	r0, r5
   10a88:	f012 ffb9 	bl	239fe <vListInitialise>
   10a8c:	f105 0014 	add.w	r0, r5, #20
   10a90:	f012 ffb5 	bl	239fe <vListInitialise>
   10a94:	f105 0028 	add.w	r0, r5, #40	; 0x28
   10a98:	f012 ffb1 	bl	239fe <vListInitialise>
   10a9c:	f105 003c 	add.w	r0, r5, #60	; 0x3c
   10aa0:	f012 ffad 	bl	239fe <vListInitialise>
   10aa4:	f105 0050 	add.w	r0, r5, #80	; 0x50
   10aa8:	f012 ffa9 	bl	239fe <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
   10aac:	4e15      	ldr	r6, [pc, #84]	; (10b04 <xTaskCreate+0x1c8>)
   10aae:	4630      	mov	r0, r6
   10ab0:	f012 ffa5 	bl	239fe <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
   10ab4:	4d14      	ldr	r5, [pc, #80]	; (10b08 <xTaskCreate+0x1cc>)
   10ab6:	4628      	mov	r0, r5
   10ab8:	f012 ffa1 	bl	239fe <vListInitialise>
	vListInitialise( &xPendingReadyList );
   10abc:	4813      	ldr	r0, [pc, #76]	; (10b0c <xTaskCreate+0x1d0>)
   10abe:	f012 ff9e 	bl	239fe <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
   10ac2:	4813      	ldr	r0, [pc, #76]	; (10b10 <xTaskCreate+0x1d4>)
   10ac4:	f012 ff9b 	bl	239fe <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
   10ac8:	4812      	ldr	r0, [pc, #72]	; (10b14 <xTaskCreate+0x1d8>)
   10aca:	f012 ff98 	bl	239fe <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
   10ace:	4b12      	ldr	r3, [pc, #72]	; (10b18 <xTaskCreate+0x1dc>)
   10ad0:	601e      	str	r6, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   10ad2:	4b12      	ldr	r3, [pc, #72]	; (10b1c <xTaskCreate+0x1e0>)
   10ad4:	601d      	str	r5, [r3, #0]
   10ad6:	e79d      	b.n	10a14 <xTaskCreate+0xd8>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   10ad8:	f04f 30ff 	mov.w	r0, #4294967295
	}
   10adc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			xReturn = pdPASS;
   10ae0:	2001      	movs	r0, #1
   10ae2:	e7fb      	b.n	10adc <xTaskCreate+0x1a0>
   10ae4:	2001      	movs	r0, #1
		return xReturn;
   10ae6:	e7f9      	b.n	10adc <xTaskCreate+0x1a0>
   10ae8:	2000ef0c 	.word	0x2000ef0c
   10aec:	2000ef00 	.word	0x2000ef00
   10af0:	2000ef30 	.word	0x2000ef30
   10af4:	2000ef18 	.word	0x2000ef18
   10af8:	2000ef1c 	.word	0x2000ef1c
   10afc:	2000e850 	.word	0x2000e850
   10b00:	e000ed04 	.word	0xe000ed04
   10b04:	2000eca0 	.word	0x2000eca0
   10b08:	2000ecb4 	.word	0x2000ecb4
   10b0c:	2000ecc8 	.word	0x2000ecc8
   10b10:	2000ecf0 	.word	0x2000ecf0
   10b14:	2000ecdc 	.word	0x2000ecdc
   10b18:	2000ef04 	.word	0x2000ef04
   10b1c:	2000ef08 	.word	0x2000ef08

Disassembly of section .text._DHCPReceive%268:

00010b20 <_DHCPReceive>:
{
   10b20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10b24:	b0e1      	sub	sp, #388	; 0x184
   10b26:	4606      	mov	r6, r0
    s = dhcpClientSocket;
   10b28:	4b70      	ldr	r3, [pc, #448]	; (10cec <_DHCPReceive+0x1cc>)
   10b2a:	f9b3 4000 	ldrsh.w	r4, [r3]
        TCPIP_UDP_ArrayGet(s, &dhcpHdr.op, sizeof(dhcpHdr));
   10b2e:	222c      	movs	r2, #44	; 0x2c
   10b30:	a955      	add	r1, sp, #340	; 0x154
   10b32:	4620      	mov	r0, r4
   10b34:	f005 ff82 	bl	16a3c <TCPIP_UDP_ArrayGet>
        if ( dhcpHdr.op != TCPIP_BOOT_REPLY )
   10b38:	f89d 3154 	ldrb.w	r3, [sp, #340]	; 0x154
   10b3c:	2b02      	cmp	r3, #2
   10b3e:	d004      	beq.n	10b4a <_DHCPReceive+0x2a>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
   10b40:	2500      	movs	r5, #0
        TCPIP_UDP_Discard(s);                     
   10b42:	4620      	mov	r0, r4
   10b44:	f011 fef9 	bl	2293a <TCPIP_UDP_Discard>
    return msgType;
   10b48:	e05a      	b.n	10c00 <_DHCPReceive+0xe0>
        if(TCPIP_UDP_ArrayGet(s, 0, sizeof(TCPIP_DHCP_FRAME_OPT_HEADER)) != sizeof(TCPIP_DHCP_FRAME_OPT_HEADER))
   10b4a:	22c0      	movs	r2, #192	; 0xc0
   10b4c:	2100      	movs	r1, #0
   10b4e:	4620      	mov	r0, r4
   10b50:	f005 ff74 	bl	16a3c <TCPIP_UDP_ArrayGet>
   10b54:	28c0      	cmp	r0, #192	; 0xc0
   10b56:	d001      	beq.n	10b5c <_DHCPReceive+0x3c>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
   10b58:	2500      	movs	r5, #0
   10b5a:	e7f2      	b.n	10b42 <_DHCPReceive+0x22>
        optSize = (int32_t)TCPIP_UDP_ArrayGet(s, dhcpOpt.cookie, sizeof(dhcpOpt));
   10b5c:	f44f 729c 	mov.w	r2, #312	; 0x138
   10b60:	a907      	add	r1, sp, #28
   10b62:	4620      	mov	r0, r4
   10b64:	f005 ff6a 	bl	16a3c <TCPIP_UDP_ArrayGet>
   10b68:	4681      	mov	r9, r0
        if(optSize < sizeof(dhcpOpt.cookie) || (memcmp(dhcpOpt.cookie, dhcpMagicCookie, sizeof(dhcpOpt.cookie)) != 0))
   10b6a:	2803      	cmp	r0, #3
   10b6c:	f240 8091 	bls.w	10c92 <_DHCPReceive+0x172>
   10b70:	2204      	movs	r2, #4
   10b72:	495f      	ldr	r1, [pc, #380]	; (10cf0 <_DHCPReceive+0x1d0>)
   10b74:	a807      	add	r0, sp, #28
   10b76:	f012 fbab 	bl	232d0 <memcmp>
   10b7a:	4605      	mov	r5, r0
   10b7c:	b108      	cbz	r0, 10b82 <_DHCPReceive+0x62>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
   10b7e:	2500      	movs	r5, #0
   10b80:	e7df      	b.n	10b42 <_DHCPReceive+0x22>
        nNets = TCPIP_STACK_NumberOfNetworksGet();
   10b82:	f013 fb59 	bl	24238 <TCPIP_STACK_NumberOfNetworksGet>
        pSrchClient = DHCPClients; 
   10b86:	4b5b      	ldr	r3, [pc, #364]	; (10cf4 <_DHCPReceive+0x1d4>)
   10b88:	681f      	ldr	r7, [r3, #0]
        for(netIx = 0; netIx < nNets; netIx++, pSrchClient++) 
   10b8a:	f1b0 0800 	subs.w	r8, r0, #0
   10b8e:	f340 808d 	ble.w	10cac <_DHCPReceive+0x18c>
            if(pSrchClient->smState == TCPIP_DHCP_GET_OFFER || pSrchClient->smState == TCPIP_DHCP_GET_REQUEST_ACK ||
   10b92:	f240 2a85 	movw	sl, #645	; 0x285
                if(dhcpHdr.xid == pSrchClient->transactionID.Val && memcmp(dhcpHdr.chaddr, _TCPIPStack_NetMACAddressGet(pIf), sizeof(TCPIP_MAC_ADDR)) == 0)
   10b96:	f04f 0b06 	mov.w	fp, #6
   10b9a:	e007      	b.n	10bac <_DHCPReceive+0x8c>
   10b9c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   10b9e:	9a56      	ldr	r2, [sp, #344]	; 0x158
   10ba0:	429a      	cmp	r2, r3
   10ba2:	d01f      	beq.n	10be4 <_DHCPReceive+0xc4>
        for(netIx = 0; netIx < nNets; netIx++, pSrchClient++) 
   10ba4:	3501      	adds	r5, #1
   10ba6:	375c      	adds	r7, #92	; 0x5c
   10ba8:	45a8      	cmp	r8, r5
   10baa:	d07f      	beq.n	10cac <_DHCPReceive+0x18c>
            pIf = (TCPIP_NET_IF*)TCPIP_STACK_IndexToNet (netIx);
   10bac:	4628      	mov	r0, r5
   10bae:	f011 fa69 	bl	22084 <TCPIP_STACK_IndexToNet>
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   10bb2:	4601      	mov	r1, r0
   10bb4:	2800      	cmp	r0, #0
   10bb6:	d0f5      	beq.n	10ba4 <_DHCPReceive+0x84>
   10bb8:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   10bbc:	f013 0f40 	tst.w	r3, #64	; 0x40
   10bc0:	d0f0      	beq.n	10ba4 <_DHCPReceive+0x84>
            if(!TCPIP_STACK_NetworkIsUp(pIf) || pSrchClient->flags.bDHCPEnabled == false)
   10bc2:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
   10bc6:	f013 0f01 	tst.w	r3, #1
   10bca:	d0eb      	beq.n	10ba4 <_DHCPReceive+0x84>
            if(pSrchClient->smState == TCPIP_DHCP_GET_OFFER || pSrchClient->smState == TCPIP_DHCP_GET_REQUEST_ACK ||
   10bcc:	f8b7 3056 	ldrh.w	r3, [r7, #86]	; 0x56
   10bd0:	3b03      	subs	r3, #3
   10bd2:	b29b      	uxth	r3, r3
   10bd4:	2b09      	cmp	r3, #9
   10bd6:	d8e5      	bhi.n	10ba4 <_DHCPReceive+0x84>
   10bd8:	fa2a f303 	lsr.w	r3, sl, r3
   10bdc:	f013 0f01 	tst.w	r3, #1
   10be0:	d1dc      	bne.n	10b9c <_DHCPReceive+0x7c>
   10be2:	e7df      	b.n	10ba4 <_DHCPReceive+0x84>
                if(dhcpHdr.xid == pSrchClient->transactionID.Val && memcmp(dhcpHdr.chaddr, _TCPIPStack_NetMACAddressGet(pIf), sizeof(TCPIP_MAC_ADDR)) == 0)
   10be4:	465a      	mov	r2, fp
   10be6:	313c      	adds	r1, #60	; 0x3c
   10be8:	a85c      	add	r0, sp, #368	; 0x170
   10bea:	f012 fb71 	bl	232d0 <memcmp>
   10bee:	2800      	cmp	r0, #0
   10bf0:	d1d8      	bne.n	10ba4 <_DHCPReceive+0x84>
        if(pClient != pOwner)
   10bf2:	42be      	cmp	r6, r7
   10bf4:	d05c      	beq.n	10cb0 <_DHCPReceive+0x190>
        TCPIP_UDP_RxOffsetSet(s, 0);
   10bf6:	2100      	movs	r1, #0
   10bf8:	4620      	mov	r0, r4
   10bfa:	f00f ffe5 	bl	20bc8 <TCPIP_UDP_RxOffsetSet>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
   10bfe:	2500      	movs	r5, #0
}
   10c00:	4628      	mov	r0, r5
   10c02:	b061      	add	sp, #388	; 0x184
   10c04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        pEntry = _DHCPOptProcTbl;
   10c08:	4b3b      	ldr	r3, [pc, #236]	; (10cf8 <_DHCPReceive+0x1d8>)
                optLen = (*pEntry->dhcpProcFnc)(pClient, pOptData);
   10c0a:	685b      	ldr	r3, [r3, #4]
   10c0c:	4669      	mov	r1, sp
   10c0e:	4630      	mov	r0, r6
   10c10:	4798      	blx	r3
                if(optLen > 0)
   10c12:	2800      	cmp	r0, #0
   10c14:	dd06      	ble.n	10c24 <_DHCPReceive+0x104>
                    pOptData->pOpt += optLen;
   10c16:	9b00      	ldr	r3, [sp, #0]
   10c18:	4403      	add	r3, r0
   10c1a:	9300      	str	r3, [sp, #0]
                    pOptData->optSize -= optLen;
   10c1c:	9b01      	ldr	r3, [sp, #4]
   10c1e:	1a1b      	subs	r3, r3, r0
   10c20:	9301      	str	r3, [sp, #4]
        if(optFound == false)
   10c22:	e009      	b.n	10c38 <_DHCPReceive+0x118>
                else if(optLen == 0)
   10c24:	2800      	cmp	r0, #0
   10c26:	d036      	beq.n	10c96 <_DHCPReceive+0x176>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
   10c28:	2500      	movs	r5, #0
   10c2a:	e78a      	b.n	10b42 <_DHCPReceive+0x22>
            optLen = *(pOptData->pOpt + 1);
   10c2c:	7843      	ldrb	r3, [r0, #1]
            pOptData->pOpt += optLen + 2;
   10c2e:	3302      	adds	r3, #2
   10c30:	4418      	add	r0, r3
   10c32:	9000      	str	r0, [sp, #0]
            pOptData->optSize -= optLen + 2;
   10c34:	1ad3      	subs	r3, r2, r3
   10c36:	9301      	str	r3, [sp, #4]
    while(pOptData->optSize > 0)
   10c38:	9a01      	ldr	r2, [sp, #4]
   10c3a:	2a00      	cmp	r2, #0
   10c3c:	ddf4      	ble.n	10c28 <_DHCPReceive+0x108>
        opt = *pOptData->pOpt;
   10c3e:	9800      	ldr	r0, [sp, #0]
            if(opt == pEntry->option)
   10c40:	7801      	ldrb	r1, [r0, #0]
   10c42:	2935      	cmp	r1, #53	; 0x35
   10c44:	d0e0      	beq.n	10c08 <_DHCPReceive+0xe8>
        for(optIx = 0; optIx < sizeof(_DHCPOptProcTbl) / sizeof(*_DHCPOptProcTbl); optIx++, pEntry++)
   10c46:	f108 0308 	add.w	r3, r8, #8
            if(opt == pEntry->option)
   10c4a:	681f      	ldr	r7, [r3, #0]
   10c4c:	428f      	cmp	r7, r1
   10c4e:	d0dc      	beq.n	10c0a <_DHCPReceive+0xea>
        for(optIx = 0; optIx < sizeof(_DHCPOptProcTbl) / sizeof(*_DHCPOptProcTbl); optIx++, pEntry++)
   10c50:	3308      	adds	r3, #8
   10c52:	42ab      	cmp	r3, r5
   10c54:	d1f9      	bne.n	10c4a <_DHCPReceive+0x12a>
   10c56:	e7e9      	b.n	10c2c <_DHCPReceive+0x10c>
        if ( dhcpOptData.msgType == TCPIP_DHCP_OFFER_MESSAGE || (dhcpOptData.msgType == TCPIP_DHCP_ACK_MESSAGE && pClient->dhcpOp == TCPIP_DHCP_OPER_INIT_REBOOT))
   10c58:	f8b6 3054 	ldrh.w	r3, [r6, #84]	; 0x54
   10c5c:	2b02      	cmp	r3, #2
   10c5e:	d005      	beq.n	10c6c <_DHCPReceive+0x14c>
        else if(pClient->dwServerID != dhcpOptData.serverID.Val)
   10c60:	9a03      	ldr	r2, [sp, #12]
   10c62:	6a73      	ldr	r3, [r6, #36]	; 0x24
   10c64:	429a      	cmp	r2, r3
   10c66:	d00c      	beq.n	10c82 <_DHCPReceive+0x162>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
   10c68:	2500      	movs	r5, #0
    if(pOwner == 0)
   10c6a:	e76a      	b.n	10b42 <_DHCPReceive+0x22>
            pClient->dwServerID = dhcpOptData.serverID.Val;
   10c6c:	9b03      	ldr	r3, [sp, #12]
   10c6e:	6273      	str	r3, [r6, #36]	; 0x24
            pClient->flags.bOfferReceived = true;
   10c70:	f896 3058 	ldrb.w	r3, [r6, #88]	; 0x58
   10c74:	f043 0304 	orr.w	r3, r3, #4
   10c78:	f886 3058 	strb.w	r3, [r6, #88]	; 0x58
        if(msgType == TCPIP_DHCP_ACK_MESSAGE)
   10c7c:	2d05      	cmp	r5, #5
   10c7e:	f47f af60 	bne.w	10b42 <_DHCPReceive+0x22>
            _DHCPSetLeaseTimeParams(pClient, &dhcpOptData);
   10c82:	4669      	mov	r1, sp
   10c84:	4630      	mov	r0, r6
   10c86:	f009 fda9 	bl	1a7dc <_DHCPSetLeaseTimeParams>
        msgType = dhcpOptData.msgType;
   10c8a:	2505      	movs	r5, #5
   10c8c:	e759      	b.n	10b42 <_DHCPReceive+0x22>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
   10c8e:	2500      	movs	r5, #0
   10c90:	e757      	b.n	10b42 <_DHCPReceive+0x22>
   10c92:	2500      	movs	r5, #0
   10c94:	e755      	b.n	10b42 <_DHCPReceive+0x22>
        if ( dhcpOptData.msgType == TCPIP_DHCP_OFFER_MESSAGE || (dhcpOptData.msgType == TCPIP_DHCP_ACK_MESSAGE && pClient->dhcpOp == TCPIP_DHCP_OPER_INIT_REBOOT))
   10c96:	9d02      	ldr	r5, [sp, #8]
   10c98:	2d02      	cmp	r5, #2
   10c9a:	d0e7      	beq.n	10c6c <_DHCPReceive+0x14c>
   10c9c:	2d05      	cmp	r5, #5
   10c9e:	d0db      	beq.n	10c58 <_DHCPReceive+0x138>
        else if(pClient->dwServerID != dhcpOptData.serverID.Val)
   10ca0:	6a72      	ldr	r2, [r6, #36]	; 0x24
   10ca2:	9b03      	ldr	r3, [sp, #12]
   10ca4:	429a      	cmp	r2, r3
   10ca6:	d0e9      	beq.n	10c7c <_DHCPReceive+0x15c>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
   10ca8:	2500      	movs	r5, #0
   10caa:	e74a      	b.n	10b42 <_DHCPReceive+0x22>
        if(pClient != pOwner)
   10cac:	2e00      	cmp	r6, #0
   10cae:	d1ee      	bne.n	10c8e <_DHCPReceive+0x16e>
        if(!pClient->flags.bOfferReceived)
   10cb0:	f896 3058 	ldrb.w	r3, [r6, #88]	; 0x58
   10cb4:	f013 0f04 	tst.w	r3, #4
   10cb8:	d107      	bne.n	10cca <_DHCPReceive+0x1aa>
            pClient->dhcpIPAddress.Val = dhcpHdr.yiaddr;
   10cba:	9b59      	ldr	r3, [sp, #356]	; 0x164
   10cbc:	62f3      	str	r3, [r6, #44]	; 0x2c
            pClient->validValues.IPAddress = 1;
   10cbe:	f896 3059 	ldrb.w	r3, [r6, #89]	; 0x59
   10cc2:	f043 0301 	orr.w	r3, r3, #1
   10cc6:	f886 3059 	strb.w	r3, [r6, #89]	; 0x59
        memset(&dhcpOptData, 0, sizeof(dhcpOptData));
   10cca:	2300      	movs	r3, #0
   10ccc:	9302      	str	r3, [sp, #8]
   10cce:	9303      	str	r3, [sp, #12]
   10cd0:	9304      	str	r3, [sp, #16]
   10cd2:	9305      	str	r3, [sp, #20]
   10cd4:	9306      	str	r3, [sp, #24]
        dhcpOptData.pOpt = dhcpOpt.options;
   10cd6:	ab08      	add	r3, sp, #32
   10cd8:	9300      	str	r3, [sp, #0]
        dhcpOptData.optSize = optSize - sizeof(dhcpMagicCookie);   // eat up the cookie
   10cda:	f1a9 0304 	sub.w	r3, r9, #4
   10cde:	9301      	str	r3, [sp, #4]
        for(optIx = 0; optIx < sizeof(_DHCPOptProcTbl) / sizeof(*_DHCPOptProcTbl); optIx++, pEntry++)
   10ce0:	f8df 8014 	ldr.w	r8, [pc, #20]	; 10cf8 <_DHCPReceive+0x1d8>
   10ce4:	f108 0548 	add.w	r5, r8, #72	; 0x48
   10ce8:	e7a6      	b.n	10c38 <_DHCPReceive+0x118>
   10cea:	bf00      	nop
   10cec:	2000ef7e 	.word	0x2000ef7e
   10cf0:	00024494 	.word	0x00024494
   10cf4:	2000ee3c 	.word	0x2000ee3c
   10cf8:	0001ecc8 	.word	0x0001ecc8

Disassembly of section .text.GenericTxEnd%269:

00010cfc <GenericTxEnd>:
{
   10cfc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   10d00:	b085      	sub	sp, #20
   10d02:	4604      	mov	r4, r0
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
   10d04:	f8d0 20c4 	ldr.w	r2, [r0, #196]	; 0xc4
   10d08:	6855      	ldr	r5, [r2, #4]
    if(  pIState->remainingTxData  > 0u )
   10d0a:	f8b0 30b0 	ldrh.w	r3, [r0, #176]	; 0xb0
   10d0e:	b1db      	cbz	r3, 10d48 <GenericTxEnd+0x4c>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Socket send failed\r\n");
   10d10:	6813      	ldr	r3, [r2, #0]
   10d12:	681b      	ldr	r3, [r3, #0]
   10d14:	4968      	ldr	r1, [pc, #416]	; (10eb8 <GenericTxEnd+0x1bc>)
   10d16:	4628      	mov	r0, r5
   10d18:	4798      	blx	r3
        pIState->errorCount++;
   10d1a:	6b23      	ldr	r3, [r4, #48]	; 0x30
   10d1c:	3301      	adds	r3, #1
   10d1e:	6323      	str	r3, [r4, #48]	; 0x30
    pIState->lastPktId = pIState->pktId - 1;
   10d20:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   10d22:	3b01      	subs	r3, #1
   10d24:	62e3      	str	r3, [r4, #44]	; 0x2c
    if ( (int32_t)(SYS_TMR_TickCountGet() - pIState->lastCheckTime) >= (pIState->mInterval - TCPIP_IPERF_TIMING_ERROR_MARGIN) )
   10d26:	f011 fa89 	bl	2223c <SYS_TMR_TickCountGet>
   10d2a:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
   10d2e:	1ac0      	subs	r0, r0, r3
   10d30:	6823      	ldr	r3, [r4, #0]
   10d32:	4298      	cmp	r0, r3
   10d34:	f080 8086 	bcs.w	10e44 <GenericTxEnd+0x148>
    if ( pIState->isLastTransmit == true )
   10d38:	f894 30d0 	ldrb.w	r3, [r4, #208]	; 0xd0
   10d3c:	2b01      	cmp	r3, #1
   10d3e:	f000 8086 	beq.w	10e4e <GenericTxEnd+0x152>
}
   10d42:	b005      	add	sp, #20
   10d44:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if ( pIState->pktCount == 0u )
   10d48:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
   10d4c:	2b00      	cmp	r3, #0
   10d4e:	d153      	bne.n	10df8 <GenericTxEnd+0xfc>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: instance %d started ...\r\n", pIState - gIperfState);
   10d50:	4b5a      	ldr	r3, [pc, #360]	; (10ebc <GenericTxEnd+0x1c0>)
   10d52:	1ac3      	subs	r3, r0, r3
   10d54:	10db      	asrs	r3, r3, #3
   10d56:	eb03 01c3 	add.w	r1, r3, r3, lsl #3
   10d5a:	eb03 0341 	add.w	r3, r3, r1, lsl #1
   10d5e:	ebc3 2343 	rsb	r3, r3, r3, lsl #9
   10d62:	eb03 4383 	add.w	r3, r3, r3, lsl #18
   10d66:	4e56      	ldr	r6, [pc, #344]	; (10ec0 <GenericTxEnd+0x1c4>)
   10d68:	6812      	ldr	r2, [r2, #0]
   10d6a:	6857      	ldr	r7, [r2, #4]
   10d6c:	425a      	negs	r2, r3
   10d6e:	f506 61a7 	add.w	r1, r6, #1336	; 0x538
   10d72:	4628      	mov	r0, r5
   10d74:	47b8      	blx	r7
            lclAddress.Val = TCPIP_STACK_NetAddress(pIState->pNetIf);
   10d76:	f8d4 00c8 	ldr.w	r0, [r4, #200]	; 0xc8
   10d7a:	f012 f88e 	bl	22e9a <TCPIP_STACK_NetAddress>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Local  %u.%u.%u.%u port %u connected with\r\n",
   10d7e:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
   10d82:	681b      	ldr	r3, [r3, #0]
   10d84:	f8b4 207e 	ldrh.w	r2, [r4, #126]	; 0x7e
   10d88:	9202      	str	r2, [sp, #8]
   10d8a:	0e02      	lsrs	r2, r0, #24
   10d8c:	9201      	str	r2, [sp, #4]
   10d8e:	f3c0 4207 	ubfx	r2, r0, #16, #8
   10d92:	9200      	str	r2, [sp, #0]
   10d94:	685f      	ldr	r7, [r3, #4]
   10d96:	f3c0 2307 	ubfx	r3, r0, #8, #8
   10d9a:	b2c2      	uxtb	r2, r0
   10d9c:	f206 515c 	addw	r1, r6, #1372	; 0x55c
   10da0:	4628      	mov	r0, r5
   10da2:	47b8      	blx	r7
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Remote %u.%u.%u.%u port %u\r\n",
   10da4:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
   10da8:	681b      	ldr	r3, [r3, #0]
   10daa:	8a62      	ldrh	r2, [r4, #18]
   10dac:	9202      	str	r2, [sp, #8]
   10dae:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
   10db2:	9201      	str	r2, [sp, #4]
   10db4:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
   10db8:	9200      	str	r2, [sp, #0]
   10dba:	685f      	ldr	r7, [r3, #4]
   10dbc:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
   10dc0:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
   10dc4:	f506 61b2 	add.w	r1, r6, #1424	; 0x590
   10dc8:	4628      	mov	r0, r5
   10dca:	47b8      	blx	r7
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Target rate = %ld bps, period = %ld ms\r\n",
   10dcc:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
   10dd0:	681b      	ldr	r3, [r3, #0]
   10dd2:	f8d3 8004 	ldr.w	r8, [r3, #4]
                    (unsigned long)pIState->mTxRate, 
   10dd6:	f8d4 9018 	ldr.w	r9, [r4, #24]
                    (unsigned long)(pIState->mPktPeriod*1000/SYS_TMR_TickCounterFrequencyGet()) );
   10dda:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
   10dde:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
   10de2:	fb07 f703 	mul.w	r7, r7, r3
   10de6:	f011 fa51 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Target rate = %ld bps, period = %ld ms\r\n",
   10dea:	fbb7 f3f0 	udiv	r3, r7, r0
   10dee:	464a      	mov	r2, r9
   10df0:	f206 51b4 	addw	r1, r6, #1460	; 0x5b4
   10df4:	4628      	mov	r0, r5
   10df6:	47c0      	blx	r8
        pIState->pktId++;
   10df8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   10dfa:	3301      	adds	r3, #1
   10dfc:	62a3      	str	r3, [r4, #40]	; 0x28
        pIState->pktCount++;
   10dfe:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
   10e02:	3301      	adds	r3, #1
   10e04:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
        if ( pIState->mProtocol == UDP_PROTOCOL )
   10e08:	7c23      	ldrb	r3, [r4, #16]
   10e0a:	2b01      	cmp	r3, #1
   10e0c:	d00e      	beq.n	10e2c <GenericTxEnd+0x130>
        if ( pIState->mProtocol == TCP_PROTOCOL )
   10e0e:	2b02      	cmp	r3, #2
   10e10:	d186      	bne.n	10d20 <GenericTxEnd+0x24>
            pIState->totalLen += pIState->mMSS;
   10e12:	f8b4 00d2 	ldrh.w	r0, [r4, #210]	; 0xd2
   10e16:	f7fa fe4b 	bl	bab0 <__aeabi_i2d>
   10e1a:	4602      	mov	r2, r0
   10e1c:	460b      	mov	r3, r1
   10e1e:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
   10e22:	f7fa fcf9 	bl	b818 <__adddf3>
   10e26:	e9c4 0108 	strd	r0, r1, [r4, #32]
   10e2a:	e779      	b.n	10d20 <GenericTxEnd+0x24>
            pIState->totalLen += pIState->mDatagramSize;
   10e2c:	68e0      	ldr	r0, [r4, #12]
   10e2e:	f7fa fe2f 	bl	ba90 <__aeabi_ui2d>
   10e32:	4602      	mov	r2, r0
   10e34:	460b      	mov	r3, r1
   10e36:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
   10e3a:	f7fa fced 	bl	b818 <__adddf3>
   10e3e:	e9c4 0108 	strd	r0, r1, [r4, #32]
        if ( pIState->mProtocol == TCP_PROTOCOL )
   10e42:	e76d      	b.n	10d20 <GenericTxEnd+0x24>
        ReportBW_Jitter_Loss(pIState, INTERVAL_REPORT);
   10e44:	2100      	movs	r1, #0
   10e46:	4620      	mov	r0, r4
   10e48:	f7fd fb2a 	bl	e4a0 <ReportBW_Jitter_Loss>
   10e4c:	e774      	b.n	10d38 <GenericTxEnd+0x3c>
        switch(pIState->mProtocol)
   10e4e:	7c23      	ldrb	r3, [r4, #16]
   10e50:	2b01      	cmp	r3, #1
   10e52:	d009      	beq.n	10e68 <GenericTxEnd+0x16c>
   10e54:	2b02      	cmp	r3, #2
   10e56:	d02a      	beq.n	10eae <GenericTxEnd+0x1b2>
        pIState->sockWaitToSend = 0;
   10e58:	2300      	movs	r3, #0
   10e5a:	f884 30d4 	strb.w	r3, [r4, #212]	; 0xd4
        pIState->stopTime = SYS_TMR_TickCountGet();
   10e5e:	f011 f9ed 	bl	2223c <SYS_TMR_TickCountGet>
   10e62:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
}
   10e66:	e76c      	b.n	10d42 <GenericTxEnd+0x46>
                if(++pIState->nAttempts < UDP_FIN_RETRANSMIT_COUNT)
   10e68:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
   10e6c:	3301      	adds	r3, #1
   10e6e:	b2db      	uxtb	r3, r3
   10e70:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
   10e74:	2b09      	cmp	r3, #9
   10e76:	d815      	bhi.n	10ea4 <GenericTxEnd+0x1a8>
                    if ( pIState->nAttempts == 1u )
   10e78:	2b01      	cmp	r3, #1
   10e7a:	d003      	beq.n	10e84 <GenericTxEnd+0x188>
                    pIState->mPktPeriod = UDP_FIN_RETRANSMIT_PERIOD;
   10e7c:	230a      	movs	r3, #10
   10e7e:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
   10e82:	e7e9      	b.n	10e58 <GenericTxEnd+0x15c>
                        pIState->stopTime = SYS_TMR_TickCountGet();
   10e84:	f011 f9da 	bl	2223c <SYS_TMR_TickCountGet>
   10e88:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
                        ReportBW_Jitter_Loss(pIState, SUBTOTAL_REPORT);
   10e8c:	2101      	movs	r1, #1
   10e8e:	4620      	mov	r0, r4
   10e90:	f7fd fb06 	bl	e4a0 <ReportBW_Jitter_Loss>
                        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "    -----------------------------------------\r\n"); 
   10e94:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
   10e98:	681b      	ldr	r3, [r3, #0]
   10e9a:	681b      	ldr	r3, [r3, #0]
   10e9c:	4909      	ldr	r1, [pc, #36]	; (10ec4 <GenericTxEnd+0x1c8>)
   10e9e:	4628      	mov	r0, r5
   10ea0:	4798      	blx	r3
   10ea2:	e7eb      	b.n	10e7c <GenericTxEnd+0x180>
                    IperfSetState(pIState, IPERF_UDP_TX_DONE_STATE);
   10ea4:	2112      	movs	r1, #18
   10ea6:	4620      	mov	r0, r4
   10ea8:	f00c ff0c 	bl	1dcc4 <IperfSetState>
   10eac:	e7d4      	b.n	10e58 <GenericTxEnd+0x15c>
                IperfSetState(pIState, IPERF_TCP_TX_DONE_STATE);
   10eae:	210f      	movs	r1, #15
   10eb0:	4620      	mov	r0, r4
   10eb2:	f00c ff07 	bl	1dcc4 <IperfSetState>
                break;
   10eb6:	e7cf      	b.n	10e58 <GenericTxEnd+0x15c>
   10eb8:	00006018 	.word	0x00006018
   10ebc:	2000e380 	.word	0x2000e380
   10ec0:	00005afc 	.word	0x00005afc
   10ec4:	000060e0 	.word	0x000060e0

Disassembly of section .text._svfprintf_r%270:

00010ec8 <_svfiprintf_r>:
   10ec8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10ecc:	461e      	mov	r6, r3
   10ece:	898b      	ldrh	r3, [r1, #12]
   10ed0:	061b      	lsls	r3, r3, #24
   10ed2:	b09d      	sub	sp, #116	; 0x74
   10ed4:	4607      	mov	r7, r0
   10ed6:	460d      	mov	r5, r1
   10ed8:	4614      	mov	r4, r2
   10eda:	d50e      	bpl.n	10efa <_svfiprintf_r+0x32>
   10edc:	690b      	ldr	r3, [r1, #16]
   10ede:	b963      	cbnz	r3, 10efa <_svfiprintf_r+0x32>
   10ee0:	2140      	movs	r1, #64	; 0x40
   10ee2:	f007 fbed 	bl	186c0 <_malloc_r>
   10ee6:	6028      	str	r0, [r5, #0]
   10ee8:	6128      	str	r0, [r5, #16]
   10eea:	b920      	cbnz	r0, 10ef6 <_svfiprintf_r+0x2e>
   10eec:	230c      	movs	r3, #12
   10eee:	603b      	str	r3, [r7, #0]
   10ef0:	f04f 30ff 	mov.w	r0, #4294967295
   10ef4:	e0c3      	b.n	1107e <_svfiprintf_r+0x1b6>
   10ef6:	2340      	movs	r3, #64	; 0x40
   10ef8:	616b      	str	r3, [r5, #20]
   10efa:	2300      	movs	r3, #0
   10efc:	9309      	str	r3, [sp, #36]	; 0x24
   10efe:	f8df 9184 	ldr.w	r9, [pc, #388]	; 11084 <_svfiprintf_r+0x1bc>
   10f02:	9603      	str	r6, [sp, #12]
   10f04:	2320      	movs	r3, #32
   10f06:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
   10f0a:	2330      	movs	r3, #48	; 0x30
   10f0c:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
   10f10:	f04f 38ff 	mov.w	r8, #4294967295
   10f14:	f109 0a06 	add.w	sl, r9, #6
   10f18:	4623      	mov	r3, r4
   10f1a:	461e      	mov	r6, r3
   10f1c:	f813 2b01 	ldrb.w	r2, [r3], #1
   10f20:	b10a      	cbz	r2, 10f26 <_svfiprintf_r+0x5e>
   10f22:	2a25      	cmp	r2, #37	; 0x25
   10f24:	d1f9      	bne.n	10f1a <_svfiprintf_r+0x52>
   10f26:	ebb6 0b04 	subs.w	fp, r6, r4
   10f2a:	d00b      	beq.n	10f44 <_svfiprintf_r+0x7c>
   10f2c:	465b      	mov	r3, fp
   10f2e:	4622      	mov	r2, r4
   10f30:	4629      	mov	r1, r5
   10f32:	4638      	mov	r0, r7
   10f34:	f007 fa5a 	bl	183ec <__ssputs_r>
   10f38:	3001      	adds	r0, #1
   10f3a:	f000 809b 	beq.w	11074 <_svfiprintf_r+0x1ac>
   10f3e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   10f40:	445b      	add	r3, fp
   10f42:	9309      	str	r3, [sp, #36]	; 0x24
   10f44:	7833      	ldrb	r3, [r6, #0]
   10f46:	2b00      	cmp	r3, #0
   10f48:	f000 8094 	beq.w	11074 <_svfiprintf_r+0x1ac>
   10f4c:	2300      	movs	r3, #0
   10f4e:	e9cd 8305 	strd	r8, r3, [sp, #20]
   10f52:	3601      	adds	r6, #1
   10f54:	9304      	str	r3, [sp, #16]
   10f56:	9307      	str	r3, [sp, #28]
   10f58:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
   10f5c:	931a      	str	r3, [sp, #104]	; 0x68
   10f5e:	f04f 0b01 	mov.w	fp, #1
   10f62:	4634      	mov	r4, r6
   10f64:	2205      	movs	r2, #5
   10f66:	f814 1b01 	ldrb.w	r1, [r4], #1
   10f6a:	4846      	ldr	r0, [pc, #280]	; (11084 <_svfiprintf_r+0x1bc>)
   10f6c:	f008 fb38 	bl	195e0 <memchr>
   10f70:	9b04      	ldr	r3, [sp, #16]
   10f72:	b9c0      	cbnz	r0, 10fa6 <_svfiprintf_r+0xde>
   10f74:	06d8      	lsls	r0, r3, #27
   10f76:	bf44      	itt	mi
   10f78:	2220      	movmi	r2, #32
   10f7a:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
   10f7e:	0719      	lsls	r1, r3, #28
   10f80:	bf44      	itt	mi
   10f82:	222b      	movmi	r2, #43	; 0x2b
   10f84:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
   10f88:	7832      	ldrb	r2, [r6, #0]
   10f8a:	2a2a      	cmp	r2, #42	; 0x2a
   10f8c:	d013      	beq.n	10fb6 <_svfiprintf_r+0xee>
   10f8e:	9a07      	ldr	r2, [sp, #28]
   10f90:	4634      	mov	r4, r6
   10f92:	2000      	movs	r0, #0
   10f94:	260a      	movs	r6, #10
   10f96:	4621      	mov	r1, r4
   10f98:	f811 3b01 	ldrb.w	r3, [r1], #1
   10f9c:	3b30      	subs	r3, #48	; 0x30
   10f9e:	2b09      	cmp	r3, #9
   10fa0:	d94b      	bls.n	1103a <_svfiprintf_r+0x172>
   10fa2:	b970      	cbnz	r0, 10fc2 <_svfiprintf_r+0xfa>
   10fa4:	e014      	b.n	10fd0 <_svfiprintf_r+0x108>
   10fa6:	eba0 0009 	sub.w	r0, r0, r9
   10faa:	fa0b f000 	lsl.w	r0, fp, r0
   10fae:	4318      	orrs	r0, r3
   10fb0:	9004      	str	r0, [sp, #16]
   10fb2:	4626      	mov	r6, r4
   10fb4:	e7d5      	b.n	10f62 <_svfiprintf_r+0x9a>
   10fb6:	9a03      	ldr	r2, [sp, #12]
   10fb8:	1d11      	adds	r1, r2, #4
   10fba:	6812      	ldr	r2, [r2, #0]
   10fbc:	9103      	str	r1, [sp, #12]
   10fbe:	2a00      	cmp	r2, #0
   10fc0:	db01      	blt.n	10fc6 <_svfiprintf_r+0xfe>
   10fc2:	9207      	str	r2, [sp, #28]
   10fc4:	e004      	b.n	10fd0 <_svfiprintf_r+0x108>
   10fc6:	4252      	negs	r2, r2
   10fc8:	f043 0302 	orr.w	r3, r3, #2
   10fcc:	9207      	str	r2, [sp, #28]
   10fce:	9304      	str	r3, [sp, #16]
   10fd0:	7823      	ldrb	r3, [r4, #0]
   10fd2:	2b2e      	cmp	r3, #46	; 0x2e
   10fd4:	d10b      	bne.n	10fee <_svfiprintf_r+0x126>
   10fd6:	7863      	ldrb	r3, [r4, #1]
   10fd8:	2b2a      	cmp	r3, #42	; 0x2a
   10fda:	d133      	bne.n	11044 <_svfiprintf_r+0x17c>
   10fdc:	9b03      	ldr	r3, [sp, #12]
   10fde:	1d1a      	adds	r2, r3, #4
   10fe0:	681b      	ldr	r3, [r3, #0]
   10fe2:	9203      	str	r2, [sp, #12]
   10fe4:	2b00      	cmp	r3, #0
   10fe6:	bfb8      	it	lt
   10fe8:	4643      	movlt	r3, r8
   10fea:	3402      	adds	r4, #2
   10fec:	9305      	str	r3, [sp, #20]
   10fee:	2203      	movs	r2, #3
   10ff0:	7821      	ldrb	r1, [r4, #0]
   10ff2:	4825      	ldr	r0, [pc, #148]	; (11088 <_svfiprintf_r+0x1c0>)
   10ff4:	f008 faf4 	bl	195e0 <memchr>
   10ff8:	b140      	cbz	r0, 1100c <_svfiprintf_r+0x144>
   10ffa:	2340      	movs	r3, #64	; 0x40
   10ffc:	eba0 000a 	sub.w	r0, r0, sl
   11000:	fa03 f000 	lsl.w	r0, r3, r0
   11004:	9b04      	ldr	r3, [sp, #16]
   11006:	4303      	orrs	r3, r0
   11008:	3401      	adds	r4, #1
   1100a:	9304      	str	r3, [sp, #16]
   1100c:	f814 1b01 	ldrb.w	r1, [r4], #1
   11010:	481e      	ldr	r0, [pc, #120]	; (1108c <_svfiprintf_r+0x1c4>)
   11012:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
   11016:	2206      	movs	r2, #6
   11018:	f008 fae2 	bl	195e0 <memchr>
   1101c:	ab03      	add	r3, sp, #12
   1101e:	9300      	str	r3, [sp, #0]
   11020:	462a      	mov	r2, r5
   11022:	4b1b      	ldr	r3, [pc, #108]	; (11090 <_svfiprintf_r+0x1c8>)
   11024:	a904      	add	r1, sp, #16
   11026:	b308      	cbz	r0, 1106c <_svfiprintf_r+0x1a4>
   11028:	4638      	mov	r0, r7
   1102a:	f7f7 fa61 	bl	84f0 <_printf_float>
   1102e:	1c42      	adds	r2, r0, #1
   11030:	d020      	beq.n	11074 <_svfiprintf_r+0x1ac>
   11032:	9b09      	ldr	r3, [sp, #36]	; 0x24
   11034:	4403      	add	r3, r0
   11036:	9309      	str	r3, [sp, #36]	; 0x24
   11038:	e76e      	b.n	10f18 <_svfiprintf_r+0x50>
   1103a:	fb06 3202 	mla	r2, r6, r2, r3
   1103e:	2001      	movs	r0, #1
   11040:	460c      	mov	r4, r1
   11042:	e7a8      	b.n	10f96 <_svfiprintf_r+0xce>
   11044:	2300      	movs	r3, #0
   11046:	3401      	adds	r4, #1
   11048:	9305      	str	r3, [sp, #20]
   1104a:	4619      	mov	r1, r3
   1104c:	260a      	movs	r6, #10
   1104e:	4620      	mov	r0, r4
   11050:	f810 2b01 	ldrb.w	r2, [r0], #1
   11054:	3a30      	subs	r2, #48	; 0x30
   11056:	2a09      	cmp	r2, #9
   11058:	d903      	bls.n	11062 <_svfiprintf_r+0x19a>
   1105a:	2b00      	cmp	r3, #0
   1105c:	d0c7      	beq.n	10fee <_svfiprintf_r+0x126>
   1105e:	9105      	str	r1, [sp, #20]
   11060:	e7c5      	b.n	10fee <_svfiprintf_r+0x126>
   11062:	fb06 2101 	mla	r1, r6, r1, r2
   11066:	2301      	movs	r3, #1
   11068:	4604      	mov	r4, r0
   1106a:	e7f0      	b.n	1104e <_svfiprintf_r+0x186>
   1106c:	4638      	mov	r0, r7
   1106e:	f7fe fa4f 	bl	f510 <_printf_i>
   11072:	e7dc      	b.n	1102e <_svfiprintf_r+0x166>
   11074:	89ab      	ldrh	r3, [r5, #12]
   11076:	065b      	lsls	r3, r3, #25
   11078:	f53f af3a 	bmi.w	10ef0 <_svfiprintf_r+0x28>
   1107c:	9809      	ldr	r0, [sp, #36]	; 0x24
   1107e:	b01d      	add	sp, #116	; 0x74
   11080:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11084:	00023d0d 	.word	0x00023d0d
   11088:	00023d13 	.word	0x00023d13
   1108c:	00023d17 	.word	0x00023d17
   11090:	000183ed 	.word	0x000183ed

Disassembly of section .text.DRV_EXTPHY_MIIConfigure%271:

00011094 <DRV_EXTPHY_MIIConfigure>:
{
   11094:	b5f0      	push	{r4, r5, r6, r7, lr}
   11096:	b087      	sub	sp, #28
   11098:	4606      	mov	r6, r0
   1109a:	460d      	mov	r5, r1
    LAN867X_REG_OBJ clientObj = {0};
   1109c:	2100      	movs	r1, #0
   1109e:	9101      	str	r1, [sp, #4]
   110a0:	9102      	str	r1, [sp, #8]
    clientObj.miimBase =
   110a2:	692b      	ldr	r3, [r5, #16]
   110a4:	9304      	str	r3, [sp, #16]
    clientObj.miimHandle =
   110a6:	696b      	ldr	r3, [r5, #20]
   110a8:	9303      	str	r3, [sp, #12]
    clientObj.miimOpHandle = &((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)
   110aa:	f105 0318 	add.w	r3, r5, #24
   110ae:	9305      	str	r3, [sp, #20]
    pBaseObj->DRV_ETHPHY_PhyAddressGet(hClientObj, DRV_ETHPHY_INF_IDX_ALL_EXTERNAL,
   110b0:	6a83      	ldr	r3, [r0, #40]	; 0x28
   110b2:	aa01      	add	r2, sp, #4
   110b4:	4628      	mov	r0, r5
   110b6:	4798      	blx	r3
    pBaseObj->DRV_ETHPHY_VendorDataGet(hClientObj, &clientObj.vendorData);
   110b8:	6cb3      	ldr	r3, [r6, #72]	; 0x48
   110ba:	a902      	add	r1, sp, #8
   110bc:	4628      	mov	r0, r5
   110be:	4798      	blx	r3
    state = R2F(clientObj.vendorData, VENDOR_STATE);
   110c0:	f89d 400a 	ldrb.w	r4, [sp, #10]
    switch (state) {
   110c4:	2c0e      	cmp	r4, #14
   110c6:	f200 809d 	bhi.w	11204 <DRV_EXTPHY_MIIConfigure+0x170>
   110ca:	e8df f004 	tbb	[pc, r4]
   110ce:	2a08      	.short	0x2a08
   110d0:	4b423b32 	.word	0x4b423b32
   110d4:	6d655c53 	.word	0x6d655c53
   110d8:	8d877e76 	.word	0x8d877e76
   110dc:	94          	.byte	0x94
   110dd:	00          	.byte	0x00
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F00D0, 0x0E03, 0x0002);
   110de:	2302      	movs	r3, #2
   110e0:	f640 6203 	movw	r2, #3587	; 0xe03
   110e4:	494d      	ldr	r1, [pc, #308]	; (1121c <DRV_EXTPHY_MIIConfigure+0x188>)
   110e6:	a801      	add	r0, sp, #4
   110e8:	f008 fca0 	bl	19a2c <Lan867x_Write_Bit_Register>
        if (miimRes < 0) {
   110ec:	2800      	cmp	r0, #0
   110ee:	f2c0 808f 	blt.w	11210 <DRV_EXTPHY_MIIConfigure+0x17c>
        } else if (miimRes != DRV_MIIM_RES_OK) {
   110f2:	2800      	cmp	r0, #0
   110f4:	f040 808f 	bne.w	11216 <DRV_EXTPHY_MIIConfigure+0x182>
            ++state;
   110f8:	3401      	adds	r4, #1
   110fa:	b2a4      	uxth	r4, r4
                F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj.vendorData);
   110fc:	9b02      	ldr	r3, [sp, #8]
   110fe:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
            clientObj.vendorData =
   11102:	9302      	str	r3, [sp, #8]
            res = DRV_ETHPHY_RES_PENDING;
   11104:	2701      	movs	r7, #1
    clientObj.vendorData = F2R(state, VENDOR_STATE, clientObj.vendorData);
   11106:	9902      	ldr	r1, [sp, #8]
   11108:	f421 017f 	bic.w	r1, r1, #16711680	; 0xff0000
   1110c:	0424      	lsls	r4, r4, #16
   1110e:	f404 047f 	and.w	r4, r4, #16711680	; 0xff0000
   11112:	4321      	orrs	r1, r4
   11114:	9102      	str	r1, [sp, #8]
    pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, clientObj.vendorData);
   11116:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
   11118:	4628      	mov	r0, r5
   1111a:	4798      	blx	r3
}
   1111c:	4638      	mov	r0, r7
   1111e:	b007      	add	sp, #28
   11120:	bdf0      	pop	{r4, r5, r6, r7, pc}
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F00D1, 0x0300, 0x0000);
   11122:	2300      	movs	r3, #0
   11124:	f44f 7240 	mov.w	r2, #768	; 0x300
   11128:	493d      	ldr	r1, [pc, #244]	; (11220 <DRV_EXTPHY_MIIConfigure+0x18c>)
   1112a:	a801      	add	r0, sp, #4
   1112c:	f008 fc7e 	bl	19a2c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
   11130:	e7dc      	b.n	110ec <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0084, 0xFFC0, 0x3380);
   11132:	f44f 534e 	mov.w	r3, #13184	; 0x3380
   11136:	f64f 72c0 	movw	r2, #65472	; 0xffc0
   1113a:	493a      	ldr	r1, [pc, #232]	; (11224 <DRV_EXTPHY_MIIConfigure+0x190>)
   1113c:	a801      	add	r0, sp, #4
   1113e:	f008 fc75 	bl	19a2c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
   11142:	e7d3      	b.n	110ec <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0085, 0x000F, 0x0006);
   11144:	2306      	movs	r3, #6
   11146:	220f      	movs	r2, #15
   11148:	4937      	ldr	r1, [pc, #220]	; (11228 <DRV_EXTPHY_MIIConfigure+0x194>)
   1114a:	a801      	add	r0, sp, #4
   1114c:	f008 fc6e 	bl	19a2c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
   11150:	e7cc      	b.n	110ec <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F008A, 0xF800, 0xC000);
   11152:	f44f 4340 	mov.w	r3, #49152	; 0xc000
   11156:	f44f 4278 	mov.w	r2, #63488	; 0xf800
   1115a:	4934      	ldr	r1, [pc, #208]	; (1122c <DRV_EXTPHY_MIIConfigure+0x198>)
   1115c:	a801      	add	r0, sp, #4
   1115e:	f008 fc65 	bl	19a2c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
   11162:	e7c3      	b.n	110ec <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0087, 0x801C, 0x801C);
   11164:	f248 031c 	movw	r3, #32796	; 0x801c
   11168:	461a      	mov	r2, r3
   1116a:	4931      	ldr	r1, [pc, #196]	; (11230 <DRV_EXTPHY_MIIConfigure+0x19c>)
   1116c:	a801      	add	r0, sp, #4
   1116e:	f008 fc5d 	bl	19a2c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
   11172:	e7bb      	b.n	110ec <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0088, 0x1FFF, 0x033F);
   11174:	f240 333f 	movw	r3, #831	; 0x33f
   11178:	f641 72ff 	movw	r2, #8191	; 0x1fff
   1117c:	492d      	ldr	r1, [pc, #180]	; (11234 <DRV_EXTPHY_MIIConfigure+0x1a0>)
   1117e:	a801      	add	r0, sp, #4
   11180:	f008 fc54 	bl	19a2c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
   11184:	e7b2      	b.n	110ec <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F008B, 0xFFFF, 0x0404);
   11186:	f240 4304 	movw	r3, #1028	; 0x404
   1118a:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1118e:	492a      	ldr	r1, [pc, #168]	; (11238 <DRV_EXTPHY_MIIConfigure+0x1a4>)
   11190:	a801      	add	r0, sp, #4
   11192:	f008 fc4b 	bl	19a2c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
   11196:	e7a9      	b.n	110ec <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0080, 0x0600, 0x0600);
   11198:	f44f 63c0 	mov.w	r3, #1536	; 0x600
   1119c:	461a      	mov	r2, r3
   1119e:	4927      	ldr	r1, [pc, #156]	; (1123c <DRV_EXTPHY_MIIConfigure+0x1a8>)
   111a0:	a801      	add	r0, sp, #4
   111a2:	f008 fc43 	bl	19a2c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
   111a6:	e7a1      	b.n	110ec <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F00F1, 0x7F00, 0x2400);
   111a8:	f44f 5310 	mov.w	r3, #9216	; 0x2400
   111ac:	f44f 42fe 	mov.w	r2, #32512	; 0x7f00
   111b0:	4923      	ldr	r1, [pc, #140]	; (11240 <DRV_EXTPHY_MIIConfigure+0x1ac>)
   111b2:	a801      	add	r0, sp, #4
   111b4:	f008 fc3a 	bl	19a2c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
   111b8:	e798      	b.n	110ec <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0096, 0x2000, 0x2000);
   111ba:	f44f 5300 	mov.w	r3, #8192	; 0x2000
   111be:	461a      	mov	r2, r3
   111c0:	4920      	ldr	r1, [pc, #128]	; (11244 <DRV_EXTPHY_MIIConfigure+0x1b0>)
   111c2:	a801      	add	r0, sp, #4
   111c4:	f008 fc32 	bl	19a2c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
   111c8:	e790      	b.n	110ec <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0099, 0xFFFF, 0x7F80);
   111ca:	f44f 43ff 	mov.w	r3, #32640	; 0x7f80
   111ce:	f64f 72ff 	movw	r2, #65535	; 0xffff
   111d2:	491d      	ldr	r1, [pc, #116]	; (11248 <DRV_EXTPHY_MIIConfigure+0x1b4>)
   111d4:	a801      	add	r0, sp, #4
   111d6:	f008 fc29 	bl	19a2c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
   111da:	e787      	b.n	110ec <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Register(&clientObj, PHY_PLCA_BURST, registerValue);
   111dc:	2200      	movs	r2, #0
   111de:	491b      	ldr	r1, [pc, #108]	; (1124c <DRV_EXTPHY_MIIConfigure+0x1b8>)
   111e0:	a801      	add	r0, sp, #4
   111e2:	f00d ff45 	bl	1f070 <Lan867x_Write_Register>
    if (inProgress == true) {
   111e6:	e781      	b.n	110ec <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Register(&clientObj, PHY_PLCA_CONTROL_1, registerValue);
   111e8:	f44f 6200 	mov.w	r2, #2048	; 0x800
   111ec:	4918      	ldr	r1, [pc, #96]	; (11250 <DRV_EXTPHY_MIIConfigure+0x1bc>)
   111ee:	a801      	add	r0, sp, #4
   111f0:	f00d ff3e 	bl	1f070 <Lan867x_Write_Register>
    if (inProgress == true) {
   111f4:	e77a      	b.n	110ec <DRV_EXTPHY_MIIConfigure+0x58>
            Lan867x_Write_Register(&clientObj, PHY_PLCA_CONTROL_0, F2R_(1, PHY_PLCA_CTRL0_EN));
   111f6:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   111fa:	4916      	ldr	r1, [pc, #88]	; (11254 <DRV_EXTPHY_MIIConfigure+0x1c0>)
   111fc:	a801      	add	r0, sp, #4
   111fe:	f00d ff37 	bl	1f070 <Lan867x_Write_Register>
    if (inProgress == true) {
   11202:	e773      	b.n	110ec <DRV_EXTPHY_MIIConfigure+0x58>
        ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->operRes = DRV_ETHPHY_RES_OK;
   11204:	2700      	movs	r7, #0
   11206:	f885 702c 	strb.w	r7, [r5, #44]	; 0x2c
        ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->miimOpHandle = 0;
   1120a:	61af      	str	r7, [r5, #24]
        ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
   1120c:	86af      	strh	r7, [r5, #52]	; 0x34
    if (inProgress == true) {
   1120e:	e77a      	b.n	11106 <DRV_EXTPHY_MIIConfigure+0x72>
            res = DRV_ETHPHY_RES_MIIM_ERR;
   11210:	f06f 070c 	mvn.w	r7, #12
   11214:	e777      	b.n	11106 <DRV_EXTPHY_MIIConfigure+0x72>
            res = DRV_ETHPHY_RES_PENDING;
   11216:	2701      	movs	r7, #1
   11218:	e775      	b.n	11106 <DRV_EXTPHY_MIIConfigure+0x72>
   1121a:	bf00      	nop
   1121c:	001f00d0 	.word	0x001f00d0
   11220:	001f00d1 	.word	0x001f00d1
   11224:	001f0084 	.word	0x001f0084
   11228:	001f0085 	.word	0x001f0085
   1122c:	001f008a 	.word	0x001f008a
   11230:	001f0087 	.word	0x001f0087
   11234:	001f0088 	.word	0x001f0088
   11238:	001f008b 	.word	0x001f008b
   1123c:	001f0080 	.word	0x001f0080
   11240:	001f00f1 	.word	0x001f00f1
   11244:	001f0096 	.word	0x001f0096
   11248:	001f0099 	.word	0x001f0099
   1124c:	001fca05 	.word	0x001fca05
   11250:	001fca02 	.word	0x001fca02
   11254:	001fca01 	.word	0x001fca01

Disassembly of section .text._DHCPSend%272:

00011258 <_DHCPSend>:
{
   11258:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1125c:	b0d4      	sub	sp, #336	; 0x150
   1125e:	4606      	mov	r6, r0
   11260:	460d      	mov	r5, r1
   11262:	4617      	mov	r7, r2
   11264:	4698      	mov	r8, r3
    s = dhcpClientSocket;
   11266:	4b68      	ldr	r3, [pc, #416]	; (11408 <_DHCPSend+0x1b0>)
   11268:	f9b3 4000 	ldrsh.w	r4, [r3]
    if(TCPIP_UDP_PutIsReady(s) < TCPIP_DHCP_MIN_UDP_TX_AVLBL_SIZE)
   1126c:	4620      	mov	r0, r4
   1126e:	f00d fa42 	bl	1e6f6 <TCPIP_UDP_PutIsReady>
   11272:	f5b0 7f96 	cmp.w	r0, #300	; 0x12c
   11276:	d338      	bcc.n	112ea <_DHCPSend+0x92>
    TCPIP_UDP_SocketNetSet(s, pNetIf);
   11278:	4629      	mov	r1, r5
   1127a:	4620      	mov	r0, r4
   1127c:	f00e fc52 	bl	1fb24 <TCPIP_UDP_SocketNetSet>
    TCPIP_UDP_OptionsSet(s, UDP_OPTION_STRICT_NET, (void*)0);
   11280:	2200      	movs	r2, #0
   11282:	2101      	movs	r1, #1
   11284:	4620      	mov	r0, r4
   11286:	f7fe fe83 	bl	ff90 <TCPIP_UDP_OptionsSet>
    if((dhcpFlags & TCPIP_DHCP_FLAG_SEND_BCAST) != 0 || pClient->serverAddress.Val == 0)
   1128a:	f018 0f01 	tst.w	r8, #1
   1128e:	d101      	bne.n	11294 <_DHCPSend+0x3c>
   11290:	6ab3      	ldr	r3, [r6, #40]	; 0x28
   11292:	bb7b      	cbnz	r3, 112f4 <_DHCPSend+0x9c>
        TCPIP_UDP_BcastIPV4AddressSet(s, UDP_BCAST_NETWORK_LIMITED, pNetIf);
   11294:	462a      	mov	r2, r5
   11296:	2101      	movs	r1, #1
   11298:	4620      	mov	r0, r4
   1129a:	f00c fb08 	bl	1d8ae <TCPIP_UDP_BcastIPV4AddressSet>
    if((dhcpFlags & TCPIP_DHCP_FLAG_SEND_ZERO_ADD) != 0)
   1129e:	f018 0f02 	tst.w	r8, #2
    return pNetIf->netIPAddr.Val;
   112a2:	bf0c      	ite	eq
   112a4:	686b      	ldreq	r3, [r5, #4]
        sourceIp.Val = 0;
   112a6:	2300      	movne	r3, #0
   112a8:	9353      	str	r3, [sp, #332]	; 0x14c
    TCPIP_UDP_SourceIPAddressSet(s, IP_ADDRESS_TYPE_IPV4, (IP_MULTI_ADDRESS*) & sourceIp);
   112aa:	aa53      	add	r2, sp, #332	; 0x14c
   112ac:	2101      	movs	r1, #1
   112ae:	4620      	mov	r0, r4
   112b0:	f00e fa57 	bl	1f762 <TCPIP_UDP_SourceIPAddressSet>
    newTransaction = (messageType == TCPIP_DHCP_DISCOVER_MESSAGE || messageType == TCPIP_DHCP_REQUEST_RENEW_MESSAGE || (messageType == TCPIP_DHCP_REQUEST_MESSAGE && pClient->dhcpOp == TCPIP_DHCP_OPER_INIT_REBOOT));
   112b4:	f027 0308 	bic.w	r3, r7, #8
   112b8:	2b01      	cmp	r3, #1
   112ba:	d032      	beq.n	11322 <_DHCPSend+0xca>
   112bc:	2f03      	cmp	r7, #3
   112be:	d13a      	bne.n	11336 <_DHCPSend+0xde>
   112c0:	f8b6 3054 	ldrh.w	r3, [r6, #84]	; 0x54
   112c4:	2b02      	cmp	r3, #2
   112c6:	d02c      	beq.n	11322 <_DHCPSend+0xca>
    memset(pDhcpHdr, 0, sizeof(*pDhcpHdr));
   112c8:	222a      	movs	r2, #42	; 0x2a
   112ca:	2100      	movs	r1, #0
   112cc:	f10d 0016 	add.w	r0, sp, #22
   112d0:	f012 fde6 	bl	23ea0 <memset>
    pDhcpHdr->op = TCPIP_BOOT_REQUEST;
   112d4:	2301      	movs	r3, #1
   112d6:	f88d 3014 	strb.w	r3, [sp, #20]
    pDhcpHdr->htype = TCPIP_BOOT_HW_TYPE;
   112da:	f88d 3015 	strb.w	r3, [sp, #21]
    pDhcpHdr->hlen = TCPIP_BOOT_LEN_OF_HW_TYPE;
   112de:	2306      	movs	r3, #6
   112e0:	f88d 3016 	strb.w	r3, [sp, #22]
    pDhcpHdr->xid = pClient->transactionID.Val;
   112e4:	6c33      	ldr	r3, [r6, #64]	; 0x40
   112e6:	9306      	str	r3, [sp, #24]
    if( messageType == TCPIP_DHCP_RELEASE_MESSAGE || messageType == TCPIP_DHCP_REQUEST_RENEW_MESSAGE) 
   112e8:	e03b      	b.n	11362 <_DHCPSend+0x10a>
        TCPIP_UDP_Flush(s); // discard old data that may be there
   112ea:	4620      	mov	r0, r4
   112ec:	f7fe fa24 	bl	f738 <TCPIP_UDP_Flush>
        return false;
   112f0:	2000      	movs	r0, #0
   112f2:	e085      	b.n	11400 <_DHCPSend+0x1a8>
        TCPIP_UDP_DestinationIPAddressSet(s, IP_ADDRESS_TYPE_IPV4, (IP_MULTI_ADDRESS*)&pClient->serverAddress);
   112f4:	f106 0228 	add.w	r2, r6, #40	; 0x28
   112f8:	2101      	movs	r1, #1
   112fa:	4620      	mov	r0, r4
   112fc:	f00d fbc2 	bl	1ea84 <TCPIP_UDP_DestinationIPAddressSet>
   11300:	e7cd      	b.n	1129e <_DHCPSend+0x46>
   11302:	f00b fc0f 	bl	1cb24 <rand>
            pClient->transactionID.Val = SYS_RANDOM_PseudoGet(); 
   11306:	6430      	str	r0, [r6, #64]	; 0x40
   11308:	e00f      	b.n	1132a <_DHCPSend+0xd2>
    return pNetIf ? pNetIf->netMACAddr.v : 0;
   1130a:	462b      	mov	r3, r5
   1130c:	e02d      	b.n	1136a <_DHCPSend+0x112>
        dhcpWriteData.writeBytes = TCPIP_DHCP_MIN_TX_FRAME_SIZE - sizeof (*pDhcpHdr) - sizeof(*pOptHdr);
   1130e:	2340      	movs	r3, #64	; 0x40
   11310:	9303      	str	r3, [sp, #12]
   11312:	e06b      	b.n	113ec <_DHCPSend+0x194>
        TCPIP_UDP_TxOffsetSet(s , 0, false);
   11314:	2200      	movs	r2, #0
   11316:	4611      	mov	r1, r2
   11318:	4620      	mov	r0, r4
   1131a:	f00e fda0 	bl	1fe5e <TCPIP_UDP_TxOffsetSet>
        return false;
   1131e:	2000      	movs	r0, #0
   11320:	e06e      	b.n	11400 <_DHCPSend+0x1a8>
        if(pClient->flags.bRetry == false)
   11322:	f996 3058 	ldrsb.w	r3, [r6, #88]	; 0x58
   11326:	2b00      	cmp	r3, #0
   11328:	daeb      	bge.n	11302 <_DHCPSend+0xaa>
        pClient->flags.bOfferReceived = false;
   1132a:	f896 3058 	ldrb.w	r3, [r6, #88]	; 0x58
   1132e:	f36f 0382 	bfc	r3, #2, #1
   11332:	f886 3058 	strb.w	r3, [r6, #88]	; 0x58
    memset(pDhcpHdr, 0, sizeof(*pDhcpHdr));
   11336:	222a      	movs	r2, #42	; 0x2a
   11338:	2100      	movs	r1, #0
   1133a:	f10d 0016 	add.w	r0, sp, #22
   1133e:	f012 fdaf 	bl	23ea0 <memset>
    pDhcpHdr->op = TCPIP_BOOT_REQUEST;
   11342:	2301      	movs	r3, #1
   11344:	f88d 3014 	strb.w	r3, [sp, #20]
    pDhcpHdr->htype = TCPIP_BOOT_HW_TYPE;
   11348:	f88d 3015 	strb.w	r3, [sp, #21]
    pDhcpHdr->hlen = TCPIP_BOOT_LEN_OF_HW_TYPE;
   1134c:	2306      	movs	r3, #6
   1134e:	f88d 3016 	strb.w	r3, [sp, #22]
    pDhcpHdr->xid = pClient->transactionID.Val;
   11352:	6c33      	ldr	r3, [r6, #64]	; 0x40
   11354:	9306      	str	r3, [sp, #24]
    if( messageType == TCPIP_DHCP_RELEASE_MESSAGE || messageType == TCPIP_DHCP_REQUEST_RENEW_MESSAGE) 
   11356:	2f07      	cmp	r7, #7
   11358:	d001      	beq.n	1135e <_DHCPSend+0x106>
   1135a:	2f09      	cmp	r7, #9
   1135c:	d101      	bne.n	11362 <_DHCPSend+0x10a>
        pDhcpHdr->ciaddr = pClient->dhcpIPAddress.Val;
   1135e:	6af3      	ldr	r3, [r6, #44]	; 0x2c
   11360:	9308      	str	r3, [sp, #32]
   11362:	2d00      	cmp	r5, #0
   11364:	d0d1      	beq.n	1130a <_DHCPSend+0xb2>
   11366:	f105 033c 	add.w	r3, r5, #60	; 0x3c
    memcpy(pDhcpHdr->chaddr, _TCPIPStack_NetMACAddressGet(pNetIf), sizeof(TCPIP_MAC_ADDR));
   1136a:	6818      	ldr	r0, [r3, #0]
   1136c:	900c      	str	r0, [sp, #48]	; 0x30
   1136e:	889b      	ldrh	r3, [r3, #4]
   11370:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
    TCPIP_UDP_ArrayPut(s, (uint8_t*)pDhcpHdr, sizeof (*pDhcpHdr));
   11374:	222c      	movs	r2, #44	; 0x2c
   11376:	a905      	add	r1, sp, #20
   11378:	4620      	mov	r0, r4
   1137a:	f00d fb5e 	bl	1ea3a <TCPIP_UDP_ArrayPut>
    memset(pOptHdr, 0, sizeof(*pOptHdr));
   1137e:	26c0      	movs	r6, #192	; 0xc0
   11380:	4632      	mov	r2, r6
   11382:	2100      	movs	r1, #0
   11384:	a805      	add	r0, sp, #20
   11386:	f012 fd8b 	bl	23ea0 <memset>
    TCPIP_UDP_ArrayPut(s, (uint8_t*)pOptHdr, sizeof(*pOptHdr));
   1138a:	4632      	mov	r2, r6
   1138c:	a905      	add	r1, sp, #20
   1138e:	4620      	mov	r0, r4
   11390:	f00d fb53 	bl	1ea3a <TCPIP_UDP_ArrayPut>
    memset(pDOpt, 0, sizeof(*pDOpt));
   11394:	f44f 729c 	mov.w	r2, #312	; 0x138
   11398:	2100      	movs	r1, #0
   1139a:	a805      	add	r0, sp, #20
   1139c:	f012 fd80 	bl	23ea0 <memset>
    memcpy(pDOpt->cookie, dhcpMagicCookie, sizeof(pDOpt->cookie)); 
   113a0:	4b1a      	ldr	r3, [pc, #104]	; (1140c <_DHCPSend+0x1b4>)
   113a2:	681b      	ldr	r3, [r3, #0]
   113a4:	9305      	str	r3, [sp, #20]
    dhcpWriteData.pOpt = pDOpt->options;
   113a6:	ab06      	add	r3, sp, #24
   113a8:	9301      	str	r3, [sp, #4]
    dhcpWriteData.writeSpace = TCPIP_UDP_PutIsReady(s) - sizeof(pDOpt->cookie);
   113aa:	4620      	mov	r0, r4
   113ac:	f00d f9a3 	bl	1e6f6 <TCPIP_UDP_PutIsReady>
   113b0:	3804      	subs	r0, #4
   113b2:	9002      	str	r0, [sp, #8]
    dhcpWriteData.writeBytes = sizeof(pDOpt->cookie);
   113b4:	2304      	movs	r3, #4
   113b6:	9303      	str	r3, [sp, #12]
    dhcpWriteData.msgType = messageType;
   113b8:	9704      	str	r7, [sp, #16]
    for(optIx = 0; optIx < sizeof(_DHCPOptWriteTbl) / sizeof(*_DHCPOptWriteTbl); optIx++, pEntry++)
   113ba:	4f15      	ldr	r7, [pc, #84]	; (11410 <_DHCPSend+0x1b8>)
   113bc:	1f3e      	subs	r6, r7, #4
   113be:	3718      	adds	r7, #24
        optSize = (*pEntry->dhcpWriteFnc)(pNetIf, pSendData);
   113c0:	f856 3f04 	ldr.w	r3, [r6, #4]!
   113c4:	a901      	add	r1, sp, #4
   113c6:	4628      	mov	r0, r5
   113c8:	4798      	blx	r3
        if(optSize < 0)
   113ca:	2800      	cmp	r0, #0
   113cc:	dba2      	blt.n	11314 <_DHCPSend+0xbc>
        pSendData->writeSpace -= optSize;
   113ce:	9b02      	ldr	r3, [sp, #8]
   113d0:	1a1b      	subs	r3, r3, r0
   113d2:	9302      	str	r3, [sp, #8]
        pSendData->writeBytes += optSize;
   113d4:	9b03      	ldr	r3, [sp, #12]
   113d6:	4403      	add	r3, r0
   113d8:	9303      	str	r3, [sp, #12]
        pSendData->pOpt += optSize;
   113da:	9a01      	ldr	r2, [sp, #4]
   113dc:	4402      	add	r2, r0
   113de:	9201      	str	r2, [sp, #4]
    for(optIx = 0; optIx < sizeof(_DHCPOptWriteTbl) / sizeof(*_DHCPOptWriteTbl); optIx++, pEntry++)
   113e0:	42b7      	cmp	r7, r6
   113e2:	d1ed      	bne.n	113c0 <_DHCPSend+0x168>
    if(sizeof (*pDhcpHdr) + sizeof(*pOptHdr) + dhcpWriteData.writeBytes < TCPIP_DHCP_MIN_TX_FRAME_SIZE)
   113e4:	33ec      	adds	r3, #236	; 0xec
   113e6:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
   113ea:	d390      	bcc.n	1130e <_DHCPSend+0xb6>
    TCPIP_UDP_ArrayPut(s, pDOpt->cookie, dhcpWriteData.writeBytes);
   113ec:	f8bd 200c 	ldrh.w	r2, [sp, #12]
   113f0:	a905      	add	r1, sp, #20
   113f2:	4620      	mov	r0, r4
   113f4:	f00d fb21 	bl	1ea3a <TCPIP_UDP_ArrayPut>
    TCPIP_UDP_Flush(s);
   113f8:	4620      	mov	r0, r4
   113fa:	f7fe f99d 	bl	f738 <TCPIP_UDP_Flush>
    return true;
   113fe:	2001      	movs	r0, #1
}
   11400:	b054      	add	sp, #336	; 0x150
   11402:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11406:	bf00      	nop
   11408:	2000ef7e 	.word	0x2000ef7e
   1140c:	00024494 	.word	0x00024494
   11410:	0002304c 	.word	0x0002304c

Disassembly of section .text.DRV_GMAC_PacketRx%273:

00011414 <DRV_GMAC_PacketRx>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   11414:	4b69      	ldr	r3, [pc, #420]	; (115bc <DRV_GMAC_PacketRx+0x1a8>)
   11416:	4283      	cmp	r3, r0
   11418:	f040 80b0 	bne.w	1157c <DRV_GMAC_PacketRx+0x168>
    if(pMACDrv == 0)
   1141c:	2800      	cmp	r0, #0
   1141e:	f000 80af 	beq.w	11580 <DRV_GMAC_PacketRx+0x16c>
{
   11422:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   11426:	b086      	sub	sp, #24
   11428:	4690      	mov	r8, r2
   1142a:	468a      	mov	sl, r1
	TCPIP_MAC_PACKET		*pRxPkt = NULL;
   1142c:	2300      	movs	r3, #0
   1142e:	9305      	str	r3, [sp, #20]
	DRV_GMAC_RXDCPT_STATUS	pRxPktStat = {0};
   11430:	9304      	str	r3, [sp, #16]
	int                     buffsPerRxPkt = 0;
   11432:	9303      	str	r3, [sp, #12]
    queueIndex = DRV_PIC32CGMAC_LibGetHighPrioReadyQue();      
   11434:	f012 fb38 	bl	23aa8 <DRV_PIC32CGMAC_LibGetHighPrioReadyQue>
   11438:	4b61      	ldr	r3, [pc, #388]	; (115c0 <DRV_GMAC_PacketRx+0x1ac>)
   1143a:	7018      	strb	r0, [r3, #0]
    while(queueIndex != DRV_GMAC_NO_ACTIVE_QUEUE)
   1143c:	28ff      	cmp	r0, #255	; 0xff
   1143e:	d025      	beq.n	1148c <DRV_GMAC_PacketRx+0x78>
	if(pMACDrv->sGmacData._synchF != 0)
   11440:	4c5e      	ldr	r4, [pc, #376]	; (115bc <DRV_GMAC_PacketRx+0x1a8>)
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
   11442:	f104 065c 	add.w	r6, r4, #92	; 0x5c
        ethRes = DRV_PIC32CGMAC_LibRxGetPacket (pMACDrv, &pRxPkt, &buffsPerRxPkt, &pRxPktStat, queueIndex);
   11446:	461d      	mov	r5, r3
   11448:	e00b      	b.n	11462 <DRV_GMAC_PacketRx+0x4e>
        if(ethRes == DRV_PIC32CGMAC_RES_OK)
   1144a:	2f00      	cmp	r7, #0
   1144c:	f000 809e 	beq.w	1158c <DRV_GMAC_PacketRx+0x178>
            DRV_PIC32CGMAC_LibClearPriorityQue(pMACDrv,queueIndex);
   11450:	7829      	ldrb	r1, [r5, #0]
   11452:	4620      	mov	r0, r4
   11454:	f00f fae8 	bl	20a28 <DRV_PIC32CGMAC_LibClearPriorityQue>
            queueIndex = DRV_PIC32CGMAC_LibGetHighPrioReadyQue();
   11458:	f012 fb26 	bl	23aa8 <DRV_PIC32CGMAC_LibGetHighPrioReadyQue>
   1145c:	7028      	strb	r0, [r5, #0]
    while(queueIndex != DRV_GMAC_NO_ACTIVE_QUEUE)
   1145e:	28ff      	cmp	r0, #255	; 0xff
   11460:	d015      	beq.n	1148e <DRV_GMAC_PacketRx+0x7a>
	if(pMACDrv->sGmacData._synchF != 0)
   11462:	6b23      	ldr	r3, [r4, #48]	; 0x30
   11464:	b113      	cbz	r3, 1146c <DRV_GMAC_PacketRx+0x58>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
   11466:	2105      	movs	r1, #5
   11468:	4630      	mov	r0, r6
   1146a:	4798      	blx	r3
        ethRes = DRV_PIC32CGMAC_LibRxGetPacket (pMACDrv, &pRxPkt, &buffsPerRxPkt, &pRxPktStat, queueIndex);
   1146c:	782b      	ldrb	r3, [r5, #0]
   1146e:	9300      	str	r3, [sp, #0]
   11470:	ab04      	add	r3, sp, #16
   11472:	aa03      	add	r2, sp, #12
   11474:	a905      	add	r1, sp, #20
   11476:	4620      	mov	r0, r4
   11478:	f7fa f808 	bl	b48c <DRV_PIC32CGMAC_LibRxGetPacket>
   1147c:	4607      	mov	r7, r0
	if(pMACDrv->sGmacData._synchF != 0)
   1147e:	6b23      	ldr	r3, [r4, #48]	; 0x30
   11480:	2b00      	cmp	r3, #0
   11482:	d0e2      	beq.n	1144a <DRV_GMAC_PacketRx+0x36>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_LEAVE);
   11484:	2106      	movs	r1, #6
   11486:	4630      	mov	r0, r6
   11488:	4798      	blx	r3
   1148a:	e7de      	b.n	1144a <DRV_GMAC_PacketRx+0x36>
	DRV_PIC32CGMAC_RESULT	ethRes = DRV_PIC32CGMAC_RES_NO_PACKET;	
   1148c:	2701      	movs	r7, #1
	if(buffsPerRxPkt > 1)
   1148e:	9b03      	ldr	r3, [sp, #12]
   11490:	2b01      	cmp	r3, #1
   11492:	f340 8089 	ble.w	115a8 <DRV_GMAC_PacketRx+0x194>
        pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_SPLIT;
   11496:	9a05      	ldr	r2, [sp, #20]
   11498:	8c53      	ldrh	r3, [r2, #34]	; 0x22
   1149a:	f043 0304 	orr.w	r3, r3, #4
   1149e:	8453      	strh	r3, [r2, #34]	; 0x22
	if(ethRes == DRV_PIC32CGMAC_RES_PACKET_QUEUED || ethRes == DRV_PIC32CGMAC_RES_NO_PACKET)
   114a0:	1e7b      	subs	r3, r7, #1
   114a2:	b2db      	uxtb	r3, r3
   114a4:	2b01      	cmp	r3, #1
   114a6:	d81b      	bhi.n	114e0 <DRV_GMAC_PacketRx+0xcc>
		mRes = TCPIP_MAC_RES_PENDING;
   114a8:	2301      	movs	r3, #1
	if(pRes)
   114aa:	f1ba 0f00 	cmp.w	sl, #0
   114ae:	d06b      	beq.n	11588 <DRV_GMAC_PacketRx+0x174>
		*pRes = mRes;
   114b0:	f88a 3000 	strb.w	r3, [sl]
	if(mRes == TCPIP_MAC_RES_OK)
   114b4:	2b00      	cmp	r3, #0
   114b6:	d165      	bne.n	11584 <DRV_GMAC_PacketRx+0x170>
        pDSeg = pRxPkt->pDSeg;
   114b8:	9c05      	ldr	r4, [sp, #20]
   114ba:	6921      	ldr	r1, [r4, #16]
        pDSeg->segLoad = pDSeg->segBuffer + pMACDrv->sGmacData._dataOffset;
   114bc:	4b3f      	ldr	r3, [pc, #252]	; (115bc <DRV_GMAC_PacketRx+0x1a8>)
   114be:	f893 20f6 	ldrb.w	r2, [r3, #246]	; 0xf6
   114c2:	684b      	ldr	r3, [r1, #4]
   114c4:	4413      	add	r3, r2
   114c6:	608b      	str	r3, [r1, #8]
        pDSeg->segLen = pDSeg->segLen - sizeof(TCPIP_MAC_ETHERNET_HEADER);
   114c8:	898a      	ldrh	r2, [r1, #12]
   114ca:	3a0e      	subs	r2, #14
   114cc:	b292      	uxth	r2, r2
   114ce:	818a      	strh	r2, [r1, #12]
        if(pDSeg->next)
   114d0:	680b      	ldr	r3, [r1, #0]
   114d2:	b1d3      	cbz	r3, 1150a <DRV_GMAC_PacketRx+0xf6>
            pDSeg->segLen = pDSeg->segLen - pMACDrv->sGmacData._dataOffset;
   114d4:	4839      	ldr	r0, [pc, #228]	; (115bc <DRV_GMAC_PacketRx+0x1a8>)
   114d6:	f890 00f6 	ldrb.w	r0, [r0, #246]	; 0xf6
   114da:	1a12      	subs	r2, r2, r0
   114dc:	818a      	strh	r2, [r1, #12]
            while (pDSeg->next)
   114de:	e009      	b.n	114f4 <DRV_GMAC_PacketRx+0xe0>
	else if(ethRes == DRV_PIC32CGMAC_RES_OK)
   114e0:	2f00      	cmp	r7, #0
   114e2:	d056      	beq.n	11592 <DRV_GMAC_PacketRx+0x17e>
		pMACDrv->sGmacData._rxStat.nRxErrorPackets++;
   114e4:	4a35      	ldr	r2, [pc, #212]	; (115bc <DRV_GMAC_PacketRx+0x1a8>)
   114e6:	6f13      	ldr	r3, [r2, #112]	; 0x70
   114e8:	3301      	adds	r3, #1
   114ea:	6713      	str	r3, [r2, #112]	; 0x70
		mRes = TCPIP_MAC_RES_PACKET_ERR;
   114ec:	f06f 0309 	mvn.w	r3, #9
   114f0:	e7db      	b.n	114aa <DRV_GMAC_PacketRx+0x96>
            while (pDSeg->next)
   114f2:	4613      	mov	r3, r2
                pDSeg->segLoad = pDSeg->segBuffer;                
   114f4:	685a      	ldr	r2, [r3, #4]
   114f6:	609a      	str	r2, [r3, #8]
            while (pDSeg->next)
   114f8:	681a      	ldr	r2, [r3, #0]
   114fa:	2a00      	cmp	r2, #0
   114fc:	d1f9      	bne.n	114f2 <DRV_GMAC_PacketRx+0xde>
            pDSeg->segLen = pDSeg->segLen + pMACDrv->sGmacData._dataOffset;
   114fe:	4a2f      	ldr	r2, [pc, #188]	; (115bc <DRV_GMAC_PacketRx+0x1a8>)
   11500:	f892 20f6 	ldrb.w	r2, [r2, #246]	; 0xf6
   11504:	8999      	ldrh	r1, [r3, #12]
   11506:	440a      	add	r2, r1
   11508:	819a      	strh	r2, [r3, #12]
		pRxPkt->pMacLayer = pRxPkt->pDSeg->segLoad;
   1150a:	6923      	ldr	r3, [r4, #16]
   1150c:	689b      	ldr	r3, [r3, #8]
   1150e:	6163      	str	r3, [r4, #20]
		pRxPkt->pNetLayer = pRxPkt->pMacLayer + sizeof(TCPIP_MAC_ETHERNET_HEADER);
   11510:	330e      	adds	r3, #14
   11512:	61a3      	str	r3, [r4, #24]
		pRxPkt->tStamp = SYS_TMR_TickCountGet();
   11514:	f010 fe92 	bl	2223c <SYS_TMR_TickCountGet>
   11518:	6260      	str	r0, [r4, #36]	; 0x24
		pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_QUEUED;
   1151a:	9c05      	ldr	r4, [sp, #20]
		pRxPkt->pktFlags &= ~TCPIP_MAC_PKT_FLAG_CAST_MASK;
   1151c:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   1151e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
   11522:	b29b      	uxth	r3, r3
   11524:	f043 0208 	orr.w	r2, r3, #8
   11528:	8462      	strh	r2, [r4, #34]	; 0x22
		if(pRxPktStat.bm.bBroadcastDetected)
   1152a:	f89d 2013 	ldrb.w	r2, [sp, #19]
   1152e:	f012 0f80 	tst.w	r2, #128	; 0x80
   11532:	d106      	bne.n	11542 <DRV_GMAC_PacketRx+0x12e>
		else if(pRxPktStat.bm.bMultiHashMatch)
   11534:	f012 0f40 	tst.w	r2, #64	; 0x40
   11538:	d019      	beq.n	1156e <DRV_GMAC_PacketRx+0x15a>
			pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_MCAST;
   1153a:	f043 0348 	orr.w	r3, r3, #72	; 0x48
   1153e:	8463      	strh	r3, [r4, #34]	; 0x22
   11540:	e002      	b.n	11548 <DRV_GMAC_PacketRx+0x134>
			pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_BCAST;
   11542:	f043 0328 	orr.w	r3, r3, #40	; 0x28
   11546:	8463      	strh	r3, [r4, #34]	; 0x22
		if(pPktStat)
   11548:	f1b8 0f00 	cmp.w	r8, #0
   1154c:	d004      	beq.n	11558 <DRV_GMAC_PacketRx+0x144>
			*pPktStat = *(TCPIP_MAC_PACKET_RX_STAT*)&pRxPktStat;
   1154e:	ab06      	add	r3, sp, #24
   11550:	e913 0003 	ldmdb	r3, {r0, r1}
   11554:	e888 0003 	stmia.w	r8, {r0, r1}
        pRxPkt->pktPriority = DRV_PIC32CGMAC_LibGetPriorityFromQueueNum(pMACDrv, queueIndex);
   11558:	4b19      	ldr	r3, [pc, #100]	; (115c0 <DRV_GMAC_PacketRx+0x1ac>)
   1155a:	7819      	ldrb	r1, [r3, #0]
   1155c:	4817      	ldr	r0, [pc, #92]	; (115bc <DRV_GMAC_PacketRx+0x1a8>)
   1155e:	f010 fee5 	bl	2232c <DRV_PIC32CGMAC_LibGetPriorityFromQueueNum>
   11562:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
		return pRxPkt;
   11566:	9805      	ldr	r0, [sp, #20]
}
   11568:	b006      	add	sp, #24
   1156a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		else if(pRxPktStat.bm.bUniHashMatch)
   1156e:	f012 0f20 	tst.w	r2, #32
			pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_UNICAST;
   11572:	bf1c      	itt	ne
   11574:	f043 0318 	orrne.w	r3, r3, #24
   11578:	8463      	strhne	r3, [r4, #34]	; 0x22
   1157a:	e7e5      	b.n	11548 <DRV_GMAC_PacketRx+0x134>
        return 0;
   1157c:	2000      	movs	r0, #0
   1157e:	4770      	bx	lr
   11580:	2000      	movs	r0, #0
}
   11582:	4770      	bx	lr
    return 0;
   11584:	2000      	movs	r0, #0
   11586:	e7ef      	b.n	11568 <DRV_GMAC_PacketRx+0x154>
   11588:	4650      	mov	r0, sl
   1158a:	e7ed      	b.n	11568 <DRV_GMAC_PacketRx+0x154>
	if(buffsPerRxPkt > 1)
   1158c:	9b03      	ldr	r3, [sp, #12]
   1158e:	2b01      	cmp	r3, #1
   11590:	dc81      	bgt.n	11496 <DRV_GMAC_PacketRx+0x82>
		pMACDrv->sGmacData._rxStat.nRxOkPackets++;		
   11592:	4a0a      	ldr	r2, [pc, #40]	; (115bc <DRV_GMAC_PacketRx+0x1a8>)
   11594:	6e53      	ldr	r3, [r2, #100]	; 0x64
   11596:	3301      	adds	r3, #1
   11598:	6653      	str	r3, [r2, #100]	; 0x64
	if(pRes)
   1159a:	f1ba 0f00 	cmp.w	sl, #0
   1159e:	d08b      	beq.n	114b8 <DRV_GMAC_PacketRx+0xa4>
		*pRes = mRes;
   115a0:	2300      	movs	r3, #0
   115a2:	f88a 3000 	strb.w	r3, [sl]
	if(mRes == TCPIP_MAC_RES_OK)
   115a6:	e787      	b.n	114b8 <DRV_GMAC_PacketRx+0xa4>
	if(ethRes == DRV_PIC32CGMAC_RES_PACKET_QUEUED || ethRes == DRV_PIC32CGMAC_RES_NO_PACKET)
   115a8:	f107 39ff 	add.w	r9, r7, #4294967295
   115ac:	fa5f f989 	uxtb.w	r9, r9
   115b0:	f1b9 0f01 	cmp.w	r9, #1
   115b4:	d896      	bhi.n	114e4 <DRV_GMAC_PacketRx+0xd0>
		mRes = TCPIP_MAC_RES_PENDING;
   115b6:	2301      	movs	r3, #1
   115b8:	e777      	b.n	114aa <DRV_GMAC_PacketRx+0x96>
   115ba:	bf00      	nop
   115bc:	2000e288 	.word	0x2000e288
   115c0:	2000eba3 	.word	0x2000eba3

Disassembly of section .text.DRV_PIC32CGMAC_LibRxFilterHash_Calculate%274:

000115c4 <DRV_PIC32CGMAC_LibRxFilterHash_Calculate>:
    if(hash->calculate_hash == true) // Calculate hash for given MAC address
   115c4:	7b0b      	ldrb	r3, [r1, #12]
   115c6:	2b01      	cmp	r3, #1
   115c8:	d008      	beq.n	115dc <DRV_PIC32CGMAC_LibRxFilterHash_Calculate+0x18>
        hash_value = hash->hash_value;
   115ca:	680b      	ldr	r3, [r1, #0]
   115cc:	6849      	ldr	r1, [r1, #4]
    GMAC_REGS->GMAC_HRB = hash_value & 0xffffffff;
   115ce:	4a68      	ldr	r2, [pc, #416]	; (11770 <DRV_PIC32CGMAC_LibRxFilterHash_Calculate+0x1ac>)
   115d0:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
    GMAC_REGS->GMAC_HRT = (hash_value >> 32) & 0xffffffff;    
   115d4:	f8c2 1084 	str.w	r1, [r2, #132]	; 0x84
}
   115d8:	2000      	movs	r0, #0
   115da:	4770      	bx	lr
{
   115dc:	b4f0      	push	{r4, r5, r6, r7}
        mac_addr = (DRV_GMAC_MAC_ADDR*)(hash->DestMACAddr);
   115de:	6888      	ldr	r0, [r1, #8]
        hash_Index.index = 0;      
   115e0:	f04f 0100 	mov.w	r1, #0
        hash_Index.bits.b0 = (mac_addr[5].bits.b0)^(mac_addr[5].bits.b6)^(mac_addr[4].bits.b4)^(mac_addr[3].bits.b2)^(mac_addr[2].bits.b0)^(mac_addr[2].bits.b6)^(mac_addr[1].bits.b4)^(mac_addr[0].bits.b2);
   115e4:	7943      	ldrb	r3, [r0, #5]
   115e6:	f3c3 0200 	ubfx	r2, r3, #0, #1
   115ea:	f3c3 1480 	ubfx	r4, r3, #6, #1
   115ee:	4062      	eors	r2, r4
   115f0:	7907      	ldrb	r7, [r0, #4]
   115f2:	f3c7 1400 	ubfx	r4, r7, #4, #1
   115f6:	4062      	eors	r2, r4
   115f8:	78c6      	ldrb	r6, [r0, #3]
   115fa:	f3c6 0480 	ubfx	r4, r6, #2, #1
   115fe:	4062      	eors	r2, r4
   11600:	7885      	ldrb	r5, [r0, #2]
   11602:	f3c5 0400 	ubfx	r4, r5, #0, #1
   11606:	4062      	eors	r2, r4
   11608:	f3c5 1480 	ubfx	r4, r5, #6, #1
   1160c:	4062      	eors	r2, r4
   1160e:	7844      	ldrb	r4, [r0, #1]
   11610:	f3c4 1c00 	ubfx	ip, r4, #4, #1
   11614:	ea82 020c 	eor.w	r2, r2, ip
   11618:	7800      	ldrb	r0, [r0, #0]
   1161a:	f3c0 0c80 	ubfx	ip, r0, #2, #1
   1161e:	ea82 020c 	eor.w	r2, r2, ip
   11622:	f362 0100 	bfi	r1, r2, #0, #1
        hash_Index.bits.b1 = (mac_addr[5].bits.b1)^(mac_addr[5].bits.b7)^(mac_addr[4].bits.b5)^(mac_addr[3].bits.b3)^(mac_addr[2].bits.b1)^(mac_addr[2].bits.b7)^(mac_addr[1].bits.b5)^(mac_addr[0].bits.b3);
   11626:	f3c3 0240 	ubfx	r2, r3, #1, #1
   1162a:	f3c3 1cc0 	ubfx	ip, r3, #7, #1
   1162e:	ea82 020c 	eor.w	r2, r2, ip
   11632:	f3c7 1c40 	ubfx	ip, r7, #5, #1
   11636:	ea82 020c 	eor.w	r2, r2, ip
   1163a:	f3c6 0cc0 	ubfx	ip, r6, #3, #1
   1163e:	ea82 020c 	eor.w	r2, r2, ip
   11642:	f3c5 0c40 	ubfx	ip, r5, #1, #1
   11646:	ea82 12d5 	eor.w	r2, r2, r5, lsr #7
   1164a:	ea82 020c 	eor.w	r2, r2, ip
   1164e:	f3c4 1c40 	ubfx	ip, r4, #5, #1
   11652:	ea82 020c 	eor.w	r2, r2, ip
   11656:	f3c0 0cc0 	ubfx	ip, r0, #3, #1
   1165a:	ea82 020c 	eor.w	r2, r2, ip
   1165e:	f362 0141 	bfi	r1, r2, #1, #1
        hash_Index.bits.b2 = (mac_addr[5].bits.b2)^(mac_addr[4].bits.b0)^(mac_addr[4].bits.b6)^(mac_addr[3].bits.b4)^(mac_addr[2].bits.b2)^(mac_addr[1].bits.b0)^(mac_addr[1].bits.b6)^(mac_addr[0].bits.b4);
   11662:	f3c3 0280 	ubfx	r2, r3, #2, #1
   11666:	f3c7 0c00 	ubfx	ip, r7, #0, #1
   1166a:	ea82 020c 	eor.w	r2, r2, ip
   1166e:	f3c7 1c80 	ubfx	ip, r7, #6, #1
   11672:	ea82 020c 	eor.w	r2, r2, ip
   11676:	f3c6 1c00 	ubfx	ip, r6, #4, #1
   1167a:	ea82 020c 	eor.w	r2, r2, ip
   1167e:	f3c5 0c80 	ubfx	ip, r5, #2, #1
   11682:	ea82 020c 	eor.w	r2, r2, ip
   11686:	f3c4 0c00 	ubfx	ip, r4, #0, #1
   1168a:	ea82 020c 	eor.w	r2, r2, ip
   1168e:	f3c4 1c80 	ubfx	ip, r4, #6, #1
   11692:	ea82 020c 	eor.w	r2, r2, ip
   11696:	f3c0 1c00 	ubfx	ip, r0, #4, #1
   1169a:	ea82 020c 	eor.w	r2, r2, ip
   1169e:	f362 0182 	bfi	r1, r2, #2, #1
        hash_Index.bits.b3 = (mac_addr[5].bits.b3)^(mac_addr[4].bits.b1)^(mac_addr[4].bits.b7)^(mac_addr[3].bits.b5)^(mac_addr[2].bits.b3)^(mac_addr[1].bits.b1)^(mac_addr[1].bits.b7)^(mac_addr[0].bits.b5);
   116a2:	f3c3 02c0 	ubfx	r2, r3, #3, #1
   116a6:	f3c7 0c40 	ubfx	ip, r7, #1, #1
   116aa:	ea82 12d7 	eor.w	r2, r2, r7, lsr #7
   116ae:	ea82 020c 	eor.w	r2, r2, ip
   116b2:	f3c6 1c40 	ubfx	ip, r6, #5, #1
   116b6:	ea82 020c 	eor.w	r2, r2, ip
   116ba:	f3c5 0cc0 	ubfx	ip, r5, #3, #1
   116be:	ea82 020c 	eor.w	r2, r2, ip
   116c2:	f3c4 0c40 	ubfx	ip, r4, #1, #1
   116c6:	ea82 12d4 	eor.w	r2, r2, r4, lsr #7
   116ca:	ea82 020c 	eor.w	r2, r2, ip
   116ce:	f3c0 1c40 	ubfx	ip, r0, #5, #1
   116d2:	ea82 020c 	eor.w	r2, r2, ip
   116d6:	f362 01c3 	bfi	r1, r2, #3, #1
        hash_Index.bits.b4 = (mac_addr[5].bits.b4)^(mac_addr[4].bits.b2)^(mac_addr[3].bits.b0)^(mac_addr[3].bits.b6)^(mac_addr[2].bits.b4)^(mac_addr[1].bits.b2)^(mac_addr[0].bits.b0)^(mac_addr[0].bits.b6);
   116da:	f3c3 1200 	ubfx	r2, r3, #4, #1
   116de:	f3c7 0c80 	ubfx	ip, r7, #2, #1
   116e2:	ea82 020c 	eor.w	r2, r2, ip
   116e6:	f3c6 0c00 	ubfx	ip, r6, #0, #1
   116ea:	ea82 020c 	eor.w	r2, r2, ip
   116ee:	f3c6 1c80 	ubfx	ip, r6, #6, #1
   116f2:	ea82 020c 	eor.w	r2, r2, ip
   116f6:	f3c5 1c00 	ubfx	ip, r5, #4, #1
   116fa:	ea82 020c 	eor.w	r2, r2, ip
   116fe:	f3c4 0c80 	ubfx	ip, r4, #2, #1
   11702:	ea82 020c 	eor.w	r2, r2, ip
   11706:	f3c0 0c00 	ubfx	ip, r0, #0, #1
   1170a:	ea82 020c 	eor.w	r2, r2, ip
   1170e:	f3c0 1c80 	ubfx	ip, r0, #6, #1
   11712:	ea82 020c 	eor.w	r2, r2, ip
   11716:	f362 1104 	bfi	r1, r2, #4, #1
        hash_Index.bits.b5 = (mac_addr[5].bits.b5)^(mac_addr[4].bits.b3)^(mac_addr[3].bits.b1)^(mac_addr[3].bits.b7)^(mac_addr[2].bits.b5)^(mac_addr[1].bits.b3)^(mac_addr[0].bits.b1)^(mac_addr[0].bits.b7);
   1171a:	f3c3 1340 	ubfx	r3, r3, #5, #1
   1171e:	f3c7 07c0 	ubfx	r7, r7, #3, #1
   11722:	407b      	eors	r3, r7
   11724:	f3c6 0240 	ubfx	r2, r6, #1, #1
   11728:	ea83 13d6 	eor.w	r3, r3, r6, lsr #7
   1172c:	4053      	eors	r3, r2
   1172e:	f3c5 1540 	ubfx	r5, r5, #5, #1
   11732:	406b      	eors	r3, r5
   11734:	f3c4 04c0 	ubfx	r4, r4, #3, #1
   11738:	4063      	eors	r3, r4
   1173a:	f3c0 0240 	ubfx	r2, r0, #1, #1
   1173e:	ea83 13d0 	eor.w	r3, r3, r0, lsr #7
   11742:	4053      	eors	r3, r2
   11744:	f363 1145 	bfi	r1, r3, #5, #1
    hash_value = GMAC_REGS->GMAC_HRT;
   11748:	4b09      	ldr	r3, [pc, #36]	; (11770 <DRV_PIC32CGMAC_LibRxFilterHash_Calculate+0x1ac>)
   1174a:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
    hash_value = (hash_value << 32) | GMAC_REGS->GMAC_HRB;
   1174e:	f8d3 4080 	ldr.w	r4, [r3, #128]	; 0x80
        hash_value  |= (1 << (hash_Index.index));
   11752:	b2c9      	uxtb	r1, r1
   11754:	2301      	movs	r3, #1
   11756:	408b      	lsls	r3, r1
   11758:	17d9      	asrs	r1, r3, #31
   1175a:	4323      	orrs	r3, r4
   1175c:	4311      	orrs	r1, r2
    GMAC_REGS->GMAC_HRB = hash_value & 0xffffffff;
   1175e:	4a04      	ldr	r2, [pc, #16]	; (11770 <DRV_PIC32CGMAC_LibRxFilterHash_Calculate+0x1ac>)
   11760:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
    GMAC_REGS->GMAC_HRT = (hash_value >> 32) & 0xffffffff;    
   11764:	f8c2 1084 	str.w	r1, [r2, #132]	; 0x84
}
   11768:	2000      	movs	r0, #0
   1176a:	bcf0      	pop	{r4, r5, r6, r7}
   1176c:	4770      	bx	lr
   1176e:	bf00      	nop
   11770:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_ETHPHY_DefaultDetect%275:

00011774 <_DRV_ETHPHY_DefaultDetect>:
}


// default PHY detection procedure
static DRV_ETHPHY_RESULT _DRV_ETHPHY_DefaultDetect( const struct DRV_ETHPHY_OBJECT_BASE_TYPE* pBaseObj, DRV_HANDLE hClientObj)
{
   11774:	b570      	push	{r4, r5, r6, lr}
   11776:	b084      	sub	sp, #16
   11778:	4605      	mov	r5, r0
   1177a:	460c      	mov	r4, r1
            uint16_t high;
        };
    }vendorData;

    __BMCONbits_t bmcon;
    uint16_t    phyReg = 0;
   1177c:	2300      	movs	r3, #0
   1177e:	f8ad 300a 	strh.w	r3, [sp, #10]
    uint16_t    detectPhase = 0;
    int         phyAddress = 0;
   11782:	9301      	str	r3, [sp, #4]

    DRV_ETHPHY_RESULT res = pBaseObj->DRV_ETHPHY_VendorDataGet(hClientObj, &vendorData.w);
   11784:	6c83      	ldr	r3, [r0, #72]	; 0x48
   11786:	a903      	add	r1, sp, #12
   11788:	4620      	mov	r0, r4
   1178a:	4798      	blx	r3

    if(res < 0)
   1178c:	2800      	cmp	r0, #0
   1178e:	db20      	blt.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
    {   // some error occurred
        return res;
    }

    pBaseObj->DRV_ETHPHY_PhyAddressGet(hClientObj, DRV_ETHPHY_INF_IDX_ALL_EXTERNAL, &phyAddress);
   11790:	6aab      	ldr	r3, [r5, #40]	; 0x28
   11792:	aa01      	add	r2, sp, #4
   11794:	2100      	movs	r1, #0
   11796:	4620      	mov	r0, r4
   11798:	4798      	blx	r3

    _PhyDetectPhase(detectPhase);

    // try to detect the PHY and reset it

    switch (detectPhase)
   1179a:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   1179e:	2b07      	cmp	r3, #7
   117a0:	f200 80b5 	bhi.w	1190e <_DRV_ETHPHY_DefaultDetect+0x19a>
   117a4:	e8df f003 	tbb	[pc, r3]
   117a8:	48341704 	.word	0x48341704
   117ac:	9f8c765a 	.word	0x9f8c765a
    {
        case 0:
            // initiate a read of the BMCON register
            res = pBaseObj->DRV_ETHPHY_VendorSMIReadStart(hClientObj, PHY_REG_BMCON, phyAddress);
   117b0:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   117b2:	9a01      	ldr	r2, [sp, #4]
   117b4:	2100      	movs	r1, #0
   117b6:	4620      	mov	r0, r4
   117b8:	4798      	blx	r3
            if(res < 0)
   117ba:	2800      	cmp	r0, #0
   117bc:	db09      	blt.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            {   // some error
                return res;
            }
            else if(res == DRV_ETHPHY_RES_PENDING)
   117be:	2801      	cmp	r0, #1
   117c0:	d007      	beq.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            {   // retry
                return DRV_ETHPHY_RES_PENDING;
            }

            // advance to the next phase
            vendorData.low = ++detectPhase;
   117c2:	2601      	movs	r6, #1
   117c4:	f8ad 600c 	strh.w	r6, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
   117c8:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   117ca:	9903      	ldr	r1, [sp, #12]
   117cc:	4620      	mov	r0, r4
   117ce:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
   117d0:	4630      	mov	r0, r6

        default:
            // shouldn't happen
            return DRV_ETHPHY_RES_OPERATION_ERR;
    }
}
   117d2:	b004      	add	sp, #16
   117d4:	bd70      	pop	{r4, r5, r6, pc}
            res = pBaseObj->DRV_ETHPHY_VendorSMIReadResultGet(hClientObj, &phyReg);
   117d6:	6d6b      	ldr	r3, [r5, #84]	; 0x54
   117d8:	f10d 010a 	add.w	r1, sp, #10
   117dc:	4620      	mov	r0, r4
   117de:	4798      	blx	r3
            if(res < 0)
   117e0:	2800      	cmp	r0, #0
   117e2:	dbf6      	blt.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
   117e4:	2801      	cmp	r0, #1
   117e6:	d0f4      	beq.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            if(bmcon.RESET == 0)
   117e8:	f99d 300b 	ldrsb.w	r3, [sp, #11]
   117ec:	2b00      	cmp	r3, #0
   117ee:	da06      	bge.n	117fe <_DRV_ETHPHY_DefaultDetect+0x8a>
            vendorData.w = 0;
   117f0:	2100      	movs	r1, #0
   117f2:	9103      	str	r1, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
   117f4:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   117f6:	4620      	mov	r0, r4
   117f8:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
   117fa:	2001      	movs	r0, #1
   117fc:	e7e9      	b.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
                vendorData.low = ++detectPhase;
   117fe:	2302      	movs	r3, #2
   11800:	f8ad 300c 	strh.w	r3, [sp, #12]
                pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
   11804:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   11806:	9903      	ldr	r1, [sp, #12]
   11808:	4620      	mov	r0, r4
   1180a:	4798      	blx	r3
                return DRV_ETHPHY_RES_PENDING;
   1180c:	2001      	movs	r0, #1
   1180e:	e7e0      	b.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            res = pBaseObj->DRV_ETHPHY_VendorSMIWriteStart(hClientObj, PHY_REG_BMCON, bmcon.w, phyAddress);
   11810:	6dae      	ldr	r6, [r5, #88]	; 0x58
   11812:	9b01      	ldr	r3, [sp, #4]
   11814:	f44f 4282 	mov.w	r2, #16640	; 0x4100
   11818:	2100      	movs	r1, #0
   1181a:	4620      	mov	r0, r4
   1181c:	47b0      	blx	r6
            if(res < 0)
   1181e:	2800      	cmp	r0, #0
   11820:	dbd7      	blt.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
   11822:	2801      	cmp	r0, #1
   11824:	d0d5      	beq.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            vendorData.low = ++detectPhase;
   11826:	2303      	movs	r3, #3
   11828:	f8ad 300c 	strh.w	r3, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
   1182c:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   1182e:	9903      	ldr	r1, [sp, #12]
   11830:	4620      	mov	r0, r4
   11832:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
   11834:	2001      	movs	r0, #1
   11836:	e7cc      	b.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            res = pBaseObj->DRV_ETHPHY_VendorSMIReadStart(hClientObj, PHY_REG_BMCON, phyAddress);
   11838:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   1183a:	9a01      	ldr	r2, [sp, #4]
   1183c:	2100      	movs	r1, #0
   1183e:	4620      	mov	r0, r4
   11840:	4798      	blx	r3
            if(res < 0)
   11842:	2800      	cmp	r0, #0
   11844:	dbc5      	blt.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
   11846:	2801      	cmp	r0, #1
   11848:	d0c3      	beq.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            vendorData.low = ++detectPhase;
   1184a:	2304      	movs	r3, #4
   1184c:	f8ad 300c 	strh.w	r3, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
   11850:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   11852:	9903      	ldr	r1, [sp, #12]
   11854:	4620      	mov	r0, r4
   11856:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
   11858:	2001      	movs	r0, #1
   1185a:	e7ba      	b.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            res = pBaseObj->DRV_ETHPHY_VendorSMIReadResultGet(hClientObj, &phyReg);
   1185c:	6d6b      	ldr	r3, [r5, #84]	; 0x54
   1185e:	f10d 010a 	add.w	r1, sp, #10
   11862:	4620      	mov	r0, r4
   11864:	4798      	blx	r3
            if(res < 0)
   11866:	2800      	cmp	r0, #0
   11868:	dbb3      	blt.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
   1186a:	2801      	cmp	r0, #1
   1186c:	d0b1      	beq.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            bmcon.w = phyReg;
   1186e:	f8bd 200a 	ldrh.w	r2, [sp, #10]
            if( (bmcon.LOOPBACK == 0) || (bmcon.DUPLEX == 0) )
   11872:	f3c2 2307 	ubfx	r3, r2, #8, #8
   11876:	f003 0341 	and.w	r3, r3, #65	; 0x41
   1187a:	2b41      	cmp	r3, #65	; 0x41
   1187c:	d14a      	bne.n	11914 <_DRV_ETHPHY_DefaultDetect+0x1a0>
            vendorData.high = phyReg;
   1187e:	f8ad 200e 	strh.w	r2, [sp, #14]
            vendorData.low = ++detectPhase;
   11882:	2305      	movs	r3, #5
   11884:	f8ad 300c 	strh.w	r3, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
   11888:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   1188a:	9903      	ldr	r1, [sp, #12]
   1188c:	4620      	mov	r0, r4
   1188e:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
   11890:	2001      	movs	r0, #1
   11892:	e79e      	b.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            bmcon.w ^= _BMCON_LOOPBACK_MASK | _BMCON_DUPLEX_MASK;
   11894:	f8bd 200e 	ldrh.w	r2, [sp, #14]
            res = pBaseObj->DRV_ETHPHY_VendorSMIWriteStart(hClientObj, PHY_REG_BMCON, bmcon.w, phyAddress);
   11898:	6dae      	ldr	r6, [r5, #88]	; 0x58
   1189a:	9b01      	ldr	r3, [sp, #4]
   1189c:	f482 4282 	eor.w	r2, r2, #16640	; 0x4100
   118a0:	2100      	movs	r1, #0
   118a2:	4620      	mov	r0, r4
   118a4:	47b0      	blx	r6
            if(res < 0)
   118a6:	2800      	cmp	r0, #0
   118a8:	db93      	blt.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
   118aa:	2801      	cmp	r0, #1
   118ac:	d091      	beq.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            vendorData.low = ++detectPhase;
   118ae:	2306      	movs	r3, #6
   118b0:	f8ad 300c 	strh.w	r3, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
   118b4:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   118b6:	9903      	ldr	r1, [sp, #12]
   118b8:	4620      	mov	r0, r4
   118ba:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
   118bc:	2001      	movs	r0, #1
   118be:	e788      	b.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            res = pBaseObj->DRV_ETHPHY_VendorSMIReadStart(hClientObj, PHY_REG_BMCON, phyAddress);
   118c0:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   118c2:	9a01      	ldr	r2, [sp, #4]
   118c4:	2100      	movs	r1, #0
   118c6:	4620      	mov	r0, r4
   118c8:	4798      	blx	r3
            if(res < 0)
   118ca:	2800      	cmp	r0, #0
   118cc:	db81      	blt.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
   118ce:	2801      	cmp	r0, #1
   118d0:	f43f af7f 	beq.w	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            vendorData.low = ++detectPhase;
   118d4:	2307      	movs	r3, #7
   118d6:	f8ad 300c 	strh.w	r3, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
   118da:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   118dc:	9903      	ldr	r1, [sp, #12]
   118de:	4620      	mov	r0, r4
   118e0:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
   118e2:	2001      	movs	r0, #1
   118e4:	e775      	b.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            res = pBaseObj->DRV_ETHPHY_VendorSMIReadResultGet(hClientObj, &phyReg);
   118e6:	6d6b      	ldr	r3, [r5, #84]	; 0x54
   118e8:	f10d 010a 	add.w	r1, sp, #10
   118ec:	4620      	mov	r0, r4
   118ee:	4798      	blx	r3
            if(res < 0)
   118f0:	2800      	cmp	r0, #0
   118f2:	f6ff af6e 	blt.w	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
   118f6:	2801      	cmp	r0, #1
   118f8:	f43f af6b 	beq.w	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            if(bmcon.LOOPBACK || bmcon.DUPLEX)
   118fc:	f89d 300b 	ldrb.w	r3, [sp, #11]
   11900:	f013 0f41 	tst.w	r3, #65	; 0x41
   11904:	bf14      	ite	ne
   11906:	f04f 30ff 	movne.w	r0, #4294967295
   1190a:	2000      	moveq	r0, #0
   1190c:	e761      	b.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
            return DRV_ETHPHY_RES_OPERATION_ERR;
   1190e:	f06f 0008 	mvn.w	r0, #8
   11912:	e75e      	b.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>
                return DRV_ETHPHY_RES_DTCT_ERR; 
   11914:	f04f 30ff 	mov.w	r0, #4294967295
   11918:	e75b      	b.n	117d2 <_DRV_ETHPHY_DefaultDetect+0x5e>

Disassembly of section .text.CommandIperfSize%276:

0001191c <CommandIperfSize>:
    (*pCmdIO->pCmdApi->print)(cmdIoParam, "iperfi: OK, set the IP address to instance: %d\r\n", iperfIndex);

}

static void CommandIperfSize(SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char** argv)
{
   1191c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11920:	b087      	sub	sp, #28
    bool        setTx, setRx;
    uint32_t    txBuffSize, rxBuffSize;
    tIperfState* pIState;	
    int iperfIndex;

    const void* cmdIoParam = pCmdIO->cmdIoParam;
   11922:	6843      	ldr	r3, [r0, #4]
   11924:	9302      	str	r3, [sp, #8]


    if (argc < 3)
   11926:	2902      	cmp	r1, #2
   11928:	dd18      	ble.n	1195c <CommandIperfSize+0x40>
   1192a:	4682      	mov	sl, r0
   1192c:	4614      	mov	r4, r2
   1192e:	3903      	subs	r1, #3
   11930:	0849      	lsrs	r1, r1, #1
   11932:	3208      	adds	r2, #8
   11934:	eb02 07c1 	add.w	r7, r2, r1, lsl #3
        return;
    }

    setTx = setRx = 0;
    txBuffSize = rxBuffSize = 0;
    iperfIndex = 0;     // assume index 0 if not specified
   11938:	f04f 0800 	mov.w	r8, #0
    txBuffSize = rxBuffSize = 0;
   1193c:	f8cd 8014 	str.w	r8, [sp, #20]
   11940:	f8cd 800c 	str.w	r8, [sp, #12]
    setTx = setRx = 0;
   11944:	f8cd 8010 	str.w	r8, [sp, #16]
   11948:	46c3      	mov	fp, r8
    while(currIx + 1 < argc)
    { 
        char* param = argv[currIx];
        char* paramVal = argv[currIx + 1];

        if(strcmp(param, "-tx") == 0)
   1194a:	f8df 9140 	ldr.w	r9, [pc, #320]	; 11a8c <CommandIperfSize+0x170>
        {
            setTx = true;
            txBuffSize = atoi(paramVal);
        }
        else if(strcmp(param, "-rx") == 0)
   1194e:	f109 0338 	add.w	r3, r9, #56	; 0x38
   11952:	9300      	str	r3, [sp, #0]
        {
            setRx = true;
            rxBuffSize = atoi(paramVal);
        }
        else if((strcmp(param, "-i") == 0) || (strcmp(param, "--index") == 0))
   11954:	f109 033c 	add.w	r3, r9, #60	; 0x3c
   11958:	9301      	str	r3, [sp, #4]
   1195a:	e010      	b.n	1197e <CommandIperfSize+0x62>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: iperfs <-tx size> <-rx size> <-i index>\r\n");
   1195c:	6803      	ldr	r3, [r0, #0]
   1195e:	681b      	ldr	r3, [r3, #0]
   11960:	494a      	ldr	r1, [pc, #296]	; (11a8c <CommandIperfSize+0x170>)
   11962:	9802      	ldr	r0, [sp, #8]
   11964:	4798      	blx	r3
    {
        pIState->rxBuffSize = rxBuffSize;
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "iperfs: OK, set instance %d rx size to %d\r\n", iperfIndex, rxBuffSize);
    }

}
   11966:	b007      	add	sp, #28
   11968:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            txBuffSize = atoi(paramVal);
   1196c:	4630      	mov	r0, r6
   1196e:	f012 fd6b 	bl	24448 <atoi>
   11972:	9003      	str	r0, [sp, #12]
            setTx = true;
   11974:	f04f 0b01 	mov.w	fp, #1
        currIx += 2;
   11978:	3408      	adds	r4, #8
    while(currIx + 1 < argc)
   1197a:	42a7      	cmp	r7, r4
   1197c:	d02b      	beq.n	119d6 <CommandIperfSize+0xba>
        char* param = argv[currIx];
   1197e:	6865      	ldr	r5, [r4, #4]
        char* paramVal = argv[currIx + 1];
   11980:	68a6      	ldr	r6, [r4, #8]
        if(strcmp(param, "-tx") == 0)
   11982:	4943      	ldr	r1, [pc, #268]	; (11a90 <CommandIperfSize+0x174>)
   11984:	4628      	mov	r0, r5
   11986:	f012 f939 	bl	23bfc <strcmp>
   1198a:	2800      	cmp	r0, #0
   1198c:	d0ee      	beq.n	1196c <CommandIperfSize+0x50>
        else if(strcmp(param, "-rx") == 0)
   1198e:	9900      	ldr	r1, [sp, #0]
   11990:	4628      	mov	r0, r5
   11992:	f012 f933 	bl	23bfc <strcmp>
   11996:	b178      	cbz	r0, 119b8 <CommandIperfSize+0x9c>
        else if((strcmp(param, "-i") == 0) || (strcmp(param, "--index") == 0))
   11998:	9901      	ldr	r1, [sp, #4]
   1199a:	4628      	mov	r0, r5
   1199c:	f012 f92e 	bl	23bfc <strcmp>
   119a0:	b128      	cbz	r0, 119ae <CommandIperfSize+0x92>
   119a2:	f109 0140 	add.w	r1, r9, #64	; 0x40
   119a6:	4628      	mov	r0, r5
   119a8:	f012 f928 	bl	23bfc <strcmp>
   119ac:	b958      	cbnz	r0, 119c6 <CommandIperfSize+0xaa>
            iperfIndex = atoi(paramVal);
   119ae:	4630      	mov	r0, r6
   119b0:	f012 fd4a 	bl	24448 <atoi>
   119b4:	4680      	mov	r8, r0
   119b6:	e7df      	b.n	11978 <CommandIperfSize+0x5c>
            rxBuffSize = atoi(paramVal);
   119b8:	4630      	mov	r0, r6
   119ba:	f012 fd45 	bl	24448 <atoi>
   119be:	9005      	str	r0, [sp, #20]
            setRx = true;
   119c0:	2301      	movs	r3, #1
   119c2:	9304      	str	r3, [sp, #16]
   119c4:	e7d8      	b.n	11978 <CommandIperfSize+0x5c>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperfi: Unknown parameter\r\n");
   119c6:	f8da 3000 	ldr.w	r3, [sl]
   119ca:	681b      	ldr	r3, [r3, #0]
   119cc:	f109 0148 	add.w	r1, r9, #72	; 0x48
   119d0:	9802      	ldr	r0, [sp, #8]
   119d2:	4798      	blx	r3
   119d4:	e7d0      	b.n	11978 <CommandIperfSize+0x5c>
    if(iperfIndex < 0 || iperfIndex >= nIperfSessions)
   119d6:	f1b8 0f00 	cmp.w	r8, #0
   119da:	db1e      	blt.n	11a1a <CommandIperfSize+0xfe>
   119dc:	4b2d      	ldr	r3, [pc, #180]	; (11a94 <CommandIperfSize+0x178>)
   119de:	681b      	ldr	r3, [r3, #0]
   119e0:	4543      	cmp	r3, r8
   119e2:	dd1a      	ble.n	11a1a <CommandIperfSize+0xfe>
    if((setTx && (txBuffSize <= 0 || txBuffSize >= 65536)) || (setRx && (rxBuffSize <= 0 || rxBuffSize >= 65536)))
   119e4:	f1bb 0f00 	cmp.w	fp, #0
   119e8:	d028      	beq.n	11a3c <CommandIperfSize+0x120>
   119ea:	9b03      	ldr	r3, [sp, #12]
   119ec:	1e5a      	subs	r2, r3, #1
   119ee:	f64f 73fe 	movw	r3, #65534	; 0xfffe
   119f2:	429a      	cmp	r2, r3
   119f4:	d81b      	bhi.n	11a2e <CommandIperfSize+0x112>
   119f6:	9b04      	ldr	r3, [sp, #16]
   119f8:	bb1b      	cbnz	r3, 11a42 <CommandIperfSize+0x126>
        pIState->txBuffSize = txBuffSize;
   119fa:	4a27      	ldr	r2, [pc, #156]	; (11a98 <CommandIperfSize+0x17c>)
   119fc:	23d8      	movs	r3, #216	; 0xd8
   119fe:	fb03 2308 	mla	r3, r3, r8, r2
   11a02:	9a03      	ldr	r2, [sp, #12]
   11a04:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "iperfs: OK, set instance %d tx size to %d\r\n", iperfIndex, txBuffSize);
   11a08:	f8da 3000 	ldr.w	r3, [sl]
   11a0c:	685c      	ldr	r4, [r3, #4]
   11a0e:	4613      	mov	r3, r2
   11a10:	4642      	mov	r2, r8
   11a12:	4922      	ldr	r1, [pc, #136]	; (11a9c <CommandIperfSize+0x180>)
   11a14:	9802      	ldr	r0, [sp, #8]
   11a16:	47a0      	blx	r4
    if(setRx)
   11a18:	e7a5      	b.n	11966 <CommandIperfSize+0x4a>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: Invalid session number. Min: 0, Max: %d\r\n", nIperfSessions - 1);
   11a1a:	4b1e      	ldr	r3, [pc, #120]	; (11a94 <CommandIperfSize+0x178>)
   11a1c:	681a      	ldr	r2, [r3, #0]
   11a1e:	f8da 3000 	ldr.w	r3, [sl]
   11a22:	685b      	ldr	r3, [r3, #4]
   11a24:	3a01      	subs	r2, #1
   11a26:	491e      	ldr	r1, [pc, #120]	; (11aa0 <CommandIperfSize+0x184>)
   11a28:	9802      	ldr	r0, [sp, #8]
   11a2a:	4798      	blx	r3
        return;
   11a2c:	e79b      	b.n	11966 <CommandIperfSize+0x4a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperfs: 0 < size < 65536\r\n");
   11a2e:	f8da 3000 	ldr.w	r3, [sl]
   11a32:	681b      	ldr	r3, [r3, #0]
   11a34:	491b      	ldr	r1, [pc, #108]	; (11aa4 <CommandIperfSize+0x188>)
   11a36:	9802      	ldr	r0, [sp, #8]
   11a38:	4798      	blx	r3
        return;
   11a3a:	e794      	b.n	11966 <CommandIperfSize+0x4a>
    if((setTx && (txBuffSize <= 0 || txBuffSize >= 65536)) || (setRx && (rxBuffSize <= 0 || rxBuffSize >= 65536)))
   11a3c:	9b04      	ldr	r3, [sp, #16]
   11a3e:	2b00      	cmp	r3, #0
   11a40:	d091      	beq.n	11966 <CommandIperfSize+0x4a>
   11a42:	9b05      	ldr	r3, [sp, #20]
   11a44:	1e5a      	subs	r2, r3, #1
   11a46:	f64f 73fe 	movw	r3, #65534	; 0xfffe
   11a4a:	429a      	cmp	r2, r3
   11a4c:	d8ef      	bhi.n	11a2e <CommandIperfSize+0x112>
    pIState = gIperfState + iperfIndex;	
   11a4e:	4b12      	ldr	r3, [pc, #72]	; (11a98 <CommandIperfSize+0x17c>)
   11a50:	24d8      	movs	r4, #216	; 0xd8
   11a52:	fb04 3408 	mla	r4, r4, r8, r3
    if(setTx)
   11a56:	f1bb 0f00 	cmp.w	fp, #0
   11a5a:	d00a      	beq.n	11a72 <CommandIperfSize+0x156>
        pIState->txBuffSize = txBuffSize;
   11a5c:	9a03      	ldr	r2, [sp, #12]
   11a5e:	f8c4 20b8 	str.w	r2, [r4, #184]	; 0xb8
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "iperfs: OK, set instance %d tx size to %d\r\n", iperfIndex, txBuffSize);
   11a62:	f8da 3000 	ldr.w	r3, [sl]
   11a66:	685d      	ldr	r5, [r3, #4]
   11a68:	4613      	mov	r3, r2
   11a6a:	4642      	mov	r2, r8
   11a6c:	490b      	ldr	r1, [pc, #44]	; (11a9c <CommandIperfSize+0x180>)
   11a6e:	9802      	ldr	r0, [sp, #8]
   11a70:	47a8      	blx	r5
        pIState->rxBuffSize = rxBuffSize;
   11a72:	9a05      	ldr	r2, [sp, #20]
   11a74:	f8c4 20bc 	str.w	r2, [r4, #188]	; 0xbc
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "iperfs: OK, set instance %d rx size to %d\r\n", iperfIndex, rxBuffSize);
   11a78:	f8da 3000 	ldr.w	r3, [sl]
   11a7c:	685c      	ldr	r4, [r3, #4]
   11a7e:	4613      	mov	r3, r2
   11a80:	4642      	mov	r2, r8
   11a82:	4909      	ldr	r1, [pc, #36]	; (11aa8 <CommandIperfSize+0x18c>)
   11a84:	9802      	ldr	r0, [sp, #8]
   11a86:	47a0      	blx	r4
   11a88:	e76d      	b.n	11966 <CommandIperfSize+0x4a>
   11a8a:	bf00      	nop
   11a8c:	00005afc 	.word	0x00005afc
   11a90:	00005b30 	.word	0x00005b30
   11a94:	2000ee24 	.word	0x2000ee24
   11a98:	2000e380 	.word	0x2000e380
   11a9c:	00005bdc 	.word	0x00005bdc
   11aa0:	00005b60 	.word	0x00005b60
   11aa4:	00005b94 	.word	0x00005b94
   11aa8:	00005bb0 	.word	0x00005bb0

Disassembly of section .text.TCPIP_DHCP_Initialize%277:

00011aac <TCPIP_DHCP_Initialize>:
{
   11aac:	b5f0      	push	{r4, r5, r6, r7, lr}
   11aae:	b083      	sub	sp, #12
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_UP)
   11ab0:	7f03      	ldrb	r3, [r0, #28]
   11ab2:	2b03      	cmp	r3, #3
   11ab4:	d062      	beq.n	11b7c <TCPIP_DHCP_Initialize+0xd0>
   11ab6:	4604      	mov	r4, r0
   11ab8:	460d      	mov	r5, r1
    if(dhcpInitCount == 0)
   11aba:	4b55      	ldr	r3, [pc, #340]	; (11c10 <TCPIP_DHCP_Initialize+0x164>)
   11abc:	681b      	ldr	r3, [r3, #0]
   11abe:	2b00      	cmp	r3, #0
   11ac0:	d13b      	bne.n	11b3a <TCPIP_DHCP_Initialize+0x8e>
        if(pDhcpConfig == 0)
   11ac2:	2900      	cmp	r1, #0
   11ac4:	f000 809f 	beq.w	11c06 <TCPIP_DHCP_Initialize+0x15a>
        dhcpMemH = stackCtrl->memH;
   11ac8:	68c0      	ldr	r0, [r0, #12]
   11aca:	4b52      	ldr	r3, [pc, #328]	; (11c14 <TCPIP_DHCP_Initialize+0x168>)
   11acc:	6018      	str	r0, [r3, #0]
        dhcpClientSocket = INVALID_UDP_SOCKET;
   11ace:	4b52      	ldr	r3, [pc, #328]	; (11c18 <TCPIP_DHCP_Initialize+0x16c>)
   11ad0:	f64f 72ff 	movw	r2, #65535	; 0xffff
   11ad4:	801a      	strh	r2, [r3, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Calloc)(h, nElems, elemSize);
   11ad6:	6883      	ldr	r3, [r0, #8]
   11ad8:	225c      	movs	r2, #92	; 0x5c
   11ada:	6821      	ldr	r1, [r4, #0]
   11adc:	4798      	blx	r3
        DHCPClients = (DHCP_CLIENT_VARS*)TCPIP_HEAP_Calloc(dhcpMemH,  stackCtrl->nIfs, sizeof(DHCP_CLIENT_VARS));
   11ade:	4b4f      	ldr	r3, [pc, #316]	; (11c1c <TCPIP_DHCP_Initialize+0x170>)
   11ae0:	6018      	str	r0, [r3, #0]
        if(DHCPClients == 0)
   11ae2:	2800      	cmp	r0, #0
   11ae4:	f000 8091 	beq.w	11c0a <TCPIP_DHCP_Initialize+0x15e>
        dhcpSignalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_DHCP_Task, TCPIP_DHCP_TASK_TICK_RATE);
   11ae8:	2205      	movs	r2, #5
   11aea:	494d      	ldr	r1, [pc, #308]	; (11c20 <TCPIP_DHCP_Initialize+0x174>)
   11aec:	200c      	movs	r0, #12
   11aee:	f00d f957 	bl	1eda0 <_TCPIPStackSignalHandlerRegister>
   11af2:	4b4c      	ldr	r3, [pc, #304]	; (11c24 <TCPIP_DHCP_Initialize+0x178>)
   11af4:	6018      	str	r0, [r3, #0]
        iniRes = TCPIP_Notification_Initialize(&dhcpRegisteredUsers);
   11af6:	484c      	ldr	r0, [pc, #304]	; (11c28 <TCPIP_DHCP_Initialize+0x17c>)
   11af8:	f012 fc6a 	bl	243d0 <TCPIP_Notification_Initialize>
   11afc:	4607      	mov	r7, r0
        dhcpClientPort = pDhcpConfig->dhcpCliPort;
   11afe:	68aa      	ldr	r2, [r5, #8]
   11b00:	4b4a      	ldr	r3, [pc, #296]	; (11c2c <TCPIP_DHCP_Initialize+0x180>)
   11b02:	801a      	strh	r2, [r3, #0]
        dhcpServerPort = pDhcpConfig->dhcpSrvPort;
   11b04:	89a9      	ldrh	r1, [r5, #12]
   11b06:	4b4a      	ldr	r3, [pc, #296]	; (11c30 <TCPIP_DHCP_Initialize+0x184>)
   11b08:	8019      	strh	r1, [r3, #0]
    UDP_SOCKET dhcpSkt = TCPIP_UDP_OpenClientSkt(IP_ADDRESS_TYPE_IPV4, dhcpServerPort, 0, UDP_OPEN_CLIENT | UDP_OPEN_CONFIG_SERVICE);
   11b0a:	f44f 7381 	mov.w	r3, #258	; 0x102
   11b0e:	2200      	movs	r2, #0
   11b10:	2001      	movs	r0, #1
   11b12:	f00e fb4b 	bl	201ac <TCPIP_UDP_OpenClientSkt>
   11b16:	4606      	mov	r6, r0
    while(dhcpSkt != INVALID_UDP_SOCKET)
   11b18:	f1b0 3fff 	cmp.w	r0, #4294967295
   11b1c:	d13b      	bne.n	11b96 <TCPIP_DHCP_Initialize+0xea>
        dhcpClientSocket = _DHCPOpenSocket();
   11b1e:	4b3e      	ldr	r3, [pc, #248]	; (11c18 <TCPIP_DHCP_Initialize+0x16c>)
   11b20:	801e      	strh	r6, [r3, #0]
        if(dhcpSignalHandle == 0 || iniRes == 0 || dhcpClientSocket == INVALID_UDP_SOCKET)
   11b22:	4b40      	ldr	r3, [pc, #256]	; (11c24 <TCPIP_DHCP_Initialize+0x178>)
   11b24:	681b      	ldr	r3, [r3, #0]
   11b26:	2b00      	cmp	r3, #0
   11b28:	d065      	beq.n	11bf6 <TCPIP_DHCP_Initialize+0x14a>
   11b2a:	2f00      	cmp	r7, #0
   11b2c:	d063      	beq.n	11bf6 <TCPIP_DHCP_Initialize+0x14a>
   11b2e:	f1b6 3fff 	cmp.w	r6, #4294967295
   11b32:	d060      	beq.n	11bf6 <TCPIP_DHCP_Initialize+0x14a>
        dhcpInterfaces = stackCtrl->nIfs;
   11b34:	6822      	ldr	r2, [r4, #0]
   11b36:	4b3f      	ldr	r3, [pc, #252]	; (11c34 <TCPIP_DHCP_Initialize+0x188>)
   11b38:	601a      	str	r2, [r3, #0]
    pClient = DHCPClients + stackCtrl->netIx;
   11b3a:	69a3      	ldr	r3, [r4, #24]
   11b3c:	4a37      	ldr	r2, [pc, #220]	; (11c1c <TCPIP_DHCP_Initialize+0x170>)
   11b3e:	6812      	ldr	r2, [r2, #0]
   11b40:	215c      	movs	r1, #92	; 0x5c
   11b42:	fb01 2303 	mla	r3, r1, r3, r2
    pClient->flags.val = 0;
   11b46:	2200      	movs	r2, #0
   11b48:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
    pClient->tOpFailTmo = (pDhcpConfig->dhcpTmo < 1) ? TCPIP_DHCP_INIT_FAIL_TMO : (uint16_t)pDhcpConfig->dhcpTmo;
   11b4c:	686a      	ldr	r2, [r5, #4]
   11b4e:	2a00      	cmp	r2, #0
   11b50:	bfd8      	it	le
   11b52:	220a      	movle	r2, #10
   11b54:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
    pClient->dhcpTmoBase = (TCPIP_DHCP_EXP_BACKOFF_BASE < TCPIP_DHCP_EXP_BACKOFF_FUZZ + 1) ? TCPIP_DHCP_EXP_BACKOFF_FUZZ + 1 : TCPIP_DHCP_EXP_BACKOFF_BASE;
   11b58:	2202      	movs	r2, #2
   11b5a:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    pClient->tLeaseCheck = TCPIP_DHCP_LEASE_CHECK_TMO;
   11b5e:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
    if(stackCtrl->pNetIf->Flags.bIsDHCPEnabled != 0)
   11b62:	6960      	ldr	r0, [r4, #20]
   11b64:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   11b68:	f013 0f01 	tst.w	r3, #1
   11b6c:	d147      	bne.n	11bfe <TCPIP_DHCP_Initialize+0x152>
    dhcpInitCount++;
   11b6e:	4a28      	ldr	r2, [pc, #160]	; (11c10 <TCPIP_DHCP_Initialize+0x164>)
   11b70:	6813      	ldr	r3, [r2, #0]
   11b72:	3301      	adds	r3, #1
   11b74:	6013      	str	r3, [r2, #0]
    return true;
   11b76:	2001      	movs	r0, #1
}
   11b78:	b003      	add	sp, #12
   11b7a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if(stackCtrl->pNetIf->Flags.bIsDHCPEnabled != 0)
   11b7c:	6940      	ldr	r0, [r0, #20]
   11b7e:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   11b82:	f013 0f01 	tst.w	r3, #1
   11b86:	d101      	bne.n	11b8c <TCPIP_DHCP_Initialize+0xe0>
        return true;
   11b88:	2001      	movs	r0, #1
   11b8a:	e7f5      	b.n	11b78 <TCPIP_DHCP_Initialize+0xcc>
            _DHCPEnable(stackCtrl->pNetIf, TCPIP_DHCP_OPER_INIT);
   11b8c:	2101      	movs	r1, #1
   11b8e:	f008 f833 	bl	19bf8 <_DHCPEnable>
        return true;
   11b92:	2001      	movs	r0, #1
   11b94:	e7f0      	b.n	11b78 <TCPIP_DHCP_Initialize+0xcc>
        TCPIP_UDP_OptionsGet(dhcpSkt, UDP_OPTION_TX_BUFF, (void*)&txBuffSize);
   11b96:	f10d 0206 	add.w	r2, sp, #6
   11b9a:	2105      	movs	r1, #5
   11b9c:	f002 fadc 	bl	14158 <TCPIP_UDP_OptionsGet>
        if(txBuffSize < TCPIP_DHCP_MIN_UDP_TX_BUFFER_SIZE)
   11ba0:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   11ba4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   11ba8:	d208      	bcs.n	11bbc <TCPIP_DHCP_Initialize+0x110>
            txBuffSize = TCPIP_DHCP_MIN_UDP_TX_BUFFER_SIZE;
   11baa:	f44f 7200 	mov.w	r2, #512	; 0x200
   11bae:	f8ad 2006 	strh.w	r2, [sp, #6]
            if(!TCPIP_UDP_OptionsSet(dhcpSkt, UDP_OPTION_TX_BUFF, (void*)(uintptr_t)txBuffSize))
   11bb2:	2105      	movs	r1, #5
   11bb4:	4630      	mov	r0, r6
   11bb6:	f7fe f9eb 	bl	ff90 <TCPIP_UDP_OptionsSet>
   11bba:	b138      	cbz	r0, 11bcc <TCPIP_DHCP_Initialize+0x120>
        if(!TCPIP_UDP_Bind(dhcpSkt, IP_ADDRESS_TYPE_IPV4, dhcpClientPort,  0))
   11bbc:	2300      	movs	r3, #0
   11bbe:	4a1b      	ldr	r2, [pc, #108]	; (11c2c <TCPIP_DHCP_Initialize+0x180>)
   11bc0:	8812      	ldrh	r2, [r2, #0]
   11bc2:	2101      	movs	r1, #1
   11bc4:	4630      	mov	r0, r6
   11bc6:	f002 fbef 	bl	143a8 <TCPIP_UDP_Bind>
   11bca:	b928      	cbnz	r0, 11bd8 <TCPIP_DHCP_Initialize+0x12c>
        TCPIP_UDP_Close(dhcpSkt);
   11bcc:	4630      	mov	r0, r6
   11bce:	f00f fbe5 	bl	2139c <TCPIP_UDP_Close>
        dhcpSkt = INVALID_UDP_SOCKET;
   11bd2:	f04f 36ff 	mov.w	r6, #4294967295
   11bd6:	e7a2      	b.n	11b1e <TCPIP_DHCP_Initialize+0x72>
        TCPIP_UDP_OptionsSet(dhcpSkt, UDP_OPTION_STRICT_ADDRESS, 0);
   11bd8:	2200      	movs	r2, #0
   11bda:	2102      	movs	r1, #2
   11bdc:	4630      	mov	r0, r6
   11bde:	f7fe f9d7 	bl	ff90 <TCPIP_UDP_OptionsSet>
        sigHandle = TCPIP_UDP_SignalHandlerRegister(dhcpSkt, TCPIP_UDP_SIGNAL_RX_DATA, _DHCPSocketRxSignalHandler, 0);
   11be2:	2300      	movs	r3, #0
   11be4:	4a14      	ldr	r2, [pc, #80]	; (11c38 <TCPIP_DHCP_Initialize+0x18c>)
   11be6:	f44f 7180 	mov.w	r1, #256	; 0x100
   11bea:	4630      	mov	r0, r6
   11bec:	f00d fb35 	bl	1f25a <TCPIP_UDP_SignalHandlerRegister>
        if(sigHandle == 0)
   11bf0:	2800      	cmp	r0, #0
   11bf2:	d194      	bne.n	11b1e <TCPIP_DHCP_Initialize+0x72>
   11bf4:	e7ea      	b.n	11bcc <TCPIP_DHCP_Initialize+0x120>
            _DHCPCleanup();
   11bf6:	f008 faa1 	bl	1a13c <_DHCPCleanup>
            return false;
   11bfa:	2000      	movs	r0, #0
   11bfc:	e7bc      	b.n	11b78 <TCPIP_DHCP_Initialize+0xcc>
        _DHCPEnable(stackCtrl->pNetIf, TCPIP_DHCP_OPER_INIT);
   11bfe:	2101      	movs	r1, #1
   11c00:	f007 fffa 	bl	19bf8 <_DHCPEnable>
   11c04:	e7b3      	b.n	11b6e <TCPIP_DHCP_Initialize+0xc2>
            return false;
   11c06:	2000      	movs	r0, #0
   11c08:	e7b6      	b.n	11b78 <TCPIP_DHCP_Initialize+0xcc>
            return false;
   11c0a:	2000      	movs	r0, #0
   11c0c:	e7b4      	b.n	11b78 <TCPIP_DHCP_Initialize+0xcc>
   11c0e:	bf00      	nop
   11c10:	2000ee40 	.word	0x2000ee40
   11c14:	2000ee48 	.word	0x2000ee48
   11c18:	2000ef7e 	.word	0x2000ef7e
   11c1c:	2000ee3c 	.word	0x2000ee3c
   11c20:	00008f35 	.word	0x00008f35
   11c24:	2000ee50 	.word	0x2000ee50
   11c28:	2000ec64 	.word	0x2000ec64
   11c2c:	2000ef7c 	.word	0x2000ef7c
   11c30:	2000ef80 	.word	0x2000ef80
   11c34:	2000ee44 	.word	0x2000ee44
   11c38:	0002397b 	.word	0x0002397b

Disassembly of section .text._Command_MacInfo%278:

00011c3c <_Command_MacInfo>:
{
   11c3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11c40:	f6ad 0d3c 	subw	sp, sp, #2108	; 0x83c
   11c44:	4606      	mov	r6, r0
   11c46:	9102      	str	r1, [sp, #8]
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   11c48:	f8d0 a004 	ldr.w	sl, [r0, #4]
    if (argc != 1) {
   11c4c:	2901      	cmp	r1, #1
   11c4e:	d010      	beq.n	11c72 <_Command_MacInfo+0x36>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: macinfo \r\n");
   11c50:	4c5a      	ldr	r4, [pc, #360]	; (11dbc <_Command_MacInfo+0x180>)
   11c52:	6803      	ldr	r3, [r0, #0]
   11c54:	681b      	ldr	r3, [r3, #0]
   11c56:	4621      	mov	r1, r4
   11c58:	4650      	mov	r0, sl
   11c5a:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: macinfo \r\n");
   11c5c:	6833      	ldr	r3, [r6, #0]
   11c5e:	681b      	ldr	r3, [r3, #0]
   11c60:	f104 0114 	add.w	r1, r4, #20
   11c64:	4650      	mov	r0, sl
   11c66:	4798      	blx	r3
        return false;
   11c68:	2000      	movs	r0, #0
}
   11c6a:	f60d 0d3c 	addw	sp, sp, #2108	; 0x83c
   11c6e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    netNo = TCPIP_STACK_NumberOfNetworksGet();
   11c72:	f012 fae1 	bl	24238 <TCPIP_STACK_NumberOfNetworksGet>
    for(netIx = 0; netIx < netNo; netIx++)
   11c76:	f1b0 0b00 	subs.w	fp, r0, #0
   11c7a:	f340 809c 	ble.w	11db6 <_Command_MacInfo+0x17a>
   11c7e:	2700      	movs	r7, #0
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Interface: %s Driver Statistics\r\n", netName);
   11c80:	f8df 9138 	ldr.w	r9, [pc, #312]	; 11dbc <_Command_MacInfo+0x180>
   11c84:	f109 0324 	add.w	r3, r9, #36	; 0x24
   11c88:	9303      	str	r3, [sp, #12]
   11c8a:	e01d      	b.n	11cc8 <_Command_MacInfo+0x8c>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "\tnot supported\r\n");
   11c8c:	6833      	ldr	r3, [r6, #0]
   11c8e:	681b      	ldr	r3, [r3, #0]
   11c90:	f509 71b2 	add.w	r1, r9, #356	; 0x164
   11c94:	4650      	mov	r0, sl
   11c96:	4798      	blx	r3
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Interface: %s Hardware Register Status\r\n", netName);
   11c98:	6833      	ldr	r3, [r6, #0]
   11c9a:	685b      	ldr	r3, [r3, #4]
   11c9c:	462a      	mov	r2, r5
   11c9e:	f509 71bc 	add.w	r1, r9, #376	; 0x178
   11ca2:	4650      	mov	r0, sl
   11ca4:	4798      	blx	r3
        if(TCPIP_STACK_NetMACRegisterStatisticsGet(netH, regEntries, sizeof(regEntries)/sizeof(*regEntries), &hwEntries))
   11ca6:	ab0f      	add	r3, sp, #60	; 0x3c
   11ca8:	2232      	movs	r2, #50	; 0x32
   11caa:	a910      	add	r1, sp, #64	; 0x40
   11cac:	4620      	mov	r0, r4
   11cae:	f010 fa11 	bl	220d4 <TCPIP_STACK_NetMACRegisterStatisticsGet>
   11cb2:	2800      	cmp	r0, #0
   11cb4:	d15d      	bne.n	11d72 <_Command_MacInfo+0x136>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "\tnot supported\r\n");
   11cb6:	6833      	ldr	r3, [r6, #0]
   11cb8:	681b      	ldr	r3, [r3, #0]
   11cba:	f509 71b2 	add.w	r1, r9, #356	; 0x164
   11cbe:	4650      	mov	r0, sl
   11cc0:	4798      	blx	r3
    for(netIx = 0; netIx < netNo; netIx++)
   11cc2:	3701      	adds	r7, #1
   11cc4:	45bb      	cmp	fp, r7
   11cc6:	d074      	beq.n	11db2 <_Command_MacInfo+0x176>
        netH = TCPIP_STACK_IndexToNet(netIx);
   11cc8:	4638      	mov	r0, r7
   11cca:	f010 f9db 	bl	22084 <TCPIP_STACK_IndexToNet>
   11cce:	4604      	mov	r4, r0
        if(TCPIP_STACK_NetGetType(netH) != TCPIP_NETWORK_TYPE_PRIMARY)
   11cd0:	f012 fb7a 	bl	243c8 <TCPIP_STACK_NetGetType>
   11cd4:	2801      	cmp	r0, #1
   11cd6:	d1f4      	bne.n	11cc2 <_Command_MacInfo+0x86>
        netName = TCPIP_STACK_NetNameGet(netH);
   11cd8:	4620      	mov	r0, r4
   11cda:	f012 fb36 	bl	2434a <TCPIP_STACK_NetNameGet>
   11cde:	4605      	mov	r5, r0
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Interface: %s Driver Statistics\r\n", netName);
   11ce0:	6833      	ldr	r3, [r6, #0]
   11ce2:	685b      	ldr	r3, [r3, #4]
   11ce4:	4602      	mov	r2, r0
   11ce6:	9903      	ldr	r1, [sp, #12]
   11ce8:	4650      	mov	r0, sl
   11cea:	4798      	blx	r3
        if(TCPIP_STACK_NetMACStatisticsGet(netH, &rxStatistics, &txStatistics))
   11cec:	f50d 6201 	add.w	r2, sp, #2064	; 0x810
   11cf0:	f50d 6102 	add.w	r1, sp, #2080	; 0x820
   11cf4:	4620      	mov	r0, r4
   11cf6:	f010 f9d9 	bl	220ac <TCPIP_STACK_NetMACStatisticsGet>
   11cfa:	2800      	cmp	r0, #0
   11cfc:	d0c6      	beq.n	11c8c <_Command_MacInfo+0x50>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\n Receive Statistics\r\n");
   11cfe:	6833      	ldr	r3, [r6, #0]
   11d00:	685b      	ldr	r3, [r3, #4]
   11d02:	f109 0148 	add.w	r1, r9, #72	; 0x48
   11d06:	4650      	mov	r0, sl
   11d08:	4798      	blx	r3
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "\t nRxOkPackets: %d\r\n\t nRxPendBuffers: %d\r\n\t nRxSchedBuffers: %d\r\n",
   11d0a:	6833      	ldr	r3, [r6, #0]
   11d0c:	f8dd 2828 	ldr.w	r2, [sp, #2088]	; 0x828
   11d10:	9200      	str	r2, [sp, #0]
   11d12:	f8d3 8004 	ldr.w	r8, [r3, #4]
   11d16:	f8dd 3824 	ldr.w	r3, [sp, #2084]	; 0x824
   11d1a:	f8dd 2820 	ldr.w	r2, [sp, #2080]	; 0x820
   11d1e:	f109 0160 	add.w	r1, r9, #96	; 0x60
   11d22:	4650      	mov	r0, sl
   11d24:	47c0      	blx	r8
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "\t nRxErrorPackets: %d\r\n\t nRxFragmentErrors: %d\r\n\t nRxBuffNotAvailable: %d\r\n", rxStatistics.nRxErrorPackets, rxStatistics.nRxFragmentErrors,rxStatistics.nRxBuffNotAvailable);
   11d26:	6833      	ldr	r3, [r6, #0]
   11d28:	f8dd 2834 	ldr.w	r2, [sp, #2100]	; 0x834
   11d2c:	9200      	str	r2, [sp, #0]
   11d2e:	f8d3 8004 	ldr.w	r8, [r3, #4]
   11d32:	f8dd 3830 	ldr.w	r3, [sp, #2096]	; 0x830
   11d36:	f8dd 282c 	ldr.w	r2, [sp, #2092]	; 0x82c
   11d3a:	f109 01a4 	add.w	r1, r9, #164	; 0xa4
   11d3e:	4650      	mov	r0, sl
   11d40:	47c0      	blx	r8
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\n Transmit Statistics\r\n");
   11d42:	6833      	ldr	r3, [r6, #0]
   11d44:	685b      	ldr	r3, [r3, #4]
   11d46:	f109 01f0 	add.w	r1, r9, #240	; 0xf0
   11d4a:	4650      	mov	r0, sl
   11d4c:	4798      	blx	r3
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "\t nTxOkPackets: %d\r\n\t nTxPendBuffers: %d\r\n\t nTxErrorPackets: %d\r\n\t nTxQueueFull: %d\r\n\r\n",
   11d4e:	6833      	ldr	r3, [r6, #0]
   11d50:	f8dd 281c 	ldr.w	r2, [sp, #2076]	; 0x81c
   11d54:	9201      	str	r2, [sp, #4]
   11d56:	f8dd 2818 	ldr.w	r2, [sp, #2072]	; 0x818
   11d5a:	9200      	str	r2, [sp, #0]
   11d5c:	f8d3 8004 	ldr.w	r8, [r3, #4]
   11d60:	f8dd 3814 	ldr.w	r3, [sp, #2068]	; 0x814
   11d64:	f8dd 2810 	ldr.w	r2, [sp, #2064]	; 0x810
   11d68:	f509 7186 	add.w	r1, r9, #268	; 0x10c
   11d6c:	4650      	mov	r0, sl
   11d6e:	47c0      	blx	r8
   11d70:	e792      	b.n	11c98 <_Command_MacInfo+0x5c>
            entryName[sizeof(entryName) - 1] = 0;
   11d72:	2300      	movs	r3, #0
   11d74:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
            for(jx = 0, pRegEntry = regEntries; jx < hwEntries && jx < sizeof(regEntries)/sizeof(*regEntries); jx++, pRegEntry++)
   11d78:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   11d7a:	2b00      	cmp	r3, #0
   11d7c:	dda1      	ble.n	11cc2 <_Command_MacInfo+0x86>
   11d7e:	2500      	movs	r5, #0
   11d80:	ac10      	add	r4, sp, #64	; 0x40
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "\t %s: 0x%x\r\n", entryName, pRegEntry->registerValue);
   11d82:	46b8      	mov	r8, r7
                strncpy(entryName, pRegEntry->registerName, sizeof(entryName) - 1);
   11d84:	2224      	movs	r2, #36	; 0x24
   11d86:	4621      	mov	r1, r4
   11d88:	a805      	add	r0, sp, #20
   11d8a:	f010 fb91 	bl	224b0 <strncpy>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "\t %s: 0x%x\r\n", entryName, pRegEntry->registerValue);
   11d8e:	6833      	ldr	r3, [r6, #0]
   11d90:	685f      	ldr	r7, [r3, #4]
   11d92:	6a63      	ldr	r3, [r4, #36]	; 0x24
   11d94:	aa05      	add	r2, sp, #20
   11d96:	490a      	ldr	r1, [pc, #40]	; (11dc0 <_Command_MacInfo+0x184>)
   11d98:	4650      	mov	r0, sl
   11d9a:	47b8      	blx	r7
            for(jx = 0, pRegEntry = regEntries; jx < hwEntries && jx < sizeof(regEntries)/sizeof(*regEntries); jx++, pRegEntry++)
   11d9c:	3501      	adds	r5, #1
   11d9e:	3428      	adds	r4, #40	; 0x28
   11da0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   11da2:	42ab      	cmp	r3, r5
   11da4:	dd03      	ble.n	11dae <_Command_MacInfo+0x172>
   11da6:	2d32      	cmp	r5, #50	; 0x32
   11da8:	d1ec      	bne.n	11d84 <_Command_MacInfo+0x148>
   11daa:	4647      	mov	r7, r8
   11dac:	e789      	b.n	11cc2 <_Command_MacInfo+0x86>
   11dae:	4647      	mov	r7, r8
   11db0:	e787      	b.n	11cc2 <_Command_MacInfo+0x86>
    return true;
   11db2:	9802      	ldr	r0, [sp, #8]
   11db4:	e759      	b.n	11c6a <_Command_MacInfo+0x2e>
   11db6:	9802      	ldr	r0, [sp, #8]
   11db8:	e757      	b.n	11c6a <_Command_MacInfo+0x2e>
   11dba:	bf00      	nop
   11dbc:	0000028c 	.word	0x0000028c
   11dc0:	00000430 	.word	0x00000430

Disassembly of section .text.wc_Sha256Final%279:

00011dc4 <wc_Sha256Final>:

        return 0;
    }

    int wc_Sha256Final(wc_Sha256* sha256, byte* hash)
    {
   11dc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        int ret;

        if (sha256 == NULL || hash == NULL) {
   11dc6:	2800      	cmp	r0, #0
   11dc8:	f000 80ab 	beq.w	11f22 <wc_Sha256Final+0x15e>
   11dcc:	4604      	mov	r4, r0
   11dce:	2900      	cmp	r1, #0
   11dd0:	f000 80aa 	beq.w	11f28 <wc_Sha256Final+0x164>
   11dd4:	460d      	mov	r5, r1
            return BAD_FUNC_ARG;
        }

    #ifdef WOLF_CRYPTO_CB
        if (sha256->devId != INVALID_DEVID) {
   11dd6:	6f03      	ldr	r3, [r0, #112]	; 0x70
   11dd8:	f113 0f02 	cmn.w	r3, #2
   11ddc:	d00a      	beq.n	11df4 <wc_Sha256Final+0x30>
            ret = wc_CryptoCb_Sha256Hash(sha256, NULL, 0, hash);
   11dde:	460b      	mov	r3, r1
   11de0:	2200      	movs	r2, #0
   11de2:	4611      	mov	r1, r2
   11de4:	f00a fcfc 	bl	1c7e0 <wc_CryptoCb_Sha256Hash>
   11de8:	4607      	mov	r7, r0
            if (ret != CRYPTOCB_UNAVAILABLE)
   11dea:	f46f 7387 	mvn.w	r3, #270	; 0x10e
   11dee:	4298      	cmp	r0, r3
   11df0:	f040 8095 	bne.w	11f1e <wc_Sha256Final+0x15a>
        local = (byte*)sha256->buffer;
   11df4:	f104 0620 	add.w	r6, r4, #32
        local[sha256->buffLen++] = 0x80; /* add 1 */
   11df8:	6e23      	ldr	r3, [r4, #96]	; 0x60
   11dfa:	1c5a      	adds	r2, r3, #1
   11dfc:	6622      	str	r2, [r4, #96]	; 0x60
   11dfe:	2280      	movs	r2, #128	; 0x80
   11e00:	54f2      	strb	r2, [r6, r3]
        if (sha256->buffLen > WC_SHA256_PAD_SIZE) {
   11e02:	6e20      	ldr	r0, [r4, #96]	; 0x60
   11e04:	2838      	cmp	r0, #56	; 0x38
   11e06:	d922      	bls.n	11e4e <wc_Sha256Final+0x8a>
            XMEMSET(&local[sha256->buffLen], 0,
   11e08:	f1c0 0240 	rsb	r2, r0, #64	; 0x40
   11e0c:	2100      	movs	r1, #0
   11e0e:	4430      	add	r0, r6
   11e10:	f012 f846 	bl	23ea0 <memset>
            sha256->buffLen += WC_SHA256_BLOCK_SIZE - sha256->buffLen;
   11e14:	2340      	movs	r3, #64	; 0x40
   11e16:	6623      	str	r3, [r4, #96]	; 0x60
    for (i = 0; i < count; i++)
   11e18:	f104 011c 	add.w	r1, r4, #28
   11e1c:	f104 005c 	add.w	r0, r4, #92	; 0x5c
        out[i] = ByteReverseWord32(in[i]);
   11e20:	f851 2f04 	ldr.w	r2, [r1, #4]!
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
   11e24:	0a13      	lsrs	r3, r2, #8
   11e26:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
   11e2a:	0212      	lsls	r2, r2, #8
   11e2c:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
   11e30:	4313      	orrs	r3, r2
        return (x << y) | (x >> (sizeof(y) * 8 - y));
   11e32:	ea4f 4333 	mov.w	r3, r3, ror #16
        out[i] = ByteReverseWord32(in[i]);
   11e36:	600b      	str	r3, [r1, #0]
    for (i = 0; i < count; i++)
   11e38:	4281      	cmp	r1, r0
   11e3a:	d1f1      	bne.n	11e20 <wc_Sha256Final+0x5c>
            ret = XTRANSFORM(sha256, (const byte*)local);
   11e3c:	4631      	mov	r1, r6
   11e3e:	4620      	mov	r0, r4
   11e40:	f7fa fba8 	bl	c594 <Transform_Sha256>
            if (ret != 0)
   11e44:	4607      	mov	r7, r0
   11e46:	2800      	cmp	r0, #0
   11e48:	d169      	bne.n	11f1e <wc_Sha256Final+0x15a>
            sha256->buffLen = 0;
   11e4a:	2300      	movs	r3, #0
   11e4c:	6623      	str	r3, [r4, #96]	; 0x60
        XMEMSET(&local[sha256->buffLen], 0,
   11e4e:	6e20      	ldr	r0, [r4, #96]	; 0x60
   11e50:	f1c0 0238 	rsb	r2, r0, #56	; 0x38
   11e54:	2100      	movs	r1, #0
   11e56:	4430      	add	r0, r6
   11e58:	f012 f822 	bl	23ea0 <memset>
        sha256->hiLen = (sha256->loLen >> (8 * sizeof(sha256->loLen) - 3)) +
   11e5c:	6e63      	ldr	r3, [r4, #100]	; 0x64
                                                         (sha256->hiLen << 3);
   11e5e:	6ea1      	ldr	r1, [r4, #104]	; 0x68
        sha256->hiLen = (sha256->loLen >> (8 * sizeof(sha256->loLen) - 3)) +
   11e60:	0f5a      	lsrs	r2, r3, #29
   11e62:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
   11e66:	66a2      	str	r2, [r4, #104]	; 0x68
        sha256->loLen = sha256->loLen << 3;
   11e68:	00db      	lsls	r3, r3, #3
   11e6a:	6663      	str	r3, [r4, #100]	; 0x64
   11e6c:	f104 011c 	add.w	r1, r4, #28
   11e70:	f104 005c 	add.w	r0, r4, #92	; 0x5c
        out[i] = ByteReverseWord32(in[i]);
   11e74:	f851 2f04 	ldr.w	r2, [r1, #4]!
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
   11e78:	0a13      	lsrs	r3, r2, #8
   11e7a:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
   11e7e:	0212      	lsls	r2, r2, #8
   11e80:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
   11e84:	4313      	orrs	r3, r2
        return (x << y) | (x >> (sizeof(y) * 8 - y));
   11e86:	ea4f 4333 	mov.w	r3, r3, ror #16
        out[i] = ByteReverseWord32(in[i]);
   11e8a:	600b      	str	r3, [r1, #0]
    for (i = 0; i < count; i++)
   11e8c:	4281      	cmp	r1, r0
   11e8e:	d1f1      	bne.n	11e74 <wc_Sha256Final+0xb0>
        XMEMCPY(&local[WC_SHA256_PAD_SIZE], &sha256->hiLen, sizeof(word32));
   11e90:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   11e92:	65a3      	str	r3, [r4, #88]	; 0x58
        XMEMCPY(&local[WC_SHA256_PAD_SIZE + sizeof(word32)], &sha256->loLen,
   11e94:	6e63      	ldr	r3, [r4, #100]	; 0x64
   11e96:	65e3      	str	r3, [r4, #92]	; 0x5c
        ret = XTRANSFORM(sha256, (const byte*)local);
   11e98:	4631      	mov	r1, r6
   11e9a:	4620      	mov	r0, r4
   11e9c:	f7fa fb7a 	bl	c594 <Transform_Sha256>
        #endif
        }
    #endif /* WOLFSSL_ASYNC_CRYPT */

        ret = Sha256Final(sha256);
        if (ret != 0)
   11ea0:	4607      	mov	r7, r0
   11ea2:	2800      	cmp	r0, #0
   11ea4:	d13b      	bne.n	11f1e <wc_Sha256Final+0x15a>
            return ret;

    #if defined(LITTLE_ENDIAN_ORDER)
        ByteReverseWords(sha256->digest, sha256->digest, WC_SHA256_DIGEST_SIZE);
   11ea6:	4626      	mov	r6, r4
   11ea8:	1f21      	subs	r1, r4, #4
   11eaa:	f104 001c 	add.w	r0, r4, #28
        out[i] = ByteReverseWord32(in[i]);
   11eae:	f851 2f04 	ldr.w	r2, [r1, #4]!
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
   11eb2:	0a13      	lsrs	r3, r2, #8
   11eb4:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
   11eb8:	0212      	lsls	r2, r2, #8
   11eba:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
   11ebe:	4313      	orrs	r3, r2
        return (x << y) | (x >> (sizeof(y) * 8 - y));
   11ec0:	ea4f 4333 	mov.w	r3, r3, ror #16
        out[i] = ByteReverseWord32(in[i]);
   11ec4:	600b      	str	r3, [r1, #0]
    for (i = 0; i < count; i++)
   11ec6:	4288      	cmp	r0, r1
   11ec8:	d1f1      	bne.n	11eae <wc_Sha256Final+0xea>
    #endif
        XMEMCPY(hash, sha256->digest, WC_SHA256_DIGEST_SIZE);
   11eca:	6830      	ldr	r0, [r6, #0]
   11ecc:	6871      	ldr	r1, [r6, #4]
   11ece:	68b2      	ldr	r2, [r6, #8]
   11ed0:	68f3      	ldr	r3, [r6, #12]
   11ed2:	6028      	str	r0, [r5, #0]
   11ed4:	6069      	str	r1, [r5, #4]
   11ed6:	60aa      	str	r2, [r5, #8]
   11ed8:	60eb      	str	r3, [r5, #12]
   11eda:	6930      	ldr	r0, [r6, #16]
   11edc:	6971      	ldr	r1, [r6, #20]
   11ede:	69b2      	ldr	r2, [r6, #24]
   11ee0:	69f3      	ldr	r3, [r6, #28]
   11ee2:	6128      	str	r0, [r5, #16]
   11ee4:	6169      	str	r1, [r5, #20]
   11ee6:	61aa      	str	r2, [r5, #24]
   11ee8:	61eb      	str	r3, [r5, #28]
    sha256->digest[0] = 0x6A09E667L;
   11eea:	4b11      	ldr	r3, [pc, #68]	; (11f30 <wc_Sha256Final+0x16c>)
   11eec:	6023      	str	r3, [r4, #0]
    sha256->digest[1] = 0xBB67AE85L;
   11eee:	4b11      	ldr	r3, [pc, #68]	; (11f34 <wc_Sha256Final+0x170>)
   11ef0:	6063      	str	r3, [r4, #4]
    sha256->digest[2] = 0x3C6EF372L;
   11ef2:	4b11      	ldr	r3, [pc, #68]	; (11f38 <wc_Sha256Final+0x174>)
   11ef4:	60a3      	str	r3, [r4, #8]
    sha256->digest[3] = 0xA54FF53AL;
   11ef6:	4b11      	ldr	r3, [pc, #68]	; (11f3c <wc_Sha256Final+0x178>)
   11ef8:	60e3      	str	r3, [r4, #12]
    sha256->digest[4] = 0x510E527FL;
   11efa:	4b11      	ldr	r3, [pc, #68]	; (11f40 <wc_Sha256Final+0x17c>)
   11efc:	6123      	str	r3, [r4, #16]
    sha256->digest[5] = 0x9B05688CL;
   11efe:	4b11      	ldr	r3, [pc, #68]	; (11f44 <wc_Sha256Final+0x180>)
   11f00:	6163      	str	r3, [r4, #20]
    sha256->digest[6] = 0x1F83D9ABL;
   11f02:	4b11      	ldr	r3, [pc, #68]	; (11f48 <wc_Sha256Final+0x184>)
   11f04:	61a3      	str	r3, [r4, #24]
    sha256->digest[7] = 0x5BE0CD19L;
   11f06:	f103 5374 	add.w	r3, r3, #1023410176	; 0x3d000000
   11f0a:	f5a3 0323 	sub.w	r3, r3, #10682368	; 0xa30000
   11f0e:	f6a3 4392 	subw	r3, r3, #3218	; 0xc92
   11f12:	61e3      	str	r3, [r4, #28]
    sha256->buffLen = 0;
   11f14:	2300      	movs	r3, #0
   11f16:	6623      	str	r3, [r4, #96]	; 0x60
    sha256->loLen   = 0;
   11f18:	6663      	str	r3, [r4, #100]	; 0x64
    sha256->hiLen   = 0;
   11f1a:	66a3      	str	r3, [r4, #104]	; 0x68
    sha256->flags = 0;
   11f1c:	67a3      	str	r3, [r4, #120]	; 0x78

        return InitSha256(sha256);  /* reset state */
    }
   11f1e:	4638      	mov	r0, r7
   11f20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return BAD_FUNC_ARG;
   11f22:	f06f 07ac 	mvn.w	r7, #172	; 0xac
   11f26:	e7fa      	b.n	11f1e <wc_Sha256Final+0x15a>
   11f28:	f06f 07ac 	mvn.w	r7, #172	; 0xac
   11f2c:	e7f7      	b.n	11f1e <wc_Sha256Final+0x15a>
   11f2e:	bf00      	nop
   11f30:	6a09e667 	.word	0x6a09e667
   11f34:	bb67ae85 	.word	0xbb67ae85
   11f38:	3c6ef372 	.word	0x3c6ef372
   11f3c:	a54ff53a 	.word	0xa54ff53a
   11f40:	510e527f 	.word	0x510e527f
   11f44:	9b05688c 	.word	0x9b05688c
   11f48:	1f83d9ab 	.word	0x1f83d9ab

Disassembly of section .text._InitRng%280:

00011f4c <_InitRng>:
/* End NIST DRBG Code */


static int _InitRng(WC_RNG* rng, byte* nonce, word32 nonceSz,
                    void* heap, int devId)
{
   11f4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11f50:	b0a9      	sub	sp, #164	; 0xa4
   11f52:	f8dd b0c8 	ldr.w	fp, [sp, #200]	; 0xc8
#endif

    (void)nonce;
    (void)nonceSz;

    if (rng == NULL)
   11f56:	2800      	cmp	r0, #0
   11f58:	f000 80af 	beq.w	120ba <_InitRng+0x16e>
   11f5c:	4604      	mov	r4, r0
        return BAD_FUNC_ARG;
    if (nonce == NULL && nonceSz != 0)
   11f5e:	2900      	cmp	r1, #0
   11f60:	d064      	beq.n	1202c <_InitRng+0xe0>

#ifdef WOLFSSL_HEAP_TEST
    rng->heap = (void*)WOLFSSL_HEAP_TEST;
    (void)heap;
#else
    rng->heap = heap;
   11f62:	6083      	str	r3, [r0, #8]
#endif
#if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
    rng->devId = devId;
   11f64:	f8c0 b014 	str.w	fp, [r0, #20]
    #if defined(WOLF_CRYPTO_CB)
        rng->seed.devId = devId;
   11f68:	f8c0 b004 	str.w	fp, [r0, #4]
    (void)devId;
#endif

#ifdef HAVE_HASHDRBG
    /* init the DBRG to known values */
    rng->drbg = NULL;
   11f6c:	2300      	movs	r3, #0
   11f6e:	60c3      	str	r3, [r0, #12]
    rng->status = DRBG_NOT_INIT;
   11f70:	7403      	strb	r3, [r0, #16]
#ifdef CUSTOM_RAND_GENERATE_BLOCK
    ret = 0; /* success */
#else
#ifdef HAVE_HASHDRBG
    if (nonceSz == 0)
        seedSz = MAX_SEED_SZ;
   11f72:	429a      	cmp	r2, r3
   11f74:	bf14      	ite	ne
   11f76:	2724      	movne	r7, #36	; 0x24
   11f78:	2734      	moveq	r7, #52	; 0x34
   11f7a:	4691      	mov	r9, r2
   11f7c:	4688      	mov	r8, r1
            XMEMCPY_P(outputB, outputB_data, sizeof(outputB_data));
#else
        const byte* seedB = seedB_data;
        const byte* outputB = outputB_data;
#endif
        ret = wc_RNG_HealthTest(0, seedB, sizeof(seedB_data),
   11f7e:	2380      	movs	r3, #128	; 0x80
   11f80:	9302      	str	r3, [sp, #8]
   11f82:	ab08      	add	r3, sp, #32
   11f84:	9301      	str	r3, [sp, #4]
   11f86:	2000      	movs	r0, #0
   11f88:	9000      	str	r0, [sp, #0]
   11f8a:	4603      	mov	r3, r0
   11f8c:	2230      	movs	r2, #48	; 0x30
   11f8e:	494e      	ldr	r1, [pc, #312]	; (120c8 <_InitRng+0x17c>)
   11f90:	f00f fe22 	bl	21bd8 <wc_RNG_HealthTest>
                                NULL, 0,
                                check, RNG_HEALTH_TEST_CHECK_SIZE);
        if (ret == 0) {
   11f94:	4601      	mov	r1, r0
   11f96:	2800      	cmp	r0, #0
   11f98:	f040 808a 	bne.w	120b0 <_InitRng+0x164>
   11f9c:	f10d 051f 	add.w	r5, sp, #31
   11fa0:	f8df a128 	ldr.w	sl, [pc, #296]	; 120cc <_InitRng+0x180>
   11fa4:	f10d 069f 	add.w	r6, sp, #159	; 0x9f
   11fa8:	4650      	mov	r0, sl
   11faa:	462a      	mov	r2, r5
{
    int i;
    int compareSum = 0;

    for (i = 0; i < length; i++) {
        compareSum |= a[i] ^ b[i];
   11fac:	f812 3f01 	ldrb.w	r3, [r2, #1]!
   11fb0:	f810 cf01 	ldrb.w	ip, [r0, #1]!
   11fb4:	ea83 030c 	eor.w	r3, r3, ip
   11fb8:	4319      	orrs	r1, r3
    for (i = 0; i < length; i++) {
   11fba:	42b2      	cmp	r2, r6
   11fbc:	d1f6      	bne.n	11fac <_InitRng+0x60>
            if (ConstantCompare(check, outputB,
   11fbe:	2900      	cmp	r1, #0
   11fc0:	d176      	bne.n	120b0 <_InitRng+0x164>
        /* The previous test cases use a large seed instead of a seed and nonce.
         * seedB is actually from a test case with a seed and nonce, and
         * just concatenates them. The pivot point between seed and nonce is
         * byte 32, feed them into the health test separately. */
        if (ret == 0) {
            ret = wc_RNG_HealthTest_ex(0,
   11fc2:	4941      	ldr	r1, [pc, #260]	; (120c8 <_InitRng+0x17c>)
   11fc4:	f06f 0301 	mvn.w	r3, #1
   11fc8:	9306      	str	r3, [sp, #24]
   11fca:	2000      	movs	r0, #0
   11fcc:	9005      	str	r0, [sp, #20]
   11fce:	2380      	movs	r3, #128	; 0x80
   11fd0:	9304      	str	r3, [sp, #16]
   11fd2:	ab08      	add	r3, sp, #32
   11fd4:	9303      	str	r3, [sp, #12]
   11fd6:	9002      	str	r0, [sp, #8]
   11fd8:	9001      	str	r0, [sp, #4]
   11fda:	2320      	movs	r3, #32
   11fdc:	9300      	str	r3, [sp, #0]
   11fde:	460b      	mov	r3, r1
   11fe0:	2210      	movs	r2, #16
   11fe2:	3120      	adds	r1, #32
   11fe4:	f007 f9b8 	bl	19358 <wc_RNG_HealthTest_ex>
                                    seedB + 32, sizeof(seedB_data) - 32,
                                    seedB, 32,
                                    NULL, 0,
                                    check, RNG_HEALTH_TEST_CHECK_SIZE,
                                    NULL, INVALID_DEVID);
            if (ret == 0) {
   11fe8:	4602      	mov	r2, r0
   11fea:	2800      	cmp	r0, #0
   11fec:	d160      	bne.n	120b0 <_InitRng+0x164>
        compareSum |= a[i] ^ b[i];
   11fee:	f815 3f01 	ldrb.w	r3, [r5, #1]!
   11ff2:	f81a 1f01 	ldrb.w	r1, [sl, #1]!
   11ff6:	404b      	eors	r3, r1
   11ff8:	431a      	orrs	r2, r3
    for (i = 0; i < length; i++) {
   11ffa:	42b5      	cmp	r5, r6
   11ffc:	d1f7      	bne.n	11fee <_InitRng+0xa2>
                if (ConstantCompare(check, outputB, sizeof(outputB_data)) != 0)
   11ffe:	2a00      	cmp	r2, #0
   12000:	d156      	bne.n	120b0 <_InitRng+0x164>
                (struct DRBG*)XMALLOC(sizeof(DRBG_internal), rng->heap,
   12002:	2084      	movs	r0, #132	; 0x84
   12004:	f011 ff3c 	bl	23e80 <malloc>
        rng->drbg =
   12008:	60e0      	str	r0, [r4, #12]
        if (rng->drbg == NULL) {
   1200a:	b1d8      	cbz	r0, 12044 <_InitRng+0xf8>
            ret = wc_GenerateSeed(&rng->seed, seed, seedSz);
   1200c:	463a      	mov	r2, r7
   1200e:	a908      	add	r1, sp, #32
   12010:	4620      	mov	r0, r4
   12012:	f009 ff5b 	bl	1becc <wc_GenerateSeed>
            if (ret == 0)
   12016:	b338      	cbz	r0, 12068 <_InitRng+0x11c>
                rng->status = DRBG_FAILED;
   12018:	2302      	movs	r3, #2
   1201a:	7423      	strb	r3, [r4, #16]
                ret = DRBG_FAILURE;
   1201c:	2501      	movs	r5, #1
                XFREE(rng->drbg, rng->heap, DYNAMIC_TYPE_RNG);
   1201e:	68e0      	ldr	r0, [r4, #12]
   12020:	b108      	cbz	r0, 12026 <_InitRng+0xda>
   12022:	f011 ff35 	bl	23e90 <free>
                rng->drbg = NULL;
   12026:	2300      	movs	r3, #0
   12028:	60e3      	str	r3, [r4, #12]
   1202a:	e00f      	b.n	1204c <_InitRng+0x100>
    if (nonce == NULL && nonceSz != 0)
   1202c:	2a00      	cmp	r2, #0
   1202e:	d147      	bne.n	120c0 <_InitRng+0x174>
    rng->heap = heap;
   12030:	6083      	str	r3, [r0, #8]
    rng->devId = devId;
   12032:	f8c0 b014 	str.w	fp, [r0, #20]
        rng->seed.devId = devId;
   12036:	f8c0 b004 	str.w	fp, [r0, #4]
    rng->drbg = NULL;
   1203a:	2300      	movs	r3, #0
   1203c:	60c3      	str	r3, [r0, #12]
    rng->status = DRBG_NOT_INIT;
   1203e:	7403      	strb	r3, [r0, #16]
        seedSz = MAX_SEED_SZ;
   12040:	2734      	movs	r7, #52	; 0x34
   12042:	e79a      	b.n	11f7a <_InitRng+0x2e>
            rng->status = DRBG_FAILED;
   12044:	2302      	movs	r3, #2
   12046:	7423      	strb	r3, [r4, #16]
            ret = MEMORY_E;
   12048:	f06f 057c 	mvn.w	r5, #124	; 0x7c
    while (len--) *z++ = 0;
   1204c:	ab08      	add	r3, sp, #32
   1204e:	441f      	add	r7, r3
    volatile byte* z = (volatile byte*)mem;
   12050:	461a      	mov	r2, r3
    while (len--) *z++ = 0;
   12052:	2100      	movs	r1, #0
   12054:	4613      	mov	r3, r2
   12056:	f803 1b01 	strb.w	r1, [r3], #1
   1205a:	461a      	mov	r2, r3
   1205c:	42bb      	cmp	r3, r7
   1205e:	d1f9      	bne.n	12054 <_InitRng+0x108>
    if (ret == DRBG_SUCCESS) {
   12060:	b9cd      	cbnz	r5, 12096 <_InitRng+0x14a>
        rng->status = DRBG_OK;
   12062:	2301      	movs	r3, #1
   12064:	7423      	strb	r3, [r4, #16]
        ret = 0;
   12066:	e01f      	b.n	120a8 <_InitRng+0x15c>
                ret = wc_RNG_TestSeed(seed, seedSz);
   12068:	4639      	mov	r1, r7
   1206a:	a808      	add	r0, sp, #32
   1206c:	f00a fd26 	bl	1cabc <wc_RNG_TestSeed>
            if (ret == DRBG_SUCCESS)
   12070:	4605      	mov	r5, r0
   12072:	2800      	cmp	r0, #0
   12074:	d1d3      	bne.n	1201e <_InitRng+0xd2>
	      ret = Hash_DRBG_Instantiate((DRBG_internal *)rng->drbg,
   12076:	f8cd b008 	str.w	fp, [sp, #8]
   1207a:	68a3      	ldr	r3, [r4, #8]
   1207c:	9301      	str	r3, [sp, #4]
   1207e:	f8cd 9000 	str.w	r9, [sp]
   12082:	4643      	mov	r3, r8
   12084:	1f3a      	subs	r2, r7, #4
   12086:	a909      	add	r1, sp, #36	; 0x24
   12088:	68e0      	ldr	r0, [r4, #12]
   1208a:	f00a f804 	bl	1c096 <Hash_DRBG_Instantiate>
            if (ret != DRBG_SUCCESS) {
   1208e:	4605      	mov	r5, r0
   12090:	2800      	cmp	r0, #0
   12092:	d0db      	beq.n	1204c <_InitRng+0x100>
   12094:	e7c3      	b.n	1201e <_InitRng+0xd2>
    else if (ret == DRBG_CONT_FAILURE) {
   12096:	2d03      	cmp	r5, #3
   12098:	d00a      	beq.n	120b0 <_InitRng+0x164>
    else if (ret == DRBG_FAILURE) {
   1209a:	2d01      	cmp	r5, #1
        rng->status = DRBG_FAILED;
   1209c:	f04f 0302 	mov.w	r3, #2
   120a0:	7423      	strb	r3, [r4, #16]
        ret = RNG_FAILURE_E;
   120a2:	bf08      	it	eq
   120a4:	f06f 05c6 	mvneq.w	r5, #198	; 0xc6
}
   120a8:	4628      	mov	r0, r5
   120aa:	b029      	add	sp, #164	; 0xa4
   120ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        rng->status = DRBG_CONT_FAILED;
   120b0:	2303      	movs	r3, #3
   120b2:	7423      	strb	r3, [r4, #16]
        ret = DRBG_CONT_FIPS_E;
   120b4:	f06f 05d0 	mvn.w	r5, #208	; 0xd0
   120b8:	e7f6      	b.n	120a8 <_InitRng+0x15c>
        return BAD_FUNC_ARG;
   120ba:	f06f 05ac 	mvn.w	r5, #172	; 0xac
   120be:	e7f3      	b.n	120a8 <_InitRng+0x15c>
        return BAD_FUNC_ARG;
   120c0:	f06f 05ac 	mvn.w	r5, #172	; 0xac
   120c4:	e7f0      	b.n	120a8 <_InitRng+0x15c>
   120c6:	bf00      	nop
   120c8:	0002157c 	.word	0x0002157c
   120cc:	0001b193 	.word	0x0001b193

Disassembly of section .text.SERCOM1_USART_InterruptHandler%281:

000120d0 <SERCOM1_USART_InterruptHandler>:
        }
    }
}

void SERCOM1_USART_InterruptHandler( void )
{
   120d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    bool testCondition = false;
    if(SERCOM1_REGS->USART_INT.SERCOM_INTENSET != 0U)
   120d2:	4b5a      	ldr	r3, [pc, #360]	; (1223c <SERCOM1_USART_InterruptHandler+0x16c>)
   120d4:	7d9b      	ldrb	r3, [r3, #22]
   120d6:	2b00      	cmp	r3, #0
   120d8:	f000 80ae 	beq.w	12238 <SERCOM1_USART_InterruptHandler+0x168>
    {
        /* Checks for error flag */
        testCondition = ((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_ERROR_Msk) == SERCOM_USART_INT_INTFLAG_ERROR_Msk);
   120dc:	4a57      	ldr	r2, [pc, #348]	; (1223c <SERCOM1_USART_InterruptHandler+0x16c>)
   120de:	7e13      	ldrb	r3, [r2, #24]
   120e0:	b2db      	uxtb	r3, r3
        testCondition = ((SERCOM1_REGS->USART_INT.SERCOM_INTENSET & SERCOM_USART_INT_INTENSET_ERROR_Msk) == SERCOM_USART_INT_INTENSET_ERROR_Msk) && testCondition;
   120e2:	7d92      	ldrb	r2, [r2, #22]
   120e4:	f012 0f80 	tst.w	r2, #128	; 0x80
   120e8:	d13e      	bne.n	12168 <SERCOM1_USART_InterruptHandler+0x98>
        if(testCondition)
        {
            SERCOM1_USART_ISR_ERR_Handler();
        }

        testCondition = ((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_DRE_Msk) == SERCOM_USART_INT_INTFLAG_DRE_Msk);
   120ea:	4a54      	ldr	r2, [pc, #336]	; (1223c <SERCOM1_USART_InterruptHandler+0x16c>)
   120ec:	7e13      	ldrb	r3, [r2, #24]
   120ee:	b2db      	uxtb	r3, r3
        testCondition = ((SERCOM1_REGS->USART_INT.SERCOM_INTENSET & SERCOM_USART_INT_INTENSET_DRE_Msk) == SERCOM_USART_INT_INTENSET_DRE_Msk) && testCondition;
   120f0:	7d92      	ldrb	r2, [r2, #22]
   120f2:	f012 0f01 	tst.w	r2, #1
   120f6:	f000 8092 	beq.w	1221e <SERCOM1_USART_InterruptHandler+0x14e>
   120fa:	f013 0f01 	tst.w	r3, #1
   120fe:	f000 808e 	beq.w	1221e <SERCOM1_USART_InterruptHandler+0x14e>
    while ((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_DRE_Msk) == SERCOM_USART_INT_INTFLAG_DRE_Msk)
   12102:	4d4e      	ldr	r5, [pc, #312]	; (1223c <SERCOM1_USART_InterruptHandler+0x16c>)
    uint32_t wrInIndex = sercom1USARTObj.wrInIndex;
   12104:	4c4e      	ldr	r4, [pc, #312]	; (12240 <SERCOM1_USART_InterruptHandler+0x170>)
            *pWrByte = ((uint16_t*)&SERCOM1_USART_WriteBuffer)[wrOutIndex++];
   12106:	4e4f      	ldr	r6, [pc, #316]	; (12244 <SERCOM1_USART_InterruptHandler+0x174>)
    while ((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_DRE_Msk) == SERCOM_USART_INT_INTFLAG_DRE_Msk)
   12108:	7e2b      	ldrb	r3, [r5, #24]
   1210a:	f013 0f01 	tst.w	r3, #1
   1210e:	f000 8086 	beq.w	1221e <SERCOM1_USART_InterruptHandler+0x14e>
    uint32_t wrInIndex = sercom1USARTObj.wrInIndex;
   12112:	68a3      	ldr	r3, [r4, #8]
    uint32_t wrOutIndex = sercom1USARTObj.wrOutIndex;
   12114:	68e2      	ldr	r2, [r4, #12]
    if (wrOutIndex != wrInIndex)
   12116:	4293      	cmp	r3, r2
   12118:	d07e      	beq.n	12218 <SERCOM1_USART_InterruptHandler+0x148>
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   1211a:	686b      	ldr	r3, [r5, #4]
   1211c:	f003 0307 	and.w	r3, r3, #7
   12120:	2b01      	cmp	r3, #1
            *pWrByte = SERCOM1_USART_WriteBuffer[wrOutIndex++];
   12122:	f102 0301 	add.w	r3, r2, #1
   12126:	bf14      	ite	ne
   12128:	5cb2      	ldrbne	r2, [r6, r2]
            *pWrByte = ((uint16_t*)&SERCOM1_USART_WriteBuffer)[wrOutIndex++];
   1212a:	f836 2012 	ldrheq.w	r2, [r6, r2, lsl #1]
        if (wrOutIndex >= sercom1USARTObj.wrBufferSize)
   1212e:	6921      	ldr	r1, [r4, #16]
            wrOutIndex = 0U;
   12130:	4299      	cmp	r1, r3
   12132:	bf98      	it	ls
   12134:	2300      	movls	r3, #0
        sercom1USARTObj.wrOutIndex = wrOutIndex;
   12136:	60e3      	str	r3, [r4, #12]
            if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   12138:	686b      	ldr	r3, [r5, #4]
   1213a:	f003 0307 	and.w	r3, r3, #7
   1213e:	2b01      	cmp	r3, #1
                SERCOM1_REGS->USART_INT.SERCOM_DATA = (uint8_t)wrByte;
   12140:	bf18      	it	ne
   12142:	b2d2      	uxtbne	r2, r2
                SERCOM1_REGS->USART_INT.SERCOM_DATA = wrByte;
   12144:	62aa      	str	r2, [r5, #40]	; 0x28
    if (sercom1USARTObj.isWrNotificationEnabled == true)
   12146:	7d23      	ldrb	r3, [r4, #20]
   12148:	2b00      	cmp	r3, #0
   1214a:	d0dd      	beq.n	12108 <SERCOM1_USART_InterruptHandler+0x38>
        nFreeWrBufferCount = SERCOM1_USART_WriteFreeBufferCountGet();
   1214c:	f011 fcf2 	bl	23b34 <SERCOM1_USART_WriteFreeBufferCountGet>
        if(sercom1USARTObj.wrCallback != NULL)
   12150:	6823      	ldr	r3, [r4, #0]
   12152:	2b00      	cmp	r3, #0
   12154:	d0d8      	beq.n	12108 <SERCOM1_USART_InterruptHandler+0x38>
            if (sercom1USARTObj.isWrNotifyPersistently == true)
   12156:	7f22      	ldrb	r2, [r4, #28]
   12158:	b342      	cbz	r2, 121ac <SERCOM1_USART_InterruptHandler+0xdc>
                if (nFreeWrBufferCount >= sercom1USARTObj.wrThreshold)
   1215a:	69a2      	ldr	r2, [r4, #24]
   1215c:	4290      	cmp	r0, r2
   1215e:	d3d3      	bcc.n	12108 <SERCOM1_USART_InterruptHandler+0x38>
                    sercom1USARTObj.wrCallback(SERCOM_USART_EVENT_WRITE_THRESHOLD_REACHED, sercom1USARTObj.wrContext);
   12160:	6861      	ldr	r1, [r4, #4]
   12162:	2003      	movs	r0, #3
   12164:	4798      	blx	r3
   12166:	e7cf      	b.n	12108 <SERCOM1_USART_InterruptHandler+0x38>
        testCondition = ((SERCOM1_REGS->USART_INT.SERCOM_INTENSET & SERCOM_USART_INT_INTENSET_ERROR_Msk) == SERCOM_USART_INT_INTENSET_ERROR_Msk) && testCondition;
   12168:	f013 0f80 	tst.w	r3, #128	; 0x80
   1216c:	d0bd      	beq.n	120ea <SERCOM1_USART_InterruptHandler+0x1a>
    USART_ERROR errorStatus = (USART_ERROR)(SERCOM1_REGS->USART_INT.SERCOM_STATUS & (SERCOM_USART_INT_STATUS_PERR_Msk | SERCOM_USART_INT_STATUS_FERR_Msk | SERCOM_USART_INT_STATUS_BUFOVF_Msk ));
   1216e:	4b33      	ldr	r3, [pc, #204]	; (1223c <SERCOM1_USART_InterruptHandler+0x16c>)
   12170:	8b5b      	ldrh	r3, [r3, #26]
    if(errorStatus != USART_ERROR_NONE)
   12172:	f013 0307 	ands.w	r3, r3, #7
   12176:	d0b8      	beq.n	120ea <SERCOM1_USART_InterruptHandler+0x1a>
        sercom1USARTObj.errorStatus = errorStatus;
   12178:	4a31      	ldr	r2, [pc, #196]	; (12240 <SERCOM1_USART_InterruptHandler+0x170>)
   1217a:	87d3      	strh	r3, [r2, #62]	; 0x3e
    SERCOM1_REGS->USART_INT.SERCOM_INTFLAG = SERCOM_USART_INT_INTFLAG_ERROR_Msk;
   1217c:	4b2f      	ldr	r3, [pc, #188]	; (1223c <SERCOM1_USART_InterruptHandler+0x16c>)
   1217e:	2280      	movs	r2, #128	; 0x80
   12180:	761a      	strb	r2, [r3, #24]
    SERCOM1_REGS->USART_INT.SERCOM_STATUS = SERCOM_USART_INT_STATUS_PERR_Msk | SERCOM_USART_INT_STATUS_FERR_Msk | SERCOM_USART_INT_STATUS_BUFOVF_Msk ;
   12182:	2207      	movs	r2, #7
   12184:	835a      	strh	r2, [r3, #26]
    while((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_RXC_Msk) == SERCOM_USART_INT_INTFLAG_RXC_Msk)
   12186:	7e1b      	ldrb	r3, [r3, #24]
   12188:	f013 0f04 	tst.w	r3, #4
   1218c:	d005      	beq.n	1219a <SERCOM1_USART_InterruptHandler+0xca>
        u8dummyData = SERCOM1_REGS->USART_INT.SERCOM_DATA;
   1218e:	4b2b      	ldr	r3, [pc, #172]	; (1223c <SERCOM1_USART_InterruptHandler+0x16c>)
   12190:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    while((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_RXC_Msk) == SERCOM_USART_INT_INTFLAG_RXC_Msk)
   12192:	7e1a      	ldrb	r2, [r3, #24]
   12194:	f012 0f04 	tst.w	r2, #4
   12198:	d1fa      	bne.n	12190 <SERCOM1_USART_InterruptHandler+0xc0>
        if(sercom1USARTObj.rdCallback != NULL)
   1219a:	4b29      	ldr	r3, [pc, #164]	; (12240 <SERCOM1_USART_InterruptHandler+0x170>)
   1219c:	6a1b      	ldr	r3, [r3, #32]
   1219e:	2b00      	cmp	r3, #0
   121a0:	d0a3      	beq.n	120ea <SERCOM1_USART_InterruptHandler+0x1a>
            sercom1USARTObj.rdCallback(SERCOM_USART_EVENT_READ_ERROR, sercom1USARTObj.rdContext);
   121a2:	4a27      	ldr	r2, [pc, #156]	; (12240 <SERCOM1_USART_InterruptHandler+0x170>)
   121a4:	6a51      	ldr	r1, [r2, #36]	; 0x24
   121a6:	2002      	movs	r0, #2
   121a8:	4798      	blx	r3
   121aa:	e79e      	b.n	120ea <SERCOM1_USART_InterruptHandler+0x1a>
                if (nFreeWrBufferCount == sercom1USARTObj.wrThreshold)
   121ac:	69a2      	ldr	r2, [r4, #24]
   121ae:	4290      	cmp	r0, r2
   121b0:	d1aa      	bne.n	12108 <SERCOM1_USART_InterruptHandler+0x38>
                    sercom1USARTObj.wrCallback(SERCOM_USART_EVENT_WRITE_THRESHOLD_REACHED, sercom1USARTObj.wrContext);
   121b2:	6861      	ldr	r1, [r4, #4]
   121b4:	2003      	movs	r0, #3
   121b6:	4798      	blx	r3
   121b8:	e7a6      	b.n	12108 <SERCOM1_USART_InterruptHandler+0x38>
        if(sercom1USARTObj.rdCallback != NULL)
   121ba:	6a22      	ldr	r2, [r4, #32]
   121bc:	b1e2      	cbz	r2, 121f8 <SERCOM1_USART_InterruptHandler+0x128>
            sercom1USARTObj.rdCallback(SERCOM_USART_EVENT_READ_BUFFER_FULL, sercom1USARTObj.rdContext);
   121be:	6a61      	ldr	r1, [r4, #36]	; 0x24
   121c0:	4638      	mov	r0, r7
   121c2:	4790      	blx	r2
            tempInIndex = sercom1USARTObj.rdInIndex + 1U;
   121c4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   121c6:	3301      	adds	r3, #1
            if (tempInIndex >= sercom1USARTObj.rdBufferSize)
   121c8:	6b22      	ldr	r2, [r4, #48]	; 0x30
                tempInIndex = 0U;
   121ca:	4293      	cmp	r3, r2
   121cc:	bf28      	it	cs
   121ce:	2300      	movcs	r3, #0
   121d0:	e012      	b.n	121f8 <SERCOM1_USART_InterruptHandler+0x128>
            ((uint16_t*)&SERCOM1_USART_ReadBuffer)[sercom1USARTObj.rdInIndex] = rdByte;
   121d2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
   121d4:	4a1c      	ldr	r2, [pc, #112]	; (12248 <SERCOM1_USART_InterruptHandler+0x178>)
        if (SERCOM1_USART_RxPushByte( (uint16_t)SERCOM1_REGS->USART_INT.SERCOM_DATA) == true)
   121d6:	f822 6011 	strh.w	r6, [r2, r1, lsl #1]
   121da:	e018      	b.n	1220e <SERCOM1_USART_InterruptHandler+0x13e>
    while ((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_RXC_Msk) == SERCOM_USART_INT_INTFLAG_RXC_Msk)
   121dc:	7e2b      	ldrb	r3, [r5, #24]
   121de:	f013 0f04 	tst.w	r3, #4
   121e2:	d029      	beq.n	12238 <SERCOM1_USART_InterruptHandler+0x168>
        if (SERCOM1_USART_RxPushByte( (uint16_t)SERCOM1_REGS->USART_INT.SERCOM_DATA) == true)
   121e4:	6aae      	ldr	r6, [r5, #40]	; 0x28
    tempInIndex = sercom1USARTObj.rdInIndex + 1U;
   121e6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   121e8:	3301      	adds	r3, #1
    if (tempInIndex >= sercom1USARTObj.rdBufferSize)
   121ea:	6b22      	ldr	r2, [r4, #48]	; 0x30
        tempInIndex = 0U;
   121ec:	4293      	cmp	r3, r2
   121ee:	bf28      	it	cs
   121f0:	2300      	movcs	r3, #0
    if (tempInIndex == sercom1USARTObj.rdOutIndex)
   121f2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   121f4:	429a      	cmp	r2, r3
   121f6:	d0e0      	beq.n	121ba <SERCOM1_USART_InterruptHandler+0xea>
    if (tempInIndex != sercom1USARTObj.rdOutIndex)
   121f8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   121fa:	429a      	cmp	r2, r3
   121fc:	d0ee      	beq.n	121dc <SERCOM1_USART_InterruptHandler+0x10c>
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   121fe:	686a      	ldr	r2, [r5, #4]
   12200:	f002 0207 	and.w	r2, r2, #7
   12204:	2a01      	cmp	r2, #1
   12206:	d0e4      	beq.n	121d2 <SERCOM1_USART_InterruptHandler+0x102>
            SERCOM1_USART_ReadBuffer[sercom1USARTObj.rdInIndex] = (uint8_t)rdByte;
   12208:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   1220a:	490f      	ldr	r1, [pc, #60]	; (12248 <SERCOM1_USART_InterruptHandler+0x178>)
   1220c:	548e      	strb	r6, [r1, r2]
        sercom1USARTObj.rdInIndex = tempInIndex;
   1220e:	62a3      	str	r3, [r4, #40]	; 0x28
            SERCOM1_USART_ReadNotificationSend();
   12210:	f00c fe0e 	bl	1ee30 <SERCOM1_USART_ReadNotificationSend>
            sercom1USARTObj.rdCallback(SERCOM_USART_EVENT_READ_BUFFER_FULL, sercom1USARTObj.rdContext);
   12214:	2701      	movs	r7, #1
   12216:	e7e1      	b.n	121dc <SERCOM1_USART_InterruptHandler+0x10c>
            SERCOM1_USART_TX_INT_DISABLE();
   12218:	4b08      	ldr	r3, [pc, #32]	; (1223c <SERCOM1_USART_InterruptHandler+0x16c>)
   1221a:	2201      	movs	r2, #1
   1221c:	751a      	strb	r2, [r3, #20]
        {
            SERCOM1_USART_ISR_TX_Handler();
        }

        /* Checks for receive complete empty flag */
        testCondition = (SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_RXC_Msk);
   1221e:	4a07      	ldr	r2, [pc, #28]	; (1223c <SERCOM1_USART_InterruptHandler+0x16c>)
   12220:	7e13      	ldrb	r3, [r2, #24]
   12222:	b2db      	uxtb	r3, r3
        testCondition = (SERCOM1_REGS->USART_INT.SERCOM_INTENSET & SERCOM_USART_INT_INTENSET_RXC_Msk) && testCondition;
   12224:	7d92      	ldrb	r2, [r2, #22]
   12226:	f012 0f04 	tst.w	r2, #4
   1222a:	d005      	beq.n	12238 <SERCOM1_USART_InterruptHandler+0x168>
   1222c:	f013 0f04 	tst.w	r3, #4
   12230:	d002      	beq.n	12238 <SERCOM1_USART_InterruptHandler+0x168>
    while ((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_RXC_Msk) == SERCOM_USART_INT_INTFLAG_RXC_Msk)
   12232:	4d02      	ldr	r5, [pc, #8]	; (1223c <SERCOM1_USART_InterruptHandler+0x16c>)
    tempInIndex = sercom1USARTObj.rdInIndex + 1U;
   12234:	4c02      	ldr	r4, [pc, #8]	; (12240 <SERCOM1_USART_InterruptHandler+0x170>)
   12236:	e7ed      	b.n	12214 <SERCOM1_USART_InterruptHandler+0x144>
        if(testCondition)
        {
            SERCOM1_USART_ISR_RX_Handler();
        }
    }
   12238:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1223a:	bf00      	nop
   1223c:	40003400 	.word	0x40003400
   12240:	2000e9c0 	.word	0x2000e9c0
   12244:	2000b004 	.word	0x2000b004
   12248:	2000a004 	.word	0x2000a004

Disassembly of section .text._TcpCloseSocket%282:

0001224c <_TcpCloseSocket>:
{
   1224c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12250:	4604      	mov	r4, r0
   12252:	460d      	mov	r5, r1
    if(pSkt->Flags.bServer !=  0 && pSkt->flags.forceKill == 0)
   12254:	f890 3036 	ldrb.w	r3, [r0, #54]	; 0x36
   12258:	f013 0f01 	tst.w	r3, #1
   1225c:	d024      	beq.n	122a8 <_TcpCloseSocket+0x5c>
   1225e:	f890 306d 	ldrb.w	r3, [r0, #109]	; 0x6d
   12262:	f013 0f04 	tst.w	r3, #4
   12266:	d13b      	bne.n	122e0 <_TcpCloseSocket+0x94>
        freePkt = (pSkt->flags.openAddType == IP_ADDRESS_TYPE_ANY) ? true : false;
   12268:	f890 306c 	ldrb.w	r3, [r0, #108]	; 0x6c
   1226c:	f013 0f03 	tst.w	r3, #3
   12270:	bf0c      	ite	eq
   12272:	2201      	moveq	r2, #1
   12274:	2200      	movne	r2, #0
        sktIsKilled = false;
   12276:	f04f 0a00 	mov.w	sl, #0
        freePkt = (pSkt->flags.openAddType == IP_ADDRESS_TYPE_ANY) ? true : false;
   1227a:	e017      	b.n	122ac <_TcpCloseSocket+0x60>
            if(freePkt)
   1227c:	b1e2      	cbz	r2, 122b8 <_TcpCloseSocket+0x6c>
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1227e:	2000      	movs	r0, #0
   12280:	f011 fa78 	bl	23774 <OSAL_CRIT_Enter>
   12284:	4601      	mov	r1, r0
    if(pSkt->pV4Pkt != 0)
   12286:	6c66      	ldr	r6, [r4, #68]	; 0x44
   12288:	2e00      	cmp	r6, #0
   1228a:	f000 808f 	beq.w	123ac <_TcpCloseSocket+0x160>
        if((pSkt->pV4Pkt->macPkt.pktFlags & TCPIP_MAC_PKT_FLAG_QUEUED) == 0)
   1228e:	8c73      	ldrh	r3, [r6, #34]	; 0x22
   12290:	f013 0f08 	tst.w	r3, #8
   12294:	f040 808e 	bne.w	123b4 <_TcpCloseSocket+0x168>
        pSkt->pTxPkt = 0;
   12298:	2000      	movs	r0, #0
   1229a:	6460      	str	r0, [r4, #68]	; 0x44
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   1229c:	f011 fba4 	bl	239e8 <OSAL_CRIT_Leave>
                    TCPIP_PKT_PacketFree(pFreePkt);
   122a0:	4630      	mov	r0, r6
   122a2:	f00d ff65 	bl	20170 <_TCPIP_PKT_PacketFree>
   122a6:	e007      	b.n	122b8 <_TcpCloseSocket+0x6c>
        freePkt = true;
   122a8:	2201      	movs	r2, #1
        sktIsKilled = true;
   122aa:	4692      	mov	sl, r2
    while(pSkt->pTxPkt != NULL)
   122ac:	6c63      	ldr	r3, [r4, #68]	; 0x44
   122ae:	b11b      	cbz	r3, 122b8 <_TcpCloseSocket+0x6c>
        if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   122b0:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
   122b4:	2b01      	cmp	r3, #1
   122b6:	d0e1      	beq.n	1227c <_TcpCloseSocket+0x30>
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   122b8:	2000      	movs	r0, #0
   122ba:	f011 fa5b 	bl	23774 <OSAL_CRIT_Enter>
    *pSigHandler = pSkt->sigHandler;
   122be:	6f67      	ldr	r7, [r4, #116]	; 0x74
    *pSigParam = pSkt->sigParam;
   122c0:	f8d4 9078 	ldr.w	r9, [r4, #120]	; 0x78
    uint16_t sigMask = pSkt->sigMask;
   122c4:	f8b4 6072 	ldrh.w	r6, [r4, #114]	; 0x72
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   122c8:	4601      	mov	r1, r0
   122ca:	2000      	movs	r0, #0
   122cc:	f011 fb8c 	bl	239e8 <OSAL_CRIT_Leave>
    if((tcpEvent &= sigMask))
   122d0:	4035      	ands	r5, r6
   122d2:	d008      	beq.n	122e6 <_TcpCloseSocket+0x9a>
        if(sigHandler != 0)
   122d4:	b1bf      	cbz	r7, 12306 <_TcpCloseSocket+0xba>
            sktIx = pSkt->sktIx;
   122d6:	f9b4 6034 	ldrsh.w	r6, [r4, #52]	; 0x34
            pSktNet = pSkt->pSktNet;
   122da:	f8d4 8040 	ldr.w	r8, [r4, #64]	; 0x40
   122de:	e004      	b.n	122ea <_TcpCloseSocket+0x9e>
        freePkt = true;
   122e0:	2201      	movs	r2, #1
        sktIsKilled = true;
   122e2:	4692      	mov	sl, r2
   122e4:	e7e2      	b.n	122ac <_TcpCloseSocket+0x60>
    TCP_SOCKET   sktIx = 0; 
   122e6:	2600      	movs	r6, #0
    TCPIP_NET_HANDLE pSktNet = 0;
   122e8:	46b0      	mov	r8, r6
    if(sktIsKilled)
   122ea:	f1ba 0f00 	cmp.w	sl, #0
   122ee:	d00e      	beq.n	1230e <_TcpCloseSocket+0xc2>
        _TcpSocketKill(pSkt);
   122f0:	4620      	mov	r0, r4
   122f2:	f00c fa4d 	bl	1e790 <_TcpSocketKill>
    if(tcpEvent)
   122f6:	b125      	cbz	r5, 12302 <_TcpCloseSocket+0xb6>
        (*sigHandler)(sktIx, pSktNet, tcpEvent, sigParam);
   122f8:	464b      	mov	r3, r9
   122fa:	462a      	mov	r2, r5
   122fc:	4641      	mov	r1, r8
   122fe:	4630      	mov	r0, r6
   12300:	47b8      	blx	r7
}
   12302:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    TCP_SOCKET   sktIx = 0; 
   12306:	2600      	movs	r6, #0
    TCPIP_NET_HANDLE pSktNet = 0;
   12308:	46b0      	mov	r8, r6
            tcpEvent = 0;
   1230a:	4635      	mov	r5, r6
   1230c:	e7ed      	b.n	122ea <_TcpCloseSocket+0x9e>
	pSkt->remoteHash = pSkt->localPort;
   1230e:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
   12312:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
	pSkt->txHead = pSkt->txStart;
   12316:	6823      	ldr	r3, [r4, #0]
   12318:	60a3      	str	r3, [r4, #8]
	pSkt->txTail = pSkt->txStart;
   1231a:	60e3      	str	r3, [r4, #12]
	pSkt->txUnackedTail = pSkt->txStart;
   1231c:	6123      	str	r3, [r4, #16]
	pSkt->rxHead = pSkt->rxStart;
   1231e:	6963      	ldr	r3, [r4, #20]
   12320:	61e3      	str	r3, [r4, #28]
	pSkt->rxTail = pSkt->rxStart;
   12322:	6223      	str	r3, [r4, #32]
	pSkt->Flags.bTimerEnabled = 0;
   12324:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
	pSkt->Flags.bTXASAPWithoutTimerReset = 0;
   12328:	f003 0381 	and.w	r3, r3, #129	; 0x81
   1232c:	f36f 13c7 	bfc	r3, #7, #1
   12330:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
	pSkt->Flags.bTXFIN = 0;
   12334:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
	pSkt->Flags.bSocketReset = 1;
   12338:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	pSkt->Flags.bRxFin = 0;
   1233c:	f043 0302 	orr.w	r3, r3, #2
   12340:	f36f 0382 	bfc	r3, #2, #1
   12344:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37
	pSkt->flags.bFINSent = 0;
   12348:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
    pSkt->flags.seqInc = 0;
   1234c:	f894 206d 	ldrb.w	r2, [r4, #109]	; 0x6d
   12350:	f36f 0241 	bfc	r2, #1, #1
   12354:	f884 206d 	strb.w	r2, [r4, #109]	; 0x6d
	pSkt->flags.bRXNoneACKed2 = 0;
   12358:	f003 03e3 	and.w	r3, r3, #227	; 0xe3
   1235c:	f36f 1345 	bfc	r3, #5, #1
   12360:	f884 306c 	strb.w	r3, [r4, #108]	; 0x6c
    pSkt->MySEQ = 0;
   12364:	2100      	movs	r1, #0
   12366:	64e1      	str	r1, [r4, #76]	; 0x4c
	pSkt->sHoleSize = -1;
   12368:	f04f 30ff 	mov.w	r0, #4294967295
   1236c:	6560      	str	r0, [r4, #84]	; 0x54
	pSkt->remoteWindow = 1;
   1236e:	2001      	movs	r0, #1
   12370:	f8a4 005c 	strh.w	r0, [r4, #92]	; 0x5c
    pSkt->maxRemoteWindow = 1;
   12374:	f8a4 0066 	strh.w	r0, [r4, #102]	; 0x66
    pSkt->remotePort = 0;
   12378:	f8a4 1058 	strh.w	r1, [r4, #88]	; 0x58
    pSkt->destAddress.Val = 0;
   1237c:	63a1      	str	r1, [r4, #56]	; 0x38
	pSkt->keepAliveCount = 0;
   1237e:	f884 1071 	strb.w	r1, [r4, #113]	; 0x71
    pSkt->addType = (IP_ADDRESS_TYPE)pSkt->flags.openAddType;
   12382:	f003 0303 	and.w	r3, r3, #3
   12386:	f884 306f 	strb.w	r3, [r4, #111]	; 0x6f
    if(pSkt->flags.openBindIf == 0)
   1238a:	b2d2      	uxtb	r2, r2
   1238c:	f012 0f20 	tst.w	r2, #32
        pSkt->pSktNet = 0;
   12390:	bf04      	itt	eq
   12392:	460b      	moveq	r3, r1
   12394:	6421      	streq	r1, [r4, #64]	; 0x40
    if(pSkt->flags.openBindAdd == 0)
   12396:	f012 0f40 	tst.w	r2, #64	; 0x40
        pSkt->srcAddress.Val = 0;
   1239a:	bf04      	itt	eq
   1239c:	2300      	moveq	r3, #0
   1239e:	63e3      	streq	r3, [r4, #60]	; 0x3c
    pSkt->dbgFlags.val = 0;
   123a0:	2300      	movs	r3, #0
   123a2:	f884 307d 	strb.w	r3, [r4, #125]	; 0x7d
    pSkt->smState = newState;
   123a6:	f884 306e 	strb.w	r3, [r4, #110]	; 0x6e
   123aa:	e7a4      	b.n	122f6 <_TcpCloseSocket+0xaa>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   123ac:	2000      	movs	r0, #0
   123ae:	f011 fb1b 	bl	239e8 <OSAL_CRIT_Leave>
                if(pFreePkt)
   123b2:	e781      	b.n	122b8 <_TcpCloseSocket+0x6c>
        pSkt->pTxPkt = 0;
   123b4:	2000      	movs	r0, #0
   123b6:	6460      	str	r0, [r4, #68]	; 0x44
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   123b8:	f011 fb16 	bl	239e8 <OSAL_CRIT_Leave>
                if(pFreePkt)
   123bc:	e77c      	b.n	122b8 <_TcpCloseSocket+0x6c>

Disassembly of section .text.TCPIP_TCP_ArrayPut%283:

000123c0 <TCPIP_TCP_ArrayPut>:
{
   123c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    if(len == 0 || data == 0 || (pSkt = _TcpSocketChk(hTCP)) == 0)
   123c4:	2a00      	cmp	r2, #0
   123c6:	f000 809e 	beq.w	12506 <TCPIP_TCP_ArrayPut+0x146>
   123ca:	460f      	mov	r7, r1
   123cc:	4615      	mov	r5, r2
   123ce:	2900      	cmp	r1, #0
   123d0:	f000 809d 	beq.w	1250e <TCPIP_TCP_ArrayPut+0x14e>
   123d4:	f00f fda2 	bl	21f1c <_TcpSocketChk>
   123d8:	4604      	mov	r4, r0
   123da:	2800      	cmp	r0, #0
   123dc:	f000 8099 	beq.w	12512 <TCPIP_TCP_ArrayPut+0x152>
    if(pSkt->pTxPkt == 0)
   123e0:	6c43      	ldr	r3, [r0, #68]	; 0x44
   123e2:	2b00      	cmp	r3, #0
   123e4:	f000 8097 	beq.w	12516 <TCPIP_TCP_ArrayPut+0x156>
    return _TCPSocketTxFreeSize(pSkt);
   123e8:	f00e fed0 	bl	2118c <_TCPSocketTxFreeSize>
	if(wFreeTxSpace == 0)
   123ec:	4606      	mov	r6, r0
   123ee:	2800      	cmp	r0, #0
   123f0:	f000 8093 	beq.w	1251a <TCPIP_TCP_ArrayPut+0x15a>
    wActualLen = len >= wFreeTxSpace ? wFreeTxSpace : len;
   123f4:	4285      	cmp	r5, r0
   123f6:	bf28      	it	cs
   123f8:	4605      	movcs	r5, r0
   123fa:	b2ad      	uxth	r5, r5
	if(pSkt->txHead + wActualLen >= pSkt->txEnd)
   123fc:	68a0      	ldr	r0, [r4, #8]
   123fe:	6863      	ldr	r3, [r4, #4]
   12400:	1942      	adds	r2, r0, r5
   12402:	4293      	cmp	r3, r2
   12404:	d930      	bls.n	12468 <TCPIP_TCP_ArrayPut+0xa8>
    wActualLen = len >= wFreeTxSpace ? wFreeTxSpace : len;
   12406:	46a8      	mov	r8, r5
	uint16_t wRightLen = 0;
   12408:	f04f 0900 	mov.w	r9, #0
    memcpy((uint8_t*)pSkt->txHead, data, wActualLen);
   1240c:	4642      	mov	r2, r8
   1240e:	4639      	mov	r1, r7
   12410:	68a0      	ldr	r0, [r4, #8]
   12412:	f010 ff6b 	bl	232ec <memcpy>
	pSkt->txHead += wActualLen;
   12416:	68a3      	ldr	r3, [r4, #8]
   12418:	4443      	add	r3, r8
   1241a:	60a3      	str	r3, [r4, #8]
    if(pSkt->txHead != pSkt->txUnackedTail)
   1241c:	6922      	ldr	r2, [r4, #16]
   1241e:	4293      	cmp	r3, r2
   12420:	d019      	beq.n	12456 <TCPIP_TCP_ArrayPut+0x96>
        if(pSkt->flags.halfThresFlush != 0)
   12422:	f894 706d 	ldrb.w	r7, [r4, #109]	; 0x6d
   12426:	f017 0f80 	tst.w	r7, #128	; 0x80
   1242a:	d12d      	bne.n	12488 <TCPIP_TCP_ArrayPut+0xc8>
        if(pSkt->txHead > pSkt->txUnackedTail)
   1242c:	4293      	cmp	r3, r2
   1242e:	d942      	bls.n	124b6 <TCPIP_TCP_ArrayPut+0xf6>
            toSendData = pSkt->txHead - pSkt->txUnackedTail;
   12430:	1a9b      	subs	r3, r3, r2
   12432:	b29b      	uxth	r3, r3
        if(toSendData > pSkt->remoteWindow)
   12434:	f8b4 005c 	ldrh.w	r0, [r4, #92]	; 0x5c
   12438:	4601      	mov	r1, r0
   1243a:	4298      	cmp	r0, r3
   1243c:	bf28      	it	cs
   1243e:	4619      	movcs	r1, r3
        if(canSend >= pSkt->wRemoteMSS || canSend >= (pSkt->maxRemoteWindow >> 1))
   12440:	f8b4 5062 	ldrh.w	r5, [r4, #98]	; 0x62
   12444:	428d      	cmp	r5, r1
   12446:	d947      	bls.n	124d8 <TCPIP_TCP_ArrayPut+0x118>
   12448:	f8b4 5066 	ldrh.w	r5, [r4, #102]	; 0x66
   1244c:	ebb1 0f55 	cmp.w	r1, r5, lsr #1
   12450:	d242      	bcs.n	124d8 <TCPIP_TCP_ArrayPut+0x118>
        if(canSend == toSendData)
   12452:	4298      	cmp	r0, r3
   12454:	d236      	bcs.n	124c4 <TCPIP_TCP_ArrayPut+0x104>
	else if(!pSkt->Flags.bTimer2Enabled)
   12456:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
   1245a:	f013 0f04 	tst.w	r3, #4
   1245e:	d03f      	beq.n	124e0 <TCPIP_TCP_ArrayPut+0x120>
	return wActualLen + wRightLen;
   12460:	eb08 0609 	add.w	r6, r8, r9
   12464:	b2b6      	uxth	r6, r6
   12466:	e04f      	b.n	12508 <TCPIP_TCP_ArrayPut+0x148>
		wRightLen = pSkt->txEnd-pSkt->txHead;
   12468:	eba3 0900 	sub.w	r9, r3, r0
   1246c:	fa1f f989 	uxth.w	r9, r9
        memcpy((uint8_t*)pSkt->txHead, data, wRightLen);
   12470:	464a      	mov	r2, r9
   12472:	4639      	mov	r1, r7
   12474:	f010 ff3a 	bl	232ec <memcpy>
		data += wRightLen;
   12478:	444f      	add	r7, r9
		wActualLen -= wRightLen;
   1247a:	eba5 0809 	sub.w	r8, r5, r9
   1247e:	fa1f f888 	uxth.w	r8, r8
		pSkt->txHead = pSkt->txStart;
   12482:	6823      	ldr	r3, [r4, #0]
   12484:	60a3      	str	r3, [r4, #8]
   12486:	e7c1      	b.n	1240c <TCPIP_TCP_ArrayPut+0x4c>
            if(pSkt->Flags.bHalfFullFlush == 0 && wFreeTxSpace <=  ((pSkt->txEnd - pSkt->txStart) >> 1) )
   12488:	f894 1036 	ldrb.w	r1, [r4, #54]	; 0x36
   1248c:	f011 0f20 	tst.w	r1, #32
   12490:	d1cc      	bne.n	1242c <TCPIP_TCP_ArrayPut+0x6c>
    wFreeTxSpace -= wActualLen; // new free space
   12492:	1b75      	subs	r5, r6, r5
            if(pSkt->Flags.bHalfFullFlush == 0 && wFreeTxSpace <=  ((pSkt->txEnd - pSkt->txStart) >> 1) )
   12494:	b2ad      	uxth	r5, r5
   12496:	6861      	ldr	r1, [r4, #4]
   12498:	6820      	ldr	r0, [r4, #0]
   1249a:	1a09      	subs	r1, r1, r0
        if(toFlush == false)
   1249c:	ebb5 0f61 	cmp.w	r5, r1, asr #1
   124a0:	dcc4      	bgt.n	1242c <TCPIP_TCP_ArrayPut+0x6c>
        _TcpFlush(pSkt);
   124a2:	4620      	mov	r0, r4
   124a4:	f00f fd4e 	bl	21f44 <_TcpFlush>
            pSkt->Flags.bHalfFullFlush = true;
   124a8:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
   124ac:	f043 0320 	orr.w	r3, r3, #32
   124b0:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
   124b4:	e7d4      	b.n	12460 <TCPIP_TCP_ArrayPut+0xa0>
            toSendData = (pSkt->txEnd - pSkt->txUnackedTail) + (pSkt->txHead - pSkt->txStart);
   124b6:	6861      	ldr	r1, [r4, #4]
   124b8:	1a89      	subs	r1, r1, r2
   124ba:	6820      	ldr	r0, [r4, #0]
   124bc:	1a1b      	subs	r3, r3, r0
   124be:	440b      	add	r3, r1
   124c0:	b29b      	uxth	r3, r3
   124c2:	e7b7      	b.n	12434 <TCPIP_TCP_ArrayPut+0x74>
            if(pSkt->flags.forceFlush || (pSkt->Flags.delayAckSend == 0 && pSkt->txTail == pSkt->txUnackedTail))
   124c4:	f017 0f08 	tst.w	r7, #8
   124c8:	d106      	bne.n	124d8 <TCPIP_TCP_ArrayPut+0x118>
   124ca:	f994 3037 	ldrsb.w	r3, [r4, #55]	; 0x37
   124ce:	2b00      	cmp	r3, #0
   124d0:	dbc1      	blt.n	12456 <TCPIP_TCP_ArrayPut+0x96>
   124d2:	68e3      	ldr	r3, [r4, #12]
   124d4:	429a      	cmp	r2, r3
   124d6:	d1be      	bne.n	12456 <TCPIP_TCP_ArrayPut+0x96>
        _TcpFlush(pSkt);
   124d8:	4620      	mov	r0, r4
   124da:	f00f fd33 	bl	21f44 <_TcpFlush>
        if(toSetFlag)
   124de:	e7bf      	b.n	12460 <TCPIP_TCP_ArrayPut+0xa0>
		pSkt->Flags.bTimer2Enabled = true;
   124e0:	f043 0304 	orr.w	r3, r3, #4
   124e4:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
		pSkt->eventTime2 = SYS_TMR_TickCountGet() + (TCPIP_TCP_AUTO_TRANSMIT_TIMEOUT_VAL * SYS_TMR_TickCounterFrequencyGet())/1000;
   124e8:	f00f fea8 	bl	2223c <SYS_TMR_TickCountGet>
   124ec:	4605      	mov	r5, r0
   124ee:	f00f fecd 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
   124f2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   124f6:	00c0      	lsls	r0, r0, #3
   124f8:	4b0c      	ldr	r3, [pc, #48]	; (1252c <TCPIP_TCP_ArrayPut+0x16c>)
   124fa:	fba3 3000 	umull	r3, r0, r3, r0
   124fe:	eb05 1090 	add.w	r0, r5, r0, lsr #6
   12502:	62a0      	str	r0, [r4, #40]	; 0x28
   12504:	e7ac      	b.n	12460 <TCPIP_TCP_ArrayPut+0xa0>
        return 0;
   12506:	4616      	mov	r6, r2
}
   12508:	4630      	mov	r0, r6
   1250a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return 0;
   1250e:	2600      	movs	r6, #0
   12510:	e7fa      	b.n	12508 <TCPIP_TCP_ArrayPut+0x148>
   12512:	2600      	movs	r6, #0
   12514:	e7f8      	b.n	12508 <TCPIP_TCP_ArrayPut+0x148>
        return 0;
   12516:	2600      	movs	r6, #0
   12518:	e7f6      	b.n	12508 <TCPIP_TCP_ArrayPut+0x148>
    switch(pSkt->addType)
   1251a:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
   1251e:	2b01      	cmp	r3, #1
   12520:	d1f2      	bne.n	12508 <TCPIP_TCP_ArrayPut+0x148>
            _TcpFlush(pSkt);
   12522:	4620      	mov	r0, r4
   12524:	f00f fd0e 	bl	21f44 <_TcpFlush>
   12528:	e7ee      	b.n	12508 <TCPIP_TCP_ArrayPut+0x148>
   1252a:	bf00      	nop
   1252c:	10624dd3 	.word	0x10624dd3

Disassembly of section .text.SERCOM0_SPI_InterruptHandler%284:

00012530 <SERCOM0_SPI_InterruptHandler>:
{
    uint32_t dataBits = 0U;
    uint32_t receivedData = 0U;
    static bool isLastByteTransferInProgress = false;

    if(SERCOM0_REGS->SPIM.SERCOM_INTENSET != 0U)
   12530:	4b58      	ldr	r3, [pc, #352]	; (12694 <SERCOM0_SPI_InterruptHandler+0x164>)
   12532:	7d9b      	ldrb	r3, [r3, #22]
   12534:	2b00      	cmp	r3, #0
   12536:	f000 80ab 	beq.w	12690 <SERCOM0_SPI_InterruptHandler+0x160>
{
   1253a:	b510      	push	{r4, lr}
    {
        dataBits = SERCOM0_REGS->SPIM.SERCOM_CTRLB & SERCOM_SPIM_CTRLB_CHSIZE_Msk;
   1253c:	4a55      	ldr	r2, [pc, #340]	; (12694 <SERCOM0_SPI_InterruptHandler+0x164>)
   1253e:	6853      	ldr	r3, [r2, #4]
   12540:	f003 0307 	and.w	r3, r3, #7

        if((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_RXC_Msk) == SERCOM_SPIM_INTFLAG_RXC_Msk)
   12544:	7e12      	ldrb	r2, [r2, #24]
   12546:	f012 0f04 	tst.w	r2, #4
   1254a:	d05b      	beq.n	12604 <SERCOM0_SPI_InterruptHandler+0xd4>
        {
            receivedData =  SERCOM0_REGS->SPIM.SERCOM_DATA;
   1254c:	4a51      	ldr	r2, [pc, #324]	; (12694 <SERCOM0_SPI_InterruptHandler+0x164>)
   1254e:	6a90      	ldr	r0, [r2, #40]	; 0x28

            if(sercom0SPIObj.rxCount < sercom0SPIObj.rxSize)
   12550:	4a51      	ldr	r2, [pc, #324]	; (12698 <SERCOM0_SPI_InterruptHandler+0x168>)
   12552:	6951      	ldr	r1, [r2, #20]
   12554:	68d2      	ldr	r2, [r2, #12]
   12556:	4291      	cmp	r1, r2
   12558:	d254      	bcs.n	12604 <SERCOM0_SPI_InterruptHandler+0xd4>
            {
                if(dataBits == (uint32_t)SPI_DATA_BITS_8)
   1255a:	2b00      	cmp	r3, #0
   1255c:	d143      	bne.n	125e6 <SERCOM0_SPI_InterruptHandler+0xb6>
                {
                    ((uint8_t*)sercom0SPIObj.rxBuffer)[sercom0SPIObj.rxCount++] = (uint8_t)receivedData;
   1255e:	4b4e      	ldr	r3, [pc, #312]	; (12698 <SERCOM0_SPI_InterruptHandler+0x168>)
   12560:	685a      	ldr	r2, [r3, #4]
   12562:	1c4c      	adds	r4, r1, #1
   12564:	615c      	str	r4, [r3, #20]
   12566:	5450      	strb	r0, [r2, r1]
                }
            }
        }

        /* If there are more words to be transmitted, then transmit them here and keep track of the count */
        if((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_DRE_Msk) == SERCOM_SPIM_INTFLAG_DRE_Msk)
   12568:	4b4a      	ldr	r3, [pc, #296]	; (12694 <SERCOM0_SPI_InterruptHandler+0x164>)
   1256a:	7e1b      	ldrb	r3, [r3, #24]
   1256c:	f013 0f01 	tst.w	r3, #1
   12570:	d018      	beq.n	125a4 <SERCOM0_SPI_InterruptHandler+0x74>
        {
            /* Disable the DRE interrupt. This will be enabled back if more than
             * one byte is pending to be transmitted */
            SERCOM0_REGS->SPIM.SERCOM_INTENCLR = (uint8_t)SERCOM_SPIM_INTENCLR_DRE_Msk;
   12572:	4b48      	ldr	r3, [pc, #288]	; (12694 <SERCOM0_SPI_InterruptHandler+0x164>)
   12574:	2201      	movs	r2, #1
   12576:	751a      	strb	r2, [r3, #20]

            if(dataBits == (uint32_t)SPI_DATA_BITS_8)
            {
                if(sercom0SPIObj.txCount < sercom0SPIObj.txSize)
   12578:	4b47      	ldr	r3, [pc, #284]	; (12698 <SERCOM0_SPI_InterruptHandler+0x168>)
   1257a:	699a      	ldr	r2, [r3, #24]
   1257c:	689b      	ldr	r3, [r3, #8]
   1257e:	429a      	cmp	r2, r3
   12580:	d258      	bcs.n	12634 <SERCOM0_SPI_InterruptHandler+0x104>
                {
                    SERCOM0_REGS->SPIM.SERCOM_DATA = ((uint8_t*)sercom0SPIObj.txBuffer)[sercom0SPIObj.txCount++];
   12582:	4b45      	ldr	r3, [pc, #276]	; (12698 <SERCOM0_SPI_InterruptHandler+0x168>)
   12584:	6819      	ldr	r1, [r3, #0]
   12586:	1c50      	adds	r0, r2, #1
   12588:	6198      	str	r0, [r3, #24]
   1258a:	5c8a      	ldrb	r2, [r1, r2]
   1258c:	4b41      	ldr	r3, [pc, #260]	; (12694 <SERCOM0_SPI_InterruptHandler+0x164>)
   1258e:	629a      	str	r2, [r3, #40]	; 0x28
                {
                    /* Do nothing */
                }
            }

            if((sercom0SPIObj.txCount == sercom0SPIObj.txSize) && (sercom0SPIObj.dummySize == 0U))
   12590:	4b41      	ldr	r3, [pc, #260]	; (12698 <SERCOM0_SPI_InterruptHandler+0x168>)
   12592:	699a      	ldr	r2, [r3, #24]
   12594:	689b      	ldr	r3, [r3, #8]
   12596:	429a      	cmp	r2, r3
   12598:	d061      	beq.n	1265e <SERCOM0_SPI_InterruptHandler+0x12e>
                 * the TXC interrupt is not enabled until the very end.
                 */

                isLastByteTransferInProgress = true;
            }
            else if(sercom0SPIObj.rxCount == sercom0SPIObj.rxSize)
   1259a:	4b3f      	ldr	r3, [pc, #252]	; (12698 <SERCOM0_SPI_InterruptHandler+0x168>)
   1259c:	695a      	ldr	r2, [r3, #20]
   1259e:	68db      	ldr	r3, [r3, #12]
   125a0:	429a      	cmp	r2, r3
   125a2:	d069      	beq.n	12678 <SERCOM0_SPI_InterruptHandler+0x148>
            {
                /* Do nothing */
            }
        }

        if(((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_TXC_Msk) == SERCOM_SPIM_INTFLAG_TXC_Msk) && (isLastByteTransferInProgress == true))
   125a4:	4b3b      	ldr	r3, [pc, #236]	; (12694 <SERCOM0_SPI_InterruptHandler+0x164>)
   125a6:	7e1b      	ldrb	r3, [r3, #24]
   125a8:	f013 0f02 	tst.w	r3, #2
   125ac:	d014      	beq.n	125d8 <SERCOM0_SPI_InterruptHandler+0xa8>
   125ae:	4b3b      	ldr	r3, [pc, #236]	; (1269c <SERCOM0_SPI_InterruptHandler+0x16c>)
   125b0:	781b      	ldrb	r3, [r3, #0]
   125b2:	b1bb      	cbz	r3, 125e4 <SERCOM0_SPI_InterruptHandler+0xb4>
        {
            if(sercom0SPIObj.rxCount == sercom0SPIObj.rxSize)
   125b4:	4b38      	ldr	r3, [pc, #224]	; (12698 <SERCOM0_SPI_InterruptHandler+0x168>)
   125b6:	695a      	ldr	r2, [r3, #20]
   125b8:	68db      	ldr	r3, [r3, #12]
   125ba:	429a      	cmp	r2, r3
   125bc:	d10f      	bne.n	125de <SERCOM0_SPI_InterruptHandler+0xae>
            {
                sercom0SPIObj.transferIsBusy = false;
   125be:	4b36      	ldr	r3, [pc, #216]	; (12698 <SERCOM0_SPI_InterruptHandler+0x168>)
   125c0:	2200      	movs	r2, #0
   125c2:	771a      	strb	r2, [r3, #28]

                /* Disable the Data Register empty and Receive Complete Interrupt flags */
                SERCOM0_REGS->SPIM.SERCOM_INTENCLR = (uint8_t)(SERCOM_SPIM_INTENCLR_DRE_Msk | SERCOM_SPIM_INTENCLR_RXC_Msk | SERCOM_SPIM_INTENSET_TXC_Msk);
   125c4:	4933      	ldr	r1, [pc, #204]	; (12694 <SERCOM0_SPI_InterruptHandler+0x164>)
   125c6:	2007      	movs	r0, #7
   125c8:	7508      	strb	r0, [r1, #20]

                isLastByteTransferInProgress = false;
   125ca:	4934      	ldr	r1, [pc, #208]	; (1269c <SERCOM0_SPI_InterruptHandler+0x16c>)
   125cc:	700a      	strb	r2, [r1, #0]

                if(sercom0SPIObj.callback != NULL)
   125ce:	6a1b      	ldr	r3, [r3, #32]
   125d0:	b143      	cbz	r3, 125e4 <SERCOM0_SPI_InterruptHandler+0xb4>
                {
                    sercom0SPIObj.callback(sercom0SPIObj.context);
   125d2:	4a31      	ldr	r2, [pc, #196]	; (12698 <SERCOM0_SPI_InterruptHandler+0x168>)
   125d4:	6a50      	ldr	r0, [r2, #36]	; 0x24
   125d6:	4798      	blx	r3
                }
            }
        }

        if(isLastByteTransferInProgress == true)
   125d8:	4b30      	ldr	r3, [pc, #192]	; (1269c <SERCOM0_SPI_InterruptHandler+0x16c>)
   125da:	781b      	ldrb	r3, [r3, #0]
   125dc:	b113      	cbz	r3, 125e4 <SERCOM0_SPI_InterruptHandler+0xb4>
        {
            /* For the last byte transfer, the DRE interrupt is already disabled.
             * Enable TXC interrupt to ensure no data is present in the shift
             * register before application callback is called.
             */
            SERCOM0_REGS->SPIM.SERCOM_INTENSET = (uint8_t)SERCOM_SPIM_INTENSET_TXC_Msk;
   125de:	4b2d      	ldr	r3, [pc, #180]	; (12694 <SERCOM0_SPI_InterruptHandler+0x164>)
   125e0:	2202      	movs	r2, #2
   125e2:	759a      	strb	r2, [r3, #22]
        }
    }
}
   125e4:	bd10      	pop	{r4, pc}
                    ((uint16_t*)sercom0SPIObj.rxBuffer)[sercom0SPIObj.rxCount++] = (uint16_t)receivedData;
   125e6:	4b2c      	ldr	r3, [pc, #176]	; (12698 <SERCOM0_SPI_InterruptHandler+0x168>)
   125e8:	685a      	ldr	r2, [r3, #4]
   125ea:	1c4c      	adds	r4, r1, #1
   125ec:	615c      	str	r4, [r3, #20]
   125ee:	f822 0011 	strh.w	r0, [r2, r1, lsl #1]
        if((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_DRE_Msk) == SERCOM_SPIM_INTFLAG_DRE_Msk)
   125f2:	4b28      	ldr	r3, [pc, #160]	; (12694 <SERCOM0_SPI_InterruptHandler+0x164>)
   125f4:	7e1b      	ldrb	r3, [r3, #24]
   125f6:	f013 0f01 	tst.w	r3, #1
   125fa:	d0d3      	beq.n	125a4 <SERCOM0_SPI_InterruptHandler+0x74>
            SERCOM0_REGS->SPIM.SERCOM_INTENCLR = (uint8_t)SERCOM_SPIM_INTENCLR_DRE_Msk;
   125fc:	4b25      	ldr	r3, [pc, #148]	; (12694 <SERCOM0_SPI_InterruptHandler+0x164>)
   125fe:	2201      	movs	r2, #1
   12600:	751a      	strb	r2, [r3, #20]
            if(dataBits == (uint32_t)SPI_DATA_BITS_8)
   12602:	e009      	b.n	12618 <SERCOM0_SPI_InterruptHandler+0xe8>
        if((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_DRE_Msk) == SERCOM_SPIM_INTFLAG_DRE_Msk)
   12604:	4a23      	ldr	r2, [pc, #140]	; (12694 <SERCOM0_SPI_InterruptHandler+0x164>)
   12606:	7e12      	ldrb	r2, [r2, #24]
   12608:	f012 0f01 	tst.w	r2, #1
   1260c:	d0ca      	beq.n	125a4 <SERCOM0_SPI_InterruptHandler+0x74>
            SERCOM0_REGS->SPIM.SERCOM_INTENCLR = (uint8_t)SERCOM_SPIM_INTENCLR_DRE_Msk;
   1260e:	4a21      	ldr	r2, [pc, #132]	; (12694 <SERCOM0_SPI_InterruptHandler+0x164>)
   12610:	2101      	movs	r1, #1
   12612:	7511      	strb	r1, [r2, #20]
            if(dataBits == (uint32_t)SPI_DATA_BITS_8)
   12614:	2b00      	cmp	r3, #0
   12616:	d0af      	beq.n	12578 <SERCOM0_SPI_InterruptHandler+0x48>
                if(sercom0SPIObj.txCount < sercom0SPIObj.txSize)
   12618:	4b1f      	ldr	r3, [pc, #124]	; (12698 <SERCOM0_SPI_InterruptHandler+0x168>)
   1261a:	699a      	ldr	r2, [r3, #24]
   1261c:	689b      	ldr	r3, [r3, #8]
   1261e:	429a      	cmp	r2, r3
   12620:	d212      	bcs.n	12648 <SERCOM0_SPI_InterruptHandler+0x118>
                    SERCOM0_REGS->SPIM.SERCOM_DATA = ((uint16_t*)sercom0SPIObj.txBuffer)[sercom0SPIObj.txCount++];
   12622:	4b1d      	ldr	r3, [pc, #116]	; (12698 <SERCOM0_SPI_InterruptHandler+0x168>)
   12624:	6819      	ldr	r1, [r3, #0]
   12626:	1c50      	adds	r0, r2, #1
   12628:	6198      	str	r0, [r3, #24]
   1262a:	f831 2012 	ldrh.w	r2, [r1, r2, lsl #1]
   1262e:	4b19      	ldr	r3, [pc, #100]	; (12694 <SERCOM0_SPI_InterruptHandler+0x164>)
   12630:	629a      	str	r2, [r3, #40]	; 0x28
   12632:	e7ad      	b.n	12590 <SERCOM0_SPI_InterruptHandler+0x60>
                else if(sercom0SPIObj.dummySize > 0U)
   12634:	4b18      	ldr	r3, [pc, #96]	; (12698 <SERCOM0_SPI_InterruptHandler+0x168>)
   12636:	691b      	ldr	r3, [r3, #16]
   12638:	b323      	cbz	r3, 12684 <SERCOM0_SPI_InterruptHandler+0x154>
                    SERCOM0_REGS->SPIM.SERCOM_DATA = 0xFFU;
   1263a:	4a16      	ldr	r2, [pc, #88]	; (12694 <SERCOM0_SPI_InterruptHandler+0x164>)
   1263c:	21ff      	movs	r1, #255	; 0xff
   1263e:	6291      	str	r1, [r2, #40]	; 0x28
                    sercom0SPIObj.dummySize--;
   12640:	3b01      	subs	r3, #1
   12642:	4a15      	ldr	r2, [pc, #84]	; (12698 <SERCOM0_SPI_InterruptHandler+0x168>)
   12644:	6113      	str	r3, [r2, #16]
   12646:	e7a3      	b.n	12590 <SERCOM0_SPI_InterruptHandler+0x60>
                else if(sercom0SPIObj.dummySize > 0U)
   12648:	4b13      	ldr	r3, [pc, #76]	; (12698 <SERCOM0_SPI_InterruptHandler+0x168>)
   1264a:	691b      	ldr	r3, [r3, #16]
   1264c:	b1d3      	cbz	r3, 12684 <SERCOM0_SPI_InterruptHandler+0x154>
                    SERCOM0_REGS->SPIM.SERCOM_DATA = 0xFFFFU;
   1264e:	4a11      	ldr	r2, [pc, #68]	; (12694 <SERCOM0_SPI_InterruptHandler+0x164>)
   12650:	f64f 71ff 	movw	r1, #65535	; 0xffff
   12654:	6291      	str	r1, [r2, #40]	; 0x28
                    sercom0SPIObj.dummySize--;
   12656:	3b01      	subs	r3, #1
   12658:	4a0f      	ldr	r2, [pc, #60]	; (12698 <SERCOM0_SPI_InterruptHandler+0x168>)
   1265a:	6113      	str	r3, [r2, #16]
   1265c:	e798      	b.n	12590 <SERCOM0_SPI_InterruptHandler+0x60>
            if((sercom0SPIObj.txCount == sercom0SPIObj.txSize) && (sercom0SPIObj.dummySize == 0U))
   1265e:	4b0e      	ldr	r3, [pc, #56]	; (12698 <SERCOM0_SPI_InterruptHandler+0x168>)
   12660:	691b      	ldr	r3, [r3, #16]
   12662:	2b00      	cmp	r3, #0
   12664:	d199      	bne.n	1259a <SERCOM0_SPI_InterruptHandler+0x6a>
                isLastByteTransferInProgress = true;
   12666:	4b0d      	ldr	r3, [pc, #52]	; (1269c <SERCOM0_SPI_InterruptHandler+0x16c>)
   12668:	2201      	movs	r2, #1
   1266a:	701a      	strb	r2, [r3, #0]
        if(((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_TXC_Msk) == SERCOM_SPIM_INTFLAG_TXC_Msk) && (isLastByteTransferInProgress == true))
   1266c:	4b09      	ldr	r3, [pc, #36]	; (12694 <SERCOM0_SPI_InterruptHandler+0x164>)
   1266e:	7e1b      	ldrb	r3, [r3, #24]
   12670:	f013 0f02 	tst.w	r3, #2
   12674:	d19e      	bne.n	125b4 <SERCOM0_SPI_InterruptHandler+0x84>
   12676:	e7b2      	b.n	125de <SERCOM0_SPI_InterruptHandler+0xae>
                SERCOM0_REGS->SPIM.SERCOM_INTENSET = (uint8_t)SERCOM_SPIM_INTENSET_DRE_Msk;
   12678:	4b06      	ldr	r3, [pc, #24]	; (12694 <SERCOM0_SPI_InterruptHandler+0x164>)
   1267a:	2201      	movs	r2, #1
   1267c:	759a      	strb	r2, [r3, #22]
                SERCOM0_REGS->SPIM.SERCOM_INTENCLR = (uint8_t)SERCOM_SPIM_INTENCLR_RXC_Msk;
   1267e:	2204      	movs	r2, #4
   12680:	751a      	strb	r2, [r3, #20]
   12682:	e78f      	b.n	125a4 <SERCOM0_SPI_InterruptHandler+0x74>
            if((sercom0SPIObj.txCount == sercom0SPIObj.txSize) && (sercom0SPIObj.dummySize == 0U))
   12684:	4b04      	ldr	r3, [pc, #16]	; (12698 <SERCOM0_SPI_InterruptHandler+0x168>)
   12686:	699a      	ldr	r2, [r3, #24]
   12688:	689b      	ldr	r3, [r3, #8]
   1268a:	429a      	cmp	r2, r3
   1268c:	d185      	bne.n	1259a <SERCOM0_SPI_InterruptHandler+0x6a>
   1268e:	e7ea      	b.n	12666 <SERCOM0_SPI_InterruptHandler+0x136>
   12690:	4770      	bx	lr
   12692:	bf00      	nop
   12694:	40003000 	.word	0x40003000
   12698:	2000ea6c 	.word	0x2000ea6c
   1269c:	2000ef8f 	.word	0x2000ef8f

Disassembly of section .text._DHCPOptionHostName%285:

000126a0 <_DHCPOptionHostName>:
{
   126a0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   126a4:	b087      	sub	sp, #28
   126a6:	4681      	mov	r9, r0
   126a8:	4688      	mov	r8, r1
    pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   126aa:	4b56      	ldr	r3, [pc, #344]	; (12804 <_DHCPOptionHostName+0x164>)
   126ac:	681c      	ldr	r4, [r3, #0]
   126ae:	f011 fc43 	bl	23f38 <TCPIP_STACK_NetIxGet>
   126b2:	275c      	movs	r7, #92	; 0x5c
   126b4:	fb07 4700 	mla	r7, r7, r0, r4
    if(pClient->nameCallback != 0)
   126b8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   126ba:	b173      	cbz	r3, 126da <_DHCPOptionHostName+0x3a>
        if((cbName = (*pClient->nameCallback)(pNetIf)) != 0)
   126bc:	4648      	mov	r0, r9
   126be:	4798      	blx	r3
   126c0:	4606      	mov	r6, r0
   126c2:	b150      	cbz	r0, 126da <_DHCPOptionHostName+0x3a>
            if(strlen(cbName) >= 2)
   126c4:	f011 fbfc 	bl	23ec0 <strlen>
   126c8:	2801      	cmp	r0, #1
   126ca:	d906      	bls.n	126da <_DHCPOptionHostName+0x3a>
                if(pClient->flags.bWriteBack != 0)
   126cc:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
   126d0:	f013 0f40 	tst.w	r3, #64	; 0x40
   126d4:	d02b      	beq.n	1272e <_DHCPOptionHostName+0x8e>
                    writeBackLen = strlen(cbName) + 1;
   126d6:	1c45      	adds	r5, r0, #1
   126d8:	e004      	b.n	126e4 <_DHCPOptionHostName+0x44>
        srcName = (char*)TCPIP_STACK_NetBIOSName(pNetIf);
   126da:	4648      	mov	r0, r9
   126dc:	f011 fec7 	bl	2446e <TCPIP_STACK_NetBIOSName>
   126e0:	4606      	mov	r6, r0
   126e2:	2500      	movs	r5, #0
    memset(destBuffer, 0x0, destSize);
   126e4:	2300      	movs	r3, #0
   126e6:	9300      	str	r3, [sp, #0]
   126e8:	9301      	str	r3, [sp, #4]
   126ea:	9302      	str	r3, [sp, #8]
   126ec:	9303      	str	r3, [sp, #12]
   126ee:	9304      	str	r3, [sp, #16]
   126f0:	f88d 3014 	strb.w	r3, [sp, #20]
    for(ix = 0; ix < destSize - 1; ix++)
   126f4:	f106 0414 	add.w	r4, r6, #20
    memset(destBuffer, 0x0, destSize);
   126f8:	4632      	mov	r2, r6
    d = destBuffer;
   126fa:	466b      	mov	r3, sp
        if(!isspace(currC))
   126fc:	4842      	ldr	r0, [pc, #264]	; (12808 <_DHCPOptionHostName+0x168>)
        currC = *srcBuffer++;
   126fe:	f812 1b01 	ldrb.w	r1, [r2], #1
        if(!isspace(currC))
   12702:	5c0f      	ldrb	r7, [r1, r0]
   12704:	f017 0f08 	tst.w	r7, #8
            *d++ = currC;
   12708:	bf08      	it	eq
   1270a:	f803 1b01 	strbeq.w	r1, [r3], #1
    for(ix = 0; ix < destSize - 1; ix++)
   1270e:	42a2      	cmp	r2, r4
   12710:	d1f5      	bne.n	126fe <_DHCPOptionHostName+0x5e>
    len = strlen(destBuffer);
   12712:	4668      	mov	r0, sp
   12714:	f011 fbd4 	bl	23ec0 <strlen>
   12718:	4604      	mov	r4, r0
   1271a:	4607      	mov	r7, r0
    if(len)
   1271c:	2800      	cmp	r0, #0
   1271e:	d057      	beq.n	127d0 <_DHCPOptionHostName+0x130>
   12720:	4669      	mov	r1, sp
        for(ix = 0; ix < len; ix++)
   12722:	2200      	movs	r2, #0
            if(currC != '-' && currC != '.' && !isalnum(currC))
   12724:	f8df e0e0 	ldr.w	lr, [pc, #224]	; 12808 <_DHCPOptionHostName+0x168>
                *d = TCPIP_DHCP_HOST_REPLACE_CHAR;
   12728:	f04f 0c78 	mov.w	ip, #120	; 0x78
   1272c:	e004      	b.n	12738 <_DHCPOptionHostName+0x98>
    int     writeBackLen = 0;
   1272e:	2500      	movs	r5, #0
   12730:	e7d8      	b.n	126e4 <_DHCPOptionHostName+0x44>
        for(ix = 0; ix < len; ix++)
   12732:	3201      	adds	r2, #1
   12734:	4297      	cmp	r7, r2
   12736:	dd0e      	ble.n	12756 <_DHCPOptionHostName+0xb6>
            currC = *d;
   12738:	f811 0b01 	ldrb.w	r0, [r1], #1
            if(currC != '-' && currC != '.' && !isalnum(currC))
   1273c:	f1a0 032d 	sub.w	r3, r0, #45	; 0x2d
   12740:	b2db      	uxtb	r3, r3
   12742:	2b01      	cmp	r3, #1
   12744:	d9f5      	bls.n	12732 <_DHCPOptionHostName+0x92>
   12746:	f810 300e 	ldrb.w	r3, [r0, lr]
   1274a:	f013 0f07 	tst.w	r3, #7
                *d = TCPIP_DHCP_HOST_REPLACE_CHAR;
   1274e:	bf08      	it	eq
   12750:	f801 cc01 	strbeq.w	ip, [r1, #-1]
   12754:	e7ed      	b.n	12732 <_DHCPOptionHostName+0x92>
        if(!isalpha(currC))
   12756:	f89d 2000 	ldrb.w	r2, [sp]
   1275a:	4b2b      	ldr	r3, [pc, #172]	; (12808 <_DHCPOptionHostName+0x168>)
   1275c:	5cd3      	ldrb	r3, [r2, r3]
   1275e:	f013 0f03 	tst.w	r3, #3
            destBuffer[0] = TCPIP_DHCP_HOST_REPLACE_CHAR;
   12762:	bf04      	itt	eq
   12764:	2378      	moveq	r3, #120	; 0x78
   12766:	f88d 3000 	strbeq.w	r3, [sp]
        currC = destBuffer[len - 1];
   1276a:	1e63      	subs	r3, r4, #1
        if(!isalnum(currC))
   1276c:	f81d 1003 	ldrb.w	r1, [sp, r3]
   12770:	4a25      	ldr	r2, [pc, #148]	; (12808 <_DHCPOptionHostName+0x168>)
   12772:	5c8a      	ldrb	r2, [r1, r2]
   12774:	f012 0f07 	tst.w	r2, #7
   12778:	d102      	bne.n	12780 <_DHCPOptionHostName+0xe0>
            destBuffer[len - 1] = TCPIP_DHCP_HOST_REPLACE_CHAR;
   1277a:	2278      	movs	r2, #120	; 0x78
   1277c:	f80d 2003 	strb.w	r2, [sp, r3]
    if(writeBackLen)
   12780:	b365      	cbz	r5, 127dc <_DHCPOptionHostName+0x13c>
        srcName[0] = 0;
   12782:	2300      	movs	r3, #0
   12784:	7033      	strb	r3, [r6, #0]
    if(pSendData->writeSpace >= sizeof(*pHost) + hostLen)
   12786:	1ca7      	adds	r7, r4, #2
   12788:	f8d8 3004 	ldr.w	r3, [r8, #4]
   1278c:	42bb      	cmp	r3, r7
    return -1;
   1278e:	bf38      	it	cc
   12790:	f04f 35ff 	movcc.w	r5, #4294967295
    if(pSendData->writeSpace >= sizeof(*pHost) + hostLen)
   12794:	d318      	bcc.n	127c8 <_DHCPOptionHostName+0x128>
        pHost = (TCPIP_DHCP_OPTION_DATA_HOST_NAME*)pSendData->pOpt;
   12796:	f8d8 0000 	ldr.w	r0, [r8]
        pHost->opt = TCPIP_DHCP_HOST_NAME;
   1279a:	230c      	movs	r3, #12
   1279c:	7003      	strb	r3, [r0, #0]
        pHost->len = hostLen;
   1279e:	7044      	strb	r4, [r0, #1]
        memcpy(pHost->hostname, hostName, hostLen);
   127a0:	4622      	mov	r2, r4
   127a2:	4669      	mov	r1, sp
   127a4:	3002      	adds	r0, #2
   127a6:	f010 fda1 	bl	232ec <memcpy>
        if(writeBackLen)
   127aa:	b165      	cbz	r5, 127c6 <_DHCPOptionHostName+0x126>
            if(writeBackLen > hostLen + 1)
   127ac:	3401      	adds	r4, #1
            memcpy(srcName, hostName, writeBackLen);
   127ae:	42a5      	cmp	r5, r4
   127b0:	bfa8      	it	ge
   127b2:	4625      	movge	r5, r4
   127b4:	462a      	mov	r2, r5
   127b6:	4669      	mov	r1, sp
   127b8:	4630      	mov	r0, r6
   127ba:	f010 fd97 	bl	232ec <memcpy>
            srcName[writeBackLen - 1] = 0;
   127be:	4435      	add	r5, r6
   127c0:	2300      	movs	r3, #0
   127c2:	f805 3c01 	strb.w	r3, [r5, #-1]
        return sizeof(*pHost) + hostLen;
   127c6:	463d      	mov	r5, r7
}
   127c8:	4628      	mov	r0, r5
   127ca:	b007      	add	sp, #28
   127cc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if(writeBackLen)
   127d0:	2d00      	cmp	r5, #0
   127d2:	d0f9      	beq.n	127c8 <_DHCPOptionHostName+0x128>
        srcName[0] = 0;
   127d4:	2300      	movs	r3, #0
   127d6:	7033      	strb	r3, [r6, #0]
        return 0;
   127d8:	4605      	mov	r5, r0
   127da:	e7f5      	b.n	127c8 <_DHCPOptionHostName+0x128>
    if(pSendData->writeSpace >= sizeof(*pHost) + hostLen)
   127dc:	1ca7      	adds	r7, r4, #2
   127de:	f8d8 3004 	ldr.w	r3, [r8, #4]
   127e2:	42bb      	cmp	r3, r7
    return -1;
   127e4:	bf38      	it	cc
   127e6:	f04f 35ff 	movcc.w	r5, #4294967295
    if(pSendData->writeSpace >= sizeof(*pHost) + hostLen)
   127ea:	d3ed      	bcc.n	127c8 <_DHCPOptionHostName+0x128>
        pHost = (TCPIP_DHCP_OPTION_DATA_HOST_NAME*)pSendData->pOpt;
   127ec:	f8d8 0000 	ldr.w	r0, [r8]
        pHost->opt = TCPIP_DHCP_HOST_NAME;
   127f0:	230c      	movs	r3, #12
   127f2:	7003      	strb	r3, [r0, #0]
        pHost->len = hostLen;
   127f4:	7044      	strb	r4, [r0, #1]
        memcpy(pHost->hostname, hostName, hostLen);
   127f6:	4622      	mov	r2, r4
   127f8:	4669      	mov	r1, sp
   127fa:	3002      	adds	r0, #2
   127fc:	f010 fd76 	bl	232ec <memcpy>
        if(writeBackLen)
   12800:	e7e1      	b.n	127c6 <_DHCPOptionHostName+0x126>
   12802:	bf00      	nop
   12804:	2000ee3c 	.word	0x2000ee3c
   12808:	00015855 	.word	0x00015855

Disassembly of section .text.DRV_PIC32CGMAC_LibTxAckPacket%286:

0001280c <DRV_PIC32CGMAC_LibTxAckPacket>:
{
   1280c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12810:	b083      	sub	sp, #12
    DRV_PIC32CGMAC_HW_TXDCPT *pTxDesc = pMACDrv->sGmacData.gmac_queue[queueIdx].pTxDesc;
   12812:	232c      	movs	r3, #44	; 0x2c
   12814:	fb03 0301 	mla	r3, r3, r1, r0
   12818:	f8d3 60a0 	ldr.w	r6, [r3, #160]	; 0xa0
	uint16_t tailIndex = pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail;
   1281c:	f8b3 40b4 	ldrh.w	r4, [r3, #180]	; 0xb4
	uint16_t headIndex = pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescHead;
   12820:	f8b3 80b2 	ldrh.w	r8, [r3, #178]	; 0xb2
    while((tailIndex != headIndex) &&
   12824:	4544      	cmp	r4, r8
   12826:	f000 8096 	beq.w	12956 <DRV_PIC32CGMAC_LibTxAckPacket+0x14a>
          ((pTxDesc[tailIndex].tx_desc_status.val) & GMAC_TX_USED_BIT) &&
   1282a:	00e3      	lsls	r3, r4, #3
   1282c:	18f2      	adds	r2, r6, r3
   1282e:	6855      	ldr	r5, [r2, #4]
    while((tailIndex != headIndex) &&
   12830:	2d00      	cmp	r5, #0
   12832:	f280 8092 	bge.w	1295a <DRV_PIC32CGMAC_LibTxAckPacket+0x14e>
          (pTxDesc[tailIndex].tx_desc_buffaddr != 0))
   12836:	f856 5034 	ldr.w	r5, [r6, r4, lsl #3]
          ((pTxDesc[tailIndex].tx_desc_status.val) & GMAC_TX_USED_BIT) &&
   1283a:	2d00      	cmp	r5, #0
   1283c:	f000 808f 	beq.w	1295e <DRV_PIC32CGMAC_LibTxAckPacket+0x152>
   12840:	468b      	mov	fp, r1
   12842:	4682      	mov	sl, r0
        if(GMAC_TX_ERR_BITS & (pTxDesc[tailIndex].tx_desc_status.val) )
   12844:	6852      	ldr	r2, [r2, #4]
   12846:	f012 5f60 	tst.w	r2, #939524096	; 0x38000000
   1284a:	d10f      	bne.n	1286c <DRV_PIC32CGMAC_LibTxAckPacket+0x60>
        pbuff = (uint8_t*)((uint32_t)pTxDesc[tailIndex].tx_desc_buffaddr & pMACDrv->sGmacData._dataOffsetMask);
   1284c:	58f3      	ldr	r3, [r6, r3]
   1284e:	f8d0 20f0 	ldr.w	r2, [r0, #240]	; 0xf0
   12852:	4013      	ands	r3, r2
        TCPIP_MAC_SEGMENT_GAP_DCPT* pGap = (TCPIP_MAC_SEGMENT_GAP_DCPT*)(pbuff + pMACDrv->sGmacData._dcptOffset);
   12854:	f9b0 20ec 	ldrsh.w	r2, [r0, #236]	; 0xec
        pPkt = pGap->segmentPktPtr;
   12858:	5898      	ldr	r0, [r3, r2]
	DRV_PIC32CGMAC_RESULT res = DRV_PIC32CGMAC_RES_NO_PACKET;
   1285a:	2101      	movs	r1, #1
            pTxDesc[tailIndex].tx_desc_status.val &= GMAC_TX_USED_BIT | GMAC_TX_WRAP_BIT | GMAC_TX_LAST_BUFFER_BIT;
   1285c:	f8df 910c 	ldr.w	r9, [pc, #268]	; 1296c <DRV_PIC32CGMAC_LibTxAckPacket+0x160>
            pTxDesc[tailIndex].tx_desc_buffaddr = 0;
   12860:	2700      	movs	r7, #0
        pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail = tailIndex;
   12862:	232c      	movs	r3, #44	; 0x2c
   12864:	fb03 a30b 	mla	r3, r3, fp, sl
   12868:	9301      	str	r3, [sp, #4]
   1286a:	e03d      	b.n	128e8 <DRV_PIC32CGMAC_LibTxAckPacket+0xdc>
            pMACDrv->sGmacData._txDiscard = true;
   1286c:	2301      	movs	r3, #1
   1286e:	f88a 30f7 	strb.w	r3, [sl, #247]	; 0xf7
            res = DRV_PIC32CGMAC_RES_TX_ERR;
   12872:	f06f 0106 	mvn.w	r1, #6
            break;
   12876:	e06a      	b.n	1294e <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
                pPkt->pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED;
   12878:	8c43      	ldrh	r3, [r0, #34]	; 0x22
   1287a:	f023 0308 	bic.w	r3, r3, #8
   1287e:	8443      	strh	r3, [r0, #34]	; 0x22
                (pMACDrv->sGmacData.pktAckF)(pPkt, TCPIP_MAC_PKT_ACK_TX_OK, TCPIP_THIS_MODULE_ID);				
   12880:	f8da 302c 	ldr.w	r3, [sl, #44]	; 0x2c
   12884:	f241 0250 	movw	r2, #4176	; 0x1050
   12888:	2101      	movs	r1, #1
   1288a:	4798      	blx	r3
                pMACDrv->sGmacData._txStat.nTxOkPackets++;
   1288c:	f8da 307c 	ldr.w	r3, [sl, #124]	; 0x7c
   12890:	3301      	adds	r3, #1
   12892:	f8ca 307c 	str.w	r3, [sl, #124]	; 0x7c
                pTxDesc[tailIndex].tx_desc_status.val &= ~GMAC_TX_LAST_BUFFER_BIT;
   12896:	686b      	ldr	r3, [r5, #4]
   12898:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
   1289c:	606b      	str	r3, [r5, #4]
                GCIRC_INC(tailIndex, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt);   
   1289e:	3401      	adds	r4, #1
   128a0:	b2a4      	uxth	r4, r4
   128a2:	eb0b 03cb 	add.w	r3, fp, fp, lsl #3
   128a6:	eb0a 0343 	add.w	r3, sl, r3, lsl #1
   128aa:	f8b3 30c8 	ldrh.w	r3, [r3, #200]	; 0xc8
   128ae:	42a3      	cmp	r3, r4
   128b0:	bf98      	it	ls
   128b2:	2400      	movls	r4, #0
        pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail = tailIndex;
   128b4:	9b01      	ldr	r3, [sp, #4]
   128b6:	f8a3 40b4 	strh.w	r4, [r3, #180]	; 0xb4
    while((tailIndex != headIndex) &&
   128ba:	4544      	cmp	r4, r8
   128bc:	d051      	beq.n	12962 <DRV_PIC32CGMAC_LibTxAckPacket+0x156>
          ((pTxDesc[tailIndex].tx_desc_status.val) & GMAC_TX_USED_BIT) &&
   128be:	00e2      	lsls	r2, r4, #3
   128c0:	18b3      	adds	r3, r6, r2
   128c2:	6859      	ldr	r1, [r3, #4]
    while((tailIndex != headIndex) &&
   128c4:	2900      	cmp	r1, #0
   128c6:	da4e      	bge.n	12966 <DRV_PIC32CGMAC_LibTxAckPacket+0x15a>
          (pTxDesc[tailIndex].tx_desc_buffaddr != 0))
   128c8:	f856 1034 	ldr.w	r1, [r6, r4, lsl #3]
          ((pTxDesc[tailIndex].tx_desc_status.val) & GMAC_TX_USED_BIT) &&
   128cc:	2900      	cmp	r1, #0
   128ce:	d03e      	beq.n	1294e <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
        if(GMAC_TX_ERR_BITS & (pTxDesc[tailIndex].tx_desc_status.val) )
   128d0:	685b      	ldr	r3, [r3, #4]
   128d2:	f013 5f60 	tst.w	r3, #939524096	; 0x38000000
   128d6:	d1c9      	bne.n	1286c <DRV_PIC32CGMAC_LibTxAckPacket+0x60>
        pbuff = (uint8_t*)((uint32_t)pTxDesc[tailIndex].tx_desc_buffaddr & pMACDrv->sGmacData._dataOffsetMask);
   128d8:	58b3      	ldr	r3, [r6, r2]
   128da:	f8da 20f0 	ldr.w	r2, [sl, #240]	; 0xf0
   128de:	4013      	ands	r3, r2
        TCPIP_MAC_SEGMENT_GAP_DCPT* pGap = (TCPIP_MAC_SEGMENT_GAP_DCPT*)(pbuff + pMACDrv->sGmacData._dcptOffset);
   128e0:	f9ba 20ec 	ldrsh.w	r2, [sl, #236]	; 0xec
        pPkt = pGap->segmentPktPtr;
   128e4:	5898      	ldr	r0, [r3, r2]
            GCIRC_INC(tailIndex, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt);  
   128e6:	4639      	mov	r1, r7
            pTxDesc[tailIndex].tx_desc_status.val |= GMAC_TX_USED_BIT;
   128e8:	eb06 05c4 	add.w	r5, r6, r4, lsl #3
   128ec:	686b      	ldr	r3, [r5, #4]
   128ee:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   128f2:	606b      	str	r3, [r5, #4]
            pTxDesc[tailIndex].tx_desc_status.val &= GMAC_TX_USED_BIT | GMAC_TX_WRAP_BIT | GMAC_TX_LAST_BUFFER_BIT;
   128f4:	686b      	ldr	r3, [r5, #4]
   128f6:	ea03 0309 	and.w	r3, r3, r9
   128fa:	606b      	str	r3, [r5, #4]
            pTxDesc[tailIndex].tx_desc_buffaddr = 0;
   128fc:	f846 7034 	str.w	r7, [r6, r4, lsl #3]
            if(GMAC_TX_LAST_BUFFER_BIT & (pTxDesc[tailIndex].tx_desc_status.val) )
   12900:	686b      	ldr	r3, [r5, #4]
   12902:	f413 4f00 	tst.w	r3, #32768	; 0x8000
   12906:	d1b7      	bne.n	12878 <DRV_PIC32CGMAC_LibTxAckPacket+0x6c>
            GCIRC_INC(tailIndex, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt);  
   12908:	eb0b 02cb 	add.w	r2, fp, fp, lsl #3
   1290c:	eb0a 0242 	add.w	r2, sl, r2, lsl #1
   12910:	3401      	adds	r4, #1
   12912:	b2a4      	uxth	r4, r4
   12914:	f8b2 30c8 	ldrh.w	r3, [r2, #200]	; 0xc8
   12918:	42a3      	cmp	r3, r4
   1291a:	bf98      	it	ls
   1291c:	2400      	movls	r4, #0
        while(tailIndex != headIndex)
   1291e:	4544      	cmp	r4, r8
   12920:	d010      	beq.n	12944 <DRV_PIC32CGMAC_LibTxAckPacket+0x138>
            pTxDesc[tailIndex].tx_desc_status.val |= GMAC_TX_USED_BIT;
   12922:	eb06 05c4 	add.w	r5, r6, r4, lsl #3
   12926:	686b      	ldr	r3, [r5, #4]
   12928:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1292c:	606b      	str	r3, [r5, #4]
            pTxDesc[tailIndex].tx_desc_status.val &= GMAC_TX_USED_BIT | GMAC_TX_WRAP_BIT | GMAC_TX_LAST_BUFFER_BIT;
   1292e:	686b      	ldr	r3, [r5, #4]
   12930:	ea03 0309 	and.w	r3, r3, r9
   12934:	606b      	str	r3, [r5, #4]
            pTxDesc[tailIndex].tx_desc_buffaddr = 0;
   12936:	f846 7034 	str.w	r7, [r6, r4, lsl #3]
            if(GMAC_TX_LAST_BUFFER_BIT & (pTxDesc[tailIndex].tx_desc_status.val) )
   1293a:	686b      	ldr	r3, [r5, #4]
   1293c:	f413 4f00 	tst.w	r3, #32768	; 0x8000
   12940:	d0e6      	beq.n	12910 <DRV_PIC32CGMAC_LibTxAckPacket+0x104>
   12942:	e799      	b.n	12878 <DRV_PIC32CGMAC_LibTxAckPacket+0x6c>
        pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail = tailIndex;
   12944:	232c      	movs	r3, #44	; 0x2c
   12946:	fb03 aa0b 	mla	sl, r3, fp, sl
   1294a:	f8aa 80b4 	strh.w	r8, [sl, #180]	; 0xb4
} //DRV_PIC32CGMAC_LibTxAckPacket
   1294e:	4608      	mov	r0, r1
   12950:	b003      	add	sp, #12
   12952:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	DRV_PIC32CGMAC_RESULT res = DRV_PIC32CGMAC_RES_NO_PACKET;
   12956:	2101      	movs	r1, #1
   12958:	e7f9      	b.n	1294e <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
   1295a:	2101      	movs	r1, #1
   1295c:	e7f7      	b.n	1294e <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
   1295e:	2101      	movs	r1, #1
   12960:	e7f5      	b.n	1294e <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
   12962:	2100      	movs	r1, #0
   12964:	e7f3      	b.n	1294e <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
   12966:	2100      	movs	r1, #0
	return res;	
   12968:	e7f1      	b.n	1294e <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
   1296a:	bf00      	nop
   1296c:	c0008000 	.word	0xc0008000

Disassembly of section .text._Command_NetworkOnOff%287:

00012970 <_Command_NetworkOnOff>:
{
   12970:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12974:	b094      	sub	sp, #80	; 0x50
   12976:	4604      	mov	r4, r0
    TCPIP_STACK_INIT    tcpip_init_data = {{0}};
   12978:	2300      	movs	r3, #0
   1297a:	9300      	str	r3, [sp, #0]
   1297c:	9301      	str	r3, [sp, #4]
   1297e:	9302      	str	r3, [sp, #8]
   12980:	9303      	str	r3, [sp, #12]
   12982:	9304      	str	r3, [sp, #16]
   12984:	9305      	str	r3, [sp, #20]
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   12986:	6845      	ldr	r5, [r0, #4]
    if (argc != 3)
   12988:	2903      	cmp	r1, #3
   1298a:	d010      	beq.n	129ae <_Command_NetworkOnOff+0x3e>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: if <interface> <down/up> \r\n");
   1298c:	4e46      	ldr	r6, [pc, #280]	; (12aa8 <_Command_NetworkOnOff+0x138>)
   1298e:	6803      	ldr	r3, [r0, #0]
   12990:	681b      	ldr	r3, [r3, #0]
   12992:	f606 31a4 	addw	r1, r6, #2980	; 0xba4
   12996:	4628      	mov	r0, r5
   12998:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: if PIC32INT down \r\n");
   1299a:	6823      	ldr	r3, [r4, #0]
   1299c:	681b      	ldr	r3, [r3, #0]
   1299e:	f606 31c8 	addw	r1, r6, #3016	; 0xbc8
   129a2:	4628      	mov	r0, r5
   129a4:	4798      	blx	r3
        return false;
   129a6:	2000      	movs	r0, #0
}
   129a8:	b014      	add	sp, #80	; 0x50
   129aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   129ae:	4616      	mov	r6, r2
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
   129b0:	6850      	ldr	r0, [r2, #4]
   129b2:	f00d f857 	bl	1fa64 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
   129b6:	4607      	mov	r7, r0
   129b8:	b1b8      	cbz	r0, 129ea <_Command_NetworkOnOff+0x7a>
    net_ix = TCPIP_STACK_NetIndexGet(netH);
   129ba:	f011 fab6 	bl	23f2a <TCPIP_STACK_NetIndexGet>
   129be:	4680      	mov	r8, r0
    if (memcmp(argv[2], "up", 2) == 0)
   129c0:	68b6      	ldr	r6, [r6, #8]
   129c2:	2202      	movs	r2, #2
   129c4:	4939      	ldr	r1, [pc, #228]	; (12aac <_Command_NetworkOnOff+0x13c>)
   129c6:	4630      	mov	r0, r6
   129c8:	f010 fc82 	bl	232d0 <memcmp>
   129cc:	b1a0      	cbz	r0, 129f8 <_Command_NetworkOnOff+0x88>
    else if (memcmp(argv[2], "down", 4) == 0)
   129ce:	2204      	movs	r2, #4
   129d0:	4937      	ldr	r1, [pc, #220]	; (12ab0 <_Command_NetworkOnOff+0x140>)
   129d2:	4630      	mov	r0, r6
   129d4:	f010 fc7c 	bl	232d0 <memcmp>
   129d8:	2800      	cmp	r0, #0
   129da:	d048      	beq.n	12a6e <_Command_NetworkOnOff+0xfe>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Wrong parameter specified \r\n");
   129dc:	6823      	ldr	r3, [r4, #0]
   129de:	681b      	ldr	r3, [r3, #0]
   129e0:	4934      	ldr	r1, [pc, #208]	; (12ab4 <_Command_NetworkOnOff+0x144>)
   129e2:	4628      	mov	r0, r5
   129e4:	4798      	blx	r3
        return false;
   129e6:	2000      	movs	r0, #0
   129e8:	e7de      	b.n	129a8 <_Command_NetworkOnOff+0x38>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   129ea:	6823      	ldr	r3, [r4, #0]
   129ec:	681b      	ldr	r3, [r3, #0]
   129ee:	4932      	ldr	r1, [pc, #200]	; (12ab8 <_Command_NetworkOnOff+0x148>)
   129f0:	4628      	mov	r0, r5
   129f2:	4798      	blx	r3
        return false;
   129f4:	2000      	movs	r0, #0
   129f6:	e7d7      	b.n	129a8 <_Command_NetworkOnOff+0x38>
        if(TCPIP_STACK_NetIsUp(netH))
   129f8:	4638      	mov	r0, r7
   129fa:	f010 fb97 	bl	2312c <TCPIP_STACK_NetIsUp>
   129fe:	b130      	cbz	r0, 12a0e <_Command_NetworkOnOff+0x9e>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "This interface already up\r\n");
   12a00:	6823      	ldr	r3, [r4, #0]
   12a02:	681b      	ldr	r3, [r3, #0]
   12a04:	492d      	ldr	r1, [pc, #180]	; (12abc <_Command_NetworkOnOff+0x14c>)
   12a06:	4628      	mov	r0, r5
   12a08:	4798      	blx	r3
            return true;
   12a0a:	2001      	movs	r0, #1
   12a0c:	e7cc      	b.n	129a8 <_Command_NetworkOnOff+0x38>
        tcpipStackObj = TCPIP_STACK_Initialize(0, 0);
   12a0e:	2100      	movs	r1, #0
   12a10:	4608      	mov	r0, r1
   12a12:	f007 fd89 	bl	1a528 <TCPIP_STACK_Initialize>
        TCPIP_STACK_InitializeDataGet(tcpipStackObj, &tcpip_init_data);
   12a16:	4669      	mov	r1, sp
   12a18:	f00e fc90 	bl	2133c <TCPIP_STACK_InitializeDataGet>
        if(tcpip_init_data.pNetConf == 0)
   12a1c:	9e01      	ldr	r6, [sp, #4]
   12a1e:	b1fe      	cbz	r6, 12a60 <_Command_NetworkOnOff+0xf0>
        memcpy(pIfConf, tcpip_init_data.pNetConf + net_ix, sizeof(*pIfConf));
   12a20:	fa1f f888 	uxth.w	r8, r8
   12a24:	ebc8 08c8 	rsb	r8, r8, r8, lsl #3
   12a28:	eb06 06c8 	add.w	r6, r6, r8, lsl #3
   12a2c:	f10d 0e18 	add.w	lr, sp, #24
   12a30:	f106 0830 	add.w	r8, r6, #48	; 0x30
   12a34:	46f4      	mov	ip, lr
   12a36:	6830      	ldr	r0, [r6, #0]
   12a38:	6871      	ldr	r1, [r6, #4]
   12a3a:	68b2      	ldr	r2, [r6, #8]
   12a3c:	68f3      	ldr	r3, [r6, #12]
   12a3e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   12a42:	3610      	adds	r6, #16
   12a44:	46e6      	mov	lr, ip
   12a46:	4546      	cmp	r6, r8
   12a48:	d1f4      	bne.n	12a34 <_Command_NetworkOnOff+0xc4>
   12a4a:	6830      	ldr	r0, [r6, #0]
   12a4c:	6871      	ldr	r1, [r6, #4]
   12a4e:	e8ae 0003 	stmia.w	lr!, {r0, r1}
        pIfConf->powerMode = TCPIP_STACK_IF_POWER_FULL;
   12a52:	4b1b      	ldr	r3, [pc, #108]	; (12ac0 <_Command_NetworkOnOff+0x150>)
   12a54:	930e      	str	r3, [sp, #56]	; 0x38
        res = TCPIP_STACK_NetUp(netH, pIfConf);
   12a56:	a906      	add	r1, sp, #24
   12a58:	4638      	mov	r0, r7
   12a5a:	f005 fe8b 	bl	18774 <TCPIP_STACK_NetUp>
   12a5e:	e014      	b.n	12a8a <_Command_NetworkOnOff+0x11a>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Operation failed. No configuration\r\n");
   12a60:	6823      	ldr	r3, [r4, #0]
   12a62:	681b      	ldr	r3, [r3, #0]
   12a64:	4917      	ldr	r1, [pc, #92]	; (12ac4 <_Command_NetworkOnOff+0x154>)
   12a66:	4628      	mov	r0, r5
   12a68:	4798      	blx	r3
            return true;
   12a6a:	2001      	movs	r0, #1
   12a6c:	e79c      	b.n	129a8 <_Command_NetworkOnOff+0x38>
        if(TCPIP_STACK_NetIsUp(netH) == 0)
   12a6e:	4638      	mov	r0, r7
   12a70:	f010 fb5c 	bl	2312c <TCPIP_STACK_NetIsUp>
   12a74:	b930      	cbnz	r0, 12a84 <_Command_NetworkOnOff+0x114>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "This interface already down\r\n");
   12a76:	6823      	ldr	r3, [r4, #0]
   12a78:	681b      	ldr	r3, [r3, #0]
   12a7a:	4913      	ldr	r1, [pc, #76]	; (12ac8 <_Command_NetworkOnOff+0x158>)
   12a7c:	4628      	mov	r0, r5
   12a7e:	4798      	blx	r3
            return true;
   12a80:	2001      	movs	r0, #1
   12a82:	e791      	b.n	129a8 <_Command_NetworkOnOff+0x38>
        res = TCPIP_STACK_NetDown(netH);
   12a84:	4638      	mov	r0, r7
   12a86:	f00e f885 	bl	20b94 <TCPIP_STACK_NetDown>
    if (res == true)
   12a8a:	b130      	cbz	r0, 12a9a <_Command_NetworkOnOff+0x12a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Operation successful!\r\n");
   12a8c:	6823      	ldr	r3, [r4, #0]
   12a8e:	681b      	ldr	r3, [r3, #0]
   12a90:	490e      	ldr	r1, [pc, #56]	; (12acc <_Command_NetworkOnOff+0x15c>)
   12a92:	4628      	mov	r0, r5
   12a94:	4798      	blx	r3
    return true;
   12a96:	2001      	movs	r0, #1
   12a98:	e786      	b.n	129a8 <_Command_NetworkOnOff+0x38>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Operation failed!\r\n");
   12a9a:	6823      	ldr	r3, [r4, #0]
   12a9c:	681b      	ldr	r3, [r3, #0]
   12a9e:	490c      	ldr	r1, [pc, #48]	; (12ad0 <_Command_NetworkOnOff+0x160>)
   12aa0:	4628      	mov	r0, r5
   12aa2:	4798      	blx	r3
    return true;
   12aa4:	2001      	movs	r0, #1
   12aa6:	e77f      	b.n	129a8 <_Command_NetworkOnOff+0x38>
   12aa8:	0000028c 	.word	0x0000028c
   12aac:	00000d84 	.word	0x00000d84
   12ab0:	00000de8 	.word	0x00000de8
   12ab4:	00000ed8 	.word	0x00000ed8
   12ab8:	00000b80 	.word	0x00000b80
   12abc:	00000e6c 	.word	0x00000e6c
   12ac0:	00000eb0 	.word	0x00000eb0
   12ac4:	00000e88 	.word	0x00000e88
   12ac8:	00000eb8 	.word	0x00000eb8
   12acc:	00000ef8 	.word	0x00000ef8
   12ad0:	00000f10 	.word	0x00000f10

Disassembly of section .text.CommandHelp%288:

00012ad4 <CommandHelp>:
{
   12ad4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12ad8:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   12ada:	6845      	ldr	r5, [r0, #4]
    if(argc == 1)
   12adc:	2901      	cmp	r1, #1
   12ade:	d004      	beq.n	12aea <CommandHelp+0x16>
   12ae0:	4691      	mov	r9, r2
        pTbl = _usrCmdTbl;
   12ae2:	4e4f      	ldr	r6, [pc, #316]	; (12c20 <CommandHelp+0x14c>)
        for (groupIx=0; groupIx < MAX_CMD_GROUP; groupIx++)
   12ae4:	f106 0780 	add.w	r7, r6, #128	; 0x80
   12ae8:	e05c      	b.n	12ba4 <CommandHelp+0xd0>
        bool hadHeader = false;
   12aea:	2200      	movs	r2, #0
        pTbl = _usrCmdTbl;
   12aec:	4e4c      	ldr	r6, [pc, #304]	; (12c20 <CommandHelp+0x14c>)
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** ");
   12aee:	4f4d      	ldr	r7, [pc, #308]	; (12c24 <CommandHelp+0x150>)
   12af0:	f107 0938 	add.w	r9, r7, #56	; 0x38
        for (groupIx=0; groupIx < MAX_CMD_GROUP; groupIx++)
   12af4:	f106 0880 	add.w	r8, r6, #128	; 0x80
   12af8:	e018      	b.n	12b2c <CommandHelp+0x58>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** ");
   12afa:	6823      	ldr	r3, [r4, #0]
   12afc:	681b      	ldr	r3, [r3, #0]
   12afe:	4649      	mov	r1, r9
   12b00:	4628      	mov	r0, r5
   12b02:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, pTbl->cmdGroupName);
   12b04:	6823      	ldr	r3, [r4, #0]
   12b06:	681b      	ldr	r3, [r3, #0]
   12b08:	68b1      	ldr	r1, [r6, #8]
   12b0a:	4628      	mov	r0, r5
   12b0c:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, pTbl->cmdMenuStr);
   12b0e:	6823      	ldr	r3, [r4, #0]
   12b10:	681b      	ldr	r3, [r3, #0]
   12b12:	68f1      	ldr	r1, [r6, #12]
   12b14:	4628      	mov	r0, r5
   12b16:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, " ***");
   12b18:	6823      	ldr	r3, [r4, #0]
   12b1a:	681b      	ldr	r3, [r3, #0]
   12b1c:	f107 0140 	add.w	r1, r7, #64	; 0x40
   12b20:	4628      	mov	r0, r5
   12b22:	4798      	blx	r3
   12b24:	2201      	movs	r2, #1
            pTbl++;
   12b26:	3610      	adds	r6, #16
        for (groupIx=0; groupIx < MAX_CMD_GROUP; groupIx++)
   12b28:	4546      	cmp	r6, r8
   12b2a:	d00b      	beq.n	12b44 <CommandHelp+0x70>
            if (pTbl->pCmd)
   12b2c:	6873      	ldr	r3, [r6, #4]
   12b2e:	2b00      	cmp	r3, #0
   12b30:	d0f9      	beq.n	12b26 <CommandHelp+0x52>
                if(!hadHeader)
   12b32:	2a00      	cmp	r2, #0
   12b34:	d1e1      	bne.n	12afa <CommandHelp+0x26>
                    (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM "------- Supported command groups ------");
   12b36:	6823      	ldr	r3, [r4, #0]
   12b38:	681b      	ldr	r3, [r3, #0]
   12b3a:	f107 010c 	add.w	r1, r7, #12
   12b3e:	4628      	mov	r0, r5
   12b40:	4798      	blx	r3
                    hadHeader = true;
   12b42:	e7da      	b.n	12afa <CommandHelp+0x26>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM "---------- Built in commands ----------");
   12b44:	6823      	ldr	r3, [r4, #0]
   12b46:	681b      	ldr	r3, [r3, #0]
   12b48:	4937      	ldr	r1, [pc, #220]	; (12c28 <CommandHelp+0x154>)
   12b4a:	4628      	mov	r0, r5
   12b4c:	4798      	blx	r3
        for(ix = 0, pDcpt = _builtinCmdTbl; ix < sizeof(_builtinCmdTbl)/sizeof(*_builtinCmdTbl); ix++, pDcpt++)
   12b4e:	4b37      	ldr	r3, [pc, #220]	; (12c2c <CommandHelp+0x158>)
   12b50:	f103 060c 	add.w	r6, r3, #12
   12b54:	f103 0830 	add.w	r8, r3, #48	; 0x30
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** ");
   12b58:	4f32      	ldr	r7, [pc, #200]	; (12c24 <CommandHelp+0x150>)
   12b5a:	f107 0938 	add.w	r9, r7, #56	; 0x38
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, " ***");
   12b5e:	3740      	adds	r7, #64	; 0x40
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** ");
   12b60:	6823      	ldr	r3, [r4, #0]
   12b62:	681b      	ldr	r3, [r3, #0]
   12b64:	4649      	mov	r1, r9
   12b66:	4628      	mov	r0, r5
   12b68:	4798      	blx	r3
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, pDcpt->cmdStr);
   12b6a:	6823      	ldr	r3, [r4, #0]
   12b6c:	681b      	ldr	r3, [r3, #0]
   12b6e:	f856 1c0c 	ldr.w	r1, [r6, #-12]
   12b72:	4628      	mov	r0, r5
   12b74:	4798      	blx	r3
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, pDcpt->cmdDescr);
   12b76:	6823      	ldr	r3, [r4, #0]
   12b78:	681b      	ldr	r3, [r3, #0]
   12b7a:	f856 1c04 	ldr.w	r1, [r6, #-4]
   12b7e:	4628      	mov	r0, r5
   12b80:	4798      	blx	r3
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, " ***");
   12b82:	6823      	ldr	r3, [r4, #0]
   12b84:	681b      	ldr	r3, [r3, #0]
   12b86:	4639      	mov	r1, r7
   12b88:	4628      	mov	r0, r5
   12b8a:	4798      	blx	r3
   12b8c:	360c      	adds	r6, #12
        for(ix = 0, pDcpt = _builtinCmdTbl; ix < sizeof(_builtinCmdTbl)/sizeof(*_builtinCmdTbl); ix++, pDcpt++)
   12b8e:	45b0      	cmp	r8, r6
   12b90:	d1e6      	bne.n	12b60 <CommandHelp+0x8c>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM);
   12b92:	6823      	ldr	r3, [r4, #0]
   12b94:	681b      	ldr	r3, [r3, #0]
   12b96:	4926      	ldr	r1, [pc, #152]	; (12c30 <CommandHelp+0x15c>)
   12b98:	4628      	mov	r0, r5
   12b9a:	4798      	blx	r3
   12b9c:	e038      	b.n	12c10 <CommandHelp+0x13c>
            pTbl++;
   12b9e:	3610      	adds	r6, #16
        for (groupIx=0; groupIx < MAX_CMD_GROUP; groupIx++)
   12ba0:	42be      	cmp	r6, r7
   12ba2:	d037      	beq.n	12c14 <CommandHelp+0x140>
            if (pTbl->pCmd)
   12ba4:	6873      	ldr	r3, [r6, #4]
   12ba6:	2b00      	cmp	r3, #0
   12ba8:	d0f9      	beq.n	12b9e <CommandHelp+0xca>
                if(strcmp(pTbl->cmdGroupName, argv[1]) == 0)
   12baa:	f8d9 1004 	ldr.w	r1, [r9, #4]
   12bae:	68b0      	ldr	r0, [r6, #8]
   12bb0:	f011 f824 	bl	23bfc <strcmp>
   12bb4:	4680      	mov	r8, r0
   12bb6:	2800      	cmp	r0, #0
   12bb8:	d1f1      	bne.n	12b9e <CommandHelp+0xca>
            for(ix = 0, pDcpt = pDTbl->pCmd; ix < pDTbl->nCmds; ix++, pDcpt++)
   12bba:	6877      	ldr	r7, [r6, #4]
   12bbc:	6833      	ldr	r3, [r6, #0]
   12bbe:	2b00      	cmp	r3, #0
   12bc0:	dd21      	ble.n	12c06 <CommandHelp+0x132>
   12bc2:	370c      	adds	r7, #12
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** ");
   12bc4:	4b17      	ldr	r3, [pc, #92]	; (12c24 <CommandHelp+0x150>)
   12bc6:	f103 0a38 	add.w	sl, r3, #56	; 0x38
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, " ***");
   12bca:	f103 0940 	add.w	r9, r3, #64	; 0x40
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** ");
   12bce:	6823      	ldr	r3, [r4, #0]
   12bd0:	681b      	ldr	r3, [r3, #0]
   12bd2:	4651      	mov	r1, sl
   12bd4:	4628      	mov	r0, r5
   12bd6:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, pDcpt->cmdStr);
   12bd8:	6823      	ldr	r3, [r4, #0]
   12bda:	681b      	ldr	r3, [r3, #0]
   12bdc:	f857 1c0c 	ldr.w	r1, [r7, #-12]
   12be0:	4628      	mov	r0, r5
   12be2:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, pDcpt->cmdDescr);
   12be4:	6823      	ldr	r3, [r4, #0]
   12be6:	681b      	ldr	r3, [r3, #0]
   12be8:	f857 1c04 	ldr.w	r1, [r7, #-4]
   12bec:	4628      	mov	r0, r5
   12bee:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, " ***");
   12bf0:	6823      	ldr	r3, [r4, #0]
   12bf2:	681b      	ldr	r3, [r3, #0]
   12bf4:	4649      	mov	r1, r9
   12bf6:	4628      	mov	r0, r5
   12bf8:	4798      	blx	r3
            for(ix = 0, pDcpt = pDTbl->pCmd; ix < pDTbl->nCmds; ix++, pDcpt++)
   12bfa:	f108 0801 	add.w	r8, r8, #1
   12bfe:	370c      	adds	r7, #12
   12c00:	6833      	ldr	r3, [r6, #0]
   12c02:	4543      	cmp	r3, r8
   12c04:	dce3      	bgt.n	12bce <CommandHelp+0xfa>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM);
   12c06:	6823      	ldr	r3, [r4, #0]
   12c08:	681b      	ldr	r3, [r3, #0]
   12c0a:	4909      	ldr	r1, [pc, #36]	; (12c30 <CommandHelp+0x15c>)
   12c0c:	4628      	mov	r0, r5
   12c0e:	4798      	blx	r3
}
   12c10:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM "Unknown command group. Try help" LINE_TERM );
   12c14:	6823      	ldr	r3, [r4, #0]
   12c16:	681b      	ldr	r3, [r3, #0]
   12c18:	4906      	ldr	r1, [pc, #24]	; (12c34 <CommandHelp+0x160>)
   12c1a:	4628      	mov	r0, r5
   12c1c:	4798      	blx	r3
   12c1e:	e7f7      	b.n	12c10 <CommandHelp+0x13c>
   12c20:	2000e768 	.word	0x2000e768
   12c24:	0000e994 	.word	0x0000e994
   12c28:	0000e9dc 	.word	0x0000e9dc
   12c2c:	00022688 	.word	0x00022688
   12c30:	0000ea08 	.word	0x0000ea08
   12c34:	0000ea0c 	.word	0x0000ea0c

Disassembly of section .text._UDPOpen%289:

00012c38 <_UDPOpen>:
{
   12c38:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12c3c:	4699      	mov	r9, r3
    if(UDPSocketDcpt == 0)
   12c3e:	4b50      	ldr	r3, [pc, #320]	; (12d80 <_UDPOpen+0x148>)
   12c40:	681b      	ldr	r3, [r3, #0]
   12c42:	2b00      	cmp	r3, #0
   12c44:	f000 808a 	beq.w	12d5c <_UDPOpen+0x124>
   12c48:	4606      	mov	r6, r0
   12c4a:	460d      	mov	r5, r1
   12c4c:	4617      	mov	r7, r2
    if((opType & UDP_OPEN_CLIENT) != 0)
   12c4e:	f011 0802 	ands.w	r8, r1, #2
   12c52:	f040 8088 	bne.w	12d66 <_UDPOpen+0x12e>
    OSAL_SEM_Pend(&userSem, OSAL_WAIT_FOREVER);
   12c56:	f64f 71ff 	movw	r1, #65535	; 0xffff
   12c5a:	484a      	ldr	r0, [pc, #296]	; (12d84 <_UDPOpen+0x14c>)
   12c5c:	f010 f94a 	bl	22ef4 <OSAL_SEM_Pend>
        if(localPort == 0)
   12c60:	2f00      	cmp	r7, #0
   12c62:	f000 8085 	beq.w	12d70 <_UDPOpen+0x138>
        for ( sktIx = 0; sktIx < nUdpSockets; sktIx++ )
   12c66:	4b48      	ldr	r3, [pc, #288]	; (12d88 <_UDPOpen+0x150>)
   12c68:	6819      	ldr	r1, [r3, #0]
   12c6a:	2900      	cmp	r1, #0
   12c6c:	dd59      	ble.n	12d22 <_UDPOpen+0xea>
            pSkt = UDPSocketDcpt[sktIx];
   12c6e:	4b44      	ldr	r3, [pc, #272]	; (12d80 <_UDPOpen+0x148>)
   12c70:	681b      	ldr	r3, [r3, #0]
   12c72:	681a      	ldr	r2, [r3, #0]
            if(pSkt == 0)
   12c74:	2a00      	cmp	r2, #0
   12c76:	d074      	beq.n	12d62 <_UDPOpen+0x12a>
        for ( sktIx = 0; sktIx < nUdpSockets; sktIx++ )
   12c78:	2400      	movs	r4, #0
   12c7a:	3401      	adds	r4, #1
   12c7c:	428c      	cmp	r4, r1
   12c7e:	d04f      	beq.n	12d20 <_UDPOpen+0xe8>
            pSkt = UDPSocketDcpt[sktIx];
   12c80:	f853 2f04 	ldr.w	r2, [r3, #4]!
            if(pSkt == 0)
   12c84:	2a00      	cmp	r2, #0
   12c86:	d1f8      	bne.n	12c7a <_UDPOpen+0x42>
        pSkt = (UDP_SOCKET_DCPT*)TCPIP_HEAP_Calloc(udpMemH, 1, sizeof(*pSkt));
   12c88:	4b40      	ldr	r3, [pc, #256]	; (12d8c <_UDPOpen+0x154>)
   12c8a:	6818      	ldr	r0, [r3, #0]
   12c8c:	6883      	ldr	r3, [r0, #8]
   12c8e:	225c      	movs	r2, #92	; 0x5c
   12c90:	2101      	movs	r1, #1
   12c92:	4798      	blx	r3
    if(newSktValid)
   12c94:	4682      	mov	sl, r0
   12c96:	2800      	cmp	r0, #0
   12c98:	d043      	beq.n	12d22 <_UDPOpen+0xea>
        pSkt->sktIx = sktIx;
   12c9a:	fa0f fb84 	sxth.w	fp, r4
   12c9e:	f8a0 b012 	strh.w	fp, [r0, #18]
        UDPSocketDcpt[sktIx] = pSkt;
   12ca2:	4b37      	ldr	r3, [pc, #220]	; (12d80 <_UDPOpen+0x148>)
   12ca4:	681b      	ldr	r3, [r3, #0]
   12ca6:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
    OSAL_SEM_Post(&userSem);
   12caa:	4836      	ldr	r0, [pc, #216]	; (12d84 <_UDPOpen+0x14c>)
   12cac:	f010 fd6e 	bl	2378c <OSAL_SEM_Post>
    pSkt->localPort = localPort;	
   12cb0:	f8aa 702a 	strh.w	r7, [sl, #42]	; 0x2a
    pSkt->remotePort = remotePort;
   12cb4:	f8aa 8028 	strh.w	r8, [sl, #40]	; 0x28
    pSkt->addType = addType;
   12cb8:	f8aa 603c 	strh.w	r6, [sl, #60]	; 0x3c
    pSkt->txAllocLimit = TCPIP_UDP_SOCKET_DEFAULT_TX_QUEUE_LIMIT; 
   12cbc:	2303      	movs	r3, #3
   12cbe:	f88a 303e 	strb.w	r3, [sl, #62]	; 0x3e
    pSkt->rxQueueLimit = TCPIP_UDP_SOCKET_DEFAULT_RX_QUEUE_LIMIT;
   12cc2:	f88a 305a 	strb.w	r3, [sl, #90]	; 0x5a
    pSkt->flags.openAddType = addType;
   12cc6:	f89a 3041 	ldrb.w	r3, [sl, #65]	; 0x41
   12cca:	f366 1305 	bfi	r3, r6, #4, #2
   12cce:	f88a 3041 	strb.w	r3, [sl, #65]	; 0x41
    if((opType & UDP_OPEN_TX_SPLIT) != 0)
   12cd2:	f015 0f80 	tst.w	r5, #128	; 0x80
   12cd6:	d02c      	beq.n	12d32 <_UDPOpen+0xfa>
        pSkt->txSize = 0;
   12cd8:	2300      	movs	r3, #0
   12cda:	f8aa 3010 	strh.w	r3, [sl, #16]
        pSkt->flags.txSplitAlloc = 1;
   12cde:	f89a 3041 	ldrb.w	r3, [sl, #65]	; 0x41
   12ce2:	f043 0302 	orr.w	r3, r3, #2
   12ce6:	f88a 3041 	strb.w	r3, [sl, #65]	; 0x41
    if((opType & UDP_OPEN_CONFIG_SERVICE) != 0)
   12cea:	f415 7f80 	tst.w	r5, #256	; 0x100
   12cee:	d005      	beq.n	12cfc <_UDPOpen+0xc4>
        pSkt->flags.stackConfig = 1;
   12cf0:	f89a 3041 	ldrb.w	r3, [sl, #65]	; 0x41
   12cf4:	f043 0308 	orr.w	r3, r3, #8
   12cf8:	f88a 3041 	strb.w	r3, [sl, #65]	; 0x41
    if((opType & UDP_OPEN_SERVER) != 0)
   12cfc:	f015 0f01 	tst.w	r5, #1
   12d00:	d01c      	beq.n	12d3c <_UDPOpen+0x104>
        pSkt->flags.looseRemPort = pSkt->flags.looseNetIf = pSkt->flags.looseRemAddress = 1; 
   12d02:	f89a 3040 	ldrb.w	r3, [sl, #64]	; 0x40
   12d06:	f043 031c 	orr.w	r3, r3, #28
   12d0a:	f88a 3040 	strb.w	r3, [sl, #64]	; 0x40
        pSkt->extFlags.serverSkt = 1;
   12d0e:	f89a 3042 	ldrb.w	r3, [sl, #66]	; 0x42
   12d12:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   12d16:	f88a 3042 	strb.w	r3, [sl, #66]	; 0x42
}
   12d1a:	4658      	mov	r0, fp
   12d1c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(pSkt != 0)
   12d20:	b12a      	cbz	r2, 12d2e <_UDPOpen+0xf6>
    OSAL_SEM_Post(&userSem);
   12d22:	4818      	ldr	r0, [pc, #96]	; (12d84 <_UDPOpen+0x14c>)
   12d24:	f010 fd32 	bl	2378c <OSAL_SEM_Post>
        return (UDP_SOCKET)INVALID_UDP_SOCKET;
   12d28:	f04f 3bff 	mov.w	fp, #4294967295
   12d2c:	e7f5      	b.n	12d1a <_UDPOpen+0xe2>
        for ( sktIx = 0; sktIx < nUdpSockets; sktIx++ )
   12d2e:	460c      	mov	r4, r1
   12d30:	e7aa      	b.n	12c88 <_UDPOpen+0x50>
        pSkt->txSize = udpDefTxSize;
   12d32:	4b17      	ldr	r3, [pc, #92]	; (12d90 <_UDPOpen+0x158>)
   12d34:	881b      	ldrh	r3, [r3, #0]
   12d36:	f8aa 3010 	strh.w	r3, [sl, #16]
   12d3a:	e7d6      	b.n	12cea <_UDPOpen+0xb2>
        switch(addType)
   12d3c:	2e01      	cmp	r6, #1
   12d3e:	d1ec      	bne.n	12d1a <_UDPOpen+0xe2>
                if(hostAddress)
   12d40:	f1b9 0f00 	cmp.w	r9, #0
   12d44:	d0e9      	beq.n	12d1a <_UDPOpen+0xe2>
                    pSkt->destAddress.Val = hostAddress->v4Add.Val;
   12d46:	f8d9 3000 	ldr.w	r3, [r9]
   12d4a:	f8ca 3014 	str.w	r3, [sl, #20]
                    pSkt->flags.destSet = 1;
   12d4e:	f89a 3041 	ldrb.w	r3, [sl, #65]	; 0x41
   12d52:	f043 0301 	orr.w	r3, r3, #1
   12d56:	f88a 3041 	strb.w	r3, [sl, #65]	; 0x41
    return (UDP_SOCKET)sktIx;
   12d5a:	e7de      	b.n	12d1a <_UDPOpen+0xe2>
        return (UDP_SOCKET)INVALID_UDP_SOCKET;
   12d5c:	f04f 3bff 	mov.w	fp, #4294967295
   12d60:	e7db      	b.n	12d1a <_UDPOpen+0xe2>
        for ( sktIx = 0; sktIx < nUdpSockets; sktIx++ )
   12d62:	2400      	movs	r4, #0
        if(pSkt != 0)
   12d64:	e790      	b.n	12c88 <_UDPOpen+0x50>
    OSAL_SEM_Pend(&userSem, OSAL_WAIT_FOREVER);
   12d66:	f64f 71ff 	movw	r1, #65535	; 0xffff
   12d6a:	4806      	ldr	r0, [pc, #24]	; (12d84 <_UDPOpen+0x14c>)
   12d6c:	f010 f8c2 	bl	22ef4 <OSAL_SEM_Pend>
            localPort = _UDPAllocateEphemeralPort();
   12d70:	f00d fd10 	bl	20794 <_UDPAllocateEphemeralPort>
            if(localPort == 0)
   12d74:	2800      	cmp	r0, #0
   12d76:	d0d4      	beq.n	12d22 <_UDPOpen+0xea>
   12d78:	46b8      	mov	r8, r7
            localPort = _UDPAllocateEphemeralPort();
   12d7a:	4607      	mov	r7, r0
   12d7c:	e773      	b.n	12c66 <_UDPOpen+0x2e>
   12d7e:	bf00      	nop
   12d80:	2000ee88 	.word	0x2000ee88
   12d84:	2000ee9c 	.word	0x2000ee9c
   12d88:	2000ee8c 	.word	0x2000ee8c
   12d8c:	2000ee98 	.word	0x2000ee98
   12d90:	2000ef82 	.word	0x2000ef82

Disassembly of section .text.TCPIP_DNS_EntryQuery%290:

00012d94 <TCPIP_DNS_EntryQuery>:
{
   12d94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    pDnsDcpt = pgDnsDcpt;
   12d96:	4b53      	ldr	r3, [pc, #332]	; (12ee4 <TCPIP_DNS_EntryQuery+0x150>)
   12d98:	681e      	ldr	r6, [r3, #0]
    if(pDnsDcpt == 0 || pDnsDcpt->hashDcpt == 0)
   12d9a:	2e00      	cmp	r6, #0
   12d9c:	f000 808d 	beq.w	12eba <TCPIP_DNS_EntryQuery+0x126>
   12da0:	4604      	mov	r4, r0
   12da2:	6830      	ldr	r0, [r6, #0]
   12da4:	2800      	cmp	r0, #0
   12da6:	f000 808b 	beq.w	12ec0 <TCPIP_DNS_EntryQuery+0x12c>
    if(pDnsQuery == 0 || pDnsQuery->hostName == 0 || pDnsQuery->nameLen == 0)
   12daa:	2c00      	cmp	r4, #0
   12dac:	f000 808b 	beq.w	12ec6 <TCPIP_DNS_EntryQuery+0x132>
   12db0:	6823      	ldr	r3, [r4, #0]
   12db2:	2b00      	cmp	r3, #0
   12db4:	f000 808a 	beq.w	12ecc <TCPIP_DNS_EntryQuery+0x138>
   12db8:	6863      	ldr	r3, [r4, #4]
   12dba:	2b00      	cmp	r3, #0
   12dbc:	f000 8089 	beq.w	12ed2 <TCPIP_DNS_EntryQuery+0x13e>
    pBkt = TCPIP_OAHASH_EntryGet(pDnsDcpt->hashDcpt, queryIndex);
   12dc0:	f010 ff4b 	bl	23c5a <TCPIP_OAHASH_EntryGet>
    if(pBkt == 0)
   12dc4:	4605      	mov	r5, r0
   12dc6:	2800      	cmp	r0, #0
   12dc8:	f000 8086 	beq.w	12ed8 <TCPIP_DNS_EntryQuery+0x144>
    if(pBkt->flags.busy != 0)
   12dcc:	7803      	ldrb	r3, [r0, #0]
   12dce:	f013 0f01 	tst.w	r3, #1
   12dd2:	f000 8084 	beq.w	12ede <TCPIP_DNS_EntryQuery+0x14a>
        strncpy(pDnsQuery->hostName, pE->pHostName, pDnsQuery->nameLen - 1);
   12dd6:	6862      	ldr	r2, [r4, #4]
   12dd8:	3a01      	subs	r2, #1
   12dda:	6a01      	ldr	r1, [r0, #32]
   12ddc:	6820      	ldr	r0, [r4, #0]
   12dde:	f00f fb67 	bl	224b0 <strncpy>
        pDnsQuery->hostName[pDnsQuery->nameLen - 1] = 0;
   12de2:	6823      	ldr	r3, [r4, #0]
   12de4:	6862      	ldr	r2, [r4, #4]
   12de6:	4413      	add	r3, r2
   12de8:	2200      	movs	r2, #0
   12dea:	f803 2c01 	strb.w	r2, [r3, #-1]
        pDnsQuery->hNet = pE->currNet;
   12dee:	69eb      	ldr	r3, [r5, #28]
   12df0:	6223      	str	r3, [r4, #32]
        pDnsQuery->serverIx = pE->currServerIx;
   12df2:	f895 3029 	ldrb.w	r3, [r5, #41]	; 0x29
   12df6:	6263      	str	r3, [r4, #36]	; 0x24
        if((pBkt->flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) != 0)
   12df8:	882b      	ldrh	r3, [r5, #0]
   12dfa:	f013 0f80 	tst.w	r3, #128	; 0x80
   12dfe:	d04f      	beq.n	12ea0 <TCPIP_DNS_EntryQuery+0x10c>
            pDnsQuery->status = TCPIP_DNS_RES_OK;
   12e00:	7622      	strb	r2, [r4, #24]
            currTime = pDnsDcpt->dnsTime;
   12e02:	69f2      	ldr	r2, [r6, #28]
            if(pDnsDcpt->cacheEntryTMO > 0)
   12e04:	6973      	ldr	r3, [r6, #20]
   12e06:	2b00      	cmp	r3, #0
   12e08:	d03d      	beq.n	12e86 <TCPIP_DNS_EntryQuery+0xf2>
                pDnsQuery->ttlTime = pDnsDcpt->cacheEntryTMO - (currTime - pE->tInsert);
   12e0a:	1a9b      	subs	r3, r3, r2
   12e0c:	68aa      	ldr	r2, [r5, #8]
   12e0e:	4413      	add	r3, r2
   12e10:	61e3      	str	r3, [r4, #28]
            for(ix = 0; ix < pE->nIPv4Entries && ix < pDnsQuery->nIPv4Entries; ix++)
   12e12:	f895 3026 	ldrb.w	r3, [r5, #38]	; 0x26
   12e16:	2b00      	cmp	r3, #0
   12e18:	d03a      	beq.n	12e90 <TCPIP_DNS_EntryQuery+0xfc>
   12e1a:	68e3      	ldr	r3, [r4, #12]
   12e1c:	2b00      	cmp	r3, #0
   12e1e:	dd39      	ble.n	12e94 <TCPIP_DNS_EntryQuery+0x100>
   12e20:	2300      	movs	r3, #0
                pDnsQuery->ipv4Entry[ix].Val = pE->pip4Address[ix].Val;
   12e22:	692a      	ldr	r2, [r5, #16]
   12e24:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
   12e28:	68a2      	ldr	r2, [r4, #8]
   12e2a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            for(ix = 0; ix < pE->nIPv4Entries && ix < pDnsQuery->nIPv4Entries; ix++)
   12e2e:	3301      	adds	r3, #1
   12e30:	f895 2026 	ldrb.w	r2, [r5, #38]	; 0x26
   12e34:	429a      	cmp	r2, r3
   12e36:	dd02      	ble.n	12e3e <TCPIP_DNS_EntryQuery+0xaa>
   12e38:	68e2      	ldr	r2, [r4, #12]
   12e3a:	429a      	cmp	r2, r3
   12e3c:	dcf1      	bgt.n	12e22 <TCPIP_DNS_EntryQuery+0x8e>
            pDnsQuery->nIPv4ValidEntries = ix;
   12e3e:	62a3      	str	r3, [r4, #40]	; 0x28
            for(ix = 0; ix < pE->nIPv6Entries && ix < pDnsQuery->nIPv6Entries; ix++)
   12e40:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
   12e44:	b343      	cbz	r3, 12e98 <TCPIP_DNS_EntryQuery+0x104>
   12e46:	6963      	ldr	r3, [r4, #20]
   12e48:	2b00      	cmp	r3, #0
   12e4a:	dd27      	ble.n	12e9c <TCPIP_DNS_EntryQuery+0x108>
   12e4c:	2200      	movs	r2, #0
                memcpy(pDnsQuery->ipv6Entry[ix].v, pE->pip6Address[ix].v, sizeof(IPV6_ADDR));
   12e4e:	0110      	lsls	r0, r2, #4
   12e50:	6926      	ldr	r6, [r4, #16]
   12e52:	1831      	adds	r1, r6, r0
   12e54:	696b      	ldr	r3, [r5, #20]
   12e56:	4403      	add	r3, r0
   12e58:	f8d3 e000 	ldr.w	lr, [r3]
   12e5c:	f8d3 c004 	ldr.w	ip, [r3, #4]
   12e60:	689f      	ldr	r7, [r3, #8]
   12e62:	68db      	ldr	r3, [r3, #12]
   12e64:	f846 e000 	str.w	lr, [r6, r0]
   12e68:	f8c1 c004 	str.w	ip, [r1, #4]
   12e6c:	608f      	str	r7, [r1, #8]
   12e6e:	60cb      	str	r3, [r1, #12]
            for(ix = 0; ix < pE->nIPv6Entries && ix < pDnsQuery->nIPv6Entries; ix++)
   12e70:	3201      	adds	r2, #1
   12e72:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
   12e76:	4293      	cmp	r3, r2
   12e78:	dd02      	ble.n	12e80 <TCPIP_DNS_EntryQuery+0xec>
   12e7a:	6963      	ldr	r3, [r4, #20]
   12e7c:	4293      	cmp	r3, r2
   12e7e:	dce6      	bgt.n	12e4e <TCPIP_DNS_EntryQuery+0xba>
            pDnsQuery->nIPv6ValidEntries = ix;
   12e80:	62e2      	str	r2, [r4, #44]	; 0x2c
            return TCPIP_DNS_RES_OK;
   12e82:	2000      	movs	r0, #0
   12e84:	e018      	b.n	12eb8 <TCPIP_DNS_EntryQuery+0x124>
                pDnsQuery->ttlTime = pE->ipTTL.Val - (currTime - pE->tInsert);
   12e86:	69ab      	ldr	r3, [r5, #24]
   12e88:	68a9      	ldr	r1, [r5, #8]
   12e8a:	440b      	add	r3, r1
   12e8c:	1a9b      	subs	r3, r3, r2
   12e8e:	e7bf      	b.n	12e10 <TCPIP_DNS_EntryQuery+0x7c>
            for(ix = 0; ix < pE->nIPv4Entries && ix < pDnsQuery->nIPv4Entries; ix++)
   12e90:	2300      	movs	r3, #0
   12e92:	e7d4      	b.n	12e3e <TCPIP_DNS_EntryQuery+0xaa>
   12e94:	2300      	movs	r3, #0
   12e96:	e7d2      	b.n	12e3e <TCPIP_DNS_EntryQuery+0xaa>
            for(ix = 0; ix < pE->nIPv6Entries && ix < pDnsQuery->nIPv6Entries; ix++)
   12e98:	2200      	movs	r2, #0
   12e9a:	e7f1      	b.n	12e80 <TCPIP_DNS_EntryQuery+0xec>
   12e9c:	2200      	movs	r2, #0
   12e9e:	e7ef      	b.n	12e80 <TCPIP_DNS_EntryQuery+0xec>
            pDnsQuery->status = (pE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_TIMEOUT) == 0 ? TCPIP_DNS_RES_PENDING : TCPIP_DNS_RES_SERVER_TMO; 
   12ea0:	f403 7380 	and.w	r3, r3, #256	; 0x100
   12ea4:	2b00      	cmp	r3, #0
   12ea6:	bf0c      	ite	eq
   12ea8:	2301      	moveq	r3, #1
   12eaa:	f06f 0304 	mvnne.w	r3, #4
   12eae:	7623      	strb	r3, [r4, #24]
            pDnsQuery->ttlTime = 0;
   12eb0:	2000      	movs	r0, #0
   12eb2:	61e0      	str	r0, [r4, #28]
            pDnsQuery->nIPv4ValidEntries = 0;
   12eb4:	62a0      	str	r0, [r4, #40]	; 0x28
            pDnsQuery->nIPv6ValidEntries = 0;
   12eb6:	62e0      	str	r0, [r4, #44]	; 0x2c
}
   12eb8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return TCPIP_DNS_RES_NO_SERVICE;
   12eba:	f06f 0005 	mvn.w	r0, #5
   12ebe:	e7fb      	b.n	12eb8 <TCPIP_DNS_EntryQuery+0x124>
   12ec0:	f06f 0005 	mvn.w	r0, #5
   12ec4:	e7f8      	b.n	12eb8 <TCPIP_DNS_EntryQuery+0x124>
        return TCPIP_DNS_RES_INVALID_HOSTNAME;
   12ec6:	f06f 0008 	mvn.w	r0, #8
   12eca:	e7f5      	b.n	12eb8 <TCPIP_DNS_EntryQuery+0x124>
   12ecc:	f06f 0008 	mvn.w	r0, #8
   12ed0:	e7f2      	b.n	12eb8 <TCPIP_DNS_EntryQuery+0x124>
   12ed2:	f06f 0008 	mvn.w	r0, #8
   12ed6:	e7ef      	b.n	12eb8 <TCPIP_DNS_EntryQuery+0x124>
        return TCPIP_DNS_RES_NO_IX_ENTRY;
   12ed8:	f06f 0002 	mvn.w	r0, #2
   12edc:	e7ec      	b.n	12eb8 <TCPIP_DNS_EntryQuery+0x124>
    return TCPIP_DNS_RES_EMPTY_IX_ENTRY;
   12ede:	f06f 0003 	mvn.w	r0, #3
   12ee2:	e7e9      	b.n	12eb8 <TCPIP_DNS_EntryQuery+0x124>
   12ee4:	2000ee58 	.word	0x2000ee58

Disassembly of section .text.xQueueSemaphoreTake%291:

00012ee8 <xQueueSemaphoreTake>:
	} /*lint -restore */
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
   12ee8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12eec:	b084      	sub	sp, #16
   12eee:	4604      	mov	r4, r0
   12ef0:	9101      	str	r1, [sp, #4]
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
   12ef2:	f04f 0800 	mov.w	r8, #0
BaseType_t xEntryTimeSet = pdFALSE;
   12ef6:	4646      	mov	r6, r8

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
   12ef8:	4645      	mov	r5, r8

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
				{
					portYIELD_WITHIN_API();
   12efa:	4f4f      	ldr	r7, [pc, #316]	; (13038 <xQueueSemaphoreTake+0x150>)
   12efc:	e043      	b.n	12f86 <xQueueSemaphoreTake+0x9e>
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
   12efe:	3b01      	subs	r3, #1
   12f00:	63a3      	str	r3, [r4, #56]	; 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   12f02:	6823      	ldr	r3, [r4, #0]
   12f04:	b14b      	cbz	r3, 12f1a <xQueueSemaphoreTake+0x32>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   12f06:	6923      	ldr	r3, [r4, #16]
   12f08:	b95b      	cbnz	r3, 12f22 <xQueueSemaphoreTake+0x3a>
				taskEXIT_CRITICAL();
   12f0a:	f010 fe59 	bl	23bc0 <vPortExitCritical>
				return pdPASS;
   12f0e:	f04f 0801 	mov.w	r8, #1
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
   12f12:	4640      	mov	r0, r8
   12f14:	b004      	add	sp, #16
   12f16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
   12f1a:	f010 f9cb 	bl	232b4 <pvTaskIncrementMutexHeldCount>
   12f1e:	60a0      	str	r0, [r4, #8]
   12f20:	e7f1      	b.n	12f06 <xQueueSemaphoreTake+0x1e>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   12f22:	f104 0010 	add.w	r0, r4, #16
   12f26:	f008 ff97 	bl	1be58 <xTaskRemoveFromEventList>
   12f2a:	2800      	cmp	r0, #0
   12f2c:	d0ed      	beq.n	12f0a <xQueueSemaphoreTake+0x22>
						queueYIELD_IF_USING_PREEMPTION();
   12f2e:	4b42      	ldr	r3, [pc, #264]	; (13038 <xQueueSemaphoreTake+0x150>)
   12f30:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   12f34:	601a      	str	r2, [r3, #0]
   12f36:	f3bf 8f4f 	dsb	sy
   12f3a:	f3bf 8f6f 	isb	sy
   12f3e:	e7e4      	b.n	12f0a <xQueueSemaphoreTake+0x22>
					taskEXIT_CRITICAL();
   12f40:	f010 fe3e 	bl	23bc0 <vPortExitCritical>
					return errQUEUE_EMPTY;
   12f44:	f04f 0800 	mov.w	r8, #0
   12f48:	e7e3      	b.n	12f12 <xQueueSemaphoreTake+0x2a>
					vTaskInternalSetTimeOutState( &xTimeOut );
   12f4a:	a802      	add	r0, sp, #8
   12f4c:	f010 fcc6 	bl	238dc <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   12f50:	e023      	b.n	12f9a <xQueueSemaphoreTake+0xb2>
						taskENTER_CRITICAL();
   12f52:	f00f ff15 	bl	22d80 <vPortEnterCritical>
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
   12f56:	68a0      	ldr	r0, [r4, #8]
   12f58:	f006 f862 	bl	19020 <xTaskPriorityInherit>
   12f5c:	4680      	mov	r8, r0
						taskEXIT_CRITICAL();
   12f5e:	f010 fe2f 	bl	23bc0 <vPortExitCritical>
   12f62:	e040      	b.n	12fe6 <xQueueSemaphoreTake+0xfe>
				prvUnlockQueue( pxQueue );
   12f64:	4620      	mov	r0, r4
   12f66:	f008 f995 	bl	1b294 <prvUnlockQueue>
				( void ) xTaskResumeAll();
   12f6a:	f003 fc85 	bl	16878 <xTaskResumeAll>
   12f6e:	e009      	b.n	12f84 <xQueueSemaphoreTake+0x9c>
			prvUnlockQueue( pxQueue );
   12f70:	4620      	mov	r0, r4
   12f72:	f008 f98f 	bl	1b294 <prvUnlockQueue>
			( void ) xTaskResumeAll();
   12f76:	f003 fc7f 	bl	16878 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   12f7a:	4620      	mov	r0, r4
   12f7c:	f010 fd55 	bl	23a2a <prvIsQueueEmpty>
   12f80:	2800      	cmp	r0, #0
   12f82:	d144      	bne.n	1300e <xQueueSemaphoreTake+0x126>
   12f84:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
   12f86:	f00f fefb 	bl	22d80 <vPortEnterCritical>
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
   12f8a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
   12f8c:	2b00      	cmp	r3, #0
   12f8e:	d1b6      	bne.n	12efe <xQueueSemaphoreTake+0x16>
				if( xTicksToWait == ( TickType_t ) 0 )
   12f90:	9b01      	ldr	r3, [sp, #4]
   12f92:	2b00      	cmp	r3, #0
   12f94:	d0d4      	beq.n	12f40 <xQueueSemaphoreTake+0x58>
				else if( xEntryTimeSet == pdFALSE )
   12f96:	2e00      	cmp	r6, #0
   12f98:	d0d7      	beq.n	12f4a <xQueueSemaphoreTake+0x62>
		taskEXIT_CRITICAL();
   12f9a:	f010 fe11 	bl	23bc0 <vPortExitCritical>
		vTaskSuspendAll();
   12f9e:	f010 ff4f 	bl	23e40 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   12fa2:	f00f feed 	bl	22d80 <vPortEnterCritical>
   12fa6:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
   12faa:	b25b      	sxtb	r3, r3
   12fac:	f1b3 3fff 	cmp.w	r3, #4294967295
   12fb0:	bf08      	it	eq
   12fb2:	f884 5044 	strbeq.w	r5, [r4, #68]	; 0x44
   12fb6:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
   12fba:	b25b      	sxtb	r3, r3
   12fbc:	f1b3 3fff 	cmp.w	r3, #4294967295
   12fc0:	bf08      	it	eq
   12fc2:	f884 5045 	strbeq.w	r5, [r4, #69]	; 0x45
   12fc6:	f010 fdfb 	bl	23bc0 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   12fca:	a901      	add	r1, sp, #4
   12fcc:	a802      	add	r0, sp, #8
   12fce:	f00a fbb7 	bl	1d740 <xTaskCheckForTimeOut>
   12fd2:	2800      	cmp	r0, #0
   12fd4:	d1cc      	bne.n	12f70 <xQueueSemaphoreTake+0x88>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   12fd6:	4620      	mov	r0, r4
   12fd8:	f010 fd27 	bl	23a2a <prvIsQueueEmpty>
   12fdc:	2800      	cmp	r0, #0
   12fde:	d0c1      	beq.n	12f64 <xQueueSemaphoreTake+0x7c>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   12fe0:	6823      	ldr	r3, [r4, #0]
   12fe2:	2b00      	cmp	r3, #0
   12fe4:	d0b5      	beq.n	12f52 <xQueueSemaphoreTake+0x6a>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   12fe6:	9901      	ldr	r1, [sp, #4]
   12fe8:	f104 0024 	add.w	r0, r4, #36	; 0x24
   12fec:	f010 f954 	bl	23298 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
   12ff0:	4620      	mov	r0, r4
   12ff2:	f008 f94f 	bl	1b294 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
   12ff6:	f003 fc3f 	bl	16878 <xTaskResumeAll>
   12ffa:	2800      	cmp	r0, #0
   12ffc:	d1c2      	bne.n	12f84 <xQueueSemaphoreTake+0x9c>
					portYIELD_WITHIN_API();
   12ffe:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   13002:	603b      	str	r3, [r7, #0]
   13004:	f3bf 8f4f 	dsb	sy
   13008:	f3bf 8f6f 	isb	sy
   1300c:	e7ba      	b.n	12f84 <xQueueSemaphoreTake+0x9c>
					if( xInheritanceOccurred != pdFALSE )
   1300e:	f1b8 0f00 	cmp.w	r8, #0
   13012:	f43f af7e 	beq.w	12f12 <xQueueSemaphoreTake+0x2a>
						taskENTER_CRITICAL();
   13016:	f00f feb3 	bl	22d80 <vPortEnterCritical>
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
   1301a:	6a61      	ldr	r1, [r4, #36]	; 0x24
   1301c:	b119      	cbz	r1, 13026 <xQueueSemaphoreTake+0x13e>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
   1301e:	6b23      	ldr	r3, [r4, #48]	; 0x30
   13020:	6819      	ldr	r1, [r3, #0]
   13022:	f1c1 0105 	rsb	r1, r1, #5
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
   13026:	68a0      	ldr	r0, [r4, #8]
   13028:	f008 f834 	bl	1b094 <vTaskPriorityDisinheritAfterTimeout>
						taskEXIT_CRITICAL();
   1302c:	f010 fdc8 	bl	23bc0 <vPortExitCritical>
				return errQUEUE_EMPTY;
   13030:	f04f 0800 	mov.w	r8, #0
   13034:	e76d      	b.n	12f12 <xQueueSemaphoreTake+0x2a>
   13036:	bf00      	nop
   13038:	e000ed04 	.word	0xe000ed04

Disassembly of section .text.DRV_MIIM_Tasks%292:

0001303c <DRV_MIIM_Tasks>:
    _DRV_MIIM_ObjUnlock(pMiimObj);
    return res;
}

void DRV_MIIM_Tasks( SYS_MODULE_OBJ hSysObj )
{
   1303c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    DRV_MIIM_OP_DCPT *pOpDcpt, *pHead;
    DRV_MIIM_REPORT_ACT repAct;
    DRV_MIIM_OBJ * pMiimObj = _DRV_MIIM_GetObjectAndLock(hSysObj);
   13040:	f00e fafb 	bl	2163a <_DRV_MIIM_GetObjectAndLock>

    if(pMiimObj == 0)
   13044:	2800      	cmp	r0, #0
   13046:	f000 808d 	beq.w	13164 <DRV_MIIM_Tasks+0x128>
   1304a:	4605      	mov	r5, r0
            }
            break;

        default:
            _MIIMAssertCond(false, __func__, __LINE__);
            pOpDcpt->opStat = DRV_MIIM_TXFER_ERROR;
   1304c:	f04f 0808 	mov.w	r8, #8
       GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_MPE_Msk;
    }
    
    static  __inline__ bool __attribute__((always_inline))_DRV_MIIM_IS_BUSY(uintptr_t ethPhyId)
    {
       if ((GMAC_REGS->GMAC_NSR & GMAC_NSR_IDLE_Msk) != GMAC_NSR_IDLE_Msk)
   13050:	4e4d      	ldr	r6, [pc, #308]	; (13188 <DRV_MIIM_Tasks+0x14c>)
            pOpDcpt->opStat = DRV_MIIM_TXFER_DONE;
   13052:	2705      	movs	r7, #5
    while((pOpDcpt = (DRV_MIIM_OP_DCPT*)pMiimObj->busyOpList.head) != 0)
   13054:	6fec      	ldr	r4, [r5, #124]	; 0x7c
   13056:	2c00      	cmp	r4, #0
   13058:	f000 8081 	beq.w	1315e <DRV_MIIM_Tasks+0x122>
    switch(pOpDcpt->opStat)
   1305c:	7aa3      	ldrb	r3, [r4, #10]
   1305e:	3b01      	subs	r3, #1
   13060:	2b03      	cmp	r3, #3
   13062:	d871      	bhi.n	13148 <DRV_MIIM_Tasks+0x10c>
   13064:	e8df f003 	tbb	[pc, r3]
   13068:	2c2c6002 	.word	0x2c2c6002
        GMAC_REGS->GMAC_NCR |=	GMAC_NCR_MPE_Msk;
   1306c:	6833      	ldr	r3, [r6, #0]
   1306e:	f043 0310 	orr.w	r3, r3, #16
   13072:	6033      	str	r3, [r6, #0]
       if ((GMAC_REGS->GMAC_NSR & GMAC_NSR_IDLE_Msk) != GMAC_NSR_IDLE_Msk)
   13074:	68b3      	ldr	r3, [r6, #8]
   13076:	f013 0f04 	tst.w	r3, #4
   1307a:	d021      	beq.n	130c0 <DRV_MIIM_Tasks+0x84>
            if(pOpDcpt->opType == DRV_MIIM_OP_SCAN)
   1307c:	7923      	ldrb	r3, [r4, #4]
   1307e:	2b03      	cmp	r3, #3
   13080:	d01d      	beq.n	130be <DRV_MIIM_Tasks+0x82>
            else if(pOpDcpt->opType == DRV_MIIM_OP_WRITE)
   13082:	2b02      	cmp	r3, #2
   13084:	d004      	beq.n	13090 <DRV_MIIM_Tasks+0x54>
            else if(pOpDcpt->opType == DRV_MIIM_OP_READ)
   13086:	2b01      	cmp	r3, #1
   13088:	d03f      	beq.n	1310a <DRV_MIIM_Tasks+0xce>
                pOpDcpt->opStat = DRV_MIIM_TXFER_ERROR; 
   1308a:	f884 800a 	strb.w	r8, [r4, #10]
                break;
   1308e:	e059      	b.n	13144 <DRV_MIIM_Tasks+0x108>
    {
        GMAC_REGS->GMAC_MAN = 
                                (~GMAC_MAN_WZO_Msk & GMAC_MAN_CLTTO_Msk)
                                 | (GMAC_MAN_OP(0x1)) 
                                 | GMAC_MAN_WTN(0x02) 
                                 | GMAC_MAN_PHYA(pOpDcpt->phyAdd) 
   13090:	79a3      	ldrb	r3, [r4, #6]
   13092:	05db      	lsls	r3, r3, #23
   13094:	f003 6378 	and.w	r3, r3, #260046848	; 0xf800000
                                 | GMAC_MAN_REGA(pOpDcpt->regIx) 
   13098:	7962      	ldrb	r2, [r4, #5]
   1309a:	0492      	lsls	r2, r2, #18
   1309c:	f402 02f8 	and.w	r2, r2, #8126464	; 0x7c0000
   130a0:	4313      	orrs	r3, r2
                                 | GMAC_MAN_DATA(pOpDcpt->opData);
   130a2:	8922      	ldrh	r2, [r4, #8]
   130a4:	4313      	orrs	r3, r2
   130a6:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
   130aa:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
        GMAC_REGS->GMAC_MAN = 
   130ae:	6373      	str	r3, [r6, #52]	; 0x34
                newStat = ((pOpDcpt->opFlags & DRV_MIIM_OPERATION_FLAG_DISCARD) == 0) ? DRV_MIIM_TXFER_RDWR_WAIT_COMPLETE : DRV_MIIM_TXFER_DONE;
   130b0:	79e3      	ldrb	r3, [r4, #7]
   130b2:	f003 0301 	and.w	r3, r3, #1
   130b6:	2b00      	cmp	r3, #0
   130b8:	bf0c      	ite	eq
   130ba:	2302      	moveq	r3, #2
   130bc:	2305      	movne	r3, #5
            pOpDcpt->opStat = newStat;
   130be:	72a3      	strb	r3, [r4, #10]
        if(pOpDcpt->opStat >= DRV_MIIM_TXFER_REPORT_STATE)
   130c0:	7aa3      	ldrb	r3, [r4, #10]
   130c2:	2b03      	cmp	r3, #3
   130c4:	d94b      	bls.n	1315e <DRV_MIIM_Tasks+0x122>

    _MIIMAssertCond(pClient->parentObj == pMiimObj, __func__, __LINE__);

    while(true)
    {
        if((pOpDcpt->opFlags & DRV_MIIM_OPERATION_FLAG_DISCARD) == 0)
   130c6:	79e2      	ldrb	r2, [r4, #7]
   130c8:	f012 0f01 	tst.w	r2, #1
   130cc:	d112      	bne.n	130f4 <DRV_MIIM_Tasks+0xb8>
    DRV_MIIM_CLIENT_DCPT* pClient = pOpDcpt->pOwner;
   130ce:	68e0      	ldr	r0, [r4, #12]
        {   // need to signal to client that we're done...
            if(pClient->cbackHandler != 0)
   130d0:	6882      	ldr	r2, [r0, #8]
   130d2:	2a00      	cmp	r2, #0
   130d4:	d048      	beq.n	13168 <DRV_MIIM_Tasks+0x12c>
{
    if(DRV_MIIM_TXFER_START <= pOpDcpt->opStat &&  pOpDcpt->opStat < DRV_MIIM_TXFER_SCAN_VALID)
    {
        return DRV_MIIM_RES_PENDING;
    }
    else if(pOpDcpt->opStat <= DRV_MIIM_TXFER_DONE)
   130d6:	2b05      	cmp	r3, #5
   130d8:	d939      	bls.n	1314e <DRV_MIIM_Tasks+0x112>
        {
            pOpDcpt->opStat = DRV_MIIM_TXFER_SCAN_STALE;
        }
        return DRV_MIIM_RES_OK;
    }
    else if(pOpDcpt->opStat == DRV_MIIM_TXFER_TMO_START || pOpDcpt->opStat == DRV_MIIM_TXFER_TMO_END)
   130da:	3b06      	subs	r3, #6
   130dc:	b2db      	uxtb	r3, r3
    {
        return DRV_MIIM_RES_OP_TIMEOUT_ERR;
   130de:	2b01      	cmp	r3, #1
   130e0:	bf8c      	ite	hi
   130e2:	f06f 0213 	mvnhi.w	r2, #19
   130e6:	f06f 0208 	mvnls.w	r2, #8
                (*pClient->cbackHandler)((DRV_HANDLE)pClient, pOpDcpt, opResult, pOpDcpt->opData);
   130ea:	f8d0 9008 	ldr.w	r9, [r0, #8]
   130ee:	8923      	ldrh	r3, [r4, #8]
   130f0:	4621      	mov	r1, r4
   130f2:	47c8      	blx	r9
        if(pOpDcpt->opType == DRV_MIIM_OP_SCAN)
   130f4:	7923      	ldrb	r3, [r4, #4]
   130f6:	2b03      	cmp	r3, #3
   130f8:	d031      	beq.n	1315e <DRV_MIIM_Tasks+0x122>
                _DRV_MIIM_ReleaseOpDcpt(pMiimObj, pOpDcpt, &pMiimObj->busyOpList, DRV_MIIM_QTYPE_BUSY);
   130fa:	2302      	movs	r3, #2
   130fc:	f105 027c 	add.w	r2, r5, #124	; 0x7c
   13100:	4621      	mov	r1, r4
   13102:	4628      	mov	r0, r5
   13104:	f00d f9b8 	bl	20478 <_DRV_MIIM_ReleaseOpDcpt>
                continue;
   13108:	e7a4      	b.n	13054 <DRV_MIIM_Tasks+0x18>
    static  __inline__ void __attribute__((always_inline))_DRV_MIIM_OP_READ_START(uintptr_t ethPhyId, DRV_MIIM_OP_DCPT* pOpDcpt)
    {
        GMAC_REGS->GMAC_MAN =    (~GMAC_MAN_WZO_Msk & GMAC_MAN_CLTTO_Msk) 
                                    | (GMAC_MAN_OP(0x2)) 
                                    | GMAC_MAN_WTN(0x02) 
                                    | GMAC_MAN_PHYA(pOpDcpt->phyAdd) 
   1310a:	79a3      	ldrb	r3, [r4, #6]
   1310c:	05db      	lsls	r3, r3, #23
   1310e:	f003 6378 	and.w	r3, r3, #260046848	; 0xf800000
                                    | GMAC_MAN_REGA(pOpDcpt->regIx) 
   13112:	7962      	ldrb	r2, [r4, #5]
   13114:	0492      	lsls	r2, r2, #18
   13116:	f402 02f8 	and.w	r2, r2, #8126464	; 0x7c0000
   1311a:	4313      	orrs	r3, r2
                                    | GMAC_MAN_DATA(0);
   1311c:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
   13120:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
        GMAC_REGS->GMAC_MAN =    (~GMAC_MAN_WZO_Msk & GMAC_MAN_CLTTO_Msk) 
   13124:	6373      	str	r3, [r6, #52]	; 0x34
            if(checkDiscard)
   13126:	e7c3      	b.n	130b0 <DRV_MIIM_Tasks+0x74>
       if ((GMAC_REGS->GMAC_NSR & GMAC_NSR_IDLE_Msk) != GMAC_NSR_IDLE_Msk)
   13128:	68b3      	ldr	r3, [r6, #8]
   1312a:	f013 0f04 	tst.w	r3, #4
   1312e:	d016      	beq.n	1315e <DRV_MIIM_Tasks+0x122>
            if(pOpDcpt->opType == DRV_MIIM_OP_READ)
   13130:	7923      	ldrb	r3, [r4, #4]
   13132:	2b01      	cmp	r3, #1
    }
    
                                 
    static  __inline__ uint16_t __attribute__((always_inline))_DRV_MIIM_OP_READ_DATA_GET(uintptr_t ethPhyId)
    {
       return (uint16_t)(GMAC_REGS->GMAC_MAN & GMAC_MAN_DATA_Msk) ;
   13134:	bf04      	itt	eq
   13136:	6b73      	ldreq	r3, [r6, #52]	; 0x34
   13138:	8123      	strheq	r3, [r4, #8]
       GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_MPE_Msk;
   1313a:	6833      	ldr	r3, [r6, #0]
   1313c:	f023 0310 	bic.w	r3, r3, #16
   13140:	6033      	str	r3, [r6, #0]
            pOpDcpt->opStat = DRV_MIIM_TXFER_DONE;
   13142:	72a7      	strb	r7, [r4, #10]
        if(pOpDcpt->opStat >= DRV_MIIM_TXFER_REPORT_STATE)
   13144:	7aa3      	ldrb	r3, [r4, #10]
   13146:	e7be      	b.n	130c6 <DRV_MIIM_Tasks+0x8a>
            pOpDcpt->opStat = DRV_MIIM_TXFER_ERROR;
   13148:	f884 800a 	strb.w	r8, [r4, #10]
            break;
   1314c:	e7fa      	b.n	13144 <DRV_MIIM_Tasks+0x108>
        if(scanAck && pOpDcpt->opStat == DRV_MIIM_TXFER_SCAN_VALID)
   1314e:	2b04      	cmp	r3, #4
   13150:	d001      	beq.n	13156 <DRV_MIIM_Tasks+0x11a>
        return DRV_MIIM_RES_OK;
   13152:	2200      	movs	r2, #0
   13154:	e7c9      	b.n	130ea <DRV_MIIM_Tasks+0xae>
            pOpDcpt->opStat = DRV_MIIM_TXFER_SCAN_STALE;
   13156:	2303      	movs	r3, #3
   13158:	72a3      	strb	r3, [r4, #10]
        return DRV_MIIM_RES_OK;
   1315a:	2200      	movs	r2, #0
   1315c:	e7c5      	b.n	130ea <DRV_MIIM_Tasks+0xae>
    OSAL_SEM_Post(&pMiimObj->objSem);
   1315e:	4628      	mov	r0, r5
   13160:	f010 fb14 	bl	2378c <OSAL_SEM_Post>
} 
   13164:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if(pOpDcpt->opType == DRV_MIIM_OP_SCAN)
   13168:	7923      	ldrb	r3, [r4, #4]
   1316a:	2b03      	cmp	r3, #3
   1316c:	d0f7      	beq.n	1315e <DRV_MIIM_Tasks+0x122>
    DRV_MIIM_OP_DCPT* pOpDcpt = (DRV_MIIM_OP_DCPT*)Helper_SingleListHeadRemove(pL);
   1316e:	f105 007c 	add.w	r0, r5, #124	; 0x7c
   13172:	f00f ff33 	bl	22fdc <Helper_SingleListHeadRemove>
   13176:	4604      	mov	r4, r0
    Helper_SingleListTailAdd(pL, (SGL_LIST_NODE*)pOpDcpt);
   13178:	4601      	mov	r1, r0
   1317a:	f105 0088 	add.w	r0, r5, #136	; 0x88
   1317e:	f010 f8fa 	bl	23376 <Helper_SingleListTailAdd>
    pOpDcpt->qType = qType;
   13182:	2303      	movs	r3, #3
   13184:	72e3      	strb	r3, [r4, #11]
                continue;
   13186:	e765      	b.n	13054 <DRV_MIIM_Tasks+0x18>
   13188:	42000800 	.word	0x42000800

Disassembly of section .text.TCPIP_TCP_Initialize%293:

0001318c <TCPIP_TCP_Initialize>:
{
   1318c:	b538      	push	{r3, r4, r5, lr}
   1318e:	4605      	mov	r5, r0
   13190:	460c      	mov	r4, r1
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);  // System Lock
   13192:	2000      	movs	r0, #0
   13194:	f010 faee 	bl	23774 <OSAL_CRIT_Enter>
    if(tcpLockCount == 0)
   13198:	4b44      	ldr	r3, [pc, #272]	; (132ac <TCPIP_TCP_Initialize+0x120>)
   1319a:	681b      	ldr	r3, [r3, #0]
   1319c:	2b00      	cmp	r3, #0
   1319e:	d142      	bne.n	13226 <TCPIP_TCP_Initialize+0x9a>
        if(tcpInitCount != 0 || stackInit->stackAction != TCPIP_STACK_ACTION_INIT)
   131a0:	4b43      	ldr	r3, [pc, #268]	; (132b0 <TCPIP_TCP_Initialize+0x124>)
   131a2:	681b      	ldr	r3, [r3, #0]
   131a4:	2b00      	cmp	r3, #0
   131a6:	d177      	bne.n	13298 <TCPIP_TCP_Initialize+0x10c>
   131a8:	7f2b      	ldrb	r3, [r5, #28]
   131aa:	2b00      	cmp	r3, #0
   131ac:	d174      	bne.n	13298 <TCPIP_TCP_Initialize+0x10c>
            tcpLockCount = 2;     // get a lock
   131ae:	4b3f      	ldr	r3, [pc, #252]	; (132ac <TCPIP_TCP_Initialize+0x120>)
   131b0:	2202      	movs	r2, #2
   131b2:	601a      	str	r2, [r3, #0]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);  // System unlock
   131b4:	4601      	mov	r1, r0
   131b6:	2000      	movs	r0, #0
   131b8:	f010 fc16 	bl	239e8 <OSAL_CRIT_Leave>
    if(stackInit->memH == 0 || pTcpInit == 0 || pTcpInit->nSockets == 0)
   131bc:	68e8      	ldr	r0, [r5, #12]
   131be:	2800      	cmp	r0, #0
   131c0:	d044      	beq.n	1324c <TCPIP_TCP_Initialize+0xc0>
   131c2:	2c00      	cmp	r4, #0
   131c4:	d042      	beq.n	1324c <TCPIP_TCP_Initialize+0xc0>
   131c6:	6825      	ldr	r5, [r4, #0]
   131c8:	2d00      	cmp	r5, #0
   131ca:	d03f      	beq.n	1324c <TCPIP_TCP_Initialize+0xc0>
    tcpHeapH = stackInit->memH;
   131cc:	4b39      	ldr	r3, [pc, #228]	; (132b4 <TCPIP_TCP_Initialize+0x128>)
   131ce:	6018      	str	r0, [r3, #0]
    tcpDefTxSize = pTcpInit->sktTxBuffSize;
   131d0:	88a2      	ldrh	r2, [r4, #4]
   131d2:	4b39      	ldr	r3, [pc, #228]	; (132b8 <TCPIP_TCP_Initialize+0x12c>)
   131d4:	801a      	strh	r2, [r3, #0]
    tcpDefRxSize = pTcpInit->sktRxBuffSize;
   131d6:	88e2      	ldrh	r2, [r4, #6]
   131d8:	4b38      	ldr	r3, [pc, #224]	; (132bc <TCPIP_TCP_Initialize+0x130>)
   131da:	801a      	strh	r2, [r3, #0]
   131dc:	6883      	ldr	r3, [r0, #8]
   131de:	2204      	movs	r2, #4
   131e0:	4629      	mov	r1, r5
   131e2:	4798      	blx	r3
    TCBStubs = (TCB_STUB**)TCPIP_HEAP_Calloc(tcpHeapH, nSockets, sizeof(*TCBStubs));
   131e4:	4b36      	ldr	r3, [pc, #216]	; (132c0 <TCPIP_TCP_Initialize+0x134>)
   131e6:	6018      	str	r0, [r3, #0]
    if(TCBStubs == 0)
   131e8:	2800      	cmp	r0, #0
   131ea:	d03c      	beq.n	13266 <TCPIP_TCP_Initialize+0xda>
    TcpSockets = nSockets;
   131ec:	4b35      	ldr	r3, [pc, #212]	; (132c4 <TCPIP_TCP_Initialize+0x138>)
   131ee:	601d      	str	r5, [r3, #0]
    tcpSignalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_TCP_Task, TCPIP_TCP_TASK_TICK_RATE);
   131f0:	2205      	movs	r2, #5
   131f2:	4935      	ldr	r1, [pc, #212]	; (132c8 <TCPIP_TCP_Initialize+0x13c>)
   131f4:	200a      	movs	r0, #10
   131f6:	f00b fdd3 	bl	1eda0 <_TCPIPStackSignalHandlerRegister>
   131fa:	4b34      	ldr	r3, [pc, #208]	; (132cc <TCPIP_TCP_Initialize+0x140>)
   131fc:	6018      	str	r0, [r3, #0]
    if(tcpSignalHandle == 0)
   131fe:	2800      	cmp	r0, #0
   13200:	d03e      	beq.n	13280 <TCPIP_TCP_Initialize+0xf4>
    tcpInitCount++;
   13202:	4a2b      	ldr	r2, [pc, #172]	; (132b0 <TCPIP_TCP_Initialize+0x124>)
   13204:	6813      	ldr	r3, [r2, #0]
   13206:	3301      	adds	r3, #1
   13208:	6013      	str	r3, [r2, #0]
    tcpSemaphoreEnabled = OSAL_SEM_Create(&tcpSemaphore, OSAL_SEM_TYPE_BINARY, 1, 1) == OSAL_RESULT_TRUE;
   1320a:	2301      	movs	r3, #1
   1320c:	461a      	mov	r2, r3
   1320e:	2100      	movs	r1, #0
   13210:	482f      	ldr	r0, [pc, #188]	; (132d0 <TCPIP_TCP_Initialize+0x144>)
   13212:	f00a fc55 	bl	1dac0 <OSAL_SEM_Create>
    if(!tcpSemaphoreEnabled)
   13216:	2801      	cmp	r0, #1
   13218:	d138      	bne.n	1328c <TCPIP_TCP_Initialize+0x100>
    tcpInitCount = 1; // initialized
   1321a:	2401      	movs	r4, #1
   1321c:	4b24      	ldr	r3, [pc, #144]	; (132b0 <TCPIP_TCP_Initialize+0x124>)
   1321e:	601c      	str	r4, [r3, #0]
    tcpLockCount = 1; // release the lock
   13220:	4b22      	ldr	r3, [pc, #136]	; (132ac <TCPIP_TCP_Initialize+0x120>)
   13222:	601c      	str	r4, [r3, #0]
    return true;
   13224:	e03d      	b.n	132a2 <TCPIP_TCP_Initialize+0x116>
    else if(tcpLockCount == 1)
   13226:	2b01      	cmp	r3, #1
   13228:	d005      	beq.n	13236 <TCPIP_TCP_Initialize+0xaa>
    bool    initRes = false;
   1322a:	2400      	movs	r4, #0
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);  // System unlock
   1322c:	4601      	mov	r1, r0
   1322e:	2000      	movs	r0, #0
   13230:	f010 fbda 	bl	239e8 <OSAL_CRIT_Leave>
    if(initFault)
   13234:	e035      	b.n	132a2 <TCPIP_TCP_Initialize+0x116>
        if(tcpInitCount <= 0)
   13236:	4b1e      	ldr	r3, [pc, #120]	; (132b0 <TCPIP_TCP_Initialize+0x124>)
   13238:	681b      	ldr	r3, [r3, #0]
   1323a:	2b00      	cmp	r3, #0
   1323c:	dd2c      	ble.n	13298 <TCPIP_TCP_Initialize+0x10c>
            if(stackInit->stackAction == TCPIP_STACK_ACTION_INIT)
   1323e:	7f2a      	ldrb	r2, [r5, #28]
   13240:	bb8a      	cbnz	r2, 132a6 <TCPIP_TCP_Initialize+0x11a>
                tcpInitCount++;
   13242:	3301      	adds	r3, #1
   13244:	4a1a      	ldr	r2, [pc, #104]	; (132b0 <TCPIP_TCP_Initialize+0x124>)
   13246:	6013      	str	r3, [r2, #0]
            initRes = true;
   13248:	2401      	movs	r4, #1
   1324a:	e7ef      	b.n	1322c <TCPIP_TCP_Initialize+0xa0>
        SYS_ERROR(SYS_ERROR_ERROR, "TCP NULL dynamic allocation handle/init data");
   1324c:	f011 f818 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
   13250:	b918      	cbnz	r0, 1325a <TCPIP_TCP_Initialize+0xce>
        tcpLockCount = 0; // leave it uninitialized
   13252:	2400      	movs	r4, #0
   13254:	4b15      	ldr	r3, [pc, #84]	; (132ac <TCPIP_TCP_Initialize+0x120>)
   13256:	601c      	str	r4, [r3, #0]
        return false;
   13258:	e023      	b.n	132a2 <TCPIP_TCP_Initialize+0x116>
        SYS_ERROR(SYS_ERROR_ERROR, "TCP NULL dynamic allocation handle/init data");
   1325a:	f011 f80b 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
   1325e:	491d      	ldr	r1, [pc, #116]	; (132d4 <TCPIP_TCP_Initialize+0x148>)
   13260:	f009 fa1c 	bl	1c69c <SYS_CONSOLE_Print>
   13264:	e7f5      	b.n	13252 <TCPIP_TCP_Initialize+0xc6>
        SYS_ERROR(SYS_ERROR_ERROR, " TCP Dynamic allocation failed");
   13266:	f011 f80b 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
   1326a:	b918      	cbnz	r0, 13274 <TCPIP_TCP_Initialize+0xe8>
        tcpLockCount = 0; // leave it uninitialized
   1326c:	2400      	movs	r4, #0
   1326e:	4b0f      	ldr	r3, [pc, #60]	; (132ac <TCPIP_TCP_Initialize+0x120>)
   13270:	601c      	str	r4, [r3, #0]
        return false;
   13272:	e016      	b.n	132a2 <TCPIP_TCP_Initialize+0x116>
        SYS_ERROR(SYS_ERROR_ERROR, " TCP Dynamic allocation failed");
   13274:	f010 fffe 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
   13278:	4917      	ldr	r1, [pc, #92]	; (132d8 <TCPIP_TCP_Initialize+0x14c>)
   1327a:	f009 fa0f 	bl	1c69c <SYS_CONSOLE_Print>
   1327e:	e7f5      	b.n	1326c <TCPIP_TCP_Initialize+0xe0>
        _TcpCleanup();
   13280:	f009 f934 	bl	1c4ec <_TcpCleanup>
        tcpLockCount = 0; // leave it uninitialized
   13284:	2400      	movs	r4, #0
   13286:	4b09      	ldr	r3, [pc, #36]	; (132ac <TCPIP_TCP_Initialize+0x120>)
   13288:	601c      	str	r4, [r3, #0]
        return false;
   1328a:	e00a      	b.n	132a2 <TCPIP_TCP_Initialize+0x116>
        _TcpCleanup();
   1328c:	f009 f92e 	bl	1c4ec <_TcpCleanup>
        tcpLockCount = 0; // leave it uninitialized
   13290:	2400      	movs	r4, #0
   13292:	4b06      	ldr	r3, [pc, #24]	; (132ac <TCPIP_TCP_Initialize+0x120>)
   13294:	601c      	str	r4, [r3, #0]
        return false;
   13296:	e004      	b.n	132a2 <TCPIP_TCP_Initialize+0x116>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);  // System unlock
   13298:	4601      	mov	r1, r0
   1329a:	2000      	movs	r0, #0
   1329c:	f010 fba4 	bl	239e8 <OSAL_CRIT_Leave>
        return false;
   132a0:	2400      	movs	r4, #0
}
   132a2:	4620      	mov	r0, r4
   132a4:	bd38      	pop	{r3, r4, r5, pc}
            initRes = true;
   132a6:	2401      	movs	r4, #1
   132a8:	e7c0      	b.n	1322c <TCPIP_TCP_Initialize+0xa0>
   132aa:	bf00      	nop
   132ac:	2000edd0 	.word	0x2000edd0
   132b0:	2000edcc 	.word	0x2000edcc
   132b4:	2000edc8 	.word	0x2000edc8
   132b8:	2000ed2a 	.word	0x2000ed2a
   132bc:	2000eda2 	.word	0x2000eda2
   132c0:	2000edc0 	.word	0x2000edc0
   132c4:	2000edc4 	.word	0x2000edc4
   132c8:	00001a55 	.word	0x00001a55
   132cc:	2000edd8 	.word	0x2000edd8
   132d0:	2000edd4 	.word	0x2000edd4
   132d4:	0001e29c 	.word	0x0001e29c
   132d8:	0001e2cc 	.word	0x0001e2cc

Disassembly of section .text.wc_Sha256Update%294:

000132dc <wc_Sha256Update>:
    {
   132dc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        if (sha256 == NULL || (data == NULL && len > 0)) {
   132e0:	2800      	cmp	r0, #0
   132e2:	f000 8097 	beq.w	13414 <wc_Sha256Update+0x138>
   132e6:	460d      	mov	r5, r1
   132e8:	4616      	mov	r6, r2
   132ea:	4604      	mov	r4, r0
   132ec:	b1f9      	cbz	r1, 1332e <wc_Sha256Update+0x52>
        if (sha256->devId != INVALID_DEVID) {
   132ee:	6f03      	ldr	r3, [r0, #112]	; 0x70
   132f0:	f113 0f02 	cmn.w	r3, #2
   132f4:	d007      	beq.n	13306 <wc_Sha256Update+0x2a>
            int ret = wc_CryptoCb_Sha256Hash(sha256, data, len, NULL);
   132f6:	2300      	movs	r3, #0
   132f8:	f009 fa72 	bl	1c7e0 <wc_CryptoCb_Sha256Hash>
   132fc:	4603      	mov	r3, r0
            if (ret != CRYPTOCB_UNAVAILABLE)
   132fe:	f46f 7287 	mvn.w	r2, #270	; 0x10e
   13302:	4290      	cmp	r0, r2
   13304:	d118      	bne.n	13338 <wc_Sha256Update+0x5c>
        if (sha256->buffLen >= WC_SHA256_BLOCK_SIZE) {
   13306:	6e20      	ldr	r0, [r4, #96]	; 0x60
   13308:	283f      	cmp	r0, #63	; 0x3f
   1330a:	f200 8086 	bhi.w	1341a <wc_Sha256Update+0x13e>
        word32 tmp = sha256->loLen;
   1330e:	6e62      	ldr	r2, [r4, #100]	; 0x64
        if ((sha256->loLen += len) < tmp) {
   13310:	18b3      	adds	r3, r6, r2
   13312:	6663      	str	r3, [r4, #100]	; 0x64
   13314:	429a      	cmp	r2, r3
   13316:	d902      	bls.n	1331e <wc_Sha256Update+0x42>
            sha256->hiLen++;                       /* carry low to high */
   13318:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   1331a:	3301      	adds	r3, #1
   1331c:	66a3      	str	r3, [r4, #104]	; 0x68
        local = (byte*)sha256->buffer;
   1331e:	f104 0720 	add.w	r7, r4, #32
        if (sha256->buffLen > 0) {
   13322:	b960      	cbnz	r0, 1333e <wc_Sha256Update+0x62>
            while (len >= WC_SHA256_BLOCK_SIZE) {
   13324:	2e3f      	cmp	r6, #63	; 0x3f
   13326:	d96a      	bls.n	133fe <wc_Sha256Update+0x122>
   13328:	f104 085c 	add.w	r8, r4, #92	; 0x5c
   1332c:	e03e      	b.n	133ac <wc_Sha256Update+0xd0>
            return 0;
   1332e:	2a00      	cmp	r2, #0
   13330:	bf14      	ite	ne
   13332:	f06f 03ac 	mvnne.w	r3, #172	; 0xac
   13336:	2300      	moveq	r3, #0
    }
   13338:	4618      	mov	r0, r3
   1333a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            blocksLen = min(len, WC_SHA256_BLOCK_SIZE - sha256->buffLen);
   1333e:	f1c0 0840 	rsb	r8, r0, #64	; 0x40
        #define min min
    #endif
    /* returns the smaller of a and b */
    WC_STATIC WC_INLINE word32 min(word32 a, word32 b)
    {
        return a > b ? b : a;
   13342:	45b0      	cmp	r8, r6
   13344:	bf28      	it	cs
   13346:	46b0      	movcs	r8, r6
            XMEMCPY(&local[sha256->buffLen], data, blocksLen);
   13348:	4642      	mov	r2, r8
   1334a:	4629      	mov	r1, r5
   1334c:	4438      	add	r0, r7
   1334e:	f00f ffcd 	bl	232ec <memcpy>
            sha256->buffLen += blocksLen;
   13352:	6e23      	ldr	r3, [r4, #96]	; 0x60
   13354:	4443      	add	r3, r8
   13356:	6623      	str	r3, [r4, #96]	; 0x60
            data            += blocksLen;
   13358:	4445      	add	r5, r8
            len             -= blocksLen;
   1335a:	eba6 0608 	sub.w	r6, r6, r8
            if (sha256->buffLen == WC_SHA256_BLOCK_SIZE) {
   1335e:	2b40      	cmp	r3, #64	; 0x40
   13360:	d1e0      	bne.n	13324 <wc_Sha256Update+0x48>
   13362:	f104 011c 	add.w	r1, r4, #28
   13366:	f104 005c 	add.w	r0, r4, #92	; 0x5c
        out[i] = ByteReverseWord32(in[i]);
   1336a:	f851 2f04 	ldr.w	r2, [r1, #4]!
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
   1336e:	0a13      	lsrs	r3, r2, #8
   13370:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
   13374:	0212      	lsls	r2, r2, #8
   13376:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
   1337a:	4313      	orrs	r3, r2
        return (x << y) | (x >> (sizeof(y) * 8 - y));
   1337c:	ea4f 4333 	mov.w	r3, r3, ror #16
        out[i] = ByteReverseWord32(in[i]);
   13380:	600b      	str	r3, [r1, #0]
    for (i = 0; i < count; i++)
   13382:	4281      	cmp	r1, r0
   13384:	d1f1      	bne.n	1336a <wc_Sha256Update+0x8e>
                ret = XTRANSFORM(sha256, (const byte*)local);
   13386:	4639      	mov	r1, r7
   13388:	4620      	mov	r0, r4
   1338a:	f7f9 f903 	bl	c594 <Transform_Sha256>
                if (ret == 0)
   1338e:	4603      	mov	r3, r0
   13390:	2800      	cmp	r0, #0
   13392:	d1d1      	bne.n	13338 <wc_Sha256Update+0x5c>
                    sha256->buffLen = 0;
   13394:	2300      	movs	r3, #0
   13396:	6623      	str	r3, [r4, #96]	; 0x60
   13398:	e7c4      	b.n	13324 <wc_Sha256Update+0x48>
                ret = XTRANSFORM(sha256, (const byte*)local32);
   1339a:	4639      	mov	r1, r7
   1339c:	4620      	mov	r0, r4
   1339e:	f7f9 f8f9 	bl	c594 <Transform_Sha256>
                if (ret != 0)
   133a2:	4603      	mov	r3, r0
   133a4:	2800      	cmp	r0, #0
   133a6:	d1c7      	bne.n	13338 <wc_Sha256Update+0x5c>
            while (len >= WC_SHA256_BLOCK_SIZE) {
   133a8:	2e3f      	cmp	r6, #63	; 0x3f
   133aa:	d928      	bls.n	133fe <wc_Sha256Update+0x122>
                    XMEMCPY(local32, data, WC_SHA256_BLOCK_SIZE);
   133ac:	462b      	mov	r3, r5
   133ae:	463a      	mov	r2, r7
   133b0:	f105 0140 	add.w	r1, r5, #64	; 0x40
   133b4:	f8d3 9000 	ldr.w	r9, [r3]
   133b8:	f8d3 e004 	ldr.w	lr, [r3, #4]
   133bc:	f8d3 c008 	ldr.w	ip, [r3, #8]
   133c0:	68d8      	ldr	r0, [r3, #12]
   133c2:	f8c2 9000 	str.w	r9, [r2]
   133c6:	f8c2 e004 	str.w	lr, [r2, #4]
   133ca:	f8c2 c008 	str.w	ip, [r2, #8]
   133ce:	60d0      	str	r0, [r2, #12]
   133d0:	3310      	adds	r3, #16
   133d2:	3210      	adds	r2, #16
   133d4:	428b      	cmp	r3, r1
   133d6:	d1ed      	bne.n	133b4 <wc_Sha256Update+0xd8>
                data += WC_SHA256_BLOCK_SIZE;
   133d8:	3540      	adds	r5, #64	; 0x40
                len  -= WC_SHA256_BLOCK_SIZE;
   133da:	3e40      	subs	r6, #64	; 0x40
   133dc:	f104 011c 	add.w	r1, r4, #28
        out[i] = ByteReverseWord32(in[i]);
   133e0:	f851 2f04 	ldr.w	r2, [r1, #4]!
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
   133e4:	0a13      	lsrs	r3, r2, #8
   133e6:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
   133ea:	0212      	lsls	r2, r2, #8
   133ec:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
   133f0:	4313      	orrs	r3, r2
        return (x << y) | (x >> (sizeof(y) * 8 - y));
   133f2:	ea4f 4333 	mov.w	r3, r3, ror #16
        out[i] = ByteReverseWord32(in[i]);
   133f6:	600b      	str	r3, [r1, #0]
    for (i = 0; i < count; i++)
   133f8:	4588      	cmp	r8, r1
   133fa:	d1f1      	bne.n	133e0 <wc_Sha256Update+0x104>
   133fc:	e7cd      	b.n	1339a <wc_Sha256Update+0xbe>
        if (ret == 0 && len > 0) {
   133fe:	b90e      	cbnz	r6, 13404 <wc_Sha256Update+0x128>
        return ret;
   13400:	2300      	movs	r3, #0
   13402:	e799      	b.n	13338 <wc_Sha256Update+0x5c>
            XMEMCPY(local, data, len);
   13404:	4632      	mov	r2, r6
   13406:	4629      	mov	r1, r5
   13408:	4638      	mov	r0, r7
   1340a:	f00f ff6f 	bl	232ec <memcpy>
            sha256->buffLen = len;
   1340e:	6626      	str	r6, [r4, #96]	; 0x60
        return ret;
   13410:	2300      	movs	r3, #0
   13412:	e791      	b.n	13338 <wc_Sha256Update+0x5c>
            return BAD_FUNC_ARG;
   13414:	f06f 03ac 	mvn.w	r3, #172	; 0xac
   13418:	e78e      	b.n	13338 <wc_Sha256Update+0x5c>
            return BUFFER_E;
   1341a:	f06f 0383 	mvn.w	r3, #131	; 0x83
   1341e:	e78b      	b.n	13338 <wc_Sha256Update+0x5c>

Disassembly of section .text.Hash_df%295:

00013420 <Hash_df>:
{
   13420:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13424:	b0ad      	sub	sp, #180	; 0xb4
   13426:	4690      	mov	r8, r2
   13428:	f8dd a0e0 	ldr.w	sl, [sp, #224]	; 0xe0
   1342c:	f88d 3007 	strb.w	r3, [sp, #7]
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
   13430:	f3c2 1357 	ubfx	r3, r2, #5, #24
   13434:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
   13438:	02d2      	lsls	r2, r2, #11
   1343a:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
   1343e:	4313      	orrs	r3, r2
        return (x << y) | (x >> (sizeof(y) * 8 - y));
   13440:	ea4f 4333 	mov.w	r3, r3, ror #16
    bits = ByteReverseWord32(bits);
   13444:	932a      	str	r3, [sp, #168]	; 0xa8
        + ((outSz % OUTPUT_BLOCK_LEN) ? 1 : 0);
   13446:	f018 091f 	ands.w	r9, r8, #31
   1344a:	bf18      	it	ne
   1344c:	f04f 0901 	movne.w	r9, #1
    for (i = 0, ctr = 1; i < len; i++, ctr++) {
   13450:	2301      	movs	r3, #1
   13452:	f88d 30af 	strb.w	r3, [sp, #175]	; 0xaf
   13456:	eb19 1958 	adds.w	r9, r9, r8, lsr #5
   1345a:	d070      	beq.n	1353e <Hash_df+0x11e>
   1345c:	4607      	mov	r7, r0
   1345e:	460d      	mov	r5, r1
   13460:	2600      	movs	r6, #0
            ret = wc_Sha256Update(sha, &ctr, sizeof(ctr));
   13462:	469b      	mov	fp, r3
   13464:	e03e      	b.n	134e4 <Hash_df+0xc4>
            ret = wc_Sha256Update(sha, (byte*)&bits, sizeof(bits));
   13466:	2204      	movs	r2, #4
   13468:	a92a      	add	r1, sp, #168	; 0xa8
   1346a:	a80b      	add	r0, sp, #44	; 0x2c
   1346c:	f7ff ff36 	bl	132dc <wc_Sha256Update>
        if (ret == 0) {
   13470:	4604      	mov	r4, r0
   13472:	2800      	cmp	r0, #0
   13474:	d146      	bne.n	13504 <Hash_df+0xe4>
            if (type != drbgInitV)
   13476:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1347a:	2b04      	cmp	r3, #4
   1347c:	d146      	bne.n	1350c <Hash_df+0xec>
            ret = wc_Sha256Update(sha, inA, inASz);
   1347e:	9a37      	ldr	r2, [sp, #220]	; 0xdc
   13480:	9936      	ldr	r1, [sp, #216]	; 0xd8
   13482:	a80b      	add	r0, sp, #44	; 0x2c
   13484:	f7ff ff2a 	bl	132dc <wc_Sha256Update>
        if (ret == 0) {
   13488:	4604      	mov	r4, r0
   1348a:	2800      	cmp	r0, #0
   1348c:	d13a      	bne.n	13504 <Hash_df+0xe4>
            if (inB != NULL && inBSz > 0)
   1348e:	f1ba 0f00 	cmp.w	sl, #0
   13492:	d002      	beq.n	1349a <Hash_df+0x7a>
   13494:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   13496:	2b00      	cmp	r3, #0
   13498:	d142      	bne.n	13520 <Hash_df+0x100>
            ret = wc_Sha256Final(sha, digest);
   1349a:	a903      	add	r1, sp, #12
   1349c:	a80b      	add	r0, sp, #44	; 0x2c
   1349e:	f7fe fc91 	bl	11dc4 <wc_Sha256Final>
   134a2:	4604      	mov	r4, r0
        wc_Sha256Free(sha);
   134a4:	a80b      	add	r0, sp, #44	; 0x2c
   134a6:	f00a fbe2 	bl	1dc6e <wc_Sha256Free>
        if (ret == 0) {
   134aa:	b99c      	cbnz	r4, 134d4 <Hash_df+0xb4>
            if (outSz > OUTPUT_BLOCK_LEN) {
   134ac:	f1b8 0f20 	cmp.w	r8, #32
   134b0:	d93f      	bls.n	13532 <Hash_df+0x112>
                XMEMCPY(out, digest, OUTPUT_BLOCK_LEN);
   134b2:	f10d 0c0c 	add.w	ip, sp, #12
   134b6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   134ba:	6028      	str	r0, [r5, #0]
   134bc:	6069      	str	r1, [r5, #4]
   134be:	60aa      	str	r2, [r5, #8]
   134c0:	60eb      	str	r3, [r5, #12]
   134c2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   134c6:	6128      	str	r0, [r5, #16]
   134c8:	6169      	str	r1, [r5, #20]
   134ca:	61aa      	str	r2, [r5, #24]
   134cc:	61eb      	str	r3, [r5, #28]
                outSz -= OUTPUT_BLOCK_LEN;
   134ce:	f1a8 0820 	sub.w	r8, r8, #32
                out += OUTPUT_BLOCK_LEN;
   134d2:	3520      	adds	r5, #32
    for (i = 0, ctr = 1; i < len; i++, ctr++) {
   134d4:	3601      	adds	r6, #1
   134d6:	f89d 30af 	ldrb.w	r3, [sp, #175]	; 0xaf
   134da:	3301      	adds	r3, #1
   134dc:	f88d 30af 	strb.w	r3, [sp, #175]	; 0xaf
   134e0:	45b1      	cmp	r9, r6
   134e2:	d02d      	beq.n	13540 <Hash_df+0x120>
        ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
   134e4:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
   134e6:	6fb9      	ldr	r1, [r7, #120]	; 0x78
   134e8:	a80b      	add	r0, sp, #44	; 0x2c
   134ea:	f009 fd45 	bl	1cf78 <wc_InitSha256_ex>
        if (ret != 0)
   134ee:	4604      	mov	r4, r0
   134f0:	bb30      	cbnz	r0, 13540 <Hash_df+0x120>
            ret = wc_Sha256Update(sha, &ctr, sizeof(ctr));
   134f2:	465a      	mov	r2, fp
   134f4:	f10d 01af 	add.w	r1, sp, #175	; 0xaf
   134f8:	a80b      	add	r0, sp, #44	; 0x2c
   134fa:	f7ff feef 	bl	132dc <wc_Sha256Update>
        if (ret == 0)
   134fe:	4604      	mov	r4, r0
   13500:	2800      	cmp	r0, #0
   13502:	d0b0      	beq.n	13466 <Hash_df+0x46>
        wc_Sha256Free(sha);
   13504:	a80b      	add	r0, sp, #44	; 0x2c
   13506:	f00a fbb2 	bl	1dc6e <wc_Sha256Free>
        if (ret == 0) {
   1350a:	e7e3      	b.n	134d4 <Hash_df+0xb4>
                ret = wc_Sha256Update(sha, &type, sizeof(type));
   1350c:	465a      	mov	r2, fp
   1350e:	f10d 0107 	add.w	r1, sp, #7
   13512:	a80b      	add	r0, sp, #44	; 0x2c
   13514:	f7ff fee2 	bl	132dc <wc_Sha256Update>
        if (ret == 0)
   13518:	4604      	mov	r4, r0
   1351a:	2800      	cmp	r0, #0
   1351c:	d1f2      	bne.n	13504 <Hash_df+0xe4>
   1351e:	e7ae      	b.n	1347e <Hash_df+0x5e>
                ret = wc_Sha256Update(sha, inB, inBSz);
   13520:	461a      	mov	r2, r3
   13522:	4651      	mov	r1, sl
   13524:	a80b      	add	r0, sp, #44	; 0x2c
   13526:	f7ff fed9 	bl	132dc <wc_Sha256Update>
        if (ret == 0)
   1352a:	4604      	mov	r4, r0
   1352c:	2800      	cmp	r0, #0
   1352e:	d1e9      	bne.n	13504 <Hash_df+0xe4>
   13530:	e7b3      	b.n	1349a <Hash_df+0x7a>
                XMEMCPY(out, digest, outSz);
   13532:	4642      	mov	r2, r8
   13534:	a903      	add	r1, sp, #12
   13536:	4628      	mov	r0, r5
   13538:	f00f fed8 	bl	232ec <memcpy>
   1353c:	e7ca      	b.n	134d4 <Hash_df+0xb4>
    int ret = DRBG_FAILURE;
   1353e:	2401      	movs	r4, #1
    volatile byte* z = (volatile byte*)mem;
   13540:	aa03      	add	r2, sp, #12
    while (len--) *z++ = 0;
   13542:	2000      	movs	r0, #0
   13544:	a90b      	add	r1, sp, #44	; 0x2c
   13546:	4613      	mov	r3, r2
   13548:	f803 0b01 	strb.w	r0, [r3], #1
   1354c:	461a      	mov	r2, r3
   1354e:	428b      	cmp	r3, r1
   13550:	d1f9      	bne.n	13546 <Hash_df+0x126>
    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
   13552:	1c20      	adds	r0, r4, #0
   13554:	bf18      	it	ne
   13556:	2001      	movne	r0, #1
}
   13558:	b02d      	add	sp, #180	; 0xb4
   1355a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

Disassembly of section .text._MACDeinit%296:

00013560 <_MACDeinit>:
{
   13560:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13564:	b08c      	sub	sp, #48	; 0x30
   13566:	4604      	mov	r4, r0
     DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, NULL);
   13568:	2200      	movs	r2, #0
   1356a:	213f      	movs	r1, #63	; 0x3f
   1356c:	f00e ffd8 	bl	22520 <DRV_PIC32CGMAC_LibSysInt_Disable>
	 DRV_PIC32CGMAC_LibClose(pMACDrv, DRV_PIC32CGMAC_CLOSE_DEFAULT);
   13570:	2100      	movs	r1, #0
   13572:	4620      	mov	r0, r4
   13574:	f00f fd16 	bl	22fa4 <DRV_PIC32CGMAC_LibClose>
     DRV_PIC32CGMAC_LibSysIntStatus_Clear(pMACDrv, GMAC_ALL_QUE_MASK);
   13578:	213f      	movs	r1, #63	; 0x3f
   1357a:	4620      	mov	r0, r4
   1357c:	f00e fc7e 	bl	21e7c <DRV_PIC32CGMAC_LibSysIntStatus_Clear>
	if(_hEventMac != hMac)
   13580:	4b45      	ldr	r3, [pc, #276]	; (13698 <_MACDeinit+0x138>)
   13582:	681b      	ldr	r3, [r3, #0]
   13584:	429c      	cmp	r4, r3
   13586:	d114      	bne.n	135b2 <_MACDeinit+0x52>
    DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, NULL);
   13588:	2200      	movs	r2, #0
   1358a:	213f      	movs	r1, #63	; 0x3f
   1358c:	4620      	mov	r0, r4
   1358e:	f00e ffc7 	bl	22520 <DRV_PIC32CGMAC_LibSysInt_Disable>
    DRV_PIC32CGMAC_LibSysIntStatus_Clear(pMACDrv, GMAC_ALL_QUE_MASK);
   13592:	213f      	movs	r1, #63	; 0x3f
   13594:	4620      	mov	r0, r4
   13596:	f00e fc71 	bl	21e7c <DRV_PIC32CGMAC_LibSysIntStatus_Clear>
	pDcpt->_TcpNotifyFnc = 0;
   1359a:	2300      	movs	r3, #0
   1359c:	6563      	str	r3, [r4, #84]	; 0x54
	pDcpt->_TcpEnabledEvents = pDcpt->_TcpPendingEvents = TCPIP_MAC_EV_NONE;
   1359e:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
   135a2:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
	pDcpt->_EthEnabledEvents = pDcpt->_EthPendingEvents = 0;
   135a6:	f8a4 3052 	strh.w	r3, [r4, #82]	; 0x52
   135aa:	f8a4 3050 	strh.w	r3, [r4, #80]	; 0x50
	_hEventMac = 0;
   135ae:	4a3a      	ldr	r2, [pc, #232]	; (13698 <_MACDeinit+0x138>)
   135b0:	6013      	str	r3, [r2, #0]
	 const DRV_ETHPHY_OBJECT_BASE* pPhyBase =  pMACDrv->sGmacData.gmacConfig.pPhyBase;
   135b2:	f8d4 50d8 	ldr.w	r5, [r4, #216]	; 0xd8
	 if(pMACDrv->sGmacData.hPhyClient != DRV_HANDLE_INVALID)
   135b6:	6920      	ldr	r0, [r4, #16]
   135b8:	f1b0 3fff 	cmp.w	r0, #4294967295
   135bc:	d004      	beq.n	135c8 <_MACDeinit+0x68>
		 pPhyBase->DRV_ETHPHY_Close(pMACDrv->sGmacData.hPhyClient);
   135be:	69ab      	ldr	r3, [r5, #24]
   135c0:	4798      	blx	r3
		 pMACDrv->sGmacData.hPhyClient = DRV_HANDLE_INVALID;
   135c2:	f04f 33ff 	mov.w	r3, #4294967295
   135c6:	6123      	str	r3, [r4, #16]
	 if(pMACDrv->sGmacData.hPhySysObject != SYS_MODULE_OBJ_INVALID)
   135c8:	68e0      	ldr	r0, [r4, #12]
   135ca:	f1b0 3fff 	cmp.w	r0, #4294967295
   135ce:	d004      	beq.n	135da <_MACDeinit+0x7a>
		 pPhyBase->DRV_ETHPHY_Deinitialize(pMACDrv->sGmacData.hPhySysObject);
   135d0:	68ab      	ldr	r3, [r5, #8]
   135d2:	4798      	blx	r3
		 pMACDrv->sGmacData.hPhySysObject = SYS_MODULE_OBJ_INVALID;
   135d4:	f04f 33ff 	mov.w	r3, #4294967295
   135d8:	60e3      	str	r3, [r4, #12]
	if(pMACDrv->sGmacData._synchF != 0)
   135da:	6b23      	ldr	r3, [r4, #48]	; 0x30
   135dc:	b11b      	cbz	r3, 135e6 <_MACDeinit+0x86>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_LOCK);
   135de:	2103      	movs	r1, #3
   135e0:	f104 0060 	add.w	r0, r4, #96	; 0x60
   135e4:	4798      	blx	r3
    _MacTxDiscardQueues(pMACDrv,TCPIP_MAC_PKT_ACK_NET_DOWN);
   135e6:	f06f 0101 	mvn.w	r1, #1
   135ea:	4620      	mov	r0, r4
   135ec:	f00b fe7a 	bl	1f2e4 <_MacTxDiscardQueues>
	if(pMACDrv->sGmacData._synchF != 0)
   135f0:	6b23      	ldr	r3, [r4, #48]	; 0x30
   135f2:	b11b      	cbz	r3, 135fc <_MACDeinit+0x9c>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_UNLOCK);
   135f4:	2104      	movs	r1, #4
   135f6:	f104 0060 	add.w	r0, r4, #96	; 0x60
   135fa:	4798      	blx	r3
        gmac_queue = pMACDrv->sGmacData.gmac_queue[queueIdx];
   135fc:	ad01      	add	r5, sp, #4
   135fe:	f104 068c 	add.w	r6, r4, #140	; 0x8c
   13602:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   13604:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   13606:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   13608:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   1360a:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
   1360e:	e885 0007 	stmia.w	r5, {r0, r1, r2}
        while((pRxPkt = (TCPIP_MAC_PACKET*)DRV_PIC32CGMAC_SingleListHeadRemove(&gmac_queue._RxQueue))!= NULL)
   13612:	a803      	add	r0, sp, #12
   13614:	f00f fcd4 	bl	22fc0 <DRV_PIC32CGMAC_SingleListHeadRemove>
   13618:	4603      	mov	r3, r0
   1361a:	b118      	cbz	r0, 13624 <_MACDeinit+0xc4>
            (*pMACDrv->sGmacData.pktFreeF)(pRxPkt);                   
   1361c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   1361e:	4618      	mov	r0, r3
   13620:	4790      	blx	r2
   13622:	e7f6      	b.n	13612 <_MACDeinit+0xb2>
        for(index = 0; index < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxDescCnt; index++ )
   13624:	f8b4 30be 	ldrh.w	r3, [r4, #190]	; 0xbe
   13628:	b30b      	cbz	r3, 1366e <_MACDeinit+0x10e>
   1362a:	2500      	movs	r5, #0
				gmac_queue.nRxDescIndex = 0;
   1362c:	462e      	mov	r6, r5
   1362e:	e011      	b.n	13654 <_MACDeinit+0xf4>
   13630:	f8ad 6028 	strh.w	r6, [sp, #40]	; 0x28
				gmac_queue.pRxPckt[index] = 0;
   13634:	9b01      	ldr	r3, [sp, #4]
   13636:	f843 6008 	str.w	r6, [r3, r8]
				gmac_queue.pRxDesc[index].rx_desc_buffaddr.val = 0;
   1363a:	9b02      	ldr	r3, [sp, #8]
   1363c:	f843 6037 	str.w	r6, [r3, r7, lsl #3]
				gmac_queue.pRxDesc[index].rx_desc_status.val = 0;
   13640:	9b02      	ldr	r3, [sp, #8]
   13642:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
   13646:	605e      	str	r6, [r3, #4]
        for(index = 0; index < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxDescCnt; index++ )
   13648:	3501      	adds	r5, #1
   1364a:	b2ed      	uxtb	r5, r5
   1364c:	f8b4 30be 	ldrh.w	r3, [r4, #190]	; 0xbe
   13650:	42ab      	cmp	r3, r5
   13652:	d90c      	bls.n	1366e <_MACDeinit+0x10e>
            if(gmac_queue.pRxPckt != NULL)
   13654:	9b01      	ldr	r3, [sp, #4]
   13656:	2b00      	cmp	r3, #0
   13658:	d0f6      	beq.n	13648 <_MACDeinit+0xe8>
				pRxPkt = gmac_queue.pRxPckt[index];
   1365a:	462f      	mov	r7, r5
   1365c:	ea4f 0885 	mov.w	r8, r5, lsl #2
   13660:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
				if(pRxPkt)
   13664:	2800      	cmp	r0, #0
   13666:	d0e3      	beq.n	13630 <_MACDeinit+0xd0>
					(*pMACDrv->sGmacData.pktFreeF)(pRxPkt);
   13668:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1366a:	4798      	blx	r3
   1366c:	e7e0      	b.n	13630 <_MACDeinit+0xd0>
        if(gmac_queue.pRxPckt != NULL)
   1366e:	9901      	ldr	r1, [sp, #4]
   13670:	b121      	cbz	r1, 1367c <_MACDeinit+0x11c>
            (*pMACDrv->sGmacData._freeF)(pMACDrv->sGmacData._AllocH, gmac_queue.pRxPckt); 
   13672:	6a23      	ldr	r3, [r4, #32]
   13674:	69a0      	ldr	r0, [r4, #24]
   13676:	4798      	blx	r3
            gmac_queue.pRxPckt = NULL;
   13678:	2300      	movs	r3, #0
   1367a:	9301      	str	r3, [sp, #4]
   1367c:	f3bf 8f5f 	dmb	sy
	if(pMACDrv->sGmacData._synchF != 0)
   13680:	6b23      	ldr	r3, [r4, #48]	; 0x30
   13682:	b11b      	cbz	r3, 1368c <_MACDeinit+0x12c>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_DELETE);
   13684:	2102      	movs	r1, #2
   13686:	f104 0060 	add.w	r0, r4, #96	; 0x60
   1368a:	4798      	blx	r3
	pMACDrv->sGmacData.sysStat = SYS_STATUS_UNINITIALIZED;
   1368c:	2300      	movs	r3, #0
   1368e:	7523      	strb	r3, [r4, #20]
	pMACDrv->sGmacData._macFlags.val = 0;
   13690:	82e3      	strh	r3, [r4, #22]
}
   13692:	b00c      	add	sp, #48	; 0x30
   13694:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   13698:	2000e6e4 	.word	0x2000e6e4

Disassembly of section .text.TCPIP_UDP_Deinitialize%297:

0001369c <TCPIP_UDP_Deinitialize>:
    if(udpInitCount == 0)
   1369c:	4b48      	ldr	r3, [pc, #288]	; (137c0 <TCPIP_UDP_Deinitialize+0x124>)
   1369e:	681b      	ldr	r3, [r3, #0]
   136a0:	b903      	cbnz	r3, 136a4 <TCPIP_UDP_Deinitialize+0x8>
   136a2:	4770      	bx	lr
{
   136a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   136a8:	b085      	sub	sp, #20
   136aa:	4683      	mov	fp, r0
    OSAL_SEM_Pend(&userSem, OSAL_WAIT_FOREVER);
   136ac:	f64f 71ff 	movw	r1, #65535	; 0xffff
   136b0:	4844      	ldr	r0, [pc, #272]	; (137c4 <TCPIP_UDP_Deinitialize+0x128>)
   136b2:	f00f fc1f 	bl	22ef4 <OSAL_SEM_Pend>
    _UDPAbortSockets(1 << stackCtrl->netIx, TCPIP_UDP_SIGNAL_IF_DOWN); 
   136b6:	f8db 3018 	ldr.w	r3, [fp, #24]
   136ba:	2601      	movs	r6, #1
   136bc:	409e      	lsls	r6, r3
    for(ix = 0; ix < nUdpSockets; ix++)
   136be:	4b42      	ldr	r3, [pc, #264]	; (137c8 <TCPIP_UDP_Deinitialize+0x12c>)
   136c0:	681b      	ldr	r3, [r3, #0]
   136c2:	2b00      	cmp	r3, #0
   136c4:	dd3f      	ble.n	13746 <TCPIP_UDP_Deinitialize+0xaa>
   136c6:	2500      	movs	r5, #0
        if((pSkt = UDPSocketDcpt[ix]) != 0)  
   136c8:	f8df 9100 	ldr.w	r9, [pc, #256]	; 137cc <TCPIP_UDP_Deinitialize+0x130>
                uint32_t sktIfMask = 1 << sktIfIx;
   136cc:	f04f 0a01 	mov.w	sl, #1
    for(ix = 0; ix < nUdpSockets; ix++)
   136d0:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 137c8 <TCPIP_UDP_Deinitialize+0x12c>
   136d4:	e004      	b.n	136e0 <TCPIP_UDP_Deinitialize+0x44>
   136d6:	3501      	adds	r5, #1
   136d8:	f8d8 3000 	ldr.w	r3, [r8]
   136dc:	429d      	cmp	r5, r3
   136de:	da32      	bge.n	13746 <TCPIP_UDP_Deinitialize+0xaa>
        if((pSkt = UDPSocketDcpt[ix]) != 0)  
   136e0:	f8d9 3000 	ldr.w	r3, [r9]
   136e4:	f853 4025 	ldr.w	r4, [r3, r5, lsl #2]
   136e8:	2c00      	cmp	r4, #0
   136ea:	d0f4      	beq.n	136d6 <TCPIP_UDP_Deinitialize+0x3a>
            sktIf = pSkt->pSktNet;
   136ec:	6a67      	ldr	r7, [r4, #36]	; 0x24
            sktIfIx = TCPIP_STACK_NetIxGet(sktIf); 
   136ee:	4638      	mov	r0, r7
   136f0:	f010 fc22 	bl	23f38 <TCPIP_STACK_NetIxGet>
            if(sktIfIx >= 0)
   136f4:	2800      	cmp	r0, #0
   136f6:	dbee      	blt.n	136d6 <TCPIP_UDP_Deinitialize+0x3a>
                uint32_t sktIfMask = 1 << sktIfIx;
   136f8:	fa0a f000 	lsl.w	r0, sl, r0
                if((sktIfMask & netMask) != 0)
   136fc:	4230      	tst	r0, r6
   136fe:	d0ea      	beq.n	136d6 <TCPIP_UDP_Deinitialize+0x3a>
                    TCPIP_UDP_Disconnect(pSkt->sktIx, true);
   13700:	4651      	mov	r1, sl
   13702:	f9b4 0012 	ldrsh.w	r0, [r4, #18]
   13706:	f005 ff19 	bl	1953c <TCPIP_UDP_Disconnect>
                    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1370a:	2000      	movs	r0, #0
   1370c:	f010 f832 	bl	23774 <OSAL_CRIT_Enter>
                    sigHandler = pSkt->sigHandler;
   13710:	6d23      	ldr	r3, [r4, #80]	; 0x50
   13712:	9301      	str	r3, [sp, #4]
                    sigParam = pSkt->sigParam;
   13714:	6d61      	ldr	r1, [r4, #84]	; 0x54
   13716:	9103      	str	r1, [sp, #12]
                    sigMask = pSkt->sigMask;
   13718:	f8b4 1058 	ldrh.w	r1, [r4, #88]	; 0x58
   1371c:	9102      	str	r1, [sp, #8]
                    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   1371e:	4601      	mov	r1, r0
   13720:	2000      	movs	r0, #0
   13722:	f010 f961 	bl	239e8 <OSAL_CRIT_Leave>
                    if(sigHandler != 0 && (sigMask & sigType) != 0)
   13726:	9a01      	ldr	r2, [sp, #4]
   13728:	2a00      	cmp	r2, #0
   1372a:	d0d4      	beq.n	136d6 <TCPIP_UDP_Deinitialize+0x3a>
   1372c:	9902      	ldr	r1, [sp, #8]
   1372e:	f411 5f00 	tst.w	r1, #8192	; 0x2000
   13732:	d0d0      	beq.n	136d6 <TCPIP_UDP_Deinitialize+0x3a>
                        (*sigHandler)(pSkt->sktIx, (TCPIP_NET_HANDLE)sktIf, sigType, sigParam);
   13734:	9b03      	ldr	r3, [sp, #12]
   13736:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   1373a:	4639      	mov	r1, r7
   1373c:	f9b4 0012 	ldrsh.w	r0, [r4, #18]
   13740:	9c01      	ldr	r4, [sp, #4]
   13742:	47a0      	blx	r4
   13744:	e7c7      	b.n	136d6 <TCPIP_UDP_Deinitialize+0x3a>
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_DEINIT)
   13746:	f89b 301c 	ldrb.w	r3, [fp, #28]
   1374a:	2b02      	cmp	r3, #2
   1374c:	d131      	bne.n	137b2 <TCPIP_UDP_Deinitialize+0x116>
        if(--udpInitCount == 0)
   1374e:	4b1c      	ldr	r3, [pc, #112]	; (137c0 <TCPIP_UDP_Deinitialize+0x124>)
   13750:	681c      	ldr	r4, [r3, #0]
   13752:	3c01      	subs	r4, #1
   13754:	601c      	str	r4, [r3, #0]
   13756:	2c00      	cmp	r4, #0
   13758:	d12b      	bne.n	137b2 <TCPIP_UDP_Deinitialize+0x116>
            for(ix = 0; ix < nUdpSockets; ix++)
   1375a:	4b1b      	ldr	r3, [pc, #108]	; (137c8 <TCPIP_UDP_Deinitialize+0x12c>)
   1375c:	681b      	ldr	r3, [r3, #0]
   1375e:	2b00      	cmp	r3, #0
   13760:	dd0e      	ble.n	13780 <TCPIP_UDP_Deinitialize+0xe4>
                pSkt = UDPSocketDcpt[ix];
   13762:	4e1a      	ldr	r6, [pc, #104]	; (137cc <TCPIP_UDP_Deinitialize+0x130>)
            for(ix = 0; ix < nUdpSockets; ix++)
   13764:	4d18      	ldr	r5, [pc, #96]	; (137c8 <TCPIP_UDP_Deinitialize+0x12c>)
   13766:	e005      	b.n	13774 <TCPIP_UDP_Deinitialize+0xd8>
                    _UDPClose(pSkt);
   13768:	f00b f8d0 	bl	1e90c <_UDPClose>
            for(ix = 0; ix < nUdpSockets; ix++)
   1376c:	3401      	adds	r4, #1
   1376e:	682b      	ldr	r3, [r5, #0]
   13770:	42a3      	cmp	r3, r4
   13772:	dd05      	ble.n	13780 <TCPIP_UDP_Deinitialize+0xe4>
                pSkt = UDPSocketDcpt[ix];
   13774:	6833      	ldr	r3, [r6, #0]
   13776:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
                if(pSkt) 
   1377a:	2800      	cmp	r0, #0
   1377c:	d1f4      	bne.n	13768 <TCPIP_UDP_Deinitialize+0xcc>
   1377e:	e7f5      	b.n	1376c <TCPIP_UDP_Deinitialize+0xd0>
            TCPIP_HEAP_Free(udpMemH, UDPSocketDcpt);
   13780:	4b13      	ldr	r3, [pc, #76]	; (137d0 <TCPIP_UDP_Deinitialize+0x134>)
   13782:	6818      	ldr	r0, [r3, #0]
   13784:	4c11      	ldr	r4, [pc, #68]	; (137cc <TCPIP_UDP_Deinitialize+0x130>)
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   13786:	68c3      	ldr	r3, [r0, #12]
   13788:	6821      	ldr	r1, [r4, #0]
   1378a:	4798      	blx	r3
            UDPSocketDcpt = 0;
   1378c:	2300      	movs	r3, #0
   1378e:	6023      	str	r3, [r4, #0]
            if(signalHandle)
   13790:	4b10      	ldr	r3, [pc, #64]	; (137d4 <TCPIP_UDP_Deinitialize+0x138>)
   13792:	6818      	ldr	r0, [r3, #0]
   13794:	b120      	cbz	r0, 137a0 <TCPIP_UDP_Deinitialize+0x104>
                _TCPIPStackSignalHandlerDeregister(signalHandle);
   13796:	f010 fbd6 	bl	23f46 <_TCPIPStackSignalHandlerDeregister>
                signalHandle = 0;
   1379a:	4b0e      	ldr	r3, [pc, #56]	; (137d4 <TCPIP_UDP_Deinitialize+0x138>)
   1379c:	2200      	movs	r2, #0
   1379e:	601a      	str	r2, [r3, #0]
            udpMemH = 0;
   137a0:	2300      	movs	r3, #0
   137a2:	4a0b      	ldr	r2, [pc, #44]	; (137d0 <TCPIP_UDP_Deinitialize+0x134>)
   137a4:	6013      	str	r3, [r2, #0]
            nUdpSockets = 0;
   137a6:	4a08      	ldr	r2, [pc, #32]	; (137c8 <TCPIP_UDP_Deinitialize+0x12c>)
   137a8:	6013      	str	r3, [r2, #0]
    OSAL_SEM_Delete(&userSem);
   137aa:	4806      	ldr	r0, [pc, #24]	; (137c4 <TCPIP_UDP_Deinitialize+0x128>)
   137ac:	f010 fa67 	bl	23c7e <OSAL_SEM_Delete>
   137b0:	e002      	b.n	137b8 <TCPIP_UDP_Deinitialize+0x11c>
    OSAL_SEM_Post(&userSem);
   137b2:	4804      	ldr	r0, [pc, #16]	; (137c4 <TCPIP_UDP_Deinitialize+0x128>)
   137b4:	f00f ffea 	bl	2378c <OSAL_SEM_Post>
}
   137b8:	b005      	add	sp, #20
   137ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   137be:	bf00      	nop
   137c0:	2000ee94 	.word	0x2000ee94
   137c4:	2000ee9c 	.word	0x2000ee9c
   137c8:	2000ee8c 	.word	0x2000ee8c
   137cc:	2000ee88 	.word	0x2000ee88
   137d0:	2000ee98 	.word	0x2000ee98
   137d4:	2000ee90 	.word	0x2000ee90

Disassembly of section .text._LoadNetworkConfig%298:

000137d8 <_LoadNetworkConfig>:
{
   137d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   137dc:	b082      	sub	sp, #8
   137de:	4605      	mov	r5, r0
   137e0:	460c      	mov	r4, r1
    if(restartIf)
   137e2:	4617      	mov	r7, r2
   137e4:	2a00      	cmp	r2, #0
   137e6:	d13b      	bne.n	13860 <_LoadNetworkConfig+0x88>
    const void*  pMacConfig = 0;             // MAC configuration save
   137e8:	2600      	movs	r6, #0
    int     netIfIx = 0;
   137ea:	46b0      	mov	r8, r6
        memset(pNetIf, 0, sizeof(*pNetIf));
   137ec:	226c      	movs	r2, #108	; 0x6c
   137ee:	2100      	movs	r1, #0
   137f0:	4620      	mov	r0, r4
   137f2:	f010 fb55 	bl	23ea0 <memset>
        if(pUsrConfig->macAddr != 0)
   137f6:	68a8      	ldr	r0, [r5, #8]
   137f8:	2800      	cmp	r0, #0
   137fa:	d03a      	beq.n	13872 <_LoadNetworkConfig+0x9a>
            TCPIP_Helper_StringToMACAddress(pUsrConfig->macAddr, pNetIf->netMACAddr.v);
   137fc:	f104 013c 	add.w	r1, r4, #60	; 0x3c
   13800:	f004 f9f2 	bl	17be8 <TCPIP_Helper_StringToMACAddress>
        TCPIP_Helper_StringToIPAddress(pUsrConfig->ipAddr, &pNetIf->DefaultIPAddr);
   13804:	f104 0118 	add.w	r1, r4, #24
   13808:	68e8      	ldr	r0, [r5, #12]
   1380a:	f001 f931 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
        TCPIP_Helper_StringToIPAddress(pUsrConfig->ipMask, &pNetIf->DefaultMask);
   1380e:	f104 011c 	add.w	r1, r4, #28
   13812:	6928      	ldr	r0, [r5, #16]
   13814:	f001 f92c 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
        TCPIP_Helper_StringToIPAddress(pUsrConfig->gateway, &pNetIf->DefaultGateway);
   13818:	f104 0120 	add.w	r1, r4, #32
   1381c:	6968      	ldr	r0, [r5, #20]
   1381e:	f001 f927 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
        TCPIP_Helper_StringToIPAddress(pUsrConfig->priDNS, &pNetIf->DefaultDNSServer[0]);
   13822:	f104 0124 	add.w	r1, r4, #36	; 0x24
   13826:	69a8      	ldr	r0, [r5, #24]
   13828:	f001 f922 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
        TCPIP_Helper_StringToIPAddress(pUsrConfig->secondDNS, &pNetIf->DefaultDNSServer[1]);
   1382c:	f104 0128 	add.w	r1, r4, #40	; 0x28
   13830:	69e8      	ldr	r0, [r5, #28]
   13832:	f001 f91d 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
        if((pNetIf->pMacObj = pUsrConfig->pMacObject) == 0)
   13836:	6aab      	ldr	r3, [r5, #40]	; 0x28
   13838:	6463      	str	r3, [r4, #68]	; 0x44
   1383a:	2b00      	cmp	r3, #0
   1383c:	d055      	beq.n	138ea <_LoadNetworkConfig+0x112>
        pNetIf->macId = pNetIf->pMacObj->macId;
   1383e:	881a      	ldrh	r2, [r3, #0]
   13840:	8062      	strh	r2, [r4, #2]
        pNetIf->macType = pNetIf->pMacObj->macType;
   13842:	789b      	ldrb	r3, [r3, #2]
   13844:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69
        if(pNetIf->macType == 0 || pNetIf->macType >= TCPIP_MAC_TYPES)
   13848:	3b01      	subs	r3, #1
   1384a:	b2db      	uxtb	r3, r3
   1384c:	2b01      	cmp	r3, #1
   1384e:	d915      	bls.n	1387c <_LoadNetworkConfig+0xa4>
            loadFault = true;       // no such MAC type
   13850:	2301      	movs	r3, #1
    if(restartIf)
   13852:	2f00      	cmp	r7, #0
   13854:	d14d      	bne.n	138f2 <_LoadNetworkConfig+0x11a>
}
   13856:	f083 0001 	eor.w	r0, r3, #1
   1385a:	b002      	add	sp, #8
   1385c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        strncpy(oldIfName, pNetIf->ifName, sizeof(oldIfName) - 1); 
   13860:	2207      	movs	r2, #7
   13862:	3162      	adds	r1, #98	; 0x62
   13864:	4668      	mov	r0, sp
   13866:	f00e fe23 	bl	224b0 <strncpy>
        pMacConfig = pNetIf->pMacConfig;
   1386a:	6d66      	ldr	r6, [r4, #84]	; 0x54
        netIfIx = pNetIf->netIfIx;
   1386c:	f8b4 8058 	ldrh.w	r8, [r4, #88]	; 0x58
   13870:	e7bc      	b.n	137ec <_LoadNetworkConfig+0x14>
            memset(pNetIf->netMACAddr.v, 0, sizeof(pNetIf->netMACAddr.v));
   13872:	2200      	movs	r2, #0
   13874:	63e2      	str	r2, [r4, #60]	; 0x3c
   13876:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
   1387a:	e7c3      	b.n	13804 <_LoadNetworkConfig+0x2c>
        memcpy(pNetIf->NetBIOSName, pUsrConfig->hostName, sizeof(tcpipNetIf[0].NetBIOSName));
   1387c:	f104 002c 	add.w	r0, r4, #44	; 0x2c
   13880:	686b      	ldr	r3, [r5, #4]
   13882:	f8d3 c000 	ldr.w	ip, [r3]
   13886:	6859      	ldr	r1, [r3, #4]
   13888:	689a      	ldr	r2, [r3, #8]
   1388a:	68db      	ldr	r3, [r3, #12]
   1388c:	f8c4 c02c 	str.w	ip, [r4, #44]	; 0x2c
   13890:	6041      	str	r1, [r0, #4]
   13892:	6082      	str	r2, [r0, #8]
   13894:	60c3      	str	r3, [r0, #12]
        TCPIP_Helper_FormatNetBIOSName(pNetIf->NetBIOSName);
   13896:	f00a fda1 	bl	1e3dc <TCPIP_Helper_FormatNetBIOSName>
        pNetIf->startFlags = pUsrConfig->startFlags;
   1389a:	8cab      	ldrh	r3, [r5, #36]	; 0x24
   1389c:	64a3      	str	r3, [r4, #72]	; 0x48
    pNetIf->Flags.bInConfig = config;
   1389e:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   138a2:	f043 0310 	orr.w	r3, r3, #16
   138a6:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
        startAddService = TCPIP_STACK_AddressServiceSelect(pNetIf, pUsrConfig->startFlags);
   138aa:	8ca9      	ldrh	r1, [r5, #36]	; 0x24
   138ac:	4620      	mov	r0, r4
   138ae:	f00c fc23 	bl	200f8 <TCPIP_STACK_AddressServiceSelect>
        if(startAddService == TCPIP_STACK_ADDRESS_SERVICE_NONE)
   138b2:	b1b0      	cbz	r0, 138e2 <_LoadNetworkConfig+0x10a>
    pNetIf->dnsServer[0].Val = pNetIf->DefaultDNSServer[0].Val;
   138b4:	6a63      	ldr	r3, [r4, #36]	; 0x24
   138b6:	6123      	str	r3, [r4, #16]
    pNetIf->dnsServer[1].Val = pNetIf->DefaultDNSServer[1].Val;
   138b8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   138ba:	6163      	str	r3, [r4, #20]
        pNetIf->Flags.bIsDNSServerAuto = 1;
   138bc:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   138c0:	f043 0320 	orr.w	r3, r3, #32
   138c4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        TCPIP_STACK_DNS_SERVICE_TYPE addDynamicNameService = TCPIP_STACK_DNSServiceSelect(pNetIf, pUsrConfig->startFlags);
   138c8:	8ca9      	ldrh	r1, [r5, #36]	; 0x24
   138ca:	4620      	mov	r0, r4
   138cc:	f00e fdca 	bl	22464 <TCPIP_STACK_DNSServiceSelect>
        if(addDynamicNameService == TCPIP_STACK_DNS_SERVICE_NONE)
   138d0:	b968      	cbnz	r0, 138ee <_LoadNetworkConfig+0x116>
            pNetIf->Flags.bIsDnsClientEnabled = 1;
   138d2:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   138d6:	f043 0308 	orr.w	r3, r3, #8
   138da:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        loadFault = false;
   138de:	2300      	movs	r3, #0
   138e0:	e7b7      	b.n	13852 <_LoadNetworkConfig+0x7a>
            TCPIP_STACK_AddressServiceDefaultSet(pNetIf);
   138e2:	4620      	mov	r0, r4
   138e4:	f00c fa9c 	bl	1fe20 <TCPIP_STACK_AddressServiceDefaultSet>
   138e8:	e7e4      	b.n	138b4 <_LoadNetworkConfig+0xdc>
            loadFault = true;       // no such MAC interface
   138ea:	2301      	movs	r3, #1
   138ec:	e7b1      	b.n	13852 <_LoadNetworkConfig+0x7a>
        loadFault = false;
   138ee:	2300      	movs	r3, #0
   138f0:	e7af      	b.n	13852 <_LoadNetworkConfig+0x7a>
        memcpy(pNetIf->ifName, oldIfName, sizeof(pNetIf->ifName)); 
   138f2:	9800      	ldr	r0, [sp, #0]
   138f4:	f8c4 0062 	str.w	r0, [r4, #98]	; 0x62
   138f8:	f8bd 0004 	ldrh.w	r0, [sp, #4]
   138fc:	f89d 1006 	ldrb.w	r1, [sp, #6]
   13900:	f8a4 0066 	strh.w	r0, [r4, #102]	; 0x66
   13904:	f884 1068 	strb.w	r1, [r4, #104]	; 0x68
        pNetIf->pMacConfig = pMacConfig;
   13908:	6566      	str	r6, [r4, #84]	; 0x54
        pNetIf->netIfIx = netIfIx;
   1390a:	f8a4 8058 	strh.w	r8, [r4, #88]	; 0x58
   1390e:	e7a2      	b.n	13856 <_LoadNetworkConfig+0x7e>

Disassembly of section .text._Command_AddressService%299:

00013910 <_Command_AddressService>:
{ 
   13910:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   13914:	4604      	mov	r4, r0
   13916:	4615      	mov	r5, r2
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   13918:	6846      	ldr	r6, [r0, #4]
    if (argc != 3)
   1391a:	2903      	cmp	r1, #3
   1391c:	d011      	beq.n	13942 <_Command_AddressService+0x32>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Usage: %s <interface> <on/off> \r\n", argv[0]);
   1391e:	4f3c      	ldr	r7, [pc, #240]	; (13a10 <_Command_AddressService+0x100>)
   13920:	6803      	ldr	r3, [r0, #0]
   13922:	685b      	ldr	r3, [r3, #4]
   13924:	6812      	ldr	r2, [r2, #0]
   13926:	f507 71ec 	add.w	r1, r7, #472	; 0x1d8
   1392a:	4630      	mov	r0, r6
   1392c:	4798      	blx	r3
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Ex: %s PIC32INT on \r\n", argv[0]);
   1392e:	6823      	ldr	r3, [r4, #0]
   13930:	685b      	ldr	r3, [r3, #4]
   13932:	682a      	ldr	r2, [r5, #0]
   13934:	f507 71fe 	add.w	r1, r7, #508	; 0x1fc
   13938:	4630      	mov	r0, r6
   1393a:	4798      	blx	r3
        return false;
   1393c:	2000      	movs	r0, #0
}
   1393e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   13942:	461f      	mov	r7, r3
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
   13944:	6850      	ldr	r0, [r2, #4]
   13946:	f00c f88d 	bl	1fa64 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
   1394a:	4681      	mov	r9, r0
   1394c:	b1a8      	cbz	r0, 1397a <_Command_AddressService+0x6a>
    if (memcmp(argv[2], "on", 2) == 0)
   1394e:	f8d5 8008 	ldr.w	r8, [r5, #8]
   13952:	2202      	movs	r2, #2
   13954:	492f      	ldr	r1, [pc, #188]	; (13a14 <_Command_AddressService+0x104>)
   13956:	4640      	mov	r0, r8
   13958:	f00f fcba 	bl	232d0 <memcmp>
   1395c:	2800      	cmp	r0, #0
   1395e:	d04b      	beq.n	139f8 <_Command_AddressService+0xe8>
    else if (memcmp(argv[2], "off", 2) == 0)
   13960:	2202      	movs	r2, #2
   13962:	492d      	ldr	r1, [pc, #180]	; (13a18 <_Command_AddressService+0x108>)
   13964:	4640      	mov	r0, r8
   13966:	f00f fcb3 	bl	232d0 <memcmp>
   1396a:	b968      	cbnz	r0, 13988 <_Command_AddressService+0x78>
    switch(svcType)
   1396c:	2f01      	cmp	r7, #1
   1396e:	d033      	beq.n	139d8 <_Command_AddressService+0xc8>
   13970:	2f03      	cmp	r7, #3
   13972:	d145      	bne.n	13a00 <_Command_AddressService+0xf0>
        svcEnable = false;
   13974:	2300      	movs	r3, #0
            addFnc = svcEnable?TCPIP_DHCPS_Enable:TCPIP_DHCPS_Disable;
   13976:	4a29      	ldr	r2, [pc, #164]	; (13a1c <_Command_AddressService+0x10c>)
   13978:	e00f      	b.n	1399a <_Command_AddressService+0x8a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface\r\n");
   1397a:	6823      	ldr	r3, [r4, #0]
   1397c:	681b      	ldr	r3, [r3, #0]
   1397e:	4928      	ldr	r1, [pc, #160]	; (13a20 <_Command_AddressService+0x110>)
   13980:	4630      	mov	r0, r6
   13982:	4798      	blx	r3
        return false;
   13984:	2000      	movs	r0, #0
   13986:	e7da      	b.n	1393e <_Command_AddressService+0x2e>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown option\r\n");
   13988:	6823      	ldr	r3, [r4, #0]
   1398a:	681b      	ldr	r3, [r3, #0]
   1398c:	4925      	ldr	r1, [pc, #148]	; (13a24 <_Command_AddressService+0x114>)
   1398e:	4630      	mov	r0, r6
   13990:	4798      	blx	r3
        return false;
   13992:	2000      	movs	r0, #0
   13994:	e7d3      	b.n	1393e <_Command_AddressService+0x2e>
        svcEnable = true;
   13996:	2301      	movs	r3, #1
            addFnc = svcEnable?TCPIP_DHCP_Enable:TCPIP_DHCP_Disable;
   13998:	4a23      	ldr	r2, [pc, #140]	; (13a28 <_Command_AddressService+0x118>)
        msgOK   = svcEnable?"enabled":"disabled";
   1399a:	b12b      	cbz	r3, 139a8 <_Command_AddressService+0x98>
   1399c:	4f1c      	ldr	r7, [pc, #112]	; (13a10 <_Command_AddressService+0x100>)
   1399e:	f507 78da 	add.w	r8, r7, #436	; 0x1b4
        msgFail = svcEnable?"enable":"disable";
   139a2:	f507 77de 	add.w	r7, r7, #444	; 0x1bc
   139a6:	e00b      	b.n	139c0 <_Command_AddressService+0xb0>
        msgOK   = svcEnable?"enabled":"disabled";
   139a8:	4f19      	ldr	r7, [pc, #100]	; (13a10 <_Command_AddressService+0x100>)
   139aa:	f507 78e2 	add.w	r8, r7, #452	; 0x1c4
        msgFail = svcEnable?"enable":"disable";
   139ae:	f507 77e8 	add.w	r7, r7, #464	; 0x1d0
   139b2:	e005      	b.n	139c0 <_Command_AddressService+0xb0>
            addFnc = svcEnable?TCPIP_DHCPS_Enable:TCPIP_DHCPS_Disable;
   139b4:	4a1d      	ldr	r2, [pc, #116]	; (13a2c <_Command_AddressService+0x11c>)
        msgOK   = svcEnable?"enabled":"disabled";
   139b6:	4f16      	ldr	r7, [pc, #88]	; (13a10 <_Command_AddressService+0x100>)
   139b8:	f507 78da 	add.w	r8, r7, #436	; 0x1b4
        msgFail = svcEnable?"enable":"disable";
   139bc:	f507 77de 	add.w	r7, r7, #444	; 0x1bc
        addRes = (*addFnc)(netH);
   139c0:	4648      	mov	r0, r9
   139c2:	4790      	blx	r2
        if(addRes)
   139c4:	b178      	cbz	r0, 139e6 <_Command_AddressService+0xd6>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "%s %s\r\n", argv[0], msgOK);
   139c6:	6823      	ldr	r3, [r4, #0]
   139c8:	685c      	ldr	r4, [r3, #4]
   139ca:	4643      	mov	r3, r8
   139cc:	682a      	ldr	r2, [r5, #0]
   139ce:	4918      	ldr	r1, [pc, #96]	; (13a30 <_Command_AddressService+0x120>)
   139d0:	4630      	mov	r0, r6
   139d2:	47a0      	blx	r4
    return true;
   139d4:	2001      	movs	r0, #1
   139d6:	e7b2      	b.n	1393e <_Command_AddressService+0x2e>
            addFnc = svcEnable?TCPIP_DHCP_Enable:TCPIP_DHCP_Disable;
   139d8:	4a16      	ldr	r2, [pc, #88]	; (13a34 <_Command_AddressService+0x124>)
        msgOK   = svcEnable?"enabled":"disabled";
   139da:	4f0d      	ldr	r7, [pc, #52]	; (13a10 <_Command_AddressService+0x100>)
   139dc:	f507 78e2 	add.w	r8, r7, #452	; 0x1c4
        msgFail = svcEnable?"enable":"disable";
   139e0:	f507 77e8 	add.w	r7, r7, #464	; 0x1d0
   139e4:	e7ec      	b.n	139c0 <_Command_AddressService+0xb0>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Failed to %s %s\r\n", msgFail, argv[0]);
   139e6:	6823      	ldr	r3, [r4, #0]
   139e8:	685c      	ldr	r4, [r3, #4]
   139ea:	682b      	ldr	r3, [r5, #0]
   139ec:	463a      	mov	r2, r7
   139ee:	4912      	ldr	r1, [pc, #72]	; (13a38 <_Command_AddressService+0x128>)
   139f0:	4630      	mov	r0, r6
   139f2:	47a0      	blx	r4
    return true;
   139f4:	2001      	movs	r0, #1
   139f6:	e7a2      	b.n	1393e <_Command_AddressService+0x2e>
    switch(svcType)
   139f8:	2f01      	cmp	r7, #1
   139fa:	d0cc      	beq.n	13996 <_Command_AddressService+0x86>
   139fc:	2f03      	cmp	r7, #3
   139fe:	d0d9      	beq.n	139b4 <_Command_AddressService+0xa4>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Unknown service %s\r\n", argv[0]);
   13a00:	6823      	ldr	r3, [r4, #0]
   13a02:	685b      	ldr	r3, [r3, #4]
   13a04:	682a      	ldr	r2, [r5, #0]
   13a06:	490d      	ldr	r1, [pc, #52]	; (13a3c <_Command_AddressService+0x12c>)
   13a08:	4630      	mov	r0, r6
   13a0a:	4798      	blx	r3
    return true;
   13a0c:	2001      	movs	r0, #1
   13a0e:	e796      	b.n	1393e <_Command_AddressService+0x2e>
   13a10:	0000028c 	.word	0x0000028c
   13a14:	000004b4 	.word	0x000004b4
   13a18:	000004b8 	.word	0x000004b8
   13a1c:	0001ede9 	.word	0x0001ede9
   13a20:	000004a0 	.word	0x000004a0
   13a24:	000004bc 	.word	0x000004bc
   13a28:	0001d5d1 	.word	0x0001d5d1
   13a2c:	0002437d 	.word	0x0002437d
   13a30:	000004d0 	.word	0x000004d0
   13a34:	0001d161 	.word	0x0001d161
   13a38:	000004d8 	.word	0x000004d8
   13a3c:	000004ec 	.word	0x000004ec

Disassembly of section .text.CommandIperfNetIf%300:

00013a40 <CommandIperfNetIf>:
{
   13a40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13a44:	b087      	sub	sp, #28
   13a46:	4682      	mov	sl, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   13a48:	6843      	ldr	r3, [r0, #4]
   13a4a:	9301      	str	r3, [sp, #4]
    ipAddr.Val = 0;
   13a4c:	2300      	movs	r3, #0
   13a4e:	9305      	str	r3, [sp, #20]
    if (argc >= 3)
   13a50:	2902      	cmp	r1, #2
   13a52:	dd5c      	ble.n	13b0e <CommandIperfNetIf+0xce>
   13a54:	4614      	mov	r4, r2
   13a56:	f1a1 0803 	sub.w	r8, r1, #3
   13a5a:	f028 0801 	bic.w	r8, r8, #1
   13a5e:	f108 0803 	add.w	r8, r8, #3
        int currIx = 1; // 1st param is always the command name, skip it
   13a62:	2601      	movs	r6, #1
    bool addFound = false;
   13a64:	9303      	str	r3, [sp, #12]
    int iperfIndex = 0;     // assume index 0 if not specified
   13a66:	4699      	mov	r9, r3
            if(strcmp(param, "-a") == 0)
   13a68:	f8df b100 	ldr.w	fp, [pc, #256]	; 13b6c <CommandIperfNetIf+0x12c>
            else if((strcmp(param, "-i") == 0) || (strcmp(param, "--index") == 0))
   13a6c:	f10b 033c 	add.w	r3, fp, #60	; 0x3c
   13a70:	9300      	str	r3, [sp, #0]
   13a72:	f10b 0340 	add.w	r3, fp, #64	; 0x40
   13a76:	9302      	str	r3, [sp, #8]
   13a78:	e014      	b.n	13aa4 <CommandIperfNetIf+0x64>
                if(!TCPIP_Helper_StringToIPAddress(paramVal, &ipAddr))
   13a7a:	a905      	add	r1, sp, #20
   13a7c:	4638      	mov	r0, r7
   13a7e:	f000 fff7 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
   13a82:	9003      	str	r0, [sp, #12]
   13a84:	b950      	cbnz	r0, 13a9c <CommandIperfNetIf+0x5c>
                    (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperfi: use a valid IP address!\r\n");
   13a86:	f8da 3000 	ldr.w	r3, [sl]
   13a8a:	681b      	ldr	r3, [r3, #0]
   13a8c:	492f      	ldr	r1, [pc, #188]	; (13b4c <CommandIperfNetIf+0x10c>)
   13a8e:	9801      	ldr	r0, [sp, #4]
   13a90:	4798      	blx	r3
                    return;
   13a92:	e042      	b.n	13b1a <CommandIperfNetIf+0xda>
                iperfIndex = atoi(paramVal);
   13a94:	4638      	mov	r0, r7
   13a96:	f010 fcd7 	bl	24448 <atoi>
   13a9a:	4681      	mov	r9, r0
            currIx += 2;
   13a9c:	3602      	adds	r6, #2
   13a9e:	3408      	adds	r4, #8
        while(currIx + 1 < argc)
   13aa0:	45b0      	cmp	r8, r6
   13aa2:	d01b      	beq.n	13adc <CommandIperfNetIf+0x9c>
            char* param = argv[currIx];
   13aa4:	6865      	ldr	r5, [r4, #4]
            char* paramVal = argv[currIx + 1];
   13aa6:	68a7      	ldr	r7, [r4, #8]
            if(strcmp(param, "-a") == 0)
   13aa8:	4929      	ldr	r1, [pc, #164]	; (13b50 <CommandIperfNetIf+0x110>)
   13aaa:	4628      	mov	r0, r5
   13aac:	f010 f8a6 	bl	23bfc <strcmp>
   13ab0:	2800      	cmp	r0, #0
   13ab2:	d0e2      	beq.n	13a7a <CommandIperfNetIf+0x3a>
            else if((strcmp(param, "-i") == 0) || (strcmp(param, "--index") == 0))
   13ab4:	9900      	ldr	r1, [sp, #0]
   13ab6:	4628      	mov	r0, r5
   13ab8:	f010 f8a0 	bl	23bfc <strcmp>
   13abc:	2800      	cmp	r0, #0
   13abe:	d0e9      	beq.n	13a94 <CommandIperfNetIf+0x54>
   13ac0:	9902      	ldr	r1, [sp, #8]
   13ac2:	4628      	mov	r0, r5
   13ac4:	f010 f89a 	bl	23bfc <strcmp>
   13ac8:	2800      	cmp	r0, #0
   13aca:	d0e3      	beq.n	13a94 <CommandIperfNetIf+0x54>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperfi: Unknown parameter\r\n");
   13acc:	f8da 3000 	ldr.w	r3, [sl]
   13ad0:	681b      	ldr	r3, [r3, #0]
   13ad2:	f10b 0148 	add.w	r1, fp, #72	; 0x48
   13ad6:	9801      	ldr	r0, [sp, #4]
   13ad8:	4798      	blx	r3
   13ada:	e7df      	b.n	13a9c <CommandIperfNetIf+0x5c>
    if (!addFound)
   13adc:	9b03      	ldr	r3, [sp, #12]
   13ade:	b1b3      	cbz	r3, 13b0e <CommandIperfNetIf+0xce>
    if(iperfIndex < 0 || iperfIndex >= nIperfSessions)
   13ae0:	f1b9 0f00 	cmp.w	r9, #0
   13ae4:	db1c      	blt.n	13b20 <CommandIperfNetIf+0xe0>
   13ae6:	4b1b      	ldr	r3, [pc, #108]	; (13b54 <CommandIperfNetIf+0x114>)
   13ae8:	681b      	ldr	r3, [r3, #0]
   13aea:	454b      	cmp	r3, r9
   13aec:	dd18      	ble.n	13b20 <CommandIperfNetIf+0xe0>
    pIState = gIperfState + iperfIndex;	
   13aee:	4a1a      	ldr	r2, [pc, #104]	; (13b58 <CommandIperfNetIf+0x118>)
   13af0:	23d8      	movs	r3, #216	; 0xd8
   13af2:	fb03 2309 	mla	r3, r3, r9, r2
    if (pIState->state != IPERF_STANDBY_STATE)
   13af6:	f893 20ce 	ldrb.w	r2, [r3, #206]	; 0xce
   13afa:	2a01      	cmp	r2, #1
   13afc:	d01a      	beq.n	13b34 <CommandIperfNetIf+0xf4>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperfi: cannot change the ip address while session: %d running!\r\n", iperfIndex);
   13afe:	f8da 3000 	ldr.w	r3, [sl]
   13b02:	685b      	ldr	r3, [r3, #4]
   13b04:	464a      	mov	r2, r9
   13b06:	4915      	ldr	r1, [pc, #84]	; (13b5c <CommandIperfNetIf+0x11c>)
   13b08:	9801      	ldr	r0, [sp, #4]
   13b0a:	4798      	blx	r3
        return;
   13b0c:	e005      	b.n	13b1a <CommandIperfNetIf+0xda>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: iperfi -a address <-i index>\r\n");
   13b0e:	f8da 3000 	ldr.w	r3, [sl]
   13b12:	681b      	ldr	r3, [r3, #0]
   13b14:	4912      	ldr	r1, [pc, #72]	; (13b60 <CommandIperfNetIf+0x120>)
   13b16:	9801      	ldr	r0, [sp, #4]
   13b18:	4798      	blx	r3
}
   13b1a:	b007      	add	sp, #28
   13b1c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: Invalid session number. Min: 0, Max: %d\r\n", nIperfSessions - 1);
   13b20:	4b0c      	ldr	r3, [pc, #48]	; (13b54 <CommandIperfNetIf+0x114>)
   13b22:	681a      	ldr	r2, [r3, #0]
   13b24:	f8da 3000 	ldr.w	r3, [sl]
   13b28:	685b      	ldr	r3, [r3, #4]
   13b2a:	3a01      	subs	r2, #1
   13b2c:	490d      	ldr	r1, [pc, #52]	; (13b64 <CommandIperfNetIf+0x124>)
   13b2e:	9801      	ldr	r0, [sp, #4]
   13b30:	4798      	blx	r3
        return;
   13b32:	e7f2      	b.n	13b1a <CommandIperfNetIf+0xda>
    pIState->localAddr.Val = ipAddr.Val;
   13b34:	9a05      	ldr	r2, [sp, #20]
   13b36:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    (*pCmdIO->pCmdApi->print)(cmdIoParam, "iperfi: OK, set the IP address to instance: %d\r\n", iperfIndex);
   13b3a:	f8da 3000 	ldr.w	r3, [sl]
   13b3e:	685b      	ldr	r3, [r3, #4]
   13b40:	464a      	mov	r2, r9
   13b42:	4909      	ldr	r1, [pc, #36]	; (13b68 <CommandIperfNetIf+0x128>)
   13b44:	9801      	ldr	r0, [sp, #4]
   13b46:	4798      	blx	r3
   13b48:	e7e7      	b.n	13b1a <CommandIperfNetIf+0xda>
   13b4a:	bf00      	nop
   13b4c:	00005c90 	.word	0x00005c90
   13b50:	00005c8c 	.word	0x00005c8c
   13b54:	2000ee24 	.word	0x2000ee24
   13b58:	2000e380 	.word	0x2000e380
   13b5c:	00005cdc 	.word	0x00005cdc
   13b60:	00005cb4 	.word	0x00005cb4
   13b64:	00005b60 	.word	0x00005b60
   13b68:	00005d20 	.word	0x00005d20
   13b6c:	00005afc 	.word	0x00005afc

Disassembly of section .text._DNS_Resolve%301:

00013b70 <_DNS_Resolve>:
{
   13b70:	b5f0      	push	{r4, r5, r6, r7, lr}
   13b72:	b085      	sub	sp, #20
    pDnsDcpt = pgDnsDcpt;
   13b74:	4b49      	ldr	r3, [pc, #292]	; (13c9c <_DNS_Resolve+0x12c>)
   13b76:	681d      	ldr	r5, [r3, #0]
    if(pDnsDcpt == 0)
   13b78:	2d00      	cmp	r5, #0
   13b7a:	d07a      	beq.n	13c72 <_DNS_Resolve+0x102>
    if(hostName == 0 || strlen(hostName) == 0 || strlen(hostName)  >= TCPIP_DNS_CLIENT_MAX_HOSTNAME_LEN)
   13b7c:	2800      	cmp	r0, #0
   13b7e:	d07b      	beq.n	13c78 <_DNS_Resolve+0x108>
   13b80:	7803      	ldrb	r3, [r0, #0]
   13b82:	2b00      	cmp	r3, #0
   13b84:	d07b      	beq.n	13c7e <_DNS_Resolve+0x10e>
   13b86:	4617      	mov	r7, r2
   13b88:	460e      	mov	r6, r1
   13b8a:	4604      	mov	r4, r0
   13b8c:	f010 f998 	bl	23ec0 <strlen>
   13b90:	283f      	cmp	r0, #63	; 0x3f
   13b92:	d877      	bhi.n	13c84 <_DNS_Resolve+0x114>
    if(TCPIP_Helper_StringToIPAddress(hostName, &ipAddr.v4Add) || TCPIP_Helper_StringToIPv6Address (hostName, &ipAddr.v6Add))
   13b94:	4669      	mov	r1, sp
   13b96:	4620      	mov	r0, r4
   13b98:	f000 ff6a 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
   13b9c:	2800      	cmp	r0, #0
   13b9e:	d174      	bne.n	13c8a <_DNS_Resolve+0x11a>
   13ba0:	4669      	mov	r1, sp
   13ba2:	4620      	mov	r0, r4
   13ba4:	f7f7 ffee 	bl	bb84 <TCPIP_Helper_StringToIPv6Address>
   13ba8:	2800      	cmp	r0, #0
   13baa:	d170      	bne.n	13c8e <_DNS_Resolve+0x11e>
    dnsHE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryLookupOrInsert(pDnsDcpt->hashDcpt, (void*)hostName);
   13bac:	4621      	mov	r1, r4
   13bae:	6828      	ldr	r0, [r5, #0]
   13bb0:	f009 f8e8 	bl	1cd84 <TCPIP_OAHASH_EntryLookupOrInsert>
    if(dnsHE == 0)
   13bb4:	4604      	mov	r4, r0
   13bb6:	2800      	cmp	r0, #0
   13bb8:	d06b      	beq.n	13c92 <_DNS_Resolve+0x122>
    if(type == TCPIP_DNS_TYPE_A)
   13bba:	2e01      	cmp	r6, #1
   13bbc:	d019      	beq.n	13bf2 <_DNS_Resolve+0x82>
        recMask = TCPIP_DNS_ADDRESS_REC_IPV4 | TCPIP_DNS_ADDRESS_REC_IPV6;
   13bbe:	2e1c      	cmp	r6, #28
   13bc0:	bf0c      	ite	eq
   13bc2:	2302      	moveq	r3, #2
   13bc4:	2303      	movne	r3, #3
    if(forceQuery == 0 && dnsHE->hEntry.flags.newEntry == 0)
   13bc6:	b9b7      	cbnz	r7, 13bf6 <_DNS_Resolve+0x86>
   13bc8:	7822      	ldrb	r2, [r4, #0]
   13bca:	f012 0f02 	tst.w	r2, #2
   13bce:	d127      	bne.n	13c20 <_DNS_Resolve+0xb0>
        if((dnsHE->recordMask & recMask) == recMask)
   13bd0:	f894 202a 	ldrb.w	r2, [r4, #42]	; 0x2a
   13bd4:	ea33 0202 	bics.w	r2, r3, r2
   13bd8:	d111      	bne.n	13bfe <_DNS_Resolve+0x8e>
            if((dnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) != 0)
   13bda:	8823      	ldrh	r3, [r4, #0]
   13bdc:	f013 0f80 	tst.w	r3, #128	; 0x80
   13be0:	d15a      	bne.n	13c98 <_DNS_Resolve+0x128>
            return (dnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_TIMEOUT) == 0 ? TCPIP_DNS_RES_PENDING : TCPIP_DNS_RES_SERVER_TMO; 
   13be2:	f403 7380 	and.w	r3, r3, #256	; 0x100
   13be6:	2b00      	cmp	r3, #0
   13be8:	bf0c      	ite	eq
   13bea:	2001      	moveq	r0, #1
   13bec:	f06f 0004 	mvnne.w	r0, #4
   13bf0:	e03a      	b.n	13c68 <_DNS_Resolve+0xf8>
        recMask = TCPIP_DNS_ADDRESS_REC_IPV4;
   13bf2:	4633      	mov	r3, r6
   13bf4:	e7e7      	b.n	13bc6 <_DNS_Resolve+0x56>
    if(dnsHE->hEntry.flags.newEntry != 0)
   13bf6:	7822      	ldrb	r2, [r4, #0]
   13bf8:	f012 0f02 	tst.w	r2, #2
   13bfc:	d110      	bne.n	13c20 <_DNS_Resolve+0xb0>
        if((recMask & TCPIP_DNS_ADDRESS_REC_IPV4) != 0)
   13bfe:	f013 0f01 	tst.w	r3, #1
            dnsHE->nIPv4Entries = 0;
   13c02:	bf1c      	itt	ne
   13c04:	2200      	movne	r2, #0
   13c06:	f884 2026 	strbne.w	r2, [r4, #38]	; 0x26
        if((recMask & TCPIP_DNS_ADDRESS_REC_IPV6) != 0)
   13c0a:	f013 0f02 	tst.w	r3, #2
            dnsHE->nIPv6Entries = 0;
   13c0e:	bf1c      	itt	ne
   13c10:	2200      	movne	r2, #0
   13c12:	f884 2027 	strbne.w	r2, [r4, #39]	; 0x27
        dnsHE->hEntry.flags.value &= ~TCPIP_DNS_FLAG_ENTRY_COMPLETE;
   13c16:	8822      	ldrh	r2, [r4, #0]
   13c18:	f022 0280 	bic.w	r2, r2, #128	; 0x80
   13c1c:	8022      	strh	r2, [r4, #0]
   13c1e:	e008      	b.n	13c32 <_DNS_Resolve+0xc2>
        dnsHE->nIPv4Entries = 0;
   13c20:	2200      	movs	r2, #0
   13c22:	f884 2026 	strb.w	r2, [r4, #38]	; 0x26
        dnsHE->nIPv6Entries = 0;
   13c26:	f884 2027 	strb.w	r2, [r4, #39]	; 0x27
        dnsHE->hEntry.flags.value &= ~(TCPIP_DNS_FLAG_ENTRY_COMPLETE | TCPIP_DNS_FLAG_ENTRY_TIMEOUT);
   13c2a:	8822      	ldrh	r2, [r4, #0]
   13c2c:	f422 72c0 	bic.w	r2, r2, #384	; 0x180
   13c30:	8022      	strh	r2, [r4, #0]
    dnsHE->ipTTL.Val = 0;
   13c32:	2200      	movs	r2, #0
   13c34:	61a2      	str	r2, [r4, #24]
    dnsHE->resolve_type = type;
   13c36:	f884 6028 	strb.w	r6, [r4, #40]	; 0x28
    dnsHE->recordMask |= recMask;
   13c3a:	f894 102a 	ldrb.w	r1, [r4, #42]	; 0x2a
   13c3e:	430b      	orrs	r3, r1
   13c40:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
    dnsHE->tRetry = dnsHE->tInsert = pDnsDcpt->dnsTime;
   13c44:	69eb      	ldr	r3, [r5, #28]
   13c46:	60a3      	str	r3, [r4, #8]
   13c48:	60e3      	str	r3, [r4, #12]
    dnsHE->currRetry = 0;
   13c4a:	f884 202b 	strb.w	r2, [r4, #43]	; 0x2b
    int retryIfs = (pDnsDcpt->strictNet == 0) ? TCPIP_STACK_NumberOfNetworksGet() : 1;
   13c4e:	686b      	ldr	r3, [r5, #4]
   13c50:	b163      	cbz	r3, 13c6c <_DNS_Resolve+0xfc>
   13c52:	2001      	movs	r0, #1
    dnsHE->nRetries = retryIfs * _TCPIP_DNS_IF_RETRY_COUNT;
   13c54:	0040      	lsls	r0, r0, #1
   13c56:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    pDnsDcpt->unsolvedEntries++;
   13c5a:	8ceb      	ldrh	r3, [r5, #38]	; 0x26
   13c5c:	3301      	adds	r3, #1
   13c5e:	84eb      	strh	r3, [r5, #38]	; 0x26
    return _DNS_Send_Query(pDnsDcpt, dnsHE);
   13c60:	4621      	mov	r1, r4
   13c62:	4628      	mov	r0, r5
   13c64:	f7fa fad4 	bl	e210 <_DNS_Send_Query>
}
   13c68:	b005      	add	sp, #20
   13c6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    int retryIfs = (pDnsDcpt->strictNet == 0) ? TCPIP_STACK_NumberOfNetworksGet() : 1;
   13c6c:	f010 fae4 	bl	24238 <TCPIP_STACK_NumberOfNetworksGet>
   13c70:	e7f0      	b.n	13c54 <_DNS_Resolve+0xe4>
        return TCPIP_DNS_RES_NO_SERVICE;
   13c72:	f06f 0005 	mvn.w	r0, #5
   13c76:	e7f7      	b.n	13c68 <_DNS_Resolve+0xf8>
        return TCPIP_DNS_RES_INVALID_HOSTNAME; 
   13c78:	f06f 0008 	mvn.w	r0, #8
   13c7c:	e7f4      	b.n	13c68 <_DNS_Resolve+0xf8>
   13c7e:	f06f 0008 	mvn.w	r0, #8
   13c82:	e7f1      	b.n	13c68 <_DNS_Resolve+0xf8>
   13c84:	f06f 0008 	mvn.w	r0, #8
   13c88:	e7ee      	b.n	13c68 <_DNS_Resolve+0xf8>
        return  TCPIP_DNS_RES_NAME_IS_IPADDRESS;
   13c8a:	2002      	movs	r0, #2
   13c8c:	e7ec      	b.n	13c68 <_DNS_Resolve+0xf8>
   13c8e:	2002      	movs	r0, #2
   13c90:	e7ea      	b.n	13c68 <_DNS_Resolve+0xf8>
        return TCPIP_DNS_RES_CACHE_FULL; 
   13c92:	f06f 0007 	mvn.w	r0, #7
   13c96:	e7e7      	b.n	13c68 <_DNS_Resolve+0xf8>
               return TCPIP_DNS_RES_OK; 
   13c98:	2000      	movs	r0, #0
   13c9a:	e7e5      	b.n	13c68 <_DNS_Resolve+0xf8>
   13c9c:	2000ee58 	.word	0x2000ee58

Disassembly of section .text.SERCOM0_SPI_WriteRead%302:

00013ca0 <SERCOM0_SPI_WriteRead>:
{
   13ca0:	b430      	push	{r4, r5}
    if((((txSize > 0U) && (pTransmitData != NULL)) || ((rxSize > 0U) && (pReceiveData != NULL))) && (sercom0SPIObj.transferIsBusy == false))
   13ca2:	460c      	mov	r4, r1
   13ca4:	2900      	cmp	r1, #0
   13ca6:	d04d      	beq.n	13d44 <SERCOM0_SPI_WriteRead+0xa4>
   13ca8:	2800      	cmp	r0, #0
   13caa:	d04b      	beq.n	13d44 <SERCOM0_SPI_WriteRead+0xa4>
   13cac:	4946      	ldr	r1, [pc, #280]	; (13dc8 <SERCOM0_SPI_WriteRead+0x128>)
   13cae:	7f09      	ldrb	r1, [r1, #28]
   13cb0:	2900      	cmp	r1, #0
   13cb2:	f040 8086 	bne.w	13dc2 <SERCOM0_SPI_WriteRead+0x122>
        if((SERCOM0_REGS->SPIM.SERCOM_CTRLB & SERCOM_SPIM_CTRLB_CHSIZE_Msk) == (uint32_t)SPI_DATA_BITS_9)
   13cb6:	4d45      	ldr	r5, [pc, #276]	; (13dcc <SERCOM0_SPI_WriteRead+0x12c>)
   13cb8:	686d      	ldr	r5, [r5, #4]
   13cba:	f005 0507 	and.w	r5, r5, #7
   13cbe:	2d01      	cmp	r5, #1
   13cc0:	d046      	beq.n	13d50 <SERCOM0_SPI_WriteRead+0xb0>
        sercom0SPIObj.txBuffer = pTransmitData;
   13cc2:	4941      	ldr	r1, [pc, #260]	; (13dc8 <SERCOM0_SPI_WriteRead+0x128>)
   13cc4:	6008      	str	r0, [r1, #0]
        sercom0SPIObj.rxBuffer = pReceiveData;
   13cc6:	604a      	str	r2, [r1, #4]
        sercom0SPIObj.rxCount = 0U;
   13cc8:	2500      	movs	r5, #0
   13cca:	614d      	str	r5, [r1, #20]
        sercom0SPIObj.txCount = 0U;
   13ccc:	618d      	str	r5, [r1, #24]
        sercom0SPIObj.dummySize = 0U;
   13cce:	610d      	str	r5, [r1, #16]
            sercom0SPIObj.txSize = 0U;
   13cd0:	42a8      	cmp	r0, r5
   13cd2:	bf08      	it	eq
   13cd4:	462c      	moveq	r4, r5
   13cd6:	608c      	str	r4, [r1, #8]
            sercom0SPIObj.rxSize = 0U;
   13cd8:	42aa      	cmp	r2, r5
   13cda:	bf18      	it	ne
   13cdc:	461d      	movne	r5, r3
   13cde:	460a      	mov	r2, r1
   13ce0:	60cd      	str	r5, [r1, #12]
        sercom0SPIObj.transferIsBusy = true;
   13ce2:	2101      	movs	r1, #1
   13ce4:	7711      	strb	r1, [r2, #28]
        while((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_RXC_Msk) == SERCOM_SPIM_INTFLAG_RXC_Msk)
   13ce6:	4a39      	ldr	r2, [pc, #228]	; (13dcc <SERCOM0_SPI_WriteRead+0x12c>)
   13ce8:	7e12      	ldrb	r2, [r2, #24]
   13cea:	f012 0f04 	tst.w	r2, #4
   13cee:	d005      	beq.n	13cfc <SERCOM0_SPI_WriteRead+0x5c>
            dummyData = SERCOM0_REGS->SPIM.SERCOM_DATA;
   13cf0:	4a36      	ldr	r2, [pc, #216]	; (13dcc <SERCOM0_SPI_WriteRead+0x12c>)
   13cf2:	6a91      	ldr	r1, [r2, #40]	; 0x28
        while((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_RXC_Msk) == SERCOM_SPIM_INTFLAG_RXC_Msk)
   13cf4:	7e11      	ldrb	r1, [r2, #24]
   13cf6:	f011 0f04 	tst.w	r1, #4
   13cfa:	d1fa      	bne.n	13cf2 <SERCOM0_SPI_WriteRead+0x52>
        SERCOM0_REGS->SPIM.SERCOM_STATUS |= (uint16_t)SERCOM_SPIM_STATUS_BUFOVF_Msk;
   13cfc:	4a33      	ldr	r2, [pc, #204]	; (13dcc <SERCOM0_SPI_WriteRead+0x12c>)
   13cfe:	8b51      	ldrh	r1, [r2, #26]
   13d00:	f041 0104 	orr.w	r1, r1, #4
   13d04:	8351      	strh	r1, [r2, #26]
        SERCOM0_REGS->SPIM.SERCOM_INTFLAG |= (uint8_t)SERCOM_SPIM_INTFLAG_ERROR_Msk;
   13d06:	7e11      	ldrb	r1, [r2, #24]
   13d08:	f041 0180 	orr.w	r1, r1, #128	; 0x80
   13d0c:	7611      	strb	r1, [r2, #24]
        if(sercom0SPIObj.rxSize > sercom0SPIObj.txSize)
   13d0e:	42a5      	cmp	r5, r4
   13d10:	d902      	bls.n	13d18 <SERCOM0_SPI_WriteRead+0x78>
            sercom0SPIObj.dummySize = sercom0SPIObj.rxSize - sercom0SPIObj.txSize;
   13d12:	1b2a      	subs	r2, r5, r4
   13d14:	492c      	ldr	r1, [pc, #176]	; (13dc8 <SERCOM0_SPI_WriteRead+0x128>)
   13d16:	610a      	str	r2, [r1, #16]
        if((SERCOM0_REGS->SPIM.SERCOM_CTRLB & SERCOM_SPIM_CTRLB_CHSIZE_Msk) == (uint32_t)SPI_DATA_BITS_8)
   13d18:	4a2c      	ldr	r2, [pc, #176]	; (13dcc <SERCOM0_SPI_WriteRead+0x12c>)
   13d1a:	6852      	ldr	r2, [r2, #4]
   13d1c:	f012 0f07 	tst.w	r2, #7
   13d20:	d12b      	bne.n	13d7a <SERCOM0_SPI_WriteRead+0xda>
            if(sercom0SPIObj.txCount < sercom0SPIObj.txSize)
   13d22:	4a29      	ldr	r2, [pc, #164]	; (13dc8 <SERCOM0_SPI_WriteRead+0x128>)
   13d24:	6992      	ldr	r2, [r2, #24]
   13d26:	42a2      	cmp	r2, r4
   13d28:	d21c      	bcs.n	13d64 <SERCOM0_SPI_WriteRead+0xc4>
                SERCOM0_REGS->SPIM.SERCOM_DATA = *((uint8_t*)sercom0SPIObj.txBuffer);
   13d2a:	7800      	ldrb	r0, [r0, #0]
   13d2c:	4927      	ldr	r1, [pc, #156]	; (13dcc <SERCOM0_SPI_WriteRead+0x12c>)
   13d2e:	6288      	str	r0, [r1, #40]	; 0x28
                sercom0SPIObj.txCount++;
   13d30:	3201      	adds	r2, #1
   13d32:	4925      	ldr	r1, [pc, #148]	; (13dc8 <SERCOM0_SPI_WriteRead+0x128>)
   13d34:	618a      	str	r2, [r1, #24]
        if(rxSize > 0U)
   13d36:	2b00      	cmp	r3, #0
   13d38:	d03b      	beq.n	13db2 <SERCOM0_SPI_WriteRead+0x112>
            SERCOM0_REGS->SPIM.SERCOM_INTENSET = (uint8_t)SERCOM_SPIM_INTENSET_RXC_Msk;
   13d3a:	4b24      	ldr	r3, [pc, #144]	; (13dcc <SERCOM0_SPI_WriteRead+0x12c>)
   13d3c:	2204      	movs	r2, #4
   13d3e:	759a      	strb	r2, [r3, #22]
        isRequestAccepted = true;
   13d40:	2101      	movs	r1, #1
   13d42:	e03b      	b.n	13dbc <SERCOM0_SPI_WriteRead+0x11c>
    if((((txSize > 0U) && (pTransmitData != NULL)) || ((rxSize > 0U) && (pReceiveData != NULL))) && (sercom0SPIObj.transferIsBusy == false))
   13d44:	2b00      	cmp	r3, #0
   13d46:	d038      	beq.n	13dba <SERCOM0_SPI_WriteRead+0x11a>
   13d48:	2a00      	cmp	r2, #0
   13d4a:	d1af      	bne.n	13cac <SERCOM0_SPI_WriteRead+0xc>
    bool isRequestAccepted = false;
   13d4c:	2100      	movs	r1, #0
   13d4e:	e035      	b.n	13dbc <SERCOM0_SPI_WriteRead+0x11c>
            if(((txSize > 0U) && ((txSize & 0x01U) != 0U)) || ((rxSize > 0U) && ((rxSize & 0x01U) != 0U)))
   13d50:	b114      	cbz	r4, 13d58 <SERCOM0_SPI_WriteRead+0xb8>
   13d52:	f014 0f01 	tst.w	r4, #1
   13d56:	d131      	bne.n	13dbc <SERCOM0_SPI_WriteRead+0x11c>
   13d58:	2b00      	cmp	r3, #0
   13d5a:	d0b2      	beq.n	13cc2 <SERCOM0_SPI_WriteRead+0x22>
   13d5c:	f013 0f01 	tst.w	r3, #1
   13d60:	d0af      	beq.n	13cc2 <SERCOM0_SPI_WriteRead+0x22>
   13d62:	e02b      	b.n	13dbc <SERCOM0_SPI_WriteRead+0x11c>
            else if(sercom0SPIObj.dummySize > 0U)
   13d64:	4a18      	ldr	r2, [pc, #96]	; (13dc8 <SERCOM0_SPI_WriteRead+0x128>)
   13d66:	6912      	ldr	r2, [r2, #16]
   13d68:	2a00      	cmp	r2, #0
   13d6a:	d0e4      	beq.n	13d36 <SERCOM0_SPI_WriteRead+0x96>
                SERCOM0_REGS->SPIM.SERCOM_DATA = 0xFFU;
   13d6c:	4917      	ldr	r1, [pc, #92]	; (13dcc <SERCOM0_SPI_WriteRead+0x12c>)
   13d6e:	20ff      	movs	r0, #255	; 0xff
   13d70:	6288      	str	r0, [r1, #40]	; 0x28
                sercom0SPIObj.dummySize--;
   13d72:	3a01      	subs	r2, #1
   13d74:	4914      	ldr	r1, [pc, #80]	; (13dc8 <SERCOM0_SPI_WriteRead+0x128>)
   13d76:	610a      	str	r2, [r1, #16]
   13d78:	e7dd      	b.n	13d36 <SERCOM0_SPI_WriteRead+0x96>
            sercom0SPIObj.txSize >>= 1U;
   13d7a:	0864      	lsrs	r4, r4, #1
   13d7c:	4a12      	ldr	r2, [pc, #72]	; (13dc8 <SERCOM0_SPI_WriteRead+0x128>)
   13d7e:	6094      	str	r4, [r2, #8]
            sercom0SPIObj.dummySize >>= 1U;
   13d80:	6911      	ldr	r1, [r2, #16]
   13d82:	0849      	lsrs	r1, r1, #1
   13d84:	6111      	str	r1, [r2, #16]
            sercom0SPIObj.rxSize >>= 1U;
   13d86:	086d      	lsrs	r5, r5, #1
   13d88:	60d5      	str	r5, [r2, #12]
            if(sercom0SPIObj.txCount < sercom0SPIObj.txSize)
   13d8a:	6992      	ldr	r2, [r2, #24]
   13d8c:	4294      	cmp	r4, r2
   13d8e:	d906      	bls.n	13d9e <SERCOM0_SPI_WriteRead+0xfe>
                SERCOM0_REGS->SPIM.SERCOM_DATA = *((uint16_t*)sercom0SPIObj.txBuffer) & SERCOM_SPIM_DATA_Msk;
   13d90:	8800      	ldrh	r0, [r0, #0]
   13d92:	490e      	ldr	r1, [pc, #56]	; (13dcc <SERCOM0_SPI_WriteRead+0x12c>)
   13d94:	6288      	str	r0, [r1, #40]	; 0x28
                sercom0SPIObj.txCount++;
   13d96:	3201      	adds	r2, #1
   13d98:	490b      	ldr	r1, [pc, #44]	; (13dc8 <SERCOM0_SPI_WriteRead+0x128>)
   13d9a:	618a      	str	r2, [r1, #24]
   13d9c:	e7cb      	b.n	13d36 <SERCOM0_SPI_WriteRead+0x96>
            else if(sercom0SPIObj.dummySize > 0U)
   13d9e:	2900      	cmp	r1, #0
   13da0:	d0c9      	beq.n	13d36 <SERCOM0_SPI_WriteRead+0x96>
                SERCOM0_REGS->SPIM.SERCOM_DATA = 0xFFFFU & SERCOM_SPIM_DATA_Msk;
   13da2:	4a0a      	ldr	r2, [pc, #40]	; (13dcc <SERCOM0_SPI_WriteRead+0x12c>)
   13da4:	f64f 70ff 	movw	r0, #65535	; 0xffff
   13da8:	6290      	str	r0, [r2, #40]	; 0x28
                sercom0SPIObj.dummySize--;
   13daa:	3901      	subs	r1, #1
   13dac:	4a06      	ldr	r2, [pc, #24]	; (13dc8 <SERCOM0_SPI_WriteRead+0x128>)
   13dae:	6111      	str	r1, [r2, #16]
   13db0:	e7c1      	b.n	13d36 <SERCOM0_SPI_WriteRead+0x96>
            SERCOM0_REGS->SPIM.SERCOM_INTENSET = (uint8_t)SERCOM_SPIM_INTENSET_DRE_Msk;
   13db2:	2101      	movs	r1, #1
   13db4:	4b05      	ldr	r3, [pc, #20]	; (13dcc <SERCOM0_SPI_WriteRead+0x12c>)
   13db6:	7599      	strb	r1, [r3, #22]
   13db8:	e000      	b.n	13dbc <SERCOM0_SPI_WriteRead+0x11c>
    bool isRequestAccepted = false;
   13dba:	2100      	movs	r1, #0
}
   13dbc:	4608      	mov	r0, r1
   13dbe:	bc30      	pop	{r4, r5}
   13dc0:	4770      	bx	lr
    bool isRequestAccepted = false;
   13dc2:	2100      	movs	r1, #0
   13dc4:	e7fa      	b.n	13dbc <SERCOM0_SPI_WriteRead+0x11c>
   13dc6:	bf00      	nop
   13dc8:	2000ea6c 	.word	0x2000ea6c
   13dcc:	40003000 	.word	0x40003000

Disassembly of section .text.__multiply%303:

00013dd0 <__multiply>:
   13dd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13dd4:	4615      	mov	r5, r2
   13dd6:	690a      	ldr	r2, [r1, #16]
   13dd8:	692b      	ldr	r3, [r5, #16]
   13dda:	429a      	cmp	r2, r3
   13ddc:	460c      	mov	r4, r1
   13dde:	bfbc      	itt	lt
   13de0:	462c      	movlt	r4, r5
   13de2:	460d      	movlt	r5, r1
   13de4:	f8d4 9010 	ldr.w	r9, [r4, #16]
   13de8:	f8d5 8010 	ldr.w	r8, [r5, #16]
   13dec:	68a3      	ldr	r3, [r4, #8]
   13dee:	6861      	ldr	r1, [r4, #4]
   13df0:	eb09 0708 	add.w	r7, r9, r8
   13df4:	42bb      	cmp	r3, r7
   13df6:	b085      	sub	sp, #20
   13df8:	bfb8      	it	lt
   13dfa:	3101      	addlt	r1, #1
   13dfc:	f008 fec6 	bl	1cb8c <_Balloc>
   13e00:	f100 0614 	add.w	r6, r0, #20
   13e04:	eb06 0e87 	add.w	lr, r6, r7, lsl #2
   13e08:	4633      	mov	r3, r6
   13e0a:	2200      	movs	r2, #0
   13e0c:	4573      	cmp	r3, lr
   13e0e:	d319      	bcc.n	13e44 <__multiply+0x74>
   13e10:	f104 0314 	add.w	r3, r4, #20
   13e14:	eb03 0389 	add.w	r3, r3, r9, lsl #2
   13e18:	f105 0214 	add.w	r2, r5, #20
   13e1c:	9300      	str	r3, [sp, #0]
   13e1e:	eb02 0388 	add.w	r3, r2, r8, lsl #2
   13e22:	9301      	str	r3, [sp, #4]
   13e24:	f64f 75ff 	movw	r5, #65535	; 0xffff
   13e28:	9b01      	ldr	r3, [sp, #4]
   13e2a:	9202      	str	r2, [sp, #8]
   13e2c:	4293      	cmp	r3, r2
   13e2e:	d80c      	bhi.n	13e4a <__multiply+0x7a>
   13e30:	2f00      	cmp	r7, #0
   13e32:	dd03      	ble.n	13e3c <__multiply+0x6c>
   13e34:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
   13e38:	2b00      	cmp	r3, #0
   13e3a:	d05f      	beq.n	13efc <__multiply+0x12c>
   13e3c:	6107      	str	r7, [r0, #16]
   13e3e:	b005      	add	sp, #20
   13e40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13e44:	f843 2b04 	str.w	r2, [r3], #4
   13e48:	e7e0      	b.n	13e0c <__multiply+0x3c>
   13e4a:	6813      	ldr	r3, [r2, #0]
   13e4c:	ea13 0c05 	ands.w	ip, r3, r5
   13e50:	d027      	beq.n	13ea2 <__multiply+0xd2>
   13e52:	f104 0a14 	add.w	sl, r4, #20
   13e56:	46b0      	mov	r8, r6
   13e58:	f04f 0900 	mov.w	r9, #0
   13e5c:	f85a 1b04 	ldr.w	r1, [sl], #4
   13e60:	ea01 0305 	and.w	r3, r1, r5
   13e64:	9303      	str	r3, [sp, #12]
   13e66:	f8d8 3000 	ldr.w	r3, [r8]
   13e6a:	ea03 0b05 	and.w	fp, r3, r5
   13e6e:	9b03      	ldr	r3, [sp, #12]
   13e70:	fb0c b303 	mla	r3, ip, r3, fp
   13e74:	ea4f 4b11 	mov.w	fp, r1, lsr #16
   13e78:	f8d8 1000 	ldr.w	r1, [r8]
   13e7c:	444b      	add	r3, r9
   13e7e:	ea4f 4911 	mov.w	r9, r1, lsr #16
   13e82:	fb0c 910b 	mla	r1, ip, fp, r9
   13e86:	eb01 4113 	add.w	r1, r1, r3, lsr #16
   13e8a:	402b      	ands	r3, r5
   13e8c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   13e90:	f848 3b04 	str.w	r3, [r8], #4
   13e94:	9b00      	ldr	r3, [sp, #0]
   13e96:	4553      	cmp	r3, sl
   13e98:	ea4f 4911 	mov.w	r9, r1, lsr #16
   13e9c:	d8de      	bhi.n	13e5c <__multiply+0x8c>
   13e9e:	f8c8 9000 	str.w	r9, [r8]
   13ea2:	9b02      	ldr	r3, [sp, #8]
   13ea4:	f8b3 9002 	ldrh.w	r9, [r3, #2]
   13ea8:	3204      	adds	r2, #4
   13eaa:	f1b9 0f00 	cmp.w	r9, #0
   13eae:	d023      	beq.n	13ef8 <__multiply+0x128>
   13eb0:	6833      	ldr	r3, [r6, #0]
   13eb2:	f104 0814 	add.w	r8, r4, #20
   13eb6:	46b4      	mov	ip, r6
   13eb8:	f04f 0a00 	mov.w	sl, #0
   13ebc:	f8d8 1000 	ldr.w	r1, [r8]
   13ec0:	f8bc b002 	ldrh.w	fp, [ip, #2]
   13ec4:	4029      	ands	r1, r5
   13ec6:	fb09 b101 	mla	r1, r9, r1, fp
   13eca:	448a      	add	sl, r1
   13ecc:	402b      	ands	r3, r5
   13ece:	ea43 430a 	orr.w	r3, r3, sl, lsl #16
   13ed2:	f84c 3b04 	str.w	r3, [ip], #4
   13ed6:	f858 3b04 	ldr.w	r3, [r8], #4
   13eda:	f8dc 1000 	ldr.w	r1, [ip]
   13ede:	0c1b      	lsrs	r3, r3, #16
   13ee0:	4029      	ands	r1, r5
   13ee2:	fb09 1303 	mla	r3, r9, r3, r1
   13ee6:	9900      	ldr	r1, [sp, #0]
   13ee8:	eb03 431a 	add.w	r3, r3, sl, lsr #16
   13eec:	4541      	cmp	r1, r8
   13eee:	ea4f 4a13 	mov.w	sl, r3, lsr #16
   13ef2:	d8e3      	bhi.n	13ebc <__multiply+0xec>
   13ef4:	f8cc 3000 	str.w	r3, [ip]
   13ef8:	3604      	adds	r6, #4
   13efa:	e795      	b.n	13e28 <__multiply+0x58>
   13efc:	3f01      	subs	r7, #1
   13efe:	e797      	b.n	13e30 <__multiply+0x60>

Disassembly of section .text.quorem%304:

00013f00 <quorem>:
   13f00:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13f04:	6903      	ldr	r3, [r0, #16]
   13f06:	690c      	ldr	r4, [r1, #16]
   13f08:	42a3      	cmp	r3, r4
   13f0a:	4680      	mov	r8, r0
   13f0c:	f2c0 808d 	blt.w	1402a <quorem+0x12a>
   13f10:	3c01      	subs	r4, #1
   13f12:	f101 0714 	add.w	r7, r1, #20
   13f16:	ea4f 0c84 	mov.w	ip, r4, lsl #2
   13f1a:	eb07 030c 	add.w	r3, r7, ip
   13f1e:	f100 0514 	add.w	r5, r0, #20
   13f22:	9300      	str	r3, [sp, #0]
   13f24:	eb05 030c 	add.w	r3, r5, ip
   13f28:	9301      	str	r3, [sp, #4]
   13f2a:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
   13f2e:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
   13f32:	3301      	adds	r3, #1
   13f34:	429a      	cmp	r2, r3
   13f36:	fbb2 f6f3 	udiv	r6, r2, r3
   13f3a:	d336      	bcc.n	13faa <quorem+0xaa>
   13f3c:	f04f 0a00 	mov.w	sl, #0
   13f40:	46be      	mov	lr, r7
   13f42:	46a9      	mov	r9, r5
   13f44:	46d3      	mov	fp, sl
   13f46:	f64f 70ff 	movw	r0, #65535	; 0xffff
   13f4a:	f85e 2b04 	ldr.w	r2, [lr], #4
   13f4e:	ea02 0300 	and.w	r3, r2, r0
   13f52:	fb06 a303 	mla	r3, r6, r3, sl
   13f56:	ea4f 4a13 	mov.w	sl, r3, lsr #16
   13f5a:	4003      	ands	r3, r0
   13f5c:	ebab 0303 	sub.w	r3, fp, r3
   13f60:	0c12      	lsrs	r2, r2, #16
   13f62:	f8d9 b000 	ldr.w	fp, [r9]
   13f66:	fb06 a202 	mla	r2, r6, r2, sl
   13f6a:	fa13 f38b 	uxtah	r3, r3, fp
   13f6e:	ea4f 4a12 	mov.w	sl, r2, lsr #16
   13f72:	ea02 0b00 	and.w	fp, r2, r0
   13f76:	f8d9 2000 	ldr.w	r2, [r9]
   13f7a:	ebcb 4212 	rsb	r2, fp, r2, lsr #16
   13f7e:	eb02 4223 	add.w	r2, r2, r3, asr #16
   13f82:	4003      	ands	r3, r0
   13f84:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   13f88:	f849 3b04 	str.w	r3, [r9], #4
   13f8c:	9b00      	ldr	r3, [sp, #0]
   13f8e:	4573      	cmp	r3, lr
   13f90:	ea4f 4b22 	mov.w	fp, r2, asr #16
   13f94:	d2d9      	bcs.n	13f4a <quorem+0x4a>
   13f96:	f855 300c 	ldr.w	r3, [r5, ip]
   13f9a:	b933      	cbnz	r3, 13faa <quorem+0xaa>
   13f9c:	9b01      	ldr	r3, [sp, #4]
   13f9e:	3b04      	subs	r3, #4
   13fa0:	429d      	cmp	r5, r3
   13fa2:	461a      	mov	r2, r3
   13fa4:	d335      	bcc.n	14012 <quorem+0x112>
   13fa6:	f8c8 4010 	str.w	r4, [r8, #16]
   13faa:	4640      	mov	r0, r8
   13fac:	f00c ffc6 	bl	20f3c <__mcmp>
   13fb0:	2800      	cmp	r0, #0
   13fb2:	db2a      	blt.n	1400a <quorem+0x10a>
   13fb4:	3601      	adds	r6, #1
   13fb6:	4628      	mov	r0, r5
   13fb8:	f04f 0e00 	mov.w	lr, #0
   13fbc:	f64f 7cff 	movw	ip, #65535	; 0xffff
   13fc0:	f857 2b04 	ldr.w	r2, [r7], #4
   13fc4:	f8d0 9000 	ldr.w	r9, [r0]
   13fc8:	ea02 030c 	and.w	r3, r2, ip
   13fcc:	ebae 0303 	sub.w	r3, lr, r3
   13fd0:	0c12      	lsrs	r2, r2, #16
   13fd2:	fa13 f389 	uxtah	r3, r3, r9
   13fd6:	ebc2 4219 	rsb	r2, r2, r9, lsr #16
   13fda:	eb02 4223 	add.w	r2, r2, r3, asr #16
   13fde:	ea03 030c 	and.w	r3, r3, ip
   13fe2:	ea4f 4e22 	mov.w	lr, r2, asr #16
   13fe6:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
   13fea:	9b00      	ldr	r3, [sp, #0]
   13fec:	f840 2b04 	str.w	r2, [r0], #4
   13ff0:	42bb      	cmp	r3, r7
   13ff2:	d2e5      	bcs.n	13fc0 <quorem+0xc0>
   13ff4:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
   13ff8:	eb05 0384 	add.w	r3, r5, r4, lsl #2
   13ffc:	b92a      	cbnz	r2, 1400a <quorem+0x10a>
   13ffe:	3b04      	subs	r3, #4
   14000:	429d      	cmp	r5, r3
   14002:	461a      	mov	r2, r3
   14004:	d30b      	bcc.n	1401e <quorem+0x11e>
   14006:	f8c8 4010 	str.w	r4, [r8, #16]
   1400a:	4630      	mov	r0, r6
   1400c:	b003      	add	sp, #12
   1400e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   14012:	6812      	ldr	r2, [r2, #0]
   14014:	3b04      	subs	r3, #4
   14016:	2a00      	cmp	r2, #0
   14018:	d1c5      	bne.n	13fa6 <quorem+0xa6>
   1401a:	3c01      	subs	r4, #1
   1401c:	e7c0      	b.n	13fa0 <quorem+0xa0>
   1401e:	6812      	ldr	r2, [r2, #0]
   14020:	3b04      	subs	r3, #4
   14022:	2a00      	cmp	r2, #0
   14024:	d1ef      	bne.n	14006 <quorem+0x106>
   14026:	3c01      	subs	r4, #1
   14028:	e7ea      	b.n	14000 <quorem+0x100>
   1402a:	2000      	movs	r0, #0
   1402c:	e7ee      	b.n	1400c <quorem+0x10c>

Disassembly of section .text.TCPIP_IPV4_Initialize%305:

00014030 <TCPIP_IPV4_Initialize>:
{
   14030:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(stackInit->stackAction == TCPIP_STACK_ACTION_IF_UP)
   14032:	7f03      	ldrb	r3, [r0, #28]
   14034:	2b03      	cmp	r3, #3
   14036:	d076      	beq.n	14126 <TCPIP_IPV4_Initialize+0xf6>
    if(ipv4InitCount == 0)
   14038:	4b3c      	ldr	r3, [pc, #240]	; (1412c <TCPIP_IPV4_Initialize+0xfc>)
   1403a:	881b      	ldrh	r3, [r3, #0]
   1403c:	b12b      	cbz	r3, 1404a <TCPIP_IPV4_Initialize+0x1a>
    ipv4InitCount++;
   1403e:	4a3b      	ldr	r2, [pc, #236]	; (1412c <TCPIP_IPV4_Initialize+0xfc>)
   14040:	8813      	ldrh	r3, [r2, #0]
   14042:	3301      	adds	r3, #1
   14044:	8013      	strh	r3, [r2, #0]
    return true;
   14046:	2001      	movs	r0, #1
}
   14048:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1404a:	460c      	mov	r4, r1
            ipv4MemH = stackInit->memH;
   1404c:	68c2      	ldr	r2, [r0, #12]
   1404e:	4b38      	ldr	r3, [pc, #224]	; (14130 <TCPIP_IPV4_Initialize+0x100>)
   14050:	601a      	str	r2, [r3, #0]
            ipv4ArpHandle = 0;
   14052:	2300      	movs	r3, #0
   14054:	4a37      	ldr	r2, [pc, #220]	; (14134 <TCPIP_IPV4_Initialize+0x104>)
   14056:	6013      	str	r3, [r2, #0]
            signalHandle = 0;
   14058:	4a37      	ldr	r2, [pc, #220]	; (14138 <TCPIP_IPV4_Initialize+0x108>)
   1405a:	6013      	str	r3, [r2, #0]
            memset(&ipv4ArpQueue, 0, sizeof(ipv4ArpQueue));
   1405c:	4a37      	ldr	r2, [pc, #220]	; (1413c <TCPIP_IPV4_Initialize+0x10c>)
   1405e:	6013      	str	r3, [r2, #0]
   14060:	6053      	str	r3, [r2, #4]
   14062:	6093      	str	r3, [r2, #8]
   14064:	60d3      	str	r3, [r2, #12]
   14066:	6113      	str	r3, [r2, #16]
            memset(&ipv4ArpPool, 0, sizeof(ipv4ArpPool));
   14068:	4a35      	ldr	r2, [pc, #212]	; (14140 <TCPIP_IPV4_Initialize+0x110>)
   1406a:	6013      	str	r3, [r2, #0]
   1406c:	6053      	str	r3, [r2, #4]
   1406e:	6093      	str	r3, [r2, #8]
            ipv4ArpEntries = 0;
   14070:	4a34      	ldr	r2, [pc, #208]	; (14144 <TCPIP_IPV4_Initialize+0x114>)
   14072:	6013      	str	r3, [r2, #0]
            memset(&ipv4PacketFilters, 0, sizeof(ipv4PacketFilters));
   14074:	4a34      	ldr	r2, [pc, #208]	; (14148 <TCPIP_IPV4_Initialize+0x118>)
   14076:	6013      	str	r3, [r2, #0]
   14078:	6053      	str	r3, [r2, #4]
   1407a:	6093      	str	r3, [r2, #8]
   1407c:	60d3      	str	r3, [r2, #12]
   1407e:	6113      	str	r3, [r2, #16]
            ipv4ActFilterCount = 0;
   14080:	4a32      	ldr	r2, [pc, #200]	; (1414c <TCPIP_IPV4_Initialize+0x11c>)
   14082:	6013      	str	r3, [r2, #0]
            if(pIpInit == 0 || pIpInit->arpEntries == 0)
   14084:	2900      	cmp	r1, #0
   14086:	d03b      	beq.n	14100 <TCPIP_IPV4_Initialize+0xd0>
   14088:	680b      	ldr	r3, [r1, #0]
   1408a:	b94b      	cbnz	r3, 140a0 <TCPIP_IPV4_Initialize+0x70>
                iniRes = TCPIP_IPV4_RES_INIT_VAL_ERR;
   1408c:	f04f 34ff 	mov.w	r4, #4294967295
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, "IPv4 Init: Failed to initalize: %d! \r\n", iniRes);
   14090:	f010 f8f6 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
   14094:	2800      	cmp	r0, #0
   14096:	d13f      	bne.n	14118 <TCPIP_IPV4_Initialize+0xe8>
            TCPIP_IPV4_Cleanup();
   14098:	f008 f8a6 	bl	1c1e8 <TCPIP_IPV4_Cleanup>
            return false;
   1409c:	2000      	movs	r0, #0
   1409e:	e7d3      	b.n	14048 <TCPIP_IPV4_Initialize+0x18>
            signalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_IPV4_Task, 0);
   140a0:	2200      	movs	r2, #0
   140a2:	492b      	ldr	r1, [pc, #172]	; (14150 <TCPIP_IPV4_Initialize+0x120>)
   140a4:	2003      	movs	r0, #3
   140a6:	f00a fe7b 	bl	1eda0 <_TCPIPStackSignalHandlerRegister>
   140aa:	4b23      	ldr	r3, [pc, #140]	; (14138 <TCPIP_IPV4_Initialize+0x108>)
   140ac:	6018      	str	r0, [r3, #0]
            if(signalHandle == 0)
   140ae:	b350      	cbz	r0, 14106 <TCPIP_IPV4_Initialize+0xd6>
            if(!TCPIP_Helper_ProtectedSingleListInitialize (&ipv4ArpQueue))
   140b0:	4822      	ldr	r0, [pc, #136]	; (1413c <TCPIP_IPV4_Initialize+0x10c>)
   140b2:	f00e fc20 	bl	228f6 <TCPIP_Helper_ProtectedSingleListInitialize>
   140b6:	b910      	cbnz	r0, 140be <TCPIP_IPV4_Initialize+0x8e>
                iniRes = TCPIP_IPV4_RES_ARP_ERR;
   140b8:	f06f 0402 	mvn.w	r4, #2
   140bc:	e7e8      	b.n	14090 <TCPIP_IPV4_Initialize+0x60>
            if(!TCPIP_Notification_Initialize(&ipv4PacketFilters))
   140be:	4822      	ldr	r0, [pc, #136]	; (14148 <TCPIP_IPV4_Initialize+0x118>)
   140c0:	f010 f986 	bl	243d0 <TCPIP_Notification_Initialize>
   140c4:	b310      	cbz	r0, 1410c <TCPIP_IPV4_Initialize+0xdc>
            ipv4ArpEntries = (IPV4_ARP_ENTRY*)TCPIP_HEAP_Calloc(ipv4MemH, pIpInit->arpEntries , sizeof(*ipv4ArpEntries));
   140c6:	4b1a      	ldr	r3, [pc, #104]	; (14130 <TCPIP_IPV4_Initialize+0x100>)
   140c8:	6818      	ldr	r0, [r3, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Calloc)(h, nElems, elemSize);
   140ca:	6883      	ldr	r3, [r0, #8]
   140cc:	2210      	movs	r2, #16
   140ce:	6821      	ldr	r1, [r4, #0]
   140d0:	4798      	blx	r3
   140d2:	4b1c      	ldr	r3, [pc, #112]	; (14144 <TCPIP_IPV4_Initialize+0x114>)
   140d4:	6018      	str	r0, [r3, #0]
            if(ipv4ArpEntries == 0)
   140d6:	b1e0      	cbz	r0, 14112 <TCPIP_IPV4_Initialize+0xe2>
            TCPIP_Helper_SingleListInitialize(&ipv4ArpPool);
   140d8:	4819      	ldr	r0, [pc, #100]	; (14140 <TCPIP_IPV4_Initialize+0x110>)
   140da:	f010 f931 	bl	24340 <TCPIP_Helper_SingleListInitialize>
            pEntry = ipv4ArpEntries;
   140de:	4b19      	ldr	r3, [pc, #100]	; (14144 <TCPIP_IPV4_Initialize+0x114>)
   140e0:	681d      	ldr	r5, [r3, #0]
            for(ix = 0; ix < pIpInit->arpEntries; ix++, pEntry++)
   140e2:	6823      	ldr	r3, [r4, #0]
   140e4:	2b00      	cmp	r3, #0
   140e6:	d0aa      	beq.n	1403e <TCPIP_IPV4_Initialize+0xe>
   140e8:	2600      	movs	r6, #0
                TCPIP_Helper_SingleListTailAdd(&ipv4ArpPool, (SGL_LIST_NODE*)pEntry); 
   140ea:	4f15      	ldr	r7, [pc, #84]	; (14140 <TCPIP_IPV4_Initialize+0x110>)
   140ec:	4629      	mov	r1, r5
   140ee:	4638      	mov	r0, r7
   140f0:	f00f f99c 	bl	2342c <TCPIP_Helper_SingleListTailAdd>
            for(ix = 0; ix < pIpInit->arpEntries; ix++, pEntry++)
   140f4:	3601      	adds	r6, #1
   140f6:	3510      	adds	r5, #16
   140f8:	6823      	ldr	r3, [r4, #0]
   140fa:	42b3      	cmp	r3, r6
   140fc:	d8f6      	bhi.n	140ec <TCPIP_IPV4_Initialize+0xbc>
   140fe:	e79e      	b.n	1403e <TCPIP_IPV4_Initialize+0xe>
                iniRes = TCPIP_IPV4_RES_INIT_VAL_ERR;
   14100:	f04f 34ff 	mov.w	r4, #4294967295
   14104:	e7c4      	b.n	14090 <TCPIP_IPV4_Initialize+0x60>
                iniRes = TCPIP_IPV4_RES_SIGNAL_ERR;
   14106:	f06f 0401 	mvn.w	r4, #1
   1410a:	e7c1      	b.n	14090 <TCPIP_IPV4_Initialize+0x60>
                iniRes = TCPIP_IPV4_RES_NOTIFY_ERR;
   1410c:	f06f 0403 	mvn.w	r4, #3
   14110:	e7be      	b.n	14090 <TCPIP_IPV4_Initialize+0x60>
                iniRes = TCPIP_IPV4_RES_MEM_ERR;
   14112:	f06f 0404 	mvn.w	r4, #4
   14116:	e7bb      	b.n	14090 <TCPIP_IPV4_Initialize+0x60>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, "IPv4 Init: Failed to initalize: %d! \r\n", iniRes);
   14118:	f010 f8ac 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
   1411c:	4622      	mov	r2, r4
   1411e:	490d      	ldr	r1, [pc, #52]	; (14154 <TCPIP_IPV4_Initialize+0x124>)
   14120:	f008 fabc 	bl	1c69c <SYS_CONSOLE_Print>
   14124:	e7b8      	b.n	14098 <TCPIP_IPV4_Initialize+0x68>
        return true;
   14126:	2001      	movs	r0, #1
   14128:	e78e      	b.n	14048 <TCPIP_IPV4_Initialize+0x18>
   1412a:	bf00      	nop
   1412c:	2000ef7a 	.word	0x2000ef7a
   14130:	2000ee34 	.word	0x2000ee34
   14134:	2000ee30 	.word	0x2000ee30
   14138:	2000ee38 	.word	0x2000ee38
   1413c:	2000ec3c 	.word	0x2000ec3c
   14140:	2000ed4c 	.word	0x2000ed4c
   14144:	2000ee2c 	.word	0x2000ee2c
   14148:	2000ec50 	.word	0x2000ec50
   1414c:	2000ee28 	.word	0x2000ee28
   14150:	0000f2dd 	.word	0x0000f2dd
   14154:	0001b858 	.word	0x0001b858

Disassembly of section .text.TCPIP_UDP_OptionsGet%306:

00014158 <TCPIP_UDP_OptionsGet>:

// Allows getting options to a socket like enable broadcast, Rx/Tx buffer size, etc
bool TCPIP_UDP_OptionsGet(UDP_SOCKET hUDP, UDP_SOCKET_OPTION option, void* optParam)
{
   14158:	b538      	push	{r3, r4, r5, lr}
   1415a:	460d      	mov	r5, r1
   1415c:	4614      	mov	r4, r2
    UDP_SOCKET_DCPT *pSkt = _UDPSocketDcpt(hUDP);
   1415e:	f00d fff5 	bl	2214c <_UDPSocketDcpt>

    if(pSkt && optParam)
   14162:	2800      	cmp	r0, #0
   14164:	f000 8086 	beq.w	14274 <TCPIP_UDP_OptionsGet+0x11c>
   14168:	2c00      	cmp	r4, #0
   1416a:	f000 8085 	beq.w	14278 <TCPIP_UDP_OptionsGet+0x120>
    {
        switch(option)
   1416e:	2d0c      	cmp	r5, #12
   14170:	f200 8084 	bhi.w	1427c <TCPIP_UDP_OptionsGet+0x124>
   14174:	e8df f005 	tbb	[pc, r5]
   14178:	22191007 	.word	0x22191007
   1417c:	39343029 	.word	0x39343029
   14180:	704a453e 	.word	0x704a453e
   14184:	77          	.byte	0x77
   14185:	00          	.byte	0x00
        {
            case UDP_OPTION_STRICT_PORT:
                *(bool*)optParam = pSkt->flags.looseRemPort == 0;
   14186:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   1418a:	f083 0304 	eor.w	r3, r3, #4
   1418e:	f3c3 0380 	ubfx	r3, r3, #2, #1
   14192:	7023      	strb	r3, [r4, #0]
                return true;
   14194:	2001      	movs	r0, #1
   14196:	e06e      	b.n	14276 <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_STRICT_NET:
                *(bool*)optParam = pSkt->flags.looseNetIf == 0;
   14198:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   1419c:	f083 0308 	eor.w	r3, r3, #8
   141a0:	f3c3 03c0 	ubfx	r3, r3, #3, #1
   141a4:	7023      	strb	r3, [r4, #0]
                return true;
   141a6:	2001      	movs	r0, #1
   141a8:	e065      	b.n	14276 <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_STRICT_ADDRESS:
                *(bool*)optParam = pSkt->flags.looseRemAddress == 0;
   141aa:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   141ae:	f083 0310 	eor.w	r3, r3, #16
   141b2:	f3c3 1300 	ubfx	r3, r3, #4, #1
   141b6:	7023      	strb	r3, [r4, #0]
                return true;
   141b8:	2001      	movs	r0, #1
   141ba:	e05c      	b.n	14276 <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_BROADCAST:
                *(UDP_SOCKET_BCAST_TYPE*)optParam = (UDP_SOCKET_BCAST_TYPE)pSkt->flags.bcastForceType;
   141bc:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   141c0:	f3c3 0301 	ubfx	r3, r3, #0, #2
   141c4:	7023      	strb	r3, [r4, #0]
                return true;
   141c6:	2001      	movs	r0, #1
   141c8:	e055      	b.n	14276 <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_BUFFER_POOL:
                *(bool*)optParam = pSkt->flags.usePool != 0;
   141ca:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
   141ce:	f3c3 0380 	ubfx	r3, r3, #2, #1
   141d2:	7023      	strb	r3, [r4, #0]
                return true;
   141d4:	2001      	movs	r0, #1
   141d6:	e04e      	b.n	14276 <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_TX_BUFF:
                *(uint16_t*)optParam = pSkt->txSize;
   141d8:	8a03      	ldrh	r3, [r0, #16]
   141da:	8023      	strh	r3, [r4, #0]
                return true;
   141dc:	2001      	movs	r0, #1
   141de:	e04a      	b.n	14276 <TCPIP_UDP_OptionsGet+0x11e>
                
            case UDP_OPTION_TX_QUEUE_LIMIT:
                *(uint8_t*)optParam = pSkt->txAllocLimit;
   141e0:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
   141e4:	7023      	strb	r3, [r4, #0]
                return true;
   141e6:	2001      	movs	r0, #1
   141e8:	e045      	b.n	14276 <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_RX_QUEUE_LIMIT:
                *(uint8_t*)optParam = pSkt->rxQueueLimit;
   141ea:	f890 305a 	ldrb.w	r3, [r0, #90]	; 0x5a
   141ee:	7023      	strb	r3, [r4, #0]
                return true;
   141f0:	2001      	movs	r0, #1
   141f2:	e040      	b.n	14276 <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_RX_AUTO_ADVANCE:
                *(bool*)optParam = pSkt->extFlags.rxAutoAdvance != 0;
   141f4:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   141f8:	f003 0301 	and.w	r3, r3, #1
   141fc:	7023      	strb	r3, [r4, #0]
                return true;
   141fe:	2001      	movs	r0, #1
   14200:	e039      	b.n	14276 <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_TX_TTL:
                *(uint8_t*)optParam = pSkt->ttl;
   14202:	f890 305b 	ldrb.w	r3, [r0, #91]	; 0x5b
   14206:	7023      	strb	r3, [r4, #0]
                return true;
   14208:	2001      	movs	r0, #1
   1420a:	e034      	b.n	14276 <TCPIP_UDP_OptionsGet+0x11e>
                    UDP_MULTICAST_FLAGS* pMcFlags = (UDP_MULTICAST_FLAGS*)optParam;
                    if(pMcFlags!= 0)
                    {
                        UDP_MULTICAST_FLAGS mcFlags = 0;

                        if(pSkt->flags.looseNetIf == 1 && pSkt->flags.looseRemAddress == 1 && pSkt->flags.looseRemPort == 1)
   1420c:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
   14210:	f002 021c 	and.w	r2, r2, #28
                        UDP_MULTICAST_FLAGS mcFlags = 0;
   14214:	2a1c      	cmp	r2, #28
   14216:	bf14      	ite	ne
   14218:	2200      	movne	r2, #0
   1421a:	2201      	moveq	r2, #1
                        {
                            mcFlags |= UDP_MCAST_FLAG_LOOSE_NET_SOURCE_PORT;
                        }
                        if(pSkt->extFlags.ignoreSrcAdd != 0)
   1421c:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   14220:	f013 0f10 	tst.w	r3, #16
                        {
                            mcFlags |= UDP_MCAST_FLAG_IGNORE_SOURCE_ADD;
   14224:	bf18      	it	ne
   14226:	f042 0202 	orrne.w	r2, r2, #2
                        }
                        if(pSkt->extFlags.ignoreSrcPort != 0)
   1422a:	f013 0f20 	tst.w	r3, #32
                        {
                            mcFlags |= UDP_MCAST_FLAG_IGNORE_SOURCE_PORT;
   1422e:	bf18      	it	ne
   14230:	f042 0204 	orrne.w	r2, r2, #4
                        }
                        if(pSkt->extFlags.mcastOnly != 0)
   14234:	f013 0f40 	tst.w	r3, #64	; 0x40
                        {
                            mcFlags |= UDP_MCAST_FLAG_IGNORE_UNICAST;
   14238:	bf18      	it	ne
   1423a:	f042 0208 	orrne.w	r2, r2, #8
                        }
                        if(pSkt->extFlags.mcastLoop != 0)
   1423e:	f013 0f04 	tst.w	r3, #4
                        {
                            mcFlags |= UDP_MCAST_FLAG_LOOP;
   14242:	bf18      	it	ne
   14244:	f042 0210 	orrne.w	r2, r2, #16
                        }
                        if(pSkt->extFlags.mcastSkipCheck != 0)
   14248:	f013 0f08 	tst.w	r3, #8
                        {
                            mcFlags |= UDP_MCAST_FLAG_DISABLE_SOURCE_CHECK;
   1424c:	bf18      	it	ne
   1424e:	f042 0220 	orrne.w	r2, r2, #32
                        }

                        *pMcFlags = mcFlags;
   14252:	7022      	strb	r2, [r4, #0]
                        return true;
   14254:	2001      	movs	r0, #1
   14256:	e00e      	b.n	14276 <TCPIP_UDP_OptionsGet+0x11e>
                }

                return false;

             case UDP_OPTION_TOS:
                *(uint8_t*)optParam = pSkt->extFlags.tos;
   14258:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
   1425c:	f3c3 0305 	ubfx	r3, r3, #0, #6
   14260:	7023      	strb	r3, [r4, #0]
                return true;
   14262:	2001      	movs	r0, #1
   14264:	e007      	b.n	14276 <TCPIP_UDP_OptionsGet+0x11e>
                
             case UDP_OPTION_DF:
                *(bool*)optParam = pSkt->extFlags.df != 0;
   14266:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
   1426a:	f3c3 1380 	ubfx	r3, r3, #6, #1
   1426e:	7023      	strb	r3, [r4, #0]
                return true;
   14270:	2001      	movs	r0, #1
   14272:	e000      	b.n	14276 <TCPIP_UDP_OptionsGet+0x11e>
           default:
                break;
        }
    }    

    return false;
   14274:	2000      	movs	r0, #0
}
   14276:	bd38      	pop	{r3, r4, r5, pc}
    return false;
   14278:	2000      	movs	r0, #0
   1427a:	e7fc      	b.n	14276 <TCPIP_UDP_OptionsGet+0x11e>
   1427c:	2000      	movs	r0, #0
   1427e:	e7fa      	b.n	14276 <TCPIP_UDP_OptionsGet+0x11e>

Disassembly of section .text._DHCPS_StartOperation%307:

00014280 <_DHCPS_StartOperation>:
{
   14280:	b570      	push	{r4, r5, r6, lr}
   14282:	b082      	sub	sp, #8
    uint32_t poolIndex=0;
   14284:	2300      	movs	r3, #0
   14286:	9301      	str	r3, [sp, #4]
    if(gPdhcpSDcpt == NULL)
   14288:	4b44      	ldr	r3, [pc, #272]	; (1439c <_DHCPS_StartOperation+0x11c>)
   1428a:	681b      	ldr	r3, [r3, #0]
   1428c:	2b00      	cmp	r3, #0
   1428e:	d07c      	beq.n	1438a <_DHCPS_StartOperation+0x10a>
   14290:	4604      	mov	r4, r0
    if( dhcps_mod.uSkt == INVALID_UDP_SOCKET)
   14292:	4b43      	ldr	r3, [pc, #268]	; (143a0 <_DHCPS_StartOperation+0x120>)
   14294:	f9b3 3000 	ldrsh.w	r3, [r3]
   14298:	f1b3 3fff 	cmp.w	r3, #4294967295
   1429c:	d04e      	beq.n	1433c <_DHCPS_StartOperation+0xbc>
    dhcps_mod.smServer = DHCP_SERVER_LISTEN;
   1429e:	4b40      	ldr	r3, [pc, #256]	; (143a0 <_DHCPS_StartOperation+0x120>)
   142a0:	2200      	movs	r2, #0
   142a2:	709a      	strb	r2, [r3, #2]
    dhcps_mod.smState = newState;
   142a4:	2201      	movs	r2, #1
   142a6:	70da      	strb	r2, [r3, #3]
    pNetIf->Flags.bIsDHCPSrvEnabled = true;
   142a8:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   142ac:	f043 0304 	orr.w	r3, r3, #4
   142b0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    if(_DHCPSDescriptorGetFromIntf(pNetIf,&poolIndex) == false)
   142b4:	a901      	add	r1, sp, #4
   142b6:	4620      	mov	r0, r4
   142b8:	f00a f8b8 	bl	1e42c <_DHCPSDescriptorGetFromIntf>
   142bc:	4606      	mov	r6, r0
   142be:	2800      	cmp	r0, #0
   142c0:	d039      	beq.n	14336 <_DHCPS_StartOperation+0xb6>
    pDhcpsDcpt = gPdhcpSDcpt+poolIndex;
   142c2:	9b01      	ldr	r3, [sp, #4]
   142c4:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   142c8:	4a34      	ldr	r2, [pc, #208]	; (1439c <_DHCPS_StartOperation+0x11c>)
   142ca:	6815      	ldr	r5, [r2, #0]
    if(pDhcpsDcpt == NULL)
   142cc:	eb15 0583 	adds.w	r5, r5, r3, lsl #2
   142d0:	d05f      	beq.n	14392 <_DHCPS_StartOperation+0x112>
    _TCPIPStackSetConfigAddress(pNetIf, &pDhcpsDcpt->intfAddrsConf.serverIPAddress, &pDhcpsDcpt->intfAddrsConf.serverMask, false);
   142d2:	2300      	movs	r3, #0
   142d4:	1d2a      	adds	r2, r5, #4
   142d6:	4629      	mov	r1, r5
   142d8:	4620      	mov	r0, r4
   142da:	f00c fb54 	bl	20986 <_TCPIPStackSetConfigAddress>
    TCPIP_STACK_GatewayAddressSet(pNetIf, &pDhcpsDcpt->intfAddrsConf.serverIPAddress);
   142de:	4629      	mov	r1, r5
   142e0:	4620      	mov	r0, r4
   142e2:	f010 f861 	bl	243a8 <TCPIP_STACK_GatewayAddressSet>
    if(pNetIf->Flags.bIsDNSServerAuto != 0)
   142e6:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   142ea:	f013 0f20 	tst.w	r3, #32
   142ee:	d136      	bne.n	1435e <_DHCPS_StartOperation+0xde>
    TCPIP_UDP_OptionsGet(dhcps_mod.uSkt, UDP_OPTION_TX_QUEUE_LIMIT, (void*)&queueSize);
   142f0:	f10d 0202 	add.w	r2, sp, #2
   142f4:	2106      	movs	r1, #6
   142f6:	4b2a      	ldr	r3, [pc, #168]	; (143a0 <_DHCPS_StartOperation+0x120>)
   142f8:	f9b3 0000 	ldrsh.w	r0, [r3]
   142fc:	f7ff ff2c 	bl	14158 <TCPIP_UDP_OptionsGet>
    if(queueSize < TCPIP_DHCPS_QUEUE_LIMIT_SIZE)
   14300:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   14304:	2b06      	cmp	r3, #6
   14306:	d80a      	bhi.n	1431e <_DHCPS_StartOperation+0x9e>
        queueSize = TCPIP_DHCPS_QUEUE_LIMIT_SIZE;
   14308:	2207      	movs	r2, #7
   1430a:	f8ad 2002 	strh.w	r2, [sp, #2]
        if(!TCPIP_UDP_OptionsSet(dhcps_mod.uSkt, UDP_OPTION_TX_QUEUE_LIMIT, (void*)(uintptr_t)queueSize))
   1430e:	2106      	movs	r1, #6
   14310:	4b23      	ldr	r3, [pc, #140]	; (143a0 <_DHCPS_StartOperation+0x120>)
   14312:	f9b3 0000 	ldrsh.w	r0, [r3]
   14316:	f7fb fe3b 	bl	ff90 <TCPIP_UDP_OptionsSet>
   1431a:	2800      	cmp	r0, #0
   1431c:	d03b      	beq.n	14396 <_DHCPS_StartOperation+0x116>
    TCPIP_UDP_OptionsGet(dhcps_mod.uSkt, UDP_OPTION_RX_QUEUE_LIMIT, (void*)&queueSize);
   1431e:	f10d 0202 	add.w	r2, sp, #2
   14322:	2107      	movs	r1, #7
   14324:	4b1e      	ldr	r3, [pc, #120]	; (143a0 <_DHCPS_StartOperation+0x120>)
   14326:	f9b3 0000 	ldrsh.w	r0, [r3]
   1432a:	f7ff ff15 	bl	14158 <TCPIP_UDP_OptionsGet>
    if(queueSize < TCPIP_DHCPS_QUEUE_LIMIT_SIZE)
   1432e:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   14332:	2b06      	cmp	r3, #6
   14334:	d91e      	bls.n	14374 <_DHCPS_StartOperation+0xf4>
}
   14336:	4630      	mov	r0, r6
   14338:	b002      	add	sp, #8
   1433a:	bd70      	pop	{r4, r5, r6, pc}
        dhcps_mod.uSkt = TCPIP_UDP_ServerOpen(IP_ADDRESS_TYPE_IPV4, TCPIP_DHCP_SERVER_PORT,  0);
   1433c:	2200      	movs	r2, #0
   1433e:	2143      	movs	r1, #67	; 0x43
   14340:	2001      	movs	r0, #1
   14342:	f010 f80c 	bl	2435e <TCPIP_UDP_ServerOpen>
   14346:	4b16      	ldr	r3, [pc, #88]	; (143a0 <_DHCPS_StartOperation+0x120>)
   14348:	8018      	strh	r0, [r3, #0]
        if(dhcps_mod.uSkt == INVALID_UDP_SOCKET)
   1434a:	f1b0 3fff 	cmp.w	r0, #4294967295
   1434e:	d01e      	beq.n	1438e <_DHCPS_StartOperation+0x10e>
        TCPIP_UDP_SignalHandlerRegister(dhcps_mod.uSkt, TCPIP_UDP_SIGNAL_RX_DATA, TCPIP_DHCPSSocketRxSignalHandler, 0);
   14350:	2300      	movs	r3, #0
   14352:	4a14      	ldr	r2, [pc, #80]	; (143a4 <_DHCPS_StartOperation+0x124>)
   14354:	f44f 7180 	mov.w	r1, #256	; 0x100
   14358:	f00a ff7f 	bl	1f25a <TCPIP_UDP_SignalHandlerRegister>
   1435c:	e79f      	b.n	1429e <_DHCPS_StartOperation+0x1e>
        TCPIP_STACK_PrimaryDNSAddressSet(pNetIf, &pDhcpsDcpt->intfAddrsConf.serverDNS);
   1435e:	f105 010c 	add.w	r1, r5, #12
   14362:	4620      	mov	r0, r4
   14364:	f010 f824 	bl	243b0 <TCPIP_STACK_PrimaryDNSAddressSet>
        TCPIP_STACK_SecondaryDNSAddressSet(pNetIf, &pDhcpsDcpt->intfAddrsConf.serverDNS2);
   14368:	f105 0110 	add.w	r1, r5, #16
   1436c:	4620      	mov	r0, r4
   1436e:	f010 f823 	bl	243b8 <TCPIP_STACK_SecondaryDNSAddressSet>
   14372:	e7bd      	b.n	142f0 <_DHCPS_StartOperation+0x70>
        queueSize = TCPIP_DHCPS_QUEUE_LIMIT_SIZE;
   14374:	2107      	movs	r1, #7
   14376:	f8ad 1002 	strh.w	r1, [sp, #2]
        if(!TCPIP_UDP_OptionsSet(dhcps_mod.uSkt, UDP_OPTION_RX_QUEUE_LIMIT, (void*)(uintptr_t)queueSize))
   1437a:	460a      	mov	r2, r1
   1437c:	4b08      	ldr	r3, [pc, #32]	; (143a0 <_DHCPS_StartOperation+0x120>)
   1437e:	f9b3 0000 	ldrsh.w	r0, [r3]
   14382:	f7fb fe05 	bl	ff90 <TCPIP_UDP_OptionsSet>
   14386:	4606      	mov	r6, r0
   14388:	e7d5      	b.n	14336 <_DHCPS_StartOperation+0xb6>
        return false;
   1438a:	2600      	movs	r6, #0
   1438c:	e7d3      	b.n	14336 <_DHCPS_StartOperation+0xb6>
            return false;
   1438e:	2600      	movs	r6, #0
   14390:	e7d1      	b.n	14336 <_DHCPS_StartOperation+0xb6>
        return false;
   14392:	2600      	movs	r6, #0
   14394:	e7cf      	b.n	14336 <_DHCPS_StartOperation+0xb6>
            return false;
   14396:	4606      	mov	r6, r0
   14398:	e7cd      	b.n	14336 <_DHCPS_StartOperation+0xb6>
   1439a:	bf00      	nop
   1439c:	2000eec8 	.word	0x2000eec8
   143a0:	2000ed3c 	.word	0x2000ed3c
   143a4:	000239d3 	.word	0x000239d3

Disassembly of section .text.TCPIP_UDP_Bind%308:

000143a8 <TCPIP_UDP_Bind>:
{
   143a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   143ac:	460d      	mov	r5, r1
   143ae:	4616      	mov	r6, r2
   143b0:	461f      	mov	r7, r3
    pSkt = _UDPSocketDcpt(s);
   143b2:	f00d fecb 	bl	2214c <_UDPSocketDcpt>
    if(pSkt == 0)
   143b6:	2800      	cmp	r0, #0
   143b8:	d07d      	beq.n	144b6 <TCPIP_UDP_Bind+0x10e>
   143ba:	4604      	mov	r4, r0
    oldAddType = pSkt->addType;
   143bc:	f8b0 803c 	ldrh.w	r8, [r0, #60]	; 0x3c
   143c0:	fa5f f288 	uxtb.w	r2, r8
    if(addType == IP_ADDRESS_TYPE_ANY)
   143c4:	bb65      	cbnz	r5, 14420 <TCPIP_UDP_Bind+0x78>
        if(oldAddType != IP_ADDRESS_TYPE_ANY)
   143c6:	2a00      	cmp	r2, #0
   143c8:	d177      	bne.n	144ba <TCPIP_UDP_Bind+0x112>
        localAddress = 0;
   143ca:	2700      	movs	r7, #0
    pSktIf = 0;
   143cc:	46ba      	mov	sl, r7
    OSAL_SEM_Pend(&userSem, OSAL_WAIT_FOREVER);
   143ce:	f64f 71ff 	movw	r1, #65535	; 0xffff
   143d2:	483d      	ldr	r0, [pc, #244]	; (144c8 <TCPIP_UDP_Bind+0x120>)
   143d4:	f00e fd8e 	bl	22ef4 <OSAL_SEM_Pend>
    if(localPort == 0)
   143d8:	2e00      	cmp	r6, #0
   143da:	d146      	bne.n	1446a <TCPIP_UDP_Bind+0xc2>
        if((localPort = pSkt->localPort) == 0)
   143dc:	8d66      	ldrh	r6, [r4, #42]	; 0x2a
   143de:	2e00      	cmp	r6, #0
   143e0:	d03b      	beq.n	1445a <TCPIP_UDP_Bind+0xb2>
    OSAL_SEM_Post(&userSem);
   143e2:	4839      	ldr	r0, [pc, #228]	; (144c8 <TCPIP_UDP_Bind+0x120>)
   143e4:	f00f f9d2 	bl	2378c <OSAL_SEM_Post>
    pSkt->extFlags.rxEnable = 0;
   143e8:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   143ec:	f36f 0341 	bfc	r3, #1, #1
   143f0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    pSkt->addType = addType;
   143f4:	87a5      	strh	r5, [r4, #60]	; 0x3c
    if((pSkt->pSktNet = pNet) != 0)
   143f6:	f8c4 a024 	str.w	sl, [r4, #36]	; 0x24
   143fa:	f1ba 0f00 	cmp.w	sl, #0
   143fe:	d005      	beq.n	1440c <TCPIP_UDP_Bind+0x64>
        pSkt->flags.looseNetIf = 0;
   14400:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
   14404:	f36f 03c3 	bfc	r3, #3, #1
   14408:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    if(localAddress == 0)
   1440c:	2f00      	cmp	r7, #0
   1440e:	d049      	beq.n	144a4 <TCPIP_UDP_Bind+0xfc>
        if (addType == IP_ADDRESS_TYPE_IPV4)
   14410:	2d01      	cmp	r5, #1
   14412:	d03d      	beq.n	14490 <TCPIP_UDP_Bind+0xe8>
        pSkt->addType = oldAddType;
   14414:	fa5f f888 	uxtb.w	r8, r8
   14418:	f8a4 803c 	strh.w	r8, [r4, #60]	; 0x3c
    bindSuccess = _UDPSocketBind(pSkt, pSktIf, localAddress);
   1441c:	2000      	movs	r0, #0
   1441e:	e043      	b.n	144a8 <TCPIP_UDP_Bind+0x100>
        if(addType != IP_ADDRESS_TYPE_IPV4 && addType != IP_ADDRESS_TYPE_IPV6) 
   14420:	1e6b      	subs	r3, r5, #1
   14422:	b2db      	uxtb	r3, r3
   14424:	2b01      	cmp	r3, #1
   14426:	d84a      	bhi.n	144be <TCPIP_UDP_Bind+0x116>
        if(oldAddType != IP_ADDRESS_TYPE_ANY && oldAddType != addType)
   14428:	b10a      	cbz	r2, 1442e <TCPIP_UDP_Bind+0x86>
   1442a:	42aa      	cmp	r2, r5
   1442c:	d149      	bne.n	144c2 <TCPIP_UDP_Bind+0x11a>
    if(localAddress != 0)
   1442e:	b197      	cbz	r7, 14456 <TCPIP_UDP_Bind+0xae>
        if (addType == IP_ADDRESS_TYPE_IPV4 && localAddress->v4Add.Val != 0)
   14430:	2d01      	cmp	r5, #1
   14432:	d002      	beq.n	1443a <TCPIP_UDP_Bind+0x92>
    pSktIf = 0;
   14434:	f04f 0a00 	mov.w	sl, #0
   14438:	e7c9      	b.n	143ce <TCPIP_UDP_Bind+0x26>
        if (addType == IP_ADDRESS_TYPE_IPV4 && localAddress->v4Add.Val != 0)
   1443a:	683b      	ldr	r3, [r7, #0]
   1443c:	b913      	cbnz	r3, 14444 <TCPIP_UDP_Bind+0x9c>
    pSktIf = 0;
   1443e:	f04f 0a00 	mov.w	sl, #0
   14442:	e7c4      	b.n	143ce <TCPIP_UDP_Bind+0x26>
            if((pSktIf = TCPIP_STACK_IPAddToNet(&localAddress->v4Add, false)) == 0)
   14444:	2100      	movs	r1, #0
   14446:	4638      	mov	r0, r7
   14448:	f00e f8fa 	bl	22640 <TCPIP_STACK_IPAddToNet>
   1444c:	4682      	mov	sl, r0
   1444e:	2800      	cmp	r0, #0
   14450:	d1bd      	bne.n	143ce <TCPIP_UDP_Bind+0x26>
                return false;
   14452:	2000      	movs	r0, #0
   14454:	e01a      	b.n	1448c <TCPIP_UDP_Bind+0xe4>
    pSktIf = 0;
   14456:	46ba      	mov	sl, r7
   14458:	e7b9      	b.n	143ce <TCPIP_UDP_Bind+0x26>
            localPort = _UDPAllocateEphemeralPort();
   1445a:	f00c f99b 	bl	20794 <_UDPAllocateEphemeralPort>
            if(localPort == 0)
   1445e:	4606      	mov	r6, r0
   14460:	fab0 f980 	clz	r9, r0
   14464:	ea4f 1959 	mov.w	r9, r9, lsr #5
   14468:	e009      	b.n	1447e <TCPIP_UDP_Bind+0xd6>
    else if(localPort != pSkt->localPort && _UDPIsAvailablePort(localPort) == false)
   1446a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
   1446c:	42b3      	cmp	r3, r6
   1446e:	d0b8      	beq.n	143e2 <TCPIP_UDP_Bind+0x3a>
   14470:	4630      	mov	r0, r6
   14472:	f00b fb37 	bl	1fae4 <_UDPIsAvailablePort>
   14476:	f080 0001 	eor.w	r0, r0, #1
   1447a:	fa5f f980 	uxtb.w	r9, r0
    OSAL_SEM_Post(&userSem);
   1447e:	4812      	ldr	r0, [pc, #72]	; (144c8 <TCPIP_UDP_Bind+0x120>)
   14480:	f00f f984 	bl	2378c <OSAL_SEM_Post>
        return false;
   14484:	2000      	movs	r0, #0
    if(portFail)
   14486:	f1b9 0f00 	cmp.w	r9, #0
   1448a:	d0ad      	beq.n	143e8 <TCPIP_UDP_Bind+0x40>
}
   1448c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            pSkt->srcAddress.Val = localAddress->v4Add.Val;
   14490:	683b      	ldr	r3, [r7, #0]
   14492:	61a3      	str	r3, [r4, #24]
            pSkt->flags.srcSet = 1;
   14494:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
            pSkt->flags.srcSolved = 0;
   14498:	f043 0360 	orr.w	r3, r3, #96	; 0x60
   1449c:	f36f 13c7 	bfc	r3, #7, #1
   144a0:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        pSkt->localPort = localPort;
   144a4:	8566      	strh	r6, [r4, #42]	; 0x2a
   144a6:	2001      	movs	r0, #1
    pSkt->extFlags.rxEnable = 1;
   144a8:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   144ac:	f043 0302 	orr.w	r3, r3, #2
   144b0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    return bindSuccess;
   144b4:	e7ea      	b.n	1448c <TCPIP_UDP_Bind+0xe4>
        return false;
   144b6:	2000      	movs	r0, #0
   144b8:	e7e8      	b.n	1448c <TCPIP_UDP_Bind+0xe4>
            return false;
   144ba:	2000      	movs	r0, #0
   144bc:	e7e6      	b.n	1448c <TCPIP_UDP_Bind+0xe4>
            return false;
   144be:	2000      	movs	r0, #0
   144c0:	e7e4      	b.n	1448c <TCPIP_UDP_Bind+0xe4>
            return false;
   144c2:	2000      	movs	r0, #0
   144c4:	e7e2      	b.n	1448c <TCPIP_UDP_Bind+0xe4>
   144c6:	bf00      	nop
   144c8:	2000ee9c 	.word	0x2000ee9c

Disassembly of section .text.xQueueGenericSend%309:

000144cc <xQueueGenericSend>:
{
   144cc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   144d0:	b084      	sub	sp, #16
   144d2:	4604      	mov	r4, r0
   144d4:	4688      	mov	r8, r1
   144d6:	9201      	str	r2, [sp, #4]
   144d8:	461d      	mov	r5, r3
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
   144da:	f04f 0900 	mov.w	r9, #0
		prvLockQueue( pxQueue );
   144de:	464e      	mov	r6, r9
					portYIELD_WITHIN_API();
   144e0:	4f42      	ldr	r7, [pc, #264]	; (145ec <xQueueGenericSend+0x120>)
   144e2:	e033      	b.n	1454c <xQueueGenericSend+0x80>
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   144e4:	462a      	mov	r2, r5
   144e6:	4641      	mov	r1, r8
   144e8:	4620      	mov	r0, r4
   144ea:	f007 fb58 	bl	1bb9e <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   144ee:	6a63      	ldr	r3, [r4, #36]	; 0x24
   144f0:	b973      	cbnz	r3, 14510 <xQueueGenericSend+0x44>
					else if( xYieldRequired != pdFALSE )
   144f2:	b138      	cbz	r0, 14504 <xQueueGenericSend+0x38>
						queueYIELD_IF_USING_PREEMPTION();
   144f4:	4b3d      	ldr	r3, [pc, #244]	; (145ec <xQueueGenericSend+0x120>)
   144f6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   144fa:	601a      	str	r2, [r3, #0]
   144fc:	f3bf 8f4f 	dsb	sy
   14500:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
   14504:	f00f fb5c 	bl	23bc0 <vPortExitCritical>
				return pdPASS;
   14508:	2001      	movs	r0, #1
}
   1450a:	b004      	add	sp, #16
   1450c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   14510:	f104 0024 	add.w	r0, r4, #36	; 0x24
   14514:	f007 fca0 	bl	1be58 <xTaskRemoveFromEventList>
   14518:	2800      	cmp	r0, #0
   1451a:	d0f3      	beq.n	14504 <xQueueGenericSend+0x38>
							queueYIELD_IF_USING_PREEMPTION();
   1451c:	4b33      	ldr	r3, [pc, #204]	; (145ec <xQueueGenericSend+0x120>)
   1451e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   14522:	601a      	str	r2, [r3, #0]
   14524:	f3bf 8f4f 	dsb	sy
   14528:	f3bf 8f6f 	isb	sy
   1452c:	e7ea      	b.n	14504 <xQueueGenericSend+0x38>
					taskEXIT_CRITICAL();
   1452e:	f00f fb47 	bl	23bc0 <vPortExitCritical>
					return errQUEUE_FULL;
   14532:	2000      	movs	r0, #0
   14534:	e7e9      	b.n	1450a <xQueueGenericSend+0x3e>
					vTaskInternalSetTimeOutState( &xTimeOut );
   14536:	a802      	add	r0, sp, #8
   14538:	f00f f9d0 	bl	238dc <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   1453c:	e014      	b.n	14568 <xQueueGenericSend+0x9c>
				prvUnlockQueue( pxQueue );
   1453e:	4620      	mov	r0, r4
   14540:	f006 fea8 	bl	1b294 <prvUnlockQueue>
				( void ) xTaskResumeAll();
   14544:	f002 f998 	bl	16878 <xTaskResumeAll>
   14548:	f04f 0901 	mov.w	r9, #1
		taskENTER_CRITICAL();
   1454c:	f00e fc18 	bl	22d80 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   14550:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   14552:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   14554:	429a      	cmp	r2, r3
   14556:	d3c5      	bcc.n	144e4 <xQueueGenericSend+0x18>
   14558:	2d02      	cmp	r5, #2
   1455a:	d0c3      	beq.n	144e4 <xQueueGenericSend+0x18>
				if( xTicksToWait == ( TickType_t ) 0 )
   1455c:	9b01      	ldr	r3, [sp, #4]
   1455e:	2b00      	cmp	r3, #0
   14560:	d0e5      	beq.n	1452e <xQueueGenericSend+0x62>
				else if( xEntryTimeSet == pdFALSE )
   14562:	f1b9 0f00 	cmp.w	r9, #0
   14566:	d0e6      	beq.n	14536 <xQueueGenericSend+0x6a>
		taskEXIT_CRITICAL();
   14568:	f00f fb2a 	bl	23bc0 <vPortExitCritical>
		vTaskSuspendAll();
   1456c:	f00f fc68 	bl	23e40 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   14570:	f00e fc06 	bl	22d80 <vPortEnterCritical>
   14574:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
   14578:	b25b      	sxtb	r3, r3
   1457a:	f1b3 3fff 	cmp.w	r3, #4294967295
   1457e:	bf08      	it	eq
   14580:	f884 6044 	strbeq.w	r6, [r4, #68]	; 0x44
   14584:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
   14588:	b25b      	sxtb	r3, r3
   1458a:	f1b3 3fff 	cmp.w	r3, #4294967295
   1458e:	bf08      	it	eq
   14590:	f884 6045 	strbeq.w	r6, [r4, #69]	; 0x45
   14594:	f00f fb14 	bl	23bc0 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   14598:	a901      	add	r1, sp, #4
   1459a:	a802      	add	r0, sp, #8
   1459c:	f009 f8d0 	bl	1d740 <xTaskCheckForTimeOut>
   145a0:	b9e8      	cbnz	r0, 145de <xQueueGenericSend+0x112>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
   145a2:	f00e fbed 	bl	22d80 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   145a6:	f8d4 a038 	ldr.w	sl, [r4, #56]	; 0x38
   145aa:	f8d4 903c 	ldr.w	r9, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
   145ae:	f00f fb07 	bl	23bc0 <vPortExitCritical>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
   145b2:	45ca      	cmp	sl, r9
   145b4:	d1c3      	bne.n	1453e <xQueueGenericSend+0x72>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
   145b6:	9901      	ldr	r1, [sp, #4]
   145b8:	f104 0010 	add.w	r0, r4, #16
   145bc:	f00e fe6c 	bl	23298 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
   145c0:	4620      	mov	r0, r4
   145c2:	f006 fe67 	bl	1b294 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
   145c6:	f002 f957 	bl	16878 <xTaskResumeAll>
   145ca:	2800      	cmp	r0, #0
   145cc:	d1bc      	bne.n	14548 <xQueueGenericSend+0x7c>
					portYIELD_WITHIN_API();
   145ce:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   145d2:	603b      	str	r3, [r7, #0]
   145d4:	f3bf 8f4f 	dsb	sy
   145d8:	f3bf 8f6f 	isb	sy
   145dc:	e7b4      	b.n	14548 <xQueueGenericSend+0x7c>
			prvUnlockQueue( pxQueue );
   145de:	4620      	mov	r0, r4
   145e0:	f006 fe58 	bl	1b294 <prvUnlockQueue>
			( void ) xTaskResumeAll();
   145e4:	f002 f948 	bl	16878 <xTaskResumeAll>
			return errQUEUE_FULL;
   145e8:	2000      	movs	r0, #0
   145ea:	e78e      	b.n	1450a <xQueueGenericSend+0x3e>
   145ec:	e000ed04 	.word	0xe000ed04

Disassembly of section .text.DRV_GMAC_Tasks%310:

000145f0 <DRV_GMAC_Tasks>:
{
   145f0:	b538      	push	{r3, r4, r5, lr}
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   145f2:	4b43      	ldr	r3, [pc, #268]	; (14700 <DRV_GMAC_Tasks+0x110>)
   145f4:	4283      	cmp	r3, r0
   145f6:	d135      	bne.n	14664 <DRV_GMAC_Tasks+0x74>
    if(pMACDrv == 0 || (pMACDrv->sGmacData._macFlags._init == 0))
   145f8:	2800      	cmp	r0, #0
   145fa:	d033      	beq.n	14664 <DRV_GMAC_Tasks+0x74>
   145fc:	7d9b      	ldrb	r3, [r3, #22]
   145fe:	f013 0f01 	tst.w	r3, #1
   14602:	d02f      	beq.n	14664 <DRV_GMAC_Tasks+0x74>
	pPhyBase =  pMACDrv->sGmacData.gmacConfig.pPhyBase;
   14604:	4c3e      	ldr	r4, [pc, #248]	; (14700 <DRV_GMAC_Tasks+0x110>)
   14606:	f8d4 50d8 	ldr.w	r5, [r4, #216]	; 0xd8
	pPhyBase->DRV_ETHPHY_Tasks(pMACDrv->sGmacData.hPhySysObject);
   1460a:	692b      	ldr	r3, [r5, #16]
   1460c:	68e0      	ldr	r0, [r4, #12]
   1460e:	4798      	blx	r3
	switch(pMACDrv->sGmacData.sysStat)
   14610:	f994 3014 	ldrsb.w	r3, [r4, #20]
   14614:	2b01      	cmp	r3, #1
   14616:	d026      	beq.n	14666 <DRV_GMAC_Tasks+0x76>
            if(((pMACDrv->sGmacData._controlFlags & TCPIP_MAC_CONTROL_NO_LINK_CHECK) == 0 && pMACDrv->sGmacData._macFlags._linkPrev == false) ||
   14618:	4b39      	ldr	r3, [pc, #228]	; (14700 <DRV_GMAC_Tasks+0x110>)
   1461a:	f8b3 30f4 	ldrh.w	r3, [r3, #244]	; 0xf4
   1461e:	f013 0f04 	tst.w	r3, #4
   14622:	d104      	bne.n	1462e <DRV_GMAC_Tasks+0x3e>
   14624:	4b36      	ldr	r3, [pc, #216]	; (14700 <DRV_GMAC_Tasks+0x110>)
   14626:	7d9b      	ldrb	r3, [r3, #22]
   14628:	f013 0f10 	tst.w	r3, #16
   1462c:	d004      	beq.n	14638 <DRV_GMAC_Tasks+0x48>
                    (pMACDrv->sGmacData._txDiscard == true))
   1462e:	4b34      	ldr	r3, [pc, #208]	; (14700 <DRV_GMAC_Tasks+0x110>)
            if(((pMACDrv->sGmacData._controlFlags & TCPIP_MAC_CONTROL_NO_LINK_CHECK) == 0 && pMACDrv->sGmacData._macFlags._linkPrev == false) ||
   14630:	f893 30f7 	ldrb.w	r3, [r3, #247]	; 0xf7
   14634:	2b01      	cmp	r3, #1
   14636:	d115      	bne.n	14664 <DRV_GMAC_Tasks+0x74>
	if(pMACDrv->sGmacData._synchF != 0)
   14638:	4b31      	ldr	r3, [pc, #196]	; (14700 <DRV_GMAC_Tasks+0x110>)
   1463a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   1463c:	b113      	cbz	r3, 14644 <DRV_GMAC_Tasks+0x54>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_LOCK);
   1463e:	2103      	movs	r1, #3
   14640:	4830      	ldr	r0, [pc, #192]	; (14704 <DRV_GMAC_Tasks+0x114>)
   14642:	4798      	blx	r3
                _MacTxDiscardQueues(pMACDrv, TCPIP_MAC_PKT_ACK_LINK_DOWN); 
   14644:	4c2e      	ldr	r4, [pc, #184]	; (14700 <DRV_GMAC_Tasks+0x110>)
   14646:	f04f 31ff 	mov.w	r1, #4294967295
   1464a:	4620      	mov	r0, r4
   1464c:	f00a fe4a 	bl	1f2e4 <_MacTxDiscardQueues>
	if(pMACDrv->sGmacData._synchF != 0)
   14650:	6b23      	ldr	r3, [r4, #48]	; 0x30
   14652:	b11b      	cbz	r3, 1465c <DRV_GMAC_Tasks+0x6c>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_UNLOCK);
   14654:	2104      	movs	r1, #4
   14656:	f104 0060 	add.w	r0, r4, #96	; 0x60
   1465a:	4798      	blx	r3
                pMACDrv->sGmacData._txDiscard = false;
   1465c:	4b28      	ldr	r3, [pc, #160]	; (14700 <DRV_GMAC_Tasks+0x110>)
   1465e:	2200      	movs	r2, #0
   14660:	f883 20f7 	strb.w	r2, [r3, #247]	; 0xf7
}
   14664:	bd38      	pop	{r3, r4, r5, pc}
            hPhyClient = pMACDrv->sGmacData.hPhyClient;
   14666:	6924      	ldr	r4, [r4, #16]
            phyStat = pPhyBase->DRV_ETHPHY_ClientStatus(hPhyClient);
   14668:	69eb      	ldr	r3, [r5, #28]
   1466a:	4620      	mov	r0, r4
   1466c:	4798      	blx	r3
            if(phyStat == DRV_ETHPHY_CLIENT_STATUS_BUSY)
   1466e:	2801      	cmp	r0, #1
   14670:	d0f8      	beq.n	14664 <DRV_GMAC_Tasks+0x74>
            phyInitRes = pPhyBase->DRV_ETHPHY_ClientOperationResult(hPhyClient);
   14672:	6a2b      	ldr	r3, [r5, #32]
   14674:	4620      	mov	r0, r4
   14676:	4798      	blx	r3
            if ( phyInitRes != DRV_ETHPHY_RES_OK)
   14678:	4604      	mov	r4, r0
   1467a:	bb28      	cbnz	r0, 146c8 <DRV_GMAC_Tasks+0xd8>
            pMACDrv->sGmacData._macFlags._linkPresent = 1;
   1467c:	4b20      	ldr	r3, [pc, #128]	; (14700 <DRV_GMAC_Tasks+0x110>)
   1467e:	7d9a      	ldrb	r2, [r3, #22]
   14680:	f042 0204 	orr.w	r2, r2, #4
   14684:	759a      	strb	r2, [r3, #22]
            if((pMACDrv->sGmacData.gmacConfig.ethFlags & TCPIP_ETH_OPEN_AUTO) != 0)
   14686:	f8b3 30d2 	ldrh.w	r3, [r3, #210]	; 0xd2
   1468a:	f013 0f01 	tst.w	r3, #1
   1468e:	d02c      	beq.n	146ea <DRV_GMAC_Tasks+0xfa>
                pMACDrv->sGmacData._macFlags._linkNegotiation = 1;	// performing the negotiation
   14690:	4a1b      	ldr	r2, [pc, #108]	; (14700 <DRV_GMAC_Tasks+0x110>)
   14692:	7d93      	ldrb	r3, [r2, #22]
   14694:	f043 0308 	orr.w	r3, r3, #8
   14698:	7593      	strb	r3, [r2, #22]
            pMACDrv->sGmacData._linkUpTick = SYS_TMR_TickCountGet();     // the initialization time
   1469a:	f00d fdcf 	bl	2223c <SYS_TMR_TickCountGet>
   1469e:	4c18      	ldr	r4, [pc, #96]	; (14700 <DRV_GMAC_Tasks+0x110>)
   146a0:	63a0      	str	r0, [r4, #56]	; 0x38
            pMACDrv->sGmacData._linkWaitTick = ((SYS_TMR_TickCounterFrequencyGet() * pMACDrv->sGmacData.gmacConfig.linkInitDelay) + 999 ) / 1000;
   146a2:	f00d fdf3 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
   146a6:	f8b4 30d0 	ldrh.w	r3, [r4, #208]	; 0xd0
   146aa:	fb00 f303 	mul.w	r3, r0, r3
   146ae:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
   146b2:	4a15      	ldr	r2, [pc, #84]	; (14708 <DRV_GMAC_Tasks+0x118>)
   146b4:	fba2 2303 	umull	r2, r3, r2, r3
   146b8:	099b      	lsrs	r3, r3, #6
   146ba:	63e3      	str	r3, [r4, #60]	; 0x3c
            pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_START_LINK;
   146bc:	2300      	movs	r3, #0
   146be:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
            pMACDrv->sGmacData.sysStat = SYS_STATUS_READY;
   146c2:	2302      	movs	r3, #2
   146c4:	7523      	strb	r3, [r4, #20]
            break;
   146c6:	e7cd      	b.n	14664 <DRV_GMAC_Tasks+0x74>
                _MACDeinit(pMACDrv);
   146c8:	4d0d      	ldr	r5, [pc, #52]	; (14700 <DRV_GMAC_Tasks+0x110>)
   146ca:	4628      	mov	r0, r5
   146cc:	f7fe ff48 	bl	13560 <_MACDeinit>
                pMACDrv->sGmacData.sysStat = SYS_STATUS_ERROR;
   146d0:	23ff      	movs	r3, #255	; 0xff
   146d2:	752b      	strb	r3, [r5, #20]
                SYS_ERROR_PRINT(SYS_ERROR_ERROR, "DRV PHY init failed: %d\r\n", phyInitRes);
   146d4:	f00f fdd4 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
   146d8:	2800      	cmp	r0, #0
   146da:	d0c3      	beq.n	14664 <DRV_GMAC_Tasks+0x74>
   146dc:	f00f fdca 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
   146e0:	4622      	mov	r2, r4
   146e2:	490a      	ldr	r1, [pc, #40]	; (1470c <DRV_GMAC_Tasks+0x11c>)
   146e4:	f007 ffda 	bl	1c69c <SYS_CONSOLE_Print>
   146e8:	e7bc      	b.n	14664 <DRV_GMAC_Tasks+0x74>
                pauseType = (pMACDrv->sGmacData.gmacConfig.ethFlags & TCPIP_ETH_OPEN_FDUPLEX) ? DRV_GMAC_PAUSE_CPBL_MASK : TCPIP_ETH_PAUSE_TYPE_NONE;
   146ea:	f003 0302 	and.w	r3, r3, #2
   146ee:	2b00      	cmp	r3, #0
                DRV_PIC32CGMAC_LibMACOpen(pMACDrv, pMACDrv->sGmacData._linkResFlags, pauseType);
   146f0:	4803      	ldr	r0, [pc, #12]	; (14700 <DRV_GMAC_Tasks+0x110>)
   146f2:	bf14      	ite	ne
   146f4:	220f      	movne	r2, #15
   146f6:	2200      	moveq	r2, #0
   146f8:	8e81      	ldrh	r1, [r0, #52]	; 0x34
   146fa:	f007 fe55 	bl	1c3a8 <DRV_PIC32CGMAC_LibMACOpen>
   146fe:	e7cc      	b.n	1469a <DRV_GMAC_Tasks+0xaa>
   14700:	2000e288 	.word	0x2000e288
   14704:	2000e2e8 	.word	0x2000e2e8
   14708:	10624dd3 	.word	0x10624dd3
   1470c:	000224fc 	.word	0x000224fc

Disassembly of section .text.DRV_PIC32CGMAC_LibRxBuffersAppend%311:

00014710 <DRV_PIC32CGMAC_LibRxBuffersAppend>:
{ 
   14710:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14714:	b085      	sub	sp, #20
   14716:	4607      	mov	r7, r0
   14718:	9101      	str	r1, [sp, #4]
   1471a:	461c      	mov	r4, r3
	uint16_t nRxDescCnt = pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxDescCnt;	
   1471c:	460e      	mov	r6, r1
   1471e:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
   14722:	eb00 0343 	add.w	r3, r0, r3, lsl #1
   14726:	f8b3 30be 	ldrh.w	r3, [r3, #190]	; 0xbe
   1472a:	9303      	str	r3, [sp, #12]
	uint8_t desc_idx = start_index;
   1472c:	b2d5      	uxtb	r5, r2
			if((pPacket = (TCPIP_MAC_PACKET *)DRV_PIC32CGMAC_SingleListHeadRemove(&pMACDrv->sGmacData.gmac_queue[queueIdx]._RxQueue))!= NULL)
   1472e:	232c      	movs	r3, #44	; 0x2c
   14730:	fb03 0301 	mla	r3, r3, r1, r0
   14734:	3394      	adds	r3, #148	; 0x94
   14736:	9302      	str	r3, [sp, #8]
	DRV_PIC32CGMAC_RESULT gmacRes = DRV_PIC32CGMAC_RES_OK;
   14738:	f04f 0900 	mov.w	r9, #0
		if((pMACDrv->sGmacData.gmac_queue[queueIdx]._RxQueue.nNodes) < (pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxBuffCntThres))
   1473c:	f04f 082c 	mov.w	r8, #44	; 0x2c
   14740:	fb08 0801 	mla	r8, r8, r1, r0
	while (nDesc_Cnt--)
   14744:	e009      	b.n	1475a <DRV_PIC32CGMAC_LibRxBuffersAppend+0x4a>
		if(pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[desc_idx] == 0)
   14746:	9500      	str	r5, [sp, #0]
   14748:	ea4f 0a85 	mov.w	sl, r5, lsl #2
   1474c:	f8d8 308c 	ldr.w	r3, [r8, #140]	; 0x8c
   14750:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
   14754:	b313      	cbz	r3, 1479c <DRV_PIC32CGMAC_LibRxBuffersAppend+0x8c>
   14756:	3c01      	subs	r4, #1
   14758:	b2a4      	uxth	r4, r4
	while (nDesc_Cnt--)
   1475a:	b1dc      	cbz	r4, 14794 <DRV_PIC32CGMAC_LibRxBuffersAppend+0x84>
		if((pMACDrv->sGmacData.gmac_queue[queueIdx]._RxQueue.nNodes) < (pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxBuffCntThres))
   1475c:	eb06 03c6 	add.w	r3, r6, r6, lsl #3
   14760:	eb07 0343 	add.w	r3, r7, r3, lsl #1
   14764:	f8b3 30c4 	ldrh.w	r3, [r3, #196]	; 0xc4
   14768:	f8d8 209c 	ldr.w	r2, [r8, #156]	; 0x9c
   1476c:	429a      	cmp	r2, r3
   1476e:	daea      	bge.n	14746 <DRV_PIC32CGMAC_LibRxBuffersAppend+0x36>
            gmacRes = _AllocateRxPacket(pMACDrv, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxBuffAllocCnt, queueIdx, GMAC_RX_DYNAMIC_BUFFERS);
   14770:	eb06 01c6 	add.w	r1, r6, r6, lsl #3
   14774:	eb07 0141 	add.w	r1, r7, r1, lsl #1
   14778:	2300      	movs	r3, #0
   1477a:	9a01      	ldr	r2, [sp, #4]
   1477c:	f8b1 10c6 	ldrh.w	r1, [r1, #198]	; 0xc6
   14780:	4638      	mov	r0, r7
   14782:	f007 fe47 	bl	1c414 <_AllocateRxPacket>
   14786:	4681      	mov	r9, r0
            if(gmacRes == DRV_PIC32CGMAC_RES_OUT_OF_MEMORY)
   14788:	f1b0 3fff 	cmp.w	r0, #4294967295
   1478c:	d1db      	bne.n	14746 <DRV_PIC32CGMAC_LibRxBuffersAppend+0x36>
                pMACDrv->sGmacData._rxStat.nRxBuffNotAvailable++;			
   1478e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   14790:	3301      	adds	r3, #1
   14792:	67bb      	str	r3, [r7, #120]	; 0x78
} //DRV_PIC32CGMAC_LibRxBuffersAppend
   14794:	4648      	mov	r0, r9
   14796:	b005      	add	sp, #20
   14798:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if((pPacket = (TCPIP_MAC_PACKET *)DRV_PIC32CGMAC_SingleListHeadRemove(&pMACDrv->sGmacData.gmac_queue[queueIdx]._RxQueue))!= NULL)
   1479c:	9802      	ldr	r0, [sp, #8]
   1479e:	f00e fc0f 	bl	22fc0 <DRV_PIC32CGMAC_SingleListHeadRemove>
   147a2:	4683      	mov	fp, r0
   147a4:	2800      	cmp	r0, #0
   147a6:	d0d6      	beq.n	14756 <DRV_PIC32CGMAC_LibRxBuffersAppend+0x46>
	if(pMACDrv->sGmacData._synchF != 0)
   147a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   147aa:	b11b      	cbz	r3, 147b4 <DRV_PIC32CGMAC_LibRxBuffersAppend+0xa4>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
   147ac:	2105      	movs	r1, #5
   147ae:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   147b2:	4798      	blx	r3
				pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc[desc_idx].rx_desc_status.val = 0;
   147b4:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
   147b8:	9a00      	ldr	r2, [sp, #0]
   147ba:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   147be:	2200      	movs	r2, #0
   147c0:	605a      	str	r2, [r3, #4]
                uint32_t segBuffer = (uint32_t)(pPacket->pDSeg->segBuffer) & GMAC_RX_ADDRESS_MASK;   // should be 4-byte aligned
   147c2:	f8db 3010 	ldr.w	r3, [fp, #16]
   147c6:	685a      	ldr	r2, [r3, #4]
   147c8:	f022 0203 	bic.w	r2, r2, #3
				if (desc_idx == pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxDescCnt - 1)
   147cc:	eb06 03c6 	add.w	r3, r6, r6, lsl #3
   147d0:	eb07 0343 	add.w	r3, r7, r3, lsl #1
   147d4:	f8b3 30be 	ldrh.w	r3, [r3, #190]	; 0xbe
   147d8:	3b01      	subs	r3, #1
   147da:	429d      	cmp	r5, r3
   147dc:	d01e      	beq.n	1481c <DRV_PIC32CGMAC_LibRxBuffersAppend+0x10c>
                    pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc[desc_idx].rx_desc_buffaddr.val =  segBuffer;            
   147de:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
   147e2:	9900      	ldr	r1, [sp, #0]
   147e4:	f843 2031 	str.w	r2, [r3, r1, lsl #3]
	if(pMACDrv->sGmacData._synchF != 0)
   147e8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   147ea:	b11b      	cbz	r3, 147f4 <DRV_PIC32CGMAC_LibRxBuffersAppend+0xe4>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_LEAVE);
   147ec:	2106      	movs	r1, #6
   147ee:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   147f2:	4798      	blx	r3
				pPacket->ackFunc = (TCPIP_MAC_PACKET_ACK_FUNC)_MacRxPacketAck;
   147f4:	4b0d      	ldr	r3, [pc, #52]	; (1482c <DRV_PIC32CGMAC_LibRxBuffersAppend+0x11c>)
   147f6:	f8cb 3008 	str.w	r3, [fp, #8]
				pPacket->ackParam = pMACDrv;
   147fa:	f8cb 700c 	str.w	r7, [fp, #12]
				pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[desc_idx] = pPacket;
   147fe:	f8d8 308c 	ldr.w	r3, [r8, #140]	; 0x8c
   14802:	f843 b00a 	str.w	fp, [r3, sl]
				pPacket->next = 0;
   14806:	2300      	movs	r3, #0
   14808:	f8cb 3000 	str.w	r3, [fp]
				GCIRC_INC(desc_idx,nRxDescCnt );
   1480c:	3501      	adds	r5, #1
   1480e:	b2ed      	uxtb	r5, r5
   14810:	b2ab      	uxth	r3, r5
   14812:	9a03      	ldr	r2, [sp, #12]
   14814:	4293      	cmp	r3, r2
   14816:	bf28      	it	cs
   14818:	2500      	movcs	r5, #0
   1481a:	e79c      	b.n	14756 <DRV_PIC32CGMAC_LibRxBuffersAppend+0x46>
                    pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc[desc_idx].rx_desc_buffaddr.val =  segBuffer | GMAC_RX_WRAP_BIT;
   1481c:	f8d8 1090 	ldr.w	r1, [r8, #144]	; 0x90
   14820:	f042 0202 	orr.w	r2, r2, #2
   14824:	9b00      	ldr	r3, [sp, #0]
   14826:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
   1482a:	e7dd      	b.n	147e8 <DRV_PIC32CGMAC_LibRxBuffersAppend+0xd8>
   1482c:	0001cd21 	.word	0x0001cd21

Disassembly of section .text._Command_StackOnOff%312:

00014830 <_Command_StackOnOff>:
{
   14830:	b5f0      	push	{r4, r5, r6, r7, lr}
   14832:	b087      	sub	sp, #28
   14834:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   14836:	6845      	ldr	r5, [r0, #4]
    if (argc < 2)
   14838:	2901      	cmp	r1, #1
   1483a:	dd10      	ble.n	1485e <_Command_StackOnOff+0x2e>
    if (memcmp(argv[1], "up", 2) == 0)
   1483c:	6856      	ldr	r6, [r2, #4]
   1483e:	2202      	movs	r2, #2
   14840:	4938      	ldr	r1, [pc, #224]	; (14924 <_Command_StackOnOff+0xf4>)
   14842:	4630      	mov	r0, r6
   14844:	f00e fd44 	bl	232d0 <memcmp>
   14848:	b1c0      	cbz	r0, 1487c <_Command_StackOnOff+0x4c>
    else if (memcmp(argv[1], "down", 4) == 0)
   1484a:	2204      	movs	r2, #4
   1484c:	4936      	ldr	r1, [pc, #216]	; (14928 <_Command_StackOnOff+0xf8>)
   1484e:	4630      	mov	r0, r6
   14850:	f00e fd3e 	bl	232d0 <memcmp>
   14854:	2800      	cmp	r0, #0
   14856:	d046      	beq.n	148e6 <_Command_StackOnOff+0xb6>
    return true;
   14858:	2001      	movs	r0, #1
}
   1485a:	b007      	add	sp, #28
   1485c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: stack <up/down> <preserve>\r\n");
   1485e:	4e33      	ldr	r6, [pc, #204]	; (1492c <_Command_StackOnOff+0xfc>)
   14860:	6803      	ldr	r3, [r0, #0]
   14862:	681b      	ldr	r3, [r3, #0]
   14864:	f606 21b8 	addw	r1, r6, #2744	; 0xab8
   14868:	4628      	mov	r0, r5
   1486a:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: stack down preserve\r\n");
   1486c:	6823      	ldr	r3, [r4, #0]
   1486e:	681b      	ldr	r3, [r3, #0]
   14870:	f606 21dc 	addw	r1, r6, #2780	; 0xadc
   14874:	4628      	mov	r0, r5
   14876:	4798      	blx	r3
        return false;
   14878:	2000      	movs	r0, #0
   1487a:	e7ee      	b.n	1485a <_Command_StackOnOff+0x2a>
        tcpipStackObj = TCPIP_STACK_Initialize(0, 0);
   1487c:	2100      	movs	r1, #0
   1487e:	4608      	mov	r0, r1
   14880:	f005 fe52 	bl	1a528 <TCPIP_STACK_Initialize>
        if ( tcpipStackObj != SYS_MODULE_OBJ_INVALID)
   14884:	f1b0 3fff 	cmp.w	r0, #4294967295
   14888:	d006      	beq.n	14898 <_Command_StackOnOff+0x68>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Stack already up!\r\n");
   1488a:	6823      	ldr	r3, [r4, #0]
   1488c:	681b      	ldr	r3, [r3, #0]
   1488e:	4928      	ldr	r1, [pc, #160]	; (14930 <_Command_StackOnOff+0x100>)
   14890:	4628      	mov	r0, r5
   14892:	4798      	blx	r3
            return true;
   14894:	2001      	movs	r0, #1
   14896:	e7e0      	b.n	1485a <_Command_StackOnOff+0x2a>
        if(pCmdTcpipInitData == 0)
   14898:	4b26      	ldr	r3, [pc, #152]	; (14934 <_Command_StackOnOff+0x104>)
   1489a:	681e      	ldr	r6, [r3, #0]
   1489c:	b1e6      	cbz	r6, 148d8 <_Command_StackOnOff+0xa8>
        tcpipInit = *pCmdTcpipInitData;
   1489e:	466f      	mov	r7, sp
   148a0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   148a2:	c70f      	stmia	r7!, {r0, r1, r2, r3}
   148a4:	e896 0003 	ldmia.w	r6, {r0, r1}
   148a8:	e887 0003 	stmia.w	r7, {r0, r1}
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Restarting the stack with %d interface(s)\r\n", tcpipInit.nNets);
   148ac:	6823      	ldr	r3, [r4, #0]
   148ae:	685b      	ldr	r3, [r3, #4]
   148b0:	4921      	ldr	r1, [pc, #132]	; (14938 <_Command_StackOnOff+0x108>)
   148b2:	4628      	mov	r0, r5
   148b4:	4798      	blx	r3
        tcpipStackObj = TCPIP_STACK_Initialize(0, &tcpipInit.moduleInit);     // init the stack
   148b6:	4669      	mov	r1, sp
   148b8:	2000      	movs	r0, #0
   148ba:	f005 fe35 	bl	1a528 <TCPIP_STACK_Initialize>
        if ( tcpipStackObj == SYS_MODULE_OBJ_INVALID)
   148be:	f1b0 3fff 	cmp.w	r0, #4294967295
            msg = "Stack up succeeded\r\n";
   148c2:	491e      	ldr	r1, [pc, #120]	; (1493c <_Command_StackOnOff+0x10c>)
   148c4:	f101 0314 	add.w	r3, r1, #20
   148c8:	bf18      	it	ne
   148ca:	4619      	movne	r1, r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, msg);
   148cc:	6823      	ldr	r3, [r4, #0]
   148ce:	681b      	ldr	r3, [r3, #0]
   148d0:	4628      	mov	r0, r5
   148d2:	4798      	blx	r3
    return true;
   148d4:	2001      	movs	r0, #1
   148d6:	e7c0      	b.n	1485a <_Command_StackOnOff+0x2a>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Turn Stack down and then up!\r\n");
   148d8:	6823      	ldr	r3, [r4, #0]
   148da:	681b      	ldr	r3, [r3, #0]
   148dc:	4918      	ldr	r1, [pc, #96]	; (14940 <_Command_StackOnOff+0x110>)
   148de:	4628      	mov	r0, r5
   148e0:	4798      	blx	r3
            return true;
   148e2:	2001      	movs	r0, #1
   148e4:	e7b9      	b.n	1485a <_Command_StackOnOff+0x2a>
        tcpipStackObj = TCPIP_STACK_Initialize(0, 0);
   148e6:	2100      	movs	r1, #0
   148e8:	4608      	mov	r0, r1
   148ea:	f005 fe1d 	bl	1a528 <TCPIP_STACK_Initialize>
   148ee:	4606      	mov	r6, r0
        if ( tcpipStackObj == SYS_MODULE_OBJ_INVALID)
   148f0:	f1b0 3fff 	cmp.w	r0, #4294967295
   148f4:	d106      	bne.n	14904 <_Command_StackOnOff+0xd4>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, msg);
   148f6:	6823      	ldr	r3, [r4, #0]
   148f8:	681b      	ldr	r3, [r3, #0]
   148fa:	4912      	ldr	r1, [pc, #72]	; (14944 <_Command_StackOnOff+0x114>)
   148fc:	4628      	mov	r0, r5
   148fe:	4798      	blx	r3
    return true;
   14900:	2001      	movs	r0, #1
   14902:	e7aa      	b.n	1485a <_Command_StackOnOff+0x2a>
            TCPIP_STACK_InitializeDataGet(tcpipStackObj, &cmdTcpipInitData);
   14904:	4f10      	ldr	r7, [pc, #64]	; (14948 <_Command_StackOnOff+0x118>)
   14906:	4639      	mov	r1, r7
   14908:	f00c fd18 	bl	2133c <TCPIP_STACK_InitializeDataGet>
            pCmdTcpipInitData = &cmdTcpipInitData;
   1490c:	4b09      	ldr	r3, [pc, #36]	; (14934 <_Command_StackOnOff+0x104>)
   1490e:	601f      	str	r7, [r3, #0]
            TCPIP_STACK_Deinitialize(tcpipStackObj);
   14910:	4630      	mov	r0, r6
   14912:	f00e fc35 	bl	23180 <TCPIP_STACK_Deinitialize>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Stack down succeeded\r\n");
   14916:	6823      	ldr	r3, [r4, #0]
   14918:	681b      	ldr	r3, [r3, #0]
   1491a:	490c      	ldr	r1, [pc, #48]	; (1494c <_Command_StackOnOff+0x11c>)
   1491c:	4628      	mov	r0, r5
   1491e:	4798      	blx	r3
    return true;
   14920:	2001      	movs	r0, #1
   14922:	e79a      	b.n	1485a <_Command_StackOnOff+0x2a>
   14924:	00000d84 	.word	0x00000d84
   14928:	00000de8 	.word	0x00000de8
   1492c:	0000028c 	.word	0x0000028c
   14930:	00000d88 	.word	0x00000d88
   14934:	2000ee10 	.word	0x2000ee10
   14938:	00000dbc 	.word	0x00000dbc
   1493c:	00000d18 	.word	0x00000d18
   14940:	00000d9c 	.word	0x00000d9c
   14944:	00000df0 	.word	0x00000df0
   14948:	2000ebf8 	.word	0x2000ebf8
   1494c:	00000e18 	.word	0x00000e18

Disassembly of section .text.TCPIP_IPV4_PacketFormatTx%313:

00014950 <TCPIP_IPV4_PacketFormatTx>:
{
   14950:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14954:	4605      	mov	r5, r0
    IPV4_HEADER*    pHdr = (IPV4_HEADER*)pPkt->macPkt.pNetLayer;
   14956:	6984      	ldr	r4, [r0, #24]
    uint16_t hdrLen = sizeof(IPV4_HEADER) + pPkt->optionLen;
   14958:	f890 6040 	ldrb.w	r6, [r0, #64]	; 0x40
   1495c:	3614      	adds	r6, #20
    pHdr->Version = IPv4_VERSION;
   1495e:	7820      	ldrb	r0, [r4, #0]
   14960:	2704      	movs	r7, #4
   14962:	f367 1007 	bfi	r0, r7, #4, #4
    pHdr->IHL = hdrLen >> 2;
   14966:	08b7      	lsrs	r7, r6, #2
   14968:	f367 0003 	bfi	r0, r7, #0, #4
   1496c:	7020      	strb	r0, [r4, #0]
    if((pPkt->optionMask & IPV4_OPTION_MASK_ROUTER_ALERT) != 0)
   1496e:	f8b5 0042 	ldrh.w	r0, [r5, #66]	; 0x42
   14972:	f010 0f01 	tst.w	r0, #1
   14976:	d01f      	beq.n	149b8 <TCPIP_IPV4_PacketFormatTx+0x68>
        pOpt = (IPV4_ROUTER_ALERT_OPTION*)pHdr->options + pPkt->optionOffset;
   14978:	f104 0714 	add.w	r7, r4, #20
   1497c:	f895 e041 	ldrb.w	lr, [r5, #65]	; 0x41
   14980:	eb07 0c8e 	add.w	ip, r7, lr, lsl #2
        pOpt->optCopied = IPV4_ROUTER_ALERT_OPTION_COPIED;
   14984:	f817 002e 	ldrb.w	r0, [r7, lr, lsl #2]
        pOpt->optClass = IPV4_ROUTER_ALERT_OPTION_CLASS;
   14988:	f060 007f 	orn	r0, r0, #127	; 0x7f
        pOpt->optNumber = TCPIP_IPV4_OPTION_ROUTER_ALERT;
   1498c:	f000 009f 	and.w	r0, r0, #159	; 0x9f
   14990:	f04f 0814 	mov.w	r8, #20
   14994:	f368 0004 	bfi	r0, r8, #0, #5
   14998:	f807 002e 	strb.w	r0, [r7, lr, lsl #2]
        pOpt->optLength = IPV4_ROUTER_ALERT_OPTION_SIZE;
   1499c:	2004      	movs	r0, #4
   1499e:	f88c 0001 	strb.w	r0, [ip, #1]
        pOpt->optValue = IPV4_ROUTER_ALERT_OPTION_DATA;
   149a2:	2000      	movs	r0, #0
   149a4:	f8ac 0002 	strh.w	r0, [ip, #2]
        pEndOpt = (uint8_t*)(pOpt + 1);
   149a8:	f10c 0704 	add.w	r7, ip, #4
        pEndHdr = (uint8_t*)pHdr + hdrLen;
   149ac:	19a0      	adds	r0, r4, r6
        if(pEndOpt < pEndHdr)
   149ae:	4287      	cmp	r7, r0
            *pEndOpt = 0;
   149b0:	bf3c      	itt	cc
   149b2:	2000      	movcc	r0, #0
   149b4:	f88c 0004 	strbcc.w	r0, [ip, #4]
    pHdr->TypeOfService.val = 0;
   149b8:	2000      	movs	r0, #0
   149ba:	7060      	strb	r0, [r4, #1]
    if(pParams)
   149bc:	b1fb      	cbz	r3, 149fe <TCPIP_IPV4_PacketFormatTx+0xae>
        if((pParams->tosFlags & TCPIP_IPV4_RELIABILITY_HIGH) != 0)
   149be:	7818      	ldrb	r0, [r3, #0]
   149c0:	f010 0f20 	tst.w	r0, #32
   149c4:	d003      	beq.n	149ce <TCPIP_IPV4_PacketFormatTx+0x7e>
            pHdr->TypeOfService.reliability = 1;
   149c6:	7860      	ldrb	r0, [r4, #1]
   149c8:	f040 0004 	orr.w	r0, r0, #4
   149cc:	7060      	strb	r0, [r4, #1]
        if((pParams->tosFlags & TCPIP_IPV4_THROUGHPUT_HIGH) != 0)
   149ce:	7818      	ldrb	r0, [r3, #0]
   149d0:	f010 0f10 	tst.w	r0, #16
   149d4:	d003      	beq.n	149de <TCPIP_IPV4_PacketFormatTx+0x8e>
            pHdr->TypeOfService.throughput = 1;
   149d6:	7860      	ldrb	r0, [r4, #1]
   149d8:	f040 0008 	orr.w	r0, r0, #8
   149dc:	7060      	strb	r0, [r4, #1]
        if((pParams->tosFlags & TCPIP_IPV4_DELAY_LOW) != 0)
   149de:	7818      	ldrb	r0, [r3, #0]
   149e0:	f010 0f08 	tst.w	r0, #8
   149e4:	d003      	beq.n	149ee <TCPIP_IPV4_PacketFormatTx+0x9e>
            pHdr->TypeOfService.delay = 1;
   149e6:	7860      	ldrb	r0, [r4, #1]
   149e8:	f040 0010 	orr.w	r0, r0, #16
   149ec:	7060      	strb	r0, [r4, #1]
        if((pParams->tosFlags & TCPIP_IPV4_PRECEDENCE_MASK) != 0)
   149ee:	7818      	ldrb	r0, [r3, #0]
   149f0:	f010 0f07 	tst.w	r0, #7
   149f4:	d003      	beq.n	149fe <TCPIP_IPV4_PacketFormatTx+0xae>
            pHdr->TypeOfService.precedence = pParams->tosFlags & TCPIP_IPV4_PRECEDENCE_MASK;
   149f6:	7867      	ldrb	r7, [r4, #1]
   149f8:	f360 1747 	bfi	r7, r0, #5, #3
   149fc:	7067      	strb	r7, [r4, #1]
    pHdr->TotalLength = TCPIP_Helper_htons(hdrLen + ipLoadLen);
   149fe:	4432      	add	r2, r6
   14a00:	b292      	uxth	r2, r2
   14a02:	0a10      	lsrs	r0, r2, #8
   14a04:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
   14a08:	8062      	strh	r2, [r4, #2]
    pHdr->Identification = TCPIP_Helper_htons(++ipv4Identifier);
   14a0a:	4818      	ldr	r0, [pc, #96]	; (14a6c <TCPIP_IPV4_PacketFormatTx+0x11c>)
   14a0c:	8802      	ldrh	r2, [r0, #0]
   14a0e:	3201      	adds	r2, #1
   14a10:	b292      	uxth	r2, r2
   14a12:	8002      	strh	r2, [r0, #0]
   14a14:	0a10      	lsrs	r0, r2, #8
   14a16:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
   14a1a:	80a2      	strh	r2, [r4, #4]
    pHdr->FragmentInfo.val = TCPIP_Helper_htons(0);
   14a1c:	2200      	movs	r2, #0
   14a1e:	80e2      	strh	r2, [r4, #6]
    if(pParams !=0 && pParams->df != 0)
   14a20:	b30b      	cbz	r3, 14a66 <TCPIP_IPV4_PacketFormatTx+0x116>
   14a22:	789a      	ldrb	r2, [r3, #2]
   14a24:	b11a      	cbz	r2, 14a2e <TCPIP_IPV4_PacketFormatTx+0xde>
        pHdr->FragmentInfo.DF = 1;
   14a26:	79e2      	ldrb	r2, [r4, #7]
   14a28:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   14a2c:	71e2      	strb	r2, [r4, #7]
    pHdr->TimeToLive = (pParams != 0 && pParams->ttl != 0) ? pParams->ttl : IPV4_DEFAULT_TTL;
   14a2e:	785b      	ldrb	r3, [r3, #1]
   14a30:	2b00      	cmp	r3, #0
   14a32:	bf08      	it	eq
   14a34:	2364      	moveq	r3, #100	; 0x64
   14a36:	7223      	strb	r3, [r4, #8]
    pHdr->Protocol = protocol;
   14a38:	7261      	strb	r1, [r4, #9]
    pHdr->HeaderChecksum = 0;
   14a3a:	2200      	movs	r2, #0
   14a3c:	8162      	strh	r2, [r4, #10]
    pHdr->SourceAddress.Val = pPkt->srcAddress.Val;
   14a3e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
   14a40:	60e3      	str	r3, [r4, #12]
    pHdr->DestAddress.Val = pPkt->destAddress.Val;
   14a42:	6bab      	ldr	r3, [r5, #56]	; 0x38
   14a44:	6123      	str	r3, [r4, #16]
    pHdr->HeaderChecksum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pHdr, hdrLen, 0);
   14a46:	4631      	mov	r1, r6
   14a48:	4620      	mov	r0, r4
   14a4a:	f007 fc05 	bl	1c258 <TCPIP_Helper_CalcIPChecksum>
   14a4e:	8160      	strh	r0, [r4, #10]
    pPkt->macPkt.pDSeg->segLen += hdrLen;
   14a50:	692a      	ldr	r2, [r5, #16]
   14a52:	8993      	ldrh	r3, [r2, #12]
   14a54:	4433      	add	r3, r6
   14a56:	8193      	strh	r3, [r2, #12]
    pPkt->macPkt.pTransportLayer = pPkt->macPkt.pNetLayer + hdrLen;
   14a58:	69ab      	ldr	r3, [r5, #24]
   14a5a:	441e      	add	r6, r3
   14a5c:	61ee      	str	r6, [r5, #28]
    pPkt->macPkt.pktIf = pPkt->netIfH;
   14a5e:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   14a60:	62ab      	str	r3, [r5, #40]	; 0x28
}
   14a62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    pHdr->TimeToLive = (pParams != 0 && pParams->ttl != 0) ? pParams->ttl : IPV4_DEFAULT_TTL;
   14a66:	2364      	movs	r3, #100	; 0x64
   14a68:	e7e5      	b.n	14a36 <TCPIP_IPV4_PacketFormatTx+0xe6>
   14a6a:	bf00      	nop
   14a6c:	2000ef78 	.word	0x2000ef78

Disassembly of section .text.TCPIP_Helper_StringToIPAddress%314:

00014a70 <TCPIP_Helper_StringToIPAddress>:
{
   14a70:	b4f0      	push	{r4, r5, r6, r7}
   14a72:	b082      	sub	sp, #8
    if(addr)
   14a74:	460d      	mov	r5, r1
   14a76:	b109      	cbz	r1, 14a7c <TCPIP_Helper_StringToIPAddress+0xc>
        addr->Val = 0;
   14a78:	2300      	movs	r3, #0
   14a7a:	600b      	str	r3, [r1, #0]
    if(str == 0 || strlen(str) == 0)
   14a7c:	2800      	cmp	r0, #0
   14a7e:	d071      	beq.n	14b64 <TCPIP_Helper_StringToIPAddress+0xf4>
   14a80:	7803      	ldrb	r3, [r0, #0]
   14a82:	2b00      	cmp	r3, #0
   14a84:	d070      	beq.n	14b68 <TCPIP_Helper_StringToIPAddress+0xf8>
	dwVal.Val = 0;
   14a86:	2100      	movs	r1, #0
	while((i = *str++))
   14a88:	3001      	adds	r0, #1
	currentOctet = 0;
   14a8a:	460c      	mov	r4, r1
	charLen = 0;
   14a8c:	460a      	mov	r2, r1
				if(dwVal.Val > 0x00020505ul)
   14a8e:	4e3f      	ldr	r6, [pc, #252]	; (14b8c <TCPIP_Helper_StringToIPAddress+0x11c>)
   14a90:	e010      	b.n	14ab4 <TCPIP_Helper_StringToIPAddress+0x44>
		else if(charLen == 3u)
   14a92:	2a03      	cmp	r2, #3
   14a94:	d016      	beq.n	14ac4 <TCPIP_Helper_StringToIPAddress+0x54>
			if(i == (uint8_t)('.' - '0'))
   14a96:	2bfe      	cmp	r3, #254	; 0xfe
   14a98:	d031      	beq.n	14afe <TCPIP_Helper_StringToIPAddress+0x8e>
			if(i > 9u)
   14a9a:	2b09      	cmp	r3, #9
   14a9c:	d86c      	bhi.n	14b78 <TCPIP_Helper_StringToIPAddress+0x108>
		charLen++;
   14a9e:	3201      	adds	r2, #1
   14aa0:	b2d2      	uxtb	r2, r2
		dwVal.Val <<= 8;
   14aa2:	0209      	lsls	r1, r1, #8
		dwVal.v[0] = i;
   14aa4:	f363 0107 	bfi	r1, r3, #0, #8
	while((i = *str++))
   14aa8:	f810 3b01 	ldrb.w	r3, [r0], #1
   14aac:	2b00      	cmp	r3, #0
   14aae:	d069      	beq.n	14b84 <TCPIP_Helper_StringToIPAddress+0x114>
		if(currentOctet > 3u)
   14ab0:	2c03      	cmp	r4, #3
   14ab2:	d85d      	bhi.n	14b70 <TCPIP_Helper_StringToIPAddress+0x100>
		i -= '0';
   14ab4:	3b30      	subs	r3, #48	; 0x30
   14ab6:	b2db      	uxtb	r3, r3
		if(charLen == 0u)
   14ab8:	2a00      	cmp	r2, #0
   14aba:	d1ea      	bne.n	14a92 <TCPIP_Helper_StringToIPAddress+0x22>
			if(i > 9u)
   14abc:	2b09      	cmp	r3, #9
   14abe:	d9ee      	bls.n	14a9e <TCPIP_Helper_StringToIPAddress+0x2e>
				return false;
   14ac0:	2000      	movs	r0, #0
   14ac2:	e052      	b.n	14b6a <TCPIP_Helper_StringToIPAddress+0xfa>
			if(i != (uint8_t)('.' - '0'))
   14ac4:	2bfe      	cmp	r3, #254	; 0xfe
   14ac6:	d155      	bne.n	14b74 <TCPIP_Helper_StringToIPAddress+0x104>
			if(dwVal.Val > 0x00020505ul)
   14ac8:	42b1      	cmp	r1, r6
   14aca:	d901      	bls.n	14ad0 <TCPIP_Helper_StringToIPAddress+0x60>
				return false;
   14acc:	2000      	movs	r0, #0
   14ace:	e04c      	b.n	14b6a <TCPIP_Helper_StringToIPAddress+0xfa>
			convAddr.v[currentOctet++] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
   14ad0:	1c62      	adds	r2, r4, #1
   14ad2:	ab02      	add	r3, sp, #8
   14ad4:	441c      	add	r4, r3
   14ad6:	f3c1 4307 	ubfx	r3, r1, #16, #8
   14ada:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   14ade:	eb03 0783 	add.w	r7, r3, r3, lsl #2
   14ae2:	f3c1 2307 	ubfx	r3, r1, #8, #8
   14ae6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   14aea:	005b      	lsls	r3, r3, #1
   14aec:	eb03 0387 	add.w	r3, r3, r7, lsl #2
   14af0:	4419      	add	r1, r3
   14af2:	f804 1c04 	strb.w	r1, [r4, #-4]
			dwVal.Val = 0;
   14af6:	2100      	movs	r1, #0
			convAddr.v[currentOctet++] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
   14af8:	b2d4      	uxtb	r4, r2
			charLen = 0;
   14afa:	460a      	mov	r2, r1
			continue;
   14afc:	e7d4      	b.n	14aa8 <TCPIP_Helper_StringToIPAddress+0x38>
				if(dwVal.Val > 0x00020505ul)
   14afe:	42b1      	cmp	r1, r6
   14b00:	d901      	bls.n	14b06 <TCPIP_Helper_StringToIPAddress+0x96>
					return false;
   14b02:	2000      	movs	r0, #0
   14b04:	e031      	b.n	14b6a <TCPIP_Helper_StringToIPAddress+0xfa>
				convAddr.v[currentOctet++] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
   14b06:	1c62      	adds	r2, r4, #1
   14b08:	ab02      	add	r3, sp, #8
   14b0a:	441c      	add	r4, r3
   14b0c:	f3c1 4307 	ubfx	r3, r1, #16, #8
   14b10:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   14b14:	eb03 0783 	add.w	r7, r3, r3, lsl #2
   14b18:	f3c1 2307 	ubfx	r3, r1, #8, #8
   14b1c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   14b20:	005b      	lsls	r3, r3, #1
   14b22:	eb03 0387 	add.w	r3, r3, r7, lsl #2
   14b26:	4419      	add	r1, r3
   14b28:	f804 1c04 	strb.w	r1, [r4, #-4]
				dwVal.Val = 0;
   14b2c:	2100      	movs	r1, #0
				convAddr.v[currentOctet++] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
   14b2e:	b2d4      	uxtb	r4, r2
				charLen = 0;
   14b30:	460a      	mov	r2, r1
				continue;
   14b32:	e7b9      	b.n	14aa8 <TCPIP_Helper_StringToIPAddress+0x38>
	if(dwVal.Val > 0x00020505ul)
   14b34:	4b15      	ldr	r3, [pc, #84]	; (14b8c <TCPIP_Helper_StringToIPAddress+0x11c>)
   14b36:	4299      	cmp	r1, r3
   14b38:	d820      	bhi.n	14b7c <TCPIP_Helper_StringToIPAddress+0x10c>
	convAddr.v[3] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
   14b3a:	f3c1 4307 	ubfx	r3, r1, #16, #8
   14b3e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   14b42:	eb03 0283 	add.w	r2, r3, r3, lsl #2
   14b46:	f3c1 2307 	ubfx	r3, r1, #8, #8
   14b4a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   14b4e:	005b      	lsls	r3, r3, #1
   14b50:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   14b54:	4419      	add	r1, r3
   14b56:	f88d 1007 	strb.w	r1, [sp, #7]
    if(addr)
   14b5a:	b18d      	cbz	r5, 14b80 <TCPIP_Helper_StringToIPAddress+0x110>
        addr->Val = convAddr.Val;
   14b5c:	9b01      	ldr	r3, [sp, #4]
   14b5e:	602b      	str	r3, [r5, #0]
	return true;
   14b60:	2001      	movs	r0, #1
   14b62:	e002      	b.n	14b6a <TCPIP_Helper_StringToIPAddress+0xfa>
        return true;
   14b64:	2001      	movs	r0, #1
   14b66:	e000      	b.n	14b6a <TCPIP_Helper_StringToIPAddress+0xfa>
   14b68:	2001      	movs	r0, #1
}
   14b6a:	b002      	add	sp, #8
   14b6c:	bcf0      	pop	{r4, r5, r6, r7}
   14b6e:	4770      	bx	lr
		return false;
   14b70:	2000      	movs	r0, #0
   14b72:	e7fa      	b.n	14b6a <TCPIP_Helper_StringToIPAddress+0xfa>
				return false;
   14b74:	2000      	movs	r0, #0
   14b76:	e7f8      	b.n	14b6a <TCPIP_Helper_StringToIPAddress+0xfa>
				return false;
   14b78:	2000      	movs	r0, #0
   14b7a:	e7f6      	b.n	14b6a <TCPIP_Helper_StringToIPAddress+0xfa>
		return false;
   14b7c:	2000      	movs	r0, #0
   14b7e:	e7f4      	b.n	14b6a <TCPIP_Helper_StringToIPAddress+0xfa>
	return true;
   14b80:	2001      	movs	r0, #1
   14b82:	e7f2      	b.n	14b6a <TCPIP_Helper_StringToIPAddress+0xfa>
	if(currentOctet != 3 || (i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t' && i != ':'))
   14b84:	2c03      	cmp	r4, #3
   14b86:	d0d5      	beq.n	14b34 <TCPIP_Helper_StringToIPAddress+0xc4>
		return false;
   14b88:	2000      	movs	r0, #0
   14b8a:	e7ee      	b.n	14b6a <TCPIP_Helper_StringToIPAddress+0xfa>
   14b8c:	00020505 	.word	0x00020505

Disassembly of section .text.DRV_GMAC_EventMaskSet%315:

00014b90 <DRV_GMAC_EventMaskSet>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   14b90:	4b45      	ldr	r3, [pc, #276]	; (14ca8 <DRV_GMAC_EventMaskSet+0x118>)
   14b92:	4283      	cmp	r3, r0
   14b94:	f040 8082 	bne.w	14c9c <DRV_GMAC_EventMaskSet+0x10c>
    if(pMACDrv == 0)
   14b98:	2800      	cmp	r0, #0
   14b9a:	f000 8081 	beq.w	14ca0 <DRV_GMAC_EventMaskSet+0x110>
{
   14b9e:	b570      	push	{r4, r5, r6, lr}
   14ba0:	b082      	sub	sp, #8
   14ba2:	4615      	mov	r5, r2
   14ba4:	460c      	mov	r4, r1
	if(enable)
   14ba6:	2a00      	cmp	r2, #0
   14ba8:	d03d      	beq.n	14c26 <DRV_GMAC_EventMaskSet+0x96>
		ethSetEvents = _XtlEventsTcp2Eth(macEvMask);
   14baa:	4608      	mov	r0, r1
   14bac:	f00c fd2e 	bl	2160c <_XtlEventsTcp2Eth>
   14bb0:	4606      	mov	r6, r0
		if(pDcpt->_TcpEnabledEvents != 0)
   14bb2:	4b3d      	ldr	r3, [pc, #244]	; (14ca8 <DRV_GMAC_EventMaskSet+0x118>)
   14bb4:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
   14bb8:	bb7b      	cbnz	r3, 14c1a <DRV_GMAC_EventMaskSet+0x8a>
		pDcpt->_TcpEnabledEvents |= macEvMask;        // add more
   14bba:	4b3b      	ldr	r3, [pc, #236]	; (14ca8 <DRV_GMAC_EventMaskSet+0x118>)
   14bbc:	f8b3 104c 	ldrh.w	r1, [r3, #76]	; 0x4c
   14bc0:	430c      	orrs	r4, r1
   14bc2:	f8a3 404c 	strh.w	r4, [r3, #76]	; 0x4c
		pDcpt->_EthEnabledEvents |= ethSetEvents;
   14bc6:	f8b3 2050 	ldrh.w	r2, [r3, #80]	; 0x50
   14bca:	4332      	orrs	r2, r6
   14bcc:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
		if(pDcpt->_TcpEnabledEvents != 0)
   14bd0:	2c00      	cmp	r4, #0
   14bd2:	d067      	beq.n	14ca4 <DRV_GMAC_EventMaskSet+0x114>
			ethSetEvents &= ~pDcpt->_EthPendingEvents;		// keep just the new un-ack events			
   14bd4:	f8b3 4052 	ldrh.w	r4, [r3, #82]	; 0x52
   14bd8:	ea26 0404 	bic.w	r4, r6, r4
   14bdc:	b2a4      	uxth	r4, r4
                if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queIdx].queueTxEnable != true)
   14bde:	f893 30ce 	ldrb.w	r3, [r3, #206]	; 0xce
   14be2:	2b01      	cmp	r3, #1
                    ethEvents = ethEvents & (~GMAC_EV_TX_ALL);
   14be4:	bf1c      	itt	ne
   14be6:	f024 04d0 	bicne.w	r4, r4, #208	; 0xd0
   14bea:	b2a4      	uxthne	r4, r4
                if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queIdx].queueRxEnable != true)
   14bec:	4b2e      	ldr	r3, [pc, #184]	; (14ca8 <DRV_GMAC_EventMaskSet+0x118>)
   14bee:	f893 30cf 	ldrb.w	r3, [r3, #207]	; 0xcf
   14bf2:	2b01      	cmp	r3, #1
   14bf4:	d004      	beq.n	14c00 <DRV_GMAC_EventMaskSet+0x70>
                    ethEvents = ethEvents & (~GMAC_EV_RX_ALL);
   14bf6:	f424 6480 	bic.w	r4, r4, #1024	; 0x400
   14bfa:	f024 0406 	bic.w	r4, r4, #6
   14bfe:	b2a4      	uxth	r4, r4
                DRV_PIC32CGMAC_LibReadInterruptStatus(queIdx);
   14c00:	2000      	movs	r0, #0
   14c02:	f00f fad7 	bl	241b4 <DRV_PIC32CGMAC_LibReadInterruptStatus>
                DRV_PIC32CGMAC_LibEnableInterrupt(queIdx, ethEvents);
   14c06:	4621      	mov	r1, r4
   14c08:	2000      	movs	r0, #0
   14c0a:	f00f fad9 	bl	241c0 <DRV_PIC32CGMAC_LibEnableInterrupt>
            DRV_PIC32CGMAC_LibSysInt_Enable(pMACDrv, GMAC_ALL_QUE_MASK);
   14c0e:	213f      	movs	r1, #63	; 0x3f
   14c10:	4825      	ldr	r0, [pc, #148]	; (14ca8 <DRV_GMAC_EventMaskSet+0x118>)
   14c12:	f00d f947 	bl	21ea4 <DRV_PIC32CGMAC_LibSysInt_Enable>
	return true;
   14c16:	4628      	mov	r0, r5
   14c18:	e032      	b.n	14c80 <DRV_GMAC_EventMaskSet+0xf0>
            DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, NULL);
   14c1a:	2200      	movs	r2, #0
   14c1c:	213f      	movs	r1, #63	; 0x3f
   14c1e:	4822      	ldr	r0, [pc, #136]	; (14ca8 <DRV_GMAC_EventMaskSet+0x118>)
   14c20:	f00d fc7e 	bl	22520 <DRV_PIC32CGMAC_LibSysInt_Disable>
   14c24:	e7c9      	b.n	14bba <DRV_GMAC_EventMaskSet+0x2a>
		macEvMask &= pDcpt->_TcpEnabledEvents;                  // keep just the enabled ones
   14c26:	4b20      	ldr	r3, [pc, #128]	; (14ca8 <DRV_GMAC_EventMaskSet+0x118>)
   14c28:	f8b3 604c 	ldrh.w	r6, [r3, #76]	; 0x4c
   14c2c:	4034      	ands	r4, r6
		ethClrEvents = _XtlEventsTcp2Eth(macEvMask);
   14c2e:	4620      	mov	r0, r4
   14c30:	f00c fcec 	bl	2160c <_XtlEventsTcp2Eth>
   14c34:	4605      	mov	r5, r0
		if(pDcpt->_TcpEnabledEvents != 0)
   14c36:	bb2e      	cbnz	r6, 14c84 <DRV_GMAC_EventMaskSet+0xf4>
		pDcpt->_TcpEnabledEvents &= ~macEvMask;     // clear some of them
   14c38:	43e4      	mvns	r4, r4
   14c3a:	b224      	sxth	r4, r4
   14c3c:	4e1a      	ldr	r6, [pc, #104]	; (14ca8 <DRV_GMAC_EventMaskSet+0x118>)
   14c3e:	f8b6 304c 	ldrh.w	r3, [r6, #76]	; 0x4c
   14c42:	4023      	ands	r3, r4
   14c44:	f8a6 304c 	strh.w	r3, [r6, #76]	; 0x4c
		pDcpt->_EthEnabledEvents &= ~ethClrEvents;
   14c48:	43eb      	mvns	r3, r5
   14c4a:	b21b      	sxth	r3, r3
   14c4c:	f8b6 2050 	ldrh.w	r2, [r6, #80]	; 0x50
   14c50:	401a      	ands	r2, r3
   14c52:	f8a6 2050 	strh.w	r2, [r6, #80]	; 0x50
		pDcpt->_TcpPendingEvents &= ~macEvMask;     // remove them from un-ack list
   14c56:	f8b6 204e 	ldrh.w	r2, [r6, #78]	; 0x4e
   14c5a:	4014      	ands	r4, r2
   14c5c:	f8a6 404e 	strh.w	r4, [r6, #78]	; 0x4e
		pDcpt->_EthPendingEvents &= ~ethClrEvents;
   14c60:	f8b6 2052 	ldrh.w	r2, [r6, #82]	; 0x52
   14c64:	4013      	ands	r3, r2
   14c66:	f8a6 3052 	strh.w	r3, [r6, #82]	; 0x52
            DRV_PIC32CGMAC_LibDisableInterrupt(queIdx, ethClrEvents);
   14c6a:	4629      	mov	r1, r5
   14c6c:	2000      	movs	r0, #0
   14c6e:	f00f faad 	bl	241cc <DRV_PIC32CGMAC_LibDisableInterrupt>
            DRV_PIC32CGMAC_LibReadInterruptStatus(queIdx);
   14c72:	2000      	movs	r0, #0
   14c74:	f00f fa9e 	bl	241b4 <DRV_PIC32CGMAC_LibReadInterruptStatus>
		if(pDcpt->_TcpEnabledEvents != 0)
   14c78:	f8b6 304c 	ldrh.w	r3, [r6, #76]	; 0x4c
   14c7c:	b943      	cbnz	r3, 14c90 <DRV_GMAC_EventMaskSet+0x100>
	return true;
   14c7e:	2001      	movs	r0, #1
}
   14c80:	b002      	add	sp, #8
   14c82:	bd70      	pop	{r4, r5, r6, pc}
            DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, intStat);
   14c84:	aa01      	add	r2, sp, #4
   14c86:	213f      	movs	r1, #63	; 0x3f
   14c88:	4807      	ldr	r0, [pc, #28]	; (14ca8 <DRV_GMAC_EventMaskSet+0x118>)
   14c8a:	f00d fc49 	bl	22520 <DRV_PIC32CGMAC_LibSysInt_Disable>
   14c8e:	e7d3      	b.n	14c38 <DRV_GMAC_EventMaskSet+0xa8>
            DRV_PIC32CGMAC_LibSysInt_Restore(pMACDrv, GMAC_ALL_QUE_MASK, intStat);
   14c90:	aa01      	add	r2, sp, #4
   14c92:	213f      	movs	r1, #63	; 0x3f
   14c94:	4630      	mov	r0, r6
   14c96:	f00e fce9 	bl	2366c <DRV_PIC32CGMAC_LibSysInt_Restore>
   14c9a:	e7f0      	b.n	14c7e <DRV_GMAC_EventMaskSet+0xee>
        return false;
   14c9c:	2000      	movs	r0, #0
   14c9e:	4770      	bx	lr
   14ca0:	2000      	movs	r0, #0
}
   14ca2:	4770      	bx	lr
	return true;
   14ca4:	4628      	mov	r0, r5
   14ca6:	e7eb      	b.n	14c80 <DRV_GMAC_EventMaskSet+0xf0>
   14ca8:	2000e288 	.word	0x2000e288

Disassembly of section .text._UDPv4TxAckFnc%316:

00014cac <_UDPv4TxAckFnc>:
{
   14cac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   14cb0:	4606      	mov	r6, r0
	while(pSkt != 0)
   14cb2:	2900      	cmp	r1, #0
   14cb4:	d071      	beq.n	14d9a <_UDPv4TxAckFnc+0xee>
   14cb6:	460c      	mov	r4, r1
        status =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   14cb8:	2000      	movs	r0, #0
   14cba:	f00e fd5b 	bl	23774 <OSAL_CRIT_Enter>
   14cbe:	4601      	mov	r1, r0
        sktIx = pSkt->sktIx;
   14cc0:	f9b4 5012 	ldrsh.w	r5, [r4, #18]
        if(UDPSocketDcpt == 0 || sktIx < 0 || sktIx >= nUdpSockets || pSkt != UDPSocketDcpt[sktIx])
   14cc4:	4b3e      	ldr	r3, [pc, #248]	; (14dc0 <_UDPv4TxAckFnc+0x114>)
   14cc6:	681b      	ldr	r3, [r3, #0]
   14cc8:	2b00      	cmp	r3, #0
   14cca:	d073      	beq.n	14db4 <_UDPv4TxAckFnc+0x108>
   14ccc:	2d00      	cmp	r5, #0
   14cce:	db73      	blt.n	14db8 <_UDPv4TxAckFnc+0x10c>
   14cd0:	4a3c      	ldr	r2, [pc, #240]	; (14dc4 <_UDPv4TxAckFnc+0x118>)
   14cd2:	6812      	ldr	r2, [r2, #0]
   14cd4:	4295      	cmp	r5, r2
   14cd6:	da71      	bge.n	14dbc <_UDPv4TxAckFnc+0x110>
   14cd8:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
   14cdc:	42a3      	cmp	r3, r4
   14cde:	d001      	beq.n	14ce4 <_UDPv4TxAckFnc+0x38>
        critLock = true;
   14ce0:	2401      	movs	r4, #1
   14ce2:	e05d      	b.n	14da0 <_UDPv4TxAckFnc+0xf4>
        if(pPkt->modPktData != 0)
   14ce4:	8e73      	ldrh	r3, [r6, #50]	; 0x32
   14ce6:	b14b      	cbz	r3, 14cfc <_UDPv4TxAckFnc+0x50>
            pPkt->modPktData = 0;
   14ce8:	f04f 0900 	mov.w	r9, #0
   14cec:	f8a6 9032 	strh.w	r9, [r6, #50]	; 0x32
    const void* sigParam = 0;
   14cf0:	46c8      	mov	r8, r9
    TCPIP_UDP_SIGNAL_FUNCTION sigHandler = 0;
   14cf2:	464f      	mov	r7, r9
            loopPkt = true;
   14cf4:	f04f 0a01 	mov.w	sl, #1
    bool freePkt = true;
   14cf8:	2400      	movs	r4, #0
   14cfa:	e014      	b.n	14d26 <_UDPv4TxAckFnc+0x7a>
        if((pSkt->sigMask & TCPIP_UDP_SIGNAL_TX_DONE) != 0)
   14cfc:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
   14d00:	f013 0f01 	tst.w	r3, #1
   14d04:	d020      	beq.n	14d48 <_UDPv4TxAckFnc+0x9c>
            sigHandler = pSkt->sigHandler;
   14d06:	6d27      	ldr	r7, [r4, #80]	; 0x50
            sigParam = pSkt->sigParam;
   14d08:	f8d4 8054 	ldr.w	r8, [r4, #84]	; 0x54
            pktIf = pPkt->pktIf;
   14d0c:	f8d6 9028 	ldr.w	r9, [r6, #40]	; 0x28
        if(pSkt->pV4Pkt != (IPV4_PACKET*)pPkt)
   14d10:	68e3      	ldr	r3, [r4, #12]
   14d12:	42b3      	cmp	r3, r6
   14d14:	d01d      	beq.n	14d52 <_UDPv4TxAckFnc+0xa6>
        pSkt->txAllocCnt--;
   14d16:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
   14d1a:	3b01      	subs	r3, #1
   14d1c:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
    bool    loopPkt = false;
   14d20:	f04f 0a00 	mov.w	sl, #0
    bool freePkt = true;
   14d24:	2401      	movs	r4, #1
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   14d26:	2000      	movs	r0, #0
   14d28:	f00e fe5e 	bl	239e8 <OSAL_CRIT_Leave>
    if(loopPkt)
   14d2c:	f1ba 0f00 	cmp.w	sl, #0
   14d30:	d129      	bne.n	14d86 <_UDPv4TxAckFnc+0xda>
    if(freePkt)
   14d32:	2c00      	cmp	r4, #0
   14d34:	d13a      	bne.n	14dac <_UDPv4TxAckFnc+0x100>
    if(sigHandler)
   14d36:	b127      	cbz	r7, 14d42 <_UDPv4TxAckFnc+0x96>
        (*sigHandler)(sktIx, pktIf, TCPIP_UDP_SIGNAL_TX_DONE, sigParam);
   14d38:	4643      	mov	r3, r8
   14d3a:	2201      	movs	r2, #1
   14d3c:	4649      	mov	r1, r9
   14d3e:	4628      	mov	r0, r5
   14d40:	47b8      	blx	r7
}
   14d42:	2000      	movs	r0, #0
   14d44:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    const void* sigParam = 0;
   14d48:	f04f 0800 	mov.w	r8, #0
    TCPIP_UDP_SIGNAL_FUNCTION sigHandler = 0;
   14d4c:	4647      	mov	r7, r8
    TCPIP_NET_HANDLE pktIf = 0;
   14d4e:	46c1      	mov	r9, r8
   14d50:	e7de      	b.n	14d10 <_UDPv4TxAckFnc+0x64>
    pPkt->macPkt.pDSeg->segLen = 0;
   14d52:	6933      	ldr	r3, [r6, #16]
   14d54:	2200      	movs	r2, #0
   14d56:	819a      	strh	r2, [r3, #12]
    if(pSkt->flags.txSplitAlloc)
   14d58:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
   14d5c:	f013 0f02 	tst.w	r3, #2
        ((UDP_V4_PACKET*)pPkt)->zcSeg->segLen = 0;
   14d60:	bf19      	ittee	ne
   14d62:	4613      	movne	r3, r2
   14d64:	f8a6 2050 	strhne.w	r2, [r6, #80]	; 0x50
        pSkt->txWrite = pSkt->txStart;
   14d68:	6823      	ldreq	r3, [r4, #0]
   14d6a:	60a3      	streq	r3, [r4, #8]
    pPkt->macPkt.pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED;
   14d6c:	8c73      	ldrh	r3, [r6, #34]	; 0x22
   14d6e:	f023 0308 	bic.w	r3, r3, #8
   14d72:	8473      	strh	r3, [r6, #34]	; 0x22
    bool    loopPkt = false;
   14d74:	f04f 0a00 	mov.w	sl, #0
   14d78:	e7be      	b.n	14cf8 <_UDPv4TxAckFnc+0x4c>
    if(critLock)
   14d7a:	f04f 0800 	mov.w	r8, #0
   14d7e:	4647      	mov	r7, r8
   14d80:	46c2      	mov	sl, r8
   14d82:	46c1      	mov	r9, r8
   14d84:	e7cf      	b.n	14d26 <_UDPv4TxAckFnc+0x7a>
        pPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_MCAST;
   14d86:	8c73      	ldrh	r3, [r6, #34]	; 0x22
   14d88:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   14d8c:	8473      	strh	r3, [r6, #34]	; 0x22
        _TCPIPStackInsertRxPacket((TCPIP_NET_IF*)pPkt->pktIf, pPkt, true);
   14d8e:	2201      	movs	r2, #1
   14d90:	4631      	mov	r1, r6
   14d92:	6ab0      	ldr	r0, [r6, #40]	; 0x28
   14d94:	f007 fe2a 	bl	1c9ec <_TCPIPStackInsertRxPacket>
        return false;
   14d98:	e7d3      	b.n	14d42 <_UDPv4TxAckFnc+0x96>
    OSAL_CRITSECT_DATA_TYPE status = 0;
   14d9a:	2100      	movs	r1, #0
    bool critLock = false;
   14d9c:	460c      	mov	r4, r1
    UDP_SOCKET   sktIx = 0;
   14d9e:	460d      	mov	r5, r1
    if(critLock)
   14da0:	2c00      	cmp	r4, #0
   14da2:	d1ea      	bne.n	14d7a <_UDPv4TxAckFnc+0xce>
   14da4:	f04f 0800 	mov.w	r8, #0
   14da8:	4647      	mov	r7, r8
   14daa:	46c1      	mov	r9, r8
            TCPIP_PKT_PacketFree(pPkt);
   14dac:	4630      	mov	r0, r6
   14dae:	f00b f9df 	bl	20170 <_TCPIP_PKT_PacketFree>
   14db2:	e7c0      	b.n	14d36 <_UDPv4TxAckFnc+0x8a>
        critLock = true;
   14db4:	2401      	movs	r4, #1
   14db6:	e7f3      	b.n	14da0 <_UDPv4TxAckFnc+0xf4>
   14db8:	2401      	movs	r4, #1
   14dba:	e7f1      	b.n	14da0 <_UDPv4TxAckFnc+0xf4>
   14dbc:	2401      	movs	r4, #1
   14dbe:	e7ef      	b.n	14da0 <_UDPv4TxAckFnc+0xf4>
   14dc0:	2000ee88 	.word	0x2000ee88
   14dc4:	2000ee8c 	.word	0x2000ee8c

Disassembly of section .text.wc_RNG_GenerateBlock%317:

00014dc8 <wc_RNG_GenerateBlock>:
    if (rng == NULL || output == NULL)
   14dc8:	2800      	cmp	r0, #0
   14dca:	d074      	beq.n	14eb6 <wc_RNG_GenerateBlock+0xee>
{
   14dcc:	b5f0      	push	{r4, r5, r6, r7, lr}
   14dce:	b0a5      	sub	sp, #148	; 0x94
   14dd0:	4606      	mov	r6, r0
    if (rng == NULL || output == NULL)
   14dd2:	2900      	cmp	r1, #0
   14dd4:	d073      	beq.n	14ebe <wc_RNG_GenerateBlock+0xf6>
    if (sz == 0)
   14dd6:	2a00      	cmp	r2, #0
   14dd8:	d074      	beq.n	14ec4 <wc_RNG_GenerateBlock+0xfc>
   14dda:	4615      	mov	r5, r2
   14ddc:	460c      	mov	r4, r1
    if (rng->devId != INVALID_DEVID) {
   14dde:	6943      	ldr	r3, [r0, #20]
   14de0:	f113 0f02 	cmn.w	r3, #2
   14de4:	d116      	bne.n	14e14 <wc_RNG_GenerateBlock+0x4c>
    if (sz > RNG_MAX_BLOCK_LEN)
   14de6:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
   14dea:	d86f      	bhi.n	14ecc <wc_RNG_GenerateBlock+0x104>
    if (rng->status != DRBG_OK)
   14dec:	7c33      	ldrb	r3, [r6, #16]
   14dee:	2b01      	cmp	r3, #1
   14df0:	d16f      	bne.n	14ed2 <wc_RNG_GenerateBlock+0x10a>
    ret = Hash_DRBG_Generate((DRBG_internal *)rng->drbg, output, sz);
   14df2:	462a      	mov	r2, r5
   14df4:	4621      	mov	r1, r4
   14df6:	68f0      	ldr	r0, [r6, #12]
   14df8:	f7f8 fb30 	bl	d45c <Hash_DRBG_Generate>
   14dfc:	4603      	mov	r3, r0
    if (ret == DRBG_NEED_RESEED) {
   14dfe:	2802      	cmp	r0, #2
   14e00:	d010      	beq.n	14e24 <wc_RNG_GenerateBlock+0x5c>
    if (ret == DRBG_SUCCESS) {
   14e02:	2b00      	cmp	r3, #0
   14e04:	d05f      	beq.n	14ec6 <wc_RNG_GenerateBlock+0xfe>
    else if (ret == DRBG_CONT_FAILURE) {
   14e06:	2b03      	cmp	r3, #3
   14e08:	d050      	beq.n	14eac <wc_RNG_GenerateBlock+0xe4>
        rng->status = DRBG_FAILED;
   14e0a:	2302      	movs	r3, #2
   14e0c:	7433      	strb	r3, [r6, #16]
        ret = RNG_FAILURE_E;
   14e0e:	f06f 03c6 	mvn.w	r3, #198	; 0xc6
   14e12:	e058      	b.n	14ec6 <wc_RNG_GenerateBlock+0xfe>
        ret = wc_CryptoCb_RandomBlock(rng, output, sz);
   14e14:	f008 fcc2 	bl	1d79c <wc_CryptoCb_RandomBlock>
   14e18:	4603      	mov	r3, r0
        if (ret != CRYPTOCB_UNAVAILABLE)
   14e1a:	f46f 7287 	mvn.w	r2, #270	; 0x10e
   14e1e:	4290      	cmp	r0, r2
   14e20:	d151      	bne.n	14ec6 <wc_RNG_GenerateBlock+0xfe>
   14e22:	e7e0      	b.n	14de6 <wc_RNG_GenerateBlock+0x1e>
        ret = wc_RNG_HealthTest(1, seedA, sizeof(seedA_data),
   14e24:	2380      	movs	r3, #128	; 0x80
   14e26:	9302      	str	r3, [sp, #8]
   14e28:	ab04      	add	r3, sp, #16
   14e2a:	9301      	str	r3, [sp, #4]
   14e2c:	2320      	movs	r3, #32
   14e2e:	9300      	str	r3, [sp, #0]
   14e30:	4b29      	ldr	r3, [pc, #164]	; (14ed8 <wc_RNG_GenerateBlock+0x110>)
   14e32:	2230      	movs	r2, #48	; 0x30
   14e34:	4929      	ldr	r1, [pc, #164]	; (14edc <wc_RNG_GenerateBlock+0x114>)
   14e36:	2001      	movs	r0, #1
   14e38:	f00c fece 	bl	21bd8 <wc_RNG_HealthTest>
        if (ret == 0) {
   14e3c:	4601      	mov	r1, r0
   14e3e:	2800      	cmp	r0, #0
   14e40:	d134      	bne.n	14eac <wc_RNG_GenerateBlock+0xe4>
   14e42:	f10d 020f 	add.w	r2, sp, #15
   14e46:	4826      	ldr	r0, [pc, #152]	; (14ee0 <wc_RNG_GenerateBlock+0x118>)
   14e48:	f10d 0c8f 	add.w	ip, sp, #143	; 0x8f
        compareSum |= a[i] ^ b[i];
   14e4c:	f812 3f01 	ldrb.w	r3, [r2, #1]!
   14e50:	f810 7f01 	ldrb.w	r7, [r0, #1]!
   14e54:	407b      	eors	r3, r7
   14e56:	4319      	orrs	r1, r3
    for (i = 0; i < length; i++) {
   14e58:	4562      	cmp	r2, ip
   14e5a:	d1f7      	bne.n	14e4c <wc_RNG_GenerateBlock+0x84>
            if (ConstantCompare(check, outputA,
   14e5c:	bb31      	cbnz	r1, 14eac <wc_RNG_GenerateBlock+0xe4>
            ret = wc_GenerateSeed(&rng->seed, newSeed,
   14e5e:	2224      	movs	r2, #36	; 0x24
   14e60:	a904      	add	r1, sp, #16
   14e62:	4630      	mov	r0, r6
   14e64:	f007 f832 	bl	1becc <wc_GenerateSeed>
            if (ret != 0)
   14e68:	b150      	cbz	r0, 14e80 <wc_RNG_GenerateBlock+0xb8>
                ret = DRBG_FAILURE;
   14e6a:	2301      	movs	r3, #1
    volatile byte* z = (volatile byte*)mem;
   14e6c:	a904      	add	r1, sp, #16
    while (len--) *z++ = 0;
   14e6e:	2400      	movs	r4, #0
   14e70:	a80d      	add	r0, sp, #52	; 0x34
   14e72:	460a      	mov	r2, r1
   14e74:	f802 4b01 	strb.w	r4, [r2], #1
   14e78:	4611      	mov	r1, r2
   14e7a:	4282      	cmp	r2, r0
   14e7c:	d1f9      	bne.n	14e72 <wc_RNG_GenerateBlock+0xaa>
   14e7e:	e7c0      	b.n	14e02 <wc_RNG_GenerateBlock+0x3a>
                ret = wc_RNG_TestSeed(newSeed, SEED_SZ + SEED_BLOCK_SZ);
   14e80:	2124      	movs	r1, #36	; 0x24
   14e82:	a804      	add	r0, sp, #16
   14e84:	f007 fe1a 	bl	1cabc <wc_RNG_TestSeed>
            if (ret == DRBG_SUCCESS)
   14e88:	4603      	mov	r3, r0
   14e8a:	2800      	cmp	r0, #0
   14e8c:	d1ee      	bne.n	14e6c <wc_RNG_GenerateBlock+0xa4>
	      ret = Hash_DRBG_Reseed((DRBG_internal *)rng->drbg, newSeed + SEED_BLOCK_SZ,
   14e8e:	2220      	movs	r2, #32
   14e90:	a905      	add	r1, sp, #20
   14e92:	68f0      	ldr	r0, [r6, #12]
   14e94:	f003 fe76 	bl	18b84 <Hash_DRBG_Reseed>
            if (ret == DRBG_SUCCESS)
   14e98:	4603      	mov	r3, r0
   14e9a:	2800      	cmp	r0, #0
   14e9c:	d1e6      	bne.n	14e6c <wc_RNG_GenerateBlock+0xa4>
	      ret = Hash_DRBG_Generate((DRBG_internal *)rng->drbg, output, sz);
   14e9e:	462a      	mov	r2, r5
   14ea0:	4621      	mov	r1, r4
   14ea2:	68f0      	ldr	r0, [r6, #12]
   14ea4:	f7f8 fada 	bl	d45c <Hash_DRBG_Generate>
   14ea8:	4603      	mov	r3, r0
   14eaa:	e7df      	b.n	14e6c <wc_RNG_GenerateBlock+0xa4>
        rng->status = DRBG_CONT_FAILED;
   14eac:	2303      	movs	r3, #3
   14eae:	7433      	strb	r3, [r6, #16]
        ret = DRBG_CONT_FIPS_E;
   14eb0:	f06f 03d0 	mvn.w	r3, #208	; 0xd0
   14eb4:	e007      	b.n	14ec6 <wc_RNG_GenerateBlock+0xfe>
        return BAD_FUNC_ARG;
   14eb6:	f06f 03ac 	mvn.w	r3, #172	; 0xac
}
   14eba:	4618      	mov	r0, r3
   14ebc:	4770      	bx	lr
        return BAD_FUNC_ARG;
   14ebe:	f06f 03ac 	mvn.w	r3, #172	; 0xac
   14ec2:	e000      	b.n	14ec6 <wc_RNG_GenerateBlock+0xfe>
        return 0; 
   14ec4:	2300      	movs	r3, #0
}
   14ec6:	4618      	mov	r0, r3
   14ec8:	b025      	add	sp, #148	; 0x94
   14eca:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return BAD_FUNC_ARG;
   14ecc:	f06f 03ac 	mvn.w	r3, #172	; 0xac
   14ed0:	e7f9      	b.n	14ec6 <wc_RNG_GenerateBlock+0xfe>
        return RNG_FAILURE_E;
   14ed2:	f06f 03c6 	mvn.w	r3, #198	; 0xc6
   14ed6:	e7f6      	b.n	14ec6 <wc_RNG_GenerateBlock+0xfe>
   14ed8:	00022da0 	.word	0x00022da0
   14edc:	0002154c 	.word	0x0002154c
   14ee0:	0001b113 	.word	0x0001b113

Disassembly of section .text.xTaskIncrementTick%318:

00014ee4 <xTaskIncrementTick>:
{
   14ee4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   14ee8:	4b38      	ldr	r3, [pc, #224]	; (14fcc <xTaskIncrementTick+0xe8>)
   14eea:	681b      	ldr	r3, [r3, #0]
   14eec:	2b00      	cmp	r3, #0
   14eee:	d167      	bne.n	14fc0 <xTaskIncrementTick+0xdc>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
   14ef0:	4b37      	ldr	r3, [pc, #220]	; (14fd0 <xTaskIncrementTick+0xec>)
   14ef2:	681f      	ldr	r7, [r3, #0]
   14ef4:	3701      	adds	r7, #1
		xTickCount = xConstTickCount;
   14ef6:	601f      	str	r7, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
   14ef8:	b1bf      	cbz	r7, 14f2a <xTaskIncrementTick+0x46>
		if( xConstTickCount >= xNextTaskUnblockTime )
   14efa:	4b36      	ldr	r3, [pc, #216]	; (14fd4 <xTaskIncrementTick+0xf0>)
   14efc:	681b      	ldr	r3, [r3, #0]
   14efe:	42bb      	cmp	r3, r7
   14f00:	d920      	bls.n	14f44 <xTaskIncrementTick+0x60>
BaseType_t xSwitchRequired = pdFALSE;
   14f02:	2500      	movs	r5, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   14f04:	4b34      	ldr	r3, [pc, #208]	; (14fd8 <xTaskIncrementTick+0xf4>)
   14f06:	681b      	ldr	r3, [r3, #0]
   14f08:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   14f0a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   14f0e:	009b      	lsls	r3, r3, #2
   14f10:	4a32      	ldr	r2, [pc, #200]	; (14fdc <xTaskIncrementTick+0xf8>)
   14f12:	58d3      	ldr	r3, [r2, r3]
				xSwitchRequired = pdTRUE;
   14f14:	2b02      	cmp	r3, #2
   14f16:	bf28      	it	cs
   14f18:	2501      	movcs	r5, #1
			if( xYieldPending != pdFALSE )
   14f1a:	4b31      	ldr	r3, [pc, #196]	; (14fe0 <xTaskIncrementTick+0xfc>)
   14f1c:	681b      	ldr	r3, [r3, #0]
				xSwitchRequired = pdTRUE;
   14f1e:	2b00      	cmp	r3, #0
   14f20:	bf18      	it	ne
   14f22:	2501      	movne	r5, #1
}
   14f24:	4628      	mov	r0, r5
   14f26:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			taskSWITCH_DELAYED_LISTS();
   14f2a:	4a2e      	ldr	r2, [pc, #184]	; (14fe4 <xTaskIncrementTick+0x100>)
   14f2c:	6811      	ldr	r1, [r2, #0]
   14f2e:	4b2e      	ldr	r3, [pc, #184]	; (14fe8 <xTaskIncrementTick+0x104>)
   14f30:	6818      	ldr	r0, [r3, #0]
   14f32:	6010      	str	r0, [r2, #0]
   14f34:	6019      	str	r1, [r3, #0]
   14f36:	4a2d      	ldr	r2, [pc, #180]	; (14fec <xTaskIncrementTick+0x108>)
   14f38:	6813      	ldr	r3, [r2, #0]
   14f3a:	3301      	adds	r3, #1
   14f3c:	6013      	str	r3, [r2, #0]
   14f3e:	f00c fe35 	bl	21bac <prvResetNextTaskUnblockTime>
   14f42:	e7da      	b.n	14efa <xTaskIncrementTick+0x16>
BaseType_t xSwitchRequired = pdFALSE;
   14f44:	2500      	movs	r5, #0
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   14f46:	f8df 809c 	ldr.w	r8, [pc, #156]	; 14fe4 <xTaskIncrementTick+0x100>
					prvAddTaskToReadyList( pxTCB );
   14f4a:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 14ff4 <xTaskIncrementTick+0x110>
   14f4e:	f8df a08c 	ldr.w	sl, [pc, #140]	; 14fdc <xTaskIncrementTick+0xf8>
   14f52:	e021      	b.n	14f98 <xTaskIncrementTick+0xb4>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   14f54:	4b1f      	ldr	r3, [pc, #124]	; (14fd4 <xTaskIncrementTick+0xf0>)
   14f56:	f04f 32ff 	mov.w	r2, #4294967295
   14f5a:	601a      	str	r2, [r3, #0]
					break;
   14f5c:	e7d2      	b.n	14f04 <xTaskIncrementTick+0x20>
						xNextTaskUnblockTime = xItemValue;
   14f5e:	4a1d      	ldr	r2, [pc, #116]	; (14fd4 <xTaskIncrementTick+0xf0>)
   14f60:	6013      	str	r3, [r2, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
   14f62:	e7cf      	b.n	14f04 <xTaskIncrementTick+0x20>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   14f64:	f104 0018 	add.w	r0, r4, #24
   14f68:	f00d fbdc 	bl	22724 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   14f6c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   14f6e:	f8d9 2000 	ldr.w	r2, [r9]
   14f72:	2301      	movs	r3, #1
   14f74:	4083      	lsls	r3, r0
   14f76:	4313      	orrs	r3, r2
   14f78:	f8c9 3000 	str.w	r3, [r9]
   14f7c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   14f80:	4631      	mov	r1, r6
   14f82:	eb0a 0080 	add.w	r0, sl, r0, lsl #2
   14f86:	f00e fd45 	bl	23a14 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   14f8a:	4b13      	ldr	r3, [pc, #76]	; (14fd8 <xTaskIncrementTick+0xf4>)
   14f8c:	681b      	ldr	r3, [r3, #0]
   14f8e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   14f90:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
   14f92:	429a      	cmp	r2, r3
   14f94:	bf28      	it	cs
   14f96:	2501      	movcs	r5, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   14f98:	f8d8 3000 	ldr.w	r3, [r8]
   14f9c:	681b      	ldr	r3, [r3, #0]
   14f9e:	2b00      	cmp	r3, #0
   14fa0:	d0d8      	beq.n	14f54 <xTaskIncrementTick+0x70>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   14fa2:	f8d8 3000 	ldr.w	r3, [r8]
   14fa6:	68db      	ldr	r3, [r3, #12]
   14fa8:	68dc      	ldr	r4, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
   14faa:	6863      	ldr	r3, [r4, #4]
					if( xConstTickCount < xItemValue )
   14fac:	429f      	cmp	r7, r3
   14fae:	d3d6      	bcc.n	14f5e <xTaskIncrementTick+0x7a>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   14fb0:	1d26      	adds	r6, r4, #4
   14fb2:	4630      	mov	r0, r6
   14fb4:	f00d fbb6 	bl	22724 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   14fb8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   14fba:	2b00      	cmp	r3, #0
   14fbc:	d1d2      	bne.n	14f64 <xTaskIncrementTick+0x80>
   14fbe:	e7d5      	b.n	14f6c <xTaskIncrementTick+0x88>
		++xPendedTicks;
   14fc0:	4a0b      	ldr	r2, [pc, #44]	; (14ff0 <xTaskIncrementTick+0x10c>)
   14fc2:	6813      	ldr	r3, [r2, #0]
   14fc4:	3301      	adds	r3, #1
   14fc6:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
   14fc8:	2500      	movs	r5, #0
	return xSwitchRequired;
   14fca:	e7ab      	b.n	14f24 <xTaskIncrementTick+0x40>
   14fcc:	2000ef14 	.word	0x2000ef14
   14fd0:	2000ef34 	.word	0x2000ef34
   14fd4:	2000ef24 	.word	0x2000ef24
   14fd8:	2000ef00 	.word	0x2000ef00
   14fdc:	2000e850 	.word	0x2000e850
   14fe0:	2000ef38 	.word	0x2000ef38
   14fe4:	2000ef04 	.word	0x2000ef04
   14fe8:	2000ef08 	.word	0x2000ef08
   14fec:	2000ef28 	.word	0x2000ef28
   14ff0:	2000ef2c 	.word	0x2000ef2c
   14ff4:	2000ef1c 	.word	0x2000ef1c

Disassembly of section .text.CommandPingHandler%319:

00014ff8 <CommandPingHandler>:
    if(result == TCPIP_ICMP_ECHO_REQUEST_RES_OK)
   14ff8:	2a00      	cmp	r2, #0
   14ffa:	d168      	bne.n	150ce <CommandPingHandler+0xd6>
{
   14ffc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15000:	b088      	sub	sp, #32
        if(pEchoReq->identifier != icmpIdentifier)
   15002:	8943      	ldrh	r3, [r0, #10]
   15004:	4a34      	ldr	r2, [pc, #208]	; (150d8 <CommandPingHandler+0xe0>)
   15006:	8812      	ldrh	r2, [r2, #0]
   15008:	1a9a      	subs	r2, r3, r2
   1500a:	bf18      	it	ne
   1500c:	2201      	movne	r2, #1
        if(pEchoReq->sequenceNumber != icmpSequenceNo)
   1500e:	8901      	ldrh	r1, [r0, #8]
   15010:	4b32      	ldr	r3, [pc, #200]	; (150dc <CommandPingHandler+0xe4>)
   15012:	881b      	ldrh	r3, [r3, #0]
   15014:	4299      	cmp	r1, r3
            errorMask |= 0x2;
   15016:	bf18      	it	ne
   15018:	f042 0202 	orrne.w	r2, r2, #2
   1501c:	4680      	mov	r8, r0
        if(pEchoReq->dataSize != icmpPingSize)
   1501e:	8a03      	ldrh	r3, [r0, #16]
   15020:	492f      	ldr	r1, [pc, #188]	; (150e0 <CommandPingHandler+0xe8>)
   15022:	680f      	ldr	r7, [r1, #0]
   15024:	42bb      	cmp	r3, r7
   15026:	d028      	beq.n	1507a <CommandPingHandler+0x82>
            errorMask |= 0x8;
   15028:	f042 0208 	orr.w	r2, r2, #8
        int checkSize = pEchoReq->dataSize < icmpPingSize ? pEchoReq->dataSize : icmpPingSize;
   1502c:	429f      	cmp	r7, r3
   1502e:	bfa8      	it	ge
   15030:	461f      	movge	r7, r3
        uint8_t* pDst = pEchoReq->pData;
   15032:	68c1      	ldr	r1, [r0, #12]
        for(ix = 0; ix < checkSize; ix++)
   15034:	2f00      	cmp	r7, #0
   15036:	dd12      	ble.n	1505e <CommandPingHandler+0x66>
            if(*pSrc++ != *pDst++)
   15038:	4b2a      	ldr	r3, [pc, #168]	; (150e4 <CommandPingHandler+0xec>)
   1503a:	7818      	ldrb	r0, [r3, #0]
   1503c:	f811 3b01 	ldrb.w	r3, [r1], #1
   15040:	4298      	cmp	r0, r3
   15042:	d10a      	bne.n	1505a <CommandPingHandler+0x62>
   15044:	4c28      	ldr	r4, [pc, #160]	; (150e8 <CommandPingHandler+0xf0>)
        for(ix = 0; ix < checkSize; ix++)
   15046:	2300      	movs	r3, #0
   15048:	3301      	adds	r3, #1
   1504a:	42bb      	cmp	r3, r7
   1504c:	da18      	bge.n	15080 <CommandPingHandler+0x88>
            if(*pSrc++ != *pDst++)
   1504e:	f814 6b01 	ldrb.w	r6, [r4], #1
   15052:	f811 5b01 	ldrb.w	r5, [r1], #1
   15056:	42ae      	cmp	r6, r5
   15058:	d0f6      	beq.n	15048 <CommandPingHandler+0x50>
                errorMask |= 0x10;
   1505a:	f042 0210 	orr.w	r2, r2, #16
            (*pTcpipCmdDevice->pCmdApi->print)(icmpCmdIoParam, "Ping: wrong reply received. Mask: 0x%2x\r\n", errorMask);
   1505e:	4b23      	ldr	r3, [pc, #140]	; (150ec <CommandPingHandler+0xf4>)
   15060:	681b      	ldr	r3, [r3, #0]
   15062:	681b      	ldr	r3, [r3, #0]
   15064:	685b      	ldr	r3, [r3, #4]
   15066:	4922      	ldr	r1, [pc, #136]	; (150f0 <CommandPingHandler+0xf8>)
   15068:	4822      	ldr	r0, [pc, #136]	; (150f4 <CommandPingHandler+0xfc>)
   1506a:	6800      	ldr	r0, [r0, #0]
   1506c:	4798      	blx	r3
    icmpReqHandle = 0;
   1506e:	4b22      	ldr	r3, [pc, #136]	; (150f8 <CommandPingHandler+0x100>)
   15070:	2200      	movs	r2, #0
   15072:	601a      	str	r2, [r3, #0]
}
   15074:	b008      	add	sp, #32
   15076:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        uint8_t* pDst = pEchoReq->pData;
   1507a:	68c1      	ldr	r1, [r0, #12]
        for(ix = 0; ix < checkSize; ix++)
   1507c:	2f00      	cmp	r7, #0
   1507e:	dcdb      	bgt.n	15038 <CommandPingHandler+0x40>
        if(errorMask != 0)
   15080:	2a00      	cmp	r2, #0
   15082:	d1ec      	bne.n	1505e <CommandPingHandler+0x66>
            uint32_t pingTicks = SYS_TMR_TickCountGet() - icmpStartTick;
   15084:	f00d f8da 	bl	2223c <SYS_TMR_TickCountGet>
   15088:	4b1c      	ldr	r3, [pc, #112]	; (150fc <CommandPingHandler+0x104>)
   1508a:	681c      	ldr	r4, [r3, #0]
   1508c:	1b00      	subs	r0, r0, r4
            int pingMs = (pingTicks * 1000) / SYS_TMR_TickCounterFrequencyGet();
   1508e:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
   15092:	fb04 f400 	mul.w	r4, r4, r0
   15096:	f00d f8f9 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
   1509a:	fbb4 f4f0 	udiv	r4, r4, r0
                pingMs = 1;
   1509e:	2c00      	cmp	r4, #0
   150a0:	bf08      	it	eq
   150a2:	2401      	moveq	r4, #1
            TCPIP_Helper_IPAddressToString(&pEchoReq->targetAddr, addBuff, sizeof(addBuff));
   150a4:	2214      	movs	r2, #20
   150a6:	a903      	add	r1, sp, #12
   150a8:	f108 0004 	add.w	r0, r8, #4
   150ac:	f009 fbe2 	bl	1e874 <TCPIP_Helper_IPAddressToString>
            (*pTcpipCmdDevice->pCmdApi->print)(icmpCmdIoParam, "Ping: reply[%d] from %s: time = %dms\r\n", ++icmpAckRecv, addBuff, pingMs);
   150b0:	4b0e      	ldr	r3, [pc, #56]	; (150ec <CommandPingHandler+0xf4>)
   150b2:	681b      	ldr	r3, [r3, #0]
   150b4:	681b      	ldr	r3, [r3, #0]
   150b6:	685d      	ldr	r5, [r3, #4]
   150b8:	4b11      	ldr	r3, [pc, #68]	; (15100 <CommandPingHandler+0x108>)
   150ba:	681a      	ldr	r2, [r3, #0]
   150bc:	3201      	adds	r2, #1
   150be:	601a      	str	r2, [r3, #0]
   150c0:	9400      	str	r4, [sp, #0]
   150c2:	ab03      	add	r3, sp, #12
   150c4:	490f      	ldr	r1, [pc, #60]	; (15104 <CommandPingHandler+0x10c>)
   150c6:	480b      	ldr	r0, [pc, #44]	; (150f4 <CommandPingHandler+0xfc>)
   150c8:	6800      	ldr	r0, [r0, #0]
   150ca:	47a8      	blx	r5
   150cc:	e7cf      	b.n	1506e <CommandPingHandler+0x76>
    icmpReqHandle = 0;
   150ce:	4b0a      	ldr	r3, [pc, #40]	; (150f8 <CommandPingHandler+0x100>)
   150d0:	2200      	movs	r2, #0
   150d2:	601a      	str	r2, [r3, #0]
   150d4:	4770      	bx	lr
   150d6:	bf00      	nop
   150d8:	2000ef72 	.word	0x2000ef72
   150dc:	2000ef76 	.word	0x2000ef76
   150e0:	2000ee1c 	.word	0x2000ee1c
   150e4:	2000ca04 	.word	0x2000ca04
   150e8:	2000ca05 	.word	0x2000ca05
   150ec:	2000ee14 	.word	0x2000ee14
   150f0:	0000164c 	.word	0x0000164c
   150f4:	2000edec 	.word	0x2000edec
   150f8:	2000edfc 	.word	0x2000edfc
   150fc:	2000ee04 	.word	0x2000ee04
   15100:	2000ede8 	.word	0x2000ede8
   15104:	00001678 	.word	0x00001678

Disassembly of section .text.DHCPSPingHandler%320:

00015108 <DHCPSPingHandler>:
    }
   
}

static void DHCPSPingHandler(const  TCPIP_ICMP_ECHO_REQUEST* pEchoReq, TCPIP_ICMP_REQUEST_HANDLE iHandle, TCPIP_ICMP_ECHO_REQUEST_RESULT result)
{
   15108:	b570      	push	{r4, r5, r6, lr}
   1510a:	b0a0      	sub	sp, #128	; 0x80
    char debugBuf[128];
    
    if(result == TCPIP_ICMP_ECHO_REQUEST_RES_OK)
   1510c:	2a00      	cmp	r2, #0
   1510e:	d14b      	bne.n	151a8 <DHCPSPingHandler+0xa0>
        // 0x2: wrong seq
        // 0x4: wrong target
        // 0x8: wrong size
        // 0x10: wrong data
        //
        if(pEchoReq->identifier != dhcpsicmpIdentifier)
   15110:	8943      	ldrh	r3, [r0, #10]
   15112:	4a33      	ldr	r2, [pc, #204]	; (151e0 <DHCPSPingHandler+0xd8>)
   15114:	8812      	ldrh	r2, [r2, #0]
   15116:	1a9a      	subs	r2, r3, r2
   15118:	bf18      	it	ne
   1511a:	2201      	movne	r2, #1
        {
            errorMask |= 0x1;
        }

        if(pEchoReq->sequenceNumber != dhcpsicmpSequenceNo)
   1511c:	8901      	ldrh	r1, [r0, #8]
   1511e:	4b31      	ldr	r3, [pc, #196]	; (151e4 <DHCPSPingHandler+0xdc>)
   15120:	881b      	ldrh	r3, [r3, #0]
   15122:	4299      	cmp	r1, r3
        {
            errorMask |= 0x2;
   15124:	bf18      	it	ne
   15126:	f042 0202 	orrne.w	r2, r2, #2
        }

        if(pEchoReq->targetAddr.Val != dhcpsicmpTargetAddr.Val)
   1512a:	6841      	ldr	r1, [r0, #4]
   1512c:	4b2e      	ldr	r3, [pc, #184]	; (151e8 <DHCPSPingHandler+0xe0>)
   1512e:	681b      	ldr	r3, [r3, #0]
   15130:	4299      	cmp	r1, r3
        {
            errorMask |= 0x4;
   15132:	bf18      	it	ne
   15134:	f042 0204 	orrne.w	r2, r2, #4
        }

        if(pEchoReq->dataSize != dhcpsicmpPingSize)
   15138:	8a03      	ldrh	r3, [r0, #16]
   1513a:	2b64      	cmp	r3, #100	; 0x64
   1513c:	d04c      	beq.n	151d8 <DHCPSPingHandler+0xd0>
        {
            errorMask |= 0x8;
   1513e:	f042 0208 	orr.w	r2, r2, #8
        }

        // check the data
        int ix;
        int checkSize = pEchoReq->dataSize < dhcpsicmpPingSize ? pEchoReq->dataSize : dhcpsicmpPingSize;
   15142:	461e      	mov	r6, r3
   15144:	2b64      	cmp	r3, #100	; 0x64
   15146:	bfa8      	it	ge
   15148:	2664      	movge	r6, #100	; 0x64
        uint8_t* pSrc = dhcpsicmpPingBuff;
        uint8_t* pDst = pEchoReq->pData;
   1514a:	68c1      	ldr	r1, [r0, #12]
        for(ix = 0; ix < checkSize; ix++)
   1514c:	b193      	cbz	r3, 15174 <DHCPSPingHandler+0x6c>
        {
            if(*pSrc++ != *pDst++)
   1514e:	4b27      	ldr	r3, [pc, #156]	; (151ec <DHCPSPingHandler+0xe4>)
   15150:	7818      	ldrb	r0, [r3, #0]
   15152:	f811 3b01 	ldrb.w	r3, [r1], #1
   15156:	4298      	cmp	r0, r3
   15158:	d10a      	bne.n	15170 <DHCPSPingHandler+0x68>
   1515a:	4825      	ldr	r0, [pc, #148]	; (151f0 <DHCPSPingHandler+0xe8>)
        for(ix = 0; ix < checkSize; ix++)
   1515c:	2300      	movs	r3, #0
   1515e:	3301      	adds	r3, #1
   15160:	42b3      	cmp	r3, r6
   15162:	da13      	bge.n	1518c <DHCPSPingHandler+0x84>
            if(*pSrc++ != *pDst++)
   15164:	f810 5b01 	ldrb.w	r5, [r0], #1
   15168:	f811 4b01 	ldrb.w	r4, [r1], #1
   1516c:	42a5      	cmp	r5, r4
   1516e:	d0f6      	beq.n	1515e <DHCPSPingHandler+0x56>
            {
                errorMask |= 0x10;
   15170:	f042 0210 	orr.w	r2, r2, #16
            }
        }

        if(errorMask != 0)
        {   // some errors
            sprintf(debugBuf,"Ping: wrong reply received. Mask: 0x%2x\r\n", (unsigned int)errorMask);
   15174:	491f      	ldr	r1, [pc, #124]	; (151f4 <DHCPSPingHandler+0xec>)
   15176:	4668      	mov	r0, sp
   15178:	f00a fa6e 	bl	1f658 <siprintf>
            _DhcpsICMPDebugMessage(debugBuf);
            dhcpsicmpProcessSteps = DHCPS_ICMP_WRONG_RESPONSE_RECEIVED;
   1517c:	4b1e      	ldr	r3, [pc, #120]	; (151f8 <DHCPSPingHandler+0xf0>)
   1517e:	2205      	movs	r2, #5
   15180:	701a      	strb	r2, [r3, #0]
            _DhcpsICMPDebugMessage(debugBuf);
            dhcpsicmpProcessSteps = DHCPS_ICMP_NO_RESPONSE_RECEIVED;
        }
    }
    // one way or the other, request is done
    dhcpsicmpReqHandle = 0;
   15182:	4b1e      	ldr	r3, [pc, #120]	; (151fc <DHCPSPingHandler+0xf4>)
   15184:	2200      	movs	r2, #0
   15186:	601a      	str	r2, [r3, #0]
}
   15188:	b020      	add	sp, #128	; 0x80
   1518a:	bd70      	pop	{r4, r5, r6, pc}
        if(errorMask != 0)
   1518c:	2a00      	cmp	r2, #0
   1518e:	d1f1      	bne.n	15174 <DHCPSPingHandler+0x6c>
            sprintf(debugBuf,"Ping: Good reply received: 0x%2x\r\n", ++dhcpsicmpAckRecv);
   15190:	4b1b      	ldr	r3, [pc, #108]	; (15200 <DHCPSPingHandler+0xf8>)
   15192:	681a      	ldr	r2, [r3, #0]
   15194:	3201      	adds	r2, #1
   15196:	601a      	str	r2, [r3, #0]
   15198:	491a      	ldr	r1, [pc, #104]	; (15204 <DHCPSPingHandler+0xfc>)
   1519a:	4668      	mov	r0, sp
   1519c:	f00a fa5c 	bl	1f658 <siprintf>
            dhcpsicmpProcessSteps = DHCPS_ICMP_RESPONSE_RECEIVED;
   151a0:	4b15      	ldr	r3, [pc, #84]	; (151f8 <DHCPSPingHandler+0xf0>)
   151a2:	2204      	movs	r2, #4
   151a4:	701a      	strb	r2, [r3, #0]
   151a6:	e7ec      	b.n	15182 <DHCPSPingHandler+0x7a>
   151a8:	4613      	mov	r3, r2
        if(dhcpsicmpReqCount < dhcpsicmpReqNo)
   151aa:	4a17      	ldr	r2, [pc, #92]	; (15208 <DHCPSPingHandler+0x100>)
   151ac:	6812      	ldr	r2, [r2, #0]
   151ae:	4917      	ldr	r1, [pc, #92]	; (1520c <DHCPSPingHandler+0x104>)
   151b0:	6809      	ldr	r1, [r1, #0]
   151b2:	428a      	cmp	r2, r1
   151b4:	da07      	bge.n	151c6 <DHCPSPingHandler+0xbe>
            sprintf(debugBuf,"Ping: Number of request attempted %d\r\n", dhcpsicmpReqCount);
   151b6:	4916      	ldr	r1, [pc, #88]	; (15210 <DHCPSPingHandler+0x108>)
   151b8:	4668      	mov	r0, sp
   151ba:	f00a fa4d 	bl	1f658 <siprintf>
            dhcpsicmpProcessSteps = DHCPS_ICMP_WAIT_REPLY;
   151be:	4b0e      	ldr	r3, [pc, #56]	; (151f8 <DHCPSPingHandler+0xf0>)
   151c0:	2202      	movs	r2, #2
   151c2:	701a      	strb	r2, [r3, #0]
   151c4:	e7dd      	b.n	15182 <DHCPSPingHandler+0x7a>
            sprintf(debugBuf,"Ping: request aborted by ICMP with result %d\r\n", result);
   151c6:	461a      	mov	r2, r3
   151c8:	4912      	ldr	r1, [pc, #72]	; (15214 <DHCPSPingHandler+0x10c>)
   151ca:	4668      	mov	r0, sp
   151cc:	f00a fa44 	bl	1f658 <siprintf>
            dhcpsicmpProcessSteps = DHCPS_ICMP_NO_RESPONSE_RECEIVED;
   151d0:	4b09      	ldr	r3, [pc, #36]	; (151f8 <DHCPSPingHandler+0xf0>)
   151d2:	2203      	movs	r2, #3
   151d4:	701a      	strb	r2, [r3, #0]
   151d6:	e7d4      	b.n	15182 <DHCPSPingHandler+0x7a>
        uint8_t* pDst = pEchoReq->pData;
   151d8:	68c1      	ldr	r1, [r0, #12]
        int checkSize = pEchoReq->dataSize < dhcpsicmpPingSize ? pEchoReq->dataSize : dhcpsicmpPingSize;
   151da:	461e      	mov	r6, r3
   151dc:	e7b7      	b.n	1514e <DHCPSPingHandler+0x46>
   151de:	bf00      	nop
   151e0:	2000ef84 	.word	0x2000ef84
   151e4:	2000ef86 	.word	0x2000ef86
   151e8:	2000eec4 	.word	0x2000eec4
   151ec:	2000d1d4 	.word	0x2000d1d4
   151f0:	2000d1d5 	.word	0x2000d1d5
   151f4:	0000d1fc 	.word	0x0000d1fc
   151f8:	2000ef8e 	.word	0x2000ef8e
   151fc:	2000eeb8 	.word	0x2000eeb8
   15200:	2000eea8 	.word	0x2000eea8
   15204:	0000d228 	.word	0x0000d228
   15208:	2000eeb0 	.word	0x2000eeb0
   1520c:	2000eebc 	.word	0x2000eebc
   15210:	0000d24c 	.word	0x0000d24c
   15214:	0000d274 	.word	0x0000d274

Disassembly of section .text%321:

00015218 <__gedf2>:
   15218:	f04f 3cff 	mov.w	ip, #4294967295
   1521c:	e006      	b.n	1522c <__cmpdf2+0x4>
   1521e:	bf00      	nop

00015220 <__ledf2>:
   15220:	f04f 0c01 	mov.w	ip, #1
   15224:	e002      	b.n	1522c <__cmpdf2+0x4>
   15226:	bf00      	nop

00015228 <__cmpdf2>:
   15228:	f04f 0c01 	mov.w	ip, #1
   1522c:	f84d cd04 	str.w	ip, [sp, #-4]!
   15230:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   15234:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   15238:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   1523c:	bf18      	it	ne
   1523e:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
   15242:	d01b      	beq.n	1527c <__cmpdf2+0x54>
   15244:	b001      	add	sp, #4
   15246:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
   1524a:	bf0c      	ite	eq
   1524c:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
   15250:	ea91 0f03 	teqne	r1, r3
   15254:	bf02      	ittt	eq
   15256:	ea90 0f02 	teqeq	r0, r2
   1525a:	2000      	moveq	r0, #0
   1525c:	4770      	bxeq	lr
   1525e:	f110 0f00 	cmn.w	r0, #0
   15262:	ea91 0f03 	teq	r1, r3
   15266:	bf58      	it	pl
   15268:	4299      	cmppl	r1, r3
   1526a:	bf08      	it	eq
   1526c:	4290      	cmpeq	r0, r2
   1526e:	bf2c      	ite	cs
   15270:	17d8      	asrcs	r0, r3, #31
   15272:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
   15276:	f040 0001 	orr.w	r0, r0, #1
   1527a:	4770      	bx	lr
   1527c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   15280:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   15284:	d102      	bne.n	1528c <__cmpdf2+0x64>
   15286:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
   1528a:	d107      	bne.n	1529c <__cmpdf2+0x74>
   1528c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   15290:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   15294:	d1d6      	bne.n	15244 <__cmpdf2+0x1c>
   15296:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
   1529a:	d0d3      	beq.n	15244 <__cmpdf2+0x1c>
   1529c:	f85d 0b04 	ldr.w	r0, [sp], #4
   152a0:	4770      	bx	lr
   152a2:	bf00      	nop

000152a4 <__aeabi_cdrcmple>:
   152a4:	4684      	mov	ip, r0
   152a6:	4610      	mov	r0, r2
   152a8:	4662      	mov	r2, ip
   152aa:	468c      	mov	ip, r1
   152ac:	4619      	mov	r1, r3
   152ae:	4663      	mov	r3, ip
   152b0:	e000      	b.n	152b4 <__aeabi_cdcmpeq>
   152b2:	bf00      	nop

000152b4 <__aeabi_cdcmpeq>:
   152b4:	b501      	push	{r0, lr}
   152b6:	f7ff ffb7 	bl	15228 <__cmpdf2>
   152ba:	2800      	cmp	r0, #0
   152bc:	bf48      	it	mi
   152be:	f110 0f00 	cmnmi.w	r0, #0
   152c2:	bd01      	pop	{r0, pc}

000152c4 <__aeabi_dcmpeq>:
   152c4:	f84d ed08 	str.w	lr, [sp, #-8]!
   152c8:	f7ff fff4 	bl	152b4 <__aeabi_cdcmpeq>
   152cc:	bf0c      	ite	eq
   152ce:	2001      	moveq	r0, #1
   152d0:	2000      	movne	r0, #0
   152d2:	f85d fb08 	ldr.w	pc, [sp], #8
   152d6:	bf00      	nop

000152d8 <__aeabi_dcmplt>:
   152d8:	f84d ed08 	str.w	lr, [sp, #-8]!
   152dc:	f7ff ffea 	bl	152b4 <__aeabi_cdcmpeq>
   152e0:	bf34      	ite	cc
   152e2:	2001      	movcc	r0, #1
   152e4:	2000      	movcs	r0, #0
   152e6:	f85d fb08 	ldr.w	pc, [sp], #8
   152ea:	bf00      	nop

000152ec <__aeabi_dcmple>:
   152ec:	f84d ed08 	str.w	lr, [sp, #-8]!
   152f0:	f7ff ffe0 	bl	152b4 <__aeabi_cdcmpeq>
   152f4:	bf94      	ite	ls
   152f6:	2001      	movls	r0, #1
   152f8:	2000      	movhi	r0, #0
   152fa:	f85d fb08 	ldr.w	pc, [sp], #8
   152fe:	bf00      	nop

00015300 <__aeabi_dcmpge>:
   15300:	f84d ed08 	str.w	lr, [sp, #-8]!
   15304:	f7ff ffce 	bl	152a4 <__aeabi_cdrcmple>
   15308:	bf94      	ite	ls
   1530a:	2001      	movls	r0, #1
   1530c:	2000      	movhi	r0, #0
   1530e:	f85d fb08 	ldr.w	pc, [sp], #8
   15312:	bf00      	nop

00015314 <__aeabi_dcmpgt>:
   15314:	f84d ed08 	str.w	lr, [sp, #-8]!
   15318:	f7ff ffc4 	bl	152a4 <__aeabi_cdrcmple>
   1531c:	bf34      	ite	cc
   1531e:	2001      	movcc	r0, #1
   15320:	2000      	movcs	r0, #0
   15322:	f85d fb08 	ldr.w	pc, [sp], #8
   15326:	bf00      	nop

Disassembly of section .text._Tcpv4TxAckFnc%322:

00015328 <_Tcpv4TxAckFnc>:
{
   15328:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1532c:	4681      	mov	r9, r0
    while(pSkt != 0)
   1532e:	460e      	mov	r6, r1
   15330:	2900      	cmp	r1, #0
   15332:	d051      	beq.n	153d8 <_Tcpv4TxAckFnc+0xb0>
        status =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   15334:	2000      	movs	r0, #0
   15336:	f00e fa1d 	bl	23774 <OSAL_CRIT_Enter>
   1533a:	4601      	mov	r1, r0
        sktIx = pSkt->sktIx;
   1533c:	f9b6 7034 	ldrsh.w	r7, [r6, #52]	; 0x34
        if(TCBStubs == 0 || sktIx < 0 || sktIx >= TcpSockets || pSkt != TCBStubs[sktIx])
   15340:	4b3a      	ldr	r3, [pc, #232]	; (1542c <_Tcpv4TxAckFnc+0x104>)
   15342:	681c      	ldr	r4, [r3, #0]
   15344:	2c00      	cmp	r4, #0
   15346:	d04f      	beq.n	153e8 <_Tcpv4TxAckFnc+0xc0>
   15348:	2f00      	cmp	r7, #0
   1534a:	db61      	blt.n	15410 <_Tcpv4TxAckFnc+0xe8>
   1534c:	4b38      	ldr	r3, [pc, #224]	; (15430 <_Tcpv4TxAckFnc+0x108>)
   1534e:	681b      	ldr	r3, [r3, #0]
   15350:	429f      	cmp	r7, r3
   15352:	d264      	bcs.n	1541e <_Tcpv4TxAckFnc+0xf6>
   15354:	f854 3027 	ldr.w	r3, [r4, r7, lsl #2]
   15358:	42b3      	cmp	r3, r6
   1535a:	d006      	beq.n	1536a <_Tcpv4TxAckFnc+0x42>
    const void* sigParam = 0;
   1535c:	2400      	movs	r4, #0
    TCPIP_TCP_SIGNAL_FUNCTION sigHandler = 0;
   1535e:	4625      	mov	r5, r4
    bool freePkt = true;
   15360:	f04f 0a01 	mov.w	sl, #1
    TCPIP_TCP_SIGNAL_TYPE sigType = 0;
   15364:	46a0      	mov	r8, r4
    TCPIP_NET_HANDLE pktIf = 0;
   15366:	4626      	mov	r6, r4
   15368:	e043      	b.n	153f2 <_Tcpv4TxAckFnc+0xca>
        if((pPkt->pDSeg->segFlags & TCPIP_MAC_SEG_FLAG_USER_PAYLOAD) != 0)
   1536a:	f8d9 3010 	ldr.w	r3, [r9, #16]
   1536e:	8a1b      	ldrh	r3, [r3, #16]
   15370:	f003 0308 	and.w	r3, r3, #8
            sigType = TCPIP_TCP_SIGNAL_TX_DONE;
   15374:	2b00      	cmp	r3, #0
   15376:	bf14      	ite	ne
   15378:	f04f 0803 	movne.w	r8, #3
   1537c:	f04f 0801 	moveq.w	r8, #1
        if((sigType &= pSkt->sigMask) != 0)
   15380:	f8b6 3072 	ldrh.w	r3, [r6, #114]	; 0x72
   15384:	ea18 0803 	ands.w	r8, r8, r3
   15388:	d00a      	beq.n	153a0 <_Tcpv4TxAckFnc+0x78>
            sigHandler = pSkt->sigHandler;
   1538a:	6f75      	ldr	r5, [r6, #116]	; 0x74
            sigParam = pSkt->sigParam;
   1538c:	6fb4      	ldr	r4, [r6, #120]	; 0x78
            pktIf = pPkt->pktIf;
   1538e:	f8d9 0028 	ldr.w	r0, [r9, #40]	; 0x28
        if(pSkt->pV4Pkt != &((TCP_V4_PACKET*)pPkt)->v4Pkt)
   15392:	6c72      	ldr	r2, [r6, #68]	; 0x44
   15394:	454a      	cmp	r2, r9
   15396:	d007      	beq.n	153a8 <_Tcpv4TxAckFnc+0x80>
   15398:	4606      	mov	r6, r0
    bool freePkt = true;
   1539a:	f04f 0a01 	mov.w	sl, #1
   1539e:	e028      	b.n	153f2 <_Tcpv4TxAckFnc+0xca>
    const void* sigParam = 0;
   153a0:	2400      	movs	r4, #0
    TCPIP_TCP_SIGNAL_FUNCTION sigHandler = 0;
   153a2:	4625      	mov	r5, r4
    TCPIP_NET_HANDLE pktIf = 0;
   153a4:	4620      	mov	r0, r4
   153a6:	e7f4      	b.n	15392 <_Tcpv4TxAckFnc+0x6a>
    pSeg->segLen = pSeg->segSize = 0;
   153a8:	2300      	movs	r3, #0
   153aa:	f8a2 3052 	strh.w	r3, [r2, #82]	; 0x52
   153ae:	f8a2 3050 	strh.w	r3, [r2, #80]	; 0x50
    pSeg->next = 0;
   153b2:	6453      	str	r3, [r2, #68]	; 0x44
    pSeg->segLen = pSeg->segSize = 0;
   153b4:	f8a2 306a 	strh.w	r3, [r2, #106]	; 0x6a
   153b8:	f8a2 3068 	strh.w	r3, [r2, #104]	; 0x68
    pSeg->next = 0;
   153bc:	65d3      	str	r3, [r2, #92]	; 0x5c
    pTcpPkt->v4Pkt.macPkt.pDSeg->next = 0;    // unlink to the 1st data seg; leave header only
   153be:	6916      	ldr	r6, [r2, #16]
   153c0:	6033      	str	r3, [r6, #0]
    pTcpPkt->v4Pkt.macPkt.pDSeg->segLen = 0;  // clear the payload
   153c2:	6912      	ldr	r2, [r2, #16]
   153c4:	8193      	strh	r3, [r2, #12]
        pPkt->pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED;
   153c6:	f8b9 2022 	ldrh.w	r2, [r9, #34]	; 0x22
   153ca:	f022 0208 	bic.w	r2, r2, #8
   153ce:	f8a9 2022 	strh.w	r2, [r9, #34]	; 0x22
        break;
   153d2:	4606      	mov	r6, r0
        freePkt = false;
   153d4:	469a      	mov	sl, r3
        break;
   153d6:	e00c      	b.n	153f2 <_Tcpv4TxAckFnc+0xca>
    const void* sigParam = 0;
   153d8:	460c      	mov	r4, r1
    TCPIP_TCP_SIGNAL_FUNCTION sigHandler = 0;
   153da:	2500      	movs	r5, #0
    TCP_SOCKET   sktIx = 0;
   153dc:	462f      	mov	r7, r5
    TCPIP_TCP_SIGNAL_TYPE sigType = 0;
   153de:	46a8      	mov	r8, r5
        TCPIP_PKT_PacketFree(pPkt);
   153e0:	4648      	mov	r0, r9
   153e2:	f00a fec5 	bl	20170 <_TCPIP_PKT_PacketFree>
   153e6:	e00a      	b.n	153fe <_Tcpv4TxAckFnc+0xd6>
    TCPIP_NET_HANDLE pktIf = 0;
   153e8:	4626      	mov	r6, r4
    TCPIP_TCP_SIGNAL_FUNCTION sigHandler = 0;
   153ea:	2500      	movs	r5, #0
    bool freePkt = true;
   153ec:	f04f 0a01 	mov.w	sl, #1
    TCPIP_TCP_SIGNAL_TYPE sigType = 0;
   153f0:	46a8      	mov	r8, r5
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   153f2:	2000      	movs	r0, #0
   153f4:	f00e faf8 	bl	239e8 <OSAL_CRIT_Leave>
    if(freePkt)
   153f8:	f1ba 0f00 	cmp.w	sl, #0
   153fc:	d1f0      	bne.n	153e0 <_Tcpv4TxAckFnc+0xb8>
    if(sigHandler)
   153fe:	b125      	cbz	r5, 1540a <_Tcpv4TxAckFnc+0xe2>
        (*sigHandler)(sktIx, pktIf, sigType, sigParam);
   15400:	4623      	mov	r3, r4
   15402:	4642      	mov	r2, r8
   15404:	4631      	mov	r1, r6
   15406:	4638      	mov	r0, r7
   15408:	47a8      	blx	r5
}
   1540a:	2000      	movs	r0, #0
   1540c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    const void* sigParam = 0;
   15410:	2400      	movs	r4, #0
    TCPIP_TCP_SIGNAL_FUNCTION sigHandler = 0;
   15412:	4625      	mov	r5, r4
    bool freePkt = true;
   15414:	f04f 0a01 	mov.w	sl, #1
    TCPIP_TCP_SIGNAL_TYPE sigType = 0;
   15418:	46a0      	mov	r8, r4
    TCPIP_NET_HANDLE pktIf = 0;
   1541a:	4626      	mov	r6, r4
   1541c:	e7e9      	b.n	153f2 <_Tcpv4TxAckFnc+0xca>
    const void* sigParam = 0;
   1541e:	2400      	movs	r4, #0
    TCPIP_TCP_SIGNAL_FUNCTION sigHandler = 0;
   15420:	4625      	mov	r5, r4
    bool freePkt = true;
   15422:	f04f 0a01 	mov.w	sl, #1
    TCPIP_TCP_SIGNAL_TYPE sigType = 0;
   15426:	46a0      	mov	r8, r4
    TCPIP_NET_HANDLE pktIf = 0;
   15428:	4626      	mov	r6, r4
   1542a:	e7e2      	b.n	153f2 <_Tcpv4TxAckFnc+0xca>
   1542c:	2000edc0 	.word	0x2000edc0
   15430:	2000edc4 	.word	0x2000edc4

Disassembly of section .text.__sflush_r%323:

00015434 <__sflush_r>:
   15434:	898a      	ldrh	r2, [r1, #12]
   15436:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1543a:	4605      	mov	r5, r0
   1543c:	0710      	lsls	r0, r2, #28
   1543e:	460c      	mov	r4, r1
   15440:	d458      	bmi.n	154f4 <__sflush_r+0xc0>
   15442:	684b      	ldr	r3, [r1, #4]
   15444:	2b00      	cmp	r3, #0
   15446:	dc05      	bgt.n	15454 <__sflush_r+0x20>
   15448:	6c0b      	ldr	r3, [r1, #64]	; 0x40
   1544a:	2b00      	cmp	r3, #0
   1544c:	dc02      	bgt.n	15454 <__sflush_r+0x20>
   1544e:	2000      	movs	r0, #0
   15450:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   15454:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   15456:	2e00      	cmp	r6, #0
   15458:	d0f9      	beq.n	1544e <__sflush_r+0x1a>
   1545a:	2300      	movs	r3, #0
   1545c:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
   15460:	682f      	ldr	r7, [r5, #0]
   15462:	602b      	str	r3, [r5, #0]
   15464:	d032      	beq.n	154cc <__sflush_r+0x98>
   15466:	6d60      	ldr	r0, [r4, #84]	; 0x54
   15468:	89a3      	ldrh	r3, [r4, #12]
   1546a:	075a      	lsls	r2, r3, #29
   1546c:	d505      	bpl.n	1547a <__sflush_r+0x46>
   1546e:	6863      	ldr	r3, [r4, #4]
   15470:	1ac0      	subs	r0, r0, r3
   15472:	6b63      	ldr	r3, [r4, #52]	; 0x34
   15474:	b10b      	cbz	r3, 1547a <__sflush_r+0x46>
   15476:	6c23      	ldr	r3, [r4, #64]	; 0x40
   15478:	1ac0      	subs	r0, r0, r3
   1547a:	2300      	movs	r3, #0
   1547c:	4602      	mov	r2, r0
   1547e:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   15480:	6a21      	ldr	r1, [r4, #32]
   15482:	4628      	mov	r0, r5
   15484:	47b0      	blx	r6
   15486:	1c43      	adds	r3, r0, #1
   15488:	89a3      	ldrh	r3, [r4, #12]
   1548a:	d106      	bne.n	1549a <__sflush_r+0x66>
   1548c:	6829      	ldr	r1, [r5, #0]
   1548e:	291d      	cmp	r1, #29
   15490:	d82c      	bhi.n	154ec <__sflush_r+0xb8>
   15492:	4a2a      	ldr	r2, [pc, #168]	; (1553c <__sflush_r+0x108>)
   15494:	40ca      	lsrs	r2, r1
   15496:	07d6      	lsls	r6, r2, #31
   15498:	d528      	bpl.n	154ec <__sflush_r+0xb8>
   1549a:	2200      	movs	r2, #0
   1549c:	6062      	str	r2, [r4, #4]
   1549e:	04d9      	lsls	r1, r3, #19
   154a0:	6922      	ldr	r2, [r4, #16]
   154a2:	6022      	str	r2, [r4, #0]
   154a4:	d504      	bpl.n	154b0 <__sflush_r+0x7c>
   154a6:	1c42      	adds	r2, r0, #1
   154a8:	d101      	bne.n	154ae <__sflush_r+0x7a>
   154aa:	682b      	ldr	r3, [r5, #0]
   154ac:	b903      	cbnz	r3, 154b0 <__sflush_r+0x7c>
   154ae:	6560      	str	r0, [r4, #84]	; 0x54
   154b0:	6b61      	ldr	r1, [r4, #52]	; 0x34
   154b2:	602f      	str	r7, [r5, #0]
   154b4:	2900      	cmp	r1, #0
   154b6:	d0ca      	beq.n	1544e <__sflush_r+0x1a>
   154b8:	f104 0344 	add.w	r3, r4, #68	; 0x44
   154bc:	4299      	cmp	r1, r3
   154be:	d002      	beq.n	154c6 <__sflush_r+0x92>
   154c0:	4628      	mov	r0, r5
   154c2:	f004 fa17 	bl	198f4 <_free_r>
   154c6:	2000      	movs	r0, #0
   154c8:	6360      	str	r0, [r4, #52]	; 0x34
   154ca:	e7c1      	b.n	15450 <__sflush_r+0x1c>
   154cc:	6a21      	ldr	r1, [r4, #32]
   154ce:	2301      	movs	r3, #1
   154d0:	4628      	mov	r0, r5
   154d2:	47b0      	blx	r6
   154d4:	1c41      	adds	r1, r0, #1
   154d6:	d1c7      	bne.n	15468 <__sflush_r+0x34>
   154d8:	682b      	ldr	r3, [r5, #0]
   154da:	2b00      	cmp	r3, #0
   154dc:	d0c4      	beq.n	15468 <__sflush_r+0x34>
   154de:	2b1d      	cmp	r3, #29
   154e0:	d001      	beq.n	154e6 <__sflush_r+0xb2>
   154e2:	2b16      	cmp	r3, #22
   154e4:	d101      	bne.n	154ea <__sflush_r+0xb6>
   154e6:	602f      	str	r7, [r5, #0]
   154e8:	e7b1      	b.n	1544e <__sflush_r+0x1a>
   154ea:	89a3      	ldrh	r3, [r4, #12]
   154ec:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   154f0:	81a3      	strh	r3, [r4, #12]
   154f2:	e7ad      	b.n	15450 <__sflush_r+0x1c>
   154f4:	690f      	ldr	r7, [r1, #16]
   154f6:	2f00      	cmp	r7, #0
   154f8:	d0a9      	beq.n	1544e <__sflush_r+0x1a>
   154fa:	0793      	lsls	r3, r2, #30
   154fc:	680e      	ldr	r6, [r1, #0]
   154fe:	bf08      	it	eq
   15500:	694b      	ldreq	r3, [r1, #20]
   15502:	600f      	str	r7, [r1, #0]
   15504:	bf18      	it	ne
   15506:	2300      	movne	r3, #0
   15508:	eba6 0807 	sub.w	r8, r6, r7
   1550c:	608b      	str	r3, [r1, #8]
   1550e:	f1b8 0f00 	cmp.w	r8, #0
   15512:	dd9c      	ble.n	1544e <__sflush_r+0x1a>
   15514:	4643      	mov	r3, r8
   15516:	463a      	mov	r2, r7
   15518:	6a21      	ldr	r1, [r4, #32]
   1551a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
   1551c:	4628      	mov	r0, r5
   1551e:	47b0      	blx	r6
   15520:	2800      	cmp	r0, #0
   15522:	dc06      	bgt.n	15532 <__sflush_r+0xfe>
   15524:	89a3      	ldrh	r3, [r4, #12]
   15526:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1552a:	81a3      	strh	r3, [r4, #12]
   1552c:	f04f 30ff 	mov.w	r0, #4294967295
   15530:	e78e      	b.n	15450 <__sflush_r+0x1c>
   15532:	4407      	add	r7, r0
   15534:	eba8 0800 	sub.w	r8, r8, r0
   15538:	e7e9      	b.n	1550e <__sflush_r+0xda>
   1553a:	bf00      	nop
   1553c:	20400001 	.word	0x20400001

Disassembly of section .text._TCPIP_HEAP_Free%324:

00015540 <_TCPIP_HEAP_Free>:
// null if invalid
static __inline__ TCPIP_HEAP_DCPT* __attribute__((always_inline)) _TCPIP_HEAP_ObjDcpt(TCPIP_STACK_HEAP_HANDLE heapH)
{
    TCPIP_HEAP_OBJ_INSTANCE* hInst = _TCPIP_HEAP_ObjInstance(heapH);

    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   15540:	2800      	cmp	r0, #0
   15542:	d07e      	beq.n	15642 <_TCPIP_HEAP_Free+0x102>
    return pBuff;

}

static size_t _TCPIP_HEAP_Free(TCPIP_STACK_HEAP_HANDLE heapH, const void* pBuff)
{  
   15544:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15548:	4604      	mov	r4, r0
    int         fail;
    size_t      freedUnits;

    hDcpt = _TCPIP_HEAP_ObjDcpt(heapH);

    if(hDcpt == 0 || pBuff == 0)
   1554a:	2900      	cmp	r1, #0
   1554c:	d07b      	beq.n	15646 <_TCPIP_HEAP_Free+0x106>
   1554e:	460e      	mov	r6, r1
	{
        return 0;
    }

    ptr = (_headNode*)pBuff-1;
   15550:	f1a1 0510 	sub.w	r5, r1, #16

    OSAL_SEM_Pend(&hDcpt->_heapSemaphore, OSAL_WAIT_FOREVER);
   15554:	f100 0844 	add.w	r8, r0, #68	; 0x44
   15558:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1555c:	4640      	mov	r0, r8
   1555e:	f00d fcc9 	bl	22ef4 <OSAL_SEM_Pend>
        OSAL_SEM_Post(&hDcpt->_heapSemaphore);
        return 0;
    }
#endif
    
    freedUnits = ptr->units;
   15562:	f856 7c0c 	ldr.w	r7, [r6, #-12]
    
    fail = 0;
    
    if(!hDcpt->_heapHead)
   15566:	6a63      	ldr	r3, [r4, #36]	; 0x24
   15568:	b18b      	cbz	r3, 1558e <_TCPIP_HEAP_Free+0x4e>
    {
        ptr->next=0;
        hDcpt->_heapHead = hDcpt->_heapTail = ptr;
    }
    else if(ptr < hDcpt->_heapHead)
   1556a:	42ab      	cmp	r3, r5
   1556c:	d922      	bls.n	155b4 <_TCPIP_HEAP_Free+0x74>
    {   // put it in front
        if(ptr+ptr->units == hDcpt->_heapHead)
   1556e:	eb05 1207 	add.w	r2, r5, r7, lsl #4
   15572:	4293      	cmp	r3, r2
   15574:	d010      	beq.n	15598 <_TCPIP_HEAP_Free+0x58>
                hDcpt->_heapTail = ptr;
            }
        }
        else
        {
            ptr->next = hDcpt->_heapHead;
   15576:	f846 3c10 	str.w	r3, [r6, #-16]
        }
        hDcpt->_heapHead = ptr;    // new head
   1557a:	6265      	str	r5, [r4, #36]	; 0x24
        hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_PTR_ERR;   // corrupted pointer!!!
        OSAL_SEM_Post(&hDcpt->_heapSemaphore);
        return 0;
    }
    
    hDcpt->_heapAllocatedUnits -= freedUnits;
   1557c:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1557e:	1bdb      	subs	r3, r3, r7
   15580:	6323      	str	r3, [r4, #48]	; 0x30
    OSAL_SEM_Post(&hDcpt->_heapSemaphore);
   15582:	4640      	mov	r0, r8
   15584:	f00e f902 	bl	2378c <OSAL_SEM_Post>
    return freedUnits * sizeof(_headNode);
   15588:	0138      	lsls	r0, r7, #4
}
   1558a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        ptr->next=0;
   1558e:	f846 3c10 	str.w	r3, [r6, #-16]
        hDcpt->_heapHead = hDcpt->_heapTail = ptr;
   15592:	62a5      	str	r5, [r4, #40]	; 0x28
   15594:	6265      	str	r5, [r4, #36]	; 0x24
    if(fail)
   15596:	e7f1      	b.n	1557c <_TCPIP_HEAP_Free+0x3c>
            ptr->units += hDcpt->_heapHead->units;
   15598:	685b      	ldr	r3, [r3, #4]
   1559a:	443b      	add	r3, r7
   1559c:	f846 3c0c 	str.w	r3, [r6, #-12]
            ptr->next = hDcpt->_heapHead->next;
   155a0:	6a63      	ldr	r3, [r4, #36]	; 0x24
   155a2:	681b      	ldr	r3, [r3, #0]
   155a4:	f846 3c10 	str.w	r3, [r6, #-16]
            if(hDcpt->_heapTail == hDcpt->_heapHead)
   155a8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   155aa:	6a63      	ldr	r3, [r4, #36]	; 0x24
   155ac:	429a      	cmp	r2, r3
   155ae:	d1e4      	bne.n	1557a <_TCPIP_HEAP_Free+0x3a>
                hDcpt->_heapTail = ptr;
   155b0:	62a5      	str	r5, [r4, #40]	; 0x28
   155b2:	e7e2      	b.n	1557a <_TCPIP_HEAP_Free+0x3a>
    else if(ptr > hDcpt->_heapTail)
   155b4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   155b6:	42aa      	cmp	r2, r5
   155b8:	d229      	bcs.n	1560e <_TCPIP_HEAP_Free+0xce>
        if(hDcpt->_heapTail + hDcpt->_heapTail->units == ptr)
   155ba:	6853      	ldr	r3, [r2, #4]
   155bc:	eb02 1103 	add.w	r1, r2, r3, lsl #4
   155c0:	428d      	cmp	r5, r1
   155c2:	d005      	beq.n	155d0 <_TCPIP_HEAP_Free+0x90>
            hDcpt->_heapTail->next = ptr;
   155c4:	6015      	str	r5, [r2, #0]
            ptr->next = 0;
   155c6:	2300      	movs	r3, #0
   155c8:	f846 3c10 	str.w	r3, [r6, #-16]
            hDcpt->_heapTail = ptr;
   155cc:	62a5      	str	r5, [r4, #40]	; 0x28
    if(fail)
   155ce:	e7d5      	b.n	1557c <_TCPIP_HEAP_Free+0x3c>
            hDcpt->_heapTail->units += ptr->units;
   155d0:	443b      	add	r3, r7
   155d2:	6053      	str	r3, [r2, #4]
    if(fail)
   155d4:	e7d2      	b.n	1557c <_TCPIP_HEAP_Free+0x3c>
                    ptr->units += hdr->next->units;
   155d6:	6852      	ldr	r2, [r2, #4]
   155d8:	443a      	add	r2, r7
   155da:	f846 2c0c 	str.w	r2, [r6, #-12]
                    ptr->next = hdr->next->next;
   155de:	681a      	ldr	r2, [r3, #0]
   155e0:	6812      	ldr	r2, [r2, #0]
   155e2:	f846 2c10 	str.w	r2, [r6, #-16]
                    if(hDcpt->_heapTail == hdr->next)
   155e6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
   155e8:	681a      	ldr	r2, [r3, #0]
   155ea:	4291      	cmp	r1, r2
   155ec:	d11a      	bne.n	15624 <_TCPIP_HEAP_Free+0xe4>
                        hDcpt->_heapTail = ptr;
   155ee:	62a5      	str	r5, [r4, #40]	; 0x28
   155f0:	e018      	b.n	15624 <_TCPIP_HEAP_Free+0xe4>
                    hdr->units += ptr->units;
   155f2:	f856 1c0c 	ldr.w	r1, [r6, #-12]
   155f6:	440a      	add	r2, r1
   155f8:	605a      	str	r2, [r3, #4]
                    hdr->next = ptr->next;
   155fa:	f856 2c10 	ldr.w	r2, [r6, #-16]
   155fe:	601a      	str	r2, [r3, #0]
                    if(hDcpt->_heapTail == ptr)
   15600:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   15602:	42aa      	cmp	r2, r5
   15604:	d1ba      	bne.n	1557c <_TCPIP_HEAP_Free+0x3c>
                        hDcpt->_heapTail = hdr;
   15606:	62a3      	str	r3, [r4, #40]	; 0x28
   15608:	e7b8      	b.n	1557c <_TCPIP_HEAP_Free+0x3c>
        for(hdr = hDcpt->_heapHead; hdr != 0; hdr = hdr->next)
   1560a:	681b      	ldr	r3, [r3, #0]
   1560c:	b18b      	cbz	r3, 15632 <_TCPIP_HEAP_Free+0xf2>
            if(hdr<ptr && ptr<hdr->next)
   1560e:	429d      	cmp	r5, r3
   15610:	d9fb      	bls.n	1560a <_TCPIP_HEAP_Free+0xca>
   15612:	681a      	ldr	r2, [r3, #0]
   15614:	42aa      	cmp	r2, r5
   15616:	d9f8      	bls.n	1560a <_TCPIP_HEAP_Free+0xca>
                if(ptr+ptr->units == hdr->next)
   15618:	eb05 1107 	add.w	r1, r5, r7, lsl #4
   1561c:	428a      	cmp	r2, r1
   1561e:	d0da      	beq.n	155d6 <_TCPIP_HEAP_Free+0x96>
                    ptr->next = hdr->next;
   15620:	f846 2c10 	str.w	r2, [r6, #-16]
                if(hdr+hdr->units == ptr)
   15624:	685a      	ldr	r2, [r3, #4]
   15626:	eb03 1102 	add.w	r1, r3, r2, lsl #4
   1562a:	428d      	cmp	r5, r1
   1562c:	d0e1      	beq.n	155f2 <_TCPIP_HEAP_Free+0xb2>
                    hdr->next = ptr;
   1562e:	601d      	str	r5, [r3, #0]
   15630:	e7a4      	b.n	1557c <_TCPIP_HEAP_Free+0x3c>
        hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_PTR_ERR;   // corrupted pointer!!!
   15632:	23f8      	movs	r3, #248	; 0xf8
   15634:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
        OSAL_SEM_Post(&hDcpt->_heapSemaphore);
   15638:	4640      	mov	r0, r8
   1563a:	f00e f8a7 	bl	2378c <OSAL_SEM_Post>
        return 0;
   1563e:	2000      	movs	r0, #0
   15640:	e7a3      	b.n	1558a <_TCPIP_HEAP_Free+0x4a>
        return 0;
   15642:	2000      	movs	r0, #0
}
   15644:	4770      	bx	lr
        return 0;
   15646:	2000      	movs	r0, #0
   15648:	e79f      	b.n	1558a <_TCPIP_HEAP_Free+0x4a>

Disassembly of section .text.TCPIP_TCP_OptionsSet%325:

0001564a <TCPIP_TCP_OptionsSet>:
{
   1564a:	b570      	push	{r4, r5, r6, lr}
   1564c:	4606      	mov	r6, r0
   1564e:	460c      	mov	r4, r1
   15650:	4615      	mov	r5, r2
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   15652:	f00c fc63 	bl	21f1c <_TcpSocketChk>
    if(pSkt)
   15656:	2800      	cmp	r0, #0
   15658:	d070      	beq.n	1573c <TCPIP_TCP_OptionsSet+0xf2>
   1565a:	4603      	mov	r3, r0
        switch(option)
   1565c:	2c0b      	cmp	r4, #11
   1565e:	d86f      	bhi.n	15740 <TCPIP_TCP_OptionsSet+0xf6>
   15660:	e8df f004 	tbb	[pc, r4]
   15664:	3f381b06 	.word	0x3f381b06
   15668:	6e466e6e 	.word	0x6e466e6e
   1566c:	68645951 	.word	0x68645951
                if(optParam)
   15670:	2d00      	cmp	r5, #0
   15672:	d067      	beq.n	15744 <TCPIP_TCP_OptionsSet+0xfa>
                    pSkt->flags.nonLinger = pLData->lingerEnable == 0;
   15674:	782a      	ldrb	r2, [r5, #0]
   15676:	f082 0201 	eor.w	r2, r2, #1
   1567a:	f890 106c 	ldrb.w	r1, [r0, #108]	; 0x6c
   1567e:	f362 1186 	bfi	r1, r2, #6, #1
   15682:	f880 106c 	strb.w	r1, [r0, #108]	; 0x6c
                    pSkt->flags.nonGraceful = pLData->gracefulEnable == 0;
   15686:	786a      	ldrb	r2, [r5, #1]
   15688:	f082 0201 	eor.w	r2, r2, #1
   1568c:	b2c9      	uxtb	r1, r1
   1568e:	f362 11c7 	bfi	r1, r2, #7, #1
   15692:	f880 106c 	strb.w	r1, [r0, #108]	; 0x6c
                    return true;
   15696:	2001      	movs	r0, #1
   15698:	e051      	b.n	1573e <TCPIP_TCP_OptionsSet+0xf4>
                if(optParam)
   1569a:	2d00      	cmp	r5, #0
   1569c:	d054      	beq.n	15748 <TCPIP_TCP_OptionsSet+0xfe>
                    if((pSkt->Flags.keepAlive = pKData->keepAliveEnable))
   1569e:	7828      	ldrb	r0, [r5, #0]
   156a0:	f893 2037 	ldrb.w	r2, [r3, #55]	; 0x37
   156a4:	f360 1286 	bfi	r2, r0, #6, #1
   156a8:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
   156ac:	2800      	cmp	r0, #0
   156ae:	d04d      	beq.n	1574c <TCPIP_TCP_OptionsSet+0x102>
                        pSkt->keepAliveCount = 0;
   156b0:	2200      	movs	r2, #0
   156b2:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
                        pSkt->keepAliveTmo = pKData->keepAliveTmo ? pKData->keepAliveTmo : TCPIP_TCP_KEEP_ALIVE_TIMEOUT;
   156b6:	886a      	ldrh	r2, [r5, #2]
   156b8:	f242 7110 	movw	r1, #10000	; 0x2710
   156bc:	2a00      	cmp	r2, #0
   156be:	bf08      	it	eq
   156c0:	460a      	moveq	r2, r1
   156c2:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
                        pSkt->keepAliveLim = pKData->keepAliveUnackLim ? pKData->keepAliveUnackLim : TCPIP_TCP_MAX_UNACKED_KEEP_ALIVES;
   156c6:	792a      	ldrb	r2, [r5, #4]
   156c8:	2a00      	cmp	r2, #0
   156ca:	bf08      	it	eq
   156cc:	2206      	moveq	r2, #6
   156ce:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
   156d2:	e034      	b.n	1573e <TCPIP_TCP_OptionsSet+0xf4>
                return TCPIP_TCP_FifoSizeAdjust(hTCP, (uint16_t)((unsigned int)optParam), 0, TCP_ADJUST_RX_ONLY | TCP_ADJUST_PRESERVE_RX);
   156d4:	2324      	movs	r3, #36	; 0x24
   156d6:	2200      	movs	r2, #0
   156d8:	b2a9      	uxth	r1, r5
   156da:	4630      	mov	r0, r6
   156dc:	f7f7 fbde 	bl	ce9c <TCPIP_TCP_FifoSizeAdjust>
   156e0:	e02d      	b.n	1573e <TCPIP_TCP_OptionsSet+0xf4>
                return TCPIP_TCP_FifoSizeAdjust(hTCP, 0, (uint16_t)((unsigned int)optParam), TCP_ADJUST_TX_ONLY | TCP_ADJUST_PRESERVE_TX);
   156e2:	2318      	movs	r3, #24
   156e4:	b2aa      	uxth	r2, r5
   156e6:	2100      	movs	r1, #0
   156e8:	4630      	mov	r0, r6
   156ea:	f7f7 fbd7 	bl	ce9c <TCPIP_TCP_FifoSizeAdjust>
   156ee:	e026      	b.n	1573e <TCPIP_TCP_OptionsSet+0xf4>
                pSkt->flags.forceFlush = (int)optParam != 0;
   156f0:	3500      	adds	r5, #0
   156f2:	bf18      	it	ne
   156f4:	2501      	movne	r5, #1
   156f6:	f890 206d 	ldrb.w	r2, [r0, #109]	; 0x6d
   156fa:	f365 02c3 	bfi	r2, r5, #3, #1
   156fe:	f880 206d 	strb.w	r2, [r0, #109]	; 0x6d
                return true;
   15702:	2001      	movs	r0, #1
   15704:	e01b      	b.n	1573e <TCPIP_TCP_OptionsSet+0xf4>
                pSkt->Flags.halfThresType = (TCP_OPTION_THRES_FLUSH_TYPE)(uint32_t)optParam;
   15706:	f890 2037 	ldrb.w	r2, [r0, #55]	; 0x37
   1570a:	f365 1205 	bfi	r2, r5, #4, #2
   1570e:	f880 2037 	strb.w	r2, [r0, #55]	; 0x37
                return true;
   15712:	2001      	movs	r0, #1
   15714:	e013      	b.n	1573e <TCPIP_TCP_OptionsSet+0xf4>
                pSkt->Flags.delayAckSend = (int)optParam != 0;
   15716:	3500      	adds	r5, #0
   15718:	bf18      	it	ne
   1571a:	2501      	movne	r5, #1
   1571c:	f890 2037 	ldrb.w	r2, [r0, #55]	; 0x37
   15720:	f365 12c7 	bfi	r2, r5, #7, #1
   15724:	f880 2037 	strb.w	r2, [r0, #55]	; 0x37
                return true;
   15728:	2001      	movs	r0, #1
   1572a:	e008      	b.n	1573e <TCPIP_TCP_OptionsSet+0xf4>
                pSkt->ttl = (uint8_t)(unsigned int)optParam;
   1572c:	f880 507e 	strb.w	r5, [r0, #126]	; 0x7e
                return true;
   15730:	2001      	movs	r0, #1
   15732:	e004      	b.n	1573e <TCPIP_TCP_OptionsSet+0xf4>
                pSkt->tos = (uint8_t)(unsigned int)optParam;
   15734:	f880 507f 	strb.w	r5, [r0, #127]	; 0x7f
                return true;
   15738:	2001      	movs	r0, #1
   1573a:	e000      	b.n	1573e <TCPIP_TCP_OptionsSet+0xf4>
    return false;
   1573c:	2000      	movs	r0, #0
}
   1573e:	bd70      	pop	{r4, r5, r6, pc}
                return false;   // not supported option
   15740:	2000      	movs	r0, #0
   15742:	e7fc      	b.n	1573e <TCPIP_TCP_OptionsSet+0xf4>
                return false;
   15744:	2000      	movs	r0, #0
   15746:	e7fa      	b.n	1573e <TCPIP_TCP_OptionsSet+0xf4>
                return false;
   15748:	2000      	movs	r0, #0
   1574a:	e7f8      	b.n	1573e <TCPIP_TCP_OptionsSet+0xf4>
                    return true;
   1574c:	2001      	movs	r0, #1
   1574e:	e7f6      	b.n	1573e <TCPIP_TCP_OptionsSet+0xf4>

Disassembly of section .text.TCPIP_UDP_Initialize%326:

00015750 <TCPIP_UDP_Initialize>:
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_UP)
   15750:	7f03      	ldrb	r3, [r0, #28]
   15752:	2b03      	cmp	r3, #3
   15754:	d065      	beq.n	15822 <TCPIP_UDP_Initialize+0xd2>
    if(udpInitCount != 0)
   15756:	4b35      	ldr	r3, [pc, #212]	; (1582c <TCPIP_UDP_Initialize+0xdc>)
   15758:	681b      	ldr	r3, [r3, #0]
   1575a:	b983      	cbnz	r3, 1577e <TCPIP_UDP_Initialize+0x2e>
{
   1575c:	b570      	push	{r4, r5, r6, lr}
   1575e:	460d      	mov	r5, r1
   15760:	4604      	mov	r4, r0
    if(stackCtrl->memH == 0)
   15762:	68c3      	ldr	r3, [r0, #12]
   15764:	b183      	cbz	r3, 15788 <TCPIP_UDP_Initialize+0x38>
    if(pUdpInit == 0)
   15766:	2900      	cmp	r1, #0
   15768:	d05d      	beq.n	15826 <TCPIP_UDP_Initialize+0xd6>
    return OSAL_SEM_Create(&userSem, OSAL_SEM_TYPE_BINARY, 1, 1);
   1576a:	2301      	movs	r3, #1
   1576c:	461a      	mov	r2, r3
   1576e:	2100      	movs	r1, #0
   15770:	482f      	ldr	r0, [pc, #188]	; (15830 <TCPIP_UDP_Initialize+0xe0>)
   15772:	f008 f9a5 	bl	1dac0 <OSAL_SEM_Create>
    if(_UserGblLockCreate() != OSAL_RESULT_TRUE)
   15776:	2801      	cmp	r0, #1
   15778:	d012      	beq.n	157a0 <TCPIP_UDP_Initialize+0x50>
        return false;
   1577a:	2000      	movs	r0, #0
}
   1577c:	bd70      	pop	{r4, r5, r6, pc}
        udpInitCount++;
   1577e:	3301      	adds	r3, #1
   15780:	4a2a      	ldr	r2, [pc, #168]	; (1582c <TCPIP_UDP_Initialize+0xdc>)
   15782:	6013      	str	r3, [r2, #0]
        return true;
   15784:	2001      	movs	r0, #1
   15786:	4770      	bx	lr
        SYS_ERROR(SYS_ERROR_ERROR, "UDP NULL dynamic allocation handle");
   15788:	f00e fd7a 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
   1578c:	b908      	cbnz	r0, 15792 <TCPIP_UDP_Initialize+0x42>
        return false;
   1578e:	2000      	movs	r0, #0
   15790:	e7f4      	b.n	1577c <TCPIP_UDP_Initialize+0x2c>
        SYS_ERROR(SYS_ERROR_ERROR, "UDP NULL dynamic allocation handle");
   15792:	f00e fd6f 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
   15796:	4927      	ldr	r1, [pc, #156]	; (15834 <TCPIP_UDP_Initialize+0xe4>)
   15798:	f006 ff80 	bl	1c69c <SYS_CONSOLE_Print>
        return false;
   1579c:	2000      	movs	r0, #0
   1579e:	e7ed      	b.n	1577c <TCPIP_UDP_Initialize+0x2c>
    signalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_UDP_Task, 0);
   157a0:	2200      	movs	r2, #0
   157a2:	4925      	ldr	r1, [pc, #148]	; (15838 <TCPIP_UDP_Initialize+0xe8>)
   157a4:	2009      	movs	r0, #9
   157a6:	f009 fafb 	bl	1eda0 <_TCPIPStackSignalHandlerRegister>
   157aa:	4b24      	ldr	r3, [pc, #144]	; (1583c <TCPIP_UDP_Initialize+0xec>)
   157ac:	6018      	str	r0, [r3, #0]
    if(signalHandle == 0)
   157ae:	b308      	cbz	r0, 157f4 <TCPIP_UDP_Initialize+0xa4>
    newSktDcpt = (UDP_SOCKET_DCPT**)TCPIP_HEAP_Calloc(stackCtrl->memH, pUdpInit->nSockets, sizeof(UDP_SOCKET_DCPT*));
   157b0:	68e0      	ldr	r0, [r4, #12]
   157b2:	6883      	ldr	r3, [r0, #8]
   157b4:	2204      	movs	r2, #4
   157b6:	8829      	ldrh	r1, [r5, #0]
   157b8:	4798      	blx	r3
    if(newSktDcpt == 0)
   157ba:	4606      	mov	r6, r0
   157bc:	b1f8      	cbz	r0, 157fe <TCPIP_UDP_Initialize+0xae>
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   157be:	2000      	movs	r0, #0
   157c0:	f00d ffd8 	bl	23774 <OSAL_CRIT_Enter>
    udpMemH = stackCtrl->memH;
   157c4:	68e2      	ldr	r2, [r4, #12]
   157c6:	4b1e      	ldr	r3, [pc, #120]	; (15840 <TCPIP_UDP_Initialize+0xf0>)
   157c8:	601a      	str	r2, [r3, #0]
    nUdpSockets = pUdpInit->nSockets;
   157ca:	882a      	ldrh	r2, [r5, #0]
   157cc:	4b1d      	ldr	r3, [pc, #116]	; (15844 <TCPIP_UDP_Initialize+0xf4>)
   157ce:	601a      	str	r2, [r3, #0]
    udpDefTxSize = pUdpInit->sktTxBuffSize;
   157d0:	886a      	ldrh	r2, [r5, #2]
   157d2:	4b1d      	ldr	r3, [pc, #116]	; (15848 <TCPIP_UDP_Initialize+0xf8>)
   157d4:	801a      	strh	r2, [r3, #0]
    UDPSocketDcpt = newSktDcpt;
   157d6:	4b1d      	ldr	r3, [pc, #116]	; (1584c <TCPIP_UDP_Initialize+0xfc>)
   157d8:	601e      	str	r6, [r3, #0]
    udpInitCount++;
   157da:	4a14      	ldr	r2, [pc, #80]	; (1582c <TCPIP_UDP_Initialize+0xdc>)
   157dc:	6813      	ldr	r3, [r2, #0]
   157de:	3301      	adds	r3, #1
   157e0:	6013      	str	r3, [r2, #0]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   157e2:	4601      	mov	r1, r0
   157e4:	2000      	movs	r0, #0
   157e6:	f00e f8ff 	bl	239e8 <OSAL_CRIT_Leave>
    OSAL_SEM_Post(&userSem);
   157ea:	4811      	ldr	r0, [pc, #68]	; (15830 <TCPIP_UDP_Initialize+0xe0>)
   157ec:	f00d ffce 	bl	2378c <OSAL_SEM_Post>
    return true;
   157f0:	2001      	movs	r0, #1
   157f2:	e7c3      	b.n	1577c <TCPIP_UDP_Initialize+0x2c>
    OSAL_SEM_Delete(&userSem);
   157f4:	480e      	ldr	r0, [pc, #56]	; (15830 <TCPIP_UDP_Initialize+0xe0>)
   157f6:	f00e fa42 	bl	23c7e <OSAL_SEM_Delete>
        return false;
   157fa:	2000      	movs	r0, #0
   157fc:	e7be      	b.n	1577c <TCPIP_UDP_Initialize+0x2c>
        SYS_ERROR(SYS_ERROR_ERROR, "UDP Dynamic allocation failed");
   157fe:	f00e fd3f 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
   15802:	b940      	cbnz	r0, 15816 <TCPIP_UDP_Initialize+0xc6>
    OSAL_SEM_Delete(&userSem);
   15804:	480a      	ldr	r0, [pc, #40]	; (15830 <TCPIP_UDP_Initialize+0xe0>)
   15806:	f00e fa3a 	bl	23c7e <OSAL_SEM_Delete>
        _TCPIPStackSignalHandlerDeregister(signalHandle);
   1580a:	4b0c      	ldr	r3, [pc, #48]	; (1583c <TCPIP_UDP_Initialize+0xec>)
   1580c:	6818      	ldr	r0, [r3, #0]
   1580e:	f00e fb9a 	bl	23f46 <_TCPIPStackSignalHandlerDeregister>
        return false;
   15812:	2000      	movs	r0, #0
   15814:	e7b2      	b.n	1577c <TCPIP_UDP_Initialize+0x2c>
        SYS_ERROR(SYS_ERROR_ERROR, "UDP Dynamic allocation failed");
   15816:	f00e fd2d 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
   1581a:	490d      	ldr	r1, [pc, #52]	; (15850 <TCPIP_UDP_Initialize+0x100>)
   1581c:	f006 ff3e 	bl	1c69c <SYS_CONSOLE_Print>
   15820:	e7f0      	b.n	15804 <TCPIP_UDP_Initialize+0xb4>
        return true;    // do not store per interface data
   15822:	2001      	movs	r0, #1
}
   15824:	4770      	bx	lr
        return false;
   15826:	2000      	movs	r0, #0
   15828:	e7a8      	b.n	1577c <TCPIP_UDP_Initialize+0x2c>
   1582a:	bf00      	nop
   1582c:	2000ee94 	.word	0x2000ee94
   15830:	2000ee9c 	.word	0x2000ee9c
   15834:	0001f4c0 	.word	0x0001f4c0
   15838:	0000ee55 	.word	0x0000ee55
   1583c:	2000ee90 	.word	0x2000ee90
   15840:	2000ee98 	.word	0x2000ee98
   15844:	2000ee8c 	.word	0x2000ee8c
   15848:	2000ef82 	.word	0x2000ef82
   1584c:	2000ee88 	.word	0x2000ee88
   15850:	0001f4e4 	.word	0x0001f4e4

Disassembly of section .rodata._ctype_%327:

00015854 <_ctype_>:
   15854:	20202000 20202020 28282020 20282828     .         ((((( 
   15864:	20202020 20202020 20202020 20202020                     
   15874:	10108820 10101010 10101010 10101010      ...............
   15884:	04040410 04040404 10040404 10101010     ................
   15894:	41411010 41414141 01010101 01010101     ..AAAAAA........
   158a4:	01010101 01010101 01010101 10101010     ................
   158b4:	42421010 42424242 02020202 02020202     ..BBBBBB........
   158c4:	02020202 02020202 02020202 10101010     ................
   158d4:	00000020 00000000 00000000 00000000      ...............
	...

Disassembly of section .rodata.K%328:

00015958 <K>:
   15958:	428a2f98 71374491 b5c0fbcf e9b5dba5     ./.B.D7q........
   15968:	3956c25b 59f111f1 923f82a4 ab1c5ed5     [.V9...Y..?..^..
   15978:	d807aa98 12835b01 243185be 550c7dc3     .....[....1$.}.U
   15988:	72be5d74 80deb1fe 9bdc06a7 c19bf174     t].r........t...
   15998:	e49b69c1 efbe4786 0fc19dc6 240ca1cc     .i...G.........$
   159a8:	2de92c6f 4a7484aa 5cb0a9dc 76f988da     o,.-..tJ...\...v
   159b8:	983e5152 a831c66d b00327c8 bf597fc7     RQ>.m.1..'....Y.
   159c8:	c6e00bf3 d5a79147 06ca6351 14292967     ....G...Qc..g)).
   159d8:	27b70a85 2e1b2138 4d2c6dfc 53380d13     ...'8!...m,M..8S
   159e8:	650a7354 766a0abb 81c2c92e 92722c85     Ts.e..jv.....,r.
   159f8:	a2bfe8a1 a81a664b c24b8b70 c76c51a3     ....Kf..p.K..Ql.
   15a08:	d192e819 d6990624 f40e3585 106aa070     ....$....5..p.j.
   15a18:	19a4c116 1e376c08 2748774c 34b0bcb5     .....l7.LwH'...4
   15a28:	391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3     ...9J..NO..[.o.h
   15a38:	748f82ee 78a5636f 84c87814 8cc70208     ...toc.x.x......
   15a48:	90befffa a4506ceb bef9a3f7 c67178f2     .....lP......xq.

Disassembly of section .text.wc_Md5Update%329:

00015a58 <wc_Md5Update>:
    return ret;
}

/* do block size increments/updates */
int wc_Md5Update(wc_Md5* md5, const byte* data, word32 len)
{
   15a58:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    int ret = 0;
    word32 blocksLen;
    byte* local;

    if (md5 == NULL || (data == NULL && len > 0)) {
   15a5c:	2800      	cmp	r0, #0
   15a5e:	d071      	beq.n	15b44 <wc_Md5Update+0xec>
   15a60:	460c      	mov	r4, r1
   15a62:	4690      	mov	r8, r2
   15a64:	4606      	mov	r6, r0
   15a66:	2900      	cmp	r1, #0
   15a68:	d03b      	beq.n	15ae2 <wc_Md5Update+0x8a>
#endif
    }
#endif /* WOLFSSL_ASYNC_CRYPT */

    /* check that internal buffLen is valid */
    if (md5->buffLen >= WC_MD5_BLOCK_SIZE)
   15a6a:	6800      	ldr	r0, [r0, #0]
   15a6c:	283f      	cmp	r0, #63	; 0x3f
   15a6e:	d86f      	bhi.n	15b50 <wc_Md5Update+0xf8>
    word32 tmp = md5->loLen;
   15a70:	6872      	ldr	r2, [r6, #4]
    if ((md5->loLen += len) < tmp) {
   15a72:	eb08 0302 	add.w	r3, r8, r2
   15a76:	6073      	str	r3, [r6, #4]
   15a78:	429a      	cmp	r2, r3
   15a7a:	d902      	bls.n	15a82 <wc_Md5Update+0x2a>
        md5->hiLen++;                       /* carry low to high */
   15a7c:	68b3      	ldr	r3, [r6, #8]
   15a7e:	3301      	adds	r3, #1
   15a80:	60b3      	str	r3, [r6, #8]
    }

    /* add length for final */
    AddLength(md5, len);

    local = (byte*)md5->buffer;
   15a82:	f106 050c 	add.w	r5, r6, #12

    /* process any remainder from previous operation */
    if (md5->buffLen > 0) {
   15a86:	bba8      	cbnz	r0, 15af4 <wc_Md5Update+0x9c>
        XTRANSFORM_LEN(md5, data, blocksLen);
        data += blocksLen;
        len  -= blocksLen;
    }
#else
    while (len >= WC_MD5_BLOCK_SIZE) {
   15a88:	f1b8 0f3f 	cmp.w	r8, #63	; 0x3f
   15a8c:	d94e      	bls.n	15b2c <wc_Md5Update+0xd4>
   15a8e:	f1a8 0740 	sub.w	r7, r8, #64	; 0x40
   15a92:	f027 073f 	bic.w	r7, r7, #63	; 0x3f
   15a96:	3740      	adds	r7, #64	; 0x40
   15a98:	4427      	add	r7, r4
            local32 = (word32*)data;
        }
        else
    #endif
        {
            XMEMCPY(local32, data, WC_MD5_BLOCK_SIZE);
   15a9a:	4623      	mov	r3, r4
   15a9c:	462a      	mov	r2, r5
   15a9e:	f104 0940 	add.w	r9, r4, #64	; 0x40
   15aa2:	f8d3 e000 	ldr.w	lr, [r3]
   15aa6:	f8d3 c004 	ldr.w	ip, [r3, #4]
   15aaa:	6898      	ldr	r0, [r3, #8]
   15aac:	68d9      	ldr	r1, [r3, #12]
   15aae:	f8c2 e000 	str.w	lr, [r2]
   15ab2:	f8c2 c004 	str.w	ip, [r2, #4]
   15ab6:	6090      	str	r0, [r2, #8]
   15ab8:	60d1      	str	r1, [r2, #12]
   15aba:	3310      	adds	r3, #16
   15abc:	3210      	adds	r2, #16
   15abe:	454b      	cmp	r3, r9
   15ac0:	d1ef      	bne.n	15aa2 <wc_Md5Update+0x4a>
        }

        data += WC_MD5_BLOCK_SIZE;
   15ac2:	3440      	adds	r4, #64	; 0x40

    #if defined(BIG_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
        ByteReverseWords(local32, local32, WC_MD5_BLOCK_SIZE);
    #endif

        ret = XTRANSFORM(md5, (const byte*)local32);
   15ac4:	4629      	mov	r1, r5
   15ac6:	4630      	mov	r0, r6
   15ac8:	f7f1 f8d8 	bl	6c7c <Transform>
   15acc:	4681      	mov	r9, r0
    while (len >= WC_MD5_BLOCK_SIZE) {
   15ace:	42bc      	cmp	r4, r7
   15ad0:	d1e3      	bne.n	15a9a <wc_Md5Update+0x42>
   15ad2:	f008 083f 	and.w	r8, r8, #63	; 0x3f
    }
#endif /* XTRANSFORM_LEN */

    /* save remainder */
    if (len > 0) {
   15ad6:	f1b8 0f00 	cmp.w	r8, #0
   15ada:	d12b      	bne.n	15b34 <wc_Md5Update+0xdc>
        XMEMCPY(local, data, len);
        md5->buffLen = len;
    }

    return ret;
}
   15adc:	4648      	mov	r0, r9
   15ade:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (md5 == NULL || (data == NULL && len > 0)) {
   15ae2:	bb92      	cbnz	r2, 15b4a <wc_Md5Update+0xf2>
    if (md5->buffLen >= WC_MD5_BLOCK_SIZE)
   15ae4:	6803      	ldr	r3, [r0, #0]
        return BUFFER_E;
   15ae6:	2b40      	cmp	r3, #64	; 0x40
   15ae8:	bf34      	ite	cc
   15aea:	f04f 0900 	movcc.w	r9, #0
   15aee:	f06f 0983 	mvncs.w	r9, #131	; 0x83
   15af2:	e7f3      	b.n	15adc <wc_Md5Update+0x84>
        blocksLen = min(len, WC_MD5_BLOCK_SIZE - md5->buffLen);
   15af4:	f1c0 0740 	rsb	r7, r0, #64	; 0x40
        return a > b ? b : a;
   15af8:	4547      	cmp	r7, r8
   15afa:	bf28      	it	cs
   15afc:	4647      	movcs	r7, r8
        XMEMCPY(&local[md5->buffLen], data, blocksLen);
   15afe:	463a      	mov	r2, r7
   15b00:	4621      	mov	r1, r4
   15b02:	4428      	add	r0, r5
   15b04:	f00d fbf2 	bl	232ec <memcpy>
        md5->buffLen += blocksLen;
   15b08:	6833      	ldr	r3, [r6, #0]
   15b0a:	443b      	add	r3, r7
   15b0c:	6033      	str	r3, [r6, #0]
        data         += blocksLen;
   15b0e:	443c      	add	r4, r7
        len          -= blocksLen;
   15b10:	eba8 0807 	sub.w	r8, r8, r7
        if (md5->buffLen == WC_MD5_BLOCK_SIZE) {
   15b14:	2b40      	cmp	r3, #64	; 0x40
   15b16:	d1b7      	bne.n	15a88 <wc_Md5Update+0x30>
            ret = XTRANSFORM(md5, (const byte*)local);
   15b18:	4629      	mov	r1, r5
   15b1a:	4630      	mov	r0, r6
   15b1c:	f7f1 f8ae 	bl	6c7c <Transform>
            if (ret != 0)
   15b20:	4681      	mov	r9, r0
   15b22:	2800      	cmp	r0, #0
   15b24:	d1da      	bne.n	15adc <wc_Md5Update+0x84>
            md5->buffLen = 0;
   15b26:	2300      	movs	r3, #0
   15b28:	6033      	str	r3, [r6, #0]
   15b2a:	e7ad      	b.n	15a88 <wc_Md5Update+0x30>
    while (len >= WC_MD5_BLOCK_SIZE) {
   15b2c:	4627      	mov	r7, r4
   15b2e:	f04f 0900 	mov.w	r9, #0
   15b32:	e7d0      	b.n	15ad6 <wc_Md5Update+0x7e>
        XMEMCPY(local, data, len);
   15b34:	4642      	mov	r2, r8
   15b36:	4639      	mov	r1, r7
   15b38:	4628      	mov	r0, r5
   15b3a:	f00d fbd7 	bl	232ec <memcpy>
        md5->buffLen = len;
   15b3e:	f8c6 8000 	str.w	r8, [r6]
   15b42:	e7cb      	b.n	15adc <wc_Md5Update+0x84>
        return BAD_FUNC_ARG;
   15b44:	f06f 09ac 	mvn.w	r9, #172	; 0xac
   15b48:	e7c8      	b.n	15adc <wc_Md5Update+0x84>
   15b4a:	f06f 09ac 	mvn.w	r9, #172	; 0xac
   15b4e:	e7c5      	b.n	15adc <wc_Md5Update+0x84>
        return BUFFER_E;
   15b50:	f06f 0983 	mvn.w	r9, #131	; 0x83
   15b54:	e7c2      	b.n	15adc <wc_Md5Update+0x84>

Disassembly of section .text.TCPIP_ICMP_EchoRequest%330:

00015b58 <TCPIP_ICMP_EchoRequest>:
{
   15b58:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    if(pHandle)
   15b5c:	4688      	mov	r8, r1
   15b5e:	b109      	cbz	r1, 15b64 <TCPIP_ICMP_EchoRequest+0xc>
        *pHandle = 0;
   15b60:	2300      	movs	r3, #0
   15b62:	600b      	str	r3, [r1, #0]
    if(pIcmpEchoRequest != 0)
   15b64:	4b38      	ldr	r3, [pc, #224]	; (15c48 <TCPIP_ICMP_EchoRequest+0xf0>)
   15b66:	681b      	ldr	r3, [r3, #0]
   15b68:	2b00      	cmp	r3, #0
   15b6a:	d15a      	bne.n	15c22 <TCPIP_ICMP_EchoRequest+0xca>
    if(pEchoRequest == 0)
   15b6c:	2800      	cmp	r0, #0
   15b6e:	d05b      	beq.n	15c28 <TCPIP_ICMP_EchoRequest+0xd0>
   15b70:	4604      	mov	r4, r0
        pktSize = sizeof(ICMP_PACKET) + pEchoRequest->dataSize;
   15b72:	8a05      	ldrh	r5, [r0, #16]
   15b74:	3508      	adds	r5, #8
   15b76:	b2ad      	uxth	r5, r5
        pTxPkt = _ICMPAllocateTxPacketStruct(pktSize);
   15b78:	4628      	mov	r0, r5
   15b7a:	f00c fce3 	bl	22544 <_ICMPAllocateTxPacketStruct>
        if(pTxPkt == 0)
   15b7e:	4607      	mov	r7, r0
   15b80:	2800      	cmp	r0, #0
   15b82:	d054      	beq.n	15c2e <TCPIP_ICMP_EchoRequest+0xd6>
        pICMPPkt = (ICMP_PACKET*)pTxPkt->macPkt.pTransportLayer;
   15b84:	69c6      	ldr	r6, [r0, #28]
        pICMPPkt->vType = ICMP_TYPE_ECHO_REQUEST; 
   15b86:	2308      	movs	r3, #8
   15b88:	7033      	strb	r3, [r6, #0]
        pICMPPkt->vCode = ICMP_CODE_ECHO_REQUEST;
   15b8a:	f04f 0900 	mov.w	r9, #0
   15b8e:	f886 9001 	strb.w	r9, [r6, #1]
        pICMPPkt->wChecksum = 0x0000;
   15b92:	f8a6 9002 	strh.w	r9, [r6, #2]
        pICMPPkt->wIdentifier = pEchoRequest->identifier;
   15b96:	8963      	ldrh	r3, [r4, #10]
   15b98:	80b3      	strh	r3, [r6, #4]
        pICMPPkt->wSequenceNumber = pEchoRequest->sequenceNumber;
   15b9a:	8923      	ldrh	r3, [r4, #8]
   15b9c:	80f3      	strh	r3, [r6, #6]
        memcpy(pICMPPkt->wData, pEchoRequest->pData, pEchoRequest->dataSize);
   15b9e:	8a22      	ldrh	r2, [r4, #16]
   15ba0:	68e1      	ldr	r1, [r4, #12]
   15ba2:	f106 0008 	add.w	r0, r6, #8
   15ba6:	f00d fba1 	bl	232ec <memcpy>
        pICMPPkt->wChecksum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pICMPPkt, pktSize, 0);
   15baa:	464a      	mov	r2, r9
   15bac:	4629      	mov	r1, r5
   15bae:	4630      	mov	r0, r6
   15bb0:	f006 fb52 	bl	1c258 <TCPIP_Helper_CalcIPChecksum>
   15bb4:	8070      	strh	r0, [r6, #2]
        pTxPkt->destAddress.Val = pEchoRequest->targetAddr.Val;
   15bb6:	6863      	ldr	r3, [r4, #4]
   15bb8:	63bb      	str	r3, [r7, #56]	; 0x38
        pTxPkt->netIfH = TCPIP_IPV4_SelectSourceInterface(pEchoRequest->netH, &pTxPkt->destAddress, &pTxPkt->srcAddress, false);
   15bba:	464b      	mov	r3, r9
   15bbc:	f107 0234 	add.w	r2, r7, #52	; 0x34
   15bc0:	f107 0138 	add.w	r1, r7, #56	; 0x38
   15bc4:	6820      	ldr	r0, [r4, #0]
   15bc6:	f008 ff13 	bl	1e9f0 <TCPIP_IPV4_SelectSourceInterface>
   15bca:	63f8      	str	r0, [r7, #60]	; 0x3c
        if(pTxPkt->netIfH == 0)
   15bcc:	2800      	cmp	r0, #0
   15bce:	d033      	beq.n	15c38 <TCPIP_ICMP_EchoRequest+0xe0>
        icmpEchoRequest = *pEchoRequest;
   15bd0:	4e1e      	ldr	r6, [pc, #120]	; (15c4c <TCPIP_ICMP_EchoRequest+0xf4>)
   15bd2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   15bd4:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   15bd6:	e894 0003 	ldmia.w	r4, {r0, r1}
   15bda:	e886 0003 	stmia.w	r6, {r0, r1}
        pTxPkt->macPkt.pDSeg->segLen += pktSize;
   15bde:	693a      	ldr	r2, [r7, #16]
   15be0:	8993      	ldrh	r3, [r2, #12]
   15be2:	442b      	add	r3, r5
   15be4:	8193      	strh	r3, [r2, #12]
        TCPIP_IPV4_PacketFormatTx(pTxPkt, IP_PROT_ICMP, pktSize, 0);
   15be6:	464b      	mov	r3, r9
   15be8:	462a      	mov	r2, r5
   15bea:	2101      	movs	r1, #1
   15bec:	4638      	mov	r0, r7
   15bee:	f7fe feaf 	bl	14950 <TCPIP_IPV4_PacketFormatTx>
        if(!TCPIP_IPV4_PacketTransmit(pTxPkt))
   15bf2:	4638      	mov	r0, r7
   15bf4:	f00e fafc 	bl	241f0 <TCPIP_IPV4_PacketTransmit>
   15bf8:	b910      	cbnz	r0, 15c00 <TCPIP_ICMP_EchoRequest+0xa8>
            res = ICMP_ECHO_TRANSMIT_ERROR;
   15bfa:	f06f 0402 	mvn.w	r4, #2
   15bfe:	e01d      	b.n	15c3c <TCPIP_ICMP_EchoRequest+0xe4>
        pIcmpEchoRequest = &icmpEchoRequest; // mark as busy
   15c00:	4b11      	ldr	r3, [pc, #68]	; (15c48 <TCPIP_ICMP_EchoRequest+0xf0>)
   15c02:	f1a6 0210 	sub.w	r2, r6, #16
   15c06:	601a      	str	r2, [r3, #0]
        icmpEchoStart = SYS_TMR_TickCountGet();
   15c08:	f00c fb18 	bl	2223c <SYS_TMR_TickCountGet>
   15c0c:	4b10      	ldr	r3, [pc, #64]	; (15c50 <TCPIP_ICMP_EchoRequest+0xf8>)
   15c0e:	6018      	str	r0, [r3, #0]
        if(pHandle)
   15c10:	f1b8 0f00 	cmp.w	r8, #0
   15c14:	d00e      	beq.n	15c34 <TCPIP_ICMP_EchoRequest+0xdc>
            *pHandle = pIcmpEchoRequest;
   15c16:	4b0c      	ldr	r3, [pc, #48]	; (15c48 <TCPIP_ICMP_EchoRequest+0xf0>)
   15c18:	681b      	ldr	r3, [r3, #0]
   15c1a:	f8c8 3000 	str.w	r3, [r8]
        res = ICMP_ECHO_OK;
   15c1e:	464c      	mov	r4, r9
   15c20:	e00f      	b.n	15c42 <TCPIP_ICMP_EchoRequest+0xea>
        return ICMP_ECHO_BUSY;
   15c22:	f06f 0404 	mvn.w	r4, #4
   15c26:	e00c      	b.n	15c42 <TCPIP_ICMP_EchoRequest+0xea>
        return ICMP_ECHO_PARAMETER_ERROR;
   15c28:	f06f 0403 	mvn.w	r4, #3
   15c2c:	e009      	b.n	15c42 <TCPIP_ICMP_EchoRequest+0xea>
            res = ICMP_ECHO_ALLOC_ERROR;
   15c2e:	f04f 34ff 	mov.w	r4, #4294967295
   15c32:	e006      	b.n	15c42 <TCPIP_ICMP_EchoRequest+0xea>
        res = ICMP_ECHO_OK;
   15c34:	2400      	movs	r4, #0
   15c36:	e004      	b.n	15c42 <TCPIP_ICMP_EchoRequest+0xea>
            res = ICMP_ECHO_ROUTE_ERROR;
   15c38:	f06f 0401 	mvn.w	r4, #1
        TCPIP_PKT_PacketFree(&pTxPkt->macPkt);
   15c3c:	4638      	mov	r0, r7
   15c3e:	f00a fa97 	bl	20170 <_TCPIP_PKT_PacketFree>
}
   15c42:	4620      	mov	r0, r4
   15c44:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   15c48:	2000edb8 	.word	0x2000edb8
   15c4c:	2000ebe0 	.word	0x2000ebe0
   15c50:	2000eda8 	.word	0x2000eda8

Disassembly of section .text._Command_HeapInfo%331:

00015c54 <_Command_HeapInfo>:
{
   15c54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15c58:	b085      	sub	sp, #20
   15c5a:	4605      	mov	r5, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   15c5c:	6843      	ldr	r3, [r0, #4]
   15c5e:	9301      	str	r3, [sp, #4]
    if (argc > 1)
   15c60:	2901      	cmp	r1, #1
   15c62:	dc51      	bgt.n	15d08 <_Command_HeapInfo+0xb4>
    bool hasArgs = false;
   15c64:	2300      	movs	r3, #0
   15c66:	9303      	str	r3, [sp, #12]
        endType = TCPIP_STACK_HEAP_TYPES;
   15c68:	2704      	movs	r7, #4
        startType = TCPIP_STACK_HEAP_TYPE_NONE + 1;
   15c6a:	2601      	movs	r6, #1
    for(hType = startType; hType < endType; hType++)
   15c6c:	4b35      	ldr	r3, [pc, #212]	; (15d44 <_Command_HeapInfo+0xf0>)
   15c6e:	eb03 0986 	add.w	r9, r3, r6, lsl #2
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Heap type: %s. Initial created heap size: %d Bytes\r\n", typeMsg, heapSize);
   15c72:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 15d4c <_Command_HeapInfo+0xf8>
   15c76:	f608 13c4 	addw	r3, r8, #2500	; 0x9c4
   15c7a:	9302      	str	r3, [sp, #8]
   15c7c:	46ba      	mov	sl, r7
        typeMsg = heapTypeStr[hType];
   15c7e:	f859 7b04 	ldr.w	r7, [r9], #4
        heapH = TCPIP_STACK_HeapHandleGet(hType, 0);
   15c82:	2100      	movs	r1, #0
   15c84:	b2f0      	uxtb	r0, r6
   15c86:	f00d ff41 	bl	23b0c <TCPIP_STACK_HeapHandleGet>
        if(heapH == 0)
   15c8a:	4604      	mov	r4, r0
   15c8c:	2800      	cmp	r0, #0
   15c8e:	d04e      	beq.n	15d2e <_Command_HeapInfo+0xda>
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Size)(h);
   15c90:	6903      	ldr	r3, [r0, #16]
   15c92:	4798      	blx	r3
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Heap type: %s. Initial created heap size: %d Bytes\r\n", typeMsg, heapSize);
   15c94:	682b      	ldr	r3, [r5, #0]
   15c96:	f8d3 b004 	ldr.w	fp, [r3, #4]
   15c9a:	4603      	mov	r3, r0
   15c9c:	463a      	mov	r2, r7
   15c9e:	9902      	ldr	r1, [sp, #8]
   15ca0:	9801      	ldr	r0, [sp, #4]
   15ca2:	47d8      	blx	fp
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Allocable block heap size: %d Bytes\r\n", TCPIP_HEAP_MaxSize(heapH));
   15ca4:	682b      	ldr	r3, [r5, #0]
   15ca6:	685f      	ldr	r7, [r3, #4]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_MaxSize)(h);
   15ca8:	6963      	ldr	r3, [r4, #20]
   15caa:	4620      	mov	r0, r4
   15cac:	4798      	blx	r3
   15cae:	4602      	mov	r2, r0
   15cb0:	f608 11fc 	addw	r1, r8, #2556	; 0x9fc
   15cb4:	9801      	ldr	r0, [sp, #4]
   15cb6:	47b8      	blx	r7
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "All available heap size: %d Bytes, high watermark: %d\r\n", TCPIP_HEAP_FreeSize(heapH), TCPIP_HEAP_HighWatermark(heapH));
   15cb8:	682b      	ldr	r3, [r5, #0]
   15cba:	685f      	ldr	r7, [r3, #4]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_FreeSize)(h);
   15cbc:	69a3      	ldr	r3, [r4, #24]
   15cbe:	4620      	mov	r0, r4
   15cc0:	4798      	blx	r3
   15cc2:	4683      	mov	fp, r0
}
#define TCPIP_HEAP_FreeSize(h) TCPIP_HEAP_FreeSizeInline(h)

static __inline__ size_t __attribute__((always_inline)) TCPIP_HEAP_HighWatermarkInline(TCPIP_STACK_HEAP_HANDLE h)
{
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_HighWatermark)(h);
   15cc4:	69e3      	ldr	r3, [r4, #28]
   15cc6:	4620      	mov	r0, r4
   15cc8:	4798      	blx	r3
   15cca:	4603      	mov	r3, r0
   15ccc:	465a      	mov	r2, fp
   15cce:	f608 2124 	addw	r1, r8, #2596	; 0xa24
   15cd2:	f8dd b004 	ldr.w	fp, [sp, #4]
   15cd6:	4658      	mov	r0, fp
   15cd8:	47b8      	blx	r7
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Last heap error: 0x%x\r\n", TCPIP_HEAP_LastError(heapH));
   15cda:	682b      	ldr	r3, [r5, #0]
   15cdc:	685f      	ldr	r7, [r3, #4]
}
#define TCPIP_HEAP_HighWatermark(h) TCPIP_HEAP_HighWatermarkInline(h)

static __inline__ TCPIP_STACK_HEAP_RES __attribute__((always_inline)) TCPIP_HEAP_LastErrorInline(TCPIP_STACK_HEAP_HANDLE h)
{
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_LastError)(h);
   15cde:	6a23      	ldr	r3, [r4, #32]
   15ce0:	4620      	mov	r0, r4
   15ce2:	4798      	blx	r3
   15ce4:	4602      	mov	r2, r0
   15ce6:	f608 215c 	addw	r1, r8, #2652	; 0xa5c
   15cea:	4658      	mov	r0, fp
   15cec:	47b8      	blx	r7
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "No Trace info exists.\r\n");
   15cee:	682b      	ldr	r3, [r5, #0]
   15cf0:	681b      	ldr	r3, [r3, #0]
   15cf2:	f608 2174 	addw	r1, r8, #2676	; 0xa74
   15cf6:	4658      	mov	r0, fp
   15cf8:	4798      	blx	r3
    for(hType = startType; hType < endType; hType++)
   15cfa:	3601      	adds	r6, #1
   15cfc:	45b2      	cmp	sl, r6
   15cfe:	d8be      	bhi.n	15c7e <_Command_HeapInfo+0x2a>
    return true;
   15d00:	2001      	movs	r0, #1
}
   15d02:	b005      	add	sp, #20
   15d04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        hType = (unsigned int)atoi(argv[1]);
   15d08:	6850      	ldr	r0, [r2, #4]
   15d0a:	f00e fb9d 	bl	24448 <atoi>
   15d0e:	4606      	mov	r6, r0
        if(hType == TCPIP_STACK_HEAP_TYPE_NONE || hType >= TCPIP_STACK_HEAP_TYPES)
   15d10:	1e43      	subs	r3, r0, #1
   15d12:	2b02      	cmp	r3, #2
   15d14:	d803      	bhi.n	15d1e <_Command_HeapInfo+0xca>
        endType = hType + 1;
   15d16:	1c47      	adds	r7, r0, #1
        hasArgs = true;
   15d18:	2301      	movs	r3, #1
   15d1a:	9303      	str	r3, [sp, #12]
   15d1c:	e7a6      	b.n	15c6c <_Command_HeapInfo+0x18>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Unknown heap type. Use: [1, %d]\r\n", TCPIP_STACK_HEAP_TYPES - 1);
   15d1e:	682b      	ldr	r3, [r5, #0]
   15d20:	685b      	ldr	r3, [r3, #4]
   15d22:	2203      	movs	r2, #3
   15d24:	4908      	ldr	r1, [pc, #32]	; (15d48 <_Command_HeapInfo+0xf4>)
   15d26:	9801      	ldr	r0, [sp, #4]
   15d28:	4798      	blx	r3
            return false;
   15d2a:	2000      	movs	r0, #0
   15d2c:	e7e9      	b.n	15d02 <_Command_HeapInfo+0xae>
            if(hasArgs == true)
   15d2e:	9b03      	ldr	r3, [sp, #12]
   15d30:	2b00      	cmp	r3, #0
   15d32:	d0e2      	beq.n	15cfa <_Command_HeapInfo+0xa6>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "No heap info exists for type: %s!\r\n", typeMsg);
   15d34:	682b      	ldr	r3, [r5, #0]
   15d36:	685b      	ldr	r3, [r3, #4]
   15d38:	463a      	mov	r2, r7
   15d3a:	f508 611a 	add.w	r1, r8, #2464	; 0x9a0
   15d3e:	9801      	ldr	r0, [sp, #4]
   15d40:	4798      	blx	r3
   15d42:	e7da      	b.n	15cfa <_Command_HeapInfo+0xa6>
   15d44:	00023d60 	.word	0x00023d60
   15d48:	00000c08 	.word	0x00000c08
   15d4c:	0000028c 	.word	0x0000028c

Disassembly of section .text.CLOCK_Initialize%332:

00015d50 <CLOCK_Initialize>:
}

static void OSC32KCTRL_Initialize(void)
{

    OSC32KCTRL_REGS->OSC32KCTRL_RTCCTRL = OSC32KCTRL_RTCCTRL_RTCSEL(0);
   15d50:	4b36      	ldr	r3, [pc, #216]	; (15e2c <CLOCK_Initialize+0xdc>)
   15d52:	2200      	movs	r2, #0
   15d54:	741a      	strb	r2, [r3, #16]
    }
}

static void GCLK2_Initialize(void)
{
    GCLK_REGS->GCLK_GENCTRL[2] = GCLK_GENCTRL_DIV(48) | GCLK_GENCTRL_SRC(6) | GCLK_GENCTRL_GENEN_Msk;
   15d56:	f503 6300 	add.w	r3, r3, #2048	; 0x800
   15d5a:	4a35      	ldr	r2, [pc, #212]	; (15e30 <CLOCK_Initialize+0xe0>)
   15d5c:	629a      	str	r2, [r3, #40]	; 0x28

    while((GCLK_REGS->GCLK_SYNCBUSY & GCLK_SYNCBUSY_GENCTRL_GCLK2) == GCLK_SYNCBUSY_GENCTRL_GCLK2)
   15d5e:	461a      	mov	r2, r3
   15d60:	6853      	ldr	r3, [r2, #4]
   15d62:	f013 0f10 	tst.w	r3, #16
   15d66:	d1fb      	bne.n	15d60 <CLOCK_Initialize+0x10>
    GCLK_REGS->GCLK_PCHCTRL[1] = GCLK_PCHCTRL_GEN(0x2)  | GCLK_PCHCTRL_CHEN_Msk;
   15d68:	4b32      	ldr	r3, [pc, #200]	; (15e34 <CLOCK_Initialize+0xe4>)
   15d6a:	2242      	movs	r2, #66	; 0x42
   15d6c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    while ((GCLK_REGS->GCLK_PCHCTRL[1] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
   15d70:	461a      	mov	r2, r3
   15d72:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
   15d76:	f013 0f40 	tst.w	r3, #64	; 0x40
   15d7a:	d0fa      	beq.n	15d72 <CLOCK_Initialize+0x22>
    OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLCTRLB = OSCCTRL_DPLLCTRLB_FILTER(0) | OSCCTRL_DPLLCTRLB_LTIME(0x0)| OSCCTRL_DPLLCTRLB_REFCLK(0) ;
   15d7c:	4b2e      	ldr	r3, [pc, #184]	; (15e38 <CLOCK_Initialize+0xe8>)
   15d7e:	2200      	movs	r2, #0
   15d80:	639a      	str	r2, [r3, #56]	; 0x38
    OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLRATIO = OSCCTRL_DPLLRATIO_LDRFRAC(0) | OSCCTRL_DPLLRATIO_LDR(119);
   15d82:	2277      	movs	r2, #119	; 0x77
   15d84:	635a      	str	r2, [r3, #52]	; 0x34
    while((OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLSYNCBUSY & OSCCTRL_DPLLSYNCBUSY_DPLLRATIO_Msk) == OSCCTRL_DPLLSYNCBUSY_DPLLRATIO_Msk)
   15d86:	461a      	mov	r2, r3
   15d88:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   15d8a:	f013 0f04 	tst.w	r3, #4
   15d8e:	d1fb      	bne.n	15d88 <CLOCK_Initialize+0x38>
    OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLCTRLA = OSCCTRL_DPLLCTRLA_ENABLE_Msk   ;
   15d90:	4b29      	ldr	r3, [pc, #164]	; (15e38 <CLOCK_Initialize+0xe8>)
   15d92:	2202      	movs	r2, #2
   15d94:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    while((OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLSYNCBUSY & OSCCTRL_DPLLSYNCBUSY_ENABLE_Msk) == OSCCTRL_DPLLSYNCBUSY_ENABLE_Msk )
   15d98:	461a      	mov	r2, r3
   15d9a:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   15d9c:	f013 0f02 	tst.w	r3, #2
   15da0:	d1fb      	bne.n	15d9a <CLOCK_Initialize+0x4a>
    while((OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLSTATUS & (OSCCTRL_DPLLSTATUS_LOCK_Msk | OSCCTRL_DPLLSTATUS_CLKRDY_Msk)) !=
   15da2:	4a25      	ldr	r2, [pc, #148]	; (15e38 <CLOCK_Initialize+0xe8>)
   15da4:	6c13      	ldr	r3, [r2, #64]	; 0x40
   15da6:	f003 0303 	and.w	r3, r3, #3
   15daa:	2b03      	cmp	r3, #3
   15dac:	d1fa      	bne.n	15da4 <CLOCK_Initialize+0x54>
    MCLK_REGS->MCLK_CPUDIV = MCLK_CPUDIV_DIV(0x01);
   15dae:	4b23      	ldr	r3, [pc, #140]	; (15e3c <CLOCK_Initialize+0xec>)
   15db0:	2201      	movs	r2, #1
   15db2:	715a      	strb	r2, [r3, #5]
    while((MCLK_REGS->MCLK_INTFLAG & MCLK_INTFLAG_CKRDY_Msk) != MCLK_INTFLAG_CKRDY_Msk)
   15db4:	461a      	mov	r2, r3
   15db6:	78d3      	ldrb	r3, [r2, #3]
   15db8:	f013 0f01 	tst.w	r3, #1
   15dbc:	d0fb      	beq.n	15db6 <CLOCK_Initialize+0x66>
    GCLK_REGS->GCLK_GENCTRL[0] = GCLK_GENCTRL_DIV(1) | GCLK_GENCTRL_SRC(7) | GCLK_GENCTRL_GENEN_Msk;
   15dbe:	4b1d      	ldr	r3, [pc, #116]	; (15e34 <CLOCK_Initialize+0xe4>)
   15dc0:	4a1f      	ldr	r2, [pc, #124]	; (15e40 <CLOCK_Initialize+0xf0>)
   15dc2:	621a      	str	r2, [r3, #32]
    while((GCLK_REGS->GCLK_SYNCBUSY & GCLK_SYNCBUSY_GENCTRL_GCLK0) == GCLK_SYNCBUSY_GENCTRL_GCLK0)
   15dc4:	461a      	mov	r2, r3
   15dc6:	6853      	ldr	r3, [r2, #4]
   15dc8:	f013 0f04 	tst.w	r3, #4
   15dcc:	d1fb      	bne.n	15dc6 <CLOCK_Initialize+0x76>
    GCLK_REGS->GCLK_GENCTRL[1] = GCLK_GENCTRL_DIV(2) | GCLK_GENCTRL_SRC(7) | GCLK_GENCTRL_GENEN_Msk;
   15dce:	4b19      	ldr	r3, [pc, #100]	; (15e34 <CLOCK_Initialize+0xe4>)
   15dd0:	4a1c      	ldr	r2, [pc, #112]	; (15e44 <CLOCK_Initialize+0xf4>)
   15dd2:	625a      	str	r2, [r3, #36]	; 0x24
    while((GCLK_REGS->GCLK_SYNCBUSY & GCLK_SYNCBUSY_GENCTRL_GCLK1) == GCLK_SYNCBUSY_GENCTRL_GCLK1)
   15dd4:	461a      	mov	r2, r3
   15dd6:	6853      	ldr	r3, [r2, #4]
   15dd8:	f013 0f08 	tst.w	r3, #8
   15ddc:	d1fb      	bne.n	15dd6 <CLOCK_Initialize+0x86>
    GCLK1_Initialize();



    /* Selection of the Generator and write Lock for SERCOM0_CORE */
    GCLK_REGS->GCLK_PCHCTRL[7] = GCLK_PCHCTRL_GEN(0x1)  | GCLK_PCHCTRL_CHEN_Msk;
   15dde:	4b15      	ldr	r3, [pc, #84]	; (15e34 <CLOCK_Initialize+0xe4>)
   15de0:	2241      	movs	r2, #65	; 0x41
   15de2:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c

    while ((GCLK_REGS->GCLK_PCHCTRL[7] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
   15de6:	461a      	mov	r2, r3
   15de8:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
   15dec:	f013 0f40 	tst.w	r3, #64	; 0x40
   15df0:	d0fa      	beq.n	15de8 <CLOCK_Initialize+0x98>
    {
        /* Wait for synchronization */
    }
    /* Selection of the Generator and write Lock for SERCOM1_CORE */
    GCLK_REGS->GCLK_PCHCTRL[8] = GCLK_PCHCTRL_GEN(0x1)  | GCLK_PCHCTRL_CHEN_Msk;
   15df2:	4b10      	ldr	r3, [pc, #64]	; (15e34 <CLOCK_Initialize+0xe4>)
   15df4:	2241      	movs	r2, #65	; 0x41
   15df6:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

    while ((GCLK_REGS->GCLK_PCHCTRL[8] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
   15dfa:	461a      	mov	r2, r3
   15dfc:	f8d2 30a0 	ldr.w	r3, [r2, #160]	; 0xa0
   15e00:	f013 0f40 	tst.w	r3, #64	; 0x40
   15e04:	d0fa      	beq.n	15dfc <CLOCK_Initialize+0xac>
    {
        /* Wait for synchronization */
    }
    /* Selection of the Generator and write Lock for TC0 TC1 */
    GCLK_REGS->GCLK_PCHCTRL[9] = GCLK_PCHCTRL_GEN(0x1)  | GCLK_PCHCTRL_CHEN_Msk;
   15e06:	4b0b      	ldr	r3, [pc, #44]	; (15e34 <CLOCK_Initialize+0xe4>)
   15e08:	2241      	movs	r2, #65	; 0x41
   15e0a:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4

    while ((GCLK_REGS->GCLK_PCHCTRL[9] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
   15e0e:	461a      	mov	r2, r3
   15e10:	f8d2 30a4 	ldr.w	r3, [r2, #164]	; 0xa4
   15e14:	f013 0f40 	tst.w	r3, #64	; 0x40
   15e18:	d0fa      	beq.n	15e10 <CLOCK_Initialize+0xc0>
    {
        /* Wait for synchronization */
    }

    /* Configure the AHB Bridge Clocks */
    MCLK_REGS->MCLK_AHBMASK = 0xffffff;
   15e1a:	4b08      	ldr	r3, [pc, #32]	; (15e3c <CLOCK_Initialize+0xec>)
   15e1c:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
   15e20:	611a      	str	r2, [r3, #16]

    /* Configure the APBA Bridge Clocks */
    MCLK_REGS->MCLK_APBAMASK = 0x77ff;
   15e22:	f247 72ff 	movw	r2, #30719	; 0x77ff
   15e26:	615a      	str	r2, [r3, #20]


}
   15e28:	4770      	bx	lr
   15e2a:	bf00      	nop
   15e2c:	40001400 	.word	0x40001400
   15e30:	00300106 	.word	0x00300106
   15e34:	40001c00 	.word	0x40001c00
   15e38:	40001000 	.word	0x40001000
   15e3c:	40000800 	.word	0x40000800
   15e40:	00010107 	.word	0x00010107
   15e44:	00020107 	.word	0x00020107

Disassembly of section .text.TCPIP_TCP_Deinitialize%333:

00015e48 <TCPIP_TCP_Deinitialize>:
{
   15e48:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15e4c:	4606      	mov	r6, r0
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);  // System Lock
   15e4e:	2000      	movs	r0, #0
   15e50:	f00d fc90 	bl	23774 <OSAL_CRIT_Enter>
    if(tcpLockCount == 1)
   15e54:	4b33      	ldr	r3, [pc, #204]	; (15f24 <TCPIP_TCP_Deinitialize+0xdc>)
   15e56:	681b      	ldr	r3, [r3, #0]
   15e58:	2b01      	cmp	r3, #1
   15e5a:	d005      	beq.n	15e68 <TCPIP_TCP_Deinitialize+0x20>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);  // System unlock
   15e5c:	4601      	mov	r1, r0
   15e5e:	2000      	movs	r0, #0
   15e60:	f00d fdc2 	bl	239e8 <OSAL_CRIT_Leave>
}
   15e64:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(tcpInitCount <= 0)
   15e68:	4b2f      	ldr	r3, [pc, #188]	; (15f28 <TCPIP_TCP_Deinitialize+0xe0>)
   15e6a:	681b      	ldr	r3, [r3, #0]
   15e6c:	2b00      	cmp	r3, #0
   15e6e:	dd54      	ble.n	15f1a <TCPIP_TCP_Deinitialize+0xd2>
            tcpLockCount = 2;   // get lock
   15e70:	4b2c      	ldr	r3, [pc, #176]	; (15f24 <TCPIP_TCP_Deinitialize+0xdc>)
   15e72:	2202      	movs	r2, #2
   15e74:	601a      	str	r2, [r3, #0]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);  // System unlock
   15e76:	4601      	mov	r1, r0
   15e78:	2000      	movs	r0, #0
   15e7a:	f00d fdb5 	bl	239e8 <OSAL_CRIT_Leave>
        _TCPAbortSockets(1 << stackInit->netIx, TCPIP_TCP_SIGNAL_IF_DOWN); 
   15e7e:	69b3      	ldr	r3, [r6, #24]
   15e80:	f04f 0901 	mov.w	r9, #1
   15e84:	fa09 f903 	lsl.w	r9, r9, r3
    for(ix = 0; ix < TcpSockets; ix++)
   15e88:	4b28      	ldr	r3, [pc, #160]	; (15f2c <TCPIP_TCP_Deinitialize+0xe4>)
   15e8a:	681b      	ldr	r3, [r3, #0]
   15e8c:	b37b      	cbz	r3, 15eee <TCPIP_TCP_Deinitialize+0xa6>
   15e8e:	2400      	movs	r4, #0
        if((pSkt = TCBStubs[ix]) != 0)  
   15e90:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 15f34 <TCPIP_TCP_Deinitialize+0xec>
                uint32_t sktIfMask = 1 << netIx;
   15e94:	f04f 0a01 	mov.w	sl, #1
    for(ix = 0; ix < TcpSockets; ix++)
   15e98:	4f24      	ldr	r7, [pc, #144]	; (15f2c <TCPIP_TCP_Deinitialize+0xe4>)
   15e9a:	e017      	b.n	15ecc <TCPIP_TCP_Deinitialize+0x84>
                    bool isServer = pSkt->Flags.bServer;
   15e9c:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
   15ea0:	f003 0b01 	and.w	fp, r3, #1
                    pSkt->Flags.bServer = 1;
   15ea4:	f043 0301 	orr.w	r3, r3, #1
   15ea8:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
                    _TcpAbort(pSkt, _TCP_ABORT_FLAG_REGULAR, sigType);
   15eac:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   15eb0:	2100      	movs	r1, #0
   15eb2:	4628      	mov	r0, r5
   15eb4:	f008 f8fe 	bl	1e0b4 <_TcpAbort>
                    pSkt->Flags.bServer = isServer;
   15eb8:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
   15ebc:	f36b 0300 	bfi	r3, fp, #0, #1
   15ec0:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
    for(ix = 0; ix < TcpSockets; ix++)
   15ec4:	3401      	adds	r4, #1
   15ec6:	683b      	ldr	r3, [r7, #0]
   15ec8:	42a3      	cmp	r3, r4
   15eca:	d910      	bls.n	15eee <TCPIP_TCP_Deinitialize+0xa6>
        if((pSkt = TCBStubs[ix]) != 0)  
   15ecc:	f8d8 3000 	ldr.w	r3, [r8]
   15ed0:	f853 5024 	ldr.w	r5, [r3, r4, lsl #2]
   15ed4:	2d00      	cmp	r5, #0
   15ed6:	d0f5      	beq.n	15ec4 <TCPIP_TCP_Deinitialize+0x7c>
            int netIx = TCPIP_STACK_NetIxGet(pSkt->pSktNet);
   15ed8:	6c28      	ldr	r0, [r5, #64]	; 0x40
   15eda:	f00e f82d 	bl	23f38 <TCPIP_STACK_NetIxGet>
            if(netIx >= 0 )
   15ede:	2800      	cmp	r0, #0
   15ee0:	dbf0      	blt.n	15ec4 <TCPIP_TCP_Deinitialize+0x7c>
                uint32_t sktIfMask = 1 << netIx;
   15ee2:	fa0a f000 	lsl.w	r0, sl, r0
                if((sktIfMask & netMask) != 0)
   15ee6:	ea10 0f09 	tst.w	r0, r9
   15eea:	d0eb      	beq.n	15ec4 <TCPIP_TCP_Deinitialize+0x7c>
   15eec:	e7d6      	b.n	15e9c <TCPIP_TCP_Deinitialize+0x54>
        if(stackInit->stackAction == TCPIP_STACK_ACTION_DEINIT && --tcpInitCount == 0)
   15eee:	7f33      	ldrb	r3, [r6, #28]
   15ef0:	2b02      	cmp	r3, #2
   15ef2:	d003      	beq.n	15efc <TCPIP_TCP_Deinitialize+0xb4>
            tcpLockCount = 1;   // release lock
   15ef4:	4b0b      	ldr	r3, [pc, #44]	; (15f24 <TCPIP_TCP_Deinitialize+0xdc>)
   15ef6:	2201      	movs	r2, #1
   15ef8:	601a      	str	r2, [r3, #0]
}
   15efa:	e7b3      	b.n	15e64 <TCPIP_TCP_Deinitialize+0x1c>
        if(stackInit->stackAction == TCPIP_STACK_ACTION_DEINIT && --tcpInitCount == 0)
   15efc:	4a0a      	ldr	r2, [pc, #40]	; (15f28 <TCPIP_TCP_Deinitialize+0xe0>)
   15efe:	6813      	ldr	r3, [r2, #0]
   15f00:	3b01      	subs	r3, #1
   15f02:	6013      	str	r3, [r2, #0]
   15f04:	2b00      	cmp	r3, #0
   15f06:	d1f5      	bne.n	15ef4 <TCPIP_TCP_Deinitialize+0xac>
            _TcpCleanup();
   15f08:	f006 faf0 	bl	1c4ec <_TcpCleanup>
            OSAL_SEM_Delete(&tcpSemaphore);
   15f0c:	4808      	ldr	r0, [pc, #32]	; (15f30 <TCPIP_TCP_Deinitialize+0xe8>)
   15f0e:	f00d feb6 	bl	23c7e <OSAL_SEM_Delete>
            tcpLockCount = 0;   // leave it uninitialized
   15f12:	4b04      	ldr	r3, [pc, #16]	; (15f24 <TCPIP_TCP_Deinitialize+0xdc>)
   15f14:	2200      	movs	r2, #0
   15f16:	601a      	str	r2, [r3, #0]
   15f18:	e7a4      	b.n	15e64 <TCPIP_TCP_Deinitialize+0x1c>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);  // System unlock
   15f1a:	4601      	mov	r1, r0
   15f1c:	2000      	movs	r0, #0
   15f1e:	f00d fd63 	bl	239e8 <OSAL_CRIT_Leave>
    if(deinitFault)
   15f22:	e79f      	b.n	15e64 <TCPIP_TCP_Deinitialize+0x1c>
   15f24:	2000edd0 	.word	0x2000edd0
   15f28:	2000edcc 	.word	0x2000edcc
   15f2c:	2000edc4 	.word	0x2000edc4
   15f30:	2000edd4 	.word	0x2000edd4
   15f34:	2000edc0 	.word	0x2000edc0

Disassembly of section .text.TCPIP_ARP_EntryRemoveNet%334:

00015f38 <TCPIP_ARP_EntryRemoveNet>:
    TCPIP_NET_IF    *pIf;
    int             index;
    uint16_t        andFlags, resFlags;
    uint32_t        matchAdd;

    if(ipAdd == 0 || ipAdd->Val == 0)
   15f38:	2900      	cmp	r1, #0
   15f3a:	d064      	beq.n	16006 <TCPIP_ARP_EntryRemoveNet+0xce>
{
   15f3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15f40:	b083      	sub	sp, #12
   15f42:	460c      	mov	r4, r1
    if(ipAdd == 0 || ipAdd->Val == 0)
   15f44:	6809      	ldr	r1, [r1, #0]
   15f46:	2900      	cmp	r1, #0
   15f48:	d060      	beq.n	1600c <TCPIP_ARP_EntryRemoveNet+0xd4>
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   15f4a:	2800      	cmp	r0, #0
   15f4c:	d061      	beq.n	16012 <TCPIP_ARP_EntryRemoveNet+0xda>
   15f4e:	f890 1042 	ldrb.w	r1, [r0, #66]	; 0x42
   15f52:	f011 0f40 	tst.w	r1, #64	; 0x40
   15f56:	d104      	bne.n	15f62 <TCPIP_ARP_EntryRemoveNet+0x2a>
    }

    pIf = _TCPIPStackHandleToNetUp(hNet);
    if(!pIf)
    {
        return ARP_RES_NO_INTERFACE;
   15f58:	f06f 0005 	mvn.w	r0, #5
            }
        }
    }

    return ARP_RES_OK;
}
   15f5c:	b003      	add	sp, #12
   15f5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    switch (type)
   15f62:	3b01      	subs	r3, #1
   15f64:	2b03      	cmp	r3, #3
   15f66:	d857      	bhi.n	16018 <TCPIP_ARP_EntryRemoveNet+0xe0>
   15f68:	e8df f003 	tbb	[pc, r3]
   15f6c:	0b06020f 	.word	0x0b06020f
            andFlags = resFlags =  ARP_FLAG_ENTRY_COMPLETE;
   15f70:	f04f 0980 	mov.w	r9, #128	; 0x80
   15f74:	46ca      	mov	sl, r9
   15f76:	e00b      	b.n	15f90 <TCPIP_ARP_EntryRemoveNet+0x58>
            resFlags = 0;
   15f78:	f04f 0900 	mov.w	r9, #0
            andFlags = (ARP_FLAG_ENTRY_PERM | ARP_FLAG_ENTRY_COMPLETE);
   15f7c:	f04f 0ac0 	mov.w	sl, #192	; 0xc0
            break;
   15f80:	e006      	b.n	15f90 <TCPIP_ARP_EntryRemoveNet+0x58>
            andFlags = resFlags = 0;
   15f82:	f04f 0900 	mov.w	r9, #0
   15f86:	46ca      	mov	sl, r9
            break;
   15f88:	e002      	b.n	15f90 <TCPIP_ARP_EntryRemoveNet+0x58>
            andFlags = resFlags = ARP_FLAG_ENTRY_PERM;
   15f8a:	f04f 0940 	mov.w	r9, #64	; 0x40
   15f8e:	46ca      	mov	sl, r9
   15f90:	4617      	mov	r7, r2
   15f92:	9001      	str	r0, [sp, #4]
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   15f94:	4b23      	ldr	r3, [pc, #140]	; (16024 <TCPIP_ARP_EntryRemoveNet+0xec>)
   15f96:	685d      	ldr	r5, [r3, #4]
   15f98:	f00d ffce 	bl	23f38 <TCPIP_STACK_NetIxGet>
   15f9c:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   15fa0:	00c0      	lsls	r0, r0, #3
   15fa2:	eb05 0800 	add.w	r8, r5, r0
    pOH = pArpDcpt->hashDcpt;
   15fa6:	582e      	ldr	r6, [r5, r0]
    matchAdd = ipAdd->Val & mask->Val;
   15fa8:	6822      	ldr	r2, [r4, #0]
   15faa:	683b      	ldr	r3, [r7, #0]
   15fac:	ea02 0b03 	and.w	fp, r2, r3
    for(index = 0; index < pOH->hEntries; index++)
   15fb0:	68f3      	ldr	r3, [r6, #12]
   15fb2:	b3a3      	cbz	r3, 1601e <TCPIP_ARP_EntryRemoveNet+0xe6>
   15fb4:	2400      	movs	r4, #0
   15fb6:	e003      	b.n	15fc0 <TCPIP_ARP_EntryRemoveNet+0x88>
   15fb8:	3401      	adds	r4, #1
   15fba:	68f3      	ldr	r3, [r6, #12]
   15fbc:	42a3      	cmp	r3, r4
   15fbe:	d920      	bls.n	16002 <TCPIP_ARP_EntryRemoveNet+0xca>
        hE = TCPIP_OAHASH_EntryGet(pArpDcpt->hashDcpt, index);
   15fc0:	4621      	mov	r1, r4
   15fc2:	f8d8 0000 	ldr.w	r0, [r8]
   15fc6:	f00d fe48 	bl	23c5a <TCPIP_OAHASH_EntryGet>
   15fca:	4605      	mov	r5, r0
        if(hE->flags.busy != 0)
   15fcc:	7803      	ldrb	r3, [r0, #0]
   15fce:	f013 0f01 	tst.w	r3, #1
   15fd2:	d0f1      	beq.n	15fb8 <TCPIP_ARP_EntryRemoveNet+0x80>
            if((hE->flags.value & andFlags) == resFlags)
   15fd4:	8803      	ldrh	r3, [r0, #0]
   15fd6:	ea0a 0303 	and.w	r3, sl, r3
   15fda:	454b      	cmp	r3, r9
   15fdc:	d1ec      	bne.n	15fb8 <TCPIP_ARP_EntryRemoveNet+0x80>
                if((arpHE->ipAddress.Val & mask->Val) == matchAdd)
   15fde:	6883      	ldr	r3, [r0, #8]
   15fe0:	683a      	ldr	r2, [r7, #0]
   15fe2:	4013      	ands	r3, r2
   15fe4:	455b      	cmp	r3, fp
   15fe6:	d1e7      	bne.n	15fb8 <TCPIP_ARP_EntryRemoveNet+0x80>
                    _ARPRemoveEntry(pArpDcpt, hE);
   15fe8:	4601      	mov	r1, r0
   15fea:	4640      	mov	r0, r8
   15fec:	f00b fcd6 	bl	2199c <_ARPRemoveEntry>
                    _ARPNotifyClients(pIf, &arpHE->ipAddress, 0, ARP_EVENT_REMOVED_USER);
   15ff0:	f06f 0301 	mvn.w	r3, #1
   15ff4:	2200      	movs	r2, #0
   15ff6:	f105 0108 	add.w	r1, r5, #8
   15ffa:	9801      	ldr	r0, [sp, #4]
   15ffc:	f007 fe38 	bl	1dc70 <_ARPNotifyClients>
   16000:	e7da      	b.n	15fb8 <TCPIP_ARP_EntryRemoveNet+0x80>
    return ARP_RES_OK;
   16002:	2000      	movs	r0, #0
   16004:	e7aa      	b.n	15f5c <TCPIP_ARP_EntryRemoveNet+0x24>
        return ARP_RES_BAD_ADDRESS;
   16006:	f06f 0004 	mvn.w	r0, #4
}
   1600a:	4770      	bx	lr
        return ARP_RES_BAD_ADDRESS;
   1600c:	f06f 0004 	mvn.w	r0, #4
   16010:	e7a4      	b.n	15f5c <TCPIP_ARP_EntryRemoveNet+0x24>
        return ARP_RES_NO_INTERFACE;
   16012:	f06f 0005 	mvn.w	r0, #5
   16016:	e7a1      	b.n	15f5c <TCPIP_ARP_EntryRemoveNet+0x24>
            return ARP_RES_BAD_TYPE;
   16018:	f06f 0006 	mvn.w	r0, #6
   1601c:	e79e      	b.n	15f5c <TCPIP_ARP_EntryRemoveNet+0x24>
    return ARP_RES_OK;
   1601e:	2000      	movs	r0, #0
   16020:	e79c      	b.n	15f5c <TCPIP_ARP_EntryRemoveNet+0x24>
   16022:	bf00      	nop
   16024:	2000e974 	.word	0x2000e974

Disassembly of section .text._DNS_IsNameResolved%335:

00016028 <_DNS_IsNameResolved>:
{    
   16028:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1602c:	b084      	sub	sp, #16
    if(hostIPv4)
   1602e:	460e      	mov	r6, r1
   16030:	b109      	cbz	r1, 16036 <_DNS_IsNameResolved+0xe>
        hostIPv4->Val = 0;
   16032:	2100      	movs	r1, #0
   16034:	6031      	str	r1, [r6, #0]
    if(hostIPv6)
   16036:	b122      	cbz	r2, 16042 <_DNS_IsNameResolved+0x1a>
        memset(hostIPv6->v, 0, sizeof(*hostIPv6));
   16038:	2100      	movs	r1, #0
   1603a:	6011      	str	r1, [r2, #0]
   1603c:	6051      	str	r1, [r2, #4]
   1603e:	6091      	str	r1, [r2, #8]
   16040:	60d1      	str	r1, [r2, #12]
    pDnsDcpt = pgDnsDcpt;
   16042:	4934      	ldr	r1, [pc, #208]	; (16114 <_DNS_IsNameResolved+0xec>)
   16044:	680f      	ldr	r7, [r1, #0]
    if(pDnsDcpt == 0)
   16046:	2f00      	cmp	r7, #0
   16048:	d055      	beq.n	160f6 <_DNS_IsNameResolved+0xce>
   1604a:	4698      	mov	r8, r3
   1604c:	4614      	mov	r4, r2
   1604e:	4605      	mov	r5, r0
    if(TCPIP_Helper_StringToIPAddress(hostName, &mAddr.v4Add))
   16050:	4669      	mov	r1, sp
   16052:	f7fe fd0d 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
   16056:	b138      	cbz	r0, 16068 <_DNS_IsNameResolved+0x40>
        if(hostIPv4)
   16058:	2e00      	cmp	r6, #0
   1605a:	d04f      	beq.n	160fc <_DNS_IsNameResolved+0xd4>
            hostIPv4->Val = mAddr.v4Add.Val;
   1605c:	9b00      	ldr	r3, [sp, #0]
   1605e:	6033      	str	r3, [r6, #0]
        return  TCPIP_DNS_RES_OK; 
   16060:	2000      	movs	r0, #0
}
   16062:	b004      	add	sp, #16
   16064:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (TCPIP_Helper_StringToIPv6Address (hostName, &mAddr.v6Add))
   16068:	4669      	mov	r1, sp
   1606a:	4628      	mov	r0, r5
   1606c:	f7f5 fd8a 	bl	bb84 <TCPIP_Helper_StringToIPv6Address>
   16070:	b148      	cbz	r0, 16086 <_DNS_IsNameResolved+0x5e>
        if(hostIPv6)
   16072:	2c00      	cmp	r4, #0
   16074:	d044      	beq.n	16100 <_DNS_IsNameResolved+0xd8>
            memcpy (hostIPv6->v, mAddr.v6Add.v, sizeof (IPV6_ADDR));
   16076:	466d      	mov	r5, sp
   16078:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1607a:	6020      	str	r0, [r4, #0]
   1607c:	6061      	str	r1, [r4, #4]
   1607e:	60a2      	str	r2, [r4, #8]
   16080:	60e3      	str	r3, [r4, #12]
        return  TCPIP_DNS_RES_OK; 
   16082:	2000      	movs	r0, #0
   16084:	e7ed      	b.n	16062 <_DNS_IsNameResolved+0x3a>
    pDnsHE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryLookup(pDnsDcpt->hashDcpt, hostName);
   16086:	4629      	mov	r1, r5
   16088:	6838      	ldr	r0, [r7, #0]
   1608a:	f006 fc7b 	bl	1c984 <TCPIP_OAHASH_EntryLookup>
    if(pDnsHE == 0)
   1608e:	4603      	mov	r3, r0
   16090:	2800      	cmp	r0, #0
   16092:	d037      	beq.n	16104 <_DNS_IsNameResolved+0xdc>
    if((pDnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) == 0)
   16094:	8802      	ldrh	r2, [r0, #0]
   16096:	f012 0f80 	tst.w	r2, #128	; 0x80
   1609a:	d00e      	beq.n	160ba <_DNS_IsNameResolved+0x92>
    nIPv6Entries = pDnsHE->nIPv6Entries;
   1609c:	f890 2027 	ldrb.w	r2, [r0, #39]	; 0x27
    nIPv4Entries = pDnsHE->nIPv4Entries;
   160a0:	f890 1026 	ldrb.w	r1, [r0, #38]	; 0x26
    if(nIPv6Entries || nIPv4Entries)
   160a4:	b98a      	cbnz	r2, 160ca <_DNS_IsNameResolved+0xa2>
    return TCPIP_DNS_RES_NO_IP_ENTRY;
   160a6:	f06f 0001 	mvn.w	r0, #1
    if(nIPv6Entries || nIPv4Entries)
   160aa:	2900      	cmp	r1, #0
   160ac:	d0d9      	beq.n	16062 <_DNS_IsNameResolved+0x3a>
            if(hostIPv4)
   160ae:	b376      	cbz	r6, 1610e <_DNS_IsNameResolved+0xe6>
                hostIPv4->Val = (pDnsHE->pip4Address + 0)->Val;
   160b0:	691b      	ldr	r3, [r3, #16]
   160b2:	681b      	ldr	r3, [r3, #0]
   160b4:	6033      	str	r3, [r6, #0]
        return TCPIP_DNS_RES_OK;
   160b6:	2000      	movs	r0, #0
   160b8:	e7d3      	b.n	16062 <_DNS_IsNameResolved+0x3a>
        return (pDnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_TIMEOUT) == 0 ? TCPIP_DNS_RES_PENDING : TCPIP_DNS_RES_SERVER_TMO; 
   160ba:	f402 7280 	and.w	r2, r2, #256	; 0x100
   160be:	2a00      	cmp	r2, #0
   160c0:	bf0c      	ite	eq
   160c2:	2001      	moveq	r0, #1
   160c4:	f06f 0004 	mvnne.w	r0, #4
   160c8:	e7cb      	b.n	16062 <_DNS_IsNameResolved+0x3a>
            if(hostIPv6)
   160ca:	b184      	cbz	r4, 160ee <_DNS_IsNameResolved+0xc6>
                memcpy (hostIPv6->v, pDnsHE->pip6Address + nIPv6Entries - 1, sizeof (IPV6_ADDR));
   160cc:	f102 5280 	add.w	r2, r2, #268435456	; 0x10000000
   160d0:	3a01      	subs	r2, #1
   160d2:	6940      	ldr	r0, [r0, #20]
   160d4:	eb00 1202 	add.w	r2, r0, r2, lsl #4
   160d8:	6817      	ldr	r7, [r2, #0]
   160da:	6855      	ldr	r5, [r2, #4]
   160dc:	6890      	ldr	r0, [r2, #8]
   160de:	68d2      	ldr	r2, [r2, #12]
   160e0:	6027      	str	r7, [r4, #0]
   160e2:	6065      	str	r5, [r4, #4]
   160e4:	60a0      	str	r0, [r4, #8]
   160e6:	60e2      	str	r2, [r4, #12]
                if(singleAddress)
   160e8:	f1b8 0f00 	cmp.w	r8, #0
   160ec:	d10d      	bne.n	1610a <_DNS_IsNameResolved+0xe2>
        return TCPIP_DNS_RES_OK;
   160ee:	2000      	movs	r0, #0
        if(nIPv4Entries)
   160f0:	2900      	cmp	r1, #0
   160f2:	d0b6      	beq.n	16062 <_DNS_IsNameResolved+0x3a>
   160f4:	e7db      	b.n	160ae <_DNS_IsNameResolved+0x86>
        return TCPIP_DNS_RES_NO_SERVICE;
   160f6:	f06f 0005 	mvn.w	r0, #5
   160fa:	e7b2      	b.n	16062 <_DNS_IsNameResolved+0x3a>
        return  TCPIP_DNS_RES_OK; 
   160fc:	2000      	movs	r0, #0
   160fe:	e7b0      	b.n	16062 <_DNS_IsNameResolved+0x3a>
        return  TCPIP_DNS_RES_OK; 
   16100:	2000      	movs	r0, #0
   16102:	e7ae      	b.n	16062 <_DNS_IsNameResolved+0x3a>
        return TCPIP_DNS_RES_NO_NAME_ENTRY;
   16104:	f04f 30ff 	mov.w	r0, #4294967295
   16108:	e7ab      	b.n	16062 <_DNS_IsNameResolved+0x3a>
        return TCPIP_DNS_RES_OK;
   1610a:	2000      	movs	r0, #0
   1610c:	e7a9      	b.n	16062 <_DNS_IsNameResolved+0x3a>
   1610e:	2000      	movs	r0, #0
   16110:	e7a7      	b.n	16062 <_DNS_IsNameResolved+0x3a>
   16112:	bf00      	nop
   16114:	2000ee58 	.word	0x2000ee58

Disassembly of section .text.TCPIP_DNS_ClientTask%336:

00016118 <TCPIP_DNS_ClientTask>:
{
   16118:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
   1611a:	210f      	movs	r1, #15
   1611c:	4608      	mov	r0, r1
   1611e:	f00a f809 	bl	20134 <_TCPIPStackModuleSignalGet>
    if(sigPend != 0)
   16122:	b900      	cbnz	r0, 16126 <TCPIP_DNS_ClientTask+0xe>
}
   16124:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        TCPIP_DNS_ClientProcess((sigPend & TCPIP_MODULE_SIGNAL_TMO) != 0);
   16126:	f000 0302 	and.w	r3, r0, #2
    if((pDnsDcpt = pgDnsDcpt) == 0)
   1612a:	4a36      	ldr	r2, [pc, #216]	; (16204 <TCPIP_DNS_ClientTask+0xec>)
   1612c:	6814      	ldr	r4, [r2, #0]
   1612e:	2c00      	cmp	r4, #0
   16130:	d0f8      	beq.n	16124 <TCPIP_DNS_ClientTask+0xc>
    if(isTmo)
   16132:	2b00      	cmp	r3, #0
   16134:	d05a      	beq.n	161ec <TCPIP_DNS_ClientTask+0xd4>
        pDnsDcpt->dnsTime = SYS_TMR_TickCountGetLong() / SYS_TMR_TickCounterFrequencyGet();
   16136:	f00c f895 	bl	22264 <SYS_TMR_TickCountGetLong>
   1613a:	4606      	mov	r6, r0
   1613c:	460f      	mov	r7, r1
   1613e:	f00c f8a5 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
   16142:	4602      	mov	r2, r0
   16144:	2300      	movs	r3, #0
   16146:	4630      	mov	r0, r6
   16148:	4639      	mov	r1, r7
   1614a:	f00b fa47 	bl	215dc <__aeabi_uldivmod>
   1614e:	4607      	mov	r7, r0
   16150:	61e0      	str	r0, [r4, #28]
    pOH = pDnsDcpt->hashDcpt;
   16152:	6826      	ldr	r6, [r4, #0]
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   16154:	68f3      	ldr	r3, [r6, #12]
   16156:	2b00      	cmp	r3, #0
   16158:	d048      	beq.n	161ec <TCPIP_DNS_ClientTask+0xd4>
   1615a:	2500      	movs	r5, #0
   1615c:	e008      	b.n	16170 <TCPIP_DNS_ClientTask+0x58>
                    timeout = pDnsHE->ipTTL.Val;
   1615e:	6982      	ldr	r2, [r0, #24]
                if((currTime - pDnsHE->tInsert) >= timeout)
   16160:	6883      	ldr	r3, [r0, #8]
   16162:	1afb      	subs	r3, r7, r3
   16164:	4293      	cmp	r3, r2
   16166:	d213      	bcs.n	16190 <TCPIP_DNS_ClientTask+0x78>
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   16168:	3501      	adds	r5, #1
   1616a:	68f3      	ldr	r3, [r6, #12]
   1616c:	42ab      	cmp	r3, r5
   1616e:	d93d      	bls.n	161ec <TCPIP_DNS_ClientTask+0xd4>
        pDnsHE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryGet(pOH, bktIx);
   16170:	4629      	mov	r1, r5
   16172:	4630      	mov	r0, r6
   16174:	f00d fd71 	bl	23c5a <TCPIP_OAHASH_EntryGet>
        if(pDnsHE->hEntry.flags.busy != 0)
   16178:	7803      	ldrb	r3, [r0, #0]
   1617a:	f013 0f01 	tst.w	r3, #1
   1617e:	d0f3      	beq.n	16168 <TCPIP_DNS_ClientTask+0x50>
            if((pDnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) != 0)
   16180:	8803      	ldrh	r3, [r0, #0]
   16182:	f013 0f80 	tst.w	r3, #128	; 0x80
   16186:	d008      	beq.n	1619a <TCPIP_DNS_ClientTask+0x82>
                if((timeout = pDnsDcpt->cacheEntryTMO) == 0)
   16188:	6962      	ldr	r2, [r4, #20]
   1618a:	2a00      	cmp	r2, #0
   1618c:	d1e8      	bne.n	16160 <TCPIP_DNS_ClientTask+0x48>
   1618e:	e7e6      	b.n	1615e <TCPIP_DNS_ClientTask+0x46>
    _DNS_CleanCacheEntry(pDnsDcpt, pDnsHE);
   16190:	4601      	mov	r1, r0
   16192:	4620      	mov	r0, r4
   16194:	f00b fb09 	bl	217aa <_DNS_CleanCacheEntry>
   16198:	e7e6      	b.n	16168 <TCPIP_DNS_ClientTask+0x50>
                if((pDnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_TIMEOUT) == 0)
   1619a:	f413 7f80 	tst.w	r3, #256	; 0x100
   1619e:	d116      	bne.n	161ce <TCPIP_DNS_ClientTask+0xb6>
                    if((currTime - pDnsHE->tRetry) >= TCPIP_DNS_CLIENT_LOOKUP_RETRY_TMO)
   161a0:	68c2      	ldr	r2, [r0, #12]
   161a2:	1aba      	subs	r2, r7, r2
   161a4:	2a01      	cmp	r2, #1
   161a6:	d9df      	bls.n	16168 <TCPIP_DNS_ClientTask+0x50>
                        pDnsHE->tRetry = currTime;
   161a8:	60c7      	str	r7, [r0, #12]
                        if(pDnsHE->currRetry < pDnsHE->nRetries)
   161aa:	f890 202b 	ldrb.w	r2, [r0, #43]	; 0x2b
   161ae:	f890 102c 	ldrb.w	r1, [r0, #44]	; 0x2c
   161b2:	4291      	cmp	r1, r2
   161b4:	d803      	bhi.n	161be <TCPIP_DNS_ClientTask+0xa6>
                            pDnsHE->hEntry.flags.value |= TCPIP_DNS_FLAG_ENTRY_TIMEOUT;
   161b6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   161ba:	8003      	strh	r3, [r0, #0]
   161bc:	e7d4      	b.n	16168 <TCPIP_DNS_ClientTask+0x50>
                            pDnsHE->currRetry++;
   161be:	3201      	adds	r2, #1
   161c0:	f880 202b 	strb.w	r2, [r0, #43]	; 0x2b
                            _DNS_Send_Query(pDnsDcpt, pDnsHE);
   161c4:	4601      	mov	r1, r0
   161c6:	4620      	mov	r0, r4
   161c8:	f7f8 f822 	bl	e210 <_DNS_Send_Query>
   161cc:	e7cc      	b.n	16168 <TCPIP_DNS_ClientTask+0x50>
                    if((currTime - pDnsHE->tRetry) >= _TCPIP_DNS_CLIENT_CACHE_UNSOLVED_EXPIRE_TMO)
   161ce:	68c3      	ldr	r3, [r0, #12]
   161d0:	429f      	cmp	r7, r3
   161d2:	d0c9      	beq.n	16168 <TCPIP_DNS_ClientTask+0x50>
    _DNS_CleanCacheEntry(pDnsDcpt, pDnsHE);
   161d4:	4601      	mov	r1, r0
   161d6:	4620      	mov	r0, r4
   161d8:	f00b fae7 	bl	217aa <_DNS_CleanCacheEntry>
   161dc:	e7c4      	b.n	16168 <TCPIP_DNS_ClientTask+0x50>
            _DNS_ProcessPacket(pDnsDcpt);
   161de:	4620      	mov	r0, r4
   161e0:	f7f4 fb8a 	bl	a8f8 <_DNS_ProcessPacket>
        TCPIP_UDP_Discard(pDnsDcpt->dnsSocket);
   161e4:	f9b4 0024 	ldrsh.w	r0, [r4, #36]	; 0x24
   161e8:	f00c fba7 	bl	2293a <TCPIP_UDP_Discard>
        if(!TCPIP_UDP_GetIsReady(pDnsDcpt->dnsSocket))
   161ec:	f9b4 0024 	ldrsh.w	r0, [r4, #36]	; 0x24
   161f0:	f00b ffd4 	bl	2219c <TCPIP_UDP_GetIsReady>
   161f4:	2800      	cmp	r0, #0
   161f6:	d095      	beq.n	16124 <TCPIP_DNS_ClientTask+0xc>
        if(pDnsDcpt->unsolvedEntries != 0)
   161f8:	f9b4 3026 	ldrsh.w	r3, [r4, #38]	; 0x26
   161fc:	2b00      	cmp	r3, #0
   161fe:	d0f1      	beq.n	161e4 <TCPIP_DNS_ClientTask+0xcc>
   16200:	e7ed      	b.n	161de <TCPIP_DNS_ClientTask+0xc6>
   16202:	bf00      	nop
   16204:	2000ee58 	.word	0x2000ee58

Disassembly of section .text.MONITOR_DHCP_eth_Handler%337:

00016208 <MONITOR_DHCP_eth_Handler>:
{
	clientObj->phyAddress = phyAddress;
	return Lan867x_Read_Register(clientObj, regAddr, rData);
}

void MONITOR_DHCP_eth_Handler(TCPIP_NET_HANDLE hNet, TCPIP_DHCP_EVENT_TYPE evType, const void* param) {
   16208:	b510      	push	{r4, lr}
   1620a:	460c      	mov	r4, r1

    SYS_CONSOLE_PRINT("%s - ", TCPIP_STACK_NetNameGet(hNet));
   1620c:	f00e f89d 	bl	2434a <TCPIP_STACK_NetNameGet>
   16210:	4602      	mov	r2, r0
   16212:	492a      	ldr	r1, [pc, #168]	; (162bc <MONITOR_DHCP_eth_Handler+0xb4>)
   16214:	2000      	movs	r0, #0
   16216:	f006 fa41 	bl	1c69c <SYS_CONSOLE_Print>

    switch (evType) {
   1621a:	2c0d      	cmp	r4, #13
   1621c:	d80c      	bhi.n	16238 <MONITOR_DHCP_eth_Handler+0x30>
   1621e:	e8df f004 	tbb	[pc, r4]
   16222:	0c07      	.short	0x0c07
   16224:	201b1611 	.word	0x201b1611
   16228:	342f2a25 	.word	0x342f2a25
   1622c:	48433e39 	.word	0x48433e39
        case DHCP_EVENT_NONE: SYS_CONSOLE_PRINT("DHCP_EVENT_NONE\n\r");
   16230:	4923      	ldr	r1, [pc, #140]	; (162c0 <MONITOR_DHCP_eth_Handler+0xb8>)
   16232:	2000      	movs	r0, #0
   16234:	f006 fa32 	bl	1c69c <SYS_CONSOLE_Print>
            break;
        case DHCP_EVENT_SERVICE_DISABLED: SYS_CONSOLE_PRINT("DHCP_EVENT_SERVICE_DISABLED\n\r");
            break;

    }
}
   16238:	bd10      	pop	{r4, pc}
        case DHCP_EVENT_DISCOVER: SYS_CONSOLE_PRINT("DHCP_EVENT_DISCOVER\n\r");
   1623a:	4922      	ldr	r1, [pc, #136]	; (162c4 <MONITOR_DHCP_eth_Handler+0xbc>)
   1623c:	2000      	movs	r0, #0
   1623e:	f006 fa2d 	bl	1c69c <SYS_CONSOLE_Print>
            break;
   16242:	e7f9      	b.n	16238 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_REQUEST: SYS_CONSOLE_PRINT("DHCP_EVENT_REQUEST\n\r");
   16244:	4920      	ldr	r1, [pc, #128]	; (162c8 <MONITOR_DHCP_eth_Handler+0xc0>)
   16246:	2000      	movs	r0, #0
   16248:	f006 fa28 	bl	1c69c <SYS_CONSOLE_Print>
            break;
   1624c:	e7f4      	b.n	16238 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_ACK: SYS_CONSOLE_PRINT("DHCP_EVENT_ACK\n\r");
   1624e:	491f      	ldr	r1, [pc, #124]	; (162cc <MONITOR_DHCP_eth_Handler+0xc4>)
   16250:	2000      	movs	r0, #0
   16252:	f006 fa23 	bl	1c69c <SYS_CONSOLE_Print>
            break;
   16256:	e7ef      	b.n	16238 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_ACK_INVALID: SYS_CONSOLE_PRINT("DHCP_EVENT_ACK_INVALID\n\r");
   16258:	491d      	ldr	r1, [pc, #116]	; (162d0 <MONITOR_DHCP_eth_Handler+0xc8>)
   1625a:	2000      	movs	r0, #0
   1625c:	f006 fa1e 	bl	1c69c <SYS_CONSOLE_Print>
            break;
   16260:	e7ea      	b.n	16238 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_DECLINE: SYS_CONSOLE_PRINT("DHCP_EVENT_DECLINE\n\r");
   16262:	491c      	ldr	r1, [pc, #112]	; (162d4 <MONITOR_DHCP_eth_Handler+0xcc>)
   16264:	2000      	movs	r0, #0
   16266:	f006 fa19 	bl	1c69c <SYS_CONSOLE_Print>
            break;
   1626a:	e7e5      	b.n	16238 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_NACK: SYS_CONSOLE_PRINT("DHCP_EVENT_NACK\n\r");
   1626c:	491a      	ldr	r1, [pc, #104]	; (162d8 <MONITOR_DHCP_eth_Handler+0xd0>)
   1626e:	2000      	movs	r0, #0
   16270:	f006 fa14 	bl	1c69c <SYS_CONSOLE_Print>
            break;
   16274:	e7e0      	b.n	16238 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_TIMEOUT: SYS_CONSOLE_PRINT("DHCP_EVENT_TIMEOUT\n\r");
   16276:	4919      	ldr	r1, [pc, #100]	; (162dc <MONITOR_DHCP_eth_Handler+0xd4>)
   16278:	2000      	movs	r0, #0
   1627a:	f006 fa0f 	bl	1c69c <SYS_CONSOLE_Print>
            break;
   1627e:	e7db      	b.n	16238 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_BOUND: SYS_CONSOLE_PRINT("DHCP_EVENT_BOUND\n\r");
   16280:	4917      	ldr	r1, [pc, #92]	; (162e0 <MONITOR_DHCP_eth_Handler+0xd8>)
   16282:	2000      	movs	r0, #0
   16284:	f006 fa0a 	bl	1c69c <SYS_CONSOLE_Print>
            break;
   16288:	e7d6      	b.n	16238 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_REQUEST_RENEW: SYS_CONSOLE_PRINT("DHCP_EVENT_REQUEST_RENEW\n\r");
   1628a:	4916      	ldr	r1, [pc, #88]	; (162e4 <MONITOR_DHCP_eth_Handler+0xdc>)
   1628c:	2000      	movs	r0, #0
   1628e:	f006 fa05 	bl	1c69c <SYS_CONSOLE_Print>
            break;
   16292:	e7d1      	b.n	16238 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_REQUEST_REBIND: SYS_CONSOLE_PRINT("DHCP_EVENT_REQUEST_REBIND\n\r");
   16294:	4914      	ldr	r1, [pc, #80]	; (162e8 <MONITOR_DHCP_eth_Handler+0xe0>)
   16296:	2000      	movs	r0, #0
   16298:	f006 fa00 	bl	1c69c <SYS_CONSOLE_Print>
            break;
   1629c:	e7cc      	b.n	16238 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_CONN_LOST: SYS_CONSOLE_PRINT("DHCP_EVENT_CONN_LOST\n\r");
   1629e:	4913      	ldr	r1, [pc, #76]	; (162ec <MONITOR_DHCP_eth_Handler+0xe4>)
   162a0:	2000      	movs	r0, #0
   162a2:	f006 f9fb 	bl	1c69c <SYS_CONSOLE_Print>
            break;
   162a6:	e7c7      	b.n	16238 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_CONN_ESTABLISHED: SYS_CONSOLE_PRINT("DHCP_EVENT_CONN_ESTABLISHED\n\r");
   162a8:	4911      	ldr	r1, [pc, #68]	; (162f0 <MONITOR_DHCP_eth_Handler+0xe8>)
   162aa:	2000      	movs	r0, #0
   162ac:	f006 f9f6 	bl	1c69c <SYS_CONSOLE_Print>
            break;
   162b0:	e7c2      	b.n	16238 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_SERVICE_DISABLED: SYS_CONSOLE_PRINT("DHCP_EVENT_SERVICE_DISABLED\n\r");
   162b2:	4910      	ldr	r1, [pc, #64]	; (162f4 <MONITOR_DHCP_eth_Handler+0xec>)
   162b4:	2000      	movs	r0, #0
   162b6:	f006 f9f1 	bl	1c69c <SYS_CONSOLE_Print>
}
   162ba:	e7bd      	b.n	16238 <MONITOR_DHCP_eth_Handler+0x30>
   162bc:	0000c430 	.word	0x0000c430
   162c0:	0000c438 	.word	0x0000c438
   162c4:	0000c44c 	.word	0x0000c44c
   162c8:	0000c464 	.word	0x0000c464
   162cc:	0000c47c 	.word	0x0000c47c
   162d0:	0000c490 	.word	0x0000c490
   162d4:	0000c4ac 	.word	0x0000c4ac
   162d8:	0000c4c4 	.word	0x0000c4c4
   162dc:	0000c4d8 	.word	0x0000c4d8
   162e0:	0000c4f0 	.word	0x0000c4f0
   162e4:	0000c504 	.word	0x0000c504
   162e8:	0000c520 	.word	0x0000c520
   162ec:	0000c53c 	.word	0x0000c53c
   162f0:	0000c554 	.word	0x0000c554
   162f4:	0000c574 	.word	0x0000c574

Disassembly of section .text._ARPProbeAddress%338:

000162f8 <_ARPProbeAddress>:
{
   162f8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   162fc:	b083      	sub	sp, #12
   162fe:	461c      	mov	r4, r3
    if((opType & ARP_OPERATION_PROBE_ONLY) != 0)
   16300:	f413 4f80 	tst.w	r3, #16384	; 0x4000
   16304:	d11c      	bne.n	16340 <_ARPProbeAddress+0x48>
   16306:	4606      	mov	r6, r0
   16308:	460d      	mov	r5, r1
   1630a:	4690      	mov	r8, r2
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   1630c:	4b33      	ldr	r3, [pc, #204]	; (163dc <_ARPProbeAddress+0xe4>)
   1630e:	685f      	ldr	r7, [r3, #4]
   16310:	f00d fe12 	bl	23f38 <TCPIP_STACK_NetIxGet>
   16314:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   16318:	00c0      	lsls	r0, r0, #3
   1631a:	eb07 0900 	add.w	r9, r7, r0
    hE = TCPIP_OAHASH_EntryLookupOrInsert(pArpDcpt->hashDcpt, &IPAddr->Val);
   1631e:	4629      	mov	r1, r5
   16320:	5838      	ldr	r0, [r7, r0]
   16322:	f006 fd2f 	bl	1cd84 <TCPIP_OAHASH_EntryLookupOrInsert>
    if(hE == 0)
   16326:	4605      	mov	r5, r0
   16328:	2800      	cmp	r0, #0
   1632a:	d053      	beq.n	163d4 <_ARPProbeAddress+0xdc>
    if(hE->flags.newEntry != 0)
   1632c:	7803      	ldrb	r3, [r0, #0]
   1632e:	f013 0f02 	tst.w	r3, #2
   16332:	d117      	bne.n	16364 <_ARPProbeAddress+0x6c>
    if((hE->flags.value & ARP_FLAG_ENTRY_VALID_MASK) != 0)
   16334:	8803      	ldrh	r3, [r0, #0]
   16336:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   1633a:	bb73      	cbnz	r3, 1639a <_ARPProbeAddress+0xa2>
    return ARP_RES_ENTRY_QUEUED;
   1633c:	2003      	movs	r0, #3
   1633e:	e00e      	b.n	1635e <_ARPProbeAddress+0x66>
        return _ARPSendIfPkt(pIf, (opType & ARP_OPERATION_MASK), (uint32_t)srcAddr->Val, (uint32_t)IPAddr->Val, &arpBcastAdd, 0) ? ARP_RES_PROBE_OK : ARP_RES_PROBE_FAILED;
   16340:	2300      	movs	r3, #0
   16342:	9301      	str	r3, [sp, #4]
   16344:	4b26      	ldr	r3, [pc, #152]	; (163e0 <_ARPProbeAddress+0xe8>)
   16346:	9300      	str	r3, [sp, #0]
   16348:	680b      	ldr	r3, [r1, #0]
   1634a:	6812      	ldr	r2, [r2, #0]
   1634c:	f004 010f 	and.w	r1, r4, #15
   16350:	f002 f8a8 	bl	184a4 <_ARPSendIfPkt>
   16354:	2800      	cmp	r0, #0
   16356:	bf14      	ite	ne
   16358:	2006      	movne	r0, #6
   1635a:	f06f 0008 	mvneq.w	r0, #8
}
   1635e:	b003      	add	sp, #12
   16360:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        ARP_ENTRY_FLAGS newFlags = (opType & ARP_OPERATION_CONFIGURE) != 0 ? ARP_FLAG_ENTRY_CONFIGURE : 0;
   16364:	1121      	asrs	r1, r4, #4
   16366:	f401 7180 	and.w	r1, r1, #256	; 0x100
        if((opType & ARP_OPERATION_GRATUITOUS) != 0) 
   1636a:	f414 5f00 	tst.w	r4, #8192	; 0x2000
            newFlags |= ARP_FLAG_ENTRY_GRATUITOUS;
   1636e:	bf18      	it	ne
   16370:	f441 7100 	orrne.w	r1, r1, #512	; 0x200
        _ARPSetEntry((ARP_HASH_ENTRY*)hE, newFlags, 0, &pArpDcpt->incompleteList);
   16374:	f109 032c 	add.w	r3, r9, #44	; 0x2c
   16378:	2200      	movs	r2, #0
   1637a:	f00a fb89 	bl	20a90 <_ARPSetEntry>
        _ARPSendIfPkt(pIf, (opType & ARP_OPERATION_MASK), (uint32_t)srcAddr->Val, ((ARP_HASH_ENTRY*)hE)->ipAddress.Val, &arpBcastAdd, 0);
   1637e:	68ab      	ldr	r3, [r5, #8]
   16380:	2200      	movs	r2, #0
   16382:	9201      	str	r2, [sp, #4]
   16384:	4a16      	ldr	r2, [pc, #88]	; (163e0 <_ARPProbeAddress+0xe8>)
   16386:	9200      	str	r2, [sp, #0]
   16388:	f8d8 2000 	ldr.w	r2, [r8]
   1638c:	f004 010f 	and.w	r1, r4, #15
   16390:	4630      	mov	r0, r6
   16392:	f002 f887 	bl	184a4 <_ARPSendIfPkt>
        return ARP_RES_ENTRY_NEW;
   16396:	2001      	movs	r0, #1
   16398:	e7e1      	b.n	1635e <_ARPProbeAddress+0x66>
        if(pHwAdd)
   1639a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1639c:	b123      	cbz	r3, 163a8 <_ARPProbeAddress+0xb0>
            *pHwAdd = arpHE->hwAdd;
   1639e:	6900      	ldr	r0, [r0, #16]
   163a0:	6018      	str	r0, [r3, #0]
   163a2:	8aab      	ldrh	r3, [r5, #20]
   163a4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   163a6:	8093      	strh	r3, [r2, #4]
        if((hE->flags.value & ARP_FLAG_ENTRY_COMPLETE) != 0 )
   163a8:	882b      	ldrh	r3, [r5, #0]
   163aa:	f013 0f80 	tst.w	r3, #128	; 0x80
   163ae:	d101      	bne.n	163b4 <_ARPProbeAddress+0xbc>
        return ARP_RES_ENTRY_SOLVED;
   163b0:	2002      	movs	r0, #2
   163b2:	e7d4      	b.n	1635e <_ARPProbeAddress+0x66>
            _ARPRefreshEntry(arpHE, &pArpDcpt->completeList);
   163b4:	f109 0918 	add.w	r9, r9, #24
    TCPIP_Helper_ProtectedSingleListNodeRemove(pL, (SGL_LIST_NODE*)&arpHE->next);
   163b8:	1d2c      	adds	r4, r5, #4
   163ba:	4621      	mov	r1, r4
   163bc:	4648      	mov	r0, r9
   163be:	f00a ffa5 	bl	2130c <TCPIP_Helper_ProtectedSingleListNodeRemove>
    arpHE->tInsert = arpMod.timeSeconds;
   163c2:	4b06      	ldr	r3, [pc, #24]	; (163dc <_ARPProbeAddress+0xe4>)
   163c4:	695b      	ldr	r3, [r3, #20]
   163c6:	60eb      	str	r3, [r5, #12]
    TCPIP_Helper_ProtectedSingleListTailAdd(pL, (SGL_LIST_NODE*)&arpHE->next);
   163c8:	4621      	mov	r1, r4
   163ca:	4648      	mov	r0, r9
   163cc:	f00b fcc7 	bl	21d5e <TCPIP_Helper_ProtectedSingleListTailAdd>
        return ARP_RES_ENTRY_SOLVED;
   163d0:	2002      	movs	r0, #2
   163d2:	e7c4      	b.n	1635e <_ARPProbeAddress+0x66>
        return ARP_RES_CACHE_FULL;
   163d4:	f06f 0001 	mvn.w	r0, #1
   163d8:	e7c1      	b.n	1635e <_ARPProbeAddress+0x66>
   163da:	bf00      	nop
   163dc:	2000e974 	.word	0x2000e974
   163e0:	2000ed9c 	.word	0x2000ed9c

Disassembly of section .text._DNS_GetAddresses%339:

000163e4 <_DNS_GetAddresses>:
{
   163e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   163e8:	f89d 7018 	ldrb.w	r7, [sp, #24]
    pDnsDcpt = pgDnsDcpt;
   163ec:	4c37      	ldr	r4, [pc, #220]	; (164cc <_DNS_GetAddresses+0xe8>)
   163ee:	6825      	ldr	r5, [r4, #0]
    if(pDnsDcpt == 0 || hostName == 0 || pIPAddr == 0 || nIPAddresses == 0)
   163f0:	2d00      	cmp	r5, #0
   163f2:	d057      	beq.n	164a4 <_DNS_GetAddresses+0xc0>
   163f4:	2800      	cmp	r0, #0
   163f6:	d057      	beq.n	164a8 <_DNS_GetAddresses+0xc4>
   163f8:	2a00      	cmp	r2, #0
   163fa:	d057      	beq.n	164ac <_DNS_GetAddresses+0xc8>
   163fc:	b913      	cbnz	r3, 16404 <_DNS_GetAddresses+0x20>
        return 0;
   163fe:	4618      	mov	r0, r3
}
   16400:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   16404:	461c      	mov	r4, r3
   16406:	4690      	mov	r8, r2
   16408:	460e      	mov	r6, r1
   1640a:	4601      	mov	r1, r0
    dnsHashEntry = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryLookup(pDnsDcpt->hashDcpt, hostName);
   1640c:	6828      	ldr	r0, [r5, #0]
   1640e:	f006 fab9 	bl	1c984 <TCPIP_OAHASH_EntryLookup>
    if(dnsHashEntry == 0 || (dnsHashEntry->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) == 0)
   16412:	4601      	mov	r1, r0
   16414:	2800      	cmp	r0, #0
   16416:	d04b      	beq.n	164b0 <_DNS_GetAddresses+0xcc>
   16418:	8803      	ldrh	r3, [r0, #0]
   1641a:	f013 0f80 	tst.w	r3, #128	; 0x80
   1641e:	d049      	beq.n	164b4 <_DNS_GetAddresses+0xd0>
    recMask &= (TCPIP_DNS_ADDRESS_REC_MASK)dnsHashEntry->recordMask;
   16420:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
    if(recMask == 0)
   16424:	401f      	ands	r7, r3
   16426:	d047      	beq.n	164b8 <_DNS_GetAddresses+0xd4>
    if(recMask == TCPIP_DNS_ADDRESS_REC_IPV4)
   16428:	2f01      	cmp	r7, #1
   1642a:	d020      	beq.n	1646e <_DNS_GetAddresses+0x8a>
        pDst6Addr = &pIPAddr->v6Add;
   1642c:	4642      	mov	r2, r8
        pSrc6Addr =  dnsHashEntry->pip6Address + startIndex;
   1642e:	46b6      	mov	lr, r6
   16430:	6943      	ldr	r3, [r0, #20]
   16432:	eb03 1306 	add.w	r3, r3, r6, lsl #4
        for(ix = startIndex; ix <= dnsHashEntry->nIPv6Entries && nAddrs < nIPAddresses; ix++, nAddrs++, pDst6Addr++)
   16436:	f890 0027 	ldrb.w	r0, [r0, #39]	; 0x27
   1643a:	4286      	cmp	r6, r0
   1643c:	dc42      	bgt.n	164c4 <_DNS_GetAddresses+0xe0>
   1643e:	2c00      	cmp	r4, #0
   16440:	dd42      	ble.n	164c8 <_DNS_GetAddresses+0xe4>
    nAddrs = 0;
   16442:	2000      	movs	r0, #0
            memcpy(pDst6Addr->v, pSrc6Addr->v, sizeof(*pDst6Addr));
   16444:	f8d3 c000 	ldr.w	ip, [r3]
   16448:	685f      	ldr	r7, [r3, #4]
   1644a:	689e      	ldr	r6, [r3, #8]
   1644c:	68dd      	ldr	r5, [r3, #12]
   1644e:	f8c2 c000 	str.w	ip, [r2]
   16452:	6057      	str	r7, [r2, #4]
   16454:	6096      	str	r6, [r2, #8]
   16456:	60d5      	str	r5, [r2, #12]
        for(ix = startIndex; ix <= dnsHashEntry->nIPv6Entries && nAddrs < nIPAddresses; ix++, nAddrs++, pDst6Addr++)
   16458:	3001      	adds	r0, #1
   1645a:	3210      	adds	r2, #16
   1645c:	f891 6027 	ldrb.w	r6, [r1, #39]	; 0x27
   16460:	eb00 050e 	add.w	r5, r0, lr
   16464:	42ae      	cmp	r6, r5
   16466:	dbcb      	blt.n	16400 <_DNS_GetAddresses+0x1c>
   16468:	4284      	cmp	r4, r0
   1646a:	d1eb      	bne.n	16444 <_DNS_GetAddresses+0x60>
   1646c:	e7c8      	b.n	16400 <_DNS_GetAddresses+0x1c>
        pSrc4Addr =  dnsHashEntry->pip4Address + startIndex;
   1646e:	6903      	ldr	r3, [r0, #16]
   16470:	4637      	mov	r7, r6
   16472:	00b2      	lsls	r2, r6, #2
        for(ix = startIndex; ix <= dnsHashEntry->nIPv4Entries && nAddrs < nIPAddresses; ix++, nAddrs++, pDst4Addr++, pSrc4Addr++)
   16474:	f890 0026 	ldrb.w	r0, [r0, #38]	; 0x26
   16478:	4286      	cmp	r6, r0
   1647a:	dc1f      	bgt.n	164bc <_DNS_GetAddresses+0xd8>
   1647c:	2c00      	cmp	r4, #0
   1647e:	dd1f      	ble.n	164c0 <_DNS_GetAddresses+0xdc>
   16480:	3a04      	subs	r2, #4
   16482:	4413      	add	r3, r2
   16484:	f1a8 0204 	sub.w	r2, r8, #4
    nAddrs = 0;
   16488:	2000      	movs	r0, #0
            pDst4Addr->Val = pSrc4Addr->Val;
   1648a:	f853 5f04 	ldr.w	r5, [r3, #4]!
   1648e:	f842 5f04 	str.w	r5, [r2, #4]!
        for(ix = startIndex; ix <= dnsHashEntry->nIPv4Entries && nAddrs < nIPAddresses; ix++, nAddrs++, pDst4Addr++, pSrc4Addr++)
   16492:	3001      	adds	r0, #1
   16494:	f891 6026 	ldrb.w	r6, [r1, #38]	; 0x26
   16498:	19c5      	adds	r5, r0, r7
   1649a:	42ae      	cmp	r6, r5
   1649c:	dbb0      	blt.n	16400 <_DNS_GetAddresses+0x1c>
   1649e:	4284      	cmp	r4, r0
   164a0:	d1f3      	bne.n	1648a <_DNS_GetAddresses+0xa6>
   164a2:	e7ad      	b.n	16400 <_DNS_GetAddresses+0x1c>
        return 0;
   164a4:	2000      	movs	r0, #0
   164a6:	e7ab      	b.n	16400 <_DNS_GetAddresses+0x1c>
   164a8:	2000      	movs	r0, #0
   164aa:	e7a9      	b.n	16400 <_DNS_GetAddresses+0x1c>
   164ac:	2000      	movs	r0, #0
   164ae:	e7a7      	b.n	16400 <_DNS_GetAddresses+0x1c>
        return 0;
   164b0:	2000      	movs	r0, #0
   164b2:	e7a5      	b.n	16400 <_DNS_GetAddresses+0x1c>
   164b4:	2000      	movs	r0, #0
   164b6:	e7a3      	b.n	16400 <_DNS_GetAddresses+0x1c>
        return 0; 
   164b8:	2000      	movs	r0, #0
   164ba:	e7a1      	b.n	16400 <_DNS_GetAddresses+0x1c>
    nAddrs = 0;
   164bc:	2000      	movs	r0, #0
   164be:	e79f      	b.n	16400 <_DNS_GetAddresses+0x1c>
   164c0:	2000      	movs	r0, #0
   164c2:	e79d      	b.n	16400 <_DNS_GetAddresses+0x1c>
   164c4:	2000      	movs	r0, #0
   164c6:	e79b      	b.n	16400 <_DNS_GetAddresses+0x1c>
   164c8:	2000      	movs	r0, #0
   164ca:	e799      	b.n	16400 <_DNS_GetAddresses+0x1c>
   164cc:	2000ee58 	.word	0x2000ee58

Disassembly of section .text._strtol_l.isra.0%340:

000164d0 <_strtol_l.isra.0>:
   164d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   164d4:	4f38      	ldr	r7, [pc, #224]	; (165b8 <_strtol_l.isra.0+0xe8>)
   164d6:	4686      	mov	lr, r0
   164d8:	4608      	mov	r0, r1
   164da:	4605      	mov	r5, r0
   164dc:	f815 4b01 	ldrb.w	r4, [r5], #1
   164e0:	5de6      	ldrb	r6, [r4, r7]
   164e2:	f016 0608 	ands.w	r6, r6, #8
   164e6:	d136      	bne.n	16556 <_strtol_l.isra.0+0x86>
   164e8:	2c2d      	cmp	r4, #45	; 0x2d
   164ea:	d136      	bne.n	1655a <_strtol_l.isra.0+0x8a>
   164ec:	782c      	ldrb	r4, [r5, #0]
   164ee:	2601      	movs	r6, #1
   164f0:	1c85      	adds	r5, r0, #2
   164f2:	2b00      	cmp	r3, #0
   164f4:	d05c      	beq.n	165b0 <_strtol_l.isra.0+0xe0>
   164f6:	2b10      	cmp	r3, #16
   164f8:	d109      	bne.n	1650e <_strtol_l.isra.0+0x3e>
   164fa:	2c30      	cmp	r4, #48	; 0x30
   164fc:	d107      	bne.n	1650e <_strtol_l.isra.0+0x3e>
   164fe:	7828      	ldrb	r0, [r5, #0]
   16500:	f000 00df 	and.w	r0, r0, #223	; 0xdf
   16504:	2858      	cmp	r0, #88	; 0x58
   16506:	d14e      	bne.n	165a6 <_strtol_l.isra.0+0xd6>
   16508:	786c      	ldrb	r4, [r5, #1]
   1650a:	2310      	movs	r3, #16
   1650c:	3502      	adds	r5, #2
   1650e:	2e00      	cmp	r6, #0
   16510:	bf14      	ite	ne
   16512:	f04f 4c00 	movne.w	ip, #2147483648	; 0x80000000
   16516:	f06f 4c00 	mvneq.w	ip, #2147483648	; 0x80000000
   1651a:	2700      	movs	r7, #0
   1651c:	fbbc f8f3 	udiv	r8, ip, r3
   16520:	4638      	mov	r0, r7
   16522:	fb03 ca18 	mls	sl, r3, r8, ip
   16526:	f04f 39ff 	mov.w	r9, #4294967295
   1652a:	f1a4 0b30 	sub.w	fp, r4, #48	; 0x30
   1652e:	f1bb 0f09 	cmp.w	fp, #9
   16532:	d817      	bhi.n	16564 <_strtol_l.isra.0+0x94>
   16534:	465c      	mov	r4, fp
   16536:	42a3      	cmp	r3, r4
   16538:	dd24      	ble.n	16584 <_strtol_l.isra.0+0xb4>
   1653a:	f1b7 3fff 	cmp.w	r7, #4294967295
   1653e:	d007      	beq.n	16550 <_strtol_l.isra.0+0x80>
   16540:	4580      	cmp	r8, r0
   16542:	d31d      	bcc.n	16580 <_strtol_l.isra.0+0xb0>
   16544:	d101      	bne.n	1654a <_strtol_l.isra.0+0x7a>
   16546:	45a2      	cmp	sl, r4
   16548:	db1a      	blt.n	16580 <_strtol_l.isra.0+0xb0>
   1654a:	fb00 4003 	mla	r0, r0, r3, r4
   1654e:	2701      	movs	r7, #1
   16550:	f815 4b01 	ldrb.w	r4, [r5], #1
   16554:	e7e9      	b.n	1652a <_strtol_l.isra.0+0x5a>
   16556:	4628      	mov	r0, r5
   16558:	e7bf      	b.n	164da <_strtol_l.isra.0+0xa>
   1655a:	2c2b      	cmp	r4, #43	; 0x2b
   1655c:	bf04      	itt	eq
   1655e:	782c      	ldrbeq	r4, [r5, #0]
   16560:	1c85      	addeq	r5, r0, #2
   16562:	e7c6      	b.n	164f2 <_strtol_l.isra.0+0x22>
   16564:	f1a4 0b41 	sub.w	fp, r4, #65	; 0x41
   16568:	f1bb 0f19 	cmp.w	fp, #25
   1656c:	d801      	bhi.n	16572 <_strtol_l.isra.0+0xa2>
   1656e:	3c37      	subs	r4, #55	; 0x37
   16570:	e7e1      	b.n	16536 <_strtol_l.isra.0+0x66>
   16572:	f1a4 0b61 	sub.w	fp, r4, #97	; 0x61
   16576:	f1bb 0f19 	cmp.w	fp, #25
   1657a:	d803      	bhi.n	16584 <_strtol_l.isra.0+0xb4>
   1657c:	3c57      	subs	r4, #87	; 0x57
   1657e:	e7da      	b.n	16536 <_strtol_l.isra.0+0x66>
   16580:	464f      	mov	r7, r9
   16582:	e7e5      	b.n	16550 <_strtol_l.isra.0+0x80>
   16584:	1c7b      	adds	r3, r7, #1
   16586:	d106      	bne.n	16596 <_strtol_l.isra.0+0xc6>
   16588:	2322      	movs	r3, #34	; 0x22
   1658a:	f8ce 3000 	str.w	r3, [lr]
   1658e:	4660      	mov	r0, ip
   16590:	b932      	cbnz	r2, 165a0 <_strtol_l.isra.0+0xd0>
   16592:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   16596:	b106      	cbz	r6, 1659a <_strtol_l.isra.0+0xca>
   16598:	4240      	negs	r0, r0
   1659a:	2a00      	cmp	r2, #0
   1659c:	d0f9      	beq.n	16592 <_strtol_l.isra.0+0xc2>
   1659e:	b107      	cbz	r7, 165a2 <_strtol_l.isra.0+0xd2>
   165a0:	1e69      	subs	r1, r5, #1
   165a2:	6011      	str	r1, [r2, #0]
   165a4:	e7f5      	b.n	16592 <_strtol_l.isra.0+0xc2>
   165a6:	2430      	movs	r4, #48	; 0x30
   165a8:	2b00      	cmp	r3, #0
   165aa:	d1b0      	bne.n	1650e <_strtol_l.isra.0+0x3e>
   165ac:	2308      	movs	r3, #8
   165ae:	e7ae      	b.n	1650e <_strtol_l.isra.0+0x3e>
   165b0:	2c30      	cmp	r4, #48	; 0x30
   165b2:	d0a4      	beq.n	164fe <_strtol_l.isra.0+0x2e>
   165b4:	230a      	movs	r3, #10
   165b6:	e7aa      	b.n	1650e <_strtol_l.isra.0+0x3e>
   165b8:	00015855 	.word	0x00015855

Disassembly of section .text._printf_common%341:

000165bc <_printf_common>:
   165bc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   165c0:	4691      	mov	r9, r2
   165c2:	461f      	mov	r7, r3
   165c4:	688a      	ldr	r2, [r1, #8]
   165c6:	690b      	ldr	r3, [r1, #16]
   165c8:	f8dd 8020 	ldr.w	r8, [sp, #32]
   165cc:	4293      	cmp	r3, r2
   165ce:	bfb8      	it	lt
   165d0:	4613      	movlt	r3, r2
   165d2:	f8c9 3000 	str.w	r3, [r9]
   165d6:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
   165da:	4606      	mov	r6, r0
   165dc:	460c      	mov	r4, r1
   165de:	b112      	cbz	r2, 165e6 <_printf_common+0x2a>
   165e0:	3301      	adds	r3, #1
   165e2:	f8c9 3000 	str.w	r3, [r9]
   165e6:	6823      	ldr	r3, [r4, #0]
   165e8:	0699      	lsls	r1, r3, #26
   165ea:	bf42      	ittt	mi
   165ec:	f8d9 3000 	ldrmi.w	r3, [r9]
   165f0:	3302      	addmi	r3, #2
   165f2:	f8c9 3000 	strmi.w	r3, [r9]
   165f6:	6825      	ldr	r5, [r4, #0]
   165f8:	f015 0506 	ands.w	r5, r5, #6
   165fc:	d107      	bne.n	1660e <_printf_common+0x52>
   165fe:	f104 0a19 	add.w	sl, r4, #25
   16602:	68e3      	ldr	r3, [r4, #12]
   16604:	f8d9 2000 	ldr.w	r2, [r9]
   16608:	1a9b      	subs	r3, r3, r2
   1660a:	42ab      	cmp	r3, r5
   1660c:	dc28      	bgt.n	16660 <_printf_common+0xa4>
   1660e:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   16612:	6822      	ldr	r2, [r4, #0]
   16614:	3300      	adds	r3, #0
   16616:	bf18      	it	ne
   16618:	2301      	movne	r3, #1
   1661a:	0692      	lsls	r2, r2, #26
   1661c:	d42d      	bmi.n	1667a <_printf_common+0xbe>
   1661e:	f104 0243 	add.w	r2, r4, #67	; 0x43
   16622:	4639      	mov	r1, r7
   16624:	4630      	mov	r0, r6
   16626:	47c0      	blx	r8
   16628:	3001      	adds	r0, #1
   1662a:	d020      	beq.n	1666e <_printf_common+0xb2>
   1662c:	6823      	ldr	r3, [r4, #0]
   1662e:	68e5      	ldr	r5, [r4, #12]
   16630:	f8d9 2000 	ldr.w	r2, [r9]
   16634:	f003 0306 	and.w	r3, r3, #6
   16638:	2b04      	cmp	r3, #4
   1663a:	bf08      	it	eq
   1663c:	1aad      	subeq	r5, r5, r2
   1663e:	68a3      	ldr	r3, [r4, #8]
   16640:	6922      	ldr	r2, [r4, #16]
   16642:	bf0c      	ite	eq
   16644:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
   16648:	2500      	movne	r5, #0
   1664a:	4293      	cmp	r3, r2
   1664c:	bfc4      	itt	gt
   1664e:	1a9b      	subgt	r3, r3, r2
   16650:	18ed      	addgt	r5, r5, r3
   16652:	f04f 0900 	mov.w	r9, #0
   16656:	341a      	adds	r4, #26
   16658:	454d      	cmp	r5, r9
   1665a:	d11a      	bne.n	16692 <_printf_common+0xd6>
   1665c:	2000      	movs	r0, #0
   1665e:	e008      	b.n	16672 <_printf_common+0xb6>
   16660:	2301      	movs	r3, #1
   16662:	4652      	mov	r2, sl
   16664:	4639      	mov	r1, r7
   16666:	4630      	mov	r0, r6
   16668:	47c0      	blx	r8
   1666a:	3001      	adds	r0, #1
   1666c:	d103      	bne.n	16676 <_printf_common+0xba>
   1666e:	f04f 30ff 	mov.w	r0, #4294967295
   16672:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   16676:	3501      	adds	r5, #1
   16678:	e7c3      	b.n	16602 <_printf_common+0x46>
   1667a:	18e1      	adds	r1, r4, r3
   1667c:	1c5a      	adds	r2, r3, #1
   1667e:	2030      	movs	r0, #48	; 0x30
   16680:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
   16684:	4422      	add	r2, r4
   16686:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
   1668a:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
   1668e:	3302      	adds	r3, #2
   16690:	e7c5      	b.n	1661e <_printf_common+0x62>
   16692:	2301      	movs	r3, #1
   16694:	4622      	mov	r2, r4
   16696:	4639      	mov	r1, r7
   16698:	4630      	mov	r0, r6
   1669a:	47c0      	blx	r8
   1669c:	3001      	adds	r0, #1
   1669e:	d0e6      	beq.n	1666e <_printf_common+0xb2>
   166a0:	f109 0901 	add.w	r9, r9, #1
   166a4:	e7d8      	b.n	16658 <_printf_common+0x9c>

Disassembly of section .text.DRV_PIC32CGMAC_LibTxSendPacket%342:

000166a8 <DRV_PIC32CGMAC_LibTxSendPacket>:
{
   166a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	DRV_PIC32CGMAC_HW_TXDCPT *pTxDesc = pMACDrv->sGmacData.gmac_queue[queueIdx].pTxDesc;
   166ac:	232c      	movs	r3, #44	; 0x2c
   166ae:	fb03 0302 	mla	r3, r3, r2, r0
   166b2:	f8d3 70a0 	ldr.w	r7, [r3, #160]	; 0xa0
	uint16_t wTxIndex = pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescHead ;
   166b6:	f8b3 30b2 	ldrh.w	r3, [r3, #178]	; 0xb2
	uint16_t wTxDescCount =pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt;
   166ba:	eb02 04c2 	add.w	r4, r2, r2, lsl #3
   166be:	eb00 0444 	add.w	r4, r0, r4, lsl #1
   166c2:	f8b4 c0c8 	ldrh.w	ip, [r4, #200]	; 0xc8
    while (pPktDSeg)
   166c6:	b371      	cbz	r1, 16726 <DRV_PIC32CGMAC_LibTxSendPacket+0x7e>
   166c8:	460d      	mov	r5, r1
    uint8_t nLoopCnt =0;
   166ca:	2400      	movs	r4, #0
        if((_DRV_GMAC_DescSpace(wTxIndex, pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail, wTxDescCount)) &&
   166cc:	f04f 0e2c 	mov.w	lr, #44	; 0x2c
   166d0:	fb0e 0e02 	mla	lr, lr, r2, r0
   166d4:	e01d      	b.n	16712 <DRV_PIC32CGMAC_LibTxSendPacket+0x6a>
           (pTxDesc[wTxIndex].tx_desc_buffaddr == 0))
   166d6:	eb07 06c3 	add.w	r6, r7, r3, lsl #3
   166da:	f857 1033 	ldr.w	r1, [r7, r3, lsl #3]
        if((_DRV_GMAC_DescSpace(wTxIndex, pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail, wTxDescCount)) &&
   166de:	2900      	cmp	r1, #0
   166e0:	d152      	bne.n	16788 <DRV_PIC32CGMAC_LibTxSendPacket+0xe0>
            pTxDesc[wTxIndex].tx_desc_status.val &= (GMAC_TX_WRAP_BIT |GMAC_TX_USED_BIT); //clear all Tx Status except Wrap Bit and Used Bit
   166e2:	6871      	ldr	r1, [r6, #4]
   166e4:	f001 4140 	and.w	r1, r1, #3221225472	; 0xc0000000
   166e8:	6071      	str	r1, [r6, #4]
            pTxDesc[wTxIndex].tx_desc_buffaddr = (uint32_t)((uint8_t *)pPktDSeg->segLoad);	//set the buffer address
   166ea:	68a9      	ldr	r1, [r5, #8]
   166ec:	f847 1033 	str.w	r1, [r7, r3, lsl #3]
            pTxDesc[wTxIndex].tx_desc_status.val |= (pPktDSeg->segLen) & GMAC_LENGTH_FRAME; //Set Length for each frame
   166f0:	f8d6 8004 	ldr.w	r8, [r6, #4]
   166f4:	89a9      	ldrh	r1, [r5, #12]
   166f6:	f3c1 010d 	ubfx	r1, r1, #0, #14
   166fa:	ea41 0108 	orr.w	r1, r1, r8
   166fe:	6071      	str	r1, [r6, #4]
            GCIRC_INC(wTxIndex,wTxDescCount); //Increment the index of Tx Desc
   16700:	3301      	adds	r3, #1
   16702:	b29b      	uxth	r3, r3
   16704:	459c      	cmp	ip, r3
   16706:	bf98      	it	ls
   16708:	2300      	movls	r3, #0
            pPktDSeg = pPktDSeg->next;
   1670a:	682d      	ldr	r5, [r5, #0]
            nLoopCnt++;
   1670c:	3401      	adds	r4, #1
   1670e:	b2e4      	uxtb	r4, r4
    while (pPktDSeg)
   16710:	b155      	cbz	r5, 16728 <DRV_PIC32CGMAC_LibTxSendPacket+0x80>
        if((_DRV_GMAC_DescSpace(wTxIndex, pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail, wTxDescCount)) &&
   16712:	f8be 10b4 	ldrh.w	r1, [lr, #180]	; 0xb4
    return (tail > head)? (tail - head) : (size - head + tail);
   16716:	4299      	cmp	r1, r3
   16718:	d8dd      	bhi.n	166d6 <DRV_PIC32CGMAC_LibTxSendPacket+0x2e>
   1671a:	4461      	add	r1, ip
   1671c:	b289      	uxth	r1, r1
   1671e:	4299      	cmp	r1, r3
   16720:	d1d9      	bne.n	166d6 <DRV_PIC32CGMAC_LibTxSendPacket+0x2e>
            return DRV_PIC32CGMAC_RES_NO_DESCRIPTORS;
   16722:	2003      	movs	r0, #3
   16724:	e02e      	b.n	16784 <DRV_PIC32CGMAC_LibTxSendPacket+0xdc>
    uint8_t nLoopCnt =0;
   16726:	2400      	movs	r4, #0
    pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescHead = wTxIndex;
   16728:	212c      	movs	r1, #44	; 0x2c
   1672a:	fb01 0002 	mla	r0, r1, r2, r0
   1672e:	f8a0 30b2 	strh.w	r3, [r0, #178]	; 0xb2
    GCIRC_DEC(wTxIndex,wTxDescCount);
   16732:	b973      	cbnz	r3, 16752 <DRV_PIC32CGMAC_LibTxSendPacket+0xaa>
   16734:	f10c 33ff 	add.w	r3, ip, #4294967295
   16738:	b29b      	uxth	r3, r3
    pTxDesc[wTxIndex].tx_desc_status.val |= GMAC_TX_LAST_BUFFER_BIT;
   1673a:	eb07 01c3 	add.w	r1, r7, r3, lsl #3
   1673e:	684a      	ldr	r2, [r1, #4]
   16740:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
   16744:	604a      	str	r2, [r1, #4]
    while(nLoopCnt)
   16746:	b1bc      	cbz	r4, 16778 <DRV_PIC32CGMAC_LibTxSendPacket+0xd0>
        GCIRC_DEC(wTxIndex,wTxDescCount);
   16748:	f10c 3cff 	add.w	ip, ip, #4294967295
   1674c:	fa1f fc8c 	uxth.w	ip, ip
   16750:	e008      	b.n	16764 <DRV_PIC32CGMAC_LibTxSendPacket+0xbc>
    GCIRC_DEC(wTxIndex,wTxDescCount);
   16752:	3b01      	subs	r3, #1
   16754:	b29b      	uxth	r3, r3
   16756:	e7f0      	b.n	1673a <DRV_PIC32CGMAC_LibTxSendPacket+0x92>
        GCIRC_DEC(wTxIndex,wTxDescCount);
   16758:	3b01      	subs	r3, #1
   1675a:	b29b      	uxth	r3, r3
        nLoopCnt--;
   1675c:	3c01      	subs	r4, #1
    while(nLoopCnt)
   1675e:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
   16762:	d009      	beq.n	16778 <DRV_PIC32CGMAC_LibTxSendPacket+0xd0>
        pTxDesc[wTxIndex].tx_desc_status.val &= ~GMAC_TX_USED_BIT;
   16764:	eb07 01c3 	add.w	r1, r7, r3, lsl #3
   16768:	684a      	ldr	r2, [r1, #4]
   1676a:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
   1676e:	604a      	str	r2, [r1, #4]
        GCIRC_DEC(wTxIndex,wTxDescCount);
   16770:	2b00      	cmp	r3, #0
   16772:	d1f1      	bne.n	16758 <DRV_PIC32CGMAC_LibTxSendPacket+0xb0>
   16774:	4663      	mov	r3, ip
   16776:	e7f1      	b.n	1675c <DRV_PIC32CGMAC_LibTxSendPacket+0xb4>
    GMAC_REGS->GMAC_NCR |= GMAC_NCR_TSTART_Msk;	
   16778:	4a04      	ldr	r2, [pc, #16]	; (1678c <DRV_PIC32CGMAC_LibTxSendPacket+0xe4>)
   1677a:	6813      	ldr	r3, [r2, #0]
   1677c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   16780:	6013      	str	r3, [r2, #0]
	return DRV_PIC32CGMAC_RES_OK;
   16782:	2000      	movs	r0, #0
} //DRV_PIC32CGMAC_LibTxSendPacket
   16784:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            return DRV_PIC32CGMAC_RES_NO_DESCRIPTORS;
   16788:	2003      	movs	r0, #3
   1678a:	e7fb      	b.n	16784 <DRV_PIC32CGMAC_LibTxSendPacket+0xdc>
   1678c:	42000800 	.word	0x42000800

Disassembly of section .text._Command_IPAddressSet%343:

00016790 <_Command_IPAddressSet>:
{
   16790:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   16794:	b082      	sub	sp, #8
   16796:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   16798:	6845      	ldr	r5, [r0, #4]
    if (argc < 3)
   1679a:	2902      	cmp	r1, #2
   1679c:	dc10      	bgt.n	167c0 <_Command_IPAddressSet+0x30>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: setip <interface> <ipv4/6 address> <ipv4mask/ipv6 prefix len>\r\n");
   1679e:	4e2f      	ldr	r6, [pc, #188]	; (1685c <_Command_IPAddressSet+0xcc>)
   167a0:	6803      	ldr	r3, [r0, #0]
   167a2:	681b      	ldr	r3, [r3, #0]
   167a4:	f506 616a 	add.w	r1, r6, #3744	; 0xea0
   167a8:	4628      	mov	r0, r5
   167aa:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: setip PIC32INT 192.168.0.8 255.255.255.0 \r\n");
   167ac:	6823      	ldr	r3, [r4, #0]
   167ae:	681b      	ldr	r3, [r3, #0]
   167b0:	f606 61e8 	addw	r1, r6, #3816	; 0xee8
   167b4:	4628      	mov	r0, r5
   167b6:	4798      	blx	r3
}
   167b8:	2000      	movs	r0, #0
   167ba:	b002      	add	sp, #8
   167bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   167c0:	460e      	mov	r6, r1
   167c2:	4617      	mov	r7, r2
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
   167c4:	6850      	ldr	r0, [r2, #4]
   167c6:	f009 f94d 	bl	1fa64 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
   167ca:	4680      	mov	r8, r0
   167cc:	b150      	cbz	r0, 167e4 <_Command_IPAddressSet+0x54>
   167ce:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   167d2:	f013 0f40 	tst.w	r3, #64	; 0x40
   167d6:	d10b      	bne.n	167f0 <_Command_IPAddressSet+0x60>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "No such interface is up\r\n");
   167d8:	6823      	ldr	r3, [r4, #0]
   167da:	681b      	ldr	r3, [r3, #0]
   167dc:	4920      	ldr	r1, [pc, #128]	; (16860 <_Command_IPAddressSet+0xd0>)
   167de:	4628      	mov	r0, r5
   167e0:	4798      	blx	r3
        return false;
   167e2:	e7e9      	b.n	167b8 <_Command_IPAddressSet+0x28>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   167e4:	6823      	ldr	r3, [r4, #0]
   167e6:	681b      	ldr	r3, [r3, #0]
   167e8:	491e      	ldr	r1, [pc, #120]	; (16864 <_Command_IPAddressSet+0xd4>)
   167ea:	4628      	mov	r0, r5
   167ec:	4798      	blx	r3
        return false;
   167ee:	e7e3      	b.n	167b8 <_Command_IPAddressSet+0x28>
    if (TCPIP_Helper_StringToIPAddress(argv[2], &ipAddr))
   167f0:	a901      	add	r1, sp, #4
   167f2:	68b8      	ldr	r0, [r7, #8]
   167f4:	f7fe f93c 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
   167f8:	b928      	cbnz	r0, 16806 <_Command_IPAddressSet+0x76>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Invalid IP address string \r\n");
   167fa:	6823      	ldr	r3, [r4, #0]
   167fc:	681b      	ldr	r3, [r3, #0]
   167fe:	491a      	ldr	r1, [pc, #104]	; (16868 <_Command_IPAddressSet+0xd8>)
   16800:	4628      	mov	r0, r5
   16802:	4798      	blx	r3
        return false;
   16804:	e7d8      	b.n	167b8 <_Command_IPAddressSet+0x28>
        if(_TCPIPStackAddressServiceIsRunning(pNetIf) != TCPIP_STACK_ADDRESS_SERVICE_NONE)
   16806:	4640      	mov	r0, r8
   16808:	f00d fda4 	bl	24354 <_TCPIPStackAddressServiceIsRunning>
   1680c:	b940      	cbnz	r0, 16820 <_Command_IPAddressSet+0x90>
        if(argc > 3)
   1680e:	2e03      	cmp	r6, #3
   16810:	dd12      	ble.n	16838 <_Command_IPAddressSet+0xa8>
            if (!TCPIP_Helper_StringToIPAddress(argv[3], &ipMask))
   16812:	4669      	mov	r1, sp
   16814:	68f8      	ldr	r0, [r7, #12]
   16816:	f7fe f92b 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
   1681a:	b138      	cbz	r0, 1682c <_Command_IPAddressSet+0x9c>
            pMask = &ipMask;
   1681c:	466a      	mov	r2, sp
   1681e:	e00c      	b.n	1683a <_Command_IPAddressSet+0xaa>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "An address service is already running. Stop DHCP, ZCLL, etc. first\r\n");
   16820:	6823      	ldr	r3, [r4, #0]
   16822:	681b      	ldr	r3, [r3, #0]
   16824:	4911      	ldr	r1, [pc, #68]	; (1686c <_Command_IPAddressSet+0xdc>)
   16826:	4628      	mov	r0, r5
   16828:	4798      	blx	r3
            return false;
   1682a:	e7c5      	b.n	167b8 <_Command_IPAddressSet+0x28>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Invalid IP mask string \r\n");
   1682c:	6823      	ldr	r3, [r4, #0]
   1682e:	681b      	ldr	r3, [r3, #0]
   16830:	490f      	ldr	r1, [pc, #60]	; (16870 <_Command_IPAddressSet+0xe0>)
   16832:	4628      	mov	r0, r5
   16834:	4798      	blx	r3
                return false;
   16836:	e7bf      	b.n	167b8 <_Command_IPAddressSet+0x28>
            pMask = 0;
   16838:	2200      	movs	r2, #0
        if(TCPIP_STACK_NetAddressSet(netH, &ipAddr, pMask, true))
   1683a:	2301      	movs	r3, #1
   1683c:	a901      	add	r1, sp, #4
   1683e:	4640      	mov	r0, r8
   16840:	f004 f91e 	bl	1aa80 <TCPIP_STACK_NetAddressSet>
    (*pCmdIO->pCmdApi->msg)(cmdIoParam, success ? "Set ip address OK\r\n" : "Set ip address failed\r\n");
   16844:	6823      	ldr	r3, [r4, #0]
   16846:	681b      	ldr	r3, [r3, #0]
   16848:	2800      	cmp	r0, #0
   1684a:	490a      	ldr	r1, [pc, #40]	; (16874 <_Command_IPAddressSet+0xe4>)
   1684c:	f101 0214 	add.w	r2, r1, #20
   16850:	bf08      	it	eq
   16852:	4611      	moveq	r1, r2
   16854:	4628      	mov	r0, r5
   16856:	4798      	blx	r3
    return false;
   16858:	e7ae      	b.n	167b8 <_Command_IPAddressSet+0x28>
   1685a:	bf00      	nop
   1685c:	0000028c 	.word	0x0000028c
   16860:	000011a4 	.word	0x000011a4
   16864:	00000b80 	.word	0x00000b80
   16868:	000010e0 	.word	0x000010e0
   1686c:	000011c0 	.word	0x000011c0
   16870:	00001208 	.word	0x00001208
   16874:	00001100 	.word	0x00001100

Disassembly of section .text.xTaskResumeAll%344:

00016878 <xTaskResumeAll>:
{
   16878:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	taskENTER_CRITICAL();
   1687c:	f00c fa80 	bl	22d80 <vPortEnterCritical>
		--uxSchedulerSuspended;
   16880:	4b2d      	ldr	r3, [pc, #180]	; (16938 <xTaskResumeAll+0xc0>)
   16882:	681a      	ldr	r2, [r3, #0]
   16884:	3a01      	subs	r2, #1
   16886:	601a      	str	r2, [r3, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   16888:	681b      	ldr	r3, [r3, #0]
   1688a:	2b00      	cmp	r3, #0
   1688c:	d14d      	bne.n	1692a <xTaskResumeAll+0xb2>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   1688e:	4b2b      	ldr	r3, [pc, #172]	; (1693c <xTaskResumeAll+0xc4>)
   16890:	681b      	ldr	r3, [r3, #0]
   16892:	b90b      	cbnz	r3, 16898 <xTaskResumeAll+0x20>
BaseType_t xAlreadyYielded = pdFALSE;
   16894:	2400      	movs	r4, #0
   16896:	e049      	b.n	1692c <xTaskResumeAll+0xb4>
TCB_t *pxTCB = NULL;
   16898:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   1689a:	4e29      	ldr	r6, [pc, #164]	; (16940 <xTaskResumeAll+0xc8>)
					prvAddTaskToReadyList( pxTCB );
   1689c:	4f29      	ldr	r7, [pc, #164]	; (16944 <xTaskResumeAll+0xcc>)
   1689e:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 16958 <xTaskResumeAll+0xe0>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   168a2:	6833      	ldr	r3, [r6, #0]
   168a4:	b303      	cbz	r3, 168e8 <xTaskResumeAll+0x70>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   168a6:	68f3      	ldr	r3, [r6, #12]
   168a8:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   168aa:	f104 0018 	add.w	r0, r4, #24
   168ae:	f00b ff39 	bl	22724 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   168b2:	1d25      	adds	r5, r4, #4
   168b4:	4628      	mov	r0, r5
   168b6:	f00b ff35 	bl	22724 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   168ba:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   168bc:	683a      	ldr	r2, [r7, #0]
   168be:	2301      	movs	r3, #1
   168c0:	4083      	lsls	r3, r0
   168c2:	4313      	orrs	r3, r2
   168c4:	603b      	str	r3, [r7, #0]
   168c6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   168ca:	4629      	mov	r1, r5
   168cc:	eb08 0080 	add.w	r0, r8, r0, lsl #2
   168d0:	f00d f8a0 	bl	23a14 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   168d4:	4b1c      	ldr	r3, [pc, #112]	; (16948 <xTaskResumeAll+0xd0>)
   168d6:	681b      	ldr	r3, [r3, #0]
   168d8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   168da:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   168dc:	429a      	cmp	r2, r3
   168de:	d3e0      	bcc.n	168a2 <xTaskResumeAll+0x2a>
						xYieldPending = pdTRUE;
   168e0:	4b1a      	ldr	r3, [pc, #104]	; (1694c <xTaskResumeAll+0xd4>)
   168e2:	2201      	movs	r2, #1
   168e4:	601a      	str	r2, [r3, #0]
   168e6:	e7dc      	b.n	168a2 <xTaskResumeAll+0x2a>
				if( pxTCB != NULL )
   168e8:	b10c      	cbz	r4, 168ee <xTaskResumeAll+0x76>
					prvResetNextTaskUnblockTime();
   168ea:	f00b f95f 	bl	21bac <prvResetNextTaskUnblockTime>
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
   168ee:	4b18      	ldr	r3, [pc, #96]	; (16950 <xTaskResumeAll+0xd8>)
   168f0:	681c      	ldr	r4, [r3, #0]
					if( xPendedCounts > ( TickType_t ) 0U )
   168f2:	b16c      	cbz	r4, 16910 <xTaskResumeAll+0x98>
								xYieldPending = pdTRUE;
   168f4:	4e15      	ldr	r6, [pc, #84]	; (1694c <xTaskResumeAll+0xd4>)
   168f6:	2501      	movs	r5, #1
   168f8:	e001      	b.n	168fe <xTaskResumeAll+0x86>
						} while( xPendedCounts > ( TickType_t ) 0U );
   168fa:	3c01      	subs	r4, #1
   168fc:	d005      	beq.n	1690a <xTaskResumeAll+0x92>
							if( xTaskIncrementTick() != pdFALSE )
   168fe:	f7fe faf1 	bl	14ee4 <xTaskIncrementTick>
   16902:	2800      	cmp	r0, #0
   16904:	d0f9      	beq.n	168fa <xTaskResumeAll+0x82>
								xYieldPending = pdTRUE;
   16906:	6035      	str	r5, [r6, #0]
   16908:	e7f7      	b.n	168fa <xTaskResumeAll+0x82>
						xPendedTicks = 0;
   1690a:	4b11      	ldr	r3, [pc, #68]	; (16950 <xTaskResumeAll+0xd8>)
   1690c:	2200      	movs	r2, #0
   1690e:	601a      	str	r2, [r3, #0]
				if( xYieldPending != pdFALSE )
   16910:	4b0e      	ldr	r3, [pc, #56]	; (1694c <xTaskResumeAll+0xd4>)
   16912:	681c      	ldr	r4, [r3, #0]
   16914:	b154      	cbz	r4, 1692c <xTaskResumeAll+0xb4>
					taskYIELD_IF_USING_PREEMPTION();
   16916:	4b0f      	ldr	r3, [pc, #60]	; (16954 <xTaskResumeAll+0xdc>)
   16918:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1691c:	601a      	str	r2, [r3, #0]
   1691e:	f3bf 8f4f 	dsb	sy
   16922:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
   16926:	2401      	movs	r4, #1
   16928:	e000      	b.n	1692c <xTaskResumeAll+0xb4>
BaseType_t xAlreadyYielded = pdFALSE;
   1692a:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
   1692c:	f00d f948 	bl	23bc0 <vPortExitCritical>
}
   16930:	4620      	mov	r0, r4
   16932:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   16936:	bf00      	nop
   16938:	2000ef14 	.word	0x2000ef14
   1693c:	2000ef0c 	.word	0x2000ef0c
   16940:	2000ecc8 	.word	0x2000ecc8
   16944:	2000ef1c 	.word	0x2000ef1c
   16948:	2000ef00 	.word	0x2000ef00
   1694c:	2000ef38 	.word	0x2000ef38
   16950:	2000ef2c 	.word	0x2000ef2c
   16954:	e000ed04 	.word	0xe000ed04
   16958:	2000e850 	.word	0x2000e850

Disassembly of section .text._Command_DHCPLeaseInfo%345:

0001695c <_Command_DHCPLeaseInfo>:
{
   1695c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16960:	b08b      	sub	sp, #44	; 0x2c
   16962:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   16964:	6845      	ldr	r5, [r0, #4]
    if (argc != 2)
   16966:	2902      	cmp	r1, #2
   16968:	d00e      	beq.n	16988 <_Command_DHCPLeaseInfo+0x2c>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: dhcpsinfo <interface> \r\n");
   1696a:	4e30      	ldr	r6, [pc, #192]	; (16a2c <_Command_DHCPLeaseInfo+0xd0>)
   1696c:	6803      	ldr	r3, [r0, #0]
   1696e:	681b      	ldr	r3, [r3, #0]
   16970:	f606 01b8 	addw	r1, r6, #2232	; 0x8b8
   16974:	4628      	mov	r0, r5
   16976:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: dhcpsinfo PIC32INT \r\n");
   16978:	6823      	ldr	r3, [r4, #0]
   1697a:	681b      	ldr	r3, [r3, #0]
   1697c:	f606 01d8 	addw	r1, r6, #2264	; 0x8d8
   16980:	4628      	mov	r0, r5
   16982:	4798      	blx	r3
        return false;
   16984:	2000      	movs	r0, #0
   16986:	e04e      	b.n	16a26 <_Command_DHCPLeaseInfo+0xca>
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
   16988:	6850      	ldr	r0, [r2, #4]
   1698a:	f009 f86b 	bl	1fa64 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
   1698e:	4680      	mov	r8, r0
   16990:	2800      	cmp	r0, #0
   16992:	d03a      	beq.n	16a0a <_Command_DHCPLeaseInfo+0xae>
    (*pCmdIO->pCmdApi->print)(cmdIoParam,"MAC Address		IPAddress		RemainingLeaseTime \r\n",0);
   16994:	6823      	ldr	r3, [r4, #0]
   16996:	685b      	ldr	r3, [r3, #4]
   16998:	2200      	movs	r2, #0
   1699a:	4925      	ldr	r1, [pc, #148]	; (16a30 <_Command_DHCPLeaseInfo+0xd4>)
   1699c:	4628      	mov	r0, r5
   1699e:	4798      	blx	r3
    prevLease = 0;
   169a0:	2600      	movs	r6, #0
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "%s", addrBuff);
   169a2:	4f22      	ldr	r7, [pc, #136]	; (16a2c <_Command_DHCPLeaseInfo+0xd0>)
   169a4:	f607 1a64 	addw	sl, r7, #2404	; 0x964
        memset((void*)&leaseEntry,0,sizeof(TCPIP_DHCPS_LEASE_ENTRY));
   169a8:	2300      	movs	r3, #0
   169aa:	9306      	str	r3, [sp, #24]
   169ac:	9307      	str	r3, [sp, #28]
   169ae:	9308      	str	r3, [sp, #32]
   169b0:	9309      	str	r3, [sp, #36]	; 0x24
        nextLease = TCPIP_DHCPS_LeaseEntryGet(netH, &leaseEntry, prevLease);
   169b2:	4632      	mov	r2, r6
   169b4:	a906      	add	r1, sp, #24
   169b6:	4640      	mov	r0, r8
   169b8:	f001 fdce 	bl	18558 <TCPIP_DHCPS_LeaseEntryGet>
        if(!nextLease)
   169bc:	4606      	mov	r6, r0
   169be:	b358      	cbz	r0, 16a18 <_Command_DHCPLeaseInfo+0xbc>
            TCPIP_Helper_MACAddressToString(&leaseEntry.hwAdd, addrBuff, sizeof(addrBuff));
   169c0:	2214      	movs	r2, #20
   169c2:	a901      	add	r1, sp, #4
   169c4:	a806      	add	r0, sp, #24
   169c6:	f008 fcf3 	bl	1f3b0 <TCPIP_Helper_MACAddressToString>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "%s", addrBuff);
   169ca:	6823      	ldr	r3, [r4, #0]
   169cc:	685b      	ldr	r3, [r3, #4]
   169ce:	aa01      	add	r2, sp, #4
   169d0:	4651      	mov	r1, sl
   169d2:	4628      	mov	r0, r5
   169d4:	4798      	blx	r3
            TCPIP_Helper_IPAddressToString(&leaseEntry.ipAddress, addrBuff, sizeof(addrBuff));
   169d6:	2214      	movs	r2, #20
   169d8:	a901      	add	r1, sp, #4
   169da:	a808      	add	r0, sp, #32
   169dc:	f007 ff4a 	bl	1e874 <TCPIP_Helper_IPAddressToString>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "	%s ", addrBuff);
   169e0:	6823      	ldr	r3, [r4, #0]
   169e2:	685b      	ldr	r3, [r3, #4]
   169e4:	aa01      	add	r2, sp, #4
   169e6:	f607 1168 	addw	r1, r7, #2408	; 0x968
   169ea:	4628      	mov	r0, r5
   169ec:	4798      	blx	r3
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "	%d Secs\r\n", leaseEntry.leaseTime/SYS_TMR_TickCounterFrequencyGet());
   169ee:	6823      	ldr	r3, [r4, #0]
   169f0:	f8d3 9004 	ldr.w	r9, [r3, #4]
   169f4:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
   169f8:	f00b fc48 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
   169fc:	fbbb f2f0 	udiv	r2, fp, r0
   16a00:	f507 6117 	add.w	r1, r7, #2416	; 0x970
   16a04:	4628      	mov	r0, r5
   16a06:	47c8      	blx	r9
            prevLease = nextLease;
   16a08:	e7ce      	b.n	169a8 <_Command_DHCPLeaseInfo+0x4c>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   16a0a:	6823      	ldr	r3, [r4, #0]
   16a0c:	681b      	ldr	r3, [r3, #0]
   16a0e:	4909      	ldr	r1, [pc, #36]	; (16a34 <_Command_DHCPLeaseInfo+0xd8>)
   16a10:	4628      	mov	r0, r5
   16a12:	4798      	blx	r3
        return false;
   16a14:	2000      	movs	r0, #0
   16a16:	e006      	b.n	16a26 <_Command_DHCPLeaseInfo+0xca>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, " \r\n No more entry present \r\n", 0);
   16a18:	6823      	ldr	r3, [r4, #0]
   16a1a:	685b      	ldr	r3, [r3, #4]
   16a1c:	2200      	movs	r2, #0
   16a1e:	4906      	ldr	r1, [pc, #24]	; (16a38 <_Command_DHCPLeaseInfo+0xdc>)
   16a20:	4628      	mov	r0, r5
   16a22:	4798      	blx	r3
    return true;
   16a24:	2001      	movs	r0, #1
}
   16a26:	b00b      	add	sp, #44	; 0x2c
   16a28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   16a2c:	0000028c 	.word	0x0000028c
   16a30:	00000ba0 	.word	0x00000ba0
   16a34:	00000b80 	.word	0x00000b80
   16a38:	00000bd0 	.word	0x00000bd0

Disassembly of section .text.TCPIP_UDP_ArrayGet%346:

00016a3c <TCPIP_UDP_ArrayGet>:
{
   16a3c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    if(reqBytes == 0 || pSkt == 0)
   16a40:	2a00      	cmp	r2, #0
   16a42:	d063      	beq.n	16b0c <TCPIP_UDP_ArrayGet+0xd0>
   16a44:	4689      	mov	r9, r1
   16a46:	4616      	mov	r6, r2
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   16a48:	f00b fb80 	bl	2214c <_UDPSocketDcpt>
    if(reqBytes == 0 || pSkt == 0)
   16a4c:	4604      	mov	r4, r0
   16a4e:	2800      	cmp	r0, #0
   16a50:	d060      	beq.n	16b14 <TCPIP_UDP_ArrayGet+0xd8>
    if(pSkt->pCurrRxSeg == 0 && pSkt->extFlags.rxAutoAdvance != 0)
   16a52:	6b03      	ldr	r3, [r0, #48]	; 0x30
   16a54:	b133      	cbz	r3, 16a64 <TCPIP_UDP_ArrayGet+0x28>
    while(reqBytes != 0 && (pSeg = pSkt->pCurrRxSeg) != 0 && pSkt->rxTotLen != 0)
   16a56:	6b07      	ldr	r7, [r0, #48]	; 0x30
   16a58:	8ee5      	ldrh	r5, [r4, #54]	; 0x36
   16a5a:	46a8      	mov	r8, r5
   16a5c:	b1c5      	cbz	r5, 16a90 <TCPIP_UDP_ArrayGet+0x54>
   16a5e:	f04f 0800 	mov.w	r8, #0
   16a62:	e026      	b.n	16ab2 <TCPIP_UDP_ArrayGet+0x76>
    if(pSkt->pCurrRxSeg == 0 && pSkt->extFlags.rxAutoAdvance != 0)
   16a64:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   16a68:	f013 0f01 	tst.w	r3, #1
   16a6c:	d102      	bne.n	16a74 <TCPIP_UDP_ArrayGet+0x38>
   16a6e:	f04f 0800 	mov.w	r8, #0
   16a72:	e00a      	b.n	16a8a <TCPIP_UDP_ArrayGet+0x4e>
        _UDPUpdatePacketLock(pSkt);
   16a74:	f00b fb7e 	bl	22174 <_UDPUpdatePacketLock>
    while(reqBytes != 0 && (pSeg = pSkt->pCurrRxSeg) != 0 && pSkt->rxTotLen != 0)
   16a78:	6b27      	ldr	r7, [r4, #48]	; 0x30
   16a7a:	f04f 0800 	mov.w	r8, #0
   16a7e:	2f00      	cmp	r7, #0
   16a80:	d1ea      	bne.n	16a58 <TCPIP_UDP_ArrayGet+0x1c>
   16a82:	e002      	b.n	16a8a <TCPIP_UDP_ArrayGet+0x4e>
                pSkt->rxSegLen = 0;
   16a84:	2300      	movs	r3, #0
   16a86:	86a3      	strh	r3, [r4, #52]	; 0x34
                pSkt->rxCurr = 0;
   16a88:	63a3      	str	r3, [r4, #56]	; 0x38
    if(pSkt->rxTotLen == 0 && pSkt->extFlags.rxAutoAdvance != 0)
   16a8a:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   16a8c:	2b00      	cmp	r3, #0
   16a8e:	d13e      	bne.n	16b0e <TCPIP_UDP_ArrayGet+0xd2>
   16a90:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   16a94:	f013 0f01 	tst.w	r3, #1
   16a98:	d039      	beq.n	16b0e <TCPIP_UDP_ArrayGet+0xd2>
        _UDPUpdatePacketLock(pSkt);
   16a9a:	4620      	mov	r0, r4
   16a9c:	f00b fb6a 	bl	22174 <_UDPUpdatePacketLock>
   16aa0:	e035      	b.n	16b0e <TCPIP_UDP_ArrayGet+0xd2>
    while(reqBytes != 0 && (pSeg = pSkt->pCurrRxSeg) != 0 && pSkt->rxTotLen != 0)
   16aa2:	2e00      	cmp	r6, #0
   16aa4:	d0f1      	beq.n	16a8a <TCPIP_UDP_ArrayGet+0x4e>
   16aa6:	6b27      	ldr	r7, [r4, #48]	; 0x30
   16aa8:	2f00      	cmp	r7, #0
   16aaa:	d0ee      	beq.n	16a8a <TCPIP_UDP_ArrayGet+0x4e>
   16aac:	8ee5      	ldrh	r5, [r4, #54]	; 0x36
   16aae:	2d00      	cmp	r5, #0
   16ab0:	d0ee      	beq.n	16a90 <TCPIP_UDP_ArrayGet+0x54>
        xtractBytes = reqBytes <= pSkt->rxSegLen ? reqBytes : pSkt->rxSegLen;
   16ab2:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
   16ab4:	42b3      	cmp	r3, r6
   16ab6:	bf28      	it	cs
   16ab8:	4633      	movcs	r3, r6
        if(xtractBytes > pSkt->rxTotLen)
   16aba:	429d      	cmp	r5, r3
   16abc:	bf28      	it	cs
   16abe:	461d      	movcs	r5, r3
        if(xtractBytes)
   16ac0:	b1b5      	cbz	r5, 16af0 <TCPIP_UDP_ArrayGet+0xb4>
            if(cData != 0)
   16ac2:	f1b9 0f00 	cmp.w	r9, #0
   16ac6:	d005      	beq.n	16ad4 <TCPIP_UDP_ArrayGet+0x98>
                memcpy(cData, pSkt->rxCurr, xtractBytes);
   16ac8:	462a      	mov	r2, r5
   16aca:	6ba1      	ldr	r1, [r4, #56]	; 0x38
   16acc:	4648      	mov	r0, r9
   16ace:	f00c fc0d 	bl	232ec <memcpy>
                cData += xtractBytes;
   16ad2:	44a9      	add	r9, r5
            reqBytes -= xtractBytes;
   16ad4:	1b76      	subs	r6, r6, r5
   16ad6:	b2b6      	uxth	r6, r6
            avlblBytes += xtractBytes;
   16ad8:	44a8      	add	r8, r5
   16ada:	fa1f f888 	uxth.w	r8, r8
            pSkt->rxTotLen -= xtractBytes;
   16ade:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   16ae0:	1b5b      	subs	r3, r3, r5
   16ae2:	86e3      	strh	r3, [r4, #54]	; 0x36
            pSkt->rxSegLen -= xtractBytes;
   16ae4:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
   16ae6:	1b5b      	subs	r3, r3, r5
   16ae8:	86a3      	strh	r3, [r4, #52]	; 0x34
            pSkt->rxCurr += xtractBytes;
   16aea:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   16aec:	441d      	add	r5, r3
   16aee:	63a5      	str	r5, [r4, #56]	; 0x38
        if(pSkt->rxSegLen == 0)
   16af0:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
   16af2:	2b00      	cmp	r3, #0
   16af4:	d1d5      	bne.n	16aa2 <TCPIP_UDP_ArrayGet+0x66>
            pSeg = pSeg->next;
   16af6:	683f      	ldr	r7, [r7, #0]
            if((pSkt->pCurrRxSeg = pSeg) != 0)
   16af8:	6327      	str	r7, [r4, #48]	; 0x30
   16afa:	2f00      	cmp	r7, #0
   16afc:	d0c2      	beq.n	16a84 <TCPIP_UDP_ArrayGet+0x48>
                pSkt->rxSegLen = pSeg->segLen;
   16afe:	89bb      	ldrh	r3, [r7, #12]
   16b00:	86a3      	strh	r3, [r4, #52]	; 0x34
                pSkt->rxCurr = pSeg->segLoad;
   16b02:	68bb      	ldr	r3, [r7, #8]
   16b04:	63a3      	str	r3, [r4, #56]	; 0x38
    while(reqBytes != 0 && (pSeg = pSkt->pCurrRxSeg) != 0 && pSkt->rxTotLen != 0)
   16b06:	2e00      	cmp	r6, #0
   16b08:	d1d0      	bne.n	16aac <TCPIP_UDP_ArrayGet+0x70>
   16b0a:	e7be      	b.n	16a8a <TCPIP_UDP_ArrayGet+0x4e>
        return 0;
   16b0c:	4690      	mov	r8, r2
}
   16b0e:	4640      	mov	r0, r8
   16b10:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return 0;
   16b14:	f04f 0800 	mov.w	r8, #0
   16b18:	e7f9      	b.n	16b0e <TCPIP_UDP_ArrayGet+0xd2>

Disassembly of section .text.DRV_ETHPHY_Setup%347:

00016b1c <DRV_ETHPHY_Setup>:
    if(hClientObj == 0)
   16b1c:	2800      	cmp	r0, #0
   16b1e:	d045      	beq.n	16bac <DRV_ETHPHY_Setup+0x90>
{
   16b20:	b5f0      	push	{r4, r5, r6, r7, lr}
   16b22:	b085      	sub	sp, #20
   16b24:	4604      	mov	r4, r0
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   16b26:	68c0      	ldr	r0, [r0, #12]
   16b28:	4b30      	ldr	r3, [pc, #192]	; (16bec <DRV_ETHPHY_Setup+0xd0>)
   16b2a:	4298      	cmp	r0, r3
   16b2c:	d141      	bne.n	16bb2 <DRV_ETHPHY_Setup+0x96>
    if(hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_READY)
   16b2e:	f994 3008 	ldrsb.w	r3, [r4, #8]
   16b32:	2b02      	cmp	r3, #2
   16b34:	d141      	bne.n	16bba <DRV_ETHPHY_Setup+0x9e>
    if(pSetUp == 0 || pSetupFlags == 0)
   16b36:	2900      	cmp	r1, #0
   16b38:	d042      	beq.n	16bc0 <DRV_ETHPHY_Setup+0xa4>
   16b3a:	2a00      	cmp	r2, #0
   16b3c:	d043      	beq.n	16bc6 <DRV_ETHPHY_Setup+0xaa>
    pPhyObj = phyInst->pPhyObj;
   16b3e:	4b2b      	ldr	r3, [pc, #172]	; (16bec <DRV_ETHPHY_Setup+0xd0>)
   16b40:	695f      	ldr	r7, [r3, #20]
    if(pPhyObj == 0 || pPhyObj->miiConfigure == 0 || pPhyObj->mdixConfigure == 0 || pPhyObj->smiClockGet == 0)
   16b42:	2f00      	cmp	r7, #0
   16b44:	d042      	beq.n	16bcc <DRV_ETHPHY_Setup+0xb0>
   16b46:	683b      	ldr	r3, [r7, #0]
   16b48:	2b00      	cmp	r3, #0
   16b4a:	d042      	beq.n	16bd2 <DRV_ETHPHY_Setup+0xb6>
   16b4c:	687b      	ldr	r3, [r7, #4]
   16b4e:	2b00      	cmp	r3, #0
   16b50:	d042      	beq.n	16bd8 <DRV_ETHPHY_Setup+0xbc>
   16b52:	68bb      	ldr	r3, [r7, #8]
   16b54:	2b00      	cmp	r3, #0
   16b56:	d042      	beq.n	16bde <DRV_ETHPHY_Setup+0xc2>
   16b58:	4616      	mov	r6, r2
   16b5a:	460d      	mov	r5, r1
    if(pSetUp->resetFunction)
   16b5c:	688b      	ldr	r3, [r1, #8]
   16b5e:	b10b      	cbz	r3, 16b64 <DRV_ETHPHY_Setup+0x48>
        (*pSetUp->resetFunction)(gDrvEthBaseObj);
   16b60:	4823      	ldr	r0, [pc, #140]	; (16bf0 <DRV_ETHPHY_Setup+0xd4>)
   16b62:	4798      	blx	r3
	miimSetup.hostClockFreq = (uint32_t)TCPIP_INTMAC_PERIPHERAL_CLK;
   16b64:	4b23      	ldr	r3, [pc, #140]	; (16bf4 <DRV_ETHPHY_Setup+0xd8>)
   16b66:	9301      	str	r3, [sp, #4]
    miimSetup.maxBusFreq = (*pPhyObj->smiClockGet)(gDrvEthBaseObj, handle);
   16b68:	68bb      	ldr	r3, [r7, #8]
   16b6a:	4621      	mov	r1, r4
   16b6c:	4820      	ldr	r0, [pc, #128]	; (16bf0 <DRV_ETHPHY_Setup+0xd4>)
   16b6e:	4798      	blx	r3
   16b70:	9002      	str	r0, [sp, #8]
    miimSetup.setupFlags = DRV_MIIM_SETUP_FLAG_NONE;
   16b72:	2300      	movs	r3, #0
   16b74:	f88d 300c 	strb.w	r3, [sp, #12]
    DRV_MIIM_RESULT miimRes = hClientObj->pMiimBase->DRV_MIIM_Setup(hClientObj->miimHandle, &miimSetup); 
   16b78:	6923      	ldr	r3, [r4, #16]
   16b7a:	699b      	ldr	r3, [r3, #24]
   16b7c:	a901      	add	r1, sp, #4
   16b7e:	6960      	ldr	r0, [r4, #20]
   16b80:	4798      	blx	r3
    if(miimRes < 0)
   16b82:	2800      	cmp	r0, #0
   16b84:	db2e      	blt.n	16be4 <DRV_ETHPHY_Setup+0xc8>
    phyInst->phyAddress = pSetUp->phyAddress;
   16b86:	682a      	ldr	r2, [r5, #0]
   16b88:	4b18      	ldr	r3, [pc, #96]	; (16bec <DRV_ETHPHY_Setup+0xd0>)
   16b8a:	611a      	str	r2, [r3, #16]
    phyInst->openFlags = pSetUp->openFlags;
   16b8c:	88aa      	ldrh	r2, [r5, #4]
   16b8e:	819a      	strh	r2, [r3, #12]
    phyInst->configFlags = pSetUp->configFlags;
   16b90:	79aa      	ldrb	r2, [r5, #6]
   16b92:	739a      	strb	r2, [r3, #14]
    phyInst->macPauseType = pSetUp->macPauseType;
   16b94:	79ea      	ldrb	r2, [r5, #7]
   16b96:	73da      	strb	r2, [r3, #15]
    hClientObj->operParam = (uintptr_t)pSetupFlags;
   16b98:	6326      	str	r6, [r4, #48]	; 0x30
    hClientObj->operType = opType;
   16b9a:	2001      	movs	r0, #1
   16b9c:	83a0      	strh	r0, [r4, #28]
    hClientObj->operPhase = hClientObj->operSubPhase = 0; 
   16b9e:	2300      	movs	r3, #0
   16ba0:	8423      	strh	r3, [r4, #32]
   16ba2:	83e3      	strh	r3, [r4, #30]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_BUSY; 
   16ba4:	7220      	strb	r0, [r4, #8]
    hClientObj->operRes = res;
   16ba6:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
   16baa:	e004      	b.n	16bb6 <DRV_ETHPHY_Setup+0x9a>
        return DRV_ETHPHY_RES_HANDLE_ERR;
   16bac:	f06f 000a 	mvn.w	r0, #10
}
   16bb0:	4770      	bx	lr
        return DRV_ETHPHY_RES_HANDLE_ERR;
   16bb2:	f06f 000a 	mvn.w	r0, #10
}
   16bb6:	b005      	add	sp, #20
   16bb8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   16bba:	f06f 0009 	mvn.w	r0, #9
   16bbe:	e7fa      	b.n	16bb6 <DRV_ETHPHY_Setup+0x9a>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   16bc0:	f06f 0008 	mvn.w	r0, #8
   16bc4:	e7f7      	b.n	16bb6 <DRV_ETHPHY_Setup+0x9a>
   16bc6:	f06f 0008 	mvn.w	r0, #8
   16bca:	e7f4      	b.n	16bb6 <DRV_ETHPHY_Setup+0x9a>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   16bcc:	f06f 0008 	mvn.w	r0, #8
   16bd0:	e7f1      	b.n	16bb6 <DRV_ETHPHY_Setup+0x9a>
   16bd2:	f06f 0008 	mvn.w	r0, #8
   16bd6:	e7ee      	b.n	16bb6 <DRV_ETHPHY_Setup+0x9a>
   16bd8:	f06f 0008 	mvn.w	r0, #8
   16bdc:	e7eb      	b.n	16bb6 <DRV_ETHPHY_Setup+0x9a>
   16bde:	f06f 0008 	mvn.w	r0, #8
   16be2:	e7e8      	b.n	16bb6 <DRV_ETHPHY_Setup+0x9a>
        return DRV_ETHPHY_RES_MIIM_ERR;
   16be4:	f06f 000c 	mvn.w	r0, #12
   16be8:	e7e5      	b.n	16bb6 <DRV_ETHPHY_Setup+0x9a>
   16bea:	bf00      	nop
   16bec:	2000e7e8 	.word	0x2000e7e8
   16bf0:	0001d460 	.word	0x0001d460
   16bf4:	07270e00 	.word	0x07270e00

Disassembly of section .text.__swsetup_r%348:

00016bf8 <__swsetup_r>:
   16bf8:	4b32      	ldr	r3, [pc, #200]	; (16cc4 <__swsetup_r+0xcc>)
   16bfa:	b570      	push	{r4, r5, r6, lr}
   16bfc:	681d      	ldr	r5, [r3, #0]
   16bfe:	4606      	mov	r6, r0
   16c00:	460c      	mov	r4, r1
   16c02:	b125      	cbz	r5, 16c0e <__swsetup_r+0x16>
   16c04:	69ab      	ldr	r3, [r5, #24]
   16c06:	b913      	cbnz	r3, 16c0e <__swsetup_r+0x16>
   16c08:	4628      	mov	r0, r5
   16c0a:	f006 fbc9 	bl	1d3a0 <__sinit>
   16c0e:	4b2e      	ldr	r3, [pc, #184]	; (16cc8 <__swsetup_r+0xd0>)
   16c10:	429c      	cmp	r4, r3
   16c12:	d10f      	bne.n	16c34 <__swsetup_r+0x3c>
   16c14:	686c      	ldr	r4, [r5, #4]
   16c16:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   16c1a:	b29a      	uxth	r2, r3
   16c1c:	0715      	lsls	r5, r2, #28
   16c1e:	d42c      	bmi.n	16c7a <__swsetup_r+0x82>
   16c20:	06d0      	lsls	r0, r2, #27
   16c22:	d411      	bmi.n	16c48 <__swsetup_r+0x50>
   16c24:	2209      	movs	r2, #9
   16c26:	6032      	str	r2, [r6, #0]
   16c28:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   16c2c:	81a3      	strh	r3, [r4, #12]
   16c2e:	f04f 30ff 	mov.w	r0, #4294967295
   16c32:	e03e      	b.n	16cb2 <__swsetup_r+0xba>
   16c34:	4b25      	ldr	r3, [pc, #148]	; (16ccc <__swsetup_r+0xd4>)
   16c36:	429c      	cmp	r4, r3
   16c38:	d101      	bne.n	16c3e <__swsetup_r+0x46>
   16c3a:	68ac      	ldr	r4, [r5, #8]
   16c3c:	e7eb      	b.n	16c16 <__swsetup_r+0x1e>
   16c3e:	4b24      	ldr	r3, [pc, #144]	; (16cd0 <__swsetup_r+0xd8>)
   16c40:	429c      	cmp	r4, r3
   16c42:	bf08      	it	eq
   16c44:	68ec      	ldreq	r4, [r5, #12]
   16c46:	e7e6      	b.n	16c16 <__swsetup_r+0x1e>
   16c48:	0751      	lsls	r1, r2, #29
   16c4a:	d512      	bpl.n	16c72 <__swsetup_r+0x7a>
   16c4c:	6b61      	ldr	r1, [r4, #52]	; 0x34
   16c4e:	b141      	cbz	r1, 16c62 <__swsetup_r+0x6a>
   16c50:	f104 0344 	add.w	r3, r4, #68	; 0x44
   16c54:	4299      	cmp	r1, r3
   16c56:	d002      	beq.n	16c5e <__swsetup_r+0x66>
   16c58:	4630      	mov	r0, r6
   16c5a:	f002 fe4b 	bl	198f4 <_free_r>
   16c5e:	2300      	movs	r3, #0
   16c60:	6363      	str	r3, [r4, #52]	; 0x34
   16c62:	89a3      	ldrh	r3, [r4, #12]
   16c64:	f023 0324 	bic.w	r3, r3, #36	; 0x24
   16c68:	81a3      	strh	r3, [r4, #12]
   16c6a:	2300      	movs	r3, #0
   16c6c:	6063      	str	r3, [r4, #4]
   16c6e:	6923      	ldr	r3, [r4, #16]
   16c70:	6023      	str	r3, [r4, #0]
   16c72:	89a3      	ldrh	r3, [r4, #12]
   16c74:	f043 0308 	orr.w	r3, r3, #8
   16c78:	81a3      	strh	r3, [r4, #12]
   16c7a:	6923      	ldr	r3, [r4, #16]
   16c7c:	b94b      	cbnz	r3, 16c92 <__swsetup_r+0x9a>
   16c7e:	89a3      	ldrh	r3, [r4, #12]
   16c80:	f403 7320 	and.w	r3, r3, #640	; 0x280
   16c84:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   16c88:	d003      	beq.n	16c92 <__swsetup_r+0x9a>
   16c8a:	4621      	mov	r1, r4
   16c8c:	4630      	mov	r0, r6
   16c8e:	f003 fcd7 	bl	1a640 <__smakebuf_r>
   16c92:	89a2      	ldrh	r2, [r4, #12]
   16c94:	f012 0301 	ands.w	r3, r2, #1
   16c98:	d00c      	beq.n	16cb4 <__swsetup_r+0xbc>
   16c9a:	2300      	movs	r3, #0
   16c9c:	60a3      	str	r3, [r4, #8]
   16c9e:	6963      	ldr	r3, [r4, #20]
   16ca0:	425b      	negs	r3, r3
   16ca2:	61a3      	str	r3, [r4, #24]
   16ca4:	6923      	ldr	r3, [r4, #16]
   16ca6:	b953      	cbnz	r3, 16cbe <__swsetup_r+0xc6>
   16ca8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   16cac:	f013 0080 	ands.w	r0, r3, #128	; 0x80
   16cb0:	d1ba      	bne.n	16c28 <__swsetup_r+0x30>
   16cb2:	bd70      	pop	{r4, r5, r6, pc}
   16cb4:	0792      	lsls	r2, r2, #30
   16cb6:	bf58      	it	pl
   16cb8:	6963      	ldrpl	r3, [r4, #20]
   16cba:	60a3      	str	r3, [r4, #8]
   16cbc:	e7f2      	b.n	16ca4 <__swsetup_r+0xac>
   16cbe:	2000      	movs	r0, #0
   16cc0:	e7f7      	b.n	16cb2 <__swsetup_r+0xba>
   16cc2:	bf00      	nop
   16cc4:	2000ef60 	.word	0x2000ef60
   16cc8:	2000eb44 	.word	0x2000eb44
   16ccc:	2000eb64 	.word	0x2000eb64
   16cd0:	2000eb24 	.word	0x2000eb24

Disassembly of section .text._DHCPS_FindValidAddressFromPool%349:

00016cd4 <_DHCPS_FindValidAddressFromPool>:
{
   16cd4:	b5f0      	push	{r4, r5, r6, r7, lr}
   16cd6:	b083      	sub	sp, #12
    if(reqIPAddress != 0)
   16cd8:	b1a3      	cbz	r3, 16d04 <_DHCPS_FindValidAddressFromPool+0x30>
        tempIpv4Addr.Val = reqIPAddress->Val;                
   16cda:	681b      	ldr	r3, [r3, #0]
   16cdc:	9301      	str	r3, [sp, #4]
    if(false == isMacAddrEffective(&(Header->ClientMAC))) 
   16cde:	f100 061c 	add.w	r6, r0, #28
        if(macAddr->v[i] != 0) return true;
   16ce2:	7f03      	ldrb	r3, [r0, #28]
   16ce4:	2b00      	cmp	r3, #0
   16ce6:	d14a      	bne.n	16d7e <_DHCPS_FindValidAddressFromPool+0xaa>
   16ce8:	f100 031d 	add.w	r3, r0, #29
   16cec:	3022      	adds	r0, #34	; 0x22
   16cee:	f813 7b01 	ldrb.w	r7, [r3], #1
   16cf2:	2f00      	cmp	r7, #0
   16cf4:	d143      	bne.n	16d7e <_DHCPS_FindValidAddressFromPool+0xaa>
    for(i=0;i<6;i++)
   16cf6:	4283      	cmp	r3, r0
   16cf8:	d1f9      	bne.n	16cee <_DHCPS_FindValidAddressFromPool+0x1a>
        return DHCPS_RES_NO_ENTRY;
   16cfa:	f04f 33ff 	mov.w	r3, #4294967295
}
   16cfe:	4618      	mov	r0, r3
   16d00:	b003      	add	sp, #12
   16d02:	bdf0      	pop	{r4, r5, r6, r7, pc}
        tempIpv4Addr.Val = 0;
   16d04:	2300      	movs	r3, #0
   16d06:	e7e9      	b.n	16cdc <_DHCPS_FindValidAddressFromPool+0x8>
            bktIx = DHCPSgetFreeHashIndex(pdhcpsHashDcpt->hashDcpt, &Header->ClientMAC,&pDhcpsDcpt->intfAddrsConf.startIPAddress,(IPV4_ADDR*)&tempIpv4Addr);
   16d08:	ab01      	add	r3, sp, #4
   16d0a:	f104 0208 	add.w	r2, r4, #8
   16d0e:	4631      	mov	r1, r6
   16d10:	6828      	ldr	r0, [r5, #0]
   16d12:	f003 faa3 	bl	1a25c <DHCPSgetFreeHashIndex>
            if(bktIx == -1)
   16d16:	f1b0 3fff 	cmp.w	r0, #4294967295
   16d1a:	d02a      	beq.n	16d72 <_DHCPS_FindValidAddressFromPool+0x9e>
            dhcps_mod.dhcpNextLease.v[0] = pDhcpsDcpt->intfAddrsConf.startIPAddress.v[0] & 0xFF;
   16d1c:	7a22      	ldrb	r2, [r4, #8]
   16d1e:	4b22      	ldr	r3, [pc, #136]	; (16da8 <_DHCPS_FindValidAddressFromPool+0xd4>)
   16d20:	721a      	strb	r2, [r3, #8]
            dhcps_mod.dhcpNextLease.v[1] = pDhcpsDcpt->intfAddrsConf.startIPAddress.v[1] & 0xFF;
   16d22:	7a62      	ldrb	r2, [r4, #9]
   16d24:	725a      	strb	r2, [r3, #9]
            dhcps_mod.dhcpNextLease.v[2] = pDhcpsDcpt->intfAddrsConf.startIPAddress.v[2] & 0xFF;
   16d26:	7aa2      	ldrb	r2, [r4, #10]
   16d28:	729a      	strb	r2, [r3, #10]
            dhcps_mod.dhcpNextLease.v[3] = (pDhcpsDcpt->intfAddrsConf.startIPAddress.v[3] & 0xFF) + bktIx;
   16d2a:	7ae2      	ldrb	r2, [r4, #11]
   16d2c:	4402      	add	r2, r0
   16d2e:	72da      	strb	r2, [r3, #11]
        return DHCPS_RES_OK;
   16d30:	2300      	movs	r3, #0
   16d32:	e7e4      	b.n	16cfe <_DHCPS_FindValidAddressFromPool+0x2a>
        if((dhcps_mod.dhcpNextLease.Val == 0)||(dhcps_mod.smState == TCPIP_DHCPS_GET_NEW_ADDRESS))
   16d34:	4b1c      	ldr	r3, [pc, #112]	; (16da8 <_DHCPS_FindValidAddressFromPool+0xd4>)
   16d36:	689b      	ldr	r3, [r3, #8]
   16d38:	b12b      	cbz	r3, 16d46 <_DHCPS_FindValidAddressFromPool+0x72>
   16d3a:	4b1b      	ldr	r3, [pc, #108]	; (16da8 <_DHCPS_FindValidAddressFromPool+0xd4>)
   16d3c:	78db      	ldrb	r3, [r3, #3]
   16d3e:	2b08      	cmp	r3, #8
   16d40:	d001      	beq.n	16d46 <_DHCPS_FindValidAddressFromPool+0x72>
    return DHCPS_RES_OK;
   16d42:	2300      	movs	r3, #0
   16d44:	e7db      	b.n	16cfe <_DHCPS_FindValidAddressFromPool+0x2a>
            bktIx = DHCPSgetFreeHashIndex(pdhcpsHashDcpt->hashDcpt, &Header->ClientMAC,&pDhcpsDcpt->intfAddrsConf.startIPAddress,(IPV4_ADDR*)&tempIpv4Addr);
   16d46:	ab01      	add	r3, sp, #4
   16d48:	f104 0208 	add.w	r2, r4, #8
   16d4c:	4631      	mov	r1, r6
   16d4e:	6828      	ldr	r0, [r5, #0]
   16d50:	f003 fa84 	bl	1a25c <DHCPSgetFreeHashIndex>
            if(bktIx == -1)
   16d54:	f1b0 3fff 	cmp.w	r0, #4294967295
   16d58:	d00e      	beq.n	16d78 <_DHCPS_FindValidAddressFromPool+0xa4>
            dhcps_mod.dhcpNextLease.v[0] = pDhcpsDcpt->intfAddrsConf.startIPAddress.v[0] & 0xFF;
   16d5a:	7a22      	ldrb	r2, [r4, #8]
   16d5c:	4b12      	ldr	r3, [pc, #72]	; (16da8 <_DHCPS_FindValidAddressFromPool+0xd4>)
   16d5e:	721a      	strb	r2, [r3, #8]
            dhcps_mod.dhcpNextLease.v[1] = pDhcpsDcpt->intfAddrsConf.startIPAddress.v[1] & 0xFF;
   16d60:	7a62      	ldrb	r2, [r4, #9]
   16d62:	725a      	strb	r2, [r3, #9]
            dhcps_mod.dhcpNextLease.v[2] = pDhcpsDcpt->intfAddrsConf.startIPAddress.v[2] & 0xFF;
   16d64:	7aa2      	ldrb	r2, [r4, #10]
   16d66:	729a      	strb	r2, [r3, #10]
            dhcps_mod.dhcpNextLease.v[3] = (pDhcpsDcpt->intfAddrsConf.startIPAddress.v[3] & 0xFF) + bktIx;
   16d68:	7ae2      	ldrb	r2, [r4, #11]
   16d6a:	4402      	add	r2, r0
   16d6c:	72da      	strb	r2, [r3, #11]
    return DHCPS_RES_OK;
   16d6e:	2300      	movs	r3, #0
   16d70:	e7c5      	b.n	16cfe <_DHCPS_FindValidAddressFromPool+0x2a>
                return DHCPS_RES_CACHE_FULL;
   16d72:	f06f 0301 	mvn.w	r3, #1
   16d76:	e7c2      	b.n	16cfe <_DHCPS_FindValidAddressFromPool+0x2a>
                return DHCPS_RES_CACHE_FULL;
   16d78:	f06f 0301 	mvn.w	r3, #1
   16d7c:	e7bf      	b.n	16cfe <_DHCPS_FindValidAddressFromPool+0x2a>
   16d7e:	4615      	mov	r5, r2
   16d80:	460c      	mov	r4, r1
    hE = TCPIP_OAHASH_EntryLookup(pdhcpsHashDcpt->hashDcpt, &Header->ClientMAC);
   16d82:	4631      	mov	r1, r6
   16d84:	6810      	ldr	r0, [r2, #0]
   16d86:	f005 fdfd 	bl	1c984 <TCPIP_OAHASH_EntryLookup>
    if(hE !=0)
   16d8a:	2800      	cmp	r0, #0
   16d8c:	d0d2      	beq.n	16d34 <_DHCPS_FindValidAddressFromPool+0x60>
        if((DHCPSLocateRequestedIpAddress(&tempIpv4Addr) != DHCPS_RES_OK)&&(dhcps_mod.smState == TCPIP_DHCPS_GET_NEW_ADDRESS))
   16d8e:	a801      	add	r0, sp, #4
   16d90:	f007 f8e8 	bl	1df64 <DHCPSLocateRequestedIpAddress>
   16d94:	4603      	mov	r3, r0
   16d96:	2800      	cmp	r0, #0
   16d98:	d0b1      	beq.n	16cfe <_DHCPS_FindValidAddressFromPool+0x2a>
   16d9a:	4b03      	ldr	r3, [pc, #12]	; (16da8 <_DHCPS_FindValidAddressFromPool+0xd4>)
   16d9c:	78db      	ldrb	r3, [r3, #3]
   16d9e:	2b08      	cmp	r3, #8
   16da0:	d0b2      	beq.n	16d08 <_DHCPS_FindValidAddressFromPool+0x34>
        return DHCPS_RES_OK;
   16da2:	2300      	movs	r3, #0
   16da4:	e7ab      	b.n	16cfe <_DHCPS_FindValidAddressFromPool+0x2a>
   16da6:	bf00      	nop
   16da8:	2000ed3c 	.word	0x2000ed3c

Disassembly of section .text.SYS_TIME_PLIBCallback%350:

00016dac <SYS_TIME_PLIBCallback>:
        }
    }
}

static void SYS_TIME_PLIBCallback(uint32_t status, uintptr_t context)
{
   16dac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    SYS_TIME_COUNTER_OBJ* counterObj = (SYS_TIME_COUNTER_OBJ *)&gSystemCounterObj;
    SYS_TIME_TIMER_OBJ* tmrActive = counterObj->tmrActive;
   16dae:	4c32      	ldr	r4, [pc, #200]	; (16e78 <SYS_TIME_PLIBCallback+0xcc>)
   16db0:	6b25      	ldr	r5, [r4, #48]	; 0x30
    uint32_t elapsedCount = 0;
    bool interruptState;

    counterObj->hwTimerCurrentValue = counterObj->timePlib->timerCounterGet();
   16db2:	6863      	ldr	r3, [r4, #4]
   16db4:	699b      	ldr	r3, [r3, #24]
   16db6:	4798      	blx	r3
   16db8:	6160      	str	r0, [r4, #20]

    elapsedCount = SYS_TIME_GetElapsedCount(counterObj->hwTimerCurrentValue);
   16dba:	6960      	ldr	r0, [r4, #20]
   16dbc:	f00c fa34 	bl	23228 <SYS_TIME_GetElapsedCount>
   16dc0:	4606      	mov	r6, r0
	
	SYS_TIME_Counter64Update(elapsedCount);
   16dc2:	f00c fa23 	bl	2320c <SYS_TIME_Counter64Update>

    if (tmrActive != NULL)
   16dc6:	2d00      	cmp	r5, #0
   16dc8:	d04d      	beq.n	16e66 <SYS_TIME_PLIBCallback+0xba>
    {
        counterObj->interruptNestingCount++;
   16dca:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
   16dce:	3301      	adds	r3, #1
   16dd0:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
    SYS_TIME_UpdateTimerList(elapsedCounts);
   16dd4:	4630      	mov	r0, r6
   16dd6:	f00a fb71 	bl	214bc <SYS_TIME_UpdateTimerList>
    SYS_TIME_TIMER_OBJ* tmrActive = counterObj->tmrActive;
   16dda:	6b24      	ldr	r4, [r4, #48]	; 0x30
    while (tmrActive != NULL)
   16ddc:	b12c      	cbz	r4, 16dea <SYS_TIME_PLIBCallback+0x3e>
        if(tmrActive->relativeTimePending == 0)
   16dde:	68a3      	ldr	r3, [r4, #8]
   16de0:	b91b      	cbnz	r3, 16dea <SYS_TIME_PLIBCallback+0x3e>
            tmrActive->tmrElapsedFlag = true;
   16de2:	2501      	movs	r5, #1
                    tmrActive->active = false;
   16de4:	2700      	movs	r7, #0
            tmrActive = counterObj->tmrActive;
   16de6:	4e24      	ldr	r6, [pc, #144]	; (16e78 <SYS_TIME_PLIBCallback+0xcc>)
   16de8:	e011      	b.n	16e0e <SYS_TIME_PLIBCallback+0x62>
   16dea:	4d24      	ldr	r5, [pc, #144]	; (16e7c <SYS_TIME_PLIBCallback+0xd0>)
{
   16dec:	2400      	movs	r4, #0
        if (timers[i].tmrElapsed == true)
   16dee:	462e      	mov	r6, r5
            timers[i].tmrElapsed = false;
   16df0:	4627      	mov	r7, r4
   16df2:	e01f      	b.n	16e34 <SYS_TIME_PLIBCallback+0x88>
                SYS_TIME_TimerDestroy(tmrActive->tmrHandle);
   16df4:	69e0      	ldr	r0, [r4, #28]
   16df6:	f009 fa8d 	bl	20314 <SYS_TIME_TimerDestroy>
            if(tmrActive->callback != NULL)
   16dfa:	68e3      	ldr	r3, [r4, #12]
   16dfc:	b10b      	cbz	r3, 16e02 <SYS_TIME_PLIBCallback+0x56>
                tmrActive->callback(tmrActive->context);
   16dfe:	6920      	ldr	r0, [r4, #16]
   16e00:	4798      	blx	r3
            tmrActive = counterObj->tmrActive;
   16e02:	6b34      	ldr	r4, [r6, #48]	; 0x30
    while (tmrActive != NULL)
   16e04:	2c00      	cmp	r4, #0
   16e06:	d0f0      	beq.n	16dea <SYS_TIME_PLIBCallback+0x3e>
        if(tmrActive->relativeTimePending == 0)
   16e08:	68a3      	ldr	r3, [r4, #8]
   16e0a:	2b00      	cmp	r3, #0
   16e0c:	d1ed      	bne.n	16dea <SYS_TIME_PLIBCallback+0x3e>
            tmrActive->tmrElapsedFlag = true;
   16e0e:	7525      	strb	r5, [r4, #20]
            tmrActive->tmrElapsed = true;
   16e10:	7565      	strb	r5, [r4, #21]
            if ((tmrActive->type == SYS_TIME_SINGLE) && (tmrActive->callback != NULL))
   16e12:	78a3      	ldrb	r3, [r4, #2]
   16e14:	b913      	cbnz	r3, 16e1c <SYS_TIME_PLIBCallback+0x70>
   16e16:	68e3      	ldr	r3, [r4, #12]
   16e18:	2b00      	cmp	r3, #0
   16e1a:	d1eb      	bne.n	16df4 <SYS_TIME_PLIBCallback+0x48>
                SYS_TIME_RemoveFromList(tmrActive);
   16e1c:	4620      	mov	r0, r4
   16e1e:	f006 fc61 	bl	1d6e4 <SYS_TIME_RemoveFromList>
                if (tmrActive->type == SYS_TIME_SINGLE)
   16e22:	78a3      	ldrb	r3, [r4, #2]
   16e24:	2b00      	cmp	r3, #0
   16e26:	d1e8      	bne.n	16dfa <SYS_TIME_PLIBCallback+0x4e>
                    tmrActive->active = false;
   16e28:	7067      	strb	r7, [r4, #1]
   16e2a:	e7e6      	b.n	16dfa <SYS_TIME_PLIBCallback+0x4e>
   16e2c:	3401      	adds	r4, #1
   16e2e:	3520      	adds	r5, #32
    for ( i = 0; i < SYS_TIME_MAX_TIMERS; i++)
   16e30:	2c05      	cmp	r4, #5
   16e32:	d012      	beq.n	16e5a <SYS_TIME_PLIBCallback+0xae>
        if (timers[i].tmrElapsed == true)
   16e34:	eb06 1344 	add.w	r3, r6, r4, lsl #5
   16e38:	7d5b      	ldrb	r3, [r3, #21]
   16e3a:	2b00      	cmp	r3, #0
   16e3c:	d0f6      	beq.n	16e2c <SYS_TIME_PLIBCallback+0x80>
            timers[i].tmrElapsed = false;
   16e3e:	eb06 1344 	add.w	r3, r6, r4, lsl #5
   16e42:	755f      	strb	r7, [r3, #21]
            if (timers[i].type == SYS_TIME_PERIODIC)
   16e44:	78ab      	ldrb	r3, [r5, #2]
   16e46:	2b01      	cmp	r3, #1
   16e48:	d1f0      	bne.n	16e2c <SYS_TIME_PLIBCallback+0x80>
                timers[i].relativeTimePending = timers[i].requestedTime;
   16e4a:	686b      	ldr	r3, [r5, #4]
   16e4c:	eb06 1244 	add.w	r2, r6, r4, lsl #5
   16e50:	6093      	str	r3, [r2, #8]
                SYS_TIME_AddToList(&timers[i]);
   16e52:	4628      	mov	r0, r5
   16e54:	f003 fa92 	bl	1a37c <SYS_TIME_AddToList>
   16e58:	e7e8      	b.n	16e2c <SYS_TIME_PLIBCallback+0x80>

        SYS_TIME_UpdateTime(elapsedCount);

        counterObj->interruptNestingCount--;
   16e5a:	4a07      	ldr	r2, [pc, #28]	; (16e78 <SYS_TIME_PLIBCallback+0xcc>)
   16e5c:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
   16e60:	3b01      	subs	r3, #1
   16e62:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
    }
    
    interruptState = SYS_INT_Disable();
   16e66:	f00d fac7 	bl	243f8 <SYS_INT_Disable>
   16e6a:	4604      	mov	r4, r0
    SYS_TIME_HwTimerCompareUpdate();
   16e6c:	f001 fbce 	bl	1860c <SYS_TIME_HwTimerCompareUpdate>
    SYS_INT_Restore(interruptState);
   16e70:	4620      	mov	r0, r4
   16e72:	f00d fac5 	bl	24400 <SYS_INT_Restore>
}
   16e76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   16e78:	2000ea00 	.word	0x2000ea00
   16e7c:	2000e520 	.word	0x2000e520

Disassembly of section .text.ssd1306_init%351:

00016e80 <ssd1306_init>:
 *
 * Call this function to initialize the hardware interface and the OLED
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void ssd1306_init(void) {
   16e80:	b530      	push	{r4, r5, lr}
   16e82:	b083      	sub	sp, #12
     * \brief Perform a hard reset of the OLED controller
     *
     * This functions will reset the OLED controller by setting the reset pin low.
     */
    static inline void ssd1306_hard_reset(void) {
        GFX_DELAY_FUNCTION(20); // At least 10us	
   16e84:	2014      	movs	r0, #20
   16e86:	f009 ffbd 	bl	20e04 <vTaskDelay>
        GFX_DISPLAY_RESET_CLEAR();
   16e8a:	4c31      	ldr	r4, [pc, #196]	; (16f50 <ssd1306_init+0xd0>)
   16e8c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   16e90:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
        GFX_DELAY_FUNCTION(20); // At least 10us	
   16e94:	2014      	movs	r0, #20
   16e96:	f009 ffb5 	bl	20e04 <vTaskDelay>
        GFX_DISPLAY_RESET_SET();
   16e9a:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98
        GFX_DELAY_FUNCTION(20); // At least 10us	
   16e9e:	2014      	movs	r0, #20
   16ea0:	f009 ffb0 	bl	20e04 <vTaskDelay>

    // Do a hard reset of the OLED display controller
    ssd1306_hard_reset();

    // Set the reset pin to the default state	
    GFX_DISPLAY_RESET_SET();
   16ea4:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98

    // 1/32 Duty (0x0F~0x3F)
    ssd1306_write_command(SSD1306_CMD_SET_MULTIPLEX_RATIO);
   16ea8:	20a8      	movs	r0, #168	; 0xa8
   16eaa:	f008 fedb 	bl	1fc64 <ssd1306_write_command>
    ssd1306_write_command(0x1F);
   16eae:	201f      	movs	r0, #31
   16eb0:	f008 fed8 	bl	1fc64 <ssd1306_write_command>

    // Shift Mapping RAM Counter (0x00~0x3F)
    ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_OFFSET);
   16eb4:	20d3      	movs	r0, #211	; 0xd3
   16eb6:	f008 fed5 	bl	1fc64 <ssd1306_write_command>
    ssd1306_write_command(0x00);
   16eba:	2000      	movs	r0, #0
   16ebc:	f008 fed2 	bl	1fc64 <ssd1306_write_command>

    // Set Mapping RAM Display Start Line (0x00~0x3F)
    ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_START_LINE(0x00));
   16ec0:	2040      	movs	r0, #64	; 0x40
   16ec2:	f008 fecf 	bl	1fc64 <ssd1306_write_command>

    // Set Column Address 0 Mapped to SEG0
    ssd1306_write_command(SSD1306_CMD_SET_SEGMENT_RE_MAP_COL127_SEG0);
   16ec6:	20a1      	movs	r0, #161	; 0xa1
   16ec8:	f008 fecc 	bl	1fc64 <ssd1306_write_command>

    // Set COM/Row Scan Scan from COM63 to 0
    ssd1306_write_command(SSD1306_CMD_SET_COM_OUTPUT_SCAN_DOWN);
   16ecc:	20c8      	movs	r0, #200	; 0xc8
   16ece:	f008 fec9 	bl	1fc64 <ssd1306_write_command>

    // Set COM Pins hardware configuration
    ssd1306_write_command(SSD1306_CMD_SET_COM_PINS);
   16ed2:	20da      	movs	r0, #218	; 0xda
   16ed4:	f008 fec6 	bl	1fc64 <ssd1306_write_command>
    ssd1306_write_command(0x02);
   16ed8:	2002      	movs	r0, #2
   16eda:	f008 fec3 	bl	1fc64 <ssd1306_write_command>
     * \param contrast a number between 0 and 0xFF
     *
     * \retval contrast the contrast value written to the OLED controller
     */
    static inline uint8_t ssd1306_set_contrast(uint8_t contrast) {
        ssd1306_write_command(SSD1306_CMD_SET_CONTRAST_CONTROL_FOR_BANK0);
   16ede:	2081      	movs	r0, #129	; 0x81
   16ee0:	f008 fec0 	bl	1fc64 <ssd1306_write_command>
        ssd1306_write_command(contrast);
   16ee4:	208f      	movs	r0, #143	; 0x8f
   16ee6:	f008 febd 	bl	1fc64 <ssd1306_write_command>

    ssd1306_set_contrast(0x8F);

    // Disable Entire display On
    ssd1306_write_command(SSD1306_CMD_ENTIRE_DISPLAY_AND_GDDRAM_ON);
   16eea:	20a4      	movs	r0, #164	; 0xa4
   16eec:	f008 feba 	bl	1fc64 <ssd1306_write_command>
     *
     * This function will disable invert on all pixels on the OLED
     *
     */
    static inline void ssd1306_display_invert_disable(void) {
        ssd1306_write_command(SSD1306_CMD_SET_NORMAL_DISPLAY);
   16ef0:	20a6      	movs	r0, #166	; 0xa6
   16ef2:	f008 feb7 	bl	1fc64 <ssd1306_write_command>

    ssd1306_display_invert_disable();

    // Set Display Clock Divide Ratio / Oscillator Frequency (Default => 0x80)
    ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_CLOCK_DIVIDE_RATIO);
   16ef6:	20d5      	movs	r0, #213	; 0xd5
   16ef8:	f008 feb4 	bl	1fc64 <ssd1306_write_command>
    ssd1306_write_command(0x80);
   16efc:	2080      	movs	r0, #128	; 0x80
   16efe:	f008 feb1 	bl	1fc64 <ssd1306_write_command>

    // Enable charge pump regulator
    ssd1306_write_command(SSD1306_CMD_SET_CHARGE_PUMP_SETTING);
   16f02:	208d      	movs	r0, #141	; 0x8d
   16f04:	f008 feae 	bl	1fc64 <ssd1306_write_command>
    ssd1306_write_command(0x14);
   16f08:	2014      	movs	r0, #20
   16f0a:	f008 feab 	bl	1fc64 <ssd1306_write_command>

    // Set VCOMH Deselect Level
    ssd1306_write_command(SSD1306_CMD_SET_VCOMH_DESELECT_LEVEL);
   16f0e:	20db      	movs	r0, #219	; 0xdb
   16f10:	f008 fea8 	bl	1fc64 <ssd1306_write_command>
    ssd1306_write_command(0x40); // Default => 0x20 (0.77*VCC)
   16f14:	2040      	movs	r0, #64	; 0x40
   16f16:	f008 fea5 	bl	1fc64 <ssd1306_write_command>

    // Set Pre-Charge as 15 Clocks & Discharge as 1 Clock
    ssd1306_write_command(SSD1306_CMD_SET_PRE_CHARGE_PERIOD);
   16f1a:	20d9      	movs	r0, #217	; 0xd9
   16f1c:	f008 fea2 	bl	1fc64 <ssd1306_write_command>
    ssd1306_write_command(0xF1);
   16f20:	20f1      	movs	r0, #241	; 0xf1
   16f22:	f008 fe9f 	bl	1fc64 <ssd1306_write_command>
        ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_ON);
   16f26:	20af      	movs	r0, #175	; 0xaf
   16f28:	f008 fe9c 	bl	1fc64 <ssd1306_write_command>

    ssd1306_display_on();

    gfx_mono_draw_filled_rect(0, 0, 128, 32, GFX_PIXEL_SET);
   16f2c:	2301      	movs	r3, #1
   16f2e:	9300      	str	r3, [sp, #0]
   16f30:	2320      	movs	r3, #32
   16f32:	2280      	movs	r2, #128	; 0x80
   16f34:	2100      	movs	r1, #0
   16f36:	4608      	mov	r0, r1
   16f38:	f009 ff98 	bl	20e6c <gfx_mono_generic_draw_filled_rect>
    gfx_mono_draw_filled_rect(0, 0, 128, 32, GFX_PIXEL_CLR);
   16f3c:	2000      	movs	r0, #0
   16f3e:	9000      	str	r0, [sp, #0]
   16f40:	2320      	movs	r3, #32
   16f42:	2280      	movs	r2, #128	; 0x80
   16f44:	4601      	mov	r1, r0
   16f46:	f009 ff91 	bl	20e6c <gfx_mono_generic_draw_filled_rect>
}
   16f4a:	b003      	add	sp, #12
   16f4c:	bd30      	pop	{r4, r5, pc}
   16f4e:	bf00      	nop
   16f50:	41008000 	.word	0x41008000

Disassembly of section .text._DRV_ETHPHY_NegResultPhase_ANAD%352:

00016f54 <_DRV_ETHPHY_NegResultPhase_ANAD>:
        _DRV_PHY_SetOperPhase(hClientObj, DRV_ETHPHY_NEG_RESULT_PHASE_ANAD, 0);
    }
}

static void _DRV_ETHPHY_NegResultPhase_ANAD(DRV_ETHPHY_CLIENT_OBJ * hClientObj)
{
   16f54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16f56:	4604      	mov	r4, r0
    DRV_ETHPHY_LINK_STATUS  linkStat;
    TCPIP_ETH_OPEN_FLAGS   oFlags;
    TCPIP_ETH_PAUSE_TYPE   pauseType;

    // wait the ANAD read to complete
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   16f58:	f00b fcbc 	bl	228d4 <_DRV_PHY_SMITransfer_Wait>
   16f5c:	2800      	cmp	r0, #0
   16f5e:	d059      	beq.n	17014 <_DRV_ETHPHY_NegResultPhase_ANAD+0xc0>
    {
        return;
    }

    anadReg.w = hClientObj->smiData;
   16f60:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
    // restore ANEXP
    phyExp.w = hClientObj->operReg[0];
    // restore ANLPAD
    lpAD.w = hClientObj->operReg[1];
   16f62:	8ca5      	ldrh	r5, [r4, #36]	; 0x24

    oFlags = 0;   // don't know the result yet
    pauseType = TCPIP_ETH_PAUSE_TYPE_NONE;
    linkStat = DRV_ETHPHY_LINK_ST_UP;

    lcl_Pause  = (hClientObj->hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_PAUSE) ? 1 : 0;
   16f64:	68e2      	ldr	r2, [r4, #12]
   16f66:	7bd7      	ldrb	r7, [r2, #15]
    lcl_AsmDir = (hClientObj->hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_ASM_DIR) ? 1 : 0;
    lp_Pause   = lp_AsmDir = 0;         // in case negotiation failed

    if(phyExp.LP_AN_ABLE)
   16f68:	f894 2022 	ldrb.w	r2, [r4, #34]	; 0x22
   16f6c:	f012 0101 	ands.w	r1, r2, #1
   16f70:	d025      	beq.n	16fbe <_DRV_ETHPHY_NegResultPhase_ANAD+0x6a>
    {   // ok,valid auto negotiation info

        if(lpAD.REM_FAULT)
   16f72:	0a29      	lsrs	r1, r5, #8
   16f74:	f001 0220 	and.w	r2, r1, #32
        {
            linkStat |= DRV_ETHPHY_LINK_ST_REMOTE_FAULT;
   16f78:	2a00      	cmp	r2, #0
   16f7a:	bf0c      	ite	eq
   16f7c:	2001      	moveq	r0, #1
   16f7e:	2005      	movne	r0, #5
        }

        if(lpAD.PAUSE)
   16f80:	f011 0f04 	tst.w	r1, #4
        {
            linkStat |= DRV_ETHPHY_LINK_ST_LP_PAUSE;
   16f84:	bf1a      	itte	ne
   16f86:	f040 0010 	orrne.w	r0, r0, #16
            lp_Pause = 1;
   16f8a:	2601      	movne	r6, #1
    lp_Pause   = lp_AsmDir = 0;         // in case negotiation failed
   16f8c:	2600      	moveq	r6, #0
        }
        if(lpAD.ASM_DIR)
   16f8e:	f011 0f08 	tst.w	r1, #8
   16f92:	d021      	beq.n	16fd8 <_DRV_ETHPHY_NegResultPhase_ANAD+0x84>
        {
            linkStat |= DRV_ETHPHY_LINK_ST_LP_ASM_DIR;
   16f94:	f040 0020 	orr.w	r0, r0, #32
            lp_AsmDir = 1;
   16f98:	2201      	movs	r2, #1
        }
    }

    // set the PHY connection params
    // advertised capabilities & the matching ones
    anadReg.w &= lpAD.w;
   16f9a:	402b      	ands	r3, r5
    // get the settings, according to IEEE 802.3 Annex 28B.3 Priority Resolution
    // Note: we don't support 100BaseT4 !

    if(anadReg.w & _ANAD_BASE100TX_FDX_MASK)
   16f9c:	f413 7f80 	tst.w	r3, #256	; 0x100
   16fa0:	d121      	bne.n	16fe6 <_DRV_ETHPHY_NegResultPhase_ANAD+0x92>
    {
        oFlags = (TCPIP_ETH_OPEN_100|TCPIP_ETH_OPEN_FDUPLEX);
    }
    else if(anadReg.w & _ANAD_BASE100TX_MASK)
   16fa2:	f013 0f80 	tst.w	r3, #128	; 0x80
   16fa6:	d119      	bne.n	16fdc <_DRV_ETHPHY_NegResultPhase_ANAD+0x88>
    {
        oFlags = (TCPIP_ETH_OPEN_100 | TCPIP_ETH_OPEN_HDUPLEX);
    }
    else if(anadReg.w & _ANAD_BASE10T_FDX_MASK)
   16fa8:	f013 0f40 	tst.w	r3, #64	; 0x40
   16fac:	d133      	bne.n	17016 <_DRV_ETHPHY_NegResultPhase_ANAD+0xc2>
    {
        oFlags = (TCPIP_ETH_OPEN_10 | TCPIP_ETH_OPEN_FDUPLEX);
    }
    else if(anadReg.w & _ANAD_BASE10T_MASK)
   16fae:	f013 0320 	ands.w	r3, r3, #32
   16fb2:	d116      	bne.n	16fe2 <_DRV_ETHPHY_NegResultPhase_ANAD+0x8e>
        oFlags = (TCPIP_ETH_OPEN_10 | TCPIP_ETH_OPEN_HDUPLEX);
    }
    else
    {   // this should NOT happen!
        linkStat |= DRV_ETHPHY_LINK_ST_NEG_FATAL_ERR;
        linkStat &= ~DRV_ETHPHY_LINK_ST_UP;      // make sure we stop...!
   16fb4:	f020 0001 	bic.w	r0, r0, #1
   16fb8:	f440 5000 	orr.w	r0, r0, #8192	; 0x2000
   16fbc:	e00f      	b.n	16fde <_DRV_ETHPHY_NegResultPhase_ANAD+0x8a>
        if(phyExp.PDF)
   16fbe:	f002 0210 	and.w	r2, r2, #16
        linkStat |= DRV_ETHPHY_LINK_ST_LP_NEG_UNABLE;
   16fc2:	2a00      	cmp	r2, #0
   16fc4:	bf14      	ite	ne
   16fc6:	200b      	movne	r0, #11
   16fc8:	2003      	moveq	r0, #3
    anadReg.w &= lpAD.w;
   16fca:	402b      	ands	r3, r5
    if(anadReg.w & _ANAD_BASE100TX_FDX_MASK)
   16fcc:	f413 7f80 	tst.w	r3, #256	; 0x100
   16fd0:	d123      	bne.n	1701a <_DRV_ETHPHY_NegResultPhase_ANAD+0xc6>
   16fd2:	2200      	movs	r2, #0
   16fd4:	4616      	mov	r6, r2
   16fd6:	e7e4      	b.n	16fa2 <_DRV_ETHPHY_NegResultPhase_ANAD+0x4e>
    lp_Pause   = lp_AsmDir = 0;         // in case negotiation failed
   16fd8:	2200      	movs	r2, #0
   16fda:	e7de      	b.n	16f9a <_DRV_ETHPHY_NegResultPhase_ANAD+0x46>
        oFlags = (TCPIP_ETH_OPEN_100 | TCPIP_ETH_OPEN_HDUPLEX);
   16fdc:	230c      	movs	r3, #12
    pauseType = TCPIP_ETH_PAUSE_TYPE_NONE;
   16fde:	2100      	movs	r1, #0
   16fe0:	e00f      	b.n	17002 <_DRV_ETHPHY_NegResultPhase_ANAD+0xae>
        oFlags = (TCPIP_ETH_OPEN_10 | TCPIP_ETH_OPEN_HDUPLEX);
   16fe2:	2314      	movs	r3, #20
   16fe4:	e7fb      	b.n	16fde <_DRV_ETHPHY_NegResultPhase_ANAD+0x8a>
        oFlags = (TCPIP_ETH_OPEN_100|TCPIP_ETH_OPEN_FDUPLEX);
   16fe6:	230a      	movs	r3, #10
    lcl_Pause  = (hClientObj->hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_PAUSE) ? 1 : 0;
   16fe8:	f007 0501 	and.w	r5, r7, #1

    // set the pause type for the MAC
    // according to IEEE Std 802.3-2002 Tables 28B-2, 28B-3
    if(oFlags & TCPIP_ETH_OPEN_FDUPLEX)
    {   // pause type relevant for full duplex only
        if(lp_Pause & (lcl_Pause | (lcl_AsmDir & lp_AsmDir)))
   16fec:	ea02 0267 	and.w	r2, r2, r7, asr #1
   16ff0:	ea45 0102 	orr.w	r1, r5, r2
   16ff4:	4031      	ands	r1, r6
    pauseType = TCPIP_ETH_PAUSE_TYPE_NONE;
   16ff6:	0089      	lsls	r1, r1, #2
        {
            pauseType = TCPIP_ETH_PAUSE_TYPE_EN_TX;
        }
        if(lcl_Pause & (lp_Pause | (lcl_AsmDir & lp_AsmDir)))
   16ff8:	4332      	orrs	r2, r6
   16ffa:	422a      	tst	r2, r5
        {
            pauseType |= TCPIP_ETH_PAUSE_TYPE_EN_RX;
   16ffc:	bf18      	it	ne
   16ffe:	f041 0108 	orrne.w	r1, r1, #8


static void _DRV_PHY_NegResultSetOperResult(DRV_ETHPHY_CLIENT_OBJ* hClientObj, DRV_ETHPHY_LINK_STATUS linkStatus,
       TCPIP_ETH_OPEN_FLAGS openFlags, TCPIP_ETH_PAUSE_TYPE pauseType, DRV_ETHPHY_RESULT res)
{
    DRV_ETHPHY_NEGOTIATION_RESULT* pNegResult = (DRV_ETHPHY_NEGOTIATION_RESULT*)hClientObj->operParam;
   17002:	6b22      	ldr	r2, [r4, #48]	; 0x30

    if(pNegResult)
   17004:	b112      	cbz	r2, 1700c <_DRV_ETHPHY_NegResultPhase_ANAD+0xb8>
    {
        pNegResult->linkStatus = linkStatus;
   17006:	8010      	strh	r0, [r2, #0]
        pNegResult->linkFlags = openFlags;
   17008:	8053      	strh	r3, [r2, #2]
        pNegResult->pauseType = pauseType;
   1700a:	7111      	strb	r1, [r2, #4]
    }

    _DRV_PHY_SetOperDoneResult(hClientObj, res);
   1700c:	2100      	movs	r1, #0
   1700e:	4620      	mov	r0, r4
   17010:	f00a ff0c 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
}
   17014:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        oFlags = (TCPIP_ETH_OPEN_10 | TCPIP_ETH_OPEN_FDUPLEX);
   17016:	2312      	movs	r3, #18
   17018:	e7e6      	b.n	16fe8 <_DRV_ETHPHY_NegResultPhase_ANAD+0x94>
    lcl_Pause  = (hClientObj->hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_PAUSE) ? 1 : 0;
   1701a:	f007 0501 	and.w	r5, r7, #1
        oFlags = (TCPIP_ETH_OPEN_100|TCPIP_ETH_OPEN_FDUPLEX);
   1701e:	230a      	movs	r3, #10
    lcl_Pause  = (hClientObj->hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_PAUSE) ? 1 : 0;
   17020:	2600      	movs	r6, #0
        if(lp_Pause & (lcl_Pause | (lcl_AsmDir & lp_AsmDir)))
   17022:	4632      	mov	r2, r6
   17024:	e7e8      	b.n	16ff8 <_DRV_ETHPHY_NegResultPhase_ANAD+0xa4>

Disassembly of section .text.DRV_ETHPHY_Detect%353:

00017026 <DRV_ETHPHY_Detect>:
{
   17026:	b5f0      	push	{r4, r5, r6, r7, lr}
   17028:	b087      	sub	sp, #28
   1702a:	4606      	mov	r6, r0
   1702c:	460c      	mov	r4, r1
    uint16_t registerValue = 0;
   1702e:	2100      	movs	r1, #0
   17030:	f8ad 1016 	strh.w	r1, [sp, #22]
    LAN867X_REG_OBJ clientObj = {0};
   17034:	9100      	str	r1, [sp, #0]
   17036:	9101      	str	r1, [sp, #4]
    clientObj.miimBase = ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->pMiimBase;
   17038:	6923      	ldr	r3, [r4, #16]
   1703a:	9303      	str	r3, [sp, #12]
    clientObj.miimHandle = ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->miimHandle;
   1703c:	6963      	ldr	r3, [r4, #20]
   1703e:	9302      	str	r3, [sp, #8]
    clientObj.miimOpHandle = &((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->miimOpHandle;
   17040:	f104 0318 	add.w	r3, r4, #24
   17044:	9304      	str	r3, [sp, #16]
    pBaseObj->DRV_ETHPHY_PhyAddressGet(hClientObj, DRV_ETHPHY_INF_IDX_ALL_EXTERNAL,
   17046:	6a83      	ldr	r3, [r0, #40]	; 0x28
   17048:	466a      	mov	r2, sp
   1704a:	4620      	mov	r0, r4
   1704c:	4798      	blx	r3
    pBaseObj->DRV_ETHPHY_VendorDataGet(hClientObj, &clientObj.vendorData);
   1704e:	6cb3      	ldr	r3, [r6, #72]	; 0x48
   17050:	a901      	add	r1, sp, #4
   17052:	4620      	mov	r0, r4
   17054:	4798      	blx	r3
    state = R2F(clientObj.vendorData, VENDOR_STATE);
   17056:	f89d 5006 	ldrb.w	r5, [sp, #6]
    switch (state) {
   1705a:	b195      	cbz	r5, 17082 <DRV_ETHPHY_Detect+0x5c>
   1705c:	2d01      	cmp	r5, #1
   1705e:	d024      	beq.n	170aa <DRV_ETHPHY_Detect+0x84>
        ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->operRes = DRV_ETHPHY_RES_OK;
   17060:	2700      	movs	r7, #0
   17062:	f884 702c 	strb.w	r7, [r4, #44]	; 0x2c
        ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->miimOpHandle = 0;
   17066:	61a7      	str	r7, [r4, #24]
        ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
   17068:	86a7      	strh	r7, [r4, #52]	; 0x34
    clientObj.vendorData = F2R(state, VENDOR_STATE, clientObj.vendorData);
   1706a:	9901      	ldr	r1, [sp, #4]
   1706c:	f421 017f 	bic.w	r1, r1, #16711680	; 0xff0000
   17070:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
   17074:	9101      	str	r1, [sp, #4]
    pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, clientObj.vendorData);
   17076:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
   17078:	4620      	mov	r0, r4
   1707a:	4798      	blx	r3
}
   1707c:	4638      	mov	r0, r7
   1707e:	b007      	add	sp, #28
   17080:	bdf0      	pop	{r4, r5, r6, r7, pc}
        miimRes = Lan867x_Read_Register(&clientObj, PHY_REG_PHYID1, &registerValue);
   17082:	f10d 0216 	add.w	r2, sp, #22
   17086:	2102      	movs	r1, #2
   17088:	4668      	mov	r0, sp
   1708a:	f008 ff44 	bl	1ff16 <Lan867x_Read_Register>
        if (miimRes < 0) {
   1708e:	2800      	cmp	r0, #0
   17090:	db21      	blt.n	170d6 <DRV_ETHPHY_Detect+0xb0>
        } else if (miimRes != DRV_MIIM_RES_OK) {
   17092:	bb18      	cbnz	r0, 170dc <DRV_ETHPHY_Detect+0xb6>
            if (registerValue != (uint16_t)0x07) {
   17094:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   17098:	2b07      	cmp	r3, #7
   1709a:	d121      	bne.n	170e0 <DRV_ETHPHY_Detect+0xba>
                    F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj.vendorData);
   1709c:	9b01      	ldr	r3, [sp, #4]
   1709e:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
                clientObj.vendorData =
   170a2:	9301      	str	r3, [sp, #4]
                res = DRV_ETHPHY_RES_PENDING;
   170a4:	2701      	movs	r7, #1
                ++state;
   170a6:	463d      	mov	r5, r7
   170a8:	e7df      	b.n	1706a <DRV_ETHPHY_Detect+0x44>
        miimRes = Lan867x_Read_Register(&clientObj, PHY_REG_PHYID2, &registerValue);
   170aa:	f10d 0216 	add.w	r2, sp, #22
   170ae:	2103      	movs	r1, #3
   170b0:	4668      	mov	r0, sp
   170b2:	f008 ff30 	bl	1ff16 <Lan867x_Read_Register>
        if (miimRes < 0) {
   170b6:	2800      	cmp	r0, #0
   170b8:	db15      	blt.n	170e6 <DRV_ETHPHY_Detect+0xc0>
        } else if (miimRes != DRV_MIIM_RES_OK) {
   170ba:	b9b8      	cbnz	r0, 170ec <DRV_ETHPHY_Detect+0xc6>
            if (registerValue != (uint16_t)0xC162) {
   170bc:	f8bd 2016 	ldrh.w	r2, [sp, #22]
   170c0:	f24c 1362 	movw	r3, #49506	; 0xc162
   170c4:	429a      	cmp	r2, r3
   170c6:	d113      	bne.n	170f0 <DRV_ETHPHY_Detect+0xca>
                    F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj.vendorData);
   170c8:	9b01      	ldr	r3, [sp, #4]
   170ca:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
                clientObj.vendorData =
   170ce:	9301      	str	r3, [sp, #4]
                res = DRV_ETHPHY_RES_PENDING;
   170d0:	2701      	movs	r7, #1
                ++state;
   170d2:	2502      	movs	r5, #2
   170d4:	e7c9      	b.n	1706a <DRV_ETHPHY_Detect+0x44>
            res = DRV_ETHPHY_RES_MIIM_ERR;
   170d6:	f06f 070c 	mvn.w	r7, #12
   170da:	e7c6      	b.n	1706a <DRV_ETHPHY_Detect+0x44>
            res = DRV_ETHPHY_RES_PENDING;
   170dc:	2701      	movs	r7, #1
   170de:	e7c4      	b.n	1706a <DRV_ETHPHY_Detect+0x44>
                res = DRV_ETHPHY_RES_CPBL_ERR;
   170e0:	f06f 0702 	mvn.w	r7, #2
   170e4:	e7c1      	b.n	1706a <DRV_ETHPHY_Detect+0x44>
            res = DRV_ETHPHY_RES_MIIM_ERR;
   170e6:	f06f 070c 	mvn.w	r7, #12
   170ea:	e7be      	b.n	1706a <DRV_ETHPHY_Detect+0x44>
            res = DRV_ETHPHY_RES_PENDING;
   170ec:	2701      	movs	r7, #1
   170ee:	e7bc      	b.n	1706a <DRV_ETHPHY_Detect+0x44>
                res = DRV_ETHPHY_RES_CPBL_ERR;
   170f0:	f06f 0702 	mvn.w	r7, #2
   170f4:	e7b9      	b.n	1706a <DRV_ETHPHY_Detect+0x44>

Disassembly of section .text.DRV_GMAC_PacketTx%354:

000170f8 <DRV_GMAC_PacketTx>:
{
   170f8:	b538      	push	{r3, r4, r5, lr}
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   170fa:	4b2e      	ldr	r3, [pc, #184]	; (171b4 <DRV_GMAC_PacketTx+0xbc>)
   170fc:	4283      	cmp	r3, r0
   170fe:	d141      	bne.n	17184 <DRV_GMAC_PacketTx+0x8c>
   17100:	460c      	mov	r4, r1
    if(pMACDrv == 0)
   17102:	2800      	cmp	r0, #0
   17104:	d041      	beq.n	1718a <DRV_GMAC_PacketTx+0x92>
    if ((ptrPacket->pktPriority) >= DRV_GMAC_NUMBER_OF_QUEUES)
   17106:	f891 302d 	ldrb.w	r3, [r1, #45]	; 0x2d
   1710a:	2b00      	cmp	r3, #0
   1710c:	d140      	bne.n	17190 <DRV_GMAC_PacketTx+0x98>
	queueIdx = (GMAC_QUE_LIST)(pMACDrv->sGmacData.gmacConfig.txPrioNumToQueIndx[ptrPacket->pktPriority]);
   1710e:	4b29      	ldr	r3, [pc, #164]	; (171b4 <DRV_GMAC_PacketTx+0xbc>)
    else if(queueIdx >= DRV_GMAC_NUMBER_OF_QUEUES)
   17110:	f893 30e3 	ldrb.w	r3, [r3, #227]	; 0xe3
   17114:	3b01      	subs	r3, #1
   17116:	b2db      	uxtb	r3, r3
   17118:	2bfd      	cmp	r3, #253	; 0xfd
   1711a:	d93c      	bls.n	17196 <DRV_GMAC_PacketTx+0x9e>
	if(pMACDrv->sGmacData._synchF != 0)
   1711c:	4b25      	ldr	r3, [pc, #148]	; (171b4 <DRV_GMAC_PacketTx+0xbc>)
   1711e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   17120:	2b00      	cmp	r3, #0
   17122:	d040      	beq.n	171a6 <DRV_GMAC_PacketTx+0xae>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_LOCK);
   17124:	2103      	movs	r1, #3
   17126:	4824      	ldr	r0, [pc, #144]	; (171b8 <DRV_GMAC_PacketTx+0xc0>)
   17128:	4798      	blx	r3
        if(pSeg == 0)
   1712a:	6923      	ldr	r3, [r4, #16]
   1712c:	b16b      	cbz	r3, 1714a <DRV_GMAC_PacketTx+0x52>
            DRV_PIC32CGMAC_SingleListTailAdd(&pMACDrv->sGmacData.gmac_queue[queueIdx]._TxQueue, (DRV_PIC32CGMAC_SGL_LIST_NODE*)ptrPacket);
   1712e:	4d23      	ldr	r5, [pc, #140]	; (171bc <DRV_GMAC_PacketTx+0xc4>)
   17130:	4621      	mov	r1, r4
   17132:	4628      	mov	r0, r5
   17134:	f00c f912 	bl	2335c <DRV_PIC32CGMAC_SingleListTailAdd>
            ptrPacket->pktFlags |= TCPIP_MAC_PKT_FLAG_QUEUED;
   17138:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   1713a:	f043 0308 	orr.w	r3, r3, #8
   1713e:	8463      	strh	r3, [r4, #34]	; 0x22
            ptrPacket = ptrPacket->next;
   17140:	6824      	ldr	r4, [r4, #0]
	while(ptrPacket)
   17142:	b15c      	cbz	r4, 1715c <DRV_GMAC_PacketTx+0x64>
        if(pSeg == 0)
   17144:	6923      	ldr	r3, [r4, #16]
   17146:	2b00      	cmp	r3, #0
   17148:	d1f2      	bne.n	17130 <DRV_GMAC_PacketTx+0x38>
	if(pMACDrv->sGmacData._synchF != 0)
   1714a:	4b1a      	ldr	r3, [pc, #104]	; (171b4 <DRV_GMAC_PacketTx+0xbc>)
   1714c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   1714e:	b32b      	cbz	r3, 1719c <DRV_GMAC_PacketTx+0xa4>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_UNLOCK);
   17150:	2104      	movs	r1, #4
   17152:	4819      	ldr	r0, [pc, #100]	; (171b8 <DRV_GMAC_PacketTx+0xc0>)
   17154:	4798      	blx	r3
            return TCPIP_MAC_RES_PACKET_ERR;
   17156:	f06f 0009 	mvn.w	r0, #9
   1715a:	e015      	b.n	17188 <DRV_GMAC_PacketTx+0x90>
	_MacTxPendingPackets(pMACDrv,queueIdx);
   1715c:	4c15      	ldr	r4, [pc, #84]	; (171b4 <DRV_GMAC_PacketTx+0xbc>)
   1715e:	2100      	movs	r1, #0
   17160:	4620      	mov	r0, r4
   17162:	f004 feed 	bl	1bf40 <_MacTxPendingPackets>
    GMAC_REGS->GMAC_TSR = GMAC_TSR_TXCOMP_Msk;
   17166:	4b16      	ldr	r3, [pc, #88]	; (171c0 <DRV_GMAC_PacketTx+0xc8>)
   17168:	2220      	movs	r2, #32
   1716a:	615a      	str	r2, [r3, #20]
    DRV_PIC32CGMAC_LibTxAckPacket(pMACDrv,queueIdx);
   1716c:	2100      	movs	r1, #0
   1716e:	4620      	mov	r0, r4
   17170:	f7fb fb4c 	bl	1280c <DRV_PIC32CGMAC_LibTxAckPacket>
	if(pMACDrv->sGmacData._synchF != 0)
   17174:	6b23      	ldr	r3, [r4, #48]	; 0x30
   17176:	b1a3      	cbz	r3, 171a2 <DRV_GMAC_PacketTx+0xaa>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_UNLOCK);
   17178:	2104      	movs	r1, #4
   1717a:	f104 0060 	add.w	r0, r4, #96	; 0x60
   1717e:	4798      	blx	r3
	return TCPIP_MAC_RES_OK;
   17180:	2000      	movs	r0, #0
   17182:	e001      	b.n	17188 <DRV_GMAC_PacketTx+0x90>
        return TCPIP_MAC_RES_OP_ERR;
   17184:	f06f 0005 	mvn.w	r0, #5
}
   17188:	bd38      	pop	{r3, r4, r5, pc}
        return TCPIP_MAC_RES_OP_ERR;
   1718a:	f06f 0005 	mvn.w	r0, #5
   1718e:	e7fb      	b.n	17188 <DRV_GMAC_PacketTx+0x90>
        return TCPIP_MAC_RES_PACKET_ERR; 	        
   17190:	f06f 0009 	mvn.w	r0, #9
   17194:	e7f8      	b.n	17188 <DRV_GMAC_PacketTx+0x90>
        return TCPIP_MAC_RES_PACKET_ERR; 
   17196:	f06f 0009 	mvn.w	r0, #9
   1719a:	e7f5      	b.n	17188 <DRV_GMAC_PacketTx+0x90>
            return TCPIP_MAC_RES_PACKET_ERR;
   1719c:	f06f 0009 	mvn.w	r0, #9
   171a0:	e7f2      	b.n	17188 <DRV_GMAC_PacketTx+0x90>
	return TCPIP_MAC_RES_OK;
   171a2:	2000      	movs	r0, #0
   171a4:	e7f0      	b.n	17188 <DRV_GMAC_PacketTx+0x90>
        if(pSeg == 0)
   171a6:	690b      	ldr	r3, [r1, #16]
   171a8:	2b00      	cmp	r3, #0
   171aa:	d1c0      	bne.n	1712e <DRV_GMAC_PacketTx+0x36>
            return TCPIP_MAC_RES_PACKET_ERR;
   171ac:	f06f 0009 	mvn.w	r0, #9
   171b0:	e7ea      	b.n	17188 <DRV_GMAC_PacketTx+0x90>
   171b2:	bf00      	nop
   171b4:	2000e288 	.word	0x2000e288
   171b8:	2000e2e8 	.word	0x2000e2e8
   171bc:	2000e32c 	.word	0x2000e32c
   171c0:	42000800 	.word	0x42000800

Disassembly of section .text.TCPIP_TCP_ArrayGet%355:

000171c4 <TCPIP_TCP_ArrayGet>:
{
   171c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if(len == 0 || (pSkt= _TcpSocketChk(hTCP)) == 0 || (wGetReadyCount = _TCPIsGetReady(pSkt)) == 0)
   171c8:	4614      	mov	r4, r2
   171ca:	2a00      	cmp	r2, #0
   171cc:	d05a      	beq.n	17284 <TCPIP_TCP_ArrayGet+0xc0>
   171ce:	4688      	mov	r8, r1
   171d0:	f00a fea4 	bl	21f1c <_TcpSocketChk>
   171d4:	4605      	mov	r5, r0
   171d6:	2800      	cmp	r0, #0
   171d8:	d051      	beq.n	1727e <TCPIP_TCP_ArrayGet+0xba>
   171da:	f00b fe40 	bl	22e5e <_TCPIsGetReady>
   171de:	4607      	mov	r7, r0
   171e0:	2800      	cmp	r0, #0
   171e2:	d04e      	beq.n	17282 <TCPIP_TCP_ArrayGet+0xbe>
	if(len > wGetReadyCount)
   171e4:	4284      	cmp	r4, r0
   171e6:	bf28      	it	cs
   171e8:	4604      	movcs	r4, r0
   171ea:	b2a4      	uxth	r4, r4
	if(pSkt->rxTail + len > pSkt->rxEnd)
   171ec:	6a29      	ldr	r1, [r5, #32]
   171ee:	69ae      	ldr	r6, [r5, #24]
   171f0:	190b      	adds	r3, r1, r4
   171f2:	429e      	cmp	r6, r3
   171f4:	d229      	bcs.n	1724a <TCPIP_TCP_ArrayGet+0x86>
		RightLen = pSkt->rxEnd - pSkt->rxTail + 1;
   171f6:	1a76      	subs	r6, r6, r1
   171f8:	3601      	adds	r6, #1
   171fa:	b2b6      	uxth	r6, r6
		if(buffer)
   171fc:	f1b8 0f00 	cmp.w	r8, #0
   17200:	d004      	beq.n	1720c <TCPIP_TCP_ArrayGet+0x48>
			memcpy(buffer, (uint8_t*)pSkt->rxTail, RightLen);
   17202:	4632      	mov	r2, r6
   17204:	4640      	mov	r0, r8
   17206:	f00c f871 	bl	232ec <memcpy>
			buffer += RightLen;
   1720a:	44b0      	add	r8, r6
		len -= RightLen;
   1720c:	1ba4      	subs	r4, r4, r6
   1720e:	b2a4      	uxth	r4, r4
		pSkt->rxTail = pSkt->rxStart;
   17210:	696b      	ldr	r3, [r5, #20]
   17212:	622b      	str	r3, [r5, #32]
	if(buffer)
   17214:	f1b8 0f00 	cmp.w	r8, #0
   17218:	d004      	beq.n	17224 <TCPIP_TCP_ArrayGet+0x60>
		memcpy(buffer, (uint8_t*)pSkt->rxTail, len);
   1721a:	4622      	mov	r2, r4
   1721c:	6a29      	ldr	r1, [r5, #32]
   1721e:	4640      	mov	r0, r8
   17220:	f00c f864 	bl	232ec <memcpy>
	pSkt->rxTail += len;
   17224:	6a2b      	ldr	r3, [r5, #32]
   17226:	4423      	add	r3, r4
   17228:	622b      	str	r3, [r5, #32]
	len += RightLen;
   1722a:	4434      	add	r4, r6
   1722c:	b2a4      	uxth	r4, r4
    if(!_TCPSendWinIncUpdate(pSkt))
   1722e:	4628      	mov	r0, r5
   17230:	f007 fcde 	bl	1ebf0 <_TCPSendWinIncUpdate>
   17234:	bb30      	cbnz	r0, 17284 <TCPIP_TCP_ArrayGet+0xc0>
        if(wGetReadyCount - len <= len)
   17236:	1b3f      	subs	r7, r7, r4
   17238:	42bc      	cmp	r4, r7
   1723a:	db08      	blt.n	1724e <TCPIP_TCP_ArrayGet+0x8a>
            pSkt->Flags.bTXASAPWithoutTimerReset = 1;
   1723c:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
   17240:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   17244:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
   17248:	e01c      	b.n	17284 <TCPIP_TCP_ArrayGet+0xc0>
	uint16_t RightLen = 0;
   1724a:	2600      	movs	r6, #0
   1724c:	e7e2      	b.n	17214 <TCPIP_TCP_ArrayGet+0x50>
        else if(!pSkt->Flags.bTimer2Enabled)
   1724e:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
   17252:	f013 0f04 	tst.w	r3, #4
   17256:	d115      	bne.n	17284 <TCPIP_TCP_ArrayGet+0xc0>
            pSkt->Flags.bTimer2Enabled = true;
   17258:	f043 0304 	orr.w	r3, r3, #4
   1725c:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
            pSkt->eventTime2 = SYS_TMR_TickCountGet() + (TCPIP_TCP_WINDOW_UPDATE_TIMEOUT_VAL * SYS_TMR_TickCounterFrequencyGet())/1000;
   17260:	f00a ffec 	bl	2223c <SYS_TMR_TickCountGet>
   17264:	4606      	mov	r6, r0
   17266:	f00b f811 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
   1726a:	23c8      	movs	r3, #200	; 0xc8
   1726c:	fb03 f300 	mul.w	r3, r3, r0
   17270:	4806      	ldr	r0, [pc, #24]	; (1728c <TCPIP_TCP_ArrayGet+0xc8>)
   17272:	fba0 2303 	umull	r2, r3, r0, r3
   17276:	eb06 1393 	add.w	r3, r6, r3, lsr #6
   1727a:	62ab      	str	r3, [r5, #40]	; 0x28
   1727c:	e002      	b.n	17284 <TCPIP_TCP_ArrayGet+0xc0>
        return 0;
   1727e:	2400      	movs	r4, #0
   17280:	e000      	b.n	17284 <TCPIP_TCP_ArrayGet+0xc0>
   17282:	4604      	mov	r4, r0
}
   17284:	4620      	mov	r0, r4
   17286:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1728a:	bf00      	nop
   1728c:	10624dd3 	.word	0x10624dd3

Disassembly of section .rodata.tcpipCmdTbl%356:

00017290 <tcpipCmdTbl>:
   17290:	0000182c 0000f959 00001834 00001850     ,...Y...4...P...
   172a0:	00017b29 00001858 00001638 0000e725     ){..X...8...%...
   172b0:	00001874 00001508 00024323 0000188c     t.......#C......
   172c0:	000018a8 00024319 000018b0 000018c4     .....C..........
   172d0:	000175bd 000018cc 000018e0 00016791     .u...........g..
   172e0:	000018e8 00001904 0001a6cd 0000190c     ................
   172f0:	00001924 0001c559 0000192c 00001948     $...Y...,...H...
   17300:	00019859 00001950 00001964 00012971     Y...P...d...q)..
   17310:	00001968 00001988 00014831 00001990     h.......1H......
   17320:	000019a4 00015c55 000019b0 000019c4     ....U\..........
   17330:	0001695d 000019d0 000019f4 0000ec01     ]i..............
   17340:	000019fc 00001a14 00008a1d 00001a1c     ................
   17350:	00001a34 00011c3d 00001a3c              4...=...<...

Disassembly of section .text.TCPIP_HEAP_CreateInternal%357:

0001735c <TCPIP_HEAP_CreateInternal>:
{
   1735c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   17360:	4688      	mov	r8, r1
        if( pHeapConfig == 0)
   17362:	2800      	cmp	r0, #0
   17364:	d04b      	beq.n	173fe <TCPIP_HEAP_CreateInternal+0xa2>
   17366:	4606      	mov	r6, r0
        heapBufferSize = pHeapConfig->heapSize;
   17368:	6904      	ldr	r4, [r0, #16]
        allocatedHeapBuffer = (uint8_t*)(*pHeapConfig->malloc_fnc)(heapBufferSize);
   1736a:	6843      	ldr	r3, [r0, #4]
   1736c:	4620      	mov	r0, r4
   1736e:	4798      	blx	r3
        if(allocatedHeapBuffer == 0)
   17370:	4607      	mov	r7, r0
   17372:	2800      	cmp	r0, #0
   17374:	d047      	beq.n	17406 <TCPIP_HEAP_CreateInternal+0xaa>
        alignBuffer = ((uintptr_t)allocatedHeapBuffer + sizeof(_heap_Align)-1 ) & ~(sizeof(_heap_Align)-1);
   17376:	300f      	adds	r0, #15
   17378:	f020 000f 	bic.w	r0, r0, #15
        heapBufferSize -= (uint8_t*)alignBuffer - allocatedHeapBuffer ;
   1737c:	1bc1      	subs	r1, r0, r7
   1737e:	1a61      	subs	r1, r4, r1
        heapBufferSize &= ~(sizeof(_heap_Align)-1) ;
   17380:	f021 010f 	bic.w	r1, r1, #15
        heapSize = heapBufferSize - headerSize;
   17384:	f1a1 0950 	sub.w	r9, r1, #80	; 0x50
        if(heapUnits < _TCPIP_HEAP_MIN_BLKS_)
   17388:	f5b9 6f80 	cmp.w	r9, #1024	; 0x400
   1738c:	d33f      	bcc.n	1740e <TCPIP_HEAP_CreateInternal+0xb2>
        heapUnits = heapSize / sizeof(_headNode);           // adjust to multiple of heads
   1738e:	ea4f 1919 	mov.w	r9, r9, lsr #4
            alignHeapBuffer = (uint8_t*)_TCPIP_HEAP_BufferMapNonCached(alignHeapBuffer, heapBufferSize);
   17392:	f7fc fe4c 	bl	1402e <_TCPIP_HEAP_BufferMapNonCached>
   17396:	4604      	mov	r4, r0
        heapStart = alignHeapBuffer + headerSize; 
   17398:	f100 0e50 	add.w	lr, r0, #80	; 0x50
        hInst->heapObj = _tcpip_heap_object;
   1739c:	4605      	mov	r5, r0
   1739e:	f8df c084 	ldr.w	ip, [pc, #132]	; 17424 <TCPIP_HEAP_CreateInternal+0xc8>
   173a2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   173a6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   173a8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   173ac:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   173ae:	f8dc 3000 	ldr.w	r3, [ip]
   173b2:	602b      	str	r3, [r5, #0]
        hDcpt->_heapHead = (_headNode*)heapStart;
   173b4:	f8c4 e024 	str.w	lr, [r4, #36]	; 0x24
        hDcpt->_heapHead->units = heapUnits;
   173b8:	f8c4 9054 	str.w	r9, [r4, #84]	; 0x54
        hDcpt->_heapHead->next = 0;
   173bc:	2100      	movs	r1, #0
   173be:	6521      	str	r1, [r4, #80]	; 0x50
        hDcpt->_heapTail = hDcpt->_heapHead;
   173c0:	f8c4 e028 	str.w	lr, [r4, #40]	; 0x28
        hDcpt->_heapUnits = heapUnits;
   173c4:	f8c4 902c 	str.w	r9, [r4, #44]	; 0x2c
        hDcpt->_heapAllocatedUnits = 0;
   173c8:	6321      	str	r1, [r4, #48]	; 0x30
        hDcpt->_heapWatermark = 0;
   173ca:	6361      	str	r1, [r4, #52]	; 0x34
        hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_OK;
   173cc:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
        hDcpt->_heapFlags = pHeapConfig->heapFlags;
   173d0:	7873      	ldrb	r3, [r6, #1]
   173d2:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
        hDcpt->allocatedBuffer = allocatedHeapBuffer;
   173d6:	63e7      	str	r7, [r4, #60]	; 0x3c
        hDcpt->free_fnc = pHeapConfig->free_fnc;
   173d8:	68f3      	ldr	r3, [r6, #12]
   173da:	6423      	str	r3, [r4, #64]	; 0x40
        if(OSAL_SEM_Create(&hDcpt->_heapSemaphore, OSAL_SEM_TYPE_BINARY, 1, 1) != OSAL_RESULT_TRUE)
   173dc:	2301      	movs	r3, #1
   173de:	461a      	mov	r2, r3
   173e0:	f104 0044 	add.w	r0, r4, #68	; 0x44
   173e4:	f006 fb6c 	bl	1dac0 <OSAL_SEM_Create>
   173e8:	2801      	cmp	r0, #1
   173ea:	d101      	bne.n	173f0 <TCPIP_HEAP_CreateInternal+0x94>
        res = TCPIP_STACK_HEAP_RES_OK;
   173ec:	2300      	movs	r3, #0
   173ee:	e011      	b.n	17414 <TCPIP_HEAP_CreateInternal+0xb8>
            (*pHeapConfig->free_fnc)(allocatedHeapBuffer);
   173f0:	68f3      	ldr	r3, [r6, #12]
   173f2:	4638      	mov	r0, r7
   173f4:	4798      	blx	r3
            res = TCPIP_STACK_HEAP_RES_SYNCH_ERR;
   173f6:	f06f 0302 	mvn.w	r3, #2
            hInst = 0;
   173fa:	2400      	movs	r4, #0
            break;
   173fc:	e00a      	b.n	17414 <TCPIP_HEAP_CreateInternal+0xb8>
        hInst = 0;
   173fe:	4604      	mov	r4, r0
            res = TCPIP_STACK_HEAP_RES_INIT_ERR;
   17400:	f04f 33ff 	mov.w	r3, #4294967295
   17404:	e006      	b.n	17414 <TCPIP_HEAP_CreateInternal+0xb8>
        hInst = 0;
   17406:	4604      	mov	r4, r0
            res = TCPIP_STACK_HEAP_RES_CREATE_ERR;
   17408:	f06f 0301 	mvn.w	r3, #1
   1740c:	e002      	b.n	17414 <TCPIP_HEAP_CreateInternal+0xb8>
            res = TCPIP_STACK_HEAP_RES_BUFF_SIZE_ERR;
   1740e:	f06f 0303 	mvn.w	r3, #3
        hInst = 0;
   17412:	2400      	movs	r4, #0
    if(pRes)
   17414:	f1b8 0f00 	cmp.w	r8, #0
   17418:	d001      	beq.n	1741e <TCPIP_HEAP_CreateInternal+0xc2>
        *pRes = res;
   1741a:	f888 3000 	strb.w	r3, [r8]
}
   1741e:	4620      	mov	r0, r4
   17420:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   17424:	000225d4 	.word	0x000225d4

Disassembly of section .text.PORT_Initialize%358:

00017428 <PORT_Initialize>:
  Remarks:
    Refer plib_port.h file for more information.
*/

void PORT_Initialize(void)
{
   17428:	b430      	push	{r4, r5}
   /************************** GROUP 0 Initialization *************************/
   PORT_REGS->GROUP[0].PORT_OUT = 0x300;
   1742a:	4b30      	ldr	r3, [pc, #192]	; (174ec <PORT_Initialize+0xc4>)
   1742c:	f44f 7240 	mov.w	r2, #768	; 0x300
   17430:	611a      	str	r2, [r3, #16]
   PORT_REGS->GROUP[0].PORT_PINCFG[8] = 0x6;
   17432:	2406      	movs	r4, #6
   17434:	f883 4048 	strb.w	r4, [r3, #72]	; 0x48
   PORT_REGS->GROUP[0].PORT_PINCFG[9] = 0x6;
   17438:	f883 4049 	strb.w	r4, [r3, #73]	; 0x49
   PORT_REGS->GROUP[0].PORT_PINCFG[12] = 0x1;
   1743c:	2201      	movs	r2, #1
   1743e:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
   PORT_REGS->GROUP[0].PORT_PINCFG[13] = 0x1;
   17442:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
   PORT_REGS->GROUP[0].PORT_PINCFG[14] = 0x1;
   17446:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
   PORT_REGS->GROUP[0].PORT_PINCFG[15] = 0x1;
   1744a:	f883 204f 	strb.w	r2, [r3, #79]	; 0x4f
   PORT_REGS->GROUP[0].PORT_PINCFG[17] = 0x1;
   1744e:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
   PORT_REGS->GROUP[0].PORT_PINCFG[18] = 0x1;
   17452:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
   PORT_REGS->GROUP[0].PORT_PINCFG[19] = 0x1;
   17456:	f883 2053 	strb.w	r2, [r3, #83]	; 0x53

   PORT_REGS->GROUP[0].PORT_PMUX[6] = 0xbb;
   1745a:	20bb      	movs	r0, #187	; 0xbb
   1745c:	f883 0036 	strb.w	r0, [r3, #54]	; 0x36
   PORT_REGS->GROUP[0].PORT_PMUX[7] = 0xbb;
   17460:	f883 0037 	strb.w	r0, [r3, #55]	; 0x37
   PORT_REGS->GROUP[0].PORT_PMUX[8] = 0xb0;
   17464:	21b0      	movs	r1, #176	; 0xb0
   17466:	f883 1038 	strb.w	r1, [r3, #56]	; 0x38
   PORT_REGS->GROUP[0].PORT_PMUX[9] = 0xbb;
   1746a:	f883 0039 	strb.w	r0, [r3, #57]	; 0x39

   /************************** GROUP 1 Initialization *************************/
   PORT_REGS->GROUP[1].PORT_DIR = 0x1000c000;
   1746e:	4920      	ldr	r1, [pc, #128]	; (174f0 <PORT_Initialize+0xc8>)
   17470:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
   PORT_REGS->GROUP[1].PORT_PINCFG[14] = 0x0;
   17474:	2100      	movs	r1, #0
   17476:	f883 10ce 	strb.w	r1, [r3, #206]	; 0xce
   PORT_REGS->GROUP[1].PORT_PINCFG[15] = 0x0;
   1747a:	f883 10cf 	strb.w	r1, [r3, #207]	; 0xcf
   PORT_REGS->GROUP[1].PORT_PINCFG[24] = 0x1;
   1747e:	f883 20d8 	strb.w	r2, [r3, #216]	; 0xd8
   PORT_REGS->GROUP[1].PORT_PINCFG[25] = 0x1;
   17482:	f883 20d9 	strb.w	r2, [r3, #217]	; 0xd9
   PORT_REGS->GROUP[1].PORT_PINCFG[28] = 0x0;
   17486:	f883 10dc 	strb.w	r1, [r3, #220]	; 0xdc

   PORT_REGS->GROUP[1].PORT_PMUX[12] = 0x22;
   1748a:	2522      	movs	r5, #34	; 0x22
   1748c:	f883 50bc 	strb.w	r5, [r3, #188]	; 0xbc

   /************************** GROUP 2 Initialization *************************/
   PORT_REGS->GROUP[2].PORT_DIR = 0x1000000;
   17490:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000
   17494:	f8c3 5100 	str.w	r5, [r3, #256]	; 0x100
   PORT_REGS->GROUP[2].PORT_OUT = 0x1000000;
   17498:	f8c3 5110 	str.w	r5, [r3, #272]	; 0x110
   PORT_REGS->GROUP[2].PORT_PINCFG[20] = 0x1;
   1749c:	f883 2154 	strb.w	r2, [r3, #340]	; 0x154
   PORT_REGS->GROUP[2].PORT_PINCFG[22] = 0x1;
   174a0:	f883 2156 	strb.w	r2, [r3, #342]	; 0x156
   PORT_REGS->GROUP[2].PORT_PINCFG[23] = 0x1;
   174a4:	f883 2157 	strb.w	r2, [r3, #343]	; 0x157
   PORT_REGS->GROUP[2].PORT_PINCFG[24] = 0x0;
   174a8:	f883 1158 	strb.w	r1, [r3, #344]	; 0x158
   PORT_REGS->GROUP[2].PORT_PINCFG[27] = 0x1;
   174ac:	f883 215b 	strb.w	r2, [r3, #347]	; 0x15b
   PORT_REGS->GROUP[2].PORT_PINCFG[28] = 0x1;
   174b0:	f883 215c 	strb.w	r2, [r3, #348]	; 0x15c

   PORT_REGS->GROUP[2].PORT_PMUX[10] = 0xb;
   174b4:	220b      	movs	r2, #11
   174b6:	f883 213a 	strb.w	r2, [r3, #314]	; 0x13a
   PORT_REGS->GROUP[2].PORT_PMUX[11] = 0xbb;
   174ba:	f883 013b 	strb.w	r0, [r3, #315]	; 0x13b
   PORT_REGS->GROUP[2].PORT_PMUX[13] = 0x20;
   174be:	2220      	movs	r2, #32
   174c0:	f883 213d 	strb.w	r2, [r3, #317]	; 0x13d
   PORT_REGS->GROUP[2].PORT_PMUX[14] = 0x2;
   174c4:	2202      	movs	r2, #2
   174c6:	f883 213e 	strb.w	r2, [r3, #318]	; 0x13e

   /************************** GROUP 3 Initialization *************************/
   PORT_REGS->GROUP[3].PORT_DIR = 0x1400;
   174ca:	f44f 52a0 	mov.w	r2, #5120	; 0x1400
   174ce:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
   PORT_REGS->GROUP[3].PORT_OUT = 0x800;
   174d2:	f44f 6200 	mov.w	r2, #2048	; 0x800
   174d6:	f8c3 2190 	str.w	r2, [r3, #400]	; 0x190
   PORT_REGS->GROUP[3].PORT_PINCFG[10] = 0x0;
   174da:	f883 11ca 	strb.w	r1, [r3, #458]	; 0x1ca
   PORT_REGS->GROUP[3].PORT_PINCFG[11] = 0x6;
   174de:	f883 41cb 	strb.w	r4, [r3, #459]	; 0x1cb
   PORT_REGS->GROUP[3].PORT_PINCFG[12] = 0x0;
   174e2:	f883 11cc 	strb.w	r1, [r3, #460]	; 0x1cc


}
   174e6:	bc30      	pop	{r4, r5}
   174e8:	4770      	bx	lr
   174ea:	bf00      	nop
   174ec:	41008000 	.word	0x41008000
   174f0:	1000c000 	.word	0x1000c000

Disassembly of section .text.DRV_PIC32CGMAC_LibRxInit%359:

000174f4 <DRV_PIC32CGMAC_LibRxInit>:
{	   
   174f4:	b510      	push	{r4, lr}
   174f6:	4604      	mov	r4, r0
}DRV_PIC32CGMAC_SGL_LIST;	// single linked list

//Initialize Single List
static  __inline__ void  __attribute__((always_inline)) DRV_PIC32CGMAC_SingleListInitialize(DRV_PIC32CGMAC_SGL_LIST* pL)
{
    pL->head = pL->tail = 0;
   174f8:	2300      	movs	r3, #0
   174fa:	f8c0 3098 	str.w	r3, [r0, #152]	; 0x98
   174fe:	f8c0 3094 	str.w	r3, [r0, #148]	; 0x94
    pL->nNodes = 0;
   17502:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
        pRxPcktAlloc = (*pMACDrv->sGmacData._callocF)(pMACDrv->sGmacData._AllocH,pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt, sizeof(TCPIP_MAC_PACKET *));
   17506:	69c3      	ldr	r3, [r0, #28]
   17508:	2204      	movs	r2, #4
   1750a:	f8b0 10be 	ldrh.w	r1, [r0, #190]	; 0xbe
   1750e:	6980      	ldr	r0, [r0, #24]
   17510:	4798      	blx	r3
		if(pRxPcktAlloc == NULL)
   17512:	2800      	cmp	r0, #0
   17514:	d04c      	beq.n	175b0 <DRV_PIC32CGMAC_LibRxInit+0xbc>
        (pMACDrv->sGmacData.gmac_queue[queue_idx].pRxPckt) = pRxPcktAlloc;
   17516:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
		for(desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt; desc_idx++)
   1751a:	f8b4 30be 	ldrh.w	r3, [r4, #190]	; 0xbe
   1751e:	2b00      	cmp	r3, #0
   17520:	d044      	beq.n	175ac <DRV_PIC32CGMAC_LibRxInit+0xb8>
   17522:	2300      	movs	r3, #0
            pMACDrv->sGmacData.gmac_queue[queue_idx].nRxDescIndex = 0;
   17524:	461a      	mov	r2, r3
   17526:	f8a4 20b0 	strh.w	r2, [r4, #176]	; 0xb0
			pMACDrv->sGmacData.gmac_queue[queue_idx].pRxPckt[desc_idx] = 0;
   1752a:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
   1752e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
			pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc[desc_idx].rx_desc_buffaddr.val = 0;
   17532:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
   17536:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
			pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc[desc_idx].rx_desc_status.val = 0;
   1753a:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
   1753e:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
   17542:	604a      	str	r2, [r1, #4]
		for(desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt; desc_idx++)
   17544:	3301      	adds	r3, #1
   17546:	b2db      	uxtb	r3, r3
   17548:	f8b4 10be 	ldrh.w	r1, [r4, #190]	; 0xbe
   1754c:	4299      	cmp	r1, r3
   1754e:	d8ea      	bhi.n	17526 <DRV_PIC32CGMAC_LibRxInit+0x32>
		pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc[desc_idx-1].rx_desc_buffaddr.val |= GMAC_RX_WRAP_BIT;
   17550:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
   17554:	3b01      	subs	r3, #1
   17556:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
   1755a:	f851 2033 	ldr.w	r2, [r1, r3, lsl #3]
   1755e:	f042 0202 	orr.w	r2, r2, #2
   17562:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
        gmacRes = _AllocateRxPacket(pMACDrv, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDedicatedBuffers, queue_idx, GMAC_RX_STICKY_BUFFERS);	
   17566:	2301      	movs	r3, #1
   17568:	2200      	movs	r2, #0
   1756a:	f8b4 10c0 	ldrh.w	r1, [r4, #192]	; 0xc0
   1756e:	4620      	mov	r0, r4
   17570:	f004 ff50 	bl	1c414 <_AllocateRxPacket>
        if(gmacRes != DRV_PIC32CGMAC_RES_OK)
   17574:	4603      	mov	r3, r0
   17576:	b9b8      	cbnz	r0, 175a8 <DRV_PIC32CGMAC_LibRxInit+0xb4>
		gmacRes = _AllocateRxPacket(pMACDrv, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxAddlBuffCount, queue_idx, GMAC_RX_DYNAMIC_BUFFERS);	
   17578:	2300      	movs	r3, #0
   1757a:	461a      	mov	r2, r3
   1757c:	f8b4 10c2 	ldrh.w	r1, [r4, #194]	; 0xc2
   17580:	4620      	mov	r0, r4
   17582:	f004 ff47 	bl	1c414 <_AllocateRxPacket>
        if(gmacRes != DRV_PIC32CGMAC_RES_OK)
   17586:	4603      	mov	r3, r0
   17588:	b970      	cbnz	r0, 175a8 <DRV_PIC32CGMAC_LibRxInit+0xb4>
		gmacRes = DRV_PIC32CGMAC_LibRxBuffersAppend(pMACDrv, queue_idx,0,pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt);		
   1758a:	f8b4 30be 	ldrh.w	r3, [r4, #190]	; 0xbe
   1758e:	2200      	movs	r2, #0
   17590:	4611      	mov	r1, r2
   17592:	4620      	mov	r0, r4
   17594:	f7fd f8bc 	bl	14710 <DRV_PIC32CGMAC_LibRxBuffersAppend>
		if(gmacRes != DRV_PIC32CGMAC_RES_OK)
   17598:	4603      	mov	r3, r0
   1759a:	b928      	cbnz	r0, 175a8 <DRV_PIC32CGMAC_LibRxInit+0xb4>
		GMAC_REGS->GMAC_RBQB = GMAC_RBQB_ADDR_Msk & ((uint32_t)pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc);
   1759c:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
   175a0:	f022 0203 	bic.w	r2, r2, #3
   175a4:	4904      	ldr	r1, [pc, #16]	; (175b8 <DRV_PIC32CGMAC_LibRxInit+0xc4>)
   175a6:	618a      	str	r2, [r1, #24]
}//DRV_PIC32CGMAC_LibRxInit
   175a8:	4618      	mov	r0, r3
   175aa:	bd10      	pop	{r4, pc}
		for(desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt; desc_idx++)
   175ac:	2300      	movs	r3, #0
   175ae:	e7cf      	b.n	17550 <DRV_PIC32CGMAC_LibRxInit+0x5c>
			gmacRes = DRV_PIC32CGMAC_RES_OUT_OF_MEMORY;
   175b0:	f04f 33ff 	mov.w	r3, #4294967295
   175b4:	e7f8      	b.n	175a8 <DRV_PIC32CGMAC_LibRxInit+0xb4>
   175b6:	bf00      	nop
   175b8:	42000800 	.word	0x42000800

Disassembly of section .text._Command_DNSAddressSet%360:

000175bc <_Command_DNSAddressSet>:
{
   175bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   175c0:	b082      	sub	sp, #8
   175c2:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   175c4:	6845      	ldr	r5, [r0, #4]
    if (argc != 4)
   175c6:	2904      	cmp	r1, #4
   175c8:	d010      	beq.n	175ec <_Command_DNSAddressSet+0x30>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: setdns 1/2 <interface> <x.x.x.x> \r\n");
   175ca:	4e28      	ldr	r6, [pc, #160]	; (1766c <_Command_DNSAddressSet+0xb0>)
   175cc:	6803      	ldr	r3, [r0, #0]
   175ce:	681b      	ldr	r3, [r3, #0]
   175d0:	f606 71a8 	addw	r1, r6, #4008	; 0xfa8
   175d4:	4628      	mov	r0, r5
   175d6:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: setdns 1 eth0 255.255.255.0 \r\n");
   175d8:	6823      	ldr	r3, [r4, #0]
   175da:	681b      	ldr	r3, [r3, #0]
   175dc:	f606 71d4 	addw	r1, r6, #4052	; 0xfd4
   175e0:	4628      	mov	r0, r5
   175e2:	4798      	blx	r3
        return false;
   175e4:	2000      	movs	r0, #0
}
   175e6:	b002      	add	sp, #8
   175e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   175ec:	4616      	mov	r6, r2
    int dnsIx = atoi(argv[1]);
   175ee:	6850      	ldr	r0, [r2, #4]
   175f0:	f00c ff2a 	bl	24448 <atoi>
   175f4:	4607      	mov	r7, r0
    if(dnsIx != 1 && dnsIx != 2)
   175f6:	1e43      	subs	r3, r0, #1
   175f8:	2b01      	cmp	r3, #1
   175fa:	d906      	bls.n	1760a <_Command_DNSAddressSet+0x4e>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown DNS index\r\n");
   175fc:	6823      	ldr	r3, [r4, #0]
   175fe:	681b      	ldr	r3, [r3, #0]
   17600:	491b      	ldr	r1, [pc, #108]	; (17670 <_Command_DNSAddressSet+0xb4>)
   17602:	4628      	mov	r0, r5
   17604:	4798      	blx	r3
        return false;
   17606:	2000      	movs	r0, #0
   17608:	e7ed      	b.n	175e6 <_Command_DNSAddressSet+0x2a>
    netH = TCPIP_STACK_NetHandleGet(argv[2]);
   1760a:	68b0      	ldr	r0, [r6, #8]
   1760c:	f008 fa2a 	bl	1fa64 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
   17610:	4680      	mov	r8, r0
   17612:	b1c0      	cbz	r0, 17646 <_Command_DNSAddressSet+0x8a>
    if (!TCPIP_Helper_StringToIPAddress(argv[3], &ipDNS))
   17614:	a901      	add	r1, sp, #4
   17616:	68f0      	ldr	r0, [r6, #12]
   17618:	f7fd fa2a 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
   1761c:	b1d0      	cbz	r0, 17654 <_Command_DNSAddressSet+0x98>
    bool res = dnsIx == 1 ? TCPIP_STACK_NetAddressDnsPrimarySet(netH, &ipDNS) : TCPIP_STACK_NetAddressDnsSecondSet(netH, &ipDNS); 
   1761e:	2f01      	cmp	r7, #1
   17620:	d01f      	beq.n	17662 <_Command_DNSAddressSet+0xa6>
   17622:	a901      	add	r1, sp, #4
   17624:	4640      	mov	r0, r8
   17626:	f00b fd73 	bl	23110 <TCPIP_STACK_NetAddressDnsSecondSet>
    (*pCmdIO->pCmdApi->print)(cmdIoParam, "Set DNS %d address %s\r\n", dnsIx, res ? "success" : "failed");
   1762a:	6823      	ldr	r3, [r4, #0]
   1762c:	685c      	ldr	r4, [r3, #4]
   1762e:	2800      	cmp	r0, #0
   17630:	4b10      	ldr	r3, [pc, #64]	; (17674 <_Command_DNSAddressSet+0xb8>)
   17632:	f103 0208 	add.w	r2, r3, #8
   17636:	bf08      	it	eq
   17638:	4613      	moveq	r3, r2
   1763a:	463a      	mov	r2, r7
   1763c:	490e      	ldr	r1, [pc, #56]	; (17678 <_Command_DNSAddressSet+0xbc>)
   1763e:	4628      	mov	r0, r5
   17640:	47a0      	blx	r4
    return true;
   17642:	2001      	movs	r0, #1
   17644:	e7cf      	b.n	175e6 <_Command_DNSAddressSet+0x2a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   17646:	6823      	ldr	r3, [r4, #0]
   17648:	681b      	ldr	r3, [r3, #0]
   1764a:	490c      	ldr	r1, [pc, #48]	; (1767c <_Command_DNSAddressSet+0xc0>)
   1764c:	4628      	mov	r0, r5
   1764e:	4798      	blx	r3
        return false;
   17650:	2000      	movs	r0, #0
   17652:	e7c8      	b.n	175e6 <_Command_DNSAddressSet+0x2a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Invalid IP address string \r\n");
   17654:	6823      	ldr	r3, [r4, #0]
   17656:	681b      	ldr	r3, [r3, #0]
   17658:	4909      	ldr	r1, [pc, #36]	; (17680 <_Command_DNSAddressSet+0xc4>)
   1765a:	4628      	mov	r0, r5
   1765c:	4798      	blx	r3
        return false;
   1765e:	2000      	movs	r0, #0
   17660:	e7c1      	b.n	175e6 <_Command_DNSAddressSet+0x2a>
    bool res = dnsIx == 1 ? TCPIP_STACK_NetAddressDnsPrimarySet(netH, &ipDNS) : TCPIP_STACK_NetAddressDnsSecondSet(netH, &ipDNS); 
   17662:	a901      	add	r1, sp, #4
   17664:	4640      	mov	r0, r8
   17666:	f00b fd45 	bl	230f4 <TCPIP_STACK_NetAddressDnsPrimarySet>
   1766a:	e7de      	b.n	1762a <_Command_DNSAddressSet+0x6e>
   1766c:	0000028c 	.word	0x0000028c
   17670:	00001284 	.word	0x00001284
   17674:	00001224 	.word	0x00001224
   17678:	00001298 	.word	0x00001298
   1767c:	00000b80 	.word	0x00000b80
   17680:	000010e0 	.word	0x000010e0

Disassembly of section .text.gfx_mono_generic_draw_horizontal_line%361:

00017684 <gfx_mono_generic_draw_horizontal_line>:
        gfx_coord_t length, enum gfx_mono_color color) {
    uint8_t page;
    uint8_t pixelmask;
    uint8_t temp;

    if (x > GFX_MONO_LCD_WIDTH) {
   17684:	2880      	cmp	r0, #128	; 0x80
   17686:	d860      	bhi.n	1774a <gfx_mono_generic_draw_horizontal_line+0xc6>
        gfx_coord_t length, enum gfx_mono_color color) {
   17688:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1768c:	4606      	mov	r6, r0
        return;
    }

    /* Clip line length if too long */
    if (x + length > GFX_MONO_LCD_WIDTH) {
   1768e:	4410      	add	r0, r2
   17690:	2880      	cmp	r0, #128	; 0x80
        length = GFX_MONO_LCD_WIDTH - x;
   17692:	bfc4      	itt	gt
   17694:	f1c6 0480 	rsbgt	r4, r6, #128	; 0x80
   17698:	b2e2      	uxtbgt	r2, r4
    }

    page = y / 8;
    pixelmask = (1 << (y - (page * 8)));

    if (length == 0) {
   1769a:	b382      	cbz	r2, 176fe <gfx_mono_generic_draw_horizontal_line+0x7a>
    page = y / 8;
   1769c:	08cd      	lsrs	r5, r1, #3
    pixelmask = (1 << (y - (page * 8)));
   1769e:	eba1 01c5 	sub.w	r1, r1, r5, lsl #3
   176a2:	2701      	movs	r7, #1
   176a4:	fa07 f101 	lsl.w	r1, r7, r1
   176a8:	b2cf      	uxtb	r7, r1
        /* Nothing to do. Move along. */
        return;
    }

    switch (color) {
   176aa:	2b01      	cmp	r3, #1
   176ac:	d009      	beq.n	176c2 <gfx_mono_generic_draw_horizontal_line+0x3e>
   176ae:	b258      	sxtb	r0, r3
   176b0:	b168      	cbz	r0, 176ce <gfx_mono_generic_draw_horizontal_line+0x4a>
   176b2:	2b02      	cmp	r3, #2
   176b4:	d123      	bne.n	176fe <gfx_mono_generic_draw_horizontal_line+0x7a>
   176b6:	1e73      	subs	r3, r6, #1
   176b8:	18d4      	adds	r4, r2, r3
   176ba:	b2e4      	uxtb	r4, r4

        case GFX_PIXEL_XOR:
            while (length-- > 0) {
                temp = gfx_mono_get_byte(page, x + length);
                temp ^= pixelmask;
                gfx_mono_put_byte(page, x + length, temp);
   176bc:	f04f 0800 	mov.w	r8, #0
   176c0:	e032      	b.n	17728 <gfx_mono_generic_draw_horizontal_line+0xa4>
   176c2:	1e73      	subs	r3, r6, #1
   176c4:	18d4      	adds	r4, r2, r3
   176c6:	b2e4      	uxtb	r4, r4
                gfx_mono_put_byte(page, x + length, temp);
   176c8:	f04f 0800 	mov.w	r8, #0
   176cc:	e007      	b.n	176de <gfx_mono_generic_draw_horizontal_line+0x5a>
   176ce:	1e74      	subs	r4, r6, #1
   176d0:	4414      	add	r4, r2
   176d2:	b2e4      	uxtb	r4, r4
                temp &= ~pixelmask;
   176d4:	43cf      	mvns	r7, r1
                gfx_mono_put_byte(page, x + length, temp);
   176d6:	f04f 0800 	mov.w	r8, #0
   176da:	e013      	b.n	17704 <gfx_mono_generic_draw_horizontal_line+0x80>
   176dc:	461c      	mov	r4, r3
                temp = gfx_mono_get_byte(page, x + length);
   176de:	4621      	mov	r1, r4
   176e0:	4628      	mov	r0, r5
   176e2:	f00c fead 	bl	24440 <gfx_mono_ssd1306_get_byte>
                temp |= pixelmask;
   176e6:	ea47 0200 	orr.w	r2, r7, r0
                gfx_mono_put_byte(page, x + length, temp);
   176ea:	4643      	mov	r3, r8
   176ec:	b2d2      	uxtb	r2, r2
   176ee:	4621      	mov	r1, r4
   176f0:	4628      	mov	r0, r5
   176f2:	f007 ff8f 	bl	1f614 <gfx_mono_ssd1306_put_byte>
   176f6:	1e63      	subs	r3, r4, #1
   176f8:	b2db      	uxtb	r3, r3
            while (length-- > 0) {
   176fa:	42a6      	cmp	r6, r4
   176fc:	d1ee      	bne.n	176dc <gfx_mono_generic_draw_horizontal_line+0x58>
            break;

        default:
            break;
    }
}
   176fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   17702:	461c      	mov	r4, r3
                temp = gfx_mono_get_byte(page, x + length);
   17704:	4621      	mov	r1, r4
   17706:	4628      	mov	r0, r5
   17708:	f00c fe9a 	bl	24440 <gfx_mono_ssd1306_get_byte>
                temp &= ~pixelmask;
   1770c:	ea07 0200 	and.w	r2, r7, r0
                gfx_mono_put_byte(page, x + length, temp);
   17710:	4643      	mov	r3, r8
   17712:	b2d2      	uxtb	r2, r2
   17714:	4621      	mov	r1, r4
   17716:	4628      	mov	r0, r5
   17718:	f007 ff7c 	bl	1f614 <gfx_mono_ssd1306_put_byte>
   1771c:	1e63      	subs	r3, r4, #1
   1771e:	b2db      	uxtb	r3, r3
            while (length-- > 0) {
   17720:	42a6      	cmp	r6, r4
   17722:	d1ee      	bne.n	17702 <gfx_mono_generic_draw_horizontal_line+0x7e>
   17724:	e7eb      	b.n	176fe <gfx_mono_generic_draw_horizontal_line+0x7a>
   17726:	461c      	mov	r4, r3
                temp = gfx_mono_get_byte(page, x + length);
   17728:	4621      	mov	r1, r4
   1772a:	4628      	mov	r0, r5
   1772c:	f00c fe88 	bl	24440 <gfx_mono_ssd1306_get_byte>
                temp ^= pixelmask;
   17730:	ea87 0200 	eor.w	r2, r7, r0
                gfx_mono_put_byte(page, x + length, temp);
   17734:	4643      	mov	r3, r8
   17736:	b2d2      	uxtb	r2, r2
   17738:	4621      	mov	r1, r4
   1773a:	4628      	mov	r0, r5
   1773c:	f007 ff6a 	bl	1f614 <gfx_mono_ssd1306_put_byte>
   17740:	1e63      	subs	r3, r4, #1
   17742:	b2db      	uxtb	r3, r3
            while (length-- > 0) {
   17744:	42b4      	cmp	r4, r6
   17746:	d1ee      	bne.n	17726 <gfx_mono_generic_draw_horizontal_line+0xa2>
   17748:	e7d9      	b.n	176fe <gfx_mono_generic_draw_horizontal_line+0x7a>
   1774a:	4770      	bx	lr

Disassembly of section .text.__mdiff%362:

0001774c <__mdiff>:
   1774c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17750:	460d      	mov	r5, r1
   17752:	4607      	mov	r7, r0
   17754:	4611      	mov	r1, r2
   17756:	4628      	mov	r0, r5
   17758:	4614      	mov	r4, r2
   1775a:	f009 fbef 	bl	20f3c <__mcmp>
   1775e:	1e06      	subs	r6, r0, #0
   17760:	d108      	bne.n	17774 <__mdiff+0x28>
   17762:	4631      	mov	r1, r6
   17764:	4638      	mov	r0, r7
   17766:	f005 fa11 	bl	1cb8c <_Balloc>
   1776a:	2301      	movs	r3, #1
   1776c:	e9c0 3604 	strd	r3, r6, [r0, #16]
   17770:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   17774:	bfa4      	itt	ge
   17776:	4623      	movge	r3, r4
   17778:	462c      	movge	r4, r5
   1777a:	4638      	mov	r0, r7
   1777c:	6861      	ldr	r1, [r4, #4]
   1777e:	bfa6      	itte	ge
   17780:	461d      	movge	r5, r3
   17782:	2600      	movge	r6, #0
   17784:	2601      	movlt	r6, #1
   17786:	f005 fa01 	bl	1cb8c <_Balloc>
   1778a:	692b      	ldr	r3, [r5, #16]
   1778c:	6927      	ldr	r7, [r4, #16]
   1778e:	60c6      	str	r6, [r0, #12]
   17790:	f104 0214 	add.w	r2, r4, #20
   17794:	f105 0614 	add.w	r6, r5, #20
   17798:	eb02 0887 	add.w	r8, r2, r7, lsl #2
   1779c:	eb06 0e83 	add.w	lr, r6, r3, lsl #2
   177a0:	f100 0514 	add.w	r5, r0, #20
   177a4:	f04f 0a00 	mov.w	sl, #0
   177a8:	f64f 79ff 	movw	r9, #65535	; 0xffff
   177ac:	f852 bb04 	ldr.w	fp, [r2], #4
   177b0:	f856 3b04 	ldr.w	r3, [r6], #4
   177b4:	fa1a fa8b 	uxtah	sl, sl, fp
   177b8:	ea03 0109 	and.w	r1, r3, r9
   177bc:	0c1b      	lsrs	r3, r3, #16
   177be:	ebaa 0101 	sub.w	r1, sl, r1
   177c2:	ebc3 431b 	rsb	r3, r3, fp, lsr #16
   177c6:	eb03 4321 	add.w	r3, r3, r1, asr #16
   177ca:	ea01 0109 	and.w	r1, r1, r9
   177ce:	ea4f 4a23 	mov.w	sl, r3, asr #16
   177d2:	45b6      	cmp	lr, r6
   177d4:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
   177d8:	4694      	mov	ip, r2
   177da:	f845 3b04 	str.w	r3, [r5], #4
   177de:	d8e5      	bhi.n	177ac <__mdiff+0x60>
   177e0:	f64f 74ff 	movw	r4, #65535	; 0xffff
   177e4:	45c4      	cmp	ip, r8
   177e6:	d304      	bcc.n	177f2 <__mdiff+0xa6>
   177e8:	f855 3d04 	ldr.w	r3, [r5, #-4]!
   177ec:	b183      	cbz	r3, 17810 <__mdiff+0xc4>
   177ee:	6107      	str	r7, [r0, #16]
   177f0:	e7be      	b.n	17770 <__mdiff+0x24>
   177f2:	f85c 1b04 	ldr.w	r1, [ip], #4
   177f6:	fa1a f381 	uxtah	r3, sl, r1
   177fa:	141a      	asrs	r2, r3, #16
   177fc:	eb02 4211 	add.w	r2, r2, r1, lsr #16
   17800:	4023      	ands	r3, r4
   17802:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   17806:	ea4f 4a22 	mov.w	sl, r2, asr #16
   1780a:	f845 3b04 	str.w	r3, [r5], #4
   1780e:	e7e9      	b.n	177e4 <__mdiff+0x98>
   17810:	3f01      	subs	r7, #1
   17812:	e7e9      	b.n	177e8 <__mdiff+0x9c>

Disassembly of section .rodata.__mprec_tens%363:

00017818 <__mprec_tens>:
   17818:	0000 0000 0000 3ff0 0000 0000 0000 4024     .......?......$@
   17828:	0000 0000 0000 4059 0000 0000 4000 408f     ......Y@.....@.@
   17838:	0000 0000 8800 40c3 0000 0000 6a00 40f8     .......@.....j.@
   17848:	0000 0000 8480 412e 0000 0000 12d0 4163     .......A......cA
   17858:	0000 0000 d784 4197 0000 0000 cd65 41cd     .......A....e..A
   17868:	0000 2000 a05f 4202 0000 e800 4876 4237     ... _..B....vH7B
   17878:	0000 a200 1a94 426d 0000 e540 309c 42a2     ......mB..@..0.B
   17888:	0000 1e90 bcc4 42d6 0000 2634 6bf5 430c     .......B..4&.k.C
   17898:	8000 37e0 c379 4341 a000 85d8 3457 4376     ...7y.AC....W4vC
   178a8:	c800 674e c16d 43ab 3d00 6091 58e4 43e1     ..Ngm..C.=.`.X.C
   178b8:	8c40 78b5 af1d 4415 ef50 d6e2 1ae4 444b     @..x...DP.....KD
   178c8:	d592 064d f0cf 4480 4af6 c7e1 2d02 44b5     ..M....D.J...-.D
   178d8:	9db4 79d9 7843 44ea                         ...yCx.D

Disassembly of section .text._DRV_MIIM_StartOp%364:

000178e0 <_DRV_MIIM_StartOp>:
{
   178e0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   178e4:	460f      	mov	r7, r1
   178e6:	4690      	mov	r8, r2
   178e8:	469a      	mov	sl, r3
   178ea:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   178ec:	f89d 9030 	ldrb.w	r9, [sp, #48]	; 0x30
        if((pClient = _DRV_MIIM_GetClientAndLock(handle, true)) == 0)
   178f0:	2101      	movs	r1, #1
   178f2:	f006 feb2 	bl	1e65a <_DRV_MIIM_GetClientAndLock>
   178f6:	b3c8      	cbz	r0, 1796c <_DRV_MIIM_StartOp+0x8c>
   178f8:	4606      	mov	r6, r0
        pMiimObj = pClient->parentObj;
   178fa:	6844      	ldr	r4, [r0, #4]
        if(pSchedData->regIx > DRV_MIIM_MAX_REG_INDEX_VALUE)
   178fc:	2f1f      	cmp	r7, #31
   178fe:	d839      	bhi.n	17974 <_DRV_MIIM_StartOp+0x94>
        if(pSchedData->phyAdd > DRV_MIIM_MAX_ADDRESS_VALUE)
   17900:	f1b8 0f1f 	cmp.w	r8, #31
   17904:	d83e      	bhi.n	17984 <_DRV_MIIM_StartOp+0xa4>
        if((pMiimObj->objFlags & DRV_MIIM_OBJ_FLAG_SETUP_DONE) == 0)
   17906:	88a3      	ldrh	r3, [r4, #4]
   17908:	f013 0f02 	tst.w	r3, #2
   1790c:	d03d      	beq.n	1798a <_DRV_MIIM_StartOp+0xaa>
        if((pMiimObj->objFlags & DRV_MIIM_OBJ_FLAG_IS_SCANNING) != 0)
   1790e:	f013 0f08 	tst.w	r3, #8
   17912:	d002      	beq.n	1791a <_DRV_MIIM_StartOp+0x3a>
            res = DRV_MIIM_RES_OP_SCAN_ERR;
   17914:	f06f 0607 	mvn.w	r6, #7
   17918:	e039      	b.n	1798e <_DRV_MIIM_StartOp+0xae>
    DRV_MIIM_OP_DCPT* pOpDcpt = (DRV_MIIM_OP_DCPT*)Helper_SingleListHeadRemove(pL);
   1791a:	f104 0070 	add.w	r0, r4, #112	; 0x70
   1791e:	f00b fb5d 	bl	22fdc <Helper_SingleListHeadRemove>
        if(pOpDcpt == 0)
   17922:	4683      	mov	fp, r0
   17924:	b3e0      	cbz	r0, 179a0 <_DRV_MIIM_StartOp+0xc0>
        pOpDcpt->opType = pSchedData->opType;
   17926:	f880 9004 	strb.w	r9, [r0, #4]
        pOpDcpt->regIx = (uint8_t)pSchedData->regIx;
   1792a:	7147      	strb	r7, [r0, #5]
        pOpDcpt->phyAdd = (uint8_t)pSchedData->phyAdd;
   1792c:	f880 8006 	strb.w	r8, [r0, #6]
        pOpDcpt->opFlags = pSchedData->opFlags;
   17930:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
   17934:	71c3      	strb	r3, [r0, #7]
        pOpDcpt->opData = pSchedData->opData;
   17936:	f8a0 a008 	strh.w	sl, [r0, #8]
        pOpDcpt->opStat = DRV_MIIM_TXFER_START;
   1793a:	2301      	movs	r3, #1
   1793c:	7283      	strb	r3, [r0, #10]
        pOpDcpt->pOwner = pClient;
   1793e:	60c6      	str	r6, [r0, #12]
        if(pOpDcpt->opType == DRV_MIIM_OP_SCAN)
   17940:	f1b9 0f03 	cmp.w	r9, #3
   17944:	d00d      	beq.n	17962 <_DRV_MIIM_StartOp+0x82>
    Helper_SingleListTailAdd(pL, (SGL_LIST_NODE*)pOpDcpt);
   17946:	4659      	mov	r1, fp
   17948:	f104 007c 	add.w	r0, r4, #124	; 0x7c
   1794c:	f00b fd13 	bl	23376 <Helper_SingleListTailAdd>
    pOpDcpt->qType = qType;
   17950:	2302      	movs	r3, #2
   17952:	f88b 300b 	strb.w	r3, [fp, #11]
    OSAL_SEM_Post(&pMiimObj->objSem);
   17956:	4620      	mov	r0, r4
   17958:	f00b ff18 	bl	2378c <OSAL_SEM_Post>
        pSchedData->opHandle = opHandle;
   1795c:	465c      	mov	r4, fp
    OSAL_SEM_Post(&pMiimObj->objSem);
   1795e:	2600      	movs	r6, #0
   17960:	e019      	b.n	17996 <_DRV_MIIM_StartOp+0xb6>
            pMiimObj->objFlags |= DRV_MIIM_OBJ_FLAG_IS_SCANNING;
   17962:	88a3      	ldrh	r3, [r4, #4]
   17964:	f043 0308 	orr.w	r3, r3, #8
   17968:	80a3      	strh	r3, [r4, #4]
   1796a:	e7ec      	b.n	17946 <_DRV_MIIM_StartOp+0x66>
        opHandle = 0;
   1796c:	4604      	mov	r4, r0
            res = DRV_MIIM_RES_HANDLE_ERR;
   1796e:	f04f 36ff 	mov.w	r6, #4294967295
   17972:	e010      	b.n	17996 <_DRV_MIIM_StartOp+0xb6>
            res = DRV_MIIM_RES_REGISTER_ERR;
   17974:	f06f 0604 	mvn.w	r6, #4
    if(pMiimObj != 0)
   17978:	b16c      	cbz	r4, 17996 <_DRV_MIIM_StartOp+0xb6>
    OSAL_SEM_Post(&pMiimObj->objSem);
   1797a:	4620      	mov	r0, r4
   1797c:	f00b ff06 	bl	2378c <OSAL_SEM_Post>
        opHandle = 0;
   17980:	2400      	movs	r4, #0
   17982:	e008      	b.n	17996 <_DRV_MIIM_StartOp+0xb6>
            res = DRV_MIIM_RES_ADDRESS_ERR;
   17984:	f06f 0605 	mvn.w	r6, #5
   17988:	e7f6      	b.n	17978 <_DRV_MIIM_StartOp+0x98>
            res = DRV_MIIM_RES_SETUP_ERR;
   1798a:	f06f 0603 	mvn.w	r6, #3
    OSAL_SEM_Post(&pMiimObj->objSem);
   1798e:	4620      	mov	r0, r4
   17990:	f00b fefc 	bl	2378c <OSAL_SEM_Post>
        opHandle = 0;
   17994:	2400      	movs	r4, #0
    if(pOpResult)
   17996:	b105      	cbz	r5, 1799a <_DRV_MIIM_StartOp+0xba>
        *pOpResult = opRes;
   17998:	702e      	strb	r6, [r5, #0]
}
   1799a:	4620      	mov	r0, r4
   1799c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
            res = DRV_MIIM_RES_BUSY;
   179a0:	2602      	movs	r6, #2
   179a2:	e7f4      	b.n	1798e <_DRV_MIIM_StartOp+0xae>

Disassembly of section .text.TCPIP_UDP_OpenServerSkt%365:

000179a4 <TCPIP_UDP_OpenServerSkt>:
   if(addType == IP_ADDRESS_TYPE_IPV6)
   179a4:	2802      	cmp	r0, #2
   179a6:	d056      	beq.n	17a56 <TCPIP_UDP_OpenServerSkt+0xb2>
{
   179a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   179aa:	461d      	mov	r5, r3
   179ac:	4614      	mov	r4, r2
   179ae:	460e      	mov	r6, r1
   if(addType == IP_ADDRESS_TYPE_IPV4 && localAddress != 0)
   179b0:	b10a      	cbz	r2, 179b6 <TCPIP_UDP_OpenServerSkt+0x12>
       if(localAddress->v4Add.Val == 0)
   179b2:	6813      	ldr	r3, [r2, #0]
   179b4:	b9ab      	cbnz	r3, 179e2 <TCPIP_UDP_OpenServerSkt+0x3e>
    skt = _UDPOpen(addType, opType, localPort, 0);
   179b6:	2300      	movs	r3, #0
   179b8:	4632      	mov	r2, r6
   179ba:	4629      	mov	r1, r5
   179bc:	2001      	movs	r0, #1
   179be:	f7fb f93b 	bl	12c38 <_UDPOpen>
    if(skt != INVALID_UDP_SOCKET)
   179c2:	f1b0 3fff 	cmp.w	r0, #4294967295
   179c6:	d00b      	beq.n	179e0 <TCPIP_UDP_OpenServerSkt+0x3c>
        UDP_SOCKET_DCPT* pSkt = UDPSocketDcpt[skt];
   179c8:	4b26      	ldr	r3, [pc, #152]	; (17a64 <TCPIP_UDP_OpenServerSkt+0xc0>)
   179ca:	681b      	ldr	r3, [r3, #0]
   179cc:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    if((pSkt->pSktNet = pNet) != 0)
   179d0:	2200      	movs	r2, #0
   179d2:	625a      	str	r2, [r3, #36]	; 0x24
    pSkt->extFlags.rxEnable = 1;
   179d4:	f893 2042 	ldrb.w	r2, [r3, #66]	; 0x42
   179d8:	f042 0202 	orr.w	r2, r2, #2
   179dc:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
}
   179e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
           pDefIf = TCPIP_STACK_IPAddToNet(&localAddress->v4Add, false);
   179e2:	2100      	movs	r1, #0
   179e4:	4610      	mov	r0, r2
   179e6:	f00a fe2b 	bl	22640 <TCPIP_STACK_IPAddToNet>
           if(pDefIf == 0)
   179ea:	4607      	mov	r7, r0
   179ec:	b3b0      	cbz	r0, 17a5c <TCPIP_UDP_OpenServerSkt+0xb8>
    skt = _UDPOpen(addType, opType, localPort, 0);
   179ee:	2300      	movs	r3, #0
   179f0:	4632      	mov	r2, r6
   179f2:	4629      	mov	r1, r5
   179f4:	2001      	movs	r0, #1
   179f6:	f7fb f91f 	bl	12c38 <_UDPOpen>
    if(skt != INVALID_UDP_SOCKET)
   179fa:	f1b0 3fff 	cmp.w	r0, #4294967295
   179fe:	d0ef      	beq.n	179e0 <TCPIP_UDP_OpenServerSkt+0x3c>
        UDP_SOCKET_DCPT* pSkt = UDPSocketDcpt[skt];
   17a00:	4b18      	ldr	r3, [pc, #96]	; (17a64 <TCPIP_UDP_OpenServerSkt+0xc0>)
   17a02:	681b      	ldr	r3, [r3, #0]
   17a04:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    if((pSkt->pSktNet = pNet) != 0)
   17a08:	625f      	str	r7, [r3, #36]	; 0x24
        pSkt->flags.looseNetIf = 0;
   17a0a:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
   17a0e:	f36f 02c3 	bfc	r2, #3, #1
   17a12:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    return _UDPSetSourceAddress(pSkt, pSkt->addType, srcAddress);
   17a16:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
    while(pSkt->addType == addType)
   17a18:	b2d1      	uxtb	r1, r2
   17a1a:	428a      	cmp	r2, r1
   17a1c:	d00d      	beq.n	17a3a <TCPIP_UDP_OpenServerSkt+0x96>
        if(pDefIf != 0)
   17a1e:	b12f      	cbz	r7, 17a2c <TCPIP_UDP_OpenServerSkt+0x88>
            pSkt->flags.openBindIf = 1;
   17a20:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
   17a24:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   17a28:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
            pSkt->flags.openBindAdd = 1;
   17a2c:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
   17a30:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   17a34:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
   17a38:	e7cc      	b.n	179d4 <TCPIP_UDP_OpenServerSkt+0x30>
        if (addType == IP_ADDRESS_TYPE_IPV4)
   17a3a:	b2d2      	uxtb	r2, r2
   17a3c:	2a01      	cmp	r2, #1
   17a3e:	d1ee      	bne.n	17a1e <TCPIP_UDP_OpenServerSkt+0x7a>
            pSkt->srcAddress.Val = localAddress->v4Add.Val;
   17a40:	6822      	ldr	r2, [r4, #0]
   17a42:	619a      	str	r2, [r3, #24]
            pSkt->flags.srcSet = 1;
   17a44:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
            pSkt->flags.srcSolved = 0;
   17a48:	f042 0260 	orr.w	r2, r2, #96	; 0x60
   17a4c:	f36f 12c7 	bfc	r2, #7, #1
   17a50:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
            return true;
   17a54:	e7e3      	b.n	17a1e <TCPIP_UDP_OpenServerSkt+0x7a>
       return INVALID_SOCKET;
   17a56:	f04f 30ff 	mov.w	r0, #4294967295
}
   17a5a:	4770      	bx	lr
               return INVALID_UDP_SOCKET;
   17a5c:	f04f 30ff 	mov.w	r0, #4294967295
   17a60:	e7be      	b.n	179e0 <TCPIP_UDP_OpenServerSkt+0x3c>
   17a62:	bf00      	nop
   17a64:	2000ee88 	.word	0x2000ee88

Disassembly of section .text.TCPIP_TCP_Bind%366:

00017a68 <TCPIP_TCP_Bind>:
{
   17a68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   17a6c:	460d      	mov	r5, r1
   17a6e:	4616      	mov	r6, r2
   17a70:	461f      	mov	r7, r3
    pSkt = _TcpSocketChk(hTCP); 
   17a72:	f00a fa53 	bl	21f1c <_TcpSocketChk>
    if(pSkt == 0 || _TCP_IsConnected(pSkt))
   17a76:	2800      	cmp	r0, #0
   17a78:	d04c      	beq.n	17b14 <__MIN_HEAP_SIZE+0x54>
   17a7a:	4604      	mov	r4, r0
    return (pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1 || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2 || pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT);
   17a7c:	f890 206e 	ldrb.w	r2, [r0, #110]	; 0x6e
   17a80:	1ed3      	subs	r3, r2, #3
   17a82:	b2db      	uxtb	r3, r3
   17a84:	2b02      	cmp	r3, #2
   17a86:	d947      	bls.n	17b18 <__MIN_HEAP_SIZE+0x58>
    if(pSkt == 0 || _TCP_IsConnected(pSkt))
   17a88:	2a08      	cmp	r2, #8
   17a8a:	d049      	beq.n	17b20 <__MIN_HEAP_SIZE+0x60>
    if(pSkt->addType != IP_ADDRESS_TYPE_ANY && pSkt->addType != addType)
   17a8c:	f890 306f 	ldrb.w	r3, [r0, #111]	; 0x6f
   17a90:	b10b      	cbz	r3, 17a96 <TCPIP_TCP_Bind+0x2e>
   17a92:	42ab      	cmp	r3, r5
   17a94:	d146      	bne.n	17b24 <__MIN_HEAP_SIZE+0x64>
    if(localAddress != 0)
   17a96:	b15f      	cbz	r7, 17ab0 <TCPIP_TCP_Bind+0x48>
        if (addType == IP_ADDRESS_TYPE_IPV4)
   17a98:	2d01      	cmp	r5, #1
   17a9a:	d001      	beq.n	17aa0 <TCPIP_TCP_Bind+0x38>
            return false;
   17a9c:	2300      	movs	r3, #0
   17a9e:	e03c      	b.n	17b1a <__MIN_HEAP_SIZE+0x5a>
            pSktIf = TCPIP_STACK_IPAddToNet(&localAddress->v4Add, false);
   17aa0:	2100      	movs	r1, #0
   17aa2:	4638      	mov	r0, r7
   17aa4:	f00a fdcc 	bl	22640 <TCPIP_STACK_IPAddToNet>
        if(pSktIf == 0)
   17aa8:	4680      	mov	r8, r0
   17aaa:	b918      	cbnz	r0, 17ab4 <TCPIP_TCP_Bind+0x4c>
            return false;
   17aac:	2300      	movs	r3, #0
   17aae:	e034      	b.n	17b1a <__MIN_HEAP_SIZE+0x5a>
        pSktIf = pSkt->pSktNet;
   17ab0:	f8d4 8040 	ldr.w	r8, [r4, #64]	; 0x40
    if(localPort == 0)
   17ab4:	b1e6      	cbz	r6, 17af0 <__MIN_HEAP_SIZE+0x30>
    else if(localPort != pSkt->localPort && !_TCP_PortIsAvailable(localPort))
   17ab6:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
   17aba:	42b3      	cmp	r3, r6
   17abc:	d004      	beq.n	17ac8 <__MIN_HEAP_SIZE+0x8>
   17abe:	4630      	mov	r0, r6
   17ac0:	f007 ff30 	bl	1f924 <_TCP_PortIsAvailable>
   17ac4:	4603      	mov	r3, r0
   17ac6:	b340      	cbz	r0, 17b1a <__MIN_HEAP_SIZE+0x5a>
    pSkt->addType = addType;
   17ac8:	f884 506f 	strb.w	r5, [r4, #111]	; 0x6f
    pSkt->pSktNet = pNet;
   17acc:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
    _TCPSetSourceAddress(pSkt, pSkt->addType, srcAddress);
   17ad0:	463a      	mov	r2, r7
   17ad2:	4629      	mov	r1, r5
   17ad4:	4620      	mov	r0, r4
   17ad6:	f008 ff20 	bl	2091a <_TCPSetSourceAddress>
    pSkt->localPort = localPort;
   17ada:	f8a4 605a 	strh.w	r6, [r4, #90]	; 0x5a
    if(pSkt->Flags.bServer)
   17ade:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
   17ae2:	f013 0f01 	tst.w	r3, #1
   17ae6:	d00a      	beq.n	17afe <__MIN_HEAP_SIZE+0x3e>
        pSkt->remoteHash = localPort;
   17ae8:	f8a4 606a 	strh.w	r6, [r4, #106]	; 0x6a
    return true;
   17aec:	2301      	movs	r3, #1
   17aee:	e014      	b.n	17b1a <__MIN_HEAP_SIZE+0x5a>
        localPort = _TCP_EphemeralPortAllocate();
   17af0:	f008 fde0 	bl	206b4 <_TCP_EphemeralPortAllocate>
        if(localPort == 0)
   17af4:	4606      	mov	r6, r0
   17af6:	2800      	cmp	r0, #0
   17af8:	d1e6      	bne.n	17ac8 <__MIN_HEAP_SIZE+0x8>
            return false;
   17afa:	2300      	movs	r3, #0
   17afc:	e00d      	b.n	17b1a <__MIN_HEAP_SIZE+0x5a>
    return (pAdd->w[1] + pAdd->w[0] + pSkt->remotePort) ^ pSkt->localPort;
   17afe:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   17b00:	8f22      	ldrh	r2, [r4, #56]	; 0x38
   17b02:	4413      	add	r3, r2
   17b04:	f8b4 2058 	ldrh.w	r2, [r4, #88]	; 0x58
   17b08:	4413      	add	r3, r2
   17b0a:	405e      	eors	r6, r3
        pSkt->remoteHash = _TCP_ClientIPV4RemoteHash(&pSkt->destAddress, pSkt);
   17b0c:	f8a4 606a 	strh.w	r6, [r4, #106]	; 0x6a
    return true;
   17b10:	2301      	movs	r3, #1
   17b12:	e002      	b.n	17b1a <__MIN_HEAP_SIZE+0x5a>
        return false;
   17b14:	2300      	movs	r3, #0
   17b16:	e000      	b.n	17b1a <__MIN_HEAP_SIZE+0x5a>
   17b18:	2300      	movs	r3, #0
}
   17b1a:	4618      	mov	r0, r3
   17b1c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return false;
   17b20:	2300      	movs	r3, #0
   17b22:	e7fa      	b.n	17b1a <__MIN_HEAP_SIZE+0x5a>
        return false;
   17b24:	2300      	movs	r3, #0
   17b26:	e7f8      	b.n	17b1a <__MIN_HEAP_SIZE+0x5a>

Disassembly of section .text._Command_DefaultInterfaceSet%367:

00017b28 <_Command_DefaultInterfaceSet>:
{
   17b28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   17b2c:	b086      	sub	sp, #24
   17b2e:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   17b30:	6845      	ldr	r5, [r0, #4]
    while(argc >= 2)
   17b32:	2901      	cmp	r1, #1
   17b34:	dd0a      	ble.n	17b4c <_Command_DefaultInterfaceSet+0x24>
   17b36:	460e      	mov	r6, r1
   17b38:	4617      	mov	r7, r2
        if(strcmp(argv[1], "set") == 0)
   17b3a:	f8d2 8004 	ldr.w	r8, [r2, #4]
   17b3e:	4923      	ldr	r1, [pc, #140]	; (17bcc <_Command_DefaultInterfaceSet+0xa4>)
   17b40:	4640      	mov	r0, r8
   17b42:	f00c f85b 	bl	23bfc <strcmp>
   17b46:	bb50      	cbnz	r0, 17b9e <_Command_DefaultInterfaceSet+0x76>
            if(argc < 3)
   17b48:	2e02      	cmp	r6, #2
   17b4a:	dc10      	bgt.n	17b6e <_Command_DefaultInterfaceSet+0x46>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: defnet set/get <interface>\r\n");
   17b4c:	4e20      	ldr	r6, [pc, #128]	; (17bd0 <_Command_DefaultInterfaceSet+0xa8>)
   17b4e:	6823      	ldr	r3, [r4, #0]
   17b50:	681b      	ldr	r3, [r3, #0]
   17b52:	f506 7194 	add.w	r1, r6, #296	; 0x128
   17b56:	4628      	mov	r0, r5
   17b58:	4798      	blx	r3
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: defnet set eth0\r\n");
   17b5a:	6823      	ldr	r3, [r4, #0]
   17b5c:	681b      	ldr	r3, [r3, #0]
   17b5e:	f506 71a6 	add.w	r1, r6, #332	; 0x14c
   17b62:	4628      	mov	r0, r5
   17b64:	4798      	blx	r3
}
   17b66:	2000      	movs	r0, #0
   17b68:	b006      	add	sp, #24
   17b6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            netH = TCPIP_STACK_NetHandleGet(argv[2]);
   17b6e:	68b8      	ldr	r0, [r7, #8]
   17b70:	f007 ff78 	bl	1fa64 <TCPIP_STACK_NetHandleGet>
            if (netH == 0)
   17b74:	b168      	cbz	r0, 17b92 <_Command_DefaultInterfaceSet+0x6a>
            res = TCPIP_STACK_NetDefaultSet(netH);
   17b76:	f00b f853 	bl	22c20 <TCPIP_STACK_NetDefaultSet>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Default interface set %s\r\n", res ? "successful" : "failed!");
   17b7a:	6823      	ldr	r3, [r4, #0]
   17b7c:	685b      	ldr	r3, [r3, #4]
   17b7e:	2800      	cmp	r0, #0
   17b80:	4a14      	ldr	r2, [pc, #80]	; (17bd4 <_Command_DefaultInterfaceSet+0xac>)
   17b82:	f102 010c 	add.w	r1, r2, #12
   17b86:	bf08      	it	eq
   17b88:	460a      	moveq	r2, r1
   17b8a:	3110      	adds	r1, #16
   17b8c:	4628      	mov	r0, r5
   17b8e:	4798      	blx	r3
            break;
   17b90:	e7e9      	b.n	17b66 <_Command_DefaultInterfaceSet+0x3e>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   17b92:	6823      	ldr	r3, [r4, #0]
   17b94:	681b      	ldr	r3, [r3, #0]
   17b96:	4910      	ldr	r1, [pc, #64]	; (17bd8 <_Command_DefaultInterfaceSet+0xb0>)
   17b98:	4628      	mov	r0, r5
   17b9a:	4798      	blx	r3
                return false;
   17b9c:	e7e3      	b.n	17b66 <_Command_DefaultInterfaceSet+0x3e>
        else if(strcmp(argv[1], "get") == 0)
   17b9e:	490f      	ldr	r1, [pc, #60]	; (17bdc <_Command_DefaultInterfaceSet+0xb4>)
   17ba0:	4640      	mov	r0, r8
   17ba2:	f00c f82b 	bl	23bfc <strcmp>
   17ba6:	2800      	cmp	r0, #0
   17ba8:	d1d0      	bne.n	17b4c <_Command_DefaultInterfaceSet+0x24>
            netH = TCPIP_STACK_NetDefaultGet();
   17baa:	f00c fb3f 	bl	2422c <TCPIP_STACK_NetDefaultGet>
            nameSize = TCPIP_STACK_NetAliasNameGet(netH, nameBuff, sizeof(nameBuff));
   17bae:	2214      	movs	r2, #20
   17bb0:	a901      	add	r1, sp, #4
   17bb2:	f008 fcd5 	bl	20560 <TCPIP_STACK_NetAliasNameGet>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Default interface is: %s\r\n", nameSize ? nameBuff : "None");
   17bb6:	6823      	ldr	r3, [r4, #0]
   17bb8:	685b      	ldr	r3, [r3, #4]
   17bba:	b920      	cbnz	r0, 17bc6 <_Command_DefaultInterfaceSet+0x9e>
   17bbc:	4a08      	ldr	r2, [pc, #32]	; (17be0 <_Command_DefaultInterfaceSet+0xb8>)
   17bbe:	4909      	ldr	r1, [pc, #36]	; (17be4 <_Command_DefaultInterfaceSet+0xbc>)
   17bc0:	4628      	mov	r0, r5
   17bc2:	4798      	blx	r3
            break;
   17bc4:	e7cf      	b.n	17b66 <_Command_DefaultInterfaceSet+0x3e>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Default interface is: %s\r\n", nameSize ? nameBuff : "None");
   17bc6:	aa01      	add	r2, sp, #4
   17bc8:	e7f9      	b.n	17bbe <_Command_DefaultInterfaceSet+0x96>
   17bca:	bf00      	nop
   17bcc:	0000146c 	.word	0x0000146c
   17bd0:	00001384 	.word	0x00001384
   17bd4:	00001458 	.word	0x00001458
   17bd8:	00000b80 	.word	0x00000b80
   17bdc:	00001470 	.word	0x00001470
   17be0:	000012bc 	.word	0x000012bc
   17be4:	00001490 	.word	0x00001490

Disassembly of section .text.TCPIP_Helper_StringToMACAddress%368:

00017be8 <TCPIP_Helper_StringToMACAddress>:
  Return Values:
  	true - a MAC address was successfully decoded
  	false - no MAC address could be found, or the format was incorrect
  ***************************************************************************/
bool TCPIP_Helper_StringToMACAddress(const char* str, uint8_t macAddr[6])
{
   17be8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   17bec:	b083      	sub	sp, #12
    TCPIP_UINT16_VAL    hexDigit;
    uint8_t     convAddr[6];
    uint8_t*    pAdd;
    int         ix;
    
    if(macAddr)
   17bee:	4688      	mov	r8, r1
   17bf0:	b111      	cbz	r1, 17bf8 <TCPIP_Helper_StringToMACAddress+0x10>
    {
        memset(macAddr, 0, sizeof(convAddr));
   17bf2:	2300      	movs	r3, #0
   17bf4:	600b      	str	r3, [r1, #0]
   17bf6:	808b      	strh	r3, [r1, #4]
    }

    if(str == 0 || strlen(str) == 0)
   17bf8:	2800      	cmp	r0, #0
   17bfa:	d046      	beq.n	17c8a <TCPIP_Helper_StringToMACAddress+0xa2>
   17bfc:	7803      	ldrb	r3, [r0, #0]
   17bfe:	2b00      	cmp	r3, #0
   17c00:	d045      	beq.n	17c8e <TCPIP_Helper_StringToMACAddress+0xa6>

    beg = str;
    pAdd = convAddr;
    for(ix=0; ix<6; ix++)
    {
        if(!isxdigit(beg[0]) || !isxdigit(beg[1]))
   17c02:	4a28      	ldr	r2, [pc, #160]	; (17ca4 <TCPIP_Helper_StringToMACAddress+0xbc>)
   17c04:	5c9a      	ldrb	r2, [r3, r2]
   17c06:	f012 0f44 	tst.w	r2, #68	; 0x44
   17c0a:	d042      	beq.n	17c92 <TCPIP_Helper_StringToMACAddress+0xaa>
   17c0c:	7842      	ldrb	r2, [r0, #1]
   17c0e:	4925      	ldr	r1, [pc, #148]	; (17ca4 <TCPIP_Helper_StringToMACAddress+0xbc>)
   17c10:	5c51      	ldrb	r1, [r2, r1]
   17c12:	f011 0f44 	tst.w	r1, #68	; 0x44
   17c16:	d03e      	beq.n	17c96 <TCPIP_Helper_StringToMACAddress+0xae>
   17c18:	4604      	mov	r4, r0
    for(ix=0; ix<6; ix++)
   17c1a:	2500      	movs	r5, #0
    pAdd = convAddr;
   17c1c:	466f      	mov	r7, sp
        if(!isxdigit(beg[0]) || !isxdigit(beg[1]))
   17c1e:	f8df 9084 	ldr.w	r9, [pc, #132]	; 17ca4 <TCPIP_Helper_StringToMACAddress+0xbc>
   17c22:	e00f      	b.n	17c44 <TCPIP_Helper_StringToMACAddress+0x5c>
    for(ix=0; ix<6; ix++)
   17c24:	3501      	adds	r5, #1
   17c26:	2d06      	cmp	r5, #6
   17c28:	d01e      	beq.n	17c68 <TCPIP_Helper_StringToMACAddress+0x80>
        if(!isxdigit(beg[0]) || !isxdigit(beg[1]))
   17c2a:	78d3      	ldrb	r3, [r2, #3]
   17c2c:	f813 1009 	ldrb.w	r1, [r3, r9]
   17c30:	f011 0f44 	tst.w	r1, #68	; 0x44
   17c34:	d031      	beq.n	17c9a <TCPIP_Helper_StringToMACAddress+0xb2>
   17c36:	7912      	ldrb	r2, [r2, #4]
   17c38:	3403      	adds	r4, #3
   17c3a:	f812 1009 	ldrb.w	r1, [r2, r9]
   17c3e:	f011 0f44 	tst.w	r1, #68	; 0x44
   17c42:	d02c      	beq.n	17c9e <TCPIP_Helper_StringToMACAddress+0xb6>
        {
            return false;
        }

        // found valid byte
        hexDigit.v[0] = beg[1];
   17c44:	f362 0607 	bfi	r6, r2, #0, #8
        hexDigit.v[1] = beg[0];
   17c48:	f363 260f 	bfi	r6, r3, #8, #8
        *pAdd++ = hexatob(hexDigit.Val);
   17c4c:	b2b0      	uxth	r0, r6
   17c4e:	f008 f99e 	bl	1ff8e <hexatob>
   17c52:	f807 0b01 	strb.w	r0, [r7], #1

        // next colon number
        beg += 2;
        if(beg[0] == '\0')
   17c56:	4622      	mov	r2, r4
   17c58:	78a3      	ldrb	r3, [r4, #2]
   17c5a:	b12b      	cbz	r3, 17c68 <TCPIP_Helper_StringToMACAddress+0x80>
        {
            break;  // done
        }
        else if(beg[0] != ':' && beg[0] != '-')
   17c5c:	2b3a      	cmp	r3, #58	; 0x3a
   17c5e:	d0e1      	beq.n	17c24 <TCPIP_Helper_StringToMACAddress+0x3c>
   17c60:	2b2d      	cmp	r3, #45	; 0x2d
   17c62:	d0df      	beq.n	17c24 <TCPIP_Helper_StringToMACAddress+0x3c>
        {
            return false;   // invalid delimiter
   17c64:	2000      	movs	r0, #0
   17c66:	e00d      	b.n	17c84 <TCPIP_Helper_StringToMACAddress+0x9c>
        }
        beg++; // next digit
    }

    if(macAddr)
   17c68:	f1b8 0f00 	cmp.w	r8, #0
   17c6c:	d006      	beq.n	17c7c <TCPIP_Helper_StringToMACAddress+0x94>
    {
        memcpy(macAddr, convAddr, sizeof(convAddr));
   17c6e:	9800      	ldr	r0, [sp, #0]
   17c70:	f8c8 0000 	str.w	r0, [r8]
   17c74:	f8bd 3004 	ldrh.w	r3, [sp, #4]
   17c78:	f8a8 3004 	strh.w	r3, [r8, #4]
    }
    
    return ix == 5 ? true : false;    // false if not enough digits    
   17c7c:	2d05      	cmp	r5, #5
   17c7e:	bf14      	ite	ne
   17c80:	2000      	movne	r0, #0
   17c82:	2001      	moveq	r0, #1
    
}
   17c84:	b003      	add	sp, #12
   17c86:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return true;
   17c8a:	2001      	movs	r0, #1
   17c8c:	e7fa      	b.n	17c84 <TCPIP_Helper_StringToMACAddress+0x9c>
   17c8e:	2001      	movs	r0, #1
   17c90:	e7f8      	b.n	17c84 <TCPIP_Helper_StringToMACAddress+0x9c>
            return false;
   17c92:	2000      	movs	r0, #0
   17c94:	e7f6      	b.n	17c84 <TCPIP_Helper_StringToMACAddress+0x9c>
   17c96:	2000      	movs	r0, #0
   17c98:	e7f4      	b.n	17c84 <TCPIP_Helper_StringToMACAddress+0x9c>
   17c9a:	2000      	movs	r0, #0
   17c9c:	e7f2      	b.n	17c84 <TCPIP_Helper_StringToMACAddress+0x9c>
   17c9e:	2000      	movs	r0, #0
   17ca0:	e7f0      	b.n	17c84 <TCPIP_Helper_StringToMACAddress+0x9c>
   17ca2:	bf00      	nop
   17ca4:	00015855 	.word	0x00015855

Disassembly of section .text._DRV_MIIM_ClientDeallocate%369:

00017ca8 <_DRV_MIIM_ClientDeallocate>:


// de-allocates a client
// MIIM object should be locked
static void _DRV_MIIM_ClientDeallocate( DRV_MIIM_CLIENT_DCPT* pClient)
{
   17ca8:	b570      	push	{r4, r5, r6, lr}
   17caa:	b08a      	sub	sp, #40	; 0x28
   17cac:	4604      	mov	r4, r0
// all operations owned by this client
static void _DRV_MIIM_PurgeClientOp(DRV_MIIM_CLIENT_DCPT* pClient)
{
    DRV_MIIM_OP_DCPT* pOpDcpt;
    SINGLE_LIST delList, busyList, completeList;
    DRV_MIIM_OBJ* pMiimObj = pClient->parentObj;
   17cae:	6845      	ldr	r5, [r0, #4]

}

void  Helper_SingleListInitialize(SINGLE_LIST* pL)
{
    pL->head = pL->tail = 0;
   17cb0:	2300      	movs	r3, #0
   17cb2:	9302      	str	r3, [sp, #8]
   17cb4:	9301      	str	r3, [sp, #4]
    pL->nNodes = 0;
   17cb6:	9303      	str	r3, [sp, #12]
    pL->head = pL->tail = 0;
   17cb8:	9305      	str	r3, [sp, #20]
   17cba:	9304      	str	r3, [sp, #16]
    pL->nNodes = 0;
   17cbc:	9306      	str	r3, [sp, #24]
    pL->head = pL->tail = 0;
   17cbe:	9308      	str	r3, [sp, #32]
   17cc0:	9307      	str	r3, [sp, #28]
    pL->nNodes = 0;
   17cc2:	9309      	str	r3, [sp, #36]	; 0x24
    while((pOpDcpt = _DRV_MIIM_OpListRemove(&pMiimObj->busyOpList, DRV_MIIM_QTYPE_BUSY)) != 0)
   17cc4:	f105 067c 	add.w	r6, r5, #124	; 0x7c
    DRV_MIIM_OP_DCPT* pOpDcpt = (DRV_MIIM_OP_DCPT*)Helper_SingleListHeadRemove(pL);
   17cc8:	4630      	mov	r0, r6
   17cca:	f00b f987 	bl	22fdc <Helper_SingleListHeadRemove>
    while((pOpDcpt = _DRV_MIIM_OpListRemove(&pMiimObj->busyOpList, DRV_MIIM_QTYPE_BUSY)) != 0)
   17cce:	4601      	mov	r1, r0
   17cd0:	b138      	cbz	r0, 17ce2 <_DRV_MIIM_ClientDeallocate+0x3a>
        if(pOpDcpt->pOwner == pClient)
   17cd2:	68cb      	ldr	r3, [r1, #12]
   17cd4:	429c      	cmp	r4, r3
            Helper_SingleListTailAdd(&delList, (SGL_LIST_NODE*)pOpDcpt);
   17cd6:	bf0c      	ite	eq
   17cd8:	a801      	addeq	r0, sp, #4
            Helper_SingleListTailAdd(&busyList, (SGL_LIST_NODE*)pOpDcpt);
   17cda:	a804      	addne	r0, sp, #16
   17cdc:	f00b fb4b 	bl	23376 <Helper_SingleListTailAdd>
   17ce0:	e7f2      	b.n	17cc8 <_DRV_MIIM_ClientDeallocate+0x20>
    pMiimObj->busyOpList = busyList;
   17ce2:	f105 037c 	add.w	r3, r5, #124	; 0x7c
   17ce6:	aa04      	add	r2, sp, #16
   17ce8:	ca07      	ldmia	r2, {r0, r1, r2}
   17cea:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    while((pOpDcpt = (DRV_MIIM_OP_DCPT*)delList.head) != 0)
   17cee:	9901      	ldr	r1, [sp, #4]
   17cf0:	b141      	cbz	r1, 17d04 <_DRV_MIIM_ClientDeallocate+0x5c>
        _DRV_MIIM_ReleaseOpDcpt(pMiimObj, pOpDcpt, &delList, DRV_MIIM_QTYPE_BUSY);
   17cf2:	2602      	movs	r6, #2
   17cf4:	4633      	mov	r3, r6
   17cf6:	aa01      	add	r2, sp, #4
   17cf8:	4628      	mov	r0, r5
   17cfa:	f008 fbbd 	bl	20478 <_DRV_MIIM_ReleaseOpDcpt>
    while((pOpDcpt = (DRV_MIIM_OP_DCPT*)delList.head) != 0)
   17cfe:	9901      	ldr	r1, [sp, #4]
   17d00:	2900      	cmp	r1, #0
   17d02:	d1f7      	bne.n	17cf4 <_DRV_MIIM_ClientDeallocate+0x4c>
    while((pOpDcpt = _DRV_MIIM_OpListRemove(&pMiimObj->completeOpList, DRV_MIIM_QTYPE_COMPLETE)) != 0)
   17d04:	f105 0688 	add.w	r6, r5, #136	; 0x88
    DRV_MIIM_OP_DCPT* pOpDcpt = (DRV_MIIM_OP_DCPT*)Helper_SingleListHeadRemove(pL);
   17d08:	4630      	mov	r0, r6
   17d0a:	f00b f967 	bl	22fdc <Helper_SingleListHeadRemove>
    while((pOpDcpt = _DRV_MIIM_OpListRemove(&pMiimObj->completeOpList, DRV_MIIM_QTYPE_COMPLETE)) != 0)
   17d0e:	4601      	mov	r1, r0
   17d10:	b138      	cbz	r0, 17d22 <_DRV_MIIM_ClientDeallocate+0x7a>
        if(pOpDcpt->pOwner == pClient)
   17d12:	68cb      	ldr	r3, [r1, #12]
   17d14:	429c      	cmp	r4, r3
            Helper_SingleListTailAdd(&delList, (SGL_LIST_NODE*)pOpDcpt);
   17d16:	bf0c      	ite	eq
   17d18:	a801      	addeq	r0, sp, #4
            Helper_SingleListTailAdd(&completeList, (SGL_LIST_NODE*)pOpDcpt);
   17d1a:	a807      	addne	r0, sp, #28
   17d1c:	f00b fb2b 	bl	23376 <Helper_SingleListTailAdd>
   17d20:	e7f2      	b.n	17d08 <_DRV_MIIM_ClientDeallocate+0x60>
    pMiimObj->completeOpList = completeList;
   17d22:	f105 0388 	add.w	r3, r5, #136	; 0x88
   17d26:	aa0a      	add	r2, sp, #40	; 0x28
   17d28:	e912 0007 	ldmdb	r2, {r0, r1, r2}
   17d2c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    while((pOpDcpt = (DRV_MIIM_OP_DCPT*)delList.head) != 0)
   17d30:	9901      	ldr	r1, [sp, #4]
   17d32:	b141      	cbz	r1, 17d46 <_DRV_MIIM_ClientDeallocate+0x9e>
        _DRV_MIIM_ReleaseOpDcpt(pMiimObj, pOpDcpt, &delList, DRV_MIIM_QTYPE_COMPLETE);
   17d34:	2603      	movs	r6, #3
   17d36:	4633      	mov	r3, r6
   17d38:	aa01      	add	r2, sp, #4
   17d3a:	4628      	mov	r0, r5
   17d3c:	f008 fb9c 	bl	20478 <_DRV_MIIM_ReleaseOpDcpt>
    while((pOpDcpt = (DRV_MIIM_OP_DCPT*)delList.head) != 0)
   17d40:	9901      	ldr	r1, [sp, #4]
   17d42:	2900      	cmp	r1, #0
   17d44:	d1f7      	bne.n	17d36 <_DRV_MIIM_ClientDeallocate+0x8e>
    pClient->clientInUse = false ;
   17d46:	2300      	movs	r3, #0
   17d48:	8023      	strh	r3, [r4, #0]
    pClient->cliStatus = DRV_CLIENT_STATUS_ERROR;
   17d4a:	23ff      	movs	r3, #255	; 0xff
   17d4c:	7323      	strb	r3, [r4, #12]
    pClient->parentObj->numClients--;
   17d4e:	6862      	ldr	r2, [r4, #4]
   17d50:	88d3      	ldrh	r3, [r2, #6]
   17d52:	3b01      	subs	r3, #1
   17d54:	80d3      	strh	r3, [r2, #6]
    pClient->parentObj->objFlags &= ~DRV_MIIM_OBJ_FLAG_EXCLUSIVE;
   17d56:	6862      	ldr	r2, [r4, #4]
   17d58:	8893      	ldrh	r3, [r2, #4]
   17d5a:	f023 0304 	bic.w	r3, r3, #4
   17d5e:	8093      	strh	r3, [r2, #4]
}
   17d60:	b00a      	add	sp, #40	; 0x28
   17d62:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_IPV4_DeInitialize%370:

00017d64 <TCPIP_IPV4_DeInitialize>:
    if(ipv4InitCount > 0)
   17d64:	4b2b      	ldr	r3, [pc, #172]	; (17e14 <TCPIP_IPV4_DeInitialize+0xb0>)
   17d66:	881b      	ldrh	r3, [r3, #0]
   17d68:	b903      	cbnz	r3, 17d6c <TCPIP_IPV4_DeInitialize+0x8>
   17d6a:	4770      	bx	lr
{
   17d6c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   17d70:	b084      	sub	sp, #16
   17d72:	4607      	mov	r7, r0
        TCPIP_IPV4_ArpListPurge(stackCtrl->pNetIf);
   17d74:	6946      	ldr	r6, [r0, #20]
    TCPIP_Helper_SingleListInitialize (&newList);
   17d76:	a801      	add	r0, sp, #4
   17d78:	f00c fae2 	bl	24340 <TCPIP_Helper_SingleListInitialize>
    TCPIP_Helper_ProtectedSingleListLock(pList);
   17d7c:	4826      	ldr	r0, [pc, #152]	; (17e18 <TCPIP_IPV4_DeInitialize+0xb4>)
   17d7e:	f00a ff2f 	bl	22be0 <TCPIP_Helper_ProtectedSingleListLock>
    while((pEntry = (IPV4_ARP_ENTRY*)TCPIP_Helper_SingleListHeadRemove(&pList->list)) != 0)
   17d82:	f8df 9094 	ldr.w	r9, [pc, #148]	; 17e18 <TCPIP_IPV4_DeInitialize+0xb4>
            TCPIP_Helper_SingleListTailAdd(&ipv4ArpPool, (SGL_LIST_NODE*)pEntry); 
   17d86:	f8df 8094 	ldr.w	r8, [pc, #148]	; 17e1c <TCPIP_IPV4_DeInitialize+0xb8>
        TCPIP_PKT_PacketAcknowledge(pTxPkt, ackRes);
   17d8a:	f04f 0a03 	mov.w	sl, #3
   17d8e:	e00a      	b.n	17da6 <TCPIP_IPV4_DeInitialize+0x42>
            pMacPkt = &pEntry->pTxPkt->macPkt;
   17d90:	68a5      	ldr	r5, [r4, #8]
   17d92:	e013      	b.n	17dbc <TCPIP_IPV4_DeInitialize+0x58>
            if(pEntry->type == IPV4_ARP_PKT_TYPE_TX || pEntry->type == IPV4_ARP_PKT_TYPE_MAC)
   17d94:	7923      	ldrb	r3, [r4, #4]
   17d96:	3b01      	subs	r3, #1
   17d98:	b2db      	uxtb	r3, r3
   17d9a:	2b01      	cmp	r3, #1
   17d9c:	d91a      	bls.n	17dd4 <TCPIP_IPV4_DeInitialize+0x70>
            TCPIP_Helper_SingleListTailAdd(&ipv4ArpPool, (SGL_LIST_NODE*)pEntry); 
   17d9e:	4621      	mov	r1, r4
   17da0:	4640      	mov	r0, r8
   17da2:	f00b fb43 	bl	2342c <TCPIP_Helper_SingleListTailAdd>
    while((pEntry = (IPV4_ARP_ENTRY*)TCPIP_Helper_SingleListHeadRemove(&pList->list)) != 0)
   17da6:	4648      	mov	r0, r9
   17da8:	f00b f95e 	bl	23068 <TCPIP_Helper_SingleListHeadRemove>
   17dac:	4604      	mov	r4, r0
   17dae:	b1c0      	cbz	r0, 17de2 <TCPIP_IPV4_DeInitialize+0x7e>
        if(pEntry->type == IPV4_ARP_PKT_TYPE_TX)
   17db0:	7923      	ldrb	r3, [r4, #4]
   17db2:	2b01      	cmp	r3, #1
   17db4:	d0ec      	beq.n	17d90 <TCPIP_IPV4_DeInitialize+0x2c>
        else if(pEntry->type == IPV4_ARP_PKT_TYPE_MAC)
   17db6:	2b02      	cmp	r3, #2
   17db8:	d11c      	bne.n	17df4 <TCPIP_IPV4_DeInitialize+0x90>
            pMacPkt = pEntry->pMacPkt; 
   17dba:	68a5      	ldr	r5, [r4, #8]
        pPktIf = (TCPIP_NET_IF*)TCPIP_STACK_IndexToNet(pEntry->arpIfIx);
   17dbc:	7960      	ldrb	r0, [r4, #5]
   17dbe:	f00a f961 	bl	22084 <TCPIP_STACK_IndexToNet>
        if(pNetIf == 0 || pNetIf == pPktIf)
   17dc2:	2e00      	cmp	r6, #0
   17dc4:	d0e6      	beq.n	17d94 <TCPIP_IPV4_DeInitialize+0x30>
   17dc6:	4286      	cmp	r6, r0
   17dc8:	d0e4      	beq.n	17d94 <TCPIP_IPV4_DeInitialize+0x30>
            TCPIP_Helper_SingleListTailAdd(&newList, (SGL_LIST_NODE*)pEntry);
   17dca:	4621      	mov	r1, r4
   17dcc:	a801      	add	r0, sp, #4
   17dce:	f00b fb2d 	bl	2342c <TCPIP_Helper_SingleListTailAdd>
   17dd2:	e7e8      	b.n	17da6 <TCPIP_IPV4_DeInitialize+0x42>
        TCPIP_PKT_PacketAcknowledge(pTxPkt, ackRes);
   17dd4:	4652      	mov	r2, sl
   17dd6:	f06f 0104 	mvn.w	r1, #4
   17dda:	4628      	mov	r0, r5
   17ddc:	f007 fe62 	bl	1faa4 <_TCPIP_PKT_PacketAcknowledge>
   17de0:	e7dd      	b.n	17d9e <TCPIP_IPV4_DeInitialize+0x3a>
    pList->list = newList;
   17de2:	4b0d      	ldr	r3, [pc, #52]	; (17e18 <TCPIP_IPV4_DeInitialize+0xb4>)
   17de4:	aa04      	add	r2, sp, #16
   17de6:	e912 0007 	ldmdb	r2, {r0, r1, r2}
   17dea:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    TCPIP_Helper_ProtectedSingleListUnlock(pList);
   17dee:	4618      	mov	r0, r3
   17df0:	f00b f948 	bl	23084 <TCPIP_Helper_ProtectedSingleListUnlock>
        if(stackCtrl->stackAction == TCPIP_STACK_ACTION_DEINIT)
   17df4:	7f3b      	ldrb	r3, [r7, #28]
   17df6:	2b02      	cmp	r3, #2
   17df8:	d002      	beq.n	17e00 <TCPIP_IPV4_DeInitialize+0x9c>
}
   17dfa:	b004      	add	sp, #16
   17dfc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            if (--ipv4InitCount == 0)
   17e00:	4a04      	ldr	r2, [pc, #16]	; (17e14 <TCPIP_IPV4_DeInitialize+0xb0>)
   17e02:	8813      	ldrh	r3, [r2, #0]
   17e04:	3b01      	subs	r3, #1
   17e06:	b29b      	uxth	r3, r3
   17e08:	8013      	strh	r3, [r2, #0]
   17e0a:	2b00      	cmp	r3, #0
   17e0c:	d1f5      	bne.n	17dfa <TCPIP_IPV4_DeInitialize+0x96>
                TCPIP_IPV4_Cleanup();
   17e0e:	f004 f9eb 	bl	1c1e8 <TCPIP_IPV4_Cleanup>
}
   17e12:	e7f2      	b.n	17dfa <TCPIP_IPV4_DeInitialize+0x96>
   17e14:	2000ef7a 	.word	0x2000ef7a
   17e18:	2000ec3c 	.word	0x2000ec3c
   17e1c:	2000ed4c 	.word	0x2000ed4c

Disassembly of section .text.TCPIP_STACK_KillStack%371:

00017e20 <TCPIP_STACK_KillStack>:
{
   17e20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (tcpip_stack_tickH != SYS_TMR_HANDLE_INVALID)
   17e24:	4b26      	ldr	r3, [pc, #152]	; (17ec0 <TCPIP_STACK_KillStack+0xa0>)
   17e26:	6818      	ldr	r0, [r3, #0]
   17e28:	f1b0 3fff 	cmp.w	r0, #4294967295
   17e2c:	d137      	bne.n	17e9e <TCPIP_STACK_KillStack+0x7e>
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   17e2e:	4b25      	ldr	r3, [pc, #148]	; (17ec4 <TCPIP_STACK_KillStack+0xa4>)
   17e30:	681c      	ldr	r4, [r3, #0]
   17e32:	4b25      	ldr	r3, [pc, #148]	; (17ec8 <TCPIP_STACK_KillStack+0xa8>)
   17e34:	681b      	ldr	r3, [r3, #0]
   17e36:	2b00      	cmp	r3, #0
   17e38:	dd0f      	ble.n	17e5a <TCPIP_STACK_KillStack+0x3a>
   17e3a:	2500      	movs	r5, #0
        TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pNetIf, TCPIP_STACK_ACTION_DEINIT, TCPIP_MAC_POWER_DOWN);
   17e3c:	4e22      	ldr	r6, [pc, #136]	; (17ec8 <TCPIP_STACK_KillStack+0xa8>)
   17e3e:	f04f 0803 	mov.w	r8, #3
   17e42:	2702      	movs	r7, #2
   17e44:	4643      	mov	r3, r8
   17e46:	463a      	mov	r2, r7
   17e48:	4621      	mov	r1, r4
   17e4a:	4630      	mov	r0, r6
   17e4c:	f004 ffcc 	bl	1cde8 <TCPIP_STACK_BringNetDown>
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   17e50:	3501      	adds	r5, #1
   17e52:	346c      	adds	r4, #108	; 0x6c
   17e54:	6833      	ldr	r3, [r6, #0]
   17e56:	42ab      	cmp	r3, r5
   17e58:	dcf4      	bgt.n	17e44 <TCPIP_STACK_KillStack+0x24>
    TCPIP_PKT_Deinitialize();
   17e5a:	f00c f9f9 	bl	24250 <TCPIP_PKT_Deinitialize>
    if(tcpip_stack_ctrl_data.memH != 0)
   17e5e:	4b1a      	ldr	r3, [pc, #104]	; (17ec8 <TCPIP_STACK_KillStack+0xa8>)
   17e60:	68d8      	ldr	r0, [r3, #12]
   17e62:	b148      	cbz	r0, 17e78 <TCPIP_STACK_KillStack+0x58>
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   17e64:	68c3      	ldr	r3, [r0, #12]
   17e66:	4a17      	ldr	r2, [pc, #92]	; (17ec4 <TCPIP_STACK_KillStack+0xa4>)
   17e68:	6811      	ldr	r1, [r2, #0]
   17e6a:	4798      	blx	r3
        if(TCPIP_HEAP_Delete(tcpip_stack_ctrl_data.memH) < 0)     // destroy the heap
   17e6c:	4b16      	ldr	r3, [pc, #88]	; (17ec8 <TCPIP_STACK_KillStack+0xa8>)
   17e6e:	68d8      	ldr	r0, [r3, #12]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Delete)(h);
   17e70:	6803      	ldr	r3, [r0, #0]
   17e72:	4798      	blx	r3
   17e74:	2800      	cmp	r0, #0
   17e76:	db19      	blt.n	17eac <TCPIP_STACK_KillStack+0x8c>
    tcpip_stack_ctrl_data.memH = 0;
   17e78:	4a13      	ldr	r2, [pc, #76]	; (17ec8 <TCPIP_STACK_KillStack+0xa8>)
   17e7a:	2300      	movs	r3, #0
   17e7c:	60d3      	str	r3, [r2, #12]
    tcpip_stack_ctrl_data.heapType = 0;
   17e7e:	7413      	strb	r3, [r2, #16]
    tcpipNetIf = 0;
   17e80:	4910      	ldr	r1, [pc, #64]	; (17ec4 <TCPIP_STACK_KillStack+0xa4>)
   17e82:	600b      	str	r3, [r1, #0]
    tcpip_stack_ctrl_data.nIfs = 0;
   17e84:	6013      	str	r3, [r2, #0]
    tcpip_stack_ctrl_data.nModules = 0;
   17e86:	6093      	str	r3, [r2, #8]
    tcpip_stack_status = SYS_STATUS_UNINITIALIZED;
   17e88:	4a10      	ldr	r2, [pc, #64]	; (17ecc <TCPIP_STACK_KillStack+0xac>)
   17e8a:	7013      	strb	r3, [r2, #0]
    stackAsyncSignalCount = 0;
   17e8c:	4a10      	ldr	r2, [pc, #64]	; (17ed0 <TCPIP_STACK_KillStack+0xb0>)
   17e8e:	6013      	str	r3, [r2, #0]
    memset(&tcpip_heap_config, 0, sizeof(tcpip_heap_config));
   17e90:	4a10      	ldr	r2, [pc, #64]	; (17ed4 <TCPIP_STACK_KillStack+0xb4>)
   17e92:	6013      	str	r3, [r2, #0]
   17e94:	6053      	str	r3, [r2, #4]
   17e96:	6093      	str	r3, [r2, #8]
   17e98:	60d3      	str	r3, [r2, #12]
}
   17e9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    
*/

static __inline__ void  __attribute__((always_inline)) SYS_TMR_CallbackStop ( SYS_TMR_HANDLE handle )
{
	SYS_TIME_TimerDestroy(handle);
   17e9e:	f008 fa39 	bl	20314 <SYS_TIME_TimerDestroy>
        tcpip_stack_tickH = SYS_TMR_HANDLE_INVALID;
   17ea2:	4b07      	ldr	r3, [pc, #28]	; (17ec0 <TCPIP_STACK_KillStack+0xa0>)
   17ea4:	f04f 32ff 	mov.w	r2, #4294967295
   17ea8:	601a      	str	r2, [r3, #0]
   17eaa:	e7c0      	b.n	17e2e <TCPIP_STACK_KillStack+0xe>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Heap Delete fail!\r\n");
   17eac:	f00c f9e8 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
   17eb0:	2800      	cmp	r0, #0
   17eb2:	d0e1      	beq.n	17e78 <TCPIP_STACK_KillStack+0x58>
   17eb4:	f00c f9de 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
   17eb8:	4907      	ldr	r1, [pc, #28]	; (17ed8 <TCPIP_STACK_KillStack+0xb8>)
   17eba:	f004 fbef 	bl	1c69c <SYS_CONSOLE_Print>
   17ebe:	e7db      	b.n	17e78 <TCPIP_STACK_KillStack+0x58>
   17ec0:	2000ee80 	.word	0x2000ee80
   17ec4:	2000ee74 	.word	0x2000ee74
   17ec8:	2000eae4 	.word	0x2000eae4
   17ecc:	2000ef8b 	.word	0x2000ef8b
   17ed0:	2000ee68 	.word	0x2000ee68
   17ed4:	2000ed2c 	.word	0x2000ed2c
   17ed8:	000094b8 	.word	0x000094b8

Disassembly of section .text.__swbuf_r%372:

00017edc <__swbuf_r>:
   17edc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   17ede:	460e      	mov	r6, r1
   17ee0:	4614      	mov	r4, r2
   17ee2:	4605      	mov	r5, r0
   17ee4:	b118      	cbz	r0, 17eee <__swbuf_r+0x12>
   17ee6:	6983      	ldr	r3, [r0, #24]
   17ee8:	b90b      	cbnz	r3, 17eee <__swbuf_r+0x12>
   17eea:	f005 fa59 	bl	1d3a0 <__sinit>
   17eee:	4b27      	ldr	r3, [pc, #156]	; (17f8c <__swbuf_r+0xb0>)
   17ef0:	429c      	cmp	r4, r3
   17ef2:	d130      	bne.n	17f56 <__swbuf_r+0x7a>
   17ef4:	686c      	ldr	r4, [r5, #4]
   17ef6:	69a3      	ldr	r3, [r4, #24]
   17ef8:	60a3      	str	r3, [r4, #8]
   17efa:	89a3      	ldrh	r3, [r4, #12]
   17efc:	0719      	lsls	r1, r3, #28
   17efe:	d534      	bpl.n	17f6a <__swbuf_r+0x8e>
   17f00:	6923      	ldr	r3, [r4, #16]
   17f02:	2b00      	cmp	r3, #0
   17f04:	d031      	beq.n	17f6a <__swbuf_r+0x8e>
   17f06:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   17f0a:	b2f6      	uxtb	r6, r6
   17f0c:	049a      	lsls	r2, r3, #18
   17f0e:	4637      	mov	r7, r6
   17f10:	d534      	bpl.n	17f7c <__swbuf_r+0xa0>
   17f12:	6923      	ldr	r3, [r4, #16]
   17f14:	6820      	ldr	r0, [r4, #0]
   17f16:	1ac0      	subs	r0, r0, r3
   17f18:	6963      	ldr	r3, [r4, #20]
   17f1a:	4283      	cmp	r3, r0
   17f1c:	dc04      	bgt.n	17f28 <__swbuf_r+0x4c>
   17f1e:	4621      	mov	r1, r4
   17f20:	4628      	mov	r0, r5
   17f22:	f006 f89d 	bl	1e060 <_fflush_r>
   17f26:	bb30      	cbnz	r0, 17f76 <__swbuf_r+0x9a>
   17f28:	68a3      	ldr	r3, [r4, #8]
   17f2a:	3b01      	subs	r3, #1
   17f2c:	60a3      	str	r3, [r4, #8]
   17f2e:	6823      	ldr	r3, [r4, #0]
   17f30:	1c5a      	adds	r2, r3, #1
   17f32:	6022      	str	r2, [r4, #0]
   17f34:	701e      	strb	r6, [r3, #0]
   17f36:	6963      	ldr	r3, [r4, #20]
   17f38:	3001      	adds	r0, #1
   17f3a:	4283      	cmp	r3, r0
   17f3c:	d004      	beq.n	17f48 <__swbuf_r+0x6c>
   17f3e:	89a3      	ldrh	r3, [r4, #12]
   17f40:	07db      	lsls	r3, r3, #31
   17f42:	d506      	bpl.n	17f52 <__swbuf_r+0x76>
   17f44:	2e0a      	cmp	r6, #10
   17f46:	d104      	bne.n	17f52 <__swbuf_r+0x76>
   17f48:	4621      	mov	r1, r4
   17f4a:	4628      	mov	r0, r5
   17f4c:	f006 f888 	bl	1e060 <_fflush_r>
   17f50:	b988      	cbnz	r0, 17f76 <__swbuf_r+0x9a>
   17f52:	4638      	mov	r0, r7
   17f54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   17f56:	4b0e      	ldr	r3, [pc, #56]	; (17f90 <__swbuf_r+0xb4>)
   17f58:	429c      	cmp	r4, r3
   17f5a:	d101      	bne.n	17f60 <__swbuf_r+0x84>
   17f5c:	68ac      	ldr	r4, [r5, #8]
   17f5e:	e7ca      	b.n	17ef6 <__swbuf_r+0x1a>
   17f60:	4b0c      	ldr	r3, [pc, #48]	; (17f94 <__swbuf_r+0xb8>)
   17f62:	429c      	cmp	r4, r3
   17f64:	bf08      	it	eq
   17f66:	68ec      	ldreq	r4, [r5, #12]
   17f68:	e7c5      	b.n	17ef6 <__swbuf_r+0x1a>
   17f6a:	4621      	mov	r1, r4
   17f6c:	4628      	mov	r0, r5
   17f6e:	f7fe fe43 	bl	16bf8 <__swsetup_r>
   17f72:	2800      	cmp	r0, #0
   17f74:	d0c7      	beq.n	17f06 <__swbuf_r+0x2a>
   17f76:	f04f 37ff 	mov.w	r7, #4294967295
   17f7a:	e7ea      	b.n	17f52 <__swbuf_r+0x76>
   17f7c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   17f80:	81a3      	strh	r3, [r4, #12]
   17f82:	6e23      	ldr	r3, [r4, #96]	; 0x60
   17f84:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
   17f88:	6623      	str	r3, [r4, #96]	; 0x60
   17f8a:	e7c2      	b.n	17f12 <__swbuf_r+0x36>
   17f8c:	2000eb44 	.word	0x2000eb44
   17f90:	2000eb64 	.word	0x2000eb64
   17f94:	2000eb24 	.word	0x2000eb24

Disassembly of section .text._GetMaxSegSizeOption%373:

00017f98 <_GetMaxSegSizeOption>:
	vOptionsBytes = (h->DataOffset.Val << 2) - sizeof(*h);
   17f98:	7b03      	ldrb	r3, [r0, #12]
   17f9a:	f3c3 1303 	ubfx	r3, r3, #4, #4
   17f9e:	009b      	lsls	r3, r3, #2
   17fa0:	3b14      	subs	r3, #20
    if(vOptionsBytes == 0u)
   17fa2:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
   17fa6:	d043      	beq.n	18030 <_GetMaxSegSizeOption+0x98>
{
   17fa8:	b470      	push	{r4, r5, r6}
   17faa:	b083      	sub	sp, #12
    pOption = (uint8_t*)(h + 1);
   17fac:	3014      	adds	r0, #20
    pEnd = pOption + vOptionsBytes;
   17fae:	18c6      	adds	r6, r0, r3
    while(vOptionsBytes-- && pOption < pEnd)
   17fb0:	e01f      	b.n	17ff2 <_GetMaxSegSizeOption+0x5a>
            if(vOptionsBytes < 3u)
   17fb2:	2b02      	cmp	r3, #2
   17fb4:	d942      	bls.n	1803c <_GetMaxSegSizeOption+0xa4>
            wMSS = 0;
   17fb6:	2300      	movs	r3, #0
   17fb8:	f8ad 3006 	strh.w	r3, [sp, #6]
            if(vOption == 4u)
   17fbc:	7853      	ldrb	r3, [r2, #1]
   17fbe:	2b04      	cmp	r3, #4
   17fc0:	d00c      	beq.n	17fdc <_GetMaxSegSizeOption+0x44>
            if(wMSS < TCP_MIN_DEFAULT_MTU)
   17fc2:	f8bd 0006 	ldrh.w	r0, [sp, #6]
   17fc6:	f240 53b4 	movw	r3, #1460	; 0x5b4
   17fca:	4298      	cmp	r0, r3
   17fcc:	bf28      	it	cs
   17fce:	4618      	movcs	r0, r3
   17fd0:	f5b0 7f06 	cmp.w	r0, #536	; 0x218
   17fd4:	bf38      	it	cc
   17fd6:	f44f 7006 	movcc.w	r0, #536	; 0x218
   17fda:	e037      	b.n	1804c <_GetMaxSegSizeOption+0xb4>
                ((uint8_t*)&wMSS)[1] = *pOption++;
   17fdc:	7893      	ldrb	r3, [r2, #2]
   17fde:	f88d 3007 	strb.w	r3, [sp, #7]
                ((uint8_t*)&wMSS)[0] = *pOption++;
   17fe2:	78d3      	ldrb	r3, [r2, #3]
   17fe4:	f88d 3006 	strb.w	r3, [sp, #6]
   17fe8:	e7eb      	b.n	17fc2 <_GetMaxSegSizeOption+0x2a>
            pOption += vOption;
   17fea:	1c88      	adds	r0, r1, #2
   17fec:	4410      	add	r0, r2
            vOptionsBytes -= vOption;
   17fee:	1a5b      	subs	r3, r3, r1
   17ff0:	b2db      	uxtb	r3, r3
   17ff2:	18c5      	adds	r5, r0, r3
{
   17ff4:	4602      	mov	r2, r0
   17ff6:	3b01      	subs	r3, #1
   17ff8:	4418      	add	r0, r3
   17ffa:	1a83      	subs	r3, r0, r2
   17ffc:	b2db      	uxtb	r3, r3
    while(vOptionsBytes-- && pOption < pEnd)
   17ffe:	42aa      	cmp	r2, r5
   18000:	d022      	beq.n	18048 <_GetMaxSegSizeOption+0xb0>
   18002:	42b2      	cmp	r2, r6
   18004:	d211      	bcs.n	1802a <_GetMaxSegSizeOption+0x92>
        vOption = *pOption++;
   18006:	4614      	mov	r4, r2
   18008:	f814 1b01 	ldrb.w	r1, [r4], #1
        if(vOption == 0u)	// End of Options list
   1800c:	b199      	cbz	r1, 18036 <_GetMaxSegSizeOption+0x9e>
        if(vOption == 1u)	// NOP option
   1800e:	2901      	cmp	r1, #1
   18010:	d009      	beq.n	18026 <_GetMaxSegSizeOption+0x8e>
        if(vOption == 2u)	// Maximum Segment Size option
   18012:	2902      	cmp	r1, #2
   18014:	d0cd      	beq.n	17fb2 <_GetMaxSegSizeOption+0x1a>
            if(vOptionsBytes < 2u)
   18016:	2b01      	cmp	r3, #1
   18018:	d913      	bls.n	18042 <_GetMaxSegSizeOption+0xaa>
            vOption = *pOption++;
   1801a:	7851      	ldrb	r1, [r2, #1]
            if(vOptionsBytes < vOption)
   1801c:	4299      	cmp	r1, r3
   1801e:	d9e4      	bls.n	17fea <_GetMaxSegSizeOption+0x52>
    return TCP_MIN_DEFAULT_MTU;
   18020:	f44f 7006 	mov.w	r0, #536	; 0x218
   18024:	e012      	b.n	1804c <_GetMaxSegSizeOption+0xb4>
        vOption = *pOption++;
   18026:	4622      	mov	r2, r4
   18028:	e7e7      	b.n	17ffa <_GetMaxSegSizeOption+0x62>
    return TCP_MIN_DEFAULT_MTU;
   1802a:	f44f 7006 	mov.w	r0, #536	; 0x218
   1802e:	e00d      	b.n	1804c <_GetMaxSegSizeOption+0xb4>
        return TCP_MIN_DEFAULT_MTU;
   18030:	f44f 7006 	mov.w	r0, #536	; 0x218
}
   18034:	4770      	bx	lr
    return TCP_MIN_DEFAULT_MTU;
   18036:	f44f 7006 	mov.w	r0, #536	; 0x218
   1803a:	e007      	b.n	1804c <_GetMaxSegSizeOption+0xb4>
   1803c:	f44f 7006 	mov.w	r0, #536	; 0x218
   18040:	e004      	b.n	1804c <_GetMaxSegSizeOption+0xb4>
   18042:	f44f 7006 	mov.w	r0, #536	; 0x218
   18046:	e001      	b.n	1804c <_GetMaxSegSizeOption+0xb4>
   18048:	f44f 7006 	mov.w	r0, #536	; 0x218
}
   1804c:	b003      	add	sp, #12
   1804e:	bc70      	pop	{r4, r5, r6}
   18050:	4770      	bx	lr

Disassembly of section .text.CommandIperfStop%374:

00018054 <CommandIperfStop>:
{
   18054:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18056:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   18058:	6845      	ldr	r5, [r0, #4]
    if(argc == 1)
   1805a:	2901      	cmp	r1, #1
   1805c:	d008      	beq.n	18070 <CommandIperfStop+0x1c>
   1805e:	4616      	mov	r6, r2
    else if(argc == 3)
   18060:	2903      	cmp	r1, #3
   18062:	d020      	beq.n	180a6 <CommandIperfStop+0x52>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: iperfk <-i index>\r\n");
   18064:	6823      	ldr	r3, [r4, #0]
   18066:	681b      	ldr	r3, [r3, #0]
   18068:	491f      	ldr	r1, [pc, #124]	; (180e8 <CommandIperfStop+0x94>)
   1806a:	4628      	mov	r0, r5
   1806c:	4798      	blx	r3
}
   1806e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperfk: Using index 0\r\n");
   18070:	6803      	ldr	r3, [r0, #0]
   18072:	681b      	ldr	r3, [r3, #0]
   18074:	491d      	ldr	r1, [pc, #116]	; (180ec <CommandIperfStop+0x98>)
   18076:	4628      	mov	r0, r5
   18078:	4798      	blx	r3
    int iperfIndex = 0;
   1807a:	2200      	movs	r2, #0
    if(iperfIndex < 0 || iperfIndex >= nIperfSessions)
   1807c:	4b1c      	ldr	r3, [pc, #112]	; (180f0 <CommandIperfStop+0x9c>)
   1807e:	681b      	ldr	r3, [r3, #0]
   18080:	4293      	cmp	r3, r2
   18082:	dd21      	ble.n	180c8 <CommandIperfStop+0x74>
    pIState = gIperfState + iperfIndex;	
   18084:	491b      	ldr	r1, [pc, #108]	; (180f4 <CommandIperfStop+0xa0>)
   18086:	23d8      	movs	r3, #216	; 0xd8
   18088:	fb03 1302 	mla	r3, r3, r2, r1
    if(pIState->state == IPERF_STANDBY_STATE)
   1808c:	f893 10ce 	ldrb.w	r1, [r3, #206]	; 0xce
   18090:	2901      	cmp	r1, #1
   18092:	d022      	beq.n	180da <CommandIperfStop+0x86>
        pIState->stopRequested = true;
   18094:	2101      	movs	r1, #1
   18096:	f883 10cf 	strb.w	r1, [r3, #207]	; 0xcf
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: trying to stop iperf instance %d...\r\n", iperfIndex);
   1809a:	6823      	ldr	r3, [r4, #0]
   1809c:	685b      	ldr	r3, [r3, #4]
   1809e:	4916      	ldr	r1, [pc, #88]	; (180f8 <CommandIperfStop+0xa4>)
   180a0:	4628      	mov	r0, r5
   180a2:	4798      	blx	r3
   180a4:	e7e3      	b.n	1806e <CommandIperfStop+0x1a>
        if((strcmp(argv[1], "-i") == 0) || (strcmp(argv[1], "--index") == 0))
   180a6:	6857      	ldr	r7, [r2, #4]
   180a8:	4914      	ldr	r1, [pc, #80]	; (180fc <CommandIperfStop+0xa8>)
   180aa:	4638      	mov	r0, r7
   180ac:	f00b fda6 	bl	23bfc <strcmp>
   180b0:	b128      	cbz	r0, 180be <CommandIperfStop+0x6a>
   180b2:	4913      	ldr	r1, [pc, #76]	; (18100 <CommandIperfStop+0xac>)
   180b4:	4638      	mov	r0, r7
   180b6:	f00b fda1 	bl	23bfc <strcmp>
   180ba:	2800      	cmp	r0, #0
   180bc:	d1d2      	bne.n	18064 <CommandIperfStop+0x10>
            iperfIndex = atoi(argv[2]);
   180be:	68b0      	ldr	r0, [r6, #8]
   180c0:	f00c f9c2 	bl	24448 <atoi>
    if(iperfIndex < 0 || iperfIndex >= nIperfSessions)
   180c4:	1e02      	subs	r2, r0, #0
   180c6:	dad9      	bge.n	1807c <CommandIperfStop+0x28>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: Invalid session number. Min: 0, Max: %d\r\n", nIperfSessions - 1);
   180c8:	4b09      	ldr	r3, [pc, #36]	; (180f0 <CommandIperfStop+0x9c>)
   180ca:	681a      	ldr	r2, [r3, #0]
   180cc:	6823      	ldr	r3, [r4, #0]
   180ce:	685b      	ldr	r3, [r3, #4]
   180d0:	3a01      	subs	r2, #1
   180d2:	490c      	ldr	r1, [pc, #48]	; (18104 <CommandIperfStop+0xb0>)
   180d4:	4628      	mov	r0, r5
   180d6:	4798      	blx	r3
        return;
   180d8:	e7c9      	b.n	1806e <CommandIperfStop+0x1a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "\r\niperf session: not started!\r\n");
   180da:	6823      	ldr	r3, [r4, #0]
   180dc:	681b      	ldr	r3, [r3, #0]
   180de:	490a      	ldr	r1, [pc, #40]	; (18108 <CommandIperfStop+0xb4>)
   180e0:	4628      	mov	r0, r5
   180e2:	4798      	blx	r3
   180e4:	e7c3      	b.n	1806e <CommandIperfStop+0x1a>
   180e6:	bf00      	nop
   180e8:	00005c70 	.word	0x00005c70
   180ec:	00005c08 	.word	0x00005c08
   180f0:	2000ee24 	.word	0x2000ee24
   180f4:	2000e380 	.word	0x2000e380
   180f8:	00005c40 	.word	0x00005c40
   180fc:	00005b38 	.word	0x00005b38
   18100:	00005b3c 	.word	0x00005b3c
   18104:	00005b60 	.word	0x00005b60
   18108:	00005c20 	.word	0x00005c20

Disassembly of section .text.TCPIP_IPERF_Initialize%375:

0001810c <TCPIP_IPERF_Initialize>:
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_UP)
   1810c:	7f03      	ldrb	r3, [r0, #28]
   1810e:	2b03      	cmp	r3, #3
   18110:	d047      	beq.n	181a2 <TCPIP_IPERF_Initialize+0x96>
{
   18112:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if(iperfInitCount == 0)
   18116:	4b25      	ldr	r3, [pc, #148]	; (181ac <TCPIP_IPERF_Initialize+0xa0>)
   18118:	681e      	ldr	r6, [r3, #0]
   1811a:	2e00      	cmp	r6, #0
   1811c:	d139      	bne.n	18192 <TCPIP_IPERF_Initialize+0x86>
        nIperfSessions = sizeof(gIperfState) / sizeof(*gIperfState);
   1811e:	4b24      	ldr	r3, [pc, #144]	; (181b0 <TCPIP_IPERF_Initialize+0xa4>)
   18120:	2201      	movs	r2, #1
   18122:	601a      	str	r2, [r3, #0]
        for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
   18124:	4c23      	ldr	r4, [pc, #140]	; (181b4 <TCPIP_IPERF_Initialize+0xa8>)
	        memset( pIState, 0, sizeof(*pIState) );
   18126:	2500      	movs	r5, #0
	        pIState->signalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_IPERF_Task, 0);
   18128:	4f23      	ldr	r7, [pc, #140]	; (181b8 <TCPIP_IPERF_Initialize+0xac>)
        for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
   1812a:	4698      	mov	r8, r3
	        memset( pIState, 0, sizeof(*pIState) );
   1812c:	22d8      	movs	r2, #216	; 0xd8
   1812e:	4629      	mov	r1, r5
   18130:	4620      	mov	r0, r4
   18132:	f00b feb5 	bl	23ea0 <memset>
	        pIState->state = IPERF_STANDBY_STATE;
   18136:	2301      	movs	r3, #1
   18138:	f884 30ce 	strb.w	r3, [r4, #206]	; 0xce
	        pIState->stopRequested = false;
   1813c:	f884 50cf 	strb.w	r5, [r4, #207]	; 0xcf
	        pIState->tcpClientSock = INVALID_SOCKET;
   18140:	f64f 73ff 	movw	r3, #65535	; 0xffff
   18144:	8763      	strh	r3, [r4, #58]	; 0x3a
	        pIState->tcpServerSock = INVALID_SOCKET;
   18146:	8723      	strh	r3, [r4, #56]	; 0x38
	        pIState->udpSock = INVALID_SOCKET;
   18148:	87a3      	strh	r3, [r4, #60]	; 0x3c
	        pIState->txBuffSize = TCPIP_IPERF_TX_BUFFER_SIZE;
   1814a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   1814e:	f8c4 20b8 	str.w	r2, [r4, #184]	; 0xb8
	        pIState->rxBuffSize = TCPIP_IPERF_RX_BUFFER_SIZE;
   18152:	f8c4 20bc 	str.w	r2, [r4, #188]	; 0xbc
               pIState->waitCount = 0;
   18156:	f884 50d5 	strb.w	r5, [r4, #213]	; 0xd5
               pIState->sockWaitToSend = 0;
   1815a:	f884 50d4 	strb.w	r5, [r4, #212]	; 0xd4
               pIState->mTypeOfService = 0xFF;
   1815e:	7523      	strb	r3, [r4, #20]
	        pIState->signalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_IPERF_Task, 0);
   18160:	462a      	mov	r2, r5
   18162:	4639      	mov	r1, r7
   18164:	2020      	movs	r0, #32
   18166:	f006 fe1b 	bl	1eda0 <_TCPIPStackSignalHandlerRegister>
   1816a:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
	        if(pIState->signalHandle == 0)
   1816e:	b1d8      	cbz	r0, 181a8 <TCPIP_IPERF_Initialize+0x9c>
        for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
   18170:	3601      	adds	r6, #1
   18172:	34d8      	adds	r4, #216	; 0xd8
   18174:	f8d8 3000 	ldr.w	r3, [r8]
   18178:	42b3      	cmp	r3, r6
   1817a:	dcd7      	bgt.n	1812c <TCPIP_IPERF_Initialize+0x20>
		if(!SYS_CMD_ADDGRP(iperfCmdTbl, sizeof(iperfCmdTbl)/sizeof(*iperfCmdTbl), "iperf", ": iperf commands"))
   1817c:	4a0f      	ldr	r2, [pc, #60]	; (181bc <TCPIP_IPERF_Initialize+0xb0>)
   1817e:	f602 13cc 	addw	r3, r2, #2508	; 0x9cc
   18182:	f502 621e 	add.w	r2, r2, #2528	; 0x9e0
   18186:	2104      	movs	r1, #4
   18188:	480d      	ldr	r0, [pc, #52]	; (181c0 <TCPIP_IPERF_Initialize+0xb4>)
   1818a:	f004 fa51 	bl	1c630 <SYS_CMD_ADDGRP>
   1818e:	4603      	mov	r3, r0
   18190:	b120      	cbz	r0, 1819c <TCPIP_IPERF_Initialize+0x90>
    iperfInitCount++;
   18192:	4a06      	ldr	r2, [pc, #24]	; (181ac <TCPIP_IPERF_Initialize+0xa0>)
   18194:	6813      	ldr	r3, [r2, #0]
   18196:	3301      	adds	r3, #1
   18198:	6013      	str	r3, [r2, #0]
    return true;
   1819a:	2301      	movs	r3, #1
}
   1819c:	4618      	mov	r0, r3
   1819e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return true;
   181a2:	2301      	movs	r3, #1
}
   181a4:	4618      	mov	r0, r3
   181a6:	4770      	bx	lr
	            return false;
   181a8:	2300      	movs	r3, #0
   181aa:	e7f7      	b.n	1819c <TCPIP_IPERF_Initialize+0x90>
   181ac:	2000ee20 	.word	0x2000ee20
   181b0:	2000ee24 	.word	0x2000ee24
   181b4:	2000e380 	.word	0x2000e380
   181b8:	00002895 	.word	0x00002895
   181bc:	00005afc 	.word	0x00005afc
   181c0:	000211ec 	.word	0x000211ec

Disassembly of section .text.TCPIP_IPV4_ArpHandler%376:

000181c4 <TCPIP_IPV4_ArpHandler>:
{
   181c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   181c8:	b084      	sub	sp, #16
   181ca:	460f      	mov	r7, r1
   181cc:	4690      	mov	r8, r2
   181ce:	469a      	mov	sl, r3
    TCPIP_Helper_SingleListInitialize (&newList);
   181d0:	a801      	add	r0, sp, #4
   181d2:	f00c f8b5 	bl	24340 <TCPIP_Helper_SingleListInitialize>
    TCPIP_Helper_ProtectedSingleListLock(&ipv4ArpQueue);
   181d6:	4827      	ldr	r0, [pc, #156]	; (18274 <TCPIP_IPV4_ArpHandler+0xb0>)
   181d8:	f00a fd02 	bl	22be0 <TCPIP_Helper_ProtectedSingleListLock>
    while((pEntry = (IPV4_ARP_ENTRY*)TCPIP_Helper_SingleListHeadRemove(arpList)) != 0)
   181dc:	4e25      	ldr	r6, [pc, #148]	; (18274 <TCPIP_IPV4_ArpHandler+0xb0>)
            TCPIP_Helper_SingleListTailAdd(&ipv4ArpPool, (SGL_LIST_NODE*)pEntry); 
   181de:	f8df 9098 	ldr.w	r9, [pc, #152]	; 18278 <TCPIP_IPV4_ArpHandler+0xb4>
    while((pEntry = (IPV4_ARP_ENTRY*)TCPIP_Helper_SingleListHeadRemove(arpList)) != 0)
   181e2:	e00b      	b.n	181fc <TCPIP_IPV4_ArpHandler+0x38>
            pMacPkt = &pEntry->pTxPkt->macPkt;
   181e4:	68a5      	ldr	r5, [r4, #8]
   181e6:	e014      	b.n	18212 <TCPIP_IPV4_ArpHandler+0x4e>
                pktAckFail = TCPIP_MAC_PKT_ACK_ARP_TMO; 
   181e8:	f06f 0103 	mvn.w	r1, #3
        TCPIP_PKT_PacketAcknowledge(pTxPkt, ackRes);
   181ec:	2203      	movs	r2, #3
   181ee:	4628      	mov	r0, r5
   181f0:	f007 fc58 	bl	1faa4 <_TCPIP_PKT_PacketAcknowledge>
            TCPIP_Helper_SingleListTailAdd(&ipv4ArpPool, (SGL_LIST_NODE*)pEntry); 
   181f4:	4621      	mov	r1, r4
   181f6:	4648      	mov	r0, r9
   181f8:	f00b f918 	bl	2342c <TCPIP_Helper_SingleListTailAdd>
    while((pEntry = (IPV4_ARP_ENTRY*)TCPIP_Helper_SingleListHeadRemove(arpList)) != 0)
   181fc:	4630      	mov	r0, r6
   181fe:	f00a ff33 	bl	23068 <TCPIP_Helper_SingleListHeadRemove>
   18202:	4604      	mov	r4, r0
   18204:	b348      	cbz	r0, 1825a <TCPIP_IPV4_ArpHandler+0x96>
        if(pEntry->type == IPV4_ARP_PKT_TYPE_TX)
   18206:	7923      	ldrb	r3, [r4, #4]
   18208:	2b01      	cmp	r3, #1
   1820a:	d0eb      	beq.n	181e4 <TCPIP_IPV4_ArpHandler+0x20>
        else if(pEntry->type == IPV4_ARP_PKT_TYPE_MAC)
   1820c:	2b02      	cmp	r3, #2
   1820e:	d12d      	bne.n	1826c <TCPIP_IPV4_ArpHandler+0xa8>
            pMacPkt = pEntry->pMacPkt;
   18210:	68a5      	ldr	r5, [r4, #8]
        pPktIf = (TCPIP_NET_IF*)TCPIP_STACK_IndexToNet(pEntry->arpIfIx);
   18212:	7960      	ldrb	r0, [r4, #5]
   18214:	f009 ff36 	bl	22084 <TCPIP_STACK_IndexToNet>
        if(pEntry->arpTarget.Val == ipAdd->Val)
   18218:	68e2      	ldr	r2, [r4, #12]
   1821a:	683b      	ldr	r3, [r7, #0]
   1821c:	429a      	cmp	r2, r3
   1821e:	d117      	bne.n	18250 <TCPIP_IPV4_ArpHandler+0x8c>
            if(evType >= 0)
   18220:	f1ba 0f00 	cmp.w	sl, #0
   18224:	dbe0      	blt.n	181e8 <TCPIP_IPV4_ArpHandler+0x24>
                memcpy(&macHdr->DestMACAddr, MACAddr, sizeof(*MACAddr));
   18226:	696b      	ldr	r3, [r5, #20]
   18228:	f8d8 2000 	ldr.w	r2, [r8]
   1822c:	601a      	str	r2, [r3, #0]
   1822e:	f8b8 2004 	ldrh.w	r2, [r8, #4]
   18232:	809a      	strh	r2, [r3, #4]
                pMacPkt->next = 0;  // send single packet
   18234:	2300      	movs	r3, #0
   18236:	602b      	str	r3, [r5, #0]
                if(pPktIf == 0 || !TCPIP_IPV4_TxMacPkt(pPktIf, pMacPkt))
   18238:	b138      	cbz	r0, 1824a <TCPIP_IPV4_ArpHandler+0x86>
    return _TCPIPStackPacketTx(pNetIf, pPkt) == TCPIP_MAC_RES_OK;
   1823a:	4629      	mov	r1, r5
   1823c:	f00b fbbe 	bl	239bc <_TCPIPStackPacketTx>
                if(pPktIf == 0 || !TCPIP_IPV4_TxMacPkt(pPktIf, pMacPkt))
   18240:	2800      	cmp	r0, #0
   18242:	d0d7      	beq.n	181f4 <TCPIP_IPV4_ArpHandler+0x30>
                    pktAckFail = TCPIP_MAC_PKT_ACK_ARP_NET_ERR; 
   18244:	f06f 0104 	mvn.w	r1, #4
   18248:	e7d0      	b.n	181ec <TCPIP_IPV4_ArpHandler+0x28>
   1824a:	f06f 0104 	mvn.w	r1, #4
   1824e:	e7cd      	b.n	181ec <TCPIP_IPV4_ArpHandler+0x28>
            TCPIP_Helper_SingleListTailAdd(&newList, (SGL_LIST_NODE*)pEntry);
   18250:	4621      	mov	r1, r4
   18252:	a801      	add	r0, sp, #4
   18254:	f00b f8ea 	bl	2342c <TCPIP_Helper_SingleListTailAdd>
   18258:	e7d0      	b.n	181fc <TCPIP_IPV4_ArpHandler+0x38>
    ipv4ArpQueue.list = newList;
   1825a:	4b06      	ldr	r3, [pc, #24]	; (18274 <TCPIP_IPV4_ArpHandler+0xb0>)
   1825c:	aa04      	add	r2, sp, #16
   1825e:	e912 0007 	ldmdb	r2, {r0, r1, r2}
   18262:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    TCPIP_Helper_ProtectedSingleListUnlock(&ipv4ArpQueue);
   18266:	4618      	mov	r0, r3
   18268:	f00a ff0c 	bl	23084 <TCPIP_Helper_ProtectedSingleListUnlock>
}
   1826c:	b004      	add	sp, #16
   1826e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   18272:	bf00      	nop
   18274:	2000ec3c 	.word	0x2000ec3c
   18278:	2000ed4c 	.word	0x2000ed4c

Disassembly of section .text.gfx_mono_draw_char%377:

0001827c <gfx_mono_draw_char>:
 * \param[in] x        X coordinate on screen.
 * \param[in] y        Y coordinate on screen.
 * \param[in] font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
        const struct font *font) {
   1827c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18280:	b085      	sub	sp, #20
   18282:	4607      	mov	r7, r0
   18284:	468a      	mov	sl, r1
   18286:	4615      	mov	r5, r2
   18288:	461e      	mov	r6, r3
    gfx_mono_draw_filled_rect(x, y, font->width, font->height,
   1828a:	2300      	movs	r3, #0
   1828c:	9300      	str	r3, [sp, #0]
   1828e:	7a73      	ldrb	r3, [r6, #9]
   18290:	7a32      	ldrb	r2, [r6, #8]
   18292:	4629      	mov	r1, r5
   18294:	4650      	mov	r0, sl
   18296:	f008 fde9 	bl	20e6c <gfx_mono_generic_draw_filled_rect>
            GFX_PIXEL_CLR);

    switch (font->type) {
   1829a:	7833      	ldrb	r3, [r6, #0]
   1829c:	2b00      	cmp	r3, #0
   1829e:	d13b      	bne.n	18318 <gfx_mono_draw_char+0x9c>
    char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
   182a0:	7a32      	ldrb	r2, [r6, #8]
   182a2:	08d1      	lsrs	r1, r2, #3
    if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
   182a4:	f012 0f07 	tst.w	r2, #7
        char_row_size++;
   182a8:	bf18      	it	ne
   182aa:	3101      	addne	r1, #1
    glyph_data_offset = char_row_size * font->height *
   182ac:	f896 8009 	ldrb.w	r8, [r6, #9]
            ((uint8_t) ch - font->first_char);
   182b0:	7ab4      	ldrb	r4, [r6, #10]
   182b2:	1b3c      	subs	r4, r7, r4
    glyph_data_offset = char_row_size * font->height *
   182b4:	fb14 f408 	smulbb	r4, r4, r8
   182b8:	fb14 f401 	smulbb	r4, r4, r1
    glyph_data = font->data.progmem + glyph_data_offset;
   182bc:	6872      	ldr	r2, [r6, #4]
   182be:	fa12 f484 	uxtah	r4, r2, r4
    rows_left = font->height;
   182c2:	44a8      	add	r8, r5
   182c4:	fa5f f888 	uxtb.w	r8, r8
        uint8_t glyph_byte = 0;
   182c8:	9303      	str	r3, [sp, #12]
                gfx_mono_draw_pixel(inc_x, inc_y,
   182ca:	46a3      	mov	fp, r4
   182cc:	e01d      	b.n	1830a <gfx_mono_draw_char+0x8e>
            glyph_byte <<= 1;
   182ce:	007f      	lsls	r7, r7, #1
   182d0:	b2ff      	uxtb	r7, r7
   182d2:	f109 0901 	add.w	r9, r9, #1
        for (i = 0; i < pixelsToDraw; i++) {
   182d6:	fa5f f389 	uxtb.w	r3, r9
   182da:	429c      	cmp	r4, r3
   182dc:	d911      	bls.n	18302 <gfx_mono_draw_char+0x86>
   182de:	fa5f f389 	uxtb.w	r3, r9
   182e2:	eb0a 0003 	add.w	r0, sl, r3
   182e6:	b2c0      	uxtb	r0, r0
            if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
   182e8:	f013 0f07 	tst.w	r3, #7
                glyph_byte = PROGMEM_READ_BYTE(glyph_data);
   182ec:	bf08      	it	eq
   182ee:	f81b 7b01 	ldrbeq.w	r7, [fp], #1
            if ((glyph_byte & 0x80)) {
   182f2:	f017 0f80 	tst.w	r7, #128	; 0x80
   182f6:	d0ea      	beq.n	182ce <gfx_mono_draw_char+0x52>
                gfx_mono_draw_pixel(inc_x, inc_y,
   182f8:	2201      	movs	r2, #1
   182fa:	4629      	mov	r1, r5
   182fc:	f005 f820 	bl	1d340 <gfx_mono_ssd1306_draw_pixel>
   18300:	e7e5      	b.n	182ce <gfx_mono_draw_char+0x52>
        inc_y += 1;
   18302:	3501      	adds	r5, #1
   18304:	b2ed      	uxtb	r5, r5
    } while (rows_left > 0);
   18306:	4545      	cmp	r5, r8
   18308:	d00d      	beq.n	18326 <gfx_mono_draw_char+0xaa>
        uint8_t pixelsToDraw = font->width;
   1830a:	7a34      	ldrb	r4, [r6, #8]
        for (i = 0; i < pixelsToDraw; i++) {
   1830c:	2c00      	cmp	r4, #0
   1830e:	d0f8      	beq.n	18302 <gfx_mono_draw_char+0x86>
        uint8_t glyph_byte = 0;
   18310:	9f03      	ldr	r7, [sp, #12]
        for (i = 0; i < pixelsToDraw; i++) {
   18312:	f04f 0900 	mov.w	r9, #0
   18316:	e7e2      	b.n	182de <gfx_mono_draw_char+0x62>
            break;

#endif
        default:
            /* Unsupported mode, call assert */
            assert(false);
   18318:	4804      	ldr	r0, [pc, #16]	; (1832c <gfx_mono_draw_char+0xb0>)
   1831a:	4603      	mov	r3, r0
   1831c:	4a04      	ldr	r2, [pc, #16]	; (18330 <gfx_mono_draw_char+0xb4>)
   1831e:	21f0      	movs	r1, #240	; 0xf0
   18320:	3008      	adds	r0, #8
   18322:	f008 f833 	bl	2038c <__assert_func>
            break;
    }
}
   18326:	b005      	add	sp, #20
   18328:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1832c:	0001f548 	.word	0x0001f548
   18330:	00023bd4 	.word	0x00023bd4

Disassembly of section .text.wc_Md5Final%378:

00018334 <wc_Md5Final>:

int wc_Md5Final(wc_Md5* md5, byte* hash)
{
    byte* local;

    if (md5 == NULL || hash == NULL) {
   18334:	2800      	cmp	r0, #0
   18336:	d051      	beq.n	183dc <wc_Md5Final+0xa8>
{
   18338:	b570      	push	{r4, r5, r6, lr}
   1833a:	4604      	mov	r4, r0
    if (md5 == NULL || hash == NULL) {
   1833c:	2900      	cmp	r1, #0
   1833e:	d050      	beq.n	183e2 <wc_Md5Final+0xae>
   18340:	460d      	mov	r5, r1
        return IntelQaSymMd5(&md5->asyncDev, hash, NULL, WC_MD5_DIGEST_SIZE);
#endif
    }
#endif /* WOLFSSL_ASYNC_CRYPT */

    local = (byte*)md5->buffer;
   18342:	4606      	mov	r6, r0

    local[md5->buffLen++] = 0x80;  /* add 1 */
   18344:	f856 3b0c 	ldr.w	r3, [r6], #12
   18348:	1c5a      	adds	r2, r3, #1
   1834a:	6002      	str	r2, [r0, #0]
   1834c:	2280      	movs	r2, #128	; 0x80
   1834e:	54f2      	strb	r2, [r6, r3]

    /* pad with zeros */
    if (md5->buffLen > WC_MD5_PAD_SIZE) {
   18350:	6800      	ldr	r0, [r0, #0]
   18352:	2838      	cmp	r0, #56	; 0x38
   18354:	d833      	bhi.n	183be <wc_Md5Final+0x8a>
        ByteReverseWords(md5->buffer, md5->buffer, WC_MD5_BLOCK_SIZE);
#endif
        XTRANSFORM(md5, local);
        md5->buffLen = 0;
    }
    XMEMSET(&local[md5->buffLen], 0, WC_MD5_PAD_SIZE - md5->buffLen);
   18356:	6820      	ldr	r0, [r4, #0]
   18358:	f1c0 0238 	rsb	r2, r0, #56	; 0x38
   1835c:	2100      	movs	r1, #0
   1835e:	4430      	add	r0, r6
   18360:	f00b fd9e 	bl	23ea0 <memset>
#if defined(BIG_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
    ByteReverseWords(md5->buffer, md5->buffer, WC_MD5_BLOCK_SIZE);
#endif

    /* put lengths in bits */
    md5->hiLen = (md5->loLen >> (8 * sizeof(md5->loLen) - 3)) +
   18364:	6863      	ldr	r3, [r4, #4]
                 (md5->hiLen << 3);
   18366:	68a1      	ldr	r1, [r4, #8]
    md5->hiLen = (md5->loLen >> (8 * sizeof(md5->loLen) - 3)) +
   18368:	0f5a      	lsrs	r2, r3, #29
   1836a:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
   1836e:	60a2      	str	r2, [r4, #8]
    md5->loLen = md5->loLen << 3;
   18370:	00db      	lsls	r3, r3, #3
   18372:	6063      	str	r3, [r4, #4]

    /* store lengths */
    /* ! length ordering dependent on digest endian type ! */
    XMEMCPY(&local[WC_MD5_PAD_SIZE], &md5->loLen, sizeof(word32));
   18374:	6463      	str	r3, [r4, #68]	; 0x44
    XMEMCPY(&local[WC_MD5_PAD_SIZE + sizeof(word32)], &md5->hiLen, sizeof(word32));
   18376:	64a2      	str	r2, [r4, #72]	; 0x48

    /* final transform and result to hash */
    XTRANSFORM(md5, local);
   18378:	4631      	mov	r1, r6
   1837a:	4620      	mov	r0, r4
   1837c:	f7ee fc7e 	bl	6c7c <Transform>
#ifdef BIG_ENDIAN_ORDER
    ByteReverseWords(md5->digest, md5->digest, WC_MD5_DIGEST_SIZE);
#endif
    XMEMCPY(hash, md5->digest, WC_MD5_DIGEST_SIZE);
   18380:	4623      	mov	r3, r4
   18382:	f853 0f4c 	ldr.w	r0, [r3, #76]!
   18386:	6859      	ldr	r1, [r3, #4]
   18388:	689a      	ldr	r2, [r3, #8]
   1838a:	68db      	ldr	r3, [r3, #12]
   1838c:	6028      	str	r0, [r5, #0]
   1838e:	6069      	str	r1, [r5, #4]
   18390:	60aa      	str	r2, [r5, #8]
   18392:	60eb      	str	r3, [r5, #12]
    md5->digest[0] = 0x67452301L;
   18394:	4b14      	ldr	r3, [pc, #80]	; (183e8 <wc_Md5Final+0xb4>)
   18396:	64e3      	str	r3, [r4, #76]	; 0x4c
    md5->digest[1] = 0xefcdab89L;
   18398:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
   1839c:	6523      	str	r3, [r4, #80]	; 0x50
    md5->digest[2] = 0x98badcfeL;
   1839e:	f103 4329 	add.w	r3, r3, #2835349504	; 0xa9000000
   183a2:	f5a3 1396 	sub.w	r3, r3, #1228800	; 0x12c000
   183a6:	f6a3 638b 	subw	r3, r3, #3723	; 0xe8b
   183aa:	6563      	str	r3, [r4, #84]	; 0x54
    md5->digest[3] = 0x10325476L;
   183ac:	f1a3 3388 	sub.w	r3, r3, #2290649224	; 0x88888888
   183b0:	65a3      	str	r3, [r4, #88]	; 0x58
    md5->buffLen = 0;
   183b2:	2000      	movs	r0, #0
   183b4:	6020      	str	r0, [r4, #0]
    md5->loLen   = 0;
   183b6:	6060      	str	r0, [r4, #4]
    md5->hiLen   = 0;
   183b8:	60a0      	str	r0, [r4, #8]
    md5->flags = 0;
   183ba:	6620      	str	r0, [r4, #96]	; 0x60

    return _InitMd5(md5); /* reset state */
}
   183bc:	bd70      	pop	{r4, r5, r6, pc}
        XMEMSET(&local[md5->buffLen], 0, WC_MD5_BLOCK_SIZE - md5->buffLen);
   183be:	f1c0 0240 	rsb	r2, r0, #64	; 0x40
   183c2:	2100      	movs	r1, #0
   183c4:	4430      	add	r0, r6
   183c6:	f00b fd6b 	bl	23ea0 <memset>
        md5->buffLen += WC_MD5_BLOCK_SIZE - md5->buffLen;
   183ca:	2340      	movs	r3, #64	; 0x40
   183cc:	6023      	str	r3, [r4, #0]
        XTRANSFORM(md5, local);
   183ce:	4631      	mov	r1, r6
   183d0:	4620      	mov	r0, r4
   183d2:	f7ee fc53 	bl	6c7c <Transform>
        md5->buffLen = 0;
   183d6:	2300      	movs	r3, #0
   183d8:	6023      	str	r3, [r4, #0]
   183da:	e7bc      	b.n	18356 <wc_Md5Final+0x22>
        return BAD_FUNC_ARG;
   183dc:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
   183e0:	4770      	bx	lr
        return BAD_FUNC_ARG;
   183e2:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   183e6:	e7e9      	b.n	183bc <wc_Md5Final+0x88>
   183e8:	67452301 	.word	0x67452301

Disassembly of section .text.__ssputs_r%379:

000183ec <__ssputs_r>:
   183ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   183f0:	688e      	ldr	r6, [r1, #8]
   183f2:	429e      	cmp	r6, r3
   183f4:	4682      	mov	sl, r0
   183f6:	460c      	mov	r4, r1
   183f8:	4691      	mov	r9, r2
   183fa:	4698      	mov	r8, r3
   183fc:	d838      	bhi.n	18470 <__ssputs_r+0x84>
   183fe:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
   18402:	f41c 6f90 	tst.w	ip, #1152	; 0x480
   18406:	d031      	beq.n	1846c <__ssputs_r+0x80>
   18408:	6962      	ldr	r2, [r4, #20]
   1840a:	6825      	ldr	r5, [r4, #0]
   1840c:	6909      	ldr	r1, [r1, #16]
   1840e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   18412:	1a6f      	subs	r7, r5, r1
   18414:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
   18418:	3301      	adds	r3, #1
   1841a:	1055      	asrs	r5, r2, #1
   1841c:	443b      	add	r3, r7
   1841e:	429d      	cmp	r5, r3
   18420:	bf38      	it	cc
   18422:	461d      	movcc	r5, r3
   18424:	f41c 6f80 	tst.w	ip, #1024	; 0x400
   18428:	d030      	beq.n	1848c <__ssputs_r+0xa0>
   1842a:	4629      	mov	r1, r5
   1842c:	f000 f948 	bl	186c0 <_malloc_r>
   18430:	4606      	mov	r6, r0
   18432:	b950      	cbnz	r0, 1844a <__ssputs_r+0x5e>
   18434:	230c      	movs	r3, #12
   18436:	f8ca 3000 	str.w	r3, [sl]
   1843a:	89a3      	ldrh	r3, [r4, #12]
   1843c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   18440:	81a3      	strh	r3, [r4, #12]
   18442:	f04f 30ff 	mov.w	r0, #4294967295
   18446:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1844a:	463a      	mov	r2, r7
   1844c:	6921      	ldr	r1, [r4, #16]
   1844e:	f00a ff4d 	bl	232ec <memcpy>
   18452:	89a3      	ldrh	r3, [r4, #12]
   18454:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
   18458:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   1845c:	81a3      	strh	r3, [r4, #12]
   1845e:	6126      	str	r6, [r4, #16]
   18460:	6165      	str	r5, [r4, #20]
   18462:	443e      	add	r6, r7
   18464:	1bed      	subs	r5, r5, r7
   18466:	6026      	str	r6, [r4, #0]
   18468:	60a5      	str	r5, [r4, #8]
   1846a:	4646      	mov	r6, r8
   1846c:	4546      	cmp	r6, r8
   1846e:	d900      	bls.n	18472 <__ssputs_r+0x86>
   18470:	4646      	mov	r6, r8
   18472:	4632      	mov	r2, r6
   18474:	4649      	mov	r1, r9
   18476:	6820      	ldr	r0, [r4, #0]
   18478:	f008 fd46 	bl	20f08 <memmove>
   1847c:	68a3      	ldr	r3, [r4, #8]
   1847e:	1b9b      	subs	r3, r3, r6
   18480:	60a3      	str	r3, [r4, #8]
   18482:	6823      	ldr	r3, [r4, #0]
   18484:	441e      	add	r6, r3
   18486:	6026      	str	r6, [r4, #0]
   18488:	2000      	movs	r0, #0
   1848a:	e7dc      	b.n	18446 <__ssputs_r+0x5a>
   1848c:	462a      	mov	r2, r5
   1848e:	f006 fa89 	bl	1e9a4 <_realloc_r>
   18492:	4606      	mov	r6, r0
   18494:	2800      	cmp	r0, #0
   18496:	d1e2      	bne.n	1845e <__ssputs_r+0x72>
   18498:	6921      	ldr	r1, [r4, #16]
   1849a:	4650      	mov	r0, sl
   1849c:	f001 fa2a 	bl	198f4 <_free_r>
   184a0:	e7c8      	b.n	18434 <__ssputs_r+0x48>

Disassembly of section .text._ARPSendIfPkt%380:

000184a4 <_ARPSendIfPkt>:
{
   184a4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   184a8:	4607      	mov	r7, r0
   184aa:	468a      	mov	sl, r1
   184ac:	4691      	mov	r9, r2
   184ae:	4698      	mov	r8, r3
   184b0:	9d08      	ldr	r5, [sp, #32]
   184b2:	9e09      	ldr	r6, [sp, #36]	; 0x24
    if(arpMod.pMacPkt != 0 && (arpMod.pMacPkt->pktFlags & TCPIP_MAC_PKT_FLAG_QUEUED) == 0)
   184b4:	4b27      	ldr	r3, [pc, #156]	; (18554 <_ARPSendIfPkt+0xb0>)
   184b6:	6c9c      	ldr	r4, [r3, #72]	; 0x48
   184b8:	b11c      	cbz	r4, 184c2 <_ARPSendIfPkt+0x1e>
   184ba:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   184bc:	f013 0f08 	tst.w	r3, #8
   184c0:	d006      	beq.n	184d0 <_ARPSendIfPkt+0x2c>
        if((pMacPkt = _ARPAllocateTxPacket()) == 0)
   184c2:	f00a f863 	bl	2258c <_ARPAllocateTxPacket>
   184c6:	4604      	mov	r4, r0
   184c8:	2800      	cmp	r0, #0
   184ca:	d041      	beq.n	18550 <_ARPSendIfPkt+0xac>
        arpMod.pMacPkt = pMacPkt;   // show we're using this one now
   184cc:	4b21      	ldr	r3, [pc, #132]	; (18554 <_ARPSendIfPkt+0xb0>)
   184ce:	6498      	str	r0, [r3, #72]	; 0x48
    pArp = (ARP_PACKET*)pMacPkt->pNetLayer;
   184d0:	69a3      	ldr	r3, [r4, #24]
    pArp->HardwareType  = HW_ETHERNET;
   184d2:	2201      	movs	r2, #1
   184d4:	801a      	strh	r2, [r3, #0]
    pArp->Protocol      = ARP_IP;
   184d6:	f44f 6200 	mov.w	r2, #2048	; 0x800
   184da:	805a      	strh	r2, [r3, #2]
    pArp->MACAddrLen    = sizeof(TCPIP_MAC_ADDR);
   184dc:	2206      	movs	r2, #6
   184de:	711a      	strb	r2, [r3, #4]
    pArp->ProtocolLen   = sizeof(IPV4_ADDR);
   184e0:	2204      	movs	r2, #4
   184e2:	715a      	strb	r2, [r3, #5]
    pArp->Operation = oper;
   184e4:	f8a3 a006 	strh.w	sl, [r3, #6]
    if(srcMAC == 0)
   184e8:	b30e      	cbz	r6, 1852e <_ARPSendIfPkt+0x8a>
        pArp->SenderMACAddr = *srcMAC;
   184ea:	6832      	ldr	r2, [r6, #0]
   184ec:	609a      	str	r2, [r3, #8]
   184ee:	88b2      	ldrh	r2, [r6, #4]
   184f0:	819a      	strh	r2, [r3, #12]
    pArp->SenderIPAddr.Val  = srcIP;
   184f2:	f8c3 900e 	str.w	r9, [r3, #14]
    pArp->TargetMACAddr = *dstMAC;
   184f6:	682a      	ldr	r2, [r5, #0]
   184f8:	f8c3 2012 	str.w	r2, [r3, #18]
   184fc:	88aa      	ldrh	r2, [r5, #4]
   184fe:	82da      	strh	r2, [r3, #22]
    pArp->TargetIPAddr.Val  = dstIP;
   18500:	f8c3 8018 	str.w	r8, [r3, #24]
    _SwapARPPacket(pArp);
   18504:	4618      	mov	r0, r3
   18506:	f00a fb4b 	bl	22ba0 <_SwapARPPacket>
    pMacPkt->pDSeg->segLen = sizeof(ARP_PACKET);
   1850a:	6923      	ldr	r3, [r4, #16]
   1850c:	221c      	movs	r2, #28
   1850e:	819a      	strh	r2, [r3, #12]
    if(TCPIP_PKT_PacketMACFormat(pMacPkt, dstMAC, (const TCPIP_MAC_ADDR*)TCPIP_STACK_NetUpMACAddressGet(pIf), TCPIP_ETHER_TYPE_ARP))
   18510:	4638      	mov	r0, r7
   18512:	f00b faf1 	bl	23af8 <TCPIP_STACK_NetUpMACAddressGet>
   18516:	f640 0306 	movw	r3, #2054	; 0x806
   1851a:	4602      	mov	r2, r0
   1851c:	4629      	mov	r1, r5
   1851e:	4620      	mov	r0, r4
   18520:	f008 f91c 	bl	2075c <TCPIP_PKT_PacketMACFormat>
   18524:	4603      	mov	r3, r0
   18526:	b940      	cbnz	r0, 1853a <_ARPSendIfPkt+0x96>
}
   18528:	4618      	mov	r0, r3
   1852a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        pArp->SenderMACAddr = pIf->netMACAddr;
   1852e:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   18530:	6098      	str	r0, [r3, #8]
   18532:	f8b7 2040 	ldrh.w	r2, [r7, #64]	; 0x40
   18536:	819a      	strh	r2, [r3, #12]
   18538:	e7db      	b.n	184f2 <_ARPSendIfPkt+0x4e>
        pMacPkt->next = 0;  // send single packet
   1853a:	2300      	movs	r3, #0
   1853c:	6023      	str	r3, [r4, #0]
        pMacPkt->pktIf = pIf;
   1853e:	62a7      	str	r7, [r4, #40]	; 0x28
        if(_TCPIPStackPacketTx(pIf, pMacPkt) >= 0)
   18540:	4621      	mov	r1, r4
   18542:	4638      	mov	r0, r7
   18544:	f00b fa3a 	bl	239bc <_TCPIPStackPacketTx>
   18548:	43c0      	mvns	r0, r0
   1854a:	f3c0 13c0 	ubfx	r3, r0, #7, #1
   1854e:	e7eb      	b.n	18528 <_ARPSendIfPkt+0x84>
            return false;
   18550:	2300      	movs	r3, #0
   18552:	e7e9      	b.n	18528 <_ARPSendIfPkt+0x84>
   18554:	2000e974 	.word	0x2000e974

Disassembly of section .text.TCPIP_DHCPS_LeaseEntryGet%381:

00018558 <TCPIP_DHCPS_LeaseEntryGet>:
{
   18558:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1855c:	4607      	mov	r7, r0
   1855e:	4688      	mov	r8, r1
   18560:	4616      	mov	r6, r2
    uint32_t 		current_time = SYS_TMR_TickCountGet();
   18562:	f009 fe6b 	bl	2223c <SYS_TMR_TickCountGet>
   18566:	2f00      	cmp	r7, #0
   18568:	d04b      	beq.n	18602 <TCPIP_DHCPS_LeaseEntryGet+0xaa>
   1856a:	4681      	mov	r9, r0
    if(pNetIf == 0 || pNetIf->Flags.bIsDHCPSrvEnabled == 0)
   1856c:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
   18570:	f003 0344 	and.w	r3, r3, #68	; 0x44
   18574:	2b44      	cmp	r3, #68	; 0x44
   18576:	d003      	beq.n	18580 <TCPIP_DHCPS_LeaseEntryGet+0x28>
        return 0;
   18578:	2500      	movs	r5, #0
}
   1857a:	4628      	mov	r0, r5
   1857c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    pOH = pDSHashDcpt->hashDcpt;
   18580:	4b21      	ldr	r3, [pc, #132]	; (18608 <TCPIP_DHCPS_LeaseEntryGet+0xb0>)
   18582:	681d      	ldr	r5, [r3, #0]
    if(pOH != 0)
   18584:	2d00      	cmp	r5, #0
   18586:	d0f8      	beq.n	1857a <TCPIP_DHCPS_LeaseEntryGet+0x22>
        for(entryIx = (int)leaseHandle; entryIx < pOH->hEntries; entryIx++)
   18588:	4634      	mov	r4, r6
   1858a:	68eb      	ldr	r3, [r5, #12]
   1858c:	429e      	cmp	r6, r3
   1858e:	d305      	bcc.n	1859c <TCPIP_DHCPS_LeaseEntryGet+0x44>
    return 0;
   18590:	2500      	movs	r5, #0
   18592:	e7f2      	b.n	1857a <TCPIP_DHCPS_LeaseEntryGet+0x22>
        for(entryIx = (int)leaseHandle; entryIx < pOH->hEntries; entryIx++)
   18594:	3401      	adds	r4, #1
   18596:	68eb      	ldr	r3, [r5, #12]
   18598:	42a3      	cmp	r3, r4
   1859a:	d930      	bls.n	185fe <TCPIP_DHCPS_LeaseEntryGet+0xa6>
            pDsEntry = (DHCPS_HASH_ENTRY*)TCPIP_OAHASH_EntryGet(pOH, entryIx);
   1859c:	4621      	mov	r1, r4
   1859e:	4628      	mov	r0, r5
   185a0:	f00b fb5b 	bl	23c5a <TCPIP_OAHASH_EntryGet>
            if(pDsEntry && (pDsEntry->hEntry.flags.busy != 0) && (pDsEntry->hEntry.flags.value & DHCPS_FLAG_ENTRY_COMPLETE) )
   185a4:	4606      	mov	r6, r0
   185a6:	2800      	cmp	r0, #0
   185a8:	d0f4      	beq.n	18594 <TCPIP_DHCPS_LeaseEntryGet+0x3c>
   185aa:	7803      	ldrb	r3, [r0, #0]
   185ac:	f013 0f01 	tst.w	r3, #1
   185b0:	d0f0      	beq.n	18594 <TCPIP_DHCPS_LeaseEntryGet+0x3c>
   185b2:	8803      	ldrh	r3, [r0, #0]
   185b4:	f013 0f80 	tst.w	r3, #128	; 0x80
   185b8:	d0ec      	beq.n	18594 <TCPIP_DHCPS_LeaseEntryGet+0x3c>
                if(pDsEntry->intfIdx != TCPIP_STACK_NetIxGet(pNetIf))
   185ba:	f8d0 a018 	ldr.w	sl, [r0, #24]
   185be:	4638      	mov	r0, r7
   185c0:	f00b fcba 	bl	23f38 <TCPIP_STACK_NetIxGet>
   185c4:	4582      	cmp	sl, r0
   185c6:	d1e5      	bne.n	18594 <TCPIP_DHCPS_LeaseEntryGet+0x3c>
                if(pLeaseEntry)
   185c8:	f1b8 0f00 	cmp.w	r8, #0
   185cc:	d015      	beq.n	185fa <TCPIP_DHCPS_LeaseEntryGet+0xa2>
                    memcpy(&pLeaseEntry->hwAdd, &pDsEntry->hwAdd, sizeof(pDsEntry->hwAdd));
   185ce:	4633      	mov	r3, r6
   185d0:	f853 2f10 	ldr.w	r2, [r3, #16]!
   185d4:	f8c8 2000 	str.w	r2, [r8]
   185d8:	889b      	ldrh	r3, [r3, #4]
   185da:	f8a8 3004 	strh.w	r3, [r8, #4]
                    pLeaseEntry->ipAddress.Val = pDsEntry->ipAddress.Val;
   185de:	68f3      	ldr	r3, [r6, #12]
   185e0:	f8c8 3008 	str.w	r3, [r8, #8]
                    pLeaseEntry->leaseTime = pDSHashDcpt->leaseDuartion*SYS_TMR_TickCounterFrequencyGet() - (current_time - pDsEntry->Client_Lease_Time);
   185e4:	4b08      	ldr	r3, [pc, #32]	; (18608 <TCPIP_DHCPS_LeaseEntryGet+0xb0>)
   185e6:	685d      	ldr	r5, [r3, #4]
   185e8:	f009 fe50 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
   185ec:	6873      	ldr	r3, [r6, #4]
   185ee:	eba3 0909 	sub.w	r9, r3, r9
   185f2:	fb00 9005 	mla	r0, r0, r5, r9
   185f6:	f8c8 000c 	str.w	r0, [r8, #12]
                return (TCPIP_DHCPS_LEASE_HANDLE)(entryIx + 1);
   185fa:	1c65      	adds	r5, r4, #1
   185fc:	e7bd      	b.n	1857a <TCPIP_DHCPS_LeaseEntryGet+0x22>
    return 0;
   185fe:	2500      	movs	r5, #0
   18600:	e7bb      	b.n	1857a <TCPIP_DHCPS_LeaseEntryGet+0x22>
        return 0;
   18602:	463d      	mov	r5, r7
   18604:	e7b9      	b.n	1857a <TCPIP_DHCPS_LeaseEntryGet+0x22>
   18606:	bf00      	nop
   18608:	2000ed7c 	.word	0x2000ed7c

Disassembly of section .text.SYS_TIME_HwTimerCompareUpdate%382:

0001860c <SYS_TIME_HwTimerCompareUpdate>:
{
   1860c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    SYS_TIME_TIMER_OBJ* tmrActive = counterObj->tmrActive;
   18610:	4b2a      	ldr	r3, [pc, #168]	; (186bc <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   18612:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    counterObj->hwTimerPreviousValue = counterObj->hwTimerCurrentValue;
   18614:	6959      	ldr	r1, [r3, #20]
   18616:	6119      	str	r1, [r3, #16]
    if (tmrActive != NULL)
   18618:	2a00      	cmp	r2, #0
   1861a:	d040      	beq.n	1869e <SYS_TIME_HwTimerCompareUpdate+0x92>
        if (tmrActive->relativeTimePending > SYS_TIME_HW_COUNTER_HALF_PERIOD)
   1861c:	6893      	ldr	r3, [r2, #8]
   1861e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   18622:	d333      	bcc.n	1868c <SYS_TIME_HwTimerCompareUpdate+0x80>
            nextHwCounterValue = (uint64_t)counterObj->hwTimerCurrentValue + SYS_TIME_HW_COUNTER_HALF_PERIOD;
   18624:	4b25      	ldr	r3, [pc, #148]	; (186bc <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   18626:	695b      	ldr	r3, [r3, #20]
   18628:	f647 74ff 	movw	r4, #32767	; 0x7fff
   1862c:	2500      	movs	r5, #0
   1862e:	eb14 0803 	adds.w	r8, r4, r3
   18632:	f145 0900 	adc.w	r9, r5, #0
    currHwCounterValue = counterObj->timePlib->timerCounterGet();
   18636:	4e21      	ldr	r6, [pc, #132]	; (186bc <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   18638:	6873      	ldr	r3, [r6, #4]
   1863a:	699b      	ldr	r3, [r3, #24]
   1863c:	4798      	blx	r3
   1863e:	b282      	uxth	r2, r0
   18640:	2300      	movs	r3, #0
    if (currHwCounterValue < counterObj->hwTimerPreviousValue)
   18642:	6931      	ldr	r1, [r6, #16]
   18644:	4281      	cmp	r1, r0
   18646:	d906      	bls.n	18656 <SYS_TIME_HwTimerCompareUpdate+0x4a>
        currHwCounterValue = SYS_TIME_HW_COUNTER_PERIOD + currHwCounterValue;
   18648:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1864c:	1852      	adds	r2, r2, r1
   1864e:	f04f 0100 	mov.w	r1, #0
   18652:	eb41 0303 	adc.w	r3, r1, r3
    if (nextHwCounterValue  < (currHwCounterValue + counterObj->hwTimerCompareMargin))
   18656:	4919      	ldr	r1, [pc, #100]	; (186bc <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   18658:	6a09      	ldr	r1, [r1, #32]
   1865a:	1856      	adds	r6, r2, r1
   1865c:	f143 0700 	adc.w	r7, r3, #0
   18660:	45b9      	cmp	r9, r7
   18662:	bf08      	it	eq
   18664:	45b0      	cmpeq	r8, r6
   18666:	d224      	bcs.n	186b2 <SYS_TIME_HwTimerCompareUpdate+0xa6>
        counterObj->hwTimerCompareValue = currHwCounterValue + counterObj->hwTimerCompareMargin;
   18668:	440a      	add	r2, r1
   1866a:	4b14      	ldr	r3, [pc, #80]	; (186bc <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   1866c:	61da      	str	r2, [r3, #28]
    if ((counterObj->hwTimerCompareValue & SYS_TIME_HW_COUNTER_PERIOD) == 0)
   1866e:	4b13      	ldr	r3, [pc, #76]	; (186bc <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   18670:	69db      	ldr	r3, [r3, #28]
   18672:	b29b      	uxth	r3, r3
   18674:	b913      	cbnz	r3, 1867c <SYS_TIME_HwTimerCompareUpdate+0x70>
        counterObj->hwTimerCompareValue = 1;
   18676:	4b11      	ldr	r3, [pc, #68]	; (186bc <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   18678:	2201      	movs	r2, #1
   1867a:	61da      	str	r2, [r3, #28]
    counterObj->timePlib->timerCompareSet(counterObj->hwTimerCompareValue);
   1867c:	4b0f      	ldr	r3, [pc, #60]	; (186bc <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   1867e:	69d8      	ldr	r0, [r3, #28]
   18680:	685b      	ldr	r3, [r3, #4]
   18682:	695b      	ldr	r3, [r3, #20]
   18684:	b280      	uxth	r0, r0
   18686:	4798      	blx	r3
}
   18688:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            uint32_t relativeTimePending = tmrActive->relativeTimePending;
   1868c:	6894      	ldr	r4, [r2, #8]
            nextHwCounterValue = (uint64_t)counterObj->hwTimerCurrentValue + relativeTimePending;
   1868e:	4b0b      	ldr	r3, [pc, #44]	; (186bc <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   18690:	695b      	ldr	r3, [r3, #20]
   18692:	2500      	movs	r5, #0
   18694:	eb14 0803 	adds.w	r8, r4, r3
   18698:	f145 0900 	adc.w	r9, r5, #0
   1869c:	e7cb      	b.n	18636 <SYS_TIME_HwTimerCompareUpdate+0x2a>
        nextHwCounterValue = (uint64_t)counterObj->hwTimerCurrentValue + SYS_TIME_HW_COUNTER_HALF_PERIOD;
   1869e:	4b07      	ldr	r3, [pc, #28]	; (186bc <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   186a0:	695b      	ldr	r3, [r3, #20]
   186a2:	f647 74ff 	movw	r4, #32767	; 0x7fff
   186a6:	2500      	movs	r5, #0
   186a8:	eb14 0803 	adds.w	r8, r4, r3
   186ac:	f145 0900 	adc.w	r9, r5, #0
   186b0:	e7c1      	b.n	18636 <SYS_TIME_HwTimerCompareUpdate+0x2a>
        counterObj->hwTimerCompareValue = nextHwCounterValue;
   186b2:	4b02      	ldr	r3, [pc, #8]	; (186bc <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   186b4:	f8c3 801c 	str.w	r8, [r3, #28]
   186b8:	e7d9      	b.n	1866e <SYS_TIME_HwTimerCompareUpdate+0x62>
   186ba:	bf00      	nop
   186bc:	2000ea00 	.word	0x2000ea00

Disassembly of section .text._malloc_r%383:

000186c0 <_malloc_r>:
   186c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   186c2:	1ccd      	adds	r5, r1, #3
   186c4:	f025 0503 	bic.w	r5, r5, #3
   186c8:	3508      	adds	r5, #8
   186ca:	2d0c      	cmp	r5, #12
   186cc:	bf38      	it	cc
   186ce:	250c      	movcc	r5, #12
   186d0:	2d00      	cmp	r5, #0
   186d2:	4606      	mov	r6, r0
   186d4:	db01      	blt.n	186da <_malloc_r+0x1a>
   186d6:	42a9      	cmp	r1, r5
   186d8:	d903      	bls.n	186e2 <_malloc_r+0x22>
   186da:	230c      	movs	r3, #12
   186dc:	6033      	str	r3, [r6, #0]
   186de:	2000      	movs	r0, #0
   186e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   186e2:	f007 fcae 	bl	20042 <__malloc_lock>
   186e6:	4921      	ldr	r1, [pc, #132]	; (1876c <_malloc_r+0xac>)
   186e8:	680a      	ldr	r2, [r1, #0]
   186ea:	4614      	mov	r4, r2
   186ec:	b99c      	cbnz	r4, 18716 <_malloc_r+0x56>
   186ee:	4f20      	ldr	r7, [pc, #128]	; (18770 <_malloc_r+0xb0>)
   186f0:	683b      	ldr	r3, [r7, #0]
   186f2:	b923      	cbnz	r3, 186fe <_malloc_r+0x3e>
   186f4:	4621      	mov	r1, r4
   186f6:	4630      	mov	r0, r6
   186f8:	f00a fb72 	bl	22de0 <_sbrk_r>
   186fc:	6038      	str	r0, [r7, #0]
   186fe:	4629      	mov	r1, r5
   18700:	4630      	mov	r0, r6
   18702:	f00a fb6d 	bl	22de0 <_sbrk_r>
   18706:	1c43      	adds	r3, r0, #1
   18708:	d123      	bne.n	18752 <_malloc_r+0x92>
   1870a:	230c      	movs	r3, #12
   1870c:	6033      	str	r3, [r6, #0]
   1870e:	4630      	mov	r0, r6
   18710:	f008 f96f 	bl	209f2 <__malloc_unlock>
   18714:	e7e3      	b.n	186de <_malloc_r+0x1e>
   18716:	6823      	ldr	r3, [r4, #0]
   18718:	1b5b      	subs	r3, r3, r5
   1871a:	d417      	bmi.n	1874c <_malloc_r+0x8c>
   1871c:	2b0b      	cmp	r3, #11
   1871e:	d903      	bls.n	18728 <_malloc_r+0x68>
   18720:	6023      	str	r3, [r4, #0]
   18722:	441c      	add	r4, r3
   18724:	6025      	str	r5, [r4, #0]
   18726:	e004      	b.n	18732 <_malloc_r+0x72>
   18728:	6863      	ldr	r3, [r4, #4]
   1872a:	42a2      	cmp	r2, r4
   1872c:	bf0c      	ite	eq
   1872e:	600b      	streq	r3, [r1, #0]
   18730:	6053      	strne	r3, [r2, #4]
   18732:	4630      	mov	r0, r6
   18734:	f008 f95d 	bl	209f2 <__malloc_unlock>
   18738:	f104 000b 	add.w	r0, r4, #11
   1873c:	1d23      	adds	r3, r4, #4
   1873e:	f020 0007 	bic.w	r0, r0, #7
   18742:	1ac2      	subs	r2, r0, r3
   18744:	d0cc      	beq.n	186e0 <_malloc_r+0x20>
   18746:	1a1b      	subs	r3, r3, r0
   18748:	50a3      	str	r3, [r4, r2]
   1874a:	e7c9      	b.n	186e0 <_malloc_r+0x20>
   1874c:	4622      	mov	r2, r4
   1874e:	6864      	ldr	r4, [r4, #4]
   18750:	e7cc      	b.n	186ec <_malloc_r+0x2c>
   18752:	1cc4      	adds	r4, r0, #3
   18754:	f024 0403 	bic.w	r4, r4, #3
   18758:	42a0      	cmp	r0, r4
   1875a:	d0e3      	beq.n	18724 <_malloc_r+0x64>
   1875c:	1a21      	subs	r1, r4, r0
   1875e:	4630      	mov	r0, r6
   18760:	f00a fb3e 	bl	22de0 <_sbrk_r>
   18764:	3001      	adds	r0, #1
   18766:	d1dd      	bne.n	18724 <_malloc_r+0x64>
   18768:	e7cf      	b.n	1870a <_malloc_r+0x4a>
   1876a:	bf00      	nop
   1876c:	2000ef64 	.word	0x2000ef64
   18770:	2000ef68 	.word	0x2000ef68

Disassembly of section .text.TCPIP_STACK_NetUp%384:

00018774 <TCPIP_STACK_NetUp>:
{
   18774:	b570      	push	{r4, r5, r6, lr}
    if(pNetIf)
   18776:	2800      	cmp	r0, #0
   18778:	d047      	beq.n	1880a <TCPIP_STACK_NetUp+0x96>
   1877a:	4605      	mov	r5, r0
        if(pNetIf->Flags.bInterfaceEnabled || pNetIf->Flags.bMacInitialize)
   1877c:	f8b0 2042 	ldrh.w	r2, [r0, #66]	; 0x42
   18780:	f244 0040 	movw	r0, #16448	; 0x4040
   18784:	4210      	tst	r0, r2
   18786:	d143      	bne.n	18810 <TCPIP_STACK_NetUp+0x9c>
        if(pUsrConfig == 0)
   18788:	2900      	cmp	r1, #0
   1878a:	d043      	beq.n	18814 <TCPIP_STACK_NetUp+0xa0>
   1878c:	460e      	mov	r6, r1
        tcpip_stack_ctrl_data.pNetIf = pNetIf;
   1878e:	4b22      	ldr	r3, [pc, #136]	; (18818 <TCPIP_STACK_NetUp+0xa4>)
   18790:	615d      	str	r5, [r3, #20]
        tcpip_stack_ctrl_data.netIx = pNetIf->netIfIx;
   18792:	f8b5 2058 	ldrh.w	r2, [r5, #88]	; 0x58
   18796:	619a      	str	r2, [r3, #24]
        tcpip_stack_ctrl_data.stackAction = TCPIP_STACK_ACTION_IF_UP;
   18798:	2203      	movs	r2, #3
   1879a:	771a      	strb	r2, [r3, #28]
        if(!_LoadNetworkConfig(pUsrConfig, pNetIf, true))
   1879c:	2201      	movs	r2, #1
   1879e:	4629      	mov	r1, r5
   187a0:	4630      	mov	r0, r6
   187a2:	f7fb f819 	bl	137d8 <_LoadNetworkConfig>
   187a6:	4604      	mov	r4, r0
   187a8:	b160      	cbz	r0, 187c4 <TCPIP_STACK_NetUp+0x50>
        powerMode = TCPIP_Helper_StringToPowerMode(pUsrConfig->powerMode);
   187aa:	6a30      	ldr	r0, [r6, #32]
   187ac:	f008 fd7e 	bl	212ac <TCPIP_Helper_StringToPowerMode>
   187b0:	4604      	mov	r4, r0
        if(powerMode != TCPIP_MAC_POWER_FULL && powerMode != TCPIP_MAC_POWER_DOWN)
   187b2:	f000 03fd 	and.w	r3, r0, #253	; 0xfd
   187b6:	2b01      	cmp	r3, #1
   187b8:	d017      	beq.n	187ea <TCPIP_STACK_NetUp+0x76>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Power Mode initialization fail: %d\r\n", powerMode);
   187ba:	f00b fd61 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
   187be:	b960      	cbnz	r0, 187da <TCPIP_STACK_NetUp+0x66>
            return false;
   187c0:	2400      	movs	r4, #0
   187c2:	e023      	b.n	1880c <TCPIP_STACK_NetUp+0x98>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration load failed: %d\r\n", pNetIf->netIfIx);
   187c4:	f00b fd5c 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
   187c8:	b300      	cbz	r0, 1880c <TCPIP_STACK_NetUp+0x98>
   187ca:	f00b fd53 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
   187ce:	f8b5 2058 	ldrh.w	r2, [r5, #88]	; 0x58
   187d2:	4912      	ldr	r1, [pc, #72]	; (1881c <TCPIP_STACK_NetUp+0xa8>)
   187d4:	f003 ff62 	bl	1c69c <SYS_CONSOLE_Print>
   187d8:	e018      	b.n	1880c <TCPIP_STACK_NetUp+0x98>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Power Mode initialization fail: %d\r\n", powerMode);
   187da:	f00b fd4b 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
   187de:	4622      	mov	r2, r4
   187e0:	490f      	ldr	r1, [pc, #60]	; (18820 <TCPIP_STACK_NetUp+0xac>)
   187e2:	f003 ff5b 	bl	1c69c <SYS_CONSOLE_Print>
            return false;
   187e6:	2400      	movs	r4, #0
   187e8:	e010      	b.n	1880c <TCPIP_STACK_NetUp+0x98>
        tcpip_stack_ctrl_data.powerMode = powerMode;
   187ea:	480b      	ldr	r0, [pc, #44]	; (18818 <TCPIP_STACK_NetUp+0xa4>)
   187ec:	7744      	strb	r4, [r0, #29]
        success = TCPIP_STACK_BringNetUp(&tcpip_stack_ctrl_data, pUsrConfig, 0, 0);
   187ee:	2300      	movs	r3, #0
   187f0:	461a      	mov	r2, r3
   187f2:	4631      	mov	r1, r6
   187f4:	f7f6 fc54 	bl	f0a0 <TCPIP_STACK_BringNetUp>
        if(!success)
   187f8:	4604      	mov	r4, r0
   187fa:	b938      	cbnz	r0, 1880c <TCPIP_STACK_NetUp+0x98>
            TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pNetIf, TCPIP_STACK_ACTION_IF_DOWN, TCPIP_MAC_POWER_DOWN);
   187fc:	2303      	movs	r3, #3
   187fe:	2204      	movs	r2, #4
   18800:	4629      	mov	r1, r5
   18802:	4805      	ldr	r0, [pc, #20]	; (18818 <TCPIP_STACK_NetUp+0xa4>)
   18804:	f004 faf0 	bl	1cde8 <TCPIP_STACK_BringNetDown>
   18808:	e000      	b.n	1880c <TCPIP_STACK_NetUp+0x98>
    return false;
   1880a:	2400      	movs	r4, #0
}
   1880c:	4620      	mov	r0, r4
   1880e:	bd70      	pop	{r4, r5, r6, pc}
            return true;
   18810:	2401      	movs	r4, #1
   18812:	e7fb      	b.n	1880c <TCPIP_STACK_NetUp+0x98>
            return false;
   18814:	2400      	movs	r4, #0
   18816:	e7f9      	b.n	1880c <TCPIP_STACK_NetUp+0x98>
   18818:	2000eae4 	.word	0x2000eae4
   1881c:	00009754 	.word	0x00009754
   18820:	00009694 	.word	0x00009694

Disassembly of section .text.SYS_TIME_TimerObjectCreate%385:

00018824 <SYS_TIME_TimerObjectCreate>:
    uint32_t period,
    SYS_TIME_CALLBACK callBack,
    uintptr_t context,
    SYS_TIME_CALLBACK_TYPE type
)
{
   18824:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18826:	4605      	mov	r5, r0
   18828:	460c      	mov	r4, r1
   1882a:	4617      	mov	r7, r2
   1882c:	461e      	mov	r6, r3
    SYS_TIME_HANDLE tmrHandle = SYS_TIME_HANDLE_INVALID;
    SYS_TIME_TIMER_OBJ *tmr;
    uint32_t tmrObjIndex = 0;

    if (SYS_TIME_ResourceLock() == false)
   1882e:	f008 f805 	bl	2083c <SYS_TIME_ResourceLock>
   18832:	2800      	cmp	r0, #0
   18834:	d042      	beq.n	188bc <SYS_TIME_TimerObjectCreate+0x98>
    {
        return tmrHandle;
    }
    if((gSystemCounterObj.status == SYS_STATUS_READY) && (period > 0) && (period >= count))
   18836:	4b23      	ldr	r3, [pc, #140]	; (188c4 <SYS_TIME_TimerObjectCreate+0xa0>)
   18838:	f993 3000 	ldrsb.w	r3, [r3]
   1883c:	2b02      	cmp	r3, #2
   1883e:	d005      	beq.n	1884c <SYS_TIME_TimerObjectCreate+0x28>
    SYS_TIME_HANDLE tmrHandle = SYS_TIME_HANDLE_INVALID;
   18840:	f04f 34ff 	mov.w	r4, #4294967295
            }
            tmrObjIndex++;
        }
    }

    SYS_TIME_ResourceUnlock();
   18844:	f007 fd2a 	bl	2029c <SYS_TIME_ResourceUnlock>

    return tmrHandle;
}
   18848:	4620      	mov	r0, r4
   1884a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((gSystemCounterObj.status == SYS_STATUS_READY) && (period > 0) && (period >= count))
   1884c:	2c00      	cmp	r4, #0
   1884e:	d02f      	beq.n	188b0 <SYS_TIME_TimerObjectCreate+0x8c>
   18850:	42ac      	cmp	r4, r5
   18852:	d330      	bcc.n	188b6 <SYS_TIME_TimerObjectCreate+0x92>
            if(tmr->inUse == false)
   18854:	4b1c      	ldr	r3, [pc, #112]	; (188c8 <SYS_TIME_TimerObjectCreate+0xa4>)
   18856:	781b      	ldrb	r3, [r3, #0]
   18858:	b153      	cbz	r3, 18870 <SYS_TIME_TimerObjectCreate+0x4c>
        for(tmr = timers; tmr < &timers[SYS_TIME_MAX_TIMERS]; tmr++)
   1885a:	4a1c      	ldr	r2, [pc, #112]	; (188cc <SYS_TIME_TimerObjectCreate+0xa8>)
            tmrObjIndex++;
   1885c:	2301      	movs	r3, #1
            if(tmr->inUse == false)
   1885e:	7811      	ldrb	r1, [r2, #0]
   18860:	b141      	cbz	r1, 18874 <SYS_TIME_TimerObjectCreate+0x50>
            tmrObjIndex++;
   18862:	3301      	adds	r3, #1
        for(tmr = timers; tmr < &timers[SYS_TIME_MAX_TIMERS]; tmr++)
   18864:	3220      	adds	r2, #32
   18866:	2b05      	cmp	r3, #5
   18868:	d1f9      	bne.n	1885e <SYS_TIME_TimerObjectCreate+0x3a>
    SYS_TIME_HANDLE tmrHandle = SYS_TIME_HANDLE_INVALID;
   1886a:	f04f 34ff 	mov.w	r4, #4294967295
   1886e:	e7e9      	b.n	18844 <SYS_TIME_TimerObjectCreate+0x20>
    uint32_t tmrObjIndex = 0;
   18870:	2300      	movs	r3, #0
        for(tmr = timers; tmr < &timers[SYS_TIME_MAX_TIMERS]; tmr++)
   18872:	4a15      	ldr	r2, [pc, #84]	; (188c8 <SYS_TIME_TimerObjectCreate+0xa4>)
                tmr->inUse = true;
   18874:	2101      	movs	r1, #1
   18876:	7011      	strb	r1, [r2, #0]
                tmr->active = false;
   18878:	2100      	movs	r1, #0
   1887a:	7051      	strb	r1, [r2, #1]
                tmr->tmrElapsedFlag = false;
   1887c:	7511      	strb	r1, [r2, #20]
                tmr->tmrElapsed = false;
   1887e:	7551      	strb	r1, [r2, #21]
                tmr->type = type;
   18880:	f89d 1018 	ldrb.w	r1, [sp, #24]
   18884:	7091      	strb	r1, [r2, #2]
                tmr->requestedTime = period;
   18886:	6054      	str	r4, [r2, #4]
                tmr->callback = callBack;
   18888:	60d7      	str	r7, [r2, #12]
                tmr->context = context;
   1888a:	6116      	str	r6, [r2, #16]
                tmr->relativeTimePending = period - count;
   1888c:	1b64      	subs	r4, r4, r5
   1888e:	6094      	str	r4, [r2, #8]
                tmr->tmrHandle = (SYS_TIME_HANDLE) SYS_TIME_MAKE_HANDLE(gSysTimeTokenCount, tmrObjIndex);
   18890:	490f      	ldr	r1, [pc, #60]	; (188d0 <SYS_TIME_TimerObjectCreate+0xac>)
   18892:	8809      	ldrh	r1, [r1, #0]
    return ((token) << 16 | (index));
   18894:	b29b      	uxth	r3, r3
   18896:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
                tmr->tmrHandle = (SYS_TIME_HANDLE) SYS_TIME_MAKE_HANDLE(gSysTimeTokenCount, tmrObjIndex);
   1889a:	61d4      	str	r4, [r2, #28]
    token++;
   1889c:	1c4b      	adds	r3, r1, #1
   1889e:	b29b      	uxth	r3, r3
        token = 1;
   188a0:	f64f 72ff 	movw	r2, #65535	; 0xffff
   188a4:	4293      	cmp	r3, r2
   188a6:	bf08      	it	eq
   188a8:	2301      	moveq	r3, #1
                gSysTimeTokenCount = SYS_TIME_UPDATE_TOKEN(gSysTimeTokenCount);
   188aa:	4a09      	ldr	r2, [pc, #36]	; (188d0 <SYS_TIME_TimerObjectCreate+0xac>)
   188ac:	8013      	strh	r3, [r2, #0]
                break;
   188ae:	e7c9      	b.n	18844 <SYS_TIME_TimerObjectCreate+0x20>
    SYS_TIME_HANDLE tmrHandle = SYS_TIME_HANDLE_INVALID;
   188b0:	f04f 34ff 	mov.w	r4, #4294967295
   188b4:	e7c6      	b.n	18844 <SYS_TIME_TimerObjectCreate+0x20>
   188b6:	f04f 34ff 	mov.w	r4, #4294967295
   188ba:	e7c3      	b.n	18844 <SYS_TIME_TimerObjectCreate+0x20>
        return tmrHandle;
   188bc:	f04f 34ff 	mov.w	r4, #4294967295
   188c0:	e7c2      	b.n	18848 <SYS_TIME_TimerObjectCreate+0x24>
   188c2:	bf00      	nop
   188c4:	2000ea00 	.word	0x2000ea00
   188c8:	2000e520 	.word	0x2000e520
   188cc:	2000e540 	.word	0x2000e540
   188d0:	2000ef88 	.word	0x2000ef88

Disassembly of section .text.SYS_TIME_Initialize%386:

000188d4 <SYS_TIME_Initialize>:
// Section: System Interface Functions
// *****************************************************************************
// *****************************************************************************
SYS_MODULE_OBJ SYS_TIME_Initialize( const SYS_MODULE_INDEX index, const SYS_MODULE_INIT * const init )
{
    if(init == 0 || index != SYS_TIME_INDEX_0)
   188d4:	2900      	cmp	r1, #0
   188d6:	d044      	beq.n	18962 <SYS_TIME_Initialize+0x8e>
{
   188d8:	b538      	push	{r3, r4, r5, lr}
   188da:	460d      	mov	r5, r1
    if(init == 0 || index != SYS_TIME_INDEX_0)
   188dc:	2800      	cmp	r0, #0
   188de:	d143      	bne.n	18968 <SYS_TIME_Initialize+0x94>
    {
        return SYS_MODULE_OBJ_INVALID;
    }
    /* Create mutex to guard from multiple contesting threads */
    if(OSAL_MUTEX_Create(&gSystemCounterObj.timerMutex) != OSAL_RESULT_TRUE)
   188e0:	4823      	ldr	r0, [pc, #140]	; (18970 <SYS_TIME_Initialize+0x9c>)
   188e2:	f00a ff5f 	bl	237a4 <OSAL_MUTEX_Create>
   188e6:	2801      	cmp	r0, #1
   188e8:	d002      	beq.n	188f0 <SYS_TIME_Initialize+0x1c>
    {
        return SYS_MODULE_OBJ_INVALID;
   188ea:	f04f 30ff 	mov.w	r0, #4294967295
   188ee:	e03d      	b.n	1896c <SYS_TIME_Initialize+0x98>
    counterObj->timePlib = initData->timePlib;
   188f0:	682b      	ldr	r3, [r5, #0]
   188f2:	4c20      	ldr	r4, [pc, #128]	; (18974 <SYS_TIME_Initialize+0xa0>)
   188f4:	6063      	str	r3, [r4, #4]
    counterObj->hwTimerFrequency = counterObj->timePlib->timerFrequencyGet();
   188f6:	68db      	ldr	r3, [r3, #12]
   188f8:	4798      	blx	r3
   188fa:	60e0      	str	r0, [r4, #12]
    cpuCyclesPerTimerClock=(SYS_TIME_CPU_CLOCK_FREQUENCY/counterObj->hwTimerFrequency);
   188fc:	4b1e      	ldr	r3, [pc, #120]	; (18978 <SYS_TIME_Initialize+0xa4>)
   188fe:	fbb3 f3f0 	udiv	r3, r3, r0
    counterObj->hwTimerCompareMargin=(SYS_TIME_COMPARE_UPDATE_EXECUTION_CYCLES/cpuCyclesPerTimerClock) +2;
   18902:	20bc      	movs	r0, #188	; 0xbc
   18904:	fb90 f0f3 	sdiv	r0, r0, r3
   18908:	3002      	adds	r0, #2
   1890a:	6220      	str	r0, [r4, #32]
    counterObj->hwTimerIntNum = initData->hwTimerIntNum;
   1890c:	f9b5 3004 	ldrsh.w	r3, [r5, #4]
   18910:	8123      	strh	r3, [r4, #8]
    counterObj->hwTimerPreviousValue = 0;
   18912:	2100      	movs	r1, #0
   18914:	6121      	str	r1, [r4, #16]
    counterObj->hwTimerPeriodValue = SYS_TIME_HW_COUNTER_PERIOD;
   18916:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1891a:	61a3      	str	r3, [r4, #24]
    counterObj->hwTimerCompareValue = SYS_TIME_HW_COUNTER_HALF_PERIOD;
   1891c:	f647 73ff 	movw	r3, #32767	; 0x7fff
   18920:	61e3      	str	r3, [r4, #28]
    counterObj->swCounter64Low = 0;
   18922:	6261      	str	r1, [r4, #36]	; 0x24
    counterObj->swCounter64High = 0;
   18924:	62a1      	str	r1, [r4, #40]	; 0x28
    counterObj->tmrActive = NULL;
   18926:	6321      	str	r1, [r4, #48]	; 0x30
    counterObj->interruptNestingCount = 0;
   18928:	f884 102c 	strb.w	r1, [r4, #44]	; 0x2c
    counterObj->timePlib->timerCallbackSet(SYS_TIME_PLIBCallback, 0);
   1892c:	6863      	ldr	r3, [r4, #4]
   1892e:	681b      	ldr	r3, [r3, #0]
   18930:	4812      	ldr	r0, [pc, #72]	; (1897c <SYS_TIME_Initialize+0xa8>)
   18932:	4798      	blx	r3
    if (counterObj->timePlib->timerPeriodSet != NULL)
   18934:	6863      	ldr	r3, [r4, #4]
   18936:	691b      	ldr	r3, [r3, #16]
   18938:	b10b      	cbz	r3, 1893e <SYS_TIME_Initialize+0x6a>
        counterObj->timePlib->timerPeriodSet(counterObj->hwTimerPeriodValue);
   1893a:	8b20      	ldrh	r0, [r4, #24]
   1893c:	4798      	blx	r3
    counterObj->timePlib->timerCompareSet(counterObj->hwTimerCompareValue);
   1893e:	4c0d      	ldr	r4, [pc, #52]	; (18974 <SYS_TIME_Initialize+0xa0>)
   18940:	69e0      	ldr	r0, [r4, #28]
   18942:	6863      	ldr	r3, [r4, #4]
   18944:	695b      	ldr	r3, [r3, #20]
   18946:	b280      	uxth	r0, r0
   18948:	4798      	blx	r3
    counterObj->timePlib->timerStart();
   1894a:	6863      	ldr	r3, [r4, #4]
   1894c:	685b      	ldr	r3, [r3, #4]
   1894e:	4798      	blx	r3
    }

    SYS_TIME_CounterInit((SYS_MODULE_INIT *)init);
    memset(timers, 0, sizeof(timers));
   18950:	22a0      	movs	r2, #160	; 0xa0
   18952:	2100      	movs	r1, #0
   18954:	480a      	ldr	r0, [pc, #40]	; (18980 <SYS_TIME_Initialize+0xac>)
   18956:	f00b faa3 	bl	23ea0 <memset>

    gSystemCounterObj.status = SYS_STATUS_READY;
   1895a:	2302      	movs	r3, #2
   1895c:	7023      	strb	r3, [r4, #0]

    return (SYS_MODULE_OBJ)&gSystemCounterObj;
   1895e:	4620      	mov	r0, r4
   18960:	e004      	b.n	1896c <SYS_TIME_Initialize+0x98>
        return SYS_MODULE_OBJ_INVALID;
   18962:	f04f 30ff 	mov.w	r0, #4294967295
}
   18966:	4770      	bx	lr
        return SYS_MODULE_OBJ_INVALID;
   18968:	f04f 30ff 	mov.w	r0, #4294967295
}
   1896c:	bd38      	pop	{r3, r4, r5, pc}
   1896e:	bf00      	nop
   18970:	2000ea34 	.word	0x2000ea34
   18974:	2000ea00 	.word	0x2000ea00
   18978:	07270e00 	.word	0x07270e00
   1897c:	00016dad 	.word	0x00016dad
   18980:	2000e520 	.word	0x2000e520

Disassembly of section .text.TCPIP_Commands_Initialize%387:

00018984 <TCPIP_Commands_Initialize>:
{
   18984:	b510      	push	{r4, lr}
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_UP)
   18986:	7f03      	ldrb	r3, [r0, #28]
   18988:	2b03      	cmp	r3, #3
   1898a:	d03b      	beq.n	18a04 <TCPIP_Commands_Initialize+0x80>
    if(commandInitCount == 0)
   1898c:	4b1e      	ldr	r3, [pc, #120]	; (18a08 <TCPIP_Commands_Initialize+0x84>)
   1898e:	681b      	ldr	r3, [r3, #0]
   18990:	b133      	cbz	r3, 189a0 <TCPIP_Commands_Initialize+0x1c>
    commandInitCount++;
   18992:	4a1d      	ldr	r2, [pc, #116]	; (18a08 <TCPIP_Commands_Initialize+0x84>)
   18994:	6813      	ldr	r3, [r2, #0]
   18996:	3301      	adds	r3, #1
   18998:	6013      	str	r3, [r2, #0]
    return true;
   1899a:	2401      	movs	r4, #1
}
   1899c:	4620      	mov	r0, r4
   1899e:	bd10      	pop	{r4, pc}
        initialNetIfs = stackCtrl->nIfs;
   189a0:	6802      	ldr	r2, [r0, #0]
   189a2:	4b1a      	ldr	r3, [pc, #104]	; (18a0c <TCPIP_Commands_Initialize+0x88>)
   189a4:	601a      	str	r2, [r3, #0]
        if (!SYS_CMD_ADDGRP(tcpipCmdTbl, sizeof(tcpipCmdTbl)/sizeof(*tcpipCmdTbl), "tcpip", ": stack commands"))
   189a6:	4a1a      	ldr	r2, [pc, #104]	; (18a10 <TCPIP_Commands_Initialize+0x8c>)
   189a8:	f502 6382 	add.w	r3, r2, #1040	; 0x410
   189ac:	f202 4224 	addw	r2, r2, #1060	; 0x424
   189b0:	2111      	movs	r1, #17
   189b2:	4818      	ldr	r0, [pc, #96]	; (18a14 <TCPIP_Commands_Initialize+0x90>)
   189b4:	f003 fe3c 	bl	1c630 <SYS_CMD_ADDGRP>
   189b8:	4604      	mov	r4, r0
   189ba:	b168      	cbz	r0, 189d8 <TCPIP_Commands_Initialize+0x54>
        icmpAckRecv = 0;
   189bc:	2200      	movs	r2, #0
   189be:	4b16      	ldr	r3, [pc, #88]	; (18a18 <TCPIP_Commands_Initialize+0x94>)
   189c0:	601a      	str	r2, [r3, #0]
        tcpipCmdSignalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_COMMAND_Task, 0);
   189c2:	4916      	ldr	r1, [pc, #88]	; (18a1c <TCPIP_Commands_Initialize+0x98>)
   189c4:	201f      	movs	r0, #31
   189c6:	f006 f9eb 	bl	1eda0 <_TCPIPStackSignalHandlerRegister>
   189ca:	4b15      	ldr	r3, [pc, #84]	; (18a20 <TCPIP_Commands_Initialize+0x9c>)
   189cc:	6018      	str	r0, [r3, #0]
        if(tcpipCmdSignalHandle == 0)
   189ce:	b168      	cbz	r0, 189ec <TCPIP_Commands_Initialize+0x68>
        tcpipCmdStat = TCPIP_CMD_STAT_IDLE;
   189d0:	4b14      	ldr	r3, [pc, #80]	; (18a24 <TCPIP_Commands_Initialize+0xa0>)
   189d2:	2200      	movs	r2, #0
   189d4:	701a      	strb	r2, [r3, #0]
   189d6:	e7dc      	b.n	18992 <TCPIP_Commands_Initialize+0xe>
            SYS_ERROR(SYS_ERROR_ERROR, "Failed to create TCPIP Commands\r\n");
   189d8:	f00b fc52 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
   189dc:	2800      	cmp	r0, #0
   189de:	d0dd      	beq.n	1899c <TCPIP_Commands_Initialize+0x18>
   189e0:	f00b fc48 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
   189e4:	4910      	ldr	r1, [pc, #64]	; (18a28 <TCPIP_Commands_Initialize+0xa4>)
   189e6:	f003 fe59 	bl	1c69c <SYS_CONSOLE_Print>
   189ea:	e7d7      	b.n	1899c <TCPIP_Commands_Initialize+0x18>
            SYS_ERROR(SYS_ERROR_ERROR, "TCPIP commands task registration failed\r\n");
   189ec:	f00b fc48 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
   189f0:	b908      	cbnz	r0, 189f6 <TCPIP_Commands_Initialize+0x72>
            return false;
   189f2:	2400      	movs	r4, #0
   189f4:	e7d2      	b.n	1899c <TCPIP_Commands_Initialize+0x18>
            SYS_ERROR(SYS_ERROR_ERROR, "TCPIP commands task registration failed\r\n");
   189f6:	f00b fc3d 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
   189fa:	490c      	ldr	r1, [pc, #48]	; (18a2c <TCPIP_Commands_Initialize+0xa8>)
   189fc:	f003 fe4e 	bl	1c69c <SYS_CONSOLE_Print>
            return false;
   18a00:	2400      	movs	r4, #0
   18a02:	e7cb      	b.n	1899c <TCPIP_Commands_Initialize+0x18>
        return true;
   18a04:	2401      	movs	r4, #1
   18a06:	e7c9      	b.n	1899c <TCPIP_Commands_Initialize+0x18>
   18a08:	2000eddc 	.word	0x2000eddc
   18a0c:	2000ee0c 	.word	0x2000ee0c
   18a10:	00001384 	.word	0x00001384
   18a14:	00017290 	.word	0x00017290
   18a18:	2000ede8 	.word	0x2000ede8
   18a1c:	0000acf1 	.word	0x0000acf1
   18a20:	2000ee18 	.word	0x2000ee18
   18a24:	2000ebc3 	.word	0x2000ebc3
   18a28:	000017b0 	.word	0x000017b0
   18a2c:	000017d4 	.word	0x000017d4

Disassembly of section .text._TcpDisconnect%388:

00018a30 <_TcpDisconnect>:
{
   18a30:	b570      	push	{r4, r5, r6, lr}
	switch(pSkt->smState)
   18a32:	f890 306e 	ldrb.w	r3, [r0, #110]	; 0x6e
   18a36:	3b02      	subs	r3, #2
   18a38:	2b08      	cmp	r3, #8
   18a3a:	d806      	bhi.n	18a4a <_TcpDisconnect+0x1a>
   18a3c:	e8df f003 	tbb	[pc, r3]
   18a40:	4b4b0707 	.word	0x4b4b0707
   18a44:	4b074b4b 	.word	0x4b074b4b
   18a48:	46          	.byte	0x46
   18a49:	00          	.byte	0x00
            sendRes = _TCP_SEND_NOT_CONN;
   18a4a:	2001      	movs	r0, #1
   18a4c:	e044      	b.n	18ad8 <_TcpDisconnect+0xa8>
   18a4e:	4604      	mov	r4, r0
            if(pSkt->flags.nonLinger != 0)
   18a50:	f890 306c 	ldrb.w	r3, [r0, #108]	; 0x6c
   18a54:	f013 0f40 	tst.w	r3, #64	; 0x40
   18a58:	d114      	bne.n	18a84 <_TcpDisconnect+0x54>
            sendData = (signalFIN || (pSkt->txHead != pSkt->txUnackedTail));
   18a5a:	b9f1      	cbnz	r1, 18a9a <_TcpDisconnect+0x6a>
            if(sendData)
   18a5c:	6882      	ldr	r2, [r0, #8]
   18a5e:	6903      	ldr	r3, [r0, #16]
   18a60:	429a      	cmp	r2, r3
   18a62:	d118      	bne.n	18a96 <_TcpDisconnect+0x66>
                sendRes = _TCP_SEND_OK; 
   18a64:	2000      	movs	r0, #0
                pSkt->Flags.failedDisconnect = 0;
   18a66:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
   18a6a:	f36f 03c3 	bfc	r3, #3, #1
   18a6e:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37
                _TcpSocketSetState(pSkt, pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT ? TCPIP_TCP_STATE_LAST_ACK : TCPIP_TCP_STATE_FIN_WAIT_1);
   18a72:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
   18a76:	2b08      	cmp	r3, #8
   18a78:	bf0c      	ite	eq
   18a7a:	2309      	moveq	r3, #9
   18a7c:	2304      	movne	r3, #4
    pSkt->smState = newState;
   18a7e:	f884 306e 	strb.w	r3, [r4, #110]	; 0x6e
   18a82:	e029      	b.n	18ad8 <_TcpDisconnect+0xa8>
    pSkt->txHead = pSkt->txTail = pSkt->txUnackedTail = pSkt->txStart;
   18a84:	6803      	ldr	r3, [r0, #0]
   18a86:	6103      	str	r3, [r0, #16]
   18a88:	60c3      	str	r3, [r0, #12]
   18a8a:	6083      	str	r3, [r0, #8]
            sendData = (signalFIN || (pSkt->txHead != pSkt->txUnackedTail));
   18a8c:	b109      	cbz	r1, 18a92 <_TcpDisconnect+0x62>
                tcpFlags = signalFIN? FIN | ACK : ACK;
   18a8e:	2511      	movs	r5, #17
   18a90:	e004      	b.n	18a9c <_TcpDisconnect+0x6c>
                sendRes = _TCP_SEND_OK; 
   18a92:	2000      	movs	r0, #0
   18a94:	e7e7      	b.n	18a66 <_TcpDisconnect+0x36>
                tcpFlags = signalFIN? FIN | ACK : ACK;
   18a96:	2510      	movs	r5, #16
   18a98:	e000      	b.n	18a9c <_TcpDisconnect+0x6c>
   18a9a:	2511      	movs	r5, #17
                    sendRes = _TcpSend(pSkt, tcpFlags, SENDTCP_RESET_TIMERS);
   18a9c:	2601      	movs	r6, #1
   18a9e:	4632      	mov	r2, r6
   18aa0:	4629      	mov	r1, r5
   18aa2:	4620      	mov	r0, r4
   18aa4:	f7ef fa4c 	bl	7f40 <_TcpSend>
                    if(sendRes < 0 || pSkt->remoteWindow == 0u)
   18aa8:	2800      	cmp	r0, #0
   18aaa:	db08      	blt.n	18abe <_TcpDisconnect+0x8e>
   18aac:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
   18ab0:	2b00      	cmp	r3, #0
   18ab2:	d0d8      	beq.n	18a66 <_TcpDisconnect+0x36>
                } while(pSkt->txHead != pSkt->txUnackedTail);
   18ab4:	68a2      	ldr	r2, [r4, #8]
   18ab6:	6923      	ldr	r3, [r4, #16]
   18ab8:	429a      	cmp	r2, r3
   18aba:	d1f0      	bne.n	18a9e <_TcpDisconnect+0x6e>
   18abc:	e7d3      	b.n	18a66 <_TcpDisconnect+0x36>
                pSkt->Flags.failedDisconnect = 1;
   18abe:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
   18ac2:	f043 0308 	orr.w	r3, r3, #8
   18ac6:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37
   18aca:	e005      	b.n	18ad8 <_TcpDisconnect+0xa8>
            _TcpCloseSocket(pSkt, 0);
   18acc:	2100      	movs	r1, #0
   18ace:	f7f9 fbbd 	bl	1224c <_TcpCloseSocket>
            sendRes = _TCP_SEND_OK;
   18ad2:	2000      	movs	r0, #0
            break;
   18ad4:	e000      	b.n	18ad8 <_TcpDisconnect+0xa8>
            sendRes = _TCP_SEND_OK;
   18ad6:	2000      	movs	r0, #0
}
   18ad8:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text._TCPIP_HEAP_Malloc%389:

00018ada <_TCPIP_HEAP_Malloc>:
    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   18ada:	2800      	cmp	r0, #0
   18adc:	d051      	beq.n	18b82 <_TCPIP_HEAP_Malloc+0xa8>
{
   18ade:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18ae0:	4606      	mov	r6, r0
	if(hDcpt == 0 || nBytes == 0)
   18ae2:	2900      	cmp	r1, #0
   18ae4:	d03f      	beq.n	18b66 <_TCPIP_HEAP_Malloc+0x8c>
	nunits=(nBytes+sizeof(_headNode)-1)/sizeof(_headNode)+1;	// allocate units   
   18ae6:	f101 050f 	add.w	r5, r1, #15
   18aea:	092d      	lsrs	r5, r5, #4
   18aec:	3501      	adds	r5, #1
    OSAL_SEM_Pend(&hDcpt->_heapSemaphore, OSAL_WAIT_FOREVER);
   18aee:	f100 0744 	add.w	r7, r0, #68	; 0x44
   18af2:	f64f 71ff 	movw	r1, #65535	; 0xffff
   18af6:	4638      	mov	r0, r7
   18af8:	f00a f9fc 	bl	22ef4 <OSAL_SEM_Pend>
	for(ptr = hDcpt->_heapHead; ptr != 0; prev = ptr, ptr = ptr->next)
   18afc:	6a73      	ldr	r3, [r6, #36]	; 0x24
   18afe:	b353      	cbz	r3, 18b56 <_TCPIP_HEAP_Malloc+0x7c>
		if(ptr->units >= nunits)
   18b00:	685a      	ldr	r2, [r3, #4]
   18b02:	4295      	cmp	r5, r2
   18b04:	d931      	bls.n	18b6a <_TCPIP_HEAP_Malloc+0x90>
	for(ptr = hDcpt->_heapHead; ptr != 0; prev = ptr, ptr = ptr->next)
   18b06:	681c      	ldr	r4, [r3, #0]
   18b08:	b32c      	cbz	r4, 18b56 <_TCPIP_HEAP_Malloc+0x7c>
		if(ptr->units >= nunits)
   18b0a:	6862      	ldr	r2, [r4, #4]
   18b0c:	42aa      	cmp	r2, r5
   18b0e:	d201      	bcs.n	18b14 <_TCPIP_HEAP_Malloc+0x3a>
	for(ptr = hDcpt->_heapHead; ptr != 0; prev = ptr, ptr = ptr->next)
   18b10:	4623      	mov	r3, r4
   18b12:	e7f8      	b.n	18b06 <_TCPIP_HEAP_Malloc+0x2c>
			if(ptr->units-nunits <= _TCPIP_HEAP_MIN_BLK_USIZE_)
   18b14:	1b51      	subs	r1, r2, r5
   18b16:	2902      	cmp	r1, #2
   18b18:	d913      	bls.n	18b42 <_TCPIP_HEAP_Malloc+0x68>
            if(ptr->units == nunits)
   18b1a:	4295      	cmp	r5, r2
   18b1c:	d010      	beq.n	18b40 <_TCPIP_HEAP_Malloc+0x66>
				ptr->units -= nunits;
   18b1e:	6061      	str	r1, [r4, #4]
				ptr += ptr->units;
   18b20:	eb04 1401 	add.w	r4, r4, r1, lsl #4
				ptr->units = nunits;
   18b24:	6065      	str	r5, [r4, #4]
            if((hDcpt->_heapAllocatedUnits += nunits) > hDcpt->_heapWatermark)
   18b26:	6b33      	ldr	r3, [r6, #48]	; 0x30
   18b28:	441d      	add	r5, r3
   18b2a:	6335      	str	r5, [r6, #48]	; 0x30
   18b2c:	6b73      	ldr	r3, [r6, #52]	; 0x34
   18b2e:	429d      	cmp	r5, r3
                hDcpt->_heapWatermark = hDcpt->_heapAllocatedUnits;
   18b30:	bf88      	it	hi
   18b32:	6375      	strhi	r5, [r6, #52]	; 0x34
            OSAL_SEM_Post(&hDcpt->_heapSemaphore);
   18b34:	4638      	mov	r0, r7
   18b36:	f00a fe29 	bl	2378c <OSAL_SEM_Post>
            return ptr + 1;
   18b3a:	f104 0010 	add.w	r0, r4, #16
   18b3e:	e011      	b.n	18b64 <_TCPIP_HEAP_Malloc+0x8a>
				if(prev)
   18b40:	b13b      	cbz	r3, 18b52 <_TCPIP_HEAP_Malloc+0x78>
					prev->next = ptr->next;
   18b42:	6821      	ldr	r1, [r4, #0]
   18b44:	6019      	str	r1, [r3, #0]
   18b46:	4615      	mov	r5, r2
                if(hDcpt->_heapTail == ptr)
   18b48:	6ab2      	ldr	r2, [r6, #40]	; 0x28
   18b4a:	42a2      	cmp	r2, r4
   18b4c:	d1eb      	bne.n	18b26 <_TCPIP_HEAP_Malloc+0x4c>
                    hDcpt->_heapTail = prev;
   18b4e:	62b3      	str	r3, [r6, #40]	; 0x28
   18b50:	e7e9      	b.n	18b26 <_TCPIP_HEAP_Malloc+0x4c>
   18b52:	4623      	mov	r3, r4
   18b54:	e00c      	b.n	18b70 <_TCPIP_HEAP_Malloc+0x96>
    hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_NO_MEM;
   18b56:	23fa      	movs	r3, #250	; 0xfa
   18b58:	f886 3038 	strb.w	r3, [r6, #56]	; 0x38
    OSAL_SEM_Post(&hDcpt->_heapSemaphore);
   18b5c:	4638      	mov	r0, r7
   18b5e:	f00a fe15 	bl	2378c <OSAL_SEM_Post>
    return 0;
   18b62:	2000      	movs	r0, #0
}
   18b64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return 0;
   18b66:	2000      	movs	r0, #0
   18b68:	e7fc      	b.n	18b64 <_TCPIP_HEAP_Malloc+0x8a>
			if(ptr->units-nunits <= _TCPIP_HEAP_MIN_BLK_USIZE_)
   18b6a:	1b51      	subs	r1, r2, r5
   18b6c:	2902      	cmp	r1, #2
   18b6e:	d805      	bhi.n	18b7c <_TCPIP_HEAP_Malloc+0xa2>
					hDcpt->_heapHead = ptr->next;
   18b70:	6819      	ldr	r1, [r3, #0]
   18b72:	6271      	str	r1, [r6, #36]	; 0x24
   18b74:	461c      	mov	r4, r3
   18b76:	4615      	mov	r5, r2
                    prev = hDcpt->_heapHead;
   18b78:	460b      	mov	r3, r1
   18b7a:	e7e5      	b.n	18b48 <_TCPIP_HEAP_Malloc+0x6e>
	for(ptr = hDcpt->_heapHead; ptr != 0; prev = ptr, ptr = ptr->next)
   18b7c:	461c      	mov	r4, r3
	prev=0;
   18b7e:	2300      	movs	r3, #0
   18b80:	e7cb      	b.n	18b1a <_TCPIP_HEAP_Malloc+0x40>
}
   18b82:	4770      	bx	lr

Disassembly of section .text.Hash_DRBG_Reseed%390:

00018b84 <Hash_DRBG_Reseed>:
{
   18b84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   18b88:	b092      	sub	sp, #72	; 0x48
   18b8a:	4607      	mov	r7, r0
   18b8c:	460d      	mov	r5, r1
   18b8e:	4616      	mov	r6, r2
    XMEMSET(newV, 0, DRBG_SEED_LEN);
   18b90:	2437      	movs	r4, #55	; 0x37
   18b92:	4622      	mov	r2, r4
   18b94:	2100      	movs	r1, #0
   18b96:	a804      	add	r0, sp, #16
   18b98:	f00b f982 	bl	23ea0 <memset>
                drbg->V, sizeof(drbg->V), seed, seedSz) != DRBG_SUCCESS) {
   18b9c:	f107 0808 	add.w	r8, r7, #8
    if (Hash_df(drbg, newV, sizeof(newV), drbgReseed,
   18ba0:	9603      	str	r6, [sp, #12]
   18ba2:	9502      	str	r5, [sp, #8]
   18ba4:	9401      	str	r4, [sp, #4]
   18ba6:	f8cd 8000 	str.w	r8, [sp]
   18baa:	2301      	movs	r3, #1
   18bac:	4622      	mov	r2, r4
   18bae:	a904      	add	r1, sp, #16
   18bb0:	4638      	mov	r0, r7
   18bb2:	f7fa fc35 	bl	13420 <Hash_df>
   18bb6:	2800      	cmp	r0, #0
   18bb8:	d135      	bne.n	18c26 <Hash_DRBG_Reseed+0xa2>
    XMEMCPY(drbg->V, newV, sizeof(drbg->V));
   18bba:	ae04      	add	r6, sp, #16
   18bbc:	4644      	mov	r4, r8
   18bbe:	f10d 0c40 	add.w	ip, sp, #64	; 0x40
   18bc2:	4635      	mov	r5, r6
   18bc4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   18bc6:	6020      	str	r0, [r4, #0]
   18bc8:	6061      	str	r1, [r4, #4]
   18bca:	60a2      	str	r2, [r4, #8]
   18bcc:	60e3      	str	r3, [r4, #12]
   18bce:	462e      	mov	r6, r5
   18bd0:	3410      	adds	r4, #16
   18bd2:	4565      	cmp	r5, ip
   18bd4:	d1f5      	bne.n	18bc2 <Hash_DRBG_Reseed+0x3e>
   18bd6:	6828      	ldr	r0, [r5, #0]
   18bd8:	6020      	str	r0, [r4, #0]
   18bda:	88aa      	ldrh	r2, [r5, #4]
   18bdc:	79ab      	ldrb	r3, [r5, #6]
   18bde:	80a2      	strh	r2, [r4, #4]
   18be0:	71a3      	strb	r3, [r4, #6]
    volatile byte* z = (volatile byte*)mem;
   18be2:	aa04      	add	r2, sp, #16
    while (len--) *z++ = 0;
   18be4:	2000      	movs	r0, #0
   18be6:	f10d 0147 	add.w	r1, sp, #71	; 0x47
   18bea:	4613      	mov	r3, r2
   18bec:	f803 0b01 	strb.w	r0, [r3], #1
   18bf0:	461a      	mov	r2, r3
   18bf2:	428b      	cmp	r3, r1
   18bf4:	d1f9      	bne.n	18bea <Hash_DRBG_Reseed+0x66>
    if (Hash_df(drbg, drbg->C, sizeof(drbg->C), drbgInitC, drbg->V,
   18bf6:	2300      	movs	r3, #0
   18bf8:	9303      	str	r3, [sp, #12]
   18bfa:	9302      	str	r3, [sp, #8]
   18bfc:	2237      	movs	r2, #55	; 0x37
   18bfe:	9201      	str	r2, [sp, #4]
   18c00:	f8cd 8000 	str.w	r8, [sp]
   18c04:	f107 013f 	add.w	r1, r7, #63	; 0x3f
   18c08:	4638      	mov	r0, r7
   18c0a:	f7fa fc09 	bl	13420 <Hash_df>
   18c0e:	4603      	mov	r3, r0
   18c10:	b958      	cbnz	r0, 18c2a <Hash_DRBG_Reseed+0xa6>
    drbg->reseedCtr = 1;
   18c12:	2201      	movs	r2, #1
   18c14:	603a      	str	r2, [r7, #0]
    drbg->lastBlock = 0;
   18c16:	2200      	movs	r2, #0
   18c18:	607a      	str	r2, [r7, #4]
    drbg->matchCount = 0;
   18c1a:	f887 2080 	strb.w	r2, [r7, #128]	; 0x80
}
   18c1e:	4618      	mov	r0, r3
   18c20:	b012      	add	sp, #72	; 0x48
   18c22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return DRBG_FAILURE;
   18c26:	2301      	movs	r3, #1
   18c28:	e7f9      	b.n	18c1e <Hash_DRBG_Reseed+0x9a>
        return DRBG_FAILURE;
   18c2a:	2301      	movs	r3, #1
   18c2c:	e7f7      	b.n	18c1e <Hash_DRBG_Reseed+0x9a>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseReset%391:

00018c30 <_DRV_ETHPHY_SetupPhaseReset>:
{
   18c30:	b538      	push	{r3, r4, r5, lr}
   18c32:	4604      	mov	r4, r0
    switch(hClientObj->operSubPhase)
   18c34:	8c03      	ldrh	r3, [r0, #32]
   18c36:	2b01      	cmp	r3, #1
   18c38:	d014      	beq.n	18c64 <_DRV_ETHPHY_SetupPhaseReset+0x34>
   18c3a:	b21a      	sxth	r2, r3
   18c3c:	b132      	cbz	r2, 18c4c <_DRV_ETHPHY_SetupPhaseReset+0x1c>
   18c3e:	2b02      	cmp	r3, #2
   18c40:	d02a      	beq.n	18c98 <_DRV_ETHPHY_SetupPhaseReset+0x68>
            _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_DTCT_ERR);
   18c42:	f04f 31ff 	mov.w	r1, #4294967295
   18c46:	f009 f8f1 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
}
   18c4a:	bd38      	pop	{r3, r4, r5, pc}
            if(_DRV_PHY_SMIWriteStart(hClientObj, PHY_REG_BMCON, _BMCON_RESET_MASK))
   18c4c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   18c50:	2100      	movs	r1, #0
   18c52:	f008 f9a6 	bl	20fa2 <_DRV_PHY_SMIWriteStart>
   18c56:	2800      	cmp	r0, #0
   18c58:	d0f7      	beq.n	18c4a <_DRV_ETHPHY_SetupPhaseReset+0x1a>
    hClientObj->operPhase = operPhase;
   18c5a:	2302      	movs	r3, #2
   18c5c:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   18c5e:	2301      	movs	r3, #1
   18c60:	8423      	strh	r3, [r4, #32]
   18c62:	e7f2      	b.n	18c4a <_DRV_ETHPHY_SetupPhaseReset+0x1a>
            if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMCON))
   18c64:	2100      	movs	r1, #0
   18c66:	f008 f983 	bl	20f70 <_DRV_PHY_SMIReadStart>
   18c6a:	2800      	cmp	r0, #0
   18c6c:	d0ed      	beq.n	18c4a <_DRV_ETHPHY_SetupPhaseReset+0x1a>
                hClientObj->operTStamp = SYS_TMR_TickCountGet() + ((DRV_ETHPHY_RESET_CLR_TMO * SYS_TMR_TickCounterFrequencyGet()) + 999) / 1000;
   18c6e:	f009 fae5 	bl	2223c <SYS_TMR_TickCountGet>
   18c72:	4605      	mov	r5, r0
   18c74:	f009 fb0a 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
   18c78:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   18c7c:	fb03 f000 	mul.w	r0, r3, r0
   18c80:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
   18c84:	4b13      	ldr	r3, [pc, #76]	; (18cd4 <_DRV_ETHPHY_SetupPhaseReset+0xa4>)
   18c86:	fba3 3000 	umull	r3, r0, r3, r0
   18c8a:	eb05 1090 	add.w	r0, r5, r0, lsr #6
   18c8e:	62a0      	str	r0, [r4, #40]	; 0x28
    hClientObj->operPhase = operPhase;
   18c90:	2302      	movs	r3, #2
   18c92:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   18c94:	8423      	strh	r3, [r4, #32]
   18c96:	e7d8      	b.n	18c4a <_DRV_ETHPHY_SetupPhaseReset+0x1a>
            if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   18c98:	f009 fe1c 	bl	228d4 <_DRV_PHY_SMITransfer_Wait>
   18c9c:	2800      	cmp	r0, #0
   18c9e:	d0d4      	beq.n	18c4a <_DRV_ETHPHY_SetupPhaseReset+0x1a>
            if(bmcon.RESET)
   18ca0:	f994 303b 	ldrsb.w	r3, [r4, #59]	; 0x3b
   18ca4:	2b00      	cmp	r3, #0
   18ca6:	db04      	blt.n	18cb2 <_DRV_ETHPHY_SetupPhaseReset+0x82>
    hClientObj->operPhase = operPhase;
   18ca8:	2303      	movs	r3, #3
   18caa:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   18cac:	2300      	movs	r3, #0
   18cae:	8423      	strh	r3, [r4, #32]
   18cb0:	e7cb      	b.n	18c4a <_DRV_ETHPHY_SetupPhaseReset+0x1a>
                if(SYS_TMR_TickCountGet() < hClientObj->operTStamp)
   18cb2:	f009 fac3 	bl	2223c <SYS_TMR_TickCountGet>
   18cb6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   18cb8:	4298      	cmp	r0, r3
   18cba:	d204      	bcs.n	18cc6 <_DRV_ETHPHY_SetupPhaseReset+0x96>
    hClientObj->operPhase = operPhase;
   18cbc:	2302      	movs	r3, #2
   18cbe:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   18cc0:	2301      	movs	r3, #1
   18cc2:	8423      	strh	r3, [r4, #32]
   18cc4:	e7c1      	b.n	18c4a <_DRV_ETHPHY_SetupPhaseReset+0x1a>
                    _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_DTCT_ERR);
   18cc6:	f04f 31ff 	mov.w	r1, #4294967295
   18cca:	4620      	mov	r0, r4
   18ccc:	f009 f8ae 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
   18cd0:	e7bb      	b.n	18c4a <_DRV_ETHPHY_SetupPhaseReset+0x1a>
   18cd2:	bf00      	nop
   18cd4:	10624dd3 	.word	0x10624dd3

Disassembly of section .text._TCP_SktSetSequenceNo%392:

00018cd8 <_TCP_SktSetSequenceNo>:
{
   18cd8:	b570      	push	{r4, r5, r6, lr}
   18cda:	b0fa      	sub	sp, #488	; 0x1e8
   18cdc:	4604      	mov	r4, r0
    SYS_RANDOM_CryptoBlockGet(secretKey, sizeof(secretKey));
   18cde:	2110      	movs	r1, #16
   18ce0:	a808      	add	r0, sp, #32
   18ce2:	f009 fbd2 	bl	2248a <SYS_RANDOM_CryptoBlockGet>
    CRYPT_MD5_Initialize(&md5Ctx);
   18ce6:	a80c      	add	r0, sp, #48	; 0x30
   18ce8:	f00a ff9c 	bl	23c24 <CRYPT_MD5_Initialize>
    if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   18cec:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
   18cf0:	2b01      	cmp	r3, #1
   18cf2:	d033      	beq.n	18d5c <_TCP_SktSetSequenceNo+0x84>
    size_t dataSize = 0;    // actual data size
   18cf4:	2200      	movs	r2, #0
    CRYPT_MD5_DataAdd(&md5Ctx, hashData.data8, dataSize);
   18cf6:	a901      	add	r1, sp, #4
   18cf8:	a80c      	add	r0, sp, #48	; 0x30
   18cfa:	f00a fc26 	bl	2354a <CRYPT_MD5_DataAdd>
    CRYPT_MD5_Finalize(&md5Ctx, hashData.data8);
   18cfe:	a901      	add	r1, sp, #4
   18d00:	a80c      	add	r0, sp, #48	; 0x30
   18d02:	f00a fc2e 	bl	23562 <CRYPT_MD5_Finalize>
    uint32_t m = (SYS_TIME_Counter64Get() * 1000000 / 64 ) / SYS_TIME_FrequencyGet();   // 274 seconds period > MSL = 120 seconds
   18d06:	f007 fae7 	bl	202d8 <SYS_TIME_Counter64Get>
   18d0a:	4604      	mov	r4, r0
   18d0c:	460d      	mov	r5, r1
   18d0e:	f00b fabd 	bl	2428c <SYS_TIME_FrequencyGet>
   18d12:	016a      	lsls	r2, r5, #5
   18d14:	0163      	lsls	r3, r4, #5
   18d16:	ea42 61d4 	orr.w	r1, r2, r4, lsr #27
   18d1a:	1b1b      	subs	r3, r3, r4
   18d1c:	eb61 0105 	sbc.w	r1, r1, r5
   18d20:	024a      	lsls	r2, r1, #9
   18d22:	ea42 52d3 	orr.w	r2, r2, r3, lsr #23
   18d26:	025e      	lsls	r6, r3, #9
   18d28:	4611      	mov	r1, r2
   18d2a:	1933      	adds	r3, r6, r4
   18d2c:	eb45 0101 	adc.w	r1, r5, r1
   18d30:	018e      	lsls	r6, r1, #6
   18d32:	ea46 6693 	orr.w	r6, r6, r3, lsr #26
   18d36:	019a      	lsls	r2, r3, #6
   18d38:	1ad3      	subs	r3, r2, r3
   18d3a:	eb66 0101 	sbc.w	r1, r6, r1
   18d3e:	191b      	adds	r3, r3, r4
   18d40:	eb45 0101 	adc.w	r1, r5, r1
   18d44:	099c      	lsrs	r4, r3, #6
   18d46:	4602      	mov	r2, r0
   18d48:	2300      	movs	r3, #0
   18d4a:	ea44 6081 	orr.w	r0, r4, r1, lsl #26
   18d4e:	0989      	lsrs	r1, r1, #6
   18d50:	f008 fc44 	bl	215dc <__aeabi_uldivmod>
    uint32_t seq = hashData.data32[0] + m;
   18d54:	9b01      	ldr	r3, [sp, #4]
}
   18d56:	4418      	add	r0, r3
   18d58:	b07a      	add	sp, #488	; 0x1e8
   18d5a:	bd70      	pop	{r4, r5, r6, pc}
        hashData.ipv4HashData[0] = pSkt->srcAddress.Val;
   18d5c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   18d5e:	9301      	str	r3, [sp, #4]
        hashData.ipv4HashData[1] = pSkt->destAddress.Val;
   18d60:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   18d62:	9302      	str	r3, [sp, #8]
        hashData.ipv4HashData[2] = ((uint32_t)pSkt->localPort << 16) + (uint32_t)pSkt->remotePort;
   18d64:	f8b4 205a 	ldrh.w	r2, [r4, #90]	; 0x5a
   18d68:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
   18d6c:	eb03 4302 	add.w	r3, r3, r2, lsl #16
   18d70:	9303      	str	r3, [sp, #12]
        memcpy(hashData.ipv4HashData + 3, secretKey, sizeof(secretKey));
   18d72:	ab08      	add	r3, sp, #32
   18d74:	ac04      	add	r4, sp, #16
   18d76:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   18d78:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        dataSize = sizeof(hashData.ipv4HashData);
   18d7c:	221c      	movs	r2, #28
   18d7e:	e7ba      	b.n	18cf6 <_TCP_SktSetSequenceNo+0x1e>

Disassembly of section .text.TCPIP_TCP_ServerOpen%393:

00018d80 <TCPIP_TCP_ServerOpen>:
{
   18d80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   if(addType == IP_ADDRESS_TYPE_IPV6)
   18d82:	2802      	cmp	r0, #2
   18d84:	d038      	beq.n	18df8 <TCPIP_TCP_ServerOpen+0x78>
   18d86:	4614      	mov	r4, r2
   18d88:	460d      	mov	r5, r1
    if(addType == IP_ADDRESS_TYPE_IPV4 && localAddress != 0 && localAddress->v4Add.Val != 0)
   18d8a:	b10a      	cbz	r2, 18d90 <TCPIP_TCP_ServerOpen+0x10>
   18d8c:	6813      	ldr	r3, [r2, #0]
   18d8e:	b95b      	cbnz	r3, 18da8 <TCPIP_TCP_ServerOpen+0x28>
    skt = _TCP_Open(addType, TCP_OPEN_SERVER, localPort, 0);
   18d90:	2300      	movs	r3, #0
   18d92:	462a      	mov	r2, r5
   18d94:	4619      	mov	r1, r3
   18d96:	2001      	movs	r0, #1
   18d98:	f7f4 fe30 	bl	d9fc <_TCP_Open>
   18d9c:	4606      	mov	r6, r0
    if(skt != INVALID_SOCKET)
   18d9e:	f1b0 3fff 	cmp.w	r0, #4294967295
   18da2:	d12f      	bne.n	18e04 <TCPIP_TCP_ServerOpen+0x84>
}
   18da4:	4630      	mov	r0, r6
   18da6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        pDefIf = TCPIP_STACK_IPAddToNet(&localAddress->v4Add, false);
   18da8:	2100      	movs	r1, #0
   18daa:	4610      	mov	r0, r2
   18dac:	f009 fc48 	bl	22640 <TCPIP_STACK_IPAddToNet>
        if(pDefIf == 0)
   18db0:	4607      	mov	r7, r0
   18db2:	b320      	cbz	r0, 18dfe <TCPIP_TCP_ServerOpen+0x7e>
    skt = _TCP_Open(addType, TCP_OPEN_SERVER, localPort, 0);
   18db4:	2300      	movs	r3, #0
   18db6:	462a      	mov	r2, r5
   18db8:	4619      	mov	r1, r3
   18dba:	2001      	movs	r0, #1
   18dbc:	f7f4 fe1e 	bl	d9fc <_TCP_Open>
   18dc0:	4606      	mov	r6, r0
    if(skt != INVALID_SOCKET)
   18dc2:	f1b0 3fff 	cmp.w	r0, #4294967295
   18dc6:	d0ed      	beq.n	18da4 <TCPIP_TCP_ServerOpen+0x24>
        TCB_STUB* pSkt = TCBStubs[skt]; 
   18dc8:	4b16      	ldr	r3, [pc, #88]	; (18e24 <TCPIP_TCP_ServerOpen+0xa4>)
   18dca:	681b      	ldr	r3, [r3, #0]
   18dcc:	f853 5026 	ldr.w	r5, [r3, r6, lsl #2]
    pSkt->pSktNet = pNet;
   18dd0:	642f      	str	r7, [r5, #64]	; 0x40
    _TCPSetSourceAddress(pSkt, pSkt->addType, srcAddress);
   18dd2:	4622      	mov	r2, r4
   18dd4:	f895 106f 	ldrb.w	r1, [r5, #111]	; 0x6f
   18dd8:	4628      	mov	r0, r5
   18dda:	f007 fd9e 	bl	2091a <_TCPSetSourceAddress>
            pSkt->flags.openBindIf = 1;
   18dde:	f895 306d 	ldrb.w	r3, [r5, #109]	; 0x6d
   18de2:	f043 0320 	orr.w	r3, r3, #32
   18de6:	f885 306d 	strb.w	r3, [r5, #109]	; 0x6d
            pSkt->flags.openBindAdd = 1;
   18dea:	f895 306d 	ldrb.w	r3, [r5, #109]	; 0x6d
   18dee:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   18df2:	f885 306d 	strb.w	r3, [r5, #109]	; 0x6d
   18df6:	e7d5      	b.n	18da4 <TCPIP_TCP_ServerOpen+0x24>
       return INVALID_SOCKET;
   18df8:	f04f 36ff 	mov.w	r6, #4294967295
   18dfc:	e7d2      	b.n	18da4 <TCPIP_TCP_ServerOpen+0x24>
            return INVALID_SOCKET;
   18dfe:	f04f 36ff 	mov.w	r6, #4294967295
   18e02:	e7cf      	b.n	18da4 <TCPIP_TCP_ServerOpen+0x24>
        TCB_STUB* pSkt = TCBStubs[skt]; 
   18e04:	4b07      	ldr	r3, [pc, #28]	; (18e24 <TCPIP_TCP_ServerOpen+0xa4>)
   18e06:	681b      	ldr	r3, [r3, #0]
   18e08:	f853 5026 	ldr.w	r5, [r3, r6, lsl #2]
    pSkt->pSktNet = pNet;
   18e0c:	2300      	movs	r3, #0
   18e0e:	642b      	str	r3, [r5, #64]	; 0x40
    _TCPSetSourceAddress(pSkt, pSkt->addType, srcAddress);
   18e10:	4622      	mov	r2, r4
   18e12:	f895 106f 	ldrb.w	r1, [r5, #111]	; 0x6f
   18e16:	4628      	mov	r0, r5
   18e18:	f007 fd7f 	bl	2091a <_TCPSetSourceAddress>
        if(localAddress != 0)
   18e1c:	2c00      	cmp	r4, #0
   18e1e:	d0c1      	beq.n	18da4 <TCPIP_TCP_ServerOpen+0x24>
   18e20:	e7e3      	b.n	18dea <TCPIP_TCP_ServerOpen+0x6a>
   18e22:	bf00      	nop
   18e24:	2000edc0 	.word	0x2000edc0

Disassembly of section .text._DHCPS_Enable%394:

00018e28 <_DHCPS_Enable>:
{
   18e28:	b538      	push	{r3, r4, r5, lr}
    if(checkIfUp)
   18e2a:	460b      	mov	r3, r1
   18e2c:	b141      	cbz	r1, 18e40 <_DHCPS_Enable+0x18>
   18e2e:	2800      	cmp	r0, #0
   18e30:	d03d      	beq.n	18eae <_DHCPS_Enable+0x86>
   18e32:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   18e36:	f012 0f40 	tst.w	r2, #64	; 0x40
   18e3a:	d13e      	bne.n	18eba <_DHCPS_Enable+0x92>
        return false;
   18e3c:	2000      	movs	r0, #0
   18e3e:	e013      	b.n	18e68 <_DHCPS_Enable+0x40>
    pDhcpsDcpt = gPdhcpSDcpt;
   18e40:	4a1f      	ldr	r2, [pc, #124]	; (18ec0 <_DHCPS_Enable+0x98>)
   18e42:	6815      	ldr	r5, [r2, #0]
    if((pNetIf==0)||(pDhcpsDcpt==0))
   18e44:	b3a8      	cbz	r0, 18eb2 <_DHCPS_Enable+0x8a>
   18e46:	b3b5      	cbz	r5, 18eb6 <_DHCPS_Enable+0x8e>
   18e48:	4604      	mov	r4, r0
    if(dhcps_mod.poolCount == 0)
   18e4a:	4a1e      	ldr	r2, [pc, #120]	; (18ec4 <_DHCPS_Enable+0x9c>)
   18e4c:	6852      	ldr	r2, [r2, #4]
   18e4e:	b162      	cbz	r2, 18e6a <_DHCPS_Enable+0x42>
    if(checkIfUp)
   18e50:	b9c3      	cbnz	r3, 18e84 <_DHCPS_Enable+0x5c>
        if((pNetIf->Flags.v & TCPIP_STACK_ADDRESS_SERVICE_MASK) == TCPIP_NETWORK_CONFIG_DHCP_SERVER_ON)
   18e52:	f8b0 3042 	ldrh.w	r3, [r0, #66]	; 0x42
   18e56:	f003 0307 	and.w	r3, r3, #7
   18e5a:	2b04      	cmp	r3, #4
   18e5c:	d01c      	beq.n	18e98 <_DHCPS_Enable+0x70>
    SYS_ERROR(SYS_ERROR_WARNING, "DHCPS: Other Services are enabled for this interface \r\n");
   18e5e:	f00b fa0f 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
   18e62:	2801      	cmp	r0, #1
   18e64:	d81c      	bhi.n	18ea0 <_DHCPS_Enable+0x78>
    return false;
   18e66:	2000      	movs	r0, #0
}
   18e68:	bd38      	pop	{r3, r4, r5, pc}
        SYS_ERROR(SYS_ERROR_WARNING, "DHCPS: DHCP server needs atleast one address pool! \r\n");
   18e6a:	f00b fa09 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
   18e6e:	2801      	cmp	r0, #1
   18e70:	d801      	bhi.n	18e76 <_DHCPS_Enable+0x4e>
        return false;
   18e72:	2000      	movs	r0, #0
   18e74:	e7f8      	b.n	18e68 <_DHCPS_Enable+0x40>
        SYS_ERROR(SYS_ERROR_WARNING, "DHCPS: DHCP server needs atleast one address pool! \r\n");
   18e76:	f00b f9fd 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
   18e7a:	4913      	ldr	r1, [pc, #76]	; (18ec8 <_DHCPS_Enable+0xa0>)
   18e7c:	f003 fc0e 	bl	1c69c <SYS_CONSOLE_Print>
        return false;
   18e80:	2000      	movs	r0, #0
   18e82:	e7f1      	b.n	18e68 <_DHCPS_Enable+0x40>
        if(TCPIP_STACK_AddressServiceCanStart(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_DHCPS))
   18e84:	2103      	movs	r1, #3
   18e86:	f00a fd8e 	bl	239a6 <TCPIP_STACK_AddressServiceCanStart>
   18e8a:	2800      	cmp	r0, #0
   18e8c:	d0e7      	beq.n	18e5e <_DHCPS_Enable+0x36>
            return _DHCPS_StartOperation(pNetIf,pDhcpsDcpt);
   18e8e:	4629      	mov	r1, r5
   18e90:	4620      	mov	r0, r4
   18e92:	f7fb f9f5 	bl	14280 <_DHCPS_StartOperation>
   18e96:	e7e7      	b.n	18e68 <_DHCPS_Enable+0x40>
            return _DHCPS_StartOperation(pNetIf,pDhcpsDcpt);
   18e98:	4629      	mov	r1, r5
   18e9a:	f7fb f9f1 	bl	14280 <_DHCPS_StartOperation>
   18e9e:	e7e3      	b.n	18e68 <_DHCPS_Enable+0x40>
    SYS_ERROR(SYS_ERROR_WARNING, "DHCPS: Other Services are enabled for this interface \r\n");
   18ea0:	f00b f9e8 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
   18ea4:	4909      	ldr	r1, [pc, #36]	; (18ecc <_DHCPS_Enable+0xa4>)
   18ea6:	f003 fbf9 	bl	1c69c <SYS_CONSOLE_Print>
    return false;
   18eaa:	2000      	movs	r0, #0
   18eac:	e7dc      	b.n	18e68 <_DHCPS_Enable+0x40>
        return false;
   18eae:	2000      	movs	r0, #0
   18eb0:	e7da      	b.n	18e68 <_DHCPS_Enable+0x40>
   18eb2:	4608      	mov	r0, r1
   18eb4:	e7d8      	b.n	18e68 <_DHCPS_Enable+0x40>
   18eb6:	2000      	movs	r0, #0
   18eb8:	e7d6      	b.n	18e68 <_DHCPS_Enable+0x40>
    pDhcpsDcpt = gPdhcpSDcpt;
   18eba:	4a01      	ldr	r2, [pc, #4]	; (18ec0 <_DHCPS_Enable+0x98>)
   18ebc:	6815      	ldr	r5, [r2, #0]
    if((pNetIf==0)||(pDhcpsDcpt==0))
   18ebe:	e7c2      	b.n	18e46 <_DHCPS_Enable+0x1e>
   18ec0:	2000eec8 	.word	0x2000eec8
   18ec4:	2000ed3c 	.word	0x2000ed3c
   18ec8:	0000d18c 	.word	0x0000d18c
   18ecc:	0000d1c4 	.word	0x0000d1c4

Disassembly of section .text.SERCOM1_USART_Write%395:

00018ed0 <SERCOM1_USART_Write>:
{
   18ed0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    while (nBytesWritten < size)
   18ed4:	2900      	cmp	r1, #0
   18ed6:	d046      	beq.n	18f66 <SERCOM1_USART_Write+0x96>
   18ed8:	468c      	mov	ip, r1
    if (tempInIndex >= sercom1USARTObj.wrBufferSize)
   18eda:	4b24      	ldr	r3, [pc, #144]	; (18f6c <SERCOM1_USART_Write+0x9c>)
   18edc:	691f      	ldr	r7, [r3, #16]
   18ede:	2400      	movs	r4, #0
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   18ee0:	4923      	ldr	r1, [pc, #140]	; (18f70 <SERCOM1_USART_Write+0xa0>)
    uint32_t wrInIndex = sercom1USARTObj.wrInIndex;
   18ee2:	461a      	mov	r2, r3
            ((uint16_t*)&SERCOM1_USART_WriteBuffer)[wrInIndex] = wrByte;
   18ee4:	f8df e08c 	ldr.w	lr, [pc, #140]	; 18f74 <SERCOM1_USART_Write+0xa4>
   18ee8:	e00f      	b.n	18f0a <SERCOM1_USART_Write+0x3a>
            if (SERCOM1_USART_TxPushByte(pWrBuffer[nBytesWritten]) == true)
   18eea:	f810 8004 	ldrb.w	r8, [r0, r4]
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   18eee:	684e      	ldr	r6, [r1, #4]
   18ef0:	f006 0607 	and.w	r6, r6, #7
   18ef4:	2e01      	cmp	r6, #1
            SERCOM1_USART_WriteBuffer[wrInIndex] = (uint8_t)wrByte;
   18ef6:	bf14      	ite	ne
   18ef8:	f80e 8005 	strbne.w	r8, [lr, r5]
            if (SERCOM1_USART_TxPushByte(pWrBuffer[nBytesWritten]) == true)
   18efc:	f82e 8015 	strheq.w	r8, [lr, r5, lsl #1]
        sercom1USARTObj.wrInIndex = tempInIndex;
   18f00:	6093      	str	r3, [r2, #8]
                nBytesWritten++;
   18f02:	1c63      	adds	r3, r4, #1
   18f04:	3401      	adds	r4, #1
    while (nBytesWritten < size)
   18f06:	4563      	cmp	r3, ip
   18f08:	d22b      	bcs.n	18f62 <SERCOM1_USART_Write+0x92>
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   18f0a:	684b      	ldr	r3, [r1, #4]
   18f0c:	f003 0307 	and.w	r3, r3, #7
   18f10:	2b01      	cmp	r3, #1
   18f12:	d010      	beq.n	18f36 <SERCOM1_USART_Write+0x66>
    uint32_t wrInIndex = sercom1USARTObj.wrInIndex;
   18f14:	6895      	ldr	r5, [r2, #8]
    uint32_t wrOutIndex = sercom1USARTObj.wrOutIndex;
   18f16:	68d6      	ldr	r6, [r2, #12]
    tempInIndex = wrInIndex + 1U;
   18f18:	1c6b      	adds	r3, r5, #1
        tempInIndex = 0U;
   18f1a:	42bb      	cmp	r3, r7
   18f1c:	bf28      	it	cs
   18f1e:	2300      	movcs	r3, #0
    if (tempInIndex != wrOutIndex)
   18f20:	429e      	cmp	r6, r3
   18f22:	d1e2      	bne.n	18eea <SERCOM1_USART_Write+0x1a>
    if (SERCOM1_USART_WritePendingBytesGet() > 0U)
   18f24:	f00a fc56 	bl	237d4 <SERCOM1_USART_WritePendingBytesGet>
   18f28:	b110      	cbz	r0, 18f30 <SERCOM1_USART_Write+0x60>
        SERCOM1_USART_TX_INT_ENABLE();
   18f2a:	4b11      	ldr	r3, [pc, #68]	; (18f70 <SERCOM1_USART_Write+0xa0>)
   18f2c:	2201      	movs	r2, #1
   18f2e:	759a      	strb	r2, [r3, #22]
}
   18f30:	4620      	mov	r0, r4
   18f32:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    uint32_t wrInIndex = sercom1USARTObj.wrInIndex;
   18f36:	6895      	ldr	r5, [r2, #8]
    uint32_t wrOutIndex = sercom1USARTObj.wrOutIndex;
   18f38:	68d6      	ldr	r6, [r2, #12]
    tempInIndex = wrInIndex + 1U;
   18f3a:	1c6b      	adds	r3, r5, #1
        tempInIndex = 0U;
   18f3c:	42bb      	cmp	r3, r7
   18f3e:	bf28      	it	cs
   18f40:	2300      	movcs	r3, #0
    if (tempInIndex != wrOutIndex)
   18f42:	429e      	cmp	r6, r3
   18f44:	d0ee      	beq.n	18f24 <SERCOM1_USART_Write+0x54>
            if (SERCOM1_USART_TxPushByte(((uint16_t*)pWrBuffer)[nBytesWritten]) == true)
   18f46:	f830 8014 	ldrh.w	r8, [r0, r4, lsl #1]
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   18f4a:	684e      	ldr	r6, [r1, #4]
   18f4c:	f006 0607 	and.w	r6, r6, #7
   18f50:	2e01      	cmp	r6, #1
            SERCOM1_USART_WriteBuffer[wrInIndex] = (uint8_t)wrByte;
   18f52:	bf14      	ite	ne
   18f54:	f80e 8005 	strbne.w	r8, [lr, r5]
            ((uint16_t*)&SERCOM1_USART_WriteBuffer)[wrInIndex] = wrByte;
   18f58:	f82e 8015 	strheq.w	r8, [lr, r5, lsl #1]
        sercom1USARTObj.wrInIndex = tempInIndex;
   18f5c:	6093      	str	r3, [r2, #8]
                nBytesWritten++;
   18f5e:	1c63      	adds	r3, r4, #1
   18f60:	e7d0      	b.n	18f04 <SERCOM1_USART_Write+0x34>
   18f62:	461c      	mov	r4, r3
   18f64:	e7de      	b.n	18f24 <SERCOM1_USART_Write+0x54>
    size_t nBytesWritten  = 0U;
   18f66:	460c      	mov	r4, r1
   18f68:	e7dc      	b.n	18f24 <SERCOM1_USART_Write+0x54>
   18f6a:	bf00      	nop
   18f6c:	2000e9c0 	.word	0x2000e9c0
   18f70:	40003400 	.word	0x40003400
   18f74:	2000b004 	.word	0x2000b004

Disassembly of section .text.vTaskSwitchContext%396:

00018f78 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   18f78:	4b24      	ldr	r3, [pc, #144]	; (1900c <vTaskSwitchContext+0x94>)
   18f7a:	681b      	ldr	r3, [r3, #0]
   18f7c:	b11b      	cbz	r3, 18f86 <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
   18f7e:	4b24      	ldr	r3, [pc, #144]	; (19010 <vTaskSwitchContext+0x98>)
   18f80:	2201      	movs	r2, #1
   18f82:	601a      	str	r2, [r3, #0]
   18f84:	4770      	bx	lr
{
   18f86:	b510      	push	{r4, lr}
		xYieldPending = pdFALSE;
   18f88:	4b21      	ldr	r3, [pc, #132]	; (19010 <vTaskSwitchContext+0x98>)
   18f8a:	2200      	movs	r2, #0
   18f8c:	601a      	str	r2, [r3, #0]
		taskCHECK_FOR_STACK_OVERFLOW();
   18f8e:	4b21      	ldr	r3, [pc, #132]	; (19014 <vTaskSwitchContext+0x9c>)
   18f90:	681b      	ldr	r3, [r3, #0]
   18f92:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   18f94:	681a      	ldr	r2, [r3, #0]
   18f96:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
   18f9a:	d103      	bne.n	18fa4 <vTaskSwitchContext+0x2c>
   18f9c:	685a      	ldr	r2, [r3, #4]
   18f9e:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
   18fa2:	d023      	beq.n	18fec <vTaskSwitchContext+0x74>
   18fa4:	4b1b      	ldr	r3, [pc, #108]	; (19014 <vTaskSwitchContext+0x9c>)
   18fa6:	6818      	ldr	r0, [r3, #0]
   18fa8:	6819      	ldr	r1, [r3, #0]
   18faa:	3134      	adds	r1, #52	; 0x34
   18fac:	f00a fe82 	bl	23cb4 <vApplicationStackOverflowHook>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   18fb0:	4b19      	ldr	r3, [pc, #100]	; (19018 <vTaskSwitchContext+0xa0>)
   18fb2:	681b      	ldr	r3, [r3, #0]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
	{
	uint8_t ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
   18fb4:	fab3 f383 	clz	r3, r3
   18fb8:	b2db      	uxtb	r3, r3
   18fba:	f1c3 031f 	rsb	r3, r3, #31
   18fbe:	4a17      	ldr	r2, [pc, #92]	; (1901c <vTaskSwitchContext+0xa4>)
   18fc0:	0099      	lsls	r1, r3, #2
   18fc2:	18c8      	adds	r0, r1, r3
   18fc4:	eb02 0080 	add.w	r0, r2, r0, lsl #2
   18fc8:	6844      	ldr	r4, [r0, #4]
   18fca:	6864      	ldr	r4, [r4, #4]
   18fcc:	6044      	str	r4, [r0, #4]
   18fce:	4419      	add	r1, r3
   18fd0:	4602      	mov	r2, r0
   18fd2:	3208      	adds	r2, #8
   18fd4:	4294      	cmp	r4, r2
   18fd6:	d012      	beq.n	18ffe <vTaskSwitchContext+0x86>
   18fd8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   18fdc:	4a0f      	ldr	r2, [pc, #60]	; (1901c <vTaskSwitchContext+0xa4>)
   18fde:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   18fe2:	685b      	ldr	r3, [r3, #4]
   18fe4:	68da      	ldr	r2, [r3, #12]
   18fe6:	4b0b      	ldr	r3, [pc, #44]	; (19014 <vTaskSwitchContext+0x9c>)
   18fe8:	601a      	str	r2, [r3, #0]
}
   18fea:	bd10      	pop	{r4, pc}
		taskCHECK_FOR_STACK_OVERFLOW();
   18fec:	689a      	ldr	r2, [r3, #8]
   18fee:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
   18ff2:	d1d7      	bne.n	18fa4 <vTaskSwitchContext+0x2c>
   18ff4:	68db      	ldr	r3, [r3, #12]
   18ff6:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
   18ffa:	d1d3      	bne.n	18fa4 <vTaskSwitchContext+0x2c>
   18ffc:	e7d8      	b.n	18fb0 <vTaskSwitchContext+0x38>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   18ffe:	6860      	ldr	r0, [r4, #4]
   19000:	460a      	mov	r2, r1
   19002:	4906      	ldr	r1, [pc, #24]	; (1901c <vTaskSwitchContext+0xa4>)
   19004:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   19008:	6050      	str	r0, [r2, #4]
   1900a:	e7e5      	b.n	18fd8 <vTaskSwitchContext+0x60>
   1900c:	2000ef14 	.word	0x2000ef14
   19010:	2000ef38 	.word	0x2000ef38
   19014:	2000ef00 	.word	0x2000ef00
   19018:	2000ef1c 	.word	0x2000ef1c
   1901c:	2000e850 	.word	0x2000e850

Disassembly of section .text.xTaskPriorityInherit%397:

00019020 <xTaskPriorityInherit>:
	BaseType_t xReturn = pdFALSE;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
   19020:	2800      	cmp	r0, #0
   19022:	d049      	beq.n	190b8 <xTaskPriorityInherit+0x98>
	{
   19024:	b538      	push	{r3, r4, r5, lr}
   19026:	4604      	mov	r4, r0
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
   19028:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   1902a:	4924      	ldr	r1, [pc, #144]	; (190bc <xTaskPriorityInherit+0x9c>)
   1902c:	6809      	ldr	r1, [r1, #0]
   1902e:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
   19030:	428a      	cmp	r2, r1
   19032:	d238      	bcs.n	190a6 <xTaskPriorityInherit+0x86>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   19034:	6981      	ldr	r1, [r0, #24]
   19036:	2900      	cmp	r1, #0
   19038:	db05      	blt.n	19046 <xTaskPriorityInherit+0x26>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1903a:	4920      	ldr	r1, [pc, #128]	; (190bc <xTaskPriorityInherit+0x9c>)
   1903c:	6809      	ldr	r1, [r1, #0]
   1903e:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
   19040:	f1c1 0105 	rsb	r1, r1, #5
   19044:	6181      	str	r1, [r0, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
   19046:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   1904a:	491d      	ldr	r1, [pc, #116]	; (190c0 <xTaskPriorityInherit+0xa0>)
   1904c:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   19050:	6961      	ldr	r1, [r4, #20]
   19052:	4291      	cmp	r1, r2
   19054:	d005      	beq.n	19062 <xTaskPriorityInherit+0x42>
					prvAddTaskToReadyList( pxMutexHolderTCB );
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   19056:	4a19      	ldr	r2, [pc, #100]	; (190bc <xTaskPriorityInherit+0x9c>)
   19058:	6812      	ldr	r2, [r2, #0]
   1905a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
   1905c:	62e2      	str	r2, [r4, #44]	; 0x2c
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
   1905e:	2001      	movs	r0, #1
   19060:	e029      	b.n	190b6 <xTaskPriorityInherit+0x96>
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   19062:	1d25      	adds	r5, r4, #4
   19064:	4628      	mov	r0, r5
   19066:	f009 fb5d 	bl	22724 <uxListRemove>
   1906a:	b938      	cbnz	r0, 1907c <xTaskPriorityInherit+0x5c>
						portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
   1906c:	4915      	ldr	r1, [pc, #84]	; (190c4 <xTaskPriorityInherit+0xa4>)
   1906e:	680b      	ldr	r3, [r1, #0]
   19070:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   19072:	2201      	movs	r2, #1
   19074:	4082      	lsls	r2, r0
   19076:	ea23 0302 	bic.w	r3, r3, r2
   1907a:	600b      	str	r3, [r1, #0]
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   1907c:	4b0f      	ldr	r3, [pc, #60]	; (190bc <xTaskPriorityInherit+0x9c>)
   1907e:	681b      	ldr	r3, [r3, #0]
   19080:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
   19082:	62e0      	str	r0, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
   19084:	4a0f      	ldr	r2, [pc, #60]	; (190c4 <xTaskPriorityInherit+0xa4>)
   19086:	6811      	ldr	r1, [r2, #0]
   19088:	2401      	movs	r4, #1
   1908a:	fa04 f300 	lsl.w	r3, r4, r0
   1908e:	430b      	orrs	r3, r1
   19090:	6013      	str	r3, [r2, #0]
   19092:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   19096:	4629      	mov	r1, r5
   19098:	4b09      	ldr	r3, [pc, #36]	; (190c0 <xTaskPriorityInherit+0xa0>)
   1909a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1909e:	f00a fcb9 	bl	23a14 <vListInsertEnd>
				xReturn = pdTRUE;
   190a2:	4620      	mov	r0, r4
   190a4:	e007      	b.n	190b6 <xTaskPriorityInherit+0x96>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
   190a6:	4a05      	ldr	r2, [pc, #20]	; (190bc <xTaskPriorityInherit+0x9c>)
   190a8:	6812      	ldr	r2, [r2, #0]
   190aa:	6c40      	ldr	r0, [r0, #68]	; 0x44
   190ac:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   190ae:	4298      	cmp	r0, r3
   190b0:	bf2c      	ite	cs
   190b2:	2000      	movcs	r0, #0
   190b4:	2001      	movcc	r0, #1
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
   190b6:	bd38      	pop	{r3, r4, r5, pc}
	BaseType_t xReturn = pdFALSE;
   190b8:	2000      	movs	r0, #0
	}
   190ba:	4770      	bx	lr
   190bc:	2000ef00 	.word	0x2000ef00
   190c0:	2000e850 	.word	0x2000e850
   190c4:	2000ef1c 	.word	0x2000ef1c

Disassembly of section .text.__lshift%398:

000190c8 <__lshift>:
   190c8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   190cc:	460c      	mov	r4, r1
   190ce:	ea4f 1a62 	mov.w	sl, r2, asr #5
   190d2:	6923      	ldr	r3, [r4, #16]
   190d4:	6849      	ldr	r1, [r1, #4]
   190d6:	eb0a 0903 	add.w	r9, sl, r3
   190da:	68a3      	ldr	r3, [r4, #8]
   190dc:	4607      	mov	r7, r0
   190de:	4616      	mov	r6, r2
   190e0:	f109 0501 	add.w	r5, r9, #1
   190e4:	42ab      	cmp	r3, r5
   190e6:	db33      	blt.n	19150 <__lshift+0x88>
   190e8:	4638      	mov	r0, r7
   190ea:	f003 fd4f 	bl	1cb8c <_Balloc>
   190ee:	2300      	movs	r3, #0
   190f0:	4680      	mov	r8, r0
   190f2:	f100 0114 	add.w	r1, r0, #20
   190f6:	f100 0210 	add.w	r2, r0, #16
   190fa:	4618      	mov	r0, r3
   190fc:	4553      	cmp	r3, sl
   190fe:	db2a      	blt.n	19156 <__lshift+0x8e>
   19100:	6920      	ldr	r0, [r4, #16]
   19102:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
   19106:	f104 0314 	add.w	r3, r4, #20
   1910a:	f016 021f 	ands.w	r2, r6, #31
   1910e:	eb01 018a 	add.w	r1, r1, sl, lsl #2
   19112:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
   19116:	d022      	beq.n	1915e <__lshift+0x96>
   19118:	f1c2 0e20 	rsb	lr, r2, #32
   1911c:	2000      	movs	r0, #0
   1911e:	681e      	ldr	r6, [r3, #0]
   19120:	4096      	lsls	r6, r2
   19122:	4330      	orrs	r0, r6
   19124:	f841 0b04 	str.w	r0, [r1], #4
   19128:	f853 0b04 	ldr.w	r0, [r3], #4
   1912c:	459c      	cmp	ip, r3
   1912e:	fa20 f00e 	lsr.w	r0, r0, lr
   19132:	d8f4      	bhi.n	1911e <__lshift+0x56>
   19134:	6008      	str	r0, [r1, #0]
   19136:	b108      	cbz	r0, 1913c <__lshift+0x74>
   19138:	f109 0502 	add.w	r5, r9, #2
   1913c:	3d01      	subs	r5, #1
   1913e:	4638      	mov	r0, r7
   19140:	f8c8 5010 	str.w	r5, [r8, #16]
   19144:	4621      	mov	r1, r4
   19146:	f008 fbba 	bl	218be <_Bfree>
   1914a:	4640      	mov	r0, r8
   1914c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   19150:	3101      	adds	r1, #1
   19152:	005b      	lsls	r3, r3, #1
   19154:	e7c6      	b.n	190e4 <__lshift+0x1c>
   19156:	f842 0f04 	str.w	r0, [r2, #4]!
   1915a:	3301      	adds	r3, #1
   1915c:	e7ce      	b.n	190fc <__lshift+0x34>
   1915e:	3904      	subs	r1, #4
   19160:	f853 2b04 	ldr.w	r2, [r3], #4
   19164:	f841 2f04 	str.w	r2, [r1, #4]!
   19168:	459c      	cmp	ip, r3
   1916a:	d8f9      	bhi.n	19160 <__lshift+0x98>
   1916c:	e7e6      	b.n	1913c <__lshift+0x74>

Disassembly of section .text._DHCPProcessReceiveData%399:

00019170 <_DHCPProcessReceiveData>:
{
   19170:	b5f0      	push	{r4, r5, r6, r7, lr}
   19172:	b083      	sub	sp, #12
   19174:	4605      	mov	r5, r0
   19176:	460e      	mov	r6, r1
    if(TCPIP_UDP_GetIsReady(dhcpClientSocket) == 0)
   19178:	4b24      	ldr	r3, [pc, #144]	; (1920c <_DHCPProcessReceiveData+0x9c>)
   1917a:	f9b3 0000 	ldrsh.w	r0, [r3]
   1917e:	f009 f80d 	bl	2219c <TCPIP_UDP_GetIsReady>
   19182:	2800      	cmp	r0, #0
   19184:	d03d      	beq.n	19202 <_DHCPProcessReceiveData+0x92>
    recvRes = _DHCPReceive(pClient, pNetIf);
   19186:	4631      	mov	r1, r6
   19188:	4628      	mov	r0, r5
   1918a:	f7f7 fcc9 	bl	10b20 <_DHCPReceive>
   1918e:	4604      	mov	r4, r0
    switch(recvRes)
   19190:	2805      	cmp	r0, #5
   19192:	d00c      	beq.n	191ae <_DHCPProcessReceiveData+0x3e>
   19194:	2806      	cmp	r0, #6
   19196:	d135      	bne.n	19204 <_DHCPProcessReceiveData+0x94>
            dhcpEv = DHCP_EVENT_NACK;
   19198:	2706      	movs	r7, #6
        _DHCPSetRunFail(pClient, TCPIP_DHCP_SEND_DISCOVERY, false);
   1919a:	2200      	movs	r2, #0
   1919c:	2102      	movs	r1, #2
   1919e:	4628      	mov	r0, r5
   191a0:	f005 fb42 	bl	1e828 <_DHCPSetRunFail>
        _DHCPNotifyClients(pNetIf, dhcpEv);
   191a4:	4639      	mov	r1, r7
   191a6:	4630      	mov	r0, r6
   191a8:	f006 ff4c 	bl	20044 <_DHCPNotifyClients>
   191ac:	e02a      	b.n	19204 <_DHCPProcessReceiveData+0x94>
            if( pClient->smState == TCPIP_DHCP_GET_REQUEST_ACK)
   191ae:	f8b5 3056 	ldrh.w	r3, [r5, #86]	; 0x56
   191b2:	2b05      	cmp	r3, #5
   191b4:	d00a      	beq.n	191cc <_DHCPProcessReceiveData+0x5c>
            else if( pClient->smState == TCPIP_DHCP_GET_RENEW_ACK || pClient->smState == TCPIP_DHCP_GET_REBIND_ACK)
   191b6:	2b0a      	cmp	r3, #10
   191b8:	d001      	beq.n	191be <_DHCPProcessReceiveData+0x4e>
   191ba:	2b0c      	cmp	r3, #12
   191bc:	d122      	bne.n	19204 <_DHCPProcessReceiveData+0x94>
                pClient->tRequest = pClient->tRenewRequest;
   191be:	68eb      	ldr	r3, [r5, #12]
   191c0:	60ab      	str	r3, [r5, #8]
                _DHCPSetBoundState(pClient);
   191c2:	4628      	mov	r0, r5
   191c4:	f006 fbce 	bl	1f964 <_DHCPSetBoundState>
                dhcpEv = DHCP_EVENT_BOUND;
   191c8:	2708      	movs	r7, #8
   191ca:	e7eb      	b.n	191a4 <_DHCPProcessReceiveData+0x34>
                if(pClient->validValues.IPAddress == 0 || pClient->validValues.Mask == 0)
   191cc:	f895 3059 	ldrb.w	r3, [r5, #89]	; 0x59
   191d0:	f003 0305 	and.w	r3, r3, #5
   191d4:	2b05      	cmp	r3, #5
   191d6:	d001      	beq.n	191dc <_DHCPProcessReceiveData+0x6c>
                    dhcpEv = DHCP_EVENT_ACK_INVALID;
   191d8:	2704      	movs	r7, #4
   191da:	e7de      	b.n	1919a <_DHCPProcessReceiveData+0x2a>
                IPV4_ADDR zeroAdd = { 0 };
   191dc:	2300      	movs	r3, #0
   191de:	9301      	str	r3, [sp, #4]
                arpCheck.Val = pClient->dhcpIPAddress.Val;
   191e0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   191e2:	9300      	str	r3, [sp, #0]
                TCPIP_ARP_Probe(pNetIf, &arpCheck, &zeroAdd, ARP_OPERATION_REQ | ARP_OPERATION_CONFIGURE |  ARP_OPERATION_GRATUITOUS);
   191e4:	f243 0301 	movw	r3, #12289	; 0x3001
   191e8:	aa01      	add	r2, sp, #4
   191ea:	4669      	mov	r1, sp
   191ec:	4630      	mov	r0, r6
   191ee:	f004 f9c1 	bl	1d574 <TCPIP_ARP_Probe>
    return dhcpSecondCount;
   191f2:	4b07      	ldr	r3, [pc, #28]	; (19210 <_DHCPProcessReceiveData+0xa0>)
                pClient->startWait = _DHCPSecondCountGet();
   191f4:	681b      	ldr	r3, [r3, #0]
   191f6:	606b      	str	r3, [r5, #4]
    pClient->smState = newState;
   191f8:	2306      	movs	r3, #6
   191fa:	f8a5 3056 	strh.w	r3, [r5, #86]	; 0x56
                dhcpEv = DHCP_EVENT_ACK;
   191fe:	2703      	movs	r7, #3
   19200:	e7d0      	b.n	191a4 <_DHCPProcessReceiveData+0x34>
        return TCPIP_DHCP_TIMEOUT_MESSAGE;
   19202:	240a      	movs	r4, #10
}
   19204:	4620      	mov	r0, r4
   19206:	b003      	add	sp, #12
   19208:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1920a:	bf00      	nop
   1920c:	2000ef7e 	.word	0x2000ef7e
   19210:	2000ee4c 	.word	0x2000ee4c

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0%400:

00019214 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0>:
{
   19214:	b510      	push	{r4, lr}
   19216:	4604      	mov	r4, r0
    openFlags = hClientObj->hDriver->openFlags;
   19218:	68c1      	ldr	r1, [r0, #12]
   1921a:	898b      	ldrh	r3, [r1, #12]
    if(!(openFlags & (TCPIP_ETH_OPEN_FDUPLEX|TCPIP_ETH_OPEN_HDUPLEX)))
   1921c:	f013 0f06 	tst.w	r3, #6
        openFlags |= TCPIP_ETH_OPEN_HDUPLEX;
   19220:	bf08      	it	eq
   19222:	f043 0304 	orreq.w	r3, r3, #4
    if(!(openFlags & (TCPIP_ETH_OPEN_100|TCPIP_ETH_OPEN_10)))
   19226:	f013 0f18 	tst.w	r3, #24
        openFlags |= TCPIP_ETH_OPEN_10;
   1922a:	bf08      	it	eq
   1922c:	f043 0310 	orreq.w	r3, r3, #16
    if(openFlags & TCPIP_ETH_OPEN_AUTO)
   19230:	f013 0f01 	tst.w	r3, #1
   19234:	d01e      	beq.n	19274 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x60>
        if(openFlags & TCPIP_ETH_OPEN_100)
   19236:	f013 0f08 	tst.w	r3, #8
   1923a:	d00c      	beq.n	19256 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x42>
            if(openFlags & TCPIP_ETH_OPEN_FDUPLEX)
   1923c:	f003 0202 	and.w	r2, r3, #2
                openReqs |= _BMSTAT_BASE100TX_FDX_MASK;
   19240:	2a00      	cmp	r2, #0
   19242:	f244 0208 	movw	r2, #16392	; 0x4008
   19246:	bf08      	it	eq
   19248:	2208      	moveq	r2, #8
            if(openFlags & TCPIP_ETH_OPEN_HDUPLEX)
   1924a:	f013 0f04 	tst.w	r3, #4
   1924e:	d003      	beq.n	19258 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x44>
                openReqs |= _BMSTAT_BASE100TX_HDX_MASK;
   19250:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
   19254:	e000      	b.n	19258 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x44>
        openReqs = _BMSTAT_AN_ABLE_MASK;
   19256:	2208      	movs	r2, #8
        if(openFlags & TCPIP_ETH_OPEN_10)
   19258:	f013 0f10 	tst.w	r3, #16
   1925c:	d015      	beq.n	1928a <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x76>
            if(openFlags & TCPIP_ETH_OPEN_FDUPLEX)
   1925e:	f013 0f02 	tst.w	r3, #2
                openReqs |= _BMSTAT_BASE10T_FDX_MASK;
   19262:	bf18      	it	ne
   19264:	f442 5280 	orrne.w	r2, r2, #4096	; 0x1000
            if(openFlags & TCPIP_ETH_OPEN_HDUPLEX)
   19268:	f013 0f04 	tst.w	r3, #4
   1926c:	d00d      	beq.n	1928a <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x76>
                openReqs |= _BMSTAT_BASE10T_HDX_MASK;
   1926e:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
   19272:	e00a      	b.n	1928a <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x76>
        if(openFlags & TCPIP_ETH_OPEN_100)
   19274:	f013 0f08 	tst.w	r3, #8
   19278:	d00f      	beq.n	1929a <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x86>
            openReqs = (openFlags & TCPIP_ETH_OPEN_FDUPLEX) ? _BMSTAT_BASE100TX_FDX_MASK : _BMSTAT_BASE100TX_HDX_MASK;
   1927a:	f003 0202 	and.w	r2, r3, #2
   1927e:	2a00      	cmp	r2, #0
   19280:	bf14      	ite	ne
   19282:	f44f 4280 	movne.w	r2, #16384	; 0x4000
   19286:	f44f 5200 	moveq.w	r2, #8192	; 0x2000
    hClientObj->hDriver->openFlags = openFlags;
   1928a:	818b      	strh	r3, [r1, #12]
    hClientObj->operReg[0] = openReqs;
   1928c:	8462      	strh	r2, [r4, #34]	; 0x22
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   1928e:	2101      	movs	r1, #1
   19290:	4620      	mov	r0, r4
   19292:	f007 fe6d 	bl	20f70 <_DRV_PHY_SMIReadStart>
   19296:	b948      	cbnz	r0, 192ac <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x98>
}
   19298:	bd10      	pop	{r4, pc}
            openReqs = (openFlags & TCPIP_ETH_OPEN_FDUPLEX) ? _BMSTAT_BASE10T_FDX_MASK : _BMSTAT_BASE10T_HDX_MASK;
   1929a:	f003 0202 	and.w	r2, r3, #2
   1929e:	2a00      	cmp	r2, #0
   192a0:	bf14      	ite	ne
   192a2:	f44f 5280 	movne.w	r2, #4096	; 0x1000
   192a6:	f44f 6200 	moveq.w	r2, #2048	; 0x800
   192aa:	e7ee      	b.n	1928a <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x76>
    hClientObj->operPhase = operPhase;
   192ac:	2303      	movs	r3, #3
   192ae:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   192b0:	2301      	movs	r3, #1
   192b2:	8423      	strh	r3, [r4, #32]
}
   192b4:	e7f0      	b.n	19298 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x84>

Disassembly of section .text.TCPIP_Helper_IPv6AddressToString%401:

000192b6 <TCPIP_Helper_IPv6AddressToString>:
    if(v6Addr && buff && buffSize >= 41)
   192b6:	b3d8      	cbz	r0, 19330 <TCPIP_Helper_IPv6AddressToString+0x7a>
{
   192b8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   192bc:	460e      	mov	r6, r1
   192be:	4607      	mov	r7, r0
    if(v6Addr && buff && buffSize >= 41)
   192c0:	b3c1      	cbz	r1, 19334 <TCPIP_Helper_IPv6AddressToString+0x7e>
   192c2:	2a28      	cmp	r2, #40	; 0x28
   192c4:	d802      	bhi.n	192cc <TCPIP_Helper_IPv6AddressToString+0x16>
    return false;
   192c6:	2000      	movs	r0, #0
}
   192c8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   192cc:	1c45      	adds	r5, r0, #1
   192ce:	4682      	mov	sl, r0
   192d0:	f100 0b11 	add.w	fp, r0, #17
   192d4:	f100 090f 	add.w	r9, r0, #15
   192d8:	e017      	b.n	1930a <TCPIP_Helper_IPv6AddressToString+0x54>
                *str++ = k;
   192da:	f806 0b01 	strb.w	r0, [r6], #1
            k = btohexa_high(v6Addr->v[1 + (i<<1)]);
   192de:	eba5 080a 	sub.w	r8, r5, sl
   192e2:	7820      	ldrb	r0, [r4, #0]
   192e4:	f00a ff78 	bl	241d8 <btohexa_high>
                *str++ = k;
   192e8:	4634      	mov	r4, r6
   192ea:	f804 0b01 	strb.w	r0, [r4], #1
            k = btohexa_low(v6Addr->v[1 + (i<<1)]);
   192ee:	f817 0008 	ldrb.w	r0, [r7, r8]
   192f2:	f00a fe0c 	bl	23f0e <btohexa_low>
            *str++ = k;
   192f6:	7020      	strb	r0, [r4, #0]
            if (i != 7)
   192f8:	454d      	cmp	r5, r9
   192fa:	d014      	beq.n	19326 <TCPIP_Helper_IPv6AddressToString+0x70>
                *str++ = ':';
   192fc:	1ca6      	adds	r6, r4, #2
   192fe:	f04f 033a 	mov.w	r3, #58	; 0x3a
   19302:	7063      	strb	r3, [r4, #1]
   19304:	3502      	adds	r5, #2
        for (i = 0; i < 8; i++)
   19306:	455d      	cmp	r5, fp
   19308:	d00e      	beq.n	19328 <TCPIP_Helper_IPv6AddressToString+0x72>
            k = btohexa_high(v6Addr->v[(i<<1)]);
   1930a:	462c      	mov	r4, r5
   1930c:	f815 0c01 	ldrb.w	r0, [r5, #-1]
   19310:	f00a ff62 	bl	241d8 <btohexa_high>
            if (k != '0')
   19314:	2830      	cmp	r0, #48	; 0x30
   19316:	d00f      	beq.n	19338 <TCPIP_Helper_IPv6AddressToString+0x82>
                *str++ = k;
   19318:	f806 0b01 	strb.w	r0, [r6], #1
            k = btohexa_low(v6Addr->v[(i<<1)]);
   1931c:	f815 0c01 	ldrb.w	r0, [r5, #-1]
   19320:	f00a fdf5 	bl	23f0e <btohexa_low>
            if (k != '0' || j == true)
   19324:	e7d9      	b.n	192da <TCPIP_Helper_IPv6AddressToString+0x24>
            *str++ = k;
   19326:	1c66      	adds	r6, r4, #1
        *str = 0;
   19328:	2300      	movs	r3, #0
   1932a:	7033      	strb	r3, [r6, #0]
        return true;
   1932c:	2001      	movs	r0, #1
   1932e:	e7cb      	b.n	192c8 <TCPIP_Helper_IPv6AddressToString+0x12>
    return false;
   19330:	2000      	movs	r0, #0
}
   19332:	4770      	bx	lr
    return false;
   19334:	2000      	movs	r0, #0
   19336:	e7c7      	b.n	192c8 <TCPIP_Helper_IPv6AddressToString+0x12>
            k = btohexa_low(v6Addr->v[(i<<1)]);
   19338:	f815 0c01 	ldrb.w	r0, [r5, #-1]
   1933c:	f00a fde7 	bl	23f0e <btohexa_low>
            if (k != '0' || j == true)
   19340:	2830      	cmp	r0, #48	; 0x30
   19342:	d1ca      	bne.n	192da <TCPIP_Helper_IPv6AddressToString+0x24>
            k = btohexa_high(v6Addr->v[1 + (i<<1)]);
   19344:	eba5 080a 	sub.w	r8, r5, sl
   19348:	7820      	ldrb	r0, [r4, #0]
   1934a:	f00a ff45 	bl	241d8 <btohexa_high>
            if (k != '0' || j == true)
   1934e:	2830      	cmp	r0, #48	; 0x30
   19350:	bf08      	it	eq
   19352:	4634      	moveq	r4, r6
   19354:	d0cb      	beq.n	192ee <TCPIP_Helper_IPv6AddressToString+0x38>
   19356:	e7c7      	b.n	192e8 <TCPIP_Helper_IPv6AddressToString+0x32>

Disassembly of section .text.wc_RNG_HealthTest_ex%402:

00019358 <wc_RNG_HealthTest_ex>:
{
   19358:	b570      	push	{r4, r5, r6, lr}
   1935a:	b0a6      	sub	sp, #152	; 0x98
   1935c:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
    if (seedA == NULL || output == NULL) {
   1935e:	2b00      	cmp	r3, #0
   19360:	d03f      	beq.n	193e2 <wc_RNG_HealthTest_ex+0x8a>
   19362:	461e      	mov	r6, r3
   19364:	2d00      	cmp	r5, #0
   19366:	d03f      	beq.n	193e8 <wc_RNG_HealthTest_ex+0x90>
    if (reseed != 0 && seedB == NULL) {
   19368:	b110      	cbz	r0, 19370 <wc_RNG_HealthTest_ex+0x18>
   1936a:	9b2b      	ldr	r3, [sp, #172]	; 0xac
   1936c:	2b00      	cmp	r3, #0
   1936e:	d03e      	beq.n	193ee <wc_RNG_HealthTest_ex+0x96>
    if (outputSz != RNG_HEALTH_TEST_CHECK_SIZE) {
   19370:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
   19372:	2b80      	cmp	r3, #128	; 0x80
   19374:	d13e      	bne.n	193f4 <wc_RNG_HealthTest_ex+0x9c>
   19376:	460b      	mov	r3, r1
   19378:	4604      	mov	r4, r0
    if (Hash_DRBG_Instantiate(drbg, seedA, seedASz, nonce, nonceSz,
   1937a:	9930      	ldr	r1, [sp, #192]	; 0xc0
   1937c:	9102      	str	r1, [sp, #8]
   1937e:	992f      	ldr	r1, [sp, #188]	; 0xbc
   19380:	9101      	str	r1, [sp, #4]
   19382:	9200      	str	r2, [sp, #0]
   19384:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
   19386:	4631      	mov	r1, r6
   19388:	a805      	add	r0, sp, #20
   1938a:	f002 fe84 	bl	1c096 <Hash_DRBG_Instantiate>
   1938e:	b9c8      	cbnz	r0, 193c4 <wc_RNG_HealthTest_ex+0x6c>
    if (reseed) {
   19390:	b12c      	cbz	r4, 1939e <wc_RNG_HealthTest_ex+0x46>
        if (Hash_DRBG_Reseed(drbg, seedB, seedBSz) != 0) {
   19392:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
   19394:	992b      	ldr	r1, [sp, #172]	; 0xac
   19396:	a805      	add	r0, sp, #20
   19398:	f7ff fbf4 	bl	18b84 <Hash_DRBG_Reseed>
   1939c:	b9f0      	cbnz	r0, 193dc <wc_RNG_HealthTest_ex+0x84>
    if (Hash_DRBG_Generate(drbg, output, outputSz) != 0) {
   1939e:	2280      	movs	r2, #128	; 0x80
   193a0:	4629      	mov	r1, r5
   193a2:	a805      	add	r0, sp, #20
   193a4:	f7f4 f85a 	bl	d45c <Hash_DRBG_Generate>
   193a8:	b110      	cbz	r0, 193b0 <wc_RNG_HealthTest_ex+0x58>
    int ret = -1;
   193aa:	f04f 34ff 	mov.w	r4, #4294967295
   193ae:	e00b      	b.n	193c8 <wc_RNG_HealthTest_ex+0x70>
    if (Hash_DRBG_Generate(drbg, output, outputSz) != 0) {
   193b0:	2280      	movs	r2, #128	; 0x80
   193b2:	4629      	mov	r1, r5
   193b4:	a805      	add	r0, sp, #20
   193b6:	f7f4 f851 	bl	d45c <Hash_DRBG_Generate>
   193ba:	3000      	adds	r0, #0
   193bc:	bf18      	it	ne
   193be:	2001      	movne	r0, #1
   193c0:	4244      	negs	r4, r0
   193c2:	e001      	b.n	193c8 <wc_RNG_HealthTest_ex+0x70>
    int ret = -1;
   193c4:	f04f 34ff 	mov.w	r4, #4294967295
    if (Hash_DRBG_Uninstantiate(drbg) != 0) {
   193c8:	a805      	add	r0, sp, #20
   193ca:	f007 fd83 	bl	20ed4 <Hash_DRBG_Uninstantiate>
   193ce:	2800      	cmp	r0, #0
        ret = -1;
   193d0:	bf18      	it	ne
   193d2:	f04f 34ff 	movne.w	r4, #4294967295
}
   193d6:	4620      	mov	r0, r4
   193d8:	b026      	add	sp, #152	; 0x98
   193da:	bd70      	pop	{r4, r5, r6, pc}
    int ret = -1;
   193dc:	f04f 34ff 	mov.w	r4, #4294967295
   193e0:	e7f2      	b.n	193c8 <wc_RNG_HealthTest_ex+0x70>
        return BAD_FUNC_ARG;
   193e2:	f06f 04ac 	mvn.w	r4, #172	; 0xac
   193e6:	e7f6      	b.n	193d6 <wc_RNG_HealthTest_ex+0x7e>
   193e8:	f06f 04ac 	mvn.w	r4, #172	; 0xac
   193ec:	e7f3      	b.n	193d6 <wc_RNG_HealthTest_ex+0x7e>
        return BAD_FUNC_ARG;
   193ee:	f06f 04ac 	mvn.w	r4, #172	; 0xac
   193f2:	e7f0      	b.n	193d6 <wc_RNG_HealthTest_ex+0x7e>
        return ret;
   193f4:	f04f 34ff 	mov.w	r4, #4294967295
   193f8:	e7ed      	b.n	193d6 <wc_RNG_HealthTest_ex+0x7e>

Disassembly of section .text._ARPDeleteResources%403:

000193fc <_ARPDeleteResources>:
{
   193fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(arpMod.arpCacheDcpt)
   193fe:	4b26      	ldr	r3, [pc, #152]	; (19498 <_ARPDeleteResources+0x9c>)
   19400:	685c      	ldr	r4, [r3, #4]
   19402:	b364      	cbz	r4, 1945e <_ARPDeleteResources+0x62>
        for(ix = 0, pArpDcpt = arpMod.arpCacheDcpt; ix < arpMod.nIfs; ix++, pArpDcpt++)
   19404:	681b      	ldr	r3, [r3, #0]
   19406:	2b00      	cmp	r3, #0
   19408:	dd22      	ble.n	19450 <_ARPDeleteResources+0x54>
   1940a:	342c      	adds	r4, #44	; 0x2c
   1940c:	2500      	movs	r5, #0
        TCPIP_HEAP_Free(arpMod.memH, pArpDcpt->hashDcpt);
   1940e:	4e22      	ldr	r6, [pc, #136]	; (19498 <_ARPDeleteResources+0x9c>)
        pArpDcpt->hashDcpt = 0;
   19410:	462f      	mov	r7, r5
   19412:	e018      	b.n	19446 <_ARPDeleteResources+0x4a>
        TCPIP_OAHASH_EntriesRemoveAll(pArpDcpt->hashDcpt);
   19414:	f007 ff32 	bl	2127c <TCPIP_OAHASH_EntriesRemoveAll>
        TCPIP_Helper_ProtectedSingleListDeinitialize(&pArpDcpt->incompleteList);
   19418:	4620      	mov	r0, r4
   1941a:	f007 ff5f 	bl	212dc <TCPIP_Helper_ProtectedSingleListDeinitialize>
        TCPIP_Helper_ProtectedSingleListDeinitialize(&pArpDcpt->completeList);
   1941e:	f1a4 0014 	sub.w	r0, r4, #20
   19422:	f007 ff5b 	bl	212dc <TCPIP_Helper_ProtectedSingleListDeinitialize>
        TCPIP_Helper_ProtectedSingleListDeinitialize(&pArpDcpt->permList);
   19426:	f1a4 0028 	sub.w	r0, r4, #40	; 0x28
   1942a:	f007 ff57 	bl	212dc <TCPIP_Helper_ProtectedSingleListDeinitialize>
        TCPIP_HEAP_Free(arpMod.memH, pArpDcpt->hashDcpt);
   1942e:	68b0      	ldr	r0, [r6, #8]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   19430:	68c3      	ldr	r3, [r0, #12]
   19432:	f854 1c2c 	ldr.w	r1, [r4, #-44]
   19436:	4798      	blx	r3
        pArpDcpt->hashDcpt = 0;
   19438:	f844 7c2c 	str.w	r7, [r4, #-44]
        for(ix = 0, pArpDcpt = arpMod.arpCacheDcpt; ix < arpMod.nIfs; ix++, pArpDcpt++)
   1943c:	3501      	adds	r5, #1
   1943e:	3448      	adds	r4, #72	; 0x48
   19440:	6833      	ldr	r3, [r6, #0]
   19442:	42ab      	cmp	r3, r5
   19444:	dd04      	ble.n	19450 <_ARPDeleteResources+0x54>
    if(pArpDcpt->hashDcpt)
   19446:	f854 0c2c 	ldr.w	r0, [r4, #-44]
   1944a:	2800      	cmp	r0, #0
   1944c:	d1e2      	bne.n	19414 <_ARPDeleteResources+0x18>
   1944e:	e7f5      	b.n	1943c <_ARPDeleteResources+0x40>
        TCPIP_HEAP_Free(arpMod.memH, arpMod.arpCacheDcpt);
   19450:	4c11      	ldr	r4, [pc, #68]	; (19498 <_ARPDeleteResources+0x9c>)
   19452:	68a0      	ldr	r0, [r4, #8]
   19454:	68c3      	ldr	r3, [r0, #12]
   19456:	6861      	ldr	r1, [r4, #4]
   19458:	4798      	blx	r3
        arpMod.arpCacheDcpt = 0;
   1945a:	2300      	movs	r3, #0
   1945c:	6063      	str	r3, [r4, #4]
    TCPIP_Notification_Deinitialize(&arpMod.registeredUsers, arpMod.memH);
   1945e:	4c0e      	ldr	r4, [pc, #56]	; (19498 <_ARPDeleteResources+0x9c>)
   19460:	68a1      	ldr	r1, [r4, #8]
   19462:	f104 0020 	add.w	r0, r4, #32
   19466:	f00a fc93 	bl	23d90 <TCPIP_Notification_Deinitialize>
    arpMod.memH = 0;
   1946a:	2300      	movs	r3, #0
   1946c:	60a3      	str	r3, [r4, #8]
    if(arpMod.timerHandle)
   1946e:	69e0      	ldr	r0, [r4, #28]
   19470:	b118      	cbz	r0, 1947a <_ARPDeleteResources+0x7e>
        _TCPIPStackSignalHandlerDeregister(arpMod.timerHandle);
   19472:	f00a fd68 	bl	23f46 <_TCPIPStackSignalHandlerDeregister>
        arpMod.timerHandle = 0;
   19476:	2200      	movs	r2, #0
   19478:	61e2      	str	r2, [r4, #28]
    if(arpMod.pMacPkt)
   1947a:	4b07      	ldr	r3, [pc, #28]	; (19498 <_ARPDeleteResources+0x9c>)
   1947c:	6c98      	ldr	r0, [r3, #72]	; 0x48
   1947e:	b130      	cbz	r0, 1948e <_ARPDeleteResources+0x92>
        if((arpMod.pMacPkt->pktFlags & TCPIP_MAC_PKT_FLAG_QUEUED) == 0 )
   19480:	8c43      	ldrh	r3, [r0, #34]	; 0x22
   19482:	f013 0f08 	tst.w	r3, #8
   19486:	d003      	beq.n	19490 <_ARPDeleteResources+0x94>
        arpMod.pMacPkt = 0;
   19488:	4b03      	ldr	r3, [pc, #12]	; (19498 <_ARPDeleteResources+0x9c>)
   1948a:	2200      	movs	r2, #0
   1948c:	649a      	str	r2, [r3, #72]	; 0x48
}
   1948e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            TCPIP_PKT_PacketFree(arpMod.pMacPkt);
   19490:	f006 fe6e 	bl	20170 <_TCPIP_PKT_PacketFree>
   19494:	e7f8      	b.n	19488 <_ARPDeleteResources+0x8c>
   19496:	bf00      	nop
   19498:	2000e974 	.word	0x2000e974

Disassembly of section .text._UDPv4AllocateSktTxBuffer%404:

0001949c <_UDPv4AllocateSktTxBuffer>:
    if(addType != IP_ADDRESS_TYPE_IPV4)
   1949c:	2901      	cmp	r1, #1
   1949e:	d145      	bne.n	1952c <_UDPv4AllocateSktTxBuffer+0x90>
    if(pSkt->txAllocCnt >= pSkt->txAllocLimit)
   194a0:	f890 103f 	ldrb.w	r1, [r0, #63]	; 0x3f
   194a4:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
   194a8:	4299      	cmp	r1, r3
   194aa:	d242      	bcs.n	19532 <_UDPv4AllocateSktTxBuffer+0x96>
{
   194ac:	b570      	push	{r4, r5, r6, lr}
    if(pSkt->flags.stackConfig != 0)
   194ae:	f890 1041 	ldrb.w	r1, [r0, #65]	; 0x41
   194b2:	f001 0308 	and.w	r3, r1, #8
        allocFlags |= TCPIP_MAC_PKT_FLAG_CONFIG;
   194b6:	2b00      	cmp	r3, #0
   194b8:	bf0c      	ite	eq
   194ba:	2300      	moveq	r3, #0
   194bc:	f44f 4300 	movne.w	r3, #32768	; 0x8000
    if(pSkt->flags.txSplitAlloc == 0)
   194c0:	f011 0f02 	tst.w	r1, #2
        allocFlags |= TCPIP_MAC_PKT_FLAG_SPLIT;
   194c4:	bf1a      	itte	ne
   194c6:	f043 0304 	orrne.w	r3, r3, #4
        pktSize = sizeof(UDP_V4_PACKET) + sizeof(*((UDP_V4_PACKET*)0)->zcSeg);
   194ca:	265c      	movne	r6, #92	; 0x5c
        pktSize = sizeof(UDP_V4_PACKET);
   194cc:	2644      	moveq	r6, #68	; 0x44
   194ce:	4615      	mov	r5, r2
   194d0:	4604      	mov	r4, r0
    return TCPIP_PKT_SocketAlloc(pktSize, sizeof(UDP_HEADER), txBuffSize, allocFlags);
   194d2:	f043 0302 	orr.w	r3, r3, #2
   194d6:	8a02      	ldrh	r2, [r0, #16]
   194d8:	2108      	movs	r1, #8
   194da:	4630      	mov	r0, r6
   194dc:	f008 fab6 	bl	21a4c <_TCPIP_PKT_SocketAlloc>
    if(pPkt)
   194e0:	4603      	mov	r3, r0
   194e2:	b1a8      	cbz	r0, 19510 <_UDPv4AllocateSktTxBuffer+0x74>
    pPkt->ackFunc = ackFunc;
   194e4:	4a14      	ldr	r2, [pc, #80]	; (19538 <_UDPv4AllocateSktTxBuffer+0x9c>)
   194e6:	6082      	str	r2, [r0, #8]
    pPkt->ackParam = ackParam;
   194e8:	60c4      	str	r4, [r0, #12]
        if(pSkt->flags.txSplitAlloc)
   194ea:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
   194ee:	f012 0f02 	tst.w	r2, #2
   194f2:	d00f      	beq.n	19514 <_UDPv4AllocateSktTxBuffer+0x78>
            pPkt->pDSeg->next = pZSeg;
   194f4:	6902      	ldr	r2, [r0, #16]
            TCPIP_MAC_DATA_SEGMENT* pZSeg = ((UDP_V4_PACKET*)pPkt)->zcSeg;
   194f6:	f100 0144 	add.w	r1, r0, #68	; 0x44
            pPkt->pDSeg->next = pZSeg;
   194fa:	6011      	str	r1, [r2, #0]
            pZSeg->segFlags = TCPIP_MAC_SEG_FLAG_STATIC;   // embedded in packet itself
   194fc:	2201      	movs	r2, #1
   194fe:	f8a0 2054 	strh.w	r2, [r0, #84]	; 0x54
            pTxBuff = 0;    // will be set as external payload
   19502:	2200      	movs	r2, #0
        if(update)
   19504:	b94d      	cbnz	r5, 1951a <_UDPv4AllocateSktTxBuffer+0x7e>
        pSkt->txAllocCnt++;
   19506:	f894 203f 	ldrb.w	r2, [r4, #63]	; 0x3f
   1950a:	3201      	adds	r2, #1
   1950c:	f884 203f 	strb.w	r2, [r4, #63]	; 0x3f
}
   19510:	4618      	mov	r0, r3
   19512:	bd70      	pop	{r4, r5, r6, pc}
            pTxBuff = pPkt->pTransportLayer + sizeof(UDP_HEADER);
   19514:	69c2      	ldr	r2, [r0, #28]
   19516:	3208      	adds	r2, #8
   19518:	e7f4      	b.n	19504 <_UDPv4AllocateSktTxBuffer+0x68>
    pSkt->txStart = txBuff;
   1951a:	6022      	str	r2, [r4, #0]
    pSkt->txEnd = txBuff + pSkt->txSize;
   1951c:	8a21      	ldrh	r1, [r4, #16]
   1951e:	4411      	add	r1, r2
   19520:	6061      	str	r1, [r4, #4]
    pSkt->txWrite = txBuff;
   19522:	60a2      	str	r2, [r4, #8]
    pSkt->addType =  addType;
   19524:	2201      	movs	r2, #1
   19526:	87a2      	strh	r2, [r4, #60]	; 0x3c
    pSkt->pPkt = pTxPkt;
   19528:	60e3      	str	r3, [r4, #12]
   1952a:	e7ec      	b.n	19506 <_UDPv4AllocateSktTxBuffer+0x6a>
        return 0;
   1952c:	2300      	movs	r3, #0
}
   1952e:	4618      	mov	r0, r3
   19530:	4770      	bx	lr
        return 0;
   19532:	2300      	movs	r3, #0
   19534:	e7fb      	b.n	1952e <_UDPv4AllocateSktTxBuffer+0x92>
   19536:	bf00      	nop
   19538:	00014cad 	.word	0x00014cad

Disassembly of section .text.TCPIP_UDP_Disconnect%405:

0001953c <TCPIP_UDP_Disconnect>:
{
   1953c:	b538      	push	{r3, r4, r5, lr}
   1953e:	460d      	mov	r5, r1
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   19540:	f008 fe04 	bl	2214c <_UDPSocketDcpt>
    if(pSkt)
   19544:	2800      	cmp	r0, #0
   19546:	d044      	beq.n	195d2 <TCPIP_UDP_Disconnect+0x96>
   19548:	4604      	mov	r4, r0
        if(pSkt->flags.openAddType == IP_ADDRESS_TYPE_ANY)
   1954a:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
   1954e:	f013 0f30 	tst.w	r3, #48	; 0x30
   19552:	d036      	beq.n	195c2 <TCPIP_UDP_Disconnect+0x86>
    pSkt->extFlags.rxEnable = 0;
   19554:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   19558:	f36f 0341 	bfc	r3, #1, #1
   1955c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        pSkt->addType = (IP_ADDRESS_TYPE)pSkt->flags.openAddType;
   19560:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
   19564:	f3c3 1201 	ubfx	r2, r3, #4, #2
   19568:	87a2      	strh	r2, [r4, #60]	; 0x3c
        if(pSkt->flags.openBindIf == 0)
   1956a:	f013 0f40 	tst.w	r3, #64	; 0x40
            pSkt->pSktNet = 0;
   1956e:	bf04      	itt	eq
   19570:	2200      	moveq	r2, #0
   19572:	6262      	streq	r2, [r4, #36]	; 0x24
        if(pSkt->flags.openBindAdd == 0)
   19574:	f013 0f80 	tst.w	r3, #128	; 0x80
   19578:	d109      	bne.n	1958e <TCPIP_UDP_Disconnect+0x52>
            pSkt->srcAddress.Val = 0;
   1957a:	2200      	movs	r2, #0
   1957c:	61a2      	str	r2, [r4, #24]
            pSkt->flags.srcValid = pSkt->flags.srcSolved = 0;
   1957e:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
   19582:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   19586:	f362 1386 	bfi	r3, r2, #6, #1
   1958a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        if(pSkt->extFlags.serverSkt != 0 && pSkt->flags.looseRemPort != 0)
   1958e:	6c22      	ldr	r2, [r4, #64]	; 0x40
   19590:	4b11      	ldr	r3, [pc, #68]	; (195d8 <TCPIP_UDP_Disconnect+0x9c>)
   19592:	4393      	bics	r3, r2
            pSkt->remotePort = 0;
   19594:	bf04      	itt	eq
   19596:	2300      	moveq	r3, #0
   19598:	8523      	strheq	r3, [r4, #40]	; 0x28
        if(flushRxQueue)
   1959a:	b1ad      	cbz	r5, 195c8 <TCPIP_UDP_Disconnect+0x8c>
            _UDPFreeRxQueue(pSkt);
   1959c:	4620      	mov	r0, r4
   1959e:	f009 f861 	bl	22664 <_UDPFreeRxQueue>
    TCPIP_MAC_PACKET* pNextPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(&pSkt->rxQueue);
   195a2:	f104 0044 	add.w	r0, r4, #68	; 0x44
   195a6:	f009 fd5f 	bl	23068 <TCPIP_Helper_SingleListHeadRemove>
    _UDPSetNewRxPacket(pSkt, pNextPkt);
   195aa:	4601      	mov	r1, r0
   195ac:	4620      	mov	r0, r4
   195ae:	f006 f8b7 	bl	1f720 <_UDPSetNewRxPacket>
    pSkt->extFlags.rxEnable = 1;
   195b2:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   195b6:	f043 0302 	orr.w	r3, r3, #2
   195ba:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        return true;
   195be:	2001      	movs	r0, #1
}
   195c0:	bd38      	pop	{r3, r4, r5, pc}
            _UDPFreeTxResources(pSkt);
   195c2:	f008 fa59 	bl	21a78 <_UDPFreeTxResources>
   195c6:	e7c5      	b.n	19554 <TCPIP_UDP_Disconnect+0x18>
            _UDPsetPacketInfo(pSkt, pSkt->pCurrRxPkt);
   195c8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   195ca:	4620      	mov	r0, r4
   195cc:	f000 fff2 	bl	1a5b4 <_UDPsetPacketInfo>
   195d0:	e7ef      	b.n	195b2 <TCPIP_UDP_Disconnect+0x76>
    return false;
   195d2:	2000      	movs	r0, #0
   195d4:	e7f4      	b.n	195c0 <TCPIP_UDP_Disconnect+0x84>
   195d6:	bf00      	nop
   195d8:	00800004 	.word	0x00800004

Disassembly of section .text%406:

000195e0 <memchr>:
   195e0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   195e4:	2a10      	cmp	r2, #16
   195e6:	db2b      	blt.n	19640 <memchr+0x60>
   195e8:	f010 0f07 	tst.w	r0, #7
   195ec:	d008      	beq.n	19600 <memchr+0x20>
   195ee:	f810 3b01 	ldrb.w	r3, [r0], #1
   195f2:	3a01      	subs	r2, #1
   195f4:	428b      	cmp	r3, r1
   195f6:	d02d      	beq.n	19654 <memchr+0x74>
   195f8:	f010 0f07 	tst.w	r0, #7
   195fc:	b342      	cbz	r2, 19650 <memchr+0x70>
   195fe:	d1f6      	bne.n	195ee <memchr+0xe>
   19600:	b4f0      	push	{r4, r5, r6, r7}
   19602:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
   19606:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
   1960a:	f022 0407 	bic.w	r4, r2, #7
   1960e:	f07f 0700 	mvns.w	r7, #0
   19612:	2300      	movs	r3, #0
   19614:	e8f0 5602 	ldrd	r5, r6, [r0], #8
   19618:	3c08      	subs	r4, #8
   1961a:	ea85 0501 	eor.w	r5, r5, r1
   1961e:	ea86 0601 	eor.w	r6, r6, r1
   19622:	fa85 f547 	uadd8	r5, r5, r7
   19626:	faa3 f587 	sel	r5, r3, r7
   1962a:	fa86 f647 	uadd8	r6, r6, r7
   1962e:	faa5 f687 	sel	r6, r5, r7
   19632:	b98e      	cbnz	r6, 19658 <memchr+0x78>
   19634:	d1ee      	bne.n	19614 <memchr+0x34>
   19636:	bcf0      	pop	{r4, r5, r6, r7}
   19638:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   1963c:	f002 0207 	and.w	r2, r2, #7
   19640:	b132      	cbz	r2, 19650 <memchr+0x70>
   19642:	f810 3b01 	ldrb.w	r3, [r0], #1
   19646:	3a01      	subs	r2, #1
   19648:	ea83 0301 	eor.w	r3, r3, r1
   1964c:	b113      	cbz	r3, 19654 <memchr+0x74>
   1964e:	d1f8      	bne.n	19642 <memchr+0x62>
   19650:	2000      	movs	r0, #0
   19652:	4770      	bx	lr
   19654:	3801      	subs	r0, #1
   19656:	4770      	bx	lr
   19658:	2d00      	cmp	r5, #0
   1965a:	bf06      	itte	eq
   1965c:	4635      	moveq	r5, r6
   1965e:	3803      	subeq	r0, #3
   19660:	3807      	subne	r0, #7
   19662:	f015 0f01 	tst.w	r5, #1
   19666:	d107      	bne.n	19678 <memchr+0x98>
   19668:	3001      	adds	r0, #1
   1966a:	f415 7f80 	tst.w	r5, #256	; 0x100
   1966e:	bf02      	ittt	eq
   19670:	3001      	addeq	r0, #1
   19672:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
   19676:	3001      	addeq	r0, #1
   19678:	bcf0      	pop	{r4, r5, r6, r7}
   1967a:	3801      	subs	r0, #1
   1967c:	4770      	bx	lr
   1967e:	bf00      	nop

Disassembly of section .text._DRV_PHY_SMITransferStart%407:

00019680 <_DRV_PHY_SMITransferStart>:
    if(hClientObj->miimOpHandle != 0)
   19680:	6983      	ldr	r3, [r0, #24]
   19682:	2b00      	cmp	r3, #0
   19684:	d135      	bne.n	196f2 <_DRV_PHY_SMITransferStart+0x72>
{
   19686:	b530      	push	{r4, r5, lr}
   19688:	b085      	sub	sp, #20
   1968a:	4604      	mov	r4, r0
    DRV_ETHPHY_SMI_XFER_TYPE txType = hClientObj->smiTxferType;
   1968c:	f890 3036 	ldrb.w	r3, [r0, #54]	; 0x36
    if(txType == DRV_ETHPHY_SMI_XFER_TYPE_READ)
   19690:	2b03      	cmp	r3, #3
   19692:	d01b      	beq.n	196cc <_DRV_PHY_SMITransferStart+0x4c>
    else if(txType == DRV_ETHPHY_SMI_XFER_TYPE_WRITE || txType == DRV_ETHPHY_SMI_XFER_TYPE_WRITE_COMPLETE)
   19694:	1e5a      	subs	r2, r3, #1
   19696:	b2d2      	uxtb	r2, r2
   19698:	2a01      	cmp	r2, #1
   1969a:	d82c      	bhi.n	196f6 <_DRV_PHY_SMITransferStart+0x76>
        if(txType == DRV_ETHPHY_SMI_XFER_TYPE_WRITE)
   1969c:	2b01      	cmp	r3, #1
   1969e:	d02d      	beq.n	196fc <_DRV_PHY_SMITransferStart+0x7c>
        miimOpHandle = hClientObj->pMiimBase->DRV_MIIM_Write(hClientObj->miimHandle, hClientObj->smiRIx, hClientObj->smiPhyAddress, hClientObj->smiData, opFlags, &miimRes);
   196a0:	6903      	ldr	r3, [r0, #16]
   196a2:	f10d 020f 	add.w	r2, sp, #15
   196a6:	9201      	str	r2, [sp, #4]
   196a8:	2200      	movs	r2, #0
   196aa:	9200      	str	r2, [sp, #0]
   196ac:	6b1d      	ldr	r5, [r3, #48]	; 0x30
   196ae:	8f43      	ldrh	r3, [r0, #58]	; 0x3a
   196b0:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
   196b2:	8f01      	ldrh	r1, [r0, #56]	; 0x38
   196b4:	6940      	ldr	r0, [r0, #20]
   196b6:	47a8      	blx	r5
    if(miimOpHandle == 0)
   196b8:	4603      	mov	r3, r0
   196ba:	b9a0      	cbnz	r0, 196e6 <_DRV_PHY_SMITransferStart+0x66>
        if(miimRes == DRV_MIIM_RES_BUSY)
   196bc:	f99d 300f 	ldrsb.w	r3, [sp, #15]
            return DRV_ETHPHY_SMI_TXFER_RES_MIIM_ERROR;
   196c0:	2b02      	cmp	r3, #2
   196c2:	bf0c      	ite	eq
   196c4:	2003      	moveq	r0, #3
   196c6:	f06f 0001 	mvnne.w	r0, #1
   196ca:	e010      	b.n	196ee <_DRV_PHY_SMITransferStart+0x6e>
        miimOpHandle = hClientObj->pMiimBase->DRV_MIIM_Read(hClientObj->miimHandle, hClientObj->smiRIx, hClientObj->smiPhyAddress, DRV_MIIM_OPERATION_FLAG_NONE, &miimRes);
   196cc:	6903      	ldr	r3, [r0, #16]
   196ce:	f10d 020f 	add.w	r2, sp, #15
   196d2:	9200      	str	r2, [sp, #0]
   196d4:	6add      	ldr	r5, [r3, #44]	; 0x2c
   196d6:	2300      	movs	r3, #0
   196d8:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
   196da:	8f01      	ldrh	r1, [r0, #56]	; 0x38
   196dc:	6940      	ldr	r0, [r0, #20]
   196de:	47a8      	blx	r5
    if(miimOpHandle == 0)
   196e0:	4603      	mov	r3, r0
   196e2:	2800      	cmp	r0, #0
   196e4:	d0ea      	beq.n	196bc <_DRV_PHY_SMITransferStart+0x3c>
        hClientObj->miimOpHandle = miimOpHandle;
   196e6:	61a3      	str	r3, [r4, #24]
        txferRes = DRV_ETHPHY_SMI_TXFER_RES_SCHEDULED; 
   196e8:	2302      	movs	r3, #2
   196ea:	2001      	movs	r0, #1
    hClientObj->smiTxferStatus = newTxferStatus;
   196ec:	86a3      	strh	r3, [r4, #52]	; 0x34
}
   196ee:	b005      	add	sp, #20
   196f0:	bd30      	pop	{r4, r5, pc}
        return DRV_ETHPHY_SMI_TXFER_RES_BUSY;
   196f2:	2003      	movs	r0, #3
}
   196f4:	4770      	bx	lr
        return DRV_ETHPHY_SMI_TXFER_RES_ILLEGAL;
   196f6:	f04f 30ff 	mov.w	r0, #4294967295
   196fa:	e7f8      	b.n	196ee <_DRV_PHY_SMITransferStart+0x6e>
        miimOpHandle = hClientObj->pMiimBase->DRV_MIIM_Write(hClientObj->miimHandle, hClientObj->smiRIx, hClientObj->smiPhyAddress, hClientObj->smiData, opFlags, &miimRes);
   196fc:	6903      	ldr	r3, [r0, #16]
   196fe:	f10d 020f 	add.w	r2, sp, #15
   19702:	9201      	str	r2, [sp, #4]
   19704:	2201      	movs	r2, #1
   19706:	9200      	str	r2, [sp, #0]
   19708:	6b1d      	ldr	r5, [r3, #48]	; 0x30
   1970a:	8f43      	ldrh	r3, [r0, #58]	; 0x3a
   1970c:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
   1970e:	8f01      	ldrh	r1, [r0, #56]	; 0x38
   19710:	6940      	ldr	r0, [r0, #20]
   19712:	47a8      	blx	r5
    if(miimOpHandle == 0)
   19714:	2800      	cmp	r0, #0
   19716:	d0d1      	beq.n	196bc <_DRV_PHY_SMITransferStart+0x3c>
            newTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
   19718:	2300      	movs	r3, #0
        txferRes = DRV_ETHPHY_SMI_TXFER_RES_DONE; 
   1971a:	4618      	mov	r0, r3
   1971c:	e7e6      	b.n	196ec <_DRV_PHY_SMITransferStart+0x6c>

Disassembly of section .text.__d2b%408:

0001971e <__d2b>:
   1971e:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   19722:	ec59 8b10 	vmov	r8, r9, d0
   19726:	460e      	mov	r6, r1
   19728:	f240 74ff 	movw	r4, #2047	; 0x7ff
   1972c:	2101      	movs	r1, #1
   1972e:	4615      	mov	r5, r2
   19730:	f003 fa2c 	bl	1cb8c <_Balloc>
   19734:	f3c9 0313 	ubfx	r3, r9, #0, #20
   19738:	ea14 5419 	ands.w	r4, r4, r9, lsr #20
   1973c:	bf18      	it	ne
   1973e:	f443 1380 	orrne.w	r3, r3, #1048576	; 0x100000
   19742:	9301      	str	r3, [sp, #4]
   19744:	f1b8 0300 	subs.w	r3, r8, #0
   19748:	4607      	mov	r7, r0
   1974a:	d023      	beq.n	19794 <__d2b+0x76>
   1974c:	4668      	mov	r0, sp
   1974e:	9300      	str	r3, [sp, #0]
   19750:	f003 fe56 	bl	1d400 <__lo0bits>
   19754:	9900      	ldr	r1, [sp, #0]
   19756:	b1d8      	cbz	r0, 19790 <__d2b+0x72>
   19758:	9a01      	ldr	r2, [sp, #4]
   1975a:	f1c0 0320 	rsb	r3, r0, #32
   1975e:	fa02 f303 	lsl.w	r3, r2, r3
   19762:	430b      	orrs	r3, r1
   19764:	40c2      	lsrs	r2, r0
   19766:	617b      	str	r3, [r7, #20]
   19768:	9201      	str	r2, [sp, #4]
   1976a:	9b01      	ldr	r3, [sp, #4]
   1976c:	61bb      	str	r3, [r7, #24]
   1976e:	2b00      	cmp	r3, #0
   19770:	bf14      	ite	ne
   19772:	2102      	movne	r1, #2
   19774:	2101      	moveq	r1, #1
   19776:	6139      	str	r1, [r7, #16]
   19778:	b1ac      	cbz	r4, 197a6 <__d2b+0x88>
   1977a:	f2a4 4433 	subw	r4, r4, #1075	; 0x433
   1977e:	4404      	add	r4, r0
   19780:	6034      	str	r4, [r6, #0]
   19782:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
   19786:	6028      	str	r0, [r5, #0]
   19788:	4638      	mov	r0, r7
   1978a:	b003      	add	sp, #12
   1978c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   19790:	6179      	str	r1, [r7, #20]
   19792:	e7ea      	b.n	1976a <__d2b+0x4c>
   19794:	a801      	add	r0, sp, #4
   19796:	f003 fe33 	bl	1d400 <__lo0bits>
   1979a:	9b01      	ldr	r3, [sp, #4]
   1979c:	617b      	str	r3, [r7, #20]
   1979e:	2101      	movs	r1, #1
   197a0:	6139      	str	r1, [r7, #16]
   197a2:	3020      	adds	r0, #32
   197a4:	e7e8      	b.n	19778 <__d2b+0x5a>
   197a6:	eb07 0381 	add.w	r3, r7, r1, lsl #2
   197aa:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
   197ae:	6030      	str	r0, [r6, #0]
   197b0:	6918      	ldr	r0, [r3, #16]
   197b2:	f006 fab7 	bl	1fd24 <__hi0bits>
   197b6:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
   197ba:	e7e4      	b.n	19786 <__d2b+0x68>

Disassembly of section .text.DRV_MIIM_Setup%409:

000197bc <DRV_MIIM_Setup>:
    if(pSetUp == 0)
   197bc:	2900      	cmp	r1, #0
   197be:	d042      	beq.n	19846 <DRV_MIIM_Setup+0x8a>
{
   197c0:	b510      	push	{r4, lr}
   197c2:	460c      	mov	r4, r1
    if((pClient = _DRV_MIIM_GetClientAndLock(handle, true)) == 0)
   197c4:	2101      	movs	r1, #1
   197c6:	f004 ff48 	bl	1e65a <_DRV_MIIM_GetClientAndLock>
   197ca:	2800      	cmp	r0, #0
   197cc:	d03e      	beq.n	1984c <DRV_MIIM_Setup+0x90>
    pMiimObj = pClient->parentObj;
   197ce:	6840      	ldr	r0, [r0, #4]
    
    static  __inline__ void __attribute__((always_inline)) _DRV_MIIM_SMI_CLOCK_SET(uintptr_t ethPhyId, uint32_t hostClock, uint32_t maxMIIMClock )
    { 
    	uint32_t mdc_div; 
        GMAC_MIIM_CLK clock_dividor ; 
        mdc_div = hostClock/maxMIIMClock; 
   197d0:	6823      	ldr	r3, [r4, #0]
   197d2:	6862      	ldr	r2, [r4, #4]
   197d4:	fbb3 f3f2 	udiv	r3, r3, r2
        if (mdc_div <= 8 ) 
   197d8:	2b08      	cmp	r3, #8
   197da:	d90c      	bls.n	197f6 <DRV_MIIM_Setup+0x3a>
        { 
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_8; 
        } 
        else if (mdc_div <= 16 ) 
   197dc:	2b10      	cmp	r3, #16
   197de:	d92a      	bls.n	19836 <DRV_MIIM_Setup+0x7a>
        { 
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_16; 
        } 
        else if (mdc_div <= 32 ) 
   197e0:	2b20      	cmp	r3, #32
   197e2:	d92a      	bls.n	1983a <DRV_MIIM_Setup+0x7e>
        { 
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_32; 
        } 
        else if (mdc_div <= 48 ) 
   197e4:	2b30      	cmp	r3, #48	; 0x30
   197e6:	d92a      	bls.n	1983e <DRV_MIIM_Setup+0x82>
        { 
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_48; 
        } 
        else if (mdc_div <= 64 ) 
   197e8:	2b40      	cmp	r3, #64	; 0x40
   197ea:	d92a      	bls.n	19842 <DRV_MIIM_Setup+0x86>
        { 
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_96; 
        } 
        else 
        { 
            clock_dividor = 0; 
   197ec:	2b61      	cmp	r3, #97	; 0x61
   197ee:	bf34      	ite	cc
   197f0:	2405      	movcc	r4, #5
   197f2:	2400      	movcs	r4, #0
   197f4:	e000      	b.n	197f8 <DRV_MIIM_Setup+0x3c>
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_8; 
   197f6:	2400      	movs	r4, #0
        } 
        GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_TXEN_Msk; 
   197f8:	4b16      	ldr	r3, [pc, #88]	; (19854 <DRV_MIIM_Setup+0x98>)
   197fa:	6819      	ldr	r1, [r3, #0]
   197fc:	f021 0108 	bic.w	r1, r1, #8
   19800:	6019      	str	r1, [r3, #0]
        GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_RXEN_Msk;	
   19802:	6819      	ldr	r1, [r3, #0]
   19804:	f021 0104 	bic.w	r1, r1, #4
   19808:	6019      	str	r1, [r3, #0]
        GMAC_REGS->GMAC_NCFGR = 
                   (GMAC_REGS->GMAC_NCFGR & 
   1980a:	685a      	ldr	r2, [r3, #4]
   1980c:	f422 12e0 	bic.w	r2, r2, #1835008	; 0x1c0000
                        (~GMAC_NCFGR_CLK_Msk)) | (clock_dividor << GMAC_NCFGR_CLK_Pos); 
   19810:	ea42 4284 	orr.w	r2, r2, r4, lsl #18
        GMAC_REGS->GMAC_NCFGR = 
   19814:	605a      	str	r2, [r3, #4]
        GMAC_REGS->GMAC_NCR |= GMAC_NCR_TXEN_Msk; 
   19816:	681a      	ldr	r2, [r3, #0]
   19818:	f042 0208 	orr.w	r2, r2, #8
   1981c:	601a      	str	r2, [r3, #0]
        GMAC_REGS->GMAC_NCR |= GMAC_NCR_RXEN_Msk;	
   1981e:	681a      	ldr	r2, [r3, #0]
   19820:	f042 0204 	orr.w	r2, r2, #4
   19824:	601a      	str	r2, [r3, #0]
    pMiimObj->objFlags |= DRV_MIIM_OBJ_FLAG_SETUP_DONE;
   19826:	8883      	ldrh	r3, [r0, #4]
   19828:	f043 0302 	orr.w	r3, r3, #2
   1982c:	8083      	strh	r3, [r0, #4]
    OSAL_SEM_Post(&pMiimObj->objSem);
   1982e:	f009 ffad 	bl	2378c <OSAL_SEM_Post>
    return res;
   19832:	2000      	movs	r0, #0
}
   19834:	bd10      	pop	{r4, pc}
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_16; 
   19836:	2401      	movs	r4, #1
   19838:	e7de      	b.n	197f8 <DRV_MIIM_Setup+0x3c>
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_32; 
   1983a:	2402      	movs	r4, #2
   1983c:	e7dc      	b.n	197f8 <DRV_MIIM_Setup+0x3c>
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_48; 
   1983e:	2403      	movs	r4, #3
   19840:	e7da      	b.n	197f8 <DRV_MIIM_Setup+0x3c>
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_64; 
   19842:	2404      	movs	r4, #4
   19844:	e7d8      	b.n	197f8 <DRV_MIIM_Setup+0x3c>
        return DRV_MIIM_RES_PARAMETER_ERR;
   19846:	f06f 0006 	mvn.w	r0, #6
}
   1984a:	4770      	bx	lr
        return DRV_MIIM_RES_HANDLE_ERR;
   1984c:	f04f 30ff 	mov.w	r0, #4294967295
   19850:	e7f0      	b.n	19834 <DRV_MIIM_Setup+0x78>
   19852:	bf00      	nop
   19854:	42000800 	.word	0x42000800

Disassembly of section .text._Command_MACAddressSet%410:

00019858 <_Command_MACAddressSet>:
{
   19858:	b5f0      	push	{r4, r5, r6, r7, lr}
   1985a:	b083      	sub	sp, #12
   1985c:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   1985e:	6845      	ldr	r5, [r0, #4]
    if (argc != 3) {
   19860:	2903      	cmp	r1, #3
   19862:	d00f      	beq.n	19884 <_Command_MACAddressSet+0x2c>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: setmac <interface> <x:x:x:x:x:x> \r\n");
   19864:	4e1e      	ldr	r6, [pc, #120]	; (198e0 <_Command_MACAddressSet+0x88>)
   19866:	6803      	ldr	r3, [r0, #0]
   19868:	681b      	ldr	r3, [r3, #0]
   1986a:	f606 4198 	addw	r1, r6, #3224	; 0xc98
   1986e:	4628      	mov	r0, r5
   19870:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: setmac PIC32INT aa:bb:cc:dd:ee:ff \r\n");
   19872:	6823      	ldr	r3, [r4, #0]
   19874:	681b      	ldr	r3, [r3, #0]
   19876:	f606 41c4 	addw	r1, r6, #3268	; 0xcc4
   1987a:	4628      	mov	r0, r5
   1987c:	4798      	blx	r3
        return false;
   1987e:	2000      	movs	r0, #0
}
   19880:	b003      	add	sp, #12
   19882:	bdf0      	pop	{r4, r5, r6, r7, pc}
   19884:	4616      	mov	r6, r2
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
   19886:	6850      	ldr	r0, [r2, #4]
   19888:	f006 f8ec 	bl	1fa64 <TCPIP_STACK_NetHandleGet>
    if (netH == 0) {
   1988c:	4607      	mov	r7, r0
   1988e:	b188      	cbz	r0, 198b4 <_Command_MACAddressSet+0x5c>
    (*pCmdIO->pCmdApi->print)(cmdIoParam, "argv[2]: %s\r\n", argv[2]);
   19890:	6823      	ldr	r3, [r4, #0]
   19892:	685b      	ldr	r3, [r3, #4]
   19894:	68b2      	ldr	r2, [r6, #8]
   19896:	4913      	ldr	r1, [pc, #76]	; (198e4 <_Command_MACAddressSet+0x8c>)
   19898:	4628      	mov	r0, r5
   1989a:	4798      	blx	r3
    if (!TCPIP_Helper_StringToMACAddress(argv[2], macAddr.v)) {
   1989c:	4669      	mov	r1, sp
   1989e:	68b0      	ldr	r0, [r6, #8]
   198a0:	f7fe f9a2 	bl	17be8 <TCPIP_Helper_StringToMACAddress>
   198a4:	b968      	cbnz	r0, 198c2 <_Command_MACAddressSet+0x6a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Invalid MAC address string \r\n");
   198a6:	6823      	ldr	r3, [r4, #0]
   198a8:	681b      	ldr	r3, [r3, #0]
   198aa:	490f      	ldr	r1, [pc, #60]	; (198e8 <_Command_MACAddressSet+0x90>)
   198ac:	4628      	mov	r0, r5
   198ae:	4798      	blx	r3
        return false;
   198b0:	2000      	movs	r0, #0
   198b2:	e7e5      	b.n	19880 <_Command_MACAddressSet+0x28>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   198b4:	6823      	ldr	r3, [r4, #0]
   198b6:	681b      	ldr	r3, [r3, #0]
   198b8:	490c      	ldr	r1, [pc, #48]	; (198ec <_Command_MACAddressSet+0x94>)
   198ba:	4628      	mov	r0, r5
   198bc:	4798      	blx	r3
        return false;
   198be:	2000      	movs	r0, #0
   198c0:	e7de      	b.n	19880 <_Command_MACAddressSet+0x28>
    if(!TCPIP_STACK_NetAddressMacSet(netH, &macAddr)) {
   198c2:	4669      	mov	r1, sp
   198c4:	4638      	mov	r0, r7
   198c6:	f009 f827 	bl	22918 <TCPIP_STACK_NetAddressMacSet>
   198ca:	b108      	cbz	r0, 198d0 <_Command_MACAddressSet+0x78>
    return true;
   198cc:	2001      	movs	r0, #1
   198ce:	e7d7      	b.n	19880 <_Command_MACAddressSet+0x28>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Set MAC address failed\r\n");
   198d0:	6823      	ldr	r3, [r4, #0]
   198d2:	681b      	ldr	r3, [r3, #0]
   198d4:	4906      	ldr	r1, [pc, #24]	; (198f0 <_Command_MACAddressSet+0x98>)
   198d6:	4628      	mov	r0, r5
   198d8:	4798      	blx	r3
        return false;
   198da:	2000      	movs	r0, #0
   198dc:	e7d0      	b.n	19880 <_Command_MACAddressSet+0x28>
   198de:	bf00      	nop
   198e0:	0000028c 	.word	0x0000028c
   198e4:	00000f7c 	.word	0x00000f7c
   198e8:	00000f8c 	.word	0x00000f8c
   198ec:	00000b80 	.word	0x00000b80
   198f0:	00000fac 	.word	0x00000fac

Disassembly of section .text._free_r%411:

000198f4 <_free_r>:
   198f4:	b538      	push	{r3, r4, r5, lr}
   198f6:	4605      	mov	r5, r0
   198f8:	2900      	cmp	r1, #0
   198fa:	d045      	beq.n	19988 <_free_r+0x94>
   198fc:	f851 3c04 	ldr.w	r3, [r1, #-4]
   19900:	1f0c      	subs	r4, r1, #4
   19902:	2b00      	cmp	r3, #0
   19904:	bfb8      	it	lt
   19906:	18e4      	addlt	r4, r4, r3
   19908:	f006 fb9b 	bl	20042 <__malloc_lock>
   1990c:	4a1f      	ldr	r2, [pc, #124]	; (1998c <_free_r+0x98>)
   1990e:	6813      	ldr	r3, [r2, #0]
   19910:	4610      	mov	r0, r2
   19912:	b933      	cbnz	r3, 19922 <_free_r+0x2e>
   19914:	6063      	str	r3, [r4, #4]
   19916:	6014      	str	r4, [r2, #0]
   19918:	4628      	mov	r0, r5
   1991a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1991e:	f007 b868 	b.w	209f2 <__malloc_unlock>
   19922:	42a3      	cmp	r3, r4
   19924:	d90c      	bls.n	19940 <_free_r+0x4c>
   19926:	6821      	ldr	r1, [r4, #0]
   19928:	1862      	adds	r2, r4, r1
   1992a:	4293      	cmp	r3, r2
   1992c:	bf04      	itt	eq
   1992e:	681a      	ldreq	r2, [r3, #0]
   19930:	685b      	ldreq	r3, [r3, #4]
   19932:	6063      	str	r3, [r4, #4]
   19934:	bf04      	itt	eq
   19936:	1852      	addeq	r2, r2, r1
   19938:	6022      	streq	r2, [r4, #0]
   1993a:	6004      	str	r4, [r0, #0]
   1993c:	e7ec      	b.n	19918 <_free_r+0x24>
   1993e:	4613      	mov	r3, r2
   19940:	685a      	ldr	r2, [r3, #4]
   19942:	b10a      	cbz	r2, 19948 <_free_r+0x54>
   19944:	42a2      	cmp	r2, r4
   19946:	d9fa      	bls.n	1993e <_free_r+0x4a>
   19948:	6819      	ldr	r1, [r3, #0]
   1994a:	1858      	adds	r0, r3, r1
   1994c:	42a0      	cmp	r0, r4
   1994e:	d10b      	bne.n	19968 <_free_r+0x74>
   19950:	6820      	ldr	r0, [r4, #0]
   19952:	4401      	add	r1, r0
   19954:	1858      	adds	r0, r3, r1
   19956:	4282      	cmp	r2, r0
   19958:	6019      	str	r1, [r3, #0]
   1995a:	d1dd      	bne.n	19918 <_free_r+0x24>
   1995c:	6810      	ldr	r0, [r2, #0]
   1995e:	6852      	ldr	r2, [r2, #4]
   19960:	605a      	str	r2, [r3, #4]
   19962:	4401      	add	r1, r0
   19964:	6019      	str	r1, [r3, #0]
   19966:	e7d7      	b.n	19918 <_free_r+0x24>
   19968:	d902      	bls.n	19970 <_free_r+0x7c>
   1996a:	230c      	movs	r3, #12
   1996c:	602b      	str	r3, [r5, #0]
   1996e:	e7d3      	b.n	19918 <_free_r+0x24>
   19970:	6820      	ldr	r0, [r4, #0]
   19972:	1821      	adds	r1, r4, r0
   19974:	428a      	cmp	r2, r1
   19976:	bf04      	itt	eq
   19978:	6811      	ldreq	r1, [r2, #0]
   1997a:	6852      	ldreq	r2, [r2, #4]
   1997c:	6062      	str	r2, [r4, #4]
   1997e:	bf04      	itt	eq
   19980:	1809      	addeq	r1, r1, r0
   19982:	6021      	streq	r1, [r4, #0]
   19984:	605c      	str	r4, [r3, #4]
   19986:	e7c7      	b.n	19918 <_free_r+0x24>
   19988:	bd38      	pop	{r3, r4, r5, pc}
   1998a:	bf00      	nop
   1998c:	2000ef64 	.word	0x2000ef64

Disassembly of section .text.__pow5mult%412:

00019990 <__pow5mult>:
   19990:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   19994:	4615      	mov	r5, r2
   19996:	f012 0203 	ands.w	r2, r2, #3
   1999a:	4606      	mov	r6, r0
   1999c:	460f      	mov	r7, r1
   1999e:	d007      	beq.n	199b0 <__pow5mult+0x20>
   199a0:	3a01      	subs	r2, #1
   199a2:	4c21      	ldr	r4, [pc, #132]	; (19a28 <__pow5mult+0x98>)
   199a4:	2300      	movs	r3, #0
   199a6:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
   199aa:	f001 fcb2 	bl	1b312 <__multadd>
   199ae:	4607      	mov	r7, r0
   199b0:	10ad      	asrs	r5, r5, #2
   199b2:	d035      	beq.n	19a20 <__pow5mult+0x90>
   199b4:	6a74      	ldr	r4, [r6, #36]	; 0x24
   199b6:	b93c      	cbnz	r4, 199c8 <__pow5mult+0x38>
   199b8:	2010      	movs	r0, #16
   199ba:	f00a fa61 	bl	23e80 <malloc>
   199be:	e9c0 4401 	strd	r4, r4, [r0, #4]
   199c2:	6270      	str	r0, [r6, #36]	; 0x24
   199c4:	6004      	str	r4, [r0, #0]
   199c6:	60c4      	str	r4, [r0, #12]
   199c8:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
   199cc:	f8d8 4008 	ldr.w	r4, [r8, #8]
   199d0:	b94c      	cbnz	r4, 199e6 <__pow5mult+0x56>
   199d2:	f240 2171 	movw	r1, #625	; 0x271
   199d6:	4630      	mov	r0, r6
   199d8:	f00a f987 	bl	23cea <__i2b>
   199dc:	2300      	movs	r3, #0
   199de:	f8c8 0008 	str.w	r0, [r8, #8]
   199e2:	4604      	mov	r4, r0
   199e4:	6003      	str	r3, [r0, #0]
   199e6:	f04f 0800 	mov.w	r8, #0
   199ea:	07eb      	lsls	r3, r5, #31
   199ec:	d50a      	bpl.n	19a04 <__pow5mult+0x74>
   199ee:	4639      	mov	r1, r7
   199f0:	4622      	mov	r2, r4
   199f2:	4630      	mov	r0, r6
   199f4:	f7fa f9ec 	bl	13dd0 <__multiply>
   199f8:	4639      	mov	r1, r7
   199fa:	4681      	mov	r9, r0
   199fc:	4630      	mov	r0, r6
   199fe:	f007 ff5e 	bl	218be <_Bfree>
   19a02:	464f      	mov	r7, r9
   19a04:	106d      	asrs	r5, r5, #1
   19a06:	d00b      	beq.n	19a20 <__pow5mult+0x90>
   19a08:	6820      	ldr	r0, [r4, #0]
   19a0a:	b938      	cbnz	r0, 19a1c <__pow5mult+0x8c>
   19a0c:	4622      	mov	r2, r4
   19a0e:	4621      	mov	r1, r4
   19a10:	4630      	mov	r0, r6
   19a12:	f7fa f9dd 	bl	13dd0 <__multiply>
   19a16:	6020      	str	r0, [r4, #0]
   19a18:	f8c0 8000 	str.w	r8, [r0]
   19a1c:	4604      	mov	r4, r0
   19a1e:	e7e4      	b.n	199ea <__pow5mult+0x5a>
   19a20:	4638      	mov	r0, r7
   19a22:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   19a26:	bf00      	nop
   19a28:	000242e0 	.word	0x000242e0

Disassembly of section .text.Lan867x_Write_Bit_Register%413:

00019a2c <Lan867x_Write_Bit_Register>:
{
   19a2c:	b5f0      	push	{r4, r5, r6, r7, lr}
   19a2e:	b083      	sub	sp, #12
   19a30:	4604      	mov	r4, r0
   19a32:	460d      	mov	r5, r1
   19a34:	4616      	mov	r6, r2
   19a36:	461f      	mov	r7, r3
    uint16_t regValue = 0;
   19a38:	2300      	movs	r3, #0
   19a3a:	f8ad 3006 	strh.w	r3, [sp, #6]
    if (R2F(clientObj->vendorData, VENDOR_INTERNAL_STATE) == IDLE_PHASE) {
   19a3e:	6843      	ldr	r3, [r0, #4]
   19a40:	0e5a      	lsrs	r2, r3, #25
   19a42:	d00f      	beq.n	19a64 <Lan867x_Write_Bit_Register+0x38>
    if (R2F(clientObj->vendorData, VENDOR_IS_BIT_OP) == true) {
   19a44:	6863      	ldr	r3, [r4, #4]
   19a46:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
   19a4a:	d02b      	beq.n	19aa4 <Lan867x_Write_Bit_Register+0x78>
        res = Lan867x_Miim_Task(clientObj, DRV_MIIM_OP_READ, regAddr, &regValue);
   19a4c:	f10d 0306 	add.w	r3, sp, #6
   19a50:	462a      	mov	r2, r5
   19a52:	2101      	movs	r1, #1
   19a54:	4620      	mov	r0, r4
   19a56:	f7f6 fc99 	bl	1038c <Lan867x_Miim_Task>
        if (res == DRV_MIIM_RES_OK) {
   19a5a:	4603      	mov	r3, r0
   19a5c:	b178      	cbz	r0, 19a7e <Lan867x_Write_Bit_Register+0x52>
}
   19a5e:	4618      	mov	r0, r3
   19a60:	b003      	add	sp, #12
   19a62:	bdf0      	pop	{r4, r5, r6, r7, pc}
            F2R(internalState, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   19a64:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   19a68:	291f      	cmp	r1, #31
   19a6a:	bf94      	ite	ls
   19a6c:	f04f 7200 	movls.w	r2, #33554432	; 0x2000000
   19a70:	f04f 6200 	movhi.w	r2, #134217728	; 0x8000000
   19a74:	4313      	orrs	r3, r2
        clientObj->vendorData = F2R(true, VENDOR_IS_BIT_OP, clientObj->vendorData);
   19a76:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   19a7a:	6043      	str	r3, [r0, #4]
   19a7c:	e7e2      	b.n	19a44 <Lan867x_Write_Bit_Register+0x18>
            clientObj->vendorData = F2R(((regValue & (uint16_t)~mask) | (wData & mask)),
   19a7e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   19a82:	405f      	eors	r7, r3
   19a84:	403e      	ands	r6, r7
   19a86:	405e      	eors	r6, r3
   19a88:	6863      	ldr	r3, [r4, #4]
   19a8a:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
                F2R(internalState, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   19a8e:	431e      	orrs	r6, r3
   19a90:	2d1f      	cmp	r5, #31
   19a92:	bf94      	ite	ls
   19a94:	f04f 6580 	movls.w	r5, #67108864	; 0x4000000
   19a98:	f04f 6500 	movhi.w	r5, #134217728	; 0x8000000
   19a9c:	4335      	orrs	r5, r6
            clientObj->vendorData =
   19a9e:	6065      	str	r5, [r4, #4]
            res = DRV_MIIM_RES_PENDING;
   19aa0:	2301      	movs	r3, #1
   19aa2:	e7dc      	b.n	19a5e <Lan867x_Write_Bit_Register+0x32>
        regValue = R2F(clientObj->vendorData, VENDOR_DATA);
   19aa4:	f8ad 3006 	strh.w	r3, [sp, #6]
        res = Lan867x_Miim_Task(clientObj, DRV_MIIM_OP_WRITE, regAddr, &regValue);
   19aa8:	f10d 0306 	add.w	r3, sp, #6
   19aac:	462a      	mov	r2, r5
   19aae:	2102      	movs	r1, #2
   19ab0:	4620      	mov	r0, r4
   19ab2:	f7f6 fc6b 	bl	1038c <Lan867x_Miim_Task>
        if (res == DRV_MIIM_RES_OK) {
   19ab6:	4603      	mov	r3, r0
   19ab8:	2800      	cmp	r0, #0
   19aba:	d1d0      	bne.n	19a5e <Lan867x_Write_Bit_Register+0x32>
                F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   19abc:	6862      	ldr	r2, [r4, #4]
   19abe:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
            clientObj->vendorData =
   19ac2:	6062      	str	r2, [r4, #4]
            res = DRV_MIIM_RES_OK;
   19ac4:	e7cb      	b.n	19a5e <Lan867x_Write_Bit_Register+0x32>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseDetect%414:

00019ac8 <_DRV_ETHPHY_SetupPhaseDetect>:
{
   19ac8:	b538      	push	{r3, r4, r5, lr}
   19aca:	4604      	mov	r4, r0
    switch (hClientObj->operSubPhase)
   19acc:	8c03      	ldrh	r3, [r0, #32]
   19ace:	b133      	cbz	r3, 19ade <_DRV_ETHPHY_SetupPhaseDetect+0x16>
   19ad0:	2b01      	cmp	r3, #1
   19ad2:	d023      	beq.n	19b1c <_DRV_ETHPHY_SetupPhaseDetect+0x54>
            _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   19ad4:	f06f 0108 	mvn.w	r1, #8
   19ad8:	f008 f9a8 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
}
   19adc:	e01d      	b.n	19b1a <_DRV_ETHPHY_SetupPhaseDetect+0x52>
            if((detectF = hDriver->pPhyObj->phyDetect) == 0)
   19ade:	68c3      	ldr	r3, [r0, #12]
   19ae0:	695b      	ldr	r3, [r3, #20]
   19ae2:	691b      	ldr	r3, [r3, #16]
                detectF = _DRV_ETHPHY_DefaultDetect;
   19ae4:	4a1b      	ldr	r2, [pc, #108]	; (19b54 <_DRV_ETHPHY_SetupPhaseDetect+0x8c>)
   19ae6:	2b00      	cmp	r3, #0
   19ae8:	bf08      	it	eq
   19aea:	4613      	moveq	r3, r2
            hClientObj->vendorDetect = detectF;
   19aec:	6443      	str	r3, [r0, #68]	; 0x44
            hClientObj->vendorData = 0;
   19aee:	2300      	movs	r3, #0
   19af0:	6403      	str	r3, [r0, #64]	; 0x40
            hClientObj->operTStamp = SYS_TMR_TickCountGet() + ((DRV_ETHPHY_RESET_CLR_TMO * SYS_TMR_TickCounterFrequencyGet()) + 999) / 1000;
   19af2:	f008 fba3 	bl	2223c <SYS_TMR_TickCountGet>
   19af6:	4605      	mov	r5, r0
   19af8:	f008 fbc8 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
   19afc:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   19b00:	fb03 f000 	mul.w	r0, r3, r0
   19b04:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
   19b08:	4b13      	ldr	r3, [pc, #76]	; (19b58 <_DRV_ETHPHY_SetupPhaseDetect+0x90>)
   19b0a:	fba3 3000 	umull	r3, r0, r3, r0
   19b0e:	eb05 1090 	add.w	r0, r5, r0, lsr #6
   19b12:	62a0      	str	r0, [r4, #40]	; 0x28
    hClientObj->operPhase = operPhase;
   19b14:	2301      	movs	r3, #1
   19b16:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   19b18:	8423      	strh	r3, [r4, #32]
}
   19b1a:	bd38      	pop	{r3, r4, r5, pc}
            res =  hClientObj->vendorDetect(gDrvEthBaseObj, (DRV_HANDLE)hClientObj);
   19b1c:	6c43      	ldr	r3, [r0, #68]	; 0x44
   19b1e:	4601      	mov	r1, r0
   19b20:	480e      	ldr	r0, [pc, #56]	; (19b5c <_DRV_ETHPHY_SetupPhaseDetect+0x94>)
   19b22:	4798      	blx	r3
            if(res == DRV_ETHPHY_RES_OK)
   19b24:	4601      	mov	r1, r0
   19b26:	b160      	cbz	r0, 19b42 <_DRV_ETHPHY_SetupPhaseDetect+0x7a>
            else if(res < 0)
   19b28:	2800      	cmp	r0, #0
   19b2a:	db0f      	blt.n	19b4c <_DRV_ETHPHY_SetupPhaseDetect+0x84>
                if(SYS_TMR_TickCountGet() >= hClientObj->operTStamp)
   19b2c:	f008 fb86 	bl	2223c <SYS_TMR_TickCountGet>
   19b30:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   19b32:	4298      	cmp	r0, r3
   19b34:	d3f1      	bcc.n	19b1a <_DRV_ETHPHY_SetupPhaseDetect+0x52>
                    _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_DTCT_TMO);
   19b36:	f06f 0101 	mvn.w	r1, #1
   19b3a:	4620      	mov	r0, r4
   19b3c:	f008 f976 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
   19b40:	e7eb      	b.n	19b1a <_DRV_ETHPHY_SetupPhaseDetect+0x52>
    hClientObj->operPhase = operPhase;
   19b42:	2302      	movs	r3, #2
   19b44:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   19b46:	2300      	movs	r3, #0
   19b48:	8423      	strh	r3, [r4, #32]
   19b4a:	e7e6      	b.n	19b1a <_DRV_ETHPHY_SetupPhaseDetect+0x52>
                _DRV_PHY_SetOperDoneResult(hClientObj, res);
   19b4c:	4620      	mov	r0, r4
   19b4e:	f008 f96d 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
   19b52:	e7e2      	b.n	19b1a <_DRV_ETHPHY_SetupPhaseDetect+0x52>
   19b54:	00011775 	.word	0x00011775
   19b58:	10624dd3 	.word	0x10624dd3
   19b5c:	0001d460 	.word	0x0001d460

Disassembly of section .text.DRV_GMAC_StatisticsGet%415:

00019b60 <DRV_GMAC_StatisticsGet>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   19b60:	4b20      	ldr	r3, [pc, #128]	; (19be4 <DRV_GMAC_StatisticsGet+0x84>)
   19b62:	4283      	cmp	r3, r0
   19b64:	d136      	bne.n	19bd4 <DRV_GMAC_StatisticsGet+0x74>
    if(pMACDrv == 0)
   19b66:	2800      	cmp	r0, #0
   19b68:	d037      	beq.n	19bda <DRV_GMAC_StatisticsGet+0x7a>
{
   19b6a:	b570      	push	{r4, r5, r6, lr}
   19b6c:	4615      	mov	r5, r2
   19b6e:	460c      	mov	r4, r1
	if(pRxStatistics)
   19b70:	b1c9      	cbz	r1, 19ba6 <DRV_GMAC_StatisticsGet+0x46>
	if(pMACDrv->sGmacData._synchF != 0)
   19b72:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   19b74:	b113      	cbz	r3, 19b7c <DRV_GMAC_StatisticsGet+0x1c>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
   19b76:	2105      	movs	r1, #5
   19b78:	481b      	ldr	r0, [pc, #108]	; (19be8 <DRV_GMAC_StatisticsGet+0x88>)
   19b7a:	4798      	blx	r3
		DRV_PIC32CGMAC_LibRxBuffersCountGet(pMACDrv, &pMACDrv->sGmacData._rxStat.nRxPendBuffers, &pMACDrv->sGmacData._rxStat.nRxSchedBuffers);
   19b7c:	4e19      	ldr	r6, [pc, #100]	; (19be4 <DRV_GMAC_StatisticsGet+0x84>)
   19b7e:	f106 026c 	add.w	r2, r6, #108	; 0x6c
   19b82:	f106 0168 	add.w	r1, r6, #104	; 0x68
   19b86:	4630      	mov	r0, r6
   19b88:	f003 fe64 	bl	1d854 <DRV_PIC32CGMAC_LibRxBuffersCountGet>
	if(pMACDrv->sGmacData._synchF != 0)
   19b8c:	6b33      	ldr	r3, [r6, #48]	; 0x30
   19b8e:	b11b      	cbz	r3, 19b98 <DRV_GMAC_StatisticsGet+0x38>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_LEAVE);
   19b90:	2106      	movs	r1, #6
   19b92:	f106 005c 	add.w	r0, r6, #92	; 0x5c
   19b96:	4798      	blx	r3
		*pRxStatistics = pMACDrv->sGmacData._rxStat;
   19b98:	4e14      	ldr	r6, [pc, #80]	; (19bec <DRV_GMAC_StatisticsGet+0x8c>)
   19b9a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   19b9c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   19b9e:	e896 0003 	ldmia.w	r6, {r0, r1}
   19ba2:	e884 0003 	stmia.w	r4, {r0, r1}
	if(pTxStatistics)
   19ba6:	b1dd      	cbz	r5, 19be0 <DRV_GMAC_StatisticsGet+0x80>
	if(pMACDrv->sGmacData._synchF != 0)
   19ba8:	4b0e      	ldr	r3, [pc, #56]	; (19be4 <DRV_GMAC_StatisticsGet+0x84>)
   19baa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   19bac:	b113      	cbz	r3, 19bb4 <DRV_GMAC_StatisticsGet+0x54>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_LOCK);
   19bae:	2103      	movs	r1, #3
   19bb0:	480f      	ldr	r0, [pc, #60]	; (19bf0 <DRV_GMAC_StatisticsGet+0x90>)
   19bb2:	4798      	blx	r3
			pMACDrv->sGmacData._txStat.nTxPendBuffers += DRV_PIC32CGMAC_SingleListCount(&(pMACDrv->sGmacData.gmac_queue[index]._TxQueue));
   19bb4:	4b0b      	ldr	r3, [pc, #44]	; (19be4 <DRV_GMAC_StatisticsGet+0x84>)
   19bb6:	f8d3 20ac 	ldr.w	r2, [r3, #172]	; 0xac
   19bba:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	if(pMACDrv->sGmacData._synchF != 0)
   19bbe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   19bc0:	b113      	cbz	r3, 19bc8 <DRV_GMAC_StatisticsGet+0x68>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_UNLOCK);
   19bc2:	2104      	movs	r1, #4
   19bc4:	480a      	ldr	r0, [pc, #40]	; (19bf0 <DRV_GMAC_StatisticsGet+0x90>)
   19bc6:	4798      	blx	r3
		*pTxStatistics = pMACDrv->sGmacData._txStat;
   19bc8:	4b0a      	ldr	r3, [pc, #40]	; (19bf4 <DRV_GMAC_StatisticsGet+0x94>)
   19bca:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   19bcc:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
	return TCPIP_MAC_RES_OK;
   19bd0:	2000      	movs	r0, #0
}
   19bd2:	bd70      	pop	{r4, r5, r6, pc}
        return TCPIP_MAC_RES_OP_ERR;
   19bd4:	f06f 0005 	mvn.w	r0, #5
   19bd8:	4770      	bx	lr
   19bda:	f06f 0005 	mvn.w	r0, #5
}
   19bde:	4770      	bx	lr
	return TCPIP_MAC_RES_OK;
   19be0:	2000      	movs	r0, #0
   19be2:	e7f6      	b.n	19bd2 <DRV_GMAC_StatisticsGet+0x72>
   19be4:	2000e288 	.word	0x2000e288
   19be8:	2000e2e4 	.word	0x2000e2e4
   19bec:	2000e2ec 	.word	0x2000e2ec
   19bf0:	2000e2e8 	.word	0x2000e2e8
   19bf4:	2000e304 	.word	0x2000e304

Disassembly of section .text._DHCPEnable%416:

00019bf8 <_DHCPEnable>:
{
   19bf8:	b570      	push	{r4, r5, r6, lr}
   19bfa:	4606      	mov	r6, r0
   19bfc:	460d      	mov	r5, r1
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   19bfe:	4b20      	ldr	r3, [pc, #128]	; (19c80 <_DHCPEnable+0x88>)
   19c00:	681c      	ldr	r4, [r3, #0]
   19c02:	f00a f999 	bl	23f38 <TCPIP_STACK_NetIxGet>
   19c06:	235c      	movs	r3, #92	; 0x5c
   19c08:	fb03 4400 	mla	r4, r3, r0, r4
    if(TCPIP_STACK_NetworkIsLinked(pNetIf) || !_TCPIPStackNetIsPrimary(pNetIf))
   19c0c:	4630      	mov	r0, r6
   19c0e:	f009 f953 	bl	22eb8 <TCPIP_STACK_NetworkIsLinked>
    pClient->smState = newState;
   19c12:	f8a4 0056 	strh.w	r0, [r4, #86]	; 0x56
    pClient->flags.bDHCPEnabled = true;
   19c16:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
   19c1a:	f043 0301 	orr.w	r3, r3, #1
   19c1e:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    pClient->dhcpOp = opType;
   19c22:	f8a4 5054 	strh.w	r5, [r4, #84]	; 0x54
    pNetIf->Flags.bIsDHCPEnabled = true;
   19c26:	f896 3042 	ldrb.w	r3, [r6, #66]	; 0x42
   19c2a:	f043 0301 	orr.w	r3, r3, #1
   19c2e:	f886 3042 	strb.w	r3, [r6, #66]	; 0x42
    if(pClient->dhcpFilterHandle == 0)
   19c32:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   19c34:	b123      	cbz	r3, 19c40 <_DHCPEnable+0x48>
    if(opType == TCPIP_DHCP_OPER_INIT || opType == TCPIP_DHCP_OPER_INIT_REBOOT)
   19c36:	3d01      	subs	r5, #1
   19c38:	b2ed      	uxtb	r5, r5
   19c3a:	2d01      	cmp	r5, #1
   19c3c:	d911      	bls.n	19c62 <_DHCPEnable+0x6a>
}
   19c3e:	bd70      	pop	{r4, r5, r6, pc}
        pClient->dhcpFilterHandle = IPv4RegisterFilter(_DHCPPacketFilter, true);
   19c40:	2101      	movs	r1, #1
   19c42:	4810      	ldr	r0, [pc, #64]	; (19c84 <_DHCPEnable+0x8c>)
   19c44:	f004 f892 	bl	1dd6c <IPv4RegisterFilter>
   19c48:	64a0      	str	r0, [r4, #72]	; 0x48
        if(pClient->dhcpFilterHandle == 0)
   19c4a:	2800      	cmp	r0, #0
   19c4c:	d1f3      	bne.n	19c36 <_DHCPEnable+0x3e>
            SYS_ERROR(SYS_ERROR_WARNING, "DHCP: Failed to register IPv4 filter! \r\n");
   19c4e:	f00a fb17 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
   19c52:	2801      	cmp	r0, #1
   19c54:	d9ef      	bls.n	19c36 <_DHCPEnable+0x3e>
   19c56:	f00a fb0d 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
   19c5a:	490b      	ldr	r1, [pc, #44]	; (19c88 <_DHCPEnable+0x90>)
   19c5c:	f002 fd1e 	bl	1c69c <SYS_CONSOLE_Print>
   19c60:	e7e9      	b.n	19c36 <_DHCPEnable+0x3e>
        pClient->dhcpTmo = pClient->dhcpTmoBase;
   19c62:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
   19c66:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    pClient->flags.bReportFail = 1;
   19c6a:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
   19c6e:	f043 0320 	orr.w	r3, r3, #32
   19c72:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    return dhcpSecondCount;
   19c76:	4b05      	ldr	r3, [pc, #20]	; (19c8c <_DHCPEnable+0x94>)
        pClient->tOpStart = _DHCPSecondCountGet();
   19c78:	681b      	ldr	r3, [r3, #0]
   19c7a:	6223      	str	r3, [r4, #32]
}
   19c7c:	e7df      	b.n	19c3e <_DHCPEnable+0x46>
   19c7e:	bf00      	nop
   19c80:	2000ee3c 	.word	0x2000ee3c
   19c84:	0001a755 	.word	0x0001a755
   19c88:	00020b2c 	.word	0x00020b2c
   19c8c:	2000ee4c 	.word	0x2000ee4c

Disassembly of section .text.TCPIP_DHCP_Request%417:

00019c90 <TCPIP_DHCP_Request>:
   19c90:	b1a8      	cbz	r0, 19cbe <TCPIP_DHCP_Request+0x2e>
{
   19c92:	b570      	push	{r4, r5, r6, lr}
   19c94:	b082      	sub	sp, #8
   19c96:	4604      	mov	r4, r0
   19c98:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   19c9c:	f012 0f40 	tst.w	r2, #64	; 0x40
   19ca0:	d114      	bne.n	19ccc <TCPIP_DHCP_Request+0x3c>
        return false;
   19ca2:	2300      	movs	r3, #0
}
   19ca4:	4618      	mov	r0, r3
   19ca6:	b002      	add	sp, #8
   19ca8:	bd70      	pop	{r4, r5, r6, pc}
                       return false;
   19caa:	2300      	movs	r3, #0
   19cac:	e7fa      	b.n	19ca4 <TCPIP_DHCP_Request+0x14>
                else if(!TCPIP_STACK_AddressServiceCanStart(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_DHCPC))
   19cae:	2101      	movs	r1, #1
   19cb0:	4620      	mov	r0, r4
   19cb2:	f009 fe78 	bl	239a6 <TCPIP_STACK_AddressServiceCanStart>
   19cb6:	4603      	mov	r3, r0
   19cb8:	2800      	cmp	r0, #0
   19cba:	d0f3      	beq.n	19ca4 <TCPIP_DHCP_Request+0x14>
   19cbc:	e02b      	b.n	19d16 <TCPIP_DHCP_Request+0x86>
        return false;
   19cbe:	2300      	movs	r3, #0
}
   19cc0:	4618      	mov	r0, r3
   19cc2:	4770      	bx	lr
    return false;
   19cc4:	2300      	movs	r3, #0
   19cc6:	e7ed      	b.n	19ca4 <TCPIP_DHCP_Request+0x14>
        return false;
   19cc8:	2300      	movs	r3, #0
    return _DHCPStartOperation(_TCPIPStackHandleToNetUp(hNet), TCPIP_DHCP_OP_REQ_REQUEST, reqAddress.Val);
   19cca:	e7eb      	b.n	19ca4 <TCPIP_DHCP_Request+0x14>
    if(DHCPClients == 0 || pNetIf == 0)
   19ccc:	4a15      	ldr	r2, [pc, #84]	; (19d24 <TCPIP_DHCP_Request+0x94>)
   19cce:	6816      	ldr	r6, [r2, #0]
   19cd0:	2e00      	cmp	r6, #0
   19cd2:	d0f9      	beq.n	19cc8 <TCPIP_DHCP_Request+0x38>
   19cd4:	460d      	mov	r5, r1
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   19cd6:	4620      	mov	r0, r4
   19cd8:	f00a f92e 	bl	23f38 <TCPIP_STACK_NetIxGet>
            if(reqAddress != 0)
   19cdc:	2d00      	cmp	r5, #0
   19cde:	d0f1      	beq.n	19cc4 <TCPIP_DHCP_Request+0x34>
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   19ce0:	235c      	movs	r3, #92	; 0x5c
   19ce2:	fb03 6600 	mla	r6, r3, r0, r6
                if(pClient->flags.bDHCPEnabled != 0)
   19ce6:	f896 3058 	ldrb.w	r3, [r6, #88]	; 0x58
   19cea:	f013 0f01 	tst.w	r3, #1
   19cee:	d0de      	beq.n	19cae <TCPIP_DHCP_Request+0x1e>
                    if(pClient->smState == TCPIP_DHCP_GET_REQUEST_ACK || 
   19cf0:	f8b6 3056 	ldrh.w	r3, [r6, #86]	; 0x56
   19cf4:	2b0c      	cmp	r3, #12
   19cf6:	d806      	bhi.n	19d06 <TCPIP_DHCP_Request+0x76>
   19cf8:	f44f 52a1 	mov.w	r2, #5152	; 0x1420
   19cfc:	fa22 f303 	lsr.w	r3, r2, r3
   19d00:	f013 0f01 	tst.w	r3, #1
   19d04:	d1d1      	bne.n	19caa <TCPIP_DHCP_Request+0x1a>
                    IPV4_ADDR zeroAdd = {0};
   19d06:	2300      	movs	r3, #0
   19d08:	9301      	str	r3, [sp, #4]
                    _TCPIPStackSetConfigAddress(pNetIf, &zeroAdd, &zeroAdd, true);
   19d0a:	2301      	movs	r3, #1
   19d0c:	aa01      	add	r2, sp, #4
   19d0e:	4611      	mov	r1, r2
   19d10:	4620      	mov	r0, r4
   19d12:	f006 fe38 	bl	20986 <_TCPIPStackSetConfigAddress>
                pClient->dhcpIPAddress.Val = reqAddress;
   19d16:	62f5      	str	r5, [r6, #44]	; 0x2c
        _DHCPEnable(pNetIf, opType);
   19d18:	2102      	movs	r1, #2
   19d1a:	4620      	mov	r0, r4
   19d1c:	f7ff ff6c 	bl	19bf8 <_DHCPEnable>
        return true;
   19d20:	2301      	movs	r3, #1
   19d22:	e7bf      	b.n	19ca4 <TCPIP_DHCP_Request+0x14>
   19d24:	2000ee3c 	.word	0x2000ee3c

Disassembly of section .text.TCPIP_DHCP_InfoGet%418:

00019d28 <TCPIP_DHCP_InfoGet>:
{
   19d28:	b570      	push	{r4, r5, r6, lr}
   19d2a:	4604      	mov	r4, r0
    if(pDhcpInfo)
   19d2c:	460e      	mov	r6, r1
   19d2e:	b121      	cbz	r1, 19d3a <TCPIP_DHCP_InfoGet+0x12>
        memset(pDhcpInfo, 0, sizeof(*pDhcpInfo));
   19d30:	2234      	movs	r2, #52	; 0x34
   19d32:	2100      	movs	r1, #0
   19d34:	4630      	mov	r0, r6
   19d36:	f00a f8b3 	bl	23ea0 <memset>
   19d3a:	b30c      	cbz	r4, 19d80 <TCPIP_DHCP_InfoGet+0x58>
   19d3c:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   19d40:	f013 0f40 	tst.w	r3, #64	; 0x40
   19d44:	d122      	bne.n	19d8c <TCPIP_DHCP_InfoGet+0x64>
    return false;
   19d46:	2000      	movs	r0, #0
}
   19d48:	bd70      	pop	{r4, r5, r6, pc}
            if(pDhcpInfo)
   19d4a:	b1ee      	cbz	r6, 19d88 <TCPIP_DHCP_InfoGet+0x60>
                pDhcpInfo->status = pClient->smState;
   19d4c:	7033      	strb	r3, [r6, #0]
    return dhcpSecondCount;
   19d4e:	4b1a      	ldr	r3, [pc, #104]	; (19db8 <TCPIP_DHCP_InfoGet+0x90>)
                pDhcpInfo->dhcpTime = _DHCPSecondCountGet();
   19d50:	681b      	ldr	r3, [r3, #0]
   19d52:	6073      	str	r3, [r6, #4]
                pDhcpInfo->leaseStartTime = pClient->tRequest;
   19d54:	6883      	ldr	r3, [r0, #8]
   19d56:	60b3      	str	r3, [r6, #8]
                pDhcpInfo->leaseDuration = pClient->tExpSeconds;
   19d58:	6983      	ldr	r3, [r0, #24]
   19d5a:	60f3      	str	r3, [r6, #12]
                pDhcpInfo->renewTime = pClient->tRequest + pClient->t1Seconds;
   19d5c:	6883      	ldr	r3, [r0, #8]
   19d5e:	6902      	ldr	r2, [r0, #16]
   19d60:	4413      	add	r3, r2
   19d62:	6133      	str	r3, [r6, #16]
                pDhcpInfo->rebindTime = pClient->tRequest + pClient->t2Seconds;
   19d64:	6883      	ldr	r3, [r0, #8]
   19d66:	6942      	ldr	r2, [r0, #20]
   19d68:	4413      	add	r3, r2
   19d6a:	6173      	str	r3, [r6, #20]
                pDhcpInfo->dhcpAddress.Val = pClient->dhcpIPAddress.Val;
   19d6c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   19d6e:	61b3      	str	r3, [r6, #24]
                pDhcpInfo->subnetMask.Val = pClient->dhcpMask.Val;
   19d70:	6b43      	ldr	r3, [r0, #52]	; 0x34
   19d72:	61f3      	str	r3, [r6, #28]
                pDhcpInfo->serverAddress.Val = pClient->serverAddress.Val;
   19d74:	6a83      	ldr	r3, [r0, #40]	; 0x28
   19d76:	6233      	str	r3, [r6, #32]
                pDhcpInfo->bootFileName = 0;
   19d78:	2300      	movs	r3, #0
   19d7a:	6273      	str	r3, [r6, #36]	; 0x24
            return true;
   19d7c:	2001      	movs	r0, #1
   19d7e:	e7e3      	b.n	19d48 <TCPIP_DHCP_InfoGet+0x20>
    return false;
   19d80:	2000      	movs	r0, #0
   19d82:	e7e1      	b.n	19d48 <TCPIP_DHCP_InfoGet+0x20>
   19d84:	2000      	movs	r0, #0
   19d86:	e7df      	b.n	19d48 <TCPIP_DHCP_InfoGet+0x20>
            return true;
   19d88:	2001      	movs	r0, #1
   19d8a:	e7dd      	b.n	19d48 <TCPIP_DHCP_InfoGet+0x20>
    if(DHCPClients && pNetIf)
   19d8c:	4b0b      	ldr	r3, [pc, #44]	; (19dbc <TCPIP_DHCP_InfoGet+0x94>)
   19d8e:	681d      	ldr	r5, [r3, #0]
   19d90:	b185      	cbz	r5, 19db4 <TCPIP_DHCP_InfoGet+0x8c>
        DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   19d92:	4620      	mov	r0, r4
   19d94:	f00a f8d0 	bl	23f38 <TCPIP_STACK_NetIxGet>
   19d98:	235c      	movs	r3, #92	; 0x5c
   19d9a:	fb03 5000 	mla	r0, r3, r0, r5
        if(pClient->flags.bDHCPEnabled == true && pClient->smState >= TCPIP_DHCP_BOUND)
   19d9e:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   19da2:	f013 0f01 	tst.w	r3, #1
   19da6:	d0ed      	beq.n	19d84 <TCPIP_DHCP_InfoGet+0x5c>
   19da8:	f8b0 3056 	ldrh.w	r3, [r0, #86]	; 0x56
   19dac:	2b07      	cmp	r3, #7
   19dae:	d8cc      	bhi.n	19d4a <TCPIP_DHCP_InfoGet+0x22>
    return false;
   19db0:	2000      	movs	r0, #0
   19db2:	e7c9      	b.n	19d48 <TCPIP_DHCP_InfoGet+0x20>
   19db4:	2000      	movs	r0, #0
   19db6:	e7c7      	b.n	19d48 <TCPIP_DHCP_InfoGet+0x20>
   19db8:	2000ee4c 	.word	0x2000ee4c
   19dbc:	2000ee3c 	.word	0x2000ee3c

Disassembly of section .text.DisplayNodeMsg%419:

00019dc0 <DisplayNodeMsg>:
{
   19dc0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   19dc4:	b083      	sub	sp, #12
   19dc6:	4680      	mov	r8, r0
   19dc8:	468b      	mov	fp, r1
    if((nCmdLen = strlen(pNext->cmdBuff)))
   19dca:	f101 0308 	add.w	r3, r1, #8
   19dce:	9301      	str	r3, [sp, #4]
   19dd0:	4618      	mov	r0, r3
   19dd2:	f00a f875 	bl	23ec0 <strlen>
   19dd6:	2800      	cmp	r0, #0
   19dd8:	d034      	beq.n	19e44 <DisplayNodeMsg+0x84>
   19dda:	4681      	mov	r9, r0
   19ddc:	4605      	mov	r5, r0
    const SYS_CMD_API* pCmdApi = pCmdIO->devNode.pCmdApi;
   19dde:	f8d8 7000 	ldr.w	r7, [r8]
    const void* cmdIoParam = pCmdIO->devNode.cmdIoParam;
   19de2:	f8d8 6004 	ldr.w	r6, [r8, #4]
        oCmdLen = pCmdIO->cmdEnd - pCmdIO->cmdBuff;
   19de6:	f108 0a20 	add.w	sl, r8, #32
   19dea:	f8d8 401c 	ldr.w	r4, [r8, #28]
   19dee:	eba4 040a 	sub.w	r4, r4, sl
        while(oCmdLen > nCmdLen)
   19df2:	42a0      	cmp	r0, r4
   19df4:	da07      	bge.n	19e06 <DisplayNodeMsg+0x46>
            (*pCmdApi->msg)(cmdIoParam, "\b \b");     // clear the old command
   19df6:	683b      	ldr	r3, [r7, #0]
   19df8:	4914      	ldr	r1, [pc, #80]	; (19e4c <DisplayNodeMsg+0x8c>)
   19dfa:	4630      	mov	r0, r6
   19dfc:	4798      	blx	r3
            oCmdLen--;
   19dfe:	3c01      	subs	r4, #1
        while(oCmdLen > nCmdLen)
   19e00:	42a5      	cmp	r5, r4
   19e02:	d1f8      	bne.n	19df6 <DisplayNodeMsg+0x36>
   19e04:	464c      	mov	r4, r9
        while(oCmdLen--)
   19e06:	1e65      	subs	r5, r4, #1
   19e08:	b144      	cbz	r4, 19e1c <DisplayNodeMsg+0x5c>
            (*pCmdApi->msg)(cmdIoParam, "\b");
   19e0a:	4c11      	ldr	r4, [pc, #68]	; (19e50 <DisplayNodeMsg+0x90>)
   19e0c:	683b      	ldr	r3, [r7, #0]
   19e0e:	4621      	mov	r1, r4
   19e10:	4630      	mov	r0, r6
   19e12:	4798      	blx	r3
        while(oCmdLen--)
   19e14:	3d01      	subs	r5, #1
   19e16:	f1b5 3fff 	cmp.w	r5, #4294967295
   19e1a:	d1f7      	bne.n	19e0c <DisplayNodeMsg+0x4c>
        strcpy(pCmdIO->cmdBuff, pNext->cmdBuff);
   19e1c:	9901      	ldr	r1, [sp, #4]
   19e1e:	4650      	mov	r0, sl
   19e20:	f00a f846 	bl	23eb0 <strcpy>
        (*pCmdApi->msg)(cmdIoParam, "\r\n>");
   19e24:	683b      	ldr	r3, [r7, #0]
   19e26:	490b      	ldr	r1, [pc, #44]	; (19e54 <DisplayNodeMsg+0x94>)
   19e28:	4630      	mov	r0, r6
   19e2a:	4798      	blx	r3
        (*pCmdApi->msg)(cmdIoParam, pCmdIO->cmdBuff);
   19e2c:	683b      	ldr	r3, [r7, #0]
   19e2e:	4651      	mov	r1, sl
   19e30:	4630      	mov	r0, r6
   19e32:	4798      	blx	r3
        pCmdIO->cmdPnt = pCmdIO->cmdEnd = pCmdIO->cmdBuff + nCmdLen;
   19e34:	eb0a 0309 	add.w	r3, sl, r9
   19e38:	f8c8 301c 	str.w	r3, [r8, #28]
   19e3c:	f8c8 3018 	str.w	r3, [r8, #24]
        pCmdIO->currHistN = pNext;
   19e40:	f8c8 b0d4 	str.w	fp, [r8, #212]	; 0xd4
}
   19e44:	b003      	add	sp, #12
   19e46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   19e4a:	bf00      	nop
   19e4c:	0000e994 	.word	0x0000e994
   19e50:	0000e998 	.word	0x0000e998
   19e54:	0000e99c 	.word	0x0000e99c

Disassembly of section .text.prvAddCurrentTaskToDelayedList%420:

00019e58 <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
   19e58:	b570      	push	{r4, r5, r6, lr}
   19e5a:	4604      	mov	r4, r0
   19e5c:	460e      	mov	r6, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
   19e5e:	4b1d      	ldr	r3, [pc, #116]	; (19ed4 <prvAddCurrentTaskToDelayedList+0x7c>)
   19e60:	681d      	ldr	r5, [r3, #0]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   19e62:	4b1d      	ldr	r3, [pc, #116]	; (19ed8 <prvAddCurrentTaskToDelayedList+0x80>)
   19e64:	6818      	ldr	r0, [r3, #0]
   19e66:	3004      	adds	r0, #4
   19e68:	f008 fc5c 	bl	22724 <uxListRemove>
   19e6c:	b948      	cbnz	r0, 19e82 <prvAddCurrentTaskToDelayedList+0x2a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
   19e6e:	4b1a      	ldr	r3, [pc, #104]	; (19ed8 <prvAddCurrentTaskToDelayedList+0x80>)
   19e70:	681a      	ldr	r2, [r3, #0]
   19e72:	491a      	ldr	r1, [pc, #104]	; (19edc <prvAddCurrentTaskToDelayedList+0x84>)
   19e74:	680b      	ldr	r3, [r1, #0]
   19e76:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
   19e78:	2201      	movs	r2, #1
   19e7a:	4082      	lsls	r2, r0
   19e7c:	ea23 0302 	bic.w	r3, r3, r2
   19e80:	600b      	str	r3, [r1, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   19e82:	f1b4 3fff 	cmp.w	r4, #4294967295
   19e86:	d00d      	beq.n	19ea4 <prvAddCurrentTaskToDelayedList+0x4c>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
   19e88:	442c      	add	r4, r5

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   19e8a:	4b13      	ldr	r3, [pc, #76]	; (19ed8 <prvAddCurrentTaskToDelayedList+0x80>)
   19e8c:	681b      	ldr	r3, [r3, #0]
   19e8e:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
   19e90:	42a5      	cmp	r5, r4
   19e92:	d910      	bls.n	19eb6 <prvAddCurrentTaskToDelayedList+0x5e>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   19e94:	4b12      	ldr	r3, [pc, #72]	; (19ee0 <prvAddCurrentTaskToDelayedList+0x88>)
   19e96:	6818      	ldr	r0, [r3, #0]
   19e98:	4b0f      	ldr	r3, [pc, #60]	; (19ed8 <prvAddCurrentTaskToDelayedList+0x80>)
   19e9a:	6819      	ldr	r1, [r3, #0]
   19e9c:	3104      	adds	r1, #4
   19e9e:	f006 ff97 	bl	20dd0 <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   19ea2:	bd70      	pop	{r4, r5, r6, pc}
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   19ea4:	2e00      	cmp	r6, #0
   19ea6:	d0ef      	beq.n	19e88 <prvAddCurrentTaskToDelayedList+0x30>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
   19ea8:	4b0b      	ldr	r3, [pc, #44]	; (19ed8 <prvAddCurrentTaskToDelayedList+0x80>)
   19eaa:	6819      	ldr	r1, [r3, #0]
   19eac:	3104      	adds	r1, #4
   19eae:	480d      	ldr	r0, [pc, #52]	; (19ee4 <prvAddCurrentTaskToDelayedList+0x8c>)
   19eb0:	f009 fdb0 	bl	23a14 <vListInsertEnd>
   19eb4:	e7f5      	b.n	19ea2 <prvAddCurrentTaskToDelayedList+0x4a>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   19eb6:	4b0c      	ldr	r3, [pc, #48]	; (19ee8 <prvAddCurrentTaskToDelayedList+0x90>)
   19eb8:	6818      	ldr	r0, [r3, #0]
   19eba:	4b07      	ldr	r3, [pc, #28]	; (19ed8 <prvAddCurrentTaskToDelayedList+0x80>)
   19ebc:	6819      	ldr	r1, [r3, #0]
   19ebe:	3104      	adds	r1, #4
   19ec0:	f006 ff86 	bl	20dd0 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
   19ec4:	4b09      	ldr	r3, [pc, #36]	; (19eec <prvAddCurrentTaskToDelayedList+0x94>)
   19ec6:	681b      	ldr	r3, [r3, #0]
   19ec8:	42a3      	cmp	r3, r4
					xNextTaskUnblockTime = xTimeToWake;
   19eca:	bf84      	itt	hi
   19ecc:	4b07      	ldrhi	r3, [pc, #28]	; (19eec <prvAddCurrentTaskToDelayedList+0x94>)
   19ece:	601c      	strhi	r4, [r3, #0]
}
   19ed0:	e7e7      	b.n	19ea2 <prvAddCurrentTaskToDelayedList+0x4a>
   19ed2:	bf00      	nop
   19ed4:	2000ef34 	.word	0x2000ef34
   19ed8:	2000ef00 	.word	0x2000ef00
   19edc:	2000ef1c 	.word	0x2000ef1c
   19ee0:	2000ef08 	.word	0x2000ef08
   19ee4:	2000ecdc 	.word	0x2000ecdc
   19ee8:	2000ef04 	.word	0x2000ef04
   19eec:	2000ef24 	.word	0x2000ef24

Disassembly of section .text.DRV_PIC32CGMAC_LibInitTransfer%421:

00019ef0 <DRV_PIC32CGMAC_LibInitTransfer>:
	uint16_t wRxDescCnt_temp = pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxDescCnt;
   19ef0:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
   19ef4:	eb00 0343 	add.w	r3, r0, r3, lsl #1
	if (wRxDescCnt_temp < 1 || wTxDescCnt_temp < 1)
   19ef8:	f8b3 30be 	ldrh.w	r3, [r3, #190]	; 0xbe
   19efc:	2b00      	cmp	r3, #0
   19efe:	d036      	beq.n	19f6e <DRV_PIC32CGMAC_LibInitTransfer+0x7e>
	uint16_t wTxDescCnt_temp = pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt;
   19f00:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
   19f04:	eb00 0343 	add.w	r3, r0, r3, lsl #1
	if (wRxDescCnt_temp < 1 || wTxDescCnt_temp < 1)
   19f08:	f8b3 30c8 	ldrh.w	r3, [r3, #200]	; 0xc8
   19f0c:	b38b      	cbz	r3, 19f72 <DRV_PIC32CGMAC_LibInitTransfer+0x82>
	uint16_t wRxBufferSize_temp = pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].rxBufferSize;
   19f0e:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
   19f12:	eb00 0343 	add.w	r3, r0, r3, lsl #1
   19f16:	f8b3 30cc 	ldrh.w	r3, [r3, #204]	; 0xcc
	if (wRxBufferSize_temp < DRV_GMAC_MIN_RX_SIZE)
   19f1a:	2b3f      	cmp	r3, #63	; 0x3f
   19f1c:	d92b      	bls.n	19f76 <DRV_PIC32CGMAC_LibInitTransfer+0x86>
    if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].queueRxEnable == true)
   19f1e:	eb01 02c1 	add.w	r2, r1, r1, lsl #3
   19f22:	eb00 0242 	add.w	r2, r0, r2, lsl #1
   19f26:	f892 20cf 	ldrb.w	r2, [r2, #207]	; 0xcf
        queIntEnable = GMAC_INT_RX_BITS;
   19f2a:	2a01      	cmp	r2, #1
   19f2c:	f240 4206 	movw	r2, #1030	; 0x406
   19f30:	bf18      	it	ne
   19f32:	2200      	movne	r2, #0
    if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].queueTxEnable == true)
   19f34:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
   19f38:	eb00 0141 	add.w	r1, r0, r1, lsl #1
   19f3c:	f891 10ce 	ldrb.w	r1, [r1, #206]	; 0xce
   19f40:	2901      	cmp	r1, #1
        queIntEnable |= GMAC_INT_TX_BITS;
   19f42:	bf08      	it	eq
   19f44:	f442 6207 	orreq.w	r2, r2, #2160	; 0x870
	GMAC_REGS->GMAC_DCFGR = GMAC_DCFGR_DRBS((wRxBufferSize_temp >> 6)) | GMAC_DCFGR_RXBMS(3) | GMAC_DCFGR_TXPBMS(1) | GMAC_DCFGR_FBLDO(4) | GMAC_DCFGR_DDRP(1);
   19f48:	029b      	lsls	r3, r3, #10
   19f4a:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
   19f4e:	490b      	ldr	r1, [pc, #44]	; (19f7c <DRV_PIC32CGMAC_LibInitTransfer+0x8c>)
   19f50:	4319      	orrs	r1, r3
   19f52:	4b0b      	ldr	r3, [pc, #44]	; (19f80 <DRV_PIC32CGMAC_LibInitTransfer+0x90>)
   19f54:	6119      	str	r1, [r3, #16]
	if((pMACDrv->sGmacData.gmacConfig.checksumOffloadTx) != TCPIP_MAC_CHECKSUM_NONE)
   19f56:	f890 30e1 	ldrb.w	r3, [r0, #225]	; 0xe1
   19f5a:	b123      	cbz	r3, 19f66 <DRV_PIC32CGMAC_LibInitTransfer+0x76>
        GMAC_REGS->GMAC_DCFGR |= GMAC_DCFGR_TXCOEN_Msk;
   19f5c:	4908      	ldr	r1, [pc, #32]	; (19f80 <DRV_PIC32CGMAC_LibInitTransfer+0x90>)
   19f5e:	690b      	ldr	r3, [r1, #16]
   19f60:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   19f64:	610b      	str	r3, [r1, #16]
	GMAC_REGS->GMAC_IER = queIntEnable;
   19f66:	4b06      	ldr	r3, [pc, #24]	; (19f80 <DRV_PIC32CGMAC_LibInitTransfer+0x90>)
   19f68:	629a      	str	r2, [r3, #40]	; 0x28
	return DRV_PIC32CGMAC_RES_OK;
   19f6a:	2000      	movs	r0, #0
   19f6c:	4770      	bx	lr
        return DRV_PIC32CGMAC_RES_DESC_CNT_ERR;
   19f6e:	2006      	movs	r0, #6
   19f70:	4770      	bx	lr
   19f72:	2006      	movs	r0, #6
   19f74:	4770      	bx	lr
        return DRV_PIC32CGMAC_RES_RX_SIZE_ERR;
   19f76:	f06f 0002 	mvn.w	r0, #2
}
   19f7a:	4770      	bx	lr
   19f7c:	01000704 	.word	0x01000704
   19f80:	42000800 	.word	0x42000800

Disassembly of section .text.TCPIP_ARP_IsResolved%422:

00019f84 <TCPIP_ARP_IsResolved>:
    if(IPAddr == 0 || IPAddr->Val == 0)
   19f84:	2900      	cmp	r1, #0
   19f86:	d03c      	beq.n	1a002 <TCPIP_ARP_IsResolved+0x7e>
{
   19f88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   19f8a:	460c      	mov	r4, r1
    if(IPAddr == 0 || IPAddr->Val == 0)
   19f8c:	6809      	ldr	r1, [r1, #0]
   19f8e:	2900      	cmp	r1, #0
   19f90:	d039      	beq.n	1a006 <TCPIP_ARP_IsResolved+0x82>
   19f92:	2800      	cmp	r0, #0
   19f94:	d039      	beq.n	1a00a <TCPIP_ARP_IsResolved+0x86>
   19f96:	f890 1042 	ldrb.w	r1, [r0, #66]	; 0x42
   19f9a:	f011 0f40 	tst.w	r1, #64	; 0x40
   19f9e:	d101      	bne.n	19fa4 <TCPIP_ARP_IsResolved+0x20>
        return false;
   19fa0:	2000      	movs	r0, #0
   19fa2:	e031      	b.n	1a008 <TCPIP_ARP_IsResolved+0x84>
   19fa4:	4615      	mov	r5, r2
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   19fa6:	4b1b      	ldr	r3, [pc, #108]	; (1a014 <TCPIP_ARP_IsResolved+0x90>)
   19fa8:	685e      	ldr	r6, [r3, #4]
   19faa:	f009 ffc5 	bl	23f38 <TCPIP_STACK_NetIxGet>
   19fae:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   19fb2:	00c0      	lsls	r0, r0, #3
   19fb4:	1837      	adds	r7, r6, r0
    hE = TCPIP_OAHASH_EntryLookup(pArpDcpt->hashDcpt, &IPAddr->Val);
   19fb6:	4621      	mov	r1, r4
   19fb8:	5830      	ldr	r0, [r6, r0]
   19fba:	f002 fce3 	bl	1c984 <TCPIP_OAHASH_EntryLookup>
    if(hE != 0 && (hE->flags.value & ARP_FLAG_ENTRY_VALID_MASK) != 0 )
   19fbe:	4604      	mov	r4, r0
   19fc0:	b328      	cbz	r0, 1a00e <TCPIP_ARP_IsResolved+0x8a>
   19fc2:	8803      	ldrh	r3, [r0, #0]
   19fc4:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   19fc8:	b90b      	cbnz	r3, 19fce <TCPIP_ARP_IsResolved+0x4a>
    return false;
   19fca:	2000      	movs	r0, #0
   19fcc:	e01c      	b.n	1a008 <TCPIP_ARP_IsResolved+0x84>
        if(MACAddr)
   19fce:	b11d      	cbz	r5, 19fd8 <TCPIP_ARP_IsResolved+0x54>
            *MACAddr = arpHE->hwAdd;
   19fd0:	6900      	ldr	r0, [r0, #16]
   19fd2:	6028      	str	r0, [r5, #0]
   19fd4:	8aa3      	ldrh	r3, [r4, #20]
   19fd6:	80ab      	strh	r3, [r5, #4]
        if((hE->flags.value & ARP_FLAG_ENTRY_COMPLETE) != 0 )
   19fd8:	8823      	ldrh	r3, [r4, #0]
   19fda:	f013 0f80 	tst.w	r3, #128	; 0x80
   19fde:	d101      	bne.n	19fe4 <TCPIP_ARP_IsResolved+0x60>
        return true;
   19fe0:	2001      	movs	r0, #1
   19fe2:	e011      	b.n	1a008 <TCPIP_ARP_IsResolved+0x84>
            _ARPRefreshEntry(arpHE, &pArpDcpt->completeList);
   19fe4:	3718      	adds	r7, #24
    TCPIP_Helper_ProtectedSingleListNodeRemove(pL, (SGL_LIST_NODE*)&arpHE->next);
   19fe6:	1d25      	adds	r5, r4, #4
   19fe8:	4629      	mov	r1, r5
   19fea:	4638      	mov	r0, r7
   19fec:	f007 f98e 	bl	2130c <TCPIP_Helper_ProtectedSingleListNodeRemove>
    arpHE->tInsert = arpMod.timeSeconds;
   19ff0:	4b08      	ldr	r3, [pc, #32]	; (1a014 <TCPIP_ARP_IsResolved+0x90>)
   19ff2:	695b      	ldr	r3, [r3, #20]
   19ff4:	60e3      	str	r3, [r4, #12]
    TCPIP_Helper_ProtectedSingleListTailAdd(pL, (SGL_LIST_NODE*)&arpHE->next);
   19ff6:	4629      	mov	r1, r5
   19ff8:	4638      	mov	r0, r7
   19ffa:	f007 feb0 	bl	21d5e <TCPIP_Helper_ProtectedSingleListTailAdd>
        return true;
   19ffe:	2001      	movs	r0, #1
   1a000:	e002      	b.n	1a008 <TCPIP_ARP_IsResolved+0x84>
        return false;
   1a002:	2000      	movs	r0, #0
}
   1a004:	4770      	bx	lr
        return false;
   1a006:	2000      	movs	r0, #0
}
   1a008:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return false;
   1a00a:	2000      	movs	r0, #0
   1a00c:	e7fc      	b.n	1a008 <TCPIP_ARP_IsResolved+0x84>
    return false;
   1a00e:	2000      	movs	r0, #0
   1a010:	e7fa      	b.n	1a008 <TCPIP_ARP_IsResolved+0x84>
   1a012:	bf00      	nop
   1a014:	2000e974 	.word	0x2000e974

Disassembly of section .text.ascii_to_u32s%423:

0001a018 <ascii_to_u32s>:
    if(ptr == 0)
   1a018:	b1f8      	cbz	r0, 1a05a <ascii_to_u32s+0x42>
{
   1a01a:	b4f0      	push	{r4, r5, r6, r7}
   1a01c:	4604      	mov	r4, r0
    for (i = 0; i < count; i++)
   1a01e:	b1d2      	cbz	r2, 1a056 <ascii_to_u32s+0x3e>
   1a020:	1f0d      	subs	r5, r1, #4
   1a022:	3a01      	subs	r2, #1
   1a024:	b2d2      	uxtb	r2, r2
   1a026:	eb01 0182 	add.w	r1, r1, r2, lsl #2
            tmp = tmp * 1000 * 1000;
   1a02a:	4f1f      	ldr	r7, [pc, #124]	; (1a0a8 <ascii_to_u32s+0x90>)
            tmp = tmp * 1000;
   1a02c:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
        while ( (*ptr > (int8_t)'9') || (*ptr < (int8_t)'0') )
   1a030:	7822      	ldrb	r2, [r4, #0]
   1a032:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
   1a036:	b2db      	uxtb	r3, r3
   1a038:	2b09      	cmp	r3, #9
   1a03a:	d931      	bls.n	1a0a0 <ascii_to_u32s+0x88>
            if ( (*ptr == (int8_t)' ') || (*ptr == (int8_t)0) ) return; // terminates at blank or NULL.
   1a03c:	f012 0fdf 	tst.w	r2, #223	; 0xdf
   1a040:	d009      	beq.n	1a056 <ascii_to_u32s+0x3e>
        while ( (*ptr > (int8_t)'9') || (*ptr < (int8_t)'0') )
   1a042:	f814 2f01 	ldrb.w	r2, [r4, #1]!
   1a046:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
   1a04a:	b2db      	uxtb	r3, r3
   1a04c:	2b09      	cmp	r3, #9
   1a04e:	d927      	bls.n	1a0a0 <ascii_to_u32s+0x88>
            if ( (*ptr == (int8_t)' ') || (*ptr == (int8_t)0) ) return; // terminates at blank or NULL.
   1a050:	f012 0fdf 	tst.w	r2, #223	; 0xdf
   1a054:	d1f5      	bne.n	1a042 <ascii_to_u32s+0x2a>
}
   1a056:	bcf0      	pop	{r4, r5, r6, r7}
   1a058:	4770      	bx	lr
        *values = 0;
   1a05a:	2300      	movs	r3, #0
   1a05c:	600b      	str	r3, [r1, #0]
        return;
   1a05e:	4770      	bx	lr
            ptr++;
   1a060:	4664      	mov	r4, ip
            tmp = tmp*10 + *ptr - '0';
   1a062:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   1a066:	eb02 0343 	add.w	r3, r2, r3, lsl #1
   1a06a:	3b30      	subs	r3, #48	; 0x30
            ptr++;
   1a06c:	f104 0c01 	add.w	ip, r4, #1
        while ( (*ptr <= (int8_t)'9') && (*ptr >= (int8_t)'0') )
   1a070:	7862      	ldrb	r2, [r4, #1]
   1a072:	f1a2 0030 	sub.w	r0, r2, #48	; 0x30
   1a076:	b2c0      	uxtb	r0, r0
   1a078:	2809      	cmp	r0, #9
   1a07a:	d9f1      	bls.n	1a060 <ascii_to_u32s+0x48>
        if ( (*ptr == (int8_t)'k') || (*ptr == (int8_t)'K') )
   1a07c:	f002 02df 	and.w	r2, r2, #223	; 0xdf
   1a080:	2a4b      	cmp	r2, #75	; 0x4b
   1a082:	d005      	beq.n	1a090 <ascii_to_u32s+0x78>
        else if ( (*ptr == (int8_t)'m') || (*ptr == (int8_t)'M') )
   1a084:	2a4d      	cmp	r2, #77	; 0x4d
            tmp = tmp * 1000 * 1000;
   1a086:	bf06      	itte	eq
   1a088:	437b      	muleq	r3, r7
            ptr++;
   1a08a:	3402      	addeq	r4, #2
            ptr++;
   1a08c:	4664      	movne	r4, ip
   1a08e:	e002      	b.n	1a096 <ascii_to_u32s+0x7e>
            tmp = tmp * 1000;
   1a090:	fb06 f303 	mul.w	r3, r6, r3
            ptr++;
   1a094:	3402      	adds	r4, #2
        values[i] = tmp;
   1a096:	f845 3f04 	str.w	r3, [r5, #4]!
    for (i = 0; i < count; i++)
   1a09a:	428d      	cmp	r5, r1
   1a09c:	d1c8      	bne.n	1a030 <ascii_to_u32s+0x18>
   1a09e:	e7da      	b.n	1a056 <ascii_to_u32s+0x3e>
        while ( (*ptr <= (int8_t)'9') && (*ptr >= (int8_t)'0') )
   1a0a0:	7822      	ldrb	r2, [r4, #0]
        tmp = 0;
   1a0a2:	2300      	movs	r3, #0
   1a0a4:	e7dd      	b.n	1a062 <ascii_to_u32s+0x4a>
   1a0a6:	bf00      	nop
   1a0a8:	000f4240 	.word	0x000f4240

Disassembly of section .text.DRV_MIIM_OperationResult%424:

0001a0ac <DRV_MIIM_OperationResult>:
{
   1a0ac:	b570      	push	{r4, r5, r6, lr}
   1a0ae:	460c      	mov	r4, r1
   1a0b0:	4616      	mov	r6, r2
        if((pClient = _DRV_MIIM_GetClientAndLock(handle, true)) == 0)
   1a0b2:	2101      	movs	r1, #1
   1a0b4:	f004 fad1 	bl	1e65a <_DRV_MIIM_GetClientAndLock>
   1a0b8:	b1f0      	cbz	r0, 1a0f8 <DRV_MIIM_OperationResult+0x4c>
   1a0ba:	4602      	mov	r2, r0
        pMiimObj = pClient->parentObj;
   1a0bc:	6845      	ldr	r5, [r0, #4]
    if(pOpDcpt != 0 && (pOpDcpt->qType == DRV_MIIM_QTYPE_BUSY || pOpDcpt->qType == DRV_MIIM_QTYPE_COMPLETE))
   1a0be:	b1c4      	cbz	r4, 1a0f2 <DRV_MIIM_OperationResult+0x46>
   1a0c0:	7ae3      	ldrb	r3, [r4, #11]
   1a0c2:	3b02      	subs	r3, #2
   1a0c4:	b2db      	uxtb	r3, r3
   1a0c6:	2b01      	cmp	r3, #1
   1a0c8:	d919      	bls.n	1a0fe <DRV_MIIM_OperationResult+0x52>
            miimRes = DRV_MIIM_RES_OP_HANDLE_ERR;
   1a0ca:	f06f 0601 	mvn.w	r6, #1
    if(pMiimObj != 0)
   1a0ce:	b115      	cbz	r5, 1a0d6 <DRV_MIIM_OperationResult+0x2a>
    OSAL_SEM_Post(&pMiimObj->objSem);
   1a0d0:	4628      	mov	r0, r5
   1a0d2:	f009 fb5b 	bl	2378c <OSAL_SEM_Post>
}
   1a0d6:	4630      	mov	r0, r6
   1a0d8:	bd70      	pop	{r4, r5, r6, pc}
        if(scanAck && pOpDcpt->opStat == DRV_MIIM_TXFER_SCAN_VALID)
   1a0da:	2b04      	cmp	r3, #4
   1a0dc:	d001      	beq.n	1a0e2 <DRV_MIIM_OperationResult+0x36>
        return DRV_MIIM_RES_OK;
   1a0de:	2600      	movs	r6, #0
   1a0e0:	e004      	b.n	1a0ec <DRV_MIIM_OperationResult+0x40>
            pOpDcpt->opStat = DRV_MIIM_TXFER_SCAN_STALE;
   1a0e2:	2303      	movs	r3, #3
   1a0e4:	72a3      	strb	r3, [r4, #10]
        return DRV_MIIM_RES_OK;
   1a0e6:	2600      	movs	r6, #0
   1a0e8:	e7f1      	b.n	1a0ce <DRV_MIIM_OperationResult+0x22>
        return DRV_MIIM_RES_PENDING;
   1a0ea:	2601      	movs	r6, #1
        if(pOpDcpt->opStat >= DRV_MIIM_TXFER_DONE)
   1a0ec:	2b04      	cmp	r3, #4
   1a0ee:	d9ee      	bls.n	1a0ce <DRV_MIIM_OperationResult+0x22>
   1a0f0:	e01c      	b.n	1a12c <DRV_MIIM_OperationResult+0x80>
            miimRes = DRV_MIIM_RES_OP_HANDLE_ERR;
   1a0f2:	f06f 0601 	mvn.w	r6, #1
   1a0f6:	e7ea      	b.n	1a0ce <DRV_MIIM_OperationResult+0x22>
            miimRes = DRV_MIIM_RES_HANDLE_ERR;
   1a0f8:	f04f 36ff 	mov.w	r6, #4294967295
    return miimRes;
   1a0fc:	e7eb      	b.n	1a0d6 <DRV_MIIM_OperationResult+0x2a>
        if(pOpData != 0)
   1a0fe:	b136      	cbz	r6, 1a10e <DRV_MIIM_OperationResult+0x62>
            if(DRV_MIIM_TXFER_SCAN_STALE <= pOpDcpt->opStat &&  pOpDcpt->opStat <= DRV_MIIM_TXFER_DONE)
   1a100:	7aa3      	ldrb	r3, [r4, #10]
   1a102:	3b03      	subs	r3, #3
   1a104:	b2db      	uxtb	r3, r3
   1a106:	2b02      	cmp	r3, #2
                *pOpData = pOpDcpt->opData;
   1a108:	bf9c      	itt	ls
   1a10a:	8923      	ldrhls	r3, [r4, #8]
   1a10c:	8033      	strhls	r3, [r6, #0]
    if(DRV_MIIM_TXFER_START <= pOpDcpt->opStat &&  pOpDcpt->opStat < DRV_MIIM_TXFER_SCAN_VALID)
   1a10e:	7aa3      	ldrb	r3, [r4, #10]
   1a110:	1e59      	subs	r1, r3, #1
   1a112:	b2c9      	uxtb	r1, r1
   1a114:	2902      	cmp	r1, #2
   1a116:	d9e8      	bls.n	1a0ea <DRV_MIIM_OperationResult+0x3e>
    else if(pOpDcpt->opStat <= DRV_MIIM_TXFER_DONE)
   1a118:	2b05      	cmp	r3, #5
   1a11a:	d9de      	bls.n	1a0da <DRV_MIIM_OperationResult+0x2e>
    else if(pOpDcpt->opStat == DRV_MIIM_TXFER_TMO_START || pOpDcpt->opStat == DRV_MIIM_TXFER_TMO_END)
   1a11c:	3b06      	subs	r3, #6
   1a11e:	b2db      	uxtb	r3, r3
        return DRV_MIIM_RES_OP_TIMEOUT_ERR;
   1a120:	2b01      	cmp	r3, #1
   1a122:	bf8c      	ite	hi
   1a124:	f06f 0613 	mvnhi.w	r6, #19
   1a128:	f06f 0608 	mvnls.w	r6, #8
            _DRV_MIIM_ReleaseOpDcpt(pMiimObj, pOpDcpt,  &pClient->parentObj->completeOpList, DRV_MIIM_QTYPE_COMPLETE);
   1a12c:	6852      	ldr	r2, [r2, #4]
   1a12e:	2303      	movs	r3, #3
   1a130:	3288      	adds	r2, #136	; 0x88
   1a132:	4621      	mov	r1, r4
   1a134:	4628      	mov	r0, r5
   1a136:	f006 f99f 	bl	20478 <_DRV_MIIM_ReleaseOpDcpt>
   1a13a:	e7c8      	b.n	1a0ce <DRV_MIIM_OperationResult+0x22>

Disassembly of section .text._DHCPCleanup%425:

0001a13c <_DHCPCleanup>:
{
   1a13c:	b570      	push	{r4, r5, r6, lr}
    if(dhcpClientSocket != INVALID_UDP_SOCKET)
   1a13e:	4b1d      	ldr	r3, [pc, #116]	; (1a1b4 <_DHCPCleanup+0x78>)
   1a140:	f9b3 0000 	ldrsh.w	r0, [r3]
   1a144:	f1b0 3fff 	cmp.w	r0, #4294967295
   1a148:	d109      	bne.n	1a15e <_DHCPCleanup+0x22>
    if(DHCPClients != 0)
   1a14a:	4b1b      	ldr	r3, [pc, #108]	; (1a1b8 <_DHCPCleanup+0x7c>)
   1a14c:	681c      	ldr	r4, [r3, #0]
   1a14e:	b304      	cbz	r4, 1a192 <_DHCPCleanup+0x56>
        for(ix = 0; ix < dhcpInterfaces; ix++, pClient++)
   1a150:	4b1a      	ldr	r3, [pc, #104]	; (1a1bc <_DHCPCleanup+0x80>)
   1a152:	681b      	ldr	r3, [r3, #0]
   1a154:	2b00      	cmp	r3, #0
   1a156:	dd14      	ble.n	1a182 <_DHCPCleanup+0x46>
   1a158:	2500      	movs	r5, #0
   1a15a:	4e18      	ldr	r6, [pc, #96]	; (1a1bc <_DHCPCleanup+0x80>)
   1a15c:	e00d      	b.n	1a17a <_DHCPCleanup+0x3e>
        TCPIP_UDP_Close(dhcpClientSocket);
   1a15e:	f007 f91d 	bl	2139c <TCPIP_UDP_Close>
        dhcpClientSocket = INVALID_UDP_SOCKET;
   1a162:	4b14      	ldr	r3, [pc, #80]	; (1a1b4 <_DHCPCleanup+0x78>)
   1a164:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1a168:	801a      	strh	r2, [r3, #0]
   1a16a:	e7ee      	b.n	1a14a <_DHCPCleanup+0xe>
                Ipv4DeRegisterFilter(pClient->dhcpFilterHandle);
   1a16c:	f007 ff26 	bl	21fbc <Ipv4DeRegisterFilter>
        for(ix = 0; ix < dhcpInterfaces; ix++, pClient++)
   1a170:	3501      	adds	r5, #1
   1a172:	345c      	adds	r4, #92	; 0x5c
   1a174:	6833      	ldr	r3, [r6, #0]
   1a176:	42ab      	cmp	r3, r5
   1a178:	dd03      	ble.n	1a182 <_DHCPCleanup+0x46>
            if(pClient->dhcpFilterHandle != 0)
   1a17a:	6ca0      	ldr	r0, [r4, #72]	; 0x48
   1a17c:	2800      	cmp	r0, #0
   1a17e:	d1f5      	bne.n	1a16c <_DHCPCleanup+0x30>
   1a180:	e7f6      	b.n	1a170 <_DHCPCleanup+0x34>
        TCPIP_HEAP_Free(dhcpMemH, DHCPClients);
   1a182:	4b0f      	ldr	r3, [pc, #60]	; (1a1c0 <_DHCPCleanup+0x84>)
   1a184:	6818      	ldr	r0, [r3, #0]
   1a186:	4c0c      	ldr	r4, [pc, #48]	; (1a1b8 <_DHCPCleanup+0x7c>)
   1a188:	68c3      	ldr	r3, [r0, #12]
   1a18a:	6821      	ldr	r1, [r4, #0]
   1a18c:	4798      	blx	r3
        DHCPClients = 0;
   1a18e:	2300      	movs	r3, #0
   1a190:	6023      	str	r3, [r4, #0]
    TCPIP_Notification_Deinitialize(&dhcpRegisteredUsers, dhcpMemH);
   1a192:	4b0b      	ldr	r3, [pc, #44]	; (1a1c0 <_DHCPCleanup+0x84>)
   1a194:	6819      	ldr	r1, [r3, #0]
   1a196:	480b      	ldr	r0, [pc, #44]	; (1a1c4 <_DHCPCleanup+0x88>)
   1a198:	f009 fdfa 	bl	23d90 <TCPIP_Notification_Deinitialize>
    if(dhcpSignalHandle)
   1a19c:	4b0a      	ldr	r3, [pc, #40]	; (1a1c8 <_DHCPCleanup+0x8c>)
   1a19e:	6818      	ldr	r0, [r3, #0]
   1a1a0:	b120      	cbz	r0, 1a1ac <_DHCPCleanup+0x70>
        _TCPIPStackSignalHandlerDeregister(dhcpSignalHandle);
   1a1a2:	f009 fed0 	bl	23f46 <_TCPIPStackSignalHandlerDeregister>
        dhcpSignalHandle = 0;
   1a1a6:	4b08      	ldr	r3, [pc, #32]	; (1a1c8 <_DHCPCleanup+0x8c>)
   1a1a8:	2200      	movs	r2, #0
   1a1aa:	601a      	str	r2, [r3, #0]
    dhcpInterfaces = 0;
   1a1ac:	4b03      	ldr	r3, [pc, #12]	; (1a1bc <_DHCPCleanup+0x80>)
   1a1ae:	2200      	movs	r2, #0
   1a1b0:	601a      	str	r2, [r3, #0]
}
   1a1b2:	bd70      	pop	{r4, r5, r6, pc}
   1a1b4:	2000ef7e 	.word	0x2000ef7e
   1a1b8:	2000ee3c 	.word	0x2000ee3c
   1a1bc:	2000ee44 	.word	0x2000ee44
   1a1c0:	2000ee48 	.word	0x2000ee48
   1a1c4:	2000ec64 	.word	0x2000ec64
   1a1c8:	2000ee50 	.word	0x2000ee50

Disassembly of section .text._TCPIPStackModuleRxPurge%426:

0001a1cc <_TCPIPStackModuleRxPurge>:
}

// purges the packets from a module RX queue
// belonging to the pNetIf
void _TCPIPStackModuleRxPurge(TCPIP_STACK_MODULE modId, TCPIP_NET_IF* pNetIf)
{
   1a1cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1a1d0:	b086      	sub	sp, #24
   1a1d2:	4688      	mov	r8, r1
    TCPIP_MAC_PACKET* pRxPkt;
    SINGLE_LIST       remList = { 0 };  // list of packets to remove/ack
   1a1d4:	2300      	movs	r3, #0
   1a1d6:	9303      	str	r3, [sp, #12]
   1a1d8:	9304      	str	r3, [sp, #16]
   1a1da:	9305      	str	r3, [sp, #20]
    SINGLE_LIST       keepList = { 0 };  // list of packets to keep
   1a1dc:	9300      	str	r3, [sp, #0]
   1a1de:	9301      	str	r3, [sp, #4]
   1a1e0:	9302      	str	r3, [sp, #8]

    SINGLE_LIST*      pRxQueue = (TCPIP_MODULES_QUEUE_TBL + modId); // list to extract from
   1a1e2:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   1a1e6:	4f1c      	ldr	r7, [pc, #112]	; (1a258 <_TCPIPStackModuleRxPurge+0x8c>)
   1a1e8:	eb07 0780 	add.w	r7, r7, r0, lsl #2
    
    // kill the list
    while(true)
    {
        OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1a1ec:	461d      	mov	r5, r3
   1a1ee:	4628      	mov	r0, r5
   1a1f0:	f009 fac0 	bl	23774 <OSAL_CRIT_Enter>
   1a1f4:	4606      	mov	r6, r0
        pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(pRxQueue);
   1a1f6:	4638      	mov	r0, r7
   1a1f8:	f008 ff36 	bl	23068 <TCPIP_Helper_SingleListHeadRemove>
   1a1fc:	4604      	mov	r4, r0
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1a1fe:	4631      	mov	r1, r6
   1a200:	4628      	mov	r0, r5
   1a202:	f009 fbf1 	bl	239e8 <OSAL_CRIT_Leave>
        if(pRxPkt == 0)
   1a206:	b144      	cbz	r4, 1a21a <_TCPIPStackModuleRxPurge+0x4e>
        {
            break;
        }


        if(pRxPkt->pktIf == pNetIf)
   1a208:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1a20a:	4543      	cmp	r3, r8
        {   // need to remove
            TCPIP_Helper_SingleListTailAdd(&remList, (SGL_LIST_NODE*)pRxPkt);
   1a20c:	4621      	mov	r1, r4
   1a20e:	bf0c      	ite	eq
   1a210:	a803      	addeq	r0, sp, #12
        }
        else
        {   // need to keep
            TCPIP_Helper_SingleListTailAdd(&keepList, (SGL_LIST_NODE*)pRxPkt);
   1a212:	4668      	movne	r0, sp
   1a214:	f009 f90a 	bl	2342c <TCPIP_Helper_SingleListTailAdd>
   1a218:	e7e9      	b.n	1a1ee <_TCPIPStackModuleRxPurge+0x22>
    }

    // acknowledge the removed packets
    while((pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(&remList)) != 0)
    {
        TCPIP_PKT_PacketAcknowledge(pRxPkt, TCPIP_MAC_PKT_ACK_SOURCE_ERR);
   1a21a:	2501      	movs	r5, #1
   1a21c:	f06f 040a 	mvn.w	r4, #10
   1a220:	e004      	b.n	1a22c <_TCPIPStackModuleRxPurge+0x60>
   1a222:	462a      	mov	r2, r5
   1a224:	4621      	mov	r1, r4
   1a226:	4618      	mov	r0, r3
   1a228:	f005 fc3c 	bl	1faa4 <_TCPIP_PKT_PacketAcknowledge>
    while((pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(&remList)) != 0)
   1a22c:	a803      	add	r0, sp, #12
   1a22e:	f008 ff1b 	bl	23068 <TCPIP_Helper_SingleListHeadRemove>
   1a232:	4603      	mov	r3, r0
   1a234:	2800      	cmp	r0, #0
   1a236:	d1f4      	bne.n	1a222 <_TCPIPStackModuleRxPurge+0x56>
    }

    if(!TCPIP_Helper_SingleListIsEmpty(&keepList))
   1a238:	9b00      	ldr	r3, [sp, #0]
   1a23a:	b153      	cbz	r3, 1a252 <_TCPIPStackModuleRxPurge+0x86>
    {   // replace the remaining packets
        OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1a23c:	f009 fa9a 	bl	23774 <OSAL_CRIT_Enter>
   1a240:	4604      	mov	r4, r0
        TCPIP_Helper_SingleListAppend(pRxQueue, &keepList);
   1a242:	4669      	mov	r1, sp
   1a244:	4638      	mov	r0, r7
   1a246:	f009 f8fe 	bl	23446 <TCPIP_Helper_SingleListAppend>
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1a24a:	4621      	mov	r1, r4
   1a24c:	2000      	movs	r0, #0
   1a24e:	f009 fbcb 	bl	239e8 <OSAL_CRIT_Leave>
    }

}
   1a252:	b006      	add	sp, #24
   1a254:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1a258:	2000e654 	.word	0x2000e654

Disassembly of section .text.DHCPSgetFreeHashIndex%427:

0001a25c <DHCPSgetFreeHashIndex>:
{
   1a25c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1a260:	b083      	sub	sp, #12
   1a262:	4606      	mov	r6, r0
   1a264:	4690      	mov	r8, r2
    probeStep = pOH->probeStep;
   1a266:	f8d0 9010 	ldr.w	r9, [r0, #16]
    if(ipAddrExists != NULL) 
   1a26a:	b14b      	cbz	r3, 1a280 <DHCPSgetFreeHashIndex+0x24>
        if(ipAddrExists->Val != 0)
   1a26c:	681f      	ldr	r7, [r3, #0]
   1a26e:	b147      	cbz	r7, 1a282 <DHCPSgetFreeHashIndex+0x26>
            bktIx = reqIP.v[3] ^ ipAddr->v[3];
   1a270:	f898 4003 	ldrb.w	r4, [r8, #3]
   1a274:	ea84 6417 	eor.w	r4, r4, r7, lsr #24
    if((bktIx ==0xFFFFFFFF)||(bktIx >  pOH->hEntries))
   1a278:	68c3      	ldr	r3, [r0, #12]
   1a27a:	42a3      	cmp	r3, r4
   1a27c:	d205      	bcs.n	1a28a <DHCPSgetFreeHashIndex+0x2e>
   1a27e:	e000      	b.n	1a282 <DHCPSgetFreeHashIndex+0x26>
        reqIP.Val = 0;
   1a280:	2700      	movs	r7, #0
        bktIx = TCPIP_DHCPS_MACHashKeyHash(pOH,key);
   1a282:	4630      	mov	r0, r6
   1a284:	f009 fa6a 	bl	2375c <TCPIP_DHCPS_MACHashKeyHash>
   1a288:	4604      	mov	r4, r0
    while(bkts < pOH->hEntries)
   1a28a:	68f3      	ldr	r3, [r6, #12]
   1a28c:	b35b      	cbz	r3, 1a2e6 <DHCPSgetFreeHashIndex+0x8a>
   1a28e:	2500      	movs	r5, #0
   1a290:	e00b      	b.n	1a2aa <DHCPSgetFreeHashIndex+0x4e>
            if((pBkt->flags.busy == 0) &&(DHCPSLocateRequestedIpAddress((IPV4_ADDR*)&dw.Val)==DHCPS_RES_NO_ENTRY))
   1a292:	7803      	ldrb	r3, [r0, #0]
   1a294:	f013 0f01 	tst.w	r3, #1
   1a298:	d018      	beq.n	1a2cc <DHCPSgetFreeHashIndex+0x70>
        bktIx += probeStep;
   1a29a:	444c      	add	r4, r9
        if(bktIx >= pOH->hEntries)
   1a29c:	68f3      	ldr	r3, [r6, #12]
   1a29e:	42a3      	cmp	r3, r4
            bktIx -= pOH->hEntries;
   1a2a0:	bf98      	it	ls
   1a2a2:	1ae4      	subls	r4, r4, r3
        bkts++;
   1a2a4:	3501      	adds	r5, #1
    while(bkts < pOH->hEntries)
   1a2a6:	42ab      	cmp	r3, r5
   1a2a8:	d917      	bls.n	1a2da <DHCPSgetFreeHashIndex+0x7e>
        pBkt = TCPIP_OAHASH_EntryGet(pOH, bktIx);
   1a2aa:	4621      	mov	r1, r4
   1a2ac:	4630      	mov	r0, r6
   1a2ae:	f009 fcd4 	bl	23c5a <TCPIP_OAHASH_EntryGet>
        dw.Val = ipAddr->Val;
   1a2b2:	f8d8 3000 	ldr.w	r3, [r8]
   1a2b6:	9301      	str	r3, [sp, #4]
        dw.v[3] |= bktIx;
   1a2b8:	ea44 6313 	orr.w	r3, r4, r3, lsr #24
   1a2bc:	f88d 3007 	strb.w	r3, [sp, #7]
        if((reqIP.Val == 0) || (reqIP.Val != dw.Val))
   1a2c0:	2f00      	cmp	r7, #0
   1a2c2:	d0e6      	beq.n	1a292 <DHCPSgetFreeHashIndex+0x36>
   1a2c4:	9b01      	ldr	r3, [sp, #4]
   1a2c6:	42bb      	cmp	r3, r7
   1a2c8:	d1e3      	bne.n	1a292 <DHCPSgetFreeHashIndex+0x36>
   1a2ca:	e7e6      	b.n	1a29a <DHCPSgetFreeHashIndex+0x3e>
            if((pBkt->flags.busy == 0) &&(DHCPSLocateRequestedIpAddress((IPV4_ADDR*)&dw.Val)==DHCPS_RES_NO_ENTRY))
   1a2cc:	a801      	add	r0, sp, #4
   1a2ce:	f003 fe49 	bl	1df64 <DHCPSLocateRequestedIpAddress>
   1a2d2:	f1b0 3fff 	cmp.w	r0, #4294967295
   1a2d6:	d1e0      	bne.n	1a29a <DHCPSgetFreeHashIndex+0x3e>
   1a2d8:	e001      	b.n	1a2de <DHCPSgetFreeHashIndex+0x82>
    return -1;	// cache full, not found
   1a2da:	f04f 34ff 	mov.w	r4, #4294967295
}
   1a2de:	4620      	mov	r0, r4
   1a2e0:	b003      	add	sp, #12
   1a2e2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return -1;	// cache full, not found
   1a2e6:	f04f 34ff 	mov.w	r4, #4294967295
   1a2ea:	e7f8      	b.n	1a2de <DHCPSgetFreeHashIndex+0x82>

Disassembly of section .text.NVIC_Initialize%428:

0001a2ec <NVIC_Initialize>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
   1a2ec:	4921      	ldr	r1, [pc, #132]	; (1a374 <NVIC_Initialize+0x88>)
   1a2ee:	68cb      	ldr	r3, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
   1a2f0:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
   1a2f4:	041b      	lsls	r3, r3, #16
   1a2f6:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                   |
   1a2f8:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
   1a2fc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  SCB->AIRCR =  reg_value;
   1a300:	60cb      	str	r3, [r1, #12]
   1a302:	f3bf 8f5f 	dmb	sy
  \details Enables IRQ interrupts by clearing special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   1a306:	b662      	cpsie	i
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1a308:	22e0      	movs	r2, #224	; 0xe0
   1a30a:	f881 2023 	strb.w	r2, [r1, #35]	; 0x23
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1a30e:	4b1a      	ldr	r3, [pc, #104]	; (1a378 <NVIC_Initialize+0x8c>)
   1a310:	f883 232e 	strb.w	r2, [r3, #814]	; 0x32e
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1a314:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   1a318:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1a31a:	f883 232f 	strb.w	r2, [r3, #815]	; 0x32f
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1a31e:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   1a322:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1a324:	f883 2330 	strb.w	r2, [r3, #816]	; 0x330
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1a328:	f44f 3180 	mov.w	r1, #65536	; 0x10000
   1a32c:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1a32e:	f883 2331 	strb.w	r2, [r3, #817]	; 0x331
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1a332:	f44f 3100 	mov.w	r1, #131072	; 0x20000
   1a336:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1a338:	f883 2332 	strb.w	r2, [r3, #818]	; 0x332
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1a33c:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   1a340:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1a342:	f883 2333 	strb.w	r2, [r3, #819]	; 0x333
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1a346:	f44f 2100 	mov.w	r1, #524288	; 0x80000
   1a34a:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1a34c:	f883 2334 	strb.w	r2, [r3, #820]	; 0x334
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1a350:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
   1a354:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1a356:	f883 2335 	strb.w	r2, [r3, #821]	; 0x335
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1a35a:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
   1a35e:	6058      	str	r0, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1a360:	f883 2354 	strb.w	r2, [r3, #852]	; 0x354
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1a364:	6099      	str	r1, [r3, #8]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1a366:	f883 236b 	strb.w	r2, [r3, #875]	; 0x36b
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1a36a:	f44f 6200 	mov.w	r2, #2048	; 0x800
   1a36e:	60da      	str	r2, [r3, #12]
    NVIC_SetPriority(TC0_IRQn, 7);
    NVIC_EnableIRQ(TC0_IRQn);



}
   1a370:	4770      	bx	lr
   1a372:	bf00      	nop
   1a374:	e000ed00 	.word	0xe000ed00
   1a378:	e000e100 	.word	0xe000e100

Disassembly of section .text.SYS_TIME_AddToList%429:

0001a37c <SYS_TIME_AddToList>:
    if (newTimer == NULL)
   1a37c:	b330      	cbz	r0, 1a3cc <SYS_TIME_AddToList+0x50>
{
   1a37e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1a382:	4686      	mov	lr, r0
    SYS_TIME_TIMER_OBJ* tmr = counter->tmrActive;
   1a384:	4b20      	ldr	r3, [pc, #128]	; (1a408 <SYS_TIME_AddToList+0x8c>)
   1a386:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    newTimerTime = newTimer->relativeTimePending;
   1a388:	f8d0 8008 	ldr.w	r8, [r0, #8]
    if (tmr == NULL)
   1a38c:	b1c2      	cbz	r2, 1a3c0 <SYS_TIME_AddToList+0x44>
            if ((total_time + tmr->relativeTimePending) > newTimerTime)
   1a38e:	6893      	ldr	r3, [r2, #8]
   1a390:	4640      	mov	r0, r8
   1a392:	2100      	movs	r1, #0
   1a394:	4598      	cmp	r8, r3
   1a396:	d31b      	bcc.n	1a3d0 <SYS_TIME_AddToList+0x54>
    uint64_t total_time = 0;
   1a398:	2400      	movs	r4, #0
   1a39a:	2500      	movs	r5, #0
            total_time += tmr->relativeTimePending;
   1a39c:	6893      	ldr	r3, [r2, #8]
   1a39e:	18e4      	adds	r4, r4, r3
   1a3a0:	f145 0500 	adc.w	r5, r5, #0
            tmr = tmr->tmrNext;
   1a3a4:	6993      	ldr	r3, [r2, #24]
        while (tmr != NULL)
   1a3a6:	b1db      	cbz	r3, 1a3e0 <SYS_TIME_AddToList+0x64>
            if ((total_time + tmr->relativeTimePending) > newTimerTime)
   1a3a8:	f8d3 c008 	ldr.w	ip, [r3, #8]
   1a3ac:	eb14 060c 	adds.w	r6, r4, ip
   1a3b0:	f145 0700 	adc.w	r7, r5, #0
   1a3b4:	42b9      	cmp	r1, r7
   1a3b6:	bf08      	it	eq
   1a3b8:	42b0      	cmpeq	r0, r6
   1a3ba:	d311      	bcc.n	1a3e0 <SYS_TIME_AddToList+0x64>
            tmr = tmr->tmrNext;
   1a3bc:	461a      	mov	r2, r3
   1a3be:	e7ed      	b.n	1a39c <SYS_TIME_AddToList+0x20>
        newTimer->relativeTimePending = newTimerTime;
   1a3c0:	f8c0 8008 	str.w	r8, [r0, #8]
        counter->tmrActive = newTimer;
   1a3c4:	4b10      	ldr	r3, [pc, #64]	; (1a408 <SYS_TIME_AddToList+0x8c>)
   1a3c6:	6318      	str	r0, [r3, #48]	; 0x30
        isHeadTimerUpdated = true;
   1a3c8:	2001      	movs	r0, #1
   1a3ca:	e01a      	b.n	1a402 <SYS_TIME_AddToList+0x86>
        return isHeadTimerUpdated;
   1a3cc:	2000      	movs	r0, #0
}
   1a3ce:	4770      	bx	lr
            counter->tmrActive = newTimer;
   1a3d0:	4b0d      	ldr	r3, [pc, #52]	; (1a408 <SYS_TIME_AddToList+0x8c>)
   1a3d2:	f8c3 e030 	str.w	lr, [r3, #48]	; 0x30
            newTimer->tmrNext = tmr;
   1a3d6:	f8ce 2018 	str.w	r2, [lr, #24]
    uint64_t total_time = 0;
   1a3da:	2400      	movs	r4, #0
            isHeadTimerUpdated = true;
   1a3dc:	2001      	movs	r0, #1
   1a3de:	e004      	b.n	1a3ea <SYS_TIME_AddToList+0x6e>
            newTimer->tmrNext = prevTmr->tmrNext;
   1a3e0:	f8ce 3018 	str.w	r3, [lr, #24]
            prevTmr->tmrNext = newTimer;
   1a3e4:	f8c2 e018 	str.w	lr, [r2, #24]
    bool isHeadTimerUpdated = false;
   1a3e8:	2000      	movs	r0, #0
        newTimer->relativeTimePending = newTimerTime - total_time;
   1a3ea:	eba8 0404 	sub.w	r4, r8, r4
   1a3ee:	f8ce 4008 	str.w	r4, [lr, #8]
        if (newTimer->tmrNext != NULL)
   1a3f2:	f8de 3018 	ldr.w	r3, [lr, #24]
   1a3f6:	b123      	cbz	r3, 1a402 <SYS_TIME_AddToList+0x86>
            newTimerTime = newTimer->relativeTimePending;
   1a3f8:	f8de 1008 	ldr.w	r1, [lr, #8]
            newTimer->tmrNext->relativeTimePending -= newTimerTime;
   1a3fc:	689a      	ldr	r2, [r3, #8]
   1a3fe:	1a52      	subs	r2, r2, r1
   1a400:	609a      	str	r2, [r3, #8]
}
   1a402:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1a406:	bf00      	nop
   1a408:	2000ea00 	.word	0x2000ea00

Disassembly of section .text.Reset_Handler%430:

0001a40c <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void __attribute__((optimize("-O1"), section(".text.Reset_Handler"), long_call, noreturn)) Reset_Handler(void)
{
   1a40c:	b508      	push	{r3, lr}
    __asm__ volatile ("add r7, sp, #0" : : : "r7");
#endif


    /* Call the optional application-provided _on_reset() function. */
    _on_reset();
   1a40e:	4b1b      	ldr	r3, [pc, #108]	; (1a47c <Reset_Handler+0x70>)
   1a410:	4798      	blx	r3

    /* Reserved for use by MPLAB XC32. */
    __xc32_on_reset();
   1a412:	4b1b      	ldr	r3, [pc, #108]	; (1a480 <Reset_Handler+0x74>)
   1a414:	4798      	blx	r3
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   1a416:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
   1a41a:	b672      	cpsid	i
     SCB->CPACR |= (0xFu << 20);
   1a41c:	4a19      	ldr	r2, [pc, #100]	; (1a484 <Reset_Handler+0x78>)
   1a41e:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
   1a422:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
   1a426:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
   1a42a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1a42e:	f3bf 8f6f 	isb	sy
    if (!prim)
   1a432:	b901      	cbnz	r1, 1a436 <Reset_Handler+0x2a>
  __ASM volatile ("cpsie i" : : : "memory");
   1a434:	b662      	cpsie	i
    CMCC_REGS->CMCC_CFG = CMCC_CFG_CSIZESW(tcmSize);
   1a436:	4c14      	ldr	r4, [pc, #80]	; (1a488 <Reset_Handler+0x7c>)
   1a438:	2320      	movs	r3, #32
   1a43a:	6063      	str	r3, [r4, #4]
    /* Enable TCM   */
    TCM_Enable();

    /* Initialize data after TCM is enabled.
     * Data initialization from the XC32 .dinit template */
    __pic32c_data_initialization();
   1a43c:	f000 fa9a 	bl	1a974 <__pic32c_data_initialization>


#  ifdef SCB_VTOR_TBLOFF_Msk
    /*  Set the vector-table base address in FLASH */
    pSrc = (uint32_t *) & __svectors;
    SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
   1a440:	4b12      	ldr	r3, [pc, #72]	; (1a48c <Reset_Handler+0x80>)
   1a442:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
   1a446:	4a0f      	ldr	r2, [pc, #60]	; (1a484 <Reset_Handler+0x78>)
   1a448:	6093      	str	r3, [r2, #8]
#  endif /* SCB_VTOR_TBLOFF_Msk */

    /* Initialize the C library */
    __libc_init_array();
   1a44a:	4b11      	ldr	r3, [pc, #68]	; (1a490 <Reset_Handler+0x84>)
   1a44c:	4798      	blx	r3
    CMCC_REGS->CMCC_CTRL &= ~(CMCC_CTRL_CEN_Msk);
   1a44e:	68a3      	ldr	r3, [r4, #8]
   1a450:	f023 0301 	bic.w	r3, r3, #1
   1a454:	60a3      	str	r3, [r4, #8]
    while((CMCC_REGS->CMCC_SR & CMCC_SR_CSTS_Msk) == CMCC_SR_CSTS_Msk)
   1a456:	4623      	mov	r3, r4
   1a458:	68da      	ldr	r2, [r3, #12]
   1a45a:	f012 0f01 	tst.w	r2, #1
   1a45e:	d1fb      	bne.n	1a458 <Reset_Handler+0x4c>
    CMCC_REGS->CMCC_CFG |= (CMCC_CFG_DCDIS_Msk);
   1a460:	4b09      	ldr	r3, [pc, #36]	; (1a488 <Reset_Handler+0x7c>)
   1a462:	685a      	ldr	r2, [r3, #4]
   1a464:	f042 0204 	orr.w	r2, r2, #4
   1a468:	605a      	str	r2, [r3, #4]
    CMCC_REGS->CMCC_CTRL = (CMCC_CTRL_CEN_Msk);
   1a46a:	2201      	movs	r2, #1
   1a46c:	609a      	str	r2, [r3, #8]
    /* Enable Instruction Cache */
    ICache_Enable();


    /* Call the optional application-provided _on_bootstrap() function. */
    _on_bootstrap();
   1a46e:	4b09      	ldr	r3, [pc, #36]	; (1a494 <Reset_Handler+0x88>)
   1a470:	4798      	blx	r3
    
    /* Reserved for use by MPLAB XC32. */
    __xc32_on_bootstrap();
   1a472:	4b09      	ldr	r3, [pc, #36]	; (1a498 <Reset_Handler+0x8c>)
   1a474:	4798      	blx	r3

    /* Branch to application's main function */
    int retval = main();
   1a476:	f009 fd74 	bl	23f62 <main>

#if (defined(__DEBUG) || defined(__DEBUG_D)) && defined(__XC32)
    __builtin_software_breakpoint();
#endif
    /* Infinite loop */
    while (true) {}
   1a47a:	e7fe      	b.n	1a47a <Reset_Handler+0x6e>
   1a47c:	0001b6ef 	.word	0x0001b6ef
   1a480:	0001b6ef 	.word	0x0001b6ef
   1a484:	e000ed00 	.word	0xe000ed00
   1a488:	41006000 	.word	0x41006000
   1a48c:	00000000 	.word	0x00000000
   1a490:	0001ef51 	.word	0x0001ef51
   1a494:	0001b6ef 	.word	0x0001b6ef
   1a498:	0001b6ef 	.word	0x0001b6ef

Disassembly of section .text._DHCPClientClose%431:

0001a49c <_DHCPClientClose>:
{
   1a49c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1a49e:	4605      	mov	r5, r0
   1a4a0:	460e      	mov	r6, r1
   1a4a2:	4617      	mov	r7, r2
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   1a4a4:	4b1f      	ldr	r3, [pc, #124]	; (1a524 <_DHCPClientClose+0x88>)
   1a4a6:	681c      	ldr	r4, [r3, #0]
   1a4a8:	f009 fd46 	bl	23f38 <TCPIP_STACK_NetIxGet>
   1a4ac:	235c      	movs	r3, #92	; 0x5c
   1a4ae:	fb03 4400 	mla	r4, r3, r0, r4
    if(pClient->flags.bDHCPEnabled != 0)
   1a4b2:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
   1a4b6:	f013 0f01 	tst.w	r3, #1
   1a4ba:	d026      	beq.n	1a50a <_DHCPClientClose+0x6e>
        if(release && pClient->smState >= TCPIP_DHCP_BOUND)
   1a4bc:	b11f      	cbz	r7, 1a4c6 <_DHCPClientClose+0x2a>
   1a4be:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
   1a4c2:	2b07      	cmp	r3, #7
   1a4c4:	d822      	bhi.n	1a50c <_DHCPClientClose+0x70>
		pClient->flags.bIsBound = false;
   1a4c6:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
        pClient->flags.bReportFail = 1;	
   1a4ca:	f003 03f5 	and.w	r3, r3, #245	; 0xf5
   1a4ce:	f043 0320 	orr.w	r3, r3, #32
   1a4d2:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
        pClient->tOpStart = 0; 
   1a4d6:	2300      	movs	r3, #0
   1a4d8:	6223      	str	r3, [r4, #32]
        pClient->dhcpTmo = pClient->dhcpTmoBase;
   1a4da:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
   1a4de:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    if(pClient->dhcpFilterHandle != 0)
   1a4e2:	6ca0      	ldr	r0, [r4, #72]	; 0x48
   1a4e4:	b110      	cbz	r0, 1a4ec <_DHCPClientClose+0x50>
        Ipv4FilterSetActive(pClient->dhcpFilterHandle, active);
   1a4e6:	2100      	movs	r1, #0
   1a4e8:	f002 fdda 	bl	1d0a0 <Ipv4FilterSetActive>
        if(disable)
   1a4ec:	b1ae      	cbz	r6, 1a51a <_DHCPClientClose+0x7e>
            pClient->flags.bWasBound = false;	
   1a4ee:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
            pClient->flags.bDHCPEnabled = false;
   1a4f2:	f003 03ef 	and.w	r3, r3, #239	; 0xef
   1a4f6:	f36f 0300 	bfc	r3, #0, #1
   1a4fa:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
            pNetIf->Flags.bIsDHCPEnabled = false;
   1a4fe:	f895 3042 	ldrb.w	r3, [r5, #66]	; 0x42
   1a502:	f36f 0300 	bfc	r3, #0, #1
   1a506:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
}
   1a50a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            _DHCPSend(pClient, pNetIf, TCPIP_DHCP_RELEASE_MESSAGE, 0);
   1a50c:	2300      	movs	r3, #0
   1a50e:	2207      	movs	r2, #7
   1a510:	4629      	mov	r1, r5
   1a512:	4620      	mov	r0, r4
   1a514:	f7f6 fea0 	bl	11258 <_DHCPSend>
   1a518:	e7d5      	b.n	1a4c6 <_DHCPClientClose+0x2a>
    pClient->smState = newState;
   1a51a:	2300      	movs	r3, #0
   1a51c:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
}
   1a520:	e7f3      	b.n	1a50a <_DHCPClientClose+0x6e>
   1a522:	bf00      	nop
   1a524:	2000ee3c 	.word	0x2000ee3c

Disassembly of section .text.TCPIP_STACK_Initialize%432:

0001a528 <TCPIP_STACK_Initialize>:
{
   1a528:	b538      	push	{r3, r4, r5, lr}
    if(tcpipNetIf != 0)
   1a52a:	4b18      	ldr	r3, [pc, #96]	; (1a58c <TCPIP_STACK_Initialize+0x64>)
   1a52c:	681b      	ldr	r3, [r3, #0]
   1a52e:	b10b      	cbz	r3, 1a534 <TCPIP_STACK_Initialize+0xc>
        return (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data;
   1a530:	4817      	ldr	r0, [pc, #92]	; (1a590 <TCPIP_STACK_Initialize+0x68>)
}
   1a532:	bd38      	pop	{r3, r4, r5, pc}
    if(init == 0)
   1a534:	b331      	cbz	r1, 1a584 <TCPIP_STACK_Initialize+0x5c>
   1a536:	460d      	mov	r5, r1
    totTcpipEventsCnt = 0;
   1a538:	2400      	movs	r4, #0
   1a53a:	4b16      	ldr	r3, [pc, #88]	; (1a594 <TCPIP_STACK_Initialize+0x6c>)
   1a53c:	601c      	str	r4, [r3, #0]
    newTcpipErrorEventCnt = 0;
   1a53e:	4b16      	ldr	r3, [pc, #88]	; (1a598 <TCPIP_STACK_Initialize+0x70>)
   1a540:	601c      	str	r4, [r3, #0]
    newTcpipStackEventCnt = 0;
   1a542:	4b16      	ldr	r3, [pc, #88]	; (1a59c <TCPIP_STACK_Initialize+0x74>)
   1a544:	601c      	str	r4, [r3, #0]
    newTcpipTickAvlbl = 0;
   1a546:	4b16      	ldr	r3, [pc, #88]	; (1a5a0 <TCPIP_STACK_Initialize+0x78>)
   1a548:	601c      	str	r4, [r3, #0]
    stackTaskRate = 0;
   1a54a:	4b16      	ldr	r3, [pc, #88]	; (1a5a4 <TCPIP_STACK_Initialize+0x7c>)
   1a54c:	601c      	str	r4, [r3, #0]
    memset(&tcpip_stack_ctrl_data, 0, sizeof(tcpip_stack_ctrl_data));
   1a54e:	2220      	movs	r2, #32
   1a550:	4621      	mov	r1, r4
   1a552:	480f      	ldr	r0, [pc, #60]	; (1a590 <TCPIP_STACK_Initialize+0x68>)
   1a554:	f009 fca4 	bl	23ea0 <memset>
    SYS_CONSOLE_MESSAGE(TCPIP_STACK_HDR_MESSAGE "Initialization Started \r\n");
   1a558:	4913      	ldr	r1, [pc, #76]	; (1a5a8 <TCPIP_STACK_Initialize+0x80>)
   1a55a:	4620      	mov	r0, r4
   1a55c:	f006 ff96 	bl	2148c <SYS_CONSOLE_Message>
    tcpip_stack_status = SYS_STATUS_BUSY;
   1a560:	4b12      	ldr	r3, [pc, #72]	; (1a5ac <TCPIP_STACK_Initialize+0x84>)
   1a562:	2201      	movs	r2, #1
   1a564:	701a      	strb	r2, [r3, #0]
    if((tcpip_stack_init_cb = ((TCPIP_STACK_INIT*)init)->initCback) == 0)
   1a566:	696b      	ldr	r3, [r5, #20]
   1a568:	4a11      	ldr	r2, [pc, #68]	; (1a5b0 <TCPIP_STACK_Initialize+0x88>)
   1a56a:	6013      	str	r3, [r2, #0]
   1a56c:	b10b      	cbz	r3, 1a572 <TCPIP_STACK_Initialize+0x4a>
    return (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data;
   1a56e:	4808      	ldr	r0, [pc, #32]	; (1a590 <TCPIP_STACK_Initialize+0x68>)
   1a570:	e7df      	b.n	1a532 <TCPIP_STACK_Initialize+0xa>
        bool init_res = _TCPIP_DoInitialize((const TCPIP_STACK_INIT*)init);
   1a572:	4628      	mov	r0, r5
   1a574:	f7ef f986 	bl	9884 <_TCPIP_DoInitialize>
        return init_res ? (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data : SYS_MODULE_OBJ_INVALID;
   1a578:	2800      	cmp	r0, #0
   1a57a:	4805      	ldr	r0, [pc, #20]	; (1a590 <TCPIP_STACK_Initialize+0x68>)
   1a57c:	bf08      	it	eq
   1a57e:	f04f 30ff 	moveq.w	r0, #4294967295
   1a582:	e7d6      	b.n	1a532 <TCPIP_STACK_Initialize+0xa>
        return SYS_MODULE_OBJ_INVALID;
   1a584:	f04f 30ff 	mov.w	r0, #4294967295
   1a588:	e7d3      	b.n	1a532 <TCPIP_STACK_Initialize+0xa>
   1a58a:	bf00      	nop
   1a58c:	2000ee74 	.word	0x2000ee74
   1a590:	2000eae4 	.word	0x2000eae4
   1a594:	2000ee7c 	.word	0x2000ee7c
   1a598:	2000ee5c 	.word	0x2000ee5c
   1a59c:	2000ee60 	.word	0x2000ee60
   1a5a0:	2000ee64 	.word	0x2000ee64
   1a5a4:	2000ee6c 	.word	0x2000ee6c
   1a5a8:	0000972c 	.word	0x0000972c
   1a5ac:	2000ef8b 	.word	0x2000ef8b
   1a5b0:	2000ee78 	.word	0x2000ee78

Disassembly of section .text._UDPsetPacketInfo%433:

0001a5b4 <_UDPsetPacketInfo>:
    if(pRxPkt != 0 && pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   1a5b4:	2900      	cmp	r1, #0
   1a5b6:	d040      	beq.n	1a63a <_UDPsetPacketInfo+0x86>
{
   1a5b8:	b570      	push	{r4, r5, r6, lr}
   1a5ba:	b082      	sub	sp, #8
   1a5bc:	460d      	mov	r5, r1
    if(pRxPkt != 0 && pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   1a5be:	8f82      	ldrh	r2, [r0, #60]	; 0x3c
   1a5c0:	2a01      	cmp	r2, #1
   1a5c2:	d001      	beq.n	1a5c8 <_UDPsetPacketInfo+0x14>
}
   1a5c4:	b002      	add	sp, #8
   1a5c6:	bd70      	pop	{r4, r5, r6, pc}
        uint32_t pktSrcAdd = TCPIP_IPV4_PacketGetSourceAddress(pRxPkt)->Val;
   1a5c8:	698a      	ldr	r2, [r1, #24]
   1a5ca:	68d2      	ldr	r2, [r2, #12]
        pSkt->pktSrcAddress.Val = pktSrcAdd;
   1a5cc:	61c2      	str	r2, [r0, #28]
        if(pSkt->extFlags.ignoreSrcAdd == 0 && pSkt->flags.destSet == 0)
   1a5ce:	6c01      	ldr	r1, [r0, #64]	; 0x40
   1a5d0:	4c1a      	ldr	r4, [pc, #104]	; (1a63c <_UDPsetPacketInfo+0x88>)
   1a5d2:	420c      	tst	r4, r1
            pSkt->destAddress.Val = pktSrcAdd;
   1a5d4:	bf08      	it	eq
   1a5d6:	6142      	streq	r2, [r0, #20]
   1a5d8:	4604      	mov	r4, r0
        uint32_t pktDestAdd = TCPIP_IPV4_PacketGetDestAddress(pRxPkt)->Val;
   1a5da:	69ab      	ldr	r3, [r5, #24]
   1a5dc:	691e      	ldr	r6, [r3, #16]
   1a5de:	9601      	str	r6, [sp, #4]
        pSkt->pktDestAddress.Val = pktDestAdd;
   1a5e0:	6206      	str	r6, [r0, #32]
        if(pSkt->flags.srcSet == 0)
   1a5e2:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   1a5e6:	f013 0f20 	tst.w	r3, #32
   1a5ea:	d00a      	beq.n	1a602 <_UDPsetPacketInfo+0x4e>
        pSkt->pSktNet = (TCPIP_NET_IF*)pRxPkt->pktIf;    // bind it
   1a5ec:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1a5ee:	6263      	str	r3, [r4, #36]	; 0x24
        if(pSkt->extFlags.ignoreSrcPort == 0 )
   1a5f0:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   1a5f4:	f013 0f20 	tst.w	r3, #32
   1a5f8:	d1e4      	bne.n	1a5c4 <_UDPsetPacketInfo+0x10>
    return ((UDP_HEADER*)pRxPkt->pTransportLayer)->SourcePort;
   1a5fa:	69eb      	ldr	r3, [r5, #28]
   1a5fc:	881b      	ldrh	r3, [r3, #0]
            pSkt->remotePort = _UDPRxPktSourcePort(pRxPkt); 
   1a5fe:	8523      	strh	r3, [r4, #40]	; 0x28
}
   1a600:	e7e0      	b.n	1a5c4 <_UDPsetPacketInfo+0x10>
            bool isBcastAdd = TCPIP_STACK_IsBcastAddress((TCPIP_NET_IF*)pRxPkt->pktIf, (IPV4_ADDR*)&pktDestAdd);
   1a602:	a901      	add	r1, sp, #4
   1a604:	6aa8      	ldr	r0, [r5, #40]	; 0x28
   1a606:	f007 f9f5 	bl	219f4 <TCPIP_STACK_IsBcastAddress>
            if(!isBcastAdd && !isMcastAdd)
   1a60a:	2800      	cmp	r0, #0
   1a60c:	d1ee      	bne.n	1a5ec <_UDPsetPacketInfo+0x38>
   1a60e:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
   1a612:	2ee0      	cmp	r6, #224	; 0xe0
   1a614:	d0ea      	beq.n	1a5ec <_UDPsetPacketInfo+0x38>
                if(pSkt->srcAddress.Val != pktDestAdd)
   1a616:	9b01      	ldr	r3, [sp, #4]
   1a618:	69a2      	ldr	r2, [r4, #24]
   1a61a:	429a      	cmp	r2, r3
   1a61c:	d006      	beq.n	1a62c <_UDPsetPacketInfo+0x78>
                    pSkt->flags.srcSolved = 0;
   1a61e:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
   1a622:	f36f 12c7 	bfc	r2, #7, #1
   1a626:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
                    pSkt->srcAddress.Val = pktDestAdd;
   1a62a:	61a3      	str	r3, [r4, #24]
                pSkt->flags.srcValid = 1;
   1a62c:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
   1a630:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1a634:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
   1a638:	e7d8      	b.n	1a5ec <_UDPsetPacketInfo+0x38>
   1a63a:	4770      	bx	lr
   1a63c:	00100100 	.word	0x00100100

Disassembly of section .text.__smakebuf_r%434:

0001a640 <__smakebuf_r>:
   1a640:	898b      	ldrh	r3, [r1, #12]
   1a642:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1a644:	079d      	lsls	r5, r3, #30
   1a646:	4606      	mov	r6, r0
   1a648:	460c      	mov	r4, r1
   1a64a:	d507      	bpl.n	1a65c <__smakebuf_r+0x1c>
   1a64c:	f101 0347 	add.w	r3, r1, #71	; 0x47
   1a650:	600b      	str	r3, [r1, #0]
   1a652:	610b      	str	r3, [r1, #16]
   1a654:	2301      	movs	r3, #1
   1a656:	614b      	str	r3, [r1, #20]
   1a658:	b002      	add	sp, #8
   1a65a:	bd70      	pop	{r4, r5, r6, pc}
   1a65c:	ab01      	add	r3, sp, #4
   1a65e:	466a      	mov	r2, sp
   1a660:	f004 fce2 	bl	1f028 <__swhatbuf_r>
   1a664:	9900      	ldr	r1, [sp, #0]
   1a666:	4605      	mov	r5, r0
   1a668:	4630      	mov	r0, r6
   1a66a:	f7fe f829 	bl	186c0 <_malloc_r>
   1a66e:	b978      	cbnz	r0, 1a690 <__smakebuf_r+0x50>
   1a670:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   1a674:	059a      	lsls	r2, r3, #22
   1a676:	d4ef      	bmi.n	1a658 <__smakebuf_r+0x18>
   1a678:	f023 0303 	bic.w	r3, r3, #3
   1a67c:	f043 0302 	orr.w	r3, r3, #2
   1a680:	81a3      	strh	r3, [r4, #12]
   1a682:	f104 0347 	add.w	r3, r4, #71	; 0x47
   1a686:	6023      	str	r3, [r4, #0]
   1a688:	6123      	str	r3, [r4, #16]
   1a68a:	2301      	movs	r3, #1
   1a68c:	6163      	str	r3, [r4, #20]
   1a68e:	e7e3      	b.n	1a658 <__smakebuf_r+0x18>
   1a690:	4b0d      	ldr	r3, [pc, #52]	; (1a6c8 <__smakebuf_r+0x88>)
   1a692:	62b3      	str	r3, [r6, #40]	; 0x28
   1a694:	89a3      	ldrh	r3, [r4, #12]
   1a696:	6020      	str	r0, [r4, #0]
   1a698:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   1a69c:	81a3      	strh	r3, [r4, #12]
   1a69e:	9b00      	ldr	r3, [sp, #0]
   1a6a0:	6163      	str	r3, [r4, #20]
   1a6a2:	9b01      	ldr	r3, [sp, #4]
   1a6a4:	6120      	str	r0, [r4, #16]
   1a6a6:	b15b      	cbz	r3, 1a6c0 <__smakebuf_r+0x80>
   1a6a8:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   1a6ac:	4630      	mov	r0, r6
   1a6ae:	f008 fbb7 	bl	22e20 <_isatty_r>
   1a6b2:	b128      	cbz	r0, 1a6c0 <__smakebuf_r+0x80>
   1a6b4:	89a3      	ldrh	r3, [r4, #12]
   1a6b6:	f023 0303 	bic.w	r3, r3, #3
   1a6ba:	f043 0301 	orr.w	r3, r3, #1
   1a6be:	81a3      	strh	r3, [r4, #12]
   1a6c0:	89a3      	ldrh	r3, [r4, #12]
   1a6c2:	431d      	orrs	r5, r3
   1a6c4:	81a5      	strh	r5, [r4, #12]
   1a6c6:	e7c7      	b.n	1a658 <__smakebuf_r+0x18>
   1a6c8:	000242c9 	.word	0x000242c9

Disassembly of section .text._Command_GatewayAddressSet%435:

0001a6cc <_Command_GatewayAddressSet>:
{
   1a6cc:	b5f0      	push	{r4, r5, r6, r7, lr}
   1a6ce:	b083      	sub	sp, #12
   1a6d0:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   1a6d2:	6845      	ldr	r5, [r0, #4]
    if (argc != 3)
   1a6d4:	2903      	cmp	r1, #3
   1a6d6:	d00f      	beq.n	1a6f8 <_Command_GatewayAddressSet+0x2c>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: setgw <interface> <ipv4/6 address> <validTime> \r\n");
   1a6d8:	4e1a      	ldr	r6, [pc, #104]	; (1a744 <_Command_GatewayAddressSet+0x78>)
   1a6da:	6803      	ldr	r3, [r0, #0]
   1a6dc:	681b      	ldr	r3, [r3, #0]
   1a6de:	f606 51f4 	addw	r1, r6, #3572	; 0xdf4
   1a6e2:	4628      	mov	r0, r5
   1a6e4:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: setgw PIC32INT 192.168.0.1 \r\n");
   1a6e6:	6823      	ldr	r3, [r4, #0]
   1a6e8:	681b      	ldr	r3, [r3, #0]
   1a6ea:	f506 6163 	add.w	r1, r6, #3632	; 0xe30
   1a6ee:	4628      	mov	r0, r5
   1a6f0:	4798      	blx	r3
}
   1a6f2:	2000      	movs	r0, #0
   1a6f4:	b003      	add	sp, #12
   1a6f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1a6f8:	4616      	mov	r6, r2
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
   1a6fa:	6850      	ldr	r0, [r2, #4]
   1a6fc:	f005 f9b2 	bl	1fa64 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
   1a700:	4607      	mov	r7, r0
   1a702:	b150      	cbz	r0, 1a71a <_Command_GatewayAddressSet+0x4e>
    if (TCPIP_Helper_StringToIPAddress(argv[2], &ipGateway))
   1a704:	a901      	add	r1, sp, #4
   1a706:	68b0      	ldr	r0, [r6, #8]
   1a708:	f7fa f9b2 	bl	14a70 <TCPIP_Helper_StringToIPAddress>
   1a70c:	b958      	cbnz	r0, 1a726 <_Command_GatewayAddressSet+0x5a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Invalid IP address string \r\n");
   1a70e:	6823      	ldr	r3, [r4, #0]
   1a710:	681b      	ldr	r3, [r3, #0]
   1a712:	490d      	ldr	r1, [pc, #52]	; (1a748 <_Command_GatewayAddressSet+0x7c>)
   1a714:	4628      	mov	r0, r5
   1a716:	4798      	blx	r3
        return false;
   1a718:	e7eb      	b.n	1a6f2 <_Command_GatewayAddressSet+0x26>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   1a71a:	6823      	ldr	r3, [r4, #0]
   1a71c:	681b      	ldr	r3, [r3, #0]
   1a71e:	490b      	ldr	r1, [pc, #44]	; (1a74c <_Command_GatewayAddressSet+0x80>)
   1a720:	4628      	mov	r0, r5
   1a722:	4798      	blx	r3
        return false;
   1a724:	e7e5      	b.n	1a6f2 <_Command_GatewayAddressSet+0x26>
        success = TCPIP_STACK_NetAddressGatewaySet(netH, &ipGateway);
   1a726:	a901      	add	r1, sp, #4
   1a728:	4638      	mov	r0, r7
   1a72a:	f008 fcd5 	bl	230d8 <TCPIP_STACK_NetAddressGatewaySet>
    (*pCmdIO->pCmdApi->msg)(cmdIoParam, success ? "Set gateway address OK\r\n" : "Set gateway address failed\r\n");
   1a72e:	6823      	ldr	r3, [r4, #0]
   1a730:	681b      	ldr	r3, [r3, #0]
   1a732:	2800      	cmp	r0, #0
   1a734:	4906      	ldr	r1, [pc, #24]	; (1a750 <_Command_GatewayAddressSet+0x84>)
   1a736:	f101 021c 	add.w	r2, r1, #28
   1a73a:	bf08      	it	eq
   1a73c:	4611      	moveq	r1, r2
   1a73e:	4628      	mov	r0, r5
   1a740:	4798      	blx	r3
    return false;
   1a742:	e7d6      	b.n	1a6f2 <_Command_GatewayAddressSet+0x26>
   1a744:	0000028c 	.word	0x0000028c
   1a748:	000010e0 	.word	0x000010e0
   1a74c:	00000b80 	.word	0x00000b80
   1a750:	00001044 	.word	0x00001044

Disassembly of section .text._DHCPPacketFilter%436:

0001a754 <_DHCPPacketFilter>:
{
   1a754:	b5f0      	push	{r4, r5, r6, r7, lr}
   1a756:	b083      	sub	sp, #12
   1a758:	4604      	mov	r4, r0
   1a75a:	460f      	mov	r7, r1
    TCPIP_MAC_ADDR bcastAdd = { {0xff, 0xff, 0xff, 0xff, 0xff, 0xff} };
   1a75c:	4b1c      	ldr	r3, [pc, #112]	; (1a7d0 <_DHCPPacketFilter+0x7c>)
   1a75e:	e893 0003 	ldmia.w	r3, {r0, r1}
   1a762:	9000      	str	r0, [sp, #0]
   1a764:	f8ad 1004 	strh.w	r1, [sp, #4]
    TCPIP_MAC_ETHERNET_HEADER* macHdr = (TCPIP_MAC_ETHERNET_HEADER*)pRxPkt->pMacLayer;
   1a768:	6966      	ldr	r6, [r4, #20]
    const uint8_t* netMacAddr = TCPIP_STACK_NetUpMACAddressGet((TCPIP_NET_IF*)pRxPkt->pktIf);
   1a76a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   1a76c:	f009 f9c4 	bl	23af8 <TCPIP_STACK_NetUpMACAddressGet>
    if(netMacAddr)
   1a770:	b350      	cbz	r0, 1a7c8 <_DHCPPacketFilter+0x74>
   1a772:	4605      	mov	r5, r0
        if(memcmp(netMacAddr, macHdr->DestMACAddr.v, sizeof(macHdr->DestMACAddr)) == 0 || 
   1a774:	2206      	movs	r2, #6
   1a776:	4631      	mov	r1, r6
   1a778:	f008 fdaa 	bl	232d0 <memcmp>
   1a77c:	b128      	cbz	r0, 1a78a <_DHCPPacketFilter+0x36>
           memcmp(netMacAddr, bcastAdd.v, sizeof(bcastAdd)) == 0 )
   1a77e:	2206      	movs	r2, #6
   1a780:	4669      	mov	r1, sp
   1a782:	4628      	mov	r0, r5
   1a784:	f008 fda4 	bl	232d0 <memcmp>
        if(memcmp(netMacAddr, macHdr->DestMACAddr.v, sizeof(macHdr->DestMACAddr)) == 0 || 
   1a788:	bb00      	cbnz	r0, 1a7cc <_DHCPPacketFilter+0x78>
            IPV4_HEADER* pHeader = (IPV4_HEADER*)pRxPkt->pNetLayer;
   1a78a:	69a3      	ldr	r3, [r4, #24]
            if(pHeader->Protocol == IP_PROT_UDP)
   1a78c:	7a5a      	ldrb	r2, [r3, #9]
   1a78e:	2a11      	cmp	r2, #17
   1a790:	d002      	beq.n	1a798 <_DHCPPacketFilter+0x44>
    return false;
   1a792:	2000      	movs	r0, #0
}
   1a794:	b003      	add	sp, #12
   1a796:	bdf0      	pop	{r4, r5, r6, r7, pc}
                UDP_HEADER* pUDPHdr = (UDP_HEADER*)(pRxPkt->pNetLayer + hdrlen);
   1a798:	19da      	adds	r2, r3, r7
                UDP_PORT destPort = TCPIP_Helper_ntohs(pUDPHdr->DestinationPort);
   1a79a:	8851      	ldrh	r1, [r2, #2]
   1a79c:	0a0a      	lsrs	r2, r1, #8
   1a79e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
                if(destPort == dhcpClientPort && srcPort == dhcpServerPort)
   1a7a2:	490c      	ldr	r1, [pc, #48]	; (1a7d4 <_DHCPPacketFilter+0x80>)
   1a7a4:	8809      	ldrh	r1, [r1, #0]
   1a7a6:	b292      	uxth	r2, r2
   1a7a8:	4291      	cmp	r1, r2
   1a7aa:	d001      	beq.n	1a7b0 <_DHCPPacketFilter+0x5c>
    return false;
   1a7ac:	2000      	movs	r0, #0
   1a7ae:	e7f1      	b.n	1a794 <_DHCPPacketFilter+0x40>
                UDP_PORT srcPort = TCPIP_Helper_ntohs(pUDPHdr->SourcePort);
   1a7b0:	5bd8      	ldrh	r0, [r3, r7]
   1a7b2:	0a03      	lsrs	r3, r0, #8
   1a7b4:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                if(destPort == dhcpClientPort && srcPort == dhcpServerPort)
   1a7b8:	4a07      	ldr	r2, [pc, #28]	; (1a7d8 <_DHCPPacketFilter+0x84>)
   1a7ba:	8810      	ldrh	r0, [r2, #0]
   1a7bc:	b29b      	uxth	r3, r3
   1a7be:	4298      	cmp	r0, r3
   1a7c0:	bf14      	ite	ne
   1a7c2:	2000      	movne	r0, #0
   1a7c4:	2001      	moveq	r0, #1
   1a7c6:	e7e5      	b.n	1a794 <_DHCPPacketFilter+0x40>
    return false;
   1a7c8:	2000      	movs	r0, #0
   1a7ca:	e7e3      	b.n	1a794 <_DHCPPacketFilter+0x40>
   1a7cc:	2000      	movs	r0, #0
   1a7ce:	e7e1      	b.n	1a794 <_DHCPPacketFilter+0x40>
   1a7d0:	00020b58 	.word	0x00020b58
   1a7d4:	2000ef7c 	.word	0x2000ef7c
   1a7d8:	2000ef80 	.word	0x2000ef80

Disassembly of section .text._DHCPSetLeaseTimeParams%437:

0001a7dc <_DHCPSetLeaseTimeParams>:
{
   1a7dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1a7e0:	4606      	mov	r6, r0
    if(pDhcpData == 0 || pDhcpData->leaseTime.Val == 0)
   1a7e2:	b131      	cbz	r1, 1a7f2 <_DHCPSetLeaseTimeParams+0x16>
   1a7e4:	460b      	mov	r3, r1
   1a7e6:	690d      	ldr	r5, [r1, #16]
   1a7e8:	b13d      	cbz	r5, 1a7fa <_DHCPSetLeaseTimeParams+0x1e>
    if(leaseTime < 2 * TCPIP_DHCP_LEASE_EXPIRE_FUZZ)
   1a7ea:	2d14      	cmp	r5, #20
   1a7ec:	bf38      	it	cc
   1a7ee:	2514      	movcc	r5, #20
   1a7f0:	e004      	b.n	1a7fc <_DHCPSetLeaseTimeParams+0x20>
        t1Time = leaseTime >> 1;
   1a7f2:	f04f 083c 	mov.w	r8, #60	; 0x3c
        leaseTime = TCPIP_DHCP_LEASE_TIME_DEFAULT;
   1a7f6:	2578      	movs	r5, #120	; 0x78
   1a7f8:	e009      	b.n	1a80e <_DHCPSetLeaseTimeParams+0x32>
   1a7fa:	2578      	movs	r5, #120	; 0x78
    if(pDhcpData == 0 || pDhcpData->renewTime.Val == 0)
   1a7fc:	f8d3 8014 	ldr.w	r8, [r3, #20]
   1a800:	f1b8 0f00 	cmp.w	r8, #0
   1a804:	d101      	bne.n	1a80a <_DHCPSetLeaseTimeParams+0x2e>
        t1Time = leaseTime >> 1;
   1a806:	ea4f 0855 	mov.w	r8, r5, lsr #1
    if(pDhcpData == 0 || pDhcpData->rebindTime.Val == 0)
   1a80a:	699f      	ldr	r7, [r3, #24]
   1a80c:	b947      	cbnz	r7, 1a820 <_DHCPSetLeaseTimeParams+0x44>
        if(leaseTime >= 0xffffffff / 7)
   1a80e:	4b13      	ldr	r3, [pc, #76]	; (1a85c <_DHCPSetLeaseTimeParams+0x80>)
   1a810:	429d      	cmp	r5, r3
            t2Time = (leaseTime >> 3) * 7 ;
   1a812:	bf87      	ittee	hi
   1a814:	08ef      	lsrhi	r7, r5, #3
   1a816:	ebc7 07c7 	rsbhi	r7, r7, r7, lsl #3
            t2Time = (leaseTime * 7) >> 3 ;
   1a81a:	ebc5 07c5 	rsbls	r7, r5, r5, lsl #3
   1a81e:	08ff      	lsrls	r7, r7, #3
   1a820:	f002 f980 	bl	1cb24 <rand>
    pClient->t1Seconds = (t1Time - TCPIP_DHCP_LEASE_EXPIRE_FUZZ) + SYS_RANDOM_PseudoGet() %  (2 * TCPIP_DHCP_LEASE_EXPIRE_FUZZ);
   1a824:	4c0e      	ldr	r4, [pc, #56]	; (1a860 <_DHCPSetLeaseTimeParams+0x84>)
   1a826:	fba4 2300 	umull	r2, r3, r4, r0
   1a82a:	091b      	lsrs	r3, r3, #4
   1a82c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   1a830:	eba0 0083 	sub.w	r0, r0, r3, lsl #2
   1a834:	f1a8 080a 	sub.w	r8, r8, #10
   1a838:	4440      	add	r0, r8
   1a83a:	6130      	str	r0, [r6, #16]
   1a83c:	f002 f972 	bl	1cb24 <rand>
    pClient->t2Seconds = (t2Time - TCPIP_DHCP_LEASE_EXPIRE_FUZZ) + SYS_RANDOM_PseudoGet() %  (2 * TCPIP_DHCP_LEASE_EXPIRE_FUZZ);
   1a840:	fba4 3400 	umull	r3, r4, r4, r0
   1a844:	0924      	lsrs	r4, r4, #4
   1a846:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   1a84a:	eba0 0484 	sub.w	r4, r0, r4, lsl #2
   1a84e:	3f0a      	subs	r7, #10
   1a850:	443c      	add	r4, r7
   1a852:	6174      	str	r4, [r6, #20]
    pClient->tExpSeconds = leaseTime;
   1a854:	61b5      	str	r5, [r6, #24]
}
   1a856:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1a85a:	bf00      	nop
   1a85c:	24924923 	.word	0x24924923
   1a860:	cccccccd 	.word	0xcccccccd

Disassembly of section .text._OAHashFindBkt%438:

0001a864 <_OAHashFindBkt>:
// implementation

// finds a entry that either contains the desired key
// or is empty and can be used to insert the key 
static OA_HASH_ENTRY* _OAHashFindBkt(OA_HASH_DCPT* pOH, const void* key)
{
   1a864:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1a868:	4604      	mov	r4, r0
   1a86a:	460f      	mov	r7, r1
    probeStep = pOH->probeStep;
   1a86c:	f8d0 8010 	ldr.w	r8, [r0, #16]
    size_t      probeStep;
    size_t      bkts = 0;

    probeStep = _OAHashProbeStep(pOH, key);
#if defined ( OA_HASH_DYNAMIC_KEY_MANIPULATION )
    bktIx = (*pOH->hashF)(pOH, key);
   1a870:	6943      	ldr	r3, [r0, #20]
   1a872:	4798      	blx	r3
#else
    bktIx = TCPIP_OAHASH_KeyHash(pOH, key);
#endif  // defined ( OA_HASH_DYNAMIC_KEY_MANIPULATION )

    while(bkts < pOH->hEntries)
   1a874:	68e3      	ldr	r3, [r4, #12]
   1a876:	2b00      	cmp	r3, #0
   1a878:	d035      	beq.n	1a8e6 <_OAHashFindBkt+0x82>
   1a87a:	4605      	mov	r5, r0
    {
        pBkt = (OA_HASH_ENTRY*)((uint8_t*)(pOH->memBlk) + bktIx * pOH->hEntrySize);
   1a87c:	68a3      	ldr	r3, [r4, #8]
   1a87e:	fb03 f300 	mul.w	r3, r3, r0
   1a882:	6822      	ldr	r2, [r4, #0]
   1a884:	eb02 0903 	add.w	r9, r2, r3
        if(pBkt->flags.busy == 0)
   1a888:	5cd3      	ldrb	r3, [r2, r3]
   1a88a:	f013 0f01 	tst.w	r3, #1
   1a88e:	d025      	beq.n	1a8dc <_OAHashFindBkt+0x78>
    size_t      bkts = 0;
   1a890:	2600      	movs	r6, #0
            pOH->fullSlots++;
            return pBkt;
        }

#if defined ( OA_HASH_DYNAMIC_KEY_MANIPULATION )
        if((*pOH->cmpF)(pOH, pBkt, key) == 0)
   1a892:	69e3      	ldr	r3, [r4, #28]
   1a894:	463a      	mov	r2, r7
   1a896:	4649      	mov	r1, r9
   1a898:	4620      	mov	r0, r4
   1a89a:	4798      	blx	r3
   1a89c:	b1d8      	cbz	r0, 1a8d6 <_OAHashFindBkt+0x72>
            return pBkt;
        }
#endif  // defined ( OA_HASH_DYNAMIC_KEY_MANIPULATION )

        // advance to the next hash slot
        bktIx += probeStep;
   1a89e:	4445      	add	r5, r8
        if(bktIx >= pOH->hEntries)
   1a8a0:	68e3      	ldr	r3, [r4, #12]
   1a8a2:	42ab      	cmp	r3, r5
        {
            bktIx -= pOH->hEntries;
   1a8a4:	bf98      	it	ls
   1a8a6:	1aed      	subls	r5, r5, r3
        }

        bkts++;
   1a8a8:	3601      	adds	r6, #1
    while(bkts < pOH->hEntries)
   1a8aa:	42b3      	cmp	r3, r6
   1a8ac:	d918      	bls.n	1a8e0 <_OAHashFindBkt+0x7c>
        pBkt = (OA_HASH_ENTRY*)((uint8_t*)(pOH->memBlk) + bktIx * pOH->hEntrySize);
   1a8ae:	68a3      	ldr	r3, [r4, #8]
   1a8b0:	fb03 f305 	mul.w	r3, r3, r5
   1a8b4:	6822      	ldr	r2, [r4, #0]
   1a8b6:	eb02 0903 	add.w	r9, r2, r3
        if(pBkt->flags.busy == 0)
   1a8ba:	5cd3      	ldrb	r3, [r2, r3]
   1a8bc:	f013 0f01 	tst.w	r3, #1
   1a8c0:	d1e7      	bne.n	1a892 <_OAHashFindBkt+0x2e>
            (*pOH->cpyF)(pOH, pBkt, key);   // set the key
   1a8c2:	6a23      	ldr	r3, [r4, #32]
   1a8c4:	463a      	mov	r2, r7
   1a8c6:	4649      	mov	r1, r9
   1a8c8:	4620      	mov	r0, r4
   1a8ca:	4798      	blx	r3
            pBkt->probeCount = bkts;
   1a8cc:	f8a9 6002 	strh.w	r6, [r9, #2]
            pOH->fullSlots++;
   1a8d0:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1a8d2:	3301      	adds	r3, #1
   1a8d4:	6263      	str	r3, [r4, #36]	; 0x24
    }
    
    return 0;   // cache full, not found
}
   1a8d6:	4648      	mov	r0, r9
   1a8d8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    size_t      bkts = 0;
   1a8dc:	2600      	movs	r6, #0
   1a8de:	e7f0      	b.n	1a8c2 <_OAHashFindBkt+0x5e>
    return 0;   // cache full, not found
   1a8e0:	f04f 0900 	mov.w	r9, #0
   1a8e4:	e7f7      	b.n	1a8d6 <_OAHashFindBkt+0x72>
   1a8e6:	f04f 0900 	mov.w	r9, #0
   1a8ea:	e7f4      	b.n	1a8d6 <_OAHashFindBkt+0x72>

Disassembly of section .text.SYS_CMDIO_ADD%439:

0001a8ec <SYS_CMDIO_ADD>:
{
   1a8ec:	b570      	push	{r4, r5, r6, lr}
   1a8ee:	4606      	mov	r6, r0
   1a8f0:	460d      	mov	r5, r1
    pNewIo = (SYS_CMD_IO_DCPT*)OSAL_Malloc(sizeof(*pNewIo));
   1a8f2:	f44f 7012 	mov.w	r0, #584	; 0x248
   1a8f6:	f009 fd73 	bl	243e0 <OSAL_Malloc>
    if (!pNewIo)
   1a8fa:	4604      	mov	r4, r0
   1a8fc:	2800      	cmp	r0, #0
   1a8fe:	d030      	beq.n	1a962 <SYS_CMDIO_ADD+0x76>
	memset(pNewIo, 0, sizeof(*pNewIo));
   1a900:	f44f 7212 	mov.w	r2, #584	; 0x248
   1a904:	2100      	movs	r1, #0
   1a906:	f009 facb 	bl	23ea0 <memset>
    pNewIo->devNode.pCmdApi = opApi;
   1a90a:	6026      	str	r6, [r4, #0]
    pNewIo->devNode.cmdIoParam = cmdIoParam;
   1a90c:	6065      	str	r5, [r4, #4]
    pNewIo->cmdPnt = pNewIo->cmdEnd = pNewIo->cmdBuff;
   1a90e:	f104 0320 	add.w	r3, r4, #32
   1a912:	61e3      	str	r3, [r4, #28]
   1a914:	61a3      	str	r3, [r4, #24]
    for(ix = 0; ix < sizeof(pNewIo->histArray) / sizeof(*pNewIo->histArray); ix++)
   1a916:	f104 03d8 	add.w	r3, r4, #216	; 0xd8
   1a91a:	f504 7112 	add.w	r1, r4, #584	; 0x248
   1a91e:	e008      	b.n	1a932 <SYS_CMDIO_ADD+0x46>
        pL->head = pL->tail = pN;
   1a920:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
   1a924:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
        pN->next = pN->prev = pN;
   1a928:	605b      	str	r3, [r3, #4]
   1a92a:	601b      	str	r3, [r3, #0]
   1a92c:	335c      	adds	r3, #92	; 0x5c
    for(ix = 0; ix < sizeof(pNewIo->histArray) / sizeof(*pNewIo->histArray); ix++)
   1a92e:	428b      	cmp	r3, r1
   1a930:	d00e      	beq.n	1a950 <SYS_CMDIO_ADD+0x64>
    if(pL->head == 0)
   1a932:	f8d4 20cc 	ldr.w	r2, [r4, #204]	; 0xcc
   1a936:	2a00      	cmp	r2, #0
   1a938:	d0f2      	beq.n	1a920 <SYS_CMDIO_ADD+0x34>
        pN->next = pL->head;
   1a93a:	601a      	str	r2, [r3, #0]
        pN->prev = pL->tail;
   1a93c:	f8d4 20d0 	ldr.w	r2, [r4, #208]	; 0xd0
   1a940:	605a      	str	r2, [r3, #4]
        pL->tail->next = pN;
   1a942:	6013      	str	r3, [r2, #0]
        pL->head->prev = pN;
   1a944:	f8d4 20cc 	ldr.w	r2, [r4, #204]	; 0xcc
   1a948:	6053      	str	r3, [r2, #4]
        pL->head = pN;
   1a94a:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
   1a94e:	e7ed      	b.n	1a92c <SYS_CMDIO_ADD+0x40>
    pNewIo->next = 0;
   1a950:	2300      	movs	r3, #0
   1a952:	60a3      	str	r3, [r4, #8]
    if(cmdIODevList.head == 0)
   1a954:	4b06      	ldr	r3, [pc, #24]	; (1a970 <SYS_CMDIO_ADD+0x84>)
   1a956:	681b      	ldr	r3, [r3, #0]
   1a958:	b12b      	cbz	r3, 1a966 <SYS_CMDIO_ADD+0x7a>
        cmdIODevList.tail->next = pNewIo;
   1a95a:	4b05      	ldr	r3, [pc, #20]	; (1a970 <SYS_CMDIO_ADD+0x84>)
   1a95c:	685a      	ldr	r2, [r3, #4]
   1a95e:	6094      	str	r4, [r2, #8]
        cmdIODevList.tail = pNewIo;
   1a960:	605c      	str	r4, [r3, #4]
}
   1a962:	4620      	mov	r0, r4
   1a964:	bd70      	pop	{r4, r5, r6, pc}
        cmdIODevList.head = pNewIo;
   1a966:	4b02      	ldr	r3, [pc, #8]	; (1a970 <SYS_CMDIO_ADD+0x84>)
   1a968:	601c      	str	r4, [r3, #0]
        cmdIODevList.tail = pNewIo;
   1a96a:	605c      	str	r4, [r3, #4]
   1a96c:	e7f9      	b.n	1a962 <SYS_CMDIO_ADD+0x76>
   1a96e:	bf00      	nop
   1a970:	2000ed8c 	.word	0x2000ed8c

Disassembly of section .text.__pic32c_data_initialization%440:

0001a974 <__pic32c_data_initialization>:
   1a974:	4b1e      	ldr	r3, [pc, #120]	; (1a9f0 <__pic32c_data_initialization+0x7c>)
   1a976:	4a1f      	ldr	r2, [pc, #124]	; (1a9f4 <__pic32c_data_initialization+0x80>)
   1a978:	4293      	cmp	r3, r2
   1a97a:	b4f0      	push	{r4, r5, r6, r7}
   1a97c:	bf38      	it	cc
   1a97e:	2100      	movcc	r1, #0
   1a980:	d203      	bcs.n	1a98a <__pic32c_data_initialization+0x16>
   1a982:	f803 1b01 	strb.w	r1, [r3], #1
   1a986:	4293      	cmp	r3, r2
   1a988:	d1fb      	bne.n	1a982 <__pic32c_data_initialization+0xe>
   1a98a:	4a1b      	ldr	r2, [pc, #108]	; (1a9f8 <__pic32c_data_initialization+0x84>)
   1a98c:	e9d2 0100 	ldrd	r0, r1, [r2]
   1a990:	ea50 0301 	orrs.w	r3, r0, r1
   1a994:	f04f 0600 	mov.w	r6, #0
   1a998:	d010      	beq.n	1a9bc <__pic32c_data_initialization+0x48>
   1a99a:	6894      	ldr	r4, [r2, #8]
   1a99c:	4603      	mov	r3, r0
   1a99e:	f102 070c 	add.w	r7, r2, #12
   1a9a2:	b96c      	cbnz	r4, 1a9c0 <__pic32c_data_initialization+0x4c>
   1a9a4:	b121      	cbz	r1, 1a9b0 <__pic32c_data_initialization+0x3c>
   1a9a6:	4401      	add	r1, r0
   1a9a8:	f803 6b01 	strb.w	r6, [r3], #1
   1a9ac:	4299      	cmp	r1, r3
   1a9ae:	d1fb      	bne.n	1a9a8 <__pic32c_data_initialization+0x34>
   1a9b0:	463a      	mov	r2, r7
   1a9b2:	e9d2 0100 	ldrd	r0, r1, [r2]
   1a9b6:	ea50 0301 	orrs.w	r3, r0, r1
   1a9ba:	d1ee      	bne.n	1a99a <__pic32c_data_initialization+0x26>
   1a9bc:	bcf0      	pop	{r4, r5, r6, r7}
   1a9be:	4770      	bx	lr
   1a9c0:	b159      	cbz	r1, 1a9da <__pic32c_data_initialization+0x66>
   1a9c2:	f101 030c 	add.w	r3, r1, #12
   1a9c6:	380c      	subs	r0, #12
   1a9c8:	1a80      	subs	r0, r0, r2
   1a9ca:	441a      	add	r2, r3
   1a9cc:	463b      	mov	r3, r7
   1a9ce:	181c      	adds	r4, r3, r0
   1a9d0:	f813 5b01 	ldrb.w	r5, [r3], #1
   1a9d4:	7025      	strb	r5, [r4, #0]
   1a9d6:	4293      	cmp	r3, r2
   1a9d8:	d1f9      	bne.n	1a9ce <__pic32c_data_initialization+0x5a>
   1a9da:	f011 0303 	ands.w	r3, r1, #3
   1a9de:	bf18      	it	ne
   1a9e0:	2301      	movne	r3, #1
   1a9e2:	eb03 0191 	add.w	r1, r3, r1, lsr #2
   1a9e6:	eb07 0781 	add.w	r7, r7, r1, lsl #2
   1a9ea:	463a      	mov	r2, r7
   1a9ec:	e7e1      	b.n	1a9b2 <__pic32c_data_initialization+0x3e>
   1a9ee:	bf00      	nop
   1a9f0:	20000000 	.word	0x20000000
   1a9f4:	20000004 	.word	0x20000004
   1a9f8:	000035c8 	.word	0x000035c8

Disassembly of section .text.TCPIP_IPV4_MacPacketSwitchTxToRx%441:

0001a9fc <TCPIP_IPV4_MacPacketSwitchTxToRx>:
//          - the destination addresses is set as the MAC packet source address
//          - the source address is the MAC address of the coresponding packet interface (which should be set!) 
//          - data segment is re-adjusted with the MAC header length
// TCPIP_MAC_PKT_FLAG_TX flag is set
void TCPIP_IPV4_MacPacketSwitchTxToRx(TCPIP_MAC_PACKET* pRxPkt, bool setChecksum, bool setMac)
{
   1a9fc:	b570      	push	{r4, r5, r6, lr}
   1a9fe:	4605      	mov	r5, r0
   1aa00:	4616      	mov	r6, r2
    IPV4_HEADER* pIpv4Hdr;

    pIpv4Hdr = (IPV4_HEADER*)pRxPkt->pNetLayer;
   1aa02:	6984      	ldr	r4, [r0, #24]
    pIpv4Hdr->DestAddress.Val = pIpv4Hdr->SourceAddress.Val;
   1aa04:	68e3      	ldr	r3, [r4, #12]
   1aa06:	6123      	str	r3, [r4, #16]
    return pNetIf->netIPAddr.Val;
   1aa08:	6a83      	ldr	r3, [r0, #40]	; 0x28
   1aa0a:	685b      	ldr	r3, [r3, #4]
    pIpv4Hdr->SourceAddress.Val = _TCPIPStackNetAddress((TCPIP_NET_IF*)pRxPkt->pktIf);
   1aa0c:	60e3      	str	r3, [r4, #12]

    pIpv4Hdr->TotalLength = TCPIP_Helper_htons(pIpv4Hdr->TotalLength);
   1aa0e:	8862      	ldrh	r2, [r4, #2]
   1aa10:	0a13      	lsrs	r3, r2, #8
   1aa12:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1aa16:	8063      	strh	r3, [r4, #2]
    pIpv4Hdr->FragmentInfo.val = TCPIP_Helper_htons(pIpv4Hdr->FragmentInfo.val);
   1aa18:	88e2      	ldrh	r2, [r4, #6]
   1aa1a:	0a13      	lsrs	r3, r2, #8
   1aa1c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1aa20:	80e3      	strh	r3, [r4, #6]
    if(pIpv4Hdr->TimeToLive == 0)
   1aa22:	7a23      	ldrb	r3, [r4, #8]
   1aa24:	b90b      	cbnz	r3, 1aa2a <TCPIP_IPV4_MacPacketSwitchTxToRx+0x2e>
    {
        pIpv4Hdr->TimeToLive = IPV4_DEFAULT_TTL;
   1aa26:	2364      	movs	r3, #100	; 0x64
   1aa28:	7223      	strb	r3, [r4, #8]
    }
    uint8_t headerLen = pIpv4Hdr->IHL << 2;  
    pRxPkt->pDSeg->segLen += headerLen;
   1aa2a:	6928      	ldr	r0, [r5, #16]
    uint8_t headerLen = pIpv4Hdr->IHL << 2;  
   1aa2c:	7823      	ldrb	r3, [r4, #0]
   1aa2e:	009b      	lsls	r3, r3, #2
    pRxPkt->pDSeg->segLen += headerLen;
   1aa30:	f003 033c 	and.w	r3, r3, #60	; 0x3c
   1aa34:	8982      	ldrh	r2, [r0, #12]
   1aa36:	441a      	add	r2, r3
   1aa38:	8182      	strh	r2, [r0, #12]

    if(setChecksum)
   1aa3a:	b929      	cbnz	r1, 1aa48 <TCPIP_IPV4_MacPacketSwitchTxToRx+0x4c>
    {
        pIpv4Hdr->HeaderChecksum = 0;
        pIpv4Hdr->HeaderChecksum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pIpv4Hdr, headerLen, 0);
    }

    if(setMac)
   1aa3c:	b966      	cbnz	r6, 1aa58 <TCPIP_IPV4_MacPacketSwitchTxToRx+0x5c>
        memcpy(&macHdr->SourceMACAddr, _TCPIPStack_NetMACAddressGet((TCPIP_NET_IF*)pRxPkt->pktIf), sizeof(TCPIP_MAC_ADDR));

        pRxPkt->pDSeg->segLen += sizeof(TCPIP_MAC_ETHERNET_HEADER);
    }

    pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_TX; 
   1aa3e:	8c6b      	ldrh	r3, [r5, #34]	; 0x22
   1aa40:	f043 0302 	orr.w	r3, r3, #2
   1aa44:	846b      	strh	r3, [r5, #34]	; 0x22
}
   1aa46:	bd70      	pop	{r4, r5, r6, pc}
        pIpv4Hdr->HeaderChecksum = 0;
   1aa48:	2200      	movs	r2, #0
   1aa4a:	8162      	strh	r2, [r4, #10]
        pIpv4Hdr->HeaderChecksum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pIpv4Hdr, headerLen, 0);
   1aa4c:	4619      	mov	r1, r3
   1aa4e:	4620      	mov	r0, r4
   1aa50:	f001 fc02 	bl	1c258 <TCPIP_Helper_CalcIPChecksum>
   1aa54:	8160      	strh	r0, [r4, #10]
   1aa56:	e7f1      	b.n	1aa3c <TCPIP_IPV4_MacPacketSwitchTxToRx+0x40>
        macHdr = (TCPIP_MAC_ETHERNET_HEADER*)pRxPkt->pMacLayer;
   1aa58:	6969      	ldr	r1, [r5, #20]
        memcpy(&macHdr->DestMACAddr, &macHdr->SourceMACAddr, sizeof(TCPIP_MAC_ADDR));
   1aa5a:	460a      	mov	r2, r1
   1aa5c:	f852 3f06 	ldr.w	r3, [r2, #6]!
   1aa60:	600b      	str	r3, [r1, #0]
   1aa62:	8893      	ldrh	r3, [r2, #4]
   1aa64:	808b      	strh	r3, [r1, #4]
        memcpy(&macHdr->SourceMACAddr, _TCPIPStack_NetMACAddressGet((TCPIP_NET_IF*)pRxPkt->pktIf), sizeof(TCPIP_MAC_ADDR));
   1aa66:	6aab      	ldr	r3, [r5, #40]	; 0x28
    return pNetIf ? pNetIf->netMACAddr.v : 0;
   1aa68:	b103      	cbz	r3, 1aa6c <TCPIP_IPV4_MacPacketSwitchTxToRx+0x70>
   1aa6a:	333c      	adds	r3, #60	; 0x3c
   1aa6c:	6818      	ldr	r0, [r3, #0]
   1aa6e:	f8c1 0006 	str.w	r0, [r1, #6]
   1aa72:	889b      	ldrh	r3, [r3, #4]
   1aa74:	8093      	strh	r3, [r2, #4]
        pRxPkt->pDSeg->segLen += sizeof(TCPIP_MAC_ETHERNET_HEADER);
   1aa76:	692a      	ldr	r2, [r5, #16]
   1aa78:	8993      	ldrh	r3, [r2, #12]
   1aa7a:	330e      	adds	r3, #14
   1aa7c:	8193      	strh	r3, [r2, #12]
   1aa7e:	e7de      	b.n	1aa3e <TCPIP_IPV4_MacPacketSwitchTxToRx+0x42>

Disassembly of section .text.TCPIP_STACK_NetAddressSet%442:

0001aa80 <TCPIP_STACK_NetAddressSet>:
{
   1aa80:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1aa84:	4604      	mov	r4, r0
   1aa86:	460f      	mov	r7, r1
   1aa88:	4690      	mov	r8, r2
   1aa8a:	4699      	mov	r9, r3
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1aa8c:	2000      	movs	r0, #0
   1aa8e:	f008 fe71 	bl	23774 <OSAL_CRIT_Enter>
   1aa92:	4605      	mov	r5, r0
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   1aa94:	b124      	cbz	r4, 1aaa0 <TCPIP_STACK_NetAddressSet+0x20>
   1aa96:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   1aa9a:	f013 0f40 	tst.w	r3, #64	; 0x40
   1aa9e:	d105      	bne.n	1aaac <TCPIP_STACK_NetAddressSet+0x2c>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1aaa0:	4629      	mov	r1, r5
   1aaa2:	2000      	movs	r0, #0
   1aaa4:	f008 ffa0 	bl	239e8 <OSAL_CRIT_Leave>
   1aaa8:	2600      	movs	r6, #0
   1aaaa:	e028      	b.n	1aafe <TCPIP_STACK_NetAddressSet+0x7e>
    if(pNetIf != 0 && TCPIP_STACK_AddressServiceCanStart(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_NONE))
   1aaac:	2100      	movs	r1, #0
   1aaae:	4620      	mov	r0, r4
   1aab0:	f008 ff79 	bl	239a6 <TCPIP_STACK_AddressServiceCanStart>
   1aab4:	4606      	mov	r6, r0
   1aab6:	2800      	cmp	r0, #0
   1aab8:	d0f2      	beq.n	1aaa0 <TCPIP_STACK_NetAddressSet+0x20>
    if(ipAddress)
   1aaba:	b16f      	cbz	r7, 1aad8 <TCPIP_STACK_NetAddressSet+0x58>
        pNetIf->netIPAddr.Val = ipAddress->Val;
   1aabc:	683b      	ldr	r3, [r7, #0]
   1aabe:	6063      	str	r3, [r4, #4]
        if(setDefault)
   1aac0:	f1b9 0f00 	cmp.w	r9, #0
   1aac4:	d008      	beq.n	1aad8 <TCPIP_STACK_NetAddressSet+0x58>
            pNetIf->DefaultIPAddr.Val = ipAddress->Val;
   1aac6:	61a3      	str	r3, [r4, #24]
    if(mask)
   1aac8:	f1b8 0f00 	cmp.w	r8, #0
   1aacc:	d00d      	beq.n	1aaea <TCPIP_STACK_NetAddressSet+0x6a>
        pNetIf->netMask.Val = mask->Val;
   1aace:	f8d8 3000 	ldr.w	r3, [r8]
   1aad2:	60a3      	str	r3, [r4, #8]
            pNetIf->DefaultMask.Val = mask->Val;
   1aad4:	61e3      	str	r3, [r4, #28]
   1aad6:	e008      	b.n	1aaea <TCPIP_STACK_NetAddressSet+0x6a>
    if(mask)
   1aad8:	f1b8 0f00 	cmp.w	r8, #0
   1aadc:	d005      	beq.n	1aaea <TCPIP_STACK_NetAddressSet+0x6a>
        pNetIf->netMask.Val = mask->Val;
   1aade:	f8d8 3000 	ldr.w	r3, [r8]
   1aae2:	60a3      	str	r3, [r4, #8]
        if(setDefault)
   1aae4:	f1b9 0f00 	cmp.w	r9, #0
   1aae8:	d1f4      	bne.n	1aad4 <TCPIP_STACK_NetAddressSet+0x54>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1aaea:	4629      	mov	r1, r5
   1aaec:	2000      	movs	r0, #0
   1aaee:	f008 ff7b 	bl	239e8 <OSAL_CRIT_Leave>
    pNetIf->Flags.bInConfig = config;
   1aaf2:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   1aaf6:	f36f 1304 	bfc	r3, #4, #1
   1aafa:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
}
   1aafe:	4630      	mov	r0, r6
   1ab00:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

Disassembly of section .text._TCPIP_PKT_PacketAlloc%443:

0001ab04 <_TCPIP_PKT_PacketAlloc>:

#else
// regular allocation functions, non-debug
// they don't take a module Id parameter; otherwise exactly the same functions
TCPIP_MAC_PACKET* _TCPIP_PKT_PacketAlloc(uint16_t pktLen, uint16_t segLoadLen, TCPIP_MAC_PACKET_FLAGS flags)
{
   1ab04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1ab08:	4688      	mov	r8, r1
   1ab0a:	4617      	mov	r7, r2
    if(pktLen < sizeof(TCPIP_MAC_PACKET))
    {
        pktLen = sizeof(TCPIP_MAC_PACKET);
    }

    pktUpLen = (((pktLen + 3) >> 2) << 2);     // 32 bits round up
   1ab0c:	2834      	cmp	r0, #52	; 0x34
   1ab0e:	bf38      	it	cc
   1ab10:	2034      	movcc	r0, #52	; 0x34
   1ab12:	1cc3      	adds	r3, r0, #3
   1ab14:	f023 0303 	bic.w	r3, r3, #3
   1ab18:	b29c      	uxth	r4, r3
    // segment size, multiple of cache line size
    segAlignSize = ((segLoadLen + sizeof(TCPIP_MAC_ETHERNET_HEADER) + TCPIP_SEGMENT_CACHE_ALIGN_SIZE  - 1) / TCPIP_SEGMENT_CACHE_ALIGN_SIZE) * TCPIP_SEGMENT_CACHE_ALIGN_SIZE;
   1ab1a:	f101 051d 	add.w	r5, r1, #29
   1ab1e:	f025 050f 	bic.w	r5, r5, #15
   1ab22:	b2ad      	uxth	r5, r5
    // segment allocation size, extra cache line so that the segBuffer can start on a cache line boundary
    segAllocSize = segAlignSize + _TCPIP_MAC_DATA_SEGMENT_GAP_SIZE + TCPIP_MAC_PAYLOAD_OFFSET + TCPIP_SEGMENT_CACHE_ALIGN_SIZE; 
    // total allocation size
    allocLen = pktUpLen + sizeof(*pSeg) + segAllocSize;

    pPkt = (TCPIP_MAC_PACKET*)TCPIP_HEAP_Malloc(pktMemH, allocLen);
   1ab24:	4b17      	ldr	r3, [pc, #92]	; (1ab84 <_TCPIP_PKT_PacketAlloc+0x80>)
   1ab26:	6818      	ldr	r0, [r3, #0]
    allocLen = pktUpLen + sizeof(*pSeg) + segAllocSize;
   1ab28:	f105 0132 	add.w	r1, r5, #50	; 0x32
   1ab2c:	4421      	add	r1, r4
    pPkt = (TCPIP_MAC_PACKET*)TCPIP_HEAP_Malloc(pktMemH, allocLen);
   1ab2e:	b289      	uxth	r1, r1
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
   1ab30:	6843      	ldr	r3, [r0, #4]
   1ab32:	4798      	blx	r3

    if(pPkt)
   1ab34:	4606      	mov	r6, r0
   1ab36:	b308      	cbz	r0, 1ab7c <_TCPIP_PKT_PacketAlloc+0x78>
    {   
        // clear the TCPIP_MAC_PACKET and 1st segment fields
        // populate the 1st segment
        memset(pPkt, 0, pktUpLen + sizeof(*pSeg));
   1ab38:	f104 0218 	add.w	r2, r4, #24
   1ab3c:	2100      	movs	r1, #0
   1ab3e:	f009 f9af 	bl	23ea0 <memset>
        pSeg = (TCPIP_MAC_DATA_SEGMENT*)((uint8_t*)pPkt + pktUpLen);
   1ab42:	4434      	add	r4, r6

        pSeg->segSize = segAlignSize;
   1ab44:	81e5      	strh	r5, [r4, #14]
    segAllocSize = segAlignSize + _TCPIP_MAC_DATA_SEGMENT_GAP_SIZE + TCPIP_MAC_PAYLOAD_OFFSET + TCPIP_SEGMENT_CACHE_ALIGN_SIZE; 
   1ab46:	351a      	adds	r5, #26
        pSeg->segAllocSize = segAllocSize;
   1ab48:	8265      	strh	r5, [r4, #18]
        pSeg->segBuffer = (uint8_t*)(pSeg + 1) + _TCPIP_MAC_DATA_SEGMENT_GAP_SIZE;
        // cache-align the data segment
        pSeg->segBuffer = (uint8_t*)((((uint32_t)pSeg->segBuffer + TCPIP_SEGMENT_CACHE_ALIGN_SIZE - 1) / TCPIP_SEGMENT_CACHE_ALIGN_SIZE) * TCPIP_SEGMENT_CACHE_ALIGN_SIZE);
   1ab4a:	f104 022f 	add.w	r2, r4, #47	; 0x2f
   1ab4e:	f022 020f 	bic.w	r2, r2, #15
   1ab52:	6062      	str	r2, [r4, #4]
        // set the pointer to the packet that segment belongs to
        TCPIP_MAC_SEGMENT_GAP_DCPT* pGap = (TCPIP_MAC_SEGMENT_GAP_DCPT*)(pSeg->segBuffer + _TCPIP_MAC_GAP_OFFSET);
        pGap->segmentPktPtr = pPkt;
   1ab54:	f842 6c08 	str.w	r6, [r2, #-8]

        pSeg->segFlags = TCPIP_MAC_SEG_FLAG_STATIC; // embedded in TCPIP_MAC_PACKET itself
   1ab58:	2201      	movs	r2, #1
   1ab5a:	8222      	strh	r2, [r4, #16]
        pPkt->pDSeg = pSeg;
   1ab5c:	6134      	str	r4, [r6, #16]

        pSeg->segLoad = pSeg->segBuffer + TCPIP_MAC_PAYLOAD_OFFSET;
   1ab5e:	6862      	ldr	r2, [r4, #4]
   1ab60:	1c91      	adds	r1, r2, #2
   1ab62:	60a1      	str	r1, [r4, #8]
        pPkt->pMacLayer = pSeg->segLoad;
   1ab64:	6171      	str	r1, [r6, #20]
        pPkt->pktFlags = flags & (~TCPIP_MAC_PKT_FLAG_STATIC);  // this packet is dynamically allocated
   1ab66:	f027 0701 	bic.w	r7, r7, #1
   1ab6a:	8477      	strh	r7, [r6, #34]	; 0x22
        if(segLoadLen)
   1ab6c:	f1b8 0f00 	cmp.w	r8, #0
   1ab70:	d001      	beq.n	1ab76 <_TCPIP_PKT_PacketAlloc+0x72>
        {
            pPkt->pNetLayer = pPkt->pMacLayer + sizeof(TCPIP_MAC_ETHERNET_HEADER);
   1ab72:	3210      	adds	r2, #16
   1ab74:	61b2      	str	r2, [r6, #24]
        }
        pPkt->pktPriority = 0; // set the default priority
   1ab76:	2300      	movs	r3, #0
   1ab78:	f886 302d 	strb.w	r3, [r6, #45]	; 0x2d

    }

    return pPkt;
}
   1ab7c:	4630      	mov	r0, r6
   1ab7e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1ab82:	bf00      	nop
   1ab84:	2000ee84 	.word	0x2000ee84

Disassembly of section .text.gfx_mono_print_scroll%444:

0001ab88 <gfx_mono_print_scroll>:

extern struct font sysfont;

#define PRINT_BUFF (256)

void gfx_mono_print_scroll(const char* format, ...) {
   1ab88:	b40f      	push	{r0, r1, r2, r3}
   1ab8a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1ab8e:	b0cb      	sub	sp, #300	; 0x12c
   1ab90:	ab52      	add	r3, sp, #328	; 0x148
   1ab92:	f853 2b04 	ldr.w	r2, [r3], #4
    char OutputBuffer[PRINT_BUFF];
    char LinePrintBuffer[22];
    int ix;
    size_t len = 0;
    va_list args = {0};
    va_start(args, format);
   1ab96:	9303      	str	r3, [sp, #12]
    len = vsnprintf(OutputBuffer, PRINT_BUFF, format, args);
   1ab98:	f44f 7180 	mov.w	r1, #256	; 0x100
   1ab9c:	a80a      	add	r0, sp, #40	; 0x28
   1ab9e:	f008 fbc1 	bl	23324 <vsniprintf>
    va_end(args);

    for (ix = 0; ix < len; ix += 21) {
   1aba2:	b358      	cbz	r0, 1abfc <gfx_mono_print_scroll+0x74>
   1aba4:	4681      	mov	r9, r0
   1aba6:	4606      	mov	r6, r0
   1aba8:	ad0a      	add	r5, sp, #40	; 0x28
   1abaa:	2400      	movs	r4, #0
        gfx_mono_scroll_Line_6x7();
        memset(LinePrintBuffer, 0x20, 22);
        int temp_len;
        if (len > 21) {
            temp_len = 21;
   1abac:	f04f 0815 	mov.w	r8, #21
            }
        } else {
            temp_len = len;
        }
        memcpy(LinePrintBuffer, &OutputBuffer[ix], temp_len);
        gfx_mono_draw_string_n(LinePrintBuffer, 21, 0, 24, &sysfont);
   1abb0:	4f15      	ldr	r7, [pc, #84]	; (1ac08 <gfx_mono_print_scroll+0x80>)
   1abb2:	e00f      	b.n	1abd4 <gfx_mono_print_scroll+0x4c>
            temp_len = len;
   1abb4:	464a      	mov	r2, r9
        memcpy(LinePrintBuffer, &OutputBuffer[ix], temp_len);
   1abb6:	4629      	mov	r1, r5
   1abb8:	a804      	add	r0, sp, #16
   1abba:	f008 fb97 	bl	232ec <memcpy>
        gfx_mono_draw_string_n(LinePrintBuffer, 21, 0, 24, &sysfont);
   1abbe:	9700      	str	r7, [sp, #0]
   1abc0:	2318      	movs	r3, #24
   1abc2:	2200      	movs	r2, #0
   1abc4:	4641      	mov	r1, r8
   1abc6:	a804      	add	r0, sp, #16
   1abc8:	f000 fcda 	bl	1b580 <gfx_mono_draw_string_n>
    for (ix = 0; ix < len; ix += 21) {
   1abcc:	3415      	adds	r4, #21
   1abce:	3515      	adds	r5, #21
   1abd0:	42a6      	cmp	r6, r4
   1abd2:	d913      	bls.n	1abfc <gfx_mono_print_scroll+0x74>
        gfx_mono_scroll_Line_6x7();
   1abd4:	f006 f964 	bl	20ea0 <gfx_mono_scroll_Line_6x7>
        memset(LinePrintBuffer, 0x20, 22);
   1abd8:	f04f 3320 	mov.w	r3, #538976288	; 0x20202020
   1abdc:	9304      	str	r3, [sp, #16]
   1abde:	9305      	str	r3, [sp, #20]
   1abe0:	9306      	str	r3, [sp, #24]
   1abe2:	9307      	str	r3, [sp, #28]
   1abe4:	9308      	str	r3, [sp, #32]
   1abe6:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
        if (len > 21) {
   1abea:	2e15      	cmp	r6, #21
   1abec:	d9e2      	bls.n	1abb4 <gfx_mono_print_scroll+0x2c>
            if (ix > 0) {
   1abee:	2c00      	cmp	r4, #0
   1abf0:	dd02      	ble.n	1abf8 <gfx_mono_print_scroll+0x70>
                temp_len = len - 21;
   1abf2:	f1a6 0215 	sub.w	r2, r6, #21
   1abf6:	e7de      	b.n	1abb6 <gfx_mono_print_scroll+0x2e>
            temp_len = 21;
   1abf8:	4642      	mov	r2, r8
   1abfa:	e7dc      	b.n	1abb6 <gfx_mono_print_scroll+0x2e>
    }
}
   1abfc:	b04b      	add	sp, #300	; 0x12c
   1abfe:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1ac02:	b004      	add	sp, #16
   1ac04:	4770      	bx	lr
   1ac06:	bf00      	nop
   1ac08:	2000ed70 	.word	0x2000ed70

Disassembly of section .text.DRV_PIC32CGMAC_LibTxAckErrPacket%445:

0001ac0c <DRV_PIC32CGMAC_LibTxAckErrPacket>:
{
   1ac0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ac10:	b083      	sub	sp, #12
    DRV_PIC32CGMAC_HW_TXDCPT *pTxDesc = pMACDrv->sGmacData.gmac_queue[queueIdx].pTxDesc;
   1ac12:	4688      	mov	r8, r1
   1ac14:	232c      	movs	r3, #44	; 0x2c
   1ac16:	fb03 0101 	mla	r1, r3, r1, r0
   1ac1a:	f8d1 70a0 	ldr.w	r7, [r1, #160]	; 0xa0
	uint16_t tailIndex = pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail;
   1ac1e:	f8b1 40b4 	ldrh.w	r4, [r1, #180]	; 0xb4
	uint16_t headIndex = pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescHead;
   1ac22:	f8b1 90b2 	ldrh.w	r9, [r1, #178]	; 0xb2
	while(tailIndex != headIndex)
   1ac26:	454c      	cmp	r4, r9
   1ac28:	d02e      	beq.n	1ac88 <DRV_PIC32CGMAC_LibTxAckErrPacket+0x7c>
   1ac2a:	9201      	str	r2, [sp, #4]
   1ac2c:	4606      	mov	r6, r0
        (pMACDrv->sGmacData.pktAckF)(pPkt, ackRes, TCPIP_THIS_MODULE_ID);	
   1ac2e:	f241 0b50 	movw	fp, #4176	; 0x1050
        pTxDesc[tailIndex].tx_desc_buffaddr = 0;
   1ac32:	f04f 0a00 	mov.w	sl, #0
        GCIRC_INC(tailIndex, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt);  
   1ac36:	eb08 08c8 	add.w	r8, r8, r8, lsl #3
   1ac3a:	eb00 0848 	add.w	r8, r0, r8, lsl #1
        pbuff = (uint8_t*)((uint32_t)pTxDesc[tailIndex].tx_desc_buffaddr & pMACDrv->sGmacData._dataOffsetMask);
   1ac3e:	eb07 05c4 	add.w	r5, r7, r4, lsl #3
   1ac42:	f857 3034 	ldr.w	r3, [r7, r4, lsl #3]
   1ac46:	f8d6 20f0 	ldr.w	r2, [r6, #240]	; 0xf0
   1ac4a:	4013      	ands	r3, r2
        TCPIP_MAC_SEGMENT_GAP_DCPT* pGap = (TCPIP_MAC_SEGMENT_GAP_DCPT*)(pbuff + pMACDrv->sGmacData._dcptOffset);
   1ac4c:	f9b6 20ec 	ldrsh.w	r2, [r6, #236]	; 0xec
        pPkt = pGap->segmentPktPtr;
   1ac50:	5898      	ldr	r0, [r3, r2]
        pPkt->pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED;
   1ac52:	8c43      	ldrh	r3, [r0, #34]	; 0x22
   1ac54:	f023 0308 	bic.w	r3, r3, #8
   1ac58:	8443      	strh	r3, [r0, #34]	; 0x22
        (pMACDrv->sGmacData.pktAckF)(pPkt, ackRes, TCPIP_THIS_MODULE_ID);	
   1ac5a:	6af3      	ldr	r3, [r6, #44]	; 0x2c
   1ac5c:	465a      	mov	r2, fp
   1ac5e:	9901      	ldr	r1, [sp, #4]
   1ac60:	4798      	blx	r3
        pTxDesc[tailIndex].tx_desc_status.val &= GMAC_TX_WRAP_BIT;
   1ac62:	686b      	ldr	r3, [r5, #4]
   1ac64:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
   1ac68:	606b      	str	r3, [r5, #4]
        pTxDesc[tailIndex].tx_desc_status.val |= GMAC_TX_USED_BIT | GMAC_TX_LAST_BUFFER_BIT;
   1ac6a:	686b      	ldr	r3, [r5, #4]
   1ac6c:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
   1ac70:	606b      	str	r3, [r5, #4]
        pTxDesc[tailIndex].tx_desc_buffaddr = 0;
   1ac72:	f847 a034 	str.w	sl, [r7, r4, lsl #3]
        GCIRC_INC(tailIndex, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt);  
   1ac76:	3401      	adds	r4, #1
   1ac78:	b2a4      	uxth	r4, r4
   1ac7a:	f8b8 30c8 	ldrh.w	r3, [r8, #200]	; 0xc8
   1ac7e:	42a3      	cmp	r3, r4
   1ac80:	bf98      	it	ls
   1ac82:	2400      	movls	r4, #0
	while(tailIndex != headIndex)
   1ac84:	454c      	cmp	r4, r9
   1ac86:	d1da      	bne.n	1ac3e <DRV_PIC32CGMAC_LibTxAckErrPacket+0x32>
}
   1ac88:	b003      	add	sp, #12
   1ac8a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

Disassembly of section .text._DNS_ValidateIf%446:

0001ac8e <_DNS_ValidateIf>:
{
   1ac8e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1ac90:	4604      	mov	r4, r0
   1ac92:	460d      	mov	r5, r1
   1ac94:	4616      	mov	r6, r2
    if(_DNS_NetIsValid(pIf))
   1ac96:	f005 fe5b 	bl	20950 <_DNS_NetIsValid>
   1ac9a:	4607      	mov	r7, r0
   1ac9c:	b1a8      	cbz	r0, 1acca <_DNS_ValidateIf+0x3c>
        if(pDnsHE->currNet == pIf)
   1ac9e:	69eb      	ldr	r3, [r5, #28]
   1aca0:	42a3      	cmp	r3, r4
   1aca2:	d014      	beq.n	1acce <_DNS_ValidateIf+0x40>
            startIx = 0;
   1aca4:	2000      	movs	r0, #0
            if(pIf->dnsServer[ix].Val != 0)
   1aca6:	1d03      	adds	r3, r0, #4
   1aca8:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
   1acac:	bb73      	cbnz	r3, 1ad0c <_DNS_ValidateIf+0x7e>
   1acae:	1d42      	adds	r2, r0, #5
   1acb0:	eb04 0282 	add.w	r2, r4, r2, lsl #2
   1acb4:	4603      	mov	r3, r0
        for(ix = startIx; ix < sizeof(pIf->dnsServer) / sizeof(*pIf->dnsServer); ix++)
   1acb6:	3301      	adds	r3, #1
   1acb8:	2b01      	cmp	r3, #1
   1acba:	d80f      	bhi.n	1acdc <_DNS_ValidateIf+0x4e>
            if(pIf->dnsServer[ix].Val != 0)
   1acbc:	f852 1b04 	ldr.w	r1, [r2], #4
   1acc0:	2900      	cmp	r1, #0
   1acc2:	d0f8      	beq.n	1acb6 <_DNS_ValidateIf+0x28>
            pDnsHE->currNet = pIf;
   1acc4:	61ec      	str	r4, [r5, #28]
            pDnsHE->currServerIx = ix;
   1acc6:	f885 3029 	strb.w	r3, [r5, #41]	; 0x29
}
   1acca:	4638      	mov	r0, r7
   1accc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            startIx = (pDnsHE->currRetry == 0) ? pDnsHE->currServerIx : pDnsHE->currServerIx + 1;
   1acce:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
   1acd2:	b933      	cbnz	r3, 1ace2 <_DNS_ValidateIf+0x54>
   1acd4:	f895 0029 	ldrb.w	r0, [r5, #41]	; 0x29
        for(ix = startIx; ix < sizeof(pIf->dnsServer) / sizeof(*pIf->dnsServer); ix++)
   1acd8:	2801      	cmp	r0, #1
   1acda:	d9e4      	bls.n	1aca6 <_DNS_ValidateIf+0x18>
        if(!srvFound && wrapAround) 
   1acdc:	b92e      	cbnz	r6, 1acea <_DNS_ValidateIf+0x5c>
    return false;
   1acde:	4637      	mov	r7, r6
   1ace0:	e7f3      	b.n	1acca <_DNS_ValidateIf+0x3c>
            startIx = (pDnsHE->currRetry == 0) ? pDnsHE->currServerIx : pDnsHE->currServerIx + 1;
   1ace2:	f895 0029 	ldrb.w	r0, [r5, #41]	; 0x29
   1ace6:	3001      	adds	r0, #1
   1ace8:	e7f6      	b.n	1acd8 <_DNS_ValidateIf+0x4a>
            for(ix = 0; ix < startIx; ix++)
   1acea:	b138      	cbz	r0, 1acfc <_DNS_ValidateIf+0x6e>
                if(pIf->dnsServer[ix].Val != 0)
   1acec:	6923      	ldr	r3, [r4, #16]
   1acee:	b94b      	cbnz	r3, 1ad04 <_DNS_ValidateIf+0x76>
            for(ix = 0; ix < startIx; ix++)
   1acf0:	2801      	cmp	r0, #1
   1acf2:	dd05      	ble.n	1ad00 <_DNS_ValidateIf+0x72>
                if(pIf->dnsServer[ix].Val != 0)
   1acf4:	6963      	ldr	r3, [r4, #20]
   1acf6:	b93b      	cbnz	r3, 1ad08 <_DNS_ValidateIf+0x7a>
    return false;
   1acf8:	2700      	movs	r7, #0
   1acfa:	e7e6      	b.n	1acca <_DNS_ValidateIf+0x3c>
   1acfc:	2700      	movs	r7, #0
   1acfe:	e7e4      	b.n	1acca <_DNS_ValidateIf+0x3c>
   1ad00:	2700      	movs	r7, #0
   1ad02:	e7e2      	b.n	1acca <_DNS_ValidateIf+0x3c>
            for(ix = 0; ix < startIx; ix++)
   1ad04:	2300      	movs	r3, #0
   1ad06:	e7dd      	b.n	1acc4 <_DNS_ValidateIf+0x36>
   1ad08:	2301      	movs	r3, #1
   1ad0a:	e7db      	b.n	1acc4 <_DNS_ValidateIf+0x36>
            if(pIf->dnsServer[ix].Val != 0)
   1ad0c:	4603      	mov	r3, r0
        if(!srvFound && wrapAround) 
   1ad0e:	e7d9      	b.n	1acc4 <_DNS_ValidateIf+0x36>

Disassembly of section .text.TCPIP_Helper_PacketChecksum%447:

0001ad10 <TCPIP_Helper_PacketChecksum>:
    uint8_t* pChkBuff;
    uint16_t checkLength, chkBytes, nBytes;
    uint16_t segChkSum;
    uint32_t calcChkSum;

    if(len == 0)
   1ad10:	b90a      	cbnz	r2, 1ad16 <TCPIP_Helper_PacketChecksum+0x6>
        }
#endif  // defined(TCPIP_IPV4_FRAGMENTATION) && (TCPIP_IPV4_FRAGMENTATION != 0)
    }

    return ~TCPIP_Helper_ChecksumFold(calcChkSum);
}
   1ad12:	4618      	mov	r0, r3
   1ad14:	4770      	bx	lr
{
   1ad16:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1ad1a:	460f      	mov	r7, r1
   1ad1c:	4616      	mov	r6, r2
    calcChkSum = seed;
   1ad1e:	4698      	mov	r8, r3
    pSeg = TCPIP_PKT_DataSegmentGet(pPkt, startAdd, true);
   1ad20:	2201      	movs	r2, #1
   1ad22:	f001 f97f 	bl	1c024 <TCPIP_PKT_DataSegmentGet>
    while(pSeg != 0 && checkLength != 0)
   1ad26:	4605      	mov	r5, r0
   1ad28:	b358      	cbz	r0, 1ad82 <TCPIP_Helper_PacketChecksum+0x72>
    nBytes = 0;
   1ad2a:	f04f 0900 	mov.w	r9, #0
            segChkSum = ~TCPIP_Helper_CalcIPChecksum(pChkBuff, chkBytes, 0);
   1ad2e:	46ca      	mov	sl, r9
   1ad30:	e009      	b.n	1ad46 <TCPIP_Helper_PacketChecksum+0x36>
            checkLength -= chkBytes;
   1ad32:	1b36      	subs	r6, r6, r4
   1ad34:	b2b6      	uxth	r6, r6
            nBytes += chkBytes;
   1ad36:	44a1      	add	r9, r4
   1ad38:	fa1f f989 	uxth.w	r9, r9
            calcChkSum += segChkSum;
   1ad3c:	4480      	add	r8, r0
        if((pSeg = pSeg->next) != 0)
   1ad3e:	682d      	ldr	r5, [r5, #0]
   1ad40:	b1fd      	cbz	r5, 1ad82 <TCPIP_Helper_PacketChecksum+0x72>
            pChkBuff = pSeg->segLoad;
   1ad42:	68af      	ldr	r7, [r5, #8]
    while(pSeg != 0 && checkLength != 0)
   1ad44:	b1ee      	cbz	r6, 1ad82 <TCPIP_Helper_PacketChecksum+0x72>
        chkBytes = (pSeg->segLoad + pSeg->segSize) - pChkBuff;
   1ad46:	89eb      	ldrh	r3, [r5, #14]
   1ad48:	68ac      	ldr	r4, [r5, #8]
   1ad4a:	441c      	add	r4, r3
   1ad4c:	1be4      	subs	r4, r4, r7
   1ad4e:	b2a4      	uxth	r4, r4
        if( pSeg->segLen && (chkBytes > pSeg->segLen) )
   1ad50:	89ab      	ldrh	r3, [r5, #12]
   1ad52:	b113      	cbz	r3, 1ad5a <TCPIP_Helper_PacketChecksum+0x4a>
   1ad54:	429c      	cmp	r4, r3
   1ad56:	bf28      	it	cs
   1ad58:	461c      	movcs	r4, r3
        if(chkBytes > checkLength)
   1ad5a:	42b4      	cmp	r4, r6
   1ad5c:	bf28      	it	cs
   1ad5e:	4634      	movcs	r4, r6
        if(chkBytes)
   1ad60:	2c00      	cmp	r4, #0
   1ad62:	d0ec      	beq.n	1ad3e <TCPIP_Helper_PacketChecksum+0x2e>
            segChkSum = ~TCPIP_Helper_CalcIPChecksum(pChkBuff, chkBytes, 0);
   1ad64:	4652      	mov	r2, sl
   1ad66:	4621      	mov	r1, r4
   1ad68:	4638      	mov	r0, r7
   1ad6a:	f001 fa75 	bl	1c258 <TCPIP_Helper_CalcIPChecksum>
   1ad6e:	43c0      	mvns	r0, r0
   1ad70:	b280      	uxth	r0, r0
            if((nBytes & 0x1) != 0)
   1ad72:	f019 0f01 	tst.w	r9, #1
   1ad76:	d0dc      	beq.n	1ad32 <TCPIP_Helper_PacketChecksum+0x22>
   1ad78:	0a03      	lsrs	r3, r0, #8
   1ad7a:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
   1ad7e:	b280      	uxth	r0, r0
   1ad80:	e7d7      	b.n	1ad32 <TCPIP_Helper_PacketChecksum+0x22>
    return ~TCPIP_Helper_ChecksumFold(calcChkSum);
   1ad82:	4640      	mov	r0, r8
   1ad84:	f009 f8ca 	bl	23f1c <TCPIP_Helper_ChecksumFold>
   1ad88:	43c0      	mvns	r0, r0
   1ad8a:	b283      	uxth	r3, r0
}
   1ad8c:	4618      	mov	r0, r3
   1ad8e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

Disassembly of section .text.__fputwc%448:

0001ad92 <__fputwc>:
   1ad92:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   1ad96:	4680      	mov	r8, r0
   1ad98:	460e      	mov	r6, r1
   1ad9a:	4614      	mov	r4, r2
   1ad9c:	f009 fa9a 	bl	242d4 <__locale_mb_cur_max>
   1ada0:	2801      	cmp	r0, #1
   1ada2:	d10e      	bne.n	1adc2 <__fputwc+0x30>
   1ada4:	1e73      	subs	r3, r6, #1
   1ada6:	2bfe      	cmp	r3, #254	; 0xfe
   1ada8:	d80b      	bhi.n	1adc2 <__fputwc+0x30>
   1adaa:	f88d 6004 	strb.w	r6, [sp, #4]
   1adae:	4605      	mov	r5, r0
   1adb0:	2700      	movs	r7, #0
   1adb2:	f10d 0904 	add.w	r9, sp, #4
   1adb6:	42af      	cmp	r7, r5
   1adb8:	d113      	bne.n	1ade2 <__fputwc+0x50>
   1adba:	4630      	mov	r0, r6
   1adbc:	b003      	add	sp, #12
   1adbe:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1adc2:	4632      	mov	r2, r6
   1adc4:	f104 0358 	add.w	r3, r4, #88	; 0x58
   1adc8:	a901      	add	r1, sp, #4
   1adca:	4640      	mov	r0, r8
   1adcc:	f006 ff46 	bl	21c5c <_wcrtomb_r>
   1add0:	1c42      	adds	r2, r0, #1
   1add2:	4605      	mov	r5, r0
   1add4:	d1ec      	bne.n	1adb0 <__fputwc+0x1e>
   1add6:	89a3      	ldrh	r3, [r4, #12]
   1add8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1addc:	81a3      	strh	r3, [r4, #12]
   1adde:	4606      	mov	r6, r0
   1ade0:	e7eb      	b.n	1adba <__fputwc+0x28>
   1ade2:	68a3      	ldr	r3, [r4, #8]
   1ade4:	f817 1009 	ldrb.w	r1, [r7, r9]
   1ade8:	3b01      	subs	r3, #1
   1adea:	2b00      	cmp	r3, #0
   1adec:	60a3      	str	r3, [r4, #8]
   1adee:	da04      	bge.n	1adfa <__fputwc+0x68>
   1adf0:	69a2      	ldr	r2, [r4, #24]
   1adf2:	4293      	cmp	r3, r2
   1adf4:	db07      	blt.n	1ae06 <__fputwc+0x74>
   1adf6:	290a      	cmp	r1, #10
   1adf8:	d005      	beq.n	1ae06 <__fputwc+0x74>
   1adfa:	6823      	ldr	r3, [r4, #0]
   1adfc:	1c5a      	adds	r2, r3, #1
   1adfe:	6022      	str	r2, [r4, #0]
   1ae00:	7019      	strb	r1, [r3, #0]
   1ae02:	3701      	adds	r7, #1
   1ae04:	e7d7      	b.n	1adb6 <__fputwc+0x24>
   1ae06:	4622      	mov	r2, r4
   1ae08:	4640      	mov	r0, r8
   1ae0a:	f7fd f867 	bl	17edc <__swbuf_r>
   1ae0e:	1c43      	adds	r3, r0, #1
   1ae10:	d1f7      	bne.n	1ae02 <__fputwc+0x70>
   1ae12:	e7e4      	b.n	1adde <__fputwc+0x4c>

Disassembly of section .text.DRV_ETHPHY_VendorSMIReadStart%449:

0001ae14 <DRV_ETHPHY_VendorSMIReadStart>:
}



DRV_ETHPHY_RESULT DRV_ETHPHY_VendorSMIReadStart( DRV_HANDLE handle, uint16_t rIx,  int phyAddress )
{
   1ae14:	b538      	push	{r3, r4, r5, lr}
    DRV_ETHPHY_SMI_TXFER_RES opRes;
    DRV_ETHPHY_CLIENT_OBJ * hClientObj = (DRV_ETHPHY_CLIENT_OBJ *) handle;

    if(hClientObj == 0 || _DRVHandleToInst(hClientObj->hDriver) == 0)
   1ae16:	b340      	cbz	r0, 1ae6a <DRV_ETHPHY_VendorSMIReadStart+0x56>
   1ae18:	4604      	mov	r4, r0
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1ae1a:	68c3      	ldr	r3, [r0, #12]
   1ae1c:	481c      	ldr	r0, [pc, #112]	; (1ae90 <DRV_ETHPHY_VendorSMIReadStart+0x7c>)
   1ae1e:	4283      	cmp	r3, r0
   1ae20:	d126      	bne.n	1ae70 <DRV_ETHPHY_VendorSMIReadStart+0x5c>
    {
        return DRV_ETHPHY_RES_HANDLE_ERR;
    }
    
    if( hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_BUSY || 
   1ae22:	f994 5008 	ldrsb.w	r5, [r4, #8]
   1ae26:	2d01      	cmp	r5, #1
   1ae28:	d126      	bne.n	1ae78 <DRV_ETHPHY_VendorSMIReadStart+0x64>
   1ae2a:	8ba0      	ldrh	r0, [r4, #28]
   1ae2c:	2801      	cmp	r0, #1
   1ae2e:	d126      	bne.n	1ae7e <DRV_ETHPHY_VendorSMIReadStart+0x6a>
        hClientObj->operType != DRV_ETHPHY_CLIENT_OP_TYPE_SETUP || 
   1ae30:	8be0      	ldrh	r0, [r4, #30]
   1ae32:	f020 0002 	bic.w	r0, r0, #2
   1ae36:	b280      	uxth	r0, r0
   1ae38:	2801      	cmp	r0, #1
   1ae3a:	d002      	beq.n	1ae42 <DRV_ETHPHY_VendorSMIReadStart+0x2e>
        (hClientObj->operPhase != DRV_ETHPHY_SETUP_PHASE_DETECT && hClientObj->operPhase != DRV_ETHPHY_SETUP_PHASE_NEGOTIATE))
    {   // not allowed
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   1ae3c:	f06f 0509 	mvn.w	r5, #9
   1ae40:	e018      	b.n	1ae74 <DRV_ETHPHY_VendorSMIReadStart+0x60>
    }

    if(hClientObj->smiTxferStatus != DRV_ETHPHY_SMI_TXFER_OP_NONE)
   1ae42:	8ea0      	ldrh	r0, [r4, #52]	; 0x34
   1ae44:	b9f0      	cbnz	r0, 1ae84 <DRV_ETHPHY_VendorSMIReadStart+0x70>
    hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_START;
   1ae46:	2301      	movs	r3, #1
   1ae48:	86a3      	strh	r3, [r4, #52]	; 0x34
    hClientObj->smiRIx = rIx;
   1ae4a:	8721      	strh	r1, [r4, #56]	; 0x38
    hClientObj->smiTxferType = DRV_ETHPHY_SMI_XFER_TYPE_READ;
   1ae4c:	2303      	movs	r3, #3
   1ae4e:	86e3      	strh	r3, [r4, #54]	; 0x36
    hClientObj->smiPhyAddress = phyAdd;
   1ae50:	63e2      	str	r2, [r4, #60]	; 0x3c
    return _DRV_PHY_SMITransferStart(hClientObj);
   1ae52:	4620      	mov	r0, r4
   1ae54:	f7fe fc14 	bl	19680 <_DRV_PHY_SMITransferStart>
        return DRV_ETHPHY_RES_OPERATION_ERR;
    }


    opRes = _DRV_PHY_SMIReadStartEx(hClientObj, rIx, phyAddress);
    if(opRes < 0)
   1ae58:	2800      	cmp	r0, #0
   1ae5a:	db16      	blt.n	1ae8a <DRV_ETHPHY_VendorSMIReadStart+0x76>
    {   // error occurred 
        return DRV_ETHPHY_RES_OPERATION_ERR;
    }
    else if(opRes == DRV_ETHPHY_SMI_TXFER_RES_BUSY)
   1ae5c:	2803      	cmp	r0, #3
   1ae5e:	d001      	beq.n	1ae64 <DRV_ETHPHY_VendorSMIReadStart+0x50>
        hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
        return DRV_ETHPHY_RES_PENDING;
    } 

    // went through
    return DRV_ETHPHY_RES_OK;
   1ae60:	2500      	movs	r5, #0
   1ae62:	e007      	b.n	1ae74 <DRV_ETHPHY_VendorSMIReadStart+0x60>
        hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
   1ae64:	2300      	movs	r3, #0
   1ae66:	86a3      	strh	r3, [r4, #52]	; 0x34
        return DRV_ETHPHY_RES_PENDING;
   1ae68:	e004      	b.n	1ae74 <DRV_ETHPHY_VendorSMIReadStart+0x60>
        return DRV_ETHPHY_RES_HANDLE_ERR;
   1ae6a:	f06f 050a 	mvn.w	r5, #10
   1ae6e:	e001      	b.n	1ae74 <DRV_ETHPHY_VendorSMIReadStart+0x60>
   1ae70:	f06f 050a 	mvn.w	r5, #10
}
   1ae74:	4628      	mov	r0, r5
   1ae76:	bd38      	pop	{r3, r4, r5, pc}
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   1ae78:	f06f 0509 	mvn.w	r5, #9
   1ae7c:	e7fa      	b.n	1ae74 <DRV_ETHPHY_VendorSMIReadStart+0x60>
   1ae7e:	f06f 0509 	mvn.w	r5, #9
   1ae82:	e7f7      	b.n	1ae74 <DRV_ETHPHY_VendorSMIReadStart+0x60>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   1ae84:	f06f 0508 	mvn.w	r5, #8
   1ae88:	e7f4      	b.n	1ae74 <DRV_ETHPHY_VendorSMIReadStart+0x60>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   1ae8a:	f06f 0508 	mvn.w	r5, #8
   1ae8e:	e7f1      	b.n	1ae74 <DRV_ETHPHY_VendorSMIReadStart+0x60>
   1ae90:	2000e7e8 	.word	0x2000e7e8

Disassembly of section .text.DRV_ETHPHY_VendorSMIWriteStart%450:

0001ae94 <DRV_ETHPHY_VendorSMIWriteStart>:
{
    DRV_ETHPHY_RESULT phyRes;
    DRV_ETHPHY_SMI_TXFER_RES opRes;
    DRV_ETHPHY_CLIENT_OBJ * hClientObj = (DRV_ETHPHY_CLIENT_OBJ *) handle;

    if(hClientObj == 0 || _DRVHandleToInst(hClientObj->hDriver) == 0)
   1ae94:	b348      	cbz	r0, 1aeea <DRV_ETHPHY_VendorSMIWriteStart+0x56>
{
   1ae96:	b538      	push	{r3, r4, r5, lr}
   1ae98:	4604      	mov	r4, r0
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1ae9a:	68c5      	ldr	r5, [r0, #12]
   1ae9c:	481c      	ldr	r0, [pc, #112]	; (1af10 <DRV_ETHPHY_VendorSMIWriteStart+0x7c>)
   1ae9e:	4285      	cmp	r5, r0
   1aea0:	d126      	bne.n	1aef0 <DRV_ETHPHY_VendorSMIWriteStart+0x5c>
    {
        return DRV_ETHPHY_RES_HANDLE_ERR;
    }

    
    if( hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_BUSY || 
   1aea2:	f994 0008 	ldrsb.w	r0, [r4, #8]
   1aea6:	2801      	cmp	r0, #1
   1aea8:	d125      	bne.n	1aef6 <DRV_ETHPHY_VendorSMIWriteStart+0x62>
   1aeaa:	8ba0      	ldrh	r0, [r4, #28]
   1aeac:	2801      	cmp	r0, #1
   1aeae:	d125      	bne.n	1aefc <DRV_ETHPHY_VendorSMIWriteStart+0x68>
        hClientObj->operType != DRV_ETHPHY_CLIENT_OP_TYPE_SETUP || 
   1aeb0:	8be0      	ldrh	r0, [r4, #30]
   1aeb2:	f020 0002 	bic.w	r0, r0, #2
   1aeb6:	b280      	uxth	r0, r0
   1aeb8:	2801      	cmp	r0, #1
   1aeba:	d002      	beq.n	1aec2 <DRV_ETHPHY_VendorSMIWriteStart+0x2e>
        (hClientObj->operPhase != DRV_ETHPHY_SETUP_PHASE_DETECT && hClientObj->operPhase != DRV_ETHPHY_SETUP_PHASE_NEGOTIATE))
    {   // not allowed
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   1aebc:	f06f 0009 	mvn.w	r0, #9
   1aec0:	e018      	b.n	1aef4 <DRV_ETHPHY_VendorSMIWriteStart+0x60>
    }

    if(hClientObj->smiTxferStatus != DRV_ETHPHY_SMI_TXFER_OP_NONE)
   1aec2:	8ea0      	ldrh	r0, [r4, #52]	; 0x34
   1aec4:	b9e8      	cbnz	r0, 1af02 <DRV_ETHPHY_VendorSMIWriteStart+0x6e>
    hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_START;
   1aec6:	2001      	movs	r0, #1
   1aec8:	86a0      	strh	r0, [r4, #52]	; 0x34
    hClientObj->smiRIx = rIx;
   1aeca:	8721      	strh	r1, [r4, #56]	; 0x38
    hClientObj->smiTxferType = DRV_ETHPHY_SMI_XFER_TYPE_WRITE;
   1aecc:	86e0      	strh	r0, [r4, #54]	; 0x36
    hClientObj->smiData =  wData;
   1aece:	8762      	strh	r2, [r4, #58]	; 0x3a
    hClientObj->smiPhyAddress = phyAdd;
   1aed0:	63e3      	str	r3, [r4, #60]	; 0x3c
   return  _DRV_PHY_SMITransferStart(hClientObj);
   1aed2:	4620      	mov	r0, r4
   1aed4:	f7fe fbd4 	bl	19680 <_DRV_PHY_SMITransferStart>
    {   // calling this before the previous SMI done?
        return DRV_ETHPHY_RES_OPERATION_ERR;
    }

    opRes = _DRV_PHY_SMIWriteStartEx(hClientObj, rIx, wData, phyAddress);
    if(opRes < 0)
   1aed8:	2800      	cmp	r0, #0
   1aeda:	db15      	blt.n	1af08 <DRV_ETHPHY_VendorSMIWriteStart+0x74>
        return DRV_ETHPHY_RES_OPERATION_ERR;
    }

    if(opRes == DRV_ETHPHY_SMI_TXFER_RES_BUSY)
    {   // retry
        phyRes = DRV_ETHPHY_RES_PENDING;
   1aedc:	2803      	cmp	r0, #3
   1aede:	bf14      	ite	ne
   1aee0:	2000      	movne	r0, #0
   1aee2:	2001      	moveq	r0, #1
    else
    {   // went through
        phyRes = DRV_ETHPHY_RES_OK;
    }

    hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
   1aee4:	2300      	movs	r3, #0
   1aee6:	86a3      	strh	r3, [r4, #52]	; 0x34


    return phyRes;
   1aee8:	e004      	b.n	1aef4 <DRV_ETHPHY_VendorSMIWriteStart+0x60>
        return DRV_ETHPHY_RES_HANDLE_ERR;
   1aeea:	f06f 000a 	mvn.w	r0, #10

}
   1aeee:	4770      	bx	lr
        return DRV_ETHPHY_RES_HANDLE_ERR;
   1aef0:	f06f 000a 	mvn.w	r0, #10
}
   1aef4:	bd38      	pop	{r3, r4, r5, pc}
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   1aef6:	f06f 0009 	mvn.w	r0, #9
   1aefa:	e7fb      	b.n	1aef4 <DRV_ETHPHY_VendorSMIWriteStart+0x60>
   1aefc:	f06f 0009 	mvn.w	r0, #9
   1af00:	e7f8      	b.n	1aef4 <DRV_ETHPHY_VendorSMIWriteStart+0x60>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   1af02:	f06f 0008 	mvn.w	r0, #8
   1af06:	e7f5      	b.n	1aef4 <DRV_ETHPHY_VendorSMIWriteStart+0x60>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   1af08:	f06f 0008 	mvn.w	r0, #8
   1af0c:	e7f2      	b.n	1aef4 <DRV_ETHPHY_VendorSMIWriteStart+0x60>
   1af0e:	bf00      	nop
   1af10:	2000e7e8 	.word	0x2000e7e8

Disassembly of section .text.SERCOM1_USART_Initialize%451:

0001af14 <SERCOM1_USART_Initialize>:
    SERCOM1_REGS->USART_INT.SERCOM_CTRLA = SERCOM_USART_INT_CTRLA_MODE_USART_INT_CLK | SERCOM_USART_INT_CTRLA_RXPO(0x1UL) | SERCOM_USART_INT_CTRLA_TXPO(0x0UL) | SERCOM_USART_INT_CTRLA_DORD_Msk | SERCOM_USART_INT_CTRLA_IBON_Msk | SERCOM_USART_INT_CTRLA_FORM(0x0UL) | SERCOM_USART_INT_CTRLA_SAMPR(0UL) ;
   1af14:	4b1c      	ldr	r3, [pc, #112]	; (1af88 <SERCOM1_USART_Initialize+0x74>)
   1af16:	4a1d      	ldr	r2, [pc, #116]	; (1af8c <SERCOM1_USART_Initialize+0x78>)
   1af18:	601a      	str	r2, [r3, #0]
    SERCOM1_REGS->USART_INT.SERCOM_BAUD = (uint16_t)SERCOM_USART_INT_BAUD_BAUD(SERCOM1_USART_INT_BAUD_VALUE);
   1af1a:	f64f 0222 	movw	r2, #63522	; 0xf822
   1af1e:	819a      	strh	r2, [r3, #12]
    SERCOM1_REGS->USART_INT.SERCOM_CTRLB = SERCOM_USART_INT_CTRLB_CHSIZE_8_BIT | SERCOM_USART_INT_CTRLB_SBMODE_1_BIT | SERCOM_USART_INT_CTRLB_RXEN_Msk | SERCOM_USART_INT_CTRLB_TXEN_Msk;
   1af20:	f44f 3240 	mov.w	r2, #196608	; 0x30000
   1af24:	605a      	str	r2, [r3, #4]
    while((SERCOM1_REGS->USART_INT.SERCOM_SYNCBUSY) != 0U)
   1af26:	461a      	mov	r2, r3
   1af28:	69d3      	ldr	r3, [r2, #28]
   1af2a:	2b00      	cmp	r3, #0
   1af2c:	d1fc      	bne.n	1af28 <SERCOM1_USART_Initialize+0x14>
    SERCOM1_REGS->USART_INT.SERCOM_CTRLA |= SERCOM_USART_INT_CTRLA_ENABLE_Msk;
   1af2e:	4a16      	ldr	r2, [pc, #88]	; (1af88 <SERCOM1_USART_Initialize+0x74>)
   1af30:	6813      	ldr	r3, [r2, #0]
   1af32:	f043 0302 	orr.w	r3, r3, #2
   1af36:	6013      	str	r3, [r2, #0]
    while((SERCOM1_REGS->USART_INT.SERCOM_SYNCBUSY) != 0U)
   1af38:	69d3      	ldr	r3, [r2, #28]
   1af3a:	2b00      	cmp	r3, #0
   1af3c:	d1fc      	bne.n	1af38 <SERCOM1_USART_Initialize+0x24>
    sercom1USARTObj.rdCallback = NULL;
   1af3e:	4b14      	ldr	r3, [pc, #80]	; (1af90 <SERCOM1_USART_Initialize+0x7c>)
   1af40:	2200      	movs	r2, #0
   1af42:	621a      	str	r2, [r3, #32]
    sercom1USARTObj.rdInIndex = 0U;
   1af44:	629a      	str	r2, [r3, #40]	; 0x28
    sercom1USARTObj.rdOutIndex = 0U;
   1af46:	62da      	str	r2, [r3, #44]	; 0x2c
    sercom1USARTObj.isRdNotificationEnabled = false;
   1af48:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    sercom1USARTObj.isRdNotifyPersistently = false;
   1af4c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    sercom1USARTObj.rdThreshold = 0U;
   1af50:	639a      	str	r2, [r3, #56]	; 0x38
    sercom1USARTObj.errorStatus = USART_ERROR_NONE;
   1af52:	87da      	strh	r2, [r3, #62]	; 0x3e
    sercom1USARTObj.wrCallback = NULL;
   1af54:	601a      	str	r2, [r3, #0]
    sercom1USARTObj.wrInIndex = 0U;
   1af56:	609a      	str	r2, [r3, #8]
    sercom1USARTObj.wrOutIndex = 0U;
   1af58:	60da      	str	r2, [r3, #12]
    sercom1USARTObj.isWrNotificationEnabled = false;
   1af5a:	751a      	strb	r2, [r3, #20]
    sercom1USARTObj.isWrNotifyPersistently = false;
   1af5c:	771a      	strb	r2, [r3, #28]
    sercom1USARTObj.wrThreshold = 0U;
   1af5e:	619a      	str	r2, [r3, #24]
    if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   1af60:	4b09      	ldr	r3, [pc, #36]	; (1af88 <SERCOM1_USART_Initialize+0x74>)
   1af62:	685b      	ldr	r3, [r3, #4]
   1af64:	f003 0307 	and.w	r3, r3, #7
   1af68:	2b01      	cmp	r3, #1
        sercom1USARTObj.rdBufferSize = SERCOM1_USART_READ_BUFFER_SIZE;
   1af6a:	4b09      	ldr	r3, [pc, #36]	; (1af90 <SERCOM1_USART_Initialize+0x7c>)
   1af6c:	bf14      	ite	ne
   1af6e:	f44f 5280 	movne.w	r2, #4096	; 0x1000
        sercom1USARTObj.rdBufferSize = SERCOM1_USART_READ_BUFFER_9BIT_SIZE;
   1af72:	f44f 6200 	moveq.w	r2, #2048	; 0x800
   1af76:	631a      	str	r2, [r3, #48]	; 0x30
        sercom1USARTObj.wrBufferSize = SERCOM1_USART_WRITE_BUFFER_9BIT_SIZE;
   1af78:	611a      	str	r2, [r3, #16]
    SERCOM1_REGS->USART_INT.SERCOM_INTENSET = (uint8_t)SERCOM_USART_INT_INTENSET_ERROR_Msk;
   1af7a:	4b03      	ldr	r3, [pc, #12]	; (1af88 <SERCOM1_USART_Initialize+0x74>)
   1af7c:	2280      	movs	r2, #128	; 0x80
   1af7e:	759a      	strb	r2, [r3, #22]
    SERCOM1_REGS->USART_INT.SERCOM_INTENSET = (uint8_t)SERCOM_USART_INT_INTENSET_RXC_Msk;
   1af80:	2204      	movs	r2, #4
   1af82:	759a      	strb	r2, [r3, #22]
}
   1af84:	4770      	bx	lr
   1af86:	bf00      	nop
   1af88:	40003400 	.word	0x40003400
   1af8c:	40100104 	.word	0x40100104
   1af90:	2000e9c0 	.word	0x2000e9c0

Disassembly of section .text.SendCommandPrint%452:

0001af94 <SendCommandPrint>:
{
   1af94:	b40e      	push	{r1, r2, r3}
   1af96:	b530      	push	{r4, r5, lr}
   1af98:	f6ad 2d08 	subw	sp, sp, #2568	; 0xa08
   1af9c:	f60d 2314 	addw	r3, sp, #2580	; 0xa14
   1afa0:	f853 2b04 	ldr.w	r2, [r3], #4
    va_start( args, format );
   1afa4:	9301      	str	r3, [sp, #4]
    len = vsnprintf(tmpBuf, SYS_CMD_PRINT_BUFFER_SIZE, format, args);
   1afa6:	f44f 6120 	mov.w	r1, #2560	; 0xa00
   1afaa:	a802      	add	r0, sp, #8
   1afac:	f008 f9ba 	bl	23324 <vsniprintf>
    if (len > 0 && len < SYS_CMD_PRINT_BUFFER_SIZE)
   1afb0:	1e42      	subs	r2, r0, #1
   1afb2:	f640 13fe 	movw	r3, #2558	; 0x9fe
   1afb6:	429a      	cmp	r2, r3
   1afb8:	d821      	bhi.n	1affe <SendCommandPrint+0x6a>
   1afba:	4604      	mov	r4, r0
        tmpBuf[len] = '\0';
   1afbc:	ab02      	add	r3, sp, #8
   1afbe:	2200      	movs	r2, #0
   1afc0:	541a      	strb	r2, [r3, r0]
        if (len + printBuffPtr >= SYS_CMD_PRINT_BUFFER_SIZE)
   1afc2:	4b12      	ldr	r3, [pc, #72]	; (1b00c <SendCommandPrint+0x78>)
   1afc4:	681b      	ldr	r3, [r3, #0]
   1afc6:	4403      	add	r3, r0
   1afc8:	f5b3 6f20 	cmp.w	r3, #2560	; 0xa00
            printBuffPtr = 0;
   1afcc:	bf24      	itt	cs
   1afce:	4b0f      	ldrcs	r3, [pc, #60]	; (1b00c <SendCommandPrint+0x78>)
   1afd0:	601a      	strcs	r2, [r3, #0]
        strcpy(&printBuff[printBuffPtr], tmpBuf);
   1afd2:	4b0e      	ldr	r3, [pc, #56]	; (1b00c <SendCommandPrint+0x78>)
   1afd4:	681b      	ldr	r3, [r3, #0]
   1afd6:	4d0e      	ldr	r5, [pc, #56]	; (1b010 <SendCommandPrint+0x7c>)
   1afd8:	441d      	add	r5, r3
   1afda:	a902      	add	r1, sp, #8
   1afdc:	4628      	mov	r0, r5
   1afde:	f008 ff67 	bl	23eb0 <strcpy>
        SendCommandMessage(NULL, &printBuff[printBuffPtr]);
   1afe2:	4629      	mov	r1, r5
   1afe4:	2000      	movs	r0, #0
   1afe6:	f008 f8f5 	bl	231d4 <SendCommandMessage>
        if (padding > 0)
   1afea:	f014 0203 	ands.w	r2, r4, #3
            padding = 4 - padding;
   1afee:	bf18      	it	ne
   1aff0:	f1c2 0204 	rsbne	r2, r2, #4
        printBuffPtr += len + padding;
   1aff4:	4b05      	ldr	r3, [pc, #20]	; (1b00c <SendCommandPrint+0x78>)
   1aff6:	6819      	ldr	r1, [r3, #0]
   1aff8:	440c      	add	r4, r1
   1affa:	4414      	add	r4, r2
   1affc:	601c      	str	r4, [r3, #0]
}
   1affe:	f60d 2d08 	addw	sp, sp, #2568	; 0xa08
   1b002:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   1b006:	b003      	add	sp, #12
   1b008:	4770      	bx	lr
   1b00a:	bf00      	nop
   1b00c:	2000eed4 	.word	0x2000eed4
   1b010:	2000c004 	.word	0x2000c004

Disassembly of section .text.xTaskPriorityDisinherit%453:

0001b014 <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
   1b014:	2800      	cmp	r0, #0
   1b016:	d035      	beq.n	1b084 <xTaskPriorityDisinherit+0x70>
	{
   1b018:	b538      	push	{r3, r4, r5, lr}
   1b01a:	4604      	mov	r4, r0
			( pxTCB->uxMutexesHeld )--;
   1b01c:	6c82      	ldr	r2, [r0, #72]	; 0x48
   1b01e:	3a01      	subs	r2, #1
   1b020:	6482      	str	r2, [r0, #72]	; 0x48
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   1b022:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   1b024:	6c61      	ldr	r1, [r4, #68]	; 0x44
   1b026:	4288      	cmp	r0, r1
   1b028:	d02e      	beq.n	1b088 <xTaskPriorityDisinherit+0x74>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   1b02a:	b10a      	cbz	r2, 1b030 <xTaskPriorityDisinherit+0x1c>
	BaseType_t xReturn = pdFALSE;
   1b02c:	2000      	movs	r0, #0
	}
   1b02e:	bd38      	pop	{r3, r4, r5, pc}
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   1b030:	1d25      	adds	r5, r4, #4
   1b032:	4628      	mov	r0, r5
   1b034:	f007 fb76 	bl	22724 <uxListRemove>
   1b038:	b970      	cbnz	r0, 1b058 <xTaskPriorityDisinherit+0x44>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   1b03a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   1b03c:	eb02 0382 	add.w	r3, r2, r2, lsl #2
   1b040:	009b      	lsls	r3, r3, #2
   1b042:	4912      	ldr	r1, [pc, #72]	; (1b08c <xTaskPriorityDisinherit+0x78>)
   1b044:	58cb      	ldr	r3, [r1, r3]
   1b046:	b93b      	cbnz	r3, 1b058 <xTaskPriorityDisinherit+0x44>
   1b048:	4811      	ldr	r0, [pc, #68]	; (1b090 <xTaskPriorityDisinherit+0x7c>)
   1b04a:	6803      	ldr	r3, [r0, #0]
   1b04c:	2101      	movs	r1, #1
   1b04e:	fa01 f202 	lsl.w	r2, r1, r2
   1b052:	ea23 0202 	bic.w	r2, r3, r2
   1b056:	6002      	str	r2, [r0, #0]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
   1b058:	6c60      	ldr	r0, [r4, #68]	; 0x44
   1b05a:	62e0      	str	r0, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1b05c:	f1c0 0305 	rsb	r3, r0, #5
   1b060:	61a3      	str	r3, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
   1b062:	4a0b      	ldr	r2, [pc, #44]	; (1b090 <xTaskPriorityDisinherit+0x7c>)
   1b064:	6811      	ldr	r1, [r2, #0]
   1b066:	2401      	movs	r4, #1
   1b068:	fa04 f300 	lsl.w	r3, r4, r0
   1b06c:	430b      	orrs	r3, r1
   1b06e:	6013      	str	r3, [r2, #0]
   1b070:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   1b074:	4629      	mov	r1, r5
   1b076:	4b05      	ldr	r3, [pc, #20]	; (1b08c <xTaskPriorityDisinherit+0x78>)
   1b078:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1b07c:	f008 fcca 	bl	23a14 <vListInsertEnd>
					xReturn = pdTRUE;
   1b080:	4620      	mov	r0, r4
   1b082:	e7d4      	b.n	1b02e <xTaskPriorityDisinherit+0x1a>
	BaseType_t xReturn = pdFALSE;
   1b084:	2000      	movs	r0, #0
	}
   1b086:	4770      	bx	lr
	BaseType_t xReturn = pdFALSE;
   1b088:	2000      	movs	r0, #0
   1b08a:	e7d0      	b.n	1b02e <xTaskPriorityDisinherit+0x1a>
   1b08c:	2000e850 	.word	0x2000e850
   1b090:	2000ef1c 	.word	0x2000ef1c

Disassembly of section .text.vTaskPriorityDisinheritAfterTimeout%454:

0001b094 <vTaskPriorityDisinheritAfterTimeout>:
		if( pxMutexHolder != NULL )
   1b094:	2800      	cmp	r0, #0
   1b096:	d038      	beq.n	1b10a <vTaskPriorityDisinheritAfterTimeout+0x76>
	{
   1b098:	b538      	push	{r3, r4, r5, lr}
   1b09a:	4604      	mov	r4, r0
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
   1b09c:	6c42      	ldr	r2, [r0, #68]	; 0x44
   1b09e:	4291      	cmp	r1, r2
   1b0a0:	bf38      	it	cc
   1b0a2:	4611      	movcc	r1, r2
			if( pxTCB->uxPriority != uxPriorityToUse )
   1b0a4:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   1b0a6:	428a      	cmp	r2, r1
   1b0a8:	d002      	beq.n	1b0b0 <vTaskPriorityDisinheritAfterTimeout+0x1c>
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
   1b0aa:	6c80      	ldr	r0, [r0, #72]	; 0x48
   1b0ac:	2801      	cmp	r0, #1
   1b0ae:	d000      	beq.n	1b0b2 <vTaskPriorityDisinheritAfterTimeout+0x1e>
	}
   1b0b0:	bd38      	pop	{r3, r4, r5, pc}
					pxTCB->uxPriority = uxPriorityToUse;
   1b0b2:	62e1      	str	r1, [r4, #44]	; 0x2c
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   1b0b4:	69a0      	ldr	r0, [r4, #24]
   1b0b6:	2800      	cmp	r0, #0
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1b0b8:	bfa4      	itt	ge
   1b0ba:	f1c1 0105 	rsbge	r1, r1, #5
   1b0be:	61a1      	strge	r1, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
   1b0c0:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   1b0c4:	4911      	ldr	r1, [pc, #68]	; (1b10c <vTaskPriorityDisinheritAfterTimeout+0x78>)
   1b0c6:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   1b0ca:	6961      	ldr	r1, [r4, #20]
   1b0cc:	4291      	cmp	r1, r2
   1b0ce:	d1ef      	bne.n	1b0b0 <vTaskPriorityDisinheritAfterTimeout+0x1c>
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   1b0d0:	1d25      	adds	r5, r4, #4
   1b0d2:	4628      	mov	r0, r5
   1b0d4:	f007 fb26 	bl	22724 <uxListRemove>
   1b0d8:	b938      	cbnz	r0, 1b0ea <vTaskPriorityDisinheritAfterTimeout+0x56>
							portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
   1b0da:	490d      	ldr	r1, [pc, #52]	; (1b110 <vTaskPriorityDisinheritAfterTimeout+0x7c>)
   1b0dc:	680b      	ldr	r3, [r1, #0]
   1b0de:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   1b0e0:	2201      	movs	r2, #1
   1b0e2:	4082      	lsls	r2, r0
   1b0e4:	ea23 0302 	bic.w	r3, r3, r2
   1b0e8:	600b      	str	r3, [r1, #0]
						prvAddTaskToReadyList( pxTCB );
   1b0ea:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   1b0ec:	4a08      	ldr	r2, [pc, #32]	; (1b110 <vTaskPriorityDisinheritAfterTimeout+0x7c>)
   1b0ee:	6811      	ldr	r1, [r2, #0]
   1b0f0:	2301      	movs	r3, #1
   1b0f2:	4083      	lsls	r3, r0
   1b0f4:	430b      	orrs	r3, r1
   1b0f6:	6013      	str	r3, [r2, #0]
   1b0f8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   1b0fc:	4629      	mov	r1, r5
   1b0fe:	4b03      	ldr	r3, [pc, #12]	; (1b10c <vTaskPriorityDisinheritAfterTimeout+0x78>)
   1b100:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1b104:	f008 fc86 	bl	23a14 <vListInsertEnd>
	}
   1b108:	e7d2      	b.n	1b0b0 <vTaskPriorityDisinheritAfterTimeout+0x1c>
   1b10a:	4770      	bx	lr
   1b10c:	2000e850 	.word	0x2000e850
   1b110:	2000ef1c 	.word	0x2000ef1c

Disassembly of section .rodata.outputA_data%455:

0001b114 <outputA_data>:
   1b114:	3bc6ee04 2cdf31b2 fb1a0a63 9d9424e7     ...;.1.,c....$..
   1b124:	78585a00 79aae151 4773475e 6256b0c8     .ZXxQ..y^GsG..Vb
   1b134:	dcbd181c fc998ddd 20b9c25f accfd853     ........_.. S...
   1b144:	83b80bfb d1fa0512 71c0d6dd 18608a31     ...........q1.`.
   1b154:	f5733bf0 d0d4e4ed 03def971 10ea7afd     .;s.....q....z..
   1b164:	b899925d 07aa99af b94ddb5b 8dc128aa     ].......[.M..(..
   1b174:	ee564b17 094d012a 22ff9688 a855c982     .KV.*.M...."..U.
   1b184:	69e06919 07e08cfa 3a1880a1 17aedf07     .i.i.......:....

Disassembly of section .rodata.outputB_data%456:

0001b194 <outputB_data>:
   1b194:	c360e1d3 40f3995b 648262b2 601075d1     ..`.[..@.b.d.u.`
   1b1a4:	a35d04e0 a557ff83 73a6737d 0dd8b8d2     ..]...W.}s.s....
   1b1b4:	c3a6f6aa 45bb915a d03fd779 11d1fec8     ....Z..Ey.?.....
   1b1c4:	061339b0 eddf8a82 81018f52 bdfeb321     .9......R...!...
   1b1d4:	97e743c3 63bb7db8 de3313db e1ecd1d9     .C...}.c..3.....
   1b1e4:	b7a6cf77 1dabe81f ed2466a4 1ce51564     w........f$.d...
   1b1f4:	cac7e2cd 9983e286 91ebea0e 52150412     ...............R
   1b204:	9195228b 2db08102 c9f431d4 df2704f7     .".....-.1....'.

Disassembly of section .text.local_miim_init%457:

0001b214 <local_miim_init>:
{
   1b214:	b510      	push	{r4, lr}
   1b216:	b084      	sub	sp, #16
	opHandle                    = 0;
   1b218:	4b16      	ldr	r3, [pc, #88]	; (1b274 <local_miim_init+0x60>)
   1b21a:	2000      	movs	r0, #0
   1b21c:	6018      	str	r0, [r3, #0]
	clientObj.miimOpHandle      = &opHandle;
   1b21e:	4c16      	ldr	r4, [pc, #88]	; (1b278 <local_miim_init+0x64>)
   1b220:	6123      	str	r3, [r4, #16]
	clientObj.miimBase          = &DRV_MIIM_OBJECT_BASE_Default;
   1b222:	4b16      	ldr	r3, [pc, #88]	; (1b27c <local_miim_init+0x68>)
   1b224:	60e3      	str	r3, [r4, #12]
	clientObj.miimHandle = clientObj.miimBase->DRV_MIIM_Open(miimObjIx, DRV_IO_INTENT_SHARED);
   1b226:	695b      	ldr	r3, [r3, #20]
   1b228:	4601      	mov	r1, r0
   1b22a:	4798      	blx	r3
   1b22c:	60a0      	str	r0, [r4, #8]
	if ( (clientObj.miimHandle == DRV_HANDLE_INVALID) || (clientObj.miimHandle == 0))
   1b22e:	1e43      	subs	r3, r0, #1
   1b230:	f113 0f03 	cmn.w	r3, #3
   1b234:	d815      	bhi.n	1b262 <local_miim_init+0x4e>
		miimSetup.hostClockFreq = (uint32_t) TCPIP_INTMAC_PERIPHERAL_CLK;
   1b236:	4b12      	ldr	r3, [pc, #72]	; (1b280 <local_miim_init+0x6c>)
   1b238:	9301      	str	r3, [sp, #4]
		miimSetup.maxBusFreq = 2000000;
   1b23a:	4b12      	ldr	r3, [pc, #72]	; (1b284 <local_miim_init+0x70>)
   1b23c:	9302      	str	r3, [sp, #8]
		miimSetup.setupFlags = 0;
   1b23e:	2300      	movs	r3, #0
   1b240:	f88d 300c 	strb.w	r3, [sp, #12]
		res = clientObj.miimBase->DRV_MIIM_Setup(clientObj.miimHandle, &miimSetup);
   1b244:	4b0c      	ldr	r3, [pc, #48]	; (1b278 <local_miim_init+0x64>)
   1b246:	68db      	ldr	r3, [r3, #12]
   1b248:	699b      	ldr	r3, [r3, #24]
   1b24a:	a901      	add	r1, sp, #4
   1b24c:	4798      	blx	r3
		if (res < 0)
   1b24e:	1e04      	subs	r4, r0, #0
			SYS_CONSOLE_PRINT("> Local miim setup: failed!\r\n");
   1b250:	bfb4      	ite	lt
   1b252:	490d      	ldrlt	r1, [pc, #52]	; (1b288 <local_miim_init+0x74>)
			SYS_CONSOLE_PRINT("> Miim Successfully opened. \r\n");
   1b254:	490d      	ldrge	r1, [pc, #52]	; (1b28c <local_miim_init+0x78>)
   1b256:	2000      	movs	r0, #0
   1b258:	f001 fa20 	bl	1c69c <SYS_CONSOLE_Print>
}
   1b25c:	4620      	mov	r0, r4
   1b25e:	b004      	add	sp, #16
   1b260:	bd10      	pop	{r4, pc}
		SYS_CONSOLE_PRINT("> Local miim open: failed!\r\n");
   1b262:	490b      	ldr	r1, [pc, #44]	; (1b290 <local_miim_init+0x7c>)
   1b264:	2000      	movs	r0, #0
   1b266:	f001 fa19 	bl	1c69c <SYS_CONSOLE_Print>
		clientObj.miimHandle = 0;
   1b26a:	2200      	movs	r2, #0
   1b26c:	60a2      	str	r2, [r4, #8]
		res = DRV_MIIM_RES_OP_INTERNAL_ERR;
   1b26e:	f06f 0413 	mvn.w	r4, #19
   1b272:	e7f3      	b.n	1b25c <local_miim_init+0x48>
   1b274:	2000ef58 	.word	0x2000ef58
   1b278:	2000ed04 	.word	0x2000ed04
   1b27c:	0001f8e4 	.word	0x0001f8e4
   1b280:	07270e00 	.word	0x07270e00
   1b284:	001e8480 	.word	0x001e8480
   1b288:	0000c3dc 	.word	0x0000c3dc
   1b28c:	0000c3fc 	.word	0x0000c3fc
   1b290:	0000c3bc 	.word	0x0000c3bc

Disassembly of section .text.prvUnlockQueue%458:

0001b294 <prvUnlockQueue>:
{
   1b294:	b570      	push	{r4, r5, r6, lr}
   1b296:	4605      	mov	r5, r0
	taskENTER_CRITICAL();
   1b298:	f007 fd72 	bl	22d80 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
   1b29c:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
   1b2a0:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
   1b2a2:	2c00      	cmp	r4, #0
   1b2a4:	dd11      	ble.n	1b2ca <prvUnlockQueue+0x36>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1b2a6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1b2a8:	b17b      	cbz	r3, 1b2ca <prvUnlockQueue+0x36>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1b2aa:	f105 0624 	add.w	r6, r5, #36	; 0x24
   1b2ae:	e006      	b.n	1b2be <prvUnlockQueue+0x2a>
						vTaskMissedYield();
   1b2b0:	f008 fff8 	bl	242a4 <vTaskMissedYield>
			--cTxLock;
   1b2b4:	3c01      	subs	r4, #1
   1b2b6:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
   1b2b8:	b13c      	cbz	r4, 1b2ca <prvUnlockQueue+0x36>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1b2ba:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1b2bc:	b12b      	cbz	r3, 1b2ca <prvUnlockQueue+0x36>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1b2be:	4630      	mov	r0, r6
   1b2c0:	f000 fdca 	bl	1be58 <xTaskRemoveFromEventList>
   1b2c4:	2800      	cmp	r0, #0
   1b2c6:	d0f5      	beq.n	1b2b4 <prvUnlockQueue+0x20>
   1b2c8:	e7f2      	b.n	1b2b0 <prvUnlockQueue+0x1c>
		pxQueue->cTxLock = queueUNLOCKED;
   1b2ca:	23ff      	movs	r3, #255	; 0xff
   1b2cc:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	taskEXIT_CRITICAL();
   1b2d0:	f008 fc76 	bl	23bc0 <vPortExitCritical>
	taskENTER_CRITICAL();
   1b2d4:	f007 fd54 	bl	22d80 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
   1b2d8:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
   1b2dc:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
   1b2de:	2c00      	cmp	r4, #0
   1b2e0:	dd11      	ble.n	1b306 <prvUnlockQueue+0x72>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1b2e2:	692b      	ldr	r3, [r5, #16]
   1b2e4:	b17b      	cbz	r3, 1b306 <prvUnlockQueue+0x72>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   1b2e6:	f105 0610 	add.w	r6, r5, #16
   1b2ea:	e006      	b.n	1b2fa <prvUnlockQueue+0x66>
					vTaskMissedYield();
   1b2ec:	f008 ffda 	bl	242a4 <vTaskMissedYield>
				--cRxLock;
   1b2f0:	3c01      	subs	r4, #1
   1b2f2:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
   1b2f4:	b13c      	cbz	r4, 1b306 <prvUnlockQueue+0x72>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1b2f6:	692b      	ldr	r3, [r5, #16]
   1b2f8:	b12b      	cbz	r3, 1b306 <prvUnlockQueue+0x72>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   1b2fa:	4630      	mov	r0, r6
   1b2fc:	f000 fdac 	bl	1be58 <xTaskRemoveFromEventList>
   1b300:	2800      	cmp	r0, #0
   1b302:	d0f5      	beq.n	1b2f0 <prvUnlockQueue+0x5c>
   1b304:	e7f2      	b.n	1b2ec <prvUnlockQueue+0x58>
		pxQueue->cRxLock = queueUNLOCKED;
   1b306:	23ff      	movs	r3, #255	; 0xff
   1b308:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	taskEXIT_CRITICAL();
   1b30c:	f008 fc58 	bl	23bc0 <vPortExitCritical>
}
   1b310:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.__multadd%459:

0001b312 <__multadd>:
   1b312:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1b316:	690d      	ldr	r5, [r1, #16]
   1b318:	461f      	mov	r7, r3
   1b31a:	4606      	mov	r6, r0
   1b31c:	460c      	mov	r4, r1
   1b31e:	f101 0c14 	add.w	ip, r1, #20
   1b322:	2300      	movs	r3, #0
   1b324:	f64f 7eff 	movw	lr, #65535	; 0xffff
   1b328:	f8dc 0000 	ldr.w	r0, [ip]
   1b32c:	ea00 010e 	and.w	r1, r0, lr
   1b330:	fb02 7101 	mla	r1, r2, r1, r7
   1b334:	0c0f      	lsrs	r7, r1, #16
   1b336:	0c00      	lsrs	r0, r0, #16
   1b338:	fb02 7000 	mla	r0, r2, r0, r7
   1b33c:	ea01 010e 	and.w	r1, r1, lr
   1b340:	3301      	adds	r3, #1
   1b342:	eb01 4100 	add.w	r1, r1, r0, lsl #16
   1b346:	429d      	cmp	r5, r3
   1b348:	ea4f 4710 	mov.w	r7, r0, lsr #16
   1b34c:	f84c 1b04 	str.w	r1, [ip], #4
   1b350:	dcea      	bgt.n	1b328 <__multadd+0x16>
   1b352:	b1d7      	cbz	r7, 1b38a <__multadd+0x78>
   1b354:	68a3      	ldr	r3, [r4, #8]
   1b356:	42ab      	cmp	r3, r5
   1b358:	dc12      	bgt.n	1b380 <__multadd+0x6e>
   1b35a:	6861      	ldr	r1, [r4, #4]
   1b35c:	4630      	mov	r0, r6
   1b35e:	3101      	adds	r1, #1
   1b360:	f001 fc14 	bl	1cb8c <_Balloc>
   1b364:	6922      	ldr	r2, [r4, #16]
   1b366:	3202      	adds	r2, #2
   1b368:	f104 010c 	add.w	r1, r4, #12
   1b36c:	4680      	mov	r8, r0
   1b36e:	0092      	lsls	r2, r2, #2
   1b370:	300c      	adds	r0, #12
   1b372:	f007 ffbb 	bl	232ec <memcpy>
   1b376:	4621      	mov	r1, r4
   1b378:	4630      	mov	r0, r6
   1b37a:	f006 faa0 	bl	218be <_Bfree>
   1b37e:	4644      	mov	r4, r8
   1b380:	eb04 0385 	add.w	r3, r4, r5, lsl #2
   1b384:	3501      	adds	r5, #1
   1b386:	615f      	str	r7, [r3, #20]
   1b388:	6125      	str	r5, [r4, #16]
   1b38a:	4620      	mov	r0, r4
   1b38c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.DRV_ETHPHY_VendorSMIReadResultGet%460:

0001b390 <DRV_ETHPHY_VendorSMIReadResultGet>:
{
   1b390:	b570      	push	{r4, r5, r6, lr}
    if(hClientObj == 0 || _DRVHandleToInst(hClientObj->hDriver) == 0)
   1b392:	b320      	cbz	r0, 1b3de <DRV_ETHPHY_VendorSMIReadResultGet+0x4e>
   1b394:	4604      	mov	r4, r0
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1b396:	68c0      	ldr	r0, [r0, #12]
   1b398:	4a1b      	ldr	r2, [pc, #108]	; (1b408 <DRV_ETHPHY_VendorSMIReadResultGet+0x78>)
   1b39a:	4290      	cmp	r0, r2
   1b39c:	d122      	bne.n	1b3e4 <DRV_ETHPHY_VendorSMIReadResultGet+0x54>
    if( hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_BUSY || 
   1b39e:	f994 5008 	ldrsb.w	r5, [r4, #8]
   1b3a2:	2d01      	cmp	r5, #1
   1b3a4:	d122      	bne.n	1b3ec <DRV_ETHPHY_VendorSMIReadResultGet+0x5c>
   1b3a6:	8ba2      	ldrh	r2, [r4, #28]
   1b3a8:	2a01      	cmp	r2, #1
   1b3aa:	d122      	bne.n	1b3f2 <DRV_ETHPHY_VendorSMIReadResultGet+0x62>
        hClientObj->operType != DRV_ETHPHY_CLIENT_OP_TYPE_SETUP || 
   1b3ac:	8be2      	ldrh	r2, [r4, #30]
   1b3ae:	f022 0202 	bic.w	r2, r2, #2
   1b3b2:	b292      	uxth	r2, r2
   1b3b4:	2a01      	cmp	r2, #1
   1b3b6:	d002      	beq.n	1b3be <DRV_ETHPHY_VendorSMIReadResultGet+0x2e>
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   1b3b8:	f06f 0509 	mvn.w	r5, #9
   1b3bc:	e014      	b.n	1b3e8 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
    if(hClientObj->smiTxferStatus != DRV_ETHPHY_SMI_TXFER_OP_WAIT_COMPLETE)
   1b3be:	8ea2      	ldrh	r2, [r4, #52]	; 0x34
   1b3c0:	2a02      	cmp	r2, #2
   1b3c2:	d119      	bne.n	1b3f8 <DRV_ETHPHY_VendorSMIReadResultGet+0x68>
   1b3c4:	460e      	mov	r6, r1
    DRV_ETHPHY_SMI_TXFER_RES opRes = _DRV_PHY_SMITransferWaitComplete(hClientObj);
   1b3c6:	4620      	mov	r0, r4
   1b3c8:	f002 fbfd 	bl	1dbc6 <_DRV_PHY_SMITransferWaitComplete>
    if(opRes < 0)
   1b3cc:	2800      	cmp	r0, #0
   1b3ce:	db16      	blt.n	1b3fe <DRV_ETHPHY_VendorSMIReadResultGet+0x6e>
    else if(opRes == DRV_ETHPHY_SMI_TXFER_RES_WAIT)
   1b3d0:	2802      	cmp	r0, #2
   1b3d2:	d009      	beq.n	1b3e8 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
    if(pSmiRes)
   1b3d4:	b1b6      	cbz	r6, 1b404 <DRV_ETHPHY_VendorSMIReadResultGet+0x74>
        *pSmiRes = hClientObj->smiData;
   1b3d6:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   1b3d8:	8033      	strh	r3, [r6, #0]
    return DRV_ETHPHY_RES_OK;
   1b3da:	2500      	movs	r5, #0
   1b3dc:	e004      	b.n	1b3e8 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
        return DRV_ETHPHY_RES_HANDLE_ERR;
   1b3de:	f06f 050a 	mvn.w	r5, #10
   1b3e2:	e001      	b.n	1b3e8 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
   1b3e4:	f06f 050a 	mvn.w	r5, #10
}
   1b3e8:	4628      	mov	r0, r5
   1b3ea:	bd70      	pop	{r4, r5, r6, pc}
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   1b3ec:	f06f 0509 	mvn.w	r5, #9
   1b3f0:	e7fa      	b.n	1b3e8 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
   1b3f2:	f06f 0509 	mvn.w	r5, #9
   1b3f6:	e7f7      	b.n	1b3e8 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   1b3f8:	f06f 0508 	mvn.w	r5, #8
   1b3fc:	e7f4      	b.n	1b3e8 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   1b3fe:	f06f 0508 	mvn.w	r5, #8
   1b402:	e7f1      	b.n	1b3e8 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
    return DRV_ETHPHY_RES_OK;
   1b404:	2500      	movs	r5, #0
   1b406:	e7ef      	b.n	1b3e8 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
   1b408:	2000e7e8 	.word	0x2000e7e8

Disassembly of section .text.DRV_PIC32CGMAC_LibInit%461:

0001b40c <DRV_PIC32CGMAC_LibInit>:
{		
   1b40c:	b508      	push	{r3, lr}
    MCLK_REGS->MCLK_AHBMASK |= MCLK_AHBMASK_GMAC(1);	
   1b40e:	4b1b      	ldr	r3, [pc, #108]	; (1b47c <DRV_PIC32CGMAC_LibInit+0x70>)
   1b410:	691a      	ldr	r2, [r3, #16]
   1b412:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   1b416:	611a      	str	r2, [r3, #16]
    MCLK_REGS->MCLK_APBCMASK |= MCLK_APBCMASK_GMAC(1);
   1b418:	69da      	ldr	r2, [r3, #28]
   1b41a:	f042 0204 	orr.w	r2, r2, #4
   1b41e:	61da      	str	r2, [r3, #28]
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_TXEN_Msk;
   1b420:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
   1b424:	681a      	ldr	r2, [r3, #0]
   1b426:	f022 0208 	bic.w	r2, r2, #8
   1b42a:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_RXEN_Msk;
   1b42c:	681a      	ldr	r2, [r3, #0]
   1b42e:	f022 0204 	bic.w	r2, r2, #4
   1b432:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_IDR = GMAC_INT_ALL;	//Clear statistics register
   1b434:	f04f 32ff 	mov.w	r2, #4294967295
   1b438:	62da      	str	r2, [r3, #44]	; 0x2c
	GMAC_REGS->GMAC_NCR |=  GMAC_NCR_CLRSTAT_Msk;
   1b43a:	681a      	ldr	r2, [r3, #0]
   1b43c:	f042 0220 	orr.w	r2, r2, #32
   1b440:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_RSR =  GMAC_RSR_RXOVR_Msk | GMAC_RSR_REC_Msk | GMAC_RSR_BNA_Msk  | GMAC_RSR_HNO_Msk;
   1b442:	220f      	movs	r2, #15
   1b444:	621a      	str	r2, [r3, #32]
	GMAC_REGS->GMAC_TSR = GMAC_TSR_UBR_Msk  | GMAC_TSR_COL_Msk  | GMAC_TSR_RLE_Msk | GMAC_TSR_TXGO_Msk |
   1b446:	f240 123f 	movw	r2, #319	; 0x13f
   1b44a:	615a      	str	r2, [r3, #20]
	GMAC_REGS->GMAC_ISR;
   1b44c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
                            | GMAC_NCFGR_MAXFS(GMAC_MAX_RXFS)| GMAC_NCFGR_RXBUFO(pMACDrv->sGmacData._dataOffset);
   1b44e:	f890 20f6 	ldrb.w	r2, [r0, #246]	; 0xf6
   1b452:	0392      	lsls	r2, r2, #14
   1b454:	b292      	uxth	r2, r2
   1b456:	490a      	ldr	r1, [pc, #40]	; (1b480 <DRV_PIC32CGMAC_LibInit+0x74>)
   1b458:	4311      	orrs	r1, r2
    GMAC_REGS->GMAC_NCFGR = GMAC_NCFGR_SPD(1) | GMAC_NCFGR_FD(1) | GMAC_NCFGR_CLK(3)  |	GMAC_NCFGR_PEN(1)  | GMAC_NCFGR_RFCS(1)
   1b45a:	6059      	str	r1, [r3, #4]
	if((pMACDrv->sGmacData.gmacConfig.checksumOffloadRx) != TCPIP_MAC_CHECKSUM_NONE)
   1b45c:	f890 30e0 	ldrb.w	r3, [r0, #224]	; 0xe0
   1b460:	b123      	cbz	r3, 1b46c <DRV_PIC32CGMAC_LibInit+0x60>
        GMAC_REGS->GMAC_NCFGR |= GMAC_NCFGR_RXCOEN_Msk;
   1b462:	4a08      	ldr	r2, [pc, #32]	; (1b484 <DRV_PIC32CGMAC_LibInit+0x78>)
   1b464:	6853      	ldr	r3, [r2, #4]
   1b466:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   1b46a:	6053      	str	r3, [r2, #4]
    DRV_PIC32CGMAC_LibSetMacAddr((const uint8_t *)(pMACDrv->sGmacData.gmacConfig.macAddress.v));
   1b46c:	30b8      	adds	r0, #184	; 0xb8
   1b46e:	f005 fe45 	bl	210fc <DRV_PIC32CGMAC_LibSetMacAddr>
		GMAC_REGS->GMAC_UR = GMAC_UR_MII(0); //initial mode set as RMII
   1b472:	4b04      	ldr	r3, [pc, #16]	; (1b484 <DRV_PIC32CGMAC_LibInit+0x78>)
   1b474:	2200      	movs	r2, #0
   1b476:	60da      	str	r2, [r3, #12]
}
   1b478:	bd08      	pop	{r3, pc}
   1b47a:	bf00      	nop
   1b47c:	40000800 	.word	0x40000800
   1b480:	000e2103 	.word	0x000e2103
   1b484:	42000800 	.word	0x42000800

Disassembly of section .text.SYS_Tasks%462:

0001b488 <SYS_Tasks>:

  Remarks:
    See prototype in system/common/sys_module.h.
*/
void SYS_Tasks ( void )
{
   1b488:	b570      	push	{r4, r5, r6, lr}
   1b48a:	b082      	sub	sp, #8
    /* Maintain system services */
    

    xTaskCreate( _SYS_CMD_Tasks,
   1b48c:	4d17      	ldr	r5, [pc, #92]	; (1b4ec <SYS_Tasks+0x64>)
   1b48e:	2400      	movs	r4, #0
   1b490:	9401      	str	r4, [sp, #4]
   1b492:	2601      	movs	r6, #1
   1b494:	9600      	str	r6, [sp, #0]
   1b496:	4623      	mov	r3, r4
   1b498:	f44f 6220 	mov.w	r2, #2560	; 0xa00
   1b49c:	4629      	mov	r1, r5
   1b49e:	4814      	ldr	r0, [pc, #80]	; (1b4f0 <SYS_Tasks+0x68>)
   1b4a0:	f7f5 fa4c 	bl	1093c <xTaskCreate>




    /* Maintain Device Drivers */
        xTaskCreate( _DRV_MIIM_Task,
   1b4a4:	9401      	str	r4, [sp, #4]
   1b4a6:	9600      	str	r6, [sp, #0]
   1b4a8:	4623      	mov	r3, r4
   1b4aa:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1b4ae:	f105 0110 	add.w	r1, r5, #16
   1b4b2:	4810      	ldr	r0, [pc, #64]	; (1b4f4 <SYS_Tasks+0x6c>)
   1b4b4:	f7f5 fa42 	bl	1093c <xTaskCreate>



    /* Maintain Middleware & Other Libraries */
    
    xTaskCreate( _TCPIP_STACK_Task,
   1b4b8:	9401      	str	r4, [sp, #4]
   1b4ba:	9600      	str	r6, [sp, #0]
   1b4bc:	4623      	mov	r3, r4
   1b4be:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1b4c2:	f105 0120 	add.w	r1, r5, #32
   1b4c6:	480c      	ldr	r0, [pc, #48]	; (1b4f8 <SYS_Tasks+0x70>)
   1b4c8:	f7f5 fa38 	bl	1093c <xTaskCreate>



    /* Maintain the application's state machine. */
        /* Create OS Thread for APP_Tasks. */
    xTaskCreate((TaskFunction_t) _APP_Tasks,
   1b4cc:	4b0b      	ldr	r3, [pc, #44]	; (1b4fc <SYS_Tasks+0x74>)
   1b4ce:	9301      	str	r3, [sp, #4]
   1b4d0:	9600      	str	r6, [sp, #0]
   1b4d2:	4623      	mov	r3, r4
   1b4d4:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1b4d8:	f105 0134 	add.w	r1, r5, #52	; 0x34
   1b4dc:	4808      	ldr	r0, [pc, #32]	; (1b500 <SYS_Tasks+0x78>)
   1b4de:	f7f5 fa2d 	bl	1093c <xTaskCreate>
    /* Start RTOS Scheduler. */
    
     /**********************************************************************
     * Create all Threads for APP Tasks before starting FreeRTOS Scheduler *
     ***********************************************************************/
    vTaskStartScheduler(); /* This function never returns. */
   1b4e2:	f001 fd17 	bl	1cf14 <vTaskStartScheduler>

}
   1b4e6:	b002      	add	sp, #8
   1b4e8:	bd70      	pop	{r4, r5, r6, pc}
   1b4ea:	bf00      	nop
   1b4ec:	0001fc24 	.word	0x0001fc24
   1b4f0:	00023e11 	.word	0x00023e11
   1b4f4:	00023895 	.word	0x00023895
   1b4f8:	0002387d 	.word	0x0002387d
   1b4fc:	2000eeec 	.word	0x2000eeec
   1b500:	00023e01 	.word	0x00023e01

Disassembly of section .text.SYS_Initialize%463:

0001b504 <SYS_Initialize>:

  Remarks:
 */

void SYS_Initialize ( void* data )
{
   1b504:	b510      	push	{r4, lr}

    NVMCTRL_Initialize( );
   1b506:	f008 fc5b 	bl	23dc0 <NVMCTRL_Initialize>

  
    PORT_Initialize();
   1b50a:	f7fb ff8d 	bl	17428 <PORT_Initialize>

    CLOCK_Initialize();
   1b50e:	f7fa fc1f 	bl	15d50 <CLOCK_Initialize>




    TC0_TimerInitialize();
   1b512:	f004 fb47 	bl	1fba4 <TC0_TimerInitialize>

    SERCOM1_USART_Initialize();
   1b516:	f7ff fcfd 	bl	1af14 <SERCOM1_USART_Initialize>

    EVSYS_Initialize();
   1b51a:	f7fa fb1c 	bl	15b56 <EVSYS_Initialize>

    SERCOM0_SPI_Initialize();
   1b51e:	f005 f955 	bl	207cc <SERCOM0_SPI_Initialize>



    /* Initialize the MIIM Driver */
    sysObj.drvMiim = DRV_MIIM_Initialize( DRV_MIIM_INDEX_0, (const SYS_MODULE_INIT *) &drvMiimInitData );
   1b522:	4911      	ldr	r1, [pc, #68]	; (1b568 <SYS_Initialize+0x64>)
   1b524:	2000      	movs	r0, #0
   1b526:	f000 f95b 	bl	1b7e0 <DRV_MIIM_Initialize>
   1b52a:	4c10      	ldr	r4, [pc, #64]	; (1b56c <SYS_Initialize+0x68>)
   1b52c:	60e0      	str	r0, [r4, #12]


    sysObj.sysTime = SYS_TIME_Initialize(SYS_TIME_INDEX_0, (SYS_MODULE_INIT *)&sysTimeInitData);
   1b52e:	4910      	ldr	r1, [pc, #64]	; (1b570 <SYS_Initialize+0x6c>)
   1b530:	2000      	movs	r0, #0
   1b532:	f7fd f9cf 	bl	188d4 <SYS_TIME_Initialize>
   1b536:	6020      	str	r0, [r4, #0]
    sysObj.sysConsole0 = SYS_CONSOLE_Initialize(SYS_CONSOLE_INDEX_0, (SYS_MODULE_INIT *)&sysConsole0Init);
   1b538:	490e      	ldr	r1, [pc, #56]	; (1b574 <SYS_Initialize+0x70>)
   1b53a:	2000      	movs	r0, #0
   1b53c:	f001 fa8a 	bl	1ca54 <SYS_CONSOLE_Initialize>
   1b540:	6060      	str	r0, [r4, #4]

    SYS_CMD_Initialize((SYS_MODULE_INIT*)&sysCmdInit);
   1b542:	480d      	ldr	r0, [pc, #52]	; (1b578 <SYS_Initialize+0x74>)
   1b544:	f005 f95e 	bl	20804 <SYS_CMD_Initialize>

    sysObj.sysDebug = SYS_DEBUG_Initialize(SYS_DEBUG_INDEX_0, (SYS_MODULE_INIT*)&debugInit);
   1b548:	490c      	ldr	r1, [pc, #48]	; (1b57c <SYS_Initialize+0x78>)
   1b54a:	2000      	movs	r0, #0
   1b54c:	f007 fe50 	bl	231f0 <SYS_DEBUG_Initialize>
   1b550:	6120      	str	r0, [r4, #16]




/* TCPIP Stack Initialization */
sysObj.tcpip = TCPIP_STACK_Init();
   1b552:	f006 fae9 	bl	21b28 <TCPIP_STACK_Init>
   1b556:	60a0      	str	r0, [r4, #8]
SYS_ASSERT(sysObj.tcpip != SYS_MODULE_OBJ_INVALID, "TCPIP_STACK_Init Failed" );


    CRYPT_WCCB_Initialize();
   1b558:	f008 fb46 	bl	23be8 <CRYPT_WCCB_Initialize>

    APP_Initialize();
   1b55c:	f006 f826 	bl	215ac <APP_Initialize>


    NVIC_Initialize();
   1b560:	f7fe fec4 	bl	1a2ec <NVIC_Initialize>

}
   1b564:	bd10      	pop	{r4, pc}
   1b566:	bf00      	nop
   1b568:	00024410 	.word	0x00024410
   1b56c:	2000ec78 	.word	0x2000ec78
   1b570:	00024418 	.word	0x00024418
   1b574:	00024298 	.word	0x00024298
   1b578:	2000eef0 	.word	0x2000eef0
   1b57c:	000244a4 	.word	0x000244a4

Disassembly of section .text.gfx_mono_draw_string_n%464:

0001b580 <gfx_mono_draw_string_n>:
        const struct font *font) {
   1b580:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1b584:	9e08      	ldr	r6, [sp, #32]
    assert(str != NULL);
   1b586:	b140      	cbz	r0, 1b59a <gfx_mono_draw_string_n+0x1a>
   1b588:	4698      	mov	r8, r3
   1b58a:	4605      	mov	r5, r0
    assert(font != NULL);
   1b58c:	b176      	cbz	r6, 1b5ac <gfx_mono_draw_string_n+0x2c>
   1b58e:	1e44      	subs	r4, r0, #1
   1b590:	3901      	subs	r1, #1
   1b592:	440d      	add	r5, r1
   1b594:	4691      	mov	r9, r2
            x = start_of_string_position_x;
   1b596:	4617      	mov	r7, r2
   1b598:	e019      	b.n	1b5ce <gfx_mono_draw_string_n+0x4e>
    assert(str != NULL);
   1b59a:	4816      	ldr	r0, [pc, #88]	; (1b5f4 <gfx_mono_draw_string_n+0x74>)
   1b59c:	f100 0328 	add.w	r3, r0, #40	; 0x28
   1b5a0:	4a15      	ldr	r2, [pc, #84]	; (1b5f8 <gfx_mono_draw_string_n+0x78>)
   1b5a2:	f240 111d 	movw	r1, #285	; 0x11d
   1b5a6:	3008      	adds	r0, #8
   1b5a8:	f004 fef0 	bl	2038c <__assert_func>
    assert(font != NULL);
   1b5ac:	4811      	ldr	r0, [pc, #68]	; (1b5f4 <gfx_mono_draw_string_n+0x74>)
   1b5ae:	f100 0334 	add.w	r3, r0, #52	; 0x34
   1b5b2:	4a11      	ldr	r2, [pc, #68]	; (1b5f8 <gfx_mono_draw_string_n+0x78>)
   1b5b4:	f44f 718f 	mov.w	r1, #286	; 0x11e
   1b5b8:	3008      	adds	r0, #8
   1b5ba:	f004 fee7 	bl	2038c <__assert_func>
            y += font->height + 1;
   1b5be:	7a73      	ldrb	r3, [r6, #9]
   1b5c0:	3301      	adds	r3, #1
   1b5c2:	4443      	add	r3, r8
   1b5c4:	fa5f f883 	uxtb.w	r8, r3
            x = start_of_string_position_x;
   1b5c8:	46b9      	mov	r9, r7
    } while (--len);
   1b5ca:	42ac      	cmp	r4, r5
   1b5cc:	d00f      	beq.n	1b5ee <gfx_mono_draw_string_n+0x6e>
        if (*str == '\n') {
   1b5ce:	f814 0f01 	ldrb.w	r0, [r4, #1]!
   1b5d2:	280a      	cmp	r0, #10
   1b5d4:	d0f3      	beq.n	1b5be <gfx_mono_draw_string_n+0x3e>
        } else if (*str == '\r') {
   1b5d6:	280d      	cmp	r0, #13
   1b5d8:	d0f7      	beq.n	1b5ca <gfx_mono_draw_string_n+0x4a>
            gfx_mono_draw_char(*str, x, y, font);
   1b5da:	4633      	mov	r3, r6
   1b5dc:	4642      	mov	r2, r8
   1b5de:	4649      	mov	r1, r9
   1b5e0:	f7fc fe4c 	bl	1827c <gfx_mono_draw_char>
            x += font->width;
   1b5e4:	7a33      	ldrb	r3, [r6, #8]
   1b5e6:	4499      	add	r9, r3
   1b5e8:	fa5f f989 	uxtb.w	r9, r9
   1b5ec:	e7ed      	b.n	1b5ca <gfx_mono_draw_string_n+0x4a>
}
   1b5ee:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1b5f2:	bf00      	nop
   1b5f4:	0001f548 	.word	0x0001f548
   1b5f8:	000238f4 	.word	0x000238f4

Disassembly of section .text.TCPIP_TCP_SocketInfoGet%465:

0001b5fc <TCPIP_TCP_SocketInfoGet>:
{
   1b5fc:	b570      	push	{r4, r5, r6, lr}
   1b5fe:	4606      	mov	r6, r0
   1b600:	460d      	mov	r5, r1
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   1b602:	f006 fc8b 	bl	21f1c <_TcpSocketChk>
    if(pSkt == 0)
   1b606:	2800      	cmp	r0, #0
   1b608:	d033      	beq.n	1b672 <TCPIP_TCP_SocketInfoGet+0x76>
   1b60a:	4604      	mov	r4, r0
        memset(remoteInfo, 0, sizeof(*remoteInfo));
   1b60c:	2238      	movs	r2, #56	; 0x38
   1b60e:	2100      	movs	r1, #0
   1b610:	4628      	mov	r0, r5
   1b612:	f008 fc45 	bl	23ea0 <memset>
        if (pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   1b616:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
   1b61a:	2b01      	cmp	r3, #1
   1b61c:	d022      	beq.n	1b664 <TCPIP_TCP_SocketInfoGet+0x68>
	remoteInfo->remotePort = pSkt->remotePort;
   1b61e:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
   1b622:	84ab      	strh	r3, [r5, #36]	; 0x24
	remoteInfo->localPort = pSkt->localPort;
   1b624:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
   1b628:	84eb      	strh	r3, [r5, #38]	; 0x26
	remoteInfo->hNet = pSkt->pSktNet;
   1b62a:	6c23      	ldr	r3, [r4, #64]	; 0x40
   1b62c:	62ab      	str	r3, [r5, #40]	; 0x28
	remoteInfo->state = (TCPIP_TCP_STATE)pSkt->smState;
   1b62e:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
   1b632:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
    remoteInfo->rxSize = pSkt->rxEnd - pSkt->rxStart;
   1b636:	69a3      	ldr	r3, [r4, #24]
   1b638:	6962      	ldr	r2, [r4, #20]
   1b63a:	1a9b      	subs	r3, r3, r2
   1b63c:	85eb      	strh	r3, [r5, #46]	; 0x2e
    remoteInfo->txSize = pSkt->txEnd - pSkt->txStart;
   1b63e:	6863      	ldr	r3, [r4, #4]
   1b640:	6822      	ldr	r2, [r4, #0]
   1b642:	1a9b      	subs	r3, r3, r2
   1b644:	862b      	strh	r3, [r5, #48]	; 0x30
    remoteInfo->rxPending = _TCPIsGetReady(pSkt);
   1b646:	4620      	mov	r0, r4
   1b648:	f007 fc09 	bl	22e5e <_TCPIsGetReady>
   1b64c:	8668      	strh	r0, [r5, #50]	; 0x32
    remoteInfo->txPending = TCPIP_TCP_FifoTxFullGet(hTCP);
   1b64e:	4630      	mov	r0, r6
   1b650:	f003 fd54 	bl	1f0fc <TCPIP_TCP_FifoTxFullGet>
   1b654:	86a8      	strh	r0, [r5, #52]	; 0x34
    remoteInfo->flags = _TCP_SktFlagsGet(pSkt);
   1b656:	4620      	mov	r0, r4
   1b658:	f005 fa00 	bl	20a5c <_TCP_SktFlagsGet>
   1b65c:	f885 0036 	strb.w	r0, [r5, #54]	; 0x36
	return true;
   1b660:	2001      	movs	r0, #1
}
   1b662:	bd70      	pop	{r4, r5, r6, pc}
            remoteInfo->remoteIPaddress.v4Add = pSkt->destAddress;
   1b664:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1b666:	606b      	str	r3, [r5, #4]
            remoteInfo->localIPaddress.v4Add = pSkt->srcAddress;
   1b668:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1b66a:	616b      	str	r3, [r5, #20]
            remoteInfo->addressType = IP_ADDRESS_TYPE_IPV4;
   1b66c:	2301      	movs	r3, #1
   1b66e:	702b      	strb	r3, [r5, #0]
   1b670:	e7d5      	b.n	1b61e <TCPIP_TCP_SocketInfoGet+0x22>
        return false;
   1b672:	2000      	movs	r0, #0
   1b674:	e7f5      	b.n	1b662 <TCPIP_TCP_SocketInfoGet+0x66>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4%466:

0001b676 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4>:
{
   1b676:	b510      	push	{r4, lr}
   1b678:	4604      	mov	r4, r0
    DRV_ETHPHY_INSTANCE *hDriver = hClientObj->hDriver;
   1b67a:	68c1      	ldr	r1, [r0, #12]
    uint16_t  matchCpbl = hClientObj->operReg[1];
   1b67c:	8c83      	ldrh	r3, [r0, #36]	; 0x24
    if(matchCpbl &_BMSTAT_AN_ABLE_MASK)
   1b67e:	f013 0f08 	tst.w	r3, #8
   1b682:	d018      	beq.n	1b6b6 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4+0x40>
        anadReg = (((matchCpbl >> _BMSTAT_NEGOTIATION_POS) << _ANAD_NEGOTIATION_POS) & _ANAD_NEGOTIATION_MASK) | PROT_802_3;
   1b684:	0ada      	lsrs	r2, r3, #11
   1b686:	0152      	lsls	r2, r2, #5
   1b688:	f042 0201 	orr.w	r2, r2, #1
        if(hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_PAUSE)
   1b68c:	7bcb      	ldrb	r3, [r1, #15]
   1b68e:	f013 0f01 	tst.w	r3, #1
            anadReg |= _ANAD_PAUSE_MASK;
   1b692:	bf18      	it	ne
   1b694:	f442 6280 	orrne.w	r2, r2, #1024	; 0x400
        if(hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_ASM_DIR)
   1b698:	f013 0f02 	tst.w	r3, #2
            anadReg |= _ANAD_ASM_DIR_MASK;
   1b69c:	bf18      	it	ne
   1b69e:	f442 6200 	orrne.w	r2, r2, #2048	; 0x800
        if(_DRV_PHY_SMIWriteStart(hClientObj, PHY_REG_ANAD, anadReg))
   1b6a2:	2104      	movs	r1, #4
   1b6a4:	f005 fc7d 	bl	20fa2 <_DRV_PHY_SMIWriteStart>
   1b6a8:	b900      	cbnz	r0, 1b6ac <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4+0x36>
}
   1b6aa:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   1b6ac:	2303      	movs	r3, #3
   1b6ae:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1b6b0:	2305      	movs	r3, #5
   1b6b2:	8423      	strh	r3, [r4, #32]
   1b6b4:	e7f9      	b.n	1b6aa <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4+0x34>
        if(matchCpbl & (_BMSTAT_BASE100TX_HDX_MASK | _BMSTAT_BASE100TX_FDX_MASK))   // set 100Mbps request/capability
   1b6b6:	f403 42c0 	and.w	r2, r3, #24576	; 0x6000
            ctrlReg |= _BMCON_SPEED_MASK;
   1b6ba:	2a00      	cmp	r2, #0
   1b6bc:	bf18      	it	ne
   1b6be:	f44f 5200 	movne.w	r2, #8192	; 0x2000
        if(matchCpbl & (_BMSTAT_BASE10T_FDX_MASK | _BMSTAT_BASE100TX_FDX_MASK))
   1b6c2:	f413 4fa0 	tst.w	r3, #20480	; 0x5000
            ctrlReg |= _BMCON_DUPLEX_MASK;
   1b6c6:	bf18      	it	ne
   1b6c8:	f442 7280 	orrne.w	r2, r2, #256	; 0x100
        if(hClientObj->hDriver->openFlags & TCPIP_ETH_OPEN_PHY_LOOPBACK)
   1b6cc:	898b      	ldrh	r3, [r1, #12]
   1b6ce:	f013 0f80 	tst.w	r3, #128	; 0x80
            ctrlReg |= _BMCON_LOOPBACK_MASK;
   1b6d2:	bf1c      	itt	ne
   1b6d4:	f442 4280 	orrne.w	r2, r2, #16384	; 0x4000
   1b6d8:	b292      	uxthne	r2, r2
        if(_DRV_PHY_SMIWriteStart(hClientObj, PHY_REG_BMCON, ctrlReg))
   1b6da:	2100      	movs	r1, #0
   1b6dc:	f005 fc61 	bl	20fa2 <_DRV_PHY_SMIWriteStart>
   1b6e0:	2800      	cmp	r0, #0
   1b6e2:	d0e2      	beq.n	1b6aa <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4+0x34>
    hClientObj->operPhase = operPhase;
   1b6e4:	2303      	movs	r3, #3
   1b6e6:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1b6e8:	2307      	movs	r3, #7
   1b6ea:	8423      	strh	r3, [r4, #32]
}
   1b6ec:	e7dd      	b.n	1b6aa <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4+0x34>

Disassembly of section .text.DRV_PIC32CGMAC_LibTxInit%467:

0001b6f0 <DRV_PIC32CGMAC_LibTxInit>:
{
   1b6f0:	b410      	push	{r4}
    pL->head = pL->tail = 0;
   1b6f2:	2300      	movs	r3, #0
   1b6f4:	f8c0 30a8 	str.w	r3, [r0, #168]	; 0xa8
   1b6f8:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
    pL->nNodes = 0;
   1b6fc:	f8c0 30ac 	str.w	r3, [r0, #172]	; 0xac
		for(desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nTxDescCnt; desc_idx++)
   1b700:	f8b0 30c8 	ldrh.w	r3, [r0, #200]	; 0xc8
   1b704:	b35b      	cbz	r3, 1b75e <DRV_PIC32CGMAC_LibTxInit+0x6e>
   1b706:	2300      	movs	r3, #0
            pMACDrv->sGmacData.gmac_queue[queue_idx].nTxDescHead = 0;
   1b708:	4619      	mov	r1, r3
			pMACDrv->sGmacData.gmac_queue[queue_idx].pTxDesc[desc_idx].tx_desc_status.val = GMAC_TX_USED_BIT | GMAC_TX_LAST_BUFFER_BIT;
   1b70a:	f04f 2480 	mov.w	r4, #2147516416	; 0x80008000
            pMACDrv->sGmacData.gmac_queue[queue_idx].nTxDescHead = 0;
   1b70e:	f8a0 10b2 	strh.w	r1, [r0, #178]	; 0xb2
            pMACDrv->sGmacData.gmac_queue[queue_idx].nTxDescTail = 0;
   1b712:	f8a0 10b4 	strh.w	r1, [r0, #180]	; 0xb4
			pMACDrv->sGmacData.gmac_queue[queue_idx].pTxDesc[desc_idx].tx_desc_buffaddr = 0;
   1b716:	f8d0 20a0 	ldr.w	r2, [r0, #160]	; 0xa0
   1b71a:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
			pMACDrv->sGmacData.gmac_queue[queue_idx].pTxDesc[desc_idx].tx_desc_status.val = GMAC_TX_USED_BIT | GMAC_TX_LAST_BUFFER_BIT;
   1b71e:	f8d0 20a0 	ldr.w	r2, [r0, #160]	; 0xa0
   1b722:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
   1b726:	6054      	str	r4, [r2, #4]
		for(desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nTxDescCnt; desc_idx++)
   1b728:	3301      	adds	r3, #1
   1b72a:	b2db      	uxtb	r3, r3
   1b72c:	f8b0 20c8 	ldrh.w	r2, [r0, #200]	; 0xc8
   1b730:	429a      	cmp	r2, r3
   1b732:	d8ec      	bhi.n	1b70e <DRV_PIC32CGMAC_LibTxInit+0x1e>
		pMACDrv->sGmacData.gmac_queue[queue_idx].pTxDesc[desc_idx-1].tx_desc_status.val |= GMAC_TX_WRAP_BIT;
   1b734:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
   1b738:	3b01      	subs	r3, #1
   1b73a:	f8d0 20a0 	ldr.w	r2, [r0, #160]	; 0xa0
   1b73e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   1b742:	685a      	ldr	r2, [r3, #4]
   1b744:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
   1b748:	605a      	str	r2, [r3, #4]
		GMAC_REGS->GMAC_TBQB = GMAC_TBQB_ADDR_Msk & ((uint32_t)pMACDrv->sGmacData.gmac_queue[queue_idx].pTxDesc);
   1b74a:	f8d0 30a0 	ldr.w	r3, [r0, #160]	; 0xa0
   1b74e:	f023 0303 	bic.w	r3, r3, #3
   1b752:	4a04      	ldr	r2, [pc, #16]	; (1b764 <DRV_PIC32CGMAC_LibTxInit+0x74>)
   1b754:	61d3      	str	r3, [r2, #28]
}//DRV_PIC32CGMAC_LibTxInit
   1b756:	2000      	movs	r0, #0
   1b758:	f85d 4b04 	ldr.w	r4, [sp], #4
   1b75c:	4770      	bx	lr
		for(desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nTxDescCnt; desc_idx++)
   1b75e:	2300      	movs	r3, #0
   1b760:	e7e8      	b.n	1b734 <DRV_PIC32CGMAC_LibTxInit+0x44>
   1b762:	bf00      	nop
   1b764:	42000800 	.word	0x42000800

Disassembly of section .text.DRV_MIIM_Open%468:

0001b768 <DRV_MIIM_Open>:
{
   1b768:	b510      	push	{r4, lr}
        if(iModule >= DRV_MIIM_INSTANCES_NUMBER)
   1b76a:	b118      	cbz	r0, 1b774 <DRV_MIIM_Open+0xc>
    DRV_HANDLE drvHandle = DRV_HANDLE_INVALID;
   1b76c:	f04f 34ff 	mov.w	r4, #4294967295
}
   1b770:	4620      	mov	r0, r4
   1b772:	bd10      	pop	{r4, pc}
   1b774:	460c      	mov	r4, r1
        pMiimObj = _DRV_MIIM_GetObjectAndLock((SYS_MODULE_OBJ)(gDrvMIIMObj + iModule));
   1b776:	4819      	ldr	r0, [pc, #100]	; (1b7dc <DRV_MIIM_Open+0x74>)
   1b778:	f005 ff5f 	bl	2163a <_DRV_MIIM_GetObjectAndLock>
        if(pMiimObj == 0)
   1b77c:	4603      	mov	r3, r0
   1b77e:	b180      	cbz	r0, 1b7a2 <DRV_MIIM_Open+0x3a>
        if((ioIntent & DRV_IO_INTENT_EXCLUSIVE) != 0)
   1b780:	f014 0108 	ands.w	r1, r4, #8
   1b784:	d001      	beq.n	1b78a <DRV_MIIM_Open+0x22>
            if(pMiimObj->numClients > 0)
   1b786:	88c2      	ldrh	r2, [r0, #6]
   1b788:	b972      	cbnz	r2, 1b7a8 <DRV_MIIM_Open+0x40>
        if(pClient->clientInUse == 0)
   1b78a:	8a1a      	ldrh	r2, [r3, #16]
   1b78c:	b17a      	cbz	r2, 1b7ae <DRV_MIIM_Open+0x46>
    for(ix = 0; ix < sizeof(pMiimObj->objClients) / sizeof(*pMiimObj->objClients); ix++, pClient++)
   1b78e:	f103 0420 	add.w	r4, r3, #32
        if(pClient->clientInUse == 0)
   1b792:	8c1a      	ldrh	r2, [r3, #32]
   1b794:	b302      	cbz	r2, 1b7d8 <DRV_MIIM_Open+0x70>
    DRV_HANDLE drvHandle = DRV_HANDLE_INVALID;
   1b796:	f04f 34ff 	mov.w	r4, #4294967295
    OSAL_SEM_Post(&pMiimObj->objSem);
   1b79a:	4618      	mov	r0, r3
   1b79c:	f007 fff6 	bl	2378c <OSAL_SEM_Post>
   1b7a0:	e7e6      	b.n	1b770 <DRV_MIIM_Open+0x8>
    DRV_HANDLE drvHandle = DRV_HANDLE_INVALID;
   1b7a2:	f04f 34ff 	mov.w	r4, #4294967295
    return drvHandle;
   1b7a6:	e7e3      	b.n	1b770 <DRV_MIIM_Open+0x8>
    DRV_HANDLE drvHandle = DRV_HANDLE_INVALID;
   1b7a8:	f04f 34ff 	mov.w	r4, #4294967295
   1b7ac:	e7f5      	b.n	1b79a <DRV_MIIM_Open+0x32>
    DRV_MIIM_CLIENT_DCPT* pClient = pMiimObj->objClients;
   1b7ae:	f103 0410 	add.w	r4, r3, #16
    for(ix = 0; ix < sizeof(pMiimObj->objClients) / sizeof(*pMiimObj->objClients); ix++, pClient++)
   1b7b2:	2000      	movs	r0, #0
            memset(pClient, 0, sizeof(*pClient));
   1b7b4:	2200      	movs	r2, #0
   1b7b6:	60a2      	str	r2, [r4, #8]
   1b7b8:	60e2      	str	r2, [r4, #12]
            pClient->clientInUse = true;
   1b7ba:	2201      	movs	r2, #1
   1b7bc:	8022      	strh	r2, [r4, #0]
            pClient->clientIx = clientIx;
   1b7be:	8060      	strh	r0, [r4, #2]
            pClient->parentObj  = pMiimObj;
   1b7c0:	6063      	str	r3, [r4, #4]
            pClient->cliStatus = DRV_MIIM_CLIENT_STATUS_READY;
   1b7c2:	2202      	movs	r2, #2
   1b7c4:	7322      	strb	r2, [r4, #12]
            if((ioIntent & DRV_IO_INTENT_EXCLUSIVE) != 0)
   1b7c6:	b119      	cbz	r1, 1b7d0 <DRV_MIIM_Open+0x68>
                pMiimObj->objFlags |= DRV_MIIM_OBJ_FLAG_EXCLUSIVE;
   1b7c8:	889a      	ldrh	r2, [r3, #4]
   1b7ca:	f042 0204 	orr.w	r2, r2, #4
   1b7ce:	809a      	strh	r2, [r3, #4]
            pMiimObj->numClients++;
   1b7d0:	88da      	ldrh	r2, [r3, #6]
   1b7d2:	3201      	adds	r2, #1
   1b7d4:	80da      	strh	r2, [r3, #6]
            drvHandle =  (DRV_HANDLE)pClient;
   1b7d6:	e7e0      	b.n	1b79a <DRV_MIIM_Open+0x32>
        if(pClient->clientInUse == 0)
   1b7d8:	2001      	movs	r0, #1
   1b7da:	e7eb      	b.n	1b7b4 <DRV_MIIM_Open+0x4c>
   1b7dc:	2000e5c0 	.word	0x2000e5c0

Disassembly of section .text.DRV_MIIM_Initialize%469:

0001b7e0 <DRV_MIIM_Initialize>:
{
   1b7e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(iModule >= DRV_MIIM_INSTANCES_NUMBER)
   1b7e2:	bb70      	cbnz	r0, 1b842 <DRV_MIIM_Initialize+0x62>
    pMiimObj = _DRV_MIIM_GetObject((SYS_MODULE_OBJ)(gDrvMIIMObj + iModule));
   1b7e4:	4e1b      	ldr	r6, [pc, #108]	; (1b854 <DRV_MIIM_Initialize+0x74>)
        if(pMiimObj->objStatus == SYS_STATUS_READY && (pMiimObj->objFlags & DRV_MIIM_OBJ_FLAG_IN_USE) != 0)
   1b7e6:	f996 3008 	ldrsb.w	r3, [r6, #8]
   1b7ea:	2b02      	cmp	r3, #2
   1b7ec:	d103      	bne.n	1b7f6 <DRV_MIIM_Initialize+0x16>
   1b7ee:	88b3      	ldrh	r3, [r6, #4]
   1b7f0:	f013 0f01 	tst.w	r3, #1
   1b7f4:	d123      	bne.n	1b83e <DRV_MIIM_Initialize+0x5e>
   1b7f6:	460d      	mov	r5, r1
    memset(pMiimObj, 0, sizeof(*pMiimObj));
   1b7f8:	2294      	movs	r2, #148	; 0x94
   1b7fa:	2100      	movs	r1, #0
   1b7fc:	4815      	ldr	r0, [pc, #84]	; (1b854 <DRV_MIIM_Initialize+0x74>)
   1b7fe:	f008 fb4f 	bl	23ea0 <memset>
    if((miimInit = (DRV_MIIM_INIT*) init) == 0)
   1b802:	b30d      	cbz	r5, 1b848 <DRV_MIIM_Initialize+0x68>
    if(OSAL_SEM_Create(&pMiimObj->objSem, OSAL_SEM_TYPE_BINARY, 1, 1) != OSAL_RESULT_TRUE)
   1b804:	2301      	movs	r3, #1
   1b806:	461a      	mov	r2, r3
   1b808:	2100      	movs	r1, #0
   1b80a:	4812      	ldr	r0, [pc, #72]	; (1b854 <DRV_MIIM_Initialize+0x74>)
   1b80c:	f002 f958 	bl	1dac0 <OSAL_SEM_Create>
   1b810:	2801      	cmp	r0, #1
   1b812:	d11c      	bne.n	1b84e <DRV_MIIM_Initialize+0x6e>
    pMiimObj->objFlags = DRV_MIIM_OBJ_FLAG_IN_USE;      // Set object to be in use
   1b814:	4c0f      	ldr	r4, [pc, #60]	; (1b854 <DRV_MIIM_Initialize+0x74>)
   1b816:	2301      	movs	r3, #1
   1b818:	80a3      	strh	r3, [r4, #4]
    pMiimObj->objStatus = SYS_STATUS_READY; // Set module state
   1b81a:	2302      	movs	r3, #2
   1b81c:	7223      	strb	r3, [r4, #8]
    pMiimObj->iModule  = iModule;  // Store driver instance
   1b81e:	2300      	movs	r3, #0
   1b820:	8163      	strh	r3, [r4, #10]
    pMiimObj->ethphyId = miimInit->ethphyId; // Store PLIB ID
   1b822:	686b      	ldr	r3, [r5, #4]
   1b824:	60e3      	str	r3, [r4, #12]
    DRV_MIIM_OP_DCPT* pOpDcpt = pMiimObj->opPool;
   1b826:	3430      	adds	r4, #48	; 0x30
        pOpDcpt->qType = DRV_MIIM_QTYPE_FREE;
   1b828:	2701      	movs	r7, #1
        Helper_SingleListTailAdd(&pMiimObj->freeOpList, (SGL_LIST_NODE*)pOpDcpt);
   1b82a:	f104 0540 	add.w	r5, r4, #64	; 0x40
        pOpDcpt->qType = DRV_MIIM_QTYPE_FREE;
   1b82e:	72e7      	strb	r7, [r4, #11]
        Helper_SingleListTailAdd(&pMiimObj->freeOpList, (SGL_LIST_NODE*)pOpDcpt);
   1b830:	4621      	mov	r1, r4
   1b832:	4628      	mov	r0, r5
   1b834:	f007 fd9f 	bl	23376 <Helper_SingleListTailAdd>
    for(ix = 0; ix < sizeof(pMiimObj->opPool) / sizeof(*pMiimObj->opPool); ix++, pOpDcpt++)
   1b838:	3410      	adds	r4, #16
   1b83a:	42ac      	cmp	r4, r5
   1b83c:	d1f7      	bne.n	1b82e <DRV_MIIM_Initialize+0x4e>
}
   1b83e:	4630      	mov	r0, r6
   1b840:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return SYS_MODULE_OBJ_INVALID;
   1b842:	f04f 36ff 	mov.w	r6, #4294967295
   1b846:	e7fa      	b.n	1b83e <DRV_MIIM_Initialize+0x5e>
        return SYS_MODULE_OBJ_INVALID;
   1b848:	f04f 36ff 	mov.w	r6, #4294967295
   1b84c:	e7f7      	b.n	1b83e <DRV_MIIM_Initialize+0x5e>
        return SYS_MODULE_OBJ_INVALID;
   1b84e:	f04f 36ff 	mov.w	r6, #4294967295
   1b852:	e7f4      	b.n	1b83e <DRV_MIIM_Initialize+0x5e>
   1b854:	2000e5c0 	.word	0x2000e5c0

Disassembly of section .rodata%470:

0001b858 <.rodata%470>:
   1b858:	34765049 	.word	0x34765049
   1b85c:	696e4920 	.word	0x696e4920
   1b860:	46203a74 	.word	0x46203a74
   1b864:	656c6961 	.word	0x656c6961
   1b868:	6f742064 	.word	0x6f742064
   1b86c:	696e6920 	.word	0x696e6920
   1b870:	696c6174 	.word	0x696c6174
   1b874:	203a657a 	.word	0x203a657a
   1b878:	20216425 	.word	0x20216425
   1b87c:	00000a0d 	.word	0x00000a0d
   1b880:	34765049 	.word	0x34765049
   1b884:	6146203a 	.word	0x6146203a
   1b888:	64656c69 	.word	0x64656c69
   1b88c:	206f7420 	.word	0x206f7420
   1b890:	69676572 	.word	0x69676572
   1b894:	72657473 	.word	0x72657473
   1b898:	50524120 	.word	0x50524120
   1b89c:	746f6e20 	.word	0x746f6e20
   1b8a0:	63696669 	.word	0x63696669
   1b8a4:	6f697461 	.word	0x6f697461
   1b8a8:	0d20216e 	.word	0x0d20216e
   1b8ac:	0000000a 	.word	0x0000000a
   1b8b0:	34765049 	.word	0x34765049
   1b8b4:	5241203a 	.word	0x5241203a
   1b8b8:	6e652050 	.word	0x6e652050
   1b8bc:	65697274 	.word	0x65697274
   1b8c0:	6f702073 	.word	0x6f702073
   1b8c4:	65206c6f 	.word	0x65206c6f
   1b8c8:	7974706d 	.word	0x7974706d
   1b8cc:	000a0d21 	.word	0x000a0d21

Disassembly of section .text.TCPIP_Helper_PacketCopy%471:

0001b8d0 <TCPIP_Helper_PacketCopy>:

// copies packet segment data to a linear destination buffer
// updates the pointer to the current location in the packet segment for further copy
// returns the number of total bytes copied
uint16_t TCPIP_Helper_PacketCopy(TCPIP_MAC_PACKET* pSrcPkt, uint8_t* pDest, uint8_t** pStartAdd, uint16_t len, bool srchTransport)
{
   1b8d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1b8d4:	4688      	mov	r8, r1
   1b8d6:	4692      	mov	sl, r2
   1b8d8:	461e      	mov	r6, r3
    uint16_t copyLen, copyBytes;
    uint8_t  *pCopyBuff, *pSrcBuff;
    uint16_t totCopyBytes = 0;

    copyLen = len;
    pCopyBuff = pSrcBuff = *pStartAdd; 
   1b8da:	6817      	ldr	r7, [r2, #0]
    pSeg = TCPIP_PKT_DataSegmentGet(pSrcPkt, pSrcBuff, srchTransport);
   1b8dc:	f89d 2020 	ldrb.w	r2, [sp, #32]
   1b8e0:	4639      	mov	r1, r7
   1b8e2:	f000 fb9f 	bl	1c024 <TCPIP_PKT_DataSegmentGet>

    while(pSeg != 0 && copyLen != 0)
   1b8e6:	b320      	cbz	r0, 1b932 <TCPIP_Helper_PacketCopy+0x62>
   1b8e8:	4605      	mov	r5, r0
   1b8ea:	b356      	cbz	r6, 1b942 <TCPIP_Helper_PacketCopy+0x72>
    pCopyBuff = pSrcBuff = *pStartAdd; 
   1b8ec:	463a      	mov	r2, r7
    uint16_t totCopyBytes = 0;
   1b8ee:	f04f 0900 	mov.w	r9, #0
   1b8f2:	e00f      	b.n	1b914 <TCPIP_Helper_PacketCopy+0x44>
            copyBytes = copyLen;
        } 

        if(copyBytes)
        {
            memcpy(pDest, pCopyBuff, copyBytes);
   1b8f4:	4622      	mov	r2, r4
   1b8f6:	4639      	mov	r1, r7
   1b8f8:	4640      	mov	r0, r8
   1b8fa:	f007 fcf7 	bl	232ec <memcpy>
            pDest += copyBytes;
   1b8fe:	44a0      	add	r8, r4
            copyLen -= copyBytes;
   1b900:	1b36      	subs	r6, r6, r4
   1b902:	b2b6      	uxth	r6, r6
            pSrcBuff = pCopyBuff + copyBytes;
   1b904:	193a      	adds	r2, r7, r4
            totCopyBytes += copyBytes;
   1b906:	44a1      	add	r9, r4
   1b908:	fa1f f989 	uxth.w	r9, r9
        }

        pSeg = pSeg->next;
   1b90c:	682d      	ldr	r5, [r5, #0]
        if(pSeg)
   1b90e:	b19d      	cbz	r5, 1b938 <TCPIP_Helper_PacketCopy+0x68>
        {
            pCopyBuff = pSeg->segLoad;
   1b910:	68af      	ldr	r7, [r5, #8]
    while(pSeg != 0 && copyLen != 0)
   1b912:	b18e      	cbz	r6, 1b938 <TCPIP_Helper_PacketCopy+0x68>
        copyBytes = (pSeg->segLoad + pSeg->segSize) - pCopyBuff;
   1b914:	89ec      	ldrh	r4, [r5, #14]
   1b916:	68ab      	ldr	r3, [r5, #8]
   1b918:	4423      	add	r3, r4
   1b91a:	1bdb      	subs	r3, r3, r7
   1b91c:	b29b      	uxth	r3, r3
        if(copyBytes > copyLen)
   1b91e:	89ac      	ldrh	r4, [r5, #12]
   1b920:	42b4      	cmp	r4, r6
   1b922:	bf28      	it	cs
   1b924:	4634      	movcs	r4, r6
   1b926:	429c      	cmp	r4, r3
   1b928:	bf28      	it	cs
   1b92a:	461c      	movcs	r4, r3
        if(copyBytes)
   1b92c:	2c00      	cmp	r4, #0
   1b92e:	d0ed      	beq.n	1b90c <TCPIP_Helper_PacketCopy+0x3c>
   1b930:	e7e0      	b.n	1b8f4 <TCPIP_Helper_PacketCopy+0x24>
    pCopyBuff = pSrcBuff = *pStartAdd; 
   1b932:	463a      	mov	r2, r7
    uint16_t totCopyBytes = 0;
   1b934:	f04f 0900 	mov.w	r9, #0
        }
    }
    
    *pStartAdd = pSrcBuff;
   1b938:	f8ca 2000 	str.w	r2, [sl]

    return totCopyBytes;
}
   1b93c:	4648      	mov	r0, r9
   1b93e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    uint16_t totCopyBytes = 0;
   1b942:	46b1      	mov	r9, r6
    pCopyBuff = pSrcBuff = *pStartAdd; 
   1b944:	463a      	mov	r2, r7
   1b946:	e7f7      	b.n	1b938 <TCPIP_Helper_PacketCopy+0x68>

Disassembly of section .rodata.TCPIP_STACK_MODULE_ENTRY_TBL%472:

0001b948 <TCPIP_STACK_MODULE_ENTRY_TBL>:
   1b948:	0002 0000 0759 0001 ec81 0001 0003 0000     ....Y...........
   1b958:	4031 0001 7d65 0001 0006 0000 c481 0001     1@..e}..........
   1b968:	1ef5 0002 0009 0000 5751 0001 369d 0001     ........QW...6..
   1b978:	000a 0000 318d 0001 5e49 0001 000c 0000     .....1..I^......
   1b988:	1aad 0001 f9a5 0001 000d 0000 cba9 0000     ................
   1b998:	fb65 0001 000f 0000 fd85 0000 d1c1 0001     e...............
   1b9a8:	001f 0000 8985 0001 06ed 0002 0020 0000     ............ ...
   1b9b8:	810d 0001 dd19 0001                         ........

Disassembly of section .text.SERCOM1_USART_Read%473:

0001b9c0 <SERCOM1_USART_Read>:
{
   1b9c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    rdOutIndex = sercom1USARTObj.rdOutIndex;
   1b9c4:	4c19      	ldr	r4, [pc, #100]	; (1ba2c <SERCOM1_USART_Read+0x6c>)
   1b9c6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    rdInIndex = sercom1USARTObj.rdInIndex;
   1b9c8:	6aa4      	ldr	r4, [r4, #40]	; 0x28
    while (nBytesRead < size)
   1b9ca:	b349      	cbz	r1, 1ba20 <SERCOM1_USART_Read+0x60>
   1b9cc:	460d      	mov	r5, r1
        if (rdOutIndex != rdInIndex)
   1b9ce:	42a3      	cmp	r3, r4
   1b9d0:	d029      	beq.n	1ba26 <SERCOM1_USART_Read+0x66>
            if (rdOutIndex >= sercom1USARTObj.rdBufferSize)
   1b9d2:	4a16      	ldr	r2, [pc, #88]	; (1ba2c <SERCOM1_USART_Read+0x6c>)
   1b9d4:	6b17      	ldr	r7, [r2, #48]	; 0x30
   1b9d6:	4602      	mov	r2, r0
            if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   1b9d8:	4e15      	ldr	r6, [pc, #84]	; (1ba30 <SERCOM1_USART_Read+0x70>)
   1b9da:	f1c0 0e01 	rsb	lr, r0, #1
                ((uint16_t*)pRdBuffer)[nBytesRead++] = ((uint16_t*)&SERCOM1_USART_ReadBuffer)[rdOutIndex++];
   1b9de:	f8df c054 	ldr.w	ip, [pc, #84]	; 1ba34 <SERCOM1_USART_Read+0x74>
   1b9e2:	f1c0 0800 	rsb	r8, r0, #0
            if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   1b9e6:	6871      	ldr	r1, [r6, #4]
   1b9e8:	f001 0107 	and.w	r1, r1, #7
   1b9ec:	2901      	cmp	r1, #1
                pRdBuffer[nBytesRead++] = SERCOM1_USART_ReadBuffer[rdOutIndex++];
   1b9ee:	eb0e 0002 	add.w	r0, lr, r2
   1b9f2:	bf19      	ittee	ne
   1b9f4:	f81c 1003 	ldrbne.w	r1, [ip, r3]
   1b9f8:	7011      	strbne	r1, [r2, #0]
                ((uint16_t*)pRdBuffer)[nBytesRead++] = ((uint16_t*)&SERCOM1_USART_ReadBuffer)[rdOutIndex++];
   1b9fa:	f83c 1013 	ldrheq.w	r1, [ip, r3, lsl #1]
   1b9fe:	f828 1012 	strheq.w	r1, [r8, r2, lsl #1]
   1ba02:	3301      	adds	r3, #1
                rdOutIndex = 0U;
   1ba04:	429f      	cmp	r7, r3
   1ba06:	bf98      	it	ls
   1ba08:	2300      	movls	r3, #0
    while (nBytesRead < size)
   1ba0a:	42a8      	cmp	r0, r5
   1ba0c:	d203      	bcs.n	1ba16 <SERCOM1_USART_Read+0x56>
        if (rdOutIndex != rdInIndex)
   1ba0e:	3201      	adds	r2, #1
   1ba10:	42a3      	cmp	r3, r4
   1ba12:	d1e8      	bne.n	1b9e6 <SERCOM1_USART_Read+0x26>
   1ba14:	e000      	b.n	1ba18 <SERCOM1_USART_Read+0x58>
   1ba16:	461c      	mov	r4, r3
    sercom1USARTObj.rdOutIndex = rdOutIndex;
   1ba18:	4b04      	ldr	r3, [pc, #16]	; (1ba2c <SERCOM1_USART_Read+0x6c>)
   1ba1a:	62dc      	str	r4, [r3, #44]	; 0x2c
}
   1ba1c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    rdOutIndex = sercom1USARTObj.rdOutIndex;
   1ba20:	461c      	mov	r4, r3
    size_t nBytesRead = 0U;
   1ba22:	4608      	mov	r0, r1
   1ba24:	e7f8      	b.n	1ba18 <SERCOM1_USART_Read+0x58>
   1ba26:	2000      	movs	r0, #0
   1ba28:	e7f6      	b.n	1ba18 <SERCOM1_USART_Read+0x58>
   1ba2a:	bf00      	nop
   1ba2c:	2000e9c0 	.word	0x2000e9c0
   1ba30:	40003400 	.word	0x40003400
   1ba34:	2000a004 	.word	0x2000a004

Disassembly of section .text.SERCOM1_USART_Virtual_Receive%474:

0001ba38 <SERCOM1_USART_Virtual_Receive>:
void SERCOM1_USART_Virtual_Receive(char *str) {
   1ba38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    while (*str!=0) {
   1ba3c:	7805      	ldrb	r5, [r0, #0]
   1ba3e:	2d00      	cmp	r5, #0
   1ba40:	d02e      	beq.n	1baa0 <SERCOM1_USART_Virtual_Receive+0x68>
   1ba42:	4606      	mov	r6, r0
    tempInIndex = sercom1USARTObj.rdInIndex + 1U;
   1ba44:	4c17      	ldr	r4, [pc, #92]	; (1baa4 <SERCOM1_USART_Virtual_Receive+0x6c>)
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   1ba46:	4f18      	ldr	r7, [pc, #96]	; (1baa8 <SERCOM1_USART_Virtual_Receive+0x70>)
            ((uint16_t*)&SERCOM1_USART_ReadBuffer)[sercom1USARTObj.rdInIndex] = rdByte;
   1ba48:	f8df 8060 	ldr.w	r8, [pc, #96]	; 1baac <SERCOM1_USART_Virtual_Receive+0x74>
   1ba4c:	e01b      	b.n	1ba86 <SERCOM1_USART_Virtual_Receive+0x4e>
        if(sercom1USARTObj.rdCallback != NULL)
   1ba4e:	6a22      	ldr	r2, [r4, #32]
   1ba50:	b312      	cbz	r2, 1ba98 <SERCOM1_USART_Virtual_Receive+0x60>
            sercom1USARTObj.rdCallback(SERCOM_USART_EVENT_READ_BUFFER_FULL, sercom1USARTObj.rdContext);
   1ba52:	6a61      	ldr	r1, [r4, #36]	; 0x24
   1ba54:	2001      	movs	r0, #1
   1ba56:	4790      	blx	r2
            tempInIndex = sercom1USARTObj.rdInIndex + 1U;
   1ba58:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1ba5a:	3301      	adds	r3, #1
            if (tempInIndex >= sercom1USARTObj.rdBufferSize)
   1ba5c:	6b22      	ldr	r2, [r4, #48]	; 0x30
                tempInIndex = 0U;
   1ba5e:	4293      	cmp	r3, r2
   1ba60:	bf28      	it	cs
   1ba62:	2300      	movcs	r3, #0
   1ba64:	e018      	b.n	1ba98 <SERCOM1_USART_Virtual_Receive+0x60>
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   1ba66:	687a      	ldr	r2, [r7, #4]
   1ba68:	f002 0207 	and.w	r2, r2, #7
   1ba6c:	2a01      	cmp	r2, #1
            SERCOM1_USART_ReadBuffer[sercom1USARTObj.rdInIndex] = (uint8_t)rdByte;
   1ba6e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   1ba70:	bf14      	ite	ne
   1ba72:	f808 5002 	strbne.w	r5, [r8, r2]
        if (SERCOM1_USART_RxPushByte(*str) == true) {
   1ba76:	f828 5012 	strheq.w	r5, [r8, r2, lsl #1]
        sercom1USARTObj.rdInIndex = tempInIndex;
   1ba7a:	62a3      	str	r3, [r4, #40]	; 0x28
            SERCOM1_USART_ReadNotificationSend();
   1ba7c:	f003 f9d8 	bl	1ee30 <SERCOM1_USART_ReadNotificationSend>
    while (*str!=0) {
   1ba80:	f816 5f01 	ldrb.w	r5, [r6, #1]!
   1ba84:	b165      	cbz	r5, 1baa0 <SERCOM1_USART_Virtual_Receive+0x68>
    tempInIndex = sercom1USARTObj.rdInIndex + 1U;
   1ba86:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1ba88:	3301      	adds	r3, #1
    if (tempInIndex >= sercom1USARTObj.rdBufferSize)
   1ba8a:	6b22      	ldr	r2, [r4, #48]	; 0x30
        tempInIndex = 0U;
   1ba8c:	4293      	cmp	r3, r2
   1ba8e:	bf28      	it	cs
   1ba90:	2300      	movcs	r3, #0
    if (tempInIndex == sercom1USARTObj.rdOutIndex)
   1ba92:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   1ba94:	429a      	cmp	r2, r3
   1ba96:	d0da      	beq.n	1ba4e <SERCOM1_USART_Virtual_Receive+0x16>
    if (tempInIndex != sercom1USARTObj.rdOutIndex)
   1ba98:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   1ba9a:	429a      	cmp	r2, r3
   1ba9c:	d1e3      	bne.n	1ba66 <SERCOM1_USART_Virtual_Receive+0x2e>
   1ba9e:	e7ef      	b.n	1ba80 <SERCOM1_USART_Virtual_Receive+0x48>
}
   1baa0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1baa4:	2000e9c0 	.word	0x2000e9c0
   1baa8:	40003400 	.word	0x40003400
   1baac:	2000a004 	.word	0x2000a004

Disassembly of section .text.__sfp%475:

0001bab0 <__sfp>:
   1bab0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1bab2:	4b1b      	ldr	r3, [pc, #108]	; (1bb20 <__sfp+0x70>)
   1bab4:	681e      	ldr	r6, [r3, #0]
   1bab6:	69b3      	ldr	r3, [r6, #24]
   1bab8:	4607      	mov	r7, r0
   1baba:	b913      	cbnz	r3, 1bac2 <__sfp+0x12>
   1babc:	4630      	mov	r0, r6
   1babe:	f001 fc6f 	bl	1d3a0 <__sinit>
   1bac2:	3648      	adds	r6, #72	; 0x48
   1bac4:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
   1bac8:	3b01      	subs	r3, #1
   1baca:	d503      	bpl.n	1bad4 <__sfp+0x24>
   1bacc:	6833      	ldr	r3, [r6, #0]
   1bace:	b1db      	cbz	r3, 1bb08 <__sfp+0x58>
   1bad0:	6836      	ldr	r6, [r6, #0]
   1bad2:	e7f7      	b.n	1bac4 <__sfp+0x14>
   1bad4:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
   1bad8:	b9a5      	cbnz	r5, 1bb04 <__sfp+0x54>
   1bada:	4b12      	ldr	r3, [pc, #72]	; (1bb24 <__sfp+0x74>)
   1badc:	6625      	str	r5, [r4, #96]	; 0x60
   1bade:	e9c4 5500 	strd	r5, r5, [r4]
   1bae2:	60a5      	str	r5, [r4, #8]
   1bae4:	e9c4 3503 	strd	r3, r5, [r4, #12]
   1bae8:	e9c4 5505 	strd	r5, r5, [r4, #20]
   1baec:	2208      	movs	r2, #8
   1baee:	4629      	mov	r1, r5
   1baf0:	f104 0058 	add.w	r0, r4, #88	; 0x58
   1baf4:	f008 f9d4 	bl	23ea0 <memset>
   1baf8:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
   1bafc:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
   1bb00:	4620      	mov	r0, r4
   1bb02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1bb04:	3464      	adds	r4, #100	; 0x64
   1bb06:	e7df      	b.n	1bac8 <__sfp+0x18>
   1bb08:	2104      	movs	r1, #4
   1bb0a:	4638      	mov	r0, r7
   1bb0c:	f006 f890 	bl	21c30 <__sfmoreglue>
   1bb10:	4604      	mov	r4, r0
   1bb12:	6030      	str	r0, [r6, #0]
   1bb14:	2800      	cmp	r0, #0
   1bb16:	d1db      	bne.n	1bad0 <__sfp+0x20>
   1bb18:	230c      	movs	r3, #12
   1bb1a:	603b      	str	r3, [r7, #0]
   1bb1c:	e7f0      	b.n	1bb00 <__sfp+0x50>
   1bb1e:	bf00      	nop
   1bb20:	000244b0 	.word	0x000244b0
   1bb24:	ffff0001 	.word	0xffff0001

Disassembly of section .text._DRV_GMAC_LinkStateNegResult%476:

0001bb28 <_DRV_GMAC_LinkStateNegResult>:
{
   1bb28:	b530      	push	{r4, r5, lr}
   1bb2a:	b083      	sub	sp, #12
   1bb2c:	4604      	mov	r4, r0
	DRV_ETHPHY_CONFIG_FLAGS phyCfgFlags = 0;
   1bb2e:	2300      	movs	r3, #0
   1bb30:	f88d 3007 	strb.w	r3, [sp, #7]
	pPhyBase =  pMACDrv->sGmacData.gmacConfig.pPhyBase;
   1bb34:	f8d0 50d8 	ldr.w	r5, [r0, #216]	; 0xd8
	phyStat = pPhyBase->DRV_ETHPHY_ClientStatus( pMACDrv->sGmacData.hPhyClient );
   1bb38:	69eb      	ldr	r3, [r5, #28]
   1bb3a:	6900      	ldr	r0, [r0, #16]
   1bb3c:	4798      	blx	r3
	if(phyStat == DRV_ETHPHY_CLIENT_STATUS_BUSY)
   1bb3e:	2801      	cmp	r0, #1
   1bb40:	d023      	beq.n	1bb8a <_DRV_GMAC_LinkStateNegResult+0x62>
	phyRes = pPhyBase->DRV_ETHPHY_ClientOperationResult(pMACDrv->sGmacData.hPhyClient);
   1bb42:	6a2b      	ldr	r3, [r5, #32]
   1bb44:	6920      	ldr	r0, [r4, #16]
   1bb46:	4798      	blx	r3
	if(phyRes != DRV_ETHPHY_RES_OK)
   1bb48:	bb08      	cbnz	r0, 1bb8e <_DRV_GMAC_LinkStateNegResult+0x66>
	if( (pMACDrv->sGmacData._negResult.linkStatus & DRV_ETHPHY_LINK_ST_UP) != 0 )
   1bb4a:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
   1bb4e:	f013 0f01 	tst.w	r3, #1
   1bb52:	d020      	beq.n	1bb96 <_DRV_GMAC_LinkStateNegResult+0x6e>
		pPhyBase->DRV_ETHPHY_HWConfigFlagsGet(pMACDrv->sGmacData.hPhyClient, &phyCfgFlags);
   1bb54:	6b6b      	ldr	r3, [r5, #52]	; 0x34
   1bb56:	f10d 0107 	add.w	r1, sp, #7
   1bb5a:	6920      	ldr	r0, [r4, #16]
   1bb5c:	4798      	blx	r3
		pMACDrv->sGmacData._negResult.linkFlags |= (phyCfgFlags & DRV_ETHPHY_CFG_RMII) ? TCPIP_ETH_OPEN_RMII : TCPIP_ETH_OPEN_MII ;
   1bb5e:	f89d 1007 	ldrb.w	r1, [sp, #7]
   1bb62:	0289      	lsls	r1, r1, #10
   1bb64:	f401 6180 	and.w	r1, r1, #1024	; 0x400
   1bb68:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
   1bb6c:	4319      	orrs	r1, r3
   1bb6e:	f8a4 1042 	strh.w	r1, [r4, #66]	; 0x42
		DRV_PIC32CGMAC_LibMACOpen(pMACDrv, pMACDrv->sGmacData._negResult.linkFlags, pauseType);
   1bb72:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
   1bb76:	4620      	mov	r0, r4
   1bb78:	f000 fc16 	bl	1c3a8 <DRV_PIC32CGMAC_LibMACOpen>
		pMACDrv->sGmacData._macFlags._linkPrev = 1;
   1bb7c:	7da3      	ldrb	r3, [r4, #22]
   1bb7e:	f043 0310 	orr.w	r3, r3, #16
   1bb82:	75a3      	strb	r3, [r4, #22]
		pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_START_LINK;
   1bb84:	2300      	movs	r3, #0
   1bb86:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
}
   1bb8a:	b003      	add	sp, #12
   1bb8c:	bd30      	pop	{r4, r5, pc}
		_DRV_GMAC_LinkStateDown(pMACDrv);
   1bb8e:	4620      	mov	r0, r4
   1bb90:	f007 f956 	bl	22e40 <_DRV_GMAC_LinkStateDown>
		return;
   1bb94:	e7f9      	b.n	1bb8a <_DRV_GMAC_LinkStateNegResult+0x62>
		_DRV_GMAC_LinkStateDown(pMACDrv);
   1bb96:	4620      	mov	r0, r4
   1bb98:	f007 f952 	bl	22e40 <_DRV_GMAC_LinkStateDown>
   1bb9c:	e7f5      	b.n	1bb8a <_DRV_GMAC_LinkStateNegResult+0x62>

Disassembly of section .text.prvCopyDataToQueue%477:

0001bb9e <prvCopyDataToQueue>:
{
   1bb9e:	b570      	push	{r4, r5, r6, lr}
   1bba0:	4604      	mov	r4, r0
   1bba2:	4616      	mov	r6, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   1bba4:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   1bba6:	6c02      	ldr	r2, [r0, #64]	; 0x40
   1bba8:	b95a      	cbnz	r2, 1bbc2 <prvCopyDataToQueue+0x24>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   1bbaa:	6803      	ldr	r3, [r0, #0]
   1bbac:	b11b      	cbz	r3, 1bbb6 <prvCopyDataToQueue+0x18>
BaseType_t xReturn = pdFALSE;
   1bbae:	2000      	movs	r0, #0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   1bbb0:	3501      	adds	r5, #1
   1bbb2:	63a5      	str	r5, [r4, #56]	; 0x38
}
   1bbb4:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
   1bbb6:	6880      	ldr	r0, [r0, #8]
   1bbb8:	f7ff fa2c 	bl	1b014 <xTaskPriorityDisinherit>
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
   1bbbc:	2300      	movs	r3, #0
   1bbbe:	60a3      	str	r3, [r4, #8]
   1bbc0:	e7f6      	b.n	1bbb0 <prvCopyDataToQueue+0x12>
	else if( xPosition == queueSEND_TO_BACK )
   1bbc2:	b96e      	cbnz	r6, 1bbe0 <prvCopyDataToQueue+0x42>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
   1bbc4:	6840      	ldr	r0, [r0, #4]
   1bbc6:	f007 fb91 	bl	232ec <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
   1bbca:	6863      	ldr	r3, [r4, #4]
   1bbcc:	6c22      	ldr	r2, [r4, #64]	; 0x40
   1bbce:	4413      	add	r3, r2
   1bbd0:	6063      	str	r3, [r4, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   1bbd2:	68a2      	ldr	r2, [r4, #8]
   1bbd4:	4293      	cmp	r3, r2
   1bbd6:	d319      	bcc.n	1bc0c <prvCopyDataToQueue+0x6e>
			pxQueue->pcWriteTo = pxQueue->pcHead;
   1bbd8:	6823      	ldr	r3, [r4, #0]
   1bbda:	6063      	str	r3, [r4, #4]
BaseType_t xReturn = pdFALSE;
   1bbdc:	4630      	mov	r0, r6
   1bbde:	e7e7      	b.n	1bbb0 <prvCopyDataToQueue+0x12>
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
   1bbe0:	68c0      	ldr	r0, [r0, #12]
   1bbe2:	f007 fb83 	bl	232ec <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
   1bbe6:	6c22      	ldr	r2, [r4, #64]	; 0x40
   1bbe8:	4252      	negs	r2, r2
   1bbea:	68e3      	ldr	r3, [r4, #12]
   1bbec:	4413      	add	r3, r2
   1bbee:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   1bbf0:	6821      	ldr	r1, [r4, #0]
   1bbf2:	428b      	cmp	r3, r1
   1bbf4:	d202      	bcs.n	1bbfc <prvCopyDataToQueue+0x5e>
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
   1bbf6:	68a3      	ldr	r3, [r4, #8]
   1bbf8:	441a      	add	r2, r3
   1bbfa:	60e2      	str	r2, [r4, #12]
		if( xPosition == queueOVERWRITE )
   1bbfc:	2e02      	cmp	r6, #2
   1bbfe:	d001      	beq.n	1bc04 <prvCopyDataToQueue+0x66>
BaseType_t xReturn = pdFALSE;
   1bc00:	2000      	movs	r0, #0
   1bc02:	e7d5      	b.n	1bbb0 <prvCopyDataToQueue+0x12>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   1bc04:	b125      	cbz	r5, 1bc10 <prvCopyDataToQueue+0x72>
				--uxMessagesWaiting;
   1bc06:	3d01      	subs	r5, #1
BaseType_t xReturn = pdFALSE;
   1bc08:	2000      	movs	r0, #0
   1bc0a:	e7d1      	b.n	1bbb0 <prvCopyDataToQueue+0x12>
   1bc0c:	4630      	mov	r0, r6
   1bc0e:	e7cf      	b.n	1bbb0 <prvCopyDataToQueue+0x12>
   1bc10:	2000      	movs	r0, #0
   1bc12:	e7cd      	b.n	1bbb0 <prvCopyDataToQueue+0x12>

Disassembly of section .text.DRV_GMAC_Process%478:

0001bc14 <DRV_GMAC_Process>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1bc14:	4b19      	ldr	r3, [pc, #100]	; (1bc7c <DRV_GMAC_Process+0x68>)
   1bc16:	4283      	cmp	r3, r0
   1bc18:	d120      	bne.n	1bc5c <DRV_GMAC_Process+0x48>
    if(pMACDrv == 0)
   1bc1a:	b310      	cbz	r0, 1bc62 <DRV_GMAC_Process+0x4e>
{
   1bc1c:	b510      	push	{r4, lr}
	if(pMACDrv->sGmacData._synchF != 0)
   1bc1e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   1bc20:	b323      	cbz	r3, 1bc6c <DRV_GMAC_Process+0x58>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_LOCK);
   1bc22:	4c16      	ldr	r4, [pc, #88]	; (1bc7c <DRV_GMAC_Process+0x68>)
   1bc24:	2103      	movs	r1, #3
   1bc26:	f104 0060 	add.w	r0, r4, #96	; 0x60
   1bc2a:	4798      	blx	r3
        if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].queueTxEnable)
   1bc2c:	f894 30ce 	ldrb.w	r3, [r4, #206]	; 0xce
   1bc30:	b93b      	cbnz	r3, 1bc42 <DRV_GMAC_Process+0x2e>
	if(pMACDrv->sGmacData._synchF != 0)
   1bc32:	4b12      	ldr	r3, [pc, #72]	; (1bc7c <DRV_GMAC_Process+0x68>)
   1bc34:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   1bc36:	b1bb      	cbz	r3, 1bc68 <DRV_GMAC_Process+0x54>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_UNLOCK);
   1bc38:	2104      	movs	r1, #4
   1bc3a:	4811      	ldr	r0, [pc, #68]	; (1bc80 <DRV_GMAC_Process+0x6c>)
   1bc3c:	4798      	blx	r3
	return TCPIP_MAC_RES_OK;
   1bc3e:	2000      	movs	r0, #0
}
   1bc40:	bd10      	pop	{r4, pc}
    GMAC_REGS->GMAC_TSR = GMAC_TSR_TXCOMP_Msk;
   1bc42:	4b10      	ldr	r3, [pc, #64]	; (1bc84 <DRV_GMAC_Process+0x70>)
   1bc44:	2220      	movs	r2, #32
   1bc46:	615a      	str	r2, [r3, #20]
    DRV_PIC32CGMAC_LibTxAckPacket(pMACDrv,queueIdx);
   1bc48:	4c0c      	ldr	r4, [pc, #48]	; (1bc7c <DRV_GMAC_Process+0x68>)
   1bc4a:	2100      	movs	r1, #0
   1bc4c:	4620      	mov	r0, r4
   1bc4e:	f7f6 fddd 	bl	1280c <DRV_PIC32CGMAC_LibTxAckPacket>
            _MacTxPendingPackets(pMACDrv,queueIdx);            
   1bc52:	2100      	movs	r1, #0
   1bc54:	4620      	mov	r0, r4
   1bc56:	f000 f973 	bl	1bf40 <_MacTxPendingPackets>
   1bc5a:	e7ea      	b.n	1bc32 <DRV_GMAC_Process+0x1e>
        return TCPIP_MAC_RES_OP_ERR;
   1bc5c:	f06f 0005 	mvn.w	r0, #5
   1bc60:	4770      	bx	lr
   1bc62:	f06f 0005 	mvn.w	r0, #5
}
   1bc66:	4770      	bx	lr
	return TCPIP_MAC_RES_OK;
   1bc68:	2000      	movs	r0, #0
   1bc6a:	e7e9      	b.n	1bc40 <DRV_GMAC_Process+0x2c>
        if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].queueTxEnable)
   1bc6c:	4b03      	ldr	r3, [pc, #12]	; (1bc7c <DRV_GMAC_Process+0x68>)
   1bc6e:	f893 30ce 	ldrb.w	r3, [r3, #206]	; 0xce
   1bc72:	2b00      	cmp	r3, #0
   1bc74:	d1e5      	bne.n	1bc42 <DRV_GMAC_Process+0x2e>
	return TCPIP_MAC_RES_OK;
   1bc76:	2000      	movs	r0, #0
   1bc78:	e7e2      	b.n	1bc40 <DRV_GMAC_Process+0x2c>
   1bc7a:	bf00      	nop
   1bc7c:	2000e288 	.word	0x2000e288
   1bc80:	2000e2e8 	.word	0x2000e2e8
   1bc84:	42000800 	.word	0x42000800

Disassembly of section .text._ARPUpdateEntry%479:

0001bc88 <_ARPUpdateEntry>:
{
   1bc88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1bc8c:	4606      	mov	r6, r0
   1bc8e:	460c      	mov	r4, r1
   1bc90:	4617      	mov	r7, r2
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   1bc92:	4b19      	ldr	r3, [pc, #100]	; (1bcf8 <_ARPUpdateEntry+0x70>)
   1bc94:	685d      	ldr	r5, [r3, #4]
   1bc96:	f008 f94f 	bl	23f38 <TCPIP_STACK_NetIxGet>
    if((arpHE->hEntry.flags.value & ARP_FLAG_ENTRY_PERM) == 0)
   1bc9a:	8823      	ldrh	r3, [r4, #0]
   1bc9c:	f013 0f40 	tst.w	r3, #64	; 0x40
   1bca0:	d11d      	bne.n	1bcde <_ARPUpdateEntry+0x56>
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   1bca2:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   1bca6:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
        if((arpHE->hEntry.flags.value & ARP_FLAG_ENTRY_COMPLETE) == 0)
   1bcaa:	f013 0f80 	tst.w	r3, #128	; 0x80
   1bcae:	d10e      	bne.n	1bcce <_ARPUpdateEntry+0x46>
            TCPIP_Helper_ProtectedSingleListNodeRemove(&pArpDcpt->incompleteList, (SGL_LIST_NODE*)&arpHE->next);
   1bcb0:	1d21      	adds	r1, r4, #4
   1bcb2:	f105 002c 	add.w	r0, r5, #44	; 0x2c
   1bcb6:	f005 fb29 	bl	2130c <TCPIP_Helper_ProtectedSingleListNodeRemove>
            evType = ARP_EVENT_SOLVED;
   1bcba:	f04f 0801 	mov.w	r8, #1
        _ARPSetEntry(arpHE, ARP_FLAG_ENTRY_COMPLETE, hwAdd, &pArpDcpt->completeList);
   1bcbe:	f105 0318 	add.w	r3, r5, #24
   1bcc2:	463a      	mov	r2, r7
   1bcc4:	2180      	movs	r1, #128	; 0x80
   1bcc6:	4620      	mov	r0, r4
   1bcc8:	f004 fee2 	bl	20a90 <_ARPSetEntry>
   1bccc:	e009      	b.n	1bce2 <_ARPUpdateEntry+0x5a>
            TCPIP_Helper_ProtectedSingleListNodeRemove(&pArpDcpt->completeList, (SGL_LIST_NODE*)&arpHE->next);
   1bcce:	1d21      	adds	r1, r4, #4
   1bcd0:	f105 0018 	add.w	r0, r5, #24
   1bcd4:	f005 fb1a 	bl	2130c <TCPIP_Helper_ProtectedSingleListNodeRemove>
            evType = ARP_EVENT_UPDATED;
   1bcd8:	f04f 0802 	mov.w	r8, #2
   1bcdc:	e7ef      	b.n	1bcbe <_ARPUpdateEntry+0x36>
        evType = ARP_EVENT_PERM_UPDATE;
   1bcde:	f04f 0803 	mov.w	r8, #3
    _ARPNotifyClients(pIf, &arpHE->ipAddress, &arpHE->hwAdd, evType);
   1bce2:	4643      	mov	r3, r8
   1bce4:	f104 0210 	add.w	r2, r4, #16
   1bce8:	f104 0108 	add.w	r1, r4, #8
   1bcec:	4630      	mov	r0, r6
   1bcee:	f001 ffbf 	bl	1dc70 <_ARPNotifyClients>
}
   1bcf2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1bcf6:	bf00      	nop
   1bcf8:	2000e974 	.word	0x2000e974

Disassembly of section .text.TCPIP_ARP_EntryRemove%480:

0001bcfc <TCPIP_ARP_EntryRemove>:
    if(ipAdd == 0 || ipAdd->Val == 0)
   1bcfc:	b349      	cbz	r1, 1bd52 <TCPIP_ARP_EntryRemove+0x56>
{
   1bcfe:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1bd00:	460d      	mov	r5, r1
    if(ipAdd == 0 || ipAdd->Val == 0)
   1bd02:	680a      	ldr	r2, [r1, #0]
   1bd04:	b342      	cbz	r2, 1bd58 <TCPIP_ARP_EntryRemove+0x5c>
   1bd06:	b350      	cbz	r0, 1bd5e <TCPIP_ARP_EntryRemove+0x62>
   1bd08:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1bd0c:	f012 0f40 	tst.w	r2, #64	; 0x40
   1bd10:	d102      	bne.n	1bd18 <TCPIP_ARP_EntryRemove+0x1c>
        return ARP_RES_NO_INTERFACE;
   1bd12:	f06f 0005 	mvn.w	r0, #5
}
   1bd16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1bd18:	4604      	mov	r4, r0
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   1bd1a:	4b14      	ldr	r3, [pc, #80]	; (1bd6c <TCPIP_ARP_EntryRemove+0x70>)
   1bd1c:	685e      	ldr	r6, [r3, #4]
   1bd1e:	f008 f90b 	bl	23f38 <TCPIP_STACK_NetIxGet>
   1bd22:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   1bd26:	00c0      	lsls	r0, r0, #3
   1bd28:	1837      	adds	r7, r6, r0
    hE = TCPIP_OAHASH_EntryLookup(pArpDcpt->hashDcpt, &ipAdd->Val);
   1bd2a:	4629      	mov	r1, r5
   1bd2c:	5830      	ldr	r0, [r6, r0]
   1bd2e:	f000 fe29 	bl	1c984 <TCPIP_OAHASH_EntryLookup>
    if(hE == 0)
   1bd32:	4605      	mov	r5, r0
   1bd34:	b1b0      	cbz	r0, 1bd64 <TCPIP_ARP_EntryRemove+0x68>
    _ARPRemoveEntry(pArpDcpt, hE);
   1bd36:	4601      	mov	r1, r0
   1bd38:	4638      	mov	r0, r7
   1bd3a:	f005 fe2f 	bl	2199c <_ARPRemoveEntry>
    _ARPNotifyClients(pIf, &((ARP_HASH_ENTRY*)hE)->ipAddress, 0, ARP_EVENT_REMOVED_USER);
   1bd3e:	f06f 0301 	mvn.w	r3, #1
   1bd42:	2200      	movs	r2, #0
   1bd44:	f105 0108 	add.w	r1, r5, #8
   1bd48:	4620      	mov	r0, r4
   1bd4a:	f001 ff91 	bl	1dc70 <_ARPNotifyClients>
    return ARP_RES_OK;
   1bd4e:	2000      	movs	r0, #0
   1bd50:	e7e1      	b.n	1bd16 <TCPIP_ARP_EntryRemove+0x1a>
        return ARP_RES_BAD_ADDRESS;
   1bd52:	f06f 0004 	mvn.w	r0, #4
}
   1bd56:	4770      	bx	lr
        return ARP_RES_BAD_ADDRESS;
   1bd58:	f06f 0004 	mvn.w	r0, #4
   1bd5c:	e7db      	b.n	1bd16 <TCPIP_ARP_EntryRemove+0x1a>
        return ARP_RES_NO_INTERFACE;
   1bd5e:	f06f 0005 	mvn.w	r0, #5
   1bd62:	e7d8      	b.n	1bd16 <TCPIP_ARP_EntryRemove+0x1a>
        return ARP_RES_NO_ENTRY;
   1bd64:	f04f 30ff 	mov.w	r0, #4294967295
   1bd68:	e7d5      	b.n	1bd16 <TCPIP_ARP_EntryRemove+0x1a>
   1bd6a:	bf00      	nop
   1bd6c:	2000e974 	.word	0x2000e974

Disassembly of section .text.TCPIP_DHCP_ConnectionHandler%481:

0001bd70 <TCPIP_DHCP_ConnectionHandler>:
{
   1bd70:	b570      	push	{r4, r5, r6, lr}
   1bd72:	4605      	mov	r5, r0
   1bd74:	460e      	mov	r6, r1
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   1bd76:	4b1a      	ldr	r3, [pc, #104]	; (1bde0 <TCPIP_DHCP_ConnectionHandler+0x70>)
   1bd78:	681c      	ldr	r4, [r3, #0]
   1bd7a:	f008 f8dd 	bl	23f38 <TCPIP_STACK_NetIxGet>
    if (pClient->flags.bDHCPEnabled != 0)
   1bd7e:	235c      	movs	r3, #92	; 0x5c
   1bd80:	fb03 4000 	mla	r0, r3, r0, r4
   1bd84:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   1bd88:	f013 0101 	ands.w	r1, r3, #1
   1bd8c:	d011      	beq.n	1bdb2 <TCPIP_DHCP_ConnectionHandler+0x42>
        if (connEvent & TCPIP_MAC_EV_CONN_LOST)
   1bd8e:	f416 5f80 	tst.w	r6, #4096	; 0x1000
   1bd92:	d10f      	bne.n	1bdb4 <TCPIP_DHCP_ConnectionHandler+0x44>
        else if (connEvent & TCPIP_MAC_EV_CONN_ESTABLISHED)
   1bd94:	f416 6f00 	tst.w	r6, #2048	; 0x800
   1bd98:	d00b      	beq.n	1bdb2 <TCPIP_DHCP_ConnectionHandler+0x42>
            _DHCPEnable(pNetIf, pClient->flags.bWasBound ? TCPIP_DHCP_OPER_INIT_REBOOT : TCPIP_DHCP_OPER_INIT);
   1bd9a:	f003 0310 	and.w	r3, r3, #16
   1bd9e:	2b00      	cmp	r3, #0
   1bda0:	bf18      	it	ne
   1bda2:	2102      	movne	r1, #2
   1bda4:	4628      	mov	r0, r5
   1bda6:	f7fd ff27 	bl	19bf8 <_DHCPEnable>
            _DHCPNotifyClients(pNetIf, DHCP_EVENT_CONN_ESTABLISHED);
   1bdaa:	210c      	movs	r1, #12
   1bdac:	4628      	mov	r0, r5
   1bdae:	f004 f949 	bl	20044 <_DHCPNotifyClients>
}
   1bdb2:	bd70      	pop	{r4, r5, r6, pc}
            _DHCPClientClose(pNetIf, false, false);
   1bdb4:	2200      	movs	r2, #0
   1bdb6:	4611      	mov	r1, r2
   1bdb8:	4628      	mov	r0, r5
   1bdba:	f7fe fb6f 	bl	1a49c <_DHCPClientClose>
            _TCPIPStackSetConfigAddress(pNetIf, 0, 0, true);
   1bdbe:	2301      	movs	r3, #1
   1bdc0:	2200      	movs	r2, #0
   1bdc2:	4611      	mov	r1, r2
   1bdc4:	4628      	mov	r0, r5
   1bdc6:	f004 fdde 	bl	20986 <_TCPIPStackSetConfigAddress>
            TCPIP_STACK_AddressServiceEvent(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_DHCPC, TCPIP_STACK_ADDRESS_SERVICE_EVENT_CONN_LOST);
   1bdca:	2202      	movs	r2, #2
   1bdcc:	2101      	movs	r1, #1
   1bdce:	4628      	mov	r0, r5
   1bdd0:	f003 fb32 	bl	1f438 <TCPIP_STACK_AddressServiceEvent>
            _DHCPNotifyClients(pNetIf, DHCP_EVENT_CONN_LOST);
   1bdd4:	210b      	movs	r1, #11
   1bdd6:	4628      	mov	r0, r5
   1bdd8:	f004 f934 	bl	20044 <_DHCPNotifyClients>
   1bddc:	e7e9      	b.n	1bdb2 <TCPIP_DHCP_ConnectionHandler+0x42>
   1bdde:	bf00      	nop
   1bde0:	2000ee3c 	.word	0x2000ee3c

Disassembly of section .rodata%482:

0001bde4 <.rodata%482>:
   1bde4:	43414d47 	.word	0x43414d47
   1bde8:	00000000 	.word	0x00000000
   1bdec:	5048434d 	.word	0x5048434d
   1bdf0:	52414f42 	.word	0x52414f42
   1bdf4:	00435f44 	.word	0x00435f44
   1bdf8:	303a3030 	.word	0x303a3030
   1bdfc:	35323a34 	.word	0x35323a34
   1be00:	3a43313a 	.word	0x3a43313a
   1be04:	303a3041 	.word	0x303a3041
   1be08:	00000033 	.word	0x00000033
   1be0c:	2e323931 	.word	0x2e323931
   1be10:	2e383631 	.word	0x2e383631
   1be14:	39392e31 	.word	0x39392e31
   1be18:	00000000 	.word	0x00000000
   1be1c:	2e353532 	.word	0x2e353532
   1be20:	2e353532 	.word	0x2e353532
   1be24:	2e353532 	.word	0x2e353532
   1be28:	00000030 	.word	0x00000030
   1be2c:	2e323931 	.word	0x2e323931
   1be30:	2e383631 	.word	0x2e383631
   1be34:	00312e31 	.word	0x00312e31
   1be38:	2e302e30 	.word	0x2e302e30
   1be3c:	00302e30 	.word	0x00302e30
   1be40:	6c6c7566 	.word	0x6c6c7566
   1be44:	00000000 	.word	0x00000000
   1be48:	2e323931 	.word	0x2e323931
   1be4c:	2e383631 	.word	0x2e383631
   1be50:	30312e31 	.word	0x30312e31
   1be54:	0030      	.short	0x0030
   1be56:	bf00      	nop

Disassembly of section .text.xTaskRemoveFromEventList%483:

0001be58 <xTaskRemoveFromEventList>:
{
   1be58:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   1be5a:	68c3      	ldr	r3, [r0, #12]
   1be5c:	68dc      	ldr	r4, [r3, #12]
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   1be5e:	f104 0518 	add.w	r5, r4, #24
   1be62:	4628      	mov	r0, r5
   1be64:	f006 fc5e 	bl	22724 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1be68:	4b12      	ldr	r3, [pc, #72]	; (1beb4 <xTaskRemoveFromEventList+0x5c>)
   1be6a:	681b      	ldr	r3, [r3, #0]
   1be6c:	b9eb      	cbnz	r3, 1beaa <xTaskRemoveFromEventList+0x52>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   1be6e:	1d25      	adds	r5, r4, #4
   1be70:	4628      	mov	r0, r5
   1be72:	f006 fc57 	bl	22724 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
   1be76:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   1be78:	4a0f      	ldr	r2, [pc, #60]	; (1beb8 <xTaskRemoveFromEventList+0x60>)
   1be7a:	6811      	ldr	r1, [r2, #0]
   1be7c:	2301      	movs	r3, #1
   1be7e:	4083      	lsls	r3, r0
   1be80:	430b      	orrs	r3, r1
   1be82:	6013      	str	r3, [r2, #0]
   1be84:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   1be88:	4629      	mov	r1, r5
   1be8a:	4b0c      	ldr	r3, [pc, #48]	; (1bebc <xTaskRemoveFromEventList+0x64>)
   1be8c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1be90:	f007 fdc0 	bl	23a14 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   1be94:	4b0a      	ldr	r3, [pc, #40]	; (1bec0 <xTaskRemoveFromEventList+0x68>)
   1be96:	681b      	ldr	r3, [r3, #0]
   1be98:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   1be9a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1be9c:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
   1be9e:	bf83      	ittte	hi
   1bea0:	2001      	movhi	r0, #1
   1bea2:	4b08      	ldrhi	r3, [pc, #32]	; (1bec4 <xTaskRemoveFromEventList+0x6c>)
   1bea4:	6018      	strhi	r0, [r3, #0]
		xReturn = pdFALSE;
   1bea6:	2000      	movls	r0, #0
}
   1bea8:	bd38      	pop	{r3, r4, r5, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   1beaa:	4629      	mov	r1, r5
   1beac:	4806      	ldr	r0, [pc, #24]	; (1bec8 <xTaskRemoveFromEventList+0x70>)
   1beae:	f007 fdb1 	bl	23a14 <vListInsertEnd>
   1beb2:	e7ef      	b.n	1be94 <xTaskRemoveFromEventList+0x3c>
   1beb4:	2000ef14 	.word	0x2000ef14
   1beb8:	2000ef1c 	.word	0x2000ef1c
   1bebc:	2000e850 	.word	0x2000e850
   1bec0:	2000ef00 	.word	0x2000ef00
   1bec4:	2000ef38 	.word	0x2000ef38
   1bec8:	2000ecc8 	.word	0x2000ecc8

Disassembly of section .text.wc_GenerateSeed%484:

0001becc <wc_GenerateSeed>:
            return 0;
        }
    #else  /* WOLFSSL_PIC32MZ_RNG */
        /* uses the core timer, in nanoseconds to seed srand */
        int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
        {
   1becc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1bece:	460f      	mov	r7, r1
   1bed0:	4616      	mov	r6, r2
            int i;
            srand(PIC32_SEED_COUNT() * 25);
   1bed2:	f008 fa99 	bl	24408 <SYS_TIME_CounterGet>
   1bed6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   1beda:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   1bede:	f003 f85b 	bl	1ef98 <srand>

            for (i = 0; i < sz; i++ ) {
   1bee2:	b35e      	cbz	r6, 1bf3c <wc_GenerateSeed+0x70>
                output[i] = rand() % 256;
   1bee4:	f000 fe1e 	bl	1cb24 <rand>
   1bee8:	4243      	negs	r3, r0
   1beea:	b2c0      	uxtb	r0, r0
   1beec:	b2db      	uxtb	r3, r3
   1beee:	bf58      	it	pl
   1bef0:	4258      	negpl	r0, r3
   1bef2:	7038      	strb	r0, [r7, #0]
                if ( (i % 8) == 7)
   1bef4:	443e      	add	r6, r7
   1bef6:	3e01      	subs	r6, #1
                output[i] = rand() % 256;
   1bef8:	463d      	mov	r5, r7
   1befa:	f1c7 0701 	rsb	r7, r7, #1
   1befe:	e007      	b.n	1bf10 <wc_GenerateSeed+0x44>
                    srand(PIC32_SEED_COUNT() * 25);
   1bf00:	f008 fa82 	bl	24408 <SYS_TIME_CounterGet>
   1bf04:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   1bf08:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   1bf0c:	f003 f844 	bl	1ef98 <srand>
   1bf10:	197c      	adds	r4, r7, r5
            for (i = 0; i < sz; i++ ) {
   1bf12:	42b5      	cmp	r5, r6
   1bf14:	d012      	beq.n	1bf3c <wc_GenerateSeed+0x70>
                output[i] = rand() % 256;
   1bf16:	f000 fe05 	bl	1cb24 <rand>
   1bf1a:	4243      	negs	r3, r0
   1bf1c:	b2c0      	uxtb	r0, r0
   1bf1e:	b2db      	uxtb	r3, r3
   1bf20:	bf58      	it	pl
   1bf22:	4258      	negpl	r0, r3
   1bf24:	f805 0f01 	strb.w	r0, [r5, #1]!
                if ( (i % 8) == 7)
   1bf28:	4263      	negs	r3, r4
   1bf2a:	f004 0407 	and.w	r4, r4, #7
   1bf2e:	f003 0307 	and.w	r3, r3, #7
   1bf32:	bf58      	it	pl
   1bf34:	425c      	negpl	r4, r3
   1bf36:	2c07      	cmp	r4, #7
   1bf38:	d1ea      	bne.n	1bf10 <wc_GenerateSeed+0x44>
   1bf3a:	e7e1      	b.n	1bf00 <wc_GenerateSeed+0x34>
            }
            return 0;
        }
   1bf3c:	2000      	movs	r0, #0
   1bf3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text._MacTxPendingPackets%485:

0001bf40 <_MacTxPendingPackets>:
{
   1bf40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1bf44:	4607      	mov	r7, r0
   1bf46:	4688      	mov	r8, r1
    while((pPkt = (TCPIP_MAC_PACKET*)DRV_PIC32CGMAC_SingleListHeadRemove(&pMACDrv->sGmacData.gmac_queue[queueIdx]._TxQueue)) != 0)
   1bf48:	262c      	movs	r6, #44	; 0x2c
   1bf4a:	fb06 0601 	mla	r6, r6, r1, r0
   1bf4e:	36a4      	adds	r6, #164	; 0xa4
	DRV_PIC32CGMAC_RESULT ethRes = DRV_PIC32CGMAC_RES_NO_PACKET;    
   1bf50:	2401      	movs	r4, #1
    while((pPkt = (TCPIP_MAC_PACKET*)DRV_PIC32CGMAC_SingleListHeadRemove(&pMACDrv->sGmacData.gmac_queue[queueIdx]._TxQueue)) != 0)
   1bf52:	4630      	mov	r0, r6
   1bf54:	f007 f834 	bl	22fc0 <DRV_PIC32CGMAC_SingleListHeadRemove>
   1bf58:	4605      	mov	r5, r0
   1bf5a:	b198      	cbz	r0, 1bf84 <_MacTxPendingPackets+0x44>
		ethRes = DRV_PIC32CGMAC_LibTxSendPacket(pMACDrv,  pPkt->pDSeg, queueIdx);
   1bf5c:	4642      	mov	r2, r8
   1bf5e:	6929      	ldr	r1, [r5, #16]
   1bf60:	4638      	mov	r0, r7
   1bf62:	f7fa fba1 	bl	166a8 <DRV_PIC32CGMAC_LibTxSendPacket>
   1bf66:	4604      	mov	r4, r0
        if(ethRes == DRV_PIC32CGMAC_RES_NO_DESCRIPTORS)
   1bf68:	2803      	cmp	r0, #3
   1bf6a:	d1f2      	bne.n	1bf52 <_MacTxPendingPackets+0x12>
            pMACDrv->sGmacData._txStat.nTxQueueFull++;
   1bf6c:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
   1bf70:	3301      	adds	r3, #1
   1bf72:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
            DRV_PIC32CGMAC_SingleListHeadAdd(&pMACDrv->sGmacData.gmac_queue[queueIdx]._TxQueue, (DRV_PIC32CGMAC_SGL_LIST_NODE*)pPkt); 
   1bf76:	4629      	mov	r1, r5
   1bf78:	4630      	mov	r0, r6
   1bf7a:	f007 fb6b 	bl	23654 <DRV_PIC32CGMAC_SingleListHeadAdd>
		return TCPIP_MAC_RES_PENDING;
   1bf7e:	2001      	movs	r0, #1
}
   1bf80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if((ethRes == DRV_PIC32CGMAC_RES_OK)||(ethRes == DRV_PIC32CGMAC_RES_NO_PACKET))
   1bf84:	b2e3      	uxtb	r3, r4
   1bf86:	2b01      	cmp	r3, #1
   1bf88:	d801      	bhi.n	1bf8e <_MacTxPendingPackets+0x4e>
		return TCPIP_MAC_RES_OK;
   1bf8a:	2000      	movs	r0, #0
   1bf8c:	e7f8      	b.n	1bf80 <_MacTxPendingPackets+0x40>
	else if(ethRes == DRV_PIC32CGMAC_RES_NO_DESCRIPTORS)
   1bf8e:	2c03      	cmp	r4, #3
		return TCPIP_MAC_RES_PENDING;
   1bf90:	bf08      	it	eq
   1bf92:	2001      	moveq	r0, #1
	else if(ethRes == DRV_PIC32CGMAC_RES_NO_DESCRIPTORS)
   1bf94:	d0f4      	beq.n	1bf80 <_MacTxPendingPackets+0x40>
		pMACDrv->sGmacData._txStat.nTxErrorPackets++;
   1bf96:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
   1bf9a:	3301      	adds	r3, #1
   1bf9c:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
		(*pMACDrv->sGmacData.pktAckF)(pPkt, TCPIP_MAC_PKT_ACK_BUFFER_ERR,TCPIP_THIS_MODULE_ID);	
   1bfa0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1bfa2:	f241 0250 	movw	r2, #4176	; 0x1050
   1bfa6:	f06f 0102 	mvn.w	r1, #2
   1bfaa:	4798      	blx	r3
        return TCPIP_MAC_RES_PACKET_ERR; 
   1bfac:	f06f 0009 	mvn.w	r0, #9
   1bfb0:	e7e6      	b.n	1bf80 <_MacTxPendingPackets+0x40>

Disassembly of section .text._TCPIP_StackSyncFunction%486:

0001bfb2 <_TCPIP_StackSyncFunction>:
    TCPIP_PKT_FlightLogTx(ptrPacket, pNetIf->macId);    // MAC doesn't call the log function
    return pNetIf->hIfMac != 0 ? (*pNetIf->pMacObj->TCPIP_MAC_PacketTx)(pNetIf->hIfMac, ptrPacket) : TCPIP_MAC_RES_NOT_READY_ERR;
}

static bool _TCPIP_StackSyncFunction(void* synchHandle, TCPIP_MAC_SYNCH_REQUEST req)
{
   1bfb2:	b510      	push	{r4, lr}
    switch(req)
   1bfb4:	3901      	subs	r1, #1
   1bfb6:	2905      	cmp	r1, #5
   1bfb8:	d832      	bhi.n	1c020 <_TCPIP_StackSyncFunction+0x6e>
   1bfba:	e8df f001 	tbb	[pc, r1]
   1bfbe:	0d03      	.short	0x0d03
   1bfc0:	2b241d14 	.word	0x2b241d14
    {
        case TCPIP_MAC_SYNCH_REQUEST_OBJ_CREATE: 
            return (OSAL_SEM_Create((OSAL_SEM_HANDLE_TYPE*)synchHandle, OSAL_SEM_TYPE_BINARY, 1, 1) == OSAL_RESULT_TRUE) ? true : false;
   1bfc4:	2301      	movs	r3, #1
   1bfc6:	461a      	mov	r2, r3
   1bfc8:	2100      	movs	r1, #0
   1bfca:	f001 fd79 	bl	1dac0 <OSAL_SEM_Create>
   1bfce:	2801      	cmp	r0, #1
   1bfd0:	bf14      	ite	ne
   1bfd2:	2000      	movne	r0, #0
   1bfd4:	2001      	moveq	r0, #1

        default:
            return false;
    }

}
   1bfd6:	bd10      	pop	{r4, pc}
            return (OSAL_SEM_Delete((OSAL_SEM_HANDLE_TYPE*)synchHandle) == OSAL_RESULT_TRUE) ? true : false;
   1bfd8:	f007 fe51 	bl	23c7e <OSAL_SEM_Delete>
   1bfdc:	2801      	cmp	r0, #1
   1bfde:	bf14      	ite	ne
   1bfe0:	2000      	movne	r0, #0
   1bfe2:	2001      	moveq	r0, #1
   1bfe4:	e7f7      	b.n	1bfd6 <_TCPIP_StackSyncFunction+0x24>
            return (OSAL_SEM_Pend((OSAL_SEM_HANDLE_TYPE*)synchHandle, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE) ? true: false;
   1bfe6:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1bfea:	f006 ff83 	bl	22ef4 <OSAL_SEM_Pend>
   1bfee:	2801      	cmp	r0, #1
   1bff0:	bf14      	ite	ne
   1bff2:	2000      	movne	r0, #0
   1bff4:	2001      	moveq	r0, #1
   1bff6:	e7ee      	b.n	1bfd6 <_TCPIP_StackSyncFunction+0x24>
            return (OSAL_SEM_Post((OSAL_SEM_HANDLE_TYPE*)synchHandle) == OSAL_RESULT_TRUE) ? true: false;
   1bff8:	f007 fbc8 	bl	2378c <OSAL_SEM_Post>
   1bffc:	2801      	cmp	r0, #1
   1bffe:	bf14      	ite	ne
   1c000:	2000      	movne	r0, #0
   1c002:	2001      	moveq	r0, #1
   1c004:	e7e7      	b.n	1bfd6 <_TCPIP_StackSyncFunction+0x24>
   1c006:	4604      	mov	r4, r0
            *(OSAL_CRITSECT_DATA_TYPE*)synchHandle =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1c008:	2000      	movs	r0, #0
   1c00a:	f007 fbb3 	bl	23774 <OSAL_CRIT_Enter>
   1c00e:	6020      	str	r0, [r4, #0]
            return true; 
   1c010:	2001      	movs	r0, #1
   1c012:	e7e0      	b.n	1bfd6 <_TCPIP_StackSyncFunction+0x24>
            OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, *(OSAL_CRITSECT_DATA_TYPE*)synchHandle);
   1c014:	6801      	ldr	r1, [r0, #0]
   1c016:	2000      	movs	r0, #0
   1c018:	f007 fce6 	bl	239e8 <OSAL_CRIT_Leave>
            return true; 
   1c01c:	2001      	movs	r0, #1
   1c01e:	e7da      	b.n	1bfd6 <_TCPIP_StackSyncFunction+0x24>
            return false;
   1c020:	2000      	movs	r0, #0
   1c022:	e7d8      	b.n	1bfd6 <_TCPIP_StackSyncFunction+0x24>

Disassembly of section .text.TCPIP_PKT_DataSegmentGet%487:

0001c024 <TCPIP_PKT_DataSegmentGet>:
    if(srchTransport)
   1c024:	b34a      	cbz	r2, 1c07a <TCPIP_PKT_DataSegmentGet+0x56>
        for(pSeg = pPkt->pDSeg; pSeg != 0; pSeg = pSeg->next)
   1c026:	6903      	ldr	r3, [r0, #16]
   1c028:	2b00      	cmp	r3, #0
   1c02a:	d032      	beq.n	1c092 <TCPIP_PKT_DataSegmentGet+0x6e>
            if(pSeg->segLoad <= pPkt->pTransportLayer && pPkt->pTransportLayer <= pSeg->segLoad + pSeg->segSize)
   1c02c:	69c0      	ldr	r0, [r0, #28]
   1c02e:	e015      	b.n	1c05c <TCPIP_PKT_DataSegmentGet+0x38>
                if(pPkt->pTransportLayer <= dataAddress && dataAddress <= pSeg->segLoad + pSeg->segSize)
   1c030:	4288      	cmp	r0, r1
   1c032:	d801      	bhi.n	1c038 <TCPIP_PKT_DataSegmentGet+0x14>
   1c034:	428a      	cmp	r2, r1
   1c036:	d20b      	bcs.n	1c050 <TCPIP_PKT_DataSegmentGet+0x2c>
                pStartSeg = pSeg->next;
   1c038:	681b      	ldr	r3, [r3, #0]
    for(pSeg = pStartSeg; pSeg != 0; pSeg = pSeg->next)
   1c03a:	b913      	cbnz	r3, 1c042 <TCPIP_PKT_DataSegmentGet+0x1e>
   1c03c:	e008      	b.n	1c050 <TCPIP_PKT_DataSegmentGet+0x2c>
   1c03e:	681b      	ldr	r3, [r3, #0]
   1c040:	b133      	cbz	r3, 1c050 <TCPIP_PKT_DataSegmentGet+0x2c>
        if(pSeg->segLoad <= dataAddress && dataAddress <= pSeg->segLoad + pSeg->segSize)
   1c042:	689a      	ldr	r2, [r3, #8]
   1c044:	428a      	cmp	r2, r1
   1c046:	d8fa      	bhi.n	1c03e <TCPIP_PKT_DataSegmentGet+0x1a>
   1c048:	89d8      	ldrh	r0, [r3, #14]
   1c04a:	4402      	add	r2, r0
   1c04c:	4291      	cmp	r1, r2
   1c04e:	d8f6      	bhi.n	1c03e <TCPIP_PKT_DataSegmentGet+0x1a>
}
   1c050:	4618      	mov	r0, r3
   1c052:	f85d 4b04 	ldr.w	r4, [sp], #4
   1c056:	4770      	bx	lr
        for(pSeg = pPkt->pDSeg; pSeg != 0; pSeg = pSeg->next)
   1c058:	681b      	ldr	r3, [r3, #0]
   1c05a:	b1d3      	cbz	r3, 1c092 <TCPIP_PKT_DataSegmentGet+0x6e>
            if(pSeg->segLoad <= pPkt->pTransportLayer && pPkt->pTransportLayer <= pSeg->segLoad + pSeg->segSize)
   1c05c:	689a      	ldr	r2, [r3, #8]
   1c05e:	4282      	cmp	r2, r0
   1c060:	d8fa      	bhi.n	1c058 <TCPIP_PKT_DataSegmentGet+0x34>
{
   1c062:	b410      	push	{r4}
            if(pSeg->segLoad <= pPkt->pTransportLayer && pPkt->pTransportLayer <= pSeg->segLoad + pSeg->segSize)
   1c064:	89dc      	ldrh	r4, [r3, #14]
   1c066:	4422      	add	r2, r4
   1c068:	4290      	cmp	r0, r2
   1c06a:	d9e1      	bls.n	1c030 <TCPIP_PKT_DataSegmentGet+0xc>
        for(pSeg = pPkt->pDSeg; pSeg != 0; pSeg = pSeg->next)
   1c06c:	681b      	ldr	r3, [r3, #0]
   1c06e:	2b00      	cmp	r3, #0
   1c070:	d0ee      	beq.n	1c050 <TCPIP_PKT_DataSegmentGet+0x2c>
            if(pSeg->segLoad <= pPkt->pTransportLayer && pPkt->pTransportLayer <= pSeg->segLoad + pSeg->segSize)
   1c072:	689a      	ldr	r2, [r3, #8]
   1c074:	4282      	cmp	r2, r0
   1c076:	d8f9      	bhi.n	1c06c <TCPIP_PKT_DataSegmentGet+0x48>
   1c078:	e7f4      	b.n	1c064 <TCPIP_PKT_DataSegmentGet+0x40>
        pStartSeg = pPkt->pDSeg;
   1c07a:	6903      	ldr	r3, [r0, #16]
    for(pSeg = pStartSeg; pSeg != 0; pSeg = pSeg->next)
   1c07c:	b913      	cbnz	r3, 1c084 <TCPIP_PKT_DataSegmentGet+0x60>
   1c07e:	e008      	b.n	1c092 <TCPIP_PKT_DataSegmentGet+0x6e>
   1c080:	681b      	ldr	r3, [r3, #0]
   1c082:	b133      	cbz	r3, 1c092 <TCPIP_PKT_DataSegmentGet+0x6e>
        if(pSeg->segLoad <= dataAddress && dataAddress <= pSeg->segLoad + pSeg->segSize)
   1c084:	689a      	ldr	r2, [r3, #8]
   1c086:	428a      	cmp	r2, r1
   1c088:	d8fa      	bhi.n	1c080 <TCPIP_PKT_DataSegmentGet+0x5c>
   1c08a:	89d8      	ldrh	r0, [r3, #14]
   1c08c:	4402      	add	r2, r0
   1c08e:	4291      	cmp	r1, r2
   1c090:	d8f6      	bhi.n	1c080 <TCPIP_PKT_DataSegmentGet+0x5c>
}
   1c092:	4618      	mov	r0, r3
   1c094:	4770      	bx	lr

Disassembly of section .text.Hash_DRBG_Instantiate%488:

0001c096 <Hash_DRBG_Instantiate>:
{
   1c096:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1c09a:	b084      	sub	sp, #16
   1c09c:	4604      	mov	r4, r0
   1c09e:	460e      	mov	r6, r1
   1c0a0:	4617      	mov	r7, r2
   1c0a2:	4698      	mov	r8, r3
    XMEMSET(drbg, 0, sizeof(DRBG_internal));
   1c0a4:	2284      	movs	r2, #132	; 0x84
   1c0a6:	2100      	movs	r1, #0
   1c0a8:	f007 fefa 	bl	23ea0 <memset>
    drbg->heap = heap;
   1c0ac:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1c0ae:	67a3      	str	r3, [r4, #120]	; 0x78
    drbg->devId = devId;
   1c0b0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1c0b2:	67e3      	str	r3, [r4, #124]	; 0x7c
    if (Hash_df(drbg, drbg->V, sizeof(drbg->V), drbgInitV, seed, seedSz,
   1c0b4:	f104 0508 	add.w	r5, r4, #8
   1c0b8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1c0ba:	9303      	str	r3, [sp, #12]
   1c0bc:	f8cd 8008 	str.w	r8, [sp, #8]
   1c0c0:	9701      	str	r7, [sp, #4]
   1c0c2:	9600      	str	r6, [sp, #0]
   1c0c4:	2304      	movs	r3, #4
   1c0c6:	2237      	movs	r2, #55	; 0x37
   1c0c8:	4629      	mov	r1, r5
   1c0ca:	4620      	mov	r0, r4
   1c0cc:	f7f7 f9a8 	bl	13420 <Hash_df>
   1c0d0:	b120      	cbz	r0, 1c0dc <Hash_DRBG_Instantiate+0x46>
    int ret = DRBG_FAILURE;
   1c0d2:	2301      	movs	r3, #1
}
   1c0d4:	4618      	mov	r0, r3
   1c0d6:	b004      	add	sp, #16
   1c0d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        Hash_df(drbg, drbg->C, sizeof(drbg->C), drbgInitC, drbg->V,
   1c0dc:	2300      	movs	r3, #0
   1c0de:	9303      	str	r3, [sp, #12]
   1c0e0:	9302      	str	r3, [sp, #8]
   1c0e2:	2237      	movs	r2, #55	; 0x37
   1c0e4:	9201      	str	r2, [sp, #4]
   1c0e6:	9500      	str	r5, [sp, #0]
   1c0e8:	f104 013f 	add.w	r1, r4, #63	; 0x3f
   1c0ec:	4620      	mov	r0, r4
   1c0ee:	f7f7 f997 	bl	13420 <Hash_df>
                                              nonce, nonceSz) == DRBG_SUCCESS &&
   1c0f2:	4603      	mov	r3, r0
   1c0f4:	b930      	cbnz	r0, 1c104 <Hash_DRBG_Instantiate+0x6e>
        drbg->reseedCtr = 1;
   1c0f6:	2201      	movs	r2, #1
   1c0f8:	6022      	str	r2, [r4, #0]
        drbg->lastBlock = 0;
   1c0fa:	2200      	movs	r2, #0
   1c0fc:	6062      	str	r2, [r4, #4]
        drbg->matchCount = 0;
   1c0fe:	f884 2080 	strb.w	r2, [r4, #128]	; 0x80
        ret = DRBG_SUCCESS;
   1c102:	e7e7      	b.n	1c0d4 <Hash_DRBG_Instantiate+0x3e>
    int ret = DRBG_FAILURE;
   1c104:	2301      	movs	r3, #1
    return ret;
   1c106:	e7e5      	b.n	1c0d4 <Hash_DRBG_Instantiate+0x3e>

Disassembly of section .text.DRV_GMAC_EventAcknowledge%489:

0001c108 <DRV_GMAC_EventAcknowledge>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1c108:	4b1a      	ldr	r3, [pc, #104]	; (1c174 <DRV_GMAC_EventAcknowledge+0x6c>)
   1c10a:	4283      	cmp	r3, r0
   1c10c:	d12d      	bne.n	1c16a <DRV_GMAC_EventAcknowledge+0x62>
    if(pMACDrv == 0)
   1c10e:	b370      	cbz	r0, 1c16e <DRV_GMAC_EventAcknowledge+0x66>
	if(pDcpt->_TcpEnabledEvents != 0)
   1c110:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
   1c114:	b90b      	cbnz	r3, 1c11a <DRV_GMAC_EventAcknowledge+0x12>
	return false;
   1c116:	2000      	movs	r0, #0
}
   1c118:	4770      	bx	lr
{
   1c11a:	b570      	push	{r4, r5, r6, lr}
   1c11c:	b082      	sub	sp, #8
   1c11e:	460c      	mov	r4, r1
		ethAckEv=_XtlEventsTcp2Eth(tcpAckEv);
   1c120:	4608      	mov	r0, r1
   1c122:	f005 fa73 	bl	2160c <_XtlEventsTcp2Eth>
   1c126:	4606      	mov	r6, r0
        DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, intStat);
   1c128:	4d12      	ldr	r5, [pc, #72]	; (1c174 <DRV_GMAC_EventAcknowledge+0x6c>)
   1c12a:	aa01      	add	r2, sp, #4
   1c12c:	213f      	movs	r1, #63	; 0x3f
   1c12e:	4628      	mov	r0, r5
   1c130:	f006 f9f6 	bl	22520 <DRV_PIC32CGMAC_LibSysInt_Disable>
		pDcpt->_TcpPendingEvents &= ~tcpAckEv;         // no longer pending
   1c134:	f8b5 104e 	ldrh.w	r1, [r5, #78]	; 0x4e
   1c138:	ea21 0104 	bic.w	r1, r1, r4
   1c13c:	f8a5 104e 	strh.w	r1, [r5, #78]	; 0x4e
		pDcpt->_EthPendingEvents &= ~ethAckEv;         // no longer pending
   1c140:	f8b5 3052 	ldrh.w	r3, [r5, #82]	; 0x52
   1c144:	ea23 0306 	bic.w	r3, r3, r6
   1c148:	f8a5 3052 	strh.w	r3, [r5, #82]	; 0x52
            DRV_PIC32CGMAC_LibReadInterruptStatus(queIdx);
   1c14c:	2000      	movs	r0, #0
   1c14e:	f008 f831 	bl	241b4 <DRV_PIC32CGMAC_LibReadInterruptStatus>
            DRV_PIC32CGMAC_LibEnableInterrupt(queIdx, ethAckEv);
   1c152:	4631      	mov	r1, r6
   1c154:	2000      	movs	r0, #0
   1c156:	f008 f833 	bl	241c0 <DRV_PIC32CGMAC_LibEnableInterrupt>
        DRV_PIC32CGMAC_LibSysInt_Restore(pMACDrv, GMAC_ALL_QUE_MASK, intStat);
   1c15a:	aa01      	add	r2, sp, #4
   1c15c:	213f      	movs	r1, #63	; 0x3f
   1c15e:	4628      	mov	r0, r5
   1c160:	f007 fa84 	bl	2366c <DRV_PIC32CGMAC_LibSysInt_Restore>
		return true;
   1c164:	2001      	movs	r0, #1
}
   1c166:	b002      	add	sp, #8
   1c168:	bd70      	pop	{r4, r5, r6, pc}
        return false;
   1c16a:	2000      	movs	r0, #0
   1c16c:	4770      	bx	lr
   1c16e:	2000      	movs	r0, #0
   1c170:	4770      	bx	lr
   1c172:	bf00      	nop
   1c174:	2000e288 	.word	0x2000e288

Disassembly of section .text.DRV_GMAC_Tasks_ISR%490:

0001c178 <DRV_GMAC_Tasks_ISR>:
{
   1c178:	b538      	push	{r3, r4, r5, lr}
	currGroupEvents = ((GMAC_EVENTS)currEthEvents) & pDcpt->_EthEnabledEvents;
   1c17a:	ebc0 1240 	rsb	r2, r0, r0, lsl #5
   1c17e:	4b19      	ldr	r3, [pc, #100]	; (1c1e4 <DRV_GMAC_Tasks_ISR+0x6c>)
   1c180:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   1c184:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
	if(currGroupEvents)
   1c188:	4019      	ands	r1, r3
   1c18a:	d02a      	beq.n	1c1e2 <DRV_GMAC_Tasks_ISR+0x6a>
		pDcpt->_EthPendingEvents |= currGroupEvents;                    
   1c18c:	4b15      	ldr	r3, [pc, #84]	; (1c1e4 <DRV_GMAC_Tasks_ISR+0x6c>)
   1c18e:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
   1c192:	f8b2 3052 	ldrh.w	r3, [r2, #82]	; 0x52
   1c196:	430b      	orrs	r3, r1
   1c198:	f8a2 3052 	strh.w	r3, [r2, #82]	; 0x52
	tcpEv |= (eEvents&(GMAC_EV_RXCOMPLETE))? TCPIP_MAC_EV_RX_DONE:0;
   1c19c:	00cb      	lsls	r3, r1, #3
   1c19e:	f003 0310 	and.w	r3, r3, #16
	tcpEv |= (eEvents&(GMAC_EV_RXOVERRUN))? TCPIP_MAC_EV_RX_OVFLOW:0;
   1c1a2:	124c      	asrs	r4, r1, #9
   1c1a4:	f004 0402 	and.w	r4, r4, #2
	tcpEv |= (eEvents&(GMAC_EV_RXUSEDBITREAD))? TCPIP_MAC_EV_RX_BUFNA:0; // mapping RX Used bit interrupt to BUFNA;
   1c1a8:	4323      	orrs	r3, r4
   1c1aa:	f001 0404 	and.w	r4, r1, #4
   1c1ae:	4323      	orrs	r3, r4
	tcpEv |= (eEvents&(GMAC_EV_TXFRAMECORRUPT))? TCPIP_MAC_EV_TX_BUSERR:0;
   1c1b0:	010c      	lsls	r4, r1, #4
   1c1b2:	f404 6480 	and.w	r4, r4, #1024	; 0x400
	tcpEv |= (eEvents&(GMAC_EV_RXUSEDBITREAD))? TCPIP_MAC_EV_RX_BUFNA:0; // mapping RX Used bit interrupt to BUFNA;
   1c1b6:	4323      	orrs	r3, r4
    tcpEv = (eEvents&(GMAC_EV_TXCOMPLETE))? TCPIP_MAC_EV_TX_DONE:0;
   1c1b8:	0049      	lsls	r1, r1, #1
   1c1ba:	f401 7180 	and.w	r1, r1, #256	; 0x100
	tcpEv |= (eEvents&(GMAC_EV_RXUSEDBITREAD))? TCPIP_MAC_EV_RX_BUFNA:0; // mapping RX Used bit interrupt to BUFNA;
   1c1be:	430b      	orrs	r3, r1
		pDcpt->_TcpPendingEvents |= _XtlEventsEth2Tcp(currGroupEvents);
   1c1c0:	f8b2 104e 	ldrh.w	r1, [r2, #78]	; 0x4e
   1c1c4:	430b      	orrs	r3, r1
   1c1c6:	f8a2 304e 	strh.w	r3, [r2, #78]	; 0x4e
		if(pDcpt->_TcpNotifyFnc)
   1c1ca:	6d54      	ldr	r4, [r2, #84]	; 0x54
   1c1cc:	b14c      	cbz	r4, 1c1e2 <DRV_GMAC_Tasks_ISR+0x6a>
			(*pDcpt->_TcpNotifyFnc)(pDcpt->_TcpPendingEvents, pDcpt->_TcpNotifyParam);     
   1c1ce:	4b05      	ldr	r3, [pc, #20]	; (1c1e4 <DRV_GMAC_Tasks_ISR+0x6c>)
   1c1d0:	0142      	lsls	r2, r0, #5
   1c1d2:	1a11      	subs	r1, r2, r0
   1c1d4:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
   1c1d8:	f8b1 504e 	ldrh.w	r5, [r1, #78]	; 0x4e
   1c1dc:	6d89      	ldr	r1, [r1, #88]	; 0x58
   1c1de:	4628      	mov	r0, r5
   1c1e0:	47a0      	blx	r4
}
   1c1e2:	bd38      	pop	{r3, r4, r5, pc}
   1c1e4:	2000e288 	.word	0x2000e288

Disassembly of section .text.TCPIP_IPV4_Cleanup%491:

0001c1e8 <TCPIP_IPV4_Cleanup>:
{
   1c1e8:	b508      	push	{r3, lr}
    if(ipv4ArpHandle)
   1c1ea:	4b14      	ldr	r3, [pc, #80]	; (1c23c <TCPIP_IPV4_Cleanup+0x54>)
   1c1ec:	6818      	ldr	r0, [r3, #0]
   1c1ee:	b120      	cbz	r0, 1c1fa <TCPIP_IPV4_Cleanup+0x12>
        TCPIP_ARP_HandlerDeRegister(ipv4ArpHandle);
   1c1f0:	f006 f9de 	bl	225b0 <TCPIP_ARP_HandlerDeRegister>
        ipv4ArpHandle = 0;
   1c1f4:	4b11      	ldr	r3, [pc, #68]	; (1c23c <TCPIP_IPV4_Cleanup+0x54>)
   1c1f6:	2200      	movs	r2, #0
   1c1f8:	601a      	str	r2, [r3, #0]
    TCPIP_Notification_Deinitialize(&ipv4PacketFilters, ipv4MemH);
   1c1fa:	4b11      	ldr	r3, [pc, #68]	; (1c240 <TCPIP_IPV4_Cleanup+0x58>)
   1c1fc:	6819      	ldr	r1, [r3, #0]
   1c1fe:	4811      	ldr	r0, [pc, #68]	; (1c244 <TCPIP_IPV4_Cleanup+0x5c>)
   1c200:	f007 fdc6 	bl	23d90 <TCPIP_Notification_Deinitialize>
    ipv4ActFilterCount = 0;
   1c204:	4b10      	ldr	r3, [pc, #64]	; (1c248 <TCPIP_IPV4_Cleanup+0x60>)
   1c206:	2200      	movs	r2, #0
   1c208:	601a      	str	r2, [r3, #0]
    TCPIP_Helper_ProtectedSingleListDeinitialize(&ipv4ArpQueue);
   1c20a:	4810      	ldr	r0, [pc, #64]	; (1c24c <TCPIP_IPV4_Cleanup+0x64>)
   1c20c:	f005 f866 	bl	212dc <TCPIP_Helper_ProtectedSingleListDeinitialize>
    if(signalHandle)
   1c210:	4b0f      	ldr	r3, [pc, #60]	; (1c250 <TCPIP_IPV4_Cleanup+0x68>)
   1c212:	6818      	ldr	r0, [r3, #0]
   1c214:	b120      	cbz	r0, 1c220 <TCPIP_IPV4_Cleanup+0x38>
        _TCPIPStackSignalHandlerDeregister(signalHandle);
   1c216:	f007 fe96 	bl	23f46 <_TCPIPStackSignalHandlerDeregister>
        signalHandle = 0;
   1c21a:	4b0d      	ldr	r3, [pc, #52]	; (1c250 <TCPIP_IPV4_Cleanup+0x68>)
   1c21c:	2200      	movs	r2, #0
   1c21e:	601a      	str	r2, [r3, #0]
    if(ipv4ArpEntries != 0)
   1c220:	4b0c      	ldr	r3, [pc, #48]	; (1c254 <TCPIP_IPV4_Cleanup+0x6c>)
   1c222:	6819      	ldr	r1, [r3, #0]
   1c224:	b131      	cbz	r1, 1c234 <TCPIP_IPV4_Cleanup+0x4c>
        TCPIP_HEAP_Free(ipv4MemH, ipv4ArpEntries);
   1c226:	4b06      	ldr	r3, [pc, #24]	; (1c240 <TCPIP_IPV4_Cleanup+0x58>)
   1c228:	6818      	ldr	r0, [r3, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   1c22a:	68c3      	ldr	r3, [r0, #12]
   1c22c:	4798      	blx	r3
        ipv4ArpEntries = 0;
   1c22e:	4b09      	ldr	r3, [pc, #36]	; (1c254 <TCPIP_IPV4_Cleanup+0x6c>)
   1c230:	2200      	movs	r2, #0
   1c232:	601a      	str	r2, [r3, #0]
    ipv4MemH = 0;
   1c234:	4b02      	ldr	r3, [pc, #8]	; (1c240 <TCPIP_IPV4_Cleanup+0x58>)
   1c236:	2200      	movs	r2, #0
   1c238:	601a      	str	r2, [r3, #0]
}
   1c23a:	bd08      	pop	{r3, pc}
   1c23c:	2000ee30 	.word	0x2000ee30
   1c240:	2000ee34 	.word	0x2000ee34
   1c244:	2000ec50 	.word	0x2000ec50
   1c248:	2000ee28 	.word	0x2000ee28
   1c24c:	2000ec3c 	.word	0x2000ec3c
   1c250:	2000ee38 	.word	0x2000ee38
   1c254:	2000ee2c 	.word	0x2000ee2c

Disassembly of section .text.TCPIP_Helper_CalcIPChecksum%492:

0001c258 <TCPIP_Helper_CalcIPChecksum>:
    if(buffer == 0)
   1c258:	b3a0      	cbz	r0, 1c2c4 <TCPIP_Helper_CalcIPChecksum+0x6c>
{
   1c25a:	b430      	push	{r4, r5}
   1c25c:	4603      	mov	r3, r0
	sum.dw = (uint32_t)seed;
   1c25e:	4610      	mov	r0, r2
    if ((unsigned int)buffer % 2)
   1c260:	f013 0501 	ands.w	r5, r3, #1
   1c264:	d007      	beq.n	1c276 <TCPIP_Helper_CalcIPChecksum+0x1e>
        sum.w[0] += (*(uint8_t *)buffer) << 8;
   1c266:	f813 4b01 	ldrb.w	r4, [r3], #1
   1c26a:	eb02 2204 	add.w	r2, r2, r4, lsl #8
   1c26e:	f362 000f 	bfi	r0, r2, #0, #16
        count--;
   1c272:	3901      	subs	r1, #1
   1c274:	b289      	uxth	r1, r1
	i = count >> 1;
   1c276:	084a      	lsrs	r2, r1, #1
	while(i--)
   1c278:	1e54      	subs	r4, r2, #1
   1c27a:	b2a4      	uxth	r4, r4
   1c27c:	b1ca      	cbz	r2, 1c2b2 <TCPIP_Helper_CalcIPChecksum+0x5a>
   1c27e:	3401      	adds	r4, #1
   1c280:	eb03 0444 	add.w	r4, r3, r4, lsl #1
		sum.dw += (uint32_t)*val++;
   1c284:	f833 2b02 	ldrh.w	r2, [r3], #2
   1c288:	4410      	add	r0, r2
	while(i--)
   1c28a:	42a3      	cmp	r3, r4
   1c28c:	d1fa      	bne.n	1c284 <TCPIP_Helper_CalcIPChecksum+0x2c>
	if(count & 0x1)
   1c28e:	f011 0f01 	tst.w	r1, #1
		sum.dw += (uint32_t)*(uint8_t*)val;
   1c292:	bf1c      	itt	ne
   1c294:	7823      	ldrbne	r3, [r4, #0]
   1c296:	18c0      	addne	r0, r0, r3
	sum.dw = (uint32_t)sum.w[0] + (uint32_t)sum.w[1];
   1c298:	0c03      	lsrs	r3, r0, #16
   1c29a:	fa13 f080 	uxtah	r0, r3, r0
	sum.w[0] += sum.w[1];
   1c29e:	eb00 4310 	add.w	r3, r0, r0, lsr #16
   1c2a2:	b29b      	uxth	r3, r3
    if ((unsigned int)buffer % 2)
   1c2a4:	b93d      	cbnz	r5, 1c2b6 <TCPIP_Helper_CalcIPChecksum+0x5e>
	sum.w[0] += sum.w[1];
   1c2a6:	f363 000f 	bfi	r0, r3, #0, #16
	return ~sum.w[0];
   1c2aa:	43c0      	mvns	r0, r0
   1c2ac:	b280      	uxth	r0, r0
}
   1c2ae:	bc30      	pop	{r4, r5}
   1c2b0:	4770      	bx	lr
	while(i--)
   1c2b2:	461c      	mov	r4, r3
   1c2b4:	e7eb      	b.n	1c28e <TCPIP_Helper_CalcIPChecksum+0x36>
        sum.w[0] = ((uint16_t)sum.b[0] << 8 ) | (uint16_t)sum.b[1];
   1c2b6:	b2da      	uxtb	r2, r3
   1c2b8:	0a1b      	lsrs	r3, r3, #8
   1c2ba:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1c2be:	f363 000f 	bfi	r0, r3, #0, #16
   1c2c2:	e7f2      	b.n	1c2aa <TCPIP_Helper_CalcIPChecksum+0x52>
        return 0;
   1c2c4:	2000      	movs	r0, #0
}
   1c2c6:	4770      	bx	lr

Disassembly of section .text.xQueueGenericReset%493:

0001c2c8 <xQueueGenericReset>:
{
   1c2c8:	b538      	push	{r3, r4, r5, lr}
   1c2ca:	4604      	mov	r4, r0
   1c2cc:	460d      	mov	r5, r1
	taskENTER_CRITICAL();
   1c2ce:	f006 fd57 	bl	22d80 <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
   1c2d2:	6822      	ldr	r2, [r4, #0]
   1c2d4:	6c21      	ldr	r1, [r4, #64]	; 0x40
   1c2d6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1c2d8:	fb03 f301 	mul.w	r3, r3, r1
   1c2dc:	18d0      	adds	r0, r2, r3
   1c2de:	60a0      	str	r0, [r4, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
   1c2e0:	2000      	movs	r0, #0
   1c2e2:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
   1c2e4:	6062      	str	r2, [r4, #4]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
   1c2e6:	1a5b      	subs	r3, r3, r1
   1c2e8:	4413      	add	r3, r2
   1c2ea:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
   1c2ec:	23ff      	movs	r3, #255	; 0xff
   1c2ee:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
   1c2f2:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if( xNewQueue == pdFALSE )
   1c2f6:	b9a5      	cbnz	r5, 1c322 <xQueueGenericReset+0x5a>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1c2f8:	6923      	ldr	r3, [r4, #16]
   1c2fa:	b91b      	cbnz	r3, 1c304 <xQueueGenericReset+0x3c>
	taskEXIT_CRITICAL();
   1c2fc:	f007 fc60 	bl	23bc0 <vPortExitCritical>
}
   1c300:	2001      	movs	r0, #1
   1c302:	bd38      	pop	{r3, r4, r5, pc}
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   1c304:	f104 0010 	add.w	r0, r4, #16
   1c308:	f7ff fda6 	bl	1be58 <xTaskRemoveFromEventList>
   1c30c:	2800      	cmp	r0, #0
   1c30e:	d0f5      	beq.n	1c2fc <xQueueGenericReset+0x34>
					queueYIELD_IF_USING_PREEMPTION();
   1c310:	4b08      	ldr	r3, [pc, #32]	; (1c334 <xQueueGenericReset+0x6c>)
   1c312:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1c316:	601a      	str	r2, [r3, #0]
   1c318:	f3bf 8f4f 	dsb	sy
   1c31c:	f3bf 8f6f 	isb	sy
   1c320:	e7ec      	b.n	1c2fc <xQueueGenericReset+0x34>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   1c322:	f104 0010 	add.w	r0, r4, #16
   1c326:	f007 fb6a 	bl	239fe <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   1c32a:	f104 0024 	add.w	r0, r4, #36	; 0x24
   1c32e:	f007 fb66 	bl	239fe <vListInitialise>
   1c332:	e7e3      	b.n	1c2fc <xQueueGenericReset+0x34>
   1c334:	e000ed04 	.word	0xe000ed04

Disassembly of section .text.prvIdleTask%494:

0001c338 <prvIdleTask>:
{
   1c338:	b580      	push	{r7, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   1c33a:	4c16      	ldr	r4, [pc, #88]	; (1c394 <prvIdleTask+0x5c>)
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   1c33c:	4f16      	ldr	r7, [pc, #88]	; (1c398 <prvIdleTask+0x60>)
				--uxCurrentNumberOfTasks;
   1c33e:	4e17      	ldr	r6, [pc, #92]	; (1c39c <prvIdleTask+0x64>)
				taskYIELD();
   1c340:	f8df 8060 	ldr.w	r8, [pc, #96]	; 1c3a4 <prvIdleTask+0x6c>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   1c344:	6823      	ldr	r3, [r4, #0]
   1c346:	b1bb      	cbz	r3, 1c378 <prvIdleTask+0x40>
			taskENTER_CRITICAL();
   1c348:	f006 fd1a 	bl	22d80 <vPortEnterCritical>
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   1c34c:	68fb      	ldr	r3, [r7, #12]
   1c34e:	68dd      	ldr	r5, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   1c350:	1d28      	adds	r0, r5, #4
   1c352:	f006 f9e7 	bl	22724 <uxListRemove>
				--uxCurrentNumberOfTasks;
   1c356:	6833      	ldr	r3, [r6, #0]
   1c358:	3b01      	subs	r3, #1
   1c35a:	6033      	str	r3, [r6, #0]
				--uxDeletedTasksWaitingCleanUp;
   1c35c:	6823      	ldr	r3, [r4, #0]
   1c35e:	3b01      	subs	r3, #1
   1c360:	6023      	str	r3, [r4, #0]
			taskEXIT_CRITICAL();
   1c362:	f007 fc2d 	bl	23bc0 <vPortExitCritical>
			vPortFree( pxTCB->pxStack );
   1c366:	6b28      	ldr	r0, [r5, #48]	; 0x30
   1c368:	f000 fe69 	bl	1d03e <vPortFree>
			vPortFree( pxTCB );
   1c36c:	4628      	mov	r0, r5
   1c36e:	f000 fe66 	bl	1d03e <vPortFree>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   1c372:	6823      	ldr	r3, [r4, #0]
   1c374:	2b00      	cmp	r3, #0
   1c376:	d1e7      	bne.n	1c348 <prvIdleTask+0x10>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   1c378:	4b09      	ldr	r3, [pc, #36]	; (1c3a0 <prvIdleTask+0x68>)
   1c37a:	681b      	ldr	r3, [r3, #0]
   1c37c:	2b01      	cmp	r3, #1
   1c37e:	d9e1      	bls.n	1c344 <prvIdleTask+0xc>
				taskYIELD();
   1c380:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   1c384:	f8c8 3000 	str.w	r3, [r8]
   1c388:	f3bf 8f4f 	dsb	sy
   1c38c:	f3bf 8f6f 	isb	sy
   1c390:	e7d8      	b.n	1c344 <prvIdleTask+0xc>
   1c392:	bf00      	nop
   1c394:	2000ef10 	.word	0x2000ef10
   1c398:	2000ecf0 	.word	0x2000ecf0
   1c39c:	2000ef0c 	.word	0x2000ef0c
   1c3a0:	2000e850 	.word	0x2000e850
   1c3a4:	e000ed04 	.word	0xe000ed04

Disassembly of section .text.DRV_PIC32CGMAC_LibMACOpen%495:

0001c3a8 <DRV_PIC32CGMAC_LibMACOpen>:
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_TXEN_Msk;
   1c3a8:	4b19      	ldr	r3, [pc, #100]	; (1c410 <DRV_PIC32CGMAC_LibMACOpen+0x68>)
   1c3aa:	6818      	ldr	r0, [r3, #0]
   1c3ac:	f020 0008 	bic.w	r0, r0, #8
   1c3b0:	6018      	str	r0, [r3, #0]
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_RXEN_Msk;
   1c3b2:	6818      	ldr	r0, [r3, #0]
   1c3b4:	f020 0004 	bic.w	r0, r0, #4
   1c3b8:	6018      	str	r0, [r3, #0]
	ncfgr = GMAC_REGS->GMAC_NCFGR;
   1c3ba:	685b      	ldr	r3, [r3, #4]
	if(oFlags & TCPIP_ETH_OPEN_FDUPLEX)
   1c3bc:	f011 0f02 	tst.w	r1, #2
		ncfgr |= GMAC_NCFGR_FD_Msk ;
   1c3c0:	bf14      	ite	ne
   1c3c2:	f043 0302 	orrne.w	r3, r3, #2
		ncfgr &= ~GMAC_NCFGR_FD_Msk ;	
   1c3c6:	f023 0302 	biceq.w	r3, r3, #2
	if(oFlags & TCPIP_ETH_OPEN_100)
   1c3ca:	f011 0f08 	tst.w	r1, #8
		ncfgr |= GMAC_NCFGR_SPD_Msk ;
   1c3ce:	bf14      	ite	ne
   1c3d0:	f043 0301 	orrne.w	r3, r3, #1
		ncfgr &= ~GMAC_NCFGR_SPD_Msk ;
   1c3d4:	f023 0301 	biceq.w	r3, r3, #1
	if(pauseType & TCPIP_ETH_PAUSE_TYPE_EN_RX)
   1c3d8:	f012 0f08 	tst.w	r2, #8
		ncfgr |= GMAC_NCFGR_PEN_Msk ;
   1c3dc:	bf14      	ite	ne
   1c3de:	f443 5300 	orrne.w	r3, r3, #8192	; 0x2000
		ncfgr &= ~GMAC_NCFGR_PEN_Msk ;		
   1c3e2:	f423 5300 	biceq.w	r3, r3, #8192	; 0x2000
	GMAC_REGS->GMAC_NCFGR = ncfgr;
   1c3e6:	4a0a      	ldr	r2, [pc, #40]	; (1c410 <DRV_PIC32CGMAC_LibMACOpen+0x68>)
   1c3e8:	6053      	str	r3, [r2, #4]
	if(oFlags & TCPIP_ETH_OPEN_RMII)	
   1c3ea:	f411 6f80 	tst.w	r1, #1024	; 0x400
        GMAC_REGS->GMAC_UR = GMAC_UR_MII(0);
   1c3ee:	bf19      	ittee	ne
   1c3f0:	4613      	movne	r3, r2
   1c3f2:	2200      	movne	r2, #0
        GMAC_REGS->GMAC_UR = GMAC_UR_MII(1);
   1c3f4:	4b06      	ldreq	r3, [pc, #24]	; (1c410 <DRV_PIC32CGMAC_LibMACOpen+0x68>)
   1c3f6:	2201      	moveq	r2, #1
   1c3f8:	60da      	str	r2, [r3, #12]
	GMAC_REGS->GMAC_NCR |= GMAC_NCR_RXEN_Msk;
   1c3fa:	4b05      	ldr	r3, [pc, #20]	; (1c410 <DRV_PIC32CGMAC_LibMACOpen+0x68>)
   1c3fc:	681a      	ldr	r2, [r3, #0]
   1c3fe:	f042 0204 	orr.w	r2, r2, #4
   1c402:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_NCR |= GMAC_NCR_TXEN_Msk;
   1c404:	681a      	ldr	r2, [r3, #0]
   1c406:	f042 0208 	orr.w	r2, r2, #8
   1c40a:	601a      	str	r2, [r3, #0]
}
   1c40c:	4770      	bx	lr
   1c40e:	bf00      	nop
   1c410:	42000800 	.word	0x42000800

Disassembly of section .text._AllocateRxPacket%496:

0001c414 <_AllocateRxPacket>:
{
	TCPIP_MAC_PACKET* pRxPkt;
    DRV_PIC32CGMAC_RESULT gmacAllocRes = DRV_PIC32CGMAC_RES_OK;
	uint8_t rxbuff_idx;
	
	for(rxbuff_idx=0; rxbuff_idx < buffer_count; rxbuff_idx++)
   1c414:	b371      	cbz	r1, 1c474 <_AllocateRxPacket+0x60>
{
   1c416:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1c41a:	4689      	mov	r9, r1
   1c41c:	4698      	mov	r8, r3
   1c41e:	4606      	mov	r6, r0
        if(sticky_flag)
        {
            pRxPkt->pDSeg->segFlags |=  TCPIP_MAC_SEG_FLAG_RX_STICKY;
        }
        
		DRV_PIC32CGMAC_SingleListTailAdd(&pMACDrv->sGmacData.gmac_queue[queue_idx]._RxQueue, (DRV_PIC32CGMAC_SGL_LIST_NODE*)pRxPkt); 
   1c420:	272c      	movs	r7, #44	; 0x2c
   1c422:	fb07 0702 	mla	r7, r7, r2, r0
   1c426:	3794      	adds	r7, #148	; 0x94
	for(rxbuff_idx=0; rxbuff_idx < buffer_count; rxbuff_idx++)
   1c428:	2400      	movs	r4, #0
		pRxPkt = (*pMACDrv->sGmacData.pktAllocF)(sizeof(*pRxPkt), pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].rxBufferSize   - sizeof(TCPIP_MAC_ETHERNET_HEADER), 0);
   1c42a:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
   1c42e:	eb00 0542 	add.w	r5, r0, r2, lsl #1
   1c432:	46a3      	mov	fp, r4
   1c434:	f04f 0a34 	mov.w	sl, #52	; 0x34
   1c438:	e007      	b.n	1c44a <_AllocateRxPacket+0x36>
		DRV_PIC32CGMAC_SingleListTailAdd(&pMACDrv->sGmacData.gmac_queue[queue_idx]._RxQueue, (DRV_PIC32CGMAC_SGL_LIST_NODE*)pRxPkt); 
   1c43a:	4638      	mov	r0, r7
   1c43c:	f006 ff8e 	bl	2335c <DRV_PIC32CGMAC_SingleListTailAdd>
	for(rxbuff_idx=0; rxbuff_idx < buffer_count; rxbuff_idx++)
   1c440:	3401      	adds	r4, #1
   1c442:	b2e4      	uxtb	r4, r4
   1c444:	b2a3      	uxth	r3, r4
   1c446:	454b      	cmp	r3, r9
   1c448:	d212      	bcs.n	1c470 <_AllocateRxPacket+0x5c>
		pRxPkt = (*pMACDrv->sGmacData.pktAllocF)(sizeof(*pRxPkt), pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].rxBufferSize   - sizeof(TCPIP_MAC_ETHERNET_HEADER), 0);
   1c44a:	f8b5 10cc 	ldrh.w	r1, [r5, #204]	; 0xcc
   1c44e:	390e      	subs	r1, #14
   1c450:	6a73      	ldr	r3, [r6, #36]	; 0x24
   1c452:	465a      	mov	r2, fp
   1c454:	b289      	uxth	r1, r1
   1c456:	4650      	mov	r0, sl
   1c458:	4798      	blx	r3
		if(pRxPkt == NULL)
   1c45a:	4601      	mov	r1, r0
   1c45c:	b160      	cbz	r0, 1c478 <_AllocateRxPacket+0x64>
        if(sticky_flag)
   1c45e:	f1b8 0f00 	cmp.w	r8, #0
   1c462:	d0ea      	beq.n	1c43a <_AllocateRxPacket+0x26>
            pRxPkt->pDSeg->segFlags |=  TCPIP_MAC_SEG_FLAG_RX_STICKY;
   1c464:	6902      	ldr	r2, [r0, #16]
   1c466:	8a13      	ldrh	r3, [r2, #16]
   1c468:	f043 0304 	orr.w	r3, r3, #4
   1c46c:	8213      	strh	r3, [r2, #16]
   1c46e:	e7e4      	b.n	1c43a <_AllocateRxPacket+0x26>
    DRV_PIC32CGMAC_RESULT gmacAllocRes = DRV_PIC32CGMAC_RES_OK;
   1c470:	2000      	movs	r0, #0
   1c472:	e003      	b.n	1c47c <_AllocateRxPacket+0x68>
   1c474:	2000      	movs	r0, #0
    }
	return gmacAllocRes;
}	
   1c476:	4770      	bx	lr
			gmacAllocRes = DRV_PIC32CGMAC_RES_OUT_OF_MEMORY;
   1c478:	f04f 30ff 	mov.w	r0, #4294967295
}	
   1c47c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

Disassembly of section .text.TCPIP_ICMP_Initialize%497:

0001c480 <TCPIP_ICMP_Initialize>:
{
   1c480:	b508      	push	{r3, lr}
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_UP)
   1c482:	7f03      	ldrb	r3, [r0, #28]
   1c484:	2b03      	cmp	r3, #3
   1c486:	d021      	beq.n	1c4cc <TCPIP_ICMP_Initialize+0x4c>
    if(icmpInitCount == 0)
   1c488:	4b11      	ldr	r3, [pc, #68]	; (1c4d0 <TCPIP_ICMP_Initialize+0x50>)
   1c48a:	681b      	ldr	r3, [r3, #0]
   1c48c:	b12b      	cbz	r3, 1c49a <TCPIP_ICMP_Initialize+0x1a>
    icmpInitCount++;
   1c48e:	4a10      	ldr	r2, [pc, #64]	; (1c4d0 <TCPIP_ICMP_Initialize+0x50>)
   1c490:	6813      	ldr	r3, [r2, #0]
   1c492:	3301      	adds	r3, #1
   1c494:	6013      	str	r3, [r2, #0]
    return true;
   1c496:	2001      	movs	r0, #1
}
   1c498:	bd08      	pop	{r3, pc}
        icmpMemH = stackCtrl->memH;
   1c49a:	68c2      	ldr	r2, [r0, #12]
   1c49c:	4b0d      	ldr	r3, [pc, #52]	; (1c4d4 <TCPIP_ICMP_Initialize+0x54>)
   1c49e:	601a      	str	r2, [r3, #0]
            iniRes = (signalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_ICMP_Task, TCPIP_ICMP_TASK_TICK_RATE)) != 0;
   1c4a0:	2221      	movs	r2, #33	; 0x21
   1c4a2:	490d      	ldr	r1, [pc, #52]	; (1c4d8 <TCPIP_ICMP_Initialize+0x58>)
   1c4a4:	2006      	movs	r0, #6
   1c4a6:	f002 fc7b 	bl	1eda0 <_TCPIPStackSignalHandlerRegister>
   1c4aa:	4b0c      	ldr	r3, [pc, #48]	; (1c4dc <TCPIP_ICMP_Initialize+0x5c>)
   1c4ac:	6018      	str	r0, [r3, #0]
            if(iniRes == false)
   1c4ae:	b148      	cbz	r0, 1c4c4 <TCPIP_ICMP_Initialize+0x44>
            pIcmpEchoRequest = 0;        // one and only request (for now)
   1c4b0:	2300      	movs	r3, #0
   1c4b2:	4a0b      	ldr	r2, [pc, #44]	; (1c4e0 <TCPIP_ICMP_Initialize+0x60>)
   1c4b4:	6013      	str	r3, [r2, #0]
            icmpEchoTmo = 0;
   1c4b6:	4a0b      	ldr	r2, [pc, #44]	; (1c4e4 <TCPIP_ICMP_Initialize+0x64>)
   1c4b8:	6013      	str	r3, [r2, #0]
            iniRes = TCPIP_Notification_Initialize(&icmpRegisteredUsers);
   1c4ba:	480b      	ldr	r0, [pc, #44]	; (1c4e8 <TCPIP_ICMP_Initialize+0x68>)
   1c4bc:	f007 ff88 	bl	243d0 <TCPIP_Notification_Initialize>
        if(iniRes == false)
   1c4c0:	2800      	cmp	r0, #0
   1c4c2:	d1e4      	bne.n	1c48e <TCPIP_ICMP_Initialize+0xe>
            TCPIP_ICMP_Cleanup();
   1c4c4:	f004 fe4a 	bl	2115c <TCPIP_ICMP_Cleanup>
            return false;
   1c4c8:	2000      	movs	r0, #0
   1c4ca:	e7e5      	b.n	1c498 <TCPIP_ICMP_Initialize+0x18>
        return true;
   1c4cc:	2001      	movs	r0, #1
   1c4ce:	e7e3      	b.n	1c498 <TCPIP_ICMP_Initialize+0x18>
   1c4d0:	2000edb0 	.word	0x2000edb0
   1c4d4:	2000edb4 	.word	0x2000edb4
   1c4d8:	00010575 	.word	0x00010575
   1c4dc:	2000edbc 	.word	0x2000edbc
   1c4e0:	2000edb8 	.word	0x2000edb8
   1c4e4:	2000edac 	.word	0x2000edac
   1c4e8:	2000ec28 	.word	0x2000ec28

Disassembly of section .text._TcpCleanup%498:

0001c4ec <_TcpCleanup>:
{
   1c4ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(TCBStubs)
   1c4ee:	4b16      	ldr	r3, [pc, #88]	; (1c548 <_TcpCleanup+0x5c>)
   1c4f0:	681b      	ldr	r3, [r3, #0]
   1c4f2:	b1ab      	cbz	r3, 1c520 <_TcpCleanup+0x34>
        for(ix = 0; ix < TcpSockets; ix++)
   1c4f4:	4b15      	ldr	r3, [pc, #84]	; (1c54c <_TcpCleanup+0x60>)
   1c4f6:	681b      	ldr	r3, [r3, #0]
   1c4f8:	b193      	cbz	r3, 1c520 <_TcpCleanup+0x34>
   1c4fa:	2400      	movs	r4, #0
            pSkt = TCBStubs[ix]; 
   1c4fc:	4e12      	ldr	r6, [pc, #72]	; (1c548 <_TcpCleanup+0x5c>)
                _TcpAbort(pSkt, _TCP_ABORT_FLAG_SHUTDOWN, 0);
   1c4fe:	4627      	mov	r7, r4
        for(ix = 0; ix < TcpSockets; ix++)
   1c500:	4d12      	ldr	r5, [pc, #72]	; (1c54c <_TcpCleanup+0x60>)
   1c502:	e007      	b.n	1c514 <_TcpCleanup+0x28>
                _TcpAbort(pSkt, _TCP_ABORT_FLAG_SHUTDOWN, 0);
   1c504:	463a      	mov	r2, r7
   1c506:	2102      	movs	r1, #2
   1c508:	f001 fdd4 	bl	1e0b4 <_TcpAbort>
        for(ix = 0; ix < TcpSockets; ix++)
   1c50c:	3401      	adds	r4, #1
   1c50e:	682b      	ldr	r3, [r5, #0]
   1c510:	42a3      	cmp	r3, r4
   1c512:	d905      	bls.n	1c520 <_TcpCleanup+0x34>
            pSkt = TCBStubs[ix]; 
   1c514:	6833      	ldr	r3, [r6, #0]
   1c516:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
            if(pSkt) 
   1c51a:	2800      	cmp	r0, #0
   1c51c:	d1f2      	bne.n	1c504 <_TcpCleanup+0x18>
   1c51e:	e7f5      	b.n	1c50c <_TcpCleanup+0x20>
    TCPIP_HEAP_Free(tcpHeapH, TCBStubs);
   1c520:	4b0b      	ldr	r3, [pc, #44]	; (1c550 <_TcpCleanup+0x64>)
   1c522:	6818      	ldr	r0, [r3, #0]
   1c524:	4c08      	ldr	r4, [pc, #32]	; (1c548 <_TcpCleanup+0x5c>)
   1c526:	68c3      	ldr	r3, [r0, #12]
   1c528:	6821      	ldr	r1, [r4, #0]
   1c52a:	4798      	blx	r3
    TCBStubs = 0;
   1c52c:	2300      	movs	r3, #0
   1c52e:	6023      	str	r3, [r4, #0]
    TcpSockets = 0;
   1c530:	4a06      	ldr	r2, [pc, #24]	; (1c54c <_TcpCleanup+0x60>)
   1c532:	6013      	str	r3, [r2, #0]
    if(tcpSignalHandle)
   1c534:	4b07      	ldr	r3, [pc, #28]	; (1c554 <_TcpCleanup+0x68>)
   1c536:	6818      	ldr	r0, [r3, #0]
   1c538:	b120      	cbz	r0, 1c544 <_TcpCleanup+0x58>
        _TCPIPStackSignalHandlerDeregister(tcpSignalHandle);
   1c53a:	f007 fd04 	bl	23f46 <_TCPIPStackSignalHandlerDeregister>
        tcpSignalHandle = 0;
   1c53e:	4b05      	ldr	r3, [pc, #20]	; (1c554 <_TcpCleanup+0x68>)
   1c540:	2200      	movs	r2, #0
   1c542:	601a      	str	r2, [r3, #0]
}
   1c544:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1c546:	bf00      	nop
   1c548:	2000edc0 	.word	0x2000edc0
   1c54c:	2000edc4 	.word	0x2000edc4
   1c550:	2000edc8 	.word	0x2000edc8
   1c554:	2000edd8 	.word	0x2000edd8

Disassembly of section .text._Command_BIOSNameSet%499:

0001c558 <_Command_BIOSNameSet>:
{
   1c558:	b570      	push	{r4, r5, r6, lr}
   1c55a:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   1c55c:	6845      	ldr	r5, [r0, #4]
    if (argc != 3)
   1c55e:	2903      	cmp	r1, #3
   1c560:	d00e      	beq.n	1c580 <_Command_BIOSNameSet+0x28>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: setbios <interface> <x.x.x.x> \r\n");
   1c562:	4e15      	ldr	r6, [pc, #84]	; (1c5b8 <_Command_BIOSNameSet+0x60>)
   1c564:	6803      	ldr	r3, [r0, #0]
   1c566:	681b      	ldr	r3, [r3, #0]
   1c568:	f606 5168 	addw	r1, r6, #3432	; 0xd68
   1c56c:	4628      	mov	r0, r5
   1c56e:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: setbios PIC32INT MCHPBOARD_29 \r\n");
   1c570:	6823      	ldr	r3, [r4, #0]
   1c572:	681b      	ldr	r3, [r3, #0]
   1c574:	f506 6159 	add.w	r1, r6, #3472	; 0xd90
   1c578:	4628      	mov	r0, r5
   1c57a:	4798      	blx	r3
        return false;
   1c57c:	2000      	movs	r0, #0
}
   1c57e:	bd70      	pop	{r4, r5, r6, pc}
   1c580:	4616      	mov	r6, r2
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
   1c582:	6850      	ldr	r0, [r2, #4]
   1c584:	f003 fa6e 	bl	1fa64 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
   1c588:	b170      	cbz	r0, 1c5a8 <_Command_BIOSNameSet+0x50>
    if(TCPIP_STACK_NetBiosNameSet(netH, argv[2]))
   1c58a:	68b1      	ldr	r1, [r6, #8]
   1c58c:	f004 fd54 	bl	21038 <TCPIP_STACK_NetBiosNameSet>
        msg = "Set BIOS Name failed\r\n";
   1c590:	2800      	cmp	r0, #0
   1c592:	490a      	ldr	r1, [pc, #40]	; (1c5bc <_Command_BIOSNameSet+0x64>)
   1c594:	f101 0314 	add.w	r3, r1, #20
   1c598:	bf08      	it	eq
   1c59a:	4619      	moveq	r1, r3
    (*pCmdIO->pCmdApi->msg)(cmdIoParam, msg);
   1c59c:	6823      	ldr	r3, [r4, #0]
   1c59e:	681b      	ldr	r3, [r3, #0]
   1c5a0:	4628      	mov	r0, r5
   1c5a2:	4798      	blx	r3
    return true;
   1c5a4:	2001      	movs	r0, #1
   1c5a6:	e7ea      	b.n	1c57e <_Command_BIOSNameSet+0x26>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   1c5a8:	6823      	ldr	r3, [r4, #0]
   1c5aa:	681b      	ldr	r3, [r3, #0]
   1c5ac:	4904      	ldr	r1, [pc, #16]	; (1c5c0 <_Command_BIOSNameSet+0x68>)
   1c5ae:	4628      	mov	r0, r5
   1c5b0:	4798      	blx	r3
        return false;
   1c5b2:	2000      	movs	r0, #0
   1c5b4:	e7e3      	b.n	1c57e <_Command_BIOSNameSet+0x26>
   1c5b6:	bf00      	nop
   1c5b8:	0000028c 	.word	0x0000028c
   1c5bc:	00000fc8 	.word	0x00000fc8
   1c5c0:	00000b80 	.word	0x00000b80

Disassembly of section .text.TCPIP_DNS_Disable%500:

0001c5c4 <TCPIP_DNS_Disable>:
    }
    return true;
}

bool TCPIP_DNS_Disable(TCPIP_NET_HANDLE hNet, bool clearCache)
{
   1c5c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    TCPIP_NET_IF* pNetIf = _TCPIPStackHandleToNet(hNet);
    TCPIP_DNS_DCPT *pDnsDcpt;

    pDnsDcpt = pgDnsDcpt;
   1c5c6:	4b19      	ldr	r3, [pc, #100]	; (1c62c <TCPIP_DNS_Disable+0x68>)
   1c5c8:	681c      	ldr	r4, [r3, #0]
    if(pDnsDcpt == 0 || pNetIf == 0)
   1c5ca:	b33c      	cbz	r4, 1c61c <TCPIP_DNS_Disable+0x58>
   1c5cc:	b340      	cbz	r0, 1c620 <TCPIP_DNS_Disable+0x5c>
    {
        return false;
    }

    pNetIf->Flags.bIsDnsClientEnabled = false;
   1c5ce:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   1c5d2:	f36f 03c3 	bfc	r3, #3, #1
   1c5d6:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
    if(pDnsDcpt->strictNet == pNetIf)
   1c5da:	6863      	ldr	r3, [r4, #4]
   1c5dc:	4283      	cmp	r3, r0
    {
        pDnsDcpt->strictNet = 0;
   1c5de:	bf04      	itt	eq
   1c5e0:	2300      	moveq	r3, #0
   1c5e2:	6063      	streq	r3, [r4, #4]
    }
    if(pDnsDcpt->prefNet == pNetIf)
   1c5e4:	68a3      	ldr	r3, [r4, #8]
   1c5e6:	4283      	cmp	r3, r0
    {
        pDnsDcpt->prefNet = 0;
   1c5e8:	bf04      	itt	eq
   1c5ea:	2300      	moveq	r3, #0
   1c5ec:	60a3      	streq	r3, [r4, #8]
    }

    if(clearCache)
   1c5ee:	b909      	cbnz	r1, 1c5f4 <TCPIP_DNS_Disable+0x30>
    {
        _DNS_CleanCache(pDnsDcpt);
    }

    return true;    
   1c5f0:	2001      	movs	r0, #1
}
   1c5f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((pOh = pDnsDcpt->hashDcpt) != 0)
   1c5f4:	6827      	ldr	r7, [r4, #0]
   1c5f6:	b1af      	cbz	r7, 1c624 <TCPIP_DNS_Disable+0x60>
        for(bktIx = 0; bktIx < pOh->hEntries; bktIx++)
   1c5f8:	68fb      	ldr	r3, [r7, #12]
   1c5fa:	b1ab      	cbz	r3, 1c628 <TCPIP_DNS_Disable+0x64>
   1c5fc:	460d      	mov	r5, r1
   1c5fe:	2600      	movs	r6, #0
            pE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryGet(pOh, bktIx);
   1c600:	4631      	mov	r1, r6
   1c602:	4638      	mov	r0, r7
   1c604:	f007 fb29 	bl	23c5a <TCPIP_OAHASH_EntryGet>
            _DNS_CleanCacheEntry(pDnsDcpt, pE);
   1c608:	4601      	mov	r1, r0
   1c60a:	4620      	mov	r0, r4
   1c60c:	f005 f8cd 	bl	217aa <_DNS_CleanCacheEntry>
        for(bktIx = 0; bktIx < pOh->hEntries; bktIx++)
   1c610:	3601      	adds	r6, #1
   1c612:	68fb      	ldr	r3, [r7, #12]
   1c614:	429e      	cmp	r6, r3
   1c616:	d3f3      	bcc.n	1c600 <TCPIP_DNS_Disable+0x3c>
    return true;    
   1c618:	4628      	mov	r0, r5
   1c61a:	e7ea      	b.n	1c5f2 <TCPIP_DNS_Disable+0x2e>
        return false;
   1c61c:	2000      	movs	r0, #0
   1c61e:	e7e8      	b.n	1c5f2 <TCPIP_DNS_Disable+0x2e>
   1c620:	2000      	movs	r0, #0
   1c622:	e7e6      	b.n	1c5f2 <TCPIP_DNS_Disable+0x2e>
    return true;    
   1c624:	4608      	mov	r0, r1
   1c626:	e7e4      	b.n	1c5f2 <TCPIP_DNS_Disable+0x2e>
   1c628:	4608      	mov	r0, r1
   1c62a:	e7e2      	b.n	1c5f2 <TCPIP_DNS_Disable+0x2e>
   1c62c:	2000ee58 	.word	0x2000ee58

Disassembly of section .text.SYS_CMD_ADDGRP%501:

0001c630 <SYS_CMD_ADDGRP>:
{
   1c630:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1c634:	4605      	mov	r5, r0
   1c636:	4688      	mov	r8, r1
   1c638:	4616      	mov	r6, r2
   1c63a:	461f      	mov	r7, r3
    for (i=0; i<MAX_CMD_GROUP; i++)
   1c63c:	4b16      	ldr	r3, [pc, #88]	; (1c698 <SYS_CMD_ADDGRP+0x68>)
    int i, groupIx = -1, emptyIx = -1;
   1c63e:	f04f 39ff 	mov.w	r9, #4294967295
    for (i=0; i<MAX_CMD_GROUP; i++)
   1c642:	2400      	movs	r4, #0
   1c644:	e004      	b.n	1c650 <SYS_CMD_ADDGRP+0x20>
   1c646:	46a1      	mov	r9, r4
   1c648:	3401      	adds	r4, #1
   1c64a:	3310      	adds	r3, #16
   1c64c:	2c08      	cmp	r4, #8
   1c64e:	d01a      	beq.n	1c686 <SYS_CMD_ADDGRP+0x56>
        if(_usrCmdTbl[i].pCmd == 0)
   1c650:	685a      	ldr	r2, [r3, #4]
   1c652:	2a00      	cmp	r2, #0
   1c654:	d0f7      	beq.n	1c646 <SYS_CMD_ADDGRP+0x16>
        else if(_usrCmdTbl[i].pCmd == pCmdTbl)
   1c656:	42aa      	cmp	r2, r5
   1c658:	d1f6      	bne.n	1c648 <SYS_CMD_ADDGRP+0x18>
            if(strcmp(groupName, _usrCmdTbl[i].cmdGroupName) != 0)
   1c65a:	4b0f      	ldr	r3, [pc, #60]	; (1c698 <SYS_CMD_ADDGRP+0x68>)
   1c65c:	eb03 1304 	add.w	r3, r3, r4, lsl #4
   1c660:	6899      	ldr	r1, [r3, #8]
   1c662:	4630      	mov	r0, r6
   1c664:	f007 faca 	bl	23bfc <strcmp>
   1c668:	b990      	cbnz	r0, 1c690 <SYS_CMD_ADDGRP+0x60>
    if (groupIx != -1)
   1c66a:	f1b4 3fff 	cmp.w	r4, #4294967295
   1c66e:	d00a      	beq.n	1c686 <SYS_CMD_ADDGRP+0x56>
    _usrCmdTbl[insertIx].pCmd = pCmdTbl;
   1c670:	4a09      	ldr	r2, [pc, #36]	; (1c698 <SYS_CMD_ADDGRP+0x68>)
   1c672:	0124      	lsls	r4, r4, #4
   1c674:	1913      	adds	r3, r2, r4
   1c676:	605d      	str	r5, [r3, #4]
    _usrCmdTbl[insertIx].nCmds = nCmds;
   1c678:	f842 8004 	str.w	r8, [r2, r4]
    _usrCmdTbl[insertIx].cmdGroupName = groupName;
   1c67c:	609e      	str	r6, [r3, #8]
    _usrCmdTbl[insertIx].cmdMenuStr = menuStr;
   1c67e:	60df      	str	r7, [r3, #12]
    return true;
   1c680:	2001      	movs	r0, #1
}
   1c682:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    else if(emptyIx != -1)
   1c686:	f1b9 3fff 	cmp.w	r9, #4294967295
   1c68a:	d003      	beq.n	1c694 <SYS_CMD_ADDGRP+0x64>
   1c68c:	464c      	mov	r4, r9
   1c68e:	e7ef      	b.n	1c670 <SYS_CMD_ADDGRP+0x40>
                return false;
   1c690:	2000      	movs	r0, #0
   1c692:	e7f6      	b.n	1c682 <SYS_CMD_ADDGRP+0x52>
        return false;
   1c694:	2000      	movs	r0, #0
   1c696:	e7f4      	b.n	1c682 <SYS_CMD_ADDGRP+0x52>
   1c698:	2000e768 	.word	0x2000e768

Disassembly of section .text.SYS_CONSOLE_Print%502:

0001c69c <SYS_CONSOLE_Print>:
        return -1;
    }
}

void SYS_CONSOLE_Print(const SYS_CONSOLE_HANDLE handle, const char *format, ...)
{
   1c69c:	b40e      	push	{r1, r2, r3}
   1c69e:	b510      	push	{r4, lr}
   1c6a0:	b083      	sub	sp, #12
    size_t len = 0;
    va_list args = {0};
   1c6a2:	2300      	movs	r3, #0
   1c6a4:	9301      	str	r3, [sp, #4]
    SYS_CONSOLE_OBJECT_INSTANCE* pConsoleObj = SYS_CONSOLE_GET_INSTANCE(handle);
   1c6a6:	b960      	cbnz	r0, 1c6c2 <SYS_CONSOLE_Print+0x26>
    if (pConsoleObj == NULL)
    {
        return;
    }

    if ((pConsoleObj->status == SYS_STATUS_UNINITIALIZED) || (pConsoleObj->devDesc == NULL))
   1c6a8:	4b14      	ldr	r3, [pc, #80]	; (1c6fc <SYS_CONSOLE_Print+0x60>)
   1c6aa:	f993 3000 	ldrsb.w	r3, [r3]
   1c6ae:	b143      	cbz	r3, 1c6c2 <SYS_CONSOLE_Print+0x26>
   1c6b0:	4b12      	ldr	r3, [pc, #72]	; (1c6fc <SYS_CONSOLE_Print+0x60>)
   1c6b2:	685b      	ldr	r3, [r3, #4]
   1c6b4:	b12b      	cbz	r3, 1c6c2 <SYS_CONSOLE_Print+0x26>
    {
        return;
    }

    /* Must protect the common print buffer from multiple threads */
    if(OSAL_MUTEX_Lock(&consolePrintBufferMutex, OSAL_WAIT_FOREVER) == OSAL_RESULT_FALSE)
   1c6b6:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1c6ba:	4811      	ldr	r0, [pc, #68]	; (1c700 <SYS_CONSOLE_Print+0x64>)
   1c6bc:	f006 fc29 	bl	22f12 <OSAL_MUTEX_Lock>
   1c6c0:	b920      	cbnz	r0, 1c6cc <SYS_CONSOLE_Print+0x30>
        pConsoleObj->devDesc->write(pConsoleObj->devIndex, consolePrintBuffer, len);
    }

    /* Release mutex */
    OSAL_MUTEX_Unlock(&consolePrintBufferMutex);
}
   1c6c2:	b003      	add	sp, #12
   1c6c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1c6c8:	b003      	add	sp, #12
   1c6ca:	4770      	bx	lr
    va_start( args, format );
   1c6cc:	ab06      	add	r3, sp, #24
   1c6ce:	9301      	str	r3, [sp, #4]
    len = vsnprintf(consolePrintBuffer, SYS_CONSOLE_PRINT_BUFFER_SIZE, format, args);
   1c6d0:	9a05      	ldr	r2, [sp, #20]
   1c6d2:	21c8      	movs	r1, #200	; 0xc8
   1c6d4:	480b      	ldr	r0, [pc, #44]	; (1c704 <SYS_CONSOLE_Print+0x68>)
   1c6d6:	f006 fe25 	bl	23324 <vsniprintf>
    if ((len > 0) && (len < SYS_CONSOLE_PRINT_BUFFER_SIZE))
   1c6da:	1e43      	subs	r3, r0, #1
   1c6dc:	2bc6      	cmp	r3, #198	; 0xc6
   1c6de:	d808      	bhi.n	1c6f2 <SYS_CONSOLE_Print+0x56>
        consolePrintBuffer[len] = '\0';
   1c6e0:	4908      	ldr	r1, [pc, #32]	; (1c704 <SYS_CONSOLE_Print+0x68>)
   1c6e2:	2300      	movs	r3, #0
   1c6e4:	540b      	strb	r3, [r1, r0]
        pConsoleObj->devDesc->write(pConsoleObj->devIndex, consolePrintBuffer, len);
   1c6e6:	4b05      	ldr	r3, [pc, #20]	; (1c6fc <SYS_CONSOLE_Print+0x60>)
   1c6e8:	685a      	ldr	r2, [r3, #4]
   1c6ea:	6954      	ldr	r4, [r2, #20]
   1c6ec:	4602      	mov	r2, r0
   1c6ee:	6898      	ldr	r0, [r3, #8]
   1c6f0:	47a0      	blx	r4
    OSAL_MUTEX_Unlock(&consolePrintBufferMutex);
   1c6f2:	4803      	ldr	r0, [pc, #12]	; (1c700 <SYS_CONSOLE_Print+0x64>)
   1c6f4:	f007 f862 	bl	237bc <OSAL_MUTEX_Unlock>
   1c6f8:	e7e3      	b.n	1c6c2 <SYS_CONSOLE_Print+0x26>
   1c6fa:	bf00      	nop
   1c6fc:	2000ed64 	.word	0x2000ed64
   1c700:	2000eed8 	.word	0x2000eed8
   1c704:	2000e458 	.word	0x2000e458

Disassembly of section .text.pvPortMalloc%503:

0001c708 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   1c708:	b538      	push	{r3, r4, r5, lr}
   1c70a:	4604      	mov	r4, r0
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if( portBYTE_ALIGNMENT != 1 )
	{
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
   1c70c:	f010 0f07 	tst.w	r0, #7
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
   1c710:	bf1c      	itt	ne
   1c712:	f020 0407 	bicne.w	r4, r0, #7
   1c716:	3408      	addne	r4, #8
		}
	}
	#endif

	vTaskSuspendAll();
   1c718:	f007 fb92 	bl	23e40 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
   1c71c:	4b12      	ldr	r3, [pc, #72]	; (1c768 <pvPortMalloc+0x60>)
   1c71e:	681b      	ldr	r3, [r3, #0]
   1c720:	b17b      	cbz	r3, 1c742 <pvPortMalloc+0x3a>
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
   1c722:	4b12      	ldr	r3, [pc, #72]	; (1c76c <pvPortMalloc+0x64>)
   1c724:	681b      	ldr	r3, [r3, #0]
   1c726:	441c      	add	r4, r3
   1c728:	f649 72f7 	movw	r2, #40951	; 0x9ff7
   1c72c:	4294      	cmp	r4, r2
   1c72e:	d80e      	bhi.n	1c74e <pvPortMalloc+0x46>
   1c730:	42a3      	cmp	r3, r4
   1c732:	d30f      	bcc.n	1c754 <pvPortMalloc+0x4c>
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
   1c734:	f7fa f8a0 	bl	16878 <xTaskResumeAll>
	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
   1c738:	f007 fac5 	bl	23cc6 <vApplicationMallocFailedHook>
   1c73c:	2500      	movs	r5, #0
		}
	}
	#endif

	return pvReturn;
}
   1c73e:	4628      	mov	r0, r5
   1c740:	bd38      	pop	{r3, r4, r5, pc}
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
   1c742:	4a09      	ldr	r2, [pc, #36]	; (1c768 <pvPortMalloc+0x60>)
   1c744:	4b0a      	ldr	r3, [pc, #40]	; (1c770 <pvPortMalloc+0x68>)
   1c746:	f023 0307 	bic.w	r3, r3, #7
   1c74a:	6013      	str	r3, [r2, #0]
   1c74c:	e7e9      	b.n	1c722 <pvPortMalloc+0x1a>
	( void ) xTaskResumeAll();
   1c74e:	f7fa f893 	bl	16878 <xTaskResumeAll>
		if( pvReturn == NULL )
   1c752:	e7f1      	b.n	1c738 <pvPortMalloc+0x30>
			pvReturn = pucAlignedHeap + xNextFreeByte;
   1c754:	4a04      	ldr	r2, [pc, #16]	; (1c768 <pvPortMalloc+0x60>)
   1c756:	6815      	ldr	r5, [r2, #0]
   1c758:	441d      	add	r5, r3
			xNextFreeByte += xWantedSize;
   1c75a:	4b04      	ldr	r3, [pc, #16]	; (1c76c <pvPortMalloc+0x64>)
   1c75c:	601c      	str	r4, [r3, #0]
	( void ) xTaskResumeAll();
   1c75e:	f7fa f88b 	bl	16878 <xTaskResumeAll>
		if( pvReturn == NULL )
   1c762:	2d00      	cmp	r5, #0
   1c764:	d1eb      	bne.n	1c73e <pvPortMalloc+0x36>
   1c766:	e7e7      	b.n	1c738 <pvPortMalloc+0x30>
   1c768:	2000eef8 	.word	0x2000eef8
   1c76c:	2000eefc 	.word	0x2000eefc
   1c770:	2000000c 	.word	0x2000000c

Disassembly of section .text.snprintf%504:

0001c774 <sniprintf>:
   1c774:	b40c      	push	{r2, r3}
   1c776:	b530      	push	{r4, r5, lr}
   1c778:	4b18      	ldr	r3, [pc, #96]	; (1c7dc <sniprintf+0x68>)
   1c77a:	1e0c      	subs	r4, r1, #0
   1c77c:	b09b      	sub	sp, #108	; 0x6c
   1c77e:	681d      	ldr	r5, [r3, #0]
   1c780:	da08      	bge.n	1c794 <sniprintf+0x20>
   1c782:	238b      	movs	r3, #139	; 0x8b
   1c784:	602b      	str	r3, [r5, #0]
   1c786:	f04f 30ff 	mov.w	r0, #4294967295
   1c78a:	b01b      	add	sp, #108	; 0x6c
   1c78c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   1c790:	b002      	add	sp, #8
   1c792:	4770      	bx	lr
   1c794:	f44f 7302 	mov.w	r3, #520	; 0x208
   1c798:	f8ad 3010 	strh.w	r3, [sp, #16]
   1c79c:	bf14      	ite	ne
   1c79e:	f104 33ff 	addne.w	r3, r4, #4294967295
   1c7a2:	4623      	moveq	r3, r4
   1c7a4:	9303      	str	r3, [sp, #12]
   1c7a6:	9306      	str	r3, [sp, #24]
   1c7a8:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1c7ac:	f8ad 3012 	strh.w	r3, [sp, #18]
   1c7b0:	2300      	movs	r3, #0
   1c7b2:	9001      	str	r0, [sp, #4]
   1c7b4:	9005      	str	r0, [sp, #20]
   1c7b6:	9319      	str	r3, [sp, #100]	; 0x64
   1c7b8:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   1c7ba:	ab1f      	add	r3, sp, #124	; 0x7c
   1c7bc:	a901      	add	r1, sp, #4
   1c7be:	4628      	mov	r0, r5
   1c7c0:	9300      	str	r3, [sp, #0]
   1c7c2:	f7f4 fb81 	bl	10ec8 <_svfiprintf_r>
   1c7c6:	1c43      	adds	r3, r0, #1
   1c7c8:	bfbc      	itt	lt
   1c7ca:	238b      	movlt	r3, #139	; 0x8b
   1c7cc:	602b      	strlt	r3, [r5, #0]
   1c7ce:	2c00      	cmp	r4, #0
   1c7d0:	d0db      	beq.n	1c78a <sniprintf+0x16>
   1c7d2:	9b01      	ldr	r3, [sp, #4]
   1c7d4:	2200      	movs	r2, #0
   1c7d6:	701a      	strb	r2, [r3, #0]
   1c7d8:	e7d7      	b.n	1c78a <sniprintf+0x16>
   1c7da:	bf00      	nop
   1c7dc:	2000ef60 	.word	0x2000ef60

Disassembly of section .text.wc_CryptoCb_Sha256Hash%505:

0001c7e0 <wc_CryptoCb_Sha256Hash>:
#endif /* !NO_SHA */

#ifndef NO_SHA256
int wc_CryptoCb_Sha256Hash(wc_Sha256* sha256, const byte* in,
    word32 inSz, byte* digest)
{
   1c7e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1c7e4:	b0a6      	sub	sp, #152	; 0x98
   1c7e6:	4688      	mov	r8, r1
   1c7e8:	4617      	mov	r7, r2
   1c7ea:	461e      	mov	r6, r3
    int ret = CRYPTOCB_UNAVAILABLE;
    CryptoCb* dev;

    /* locate registered callback */
    if (sha256) {
   1c7ec:	4605      	mov	r5, r0
   1c7ee:	b308      	cbz	r0, 1c834 <wc_CryptoCb_Sha256Hash+0x54>
        dev = wc_CryptoCb_FindDevice(sha256->devId);
   1c7f0:	6f00      	ldr	r0, [r0, #112]	; 0x70
   1c7f2:	f004 fe93 	bl	2151c <wc_CryptoCb_FindDevice>
   1c7f6:	4604      	mov	r4, r0
    else {
        /* locate first callback and try using it */
        dev = wc_CryptoCb_FindDeviceByIndex(0);
    }

    if (dev && dev->cb) {
   1c7f8:	b30c      	cbz	r4, 1c83e <wc_CryptoCb_Sha256Hash+0x5e>
   1c7fa:	6863      	ldr	r3, [r4, #4]
   1c7fc:	b313      	cbz	r3, 1c844 <wc_CryptoCb_Sha256Hash+0x64>
        wc_CryptoInfo cryptoInfo;
        XMEMSET(&cryptoInfo, 0, sizeof(cryptoInfo));
   1c7fe:	2290      	movs	r2, #144	; 0x90
   1c800:	2100      	movs	r1, #0
   1c802:	a802      	add	r0, sp, #8
   1c804:	f007 fb4c 	bl	23ea0 <memset>
        cryptoInfo.algo_type = WC_ALGO_TYPE_HASH;
   1c808:	2301      	movs	r3, #1
   1c80a:	9301      	str	r3, [sp, #4]
        cryptoInfo.hash.type = WC_HASH_TYPE_SHA256;
   1c80c:	2306      	movs	r3, #6
   1c80e:	9316      	str	r3, [sp, #88]	; 0x58
        cryptoInfo.hash.sha256 = sha256;
   1c810:	951a      	str	r5, [sp, #104]	; 0x68
        cryptoInfo.hash.in = in;
   1c812:	f8cd 805c 	str.w	r8, [sp, #92]	; 0x5c
        cryptoInfo.hash.inSz = inSz;
   1c816:	9718      	str	r7, [sp, #96]	; 0x60
        cryptoInfo.hash.digest = digest;
   1c818:	9619      	str	r6, [sp, #100]	; 0x64

        ret = dev->cb(dev->devId, &cryptoInfo, dev->ctx);
   1c81a:	6863      	ldr	r3, [r4, #4]
   1c81c:	68a2      	ldr	r2, [r4, #8]
   1c81e:	a901      	add	r1, sp, #4
   1c820:	6820      	ldr	r0, [r4, #0]
   1c822:	4798      	blx	r3
        ret = CRYPTOCB_UNAVAILABLE;
   1c824:	f110 0fae 	cmn.w	r0, #174	; 0xae
   1c828:	bf08      	it	eq
   1c82a:	f46f 7087 	mvneq.w	r0, #270	; 0x10e
    }

    return wc_CryptoCb_TranslateErrorCode(ret);
}
   1c82e:	b026      	add	sp, #152	; 0x98
   1c830:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        dev = wc_CryptoCb_FindDeviceByIndex(0);
   1c834:	2000      	movs	r0, #0
   1c836:	f002 fb67 	bl	1ef08 <wc_CryptoCb_FindDeviceByIndex>
   1c83a:	4604      	mov	r4, r0
   1c83c:	e7dc      	b.n	1c7f8 <wc_CryptoCb_Sha256Hash+0x18>
    int ret = CRYPTOCB_UNAVAILABLE;
   1c83e:	f46f 7087 	mvn.w	r0, #270	; 0x10e
   1c842:	e7f4      	b.n	1c82e <wc_CryptoCb_Sha256Hash+0x4e>
   1c844:	f46f 7087 	mvn.w	r0, #270	; 0x10e
    return wc_CryptoCb_TranslateErrorCode(ret);
   1c848:	e7f1      	b.n	1c82e <wc_CryptoCb_Sha256Hash+0x4e>

Disassembly of section .text.DRV_ETHPHY_Open%506:

0001c84c <DRV_ETHPHY_Open>:
{
   1c84c:	b508      	push	{r3, lr}
    if(phyInst->objInUse == false)
   1c84e:	4b18      	ldr	r3, [pc, #96]	; (1c8b0 <DRV_ETHPHY_Open+0x64>)
   1c850:	781b      	ldrb	r3, [r3, #0]
   1c852:	b133      	cbz	r3, 1c862 <DRV_ETHPHY_Open+0x16>
        if(pClientObj->clientInUse == 0)
   1c854:	4b16      	ldr	r3, [pc, #88]	; (1c8b0 <DRV_ETHPHY_Open+0x64>)
   1c856:	8b1b      	ldrh	r3, [r3, #24]
   1c858:	4303      	orrs	r3, r0
   1c85a:	d005      	beq.n	1c868 <DRV_ETHPHY_Open+0x1c>
    return DRV_HANDLE_INVALID;
   1c85c:	f04f 30ff 	mov.w	r0, #4294967295
}
   1c860:	bd08      	pop	{r3, pc}
        return DRV_HANDLE_INVALID;
   1c862:	f04f 30ff 	mov.w	r0, #4294967295
   1c866:	e7fb      	b.n	1c860 <DRV_ETHPHY_Open+0x14>
        DRV_HANDLE miimHandle = phyInst->pMiimBase->DRV_MIIM_Open(phyInst->miimIndex, DRV_IO_INTENT_SHARED);
   1c868:	4b11      	ldr	r3, [pc, #68]	; (1c8b0 <DRV_ETHPHY_Open+0x64>)
   1c86a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   1c86c:	6952      	ldr	r2, [r2, #20]
   1c86e:	2100      	movs	r1, #0
   1c870:	f8b3 0064 	ldrh.w	r0, [r3, #100]	; 0x64
   1c874:	4790      	blx	r2
        if(miimHandle == DRV_HANDLE_INVALID)
   1c876:	f1b0 3fff 	cmp.w	r0, #4294967295
   1c87a:	d0f1      	beq.n	1c860 <DRV_ETHPHY_Open+0x14>
        hClientObj->pMiimBase = phyInst->pMiimBase;
   1c87c:	4b0c      	ldr	r3, [pc, #48]	; (1c8b0 <DRV_ETHPHY_Open+0x64>)
   1c87e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   1c880:	629a      	str	r2, [r3, #40]	; 0x28
        hClientObj->miimHandle = miimHandle;
   1c882:	62d8      	str	r0, [r3, #44]	; 0x2c
        hClientObj->miimOpHandle = 0;
   1c884:	2200      	movs	r2, #0
   1c886:	631a      	str	r2, [r3, #48]	; 0x30
        hClientObj->clientInUse    = true;
   1c888:	2101      	movs	r1, #1
   1c88a:	8319      	strh	r1, [r3, #24]
        hClientObj->clientIx = clientIx;
   1c88c:	835a      	strh	r2, [r3, #26]
        hClientObj->hDriver  = phyInst;
   1c88e:	625b      	str	r3, [r3, #36]	; 0x24
        hClientObj->ethphyId = phyInst->ethphyId;
   1c890:	6899      	ldr	r1, [r3, #8]
   1c892:	61d9      	str	r1, [r3, #28]
        hClientObj->operType = DRV_ETHPHY_CLIENT_OP_TYPE_NONE;
   1c894:	869a      	strh	r2, [r3, #52]	; 0x34
        hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
   1c896:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    hClientObj->operPhase = operPhase;
   1c89a:	86da      	strh	r2, [r3, #54]	; 0x36
    hClientObj->operSubPhase = operSubPhase;
   1c89c:	871a      	strh	r2, [r3, #56]	; 0x38
        phyInst->numClients++;
   1c89e:	885a      	ldrh	r2, [r3, #2]
   1c8a0:	3201      	adds	r2, #1
   1c8a2:	805a      	strh	r2, [r3, #2]
        hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_READY;
   1c8a4:	2202      	movs	r2, #2
   1c8a6:	f883 2020 	strb.w	r2, [r3, #32]
        return ( ( DRV_HANDLE ) hClientObj );
   1c8aa:	f103 0018 	add.w	r0, r3, #24
   1c8ae:	e7d7      	b.n	1c860 <DRV_ETHPHY_Open+0x14>
   1c8b0:	2000e7e8 	.word	0x2000e7e8

Disassembly of section .text._TcpSwapHeader%507:

0001c8b4 <_TcpSwapHeader>:
	header->SourcePort      = TCPIP_Helper_ntohs(header->SourcePort);
   1c8b4:	8802      	ldrh	r2, [r0, #0]
   1c8b6:	0a13      	lsrs	r3, r2, #8
   1c8b8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1c8bc:	8003      	strh	r3, [r0, #0]
	header->DestPort        = TCPIP_Helper_ntohs(header->DestPort);
   1c8be:	8842      	ldrh	r2, [r0, #2]
   1c8c0:	0a13      	lsrs	r3, r2, #8
   1c8c2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1c8c6:	8043      	strh	r3, [r0, #2]
	header->SeqNumber       = TCPIP_Helper_ntohl(header->SeqNumber);
   1c8c8:	6843      	ldr	r3, [r0, #4]
    return (((hLong & 0x000000ff) << 24) | ((hLong & 0x0000ff00) << 8) | ((hLong & 0x00ff0000) >> 8) | ((hLong & 0xff000000) >> 24));
   1c8ca:	0e1a      	lsrs	r2, r3, #24
   1c8cc:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
   1c8d0:	0219      	lsls	r1, r3, #8
   1c8d2:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
   1c8d6:	430a      	orrs	r2, r1
   1c8d8:	0a1b      	lsrs	r3, r3, #8
   1c8da:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   1c8de:	4313      	orrs	r3, r2
   1c8e0:	6043      	str	r3, [r0, #4]
	header->AckNumber       = TCPIP_Helper_ntohl(header->AckNumber);
   1c8e2:	6883      	ldr	r3, [r0, #8]
   1c8e4:	0e1a      	lsrs	r2, r3, #24
   1c8e6:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
   1c8ea:	0219      	lsls	r1, r3, #8
   1c8ec:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
   1c8f0:	430a      	orrs	r2, r1
   1c8f2:	0a1b      	lsrs	r3, r3, #8
   1c8f4:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   1c8f8:	4313      	orrs	r3, r2
   1c8fa:	6083      	str	r3, [r0, #8]
	header->Window          = TCPIP_Helper_ntohs(header->Window);
   1c8fc:	89c2      	ldrh	r2, [r0, #14]
       return (((hShort) << 8) | ((hShort) >> 8));
   1c8fe:	0a13      	lsrs	r3, r2, #8
   1c900:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1c904:	81c3      	strh	r3, [r0, #14]
	header->Checksum        = TCPIP_Helper_ntohs(header->Checksum);
   1c906:	8a02      	ldrh	r2, [r0, #16]
   1c908:	0a13      	lsrs	r3, r2, #8
   1c90a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1c90e:	8203      	strh	r3, [r0, #16]
	header->UrgentPointer   = TCPIP_Helper_ntohs(header->UrgentPointer);
   1c910:	8a42      	ldrh	r2, [r0, #18]
   1c912:	0213      	lsls	r3, r2, #8
   1c914:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
   1c918:	8243      	strh	r3, [r0, #18]
}
   1c91a:	4770      	bx	lr

Disassembly of section .text._DNS_AddSelectionIf%508:

0001c91c <_DNS_AddSelectionIf>:
    if(pIf && _DNS_NetIsValid(pIf))
   1c91c:	b320      	cbz	r0, 1c968 <_DNS_AddSelectionIf+0x4c>
{
   1c91e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1c920:	4605      	mov	r5, r0
   1c922:	4616      	mov	r6, r2
   1c924:	460f      	mov	r7, r1
    if(pIf && _DNS_NetIsValid(pIf))
   1c926:	f004 f813 	bl	20950 <_DNS_NetIsValid>
   1c92a:	4684      	mov	ip, r0
   1c92c:	b300      	cbz	r0, 1c970 <_DNS_AddSelectionIf+0x54>
        for(ix = 0; ix < tblEntries; ix++)
   1c92e:	2e00      	cmp	r6, #0
   1c930:	dd22      	ble.n	1c978 <_DNS_AddSelectionIf+0x5c>
            if(dnsIfTbl[ix] == pIf)
   1c932:	683c      	ldr	r4, [r7, #0]
   1c934:	42a5      	cmp	r5, r4
   1c936:	d01d      	beq.n	1c974 <_DNS_AddSelectionIf+0x58>
   1c938:	463a      	mov	r2, r7
        addIx = -1;
   1c93a:	f04f 31ff 	mov.w	r1, #4294967295
        for(ix = 0; ix < tblEntries; ix++)
   1c93e:	2300      	movs	r3, #0
   1c940:	e00a      	b.n	1c958 <_DNS_AddSelectionIf+0x3c>
            if(dnsIfTbl[ix] == 0 && addIx < 0)
   1c942:	ea31 0121 	bics.w	r1, r1, r1, asr #32
   1c946:	bf28      	it	cs
   1c948:	4619      	movcs	r1, r3
        for(ix = 0; ix < tblEntries; ix++)
   1c94a:	3301      	adds	r3, #1
   1c94c:	429e      	cmp	r6, r3
   1c94e:	d006      	beq.n	1c95e <_DNS_AddSelectionIf+0x42>
            if(dnsIfTbl[ix] == pIf)
   1c950:	f852 4f04 	ldr.w	r4, [r2, #4]!
   1c954:	42ac      	cmp	r4, r5
   1c956:	d00d      	beq.n	1c974 <_DNS_AddSelectionIf+0x58>
            if(dnsIfTbl[ix] == 0 && addIx < 0)
   1c958:	2c00      	cmp	r4, #0
   1c95a:	d1f6      	bne.n	1c94a <_DNS_AddSelectionIf+0x2e>
   1c95c:	e7f1      	b.n	1c942 <_DNS_AddSelectionIf+0x26>
        if(addIx >= 0)
   1c95e:	2900      	cmp	r1, #0
   1c960:	db0d      	blt.n	1c97e <_DNS_AddSelectionIf+0x62>
            dnsIfTbl[addIx] = pIf;
   1c962:	f847 5021 	str.w	r5, [r7, r1, lsl #2]
   1c966:	e005      	b.n	1c974 <_DNS_AddSelectionIf+0x58>
    return true;
   1c968:	f04f 0c01 	mov.w	ip, #1
}
   1c96c:	4660      	mov	r0, ip
   1c96e:	4770      	bx	lr
    return true;
   1c970:	f04f 0c01 	mov.w	ip, #1
}
   1c974:	4660      	mov	r0, ip
   1c976:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return false;
   1c978:	f04f 0c00 	mov.w	ip, #0
   1c97c:	e7fa      	b.n	1c974 <_DNS_AddSelectionIf+0x58>
   1c97e:	f04f 0c00 	mov.w	ip, #0
   1c982:	e7f7      	b.n	1c974 <_DNS_AddSelectionIf+0x58>

Disassembly of section .text.TCPIP_OAHASH_EntryLookup%509:

0001c984 <TCPIP_OAHASH_EntryLookup>:
{
   1c984:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1c988:	4605      	mov	r5, r0
   1c98a:	4688      	mov	r8, r1
    probeStep = pOH->probeStep;
   1c98c:	6907      	ldr	r7, [r0, #16]
    bktIx = (*pOH->hashF)(pOH, key);
   1c98e:	6943      	ldr	r3, [r0, #20]
   1c990:	4798      	blx	r3
    while(bkts < pOH->hEntries)
   1c992:	68eb      	ldr	r3, [r5, #12]
   1c994:	b33b      	cbz	r3, 1c9e6 <TCPIP_OAHASH_EntryLookup+0x62>
   1c996:	4604      	mov	r4, r0
    size_t      bkts = 0;
   1c998:	2600      	movs	r6, #0
   1c99a:	e007      	b.n	1c9ac <TCPIP_OAHASH_EntryLookup+0x28>
        bktIx += probeStep;
   1c99c:	443c      	add	r4, r7
        if(bktIx >= pOH->hEntries)
   1c99e:	68eb      	ldr	r3, [r5, #12]
   1c9a0:	42a3      	cmp	r3, r4
            bktIx -= pOH->hEntries;
   1c9a2:	bf98      	it	ls
   1c9a4:	1ae4      	subls	r4, r4, r3
        bkts++;
   1c9a6:	3601      	adds	r6, #1
    while(bkts < pOH->hEntries)
   1c9a8:	42b3      	cmp	r3, r6
   1c9aa:	d917      	bls.n	1c9dc <TCPIP_OAHASH_EntryLookup+0x58>
        pBkt = (OA_HASH_ENTRY*)((uint8_t*)(pOH->memBlk) + bktIx * pOH->hEntrySize);
   1c9ac:	68ab      	ldr	r3, [r5, #8]
   1c9ae:	fb03 f304 	mul.w	r3, r3, r4
   1c9b2:	682a      	ldr	r2, [r5, #0]
   1c9b4:	eb02 0903 	add.w	r9, r2, r3
        if(pBkt->flags.busy && (*pOH->cmpF)(pOH, pBkt, key) == 0)
   1c9b8:	5cd3      	ldrb	r3, [r2, r3]
   1c9ba:	f013 0f01 	tst.w	r3, #1
   1c9be:	d0ed      	beq.n	1c99c <TCPIP_OAHASH_EntryLookup+0x18>
   1c9c0:	69eb      	ldr	r3, [r5, #28]
   1c9c2:	4642      	mov	r2, r8
   1c9c4:	4649      	mov	r1, r9
   1c9c6:	4628      	mov	r0, r5
   1c9c8:	4798      	blx	r3
   1c9ca:	2800      	cmp	r0, #0
   1c9cc:	d1e6      	bne.n	1c99c <TCPIP_OAHASH_EntryLookup+0x18>
            pBkt->flags.newEntry = 0;
   1c9ce:	f899 3000 	ldrb.w	r3, [r9]
   1c9d2:	f36f 0341 	bfc	r3, #1, #1
   1c9d6:	f889 3000 	strb.w	r3, [r9]
            return pBkt;
   1c9da:	e001      	b.n	1c9e0 <TCPIP_OAHASH_EntryLookup+0x5c>
    return 0;   // not found
   1c9dc:	f04f 0900 	mov.w	r9, #0
}
   1c9e0:	4648      	mov	r0, r9
   1c9e2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return 0;   // not found
   1c9e6:	f04f 0900 	mov.w	r9, #0
   1c9ea:	e7f9      	b.n	1c9e0 <TCPIP_OAHASH_EntryLookup+0x5c>

Disassembly of section .text._TCPIPStackInsertRxPacket%510:

0001c9ec <_TCPIPStackInsertRxPacket>:
{
   1c9ec:	b538      	push	{r3, r4, r5, lr}
   1c9ee:	4604      	mov	r4, r0
   1c9f0:	4615      	mov	r5, r2
    pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_QUEUED;
   1c9f2:	8c4a      	ldrh	r2, [r1, #34]	; 0x22
   1c9f4:	f042 0208 	orr.w	r2, r2, #8
   1c9f8:	844a      	strh	r2, [r1, #34]	; 0x22
    pRxPkt->pDSeg->segLen -= sizeof(TCPIP_MAC_ETHERNET_HEADER);
   1c9fa:	6908      	ldr	r0, [r1, #16]
   1c9fc:	8982      	ldrh	r2, [r0, #12]
   1c9fe:	3a0e      	subs	r2, #14
   1ca00:	8182      	strh	r2, [r0, #12]
    pRxPkt->pktIf = pNetIf;
   1ca02:	628c      	str	r4, [r1, #40]	; 0x28
    _TCPIPStackModuleRxInsert(TCPIP_MODULE_MANAGER, pRxPkt, 0);
   1ca04:	2200      	movs	r2, #0
   1ca06:	2001      	movs	r0, #1
   1ca08:	f002 fd38 	bl	1f47c <_TCPIPStackModuleRxInsert>
    if(signal)
   1ca0c:	b905      	cbnz	r5, 1ca10 <_TCPIPStackInsertRxPacket+0x24>
}
   1ca0e:	bd38      	pop	{r3, r4, r5, pc}
    return OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
   1ca10:	2001      	movs	r0, #1
   1ca12:	f006 feaf 	bl	23774 <OSAL_CRIT_Enter>
    pNetIf->activeEvents |= event;
   1ca16:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
   1ca1a:	f043 0310 	orr.w	r3, r3, #16
   1ca1e:	f8a4 305a 	strh.w	r3, [r4, #90]	; 0x5a
    totTcpipEventsCnt++;
   1ca22:	4a0a      	ldr	r2, [pc, #40]	; (1ca4c <_TCPIPStackInsertRxPacket+0x60>)
   1ca24:	6813      	ldr	r3, [r2, #0]
   1ca26:	3301      	adds	r3, #1
   1ca28:	6013      	str	r3, [r2, #0]
        pSigEntry->signalVal |= TCPIP_MODULE_SIGNAL_RX_PENDING;
   1ca2a:	4c09      	ldr	r4, [pc, #36]	; (1ca50 <_TCPIPStackInsertRxPacket+0x64>)
   1ca2c:	8b23      	ldrh	r3, [r4, #24]
   1ca2e:	f043 0301 	orr.w	r3, r3, #1
   1ca32:	8323      	strh	r3, [r4, #24]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, suspLevel);
   1ca34:	4601      	mov	r1, r0
   1ca36:	2001      	movs	r0, #1
   1ca38:	f006 ffd6 	bl	239e8 <OSAL_CRIT_Leave>
        _TCPIPSignalEntryNotify(pSigEntry, TCPIP_MODULE_SIGNAL_RX_PENDING, 0);
   1ca3c:	2200      	movs	r2, #0
   1ca3e:	2101      	movs	r1, #1
   1ca40:	f104 0010 	add.w	r0, r4, #16
   1ca44:	f006 fb2c 	bl	230a0 <_TCPIPSignalEntryNotify>
}
   1ca48:	e7e1      	b.n	1ca0e <_TCPIPStackInsertRxPacket+0x22>
   1ca4a:	bf00      	nop
   1ca4c:	2000ee7c 	.word	0x2000ee7c
   1ca50:	2000d9a4 	.word	0x2000d9a4

Disassembly of section .text.SYS_CONSOLE_Initialize%511:

0001ca54 <SYS_CONSOLE_Initialize>:
{
   1ca54:	b538      	push	{r3, r4, r5, lr}
   1ca56:	4605      	mov	r5, r0
   1ca58:	460c      	mov	r4, r1
    if (isConsoleMutexCreated == false)
   1ca5a:	4b15      	ldr	r3, [pc, #84]	; (1cab0 <SYS_CONSOLE_Initialize+0x5c>)
   1ca5c:	781b      	ldrb	r3, [r3, #0]
   1ca5e:	b143      	cbz	r3, 1ca72 <SYS_CONSOLE_Initialize+0x1e>
    if (index >= SYS_CONSOLE_DEVICE_MAX_INSTANCES || init == NULL)
   1ca60:	b9fd      	cbnz	r5, 1caa2 <SYS_CONSOLE_Initialize+0x4e>
   1ca62:	b30c      	cbz	r4, 1caa8 <SYS_CONSOLE_Initialize+0x54>
    if ((pConsoleObj->status == SYS_STATUS_UNINITIALIZED) && initConfig)
   1ca64:	4b13      	ldr	r3, [pc, #76]	; (1cab4 <SYS_CONSOLE_Initialize+0x60>)
   1ca66:	f993 3000 	ldrsb.w	r3, [r3]
   1ca6a:	b15b      	cbz	r3, 1ca84 <SYS_CONSOLE_Initialize+0x30>
    return SYS_MODULE_OBJ_INVALID;
   1ca6c:	f04f 30ff 	mov.w	r0, #4294967295
}
   1ca70:	bd38      	pop	{r3, r4, r5, pc}
        if(OSAL_MUTEX_Create(&(consolePrintBufferMutex)) != OSAL_RESULT_TRUE)
   1ca72:	4811      	ldr	r0, [pc, #68]	; (1cab8 <SYS_CONSOLE_Initialize+0x64>)
   1ca74:	f006 fe96 	bl	237a4 <OSAL_MUTEX_Create>
   1ca78:	2801      	cmp	r0, #1
   1ca7a:	d10f      	bne.n	1ca9c <SYS_CONSOLE_Initialize+0x48>
            isConsoleMutexCreated = true;
   1ca7c:	4b0c      	ldr	r3, [pc, #48]	; (1cab0 <SYS_CONSOLE_Initialize+0x5c>)
   1ca7e:	2201      	movs	r2, #1
   1ca80:	701a      	strb	r2, [r3, #0]
   1ca82:	e7ed      	b.n	1ca60 <SYS_CONSOLE_Initialize+0xc>
        pConsoleObj->devIndex = initConfig->deviceIndex;
   1ca84:	68a0      	ldr	r0, [r4, #8]
   1ca86:	4b0b      	ldr	r3, [pc, #44]	; (1cab4 <SYS_CONSOLE_Initialize+0x60>)
   1ca88:	6098      	str	r0, [r3, #8]
        pConsoleObj->devDesc = initConfig->consDevDesc;
   1ca8a:	6862      	ldr	r2, [r4, #4]
   1ca8c:	605a      	str	r2, [r3, #4]
        pConsoleObj->status = SYS_STATUS_READY;
   1ca8e:	2102      	movs	r1, #2
   1ca90:	7019      	strb	r1, [r3, #0]
        pConsoleObj->devDesc->init( pConsoleObj->devIndex, initConfig->deviceInitData);
   1ca92:	6853      	ldr	r3, [r2, #4]
   1ca94:	6821      	ldr	r1, [r4, #0]
   1ca96:	4798      	blx	r3
        return index;
   1ca98:	2000      	movs	r0, #0
   1ca9a:	e7e9      	b.n	1ca70 <SYS_CONSOLE_Initialize+0x1c>
            return SYS_MODULE_OBJ_INVALID;
   1ca9c:	f04f 30ff 	mov.w	r0, #4294967295
   1caa0:	e7e6      	b.n	1ca70 <SYS_CONSOLE_Initialize+0x1c>
        return SYS_MODULE_OBJ_INVALID;
   1caa2:	f04f 30ff 	mov.w	r0, #4294967295
   1caa6:	e7e3      	b.n	1ca70 <SYS_CONSOLE_Initialize+0x1c>
   1caa8:	f04f 30ff 	mov.w	r0, #4294967295
   1caac:	e7e0      	b.n	1ca70 <SYS_CONSOLE_Initialize+0x1c>
   1caae:	bf00      	nop
   1cab0:	2000ef90 	.word	0x2000ef90
   1cab4:	2000ed64 	.word	0x2000ed64
   1cab8:	2000eed8 	.word	0x2000eed8

Disassembly of section .text.wc_RNG_TestSeed%512:

0001cabc <wc_RNG_TestSeed>:
{
   1cabc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    word32 scratchSz = min(SEED_BLOCK_SZ, seedSz - SEED_BLOCK_SZ);
   1cac0:	f1a1 0e04 	sub.w	lr, r1, #4
        return a > b ? b : a;
   1cac4:	4673      	mov	r3, lr
   1cac6:	2b04      	cmp	r3, #4
   1cac8:	bf28      	it	cs
   1caca:	2304      	movcs	r3, #4
    while (seedIdx < seedSz - SEED_BLOCK_SZ) {
   1cacc:	f1be 0f00 	cmp.w	lr, #0
   1cad0:	d025      	beq.n	1cb1e <wc_RNG_TestSeed+0x62>
   1cad2:	4684      	mov	ip, r0
    word32 seedIdx = 0;
   1cad4:	2700      	movs	r7, #0
    int ret = 0;
   1cad6:	4638      	mov	r0, r7
   1cad8:	f10c 38ff 	add.w	r8, ip, #4294967295
   1cadc:	e009      	b.n	1caf2 <wc_RNG_TestSeed+0x36>
            ret = DRBG_CONT_FAILURE;
   1cade:	2c00      	cmp	r4, #0
   1cae0:	bf08      	it	eq
   1cae2:	2003      	moveq	r0, #3
        seedIdx += SEED_BLOCK_SZ;
   1cae4:	3704      	adds	r7, #4
   1cae6:	1bcb      	subs	r3, r1, r7
   1cae8:	2b04      	cmp	r3, #4
   1caea:	bf28      	it	cs
   1caec:	2304      	movcs	r3, #4
    while (seedIdx < seedSz - SEED_BLOCK_SZ) {
   1caee:	45be      	cmp	lr, r7
   1caf0:	d916      	bls.n	1cb20 <wc_RNG_TestSeed+0x64>
                            seed + seedIdx + scratchSz,
   1caf2:	18fe      	adds	r6, r7, r3
    for (i = 0; i < length; i++) {
   1caf4:	2b00      	cmp	r3, #0
   1caf6:	dd10      	ble.n	1cb1a <wc_RNG_TestSeed+0x5e>
   1caf8:	eb08 0507 	add.w	r5, r8, r7
   1cafc:	eb0c 0206 	add.w	r2, ip, r6
   1cb00:	4463      	add	r3, ip
   1cb02:	441e      	add	r6, r3
    int compareSum = 0;
   1cb04:	2400      	movs	r4, #0
        compareSum |= a[i] ^ b[i];
   1cb06:	f812 3b01 	ldrb.w	r3, [r2], #1
   1cb0a:	f815 9f01 	ldrb.w	r9, [r5, #1]!
   1cb0e:	ea83 0309 	eor.w	r3, r3, r9
   1cb12:	431c      	orrs	r4, r3
    for (i = 0; i < length; i++) {
   1cb14:	42b2      	cmp	r2, r6
   1cb16:	d1f6      	bne.n	1cb06 <wc_RNG_TestSeed+0x4a>
   1cb18:	e7e1      	b.n	1cade <wc_RNG_TestSeed+0x22>
            ret = DRBG_CONT_FAILURE;
   1cb1a:	2003      	movs	r0, #3
   1cb1c:	e7e2      	b.n	1cae4 <wc_RNG_TestSeed+0x28>
    int ret = 0;
   1cb1e:	2000      	movs	r0, #0
}
   1cb20:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

Disassembly of section .text.rand%513:

0001cb24 <rand>:
   1cb24:	4b13      	ldr	r3, [pc, #76]	; (1cb74 <rand+0x50>)
   1cb26:	b510      	push	{r4, lr}
   1cb28:	681c      	ldr	r4, [r3, #0]
   1cb2a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1cb2c:	b97b      	cbnz	r3, 1cb4e <rand+0x2a>
   1cb2e:	2018      	movs	r0, #24
   1cb30:	f007 f9a6 	bl	23e80 <malloc>
   1cb34:	4a10      	ldr	r2, [pc, #64]	; (1cb78 <rand+0x54>)
   1cb36:	4b11      	ldr	r3, [pc, #68]	; (1cb7c <rand+0x58>)
   1cb38:	63a0      	str	r0, [r4, #56]	; 0x38
   1cb3a:	e9c0 2300 	strd	r2, r3, [r0]
   1cb3e:	4b10      	ldr	r3, [pc, #64]	; (1cb80 <rand+0x5c>)
   1cb40:	6083      	str	r3, [r0, #8]
   1cb42:	230b      	movs	r3, #11
   1cb44:	8183      	strh	r3, [r0, #12]
   1cb46:	2201      	movs	r2, #1
   1cb48:	2300      	movs	r3, #0
   1cb4a:	e9c0 2304 	strd	r2, r3, [r0, #16]
   1cb4e:	6ba1      	ldr	r1, [r4, #56]	; 0x38
   1cb50:	480c      	ldr	r0, [pc, #48]	; (1cb84 <rand+0x60>)
   1cb52:	690a      	ldr	r2, [r1, #16]
   1cb54:	694b      	ldr	r3, [r1, #20]
   1cb56:	4c0c      	ldr	r4, [pc, #48]	; (1cb88 <rand+0x64>)
   1cb58:	4350      	muls	r0, r2
   1cb5a:	fb04 0003 	mla	r0, r4, r3, r0
   1cb5e:	fba2 3404 	umull	r3, r4, r2, r4
   1cb62:	1c5a      	adds	r2, r3, #1
   1cb64:	4404      	add	r4, r0
   1cb66:	f144 0000 	adc.w	r0, r4, #0
   1cb6a:	e9c1 2004 	strd	r2, r0, [r1, #16]
   1cb6e:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
   1cb72:	bd10      	pop	{r4, pc}
   1cb74:	2000ef60 	.word	0x2000ef60
   1cb78:	abcd330e 	.word	0xabcd330e
   1cb7c:	e66d1234 	.word	0xe66d1234
   1cb80:	0005deec 	.word	0x0005deec
   1cb84:	5851f42d 	.word	0x5851f42d
   1cb88:	4c957f2d 	.word	0x4c957f2d

Disassembly of section .text._Balloc%514:

0001cb8c <_Balloc>:
   1cb8c:	b570      	push	{r4, r5, r6, lr}
   1cb8e:	6a45      	ldr	r5, [r0, #36]	; 0x24
   1cb90:	4604      	mov	r4, r0
   1cb92:	460e      	mov	r6, r1
   1cb94:	b93d      	cbnz	r5, 1cba6 <_Balloc+0x1a>
   1cb96:	2010      	movs	r0, #16
   1cb98:	f007 f972 	bl	23e80 <malloc>
   1cb9c:	e9c0 5501 	strd	r5, r5, [r0, #4]
   1cba0:	6260      	str	r0, [r4, #36]	; 0x24
   1cba2:	6005      	str	r5, [r0, #0]
   1cba4:	60c5      	str	r5, [r0, #12]
   1cba6:	6a65      	ldr	r5, [r4, #36]	; 0x24
   1cba8:	68eb      	ldr	r3, [r5, #12]
   1cbaa:	b183      	cbz	r3, 1cbce <_Balloc+0x42>
   1cbac:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1cbae:	68db      	ldr	r3, [r3, #12]
   1cbb0:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
   1cbb4:	b9b8      	cbnz	r0, 1cbe6 <_Balloc+0x5a>
   1cbb6:	2101      	movs	r1, #1
   1cbb8:	fa01 f506 	lsl.w	r5, r1, r6
   1cbbc:	1d6a      	adds	r2, r5, #5
   1cbbe:	0092      	lsls	r2, r2, #2
   1cbc0:	4620      	mov	r0, r4
   1cbc2:	f006 fba1 	bl	23308 <_calloc_r>
   1cbc6:	b160      	cbz	r0, 1cbe2 <_Balloc+0x56>
   1cbc8:	e9c0 6501 	strd	r6, r5, [r0, #4]
   1cbcc:	e00e      	b.n	1cbec <_Balloc+0x60>
   1cbce:	2221      	movs	r2, #33	; 0x21
   1cbd0:	2104      	movs	r1, #4
   1cbd2:	4620      	mov	r0, r4
   1cbd4:	f006 fb98 	bl	23308 <_calloc_r>
   1cbd8:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1cbda:	60e8      	str	r0, [r5, #12]
   1cbdc:	68db      	ldr	r3, [r3, #12]
   1cbde:	2b00      	cmp	r3, #0
   1cbe0:	d1e4      	bne.n	1cbac <_Balloc+0x20>
   1cbe2:	2000      	movs	r0, #0
   1cbe4:	bd70      	pop	{r4, r5, r6, pc}
   1cbe6:	6802      	ldr	r2, [r0, #0]
   1cbe8:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
   1cbec:	2300      	movs	r3, #0
   1cbee:	e9c0 3303 	strd	r3, r3, [r0, #12]
   1cbf2:	e7f7      	b.n	1cbe4 <_Balloc+0x58>

Disassembly of section .text._DRV_ETHPHY_NegResultPhase_BMSTAT%515:

0001cbf4 <_DRV_ETHPHY_NegResultPhase_BMSTAT>:
{
   1cbf4:	b510      	push	{r4, lr}
   1cbf6:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1cbf8:	f005 fe6c 	bl	228d4 <_DRV_PHY_SMITransfer_Wait>
   1cbfc:	b190      	cbz	r0, 1cc24 <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x30>
    if(phyStat.AN_COMPLETE == 0)
   1cbfe:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
   1cc02:	f013 0f20 	tst.w	r3, #32
   1cc06:	d00e      	beq.n	1cc26 <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x32>
    else if(phyStat.LINK_STAT == 0)
   1cc08:	f013 0f04 	tst.w	r3, #4
   1cc0c:	d119      	bne.n	1cc42 <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x4e>
    DRV_ETHPHY_NEGOTIATION_RESULT* pNegResult = (DRV_ETHPHY_NEGOTIATION_RESULT*)hClientObj->operParam;
   1cc0e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    if(pNegResult)
   1cc10:	b11b      	cbz	r3, 1cc1a <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x26>
        pNegResult->linkStatus = linkStatus;
   1cc12:	2200      	movs	r2, #0
   1cc14:	801a      	strh	r2, [r3, #0]
        pNegResult->linkFlags = openFlags;
   1cc16:	805a      	strh	r2, [r3, #2]
        pNegResult->pauseType = pauseType;
   1cc18:	711a      	strb	r2, [r3, #4]
    _DRV_PHY_SetOperDoneResult(hClientObj, res);
   1cc1a:	f06f 0107 	mvn.w	r1, #7
   1cc1e:	4620      	mov	r0, r4
   1cc20:	f005 f904 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
}
   1cc24:	bd10      	pop	{r4, pc}
    DRV_ETHPHY_NEGOTIATION_RESULT* pNegResult = (DRV_ETHPHY_NEGOTIATION_RESULT*)hClientObj->operParam;
   1cc26:	6b23      	ldr	r3, [r4, #48]	; 0x30
    if(pNegResult)
   1cc28:	b12b      	cbz	r3, 1cc36 <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x42>
        pNegResult->linkStatus = linkStatus;
   1cc2a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   1cc2e:	801a      	strh	r2, [r3, #0]
        pNegResult->linkFlags = openFlags;
   1cc30:	2200      	movs	r2, #0
   1cc32:	805a      	strh	r2, [r3, #2]
        pNegResult->pauseType = pauseType;
   1cc34:	711a      	strb	r2, [r3, #4]
    _DRV_PHY_SetOperDoneResult(hClientObj, res);
   1cc36:	f06f 0107 	mvn.w	r1, #7
   1cc3a:	4620      	mov	r0, r4
   1cc3c:	f005 f8f6 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
   1cc40:	e7f0      	b.n	1cc24 <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x30>
        if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_ANEXP))
   1cc42:	2106      	movs	r1, #6
   1cc44:	4620      	mov	r0, r4
   1cc46:	f004 f993 	bl	20f70 <_DRV_PHY_SMIReadStart>
   1cc4a:	2800      	cmp	r0, #0
   1cc4c:	d0ea      	beq.n	1cc24 <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x30>
    hClientObj->operPhase = operPhase;
   1cc4e:	2302      	movs	r3, #2
   1cc50:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1cc52:	2300      	movs	r3, #0
   1cc54:	8423      	strh	r3, [r4, #32]
   1cc56:	e7e5      	b.n	1cc24 <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x30>

Disassembly of section .text._DRV_ETHPHY_ResetPhaseRead%516:

0001cc58 <_DRV_ETHPHY_ResetPhaseRead>:
{
   1cc58:	b510      	push	{r4, lr}
   1cc5a:	4604      	mov	r4, r0
    switch(hClientObj->operSubPhase)
   1cc5c:	8c03      	ldrh	r3, [r0, #32]
   1cc5e:	b133      	cbz	r3, 1cc6e <_DRV_ETHPHY_ResetPhaseRead+0x16>
   1cc60:	2b01      	cmp	r3, #1
   1cc62:	d00e      	beq.n	1cc82 <_DRV_ETHPHY_ResetPhaseRead+0x2a>
            _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   1cc64:	f06f 0108 	mvn.w	r1, #8
   1cc68:	f005 f8e0 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
}
   1cc6c:	bd10      	pop	{r4, pc}
            if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMCON))
   1cc6e:	2100      	movs	r1, #0
   1cc70:	f004 f97e 	bl	20f70 <_DRV_PHY_SMIReadStart>
   1cc74:	2800      	cmp	r0, #0
   1cc76:	d0f9      	beq.n	1cc6c <_DRV_ETHPHY_ResetPhaseRead+0x14>
    hClientObj->operPhase = operPhase;
   1cc78:	2302      	movs	r3, #2
   1cc7a:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1cc7c:	2301      	movs	r3, #1
   1cc7e:	8423      	strh	r3, [r4, #32]
   1cc80:	e7f4      	b.n	1cc6c <_DRV_ETHPHY_ResetPhaseRead+0x14>
            if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1cc82:	f005 fe27 	bl	228d4 <_DRV_PHY_SMITransfer_Wait>
   1cc86:	2800      	cmp	r0, #0
   1cc88:	d0f0      	beq.n	1cc6c <_DRV_ETHPHY_ResetPhaseRead+0x14>
            if(bmcon.RESET)
   1cc8a:	f994 303b 	ldrsb.w	r3, [r4, #59]	; 0x3b
   1cc8e:	2b00      	cmp	r3, #0
   1cc90:	db04      	blt.n	1cc9c <_DRV_ETHPHY_ResetPhaseRead+0x44>
                _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OK);
   1cc92:	2100      	movs	r1, #0
   1cc94:	4620      	mov	r0, r4
   1cc96:	f005 f8c9 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
   1cc9a:	e7e7      	b.n	1cc6c <_DRV_ETHPHY_ResetPhaseRead+0x14>
                if(SYS_TMR_TickCountGet() < hClientObj->operTStamp)
   1cc9c:	f005 face 	bl	2223c <SYS_TMR_TickCountGet>
   1cca0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1cca2:	4298      	cmp	r0, r3
   1cca4:	d204      	bcs.n	1ccb0 <_DRV_ETHPHY_ResetPhaseRead+0x58>
    hClientObj->operPhase = operPhase;
   1cca6:	2302      	movs	r3, #2
   1cca8:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1ccaa:	2300      	movs	r3, #0
   1ccac:	8423      	strh	r3, [r4, #32]
   1ccae:	e7dd      	b.n	1cc6c <_DRV_ETHPHY_ResetPhaseRead+0x14>
                    _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_DTCT_ERR);
   1ccb0:	f04f 31ff 	mov.w	r1, #4294967295
   1ccb4:	4620      	mov	r0, r4
   1ccb6:	f005 f8b9 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
   1ccba:	e7d7      	b.n	1cc6c <_DRV_ETHPHY_ResetPhaseRead+0x14>

Disassembly of section .text.DRV_GMAC_RegisterStatisticsGet%517:

0001ccbc <DRV_GMAC_RegisterStatisticsGet>:
{
   1ccbc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1ccc0:	460c      	mov	r4, r1
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1ccc2:	4915      	ldr	r1, [pc, #84]	; (1cd18 <DRV_GMAC_RegisterStatisticsGet+0x5c>)
   1ccc4:	4281      	cmp	r1, r0
   1ccc6:	d11c      	bne.n	1cd02 <DRV_GMAC_RegisterStatisticsGet+0x46>
    if(pMACDrv == 0)
   1ccc8:	b1f8      	cbz	r0, 1cd0a <DRV_GMAC_RegisterStatisticsGet+0x4e>
	if(pHwEntries)
   1ccca:	b10b      	cbz	r3, 1ccd0 <DRV_GMAC_RegisterStatisticsGet+0x14>
		*pHwEntries = nHwEntries;
   1cccc:	212d      	movs	r1, #45	; 0x2d
   1ccce:	6019      	str	r1, [r3, #0]
	if(pRegEntries)
   1ccd0:	b1f4      	cbz	r4, 1cd10 <DRV_GMAC_RegisterStatisticsGet+0x54>
		regLim = nEntries > nHwEntries ? nHwEntries : nEntries;
   1ccd2:	2a2d      	cmp	r2, #45	; 0x2d
   1ccd4:	bfa8      	it	ge
   1ccd6:	222d      	movge	r2, #45	; 0x2d
   1ccd8:	4617      	mov	r7, r2
		for(ix = 0; ix < regLim; ix++, pRegEntries++, pHwRegDcpt++)
   1ccda:	b1da      	cbz	r2, 1cd14 <DRV_GMAC_RegisterStatisticsGet+0x58>
   1ccdc:	2600      	movs	r6, #0
		pHwRegDcpt = macPIC32CHwRegDcpt;
   1ccde:	4d0f      	ldr	r5, [pc, #60]	; (1cd1c <DRV_GMAC_RegisterStatisticsGet+0x60>)
			strncpy(pRegEntries->registerName, pHwRegDcpt->regName, sizeof(pRegEntries->registerName));
   1cce0:	f04f 0824 	mov.w	r8, #36	; 0x24
   1cce4:	4642      	mov	r2, r8
   1cce6:	4629      	mov	r1, r5
   1cce8:	4620      	mov	r0, r4
   1ccea:	f005 fbe1 	bl	224b0 <strncpy>
			pRegEntries->registerValue = (*pHwRegDcpt->regFunc)();
   1ccee:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1ccf0:	4798      	blx	r3
   1ccf2:	6260      	str	r0, [r4, #36]	; 0x24
		for(ix = 0; ix < regLim; ix++, pRegEntries++, pHwRegDcpt++)
   1ccf4:	3601      	adds	r6, #1
   1ccf6:	3428      	adds	r4, #40	; 0x28
   1ccf8:	3528      	adds	r5, #40	; 0x28
   1ccfa:	42b7      	cmp	r7, r6
   1ccfc:	d1f2      	bne.n	1cce4 <DRV_GMAC_RegisterStatisticsGet+0x28>
	return TCPIP_MAC_RES_OK;
   1ccfe:	2000      	movs	r0, #0
   1cd00:	e001      	b.n	1cd06 <DRV_GMAC_RegisterStatisticsGet+0x4a>
        return TCPIP_MAC_RES_OP_ERR;
   1cd02:	f06f 0005 	mvn.w	r0, #5
}
   1cd06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return TCPIP_MAC_RES_OP_ERR;
   1cd0a:	f06f 0005 	mvn.w	r0, #5
   1cd0e:	e7fa      	b.n	1cd06 <DRV_GMAC_RegisterStatisticsGet+0x4a>
	return TCPIP_MAC_RES_OK;
   1cd10:	2000      	movs	r0, #0
   1cd12:	e7f8      	b.n	1cd06 <DRV_GMAC_RegisterStatisticsGet+0x4a>
   1cd14:	2000      	movs	r0, #0
   1cd16:	e7f6      	b.n	1cd06 <DRV_GMAC_RegisterStatisticsGet+0x4a>
   1cd18:	2000e288 	.word	0x2000e288
   1cd1c:	00006574 	.word	0x00006574

Disassembly of section .text._MacRxPacketAck%518:

0001cd20 <_MacRxPacketAck>:
    if(pPkt && pPkt->pDSeg)
   1cd20:	b350      	cbz	r0, 1cd78 <_MacRxPacketAck+0x58>
{
   1cd22:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1cd24:	460c      	mov	r4, r1
   1cd26:	4601      	mov	r1, r0
    if(pPkt && pPkt->pDSeg)
   1cd28:	6903      	ldr	r3, [r0, #16]
   1cd2a:	b33b      	cbz	r3, 1cd7c <_MacRxPacketAck+0x5c>
            pPkt->pDSeg->next = 0;
   1cd2c:	2600      	movs	r6, #0
                DRV_PIC32CGMAC_SingleListTailAdd(&pMacDrv->sGmacData.gmac_queue[queueIdx]._RxQueue, (DRV_PIC32CGMAC_SGL_LIST_NODE*)pPkt); 
   1cd2e:	f104 0794 	add.w	r7, r4, #148	; 0x94
   1cd32:	e009      	b.n	1cd48 <_MacRxPacketAck+0x28>
                (*pMacDrv->sGmacData.pktFreeF)(pPkt);          
   1cd34:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1cd36:	4608      	mov	r0, r1
   1cd38:	4798      	blx	r3
            if( !pDSegNext )
   1cd3a:	b30d      	cbz	r5, 1cd80 <_MacRxPacketAck+0x60>
            TCPIP_MAC_SEGMENT_GAP_DCPT* pGap = (TCPIP_MAC_SEGMENT_GAP_DCPT*)(pDSegNext->segBuffer + pMacDrv->sGmacData._dcptOffset);
   1cd3c:	f9b4 30ec 	ldrsh.w	r3, [r4, #236]	; 0xec
            pPkt = pGap->segmentPktPtr;
   1cd40:	686a      	ldr	r2, [r5, #4]
   1cd42:	58d1      	ldr	r1, [r2, r3]
        while(pPkt->pDSeg)
   1cd44:	690b      	ldr	r3, [r1, #16]
   1cd46:	b1ab      	cbz	r3, 1cd74 <_MacRxPacketAck+0x54>
            pDSegNext = pPkt->pDSeg->next;
   1cd48:	681d      	ldr	r5, [r3, #0]
            pPkt->pDSeg->next = 0;
   1cd4a:	601e      	str	r6, [r3, #0]
            if((pPkt->pDSeg->segFlags  & TCPIP_MAC_SEG_FLAG_RX_STICKY) == 0 && 
   1cd4c:	690b      	ldr	r3, [r1, #16]
   1cd4e:	8a1b      	ldrh	r3, [r3, #16]
   1cd50:	f013 0f04 	tst.w	r3, #4
   1cd54:	d10a      	bne.n	1cd6c <_MacRxPacketAck+0x4c>
   1cd56:	f8b4 30f4 	ldrh.w	r3, [r4, #244]	; 0xf4
   1cd5a:	f013 0f02 	tst.w	r3, #2
   1cd5e:	d1e9      	bne.n	1cd34 <_MacRxPacketAck+0x14>
                        pMacDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxBuffCntThres)))
   1cd60:	f8b4 30c4 	ldrh.w	r3, [r4, #196]	; 0xc4
                (((pMacDrv->sGmacData._controlFlags & TCPIP_MAC_CONTROL_NO_SMART_ALLOC) != 0) ||
   1cd64:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
   1cd68:	429a      	cmp	r2, r3
   1cd6a:	dce3      	bgt.n	1cd34 <_MacRxPacketAck+0x14>
                DRV_PIC32CGMAC_SingleListTailAdd(&pMacDrv->sGmacData.gmac_queue[queueIdx]._RxQueue, (DRV_PIC32CGMAC_SGL_LIST_NODE*)pPkt); 
   1cd6c:	4638      	mov	r0, r7
   1cd6e:	f006 faf5 	bl	2335c <DRV_PIC32CGMAC_SingleListTailAdd>
   1cd72:	e7e2      	b.n	1cd3a <_MacRxPacketAck+0x1a>
        res  = true; 
   1cd74:	2001      	movs	r0, #1
   1cd76:	e004      	b.n	1cd82 <_MacRxPacketAck+0x62>
    bool res = false;
   1cd78:	2000      	movs	r0, #0
}
   1cd7a:	4770      	bx	lr
    bool res = false;
   1cd7c:	2000      	movs	r0, #0
   1cd7e:	e000      	b.n	1cd82 <_MacRxPacketAck+0x62>
        res  = true; 
   1cd80:	2001      	movs	r0, #1
}
   1cd82:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.TCPIP_OAHASH_EntryLookupOrInsert%519:

0001cd84 <TCPIP_OAHASH_EntryLookupOrInsert>:
{
   1cd84:	b538      	push	{r3, r4, r5, lr}
   1cd86:	4604      	mov	r4, r0
   1cd88:	460d      	mov	r5, r1
    pBkt = _OAHashFindBkt(pOH, key);
   1cd8a:	f7fd fd6b 	bl	1a864 <_OAHashFindBkt>
    if(pBkt == 0)
   1cd8e:	4603      	mov	r3, r0
   1cd90:	b158      	cbz	r0, 1cdaa <TCPIP_OAHASH_EntryLookupOrInsert+0x26>
    if(pBkt->flags.busy == 0)
   1cd92:	781a      	ldrb	r2, [r3, #0]
   1cd94:	f012 0f01 	tst.w	r2, #1
        pBkt->flags.newEntry = 1;
   1cd98:	bf0e      	itee	eq
   1cd9a:	f042 0203 	orreq.w	r2, r2, #3
        pBkt->flags.newEntry = 0;
   1cd9e:	781a      	ldrbne	r2, [r3, #0]
   1cda0:	f36f 0241 	bfcne	r2, #1, #1
   1cda4:	701a      	strb	r2, [r3, #0]
}
   1cda6:	4618      	mov	r0, r3
   1cda8:	bd38      	pop	{r3, r4, r5, pc}
        if(pOH->fullSlots != pOH->hEntries)
   1cdaa:	6a61      	ldr	r1, [r4, #36]	; 0x24
   1cdac:	68e2      	ldr	r2, [r4, #12]
   1cdae:	4291      	cmp	r1, r2
   1cdb0:	d1f9      	bne.n	1cda6 <TCPIP_OAHASH_EntryLookupOrInsert+0x22>
        if(pOH->delF == 0 || (pDel = (*pOH->delF)(pOH)) == 0)
   1cdb2:	69a2      	ldr	r2, [r4, #24]
   1cdb4:	2a00      	cmp	r2, #0
   1cdb6:	d0f6      	beq.n	1cda6 <TCPIP_OAHASH_EntryLookupOrInsert+0x22>
   1cdb8:	4620      	mov	r0, r4
   1cdba:	4790      	blx	r2
   1cdbc:	4603      	mov	r3, r0
   1cdbe:	2800      	cmp	r0, #0
   1cdc0:	d0f1      	beq.n	1cda6 <TCPIP_OAHASH_EntryLookupOrInsert+0x22>
    if(pOE->flags.busy)
   1cdc2:	7802      	ldrb	r2, [r0, #0]
   1cdc4:	f012 0f01 	tst.w	r2, #1
   1cdc8:	d006      	beq.n	1cdd8 <TCPIP_OAHASH_EntryLookupOrInsert+0x54>
        pOE->flags.busy = 0;
   1cdca:	7802      	ldrb	r2, [r0, #0]
   1cdcc:	f36f 0200 	bfc	r2, #0, #1
   1cdd0:	7002      	strb	r2, [r0, #0]
        pOH->fullSlots--;
   1cdd2:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1cdd4:	3b01      	subs	r3, #1
   1cdd6:	6263      	str	r3, [r4, #36]	; 0x24
        pBkt = _OAHashFindBkt(pOH, key);
   1cdd8:	4629      	mov	r1, r5
   1cdda:	4620      	mov	r0, r4
   1cddc:	f7fd fd42 	bl	1a864 <_OAHashFindBkt>
        if(pBkt == 0)
   1cde0:	4603      	mov	r3, r0
   1cde2:	2800      	cmp	r0, #0
   1cde4:	d1d5      	bne.n	1cd92 <TCPIP_OAHASH_EntryLookupOrInsert+0xe>
   1cde6:	e7de      	b.n	1cda6 <TCPIP_OAHASH_EntryLookupOrInsert+0x22>

Disassembly of section .text.TCPIP_STACK_BringNetDown%520:

0001cde8 <TCPIP_STACK_BringNetDown>:
{
   1cde8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1cdea:	4605      	mov	r5, r0
   1cdec:	460e      	mov	r6, r1
    stackCtrlData->pNetIf = pNetIf;
   1cdee:	6141      	str	r1, [r0, #20]
    stackCtrlData->netIx = pNetIf->netIfIx;
   1cdf0:	f8b1 1058 	ldrh.w	r1, [r1, #88]	; 0x58
   1cdf4:	6181      	str	r1, [r0, #24]
    stackCtrlData->stackAction = action;
   1cdf6:	7702      	strb	r2, [r0, #28]
    stackCtrlData->powerMode = powerMode;
   1cdf8:	7743      	strb	r3, [r0, #29]
    pEntry = TCPIP_STACK_MODULE_ENTRY_TBL + sizeof(TCPIP_STACK_MODULE_ENTRY_TBL)/sizeof(*TCPIP_STACK_MODULE_ENTRY_TBL);
   1cdfa:	4c13      	ldr	r4, [pc, #76]	; (1ce48 <TCPIP_STACK_BringNetDown+0x60>)
    while (pEntry != TCPIP_STACK_MODULE_ENTRY_TBL);
   1cdfc:	f1a4 0778 	sub.w	r7, r4, #120	; 0x78
        pEntry--;
   1ce00:	3c0c      	subs	r4, #12
        pEntry->deInitFunc(stackCtrlData);
   1ce02:	68a3      	ldr	r3, [r4, #8]
   1ce04:	4628      	mov	r0, r5
   1ce06:	4798      	blx	r3
    while (pEntry != TCPIP_STACK_MODULE_ENTRY_TBL);
   1ce08:	42bc      	cmp	r4, r7
   1ce0a:	d1f9      	bne.n	1ce00 <TCPIP_STACK_BringNetDown+0x18>
    _TCPIPStackModuleRxPurge(TCPIP_MODULE_MANAGER, pNetIf);
   1ce0c:	4631      	mov	r1, r6
   1ce0e:	2001      	movs	r0, #1
   1ce10:	f7fd f9dc 	bl	1a1cc <_TCPIPStackModuleRxPurge>
        if(pNetIf->hIfMac != 0)
   1ce14:	6d30      	ldr	r0, [r6, #80]	; 0x50
   1ce16:	b110      	cbz	r0, 1ce1e <TCPIP_STACK_BringNetDown+0x36>
            (*pNetIf->pMacObj->TCPIP_MAC_Close)(pNetIf->hIfMac);
   1ce18:	6c73      	ldr	r3, [r6, #68]	; 0x44
   1ce1a:	6a1b      	ldr	r3, [r3, #32]
   1ce1c:	4798      	blx	r3
        if(pNetIf->macObjHandle != 0)
   1ce1e:	6cf0      	ldr	r0, [r6, #76]	; 0x4c
   1ce20:	b110      	cbz	r0, 1ce28 <TCPIP_STACK_BringNetDown+0x40>
            (*pNetIf->pMacObj->TCPIP_MAC_Deinitialize)(pNetIf->macObjHandle);
   1ce22:	6c73      	ldr	r3, [r6, #68]	; 0x44
   1ce24:	68db      	ldr	r3, [r3, #12]
   1ce26:	4798      	blx	r3
    pNetIf->hIfMac = 0;
   1ce28:	2300      	movs	r3, #0
   1ce2a:	6533      	str	r3, [r6, #80]	; 0x50
    pNetIf->macObjHandle = 0;
   1ce2c:	64f3      	str	r3, [r6, #76]	; 0x4c
    pNetIf->Flags.bInterfaceEnabled = pNetIf->Flags.bMacInitialize = false;
   1ce2e:	f896 2043 	ldrb.w	r2, [r6, #67]	; 0x43
   1ce32:	f363 1286 	bfi	r2, r3, #6, #1
   1ce36:	f886 2043 	strb.w	r2, [r6, #67]	; 0x43
   1ce3a:	f896 2042 	ldrb.w	r2, [r6, #66]	; 0x42
   1ce3e:	f363 1286 	bfi	r2, r3, #6, #1
   1ce42:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42
}
   1ce46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1ce48:	0001b9c0 	.word	0x0001b9c0

Disassembly of section .text.TCPIP_UDP_SocketInfoGet%521:

0001ce4c <TCPIP_UDP_SocketInfoGet>:
{
   1ce4c:	b538      	push	{r3, r4, r5, lr}
   1ce4e:	460c      	mov	r4, r1
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1ce50:	f005 f97c 	bl	2214c <_UDPSocketDcpt>
    if(pSkt == 0 || pInfo == 0)
   1ce54:	b340      	cbz	r0, 1cea8 <TCPIP_UDP_SocketInfoGet+0x5c>
   1ce56:	4605      	mov	r5, r0
   1ce58:	b344      	cbz	r4, 1ceac <TCPIP_UDP_SocketInfoGet+0x60>
    memset(pInfo, 0, sizeof(*pInfo));
   1ce5a:	2250      	movs	r2, #80	; 0x50
   1ce5c:	2100      	movs	r1, #0
   1ce5e:	4620      	mov	r0, r4
   1ce60:	f007 f81e 	bl	23ea0 <memset>
        if (pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   1ce64:	8fab      	ldrh	r3, [r5, #60]	; 0x3c
   1ce66:	2b01      	cmp	r3, #1
   1ce68:	d013      	beq.n	1ce92 <TCPIP_UDP_SocketInfoGet+0x46>
        pInfo->addressType = IP_ADDRESS_TYPE_ANY;
   1ce6a:	2300      	movs	r3, #0
   1ce6c:	7023      	strb	r3, [r4, #0]
	pInfo->remotePort = pSkt->remotePort;
   1ce6e:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
   1ce70:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
	pInfo->localPort = pSkt->localPort;
   1ce74:	8d6b      	ldrh	r3, [r5, #42]	; 0x2a
   1ce76:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
    pInfo->hNet = pSkt->pSktNet;
   1ce7a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1ce7c:	64a3      	str	r3, [r4, #72]	; 0x48
    pInfo->rxQueueSize = TCPIP_Helper_SingleListCount(&pSkt->rxQueue);
   1ce7e:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   1ce80:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    pInfo->txSize = pSkt->txEnd - pSkt->txStart;
   1ce84:	686b      	ldr	r3, [r5, #4]
   1ce86:	682a      	ldr	r2, [r5, #0]
   1ce88:	1a9b      	subs	r3, r3, r2
   1ce8a:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
	return true;
   1ce8e:	2001      	movs	r0, #1
}
   1ce90:	bd38      	pop	{r3, r4, r5, pc}
            pInfo->remoteIPaddress.v4Add.Val = pSkt->destAddress.Val;
   1ce92:	696b      	ldr	r3, [r5, #20]
   1ce94:	6063      	str	r3, [r4, #4]
            pInfo->localIPaddress.v4Add.Val = pSkt->srcAddress.Val;
   1ce96:	69ab      	ldr	r3, [r5, #24]
   1ce98:	6163      	str	r3, [r4, #20]
            pInfo->sourceIPaddress.v4Add.Val = pSkt->pktSrcAddress.Val;
   1ce9a:	69eb      	ldr	r3, [r5, #28]
   1ce9c:	6263      	str	r3, [r4, #36]	; 0x24
            pInfo->destIPaddress.v4Add.Val = pSkt->pktDestAddress.Val;
   1ce9e:	6a2b      	ldr	r3, [r5, #32]
   1cea0:	6363      	str	r3, [r4, #52]	; 0x34
            pInfo->addressType = IP_ADDRESS_TYPE_IPV4;
   1cea2:	2301      	movs	r3, #1
   1cea4:	7023      	strb	r3, [r4, #0]
            break;
   1cea6:	e7e2      	b.n	1ce6e <TCPIP_UDP_SocketInfoGet+0x22>
        return false;
   1cea8:	2000      	movs	r0, #0
   1ceaa:	e7f1      	b.n	1ce90 <TCPIP_UDP_SocketInfoGet+0x44>
   1ceac:	2000      	movs	r0, #0
   1ceae:	e7ef      	b.n	1ce90 <TCPIP_UDP_SocketInfoGet+0x44>

Disassembly of section .text.xPortPendSVHandler%522:

0001ceb0 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
   1ceb0:	f3ef 8009 	mrs	r0, PSP
   1ceb4:	f3bf 8f6f 	isb	sy
   1ceb8:	4b15      	ldr	r3, [pc, #84]	; (1cf10 <pxCurrentTCBConst>)
   1ceba:	681a      	ldr	r2, [r3, #0]
   1cebc:	f01e 0f10 	tst.w	lr, #16
   1cec0:	bf08      	it	eq
   1cec2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
   1cec6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ceca:	6010      	str	r0, [r2, #0]
   1cecc:	e92d 0009 	stmdb	sp!, {r0, r3}
   1ced0:	f04f 0020 	mov.w	r0, #32
   1ced4:	f380 8811 	msr	BASEPRI, r0
   1ced8:	f3bf 8f4f 	dsb	sy
   1cedc:	f3bf 8f6f 	isb	sy
   1cee0:	f7fc f84a 	bl	18f78 <vTaskSwitchContext>
   1cee4:	f04f 0000 	mov.w	r0, #0
   1cee8:	f380 8811 	msr	BASEPRI, r0
   1ceec:	bc09      	pop	{r0, r3}
   1ceee:	6819      	ldr	r1, [r3, #0]
   1cef0:	6808      	ldr	r0, [r1, #0]
   1cef2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1cef6:	f01e 0f10 	tst.w	lr, #16
   1cefa:	bf08      	it	eq
   1cefc:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
   1cf00:	f380 8809 	msr	PSP, r0
   1cf04:	f3bf 8f6f 	isb	sy
   1cf08:	4770      	bx	lr
   1cf0a:	bf00      	nop
   1cf0c:	f3af 8000 	nop.w

0001cf10 <pxCurrentTCBConst>:
   1cf10:	2000ef00 	.word	0x2000ef00

Disassembly of section .text.vTaskStartScheduler%523:

0001cf14 <vTaskStartScheduler>:
{
   1cf14:	b500      	push	{lr}
   1cf16:	b083      	sub	sp, #12
		xReturn = xTaskCreate(	prvIdleTask,
   1cf18:	4b11      	ldr	r3, [pc, #68]	; (1cf60 <vTaskStartScheduler+0x4c>)
   1cf1a:	9301      	str	r3, [sp, #4]
   1cf1c:	2300      	movs	r3, #0
   1cf1e:	9300      	str	r3, [sp, #0]
   1cf20:	2280      	movs	r2, #128	; 0x80
   1cf22:	4910      	ldr	r1, [pc, #64]	; (1cf64 <vTaskStartScheduler+0x50>)
   1cf24:	4810      	ldr	r0, [pc, #64]	; (1cf68 <vTaskStartScheduler+0x54>)
   1cf26:	f7f3 fd09 	bl	1093c <xTaskCreate>
	if( xReturn == pdPASS )
   1cf2a:	2801      	cmp	r0, #1
   1cf2c:	d002      	beq.n	1cf34 <vTaskStartScheduler+0x20>
}
   1cf2e:	b003      	add	sp, #12
   1cf30:	f85d fb04 	ldr.w	pc, [sp], #4

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   1cf34:	f04f 0320 	mov.w	r3, #32
   1cf38:	f383 8811 	msr	BASEPRI, r3
   1cf3c:	f3bf 8f6f 	isb	sy
   1cf40:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
   1cf44:	4b09      	ldr	r3, [pc, #36]	; (1cf6c <vTaskStartScheduler+0x58>)
   1cf46:	f04f 32ff 	mov.w	r2, #4294967295
   1cf4a:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
   1cf4c:	4b08      	ldr	r3, [pc, #32]	; (1cf70 <vTaskStartScheduler+0x5c>)
   1cf4e:	2201      	movs	r2, #1
   1cf50:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
   1cf52:	4b08      	ldr	r3, [pc, #32]	; (1cf74 <vTaskStartScheduler+0x60>)
   1cf54:	2200      	movs	r2, #0
   1cf56:	601a      	str	r2, [r3, #0]
		if( xPortStartScheduler() != pdFALSE )
   1cf58:	f001 ffb2 	bl	1eec0 <xPortStartScheduler>
}
   1cf5c:	e7e7      	b.n	1cf2e <vTaskStartScheduler+0x1a>
   1cf5e:	bf00      	nop
   1cf60:	2000ef20 	.word	0x2000ef20
   1cf64:	00024438 	.word	0x00024438
   1cf68:	0001c339 	.word	0x0001c339
   1cf6c:	2000ef24 	.word	0x2000ef24
   1cf70:	2000ef30 	.word	0x2000ef30
   1cf74:	2000ef34 	.word	0x2000ef34

Disassembly of section .text.wc_InitSha256_ex%524:

0001cf78 <wc_InitSha256_ex>:
        if (sha256 == NULL)
   1cf78:	4603      	mov	r3, r0
   1cf7a:	b1e8      	cbz	r0, 1cfb8 <wc_InitSha256_ex+0x40>
        sha256->heap = heap;
   1cf7c:	66c1      	str	r1, [r0, #108]	; 0x6c
        sha256->devId = devId;
   1cf7e:	6702      	str	r2, [r0, #112]	; 0x70
        sha256->devCtx = NULL;
   1cf80:	2000      	movs	r0, #0
   1cf82:	6758      	str	r0, [r3, #116]	; 0x74
    sha256->digest[0] = 0x6A09E667L;
   1cf84:	4a0e      	ldr	r2, [pc, #56]	; (1cfc0 <wc_InitSha256_ex+0x48>)
   1cf86:	601a      	str	r2, [r3, #0]
    sha256->digest[1] = 0xBB67AE85L;
   1cf88:	4a0e      	ldr	r2, [pc, #56]	; (1cfc4 <wc_InitSha256_ex+0x4c>)
   1cf8a:	605a      	str	r2, [r3, #4]
    sha256->digest[2] = 0x3C6EF372L;
   1cf8c:	4a0e      	ldr	r2, [pc, #56]	; (1cfc8 <wc_InitSha256_ex+0x50>)
   1cf8e:	609a      	str	r2, [r3, #8]
    sha256->digest[3] = 0xA54FF53AL;
   1cf90:	4a0e      	ldr	r2, [pc, #56]	; (1cfcc <wc_InitSha256_ex+0x54>)
   1cf92:	60da      	str	r2, [r3, #12]
    sha256->digest[4] = 0x510E527FL;
   1cf94:	4a0e      	ldr	r2, [pc, #56]	; (1cfd0 <wc_InitSha256_ex+0x58>)
   1cf96:	611a      	str	r2, [r3, #16]
    sha256->digest[5] = 0x9B05688CL;
   1cf98:	4a0e      	ldr	r2, [pc, #56]	; (1cfd4 <wc_InitSha256_ex+0x5c>)
   1cf9a:	615a      	str	r2, [r3, #20]
    sha256->digest[6] = 0x1F83D9ABL;
   1cf9c:	4a0e      	ldr	r2, [pc, #56]	; (1cfd8 <wc_InitSha256_ex+0x60>)
   1cf9e:	619a      	str	r2, [r3, #24]
    sha256->digest[7] = 0x5BE0CD19L;
   1cfa0:	f102 5274 	add.w	r2, r2, #1023410176	; 0x3d000000
   1cfa4:	f5a2 0223 	sub.w	r2, r2, #10682368	; 0xa30000
   1cfa8:	f6a2 4292 	subw	r2, r2, #3218	; 0xc92
   1cfac:	61da      	str	r2, [r3, #28]
    sha256->buffLen = 0;
   1cfae:	6618      	str	r0, [r3, #96]	; 0x60
    sha256->loLen   = 0;
   1cfb0:	6658      	str	r0, [r3, #100]	; 0x64
    sha256->hiLen   = 0;
   1cfb2:	6698      	str	r0, [r3, #104]	; 0x68
    sha256->flags = 0;
   1cfb4:	6798      	str	r0, [r3, #120]	; 0x78
        if (ret != 0)
   1cfb6:	4770      	bx	lr
            return BAD_FUNC_ARG;
   1cfb8:	f06f 00ac 	mvn.w	r0, #172	; 0xac
    }
   1cfbc:	4770      	bx	lr
   1cfbe:	bf00      	nop
   1cfc0:	6a09e667 	.word	0x6a09e667
   1cfc4:	bb67ae85 	.word	0xbb67ae85
   1cfc8:	3c6ef372 	.word	0x3c6ef372
   1cfcc:	a54ff53a 	.word	0xa54ff53a
   1cfd0:	510e527f 	.word	0x510e527f
   1cfd4:	9b05688c 	.word	0x9b05688c
   1cfd8:	1f83d9ab 	.word	0x1f83d9ab

Disassembly of section .text.TCPIP_ARP_EntryGet%525:

0001cfdc <TCPIP_ARP_EntryGet>:
    if(ipAdd == 0 || ipAdd->Val == 0)
   1cfdc:	b319      	cbz	r1, 1d026 <TCPIP_ARP_EntryGet+0x4a>
{   
   1cfde:	b510      	push	{r4, lr}
   1cfe0:	b082      	sub	sp, #8
   1cfe2:	460c      	mov	r4, r1
    if(ipAdd == 0 || ipAdd->Val == 0)
   1cfe4:	6809      	ldr	r1, [r1, #0]
   1cfe6:	b309      	cbz	r1, 1d02c <TCPIP_ARP_EntryGet+0x50>
   1cfe8:	b318      	cbz	r0, 1d032 <TCPIP_ARP_EntryGet+0x56>
   1cfea:	f890 1042 	ldrb.w	r1, [r0, #66]	; 0x42
   1cfee:	f011 0f40 	tst.w	r1, #64	; 0x40
   1cff2:	d103      	bne.n	1cffc <TCPIP_ARP_EntryGet+0x20>
        return ARP_RES_NO_INTERFACE;
   1cff4:	f06f 0005 	mvn.w	r0, #5
}
   1cff8:	b002      	add	sp, #8
   1cffa:	bd10      	pop	{r4, pc}
   1cffc:	4621      	mov	r1, r4
    if(probe)
   1cffe:	b153      	cbz	r3, 1d016 <TCPIP_ARP_EntryGet+0x3a>
    return pNetIf->Flags.bInConfig != 0;
   1d000:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
        if(_TCPIPStackIsConfig(pIf))
   1d004:	f013 0f10 	tst.w	r3, #16
   1d008:	d116      	bne.n	1d038 <TCPIP_ARP_EntryGet+0x5c>
        return _ARPProbeAddress(pIf, ipAdd, &pIf->netIPAddr, ARP_OPERATION_REQ, pHwAdd);
   1d00a:	9200      	str	r2, [sp, #0]
   1d00c:	2301      	movs	r3, #1
   1d00e:	1d02      	adds	r2, r0, #4
   1d010:	f7f9 f972 	bl	162f8 <_ARPProbeAddress>
   1d014:	e7f0      	b.n	1cff8 <TCPIP_ARP_EntryGet+0x1c>
        return (TCPIP_ARP_IsResolved(pIf, ipAdd, pHwAdd))? ARP_RES_ENTRY_SOLVED : ARP_RES_NO_ENTRY;
   1d016:	f7fc ffb5 	bl	19f84 <TCPIP_ARP_IsResolved>
   1d01a:	2800      	cmp	r0, #0
   1d01c:	bf14      	ite	ne
   1d01e:	2002      	movne	r0, #2
   1d020:	f04f 30ff 	moveq.w	r0, #4294967295
   1d024:	e7e8      	b.n	1cff8 <TCPIP_ARP_EntryGet+0x1c>
        return ARP_RES_BAD_ADDRESS;
   1d026:	f06f 0004 	mvn.w	r0, #4
}
   1d02a:	4770      	bx	lr
        return ARP_RES_BAD_ADDRESS;
   1d02c:	f06f 0004 	mvn.w	r0, #4
   1d030:	e7e2      	b.n	1cff8 <TCPIP_ARP_EntryGet+0x1c>
        return ARP_RES_NO_INTERFACE;
   1d032:	f06f 0005 	mvn.w	r0, #5
   1d036:	e7df      	b.n	1cff8 <TCPIP_ARP_EntryGet+0x1c>
            return ARP_RES_CONFIGURE_ERR;
   1d038:	f06f 0007 	mvn.w	r0, #7
   1d03c:	e7dc      	b.n	1cff8 <TCPIP_ARP_EntryGet+0x1c>

Disassembly of section .text._PingStop%526:

0001d040 <_PingStop>:
{
   1d040:	b538      	push	{r3, r4, r5, lr}
   1d042:	4604      	mov	r4, r0
   1d044:	460d      	mov	r5, r1
    if(icmpReqHandle != 0)
   1d046:	4b0f      	ldr	r3, [pc, #60]	; (1d084 <_PingStop+0x44>)
   1d048:	6818      	ldr	r0, [r3, #0]
   1d04a:	b120      	cbz	r0, 1d056 <_PingStop+0x16>
        TCPIP_ICMP_EchoRequestCancel(icmpReqHandle);
   1d04c:	f005 fa8c 	bl	22568 <TCPIP_ICMP_EchoRequestCancel>
        icmpReqHandle = 0;
   1d050:	4b0c      	ldr	r3, [pc, #48]	; (1d084 <_PingStop+0x44>)
   1d052:	2200      	movs	r2, #0
   1d054:	601a      	str	r2, [r3, #0]
    _TCPIPStackSignalHandlerSetParams(TCPIP_THIS_MODULE_ID, tcpipCmdSignalHandle, 0);
   1d056:	2200      	movs	r2, #0
   1d058:	4b0b      	ldr	r3, [pc, #44]	; (1d088 <_PingStop+0x48>)
   1d05a:	6819      	ldr	r1, [r3, #0]
   1d05c:	201f      	movs	r0, #31
   1d05e:	f005 f861 	bl	22124 <_TCPIPStackSignalHandlerSetParams>
    tcpipCmdStat = TCPIP_CMD_STAT_IDLE;
   1d062:	4b0a      	ldr	r3, [pc, #40]	; (1d08c <_PingStop+0x4c>)
   1d064:	2200      	movs	r2, #0
   1d066:	701a      	strb	r2, [r3, #0]
    if(pCmdIO)
   1d068:	b144      	cbz	r4, 1d07c <_PingStop+0x3c>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Ping: done. Sent %d requests, received %d replies.\r\n", icmpReqCount, icmpAckRecv);
   1d06a:	6823      	ldr	r3, [r4, #0]
   1d06c:	685c      	ldr	r4, [r3, #4]
   1d06e:	4b08      	ldr	r3, [pc, #32]	; (1d090 <_PingStop+0x50>)
   1d070:	681b      	ldr	r3, [r3, #0]
   1d072:	4a08      	ldr	r2, [pc, #32]	; (1d094 <_PingStop+0x54>)
   1d074:	6812      	ldr	r2, [r2, #0]
   1d076:	4908      	ldr	r1, [pc, #32]	; (1d098 <_PingStop+0x58>)
   1d078:	4628      	mov	r0, r5
   1d07a:	47a0      	blx	r4
    pTcpipCmdDevice = 0;
   1d07c:	4b07      	ldr	r3, [pc, #28]	; (1d09c <_PingStop+0x5c>)
   1d07e:	2200      	movs	r2, #0
   1d080:	601a      	str	r2, [r3, #0]
}
   1d082:	bd38      	pop	{r3, r4, r5, pc}
   1d084:	2000edfc 	.word	0x2000edfc
   1d088:	2000ee18 	.word	0x2000ee18
   1d08c:	2000ebc3 	.word	0x2000ebc3
   1d090:	2000ede8 	.word	0x2000ede8
   1d094:	2000edf4 	.word	0x2000edf4
   1d098:	000009e8 	.word	0x000009e8
   1d09c:	2000ee14 	.word	0x2000ee14

Disassembly of section .text.Ipv4FilterSetActive%527:

0001d0a0 <Ipv4FilterSetActive>:
{
   1d0a0:	b570      	push	{r4, r5, r6, lr}
   1d0a2:	4604      	mov	r4, r0
   1d0a4:	460e      	mov	r6, r1
    TCPIP_Helper_ProtectedSingleListLock(notifyList);
   1d0a6:	4d14      	ldr	r5, [pc, #80]	; (1d0f8 <Ipv4FilterSetActive+0x58>)
   1d0a8:	4628      	mov	r0, r5
   1d0aa:	f005 fd99 	bl	22be0 <TCPIP_Helper_ProtectedSingleListLock>
    for(fNode = (IPV4_FILTER_LIST_NODE*)ipv4PacketFilters.list.head; fNode != 0; fNode = fNode->next)
   1d0ae:	682b      	ldr	r3, [r5, #0]
   1d0b0:	b1eb      	cbz	r3, 1d0ee <Ipv4FilterSetActive+0x4e>
        if(fNode == (IPV4_FILTER_LIST_NODE*)hFilter)
   1d0b2:	42a3      	cmp	r3, r4
   1d0b4:	d00e      	beq.n	1d0d4 <Ipv4FilterSetActive+0x34>
    for(fNode = (IPV4_FILTER_LIST_NODE*)ipv4PacketFilters.list.head; fNode != 0; fNode = fNode->next)
   1d0b6:	681b      	ldr	r3, [r3, #0]
   1d0b8:	b19b      	cbz	r3, 1d0e2 <Ipv4FilterSetActive+0x42>
        if(fNode == (IPV4_FILTER_LIST_NODE*)hFilter)
   1d0ba:	429c      	cmp	r4, r3
   1d0bc:	d1fb      	bne.n	1d0b6 <Ipv4FilterSetActive+0x16>
            if(fNode->active != active)
   1d0be:	7a1a      	ldrb	r2, [r3, #8]
   1d0c0:	42b2      	cmp	r2, r6
   1d0c2:	d016      	beq.n	1d0f2 <Ipv4FilterSetActive+0x52>
                if(active)
   1d0c4:	b146      	cbz	r6, 1d0d8 <Ipv4FilterSetActive+0x38>
                    ipv4ActFilterCount++;
   1d0c6:	490d      	ldr	r1, [pc, #52]	; (1d0fc <Ipv4FilterSetActive+0x5c>)
   1d0c8:	680a      	ldr	r2, [r1, #0]
   1d0ca:	3201      	adds	r2, #1
   1d0cc:	600a      	str	r2, [r1, #0]
                fNode->active = active;
   1d0ce:	721e      	strb	r6, [r3, #8]
                activeOk = true;
   1d0d0:	2401      	movs	r4, #1
   1d0d2:	e007      	b.n	1d0e4 <Ipv4FilterSetActive+0x44>
    for(fNode = (IPV4_FILTER_LIST_NODE*)ipv4PacketFilters.list.head; fNode != 0; fNode = fNode->next)
   1d0d4:	4623      	mov	r3, r4
   1d0d6:	e7f2      	b.n	1d0be <Ipv4FilterSetActive+0x1e>
                    ipv4ActFilterCount--;
   1d0d8:	4908      	ldr	r1, [pc, #32]	; (1d0fc <Ipv4FilterSetActive+0x5c>)
   1d0da:	680a      	ldr	r2, [r1, #0]
   1d0dc:	3a01      	subs	r2, #1
   1d0de:	600a      	str	r2, [r1, #0]
   1d0e0:	e7f5      	b.n	1d0ce <Ipv4FilterSetActive+0x2e>
    bool activeOk = false;
   1d0e2:	2400      	movs	r4, #0
    TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
   1d0e4:	4804      	ldr	r0, [pc, #16]	; (1d0f8 <Ipv4FilterSetActive+0x58>)
   1d0e6:	f005 ffcd 	bl	23084 <TCPIP_Helper_ProtectedSingleListUnlock>
}
   1d0ea:	4620      	mov	r0, r4
   1d0ec:	bd70      	pop	{r4, r5, r6, pc}
    bool activeOk = false;
   1d0ee:	2400      	movs	r4, #0
   1d0f0:	e7f8      	b.n	1d0e4 <Ipv4FilterSetActive+0x44>
   1d0f2:	2400      	movs	r4, #0
   1d0f4:	e7f6      	b.n	1d0e4 <Ipv4FilterSetActive+0x44>
   1d0f6:	bf00      	nop
   1d0f8:	2000ec50 	.word	0x2000ec50
   1d0fc:	2000ee28 	.word	0x2000ee28

Disassembly of section .text._DHCPOptionProcessDns%528:

0001d100 <_DHCPOptionProcessDns>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_DNS1))
   1d100:	684b      	ldr	r3, [r1, #4]
   1d102:	2b05      	cmp	r3, #5
   1d104:	d923      	bls.n	1d14e <_DHCPOptionProcessDns+0x4e>
        TCPIP_DHCP_OPTION_DATA_DNS* pDns = (TCPIP_DHCP_OPTION_DATA_DNS*)pOptData->pOpt;
   1d106:	680b      	ldr	r3, [r1, #0]
        if((pDns->len & 0x3) == 0 && pDns->len >= sizeof(pDns->dns1))
   1d108:	785a      	ldrb	r2, [r3, #1]
   1d10a:	f012 0f03 	tst.w	r2, #3
   1d10e:	d121      	bne.n	1d154 <_DHCPOptionProcessDns+0x54>
   1d110:	2a03      	cmp	r2, #3
   1d112:	d922      	bls.n	1d15a <_DHCPOptionProcessDns+0x5a>
            if(pClient->flags.bOfferReceived == 0)
   1d114:	f890 2058 	ldrb.w	r2, [r0, #88]	; 0x58
   1d118:	f012 0f04 	tst.w	r2, #4
   1d11c:	d114      	bne.n	1d148 <_DHCPOptionProcessDns+0x48>
                memcpy(&pClient->dhcpDNS, pDns->dns1, sizeof(pClient->dhcpDNS)); 
   1d11e:	f8d3 2002 	ldr.w	r2, [r3, #2]
   1d122:	6382      	str	r2, [r0, #56]	; 0x38
                pClient->validValues.DNS = 1;
   1d124:	f890 2059 	ldrb.w	r2, [r0, #89]	; 0x59
   1d128:	f042 0208 	orr.w	r2, r2, #8
   1d12c:	f880 2059 	strb.w	r2, [r0, #89]	; 0x59
                if(pDns->len >= sizeof(pDns->dns1) + sizeof(pDns->dns2))
   1d130:	785a      	ldrb	r2, [r3, #1]
   1d132:	2a07      	cmp	r2, #7
   1d134:	d908      	bls.n	1d148 <_DHCPOptionProcessDns+0x48>
                    memcpy(&pClient->dhcpDNS2, pDns->dns2, sizeof(pClient->dhcpDNS2)); 
   1d136:	f8d3 2006 	ldr.w	r2, [r3, #6]
   1d13a:	63c2      	str	r2, [r0, #60]	; 0x3c
                    pClient->validValues.DNS2 = 1;
   1d13c:	f890 2059 	ldrb.w	r2, [r0, #89]	; 0x59
   1d140:	f042 0210 	orr.w	r2, r2, #16
   1d144:	f880 2059 	strb.w	r2, [r0, #89]	; 0x59
            return 2 + pDns->len;
   1d148:	7858      	ldrb	r0, [r3, #1]
   1d14a:	3002      	adds	r0, #2
   1d14c:	4770      	bx	lr
    return -1;
   1d14e:	f04f 30ff 	mov.w	r0, #4294967295
   1d152:	4770      	bx	lr
   1d154:	f04f 30ff 	mov.w	r0, #4294967295
   1d158:	4770      	bx	lr
   1d15a:	f04f 30ff 	mov.w	r0, #4294967295
}
   1d15e:	4770      	bx	lr

Disassembly of section .text.TCPIP_DHCP_Disable%529:

0001d160 <TCPIP_DHCP_Disable>:
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   1d160:	b1c0      	cbz	r0, 1d194 <TCPIP_DHCP_Disable+0x34>
{
   1d162:	b538      	push	{r3, r4, r5, lr}
   1d164:	4604      	mov	r4, r0
   1d166:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1d16a:	f012 0f40 	tst.w	r2, #64	; 0x40
   1d16e:	d113      	bne.n	1d198 <TCPIP_DHCP_Disable+0x38>
    return false;
   1d170:	2000      	movs	r0, #0
}
   1d172:	bd38      	pop	{r3, r4, r5, pc}
            _DHCPClientClose(pNetIf, true, true);
   1d174:	2201      	movs	r2, #1
   1d176:	4611      	mov	r1, r2
   1d178:	4620      	mov	r0, r4
   1d17a:	f7fd f98f 	bl	1a49c <_DHCPClientClose>
            TCPIP_STACK_AddressServiceEvent(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_DHCPC, TCPIP_STACK_ADDRESS_SERVICE_EVENT_USER_STOP);
   1d17e:	2203      	movs	r2, #3
   1d180:	2101      	movs	r1, #1
   1d182:	4620      	mov	r0, r4
   1d184:	f002 f958 	bl	1f438 <TCPIP_STACK_AddressServiceEvent>
            _DHCPNotifyClients(pNetIf, DHCP_EVENT_SERVICE_DISABLED);
   1d188:	210d      	movs	r1, #13
   1d18a:	4620      	mov	r0, r4
   1d18c:	f002 ff5a 	bl	20044 <_DHCPNotifyClients>
        return true;
   1d190:	2001      	movs	r0, #1
   1d192:	e7ee      	b.n	1d172 <TCPIP_DHCP_Disable+0x12>
    return false;
   1d194:	2000      	movs	r0, #0
}
   1d196:	4770      	bx	lr
    if(DHCPClients && pNetIf)
   1d198:	4a08      	ldr	r2, [pc, #32]	; (1d1bc <TCPIP_DHCP_Disable+0x5c>)
   1d19a:	6815      	ldr	r5, [r2, #0]
   1d19c:	b165      	cbz	r5, 1d1b8 <TCPIP_DHCP_Disable+0x58>
        DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   1d19e:	4620      	mov	r0, r4
   1d1a0:	f006 feca 	bl	23f38 <TCPIP_STACK_NetIxGet>
        if(pClient->flags.bDHCPEnabled != 0)
   1d1a4:	235c      	movs	r3, #92	; 0x5c
   1d1a6:	fb03 5000 	mla	r0, r3, r0, r5
   1d1aa:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   1d1ae:	f013 0f01 	tst.w	r3, #1
   1d1b2:	d1df      	bne.n	1d174 <TCPIP_DHCP_Disable+0x14>
        return true;
   1d1b4:	2001      	movs	r0, #1
   1d1b6:	e7dc      	b.n	1d172 <TCPIP_DHCP_Disable+0x12>
    return false;
   1d1b8:	2000      	movs	r0, #0
   1d1ba:	e7da      	b.n	1d172 <TCPIP_DHCP_Disable+0x12>
   1d1bc:	2000ee3c 	.word	0x2000ee3c

Disassembly of section .text.TCPIP_DNS_ClientDeinitialize%530:

0001d1c0 <TCPIP_DNS_ClientDeinitialize>:
    if(dnsInitCount > 0)
   1d1c0:	4b15      	ldr	r3, [pc, #84]	; (1d218 <TCPIP_DNS_ClientDeinitialize+0x58>)
   1d1c2:	681b      	ldr	r3, [r3, #0]
   1d1c4:	2b00      	cmp	r3, #0
   1d1c6:	dc00      	bgt.n	1d1ca <TCPIP_DNS_ClientDeinitialize+0xa>
   1d1c8:	4770      	bx	lr
{
   1d1ca:	b530      	push	{r4, r5, lr}
   1d1cc:	b095      	sub	sp, #84	; 0x54
   1d1ce:	4604      	mov	r4, r0
        TCPIP_DNS_DCPT* pDnsDcpt = pgDnsDcpt;
   1d1d0:	4b12      	ldr	r3, [pc, #72]	; (1d21c <TCPIP_DNS_ClientDeinitialize+0x5c>)
   1d1d2:	681d      	ldr	r5, [r3, #0]
        if(TCPIP_UDP_SocketInfoGet(pDnsDcpt->dnsSocket, &sktInfo))
   1d1d4:	4669      	mov	r1, sp
   1d1d6:	f9b5 0024 	ldrsh.w	r0, [r5, #36]	; 0x24
   1d1da:	f7ff fe37 	bl	1ce4c <TCPIP_UDP_SocketInfoGet>
   1d1de:	b118      	cbz	r0, 1d1e8 <TCPIP_DNS_ClientDeinitialize+0x28>
            if(sktInfo.hNet == stackData->pNetIf)
   1d1e0:	6963      	ldr	r3, [r4, #20]
   1d1e2:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1d1e4:	429a      	cmp	r2, r3
   1d1e6:	d004      	beq.n	1d1f2 <TCPIP_DNS_ClientDeinitialize+0x32>
        if(stackData->stackAction == TCPIP_STACK_ACTION_DEINIT)
   1d1e8:	7f23      	ldrb	r3, [r4, #28]
   1d1ea:	2b02      	cmp	r3, #2
   1d1ec:	d007      	beq.n	1d1fe <TCPIP_DNS_ClientDeinitialize+0x3e>
}
   1d1ee:	b015      	add	sp, #84	; 0x54
   1d1f0:	bd30      	pop	{r4, r5, pc}
                TCPIP_UDP_Disconnect(pDnsDcpt->dnsSocket, true);
   1d1f2:	2101      	movs	r1, #1
   1d1f4:	f9b5 0024 	ldrsh.w	r0, [r5, #36]	; 0x24
   1d1f8:	f7fc f9a0 	bl	1953c <TCPIP_UDP_Disconnect>
   1d1fc:	e7f4      	b.n	1d1e8 <TCPIP_DNS_ClientDeinitialize+0x28>
            if(--dnsInitCount == 0)
   1d1fe:	4a06      	ldr	r2, [pc, #24]	; (1d218 <TCPIP_DNS_ClientDeinitialize+0x58>)
   1d200:	6813      	ldr	r3, [r2, #0]
   1d202:	3b01      	subs	r3, #1
   1d204:	6013      	str	r3, [r2, #0]
   1d206:	2b00      	cmp	r3, #0
   1d208:	d1f1      	bne.n	1d1ee <TCPIP_DNS_ClientDeinitialize+0x2e>
                _DNSClientCleanup(pDnsDcpt);
   1d20a:	4628      	mov	r0, r5
   1d20c:	f004 fae4 	bl	217d8 <_DNSClientCleanup>
                pgDnsDcpt = 0;
   1d210:	4b02      	ldr	r3, [pc, #8]	; (1d21c <TCPIP_DNS_ClientDeinitialize+0x5c>)
   1d212:	2200      	movs	r2, #0
   1d214:	601a      	str	r2, [r3, #0]
}
   1d216:	e7ea      	b.n	1d1ee <TCPIP_DNS_ClientDeinitialize+0x2e>
   1d218:	2000ee54 	.word	0x2000ee54
   1d21c:	2000ee58 	.word	0x2000ee58

Disassembly of section .text.TCPIP_DNS_GetIPAddressesNumber%531:

0001d220 <TCPIP_DNS_GetIPAddressesNumber>:
    pDnsDcpt = pgDnsDcpt;
   1d220:	4b16      	ldr	r3, [pc, #88]	; (1d27c <TCPIP_DNS_GetIPAddressesNumber+0x5c>)
   1d222:	681b      	ldr	r3, [r3, #0]
    if(pDnsDcpt == 0 || hostName == 0)
   1d224:	b313      	cbz	r3, 1d26c <TCPIP_DNS_GetIPAddressesNumber+0x4c>
{
   1d226:	b510      	push	{r4, lr}
   1d228:	460c      	mov	r4, r1
    if(pDnsDcpt == 0 || hostName == 0)
   1d22a:	b308      	cbz	r0, 1d270 <TCPIP_DNS_GetIPAddressesNumber+0x50>
    if(type == IP_ADDRESS_TYPE_IPV4)
   1d22c:	2901      	cmp	r1, #1
   1d22e:	d003      	beq.n	1d238 <TCPIP_DNS_GetIPAddressesNumber+0x18>
        recMask = TCPIP_DNS_ADDRESS_REC_IPV4 | TCPIP_DNS_ADDRESS_REC_IPV6;
   1d230:	2902      	cmp	r1, #2
   1d232:	bf0c      	ite	eq
   1d234:	460c      	moveq	r4, r1
   1d236:	2403      	movne	r4, #3
    hE = TCPIP_OAHASH_EntryLookup(pDnsDcpt->hashDcpt, hostName);
   1d238:	4601      	mov	r1, r0
   1d23a:	6818      	ldr	r0, [r3, #0]
   1d23c:	f7ff fba2 	bl	1c984 <TCPIP_OAHASH_EntryLookup>
    if(hE != 0)
   1d240:	4603      	mov	r3, r0
   1d242:	b1b8      	cbz	r0, 1d274 <TCPIP_DNS_GetIPAddressesNumber+0x54>
        if(hE->flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE)
   1d244:	8802      	ldrh	r2, [r0, #0]
   1d246:	f012 0f80 	tst.w	r2, #128	; 0x80
   1d24a:	d015      	beq.n	1d278 <TCPIP_DNS_GetIPAddressesNumber+0x58>
            if(((dnsHashEntry->recordMask & recMask) & TCPIP_DNS_ADDRESS_REC_IPV4) != 0)
   1d24c:	f890 202a 	ldrb.w	r2, [r0, #42]	; 0x2a
   1d250:	4014      	ands	r4, r2
   1d252:	f014 0f01 	tst.w	r4, #1
                nAddresses += dnsHashEntry->nIPv4Entries;
   1d256:	bf14      	ite	ne
   1d258:	f890 0026 	ldrbne.w	r0, [r0, #38]	; 0x26
    nAddresses = 0;
   1d25c:	2000      	moveq	r0, #0
            if(((dnsHashEntry->recordMask & recMask) & TCPIP_DNS_ADDRESS_REC_IPV6) != 0)
   1d25e:	f014 0f02 	tst.w	r4, #2
   1d262:	d00a      	beq.n	1d27a <TCPIP_DNS_GetIPAddressesNumber+0x5a>
                 nAddresses += dnsHashEntry->nIPv6Entries;
   1d264:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
   1d268:	4418      	add	r0, r3
   1d26a:	e006      	b.n	1d27a <TCPIP_DNS_GetIPAddressesNumber+0x5a>
        return 0;
   1d26c:	2000      	movs	r0, #0
}
   1d26e:	4770      	bx	lr
        return 0;
   1d270:	2000      	movs	r0, #0
   1d272:	e002      	b.n	1d27a <TCPIP_DNS_GetIPAddressesNumber+0x5a>
    nAddresses = 0;
   1d274:	2000      	movs	r0, #0
   1d276:	e000      	b.n	1d27a <TCPIP_DNS_GetIPAddressesNumber+0x5a>
   1d278:	2000      	movs	r0, #0
}
   1d27a:	bd10      	pop	{r4, pc}
   1d27c:	2000ee58 	.word	0x2000ee58

Disassembly of section .text._TCPIP_SelectDefaultNet%532:

0001d280 <_TCPIP_SelectDefaultNet>:
    if(tcpipDefIf.defaultNet == 0)
   1d280:	4b14      	ldr	r3, [pc, #80]	; (1d2d4 <_TCPIP_SelectDefaultNet+0x54>)
   1d282:	681b      	ldr	r3, [r3, #0]
   1d284:	b12b      	cbz	r3, 1d292 <_TCPIP_SelectDefaultNet+0x12>
    else if(tcpipDefIf.defaultNet == pDownIf)
   1d286:	4283      	cmp	r3, r0
   1d288:	d000      	beq.n	1d28c <_TCPIP_SelectDefaultNet+0xc>
}
   1d28a:	4770      	bx	lr
        tcpipDefIf.defaultNet = 0;
   1d28c:	4b11      	ldr	r3, [pc, #68]	; (1d2d4 <_TCPIP_SelectDefaultNet+0x54>)
   1d28e:	2200      	movs	r2, #0
   1d290:	601a      	str	r2, [r3, #0]
        for(netIx = 0, pIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1d292:	4b11      	ldr	r3, [pc, #68]	; (1d2d8 <_TCPIP_SelectDefaultNet+0x58>)
   1d294:	681b      	ldr	r3, [r3, #0]
   1d296:	4a11      	ldr	r2, [pc, #68]	; (1d2dc <_TCPIP_SelectDefaultNet+0x5c>)
   1d298:	6810      	ldr	r0, [r2, #0]
   1d29a:	2800      	cmp	r0, #0
        pNewIf = 0;
   1d29c:	bfd8      	it	le
   1d29e:	2300      	movle	r3, #0
        for(netIx = 0, pIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1d2a0:	dd14      	ble.n	1d2cc <_TCPIP_SelectDefaultNet+0x4c>
            if(pIf->Flags.bInterfaceEnabled)
   1d2a2:	f893 2042 	ldrb.w	r2, [r3, #66]	; 0x42
   1d2a6:	f012 0f40 	tst.w	r2, #64	; 0x40
   1d2aa:	d10b      	bne.n	1d2c4 <_TCPIP_SelectDefaultNet+0x44>
        for(netIx = 0, pIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1d2ac:	2200      	movs	r2, #0
   1d2ae:	3201      	adds	r2, #1
   1d2b0:	336c      	adds	r3, #108	; 0x6c
   1d2b2:	4282      	cmp	r2, r0
   1d2b4:	d005      	beq.n	1d2c2 <_TCPIP_SelectDefaultNet+0x42>
            if(pIf->Flags.bInterfaceEnabled)
   1d2b6:	f893 1042 	ldrb.w	r1, [r3, #66]	; 0x42
   1d2ba:	f011 0f40 	tst.w	r1, #64	; 0x40
   1d2be:	d0f6      	beq.n	1d2ae <_TCPIP_SelectDefaultNet+0x2e>
   1d2c0:	e000      	b.n	1d2c4 <_TCPIP_SelectDefaultNet+0x44>
        pNewIf = 0;
   1d2c2:	2300      	movs	r3, #0
        if(tcpipDefIf.defaultNet == 0)
   1d2c4:	4a03      	ldr	r2, [pc, #12]	; (1d2d4 <_TCPIP_SelectDefaultNet+0x54>)
   1d2c6:	6812      	ldr	r2, [r2, #0]
   1d2c8:	2a00      	cmp	r2, #0
   1d2ca:	d1de      	bne.n	1d28a <_TCPIP_SelectDefaultNet+0xa>
            tcpipDefIf.defaultNet = pNewIf;
   1d2cc:	4a01      	ldr	r2, [pc, #4]	; (1d2d4 <_TCPIP_SelectDefaultNet+0x54>)
   1d2ce:	6013      	str	r3, [r2, #0]
}
   1d2d0:	4770      	bx	lr
   1d2d2:	bf00      	nop
   1d2d4:	2000ee70 	.word	0x2000ee70
   1d2d8:	2000ee74 	.word	0x2000ee74
   1d2dc:	2000eae4 	.word	0x2000eae4

Disassembly of section .text._DHCPSAddCompleteEntry%533:

0001d2e0 <_DHCPSAddCompleteEntry>:
{
   1d2e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d2e4:	4680      	mov	r8, r0
   1d2e6:	460e      	mov	r6, r1
   1d2e8:	4615      	mov	r5, r2
   1d2ea:	461f      	mov	r7, r3
    hE = TCPIP_OAHASH_EntryLookupOrInsert(pdhcpsDcpt->hashDcpt, hwAdd);
   1d2ec:	4611      	mov	r1, r2
   1d2ee:	4b13      	ldr	r3, [pc, #76]	; (1d33c <_DHCPSAddCompleteEntry+0x5c>)
   1d2f0:	6818      	ldr	r0, [r3, #0]
   1d2f2:	f7ff fd47 	bl	1cd84 <TCPIP_OAHASH_EntryLookupOrInsert>
    if(hE == 0)
   1d2f6:	b1f8      	cbz	r0, 1d338 <_DHCPSAddCompleteEntry+0x58>
   1d2f8:	4604      	mov	r4, r0
    if(dhcpsHE->hEntry.flags.newEntry != 0)
   1d2fa:	7803      	ldrb	r3, [r0, #0]
   1d2fc:	f013 0f02 	tst.w	r3, #2
   1d300:	d016      	beq.n	1d330 <_DHCPSAddCompleteEntry+0x50>
    	dhcpsHE->intfIdx = intfIdx;
   1d302:	f8c0 8018 	str.w	r8, [r0, #24]
    dhcpsHE->hEntry.flags.value &= ~DHCPS_FLAG_ENTRY_VALID_MASK;
   1d306:	8803      	ldrh	r3, [r0, #0]
   1d308:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    dhcpsHE->hEntry.flags.value |= newFlags;
   1d30c:	433b      	orrs	r3, r7
   1d30e:	8003      	strh	r3, [r0, #0]
    if(hwAdd)
   1d310:	b12d      	cbz	r5, 1d31e <_DHCPSAddCompleteEntry+0x3e>
        dhcpsHE->hwAdd = *hwAdd;		
   1d312:	6828      	ldr	r0, [r5, #0]
   1d314:	6120      	str	r0, [r4, #16]
   1d316:	88ab      	ldrh	r3, [r5, #4]
   1d318:	82a3      	strh	r3, [r4, #20]
        memcpy(dhcpsHE->ipAddress.v, pIPAddr, sizeof(dhcpsHE->ipAddress));
   1d31a:	6833      	ldr	r3, [r6, #0]
   1d31c:	60e3      	str	r3, [r4, #12]
    dhcpsHE->Client_Lease_Time = SYS_TMR_TickCountGet();
   1d31e:	f004 ff8d 	bl	2223c <SYS_TMR_TickCountGet>
   1d322:	6060      	str	r0, [r4, #4]
    dhcpsHE->pendingTime = SYS_TMR_TickCountGet();
   1d324:	f004 ff8a 	bl	2223c <SYS_TMR_TickCountGet>
   1d328:	60a0      	str	r0, [r4, #8]
    return DHCPS_RES_OK;
   1d32a:	2000      	movs	r0, #0
}
   1d32c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        _DHCPSUpdateEntry(dhcpsHE);
   1d330:	f005 ff34 	bl	2319c <_DHCPSUpdateEntry>
    return DHCPS_RES_OK;
   1d334:	2000      	movs	r0, #0
   1d336:	e7f9      	b.n	1d32c <_DHCPSAddCompleteEntry+0x4c>
        return DHCPS_RES_CACHE_FULL;
   1d338:	2001      	movs	r0, #1
   1d33a:	e7f7      	b.n	1d32c <_DHCPSAddCompleteEntry+0x4c>
   1d33c:	2000ed7c 	.word	0x2000ed7c

Disassembly of section .text.gfx_mono_ssd1306_draw_pixel%534:

0001d340 <gfx_mono_ssd1306_draw_pixel>:
    uint8_t page;
    uint8_t pixel_mask;
    uint8_t pixel_value;

    /* Discard pixels drawn outside the screen */
    if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
   1d340:	f010 0f80 	tst.w	r0, #128	; 0x80
   1d344:	d101      	bne.n	1d34a <gfx_mono_ssd1306_draw_pixel+0xa>
   1d346:	291f      	cmp	r1, #31
   1d348:	d900      	bls.n	1d34c <gfx_mono_ssd1306_draw_pixel+0xc>
   1d34a:	4770      	bx	lr
        gfx_coord_t color) {
   1d34c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d350:	4614      	mov	r4, r2
   1d352:	4605      	mov	r5, r0
        return;
    }

    page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
   1d354:	08ce      	lsrs	r6, r1, #3
    pixel_mask = (1 << (y - (page * 8)));
   1d356:	eba1 01c6 	sub.w	r1, r1, r6, lsl #3
   1d35a:	2201      	movs	r2, #1
   1d35c:	fa02 f701 	lsl.w	r7, r2, r1
   1d360:	fa5f f887 	uxtb.w	r8, r7
    data = gfx_mono_ssd1306_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_ssd1306_get_byte(gfx_coord_t page, gfx_coord_t column) {
#ifdef CONFIG_SSD1306_FRAMEBUFFER
    return gfx_mono_framebuffer_get_byte(page, column);
   1d364:	4601      	mov	r1, r0
   1d366:	4630      	mov	r0, r6
   1d368:	f006 fd72 	bl	23e50 <gfx_mono_framebuffer_get_byte>
   1d36c:	4602      	mov	r2, r0
    switch (color) {
   1d36e:	2c01      	cmp	r4, #1
   1d370:	d00a      	beq.n	1d388 <gfx_mono_ssd1306_draw_pixel+0x48>
   1d372:	b263      	sxtb	r3, r4
   1d374:	b163      	cbz	r3, 1d390 <gfx_mono_ssd1306_draw_pixel+0x50>
   1d376:	2c02      	cmp	r4, #2
   1d378:	d00e      	beq.n	1d398 <gfx_mono_ssd1306_draw_pixel+0x58>
    gfx_mono_put_byte(page, x, pixel_value);
   1d37a:	2300      	movs	r3, #0
   1d37c:	4629      	mov	r1, r5
   1d37e:	4630      	mov	r0, r6
   1d380:	f002 f948 	bl	1f614 <gfx_mono_ssd1306_put_byte>
}
   1d384:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            pixel_value |= pixel_mask;
   1d388:	ea48 0200 	orr.w	r2, r8, r0
   1d38c:	b2d2      	uxtb	r2, r2
            break;
   1d38e:	e7f4      	b.n	1d37a <gfx_mono_ssd1306_draw_pixel+0x3a>
            pixel_value &= ~pixel_mask;
   1d390:	ea20 0207 	bic.w	r2, r0, r7
   1d394:	b2d2      	uxtb	r2, r2
            break;
   1d396:	e7f0      	b.n	1d37a <gfx_mono_ssd1306_draw_pixel+0x3a>
            pixel_value ^= pixel_mask;
   1d398:	ea88 0200 	eor.w	r2, r8, r0
   1d39c:	b2d2      	uxtb	r2, r2
            break;
   1d39e:	e7ec      	b.n	1d37a <gfx_mono_ssd1306_draw_pixel+0x3a>

Disassembly of section .text.__sinit%535:

0001d3a0 <__sinit>:
   1d3a0:	6983      	ldr	r3, [r0, #24]
   1d3a2:	b510      	push	{r4, lr}
   1d3a4:	4604      	mov	r4, r0
   1d3a6:	bb33      	cbnz	r3, 1d3f6 <__sinit+0x56>
   1d3a8:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
   1d3ac:	6503      	str	r3, [r0, #80]	; 0x50
   1d3ae:	4b12      	ldr	r3, [pc, #72]	; (1d3f8 <__sinit+0x58>)
   1d3b0:	4a12      	ldr	r2, [pc, #72]	; (1d3fc <__sinit+0x5c>)
   1d3b2:	681b      	ldr	r3, [r3, #0]
   1d3b4:	6282      	str	r2, [r0, #40]	; 0x28
   1d3b6:	4298      	cmp	r0, r3
   1d3b8:	bf04      	itt	eq
   1d3ba:	2301      	moveq	r3, #1
   1d3bc:	6183      	streq	r3, [r0, #24]
   1d3be:	f7fe fb77 	bl	1bab0 <__sfp>
   1d3c2:	6060      	str	r0, [r4, #4]
   1d3c4:	4620      	mov	r0, r4
   1d3c6:	f7fe fb73 	bl	1bab0 <__sfp>
   1d3ca:	60a0      	str	r0, [r4, #8]
   1d3cc:	4620      	mov	r0, r4
   1d3ce:	f7fe fb6f 	bl	1bab0 <__sfp>
   1d3d2:	2200      	movs	r2, #0
   1d3d4:	60e0      	str	r0, [r4, #12]
   1d3d6:	2104      	movs	r1, #4
   1d3d8:	6860      	ldr	r0, [r4, #4]
   1d3da:	f001 fe01 	bl	1efe0 <std>
   1d3de:	2201      	movs	r2, #1
   1d3e0:	2109      	movs	r1, #9
   1d3e2:	68a0      	ldr	r0, [r4, #8]
   1d3e4:	f001 fdfc 	bl	1efe0 <std>
   1d3e8:	2202      	movs	r2, #2
   1d3ea:	2112      	movs	r1, #18
   1d3ec:	68e0      	ldr	r0, [r4, #12]
   1d3ee:	f001 fdf7 	bl	1efe0 <std>
   1d3f2:	2301      	movs	r3, #1
   1d3f4:	61a3      	str	r3, [r4, #24]
   1d3f6:	bd10      	pop	{r4, pc}
   1d3f8:	000244b0 	.word	0x000244b0
   1d3fc:	000242c9 	.word	0x000242c9

Disassembly of section .text.__lo0bits%536:

0001d400 <__lo0bits>:
   1d400:	6803      	ldr	r3, [r0, #0]
   1d402:	f013 0207 	ands.w	r2, r3, #7
   1d406:	4601      	mov	r1, r0
   1d408:	d00b      	beq.n	1d422 <__lo0bits+0x22>
   1d40a:	07da      	lsls	r2, r3, #31
   1d40c:	d424      	bmi.n	1d458 <__lo0bits+0x58>
   1d40e:	0799      	lsls	r1, r3, #30
   1d410:	bf4b      	itete	mi
   1d412:	085b      	lsrmi	r3, r3, #1
   1d414:	089b      	lsrpl	r3, r3, #2
   1d416:	6003      	strmi	r3, [r0, #0]
   1d418:	6003      	strpl	r3, [r0, #0]
   1d41a:	bf4c      	ite	mi
   1d41c:	2001      	movmi	r0, #1
   1d41e:	2002      	movpl	r0, #2
   1d420:	4770      	bx	lr
   1d422:	b298      	uxth	r0, r3
   1d424:	b9b0      	cbnz	r0, 1d454 <__lo0bits+0x54>
   1d426:	0c1b      	lsrs	r3, r3, #16
   1d428:	2010      	movs	r0, #16
   1d42a:	f013 0fff 	tst.w	r3, #255	; 0xff
   1d42e:	bf04      	itt	eq
   1d430:	0a1b      	lsreq	r3, r3, #8
   1d432:	3008      	addeq	r0, #8
   1d434:	071a      	lsls	r2, r3, #28
   1d436:	bf04      	itt	eq
   1d438:	091b      	lsreq	r3, r3, #4
   1d43a:	3004      	addeq	r0, #4
   1d43c:	079a      	lsls	r2, r3, #30
   1d43e:	bf04      	itt	eq
   1d440:	089b      	lsreq	r3, r3, #2
   1d442:	3002      	addeq	r0, #2
   1d444:	07da      	lsls	r2, r3, #31
   1d446:	d403      	bmi.n	1d450 <__lo0bits+0x50>
   1d448:	085b      	lsrs	r3, r3, #1
   1d44a:	f100 0001 	add.w	r0, r0, #1
   1d44e:	d005      	beq.n	1d45c <__lo0bits+0x5c>
   1d450:	600b      	str	r3, [r1, #0]
   1d452:	4770      	bx	lr
   1d454:	4610      	mov	r0, r2
   1d456:	e7e8      	b.n	1d42a <__lo0bits+0x2a>
   1d458:	2000      	movs	r0, #0
   1d45a:	4770      	bx	lr
   1d45c:	2020      	movs	r0, #32
   1d45e:	4770      	bx	lr

Disassembly of section .rodata.DRV_ETHPHY_OBJECT_BASE_Default%537:

0001d460 <DRV_ETHPHY_OBJECT_BASE_Default>:
   1d460:	d909 0001 1945 0002 3595 0002 29a1 0002     ....E....5...)..
   1d470:	1ddd 0002 c84d 0001 18ed 0002 29c1 0002     ....M........)..
   1d480:	29e1 0002 1e55 0002 1e05 0002 6b1d 0001     .)..U........k..
   1d490:	f865 0001 05d5 0002 f825 0001 eb19 0001     e.......%.......
   1d4a0:	e1fd 0001 f7e5 0001 1919 0002 24d9 0002     .............$..
   1d4b0:	ae15 0001 b391 0001 ae95 0001               ............

Disassembly of section .text._DRV_GMAC_LinkStateWaitLinkUp%538:

0001d4bc <_DRV_GMAC_LinkStateWaitLinkUp>:
{
   1d4bc:	b510      	push	{r4, lr}
   1d4be:	4604      	mov	r4, r0
	if(pMACDrv->sGmacData._macFlags._linkUpDone == 0)
   1d4c0:	7d83      	ldrb	r3, [r0, #22]
   1d4c2:	f013 0f20 	tst.w	r3, #32
   1d4c6:	d010      	beq.n	1d4ea <_DRV_GMAC_LinkStateWaitLinkUp+0x2e>
	if(pMACDrv->sGmacData._macFlags._linkNegotiation == 0)
   1d4c8:	7da3      	ldrb	r3, [r4, #22]
   1d4ca:	f013 0f08 	tst.w	r3, #8
   1d4ce:	d018      	beq.n	1d502 <_DRV_GMAC_LinkStateWaitLinkUp+0x46>
	phyRes = pMACDrv->sGmacData.gmacConfig.pPhyBase->DRV_ETHPHY_NegotiationIsComplete(pMACDrv->sGmacData.hPhyClient, DRV_ETHPHY_INF_IDX_ALL_EXTERNAL, false);
   1d4d0:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
   1d4d4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1d4d6:	2200      	movs	r2, #0
   1d4d8:	4611      	mov	r1, r2
   1d4da:	6920      	ldr	r0, [r4, #16]
   1d4dc:	4798      	blx	r3
	if(phyRes < 0)
   1d4de:	2800      	cmp	r0, #0
   1d4e0:	db16      	blt.n	1d510 <_DRV_GMAC_LinkStateWaitLinkUp+0x54>
		pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_NEG_COMPLETE;
   1d4e2:	2303      	movs	r3, #3
   1d4e4:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
}
   1d4e8:	bd10      	pop	{r4, pc}
		uint32_t currTick = SYS_TMR_TickCountGet();
   1d4ea:	f004 fea7 	bl	2223c <SYS_TMR_TickCountGet>
		if(currTick - pMACDrv->sGmacData._linkUpTick < pMACDrv->sGmacData._linkWaitTick)
   1d4ee:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1d4f0:	1ac0      	subs	r0, r0, r3
   1d4f2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1d4f4:	4298      	cmp	r0, r3
   1d4f6:	d3f7      	bcc.n	1d4e8 <_DRV_GMAC_LinkStateWaitLinkUp+0x2c>
		pMACDrv->sGmacData._macFlags._linkUpDone = 1;
   1d4f8:	7da3      	ldrb	r3, [r4, #22]
   1d4fa:	f043 0320 	orr.w	r3, r3, #32
   1d4fe:	75a3      	strb	r3, [r4, #22]
   1d500:	e7e2      	b.n	1d4c8 <_DRV_GMAC_LinkStateWaitLinkUp+0xc>
		pMACDrv->sGmacData._macFlags._linkPrev = true;
   1d502:	f043 0310 	orr.w	r3, r3, #16
   1d506:	75a3      	strb	r3, [r4, #22]
		pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_START_LINK;
   1d508:	2300      	movs	r3, #0
   1d50a:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
		return;
   1d50e:	e7eb      	b.n	1d4e8 <_DRV_GMAC_LinkStateWaitLinkUp+0x2c>
		_DRV_GMAC_LinkStateDown(pMACDrv);
   1d510:	4620      	mov	r0, r4
   1d512:	f005 fc95 	bl	22e40 <_DRV_GMAC_LinkStateDown>
   1d516:	e7e7      	b.n	1d4e8 <_DRV_GMAC_LinkStateWaitLinkUp+0x2c>

Disassembly of section .text._TcpClientSocketConnect%539:

0001d518 <_TcpClientSocketConnect>:
    switch(pSkt->addType)
   1d518:	f890 306f 	ldrb.w	r3, [r0, #111]	; 0x6f
   1d51c:	2b01      	cmp	r3, #1
   1d51e:	d002      	beq.n	1d526 <_TcpClientSocketConnect+0xe>
            return -1;  // IP_ADDRESS_TYPE_ANY
   1d520:	f04f 30ff 	mov.w	r0, #4294967295
   1d524:	4770      	bx	lr
            if( pSkt->destAddress.Val == 0)
   1d526:	6b83      	ldr	r3, [r0, #56]	; 0x38
   1d528:	b913      	cbnz	r3, 1d530 <_TcpClientSocketConnect+0x18>
                return -1;
   1d52a:	f04f 30ff 	mov.w	r0, #4294967295
}
   1d52e:	4770      	bx	lr
{
   1d530:	b510      	push	{r4, lr}
   1d532:	4604      	mov	r4, r0
    return (pAdd->w[1] + pAdd->w[0] + pSkt->remotePort) ^ pSkt->localPort;
   1d534:	8f43      	ldrh	r3, [r0, #58]	; 0x3a
   1d536:	8f02      	ldrh	r2, [r0, #56]	; 0x38
   1d538:	4413      	add	r3, r2
   1d53a:	f8b0 2058 	ldrh.w	r2, [r0, #88]	; 0x58
   1d53e:	4413      	add	r3, r2
   1d540:	f8b0 205a 	ldrh.w	r2, [r0, #90]	; 0x5a
   1d544:	4053      	eors	r3, r2
            pSkt->remoteHash = _TCP_ClientIPV4RemoteHash(&pSkt->destAddress, pSkt);
   1d546:	f8a0 306a 	strh.w	r3, [r0, #106]	; 0x6a
    pSkt->retryCount = 0;
   1d54a:	2300      	movs	r3, #0
   1d54c:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    pSkt->retryInterval = (SYS_TMR_TickCounterFrequencyGet()/4);
   1d550:	f004 fe9c 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
   1d554:	0880      	lsrs	r0, r0, #2
   1d556:	64a0      	str	r0, [r4, #72]	; 0x48
    _TCP_SEND_RES sendRes = _TcpSend(pSkt, SYN, SENDTCP_RESET_TIMERS);
   1d558:	2201      	movs	r2, #1
   1d55a:	2102      	movs	r1, #2
   1d55c:	4620      	mov	r0, r4
   1d55e:	f7ea fcef 	bl	7f40 <_TcpSend>
    if(sendRes == _TCP_SEND_OK)
   1d562:	b128      	cbz	r0, 1d570 <_TcpClientSocketConnect+0x58>
    return sendRes > 0 ? 1 : -1;
   1d564:	2800      	cmp	r0, #0
   1d566:	bfcc      	ite	gt
   1d568:	2001      	movgt	r0, #1
   1d56a:	f04f 30ff 	movle.w	r0, #4294967295
}
   1d56e:	bd10      	pop	{r4, pc}
        return 0;
   1d570:	2000      	movs	r0, #0
   1d572:	e7fc      	b.n	1d56e <_TcpClientSocketConnect+0x56>

Disassembly of section .text.TCPIP_ARP_Probe%540:

0001d574 <TCPIP_ARP_Probe>:
    if(IPAddr == 0 || IPAddr->Val == 0 || srcAddr == 0)
   1d574:	b1e9      	cbz	r1, 1d5b2 <TCPIP_ARP_Probe+0x3e>
{
   1d576:	b5f0      	push	{r4, r5, r6, r7, lr}
   1d578:	b083      	sub	sp, #12
   1d57a:	460c      	mov	r4, r1
    if(IPAddr == 0 || IPAddr->Val == 0 || srcAddr == 0)
   1d57c:	6809      	ldr	r1, [r1, #0]
   1d57e:	b1d9      	cbz	r1, 1d5b8 <TCPIP_ARP_Probe+0x44>
   1d580:	b1ea      	cbz	r2, 1d5be <TCPIP_ARP_Probe+0x4a>
   1d582:	461d      	mov	r5, r3
   1d584:	4616      	mov	r6, r2
    pIf =_TCPIPStackHandleToNetLinked(hNet);
   1d586:	f005 fb5b 	bl	22c40 <_TCPIPStackHandleToNetLinked>
    if(pIf == 0)
   1d58a:	4607      	mov	r7, r0
   1d58c:	b1d0      	cbz	r0, 1d5c4 <TCPIP_ARP_Probe+0x50>
    return pNetIf->Flags.bInConfig != 0;
   1d58e:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
    if(_TCPIPStackIsConfig(pIf) && (opType & ARP_OPERATION_CONFIGURE) == 0)
   1d592:	f013 0f10 	tst.w	r3, #16
   1d596:	d002      	beq.n	1d59e <TCPIP_ARP_Probe+0x2a>
   1d598:	f415 5f80 	tst.w	r5, #4096	; 0x1000
   1d59c:	d015      	beq.n	1d5ca <TCPIP_ARP_Probe+0x56>
    return _ARPProbeAddress(pIf, IPAddr, srcAddr, opType, 0);
   1d59e:	2300      	movs	r3, #0
   1d5a0:	9300      	str	r3, [sp, #0]
   1d5a2:	462b      	mov	r3, r5
   1d5a4:	4632      	mov	r2, r6
   1d5a6:	4621      	mov	r1, r4
   1d5a8:	4638      	mov	r0, r7
   1d5aa:	f7f8 fea5 	bl	162f8 <_ARPProbeAddress>
}
   1d5ae:	b003      	add	sp, #12
   1d5b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return ARP_RES_BAD_ADDRESS;
   1d5b2:	f06f 0004 	mvn.w	r0, #4
}
   1d5b6:	4770      	bx	lr
        return ARP_RES_BAD_ADDRESS;
   1d5b8:	f06f 0004 	mvn.w	r0, #4
   1d5bc:	e7f7      	b.n	1d5ae <TCPIP_ARP_Probe+0x3a>
   1d5be:	f06f 0004 	mvn.w	r0, #4
   1d5c2:	e7f4      	b.n	1d5ae <TCPIP_ARP_Probe+0x3a>
        return ARP_RES_NO_INTERFACE;
   1d5c4:	f06f 0005 	mvn.w	r0, #5
   1d5c8:	e7f1      	b.n	1d5ae <TCPIP_ARP_Probe+0x3a>
        return ARP_RES_CONFIGURE_ERR;
   1d5ca:	f06f 0007 	mvn.w	r0, #7
   1d5ce:	e7ee      	b.n	1d5ae <TCPIP_ARP_Probe+0x3a>

Disassembly of section .text.TCPIP_DHCP_Enable%541:

0001d5d0 <TCPIP_DHCP_Enable>:
{
   1d5d0:	b538      	push	{r3, r4, r5, lr}
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   1d5d2:	b1a0      	cbz	r0, 1d5fe <TCPIP_DHCP_Enable+0x2e>
   1d5d4:	4604      	mov	r4, r0
   1d5d6:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1d5da:	f012 0f40 	tst.w	r2, #64	; 0x40
   1d5de:	d112      	bne.n	1d606 <TCPIP_DHCP_Enable+0x36>
        return false;
   1d5e0:	2500      	movs	r5, #0
}
   1d5e2:	4628      	mov	r0, r5
   1d5e4:	bd38      	pop	{r3, r4, r5, pc}
            if(TCPIP_STACK_AddressServiceCanStart(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_DHCPC))
   1d5e6:	2101      	movs	r1, #1
   1d5e8:	4620      	mov	r0, r4
   1d5ea:	f006 f9dc 	bl	239a6 <TCPIP_STACK_AddressServiceCanStart>
   1d5ee:	4605      	mov	r5, r0
   1d5f0:	2800      	cmp	r0, #0
   1d5f2:	d0f6      	beq.n	1d5e2 <TCPIP_DHCP_Enable+0x12>
        _DHCPEnable(pNetIf, opType);
   1d5f4:	2101      	movs	r1, #1
   1d5f6:	4620      	mov	r0, r4
   1d5f8:	f7fc fafe 	bl	19bf8 <_DHCPEnable>
        return true;
   1d5fc:	e7f1      	b.n	1d5e2 <TCPIP_DHCP_Enable+0x12>
        return false;
   1d5fe:	2500      	movs	r5, #0
   1d600:	e7ef      	b.n	1d5e2 <TCPIP_DHCP_Enable+0x12>
   1d602:	2500      	movs	r5, #0
    return _DHCPStartOperation(_TCPIPStackHandleToNetUp(hNet), TCPIP_DHCP_OP_REQ_ENABLE, 0);
   1d604:	e7ed      	b.n	1d5e2 <TCPIP_DHCP_Enable+0x12>
    if(DHCPClients == 0 || pNetIf == 0)
   1d606:	4a08      	ldr	r2, [pc, #32]	; (1d628 <TCPIP_DHCP_Enable+0x58>)
   1d608:	6815      	ldr	r5, [r2, #0]
   1d60a:	2d00      	cmp	r5, #0
   1d60c:	d0f9      	beq.n	1d602 <TCPIP_DHCP_Enable+0x32>
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   1d60e:	4620      	mov	r0, r4
   1d610:	f006 fc92 	bl	23f38 <TCPIP_STACK_NetIxGet>
            if(pClient->flags.bDHCPEnabled != 0)
   1d614:	235c      	movs	r3, #92	; 0x5c
   1d616:	fb03 5000 	mla	r0, r3, r0, r5
   1d61a:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   1d61e:	f013 0f01 	tst.w	r3, #1
   1d622:	d0e0      	beq.n	1d5e6 <TCPIP_DHCP_Enable+0x16>
                return true;
   1d624:	2501      	movs	r5, #1
   1d626:	e7dc      	b.n	1d5e2 <TCPIP_DHCP_Enable+0x12>
   1d628:	2000ee3c 	.word	0x2000ee3c

Disassembly of section .text._TCPIPStackIpAddFromAnyNet%542:

0001d62c <_TCPIPStackIpAddFromAnyNet>:
    if(pIpAddress && pIpAddress->Val != 0)
   1d62c:	b329      	cbz	r1, 1d67a <_TCPIPStackIpAddFromAnyNet+0x4e>
{
   1d62e:	b470      	push	{r4, r5, r6}
    if(pIpAddress && pIpAddress->Val != 0)
   1d630:	680e      	ldr	r6, [r1, #0]
   1d632:	b1f6      	cbz	r6, 1d672 <_TCPIPStackIpAddFromAnyNet+0x46>
        for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1d634:	4b12      	ldr	r3, [pc, #72]	; (1d680 <_TCPIPStackIpAddFromAnyNet+0x54>)
   1d636:	6819      	ldr	r1, [r3, #0]
   1d638:	4b12      	ldr	r3, [pc, #72]	; (1d684 <_TCPIPStackIpAddFromAnyNet+0x58>)
   1d63a:	681a      	ldr	r2, [r3, #0]
   1d63c:	2a00      	cmp	r2, #0
   1d63e:	dd1a      	ble.n	1d676 <_TCPIPStackIpAddFromAnyNet+0x4a>
   1d640:	2300      	movs	r3, #0
   1d642:	e00d      	b.n	1d660 <_TCPIPStackIpAddFromAnyNet+0x34>
                if(pIf->Flags.bInterfaceEnabled)
   1d644:	f891 4042 	ldrb.w	r4, [r1, #66]	; 0x42
   1d648:	f014 0f40 	tst.w	r4, #64	; 0x40
   1d64c:	d004      	beq.n	1d658 <_TCPIPStackIpAddFromAnyNet+0x2c>
    return ((pIf->netIPAddr.Val ^ pIpAddress->Val) & pIf->netMask.Val) == 0;
   1d64e:	684c      	ldr	r4, [r1, #4]
   1d650:	4074      	eors	r4, r6
   1d652:	688d      	ldr	r5, [r1, #8]
                    if(_TCPIPStackIpAddFromLAN(pIf, pIpAddress))
   1d654:	422c      	tst	r4, r5
   1d656:	d009      	beq.n	1d66c <_TCPIPStackIpAddFromAnyNet+0x40>
        for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1d658:	3301      	adds	r3, #1
   1d65a:	316c      	adds	r1, #108	; 0x6c
   1d65c:	4293      	cmp	r3, r2
   1d65e:	d004      	beq.n	1d66a <_TCPIPStackIpAddFromAnyNet+0x3e>
            if(pNetIf == 0 || pIf == pNetIf)
   1d660:	2800      	cmp	r0, #0
   1d662:	d0ef      	beq.n	1d644 <_TCPIPStackIpAddFromAnyNet+0x18>
   1d664:	4288      	cmp	r0, r1
   1d666:	d1f7      	bne.n	1d658 <_TCPIPStackIpAddFromAnyNet+0x2c>
   1d668:	e7ec      	b.n	1d644 <_TCPIPStackIpAddFromAnyNet+0x18>
    return 0;
   1d66a:	2100      	movs	r1, #0
}
   1d66c:	4608      	mov	r0, r1
   1d66e:	bc70      	pop	{r4, r5, r6}
   1d670:	4770      	bx	lr
    return 0;
   1d672:	2100      	movs	r1, #0
   1d674:	e7fa      	b.n	1d66c <_TCPIPStackIpAddFromAnyNet+0x40>
   1d676:	2100      	movs	r1, #0
   1d678:	e7f8      	b.n	1d66c <_TCPIPStackIpAddFromAnyNet+0x40>
}
   1d67a:	4608      	mov	r0, r1
   1d67c:	4770      	bx	lr
   1d67e:	bf00      	nop
   1d680:	2000ee74 	.word	0x2000ee74
   1d684:	2000eae4 	.word	0x2000eae4

Disassembly of section .text._DHCPSrvClose%543:

0001d688 <_DHCPSrvClose>:
{
   1d688:	b510      	push	{r4, lr}
    if(disable)
   1d68a:	b129      	cbz	r1, 1d698 <_DHCPSrvClose+0x10>
        pNetIf->Flags.bIsDHCPSrvEnabled = false;
   1d68c:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   1d690:	f36f 0382 	bfc	r3, #2, #1
   1d694:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
{
   1d698:	2400      	movs	r4, #0
    for(netIx = 0;netIx < TCPIP_STACK_NumberOfNetworksGet(); netIx++)
   1d69a:	f006 fdcd 	bl	24238 <TCPIP_STACK_NumberOfNetworksGet>
   1d69e:	42a0      	cmp	r0, r4
   1d6a0:	dd09      	ble.n	1d6b6 <_DHCPSrvClose+0x2e>
        pIf = (TCPIP_NET_IF*)TCPIP_STACK_IndexToNet(netIx);
   1d6a2:	4620      	mov	r0, r4
   1d6a4:	f004 fcee 	bl	22084 <TCPIP_STACK_IndexToNet>
        if(pIf->Flags.bIsDHCPSrvEnabled)
   1d6a8:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   1d6ac:	f013 0f04 	tst.w	r3, #4
   1d6b0:	d112      	bne.n	1d6d8 <_DHCPSrvClose+0x50>
    for(netIx = 0;netIx < TCPIP_STACK_NumberOfNetworksGet(); netIx++)
   1d6b2:	3401      	adds	r4, #1
   1d6b4:	e7f1      	b.n	1d69a <_DHCPSrvClose+0x12>
        if( dhcps_mod.uSkt != INVALID_UDP_SOCKET)
   1d6b6:	4b0a      	ldr	r3, [pc, #40]	; (1d6e0 <_DHCPSrvClose+0x58>)
   1d6b8:	f9b3 0000 	ldrsh.w	r0, [r3]
   1d6bc:	f1b0 3fff 	cmp.w	r0, #4294967295
   1d6c0:	d00d      	beq.n	1d6de <_DHCPSrvClose+0x56>
            TCPIP_UDP_Close(dhcps_mod.uSkt);
   1d6c2:	f003 fe6b 	bl	2139c <TCPIP_UDP_Close>
            dhcps_mod.uSkt = INVALID_UDP_SOCKET;
   1d6c6:	4b06      	ldr	r3, [pc, #24]	; (1d6e0 <_DHCPSrvClose+0x58>)
   1d6c8:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1d6cc:	801a      	strh	r2, [r3, #0]
            dhcps_mod.smServer = DHCP_SERVER_IDLE;
   1d6ce:	2202      	movs	r2, #2
   1d6d0:	709a      	strb	r2, [r3, #2]
    dhcps_mod.smState = newState;
   1d6d2:	2200      	movs	r2, #0
   1d6d4:	70da      	strb	r2, [r3, #3]
}
   1d6d6:	e002      	b.n	1d6de <_DHCPSrvClose+0x56>
        dhcps_mod.smServer = DHCP_SERVER_LISTEN;
   1d6d8:	4b01      	ldr	r3, [pc, #4]	; (1d6e0 <_DHCPSrvClose+0x58>)
   1d6da:	2200      	movs	r2, #0
   1d6dc:	709a      	strb	r2, [r3, #2]
}
   1d6de:	bd10      	pop	{r4, pc}
   1d6e0:	2000ed3c 	.word	0x2000ed3c

Disassembly of section .text.SYS_TIME_RemoveFromList%544:

0001d6e4 <SYS_TIME_RemoveFromList>:
    SYS_TIME_TIMER_OBJ* tmr = counter->tmrActive;
   1d6e4:	4b15      	ldr	r3, [pc, #84]	; (1d73c <SYS_TIME_RemoveFromList+0x58>)
   1d6e6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    while ((tmr != NULL) && (tmr != delTimer))
   1d6e8:	b31a      	cbz	r2, 1d732 <SYS_TIME_RemoveFromList+0x4e>
{
   1d6ea:	b410      	push	{r4}
   1d6ec:	4601      	mov	r1, r0
    while ((tmr != NULL) && (tmr != delTimer))
   1d6ee:	4282      	cmp	r2, r0
   1d6f0:	d104      	bne.n	1d6fc <SYS_TIME_RemoveFromList+0x18>
    if (delTimer->tmrNext != NULL)
   1d6f2:	6983      	ldr	r3, [r0, #24]
   1d6f4:	b1ab      	cbz	r3, 1d722 <SYS_TIME_RemoveFromList+0x3e>
    SYS_TIME_TIMER_OBJ* prevTmr = NULL;
   1d6f6:	2200      	movs	r2, #0
   1d6f8:	e006      	b.n	1d708 <SYS_TIME_RemoveFromList+0x24>
        tmr = tmr->tmrNext;
   1d6fa:	461a      	mov	r2, r3
   1d6fc:	6993      	ldr	r3, [r2, #24]
    while ((tmr != NULL) && (tmr != delTimer))
   1d6fe:	b1d3      	cbz	r3, 1d736 <SYS_TIME_RemoveFromList+0x52>
   1d700:	4299      	cmp	r1, r3
   1d702:	d1fa      	bne.n	1d6fa <SYS_TIME_RemoveFromList+0x16>
    if (delTimer->tmrNext != NULL)
   1d704:	698b      	ldr	r3, [r1, #24]
   1d706:	b123      	cbz	r3, 1d712 <SYS_TIME_RemoveFromList+0x2e>
        uint32_t relativeTimePending = delTimer->relativeTimePending;
   1d708:	688c      	ldr	r4, [r1, #8]
        delTimer->tmrNext->relativeTimePending += relativeTimePending;
   1d70a:	6898      	ldr	r0, [r3, #8]
   1d70c:	4420      	add	r0, r4
   1d70e:	6098      	str	r0, [r3, #8]
    if (prevTmr == NULL)
   1d710:	b14a      	cbz	r2, 1d726 <SYS_TIME_RemoveFromList+0x42>
        prevTmr->tmrNext = delTimer->tmrNext;
   1d712:	698b      	ldr	r3, [r1, #24]
   1d714:	6193      	str	r3, [r2, #24]
    bool isHeadTimerUpdated = false;
   1d716:	2000      	movs	r0, #0
    delTimer->tmrNext = NULL;
   1d718:	2300      	movs	r3, #0
   1d71a:	618b      	str	r3, [r1, #24]
}
   1d71c:	f85d 4b04 	ldr.w	r4, [sp], #4
   1d720:	4770      	bx	lr
    SYS_TIME_TIMER_OBJ* prevTmr = NULL;
   1d722:	461a      	mov	r2, r3
   1d724:	e7f4      	b.n	1d710 <SYS_TIME_RemoveFromList+0x2c>
        counter->tmrActive = counter->tmrActive->tmrNext;
   1d726:	4b05      	ldr	r3, [pc, #20]	; (1d73c <SYS_TIME_RemoveFromList+0x58>)
   1d728:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   1d72a:	6992      	ldr	r2, [r2, #24]
   1d72c:	631a      	str	r2, [r3, #48]	; 0x30
        isHeadTimerUpdated = true;
   1d72e:	2001      	movs	r0, #1
   1d730:	e7f2      	b.n	1d718 <SYS_TIME_RemoveFromList+0x34>
        return isHeadTimerUpdated;
   1d732:	2000      	movs	r0, #0
}
   1d734:	4770      	bx	lr
        return isHeadTimerUpdated;
   1d736:	2000      	movs	r0, #0
   1d738:	e7f0      	b.n	1d71c <SYS_TIME_RemoveFromList+0x38>
   1d73a:	bf00      	nop
   1d73c:	2000ea00 	.word	0x2000ea00

Disassembly of section .text.xTaskCheckForTimeOut%545:

0001d740 <xTaskCheckForTimeOut>:
{
   1d740:	b570      	push	{r4, r5, r6, lr}
   1d742:	4604      	mov	r4, r0
   1d744:	460d      	mov	r5, r1
	taskENTER_CRITICAL();
   1d746:	f005 fb1b 	bl	22d80 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
   1d74a:	4b12      	ldr	r3, [pc, #72]	; (1d794 <xTaskCheckForTimeOut+0x54>)
   1d74c:	681a      	ldr	r2, [r3, #0]
			if( *pxTicksToWait == portMAX_DELAY )
   1d74e:	682b      	ldr	r3, [r5, #0]
   1d750:	f1b3 3fff 	cmp.w	r3, #4294967295
   1d754:	d016      	beq.n	1d784 <xTaskCheckForTimeOut+0x44>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   1d756:	6861      	ldr	r1, [r4, #4]
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   1d758:	480f      	ldr	r0, [pc, #60]	; (1d798 <xTaskCheckForTimeOut+0x58>)
   1d75a:	6800      	ldr	r0, [r0, #0]
   1d75c:	6826      	ldr	r6, [r4, #0]
   1d75e:	4286      	cmp	r6, r0
   1d760:	d001      	beq.n	1d766 <xTaskCheckForTimeOut+0x26>
   1d762:	4291      	cmp	r1, r2
   1d764:	d913      	bls.n	1d78e <xTaskCheckForTimeOut+0x4e>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   1d766:	1a50      	subs	r0, r2, r1
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
   1d768:	4283      	cmp	r3, r0
   1d76a:	d803      	bhi.n	1d774 <xTaskCheckForTimeOut+0x34>
			*pxTicksToWait = 0;
   1d76c:	2300      	movs	r3, #0
   1d76e:	602b      	str	r3, [r5, #0]
			xReturn = pdTRUE;
   1d770:	2401      	movs	r4, #1
   1d772:	e008      	b.n	1d786 <xTaskCheckForTimeOut+0x46>
			*pxTicksToWait -= xElapsedTime;
   1d774:	1a9b      	subs	r3, r3, r2
   1d776:	440b      	add	r3, r1
   1d778:	602b      	str	r3, [r5, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
   1d77a:	4620      	mov	r0, r4
   1d77c:	f006 f8ae 	bl	238dc <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
   1d780:	2400      	movs	r4, #0
   1d782:	e000      	b.n	1d786 <xTaskCheckForTimeOut+0x46>
				xReturn = pdFALSE;
   1d784:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
   1d786:	f006 fa1b 	bl	23bc0 <vPortExitCritical>
}
   1d78a:	4620      	mov	r0, r4
   1d78c:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = pdTRUE;
   1d78e:	2401      	movs	r4, #1
   1d790:	e7f9      	b.n	1d786 <xTaskCheckForTimeOut+0x46>
   1d792:	bf00      	nop
   1d794:	2000ef34 	.word	0x2000ef34
   1d798:	2000ef28 	.word	0x2000ef28

Disassembly of section .text.wc_CryptoCb_RandomBlock%546:

0001d79c <wc_CryptoCb_RandomBlock>:
}
#endif /* !NO_HMAC */

#ifndef WC_NO_RNG
int wc_CryptoCb_RandomBlock(WC_RNG* rng, byte* out, word32 sz)
{
   1d79c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1d79e:	b0a7      	sub	sp, #156	; 0x9c
   1d7a0:	460f      	mov	r7, r1
   1d7a2:	4616      	mov	r6, r2
    int ret = CRYPTOCB_UNAVAILABLE;
    CryptoCb* dev;

    /* locate registered callback */
    if (rng) {
   1d7a4:	4605      	mov	r5, r0
   1d7a6:	b1e0      	cbz	r0, 1d7e2 <wc_CryptoCb_RandomBlock+0x46>
        dev = wc_CryptoCb_FindDevice(rng->devId);
   1d7a8:	6940      	ldr	r0, [r0, #20]
   1d7aa:	f003 feb7 	bl	2151c <wc_CryptoCb_FindDevice>
   1d7ae:	4604      	mov	r4, r0
    else {
        /* locate first callback and try using it */
        dev = wc_CryptoCb_FindDeviceByIndex(0);
    }

    if (dev && dev->cb) {
   1d7b0:	b1e4      	cbz	r4, 1d7ec <wc_CryptoCb_RandomBlock+0x50>
   1d7b2:	6863      	ldr	r3, [r4, #4]
   1d7b4:	b1eb      	cbz	r3, 1d7f2 <wc_CryptoCb_RandomBlock+0x56>
        wc_CryptoInfo cryptoInfo;
        XMEMSET(&cryptoInfo, 0, sizeof(cryptoInfo));
   1d7b6:	2290      	movs	r2, #144	; 0x90
   1d7b8:	2100      	movs	r1, #0
   1d7ba:	a802      	add	r0, sp, #8
   1d7bc:	f006 fb70 	bl	23ea0 <memset>
        cryptoInfo.algo_type = WC_ALGO_TYPE_RNG;
   1d7c0:	2304      	movs	r3, #4
   1d7c2:	9301      	str	r3, [sp, #4]
        cryptoInfo.rng.rng = rng;
   1d7c4:	9520      	str	r5, [sp, #128]	; 0x80
        cryptoInfo.rng.out = out;
   1d7c6:	9721      	str	r7, [sp, #132]	; 0x84
        cryptoInfo.rng.sz = sz;
   1d7c8:	9622      	str	r6, [sp, #136]	; 0x88

        ret = dev->cb(dev->devId, &cryptoInfo, dev->ctx);
   1d7ca:	6863      	ldr	r3, [r4, #4]
   1d7cc:	68a2      	ldr	r2, [r4, #8]
   1d7ce:	a901      	add	r1, sp, #4
   1d7d0:	6820      	ldr	r0, [r4, #0]
   1d7d2:	4798      	blx	r3
        ret = CRYPTOCB_UNAVAILABLE;
   1d7d4:	f110 0fae 	cmn.w	r0, #174	; 0xae
   1d7d8:	bf08      	it	eq
   1d7da:	f46f 7087 	mvneq.w	r0, #270	; 0x10e
    }

    return wc_CryptoCb_TranslateErrorCode(ret);
}
   1d7de:	b027      	add	sp, #156	; 0x9c
   1d7e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        dev = wc_CryptoCb_FindDeviceByIndex(0);
   1d7e2:	2000      	movs	r0, #0
   1d7e4:	f001 fb90 	bl	1ef08 <wc_CryptoCb_FindDeviceByIndex>
   1d7e8:	4604      	mov	r4, r0
   1d7ea:	e7e1      	b.n	1d7b0 <wc_CryptoCb_RandomBlock+0x14>
    int ret = CRYPTOCB_UNAVAILABLE;
   1d7ec:	f46f 7087 	mvn.w	r0, #270	; 0x10e
   1d7f0:	e7f5      	b.n	1d7de <wc_CryptoCb_RandomBlock+0x42>
   1d7f2:	f46f 7087 	mvn.w	r0, #270	; 0x10e
    return wc_CryptoCb_TranslateErrorCode(ret);
   1d7f6:	e7f2      	b.n	1d7de <wc_CryptoCb_RandomBlock+0x42>

Disassembly of section .text._vsnprintf_r%547:

0001d7f8 <_vsniprintf_r>:
   1d7f8:	b530      	push	{r4, r5, lr}
   1d7fa:	1e14      	subs	r4, r2, #0
   1d7fc:	4605      	mov	r5, r0
   1d7fe:	b09b      	sub	sp, #108	; 0x6c
   1d800:	4618      	mov	r0, r3
   1d802:	da05      	bge.n	1d810 <_vsniprintf_r+0x18>
   1d804:	238b      	movs	r3, #139	; 0x8b
   1d806:	602b      	str	r3, [r5, #0]
   1d808:	f04f 30ff 	mov.w	r0, #4294967295
   1d80c:	b01b      	add	sp, #108	; 0x6c
   1d80e:	bd30      	pop	{r4, r5, pc}
   1d810:	f44f 7302 	mov.w	r3, #520	; 0x208
   1d814:	f8ad 3010 	strh.w	r3, [sp, #16]
   1d818:	bf14      	ite	ne
   1d81a:	f104 33ff 	addne.w	r3, r4, #4294967295
   1d81e:	4623      	moveq	r3, r4
   1d820:	9303      	str	r3, [sp, #12]
   1d822:	9306      	str	r3, [sp, #24]
   1d824:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1d828:	f8ad 3012 	strh.w	r3, [sp, #18]
   1d82c:	2300      	movs	r3, #0
   1d82e:	9101      	str	r1, [sp, #4]
   1d830:	9105      	str	r1, [sp, #20]
   1d832:	9319      	str	r3, [sp, #100]	; 0x64
   1d834:	4602      	mov	r2, r0
   1d836:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   1d838:	a901      	add	r1, sp, #4
   1d83a:	4628      	mov	r0, r5
   1d83c:	f7f3 fb44 	bl	10ec8 <_svfiprintf_r>
   1d840:	1c43      	adds	r3, r0, #1
   1d842:	bfbc      	itt	lt
   1d844:	238b      	movlt	r3, #139	; 0x8b
   1d846:	602b      	strlt	r3, [r5, #0]
   1d848:	2c00      	cmp	r4, #0
   1d84a:	d0df      	beq.n	1d80c <_vsniprintf_r+0x14>
   1d84c:	9b01      	ldr	r3, [sp, #4]
   1d84e:	2200      	movs	r2, #0
   1d850:	701a      	strb	r2, [r3, #0]
   1d852:	e7db      	b.n	1d80c <_vsniprintf_r+0x14>

Disassembly of section .text.DRV_PIC32CGMAC_LibRxBuffersCountGet%548:

0001d854 <DRV_PIC32CGMAC_LibRxBuffersCountGet>:
{
   1d854:	b470      	push	{r4, r5, r6}
        if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].queueRxEnable == true)
   1d856:	f890 30cf 	ldrb.w	r3, [r0, #207]	; 0xcf
   1d85a:	2b01      	cmp	r3, #1
   1d85c:	d008      	beq.n	1d870 <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x1c>
   1d85e:	2000      	movs	r0, #0
   1d860:	4605      	mov	r5, r0
    if(pendBuffs)
   1d862:	b101      	cbz	r1, 1d866 <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x12>
        *pendBuffs = pend_buffer_cnt;
   1d864:	600d      	str	r5, [r1, #0]
    if(schedBuffs)
   1d866:	b102      	cbz	r2, 1d86a <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x16>
        *schedBuffs = sched_buffer_cnt;
   1d868:	6010      	str	r0, [r2, #0]
}
   1d86a:	2000      	movs	r0, #0
   1d86c:	bc70      	pop	{r4, r5, r6}
   1d86e:	4770      	bx	lr
            for(uint16_t desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt; desc_idx++)
   1d870:	f8b0 60be 	ldrh.w	r6, [r0, #190]	; 0xbe
   1d874:	b1c6      	cbz	r6, 1d8a8 <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x54>
   1d876:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
   1d87a:	3e01      	subs	r6, #1
   1d87c:	b2b0      	uxth	r0, r6
   1d87e:	f103 0608 	add.w	r6, r3, #8
   1d882:	eb06 06c0 	add.w	r6, r6, r0, lsl #3
                if ((pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc[desc_idx].rx_desc_buffaddr.val) & GMAC_RX_ADDRESS_MASK)
   1d886:	2000      	movs	r0, #0
   1d888:	4605      	mov	r5, r0
   1d88a:	e002      	b.n	1d892 <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x3e>
   1d88c:	3308      	adds	r3, #8
            for(uint16_t desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt; desc_idx++)
   1d88e:	42b3      	cmp	r3, r6
   1d890:	d0e7      	beq.n	1d862 <DRV_PIC32CGMAC_LibRxBuffersCountGet+0xe>
                if ((pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc[desc_idx].rx_desc_buffaddr.val) & GMAC_RX_ADDRESS_MASK)
   1d892:	681c      	ldr	r4, [r3, #0]
   1d894:	f034 0403 	bics.w	r4, r4, #3
   1d898:	d0f8      	beq.n	1d88c <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x38>
                    if ((pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc[desc_idx].rx_desc_buffaddr.val) & GMAC_RX_OWNERSHIP_BIT)
   1d89a:	681c      	ldr	r4, [r3, #0]
   1d89c:	f014 0f01 	tst.w	r4, #1
                        pend_buffer_cnt++;
   1d8a0:	bf14      	ite	ne
   1d8a2:	3501      	addne	r5, #1
                        sched_buffer_cnt++;
   1d8a4:	3001      	addeq	r0, #1
   1d8a6:	e7f1      	b.n	1d88c <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x38>
            for(uint16_t desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt; desc_idx++)
   1d8a8:	2000      	movs	r0, #0
   1d8aa:	4605      	mov	r5, r0
   1d8ac:	e7d9      	b.n	1d862 <DRV_PIC32CGMAC_LibRxBuffersCountGet+0xe>

Disassembly of section .text.TCPIP_UDP_BcastIPV4AddressSet%549:

0001d8ae <TCPIP_UDP_BcastIPV4AddressSet>:
{
   1d8ae:	b570      	push	{r4, r5, r6, lr}
   1d8b0:	460d      	mov	r5, r1
   1d8b2:	4616      	mov	r6, r2
    pSkt = _UDPSocketDcpt(s);
   1d8b4:	f004 fc4a 	bl	2214c <_UDPSocketDcpt>
    if(pSkt == 0 || pSkt->addType != IP_ADDRESS_TYPE_IPV4)
   1d8b8:	b1f0      	cbz	r0, 1d8f8 <TCPIP_UDP_BcastIPV4AddressSet+0x4a>
   1d8ba:	4604      	mov	r4, r0
   1d8bc:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
   1d8be:	2b01      	cmp	r3, #1
   1d8c0:	d11c      	bne.n	1d8fc <TCPIP_UDP_BcastIPV4AddressSet+0x4e>
    if(pSkt->flags.bcastForceType != UDP_BCAST_NONE)
   1d8c2:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   1d8c6:	f013 0f03 	tst.w	r3, #3
   1d8ca:	d119      	bne.n	1d900 <TCPIP_UDP_BcastIPV4AddressSet+0x52>
    switch (bcastType)
   1d8cc:	2d01      	cmp	r5, #1
   1d8ce:	d008      	beq.n	1d8e2 <TCPIP_UDP_BcastIPV4AddressSet+0x34>
   1d8d0:	2d02      	cmp	r5, #2
   1d8d2:	d117      	bne.n	1d904 <TCPIP_UDP_BcastIPV4AddressSet+0x56>
            if((bcastAddress.Val = TCPIP_STACK_NetAddressBcast(hNet)) == 0)
   1d8d4:	4630      	mov	r0, r6
   1d8d6:	f005 fad1 	bl	22e7c <TCPIP_STACK_NetAddressBcast>
   1d8da:	4603      	mov	r3, r0
   1d8dc:	b918      	cbnz	r0, 1d8e6 <TCPIP_UDP_BcastIPV4AddressSet+0x38>
                return false;
   1d8de:	2000      	movs	r0, #0
   1d8e0:	e00d      	b.n	1d8fe <TCPIP_UDP_BcastIPV4AddressSet+0x50>
            bcastAddress.Val = 0xffffffff;
   1d8e2:	f04f 33ff 	mov.w	r3, #4294967295
    pSkt->destAddress.Val = bcastAddress.Val;
   1d8e6:	6163      	str	r3, [r4, #20]
    pSkt->flags.destSet = 1;
   1d8e8:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
   1d8ec:	f043 0301 	orr.w	r3, r3, #1
   1d8f0:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    return true;
   1d8f4:	2001      	movs	r0, #1
   1d8f6:	e002      	b.n	1d8fe <TCPIP_UDP_BcastIPV4AddressSet+0x50>
        return false;
   1d8f8:	2000      	movs	r0, #0
   1d8fa:	e000      	b.n	1d8fe <TCPIP_UDP_BcastIPV4AddressSet+0x50>
   1d8fc:	2000      	movs	r0, #0
}
   1d8fe:	bd70      	pop	{r4, r5, r6, pc}
        return false;
   1d900:	2000      	movs	r0, #0
   1d902:	e7fc      	b.n	1d8fe <TCPIP_UDP_BcastIPV4AddressSet+0x50>
            return false;
   1d904:	2000      	movs	r0, #0
   1d906:	e7fa      	b.n	1d8fe <TCPIP_UDP_BcastIPV4AddressSet+0x50>

Disassembly of section .text.DRV_ETHPHY_Initialize%550:

0001d908 <DRV_ETHPHY_Initialize>:
    if ( iModule >= _DRV_ETHPHY_INSTANCES_NUMBER )
   1d908:	bb10      	cbnz	r0, 1d950 <DRV_ETHPHY_Initialize+0x48>
    if( hSysObj->objInUse == true )
   1d90a:	4b14      	ldr	r3, [pc, #80]	; (1d95c <DRV_ETHPHY_Initialize+0x54>)
   1d90c:	781b      	ldrb	r3, [r3, #0]
   1d90e:	2b01      	cmp	r3, #1
   1d910:	d01c      	beq.n	1d94c <DRV_ETHPHY_Initialize+0x44>
    if((hSysObj->pMiimBase = ethphyInit->pMiimObject) == 0)
   1d912:	694b      	ldr	r3, [r1, #20]
   1d914:	4a11      	ldr	r2, [pc, #68]	; (1d95c <DRV_ETHPHY_Initialize+0x54>)
   1d916:	6613      	str	r3, [r2, #96]	; 0x60
   1d918:	b1eb      	cbz	r3, 1d956 <DRV_ETHPHY_Initialize+0x4e>
{
   1d91a:	b510      	push	{r4, lr}
   1d91c:	460b      	mov	r3, r1
    hSysObj->miimIndex = ethphyInit->miimIndex;
   1d91e:	8b8a      	ldrh	r2, [r1, #28]
   1d920:	4c0e      	ldr	r4, [pc, #56]	; (1d95c <DRV_ETHPHY_Initialize+0x54>)
   1d922:	f8a4 2064 	strh.w	r2, [r4, #100]	; 0x64
    hSysObj->objInUse = true;      // Set object to be in use
   1d926:	2201      	movs	r2, #1
   1d928:	7022      	strb	r2, [r4, #0]
    hSysObj->busInUse = 0;
   1d92a:	2100      	movs	r1, #0
   1d92c:	7061      	strb	r1, [r4, #1]
    hSysObj->numClients = 0;
   1d92e:	8061      	strh	r1, [r4, #2]
    hSysObj->status = SYS_STATUS_READY; // Set module state
   1d930:	2202      	movs	r2, #2
   1d932:	7122      	strb	r2, [r4, #4]
    hSysObj->iModule  = iModule;  // Store driver instance
   1d934:	80e1      	strh	r1, [r4, #6]
    hSysObj->ethphyId = ethphyInit->ethphyId; // Store PLIB ID
   1d936:	685a      	ldr	r2, [r3, #4]
   1d938:	60a2      	str	r2, [r4, #8]
    hSysObj->pPhyObj = ethphyInit->pPhyObject;
   1d93a:	68db      	ldr	r3, [r3, #12]
   1d93c:	6163      	str	r3, [r4, #20]
    memset(hSysObj->objClients, 0, sizeof(hSysObj->objClients));
   1d93e:	2248      	movs	r2, #72	; 0x48
   1d940:	f104 0018 	add.w	r0, r4, #24
   1d944:	f006 faac 	bl	23ea0 <memset>
    return ( SYS_MODULE_OBJ )hSysObj ;
   1d948:	4620      	mov	r0, r4
}
   1d94a:	bd10      	pop	{r4, pc}
        return ( SYS_MODULE_OBJ )hSysObj ;
   1d94c:	4803      	ldr	r0, [pc, #12]	; (1d95c <DRV_ETHPHY_Initialize+0x54>)
   1d94e:	4770      	bx	lr
        return SYS_MODULE_OBJ_INVALID;
   1d950:	f04f 30ff 	mov.w	r0, #4294967295
   1d954:	4770      	bx	lr
        return SYS_MODULE_OBJ_INVALID;
   1d956:	f04f 30ff 	mov.w	r0, #4294967295
}
   1d95a:	4770      	bx	lr
   1d95c:	2000e7e8 	.word	0x2000e7e8

Disassembly of section .text.DRV_GMAC_RxFilterHashTableEntrySet%551:

0001d960 <DRV_GMAC_RxFilterHashTableEntrySet>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1d960:	4b14      	ldr	r3, [pc, #80]	; (1d9b4 <DRV_GMAC_RxFilterHashTableEntrySet+0x54>)
   1d962:	4283      	cmp	r3, r0
   1d964:	d120      	bne.n	1d9a8 <DRV_GMAC_RxFilterHashTableEntrySet+0x48>
    if(pMACDrv == 0)
   1d966:	b310      	cbz	r0, 1d9ae <DRV_GMAC_RxFilterHashTableEntrySet+0x4e>
{ 
   1d968:	b510      	push	{r4, lr}
   1d96a:	b086      	sub	sp, #24
   1d96c:	460c      	mov	r4, r1
    uint8_t nullMACAddr[6] =   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
   1d96e:	2300      	movs	r3, #0
   1d970:	9300      	str	r3, [sp, #0]
   1d972:	f8ad 3004 	strh.w	r3, [sp, #4]
    if( DestMACAddr == 0 || memcmp(DestMACAddr->v, nullMACAddr, sizeof(nullMACAddr))==0 )
   1d976:	b129      	cbz	r1, 1d984 <DRV_GMAC_RxFilterHashTableEntrySet+0x24>
   1d978:	2206      	movs	r2, #6
   1d97a:	4669      	mov	r1, sp
   1d97c:	4620      	mov	r0, r4
   1d97e:	f005 fca7 	bl	232d0 <memcmp>
   1d982:	b960      	cbnz	r0, 1d99e <DRV_GMAC_RxFilterHashTableEntrySet+0x3e>
        hash.hash_value = 0x0; //Clear to all 0 for 64-bit Hash value to reject all hash match
   1d984:	2200      	movs	r2, #0
   1d986:	2300      	movs	r3, #0
   1d988:	e9cd 2302 	strd	r2, r3, [sp, #8]
        hash.calculate_hash = false; // No hash calculation; directly set hash register
   1d98c:	f88d 3014 	strb.w	r3, [sp, #20]
    DRV_PIC32CGMAC_LibRxFilterHash_Calculate(pMACDrv, &hash);
   1d990:	a902      	add	r1, sp, #8
   1d992:	4808      	ldr	r0, [pc, #32]	; (1d9b4 <DRV_GMAC_RxFilterHashTableEntrySet+0x54>)
   1d994:	f7f3 fe16 	bl	115c4 <DRV_PIC32CGMAC_LibRxFilterHash_Calculate>
    return TCPIP_MAC_RES_OK;
   1d998:	2000      	movs	r0, #0
}
   1d99a:	b006      	add	sp, #24
   1d99c:	bd10      	pop	{r4, pc}
        hash.DestMACAddr = DestMACAddr;    
   1d99e:	9404      	str	r4, [sp, #16]
        hash.calculate_hash = true; // calculate hash and set hash register
   1d9a0:	2301      	movs	r3, #1
   1d9a2:	f88d 3014 	strb.w	r3, [sp, #20]
   1d9a6:	e7f3      	b.n	1d990 <DRV_GMAC_RxFilterHashTableEntrySet+0x30>
        return TCPIP_MAC_RES_OP_ERR;
   1d9a8:	f06f 0005 	mvn.w	r0, #5
   1d9ac:	4770      	bx	lr
   1d9ae:	f06f 0005 	mvn.w	r0, #5
}
   1d9b2:	4770      	bx	lr
   1d9b4:	2000e288 	.word	0x2000e288

Disassembly of section .rodata.DRV_GMAC_Object%552:

0001d9b8 <DRV_GMAC_Object>:
   1d9b8:	00011050 00022518 0000c8a1 00022b41     P....%......A+..
   1d9c8:	000123bf 000210cd 000145f1 00020645     .#.......E..E...
   1d9d8:	00022b21 0001eba9 0001d961 00017815     !+......a....x..
   1d9e8:	000170f9 00011415 0001bc15 00019b61     .p..........a...
   1d9f8:	0001e24d 0001ccbd 0001f2a1 00014b91     M............K..
   1da08:	0001c109 00022f89                       ...../..

Disassembly of section .text._DNS_Enable%553:

0001da10 <_DNS_Enable>:
{
   1da10:	b570      	push	{r4, r5, r6, lr}
    pDnsDcpt = pgDnsDcpt;
   1da12:	4b14      	ldr	r3, [pc, #80]	; (1da64 <_DNS_Enable+0x54>)
   1da14:	681d      	ldr	r5, [r3, #0]
    if(pDnsDcpt == 0)
   1da16:	b30d      	cbz	r5, 1da5c <_DNS_Enable+0x4c>
    if(checkIfUp)
   1da18:	b141      	cbz	r1, 1da2c <_DNS_Enable+0x1c>
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   1da1a:	b308      	cbz	r0, 1da60 <_DNS_Enable+0x50>
   1da1c:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   1da20:	f013 0f40 	tst.w	r3, #64	; 0x40
   1da24:	d104      	bne.n	1da30 <_DNS_Enable+0x20>
        return false;
   1da26:	2100      	movs	r1, #0
}
   1da28:	4608      	mov	r0, r1
   1da2a:	bd70      	pop	{r4, r5, r6, pc}
    if(pNetIf == 0 || TCPIP_STACK_DNSServiceCanStart(pNetIf, TCPIP_STACK_DNS_SERVICE_CLIENT) == false)
   1da2c:	2800      	cmp	r0, #0
   1da2e:	d0fb      	beq.n	1da28 <_DNS_Enable+0x18>
   1da30:	4616      	mov	r6, r2
   1da32:	4604      	mov	r4, r0
   1da34:	2101      	movs	r1, #1
   1da36:	f003 fee6 	bl	21806 <TCPIP_STACK_DNSServiceCanStart>
   1da3a:	4601      	mov	r1, r0
   1da3c:	2800      	cmp	r0, #0
   1da3e:	d0f3      	beq.n	1da28 <_DNS_Enable+0x18>
    pNetIf->Flags.bIsDnsClientEnabled = true;      
   1da40:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   1da44:	f043 0308 	orr.w	r3, r3, #8
   1da48:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    if(flags == TCPIP_DNS_ENABLE_STRICT)
   1da4c:	2e01      	cmp	r6, #1
   1da4e:	d003      	beq.n	1da58 <_DNS_Enable+0x48>
    else if(flags == TCPIP_DNS_ENABLE_PREFERRED)
   1da50:	2e02      	cmp	r6, #2
   1da52:	d1e9      	bne.n	1da28 <_DNS_Enable+0x18>
        pDnsDcpt->prefNet =  pNetIf;
   1da54:	60ac      	str	r4, [r5, #8]
   1da56:	e7e7      	b.n	1da28 <_DNS_Enable+0x18>
        pDnsDcpt->strictNet =  pNetIf;
   1da58:	606c      	str	r4, [r5, #4]
   1da5a:	e7e5      	b.n	1da28 <_DNS_Enable+0x18>
        return false;
   1da5c:	2100      	movs	r1, #0
   1da5e:	e7e3      	b.n	1da28 <_DNS_Enable+0x18>
        return false;
   1da60:	2100      	movs	r1, #0
   1da62:	e7e1      	b.n	1da28 <_DNS_Enable+0x18>
   1da64:	2000ee58 	.word	0x2000ee58

Disassembly of section .text._TCPIPStackModuleSignalRequest%554:

0001da68 <_TCPIPStackModuleSignalRequest>:
    if(modId <= TCPIP_MODULE_MANAGER)
   1da68:	2801      	cmp	r0, #1
   1da6a:	d921      	bls.n	1dab0 <_TCPIPStackModuleSignalRequest+0x48>
{
   1da6c:	b538      	push	{r3, r4, r5, lr}
   1da6e:	4615      	mov	r5, r2
   1da70:	460c      	mov	r4, r1
    _TCPIPSignalEntrySetNotify(_TCPIPModuleToSignalEntry(modId), signals, 0);
   1da72:	2200      	movs	r2, #0
   1da74:	4b0f      	ldr	r3, [pc, #60]	; (1dab4 <_TCPIPStackModuleSignalRequest+0x4c>)
   1da76:	eb03 1000 	add.w	r0, r3, r0, lsl #4
   1da7a:	f004 faef 	bl	2205c <_TCPIPSignalEntrySetNotify>
    if((signal & TCPIP_MODULE_SIGNAL_ASYNC) != 0)
   1da7e:	f414 7f80 	tst.w	r4, #256	; 0x100
   1da82:	d102      	bne.n	1da8a <_TCPIPStackModuleSignalRequest+0x22>
    if(noMgrAlert == 0)
   1da84:	b16d      	cbz	r5, 1daa2 <_TCPIPStackModuleSignalRequest+0x3a>
    return true;
   1da86:	4628      	mov	r0, r5
}
   1da88:	bd38      	pop	{r3, r4, r5, pc}
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1da8a:	2000      	movs	r0, #0
   1da8c:	f005 fe72 	bl	23774 <OSAL_CRIT_Enter>
    stackAsyncSignalCount += 1; 
   1da90:	4a09      	ldr	r2, [pc, #36]	; (1dab8 <_TCPIPStackModuleSignalRequest+0x50>)
   1da92:	6813      	ldr	r3, [r2, #0]
   1da94:	3301      	adds	r3, #1
   1da96:	6013      	str	r3, [r2, #0]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1da98:	4601      	mov	r1, r0
   1da9a:	2000      	movs	r0, #0
   1da9c:	f005 ffa4 	bl	239e8 <OSAL_CRIT_Leave>
   1daa0:	e7f0      	b.n	1da84 <_TCPIPStackModuleSignalRequest+0x1c>
        _TCPIPSignalEntryNotify(_TCPIPModuleToSignalEntry(TCPIP_MODULE_MANAGER), signal, 0);
   1daa2:	2200      	movs	r2, #0
   1daa4:	4621      	mov	r1, r4
   1daa6:	4805      	ldr	r0, [pc, #20]	; (1dabc <_TCPIPStackModuleSignalRequest+0x54>)
   1daa8:	f005 fafa 	bl	230a0 <_TCPIPSignalEntryNotify>
    return true;
   1daac:	2001      	movs	r0, #1
   1daae:	e7eb      	b.n	1da88 <_TCPIPStackModuleSignalRequest+0x20>
        return false;
   1dab0:	2000      	movs	r0, #0
}
   1dab2:	4770      	bx	lr
   1dab4:	2000d9a4 	.word	0x2000d9a4
   1dab8:	2000ee68 	.word	0x2000ee68
   1dabc:	2000d9b4 	.word	0x2000d9b4

Disassembly of section .text.OSAL_SEM_Create%555:

0001dac0 <OSAL_SEM_Create>:
    </code>

  Remarks:
 */
OSAL_RESULT OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE* semID, OSAL_SEM_TYPE type, uint8_t maxCount, uint8_t initialCount)
{
   1dac0:	b538      	push	{r3, r4, r5, lr}
   1dac2:	4604      	mov	r4, r0
   1dac4:	461d      	mov	r5, r3
  switch (type)
   1dac6:	b131      	cbz	r1, 1dad6 <OSAL_SEM_Create+0x16>
   1dac8:	2901      	cmp	r1, #1
   1daca:	d01b      	beq.n	1db04 <OSAL_SEM_Create+0x44>
    case OSAL_SEM_TYPE_COUNTING:
      *(SemaphoreHandle_t*)semID = xSemaphoreCreateCounting((UBaseType_t)maxCount, (UBaseType_t)initialCount);
    break;

    default:
      *(SemaphoreHandle_t*)semID = NULL;
   1dacc:	2300      	movs	r3, #0
   1dace:	6003      	str	r3, [r0, #0]

    return OSAL_RESULT_NOT_IMPLEMENTED;
   1dad0:	f04f 30ff 	mov.w	r0, #4294967295
   1dad4:	e01f      	b.n	1db16 <OSAL_SEM_Create+0x56>
      if ( initialCount <= 1)
   1dad6:	2d01      	cmp	r5, #1
   1dad8:	d901      	bls.n	1dade <OSAL_SEM_Create+0x1e>
        return OSAL_RESULT_FALSE;
   1dada:	2000      	movs	r0, #0
   1dadc:	e01b      	b.n	1db16 <OSAL_SEM_Create+0x56>
        *(SemaphoreHandle_t*)semID = xSemaphoreCreateBinary();
   1dade:	2203      	movs	r2, #3
   1dae0:	2100      	movs	r1, #0
   1dae2:	2001      	movs	r0, #1
   1dae4:	f003 fd02 	bl	214ec <xQueueGenericCreate>
   1dae8:	6020      	str	r0, [r4, #0]
        if (*(SemaphoreHandle_t*)semID != NULL && initialCount == 1)
   1daea:	b180      	cbz	r0, 1db0e <OSAL_SEM_Create+0x4e>
   1daec:	2d01      	cmp	r5, #1
   1daee:	d10e      	bne.n	1db0e <OSAL_SEM_Create+0x4e>
          if (xSemaphoreGive(*(SemaphoreHandle_t*)semID) == pdTRUE)
   1daf0:	2300      	movs	r3, #0
   1daf2:	461a      	mov	r2, r3
   1daf4:	4619      	mov	r1, r3
   1daf6:	f7f6 fce9 	bl	144cc <xQueueGenericSend>
            return OSAL_RESULT_TRUE;
   1dafa:	2801      	cmp	r0, #1
   1dafc:	bf14      	ite	ne
   1dafe:	2000      	movne	r0, #0
   1db00:	2001      	moveq	r0, #1
   1db02:	e008      	b.n	1db16 <OSAL_SEM_Create+0x56>
      *(SemaphoreHandle_t*)semID = xSemaphoreCreateCounting((UBaseType_t)maxCount, (UBaseType_t)initialCount);
   1db04:	4629      	mov	r1, r5
   1db06:	4610      	mov	r0, r2
   1db08:	f005 ff9a 	bl	23a40 <xQueueCreateCountingSemaphore>
   1db0c:	6020      	str	r0, [r4, #0]
  }

  if (*(SemaphoreHandle_t*)semID == NULL)
   1db0e:	6820      	ldr	r0, [r4, #0]
            return OSAL_RESULT_TRUE;
   1db10:	3000      	adds	r0, #0
   1db12:	bf18      	it	ne
   1db14:	2001      	movne	r0, #1
  {
    return OSAL_RESULT_FALSE;
  }

  return OSAL_RESULT_TRUE;
}
   1db16:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.SYS_TIME_TimerStart%556:

0001db18 <SYS_TIME_TimerStart>:
    SYS_TIME_ResourceUnlock();
    return result;
}

SYS_TIME_RESULT SYS_TIME_TimerStart(SYS_TIME_HANDLE handle)
{
   1db18:	b538      	push	{r3, r4, r5, lr}
   1db1a:	4604      	mov	r4, r0
    SYS_TIME_TIMER_OBJ *tmr = NULL;
    SYS_TIME_RESULT result = SYS_TIME_ERROR;

    if (SYS_TIME_ResourceLock() == false)
   1db1c:	f002 fe8e 	bl	2083c <SYS_TIME_ResourceLock>
   1db20:	b310      	cbz	r0, 1db68 <SYS_TIME_TimerStart+0x50>
    {
        return result;
    }

    tmr = SYS_TIME_GetTimerObject(handle);
   1db22:	4620      	mov	r0, r4
   1db24:	f002 fb9c 	bl	20260 <SYS_TIME_GetTimerObject>

    if(tmr != NULL)
   1db28:	4605      	mov	r5, r0
   1db2a:	b1b0      	cbz	r0, 1db5a <SYS_TIME_TimerStart+0x42>
    {
        if (tmr->active == false)
   1db2c:	7843      	ldrb	r3, [r0, #1]
   1db2e:	b9b3      	cbnz	r3, 1db5e <SYS_TIME_TimerStart+0x46>
        {
            /* Single shot timers can be started back from the single shot timer's
             * callback where relativeTimePending is 0. For this reason, if the
             * relativeTimePending is 0, it is reloaded with the requested time.
             */
            if (tmr->relativeTimePending == 0)
   1db30:	6883      	ldr	r3, [r0, #8]
   1db32:	b90b      	cbnz	r3, 1db38 <SYS_TIME_TimerStart+0x20>
            {
                tmr->relativeTimePending = tmr->requestedTime;
   1db34:	6843      	ldr	r3, [r0, #4]
   1db36:	6083      	str	r3, [r0, #8]
            }
            if (gSystemCounterObj.interruptNestingCount == 0)
   1db38:	4b0c      	ldr	r3, [pc, #48]	; (1db6c <SYS_TIME_TimerStart+0x54>)
   1db3a:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   1db3e:	b943      	cbnz	r3, 1db52 <SYS_TIME_TimerStart+0x3a>
            {
                SYS_TIME_TimerAdd(tmr);
   1db40:	4628      	mov	r0, r5
   1db42:	f002 f84f 	bl	1fbe4 <SYS_TIME_TimerAdd>
            }
            else
            {
                SYS_TIME_AddToList(tmr);
            }
            tmr->tmrElapsedFlag = false;
   1db46:	2400      	movs	r4, #0
   1db48:	752c      	strb	r4, [r5, #20]
            tmr->tmrElapsed = false;
   1db4a:	756c      	strb	r4, [r5, #21]
            tmr->active = true;
   1db4c:	2301      	movs	r3, #1
   1db4e:	706b      	strb	r3, [r5, #1]
   1db50:	e006      	b.n	1db60 <SYS_TIME_TimerStart+0x48>
                SYS_TIME_AddToList(tmr);
   1db52:	4628      	mov	r0, r5
   1db54:	f7fc fc12 	bl	1a37c <SYS_TIME_AddToList>
   1db58:	e7f5      	b.n	1db46 <SYS_TIME_TimerStart+0x2e>
    SYS_TIME_RESULT result = SYS_TIME_ERROR;
   1db5a:	2401      	movs	r4, #1
   1db5c:	e000      	b.n	1db60 <SYS_TIME_TimerStart+0x48>
        }
        result = SYS_TIME_SUCCESS;
   1db5e:	2400      	movs	r4, #0
    }

    SYS_TIME_ResourceUnlock();
   1db60:	f002 fb9c 	bl	2029c <SYS_TIME_ResourceUnlock>
    return result;
}
   1db64:	4620      	mov	r0, r4
   1db66:	bd38      	pop	{r3, r4, r5, pc}
        return result;
   1db68:	2401      	movs	r4, #1
   1db6a:	e7fb      	b.n	1db64 <SYS_TIME_TimerStart+0x4c>
   1db6c:	2000ea00 	.word	0x2000ea00

Disassembly of section .text.DRV_MIIM_OperationAbort%557:

0001db70 <DRV_MIIM_OperationAbort>:
{
   1db70:	b538      	push	{r3, r4, r5, lr}
   1db72:	460c      	mov	r4, r1
        if((pClient = _DRV_MIIM_GetClientAndLock(handle, true)) == 0)
   1db74:	2101      	movs	r1, #1
   1db76:	f000 fd70 	bl	1e65a <_DRV_MIIM_GetClientAndLock>
   1db7a:	b1d0      	cbz	r0, 1dbb2 <DRV_MIIM_OperationAbort+0x42>
        pMiimObj = pClient->parentObj;
   1db7c:	6845      	ldr	r5, [r0, #4]
    if(pOpDcpt != 0 && (pOpDcpt->qType == DRV_MIIM_QTYPE_BUSY || pOpDcpt->qType == DRV_MIIM_QTYPE_COMPLETE))
   1db7e:	b1ac      	cbz	r4, 1dbac <DRV_MIIM_OperationAbort+0x3c>
   1db80:	7ae3      	ldrb	r3, [r4, #11]
   1db82:	3b02      	subs	r3, #2
   1db84:	b2db      	uxtb	r3, r3
   1db86:	2b01      	cmp	r3, #1
   1db88:	d916      	bls.n	1dbb8 <DRV_MIIM_OperationAbort+0x48>
            miimRes = DRV_MIIM_RES_OP_HANDLE_ERR;
   1db8a:	f06f 0401 	mvn.w	r4, #1
   1db8e:	e007      	b.n	1dba0 <DRV_MIIM_OperationAbort+0x30>
            pList = &pMiimObj->completeOpList;
   1db90:	f105 0288 	add.w	r2, r5, #136	; 0x88
            qType = DRV_MIIM_QTYPE_COMPLETE;
   1db94:	2303      	movs	r3, #3
        _DRV_MIIM_ReleaseOpDcpt(pMiimObj, pOpDcpt, pList, qType);
   1db96:	4621      	mov	r1, r4
   1db98:	4628      	mov	r0, r5
   1db9a:	f002 fc6d 	bl	20478 <_DRV_MIIM_ReleaseOpDcpt>
        miimRes = DRV_MIIM_RES_OK;
   1db9e:	2400      	movs	r4, #0
    if(pMiimObj != 0)
   1dba0:	b115      	cbz	r5, 1dba8 <DRV_MIIM_OperationAbort+0x38>
    OSAL_SEM_Post(&pMiimObj->objSem);
   1dba2:	4628      	mov	r0, r5
   1dba4:	f005 fdf2 	bl	2378c <OSAL_SEM_Post>
}
   1dba8:	4620      	mov	r0, r4
   1dbaa:	bd38      	pop	{r3, r4, r5, pc}
            miimRes = DRV_MIIM_RES_OP_HANDLE_ERR;
   1dbac:	f06f 0401 	mvn.w	r4, #1
   1dbb0:	e7f6      	b.n	1dba0 <DRV_MIIM_OperationAbort+0x30>
            miimRes = DRV_MIIM_RES_HANDLE_ERR;
   1dbb2:	f04f 34ff 	mov.w	r4, #4294967295
    return miimRes;
   1dbb6:	e7f7      	b.n	1dba8 <DRV_MIIM_OperationAbort+0x38>
        if(pOpDcpt->opStat >= DRV_MIIM_TXFER_DONE)
   1dbb8:	7aa3      	ldrb	r3, [r4, #10]
   1dbba:	2b04      	cmp	r3, #4
   1dbbc:	d8e8      	bhi.n	1db90 <DRV_MIIM_OperationAbort+0x20>
            pList = &pMiimObj->busyOpList;
   1dbbe:	f105 027c 	add.w	r2, r5, #124	; 0x7c
            qType = DRV_MIIM_QTYPE_BUSY;
   1dbc2:	2302      	movs	r3, #2
   1dbc4:	e7e7      	b.n	1db96 <DRV_MIIM_OperationAbort+0x26>

Disassembly of section .text._DRV_PHY_SMITransferWaitComplete%558:

0001dbc6 <_DRV_PHY_SMITransferWaitComplete>:
    if(hClientObj->smiTxferStatus != DRV_ETHPHY_SMI_TXFER_OP_WAIT_COMPLETE)
   1dbc6:	8e83      	ldrh	r3, [r0, #52]	; 0x34
   1dbc8:	2b02      	cmp	r3, #2
   1dbca:	d11f      	bne.n	1dc0c <_DRV_PHY_SMITransferWaitComplete+0x46>
    if(hClientObj->miimHandle == 0)
   1dbcc:	6943      	ldr	r3, [r0, #20]
   1dbce:	b1fb      	cbz	r3, 1dc10 <_DRV_PHY_SMITransferWaitComplete+0x4a>
{
   1dbd0:	b510      	push	{r4, lr}
   1dbd2:	b082      	sub	sp, #8
   1dbd4:	4604      	mov	r4, r0
    miimRes = DRV_MIIM_OperationResult(hClientObj->miimHandle, hClientObj->miimOpHandle, &opData);
   1dbd6:	f10d 0206 	add.w	r2, sp, #6
   1dbda:	6981      	ldr	r1, [r0, #24]
   1dbdc:	4618      	mov	r0, r3
   1dbde:	f7fc fa65 	bl	1a0ac <DRV_MIIM_OperationResult>
    if(miimRes == DRV_MIIM_RES_PENDING)
   1dbe2:	2801      	cmp	r0, #1
   1dbe4:	d017      	beq.n	1dc16 <_DRV_PHY_SMITransferWaitComplete+0x50>
    if(miimRes < 0)
   1dbe6:	2800      	cmp	r0, #0
   1dbe8:	db09      	blt.n	1dbfe <_DRV_PHY_SMITransferWaitComplete+0x38>
        if(hClientObj->smiTxferType == DRV_ETHPHY_SMI_XFER_TYPE_READ)
   1dbea:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   1dbec:	2b03      	cmp	r3, #3
   1dbee:	d001      	beq.n	1dbf4 <_DRV_PHY_SMITransferWaitComplete+0x2e>
        txferRes = DRV_ETHPHY_SMI_TXFER_RES_DONE; 
   1dbf0:	2000      	movs	r0, #0
   1dbf2:	e006      	b.n	1dc02 <_DRV_PHY_SMITransferWaitComplete+0x3c>
            hClientObj->smiData = opData; // set the read result
   1dbf4:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   1dbf8:	8763      	strh	r3, [r4, #58]	; 0x3a
        txferRes = DRV_ETHPHY_SMI_TXFER_RES_DONE; 
   1dbfa:	2000      	movs	r0, #0
   1dbfc:	e001      	b.n	1dc02 <_DRV_PHY_SMITransferWaitComplete+0x3c>
        txferRes = DRV_ETHPHY_SMI_TXFER_RES_MIIM_ERROR; 
   1dbfe:	f06f 0001 	mvn.w	r0, #1
    hClientObj->miimOpHandle = 0;  // operation done
   1dc02:	2300      	movs	r3, #0
   1dc04:	61a3      	str	r3, [r4, #24]
    hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
   1dc06:	86a3      	strh	r3, [r4, #52]	; 0x34
}
   1dc08:	b002      	add	sp, #8
   1dc0a:	bd10      	pop	{r4, pc}
        return DRV_ETHPHY_SMI_TXFER_RES_DONE;
   1dc0c:	2000      	movs	r0, #0
   1dc0e:	4770      	bx	lr
        return DRV_ETHPHY_SMI_TXFER_RES_ILLEGAL;
   1dc10:	f04f 30ff 	mov.w	r0, #4294967295
}
   1dc14:	4770      	bx	lr
        return DRV_ETHPHY_SMI_TXFER_RES_WAIT;
   1dc16:	2002      	movs	r0, #2
   1dc18:	e7f6      	b.n	1dc08 <_DRV_PHY_SMITransferWaitComplete+0x42>

Disassembly of section .text._DRV_ETHPHY_NegCompletePhaseAN_Restart%559:

0001dc1a <_DRV_ETHPHY_NegCompletePhaseAN_Restart>:
{
   1dc1a:	b510      	push	{r4, lr}
   1dc1c:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1dc1e:	f004 fe59 	bl	228d4 <_DRV_PHY_SMITransfer_Wait>
   1dc22:	b168      	cbz	r0, 1dc40 <_DRV_ETHPHY_NegCompletePhaseAN_Restart+0x26>
    hClientObj->operReg[1] = phyBMCon.w = hClientObj->smiData;
   1dc24:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   1dc26:	84a3      	strh	r3, [r4, #36]	; 0x24
    if(phyBMCon.AN_RESTART == 0)
   1dc28:	f413 7f00 	tst.w	r3, #512	; 0x200
   1dc2c:	d009      	beq.n	1dc42 <_DRV_ETHPHY_NegCompletePhaseAN_Restart+0x28>
    if(SYS_TMR_TickCountGet() < hClientObj->operTStamp)
   1dc2e:	f004 fb05 	bl	2223c <SYS_TMR_TickCountGet>
   1dc32:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1dc34:	4298      	cmp	r0, r3
   1dc36:	d214      	bcs.n	1dc62 <_DRV_ETHPHY_NegCompletePhaseAN_Restart+0x48>
        _DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMCON);
   1dc38:	2100      	movs	r1, #0
   1dc3a:	4620      	mov	r0, r4
   1dc3c:	f003 f998 	bl	20f70 <_DRV_PHY_SMIReadStart>
}
   1dc40:	bd10      	pop	{r4, pc}
        hClientObj->operTStamp = SYS_TMR_TickCountGet() + ((DRV_ETHPHY_NEG_DONE_TMO * SYS_TMR_TickCounterFrequencyGet()) + 999) / 1000;
   1dc42:	f004 fb23 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
   1dc46:	f004 faf9 	bl	2223c <SYS_TMR_TickCountGet>
   1dc4a:	62a0      	str	r0, [r4, #40]	; 0x28
        if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   1dc4c:	2101      	movs	r1, #1
   1dc4e:	4620      	mov	r0, r4
   1dc50:	f003 f98e 	bl	20f70 <_DRV_PHY_SMIReadStart>
   1dc54:	2800      	cmp	r0, #0
   1dc56:	d0f3      	beq.n	1dc40 <_DRV_ETHPHY_NegCompletePhaseAN_Restart+0x26>
    hClientObj->operPhase = operPhase;
   1dc58:	2305      	movs	r3, #5
   1dc5a:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1dc5c:	2300      	movs	r3, #0
   1dc5e:	8423      	strh	r3, [r4, #32]
   1dc60:	e7ee      	b.n	1dc40 <_DRV_ETHPHY_NegCompletePhaseAN_Restart+0x26>
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_NEGOTIATION_NOT_STARTED);
   1dc62:	f06f 0106 	mvn.w	r1, #6
   1dc66:	4620      	mov	r0, r4
   1dc68:	f004 f8e0 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
   1dc6c:	e7e8      	b.n	1dc40 <_DRV_ETHPHY_NegCompletePhaseAN_Restart+0x26>

Disassembly of section .text._ARPNotifyClients%560:

0001dc70 <_ARPNotifyClients>:
{
   1dc70:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1dc74:	b083      	sub	sp, #12
   1dc76:	4605      	mov	r5, r0
   1dc78:	4689      	mov	r9, r1
   1dc7a:	4690      	mov	r8, r2
   1dc7c:	461f      	mov	r7, r3
    TCPIP_Helper_ProtectedSingleListLock(notifyList);
   1dc7e:	4c0f      	ldr	r4, [pc, #60]	; (1dcbc <_ARPNotifyClients+0x4c>)
   1dc80:	f104 0020 	add.w	r0, r4, #32
   1dc84:	f004 ffac 	bl	22be0 <TCPIP_Helper_ProtectedSingleListLock>
    for(aNode = (ARP_LIST_NODE*)arpMod.registeredUsers.list.head; aNode != 0; aNode = aNode->next)
   1dc88:	6a24      	ldr	r4, [r4, #32]
   1dc8a:	b984      	cbnz	r4, 1dcae <_ARPNotifyClients+0x3e>
    TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
   1dc8c:	480c      	ldr	r0, [pc, #48]	; (1dcc0 <_ARPNotifyClients+0x50>)
   1dc8e:	f005 f9f9 	bl	23084 <TCPIP_Helper_ProtectedSingleListUnlock>
}
   1dc92:	b003      	add	sp, #12
   1dc94:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            (*aNode->handler)(pNetIf, ipAdd, MACAddr, evType, aNode->hParam);
   1dc98:	68a3      	ldr	r3, [r4, #8]
   1dc9a:	9300      	str	r3, [sp, #0]
   1dc9c:	6866      	ldr	r6, [r4, #4]
   1dc9e:	463b      	mov	r3, r7
   1dca0:	4642      	mov	r2, r8
   1dca2:	4649      	mov	r1, r9
   1dca4:	4628      	mov	r0, r5
   1dca6:	47b0      	blx	r6
    for(aNode = (ARP_LIST_NODE*)arpMod.registeredUsers.list.head; aNode != 0; aNode = aNode->next)
   1dca8:	6824      	ldr	r4, [r4, #0]
   1dcaa:	2c00      	cmp	r4, #0
   1dcac:	d0ee      	beq.n	1dc8c <_ARPNotifyClients+0x1c>
        if(aNode->hNet == 0 || aNode->hNet == pNetIf)
   1dcae:	68e3      	ldr	r3, [r4, #12]
   1dcb0:	2b00      	cmp	r3, #0
   1dcb2:	d0f1      	beq.n	1dc98 <_ARPNotifyClients+0x28>
   1dcb4:	42ab      	cmp	r3, r5
   1dcb6:	d1f7      	bne.n	1dca8 <_ARPNotifyClients+0x38>
   1dcb8:	e7ee      	b.n	1dc98 <_ARPNotifyClients+0x28>
   1dcba:	bf00      	nop
   1dcbc:	2000e974 	.word	0x2000e974
   1dcc0:	2000e994 	.word	0x2000e994

Disassembly of section .text.IperfSetState%561:

0001dcc4 <IperfSetState>:

static void IperfSetState(tIperfState* pIState, int newState)
{
   1dcc4:	b538      	push	{r3, r4, r5, lr}
   1dcc6:	4604      	mov	r4, r0
   1dcc8:	460d      	mov	r5, r1
    uint8_t oldState = pIState->state;
   1dcca:	f890 30ce 	ldrb.w	r3, [r0, #206]	; 0xce
	static uint8_t	iperf_async_request = 0;
	
    if(newState == IPERF_STANDBY_STATE)
   1dcce:	2901      	cmp	r1, #1
   1dcd0:	d007      	beq.n	1dce2 <IperfSetState+0x1e>
        if(oldState != IPERF_STANDBY_STATE)
        {   // clear the async request
        	iperf_async_request--;
        }
    }
    else if (oldState == IPERF_STANDBY_STATE)
   1dcd2:	2b01      	cmp	r3, #1
   1dcd4:	d00c      	beq.n	1dcf0 <IperfSetState+0x2c>
    {   // going busy; set the async request
    	iperf_async_request++;
		_TCPIPStackModuleSignalRequest(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_ASYNC, 0); 
    }

	if(iperf_async_request == 0)
   1dcd6:	4b0f      	ldr	r3, [pc, #60]	; (1dd14 <IperfSetState+0x50>)
   1dcd8:	781b      	ldrb	r3, [r3, #0]
   1dcda:	b1a3      	cbz	r3, 1dd06 <IperfSetState+0x42>
		_TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_ASYNC); 
	
    pIState->state = (uint8_t)newState;
   1dcdc:	f884 50ce 	strb.w	r5, [r4, #206]	; 0xce

}
   1dce0:	bd38      	pop	{r3, r4, r5, pc}
        if(oldState != IPERF_STANDBY_STATE)
   1dce2:	2b01      	cmp	r3, #1
   1dce4:	d0f7      	beq.n	1dcd6 <IperfSetState+0x12>
        	iperf_async_request--;
   1dce6:	4a0b      	ldr	r2, [pc, #44]	; (1dd14 <IperfSetState+0x50>)
   1dce8:	7813      	ldrb	r3, [r2, #0]
   1dcea:	3b01      	subs	r3, #1
   1dcec:	7013      	strb	r3, [r2, #0]
   1dcee:	e7f2      	b.n	1dcd6 <IperfSetState+0x12>
    	iperf_async_request++;
   1dcf0:	4a08      	ldr	r2, [pc, #32]	; (1dd14 <IperfSetState+0x50>)
   1dcf2:	7813      	ldrb	r3, [r2, #0]
   1dcf4:	3301      	adds	r3, #1
   1dcf6:	7013      	strb	r3, [r2, #0]
		_TCPIPStackModuleSignalRequest(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_ASYNC, 0); 
   1dcf8:	2200      	movs	r2, #0
   1dcfa:	f44f 7180 	mov.w	r1, #256	; 0x100
   1dcfe:	2020      	movs	r0, #32
   1dd00:	f7ff feb2 	bl	1da68 <_TCPIPStackModuleSignalRequest>
   1dd04:	e7e7      	b.n	1dcd6 <IperfSetState+0x12>
		_TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_ASYNC); 
   1dd06:	f44f 7180 	mov.w	r1, #256	; 0x100
   1dd0a:	2020      	movs	r0, #32
   1dd0c:	f002 fa12 	bl	20134 <_TCPIPStackModuleSignalGet>
   1dd10:	e7e4      	b.n	1dcdc <IperfSetState+0x18>
   1dd12:	bf00      	nop
   1dd14:	2000ef71 	.word	0x2000ef71

Disassembly of section .text.TCPIP_IPERF_Deinitialize%562:

0001dd18 <TCPIP_IPERF_Deinitialize>:
{
   1dd18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(iperfInitCount > 0)
   1dd1a:	4b11      	ldr	r3, [pc, #68]	; (1dd60 <TCPIP_IPERF_Deinitialize+0x48>)
   1dd1c:	681c      	ldr	r4, [r3, #0]
   1dd1e:	2c00      	cmp	r4, #0
   1dd20:	dd02      	ble.n	1dd28 <TCPIP_IPERF_Deinitialize+0x10>
        if(stackCtrl->stackAction == TCPIP_STACK_ACTION_DEINIT)
   1dd22:	7f03      	ldrb	r3, [r0, #28]
   1dd24:	2b02      	cmp	r3, #2
   1dd26:	d000      	beq.n	1dd2a <TCPIP_IPERF_Deinitialize+0x12>
}
   1dd28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            if(--iperfInitCount == 0)
   1dd2a:	3c01      	subs	r4, #1
   1dd2c:	4b0c      	ldr	r3, [pc, #48]	; (1dd60 <TCPIP_IPERF_Deinitialize+0x48>)
   1dd2e:	601c      	str	r4, [r3, #0]
   1dd30:	2c00      	cmp	r4, #0
   1dd32:	d1f9      	bne.n	1dd28 <TCPIP_IPERF_Deinitialize+0x10>
                for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
   1dd34:	4b0b      	ldr	r3, [pc, #44]	; (1dd64 <TCPIP_IPERF_Deinitialize+0x4c>)
   1dd36:	681b      	ldr	r3, [r3, #0]
   1dd38:	2b00      	cmp	r3, #0
   1dd3a:	ddf5      	ble.n	1dd28 <TCPIP_IPERF_Deinitialize+0x10>
   1dd3c:	4d0a      	ldr	r5, [pc, #40]	; (1dd68 <TCPIP_IPERF_Deinitialize+0x50>)
                    	pIState->signalHandle = 0;
   1dd3e:	2700      	movs	r7, #0
                for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
   1dd40:	4e08      	ldr	r6, [pc, #32]	; (1dd64 <TCPIP_IPERF_Deinitialize+0x4c>)
   1dd42:	e008      	b.n	1dd56 <TCPIP_IPERF_Deinitialize+0x3e>
                    	_TCPIPStackSignalHandlerDeregister(pIState->signalHandle);
   1dd44:	f006 f8ff 	bl	23f46 <_TCPIPStackSignalHandlerDeregister>
                    	pIState->signalHandle = 0;
   1dd48:	f8c5 70c0 	str.w	r7, [r5, #192]	; 0xc0
                for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
   1dd4c:	3401      	adds	r4, #1
   1dd4e:	35d8      	adds	r5, #216	; 0xd8
   1dd50:	6833      	ldr	r3, [r6, #0]
   1dd52:	42a3      	cmp	r3, r4
   1dd54:	dde8      	ble.n	1dd28 <TCPIP_IPERF_Deinitialize+0x10>
                	if(pIState->signalHandle != 0)
   1dd56:	f8d5 00c0 	ldr.w	r0, [r5, #192]	; 0xc0
   1dd5a:	2800      	cmp	r0, #0
   1dd5c:	d1f2      	bne.n	1dd44 <TCPIP_IPERF_Deinitialize+0x2c>
   1dd5e:	e7f5      	b.n	1dd4c <TCPIP_IPERF_Deinitialize+0x34>
   1dd60:	2000ee20 	.word	0x2000ee20
   1dd64:	2000ee24 	.word	0x2000ee24
   1dd68:	2000e380 	.word	0x2000e380

Disassembly of section .text.IPv4RegisterFilter%563:

0001dd6c <IPv4RegisterFilter>:
{
   1dd6c:	b530      	push	{r4, r5, lr}
   1dd6e:	b085      	sub	sp, #20
    if(ipv4MemH && handler)
   1dd70:	4b10      	ldr	r3, [pc, #64]	; (1ddb4 <IPv4RegisterFilter+0x48>)
   1dd72:	681c      	ldr	r4, [r3, #0]
   1dd74:	b16c      	cbz	r4, 1dd92 <IPv4RegisterFilter+0x26>
   1dd76:	b1d8      	cbz	r0, 1ddb0 <IPv4RegisterFilter+0x44>
   1dd78:	460d      	mov	r5, r1
        filtNode.handler = handler;
   1dd7a:	9002      	str	r0, [sp, #8]
        filtNode.active = active;
   1dd7c:	f88d 100c 	strb.w	r1, [sp, #12]
        newNode = (IPV4_FILTER_LIST_NODE*)TCPIP_Notification_Add(&ipv4PacketFilters, ipv4MemH, &filtNode, sizeof(*newNode));
   1dd80:	230c      	movs	r3, #12
   1dd82:	aa01      	add	r2, sp, #4
   1dd84:	4621      	mov	r1, r4
   1dd86:	480c      	ldr	r0, [pc, #48]	; (1ddb8 <IPv4RegisterFilter+0x4c>)
   1dd88:	f004 f813 	bl	21db2 <TCPIP_Notification_Add>
        if(newNode && active)
   1dd8c:	4604      	mov	r4, r0
   1dd8e:	b100      	cbz	r0, 1dd92 <IPv4RegisterFilter+0x26>
   1dd90:	b915      	cbnz	r5, 1dd98 <IPv4RegisterFilter+0x2c>
}
   1dd92:	4620      	mov	r0, r4
   1dd94:	b005      	add	sp, #20
   1dd96:	bd30      	pop	{r4, r5, pc}
    TCPIP_Helper_ProtectedSingleListLock(notifyList);
   1dd98:	4d07      	ldr	r5, [pc, #28]	; (1ddb8 <IPv4RegisterFilter+0x4c>)
   1dd9a:	4628      	mov	r0, r5
   1dd9c:	f004 ff20 	bl	22be0 <TCPIP_Helper_ProtectedSingleListLock>
            ipv4ActFilterCount++;
   1dda0:	4a06      	ldr	r2, [pc, #24]	; (1ddbc <IPv4RegisterFilter+0x50>)
   1dda2:	6813      	ldr	r3, [r2, #0]
   1dda4:	3301      	adds	r3, #1
   1dda6:	6013      	str	r3, [r2, #0]
    TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
   1dda8:	4628      	mov	r0, r5
   1ddaa:	f005 f96b 	bl	23084 <TCPIP_Helper_ProtectedSingleListUnlock>
   1ddae:	e7f0      	b.n	1dd92 <IPv4RegisterFilter+0x26>
    IPV4_FILTER_LIST_NODE* newNode = 0;
   1ddb0:	2400      	movs	r4, #0
    return newNode;
   1ddb2:	e7ee      	b.n	1dd92 <IPv4RegisterFilter+0x26>
   1ddb4:	2000ee34 	.word	0x2000ee34
   1ddb8:	2000ec50 	.word	0x2000ec50
   1ddbc:	2000ee28 	.word	0x2000ee28

Disassembly of section .text._DHCPOptionWriteSrvIdent%564:

0001ddc0 <_DHCPOptionWriteSrvIdent>:
{
   1ddc0:	b570      	push	{r4, r5, r6, lr}
   1ddc2:	460c      	mov	r4, r1
    unsigned int msgType = pSendData->msgType;
   1ddc4:	68cd      	ldr	r5, [r1, #12]
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf); 
   1ddc6:	4b12      	ldr	r3, [pc, #72]	; (1de10 <_DHCPOptionWriteSrvIdent+0x50>)
   1ddc8:	681e      	ldr	r6, [r3, #0]
   1ddca:	f006 f8b5 	bl	23f38 <TCPIP_STACK_NetIxGet>
   1ddce:	235c      	movs	r3, #92	; 0x5c
   1ddd0:	fb03 6000 	mla	r0, r3, r0, r6
    if( (msgType == TCPIP_DHCP_DECLINE_MESSAGE) ||  (msgType == TCPIP_DHCP_RELEASE_MESSAGE) ||
   1ddd4:	2d04      	cmp	r5, #4
   1ddd6:	d009      	beq.n	1ddec <_DHCPOptionWriteSrvIdent+0x2c>
   1ddd8:	2d07      	cmp	r5, #7
   1ddda:	d007      	beq.n	1ddec <_DHCPOptionWriteSrvIdent+0x2c>
   1dddc:	2d03      	cmp	r5, #3
   1ddde:	d001      	beq.n	1dde4 <_DHCPOptionWriteSrvIdent+0x24>
    return 0;
   1dde0:	2000      	movs	r0, #0
   1dde2:	e00f      	b.n	1de04 <_DHCPOptionWriteSrvIdent+0x44>
            (msgType == TCPIP_DHCP_REQUEST_MESSAGE && pClient->dhcpOp != TCPIP_DHCP_OPER_INIT_REBOOT) )
   1dde4:	f8b0 3054 	ldrh.w	r3, [r0, #84]	; 0x54
   1dde8:	2b02      	cmp	r3, #2
   1ddea:	d00c      	beq.n	1de06 <_DHCPOptionWriteSrvIdent+0x46>
        if(pSendData->writeSpace >= sizeof(*pSrvId))
   1ddec:	6863      	ldr	r3, [r4, #4]
   1ddee:	2b05      	cmp	r3, #5
   1ddf0:	d90b      	bls.n	1de0a <_DHCPOptionWriteSrvIdent+0x4a>
            pSrvId = (TCPIP_DHCP_OPTION_DATA_SERVER_ID*)pSendData->pOpt;
   1ddf2:	6823      	ldr	r3, [r4, #0]
            pSrvId->opt = TCPIP_DHCP_SERVER_IDENTIFIER;
   1ddf4:	2236      	movs	r2, #54	; 0x36
   1ddf6:	701a      	strb	r2, [r3, #0]
            pSrvId->len = sizeof(pSrvId->serverId);
   1ddf8:	2204      	movs	r2, #4
   1ddfa:	705a      	strb	r2, [r3, #1]
            memcpy(pSrvId->serverId, &pClient->dwServerID, sizeof(pSrvId->serverId));
   1ddfc:	6a42      	ldr	r2, [r0, #36]	; 0x24
   1ddfe:	f8c3 2002 	str.w	r2, [r3, #2]
            return sizeof(*pSrvId);
   1de02:	2006      	movs	r0, #6
}
   1de04:	bd70      	pop	{r4, r5, r6, pc}
    return 0;
   1de06:	2000      	movs	r0, #0
   1de08:	e7fc      	b.n	1de04 <_DHCPOptionWriteSrvIdent+0x44>
        return -1;
   1de0a:	f04f 30ff 	mov.w	r0, #4294967295
   1de0e:	e7f9      	b.n	1de04 <_DHCPOptionWriteSrvIdent+0x44>
   1de10:	2000ee3c 	.word	0x2000ee3c

Disassembly of section .text._DNS_DeleteHash%565:

0001de14 <_DNS_DeleteHash>:
{
   1de14:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1de18:	4604      	mov	r4, r0
    if((pOh = pDnsDcpt->hashDcpt) != 0)
   1de1a:	6805      	ldr	r5, [r0, #0]
   1de1c:	b1dd      	cbz	r5, 1de56 <_DNS_DeleteHash+0x42>
        for(bktIx = 0; bktIx < pOh->hEntries; bktIx++)
   1de1e:	68eb      	ldr	r3, [r5, #12]
   1de20:	b1cb      	cbz	r3, 1de56 <_DNS_DeleteHash+0x42>
   1de22:	2600      	movs	r6, #0
            memset(pE, 0, sizeof(*pE));
   1de24:	f04f 0930 	mov.w	r9, #48	; 0x30
   1de28:	46b0      	mov	r8, r6
            pE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryGet(pOh, bktIx);
   1de2a:	4631      	mov	r1, r6
   1de2c:	4628      	mov	r0, r5
   1de2e:	f005 ff14 	bl	23c5a <TCPIP_OAHASH_EntryGet>
   1de32:	4607      	mov	r7, r0
            TCPIP_OAHASH_EntryRemove(pOh, &pE->hEntry);
   1de34:	4601      	mov	r1, r0
   1de36:	4628      	mov	r0, r5
   1de38:	f005 fc3c 	bl	236b4 <TCPIP_OAHASH_EntryRemove>
            TCPIP_HEAP_Free(pDnsDcpt->memH, pE->memblk);
   1de3c:	6920      	ldr	r0, [r4, #16]
   1de3e:	68c3      	ldr	r3, [r0, #12]
   1de40:	6879      	ldr	r1, [r7, #4]
   1de42:	4798      	blx	r3
            memset(pE, 0, sizeof(*pE));
   1de44:	464a      	mov	r2, r9
   1de46:	4641      	mov	r1, r8
   1de48:	4638      	mov	r0, r7
   1de4a:	f006 f829 	bl	23ea0 <memset>
        for(bktIx = 0; bktIx < pOh->hEntries; bktIx++)
   1de4e:	3601      	adds	r6, #1
   1de50:	68eb      	ldr	r3, [r5, #12]
   1de52:	429e      	cmp	r6, r3
   1de54:	d3e9      	bcc.n	1de2a <_DNS_DeleteHash+0x16>
    TCPIP_HEAP_Free(pDnsDcpt->memH, pDnsDcpt->hashDcpt);
   1de56:	6920      	ldr	r0, [r4, #16]
   1de58:	68c3      	ldr	r3, [r0, #12]
   1de5a:	6821      	ldr	r1, [r4, #0]
   1de5c:	4798      	blx	r3
    pDnsDcpt->hashDcpt = 0;
   1de5e:	2300      	movs	r3, #0
   1de60:	6023      	str	r3, [r4, #0]
    pDnsDcpt->unsolvedEntries = 0;
   1de62:	84e3      	strh	r3, [r4, #38]	; 0x26
}
   1de64:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

Disassembly of section .text.TCPIP_DNS_RemoveAll%566:

0001de68 <TCPIP_DNS_RemoveAll>:
{
   1de68:	b570      	push	{r4, r5, r6, lr}
    pDnsDcpt = pgDnsDcpt;
   1de6a:	4b13      	ldr	r3, [pc, #76]	; (1deb8 <TCPIP_DNS_RemoveAll+0x50>)
   1de6c:	681e      	ldr	r6, [r3, #0]
    if(pDnsDcpt == 0 || pDnsDcpt->hashDcpt == 0)
   1de6e:	b1d6      	cbz	r6, 1dea6 <TCPIP_DNS_RemoveAll+0x3e>
   1de70:	6835      	ldr	r5, [r6, #0]
   1de72:	b1dd      	cbz	r5, 1deac <TCPIP_DNS_RemoveAll+0x44>
    for(bktIx = 0; bktIx < pOh->hEntries; bktIx++)
   1de74:	68eb      	ldr	r3, [r5, #12]
   1de76:	b1e3      	cbz	r3, 1deb2 <TCPIP_DNS_RemoveAll+0x4a>
   1de78:	2400      	movs	r4, #0
   1de7a:	e006      	b.n	1de8a <TCPIP_DNS_RemoveAll+0x22>
    _DNS_CleanCacheEntry(pDnsDcpt, pDnsHE);
   1de7c:	4630      	mov	r0, r6
   1de7e:	f003 fc94 	bl	217aa <_DNS_CleanCacheEntry>
    for(bktIx = 0; bktIx < pOh->hEntries; bktIx++)
   1de82:	3401      	adds	r4, #1
   1de84:	68eb      	ldr	r3, [r5, #12]
   1de86:	42a3      	cmp	r3, r4
   1de88:	d90b      	bls.n	1dea2 <TCPIP_DNS_RemoveAll+0x3a>
        pBkt = TCPIP_OAHASH_EntryGet(pOh, bktIx);
   1de8a:	4621      	mov	r1, r4
   1de8c:	4628      	mov	r0, r5
   1de8e:	f005 fee4 	bl	23c5a <TCPIP_OAHASH_EntryGet>
        if(pBkt != 0)
   1de92:	4601      	mov	r1, r0
   1de94:	2800      	cmp	r0, #0
   1de96:	d0f4      	beq.n	1de82 <TCPIP_DNS_RemoveAll+0x1a>
            if(pBkt->flags.busy != 0)
   1de98:	7803      	ldrb	r3, [r0, #0]
   1de9a:	f013 0f01 	tst.w	r3, #1
   1de9e:	d0f0      	beq.n	1de82 <TCPIP_DNS_RemoveAll+0x1a>
   1dea0:	e7ec      	b.n	1de7c <TCPIP_DNS_RemoveAll+0x14>
    return TCPIP_DNS_RES_OK;
   1dea2:	2000      	movs	r0, #0
}
   1dea4:	bd70      	pop	{r4, r5, r6, pc}
        return TCPIP_DNS_RES_NO_SERVICE;
   1dea6:	f06f 0005 	mvn.w	r0, #5
   1deaa:	e7fb      	b.n	1dea4 <TCPIP_DNS_RemoveAll+0x3c>
   1deac:	f06f 0005 	mvn.w	r0, #5
   1deb0:	e7f8      	b.n	1dea4 <TCPIP_DNS_RemoveAll+0x3c>
    return TCPIP_DNS_RES_OK;
   1deb2:	2000      	movs	r0, #0
   1deb4:	e7f6      	b.n	1dea4 <TCPIP_DNS_RemoveAll+0x3c>
   1deb6:	bf00      	nop
   1deb8:	2000ee58 	.word	0x2000ee58

Disassembly of section .text.TCPIP_STACK_StringToMACId%567:

0001debc <TCPIP_STACK_StringToMACId>:
    if(str)
   1debc:	b1e8      	cbz	r0, 1defa <TCPIP_STACK_StringToMACId+0x3e>
{
   1debe:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1dec2:	4680      	mov	r8, r0
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   1dec4:	4b10      	ldr	r3, [pc, #64]	; (1df08 <TCPIP_STACK_StringToMACId+0x4c>)
   1dec6:	681c      	ldr	r4, [r3, #0]
   1dec8:	4b10      	ldr	r3, [pc, #64]	; (1df0c <TCPIP_STACK_StringToMACId+0x50>)
   1deca:	681f      	ldr	r7, [r3, #0]
   1decc:	2f00      	cmp	r7, #0
   1dece:	dd17      	ble.n	1df00 <TCPIP_STACK_StringToMACId+0x44>
   1ded0:	2500      	movs	r5, #0
   1ded2:	e003      	b.n	1dedc <TCPIP_STACK_StringToMACId+0x20>
   1ded4:	3501      	adds	r5, #1
   1ded6:	346c      	adds	r4, #108	; 0x6c
   1ded8:	42bd      	cmp	r5, r7
   1deda:	d00a      	beq.n	1def2 <TCPIP_STACK_StringToMACId+0x36>
            if((pObj = pNetIf->pMacObj) != 0)
   1dedc:	6c66      	ldr	r6, [r4, #68]	; 0x44
   1dede:	2e00      	cmp	r6, #0
   1dee0:	d0f8      	beq.n	1ded4 <TCPIP_STACK_StringToMACId+0x18>
                if(strcmp(str, pObj->macName) == 0)
   1dee2:	6871      	ldr	r1, [r6, #4]
   1dee4:	4640      	mov	r0, r8
   1dee6:	f005 fe89 	bl	23bfc <strcmp>
   1deea:	2800      	cmp	r0, #0
   1deec:	d1f2      	bne.n	1ded4 <TCPIP_STACK_StringToMACId+0x18>
                    return pObj->macId;
   1deee:	8830      	ldrh	r0, [r6, #0]
   1def0:	e001      	b.n	1def6 <TCPIP_STACK_StringToMACId+0x3a>
    return (TCPIP_STACK_MODULE)TCPIP_MODULE_MAC_NONE;
   1def2:	f44f 5080 	mov.w	r0, #4096	; 0x1000
}
   1def6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return (TCPIP_STACK_MODULE)TCPIP_MODULE_MAC_NONE;
   1defa:	f44f 5080 	mov.w	r0, #4096	; 0x1000
}
   1defe:	4770      	bx	lr
    return (TCPIP_STACK_MODULE)TCPIP_MODULE_MAC_NONE;
   1df00:	f44f 5080 	mov.w	r0, #4096	; 0x1000
   1df04:	e7f7      	b.n	1def6 <TCPIP_STACK_StringToMACId+0x3a>
   1df06:	bf00      	nop
   1df08:	2000ee74 	.word	0x2000ee74
   1df0c:	2000eae4 	.word	0x2000eae4

Disassembly of section .text._TCPIPStackAnyNetLinked%568:

0001df10 <_TCPIPStackAnyNetLinked>:
{
   1df10:	b508      	push	{r3, lr}
    if(useDefault)
   1df12:	b128      	cbz	r0, 1df20 <_TCPIPStackAnyNetLinked+0x10>
        pNetIf = _TCPIPStackHandleToNetLinked(tcpipDefIf.defaultNet);
   1df14:	4b10      	ldr	r3, [pc, #64]	; (1df58 <_TCPIPStackAnyNetLinked+0x48>)
   1df16:	6818      	ldr	r0, [r3, #0]
   1df18:	f004 fe92 	bl	22c40 <_TCPIPStackHandleToNetLinked>
    if(pNetIf == 0)
   1df1c:	4603      	mov	r3, r0
   1df1e:	b9b8      	cbnz	r0, 1df50 <_TCPIPStackAnyNetLinked+0x40>
        for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1df20:	4b0e      	ldr	r3, [pc, #56]	; (1df5c <_TCPIPStackAnyNetLinked+0x4c>)
   1df22:	681b      	ldr	r3, [r3, #0]
   1df24:	4a0e      	ldr	r2, [pc, #56]	; (1df60 <_TCPIPStackAnyNetLinked+0x50>)
   1df26:	6810      	ldr	r0, [r2, #0]
   1df28:	2800      	cmp	r0, #0
   1df2a:	dd13      	ble.n	1df54 <_TCPIPStackAnyNetLinked+0x44>
   1df2c:	2200      	movs	r2, #0
   1df2e:	e003      	b.n	1df38 <_TCPIPStackAnyNetLinked+0x28>
   1df30:	3201      	adds	r2, #1
   1df32:	336c      	adds	r3, #108	; 0x6c
   1df34:	4282      	cmp	r2, r0
   1df36:	d00a      	beq.n	1df4e <_TCPIPStackAnyNetLinked+0x3e>
            if(pIf->Flags.bInterfaceEnabled && pIf->exFlags.linkPrev != 0)
   1df38:	f893 1042 	ldrb.w	r1, [r3, #66]	; 0x42
   1df3c:	f011 0f40 	tst.w	r1, #64	; 0x40
   1df40:	d0f6      	beq.n	1df30 <_TCPIPStackAnyNetLinked+0x20>
   1df42:	f893 1060 	ldrb.w	r1, [r3, #96]	; 0x60
   1df46:	f011 0f01 	tst.w	r1, #1
   1df4a:	d0f1      	beq.n	1df30 <_TCPIPStackAnyNetLinked+0x20>
   1df4c:	e000      	b.n	1df50 <_TCPIPStackAnyNetLinked+0x40>
   1df4e:	2300      	movs	r3, #0
}
   1df50:	4618      	mov	r0, r3
   1df52:	bd08      	pop	{r3, pc}
        for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1df54:	2300      	movs	r3, #0
    return pNetIf;
   1df56:	e7fb      	b.n	1df50 <_TCPIPStackAnyNetLinked+0x40>
   1df58:	2000ee70 	.word	0x2000ee70
   1df5c:	2000ee74 	.word	0x2000ee74
   1df60:	2000eae4 	.word	0x2000eae4

Disassembly of section .text.DHCPSLocateRequestedIpAddress%569:

0001df64 <DHCPSLocateRequestedIpAddress>:
{
   1df64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    pOH = pdhcpsDcpt->hashDcpt;
   1df66:	4b13      	ldr	r3, [pc, #76]	; (1dfb4 <DHCPSLocateRequestedIpAddress+0x50>)
   1df68:	681d      	ldr	r5, [r3, #0]
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   1df6a:	68eb      	ldr	r3, [r5, #12]
   1df6c:	b1fb      	cbz	r3, 1dfae <DHCPSLocateRequestedIpAddress+0x4a>
   1df6e:	4606      	mov	r6, r0
   1df70:	2400      	movs	r4, #0
    return memcmp(((DHCPS_HASH_ENTRY*)hEntry)->ipAddress.v, key, sizeof(((DHCPS_HASH_ENTRY*)hEntry)->ipAddress));
   1df72:	2704      	movs	r7, #4
   1df74:	e003      	b.n	1df7e <DHCPSLocateRequestedIpAddress+0x1a>
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   1df76:	3401      	adds	r4, #1
   1df78:	68eb      	ldr	r3, [r5, #12]
   1df7a:	42a3      	cmp	r3, r4
   1df7c:	d914      	bls.n	1dfa8 <DHCPSLocateRequestedIpAddress+0x44>
        hE = TCPIP_OAHASH_EntryGet(pOH, bktIx);
   1df7e:	4621      	mov	r1, r4
   1df80:	4628      	mov	r0, r5
   1df82:	f005 fe6a 	bl	23c5a <TCPIP_OAHASH_EntryGet>
        if((hE->flags.busy != 0) && (hE->flags.value & DHCPS_FLAG_ENTRY_COMPLETE))
   1df86:	7803      	ldrb	r3, [r0, #0]
   1df88:	f013 0f01 	tst.w	r3, #1
   1df8c:	d0f3      	beq.n	1df76 <DHCPSLocateRequestedIpAddress+0x12>
   1df8e:	8803      	ldrh	r3, [r0, #0]
   1df90:	f013 0f80 	tst.w	r3, #128	; 0x80
   1df94:	d0ef      	beq.n	1df76 <DHCPSLocateRequestedIpAddress+0x12>
    return memcmp(((DHCPS_HASH_ENTRY*)hEntry)->ipAddress.v, key, sizeof(((DHCPS_HASH_ENTRY*)hEntry)->ipAddress));
   1df96:	463a      	mov	r2, r7
   1df98:	4631      	mov	r1, r6
   1df9a:	300c      	adds	r0, #12
   1df9c:	f005 f998 	bl	232d0 <memcmp>
            if(TCPIP_DHCPS_HashIPKeyCompare(pOH, hE, requestedIpAddr->v) == 0)
   1dfa0:	2800      	cmp	r0, #0
   1dfa2:	d1e8      	bne.n	1df76 <DHCPSLocateRequestedIpAddress+0x12>
                return DHCPS_RES_OK;
   1dfa4:	2000      	movs	r0, #0
   1dfa6:	e001      	b.n	1dfac <DHCPSLocateRequestedIpAddress+0x48>
    return DHCPS_RES_NO_ENTRY;
   1dfa8:	f04f 30ff 	mov.w	r0, #4294967295
}
   1dfac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return DHCPS_RES_NO_ENTRY;
   1dfae:	f04f 30ff 	mov.w	r0, #4294967295
   1dfb2:	e7fb      	b.n	1dfac <DHCPSLocateRequestedIpAddress+0x48>
   1dfb4:	2000ed7c 	.word	0x2000ed7c

Disassembly of section .text.SYS_TIME_CallbackRegisterMS%570:

0001dfb8 <SYS_TIME_CallbackRegisterMS>:

    return handle;
}

SYS_TIME_HANDLE SYS_TIME_CallbackRegisterMS ( SYS_TIME_CALLBACK callback, uintptr_t context, uint32_t ms, SYS_TIME_CALLBACK_TYPE type )
{
   1dfb8:	b5f0      	push	{r4, r5, r6, r7, lr}
   1dfba:	b083      	sub	sp, #12
    SYS_TIME_HANDLE handle = SYS_TIME_HANDLE_INVALID;

    /* Single shot timers must register a callback. */
    if ((type == SYS_TIME_SINGLE) && (callback == NULL))
   1dfbc:	461f      	mov	r7, r3
   1dfbe:	b903      	cbnz	r3, 1dfc2 <SYS_TIME_CallbackRegisterMS+0xa>
   1dfc0:	b1f8      	cbz	r0, 1e002 <SYS_TIME_CallbackRegisterMS+0x4a>
    {
        return handle;
    }

    if (ms != 0)
   1dfc2:	b922      	cbnz	r2, 1dfce <SYS_TIME_CallbackRegisterMS+0x16>
    SYS_TIME_HANDLE handle = SYS_TIME_HANDLE_INVALID;
   1dfc4:	f04f 34ff 	mov.w	r4, #4294967295
            SYS_TIME_TimerStart(handle);
        }
    }

    return handle;
}
   1dfc8:	4620      	mov	r0, r4
   1dfca:	b003      	add	sp, #12
   1dfcc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1dfce:	4614      	mov	r4, r2
   1dfd0:	460e      	mov	r6, r1
   1dfd2:	4605      	mov	r5, r0
    return (uint32_t) (( ms * (uint64_t) gSystemCounterObj.hwTimerFrequency) / 1000);
   1dfd4:	4b0c      	ldr	r3, [pc, #48]	; (1e008 <SYS_TIME_CallbackRegisterMS+0x50>)
   1dfd6:	68d8      	ldr	r0, [r3, #12]
   1dfd8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1dfdc:	2300      	movs	r3, #0
   1dfde:	fba0 0104 	umull	r0, r1, r0, r4
   1dfe2:	f003 fafb 	bl	215dc <__aeabi_uldivmod>
        handle = SYS_TIME_TimerObjectCreate(0, SYS_TIME_MSToCount(ms), callback, context, type);
   1dfe6:	9700      	str	r7, [sp, #0]
   1dfe8:	4633      	mov	r3, r6
   1dfea:	462a      	mov	r2, r5
   1dfec:	4601      	mov	r1, r0
   1dfee:	2000      	movs	r0, #0
   1dff0:	f7fa fc18 	bl	18824 <SYS_TIME_TimerObjectCreate>
   1dff4:	4604      	mov	r4, r0
        if(handle != SYS_TIME_HANDLE_INVALID)
   1dff6:	f1b0 3fff 	cmp.w	r0, #4294967295
   1dffa:	d0e5      	beq.n	1dfc8 <SYS_TIME_CallbackRegisterMS+0x10>
            SYS_TIME_TimerStart(handle);
   1dffc:	f7ff fd8c 	bl	1db18 <SYS_TIME_TimerStart>
   1e000:	e7e2      	b.n	1dfc8 <SYS_TIME_CallbackRegisterMS+0x10>
        return handle;
   1e002:	f04f 34ff 	mov.w	r4, #4294967295
   1e006:	e7df      	b.n	1dfc8 <SYS_TIME_CallbackRegisterMS+0x10>
   1e008:	2000ea00 	.word	0x2000ea00

Disassembly of section .text.strtok%571:

0001e00c <strtok>:
   1e00c:	4b13      	ldr	r3, [pc, #76]	; (1e05c <strtok+0x50>)
   1e00e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1e012:	681d      	ldr	r5, [r3, #0]
   1e014:	6dac      	ldr	r4, [r5, #88]	; 0x58
   1e016:	4606      	mov	r6, r0
   1e018:	460f      	mov	r7, r1
   1e01a:	b9b4      	cbnz	r4, 1e04a <strtok+0x3e>
   1e01c:	2050      	movs	r0, #80	; 0x50
   1e01e:	f005 ff2f 	bl	23e80 <malloc>
   1e022:	65a8      	str	r0, [r5, #88]	; 0x58
   1e024:	e9c0 4400 	strd	r4, r4, [r0]
   1e028:	e9c0 4402 	strd	r4, r4, [r0, #8]
   1e02c:	e9c0 4404 	strd	r4, r4, [r0, #16]
   1e030:	e9c0 440a 	strd	r4, r4, [r0, #40]	; 0x28
   1e034:	e9c0 440c 	strd	r4, r4, [r0, #48]	; 0x30
   1e038:	e9c0 440e 	strd	r4, r4, [r0, #56]	; 0x38
   1e03c:	e9c0 4410 	strd	r4, r4, [r0, #64]	; 0x40
   1e040:	e9c0 4412 	strd	r4, r4, [r0, #72]	; 0x48
   1e044:	6184      	str	r4, [r0, #24]
   1e046:	7704      	strb	r4, [r0, #28]
   1e048:	6244      	str	r4, [r0, #36]	; 0x24
   1e04a:	6daa      	ldr	r2, [r5, #88]	; 0x58
   1e04c:	4639      	mov	r1, r7
   1e04e:	4630      	mov	r0, r6
   1e050:	2301      	movs	r3, #1
   1e052:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1e056:	f000 b8a8 	b.w	1e1aa <__strtok_r>
   1e05a:	bf00      	nop
   1e05c:	2000ef60 	.word	0x2000ef60

Disassembly of section .text._fflush_r%572:

0001e060 <_fflush_r>:
   1e060:	b538      	push	{r3, r4, r5, lr}
   1e062:	690b      	ldr	r3, [r1, #16]
   1e064:	4605      	mov	r5, r0
   1e066:	460c      	mov	r4, r1
   1e068:	b1db      	cbz	r3, 1e0a2 <_fflush_r+0x42>
   1e06a:	b118      	cbz	r0, 1e074 <_fflush_r+0x14>
   1e06c:	6983      	ldr	r3, [r0, #24]
   1e06e:	b90b      	cbnz	r3, 1e074 <_fflush_r+0x14>
   1e070:	f7ff f996 	bl	1d3a0 <__sinit>
   1e074:	4b0c      	ldr	r3, [pc, #48]	; (1e0a8 <_fflush_r+0x48>)
   1e076:	429c      	cmp	r4, r3
   1e078:	d109      	bne.n	1e08e <_fflush_r+0x2e>
   1e07a:	686c      	ldr	r4, [r5, #4]
   1e07c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   1e080:	b17b      	cbz	r3, 1e0a2 <_fflush_r+0x42>
   1e082:	4621      	mov	r1, r4
   1e084:	4628      	mov	r0, r5
   1e086:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1e08a:	f7f7 b9d3 	b.w	15434 <__sflush_r>
   1e08e:	4b07      	ldr	r3, [pc, #28]	; (1e0ac <_fflush_r+0x4c>)
   1e090:	429c      	cmp	r4, r3
   1e092:	d101      	bne.n	1e098 <_fflush_r+0x38>
   1e094:	68ac      	ldr	r4, [r5, #8]
   1e096:	e7f1      	b.n	1e07c <_fflush_r+0x1c>
   1e098:	4b05      	ldr	r3, [pc, #20]	; (1e0b0 <_fflush_r+0x50>)
   1e09a:	429c      	cmp	r4, r3
   1e09c:	bf08      	it	eq
   1e09e:	68ec      	ldreq	r4, [r5, #12]
   1e0a0:	e7ec      	b.n	1e07c <_fflush_r+0x1c>
   1e0a2:	2000      	movs	r0, #0
   1e0a4:	bd38      	pop	{r3, r4, r5, pc}
   1e0a6:	bf00      	nop
   1e0a8:	2000eb44 	.word	0x2000eb44
   1e0ac:	2000eb64 	.word	0x2000eb64
   1e0b0:	2000eb24 	.word	0x2000eb24

Disassembly of section .text._TcpAbort%573:

0001e0b4 <_TcpAbort>:
{
   1e0b4:	b570      	push	{r4, r5, r6, lr}
   1e0b6:	4604      	mov	r4, r0
   1e0b8:	460d      	mov	r5, r1
   1e0ba:	4616      	mov	r6, r2
	switch(pSkt->smState)
   1e0bc:	f890 306e 	ldrb.w	r3, [r0, #110]	; 0x6e
   1e0c0:	3b02      	subs	r3, #2
   1e0c2:	2b07      	cmp	r3, #7
   1e0c4:	d811      	bhi.n	1e0ea <_TcpAbort+0x36>
   1e0c6:	e8df f003 	tbb	[pc, r3]
   1e0ca:	0808      	.short	0x0808
   1e0cc:	04100808 	.word	0x04100808
   1e0d0:	0808      	.short	0x0808
            if((abFlags & _TCP_ABORT_FLAG_SHUTDOWN) == 0)
   1e0d2:	f011 0f02 	tst.w	r1, #2
   1e0d6:	d108      	bne.n	1e0ea <_TcpAbort+0x36>
   1e0d8:	e014      	b.n	1e104 <_TcpAbort+0x50>
    pSkt->txHead = pSkt->txTail = pSkt->txUnackedTail = pSkt->txStart;
   1e0da:	6803      	ldr	r3, [r0, #0]
   1e0dc:	6103      	str	r3, [r0, #16]
   1e0de:	60c3      	str	r3, [r0, #12]
   1e0e0:	6083      	str	r3, [r0, #8]
        _TcpSend(pSkt, RST | ACK, 0);
   1e0e2:	2200      	movs	r2, #0
   1e0e4:	2114      	movs	r1, #20
   1e0e6:	f7e9 ff2b 	bl	7f40 <_TcpSend>
    if((abFlags & (_TCP_ABORT_FLAG_FORCE_CLOSE | _TCP_ABORT_FLAG_SHUTDOWN)) != 0)
   1e0ea:	f015 0f03 	tst.w	r5, #3
   1e0ee:	d005      	beq.n	1e0fc <_TcpAbort+0x48>
        pSkt->flags.forceKill = 1;
   1e0f0:	f894 306d 	ldrb.w	r3, [r4, #109]	; 0x6d
   1e0f4:	f043 0304 	orr.w	r3, r3, #4
   1e0f8:	f884 306d 	strb.w	r3, [r4, #109]	; 0x6d
    _TcpCloseSocket(pSkt, tcpEvent);
   1e0fc:	4631      	mov	r1, r6
   1e0fe:	4620      	mov	r0, r4
   1e100:	f7f4 f8a4 	bl	1224c <_TcpCloseSocket>
}
   1e104:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_TCP_RemoteBind%574:

0001e106 <TCPIP_TCP_RemoteBind>:
{
   1e106:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1e10a:	4607      	mov	r7, r0
   1e10c:	4688      	mov	r8, r1
   1e10e:	4616      	mov	r6, r2
   1e110:	461d      	mov	r5, r3
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   1e112:	f003 ff03 	bl	21f1c <_TcpSocketChk>
    if(pSkt != 0 && !_TCP_IsConnected(pSkt))
   1e116:	b1a8      	cbz	r0, 1e144 <TCPIP_TCP_RemoteBind+0x3e>
   1e118:	4604      	mov	r4, r0
    return (pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1 || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2 || pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT);
   1e11a:	f890 206e 	ldrb.w	r2, [r0, #110]	; 0x6e
   1e11e:	1ed3      	subs	r3, r2, #3
   1e120:	b2db      	uxtb	r3, r3
   1e122:	2b02      	cmp	r3, #2
   1e124:	d910      	bls.n	1e148 <TCPIP_TCP_RemoteBind+0x42>
    if(pSkt != 0 && !_TCP_IsConnected(pSkt))
   1e126:	2a08      	cmp	r2, #8
   1e128:	d012      	beq.n	1e150 <TCPIP_TCP_RemoteBind+0x4a>
        if(remoteAddress == 0 || TCPIP_TCP_DestinationIPAddressSet(hTCP, addType, remoteAddress) == true)
   1e12a:	b135      	cbz	r5, 1e13a <TCPIP_TCP_RemoteBind+0x34>
   1e12c:	462a      	mov	r2, r5
   1e12e:	4641      	mov	r1, r8
   1e130:	4638      	mov	r0, r7
   1e132:	f000 fd81 	bl	1ec38 <TCPIP_TCP_DestinationIPAddressSet>
   1e136:	4603      	mov	r3, r0
   1e138:	b138      	cbz	r0, 1e14a <TCPIP_TCP_RemoteBind+0x44>
            if(remotePort != 0)
   1e13a:	b15e      	cbz	r6, 1e154 <TCPIP_TCP_RemoteBind+0x4e>
                pSkt->remotePort = remotePort;
   1e13c:	f8a4 6058 	strh.w	r6, [r4, #88]	; 0x58
            return true;
   1e140:	2301      	movs	r3, #1
   1e142:	e002      	b.n	1e14a <TCPIP_TCP_RemoteBind+0x44>
    return false;
   1e144:	2300      	movs	r3, #0
   1e146:	e000      	b.n	1e14a <TCPIP_TCP_RemoteBind+0x44>
   1e148:	2300      	movs	r3, #0
}
   1e14a:	4618      	mov	r0, r3
   1e14c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return false;
   1e150:	2300      	movs	r3, #0
   1e152:	e7fa      	b.n	1e14a <TCPIP_TCP_RemoteBind+0x44>
            return true;
   1e154:	2301      	movs	r3, #1
   1e156:	e7f8      	b.n	1e14a <TCPIP_TCP_RemoteBind+0x44>

Disassembly of section .text.TCPIP_DHCPS_HashDeleteEntry%575:

0001e158 <TCPIP_DHCPS_HashDeleteEntry>:
{
   1e158:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1e15c:	4606      	mov	r6, r0
    uint32_t current_timer = SYS_TMR_TickCountGet();
   1e15e:	f004 f86d 	bl	2223c <SYS_TMR_TickCountGet>
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   1e162:	68f3      	ldr	r3, [r6, #12]
   1e164:	b1fb      	cbz	r3, 1e1a6 <TCPIP_DHCPS_HashDeleteEntry+0x4e>
   1e166:	4680      	mov	r8, r0
   1e168:	2400      	movs	r4, #0
            if((current_timer - pE->Client_Lease_Time) >= TCPIP_DHCPS_LEASE_DURATION* SYS_TMR_TickCounterFrequencyGet())
   1e16a:	f44f 6996 	mov.w	r9, #1200	; 0x4b0
   1e16e:	e003      	b.n	1e178 <TCPIP_DHCPS_HashDeleteEntry+0x20>
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   1e170:	3401      	adds	r4, #1
   1e172:	68f3      	ldr	r3, [r6, #12]
   1e174:	42a3      	cmp	r3, r4
   1e176:	d912      	bls.n	1e19e <TCPIP_DHCPS_HashDeleteEntry+0x46>
        pBkt = TCPIP_OAHASH_EntryGet(pOH, bktIx);		
   1e178:	4621      	mov	r1, r4
   1e17a:	4630      	mov	r0, r6
   1e17c:	f005 fd6d 	bl	23c5a <TCPIP_OAHASH_EntryGet>
   1e180:	4605      	mov	r5, r0
        if(pBkt->flags.busy != 0)
   1e182:	7803      	ldrb	r3, [r0, #0]
   1e184:	f013 0f01 	tst.w	r3, #1
   1e188:	d0f2      	beq.n	1e170 <TCPIP_DHCPS_HashDeleteEntry+0x18>
            if((current_timer - pE->Client_Lease_Time) >= TCPIP_DHCPS_LEASE_DURATION* SYS_TMR_TickCounterFrequencyGet())
   1e18a:	6847      	ldr	r7, [r0, #4]
   1e18c:	eba8 0707 	sub.w	r7, r8, r7
   1e190:	f004 f87c 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
   1e194:	fb09 f000 	mul.w	r0, r9, r0
   1e198:	4287      	cmp	r7, r0
   1e19a:	d3e9      	bcc.n	1e170 <TCPIP_DHCPS_HashDeleteEntry+0x18>
   1e19c:	e000      	b.n	1e1a0 <TCPIP_DHCPS_HashDeleteEntry+0x48>
    return 0;
   1e19e:	2500      	movs	r5, #0
}
   1e1a0:	4628      	mov	r0, r5
   1e1a2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return 0;
   1e1a6:	2500      	movs	r5, #0
   1e1a8:	e7fa      	b.n	1e1a0 <TCPIP_DHCPS_HashDeleteEntry+0x48>

Disassembly of section .text.__strtok_r%576:

0001e1aa <__strtok_r>:
   1e1aa:	b5f0      	push	{r4, r5, r6, r7, lr}
   1e1ac:	b918      	cbnz	r0, 1e1b6 <__strtok_r+0xc>
   1e1ae:	6810      	ldr	r0, [r2, #0]
   1e1b0:	b908      	cbnz	r0, 1e1b6 <__strtok_r+0xc>
   1e1b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1e1b4:	4620      	mov	r0, r4
   1e1b6:	4604      	mov	r4, r0
   1e1b8:	460f      	mov	r7, r1
   1e1ba:	f814 5b01 	ldrb.w	r5, [r4], #1
   1e1be:	f817 6b01 	ldrb.w	r6, [r7], #1
   1e1c2:	b91e      	cbnz	r6, 1e1cc <__strtok_r+0x22>
   1e1c4:	b965      	cbnz	r5, 1e1e0 <__strtok_r+0x36>
   1e1c6:	6015      	str	r5, [r2, #0]
   1e1c8:	4628      	mov	r0, r5
   1e1ca:	e7f2      	b.n	1e1b2 <__strtok_r+0x8>
   1e1cc:	42b5      	cmp	r5, r6
   1e1ce:	d1f6      	bne.n	1e1be <__strtok_r+0x14>
   1e1d0:	2b00      	cmp	r3, #0
   1e1d2:	d1ef      	bne.n	1e1b4 <__strtok_r+0xa>
   1e1d4:	6014      	str	r4, [r2, #0]
   1e1d6:	7003      	strb	r3, [r0, #0]
   1e1d8:	e7eb      	b.n	1e1b2 <__strtok_r+0x8>
   1e1da:	461c      	mov	r4, r3
   1e1dc:	e00c      	b.n	1e1f8 <__strtok_r+0x4e>
   1e1de:	b915      	cbnz	r5, 1e1e6 <__strtok_r+0x3c>
   1e1e0:	f814 3b01 	ldrb.w	r3, [r4], #1
   1e1e4:	460e      	mov	r6, r1
   1e1e6:	f816 5b01 	ldrb.w	r5, [r6], #1
   1e1ea:	42ab      	cmp	r3, r5
   1e1ec:	d1f7      	bne.n	1e1de <__strtok_r+0x34>
   1e1ee:	2b00      	cmp	r3, #0
   1e1f0:	d0f3      	beq.n	1e1da <__strtok_r+0x30>
   1e1f2:	2300      	movs	r3, #0
   1e1f4:	f804 3c01 	strb.w	r3, [r4, #-1]
   1e1f8:	6014      	str	r4, [r2, #0]
   1e1fa:	e7da      	b.n	1e1b2 <__strtok_r+0x8>

Disassembly of section .text.DRV_ETHPHY_LinkStatusGet%577:

0001e1fc <DRV_ETHPHY_LinkStatusGet>:
    if(hClientObj != 0)
   1e1fc:	b1c0      	cbz	r0, 1e230 <DRV_ETHPHY_LinkStatusGet+0x34>
{
   1e1fe:	b410      	push	{r4}
   1e200:	4601      	mov	r1, r0
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1e202:	68c4      	ldr	r4, [r0, #12]
   1e204:	4810      	ldr	r0, [pc, #64]	; (1e248 <DRV_ETHPHY_LinkStatusGet+0x4c>)
   1e206:	4284      	cmp	r4, r0
   1e208:	d115      	bne.n	1e236 <DRV_ETHPHY_LinkStatusGet+0x3a>
            if(hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_READY)
   1e20a:	f991 0008 	ldrsb.w	r0, [r1, #8]
   1e20e:	2802      	cmp	r0, #2
   1e210:	d114      	bne.n	1e23c <DRV_ETHPHY_LinkStatusGet+0x40>
            if(pLinkStat == 0)
   1e212:	b1b2      	cbz	r2, 1e242 <DRV_ETHPHY_LinkStatusGet+0x46>
            hClientObj->operParam = (uintptr_t)pLinkStat;
   1e214:	630a      	str	r2, [r1, #48]	; 0x30
            hClientObj->operReg[0] = refresh;
   1e216:	844b      	strh	r3, [r1, #34]	; 0x22
    hClientObj->operType = opType;
   1e218:	2302      	movs	r3, #2
   1e21a:	838b      	strh	r3, [r1, #28]
    hClientObj->operPhase = hClientObj->operSubPhase = 0; 
   1e21c:	2300      	movs	r3, #0
   1e21e:	840b      	strh	r3, [r1, #32]
   1e220:	83cb      	strh	r3, [r1, #30]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_BUSY; 
   1e222:	2001      	movs	r0, #1
   1e224:	7208      	strb	r0, [r1, #8]
    hClientObj->operRes = res;
   1e226:	f881 002c 	strb.w	r0, [r1, #44]	; 0x2c
}
   1e22a:	f85d 4b04 	ldr.w	r4, [sp], #4
   1e22e:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1e230:	f06f 000a 	mvn.w	r0, #10
}
   1e234:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1e236:	f06f 000a 	mvn.w	r0, #10
   1e23a:	e7f6      	b.n	1e22a <DRV_ETHPHY_LinkStatusGet+0x2e>
                return DRV_ETHPHY_RES_NOT_READY_ERR;
   1e23c:	f06f 0009 	mvn.w	r0, #9
   1e240:	e7f3      	b.n	1e22a <DRV_ETHPHY_LinkStatusGet+0x2e>
                return DRV_ETHPHY_RES_OPERATION_ERR;
   1e242:	f06f 0008 	mvn.w	r0, #8
   1e246:	e7f0      	b.n	1e22a <DRV_ETHPHY_LinkStatusGet+0x2e>
   1e248:	2000e7e8 	.word	0x2000e7e8

Disassembly of section .text.DRV_GMAC_ParametersGet%578:

0001e24c <DRV_GMAC_ParametersGet>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1e24c:	4b12      	ldr	r3, [pc, #72]	; (1e298 <DRV_GMAC_ParametersGet+0x4c>)
   1e24e:	4283      	cmp	r3, r0
   1e250:	d117      	bne.n	1e282 <DRV_GMAC_ParametersGet+0x36>
    if(pMACDrv == 0)
   1e252:	b1c8      	cbz	r0, 1e288 <DRV_GMAC_ParametersGet+0x3c>
	if(pMACDrv->sGmacData.sysStat == SYS_STATUS_READY)
   1e254:	f993 3014 	ldrsb.w	r3, [r3, #20]
   1e258:	2b02      	cmp	r3, #2
   1e25a:	d118      	bne.n	1e28e <DRV_GMAC_ParametersGet+0x42>
		if(pMacParams)
   1e25c:	b1d1      	cbz	r1, 1e294 <DRV_GMAC_ParametersGet+0x48>
{
   1e25e:	b510      	push	{r4, lr}
   1e260:	460c      	mov	r4, r1
            DRV_PIC32CGMAC_LibGetMacAddr(pMacParams->ifPhyAddress.v);
   1e262:	4608      	mov	r0, r1
   1e264:	f002 fa0a 	bl	2067c <DRV_PIC32CGMAC_LibGetMacAddr>
			pMacParams->processFlags = (TCPIP_MAC_PROCESS_FLAG_RX | TCPIP_MAC_PROCESS_FLAG_TX);
   1e268:	2303      	movs	r3, #3
   1e26a:	80e3      	strh	r3, [r4, #6]
			pMacParams->macType = TCPIP_MAC_TYPE_ETH;
   1e26c:	2301      	movs	r3, #1
   1e26e:	7223      	strb	r3, [r4, #8]
			pMacParams->linkMtu = TCPIP_MAC_LINK_MTU_ETH;
   1e270:	f240 52dc 	movw	r2, #1500	; 0x5dc
   1e274:	8162      	strh	r2, [r4, #10]
            pMacParams->checksumOffloadRx = DRV_GMAC_RX_CHKSM_OFFLOAD;
   1e276:	2000      	movs	r0, #0
   1e278:	7320      	strb	r0, [r4, #12]
            pMacParams->checksumOffloadTx = DRV_GMAC_TX_CHKSM_OFFLOAD;
   1e27a:	7360      	strb	r0, [r4, #13]
            pMacParams->macTxPrioNum = TCPIP_GMAC_TX_PRIO_COUNT;
   1e27c:	73a3      	strb	r3, [r4, #14]
            pMacParams->macRxPrioNum = TCPIP_GMAC_RX_PRIO_COUNT;
   1e27e:	73e3      	strb	r3, [r4, #15]
}
   1e280:	bd10      	pop	{r4, pc}
        return TCPIP_MAC_RES_OP_ERR;
   1e282:	f06f 0005 	mvn.w	r0, #5
   1e286:	4770      	bx	lr
   1e288:	f06f 0005 	mvn.w	r0, #5
   1e28c:	4770      	bx	lr
	return TCPIP_MAC_RES_IS_BUSY;
   1e28e:	f06f 0001 	mvn.w	r0, #1
   1e292:	4770      	bx	lr
		return TCPIP_MAC_RES_OK;
   1e294:	2000      	movs	r0, #0
}
   1e296:	4770      	bx	lr
   1e298:	2000e288 	.word	0x2000e288

Disassembly of section .rodata%579:

0001e29c <.rodata%579>:
   1e29c:	20504354 	.word	0x20504354
   1e2a0:	4c4c554e 	.word	0x4c4c554e
   1e2a4:	6e796420 	.word	0x6e796420
   1e2a8:	63696d61 	.word	0x63696d61
   1e2ac:	6c6c6120 	.word	0x6c6c6120
   1e2b0:	7461636f 	.word	0x7461636f
   1e2b4:	206e6f69 	.word	0x206e6f69
   1e2b8:	646e6168 	.word	0x646e6168
   1e2bc:	692f656c 	.word	0x692f656c
   1e2c0:	2074696e 	.word	0x2074696e
   1e2c4:	61746164 	.word	0x61746164
   1e2c8:	00000000 	.word	0x00000000
   1e2cc:	50435420 	.word	0x50435420
   1e2d0:	6e794420 	.word	0x6e794420
   1e2d4:	63696d61 	.word	0x63696d61
   1e2d8:	6c6c6120 	.word	0x6c6c6120
   1e2dc:	7461636f 	.word	0x7461636f
   1e2e0:	206e6f69 	.word	0x206e6f69
   1e2e4:	6c696166 	.word	0x6c696166
   1e2e8:	6465      	.short	0x6465
	...

Disassembly of section .text._DHCPOptionWriteIPRequest%580:

0001e2ec <_DHCPOptionWriteIPRequest>:
{
   1e2ec:	b570      	push	{r4, r5, r6, lr}
   1e2ee:	460c      	mov	r4, r1
    unsigned int msgType = pSendData->msgType;
   1e2f0:	68cd      	ldr	r5, [r1, #12]
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf); 
   1e2f2:	4b11      	ldr	r3, [pc, #68]	; (1e338 <_DHCPOptionWriteIPRequest+0x4c>)
   1e2f4:	681e      	ldr	r6, [r3, #0]
   1e2f6:	f005 fe1f 	bl	23f38 <TCPIP_STACK_NetIxGet>
   1e2fa:	235c      	movs	r3, #92	; 0x5c
   1e2fc:	fb03 6000 	mla	r0, r3, r0, r6
    if ( (msgType == TCPIP_DHCP_DECLINE_MESSAGE) || (msgType == TCPIP_DHCP_REQUEST_MESSAGE) ||  
   1e300:	1eeb      	subs	r3, r5, #3
   1e302:	2b01      	cmp	r3, #1
   1e304:	d905      	bls.n	1e312 <_DHCPOptionWriteIPRequest+0x26>
   1e306:	2d01      	cmp	r5, #1
   1e308:	d001      	beq.n	1e30e <_DHCPOptionWriteIPRequest+0x22>
    return 0;
   1e30a:	2000      	movs	r0, #0
   1e30c:	e00d      	b.n	1e32a <_DHCPOptionWriteIPRequest+0x3e>
            ((msgType == TCPIP_DHCP_DISCOVER_MESSAGE) && pClient->dhcpIPAddress.Val))
   1e30e:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   1e310:	b163      	cbz	r3, 1e32c <_DHCPOptionWriteIPRequest+0x40>
        if(pSendData->writeSpace >= sizeof(*pReqAdd))
   1e312:	6863      	ldr	r3, [r4, #4]
   1e314:	2b05      	cmp	r3, #5
   1e316:	d90b      	bls.n	1e330 <_DHCPOptionWriteIPRequest+0x44>
            pReqAdd = (TCPIP_DHCP_OPTION_DATA_REQUEST_IP_ADDRESS*)pSendData->pOpt;
   1e318:	6823      	ldr	r3, [r4, #0]
            pReqAdd->opt = TCPIP_DHCP_PARAM_REQUEST_IP_ADDRESS;
   1e31a:	2232      	movs	r2, #50	; 0x32
   1e31c:	701a      	strb	r2, [r3, #0]
            pReqAdd->len = sizeof(pReqAdd->reqIpAddr);
   1e31e:	2204      	movs	r2, #4
   1e320:	705a      	strb	r2, [r3, #1]
            memcpy(pReqAdd->reqIpAddr, pClient->dhcpIPAddress.v, sizeof(pReqAdd->reqIpAddr));
   1e322:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   1e324:	f8c3 2002 	str.w	r2, [r3, #2]
            return sizeof(*pReqAdd);
   1e328:	2006      	movs	r0, #6
}
   1e32a:	bd70      	pop	{r4, r5, r6, pc}
    return 0;
   1e32c:	2000      	movs	r0, #0
   1e32e:	e7fc      	b.n	1e32a <_DHCPOptionWriteIPRequest+0x3e>
        return -1;
   1e330:	f04f 30ff 	mov.w	r0, #4294967295
   1e334:	e7f9      	b.n	1e32a <_DHCPOptionWriteIPRequest+0x3e>
   1e336:	bf00      	nop
   1e338:	2000ee3c 	.word	0x2000ee3c

Disassembly of section .text.TCPIP_DHCP_Renew%581:

0001e33c <TCPIP_DHCP_Renew>:
   1e33c:	b170      	cbz	r0, 1e35c <TCPIP_DHCP_Renew+0x20>
{
   1e33e:	b538      	push	{r3, r4, r5, lr}
   1e340:	4604      	mov	r4, r0
   1e342:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1e346:	f012 0f40 	tst.w	r2, #64	; 0x40
   1e34a:	d10b      	bne.n	1e364 <TCPIP_DHCP_Renew+0x28>
        return false;
   1e34c:	2000      	movs	r0, #0
}
   1e34e:	bd38      	pop	{r3, r4, r5, pc}
        _DHCPEnable(pNetIf, opType);
   1e350:	2103      	movs	r1, #3
   1e352:	4620      	mov	r0, r4
   1e354:	f7fb fc50 	bl	19bf8 <_DHCPEnable>
        return true;
   1e358:	2001      	movs	r0, #1
   1e35a:	e7f8      	b.n	1e34e <TCPIP_DHCP_Renew+0x12>
        return false;
   1e35c:	2000      	movs	r0, #0
}
   1e35e:	4770      	bx	lr
        return false;
   1e360:	2000      	movs	r0, #0
    return _DHCPStartOperation(_TCPIPStackHandleToNetUp(hNet), TCPIP_DHCP_OP_REQ_RENEW, 0);
   1e362:	e7f4      	b.n	1e34e <TCPIP_DHCP_Renew+0x12>
    if(DHCPClients == 0 || pNetIf == 0)
   1e364:	4a08      	ldr	r2, [pc, #32]	; (1e388 <TCPIP_DHCP_Renew+0x4c>)
   1e366:	6815      	ldr	r5, [r2, #0]
   1e368:	2d00      	cmp	r5, #0
   1e36a:	d0f9      	beq.n	1e360 <TCPIP_DHCP_Renew+0x24>
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   1e36c:	4620      	mov	r0, r4
   1e36e:	f005 fde3 	bl	23f38 <TCPIP_STACK_NetIxGet>
            if(pClient->flags.bDHCPEnabled != 0 && pClient->flags.bIsBound != 0)
   1e372:	235c      	movs	r3, #92	; 0x5c
   1e374:	fb03 5000 	mla	r0, r3, r0, r5
   1e378:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   1e37c:	f003 0303 	and.w	r3, r3, #3
   1e380:	2b03      	cmp	r3, #3
   1e382:	d0e5      	beq.n	1e350 <TCPIP_DHCP_Renew+0x14>
    return false;
   1e384:	2000      	movs	r0, #0
   1e386:	e7e2      	b.n	1e34e <TCPIP_DHCP_Renew+0x12>
   1e388:	2000ee3c 	.word	0x2000ee3c

Disassembly of section .text.TCPIP_DNS_OAHASH_DeleteEntry%582:

0001e38c <TCPIP_DNS_OAHASH_DeleteEntry>:
{
   1e38c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    pDnsDcpt = pgDnsDcpt;
   1e38e:	4b12      	ldr	r3, [pc, #72]	; (1e3d8 <TCPIP_DNS_OAHASH_DeleteEntry+0x4c>)
   1e390:	681e      	ldr	r6, [r3, #0]
    currTime = pDnsDcpt->dnsTime;
   1e392:	69f7      	ldr	r7, [r6, #28]
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   1e394:	68c3      	ldr	r3, [r0, #12]
   1e396:	b1eb      	cbz	r3, 1e3d4 <TCPIP_DNS_OAHASH_DeleteEntry+0x48>
   1e398:	4605      	mov	r5, r0
   1e39a:	2400      	movs	r4, #0
   1e39c:	e007      	b.n	1e3ae <TCPIP_DNS_OAHASH_DeleteEntry+0x22>
            if((currTime - pE->tInsert) >= timeout)
   1e39e:	6883      	ldr	r3, [r0, #8]
   1e3a0:	1afb      	subs	r3, r7, r3
   1e3a2:	4293      	cmp	r3, r2
   1e3a4:	d215      	bcs.n	1e3d2 <TCPIP_DNS_OAHASH_DeleteEntry+0x46>
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   1e3a6:	3401      	adds	r4, #1
   1e3a8:	68eb      	ldr	r3, [r5, #12]
   1e3aa:	42a3      	cmp	r3, r4
   1e3ac:	d910      	bls.n	1e3d0 <TCPIP_DNS_OAHASH_DeleteEntry+0x44>
        pBkt = TCPIP_OAHASH_EntryGet(pOH, bktIx);       
   1e3ae:	4621      	mov	r1, r4
   1e3b0:	4628      	mov	r0, r5
   1e3b2:	f005 fc52 	bl	23c5a <TCPIP_OAHASH_EntryGet>
        if(pBkt->flags.busy != 0 && (pBkt->flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) != 0)
   1e3b6:	7803      	ldrb	r3, [r0, #0]
   1e3b8:	f013 0f01 	tst.w	r3, #1
   1e3bc:	d0f3      	beq.n	1e3a6 <TCPIP_DNS_OAHASH_DeleteEntry+0x1a>
   1e3be:	8803      	ldrh	r3, [r0, #0]
   1e3c0:	f013 0f80 	tst.w	r3, #128	; 0x80
   1e3c4:	d0ef      	beq.n	1e3a6 <TCPIP_DNS_OAHASH_DeleteEntry+0x1a>
            timeout = (pDnsDcpt->cacheEntryTMO > 0) ? pDnsDcpt->cacheEntryTMO : pE->ipTTL.Val;
   1e3c6:	6972      	ldr	r2, [r6, #20]
   1e3c8:	2a00      	cmp	r2, #0
   1e3ca:	d1e8      	bne.n	1e39e <TCPIP_DNS_OAHASH_DeleteEntry+0x12>
   1e3cc:	6982      	ldr	r2, [r0, #24]
   1e3ce:	e7e6      	b.n	1e39e <TCPIP_DNS_OAHASH_DeleteEntry+0x12>
    return 0;
   1e3d0:	2000      	movs	r0, #0
}
   1e3d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return 0;
   1e3d4:	2000      	movs	r0, #0
   1e3d6:	e7fc      	b.n	1e3d2 <TCPIP_DNS_OAHASH_DeleteEntry+0x46>
   1e3d8:	2000ee58 	.word	0x2000ee58

Disassembly of section .text.TCPIP_Helper_FormatNetBIOSName%583:

0001e3dc <TCPIP_Helper_FormatNetBIOSName>:

  Returns:
	None
  ***************************************************************************/
void TCPIP_Helper_FormatNetBIOSName(uint8_t Name[])
{
   1e3dc:	b470      	push	{r4, r5, r6}
	uint8_t i;

	Name[15] = '\0';
   1e3de:	2200      	movs	r2, #0
   1e3e0:	73c2      	strb	r2, [r0, #15]
	i = 0;
	while(i < 15u)
   1e3e2:	1e41      	subs	r1, r0, #1
	{
        Name[i] = toupper(Name[i]);
   1e3e4:	4e10      	ldr	r6, [pc, #64]	; (1e428 <TCPIP_Helper_FormatNetBIOSName+0x4c>)
   1e3e6:	3101      	adds	r1, #1
   1e3e8:	780b      	ldrb	r3, [r1, #0]
   1e3ea:	5d9c      	ldrb	r4, [r3, r6]
   1e3ec:	f004 0403 	and.w	r4, r4, #3
   1e3f0:	2c02      	cmp	r4, #2
   1e3f2:	bf08      	it	eq
   1e3f4:	3b20      	subeq	r3, #32
   1e3f6:	b2db      	uxtb	r3, r3
   1e3f8:	700b      	strb	r3, [r1, #0]
		if(Name[i] == '\0')
   1e3fa:	b12b      	cbz	r3, 1e408 <TCPIP_Helper_FormatNetBIOSName+0x2c>
			{
				Name[i++] = ' ';
			}
			break;
		}
		i++;
   1e3fc:	3201      	adds	r2, #1
   1e3fe:	b2d2      	uxtb	r2, r2
	while(i < 15u)
   1e400:	2a0f      	cmp	r2, #15
   1e402:	d1f0      	bne.n	1e3e6 <TCPIP_Helper_FormatNetBIOSName+0xa>
	}
}
   1e404:	bc70      	pop	{r4, r5, r6}
   1e406:	4770      	bx	lr
			while(i < 15u)
   1e408:	2a0e      	cmp	r2, #14
   1e40a:	d8fb      	bhi.n	1e404 <TCPIP_Helper_FormatNetBIOSName+0x28>
   1e40c:	1883      	adds	r3, r0, r2
   1e40e:	3001      	adds	r0, #1
   1e410:	4410      	add	r0, r2
   1e412:	f1c2 020e 	rsb	r2, r2, #14
   1e416:	fa50 f282 	uxtab	r2, r0, r2
				Name[i++] = ' ';
   1e41a:	2120      	movs	r1, #32
   1e41c:	f803 1b01 	strb.w	r1, [r3], #1
			while(i < 15u)
   1e420:	4293      	cmp	r3, r2
   1e422:	d1fb      	bne.n	1e41c <TCPIP_Helper_FormatNetBIOSName+0x40>
   1e424:	e7ee      	b.n	1e404 <TCPIP_Helper_FormatNetBIOSName+0x28>
   1e426:	bf00      	nop
   1e428:	00015855 	.word	0x00015855

Disassembly of section .text._DHCPSDescriptorGetFromIntf%584:

0001e42c <_DHCPSDescriptorGetFromIntf>:
    for(ix = 0, pDhcpServDcpt = gPdhcpSDcpt; ix < dhcps_mod.poolCount; ix++, pDhcpServDcpt++)
   1e42c:	4b11      	ldr	r3, [pc, #68]	; (1e474 <_DHCPSDescriptorGetFromIntf+0x48>)
   1e42e:	681b      	ldr	r3, [r3, #0]
   1e430:	4a11      	ldr	r2, [pc, #68]	; (1e478 <_DHCPSDescriptorGetFromIntf+0x4c>)
   1e432:	6852      	ldr	r2, [r2, #4]
   1e434:	b1aa      	cbz	r2, 1e462 <_DHCPSDescriptorGetFromIntf+0x36>
        if(pDhcpServDcpt == NULL)
   1e436:	b1d3      	cbz	r3, 1e46e <_DHCPSDescriptorGetFromIntf+0x42>
{
   1e438:	b430      	push	{r4, r5}
        if(pNetIf->netIfIx != pDhcpServDcpt->netIx)
   1e43a:	f8b0 4058 	ldrh.w	r4, [r0, #88]	; 0x58
   1e43e:	6998      	ldr	r0, [r3, #24]
   1e440:	4284      	cmp	r4, r0
   1e442:	d009      	beq.n	1e458 <_DHCPSDescriptorGetFromIntf+0x2c>
   1e444:	4610      	mov	r0, r2
    for(ix = 0, pDhcpServDcpt = gPdhcpSDcpt; ix < dhcps_mod.poolCount; ix++, pDhcpServDcpt++)
   1e446:	2200      	movs	r2, #0
   1e448:	3201      	adds	r2, #1
   1e44a:	331c      	adds	r3, #28
   1e44c:	4290      	cmp	r0, r2
   1e44e:	d00a      	beq.n	1e466 <_DHCPSDescriptorGetFromIntf+0x3a>
        if(pDhcpServDcpt == NULL)
   1e450:	b15b      	cbz	r3, 1e46a <_DHCPSDescriptorGetFromIntf+0x3e>
        if(pNetIf->netIfIx != pDhcpServDcpt->netIx)
   1e452:	699d      	ldr	r5, [r3, #24]
   1e454:	42a5      	cmp	r5, r4
   1e456:	d1f7      	bne.n	1e448 <_DHCPSDescriptorGetFromIntf+0x1c>
            *dcptIdx = pDhcpServDcpt->intfAddrsConf.poolIndex;
   1e458:	695b      	ldr	r3, [r3, #20]
   1e45a:	600b      	str	r3, [r1, #0]
            return true;
   1e45c:	2001      	movs	r0, #1
}
   1e45e:	bc30      	pop	{r4, r5}
   1e460:	4770      	bx	lr
    return false;
   1e462:	2000      	movs	r0, #0
   1e464:	4770      	bx	lr
   1e466:	2000      	movs	r0, #0
   1e468:	e7f9      	b.n	1e45e <_DHCPSDescriptorGetFromIntf+0x32>
            return false;
   1e46a:	2000      	movs	r0, #0
   1e46c:	e7f7      	b.n	1e45e <_DHCPSDescriptorGetFromIntf+0x32>
   1e46e:	2000      	movs	r0, #0
}
   1e470:	4770      	bx	lr
   1e472:	bf00      	nop
   1e474:	2000eec8 	.word	0x2000eec8
   1e478:	2000ed3c 	.word	0x2000ed3c

Disassembly of section .text._DHCPServerCleanup%585:

0001e47c <_DHCPServerCleanup>:
{
   1e47c:	b510      	push	{r4, lr}
    if(gPdhcpsHashDcpt.hashDcpt != NULL)
   1e47e:	4b0f      	ldr	r3, [pc, #60]	; (1e4bc <_DHCPServerCleanup+0x40>)
   1e480:	681b      	ldr	r3, [r3, #0]
   1e482:	b153      	cbz	r3, 1e49a <_DHCPServerCleanup+0x1e>
        _DHCPSRemoveCacheEntries(&gPdhcpsHashDcpt);
   1e484:	4c0d      	ldr	r4, [pc, #52]	; (1e4bc <_DHCPServerCleanup+0x40>)
   1e486:	4620      	mov	r0, r4
   1e488:	f005 fd64 	bl	23f54 <_DHCPSRemoveCacheEntries>
        TCPIP_HEAP_Free(dhcpSMemH,gPdhcpsHashDcpt.hashDcpt);
   1e48c:	4b0c      	ldr	r3, [pc, #48]	; (1e4c0 <_DHCPServerCleanup+0x44>)
   1e48e:	6818      	ldr	r0, [r3, #0]
   1e490:	68c3      	ldr	r3, [r0, #12]
   1e492:	6821      	ldr	r1, [r4, #0]
   1e494:	4798      	blx	r3
        gPdhcpsHashDcpt.hashDcpt = 0;
   1e496:	2300      	movs	r3, #0
   1e498:	6023      	str	r3, [r4, #0]
    if(gPdhcpSDcpt != NULL)
   1e49a:	4b0a      	ldr	r3, [pc, #40]	; (1e4c4 <_DHCPServerCleanup+0x48>)
   1e49c:	6819      	ldr	r1, [r3, #0]
   1e49e:	b119      	cbz	r1, 1e4a8 <_DHCPServerCleanup+0x2c>
        TCPIP_HEAP_Free(dhcpSMemH,gPdhcpSDcpt);
   1e4a0:	4b07      	ldr	r3, [pc, #28]	; (1e4c0 <_DHCPServerCleanup+0x44>)
   1e4a2:	6818      	ldr	r0, [r3, #0]
   1e4a4:	68c3      	ldr	r3, [r0, #12]
   1e4a6:	4798      	blx	r3
    if(dhcps_mod.signalHandle)
   1e4a8:	4b07      	ldr	r3, [pc, #28]	; (1e4c8 <_DHCPServerCleanup+0x4c>)
   1e4aa:	68d8      	ldr	r0, [r3, #12]
   1e4ac:	b120      	cbz	r0, 1e4b8 <_DHCPServerCleanup+0x3c>
        _TCPIPStackSignalHandlerDeregister(dhcps_mod.signalHandle);
   1e4ae:	f005 fd4a 	bl	23f46 <_TCPIPStackSignalHandlerDeregister>
        dhcps_mod.signalHandle = 0;
   1e4b2:	4b05      	ldr	r3, [pc, #20]	; (1e4c8 <_DHCPServerCleanup+0x4c>)
   1e4b4:	2200      	movs	r2, #0
   1e4b6:	60da      	str	r2, [r3, #12]
}
   1e4b8:	bd10      	pop	{r4, pc}
   1e4ba:	bf00      	nop
   1e4bc:	2000ed7c 	.word	0x2000ed7c
   1e4c0:	2000eea4 	.word	0x2000eea4
   1e4c4:	2000eec8 	.word	0x2000eec8
   1e4c8:	2000ed3c 	.word	0x2000ed3c

Disassembly of section .text.SYS_CONSOLE_Status%586:

0001e4cc <SYS_CONSOLE_Status>:
{
   1e4cc:	b508      	push	{r3, lr}
    if (index >= SYS_CONSOLE_DEVICE_MAX_INSTANCES)
   1e4ce:	b283      	uxth	r3, r0
   1e4d0:	b9cb      	cbnz	r3, 1e506 <SYS_CONSOLE_Status+0x3a>
    pConsoleObj = &consoleDeviceInstance[index];
   1e4d2:	4618      	mov	r0, r3
    if (pConsoleObj->devDesc == NULL)
   1e4d4:	eb03 0243 	add.w	r2, r3, r3, lsl #1
   1e4d8:	4b0f      	ldr	r3, [pc, #60]	; (1e518 <SYS_CONSOLE_Status+0x4c>)
   1e4da:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   1e4de:	685a      	ldr	r2, [r3, #4]
   1e4e0:	b1a2      	cbz	r2, 1e50c <SYS_CONSOLE_Status+0x40>
    status = pConsoleObj->devDesc->status(pConsoleObj->devIndex);
   1e4e2:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   1e4e6:	4b0c      	ldr	r3, [pc, #48]	; (1e518 <SYS_CONSOLE_Status+0x4c>)
   1e4e8:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1e4ec:	6a53      	ldr	r3, [r2, #36]	; 0x24
   1e4ee:	6880      	ldr	r0, [r0, #8]
   1e4f0:	4798      	blx	r3
    switch (status)
   1e4f2:	2801      	cmp	r0, #1
   1e4f4:	d00c      	beq.n	1e510 <SYS_CONSOLE_Status+0x44>
   1e4f6:	b243      	sxtb	r3, r0
   1e4f8:	b163      	cbz	r3, 1e514 <SYS_CONSOLE_Status+0x48>
    SYS_STATUS ret = SYS_STATUS_ERROR;
   1e4fa:	2802      	cmp	r0, #2
   1e4fc:	bf0c      	ite	eq
   1e4fe:	2001      	moveq	r0, #1
   1e500:	f04f 30ff 	movne.w	r0, #4294967295
}
   1e504:	bd08      	pop	{r3, pc}
        return SYS_STATUS_ERROR;
   1e506:	f04f 30ff 	mov.w	r0, #4294967295
   1e50a:	e7fb      	b.n	1e504 <SYS_CONSOLE_Status+0x38>
        return SYS_STATUS_UNINITIALIZED;
   1e50c:	2000      	movs	r0, #0
   1e50e:	e7f9      	b.n	1e504 <SYS_CONSOLE_Status+0x38>
            ret = SYS_STATUS_READY;
   1e510:	2002      	movs	r0, #2
   1e512:	e7f7      	b.n	1e504 <SYS_CONSOLE_Status+0x38>
            ret = SYS_STATUS_UNINITIALIZED;
   1e514:	2000      	movs	r0, #0
   1e516:	e7f5      	b.n	1e504 <SYS_CONSOLE_Status+0x38>
   1e518:	2000ed64 	.word	0x2000ed64

Disassembly of section .rodata.TCPIP_STACK_MODULE_CONFIG_TBL%587:

0001e51c <TCPIP_STACK_MODULE_CONFIG_TBL>:
   1e51c:	00000003 00023e30 00000006 00000000     ....0>..........
   1e52c:	00000002 000222b4 00000009 00024428     ....."......(D..
   1e53c:	0000000a 00024420 0000000c 00023e20     .... D...... >..
   1e54c:	0000000d 00023b98 0000000f 000238c4     .....;.......8..
   1e55c:	00000001 2000ec8c 00001050 00020d9c     ....... P.......

Disassembly of section .text._raise_r%588:

0001e56c <_raise_r>:
   1e56c:	291f      	cmp	r1, #31
   1e56e:	b538      	push	{r3, r4, r5, lr}
   1e570:	4604      	mov	r4, r0
   1e572:	460d      	mov	r5, r1
   1e574:	d904      	bls.n	1e580 <_raise_r+0x14>
   1e576:	2316      	movs	r3, #22
   1e578:	6003      	str	r3, [r0, #0]
   1e57a:	f04f 30ff 	mov.w	r0, #4294967295
   1e57e:	bd38      	pop	{r3, r4, r5, pc}
   1e580:	6c42      	ldr	r2, [r0, #68]	; 0x44
   1e582:	b112      	cbz	r2, 1e58a <_raise_r+0x1e>
   1e584:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   1e588:	b94b      	cbnz	r3, 1e59e <_raise_r+0x32>
   1e58a:	4620      	mov	r0, r4
   1e58c:	f005 ff92 	bl	244b4 <_getpid_r>
   1e590:	462a      	mov	r2, r5
   1e592:	4601      	mov	r1, r0
   1e594:	4620      	mov	r0, r4
   1e596:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1e59a:	f004 b92f 	b.w	227fc <_kill_r>
   1e59e:	2b01      	cmp	r3, #1
   1e5a0:	d00a      	beq.n	1e5b8 <_raise_r+0x4c>
   1e5a2:	1c5c      	adds	r4, r3, #1
   1e5a4:	d103      	bne.n	1e5ae <_raise_r+0x42>
   1e5a6:	2316      	movs	r3, #22
   1e5a8:	6003      	str	r3, [r0, #0]
   1e5aa:	2001      	movs	r0, #1
   1e5ac:	e7e7      	b.n	1e57e <_raise_r+0x12>
   1e5ae:	2400      	movs	r4, #0
   1e5b0:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
   1e5b4:	4608      	mov	r0, r1
   1e5b6:	4798      	blx	r3
   1e5b8:	2000      	movs	r0, #0
   1e5ba:	e7e0      	b.n	1e57e <_raise_r+0x12>

Disassembly of section .text%589:

0001e5bc <__aeabi_d2iz>:
   1e5bc:	ea4f 0241 	mov.w	r2, r1, lsl #1
   1e5c0:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   1e5c4:	d215      	bcs.n	1e5f2 <__aeabi_d2iz+0x36>
   1e5c6:	d511      	bpl.n	1e5ec <__aeabi_d2iz+0x30>
   1e5c8:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   1e5cc:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   1e5d0:	d912      	bls.n	1e5f8 <__aeabi_d2iz+0x3c>
   1e5d2:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   1e5d6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1e5da:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   1e5de:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   1e5e2:	fa23 f002 	lsr.w	r0, r3, r2
   1e5e6:	bf18      	it	ne
   1e5e8:	4240      	negne	r0, r0
   1e5ea:	4770      	bx	lr
   1e5ec:	f04f 0000 	mov.w	r0, #0
   1e5f0:	4770      	bx	lr
   1e5f2:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   1e5f6:	d105      	bne.n	1e604 <__aeabi_d2iz+0x48>
   1e5f8:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
   1e5fc:	bf08      	it	eq
   1e5fe:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
   1e602:	4770      	bx	lr
   1e604:	f04f 0000 	mov.w	r0, #0
   1e608:	4770      	bx	lr
   1e60a:	bf00      	nop

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase7%590:

0001e60c <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase7>:
{
   1e60c:	b508      	push	{r3, lr}
    openFlags = hClientObj->hDriver->openFlags;
   1e60e:	68c1      	ldr	r1, [r0, #12]
   1e610:	898b      	ldrh	r3, [r1, #12]
    matchCpbl = hClientObj->operReg[1];
   1e612:	8c82      	ldrh	r2, [r0, #36]	; 0x24
    openFlags &= ~(TCPIP_ETH_OPEN_AUTO | TCPIP_ETH_OPEN_FDUPLEX | TCPIP_ETH_OPEN_HDUPLEX | TCPIP_ETH_OPEN_100|TCPIP_ETH_OPEN_10);
   1e614:	f023 031f 	bic.w	r3, r3, #31
   1e618:	b29b      	uxth	r3, r3
    if(matchCpbl & _BMSTAT_AN_ABLE_MASK)
   1e61a:	f012 0f08 	tst.w	r2, #8
        openFlags |= TCPIP_ETH_OPEN_AUTO;
   1e61e:	bf18      	it	ne
   1e620:	f043 0301 	orrne.w	r3, r3, #1
    if(matchCpbl & (_BMSTAT_BASE100TX_HDX_MASK | _BMSTAT_BASE100TX_FDX_MASK))   // set 100Mbps request/capability
   1e624:	f412 4fc0 	tst.w	r2, #24576	; 0x6000
        openFlags |= TCPIP_ETH_OPEN_100;
   1e628:	bf18      	it	ne
   1e62a:	f043 0308 	orrne.w	r3, r3, #8
    if(matchCpbl & (_BMSTAT_BASE10T_HDX_MASK | _BMSTAT_BASE10T_FDX_MASK))   // set 10Mbps request/capability
   1e62e:	f412 5fc0 	tst.w	r2, #6144	; 0x1800
        openFlags |= TCPIP_ETH_OPEN_10;
   1e632:	bf18      	it	ne
   1e634:	f043 0310 	orrne.w	r3, r3, #16
    if(matchCpbl & (_BMSTAT_BASE10T_FDX_MASK | _BMSTAT_BASE100TX_FDX_MASK))
   1e638:	f412 4fa0 	tst.w	r2, #20480	; 0x5000
        openFlags |= TCPIP_ETH_OPEN_FDUPLEX;
   1e63c:	bf18      	it	ne
   1e63e:	f043 0302 	orrne.w	r3, r3, #2
    if(matchCpbl & (_BMSTAT_BASE10T_HDX_MASK | _BMSTAT_BASE100TX_HDX_MASK))
   1e642:	f412 5f20 	tst.w	r2, #10240	; 0x2800
        openFlags |= TCPIP_ETH_OPEN_HDUPLEX;
   1e646:	bf18      	it	ne
   1e648:	f043 0304 	orrne.w	r3, r3, #4
    hClientObj->hDriver->openFlags = openFlags;
   1e64c:	818b      	strh	r3, [r1, #12]
    *pSetUpFlags = openFlags;
   1e64e:	6b02      	ldr	r2, [r0, #48]	; 0x30
   1e650:	8013      	strh	r3, [r2, #0]
    _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OK);
   1e652:	2100      	movs	r1, #0
   1e654:	f003 fbea 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
} 
   1e658:	bd08      	pop	{r3, pc}

Disassembly of section .text._DRV_MIIM_GetClientAndLock%591:

0001e65a <_DRV_MIIM_GetClientAndLock>:
    if(pClient != 0)
   1e65a:	b1e8      	cbz	r0, 1e698 <_DRV_MIIM_GetClientAndLock+0x3e>
{
   1e65c:	b510      	push	{r4, lr}
   1e65e:	4604      	mov	r4, r0
        if(pClient->clientInUse != 0 && pClient->cliStatus == DRV_MIIM_CLIENT_STATUS_READY)
   1e660:	8802      	ldrh	r2, [r0, #0]
   1e662:	b1da      	cbz	r2, 1e69c <_DRV_MIIM_GetClientAndLock+0x42>
   1e664:	f990 200c 	ldrsb.w	r2, [r0, #12]
   1e668:	2a02      	cmp	r2, #2
   1e66a:	d119      	bne.n	1e6a0 <_DRV_MIIM_GetClientAndLock+0x46>
            if(lock)
   1e66c:	b969      	cbnz	r1, 1e68a <_DRV_MIIM_GetClientAndLock+0x30>
                pMiimObj = _DRV_MIIM_GetObject((SYS_MODULE_OBJ)pClient->parentObj);
   1e66e:	6840      	ldr	r0, [r0, #4]
    if(pMiimObj != 0)
   1e670:	b1b8      	cbz	r0, 1e6a2 <_DRV_MIIM_GetClientAndLock+0x48>
        if(pMiimObj->objStatus == SYS_STATUS_READY && (pMiimObj->objFlags & DRV_MIIM_OBJ_FLAG_IN_USE) != 0)
   1e672:	f990 2008 	ldrsb.w	r2, [r0, #8]
   1e676:	2a02      	cmp	r2, #2
   1e678:	d114      	bne.n	1e6a4 <_DRV_MIIM_GetClientAndLock+0x4a>
   1e67a:	8882      	ldrh	r2, [r0, #4]
   1e67c:	f002 0201 	and.w	r2, r2, #1
                return pClient;
   1e680:	2a00      	cmp	r2, #0
   1e682:	bf14      	ite	ne
   1e684:	4620      	movne	r0, r4
   1e686:	2000      	moveq	r0, #0
   1e688:	e00b      	b.n	1e6a2 <_DRV_MIIM_GetClientAndLock+0x48>
                pMiimObj = _DRV_MIIM_GetObjectAndLock((SYS_MODULE_OBJ)pClient->parentObj);
   1e68a:	6840      	ldr	r0, [r0, #4]
   1e68c:	f002 ffd5 	bl	2163a <_DRV_MIIM_GetObjectAndLock>
            if(pMiimObj != 0)
   1e690:	2800      	cmp	r0, #0
                return pClient;
   1e692:	bf18      	it	ne
   1e694:	4620      	movne	r0, r4
   1e696:	e004      	b.n	1e6a2 <_DRV_MIIM_GetClientAndLock+0x48>
    return 0;
   1e698:	2000      	movs	r0, #0
}
   1e69a:	4770      	bx	lr
    return 0;
   1e69c:	2000      	movs	r0, #0
   1e69e:	e000      	b.n	1e6a2 <_DRV_MIIM_GetClientAndLock+0x48>
   1e6a0:	2000      	movs	r0, #0
}
   1e6a2:	bd10      	pop	{r4, pc}
    return 0;
   1e6a4:	2000      	movs	r0, #0
   1e6a6:	e7fc      	b.n	1e6a2 <_DRV_MIIM_GetClientAndLock+0x48>

Disassembly of section .text.TCPIP_IPV4_SelectDestInterface%592:

0001e6a8 <TCPIP_IPV4_SelectDestInterface>:
    if(pDestAddress == 0 || pDestAddress->Val == 0)
   1e6a8:	b310      	cbz	r0, 1e6f0 <TCPIP_IPV4_SelectDestInterface+0x48>
{
   1e6aa:	b570      	push	{r4, r5, r6, lr}
   1e6ac:	4605      	mov	r5, r0
    if(pDestAddress == 0 || pDestAddress->Val == 0)
   1e6ae:	6803      	ldr	r3, [r0, #0]
   1e6b0:	b1fb      	cbz	r3, 1e6f2 <TCPIP_IPV4_SelectDestInterface+0x4a>
    if((avlblInterfaces = TCPIP_STACK_NumberOfNetworksGet()) > 1)
   1e6b2:	f005 fdc1 	bl	24238 <TCPIP_STACK_NumberOfNetworksGet>
   1e6b6:	4606      	mov	r6, r0
   1e6b8:	2801      	cmp	r0, #1
   1e6ba:	dd13      	ble.n	1e6e4 <TCPIP_IPV4_SelectDestInterface+0x3c>
        for(netIx = 0; netIx < avlblInterfaces; netIx++)
   1e6bc:	2400      	movs	r4, #0
   1e6be:	e002      	b.n	1e6c6 <TCPIP_IPV4_SelectDestInterface+0x1e>
   1e6c0:	3401      	adds	r4, #1
   1e6c2:	42a6      	cmp	r6, r4
   1e6c4:	d00e      	beq.n	1e6e4 <TCPIP_IPV4_SelectDestInterface+0x3c>
            pIf = _TCPIPStackHandleToNetLinked(TCPIP_STACK_IndexToNet(netIx));
   1e6c6:	4620      	mov	r0, r4
   1e6c8:	f003 fcdc 	bl	22084 <TCPIP_STACK_IndexToNet>
   1e6cc:	f004 fab8 	bl	22c40 <_TCPIPStackHandleToNetLinked>
            if(pIf)
   1e6d0:	4602      	mov	r2, r0
   1e6d2:	2800      	cmp	r0, #0
   1e6d4:	d0f4      	beq.n	1e6c0 <TCPIP_IPV4_SelectDestInterface+0x18>
                if((ifAdd & ifMask) == (pDestAddress->Val & ifMask))
   1e6d6:	682b      	ldr	r3, [r5, #0]
   1e6d8:	6841      	ldr	r1, [r0, #4]
   1e6da:	404b      	eors	r3, r1
   1e6dc:	6881      	ldr	r1, [r0, #8]
   1e6de:	420b      	tst	r3, r1
   1e6e0:	d1ee      	bne.n	1e6c0 <TCPIP_IPV4_SelectDestInterface+0x18>
   1e6e2:	e003      	b.n	1e6ec <TCPIP_IPV4_SelectDestInterface+0x44>
    return _TCPIPStackAnyNetLinked(true);
   1e6e4:	2001      	movs	r0, #1
   1e6e6:	f7ff fc13 	bl	1df10 <_TCPIPStackAnyNetLinked>
   1e6ea:	4602      	mov	r2, r0
}
   1e6ec:	4610      	mov	r0, r2
   1e6ee:	bd70      	pop	{r4, r5, r6, pc}
   1e6f0:	4770      	bx	lr
        return 0;
   1e6f2:	2200      	movs	r2, #0
   1e6f4:	e7fa      	b.n	1e6ec <TCPIP_IPV4_SelectDestInterface+0x44>

Disassembly of section .text.TCPIP_UDP_PutIsReady%593:

0001e6f6 <TCPIP_UDP_PutIsReady>:
{
   1e6f6:	b510      	push	{r4, lr}
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1e6f8:	f003 fd28 	bl	2214c <_UDPSocketDcpt>
    if(pSkt == 0)
   1e6fc:	b300      	cbz	r0, 1e740 <TCPIP_UDP_PutIsReady+0x4a>
   1e6fe:	4604      	mov	r4, r0
    if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   1e700:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
   1e702:	2b01      	cmp	r3, #1
    return 0;   // can happen if it is a server socket and opened with IP_ADDRESS_TYPE_ANY
   1e704:	bf18      	it	ne
   1e706:	2000      	movne	r0, #0
    if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   1e708:	d000      	beq.n	1e70c <TCPIP_UDP_PutIsReady+0x16>
}
   1e70a:	bd10      	pop	{r4, pc}
    void* pPkt = _TxSktGetLockedV4Pkt(pSkt, true);
   1e70c:	2101      	movs	r1, #1
   1e70e:	f003 f891 	bl	21834 <_TxSktGetLockedV4Pkt>
    if(pPkt == 0)
   1e712:	b138      	cbz	r0, 1e724 <TCPIP_UDP_PutIsReady+0x2e>
    if(pSkt->flags.txSplitAlloc == 0)
   1e714:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
   1e718:	f013 0f02 	tst.w	r3, #2
   1e71c:	d00b      	beq.n	1e736 <TCPIP_UDP_PutIsReady+0x40>
    return 1514 - sizeof(TCPIP_MAC_ETHERNET_HEADER) - sizeof(IPV4_HEADER) - sizeof(UDP_HEADER);
   1e71e:	f44f 60b8 	mov.w	r0, #1472	; 0x5c0
   1e722:	e7f2      	b.n	1e70a <TCPIP_UDP_PutIsReady+0x14>
        if(_UDPv4AllocateSktTxBuffer(pSkt, IP_ADDRESS_TYPE_IPV4, true) == 0)
   1e724:	2201      	movs	r2, #1
   1e726:	4611      	mov	r1, r2
   1e728:	4620      	mov	r0, r4
   1e72a:	f7fa feb7 	bl	1949c <_UDPv4AllocateSktTxBuffer>
   1e72e:	2800      	cmp	r0, #0
   1e730:	d1f0      	bne.n	1e714 <TCPIP_UDP_PutIsReady+0x1e>
            return 0;
   1e732:	2000      	movs	r0, #0
   1e734:	e7e9      	b.n	1e70a <TCPIP_UDP_PutIsReady+0x14>
        return pSkt->txEnd - pSkt->txWrite;
   1e736:	6860      	ldr	r0, [r4, #4]
   1e738:	68a3      	ldr	r3, [r4, #8]
   1e73a:	1ac0      	subs	r0, r0, r3
   1e73c:	b280      	uxth	r0, r0
   1e73e:	e7e4      	b.n	1e70a <TCPIP_UDP_PutIsReady+0x14>
        return 0;
   1e740:	2000      	movs	r0, #0
   1e742:	e7e2      	b.n	1e70a <TCPIP_UDP_PutIsReady+0x14>

Disassembly of section .text._DRV_ETHPHY_LinkStatPhaseRead%594:

0001e744 <_DRV_ETHPHY_LinkStatPhaseRead>:
{
   1e744:	b510      	push	{r4, lr}
   1e746:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1e748:	f004 f8c4 	bl	228d4 <_DRV_PHY_SMITransfer_Wait>
   1e74c:	b1a0      	cbz	r0, 1e778 <_DRV_ETHPHY_LinkStatPhaseRead+0x34>
    if( phyStat.LINK_STAT != 0 || hClientObj->operReg[0] == 0)
   1e74e:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
   1e752:	f013 0f04 	tst.w	r3, #4
   1e756:	d101      	bne.n	1e75c <_DRV_ETHPHY_LinkStatPhaseRead+0x18>
   1e758:	8c62      	ldrh	r2, [r4, #34]	; 0x22
   1e75a:	b972      	cbnz	r2, 1e77a <_DRV_ETHPHY_LinkStatPhaseRead+0x36>
        DRV_ETHPHY_LINK_STATUS* pLinkStat = (DRV_ETHPHY_LINK_STATUS*)hClientObj->operParam;
   1e75c:	6b22      	ldr	r2, [r4, #48]	; 0x30
        if(pLinkStat)
   1e75e:	b13a      	cbz	r2, 1e770 <_DRV_ETHPHY_LinkStatPhaseRead+0x2c>
    linkStat = (phyStat.LINK_STAT)?DRV_ETHPHY_LINK_ST_UP:DRV_ETHPHY_LINK_ST_DOWN;
   1e760:	f3c3 0180 	ubfx	r1, r3, #2, #1
    if(phyStat.REM_FAULT)
   1e764:	f013 0f10 	tst.w	r3, #16
        linkStat|=DRV_ETHPHY_LINK_ST_REMOTE_FAULT;
   1e768:	bf18      	it	ne
   1e76a:	f041 0104 	orrne.w	r1, r1, #4
            *pLinkStat = _Phy2LinkStat(phyStat);
   1e76e:	8011      	strh	r1, [r2, #0]
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OK);
   1e770:	2100      	movs	r1, #0
   1e772:	4620      	mov	r0, r4
   1e774:	f003 fb5a 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
}
   1e778:	bd10      	pop	{r4, pc}
        if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   1e77a:	2101      	movs	r1, #1
   1e77c:	4620      	mov	r0, r4
   1e77e:	f002 fbf7 	bl	20f70 <_DRV_PHY_SMIReadStart>
   1e782:	2800      	cmp	r0, #0
   1e784:	d0f8      	beq.n	1e778 <_DRV_ETHPHY_LinkStatPhaseRead+0x34>
    hClientObj->operPhase = operPhase;
   1e786:	2302      	movs	r3, #2
   1e788:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1e78a:	2300      	movs	r3, #0
   1e78c:	8423      	strh	r3, [r4, #32]
   1e78e:	e7f3      	b.n	1e778 <_DRV_ETHPHY_LinkStatPhaseRead+0x34>

Disassembly of section .text._TcpSocketKill%595:

0001e790 <_TcpSocketKill>:
{
   1e790:	b538      	push	{r3, r4, r5, lr}
   1e792:	4604      	mov	r4, r0
    pSkt->smState = newState;
   1e794:	230c      	movs	r3, #12
   1e796:	f880 306e 	strb.w	r3, [r0, #110]	; 0x6e
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1e79a:	2000      	movs	r0, #0
   1e79c:	f004 ffea 	bl	23774 <OSAL_CRIT_Enter>
    TCBStubs[pSkt->sktIx] = 0;
   1e7a0:	f9b4 1034 	ldrsh.w	r1, [r4, #52]	; 0x34
   1e7a4:	4b0b      	ldr	r3, [pc, #44]	; (1e7d4 <_TcpSocketKill+0x44>)
   1e7a6:	681a      	ldr	r2, [r3, #0]
   1e7a8:	2300      	movs	r3, #0
   1e7aa:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   1e7ae:	4601      	mov	r1, r0
   1e7b0:	4618      	mov	r0, r3
   1e7b2:	f005 f919 	bl	239e8 <OSAL_CRIT_Leave>
    TCPIP_HEAP_Free(tcpHeapH, (void*)pSkt->rxStart);
   1e7b6:	4d08      	ldr	r5, [pc, #32]	; (1e7d8 <_TcpSocketKill+0x48>)
   1e7b8:	6828      	ldr	r0, [r5, #0]
   1e7ba:	68c3      	ldr	r3, [r0, #12]
   1e7bc:	6961      	ldr	r1, [r4, #20]
   1e7be:	4798      	blx	r3
    TCPIP_HEAP_Free(tcpHeapH, (void*)pSkt->txStart);
   1e7c0:	6828      	ldr	r0, [r5, #0]
   1e7c2:	68c3      	ldr	r3, [r0, #12]
   1e7c4:	6821      	ldr	r1, [r4, #0]
   1e7c6:	4798      	blx	r3
    TCPIP_HEAP_Free(tcpHeapH, pSkt);
   1e7c8:	6828      	ldr	r0, [r5, #0]
   1e7ca:	68c3      	ldr	r3, [r0, #12]
   1e7cc:	4621      	mov	r1, r4
   1e7ce:	4798      	blx	r3
}
   1e7d0:	bd38      	pop	{r3, r4, r5, pc}
   1e7d2:	bf00      	nop
   1e7d4:	2000edc0 	.word	0x2000edc0
   1e7d8:	2000edc8 	.word	0x2000edc8

Disassembly of section .text.ResetIperfCounters%596:

0001e7dc <ResetIperfCounters>:
    pIState->mMSS = IPERF_TCP_MSS;
   1e7dc:	f240 53b4 	movw	r3, #1460	; 0x5b4
   1e7e0:	f8a0 30d2 	strh.w	r3, [r0, #210]	; 0xd2
    pIState->mDatagramSize = 1470; // -l: default 1470 bytes. UDP datagram size.
   1e7e4:	f240 53be 	movw	r3, #1470	; 0x5be
   1e7e8:	60c3      	str	r3, [r0, #12]
    pIState->totalLen = 0;
   1e7ea:	2200      	movs	r2, #0
   1e7ec:	2300      	movs	r3, #0
   1e7ee:	e9c0 2308 	strd	r2, r3, [r0, #32]
    pIState->pktId = 0;
   1e7f2:	6283      	str	r3, [r0, #40]	; 0x28
    pIState->lastPktId = 0;
   1e7f4:	62c3      	str	r3, [r0, #44]	; 0x2c
    pIState->errorCount = 0;
   1e7f6:	6303      	str	r3, [r0, #48]	; 0x30
    pIState->outofOrder = 0;
   1e7f8:	6343      	str	r3, [r0, #52]	; 0x34
    pIState->pktCount = 0;
   1e7fa:	f8c0 3094 	str.w	r3, [r0, #148]	; 0x94
    pIState->statusReported = 0;
   1e7fe:	f880 30cd 	strb.w	r3, [r0, #205]	; 0xcd
    pIState->startTime = 0;
   1e802:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
    pIState->stopTime = 0;
   1e806:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
    pIState->lastCheckPktCount = 0;
   1e80a:	f8c0 3098 	str.w	r3, [r0, #152]	; 0x98
    pIState->lastCheckPktId = 0;
   1e80e:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
    pIState->lastCheckErrorCount = 0;
   1e812:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
    pIState->lastCheckTotalLen = 0;
   1e816:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
    pIState->lastCheckTime = 0;
   1e81a:	f8c0 30a8 	str.w	r3, [r0, #168]	; 0xa8
    pIState->isLastTransmit = false;
   1e81e:	f880 30d0 	strb.w	r3, [r0, #208]	; 0xd0
    pIState->txWaitTick = 0;
   1e822:	f8c0 30b4 	str.w	r3, [r0, #180]	; 0xb4
}
   1e826:	4770      	bx	lr

Disassembly of section .text._DHCPSetRunFail%597:

0001e828 <_DHCPSetRunFail>:
    pClient->smState = newState;
   1e828:	f8a0 1056 	strh.w	r1, [r0, #86]	; 0x56
    pClient->dhcpOp = TCPIP_DHCP_OPER_INIT;       // failure forces a brand new lease acquisition
   1e82c:	2301      	movs	r3, #1
   1e82e:	f8a0 3054 	strh.w	r3, [r0, #84]	; 0x54
    if(expBackoff)
   1e832:	b142      	cbz	r2, 1e846 <_DHCPSetRunFail+0x1e>
        pClient->dhcpTmo <<= 1;
   1e834:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
   1e838:	005b      	lsls	r3, r3, #1
   1e83a:	b29b      	uxth	r3, r3
        if(pClient->dhcpTmo > TCPIP_DHCP_EXP_BACKOFF_LIMIT)
   1e83c:	2b40      	cmp	r3, #64	; 0x40
            pClient->dhcpTmo = TCPIP_DHCP_EXP_BACKOFF_LIMIT;
   1e83e:	bf88      	it	hi
   1e840:	2340      	movhi	r3, #64	; 0x40
   1e842:	f8a0 304c 	strh.w	r3, [r0, #76]	; 0x4c
    if(pClient->flags.bReportFail)
   1e846:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   1e84a:	f013 0f20 	tst.w	r3, #32
   1e84e:	d008      	beq.n	1e862 <_DHCPSetRunFail+0x3a>
    pClient->flags.bReportFail = 1;
   1e850:	f043 0320 	orr.w	r3, r3, #32
   1e854:	f880 3058 	strb.w	r3, [r0, #88]	; 0x58
    if(resetTmo || pClient->tOpStart == 0)
   1e858:	6a03      	ldr	r3, [r0, #32]
   1e85a:	b913      	cbnz	r3, 1e862 <_DHCPSetRunFail+0x3a>
    return dhcpSecondCount;
   1e85c:	4b04      	ldr	r3, [pc, #16]	; (1e870 <_DHCPSetRunFail+0x48>)
        pClient->tOpStart = _DHCPSecondCountGet();
   1e85e:	681b      	ldr	r3, [r3, #0]
   1e860:	6203      	str	r3, [r0, #32]
    pClient->flags.bRetry = true;
   1e862:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   1e866:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   1e86a:	f880 3058 	strb.w	r3, [r0, #88]	; 0x58
}
   1e86e:	4770      	bx	lr
   1e870:	2000ee4c 	.word	0x2000ee4c

Disassembly of section .text.TCPIP_Helper_IPAddressToString%598:

0001e874 <TCPIP_Helper_IPAddressToString>:
    if(ipAdd && buff)
   1e874:	b1e8      	cbz	r0, 1e8b2 <TCPIP_Helper_IPAddressToString+0x3e>
   1e876:	b1f1      	cbz	r1, 1e8b6 <TCPIP_Helper_IPAddressToString+0x42>
{
   1e878:	b530      	push	{r4, r5, lr}
   1e87a:	b089      	sub	sp, #36	; 0x24
   1e87c:	4615      	mov	r5, r2
   1e87e:	460c      	mov	r4, r1
        sprintf(tempBuff, "%d.%d.%d.%d", ipAdd->v[0], ipAdd->v[1], ipAdd->v[2], ipAdd->v[3]);
   1e880:	78c3      	ldrb	r3, [r0, #3]
   1e882:	9301      	str	r3, [sp, #4]
   1e884:	7883      	ldrb	r3, [r0, #2]
   1e886:	9300      	str	r3, [sp, #0]
   1e888:	7843      	ldrb	r3, [r0, #1]
   1e88a:	7802      	ldrb	r2, [r0, #0]
   1e88c:	490b      	ldr	r1, [pc, #44]	; (1e8bc <TCPIP_Helper_IPAddressToString+0x48>)
   1e88e:	a803      	add	r0, sp, #12
   1e890:	f000 fee2 	bl	1f658 <siprintf>
        len = strlen(tempBuff) + 1;
   1e894:	a803      	add	r0, sp, #12
   1e896:	f005 fb13 	bl	23ec0 <strlen>
   1e89a:	3001      	adds	r0, #1
        if(buffSize >= len)
   1e89c:	42a8      	cmp	r0, r5
   1e89e:	d902      	bls.n	1e8a6 <TCPIP_Helper_IPAddressToString+0x32>
    return false; 
   1e8a0:	2000      	movs	r0, #0
}
   1e8a2:	b009      	add	sp, #36	; 0x24
   1e8a4:	bd30      	pop	{r4, r5, pc}
            strcpy(buff, tempBuff);
   1e8a6:	a903      	add	r1, sp, #12
   1e8a8:	4620      	mov	r0, r4
   1e8aa:	f005 fb01 	bl	23eb0 <strcpy>
            return true;
   1e8ae:	2001      	movs	r0, #1
   1e8b0:	e7f7      	b.n	1e8a2 <TCPIP_Helper_IPAddressToString+0x2e>
    return false; 
   1e8b2:	2000      	movs	r0, #0
   1e8b4:	4770      	bx	lr
   1e8b6:	2000      	movs	r0, #0
}
   1e8b8:	4770      	bx	lr
   1e8ba:	bf00      	nop
   1e8bc:	0001fa24 	.word	0x0001fa24

Disassembly of section .text._TCPIP_MacEventCB%599:

0001e8c0 <_TCPIP_MacEventCB>:
{
   1e8c0:	b508      	push	{r3, lr}
    pSigEntry = ((event & (TCPIP_STACK_MAC_ACTIVE_RX_EVENTS)) != 0) ? _TCPIPModuleToSignalEntry(TCPIP_MODULE_MANAGER) : 0;
   1e8c2:	f010 0f16 	tst.w	r0, #22
   1e8c6:	d109      	bne.n	1e8dc <_TCPIP_MacEventCB+0x1c>
    pNetIf->activeEvents |= event;
   1e8c8:	f8b1 305a 	ldrh.w	r3, [r1, #90]	; 0x5a
   1e8cc:	4318      	orrs	r0, r3
   1e8ce:	f8a1 005a 	strh.w	r0, [r1, #90]	; 0x5a
    totTcpipEventsCnt++;
   1e8d2:	4a0c      	ldr	r2, [pc, #48]	; (1e904 <_TCPIP_MacEventCB+0x44>)
   1e8d4:	6813      	ldr	r3, [r2, #0]
   1e8d6:	3301      	adds	r3, #1
   1e8d8:	6013      	str	r3, [r2, #0]
    if(pSigEntry)
   1e8da:	e012      	b.n	1e902 <_TCPIP_MacEventCB+0x42>
    pNetIf->activeEvents |= event;
   1e8dc:	f8b1 305a 	ldrh.w	r3, [r1, #90]	; 0x5a
   1e8e0:	4318      	orrs	r0, r3
   1e8e2:	f8a1 005a 	strh.w	r0, [r1, #90]	; 0x5a
    totTcpipEventsCnt++;
   1e8e6:	4a07      	ldr	r2, [pc, #28]	; (1e904 <_TCPIP_MacEventCB+0x44>)
   1e8e8:	6813      	ldr	r3, [r2, #0]
   1e8ea:	3301      	adds	r3, #1
   1e8ec:	6013      	str	r3, [r2, #0]
        pSigEntry->signalVal |= TCPIP_MODULE_SIGNAL_RX_PENDING;
   1e8ee:	4806      	ldr	r0, [pc, #24]	; (1e908 <_TCPIP_MacEventCB+0x48>)
   1e8f0:	8b03      	ldrh	r3, [r0, #24]
   1e8f2:	f043 0301 	orr.w	r3, r3, #1
   1e8f6:	8303      	strh	r3, [r0, #24]
        _TCPIPSignalEntryNotify(pSigEntry, TCPIP_MODULE_SIGNAL_RX_PENDING, 0);
   1e8f8:	2200      	movs	r2, #0
   1e8fa:	2101      	movs	r1, #1
   1e8fc:	3010      	adds	r0, #16
   1e8fe:	f004 fbcf 	bl	230a0 <_TCPIPSignalEntryNotify>
}
   1e902:	bd08      	pop	{r3, pc}
   1e904:	2000ee7c 	.word	0x2000ee7c
   1e908:	2000d9a4 	.word	0x2000d9a4

Disassembly of section .text._UDPClose%600:

0001e90c <_UDPClose>:
{
   1e90c:	b510      	push	{r4, lr}
   1e90e:	4604      	mov	r4, r0
    _UDPFreeTxResources(pSkt);
   1e910:	f003 f8b2 	bl	21a78 <_UDPFreeTxResources>
    pSkt->extFlags.rxEnable = 0;
   1e914:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   1e918:	f36f 0341 	bfc	r3, #1, #1
   1e91c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    _UDPFreeRxQueue(pSkt);
   1e920:	4620      	mov	r0, r4
   1e922:	f003 fe9f 	bl	22664 <_UDPFreeRxQueue>
    if(pSkt->pCurrRxPkt != 0)
   1e926:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   1e928:	b120      	cbz	r0, 1e934 <_UDPClose+0x28>
    TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
   1e92a:	2209      	movs	r2, #9
   1e92c:	f06f 0110 	mvn.w	r1, #16
   1e930:	f001 f8b8 	bl	1faa4 <_TCPIP_PKT_PacketAcknowledge>
    UDPSocketDcpt[pSkt->sktIx] = 0;
   1e934:	f9b4 2012 	ldrsh.w	r2, [r4, #18]
   1e938:	4b05      	ldr	r3, [pc, #20]	; (1e950 <_UDPClose+0x44>)
   1e93a:	681b      	ldr	r3, [r3, #0]
   1e93c:	2100      	movs	r1, #0
   1e93e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    TCPIP_HEAP_Free(udpMemH, pSkt);
   1e942:	4b04      	ldr	r3, [pc, #16]	; (1e954 <_UDPClose+0x48>)
   1e944:	6818      	ldr	r0, [r3, #0]
   1e946:	68c3      	ldr	r3, [r0, #12]
   1e948:	4621      	mov	r1, r4
   1e94a:	4798      	blx	r3
}
   1e94c:	bd10      	pop	{r4, pc}
   1e94e:	bf00      	nop
   1e950:	2000ee88 	.word	0x2000ee88
   1e954:	2000ee98 	.word	0x2000ee98

Disassembly of section .text.gfx_mono_ssd1306_init%601:

0001e958 <gfx_mono_ssd1306_init>:
void gfx_mono_ssd1306_init(void) {
   1e958:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    for (ix = 0; ix < GFX_MONO_LCD_FRAMEBUFFER_SIZE; ix++) {
   1e95a:	4a11      	ldr	r2, [pc, #68]	; (1e9a0 <gfx_mono_ssd1306_init+0x48>)
   1e95c:	1e53      	subs	r3, r2, #1
   1e95e:	f202 12ff 	addw	r2, r2, #511	; 0x1ff
        framebuffer[ix] = 0x00;
   1e962:	2100      	movs	r1, #0
   1e964:	f803 1f01 	strb.w	r1, [r3, #1]!
    for (ix = 0; ix < GFX_MONO_LCD_FRAMEBUFFER_SIZE; ix++) {
   1e968:	4293      	cmp	r3, r2
   1e96a:	d1fb      	bne.n	1e964 <gfx_mono_ssd1306_init+0xc>
    gfx_mono_set_framebuffer(framebuffer);
   1e96c:	480c      	ldr	r0, [pc, #48]	; (1e9a0 <gfx_mono_ssd1306_init+0x48>)
   1e96e:	f005 fc9f 	bl	242b0 <gfx_mono_set_framebuffer>
    ssd1306_init();
   1e972:	f7f8 fa85 	bl	16e80 <ssd1306_init>
        ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_START_LINE(address));
   1e976:	2040      	movs	r0, #64	; 0x40
   1e978:	f001 f974 	bl	1fc64 <ssd1306_write_command>
    for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
   1e97c:	2500      	movs	r5, #0
            gfx_mono_ssd1306_put_byte(page, column, 0x00, true);
   1e97e:	2701      	movs	r7, #1
   1e980:	462e      	mov	r6, r5
void gfx_mono_ssd1306_init(void) {
   1e982:	2400      	movs	r4, #0
            gfx_mono_ssd1306_put_byte(page, column, 0x00, true);
   1e984:	463b      	mov	r3, r7
   1e986:	4632      	mov	r2, r6
   1e988:	b2e1      	uxtb	r1, r4
   1e98a:	4628      	mov	r0, r5
   1e98c:	f000 fe42 	bl	1f614 <gfx_mono_ssd1306_put_byte>
   1e990:	3401      	adds	r4, #1
        for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
   1e992:	2c80      	cmp	r4, #128	; 0x80
   1e994:	d1f6      	bne.n	1e984 <gfx_mono_ssd1306_init+0x2c>
    for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
   1e996:	3501      	adds	r5, #1
   1e998:	b2ed      	uxtb	r5, r5
   1e99a:	2d04      	cmp	r5, #4
   1e99c:	d1f1      	bne.n	1e982 <gfx_mono_ssd1306_init+0x2a>
}
   1e99e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1e9a0:	2000dc14 	.word	0x2000dc14

Disassembly of section .text._realloc_r%602:

0001e9a4 <_realloc_r>:
   1e9a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1e9a6:	4607      	mov	r7, r0
   1e9a8:	4614      	mov	r4, r2
   1e9aa:	460e      	mov	r6, r1
   1e9ac:	b921      	cbnz	r1, 1e9b8 <_realloc_r+0x14>
   1e9ae:	4611      	mov	r1, r2
   1e9b0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   1e9b4:	f7f9 be84 	b.w	186c0 <_malloc_r>
   1e9b8:	b922      	cbnz	r2, 1e9c4 <_realloc_r+0x20>
   1e9ba:	f7fa ff9b 	bl	198f4 <_free_r>
   1e9be:	4625      	mov	r5, r4
   1e9c0:	4628      	mov	r0, r5
   1e9c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1e9c4:	f005 fa8c 	bl	23ee0 <_malloc_usable_size_r>
   1e9c8:	42a0      	cmp	r0, r4
   1e9ca:	d20f      	bcs.n	1e9ec <_realloc_r+0x48>
   1e9cc:	4621      	mov	r1, r4
   1e9ce:	4638      	mov	r0, r7
   1e9d0:	f7f9 fe76 	bl	186c0 <_malloc_r>
   1e9d4:	4605      	mov	r5, r0
   1e9d6:	2800      	cmp	r0, #0
   1e9d8:	d0f2      	beq.n	1e9c0 <_realloc_r+0x1c>
   1e9da:	4631      	mov	r1, r6
   1e9dc:	4622      	mov	r2, r4
   1e9de:	f004 fc85 	bl	232ec <memcpy>
   1e9e2:	4631      	mov	r1, r6
   1e9e4:	4638      	mov	r0, r7
   1e9e6:	f7fa ff85 	bl	198f4 <_free_r>
   1e9ea:	e7e9      	b.n	1e9c0 <_realloc_r+0x1c>
   1e9ec:	4635      	mov	r5, r6
   1e9ee:	e7e7      	b.n	1e9c0 <_realloc_r+0x1c>

Disassembly of section .text.TCPIP_IPV4_SelectSourceInterface%603:

0001e9f0 <TCPIP_IPV4_SelectSourceInterface>:
{
   1e9f0:	b570      	push	{r4, r5, r6, lr}
   1e9f2:	460e      	mov	r6, r1
   1e9f4:	4615      	mov	r5, r2
   1e9f6:	b160      	cbz	r0, 1ea12 <TCPIP_IPV4_SelectSourceInterface+0x22>
   1e9f8:	4604      	mov	r4, r0
   1e9fa:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1e9fe:	f012 0f40 	tst.w	r2, #64	; 0x40
   1ea02:	d113      	bne.n	1ea2c <TCPIP_IPV4_SelectSourceInterface+0x3c>
    if(srcSet)
   1ea04:	b93b      	cbnz	r3, 1ea16 <TCPIP_IPV4_SelectSourceInterface+0x26>
        pIf = (TCPIP_NET_IF*)TCPIP_IPV4_SelectDestInterface(pDestAddress);
   1ea06:	4630      	mov	r0, r6
   1ea08:	f7ff fe4e 	bl	1e6a8 <TCPIP_IPV4_SelectDestInterface>
    if(pIf)
   1ea0c:	4604      	mov	r4, r0
   1ea0e:	b190      	cbz	r0, 1ea36 <TCPIP_IPV4_SelectSourceInterface+0x46>
   1ea10:	e00d      	b.n	1ea2e <TCPIP_IPV4_SelectSourceInterface+0x3e>
    if(srcSet)
   1ea12:	2b00      	cmp	r3, #0
   1ea14:	d0f7      	beq.n	1ea06 <TCPIP_IPV4_SelectSourceInterface+0x16>
            pIf = _TCPIPStackIpAddFromAnyNet(0, pSrcAddress);
   1ea16:	4629      	mov	r1, r5
   1ea18:	2000      	movs	r0, #0
   1ea1a:	f7fe fe07 	bl	1d62c <_TCPIPStackIpAddFromAnyNet>
            if(pIf == 0)
   1ea1e:	4604      	mov	r4, r0
   1ea20:	b948      	cbnz	r0, 1ea36 <TCPIP_IPV4_SelectSourceInterface+0x46>
                pIf = (TCPIP_NET_IF*)TCPIP_IPV4_SelectDestInterface(pDestAddress);
   1ea22:	4630      	mov	r0, r6
   1ea24:	f7ff fe40 	bl	1e6a8 <TCPIP_IPV4_SelectDestInterface>
   1ea28:	4604      	mov	r4, r0
   1ea2a:	e004      	b.n	1ea36 <TCPIP_IPV4_SelectSourceInterface+0x46>
    if(srcSet)
   1ea2c:	b91b      	cbnz	r3, 1ea36 <TCPIP_IPV4_SelectSourceInterface+0x46>
        pSrcAddress->Val = TCPIP_STACK_NetAddressGet(pIf);
   1ea2e:	4620      	mov	r0, r4
   1ea30:	f004 fe70 	bl	23714 <TCPIP_STACK_NetAddressGet>
   1ea34:	6028      	str	r0, [r5, #0]
}
   1ea36:	4620      	mov	r0, r4
   1ea38:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_UDP_ArrayPut%604:

0001ea3a <TCPIP_UDP_ArrayPut>:
{
   1ea3a:	b570      	push	{r4, r5, r6, lr}
    if(cData != 0 && wDataLen != 0)
   1ea3c:	b1d9      	cbz	r1, 1ea76 <TCPIP_UDP_ArrayPut+0x3c>
   1ea3e:	460d      	mov	r5, r1
   1ea40:	b1da      	cbz	r2, 1ea7a <TCPIP_UDP_ArrayPut+0x40>
   1ea42:	4614      	mov	r4, r2
        UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1ea44:	f003 fb82 	bl	2214c <_UDPSocketDcpt>
        if(pSkt != 0 && _UDPTxPktValid(pSkt))
   1ea48:	4606      	mov	r6, r0
   1ea4a:	b1c8      	cbz	r0, 1ea80 <TCPIP_UDP_ArrayPut+0x46>
   1ea4c:	f004 fd22 	bl	23494 <_UDPTxPktValid>
   1ea50:	b908      	cbnz	r0, 1ea56 <TCPIP_UDP_ArrayPut+0x1c>
    return 0;
   1ea52:	2400      	movs	r4, #0
   1ea54:	e012      	b.n	1ea7c <TCPIP_UDP_ArrayPut+0x42>
            uint16_t wrSpace = pSkt->txEnd - pSkt->txWrite;
   1ea56:	68b0      	ldr	r0, [r6, #8]
   1ea58:	6873      	ldr	r3, [r6, #4]
   1ea5a:	1a1b      	subs	r3, r3, r0
   1ea5c:	b29a      	uxth	r2, r3
   1ea5e:	4294      	cmp	r4, r2
   1ea60:	bf28      	it	cs
   1ea62:	4614      	movcs	r4, r2
            if(wDataLen)
   1ea64:	b154      	cbz	r4, 1ea7c <TCPIP_UDP_ArrayPut+0x42>
                memcpy(pSkt->txWrite, cData, wDataLen);
   1ea66:	4622      	mov	r2, r4
   1ea68:	4629      	mov	r1, r5
   1ea6a:	f004 fc3f 	bl	232ec <memcpy>
                pSkt->txWrite += wDataLen;
   1ea6e:	68b3      	ldr	r3, [r6, #8]
   1ea70:	4423      	add	r3, r4
   1ea72:	60b3      	str	r3, [r6, #8]
   1ea74:	e002      	b.n	1ea7c <TCPIP_UDP_ArrayPut+0x42>
    return 0;
   1ea76:	2400      	movs	r4, #0
   1ea78:	e000      	b.n	1ea7c <TCPIP_UDP_ArrayPut+0x42>
   1ea7a:	4614      	mov	r4, r2
}
   1ea7c:	4620      	mov	r0, r4
   1ea7e:	bd70      	pop	{r4, r5, r6, pc}
    return 0;
   1ea80:	2400      	movs	r4, #0
   1ea82:	e7fb      	b.n	1ea7c <TCPIP_UDP_ArrayPut+0x42>

Disassembly of section .text.TCPIP_UDP_DestinationIPAddressSet%605:

0001ea84 <TCPIP_UDP_DestinationIPAddressSet>:

bool TCPIP_UDP_DestinationIPAddressSet(UDP_SOCKET s, IP_ADDRESS_TYPE addType, IP_MULTI_ADDRESS* remoteAddress)
{
    UDP_SOCKET_DCPT *pSkt;

    if(remoteAddress == 0)
   1ea84:	b1fa      	cbz	r2, 1eac6 <TCPIP_UDP_DestinationIPAddressSet+0x42>
{
   1ea86:	b538      	push	{r3, r4, r5, lr}
   1ea88:	4615      	mov	r5, r2
   1ea8a:	460c      	mov	r4, r1
    {
        return false;
    }

    pSkt = _UDPSocketDcpt(s);
   1ea8c:	f003 fb5e 	bl	2214c <_UDPSocketDcpt>

    while(pSkt != 0 && pSkt->addType == addType)
   1ea90:	4603      	mov	r3, r0
   1ea92:	b120      	cbz	r0, 1ea9e <TCPIP_UDP_DestinationIPAddressSet+0x1a>
   1ea94:	8f82      	ldrh	r2, [r0, #60]	; 0x3c
   1ea96:	b2a1      	uxth	r1, r4
   1ea98:	428a      	cmp	r2, r1
   1ea9a:	d001      	beq.n	1eaa0 <TCPIP_UDP_DestinationIPAddressSet+0x1c>
#endif  // defined (TCPIP_STACK_USE_IPV4)

        break;
    }

    return false;
   1ea9c:	2000      	movs	r0, #0
}
   1ea9e:	bd38      	pop	{r3, r4, r5, pc}
        if (pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   1eaa0:	2a01      	cmp	r2, #1
   1eaa2:	d001      	beq.n	1eaa8 <TCPIP_UDP_DestinationIPAddressSet+0x24>
    return false;
   1eaa4:	2000      	movs	r0, #0
   1eaa6:	e7fa      	b.n	1ea9e <TCPIP_UDP_DestinationIPAddressSet+0x1a>
            if(pSkt->flags.bcastForceType != UDP_BCAST_NONE)
   1eaa8:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
   1eaac:	f012 0f03 	tst.w	r2, #3
   1eab0:	d10b      	bne.n	1eaca <TCPIP_UDP_DestinationIPAddressSet+0x46>
            pSkt->destAddress.Val = remoteAddress->v4Add.Val;
   1eab2:	682a      	ldr	r2, [r5, #0]
   1eab4:	615a      	str	r2, [r3, #20]
            pSkt->flags.destSet = 1;
   1eab6:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
   1eaba:	f042 0201 	orr.w	r2, r2, #1
   1eabe:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
            return true;
   1eac2:	2001      	movs	r0, #1
   1eac4:	e7eb      	b.n	1ea9e <TCPIP_UDP_DestinationIPAddressSet+0x1a>
        return false;
   1eac6:	2000      	movs	r0, #0
}
   1eac8:	4770      	bx	lr
                return false;
   1eaca:	2000      	movs	r0, #0
   1eacc:	e7e7      	b.n	1ea9e <TCPIP_UDP_DestinationIPAddressSet+0x1a>

Disassembly of section .text.__ssfputs_r%606:

0001eace <__ssfputs_r>:
   1eace:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1ead0:	460e      	mov	r6, r1
   1ead2:	6e09      	ldr	r1, [r1, #96]	; 0x60
   1ead4:	0489      	lsls	r1, r1, #18
   1ead6:	4607      	mov	r7, r0
   1ead8:	4614      	mov	r4, r2
   1eada:	d40b      	bmi.n	1eaf4 <__ssfputs_r+0x26>
   1eadc:	18d5      	adds	r5, r2, r3
   1eade:	42ac      	cmp	r4, r5
   1eae0:	d00d      	beq.n	1eafe <__ssfputs_r+0x30>
   1eae2:	4632      	mov	r2, r6
   1eae4:	f814 1b01 	ldrb.w	r1, [r4], #1
   1eae8:	4638      	mov	r0, r7
   1eaea:	f002 fed1 	bl	21890 <__sfputc_r>
   1eaee:	3001      	adds	r0, #1
   1eaf0:	d1f5      	bne.n	1eade <__ssfputs_r+0x10>
   1eaf2:	e00e      	b.n	1eb12 <__ssfputs_r+0x44>
   1eaf4:	f023 0303 	bic.w	r3, r3, #3
   1eaf8:	18d5      	adds	r5, r2, r3
   1eafa:	42ac      	cmp	r4, r5
   1eafc:	d101      	bne.n	1eb02 <__ssfputs_r+0x34>
   1eafe:	2000      	movs	r0, #0
   1eb00:	e009      	b.n	1eb16 <__ssfputs_r+0x48>
   1eb02:	4632      	mov	r2, r6
   1eb04:	f854 1b04 	ldr.w	r1, [r4], #4
   1eb08:	4638      	mov	r0, r7
   1eb0a:	f004 fc19 	bl	23340 <_fputwc_r>
   1eb0e:	3001      	adds	r0, #1
   1eb10:	d1f3      	bne.n	1eafa <__ssfputs_r+0x2c>
   1eb12:	f04f 30ff 	mov.w	r0, #4294967295
   1eb16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.DRV_ETHPHY_NegotiationResultGet%607:

0001eb18 <DRV_ETHPHY_NegotiationResultGet>:
    if(hClientObj != 0)
   1eb18:	4603      	mov	r3, r0
   1eb1a:	b198      	cbz	r0, 1eb44 <DRV_ETHPHY_NegotiationResultGet+0x2c>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1eb1c:	68c0      	ldr	r0, [r0, #12]
   1eb1e:	490f      	ldr	r1, [pc, #60]	; (1eb5c <DRV_ETHPHY_NegotiationResultGet+0x44>)
   1eb20:	4288      	cmp	r0, r1
   1eb22:	d112      	bne.n	1eb4a <DRV_ETHPHY_NegotiationResultGet+0x32>
            if(hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_READY)
   1eb24:	f993 1008 	ldrsb.w	r1, [r3, #8]
   1eb28:	2902      	cmp	r1, #2
   1eb2a:	d111      	bne.n	1eb50 <DRV_ETHPHY_NegotiationResultGet+0x38>
            if(pNegResult == 0)
   1eb2c:	b19a      	cbz	r2, 1eb56 <DRV_ETHPHY_NegotiationResultGet+0x3e>
            hClientObj->operParam = (uintptr_t)pNegResult;
   1eb2e:	631a      	str	r2, [r3, #48]	; 0x30
    hClientObj->operType = opType;
   1eb30:	2204      	movs	r2, #4
   1eb32:	839a      	strh	r2, [r3, #28]
    hClientObj->operPhase = hClientObj->operSubPhase = 0; 
   1eb34:	2200      	movs	r2, #0
   1eb36:	841a      	strh	r2, [r3, #32]
   1eb38:	83da      	strh	r2, [r3, #30]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_BUSY; 
   1eb3a:	2001      	movs	r0, #1
   1eb3c:	7218      	strb	r0, [r3, #8]
    hClientObj->operRes = res;
   1eb3e:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c
   1eb42:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1eb44:	f06f 000a 	mvn.w	r0, #10
   1eb48:	4770      	bx	lr
   1eb4a:	f06f 000a 	mvn.w	r0, #10
   1eb4e:	4770      	bx	lr
                return DRV_ETHPHY_RES_NOT_READY_ERR;
   1eb50:	f06f 0009 	mvn.w	r0, #9
   1eb54:	4770      	bx	lr
                return DRV_ETHPHY_RES_OPERATION_ERR;
   1eb56:	f06f 0008 	mvn.w	r0, #8
}
   1eb5a:	4770      	bx	lr
   1eb5c:	2000e7e8 	.word	0x2000e7e8

Disassembly of section .text._DRV_ETHPHY_NegCompletePhaseRead2%608:

0001eb60 <_DRV_ETHPHY_NegCompletePhaseRead2>:
{
   1eb60:	b510      	push	{r4, lr}
   1eb62:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1eb64:	f003 feb6 	bl	228d4 <_DRV_PHY_SMITransfer_Wait>
   1eb68:	b168      	cbz	r0, 1eb86 <_DRV_ETHPHY_NegCompletePhaseRead2+0x26>
    hClientObj->operReg[1] = hClientObj->smiData;
   1eb6a:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   1eb6c:	84a3      	strh	r3, [r4, #36]	; 0x24
    if(hClientObj->operParam == 0)
   1eb6e:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1eb70:	b153      	cbz	r3, 1eb88 <_DRV_ETHPHY_NegCompletePhaseRead2+0x28>
    hClientObj->operTStamp = SYS_TMR_TickCountGet() + ((DRV_ETHPHY_NEG_INIT_TMO * SYS_TMR_TickCounterFrequencyGet()) + 999) / 1000;
   1eb72:	f003 fb8b 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
   1eb76:	f003 fb61 	bl	2223c <SYS_TMR_TickCountGet>
   1eb7a:	62a0      	str	r0, [r4, #40]	; 0x28
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMCON))
   1eb7c:	2100      	movs	r1, #0
   1eb7e:	4620      	mov	r0, r4
   1eb80:	f002 f9f6 	bl	20f70 <_DRV_PHY_SMIReadStart>
   1eb84:	b958      	cbnz	r0, 1eb9e <_DRV_ETHPHY_NegCompletePhaseRead2+0x3e>
}
   1eb86:	bd10      	pop	{r4, pc}
        if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   1eb88:	2101      	movs	r1, #1
   1eb8a:	4620      	mov	r0, r4
   1eb8c:	f002 f9f0 	bl	20f70 <_DRV_PHY_SMIReadStart>
   1eb90:	2800      	cmp	r0, #0
   1eb92:	d0f8      	beq.n	1eb86 <_DRV_ETHPHY_NegCompletePhaseRead2+0x26>
    hClientObj->operPhase = operPhase;
   1eb94:	2303      	movs	r3, #3
   1eb96:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1eb98:	2300      	movs	r3, #0
   1eb9a:	8423      	strh	r3, [r4, #32]
   1eb9c:	e7f3      	b.n	1eb86 <_DRV_ETHPHY_NegCompletePhaseRead2+0x26>
    hClientObj->operPhase = operPhase;
   1eb9e:	2304      	movs	r3, #4
   1eba0:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1eba2:	2300      	movs	r3, #0
   1eba4:	8423      	strh	r3, [r4, #32]
   1eba6:	e7ee      	b.n	1eb86 <_DRV_ETHPHY_NegCompletePhaseRead2+0x26>

Disassembly of section .text.DRV_GMAC_LinkCheck%609:

0001eba8 <DRV_GMAC_LinkCheck>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1eba8:	4b0f      	ldr	r3, [pc, #60]	; (1ebe8 <DRV_GMAC_LinkCheck+0x40>)
   1ebaa:	4283      	cmp	r3, r0
   1ebac:	d116      	bne.n	1ebdc <DRV_GMAC_LinkCheck+0x34>
    if(pMACDrv == 0 || (pMACDrv->sGmacData._macFlags._linkPresent == 0))
   1ebae:	b1b8      	cbz	r0, 1ebe0 <DRV_GMAC_LinkCheck+0x38>
   1ebb0:	7d9b      	ldrb	r3, [r3, #22]
   1ebb2:	f013 0f04 	tst.w	r3, #4
   1ebb6:	d015      	beq.n	1ebe4 <DRV_GMAC_LinkCheck+0x3c>
{
   1ebb8:	b510      	push	{r4, lr}
	pPhyBase->DRV_ETHPHY_Tasks(pMACDrv->sGmacData.hPhySysObject);
   1ebba:	4c0b      	ldr	r4, [pc, #44]	; (1ebe8 <DRV_GMAC_LinkCheck+0x40>)
   1ebbc:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
   1ebc0:	691b      	ldr	r3, [r3, #16]
   1ebc2:	68e0      	ldr	r0, [r4, #12]
   1ebc4:	4798      	blx	r3
    (*_DRV_GMAC_LinkStateTbl[pMACDrv->sGmacData._linkCheckState])(pMACDrv);
   1ebc6:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
   1ebca:	4b08      	ldr	r3, [pc, #32]	; (1ebec <DRV_GMAC_LinkCheck+0x44>)
   1ebcc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1ebd0:	4620      	mov	r0, r4
   1ebd2:	4798      	blx	r3
    return pMACDrv->sGmacData._macFlags._linkPrev == 1;	
   1ebd4:	7da0      	ldrb	r0, [r4, #22]
   1ebd6:	f3c0 1000 	ubfx	r0, r0, #4, #1
}
   1ebda:	bd10      	pop	{r4, pc}
	    return false;
   1ebdc:	2000      	movs	r0, #0
   1ebde:	4770      	bx	lr
   1ebe0:	2000      	movs	r0, #0
   1ebe2:	4770      	bx	lr
   1ebe4:	2000      	movs	r0, #0
}
   1ebe6:	4770      	bx	lr
   1ebe8:	2000e288 	.word	0x2000e288
   1ebec:	00023a94 	.word	0x00023a94

Disassembly of section .text._TCPSendWinIncUpdate%610:

0001ebf0 <_TCPSendWinIncUpdate>:
{
   1ebf0:	b570      	push	{r4, r5, r6, lr}
   1ebf2:	4605      	mov	r5, r0
    oldWin = pSkt->localWindow;
   1ebf4:	f8b0 605e 	ldrh.w	r6, [r0, #94]	; 0x5e
    wFIFOSize = pSkt->rxEnd - pSkt->rxStart;
   1ebf8:	6984      	ldr	r4, [r0, #24]
   1ebfa:	6943      	ldr	r3, [r0, #20]
   1ebfc:	1ae4      	subs	r4, r4, r3
   1ebfe:	b2a4      	uxth	r4, r4
    wDataLen = _TCPIsGetReady(pSkt);
   1ec00:	f004 f92d 	bl	22e5e <_TCPIsGetReady>
    return wFIFOSize - wDataLen;
   1ec04:	1a20      	subs	r0, r4, r0
   1ec06:	b280      	uxth	r0, r0
    if(newWin == rxBuffSz)
   1ec08:	4284      	cmp	r4, r0
   1ec0a:	d00c      	beq.n	1ec26 <_TCPSendWinIncUpdate+0x36>
    else if(newWin > oldWin)
   1ec0c:	4286      	cmp	r6, r0
   1ec0e:	d211      	bcs.n	1ec34 <_TCPSendWinIncUpdate+0x44>
        minWinInc = rxBuffSz >> 1; // half RX buffer
   1ec10:	0864      	lsrs	r4, r4, #1
        if((newWin - oldWin) > minWinInc)
   1ec12:	1b80      	subs	r0, r0, r6
   1ec14:	f8b5 3064 	ldrh.w	r3, [r5, #100]	; 0x64
   1ec18:	429c      	cmp	r4, r3
   1ec1a:	bf28      	it	cs
   1ec1c:	461c      	movcs	r4, r3
   1ec1e:	42a0      	cmp	r0, r4
   1ec20:	dc01      	bgt.n	1ec26 <_TCPSendWinIncUpdate+0x36>
    return false;
   1ec22:	2000      	movs	r0, #0
   1ec24:	e007      	b.n	1ec36 <_TCPSendWinIncUpdate+0x46>
        _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
   1ec26:	2201      	movs	r2, #1
   1ec28:	2110      	movs	r1, #16
   1ec2a:	4628      	mov	r0, r5
   1ec2c:	f7e9 f988 	bl	7f40 <_TcpSend>
        return true;
   1ec30:	2001      	movs	r0, #1
   1ec32:	e000      	b.n	1ec36 <_TCPSendWinIncUpdate+0x46>
    return false;
   1ec34:	2000      	movs	r0, #0
}
   1ec36:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_TCP_DestinationIPAddressSet%611:

0001ec38 <TCPIP_TCP_DestinationIPAddressSet>:
    if(remoteAddress == 0)
   1ec38:	b1f2      	cbz	r2, 1ec78 <TCPIP_TCP_DestinationIPAddressSet+0x40>
{
   1ec3a:	b538      	push	{r3, r4, r5, lr}
   1ec3c:	4615      	mov	r5, r2
   1ec3e:	460c      	mov	r4, r1
    pSkt = _TcpSocketChk(hTCP); 
   1ec40:	f003 f96c 	bl	21f1c <_TcpSocketChk>
    while(pSkt != 0 && pSkt->addType == addType && !_TCP_IsConnected(pSkt))
   1ec44:	4603      	mov	r3, r0
   1ec46:	b120      	cbz	r0, 1ec52 <TCPIP_TCP_DestinationIPAddressSet+0x1a>
   1ec48:	f890 206f 	ldrb.w	r2, [r0, #111]	; 0x6f
   1ec4c:	42a2      	cmp	r2, r4
   1ec4e:	d005      	beq.n	1ec5c <TCPIP_TCP_DestinationIPAddressSet+0x24>
    return false;
   1ec50:	2000      	movs	r0, #0
}
   1ec52:	bd38      	pop	{r3, r4, r5, pc}
            pSkt->destAddress.Val = remoteAddress->v4Add.Val;
   1ec54:	682a      	ldr	r2, [r5, #0]
   1ec56:	639a      	str	r2, [r3, #56]	; 0x38
            return true;
   1ec58:	2001      	movs	r0, #1
   1ec5a:	e7fa      	b.n	1ec52 <TCPIP_TCP_DestinationIPAddressSet+0x1a>
    return (pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1 || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2 || pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT);
   1ec5c:	f890 006e 	ldrb.w	r0, [r0, #110]	; 0x6e
   1ec60:	1ec1      	subs	r1, r0, #3
   1ec62:	b2c9      	uxtb	r1, r1
   1ec64:	2902      	cmp	r1, #2
   1ec66:	d909      	bls.n	1ec7c <TCPIP_TCP_DestinationIPAddressSet+0x44>
    while(pSkt != 0 && pSkt->addType == addType && !_TCP_IsConnected(pSkt))
   1ec68:	2808      	cmp	r0, #8
    return false;
   1ec6a:	bf08      	it	eq
   1ec6c:	2000      	moveq	r0, #0
    while(pSkt != 0 && pSkt->addType == addType && !_TCP_IsConnected(pSkt))
   1ec6e:	d0f0      	beq.n	1ec52 <TCPIP_TCP_DestinationIPAddressSet+0x1a>
        if (pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   1ec70:	2a01      	cmp	r2, #1
   1ec72:	d0ef      	beq.n	1ec54 <TCPIP_TCP_DestinationIPAddressSet+0x1c>
    return false;
   1ec74:	2000      	movs	r0, #0
   1ec76:	e7ec      	b.n	1ec52 <TCPIP_TCP_DestinationIPAddressSet+0x1a>
        return false;
   1ec78:	2000      	movs	r0, #0
}
   1ec7a:	4770      	bx	lr
    return false;
   1ec7c:	2000      	movs	r0, #0
   1ec7e:	e7e8      	b.n	1ec52 <TCPIP_TCP_DestinationIPAddressSet+0x1a>

Disassembly of section .text.TCPIP_ARP_Deinitialize%612:

0001ec80 <TCPIP_ARP_Deinitialize>:
    if(arpMod.initCount > 0)
   1ec80:	4b10      	ldr	r3, [pc, #64]	; (1ecc4 <TCPIP_ARP_Deinitialize+0x44>)
   1ec82:	68db      	ldr	r3, [r3, #12]
   1ec84:	2b00      	cmp	r3, #0
   1ec86:	dd1c      	ble.n	1ecc2 <TCPIP_ARP_Deinitialize+0x42>
{
   1ec88:	b510      	push	{r4, lr}
        if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_DOWN)
   1ec8a:	7f02      	ldrb	r2, [r0, #28]
   1ec8c:	2a04      	cmp	r2, #4
   1ec8e:	d004      	beq.n	1ec9a <TCPIP_ARP_Deinitialize+0x1a>
            if(--arpMod.initCount == 0)
   1ec90:	3b01      	subs	r3, #1
   1ec92:	4a0c      	ldr	r2, [pc, #48]	; (1ecc4 <TCPIP_ARP_Deinitialize+0x44>)
   1ec94:	60d3      	str	r3, [r2, #12]
   1ec96:	b18b      	cbz	r3, 1ecbc <TCPIP_ARP_Deinitialize+0x3c>
}
   1ec98:	bd10      	pop	{r4, pc}
            if(arpMod.deleteOld)
   1ec9a:	4b0a      	ldr	r3, [pc, #40]	; (1ecc4 <TCPIP_ARP_Deinitialize+0x44>)
   1ec9c:	7c1b      	ldrb	r3, [r3, #16]
   1ec9e:	2b00      	cmp	r3, #0
   1eca0:	d0fa      	beq.n	1ec98 <TCPIP_ARP_Deinitialize+0x18>
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   1eca2:	4b08      	ldr	r3, [pc, #32]	; (1ecc4 <TCPIP_ARP_Deinitialize+0x44>)
   1eca4:	685c      	ldr	r4, [r3, #4]
   1eca6:	6940      	ldr	r0, [r0, #20]
   1eca8:	f005 f946 	bl	23f38 <TCPIP_STACK_NetIxGet>
   1ecac:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
                if(pArpDcpt != 0)
   1ecb0:	eb14 00c0 	adds.w	r0, r4, r0, lsl #3
   1ecb4:	d0f0      	beq.n	1ec98 <TCPIP_ARP_Deinitialize+0x18>
                    _ARPRemoveCacheEntries(pArpDcpt);
   1ecb6:	f003 f959 	bl	21f6c <_ARPRemoveCacheEntries>
   1ecba:	e7ed      	b.n	1ec98 <TCPIP_ARP_Deinitialize+0x18>
                    _ARPDeleteResources();
   1ecbc:	f7fa fb9e 	bl	193fc <_ARPDeleteResources>
}
   1ecc0:	e7ea      	b.n	1ec98 <TCPIP_ARP_Deinitialize+0x18>
   1ecc2:	4770      	bx	lr
   1ecc4:	2000e974 	.word	0x2000e974

Disassembly of section .rodata._DHCPOptProcTbl%613:

0001ecc8 <_DHCPOptProcTbl>:
   1ecc8:	00000035 00020527 00000001 0001fde3     5...'...........
   1ecd8:	00000003 00020007 00000006 0001d101     ................
   1ece8:	00000036 000225f9 00000033 000216c5     6....%..3.......
   1ecf8:	0000003a 000216f3 0000003b 00021721     :.......;...!...
   1ed08:	000000ff 0002448b                       .....D..

Disassembly of section .text.TCPIP_STACK_MACIdToNet%614:

0001ed10 <TCPIP_STACK_MACIdToNet>:
    if(macId != (TCPIP_STACK_MODULE)TCPIP_MODULE_MAC_NONE)
   1ed10:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
   1ed14:	d017      	beq.n	1ed46 <TCPIP_STACK_MACIdToNet+0x36>
{
   1ed16:	b410      	push	{r4}
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   1ed18:	4b0d      	ldr	r3, [pc, #52]	; (1ed50 <TCPIP_STACK_MACIdToNet+0x40>)
   1ed1a:	681b      	ldr	r3, [r3, #0]
   1ed1c:	4a0d      	ldr	r2, [pc, #52]	; (1ed54 <TCPIP_STACK_MACIdToNet+0x44>)
   1ed1e:	6814      	ldr	r4, [r2, #0]
   1ed20:	2c00      	cmp	r4, #0
   1ed22:	dd13      	ble.n	1ed4c <TCPIP_STACK_MACIdToNet+0x3c>
            if(pNetIf->macId == macId)
   1ed24:	885a      	ldrh	r2, [r3, #2]
   1ed26:	4282      	cmp	r2, r0
   1ed28:	d009      	beq.n	1ed3e <TCPIP_STACK_MACIdToNet+0x2e>
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   1ed2a:	2200      	movs	r2, #0
   1ed2c:	3201      	adds	r2, #1
   1ed2e:	336c      	adds	r3, #108	; 0x6c
   1ed30:	42a2      	cmp	r2, r4
   1ed32:	d003      	beq.n	1ed3c <TCPIP_STACK_MACIdToNet+0x2c>
            if(pNetIf->macId == macId)
   1ed34:	8859      	ldrh	r1, [r3, #2]
   1ed36:	4281      	cmp	r1, r0
   1ed38:	d1f8      	bne.n	1ed2c <TCPIP_STACK_MACIdToNet+0x1c>
   1ed3a:	e000      	b.n	1ed3e <TCPIP_STACK_MACIdToNet+0x2e>
    return 0;
   1ed3c:	2300      	movs	r3, #0
}
   1ed3e:	4618      	mov	r0, r3
   1ed40:	f85d 4b04 	ldr.w	r4, [sp], #4
   1ed44:	4770      	bx	lr
    return 0;
   1ed46:	2300      	movs	r3, #0
}
   1ed48:	4618      	mov	r0, r3
   1ed4a:	4770      	bx	lr
    return 0;
   1ed4c:	2300      	movs	r3, #0
   1ed4e:	e7f6      	b.n	1ed3e <TCPIP_STACK_MACIdToNet+0x2e>
   1ed50:	2000ee74 	.word	0x2000ee74
   1ed54:	2000eae4 	.word	0x2000eae4

Disassembly of section .text.TCPIP_STACK_MatchNetAddress%615:

0001ed58 <TCPIP_STACK_MatchNetAddress>:
    if(pIpAdd->Val == 0x0100007f /* || pNetIf->netIPAddr.Val == pIpAdd->Val*/)
   1ed58:	6809      	ldr	r1, [r1, #0]
   1ed5a:	4b0e      	ldr	r3, [pc, #56]	; (1ed94 <TCPIP_STACK_MatchNetAddress+0x3c>)
   1ed5c:	4299      	cmp	r1, r3
   1ed5e:	d018      	beq.n	1ed92 <TCPIP_STACK_MatchNetAddress+0x3a>
{
   1ed60:	b410      	push	{r4}
    for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1ed62:	4b0d      	ldr	r3, [pc, #52]	; (1ed98 <TCPIP_STACK_MatchNetAddress+0x40>)
   1ed64:	6818      	ldr	r0, [r3, #0]
   1ed66:	4b0d      	ldr	r3, [pc, #52]	; (1ed9c <TCPIP_STACK_MatchNetAddress+0x44>)
   1ed68:	681c      	ldr	r4, [r3, #0]
   1ed6a:	2c00      	cmp	r4, #0
   1ed6c:	dd0f      	ble.n	1ed8e <TCPIP_STACK_MatchNetAddress+0x36>
        if(pIf->netIPAddr.Val == pIpAdd->Val)
   1ed6e:	6843      	ldr	r3, [r0, #4]
   1ed70:	4299      	cmp	r1, r3
   1ed72:	d009      	beq.n	1ed88 <TCPIP_STACK_MatchNetAddress+0x30>
    for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1ed74:	2300      	movs	r3, #0
   1ed76:	3301      	adds	r3, #1
   1ed78:	306c      	adds	r0, #108	; 0x6c
   1ed7a:	42a3      	cmp	r3, r4
   1ed7c:	d003      	beq.n	1ed86 <TCPIP_STACK_MatchNetAddress+0x2e>
        if(pIf->netIPAddr.Val == pIpAdd->Val)
   1ed7e:	6842      	ldr	r2, [r0, #4]
   1ed80:	4291      	cmp	r1, r2
   1ed82:	d1f8      	bne.n	1ed76 <TCPIP_STACK_MatchNetAddress+0x1e>
   1ed84:	e000      	b.n	1ed88 <TCPIP_STACK_MatchNetAddress+0x30>
    return 0;
   1ed86:	2000      	movs	r0, #0
}
   1ed88:	f85d 4b04 	ldr.w	r4, [sp], #4
   1ed8c:	4770      	bx	lr
    return 0;
   1ed8e:	2000      	movs	r0, #0
   1ed90:	e7fa      	b.n	1ed88 <TCPIP_STACK_MatchNetAddress+0x30>
}
   1ed92:	4770      	bx	lr
   1ed94:	0100007f 	.word	0x0100007f
   1ed98:	2000ee74 	.word	0x2000ee74
   1ed9c:	2000eae4 	.word	0x2000eae4

Disassembly of section .text._TCPIPStackSignalHandlerRegister%616:

0001eda0 <_TCPIPStackSignalHandlerRegister>:
    if(signalHandler != 0 )
   1eda0:	b1c9      	cbz	r1, 1edd6 <_TCPIPStackSignalHandlerRegister+0x36>
{
   1eda2:	b430      	push	{r4, r5}
   1eda4:	460c      	mov	r4, r1
        if(TCPIP_MODULE_LAYER1 <= modId && modId < sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL)/sizeof(*TCPIP_STACK_MODULE_SIGNAL_TBL))
   1eda6:	1e83      	subs	r3, r0, #2
   1eda8:	b29b      	uxth	r3, r3
   1edaa:	2b24      	cmp	r3, #36	; 0x24
   1edac:	d815      	bhi.n	1edda <_TCPIPStackSignalHandlerRegister+0x3a>
            TCPIP_MODULE_SIGNAL_ENTRY* pSignalEntry = TCPIP_STACK_MODULE_SIGNAL_TBL + modId;
   1edae:	490c      	ldr	r1, [pc, #48]	; (1ede0 <_TCPIPStackSignalHandlerRegister+0x40>)
   1edb0:	0103      	lsls	r3, r0, #4
   1edb2:	18c8      	adds	r0, r1, r3
            if(pSignalEntry->signalHandler == 0 || pSignalEntry->signalHandler == signalHandler)
   1edb4:	58cd      	ldr	r5, [r1, r3]
   1edb6:	b125      	cbz	r5, 1edc2 <_TCPIPStackSignalHandlerRegister+0x22>
   1edb8:	42a5      	cmp	r5, r4
   1edba:	d002      	beq.n	1edc2 <_TCPIPStackSignalHandlerRegister+0x22>
    return 0;
   1edbc:	2000      	movs	r0, #0
}
   1edbe:	bc30      	pop	{r4, r5}
   1edc0:	4770      	bx	lr
                pSignalEntry->signalHandler = signalHandler;
   1edc2:	50cc      	str	r4, [r1, r3]
                if ((asyncTmoMs != 0) && (asyncTmoMs < stackTaskRate))
   1edc4:	b122      	cbz	r2, 1edd0 <_TCPIPStackSignalHandlerRegister+0x30>
   1edc6:	4b07      	ldr	r3, [pc, #28]	; (1ede4 <_TCPIPStackSignalHandlerRegister+0x44>)
   1edc8:	681b      	ldr	r3, [r3, #0]
   1edca:	429a      	cmp	r2, r3
                    asyncTmoMs = stackTaskRate;
   1edcc:	bf38      	it	cc
   1edce:	b21a      	sxthcc	r2, r3
                pSignalEntry->asyncTmo = pSignalEntry->currTmo = asyncTmoMs;
   1edd0:	8182      	strh	r2, [r0, #12]
   1edd2:	8142      	strh	r2, [r0, #10]
                return pSignalEntry;
   1edd4:	e7f3      	b.n	1edbe <_TCPIPStackSignalHandlerRegister+0x1e>
    return 0;
   1edd6:	2000      	movs	r0, #0
}
   1edd8:	4770      	bx	lr
    return 0;
   1edda:	2000      	movs	r0, #0
   1eddc:	e7ef      	b.n	1edbe <_TCPIPStackSignalHandlerRegister+0x1e>
   1edde:	bf00      	nop
   1ede0:	2000d9a4 	.word	0x2000d9a4
   1ede4:	2000ee6c 	.word	0x2000ee6c

Disassembly of section .text.TCPIP_DHCPS_Disable%617:

0001ede8 <TCPIP_DHCPS_Disable>:
   1ede8:	b1f0      	cbz	r0, 1ee28 <TCPIP_DHCPS_Disable+0x40>
{    
   1edea:	b510      	push	{r4, lr}
   1edec:	4604      	mov	r4, r0
   1edee:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1edf2:	f012 0f40 	tst.w	r2, #64	; 0x40
   1edf6:	d101      	bne.n	1edfc <TCPIP_DHCPS_Disable+0x14>
        return false;
   1edf8:	2000      	movs	r0, #0
}
   1edfa:	bd10      	pop	{r4, pc}
    _DHCPSrvClose(pNetIf,true);
   1edfc:	2101      	movs	r1, #1
   1edfe:	f7fe fc43 	bl	1d688 <_DHCPSrvClose>
    TCPIP_STACK_AddressServiceEvent(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_DHCPS, TCPIP_STACK_ADDRESS_SERVICE_EVENT_USER_STOP);
   1ee02:	2203      	movs	r2, #3
   1ee04:	4611      	mov	r1, r2
   1ee06:	4620      	mov	r0, r4
   1ee08:	f000 fb16 	bl	1f438 <TCPIP_STACK_AddressServiceEvent>
    TCPIP_STACK_AddressServiceDefaultSet(pNetIf);
   1ee0c:	4620      	mov	r0, r4
   1ee0e:	f001 f807 	bl	1fe20 <TCPIP_STACK_AddressServiceDefaultSet>
    _TCPIPStackSetConfigAddress(pNetIf, 0, 0, true);
   1ee12:	2301      	movs	r3, #1
   1ee14:	2200      	movs	r2, #0
   1ee16:	4611      	mov	r1, r2
   1ee18:	4620      	mov	r0, r4
   1ee1a:	f001 fdb4 	bl	20986 <_TCPIPStackSetConfigAddress>
    _DHCPSRemoveCacheEntries(&gPdhcpsHashDcpt);
   1ee1e:	4803      	ldr	r0, [pc, #12]	; (1ee2c <TCPIP_DHCPS_Disable+0x44>)
   1ee20:	f005 f898 	bl	23f54 <_DHCPSRemoveCacheEntries>
    return true;
   1ee24:	2001      	movs	r0, #1
   1ee26:	e7e8      	b.n	1edfa <TCPIP_DHCPS_Disable+0x12>
        return false;
   1ee28:	2000      	movs	r0, #0
}
   1ee2a:	4770      	bx	lr
   1ee2c:	2000ed7c 	.word	0x2000ed7c

Disassembly of section .text.SERCOM1_USART_ReadNotificationSend%618:

0001ee30 <SERCOM1_USART_ReadNotificationSend>:
{
   1ee30:	b508      	push	{r3, lr}
    if (sercom1USARTObj.isRdNotificationEnabled == true)
   1ee32:	4b10      	ldr	r3, [pc, #64]	; (1ee74 <SERCOM1_USART_ReadNotificationSend+0x44>)
   1ee34:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
   1ee38:	b903      	cbnz	r3, 1ee3c <SERCOM1_USART_ReadNotificationSend+0xc>
}
   1ee3a:	bd08      	pop	{r3, pc}
        nUnreadBytesAvailable = SERCOM1_USART_ReadCountGet();
   1ee3c:	f004 fcd6 	bl	237ec <SERCOM1_USART_ReadCountGet>
        if(sercom1USARTObj.rdCallback != NULL)
   1ee40:	4b0c      	ldr	r3, [pc, #48]	; (1ee74 <SERCOM1_USART_ReadNotificationSend+0x44>)
   1ee42:	6a1b      	ldr	r3, [r3, #32]
   1ee44:	2b00      	cmp	r3, #0
   1ee46:	d0f8      	beq.n	1ee3a <SERCOM1_USART_ReadNotificationSend+0xa>
            if (sercom1USARTObj.isRdNotifyPersistently == true)
   1ee48:	4a0a      	ldr	r2, [pc, #40]	; (1ee74 <SERCOM1_USART_ReadNotificationSend+0x44>)
   1ee4a:	f892 203c 	ldrb.w	r2, [r2, #60]	; 0x3c
   1ee4e:	b142      	cbz	r2, 1ee62 <SERCOM1_USART_ReadNotificationSend+0x32>
                if (nUnreadBytesAvailable >= sercom1USARTObj.rdThreshold)
   1ee50:	4a08      	ldr	r2, [pc, #32]	; (1ee74 <SERCOM1_USART_ReadNotificationSend+0x44>)
   1ee52:	6b92      	ldr	r2, [r2, #56]	; 0x38
   1ee54:	4282      	cmp	r2, r0
   1ee56:	d8f0      	bhi.n	1ee3a <SERCOM1_USART_ReadNotificationSend+0xa>
                    sercom1USARTObj.rdCallback(SERCOM_USART_EVENT_READ_THRESHOLD_REACHED, sercom1USARTObj.rdContext);
   1ee58:	4a06      	ldr	r2, [pc, #24]	; (1ee74 <SERCOM1_USART_ReadNotificationSend+0x44>)
   1ee5a:	6a51      	ldr	r1, [r2, #36]	; 0x24
   1ee5c:	2000      	movs	r0, #0
   1ee5e:	4798      	blx	r3
   1ee60:	e7eb      	b.n	1ee3a <SERCOM1_USART_ReadNotificationSend+0xa>
                if (nUnreadBytesAvailable == sercom1USARTObj.rdThreshold)
   1ee62:	4a04      	ldr	r2, [pc, #16]	; (1ee74 <SERCOM1_USART_ReadNotificationSend+0x44>)
   1ee64:	6b92      	ldr	r2, [r2, #56]	; 0x38
   1ee66:	4282      	cmp	r2, r0
   1ee68:	d1e7      	bne.n	1ee3a <SERCOM1_USART_ReadNotificationSend+0xa>
                    sercom1USARTObj.rdCallback(SERCOM_USART_EVENT_READ_THRESHOLD_REACHED, sercom1USARTObj.rdContext);
   1ee6a:	4a02      	ldr	r2, [pc, #8]	; (1ee74 <SERCOM1_USART_ReadNotificationSend+0x44>)
   1ee6c:	6a51      	ldr	r1, [r2, #36]	; 0x24
   1ee6e:	2000      	movs	r0, #0
   1ee70:	4798      	blx	r3
}
   1ee72:	e7e2      	b.n	1ee3a <SERCOM1_USART_ReadNotificationSend+0xa>
   1ee74:	2000e9c0 	.word	0x2000e9c0

Disassembly of section .rodata.keySeqTbl%619:

0001ee78 <keySeqTbl>:
   1ee78:	0000ebe0 00022f31 00000003 0000ebe4     ....1/..........
   1ee88:	00023835 00000003 0000ebe8 00022cc1     58...........,..
   1ee98:	00000003 0000ebec 000231b9 00000003     .........1......
   1eea8:	0000ebf0 0002145d 00000004 0000ebf8     ....]...........
   1eeb8:	0002142d 00000004                       -.......

Disassembly of section .text.xPortStartScheduler%620:

0001eec0 <xPortStartScheduler>:
{
   1eec0:	b510      	push	{r4, lr}
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
   1eec2:	4b0e      	ldr	r3, [pc, #56]	; (1eefc <xPortStartScheduler+0x3c>)
   1eec4:	681a      	ldr	r2, [r3, #0]
   1eec6:	f442 0260 	orr.w	r2, r2, #14680064	; 0xe00000
   1eeca:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
   1eecc:	681a      	ldr	r2, [r3, #0]
   1eece:	f042 4260 	orr.w	r2, r2, #3758096384	; 0xe0000000
   1eed2:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
   1eed4:	f003 fa16 	bl	22304 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
   1eed8:	2400      	movs	r4, #0
   1eeda:	4b09      	ldr	r3, [pc, #36]	; (1ef00 <xPortStartScheduler+0x40>)
   1eedc:	601c      	str	r4, [r3, #0]
	vPortEnableVFP();
   1eede:	f004 fe65 	bl	23bac <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
   1eee2:	4a08      	ldr	r2, [pc, #32]	; (1ef04 <xPortStartScheduler+0x44>)
   1eee4:	6813      	ldr	r3, [r2, #0]
   1eee6:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
   1eeea:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
   1eeec:	f003 f9f6 	bl	222dc <prvPortStartFirstTask>
	vTaskSwitchContext();
   1eef0:	f7fa f842 	bl	18f78 <vTaskSwitchContext>
	prvTaskExitError();
   1eef4:	f003 ff34 	bl	22d60 <prvTaskExitError>
}
   1eef8:	4620      	mov	r0, r4
   1eefa:	bd10      	pop	{r4, pc}
   1eefc:	e000ed20 	.word	0xe000ed20
   1ef00:	2000eef4 	.word	0x2000eef4
   1ef04:	e000ef34 	.word	0xe000ef34

Disassembly of section .text.wc_CryptoCb_FindDeviceByIndex%621:

0001ef08 <wc_CryptoCb_FindDeviceByIndex>:
    for (i=startIdx; i<MAX_CRYPTO_DEVID_CALLBACKS; i++) {
   1ef08:	2807      	cmp	r0, #7
   1ef0a:	dc1c      	bgt.n	1ef46 <wc_CryptoCb_FindDeviceByIndex+0x3e>
        if (gCryptoDev[i].devId != INVALID_DEVID)
   1ef0c:	eb00 0340 	add.w	r3, r0, r0, lsl #1
   1ef10:	4a0e      	ldr	r2, [pc, #56]	; (1ef4c <wc_CryptoCb_FindDeviceByIndex+0x44>)
   1ef12:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1ef16:	f113 0f02 	cmn.w	r3, #2
   1ef1a:	d10c      	bne.n	1ef36 <wc_CryptoCb_FindDeviceByIndex+0x2e>
   1ef1c:	eb00 0340 	add.w	r3, r0, r0, lsl #1
   1ef20:	4a0a      	ldr	r2, [pc, #40]	; (1ef4c <wc_CryptoCb_FindDeviceByIndex+0x44>)
   1ef22:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    for (i=startIdx; i<MAX_CRYPTO_DEVID_CALLBACKS; i++) {
   1ef26:	3001      	adds	r0, #1
   1ef28:	2808      	cmp	r0, #8
   1ef2a:	d00a      	beq.n	1ef42 <wc_CryptoCb_FindDeviceByIndex+0x3a>
        if (gCryptoDev[i].devId != INVALID_DEVID)
   1ef2c:	f853 2f0c 	ldr.w	r2, [r3, #12]!
   1ef30:	f112 0f02 	cmn.w	r2, #2
   1ef34:	d0f7      	beq.n	1ef26 <wc_CryptoCb_FindDeviceByIndex+0x1e>
            return &gCryptoDev[i];
   1ef36:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   1ef3a:	4b04      	ldr	r3, [pc, #16]	; (1ef4c <wc_CryptoCb_FindDeviceByIndex+0x44>)
   1ef3c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1ef40:	4770      	bx	lr
    return NULL;
   1ef42:	2000      	movs	r0, #0
   1ef44:	4770      	bx	lr
   1ef46:	2000      	movs	r0, #0
}
   1ef48:	4770      	bx	lr
   1ef4a:	bf00      	nop
   1ef4c:	2000e8b4 	.word	0x2000e8b4

Disassembly of section .text.__libc_init_array%622:

0001ef50 <__libc_init_array>:
   1ef50:	b570      	push	{r4, r5, r6, lr}
   1ef52:	4d0d      	ldr	r5, [pc, #52]	; (1ef88 <__libc_init_array+0x38>)
   1ef54:	4c0d      	ldr	r4, [pc, #52]	; (1ef8c <__libc_init_array+0x3c>)
   1ef56:	1b64      	subs	r4, r4, r5
   1ef58:	10a4      	asrs	r4, r4, #2
   1ef5a:	2600      	movs	r6, #0
   1ef5c:	42a6      	cmp	r6, r4
   1ef5e:	d109      	bne.n	1ef74 <__libc_init_array+0x24>
   1ef60:	4d0b      	ldr	r5, [pc, #44]	; (1ef90 <__libc_init_array+0x40>)
   1ef62:	4c0c      	ldr	r4, [pc, #48]	; (1ef94 <__libc_init_array+0x44>)
   1ef64:	f7e1 f97e 	bl	264 <_init>
   1ef68:	1b64      	subs	r4, r4, r5
   1ef6a:	10a4      	asrs	r4, r4, #2
   1ef6c:	2600      	movs	r6, #0
   1ef6e:	42a6      	cmp	r6, r4
   1ef70:	d105      	bne.n	1ef7e <__libc_init_array+0x2e>
   1ef72:	bd70      	pop	{r4, r5, r6, pc}
   1ef74:	f855 3b04 	ldr.w	r3, [r5], #4
   1ef78:	4798      	blx	r3
   1ef7a:	3601      	adds	r6, #1
   1ef7c:	e7ee      	b.n	1ef5c <__libc_init_array+0xc>
   1ef7e:	f855 3b04 	ldr.w	r3, [r5], #4
   1ef82:	4798      	blx	r3
   1ef84:	3601      	adds	r6, #1
   1ef86:	e7f2      	b.n	1ef6e <__libc_init_array+0x1e>
   1ef88:	00000270 	.word	0x00000270
   1ef8c:	00000270 	.word	0x00000270
   1ef90:	00000270 	.word	0x00000270
   1ef94:	00000274 	.word	0x00000274

Disassembly of section .text.srand%623:

0001ef98 <srand>:
   1ef98:	b538      	push	{r3, r4, r5, lr}
   1ef9a:	4b0d      	ldr	r3, [pc, #52]	; (1efd0 <srand+0x38>)
   1ef9c:	681c      	ldr	r4, [r3, #0]
   1ef9e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1efa0:	4605      	mov	r5, r0
   1efa2:	b97b      	cbnz	r3, 1efc4 <srand+0x2c>
   1efa4:	2018      	movs	r0, #24
   1efa6:	f004 ff6b 	bl	23e80 <malloc>
   1efaa:	4a0a      	ldr	r2, [pc, #40]	; (1efd4 <srand+0x3c>)
   1efac:	4b0a      	ldr	r3, [pc, #40]	; (1efd8 <srand+0x40>)
   1efae:	63a0      	str	r0, [r4, #56]	; 0x38
   1efb0:	e9c0 2300 	strd	r2, r3, [r0]
   1efb4:	4b09      	ldr	r3, [pc, #36]	; (1efdc <srand+0x44>)
   1efb6:	6083      	str	r3, [r0, #8]
   1efb8:	230b      	movs	r3, #11
   1efba:	8183      	strh	r3, [r0, #12]
   1efbc:	2201      	movs	r2, #1
   1efbe:	2300      	movs	r3, #0
   1efc0:	e9c0 2304 	strd	r2, r3, [r0, #16]
   1efc4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1efc6:	2200      	movs	r2, #0
   1efc8:	611d      	str	r5, [r3, #16]
   1efca:	615a      	str	r2, [r3, #20]
   1efcc:	bd38      	pop	{r3, r4, r5, pc}
   1efce:	bf00      	nop
   1efd0:	2000ef60 	.word	0x2000ef60
   1efd4:	abcd330e 	.word	0xabcd330e
   1efd8:	e66d1234 	.word	0xe66d1234
   1efdc:	0005deec 	.word	0x0005deec

Disassembly of section .text.std%624:

0001efe0 <std>:
   1efe0:	2300      	movs	r3, #0
   1efe2:	b510      	push	{r4, lr}
   1efe4:	4604      	mov	r4, r0
   1efe6:	e9c0 3300 	strd	r3, r3, [r0]
   1efea:	6083      	str	r3, [r0, #8]
   1efec:	8181      	strh	r1, [r0, #12]
   1efee:	6603      	str	r3, [r0, #96]	; 0x60
   1eff0:	81c2      	strh	r2, [r0, #14]
   1eff2:	e9c0 3304 	strd	r3, r3, [r0, #16]
   1eff6:	6183      	str	r3, [r0, #24]
   1eff8:	4619      	mov	r1, r3
   1effa:	2208      	movs	r2, #8
   1effc:	3058      	adds	r0, #88	; 0x58
   1effe:	f004 ff4f 	bl	23ea0 <memset>
   1f002:	4b05      	ldr	r3, [pc, #20]	; (1f018 <std+0x38>)
   1f004:	6263      	str	r3, [r4, #36]	; 0x24
   1f006:	4b05      	ldr	r3, [pc, #20]	; (1f01c <std+0x3c>)
   1f008:	62a3      	str	r3, [r4, #40]	; 0x28
   1f00a:	4b05      	ldr	r3, [pc, #20]	; (1f020 <std+0x40>)
   1f00c:	62e3      	str	r3, [r4, #44]	; 0x2c
   1f00e:	4b05      	ldr	r3, [pc, #20]	; (1f024 <std+0x44>)
   1f010:	6224      	str	r4, [r4, #32]
   1f012:	6323      	str	r3, [r4, #48]	; 0x30
   1f014:	bd10      	pop	{r4, pc}
   1f016:	bf00      	nop
   1f018:	0002297f 	.word	0x0002297f
   1f01c:	000208ad 	.word	0x000208ad
   1f020:	00022821 	.word	0x00022821
   1f024:	00024459 	.word	0x00024459

Disassembly of section .text.__swhatbuf_r%625:

0001f028 <__swhatbuf_r>:
   1f028:	b570      	push	{r4, r5, r6, lr}
   1f02a:	460e      	mov	r6, r1
   1f02c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   1f030:	2900      	cmp	r1, #0
   1f032:	b090      	sub	sp, #64	; 0x40
   1f034:	4614      	mov	r4, r2
   1f036:	461d      	mov	r5, r3
   1f038:	da07      	bge.n	1f04a <__swhatbuf_r+0x22>
   1f03a:	2300      	movs	r3, #0
   1f03c:	602b      	str	r3, [r5, #0]
   1f03e:	89b3      	ldrh	r3, [r6, #12]
   1f040:	061a      	lsls	r2, r3, #24
   1f042:	d410      	bmi.n	1f066 <__swhatbuf_r+0x3e>
   1f044:	f44f 6380 	mov.w	r3, #1024	; 0x400
   1f048:	e00e      	b.n	1f068 <__swhatbuf_r+0x40>
   1f04a:	aa01      	add	r2, sp, #4
   1f04c:	f003 fc0c 	bl	22868 <_fstat_r>
   1f050:	2800      	cmp	r0, #0
   1f052:	dbf2      	blt.n	1f03a <__swhatbuf_r+0x12>
   1f054:	9a02      	ldr	r2, [sp, #8]
   1f056:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
   1f05a:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
   1f05e:	425a      	negs	r2, r3
   1f060:	415a      	adcs	r2, r3
   1f062:	602a      	str	r2, [r5, #0]
   1f064:	e7ee      	b.n	1f044 <__swhatbuf_r+0x1c>
   1f066:	2340      	movs	r3, #64	; 0x40
   1f068:	2000      	movs	r0, #0
   1f06a:	6023      	str	r3, [r4, #0]
   1f06c:	b010      	add	sp, #64	; 0x40
   1f06e:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.Lan867x_Write_Register%626:

0001f070 <Lan867x_Write_Register>:
{
   1f070:	b510      	push	{r4, lr}
   1f072:	b082      	sub	sp, #8
   1f074:	4604      	mov	r4, r0
   1f076:	f8ad 2006 	strh.w	r2, [sp, #6]
    if (R2F(clientObj->vendorData, VENDOR_INTERNAL_STATE) == IDLE_PHASE) {
   1f07a:	6843      	ldr	r3, [r0, #4]
   1f07c:	0e5a      	lsrs	r2, r3, #25
   1f07e:	d00f      	beq.n	1f0a0 <Lan867x_Write_Register+0x30>
    res = Lan867x_Miim_Task(clientObj, DRV_MIIM_OP_WRITE, regAddr, &wData);
   1f080:	f10d 0306 	add.w	r3, sp, #6
   1f084:	460a      	mov	r2, r1
   1f086:	2102      	movs	r1, #2
   1f088:	4620      	mov	r0, r4
   1f08a:	f7f1 f97f 	bl	1038c <Lan867x_Miim_Task>
    if (res == DRV_MIIM_RES_OK) {
   1f08e:	4603      	mov	r3, r0
   1f090:	b918      	cbnz	r0, 1f09a <Lan867x_Write_Register+0x2a>
        clientObj->vendorData = F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   1f092:	6862      	ldr	r2, [r4, #4]
   1f094:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   1f098:	6062      	str	r2, [r4, #4]
}
   1f09a:	4618      	mov	r0, r3
   1f09c:	b002      	add	sp, #8
   1f09e:	bd10      	pop	{r4, pc}
            F2R(initialState, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   1f0a0:	291f      	cmp	r1, #31
   1f0a2:	bf94      	ite	ls
   1f0a4:	f04f 6280 	movls.w	r2, #67108864	; 0x4000000
   1f0a8:	f04f 6200 	movhi.w	r2, #134217728	; 0x8000000
   1f0ac:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
        clientObj->vendorData = F2R(false, VENDOR_IS_BIT_OP, clientObj->vendorData);
   1f0b0:	4313      	orrs	r3, r2
   1f0b2:	6043      	str	r3, [r0, #4]
   1f0b4:	e7e4      	b.n	1f080 <Lan867x_Write_Register+0x10>

Disassembly of section .text._DRV_GMAC_LinkStateGetLink%627:

0001f0b6 <_DRV_GMAC_LinkStateGetLink>:
{
   1f0b6:	b538      	push	{r3, r4, r5, lr}
   1f0b8:	4604      	mov	r4, r0
	pPhyBase =  pMACDrv->sGmacData.gmacConfig.pPhyBase;
   1f0ba:	f8d0 50d8 	ldr.w	r5, [r0, #216]	; 0xd8
	phyStat = pPhyBase->DRV_ETHPHY_ClientStatus( pMACDrv->sGmacData.hPhyClient );
   1f0be:	69eb      	ldr	r3, [r5, #28]
   1f0c0:	6900      	ldr	r0, [r0, #16]
   1f0c2:	4798      	blx	r3
	if(phyStat == DRV_ETHPHY_CLIENT_STATUS_BUSY)
   1f0c4:	2801      	cmp	r0, #1
   1f0c6:	d010      	beq.n	1f0ea <_DRV_GMAC_LinkStateGetLink+0x34>
	phyRes = pPhyBase->DRV_ETHPHY_ClientOperationResult(pMACDrv->sGmacData.hPhyClient);
   1f0c8:	6a2b      	ldr	r3, [r5, #32]
   1f0ca:	6920      	ldr	r0, [r4, #16]
   1f0cc:	4798      	blx	r3
	if(phyRes != DRV_ETHPHY_RES_OK)
   1f0ce:	b968      	cbnz	r0, 1f0ec <_DRV_GMAC_LinkStateGetLink+0x36>
	if(linkCurrUp == false)
   1f0d0:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
   1f0d4:	f013 0f01 	tst.w	r3, #1
   1f0d8:	d00c      	beq.n	1f0f4 <_DRV_GMAC_LinkStateGetLink+0x3e>
	if( (bool) pMACDrv->sGmacData._macFlags._linkPrev == linkCurrUp )
   1f0da:	7da3      	ldrb	r3, [r4, #22]
   1f0dc:	f013 0f10 	tst.w	r3, #16
		pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_START_LINK;
   1f0e0:	bf14      	ite	ne
   1f0e2:	2300      	movne	r3, #0
		pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_WAIT_LINK_UP;
   1f0e4:	2302      	moveq	r3, #2
   1f0e6:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
}
   1f0ea:	bd38      	pop	{r3, r4, r5, pc}
		_DRV_GMAC_LinkStateDown(pMACDrv);
   1f0ec:	4620      	mov	r0, r4
   1f0ee:	f003 fea7 	bl	22e40 <_DRV_GMAC_LinkStateDown>
		return;
   1f0f2:	e7fa      	b.n	1f0ea <_DRV_GMAC_LinkStateGetLink+0x34>
		_DRV_GMAC_LinkStateDown(pMACDrv);
   1f0f4:	4620      	mov	r0, r4
   1f0f6:	f003 fea3 	bl	22e40 <_DRV_GMAC_LinkStateDown>
		return;
   1f0fa:	e7f6      	b.n	1f0ea <_DRV_GMAC_LinkStateGetLink+0x34>

Disassembly of section .text.TCPIP_TCP_FifoTxFullGet%628:

0001f0fc <TCPIP_TCP_FifoTxFullGet>:
{
   1f0fc:	b510      	push	{r4, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   1f0fe:	f002 ff0d 	bl	21f1c <_TcpSocketChk>
    if(pSkt != 0 && _TCP_TxPktValid(pSkt))
   1f102:	b1d0      	cbz	r0, 1f13a <TCPIP_TCP_FifoTxFullGet+0x3e>
   1f104:	4604      	mov	r4, r0
    switch(pSkt->addType)
   1f106:	f890 306f 	ldrb.w	r3, [r0, #111]	; 0x6f
   1f10a:	2b01      	cmp	r3, #1
   1f10c:	d001      	beq.n	1f112 <TCPIP_TCP_FifoTxFullGet+0x16>
    return 0;
   1f10e:	2000      	movs	r0, #0
}
   1f110:	bd10      	pop	{r4, pc}
    if(pSkt != 0 && _TCP_TxPktValid(pSkt))
   1f112:	6c43      	ldr	r3, [r0, #68]	; 0x44
   1f114:	b19b      	cbz	r3, 1f13e <TCPIP_TCP_FifoTxFullGet+0x42>
        if((pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED) || (pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT))
   1f116:	f890 306e 	ldrb.w	r3, [r0, #110]	; 0x6e
   1f11a:	2b03      	cmp	r3, #3
   1f11c:	d003      	beq.n	1f126 <TCPIP_TCP_FifoTxFullGet+0x2a>
   1f11e:	2b08      	cmp	r3, #8
   1f120:	d001      	beq.n	1f126 <TCPIP_TCP_FifoTxFullGet+0x2a>
    return 0;
   1f122:	2000      	movs	r0, #0
   1f124:	e7f4      	b.n	1f110 <TCPIP_TCP_FifoTxFullGet+0x14>
            wDataLen = _TCPSocketTxFreeSize(pSkt);
   1f126:	4620      	mov	r0, r4
   1f128:	f002 f830 	bl	2118c <_TCPSocketTxFreeSize>
            wFIFOSize = pSkt->txEnd - pSkt->txStart - 1;
   1f12c:	6863      	ldr	r3, [r4, #4]
   1f12e:	6822      	ldr	r2, [r4, #0]
   1f130:	1a9b      	subs	r3, r3, r2
   1f132:	3b01      	subs	r3, #1
            return wFIFOSize - wDataLen;
   1f134:	1a18      	subs	r0, r3, r0
   1f136:	b280      	uxth	r0, r0
   1f138:	e7ea      	b.n	1f110 <TCPIP_TCP_FifoTxFullGet+0x14>
    return 0;
   1f13a:	2000      	movs	r0, #0
   1f13c:	e7e8      	b.n	1f110 <TCPIP_TCP_FifoTxFullGet+0x14>
   1f13e:	2000      	movs	r0, #0
   1f140:	e7e6      	b.n	1f110 <TCPIP_TCP_FifoTxFullGet+0x14>

Disassembly of section .text.TCPIP_ARP_Resolve%629:

0001f142 <TCPIP_ARP_Resolve>:
    if(IPAddr == 0 || IPAddr->Val == 0)
   1f142:	b1a9      	cbz	r1, 1f170 <TCPIP_ARP_Resolve+0x2e>
{
   1f144:	b530      	push	{r4, r5, lr}
   1f146:	b083      	sub	sp, #12
   1f148:	460c      	mov	r4, r1
    if(IPAddr == 0 || IPAddr->Val == 0)
   1f14a:	680a      	ldr	r2, [r1, #0]
   1f14c:	b19a      	cbz	r2, 1f176 <TCPIP_ARP_Resolve+0x34>
    pIf = _TCPIPStackHandleToNetLinked(hNet);
   1f14e:	f003 fd77 	bl	22c40 <_TCPIPStackHandleToNetLinked>
    if(pIf == 0)
   1f152:	b198      	cbz	r0, 1f17c <TCPIP_ARP_Resolve+0x3a>
    return pNetIf->Flags.bInConfig != 0;
   1f154:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
    if(_TCPIPStackIsConfig(pIf))
   1f158:	f013 0f10 	tst.w	r3, #16
   1f15c:	d111      	bne.n	1f182 <TCPIP_ARP_Resolve+0x40>
    return _ARPProbeAddress(pIf, IPAddr, &pIf->netIPAddr, ARP_OPERATION_REQ, 0);
   1f15e:	2300      	movs	r3, #0
   1f160:	9300      	str	r3, [sp, #0]
   1f162:	2301      	movs	r3, #1
   1f164:	1d02      	adds	r2, r0, #4
   1f166:	4621      	mov	r1, r4
   1f168:	f7f7 f8c6 	bl	162f8 <_ARPProbeAddress>
}
   1f16c:	b003      	add	sp, #12
   1f16e:	bd30      	pop	{r4, r5, pc}
        return ARP_RES_BAD_ADDRESS;
   1f170:	f06f 0004 	mvn.w	r0, #4
}
   1f174:	4770      	bx	lr
        return ARP_RES_BAD_ADDRESS;
   1f176:	f06f 0004 	mvn.w	r0, #4
   1f17a:	e7f7      	b.n	1f16c <TCPIP_ARP_Resolve+0x2a>
        return ARP_RES_NO_INTERFACE;
   1f17c:	f06f 0005 	mvn.w	r0, #5
   1f180:	e7f4      	b.n	1f16c <TCPIP_ARP_Resolve+0x2a>
        return ARP_RES_CONFIGURE_ERR;
   1f182:	f06f 0007 	mvn.w	r0, #7
   1f186:	e7f1      	b.n	1f16c <TCPIP_ARP_Resolve+0x2a>

Disassembly of section .text._TCPIP_HEAP_Delete%630:

0001f188 <_TCPIP_HEAP_Delete>:
    if(hInst == 0)
   1f188:	b1f0      	cbz	r0, 1f1c8 <_TCPIP_HEAP_Delete+0x40>
{
   1f18a:	b510      	push	{r4, lr}
   1f18c:	4604      	mov	r4, r0
    if(hDcpt->_heapHead)
   1f18e:	6a43      	ldr	r3, [r0, #36]	; 0x24
   1f190:	b1a3      	cbz	r3, 1f1bc <_TCPIP_HEAP_Delete+0x34>
        if(hDcpt->_heapAllocatedUnits != 0)
   1f192:	6b03      	ldr	r3, [r0, #48]	; 0x30
   1f194:	b963      	cbnz	r3, 1f1b0 <_TCPIP_HEAP_Delete+0x28>
        OSAL_SEM_Delete(&hDcpt->_heapSemaphore);
   1f196:	3044      	adds	r0, #68	; 0x44
   1f198:	f004 fd71 	bl	23c7e <OSAL_SEM_Delete>
        memset(&hInst->heapObj, 0, sizeof(hInst->heapObj));
   1f19c:	2224      	movs	r2, #36	; 0x24
   1f19e:	2100      	movs	r1, #0
   1f1a0:	4620      	mov	r0, r4
   1f1a2:	f004 fe7d 	bl	23ea0 <memset>
        (*hDcpt->free_fnc)(hDcpt->allocatedBuffer);
   1f1a6:	6c23      	ldr	r3, [r4, #64]	; 0x40
   1f1a8:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1f1aa:	4798      	blx	r3
        return TCPIP_STACK_HEAP_RES_OK;
   1f1ac:	2000      	movs	r0, #0
}
   1f1ae:	bd10      	pop	{r4, pc}
            return (hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_IN_USE); 
   1f1b0:	23f9      	movs	r3, #249	; 0xf9
   1f1b2:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
   1f1b6:	f06f 0006 	mvn.w	r0, #6
   1f1ba:	e7f8      	b.n	1f1ae <_TCPIP_HEAP_Delete+0x26>
    return (hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_IN_USE); 
   1f1bc:	23f9      	movs	r3, #249	; 0xf9
   1f1be:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
   1f1c2:	f06f 0006 	mvn.w	r0, #6
   1f1c6:	e7f2      	b.n	1f1ae <_TCPIP_HEAP_Delete+0x26>
        return TCPIP_STACK_HEAP_RES_NO_HEAP; 
   1f1c8:	f06f 0008 	mvn.w	r0, #8
}
   1f1cc:	4770      	bx	lr

Disassembly of section .text.TCPIP_Helper_SingleListNodeRemove%631:

0001f1ce <TCPIP_Helper_SingleListNodeRemove>:
// Use a double linked list if faster operation needed!



SGL_LIST_NODE*  TCPIP_Helper_SingleListNodeRemove(SINGLE_LIST* pL, SGL_LIST_NODE* pN)
{
   1f1ce:	b510      	push	{r4, lr}
    if(pN == pL->head)
   1f1d0:	6802      	ldr	r2, [r0, #0]
   1f1d2:	428a      	cmp	r2, r1
   1f1d4:	d00b      	beq.n	1f1ee <TCPIP_Helper_SingleListNodeRemove+0x20>
        TCPIP_Helper_SingleListHeadRemove(pL);
    }
    else
    {
        SGL_LIST_NODE* prev;
        for(prev = pL->head; prev != 0 && prev->next != pN; prev = prev->next);
   1f1d6:	b182      	cbz	r2, 1f1fa <TCPIP_Helper_SingleListNodeRemove+0x2c>
   1f1d8:	6814      	ldr	r4, [r2, #0]
   1f1da:	42a1      	cmp	r1, r4
   1f1dc:	bf08      	it	eq
   1f1de:	4614      	moveq	r4, r2
   1f1e0:	d00d      	beq.n	1f1fe <TCPIP_Helper_SingleListNodeRemove+0x30>
   1f1e2:	b1ac      	cbz	r4, 1f210 <TCPIP_Helper_SingleListNodeRemove+0x42>
   1f1e4:	6822      	ldr	r2, [r4, #0]
   1f1e6:	428a      	cmp	r2, r1
   1f1e8:	d009      	beq.n	1f1fe <TCPIP_Helper_SingleListNodeRemove+0x30>
   1f1ea:	4614      	mov	r4, r2
   1f1ec:	e7f9      	b.n	1f1e2 <TCPIP_Helper_SingleListNodeRemove+0x14>
   1f1ee:	460c      	mov	r4, r1
        TCPIP_Helper_SingleListHeadRemove(pL);
   1f1f0:	f003 ff3a 	bl	23068 <TCPIP_Helper_SingleListHeadRemove>
   1f1f4:	e00c      	b.n	1f210 <TCPIP_Helper_SingleListNodeRemove+0x42>
        }
        // found it
        prev->next = pN->next;
        if(pN == pL->tail)
        {
            pL->tail = prev;
   1f1f6:	6044      	str	r4, [r0, #4]
   1f1f8:	e006      	b.n	1f208 <TCPIP_Helper_SingleListNodeRemove+0x3a>
            return 0;
   1f1fa:	4614      	mov	r4, r2
   1f1fc:	e008      	b.n	1f210 <TCPIP_Helper_SingleListNodeRemove+0x42>
        prev->next = pN->next;
   1f1fe:	680a      	ldr	r2, [r1, #0]
   1f200:	6022      	str	r2, [r4, #0]
        if(pN == pL->tail)
   1f202:	6842      	ldr	r2, [r0, #4]
   1f204:	428a      	cmp	r2, r1
   1f206:	d0f6      	beq.n	1f1f6 <TCPIP_Helper_SingleListNodeRemove+0x28>
        }
        pL->nNodes--;
   1f208:	6883      	ldr	r3, [r0, #8]
   1f20a:	3b01      	subs	r3, #1
   1f20c:	6083      	str	r3, [r0, #8]
    }

    return pN;
   1f20e:	460c      	mov	r4, r1
}
   1f210:	4620      	mov	r0, r4
   1f212:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_Notification_CbackRemove%632:

0001f214 <TCPIP_Notification_CbackRemove>:
    return false;

}

bool TCPIP_Notification_CbackRemove(SGL_LIST_NODE* node, PROTECTED_SINGLE_LIST* notifyList, TCPIP_STACK_HEAP_HANDLE heapH, void (*pCback)(SGL_LIST_NODE* node))
{
   1f214:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1f218:	4606      	mov	r6, r0
   1f21a:	460c      	mov	r4, r1
   1f21c:	4690      	mov	r8, r2
   1f21e:	461f      	mov	r7, r3
    if(TCPIP_Helper_ProtectedSingleListLock(notifyList))
   1f220:	4608      	mov	r0, r1
   1f222:	f003 fcdd 	bl	22be0 <TCPIP_Helper_ProtectedSingleListLock>
   1f226:	4605      	mov	r5, r0
   1f228:	b910      	cbnz	r0, 1f230 <TCPIP_Notification_CbackRemove+0x1c>
            TCPIP_HEAP_Free(heapH, node);
            return true;
        }
    }
    return false;
}
   1f22a:	4628      	mov	r0, r5
   1f22c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        SGL_LIST_NODE* ret = TCPIP_Helper_SingleListNodeRemove(&notifyList->list, node);
   1f230:	4631      	mov	r1, r6
   1f232:	4620      	mov	r0, r4
   1f234:	f7ff ffcb 	bl	1f1ce <TCPIP_Helper_SingleListNodeRemove>
        if(ret && pCback)
   1f238:	b150      	cbz	r0, 1f250 <TCPIP_Notification_CbackRemove+0x3c>
   1f23a:	b107      	cbz	r7, 1f23e <TCPIP_Notification_CbackRemove+0x2a>
            (*pCback)(ret);
   1f23c:	47b8      	blx	r7
        TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
   1f23e:	4620      	mov	r0, r4
   1f240:	f003 ff20 	bl	23084 <TCPIP_Helper_ProtectedSingleListUnlock>
   1f244:	f8d8 300c 	ldr.w	r3, [r8, #12]
   1f248:	4631      	mov	r1, r6
   1f24a:	4640      	mov	r0, r8
   1f24c:	4798      	blx	r3
            return true;
   1f24e:	e7ec      	b.n	1f22a <TCPIP_Notification_CbackRemove+0x16>
        TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
   1f250:	4620      	mov	r0, r4
   1f252:	f003 ff17 	bl	23084 <TCPIP_Helper_ProtectedSingleListUnlock>
    return false;
   1f256:	2500      	movs	r5, #0
   1f258:	e7e7      	b.n	1f22a <TCPIP_Notification_CbackRemove+0x16>

Disassembly of section .text.TCPIP_UDP_SignalHandlerRegister%633:

0001f25a <TCPIP_UDP_SignalHandlerRegister>:

    return true;
}

TCPIP_UDP_SIGNAL_HANDLE TCPIP_UDP_SignalHandlerRegister(UDP_SOCKET s, TCPIP_UDP_SIGNAL_TYPE sigMask, TCPIP_UDP_SIGNAL_FUNCTION handler, const void* hParam)
{
   1f25a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1f25e:	4604      	mov	r4, r0
   1f260:	460f      	mov	r7, r1
   1f262:	4615      	mov	r5, r2
   1f264:	4698      	mov	r8, r3
    TCPIP_UDP_SIGNAL_HANDLE sHandle = 0;

    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1f266:	2000      	movs	r0, #0
   1f268:	f004 fa84 	bl	23774 <OSAL_CRIT_Enter>
   1f26c:	4606      	mov	r6, r0
    if(handler != 0)
   1f26e:	b19d      	cbz	r5, 1f298 <TCPIP_UDP_SignalHandlerRegister+0x3e>
    {
        UDP_SOCKET_DCPT *pSkt = _UDPSocketDcpt(s);
   1f270:	4620      	mov	r0, r4
   1f272:	f002 ff6b 	bl	2214c <_UDPSocketDcpt>
        if(pSkt != 0 && pSkt->sigHandler == 0)
   1f276:	4604      	mov	r4, r0
   1f278:	b138      	cbz	r0, 1f28a <TCPIP_UDP_SignalHandlerRegister+0x30>
   1f27a:	6d03      	ldr	r3, [r0, #80]	; 0x50
   1f27c:	b973      	cbnz	r3, 1f29c <TCPIP_UDP_SignalHandlerRegister+0x42>
        {
            pSkt->sigHandler = handler;
   1f27e:	6505      	str	r5, [r0, #80]	; 0x50
            pSkt->sigParam = hParam;
   1f280:	f8c0 8054 	str.w	r8, [r0, #84]	; 0x54
            pSkt->sigMask = sigMask;
   1f284:	f8a0 7058 	strh.w	r7, [r0, #88]	; 0x58
            sHandle = (TCPIP_UDP_SIGNAL_HANDLE)handler;
   1f288:	462c      	mov	r4, r5
            // Note: this may change if multiple notfication handlers required 
        }
    }

    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1f28a:	4631      	mov	r1, r6
   1f28c:	2000      	movs	r0, #0
   1f28e:	f004 fbab 	bl	239e8 <OSAL_CRIT_Leave>
    return sHandle;
}
   1f292:	4620      	mov	r0, r4
   1f294:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    TCPIP_UDP_SIGNAL_HANDLE sHandle = 0;
   1f298:	2400      	movs	r4, #0
   1f29a:	e7f6      	b.n	1f28a <TCPIP_UDP_SignalHandlerRegister+0x30>
   1f29c:	2400      	movs	r4, #0
   1f29e:	e7f4      	b.n	1f28a <TCPIP_UDP_SignalHandlerRegister+0x30>

Disassembly of section .text.DRV_GMAC_ConfigGet%634:

0001f2a0 <DRV_GMAC_ConfigGet>:
{	
   1f2a0:	b430      	push	{r4, r5}
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1f2a2:	4c0e      	ldr	r4, [pc, #56]	; (1f2dc <DRV_GMAC_ConfigGet+0x3c>)
   1f2a4:	4284      	cmp	r4, r0
   1f2a6:	d114      	bne.n	1f2d2 <DRV_GMAC_ConfigGet+0x32>
    if(pMACDrv != 0)
   1f2a8:	b1a0      	cbz	r0, 1f2d4 <DRV_GMAC_ConfigGet+0x34>
        if(pConfigSize)
   1f2aa:	b10b      	cbz	r3, 1f2b0 <DRV_GMAC_ConfigGet+0x10>
            *pConfigSize =  sizeof(TCPIP_MODULE_MAC_PIC32C_CONFIG);
   1f2ac:	2034      	movs	r0, #52	; 0x34
   1f2ae:	6018      	str	r0, [r3, #0]
        if(configBuff && buffSize >= sizeof(TCPIP_MODULE_MAC_PIC32C_CONFIG))
   1f2b0:	b191      	cbz	r1, 1f2d8 <DRV_GMAC_ConfigGet+0x38>
   1f2b2:	2a33      	cmp	r2, #51	; 0x33
   1f2b4:	d801      	bhi.n	1f2ba <DRV_GMAC_ConfigGet+0x1a>
    return 0;
   1f2b6:	2000      	movs	r0, #0
   1f2b8:	e00c      	b.n	1f2d4 <DRV_GMAC_ConfigGet+0x34>
            *pMacConfig = pMACDrv->sGmacData.gmacConfig;
   1f2ba:	460c      	mov	r4, r1
   1f2bc:	4d08      	ldr	r5, [pc, #32]	; (1f2e0 <DRV_GMAC_ConfigGet+0x40>)
   1f2be:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1f2c0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1f2c2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1f2c4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1f2c6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1f2c8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1f2ca:	682b      	ldr	r3, [r5, #0]
   1f2cc:	6023      	str	r3, [r4, #0]
            return sizeof(TCPIP_MODULE_MAC_PIC32C_CONFIG);
   1f2ce:	2034      	movs	r0, #52	; 0x34
   1f2d0:	e000      	b.n	1f2d4 <DRV_GMAC_ConfigGet+0x34>
    return 0;
   1f2d2:	2000      	movs	r0, #0
}
   1f2d4:	bc30      	pop	{r4, r5}
   1f2d6:	4770      	bx	lr
    return 0;
   1f2d8:	2000      	movs	r0, #0
   1f2da:	e7fb      	b.n	1f2d4 <DRV_GMAC_ConfigGet+0x34>
   1f2dc:	2000e288 	.word	0x2000e288
   1f2e0:	2000e340 	.word	0x2000e340

Disassembly of section .text._MacTxDiscardQueues%635:

0001f2e4 <_MacTxDiscardQueues>:
{
   1f2e4:	b570      	push	{r4, r5, r6, lr}
   1f2e6:	4605      	mov	r5, r0
   1f2e8:	460e      	mov	r6, r1
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_TXEN_Msk;           
   1f2ea:	4c0e      	ldr	r4, [pc, #56]	; (1f324 <_MacTxDiscardQueues+0x40>)
   1f2ec:	6823      	ldr	r3, [r4, #0]
   1f2ee:	f023 0308 	bic.w	r3, r3, #8
   1f2f2:	6023      	str	r3, [r4, #0]
    GMAC_REGS->GMAC_TSR = GMAC_TSR_TXCOMP_Msk;
   1f2f4:	2320      	movs	r3, #32
   1f2f6:	6163      	str	r3, [r4, #20]
    DRV_PIC32CGMAC_LibTxAckPacket(pMACDrv,queueIdx);
   1f2f8:	2100      	movs	r1, #0
   1f2fa:	f7f3 fa87 	bl	1280c <DRV_PIC32CGMAC_LibTxAckPacket>
        DRV_PIC32CGMAC_LibTxAckErrPacket(pMACDrv, queueIdx, ackRes); 
   1f2fe:	4632      	mov	r2, r6
   1f300:	2100      	movs	r1, #0
   1f302:	4628      	mov	r0, r5
   1f304:	f7fb fc82 	bl	1ac0c <DRV_PIC32CGMAC_LibTxAckErrPacket>
        DRV_PIC32CGMAC_LibTxAckPendPacket(pMACDrv, queueIdx, ackRes);  
   1f308:	4632      	mov	r2, r6
   1f30a:	2100      	movs	r1, #0
   1f30c:	4628      	mov	r0, r5
   1f30e:	f001 fe7a 	bl	21006 <DRV_PIC32CGMAC_LibTxAckPendPacket>
        DRV_PIC32CGMAC_LibTxInit(pMACDrv);
   1f312:	4628      	mov	r0, r5
   1f314:	f7fc f9ec 	bl	1b6f0 <DRV_PIC32CGMAC_LibTxInit>
    GMAC_REGS->GMAC_NCR |= GMAC_NCR_TXEN_Msk; 
   1f318:	6823      	ldr	r3, [r4, #0]
   1f31a:	f043 0308 	orr.w	r3, r3, #8
   1f31e:	6023      	str	r3, [r4, #0]
}
   1f320:	bd70      	pop	{r4, r5, r6, pc}
   1f322:	bf00      	nop
   1f324:	42000800 	.word	0x42000800

Disassembly of section .text.Helper_SingleListNodeRemove%636:

0001f328 <Helper_SingleListNodeRemove>:
// Use a double linked list if faster operation needed!



SGL_LIST_NODE*  Helper_SingleListNodeRemove(SINGLE_LIST* pL, SGL_LIST_NODE* pN)
{
   1f328:	b508      	push	{r3, lr}
    if(pN == pL->head)
   1f32a:	6803      	ldr	r3, [r0, #0]
   1f32c:	428b      	cmp	r3, r1
   1f32e:	d00c      	beq.n	1f34a <Helper_SingleListNodeRemove+0x22>
   1f330:	4602      	mov	r2, r0
        return Helper_SingleListHeadRemove(pL);
    }
    else
    {
        SGL_LIST_NODE* prev;
        for(prev = pL->head; prev != 0 && prev->next != pN; prev = prev->next);
   1f332:	b17b      	cbz	r3, 1f354 <Helper_SingleListNodeRemove+0x2c>
   1f334:	6818      	ldr	r0, [r3, #0]
   1f336:	4281      	cmp	r1, r0
   1f338:	bf08      	it	eq
   1f33a:	4618      	moveq	r0, r3
   1f33c:	d00c      	beq.n	1f358 <Helper_SingleListNodeRemove+0x30>
   1f33e:	b1a0      	cbz	r0, 1f36a <Helper_SingleListNodeRemove+0x42>
   1f340:	6803      	ldr	r3, [r0, #0]
   1f342:	428b      	cmp	r3, r1
   1f344:	d008      	beq.n	1f358 <Helper_SingleListNodeRemove+0x30>
   1f346:	4618      	mov	r0, r3
   1f348:	e7f9      	b.n	1f33e <Helper_SingleListNodeRemove+0x16>
        return Helper_SingleListHeadRemove(pL);
   1f34a:	f003 fe47 	bl	22fdc <Helper_SingleListHeadRemove>
   1f34e:	e00c      	b.n	1f36a <Helper_SingleListNodeRemove+0x42>
        }
        // found it
        prev->next = pN->next;
        if(pN == pL->tail)
        {
            pL->tail = prev;
   1f350:	6050      	str	r0, [r2, #4]
   1f352:	e006      	b.n	1f362 <Helper_SingleListNodeRemove+0x3a>
            return 0;
   1f354:	4618      	mov	r0, r3
   1f356:	e008      	b.n	1f36a <Helper_SingleListNodeRemove+0x42>
        prev->next = pN->next;
   1f358:	680b      	ldr	r3, [r1, #0]
   1f35a:	6003      	str	r3, [r0, #0]
        if(pN == pL->tail)
   1f35c:	6853      	ldr	r3, [r2, #4]
   1f35e:	428b      	cmp	r3, r1
   1f360:	d0f6      	beq.n	1f350 <Helper_SingleListNodeRemove+0x28>
        }
        pL->nNodes--;
   1f362:	6893      	ldr	r3, [r2, #8]
   1f364:	3b01      	subs	r3, #1
   1f366:	6093      	str	r3, [r2, #8]
    }

    return pN;
   1f368:	4608      	mov	r0, r1
}
   1f36a:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_TCP_SignalHandlerRegister%637:

0001f36c <TCPIP_TCP_SignalHandlerRegister>:
    }
}


TCPIP_TCP_SIGNAL_HANDLE TCPIP_TCP_SignalHandlerRegister(TCP_SOCKET s, TCPIP_TCP_SIGNAL_TYPE sigMask, TCPIP_TCP_SIGNAL_FUNCTION handler, const void* hParam)
{
   1f36c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1f370:	4604      	mov	r4, r0
   1f372:	4688      	mov	r8, r1
   1f374:	4615      	mov	r5, r2
   1f376:	461f      	mov	r7, r3
    TCPIP_TCP_SIGNAL_HANDLE sHandle = 0;

    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1f378:	2000      	movs	r0, #0
   1f37a:	f004 f9fb 	bl	23774 <OSAL_CRIT_Enter>
   1f37e:	4606      	mov	r6, r0
    if(handler != 0)
   1f380:	b195      	cbz	r5, 1f3a8 <TCPIP_TCP_SignalHandlerRegister+0x3c>
    {
        TCB_STUB* pSkt = _TcpSocketChk(s);
   1f382:	4620      	mov	r0, r4
   1f384:	f002 fdca 	bl	21f1c <_TcpSocketChk>
        if(pSkt != 0 && pSkt->sigHandler == 0)
   1f388:	4604      	mov	r4, r0
   1f38a:	b130      	cbz	r0, 1f39a <TCPIP_TCP_SignalHandlerRegister+0x2e>
   1f38c:	6f43      	ldr	r3, [r0, #116]	; 0x74
   1f38e:	b96b      	cbnz	r3, 1f3ac <TCPIP_TCP_SignalHandlerRegister+0x40>
        {
            pSkt->sigHandler = handler;
   1f390:	6745      	str	r5, [r0, #116]	; 0x74
            pSkt->sigMask = (uint16_t)sigMask;
   1f392:	f8a0 8072 	strh.w	r8, [r0, #114]	; 0x72
            pSkt->sigParam = hParam;
   1f396:	6787      	str	r7, [r0, #120]	; 0x78
            sHandle = (TCPIP_TCP_SIGNAL_HANDLE)handler;
   1f398:	462c      	mov	r4, r5
            // Note: this may change if multiple notfication handlers required 
        }
    }
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1f39a:	4631      	mov	r1, r6
   1f39c:	2000      	movs	r0, #0
   1f39e:	f004 fb23 	bl	239e8 <OSAL_CRIT_Leave>

    return sHandle;
}
   1f3a2:	4620      	mov	r0, r4
   1f3a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    TCPIP_TCP_SIGNAL_HANDLE sHandle = 0;
   1f3a8:	2400      	movs	r4, #0
   1f3aa:	e7f6      	b.n	1f39a <TCPIP_TCP_SignalHandlerRegister+0x2e>
   1f3ac:	2400      	movs	r4, #0
   1f3ae:	e7f4      	b.n	1f39a <TCPIP_TCP_SignalHandlerRegister+0x2e>

Disassembly of section .text.TCPIP_Helper_MACAddressToString%638:

0001f3b0 <TCPIP_Helper_MACAddressToString>:
    if(macAddr && buff && buffSize >= 18)
   1f3b0:	b1d0      	cbz	r0, 1f3e8 <TCPIP_Helper_MACAddressToString+0x38>
   1f3b2:	4603      	mov	r3, r0
   1f3b4:	b1d1      	cbz	r1, 1f3ec <TCPIP_Helper_MACAddressToString+0x3c>
   1f3b6:	2a11      	cmp	r2, #17
   1f3b8:	d801      	bhi.n	1f3be <TCPIP_Helper_MACAddressToString+0xe>
    return false;
   1f3ba:	2000      	movs	r0, #0
}
   1f3bc:	4770      	bx	lr
{
   1f3be:	b500      	push	{lr}
   1f3c0:	b085      	sub	sp, #20
   1f3c2:	4602      	mov	r2, r0
   1f3c4:	4608      	mov	r0, r1
        sprintf(buff, "%.2x:%.2x:%.2x:%.2x:%.2x:%.2x", *pAdd, *(pAdd+1), *(pAdd+2), *(pAdd+3), *(pAdd+4), *(pAdd+5));
   1f3c6:	795b      	ldrb	r3, [r3, #5]
   1f3c8:	9303      	str	r3, [sp, #12]
   1f3ca:	7913      	ldrb	r3, [r2, #4]
   1f3cc:	9302      	str	r3, [sp, #8]
   1f3ce:	78d3      	ldrb	r3, [r2, #3]
   1f3d0:	9301      	str	r3, [sp, #4]
   1f3d2:	7893      	ldrb	r3, [r2, #2]
   1f3d4:	9300      	str	r3, [sp, #0]
   1f3d6:	7853      	ldrb	r3, [r2, #1]
   1f3d8:	7812      	ldrb	r2, [r2, #0]
   1f3da:	4905      	ldr	r1, [pc, #20]	; (1f3f0 <TCPIP_Helper_MACAddressToString+0x40>)
   1f3dc:	f000 f93c 	bl	1f658 <siprintf>
        return true;
   1f3e0:	2001      	movs	r0, #1
}
   1f3e2:	b005      	add	sp, #20
   1f3e4:	f85d fb04 	ldr.w	pc, [sp], #4
    return false;
   1f3e8:	2000      	movs	r0, #0
   1f3ea:	4770      	bx	lr
   1f3ec:	2000      	movs	r0, #0
   1f3ee:	4770      	bx	lr
   1f3f0:	0001fa30 	.word	0x0001fa30

Disassembly of section .text.TCPIP_STACK_NetByAddress%639:

0001f3f4 <TCPIP_STACK_NetByAddress>:
{
   1f3f4:	b430      	push	{r4, r5}
    for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1f3f6:	4b0e      	ldr	r3, [pc, #56]	; (1f430 <TCPIP_STACK_NetByAddress+0x3c>)
   1f3f8:	681b      	ldr	r3, [r3, #0]
   1f3fa:	4a0e      	ldr	r2, [pc, #56]	; (1f434 <TCPIP_STACK_NetByAddress+0x40>)
   1f3fc:	6814      	ldr	r4, [r2, #0]
   1f3fe:	2c00      	cmp	r4, #0
   1f400:	dd13      	ble.n	1f42a <TCPIP_STACK_NetByAddress+0x36>
   1f402:	2200      	movs	r2, #0
   1f404:	e003      	b.n	1f40e <TCPIP_STACK_NetByAddress+0x1a>
   1f406:	3201      	adds	r2, #1
   1f408:	336c      	adds	r3, #108	; 0x6c
   1f40a:	42a2      	cmp	r2, r4
   1f40c:	d009      	beq.n	1f422 <TCPIP_STACK_NetByAddress+0x2e>
        if(pIf->Flags.bInterfaceEnabled && pIf->netIPAddr.Val == pIpAddress->Val)
   1f40e:	f893 1042 	ldrb.w	r1, [r3, #66]	; 0x42
   1f412:	f011 0f40 	tst.w	r1, #64	; 0x40
   1f416:	d0f6      	beq.n	1f406 <TCPIP_STACK_NetByAddress+0x12>
   1f418:	685d      	ldr	r5, [r3, #4]
   1f41a:	6801      	ldr	r1, [r0, #0]
   1f41c:	428d      	cmp	r5, r1
   1f41e:	d1f2      	bne.n	1f406 <TCPIP_STACK_NetByAddress+0x12>
   1f420:	e000      	b.n	1f424 <TCPIP_STACK_NetByAddress+0x30>
    return 0;
   1f422:	2300      	movs	r3, #0
}
   1f424:	4618      	mov	r0, r3
   1f426:	bc30      	pop	{r4, r5}
   1f428:	4770      	bx	lr
    return 0;
   1f42a:	2300      	movs	r3, #0
   1f42c:	e7fa      	b.n	1f424 <TCPIP_STACK_NetByAddress+0x30>
   1f42e:	bf00      	nop
   1f430:	2000ee74 	.word	0x2000ee74
   1f434:	2000eae4 	.word	0x2000eae4

Disassembly of section .text.TCPIP_STACK_AddressServiceEvent%640:

0001f438 <TCPIP_STACK_AddressServiceEvent>:
{
   1f438:	b508      	push	{r3, lr}
    if(evType == TCPIP_STACK_ADDRESS_SERVICE_EVENT_RUN_RESTORE)
   1f43a:	2a04      	cmp	r2, #4
   1f43c:	d015      	beq.n	1f46a <TCPIP_STACK_AddressServiceEvent+0x32>
    else if(evType == TCPIP_STACK_ADDRESS_SERVICE_EVENT_CONN_LOST)
   1f43e:	2a02      	cmp	r2, #2
   1f440:	d012      	beq.n	1f468 <TCPIP_STACK_AddressServiceEvent+0x30>
    else if(adSvcType == TCPIP_STACK_ADDRESS_SERVICE_DHCPS)
   1f442:	2903      	cmp	r1, #3
   1f444:	d010      	beq.n	1f468 <TCPIP_STACK_AddressServiceEvent+0x30>
    pNetIf->Flags.v &= ~TCPIP_STACK_ADDRESS_SERVICE_MASK;
   1f446:	f8b0 3042 	ldrh.w	r3, [r0, #66]	; 0x42
   1f44a:	f023 0307 	bic.w	r3, r3, #7
   1f44e:	f8a0 3042 	strh.w	r3, [r0, #66]	; 0x42
    pNetIf->Flags.bInConfig = config;
   1f452:	0a1b      	lsrs	r3, r3, #8
   1f454:	f043 0310 	orr.w	r3, r3, #16
   1f458:	f880 3043 	strb.w	r3, [r0, #67]	; 0x43
    pNetIf->dnsServer[0].Val = pNetIf->DefaultDNSServer[0].Val;
   1f45c:	6a43      	ldr	r3, [r0, #36]	; 0x24
   1f45e:	6103      	str	r3, [r0, #16]
    pNetIf->dnsServer[1].Val = pNetIf->DefaultDNSServer[1].Val;
   1f460:	6a83      	ldr	r3, [r0, #40]	; 0x28
   1f462:	6143      	str	r3, [r0, #20]
    TCPIP_STACK_AddressServiceDefaultSet(pNetIf);
   1f464:	f000 fcdc 	bl	1fe20 <TCPIP_STACK_AddressServiceDefaultSet>
}
   1f468:	bd08      	pop	{r3, pc}
        if(adSvcType == TCPIP_STACK_ADDRESS_SERVICE_DHCPC)
   1f46a:	2901      	cmp	r1, #1
   1f46c:	d1eb      	bne.n	1f446 <TCPIP_STACK_AddressServiceEvent+0xe>
            pNetIf->Flags.bIsDHCPEnabled = 1;
   1f46e:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   1f472:	f043 0301 	orr.w	r3, r3, #1
   1f476:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
            return;
   1f47a:	e7f5      	b.n	1f468 <TCPIP_STACK_AddressServiceEvent+0x30>

Disassembly of section .text._TCPIPStackModuleRxInsert%641:

0001f47c <_TCPIPStackModuleRxInsert>:
{
   1f47c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1f47e:	4604      	mov	r4, r0
   1f480:	460f      	mov	r7, r1
   1f482:	4615      	mov	r5, r2
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1f484:	2000      	movs	r0, #0
   1f486:	f004 f975 	bl	23774 <OSAL_CRIT_Enter>
   1f48a:	4606      	mov	r6, r0
    SINGLE_LIST* pQueue = TCPIP_MODULES_QUEUE_TBL + modId;
   1f48c:	eb04 0044 	add.w	r0, r4, r4, lsl #1
    TCPIP_Helper_SingleListTailAdd(pQueue, (SGL_LIST_NODE*)pRxPkt);
   1f490:	4639      	mov	r1, r7
   1f492:	4b09      	ldr	r3, [pc, #36]	; (1f4b8 <_TCPIPStackModuleRxInsert+0x3c>)
   1f494:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1f498:	f003 ffc8 	bl	2342c <TCPIP_Helper_SingleListTailAdd>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1f49c:	4631      	mov	r1, r6
   1f49e:	2000      	movs	r0, #0
   1f4a0:	f004 faa2 	bl	239e8 <OSAL_CRIT_Leave>
    if(signal)
   1f4a4:	b905      	cbnz	r5, 1f4a8 <_TCPIPStackModuleRxInsert+0x2c>
}
   1f4a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    _TCPIPSignalEntrySetNotify(_TCPIPModuleToSignalEntry(modId), signals, 0);
   1f4a8:	2200      	movs	r2, #0
   1f4aa:	2101      	movs	r1, #1
   1f4ac:	4803      	ldr	r0, [pc, #12]	; (1f4bc <_TCPIPStackModuleRxInsert+0x40>)
   1f4ae:	eb00 1004 	add.w	r0, r0, r4, lsl #4
   1f4b2:	f002 fdd3 	bl	2205c <_TCPIPSignalEntrySetNotify>
}
   1f4b6:	e7f6      	b.n	1f4a6 <_TCPIPStackModuleRxInsert+0x2a>
   1f4b8:	2000e654 	.word	0x2000e654
   1f4bc:	2000d9a4 	.word	0x2000d9a4

Disassembly of section .rodata%642:

0001f4c0 <.rodata%642>:
   1f4c0:	20504455 	.word	0x20504455
   1f4c4:	4c4c554e 	.word	0x4c4c554e
   1f4c8:	6e796420 	.word	0x6e796420
   1f4cc:	63696d61 	.word	0x63696d61
   1f4d0:	6c6c6120 	.word	0x6c6c6120
   1f4d4:	7461636f 	.word	0x7461636f
   1f4d8:	206e6f69 	.word	0x206e6f69
   1f4dc:	646e6168 	.word	0x646e6168
   1f4e0:	0000656c 	.word	0x0000656c
   1f4e4:	20504455 	.word	0x20504455
   1f4e8:	616e7944 	.word	0x616e7944
   1f4ec:	2063696d 	.word	0x2063696d
   1f4f0:	6f6c6c61 	.word	0x6f6c6c61
   1f4f4:	69746163 	.word	0x69746163
   1f4f8:	66206e6f 	.word	0x66206e6f
   1f4fc:	656c6961 	.word	0x656c6961
   1f500:	0064      	.short	0x0064
   1f502:	bf00      	nop

Disassembly of section .text.SYS_INT_SourceDisable%643:

0001f504 <SYS_INT_SourceDisable>:
{
    NVIC_INT_Restore(state);
}

bool SYS_INT_SourceDisable( INT_SOURCE source )
{
   1f504:	b538      	push	{r3, r4, r5, lr}
   1f506:	4604      	mov	r4, r0
    return NVIC_INT_Disable();
   1f508:	f004 fbc2 	bl	23c90 <NVIC_INT_Disable>
  if ((int32_t)(IRQn) >= 0)
   1f50c:	2c00      	cmp	r4, #0
   1f50e:	db16      	blt.n	1f53e <SYS_INT_SourceDisable+0x3a>
    return((uint32_t)(((NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
   1f510:	0963      	lsrs	r3, r4, #5
   1f512:	490c      	ldr	r1, [pc, #48]	; (1f544 <SYS_INT_SourceDisable+0x40>)
   1f514:	f851 5023 	ldr.w	r5, [r1, r3, lsl #2]
   1f518:	f004 041f 	and.w	r4, r4, #31
   1f51c:	40e5      	lsrs	r5, r4
    bool processorStatus;
    bool intSrcStatus;

    processorStatus = SYS_INT_Disable();

    intSrcStatus = NVIC_GetEnableIRQ(source);
   1f51e:	f005 0501 	and.w	r5, r5, #1
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1f522:	2201      	movs	r2, #1
   1f524:	fa02 f404 	lsl.w	r4, r2, r4
   1f528:	3320      	adds	r3, #32
   1f52a:	f841 4023 	str.w	r4, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   1f52e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1f532:	f3bf 8f6f 	isb	sy
    NVIC_INT_Restore(state);
   1f536:	f004 fbb4 	bl	23ca2 <NVIC_INT_Restore>

    SYS_INT_Restore( processorStatus );

    /* return the source status */
    return intSrcStatus;
}
   1f53a:	4628      	mov	r0, r5
   1f53c:	bd38      	pop	{r3, r4, r5, pc}
    intSrcStatus = NVIC_GetEnableIRQ(source);
   1f53e:	2500      	movs	r5, #0
   1f540:	e7f9      	b.n	1f536 <SYS_INT_SourceDisable+0x32>
   1f542:	bf00      	nop
   1f544:	e000e100 	.word	0xe000e100

Disassembly of section .rodata%644:

0001f548 <.rodata%644>:
   1f548:	736c6166 	.word	0x736c6166
   1f54c:	00000065 	.word	0x00000065
   1f550:	732f2e2e 	.word	0x732f2e2e
   1f554:	672f6372 	.word	0x672f6372
   1f558:	6d5f7866 	.word	0x6d5f7866
   1f55c:	2f6f6e6f 	.word	0x2f6f6e6f
   1f560:	5f786667 	.word	0x5f786667
   1f564:	6f6e6f6d 	.word	0x6f6e6f6d
   1f568:	7865745f 	.word	0x7865745f
   1f56c:	00632e74 	.word	0x00632e74
   1f570:	20727473 	.word	0x20727473
   1f574:	4e203d21 	.word	0x4e203d21
   1f578:	004c4c55 	.word	0x004c4c55
   1f57c:	746e6f66 	.word	0x746e6f66
   1f580:	203d2120 	.word	0x203d2120
   1f584:	4c4c554e 	.word	0x4c4c554e
   1f588:	00          	.byte	0x00
   1f589:	00          	.byte	0x00
   1f58a:	bf00      	nop

Disassembly of section .text.gfx_mono_ssd1306_put_page%645:

0001f58c <gfx_mono_ssd1306_put_page>:
        gfx_coord_t column, gfx_coord_t width) {
   1f58c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1f58e:	4604      	mov	r4, r0
   1f590:	460e      	mov	r6, r1
   1f592:	4617      	mov	r7, r2
   1f594:	461d      	mov	r5, r3
    gfx_mono_framebuffer_put_page(data, page, column, width);
   1f596:	f001 fc4f 	bl	20e38 <gfx_mono_framebuffer_put_page>
        address &= 0x0F;
   1f59a:	f006 000f 	and.w	r0, r6, #15
        ssd1306_write_command(SSD1306_CMD_SET_PAGE_START_ADDRESS(address));
   1f59e:	f040 00b0 	orr.w	r0, r0, #176	; 0xb0
   1f5a2:	f000 fb5f 	bl	1fc64 <ssd1306_write_command>
        ssd1306_write_command(SSD1306_CMD_COL_ADD_SET_MSB(address >> 4));
   1f5a6:	f3c7 1002 	ubfx	r0, r7, #4, #3
   1f5aa:	f040 0010 	orr.w	r0, r0, #16
   1f5ae:	f000 fb59 	bl	1fc64 <ssd1306_write_command>
        ssd1306_write_command(SSD1306_CMD_COL_ADD_SET_LSB(address & 0x0F));
   1f5b2:	f007 000f 	and.w	r0, r7, #15
   1f5b6:	f000 fb55 	bl	1fc64 <ssd1306_write_command>
   1f5ba:	3d01      	subs	r5, #1
   1f5bc:	b2ed      	uxtb	r5, r5
   1f5be:	3501      	adds	r5, #1
   1f5c0:	4425      	add	r5, r4
        ssd1306_write_data(*data++);
   1f5c2:	f814 0b01 	ldrb.w	r0, [r4], #1
   1f5c6:	f000 fb6d 	bl	1fca4 <ssd1306_write_data>
    } while (--width);
   1f5ca:	42ac      	cmp	r4, r5
   1f5cc:	d1f9      	bne.n	1f5c2 <gfx_mono_ssd1306_put_page+0x36>
}
   1f5ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.gfx_mono_ssd1306_put_framebuffer%646:

0001f5d0 <gfx_mono_ssd1306_put_framebuffer>:
void gfx_mono_ssd1306_put_framebuffer(void) {
   1f5d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
   1f5d4:	4d0e      	ldr	r5, [pc, #56]	; (1f610 <gfx_mono_ssd1306_put_framebuffer+0x40>)
void gfx_mono_ssd1306_put_framebuffer(void) {
   1f5d6:	2400      	movs	r4, #0
        ssd1306_write_command(SSD1306_CMD_COL_ADD_SET_MSB(address >> 4));
   1f5d8:	f04f 0910 	mov.w	r9, #16
        ssd1306_write_command(SSD1306_CMD_COL_ADD_SET_LSB(address & 0x0F));
   1f5dc:	4627      	mov	r7, r4
        gfx_mono_ssd1306_put_page(framebuffer
   1f5de:	f04f 0880 	mov.w	r8, #128	; 0x80
   1f5e2:	b2e6      	uxtb	r6, r4
        ssd1306_write_command(SSD1306_CMD_SET_PAGE_START_ADDRESS(address));
   1f5e4:	f046 00b0 	orr.w	r0, r6, #176	; 0xb0
   1f5e8:	f000 fb3c 	bl	1fc64 <ssd1306_write_command>
        ssd1306_write_command(SSD1306_CMD_COL_ADD_SET_MSB(address >> 4));
   1f5ec:	4648      	mov	r0, r9
   1f5ee:	f000 fb39 	bl	1fc64 <ssd1306_write_command>
        ssd1306_write_command(SSD1306_CMD_COL_ADD_SET_LSB(address & 0x0F));
   1f5f2:	4638      	mov	r0, r7
   1f5f4:	f000 fb36 	bl	1fc64 <ssd1306_write_command>
   1f5f8:	4643      	mov	r3, r8
   1f5fa:	463a      	mov	r2, r7
   1f5fc:	4631      	mov	r1, r6
   1f5fe:	4628      	mov	r0, r5
   1f600:	f7ff ffc4 	bl	1f58c <gfx_mono_ssd1306_put_page>
   1f604:	3401      	adds	r4, #1
   1f606:	3580      	adds	r5, #128	; 0x80
    for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
   1f608:	2c04      	cmp	r4, #4
   1f60a:	d1ea      	bne.n	1f5e2 <gfx_mono_ssd1306_put_framebuffer+0x12>
}
   1f60c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1f610:	2000dc14 	.word	0x2000dc14

Disassembly of section .text.gfx_mono_ssd1306_put_byte%647:

0001f614 <gfx_mono_ssd1306_put_byte>:
        uint8_t data, bool force) {
   1f614:	b570      	push	{r4, r5, r6, lr}
   1f616:	4604      	mov	r4, r0
   1f618:	460d      	mov	r5, r1
   1f61a:	4616      	mov	r6, r2
    if (!force && data == gfx_mono_framebuffer_get_byte(page, column)) {
   1f61c:	b91b      	cbnz	r3, 1f626 <gfx_mono_ssd1306_put_byte+0x12>
   1f61e:	f004 fc17 	bl	23e50 <gfx_mono_framebuffer_get_byte>
   1f622:	42b0      	cmp	r0, r6
   1f624:	d017      	beq.n	1f656 <gfx_mono_ssd1306_put_byte+0x42>
    gfx_mono_framebuffer_put_byte(page, column, data);
   1f626:	4632      	mov	r2, r6
   1f628:	4629      	mov	r1, r5
   1f62a:	4620      	mov	r0, r4
   1f62c:	f003 f89e 	bl	2276c <gfx_mono_framebuffer_put_byte>
        address &= 0x0F;
   1f630:	f004 000f 	and.w	r0, r4, #15
        ssd1306_write_command(SSD1306_CMD_SET_PAGE_START_ADDRESS(address));
   1f634:	f040 00b0 	orr.w	r0, r0, #176	; 0xb0
   1f638:	f000 fb14 	bl	1fc64 <ssd1306_write_command>
        ssd1306_write_command(SSD1306_CMD_COL_ADD_SET_MSB(address >> 4));
   1f63c:	f3c5 1002 	ubfx	r0, r5, #4, #3
   1f640:	f040 0010 	orr.w	r0, r0, #16
   1f644:	f000 fb0e 	bl	1fc64 <ssd1306_write_command>
        ssd1306_write_command(SSD1306_CMD_COL_ADD_SET_LSB(address & 0x0F));
   1f648:	f005 000f 	and.w	r0, r5, #15
   1f64c:	f000 fb0a 	bl	1fc64 <ssd1306_write_command>
    ssd1306_write_data(data);
   1f650:	4630      	mov	r0, r6
   1f652:	f000 fb27 	bl	1fca4 <ssd1306_write_data>
}
   1f656:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.sprintf%648:

0001f658 <siprintf>:
   1f658:	b40e      	push	{r1, r2, r3}
   1f65a:	b510      	push	{r4, lr}
   1f65c:	b09b      	sub	sp, #108	; 0x6c
   1f65e:	ab1d      	add	r3, sp, #116	; 0x74
   1f660:	9001      	str	r0, [sp, #4]
   1f662:	9005      	str	r0, [sp, #20]
   1f664:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   1f668:	480a      	ldr	r0, [pc, #40]	; (1f694 <siprintf+0x3c>)
   1f66a:	9106      	str	r1, [sp, #24]
   1f66c:	9103      	str	r1, [sp, #12]
   1f66e:	490a      	ldr	r1, [pc, #40]	; (1f698 <siprintf+0x40>)
   1f670:	f853 2b04 	ldr.w	r2, [r3], #4
   1f674:	9104      	str	r1, [sp, #16]
   1f676:	2400      	movs	r4, #0
   1f678:	a901      	add	r1, sp, #4
   1f67a:	6800      	ldr	r0, [r0, #0]
   1f67c:	9300      	str	r3, [sp, #0]
   1f67e:	9419      	str	r4, [sp, #100]	; 0x64
   1f680:	f7f1 fc22 	bl	10ec8 <_svfiprintf_r>
   1f684:	9b01      	ldr	r3, [sp, #4]
   1f686:	701c      	strb	r4, [r3, #0]
   1f688:	b01b      	add	sp, #108	; 0x6c
   1f68a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1f68e:	b003      	add	sp, #12
   1f690:	4770      	bx	lr
   1f692:	bf00      	nop
   1f694:	2000ef60 	.word	0x2000ef60
   1f698:	ffff0208 	.word	0xffff0208

Disassembly of section .text._DRV_GMAC_LinkStateNegComplete%649:

0001f69c <_DRV_GMAC_LinkStateNegComplete>:
{
   1f69c:	b538      	push	{r3, r4, r5, lr}
   1f69e:	4604      	mov	r4, r0
	pPhyBase =  pMACDrv->sGmacData.gmacConfig.pPhyBase;
   1f6a0:	f8d0 50d8 	ldr.w	r5, [r0, #216]	; 0xd8
	phyStat = pPhyBase->DRV_ETHPHY_ClientStatus( pMACDrv->sGmacData.hPhyClient );
   1f6a4:	69eb      	ldr	r3, [r5, #28]
   1f6a6:	6900      	ldr	r0, [r0, #16]
   1f6a8:	4798      	blx	r3
	if(phyStat == DRV_ETHPHY_CLIENT_STATUS_BUSY)
   1f6aa:	2801      	cmp	r0, #1
   1f6ac:	d00e      	beq.n	1f6cc <_DRV_GMAC_LinkStateNegComplete+0x30>
	phyRes = pPhyBase->DRV_ETHPHY_ClientOperationResult(pMACDrv->sGmacData.hPhyClient);
   1f6ae:	6a2b      	ldr	r3, [r5, #32]
   1f6b0:	6920      	ldr	r0, [r4, #16]
   1f6b2:	4798      	blx	r3
	if(phyRes != DRV_ETHPHY_RES_OK)
   1f6b4:	b958      	cbnz	r0, 1f6ce <_DRV_GMAC_LinkStateNegComplete+0x32>
	phyRes = pPhyBase->DRV_ETHPHY_NegotiationResultGet(pMACDrv->sGmacData.hPhyClient, DRV_ETHPHY_INF_IDX_ALL_EXTERNAL, &pMACDrv->sGmacData._negResult);
   1f6b6:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   1f6b8:	f104 0240 	add.w	r2, r4, #64	; 0x40
   1f6bc:	2100      	movs	r1, #0
   1f6be:	6920      	ldr	r0, [r4, #16]
   1f6c0:	4798      	blx	r3
	if(phyRes < 0)
   1f6c2:	2800      	cmp	r0, #0
   1f6c4:	db07      	blt.n	1f6d6 <_DRV_GMAC_LinkStateNegComplete+0x3a>
		pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_NEG_RESULT;
   1f6c6:	2304      	movs	r3, #4
   1f6c8:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
}
   1f6cc:	bd38      	pop	{r3, r4, r5, pc}
		_DRV_GMAC_LinkStateDown(pMACDrv);
   1f6ce:	4620      	mov	r0, r4
   1f6d0:	f003 fbb6 	bl	22e40 <_DRV_GMAC_LinkStateDown>
		return;
   1f6d4:	e7fa      	b.n	1f6cc <_DRV_GMAC_LinkStateNegComplete+0x30>
		_DRV_GMAC_LinkStateDown(pMACDrv);
   1f6d6:	4620      	mov	r0, r4
   1f6d8:	f003 fbb2 	bl	22e40 <_DRV_GMAC_LinkStateDown>
   1f6dc:	e7f6      	b.n	1f6cc <_DRV_GMAC_LinkStateNegComplete+0x30>

Disassembly of section .text._TcpSocketSetSourceInterface%650:

0001f6de <_TcpSocketSetSourceInterface>:
    if(pSkt->flags.srcSet == 0 || pSkt->pSktNet == 0)
   1f6de:	f890 306d 	ldrb.w	r3, [r0, #109]	; 0x6d
   1f6e2:	f013 0310 	ands.w	r3, r3, #16
   1f6e6:	d003      	beq.n	1f6f0 <_TcpSocketSetSourceInterface+0x12>
   1f6e8:	6c02      	ldr	r2, [r0, #64]	; 0x40
   1f6ea:	b10a      	cbz	r2, 1f6f0 <_TcpSocketSetSourceInterface+0x12>
    return true;
   1f6ec:	2001      	movs	r0, #1
}
   1f6ee:	4770      	bx	lr
{
   1f6f0:	b510      	push	{r4, lr}
   1f6f2:	4604      	mov	r4, r0
        pSkt->pSktNet = (TCPIP_NET_IF*)TCPIP_IPV4_SelectSourceInterface(pSkt->pSktNet, &pSkt->destAddress, &pSkt->srcAddress, pSkt->flags.srcSet != 0);
   1f6f4:	3300      	adds	r3, #0
   1f6f6:	bf18      	it	ne
   1f6f8:	2301      	movne	r3, #1
   1f6fa:	f100 023c 	add.w	r2, r0, #60	; 0x3c
   1f6fe:	f100 0138 	add.w	r1, r0, #56	; 0x38
   1f702:	6c00      	ldr	r0, [r0, #64]	; 0x40
   1f704:	f7ff f974 	bl	1e9f0 <TCPIP_IPV4_SelectSourceInterface>
   1f708:	6420      	str	r0, [r4, #64]	; 0x40
        if(pSkt->pSktNet == 0)
   1f70a:	b138      	cbz	r0, 1f71c <_TcpSocketSetSourceInterface+0x3e>
        pSkt->flags.srcSet = 1;
   1f70c:	f894 306d 	ldrb.w	r3, [r4, #109]	; 0x6d
   1f710:	f043 0310 	orr.w	r3, r3, #16
   1f714:	f884 306d 	strb.w	r3, [r4, #109]	; 0x6d
    return true;
   1f718:	2001      	movs	r0, #1
}
   1f71a:	bd10      	pop	{r4, pc}
            return false;
   1f71c:	2000      	movs	r0, #0
   1f71e:	e7fc      	b.n	1f71a <_TcpSocketSetSourceInterface+0x3c>

Disassembly of section .text._UDPSetNewRxPacket%651:

0001f720 <_UDPSetNewRxPacket>:
{
   1f720:	b538      	push	{r3, r4, r5, lr}
   1f722:	4604      	mov	r4, r0
   1f724:	460d      	mov	r5, r1
    if(pSkt->pCurrRxPkt != 0)
   1f726:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   1f728:	b118      	cbz	r0, 1f732 <_UDPSetNewRxPacket+0x12>
    TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
   1f72a:	2209      	movs	r2, #9
   1f72c:	2102      	movs	r1, #2
   1f72e:	f000 f9b9 	bl	1faa4 <_TCPIP_PKT_PacketAcknowledge>
    if((pSkt->pCurrRxPkt = pRxPkt) != 0)
   1f732:	62e5      	str	r5, [r4, #44]	; 0x2c
   1f734:	b17d      	cbz	r5, 1f756 <_UDPSetNewRxPacket+0x36>
        UDP_HEADER* pUDPHdr = (UDP_HEADER*)pRxPkt->pTransportLayer;
   1f736:	69ea      	ldr	r2, [r5, #28]
        pSkt->pCurrRxSeg = pRxPkt->pDSeg;
   1f738:	692b      	ldr	r3, [r5, #16]
   1f73a:	6323      	str	r3, [r4, #48]	; 0x30
        pSkt->rxSegLen = pRxPkt->pDSeg->segLen - sizeof(UDP_HEADER);
   1f73c:	899b      	ldrh	r3, [r3, #12]
   1f73e:	3b08      	subs	r3, #8
   1f740:	86a3      	strh	r3, [r4, #52]	; 0x34
        pSkt->rxTotLen = pUDPHdr->Length;  
   1f742:	8893      	ldrh	r3, [r2, #4]
   1f744:	86e3      	strh	r3, [r4, #54]	; 0x36
        pSkt->rxCurr = pRxPkt->pTransportLayer + sizeof(UDP_HEADER);
   1f746:	69eb      	ldr	r3, [r5, #28]
   1f748:	3308      	adds	r3, #8
   1f74a:	63a3      	str	r3, [r4, #56]	; 0x38
    _UDPsetPacketInfo(pSkt, pRxPkt);
   1f74c:	4629      	mov	r1, r5
   1f74e:	4620      	mov	r0, r4
   1f750:	f7fa ff30 	bl	1a5b4 <_UDPsetPacketInfo>
}
   1f754:	bd38      	pop	{r3, r4, r5, pc}
        pSkt->pCurrRxSeg = 0;
   1f756:	2300      	movs	r3, #0
   1f758:	6323      	str	r3, [r4, #48]	; 0x30
        pSkt->rxSegLen = 0;
   1f75a:	86a3      	strh	r3, [r4, #52]	; 0x34
        pSkt->rxTotLen = 0;
   1f75c:	86e3      	strh	r3, [r4, #54]	; 0x36
        pSkt->rxCurr = 0;
   1f75e:	63a3      	str	r3, [r4, #56]	; 0x38
   1f760:	e7f4      	b.n	1f74c <_UDPSetNewRxPacket+0x2c>

Disassembly of section .text.TCPIP_UDP_SourceIPAddressSet%652:

0001f762 <TCPIP_UDP_SourceIPAddressSet>:
{
   1f762:	b538      	push	{r3, r4, r5, lr}
   1f764:	460c      	mov	r4, r1
   1f766:	4615      	mov	r5, r2
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1f768:	f002 fcf0 	bl	2214c <_UDPSocketDcpt>
    return pSkt ? _UDPSetSourceAddress(pSkt, addType, localAddress) : false;
   1f76c:	b1c0      	cbz	r0, 1f7a0 <TCPIP_UDP_SourceIPAddressSet+0x3e>
   1f76e:	4603      	mov	r3, r0
    if(localAddress == 0)
   1f770:	b1a5      	cbz	r5, 1f79c <TCPIP_UDP_SourceIPAddressSet+0x3a>
    while(pSkt->addType == addType)
   1f772:	8f82      	ldrh	r2, [r0, #60]	; 0x3c
   1f774:	42a2      	cmp	r2, r4
   1f776:	d001      	beq.n	1f77c <TCPIP_UDP_SourceIPAddressSet+0x1a>
    return false;
   1f778:	2000      	movs	r0, #0
   1f77a:	e012      	b.n	1f7a2 <TCPIP_UDP_SourceIPAddressSet+0x40>
        if (addType == IP_ADDRESS_TYPE_IPV4)
   1f77c:	2c01      	cmp	r4, #1
   1f77e:	d001      	beq.n	1f784 <TCPIP_UDP_SourceIPAddressSet+0x22>
    return false;
   1f780:	2000      	movs	r0, #0
   1f782:	e00e      	b.n	1f7a2 <TCPIP_UDP_SourceIPAddressSet+0x40>
            pSkt->srcAddress.Val = localAddress->v4Add.Val;
   1f784:	682a      	ldr	r2, [r5, #0]
   1f786:	619a      	str	r2, [r3, #24]
            pSkt->flags.srcSet = 1;
   1f788:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
            pSkt->flags.srcSolved = 0;
   1f78c:	f042 0260 	orr.w	r2, r2, #96	; 0x60
   1f790:	f36f 12c7 	bfc	r2, #7, #1
   1f794:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
            return true;
   1f798:	2001      	movs	r0, #1
   1f79a:	e002      	b.n	1f7a2 <TCPIP_UDP_SourceIPAddressSet+0x40>
        return false;
   1f79c:	2000      	movs	r0, #0
   1f79e:	e000      	b.n	1f7a2 <TCPIP_UDP_SourceIPAddressSet+0x40>
    return pSkt ? _UDPSetSourceAddress(pSkt, addType, localAddress) : false;
   1f7a0:	2000      	movs	r0, #0
}
   1f7a2:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text%653:

0001f7a4 <__do_global_dtors_aux>:
   1f7a4:	b510      	push	{r4, lr}
   1f7a6:	4c05      	ldr	r4, [pc, #20]	; (1f7bc <__do_global_dtors_aux+0x18>)
   1f7a8:	7823      	ldrb	r3, [r4, #0]
   1f7aa:	b933      	cbnz	r3, 1f7ba <__do_global_dtors_aux+0x16>
   1f7ac:	4b04      	ldr	r3, [pc, #16]	; (1f7c0 <__do_global_dtors_aux+0x1c>)
   1f7ae:	b113      	cbz	r3, 1f7b6 <__do_global_dtors_aux+0x12>
   1f7b0:	4804      	ldr	r0, [pc, #16]	; (1f7c4 <__do_global_dtors_aux+0x20>)
   1f7b2:	f3af 8000 	nop.w
   1f7b6:	2301      	movs	r3, #1
   1f7b8:	7023      	strb	r3, [r4, #0]
   1f7ba:	bd10      	pop	{r4, pc}
   1f7bc:	2000ebc4 	.word	0x2000ebc4
	...

0001f7c8 <frame_dummy>:
   1f7c8:	b508      	push	{r3, lr}
   1f7ca:	4b03      	ldr	r3, [pc, #12]	; (1f7d8 <frame_dummy+0x10>)
   1f7cc:	b11b      	cbz	r3, 1f7d6 <frame_dummy+0xe>
   1f7ce:	4903      	ldr	r1, [pc, #12]	; (1f7dc <frame_dummy+0x14>)
   1f7d0:	4803      	ldr	r0, [pc, #12]	; (1f7e0 <frame_dummy+0x18>)
   1f7d2:	f3af 8000 	nop.w
   1f7d6:	bd08      	pop	{r3, pc}
   1f7d8:	00000000 	.word	0x00000000
   1f7dc:	2000ebc8 	.word	0x2000ebc8
   1f7e0:	00000000 	.word	0x00000000

Disassembly of section .text.DRV_ETHPHY_Reset%654:

0001f7e4 <DRV_ETHPHY_Reset>:
    if(hClientObj != 0)
   1f7e4:	4603      	mov	r3, r0
   1f7e6:	b190      	cbz	r0, 1f80e <DRV_ETHPHY_Reset+0x2a>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1f7e8:	68c0      	ldr	r0, [r0, #12]
   1f7ea:	4a0d      	ldr	r2, [pc, #52]	; (1f820 <DRV_ETHPHY_Reset+0x3c>)
   1f7ec:	4290      	cmp	r0, r2
   1f7ee:	d111      	bne.n	1f814 <DRV_ETHPHY_Reset+0x30>
            if(hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_READY)
   1f7f0:	f993 2008 	ldrsb.w	r2, [r3, #8]
   1f7f4:	2a02      	cmp	r2, #2
   1f7f6:	d110      	bne.n	1f81a <DRV_ETHPHY_Reset+0x36>
            hClientObj->operParam = waitComplete;
   1f7f8:	6319      	str	r1, [r3, #48]	; 0x30
    hClientObj->operType = opType;
   1f7fa:	2206      	movs	r2, #6
   1f7fc:	839a      	strh	r2, [r3, #28]
    hClientObj->operPhase = hClientObj->operSubPhase = 0; 
   1f7fe:	2200      	movs	r2, #0
   1f800:	841a      	strh	r2, [r3, #32]
   1f802:	83da      	strh	r2, [r3, #30]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_BUSY; 
   1f804:	2001      	movs	r0, #1
   1f806:	7218      	strb	r0, [r3, #8]
    hClientObj->operRes = res;
   1f808:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c
   1f80c:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1f80e:	f06f 000a 	mvn.w	r0, #10
   1f812:	4770      	bx	lr
   1f814:	f06f 000a 	mvn.w	r0, #10
   1f818:	4770      	bx	lr
                return DRV_ETHPHY_RES_NOT_READY_ERR;
   1f81a:	f06f 0009 	mvn.w	r0, #9
}
   1f81e:	4770      	bx	lr
   1f820:	2000e7e8 	.word	0x2000e7e8

Disassembly of section .text.DRV_ETHPHY_NegotiationIsComplete%655:

0001f824 <DRV_ETHPHY_NegotiationIsComplete>:
    if(hClientObj != 0)
   1f824:	4603      	mov	r3, r0
   1f826:	b190      	cbz	r0, 1f84e <DRV_ETHPHY_NegotiationIsComplete+0x2a>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1f828:	68c0      	ldr	r0, [r0, #12]
   1f82a:	490d      	ldr	r1, [pc, #52]	; (1f860 <DRV_ETHPHY_NegotiationIsComplete+0x3c>)
   1f82c:	4288      	cmp	r0, r1
   1f82e:	d111      	bne.n	1f854 <DRV_ETHPHY_NegotiationIsComplete+0x30>
            if(hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_READY)
   1f830:	f993 1008 	ldrsb.w	r1, [r3, #8]
   1f834:	2902      	cmp	r1, #2
   1f836:	d110      	bne.n	1f85a <DRV_ETHPHY_NegotiationIsComplete+0x36>
            hClientObj->operParam = waitComplete;
   1f838:	631a      	str	r2, [r3, #48]	; 0x30
    hClientObj->operType = opType;
   1f83a:	2203      	movs	r2, #3
   1f83c:	839a      	strh	r2, [r3, #28]
    hClientObj->operPhase = hClientObj->operSubPhase = 0; 
   1f83e:	2200      	movs	r2, #0
   1f840:	841a      	strh	r2, [r3, #32]
   1f842:	83da      	strh	r2, [r3, #30]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_BUSY; 
   1f844:	2001      	movs	r0, #1
   1f846:	7218      	strb	r0, [r3, #8]
    hClientObj->operRes = res;
   1f848:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c
   1f84c:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1f84e:	f06f 000a 	mvn.w	r0, #10
   1f852:	4770      	bx	lr
   1f854:	f06f 000a 	mvn.w	r0, #10
   1f858:	4770      	bx	lr
                return DRV_ETHPHY_RES_NOT_READY_ERR;
   1f85a:	f06f 0009 	mvn.w	r0, #9
}
   1f85e:	4770      	bx	lr
   1f860:	2000e7e8 	.word	0x2000e7e8

Disassembly of section .text.DRV_ETHPHY_RestartNegotiation%656:

0001f864 <DRV_ETHPHY_RestartNegotiation>:
    if(hClientObj != 0)
   1f864:	4603      	mov	r3, r0
   1f866:	b188      	cbz	r0, 1f88c <DRV_ETHPHY_RestartNegotiation+0x28>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1f868:	68c1      	ldr	r1, [r0, #12]
   1f86a:	4a0d      	ldr	r2, [pc, #52]	; (1f8a0 <DRV_ETHPHY_RestartNegotiation+0x3c>)
   1f86c:	4291      	cmp	r1, r2
   1f86e:	d110      	bne.n	1f892 <DRV_ETHPHY_RestartNegotiation+0x2e>
            if(hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_READY)
   1f870:	f990 2008 	ldrsb.w	r2, [r0, #8]
   1f874:	2a02      	cmp	r2, #2
   1f876:	d10f      	bne.n	1f898 <DRV_ETHPHY_RestartNegotiation+0x34>
    hClientObj->operType = opType;
   1f878:	2205      	movs	r2, #5
   1f87a:	8382      	strh	r2, [r0, #28]
    hClientObj->operPhase = hClientObj->operSubPhase = 0; 
   1f87c:	2200      	movs	r2, #0
   1f87e:	8402      	strh	r2, [r0, #32]
   1f880:	83c2      	strh	r2, [r0, #30]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_BUSY; 
   1f882:	2001      	movs	r0, #1
   1f884:	7218      	strb	r0, [r3, #8]
    hClientObj->operRes = res;
   1f886:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c
   1f88a:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1f88c:	f06f 000a 	mvn.w	r0, #10
   1f890:	4770      	bx	lr
   1f892:	f06f 000a 	mvn.w	r0, #10
   1f896:	4770      	bx	lr
                return DRV_ETHPHY_RES_NOT_READY_ERR;
   1f898:	f06f 0009 	mvn.w	r0, #9
}
   1f89c:	4770      	bx	lr
   1f89e:	bf00      	nop
   1f8a0:	2000e7e8 	.word	0x2000e7e8

Disassembly of section .text._DRV_ETHPHY_ResetPhaseWrite%657:

0001f8a4 <_DRV_ETHPHY_ResetPhaseWrite>:
{
   1f8a4:	b538      	push	{r3, r4, r5, lr}
    if( hClientObj->operParam == 0)
   1f8a6:	6b03      	ldr	r3, [r0, #48]	; 0x30
   1f8a8:	b91b      	cbnz	r3, 1f8b2 <_DRV_ETHPHY_ResetPhaseWrite+0xe>
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OK);
   1f8aa:	2100      	movs	r1, #0
   1f8ac:	f002 fabe 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
}
   1f8b0:	bd38      	pop	{r3, r4, r5, pc}
   1f8b2:	4604      	mov	r4, r0
        hClientObj->operTStamp = SYS_TMR_TickCountGet() + ((DRV_ETHPHY_RESET_CLR_TMO * SYS_TMR_TickCounterFrequencyGet()) + 999) / 1000;
   1f8b4:	f002 fcc2 	bl	2223c <SYS_TMR_TickCountGet>
   1f8b8:	4605      	mov	r5, r0
   1f8ba:	f002 fce7 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
   1f8be:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   1f8c2:	fb03 f000 	mul.w	r0, r3, r0
   1f8c6:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
   1f8ca:	4b05      	ldr	r3, [pc, #20]	; (1f8e0 <_DRV_ETHPHY_ResetPhaseWrite+0x3c>)
   1f8cc:	fba3 3000 	umull	r3, r0, r3, r0
   1f8d0:	eb05 1090 	add.w	r0, r5, r0, lsr #6
   1f8d4:	62a0      	str	r0, [r4, #40]	; 0x28
    hClientObj->operPhase = operPhase;
   1f8d6:	2302      	movs	r3, #2
   1f8d8:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1f8da:	2300      	movs	r3, #0
   1f8dc:	8423      	strh	r3, [r4, #32]
}
   1f8de:	e7e7      	b.n	1f8b0 <_DRV_ETHPHY_ResetPhaseWrite+0xc>
   1f8e0:	10624dd3 	.word	0x10624dd3

Disassembly of section .rodata.DRV_MIIM_OBJECT_BASE_Default%658:

0001f8e4 <DRV_MIIM_OBJECT_BASE_Default>:
   1f8e4:	0001b7e1 0001355f 000204b3 00021ecd     ...._5..........
   1f8f4:	0001303d 0001b769 000197bd 00023685     =0..i........6..
   1f904:	0002390d 0001ff53 00021669 00023391     .9..S...i....3..
   1f914:	000233ab 000233c5 0001a0ad 0001db71     .3...3......q...

Disassembly of section .text._TCP_PortIsAvailable%659:

0001f924 <_TCP_PortIsAvailable>:
{
   1f924:	b410      	push	{r4}
    for(sktIx = 0; sktIx < TcpSockets; sktIx++)
   1f926:	4b0d      	ldr	r3, [pc, #52]	; (1f95c <_TCP_PortIsAvailable+0x38>)
   1f928:	681c      	ldr	r4, [r3, #0]
   1f92a:	b1ac      	cbz	r4, 1f958 <_TCP_PortIsAvailable+0x34>
        pSkt = TCBStubs[sktIx];
   1f92c:	4b0c      	ldr	r3, [pc, #48]	; (1f960 <_TCP_PortIsAvailable+0x3c>)
   1f92e:	6819      	ldr	r1, [r3, #0]
   1f930:	3904      	subs	r1, #4
    for(sktIx = 0; sktIx < TcpSockets; sktIx++)
   1f932:	2300      	movs	r3, #0
   1f934:	e002      	b.n	1f93c <_TCP_PortIsAvailable+0x18>
   1f936:	3301      	adds	r3, #1
   1f938:	42a3      	cmp	r3, r4
   1f93a:	d009      	beq.n	1f950 <_TCP_PortIsAvailable+0x2c>
        pSkt = TCBStubs[sktIx];
   1f93c:	f851 2f04 	ldr.w	r2, [r1, #4]!
        if(pSkt && pSkt->localPort == port)
   1f940:	2a00      	cmp	r2, #0
   1f942:	d0f8      	beq.n	1f936 <_TCP_PortIsAvailable+0x12>
   1f944:	f8b2 205a 	ldrh.w	r2, [r2, #90]	; 0x5a
   1f948:	4282      	cmp	r2, r0
   1f94a:	d1f4      	bne.n	1f936 <_TCP_PortIsAvailable+0x12>
            return false;
   1f94c:	2000      	movs	r0, #0
   1f94e:	e000      	b.n	1f952 <_TCP_PortIsAvailable+0x2e>
    return true;
   1f950:	2001      	movs	r0, #1
}
   1f952:	f85d 4b04 	ldr.w	r4, [sp], #4
   1f956:	4770      	bx	lr
    return true;
   1f958:	2001      	movs	r0, #1
   1f95a:	e7fa      	b.n	1f952 <_TCP_PortIsAvailable+0x2e>
   1f95c:	2000edc4 	.word	0x2000edc4
   1f960:	2000edc0 	.word	0x2000edc0

Disassembly of section .text._DHCPSetBoundState%660:

0001f964 <_DHCPSetBoundState>:
{
   1f964:	b510      	push	{r4, lr}
   1f966:	b094      	sub	sp, #80	; 0x50
   1f968:	4604      	mov	r4, r0
    TCPIP_UDP_SocketInfoGet(dhcpClientSocket , &sktInfo);
   1f96a:	4669      	mov	r1, sp
   1f96c:	4b0c      	ldr	r3, [pc, #48]	; (1f9a0 <_DHCPSetBoundState+0x3c>)
   1f96e:	f9b3 0000 	ldrsh.w	r0, [r3]
   1f972:	f7fd fa6b 	bl	1ce4c <TCPIP_UDP_SocketInfoGet>
    pClient->serverAddress.Val = sktInfo.sourceIPaddress.v4Add.Val;
   1f976:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1f978:	62a3      	str	r3, [r4, #40]	; 0x28
    pClient->smState = newState;
   1f97a:	2308      	movs	r3, #8
   1f97c:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    pClient->flags.bIsBound = true;	
   1f980:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
    pClient->flags.bRetry = false; 
   1f984:	f043 0332 	orr.w	r3, r3, #50	; 0x32
   1f988:	f36f 13c7 	bfc	r3, #7, #1
   1f98c:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    if(pClient->dhcpFilterHandle != 0)
   1f990:	6ca0      	ldr	r0, [r4, #72]	; 0x48
   1f992:	b110      	cbz	r0, 1f99a <_DHCPSetBoundState+0x36>
        Ipv4FilterSetActive(pClient->dhcpFilterHandle, active);
   1f994:	2100      	movs	r1, #0
   1f996:	f7fd fb83 	bl	1d0a0 <Ipv4FilterSetActive>
}
   1f99a:	b014      	add	sp, #80	; 0x50
   1f99c:	bd10      	pop	{r4, pc}
   1f99e:	bf00      	nop
   1f9a0:	2000ef7e 	.word	0x2000ef7e

Disassembly of section .text.TCPIP_DHCP_Deinitialize%661:

0001f9a4 <TCPIP_DHCP_Deinitialize>:
    if(dhcpInitCount > 0)
   1f9a4:	4b0d      	ldr	r3, [pc, #52]	; (1f9dc <TCPIP_DHCP_Deinitialize+0x38>)
   1f9a6:	681b      	ldr	r3, [r3, #0]
   1f9a8:	2b00      	cmp	r3, #0
   1f9aa:	dc00      	bgt.n	1f9ae <TCPIP_DHCP_Deinitialize+0xa>
   1f9ac:	4770      	bx	lr
{
   1f9ae:	b510      	push	{r4, lr}
   1f9b0:	4604      	mov	r4, r0
        _DHCPClientClose(stackCtrl->pNetIf, true, true);
   1f9b2:	2201      	movs	r2, #1
   1f9b4:	4611      	mov	r1, r2
   1f9b6:	6940      	ldr	r0, [r0, #20]
   1f9b8:	f7fa fd70 	bl	1a49c <_DHCPClientClose>
        if(stackCtrl->stackAction == TCPIP_STACK_ACTION_DEINIT)
   1f9bc:	7f23      	ldrb	r3, [r4, #28]
   1f9be:	2b02      	cmp	r3, #2
   1f9c0:	d000      	beq.n	1f9c4 <TCPIP_DHCP_Deinitialize+0x20>
}
   1f9c2:	bd10      	pop	{r4, pc}
            if(--dhcpInitCount == 0)
   1f9c4:	4a05      	ldr	r2, [pc, #20]	; (1f9dc <TCPIP_DHCP_Deinitialize+0x38>)
   1f9c6:	6813      	ldr	r3, [r2, #0]
   1f9c8:	3b01      	subs	r3, #1
   1f9ca:	6013      	str	r3, [r2, #0]
   1f9cc:	2b00      	cmp	r3, #0
   1f9ce:	d1f8      	bne.n	1f9c2 <TCPIP_DHCP_Deinitialize+0x1e>
                _DHCPCleanup();
   1f9d0:	f7fa fbb4 	bl	1a13c <_DHCPCleanup>
                dhcpMemH = 0;
   1f9d4:	4b02      	ldr	r3, [pc, #8]	; (1f9e0 <TCPIP_DHCP_Deinitialize+0x3c>)
   1f9d6:	2200      	movs	r2, #0
   1f9d8:	601a      	str	r2, [r3, #0]
}
   1f9da:	e7f2      	b.n	1f9c2 <TCPIP_DHCP_Deinitialize+0x1e>
   1f9dc:	2000ee40 	.word	0x2000ee40
   1f9e0:	2000ee48 	.word	0x2000ee48

Disassembly of section .text.TCPIP_DNS_RemoveEntry%662:

0001f9e4 <TCPIP_DNS_RemoveEntry>:
{
   1f9e4:	b510      	push	{r4, lr}
    pDnsDcpt = pgDnsDcpt;
   1f9e6:	4b0e      	ldr	r3, [pc, #56]	; (1fa20 <TCPIP_DNS_RemoveEntry+0x3c>)
   1f9e8:	681c      	ldr	r4, [r3, #0]
    if(pDnsDcpt == 0 || pDnsDcpt->hashDcpt == 0)
   1f9ea:	b164      	cbz	r4, 1fa06 <TCPIP_DNS_RemoveEntry+0x22>
   1f9ec:	4601      	mov	r1, r0
   1f9ee:	6820      	ldr	r0, [r4, #0]
   1f9f0:	b160      	cbz	r0, 1fa0c <TCPIP_DNS_RemoveEntry+0x28>
    if(hostName == NULL)
   1f9f2:	b171      	cbz	r1, 1fa12 <TCPIP_DNS_RemoveEntry+0x2e>
    pDnsHE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryLookup(pDnsDcpt->hashDcpt, hostName);
   1f9f4:	f7fc ffc6 	bl	1c984 <TCPIP_OAHASH_EntryLookup>
    if(pDnsHE != 0)
   1f9f8:	4601      	mov	r1, r0
   1f9fa:	b168      	cbz	r0, 1fa18 <TCPIP_DNS_RemoveEntry+0x34>
    _DNS_CleanCacheEntry(pDnsDcpt, pDnsHE);
   1f9fc:	4620      	mov	r0, r4
   1f9fe:	f001 fed4 	bl	217aa <_DNS_CleanCacheEntry>
        return TCPIP_DNS_RES_OK;
   1fa02:	2000      	movs	r0, #0
}
   1fa04:	bd10      	pop	{r4, pc}
        return TCPIP_DNS_RES_NO_SERVICE;
   1fa06:	f06f 0005 	mvn.w	r0, #5
   1fa0a:	e7fb      	b.n	1fa04 <TCPIP_DNS_RemoveEntry+0x20>
   1fa0c:	f06f 0005 	mvn.w	r0, #5
   1fa10:	e7f8      	b.n	1fa04 <TCPIP_DNS_RemoveEntry+0x20>
        return TCPIP_DNS_RES_INVALID_HOSTNAME;
   1fa12:	f06f 0008 	mvn.w	r0, #8
   1fa16:	e7f5      	b.n	1fa04 <TCPIP_DNS_RemoveEntry+0x20>
    return TCPIP_DNS_RES_NO_NAME_ENTRY;
   1fa18:	f04f 30ff 	mov.w	r0, #4294967295
   1fa1c:	e7f2      	b.n	1fa04 <TCPIP_DNS_RemoveEntry+0x20>
   1fa1e:	bf00      	nop
   1fa20:	2000ee58 	.word	0x2000ee58

Disassembly of section .rodata%663:

0001fa24 <.rodata%663>:
   1fa24:	252e6425 	.word	0x252e6425
   1fa28:	64252e64 	.word	0x64252e64
   1fa2c:	0064252e 	.word	0x0064252e
   1fa30:	78322e25 	.word	0x78322e25
   1fa34:	322e253a 	.word	0x322e253a
   1fa38:	2e253a78 	.word	0x2e253a78
   1fa3c:	253a7832 	.word	0x253a7832
   1fa40:	3a78322e 	.word	0x3a78322e
   1fa44:	78322e25 	.word	0x78322e25
   1fa48:	322e253a 	.word	0x322e253a
   1fa4c:	00000078 	.word	0x00000078
   1fa50:	6c6c7566 	.word	0x6c6c7566
   1fa54:	00000000 	.word	0x00000000
   1fa58:	00776f6c 	.word	0x00776f6c
   1fa5c:	6e776f64 	.word	0x6e776f64
   1fa60:	00          	.byte	0x00
   1fa61:	00          	.byte	0x00
   1fa62:	bf00      	nop

Disassembly of section .text.TCPIP_STACK_NetHandleGet%664:

0001fa64 <TCPIP_STACK_NetHandleGet>:
{
   1fa64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1fa66:	4606      	mov	r6, r0
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   1fa68:	4b0c      	ldr	r3, [pc, #48]	; (1fa9c <TCPIP_STACK_NetHandleGet+0x38>)
   1fa6a:	681c      	ldr	r4, [r3, #0]
   1fa6c:	4b0c      	ldr	r3, [pc, #48]	; (1faa0 <TCPIP_STACK_NetHandleGet+0x3c>)
   1fa6e:	681f      	ldr	r7, [r3, #0]
   1fa70:	2f00      	cmp	r7, #0
   1fa72:	dd0a      	ble.n	1fa8a <TCPIP_STACK_NetHandleGet+0x26>
   1fa74:	2500      	movs	r5, #0
        if(strcmp(pNetIf->ifName, interface) == 0)
   1fa76:	4631      	mov	r1, r6
   1fa78:	f104 0062 	add.w	r0, r4, #98	; 0x62
   1fa7c:	f004 f8be 	bl	23bfc <strcmp>
   1fa80:	b148      	cbz	r0, 1fa96 <TCPIP_STACK_NetHandleGet+0x32>
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   1fa82:	3501      	adds	r5, #1
   1fa84:	346c      	adds	r4, #108	; 0x6c
   1fa86:	42bd      	cmp	r5, r7
   1fa88:	d1f5      	bne.n	1fa76 <TCPIP_STACK_NetHandleGet+0x12>
    return TCPIP_STACK_MACIdToNet(TCPIP_STACK_StringToMACId(interface));
   1fa8a:	4630      	mov	r0, r6
   1fa8c:	f7fe fa16 	bl	1debc <TCPIP_STACK_StringToMACId>
   1fa90:	f7ff f93e 	bl	1ed10 <TCPIP_STACK_MACIdToNet>
   1fa94:	4604      	mov	r4, r0
}
   1fa96:	4620      	mov	r0, r4
   1fa98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1fa9a:	bf00      	nop
   1fa9c:	2000ee74 	.word	0x2000ee74
   1faa0:	2000eae4 	.word	0x2000eae4

Disassembly of section .text._TCPIP_PKT_PacketAcknowledge%665:

0001faa4 <_TCPIP_PKT_PacketAcknowledge>:
{
   1faa4:	b510      	push	{r4, lr}
   1faa6:	4604      	mov	r4, r0
    if(ackRes != TCPIP_MAC_PKT_ACK_NONE)
   1faa8:	b109      	cbz	r1, 1faae <_TCPIP_PKT_PacketAcknowledge+0xa>
        pPkt->ackRes = ackRes;
   1faaa:	f880 102c 	strb.w	r1, [r0, #44]	; 0x2c
    pPkt->pktPriority = 0; //clear the packet priority to default
   1faae:	2300      	movs	r3, #0
   1fab0:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
    if(pPkt->ackFunc)
   1fab4:	68a3      	ldr	r3, [r4, #8]
   1fab6:	b143      	cbz	r3, 1faca <_TCPIP_PKT_PacketAcknowledge+0x26>
       if((*pPkt->ackFunc)(pPkt, pPkt->ackParam))
   1fab8:	68e1      	ldr	r1, [r4, #12]
   1faba:	4620      	mov	r0, r4
   1fabc:	4798      	blx	r3
   1fabe:	b118      	cbz	r0, 1fac8 <_TCPIP_PKT_PacketAcknowledge+0x24>
           pPkt->pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED;
   1fac0:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   1fac2:	f023 0308 	bic.w	r3, r3, #8
   1fac6:	8463      	strh	r3, [r4, #34]	; 0x22
}
   1fac8:	bd10      	pop	{r4, pc}
        SYS_ERROR(SYS_ERROR_WARNING, "Packet Ack: orphan packet! \r\n");
   1faca:	f004 fbd9 	bl	24280 <SYS_DEBUG_ErrorLevelGet>
   1face:	2801      	cmp	r0, #1
   1fad0:	d9fa      	bls.n	1fac8 <_TCPIP_PKT_PacketAcknowledge+0x24>
   1fad2:	f004 fbcf 	bl	24274 <SYS_DEBUG_ConsoleInstanceGet>
   1fad6:	4902      	ldr	r1, [pc, #8]	; (1fae0 <_TCPIP_PKT_PacketAcknowledge+0x3c>)
   1fad8:	f7fc fde0 	bl	1c69c <SYS_CONSOLE_Print>
}
   1fadc:	e7f4      	b.n	1fac8 <_TCPIP_PKT_PacketAcknowledge+0x24>
   1fade:	bf00      	nop
   1fae0:	00022c80 	.word	0x00022c80

Disassembly of section .text._UDPIsAvailablePort%666:

0001fae4 <_UDPIsAvailablePort>:
{
   1fae4:	b410      	push	{r4}
    for(skt = 0; skt < nUdpSockets; skt++)
   1fae6:	4b0d      	ldr	r3, [pc, #52]	; (1fb1c <_UDPIsAvailablePort+0x38>)
   1fae8:	681c      	ldr	r4, [r3, #0]
   1faea:	2c00      	cmp	r4, #0
   1faec:	dd14      	ble.n	1fb18 <_UDPIsAvailablePort+0x34>
        pSkt = UDPSocketDcpt[skt]; 
   1faee:	4b0c      	ldr	r3, [pc, #48]	; (1fb20 <_UDPIsAvailablePort+0x3c>)
   1faf0:	6819      	ldr	r1, [r3, #0]
   1faf2:	3904      	subs	r1, #4
    for(skt = 0; skt < nUdpSockets; skt++)
   1faf4:	2300      	movs	r3, #0
   1faf6:	e002      	b.n	1fafe <_UDPIsAvailablePort+0x1a>
   1faf8:	3301      	adds	r3, #1
   1fafa:	42a3      	cmp	r3, r4
   1fafc:	d008      	beq.n	1fb10 <_UDPIsAvailablePort+0x2c>
        pSkt = UDPSocketDcpt[skt]; 
   1fafe:	f851 2f04 	ldr.w	r2, [r1, #4]!
        if(pSkt && pSkt->localPort == port)
   1fb02:	2a00      	cmp	r2, #0
   1fb04:	d0f8      	beq.n	1faf8 <_UDPIsAvailablePort+0x14>
   1fb06:	8d52      	ldrh	r2, [r2, #42]	; 0x2a
   1fb08:	4282      	cmp	r2, r0
   1fb0a:	d1f5      	bne.n	1faf8 <_UDPIsAvailablePort+0x14>
            return false;
   1fb0c:	2000      	movs	r0, #0
   1fb0e:	e000      	b.n	1fb12 <_UDPIsAvailablePort+0x2e>
    return true;
   1fb10:	2001      	movs	r0, #1
}
   1fb12:	f85d 4b04 	ldr.w	r4, [sp], #4
   1fb16:	4770      	bx	lr
    return true;
   1fb18:	2001      	movs	r0, #1
   1fb1a:	e7fa      	b.n	1fb12 <_UDPIsAvailablePort+0x2e>
   1fb1c:	2000ee8c 	.word	0x2000ee8c
   1fb20:	2000ee88 	.word	0x2000ee88

Disassembly of section .text.TCPIP_UDP_SocketNetSet%667:

0001fb24 <TCPIP_UDP_SocketNetSet>:
{
   1fb24:	b510      	push	{r4, lr}
   1fb26:	460c      	mov	r4, r1
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1fb28:	f002 fb10 	bl	2214c <_UDPSocketDcpt>
    if(pSkt)
   1fb2c:	b148      	cbz	r0, 1fb42 <TCPIP_UDP_SocketNetSet+0x1e>
   1fb2e:	4603      	mov	r3, r0
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   1fb30:	b124      	cbz	r4, 1fb3c <TCPIP_UDP_SocketNetSet+0x18>
   1fb32:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
   1fb36:	f012 0f40 	tst.w	r2, #64	; 0x40
   1fb3a:	d104      	bne.n	1fb46 <TCPIP_UDP_SocketNetSet+0x22>
        if((pSkt->pSktNet = pIf) != 0)
   1fb3c:	2200      	movs	r2, #0
   1fb3e:	625a      	str	r2, [r3, #36]	; 0x24
   1fb40:	e008      	b.n	1fb54 <TCPIP_UDP_SocketNetSet+0x30>
    return false;
   1fb42:	2000      	movs	r0, #0
   1fb44:	e00d      	b.n	1fb62 <TCPIP_UDP_SocketNetSet+0x3e>
        if((pSkt->pSktNet = pIf) != 0)
   1fb46:	6244      	str	r4, [r0, #36]	; 0x24
            pSkt->flags.looseNetIf = 0;
   1fb48:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
   1fb4c:	f36f 02c3 	bfc	r2, #3, #1
   1fb50:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
    pSkt->extFlags.rxEnable = 1;
   1fb54:	f893 2042 	ldrb.w	r2, [r3, #66]	; 0x42
   1fb58:	f042 0202 	orr.w	r2, r2, #2
   1fb5c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        return true;
   1fb60:	2001      	movs	r0, #1
}
   1fb62:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_DHCPS_Deinitialize%668:

0001fb64 <TCPIP_DHCPS_Deinitialize>:
    if(dhcpSInitCount > 0)
   1fb64:	4b0d      	ldr	r3, [pc, #52]	; (1fb9c <TCPIP_DHCPS_Deinitialize+0x38>)
   1fb66:	681b      	ldr	r3, [r3, #0]
   1fb68:	2b00      	cmp	r3, #0
   1fb6a:	dc00      	bgt.n	1fb6e <TCPIP_DHCPS_Deinitialize+0xa>
   1fb6c:	4770      	bx	lr
{
   1fb6e:	b510      	push	{r4, lr}
   1fb70:	4604      	mov	r4, r0
        _DHCPSrvClose(stackCtrl->pNetIf,true);
   1fb72:	2101      	movs	r1, #1
   1fb74:	6940      	ldr	r0, [r0, #20]
   1fb76:	f7fd fd87 	bl	1d688 <_DHCPSrvClose>
        if(stackCtrl->stackAction == TCPIP_STACK_ACTION_DEINIT)
   1fb7a:	7f23      	ldrb	r3, [r4, #28]
   1fb7c:	2b02      	cmp	r3, #2
   1fb7e:	d000      	beq.n	1fb82 <TCPIP_DHCPS_Deinitialize+0x1e>
}
   1fb80:	bd10      	pop	{r4, pc}
            if(--dhcpSInitCount == 0)
   1fb82:	4a06      	ldr	r2, [pc, #24]	; (1fb9c <TCPIP_DHCPS_Deinitialize+0x38>)
   1fb84:	6813      	ldr	r3, [r2, #0]
   1fb86:	3b01      	subs	r3, #1
   1fb88:	6013      	str	r3, [r2, #0]
   1fb8a:	2b00      	cmp	r3, #0
   1fb8c:	d1f8      	bne.n	1fb80 <TCPIP_DHCPS_Deinitialize+0x1c>
                _DHCPServerCleanup();
   1fb8e:	f7fe fc75 	bl	1e47c <_DHCPServerCleanup>
                dhcpSMemH = 0;
   1fb92:	4b03      	ldr	r3, [pc, #12]	; (1fba0 <TCPIP_DHCPS_Deinitialize+0x3c>)
   1fb94:	2200      	movs	r2, #0
   1fb96:	601a      	str	r2, [r3, #0]
}
   1fb98:	e7f2      	b.n	1fb80 <TCPIP_DHCPS_Deinitialize+0x1c>
   1fb9a:	bf00      	nop
   1fb9c:	2000eea0 	.word	0x2000eea0
   1fba0:	2000eea4 	.word	0x2000eea4

Disassembly of section .text.TC0_TimerInitialize%669:

0001fba4 <TC0_TimerInitialize>:
// *****************************************************************************
/* Initialize the TC module in Timer mode */
void TC0_TimerInitialize( void )
{
    /* Reset TC */
    TC0_REGS->COUNT16.TC_CTRLA = TC_CTRLA_SWRST_Msk;
   1fba4:	4b0d      	ldr	r3, [pc, #52]	; (1fbdc <TC0_TimerInitialize+0x38>)
   1fba6:	2201      	movs	r2, #1
   1fba8:	601a      	str	r2, [r3, #0]

    while((TC0_REGS->COUNT16.TC_SYNCBUSY & TC_SYNCBUSY_SWRST_Msk) == TC_SYNCBUSY_SWRST_Msk)
   1fbaa:	461a      	mov	r2, r3
   1fbac:	6913      	ldr	r3, [r2, #16]
   1fbae:	f013 0f01 	tst.w	r3, #1
   1fbb2:	d1fb      	bne.n	1fbac <TC0_TimerInitialize+0x8>
    {
        /* Wait for Write Synchronization */
    }

    /* Configure counter mode & prescaler */
    TC0_REGS->COUNT16.TC_CTRLA = TC_CTRLA_MODE_COUNT16 | TC_CTRLA_PRESCALER_DIV1 | TC_CTRLA_PRESCSYNC_PRESC ;
   1fbb4:	4b09      	ldr	r3, [pc, #36]	; (1fbdc <TC0_TimerInitialize+0x38>)
   1fbb6:	2210      	movs	r2, #16
   1fbb8:	601a      	str	r2, [r3, #0]

    /* Configure in Match Frequency Mode */
    TC0_REGS->COUNT16.TC_WAVE = (uint8_t)TC_WAVE_WAVEGEN_MPWM;
   1fbba:	2203      	movs	r2, #3
   1fbbc:	731a      	strb	r2, [r3, #12]

    /* Configure timer period */
    TC0_REGS->COUNT16.TC_CC[0U] = 60000U;
   1fbbe:	f64e 2260 	movw	r2, #60000	; 0xea60
   1fbc2:	839a      	strh	r2, [r3, #28]

    /* Clear all interrupt flags */
    TC0_REGS->COUNT16.TC_INTFLAG = (uint8_t)TC_INTFLAG_Msk;
   1fbc4:	2233      	movs	r2, #51	; 0x33
   1fbc6:	729a      	strb	r2, [r3, #10]

    TC0_CallbackObject.callback = NULL;
   1fbc8:	4a05      	ldr	r2, [pc, #20]	; (1fbe0 <TC0_TimerInitialize+0x3c>)
   1fbca:	2100      	movs	r1, #0
   1fbcc:	6011      	str	r1, [r2, #0]
    /* Enable interrupt*/
    TC0_REGS->COUNT16.TC_INTENSET = (uint8_t)(TC_INTENSET_MC1_Msk);
   1fbce:	2220      	movs	r2, #32
   1fbd0:	725a      	strb	r2, [r3, #9]


    while((TC0_REGS->COUNT16.TC_SYNCBUSY) != 0U)
   1fbd2:	461a      	mov	r2, r3
   1fbd4:	6913      	ldr	r3, [r2, #16]
   1fbd6:	2b00      	cmp	r3, #0
   1fbd8:	d1fc      	bne.n	1fbd4 <TC0_TimerInitialize+0x30>
    {
        /* Wait for Write Synchronization */
    }
}
   1fbda:	4770      	bx	lr
   1fbdc:	40003800 	.word	0x40003800
   1fbe0:	2000ed84 	.word	0x2000ed84

Disassembly of section .text.SYS_TIME_TimerAdd%670:

0001fbe4 <SYS_TIME_TimerAdd>:
{
   1fbe4:	b538      	push	{r3, r4, r5, lr}
   1fbe6:	4605      	mov	r5, r0
    counterObj->hwTimerCurrentValue = counterObj->timePlib->timerCounterGet();
   1fbe8:	4c0d      	ldr	r4, [pc, #52]	; (1fc20 <SYS_TIME_TimerAdd+0x3c>)
   1fbea:	6863      	ldr	r3, [r4, #4]
   1fbec:	699b      	ldr	r3, [r3, #24]
   1fbee:	4798      	blx	r3
   1fbf0:	6160      	str	r0, [r4, #20]
    elapsedCount = SYS_TIME_GetElapsedCount(counterObj->hwTimerCurrentValue);
   1fbf2:	6960      	ldr	r0, [r4, #20]
   1fbf4:	f003 fb18 	bl	23228 <SYS_TIME_GetElapsedCount>
   1fbf8:	4604      	mov	r4, r0
    SYS_TIME_UpdateTimerList(elapsedCount);
   1fbfa:	f001 fc5f 	bl	214bc <SYS_TIME_UpdateTimerList>
    SYS_TIME_Counter64Update(elapsedCount);
   1fbfe:	4620      	mov	r0, r4
   1fc00:	f003 fb04 	bl	2320c <SYS_TIME_Counter64Update>
    isHeadTimerUpdated = SYS_TIME_AddToList(newTimer);
   1fc04:	4628      	mov	r0, r5
   1fc06:	f7fa fbb9 	bl	1a37c <SYS_TIME_AddToList>
    if (isHeadTimerUpdated == true)
   1fc0a:	b900      	cbnz	r0, 1fc0e <SYS_TIME_TimerAdd+0x2a>
}
   1fc0c:	bd38      	pop	{r3, r4, r5, pc}
        interruptState = SYS_INT_Disable();
   1fc0e:	f004 fbf3 	bl	243f8 <SYS_INT_Disable>
   1fc12:	4604      	mov	r4, r0
        SYS_TIME_HwTimerCompareUpdate();
   1fc14:	f7f8 fcfa 	bl	1860c <SYS_TIME_HwTimerCompareUpdate>
        SYS_INT_Restore(interruptState);
   1fc18:	4620      	mov	r0, r4
   1fc1a:	f004 fbf1 	bl	24400 <SYS_INT_Restore>
}
   1fc1e:	e7f5      	b.n	1fc0c <SYS_TIME_TimerAdd+0x28>
   1fc20:	2000ea00 	.word	0x2000ea00

Disassembly of section .rodata%671:

0001fc24 <.rodata%671>:
   1fc24:	5f535953 	.word	0x5f535953
   1fc28:	5f444d43 	.word	0x5f444d43
   1fc2c:	4b534154 	.word	0x4b534154
   1fc30:	00000053 	.word	0x00000053
   1fc34:	5f565244 	.word	0x5f565244
   1fc38:	4d49494d 	.word	0x4d49494d
   1fc3c:	7361545f 	.word	0x7361545f
   1fc40:	0000736b 	.word	0x0000736b
   1fc44:	49504354 	.word	0x49504354
   1fc48:	54535f50 	.word	0x54535f50
   1fc4c:	5f4b4341 	.word	0x5f4b4341
   1fc50:	6b736154 	.word	0x6b736154
   1fc54:	00000073 	.word	0x00000073
   1fc58:	5f505041 	.word	0x5f505041
   1fc5c:	6b736154 	.word	0x6b736154
   1fc60:	0073      	.short	0x0073
   1fc62:	bf00      	nop

Disassembly of section .text.ssd1306_write_command%672:

0001fc64 <ssd1306_write_command>:
 * This functions pull pin D/C# low before writing to the controller. Different
 * data write function is called based on the selected interface.
 *
 * \param command the command to write
 */
void ssd1306_write_command(uint8_t command) {
   1fc64:	b500      	push	{lr}
   1fc66:	b083      	sub	sp, #12
   1fc68:	f88d 0007 	strb.w	r0, [sp, #7]
    GFX_DISPLAY_SS_N_CLEAR();
   1fc6c:	4b0c      	ldr	r3, [pc, #48]	; (1fca0 <ssd1306_write_command+0x3c>)
   1fc6e:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   1fc72:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    GFX_DATA_CMD_SEL_CLEAR();
   1fc76:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1fc7a:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194
    GFX_SPI_WRITE_FUNCTION(&command, 1);
   1fc7e:	2101      	movs	r1, #1
   1fc80:	f10d 0007 	add.w	r0, sp, #7
   1fc84:	f004 faea 	bl	2425c <SERCOM0_SPI_Write>
    while (GFX_SPI_IS_BUSY());
   1fc88:	f001 ff0c 	bl	21aa4 <SERCOM0_SPI_IsBusy>
   1fc8c:	2800      	cmp	r0, #0
   1fc8e:	d1fb      	bne.n	1fc88 <ssd1306_write_command+0x24>
    GFX_DISPLAY_SS_N_SET();
   1fc90:	4b03      	ldr	r3, [pc, #12]	; (1fca0 <ssd1306_write_command+0x3c>)
   1fc92:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   1fc96:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
}
   1fc9a:	b003      	add	sp, #12
   1fc9c:	f85d fb04 	ldr.w	pc, [sp], #4
   1fca0:	41008000 	.word	0x41008000

Disassembly of section .text.ssd1306_write_data%673:

0001fca4 <ssd1306_write_data>:
 * This functions sets the pin D/C# before writing to the controller. Different
 * data write function is called based on the selected interface.
 *
 * \param data the data to write
 */
void ssd1306_write_data(uint8_t data) {
   1fca4:	b500      	push	{lr}
   1fca6:	b083      	sub	sp, #12
   1fca8:	f88d 0007 	strb.w	r0, [sp, #7]
    GFX_DISPLAY_SS_N_CLEAR();
   1fcac:	4b0c      	ldr	r3, [pc, #48]	; (1fce0 <ssd1306_write_data+0x3c>)
   1fcae:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   1fcb2:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    GFX_DATA_CMD_SEL_SET();
   1fcb6:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1fcba:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
    GFX_SPI_WRITE_FUNCTION(&data, 1);
   1fcbe:	2101      	movs	r1, #1
   1fcc0:	f10d 0007 	add.w	r0, sp, #7
   1fcc4:	f004 faca 	bl	2425c <SERCOM0_SPI_Write>
    while (GFX_SPI_IS_BUSY());
   1fcc8:	f001 feec 	bl	21aa4 <SERCOM0_SPI_IsBusy>
   1fccc:	2800      	cmp	r0, #0
   1fcce:	d1fb      	bne.n	1fcc8 <ssd1306_write_data+0x24>
    GFX_DISPLAY_SS_N_SET();
   1fcd0:	4b03      	ldr	r3, [pc, #12]	; (1fce0 <ssd1306_write_data+0x3c>)
   1fcd2:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   1fcd6:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
}
   1fcda:	b003      	add	sp, #12
   1fcdc:	f85d fb04 	ldr.w	pc, [sp], #4
   1fce0:	41008000 	.word	0x41008000

Disassembly of section .text%674:

0001fce4 <__aeabi_d2uiz>:
   1fce4:	004a      	lsls	r2, r1, #1
   1fce6:	d211      	bcs.n	1fd0c <__aeabi_d2uiz+0x28>
   1fce8:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   1fcec:	d211      	bcs.n	1fd12 <__aeabi_d2uiz+0x2e>
   1fcee:	d50d      	bpl.n	1fd0c <__aeabi_d2uiz+0x28>
   1fcf0:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   1fcf4:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   1fcf8:	d40e      	bmi.n	1fd18 <__aeabi_d2uiz+0x34>
   1fcfa:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   1fcfe:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1fd02:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   1fd06:	fa23 f002 	lsr.w	r0, r3, r2
   1fd0a:	4770      	bx	lr
   1fd0c:	f04f 0000 	mov.w	r0, #0
   1fd10:	4770      	bx	lr
   1fd12:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   1fd16:	d102      	bne.n	1fd1e <__aeabi_d2uiz+0x3a>
   1fd18:	f04f 30ff 	mov.w	r0, #4294967295
   1fd1c:	4770      	bx	lr
   1fd1e:	f04f 0000 	mov.w	r0, #0
   1fd22:	4770      	bx	lr

Disassembly of section .text.__hi0bits%675:

0001fd24 <__hi0bits>:
   1fd24:	0c02      	lsrs	r2, r0, #16
   1fd26:	0412      	lsls	r2, r2, #16
   1fd28:	4603      	mov	r3, r0
   1fd2a:	b9ca      	cbnz	r2, 1fd60 <__hi0bits+0x3c>
   1fd2c:	0403      	lsls	r3, r0, #16
   1fd2e:	2010      	movs	r0, #16
   1fd30:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
   1fd34:	bf04      	itt	eq
   1fd36:	021b      	lsleq	r3, r3, #8
   1fd38:	3008      	addeq	r0, #8
   1fd3a:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
   1fd3e:	bf04      	itt	eq
   1fd40:	011b      	lsleq	r3, r3, #4
   1fd42:	3004      	addeq	r0, #4
   1fd44:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
   1fd48:	bf04      	itt	eq
   1fd4a:	009b      	lsleq	r3, r3, #2
   1fd4c:	3002      	addeq	r0, #2
   1fd4e:	2b00      	cmp	r3, #0
   1fd50:	db05      	blt.n	1fd5e <__hi0bits+0x3a>
   1fd52:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
   1fd56:	f100 0001 	add.w	r0, r0, #1
   1fd5a:	bf08      	it	eq
   1fd5c:	2020      	moveq	r0, #32
   1fd5e:	4770      	bx	lr
   1fd60:	2000      	movs	r0, #0
   1fd62:	e7e5      	b.n	1fd30 <__hi0bits+0xc>

Disassembly of section .text.write%676:

0001fd64 <write>:
   1fd64:	b570      	push	{r4, r5, r6, lr}
   1fd66:	b1b9      	cbz	r1, 1fd98 <write+0x34>
   1fd68:	4615      	mov	r5, r2
   1fd6a:	b10a      	cbz	r2, 1fd70 <write+0xc>
   1fd6c:	2802      	cmp	r0, #2
   1fd6e:	d901      	bls.n	1fd74 <write+0x10>
   1fd70:	4628      	mov	r0, r5
   1fd72:	bd70      	pop	{r4, r5, r6, pc}
   1fd74:	4b0a      	ldr	r3, [pc, #40]	; (1fda0 <write+0x3c>)
   1fd76:	b12b      	cbz	r3, 1fd84 <write+0x20>
   1fd78:	4608      	mov	r0, r1
   1fd7a:	4611      	mov	r1, r2
   1fd7c:	f3af 8000 	nop.w
   1fd80:	4628      	mov	r0, r5
   1fd82:	bd70      	pop	{r4, r5, r6, pc}
   1fd84:	460c      	mov	r4, r1
   1fd86:	188e      	adds	r6, r1, r2
   1fd88:	f814 0b01 	ldrb.w	r0, [r4], #1
   1fd8c:	f7f6 fc8b 	bl	166a6 <_mon_putc>
   1fd90:	42b4      	cmp	r4, r6
   1fd92:	d1f9      	bne.n	1fd88 <write+0x24>
   1fd94:	4628      	mov	r0, r5
   1fd96:	bd70      	pop	{r4, r5, r6, pc}
   1fd98:	460d      	mov	r5, r1
   1fd9a:	4628      	mov	r0, r5
   1fd9c:	bd70      	pop	{r4, r5, r6, pc}
   1fd9e:	bf00      	nop
   1fda0:	00000000 	.word	0x00000000

Disassembly of section .text._TCPSetHalfFlushFlag%677:

0001fda4 <_TCPSetHalfFlushFlag>:
    TCP_OPTION_THRES_FLUSH_TYPE flushType = (TCP_OPTION_THRES_FLUSH_TYPE)pSkt->Flags.halfThresType;
   1fda4:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
   1fda8:	f3c3 1301 	ubfx	r3, r3, #4, #2
    switch(flushType)
   1fdac:	b163      	cbz	r3, 1fdc8 <_TCPSetHalfFlushFlag+0x24>
    bool    clrFlushFlag = false;
   1fdae:	2b01      	cmp	r3, #1
   1fdb0:	bf14      	ite	ne
   1fdb2:	2300      	movne	r3, #0
   1fdb4:	2301      	moveq	r3, #1
    pSkt->flags.halfThresFlush = clrFlushFlag ? 0 : 1;
   1fdb6:	f083 0301 	eor.w	r3, r3, #1
   1fdba:	f890 206d 	ldrb.w	r2, [r0, #109]	; 0x6d
   1fdbe:	f363 12c7 	bfi	r2, r3, #7, #1
   1fdc2:	f880 206d 	strb.w	r2, [r0, #109]	; 0x6d
}
   1fdc6:	4770      	bx	lr
            if((pSkt->txEnd - pSkt->txStart) >= (pSkt->wRemoteMSS * 3) / 2 )
   1fdc8:	6843      	ldr	r3, [r0, #4]
   1fdca:	6802      	ldr	r2, [r0, #0]
   1fdcc:	1a9a      	subs	r2, r3, r2
   1fdce:	f8b0 3062 	ldrh.w	r3, [r0, #98]	; 0x62
   1fdd2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1fdd6:	ebb2 0f63 	cmp.w	r2, r3, asr #1
   1fdda:	bfac      	ite	ge
   1fddc:	2301      	movge	r3, #1
   1fdde:	2300      	movlt	r3, #0
   1fde0:	e7e9      	b.n	1fdb6 <_TCPSetHalfFlushFlag+0x12>

Disassembly of section .text._DHCPOptionProcessSubNet%678:

0001fde2 <_DHCPOptionProcessSubNet>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_SUBNET_MASK))
   1fde2:	684b      	ldr	r3, [r1, #4]
   1fde4:	2b05      	cmp	r3, #5
   1fde6:	d913      	bls.n	1fe10 <_DHCPOptionProcessSubNet+0x2e>
        TCPIP_DHCP_OPTION_DATA_SUBNET_MASK* pSubMask = (TCPIP_DHCP_OPTION_DATA_SUBNET_MASK*)pOptData->pOpt;
   1fde8:	680b      	ldr	r3, [r1, #0]
        if(pSubMask->len == sizeof(pSubMask->mask))
   1fdea:	785a      	ldrb	r2, [r3, #1]
   1fdec:	2a04      	cmp	r2, #4
   1fdee:	d112      	bne.n	1fe16 <_DHCPOptionProcessSubNet+0x34>
            if(pClient->flags.bOfferReceived == 0)
   1fdf0:	f890 2058 	ldrb.w	r2, [r0, #88]	; 0x58
   1fdf4:	f012 0f04 	tst.w	r2, #4
   1fdf8:	d110      	bne.n	1fe1c <_DHCPOptionProcessSubNet+0x3a>
                memcpy(&pClient->dhcpMask, pSubMask->mask, sizeof(pClient->dhcpMask)); 
   1fdfa:	f8d3 3002 	ldr.w	r3, [r3, #2]
   1fdfe:	6343      	str	r3, [r0, #52]	; 0x34
                pClient->validValues.Mask = 1;
   1fe00:	f890 3059 	ldrb.w	r3, [r0, #89]	; 0x59
   1fe04:	f043 0304 	orr.w	r3, r3, #4
   1fe08:	f880 3059 	strb.w	r3, [r0, #89]	; 0x59
            return sizeof(TCPIP_DHCP_OPTION_DATA_SUBNET_MASK);
   1fe0c:	2006      	movs	r0, #6
   1fe0e:	4770      	bx	lr
    return -1;
   1fe10:	f04f 30ff 	mov.w	r0, #4294967295
   1fe14:	4770      	bx	lr
   1fe16:	f04f 30ff 	mov.w	r0, #4294967295
   1fe1a:	4770      	bx	lr
            return sizeof(TCPIP_DHCP_OPTION_DATA_SUBNET_MASK);
   1fe1c:	2006      	movs	r0, #6
}
   1fe1e:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_AddressServiceDefaultSet%679:

0001fe20 <TCPIP_STACK_AddressServiceDefaultSet>:
{
   1fe20:	b510      	push	{r4, lr}
   1fe22:	4604      	mov	r4, r0
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1fe24:	2000      	movs	r0, #0
   1fe26:	f003 fca5 	bl	23774 <OSAL_CRIT_Enter>
   1fe2a:	4601      	mov	r1, r0
    _TCPIPStackSetIpAddress(pNetIf, &pNetIf->DefaultIPAddr, &pNetIf->DefaultMask, &pNetIf->DefaultGateway, false);
   1fe2c:	f104 021c 	add.w	r2, r4, #28
   1fe30:	f104 0320 	add.w	r3, r4, #32
    if(ipAddress)
   1fe34:	f114 0f18 	cmn.w	r4, #24
        pNetIf->netIPAddr.Val = ipAddress->Val;
   1fe38:	bf1c      	itt	ne
   1fe3a:	69a0      	ldrne	r0, [r4, #24]
   1fe3c:	6060      	strne	r0, [r4, #4]
    if(mask)
   1fe3e:	b10a      	cbz	r2, 1fe44 <TCPIP_STACK_AddressServiceDefaultSet+0x24>
        pNetIf->netMask.Val = mask->Val;
   1fe40:	69e2      	ldr	r2, [r4, #28]
   1fe42:	60a2      	str	r2, [r4, #8]
    if(gw)
   1fe44:	b10b      	cbz	r3, 1fe4a <TCPIP_STACK_AddressServiceDefaultSet+0x2a>
        pNetIf->netGateway.Val = gw->Val;
   1fe46:	6a23      	ldr	r3, [r4, #32]
   1fe48:	60e3      	str	r3, [r4, #12]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1fe4a:	2000      	movs	r0, #0
   1fe4c:	f003 fdcc 	bl	239e8 <OSAL_CRIT_Leave>
    pNetIf->Flags.bInConfig = config;
   1fe50:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   1fe54:	f36f 1304 	bfc	r3, #4, #1
   1fe58:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
}
   1fe5c:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_UDP_TxOffsetSet%680:

0001fe5e <TCPIP_UDP_TxOffsetSet>:
{
   1fe5e:	b570      	push	{r4, r5, r6, lr}
   1fe60:	460d      	mov	r5, r1
   1fe62:	4616      	mov	r6, r2
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1fe64:	f002 f972 	bl	2214c <_UDPSocketDcpt>
    if(pSkt && _UDPTxPktValid(pSkt))
   1fe68:	b198      	cbz	r0, 1fe92 <TCPIP_UDP_TxOffsetSet+0x34>
   1fe6a:	4604      	mov	r4, r0
   1fe6c:	f003 fb12 	bl	23494 <_UDPTxPktValid>
   1fe70:	4603      	mov	r3, r0
   1fe72:	b178      	cbz	r0, 1fe94 <TCPIP_UDP_TxOffsetSet+0x36>
        uint8_t* pNewWrite = relative ? pSkt->txWrite : pSkt->txStart;
   1fe74:	b14e      	cbz	r6, 1fe8a <TCPIP_UDP_TxOffsetSet+0x2c>
   1fe76:	68a2      	ldr	r2, [r4, #8]
        pNewWrite += wOffset;
   1fe78:	4415      	add	r5, r2
        if(pSkt->txStart <= pNewWrite && pNewWrite <= pSkt->txEnd)
   1fe7a:	6822      	ldr	r2, [r4, #0]
   1fe7c:	42aa      	cmp	r2, r5
   1fe7e:	d80b      	bhi.n	1fe98 <TCPIP_UDP_TxOffsetSet+0x3a>
   1fe80:	6862      	ldr	r2, [r4, #4]
   1fe82:	42aa      	cmp	r2, r5
   1fe84:	d203      	bcs.n	1fe8e <TCPIP_UDP_TxOffsetSet+0x30>
    return false;
   1fe86:	2300      	movs	r3, #0
   1fe88:	e004      	b.n	1fe94 <TCPIP_UDP_TxOffsetSet+0x36>
        uint8_t* pNewWrite = relative ? pSkt->txWrite : pSkt->txStart;
   1fe8a:	6822      	ldr	r2, [r4, #0]
   1fe8c:	e7f4      	b.n	1fe78 <TCPIP_UDP_TxOffsetSet+0x1a>
            pSkt->txWrite = pNewWrite;
   1fe8e:	60a5      	str	r5, [r4, #8]
            return true;
   1fe90:	e000      	b.n	1fe94 <TCPIP_UDP_TxOffsetSet+0x36>
    return false;
   1fe92:	2300      	movs	r3, #0
}
   1fe94:	4618      	mov	r0, r3
   1fe96:	bd70      	pop	{r4, r5, r6, pc}
    return false;
   1fe98:	2300      	movs	r3, #0
   1fe9a:	e7fb      	b.n	1fe94 <TCPIP_UDP_TxOffsetSet+0x36>

Disassembly of section .rodata%681:

0001fe9c <.rodata%681>:
   1fe9c:	66202c00 	.word	0x66202c00
   1fea0:	74636e75 	.word	0x74636e75
   1fea4:	3a6e6f69 	.word	0x3a6e6f69
   1fea8:	73610020 	.word	0x73610020
   1feac:	74726573 	.word	0x74726573
   1feb0:	206e6f69 	.word	0x206e6f69
   1feb4:	22732522 	.word	0x22732522
   1feb8:	69616620 	.word	0x69616620
   1febc:	3a64656c 	.word	0x3a64656c
   1fec0:	6c696620 	.word	0x6c696620
   1fec4:	25222065 	.word	0x25222065
   1fec8:	202c2273 	.word	0x202c2273
   1fecc:	656e696c 	.word	0x656e696c
   1fed0:	25642520 	.word	0x25642520
   1fed4:	0a732573 	.word	0x0a732573
	...

Disassembly of section .text._DRV_ETHPHY_NegCompletePhaseAN_Complete%682:

0001feda <_DRV_ETHPHY_NegCompletePhaseAN_Complete>:
{
   1feda:	b510      	push	{r4, lr}
   1fedc:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1fede:	f002 fcf9 	bl	228d4 <_DRV_PHY_SMITransfer_Wait>
   1fee2:	b1b8      	cbz	r0, 1ff14 <_DRV_ETHPHY_NegCompletePhaseAN_Complete+0x3a>
    phyStat.w = hClientObj->smiData;
   1fee4:	8f62      	ldrh	r2, [r4, #58]	; 0x3a
    if(phyStat.AN_COMPLETE == 0)
   1fee6:	f012 0f20 	tst.w	r2, #32
   1feea:	d10f      	bne.n	1ff0c <_DRV_ETHPHY_NegCompletePhaseAN_Complete+0x32>
        if(SYS_TMR_TickCountGet() < hClientObj->operTStamp)
   1feec:	f002 f9a6 	bl	2223c <SYS_TMR_TickCountGet>
   1fef0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1fef2:	4298      	cmp	r0, r3
   1fef4:	d204      	bcs.n	1ff00 <_DRV_ETHPHY_NegCompletePhaseAN_Complete+0x26>
            _DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT);
   1fef6:	2101      	movs	r1, #1
   1fef8:	4620      	mov	r0, r4
   1fefa:	f001 f839 	bl	20f70 <_DRV_PHY_SMIReadStart>
   1fefe:	e009      	b.n	1ff14 <_DRV_ETHPHY_NegCompletePhaseAN_Complete+0x3a>
            _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_NEGOTIATION_ACTIVE);
   1ff00:	f06f 0107 	mvn.w	r1, #7
   1ff04:	4620      	mov	r0, r4
   1ff06:	f001 ff91 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
   1ff0a:	e003      	b.n	1ff14 <_DRV_ETHPHY_NegCompletePhaseAN_Complete+0x3a>
        _DRV_PHY_NegCompleteSetOperResult(hClientObj, phyBMCon.w, phyStat.w);
   1ff0c:	8ca1      	ldrh	r1, [r4, #36]	; 0x24
   1ff0e:	4620      	mov	r0, r4
   1ff10:	f001 f8ab 	bl	2106a <_DRV_PHY_NegCompleteSetOperResult>
}
   1ff14:	bd10      	pop	{r4, pc}

Disassembly of section .text.Lan867x_Read_Register%683:

0001ff16 <Lan867x_Read_Register>:
{
   1ff16:	b510      	push	{r4, lr}
   1ff18:	4604      	mov	r4, r0
   1ff1a:	4613      	mov	r3, r2
    if (R2F(clientObj->vendorData, VENDOR_INTERNAL_STATE) == IDLE_PHASE) {
   1ff1c:	6840      	ldr	r0, [r0, #4]
   1ff1e:	0e42      	lsrs	r2, r0, #25
   1ff20:	d00c      	beq.n	1ff3c <Lan867x_Read_Register+0x26>
    res = Lan867x_Miim_Task(clientObj, DRV_MIIM_OP_READ, regAddr, rData);
   1ff22:	460a      	mov	r2, r1
   1ff24:	2101      	movs	r1, #1
   1ff26:	4620      	mov	r0, r4
   1ff28:	f7f0 fa30 	bl	1038c <Lan867x_Miim_Task>
    if (res == DRV_MIIM_RES_OK) {
   1ff2c:	4603      	mov	r3, r0
   1ff2e:	b918      	cbnz	r0, 1ff38 <Lan867x_Read_Register+0x22>
        clientObj->vendorData = F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   1ff30:	6862      	ldr	r2, [r4, #4]
   1ff32:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   1ff36:	6062      	str	r2, [r4, #4]
}
   1ff38:	4618      	mov	r0, r3
   1ff3a:	bd10      	pop	{r4, pc}
            F2R(initialState, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   1ff3c:	291f      	cmp	r1, #31
   1ff3e:	bf94      	ite	ls
   1ff40:	f04f 7200 	movls.w	r2, #33554432	; 0x2000000
   1ff44:	f04f 6200 	movhi.w	r2, #134217728	; 0x8000000
   1ff48:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
        clientObj->vendorData = F2R(false, VENDOR_IS_BIT_OP, clientObj->vendorData);
   1ff4c:	4310      	orrs	r0, r2
   1ff4e:	6060      	str	r0, [r4, #4]
   1ff50:	e7e7      	b.n	1ff22 <Lan867x_Read_Register+0xc>

Disassembly of section .text.DRV_MIIM_RegisterCallback%684:

0001ff52 <DRV_MIIM_RegisterCallback>:
{
   1ff52:	b538      	push	{r3, r4, r5, lr}
   1ff54:	4615      	mov	r5, r2
        if(cbFunction == 0)
   1ff56:	b181      	cbz	r1, 1ff7a <DRV_MIIM_RegisterCallback+0x28>
   1ff58:	460c      	mov	r4, r1
        if((pClient = _DRV_MIIM_GetClientAndLock(handle, true)) == 0)
   1ff5a:	2101      	movs	r1, #1
   1ff5c:	f7fe fb7d 	bl	1e65a <_DRV_MIIM_GetClientAndLock>
   1ff60:	4603      	mov	r3, r0
   1ff62:	b188      	cbz	r0, 1ff88 <DRV_MIIM_RegisterCallback+0x36>
        pClient->cbackHandler = cbFunction;
   1ff64:	6084      	str	r4, [r0, #8]
    if(pRegResult)
   1ff66:	b10d      	cbz	r5, 1ff6c <DRV_MIIM_RegisterCallback+0x1a>
        *pRegResult = miimRes;
   1ff68:	2200      	movs	r2, #0
   1ff6a:	702a      	strb	r2, [r5, #0]
    OSAL_SEM_Post(&pMiimObj->objSem);
   1ff6c:	6858      	ldr	r0, [r3, #4]
   1ff6e:	f003 fc0d 	bl	2378c <OSAL_SEM_Post>
   1ff72:	4620      	mov	r0, r4
}
   1ff74:	bd38      	pop	{r3, r4, r5, pc}
    if(pRegResult)
   1ff76:	4628      	mov	r0, r5
    return cbHandle;
   1ff78:	e7fc      	b.n	1ff74 <DRV_MIIM_RegisterCallback+0x22>
            miimRes = DRV_MIIM_RES_CALLBACK_HANDLE_ERR; 
   1ff7a:	f06f 0302 	mvn.w	r3, #2
    if(pRegResult)
   1ff7e:	2d00      	cmp	r5, #0
   1ff80:	d0f9      	beq.n	1ff76 <DRV_MIIM_RegisterCallback+0x24>
        *pRegResult = miimRes;
   1ff82:	702b      	strb	r3, [r5, #0]
   1ff84:	2000      	movs	r0, #0
   1ff86:	e7f5      	b.n	1ff74 <DRV_MIIM_RegisterCallback+0x22>
            miimRes = DRV_MIIM_RES_HANDLE_ERR;
   1ff88:	f04f 33ff 	mov.w	r3, #4294967295
   1ff8c:	e7f7      	b.n	1ff7e <DRV_MIIM_RegisterCallback+0x2c>

Disassembly of section .text.hexatob%685:

0001ff8e <hexatob>:
  	Resulting packed byte 0x00 - 0xFF.
  ***************************************************************************/
uint8_t hexatob(uint16_t AsciiVal)
{
    MCHP_UINT16_VAL AsciiChars;
    AsciiChars.Val = AsciiVal;
   1ff8e:	4603      	mov	r3, r0

	// Convert lowercase to uppercase
	if(AsciiChars.v[1] > 'F')
   1ff90:	0a02      	lsrs	r2, r0, #8
   1ff92:	2a46      	cmp	r2, #70	; 0x46
		AsciiChars.v[1] -= 'a'-'A';
   1ff94:	bf84      	itt	hi
   1ff96:	3a20      	subhi	r2, #32
   1ff98:	f362 230f 	bfihi	r3, r2, #8, #8
	if(AsciiChars.v[0] > 'F')
   1ff9c:	b2c0      	uxtb	r0, r0
   1ff9e:	2846      	cmp	r0, #70	; 0x46
		AsciiChars.v[0] -= 'a'-'A';
   1ffa0:	bf84      	itt	hi
   1ffa2:	3820      	subhi	r0, #32
   1ffa4:	f360 0307 	bfihi	r3, r0, #0, #8

	// Convert 0-9, A-F to 0x0-0xF
	if(AsciiChars.v[1] > '9')
   1ffa8:	f3c3 2007 	ubfx	r0, r3, #8, #8
   1ffac:	2839      	cmp	r0, #57	; 0x39
		AsciiChars.v[1] -= 'A' - 10;
   1ffae:	bf8c      	ite	hi
   1ffb0:	3837      	subhi	r0, #55	; 0x37
	else
		AsciiChars.v[1] -= '0';
   1ffb2:	3830      	subls	r0, #48	; 0x30
   1ffb4:	b2c2      	uxtb	r2, r0

	if(AsciiChars.v[0] > '9')
   1ffb6:	b2db      	uxtb	r3, r3
   1ffb8:	2b39      	cmp	r3, #57	; 0x39
		AsciiChars.v[0] -= 'A' - 10;
   1ffba:	bf8c      	ite	hi
   1ffbc:	3b37      	subhi	r3, #55	; 0x37
	else
		AsciiChars.v[0] -= '0';
   1ffbe:	3b30      	subls	r3, #48	; 0x30
   1ffc0:	b2d8      	uxtb	r0, r3

	// Concatenate
	return (AsciiChars.v[1]<<4) |  AsciiChars.v[0];
   1ffc2:	ea40 1002 	orr.w	r0, r0, r2, lsl #4
}
   1ffc6:	b2c0      	uxtb	r0, r0
   1ffc8:	4770      	bx	lr

Disassembly of section .text.TCPIP_TCP_Close%686:

0001ffca <TCPIP_TCP_Close>:
{
   1ffca:	b510      	push	{r4, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   1ffcc:	f001 ffa6 	bl	21f1c <_TcpSocketChk>
    if(pSkt)
   1ffd0:	b1a8      	cbz	r0, 1fffe <TCPIP_TCP_Close+0x34>
   1ffd2:	4604      	mov	r4, r0
        if(pSkt->flags.nonGraceful == 0)
   1ffd4:	f990 306c 	ldrsb.w	r3, [r0, #108]	; 0x6c
   1ffd8:	2b00      	cmp	r3, #0
   1ffda:	db09      	blt.n	1fff0 <TCPIP_TCP_Close+0x26>
            pSkt->flags.forceKill = 1;
   1ffdc:	f890 306d 	ldrb.w	r3, [r0, #109]	; 0x6d
   1ffe0:	f043 0304 	orr.w	r3, r3, #4
   1ffe4:	f880 306d 	strb.w	r3, [r0, #109]	; 0x6d
            _TCP_SEND_RES sRes = _TcpDisconnect(pSkt, true);
   1ffe8:	2101      	movs	r1, #1
   1ffea:	f7f8 fd21 	bl	18a30 <_TcpDisconnect>
            if(sRes != _TCP_SEND_OK)
   1ffee:	b140      	cbz	r0, 20002 <TCPIP_TCP_Close+0x38>
            _TcpAbort(pSkt, _TCP_ABORT_FLAG_FORCE_CLOSE, 0);
   1fff0:	2200      	movs	r2, #0
   1fff2:	2101      	movs	r1, #1
   1fff4:	4620      	mov	r0, r4
   1fff6:	f7fe f85d 	bl	1e0b4 <_TcpAbort>
        return true;
   1fffa:	2001      	movs	r0, #1
   1fffc:	e000      	b.n	20000 <TCPIP_TCP_Close+0x36>
    return false;
   1fffe:	2000      	movs	r0, #0
}
   20000:	bd10      	pop	{r4, pc}
        return true;
   20002:	2001      	movs	r0, #1
   20004:	e7fc      	b.n	20000 <TCPIP_TCP_Close+0x36>

Disassembly of section .text._DHCPOptionProcessRouter%687:

00020006 <_DHCPOptionProcessRouter>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_ROUTER))
   20006:	684b      	ldr	r3, [r1, #4]
   20008:	2b05      	cmp	r3, #5
   2000a:	d914      	bls.n	20036 <_DHCPOptionProcessRouter+0x30>
        TCPIP_DHCP_OPTION_DATA_ROUTER* pRouter = (TCPIP_DHCP_OPTION_DATA_ROUTER*)pOptData->pOpt;
   2000c:	680b      	ldr	r3, [r1, #0]
        if(pRouter->len >= sizeof(pRouter->gateway))
   2000e:	785a      	ldrb	r2, [r3, #1]
   20010:	2a03      	cmp	r2, #3
   20012:	d913      	bls.n	2003c <_DHCPOptionProcessRouter+0x36>
            if(pClient->flags.bOfferReceived == 0)
   20014:	f890 2058 	ldrb.w	r2, [r0, #88]	; 0x58
   20018:	f012 0f04 	tst.w	r2, #4
   2001c:	d108      	bne.n	20030 <_DHCPOptionProcessRouter+0x2a>
                memcpy(&pClient->dhcpGateway, pRouter->gateway, sizeof(pClient->dhcpGateway)); 
   2001e:	f8d3 2002 	ldr.w	r2, [r3, #2]
   20022:	6302      	str	r2, [r0, #48]	; 0x30
                pClient->validValues.Gateway = 1;
   20024:	f890 2059 	ldrb.w	r2, [r0, #89]	; 0x59
   20028:	f042 0202 	orr.w	r2, r2, #2
   2002c:	f880 2059 	strb.w	r2, [r0, #89]	; 0x59
            return 2 + pRouter->len;
   20030:	7858      	ldrb	r0, [r3, #1]
   20032:	3002      	adds	r0, #2
   20034:	4770      	bx	lr
    return -1;
   20036:	f04f 30ff 	mov.w	r0, #4294967295
   2003a:	4770      	bx	lr
   2003c:	f04f 30ff 	mov.w	r0, #4294967295
}
   20040:	4770      	bx	lr

Disassembly of section .text._DHCPNotifyClients%688:

00020044 <_DHCPNotifyClients>:
{
   20044:	b570      	push	{r4, r5, r6, lr}
   20046:	4605      	mov	r5, r0
   20048:	460e      	mov	r6, r1
    TCPIP_Helper_ProtectedSingleListLock(notifyList);
   2004a:	4c0c      	ldr	r4, [pc, #48]	; (2007c <_DHCPNotifyClients+0x38>)
   2004c:	4620      	mov	r0, r4
   2004e:	f002 fdc7 	bl	22be0 <TCPIP_Helper_ProtectedSingleListLock>
    for(dNode = (TCPIP_DHCP_LIST_NODE*)dhcpRegisteredUsers.list.head; dNode != 0; dNode = dNode->next)
   20052:	6824      	ldr	r4, [r4, #0]
   20054:	b95c      	cbnz	r4, 2006e <_DHCPNotifyClients+0x2a>
    TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
   20056:	4809      	ldr	r0, [pc, #36]	; (2007c <_DHCPNotifyClients+0x38>)
   20058:	f003 f814 	bl	23084 <TCPIP_Helper_ProtectedSingleListUnlock>
}
   2005c:	bd70      	pop	{r4, r5, r6, pc}
            (*dNode->handler)(pNetIf, evType, dNode->hParam);
   2005e:	6863      	ldr	r3, [r4, #4]
   20060:	68a2      	ldr	r2, [r4, #8]
   20062:	4631      	mov	r1, r6
   20064:	4628      	mov	r0, r5
   20066:	4798      	blx	r3
    for(dNode = (TCPIP_DHCP_LIST_NODE*)dhcpRegisteredUsers.list.head; dNode != 0; dNode = dNode->next)
   20068:	6824      	ldr	r4, [r4, #0]
   2006a:	2c00      	cmp	r4, #0
   2006c:	d0f3      	beq.n	20056 <_DHCPNotifyClients+0x12>
        if(dNode->hNet == 0 || dNode->hNet == pNetIf)
   2006e:	68e3      	ldr	r3, [r4, #12]
   20070:	2b00      	cmp	r3, #0
   20072:	d0f4      	beq.n	2005e <_DHCPNotifyClients+0x1a>
   20074:	42ab      	cmp	r3, r5
   20076:	d1f7      	bne.n	20068 <_DHCPNotifyClients+0x24>
   20078:	e7f1      	b.n	2005e <_DHCPNotifyClients+0x1a>
   2007a:	bf00      	nop
   2007c:	2000ec64 	.word	0x2000ec64

Disassembly of section .text.TCPIP_DHCP_IsEnabled%689:

00020080 <TCPIP_DHCP_IsEnabled>:
   20080:	b138      	cbz	r0, 20092 <TCPIP_DHCP_IsEnabled+0x12>
   20082:	4603      	mov	r3, r0
   20084:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20088:	f012 0f40 	tst.w	r2, #64	; 0x40
   2008c:	d103      	bne.n	20096 <TCPIP_DHCP_IsEnabled+0x16>
    return false;
   2008e:	2000      	movs	r0, #0
   20090:	4770      	bx	lr
   20092:	2000      	movs	r0, #0
}
   20094:	4770      	bx	lr
{
   20096:	b510      	push	{r4, lr}
    if(DHCPClients && pNetIf)
   20098:	4a07      	ldr	r2, [pc, #28]	; (200b8 <TCPIP_DHCP_IsEnabled+0x38>)
   2009a:	6814      	ldr	r4, [r2, #0]
   2009c:	b154      	cbz	r4, 200b4 <TCPIP_DHCP_IsEnabled+0x34>
   2009e:	4618      	mov	r0, r3
        DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   200a0:	f003 ff4a 	bl	23f38 <TCPIP_STACK_NetIxGet>
        return pClient->flags.bDHCPEnabled != 0;
   200a4:	235c      	movs	r3, #92	; 0x5c
   200a6:	fb03 4000 	mla	r0, r3, r0, r4
   200aa:	f890 0058 	ldrb.w	r0, [r0, #88]	; 0x58
   200ae:	f000 0001 	and.w	r0, r0, #1
}
   200b2:	bd10      	pop	{r4, pc}
    return false;
   200b4:	2000      	movs	r0, #0
   200b6:	e7fc      	b.n	200b2 <TCPIP_DHCP_IsEnabled+0x32>
   200b8:	2000ee3c 	.word	0x2000ee3c

Disassembly of section .text.TCPIP_DHCP_IsServerDetected%690:

000200bc <TCPIP_DHCP_IsServerDetected>:
   200bc:	b138      	cbz	r0, 200ce <TCPIP_DHCP_IsServerDetected+0x12>
   200be:	4603      	mov	r3, r0
   200c0:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   200c4:	f012 0f40 	tst.w	r2, #64	; 0x40
   200c8:	d103      	bne.n	200d2 <TCPIP_DHCP_IsServerDetected+0x16>
    return false;
   200ca:	2000      	movs	r0, #0
   200cc:	4770      	bx	lr
   200ce:	2000      	movs	r0, #0
}
   200d0:	4770      	bx	lr
{
   200d2:	b510      	push	{r4, lr}
    if(DHCPClients && pNetIf)
   200d4:	4a07      	ldr	r2, [pc, #28]	; (200f4 <TCPIP_DHCP_IsServerDetected+0x38>)
   200d6:	6814      	ldr	r4, [r2, #0]
   200d8:	b154      	cbz	r4, 200f0 <TCPIP_DHCP_IsServerDetected+0x34>
   200da:	4618      	mov	r0, r3
        return (DHCPClients + TCPIP_STACK_NetIxGet(pNetIf))->flags.bDHCPServerDetected;
   200dc:	f003 ff2c 	bl	23f38 <TCPIP_STACK_NetIxGet>
   200e0:	235c      	movs	r3, #92	; 0x5c
   200e2:	fb03 4000 	mla	r0, r3, r0, r4
   200e6:	f890 0058 	ldrb.w	r0, [r0, #88]	; 0x58
   200ea:	f3c0 00c0 	ubfx	r0, r0, #3, #1
}
   200ee:	bd10      	pop	{r4, pc}
    return false;
   200f0:	2000      	movs	r0, #0
   200f2:	e7fc      	b.n	200ee <TCPIP_DHCP_IsServerDetected+0x32>
   200f4:	2000ee3c 	.word	0x2000ee3c

Disassembly of section .text.TCPIP_STACK_AddressServiceSelect%691:

000200f8 <TCPIP_STACK_AddressServiceSelect>:
    pNetIf->Flags.v &= ~TCPIP_STACK_ADDRESS_SERVICE_MASK;
   200f8:	f8b0 3042 	ldrh.w	r3, [r0, #66]	; 0x42
   200fc:	f023 0307 	bic.w	r3, r3, #7
   20100:	f8a0 3042 	strh.w	r3, [r0, #66]	; 0x42
    if((configFlags & TCPIP_NETWORK_CONFIG_DHCP_CLIENT_ON) != 0 )
   20104:	f011 0f01 	tst.w	r1, #1
   20108:	d104      	bne.n	20114 <TCPIP_STACK_AddressServiceSelect+0x1c>
    if((configFlags & TCPIP_NETWORK_CONFIG_DHCP_SERVER_ON) != 0 )
   2010a:	f011 0f04 	tst.w	r1, #4
   2010e:	d109      	bne.n	20124 <TCPIP_STACK_AddressServiceSelect+0x2c>
    return TCPIP_STACK_ADDRESS_SERVICE_NONE;
   20110:	2000      	movs	r0, #0
}
   20112:	4770      	bx	lr
        pNetIf->Flags.bIsDHCPEnabled = 1;
   20114:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   20118:	f043 0301 	orr.w	r3, r3, #1
   2011c:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
        return TCPIP_STACK_ADDRESS_SERVICE_DHCPC;
   20120:	2001      	movs	r0, #1
   20122:	4770      	bx	lr
        pNetIf->Flags.bIsDHCPSrvEnabled = 1;
   20124:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   20128:	f043 0304 	orr.w	r3, r3, #4
   2012c:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
        return TCPIP_STACK_ADDRESS_SERVICE_DHCPS;
   20130:	2003      	movs	r0, #3
   20132:	4770      	bx	lr

Disassembly of section .text._TCPIPStackModuleSignalGet%692:

00020134 <_TCPIPStackModuleSignalGet>:
{
   20134:	b570      	push	{r4, r5, r6, lr}
   20136:	460e      	mov	r6, r1
    TCPIP_MODULE_SIGNAL_ENTRY* pSignalEntry = TCPIP_STACK_MODULE_SIGNAL_TBL + modId;
   20138:	4c0b      	ldr	r4, [pc, #44]	; (20168 <_TCPIPStackModuleSignalGet+0x34>)
   2013a:	eb04 1400 	add.w	r4, r4, r0, lsl #4
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   2013e:	2000      	movs	r0, #0
   20140:	f003 fb18 	bl	23774 <OSAL_CRIT_Enter>
   20144:	4601      	mov	r1, r0
    TCPIP_MODULE_SIGNAL modSignal = pSignalEntry->signalVal;
   20146:	8925      	ldrh	r5, [r4, #8]
    pSignalEntry->signalVal &= (uint16_t)(~clrMask);
   20148:	ea25 0306 	bic.w	r3, r5, r6
   2014c:	8123      	strh	r3, [r4, #8]
    if((clrMask & TCPIP_MODULE_SIGNAL_ASYNC) != 0)
   2014e:	f416 7f80 	tst.w	r6, #256	; 0x100
   20152:	d003      	beq.n	2015c <_TCPIPStackModuleSignalGet+0x28>
        stackAsyncSignalCount -= 1; 
   20154:	4a05      	ldr	r2, [pc, #20]	; (2016c <_TCPIPStackModuleSignalGet+0x38>)
   20156:	6813      	ldr	r3, [r2, #0]
   20158:	3b01      	subs	r3, #1
   2015a:	6013      	str	r3, [r2, #0]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   2015c:	2000      	movs	r0, #0
   2015e:	f003 fc43 	bl	239e8 <OSAL_CRIT_Leave>
}
   20162:	4628      	mov	r0, r5
   20164:	bd70      	pop	{r4, r5, r6, pc}
   20166:	bf00      	nop
   20168:	2000d9a4 	.word	0x2000d9a4
   2016c:	2000ee68 	.word	0x2000ee68

Disassembly of section .text._TCPIP_PKT_PacketFree%693:

00020170 <_TCPIP_PKT_PacketFree>:
}

// frees a previously allocated packet
void _TCPIP_PKT_PacketFree(TCPIP_MAC_PACKET* pPkt)
{
    if((pPkt->pktFlags & TCPIP_MAC_PKT_FLAG_STATIC) == 0)
   20170:	8c43      	ldrh	r3, [r0, #34]	; 0x22
   20172:	f013 0f01 	tst.w	r3, #1
   20176:	d116      	bne.n	201a6 <_TCPIP_PKT_PacketFree+0x36>
{
   20178:	b570      	push	{r4, r5, r6, lr}
   2017a:	4605      	mov	r5, r0
    {   // we don't deallocate static packets
        TCPIP_MAC_DATA_SEGMENT  *pSeg, *pNSeg;

        for( pSeg = pPkt->pDSeg; pSeg != 0; pSeg = pNSeg )
   2017c:	6901      	ldr	r1, [r0, #16]
   2017e:	b161      	cbz	r1, 2019a <_TCPIP_PKT_PacketFree+0x2a>
        {
            pNSeg = pSeg->next;
            if((pSeg->segFlags & TCPIP_MAC_SEG_FLAG_STATIC) == 0)
            {
                TCPIP_HEAP_Free(pktMemH, pSeg);
   20180:	4e09      	ldr	r6, [pc, #36]	; (201a8 <_TCPIP_PKT_PacketFree+0x38>)
   20182:	e001      	b.n	20188 <_TCPIP_PKT_PacketFree+0x18>
   20184:	4621      	mov	r1, r4
        for( pSeg = pPkt->pDSeg; pSeg != 0; pSeg = pNSeg )
   20186:	b144      	cbz	r4, 2019a <_TCPIP_PKT_PacketFree+0x2a>
            pNSeg = pSeg->next;
   20188:	680c      	ldr	r4, [r1, #0]
            if((pSeg->segFlags & TCPIP_MAC_SEG_FLAG_STATIC) == 0)
   2018a:	8a0b      	ldrh	r3, [r1, #16]
   2018c:	f013 0f01 	tst.w	r3, #1
   20190:	d1f8      	bne.n	20184 <_TCPIP_PKT_PacketFree+0x14>
                TCPIP_HEAP_Free(pktMemH, pSeg);
   20192:	6830      	ldr	r0, [r6, #0]
   20194:	68c3      	ldr	r3, [r0, #12]
   20196:	4798      	blx	r3
   20198:	e7f4      	b.n	20184 <_TCPIP_PKT_PacketFree+0x14>
            }
        }

        TCPIP_HEAP_Free(pktMemH, pPkt);
   2019a:	4b03      	ldr	r3, [pc, #12]	; (201a8 <_TCPIP_PKT_PacketFree+0x38>)
   2019c:	6818      	ldr	r0, [r3, #0]
   2019e:	68c3      	ldr	r3, [r0, #12]
   201a0:	4629      	mov	r1, r5
   201a2:	4798      	blx	r3
    }
}
   201a4:	bd70      	pop	{r4, r5, r6, pc}
   201a6:	4770      	bx	lr
   201a8:	2000ee84 	.word	0x2000ee84

Disassembly of section .text.TCPIP_UDP_OpenClientSkt%694:

000201ac <TCPIP_UDP_OpenClientSkt>:
    if(addType == IP_ADDRESS_TYPE_IPV6)
   201ac:	2802      	cmp	r0, #2
   201ae:	d015      	beq.n	201dc <TCPIP_UDP_OpenClientSkt+0x30>
{
   201b0:	b508      	push	{r3, lr}
   201b2:	4618      	mov	r0, r3
   201b4:	4613      	mov	r3, r2
   201b6:	460a      	mov	r2, r1
    skt = _UDPOpen(addType, opType, remotePort, remoteAddress);
   201b8:	4601      	mov	r1, r0
   201ba:	2001      	movs	r0, #1
   201bc:	f7f2 fd3c 	bl	12c38 <_UDPOpen>
    if(skt != INVALID_UDP_SOCKET)
   201c0:	f1b0 3fff 	cmp.w	r0, #4294967295
   201c4:	d009      	beq.n	201da <TCPIP_UDP_OpenClientSkt+0x2e>
        UDP_SOCKET_DCPT* pSkt = UDPSocketDcpt[skt];
   201c6:	4b07      	ldr	r3, [pc, #28]	; (201e4 <TCPIP_UDP_OpenClientSkt+0x38>)
   201c8:	681b      	ldr	r3, [r3, #0]
   201ca:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
    pSkt->extFlags.rxEnable = 1;
   201ce:	f892 3042 	ldrb.w	r3, [r2, #66]	; 0x42
   201d2:	f043 0302 	orr.w	r3, r3, #2
   201d6:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
}
   201da:	bd08      	pop	{r3, pc}
        return INVALID_SOCKET; 
   201dc:	f04f 30ff 	mov.w	r0, #4294967295
}
   201e0:	4770      	bx	lr
   201e2:	bf00      	nop
   201e4:	2000ee88 	.word	0x2000ee88

Disassembly of section .text.Console_UART_Read%695:

000201e8 <Console_UART_Read>:
    pConsoleUartData->status = SYS_CONSOLE_STATUS_CONFIGURED;
}

/* Read out the data from the RX Ring Buffer */
ssize_t Console_UART_Read(uint32_t index, void* pRdBuffer, size_t count)
{
   201e8:	b570      	push	{r4, r5, r6, lr}
    ssize_t nBytesRead = 0;
    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   201ea:	b990      	cbnz	r0, 20212 <Console_UART_Read+0x2a>
   201ec:	4615      	mov	r5, r2
   201ee:	460c      	mov	r4, r1
    if (pConsoleUartData == NULL)
    {
        return -1;
    }

    if (Console_UART_ResourceLock(pConsoleUartData) == false)
   201f0:	480b      	ldr	r0, [pc, #44]	; (20220 <Console_UART_Read+0x38>)
   201f2:	f003 fcc7 	bl	23b84 <Console_UART_ResourceLock>
   201f6:	b178      	cbz	r0, 20218 <Console_UART_Read+0x30>
    {
        return -1;
    }

    nBytesRead = pConsoleUartData->uartPLIB->read(pRdBuffer, count);
   201f8:	4e09      	ldr	r6, [pc, #36]	; (20220 <Console_UART_Read+0x38>)
   201fa:	f856 3b08 	ldr.w	r3, [r6], #8
   201fe:	681b      	ldr	r3, [r3, #0]
   20200:	4629      	mov	r1, r5
   20202:	4620      	mov	r0, r4
   20204:	4798      	blx	r3
   20206:	4604      	mov	r4, r0
    OSAL_MUTEX_Unlock(&(pConsoleUartData->mutexTransferObjects));
   20208:	4630      	mov	r0, r6
   2020a:	f003 fad7 	bl	237bc <OSAL_MUTEX_Unlock>

    Console_UART_ResourceUnlock(pConsoleUartData);

    return nBytesRead;
}
   2020e:	4620      	mov	r0, r4
   20210:	bd70      	pop	{r4, r5, r6, pc}
        return -1;
   20212:	f04f 34ff 	mov.w	r4, #4294967295
   20216:	e7fa      	b.n	2020e <Console_UART_Read+0x26>
        return -1;
   20218:	f04f 34ff 	mov.w	r4, #4294967295
   2021c:	e7f7      	b.n	2020e <Console_UART_Read+0x26>
   2021e:	bf00      	nop
   20220:	2000ed58 	.word	0x2000ed58

Disassembly of section .text.Console_UART_Write%696:

00020224 <Console_UART_Write>:

    return nFreeBufferAvailable;
}

ssize_t Console_UART_Write(uint32_t index, const void* pWrBuffer, size_t count )
{
   20224:	b570      	push	{r4, r5, r6, lr}
    ssize_t nBytesWritten = 0;

    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   20226:	b990      	cbnz	r0, 2024e <Console_UART_Write+0x2a>
   20228:	4615      	mov	r5, r2
   2022a:	460c      	mov	r4, r1
    if (pConsoleUartData == NULL)
    {
        return -1;
    }

    if (Console_UART_ResourceLock(pConsoleUartData) == false)
   2022c:	480b      	ldr	r0, [pc, #44]	; (2025c <Console_UART_Write+0x38>)
   2022e:	f003 fca9 	bl	23b84 <Console_UART_ResourceLock>
   20232:	b178      	cbz	r0, 20254 <Console_UART_Write+0x30>
    {
        return -1;
    }

    nBytesWritten = pConsoleUartData->uartPLIB->write((uint8_t*)pWrBuffer, count);
   20234:	4e09      	ldr	r6, [pc, #36]	; (2025c <Console_UART_Write+0x38>)
   20236:	f856 3b08 	ldr.w	r3, [r6], #8
   2023a:	68db      	ldr	r3, [r3, #12]
   2023c:	4629      	mov	r1, r5
   2023e:	4620      	mov	r0, r4
   20240:	4798      	blx	r3
   20242:	4604      	mov	r4, r0
    OSAL_MUTEX_Unlock(&(pConsoleUartData->mutexTransferObjects));
   20244:	4630      	mov	r0, r6
   20246:	f003 fab9 	bl	237bc <OSAL_MUTEX_Unlock>

    Console_UART_ResourceUnlock(pConsoleUartData);

    return nBytesWritten;
}
   2024a:	4620      	mov	r0, r4
   2024c:	bd70      	pop	{r4, r5, r6, pc}
        return -1;
   2024e:	f04f 34ff 	mov.w	r4, #4294967295
   20252:	e7fa      	b.n	2024a <Console_UART_Write+0x26>
        return -1;
   20254:	f04f 34ff 	mov.w	r4, #4294967295
   20258:	e7f7      	b.n	2024a <Console_UART_Write+0x26>
   2025a:	bf00      	nop
   2025c:	2000ed58 	.word	0x2000ed58

Disassembly of section .text.SYS_TIME_GetTimerObject%697:

00020260 <SYS_TIME_GetTimerObject>:
    if ((handle != SYS_TIME_HANDLE_INVALID) && (handle != 0))
   20260:	1e43      	subs	r3, r0, #1
   20262:	f113 0f03 	cmn.w	r3, #3
   20266:	d80f      	bhi.n	20288 <SYS_TIME_GetTimerObject+0x28>
        if ((handle & _SYS_TIME_INDEX_MASK) < SYS_TIME_MAX_TIMERS)
   20268:	b283      	uxth	r3, r0
   2026a:	2b04      	cmp	r3, #4
   2026c:	d80e      	bhi.n	2028c <SYS_TIME_GetTimerObject+0x2c>
            if ((timerObj->tmrHandle == handle) && (timerObj->inUse == true))
   2026e:	4a0a      	ldr	r2, [pc, #40]	; (20298 <SYS_TIME_GetTimerObject+0x38>)
   20270:	eb02 1243 	add.w	r2, r2, r3, lsl #5
   20274:	69d2      	ldr	r2, [r2, #28]
   20276:	4282      	cmp	r2, r0
   20278:	d10a      	bne.n	20290 <SYS_TIME_GetTimerObject+0x30>
   2027a:	015a      	lsls	r2, r3, #5
   2027c:	4906      	ldr	r1, [pc, #24]	; (20298 <SYS_TIME_GetTimerObject+0x38>)
   2027e:	5c8a      	ldrb	r2, [r1, r2]
   20280:	b142      	cbz	r2, 20294 <SYS_TIME_GetTimerObject+0x34>
            timerObj = &timers[handle & _SYS_TIME_INDEX_MASK];
   20282:	eb01 1043 	add.w	r0, r1, r3, lsl #5
                return timerObj;
   20286:	4770      	bx	lr
    return NULL;
   20288:	2000      	movs	r0, #0
   2028a:	4770      	bx	lr
   2028c:	2000      	movs	r0, #0
   2028e:	4770      	bx	lr
   20290:	2000      	movs	r0, #0
   20292:	4770      	bx	lr
   20294:	2000      	movs	r0, #0
}
   20296:	4770      	bx	lr
   20298:	2000e520 	.word	0x2000e520

Disassembly of section .text.SYS_TIME_ResourceUnlock%698:

0002029c <SYS_TIME_ResourceUnlock>:
{
   2029c:	b508      	push	{r3, lr}
    SYS_INT_SourceEnable(gSystemCounterObj.hwTimerIntNum);
   2029e:	4b0b      	ldr	r3, [pc, #44]	; (202cc <SYS_TIME_ResourceUnlock+0x30>)
   202a0:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
  if ((int32_t)(IRQn) >= 0)
   202a4:	2b00      	cmp	r3, #0
   202a6:	db08      	blt.n	202ba <SYS_TIME_ResourceUnlock+0x1e>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   202a8:	0959      	lsrs	r1, r3, #5
   202aa:	f003 031f 	and.w	r3, r3, #31
   202ae:	2201      	movs	r2, #1
   202b0:	fa02 f303 	lsl.w	r3, r2, r3
   202b4:	4a06      	ldr	r2, [pc, #24]	; (202d0 <SYS_TIME_ResourceUnlock+0x34>)
   202b6:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    if(gSystemCounterObj.interruptNestingCount == 0)
   202ba:	4b04      	ldr	r3, [pc, #16]	; (202cc <SYS_TIME_ResourceUnlock+0x30>)
   202bc:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   202c0:	b103      	cbz	r3, 202c4 <SYS_TIME_ResourceUnlock+0x28>
}
   202c2:	bd08      	pop	{r3, pc}
        OSAL_MUTEX_Unlock(&gSystemCounterObj.timerMutex);
   202c4:	4803      	ldr	r0, [pc, #12]	; (202d4 <SYS_TIME_ResourceUnlock+0x38>)
   202c6:	f003 fa79 	bl	237bc <OSAL_MUTEX_Unlock>
}
   202ca:	e7fa      	b.n	202c2 <SYS_TIME_ResourceUnlock+0x26>
   202cc:	2000ea00 	.word	0x2000ea00
   202d0:	e000e100 	.word	0xe000e100
   202d4:	2000ea34 	.word	0x2000ea34

Disassembly of section .text.SYS_TIME_Counter64Get%699:

000202d8 <SYS_TIME_Counter64Get>:
{
   202d8:	b538      	push	{r3, r4, r5, lr}
    if (SYS_TIME_ResourceLock() == false)
   202da:	f000 faaf 	bl	2083c <SYS_TIME_ResourceLock>
   202de:	b1a0      	cbz	r0, 2030a <SYS_TIME_Counter64Get+0x32>
    elapsedCount = SYS_TIME_GetElapsedCount(counterObj->timePlib->timerCounterGet());
   202e0:	4c0b      	ldr	r4, [pc, #44]	; (20310 <SYS_TIME_Counter64Get+0x38>)
   202e2:	6863      	ldr	r3, [r4, #4]
   202e4:	699b      	ldr	r3, [r3, #24]
   202e6:	4798      	blx	r3
   202e8:	f002 ff9e 	bl	23228 <SYS_TIME_GetElapsedCount>
    uint32_t prevSwCounter32Bit = counterObj->swCounter64Low;
   202ec:	6a63      	ldr	r3, [r4, #36]	; 0x24
    counter64 = counterObj->swCounter64High;
   202ee:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    if (isSwCounter32Oveflow == true)
   202f0:	18c0      	adds	r0, r0, r3
   202f2:	d208      	bcs.n	20306 <SYS_TIME_Counter64Get+0x2e>
    counter64 = ((counter64 << 32) + counter32);
   202f4:	2200      	movs	r2, #0
   202f6:	1814      	adds	r4, r2, r0
   202f8:	f141 0500 	adc.w	r5, r1, #0
    SYS_TIME_ResourceUnlock();
   202fc:	f7ff ffce 	bl	2029c <SYS_TIME_ResourceUnlock>
}
   20300:	4620      	mov	r0, r4
   20302:	4629      	mov	r1, r5
   20304:	bd38      	pop	{r3, r4, r5, pc}
        counter64++;
   20306:	3101      	adds	r1, #1
   20308:	e7f4      	b.n	202f4 <SYS_TIME_Counter64Get+0x1c>
        return counter64;
   2030a:	2400      	movs	r4, #0
   2030c:	2500      	movs	r5, #0
   2030e:	e7f7      	b.n	20300 <SYS_TIME_Counter64Get+0x28>
   20310:	2000ea00 	.word	0x2000ea00

Disassembly of section .text.SYS_TIME_TimerDestroy%700:

00020314 <SYS_TIME_TimerDestroy>:
{
   20314:	b510      	push	{r4, lr}
   20316:	4604      	mov	r4, r0
    if (SYS_TIME_ResourceLock() == false)
   20318:	f000 fa90 	bl	2083c <SYS_TIME_ResourceLock>
   2031c:	b1b0      	cbz	r0, 2034c <SYS_TIME_TimerDestroy+0x38>
    tmr = SYS_TIME_GetTimerObject(handle);
   2031e:	4620      	mov	r0, r4
   20320:	f7ff ff9e 	bl	20260 <SYS_TIME_GetTimerObject>
    if(tmr != NULL)
   20324:	4604      	mov	r4, r0
   20326:	b178      	cbz	r0, 20348 <SYS_TIME_TimerDestroy+0x34>
        if(tmr->active == true)
   20328:	7843      	ldrb	r3, [r0, #1]
   2032a:	b943      	cbnz	r3, 2033e <SYS_TIME_TimerDestroy+0x2a>
        tmr->tmrElapsedFlag = false;
   2032c:	2000      	movs	r0, #0
   2032e:	7520      	strb	r0, [r4, #20]
        tmr->tmrElapsed = false;
   20330:	7560      	strb	r0, [r4, #21]
        tmr->inUse = false;
   20332:	7020      	strb	r0, [r4, #0]
        result = SYS_TIME_SUCCESS;
   20334:	4604      	mov	r4, r0
    SYS_TIME_ResourceUnlock();
   20336:	f7ff ffb1 	bl	2029c <SYS_TIME_ResourceUnlock>
}
   2033a:	4620      	mov	r0, r4
   2033c:	bd10      	pop	{r4, pc}
            SYS_TIME_RemoveFromList(tmr);
   2033e:	f7fd f9d1 	bl	1d6e4 <SYS_TIME_RemoveFromList>
            tmr->active = false;
   20342:	2300      	movs	r3, #0
   20344:	7063      	strb	r3, [r4, #1]
   20346:	e7f1      	b.n	2032c <SYS_TIME_TimerDestroy+0x18>
    SYS_TIME_RESULT result = SYS_TIME_ERROR;
   20348:	2401      	movs	r4, #1
   2034a:	e7f4      	b.n	20336 <SYS_TIME_TimerDestroy+0x22>
        return result;
   2034c:	2401      	movs	r4, #1
   2034e:	e7f4      	b.n	2033a <SYS_TIME_TimerDestroy+0x26>

Disassembly of section .text.wc_InitMd5_ex%701:

00020350 <wc_InitMd5_ex>:
    if (md5 == NULL)
   20350:	4603      	mov	r3, r0
   20352:	b1a8      	cbz	r0, 20380 <wc_InitMd5_ex+0x30>
    md5->heap = heap;
   20354:	65c1      	str	r1, [r0, #92]	; 0x5c
    md5->digest[0] = 0x67452301L;
   20356:	4a0c      	ldr	r2, [pc, #48]	; (20388 <wc_InitMd5_ex+0x38>)
   20358:	64c2      	str	r2, [r0, #76]	; 0x4c
    md5->digest[1] = 0xefcdab89L;
   2035a:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
   2035e:	6502      	str	r2, [r0, #80]	; 0x50
    md5->digest[2] = 0x98badcfeL;
   20360:	f102 4229 	add.w	r2, r2, #2835349504	; 0xa9000000
   20364:	f5a2 1296 	sub.w	r2, r2, #1228800	; 0x12c000
   20368:	f6a2 628b 	subw	r2, r2, #3723	; 0xe8b
   2036c:	6542      	str	r2, [r0, #84]	; 0x54
    md5->digest[3] = 0x10325476L;
   2036e:	f1a2 3288 	sub.w	r2, r2, #2290649224	; 0x88888888
   20372:	6582      	str	r2, [r0, #88]	; 0x58
    md5->buffLen = 0;
   20374:	2000      	movs	r0, #0
   20376:	6018      	str	r0, [r3, #0]
    md5->loLen   = 0;
   20378:	6058      	str	r0, [r3, #4]
    md5->hiLen   = 0;
   2037a:	6098      	str	r0, [r3, #8]
    md5->flags = 0;
   2037c:	6618      	str	r0, [r3, #96]	; 0x60
    if (ret != 0)
   2037e:	4770      	bx	lr
        return BAD_FUNC_ARG;
   20380:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
   20384:	4770      	bx	lr
   20386:	bf00      	nop
   20388:	67452301 	.word	0x67452301

Disassembly of section .text.__assert_func%702:

0002038c <__assert_func>:
   2038c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   2038e:	461c      	mov	r4, r3
   20390:	4b09      	ldr	r3, [pc, #36]	; (203b8 <__assert_func+0x2c>)
   20392:	681b      	ldr	r3, [r3, #0]
   20394:	4605      	mov	r5, r0
   20396:	68d8      	ldr	r0, [r3, #12]
   20398:	b152      	cbz	r2, 203b0 <__assert_func+0x24>
   2039a:	4b08      	ldr	r3, [pc, #32]	; (203bc <__assert_func+0x30>)
   2039c:	9100      	str	r1, [sp, #0]
   2039e:	e9cd 3201 	strd	r3, r2, [sp, #4]
   203a2:	4907      	ldr	r1, [pc, #28]	; (203c0 <__assert_func+0x34>)
   203a4:	462b      	mov	r3, r5
   203a6:	4622      	mov	r2, r4
   203a8:	f002 f9f2 	bl	22790 <fiprintf>
   203ac:	f003 fde0 	bl	23f70 <abort>
   203b0:	4b04      	ldr	r3, [pc, #16]	; (203c4 <__assert_func+0x38>)
   203b2:	461a      	mov	r2, r3
   203b4:	e7f2      	b.n	2039c <__assert_func+0x10>
   203b6:	bf00      	nop
   203b8:	2000ef60 	.word	0x2000ef60
   203bc:	0001fe9d 	.word	0x0001fe9d
   203c0:	0001feaa 	.word	0x0001feaa
   203c4:	0001fe9c 	.word	0x0001fe9c

Disassembly of section .text._fwalk_reent%703:

000203c8 <_fwalk_reent>:
   203c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   203cc:	4680      	mov	r8, r0
   203ce:	4689      	mov	r9, r1
   203d0:	f100 0448 	add.w	r4, r0, #72	; 0x48
   203d4:	2600      	movs	r6, #0
   203d6:	b914      	cbnz	r4, 203de <_fwalk_reent+0x16>
   203d8:	4630      	mov	r0, r6
   203da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   203de:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
   203e2:	3f01      	subs	r7, #1
   203e4:	d501      	bpl.n	203ea <_fwalk_reent+0x22>
   203e6:	6824      	ldr	r4, [r4, #0]
   203e8:	e7f5      	b.n	203d6 <_fwalk_reent+0xe>
   203ea:	89ab      	ldrh	r3, [r5, #12]
   203ec:	2b01      	cmp	r3, #1
   203ee:	d907      	bls.n	20400 <_fwalk_reent+0x38>
   203f0:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
   203f4:	3301      	adds	r3, #1
   203f6:	d003      	beq.n	20400 <_fwalk_reent+0x38>
   203f8:	4629      	mov	r1, r5
   203fa:	4640      	mov	r0, r8
   203fc:	47c8      	blx	r9
   203fe:	4306      	orrs	r6, r0
   20400:	3564      	adds	r5, #100	; 0x64
   20402:	e7ee      	b.n	203e2 <_fwalk_reent+0x1a>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase1%704:

00020404 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase1>:
{
   20404:	b510      	push	{r4, lr}
   20406:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   20408:	f002 fa64 	bl	228d4 <_DRV_PHY_SMITransfer_Wait>
   2040c:	b180      	cbz	r0, 20430 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase1+0x2c>
    matchCpbl = (hClientObj->operReg[0] & (MAC_COMM_CPBL_MASK | _BMSTAT_AN_ABLE_MASK)) & phyCpbl; // common features
   2040e:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   20410:	8f62      	ldrh	r2, [r4, #58]	; 0x3a
   20412:	4013      	ands	r3, r2
    if(!(matchCpbl & MAC_COMM_CPBL_MASK))
   20414:	f413 4ff0 	tst.w	r3, #30720	; 0x7800
   20418:	d00b      	beq.n	20432 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase1+0x2e>
    matchCpbl = (hClientObj->operReg[0] & (MAC_COMM_CPBL_MASK | _BMSTAT_AN_ABLE_MASK)) & phyCpbl; // common features
   2041a:	f423 4307 	bic.w	r3, r3, #34560	; 0x8700
   2041e:	f023 03f7 	bic.w	r3, r3, #247	; 0xf7
    hClientObj->operReg[1] = matchCpbl;
   20422:	84a3      	strh	r3, [r4, #36]	; 0x24
    hClientObj->vendorData = 0;
   20424:	2300      	movs	r3, #0
   20426:	6423      	str	r3, [r4, #64]	; 0x40
    hClientObj->operPhase = operPhase;
   20428:	2303      	movs	r3, #3
   2042a:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   2042c:	2302      	movs	r3, #2
   2042e:	8423      	strh	r3, [r4, #32]
}
   20430:	bd10      	pop	{r4, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_CPBL_ERR);
   20432:	f06f 0102 	mvn.w	r1, #2
   20436:	4620      	mov	r0, r4
   20438:	f001 fcf8 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
        return;
   2043c:	e7f8      	b.n	20430 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase1+0x2c>

Disassembly of section .text._DRV_ETHPHY_NegRestartPhaseRead%705:

0002043e <_DRV_ETHPHY_NegRestartPhaseRead>:
{
   2043e:	b510      	push	{r4, lr}
   20440:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   20442:	f002 fa47 	bl	228d4 <_DRV_PHY_SMITransfer_Wait>
   20446:	b158      	cbz	r0, 20460 <_DRV_ETHPHY_NegRestartPhaseRead+0x22>
    if(phyCpbl.AN_ABLE == 0)
   20448:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
   2044c:	f013 0f08 	tst.w	r3, #8
   20450:	d007      	beq.n	20462 <_DRV_ETHPHY_NegRestartPhaseRead+0x24>
    if(_DRV_PHY_SMIWriteStart(hClientObj, PHY_REG_BMCON, _BMCON_AN_ENABLE_MASK | _BMCON_AN_RESTART_MASK ))
   20452:	f44f 5290 	mov.w	r2, #4608	; 0x1200
   20456:	2100      	movs	r1, #0
   20458:	4620      	mov	r0, r4
   2045a:	f000 fda2 	bl	20fa2 <_DRV_PHY_SMIWriteStart>
   2045e:	b930      	cbnz	r0, 2046e <_DRV_ETHPHY_NegRestartPhaseRead+0x30>
}
   20460:	bd10      	pop	{r4, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_NEGOTIATION_UNABLE);
   20462:	f06f 0105 	mvn.w	r1, #5
   20466:	4620      	mov	r0, r4
   20468:	f001 fce0 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
        return;
   2046c:	e7f8      	b.n	20460 <_DRV_ETHPHY_NegRestartPhaseRead+0x22>
    hClientObj->operPhase = operPhase;
   2046e:	2302      	movs	r3, #2
   20470:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   20472:	2300      	movs	r3, #0
   20474:	8423      	strh	r3, [r4, #32]
   20476:	e7f3      	b.n	20460 <_DRV_ETHPHY_NegRestartPhaseRead+0x22>

Disassembly of section .text._DRV_MIIM_ReleaseOpDcpt%706:

00020478 <_DRV_MIIM_ReleaseOpDcpt>:
{
   20478:	b570      	push	{r4, r5, r6, lr}
   2047a:	4605      	mov	r5, r0
   2047c:	460c      	mov	r4, r1
    pRemNode =  (DRV_MIIM_OP_DCPT*)Helper_SingleListNodeRemove(pRemList, (SGL_LIST_NODE*)pOpDcpt);
   2047e:	4610      	mov	r0, r2
   20480:	f7fe ff52 	bl	1f328 <Helper_SingleListNodeRemove>
    if(pRemNode == pOpDcpt)
   20484:	4284      	cmp	r4, r0
   20486:	d000      	beq.n	2048a <_DRV_MIIM_ReleaseOpDcpt+0x12>
}
   20488:	bd70      	pop	{r4, r5, r6, pc}
        wasScan = pOpDcpt->opType == DRV_MIIM_OP_SCAN; 
   2048a:	7926      	ldrb	r6, [r4, #4]
        memset(pOpDcpt, 0, sizeof(*pOpDcpt));
   2048c:	2300      	movs	r3, #0
   2048e:	6023      	str	r3, [r4, #0]
   20490:	6063      	str	r3, [r4, #4]
   20492:	60a3      	str	r3, [r4, #8]
   20494:	60e3      	str	r3, [r4, #12]
    Helper_SingleListTailAdd(pL, (SGL_LIST_NODE*)pOpDcpt);
   20496:	4621      	mov	r1, r4
   20498:	f105 0070 	add.w	r0, r5, #112	; 0x70
   2049c:	f002 ff6b 	bl	23376 <Helper_SingleListTailAdd>
    pOpDcpt->qType = qType;
   204a0:	2301      	movs	r3, #1
   204a2:	72e3      	strb	r3, [r4, #11]
    if(wasScan)
   204a4:	2e03      	cmp	r6, #3
   204a6:	d1ef      	bne.n	20488 <_DRV_MIIM_ReleaseOpDcpt+0x10>
        pMiimObj->objFlags &= ~DRV_MIIM_OBJ_FLAG_IS_SCANNING;
   204a8:	88ab      	ldrh	r3, [r5, #4]
   204aa:	f023 0308 	bic.w	r3, r3, #8
   204ae:	80ab      	strh	r3, [r5, #4]
}
   204b0:	e7ea      	b.n	20488 <_DRV_MIIM_ReleaseOpDcpt+0x10>

Disassembly of section .text.DRV_MIIM_Deinitialize%707:

000204b2 <DRV_MIIM_Deinitialize>:
{
   204b2:	b510      	push	{r4, lr}
    DRV_MIIM_OBJ* pMiimObj = _DRV_MIIM_GetObjectAndLock(hSysObj);
   204b4:	f001 f8c1 	bl	2163a <_DRV_MIIM_GetObjectAndLock>
    if(pMiimObj != 0)
   204b8:	b188      	cbz	r0, 204de <DRV_MIIM_Deinitialize+0x2c>
   204ba:	4604      	mov	r4, r0
        pClient = pMiimObj->objClients;
   204bc:	3010      	adds	r0, #16
            if(pClient->clientInUse != 0)
   204be:	8a23      	ldrh	r3, [r4, #16]
   204c0:	b973      	cbnz	r3, 204e0 <DRV_MIIM_Deinitialize+0x2e>
        for(ix = 0; ix < sizeof(pMiimObj->objClients) / sizeof(*pMiimObj->objClients); ix++, pClient++)
   204c2:	f104 0020 	add.w	r0, r4, #32
            if(pClient->clientInUse != 0)
   204c6:	8c23      	ldrh	r3, [r4, #32]
   204c8:	b96b      	cbnz	r3, 204e6 <DRV_MIIM_Deinitialize+0x34>
        OSAL_SEM_Delete(&pMiimObj->objSem);
   204ca:	4620      	mov	r0, r4
   204cc:	f003 fbd7 	bl	23c7e <OSAL_SEM_Delete>
        memset(pMiimObj, 0, sizeof(*pMiimObj));
   204d0:	2294      	movs	r2, #148	; 0x94
   204d2:	2100      	movs	r1, #0
   204d4:	4620      	mov	r0, r4
   204d6:	f003 fce3 	bl	23ea0 <memset>
        pMiimObj->objStatus  = SYS_STATUS_UNINITIALIZED;
   204da:	2300      	movs	r3, #0
   204dc:	7223      	strb	r3, [r4, #8]
} 
   204de:	bd10      	pop	{r4, pc}
                _DRV_MIIM_ClientDeallocate(pClient);
   204e0:	f7f7 fbe2 	bl	17ca8 <_DRV_MIIM_ClientDeallocate>
   204e4:	e7ed      	b.n	204c2 <DRV_MIIM_Deinitialize+0x10>
   204e6:	f7f7 fbdf 	bl	17ca8 <_DRV_MIIM_ClientDeallocate>
   204ea:	e7ee      	b.n	204ca <DRV_MIIM_Deinitialize+0x18>

Disassembly of section .text._TCPIP_HEAP_MaxSize%708:

000204ec <_TCPIP_HEAP_MaxSize>:
    }
    return 0;
}

static size_t _TCPIP_HEAP_MaxSize(TCPIP_STACK_HEAP_HANDLE heapH)
{
   204ec:	b538      	push	{r3, r4, r5, lr}
    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   204ee:	b1c0      	cbz	r0, 20522 <_TCPIP_HEAP_MaxSize+0x36>
   204f0:	4604      	mov	r4, r0
    max_nunits = 0;

    hDcpt = _TCPIP_HEAP_ObjDcpt(heapH);
    if(hDcpt)
    {
        OSAL_SEM_Pend(&hDcpt->_heapSemaphore, OSAL_WAIT_FOREVER);
   204f2:	f100 0544 	add.w	r5, r0, #68	; 0x44
   204f6:	f64f 71ff 	movw	r1, #65535	; 0xffff
   204fa:	4628      	mov	r0, r5
   204fc:	f002 fcfa 	bl	22ef4 <OSAL_SEM_Pend>

        for(ptr = hDcpt->_heapHead; ptr != 0; ptr = ptr->next)
   20500:	6a63      	ldr	r3, [r4, #36]	; 0x24
   20502:	b163      	cbz	r3, 2051e <_TCPIP_HEAP_MaxSize+0x32>
    max_nunits = 0;
   20504:	2400      	movs	r4, #0
        {
            if(ptr->units >= max_nunits)
   20506:	685a      	ldr	r2, [r3, #4]
   20508:	4294      	cmp	r4, r2
   2050a:	bf38      	it	cc
   2050c:	4614      	movcc	r4, r2
        for(ptr = hDcpt->_heapHead; ptr != 0; ptr = ptr->next)
   2050e:	681b      	ldr	r3, [r3, #0]
   20510:	2b00      	cmp	r3, #0
   20512:	d1f8      	bne.n	20506 <_TCPIP_HEAP_MaxSize+0x1a>
            {   // found block
                max_nunits = ptr->units;
            }
        }
        OSAL_SEM_Post(&hDcpt->_heapSemaphore);
   20514:	4628      	mov	r0, r5
   20516:	f003 f939 	bl	2378c <OSAL_SEM_Post>
    }

    return max_nunits * sizeof(_headNode);   

}
   2051a:	0120      	lsls	r0, r4, #4
   2051c:	bd38      	pop	{r3, r4, r5, pc}
    max_nunits = 0;
   2051e:	2400      	movs	r4, #0
   20520:	e7f8      	b.n	20514 <_TCPIP_HEAP_MaxSize+0x28>
   20522:	2400      	movs	r4, #0
   20524:	e7f9      	b.n	2051a <_TCPIP_HEAP_MaxSize+0x2e>

Disassembly of section .text._DHCPOptionProcessMsgType%709:

00020526 <_DHCPOptionProcessMsgType>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_MSG_TYPE))
   20526:	684b      	ldr	r3, [r1, #4]
   20528:	2b02      	cmp	r3, #2
   2052a:	d911      	bls.n	20550 <_DHCPOptionProcessMsgType+0x2a>
        TCPIP_DHCP_OPTION_DATA_MSG_TYPE* pMsgType = (TCPIP_DHCP_OPTION_DATA_MSG_TYPE*)pOptData->pOpt;
   2052c:	680b      	ldr	r3, [r1, #0]
        if(pMsgType->len == sizeof(pMsgType->type))
   2052e:	785a      	ldrb	r2, [r3, #1]
   20530:	2a01      	cmp	r2, #1
   20532:	d110      	bne.n	20556 <_DHCPOptionProcessMsgType+0x30>
            pOptData->msgType = pMsgType->type;
   20534:	789b      	ldrb	r3, [r3, #2]
   20536:	608b      	str	r3, [r1, #8]
            if(pOptData->msgType != TCPIP_DHCP_OFFER_MESSAGE || pClient->flags.bOfferReceived == 0)
   20538:	2b02      	cmp	r3, #2
   2053a:	d10f      	bne.n	2055c <_DHCPOptionProcessMsgType+0x36>
   2053c:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   20540:	f003 0304 	and.w	r3, r3, #4
                return sizeof(TCPIP_DHCP_OPTION_DATA_MSG_TYPE);
   20544:	2b00      	cmp	r3, #0
   20546:	bf14      	ite	ne
   20548:	f04f 30ff 	movne.w	r0, #4294967295
   2054c:	2003      	moveq	r0, #3
   2054e:	4770      	bx	lr
    return -1;
   20550:	f04f 30ff 	mov.w	r0, #4294967295
   20554:	4770      	bx	lr
   20556:	f04f 30ff 	mov.w	r0, #4294967295
   2055a:	4770      	bx	lr
                return sizeof(TCPIP_DHCP_OPTION_DATA_MSG_TYPE);
   2055c:	2003      	movs	r0, #3
}
   2055e:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAliasNameGet%710:

00020560 <TCPIP_STACK_NetAliasNameGet>:
{
   20560:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   20562:	460c      	mov	r4, r1
   20564:	4616      	mov	r6, r2
    if(pNetIf)
   20566:	4607      	mov	r7, r0
   20568:	b150      	cbz	r0, 20580 <TCPIP_STACK_NetAliasNameGet+0x20>
        aliasSize = strlen(pNetIf->ifName);
   2056a:	3062      	adds	r0, #98	; 0x62
   2056c:	f003 fca8 	bl	23ec0 <strlen>
   20570:	4605      	mov	r5, r0
    if(nameBuffer && buffSize)
   20572:	b11c      	cbz	r4, 2057c <TCPIP_STACK_NetAliasNameGet+0x1c>
   20574:	b116      	cbz	r6, 2057c <TCPIP_STACK_NetAliasNameGet+0x1c>
        if(aliasSize)
   20576:	b92d      	cbnz	r5, 20584 <TCPIP_STACK_NetAliasNameGet+0x24>
            nameBuffer[0] = 0;
   20578:	2300      	movs	r3, #0
   2057a:	7023      	strb	r3, [r4, #0]
}
   2057c:	4628      	mov	r0, r5
   2057e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        aliasSize = 0;
   20580:	2500      	movs	r5, #0
   20582:	e7f6      	b.n	20572 <TCPIP_STACK_NetAliasNameGet+0x12>
            strncpy(nameBuffer, pNetIf->ifName, buffSize - 1);
   20584:	1e72      	subs	r2, r6, #1
   20586:	f107 0162 	add.w	r1, r7, #98	; 0x62
   2058a:	4620      	mov	r0, r4
   2058c:	f001 ff90 	bl	224b0 <strncpy>
            nameBuffer[buffSize - 1] = 0;
   20590:	4434      	add	r4, r6
   20592:	2300      	movs	r3, #0
   20594:	f804 3c01 	strb.w	r3, [r4, #-1]
   20598:	e7f0      	b.n	2057c <TCPIP_STACK_NetAliasNameGet+0x1c>

Disassembly of section .text._DHCPS_ValidatePktReceivedIntf%711:

0002059a <_DHCPS_ValidatePktReceivedIntf>:
{
   2059a:	b538      	push	{r3, r4, r5, lr}
   2059c:	4604      	mov	r4, r0
    if(_TCPIPStackHandleToNetLinked(pNetIfFromDcpt) == 0)
   2059e:	f002 fb4f 	bl	22c40 <_TCPIPStackHandleToNetLinked>
   205a2:	b1a8      	cbz	r0, 205d0 <_DHCPS_ValidatePktReceivedIntf+0x36>
    if(_TCPIPStackNetAddress(pNetIfFromDcpt) == 0)
   205a4:	6863      	ldr	r3, [r4, #4]
   205a6:	b913      	cbnz	r3, 205ae <_DHCPS_ValidatePktReceivedIntf+0x14>
        return false;
   205a8:	2500      	movs	r5, #0
}
   205aa:	4628      	mov	r0, r5
   205ac:	bd38      	pop	{r3, r4, r5, pc}
    if(TCPIP_DHCP_IsServerDetected(pNetIfFromDcpt)|| TCPIP_DHCP_IsEnabled(pNetIfFromDcpt))
   205ae:	4620      	mov	r0, r4
   205b0:	f7ff fd84 	bl	200bc <TCPIP_DHCP_IsServerDetected>
   205b4:	4605      	mov	r5, r0
   205b6:	b108      	cbz	r0, 205bc <_DHCPS_ValidatePktReceivedIntf+0x22>
        return false;
   205b8:	2500      	movs	r5, #0
   205ba:	e7f6      	b.n	205aa <_DHCPS_ValidatePktReceivedIntf+0x10>
    if(TCPIP_DHCP_IsServerDetected(pNetIfFromDcpt)|| TCPIP_DHCP_IsEnabled(pNetIfFromDcpt))
   205bc:	4620      	mov	r0, r4
   205be:	f7ff fd5f 	bl	20080 <TCPIP_DHCP_IsEnabled>
   205c2:	2800      	cmp	r0, #0
   205c4:	d1f1      	bne.n	205aa <_DHCPS_ValidatePktReceivedIntf+0x10>
    if(!TCPIP_DHCPS_IsEnabled(pNetIfFromDcpt))
   205c6:	4620      	mov	r0, r4
   205c8:	f002 ff8b 	bl	234e2 <TCPIP_DHCPS_IsEnabled>
   205cc:	4605      	mov	r5, r0
   205ce:	e7ec      	b.n	205aa <_DHCPS_ValidatePktReceivedIntf+0x10>
        return false;
   205d0:	2500      	movs	r5, #0
   205d2:	e7ea      	b.n	205aa <_DHCPS_ValidatePktReceivedIntf+0x10>

Disassembly of section .text.DRV_ETHPHY_HWConfigFlagsGet%712:

000205d4 <DRV_ETHPHY_HWConfigFlagsGet>:
    if(hClientObj != 0)
   205d4:	b168      	cbz	r0, 205f2 <DRV_ETHPHY_HWConfigFlagsGet+0x1e>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   205d6:	68c2      	ldr	r2, [r0, #12]
   205d8:	4b0a      	ldr	r3, [pc, #40]	; (20604 <DRV_ETHPHY_HWConfigFlagsGet+0x30>)
   205da:	429a      	cmp	r2, r3
   205dc:	d10c      	bne.n	205f8 <DRV_ETHPHY_HWConfigFlagsGet+0x24>
            hwFlags = ((GMAC_REGS->GMAC_UR & GMAC_UR_Msk)== DRV_GMAC_RMII_MODE) ?  DRV_ETHPHY_CFG_RMII : DRV_ETHPHY_CFG_MII;
   205de:	4b0a      	ldr	r3, [pc, #40]	; (20608 <DRV_ETHPHY_HWConfigFlagsGet+0x34>)
   205e0:	68db      	ldr	r3, [r3, #12]
            if(pFlags)
   205e2:	b161      	cbz	r1, 205fe <DRV_ETHPHY_HWConfigFlagsGet+0x2a>
            hwFlags = ((GMAC_REGS->GMAC_UR & GMAC_UR_Msk)== DRV_GMAC_RMII_MODE) ?  DRV_ETHPHY_CFG_RMII : DRV_ETHPHY_CFG_MII;
   205e4:	f083 0301 	eor.w	r3, r3, #1
   205e8:	f003 0301 	and.w	r3, r3, #1
                *pFlags = hwFlags;
   205ec:	700b      	strb	r3, [r1, #0]
            return ethRes;
   205ee:	2000      	movs	r0, #0
   205f0:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   205f2:	f06f 000a 	mvn.w	r0, #10
   205f6:	4770      	bx	lr
   205f8:	f06f 000a 	mvn.w	r0, #10
   205fc:	4770      	bx	lr
            return ethRes;
   205fe:	2000      	movs	r0, #0
}
   20600:	4770      	bx	lr
   20602:	bf00      	nop
   20604:	2000e7e8 	.word	0x2000e7e8
   20608:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase6%713:

0002060c <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase6>:
{
   2060c:	b510      	push	{r4, lr}
   2060e:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   20610:	f002 f960 	bl	228d4 <_DRV_PHY_SMITransfer_Wait>
   20614:	b1a8      	cbz	r0, 20642 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase6+0x36>
    if(phyCpbl.AN_ABLE)
   20616:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
   2061a:	f013 0f08 	tst.w	r3, #8
   2061e:	d00b      	beq.n	20638 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase6+0x2c>
        if(_DRV_PHY_SMIWriteStart( hClientObj, PHY_REG_BMCON, _BMCON_AN_ENABLE_MASK | _BMCON_AN_RESTART_MASK ))
   20620:	f44f 5290 	mov.w	r2, #4608	; 0x1200
   20624:	2100      	movs	r1, #0
   20626:	4620      	mov	r0, r4
   20628:	f000 fcbb 	bl	20fa2 <_DRV_PHY_SMIWriteStart>
   2062c:	b148      	cbz	r0, 20642 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase6+0x36>
    hClientObj->operPhase = operPhase;
   2062e:	2303      	movs	r3, #3
   20630:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   20632:	2307      	movs	r3, #7
   20634:	8423      	strh	r3, [r4, #32]
   20636:	e004      	b.n	20642 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase6+0x36>
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_NEGOTIATION_UNABLE);
   20638:	f06f 0105 	mvn.w	r1, #5
   2063c:	4620      	mov	r0, r4
   2063e:	f001 fbf5 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
}
   20642:	bd10      	pop	{r4, pc}

Disassembly of section .text.DRV_GMAC_Open%714:

00020644 <DRV_GMAC_Open>:
    if(macIx >= 0 && macIx < sizeof(_gmac_drv_dcpt)/sizeof(*_gmac_drv_dcpt))
   20644:	f241 0350 	movw	r3, #4176	; 0x1050
   20648:	4298      	cmp	r0, r3
   2064a:	d10c      	bne.n	20666 <DRV_GMAC_Open+0x22>
		if(pMACDrv->sGmacData._macFlags._init == 1)
   2064c:	4b0a      	ldr	r3, [pc, #40]	; (20678 <DRV_GMAC_Open+0x34>)
   2064e:	7d9b      	ldrb	r3, [r3, #22]
   20650:	f013 0f01 	tst.w	r3, #1
   20654:	d00a      	beq.n	2066c <DRV_GMAC_Open+0x28>
			if(pMACDrv->sGmacData._macFlags._open == 0)
   20656:	f013 0f02 	tst.w	r3, #2
   2065a:	d10a      	bne.n	20672 <DRV_GMAC_Open+0x2e>
				pMACDrv->sGmacData._macFlags._open = 1;
   2065c:	4806      	ldr	r0, [pc, #24]	; (20678 <DRV_GMAC_Open+0x34>)
   2065e:	f043 0302 	orr.w	r3, r3, #2
   20662:	7583      	strb	r3, [r0, #22]
				hMac = (DRV_HANDLE)pMACDrv;
   20664:	4770      	bx	lr
    DRV_HANDLE    hMac = DRV_HANDLE_INVALID;
   20666:	f04f 30ff 	mov.w	r0, #4294967295
   2066a:	4770      	bx	lr
   2066c:	f04f 30ff 	mov.w	r0, #4294967295
   20670:	4770      	bx	lr
   20672:	f04f 30ff 	mov.w	r0, #4294967295
}
   20676:	4770      	bx	lr
   20678:	2000e288 	.word	0x2000e288

Disassembly of section .text.DRV_PIC32CGMAC_LibGetMacAddr%715:

0002067c <DRV_PIC32CGMAC_LibGetMacAddr>:
    pMacAddr[0] = (GMAC_REGS->SA[0].GMAC_SAB)& 0xFF;
   2067c:	4b0c      	ldr	r3, [pc, #48]	; (206b0 <DRV_PIC32CGMAC_LibGetMacAddr+0x34>)
   2067e:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   20682:	7002      	strb	r2, [r0, #0]
    pMacAddr[1] = ((GMAC_REGS->SA[0].GMAC_SAB)>>8)& 0xFF;
   20684:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   20688:	0a12      	lsrs	r2, r2, #8
   2068a:	7042      	strb	r2, [r0, #1]
    pMacAddr[2] = ((GMAC_REGS->SA[0].GMAC_SAB)>>16)& 0xFF;
   2068c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   20690:	0c12      	lsrs	r2, r2, #16
   20692:	7082      	strb	r2, [r0, #2]
    pMacAddr[3] = ((GMAC_REGS->SA[0].GMAC_SAB)>>24)& 0xFF;
   20694:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   20698:	0e12      	lsrs	r2, r2, #24
   2069a:	70c2      	strb	r2, [r0, #3]
    pMacAddr[4] = (GMAC_REGS->SA[0].GMAC_SAT)& 0xFF;
   2069c:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
   206a0:	7102      	strb	r2, [r0, #4]
    pMacAddr[5] = ((GMAC_REGS->SA[0].GMAC_SAT)>>8)& 0xFF;
   206a2:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
   206a6:	0a1b      	lsrs	r3, r3, #8
   206a8:	7143      	strb	r3, [r0, #5]
}
   206aa:	2000      	movs	r0, #0
   206ac:	4770      	bx	lr
   206ae:	bf00      	nop
   206b0:	42000800 	.word	0x42000800

Disassembly of section .text._TCP_EphemeralPortAllocate%716:

000206b4 <_TCP_EphemeralPortAllocate>:
{
   206b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    next_ephemeral = TCPIP_TCP_LOCAL_PORT_START_NUMBER + (SYS_RANDOM_CryptoGet() % num_ephemeral);
   206b6:	f002 f80b 	bl	226d0 <SYS_RANDOM_CryptoGet>
   206ba:	ea6f 4080 	mvn.w	r0, r0, lsl #18
   206be:	ea6f 4090 	mvn.w	r0, r0, lsr #18
   206c2:	b284      	uxth	r4, r0
   206c4:	f44f 4580 	mov.w	r5, #16384	; 0x4000
        if (next_ephemeral == TCPIP_TCP_LOCAL_PORT_END_NUMBER)
   206c8:	f64f 76ff 	movw	r6, #65535	; 0xffff
            next_ephemeral = TCPIP_TCP_LOCAL_PORT_START_NUMBER;
   206cc:	f44f 4740 	mov.w	r7, #49152	; 0xc000
        if(_TCP_PortIsAvailable(next_ephemeral))
   206d0:	4620      	mov	r0, r4
   206d2:	f7ff f927 	bl	1f924 <_TCP_PortIsAvailable>
   206d6:	b938      	cbnz	r0, 206e8 <_TCP_EphemeralPortAllocate+0x34>
        if (next_ephemeral == TCPIP_TCP_LOCAL_PORT_END_NUMBER)
   206d8:	42b4      	cmp	r4, r6
            next_ephemeral++;
   206da:	bf1a      	itte	ne
   206dc:	3401      	addne	r4, #1
   206de:	b2a4      	uxthne	r4, r4
            next_ephemeral = TCPIP_TCP_LOCAL_PORT_START_NUMBER;
   206e0:	463c      	moveq	r4, r7
    while(count--)
   206e2:	3d01      	subs	r5, #1
   206e4:	d1f4      	bne.n	206d0 <_TCP_EphemeralPortAllocate+0x1c>
    return 0;   // not found
   206e6:	2400      	movs	r4, #0
}
   206e8:	4620      	mov	r0, r4
   206ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.TCPIP_Commands_Deinitialize%717:

000206ec <TCPIP_Commands_Deinitialize>:
{
   206ec:	b508      	push	{r3, lr}
    if(commandInitCount > 0 && stackCtrl->stackAction == TCPIP_STACK_ACTION_DEINIT)
   206ee:	4b0b      	ldr	r3, [pc, #44]	; (2071c <TCPIP_Commands_Deinitialize+0x30>)
   206f0:	681b      	ldr	r3, [r3, #0]
   206f2:	2b00      	cmp	r3, #0
   206f4:	dd02      	ble.n	206fc <TCPIP_Commands_Deinitialize+0x10>
   206f6:	7f02      	ldrb	r2, [r0, #28]
   206f8:	2a02      	cmp	r2, #2
   206fa:	d000      	beq.n	206fe <TCPIP_Commands_Deinitialize+0x12>
}
   206fc:	bd08      	pop	{r3, pc}
        if(--commandInitCount == 0)
   206fe:	3b01      	subs	r3, #1
   20700:	4a06      	ldr	r2, [pc, #24]	; (2071c <TCPIP_Commands_Deinitialize+0x30>)
   20702:	6013      	str	r3, [r2, #0]
   20704:	2b00      	cmp	r3, #0
   20706:	d1f9      	bne.n	206fc <TCPIP_Commands_Deinitialize+0x10>
            if(tcpipCmdSignalHandle != 0)
   20708:	4b05      	ldr	r3, [pc, #20]	; (20720 <TCPIP_Commands_Deinitialize+0x34>)
   2070a:	6818      	ldr	r0, [r3, #0]
   2070c:	2800      	cmp	r0, #0
   2070e:	d0f5      	beq.n	206fc <TCPIP_Commands_Deinitialize+0x10>
                _TCPIPStackSignalHandlerDeregister(tcpipCmdSignalHandle);
   20710:	f003 fc19 	bl	23f46 <_TCPIPStackSignalHandlerDeregister>
                tcpipCmdSignalHandle = 0;
   20714:	4b02      	ldr	r3, [pc, #8]	; (20720 <TCPIP_Commands_Deinitialize+0x34>)
   20716:	2200      	movs	r2, #0
   20718:	601a      	str	r2, [r3, #0]
}
   2071a:	e7ef      	b.n	206fc <TCPIP_Commands_Deinitialize+0x10>
   2071c:	2000eddc 	.word	0x2000eddc
   20720:	2000ee18 	.word	0x2000ee18

Disassembly of section .text.TCPIP_DNS_ClientInfoGet%718:

00020724 <TCPIP_DNS_ClientInfoGet>:
    TCPIP_DNS_DCPT* pDnsDcpt = pgDnsDcpt;
   20724:	4b0c      	ldr	r3, [pc, #48]	; (20758 <TCPIP_DNS_ClientInfoGet+0x34>)
   20726:	681b      	ldr	r3, [r3, #0]
    if(pDnsDcpt==NULL)
   20728:	b183      	cbz	r3, 2074c <TCPIP_DNS_ClientInfoGet+0x28>
    if(pClientInfo)
   2072a:	b190      	cbz	r0, 20752 <TCPIP_DNS_ClientInfoGet+0x2e>
        pClientInfo->strictNet = pDnsDcpt->strictNet;
   2072c:	685a      	ldr	r2, [r3, #4]
   2072e:	6002      	str	r2, [r0, #0]
        pClientInfo->prefNet = pDnsDcpt->prefNet;
   20730:	689a      	ldr	r2, [r3, #8]
   20732:	6042      	str	r2, [r0, #4]
        pClientInfo->dnsTime = pDnsDcpt->dnsTime;
   20734:	69da      	ldr	r2, [r3, #28]
   20736:	6082      	str	r2, [r0, #8]
        pClientInfo->pendingEntries = pDnsDcpt->unsolvedEntries;
   20738:	8cda      	ldrh	r2, [r3, #38]	; 0x26
   2073a:	8182      	strh	r2, [r0, #12]
        pClientInfo->currentEntries = pDnsDcpt->hashDcpt->fullSlots;
   2073c:	681a      	ldr	r2, [r3, #0]
   2073e:	6a52      	ldr	r2, [r2, #36]	; 0x24
   20740:	81c2      	strh	r2, [r0, #14]
        pClientInfo->totalEntries = pDnsDcpt->hashDcpt->hEntries;
   20742:	681b      	ldr	r3, [r3, #0]
   20744:	68db      	ldr	r3, [r3, #12]
   20746:	8203      	strh	r3, [r0, #16]
    return TCPIP_DNS_RES_OK;
   20748:	2000      	movs	r0, #0
   2074a:	4770      	bx	lr
         return TCPIP_DNS_RES_NO_SERVICE;
   2074c:	f06f 0005 	mvn.w	r0, #5
   20750:	4770      	bx	lr
    return TCPIP_DNS_RES_OK;
   20752:	2000      	movs	r0, #0
}
   20754:	4770      	bx	lr
   20756:	bf00      	nop
   20758:	2000ee58 	.word	0x2000ee58

Disassembly of section .text.TCPIP_PKT_PacketMACFormat%719:

0002075c <TCPIP_PKT_PacketMACFormat>:
    if(srcAddr)
   2075c:	b1c2      	cbz	r2, 20790 <TCPIP_PKT_PacketMACFormat+0x34>
{
   2075e:	b470      	push	{r4, r5, r6}
   20760:	4614      	mov	r4, r2
        macHdr = (TCPIP_MAC_ETHERNET_HEADER*)pPkt->pMacLayer;
   20762:	6942      	ldr	r2, [r0, #20]
        srcHdrAdd = &macHdr->SourceMACAddr;
   20764:	1d95      	adds	r5, r2, #6
        if(dstAddr)
   20766:	b119      	cbz	r1, 20770 <TCPIP_PKT_PacketMACFormat+0x14>
            memcpy(destHdrAdd, dstAddr, sizeof(*destHdrAdd));
   20768:	680e      	ldr	r6, [r1, #0]
   2076a:	6016      	str	r6, [r2, #0]
   2076c:	8889      	ldrh	r1, [r1, #4]
   2076e:	8091      	strh	r1, [r2, #4]
        memcpy(srcHdrAdd, srcAddr, sizeof(*srcHdrAdd));
   20770:	6821      	ldr	r1, [r4, #0]
   20772:	f8c2 1006 	str.w	r1, [r2, #6]
   20776:	88a1      	ldrh	r1, [r4, #4]
   20778:	80a9      	strh	r1, [r5, #4]
   2077a:	0a19      	lsrs	r1, r3, #8
   2077c:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
        macHdr->Type = TCPIP_Helper_htons(pktType);
   20780:	8191      	strh	r1, [r2, #12]
        pPkt->pDSeg->segLen += sizeof(TCPIP_MAC_ETHERNET_HEADER);
   20782:	6902      	ldr	r2, [r0, #16]
   20784:	8993      	ldrh	r3, [r2, #12]
   20786:	330e      	adds	r3, #14
   20788:	8193      	strh	r3, [r2, #12]
        return true;
   2078a:	2001      	movs	r0, #1
}
   2078c:	bc70      	pop	{r4, r5, r6}
   2078e:	4770      	bx	lr
    return false;
   20790:	2000      	movs	r0, #0
}
   20792:	4770      	bx	lr

Disassembly of section .text._UDPAllocateEphemeralPort%720:

00020794 <_UDPAllocateEphemeralPort>:
{
   20794:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   20796:	f7fc f9c5 	bl	1cb24 <rand>
    next_ephemeral = TCPIP_UDP_LOCAL_PORT_START_NUMBER + (SYS_RANDOM_PseudoGet() % num_ephemeral);
   2079a:	ea6f 4080 	mvn.w	r0, r0, lsl #18
   2079e:	ea6f 4090 	mvn.w	r0, r0, lsr #18
   207a2:	b284      	uxth	r4, r0
   207a4:	f44f 4580 	mov.w	r5, #16384	; 0x4000
        if (next_ephemeral == TCPIP_UDP_LOCAL_PORT_END_NUMBER)
   207a8:	f64f 76ff 	movw	r6, #65535	; 0xffff
            next_ephemeral = TCPIP_UDP_LOCAL_PORT_START_NUMBER;
   207ac:	f44f 4740 	mov.w	r7, #49152	; 0xc000
        if(_UDPIsAvailablePort(next_ephemeral))
   207b0:	4620      	mov	r0, r4
   207b2:	f7ff f997 	bl	1fae4 <_UDPIsAvailablePort>
   207b6:	b938      	cbnz	r0, 207c8 <_UDPAllocateEphemeralPort+0x34>
        if (next_ephemeral == TCPIP_UDP_LOCAL_PORT_END_NUMBER)
   207b8:	42b4      	cmp	r4, r6
            next_ephemeral++;
   207ba:	bf1a      	itte	ne
   207bc:	3401      	addne	r4, #1
   207be:	b2a4      	uxthne	r4, r4
            next_ephemeral = TCPIP_UDP_LOCAL_PORT_START_NUMBER;
   207c0:	463c      	moveq	r4, r7
    while(count--)
   207c2:	3d01      	subs	r5, #1
   207c4:	d1f4      	bne.n	207b0 <_UDPAllocateEphemeralPort+0x1c>
    return 0;   // not found
   207c6:	2400      	movs	r4, #0
}
   207c8:	4620      	mov	r0, r4
   207ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.SERCOM0_SPI_Initialize%721:

000207cc <SERCOM0_SPI_Initialize>:
    sercom0SPIObj.callback = NULL ;
   207cc:	4b0b      	ldr	r3, [pc, #44]	; (207fc <SERCOM0_SPI_Initialize+0x30>)
   207ce:	2200      	movs	r2, #0
   207d0:	621a      	str	r2, [r3, #32]
    sercom0SPIObj.transferIsBusy = false ;
   207d2:	771a      	strb	r2, [r3, #28]
    sercom0SPIObj.txSize = 0U;
   207d4:	609a      	str	r2, [r3, #8]
    sercom0SPIObj.rxSize = 0U;
   207d6:	60da      	str	r2, [r3, #12]
    SERCOM0_REGS->SPIM.SERCOM_CTRLB = SERCOM_SPIM_CTRLB_CHSIZE_8_BIT | SERCOM_SPIM_CTRLB_RXEN_Msk ;
   207d8:	4b09      	ldr	r3, [pc, #36]	; (20800 <SERCOM0_SPI_Initialize+0x34>)
   207da:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   207de:	605a      	str	r2, [r3, #4]
    while((SERCOM0_REGS->SPIM.SERCOM_SYNCBUSY) != 0U)
   207e0:	461a      	mov	r2, r3
   207e2:	69d3      	ldr	r3, [r2, #28]
   207e4:	2b00      	cmp	r3, #0
   207e6:	d1fc      	bne.n	207e2 <SERCOM0_SPI_Initialize+0x16>
    SERCOM0_REGS->SPIM.SERCOM_BAUD = (uint8_t)SERCOM_SPIM_BAUD_BAUD(SERCOM0_SPIM_BAUD_VALUE);
   207e8:	4b05      	ldr	r3, [pc, #20]	; (20800 <SERCOM0_SPI_Initialize+0x34>)
   207ea:	221d      	movs	r2, #29
   207ec:	731a      	strb	r2, [r3, #12]
    SERCOM0_REGS->SPIM.SERCOM_CTRLA = SERCOM_SPIM_CTRLA_MODE_SPI_MASTER | SERCOM_SPIM_CTRLA_DOPO_PAD0 | SERCOM_SPIM_CTRLA_DIPO_PAD0 | SERCOM_SPIM_CTRLA_CPOL_IDLE_LOW | SERCOM_SPIM_CTRLA_CPHA_LEADING_EDGE | SERCOM_SPIM_CTRLA_DORD_MSB | SERCOM_SPIM_CTRLA_ENABLE_Msk ;
   207ee:	220e      	movs	r2, #14
   207f0:	601a      	str	r2, [r3, #0]
    while((SERCOM0_REGS->SPIM.SERCOM_SYNCBUSY) != 0U)
   207f2:	461a      	mov	r2, r3
   207f4:	69d3      	ldr	r3, [r2, #28]
   207f6:	2b00      	cmp	r3, #0
   207f8:	d1fc      	bne.n	207f4 <SERCOM0_SPI_Initialize+0x28>
}
   207fa:	4770      	bx	lr
   207fc:	2000ea6c 	.word	0x2000ea6c
   20800:	40003000 	.word	0x40003000

Disassembly of section .text.SYS_CMD_Initialize%722:

00020804 <SYS_CMD_Initialize>:
    if (initConfig == 0)
   20804:	b190      	cbz	r0, 2082c <SYS_CMD_Initialize+0x28>
{
   20806:	b538      	push	{r3, r4, r5, lr}
   20808:	4604      	mov	r4, r0
    _cmdInitData = *initConfig; // save a copy of the initialization data
   2080a:	4d09      	ldr	r5, [pc, #36]	; (20830 <SYS_CMD_Initialize+0x2c>)
   2080c:	6800      	ldr	r0, [r0, #0]
   2080e:	6028      	str	r0, [r5, #0]
    cmdIODevList.head = cmdIODevList.tail = 0;
   20810:	4b08      	ldr	r3, [pc, #32]	; (20834 <SYS_CMD_Initialize+0x30>)
   20812:	2200      	movs	r2, #0
   20814:	605a      	str	r2, [r3, #4]
   20816:	601a      	str	r2, [r3, #0]
    SYS_CMDIO_ADD(&sysConsoleApi, &initConfig->consoleCmdIOParam, initConfig->consoleCmdIOParam);
   20818:	4621      	mov	r1, r4
   2081a:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   2081e:	4806      	ldr	r0, [pc, #24]	; (20838 <SYS_CMD_Initialize+0x34>)
   20820:	f7fa f864 	bl	1a8ec <SYS_CMDIO_ADD>
    _cmdInitData.consoleIndex = initConfig->consoleIndex;
   20824:	8863      	ldrh	r3, [r4, #2]
   20826:	806b      	strh	r3, [r5, #2]
    return true;
   20828:	2001      	movs	r0, #1
}
   2082a:	bd38      	pop	{r3, r4, r5, pc}
        return false;
   2082c:	2000      	movs	r0, #0
}
   2082e:	4770      	bx	lr
   20830:	2000eed0 	.word	0x2000eed0
   20834:	2000ed8c 	.word	0x2000ed8c
   20838:	00023b70 	.word	0x00023b70

Disassembly of section .text.SYS_TIME_ResourceLock%723:

0002083c <SYS_TIME_ResourceLock>:
{
   2083c:	b508      	push	{r3, lr}
    if (gSystemCounterObj.interruptNestingCount == 0)
   2083e:	4b0b      	ldr	r3, [pc, #44]	; (2086c <SYS_TIME_ResourceLock+0x30>)
   20840:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   20844:	b10b      	cbz	r3, 2084a <SYS_TIME_ResourceLock+0xe>
    return true;
   20846:	2001      	movs	r0, #1
}
   20848:	bd08      	pop	{r3, pc}
        if(OSAL_MUTEX_Lock(&gSystemCounterObj.timerMutex, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
   2084a:	f64f 71ff 	movw	r1, #65535	; 0xffff
   2084e:	4808      	ldr	r0, [pc, #32]	; (20870 <SYS_TIME_ResourceLock+0x34>)
   20850:	f002 fb5f 	bl	22f12 <OSAL_MUTEX_Lock>
   20854:	2801      	cmp	r0, #1
   20856:	d001      	beq.n	2085c <SYS_TIME_ResourceLock+0x20>
            return false;
   20858:	2000      	movs	r0, #0
   2085a:	e7f5      	b.n	20848 <SYS_TIME_ResourceLock+0xc>
            SYS_INT_SourceDisable(gSystemCounterObj.hwTimerIntNum);
   2085c:	4b03      	ldr	r3, [pc, #12]	; (2086c <SYS_TIME_ResourceLock+0x30>)
   2085e:	f9b3 0008 	ldrsh.w	r0, [r3, #8]
   20862:	f7fe fe4f 	bl	1f504 <SYS_INT_SourceDisable>
            return true;
   20866:	2001      	movs	r0, #1
   20868:	e7ee      	b.n	20848 <SYS_TIME_ResourceLock+0xc>
   2086a:	bf00      	nop
   2086c:	2000ea00 	.word	0x2000ea00
   20870:	2000ea34 	.word	0x2000ea34

Disassembly of section .rodata.TCPIP_HOSTS_CONFIGURATION%724:

00020874 <TCPIP_HOSTS_CONFIGURATION>:
   20874:	0001bde4 0001bdec 0001bdf8 0001be0c     ................
   20884:	0001be1c 0001be2c 0001be2c 0001be38     ....,...,...8...
   20894:	0001be40 00000004 0001d9b8 00000000     @...............
	...

Disassembly of section .text.__swrite%725:

000208ac <__swrite>:
   208ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   208b0:	461f      	mov	r7, r3
   208b2:	898b      	ldrh	r3, [r1, #12]
   208b4:	05db      	lsls	r3, r3, #23
   208b6:	4605      	mov	r5, r0
   208b8:	460c      	mov	r4, r1
   208ba:	4616      	mov	r6, r2
   208bc:	d505      	bpl.n	208ca <__swrite+0x1e>
   208be:	2302      	movs	r3, #2
   208c0:	2200      	movs	r2, #0
   208c2:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   208c6:	f001 ffe1 	bl	2288c <_lseek_r>
   208ca:	89a3      	ldrh	r3, [r4, #12]
   208cc:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   208d0:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
   208d4:	81a3      	strh	r3, [r4, #12]
   208d6:	4632      	mov	r2, r6
   208d8:	463b      	mov	r3, r7
   208da:	4628      	mov	r0, r5
   208dc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   208e0:	f001 bfb0 	b.w	22844 <_write_r>

Disassembly of section .text._DRV_ETHPHY_NegCompletePhaseRead1%726:

000208e4 <_DRV_ETHPHY_NegCompletePhaseRead1>:
{
   208e4:	b510      	push	{r4, lr}
   208e6:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   208e8:	f001 fff4 	bl	228d4 <_DRV_PHY_SMITransfer_Wait>
   208ec:	b148      	cbz	r0, 20902 <_DRV_ETHPHY_NegCompletePhaseRead1+0x1e>
    if(phyBMCon.AN_ENABLE == 0)
   208ee:	f894 303b 	ldrb.w	r3, [r4, #59]	; 0x3b
   208f2:	f013 0f10 	tst.w	r3, #16
   208f6:	d005      	beq.n	20904 <_DRV_ETHPHY_NegCompletePhaseRead1+0x20>
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMCON))
   208f8:	2100      	movs	r1, #0
   208fa:	4620      	mov	r0, r4
   208fc:	f000 fb38 	bl	20f70 <_DRV_PHY_SMIReadStart>
   20900:	b930      	cbnz	r0, 20910 <_DRV_ETHPHY_NegCompletePhaseRead1+0x2c>
}
   20902:	bd10      	pop	{r4, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_NEGOTIATION_INACTIVE);
   20904:	f06f 0104 	mvn.w	r1, #4
   20908:	4620      	mov	r0, r4
   2090a:	f001 fa8f 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
        return;
   2090e:	e7f8      	b.n	20902 <_DRV_ETHPHY_NegCompletePhaseRead1+0x1e>
    hClientObj->operPhase = operPhase;
   20910:	2302      	movs	r3, #2
   20912:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   20914:	2300      	movs	r3, #0
   20916:	8423      	strh	r3, [r4, #32]
   20918:	e7f3      	b.n	20902 <_DRV_ETHPHY_NegCompletePhaseRead1+0x1e>

Disassembly of section .text._TCPSetSourceAddress%727:

0002091a <_TCPSetSourceAddress>:
    if(localAddress == 0)
   2091a:	b1ba      	cbz	r2, 2094c <_TCPSetSourceAddress+0x32>
{
   2091c:	b410      	push	{r4}
   2091e:	4614      	mov	r4, r2
    while(pSkt->addType == addType)
   20920:	f890 306f 	ldrb.w	r3, [r0, #111]	; 0x6f
   20924:	428b      	cmp	r3, r1
   20926:	d003      	beq.n	20930 <_TCPSetSourceAddress+0x16>
    return false;
   20928:	2000      	movs	r0, #0
}
   2092a:	f85d 4b04 	ldr.w	r4, [sp], #4
   2092e:	4770      	bx	lr
        if (addType == IP_ADDRESS_TYPE_IPV4)
   20930:	2901      	cmp	r1, #1
   20932:	d001      	beq.n	20938 <_TCPSetSourceAddress+0x1e>
    return false;
   20934:	2000      	movs	r0, #0
   20936:	e7f8      	b.n	2092a <_TCPSetSourceAddress+0x10>
            pSkt->srcAddress.Val = localAddress->v4Add.Val;
   20938:	6823      	ldr	r3, [r4, #0]
   2093a:	63c3      	str	r3, [r0, #60]	; 0x3c
            pSkt->flags.srcSet = 1;
   2093c:	f890 306d 	ldrb.w	r3, [r0, #109]	; 0x6d
   20940:	f043 0310 	orr.w	r3, r3, #16
   20944:	f880 306d 	strb.w	r3, [r0, #109]	; 0x6d
            return true;
   20948:	2001      	movs	r0, #1
   2094a:	e7ee      	b.n	2092a <_TCPSetSourceAddress+0x10>
        return false;
   2094c:	2000      	movs	r0, #0
}
   2094e:	4770      	bx	lr

Disassembly of section .text._DNS_NetIsValid%728:

00020950 <_DNS_NetIsValid>:
{
   20950:	b510      	push	{r4, lr}
   20952:	4604      	mov	r4, r0
    if(TCPIP_STACK_NetIsReady(pIf) != 0)
   20954:	f002 fd84 	bl	23460 <TCPIP_STACK_NetIsReady>
   20958:	4603      	mov	r3, r0
   2095a:	b190      	cbz	r0, 20982 <_DNS_NetIsValid+0x32>
        if(_TCPIPStackNetAddress(pIf) != 0)
   2095c:	6863      	ldr	r3, [r4, #4]
   2095e:	b17b      	cbz	r3, 20980 <_DNS_NetIsValid+0x30>
            if(pIf->Flags.bIsDnsClientEnabled != 0)
   20960:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   20964:	f013 0f08 	tst.w	r3, #8
   20968:	d101      	bne.n	2096e <_DNS_NetIsValid+0x1e>
    return false;
   2096a:	2300      	movs	r3, #0
   2096c:	e009      	b.n	20982 <_DNS_NetIsValid+0x32>
                return pIf->dnsServer[0].Val != 0 || pIf->dnsServer[1].Val != 0;
   2096e:	6923      	ldr	r3, [r4, #16]
   20970:	b923      	cbnz	r3, 2097c <_DNS_NetIsValid+0x2c>
   20972:	6963      	ldr	r3, [r4, #20]
   20974:	3300      	adds	r3, #0
   20976:	bf18      	it	ne
   20978:	2301      	movne	r3, #1
   2097a:	e002      	b.n	20982 <_DNS_NetIsValid+0x32>
   2097c:	2301      	movs	r3, #1
   2097e:	e000      	b.n	20982 <_DNS_NetIsValid+0x32>
    return false;
   20980:	2300      	movs	r3, #0
}
   20982:	4618      	mov	r0, r3
   20984:	bd10      	pop	{r4, pc}

Disassembly of section .text._TCPIPStackSetConfigAddress%729:

00020986 <_TCPIPStackSetConfigAddress>:
    if(pNetIf)
   20986:	b1c0      	cbz	r0, 209ba <_TCPIPStackSetConfigAddress+0x34>
{
   20988:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2098a:	4604      	mov	r4, r0
   2098c:	461f      	mov	r7, r3
   2098e:	4615      	mov	r5, r2
   20990:	460e      	mov	r6, r1
        OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   20992:	2000      	movs	r0, #0
   20994:	f002 feee 	bl	23774 <OSAL_CRIT_Enter>
   20998:	4601      	mov	r1, r0
    if(ipAddress)
   2099a:	b10e      	cbz	r6, 209a0 <_TCPIPStackSetConfigAddress+0x1a>
        pNetIf->netIPAddr.Val = ipAddress->Val;
   2099c:	6833      	ldr	r3, [r6, #0]
   2099e:	6063      	str	r3, [r4, #4]
    if(mask)
   209a0:	b10d      	cbz	r5, 209a6 <_TCPIPStackSetConfigAddress+0x20>
        pNetIf->netMask.Val = mask->Val;
   209a2:	682b      	ldr	r3, [r5, #0]
   209a4:	60a3      	str	r3, [r4, #8]
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   209a6:	2000      	movs	r0, #0
   209a8:	f003 f81e 	bl	239e8 <OSAL_CRIT_Leave>
    pNetIf->Flags.bInConfig = config;
   209ac:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
   209b0:	f367 1204 	bfi	r2, r7, #4, #1
   209b4:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
}
   209b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   209ba:	4770      	bx	lr

Disassembly of section .text.TCPIP_DHCPS_CopyDataArrayToProcessBuff%730:

000209bc <TCPIP_DHCPS_CopyDataArrayToProcessBuff>:
{
   209bc:	b538      	push	{r3, r4, r5, lr}
    int nBytes = putbuf->endPtr - putbuf->wrPtr;
   209be:	684b      	ldr	r3, [r1, #4]
   209c0:	688c      	ldr	r4, [r1, #8]
   209c2:	1ae4      	subs	r4, r4, r3
    if(len < nBytes)
   209c4:	4294      	cmp	r4, r2
   209c6:	bfa8      	it	ge
   209c8:	4614      	movge	r4, r2
    if(nBytes <= 0)
   209ca:	2c00      	cmp	r4, #0
   209cc:	dd0f      	ble.n	209ee <TCPIP_DHCPS_CopyDataArrayToProcessBuff+0x32>
    if(val == NULL)
   209ce:	b150      	cbz	r0, 209e6 <TCPIP_DHCPS_CopyDataArrayToProcessBuff+0x2a>
   209d0:	460d      	mov	r5, r1
   209d2:	4601      	mov	r1, r0
    memcpy(putbuf->wrPtr, val,nBytes);
   209d4:	4622      	mov	r2, r4
   209d6:	4618      	mov	r0, r3
   209d8:	f002 fc88 	bl	232ec <memcpy>
    putbuf->wrPtr += nBytes;
   209dc:	686b      	ldr	r3, [r5, #4]
   209de:	4423      	add	r3, r4
   209e0:	606b      	str	r3, [r5, #4]
}
   209e2:	4620      	mov	r0, r4
   209e4:	bd38      	pop	{r3, r4, r5, pc}
        putbuf->wrPtr = putbuf->wrPtr+nBytes;
   209e6:	441c      	add	r4, r3
   209e8:	604c      	str	r4, [r1, #4]
        return 0;
   209ea:	2400      	movs	r4, #0
   209ec:	e7f9      	b.n	209e2 <TCPIP_DHCPS_CopyDataArrayToProcessBuff+0x26>
        return 0;
   209ee:	2400      	movs	r4, #0
   209f0:	e7f7      	b.n	209e2 <TCPIP_DHCPS_CopyDataArrayToProcessBuff+0x26>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2%731:

000209f4 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2>:
{
   209f4:	b538      	push	{r3, r4, r5, lr}
   209f6:	4604      	mov	r4, r0
    hDriver = hClientObj->hDriver;
   209f8:	68c3      	ldr	r3, [r0, #12]
    res = (*hDriver->pPhyObj->miiConfigure)(gDrvEthBaseObj, (DRV_HANDLE)hClientObj, hDriver->configFlags);
   209fa:	695a      	ldr	r2, [r3, #20]
   209fc:	6815      	ldr	r5, [r2, #0]
   209fe:	7b9a      	ldrb	r2, [r3, #14]
   20a00:	4601      	mov	r1, r0
   20a02:	4808      	ldr	r0, [pc, #32]	; (20a24 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2+0x30>)
   20a04:	47a8      	blx	r5
    if(res == DRV_ETHPHY_RES_OK)
   20a06:	b118      	cbz	r0, 20a10 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2+0x1c>
   20a08:	4601      	mov	r1, r0
    else if(res != DRV_ETHPHY_RES_PENDING)
   20a0a:	2801      	cmp	r0, #1
   20a0c:	d106      	bne.n	20a1c <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2+0x28>
}
   20a0e:	bd38      	pop	{r3, r4, r5, pc}
        hClientObj->vendorData = 0;
   20a10:	2300      	movs	r3, #0
   20a12:	6423      	str	r3, [r4, #64]	; 0x40
    hClientObj->operPhase = operPhase;
   20a14:	2303      	movs	r3, #3
   20a16:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   20a18:	8423      	strh	r3, [r4, #32]
   20a1a:	e7f8      	b.n	20a0e <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2+0x1a>
        _DRV_PHY_SetOperDoneResult(hClientObj, res);
   20a1c:	4620      	mov	r0, r4
   20a1e:	f001 fa05 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
}
   20a22:	e7f4      	b.n	20a0e <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2+0x1a>
   20a24:	0001d460 	.word	0x0001d460

Disassembly of section .text.DRV_PIC32CGMAC_LibClearPriorityQue%732:

00020a28 <DRV_PIC32CGMAC_LibClearPriorityQue>:
{
   20a28:	b570      	push	{r4, r5, r6, lr}
   20a2a:	4604      	mov	r4, r0
   20a2c:	460e      	mov	r6, r1
    intStat = SYS_INT_SourceDisable(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc);
   20a2e:	f9b0 00b6 	ldrsh.w	r0, [r0, #182]	; 0xb6
   20a32:	f7fe fd67 	bl	1f504 <SYS_INT_SourceDisable>
   20a36:	4601      	mov	r1, r0
    drvGmacQueEvents &= ~(1<<queueIdx);
   20a38:	4d07      	ldr	r5, [pc, #28]	; (20a58 <DRV_PIC32CGMAC_LibClearPriorityQue+0x30>)
   20a3a:	2301      	movs	r3, #1
   20a3c:	fa03 f206 	lsl.w	r2, r3, r6
   20a40:	682b      	ldr	r3, [r5, #0]
   20a42:	ea23 0302 	bic.w	r3, r3, r2
   20a46:	602b      	str	r3, [r5, #0]
  __ASM volatile ("dmb 0xF":::"memory");
   20a48:	f3bf 8f5f 	dmb	sy
    SYS_INT_SourceRestore(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc, intStat);
   20a4c:	f9b4 00b6 	ldrsh.w	r0, [r4, #182]	; 0xb6
   20a50:	f002 f956 	bl	22d00 <SYS_INT_SourceRestore>
}
   20a54:	bd70      	pop	{r4, r5, r6, pc}
   20a56:	bf00      	nop
   20a58:	2000eda4 	.word	0x2000eda4

Disassembly of section .text._TCP_SktFlagsGet%733:

00020a5c <_TCP_SktFlagsGet>:
    return (pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1 || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2 || pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT);
   20a5c:	f890 206e 	ldrb.w	r2, [r0, #110]	; 0x6e
   20a60:	1ed3      	subs	r3, r2, #3
   20a62:	b2db      	uxtb	r3, r3
   20a64:	2b02      	cmp	r3, #2
   20a66:	d911      	bls.n	20a8c <_TCP_SktFlagsGet+0x30>
        flags |= TCP_SOCKET_FLAG_CONNECTED;
   20a68:	2a08      	cmp	r2, #8
   20a6a:	bf14      	ite	ne
   20a6c:	2301      	movne	r3, #1
   20a6e:	2303      	moveq	r3, #3
    if(pSkt->Flags.bSocketReset)
   20a70:	f890 2037 	ldrb.w	r2, [r0, #55]	; 0x37
   20a74:	f012 0f02 	tst.w	r2, #2
        flags |= TCP_SOCKET_FLAG_RST;
   20a78:	bf18      	it	ne
   20a7a:	f043 0304 	orrne.w	r3, r3, #4
    if(pSkt->Flags.bRxFin)
   20a7e:	f012 0f04 	tst.w	r2, #4
        flags |= TCP_SOCKET_FLAG_FIN;
   20a82:	bf18      	it	ne
   20a84:	f043 0308 	orrne.w	r3, r3, #8
}
   20a88:	4618      	mov	r0, r3
   20a8a:	4770      	bx	lr
        flags |= TCP_SOCKET_FLAG_CONNECTED;
   20a8c:	2303      	movs	r3, #3
   20a8e:	e7ef      	b.n	20a70 <_TCP_SktFlagsGet+0x14>

Disassembly of section .text._ARPSetEntry%734:

00020a90 <_ARPSetEntry>:
{
   20a90:	b538      	push	{r3, r4, r5, lr}
   20a92:	4604      	mov	r4, r0
    arpHE->hEntry.flags.value &= ~ARP_FLAG_ENTRY_VALID_MASK;
   20a94:	8805      	ldrh	r5, [r0, #0]
   20a96:	f025 05c0 	bic.w	r5, r5, #192	; 0xc0
    arpHE->hEntry.flags.value |= newFlags;
   20a9a:	4329      	orrs	r1, r5
   20a9c:	8001      	strh	r1, [r0, #0]
    if(hwAdd)
   20a9e:	b11a      	cbz	r2, 20aa8 <_ARPSetEntry+0x18>
        arpHE->hwAdd = *hwAdd;
   20aa0:	6810      	ldr	r0, [r2, #0]
   20aa2:	6120      	str	r0, [r4, #16]
   20aa4:	8892      	ldrh	r2, [r2, #4]
   20aa6:	82a2      	strh	r2, [r4, #20]
    arpHE->tInsert = arpMod.timeSeconds;
   20aa8:	4a05      	ldr	r2, [pc, #20]	; (20ac0 <_ARPSetEntry+0x30>)
   20aaa:	6952      	ldr	r2, [r2, #20]
   20aac:	60e2      	str	r2, [r4, #12]
    arpHE->nRetries = 1;
   20aae:	2201      	movs	r2, #1
   20ab0:	82e2      	strh	r2, [r4, #22]
    if(addList)
   20ab2:	b11b      	cbz	r3, 20abc <_ARPSetEntry+0x2c>
   20ab4:	4618      	mov	r0, r3
        TCPIP_Helper_ProtectedSingleListTailAdd(addList, (SGL_LIST_NODE*)&arpHE->next);
   20ab6:	1d21      	adds	r1, r4, #4
   20ab8:	f001 f951 	bl	21d5e <TCPIP_Helper_ProtectedSingleListTailAdd>
}
   20abc:	bd38      	pop	{r3, r4, r5, pc}
   20abe:	bf00      	nop
   20ac0:	2000e974 	.word	0x2000e974

Disassembly of section .text.TCPIP_ARP_HandlerRegister%735:

00020ac4 <TCPIP_ARP_HandlerRegister>:
    if(handler && arpMod.memH)
   20ac4:	b181      	cbz	r1, 20ae8 <TCPIP_ARP_HandlerRegister+0x24>
   20ac6:	460b      	mov	r3, r1
   20ac8:	4909      	ldr	r1, [pc, #36]	; (20af0 <TCPIP_ARP_HandlerRegister+0x2c>)
   20aca:	6889      	ldr	r1, [r1, #8]
   20acc:	b169      	cbz	r1, 20aea <TCPIP_ARP_HandlerRegister+0x26>
{
   20ace:	b500      	push	{lr}
   20ad0:	b085      	sub	sp, #20
        arpNode.handler = handler;
   20ad2:	9301      	str	r3, [sp, #4]
        arpNode.hParam = hParam;
   20ad4:	9202      	str	r2, [sp, #8]
        arpNode.hNet = hNet;
   20ad6:	9003      	str	r0, [sp, #12]
        return (ARP_LIST_NODE*)TCPIP_Notification_Add(&arpMod.registeredUsers, arpMod.memH, &arpNode, sizeof(arpNode));
   20ad8:	2310      	movs	r3, #16
   20ada:	466a      	mov	r2, sp
   20adc:	4805      	ldr	r0, [pc, #20]	; (20af4 <TCPIP_ARP_HandlerRegister+0x30>)
   20ade:	f001 f968 	bl	21db2 <TCPIP_Notification_Add>
}
   20ae2:	b005      	add	sp, #20
   20ae4:	f85d fb04 	ldr.w	pc, [sp], #4
    return 0;
   20ae8:	2100      	movs	r1, #0
}
   20aea:	4608      	mov	r0, r1
   20aec:	4770      	bx	lr
   20aee:	bf00      	nop
   20af0:	2000e974 	.word	0x2000e974
   20af4:	2000e994 	.word	0x2000e994

Disassembly of section .text.TCPIP_DHCP_HandlerRegister%736:

00020af8 <TCPIP_DHCP_HandlerRegister>:
    if(handler && dhcpMemH)
   20af8:	b181      	cbz	r1, 20b1c <TCPIP_DHCP_HandlerRegister+0x24>
   20afa:	460b      	mov	r3, r1
   20afc:	4909      	ldr	r1, [pc, #36]	; (20b24 <TCPIP_DHCP_HandlerRegister+0x2c>)
   20afe:	6809      	ldr	r1, [r1, #0]
   20b00:	b169      	cbz	r1, 20b1e <TCPIP_DHCP_HandlerRegister+0x26>
{
   20b02:	b500      	push	{lr}
   20b04:	b085      	sub	sp, #20
        dhcpNode.handler = handler;
   20b06:	9301      	str	r3, [sp, #4]
        dhcpNode.hParam = hParam;
   20b08:	9202      	str	r2, [sp, #8]
        dhcpNode.hNet = hNet;
   20b0a:	9003      	str	r0, [sp, #12]
        return (TCPIP_DHCP_LIST_NODE*)TCPIP_Notification_Add(&dhcpRegisteredUsers, dhcpMemH, &dhcpNode, sizeof(dhcpNode));
   20b0c:	2310      	movs	r3, #16
   20b0e:	466a      	mov	r2, sp
   20b10:	4805      	ldr	r0, [pc, #20]	; (20b28 <TCPIP_DHCP_HandlerRegister+0x30>)
   20b12:	f001 f94e 	bl	21db2 <TCPIP_Notification_Add>
}
   20b16:	b005      	add	sp, #20
   20b18:	f85d fb04 	ldr.w	pc, [sp], #4
    return 0;
   20b1c:	2100      	movs	r1, #0
}
   20b1e:	4608      	mov	r0, r1
   20b20:	4770      	bx	lr
   20b22:	bf00      	nop
   20b24:	2000ee48 	.word	0x2000ee48
   20b28:	2000ec64 	.word	0x2000ec64

Disassembly of section .rodata%737:

00020b2c <.rodata%737>:
   20b2c:	50434844 	.word	0x50434844
   20b30:	6146203a 	.word	0x6146203a
   20b34:	64656c69 	.word	0x64656c69
   20b38:	206f7420 	.word	0x206f7420
   20b3c:	69676572 	.word	0x69676572
   20b40:	72657473 	.word	0x72657473
   20b44:	76504920 	.word	0x76504920
   20b48:	69662034 	.word	0x69662034
   20b4c:	7265746c 	.word	0x7265746c
   20b50:	0a0d2021 	.word	0x0a0d2021
   20b54:	00000000 	.word	0x00000000
   20b58:	ffffffff 	.word	0xffffffff
   20b5c:	ffff      	.short	0xffff
   20b5e:	bf00      	nop

Disassembly of section .text._DNSGetData%738:

00020b60 <_DNSGetData>:
{
   20b60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   20b62:	4605      	mov	r5, r0
   20b64:	4616      	mov	r6, r2
    size_t avlblBytes = srcBuff->endPtr - srcBuff->rdPtr;
   20b66:	6843      	ldr	r3, [r0, #4]
   20b68:	6884      	ldr	r4, [r0, #8]
   20b6a:	1ae4      	subs	r4, r4, r3
    if(copyBytes > avlblBytes)
   20b6c:	4627      	mov	r7, r4
   20b6e:	4294      	cmp	r4, r2
   20b70:	bf28      	it	cs
   20b72:	4617      	movcs	r7, r2
    if(destBuff && copyBytes)
   20b74:	4608      	mov	r0, r1
   20b76:	b101      	cbz	r1, 20b7a <_DNSGetData+0x1a>
   20b78:	b93f      	cbnz	r7, 20b8a <_DNSGetData+0x2a>
    srcBuff->rdPtr += copyBytes;
   20b7a:	686a      	ldr	r2, [r5, #4]
   20b7c:	443a      	add	r2, r7
   20b7e:	606a      	str	r2, [r5, #4]
}
   20b80:	42b4      	cmp	r4, r6
   20b82:	bf34      	ite	cc
   20b84:	2000      	movcc	r0, #0
   20b86:	2001      	movcs	r0, #1
   20b88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        memcpy(destBuff, srcBuff->rdPtr, copyBytes);
   20b8a:	463a      	mov	r2, r7
   20b8c:	4619      	mov	r1, r3
   20b8e:	f002 fbad 	bl	232ec <memcpy>
   20b92:	e7f2      	b.n	20b7a <_DNSGetData+0x1a>

Disassembly of section .text.TCPIP_STACK_NetDown%739:

00020b94 <TCPIP_STACK_NetDown>:
    if(pDownIf)
   20b94:	b1a0      	cbz	r0, 20bc0 <TCPIP_STACK_NetDown+0x2c>
{
   20b96:	b510      	push	{r4, lr}
   20b98:	4604      	mov	r4, r0
        if(pDownIf->Flags.bInterfaceEnabled || pDownIf->Flags.bMacInitialize)
   20b9a:	f8b0 3042 	ldrh.w	r3, [r0, #66]	; 0x42
   20b9e:	f244 0240 	movw	r2, #16448	; 0x4040
   20ba2:	421a      	tst	r2, r3
   20ba4:	d101      	bne.n	20baa <TCPIP_STACK_NetDown+0x16>
        return true;
   20ba6:	2001      	movs	r0, #1
}
   20ba8:	bd10      	pop	{r4, pc}
            TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pDownIf, TCPIP_STACK_ACTION_IF_DOWN, TCPIP_MAC_POWER_DOWN);
   20baa:	2303      	movs	r3, #3
   20bac:	2204      	movs	r2, #4
   20bae:	4601      	mov	r1, r0
   20bb0:	4804      	ldr	r0, [pc, #16]	; (20bc4 <TCPIP_STACK_NetDown+0x30>)
   20bb2:	f7fc f919 	bl	1cde8 <TCPIP_STACK_BringNetDown>
            _TCPIP_SelectDefaultNet(pDownIf);
   20bb6:	4620      	mov	r0, r4
   20bb8:	f7fc fb62 	bl	1d280 <_TCPIP_SelectDefaultNet>
        return true;
   20bbc:	2001      	movs	r0, #1
   20bbe:	e7f3      	b.n	20ba8 <TCPIP_STACK_NetDown+0x14>
    return false;
   20bc0:	2000      	movs	r0, #0
}
   20bc2:	4770      	bx	lr
   20bc4:	2000eae4 	.word	0x2000eae4

Disassembly of section .text.TCPIP_UDP_RxOffsetSet%740:

00020bc8 <TCPIP_UDP_RxOffsetSet>:
{
   20bc8:	b538      	push	{r3, r4, r5, lr}
   20bca:	4604      	mov	r4, r0
   20bcc:	460d      	mov	r5, r1
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   20bce:	f001 fabd 	bl	2214c <_UDPSocketDcpt>
    if(pSkt && pSkt->pCurrRxPkt != 0)
   20bd2:	b190      	cbz	r0, 20bfa <TCPIP_UDP_RxOffsetSet+0x32>
   20bd4:	4603      	mov	r3, r0
   20bd6:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   20bd8:	b17a      	cbz	r2, 20bfa <TCPIP_UDP_RxOffsetSet+0x32>
        UDP_HEADER* pUDPHdr = (UDP_HEADER*)pRxPkt->pTransportLayer;
   20bda:	69d0      	ldr	r0, [r2, #28]
        pSkt->pCurrRxSeg = pRxPkt->pDSeg;
   20bdc:	6911      	ldr	r1, [r2, #16]
   20bde:	6319      	str	r1, [r3, #48]	; 0x30
        pSkt->rxSegLen = pRxPkt->pDSeg->segLen - sizeof(UDP_HEADER);
   20be0:	8989      	ldrh	r1, [r1, #12]
   20be2:	3908      	subs	r1, #8
   20be4:	8699      	strh	r1, [r3, #52]	; 0x34
        pSkt->rxTotLen = pUDPHdr->Length;  
   20be6:	8881      	ldrh	r1, [r0, #4]
   20be8:	86d9      	strh	r1, [r3, #54]	; 0x36
        pSkt->rxCurr = pRxPkt->pTransportLayer + sizeof(UDP_HEADER);
   20bea:	69d2      	ldr	r2, [r2, #28]
   20bec:	3208      	adds	r2, #8
   20bee:	639a      	str	r2, [r3, #56]	; 0x38
        TCPIP_UDP_ArrayGet(s, 0, wOffset);
   20bf0:	462a      	mov	r2, r5
   20bf2:	2100      	movs	r1, #0
   20bf4:	4620      	mov	r0, r4
   20bf6:	f7f5 ff21 	bl	16a3c <TCPIP_UDP_ArrayGet>
}
   20bfa:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.CommandQuit%741:

00020bfc <CommandQuit>:
{
   20bfc:	b510      	push	{r4, lr}
    (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** Quitting the Command Processor. Bye ***\r\n" );
   20bfe:	6803      	ldr	r3, [r0, #0]
   20c00:	681b      	ldr	r3, [r3, #0]
   20c02:	4908      	ldr	r1, [pc, #32]	; (20c24 <CommandQuit+0x28>)
   20c04:	6840      	ldr	r0, [r0, #4]
   20c06:	4798      	blx	r3
    memset(_usrCmdTbl, 0x0, sizeof(_usrCmdTbl));
   20c08:	2280      	movs	r2, #128	; 0x80
   20c0a:	2100      	movs	r1, #0
   20c0c:	4806      	ldr	r0, [pc, #24]	; (20c28 <CommandQuit+0x2c>)
   20c0e:	f003 f947 	bl	23ea0 <memset>
    while((pCmdIoNode = cmdIODevList.head) != NULL)
   20c12:	4b06      	ldr	r3, [pc, #24]	; (20c2c <CommandQuit+0x30>)
   20c14:	681c      	ldr	r4, [r3, #0]
   20c16:	b11c      	cbz	r4, 20c20 <CommandQuit+0x24>
        free(pCmdIoNode);
   20c18:	4620      	mov	r0, r4
   20c1a:	f003 f939 	bl	23e90 <free>
   20c1e:	e7fb      	b.n	20c18 <CommandQuit+0x1c>
}
   20c20:	bd10      	pop	{r4, pc}
   20c22:	bf00      	nop
   20c24:	0000ea40 	.word	0x0000ea40
   20c28:	2000e768 	.word	0x2000e768
   20c2c:	2000ed8c 	.word	0x2000ed8c

Disassembly of section .text.Console_UART_WriteCountGet%742:

00020c30 <Console_UART_WriteCountGet>:

    return nFreeBufferAvailable;
}

ssize_t Console_UART_WriteCountGet(uint32_t index)
{
   20c30:	b538      	push	{r3, r4, r5, lr}
    ssize_t nPendingTxBytes = 0;

    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   20c32:	b970      	cbnz	r0, 20c52 <Console_UART_WriteCountGet+0x22>
    if (pConsoleUartData == NULL)
    {
        return -1;
    }

    if (Console_UART_ResourceLock(pConsoleUartData) == false)
   20c34:	480a      	ldr	r0, [pc, #40]	; (20c60 <Console_UART_WriteCountGet+0x30>)
   20c36:	f002 ffa5 	bl	23b84 <Console_UART_ResourceLock>
   20c3a:	b168      	cbz	r0, 20c58 <Console_UART_WriteCountGet+0x28>
    {
        return -1;
    }

    nPendingTxBytes = pConsoleUartData->uartPLIB->writeCountGet();
   20c3c:	4c08      	ldr	r4, [pc, #32]	; (20c60 <Console_UART_WriteCountGet+0x30>)
   20c3e:	f854 3b08 	ldr.w	r3, [r4], #8
   20c42:	691b      	ldr	r3, [r3, #16]
   20c44:	4798      	blx	r3
   20c46:	4605      	mov	r5, r0
    OSAL_MUTEX_Unlock(&(pConsoleUartData->mutexTransferObjects));
   20c48:	4620      	mov	r0, r4
   20c4a:	f002 fdb7 	bl	237bc <OSAL_MUTEX_Unlock>

    Console_UART_ResourceUnlock(pConsoleUartData);

    return nPendingTxBytes;
}
   20c4e:	4628      	mov	r0, r5
   20c50:	bd38      	pop	{r3, r4, r5, pc}
        return -1;
   20c52:	f04f 35ff 	mov.w	r5, #4294967295
   20c56:	e7fa      	b.n	20c4e <Console_UART_WriteCountGet+0x1e>
        return -1;
   20c58:	f04f 35ff 	mov.w	r5, #4294967295
   20c5c:	e7f7      	b.n	20c4e <Console_UART_WriteCountGet+0x1e>
   20c5e:	bf00      	nop
   20c60:	2000ed58 	.word	0x2000ed58

Disassembly of section .text.Console_UART_WriteFreeBufferCountGet%743:

00020c64 <Console_UART_WriteFreeBufferCountGet>:
{
   20c64:	b538      	push	{r3, r4, r5, lr}
    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   20c66:	b970      	cbnz	r0, 20c86 <Console_UART_WriteFreeBufferCountGet+0x22>
    if (Console_UART_ResourceLock(pConsoleUartData) == false)
   20c68:	480a      	ldr	r0, [pc, #40]	; (20c94 <Console_UART_WriteFreeBufferCountGet+0x30>)
   20c6a:	f002 ff8b 	bl	23b84 <Console_UART_ResourceLock>
   20c6e:	b168      	cbz	r0, 20c8c <Console_UART_WriteFreeBufferCountGet+0x28>
    nFreeBufferAvailable = pConsoleUartData->uartPLIB->writeFreeBufferCountGet();
   20c70:	4c08      	ldr	r4, [pc, #32]	; (20c94 <Console_UART_WriteFreeBufferCountGet+0x30>)
   20c72:	f854 3b08 	ldr.w	r3, [r4], #8
   20c76:	695b      	ldr	r3, [r3, #20]
   20c78:	4798      	blx	r3
   20c7a:	4605      	mov	r5, r0
    OSAL_MUTEX_Unlock(&(pConsoleUartData->mutexTransferObjects));
   20c7c:	4620      	mov	r0, r4
   20c7e:	f002 fd9d 	bl	237bc <OSAL_MUTEX_Unlock>
}
   20c82:	4628      	mov	r0, r5
   20c84:	bd38      	pop	{r3, r4, r5, pc}
        return -1;
   20c86:	f04f 35ff 	mov.w	r5, #4294967295
   20c8a:	e7fa      	b.n	20c82 <Console_UART_WriteFreeBufferCountGet+0x1e>
        return -1;
   20c8c:	f04f 35ff 	mov.w	r5, #4294967295
   20c90:	e7f7      	b.n	20c82 <Console_UART_WriteFreeBufferCountGet+0x1e>
   20c92:	bf00      	nop
   20c94:	2000ed58 	.word	0x2000ed58

Disassembly of section .text.Console_UART_ReadFreeBufferCountGet%744:

00020c98 <Console_UART_ReadFreeBufferCountGet>:
{
   20c98:	b538      	push	{r3, r4, r5, lr}
    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   20c9a:	b970      	cbnz	r0, 20cba <Console_UART_ReadFreeBufferCountGet+0x22>
    if (Console_UART_ResourceLock(pConsoleUartData) == false)
   20c9c:	480a      	ldr	r0, [pc, #40]	; (20cc8 <Console_UART_ReadFreeBufferCountGet+0x30>)
   20c9e:	f002 ff71 	bl	23b84 <Console_UART_ResourceLock>
   20ca2:	b168      	cbz	r0, 20cc0 <Console_UART_ReadFreeBufferCountGet+0x28>
    nFreeBufferAvailable = pConsoleUartData->uartPLIB->readFreeBufferCountGet();
   20ca4:	4c08      	ldr	r4, [pc, #32]	; (20cc8 <Console_UART_ReadFreeBufferCountGet+0x30>)
   20ca6:	f854 3b08 	ldr.w	r3, [r4], #8
   20caa:	689b      	ldr	r3, [r3, #8]
   20cac:	4798      	blx	r3
   20cae:	4605      	mov	r5, r0
    OSAL_MUTEX_Unlock(&(pConsoleUartData->mutexTransferObjects));
   20cb0:	4620      	mov	r0, r4
   20cb2:	f002 fd83 	bl	237bc <OSAL_MUTEX_Unlock>
}
   20cb6:	4628      	mov	r0, r5
   20cb8:	bd38      	pop	{r3, r4, r5, pc}
        return -1;
   20cba:	f04f 35ff 	mov.w	r5, #4294967295
   20cbe:	e7fa      	b.n	20cb6 <Console_UART_ReadFreeBufferCountGet+0x1e>
        return -1;
   20cc0:	f04f 35ff 	mov.w	r5, #4294967295
   20cc4:	e7f7      	b.n	20cb6 <Console_UART_ReadFreeBufferCountGet+0x1e>
   20cc6:	bf00      	nop
   20cc8:	2000ed58 	.word	0x2000ed58

Disassembly of section .text.Console_UART_ReadCountGet%745:

00020ccc <Console_UART_ReadCountGet>:
{
   20ccc:	b538      	push	{r3, r4, r5, lr}
    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   20cce:	b970      	cbnz	r0, 20cee <Console_UART_ReadCountGet+0x22>
    if (Console_UART_ResourceLock(pConsoleUartData) == false)
   20cd0:	480a      	ldr	r0, [pc, #40]	; (20cfc <Console_UART_ReadCountGet+0x30>)
   20cd2:	f002 ff57 	bl	23b84 <Console_UART_ResourceLock>
   20cd6:	b168      	cbz	r0, 20cf4 <Console_UART_ReadCountGet+0x28>
    nUnreadBytesAvailable = pConsoleUartData->uartPLIB->readCountGet();
   20cd8:	4c08      	ldr	r4, [pc, #32]	; (20cfc <Console_UART_ReadCountGet+0x30>)
   20cda:	f854 3b08 	ldr.w	r3, [r4], #8
   20cde:	685b      	ldr	r3, [r3, #4]
   20ce0:	4798      	blx	r3
   20ce2:	4605      	mov	r5, r0
    OSAL_MUTEX_Unlock(&(pConsoleUartData->mutexTransferObjects));
   20ce4:	4620      	mov	r0, r4
   20ce6:	f002 fd69 	bl	237bc <OSAL_MUTEX_Unlock>
}
   20cea:	4628      	mov	r0, r5
   20cec:	bd38      	pop	{r3, r4, r5, pc}
        return -1;
   20cee:	f04f 35ff 	mov.w	r5, #4294967295
   20cf2:	e7fa      	b.n	20cea <Console_UART_ReadCountGet+0x1e>
        return -1;
   20cf4:	f04f 35ff 	mov.w	r5, #4294967295
   20cf8:	e7f7      	b.n	20cea <Console_UART_ReadCountGet+0x1e>
   20cfa:	bf00      	nop
   20cfc:	2000ed58 	.word	0x2000ed58

Disassembly of section .text.SYS_CONSOLE_Read%746:

00020d00 <SYS_CONSOLE_Read>:
    SYS_CONSOLE_OBJECT_INSTANCE* pConsoleObj = SYS_CONSOLE_GET_INSTANCE(handle);
   20d00:	b960      	cbnz	r0, 20d1c <SYS_CONSOLE_Read+0x1c>
{
   20d02:	b508      	push	{r3, lr}
        if (pConsoleObj->status == SYS_STATUS_UNINITIALIZED || pConsoleObj->devDesc == NULL)
   20d04:	4b0a      	ldr	r3, [pc, #40]	; (20d30 <SYS_CONSOLE_Read+0x30>)
   20d06:	f993 3000 	ldrsb.w	r3, [r3]
   20d0a:	b153      	cbz	r3, 20d22 <SYS_CONSOLE_Read+0x22>
   20d0c:	4b08      	ldr	r3, [pc, #32]	; (20d30 <SYS_CONSOLE_Read+0x30>)
   20d0e:	685b      	ldr	r3, [r3, #4]
   20d10:	b153      	cbz	r3, 20d28 <SYS_CONSOLE_Read+0x28>
        return pConsoleObj->devDesc->read(pConsoleObj->devIndex, buf, count);
   20d12:	689b      	ldr	r3, [r3, #8]
   20d14:	4806      	ldr	r0, [pc, #24]	; (20d30 <SYS_CONSOLE_Read+0x30>)
   20d16:	6880      	ldr	r0, [r0, #8]
   20d18:	4798      	blx	r3
}
   20d1a:	bd08      	pop	{r3, pc}
        return -1;
   20d1c:	f04f 30ff 	mov.w	r0, #4294967295
}
   20d20:	4770      	bx	lr
            return -1;
   20d22:	f04f 30ff 	mov.w	r0, #4294967295
   20d26:	e7f8      	b.n	20d1a <SYS_CONSOLE_Read+0x1a>
   20d28:	f04f 30ff 	mov.w	r0, #4294967295
   20d2c:	e7f5      	b.n	20d1a <SYS_CONSOLE_Read+0x1a>
   20d2e:	bf00      	nop
   20d30:	2000ed64 	.word	0x2000ed64

Disassembly of section .text.SYS_CONSOLE_ReadCountGet%747:

00020d34 <SYS_CONSOLE_ReadCountGet>:
    SYS_CONSOLE_OBJECT_INSTANCE* pConsoleObj = SYS_CONSOLE_GET_INSTANCE(handle);
   20d34:	b960      	cbnz	r0, 20d50 <SYS_CONSOLE_ReadCountGet+0x1c>
{
   20d36:	b508      	push	{r3, lr}
        if (pConsoleObj->status == SYS_STATUS_UNINITIALIZED || pConsoleObj->devDesc == NULL)
   20d38:	4b0a      	ldr	r3, [pc, #40]	; (20d64 <SYS_CONSOLE_ReadCountGet+0x30>)
   20d3a:	f993 3000 	ldrsb.w	r3, [r3]
   20d3e:	b153      	cbz	r3, 20d56 <SYS_CONSOLE_ReadCountGet+0x22>
   20d40:	4b08      	ldr	r3, [pc, #32]	; (20d64 <SYS_CONSOLE_ReadCountGet+0x30>)
   20d42:	685b      	ldr	r3, [r3, #4]
   20d44:	b153      	cbz	r3, 20d5c <SYS_CONSOLE_ReadCountGet+0x28>
        return pConsoleObj->devDesc->readCountGet(pConsoleObj->devIndex);
   20d46:	68db      	ldr	r3, [r3, #12]
   20d48:	4a06      	ldr	r2, [pc, #24]	; (20d64 <SYS_CONSOLE_ReadCountGet+0x30>)
   20d4a:	6890      	ldr	r0, [r2, #8]
   20d4c:	4798      	blx	r3
}
   20d4e:	bd08      	pop	{r3, pc}
        return -1;
   20d50:	f04f 30ff 	mov.w	r0, #4294967295
}
   20d54:	4770      	bx	lr
            return -1;
   20d56:	f04f 30ff 	mov.w	r0, #4294967295
   20d5a:	e7f8      	b.n	20d4e <SYS_CONSOLE_ReadCountGet+0x1a>
   20d5c:	f04f 30ff 	mov.w	r0, #4294967295
   20d60:	e7f5      	b.n	20d4e <SYS_CONSOLE_ReadCountGet+0x1a>
   20d62:	bf00      	nop
   20d64:	2000ed64 	.word	0x2000ed64

Disassembly of section .text.SYS_CONSOLE_Write%748:

00020d68 <SYS_CONSOLE_Write>:
    SYS_CONSOLE_OBJECT_INSTANCE* pConsoleObj = SYS_CONSOLE_GET_INSTANCE(handle);
   20d68:	b960      	cbnz	r0, 20d84 <SYS_CONSOLE_Write+0x1c>
{
   20d6a:	b508      	push	{r3, lr}
        if (pConsoleObj->status == SYS_STATUS_UNINITIALIZED || pConsoleObj->devDesc == NULL)
   20d6c:	4b0a      	ldr	r3, [pc, #40]	; (20d98 <SYS_CONSOLE_Write+0x30>)
   20d6e:	f993 3000 	ldrsb.w	r3, [r3]
   20d72:	b153      	cbz	r3, 20d8a <SYS_CONSOLE_Write+0x22>
   20d74:	4b08      	ldr	r3, [pc, #32]	; (20d98 <SYS_CONSOLE_Write+0x30>)
   20d76:	685b      	ldr	r3, [r3, #4]
   20d78:	b153      	cbz	r3, 20d90 <SYS_CONSOLE_Write+0x28>
        return pConsoleObj->devDesc->write(pConsoleObj->devIndex, buf, count);
   20d7a:	695b      	ldr	r3, [r3, #20]
   20d7c:	4806      	ldr	r0, [pc, #24]	; (20d98 <SYS_CONSOLE_Write+0x30>)
   20d7e:	6880      	ldr	r0, [r0, #8]
   20d80:	4798      	blx	r3
}
   20d82:	bd08      	pop	{r3, pc}
        return -1;
   20d84:	f04f 30ff 	mov.w	r0, #4294967295
}
   20d88:	4770      	bx	lr
            return -1;
   20d8a:	f04f 30ff 	mov.w	r0, #4294967295
   20d8e:	e7f8      	b.n	20d82 <SYS_CONSOLE_Write+0x1a>
   20d90:	f04f 30ff 	mov.w	r0, #4294967295
   20d94:	e7f5      	b.n	20d82 <SYS_CONSOLE_Write+0x1a>
   20d96:	bf00      	nop
   20d98:	2000ed64 	.word	0x2000ed64

Disassembly of section .rodata.tcpipMACPIC32CINTInitData%749:

00020d9c <tcpipMACPIC32CINTInitData>:
   20d9c:	00000000 00080000 00020008 00020001     ................
   20dac:	06000008 01010600 041401f4 42000800     ...............B
   20dbc:	0001d460 00022d40 00010000 00000001     `...@-..........
   20dcc:	00000000                                ....

Disassembly of section .text.vListInsert%750:

00020dd0 <vListInsert>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   20dd0:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
   20dd2:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
   20dd4:	f1b5 3fff 	cmp.w	r5, #4294967295
   20dd8:	d002      	beq.n	20de0 <vListInsert+0x10>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
   20dda:	f100 0208 	add.w	r2, r0, #8
   20dde:	e002      	b.n	20de6 <vListInsert+0x16>
		pxIterator = pxList->xListEnd.pxPrevious;
   20de0:	6902      	ldr	r2, [r0, #16]
   20de2:	e004      	b.n	20dee <vListInsert+0x1e>
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
   20de4:	461a      	mov	r2, r3
   20de6:	6853      	ldr	r3, [r2, #4]
   20de8:	681c      	ldr	r4, [r3, #0]
   20dea:	42ac      	cmp	r4, r5
   20dec:	d9fa      	bls.n	20de4 <vListInsert+0x14>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
   20dee:	6853      	ldr	r3, [r2, #4]
   20df0:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
   20df2:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
   20df4:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
   20df6:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
   20df8:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
   20dfa:	6803      	ldr	r3, [r0, #0]
   20dfc:	3301      	adds	r3, #1
   20dfe:	6003      	str	r3, [r0, #0]
}
   20e00:	bc30      	pop	{r4, r5}
   20e02:	4770      	bx	lr

Disassembly of section .text.vTaskDelay%751:

00020e04 <vTaskDelay>:
	{
   20e04:	b510      	push	{r4, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
   20e06:	b940      	cbnz	r0, 20e1a <vTaskDelay+0x16>
			portYIELD_WITHIN_API();
   20e08:	4b0a      	ldr	r3, [pc, #40]	; (20e34 <vTaskDelay+0x30>)
   20e0a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   20e0e:	601a      	str	r2, [r3, #0]
   20e10:	f3bf 8f4f 	dsb	sy
   20e14:	f3bf 8f6f 	isb	sy
	}
   20e18:	bd10      	pop	{r4, pc}
   20e1a:	4604      	mov	r4, r0
			vTaskSuspendAll();
   20e1c:	f003 f810 	bl	23e40 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
   20e20:	2100      	movs	r1, #0
   20e22:	4620      	mov	r0, r4
   20e24:	f7f9 f818 	bl	19e58 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
   20e28:	f7f5 fd26 	bl	16878 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
   20e2c:	2800      	cmp	r0, #0
   20e2e:	d1f3      	bne.n	20e18 <vTaskDelay+0x14>
   20e30:	e7ea      	b.n	20e08 <vTaskDelay+0x4>
   20e32:	bf00      	nop
   20e34:	e000ed04 	.word	0xe000ed04

Disassembly of section .text.gfx_mono_framebuffer_put_page%752:

00020e38 <gfx_mono_framebuffer_put_page>:
 * \code
    gfx_mono_framebuffer_put_page(data_buf, 0, 10, 32);
\endcode
 */
void gfx_mono_framebuffer_put_page(gfx_mono_color_t *data, gfx_coord_t page,
        gfx_coord_t column, gfx_coord_t width) {
   20e38:	b430      	push	{r4, r5}
    gfx_mono_color_t *data_pt = data;
    gfx_coord_t *framebuffer_pt = fbpointer +
   20e3a:	4c0b      	ldr	r4, [pc, #44]	; (20e68 <gfx_mono_framebuffer_put_page+0x30>)
   20e3c:	6824      	ldr	r4, [r4, #0]
            ((page * GFX_MONO_LCD_WIDTH) + column);
   20e3e:	eb02 12c1 	add.w	r2, r2, r1, lsl #7
    gfx_coord_t *framebuffer_pt = fbpointer +
   20e42:	4422      	add	r2, r4

    do {
        uint8_t *fBufferBegin = fbpointer;
        uint8_t *fBufferEnd = fbpointer + GFX_MONO_LCD_FRAMEBUFFER_SIZE;
   20e44:	f504 7100 	add.w	r1, r4, #512	; 0x200
   20e48:	e003      	b.n	20e52 <gfx_mono_framebuffer_put_page+0x1a>

        if ((framebuffer_pt >= fBufferBegin) && (framebuffer_pt <= fBufferEnd)) {
            *framebuffer_pt++ = *data_pt++;
        }

    } while (--width > 0);
   20e4a:	3b01      	subs	r3, #1
   20e4c:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
   20e50:	d008      	beq.n	20e64 <gfx_mono_framebuffer_put_page+0x2c>
        if ((framebuffer_pt >= fBufferBegin) && (framebuffer_pt <= fBufferEnd)) {
   20e52:	4294      	cmp	r4, r2
   20e54:	d8f9      	bhi.n	20e4a <gfx_mono_framebuffer_put_page+0x12>
   20e56:	428a      	cmp	r2, r1
            *framebuffer_pt++ = *data_pt++;
   20e58:	bf9c      	itt	ls
   20e5a:	f810 5b01 	ldrbls.w	r5, [r0], #1
   20e5e:	f802 5b01 	strbls.w	r5, [r2], #1
   20e62:	e7f2      	b.n	20e4a <gfx_mono_framebuffer_put_page+0x12>
}
   20e64:	bc30      	pop	{r4, r5}
   20e66:	4770      	bx	lr
   20e68:	2000ef3c 	.word	0x2000ef3c

Disassembly of section .text.gfx_mono_generic_draw_filled_rect%753:

00020e6c <gfx_mono_generic_draw_filled_rect>:
 * \param[in]  height      Height of the rectangle.
 * \param[in]  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
        gfx_coord_t width, gfx_coord_t height,
        enum gfx_mono_color color) {
   20e6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   20e70:	f89d 7018 	ldrb.w	r7, [sp, #24]
    if (height == 0) {
   20e74:	b193      	cbz	r3, 20e9c <gfx_mono_generic_draw_filled_rect+0x30>
   20e76:	461c      	mov	r4, r3
   20e78:	4690      	mov	r8, r2
   20e7a:	460d      	mov	r5, r1
   20e7c:	4606      	mov	r6, r0
   20e7e:	1e4b      	subs	r3, r1, #1
   20e80:	441c      	add	r4, r3
   20e82:	b2e4      	uxtb	r4, r4
   20e84:	e000      	b.n	20e88 <gfx_mono_generic_draw_filled_rect+0x1c>
   20e86:	461c      	mov	r4, r3
        /* Nothing to do. Move along. */
        return;
    }

    while (height-- > 0) {
        gfx_mono_draw_horizontal_line(x, y + height, width, color);
   20e88:	463b      	mov	r3, r7
   20e8a:	4642      	mov	r2, r8
   20e8c:	4621      	mov	r1, r4
   20e8e:	4630      	mov	r0, r6
   20e90:	f7f6 fbf8 	bl	17684 <gfx_mono_generic_draw_horizontal_line>
   20e94:	1e63      	subs	r3, r4, #1
   20e96:	b2db      	uxtb	r3, r3
    while (height-- > 0) {
   20e98:	42a5      	cmp	r5, r4
   20e9a:	d1f4      	bne.n	20e86 <gfx_mono_generic_draw_filled_rect+0x1a>
    }
}
   20e9c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.gfx_mono_scroll_Line_6x7%754:

00020ea0 <gfx_mono_scroll_Line_6x7>:
    }

    gfx_mono_put_byte(page, column, temp);
}

void gfx_mono_scroll_Line_6x7(void) {
   20ea0:	b508      	push	{r3, lr}
    int ix;
    for (ix = 0; ix < (128*3); ix++) {
   20ea2:	480a      	ldr	r0, [pc, #40]	; (20ecc <gfx_mono_scroll_Line_6x7+0x2c>)
   20ea4:	1e43      	subs	r3, r0, #1
   20ea6:	f200 117f 	addw	r1, r0, #383	; 0x17f
        framebuffer[ix] = framebuffer[ix + 128];
   20eaa:	f893 2081 	ldrb.w	r2, [r3, #129]	; 0x81
   20eae:	f803 2f01 	strb.w	r2, [r3, #1]!
    for (ix = 0; ix < (128*3); ix++) {
   20eb2:	428b      	cmp	r3, r1
   20eb4:	d1f9      	bne.n	20eaa <gfx_mono_scroll_Line_6x7+0xa>
   20eb6:	4b06      	ldr	r3, [pc, #24]	; (20ed0 <gfx_mono_scroll_Line_6x7+0x30>)
   20eb8:	f200 12ff 	addw	r2, r0, #511	; 0x1ff
    }
    for ( ; ix < 512; ix++) {
        framebuffer[ix] = 0;
   20ebc:	2100      	movs	r1, #0
   20ebe:	f803 1f01 	strb.w	r1, [r3, #1]!
    for ( ; ix < 512; ix++) {
   20ec2:	4293      	cmp	r3, r2
   20ec4:	d1fb      	bne.n	20ebe <gfx_mono_scroll_Line_6x7+0x1e>
    }  
    gfx_mono_ssd1306_put_framebuffer();
   20ec6:	f7fe fb83 	bl	1f5d0 <gfx_mono_ssd1306_put_framebuffer>
}
   20eca:	bd08      	pop	{r3, pc}
   20ecc:	2000dc14 	.word	0x2000dc14
   20ed0:	2000dd93 	.word	0x2000dd93

Disassembly of section .text.Hash_DRBG_Uninstantiate%755:

00020ed4 <Hash_DRBG_Uninstantiate>:
{
   20ed4:	b410      	push	{r4}
    while (len--) *z++ = 0;
   20ed6:	f100 0484 	add.w	r4, r0, #132	; 0x84
    volatile byte* z = (volatile byte*)mem;
   20eda:	4602      	mov	r2, r0
    while (len--) *z++ = 0;
   20edc:	2100      	movs	r1, #0
   20ede:	4613      	mov	r3, r2
   20ee0:	f803 1b01 	strb.w	r1, [r3], #1
   20ee4:	461a      	mov	r2, r3
   20ee6:	42a3      	cmp	r3, r4
   20ee8:	d1f9      	bne.n	20ede <Hash_DRBG_Uninstantiate+0xa>
   20eea:	1e43      	subs	r3, r0, #1
   20eec:	f100 0183 	add.w	r1, r0, #131	; 0x83
    int    compareSum = 0;
   20ef0:	2000      	movs	r0, #0
        compareSum |= compareDrbg[i] ^ 0;
   20ef2:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   20ef6:	4310      	orrs	r0, r2
    for (i = 0; i < sizeof(DRBG_internal); i++)
   20ef8:	428b      	cmp	r3, r1
   20efa:	d1fa      	bne.n	20ef2 <Hash_DRBG_Uninstantiate+0x1e>
}
   20efc:	3000      	adds	r0, #0
   20efe:	bf18      	it	ne
   20f00:	2001      	movne	r0, #1
   20f02:	f85d 4b04 	ldr.w	r4, [sp], #4
   20f06:	4770      	bx	lr

Disassembly of section .text.memmove%756:

00020f08 <memmove>:
   20f08:	4288      	cmp	r0, r1
   20f0a:	b510      	push	{r4, lr}
   20f0c:	eb01 0302 	add.w	r3, r1, r2
   20f10:	d902      	bls.n	20f18 <memmove+0x10>
   20f12:	4283      	cmp	r3, r0
   20f14:	461c      	mov	r4, r3
   20f16:	d807      	bhi.n	20f28 <memmove+0x20>
   20f18:	1e42      	subs	r2, r0, #1
   20f1a:	4299      	cmp	r1, r3
   20f1c:	d008      	beq.n	20f30 <memmove+0x28>
   20f1e:	f811 4b01 	ldrb.w	r4, [r1], #1
   20f22:	f802 4f01 	strb.w	r4, [r2, #1]!
   20f26:	e7f8      	b.n	20f1a <memmove+0x12>
   20f28:	1883      	adds	r3, r0, r2
   20f2a:	1a9a      	subs	r2, r3, r2
   20f2c:	429a      	cmp	r2, r3
   20f2e:	d100      	bne.n	20f32 <memmove+0x2a>
   20f30:	bd10      	pop	{r4, pc}
   20f32:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
   20f36:	f803 1d01 	strb.w	r1, [r3, #-1]!
   20f3a:	e7f7      	b.n	20f2c <memmove+0x24>

Disassembly of section .text.__mcmp%757:

00020f3c <__mcmp>:
   20f3c:	6903      	ldr	r3, [r0, #16]
   20f3e:	690a      	ldr	r2, [r1, #16]
   20f40:	1a9b      	subs	r3, r3, r2
   20f42:	b530      	push	{r4, r5, lr}
   20f44:	d10c      	bne.n	20f60 <__mcmp+0x24>
   20f46:	0092      	lsls	r2, r2, #2
   20f48:	3014      	adds	r0, #20
   20f4a:	3114      	adds	r1, #20
   20f4c:	1884      	adds	r4, r0, r2
   20f4e:	4411      	add	r1, r2
   20f50:	f854 5d04 	ldr.w	r5, [r4, #-4]!
   20f54:	f851 2d04 	ldr.w	r2, [r1, #-4]!
   20f58:	4295      	cmp	r5, r2
   20f5a:	d003      	beq.n	20f64 <__mcmp+0x28>
   20f5c:	d305      	bcc.n	20f6a <__mcmp+0x2e>
   20f5e:	2301      	movs	r3, #1
   20f60:	4618      	mov	r0, r3
   20f62:	bd30      	pop	{r4, r5, pc}
   20f64:	42a0      	cmp	r0, r4
   20f66:	d3f3      	bcc.n	20f50 <__mcmp+0x14>
   20f68:	e7fa      	b.n	20f60 <__mcmp+0x24>
   20f6a:	f04f 33ff 	mov.w	r3, #4294967295
   20f6e:	e7f7      	b.n	20f60 <__mcmp+0x24>

Disassembly of section .text._DRV_PHY_SMIReadStart%758:

00020f70 <_DRV_PHY_SMIReadStart>:
{
   20f70:	b510      	push	{r4, lr}
   20f72:	4604      	mov	r4, r0
    hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_START;
   20f74:	2301      	movs	r3, #1
   20f76:	8683      	strh	r3, [r0, #52]	; 0x34
    hClientObj->smiRIx = rIx;
   20f78:	8701      	strh	r1, [r0, #56]	; 0x38
    hClientObj->smiTxferType = DRV_ETHPHY_SMI_XFER_TYPE_READ;
   20f7a:	2303      	movs	r3, #3
   20f7c:	86c3      	strh	r3, [r0, #54]	; 0x36
    hClientObj->smiPhyAddress = hClientObj->hDriver->phyAddress;
   20f7e:	68c3      	ldr	r3, [r0, #12]
   20f80:	691b      	ldr	r3, [r3, #16]
   20f82:	63c3      	str	r3, [r0, #60]	; 0x3c
    DRV_ETHPHY_SMI_TXFER_RES opRes = _DRV_PHY_SMITransferStart(hClientObj);
   20f84:	f7f8 fb7c 	bl	19680 <_DRV_PHY_SMITransferStart>
    if(opRes < 0)
   20f88:	2800      	cmp	r0, #0
   20f8a:	db03      	blt.n	20f94 <_DRV_PHY_SMIReadStart+0x24>
    else if(opRes == DRV_ETHPHY_SMI_TXFER_RES_BUSY)
   20f8c:	3803      	subs	r0, #3
   20f8e:	bf18      	it	ne
   20f90:	2001      	movne	r0, #1
}
   20f92:	bd10      	pop	{r4, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   20f94:	f06f 0108 	mvn.w	r1, #8
   20f98:	4620      	mov	r0, r4
   20f9a:	f000 ff47 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
        return false;
   20f9e:	2000      	movs	r0, #0
   20fa0:	e7f7      	b.n	20f92 <_DRV_PHY_SMIReadStart+0x22>

Disassembly of section .text._DRV_PHY_SMIWriteStart%759:

00020fa2 <_DRV_PHY_SMIWriteStart>:
{
   20fa2:	b510      	push	{r4, lr}
   20fa4:	4604      	mov	r4, r0
    hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_START;
   20fa6:	2301      	movs	r3, #1
   20fa8:	8683      	strh	r3, [r0, #52]	; 0x34
    hClientObj->smiRIx = rIx;
   20faa:	8701      	strh	r1, [r0, #56]	; 0x38
    hClientObj->smiTxferType = DRV_ETHPHY_SMI_XFER_TYPE_WRITE;
   20fac:	86c3      	strh	r3, [r0, #54]	; 0x36
    hClientObj->smiData =  wData;
   20fae:	8742      	strh	r2, [r0, #58]	; 0x3a
    hClientObj->smiPhyAddress = hClientObj->hDriver->phyAddress;
   20fb0:	68c3      	ldr	r3, [r0, #12]
   20fb2:	691b      	ldr	r3, [r3, #16]
   20fb4:	63c3      	str	r3, [r0, #60]	; 0x3c
    DRV_ETHPHY_SMI_TXFER_RES opRes = _DRV_PHY_SMITransferStart(hClientObj);
   20fb6:	f7f8 fb63 	bl	19680 <_DRV_PHY_SMITransferStart>
    if(opRes < 0)
   20fba:	2800      	cmp	r0, #0
   20fbc:	db03      	blt.n	20fc6 <_DRV_PHY_SMIWriteStart+0x24>
    else if(opRes == DRV_ETHPHY_SMI_TXFER_RES_BUSY)
   20fbe:	3803      	subs	r0, #3
   20fc0:	bf18      	it	ne
   20fc2:	2001      	movne	r0, #1
}
   20fc4:	bd10      	pop	{r4, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   20fc6:	f06f 0108 	mvn.w	r1, #8
   20fca:	4620      	mov	r0, r4
   20fcc:	f000 ff2e 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
        return false;
   20fd0:	2000      	movs	r0, #0
   20fd2:	e7f7      	b.n	20fc4 <_DRV_PHY_SMIWriteStart+0x22>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseIdle%760:

00020fd4 <_DRV_ETHPHY_SetupPhaseIdle>:
    hDriver = hClientObj->hDriver;
   20fd4:	68c1      	ldr	r1, [r0, #12]
    configFlags = hDriver->configFlags;
   20fd6:	7b8b      	ldrb	r3, [r1, #14]
    openFlags = hDriver->openFlags;
   20fd8:	898a      	ldrh	r2, [r1, #12]
    if(openFlags & (TCPIP_ETH_OPEN_PHY_LOOPBACK | TCPIP_ETH_OPEN_MAC_LOOPBACK))
   20fda:	f012 0fc0 	tst.w	r2, #192	; 0xc0
        openFlags &= ~TCPIP_ETH_OPEN_AUTO; // no negotiation in loopback mode!
   20fde:	bf1c      	itt	ne
   20fe0:	f022 0201 	bicne.w	r2, r2, #1
   20fe4:	b292      	uxthne	r2, r2
    if(!(openFlags & TCPIP_ETH_OPEN_AUTO))
   20fe6:	f012 0f01 	tst.w	r2, #1
        openFlags &= ~TCPIP_ETH_OPEN_MDIX_AUTO;        // Auto-MDIX has to be in auto negotiation only
   20fea:	bf04      	itt	eq
   20fec:	f422 7280 	biceq.w	r2, r2, #256	; 0x100
   20ff0:	b292      	uxtheq	r2, r2
    openFlags |= (configFlags & DRV_ETHPHY_CFG_RMII) ? TCPIP_ETH_OPEN_RMII : TCPIP_ETH_OPEN_MII;
   20ff2:	029b      	lsls	r3, r3, #10
   20ff4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   20ff8:	4313      	orrs	r3, r2
    hDriver->openFlags = openFlags;
   20ffa:	818b      	strh	r3, [r1, #12]
    hClientObj->operPhase = operPhase;
   20ffc:	2301      	movs	r3, #1
   20ffe:	83c3      	strh	r3, [r0, #30]
    hClientObj->operSubPhase = operSubPhase;
   21000:	2300      	movs	r3, #0
   21002:	8403      	strh	r3, [r0, #32]
}
   21004:	4770      	bx	lr

Disassembly of section .text.DRV_PIC32CGMAC_LibTxAckPendPacket%761:

00021006 <DRV_PIC32CGMAC_LibTxAckPendPacket>:
{
   21006:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2100a:	4605      	mov	r5, r0
   2100c:	4690      	mov	r8, r2
    while((pPkt = (TCPIP_MAC_PACKET*)DRV_PIC32CGMAC_SingleListHeadRemove(&pMACDrv->sGmacData.gmac_queue[queueIdx]._TxQueue)) != 0)
   2100e:	242c      	movs	r4, #44	; 0x2c
   21010:	fb04 0401 	mla	r4, r4, r1, r0
   21014:	34a4      	adds	r4, #164	; 0xa4
            (*pMACDrv->sGmacData.pktAckF)(pPkt, ackRes, TCPIP_THIS_MODULE_ID);
   21016:	f241 0750 	movw	r7, #4176	; 0x1050
    while((pPkt = (TCPIP_MAC_PACKET*)DRV_PIC32CGMAC_SingleListHeadRemove(&pMACDrv->sGmacData.gmac_queue[queueIdx]._TxQueue)) != 0)
   2101a:	4620      	mov	r0, r4
   2101c:	f001 ffd0 	bl	22fc0 <DRV_PIC32CGMAC_SingleListHeadRemove>
   21020:	4606      	mov	r6, r0
   21022:	b138      	cbz	r0, 21034 <DRV_PIC32CGMAC_LibTxAckPendPacket+0x2e>
        if(*pMACDrv->sGmacData.pktAckF)
   21024:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   21026:	2b00      	cmp	r3, #0
   21028:	d0f7      	beq.n	2101a <DRV_PIC32CGMAC_LibTxAckPendPacket+0x14>
            (*pMACDrv->sGmacData.pktAckF)(pPkt, ackRes, TCPIP_THIS_MODULE_ID);
   2102a:	463a      	mov	r2, r7
   2102c:	4641      	mov	r1, r8
   2102e:	4630      	mov	r0, r6
   21030:	4798      	blx	r3
   21032:	e7f2      	b.n	2101a <DRV_PIC32CGMAC_LibTxAckPendPacket+0x14>
}
   21034:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.TCPIP_STACK_NetBiosNameSet%762:

00021038 <TCPIP_STACK_NetBiosNameSet>:
   21038:	b1a8      	cbz	r0, 21066 <TCPIP_STACK_NetBiosNameSet+0x2e>
   2103a:	4603      	mov	r3, r0
   2103c:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   21040:	f012 0f40 	tst.w	r2, #64	; 0x40
   21044:	d101      	bne.n	2104a <TCPIP_STACK_NetBiosNameSet+0x12>
    return false;
   21046:	2000      	movs	r0, #0
}
   21048:	4770      	bx	lr
{
   2104a:	b570      	push	{r4, r5, r6, lr}
        memcpy(pNetIf->NetBIOSName, biosName, sizeof(pNetIf->NetBIOSName));
   2104c:	302c      	adds	r0, #44	; 0x2c
   2104e:	680e      	ldr	r6, [r1, #0]
   21050:	684d      	ldr	r5, [r1, #4]
   21052:	688c      	ldr	r4, [r1, #8]
   21054:	68ca      	ldr	r2, [r1, #12]
   21056:	62de      	str	r6, [r3, #44]	; 0x2c
   21058:	6045      	str	r5, [r0, #4]
   2105a:	6084      	str	r4, [r0, #8]
   2105c:	60c2      	str	r2, [r0, #12]
        TCPIP_Helper_FormatNetBIOSName(pNetIf->NetBIOSName);
   2105e:	f7fd f9bd 	bl	1e3dc <TCPIP_Helper_FormatNetBIOSName>
        return true;
   21062:	2001      	movs	r0, #1
}
   21064:	bd70      	pop	{r4, r5, r6, pc}
    return false;
   21066:	2000      	movs	r0, #0
   21068:	4770      	bx	lr

Disassembly of section .text._DRV_PHY_NegCompleteSetOperResult%763:

0002106a <_DRV_PHY_NegCompleteSetOperResult>:
{
   2106a:	b508      	push	{r3, lr}
    if(!phyBMCon.AN_ENABLE)
   2106c:	0a09      	lsrs	r1, r1, #8
   2106e:	f011 0f10 	tst.w	r1, #16
   21072:	d00a      	beq.n	2108a <_DRV_PHY_NegCompleteSetOperResult+0x20>
    else if(phyBMCon.AN_RESTART)
   21074:	f011 0f02 	tst.w	r1, #2
   21078:	d10c      	bne.n	21094 <_DRV_PHY_NegCompleteSetOperResult+0x2a>
        res = (phyStat.AN_COMPLETE == 0) ? DRV_ETHPHY_RES_NEGOTIATION_ACTIVE : DRV_ETHPHY_RES_OK;    // active/tmo/ok
   2107a:	f002 0220 	and.w	r2, r2, #32
   2107e:	2a00      	cmp	r2, #0
   21080:	bf0c      	ite	eq
   21082:	f06f 0107 	mvneq.w	r1, #7
   21086:	2100      	movne	r1, #0
   21088:	e001      	b.n	2108e <_DRV_PHY_NegCompleteSetOperResult+0x24>
        res = DRV_ETHPHY_RES_NEGOTIATION_INACTIVE;       // no negotiation is taking place!
   2108a:	f06f 0104 	mvn.w	r1, #4
    _DRV_PHY_SetOperDoneResult(hClientObj, res);
   2108e:	f000 fecd 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
}
   21092:	bd08      	pop	{r3, pc}
        res = DRV_ETHPHY_RES_NEGOTIATION_NOT_STARTED;        // not started yet/tmo
   21094:	f06f 0106 	mvn.w	r1, #6
   21098:	e7f9      	b.n	2108e <_DRV_PHY_NegCompleteSetOperResult+0x24>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3%764:

0002109c <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3>:
{
   2109c:	b538      	push	{r3, r4, r5, lr}
   2109e:	4604      	mov	r4, r0
    DRV_ETHPHY_INSTANCE *hDriver = hClientObj->hDriver;
   210a0:	68c3      	ldr	r3, [r0, #12]
    res = (*hDriver->pPhyObj->mdixConfigure)(gDrvEthBaseObj, (DRV_HANDLE)hClientObj, hClientObj->hDriver->openFlags);
   210a2:	695a      	ldr	r2, [r3, #20]
   210a4:	6855      	ldr	r5, [r2, #4]
   210a6:	899a      	ldrh	r2, [r3, #12]
   210a8:	4601      	mov	r1, r0
   210aa:	4807      	ldr	r0, [pc, #28]	; (210c8 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3+0x2c>)
   210ac:	47a8      	blx	r5
    if(res < 0)
   210ae:	1e01      	subs	r1, r0, #0
   210b0:	db01      	blt.n	210b6 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3+0x1a>
    else if(res != DRV_ETHPHY_RES_OK)
   210b2:	b121      	cbz	r1, 210be <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3+0x22>
}
   210b4:	bd38      	pop	{r3, r4, r5, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, res);
   210b6:	4620      	mov	r0, r4
   210b8:	f000 feb8 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
        return;
   210bc:	e7fa      	b.n	210b4 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3+0x18>
    hClientObj->operPhase = operPhase;
   210be:	2303      	movs	r3, #3
   210c0:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   210c2:	2304      	movs	r3, #4
   210c4:	8423      	strh	r3, [r4, #32]
   210c6:	e7f5      	b.n	210b4 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3+0x18>
   210c8:	0001d460 	.word	0x0001d460

Disassembly of section .text.DRV_GMAC_Status%765:

000210cc <DRV_GMAC_Status>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   210cc:	4b0a      	ldr	r3, [pc, #40]	; (210f8 <DRV_GMAC_Status+0x2c>)
   210ce:	4283      	cmp	r3, r0
   210d0:	d108      	bne.n	210e4 <DRV_GMAC_Status+0x18>
    if(pMACDrv != 0)
   210d2:	b150      	cbz	r0, 210ea <DRV_GMAC_Status+0x1e>
        if(pMACDrv->sGmacData._macFlags._init != 0)
   210d4:	7d9b      	ldrb	r3, [r3, #22]
   210d6:	f013 0f01 	tst.w	r3, #1
   210da:	d009      	beq.n	210f0 <DRV_GMAC_Status+0x24>
            return pMACDrv->sGmacData.sysStat;
   210dc:	4b06      	ldr	r3, [pc, #24]	; (210f8 <DRV_GMAC_Status+0x2c>)
   210de:	f993 0014 	ldrsb.w	r0, [r3, #20]
   210e2:	4770      	bx	lr
	return SYS_STATUS_ERROR;
   210e4:	f04f 30ff 	mov.w	r0, #4294967295
   210e8:	4770      	bx	lr
   210ea:	f04f 30ff 	mov.w	r0, #4294967295
   210ee:	4770      	bx	lr
   210f0:	f04f 30ff 	mov.w	r0, #4294967295
}
   210f4:	4770      	bx	lr
   210f6:	bf00      	nop
   210f8:	2000e288 	.word	0x2000e288

Disassembly of section .text.DRV_PIC32CGMAC_LibSetMacAddr%766:

000210fc <DRV_PIC32CGMAC_LibSetMacAddr>:
    GMAC_REGS->SA[0].GMAC_SAB = (pMacAddr[3] << 24)
   210fc:	78c2      	ldrb	r2, [r0, #3]
                                | (pMacAddr[2] << 16)
   210fe:	7883      	ldrb	r3, [r0, #2]
   21100:	041b      	lsls	r3, r3, #16
   21102:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
                                | (pMacAddr[0]);
   21106:	7802      	ldrb	r2, [r0, #0]
   21108:	4313      	orrs	r3, r2
                                | (pMacAddr[1] <<  8)
   2110a:	7842      	ldrb	r2, [r0, #1]
                                | (pMacAddr[0]);
   2110c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    GMAC_REGS->SA[0].GMAC_SAB = (pMacAddr[3] << 24)
   21110:	4a05      	ldr	r2, [pc, #20]	; (21128 <DRV_PIC32CGMAC_LibSetMacAddr+0x2c>)
   21112:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    GMAC_REGS->SA[0].GMAC_SAT = (pMacAddr[5] <<  8)
   21116:	7941      	ldrb	r1, [r0, #5]
                                | (pMacAddr[4]) ;
   21118:	7903      	ldrb	r3, [r0, #4]
   2111a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    GMAC_REGS->SA[0].GMAC_SAT = (pMacAddr[5] <<  8)
   2111e:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
}
   21122:	2000      	movs	r0, #0
   21124:	4770      	bx	lr
   21126:	bf00      	nop
   21128:	42000800 	.word	0x42000800

Disassembly of section .text.GMAC_InterruptHandler%767:

0002112c <GMAC_InterruptHandler>:
{
   2112c:	b508      	push	{r3, lr}
    GMAC_EVENTS  currEthEvents = (GMAC_EVENTS)GMAC_REGS->GMAC_ISR;
   2112e:	4b09      	ldr	r3, [pc, #36]	; (21154 <GMAC_InterruptHandler+0x28>)
   21130:	6a59      	ldr	r1, [r3, #36]	; 0x24
    GMAC_REGS->GMAC_IDR = currEthEvents;
   21132:	b289      	uxth	r1, r1
   21134:	62d9      	str	r1, [r3, #44]	; 0x2c
    if(currEthEvents & GMAC_EV_RX_ALL)
   21136:	f240 4306 	movw	r3, #1030	; 0x406
   2113a:	4219      	tst	r1, r3
   2113c:	d004      	beq.n	21148 <GMAC_InterruptHandler+0x1c>
        drvGmacQueEvents |= GMAC_QUE0_MASK;
   2113e:	4a06      	ldr	r2, [pc, #24]	; (21158 <GMAC_InterruptHandler+0x2c>)
   21140:	6813      	ldr	r3, [r2, #0]
   21142:	f043 0301 	orr.w	r3, r3, #1
   21146:	6013      	str	r3, [r2, #0]
   21148:	f3bf 8f5f 	dmb	sy
	DRV_GMAC_Tasks_ISR((SYS_MODULE_OBJ)0, (uint32_t)currEthEvents);
   2114c:	2000      	movs	r0, #0
   2114e:	f7fb f813 	bl	1c178 <DRV_GMAC_Tasks_ISR>
}
   21152:	bd08      	pop	{r3, pc}
   21154:	42000800 	.word	0x42000800
   21158:	2000eda4 	.word	0x2000eda4

Disassembly of section .text.TCPIP_ICMP_Cleanup%768:

0002115c <TCPIP_ICMP_Cleanup>:
{
   2115c:	b508      	push	{r3, lr}
    TCPIP_Notification_Deinitialize(&icmpRegisteredUsers, icmpMemH);
   2115e:	4b08      	ldr	r3, [pc, #32]	; (21180 <TCPIP_ICMP_Cleanup+0x24>)
   21160:	6819      	ldr	r1, [r3, #0]
   21162:	4808      	ldr	r0, [pc, #32]	; (21184 <TCPIP_ICMP_Cleanup+0x28>)
   21164:	f002 fe14 	bl	23d90 <TCPIP_Notification_Deinitialize>
    if(signalHandle)
   21168:	4b07      	ldr	r3, [pc, #28]	; (21188 <TCPIP_ICMP_Cleanup+0x2c>)
   2116a:	6818      	ldr	r0, [r3, #0]
   2116c:	b120      	cbz	r0, 21178 <TCPIP_ICMP_Cleanup+0x1c>
        _TCPIPStackSignalHandlerDeregister(signalHandle);
   2116e:	f002 feea 	bl	23f46 <_TCPIPStackSignalHandlerDeregister>
        signalHandle = 0;
   21172:	4b05      	ldr	r3, [pc, #20]	; (21188 <TCPIP_ICMP_Cleanup+0x2c>)
   21174:	2200      	movs	r2, #0
   21176:	601a      	str	r2, [r3, #0]
    icmpMemH = 0;
   21178:	4b01      	ldr	r3, [pc, #4]	; (21180 <TCPIP_ICMP_Cleanup+0x24>)
   2117a:	2200      	movs	r2, #0
   2117c:	601a      	str	r2, [r3, #0]
}
   2117e:	bd08      	pop	{r3, pc}
   21180:	2000edb4 	.word	0x2000edb4
   21184:	2000ec28 	.word	0x2000ec28
   21188:	2000edbc 	.word	0x2000edbc

Disassembly of section .text._TCPSocketTxFreeSize%769:

0002118c <_TCPSocketTxFreeSize>:
	if(!( (pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED) || (pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT) ))
   2118c:	f890 306e 	ldrb.w	r3, [r0, #110]	; 0x6e
   21190:	2b03      	cmp	r3, #3
   21192:	d001      	beq.n	21198 <_TCPSocketTxFreeSize+0xc>
   21194:	2b08      	cmp	r3, #8
   21196:	d10f      	bne.n	211b8 <_TCPSocketTxFreeSize+0x2c>
	if(pSkt->txHead >= pSkt->txTail)
   21198:	6882      	ldr	r2, [r0, #8]
   2119a:	68c3      	ldr	r3, [r0, #12]
   2119c:	429a      	cmp	r2, r3
   2119e:	d203      	bcs.n	211a8 <_TCPSocketTxFreeSize+0x1c>
	return pSkt->txTail - pSkt->txHead - 1;
   211a0:	1a98      	subs	r0, r3, r2
   211a2:	3801      	subs	r0, #1
   211a4:	b280      	uxth	r0, r0
   211a6:	4770      	bx	lr
		return (pSkt->txEnd - pSkt->txStart - 1) - (pSkt->txHead - pSkt->txTail);
   211a8:	6841      	ldr	r1, [r0, #4]
   211aa:	6800      	ldr	r0, [r0, #0]
   211ac:	1a09      	subs	r1, r1, r0
   211ae:	3901      	subs	r1, #1
   211b0:	1ad0      	subs	r0, r2, r3
   211b2:	1a08      	subs	r0, r1, r0
   211b4:	b280      	uxth	r0, r0
   211b6:	4770      	bx	lr
		return 0;
   211b8:	2000      	movs	r0, #0
}
   211ba:	4770      	bx	lr

Disassembly of section .text.TCPIP_ARP_HashEntryDelete%770:

000211bc <TCPIP_ARP_HashEntryDelete>:
// This shouldn't normally occur if TCPIP_ARP_Task()
// does its job of periodically performing the cache clean-up.
// However, since the threshold can be dynamically adjusted,
// the situation could still occur
OA_HASH_ENTRY* TCPIP_ARP_HashEntryDelete(OA_HASH_DCPT* pOH)
{
   211bc:	b508      	push	{r3, lr}
    ARP_CACHE_DCPT  *pArpDcpt;
    ARP_HASH_ENTRY  *pE;
    SGL_LIST_NODE   *pN;
    PROTECTED_SINGLE_LIST     *pRemList = 0;
    
    pArpDcpt = (ARP_CACHE_DCPT*)pOH->hParam;
   211be:	6840      	ldr	r0, [r0, #4]

    if( (pN = pArpDcpt->incompleteList.list.head) != 0)
   211c0:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   211c2:	b142      	cbz	r2, 211d6 <TCPIP_ARP_HashEntryDelete+0x1a>
    {
        pE = (ARP_HASH_ENTRY*) ((uint8_t*)pN - offsetof(struct _TAG_ARP_HASH_ENTRY, next));
        if( (arpMod.timeSeconds - pE->tInsert) >= arpMod.entryPendingTmo)
   211c4:	4908      	ldr	r1, [pc, #32]	; (211e8 <TCPIP_ARP_HashEntryDelete+0x2c>)
   211c6:	694b      	ldr	r3, [r1, #20]
   211c8:	6892      	ldr	r2, [r2, #8]
   211ca:	1a9b      	subs	r3, r3, r2
   211cc:	6b8a      	ldr	r2, [r1, #56]	; 0x38
   211ce:	4293      	cmp	r3, r2
   211d0:	d301      	bcc.n	211d6 <TCPIP_ARP_HashEntryDelete+0x1a>
        {   // we remove this one
            pRemList = &pArpDcpt->incompleteList;
   211d2:	302c      	adds	r0, #44	; 0x2c
        }
    }

    if(pRemList == 0)
   211d4:	e000      	b.n	211d8 <TCPIP_ARP_HashEntryDelete+0x1c>
    {   // no luck with the incomplete list; use the complete one
            pRemList = &pArpDcpt->completeList;
   211d6:	3018      	adds	r0, #24
    }

    pN = TCPIP_Helper_ProtectedSingleListHeadRemove(pRemList);
   211d8:	f000 fbf6 	bl	219c8 <TCPIP_Helper_ProtectedSingleListHeadRemove>

    if(pN)
   211dc:	4603      	mov	r3, r0
   211de:	b100      	cbz	r0, 211e2 <TCPIP_ARP_HashEntryDelete+0x26>
    {
        pE = (ARP_HASH_ENTRY*) ((uint8_t*)pN - offsetof(struct _TAG_ARP_HASH_ENTRY, next));
        return &pE->hEntry;    
   211e0:	1f03      	subs	r3, r0, #4

    // it's possible to be unable to make room in the cache
    // for example, too many permanent entries added...
                   
    return 0;
}
   211e2:	4618      	mov	r0, r3
   211e4:	bd08      	pop	{r3, pc}
   211e6:	bf00      	nop
   211e8:	2000e974 	.word	0x2000e974

Disassembly of section .rodata.iperfCmdTbl%771:

000211ec <iperfCmdTbl>:
   211ec:	000064dc 0000797d 000064e4 000064fc     .d..}y...d...d..
   211fc:	00018055 00006504 00006518 00013a41     U....e...e..A:..
   2120c:	00006520 00006544 0001191d 0000654c      e..De......Le..

Disassembly of section .text.TCPIP_IPV4_CheckPktTx%772:

0002121c <TCPIP_IPV4_CheckPktTx>:
{
   2121c:	b538      	push	{r3, r4, r5, lr}
    if(pPkt->next == 0)
   2121e:	680d      	ldr	r5, [r1, #0]
   21220:	b115      	cbz	r5, 21228 <TCPIP_IPV4_CheckPktTx+0xc>
    TCPIP_NET_IF* pNetIf = 0;
   21222:	2300      	movs	r3, #0
}
   21224:	4618      	mov	r0, r3
   21226:	bd38      	pop	{r3, r4, r5, pc}
   21228:	460c      	mov	r4, r1
        if((pNetIf = _TCPIPStackHandleToNetLinked(hNet)) != 0)
   2122a:	f001 fd09 	bl	22c40 <_TCPIPStackHandleToNetLinked>
   2122e:	4603      	mov	r3, r0
   21230:	2800      	cmp	r0, #0
   21232:	d0f7      	beq.n	21224 <TCPIP_IPV4_CheckPktTx+0x8>
    return pNetIf->Flags.bInConfig != 0;
   21234:	f890 2043 	ldrb.w	r2, [r0, #67]	; 0x43
            if(_TCPIPStackIsConfig(pNetIf) && (pPkt->pktFlags & TCPIP_MAC_PKT_FLAG_CONFIG) == 0)
   21238:	f012 0f10 	tst.w	r2, #16
   2123c:	d0f2      	beq.n	21224 <TCPIP_IPV4_CheckPktTx+0x8>
   2123e:	f9b4 2022 	ldrsh.w	r2, [r4, #34]	; 0x22
                pNetIf = 0;
   21242:	ea13 0322 	ands.w	r3, r3, r2, asr #32
   21246:	bf38      	it	cc
   21248:	462b      	movcc	r3, r5
   2124a:	e7eb      	b.n	21224 <TCPIP_IPV4_CheckPktTx+0x8>

Disassembly of section .text.fnv_32_hash%773:

0002124c <fnv_32_hash>:

#include "tcpip/src/hash_fnv.h"


uint32_t fnv_32_hash(const void *key, size_t keyLen)
{
   2124c:	4602      	mov	r2, r0
    size_t      ix;
    uint32_t    hval = FNV_32_INIT;
    
    const uint8_t* p = (const uint8_t*)key;

    for(ix = 0; ix < keyLen; ix++)
   2124e:	b189      	cbz	r1, 21274 <fnv_32_hash+0x28>
   21250:	1841      	adds	r1, r0, r1
    uint32_t    hval = FNV_32_INIT;
   21252:	4809      	ldr	r0, [pc, #36]	; (21278 <fnv_32_hash+0x2c>)
    {
#if defined(NO_FNV_GCC_OPTIMIZATION)
        hval *= FNV_32_PRIME;
#else
        hval += (hval<<1) + (hval<<4) + (hval<<7) + (hval<<8) + (hval<<24);
   21254:	0103      	lsls	r3, r0, #4
   21256:	eb03 0340 	add.w	r3, r3, r0, lsl #1
   2125a:	4403      	add	r3, r0
   2125c:	eb03 13c0 	add.w	r3, r3, r0, lsl #7
   21260:	eb03 2300 	add.w	r3, r3, r0, lsl #8
   21264:	eb03 6300 	add.w	r3, r3, r0, lsl #24
#endif
        hval ^= (uint32_t)*p++;
   21268:	f812 0b01 	ldrb.w	r0, [r2], #1
   2126c:	4058      	eors	r0, r3
    for(ix = 0; ix < keyLen; ix++)
   2126e:	4291      	cmp	r1, r2
   21270:	d1f0      	bne.n	21254 <fnv_32_hash+0x8>
   21272:	4770      	bx	lr
    uint32_t    hval = FNV_32_INIT;
   21274:	4800      	ldr	r0, [pc, #0]	; (21278 <fnv_32_hash+0x2c>)
    }
    return hval;
}
   21276:	4770      	bx	lr
   21278:	811c9dc5 	.word	0x811c9dc5

Disassembly of section .text.TCPIP_OAHASH_EntriesRemoveAll%774:

0002127c <TCPIP_OAHASH_EntriesRemoveAll>:
    pBkt = (OA_HASH_ENTRY*)pOH->memBlk;
   2127c:	6803      	ldr	r3, [r0, #0]
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   2127e:	68c2      	ldr	r2, [r0, #12]
   21280:	b19a      	cbz	r2, 212aa <TCPIP_OAHASH_EntriesRemoveAll+0x2e>
   21282:	2200      	movs	r2, #0
   21284:	e005      	b.n	21292 <TCPIP_OAHASH_EntriesRemoveAll+0x16>
        pBkt = (OA_HASH_ENTRY*)((uint8_t*)pBkt + pOH->hEntrySize);
   21286:	6881      	ldr	r1, [r0, #8]
   21288:	440b      	add	r3, r1
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   2128a:	3201      	adds	r2, #1
   2128c:	68c1      	ldr	r1, [r0, #12]
   2128e:	4291      	cmp	r1, r2
   21290:	d90b      	bls.n	212aa <TCPIP_OAHASH_EntriesRemoveAll+0x2e>
        if(pBkt->flags.busy)
   21292:	7819      	ldrb	r1, [r3, #0]
   21294:	f011 0f01 	tst.w	r1, #1
   21298:	d0f5      	beq.n	21286 <TCPIP_OAHASH_EntriesRemoveAll+0xa>
        pOE->flags.busy = 0;
   2129a:	7819      	ldrb	r1, [r3, #0]
   2129c:	f36f 0100 	bfc	r1, #0, #1
   212a0:	7019      	strb	r1, [r3, #0]
        pOH->fullSlots--;
   212a2:	6a41      	ldr	r1, [r0, #36]	; 0x24
   212a4:	3901      	subs	r1, #1
   212a6:	6241      	str	r1, [r0, #36]	; 0x24
   212a8:	e7ed      	b.n	21286 <TCPIP_OAHASH_EntriesRemoveAll+0xa>
}
   212aa:	4770      	bx	lr

Disassembly of section .text.TCPIP_Helper_StringToPowerMode%775:

000212ac <TCPIP_Helper_StringToPowerMode>:
    if(str)
   212ac:	b188      	cbz	r0, 212d2 <TCPIP_Helper_StringToPowerMode+0x26>
{
   212ae:	b570      	push	{r4, r5, r6, lr}
   212b0:	4605      	mov	r5, r0
        pEntry = TCPIP_MAC_POWER_TBL + 0;
   212b2:	4c09      	ldr	r4, [pc, #36]	; (212d8 <TCPIP_Helper_StringToPowerMode+0x2c>)
        for(pwrIx = 0; pwrIx < sizeof(TCPIP_MAC_POWER_TBL)/sizeof(*TCPIP_MAC_POWER_TBL); pwrIx++, pEntry++)
   212b4:	f104 0620 	add.w	r6, r4, #32
   212b8:	3408      	adds	r4, #8
   212ba:	42b4      	cmp	r4, r6
   212bc:	d00a      	beq.n	212d4 <TCPIP_Helper_StringToPowerMode+0x28>
            if(pEntry->pwrName)
   212be:	6861      	ldr	r1, [r4, #4]
   212c0:	2900      	cmp	r1, #0
   212c2:	d0f9      	beq.n	212b8 <TCPIP_Helper_StringToPowerMode+0xc>
                if(!strcmp(str, pEntry->pwrName))
   212c4:	4628      	mov	r0, r5
   212c6:	f002 fc99 	bl	23bfc <strcmp>
   212ca:	2800      	cmp	r0, #0
   212cc:	d1f4      	bne.n	212b8 <TCPIP_Helper_StringToPowerMode+0xc>
                    return pEntry->pwrMode;
   212ce:	7820      	ldrb	r0, [r4, #0]
   212d0:	e001      	b.n	212d6 <TCPIP_Helper_StringToPowerMode+0x2a>
   212d2:	4770      	bx	lr
    return TCPIP_MAC_POWER_NONE;
   212d4:	2000      	movs	r0, #0
}
   212d6:	bd70      	pop	{r4, r5, r6, pc}
   212d8:	00022c00 	.word	0x00022c00

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListDeinitialize%776:

000212dc <TCPIP_Helper_ProtectedSingleListDeinitialize>:
    return pL->semValid;
}

void  TCPIP_Helper_ProtectedSingleListDeinitialize(PROTECTED_SINGLE_LIST* pL)
{
    if(pL->semValid)
   212dc:	7c03      	ldrb	r3, [r0, #16]
   212de:	b903      	cbnz	r3, 212e2 <TCPIP_Helper_ProtectedSingleListDeinitialize+0x6>
   212e0:	4770      	bx	lr
{
   212e2:	b570      	push	{r4, r5, r6, lr}
   212e4:	4604      	mov	r4, r0
    {
        if (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
   212e6:	f100 060c 	add.w	r6, r0, #12
   212ea:	f64f 71ff 	movw	r1, #65535	; 0xffff
   212ee:	4630      	mov	r0, r6
   212f0:	f001 fe00 	bl	22ef4 <OSAL_SEM_Pend>
        {
            //SYS_DEBUG LOG
        }
        TCPIP_Helper_SingleListRemoveAll(&pL->list);
   212f4:	4625      	mov	r5, r4


// no memory de-allocation is performed, just removes the nodes from the list
static __inline__ void __attribute__((always_inline)) TCPIP_Helper_SingleListRemoveAll(SINGLE_LIST* pL)
{
	while((TCPIP_Helper_SingleListHeadRemove(pL)));
   212f6:	4628      	mov	r0, r5
   212f8:	f001 feb6 	bl	23068 <TCPIP_Helper_SingleListHeadRemove>
   212fc:	2800      	cmp	r0, #0
   212fe:	d1fa      	bne.n	212f6 <TCPIP_Helper_ProtectedSingleListDeinitialize+0x1a>
        OSAL_SEM_Delete(&pL->semaphore);
   21300:	4630      	mov	r0, r6
   21302:	f002 fcbc 	bl	23c7e <OSAL_SEM_Delete>
        pL->semValid = false;
   21306:	2300      	movs	r3, #0
   21308:	7423      	strb	r3, [r4, #16]
    }
}
   2130a:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListNodeRemove%777:

0002130c <TCPIP_Helper_ProtectedSingleListNodeRemove>:

// removes a node anywhere in the list
// Note: this is lengthy!
// Use a double linked list if faster operation needed!
SGL_LIST_NODE*  TCPIP_Helper_ProtectedSingleListNodeRemove(PROTECTED_SINGLE_LIST* pL, SGL_LIST_NODE* pN)
{
   2130c:	b570      	push	{r4, r5, r6, lr}

    if(pL->semValid)
   2130e:	7c03      	ldrb	r3, [r0, #16]
   21310:	b913      	cbnz	r3, 21318 <TCPIP_Helper_ProtectedSingleListNodeRemove+0xc>
            //SYS_DEBUG LOG
        }
        return ret;
    }

    return 0;
   21312:	2400      	movs	r4, #0
}
   21314:	4620      	mov	r0, r4
   21316:	bd70      	pop	{r4, r5, r6, pc}
   21318:	460d      	mov	r5, r1
   2131a:	4604      	mov	r4, r0
        if (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
   2131c:	f100 060c 	add.w	r6, r0, #12
   21320:	f64f 71ff 	movw	r1, #65535	; 0xffff
   21324:	4630      	mov	r0, r6
   21326:	f001 fde5 	bl	22ef4 <OSAL_SEM_Pend>
        SGL_LIST_NODE * ret = TCPIP_Helper_SingleListNodeRemove(&pL->list, pN);
   2132a:	4629      	mov	r1, r5
   2132c:	4620      	mov	r0, r4
   2132e:	f7fd ff4e 	bl	1f1ce <TCPIP_Helper_SingleListNodeRemove>
   21332:	4604      	mov	r4, r0
        if (OSAL_SEM_Post(&pL->semaphore) != OSAL_RESULT_TRUE)
   21334:	4630      	mov	r0, r6
   21336:	f002 fa29 	bl	2378c <OSAL_SEM_Post>
        return ret;
   2133a:	e7eb      	b.n	21314 <TCPIP_Helper_ProtectedSingleListNodeRemove+0x8>

Disassembly of section .text.TCPIP_STACK_InitializeDataGet%778:

0002133c <TCPIP_STACK_InitializeDataGet>:
    if(object != (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data)
   2133c:	4b09      	ldr	r3, [pc, #36]	; (21364 <TCPIP_STACK_InitializeDataGet+0x28>)
   2133e:	4283      	cmp	r3, r0
   21340:	d10c      	bne.n	2135c <TCPIP_STACK_InitializeDataGet+0x20>
    if(pStackInit)
   21342:	b169      	cbz	r1, 21360 <TCPIP_STACK_InitializeDataGet+0x24>
{
   21344:	b430      	push	{r4, r5}
        *pStackInit = tcpip_init_data;
   21346:	460c      	mov	r4, r1
   21348:	4d07      	ldr	r5, [pc, #28]	; (21368 <TCPIP_STACK_InitializeDataGet+0x2c>)
   2134a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   2134c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   2134e:	e895 0003 	ldmia.w	r5, {r0, r1}
   21352:	e884 0003 	stmia.w	r4, {r0, r1}
    return true;
   21356:	2001      	movs	r0, #1
}
   21358:	bc30      	pop	{r4, r5}
   2135a:	4770      	bx	lr
        return false;
   2135c:	2000      	movs	r0, #0
   2135e:	4770      	bx	lr
    return true;
   21360:	2001      	movs	r0, #1
}
   21362:	4770      	bx	lr
   21364:	2000eae4 	.word	0x2000eae4
   21368:	2000ec10 	.word	0x2000ec10

Disassembly of section .text.TCPIP_PKT_Initialize%779:

0002136c <TCPIP_PKT_Initialize>:
{
   2136c:	b510      	push	{r4, lr}
    pktMemH = 0;
   2136e:	4b0a      	ldr	r3, [pc, #40]	; (21398 <TCPIP_PKT_Initialize+0x2c>)
   21370:	2200      	movs	r2, #0
   21372:	601a      	str	r2, [r3, #0]
    while(heapH != 0)
   21374:	b150      	cbz	r0, 2138c <TCPIP_PKT_Initialize+0x20>
   21376:	4604      	mov	r4, r0
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
   21378:	6843      	ldr	r3, [r0, #4]
   2137a:	2134      	movs	r1, #52	; 0x34
   2137c:	4798      	blx	r3
        if(allocPtr == 0)
   2137e:	4601      	mov	r1, r0
   21380:	b120      	cbz	r0, 2138c <TCPIP_PKT_Initialize+0x20>
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   21382:	68e3      	ldr	r3, [r4, #12]
   21384:	4620      	mov	r0, r4
   21386:	4798      	blx	r3
        pktMemH = heapH;
   21388:	4b03      	ldr	r3, [pc, #12]	; (21398 <TCPIP_PKT_Initialize+0x2c>)
   2138a:	601c      	str	r4, [r3, #0]
    return pktMemH != 0;
   2138c:	4b02      	ldr	r3, [pc, #8]	; (21398 <TCPIP_PKT_Initialize+0x2c>)
   2138e:	6818      	ldr	r0, [r3, #0]
}
   21390:	3000      	adds	r0, #0
   21392:	bf18      	it	ne
   21394:	2001      	movne	r0, #1
   21396:	bd10      	pop	{r4, pc}
   21398:	2000ee84 	.word	0x2000ee84

Disassembly of section .text.TCPIP_UDP_Close%780:

0002139c <TCPIP_UDP_Close>:
{
   2139c:	b538      	push	{r3, r4, r5, lr}
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   2139e:	f000 fed5 	bl	2214c <_UDPSocketDcpt>
    if(pSkt)
   213a2:	b908      	cbnz	r0, 213a8 <TCPIP_UDP_Close+0xc>
    return false;
   213a4:	2000      	movs	r0, #0
}
   213a6:	bd38      	pop	{r3, r4, r5, pc}
   213a8:	4604      	mov	r4, r0
    OSAL_SEM_Pend(&userSem, OSAL_WAIT_FOREVER);
   213aa:	4d07      	ldr	r5, [pc, #28]	; (213c8 <TCPIP_UDP_Close+0x2c>)
   213ac:	f64f 71ff 	movw	r1, #65535	; 0xffff
   213b0:	4628      	mov	r0, r5
   213b2:	f001 fd9f 	bl	22ef4 <OSAL_SEM_Pend>
        _UDPClose(pSkt);
   213b6:	4620      	mov	r0, r4
   213b8:	f7fd faa8 	bl	1e90c <_UDPClose>
    OSAL_SEM_Post(&userSem);
   213bc:	4628      	mov	r0, r5
   213be:	f002 f9e5 	bl	2378c <OSAL_SEM_Post>
        return true;
   213c2:	2001      	movs	r0, #1
   213c4:	e7ef      	b.n	213a6 <TCPIP_UDP_Close+0xa>
   213c6:	bf00      	nop
   213c8:	2000ee9c 	.word	0x2000ee9c

Disassembly of section .text.TCPIP_DHCPS_GetArrayOfDataFromUDPBuff%781:

000213cc <TCPIP_DHCPS_GetArrayOfDataFromUDPBuff>:
{
   213cc:	b570      	push	{r4, r5, r6, lr}
    int nBytes = getbuf->endPtr - getbuf->wrPtr;
   213ce:	6843      	ldr	r3, [r0, #4]
   213d0:	6884      	ldr	r4, [r0, #8]
    if(nBytes == 0)
   213d2:	1ae4      	subs	r4, r4, r3
   213d4:	d00d      	beq.n	213f2 <TCPIP_DHCPS_GetArrayOfDataFromUDPBuff+0x26>
    if(bytes < nBytes)
   213d6:	4294      	cmp	r4, r2
   213d8:	bfa8      	it	ge
   213da:	4614      	movge	r4, r2
    if(buf == NULL)
   213dc:	b159      	cbz	r1, 213f6 <TCPIP_DHCPS_GetArrayOfDataFromUDPBuff+0x2a>
   213de:	460e      	mov	r6, r1
   213e0:	4605      	mov	r5, r0
    memcpy(buf,getbuf->wrPtr,nBytes);
   213e2:	4622      	mov	r2, r4
   213e4:	4619      	mov	r1, r3
   213e6:	4630      	mov	r0, r6
   213e8:	f001 ff80 	bl	232ec <memcpy>
    getbuf->wrPtr = getbuf->wrPtr+nBytes;
   213ec:	686b      	ldr	r3, [r5, #4]
   213ee:	4423      	add	r3, r4
   213f0:	606b      	str	r3, [r5, #4]
}
   213f2:	4620      	mov	r0, r4
   213f4:	bd70      	pop	{r4, r5, r6, pc}
        getbuf->wrPtr = getbuf->wrPtr+nBytes;
   213f6:	4423      	add	r3, r4
   213f8:	6043      	str	r3, [r0, #4]
        return nBytes;
   213fa:	e7fa      	b.n	213f2 <TCPIP_DHCPS_GetArrayOfDataFromUDPBuff+0x26>

Disassembly of section .text.SendCommandCharacter%782:

000213fc <SendCommandCharacter>:
{
   213fc:	b500      	push	{lr}
   213fe:	b083      	sub	sp, #12
   21400:	f88d 1007 	strb.w	r1, [sp, #7]
    if (SYS_CONSOLE_Status((SYS_MODULE_OBJ)_cmdInitData.consoleIndex) == SYS_STATUS_READY)
   21404:	4b08      	ldr	r3, [pc, #32]	; (21428 <SendCommandCharacter+0x2c>)
   21406:	8858      	ldrh	r0, [r3, #2]
   21408:	f7fd f860 	bl	1e4cc <SYS_CONSOLE_Status>
   2140c:	2802      	cmp	r0, #2
   2140e:	d002      	beq.n	21416 <SendCommandCharacter+0x1a>
}
   21410:	b003      	add	sp, #12
   21412:	f85d fb04 	ldr.w	pc, [sp], #4
        SYS_CONSOLE_Write(_cmdInitData.consoleIndex, (const char*)&c, 1);
   21416:	2201      	movs	r2, #1
   21418:	f10d 0107 	add.w	r1, sp, #7
   2141c:	4b02      	ldr	r3, [pc, #8]	; (21428 <SendCommandCharacter+0x2c>)
   2141e:	8858      	ldrh	r0, [r3, #2]
   21420:	f7ff fca2 	bl	20d68 <SYS_CONSOLE_Write>
}
   21424:	e7f4      	b.n	21410 <SendCommandCharacter+0x14>
   21426:	bf00      	nop
   21428:	2000eed0 	.word	0x2000eed0

Disassembly of section .text._keyEndProcess%783:

0002142c <_keyEndProcess>:
    int nChars = pCmdIO->cmdEnd - pCmdIO->cmdPnt;
   2142c:	69c2      	ldr	r2, [r0, #28]
   2142e:	6983      	ldr	r3, [r0, #24]
    if(nChars)
   21430:	1ad2      	subs	r2, r2, r3
   21432:	d010      	beq.n	21456 <_keyEndProcess+0x2a>
{   // end key
   21434:	b570      	push	{r4, r5, r6, lr}
   21436:	b084      	sub	sp, #16
   21438:	4604      	mov	r4, r0
    const SYS_CMD_API* pCmdApi = pCmdIO->devNode.pCmdApi;
   2143a:	6806      	ldr	r6, [r0, #0]
    const void* cmdIoParam = pCmdIO->devNode.cmdIoParam;
   2143c:	6845      	ldr	r5, [r0, #4]
        sprintf(endBuff, "\x1b[%dC", nChars);
   2143e:	4906      	ldr	r1, [pc, #24]	; (21458 <_keyEndProcess+0x2c>)
   21440:	a801      	add	r0, sp, #4
   21442:	f7fe f909 	bl	1f658 <siprintf>
        (*pCmdApi->msg)(cmdIoParam, endBuff);
   21446:	6833      	ldr	r3, [r6, #0]
   21448:	a901      	add	r1, sp, #4
   2144a:	4628      	mov	r0, r5
   2144c:	4798      	blx	r3
        pCmdIO->cmdPnt = pCmdIO->cmdEnd;
   2144e:	69e3      	ldr	r3, [r4, #28]
   21450:	61a3      	str	r3, [r4, #24]
}
   21452:	b004      	add	sp, #16
   21454:	bd70      	pop	{r4, r5, r6, pc}
   21456:	4770      	bx	lr
   21458:	0000ea30 	.word	0x0000ea30

Disassembly of section .text._keyHomeProcess%784:

0002145c <_keyHomeProcess>:
{   // home key
   2145c:	b5f0      	push	{r4, r5, r6, r7, lr}
   2145e:	b085      	sub	sp, #20
    int nChars = pCmdIO->cmdPnt - pCmdIO->cmdBuff;
   21460:	f100 0520 	add.w	r5, r0, #32
   21464:	6982      	ldr	r2, [r0, #24]
    if(nChars != 0)
   21466:	1b52      	subs	r2, r2, r5
   21468:	d00b      	beq.n	21482 <_keyHomeProcess+0x26>
   2146a:	4604      	mov	r4, r0
    const SYS_CMD_API* pCmdApi = pCmdIO->devNode.pCmdApi;
   2146c:	6807      	ldr	r7, [r0, #0]
    const void* cmdIoParam = pCmdIO->devNode.cmdIoParam;
   2146e:	6846      	ldr	r6, [r0, #4]
        sprintf(homeBuff, "\x1b[%dD", nChars);
   21470:	4905      	ldr	r1, [pc, #20]	; (21488 <_keyHomeProcess+0x2c>)
   21472:	a801      	add	r0, sp, #4
   21474:	f7fe f8f0 	bl	1f658 <siprintf>
        (*pCmdApi->msg)(cmdIoParam, homeBuff);
   21478:	683b      	ldr	r3, [r7, #0]
   2147a:	a901      	add	r1, sp, #4
   2147c:	4630      	mov	r0, r6
   2147e:	4798      	blx	r3
        pCmdIO->cmdPnt = pCmdIO->cmdBuff;
   21480:	61a5      	str	r5, [r4, #24]
}
   21482:	b005      	add	sp, #20
   21484:	bdf0      	pop	{r4, r5, r6, r7, pc}
   21486:	bf00      	nop
   21488:	0000ea38 	.word	0x0000ea38

Disassembly of section .text.SYS_CONSOLE_Message%785:

0002148c <SYS_CONSOLE_Message>:

void SYS_CONSOLE_Message(const SYS_CONSOLE_HANDLE handle, const char *message)
{
    SYS_CONSOLE_OBJECT_INSTANCE* pConsoleObj = SYS_CONSOLE_GET_INSTANCE(handle);
   2148c:	b990      	cbnz	r0, 214b4 <SYS_CONSOLE_Message+0x28>
{
   2148e:	b538      	push	{r3, r4, r5, lr}
    if (pConsoleObj == NULL)
    {
        return;
    }

    if (pConsoleObj->status == SYS_STATUS_UNINITIALIZED || pConsoleObj->devDesc == NULL)
   21490:	4b09      	ldr	r3, [pc, #36]	; (214b8 <SYS_CONSOLE_Message+0x2c>)
   21492:	f993 3000 	ldrsb.w	r3, [r3]
   21496:	b163      	cbz	r3, 214b2 <SYS_CONSOLE_Message+0x26>
   21498:	4b07      	ldr	r3, [pc, #28]	; (214b8 <SYS_CONSOLE_Message+0x2c>)
   2149a:	685d      	ldr	r5, [r3, #4]
   2149c:	b14d      	cbz	r5, 214b2 <SYS_CONSOLE_Message+0x26>
   2149e:	460c      	mov	r4, r1
    {
        return;
    }

    pConsoleObj->devDesc->write(pConsoleObj->devIndex, message, strlen(message));
   214a0:	4608      	mov	r0, r1
   214a2:	f002 fd0d 	bl	23ec0 <strlen>
   214a6:	696b      	ldr	r3, [r5, #20]
   214a8:	4602      	mov	r2, r0
   214aa:	4621      	mov	r1, r4
   214ac:	4802      	ldr	r0, [pc, #8]	; (214b8 <SYS_CONSOLE_Message+0x2c>)
   214ae:	6880      	ldr	r0, [r0, #8]
   214b0:	4798      	blx	r3
}
   214b2:	bd38      	pop	{r3, r4, r5, pc}
   214b4:	4770      	bx	lr
   214b6:	bf00      	nop
   214b8:	2000ed64 	.word	0x2000ed64

Disassembly of section .text.SYS_TIME_UpdateTimerList%786:

000214bc <SYS_TIME_UpdateTimerList>:
    tmr = counterObj->tmrActive;
   214bc:	4b0a      	ldr	r3, [pc, #40]	; (214e8 <SYS_TIME_UpdateTimerList+0x2c>)
   214be:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    while ((tmr != NULL) && (elapsedCount > 0))
   214c0:	b173      	cbz	r3, 214e0 <SYS_TIME_UpdateTimerList+0x24>
   214c2:	b168      	cbz	r0, 214e0 <SYS_TIME_UpdateTimerList+0x24>
            tmr->relativeTimePending = 0;
   214c4:	2100      	movs	r1, #0
   214c6:	e005      	b.n	214d4 <SYS_TIME_UpdateTimerList+0x18>
            elapsedCount -= tmr->relativeTimePending;
   214c8:	689a      	ldr	r2, [r3, #8]
   214ca:	1a80      	subs	r0, r0, r2
            tmr->relativeTimePending = 0;
   214cc:	6099      	str	r1, [r3, #8]
        tmr = tmr->tmrNext;
   214ce:	699b      	ldr	r3, [r3, #24]
    while ((tmr != NULL) && (elapsedCount > 0))
   214d0:	b133      	cbz	r3, 214e0 <SYS_TIME_UpdateTimerList+0x24>
   214d2:	b128      	cbz	r0, 214e0 <SYS_TIME_UpdateTimerList+0x24>
        if (tmr->relativeTimePending >= elapsedCount)
   214d4:	689a      	ldr	r2, [r3, #8]
   214d6:	4282      	cmp	r2, r0
   214d8:	d3f6      	bcc.n	214c8 <SYS_TIME_UpdateTimerList+0xc>
            tmr->relativeTimePending -= elapsedCount;
   214da:	689a      	ldr	r2, [r3, #8]
   214dc:	1a10      	subs	r0, r2, r0
   214de:	6098      	str	r0, [r3, #8]
    counterObj->hwTimerPreviousValue = counterObj->hwTimerCurrentValue;
   214e0:	4b01      	ldr	r3, [pc, #4]	; (214e8 <SYS_TIME_UpdateTimerList+0x2c>)
   214e2:	695a      	ldr	r2, [r3, #20]
   214e4:	611a      	str	r2, [r3, #16]
}
   214e6:	4770      	bx	lr
   214e8:	2000ea00 	.word	0x2000ea00

Disassembly of section .text.xQueueGenericCreate%787:

000214ec <xQueueGenericCreate>:
	{
   214ec:	b570      	push	{r4, r5, r6, lr}
   214ee:	4606      	mov	r6, r0
   214f0:	460d      	mov	r5, r1
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   214f2:	fb01 f000 	mul.w	r0, r1, r0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
   214f6:	3048      	adds	r0, #72	; 0x48
   214f8:	f7fb f906 	bl	1c708 <pvPortMalloc>
		if( pxNewQueue != NULL )
   214fc:	4604      	mov	r4, r0
   214fe:	b148      	cbz	r0, 21514 <xQueueGenericCreate+0x28>
	if( uxItemSize == ( UBaseType_t ) 0 )
   21500:	b155      	cbz	r5, 21518 <xQueueGenericCreate+0x2c>
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
   21502:	f100 0348 	add.w	r3, r0, #72	; 0x48
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
   21506:	6023      	str	r3, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
   21508:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
   2150a:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
   2150c:	2101      	movs	r1, #1
   2150e:	4620      	mov	r0, r4
   21510:	f7fa feda 	bl	1c2c8 <xQueueGenericReset>
	}
   21514:	4620      	mov	r0, r4
   21516:	bd70      	pop	{r4, r5, r6, pc}
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
   21518:	4603      	mov	r3, r0
   2151a:	e7f4      	b.n	21506 <xQueueGenericCreate+0x1a>

Disassembly of section .text.wc_CryptoCb_FindDevice%788:

0002151c <wc_CryptoCb_FindDevice>:
        if (gCryptoDev[i].devId == devId)
   2151c:	4b0a      	ldr	r3, [pc, #40]	; (21548 <wc_CryptoCb_FindDevice+0x2c>)
   2151e:	681b      	ldr	r3, [r3, #0]
   21520:	4298      	cmp	r0, r3
   21522:	d00a      	beq.n	2153a <wc_CryptoCb_FindDevice+0x1e>
   21524:	4a08      	ldr	r2, [pc, #32]	; (21548 <wc_CryptoCb_FindDevice+0x2c>)
    for (i=0; i<MAX_CRYPTO_DEVID_CALLBACKS; i++) {
   21526:	2301      	movs	r3, #1
        if (gCryptoDev[i].devId == devId)
   21528:	68d1      	ldr	r1, [r2, #12]
   2152a:	4281      	cmp	r1, r0
   2152c:	d006      	beq.n	2153c <wc_CryptoCb_FindDevice+0x20>
    for (i=0; i<MAX_CRYPTO_DEVID_CALLBACKS; i++) {
   2152e:	3301      	adds	r3, #1
   21530:	320c      	adds	r2, #12
   21532:	2b08      	cmp	r3, #8
   21534:	d1f8      	bne.n	21528 <wc_CryptoCb_FindDevice+0xc>
    return NULL;
   21536:	2000      	movs	r0, #0
}
   21538:	4770      	bx	lr
    for (i=0; i<MAX_CRYPTO_DEVID_CALLBACKS; i++) {
   2153a:	2300      	movs	r3, #0
            return &gCryptoDev[i];
   2153c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   21540:	4801      	ldr	r0, [pc, #4]	; (21548 <wc_CryptoCb_FindDevice+0x2c>)
   21542:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   21546:	4770      	bx	lr
   21548:	2000e8b4 	.word	0x2000e8b4

Disassembly of section .rodata.seedA_data%789:

0002154c <seedA_data>:
   2154c:	77333663 46861ee4 b40aeb8d 3f68eda8     c63w...F......h?
   2155c:	474e136a 00c714e0 e9814e45 69a55853     j.NG....EN..SX.i
   2156c:	8fa38a80 23a6722a 9f5a9159 68ca048a     ....*r.#Y.Z....h

Disassembly of section .rodata.seedB_data%790:

0002157c <seedB_data>:
   2157c:	f3d05aa6 0e4edb45 c375e8ff 421fe7a2     .Z..E.N...u....B
   2158c:	629d12c7 19c1f50f f055efa9 fbe08551     ...b......U.Q...
   2159c:	31f98185 6e271775 7d60e906 2ecccbdb     ...1u.'n..`}....

Disassembly of section .text.APP_Initialize%791:

000215ac <APP_Initialize>:
{
   215ac:	b508      	push	{r3, lr}
	appData.state = APP_DISPLAY_INIT;    
   215ae:	4b09      	ldr	r3, [pc, #36]	; (215d4 <APP_Initialize+0x28>)
   215b0:	2201      	movs	r2, #1
   215b2:	701a      	strb	r2, [r3, #0]
    LED1_Set();
   215b4:	4b08      	ldr	r3, [pc, #32]	; (215d8 <APP_Initialize+0x2c>)
   215b6:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   215ba:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    LED2_Set();
   215be:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   215c2:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    LED3_Set();
   215c6:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   215ca:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
    MyTxQueueErase();
   215ce:	f000 fb19 	bl	21c04 <MyTxQueueErase>
}
   215d2:	bd08      	pop	{r3, pc}
   215d4:	2000ef70 	.word	0x2000ef70
   215d8:	41008000 	.word	0x41008000

Disassembly of section .text%792:

000215dc <__aeabi_uldivmod>:
   215dc:	b953      	cbnz	r3, 215f4 <__aeabi_uldivmod+0x18>
   215de:	b94a      	cbnz	r2, 215f4 <__aeabi_uldivmod+0x18>
   215e0:	2900      	cmp	r1, #0
   215e2:	bf08      	it	eq
   215e4:	2800      	cmpeq	r0, #0
   215e6:	bf1c      	itt	ne
   215e8:	f04f 31ff 	movne.w	r1, #4294967295
   215ec:	f04f 30ff 	movne.w	r0, #4294967295
   215f0:	f002 bf5c 	b.w	244ac <__aeabi_idiv0>
   215f4:	f1ad 0c08 	sub.w	ip, sp, #8
   215f8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   215fc:	f7ec f896 	bl	d72c <__udivmoddi4>
   21600:	f8dd e004 	ldr.w	lr, [sp, #4]
   21604:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   21608:	b004      	add	sp, #16
   2160a:	4770      	bx	lr

Disassembly of section .text._XtlEventsTcp2Eth%793:

0002160c <_XtlEventsTcp2Eth>:
	eEvents |= (tcpEv&(TCPIP_MAC_EV_RX_DONE))? GMAC_EV_RXCOMPLETE:0;	
   2160c:	10c3      	asrs	r3, r0, #3
   2160e:	f003 0302 	and.w	r3, r3, #2
	eEvents |= (tcpEv&(TCPIP_MAC_EV_RX_OVFLOW))? GMAC_EV_RXOVERRUN:0;
   21612:	0242      	lsls	r2, r0, #9
   21614:	f402 6280 	and.w	r2, r2, #1024	; 0x400
	eEvents |= (tcpEv&(TCPIP_MAC_EV_RX_BUFNA))? GMAC_EV_RXUSEDBITREAD:0; // mapping RX Used bit interrupt to BUFNA;
   21618:	4313      	orrs	r3, r2
   2161a:	f000 0204 	and.w	r2, r0, #4
   2161e:	4313      	orrs	r3, r2
	eEvents |= (tcpEv&(TCPIP_MAC_EV_TX_BUSERR))? GMAC_EV_TXFRAMECORRUPT:0;
   21620:	1102      	asrs	r2, r0, #4
   21622:	f002 0240 	and.w	r2, r2, #64	; 0x40
	eEvents |= (tcpEv&(TCPIP_MAC_EV_RX_BUFNA))? GMAC_EV_RXUSEDBITREAD:0; // mapping RX Used bit interrupt to BUFNA;
   21626:	4313      	orrs	r3, r2
    eEvents |= (tcpEv&(TCPIP_MAC_EV_TX_ABORT))? GMAC_EV_TXUNDERRUN:0;
   21628:	1142      	asrs	r2, r0, #5
   2162a:	f002 0210 	and.w	r2, r2, #16
	eEvents |= (tcpEv&(TCPIP_MAC_EV_RX_BUFNA))? GMAC_EV_RXUSEDBITREAD:0; // mapping RX Used bit interrupt to BUFNA;
   2162e:	4313      	orrs	r3, r2
	eEvents = (tcpEv&(TCPIP_MAC_EV_TX_DONE))? GMAC_EV_TXCOMPLETE:0;	
   21630:	1040      	asrs	r0, r0, #1
   21632:	f000 0080 	and.w	r0, r0, #128	; 0x80
}
   21636:	4318      	orrs	r0, r3
   21638:	4770      	bx	lr

Disassembly of section .text._DRV_MIIM_GetObjectAndLock%794:

0002163a <_DRV_MIIM_GetObjectAndLock>:
{
   2163a:	b510      	push	{r4, lr}
    if(pMiimObj != 0)
   2163c:	b168      	cbz	r0, 2165a <_DRV_MIIM_GetObjectAndLock+0x20>
    pMiimObj = (DRV_MIIM_OBJ*)object;
   2163e:	4604      	mov	r4, r0
        if(pMiimObj->objStatus == SYS_STATUS_READY && (pMiimObj->objFlags & DRV_MIIM_OBJ_FLAG_IN_USE) != 0)
   21640:	f990 2008 	ldrsb.w	r2, [r0, #8]
   21644:	2a02      	cmp	r2, #2
   21646:	d10a      	bne.n	2165e <_DRV_MIIM_GetObjectAndLock+0x24>
   21648:	8882      	ldrh	r2, [r0, #4]
   2164a:	f012 0f01 	tst.w	r2, #1
   2164e:	d009      	beq.n	21664 <_DRV_MIIM_GetObjectAndLock+0x2a>
    OSAL_SEM_Pend(&pMiimObj->objSem, OSAL_WAIT_FOREVER);
   21650:	f64f 71ff 	movw	r1, #65535	; 0xffff
   21654:	f001 fc4e 	bl	22ef4 <OSAL_SEM_Pend>
        return pMiimObj;
   21658:	e002      	b.n	21660 <_DRV_MIIM_GetObjectAndLock+0x26>
    return 0;
   2165a:	2400      	movs	r4, #0
   2165c:	e000      	b.n	21660 <_DRV_MIIM_GetObjectAndLock+0x26>
   2165e:	2400      	movs	r4, #0
}
   21660:	4620      	mov	r0, r4
   21662:	bd10      	pop	{r4, pc}
    return 0;
   21664:	2400      	movs	r4, #0
   21666:	e7fb      	b.n	21660 <_DRV_MIIM_GetObjectAndLock+0x26>

Disassembly of section .text.DRV_MIIM_DeregisterCallback%795:

00021668 <DRV_MIIM_DeregisterCallback>:
{
   21668:	b510      	push	{r4, lr}
   2166a:	460c      	mov	r4, r1
        if((pClient = _DRV_MIIM_GetClientAndLock(handle, true)) == 0)
   2166c:	2101      	movs	r1, #1
   2166e:	f7fc fff4 	bl	1e65a <_DRV_MIIM_GetClientAndLock>
   21672:	b150      	cbz	r0, 2168a <DRV_MIIM_DeregisterCallback+0x22>
   21674:	4603      	mov	r3, r0
        if(pClient->cbackHandler != (DRV_MIIM_OPERATION_CALLBACK)cbHandle)
   21676:	6882      	ldr	r2, [r0, #8]
   21678:	42a2      	cmp	r2, r4
   2167a:	d109      	bne.n	21690 <DRV_MIIM_DeregisterCallback+0x28>
        pClient->cbackHandler = 0;
   2167c:	2400      	movs	r4, #0
   2167e:	6084      	str	r4, [r0, #8]
    OSAL_SEM_Post(&pMiimObj->objSem);
   21680:	6858      	ldr	r0, [r3, #4]
   21682:	f002 f883 	bl	2378c <OSAL_SEM_Post>
}
   21686:	4620      	mov	r0, r4
   21688:	bd10      	pop	{r4, pc}
            res = DRV_MIIM_RES_HANDLE_ERR;
   2168a:	f04f 34ff 	mov.w	r4, #4294967295
   2168e:	e7fa      	b.n	21686 <DRV_MIIM_DeregisterCallback+0x1e>
            res = DRV_MIIM_RES_CALLBACK_HANDLE_ERR;
   21690:	f06f 0402 	mvn.w	r4, #2
   21694:	e7f4      	b.n	21680 <DRV_MIIM_DeregisterCallback+0x18>

Disassembly of section .text.TCPIP_TCP_Connect%796:

00021696 <TCPIP_TCP_Connect>:
{
   21696:	b510      	push	{r4, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   21698:	f000 fc40 	bl	21f1c <_TcpSocketChk>
    if(pSkt && pSkt->smState == TCPIP_TCP_STATE_CLIENT_WAIT_CONNECT)
   2169c:	b180      	cbz	r0, 216c0 <TCPIP_TCP_Connect+0x2a>
   2169e:	4604      	mov	r4, r0
   216a0:	f890 306e 	ldrb.w	r3, [r0, #110]	; 0x6e
   216a4:	2b0b      	cmp	r3, #11
   216a6:	d001      	beq.n	216ac <TCPIP_TCP_Connect+0x16>
    return false;
   216a8:	2000      	movs	r0, #0
}
   216aa:	bd10      	pop	{r4, pc}
        if(_TcpClientSocketConnect(pSkt) >= 0)
   216ac:	f7fb ff34 	bl	1d518 <_TcpClientSocketConnect>
   216b0:	2800      	cmp	r0, #0
   216b2:	da01      	bge.n	216b8 <TCPIP_TCP_Connect+0x22>
    return false;
   216b4:	2000      	movs	r0, #0
   216b6:	e7f8      	b.n	216aa <TCPIP_TCP_Connect+0x14>
    pSkt->smState = newState;
   216b8:	2001      	movs	r0, #1
   216ba:	f884 006e 	strb.w	r0, [r4, #110]	; 0x6e
            return true;
   216be:	e7f4      	b.n	216aa <TCPIP_TCP_Connect+0x14>
    return false;
   216c0:	2000      	movs	r0, #0
   216c2:	e7f2      	b.n	216aa <TCPIP_TCP_Connect+0x14>

Disassembly of section .text._DHCPOptionProcessLease%797:

000216c4 <_DHCPOptionProcessLease>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_LEASE_TIME))
   216c4:	684b      	ldr	r3, [r1, #4]
   216c6:	2b05      	cmp	r3, #5
   216c8:	d90d      	bls.n	216e6 <_DHCPOptionProcessLease+0x22>
        TCPIP_DHCP_OPTION_DATA_LEASE_TIME* pLease = (TCPIP_DHCP_OPTION_DATA_LEASE_TIME*)pOptData->pOpt;
   216ca:	680b      	ldr	r3, [r1, #0]
        if(pLease->len == sizeof(pLease->lease))
   216cc:	785a      	ldrb	r2, [r3, #1]
   216ce:	2a04      	cmp	r2, #4
   216d0:	d10c      	bne.n	216ec <_DHCPOptionProcessLease+0x28>
            pOptData->leaseTime.v[3] = pLease->lease[0];
   216d2:	789a      	ldrb	r2, [r3, #2]
   216d4:	74ca      	strb	r2, [r1, #19]
            pOptData->leaseTime.v[2] = pLease->lease[1];
   216d6:	78da      	ldrb	r2, [r3, #3]
   216d8:	748a      	strb	r2, [r1, #18]
            pOptData->leaseTime.v[1] = pLease->lease[2];
   216da:	791a      	ldrb	r2, [r3, #4]
   216dc:	744a      	strb	r2, [r1, #17]
            pOptData->leaseTime.v[0] = pLease->lease[3];
   216de:	795b      	ldrb	r3, [r3, #5]
   216e0:	740b      	strb	r3, [r1, #16]
            return sizeof(TCPIP_DHCP_OPTION_DATA_LEASE_TIME);
   216e2:	2006      	movs	r0, #6
   216e4:	4770      	bx	lr
    return -1;
   216e6:	f04f 30ff 	mov.w	r0, #4294967295
   216ea:	4770      	bx	lr
   216ec:	f04f 30ff 	mov.w	r0, #4294967295
}
   216f0:	4770      	bx	lr

Disassembly of section .text._DHCPOptionProcessRenewT%798:

000216f2 <_DHCPOptionProcessRenewT>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_RENEW_TIME))
   216f2:	684b      	ldr	r3, [r1, #4]
   216f4:	2b05      	cmp	r3, #5
   216f6:	d90d      	bls.n	21714 <_DHCPOptionProcessRenewT+0x22>
        TCPIP_DHCP_OPTION_DATA_RENEW_TIME* pRenew = (TCPIP_DHCP_OPTION_DATA_RENEW_TIME*)pOptData->pOpt;
   216f8:	680b      	ldr	r3, [r1, #0]
        if(pRenew->len == sizeof(pRenew->tRenew))
   216fa:	785a      	ldrb	r2, [r3, #1]
   216fc:	2a04      	cmp	r2, #4
   216fe:	d10c      	bne.n	2171a <_DHCPOptionProcessRenewT+0x28>
            pOptData->renewTime.v[3] = pRenew->tRenew[0];
   21700:	789a      	ldrb	r2, [r3, #2]
   21702:	75ca      	strb	r2, [r1, #23]
            pOptData->renewTime.v[2] = pRenew->tRenew[1];
   21704:	78da      	ldrb	r2, [r3, #3]
   21706:	758a      	strb	r2, [r1, #22]
            pOptData->renewTime.v[1] = pRenew->tRenew[2];
   21708:	791a      	ldrb	r2, [r3, #4]
   2170a:	754a      	strb	r2, [r1, #21]
            pOptData->renewTime.v[0] = pRenew->tRenew[3];
   2170c:	795b      	ldrb	r3, [r3, #5]
   2170e:	750b      	strb	r3, [r1, #20]
            return sizeof(TCPIP_DHCP_OPTION_DATA_RENEW_TIME);
   21710:	2006      	movs	r0, #6
   21712:	4770      	bx	lr
    return -1;
   21714:	f04f 30ff 	mov.w	r0, #4294967295
   21718:	4770      	bx	lr
   2171a:	f04f 30ff 	mov.w	r0, #4294967295
}
   2171e:	4770      	bx	lr

Disassembly of section .text._DHCPOptionProcessRebindT%799:

00021720 <_DHCPOptionProcessRebindT>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_REBIND_TIME))
   21720:	684b      	ldr	r3, [r1, #4]
   21722:	2b05      	cmp	r3, #5
   21724:	d90d      	bls.n	21742 <_DHCPOptionProcessRebindT+0x22>
        TCPIP_DHCP_OPTION_DATA_REBIND_TIME* pRebind = (TCPIP_DHCP_OPTION_DATA_REBIND_TIME*)pOptData->pOpt;
   21726:	680b      	ldr	r3, [r1, #0]
        if(pRebind->len == sizeof(pRebind->tRebind))
   21728:	785a      	ldrb	r2, [r3, #1]
   2172a:	2a04      	cmp	r2, #4
   2172c:	d10c      	bne.n	21748 <_DHCPOptionProcessRebindT+0x28>
            pOptData->rebindTime.v[3] = pRebind->tRebind[0];
   2172e:	789a      	ldrb	r2, [r3, #2]
   21730:	76ca      	strb	r2, [r1, #27]
            pOptData->rebindTime.v[2] = pRebind->tRebind[1];
   21732:	78da      	ldrb	r2, [r3, #3]
   21734:	768a      	strb	r2, [r1, #26]
            pOptData->rebindTime.v[1] = pRebind->tRebind[2];
   21736:	791a      	ldrb	r2, [r3, #4]
   21738:	764a      	strb	r2, [r1, #25]
            pOptData->rebindTime.v[0] = pRebind->tRebind[3];
   2173a:	795b      	ldrb	r3, [r3, #5]
   2173c:	760b      	strb	r3, [r1, #24]
            return sizeof(TCPIP_DHCP_OPTION_DATA_REBIND_TIME);
   2173e:	2006      	movs	r0, #6
   21740:	4770      	bx	lr
    return -1;
   21742:	f04f 30ff 	mov.w	r0, #4294967295
   21746:	4770      	bx	lr
   21748:	f04f 30ff 	mov.w	r0, #4294967295
}
   2174c:	4770      	bx	lr

Disassembly of section .text._DHCPOptionClientId%800:

0002174e <_DHCPOptionClientId>:
    if(pSendData->writeSpace >= sizeof(*pClientOpt))
   2174e:	684b      	ldr	r3, [r1, #4]
   21750:	2b08      	cmp	r3, #8
   21752:	d910      	bls.n	21776 <_DHCPOptionClientId+0x28>
        pClientOpt = (TCPIP_DHCP_OPTION_DATA_CLIENT_ID*)pSendData->pOpt;
   21754:	680b      	ldr	r3, [r1, #0]
        pClientOpt->opt = TCPIP_DHCP_PARAM_REQUEST_CLIENT_ID;
   21756:	223d      	movs	r2, #61	; 0x3d
   21758:	701a      	strb	r2, [r3, #0]
        pClientOpt->len = sizeof(pClientOpt->cliId);
   2175a:	2207      	movs	r2, #7
   2175c:	705a      	strb	r2, [r3, #1]
        pClientOpt->cliId.type = TCPIP_BOOT_HW_TYPE;    // standard hardware address
   2175e:	2201      	movs	r2, #1
   21760:	709a      	strb	r2, [r3, #2]
        memcpy(pClientOpt->cliId.id, _TCPIPStack_NetMACAddressGet(pNetIf), sizeof(pClientOpt->cliId.id));
   21762:	1cda      	adds	r2, r3, #3
    return pNetIf ? pNetIf->netMACAddr.v : 0;
   21764:	b100      	cbz	r0, 21768 <_DHCPOptionClientId+0x1a>
   21766:	303c      	adds	r0, #60	; 0x3c
   21768:	6801      	ldr	r1, [r0, #0]
   2176a:	f8c3 1003 	str.w	r1, [r3, #3]
   2176e:	8883      	ldrh	r3, [r0, #4]
   21770:	8093      	strh	r3, [r2, #4]
        return sizeof(*pClientOpt);
   21772:	2009      	movs	r0, #9
   21774:	4770      	bx	lr
    return -1;
   21776:	f04f 30ff 	mov.w	r0, #4294967295
}
   2177a:	4770      	bx	lr

Disassembly of section .text._DHCPSetTimeout%801:

0002177c <_DHCPSetTimeout>:
{
   2177c:	b570      	push	{r4, r5, r6, lr}
   2177e:	4606      	mov	r6, r0
    uint32_t sysFreq = SYS_TMR_TickCounterFrequencyGet();
   21780:	f000 fd84 	bl	2228c <SYS_TMR_TickCounterFrequencyGet>
   21784:	4604      	mov	r4, r0
    pClient->waitTicks = (pClient->dhcpTmo - TCPIP_DHCP_EXP_BACKOFF_FUZZ) * sysFreq + SYS_RANDOM_PseudoGet() % ((2 * TCPIP_DHCP_EXP_BACKOFF_FUZZ) * sysFreq);
   21786:	f8b6 504c 	ldrh.w	r5, [r6, #76]	; 0x4c
   2178a:	3d01      	subs	r5, #1
   2178c:	fb00 f505 	mul.w	r5, r0, r5
   21790:	f7fb f9c8 	bl	1cb24 <rand>
   21794:	0064      	lsls	r4, r4, #1
   21796:	fbb0 f3f4 	udiv	r3, r0, r4
   2179a:	fb03 0414 	mls	r4, r3, r4, r0
   2179e:	442c      	add	r4, r5
   217a0:	6034      	str	r4, [r6, #0]
    pClient->startWait = SYS_TMR_TickCountGet();
   217a2:	f000 fd4b 	bl	2223c <SYS_TMR_TickCountGet>
   217a6:	6070      	str	r0, [r6, #4]
}
   217a8:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text._DNS_CleanCacheEntry%802:

000217aa <_DNS_CleanCacheEntry>:
    if(pDnsHE->hEntry.flags.busy)
   217aa:	780b      	ldrb	r3, [r1, #0]
   217ac:	f013 0f01 	tst.w	r3, #1
   217b0:	d011      	beq.n	217d6 <_DNS_CleanCacheEntry+0x2c>
{
   217b2:	b510      	push	{r4, lr}
        if((pDnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) == 0)
   217b4:	880b      	ldrh	r3, [r1, #0]
   217b6:	f013 0f80 	tst.w	r3, #128	; 0x80
   217ba:	d102      	bne.n	217c2 <_DNS_CleanCacheEntry+0x18>
            pDnsDcpt->unsolvedEntries--;
   217bc:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
   217be:	3b01      	subs	r3, #1
   217c0:	84c3      	strh	r3, [r0, #38]	; 0x26
   217c2:	460c      	mov	r4, r1
        TCPIP_OAHASH_EntryRemove(pDnsDcpt->hashDcpt, &pDnsHE->hEntry);
   217c4:	6800      	ldr	r0, [r0, #0]
   217c6:	f001 ff75 	bl	236b4 <TCPIP_OAHASH_EntryRemove>
        pDnsHE->nIPv4Entries = pDnsHE->nIPv6Entries = 0;
   217ca:	2300      	movs	r3, #0
   217cc:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
   217d0:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
}
   217d4:	bd10      	pop	{r4, pc}
   217d6:	4770      	bx	lr

Disassembly of section .text._DNSClientCleanup%803:

000217d8 <_DNSClientCleanup>:
{
   217d8:	b510      	push	{r4, lr}
   217da:	4604      	mov	r4, r0
    if(pDnsDcpt->dnsSocket != INVALID_UDP_SOCKET)
   217dc:	f9b0 0024 	ldrsh.w	r0, [r0, #36]	; 0x24
   217e0:	f1b0 3fff 	cmp.w	r0, #4294967295
   217e4:	d109      	bne.n	217fa <_DNSClientCleanup+0x22>
    if( pDnsDcpt->dnsSignalHandle)
   217e6:	68e0      	ldr	r0, [r4, #12]
   217e8:	b118      	cbz	r0, 217f2 <_DNSClientCleanup+0x1a>
       _TCPIPStackSignalHandlerDeregister( pDnsDcpt->dnsSignalHandle);
   217ea:	f002 fbac 	bl	23f46 <_TCPIPStackSignalHandlerDeregister>
        pDnsDcpt->dnsSignalHandle = 0;
   217ee:	2300      	movs	r3, #0
   217f0:	60e3      	str	r3, [r4, #12]
    _DNS_DeleteHash(pDnsDcpt);
   217f2:	4620      	mov	r0, r4
   217f4:	f7fc fb0e 	bl	1de14 <_DNS_DeleteHash>
}
   217f8:	bd10      	pop	{r4, pc}
        TCPIP_UDP_Close(pDnsDcpt->dnsSocket);
   217fa:	f7ff fdcf 	bl	2139c <TCPIP_UDP_Close>
        pDnsDcpt->dnsSocket = INVALID_UDP_SOCKET;
   217fe:	f64f 73ff 	movw	r3, #65535	; 0xffff
   21802:	84a3      	strh	r3, [r4, #36]	; 0x24
   21804:	e7ef      	b.n	217e6 <_DNSClientCleanup+0xe>

Disassembly of section .text.TCPIP_STACK_DNSServiceCanStart%804:

00021806 <TCPIP_STACK_DNSServiceCanStart>:
    if(pNetIf)
   21806:	b198      	cbz	r0, 21830 <TCPIP_STACK_DNSServiceCanStart+0x2a>
        if(dnsSvcType == TCPIP_STACK_DNS_SERVICE_SERVER)
   21808:	2902      	cmp	r1, #2
   2180a:	d003      	beq.n	21814 <TCPIP_STACK_DNSServiceCanStart+0xe>
        else if(dnsSvcType == TCPIP_STACK_DNS_SERVICE_CLIENT)
   2180c:	2901      	cmp	r1, #1
   2180e:	d008      	beq.n	21822 <TCPIP_STACK_DNSServiceCanStart+0x1c>
    return false;
   21810:	2000      	movs	r0, #0
}
   21812:	4770      	bx	lr
            return (pNetIf->Flags.bIsDnsClientEnabled == 0);
   21814:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
   21818:	f080 0008 	eor.w	r0, r0, #8
   2181c:	f3c0 00c0 	ubfx	r0, r0, #3, #1
   21820:	4770      	bx	lr
            return (pNetIf->Flags.bIsDnsServerEnabled == 0);
   21822:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
   21826:	f080 0010 	eor.w	r0, r0, #16
   2182a:	f3c0 1000 	ubfx	r0, r0, #4, #1
   2182e:	4770      	bx	lr
    return false;
   21830:	2000      	movs	r0, #0
   21832:	4770      	bx	lr

Disassembly of section .text._TxSktGetLockedV4Pkt%805:

00021834 <_TxSktGetLockedV4Pkt>:
{
   21834:	b570      	push	{r4, r5, r6, lr}
   21836:	4605      	mov	r5, r0
   21838:	460e      	mov	r6, r1
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   2183a:	2000      	movs	r0, #0
   2183c:	f001 ff9a 	bl	23774 <OSAL_CRIT_Enter>
   21840:	4601      	mov	r1, r0
    if((pPkt = pSkt->pV4Pkt) != 0)
   21842:	68ec      	ldr	r4, [r5, #12]
   21844:	b134      	cbz	r4, 21854 <_TxSktGetLockedV4Pkt+0x20>
        if((pPkt->macPkt.pktFlags & TCPIP_MAC_PKT_FLAG_QUEUED) != 0)
   21846:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   21848:	f013 0f08 	tst.w	r3, #8
   2184c:	d002      	beq.n	21854 <_TxSktGetLockedV4Pkt+0x20>
            if(clrSktPkt)
   2184e:	b136      	cbz	r6, 2185e <_TxSktGetLockedV4Pkt+0x2a>
                pSkt->pV4Pkt = 0;
   21850:	2400      	movs	r4, #0
   21852:	60ec      	str	r4, [r5, #12]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   21854:	2000      	movs	r0, #0
   21856:	f002 f8c7 	bl	239e8 <OSAL_CRIT_Leave>
}
   2185a:	4620      	mov	r0, r4
   2185c:	bd70      	pop	{r4, r5, r6, pc}
            pPkt = 0;
   2185e:	2400      	movs	r4, #0
   21860:	e7f8      	b.n	21854 <_TxSktGetLockedV4Pkt+0x20>

Disassembly of section .text.wc_CryptoCb_RegisterDevice%806:

00021862 <wc_CryptoCb_RegisterDevice>:
{
   21862:	b570      	push	{r4, r5, r6, lr}
   21864:	4606      	mov	r6, r0
   21866:	460d      	mov	r5, r1
   21868:	4614      	mov	r4, r2
    CryptoCb* dev = wc_CryptoCb_FindDevice(devId);
   2186a:	f7ff fe57 	bl	2151c <wc_CryptoCb_FindDevice>
    if (dev == NULL)
   2186e:	4603      	mov	r3, r0
   21870:	b120      	cbz	r0, 2187c <wc_CryptoCb_RegisterDevice+0x1a>
    dev->devId = devId;
   21872:	601e      	str	r6, [r3, #0]
    dev->cb = cb;
   21874:	605d      	str	r5, [r3, #4]
    dev->ctx = ctx;
   21876:	609c      	str	r4, [r3, #8]
    return 0;
   21878:	2000      	movs	r0, #0
}
   2187a:	bd70      	pop	{r4, r5, r6, pc}
        dev = wc_CryptoCb_FindDevice(INVALID_DEVID);
   2187c:	f06f 0001 	mvn.w	r0, #1
   21880:	f7ff fe4c 	bl	2151c <wc_CryptoCb_FindDevice>
    if (dev == NULL)
   21884:	4603      	mov	r3, r0
   21886:	2800      	cmp	r0, #0
   21888:	d1f3      	bne.n	21872 <wc_CryptoCb_RegisterDevice+0x10>
        return BUFFER_E; /* out of devices */
   2188a:	f06f 0083 	mvn.w	r0, #131	; 0x83
   2188e:	e7f4      	b.n	2187a <wc_CryptoCb_RegisterDevice+0x18>

Disassembly of section .text.__sfputc_r%807:

00021890 <__sfputc_r>:
   21890:	6893      	ldr	r3, [r2, #8]
   21892:	3b01      	subs	r3, #1
   21894:	2b00      	cmp	r3, #0
   21896:	b410      	push	{r4}
   21898:	6093      	str	r3, [r2, #8]
   2189a:	da08      	bge.n	218ae <__sfputc_r+0x1e>
   2189c:	6994      	ldr	r4, [r2, #24]
   2189e:	42a3      	cmp	r3, r4
   218a0:	db01      	blt.n	218a6 <__sfputc_r+0x16>
   218a2:	290a      	cmp	r1, #10
   218a4:	d103      	bne.n	218ae <__sfputc_r+0x1e>
   218a6:	f85d 4b04 	ldr.w	r4, [sp], #4
   218aa:	f7f6 bb17 	b.w	17edc <__swbuf_r>
   218ae:	6813      	ldr	r3, [r2, #0]
   218b0:	1c58      	adds	r0, r3, #1
   218b2:	6010      	str	r0, [r2, #0]
   218b4:	7019      	strb	r1, [r3, #0]
   218b6:	4608      	mov	r0, r1
   218b8:	f85d 4b04 	ldr.w	r4, [sp], #4
   218bc:	4770      	bx	lr

Disassembly of section .text._Bfree%808:

000218be <_Bfree>:
   218be:	b570      	push	{r4, r5, r6, lr}
   218c0:	6a44      	ldr	r4, [r0, #36]	; 0x24
   218c2:	4606      	mov	r6, r0
   218c4:	460d      	mov	r5, r1
   218c6:	b93c      	cbnz	r4, 218d8 <_Bfree+0x1a>
   218c8:	2010      	movs	r0, #16
   218ca:	f002 fad9 	bl	23e80 <malloc>
   218ce:	e9c0 4401 	strd	r4, r4, [r0, #4]
   218d2:	6270      	str	r0, [r6, #36]	; 0x24
   218d4:	6004      	str	r4, [r0, #0]
   218d6:	60c4      	str	r4, [r0, #12]
   218d8:	b13d      	cbz	r5, 218ea <_Bfree+0x2c>
   218da:	6a73      	ldr	r3, [r6, #36]	; 0x24
   218dc:	686a      	ldr	r2, [r5, #4]
   218de:	68db      	ldr	r3, [r3, #12]
   218e0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   218e4:	6029      	str	r1, [r5, #0]
   218e6:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
   218ea:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.DRV_ETHPHY_Close%809:

000218ec <DRV_ETHPHY_Close>:
    if(hClientObj != 0)
   218ec:	b188      	cbz	r0, 21912 <DRV_ETHPHY_Close+0x26>
{
   218ee:	b510      	push	{r4, lr}
   218f0:	4604      	mov	r4, r0
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   218f2:	68c1      	ldr	r1, [r0, #12]
   218f4:	4a07      	ldr	r2, [pc, #28]	; (21914 <DRV_ETHPHY_Close+0x28>)
   218f6:	4291      	cmp	r1, r2
   218f8:	d10a      	bne.n	21910 <DRV_ETHPHY_Close+0x24>
            hClientObj->pMiimBase->DRV_MIIM_Close(hClientObj->miimHandle);
   218fa:	6903      	ldr	r3, [r0, #16]
   218fc:	69db      	ldr	r3, [r3, #28]
   218fe:	6940      	ldr	r0, [r0, #20]
   21900:	4798      	blx	r3
            hClientObj->clientInUse = false ;
   21902:	2200      	movs	r2, #0
   21904:	8022      	strh	r2, [r4, #0]
            hClientObj->hDriver->numClients--;
   21906:	68e1      	ldr	r1, [r4, #12]
   21908:	884b      	ldrh	r3, [r1, #2]
   2190a:	3b01      	subs	r3, #1
   2190c:	804b      	strh	r3, [r1, #2]
            hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_CLOSED;
   2190e:	7222      	strb	r2, [r4, #8]
}
   21910:	bd10      	pop	{r4, pc}
   21912:	4770      	bx	lr
   21914:	2000e7e8 	.word	0x2000e7e8

Disassembly of section .text.DRV_ETHPHY_VendorDataGet%810:

00021918 <DRV_ETHPHY_VendorDataGet>:
    if(hClientObj != 0)
   21918:	4603      	mov	r3, r0
   2191a:	b140      	cbz	r0, 2192e <DRV_ETHPHY_VendorDataGet+0x16>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   2191c:	68c0      	ldr	r0, [r0, #12]
   2191e:	4a08      	ldr	r2, [pc, #32]	; (21940 <DRV_ETHPHY_VendorDataGet+0x28>)
   21920:	4290      	cmp	r0, r2
   21922:	d107      	bne.n	21934 <DRV_ETHPHY_VendorDataGet+0x1c>
            if(pVendorData)
   21924:	b149      	cbz	r1, 2193a <DRV_ETHPHY_VendorDataGet+0x22>
                *pVendorData = hClientObj->vendorData;
   21926:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   21928:	600b      	str	r3, [r1, #0]
            return DRV_ETHPHY_RES_OK;
   2192a:	2000      	movs	r0, #0
   2192c:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   2192e:	f06f 000a 	mvn.w	r0, #10
   21932:	4770      	bx	lr
   21934:	f06f 000a 	mvn.w	r0, #10
   21938:	4770      	bx	lr
            return DRV_ETHPHY_RES_OK;
   2193a:	2000      	movs	r0, #0
}
   2193c:	4770      	bx	lr
   2193e:	bf00      	nop
   21940:	2000e7e8 	.word	0x2000e7e8

Disassembly of section .text.DRV_ETHPHY_Reinitialize%811:

00021944 <DRV_ETHPHY_Reinitialize>:
{
   21944:	b508      	push	{r3, lr}
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   21946:	4b09      	ldr	r3, [pc, #36]	; (2196c <DRV_ETHPHY_Reinitialize+0x28>)
   21948:	4283      	cmp	r3, r0
   2194a:	d10e      	bne.n	2196a <DRV_ETHPHY_Reinitialize+0x26>
    if(phyInst != 0)
   2194c:	b168      	cbz	r0, 2196a <DRV_ETHPHY_Reinitialize+0x26>
   2194e:	460b      	mov	r3, r1
        phyInst->numClients = 0;
   21950:	4806      	ldr	r0, [pc, #24]	; (2196c <DRV_ETHPHY_Reinitialize+0x28>)
   21952:	2100      	movs	r1, #0
   21954:	8041      	strh	r1, [r0, #2]
        phyInst->status = SYS_STATUS_READY; // Set module state
   21956:	2202      	movs	r2, #2
   21958:	7102      	strb	r2, [r0, #4]
        phyInst->ethphyId = ethphyInit->ethphyId; // Store PLIB ID
   2195a:	685a      	ldr	r2, [r3, #4]
   2195c:	6082      	str	r2, [r0, #8]
        phyInst->pPhyObj = ethphyInit->pPhyObject;
   2195e:	68db      	ldr	r3, [r3, #12]
   21960:	6143      	str	r3, [r0, #20]
        memset(phyInst->objClients, 0, sizeof(phyInst->objClients));
   21962:	2248      	movs	r2, #72	; 0x48
   21964:	3018      	adds	r0, #24
   21966:	f002 fa9b 	bl	23ea0 <memset>
}
   2196a:	bd08      	pop	{r3, pc}
   2196c:	2000e7e8 	.word	0x2000e7e8

Disassembly of section .text._DRV_ETHPHY_LinkStatPhaseRefresh%812:

00021970 <_DRV_ETHPHY_LinkStatPhaseRefresh>:
{
   21970:	b510      	push	{r4, lr}
   21972:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   21974:	f000 ffae 	bl	228d4 <_DRV_PHY_SMITransfer_Wait>
   21978:	b178      	cbz	r0, 2199a <_DRV_ETHPHY_LinkStatPhaseRefresh+0x2a>
    DRV_ETHPHY_LINK_STATUS* pLinkStat = (DRV_ETHPHY_LINK_STATUS*)hClientObj->operParam;
   2197a:	6b23      	ldr	r3, [r4, #48]	; 0x30
    if(pLinkStat)
   2197c:	b14b      	cbz	r3, 21992 <_DRV_ETHPHY_LinkStatPhaseRefresh+0x22>
    linkStat = (phyStat.LINK_STAT)?DRV_ETHPHY_LINK_ST_UP:DRV_ETHPHY_LINK_ST_DOWN;
   2197e:	f894 103a 	ldrb.w	r1, [r4, #58]	; 0x3a
   21982:	f3c1 0280 	ubfx	r2, r1, #2, #1
    if(phyStat.REM_FAULT)
   21986:	f011 0f10 	tst.w	r1, #16
        linkStat|=DRV_ETHPHY_LINK_ST_REMOTE_FAULT;
   2198a:	bf18      	it	ne
   2198c:	f042 0204 	orrne.w	r2, r2, #4
        *pLinkStat = _Phy2LinkStat(phyStat);
   21990:	801a      	strh	r2, [r3, #0]
    _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OK);
   21992:	2100      	movs	r1, #0
   21994:	4620      	mov	r0, r4
   21996:	f000 fa49 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
}
   2199a:	bd10      	pop	{r4, pc}

Disassembly of section .text._ARPRemoveEntry%813:

0002199c <_ARPRemoveEntry>:
{
   2199c:	b538      	push	{r3, r4, r5, lr}
   2199e:	4605      	mov	r5, r0
   219a0:	460c      	mov	r4, r1
    if((hE->flags.value & ARP_FLAG_ENTRY_PERM) != 0 )
   219a2:	880b      	ldrh	r3, [r1, #0]
   219a4:	f013 0f40 	tst.w	r3, #64	; 0x40
   219a8:	d008      	beq.n	219bc <_ARPRemoveEntry+0x20>
        remList =  &pArpDcpt->permList;
   219aa:	3004      	adds	r0, #4
    TCPIP_Helper_ProtectedSingleListNodeRemove(remList, (SGL_LIST_NODE*)&((ARP_HASH_ENTRY*)hE)->next);
   219ac:	1d21      	adds	r1, r4, #4
   219ae:	f7ff fcad 	bl	2130c <TCPIP_Helper_ProtectedSingleListNodeRemove>
    TCPIP_OAHASH_EntryRemove(pArpDcpt->hashDcpt, hE);
   219b2:	4621      	mov	r1, r4
   219b4:	6828      	ldr	r0, [r5, #0]
   219b6:	f001 fe7d 	bl	236b4 <TCPIP_OAHASH_EntryRemove>
}
   219ba:	bd38      	pop	{r3, r4, r5, pc}
    else if((hE->flags.value & ARP_FLAG_ENTRY_COMPLETE) != 0 )
   219bc:	f013 0f80 	tst.w	r3, #128	; 0x80
        remList =  &pArpDcpt->completeList;
   219c0:	bf14      	ite	ne
   219c2:	3018      	addne	r0, #24
        remList =  &pArpDcpt->incompleteList;
   219c4:	302c      	addeq	r0, #44	; 0x2c
   219c6:	e7f1      	b.n	219ac <_ARPRemoveEntry+0x10>

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListHeadRemove%814:

000219c8 <TCPIP_Helper_ProtectedSingleListHeadRemove>:
{
   219c8:	b538      	push	{r3, r4, r5, lr}
    if(pL->semValid)
   219ca:	7c03      	ldrb	r3, [r0, #16]
   219cc:	b913      	cbnz	r3, 219d4 <TCPIP_Helper_ProtectedSingleListHeadRemove+0xc>
    return 0;
   219ce:	2400      	movs	r4, #0
}
   219d0:	4620      	mov	r0, r4
   219d2:	bd38      	pop	{r3, r4, r5, pc}
   219d4:	4604      	mov	r4, r0
        if (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
   219d6:	f100 050c 	add.w	r5, r0, #12
   219da:	f64f 71ff 	movw	r1, #65535	; 0xffff
   219de:	4628      	mov	r0, r5
   219e0:	f001 fa88 	bl	22ef4 <OSAL_SEM_Pend>
        SGL_LIST_NODE * ret = TCPIP_Helper_SingleListHeadRemove(&pL->list);
   219e4:	4620      	mov	r0, r4
   219e6:	f001 fb3f 	bl	23068 <TCPIP_Helper_SingleListHeadRemove>
   219ea:	4604      	mov	r4, r0
        if (OSAL_SEM_Post(&pL->semaphore) != OSAL_RESULT_TRUE)
   219ec:	4628      	mov	r0, r5
   219ee:	f001 fecd 	bl	2378c <OSAL_SEM_Post>
        return ret;
   219f2:	e7ed      	b.n	219d0 <TCPIP_Helper_ProtectedSingleListHeadRemove+0x8>

Disassembly of section .text.TCPIP_STACK_IsBcastAddress%815:

000219f4 <TCPIP_STACK_IsBcastAddress>:
{
   219f4:	b508      	push	{r3, lr}
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   219f6:	b188      	cbz	r0, 21a1c <TCPIP_STACK_IsBcastAddress+0x28>
   219f8:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   219fc:	f012 0f40 	tst.w	r2, #64	; 0x40
   21a00:	d101      	bne.n	21a06 <TCPIP_STACK_IsBcastAddress+0x12>
    return false;
   21a02:	2000      	movs	r0, #0
}
   21a04:	bd08      	pop	{r3, pc}
       return (TCPIP_Helper_IsBcastAddress(pIpAdd) ||  TCPIP_STACK_NetIsBcastAddress(pNetIf, pIpAdd));
   21a06:	680a      	ldr	r2, [r1, #0]
   21a08:	f1b2 3fff 	cmp.w	r2, #4294967295
   21a0c:	d004      	beq.n	21a18 <TCPIP_STACK_IsBcastAddress+0x24>
   21a0e:	f000 fb75 	bl	220fc <TCPIP_STACK_NetIsBcastAddress>
   21a12:	f000 0001 	and.w	r0, r0, #1
   21a16:	e7f5      	b.n	21a04 <TCPIP_STACK_IsBcastAddress+0x10>
   21a18:	2001      	movs	r0, #1
   21a1a:	e7fa      	b.n	21a12 <TCPIP_STACK_IsBcastAddress+0x1e>
    return false;
   21a1c:	2000      	movs	r0, #0
   21a1e:	e7f1      	b.n	21a04 <TCPIP_STACK_IsBcastAddress+0x10>

Disassembly of section .text._TCPIPStackModuleRxExtract%816:

00021a20 <_TCPIPStackModuleRxExtract>:
{
   21a20:	b538      	push	{r3, r4, r5, lr}
   21a22:	4604      	mov	r4, r0
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   21a24:	2000      	movs	r0, #0
   21a26:	f001 fea5 	bl	23774 <OSAL_CRIT_Enter>
   21a2a:	4605      	mov	r5, r0
    SINGLE_LIST* pQueue = TCPIP_MODULES_QUEUE_TBL + modId;
   21a2c:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    TCPIP_MAC_PACKET* pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(pQueue);
   21a30:	4805      	ldr	r0, [pc, #20]	; (21a48 <_TCPIPStackModuleRxExtract+0x28>)
   21a32:	eb00 0084 	add.w	r0, r0, r4, lsl #2
   21a36:	f001 fb17 	bl	23068 <TCPIP_Helper_SingleListHeadRemove>
   21a3a:	4604      	mov	r4, r0
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   21a3c:	4629      	mov	r1, r5
   21a3e:	2000      	movs	r0, #0
   21a40:	f001 ffd2 	bl	239e8 <OSAL_CRIT_Leave>
}
   21a44:	4620      	mov	r0, r4
   21a46:	bd38      	pop	{r3, r4, r5, pc}
   21a48:	2000e654 	.word	0x2000e654

Disassembly of section .text._TCPIP_PKT_SocketAlloc%817:

00021a4c <_TCPIP_PKT_SocketAlloc>:
{
   21a4c:	b538      	push	{r3, r4, r5, lr}
   21a4e:	460c      	mov	r4, r1
    if((flags & TCPIP_MAC_PKT_FLAG_IPV6) != 0)
   21a50:	f403 7100 	and.w	r1, r3, #512	; 0x200
        netHdrLen = sizeof(IPV4_HEADER);
   21a54:	2900      	cmp	r1, #0
   21a56:	bf14      	ite	ne
   21a58:	2528      	movne	r5, #40	; 0x28
   21a5a:	2514      	moveq	r5, #20
    pPkt = _TCPIP_PKT_PacketAlloc(pktLen, totHdrLen +  payloadLen, flags );
   21a5c:	4422      	add	r2, r4
   21a5e:	18a9      	adds	r1, r5, r2
   21a60:	461a      	mov	r2, r3
   21a62:	b289      	uxth	r1, r1
   21a64:	f7f9 f84e 	bl	1ab04 <_TCPIP_PKT_PacketAlloc>
    if(pPkt)
   21a68:	4603      	mov	r3, r0
   21a6a:	b118      	cbz	r0, 21a74 <_TCPIP_PKT_SocketAlloc+0x28>
        if(transpHdrLen)
   21a6c:	b114      	cbz	r4, 21a74 <_TCPIP_PKT_SocketAlloc+0x28>
            pPkt->pTransportLayer = pPkt->pNetLayer + netHdrLen;
   21a6e:	6982      	ldr	r2, [r0, #24]
   21a70:	4415      	add	r5, r2
   21a72:	61c5      	str	r5, [r0, #28]
}
   21a74:	4618      	mov	r0, r3
   21a76:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text._UDPFreeTxResources%818:

00021a78 <_UDPFreeTxResources>:
{
   21a78:	b510      	push	{r4, lr}
   21a7a:	4604      	mov	r4, r0
    switch(pSkt->addType)
   21a7c:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
   21a7e:	2b01      	cmp	r3, #1
   21a80:	d002      	beq.n	21a88 <_UDPFreeTxResources+0x10>
    pSkt->pPkt = 0;
   21a82:	2300      	movs	r3, #0
   21a84:	60e3      	str	r3, [r4, #12]
}
   21a86:	bd10      	pop	{r4, pc}
            pCurrPkt = _TxSktGetLockedV4Pkt(pSkt, true);
   21a88:	2101      	movs	r1, #1
   21a8a:	f7ff fed3 	bl	21834 <_TxSktGetLockedV4Pkt>
            if(pCurrPkt)
   21a8e:	2800      	cmp	r0, #0
   21a90:	d0f7      	beq.n	21a82 <_UDPFreeTxResources+0xa>
                    TCPIP_PKT_PacketFree(pPkt);
   21a92:	68e0      	ldr	r0, [r4, #12]
   21a94:	f7fe fb6c 	bl	20170 <_TCPIP_PKT_PacketFree>
        pSkt->txAllocCnt--;
   21a98:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
   21a9c:	3b01      	subs	r3, #1
   21a9e:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
   21aa2:	e7ee      	b.n	21a82 <_UDPFreeTxResources+0xa>

Disassembly of section .text.SERCOM0_SPI_IsBusy%819:

00021aa4 <SERCOM0_SPI_IsBusy>:
	if ((sercom0SPIObj.txSize == 0U) && (sercom0SPIObj.rxSize == 0U))
   21aa4:	4b08      	ldr	r3, [pc, #32]	; (21ac8 <SERCOM0_SPI_IsBusy+0x24>)
   21aa6:	689a      	ldr	r2, [r3, #8]
   21aa8:	68db      	ldr	r3, [r3, #12]
   21aaa:	4313      	orrs	r3, r2
   21aac:	d00a      	beq.n	21ac4 <SERCOM0_SPI_IsBusy+0x20>
        isBusy = (((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_TXC_Msk) == 0U) || sercom0SPIObj.transferIsBusy);
   21aae:	4b07      	ldr	r3, [pc, #28]	; (21acc <SERCOM0_SPI_IsBusy+0x28>)
   21ab0:	7e1b      	ldrb	r3, [r3, #24]
   21ab2:	f013 0f02 	tst.w	r3, #2
   21ab6:	bf1a      	itte	ne
   21ab8:	4b03      	ldrne	r3, [pc, #12]	; (21ac8 <SERCOM0_SPI_IsBusy+0x24>)
   21aba:	7f18      	ldrbne	r0, [r3, #28]
   21abc:	2001      	moveq	r0, #1
   21abe:	f000 0001 	and.w	r0, r0, #1
   21ac2:	4770      	bx	lr
		isBusy = false;
   21ac4:	2000      	movs	r0, #0
}
   21ac6:	4770      	bx	lr
   21ac8:	2000ea6c 	.word	0x2000ea6c
   21acc:	40003000 	.word	0x40003000

Disassembly of section .text.TC0_TimerInterruptHandler%820:

00021ad0 <TC0_TimerInterruptHandler>:
    TC0_CallbackObject.context = context;
}

/* Timer Interrupt handler */
void TC0_TimerInterruptHandler( void )
{
   21ad0:	b508      	push	{r3, lr}
    if (TC0_REGS->COUNT16.TC_INTENSET != 0U)
   21ad2:	4b08      	ldr	r3, [pc, #32]	; (21af4 <TC0_TimerInterruptHandler+0x24>)
   21ad4:	7a5b      	ldrb	r3, [r3, #9]
   21ad6:	b163      	cbz	r3, 21af2 <TC0_TimerInterruptHandler+0x22>
    {
        TC_TIMER_STATUS status;
        status = (TC_TIMER_STATUS) TC0_REGS->COUNT16.TC_INTFLAG;
   21ad8:	4a06      	ldr	r2, [pc, #24]	; (21af4 <TC0_TimerInterruptHandler+0x24>)
   21ada:	7a93      	ldrb	r3, [r2, #10]
        /* Clear interrupt flags */
        TC0_REGS->COUNT16.TC_INTFLAG = (uint8_t)TC_INTFLAG_Msk;
   21adc:	2133      	movs	r1, #51	; 0x33
   21ade:	7291      	strb	r1, [r2, #10]
        if((status != TC_TIMER_STATUS_NONE) && (TC0_CallbackObject.callback != NULL))
   21ae0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
   21ae4:	b12b      	cbz	r3, 21af2 <TC0_TimerInterruptHandler+0x22>
   21ae6:	4b04      	ldr	r3, [pc, #16]	; (21af8 <TC0_TimerInterruptHandler+0x28>)
   21ae8:	681b      	ldr	r3, [r3, #0]
   21aea:	b113      	cbz	r3, 21af2 <TC0_TimerInterruptHandler+0x22>
        {
            TC0_CallbackObject.callback(status, TC0_CallbackObject.context);
   21aec:	4a02      	ldr	r2, [pc, #8]	; (21af8 <TC0_TimerInterruptHandler+0x28>)
   21aee:	6851      	ldr	r1, [r2, #4]
   21af0:	4798      	blx	r3
        }
    }
}
   21af2:	bd08      	pop	{r3, pc}
   21af4:	40003800 	.word	0x40003800
   21af8:	2000ed84 	.word	0x2000ed84

Disassembly of section .rodata.sysConsoleUARTDevDesc%821:

00021afc <sysConsoleUARTDevDesc>:
   21afc:	00000300 00022215 000201e9 00020ccd     ....."..........
   21b0c:	00020c99 00020225 00020c31 00020c65     ....%...1...e...
   21b1c:	00016b1b 00023de1 000244a1              .k...=...D..

Disassembly of section .text.TCPIP_STACK_Init%822:

00021b28 <TCPIP_STACK_Init>:
{
   21b28:	b500      	push	{lr}
   21b2a:	b087      	sub	sp, #28
    tcpipInit.pNetConf = TCPIP_HOSTS_CONFIGURATION;
   21b2c:	4b07      	ldr	r3, [pc, #28]	; (21b4c <TCPIP_STACK_Init+0x24>)
   21b2e:	9301      	str	r3, [sp, #4]
    tcpipInit.nNets = TCPIP_HOSTS_CONFIGURATION_SIZE;
   21b30:	2301      	movs	r3, #1
   21b32:	9302      	str	r3, [sp, #8]
    tcpipInit.pModConfig = TCPIP_STACK_MODULE_CONFIG_TBL;
   21b34:	4b06      	ldr	r3, [pc, #24]	; (21b50 <TCPIP_STACK_Init+0x28>)
   21b36:	9303      	str	r3, [sp, #12]
    tcpipInit.nModules = TCPIP_STACK_MODULE_CONFIG_TBL_SIZE;
   21b38:	230a      	movs	r3, #10
   21b3a:	9304      	str	r3, [sp, #16]
    tcpipInit.initCback = 0;
   21b3c:	2000      	movs	r0, #0
   21b3e:	9005      	str	r0, [sp, #20]
    return TCPIP_STACK_Initialize(0, &tcpipInit.moduleInit);
   21b40:	4669      	mov	r1, sp
   21b42:	f7f8 fcf1 	bl	1a528 <TCPIP_STACK_Initialize>
}
   21b46:	b007      	add	sp, #28
   21b48:	f85d fb04 	ldr.w	pc, [sp], #4
   21b4c:	00020874 	.word	0x00020874
   21b50:	0001e51c 	.word	0x0001e51c

Disassembly of section .text.pxPortInitialiseStack%823:

00021b54 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   21b54:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   21b58:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
   21b5c:	f021 0101 	bic.w	r1, r1, #1
   21b60:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
   21b64:	4b05      	ldr	r3, [pc, #20]	; (21b7c <pxPortInitialiseStack+0x28>)
   21b66:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
   21b6a:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
   21b6e:	f06f 0302 	mvn.w	r3, #2
   21b72:	f840 3c24 	str.w	r3, [r0, #-36]
}
   21b76:	3844      	subs	r0, #68	; 0x44
   21b78:	4770      	bx	lr
   21b7a:	bf00      	nop
   21b7c:	00022d61 	.word	0x00022d61

Disassembly of section .text.xPortSysTickHandler%824:

00021b80 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
   21b80:	b508      	push	{r3, lr}
   21b82:	f04f 0320 	mov.w	r3, #32
   21b86:	f383 8811 	msr	BASEPRI, r3
   21b8a:	f3bf 8f6f 	isb	sy
   21b8e:	f3bf 8f4f 	dsb	sy
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
   21b92:	f7f3 f9a7 	bl	14ee4 <xTaskIncrementTick>
   21b96:	b118      	cbz	r0, 21ba0 <xPortSysTickHandler+0x20>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   21b98:	4b03      	ldr	r3, [pc, #12]	; (21ba8 <xPortSysTickHandler+0x28>)
   21b9a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   21b9e:	601a      	str	r2, [r3, #0]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   21ba0:	2300      	movs	r3, #0
   21ba2:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
   21ba6:	bd08      	pop	{r3, pc}
   21ba8:	e000ed04 	.word	0xe000ed04

Disassembly of section .text.prvResetNextTaskUnblockTime%825:

00021bac <prvResetNextTaskUnblockTime>:
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   21bac:	4b08      	ldr	r3, [pc, #32]	; (21bd0 <prvResetNextTaskUnblockTime+0x24>)
   21bae:	681b      	ldr	r3, [r3, #0]
   21bb0:	681b      	ldr	r3, [r3, #0]
   21bb2:	b923      	cbnz	r3, 21bbe <prvResetNextTaskUnblockTime+0x12>
		xNextTaskUnblockTime = portMAX_DELAY;
   21bb4:	4b07      	ldr	r3, [pc, #28]	; (21bd4 <prvResetNextTaskUnblockTime+0x28>)
   21bb6:	f04f 32ff 	mov.w	r2, #4294967295
   21bba:	601a      	str	r2, [r3, #0]
   21bbc:	4770      	bx	lr
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   21bbe:	4b04      	ldr	r3, [pc, #16]	; (21bd0 <prvResetNextTaskUnblockTime+0x24>)
   21bc0:	681b      	ldr	r3, [r3, #0]
   21bc2:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
   21bc4:	68db      	ldr	r3, [r3, #12]
   21bc6:	685a      	ldr	r2, [r3, #4]
   21bc8:	4b02      	ldr	r3, [pc, #8]	; (21bd4 <prvResetNextTaskUnblockTime+0x28>)
   21bca:	601a      	str	r2, [r3, #0]
}
   21bcc:	4770      	bx	lr
   21bce:	bf00      	nop
   21bd0:	2000ef04 	.word	0x2000ef04
   21bd4:	2000ef24 	.word	0x2000ef24

Disassembly of section .text.wc_RNG_HealthTest%826:

00021bd8 <wc_RNG_HealthTest>:
{
   21bd8:	b530      	push	{r4, r5, lr}
   21bda:	b089      	sub	sp, #36	; 0x24
    return wc_RNG_HealthTest_ex(reseed, NULL, 0,
   21bdc:	f06f 0401 	mvn.w	r4, #1
   21be0:	9406      	str	r4, [sp, #24]
   21be2:	2400      	movs	r4, #0
   21be4:	9405      	str	r4, [sp, #20]
   21be6:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   21be8:	9504      	str	r5, [sp, #16]
   21bea:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   21bec:	9503      	str	r5, [sp, #12]
   21bee:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   21bf0:	9502      	str	r5, [sp, #8]
   21bf2:	9301      	str	r3, [sp, #4]
   21bf4:	9200      	str	r2, [sp, #0]
   21bf6:	460b      	mov	r3, r1
   21bf8:	4622      	mov	r2, r4
   21bfa:	4621      	mov	r1, r4
   21bfc:	f7f7 fbac 	bl	19358 <wc_RNG_HealthTest_ex>
}
   21c00:	b009      	add	sp, #36	; 0x24
   21c02:	bd30      	pop	{r4, r5, pc}

Disassembly of section .text.MyTxQueueErase%827:

00021c04 <MyTxQueueErase>:
    for(ix=0;ix<MY_QUEUE_SIZE;ix++){
   21c04:	4a07      	ldr	r2, [pc, #28]	; (21c24 <MyTxQueueErase+0x20>)
   21c06:	1e53      	subs	r3, r2, #1
   21c08:	f202 12ff 	addw	r2, r2, #511	; 0x1ff
        MyQueue[ix]=0;        
   21c0c:	2100      	movs	r1, #0
   21c0e:	f803 1f01 	strb.w	r1, [r3, #1]!
    for(ix=0;ix<MY_QUEUE_SIZE;ix++){
   21c12:	4293      	cmp	r3, r2
   21c14:	d1fb      	bne.n	21c0e <MyTxQueueErase+0xa>
    MyQueue_wr_ix = 0;
   21c16:	2300      	movs	r3, #0
   21c18:	4a03      	ldr	r2, [pc, #12]	; (21c28 <MyTxQueueErase+0x24>)
   21c1a:	6013      	str	r3, [r2, #0]
    MyQueue_rd_ix = 0;
   21c1c:	4a03      	ldr	r2, [pc, #12]	; (21c2c <MyTxQueueErase+0x28>)
   21c1e:	6013      	str	r3, [r2, #0]
}
   21c20:	4770      	bx	lr
   21c22:	bf00      	nop
   21c24:	2000de14 	.word	0x2000de14
   21c28:	2000ef50 	.word	0x2000ef50
   21c2c:	2000ef4c 	.word	0x2000ef4c

Disassembly of section .text.__sfmoreglue%828:

00021c30 <__sfmoreglue>:
   21c30:	b570      	push	{r4, r5, r6, lr}
   21c32:	1e4a      	subs	r2, r1, #1
   21c34:	2564      	movs	r5, #100	; 0x64
   21c36:	4355      	muls	r5, r2
   21c38:	460e      	mov	r6, r1
   21c3a:	f105 0170 	add.w	r1, r5, #112	; 0x70
   21c3e:	f7f6 fd3f 	bl	186c0 <_malloc_r>
   21c42:	4604      	mov	r4, r0
   21c44:	b140      	cbz	r0, 21c58 <__sfmoreglue+0x28>
   21c46:	2100      	movs	r1, #0
   21c48:	e9c0 1600 	strd	r1, r6, [r0]
   21c4c:	300c      	adds	r0, #12
   21c4e:	60a0      	str	r0, [r4, #8]
   21c50:	f105 0264 	add.w	r2, r5, #100	; 0x64
   21c54:	f002 f924 	bl	23ea0 <memset>
   21c58:	4620      	mov	r0, r4
   21c5a:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text._wcrtomb_r%829:

00021c5c <_wcrtomb_r>:
   21c5c:	b5f0      	push	{r4, r5, r6, r7, lr}
   21c5e:	4c09      	ldr	r4, [pc, #36]	; (21c84 <_wcrtomb_r+0x28>)
   21c60:	b085      	sub	sp, #20
   21c62:	4605      	mov	r5, r0
   21c64:	461e      	mov	r6, r3
   21c66:	f8d4 40e0 	ldr.w	r4, [r4, #224]	; 0xe0
   21c6a:	b909      	cbnz	r1, 21c70 <_wcrtomb_r+0x14>
   21c6c:	460a      	mov	r2, r1
   21c6e:	a901      	add	r1, sp, #4
   21c70:	47a0      	blx	r4
   21c72:	1c43      	adds	r3, r0, #1
   21c74:	bf01      	itttt	eq
   21c76:	2300      	moveq	r3, #0
   21c78:	6033      	streq	r3, [r6, #0]
   21c7a:	238a      	moveq	r3, #138	; 0x8a
   21c7c:	602b      	streq	r3, [r5, #0]
   21c7e:	b005      	add	sp, #20
   21c80:	bdf0      	pop	{r4, r5, r6, r7, pc}
   21c82:	bf00      	nop
   21c84:	2000e014 	.word	0x2000e014

Disassembly of section .text._sbrk%830:

00021c88 <_sbrk>:
   21c88:	4a07      	ldr	r2, [pc, #28]	; (21ca8 <_sbrk+0x20>)
   21c8a:	6813      	ldr	r3, [r2, #0]
   21c8c:	b143      	cbz	r3, 21ca0 <_sbrk+0x18>
   21c8e:	4907      	ldr	r1, [pc, #28]	; (21cac <_sbrk+0x24>)
   21c90:	4418      	add	r0, r3
   21c92:	4288      	cmp	r0, r1
   21c94:	bf8c      	ite	hi
   21c96:	f04f 33ff 	movhi.w	r3, #4294967295
   21c9a:	6010      	strls	r0, [r2, #0]
   21c9c:	4618      	mov	r0, r3
   21c9e:	4770      	bx	lr
   21ca0:	4b03      	ldr	r3, [pc, #12]	; (21cb0 <_sbrk+0x28>)
   21ca2:	6013      	str	r3, [r2, #0]
   21ca4:	e7f3      	b.n	21c8e <_sbrk+0x6>
   21ca6:	bf00      	nop
   21ca8:	2000ef6c 	.word	0x2000ef6c
   21cac:	20026a58 	.word	0x20026a58
   21cb0:	2000ef98 	.word	0x2000ef98

Disassembly of section .text%831:

00021cb4 <__aeabi_dcmpun>:
   21cb4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   21cb8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   21cbc:	d102      	bne.n	21cc4 <__aeabi_dcmpun+0x10>
   21cbe:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
   21cc2:	d10a      	bne.n	21cda <__aeabi_dcmpun+0x26>
   21cc4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   21cc8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   21ccc:	d102      	bne.n	21cd4 <__aeabi_dcmpun+0x20>
   21cce:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
   21cd2:	d102      	bne.n	21cda <__aeabi_dcmpun+0x26>
   21cd4:	f04f 0000 	mov.w	r0, #0
   21cd8:	4770      	bx	lr
   21cda:	f04f 0001 	mov.w	r0, #1
   21cde:	4770      	bx	lr

Disassembly of section .text._DRV_GMAC_LinkStateStartLink%832:

00021ce0 <_DRV_GMAC_LinkStateStartLink>:
{
   21ce0:	b538      	push	{r3, r4, r5, lr}
   21ce2:	4604      	mov	r4, r0
	phyRes = pMACDrv->sGmacData.gmacConfig.pPhyBase->DRV_ETHPHY_LinkStatusGet(pMACDrv->sGmacData.hPhyClient, DRV_ETHPHY_INF_IDX_ALL_EXTERNAL, &pMACDrv->sGmacData._negResult.linkStatus, false);
   21ce4:	f8d0 30d8 	ldr.w	r3, [r0, #216]	; 0xd8
   21ce8:	6c1d      	ldr	r5, [r3, #64]	; 0x40
   21cea:	2300      	movs	r3, #0
   21cec:	f100 0240 	add.w	r2, r0, #64	; 0x40
   21cf0:	4619      	mov	r1, r3
   21cf2:	6900      	ldr	r0, [r0, #16]
   21cf4:	47a8      	blx	r5
    if(phyRes < 0)
   21cf6:	2800      	cmp	r0, #0
   21cf8:	db03      	blt.n	21d02 <_DRV_GMAC_LinkStateStartLink+0x22>
    pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_GET_LINK;
   21cfa:	2301      	movs	r3, #1
   21cfc:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
}
   21d00:	bd38      	pop	{r3, r4, r5, pc}
	    _DRV_GMAC_LinkStateDown(pMACDrv);
   21d02:	4620      	mov	r0, r4
   21d04:	f001 f89c 	bl	22e40 <_DRV_GMAC_LinkStateDown>
	    return;
   21d08:	e7fa      	b.n	21d00 <_DRV_GMAC_LinkStateStartLink+0x20>

Disassembly of section .text.TCPIP_TCP_WasReset%833:

00021d0a <TCPIP_TCP_WasReset>:
{
   21d0a:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   21d0c:	f000 f906 	bl	21f1c <_TcpSocketChk>
    if(pSkt)
   21d10:	b160      	cbz	r0, 21d2c <TCPIP_TCP_WasReset+0x22>
        if(pSkt->Flags.bSocketReset)
   21d12:	f890 2037 	ldrb.w	r2, [r0, #55]	; 0x37
   21d16:	f012 0f02 	tst.w	r2, #2
   21d1a:	d009      	beq.n	21d30 <TCPIP_TCP_WasReset+0x26>
            pSkt->Flags.bSocketReset = 0;
   21d1c:	f890 2037 	ldrb.w	r2, [r0, #55]	; 0x37
   21d20:	f36f 0241 	bfc	r2, #1, #1
   21d24:	f880 2037 	strb.w	r2, [r0, #55]	; 0x37
            return true;
   21d28:	2001      	movs	r0, #1
   21d2a:	e002      	b.n	21d32 <TCPIP_TCP_WasReset+0x28>
    return true;
   21d2c:	2001      	movs	r0, #1
   21d2e:	e000      	b.n	21d32 <TCPIP_TCP_WasReset+0x28>
        return false;
   21d30:	2000      	movs	r0, #0
}
   21d32:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_DNS_OAHASH_KeyCopy%834:

00021d34 <TCPIP_DNS_OAHASH_KeyCopy>:
    if(key == 0) 
   21d34:	b192      	cbz	r2, 21d5c <TCPIP_DNS_OAHASH_KeyCopy+0x28>
{
   21d36:	b570      	push	{r4, r5, r6, lr}
   21d38:	4615      	mov	r5, r2
   21d3a:	460c      	mov	r4, r1
    size_t hostnameLen = strlen(dnsHostNameKey);
   21d3c:	4610      	mov	r0, r2
   21d3e:	f002 f8bf 	bl	23ec0 <strlen>
    if(hostnameLen > TCPIP_DNS_CLIENT_MAX_HOSTNAME_LEN) 
   21d42:	2840      	cmp	r0, #64	; 0x40
   21d44:	bf28      	it	cs
   21d46:	2040      	movcs	r0, #64	; 0x40
   21d48:	4606      	mov	r6, r0
    memcpy(pDnsHE->pHostName, dnsHostNameKey, hostnameLen);
   21d4a:	4602      	mov	r2, r0
   21d4c:	4629      	mov	r1, r5
   21d4e:	6a20      	ldr	r0, [r4, #32]
   21d50:	f001 facc 	bl	232ec <memcpy>
    pDnsHE->pHostName[hostnameLen] = '\0';
   21d54:	6a23      	ldr	r3, [r4, #32]
   21d56:	2200      	movs	r2, #0
   21d58:	559a      	strb	r2, [r3, r6]
}
   21d5a:	bd70      	pop	{r4, r5, r6, pc}
   21d5c:	4770      	bx	lr

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListTailAdd%835:

00021d5e <TCPIP_Helper_ProtectedSingleListTailAdd>:
    if(pL->semValid)
   21d5e:	7c03      	ldrb	r3, [r0, #16]
   21d60:	b903      	cbnz	r3, 21d64 <TCPIP_Helper_ProtectedSingleListTailAdd+0x6>
   21d62:	4770      	bx	lr
{
   21d64:	b570      	push	{r4, r5, r6, lr}
   21d66:	460d      	mov	r5, r1
   21d68:	4604      	mov	r4, r0
        if (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
   21d6a:	f100 060c 	add.w	r6, r0, #12
   21d6e:	f64f 71ff 	movw	r1, #65535	; 0xffff
   21d72:	4630      	mov	r0, r6
   21d74:	f001 f8be 	bl	22ef4 <OSAL_SEM_Pend>
        TCPIP_Helper_SingleListTailAdd(&pL->list, pN);
   21d78:	4629      	mov	r1, r5
   21d7a:	4620      	mov	r0, r4
   21d7c:	f001 fb56 	bl	2342c <TCPIP_Helper_SingleListTailAdd>
        if (OSAL_SEM_Post(&pL->semaphore) != OSAL_RESULT_TRUE)
   21d80:	4630      	mov	r0, r6
   21d82:	f001 fd03 	bl	2378c <OSAL_SEM_Post>
}
   21d86:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListRemoveAll%836:

00021d88 <TCPIP_Helper_ProtectedSingleListRemoveAll>:
}



void TCPIP_Helper_ProtectedSingleListRemoveAll(PROTECTED_SINGLE_LIST* pL)
{
   21d88:	b538      	push	{r3, r4, r5, lr}
    if(pL->semValid)
   21d8a:	7c03      	ldrb	r3, [r0, #16]
   21d8c:	b903      	cbnz	r3, 21d90 <TCPIP_Helper_ProtectedSingleListRemoveAll+0x8>
        if (OSAL_SEM_Post(&pL->semaphore) != OSAL_RESULT_TRUE)
        {
            //SYS_DEBUG LOG
        }
    }
}
   21d8e:	bd38      	pop	{r3, r4, r5, pc}
   21d90:	4604      	mov	r4, r0
        if (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
   21d92:	f100 050c 	add.w	r5, r0, #12
   21d96:	f64f 71ff 	movw	r1, #65535	; 0xffff
   21d9a:	4628      	mov	r0, r5
   21d9c:	f001 f8aa 	bl	22ef4 <OSAL_SEM_Pend>
   21da0:	4620      	mov	r0, r4
   21da2:	f001 f961 	bl	23068 <TCPIP_Helper_SingleListHeadRemove>
   21da6:	2800      	cmp	r0, #0
   21da8:	d1fa      	bne.n	21da0 <TCPIP_Helper_ProtectedSingleListRemoveAll+0x18>
        if (OSAL_SEM_Post(&pL->semaphore) != OSAL_RESULT_TRUE)
   21daa:	4628      	mov	r0, r5
   21dac:	f001 fcee 	bl	2378c <OSAL_SEM_Post>
}
   21db0:	e7ed      	b.n	21d8e <TCPIP_Helper_ProtectedSingleListRemoveAll+0x6>

Disassembly of section .text.TCPIP_Notification_Add%837:

00021db2 <TCPIP_Notification_Add>:
{
   21db2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   21db4:	4607      	mov	r7, r0
   21db6:	4608      	mov	r0, r1
   21db8:	4616      	mov	r6, r2
   21dba:	461d      	mov	r5, r3
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
   21dbc:	684b      	ldr	r3, [r1, #4]
   21dbe:	4629      	mov	r1, r5
   21dc0:	4798      	blx	r3
    if(newNode)
   21dc2:	4604      	mov	r4, r0
   21dc4:	b140      	cbz	r0, 21dd8 <TCPIP_Notification_Add+0x26>
        if(pContent)
   21dc6:	b11e      	cbz	r6, 21dd0 <TCPIP_Notification_Add+0x1e>
            memcpy(newNode, pContent, nBytes);
   21dc8:	462a      	mov	r2, r5
   21dca:	4631      	mov	r1, r6
   21dcc:	f001 fa8e 	bl	232ec <memcpy>
        TCPIP_Helper_ProtectedSingleListTailAdd(notifyList, newNode);
   21dd0:	4621      	mov	r1, r4
   21dd2:	4638      	mov	r0, r7
   21dd4:	f7ff ffc3 	bl	21d5e <TCPIP_Helper_ProtectedSingleListTailAdd>
}
   21dd8:	4620      	mov	r0, r4
   21dda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.DRV_ETHPHY_Tasks%838:

00021ddc <DRV_ETHPHY_Tasks>:
{
   21ddc:	b508      	push	{r3, lr}
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   21dde:	4b07      	ldr	r3, [pc, #28]	; (21dfc <DRV_ETHPHY_Tasks+0x20>)
   21de0:	4283      	cmp	r3, r0
   21de2:	d109      	bne.n	21df8 <DRV_ETHPHY_Tasks+0x1c>
    if(phyInst != 0)
   21de4:	b140      	cbz	r0, 21df8 <DRV_ETHPHY_Tasks+0x1c>
            if(hClientObj->clientInUse != 0)
   21de6:	8b1b      	ldrh	r3, [r3, #24]
   21de8:	b133      	cbz	r3, 21df8 <DRV_ETHPHY_Tasks+0x1c>
                (*_DRV_PHY_ClientOpTbl[hClientObj->operType])(hClientObj);
   21dea:	4804      	ldr	r0, [pc, #16]	; (21dfc <DRV_ETHPHY_Tasks+0x20>)
   21dec:	8e82      	ldrh	r2, [r0, #52]	; 0x34
   21dee:	4b04      	ldr	r3, [pc, #16]	; (21e00 <DRV_ETHPHY_Tasks+0x24>)
   21df0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   21df4:	3018      	adds	r0, #24
   21df6:	4798      	blx	r3
} 
   21df8:	bd08      	pop	{r3, pc}
   21dfa:	bf00      	nop
   21dfc:	2000e7e8 	.word	0x2000e7e8
   21e00:	00022f6c 	.word	0x00022f6c

Disassembly of section .text.DRV_ETHPHY_PhyAddressGet%839:

00021e04 <DRV_ETHPHY_PhyAddressGet>:
    if( hClientObj != 0)
   21e04:	b140      	cbz	r0, 21e18 <DRV_ETHPHY_PhyAddressGet+0x14>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   21e06:	68c1      	ldr	r1, [r0, #12]
   21e08:	4b07      	ldr	r3, [pc, #28]	; (21e28 <DRV_ETHPHY_PhyAddressGet+0x24>)
   21e0a:	4299      	cmp	r1, r3
   21e0c:	d107      	bne.n	21e1e <DRV_ETHPHY_PhyAddressGet+0x1a>
            if(pPhyAddress)
   21e0e:	b14a      	cbz	r2, 21e24 <DRV_ETHPHY_PhyAddressGet+0x20>
                *pPhyAddress = hClientObj->hDriver->phyAddress;
   21e10:	691b      	ldr	r3, [r3, #16]
   21e12:	6013      	str	r3, [r2, #0]
            return DRV_ETHPHY_RES_OK;
   21e14:	2000      	movs	r0, #0
   21e16:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   21e18:	f06f 000a 	mvn.w	r0, #10
   21e1c:	4770      	bx	lr
   21e1e:	f06f 000a 	mvn.w	r0, #10
   21e22:	4770      	bx	lr
            return DRV_ETHPHY_RES_OK;
   21e24:	2000      	movs	r0, #0
}
   21e26:	4770      	bx	lr
   21e28:	2000e7e8 	.word	0x2000e7e8

Disassembly of section .text._DRV_PHY_SetOperDoneResult%840:

00021e2c <_DRV_PHY_SetOperDoneResult>:
{
   21e2c:	b508      	push	{r3, lr}
    hClientObj->operPhase =  hClientObj->operSubPhase = 0;
   21e2e:	2300      	movs	r3, #0
   21e30:	8403      	strh	r3, [r0, #32]
   21e32:	83c3      	strh	r3, [r0, #30]
    hClientObj->operType = DRV_ETHPHY_CLIENT_OP_TYPE_NONE;
   21e34:	8383      	strh	r3, [r0, #28]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_READY;
   21e36:	2302      	movs	r3, #2
   21e38:	7203      	strb	r3, [r0, #8]
    hClientObj->operRes = res;
   21e3a:	f880 102c 	strb.w	r1, [r0, #44]	; 0x2c
    if(res < 0)
   21e3e:	2900      	cmp	r1, #0
   21e40:	db00      	blt.n	21e44 <_DRV_PHY_SetOperDoneResult+0x18>
}
   21e42:	bd08      	pop	{r3, pc}
   21e44:	460a      	mov	r2, r1
        SYS_CONSOLE_PRINT("DRV_PHY operation error: %d\r\n", res);
   21e46:	4902      	ldr	r1, [pc, #8]	; (21e50 <_DRV_PHY_SetOperDoneResult+0x24>)
   21e48:	2000      	movs	r0, #0
   21e4a:	f7fa fc27 	bl	1c69c <SYS_CONSOLE_Print>
}
   21e4e:	e7f8      	b.n	21e42 <_DRV_PHY_SetOperDoneResult+0x16>
   21e50:	00022ae0 	.word	0x00022ae0

Disassembly of section .text.DRV_ETHPHY_ClientOperationAbort%841:

00021e54 <DRV_ETHPHY_ClientOperationAbort>:
{
   21e54:	b508      	push	{r3, lr}
    if( hClientObj != 0)
   21e56:	b148      	cbz	r0, 21e6c <DRV_ETHPHY_ClientOperationAbort+0x18>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   21e58:	68c1      	ldr	r1, [r0, #12]
   21e5a:	4a07      	ldr	r2, [pc, #28]	; (21e78 <DRV_ETHPHY_ClientOperationAbort+0x24>)
   21e5c:	4291      	cmp	r1, r2
   21e5e:	d108      	bne.n	21e72 <DRV_ETHPHY_ClientOperationAbort+0x1e>
            _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_ABORTED);
   21e60:	f06f 010b 	mvn.w	r1, #11
   21e64:	f7ff ffe2 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
            return DRV_ETHPHY_RES_OK;
   21e68:	2000      	movs	r0, #0
}
   21e6a:	bd08      	pop	{r3, pc}
    return DRV_ETHPHY_RES_HANDLE_ERR;
   21e6c:	f06f 000a 	mvn.w	r0, #10
   21e70:	e7fb      	b.n	21e6a <DRV_ETHPHY_ClientOperationAbort+0x16>
   21e72:	f06f 000a 	mvn.w	r0, #10
   21e76:	e7f8      	b.n	21e6a <DRV_ETHPHY_ClientOperationAbort+0x16>
   21e78:	2000e7e8 	.word	0x2000e7e8

Disassembly of section .text.DRV_PIC32CGMAC_LibSysIntStatus_Clear%842:

00021e7c <DRV_PIC32CGMAC_LibSysIntStatus_Clear>:
    if(queMask & GMAC_QUE0_MASK)
   21e7c:	f011 0f01 	tst.w	r1, #1
   21e80:	d00d      	beq.n	21e9e <DRV_PIC32CGMAC_LibSysIntStatus_Clear+0x22>
        SYS_INT_SourceStatusClear(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc);                        
   21e82:	f9b0 30b6 	ldrsh.w	r3, [r0, #182]	; 0xb6
  if ((int32_t)(IRQn) >= 0)
   21e86:	2b00      	cmp	r3, #0
   21e88:	db09      	blt.n	21e9e <DRV_PIC32CGMAC_LibSysIntStatus_Clear+0x22>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   21e8a:	095a      	lsrs	r2, r3, #5
   21e8c:	f003 031f 	and.w	r3, r3, #31
   21e90:	2101      	movs	r1, #1
   21e92:	fa01 f303 	lsl.w	r3, r1, r3
   21e96:	3260      	adds	r2, #96	; 0x60
   21e98:	4901      	ldr	r1, [pc, #4]	; (21ea0 <DRV_PIC32CGMAC_LibSysIntStatus_Clear+0x24>)
   21e9a:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
   21e9e:	4770      	bx	lr
   21ea0:	e000e100 	.word	0xe000e100

Disassembly of section .text.DRV_PIC32CGMAC_LibSysInt_Enable%843:

00021ea4 <DRV_PIC32CGMAC_LibSysInt_Enable>:
    if(queMask & GMAC_QUE0_MASK)
   21ea4:	f011 0f01 	tst.w	r1, #1
   21ea8:	d00c      	beq.n	21ec4 <DRV_PIC32CGMAC_LibSysInt_Enable+0x20>
        SYS_INT_SourceEnable(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc);
   21eaa:	f9b0 30b6 	ldrsh.w	r3, [r0, #182]	; 0xb6
  if ((int32_t)(IRQn) >= 0)
   21eae:	2b00      	cmp	r3, #0
   21eb0:	db08      	blt.n	21ec4 <DRV_PIC32CGMAC_LibSysInt_Enable+0x20>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   21eb2:	0959      	lsrs	r1, r3, #5
   21eb4:	f003 031f 	and.w	r3, r3, #31
   21eb8:	2201      	movs	r2, #1
   21eba:	fa02 f303 	lsl.w	r3, r2, r3
   21ebe:	4a02      	ldr	r2, [pc, #8]	; (21ec8 <DRV_PIC32CGMAC_LibSysInt_Enable+0x24>)
   21ec0:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
   21ec4:	4770      	bx	lr
   21ec6:	bf00      	nop
   21ec8:	e000e100 	.word	0xe000e100

Disassembly of section .text.DRV_MIIM_Status%844:

00021ecc <DRV_MIIM_Status>:
    if(pMiimObj != 0)
   21ecc:	4603      	mov	r3, r0
   21ece:	b158      	cbz	r0, 21ee8 <DRV_MIIM_Status+0x1c>
        if(pMiimObj->objStatus == SYS_STATUS_READY && (pMiimObj->objFlags & DRV_MIIM_OBJ_FLAG_IN_USE) != 0)
   21ed0:	f990 0008 	ldrsb.w	r0, [r0, #8]
   21ed4:	2802      	cmp	r0, #2
   21ed6:	d10a      	bne.n	21eee <DRV_MIIM_Status+0x22>
   21ed8:	889b      	ldrh	r3, [r3, #4]
   21eda:	f003 0301 	and.w	r3, r3, #1
    return SYS_STATUS_ERROR;
   21ede:	2b00      	cmp	r3, #0
   21ee0:	bf08      	it	eq
   21ee2:	f04f 30ff 	moveq.w	r0, #4294967295
   21ee6:	4770      	bx	lr
   21ee8:	f04f 30ff 	mov.w	r0, #4294967295
   21eec:	4770      	bx	lr
   21eee:	f04f 30ff 	mov.w	r0, #4294967295
} 
   21ef2:	4770      	bx	lr

Disassembly of section .text.TCPIP_ICMP_Deinitialize%845:

00021ef4 <TCPIP_ICMP_Deinitialize>:
{
   21ef4:	b508      	push	{r3, lr}
    if(icmpInitCount > 0)
   21ef6:	4b08      	ldr	r3, [pc, #32]	; (21f18 <TCPIP_ICMP_Deinitialize+0x24>)
   21ef8:	681b      	ldr	r3, [r3, #0]
   21efa:	2b00      	cmp	r3, #0
   21efc:	dd02      	ble.n	21f04 <TCPIP_ICMP_Deinitialize+0x10>
        if(stackCtrl->stackAction == TCPIP_STACK_ACTION_DEINIT)
   21efe:	7f02      	ldrb	r2, [r0, #28]
   21f00:	2a02      	cmp	r2, #2
   21f02:	d000      	beq.n	21f06 <TCPIP_ICMP_Deinitialize+0x12>
}
   21f04:	bd08      	pop	{r3, pc}
            if(--icmpInitCount == 0)
   21f06:	3b01      	subs	r3, #1
   21f08:	4a03      	ldr	r2, [pc, #12]	; (21f18 <TCPIP_ICMP_Deinitialize+0x24>)
   21f0a:	6013      	str	r3, [r2, #0]
   21f0c:	2b00      	cmp	r3, #0
   21f0e:	d1f9      	bne.n	21f04 <TCPIP_ICMP_Deinitialize+0x10>
                TCPIP_ICMP_Cleanup();
   21f10:	f7ff f924 	bl	2115c <TCPIP_ICMP_Cleanup>
}
   21f14:	e7f6      	b.n	21f04 <TCPIP_ICMP_Deinitialize+0x10>
   21f16:	bf00      	nop
   21f18:	2000edb0 	.word	0x2000edb0

Disassembly of section .text._TcpSocketChk%846:

00021f1c <_TcpSocketChk>:
    if(hTCP >= 0 && hTCP < TcpSockets)
   21f1c:	2800      	cmp	r0, #0
   21f1e:	db08      	blt.n	21f32 <_TcpSocketChk+0x16>
   21f20:	4b06      	ldr	r3, [pc, #24]	; (21f3c <_TcpSocketChk+0x20>)
   21f22:	681b      	ldr	r3, [r3, #0]
   21f24:	4298      	cmp	r0, r3
   21f26:	d206      	bcs.n	21f36 <_TcpSocketChk+0x1a>
        return TCBStubs[hTCP];
   21f28:	4b05      	ldr	r3, [pc, #20]	; (21f40 <_TcpSocketChk+0x24>)
   21f2a:	681b      	ldr	r3, [r3, #0]
   21f2c:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
   21f30:	4770      	bx	lr
    return 0;
   21f32:	2000      	movs	r0, #0
   21f34:	4770      	bx	lr
   21f36:	2000      	movs	r0, #0
}
   21f38:	4770      	bx	lr
   21f3a:	bf00      	nop
   21f3c:	2000edc4 	.word	0x2000edc4
   21f40:	2000edc0 	.word	0x2000edc0

Disassembly of section .text._TcpFlush%847:

00021f44 <_TcpFlush>:
{
   21f44:	b508      	push	{r3, lr}
    if(pSkt->txHead != pSkt->txUnackedTail && pSkt->remoteWindow != 0)
   21f46:	6882      	ldr	r2, [r0, #8]
   21f48:	6903      	ldr	r3, [r0, #16]
   21f4a:	429a      	cmp	r2, r3
   21f4c:	d00c      	beq.n	21f68 <_TcpFlush+0x24>
   21f4e:	f8b0 305c 	ldrh.w	r3, [r0, #92]	; 0x5c
   21f52:	b90b      	cbnz	r3, 21f58 <_TcpFlush+0x14>
    return false;
   21f54:	2000      	movs	r0, #0
}
   21f56:	bd08      	pop	{r3, pc}
        return _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS) == 0;
   21f58:	2201      	movs	r2, #1
   21f5a:	2110      	movs	r1, #16
   21f5c:	f7e5 fff0 	bl	7f40 <_TcpSend>
   21f60:	fab0 f080 	clz	r0, r0
   21f64:	0940      	lsrs	r0, r0, #5
   21f66:	e7f6      	b.n	21f56 <_TcpFlush+0x12>
    return false;
   21f68:	2000      	movs	r0, #0
   21f6a:	e7f4      	b.n	21f56 <_TcpFlush+0x12>

Disassembly of section .text._ARPRemoveCacheEntries%848:

00021f6c <_ARPRemoveCacheEntries>:
    if(pArpDcpt->hashDcpt)
   21f6c:	6803      	ldr	r3, [r0, #0]
   21f6e:	b183      	cbz	r3, 21f92 <_ARPRemoveCacheEntries+0x26>
{
   21f70:	b510      	push	{r4, lr}
   21f72:	4604      	mov	r4, r0
        TCPIP_OAHASH_EntriesRemoveAll(pArpDcpt->hashDcpt);
   21f74:	4618      	mov	r0, r3
   21f76:	f7ff f981 	bl	2127c <TCPIP_OAHASH_EntriesRemoveAll>
        TCPIP_Helper_ProtectedSingleListRemoveAll(&pArpDcpt->incompleteList);
   21f7a:	f104 002c 	add.w	r0, r4, #44	; 0x2c
   21f7e:	f7ff ff03 	bl	21d88 <TCPIP_Helper_ProtectedSingleListRemoveAll>
        TCPIP_Helper_ProtectedSingleListRemoveAll(&pArpDcpt->completeList);
   21f82:	f104 0018 	add.w	r0, r4, #24
   21f86:	f7ff feff 	bl	21d88 <TCPIP_Helper_ProtectedSingleListRemoveAll>
        TCPIP_Helper_ProtectedSingleListRemoveAll(&pArpDcpt->permList);
   21f8a:	1d20      	adds	r0, r4, #4
   21f8c:	f7ff fefc 	bl	21d88 <TCPIP_Helper_ProtectedSingleListRemoveAll>
}
   21f90:	bd10      	pop	{r4, pc}
   21f92:	4770      	bx	lr

Disassembly of section .text.GenericTxDone%849:

00021f94 <GenericTxDone>:
{
   21f94:	b510      	push	{r4, lr}
   21f96:	4604      	mov	r4, r0
    if ( pIState->statusReported == 0u )
   21f98:	f890 30cd 	ldrb.w	r3, [r0, #205]	; 0xcd
   21f9c:	b13b      	cbz	r3, 21fae <GenericTxDone+0x1a>
    IperfSetState(pIState, IPERF_STANDBY_STATE);
   21f9e:	2101      	movs	r1, #1
   21fa0:	4620      	mov	r0, r4
   21fa2:	f7fb fe8f 	bl	1dcc4 <IperfSetState>
    ResetIperfCounters(pIState);
   21fa6:	4620      	mov	r0, r4
   21fa8:	f7fc fc18 	bl	1e7dc <ResetIperfCounters>
}
   21fac:	bd10      	pop	{r4, pc}
        ReportBW_Jitter_Loss(pIState, SESSION_REPORT);
   21fae:	2102      	movs	r1, #2
   21fb0:	f7ec fa76 	bl	e4a0 <ReportBW_Jitter_Loss>
        pIState->statusReported = 1;
   21fb4:	2301      	movs	r3, #1
   21fb6:	f884 30cd 	strb.w	r3, [r4, #205]	; 0xcd
   21fba:	e7f0      	b.n	21f9e <GenericTxDone+0xa>

Disassembly of section .text.Ipv4DeRegisterFilter%850:

00021fbc <Ipv4DeRegisterFilter>:
{
   21fbc:	b508      	push	{r3, lr}
    if(hFilter && ipv4MemH)
   21fbe:	b138      	cbz	r0, 21fd0 <Ipv4DeRegisterFilter+0x14>
   21fc0:	4a05      	ldr	r2, [pc, #20]	; (21fd8 <Ipv4DeRegisterFilter+0x1c>)
   21fc2:	6812      	ldr	r2, [r2, #0]
   21fc4:	b132      	cbz	r2, 21fd4 <Ipv4DeRegisterFilter+0x18>
        if(TCPIP_Notification_CbackRemove((SGL_LIST_NODE*)hFilter, &ipv4PacketFilters, ipv4MemH, Ipv4DeRegisterCallback))
   21fc6:	4b05      	ldr	r3, [pc, #20]	; (21fdc <Ipv4DeRegisterFilter+0x20>)
   21fc8:	4905      	ldr	r1, [pc, #20]	; (21fe0 <Ipv4DeRegisterFilter+0x24>)
   21fca:	f7fd f923 	bl	1f214 <TCPIP_Notification_CbackRemove>
}
   21fce:	bd08      	pop	{r3, pc}
    return false;
   21fd0:	2000      	movs	r0, #0
   21fd2:	e7fc      	b.n	21fce <Ipv4DeRegisterFilter+0x12>
   21fd4:	2000      	movs	r0, #0
   21fd6:	e7fa      	b.n	21fce <Ipv4DeRegisterFilter+0x12>
   21fd8:	2000ee34 	.word	0x2000ee34
   21fdc:	00023abd 	.word	0x00023abd
   21fe0:	2000ec50 	.word	0x2000ec50

Disassembly of section .text._DHCPOptionWriteParamRequest%851:

00021fe4 <_DHCPOptionWriteParamRequest>:
    if(pSendData->writeSpace >= sizeof(*pReqL) + nOptions)
   21fe4:	684b      	ldr	r3, [r1, #4]
   21fe6:	2b04      	cmp	r3, #4
   21fe8:	d90b      	bls.n	22002 <_DHCPOptionWriteParamRequest+0x1e>
        pReqL = (TCPIP_DHCP_OPTION_DATA_REQUEST_LIST*)pSendData->pOpt;
   21fea:	680b      	ldr	r3, [r1, #0]
        pReqL->opt = TCPIP_DHCP_PARAM_REQUEST_LIST;
   21fec:	2237      	movs	r2, #55	; 0x37
   21fee:	701a      	strb	r2, [r3, #0]
        pReqL->len = (uint8_t)nOptions;
   21ff0:	2203      	movs	r2, #3
   21ff2:	705a      	strb	r2, [r3, #1]
        memcpy(pReqL->optList, _DHCPRequestParamsTbl, nOptions);
   21ff4:	4a04      	ldr	r2, [pc, #16]	; (22008 <_DHCPOptionWriteParamRequest+0x24>)
   21ff6:	8811      	ldrh	r1, [r2, #0]
   21ff8:	7892      	ldrb	r2, [r2, #2]
   21ffa:	8059      	strh	r1, [r3, #2]
   21ffc:	711a      	strb	r2, [r3, #4]
        return sizeof(*pReqL) + nOptions;
   21ffe:	2005      	movs	r0, #5
   22000:	4770      	bx	lr
    return -1;
   22002:	f04f 30ff 	mov.w	r0, #4294967295
}
   22006:	4770      	bx	lr
   22008:	00024490 	.word	0x00024490

Disassembly of section .text.TCPIP_DHCP_IsActive%852:

0002200c <TCPIP_DHCP_IsActive>:
   2200c:	b130      	cbz	r0, 2201c <TCPIP_DHCP_IsActive+0x10>
   2200e:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
   22012:	f010 0f40 	tst.w	r0, #64	; 0x40
   22016:	d103      	bne.n	22020 <TCPIP_DHCP_IsActive+0x14>
    return false;
   22018:	2000      	movs	r0, #0
   2201a:	4770      	bx	lr
   2201c:	2000      	movs	r0, #0
   2201e:	4770      	bx	lr
    if(DHCPClients && pNetIf)
   22020:	4b03      	ldr	r3, [pc, #12]	; (22030 <TCPIP_DHCP_IsActive+0x24>)
   22022:	681b      	ldr	r3, [r3, #0]
   22024:	b113      	cbz	r3, 2202c <TCPIP_DHCP_IsActive+0x20>
        return pNetIf->Flags.bIsDHCPEnabled != 0;
   22026:	f000 0001 	and.w	r0, r0, #1
   2202a:	4770      	bx	lr
    return false;
   2202c:	2000      	movs	r0, #0
}
   2202e:	4770      	bx	lr
   22030:	2000ee3c 	.word	0x2000ee3c

Disassembly of section .text._TCPIP_STACK_TickHandler%853:

00022034 <_TCPIP_STACK_TickHandler>:
{
   22034:	b508      	push	{r3, lr}
    newTcpipTickAvlbl++;
   22036:	4a07      	ldr	r2, [pc, #28]	; (22054 <_TCPIP_STACK_TickHandler+0x20>)
   22038:	6813      	ldr	r3, [r2, #0]
   2203a:	3301      	adds	r3, #1
   2203c:	6013      	str	r3, [r2, #0]
    pTmoEntry->signalVal |= TCPIP_MODULE_SIGNAL_TMO;
   2203e:	4806      	ldr	r0, [pc, #24]	; (22058 <_TCPIP_STACK_TickHandler+0x24>)
   22040:	8903      	ldrh	r3, [r0, #8]
   22042:	f043 0302 	orr.w	r3, r3, #2
   22046:	8103      	strh	r3, [r0, #8]
    _TCPIPSignalEntryNotify(pMgrEntry, TCPIP_MODULE_SIGNAL_TMO, 0);
   22048:	2200      	movs	r2, #0
   2204a:	2102      	movs	r1, #2
   2204c:	3010      	adds	r0, #16
   2204e:	f001 f827 	bl	230a0 <_TCPIPSignalEntryNotify>
}
   22052:	bd08      	pop	{r3, pc}
   22054:	2000ee64 	.word	0x2000ee64
   22058:	2000d9a4 	.word	0x2000d9a4

Disassembly of section .text._TCPIPSignalEntrySetNotify%854:

0002205c <_TCPIPSignalEntrySetNotify>:
{
   2205c:	b570      	push	{r4, r5, r6, lr}
   2205e:	4604      	mov	r4, r0
   22060:	460d      	mov	r5, r1
   22062:	4616      	mov	r6, r2
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   22064:	2000      	movs	r0, #0
   22066:	f001 fb85 	bl	23774 <OSAL_CRIT_Enter>
    pSigEntry->signalVal |= (uint16_t)signal;
   2206a:	8923      	ldrh	r3, [r4, #8]
   2206c:	432b      	orrs	r3, r5
   2206e:	8123      	strh	r3, [r4, #8]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   22070:	4601      	mov	r1, r0
   22072:	2000      	movs	r0, #0
   22074:	f001 fcb8 	bl	239e8 <OSAL_CRIT_Leave>
    _TCPIPSignalEntryNotify(pSigEntry, signals, sigParam);
   22078:	4632      	mov	r2, r6
   2207a:	4629      	mov	r1, r5
   2207c:	4620      	mov	r0, r4
   2207e:	f001 f80f 	bl	230a0 <_TCPIPSignalEntryNotify>
}
   22082:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_STACK_IndexToNet%855:

00022084 <TCPIP_STACK_IndexToNet>:
    if(0 <= netIx && netIx < tcpip_stack_ctrl_data.nIfs)
   22084:	2800      	cmp	r0, #0
   22086:	db09      	blt.n	2209c <TCPIP_STACK_IndexToNet+0x18>
   22088:	4b06      	ldr	r3, [pc, #24]	; (220a4 <TCPIP_STACK_IndexToNet+0x20>)
   2208a:	681b      	ldr	r3, [r3, #0]
   2208c:	4283      	cmp	r3, r0
   2208e:	dd07      	ble.n	220a0 <TCPIP_STACK_IndexToNet+0x1c>
        return tcpipNetIf + netIx;
   22090:	4b05      	ldr	r3, [pc, #20]	; (220a8 <TCPIP_STACK_IndexToNet+0x24>)
   22092:	681b      	ldr	r3, [r3, #0]
   22094:	226c      	movs	r2, #108	; 0x6c
   22096:	fb02 3000 	mla	r0, r2, r0, r3
   2209a:	4770      	bx	lr
    return 0;
   2209c:	2000      	movs	r0, #0
   2209e:	4770      	bx	lr
   220a0:	2000      	movs	r0, #0
}
   220a2:	4770      	bx	lr
   220a4:	2000eae4 	.word	0x2000eae4
   220a8:	2000ee74 	.word	0x2000ee74

Disassembly of section .text.TCPIP_STACK_NetMACStatisticsGet%856:

000220ac <TCPIP_STACK_NetMACStatisticsGet>:
   220ac:	b180      	cbz	r0, 220d0 <TCPIP_STACK_NetMACStatisticsGet+0x24>
   220ae:	4603      	mov	r3, r0
   220b0:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
   220b4:	f010 0f40 	tst.w	r0, #64	; 0x40
   220b8:	d101      	bne.n	220be <TCPIP_STACK_NetMACStatisticsGet+0x12>
    return false;
   220ba:	2000      	movs	r0, #0
}
   220bc:	4770      	bx	lr
{
   220be:	b510      	push	{r4, lr}
        TCPIP_MAC_RES res = (*pNetIf->pMacObj->TCPIP_MAC_StatisticsGet)(pNetIf->hIfMac, pRxStatistics, pTxStatistics);
   220c0:	6c58      	ldr	r0, [r3, #68]	; 0x44
   220c2:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
   220c4:	6d18      	ldr	r0, [r3, #80]	; 0x50
   220c6:	47a0      	blx	r4
        if(res == TCPIP_MAC_RES_OK)
   220c8:	fab0 f080 	clz	r0, r0
   220cc:	0940      	lsrs	r0, r0, #5
}
   220ce:	bd10      	pop	{r4, pc}
    return false;
   220d0:	2000      	movs	r0, #0
   220d2:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetMACRegisterStatisticsGet%857:

000220d4 <TCPIP_STACK_NetMACRegisterStatisticsGet>:
   220d4:	b180      	cbz	r0, 220f8 <TCPIP_STACK_NetMACRegisterStatisticsGet+0x24>
{
   220d6:	b538      	push	{r3, r4, r5, lr}
   220d8:	4604      	mov	r4, r0
   220da:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
   220de:	f010 0f40 	tst.w	r0, #64	; 0x40
   220e2:	d101      	bne.n	220e8 <TCPIP_STACK_NetMACRegisterStatisticsGet+0x14>
    return false;
   220e4:	2000      	movs	r0, #0
}
   220e6:	bd38      	pop	{r3, r4, r5, pc}
        TCPIP_MAC_RES res = (*pNetIf->pMacObj->TCPIP_MAC_RegisterStatisticsGet)(pNetIf->hIfMac, pRegEntries, nEntries, pHwEntries);
   220e8:	6c60      	ldr	r0, [r4, #68]	; 0x44
   220ea:	6c45      	ldr	r5, [r0, #68]	; 0x44
   220ec:	6d20      	ldr	r0, [r4, #80]	; 0x50
   220ee:	47a8      	blx	r5
        if(res == TCPIP_MAC_RES_OK)
   220f0:	fab0 f080 	clz	r0, r0
   220f4:	0940      	lsrs	r0, r0, #5
   220f6:	e7f6      	b.n	220e6 <TCPIP_STACK_NetMACRegisterStatisticsGet+0x12>
    return false;
   220f8:	2000      	movs	r0, #0
}
   220fa:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetIsBcastAddress%858:

000220fc <TCPIP_STACK_NetIsBcastAddress>:
   220fc:	b180      	cbz	r0, 22120 <TCPIP_STACK_NetIsBcastAddress+0x24>
   220fe:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   22102:	f012 0f40 	tst.w	r2, #64	; 0x40
   22106:	d101      	bne.n	2210c <TCPIP_STACK_NetIsBcastAddress+0x10>
    return false;
   22108:	2000      	movs	r0, #0
}
   2210a:	4770      	bx	lr
       return (pIpAdd->Val == (pNetIf->netIPAddr.Val | ~pNetIf->netMask.Val));
   2210c:	6882      	ldr	r2, [r0, #8]
   2210e:	6840      	ldr	r0, [r0, #4]
   22110:	ea60 0002 	orn	r0, r0, r2
   22114:	680b      	ldr	r3, [r1, #0]
   22116:	4298      	cmp	r0, r3
   22118:	bf14      	ite	ne
   2211a:	2000      	movne	r0, #0
   2211c:	2001      	moveq	r0, #1
   2211e:	4770      	bx	lr
    return false;
   22120:	2000      	movs	r0, #0
   22122:	4770      	bx	lr

Disassembly of section .text._TCPIPStackSignalHandlerSetParams%859:

00022124 <_TCPIPStackSignalHandlerSetParams>:
    if((pSignalEntry = (TCPIP_MODULE_SIGNAL_ENTRY*)handle) != 0 && pSignalEntry->signalHandler != 0)
   22124:	460b      	mov	r3, r1
   22126:	b159      	cbz	r1, 22140 <_TCPIPStackSignalHandlerSetParams+0x1c>
   22128:	6809      	ldr	r1, [r1, #0]
   2212a:	b159      	cbz	r1, 22144 <_TCPIPStackSignalHandlerSetParams+0x20>
		if ((asyncTmoMs != 0) && (asyncTmoMs < stackTaskRate))
   2212c:	b122      	cbz	r2, 22138 <_TCPIPStackSignalHandlerSetParams+0x14>
   2212e:	4906      	ldr	r1, [pc, #24]	; (22148 <_TCPIPStackSignalHandlerSetParams+0x24>)
   22130:	6809      	ldr	r1, [r1, #0]
   22132:	428a      	cmp	r2, r1
            asyncTmoMs = stackTaskRate;
   22134:	bf38      	it	cc
   22136:	b20a      	sxthcc	r2, r1
        pSignalEntry->asyncTmo = pSignalEntry->currTmo = asyncTmoMs;
   22138:	819a      	strh	r2, [r3, #12]
   2213a:	815a      	strh	r2, [r3, #10]
        return true;
   2213c:	2001      	movs	r0, #1
   2213e:	4770      	bx	lr
    return false;
   22140:	2000      	movs	r0, #0
   22142:	4770      	bx	lr
   22144:	2000      	movs	r0, #0
}
   22146:	4770      	bx	lr
   22148:	2000ee6c 	.word	0x2000ee6c

Disassembly of section .text._UDPSocketDcpt%860:

0002214c <_UDPSocketDcpt>:
    if(s >= 0 && s < nUdpSockets)
   2214c:	2800      	cmp	r0, #0
   2214e:	db08      	blt.n	22162 <_UDPSocketDcpt+0x16>
   22150:	4b06      	ldr	r3, [pc, #24]	; (2216c <_UDPSocketDcpt+0x20>)
   22152:	681b      	ldr	r3, [r3, #0]
   22154:	4298      	cmp	r0, r3
   22156:	da06      	bge.n	22166 <_UDPSocketDcpt+0x1a>
       return UDPSocketDcpt[s];
   22158:	4b05      	ldr	r3, [pc, #20]	; (22170 <_UDPSocketDcpt+0x24>)
   2215a:	681b      	ldr	r3, [r3, #0]
   2215c:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
   22160:	4770      	bx	lr
    return 0;
   22162:	2000      	movs	r0, #0
   22164:	4770      	bx	lr
   22166:	2000      	movs	r0, #0
}
   22168:	4770      	bx	lr
   2216a:	bf00      	nop
   2216c:	2000ee8c 	.word	0x2000ee8c
   22170:	2000ee88 	.word	0x2000ee88

Disassembly of section .text._UDPUpdatePacketLock%861:

00022174 <_UDPUpdatePacketLock>:
{
   22174:	b570      	push	{r4, r5, r6, lr}
   22176:	4604      	mov	r4, r0
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   22178:	2000      	movs	r0, #0
   2217a:	f001 fafb 	bl	23774 <OSAL_CRIT_Enter>
   2217e:	4606      	mov	r6, r0
    SGL_LIST_NODE* pNode = TCPIP_Helper_SingleListHeadRemove(&pSkt->rxQueue);
   22180:	f104 0044 	add.w	r0, r4, #68	; 0x44
   22184:	f000 ff70 	bl	23068 <TCPIP_Helper_SingleListHeadRemove>
   22188:	4605      	mov	r5, r0
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   2218a:	4631      	mov	r1, r6
   2218c:	2000      	movs	r0, #0
   2218e:	f001 fc2b 	bl	239e8 <OSAL_CRIT_Leave>
    _UDPSetNewRxPacket(pSkt, pNextPkt);
   22192:	4629      	mov	r1, r5
   22194:	4620      	mov	r0, r4
   22196:	f7fd fac3 	bl	1f720 <_UDPSetNewRxPacket>
}
   2219a:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_UDP_GetIsReady%862:

0002219c <TCPIP_UDP_GetIsReady>:
{
   2219c:	b510      	push	{r4, lr}
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   2219e:	f7ff ffd5 	bl	2214c <_UDPSocketDcpt>
    if(pSkt == 0)
   221a2:	b168      	cbz	r0, 221c0 <TCPIP_UDP_GetIsReady+0x24>
   221a4:	4604      	mov	r4, r0
    if(pSkt->pCurrRxSeg == 0 || pSkt->rxTotLen == 0)
   221a6:	6b03      	ldr	r3, [r0, #48]	; 0x30
   221a8:	b10b      	cbz	r3, 221ae <TCPIP_UDP_GetIsReady+0x12>
   221aa:	8ec3      	ldrh	r3, [r0, #54]	; 0x36
   221ac:	b933      	cbnz	r3, 221bc <TCPIP_UDP_GetIsReady+0x20>
        _UDPUpdatePacketLock(pSkt);
   221ae:	4620      	mov	r0, r4
   221b0:	f7ff ffe0 	bl	22174 <_UDPUpdatePacketLock>
    return pSkt->pCurrRxSeg == 0 ? 0 : pSkt->rxTotLen;
   221b4:	6b23      	ldr	r3, [r4, #48]	; 0x30
   221b6:	b90b      	cbnz	r3, 221bc <TCPIP_UDP_GetIsReady+0x20>
   221b8:	2000      	movs	r0, #0
   221ba:	e000      	b.n	221be <TCPIP_UDP_GetIsReady+0x22>
   221bc:	8ee0      	ldrh	r0, [r4, #54]	; 0x36
}
   221be:	bd10      	pop	{r4, pc}
        return 0;
   221c0:	2000      	movs	r0, #0
   221c2:	e7fc      	b.n	221be <TCPIP_UDP_GetIsReady+0x22>

Disassembly of section .text._DHCPS_GetOptionLen%863:

000221c4 <_DHCPS_GetOptionLen>:
{
   221c4:	b570      	push	{r4, r5, r6, lr}
   221c6:	4605      	mov	r5, r0
   221c8:	460c      	mov	r4, r1
   221ca:	4616      	mov	r6, r2
    if(!TCPIP_DHCPS_GetDataFromUDPBuff(inputBuf,(uint8_t *)optionVal))
   221cc:	f001 f97c 	bl	234c8 <TCPIP_DHCPS_GetDataFromUDPBuff>
   221d0:	4603      	mov	r3, r0
   221d2:	b138      	cbz	r0, 221e4 <_DHCPS_GetOptionLen+0x20>
    if(*optionVal == DHCP_END_OPTION)
   221d4:	7823      	ldrb	r3, [r4, #0]
   221d6:	2bff      	cmp	r3, #255	; 0xff
   221d8:	d006      	beq.n	221e8 <_DHCPS_GetOptionLen+0x24>
    if(!TCPIP_DHCPS_GetDataFromUDPBuff(inputBuf,(uint8_t *)optionLen))
   221da:	4631      	mov	r1, r6
   221dc:	4628      	mov	r0, r5
   221de:	f001 f973 	bl	234c8 <TCPIP_DHCPS_GetDataFromUDPBuff>
   221e2:	4603      	mov	r3, r0
}
   221e4:	4618      	mov	r0, r3
   221e6:	bd70      	pop	{r4, r5, r6, pc}
        return false;
   221e8:	2300      	movs	r3, #0
   221ea:	e7fb      	b.n	221e4 <_DHCPS_GetOptionLen+0x20>

Disassembly of section .text.TC0_Timer16bitCounterGet%864:

000221ec <TC0_Timer16bitCounterGet>:
    TC0_REGS->COUNT16.TC_CTRLBSET |= (uint8_t)TC_CTRLBSET_CMD_READSYNC;
   221ec:	4a08      	ldr	r2, [pc, #32]	; (22210 <TC0_Timer16bitCounterGet+0x24>)
   221ee:	7953      	ldrb	r3, [r2, #5]
   221f0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   221f4:	7153      	strb	r3, [r2, #5]
    while((TC0_REGS->COUNT16.TC_SYNCBUSY & TC_SYNCBUSY_CTRLB_Msk) == TC_SYNCBUSY_CTRLB_Msk)
   221f6:	6913      	ldr	r3, [r2, #16]
   221f8:	f013 0f04 	tst.w	r3, #4
   221fc:	d1fb      	bne.n	221f6 <TC0_Timer16bitCounterGet+0xa>
    while((TC0_REGS->COUNT16.TC_CTRLBSET & TC_CTRLBSET_CMD_Msk) != 0U)
   221fe:	4a04      	ldr	r2, [pc, #16]	; (22210 <TC0_Timer16bitCounterGet+0x24>)
   22200:	7953      	ldrb	r3, [r2, #5]
   22202:	f013 0fe0 	tst.w	r3, #224	; 0xe0
   22206:	d1fb      	bne.n	22200 <TC0_Timer16bitCounterGet+0x14>
    return (uint16_t)TC0_REGS->COUNT16.TC_COUNT;
   22208:	4b01      	ldr	r3, [pc, #4]	; (22210 <TC0_Timer16bitCounterGet+0x24>)
   2220a:	8a98      	ldrh	r0, [r3, #20]
}
   2220c:	4770      	bx	lr
   2220e:	bf00      	nop
   22210:	40003800 	.word	0x40003800

Disassembly of section .text.Console_UART_Initialize%865:

00022214 <Console_UART_Initialize>:
    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   22214:	b960      	cbnz	r0, 22230 <Console_UART_Initialize+0x1c>
{
   22216:	b510      	push	{r4, lr}
   22218:	460c      	mov	r4, r1
    if(OSAL_MUTEX_Create(&(pConsoleUartData->mutexTransferObjects)) != OSAL_RESULT_TRUE)
   2221a:	4806      	ldr	r0, [pc, #24]	; (22234 <Console_UART_Initialize+0x20>)
   2221c:	f001 fac2 	bl	237a4 <OSAL_MUTEX_Create>
   22220:	2801      	cmp	r0, #1
   22222:	d104      	bne.n	2222e <Console_UART_Initialize+0x1a>
    pConsoleUartData->uartPLIB = consoleUsartInitData->uartPLIB;
   22224:	6822      	ldr	r2, [r4, #0]
   22226:	4b04      	ldr	r3, [pc, #16]	; (22238 <Console_UART_Initialize+0x24>)
   22228:	601a      	str	r2, [r3, #0]
    pConsoleUartData->status = SYS_CONSOLE_STATUS_CONFIGURED;
   2222a:	2201      	movs	r2, #1
   2222c:	711a      	strb	r2, [r3, #4]
}
   2222e:	bd10      	pop	{r4, pc}
   22230:	4770      	bx	lr
   22232:	bf00      	nop
   22234:	2000ed60 	.word	0x2000ed60
   22238:	2000ed58 	.word	0x2000ed58

Disassembly of section .text.SYS_TMR_TickCountGet%866:

0002223c <SYS_TMR_TickCountGet>:
}

static uint32_t gTickConv = 0;

uint32_t SYS_TMR_TickCountGet(void)
{
   2223c:	b508      	push	{r3, lr}
    if(gTickConv == 0)
   2223e:	4b08      	ldr	r3, [pc, #32]	; (22260 <SYS_TMR_TickCountGet+0x24>)
   22240:	681b      	ldr	r3, [r3, #0]
   22242:	b13b      	cbz	r3, 22254 <SYS_TMR_TickCountGet+0x18>
    {
        gTickConv = SYS_TIME_MSToCount(1);
    }

    return (uint32_t)(SYS_TIME_Counter64Get() / (uint64_t)gTickConv);
   22244:	f7fe f848 	bl	202d8 <SYS_TIME_Counter64Get>
   22248:	4b05      	ldr	r3, [pc, #20]	; (22260 <SYS_TMR_TickCountGet+0x24>)
   2224a:	681a      	ldr	r2, [r3, #0]
   2224c:	2300      	movs	r3, #0
   2224e:	f7ff f9c5 	bl	215dc <__aeabi_uldivmod>
}
   22252:	bd08      	pop	{r3, pc}
        gTickConv = SYS_TIME_MSToCount(1);
   22254:	2001      	movs	r0, #1
   22256:	f000 fff5 	bl	23244 <SYS_TIME_MSToCount>
   2225a:	4b01      	ldr	r3, [pc, #4]	; (22260 <SYS_TMR_TickCountGet+0x24>)
   2225c:	6018      	str	r0, [r3, #0]
   2225e:	e7f1      	b.n	22244 <SYS_TMR_TickCountGet+0x8>
   22260:	2000eee0 	.word	0x2000eee0

Disassembly of section .text.SYS_TMR_TickCountGetLong%867:

00022264 <SYS_TMR_TickCountGetLong>:

uint64_t SYS_TMR_TickCountGetLong(void)
{
   22264:	b508      	push	{r3, lr}
    if(gTickConv == 0)
   22266:	4b08      	ldr	r3, [pc, #32]	; (22288 <SYS_TMR_TickCountGetLong+0x24>)
   22268:	681b      	ldr	r3, [r3, #0]
   2226a:	b13b      	cbz	r3, 2227c <SYS_TMR_TickCountGetLong+0x18>
    {
        gTickConv = SYS_TIME_MSToCount(1);
    }

	return SYS_TIME_Counter64Get() / (uint64_t)gTickConv;
   2226c:	f7fe f834 	bl	202d8 <SYS_TIME_Counter64Get>
   22270:	4b05      	ldr	r3, [pc, #20]	; (22288 <SYS_TMR_TickCountGetLong+0x24>)
   22272:	681a      	ldr	r2, [r3, #0]
   22274:	2300      	movs	r3, #0
   22276:	f7ff f9b1 	bl	215dc <__aeabi_uldivmod>
}
   2227a:	bd08      	pop	{r3, pc}
        gTickConv = SYS_TIME_MSToCount(1);
   2227c:	2001      	movs	r0, #1
   2227e:	f000 ffe1 	bl	23244 <SYS_TIME_MSToCount>
   22282:	4b01      	ldr	r3, [pc, #4]	; (22288 <SYS_TMR_TickCountGetLong+0x24>)
   22284:	6018      	str	r0, [r3, #0]
   22286:	e7f1      	b.n	2226c <SYS_TMR_TickCountGetLong+0x8>
   22288:	2000eee0 	.word	0x2000eee0

Disassembly of section .text.SYS_TMR_TickCounterFrequencyGet%868:

0002228c <SYS_TMR_TickCounterFrequencyGet>:

uint32_t SYS_TMR_TickCounterFrequencyGet ( void )
{
   2228c:	b508      	push	{r3, lr}
    if(gTickConv == 0)
   2228e:	4b08      	ldr	r3, [pc, #32]	; (222b0 <SYS_TMR_TickCounterFrequencyGet+0x24>)
   22290:	681b      	ldr	r3, [r3, #0]
   22292:	b133      	cbz	r3, 222a2 <SYS_TMR_TickCounterFrequencyGet+0x16>
    {
        gTickConv = SYS_TIME_MSToCount(1);
    }

	return SYS_TIME_FrequencyGet() / gTickConv;
   22294:	f001 fffa 	bl	2428c <SYS_TIME_FrequencyGet>
   22298:	4b05      	ldr	r3, [pc, #20]	; (222b0 <SYS_TMR_TickCounterFrequencyGet+0x24>)
   2229a:	681b      	ldr	r3, [r3, #0]
}
   2229c:	fbb0 f0f3 	udiv	r0, r0, r3
   222a0:	bd08      	pop	{r3, pc}
        gTickConv = SYS_TIME_MSToCount(1);
   222a2:	2001      	movs	r0, #1
   222a4:	f000 ffce 	bl	23244 <SYS_TIME_MSToCount>
   222a8:	4b01      	ldr	r3, [pc, #4]	; (222b0 <SYS_TMR_TickCounterFrequencyGet+0x24>)
   222aa:	6018      	str	r0, [r3, #0]
   222ac:	e7f2      	b.n	22294 <SYS_TMR_TickCounterFrequencyGet+0x8>
   222ae:	bf00      	nop
   222b0:	2000eee0 	.word	0x2000eee0

Disassembly of section .rodata.tcpipARPInitData%869:

000222b4 <tcpipARPInitData>:
   222b4:	00000005 00000001 000004b0 0000003c     ............<...
   222c4:	00000002 00000032 0000004b 00000001     ....2...K.......
   222d4:	00000003 00000001                       ........

Disassembly of section .text.prvPortStartFirstTask%870:

000222dc <prvPortStartFirstTask>:
	__asm volatile(
   222dc:	4808      	ldr	r0, [pc, #32]	; (22300 <prvPortStartFirstTask+0x24>)
   222de:	6800      	ldr	r0, [r0, #0]
   222e0:	6800      	ldr	r0, [r0, #0]
   222e2:	f380 8808 	msr	MSP, r0
   222e6:	f04f 0000 	mov.w	r0, #0
   222ea:	f380 8814 	msr	CONTROL, r0
   222ee:	b662      	cpsie	i
   222f0:	b661      	cpsie	f
   222f2:	f3bf 8f4f 	dsb	sy
   222f6:	f3bf 8f6f 	isb	sy
   222fa:	df00      	svc	0
   222fc:	bf00      	nop
}
   222fe:	0000      	.short	0x0000
   22300:	e000ed08 	.word	0xe000ed08

Disassembly of section .text.vPortSetupTimerInterrupt%871:

00022304 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Stop and clear the SysTick. */
	portNVIC_SYSTICK_CTRL_REG = 0UL;
   22304:	4b05      	ldr	r3, [pc, #20]	; (2231c <vPortSetupTimerInterrupt+0x18>)
   22306:	2200      	movs	r2, #0
   22308:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
   2230a:	4905      	ldr	r1, [pc, #20]	; (22320 <vPortSetupTimerInterrupt+0x1c>)
   2230c:	600a      	str	r2, [r1, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
   2230e:	4a05      	ldr	r2, [pc, #20]	; (22324 <vPortSetupTimerInterrupt+0x20>)
   22310:	4905      	ldr	r1, [pc, #20]	; (22328 <vPortSetupTimerInterrupt+0x24>)
   22312:	6011      	str	r1, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
   22314:	2207      	movs	r2, #7
   22316:	601a      	str	r2, [r3, #0]
}
   22318:	4770      	bx	lr
   2231a:	bf00      	nop
   2231c:	e000e010 	.word	0xe000e010
   22320:	e000e018 	.word	0xe000e018
   22324:	e000e014 	.word	0xe000e014
   22328:	0001d4bf 	.word	0x0001d4bf

Disassembly of section .rodata.__mprec_bigtens%872:

00022330 <__mprec_bigtens>:
   22330:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
   22340:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
   22350:	7f73bf3c 75154fdd                       <.s..O.u

Disassembly of section .text.read%873:

00022358 <read>:
   22358:	b570      	push	{r4, r5, r6, lr}
   2235a:	b169      	cbz	r1, 22378 <read+0x20>
   2235c:	4615      	mov	r5, r2
   2235e:	b14a      	cbz	r2, 22374 <read+0x1c>
   22360:	b940      	cbnz	r0, 22374 <read+0x1c>
   22362:	460c      	mov	r4, r1
   22364:	188e      	adds	r6, r1, r2
   22366:	2001      	movs	r0, #1
   22368:	f002 f898 	bl	2449c <_mon_getc>
   2236c:	f804 0b01 	strb.w	r0, [r4], #1
   22370:	42a6      	cmp	r6, r4
   22372:	d1f8      	bne.n	22366 <read+0xe>
   22374:	4628      	mov	r0, r5
   22376:	bd70      	pop	{r4, r5, r6, pc}
   22378:	460d      	mov	r5, r1
   2237a:	4628      	mov	r0, r5
   2237c:	bd70      	pop	{r4, r5, r6, pc}
   2237e:	bf00      	nop

Disassembly of section .text._DRV_ETHPHY_NegResultPhase_ANEXP%874:

00022380 <_DRV_ETHPHY_NegResultPhase_ANEXP>:
{
   22380:	b510      	push	{r4, lr}
   22382:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   22384:	f000 faa6 	bl	228d4 <_DRV_PHY_SMITransfer_Wait>
   22388:	b900      	cbnz	r0, 2238c <_DRV_ETHPHY_NegResultPhase_ANEXP+0xc>
}
   2238a:	bd10      	pop	{r4, pc}
    hClientObj->operReg[0] = hClientObj->smiData;
   2238c:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   2238e:	8463      	strh	r3, [r4, #34]	; 0x22
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_ANLPAD))
   22390:	2105      	movs	r1, #5
   22392:	4620      	mov	r0, r4
   22394:	f7fe fdec 	bl	20f70 <_DRV_PHY_SMIReadStart>
   22398:	2800      	cmp	r0, #0
   2239a:	d0f6      	beq.n	2238a <_DRV_ETHPHY_NegResultPhase_ANEXP+0xa>
    hClientObj->operPhase = operPhase;
   2239c:	2303      	movs	r3, #3
   2239e:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   223a0:	2300      	movs	r3, #0
   223a2:	8423      	strh	r3, [r4, #32]
   223a4:	e7f1      	b.n	2238a <_DRV_ETHPHY_NegResultPhase_ANEXP+0xa>

Disassembly of section .text._DRV_ETHPHY_NegResultPhase_ANLPAD%875:

000223a6 <_DRV_ETHPHY_NegResultPhase_ANLPAD>:
{
   223a6:	b510      	push	{r4, lr}
   223a8:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   223aa:	f000 fa93 	bl	228d4 <_DRV_PHY_SMITransfer_Wait>
   223ae:	b900      	cbnz	r0, 223b2 <_DRV_ETHPHY_NegResultPhase_ANLPAD+0xc>
}
   223b0:	bd10      	pop	{r4, pc}
    hClientObj->operReg[1] = hClientObj->smiData;
   223b2:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   223b4:	84a3      	strh	r3, [r4, #36]	; 0x24
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_ANAD))
   223b6:	2104      	movs	r1, #4
   223b8:	4620      	mov	r0, r4
   223ba:	f7fe fdd9 	bl	20f70 <_DRV_PHY_SMIReadStart>
   223be:	2800      	cmp	r0, #0
   223c0:	d0f6      	beq.n	223b0 <_DRV_ETHPHY_NegResultPhase_ANLPAD+0xa>
    hClientObj->operPhase = operPhase;
   223c2:	2304      	movs	r3, #4
   223c4:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   223c6:	2300      	movs	r3, #0
   223c8:	8423      	strh	r3, [r4, #32]
   223ca:	e7f1      	b.n	223b0 <_DRV_ETHPHY_NegResultPhase_ANLPAD+0xa>

Disassembly of section .text.TCPIP_TCP_IsConnected%876:

000223cc <TCPIP_TCP_IsConnected>:
{
   223cc:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   223ce:	f7ff fda5 	bl	21f1c <_TcpSocketChk>
    return (pSkt) ? _TCP_IsConnected(pSkt) : false;
   223d2:	b160      	cbz	r0, 223ee <TCPIP_TCP_IsConnected+0x22>
    return (pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1 || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2 || pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT);
   223d4:	f890 006e 	ldrb.w	r0, [r0, #110]	; 0x6e
   223d8:	1ec3      	subs	r3, r0, #3
   223da:	b2db      	uxtb	r3, r3
   223dc:	2b02      	cmp	r3, #2
   223de:	d904      	bls.n	223ea <TCPIP_TCP_IsConnected+0x1e>
   223e0:	2808      	cmp	r0, #8
   223e2:	bf14      	ite	ne
   223e4:	2000      	movne	r0, #0
   223e6:	2001      	moveq	r0, #1
   223e8:	e000      	b.n	223ec <TCPIP_TCP_IsConnected+0x20>
   223ea:	2001      	movs	r0, #1
}
   223ec:	bd08      	pop	{r3, pc}
    return (pSkt) ? _TCP_IsConnected(pSkt) : false;
   223ee:	2000      	movs	r0, #0
   223f0:	e7fc      	b.n	223ec <TCPIP_TCP_IsConnected+0x20>

Disassembly of section .text.TCPIP_TCP_Flush%877:

000223f2 <TCPIP_TCP_Flush>:
{
   223f2:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   223f4:	f7ff fd92 	bl	21f1c <_TcpSocketChk>
    if(pSkt && _TCP_TxPktValid(pSkt))
   223f8:	b150      	cbz	r0, 22410 <TCPIP_TCP_Flush+0x1e>
    switch(pSkt->addType)
   223fa:	f890 206f 	ldrb.w	r2, [r0, #111]	; 0x6f
   223fe:	2a01      	cmp	r2, #1
   22400:	d001      	beq.n	22406 <TCPIP_TCP_Flush+0x14>
    return false;
   22402:	2000      	movs	r0, #0
}
   22404:	bd08      	pop	{r3, pc}
    if(pSkt && _TCP_TxPktValid(pSkt))
   22406:	6c42      	ldr	r2, [r0, #68]	; 0x44
   22408:	b122      	cbz	r2, 22414 <TCPIP_TCP_Flush+0x22>
        return _TcpFlush(pSkt);
   2240a:	f7ff fd9b 	bl	21f44 <_TcpFlush>
   2240e:	e7f9      	b.n	22404 <TCPIP_TCP_Flush+0x12>
    return false;
   22410:	2000      	movs	r0, #0
   22412:	e7f7      	b.n	22404 <TCPIP_TCP_Flush+0x12>
   22414:	2000      	movs	r0, #0
   22416:	e7f5      	b.n	22404 <TCPIP_TCP_Flush+0x12>

Disassembly of section .text.TCPIP_TCP_Discard%878:

00022418 <TCPIP_TCP_Discard>:
{
   22418:	b538      	push	{r3, r4, r5, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   2241a:	f7ff fd7f 	bl	21f1c <_TcpSocketChk>
    if(pSkt)
   2241e:	b160      	cbz	r0, 2243a <TCPIP_TCP_Discard+0x22>
   22420:	4604      	mov	r4, r0
        nBytes = _TCPIsGetReady(pSkt);
   22422:	f000 fd1c 	bl	22e5e <_TCPIsGetReady>
        if(nBytes)
   22426:	4605      	mov	r5, r0
   22428:	b908      	cbnz	r0, 2242e <TCPIP_TCP_Discard+0x16>
}
   2242a:	4628      	mov	r0, r5
   2242c:	bd38      	pop	{r3, r4, r5, pc}
            pSkt->rxTail = pSkt->rxHead;
   2242e:	69e3      	ldr	r3, [r4, #28]
   22430:	6223      	str	r3, [r4, #32]
            _TCPSendWinIncUpdate(pSkt);
   22432:	4620      	mov	r0, r4
   22434:	f7fc fbdc 	bl	1ebf0 <_TCPSendWinIncUpdate>
   22438:	e7f7      	b.n	2242a <TCPIP_TCP_Discard+0x12>
    uint16_t nBytes = 0;
   2243a:	2500      	movs	r5, #0
   2243c:	e7f5      	b.n	2242a <TCPIP_TCP_Discard+0x12>

Disassembly of section .text.TCPIP_OAHASH_Initialize%879:

0002243e <TCPIP_OAHASH_Initialize>:
    pOH->fullSlots = 0; 
   2243e:	2300      	movs	r3, #0
   22440:	6243      	str	r3, [r0, #36]	; 0x24
    pHE = (OA_HASH_ENTRY*)pOH->memBlk;
   22442:	6803      	ldr	r3, [r0, #0]
    for(ix = 0; ix < pOH->hEntries; ix++)
   22444:	68c2      	ldr	r2, [r0, #12]
   22446:	b162      	cbz	r2, 22462 <TCPIP_OAHASH_Initialize+0x24>
{
   22448:	b410      	push	{r4}
    for(ix = 0; ix < pOH->hEntries; ix++)
   2244a:	2200      	movs	r2, #0
        pHE->flags.value = 0;
   2244c:	4614      	mov	r4, r2
   2244e:	801c      	strh	r4, [r3, #0]
        pHE = (OA_HASH_ENTRY*)((uint8_t*)pHE + pOH->hEntrySize);
   22450:	6881      	ldr	r1, [r0, #8]
   22452:	440b      	add	r3, r1
    for(ix = 0; ix < pOH->hEntries; ix++)
   22454:	3201      	adds	r2, #1
   22456:	68c1      	ldr	r1, [r0, #12]
   22458:	4291      	cmp	r1, r2
   2245a:	d8f8      	bhi.n	2244e <TCPIP_OAHASH_Initialize+0x10>
}
   2245c:	f85d 4b04 	ldr.w	r4, [sp], #4
   22460:	4770      	bx	lr
   22462:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_DNSServiceSelect%880:

00022464 <TCPIP_STACK_DNSServiceSelect>:
    pNetIf->Flags.v &= ~TCPIP_STACK_DNS_SERVICE_MASK;
   22464:	f8b0 3042 	ldrh.w	r3, [r0, #66]	; 0x42
   22468:	f023 0318 	bic.w	r3, r3, #24
   2246c:	f8a0 3042 	strh.w	r3, [r0, #66]	; 0x42
        if((configFlags & TCPIP_NETWORK_CONFIG_DNS_CLIENT_ON) != 0 )
   22470:	f011 0f08 	tst.w	r1, #8
   22474:	d101      	bne.n	2247a <TCPIP_STACK_DNSServiceSelect+0x16>
    return TCPIP_STACK_DNS_SERVICE_NONE;
   22476:	2000      	movs	r0, #0
}
   22478:	4770      	bx	lr
            pNetIf->Flags.bIsDnsClientEnabled = 1;
   2247a:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   2247e:	f043 0308 	orr.w	r3, r3, #8
   22482:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
            return TCPIP_STACK_DNS_SERVICE_CLIENT;
   22486:	2001      	movs	r0, #1
   22488:	4770      	bx	lr

Disassembly of section .text.SYS_RANDOM_CryptoBlockGet%881:

0002248a <SYS_RANDOM_CryptoBlockGet>:
}



size_t SYS_RANDOM_CryptoBlockGet( void *buffer, size_t size )
{
   2248a:	b538      	push	{r3, r4, r5, lr}
    if(buffer != 0 && size != 0)
   2248c:	b170      	cbz	r0, 224ac <SYS_RANDOM_CryptoBlockGet+0x22>
   2248e:	460c      	mov	r4, r1
   22490:	4605      	mov	r5, r0
   22492:	b909      	cbnz	r1, 22498 <SYS_RANDOM_CryptoBlockGet+0xe>
            return size;
        }
    }

    return 0;
}
   22494:	4620      	mov	r0, r4
   22496:	bd38      	pop	{r3, r4, r5, pc}
        CRYPT_RNG_CTX* pCtx = _SYS_RANDOM_CryptoContext();
   22498:	f001 f9e4 	bl	23864 <_SYS_RANDOM_CryptoContext>
        if(pCtx)
   2249c:	b908      	cbnz	r0, 224a2 <SYS_RANDOM_CryptoBlockGet+0x18>
    return 0;
   2249e:	2400      	movs	r4, #0
   224a0:	e7f8      	b.n	22494 <SYS_RANDOM_CryptoBlockGet+0xa>
            CRYPT_RNG_BlockGenerate(pCtx, (uint8_t*)buffer, size);
   224a2:	4622      	mov	r2, r4
   224a4:	4629      	mov	r1, r5
   224a6:	f001 f868 	bl	2357a <CRYPT_RNG_BlockGenerate>
            return size;
   224aa:	e7f3      	b.n	22494 <SYS_RANDOM_CryptoBlockGet+0xa>
    return 0;
   224ac:	2400      	movs	r4, #0
   224ae:	e7f1      	b.n	22494 <SYS_RANDOM_CryptoBlockGet+0xa>

Disassembly of section .text.strncpy%882:

000224b0 <strncpy>:
   224b0:	b510      	push	{r4, lr}
   224b2:	3901      	subs	r1, #1
   224b4:	4603      	mov	r3, r0
   224b6:	b132      	cbz	r2, 224c6 <strncpy+0x16>
   224b8:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   224bc:	f803 4b01 	strb.w	r4, [r3], #1
   224c0:	3a01      	subs	r2, #1
   224c2:	2c00      	cmp	r4, #0
   224c4:	d1f7      	bne.n	224b6 <strncpy+0x6>
   224c6:	441a      	add	r2, r3
   224c8:	2100      	movs	r1, #0
   224ca:	4293      	cmp	r3, r2
   224cc:	d100      	bne.n	224d0 <strncpy+0x20>
   224ce:	bd10      	pop	{r4, pc}
   224d0:	f803 1b01 	strb.w	r1, [r3], #1
   224d4:	e7f9      	b.n	224ca <strncpy+0x1a>

Disassembly of section .text.DRV_ETHPHY_VendorDataSet%883:

000224d8 <DRV_ETHPHY_VendorDataSet>:
    if(hClientObj != 0)
   224d8:	4603      	mov	r3, r0
   224da:	b130      	cbz	r0, 224ea <DRV_ETHPHY_VendorDataSet+0x12>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   224dc:	68c0      	ldr	r0, [r0, #12]
   224de:	4a06      	ldr	r2, [pc, #24]	; (224f8 <DRV_ETHPHY_VendorDataSet+0x20>)
   224e0:	4290      	cmp	r0, r2
   224e2:	d105      	bne.n	224f0 <DRV_ETHPHY_VendorDataSet+0x18>
            hClientObj->vendorData = vendorData;
   224e4:	6419      	str	r1, [r3, #64]	; 0x40
            return DRV_ETHPHY_RES_OK;
   224e6:	2000      	movs	r0, #0
   224e8:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   224ea:	f06f 000a 	mvn.w	r0, #10
   224ee:	4770      	bx	lr
   224f0:	f06f 000a 	mvn.w	r0, #10
}
   224f4:	4770      	bx	lr
   224f6:	bf00      	nop
   224f8:	2000e7e8 	.word	0x2000e7e8

Disassembly of section .rodata%884:

000224fc <.rodata%884>:
   224fc:	20565244 	.word	0x20565244
   22500:	20594850 	.word	0x20594850
   22504:	74696e69 	.word	0x74696e69
   22508:	69616620 	.word	0x69616620
   2250c:	3a64656c 	.word	0x3a64656c
   22510:	0d642520 	.word	0x0d642520
   22514:	0000000a 	.word	0x0000000a
   22518:	43414d47 	.word	0x43414d47
   2251c:	00          	.byte	0x00
   2251d:	00          	.byte	0x00
   2251e:	bf00      	nop

Disassembly of section .text.DRV_PIC32CGMAC_LibSysInt_Disable%885:

00022520 <DRV_PIC32CGMAC_LibSysInt_Disable>:
    if(queMask & GMAC_QUE0_MASK)
   22520:	f011 0f01 	tst.w	r1, #1
   22524:	d00d      	beq.n	22542 <DRV_PIC32CGMAC_LibSysInt_Disable+0x22>
{
   22526:	b510      	push	{r4, lr}
   22528:	4614      	mov	r4, r2
        if(queStat)
   2252a:	b12a      	cbz	r2, 22538 <DRV_PIC32CGMAC_LibSysInt_Disable+0x18>
            queStat[GMAC_QUE_0] = SYS_INT_SourceDisable(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc);
   2252c:	f9b0 00b6 	ldrsh.w	r0, [r0, #182]	; 0xb6
   22530:	f7fc ffe8 	bl	1f504 <SYS_INT_SourceDisable>
   22534:	7020      	strb	r0, [r4, #0]
}
   22536:	bd10      	pop	{r4, pc}
            SYS_INT_SourceDisable(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc);
   22538:	f9b0 00b6 	ldrsh.w	r0, [r0, #182]	; 0xb6
   2253c:	f7fc ffe2 	bl	1f504 <SYS_INT_SourceDisable>
}
   22540:	e7f9      	b.n	22536 <DRV_PIC32CGMAC_LibSysInt_Disable+0x16>
   22542:	4770      	bx	lr

Disassembly of section .text._ICMPAllocateTxPacketStruct%886:

00022544 <_ICMPAllocateTxPacketStruct>:
{
   22544:	b508      	push	{r3, lr}
    ptrPacket = (IPV4_PACKET*)TCPIP_PKT_SocketAlloc(sizeof(IPV4_PACKET), totICMPLen, 0, TCPIP_MAC_PKT_FLAG_ICMPV4 | TCPIP_MAC_PKT_FLAG_IPV4 | TCPIP_MAC_PKT_FLAG_TX);
   22546:	2302      	movs	r3, #2
   22548:	2200      	movs	r2, #0
   2254a:	4601      	mov	r1, r0
   2254c:	2044      	movs	r0, #68	; 0x44
   2254e:	f7ff fa7d 	bl	21a4c <_TCPIP_PKT_SocketAlloc>
    if (ptrPacket != 0)
   22552:	4603      	mov	r3, r0
   22554:	b118      	cbz	r0, 2255e <_ICMPAllocateTxPacketStruct+0x1a>
    pPkt->ackFunc = ackFunc;
   22556:	4a03      	ldr	r2, [pc, #12]	; (22564 <_ICMPAllocateTxPacketStruct+0x20>)
   22558:	6082      	str	r2, [r0, #8]
    pPkt->ackParam = ackParam;
   2255a:	2200      	movs	r2, #0
   2255c:	60c2      	str	r2, [r0, #12]
}
   2255e:	4618      	mov	r0, r3
   22560:	bd08      	pop	{r3, pc}
   22562:	bf00      	nop
   22564:	0002430f 	.word	0x0002430f

Disassembly of section .text.TCPIP_ICMP_EchoRequestCancel%887:

00022568 <TCPIP_ICMP_EchoRequestCancel>:
    if(icmpHandle == pIcmpEchoRequest && pIcmpEchoRequest != 0)
   22568:	4b07      	ldr	r3, [pc, #28]	; (22588 <TCPIP_ICMP_EchoRequestCancel+0x20>)
   2256a:	681b      	ldr	r3, [r3, #0]
   2256c:	4283      	cmp	r3, r0
   2256e:	d104      	bne.n	2257a <TCPIP_ICMP_EchoRequestCancel+0x12>
   22570:	b133      	cbz	r3, 22580 <TCPIP_ICMP_EchoRequestCancel+0x18>
        pIcmpEchoRequest = 0;    // free
   22572:	2000      	movs	r0, #0
   22574:	4b04      	ldr	r3, [pc, #16]	; (22588 <TCPIP_ICMP_EchoRequestCancel+0x20>)
   22576:	6018      	str	r0, [r3, #0]
        return ICMP_ECHO_OK;
   22578:	4770      	bx	lr
    return ICMP_ECHO_BAD_HANDLE;
   2257a:	f06f 0005 	mvn.w	r0, #5
   2257e:	4770      	bx	lr
   22580:	f06f 0005 	mvn.w	r0, #5
}
   22584:	4770      	bx	lr
   22586:	bf00      	nop
   22588:	2000edb8 	.word	0x2000edb8

Disassembly of section .text._ARPAllocateTxPacket%888:

0002258c <_ARPAllocateTxPacket>:
{
   2258c:	b508      	push	{r3, lr}
    pPkt = TCPIP_PKT_PacketAlloc(sizeof(TCPIP_MAC_PACKET), sizeof(ARP_PACKET), TCPIP_MAC_PKT_FLAG_ARP | TCPIP_MAC_PKT_FLAG_TX);
   2258e:	f44f 7281 	mov.w	r2, #258	; 0x102
   22592:	211c      	movs	r1, #28
   22594:	2034      	movs	r0, #52	; 0x34
   22596:	f7f8 fab5 	bl	1ab04 <_TCPIP_PKT_PacketAlloc>
    if(pPkt)
   2259a:	4603      	mov	r3, r0
   2259c:	b118      	cbz	r0, 225a6 <_ARPAllocateTxPacket+0x1a>
    pPkt->ackFunc = ackFunc;
   2259e:	4a03      	ldr	r2, [pc, #12]	; (225ac <_ARPAllocateTxPacket+0x20>)
   225a0:	6082      	str	r2, [r0, #8]
    pPkt->ackParam = ackParam;
   225a2:	2200      	movs	r2, #0
   225a4:	60c2      	str	r2, [r0, #12]
}
   225a6:	4618      	mov	r0, r3
   225a8:	bd08      	pop	{r3, pc}
   225aa:	bf00      	nop
   225ac:	00022ff9 	.word	0x00022ff9

Disassembly of section .text.TCPIP_ARP_HandlerDeRegister%889:

000225b0 <TCPIP_ARP_HandlerDeRegister>:
{
   225b0:	b508      	push	{r3, lr}
    if(hArp && arpMod.memH)
   225b2:	b130      	cbz	r0, 225c2 <TCPIP_ARP_HandlerDeRegister+0x12>
   225b4:	4a05      	ldr	r2, [pc, #20]	; (225cc <TCPIP_ARP_HandlerDeRegister+0x1c>)
   225b6:	6892      	ldr	r2, [r2, #8]
   225b8:	b12a      	cbz	r2, 225c6 <TCPIP_ARP_HandlerDeRegister+0x16>
        if(TCPIP_Notification_Remove((SGL_LIST_NODE*)hArp, &arpMod.registeredUsers, arpMod.memH))
   225ba:	4905      	ldr	r1, [pc, #20]	; (225d0 <TCPIP_ARP_HandlerDeRegister+0x20>)
   225bc:	f000 fb50 	bl	22c60 <TCPIP_Notification_Remove>
}
   225c0:	bd08      	pop	{r3, pc}
    return false;
   225c2:	2000      	movs	r0, #0
   225c4:	e7fc      	b.n	225c0 <TCPIP_ARP_HandlerDeRegister+0x10>
   225c6:	2000      	movs	r0, #0
   225c8:	e7fa      	b.n	225c0 <TCPIP_ARP_HandlerDeRegister+0x10>
   225ca:	bf00      	nop
   225cc:	2000e974 	.word	0x2000e974
   225d0:	2000e994 	.word	0x2000e994

Disassembly of section .rodata._tcpip_heap_object%890:

000225d4 <_tcpip_heap_object>:
   225d4:	0001f189 00018adb 00023031 00015541     ........10..AU..
   225e4:	000241fd 000204ed 00023c49 00024209     .A......I<...B..
   225f4:	00023965                                e9..

Disassembly of section .text._DHCPOptionProcessSrvIdent%891:

000225f8 <_DHCPOptionProcessSrvIdent>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_SERVER_ID))
   225f8:	684b      	ldr	r3, [r1, #4]
   225fa:	2b05      	cmp	r3, #5
   225fc:	d908      	bls.n	22610 <_DHCPOptionProcessSrvIdent+0x18>
        TCPIP_DHCP_OPTION_DATA_SERVER_ID* pServId = (TCPIP_DHCP_OPTION_DATA_SERVER_ID*)pOptData->pOpt;
   225fe:	680b      	ldr	r3, [r1, #0]
        if(pServId->len == sizeof(pServId->serverId))
   22600:	785a      	ldrb	r2, [r3, #1]
   22602:	2a04      	cmp	r2, #4
   22604:	d107      	bne.n	22616 <_DHCPOptionProcessSrvIdent+0x1e>
            memcpy( pOptData->serverID.v, pServId->serverId, sizeof(pServId->serverId));
   22606:	f8d3 3002 	ldr.w	r3, [r3, #2]
   2260a:	60cb      	str	r3, [r1, #12]
            return sizeof(TCPIP_DHCP_OPTION_DATA_SERVER_ID);
   2260c:	2006      	movs	r0, #6
   2260e:	4770      	bx	lr
    return -1;
   22610:	f04f 30ff 	mov.w	r0, #4294967295
   22614:	4770      	bx	lr
   22616:	f04f 30ff 	mov.w	r0, #4294967295
}
   2261a:	4770      	bx	lr

Disassembly of section .text._DHCPOptionWriteMsgType%892:

0002261c <_DHCPOptionWriteMsgType>:
    if(pSendData->writeSpace >= sizeof(*pDhcpOptType))
   2261c:	684b      	ldr	r3, [r1, #4]
   2261e:	2b02      	cmp	r3, #2
   22620:	d90b      	bls.n	2263a <_DHCPOptionWriteMsgType+0x1e>
        pDhcpOptType = (TCPIP_DHCP_OPTION_DATA_MSG_TYPE*)pSendData->pOpt;
   22622:	680a      	ldr	r2, [r1, #0]
        pDhcpOptType->opt = TCPIP_DHCP_MESSAGE_TYPE;
   22624:	2335      	movs	r3, #53	; 0x35
   22626:	7013      	strb	r3, [r2, #0]
        pDhcpOptType->len = sizeof(pDhcpOptType->type);
   22628:	2301      	movs	r3, #1
   2262a:	7053      	strb	r3, [r2, #1]
        pDhcpOptType->type = (pSendData->msgType == TCPIP_DHCP_REQUEST_RENEW_MESSAGE) ? TCPIP_DHCP_REQUEST_MESSAGE : (uint8_t)pSendData->msgType;
   2262c:	68cb      	ldr	r3, [r1, #12]
   2262e:	2b09      	cmp	r3, #9
   22630:	bf08      	it	eq
   22632:	2303      	moveq	r3, #3
   22634:	7093      	strb	r3, [r2, #2]
        return sizeof(*pDhcpOptType);
   22636:	2003      	movs	r0, #3
   22638:	4770      	bx	lr
    return -1;
   2263a:	f04f 30ff 	mov.w	r0, #4294967295
}
   2263e:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_IPAddToNet%893:

00022640 <TCPIP_STACK_IPAddToNet>:
{
   22640:	b510      	push	{r4, lr}
   22642:	460c      	mov	r4, r1
    if(pIpAddress && pIpAddress->Val != 0)
   22644:	b128      	cbz	r0, 22652 <TCPIP_STACK_IPAddToNet+0x12>
   22646:	6802      	ldr	r2, [r0, #0]
   22648:	b11a      	cbz	r2, 22652 <TCPIP_STACK_IPAddToNet+0x12>
        pNetIf = TCPIP_STACK_NetByAddress(pIpAddress);
   2264a:	f7fc fed3 	bl	1f3f4 <TCPIP_STACK_NetByAddress>
    if(pNetIf == 0 && useDefault)
   2264e:	4603      	mov	r3, r0
   22650:	b910      	cbnz	r0, 22658 <TCPIP_STACK_IPAddToNet+0x18>
   22652:	b11c      	cbz	r4, 2265c <TCPIP_STACK_IPAddToNet+0x1c>
        pNetIf = tcpipDefIf.defaultNet;
   22654:	4b02      	ldr	r3, [pc, #8]	; (22660 <TCPIP_STACK_IPAddToNet+0x20>)
   22656:	681b      	ldr	r3, [r3, #0]
}
   22658:	4618      	mov	r0, r3
   2265a:	bd10      	pop	{r4, pc}
   2265c:	2300      	movs	r3, #0
    return pNetIf;
   2265e:	e7fb      	b.n	22658 <TCPIP_STACK_IPAddToNet+0x18>
   22660:	2000ee70 	.word	0x2000ee70

Disassembly of section .text._UDPFreeRxQueue%894:

00022664 <_UDPFreeRxQueue>:
{
   22664:	b570      	push	{r4, r5, r6, lr}
    while((pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(&pSkt->rxQueue)) != 0)
   22666:	f100 0444 	add.w	r4, r0, #68	; 0x44
    TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
   2266a:	2609      	movs	r6, #9
   2266c:	f06f 0510 	mvn.w	r5, #16
    while((pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(&pSkt->rxQueue)) != 0)
   22670:	4620      	mov	r0, r4
   22672:	f000 fcf9 	bl	23068 <TCPIP_Helper_SingleListHeadRemove>
   22676:	4603      	mov	r3, r0
   22678:	b128      	cbz	r0, 22686 <_UDPFreeRxQueue+0x22>
    TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
   2267a:	4632      	mov	r2, r6
   2267c:	4629      	mov	r1, r5
   2267e:	4618      	mov	r0, r3
   22680:	f7fd fa10 	bl	1faa4 <_TCPIP_PKT_PacketAcknowledge>
   22684:	e7f4      	b.n	22670 <_UDPFreeRxQueue+0xc>
}
   22686:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .rodata._builtinCmdTbl%895:

00022688 <_builtinCmdTbl>:
   22688:	eb98 0000 384d 0002 eba0 0000 ebb0 0000     ....M8..........
   22698:	0bfd 0002 ebb4 0000 ebd0 0000 2ad5 0001     .............*..
   226a8:	ebd8 0000                                   ....

Disassembly of section .text.SYS_RESET_SoftwareReset%896:

000226ac <SYS_RESET_SoftwareReset>:
  __ASM volatile ("dsb 0xF":::"memory");
   226ac:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   226b0:	4905      	ldr	r1, [pc, #20]	; (226c8 <SYS_RESET_SoftwareReset+0x1c>)
   226b2:	68ca      	ldr	r2, [r1, #12]
   226b4:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   226b8:	4b04      	ldr	r3, [pc, #16]	; (226cc <SYS_RESET_SoftwareReset+0x20>)
   226ba:	4313      	orrs	r3, r2
   226bc:	60cb      	str	r3, [r1, #12]
   226be:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
   226c2:	bf00      	nop
   226c4:	e7fd      	b.n	226c2 <SYS_RESET_SoftwareReset+0x16>
   226c6:	bf00      	nop
   226c8:	e000ed00 	.word	0xe000ed00
   226cc:	05fa0004 	.word	0x05fa0004

Disassembly of section .text.SYS_RANDOM_CryptoGet%897:

000226d0 <SYS_RANDOM_CryptoGet>:
{
   226d0:	b500      	push	{lr}
   226d2:	b083      	sub	sp, #12
    }sUint = {0};
   226d4:	2300      	movs	r3, #0
   226d6:	9301      	str	r3, [sp, #4]
    CRYPT_RNG_CTX* pCtx = _SYS_RANDOM_CryptoContext();
   226d8:	f001 f8c4 	bl	23864 <_SYS_RANDOM_CryptoContext>
    if(pCtx)
   226dc:	b918      	cbnz	r0, 226e6 <SYS_RANDOM_CryptoGet+0x16>
    return 0;
   226de:	2000      	movs	r0, #0
}
   226e0:	b003      	add	sp, #12
   226e2:	f85d fb04 	ldr.w	pc, [sp], #4
        CRYPT_RNG_BlockGenerate(pCtx, (unsigned char*)sUint.u8, sizeof(sUint.u8));
   226e6:	2204      	movs	r2, #4
   226e8:	eb0d 0102 	add.w	r1, sp, r2
   226ec:	f000 ff45 	bl	2357a <CRYPT_RNG_BlockGenerate>
        return sUint.u32;
   226f0:	9801      	ldr	r0, [sp, #4]
   226f2:	e7f5      	b.n	226e0 <SYS_RANDOM_CryptoGet+0x10>

Disassembly of section .text.vPortSVCHandler%898:

00022700 <vPortSVCHandler>:
	__asm volatile (
   22700:	4b07      	ldr	r3, [pc, #28]	; (22720 <pxCurrentTCBConst2>)
   22702:	6819      	ldr	r1, [r3, #0]
   22704:	6808      	ldr	r0, [r1, #0]
   22706:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2270a:	f380 8809 	msr	PSP, r0
   2270e:	f3bf 8f6f 	isb	sy
   22712:	f04f 0000 	mov.w	r0, #0
   22716:	f380 8811 	msr	BASEPRI, r0
   2271a:	4770      	bx	lr
   2271c:	f3af 8000 	nop.w

00022720 <pxCurrentTCBConst2>:
   22720:	2000ef00 	.word	0x2000ef00

Disassembly of section .text.uxListRemove%899:

00022724 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
   22724:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   22726:	6841      	ldr	r1, [r0, #4]
   22728:	6882      	ldr	r2, [r0, #8]
   2272a:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   2272c:	6841      	ldr	r1, [r0, #4]
   2272e:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
   22730:	685a      	ldr	r2, [r3, #4]
   22732:	4282      	cmp	r2, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
   22734:	bf04      	itt	eq
   22736:	6882      	ldreq	r2, [r0, #8]
   22738:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
   2273a:	2200      	movs	r2, #0
   2273c:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
   2273e:	681a      	ldr	r2, [r3, #0]
   22740:	3a01      	subs	r2, #1
   22742:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
   22744:	6818      	ldr	r0, [r3, #0]
}
   22746:	4770      	bx	lr

Disassembly of section .text.xQueueCreateMutex%900:

00022748 <xQueueCreateMutex>:
	{
   22748:	b510      	push	{r4, lr}
		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
   2274a:	4602      	mov	r2, r0
   2274c:	2100      	movs	r1, #0
   2274e:	2001      	movs	r0, #1
   22750:	f7fe fecc 	bl	214ec <xQueueGenericCreate>
		if( pxNewQueue != NULL )
   22754:	4604      	mov	r4, r0
   22756:	b138      	cbz	r0, 22768 <xQueueCreateMutex+0x20>
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
   22758:	2100      	movs	r1, #0
   2275a:	6081      	str	r1, [r0, #8]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
   2275c:	6001      	str	r1, [r0, #0]
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
   2275e:	60c1      	str	r1, [r0, #12]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
   22760:	460b      	mov	r3, r1
   22762:	460a      	mov	r2, r1
   22764:	f7f1 feb2 	bl	144cc <xQueueGenericSend>
	}
   22768:	4620      	mov	r0, r4
   2276a:	bd10      	pop	{r4, pc}

Disassembly of section .text.gfx_mono_framebuffer_put_byte%901:

0002276c <gfx_mono_framebuffer_put_byte>:
    gfx_mono_framebuffer_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
        uint8_t data) {
    uint8_t *fBufferBegin = fbpointer;
   2276c:	4b07      	ldr	r3, [pc, #28]	; (2278c <gfx_mono_framebuffer_put_byte+0x20>)
   2276e:	681b      	ldr	r3, [r3, #0]
    uint8_t *fBufferEnd = fbpointer + GFX_MONO_LCD_FRAMEBUFFER_SIZE;
    uint8_t *fbpointerTemp = (fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
   22770:	eb01 11c0 	add.w	r1, r1, r0, lsl #7
    if ((fbpointerTemp >= fBufferBegin) && (fbpointerTemp <= fBufferEnd)) {
   22774:	1858      	adds	r0, r3, r1
   22776:	d208      	bcs.n	2278a <gfx_mono_framebuffer_put_byte+0x1e>
        uint8_t data) {
   22778:	b410      	push	{r4}
    uint8_t *fBufferEnd = fbpointer + GFX_MONO_LCD_FRAMEBUFFER_SIZE;
   2277a:	f503 7400 	add.w	r4, r3, #512	; 0x200
    if ((fbpointerTemp >= fBufferBegin) && (fbpointerTemp <= fBufferEnd)) {
   2277e:	42a0      	cmp	r0, r4
        *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
   22780:	bf98      	it	ls
   22782:	545a      	strbls	r2, [r3, r1]
    }
}
   22784:	f85d 4b04 	ldr.w	r4, [sp], #4
   22788:	4770      	bx	lr
   2278a:	4770      	bx	lr
   2278c:	2000ef3c 	.word	0x2000ef3c

Disassembly of section .text.fprintf%902:

00022790 <fiprintf>:
   22790:	b40e      	push	{r1, r2, r3}
   22792:	b503      	push	{r0, r1, lr}
   22794:	4601      	mov	r1, r0
   22796:	ab03      	add	r3, sp, #12
   22798:	4805      	ldr	r0, [pc, #20]	; (227b0 <fiprintf+0x20>)
   2279a:	f853 2b04 	ldr.w	r2, [r3], #4
   2279e:	6800      	ldr	r0, [r0, #0]
   227a0:	9301      	str	r3, [sp, #4]
   227a2:	f7ed fcf7 	bl	10194 <_vfiprintf_r>
   227a6:	b002      	add	sp, #8
   227a8:	f85d eb04 	ldr.w	lr, [sp], #4
   227ac:	b003      	add	sp, #12
   227ae:	4770      	bx	lr
   227b0:	2000ef60 	.word	0x2000ef60

Disassembly of section .text.strncmp%903:

000227b4 <strncmp>:
   227b4:	b510      	push	{r4, lr}
   227b6:	b16a      	cbz	r2, 227d4 <strncmp+0x20>
   227b8:	3901      	subs	r1, #1
   227ba:	1884      	adds	r4, r0, r2
   227bc:	f810 3b01 	ldrb.w	r3, [r0], #1
   227c0:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   227c4:	4293      	cmp	r3, r2
   227c6:	d103      	bne.n	227d0 <strncmp+0x1c>
   227c8:	42a0      	cmp	r0, r4
   227ca:	d001      	beq.n	227d0 <strncmp+0x1c>
   227cc:	2b00      	cmp	r3, #0
   227ce:	d1f5      	bne.n	227bc <strncmp+0x8>
   227d0:	1a98      	subs	r0, r3, r2
   227d2:	bd10      	pop	{r4, pc}
   227d4:	4610      	mov	r0, r2
   227d6:	e7fc      	b.n	227d2 <strncmp+0x1e>

Disassembly of section .text.__ascii_mbtowc%904:

000227d8 <__ascii_mbtowc>:
   227d8:	b082      	sub	sp, #8
   227da:	b901      	cbnz	r1, 227de <__ascii_mbtowc+0x6>
   227dc:	a901      	add	r1, sp, #4
   227de:	b142      	cbz	r2, 227f2 <__ascii_mbtowc+0x1a>
   227e0:	b14b      	cbz	r3, 227f6 <__ascii_mbtowc+0x1e>
   227e2:	7813      	ldrb	r3, [r2, #0]
   227e4:	600b      	str	r3, [r1, #0]
   227e6:	7812      	ldrb	r2, [r2, #0]
   227e8:	1c10      	adds	r0, r2, #0
   227ea:	bf18      	it	ne
   227ec:	2001      	movne	r0, #1
   227ee:	b002      	add	sp, #8
   227f0:	4770      	bx	lr
   227f2:	4610      	mov	r0, r2
   227f4:	e7fb      	b.n	227ee <__ascii_mbtowc+0x16>
   227f6:	f06f 0001 	mvn.w	r0, #1
   227fa:	e7f8      	b.n	227ee <__ascii_mbtowc+0x16>

Disassembly of section .text._kill_r%905:

000227fc <_kill_r>:
   227fc:	b538      	push	{r3, r4, r5, lr}
   227fe:	4c07      	ldr	r4, [pc, #28]	; (2281c <_kill_r+0x20>)
   22800:	2300      	movs	r3, #0
   22802:	4605      	mov	r5, r0
   22804:	4608      	mov	r0, r1
   22806:	4611      	mov	r1, r2
   22808:	6023      	str	r3, [r4, #0]
   2280a:	f001 fe5d 	bl	244c8 <_kill>
   2280e:	1c43      	adds	r3, r0, #1
   22810:	d102      	bne.n	22818 <_kill_r+0x1c>
   22812:	6823      	ldr	r3, [r4, #0]
   22814:	b103      	cbz	r3, 22818 <_kill_r+0x1c>
   22816:	602b      	str	r3, [r5, #0]
   22818:	bd38      	pop	{r3, r4, r5, pc}
   2281a:	bf00      	nop
   2281c:	20000000 	.word	0x20000000

Disassembly of section .text.__sseek%906:

00022820 <__sseek>:
   22820:	b510      	push	{r4, lr}
   22822:	460c      	mov	r4, r1
   22824:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   22828:	f000 f830 	bl	2288c <_lseek_r>
   2282c:	1c43      	adds	r3, r0, #1
   2282e:	89a3      	ldrh	r3, [r4, #12]
   22830:	bf15      	itete	ne
   22832:	6560      	strne	r0, [r4, #84]	; 0x54
   22834:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
   22838:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
   2283c:	81a3      	strheq	r3, [r4, #12]
   2283e:	bf18      	it	ne
   22840:	81a3      	strhne	r3, [r4, #12]
   22842:	bd10      	pop	{r4, pc}

Disassembly of section .text._write_r%907:

00022844 <_write_r>:
   22844:	b538      	push	{r3, r4, r5, lr}
   22846:	4c07      	ldr	r4, [pc, #28]	; (22864 <_write_r+0x20>)
   22848:	4605      	mov	r5, r0
   2284a:	4608      	mov	r0, r1
   2284c:	4611      	mov	r1, r2
   2284e:	2200      	movs	r2, #0
   22850:	6022      	str	r2, [r4, #0]
   22852:	461a      	mov	r2, r3
   22854:	f001 fe3e 	bl	244d4 <_write>
   22858:	1c43      	adds	r3, r0, #1
   2285a:	d102      	bne.n	22862 <_write_r+0x1e>
   2285c:	6823      	ldr	r3, [r4, #0]
   2285e:	b103      	cbz	r3, 22862 <_write_r+0x1e>
   22860:	602b      	str	r3, [r5, #0]
   22862:	bd38      	pop	{r3, r4, r5, pc}
   22864:	20000000 	.word	0x20000000

Disassembly of section .text._fstat_r%908:

00022868 <_fstat_r>:
   22868:	b538      	push	{r3, r4, r5, lr}
   2286a:	4c07      	ldr	r4, [pc, #28]	; (22888 <_fstat_r+0x20>)
   2286c:	2300      	movs	r3, #0
   2286e:	4605      	mov	r5, r0
   22870:	4608      	mov	r0, r1
   22872:	4611      	mov	r1, r2
   22874:	6023      	str	r3, [r4, #0]
   22876:	f001 fe21 	bl	244bc <_fstat>
   2287a:	1c43      	adds	r3, r0, #1
   2287c:	d102      	bne.n	22884 <_fstat_r+0x1c>
   2287e:	6823      	ldr	r3, [r4, #0]
   22880:	b103      	cbz	r3, 22884 <_fstat_r+0x1c>
   22882:	602b      	str	r3, [r5, #0]
   22884:	bd38      	pop	{r3, r4, r5, pc}
   22886:	bf00      	nop
   22888:	20000000 	.word	0x20000000

Disassembly of section .text._lseek_r%909:

0002288c <_lseek_r>:
   2288c:	b538      	push	{r3, r4, r5, lr}
   2288e:	4c07      	ldr	r4, [pc, #28]	; (228ac <_lseek_r+0x20>)
   22890:	4605      	mov	r5, r0
   22892:	4608      	mov	r0, r1
   22894:	4611      	mov	r1, r2
   22896:	2200      	movs	r2, #0
   22898:	6022      	str	r2, [r4, #0]
   2289a:	461a      	mov	r2, r3
   2289c:	f001 fe16 	bl	244cc <_lseek>
   228a0:	1c43      	adds	r3, r0, #1
   228a2:	d102      	bne.n	228aa <_lseek_r+0x1e>
   228a4:	6823      	ldr	r3, [r4, #0]
   228a6:	b103      	cbz	r3, 228aa <_lseek_r+0x1e>
   228a8:	602b      	str	r3, [r5, #0]
   228aa:	bd38      	pop	{r3, r4, r5, pc}
   228ac:	20000000 	.word	0x20000000

Disassembly of section .text._read_r%910:

000228b0 <_read_r>:
   228b0:	b538      	push	{r3, r4, r5, lr}
   228b2:	4c07      	ldr	r4, [pc, #28]	; (228d0 <_read_r+0x20>)
   228b4:	4605      	mov	r5, r0
   228b6:	4608      	mov	r0, r1
   228b8:	4611      	mov	r1, r2
   228ba:	2200      	movs	r2, #0
   228bc:	6022      	str	r2, [r4, #0]
   228be:	461a      	mov	r2, r3
   228c0:	f001 fe06 	bl	244d0 <_read>
   228c4:	1c43      	adds	r3, r0, #1
   228c6:	d102      	bne.n	228ce <_read_r+0x1e>
   228c8:	6823      	ldr	r3, [r4, #0]
   228ca:	b103      	cbz	r3, 228ce <_read_r+0x1e>
   228cc:	602b      	str	r3, [r5, #0]
   228ce:	bd38      	pop	{r3, r4, r5, pc}
   228d0:	20000000 	.word	0x20000000

Disassembly of section .text._DRV_PHY_SMITransfer_Wait%911:

000228d4 <_DRV_PHY_SMITransfer_Wait>:
{
   228d4:	b510      	push	{r4, lr}
   228d6:	4604      	mov	r4, r0
    DRV_ETHPHY_SMI_TXFER_RES opRes = _DRV_PHY_SMITransferWaitComplete(hClientObj);
   228d8:	f7fb f975 	bl	1dbc6 <_DRV_PHY_SMITransferWaitComplete>
    if(opRes < 0)
   228dc:	2800      	cmp	r0, #0
   228de:	db03      	blt.n	228e8 <_DRV_PHY_SMITransfer_Wait+0x14>
    else if(opRes == DRV_ETHPHY_SMI_TXFER_RES_WAIT)
   228e0:	3802      	subs	r0, #2
   228e2:	bf18      	it	ne
   228e4:	2001      	movne	r0, #1
}
   228e6:	bd10      	pop	{r4, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   228e8:	f06f 0108 	mvn.w	r1, #8
   228ec:	4620      	mov	r0, r4
   228ee:	f7ff fa9d 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
        return false;
   228f2:	2000      	movs	r0, #0
   228f4:	e7f7      	b.n	228e6 <_DRV_PHY_SMITransfer_Wait+0x12>

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListInitialize%912:

000228f6 <TCPIP_Helper_ProtectedSingleListInitialize>:
{
   228f6:	b510      	push	{r4, lr}
   228f8:	4604      	mov	r4, r0
    pL->head = pL->tail = 0;
   228fa:	2100      	movs	r1, #0
   228fc:	6041      	str	r1, [r0, #4]
   228fe:	6001      	str	r1, [r0, #0]
    pL->nNodes = 0;
   22900:	6081      	str	r1, [r0, #8]
    pL->semValid = (OSAL_SEM_Create(&pL->semaphore, OSAL_SEM_TYPE_BINARY, 1, 1) == OSAL_RESULT_TRUE);
   22902:	2301      	movs	r3, #1
   22904:	461a      	mov	r2, r3
   22906:	300c      	adds	r0, #12
   22908:	f7fb f8da 	bl	1dac0 <OSAL_SEM_Create>
   2290c:	2801      	cmp	r0, #1
   2290e:	bf14      	ite	ne
   22910:	2000      	movne	r0, #0
   22912:	2001      	moveq	r0, #1
   22914:	7420      	strb	r0, [r4, #16]
}
   22916:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_STACK_NetAddressMacSet%913:

00022918 <TCPIP_STACK_NetAddressMacSet>:
   22918:	b168      	cbz	r0, 22936 <TCPIP_STACK_NetAddressMacSet+0x1e>
   2291a:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   2291e:	f012 0f40 	tst.w	r2, #64	; 0x40
   22922:	d101      	bne.n	22928 <TCPIP_STACK_NetAddressMacSet+0x10>
    return false;
   22924:	2000      	movs	r0, #0
}
   22926:	4770      	bx	lr
        memcpy(pNetIf->netMACAddr.v, pAddr->v, sizeof(pNetIf->netMACAddr));
   22928:	680a      	ldr	r2, [r1, #0]
   2292a:	63c2      	str	r2, [r0, #60]	; 0x3c
   2292c:	888a      	ldrh	r2, [r1, #4]
   2292e:	f8a0 2040 	strh.w	r2, [r0, #64]	; 0x40
        return true;
   22932:	2001      	movs	r0, #1
   22934:	4770      	bx	lr
    return false;
   22936:	2000      	movs	r0, #0
   22938:	4770      	bx	lr

Disassembly of section .text.TCPIP_UDP_Discard%914:

0002293a <TCPIP_UDP_Discard>:
{
   2293a:	b510      	push	{r4, lr}
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   2293c:	f7ff fc06 	bl	2214c <_UDPSocketDcpt>
    if(pSkt)
   22940:	b150      	cbz	r0, 22958 <TCPIP_UDP_Discard+0x1e>
   22942:	4603      	mov	r3, r0
        if(pSkt->pCurrRxSeg)
   22944:	6b02      	ldr	r2, [r0, #48]	; 0x30
   22946:	b12a      	cbz	r2, 22954 <TCPIP_UDP_Discard+0x1a>
            nBytes = pSkt->rxTotLen;
   22948:	8ec4      	ldrh	r4, [r0, #54]	; 0x36
        _UDPUpdatePacketLock(pSkt);
   2294a:	4618      	mov	r0, r3
   2294c:	f7ff fc12 	bl	22174 <_UDPUpdatePacketLock>
}
   22950:	4620      	mov	r0, r4
   22952:	bd10      	pop	{r4, pc}
    uint16_t nBytes = 0;
   22954:	2400      	movs	r4, #0
   22956:	e7f8      	b.n	2294a <TCPIP_UDP_Discard+0x10>
   22958:	2400      	movs	r4, #0
   2295a:	e7f9      	b.n	22950 <TCPIP_UDP_Discard+0x16>

Disassembly of section .rodata%915:

0002295c <.rodata%915>:
   2295c:	33323130 	.word	0x33323130
   22960:	37363534 	.word	0x37363534
   22964:	42413938 	.word	0x42413938
   22968:	46454443 	.word	0x46454443
   2296c:	32313000 	.word	0x32313000
   22970:	36353433 	.word	0x36353433
   22974:	61393837 	.word	0x61393837
   22978:	65646362 	.word	0x65646362
   2297c:	Address 0x0002297c is out of bounds.


Disassembly of section .text.__sread%916:

0002297e <__sread>:
   2297e:	b510      	push	{r4, lr}
   22980:	460c      	mov	r4, r1
   22982:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   22986:	f7ff ff93 	bl	228b0 <_read_r>
   2298a:	2800      	cmp	r0, #0
   2298c:	bfab      	itete	ge
   2298e:	6d63      	ldrge	r3, [r4, #84]	; 0x54
   22990:	89a3      	ldrhlt	r3, [r4, #12]
   22992:	181b      	addge	r3, r3, r0
   22994:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
   22998:	bfac      	ite	ge
   2299a:	6563      	strge	r3, [r4, #84]	; 0x54
   2299c:	81a3      	strhlt	r3, [r4, #12]
   2299e:	bd10      	pop	{r4, pc}

Disassembly of section .text.DRV_ETHPHY_Status%917:

000229a0 <DRV_ETHPHY_Status>:
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   229a0:	4b06      	ldr	r3, [pc, #24]	; (229bc <DRV_ETHPHY_Status+0x1c>)
   229a2:	4283      	cmp	r3, r0
   229a4:	d103      	bne.n	229ae <DRV_ETHPHY_Status+0xe>
    if(phyInst != 0)
   229a6:	b128      	cbz	r0, 229b4 <DRV_ETHPHY_Status+0x14>
        return( phyInst->status ) ;
   229a8:	f993 0004 	ldrsb.w	r0, [r3, #4]
   229ac:	4770      	bx	lr
    return SYS_STATUS_ERROR;
   229ae:	f04f 30ff 	mov.w	r0, #4294967295
   229b2:	4770      	bx	lr
   229b4:	f04f 30ff 	mov.w	r0, #4294967295
} 
   229b8:	4770      	bx	lr
   229ba:	bf00      	nop
   229bc:	2000e7e8 	.word	0x2000e7e8

Disassembly of section .text.DRV_ETHPHY_ClientStatus%918:

000229c0 <DRV_ETHPHY_ClientStatus>:
    if( hClientObj != 0)
   229c0:	b130      	cbz	r0, 229d0 <DRV_ETHPHY_ClientStatus+0x10>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   229c2:	68c1      	ldr	r1, [r0, #12]
   229c4:	4a05      	ldr	r2, [pc, #20]	; (229dc <DRV_ETHPHY_ClientStatus+0x1c>)
   229c6:	4291      	cmp	r1, r2
   229c8:	d105      	bne.n	229d6 <DRV_ETHPHY_ClientStatus+0x16>
            return( hClientObj->status );
   229ca:	f990 0008 	ldrsb.w	r0, [r0, #8]
   229ce:	4770      	bx	lr
    return DRV_ETHPHY_CLIENT_STATUS_ERROR;
   229d0:	f04f 30ff 	mov.w	r0, #4294967295
   229d4:	4770      	bx	lr
   229d6:	f04f 30ff 	mov.w	r0, #4294967295
}
   229da:	4770      	bx	lr
   229dc:	2000e7e8 	.word	0x2000e7e8

Disassembly of section .text.DRV_ETHPHY_ClientOperationResult%919:

000229e0 <DRV_ETHPHY_ClientOperationResult>:
    if( hClientObj != 0)
   229e0:	b130      	cbz	r0, 229f0 <DRV_ETHPHY_ClientOperationResult+0x10>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   229e2:	68c1      	ldr	r1, [r0, #12]
   229e4:	4a05      	ldr	r2, [pc, #20]	; (229fc <DRV_ETHPHY_ClientOperationResult+0x1c>)
   229e6:	4291      	cmp	r1, r2
   229e8:	d105      	bne.n	229f6 <DRV_ETHPHY_ClientOperationResult+0x16>
            return( hClientObj->operRes );
   229ea:	f990 002c 	ldrsb.w	r0, [r0, #44]	; 0x2c
   229ee:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   229f0:	f06f 000a 	mvn.w	r0, #10
   229f4:	4770      	bx	lr
   229f6:	f06f 000a 	mvn.w	r0, #10
}
   229fa:	4770      	bx	lr
   229fc:	2000e7e8 	.word	0x2000e7e8

Disassembly of section .text._DRV_ETHPHY_ClientOpReset%920:

00022a00 <_DRV_ETHPHY_ClientOpReset>:
{
   22a00:	b508      	push	{r3, lr}
    if((unsigned int)hClientObj->operPhase < sizeof(_DRV_PHY_ResetPhasesTbl)/sizeof(*_DRV_PHY_ResetPhasesTbl))
   22a02:	8bc3      	ldrh	r3, [r0, #30]
   22a04:	2b02      	cmp	r3, #2
   22a06:	d804      	bhi.n	22a12 <_DRV_ETHPHY_ClientOpReset+0x12>
        (*_DRV_PHY_ResetPhasesTbl[hClientObj->operPhase])(hClientObj);
   22a08:	4a04      	ldr	r2, [pc, #16]	; (22a1c <_DRV_ETHPHY_ClientOpReset+0x1c>)
   22a0a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   22a0e:	4798      	blx	r3
}
   22a10:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   22a12:	f06f 0108 	mvn.w	r1, #8
   22a16:	f7ff fa09 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
}
   22a1a:	e7f9      	b.n	22a10 <_DRV_ETHPHY_ClientOpReset+0x10>
   22a1c:	00023f8c 	.word	0x00023f8c

Disassembly of section .text._DRV_ETHPHY_ClientOpNegRestart%921:

00022a20 <_DRV_ETHPHY_ClientOpNegRestart>:
{
   22a20:	b508      	push	{r3, lr}
    if((unsigned int)hClientObj->operPhase < sizeof(_DRV_PHY_NegRestartPhasesTbl)/sizeof(*_DRV_PHY_NegRestartPhasesTbl))
   22a22:	8bc3      	ldrh	r3, [r0, #30]
   22a24:	2b02      	cmp	r3, #2
   22a26:	d804      	bhi.n	22a32 <_DRV_ETHPHY_ClientOpNegRestart+0x12>
        (*_DRV_PHY_NegRestartPhasesTbl[hClientObj->operPhase])(hClientObj);
   22a28:	4a04      	ldr	r2, [pc, #16]	; (22a3c <_DRV_ETHPHY_ClientOpNegRestart+0x1c>)
   22a2a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   22a2e:	4798      	blx	r3
}
   22a30:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   22a32:	f06f 0108 	mvn.w	r1, #8
   22a36:	f7ff f9f9 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
}
   22a3a:	e7f9      	b.n	22a30 <_DRV_ETHPHY_ClientOpNegRestart+0x10>
   22a3c:	00023f80 	.word	0x00023f80

Disassembly of section .text._DRV_ETHPHY_ClientOpNegResult%922:

00022a40 <_DRV_ETHPHY_ClientOpNegResult>:
{
   22a40:	b508      	push	{r3, lr}
    if((unsigned int)hClientObj->operPhase < sizeof(_DRV_PHY_NegResultPhasesTbl)/sizeof(*_DRV_PHY_NegResultPhasesTbl))
   22a42:	8bc3      	ldrh	r3, [r0, #30]
   22a44:	2b04      	cmp	r3, #4
   22a46:	d804      	bhi.n	22a52 <_DRV_ETHPHY_ClientOpNegResult+0x12>
        (*_DRV_PHY_NegResultPhasesTbl[hClientObj->operPhase])(hClientObj);
   22a48:	4a04      	ldr	r2, [pc, #16]	; (22a5c <_DRV_ETHPHY_ClientOpNegResult+0x1c>)
   22a4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   22a4e:	4798      	blx	r3
}
   22a50:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   22a52:	f06f 0108 	mvn.w	r1, #8
   22a56:	f7ff f9e9 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
}
   22a5a:	e7f9      	b.n	22a50 <_DRV_ETHPHY_ClientOpNegResult+0x10>
   22a5c:	00023a6c 	.word	0x00023a6c

Disassembly of section .text._DRV_ETHPHY_ClientOpNegComplete%923:

00022a60 <_DRV_ETHPHY_ClientOpNegComplete>:
{
   22a60:	b508      	push	{r3, lr}
    if((unsigned int)hClientObj->operPhase < sizeof(_DRV_PHY_NegCompletePhasesTbl)/sizeof(*_DRV_PHY_NegCompletePhasesTbl))
   22a62:	8bc3      	ldrh	r3, [r0, #30]
   22a64:	2b05      	cmp	r3, #5
   22a66:	d804      	bhi.n	22a72 <_DRV_ETHPHY_ClientOpNegComplete+0x12>
        (*_DRV_PHY_NegCompletePhasesTbl[hClientObj->operPhase])(hClientObj);
   22a68:	4a04      	ldr	r2, [pc, #16]	; (22a7c <_DRV_ETHPHY_ClientOpNegComplete+0x1c>)
   22a6a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   22a6e:	4798      	blx	r3
}
   22a70:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   22a72:	f06f 0108 	mvn.w	r1, #8
   22a76:	f7ff f9d9 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
}
   22a7a:	e7f9      	b.n	22a70 <_DRV_ETHPHY_ClientOpNegComplete+0x10>
   22a7c:	0002363c 	.word	0x0002363c

Disassembly of section .text._DRV_ETHPHY_ClientOpLinkStat%924:

00022a80 <_DRV_ETHPHY_ClientOpLinkStat>:
{
   22a80:	b508      	push	{r3, lr}
    if((unsigned int)hClientObj->operPhase < sizeof(_DRV_PHY_LinkStatPhasesTbl)/sizeof(*_DRV_PHY_LinkStatPhasesTbl))
   22a82:	8bc3      	ldrh	r3, [r0, #30]
   22a84:	2b02      	cmp	r3, #2
   22a86:	d804      	bhi.n	22a92 <_DRV_ETHPHY_ClientOpLinkStat+0x12>
        (*_DRV_PHY_LinkStatPhasesTbl[hClientObj->operPhase])(hClientObj);
   22a88:	4a04      	ldr	r2, [pc, #16]	; (22a9c <_DRV_ETHPHY_ClientOpLinkStat+0x1c>)
   22a8a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   22a8e:	4798      	blx	r3
}
   22a90:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   22a92:	f06f 0108 	mvn.w	r1, #8
   22a96:	f7ff f9c9 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
}
   22a9a:	e7f9      	b.n	22a90 <_DRV_ETHPHY_ClientOpLinkStat+0x10>
   22a9c:	000226f4 	.word	0x000226f4

Disassembly of section .text._DRV_ETHPHY_ClientOpSetup%925:

00022aa0 <_DRV_ETHPHY_ClientOpSetup>:
{
   22aa0:	b508      	push	{r3, lr}
    if((unsigned int)hClientObj->operPhase >= sizeof(_DRV_PHY_SetupPhasesTbl)/sizeof(*_DRV_PHY_SetupPhasesTbl))
   22aa2:	8bc3      	ldrh	r3, [r0, #30]
   22aa4:	2b03      	cmp	r3, #3
   22aa6:	d804      	bhi.n	22ab2 <_DRV_ETHPHY_ClientOpSetup+0x12>
        (*_DRV_PHY_SetupPhasesTbl[hClientObj->operPhase])(hClientObj);
   22aa8:	4a04      	ldr	r2, [pc, #16]	; (22abc <_DRV_ETHPHY_ClientOpSetup+0x1c>)
   22aaa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   22aae:	4798      	blx	r3
}
   22ab0:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   22ab2:	f06f 0108 	mvn.w	r1, #8
   22ab6:	f7ff f9b9 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
   22aba:	e7f9      	b.n	22ab0 <_DRV_ETHPHY_ClientOpSetup+0x10>
   22abc:	00023d30 	.word	0x00023d30

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate%926:

00022ac0 <_DRV_ETHPHY_SetupPhaseNegotiate>:
{
   22ac0:	b508      	push	{r3, lr}
    if(hClientObj->operSubPhase <  sizeof(_DRV_PHY_SetupPhaseNegotiateSubPhaseTbl) / sizeof(*_DRV_PHY_SetupPhaseNegotiateSubPhaseTbl))
   22ac2:	8c03      	ldrh	r3, [r0, #32]
   22ac4:	2b07      	cmp	r3, #7
   22ac6:	d804      	bhi.n	22ad2 <_DRV_ETHPHY_SetupPhaseNegotiate+0x12>
        (*_DRV_PHY_SetupPhaseNegotiateSubPhaseTbl[hClientObj->operSubPhase])(hClientObj);
   22ac8:	4a04      	ldr	r2, [pc, #16]	; (22adc <_DRV_ETHPHY_SetupPhaseNegotiate+0x1c>)
   22aca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   22ace:	4798      	blx	r3
}
   22ad0:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   22ad2:	f06f 0108 	mvn.w	r1, #8
   22ad6:	f7ff f9a9 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
}
   22ada:	e7f9      	b.n	22ad0 <_DRV_ETHPHY_SetupPhaseNegotiate+0x10>
   22adc:	00022b00 	.word	0x00022b00

Disassembly of section .rodata%927:

00022ae0 <.rodata%927>:
   22ae0:	5f565244 	.word	0x5f565244
   22ae4:	20594850 	.word	0x20594850
   22ae8:	7265706f 	.word	0x7265706f
   22aec:	6f697461 	.word	0x6f697461
   22af0:	7265206e 	.word	0x7265206e
   22af4:	3a726f72 	.word	0x3a726f72
   22af8:	0d642520 	.word	0x0d642520
   22afc:	000a      	.short	0x000a
   22afe:	bf00      	nop

Disassembly of section .rodata._DRV_PHY_SetupPhaseNegotiateSubPhaseTbl%928:

00022b00 <_DRV_PHY_SetupPhaseNegotiateSubPhaseTbl>:
   22b00:	9215 0001 0405 0002 09f5 0002 109d 0002     ................
   22b10:	b677 0001 35c5 0002 060d 0002 e60d 0001     w....5..........

Disassembly of section .text.DRV_GMAC_Close%929:

00022b20 <DRV_GMAC_Close>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   22b20:	4b06      	ldr	r3, [pc, #24]	; (22b3c <DRV_GMAC_Close+0x1c>)
   22b22:	4283      	cmp	r3, r0
   22b24:	d109      	bne.n	22b3a <DRV_GMAC_Close+0x1a>
    if(pMACDrv != 0)
   22b26:	b140      	cbz	r0, 22b3a <DRV_GMAC_Close+0x1a>
        if(pMACDrv->sGmacData._macFlags._init == 1)	
   22b28:	7d9b      	ldrb	r3, [r3, #22]
   22b2a:	f013 0f01 	tst.w	r3, #1
   22b2e:	d004      	beq.n	22b3a <DRV_GMAC_Close+0x1a>
            pMACDrv->sGmacData._macFlags._open = 0;
   22b30:	4b02      	ldr	r3, [pc, #8]	; (22b3c <DRV_GMAC_Close+0x1c>)
   22b32:	7d9a      	ldrb	r2, [r3, #22]
   22b34:	f36f 0241 	bfc	r2, #1, #1
   22b38:	759a      	strb	r2, [r3, #22]
}
   22b3a:	4770      	bx	lr
   22b3c:	2000e288 	.word	0x2000e288

Disassembly of section .text.DRV_GMAC_Deinitialize%930:

00022b40 <DRV_GMAC_Deinitialize>:
{
   22b40:	b508      	push	{r3, lr}
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   22b42:	4b06      	ldr	r3, [pc, #24]	; (22b5c <DRV_GMAC_Deinitialize+0x1c>)
   22b44:	4283      	cmp	r3, r0
   22b46:	d104      	bne.n	22b52 <DRV_GMAC_Deinitialize+0x12>
    if(pMACDrv != 0)
   22b48:	b118      	cbz	r0, 22b52 <DRV_GMAC_Deinitialize+0x12>
        if(pMACDrv->sGmacData._macFlags._init != 0)
   22b4a:	7d9b      	ldrb	r3, [r3, #22]
   22b4c:	f013 0f01 	tst.w	r3, #1
   22b50:	d100      	bne.n	22b54 <DRV_GMAC_Deinitialize+0x14>
}
   22b52:	bd08      	pop	{r3, pc}
            _MACDeinit(pMACDrv);
   22b54:	4801      	ldr	r0, [pc, #4]	; (22b5c <DRV_GMAC_Deinitialize+0x1c>)
   22b56:	f7f0 fd03 	bl	13560 <_MACDeinit>
}
   22b5a:	e7fa      	b.n	22b52 <DRV_GMAC_Deinitialize+0x12>
   22b5c:	2000e288 	.word	0x2000e288

Disassembly of section .text.DRV_PIC32CGMAC_LibTransferEnable%931:

00022b60 <DRV_PIC32CGMAC_LibTransferEnable>:
	GMAC_REGS->GMAC_NCR |= GMAC_NCR_TXEN_Msk;
   22b60:	4b06      	ldr	r3, [pc, #24]	; (22b7c <DRV_PIC32CGMAC_LibTransferEnable+0x1c>)
   22b62:	681a      	ldr	r2, [r3, #0]
   22b64:	f042 0208 	orr.w	r2, r2, #8
   22b68:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_NCR |= GMAC_NCR_RXEN_Msk;	
   22b6a:	681a      	ldr	r2, [r3, #0]
   22b6c:	f042 0204 	orr.w	r2, r2, #4
   22b70:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_NCR |= GMAC_NCR_WESTAT_Msk;
   22b72:	681a      	ldr	r2, [r3, #0]
   22b74:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   22b78:	601a      	str	r2, [r3, #0]
}
   22b7a:	4770      	bx	lr
   22b7c:	42000800 	.word	0x42000800

Disassembly of section .text.DRV_GMAC_LibDescriptorsPoolAdd%932:

00022b80 <DRV_GMAC_LibDescriptorsPoolAdd>:
    if(dType == DRV_GMAC_DCPT_TYPE_TX)
   22b80:	2902      	cmp	r1, #2
   22b82:	d005      	beq.n	22b90 <DRV_GMAC_LibDescriptorsPoolAdd+0x10>
    else if(dType == DRV_GMAC_DCPT_TYPE_RX)
   22b84:	2901      	cmp	r1, #1
        pMACDrv->sGmacData.gmac_queue[0].pRxDesc = gmac_dcpt_array.sRxDesc_queue0;
   22b86:	bf04      	itt	eq
   22b88:	4b03      	ldreq	r3, [pc, #12]	; (22b98 <DRV_GMAC_LibDescriptorsPoolAdd+0x18>)
   22b8a:	f8c0 3090 	streq.w	r3, [r0, #144]	; 0x90
}
   22b8e:	4770      	bx	lr
        pMACDrv->sGmacData.gmac_queue[0].pTxDesc = gmac_dcpt_array.sTxDesc_queue0;
   22b90:	4b02      	ldr	r3, [pc, #8]	; (22b9c <DRV_GMAC_LibDescriptorsPoolAdd+0x1c>)
   22b92:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
   22b96:	4770      	bx	lr
   22b98:	2000e728 	.word	0x2000e728
   22b9c:	2000e6e8 	.word	0x2000e6e8

Disassembly of section .text._SwapARPPacket%933:

00022ba0 <_SwapARPPacket>:
    p->HardwareType     = TCPIP_Helper_htons(p->HardwareType);
   22ba0:	8802      	ldrh	r2, [r0, #0]
   22ba2:	0a13      	lsrs	r3, r2, #8
   22ba4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   22ba8:	8003      	strh	r3, [r0, #0]
    p->Protocol         = TCPIP_Helper_htons(p->Protocol);
   22baa:	8842      	ldrh	r2, [r0, #2]
   22bac:	0a13      	lsrs	r3, r2, #8
   22bae:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   22bb2:	8043      	strh	r3, [r0, #2]
    p->Operation        = TCPIP_Helper_htons(p->Operation);
   22bb4:	88c2      	ldrh	r2, [r0, #6]
   22bb6:	0a13      	lsrs	r3, r2, #8
   22bb8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   22bbc:	80c3      	strh	r3, [r0, #6]
}
   22bbe:	4770      	bx	lr

Disassembly of section .text.TCPIP_DNS_OAHASH_KeyHash%934:

00022bc0 <TCPIP_DNS_OAHASH_KeyHash>:
{
   22bc0:	b538      	push	{r3, r4, r5, lr}
   22bc2:	4605      	mov	r5, r0
   22bc4:	460c      	mov	r4, r1
    hostnameLen = strlen((const char*)dnsHostNameKey);
   22bc6:	4608      	mov	r0, r1
   22bc8:	f001 f97a 	bl	23ec0 <strlen>
    return fnv_32_hash(dnsHostNameKey, hostnameLen) % (pOH->hEntries);
   22bcc:	4601      	mov	r1, r0
   22bce:	4620      	mov	r0, r4
   22bd0:	f7fe fb3c 	bl	2124c <fnv_32_hash>
   22bd4:	68eb      	ldr	r3, [r5, #12]
   22bd6:	fbb0 f2f3 	udiv	r2, r0, r3
}
   22bda:	fb02 0013 	mls	r0, r2, r3, r0
   22bde:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListLock%935:

00022be0 <TCPIP_Helper_ProtectedSingleListLock>:

bool TCPIP_Helper_ProtectedSingleListLock(PROTECTED_SINGLE_LIST* pL)
{
   22be0:	b508      	push	{r3, lr}
   22be2:	4603      	mov	r3, r0
    if(pL->semValid)
   22be4:	7c00      	ldrb	r0, [r0, #16]
   22be6:	b900      	cbnz	r0, 22bea <TCPIP_Helper_ProtectedSingleListLock+0xa>
    {
        return (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE);
    }

    return false;
}
   22be8:	bd08      	pop	{r3, pc}
        return (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE);
   22bea:	f64f 71ff 	movw	r1, #65535	; 0xffff
   22bee:	f103 000c 	add.w	r0, r3, #12
   22bf2:	f000 f97f 	bl	22ef4 <OSAL_SEM_Pend>
   22bf6:	2801      	cmp	r0, #1
   22bf8:	bf14      	ite	ne
   22bfa:	2000      	movne	r0, #0
   22bfc:	2001      	moveq	r0, #1
   22bfe:	e7f3      	b.n	22be8 <TCPIP_Helper_ProtectedSingleListLock+0x8>

Disassembly of section .rodata.TCPIP_MAC_POWER_TBL%936:

00022c00 <TCPIP_MAC_POWER_TBL>:
	...
   22c08:	0001 0000 fa50 0001 0002 0000 fa58 0001     ....P.......X...
   22c18:	0003 0000 fa5c 0001                         ....\...

Disassembly of section .text.TCPIP_STACK_NetDefaultSet%937:

00022c20 <TCPIP_STACK_NetDefaultSet>:
   22c20:	b150      	cbz	r0, 22c38 <TCPIP_STACK_NetDefaultSet+0x18>
   22c22:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   22c26:	f012 0f40 	tst.w	r2, #64	; 0x40
   22c2a:	d101      	bne.n	22c30 <TCPIP_STACK_NetDefaultSet+0x10>
    return false;
   22c2c:	2000      	movs	r0, #0
}
   22c2e:	4770      	bx	lr
        tcpipDefIf.defaultNet = pNewIf;
   22c30:	4a02      	ldr	r2, [pc, #8]	; (22c3c <TCPIP_STACK_NetDefaultSet+0x1c>)
   22c32:	6010      	str	r0, [r2, #0]
        return true;
   22c34:	2001      	movs	r0, #1
   22c36:	4770      	bx	lr
    return false;
   22c38:	2000      	movs	r0, #0
   22c3a:	4770      	bx	lr
   22c3c:	2000ee70 	.word	0x2000ee70

Disassembly of section .text._TCPIPStackHandleToNetLinked%938:

00022c40 <_TCPIPStackHandleToNetLinked>:
   22c40:	b128      	cbz	r0, 22c4e <_TCPIPStackHandleToNetLinked+0xe>
   22c42:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   22c46:	f012 0f40 	tst.w	r2, #64	; 0x40
   22c4a:	d101      	bne.n	22c50 <_TCPIPStackHandleToNetLinked+0x10>
    return 0;
   22c4c:	2000      	movs	r0, #0
}
   22c4e:	4770      	bx	lr
    if(pNetIf != 0 && pNetIf->exFlags.linkPrev != 0)
   22c50:	f890 2060 	ldrb.w	r2, [r0, #96]	; 0x60
   22c54:	f002 0201 	and.w	r2, r2, #1
        return pNetIf;
   22c58:	2a00      	cmp	r2, #0
   22c5a:	bf08      	it	eq
   22c5c:	2000      	moveq	r0, #0
   22c5e:	4770      	bx	lr

Disassembly of section .text.TCPIP_Notification_Remove%939:

00022c60 <TCPIP_Notification_Remove>:
{
   22c60:	b538      	push	{r3, r4, r5, lr}
   22c62:	4604      	mov	r4, r0
   22c64:	4608      	mov	r0, r1
   22c66:	4615      	mov	r5, r2
    if(TCPIP_Helper_ProtectedSingleListNodeRemove(notifyList, node))
   22c68:	4621      	mov	r1, r4
   22c6a:	f7fe fb4f 	bl	2130c <TCPIP_Helper_ProtectedSingleListNodeRemove>
   22c6e:	b128      	cbz	r0, 22c7c <TCPIP_Notification_Remove+0x1c>
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   22c70:	68eb      	ldr	r3, [r5, #12]
   22c72:	4621      	mov	r1, r4
   22c74:	4628      	mov	r0, r5
   22c76:	4798      	blx	r3
        return true;
   22c78:	2001      	movs	r0, #1
}
   22c7a:	bd38      	pop	{r3, r4, r5, pc}
    return false;
   22c7c:	2000      	movs	r0, #0
   22c7e:	e7fc      	b.n	22c7a <TCPIP_Notification_Remove+0x1a>

Disassembly of section .rodata%940:

00022c80 <.rodata%940>:
   22c80:	6b636150 	.word	0x6b636150
   22c84:	41207465 	.word	0x41207465
   22c88:	203a6b63 	.word	0x203a6b63
   22c8c:	6870726f 	.word	0x6870726f
   22c90:	70206e61 	.word	0x70206e61
   22c94:	656b6361 	.word	0x656b6361
   22c98:	0d202174 	.word	0x0d202174
   22c9c:	000a      	.short	0x000a
   22c9e:	bf00      	nop

Disassembly of section .text.TCPIP_UDP_DestinationPortSet%941:

00022ca0 <TCPIP_UDP_DestinationPortSet>:
{
   22ca0:	b510      	push	{r4, lr}
   22ca2:	460c      	mov	r4, r1
    UDP_SOCKET_DCPT *pSkt = _UDPSocketDcpt(s);
   22ca4:	f7ff fa52 	bl	2214c <_UDPSocketDcpt>
    if(pSkt != 0)
   22ca8:	b140      	cbz	r0, 22cbc <TCPIP_UDP_DestinationPortSet+0x1c>
        pSkt->remotePort = remotePort;
   22caa:	8504      	strh	r4, [r0, #40]	; 0x28
    pSkt->extFlags.rxEnable = 1;
   22cac:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   22cb0:	f042 0202 	orr.w	r2, r2, #2
   22cb4:	f880 2042 	strb.w	r2, [r0, #66]	; 0x42
        return true;
   22cb8:	2001      	movs	r0, #1
}
   22cba:	bd10      	pop	{r4, pc}
    return false;
   22cbc:	2000      	movs	r0, #0
   22cbe:	e7fc      	b.n	22cba <TCPIP_UDP_DestinationPortSet+0x1a>

Disassembly of section .text._keyRightProcess%942:

00022cc0 <_keyRightProcess>:
    if(pCmdIO->cmdPnt < pCmdIO->cmdEnd)
   22cc0:	6982      	ldr	r2, [r0, #24]
   22cc2:	69c3      	ldr	r3, [r0, #28]
   22cc4:	429a      	cmp	r2, r3
   22cc6:	d20a      	bcs.n	22cde <_keyRightProcess+0x1e>
{   // right arrow
   22cc8:	b510      	push	{r4, lr}
   22cca:	4604      	mov	r4, r0
        (*pCmdApi->msg)(cmdIoParam, pSeqDcpt->keyCode);
   22ccc:	6803      	ldr	r3, [r0, #0]
   22cce:	681b      	ldr	r3, [r3, #0]
   22cd0:	6809      	ldr	r1, [r1, #0]
   22cd2:	6840      	ldr	r0, [r0, #4]
   22cd4:	4798      	blx	r3
        pCmdIO->cmdPnt++;
   22cd6:	69a3      	ldr	r3, [r4, #24]
   22cd8:	3301      	adds	r3, #1
   22cda:	61a3      	str	r3, [r4, #24]
}
   22cdc:	bd10      	pop	{r4, pc}
   22cde:	4770      	bx	lr

Disassembly of section .text.GetCommandCharacter%943:

00022ce0 <GetCommandCharacter>:
{
   22ce0:	b500      	push	{lr}
   22ce2:	b083      	sub	sp, #12
    SYS_CONSOLE_Read(_cmdInitData.consoleIndex, &new_c, 1);
   22ce4:	2201      	movs	r2, #1
   22ce6:	f10d 0107 	add.w	r1, sp, #7
   22cea:	4b04      	ldr	r3, [pc, #16]	; (22cfc <GetCommandCharacter+0x1c>)
   22cec:	8858      	ldrh	r0, [r3, #2]
   22cee:	f7fe f807 	bl	20d00 <SYS_CONSOLE_Read>
}
   22cf2:	f89d 0007 	ldrb.w	r0, [sp, #7]
   22cf6:	b003      	add	sp, #12
   22cf8:	f85d fb04 	ldr.w	pc, [sp], #4
   22cfc:	2000eed0 	.word	0x2000eed0

Disassembly of section .text.SYS_INT_SourceRestore%944:

00022d00 <SYS_INT_SourceRestore>:

void SYS_INT_SourceRestore( INT_SOURCE source, bool status )
{
    if( status ) {
   22d00:	b151      	cbz	r1, 22d18 <SYS_INT_SourceRestore+0x18>
  if ((int32_t)(IRQn) >= 0)
   22d02:	2800      	cmp	r0, #0
   22d04:	db08      	blt.n	22d18 <SYS_INT_SourceRestore+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   22d06:	0942      	lsrs	r2, r0, #5
   22d08:	f000 001f 	and.w	r0, r0, #31
   22d0c:	2301      	movs	r3, #1
   22d0e:	fa03 f000 	lsl.w	r0, r3, r0
   22d12:	4b02      	ldr	r3, [pc, #8]	; (22d1c <SYS_INT_SourceRestore+0x1c>)
   22d14:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
        SYS_INT_SourceEnable( source );
    }
    return;
}
   22d18:	4770      	bx	lr
   22d1a:	bf00      	nop
   22d1c:	e000e100 	.word	0xe000e100

Disassembly of section .text.SYS_RANDOM_CryptoInitialize%945:

00022d20 <SYS_RANDOM_CryptoInitialize>:
{
   22d20:	b508      	push	{r3, lr}
    if(CRYPT_RNG_Initialize(&sysRandCtx) >= 0)
   22d22:	4805      	ldr	r0, [pc, #20]	; (22d38 <SYS_RANDOM_CryptoInitialize+0x18>)
   22d24:	f000 fffb 	bl	23d1e <CRYPT_RNG_Initialize>
   22d28:	2800      	cmp	r0, #0
        pRandCtx = 0;
   22d2a:	4803      	ldr	r0, [pc, #12]	; (22d38 <SYS_RANDOM_CryptoInitialize+0x18>)
   22d2c:	bfb8      	it	lt
   22d2e:	2000      	movlt	r0, #0
   22d30:	4b02      	ldr	r3, [pc, #8]	; (22d3c <SYS_RANDOM_CryptoInitialize+0x1c>)
   22d32:	6018      	str	r0, [r3, #0]
}
   22d34:	bd08      	pop	{r3, pc}
   22d36:	bf00      	nop
   22d38:	2000e180 	.word	0x2000e180
   22d3c:	2000eee8 	.word	0x2000eee8

Disassembly of section .rodata.tcpipPhyInitData_LAN867x%946:

00022d40 <tcpipPhyInitData_LAN867x>:
   22d40:	00000000 42000800 00010000 00023a80     .......B.....:..
   22d50:	00000000 0001f8e4 00024410 00000000     .........D......

Disassembly of section .text.prvTaskExitError%947:

00022d60 <prvTaskExitError>:
{
   22d60:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
   22d62:	2300      	movs	r3, #0
   22d64:	9301      	str	r3, [sp, #4]
	__asm volatile
   22d66:	f04f 0320 	mov.w	r3, #32
   22d6a:	f383 8811 	msr	BASEPRI, r3
   22d6e:	f3bf 8f6f 	isb	sy
   22d72:	f3bf 8f4f 	dsb	sy
	while( ulDummy == 0 )
   22d76:	9b01      	ldr	r3, [sp, #4]
   22d78:	2b00      	cmp	r3, #0
   22d7a:	d0fc      	beq.n	22d76 <prvTaskExitError+0x16>
}
   22d7c:	b002      	add	sp, #8
   22d7e:	4770      	bx	lr

Disassembly of section .text.vPortEnterCritical%948:

00022d80 <vPortEnterCritical>:
   22d80:	f04f 0320 	mov.w	r3, #32
   22d84:	f383 8811 	msr	BASEPRI, r3
   22d88:	f3bf 8f6f 	isb	sy
   22d8c:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
   22d90:	4a02      	ldr	r2, [pc, #8]	; (22d9c <vPortEnterCritical+0x1c>)
   22d92:	6813      	ldr	r3, [r2, #0]
   22d94:	3301      	adds	r3, #1
   22d96:	6013      	str	r3, [r2, #0]
}
   22d98:	4770      	bx	lr
   22d9a:	bf00      	nop
   22d9c:	2000eef4 	.word	0x2000eef4

Disassembly of section .rodata.reseedSeedA_data%949:

00022da0 <reseedSeedA_data>:
   22da0:	8e8a2be6 b641f1e8 e3660598 49c0e3bf     .+....A...f....I
   22db0:	acd4da03 229fdf2c 670a0180 d383bc39     ....,.."...g9...

Disassembly of section .text.local_miim_close%950:

00022dc0 <local_miim_close>:
{
   22dc0:	b510      	push	{r4, lr}
	clientObj.miimBase->DRV_MIIM_Close(clientObj.miimHandle);
   22dc2:	4c05      	ldr	r4, [pc, #20]	; (22dd8 <local_miim_close+0x18>)
   22dc4:	68e3      	ldr	r3, [r4, #12]
   22dc6:	69db      	ldr	r3, [r3, #28]
   22dc8:	68a0      	ldr	r0, [r4, #8]
   22dca:	4798      	blx	r3
	clientObj.miimHandle = 0;
   22dcc:	2000      	movs	r0, #0
   22dce:	60a0      	str	r0, [r4, #8]
	SYS_CONSOLE_PRINT("> Miim closed. \r\n");
   22dd0:	4902      	ldr	r1, [pc, #8]	; (22ddc <local_miim_close+0x1c>)
   22dd2:	f7f9 fc63 	bl	1c69c <SYS_CONSOLE_Print>
}
   22dd6:	bd10      	pop	{r4, pc}
   22dd8:	2000ed04 	.word	0x2000ed04
   22ddc:	0000c41c 	.word	0x0000c41c

Disassembly of section .text._sbrk_r%951:

00022de0 <_sbrk_r>:
   22de0:	b538      	push	{r3, r4, r5, lr}
   22de2:	4c06      	ldr	r4, [pc, #24]	; (22dfc <_sbrk_r+0x1c>)
   22de4:	2300      	movs	r3, #0
   22de6:	4605      	mov	r5, r0
   22de8:	4608      	mov	r0, r1
   22dea:	6023      	str	r3, [r4, #0]
   22dec:	f7fe ff4c 	bl	21c88 <_sbrk>
   22df0:	1c43      	adds	r3, r0, #1
   22df2:	d102      	bne.n	22dfa <_sbrk_r+0x1a>
   22df4:	6823      	ldr	r3, [r4, #0]
   22df6:	b103      	cbz	r3, 22dfa <_sbrk_r+0x1a>
   22df8:	602b      	str	r3, [r5, #0]
   22dfa:	bd38      	pop	{r3, r4, r5, pc}
   22dfc:	20000000 	.word	0x20000000

Disassembly of section .text._close_r%952:

00022e00 <_close_r>:
   22e00:	b538      	push	{r3, r4, r5, lr}
   22e02:	4c06      	ldr	r4, [pc, #24]	; (22e1c <_close_r+0x1c>)
   22e04:	2300      	movs	r3, #0
   22e06:	4605      	mov	r5, r0
   22e08:	4608      	mov	r0, r1
   22e0a:	6023      	str	r3, [r4, #0]
   22e0c:	f001 fb54 	bl	244b8 <_close>
   22e10:	1c43      	adds	r3, r0, #1
   22e12:	d102      	bne.n	22e1a <_close_r+0x1a>
   22e14:	6823      	ldr	r3, [r4, #0]
   22e16:	b103      	cbz	r3, 22e1a <_close_r+0x1a>
   22e18:	602b      	str	r3, [r5, #0]
   22e1a:	bd38      	pop	{r3, r4, r5, pc}
   22e1c:	20000000 	.word	0x20000000

Disassembly of section .text._isatty_r%953:

00022e20 <_isatty_r>:
   22e20:	b538      	push	{r3, r4, r5, lr}
   22e22:	4c06      	ldr	r4, [pc, #24]	; (22e3c <_isatty_r+0x1c>)
   22e24:	2300      	movs	r3, #0
   22e26:	4605      	mov	r5, r0
   22e28:	4608      	mov	r0, r1
   22e2a:	6023      	str	r3, [r4, #0]
   22e2c:	f001 fb4a 	bl	244c4 <_isatty>
   22e30:	1c43      	adds	r3, r0, #1
   22e32:	d102      	bne.n	22e3a <_isatty_r+0x1a>
   22e34:	6823      	ldr	r3, [r4, #0]
   22e36:	b103      	cbz	r3, 22e3a <_isatty_r+0x1a>
   22e38:	602b      	str	r3, [r5, #0]
   22e3a:	bd38      	pop	{r3, r4, r5, pc}
   22e3c:	20000000 	.word	0x20000000

Disassembly of section .text._DRV_GMAC_LinkStateDown%954:

00022e40 <_DRV_GMAC_LinkStateDown>:
{
   22e40:	b510      	push	{r4, lr}
   22e42:	4604      	mov	r4, r0
	pMACDrv->sGmacData._macFlags._linkPrev = 0;
   22e44:	7d83      	ldrb	r3, [r0, #22]
	pMACDrv->sGmacData._macFlags._linkUpDone = 0;
   22e46:	f003 03ef 	and.w	r3, r3, #239	; 0xef
   22e4a:	f36f 1345 	bfc	r3, #5, #1
   22e4e:	7583      	strb	r3, [r0, #22]
	pMACDrv->sGmacData._linkUpTick = SYS_TMR_TickCountGet();
   22e50:	f7ff f9f4 	bl	2223c <SYS_TMR_TickCountGet>
   22e54:	63a0      	str	r0, [r4, #56]	; 0x38
	pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_START_LINK;
   22e56:	2300      	movs	r3, #0
   22e58:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
}
   22e5c:	bd10      	pop	{r4, pc}

Disassembly of section .text._TCPIsGetReady%955:

00022e5e <_TCPIsGetReady>:
	if(pSkt->rxHead >= pSkt->rxTail)
   22e5e:	69c2      	ldr	r2, [r0, #28]
   22e60:	6a01      	ldr	r1, [r0, #32]
   22e62:	428a      	cmp	r2, r1
   22e64:	d207      	bcs.n	22e76 <_TCPIsGetReady+0x18>
    return (pSkt->rxEnd - pSkt->rxTail + 1) + (pSkt->rxHead - pSkt->rxStart);
   22e66:	6983      	ldr	r3, [r0, #24]
   22e68:	1a5b      	subs	r3, r3, r1
   22e6a:	6940      	ldr	r0, [r0, #20]
   22e6c:	1a10      	subs	r0, r2, r0
   22e6e:	4418      	add	r0, r3
   22e70:	3001      	adds	r0, #1
   22e72:	b280      	uxth	r0, r0
}
   22e74:	4770      	bx	lr
		return pSkt->rxHead - pSkt->rxTail;
   22e76:	1a50      	subs	r0, r2, r1
   22e78:	b280      	uxth	r0, r0
   22e7a:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressBcast%956:

00022e7c <TCPIP_STACK_NetAddressBcast>:
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   22e7c:	b158      	cbz	r0, 22e96 <TCPIP_STACK_NetAddressBcast+0x1a>
   22e7e:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   22e82:	f012 0f40 	tst.w	r2, #64	; 0x40
   22e86:	d101      	bne.n	22e8c <TCPIP_STACK_NetAddressBcast+0x10>
    return 0;
   22e88:	2000      	movs	r0, #0
}
   22e8a:	4770      	bx	lr
        return (pNetIf->netIPAddr.Val | ~pNetIf->netMask.Val);
   22e8c:	6882      	ldr	r2, [r0, #8]
   22e8e:	6840      	ldr	r0, [r0, #4]
   22e90:	ea60 0002 	orn	r0, r0, r2
   22e94:	4770      	bx	lr
    return 0;
   22e96:	2000      	movs	r0, #0
   22e98:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddress%957:

00022e9a <TCPIP_STACK_NetAddress>:
{
   22e9a:	b508      	push	{r3, lr}
   22e9c:	4603      	mov	r3, r0
   22e9e:	b138      	cbz	r0, 22eb0 <TCPIP_STACK_NetAddress+0x16>
   22ea0:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   22ea4:	f002 0240 	and.w	r2, r2, #64	; 0x40
    return 0;
   22ea8:	2a00      	cmp	r2, #0
   22eaa:	bf14      	ite	ne
   22eac:	4603      	movne	r3, r0
   22eae:	2300      	moveq	r3, #0
    return TCPIP_STACK_NetAddressGet(pNetIf);
   22eb0:	4618      	mov	r0, r3
   22eb2:	f000 fc2f 	bl	23714 <TCPIP_STACK_NetAddressGet>
}
   22eb6:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_STACK_NetworkIsLinked%958:

00022eb8 <TCPIP_STACK_NetworkIsLinked>:
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   22eb8:	b158      	cbz	r0, 22ed2 <TCPIP_STACK_NetworkIsLinked+0x1a>
   22eba:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   22ebe:	f012 0f40 	tst.w	r2, #64	; 0x40
   22ec2:	d101      	bne.n	22ec8 <TCPIP_STACK_NetworkIsLinked+0x10>
    return false;
   22ec4:	2000      	movs	r0, #0
}
   22ec6:	4770      	bx	lr
        return pNetIf->exFlags.linkPrev;
   22ec8:	f890 0060 	ldrb.w	r0, [r0, #96]	; 0x60
   22ecc:	f000 0001 	and.w	r0, r0, #1
   22ed0:	4770      	bx	lr
    return false;
   22ed2:	2000      	movs	r0, #0
   22ed4:	4770      	bx	lr

Disassembly of section .text.TCPIP_PKT_PayloadLen%959:

00022ed6 <TCPIP_PKT_PayloadLen>:
    if(pPkt)
   22ed6:	b148      	cbz	r0, 22eec <TCPIP_PKT_PayloadLen+0x16>
        TCPIP_MAC_DATA_SEGMENT* pSeg = pPkt->pDSeg;
   22ed8:	6903      	ldr	r3, [r0, #16]
        while(pSeg != 0)
   22eda:	b14b      	cbz	r3, 22ef0 <TCPIP_PKT_PayloadLen+0x1a>
    uint32_t payloadSize = 0;
   22edc:	2000      	movs	r0, #0
            payloadSize += pSeg->segLen;
   22ede:	899a      	ldrh	r2, [r3, #12]
   22ee0:	4410      	add	r0, r2
            pSeg = pSeg->next;
   22ee2:	681b      	ldr	r3, [r3, #0]
        while(pSeg != 0)
   22ee4:	2b00      	cmp	r3, #0
   22ee6:	d1fa      	bne.n	22ede <TCPIP_PKT_PayloadLen+0x8>
}
   22ee8:	b280      	uxth	r0, r0
   22eea:	4770      	bx	lr
    uint32_t payloadSize = 0;
   22eec:	2000      	movs	r0, #0
   22eee:	e7fb      	b.n	22ee8 <TCPIP_PKT_PayloadLen+0x12>
   22ef0:	2000      	movs	r0, #0
   22ef2:	e7f9      	b.n	22ee8 <TCPIP_PKT_PayloadLen+0x12>

Disassembly of section .text.OSAL_SEM_Pend%960:

00022ef4 <OSAL_SEM_Pend>:
   </code>

  Remarks:
 */
OSAL_RESULT OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE* semID, uint16_t waitMS)
{
   22ef4:	b508      	push	{r3, lr}
  else
  {
    timeout = (TickType_t)(waitMS / portTICK_PERIOD_MS);
  }

  if (xSemaphoreTake(*(SemaphoreHandle_t*)semID, timeout) == pdTRUE)
   22ef6:	f64f 73ff 	movw	r3, #65535	; 0xffff
   22efa:	4299      	cmp	r1, r3
   22efc:	bf08      	it	eq
   22efe:	f04f 31ff 	moveq.w	r1, #4294967295
   22f02:	6800      	ldr	r0, [r0, #0]
   22f04:	f7ef fff0 	bl	12ee8 <xQueueSemaphoreTake>
    return OSAL_RESULT_TRUE;
  else
    return OSAL_RESULT_FALSE;
}
   22f08:	2801      	cmp	r0, #1
   22f0a:	bf14      	ite	ne
   22f0c:	2000      	movne	r0, #0
   22f0e:	2001      	moveq	r0, #1
   22f10:	bd08      	pop	{r3, pc}

Disassembly of section .text.OSAL_MUTEX_Lock%961:

00022f12 <OSAL_MUTEX_Lock>:

  Remarks:

 */
OSAL_RESULT OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE* mutexID, uint16_t waitMS)
{
   22f12:	b508      	push	{r3, lr}
  else
  {
    timeout = (TickType_t)(waitMS / portTICK_PERIOD_MS);
  }

  if (xSemaphoreTake(*(SemaphoreHandle_t*)mutexID, timeout) == pdTRUE)
   22f14:	f64f 73ff 	movw	r3, #65535	; 0xffff
   22f18:	4299      	cmp	r1, r3
   22f1a:	bf08      	it	eq
   22f1c:	f04f 31ff 	moveq.w	r1, #4294967295
   22f20:	6800      	ldr	r0, [r0, #0]
   22f22:	f7ef ffe1 	bl	12ee8 <xQueueSemaphoreTake>
    return OSAL_RESULT_TRUE;
  else
    return OSAL_RESULT_FALSE;
}
   22f26:	2801      	cmp	r0, #1
   22f28:	bf14      	ite	ne
   22f2a:	2000      	movne	r0, #0
   22f2c:	2001      	moveq	r0, #1
   22f2e:	bd08      	pop	{r3, pc}

Disassembly of section .text._keyUpProcess%962:

00022f30 <_keyUpProcess>:
{   // up arrow
   22f30:	b508      	push	{r3, lr}
    if(pCmdIO->currHistN)
   22f32:	f8d0 30d4 	ldr.w	r3, [r0, #212]	; 0xd4
   22f36:	b13b      	cbz	r3, 22f48 <_keyUpProcess+0x18>
        pNext = pCmdIO->currHistN->next;
   22f38:	6819      	ldr	r1, [r3, #0]
        if(pNext == pCmdIO->histList.head)
   22f3a:	f8d0 30cc 	ldr.w	r3, [r0, #204]	; 0xcc
   22f3e:	428b      	cmp	r3, r1
   22f40:	d001      	beq.n	22f46 <_keyUpProcess+0x16>
    DisplayNodeMsg(pCmdIO, pNext);
   22f42:	f7f6 ff3d 	bl	19dc0 <DisplayNodeMsg>
}
   22f46:	bd08      	pop	{r3, pc}
        pNext = pCmdIO->histList.head;
   22f48:	f8d0 10cc 	ldr.w	r1, [r0, #204]	; 0xcc
   22f4c:	e7f9      	b.n	22f42 <_keyUpProcess+0x12>

Disassembly of section .text._DRV_ETHPHY_ResetPhaseIdle%963:

00022f4e <_DRV_ETHPHY_ResetPhaseIdle>:
{
   22f4e:	b510      	push	{r4, lr}
   22f50:	4604      	mov	r4, r0
    if(_DRV_PHY_SMIWriteStart(hClientObj, PHY_REG_BMCON, _BMCON_RESET_MASK))
   22f52:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   22f56:	2100      	movs	r1, #0
   22f58:	f7fe f823 	bl	20fa2 <_DRV_PHY_SMIWriteStart>
   22f5c:	b900      	cbnz	r0, 22f60 <_DRV_ETHPHY_ResetPhaseIdle+0x12>
}
   22f5e:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   22f60:	2301      	movs	r3, #1
   22f62:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   22f64:	2300      	movs	r3, #0
   22f66:	8423      	strh	r3, [r4, #32]
}
   22f68:	e7f9      	b.n	22f5e <_DRV_ETHPHY_ResetPhaseIdle+0x10>

Disassembly of section .rodata._DRV_PHY_ClientOpTbl%964:

00022f6c <_DRV_PHY_ClientOpTbl>:
   22f6c:	191b 0001 2aa1 0002 2a81 0002 2a61 0002     .....*...*..a*..
   22f7c:	2a41 0002 2a21 0002 2a01 0002               A*..!*...*..

Disassembly of section .text.DRV_GMAC_EventPendingGet%965:

00022f88 <DRV_GMAC_EventPendingGet>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   22f88:	4b05      	ldr	r3, [pc, #20]	; (22fa0 <DRV_GMAC_EventPendingGet+0x18>)
   22f8a:	4283      	cmp	r3, r0
   22f8c:	d104      	bne.n	22f98 <DRV_GMAC_EventPendingGet+0x10>
    if(pMACDrv != 0)
   22f8e:	b128      	cbz	r0, 22f9c <DRV_GMAC_EventPendingGet+0x14>
        return pMACDrv->sGmacData._gmac_event_group_dcpt._TcpPendingEvents;
   22f90:	f8b3 004e 	ldrh.w	r0, [r3, #78]	; 0x4e
   22f94:	b280      	uxth	r0, r0
   22f96:	4770      	bx	lr
    return TCPIP_MAC_EV_NONE;
   22f98:	2000      	movs	r0, #0
   22f9a:	4770      	bx	lr
   22f9c:	2000      	movs	r0, #0
}
   22f9e:	4770      	bx	lr
   22fa0:	2000e288 	.word	0x2000e288

Disassembly of section .text.DRV_PIC32CGMAC_LibClose%966:

00022fa4 <DRV_PIC32CGMAC_LibClose>:
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_TXEN_Msk;
   22fa4:	4b05      	ldr	r3, [pc, #20]	; (22fbc <DRV_PIC32CGMAC_LibClose+0x18>)
   22fa6:	681a      	ldr	r2, [r3, #0]
   22fa8:	f022 0208 	bic.w	r2, r2, #8
   22fac:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_RXEN_Msk;
   22fae:	681a      	ldr	r2, [r3, #0]
   22fb0:	f022 0204 	bic.w	r2, r2, #4
   22fb4:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_ISR;
   22fb6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
   22fb8:	4770      	bx	lr
   22fba:	bf00      	nop
   22fbc:	42000800 	.word	0x42000800

Disassembly of section .text.DRV_PIC32CGMAC_SingleListHeadRemove%967:

00022fc0 <DRV_PIC32CGMAC_SingleListHeadRemove>:
{
   22fc0:	4603      	mov	r3, r0
	DRV_PIC32CGMAC_SGL_LIST_NODE* pN = pL->head;
   22fc2:	6800      	ldr	r0, [r0, #0]
    if(pN)
   22fc4:	b148      	cbz	r0, 22fda <DRV_PIC32CGMAC_SingleListHeadRemove+0x1a>
        if(pL->head == pL->tail)
   22fc6:	685a      	ldr	r2, [r3, #4]
   22fc8:	4282      	cmp	r2, r0
            pL->head = pL->tail = 0;
   22fca:	bf06      	itte	eq
   22fcc:	2200      	moveq	r2, #0
   22fce:	605a      	streq	r2, [r3, #4]
            pL->head = pN->next;
   22fd0:	6802      	ldrne	r2, [r0, #0]
   22fd2:	601a      	str	r2, [r3, #0]
        pL->nNodes--;
   22fd4:	689a      	ldr	r2, [r3, #8]
   22fd6:	3a01      	subs	r2, #1
   22fd8:	609a      	str	r2, [r3, #8]
}
   22fda:	4770      	bx	lr

Disassembly of section .text.Helper_SingleListHeadRemove%968:

00022fdc <Helper_SingleListHeadRemove>:
{
   22fdc:	4603      	mov	r3, r0
	SGL_LIST_NODE* pN = pL->head;
   22fde:	6800      	ldr	r0, [r0, #0]
    if(pN)
   22fe0:	b148      	cbz	r0, 22ff6 <Helper_SingleListHeadRemove+0x1a>
        if(pL->head == pL->tail)
   22fe2:	685a      	ldr	r2, [r3, #4]
   22fe4:	4282      	cmp	r2, r0
            pL->head = pL->tail = 0;
   22fe6:	bf06      	itte	eq
   22fe8:	2200      	moveq	r2, #0
   22fea:	605a      	streq	r2, [r3, #4]
            pL->head = pN->next;
   22fec:	6802      	ldrne	r2, [r0, #0]
   22fee:	601a      	str	r2, [r3, #0]
        pL->nNodes--;
   22ff0:	689a      	ldr	r2, [r3, #8]
   22ff2:	3a01      	subs	r2, #1
   22ff4:	609a      	str	r2, [r3, #8]
}
   22ff6:	4770      	bx	lr

Disassembly of section .text._ARPTxAckFnc%969:

00022ff8 <_ARPTxAckFnc>:
{
   22ff8:	b508      	push	{r3, lr}
    if(arpMod.pMacPkt != pPkt)
   22ffa:	4b05      	ldr	r3, [pc, #20]	; (23010 <_ARPTxAckFnc+0x18>)
   22ffc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   22ffe:	4283      	cmp	r3, r0
   23000:	d101      	bne.n	23006 <_ARPTxAckFnc+0xe>
    return true;
   23002:	2001      	movs	r0, #1
}
   23004:	bd08      	pop	{r3, pc}
        TCPIP_PKT_PacketFree(pPkt);
   23006:	f7fd f8b3 	bl	20170 <_TCPIP_PKT_PacketFree>
        return false;
   2300a:	2000      	movs	r0, #0
   2300c:	e7fa      	b.n	23004 <_ARPTxAckFnc+0xc>
   2300e:	bf00      	nop
   23010:	2000e974 	.word	0x2000e974

Disassembly of section .text.TCPIP_IPV4_MaxDatagramDataSizeGet%970:

00023014 <TCPIP_IPV4_MaxDatagramDataSizeGet>:
   23014:	b150      	cbz	r0, 2302c <TCPIP_IPV4_MaxDatagramDataSizeGet+0x18>
   23016:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   2301a:	f012 0f40 	tst.w	r2, #64	; 0x40
   2301e:	d101      	bne.n	23024 <TCPIP_IPV4_MaxDatagramDataSizeGet+0x10>

int TCPIP_IPV4_MaxDatagramDataSizeGet(TCPIP_NET_HANDLE netH)
{
    TCPIP_NET_IF* pIf = _TCPIPStackHandleToNetUp(netH);

    return pIf ? _TCPIPStackNetLinkMtu(pIf) - sizeof(IPV4_HEADER) : 0;
   23020:	2000      	movs	r0, #0
}
   23022:	4770      	bx	lr
    return pIf ? _TCPIPStackNetLinkMtu(pIf) - sizeof(IPV4_HEADER) : 0;
   23024:	f8b0 005e 	ldrh.w	r0, [r0, #94]	; 0x5e
   23028:	3814      	subs	r0, #20
   2302a:	4770      	bx	lr
   2302c:	2000      	movs	r0, #0
   2302e:	4770      	bx	lr

Disassembly of section .text._TCPIP_HEAP_Calloc%971:

00023030 <_TCPIP_HEAP_Calloc>:
{
   23030:	b538      	push	{r3, r4, r5, lr}
    void* pBuff = _TCPIP_HEAP_Malloc(heapH, nElems * elemSize);
   23032:	fb02 f501 	mul.w	r5, r2, r1
   23036:	4629      	mov	r1, r5
   23038:	f7f5 fd4f 	bl	18ada <_TCPIP_HEAP_Malloc>
    if(pBuff)
   2303c:	4604      	mov	r4, r0
   2303e:	b118      	cbz	r0, 23048 <_TCPIP_HEAP_Calloc+0x18>
        memset(pBuff, 0, nElems * elemSize);
   23040:	462a      	mov	r2, r5
   23042:	2100      	movs	r1, #0
   23044:	f000 ff2c 	bl	23ea0 <memset>
}
   23048:	4620      	mov	r0, r4
   2304a:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .rodata._DHCPOptWriteTbl%972:

0002304c <_DHCPOptWriteTbl>:
   2304c:	261d 0002 ddc1 0001 1fe5 0002 e2ed 0001     .&..............
   2305c:	26a1 0001 174f 0002 3ae5 0002               .&..O....:..

Disassembly of section .text.TCPIP_Helper_SingleListHeadRemove%973:

00023068 <TCPIP_Helper_SingleListHeadRemove>:
{
   23068:	4603      	mov	r3, r0
	SGL_LIST_NODE* pN = pL->head;
   2306a:	6800      	ldr	r0, [r0, #0]
    if(pN)
   2306c:	b148      	cbz	r0, 23082 <TCPIP_Helper_SingleListHeadRemove+0x1a>
        if(pL->head == pL->tail)
   2306e:	685a      	ldr	r2, [r3, #4]
   23070:	4282      	cmp	r2, r0
            pL->head = pL->tail = 0;
   23072:	bf06      	itte	eq
   23074:	2200      	moveq	r2, #0
   23076:	605a      	streq	r2, [r3, #4]
            pL->head = pN->next;
   23078:	6802      	ldrne	r2, [r0, #0]
   2307a:	601a      	str	r2, [r3, #0]
        pL->nNodes--;
   2307c:	689a      	ldr	r2, [r3, #8]
   2307e:	3a01      	subs	r2, #1
   23080:	609a      	str	r2, [r3, #8]
}
   23082:	4770      	bx	lr

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListUnlock%974:

00023084 <TCPIP_Helper_ProtectedSingleListUnlock>:

bool TCPIP_Helper_ProtectedSingleListUnlock(PROTECTED_SINGLE_LIST* pL)
{
   23084:	b508      	push	{r3, lr}
   23086:	4603      	mov	r3, r0
    if(pL->semValid)
   23088:	7c00      	ldrb	r0, [r0, #16]
   2308a:	b900      	cbnz	r0, 2308e <TCPIP_Helper_ProtectedSingleListUnlock+0xa>
    {
        return (OSAL_SEM_Post(&pL->semaphore) == OSAL_RESULT_TRUE);
    }

    return false;
}
   2308c:	bd08      	pop	{r3, pc}
        return (OSAL_SEM_Post(&pL->semaphore) == OSAL_RESULT_TRUE);
   2308e:	f103 000c 	add.w	r0, r3, #12
   23092:	f000 fb7b 	bl	2378c <OSAL_SEM_Post>
   23096:	2801      	cmp	r0, #1
   23098:	bf14      	ite	ne
   2309a:	2000      	movne	r0, #0
   2309c:	2001      	moveq	r0, #1
   2309e:	e7f5      	b.n	2308c <TCPIP_Helper_ProtectedSingleListUnlock+0x8>

Disassembly of section .text._TCPIPSignalEntryNotify%975:

000230a0 <_TCPIPSignalEntryNotify>:
{
   230a0:	b510      	push	{r4, lr}
    if((userF = pSigEntry->userSignalF) != 0)
   230a2:	6844      	ldr	r4, [r0, #4]
   230a4:	b134      	cbz	r4, 230b4 <_TCPIPSignalEntryNotify+0x14>
   230a6:	4613      	mov	r3, r2
   230a8:	460a      	mov	r2, r1
        (*userF)(pSigEntry, pSigEntry - TCPIP_STACK_MODULE_SIGNAL_TBL, signal, sigParam);
   230aa:	4903      	ldr	r1, [pc, #12]	; (230b8 <_TCPIPSignalEntryNotify+0x18>)
   230ac:	1a41      	subs	r1, r0, r1
   230ae:	f3c1 110f 	ubfx	r1, r1, #4, #16
   230b2:	47a0      	blx	r4
}
   230b4:	bd10      	pop	{r4, pc}
   230b6:	bf00      	nop
   230b8:	2000d9a4 	.word	0x2000d9a4

Disassembly of section .text.TCPIP_STACK_Status%976:

000230bc <TCPIP_STACK_Status>:
    if(object != (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data)
   230bc:	4b04      	ldr	r3, [pc, #16]	; (230d0 <TCPIP_STACK_Status+0x14>)
   230be:	4283      	cmp	r3, r0
    return tcpip_stack_status;
   230c0:	bf06      	itte	eq
   230c2:	4b04      	ldreq	r3, [pc, #16]	; (230d4 <TCPIP_STACK_Status+0x18>)
   230c4:	f993 0000 	ldrsbeq.w	r0, [r3]
        return SYS_STATUS_ERROR;
   230c8:	f04f 30ff 	movne.w	r0, #4294967295
}
   230cc:	4770      	bx	lr
   230ce:	bf00      	nop
   230d0:	2000eae4 	.word	0x2000eae4
   230d4:	2000ef8b 	.word	0x2000ef8b

Disassembly of section .text.TCPIP_STACK_NetAddressGatewaySet%977:

000230d8 <TCPIP_STACK_NetAddressGatewaySet>:
   230d8:	b150      	cbz	r0, 230f0 <TCPIP_STACK_NetAddressGatewaySet+0x18>
   230da:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   230de:	f012 0f40 	tst.w	r2, #64	; 0x40
   230e2:	d101      	bne.n	230e8 <TCPIP_STACK_NetAddressGatewaySet+0x10>
    return false;
   230e4:	2000      	movs	r0, #0
}
   230e6:	4770      	bx	lr
        pNetIf->netGateway.Val = ipAddress->Val;
   230e8:	680a      	ldr	r2, [r1, #0]
   230ea:	60c2      	str	r2, [r0, #12]
        return true;
   230ec:	2001      	movs	r0, #1
   230ee:	4770      	bx	lr
    return false;
   230f0:	2000      	movs	r0, #0
   230f2:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressDnsPrimarySet%978:

000230f4 <TCPIP_STACK_NetAddressDnsPrimarySet>:
   230f4:	4603      	mov	r3, r0
   230f6:	b138      	cbz	r0, 23108 <TCPIP_STACK_NetAddressDnsPrimarySet+0x14>
   230f8:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   230fc:	f012 0f40 	tst.w	r2, #64	; 0x40
   23100:	bf0e      	itee	eq
   23102:	2300      	moveq	r3, #0
        pNetIf->dnsServer[0].Val = ipAddress->Val;
   23104:	680a      	ldrne	r2, [r1, #0]
   23106:	6102      	strne	r2, [r0, #16]
    return pNetIf != 0;
   23108:	1c18      	adds	r0, r3, #0
   2310a:	bf18      	it	ne
   2310c:	2001      	movne	r0, #1
}
   2310e:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressDnsSecondSet%979:

00023110 <TCPIP_STACK_NetAddressDnsSecondSet>:
   23110:	b150      	cbz	r0, 23128 <TCPIP_STACK_NetAddressDnsSecondSet+0x18>
   23112:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   23116:	f012 0f40 	tst.w	r2, #64	; 0x40
   2311a:	d101      	bne.n	23120 <TCPIP_STACK_NetAddressDnsSecondSet+0x10>
    return false;
   2311c:	2000      	movs	r0, #0
}
   2311e:	4770      	bx	lr
        pNetIf->dnsServer[1].Val = ipAddress->Val;
   23120:	680a      	ldr	r2, [r1, #0]
   23122:	6142      	str	r2, [r0, #20]
        return true;
   23124:	2001      	movs	r0, #1
   23126:	4770      	bx	lr
    return false;
   23128:	2000      	movs	r0, #0
   2312a:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetIsUp%980:

0002312c <TCPIP_STACK_NetIsUp>:
   2312c:	4603      	mov	r3, r0
   2312e:	b138      	cbz	r0, 23140 <TCPIP_STACK_NetIsUp+0x14>
   23130:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   23134:	f002 0240 	and.w	r2, r2, #64	; 0x40
    return 0;
   23138:	2a00      	cmp	r2, #0
   2313a:	bf14      	ite	ne
   2313c:	4603      	movne	r3, r0
   2313e:	2300      	moveq	r3, #0
}
   23140:	1c18      	adds	r0, r3, #0
   23142:	bf18      	it	ne
   23144:	2001      	movne	r0, #1
   23146:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetMask%981:

00023148 <TCPIP_STACK_NetMask>:
{
   23148:	b508      	push	{r3, lr}
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   2314a:	b148      	cbz	r0, 23160 <TCPIP_STACK_NetMask+0x18>
   2314c:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   23150:	f012 0f40 	tst.w	r2, #64	; 0x40
   23154:	d101      	bne.n	2315a <TCPIP_STACK_NetMask+0x12>
    return 0;
   23156:	2000      	movs	r0, #0
}
   23158:	bd08      	pop	{r3, pc}
        return TCPIP_STACK_NetMaskGet(pNetIf);
   2315a:	f000 fae7 	bl	2372c <TCPIP_STACK_NetMaskGet>
   2315e:	e7fb      	b.n	23158 <TCPIP_STACK_NetMask+0x10>
    return 0;
   23160:	2000      	movs	r0, #0
   23162:	e7f9      	b.n	23158 <TCPIP_STACK_NetMask+0x10>

Disassembly of section .text.TCPIP_STACK_NetIsLinked%982:

00023164 <TCPIP_STACK_NetIsLinked>:
{
   23164:	b508      	push	{r3, lr}
   23166:	b148      	cbz	r0, 2317c <TCPIP_STACK_NetIsLinked+0x18>
   23168:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   2316c:	f012 0f40 	tst.w	r2, #64	; 0x40
   23170:	d101      	bne.n	23176 <TCPIP_STACK_NetIsLinked+0x12>
    return false;
   23172:	2000      	movs	r0, #0
}
   23174:	bd08      	pop	{r3, pc}
        return TCPIP_STACK_NetworkIsLinked(pNetIf);
   23176:	f7ff fe9f 	bl	22eb8 <TCPIP_STACK_NetworkIsLinked>
   2317a:	e7fb      	b.n	23174 <TCPIP_STACK_NetIsLinked+0x10>
    return false;
   2317c:	2000      	movs	r0, #0
   2317e:	e7f9      	b.n	23174 <TCPIP_STACK_NetIsLinked+0x10>

Disassembly of section .text.TCPIP_STACK_Deinitialize%983:

00023180 <TCPIP_STACK_Deinitialize>:
{
   23180:	b508      	push	{r3, lr}
    if(object != (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data || tcpipNetIf == 0)
   23182:	4b04      	ldr	r3, [pc, #16]	; (23194 <TCPIP_STACK_Deinitialize+0x14>)
   23184:	4283      	cmp	r3, r0
   23186:	d104      	bne.n	23192 <TCPIP_STACK_Deinitialize+0x12>
   23188:	4b03      	ldr	r3, [pc, #12]	; (23198 <TCPIP_STACK_Deinitialize+0x18>)
   2318a:	681b      	ldr	r3, [r3, #0]
   2318c:	b10b      	cbz	r3, 23192 <TCPIP_STACK_Deinitialize+0x12>
    TCPIP_STACK_KillStack();
   2318e:	f7f4 fe47 	bl	17e20 <TCPIP_STACK_KillStack>
}
   23192:	bd08      	pop	{r3, pc}
   23194:	2000eae4 	.word	0x2000eae4
   23198:	2000ee74 	.word	0x2000ee74

Disassembly of section .text._DHCPSUpdateEntry%984:

0002319c <_DHCPSUpdateEntry>:
{    
   2319c:	b510      	push	{r4, lr}
   2319e:	4604      	mov	r4, r0
     dhcpsHE->Client_Lease_Time = SYS_TMR_TickCountGet();
   231a0:	f7ff f84c 	bl	2223c <SYS_TMR_TickCountGet>
   231a4:	6060      	str	r0, [r4, #4]
     dhcpsHE->pendingTime = 0;
   231a6:	2300      	movs	r3, #0
   231a8:	60a3      	str	r3, [r4, #8]
     dhcpsHE->hEntry.flags.value &= ~DHCPS_FLAG_ENTRY_VALID_MASK;
   231aa:	8823      	ldrh	r3, [r4, #0]
   231ac:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
     dhcpsHE->hEntry.flags.value |= DHCPS_FLAG_ENTRY_COMPLETE;
   231b0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   231b4:	8023      	strh	r3, [r4, #0]
}
   231b6:	bd10      	pop	{r4, pc}

Disassembly of section .text._keyLeftProcess%985:

000231b8 <_keyLeftProcess>:
{   // left arrow
   231b8:	b508      	push	{r3, lr}
    if(pCmdIO->cmdPnt > pCmdIO->cmdBuff)
   231ba:	6983      	ldr	r3, [r0, #24]
   231bc:	f100 0220 	add.w	r2, r0, #32
   231c0:	4293      	cmp	r3, r2
   231c2:	d906      	bls.n	231d2 <_keyLeftProcess+0x1a>
    const SYS_CMD_API* pCmdApi = pCmdIO->devNode.pCmdApi;
   231c4:	6802      	ldr	r2, [r0, #0]
        pCmdIO->cmdPnt--;
   231c6:	3b01      	subs	r3, #1
   231c8:	6183      	str	r3, [r0, #24]
        (*pCmdApi->msg)(cmdIoParam, pSeqDcpt->keyCode);
   231ca:	6813      	ldr	r3, [r2, #0]
   231cc:	6809      	ldr	r1, [r1, #0]
   231ce:	6840      	ldr	r0, [r0, #4]
   231d0:	4798      	blx	r3
}
   231d2:	bd08      	pop	{r3, pc}

Disassembly of section .text.SendCommandMessage%986:

000231d4 <SendCommandMessage>:
{
   231d4:	b510      	push	{r4, lr}
   231d6:	460c      	mov	r4, r1
    SYS_CONSOLE_Write(_cmdInitData.consoleIndex, message, strlen(message));
   231d8:	4608      	mov	r0, r1
   231da:	f000 fe71 	bl	23ec0 <strlen>
   231de:	4602      	mov	r2, r0
   231e0:	4621      	mov	r1, r4
   231e2:	4b02      	ldr	r3, [pc, #8]	; (231ec <SendCommandMessage+0x18>)
   231e4:	8858      	ldrh	r0, [r3, #2]
   231e6:	f7fd fdbf 	bl	20d68 <SYS_CONSOLE_Write>
}
   231ea:	bd10      	pop	{r4, pc}
   231ec:	2000eed0 	.word	0x2000eed0

Disassembly of section .text.SYS_DEBUG_Initialize%987:

000231f0 <SYS_DEBUG_Initialize>:
    const SYS_MODULE_INIT* const init
)
{
    SYS_DEBUG_INIT* initConfig = (SYS_DEBUG_INIT*)init;

    gblErrLvl = initConfig->errorLevel;
   231f0:	784a      	ldrb	r2, [r1, #1]
   231f2:	4b04      	ldr	r3, [pc, #16]	; (23204 <SYS_DEBUG_Initialize+0x14>)
   231f4:	701a      	strb	r2, [r3, #0]

    sysDebugInstance.debugConsole = initConfig->consoleIndex;
   231f6:	4b04      	ldr	r3, [pc, #16]	; (23208 <SYS_DEBUG_Initialize+0x18>)
   231f8:	884a      	ldrh	r2, [r1, #2]
   231fa:	805a      	strh	r2, [r3, #2]
    sysDebugInstance.status = SYS_STATUS_READY;
   231fc:	2202      	movs	r2, #2
   231fe:	701a      	strb	r2, [r3, #0]

    return SYS_MODULE_OBJ_STATIC;
}
   23200:	2000      	movs	r0, #0
   23202:	4770      	bx	lr
   23204:	2000ef91 	.word	0x2000ef91
   23208:	2000eedc 	.word	0x2000eedc

Disassembly of section .text.SYS_TIME_Counter64Update%988:

0002320c <SYS_TIME_Counter64Update>:
    uint32_t prevSwCounter32Bit = counterObj->swCounter64Low;
   2320c:	4a05      	ldr	r2, [pc, #20]	; (23224 <SYS_TIME_Counter64Update+0x18>)
   2320e:	6a53      	ldr	r3, [r2, #36]	; 0x24
    newSwCounter32Bit = prevSwCounter32Bit + elapsedCount;
   23210:	4418      	add	r0, r3
    counterObj->swCounter64Low = SYS_TIME_Counter32Update(elapsedCount, &isSwCounter32Oveflow);
   23212:	6250      	str	r0, [r2, #36]	; 0x24
    if (isSwCounter32Oveflow == true)
   23214:	4283      	cmp	r3, r0
   23216:	d800      	bhi.n	2321a <SYS_TIME_Counter64Update+0xe>
}
   23218:	4770      	bx	lr
        counterObj->swCounter64High++;
   2321a:	6a93      	ldr	r3, [r2, #40]	; 0x28
   2321c:	3301      	adds	r3, #1
   2321e:	6293      	str	r3, [r2, #40]	; 0x28
}
   23220:	e7fa      	b.n	23218 <SYS_TIME_Counter64Update+0xc>
   23222:	bf00      	nop
   23224:	2000ea00 	.word	0x2000ea00

Disassembly of section .text.SYS_TIME_GetElapsedCount%989:

00023228 <SYS_TIME_GetElapsedCount>:
    if (hwTimerCurrentValue > counterObj->hwTimerPreviousValue)
   23228:	4b05      	ldr	r3, [pc, #20]	; (23240 <SYS_TIME_GetElapsedCount+0x18>)
   2322a:	691b      	ldr	r3, [r3, #16]
   2322c:	4283      	cmp	r3, r0
        elapsedCount = hwTimerCurrentValue - counterObj->hwTimerPreviousValue;
   2322e:	4b04      	ldr	r3, [pc, #16]	; (23240 <SYS_TIME_GetElapsedCount+0x18>)
   23230:	691b      	ldr	r3, [r3, #16]
   23232:	bf32      	itee	cc
   23234:	1ac0      	subcc	r0, r0, r3
        elapsedCount = (SYS_TIME_HW_COUNTER_PERIOD - counterObj->hwTimerPreviousValue) + hwTimerCurrentValue + 1;
   23236:	f5c3 3380 	rsbcs	r3, r3, #65536	; 0x10000
   2323a:	18c0      	addcs	r0, r0, r3
}
   2323c:	4770      	bx	lr
   2323e:	bf00      	nop
   23240:	2000ea00 	.word	0x2000ea00

Disassembly of section .text.SYS_TIME_MSToCount%990:

00023244 <SYS_TIME_MSToCount>:
{
   23244:	b508      	push	{r3, lr}
    return (uint32_t) (( ms * (uint64_t) gSystemCounterObj.hwTimerFrequency) / 1000);
   23246:	4b05      	ldr	r3, [pc, #20]	; (2325c <SYS_TIME_MSToCount+0x18>)
   23248:	68d9      	ldr	r1, [r3, #12]
   2324a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2324e:	2300      	movs	r3, #0
   23250:	fba1 0100 	umull	r0, r1, r1, r0
   23254:	f7fe f9c2 	bl	215dc <__aeabi_uldivmod>
}
   23258:	bd08      	pop	{r3, pc}
   2325a:	bf00      	nop
   2325c:	2000ea00 	.word	0x2000ea00

Disassembly of section .text.SYS_TMR_CallbackPeriodic%991:

00023260 <SYS_TMR_CallbackPeriodic>:
{
   23260:	b508      	push	{r3, lr}
	systemAdaptObj.callback = callback;
   23262:	4b04      	ldr	r3, [pc, #16]	; (23274 <SYS_TMR_CallbackPeriodic+0x14>)
   23264:	601a      	str	r2, [r3, #0]
	return SYS_TIME_CallbackRegisterMS((SYS_TIME_CALLBACK)sy_time_h2_adapter_callback, context, periodMs, SYS_TIME_PERIODIC );
   23266:	2301      	movs	r3, #1
   23268:	4602      	mov	r2, r0
   2326a:	4803      	ldr	r0, [pc, #12]	; (23278 <SYS_TMR_CallbackPeriodic+0x18>)
   2326c:	f7fa fea4 	bl	1dfb8 <SYS_TIME_CallbackRegisterMS>
}
   23270:	bd08      	pop	{r3, pc}
   23272:	bf00      	nop
   23274:	2000eee4 	.word	0x2000eee4
   23278:	00023df1 	.word	0x00023df1

Disassembly of section .rodata.sysTimePlibAPI%992:

0002327c <sysTimePlibAPI>:
   2327c:	00024269 00023805 0002381d 000243f1     iB...8...8...C..
   2328c:	00023b49 00023b5d 000221ed              I;..];...!..

Disassembly of section .text.vTaskPlaceOnEventList%993:

00023298 <vTaskPlaceOnEventList>:
{
   23298:	b510      	push	{r4, lr}
   2329a:	460c      	mov	r4, r1
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   2329c:	4b04      	ldr	r3, [pc, #16]	; (232b0 <vTaskPlaceOnEventList+0x18>)
   2329e:	6819      	ldr	r1, [r3, #0]
   232a0:	3118      	adds	r1, #24
   232a2:	f7fd fd95 	bl	20dd0 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   232a6:	2101      	movs	r1, #1
   232a8:	4620      	mov	r0, r4
   232aa:	f7f6 fdd5 	bl	19e58 <prvAddCurrentTaskToDelayedList>
}
   232ae:	bd10      	pop	{r4, pc}
   232b0:	2000ef00 	.word	0x2000ef00

Disassembly of section .text.pvTaskIncrementMutexHeldCount%994:

000232b4 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
   232b4:	4b05      	ldr	r3, [pc, #20]	; (232cc <pvTaskIncrementMutexHeldCount+0x18>)
   232b6:	681b      	ldr	r3, [r3, #0]
   232b8:	b123      	cbz	r3, 232c4 <pvTaskIncrementMutexHeldCount+0x10>
			( pxCurrentTCB->uxMutexesHeld )++;
   232ba:	4b04      	ldr	r3, [pc, #16]	; (232cc <pvTaskIncrementMutexHeldCount+0x18>)
   232bc:	681a      	ldr	r2, [r3, #0]
   232be:	6c93      	ldr	r3, [r2, #72]	; 0x48
   232c0:	3301      	adds	r3, #1
   232c2:	6493      	str	r3, [r2, #72]	; 0x48
		return pxCurrentTCB;
   232c4:	4b01      	ldr	r3, [pc, #4]	; (232cc <pvTaskIncrementMutexHeldCount+0x18>)
   232c6:	6818      	ldr	r0, [r3, #0]
	}
   232c8:	4770      	bx	lr
   232ca:	bf00      	nop
   232cc:	2000ef00 	.word	0x2000ef00

Disassembly of section .text.memcmp%995:

000232d0 <memcmp>:
   232d0:	b530      	push	{r4, r5, lr}
   232d2:	3901      	subs	r1, #1
   232d4:	2400      	movs	r4, #0
   232d6:	42a2      	cmp	r2, r4
   232d8:	d101      	bne.n	232de <memcmp+0xe>
   232da:	2000      	movs	r0, #0
   232dc:	e005      	b.n	232ea <memcmp+0x1a>
   232de:	5d03      	ldrb	r3, [r0, r4]
   232e0:	3401      	adds	r4, #1
   232e2:	5d0d      	ldrb	r5, [r1, r4]
   232e4:	42ab      	cmp	r3, r5
   232e6:	d0f6      	beq.n	232d6 <memcmp+0x6>
   232e8:	1b58      	subs	r0, r3, r5
   232ea:	bd30      	pop	{r4, r5, pc}

Disassembly of section .text.memcpy%996:

000232ec <memcpy>:
   232ec:	440a      	add	r2, r1
   232ee:	4291      	cmp	r1, r2
   232f0:	f100 33ff 	add.w	r3, r0, #4294967295
   232f4:	d100      	bne.n	232f8 <memcpy+0xc>
   232f6:	4770      	bx	lr
   232f8:	b510      	push	{r4, lr}
   232fa:	f811 4b01 	ldrb.w	r4, [r1], #1
   232fe:	f803 4f01 	strb.w	r4, [r3, #1]!
   23302:	4291      	cmp	r1, r2
   23304:	d1f9      	bne.n	232fa <memcpy+0xe>
   23306:	bd10      	pop	{r4, pc}

Disassembly of section .text._calloc_r%997:

00023308 <_calloc_r>:
   23308:	b538      	push	{r3, r4, r5, lr}
   2330a:	fb02 f401 	mul.w	r4, r2, r1
   2330e:	4621      	mov	r1, r4
   23310:	f7f5 f9d6 	bl	186c0 <_malloc_r>
   23314:	4605      	mov	r5, r0
   23316:	b118      	cbz	r0, 23320 <_calloc_r+0x18>
   23318:	4622      	mov	r2, r4
   2331a:	2100      	movs	r1, #0
   2331c:	f000 fdc0 	bl	23ea0 <memset>
   23320:	4628      	mov	r0, r5
   23322:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.vsnprintf%998:

00023324 <vsniprintf>:
   23324:	b507      	push	{r0, r1, r2, lr}
   23326:	9300      	str	r3, [sp, #0]
   23328:	4613      	mov	r3, r2
   2332a:	460a      	mov	r2, r1
   2332c:	4601      	mov	r1, r0
   2332e:	4803      	ldr	r0, [pc, #12]	; (2333c <vsniprintf+0x18>)
   23330:	6800      	ldr	r0, [r0, #0]
   23332:	f7fa fa61 	bl	1d7f8 <_vsniprintf_r>
   23336:	b003      	add	sp, #12
   23338:	f85d fb04 	ldr.w	pc, [sp], #4
   2333c:	2000ef60 	.word	0x2000ef60

Disassembly of section .text._fputwc_r%999:

00023340 <_fputwc_r>:
   23340:	f9b2 300c 	ldrsh.w	r3, [r2, #12]
   23344:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   23348:	d106      	bne.n	23358 <_fputwc_r+0x18>
   2334a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   2334e:	8193      	strh	r3, [r2, #12]
   23350:	6e13      	ldr	r3, [r2, #96]	; 0x60
   23352:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   23356:	6613      	str	r3, [r2, #96]	; 0x60
   23358:	f7f7 bd1b 	b.w	1ad92 <__fputwc>

Disassembly of section .text.DRV_PIC32CGMAC_SingleListTailAdd%1000:

0002335c <DRV_PIC32CGMAC_SingleListTailAdd>:
	pN->next = 0;
   2335c:	2300      	movs	r3, #0
   2335e:	600b      	str	r3, [r1, #0]
	if(pL->tail == 0)
   23360:	6843      	ldr	r3, [r0, #4]
   23362:	b12b      	cbz	r3, 23370 <DRV_PIC32CGMAC_SingleListTailAdd+0x14>
		pL->tail->next = pN;
   23364:	6019      	str	r1, [r3, #0]
		pL->tail = pN;
   23366:	6041      	str	r1, [r0, #4]
    pL->nNodes++;
   23368:	6883      	ldr	r3, [r0, #8]
   2336a:	3301      	adds	r3, #1
   2336c:	6083      	str	r3, [r0, #8]
}
   2336e:	4770      	bx	lr
		pL->head = pL->tail = pN;
   23370:	6041      	str	r1, [r0, #4]
   23372:	6001      	str	r1, [r0, #0]
   23374:	e7f8      	b.n	23368 <DRV_PIC32CGMAC_SingleListTailAdd+0xc>

Disassembly of section .text.Helper_SingleListTailAdd%1001:

00023376 <Helper_SingleListTailAdd>:
	pN->next = 0;
   23376:	2300      	movs	r3, #0
   23378:	600b      	str	r3, [r1, #0]
	if(pL->tail == 0)
   2337a:	6843      	ldr	r3, [r0, #4]
   2337c:	b12b      	cbz	r3, 2338a <Helper_SingleListTailAdd+0x14>
		pL->tail->next = pN;
   2337e:	6019      	str	r1, [r3, #0]
		pL->tail = pN;
   23380:	6041      	str	r1, [r0, #4]
    pL->nNodes++;
   23382:	6883      	ldr	r3, [r0, #8]
   23384:	3301      	adds	r3, #1
   23386:	6083      	str	r3, [r0, #8]
}
   23388:	4770      	bx	lr
		pL->head = pL->tail = pN;
   2338a:	6041      	str	r1, [r0, #4]
   2338c:	6001      	str	r1, [r0, #0]
   2338e:	e7f8      	b.n	23382 <Helper_SingleListTailAdd+0xc>

Disassembly of section .text.DRV_MIIM_Read%1002:

00023390 <DRV_MIIM_Read>:
{
   23390:	b510      	push	{r4, lr}
   23392:	b084      	sub	sp, #16
    return _DRV_MIIM_StartOp(handle, rIx, phyAdd, 0xffff, opFlags, pOpResult, DRV_MIIM_OP_READ);
   23394:	2401      	movs	r4, #1
   23396:	9402      	str	r4, [sp, #8]
   23398:	9c06      	ldr	r4, [sp, #24]
   2339a:	9401      	str	r4, [sp, #4]
   2339c:	9300      	str	r3, [sp, #0]
   2339e:	f64f 73ff 	movw	r3, #65535	; 0xffff
   233a2:	f7f4 fa9d 	bl	178e0 <_DRV_MIIM_StartOp>
}
   233a6:	b004      	add	sp, #16
   233a8:	bd10      	pop	{r4, pc}

Disassembly of section .text.DRV_MIIM_Write%1003:

000233aa <DRV_MIIM_Write>:
{
   233aa:	b510      	push	{r4, lr}
   233ac:	b084      	sub	sp, #16
    return _DRV_MIIM_StartOp(handle, rIx, phyAdd, wData, opFlags, pOpResult, DRV_MIIM_OP_WRITE);
   233ae:	2402      	movs	r4, #2
   233b0:	9402      	str	r4, [sp, #8]
   233b2:	9c07      	ldr	r4, [sp, #28]
   233b4:	9401      	str	r4, [sp, #4]
   233b6:	f89d 4018 	ldrb.w	r4, [sp, #24]
   233ba:	9400      	str	r4, [sp, #0]
   233bc:	f7f4 fa90 	bl	178e0 <_DRV_MIIM_StartOp>
}
   233c0:	b004      	add	sp, #16
   233c2:	bd10      	pop	{r4, pc}

Disassembly of section .text.DRV_MIIM_Scan%1004:

000233c4 <DRV_MIIM_Scan>:
{
   233c4:	b510      	push	{r4, lr}
   233c6:	b084      	sub	sp, #16
    return _DRV_MIIM_StartOp(handle, rIx, phyAdd, 0xffff, opFlags, pOpResult, DRV_MIIM_OP_SCAN);
   233c8:	2403      	movs	r4, #3
   233ca:	9402      	str	r4, [sp, #8]
   233cc:	9c06      	ldr	r4, [sp, #24]
   233ce:	9401      	str	r4, [sp, #4]
   233d0:	9300      	str	r3, [sp, #0]
   233d2:	f64f 73ff 	movw	r3, #65535	; 0xffff
   233d6:	f7f4 fa83 	bl	178e0 <_DRV_MIIM_StartOp>
}
   233da:	b004      	add	sp, #16
   233dc:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_TCP_ClientOpen%1005:

000233de <TCPIP_TCP_ClientOpen>:
    if(addType == IP_ADDRESS_TYPE_IPV6)
   233de:	2802      	cmp	r0, #2
   233e0:	d007      	beq.n	233f2 <TCPIP_TCP_ClientOpen+0x14>
{
   233e2:	b508      	push	{r3, lr}
   233e4:	4613      	mov	r3, r2
   233e6:	460a      	mov	r2, r1
    skt = _TCP_Open(addType, TCP_OPEN_CLIENT, remotePort, remoteAddress);
   233e8:	2101      	movs	r1, #1
   233ea:	4608      	mov	r0, r1
   233ec:	f7ea fb06 	bl	d9fc <_TCP_Open>
}
   233f0:	bd08      	pop	{r3, pc}
        return INVALID_SOCKET; 
   233f2:	f04f 30ff 	mov.w	r0, #4294967295
}
   233f6:	4770      	bx	lr

Disassembly of section .text.TCPIP_TCP_PutIsReady%1006:

000233f8 <TCPIP_TCP_PutIsReady>:
{
   233f8:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   233fa:	f7fe fd8f 	bl	21f1c <_TcpSocketChk>
    return pSkt ? _TCPIsPutReady(pSkt) : 0;
   233fe:	b120      	cbz	r0, 2340a <TCPIP_TCP_PutIsReady+0x12>
    if(pSkt->pTxPkt == 0)
   23400:	6c42      	ldr	r2, [r0, #68]	; 0x44
   23402:	b122      	cbz	r2, 2340e <TCPIP_TCP_PutIsReady+0x16>
    return _TCPSocketTxFreeSize(pSkt);
   23404:	f7fd fec2 	bl	2118c <_TCPSocketTxFreeSize>
}
   23408:	bd08      	pop	{r3, pc}
    return pSkt ? _TCPIsPutReady(pSkt) : 0;
   2340a:	2000      	movs	r0, #0
   2340c:	e7fc      	b.n	23408 <TCPIP_TCP_PutIsReady+0x10>
        return 0;
   2340e:	2000      	movs	r0, #0
   23410:	e7fa      	b.n	23408 <TCPIP_TCP_PutIsReady+0x10>

Disassembly of section .text.TCPIP_DNS_IsResolved%1007:

00023412 <TCPIP_DNS_IsResolved>:
{
   23412:	b508      	push	{r3, lr}
    if(type == IP_ADDRESS_TYPE_IPV4)
   23414:	2a01      	cmp	r2, #1
   23416:	d007      	beq.n	23428 <TCPIP_DNS_IsResolved+0x16>
    else if(type == IP_ADDRESS_TYPE_IPV6)
   23418:	2a02      	cmp	r2, #2
        hostIPv6 = &hostIP->v6Add;
   2341a:	460a      	mov	r2, r1
   2341c:	bf08      	it	eq
   2341e:	2100      	moveq	r1, #0
    return _DNS_IsNameResolved(hostName, hostIPv4, hostIPv6, true);
   23420:	2301      	movs	r3, #1
   23422:	f7f2 fe01 	bl	16028 <_DNS_IsNameResolved>
}
   23426:	bd08      	pop	{r3, pc}
        hostIPv6 = 0;
   23428:	2200      	movs	r2, #0
   2342a:	e7f9      	b.n	23420 <TCPIP_DNS_IsResolved+0xe>

Disassembly of section .text.TCPIP_Helper_SingleListTailAdd%1008:

0002342c <TCPIP_Helper_SingleListTailAdd>:
	pN->next = 0;
   2342c:	2300      	movs	r3, #0
   2342e:	600b      	str	r3, [r1, #0]
	if(pL->tail == 0)
   23430:	6843      	ldr	r3, [r0, #4]
   23432:	b12b      	cbz	r3, 23440 <TCPIP_Helper_SingleListTailAdd+0x14>
		pL->tail->next = pN;
   23434:	6019      	str	r1, [r3, #0]
		pL->tail = pN;
   23436:	6041      	str	r1, [r0, #4]
    pL->nNodes++;
   23438:	6883      	ldr	r3, [r0, #8]
   2343a:	3301      	adds	r3, #1
   2343c:	6083      	str	r3, [r0, #8]
}
   2343e:	4770      	bx	lr
		pL->head = pL->tail = pN;
   23440:	6041      	str	r1, [r0, #4]
   23442:	6001      	str	r1, [r0, #0]
   23444:	e7f8      	b.n	23438 <TCPIP_Helper_SingleListTailAdd+0xc>

Disassembly of section .text.TCPIP_Helper_SingleListAppend%1009:

00023446 <TCPIP_Helper_SingleListAppend>:
{
   23446:	b538      	push	{r3, r4, r5, lr}
   23448:	4605      	mov	r5, r0
   2344a:	460c      	mov	r4, r1
	while((pN = TCPIP_Helper_SingleListHeadRemove(pAList)))
   2344c:	4620      	mov	r0, r4
   2344e:	f7ff fe0b 	bl	23068 <TCPIP_Helper_SingleListHeadRemove>
   23452:	4601      	mov	r1, r0
   23454:	b118      	cbz	r0, 2345e <TCPIP_Helper_SingleListAppend+0x18>
		TCPIP_Helper_SingleListTailAdd(pDstL, pN);
   23456:	4628      	mov	r0, r5
   23458:	f7ff ffe8 	bl	2342c <TCPIP_Helper_SingleListTailAdd>
   2345c:	e7f6      	b.n	2344c <TCPIP_Helper_SingleListAppend+0x6>
}
   2345e:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.TCPIP_STACK_NetIsReady%1010:

00023460 <TCPIP_STACK_NetIsReady>:
{
   23460:	b508      	push	{r3, lr}
    TCPIP_NET_IF* pNetIf = _TCPIPStackHandleToNetLinked(netH);
   23462:	f7ff fbed 	bl	22c40 <_TCPIPStackHandleToNetLinked>
    if(pNetIf)
   23466:	b130      	cbz	r0, 23476 <TCPIP_STACK_NetIsReady+0x16>
        return _TCPIPStackIsConfig(pNetIf) == 0;
   23468:	f890 0043 	ldrb.w	r0, [r0, #67]	; 0x43
   2346c:	f080 0010 	eor.w	r0, r0, #16
   23470:	f3c0 1000 	ubfx	r0, r0, #4, #1
}
   23474:	bd08      	pop	{r3, pc}
    return false;
   23476:	2000      	movs	r0, #0
   23478:	e7fc      	b.n	23474 <TCPIP_STACK_NetIsReady+0x14>

Disassembly of section .text.TCPIP_Notification_RemoveAll%1011:

0002347a <TCPIP_Notification_RemoveAll>:

void TCPIP_Notification_RemoveAll(PROTECTED_SINGLE_LIST* notifyList, TCPIP_STACK_HEAP_HANDLE heapH)
{
   2347a:	b538      	push	{r3, r4, r5, lr}
   2347c:	4605      	mov	r5, r0
   2347e:	460c      	mov	r4, r1
    SGL_LIST_NODE* dNode;

    while( (dNode = TCPIP_Helper_ProtectedSingleListHeadRemove(notifyList)) != 0 )
   23480:	4628      	mov	r0, r5
   23482:	f7fe faa1 	bl	219c8 <TCPIP_Helper_ProtectedSingleListHeadRemove>
   23486:	4601      	mov	r1, r0
   23488:	b118      	cbz	r0, 23492 <TCPIP_Notification_RemoveAll+0x18>
   2348a:	68e3      	ldr	r3, [r4, #12]
   2348c:	4620      	mov	r0, r4
   2348e:	4798      	blx	r3
   23490:	e7f6      	b.n	23480 <TCPIP_Notification_RemoveAll+0x6>
    {
        TCPIP_HEAP_Free(heapH, dNode);
    }

}
   23492:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text._UDPTxPktValid%1012:

00023494 <_UDPTxPktValid>:
{
   23494:	b508      	push	{r3, lr}
    switch(pSkt->addType)
   23496:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
   23498:	2b01      	cmp	r3, #1
   2349a:	d001      	beq.n	234a0 <_UDPTxPktValid+0xc>
            return false;
   2349c:	2000      	movs	r0, #0
}
   2349e:	bd08      	pop	{r3, pc}
            return _TxSktGetLockedV4Pkt(pSkt, false) != 0;
   234a0:	2100      	movs	r1, #0
   234a2:	f7fe f9c7 	bl	21834 <_TxSktGetLockedV4Pkt>
   234a6:	3000      	adds	r0, #0
   234a8:	bf18      	it	ne
   234aa:	2001      	movne	r0, #1
   234ac:	e7f7      	b.n	2349e <_UDPTxPktValid+0xa>

Disassembly of section .text.TCPIP_UDP_TxPointerGet%1013:

000234ae <TCPIP_UDP_TxPointerGet>:
{
   234ae:	b510      	push	{r4, lr}
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   234b0:	f7fe fe4c 	bl	2214c <_UDPSocketDcpt>
    if(pSkt && _UDPTxPktValid(pSkt))
   234b4:	4604      	mov	r4, r0
   234b6:	b118      	cbz	r0, 234c0 <TCPIP_UDP_TxPointerGet+0x12>
   234b8:	f7ff ffec 	bl	23494 <_UDPTxPktValid>
   234bc:	b110      	cbz	r0, 234c4 <TCPIP_UDP_TxPointerGet+0x16>
        return pSkt->txWrite;
   234be:	68a4      	ldr	r4, [r4, #8]
}
   234c0:	4620      	mov	r0, r4
   234c2:	bd10      	pop	{r4, pc}
    return 0;
   234c4:	2400      	movs	r4, #0
   234c6:	e7fb      	b.n	234c0 <TCPIP_UDP_TxPointerGet+0x12>

Disassembly of section .text.TCPIP_DHCPS_GetDataFromUDPBuff%1014:

000234c8 <TCPIP_DHCPS_GetDataFromUDPBuff>:
    int nBytes = getbuf->endPtr - getbuf->wrPtr;
   234c8:	6843      	ldr	r3, [r0, #4]
    if(nBytes == 0)
   234ca:	6882      	ldr	r2, [r0, #8]
   234cc:	429a      	cmp	r2, r3
   234ce:	d006      	beq.n	234de <TCPIP_DHCPS_GetDataFromUDPBuff+0x16>
    *val = getbuf->wrPtr[0];
   234d0:	781b      	ldrb	r3, [r3, #0]
   234d2:	700b      	strb	r3, [r1, #0]
    getbuf->wrPtr = getbuf->wrPtr+1;    
   234d4:	6843      	ldr	r3, [r0, #4]
   234d6:	3301      	adds	r3, #1
   234d8:	6043      	str	r3, [r0, #4]
    return true;
   234da:	2001      	movs	r0, #1
   234dc:	4770      	bx	lr
        return false;
   234de:	2000      	movs	r0, #0
}
   234e0:	4770      	bx	lr

Disassembly of section .text.TCPIP_DHCPS_IsEnabled%1015:

000234e2 <TCPIP_DHCPS_IsEnabled>:
   234e2:	b148      	cbz	r0, 234f8 <TCPIP_DHCPS_IsEnabled+0x16>
   234e4:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
   234e8:	f010 0f40 	tst.w	r0, #64	; 0x40
   234ec:	d101      	bne.n	234f2 <TCPIP_DHCPS_IsEnabled+0x10>
    return false;
   234ee:	2000      	movs	r0, #0
}
   234f0:	4770      	bx	lr
        return pNetIf->Flags.bIsDHCPSrvEnabled != 0;
   234f2:	f3c0 0080 	ubfx	r0, r0, #2, #1
   234f6:	4770      	bx	lr
    return false;
   234f8:	2000      	movs	r0, #0
   234fa:	4770      	bx	lr

Disassembly of section .text.wc_InitRng%1016:

000234fc <wc_InitRng>:
{
   234fc:	b500      	push	{lr}
   234fe:	b083      	sub	sp, #12
    return _InitRng(rng, NULL, 0, NULL, INVALID_DEVID);
   23500:	f06f 0301 	mvn.w	r3, #1
   23504:	9300      	str	r3, [sp, #0]
   23506:	2300      	movs	r3, #0
   23508:	461a      	mov	r2, r3
   2350a:	4619      	mov	r1, r3
   2350c:	f7ee fd1e 	bl	11f4c <_InitRng>
}
   23510:	b003      	add	sp, #12
   23512:	f85d fb04 	ldr.w	pc, [sp], #4

Disassembly of section .text.strchr%1017:

00023516 <strchr>:
   23516:	b2c9      	uxtb	r1, r1
   23518:	4603      	mov	r3, r0
   2351a:	f810 2b01 	ldrb.w	r2, [r0], #1
   2351e:	b11a      	cbz	r2, 23528 <strchr+0x12>
   23520:	428a      	cmp	r2, r1
   23522:	d1f9      	bne.n	23518 <strchr+0x2>
   23524:	4618      	mov	r0, r3
   23526:	4770      	bx	lr
   23528:	2900      	cmp	r1, #0
   2352a:	bf18      	it	ne
   2352c:	2300      	movne	r3, #0
   2352e:	e7f9      	b.n	23524 <strchr+0xe>

Disassembly of section .text.__ascii_wctomb%1018:

00023530 <__ascii_wctomb>:
   23530:	b149      	cbz	r1, 23546 <__ascii_wctomb+0x16>
   23532:	2aff      	cmp	r2, #255	; 0xff
   23534:	bf85      	ittet	hi
   23536:	238a      	movhi	r3, #138	; 0x8a
   23538:	6003      	strhi	r3, [r0, #0]
   2353a:	700a      	strbls	r2, [r1, #0]
   2353c:	f04f 30ff 	movhi.w	r0, #4294967295
   23540:	bf98      	it	ls
   23542:	2001      	movls	r0, #1
   23544:	4770      	bx	lr
   23546:	4608      	mov	r0, r1
   23548:	4770      	bx	lr

Disassembly of section .text.CRYPT_MD5_DataAdd%1019:

0002354a <CRYPT_MD5_DataAdd>:


/* Add data to MD5 */
int CRYPT_MD5_DataAdd(CRYPT_MD5_CTX* md5, const unsigned char* input,
                      unsigned int sz)
{
   2354a:	b508      	push	{r3, lr}
    if (md5 == NULL || input == NULL)
   2354c:	b118      	cbz	r0, 23556 <CRYPT_MD5_DataAdd+0xc>
   2354e:	b129      	cbz	r1, 2355c <CRYPT_MD5_DataAdd+0x12>
        return BAD_FUNC_ARG;

    return wc_Md5Update((Md5*)md5, input, sz);
   23550:	f7f2 fa82 	bl	15a58 <wc_Md5Update>
}
   23554:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
   23556:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   2355a:	e7fb      	b.n	23554 <CRYPT_MD5_DataAdd+0xa>
   2355c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   23560:	e7f8      	b.n	23554 <CRYPT_MD5_DataAdd+0xa>

Disassembly of section .text.CRYPT_MD5_Finalize%1020:

00023562 <CRYPT_MD5_Finalize>:


/* Get MD5 Final into digest */
int CRYPT_MD5_Finalize(CRYPT_MD5_CTX* md5, unsigned char* digest)
{
   23562:	b508      	push	{r3, lr}
    if (md5 == NULL || digest == NULL)
   23564:	b118      	cbz	r0, 2356e <CRYPT_MD5_Finalize+0xc>
   23566:	b129      	cbz	r1, 23574 <CRYPT_MD5_Finalize+0x12>
        return BAD_FUNC_ARG;

    return wc_Md5Final((Md5*)md5, digest);
   23568:	f7f4 fee4 	bl	18334 <wc_Md5Final>
}
   2356c:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
   2356e:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   23572:	e7fb      	b.n	2356c <CRYPT_MD5_Finalize+0xa>
   23574:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   23578:	e7f8      	b.n	2356c <CRYPT_MD5_Finalize+0xa>

Disassembly of section .text.CRYPT_RNG_BlockGenerate%1021:

0002357a <CRYPT_RNG_BlockGenerate>:


/* RNG Block Generation of sz bytes, < 0 on error */
int CRYPT_RNG_BlockGenerate(CRYPT_RNG_CTX* rng, unsigned char* b,
                            unsigned int sz)
{
   2357a:	b508      	push	{r3, lr}
    if (rng == NULL || b == NULL)
   2357c:	b118      	cbz	r0, 23586 <CRYPT_RNG_BlockGenerate+0xc>
   2357e:	b129      	cbz	r1, 2358c <CRYPT_RNG_BlockGenerate+0x12>
        return BAD_FUNC_ARG;

#if defined(WOLFSSL_MICROCHIP_SAME70)
    return same70_RNG_GenerateBlock(b, sz);
#else
    return wc_RNG_GenerateBlock((WC_RNG*)rng, b, sz);
   23580:	f7f1 fc22 	bl	14dc8 <wc_RNG_GenerateBlock>
#endif
}
   23584:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
   23586:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   2358a:	e7fb      	b.n	23584 <CRYPT_RNG_BlockGenerate+0xa>
   2358c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   23590:	e7f8      	b.n	23584 <CRYPT_RNG_BlockGenerate+0xa>

Disassembly of section .text.DRV_ETHPHY_Deinitialize%1022:

00023594 <DRV_ETHPHY_Deinitialize>:
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   23594:	4b04      	ldr	r3, [pc, #16]	; (235a8 <DRV_ETHPHY_Deinitialize+0x14>)
   23596:	4283      	cmp	r3, r0
   23598:	d104      	bne.n	235a4 <DRV_ETHPHY_Deinitialize+0x10>
    if(phyInst != 0)
   2359a:	b118      	cbz	r0, 235a4 <DRV_ETHPHY_Deinitialize+0x10>
        phyInst->status  = SYS_STATUS_UNINITIALIZED;
   2359c:	2200      	movs	r2, #0
   2359e:	711a      	strb	r2, [r3, #4]
        phyInst->objInUse  = false;
   235a0:	701a      	strb	r2, [r3, #0]
        phyInst->pPhyObj = 0;
   235a2:	615a      	str	r2, [r3, #20]
} 
   235a4:	4770      	bx	lr
   235a6:	bf00      	nop
   235a8:	2000e7e8 	.word	0x2000e7e8

Disassembly of section .text._DRV_ETHPHY_NegCompletePhaseResultNoWait%1023:

000235ac <_DRV_ETHPHY_NegCompletePhaseResultNoWait>:
{
   235ac:	b510      	push	{r4, lr}
   235ae:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   235b0:	f7ff f990 	bl	228d4 <_DRV_PHY_SMITransfer_Wait>
   235b4:	b900      	cbnz	r0, 235b8 <_DRV_ETHPHY_NegCompletePhaseResultNoWait+0xc>
}
   235b6:	bd10      	pop	{r4, pc}
    _DRV_PHY_NegCompleteSetOperResult(hClientObj, phyBMCon.w, phyStat.w);
   235b8:	8f62      	ldrh	r2, [r4, #58]	; 0x3a
   235ba:	8ca1      	ldrh	r1, [r4, #36]	; 0x24
   235bc:	4620      	mov	r0, r4
   235be:	f7fd fd54 	bl	2106a <_DRV_PHY_NegCompleteSetOperResult>
   235c2:	e7f8      	b.n	235b6 <_DRV_ETHPHY_NegCompletePhaseResultNoWait+0xa>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase5%1024:

000235c4 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase5>:
{
   235c4:	b510      	push	{r4, lr}
   235c6:	4604      	mov	r4, r0
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   235c8:	2101      	movs	r1, #1
   235ca:	f7fd fcd1 	bl	20f70 <_DRV_PHY_SMIReadStart>
   235ce:	b900      	cbnz	r0, 235d2 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase5+0xe>
}
   235d0:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   235d2:	2303      	movs	r3, #3
   235d4:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   235d6:	2306      	movs	r3, #6
   235d8:	8423      	strh	r3, [r4, #32]
}
   235da:	e7f9      	b.n	235d0 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase5+0xc>

Disassembly of section .text._DRV_ETHPHY_LinkStatPhaseIdle%1025:

000235dc <_DRV_ETHPHY_LinkStatPhaseIdle>:
{
   235dc:	b510      	push	{r4, lr}
   235de:	4604      	mov	r4, r0
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   235e0:	2101      	movs	r1, #1
   235e2:	f7fd fcc5 	bl	20f70 <_DRV_PHY_SMIReadStart>
   235e6:	b900      	cbnz	r0, 235ea <_DRV_ETHPHY_LinkStatPhaseIdle+0xe>
}
   235e8:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   235ea:	2301      	movs	r3, #1
   235ec:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   235ee:	2300      	movs	r3, #0
   235f0:	8423      	strh	r3, [r4, #32]
}
   235f2:	e7f9      	b.n	235e8 <_DRV_ETHPHY_LinkStatPhaseIdle+0xc>

Disassembly of section .text._DRV_ETHPHY_NegCompletePhaseIdle%1026:

000235f4 <_DRV_ETHPHY_NegCompletePhaseIdle>:
{
   235f4:	b510      	push	{r4, lr}
   235f6:	4604      	mov	r4, r0
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMCON))
   235f8:	2100      	movs	r1, #0
   235fa:	f7fd fcb9 	bl	20f70 <_DRV_PHY_SMIReadStart>
   235fe:	b900      	cbnz	r0, 23602 <_DRV_ETHPHY_NegCompletePhaseIdle+0xe>
}
   23600:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   23602:	2301      	movs	r3, #1
   23604:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   23606:	2300      	movs	r3, #0
   23608:	8423      	strh	r3, [r4, #32]
}
   2360a:	e7f9      	b.n	23600 <_DRV_ETHPHY_NegCompletePhaseIdle+0xc>

Disassembly of section .text._DRV_ETHPHY_NegResultPhaseIdle%1027:

0002360c <_DRV_ETHPHY_NegResultPhaseIdle>:
{
   2360c:	b510      	push	{r4, lr}
   2360e:	4604      	mov	r4, r0
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   23610:	2101      	movs	r1, #1
   23612:	f7fd fcad 	bl	20f70 <_DRV_PHY_SMIReadStart>
   23616:	b900      	cbnz	r0, 2361a <_DRV_ETHPHY_NegResultPhaseIdle+0xe>
}
   23618:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   2361a:	2301      	movs	r3, #1
   2361c:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   2361e:	2300      	movs	r3, #0
   23620:	8423      	strh	r3, [r4, #32]
}
   23622:	e7f9      	b.n	23618 <_DRV_ETHPHY_NegResultPhaseIdle+0xc>

Disassembly of section .text._DRV_ETHPHY_NegRestartPhaseIdle%1028:

00023624 <_DRV_ETHPHY_NegRestartPhaseIdle>:
{
   23624:	b510      	push	{r4, lr}
   23626:	4604      	mov	r4, r0
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   23628:	2101      	movs	r1, #1
   2362a:	f7fd fca1 	bl	20f70 <_DRV_PHY_SMIReadStart>
   2362e:	b900      	cbnz	r0, 23632 <_DRV_ETHPHY_NegRestartPhaseIdle+0xe>
}
   23630:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   23632:	2301      	movs	r3, #1
   23634:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   23636:	2300      	movs	r3, #0
   23638:	8423      	strh	r3, [r4, #32]
}
   2363a:	e7f9      	b.n	23630 <_DRV_ETHPHY_NegRestartPhaseIdle+0xc>

Disassembly of section .rodata._DRV_PHY_NegCompletePhasesTbl%1029:

0002363c <_DRV_PHY_NegCompletePhasesTbl>:
   2363c:	35f5 0002 08e5 0002 eb61 0001 35ad 0002     .5......a....5..
   2364c:	dc1b 0001 fedb 0001                         ........

Disassembly of section .text.DRV_PIC32CGMAC_SingleListHeadAdd%1030:

00023654 <DRV_PIC32CGMAC_SingleListHeadAdd>:
	if(pN)
   23654:	b131      	cbz	r1, 23664 <DRV_PIC32CGMAC_SingleListHeadAdd+0x10>
		if(pL->head == 0)
   23656:	6802      	ldr	r2, [r0, #0]
   23658:	b12a      	cbz	r2, 23666 <DRV_PIC32CGMAC_SingleListHeadAdd+0x12>
			pN->next = pL->head;
   2365a:	600a      	str	r2, [r1, #0]
			pL->head = pN;
   2365c:	6001      	str	r1, [r0, #0]
		pL->nNodes++;
   2365e:	6883      	ldr	r3, [r0, #8]
   23660:	3301      	adds	r3, #1
   23662:	6083      	str	r3, [r0, #8]
}
   23664:	4770      	bx	lr
			pL->head = pL->tail = pN;
   23666:	6041      	str	r1, [r0, #4]
   23668:	6001      	str	r1, [r0, #0]
   2366a:	e7f8      	b.n	2365e <DRV_PIC32CGMAC_SingleListHeadAdd+0xa>

Disassembly of section .text.DRV_PIC32CGMAC_LibSysInt_Restore%1031:

0002366c <DRV_PIC32CGMAC_LibSysInt_Restore>:
    if(queMask & GMAC_QUE0_MASK)
   2366c:	f011 0f01 	tst.w	r1, #1
   23670:	d007      	beq.n	23682 <DRV_PIC32CGMAC_LibSysInt_Restore+0x16>
        if(queStat)
   23672:	b132      	cbz	r2, 23682 <DRV_PIC32CGMAC_LibSysInt_Restore+0x16>
{
   23674:	b508      	push	{r3, lr}
            SYS_INT_SourceRestore(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc, queStat[GMAC_QUE_0]); 
   23676:	7811      	ldrb	r1, [r2, #0]
   23678:	f9b0 00b6 	ldrsh.w	r0, [r0, #182]	; 0xb6
   2367c:	f7ff fb40 	bl	22d00 <SYS_INT_SourceRestore>
}
   23680:	bd08      	pop	{r3, pc}
   23682:	4770      	bx	lr

Disassembly of section .text.DRV_MIIM_Close%1032:

00023684 <DRV_MIIM_Close>:
{
   23684:	b510      	push	{r4, lr}
    DRV_MIIM_CLIENT_DCPT * pClient = _DRV_MIIM_GetClientAndLock(handle, true);
   23686:	2101      	movs	r1, #1
   23688:	f7fa ffe7 	bl	1e65a <_DRV_MIIM_GetClientAndLock>
    if(pClient != 0)
   2368c:	b128      	cbz	r0, 2369a <DRV_MIIM_Close+0x16>
   2368e:	4604      	mov	r4, r0
        _DRV_MIIM_ClientDeallocate(pClient);
   23690:	f7f4 fb0a 	bl	17ca8 <_DRV_MIIM_ClientDeallocate>
    OSAL_SEM_Post(&pMiimObj->objSem);
   23694:	6860      	ldr	r0, [r4, #4]
   23696:	f000 f879 	bl	2378c <OSAL_SEM_Post>
}
   2369a:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_ARP_HashKeyHash%1033:

0002369c <TCPIP_ARP_HashKeyHash>:
{
   2369c:	b510      	push	{r4, lr}
   2369e:	4604      	mov	r4, r0
   236a0:	4608      	mov	r0, r1
    return fnv_32_hash(key, sizeof(((ARP_HASH_ENTRY*)0)->ipAddress)) % (pOH->hEntries);
   236a2:	2104      	movs	r1, #4
   236a4:	f7fd fdd2 	bl	2124c <fnv_32_hash>
   236a8:	68e3      	ldr	r3, [r4, #12]
   236aa:	fbb0 f2f3 	udiv	r2, r0, r3
}
   236ae:	fb02 0013 	mls	r0, r2, r3, r0
   236b2:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_OAHASH_EntryRemove%1034:

000236b4 <TCPIP_OAHASH_EntryRemove>:
    if(pOE->flags.busy)
   236b4:	780b      	ldrb	r3, [r1, #0]
   236b6:	f013 0f01 	tst.w	r3, #1
   236ba:	d006      	beq.n	236ca <TCPIP_OAHASH_EntryRemove+0x16>
        pOE->flags.busy = 0;
   236bc:	780b      	ldrb	r3, [r1, #0]
   236be:	f36f 0300 	bfc	r3, #0, #1
   236c2:	700b      	strb	r3, [r1, #0]
        pOH->fullSlots--;
   236c4:	6a43      	ldr	r3, [r0, #36]	; 0x24
   236c6:	3b01      	subs	r3, #1
   236c8:	6243      	str	r3, [r0, #36]	; 0x24
}
   236ca:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressGateway%1035:

000236cc <TCPIP_STACK_NetAddressGateway>:
   236cc:	b140      	cbz	r0, 236e0 <TCPIP_STACK_NetAddressGateway+0x14>
   236ce:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   236d2:	f012 0f40 	tst.w	r2, #64	; 0x40
   236d6:	d101      	bne.n	236dc <TCPIP_STACK_NetAddressGateway+0x10>
    return 0;
   236d8:	2000      	movs	r0, #0
}
   236da:	4770      	bx	lr
        return pNetIf->netGateway.Val;
   236dc:	68c0      	ldr	r0, [r0, #12]
   236de:	4770      	bx	lr
    return 0;
   236e0:	2000      	movs	r0, #0
   236e2:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressDnsPrimary%1036:

000236e4 <TCPIP_STACK_NetAddressDnsPrimary>:
   236e4:	b140      	cbz	r0, 236f8 <TCPIP_STACK_NetAddressDnsPrimary+0x14>
   236e6:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   236ea:	f012 0f40 	tst.w	r2, #64	; 0x40
   236ee:	d101      	bne.n	236f4 <TCPIP_STACK_NetAddressDnsPrimary+0x10>
    return 0;
   236f0:	2000      	movs	r0, #0
}
   236f2:	4770      	bx	lr
        return pNetIf->dnsServer[0].Val;
   236f4:	6900      	ldr	r0, [r0, #16]
   236f6:	4770      	bx	lr
    return 0;
   236f8:	2000      	movs	r0, #0
   236fa:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressDnsSecond%1037:

000236fc <TCPIP_STACK_NetAddressDnsSecond>:
   236fc:	b140      	cbz	r0, 23710 <TCPIP_STACK_NetAddressDnsSecond+0x14>
   236fe:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   23702:	f012 0f40 	tst.w	r2, #64	; 0x40
   23706:	d101      	bne.n	2370c <TCPIP_STACK_NetAddressDnsSecond+0x10>
    return 0;
   23708:	2000      	movs	r0, #0
}
   2370a:	4770      	bx	lr
        return pNetIf->dnsServer[1].Val;
   2370c:	6940      	ldr	r0, [r0, #20]
   2370e:	4770      	bx	lr
    return 0;
   23710:	2000      	movs	r0, #0
   23712:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressGet%1038:

00023714 <TCPIP_STACK_NetAddressGet>:
   23714:	b140      	cbz	r0, 23728 <TCPIP_STACK_NetAddressGet+0x14>
   23716:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   2371a:	f012 0f40 	tst.w	r2, #64	; 0x40
   2371e:	d101      	bne.n	23724 <TCPIP_STACK_NetAddressGet+0x10>
    return 0;
   23720:	2000      	movs	r0, #0
}
   23722:	4770      	bx	lr
    return pNetIf->netIPAddr.Val;
   23724:	6840      	ldr	r0, [r0, #4]
        return _TCPIPStackNetAddress(pNetIf);
   23726:	4770      	bx	lr
    return 0;
   23728:	2000      	movs	r0, #0
   2372a:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetMaskGet%1039:

0002372c <TCPIP_STACK_NetMaskGet>:
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   2372c:	b140      	cbz	r0, 23740 <TCPIP_STACK_NetMaskGet+0x14>
   2372e:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   23732:	f012 0f40 	tst.w	r2, #64	; 0x40
   23736:	d101      	bne.n	2373c <TCPIP_STACK_NetMaskGet+0x10>
    return 0;
   23738:	2000      	movs	r0, #0
}
   2373a:	4770      	bx	lr
        return pNetIf->netMask.Val;
   2373c:	6880      	ldr	r0, [r0, #8]
   2373e:	4770      	bx	lr
    return 0;
   23740:	2000      	movs	r0, #0
   23742:	4770      	bx	lr

Disassembly of section .rodata.TCPIP_FRAME_PROCESS_TBL%1040:

00023744 <TCPIP_FRAME_PROCESS_TBL>:
   23744:	0806 0100 0002 0800 0000 0003 ffff 0000     ................
   23754:	0004 ffff 0000 0005                         ........

Disassembly of section .text.TCPIP_DHCPS_MACHashKeyHash%1041:

0002375c <TCPIP_DHCPS_MACHashKeyHash>:
{
   2375c:	b510      	push	{r4, lr}
   2375e:	4604      	mov	r4, r0
   23760:	4608      	mov	r0, r1
    return fnv_32_hash(key, DHCPS_HASH_KEY_SIZE) % (pOH->hEntries);
   23762:	2106      	movs	r1, #6
   23764:	f7fd fd72 	bl	2124c <fnv_32_hash>
   23768:	68e3      	ldr	r3, [r4, #12]
   2376a:	fbb0 f2f3 	udiv	r2, r0, r3
}
   2376e:	fb02 0013 	mls	r0, r2, r3, r0
   23772:	bd10      	pop	{r4, pc}

Disassembly of section .text.OSAL_CRIT_Enter%1042:

00023774 <OSAL_CRIT_Enter>:
{
   23774:	b508      	push	{r3, lr}
  switch (severity)
   23776:	b118      	cbz	r0, 23780 <OSAL_CRIT_Enter+0xc>
   23778:	2801      	cmp	r0, #1
   2377a:	d004      	beq.n	23786 <OSAL_CRIT_Enter+0x12>
}
   2377c:	2000      	movs	r0, #0
   2377e:	bd08      	pop	{r3, pc}
      vTaskSuspendAll();
   23780:	f000 fb5e 	bl	23e40 <vTaskSuspendAll>
      break;
   23784:	e7fa      	b.n	2377c <OSAL_CRIT_Enter+0x8>
      portENTER_CRITICAL();
   23786:	f7ff fafb 	bl	22d80 <vPortEnterCritical>
      break;
   2378a:	e7f7      	b.n	2377c <OSAL_CRIT_Enter+0x8>

Disassembly of section .text.OSAL_SEM_Post%1043:

0002378c <OSAL_SEM_Post>:
{
   2378c:	b508      	push	{r3, lr}
  if (xSemaphoreGive(*(SemaphoreHandle_t*)semID) == pdTRUE)
   2378e:	2300      	movs	r3, #0
   23790:	461a      	mov	r2, r3
   23792:	4619      	mov	r1, r3
   23794:	6800      	ldr	r0, [r0, #0]
   23796:	f7f0 fe99 	bl	144cc <xQueueGenericSend>
}
   2379a:	2801      	cmp	r0, #1
   2379c:	bf14      	ite	ne
   2379e:	2000      	movne	r0, #0
   237a0:	2001      	moveq	r0, #1
   237a2:	bd08      	pop	{r3, pc}

Disassembly of section .text.OSAL_MUTEX_Create%1044:

000237a4 <OSAL_MUTEX_Create>:
  if (*(SemaphoreHandle_t*)mutexID != NULL)
   237a4:	6803      	ldr	r3, [r0, #0]
   237a6:	b10b      	cbz	r3, 237ac <OSAL_MUTEX_Create+0x8>
    return OSAL_RESULT_FALSE;
   237a8:	2000      	movs	r0, #0
}
   237aa:	4770      	bx	lr
{
   237ac:	b510      	push	{r4, lr}
   237ae:	4604      	mov	r4, r0
  *(SemaphoreHandle_t*)mutexID = xSemaphoreCreateMutex();
   237b0:	2001      	movs	r0, #1
   237b2:	f7fe ffc9 	bl	22748 <xQueueCreateMutex>
   237b6:	6020      	str	r0, [r4, #0]
  return OSAL_RESULT_TRUE;
   237b8:	2001      	movs	r0, #1
}
   237ba:	bd10      	pop	{r4, pc}

Disassembly of section .text.OSAL_MUTEX_Unlock%1045:

000237bc <OSAL_MUTEX_Unlock>:

  Remarks:

 */
OSAL_RESULT OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE* mutexID)
{
   237bc:	b508      	push	{r3, lr}
  if (xSemaphoreGive(*(SemaphoreHandle_t*)mutexID) == pdTRUE)
   237be:	2300      	movs	r3, #0
   237c0:	461a      	mov	r2, r3
   237c2:	4619      	mov	r1, r3
   237c4:	6800      	ldr	r0, [r0, #0]
   237c6:	f7f0 fe81 	bl	144cc <xQueueGenericSend>
  {
    return OSAL_RESULT_TRUE;
  }

  return OSAL_RESULT_FALSE;
}
   237ca:	2801      	cmp	r0, #1
   237cc:	bf14      	ite	ne
   237ce:	2000      	movne	r0, #0
   237d0:	2001      	moveq	r0, #1
   237d2:	bd08      	pop	{r3, pc}

Disassembly of section .text.SERCOM1_USART_WritePendingBytesGet%1046:

000237d4 <SERCOM1_USART_WritePendingBytesGet>:
    uint32_t wrInIndex = sercom1USARTObj.wrInIndex;
   237d4:	4a04      	ldr	r2, [pc, #16]	; (237e8 <SERCOM1_USART_WritePendingBytesGet+0x14>)
   237d6:	6893      	ldr	r3, [r2, #8]
    uint32_t wrOutIndex = sercom1USARTObj.wrOutIndex;
   237d8:	68d0      	ldr	r0, [r2, #12]
    if ( wrInIndex >= wrOutIndex)
   237da:	4283      	cmp	r3, r0
        nPendingTxBytes =  (sercom1USARTObj.wrBufferSize -  wrOutIndex) + wrInIndex;
   237dc:	bf3e      	ittt	cc
   237de:	4a02      	ldrcc	r2, [pc, #8]	; (237e8 <SERCOM1_USART_WritePendingBytesGet+0x14>)
   237e0:	6912      	ldrcc	r2, [r2, #16]
   237e2:	189b      	addcc	r3, r3, r2
   237e4:	1a18      	subs	r0, r3, r0
}
   237e6:	4770      	bx	lr
   237e8:	2000e9c0 	.word	0x2000e9c0

Disassembly of section .text.SERCOM1_USART_ReadCountGet%1047:

000237ec <SERCOM1_USART_ReadCountGet>:
    rdOutIndex = sercom1USARTObj.rdOutIndex;
   237ec:	4b04      	ldr	r3, [pc, #16]	; (23800 <SERCOM1_USART_ReadCountGet+0x14>)
   237ee:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    rdInIndex = sercom1USARTObj.rdInIndex;
   237f0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    if ( rdInIndex >=  rdOutIndex)
   237f2:	4298      	cmp	r0, r3
        nUnreadBytesAvailable =  (sercom1USARTObj.rdBufferSize -  rdOutIndex) + rdInIndex;
   237f4:	bf82      	ittt	hi
   237f6:	4a02      	ldrhi	r2, [pc, #8]	; (23800 <SERCOM1_USART_ReadCountGet+0x14>)
   237f8:	6b12      	ldrhi	r2, [r2, #48]	; 0x30
   237fa:	189b      	addhi	r3, r3, r2
   237fc:	1a18      	subs	r0, r3, r0
}
   237fe:	4770      	bx	lr
   23800:	2000e9c0 	.word	0x2000e9c0

Disassembly of section .text.TC0_TimerStart%1048:

00023804 <TC0_TimerStart>:
    TC0_REGS->COUNT16.TC_CTRLA |= TC_CTRLA_ENABLE_Msk;
   23804:	4a04      	ldr	r2, [pc, #16]	; (23818 <TC0_TimerStart+0x14>)
   23806:	6813      	ldr	r3, [r2, #0]
   23808:	f043 0302 	orr.w	r3, r3, #2
   2380c:	6013      	str	r3, [r2, #0]
    while((TC0_REGS->COUNT16.TC_SYNCBUSY & TC_SYNCBUSY_ENABLE_Msk) == TC_SYNCBUSY_ENABLE_Msk)
   2380e:	6913      	ldr	r3, [r2, #16]
   23810:	f013 0f02 	tst.w	r3, #2
   23814:	d1fb      	bne.n	2380e <TC0_TimerStart+0xa>
}
   23816:	4770      	bx	lr
   23818:	40003800 	.word	0x40003800

Disassembly of section .text.TC0_TimerStop%1049:

0002381c <TC0_TimerStop>:
    TC0_REGS->COUNT16.TC_CTRLA &= ~TC_CTRLA_ENABLE_Msk;
   2381c:	4a04      	ldr	r2, [pc, #16]	; (23830 <TC0_TimerStop+0x14>)
   2381e:	6813      	ldr	r3, [r2, #0]
   23820:	f023 0302 	bic.w	r3, r3, #2
   23824:	6013      	str	r3, [r2, #0]
    while((TC0_REGS->COUNT16.TC_SYNCBUSY & TC_SYNCBUSY_ENABLE_Msk) == TC_SYNCBUSY_ENABLE_Msk)
   23826:	6913      	ldr	r3, [r2, #16]
   23828:	f013 0f02 	tst.w	r3, #2
   2382c:	d1fb      	bne.n	23826 <TC0_TimerStop+0xa>
}
   2382e:	4770      	bx	lr
   23830:	40003800 	.word	0x40003800

Disassembly of section .text._keyDownProcess%1050:

00023834 <_keyDownProcess>:
{   // down arrow
   23834:	b508      	push	{r3, lr}
    if(pCmdIO->currHistN)
   23836:	f8d0 30d4 	ldr.w	r3, [r0, #212]	; 0xd4
   2383a:	b133      	cbz	r3, 2384a <_keyDownProcess+0x16>
        pNext = pCmdIO->currHistN->prev;
   2383c:	6859      	ldr	r1, [r3, #4]
        if(pNext != pCmdIO->histList.tail)
   2383e:	f8d0 30d0 	ldr.w	r3, [r0, #208]	; 0xd0
   23842:	428b      	cmp	r3, r1
   23844:	d001      	beq.n	2384a <_keyDownProcess+0x16>
            DisplayNodeMsg(pCmdIO, pNext);
   23846:	f7f6 fabb 	bl	19dc0 <DisplayNodeMsg>
}
   2384a:	bd08      	pop	{r3, pc}

Disassembly of section .text.CommandReset%1051:

0002384c <CommandReset>:
{
   2384c:	b508      	push	{r3, lr}
    (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** System Reboot ***\r\n" );
   2384e:	6803      	ldr	r3, [r0, #0]
   23850:	681b      	ldr	r3, [r3, #0]
   23852:	4903      	ldr	r1, [pc, #12]	; (23860 <CommandReset+0x14>)
   23854:	6840      	ldr	r0, [r0, #4]
   23856:	4798      	blx	r3
    SYS_RESET_SoftwareReset();
   23858:	f7fe ff28 	bl	226ac <SYS_RESET_SoftwareReset>
}
   2385c:	bd08      	pop	{r3, pc}
   2385e:	bf00      	nop
   23860:	0000ea74 	.word	0x0000ea74

Disassembly of section .text._SYS_RANDOM_CryptoContext%1052:

00023864 <_SYS_RANDOM_CryptoContext>:
{
   23864:	b508      	push	{r3, lr}
    if(pRandCtx == 0)
   23866:	4b04      	ldr	r3, [pc, #16]	; (23878 <_SYS_RANDOM_CryptoContext+0x14>)
   23868:	681b      	ldr	r3, [r3, #0]
   2386a:	b113      	cbz	r3, 23872 <_SYS_RANDOM_CryptoContext+0xe>
} 
   2386c:	4b02      	ldr	r3, [pc, #8]	; (23878 <_SYS_RANDOM_CryptoContext+0x14>)
   2386e:	6818      	ldr	r0, [r3, #0]
   23870:	bd08      	pop	{r3, pc}
        SYS_RANDOM_CryptoInitialize();
   23872:	f7ff fa55 	bl	22d20 <SYS_RANDOM_CryptoInitialize>
   23876:	e7f9      	b.n	2386c <_SYS_RANDOM_CryptoContext+0x8>
   23878:	2000eee8 	.word	0x2000eee8

Disassembly of section .text._TCPIP_STACK_Task%1053:

0002387c <_TCPIP_STACK_Task>:
{
   2387c:	b508      	push	{r3, lr}
        TCPIP_STACK_Task(sysObj.tcpip);
   2387e:	4d04      	ldr	r5, [pc, #16]	; (23890 <_TCPIP_STACK_Task+0x14>)
        vTaskDelay(1 / portTICK_PERIOD_MS);
   23880:	2401      	movs	r4, #1
        TCPIP_STACK_Task(sysObj.tcpip);
   23882:	68a8      	ldr	r0, [r5, #8]
   23884:	f7e3 fd62 	bl	734c <TCPIP_STACK_Task>
        vTaskDelay(1 / portTICK_PERIOD_MS);
   23888:	4620      	mov	r0, r4
   2388a:	f7fd fabb 	bl	20e04 <vTaskDelay>
   2388e:	e7f8      	b.n	23882 <_TCPIP_STACK_Task+0x6>
   23890:	2000ec78 	.word	0x2000ec78

Disassembly of section .text._DRV_MIIM_Task%1054:

00023894 <_DRV_MIIM_Task>:
{
   23894:	b508      	push	{r3, lr}
        DRV_MIIM_Tasks(sysObj.drvMiim);
   23896:	4d04      	ldr	r5, [pc, #16]	; (238a8 <_DRV_MIIM_Task+0x14>)
        vTaskDelay(1 / portTICK_PERIOD_MS);
   23898:	2401      	movs	r4, #1
        DRV_MIIM_Tasks(sysObj.drvMiim);
   2389a:	68e8      	ldr	r0, [r5, #12]
   2389c:	f7ef fbce 	bl	1303c <DRV_MIIM_Tasks>
        vTaskDelay(1 / portTICK_PERIOD_MS);
   238a0:	4620      	mov	r0, r4
   238a2:	f7fd faaf 	bl	20e04 <vTaskDelay>
   238a6:	e7f8      	b.n	2389a <_DRV_MIIM_Task+0x6>
   238a8:	2000ec78 	.word	0x2000ec78

Disassembly of section .rodata.sysConsole0UARTPlibAPI%1055:

000238ac <sysConsole0UARTPlibAPI>:
   238ac:	0001b9c1 000237ed 00023b21 00018ed1     .....7..!;......
   238bc:	000243e9 00023b35                       .C..5;..

Disassembly of section .rodata.tcpipDNSClientInitData%1056:

000238c4 <tcpipDNSClientInitData>:
   238c4:	00000001 00000005 00000000 00000005     ................
   238d4:	00000001 00000001                       ........

Disassembly of section .text.vTaskInternalSetTimeOutState%1057:

000238dc <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
   238dc:	4b03      	ldr	r3, [pc, #12]	; (238ec <vTaskInternalSetTimeOutState+0x10>)
   238de:	681b      	ldr	r3, [r3, #0]
   238e0:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   238e2:	4b03      	ldr	r3, [pc, #12]	; (238f0 <vTaskInternalSetTimeOutState+0x14>)
   238e4:	681b      	ldr	r3, [r3, #0]
   238e6:	6043      	str	r3, [r0, #4]
}
   238e8:	4770      	bx	lr
   238ea:	bf00      	nop
   238ec:	2000ef28 	.word	0x2000ef28
   238f0:	2000ef34 	.word	0x2000ef34

Disassembly of section .rodata.__func__.10049%1058:

000238f4 <__func__.10049>:
   238f4:	5f786667 6f6e6f6d 6172645f 74735f77     gfx_mono_draw_st
   23904:	676e6972 00006e5f                       ring_n..

Disassembly of section .text.DRV_MIIM_ClientStatus%1059:

0002390c <DRV_MIIM_ClientStatus>:
{
   2390c:	b508      	push	{r3, lr}
    DRV_MIIM_CLIENT_DCPT * pClient = _DRV_MIIM_GetClientAndLock(handle, false);
   2390e:	2100      	movs	r1, #0
   23910:	f7fa fea3 	bl	1e65a <_DRV_MIIM_GetClientAndLock>
    if(pClient == 0)
   23914:	b110      	cbz	r0, 2391c <DRV_MIIM_ClientStatus+0x10>
    return pClient->cliStatus; 
   23916:	f990 000c 	ldrsb.w	r0, [r0, #12]
}
   2391a:	bd08      	pop	{r3, pc}
        return DRV_MIIM_CLIENT_STATUS_ERROR;
   2391c:	f04f 30ff 	mov.w	r0, #4294967295
   23920:	e7fb      	b.n	2391a <DRV_MIIM_ClientStatus+0xe>

Disassembly of section .text.TCPIP_TCP_WasDisconnected%1060:

00023922 <TCPIP_TCP_WasDisconnected>:
{
   23922:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   23924:	f7fe fafa 	bl	21f1c <_TcpSocketChk>
    if(pSkt)
   23928:	b120      	cbz	r0, 23934 <TCPIP_TCP_WasDisconnected+0x12>
        return pSkt->Flags.bRxFin != 0;
   2392a:	f890 0037 	ldrb.w	r0, [r0, #55]	; 0x37
   2392e:	f3c0 0080 	ubfx	r0, r0, #2, #1
}
   23932:	bd08      	pop	{r3, pc}
    return false;
   23934:	2000      	movs	r0, #0
   23936:	e7fc      	b.n	23932 <TCPIP_TCP_WasDisconnected+0x10>

Disassembly of section .text._IperfUDPRxSignalHandler%1061:

00023938 <_IperfUDPRxSignalHandler>:
    if(sigType == TCPIP_UDP_SIGNAL_RX_DATA)
   23938:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
   2393c:	d000      	beq.n	23940 <_IperfUDPRxSignalHandler+0x8>
   2393e:	4770      	bx	lr
{
   23940:	b508      	push	{r3, lr}
        _TCPIPStackModuleSignalRequest(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_RX_PENDING, true); 
   23942:	2201      	movs	r2, #1
   23944:	4611      	mov	r1, r2
   23946:	2020      	movs	r0, #32
   23948:	f7fa f88e 	bl	1da68 <_TCPIPStackModuleSignalRequest>
}
   2394c:	bd08      	pop	{r3, pc}

Disassembly of section .text._IperfTCPRxSignalHandler%1062:

0002394e <_IperfTCPRxSignalHandler>:
    if(sigType == TCPIP_TCP_SIGNAL_RX_DATA)
   2394e:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
   23952:	d000      	beq.n	23956 <_IperfTCPRxSignalHandler+0x8>
   23954:	4770      	bx	lr
{
   23956:	b508      	push	{r3, lr}
        _TCPIPStackModuleSignalRequest(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_RX_PENDING, true); 
   23958:	2201      	movs	r2, #1
   2395a:	4611      	mov	r1, r2
   2395c:	2020      	movs	r0, #32
   2395e:	f7fa f883 	bl	1da68 <_TCPIPStackModuleSignalRequest>
}
   23962:	bd08      	pop	{r3, pc}

Disassembly of section .text._TCPIP_HEAP_LastError%1063:

00023964 <_TCPIP_HEAP_LastError>:
    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   23964:	4603      	mov	r3, r0
   23966:	b128      	cbz	r0, 23974 <_TCPIP_HEAP_LastError+0x10>

    hDcpt = _TCPIP_HEAP_ObjDcpt(heapH);

    if(hDcpt)
    {
        res = hDcpt->_lastHeapErr;
   23968:	f990 0038 	ldrsb.w	r0, [r0, #56]	; 0x38
        hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_OK;
   2396c:	2200      	movs	r2, #0
   2396e:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
        return res;
   23972:	4770      	bx	lr
    }

    return TCPIP_STACK_HEAP_RES_NO_HEAP;
   23974:	f06f 0008 	mvn.w	r0, #8

}
   23978:	4770      	bx	lr

Disassembly of section .text._DHCPSocketRxSignalHandler%1064:

0002397a <_DHCPSocketRxSignalHandler>:
    if(sigType == TCPIP_UDP_SIGNAL_RX_DATA)
   2397a:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
   2397e:	d000      	beq.n	23982 <_DHCPSocketRxSignalHandler+0x8>
   23980:	4770      	bx	lr
{
   23982:	b508      	push	{r3, lr}
        _TCPIPStackModuleSignalRequest(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_RX_PENDING, true); 
   23984:	2201      	movs	r2, #1
   23986:	4611      	mov	r1, r2
   23988:	200c      	movs	r0, #12
   2398a:	f7fa f86d 	bl	1da68 <_TCPIPStackModuleSignalRequest>
}
   2398e:	bd08      	pop	{r3, pc}

Disassembly of section .text._DNSSocketRxSignalHandler%1065:

00023990 <_DNSSocketRxSignalHandler>:
    if(sigType == TCPIP_UDP_SIGNAL_RX_DATA)
   23990:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
   23994:	d000      	beq.n	23998 <_DNSSocketRxSignalHandler+0x8>
   23996:	4770      	bx	lr
{
   23998:	b508      	push	{r3, lr}
        _TCPIPStackModuleSignalRequest(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_RX_PENDING, true); 
   2399a:	2201      	movs	r2, #1
   2399c:	4611      	mov	r1, r2
   2399e:	200f      	movs	r0, #15
   239a0:	f7fa f862 	bl	1da68 <_TCPIPStackModuleSignalRequest>
}
   239a4:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_STACK_AddressServiceCanStart%1066:

000239a6 <TCPIP_STACK_AddressServiceCanStart>:
    if(pNetIf)
   239a6:	b138      	cbz	r0, 239b8 <TCPIP_STACK_AddressServiceCanStart+0x12>
        return (pNetIf->Flags.v & TCPIP_STACK_ADDRESS_SERVICE_MASK) == TCPIP_STACK_ADDRESS_SERVICE_NONE;
   239a8:	f8b0 3042 	ldrh.w	r3, [r0, #66]	; 0x42
   239ac:	f013 0f07 	tst.w	r3, #7
   239b0:	bf0c      	ite	eq
   239b2:	2001      	moveq	r0, #1
   239b4:	2000      	movne	r0, #0
   239b6:	4770      	bx	lr
    return false;
   239b8:	2000      	movs	r0, #0
}
   239ba:	4770      	bx	lr

Disassembly of section .text._TCPIPStackPacketTx%1067:

000239bc <_TCPIPStackPacketTx>:
    return pNetIf->hIfMac != 0 ? (*pNetIf->pMacObj->TCPIP_MAC_PacketTx)(pNetIf->hIfMac, ptrPacket) : TCPIP_MAC_RES_NOT_READY_ERR;
   239bc:	6d02      	ldr	r2, [r0, #80]	; 0x50
   239be:	b12a      	cbz	r2, 239cc <_TCPIPStackPacketTx+0x10>
{
   239c0:	b508      	push	{r3, lr}
    return pNetIf->hIfMac != 0 ? (*pNetIf->pMacObj->TCPIP_MAC_PacketTx)(pNetIf->hIfMac, ptrPacket) : TCPIP_MAC_RES_NOT_READY_ERR;
   239c2:	6c43      	ldr	r3, [r0, #68]	; 0x44
   239c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   239c6:	4610      	mov	r0, r2
   239c8:	4798      	blx	r3
}
   239ca:	bd08      	pop	{r3, pc}
    return pNetIf->hIfMac != 0 ? (*pNetIf->pMacObj->TCPIP_MAC_PacketTx)(pNetIf->hIfMac, ptrPacket) : TCPIP_MAC_RES_NOT_READY_ERR;
   239cc:	f06f 000c 	mvn.w	r0, #12
}
   239d0:	4770      	bx	lr

Disassembly of section .text.TCPIP_DHCPSSocketRxSignalHandler%1068:

000239d2 <TCPIP_DHCPSSocketRxSignalHandler>:
    if(sigType == TCPIP_UDP_SIGNAL_RX_DATA)
   239d2:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
   239d6:	d000      	beq.n	239da <TCPIP_DHCPSSocketRxSignalHandler+0x8>
   239d8:	4770      	bx	lr
{
   239da:	b508      	push	{r3, lr}
        _TCPIPStackModuleSignalRequest(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_RX_PENDING, true); 
   239dc:	2201      	movs	r2, #1
   239de:	4611      	mov	r1, r2
   239e0:	200d      	movs	r0, #13
   239e2:	f7fa f841 	bl	1da68 <_TCPIPStackModuleSignalRequest>
}
   239e6:	bd08      	pop	{r3, pc}

Disassembly of section .text.OSAL_CRIT_Leave%1069:

000239e8 <OSAL_CRIT_Leave>:
{
   239e8:	b508      	push	{r3, lr}
  switch (severity)
   239ea:	b110      	cbz	r0, 239f2 <OSAL_CRIT_Leave+0xa>
   239ec:	2801      	cmp	r0, #1
   239ee:	d003      	beq.n	239f8 <OSAL_CRIT_Leave+0x10>
}
   239f0:	bd08      	pop	{r3, pc}
      xTaskResumeAll();
   239f2:	f7f2 ff41 	bl	16878 <xTaskResumeAll>
      break;
   239f6:	e7fb      	b.n	239f0 <OSAL_CRIT_Leave+0x8>
      portEXIT_CRITICAL();
   239f8:	f000 f8e2 	bl	23bc0 <vPortExitCritical>
}
   239fc:	e7f8      	b.n	239f0 <OSAL_CRIT_Leave+0x8>

Disassembly of section .text.vListInitialise%1070:

000239fe <vListInitialise>:
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   239fe:	f100 0308 	add.w	r3, r0, #8
   23a02:	6043      	str	r3, [r0, #4]
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   23a04:	f04f 32ff 	mov.w	r2, #4294967295
   23a08:	6082      	str	r2, [r0, #8]
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   23a0a:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   23a0c:	6103      	str	r3, [r0, #16]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
   23a0e:	2300      	movs	r3, #0
   23a10:	6003      	str	r3, [r0, #0]
}
   23a12:	4770      	bx	lr

Disassembly of section .text.vListInsertEnd%1071:

00023a14 <vListInsertEnd>:
ListItem_t * const pxIndex = pxList->pxIndex;
   23a14:	6843      	ldr	r3, [r0, #4]
	pxNewListItem->pxNext = pxIndex;
   23a16:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
   23a18:	689a      	ldr	r2, [r3, #8]
   23a1a:	608a      	str	r2, [r1, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
   23a1c:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
   23a1e:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxContainer = pxList;
   23a20:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
   23a22:	6803      	ldr	r3, [r0, #0]
   23a24:	3301      	adds	r3, #1
   23a26:	6003      	str	r3, [r0, #0]
}
   23a28:	4770      	bx	lr

Disassembly of section .text.prvIsQueueEmpty%1072:

00023a2a <prvIsQueueEmpty>:
{
   23a2a:	b510      	push	{r4, lr}
   23a2c:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
   23a2e:	f7ff f9a7 	bl	22d80 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
   23a32:	6ba4      	ldr	r4, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
   23a34:	f000 f8c4 	bl	23bc0 <vPortExitCritical>
}
   23a38:	fab4 f084 	clz	r0, r4
   23a3c:	0940      	lsrs	r0, r0, #5
   23a3e:	bd10      	pop	{r4, pc}

Disassembly of section .text.xQueueCreateCountingSemaphore%1073:

00023a40 <xQueueCreateCountingSemaphore>:
	{
   23a40:	b510      	push	{r4, lr}
   23a42:	460c      	mov	r4, r1
		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
   23a44:	2202      	movs	r2, #2
   23a46:	2100      	movs	r1, #0
   23a48:	f7fd fd50 	bl	214ec <xQueueGenericCreate>
		if( xHandle != NULL )
   23a4c:	4603      	mov	r3, r0
   23a4e:	b100      	cbz	r0, 23a52 <xQueueCreateCountingSemaphore+0x12>
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
   23a50:	6384      	str	r4, [r0, #56]	; 0x38
	}
   23a52:	4618      	mov	r0, r3
   23a54:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_InitMd5%1074:

00023a56 <wc_InitMd5>:
#endif /* !HAVE_MD5_CUST_API */


int wc_InitMd5(wc_Md5* md5)
{
   23a56:	b508      	push	{r3, lr}
    if (md5 == NULL) {
   23a58:	b128      	cbz	r0, 23a66 <wc_InitMd5+0x10>
        return BAD_FUNC_ARG;
    }
    return wc_InitMd5_ex(md5, NULL, INVALID_DEVID);
   23a5a:	f06f 0201 	mvn.w	r2, #1
   23a5e:	2100      	movs	r1, #0
   23a60:	f7fc fc76 	bl	20350 <wc_InitMd5_ex>
}
   23a64:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
   23a66:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   23a6a:	e7fb      	b.n	23a64 <wc_InitMd5+0xe>

Disassembly of section .rodata._DRV_PHY_NegResultPhasesTbl%1075:

00023a6c <_DRV_PHY_NegResultPhasesTbl>:
   23a6c:	360d 0002 cbf5 0001 2381 0002 23a7 0002     .6.......#...#..
   23a7c:	6f55 0001                                   Uo..

Disassembly of section .rodata.DRV_ETHPHY_OBJECT_LAN867x%1076:

00023a80 <DRV_ETHPHY_OBJECT_LAN867x>:
   23a80:	1095 0001 4f8d 0000 4389 0002 0000 0000     .....O...C......
   23a90:	7027 0001                                   'p..

Disassembly of section .rodata._DRV_GMAC_LinkStateTbl%1077:

00023a94 <_DRV_GMAC_LinkStateTbl>:
   23a94:	1ce1 0002 f0b7 0001 d4bd 0001 f69d 0001     ................
   23aa4:	bb29 0001                                   )...

Disassembly of section .text.DRV_PIC32CGMAC_LibGetHighPrioReadyQue%1078:

00023aa8 <DRV_PIC32CGMAC_LibGetHighPrioReadyQue>:
    if(drvGmacQueEvents & GMAC_QUE0_MASK)
   23aa8:	4b03      	ldr	r3, [pc, #12]	; (23ab8 <DRV_PIC32CGMAC_LibGetHighPrioReadyQue+0x10>)
   23aaa:	6818      	ldr	r0, [r3, #0]
   23aac:	f080 0001 	eor.w	r0, r0, #1
   23ab0:	f340 0000 	sbfx	r0, r0, #0, #1
}
   23ab4:	b2c0      	uxtb	r0, r0
   23ab6:	4770      	bx	lr
   23ab8:	2000eda4 	.word	0x2000eda4

Disassembly of section .text.Ipv4DeRegisterCallback%1079:

00023abc <Ipv4DeRegisterCallback>:
    if(filtNode->active)
   23abc:	7a03      	ldrb	r3, [r0, #8]
   23abe:	b11b      	cbz	r3, 23ac8 <Ipv4DeRegisterCallback+0xc>
        ipv4ActFilterCount--;
   23ac0:	4a02      	ldr	r2, [pc, #8]	; (23acc <Ipv4DeRegisterCallback+0x10>)
   23ac2:	6813      	ldr	r3, [r2, #0]
   23ac4:	3b01      	subs	r3, #1
   23ac6:	6013      	str	r3, [r2, #0]
}
   23ac8:	4770      	bx	lr
   23aca:	bf00      	nop
   23acc:	2000ee28 	.word	0x2000ee28

Disassembly of section .text.TCPIP_HEAP_Create%1080:

00023ad0 <TCPIP_HEAP_Create>:
#if !defined(TCPIP_STACK_DRAM_DEBUG_ENABLE) 

// functions needed when debugging is not enabled

TCPIP_STACK_HEAP_HANDLE TCPIP_HEAP_Create(const TCPIP_STACK_HEAP_CONFIG* initData, TCPIP_STACK_HEAP_RES* pRes)
{
   23ad0:	b508      	push	{r3, lr}
    if(initData != 0)
   23ad2:	b118      	cbz	r0, 23adc <TCPIP_HEAP_Create+0xc>
    {
        switch (initData->heapType)
   23ad4:	7802      	ldrb	r2, [r0, #0]
   23ad6:	2a01      	cmp	r2, #1
   23ad8:	d001      	beq.n	23ade <TCPIP_HEAP_Create+0xe>
            default:
                break;
        }
    }

    return 0;
   23ada:	2000      	movs	r0, #0
}
   23adc:	bd08      	pop	{r3, pc}
                return TCPIP_HEAP_CreateInternal((const TCPIP_STACK_HEAP_INTERNAL_CONFIG*)initData, pRes);
   23ade:	f7f3 fc3d 	bl	1735c <TCPIP_HEAP_CreateInternal>
   23ae2:	e7fb      	b.n	23adc <TCPIP_HEAP_Create+0xc>

Disassembly of section .text._DHCPOptionWriteEnd%1081:

00023ae4 <_DHCPOptionWriteEnd>:
    if(pSendData->writeSpace >= sizeof(*pEnd))
   23ae4:	684b      	ldr	r3, [r1, #4]
   23ae6:	b913      	cbnz	r3, 23aee <_DHCPOptionWriteEnd+0xa>
    return -1;
   23ae8:	f04f 30ff 	mov.w	r0, #4294967295
}
   23aec:	4770      	bx	lr
        pEnd = (TCPIP_DHCP_OPTION_DATA_END*)pSendData->pOpt;
   23aee:	680b      	ldr	r3, [r1, #0]
        pEnd->opt = TCPIP_DHCP_END_OPTION;
   23af0:	22ff      	movs	r2, #255	; 0xff
   23af2:	701a      	strb	r2, [r3, #0]
        return sizeof(*pEnd);
   23af4:	2001      	movs	r0, #1
   23af6:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetUpMACAddressGet%1082:

00023af8 <TCPIP_STACK_NetUpMACAddressGet>:
   23af8:	b128      	cbz	r0, 23b06 <TCPIP_STACK_NetUpMACAddressGet+0xe>
   23afa:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   23afe:	f012 0f40 	tst.w	r2, #64	; 0x40
   23b02:	d101      	bne.n	23b08 <TCPIP_STACK_NetUpMACAddressGet+0x10>
    return 0;
   23b04:	2000      	movs	r0, #0
}
   23b06:	4770      	bx	lr
        return pNetIf->netMACAddr.v;
   23b08:	303c      	adds	r0, #60	; 0x3c
   23b0a:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_HeapHandleGet%1083:

00023b0c <TCPIP_STACK_HeapHandleGet>:
    return TCPIP_MODULE_SIGNAL_NONE; 
}

TCPIP_STACK_HEAP_HANDLE TCPIP_STACK_HeapHandleGet(TCPIP_STACK_HEAP_TYPE heapType, int heapIndex)
{
    return (heapType == tcpip_stack_ctrl_data.heapType) ? tcpip_stack_ctrl_data.memH : 0;
   23b0c:	4b03      	ldr	r3, [pc, #12]	; (23b1c <TCPIP_STACK_HeapHandleGet+0x10>)
   23b0e:	7c1b      	ldrb	r3, [r3, #16]
   23b10:	4283      	cmp	r3, r0
   23b12:	bf06      	itte	eq
   23b14:	4b01      	ldreq	r3, [pc, #4]	; (23b1c <TCPIP_STACK_HeapHandleGet+0x10>)
   23b16:	68d8      	ldreq	r0, [r3, #12]
   23b18:	2000      	movne	r0, #0
}
   23b1a:	4770      	bx	lr
   23b1c:	2000eae4 	.word	0x2000eae4

Disassembly of section .text.SERCOM1_USART_ReadFreeBufferCountGet%1084:

00023b20 <SERCOM1_USART_ReadFreeBufferCountGet>:
{
   23b20:	b510      	push	{r4, lr}
    return (sercom1USARTObj.rdBufferSize - 1U) - SERCOM1_USART_ReadCountGet();
   23b22:	4b03      	ldr	r3, [pc, #12]	; (23b30 <SERCOM1_USART_ReadFreeBufferCountGet+0x10>)
   23b24:	6b1c      	ldr	r4, [r3, #48]	; 0x30
   23b26:	f7ff fe61 	bl	237ec <SERCOM1_USART_ReadCountGet>
   23b2a:	3c01      	subs	r4, #1
}
   23b2c:	1a20      	subs	r0, r4, r0
   23b2e:	bd10      	pop	{r4, pc}
   23b30:	2000e9c0 	.word	0x2000e9c0

Disassembly of section .text.SERCOM1_USART_WriteFreeBufferCountGet%1085:

00023b34 <SERCOM1_USART_WriteFreeBufferCountGet>:
{
   23b34:	b510      	push	{r4, lr}
    return (sercom1USARTObj.wrBufferSize - 1U) - SERCOM1_USART_WriteCountGet();
   23b36:	4b03      	ldr	r3, [pc, #12]	; (23b44 <SERCOM1_USART_WriteFreeBufferCountGet+0x10>)
   23b38:	691c      	ldr	r4, [r3, #16]
    nPendingTxBytes = SERCOM1_USART_WritePendingBytesGet();
   23b3a:	f7ff fe4b 	bl	237d4 <SERCOM1_USART_WritePendingBytesGet>
    return (sercom1USARTObj.wrBufferSize - 1U) - SERCOM1_USART_WriteCountGet();
   23b3e:	3c01      	subs	r4, #1
}
   23b40:	1a20      	subs	r0, r4, r0
   23b42:	bd10      	pop	{r4, pc}
   23b44:	2000e9c0 	.word	0x2000e9c0

Disassembly of section .text.TC0_Timer16bitPeriodSet%1086:

00023b48 <TC0_Timer16bitPeriodSet>:
    TC0_REGS->COUNT16.TC_CC[0] = period;
   23b48:	4b03      	ldr	r3, [pc, #12]	; (23b58 <TC0_Timer16bitPeriodSet+0x10>)
   23b4a:	8398      	strh	r0, [r3, #28]
    while((TC0_REGS->COUNT16.TC_SYNCBUSY & TC_SYNCBUSY_CC0_Msk) == TC_SYNCBUSY_CC0_Msk)
   23b4c:	461a      	mov	r2, r3
   23b4e:	6913      	ldr	r3, [r2, #16]
   23b50:	f013 0f40 	tst.w	r3, #64	; 0x40
   23b54:	d1fb      	bne.n	23b4e <TC0_Timer16bitPeriodSet+0x6>
}
   23b56:	4770      	bx	lr
   23b58:	40003800 	.word	0x40003800

Disassembly of section .text.TC0_Timer16bitCompareSet%1087:

00023b5c <TC0_Timer16bitCompareSet>:
    TC0_REGS->COUNT16.TC_CC[1] = compare;
   23b5c:	4b03      	ldr	r3, [pc, #12]	; (23b6c <TC0_Timer16bitCompareSet+0x10>)
   23b5e:	83d8      	strh	r0, [r3, #30]
    while((TC0_REGS->COUNT16.TC_SYNCBUSY & TC_SYNCBUSY_CC1_Msk) == TC_SYNCBUSY_CC1_Msk)
   23b60:	461a      	mov	r2, r3
   23b62:	6913      	ldr	r3, [r2, #16]
   23b64:	f013 0f80 	tst.w	r3, #128	; 0x80
   23b68:	d1fb      	bne.n	23b62 <TC0_Timer16bitCompareSet+0x6>
}
   23b6a:	4770      	bx	lr
   23b6c:	40003800 	.word	0x40003800

Disassembly of section .rodata.sysConsoleApi%1088:

00023b70 <sysConsoleApi>:
   23b70:	000231d5 0001af95 000213fd 00023dd1     .1...........=..
   23b80:	00022ce1                                .,..

Disassembly of section .text.Console_UART_ResourceLock%1089:

00023b84 <Console_UART_ResourceLock>:
{
   23b84:	b508      	push	{r3, lr}
    if(OSAL_MUTEX_Lock(&(pConsoleUartData->mutexTransferObjects), OSAL_WAIT_FOREVER) == OSAL_RESULT_FALSE)
   23b86:	f64f 71ff 	movw	r1, #65535	; 0xffff
   23b8a:	3008      	adds	r0, #8
   23b8c:	f7ff f9c1 	bl	22f12 <OSAL_MUTEX_Lock>
}
   23b90:	3000      	adds	r0, #0
   23b92:	bf18      	it	ne
   23b94:	2001      	movne	r0, #1
   23b96:	bd08      	pop	{r3, pc}

Disassembly of section .rodata.tcpipDHCPSInitData%1090:

00023b98 <tcpipDHCPSInitData>:
   23b98:	0101 0000 0001 0000 000f 0000 04b0 0000     ................
   23ba8:	eb04 2000                                   ... 

Disassembly of section .text.vPortEnableVFP%1091:

00023bac <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
   23bac:	f8df 000c 	ldr.w	r0, [pc, #12]	; 23bbc <vPortEnableVFP+0x10>
   23bb0:	6801      	ldr	r1, [r0, #0]
   23bb2:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   23bb6:	6001      	str	r1, [r0, #0]
   23bb8:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
   23bba:	0000      	.short	0x0000
   23bbc:	e000ed88 	.word	0xe000ed88

Disassembly of section .text.vPortExitCritical%1092:

00023bc0 <vPortExitCritical>:
	uxCriticalNesting--;
   23bc0:	4a03      	ldr	r2, [pc, #12]	; (23bd0 <vPortExitCritical+0x10>)
   23bc2:	6813      	ldr	r3, [r2, #0]
   23bc4:	3b01      	subs	r3, #1
   23bc6:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
   23bc8:	b90b      	cbnz	r3, 23bce <vPortExitCritical+0xe>
	__asm volatile
   23bca:	f383 8811 	msr	BASEPRI, r3
}
   23bce:	4770      	bx	lr
   23bd0:	2000eef4 	.word	0x2000eef4

Disassembly of section .rodata.__func__.10030%1093:

00023bd4 <__func__.10030>:
   23bd4:	5f786667 6f6e6f6d 6172645f 68635f77     gfx_mono_draw_ch
   23be4:	00007261                                ar..

Disassembly of section .text.CRYPT_WCCB_Initialize%1094:

00023be8 <CRYPT_WCCB_Initialize>:
    }    
    return CRYPTOCB_UNAVAILABLE;
}

void CRYPT_WCCB_Initialize()
{
   23be8:	b508      	push	{r3, lr}
    wc_CryptoCb_RegisterDevice(0, CRYPT_WCCB_Callback, NULL);
   23bea:	2200      	movs	r2, #0
   23bec:	4902      	ldr	r1, [pc, #8]	; (23bf8 <CRYPT_WCCB_Initialize+0x10>)
   23bee:	4610      	mov	r0, r2
   23bf0:	f7fd fe37 	bl	21862 <wc_CryptoCb_RegisterDevice>
   23bf4:	bd08      	pop	{r3, pc}
   23bf6:	bf00      	nop
   23bf8:	00024481 	.word	0x00024481

Disassembly of section .text%1095:

00023bfc <strcmp>:
   23bfc:	f810 2b01 	ldrb.w	r2, [r0], #1
   23c00:	f811 3b01 	ldrb.w	r3, [r1], #1
   23c04:	2a01      	cmp	r2, #1
   23c06:	bf28      	it	cs
   23c08:	429a      	cmpcs	r2, r3
   23c0a:	d0f7      	beq.n	23bfc <strcmp>
   23c0c:	1ad0      	subs	r0, r2, r3
   23c0e:	4770      	bx	lr

Disassembly of section .text.strtol%1096:

00023c10 <strtol>:
   23c10:	4613      	mov	r3, r2
   23c12:	460a      	mov	r2, r1
   23c14:	4601      	mov	r1, r0
   23c16:	4802      	ldr	r0, [pc, #8]	; (23c20 <strtol+0x10>)
   23c18:	6800      	ldr	r0, [r0, #0]
   23c1a:	f7f2 bc59 	b.w	164d0 <_strtol_l.isra.0>
   23c1e:	bf00      	nop
   23c20:	2000ef60 	.word	0x2000ef60

Disassembly of section .text.CRYPT_MD5_Initialize%1097:

00023c24 <CRYPT_MD5_Initialize>:
{
   23c24:	b508      	push	{r3, lr}
    if (md5 == NULL)
   23c26:	b118      	cbz	r0, 23c30 <CRYPT_MD5_Initialize+0xc>
    wc_InitMd5((Md5*)md5);
   23c28:	f7ff ff15 	bl	23a56 <wc_InitMd5>
    return 0;
   23c2c:	2000      	movs	r0, #0
}
   23c2e:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
   23c30:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   23c34:	e7fb      	b.n	23c2e <CRYPT_MD5_Initialize+0xa>

Disassembly of section .text.TCPIP_TCP_GetIsReady%1098:

00023c36 <TCPIP_TCP_GetIsReady>:
{
   23c36:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   23c38:	f7fe f970 	bl	21f1c <_TcpSocketChk>
    if(pSkt)
   23c3c:	b110      	cbz	r0, 23c44 <TCPIP_TCP_GetIsReady+0xe>
        return _TCPIsGetReady(pSkt);
   23c3e:	f7ff f90e 	bl	22e5e <_TCPIsGetReady>
}
   23c42:	bd08      	pop	{r3, pc}
    return 0;
   23c44:	2000      	movs	r0, #0
   23c46:	e7fc      	b.n	23c42 <TCPIP_TCP_GetIsReady+0xc>

Disassembly of section .text._TCPIP_HEAP_FreeSize%1099:

00023c48 <_TCPIP_HEAP_FreeSize>:
    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   23c48:	4603      	mov	r3, r0
   23c4a:	b120      	cbz	r0, 23c56 <_TCPIP_HEAP_FreeSize+0xe>
        return (hDcpt->_heapUnits - hDcpt->_heapAllocatedUnits) * sizeof(_headNode);   
   23c4c:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   23c4e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   23c50:	1ac0      	subs	r0, r0, r3
   23c52:	0100      	lsls	r0, r0, #4
   23c54:	4770      	bx	lr
    return 0;
   23c56:	2000      	movs	r0, #0
}
   23c58:	4770      	bx	lr

Disassembly of section .text.TCPIP_OAHASH_EntryGet%1100:

00023c5a <TCPIP_OAHASH_EntryGet>:
    if(entryIx < pOH->hEntries)
   23c5a:	68c3      	ldr	r3, [r0, #12]
   23c5c:	428b      	cmp	r3, r1
        return (OA_HASH_ENTRY*)((uint8_t*)(pOH->memBlk) + entryIx * pOH->hEntrySize);
   23c5e:	bf83      	ittte	hi
   23c60:	6883      	ldrhi	r3, [r0, #8]
   23c62:	6800      	ldrhi	r0, [r0, #0]
   23c64:	fb03 0001 	mlahi	r0, r3, r1, r0
    return 0;
   23c68:	2000      	movls	r0, #0
}
   23c6a:	4770      	bx	lr

Disassembly of section .text.TCPIP_DHCPS_HashMACKeyCompare%1101:

00023c6c <TCPIP_DHCPS_HashMACKeyCompare>:
{
   23c6c:	b508      	push	{r3, lr}
   23c6e:	4613      	mov	r3, r2
    return memcmp((void*)&((DHCPS_HASH_ENTRY*)hEntry)->hwAdd, key, DHCPS_HASH_KEY_SIZE);
   23c70:	f101 0010 	add.w	r0, r1, #16
   23c74:	2206      	movs	r2, #6
   23c76:	4619      	mov	r1, r3
   23c78:	f7ff fb2a 	bl	232d0 <memcmp>
}
   23c7c:	bd08      	pop	{r3, pc}

Disassembly of section .text.OSAL_SEM_Delete%1102:

00023c7e <OSAL_SEM_Delete>:
{
   23c7e:	b510      	push	{r4, lr}
   23c80:	4604      	mov	r4, r0
  vSemaphoreDelete(*(SemaphoreHandle_t*)semID);
   23c82:	6800      	ldr	r0, [r0, #0]
   23c84:	f000 fbd4 	bl	24430 <vQueueDelete>
  *(SemaphoreHandle_t*)semID = NULL;
   23c88:	2300      	movs	r3, #0
   23c8a:	6023      	str	r3, [r4, #0]
}
   23c8c:	2001      	movs	r0, #1
   23c8e:	bd10      	pop	{r4, pc}

Disassembly of section .text.NVIC_INT_Disable%1103:

00023c90 <NVIC_INT_Disable>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   23c90:	f3ef 8010 	mrs	r0, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
   23c94:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   23c96:	f3bf 8f5f 	dmb	sy

    __disable_irq();
    __DMB();

    return processorStatus;
}
   23c9a:	fab0 f080 	clz	r0, r0
   23c9e:	0940      	lsrs	r0, r0, #5
   23ca0:	4770      	bx	lr

Disassembly of section .text.NVIC_INT_Restore%1104:

00023ca2 <NVIC_INT_Restore>:

void NVIC_INT_Restore( bool state )
{
    if( state == true )
   23ca2:	b118      	cbz	r0, 23cac <NVIC_INT_Restore+0xa>
   23ca4:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   23ca8:	b662      	cpsie	i
   23caa:	4770      	bx	lr
  __ASM volatile ("cpsid i" : : : "memory");
   23cac:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   23cae:	f3bf 8f5f 	dmb	sy
    else
    {
        __disable_irq();
        __DMB();
    }
}
   23cb2:	4770      	bx	lr

Disassembly of section .text.vApplicationStackOverflowHook%1105:

00023cb4 <vApplicationStackOverflowHook>:
	__asm volatile
   23cb4:	f04f 0320 	mov.w	r3, #32
   23cb8:	f383 8811 	msr	BASEPRI, r3
   23cbc:	f3bf 8f6f 	isb	sy
   23cc0:	f3bf 8f4f 	dsb	sy
   /* Run time task stack overflow checking is performed if
   configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook  function is
   called if a task stack overflow is detected.  Note the system/interrupt
   stack is not checked. */
   taskDISABLE_INTERRUPTS();
   for( ;; );
   23cc4:	e7fe      	b.n	23cc4 <vApplicationStackOverflowHook+0x10>

Disassembly of section .text.vApplicationMallocFailedHook%1106:

00023cc6 <vApplicationMallocFailedHook>:
   23cc6:	f04f 0320 	mov.w	r3, #32
   23cca:	f383 8811 	msr	BASEPRI, r3
   23cce:	f3bf 8f6f 	isb	sy
   23cd2:	f3bf 8f4f 	dsb	sy
      heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
      FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
      to query the size of free heap space that remains (although it does not
      provide information on how the remaining heap might be fragmented). */
   taskDISABLE_INTERRUPTS();
   for( ;; );
   23cd6:	e7fe      	b.n	23cd6 <vApplicationMallocFailedHook+0x10>

Disassembly of section .rodata%1107:

00023cd8 <.rodata%1107>:
   23cd8:	00464e49 	.word	0x00464e49
   23cdc:	00666e69 	.word	0x00666e69
   23ce0:	004e414e 	.word	0x004e414e
   23ce4:	006e616e 	.word	0x006e616e
   23ce8:	Address 0x00023ce8 is out of bounds.


Disassembly of section .text.__i2b%1108:

00023cea <__i2b>:
   23cea:	b510      	push	{r4, lr}
   23cec:	460c      	mov	r4, r1
   23cee:	2101      	movs	r1, #1
   23cf0:	f7f8 ff4c 	bl	1cb8c <_Balloc>
   23cf4:	2201      	movs	r2, #1
   23cf6:	6144      	str	r4, [r0, #20]
   23cf8:	6102      	str	r2, [r0, #16]
   23cfa:	bd10      	pop	{r4, pc}

Disassembly of section .rodata%1109:

00023cfc <.rodata%1109>:
   23cfc:	2b302d23 	.word	0x2b302d23
   23d00:	6c680020 	.word	0x6c680020
   23d04:	6665004c 	.word	0x6665004c
   23d08:	47464567 	.word	0x47464567
   23d0c:	00          	.byte	0x00
   23d0d:	23          	.byte	0x23
   23d0e:	302d      	.short	0x302d
   23d10:	6800202b 	.word	0x6800202b
   23d14:	65004c6c 	.word	0x65004c6c
   23d18:	46456766 	.word	0x46456766
   23d1c:	Address 0x00023d1c is out of bounds.


Disassembly of section .text.CRYPT_RNG_Initialize%1111:

00023d1e <CRYPT_RNG_Initialize>:
{
   23d1e:	b508      	push	{r3, lr}
    if (rng == NULL)
   23d20:	b110      	cbz	r0, 23d28 <CRYPT_RNG_Initialize+0xa>
    return wc_InitRng((WC_RNG*)rng);
   23d22:	f7ff fbeb 	bl	234fc <wc_InitRng>
}
   23d26:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
   23d28:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   23d2c:	e7fb      	b.n	23d26 <CRYPT_RNG_Initialize+0x8>

Disassembly of section .rodata._DRV_PHY_SetupPhasesTbl%1112:

00023d30 <_DRV_PHY_SetupPhasesTbl>:
   23d30:	0fd5 0002 9ac9 0001 8c31 0001 2ac1 0002     ........1....*..

Disassembly of section .text.DRV_PIC32CGMAC_LibSetInterruptSrc%1113:

00023d40 <DRV_PIC32CGMAC_LibSetInterruptSrc>:
    pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc = drvGmacIRQ[GMAC_QUE_0];    
   23d40:	4b02      	ldr	r3, [pc, #8]	; (23d4c <DRV_PIC32CGMAC_LibSetInterruptSrc+0xc>)
   23d42:	881b      	ldrh	r3, [r3, #0]
   23d44:	f8a0 30b6 	strh.w	r3, [r0, #182]	; 0xb6
}
   23d48:	4770      	bx	lr
   23d4a:	bf00      	nop
   23d4c:	2000ef74 	.word	0x2000ef74

Disassembly of section .text.TCPIP_TCP_SocketNetGet%1114:

00023d50 <TCPIP_TCP_SocketNetGet>:
{
   23d50:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   23d52:	f7fe f8e3 	bl	21f1c <_TcpSocketChk>
    if(pSkt == 0)
   23d56:	4603      	mov	r3, r0
   23d58:	b100      	cbz	r0, 23d5c <TCPIP_TCP_SocketNetGet+0xc>
    return pSkt->pSktNet;
   23d5a:	6c03      	ldr	r3, [r0, #64]	; 0x40
}
   23d5c:	4618      	mov	r0, r3
   23d5e:	bd08      	pop	{r3, pc}

Disassembly of section .rodata.heapTypeStr.14816%1115:

00023d60 <heapTypeStr.14816>:
   23d60:	0000 0000 1800 0000 180c 0000 1814 0000     ................

Disassembly of section .text.TCPIP_DNS_GetIPv4Addresses%1116:

00023d70 <TCPIP_DNS_GetIPv4Addresses>:
{
   23d70:	b510      	push	{r4, lr}
   23d72:	b082      	sub	sp, #8
    return _DNS_GetAddresses(hostName, startIndex, (IP_MULTI_ADDRESS*)pIPv4Addr, nIPv4Addresses, TCPIP_DNS_ADDRESS_REC_IPV4);
   23d74:	2401      	movs	r4, #1
   23d76:	9400      	str	r4, [sp, #0]
   23d78:	f7f2 fb34 	bl	163e4 <_DNS_GetAddresses>
}
   23d7c:	b002      	add	sp, #8
   23d7e:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_DNS_GetIPv6Addresses%1117:

00023d80 <TCPIP_DNS_GetIPv6Addresses>:
{
   23d80:	b510      	push	{r4, lr}
   23d82:	b082      	sub	sp, #8
    return _DNS_GetAddresses(hostName, startIndex, (IP_MULTI_ADDRESS*)pIPv6Addr, nIPv6Addresses, TCPIP_DNS_ADDRESS_REC_IPV6);
   23d84:	2402      	movs	r4, #2
   23d86:	9400      	str	r4, [sp, #0]
   23d88:	f7f2 fb2c 	bl	163e4 <_DNS_GetAddresses>
}
   23d8c:	b002      	add	sp, #8
   23d8e:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_Notification_Deinitialize%1118:

00023d90 <TCPIP_Notification_Deinitialize>:
{
   23d90:	b510      	push	{r4, lr}
   23d92:	4604      	mov	r4, r0
    TCPIP_Notification_RemoveAll(notifyList, heapH);
   23d94:	f7ff fb71 	bl	2347a <TCPIP_Notification_RemoveAll>
    TCPIP_Helper_ProtectedSingleListDeinitialize(notifyList);
   23d98:	4620      	mov	r0, r4
   23d9a:	f7fd fa9f 	bl	212dc <TCPIP_Helper_ProtectedSingleListDeinitialize>
}
   23d9e:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_UDP_SocketNetGet%1119:

00023da0 <TCPIP_UDP_SocketNetGet>:
{
   23da0:	b508      	push	{r3, lr}
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   23da2:	f7fe f9d3 	bl	2214c <_UDPSocketDcpt>
    return pSkt?pSkt->pSktNet:0;
   23da6:	4603      	mov	r3, r0
   23da8:	b100      	cbz	r0, 23dac <TCPIP_UDP_SocketNetGet+0xc>
   23daa:	6a43      	ldr	r3, [r0, #36]	; 0x24
}
   23dac:	4618      	mov	r0, r3
   23dae:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_DHCPS_DataCopyToProcessBuffer%1120:

00023db0 <TCPIP_DHCPS_DataCopyToProcessBuffer>:
    if(putBuf->wrPtr < putBuf->endPtr)
   23db0:	684b      	ldr	r3, [r1, #4]
   23db2:	688a      	ldr	r2, [r1, #8]
   23db4:	4293      	cmp	r3, r2
   23db6:	d202      	bcs.n	23dbe <TCPIP_DHCPS_DataCopyToProcessBuffer+0xe>
        *putBuf->wrPtr++ = val;
   23db8:	1c5a      	adds	r2, r3, #1
   23dba:	604a      	str	r2, [r1, #4]
   23dbc:	7018      	strb	r0, [r3, #0]
}
   23dbe:	4770      	bx	lr

Disassembly of section .text.NVMCTRL_Initialize%1121:

00023dc0 <NVMCTRL_Initialize>:



void NVMCTRL_Initialize(void)
{
   NVMCTRL_REGS->NVMCTRL_CTRLA = NVMCTRL_CTRLA_RWS(5) | NVMCTRL_CTRLA_AUTOWS_Msk;    
   23dc0:	4b02      	ldr	r3, [pc, #8]	; (23dcc <NVMCTRL_Initialize+0xc>)
   23dc2:	f240 5204 	movw	r2, #1284	; 0x504
   23dc6:	801a      	strh	r2, [r3, #0]
}
   23dc8:	4770      	bx	lr
   23dca:	bf00      	nop
   23dcc:	41004000 	.word	0x41004000

Disassembly of section .text.IsCommandReady%1122:

00023dd0 <IsCommandReady>:
{
   23dd0:	b508      	push	{r3, lr}
    return (int)SYS_CONSOLE_ReadCountGet(_cmdInitData.consoleIndex);
   23dd2:	4b02      	ldr	r3, [pc, #8]	; (23ddc <IsCommandReady+0xc>)
   23dd4:	8858      	ldrh	r0, [r3, #2]
   23dd6:	f7fc ffad 	bl	20d34 <SYS_CONSOLE_ReadCountGet>
}
   23dda:	bd08      	pop	{r3, pc}
   23ddc:	2000eed0 	.word	0x2000eed0

Disassembly of section .text.Console_UART_Status%1123:

00023de0 <Console_UART_Status>:
    return true;
}

SYS_CONSOLE_STATUS Console_UART_Status(uint32_t index)
{
    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   23de0:	b910      	cbnz	r0, 23de8 <Console_UART_Status+0x8>
    {
        return SYS_CONSOLE_STATUS_ERROR;
    }
    else
    {
        return pConsoleUartData->status;
   23de2:	4b02      	ldr	r3, [pc, #8]	; (23dec <Console_UART_Status+0xc>)
   23de4:	7918      	ldrb	r0, [r3, #4]
   23de6:	4770      	bx	lr
        return SYS_CONSOLE_STATUS_ERROR;
   23de8:	2003      	movs	r0, #3
    }
}
   23dea:	4770      	bx	lr
   23dec:	2000ed58 	.word	0x2000ed58

Disassembly of section .text.sy_time_h2_adapter_callback%1124:

00023df0 <sy_time_h2_adapter_callback>:
{
   23df0:	b508      	push	{r3, lr}
	systemAdaptObj.callback(context,0);
   23df2:	4b02      	ldr	r3, [pc, #8]	; (23dfc <sy_time_h2_adapter_callback+0xc>)
   23df4:	681b      	ldr	r3, [r3, #0]
   23df6:	2100      	movs	r1, #0
   23df8:	4798      	blx	r3
}
   23dfa:	bd08      	pop	{r3, pc}
   23dfc:	2000eee4 	.word	0x2000eee4

Disassembly of section .text._APP_Tasks%1125:

00023e00 <_APP_Tasks>:
{   
   23e00:	b508      	push	{r3, lr}
        vTaskDelay(2 / portTICK_PERIOD_MS);
   23e02:	2402      	movs	r4, #2
        APP_Tasks();
   23e04:	f7e6 fb74 	bl	a4f0 <APP_Tasks>
        vTaskDelay(2 / portTICK_PERIOD_MS);
   23e08:	4620      	mov	r0, r4
   23e0a:	f7fc fffb 	bl	20e04 <vTaskDelay>
   23e0e:	e7f9      	b.n	23e04 <_APP_Tasks+0x4>

Disassembly of section .text._SYS_CMD_Tasks%1126:

00023e10 <_SYS_CMD_Tasks>:
{
   23e10:	b508      	push	{r3, lr}
        vTaskDelay(10 / portTICK_PERIOD_MS);
   23e12:	240a      	movs	r4, #10
        SYS_CMD_Tasks();
   23e14:	f7e5 ff48 	bl	9ca8 <SYS_CMD_Tasks>
        vTaskDelay(10 / portTICK_PERIOD_MS);
   23e18:	4620      	mov	r0, r4
   23e1a:	f7fc fff3 	bl	20e04 <vTaskDelay>
   23e1e:	e7f9      	b.n	23e14 <_SYS_CMD_Tasks+0x4>

Disassembly of section .rodata.tcpipDHCPInitData%1127:

00023e20 <tcpipDHCPInitData>:
   23e20:	0000 0000 000a 0000 0044 0000 0043 0000     ........D...C...

Disassembly of section .rodata.tcpipIPv4InitData%1128:

00023e30 <tcpipIPv4InitData>:
   23e30:	000a 0000 0000 0000 0000 0000 0000 0000     ................

Disassembly of section .text.vTaskSuspendAll%1129:

00023e40 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
   23e40:	4a02      	ldr	r2, [pc, #8]	; (23e4c <vTaskSuspendAll+0xc>)
   23e42:	6813      	ldr	r3, [r2, #0]
   23e44:	3301      	adds	r3, #1
   23e46:	6013      	str	r3, [r2, #0]
}
   23e48:	4770      	bx	lr
   23e4a:	bf00      	nop
   23e4c:	2000ef14 	.word	0x2000ef14

Disassembly of section .text.gfx_mono_framebuffer_get_byte%1130:

00023e50 <gfx_mono_framebuffer_get_byte>:
 * \code
    data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column) {
    return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
   23e50:	4b02      	ldr	r3, [pc, #8]	; (23e5c <gfx_mono_framebuffer_get_byte+0xc>)
   23e52:	681b      	ldr	r3, [r3, #0]
   23e54:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
}
   23e58:	5c40      	ldrb	r0, [r0, r1]
   23e5a:	4770      	bx	lr
   23e5c:	2000ef3c 	.word	0x2000ef3c

Disassembly of section .text.Read_Phy_Register%1131:

00023e60 <Read_Phy_Register>:
{
   23e60:	b510      	push	{r4, lr}
   23e62:	4614      	mov	r4, r2
	clientObj->phyAddress = phyAddress;
   23e64:	6001      	str	r1, [r0, #0]
	return Lan867x_Read_Register(clientObj, regAddr, rData);
   23e66:	461a      	mov	r2, r3
   23e68:	4621      	mov	r1, r4
   23e6a:	f7fc f854 	bl	1ff16 <Lan867x_Read_Register>
}
   23e6e:	bd10      	pop	{r4, pc}

Disassembly of section .text.calloc%1132:

00023e70 <calloc>:
   23e70:	4b02      	ldr	r3, [pc, #8]	; (23e7c <calloc+0xc>)
   23e72:	460a      	mov	r2, r1
   23e74:	4601      	mov	r1, r0
   23e76:	6818      	ldr	r0, [r3, #0]
   23e78:	f7ff ba46 	b.w	23308 <_calloc_r>
   23e7c:	2000ef60 	.word	0x2000ef60

Disassembly of section .text.malloc%1133:

00023e80 <malloc>:
   23e80:	4b02      	ldr	r3, [pc, #8]	; (23e8c <malloc+0xc>)
   23e82:	4601      	mov	r1, r0
   23e84:	6818      	ldr	r0, [r3, #0]
   23e86:	f7f4 bc1b 	b.w	186c0 <_malloc_r>
   23e8a:	bf00      	nop
   23e8c:	2000ef60 	.word	0x2000ef60

Disassembly of section .text.free%1134:

00023e90 <free>:
   23e90:	4b02      	ldr	r3, [pc, #8]	; (23e9c <free+0xc>)
   23e92:	4601      	mov	r1, r0
   23e94:	6818      	ldr	r0, [r3, #0]
   23e96:	f7f5 bd2d 	b.w	198f4 <_free_r>
   23e9a:	bf00      	nop
   23e9c:	2000ef60 	.word	0x2000ef60

Disassembly of section .text.memset%1135:

00023ea0 <memset>:
   23ea0:	4402      	add	r2, r0
   23ea2:	4603      	mov	r3, r0
   23ea4:	4293      	cmp	r3, r2
   23ea6:	d100      	bne.n	23eaa <memset+0xa>
   23ea8:	4770      	bx	lr
   23eaa:	f803 1b01 	strb.w	r1, [r3], #1
   23eae:	e7f9      	b.n	23ea4 <memset+0x4>

Disassembly of section .text.strcpy%1136:

00023eb0 <strcpy>:
   23eb0:	4603      	mov	r3, r0
   23eb2:	f811 2b01 	ldrb.w	r2, [r1], #1
   23eb6:	f803 2b01 	strb.w	r2, [r3], #1
   23eba:	2a00      	cmp	r2, #0
   23ebc:	d1f9      	bne.n	23eb2 <strcpy+0x2>
   23ebe:	4770      	bx	lr

Disassembly of section .text%1137:

00023ec0 <strlen>:
   23ec0:	4603      	mov	r3, r0
   23ec2:	f813 2b01 	ldrb.w	r2, [r3], #1
   23ec6:	2a00      	cmp	r2, #0
   23ec8:	d1fb      	bne.n	23ec2 <strlen+0x2>
   23eca:	1a18      	subs	r0, r3, r0
   23ecc:	3801      	subs	r0, #1
   23ece:	4770      	bx	lr

Disassembly of section .text.raise%1138:

00023ed0 <raise>:
   23ed0:	4b02      	ldr	r3, [pc, #8]	; (23edc <raise+0xc>)
   23ed2:	4601      	mov	r1, r0
   23ed4:	6818      	ldr	r0, [r3, #0]
   23ed6:	f7fa bb49 	b.w	1e56c <_raise_r>
   23eda:	bf00      	nop
   23edc:	2000ef60 	.word	0x2000ef60

Disassembly of section .text._malloc_usable_size_r%1139:

00023ee0 <_malloc_usable_size_r>:
   23ee0:	f851 3c04 	ldr.w	r3, [r1, #-4]
   23ee4:	1f18      	subs	r0, r3, #4
   23ee6:	2b00      	cmp	r3, #0
   23ee8:	bfbc      	itt	lt
   23eea:	580b      	ldrlt	r3, [r1, r0]
   23eec:	18c0      	addlt	r0, r0, r3
   23eee:	4770      	bx	lr

Disassembly of section .rodata%1140:

00023ef0 <.rodata%1140>:
   23ef0:	69666e49 	.word	0x69666e49
   23ef4:	7974696e 	.word	0x7974696e
   23ef8:	4e614e00 	.word	0x4e614e00
   23efc:	Address 0x00023efc is out of bounds.


Disassembly of section .text.DRV_PIC32CGMAC_LibSetPriorityToQueueNum%1141:

00023f00 <DRV_PIC32CGMAC_LibSetPriorityToQueueNum>:
    pMACDrv->sGmacData.gmacConfig.txPrioNumToQueIndx[0] = GMAC_QUE_0;
   23f00:	2300      	movs	r3, #0
   23f02:	f880 30e3 	strb.w	r3, [r0, #227]	; 0xe3
    pMACDrv->sGmacData.gmacConfig.rxPrioNumToQueIndx[0] = GMAC_QUE_0;    
   23f06:	f880 30e5 	strb.w	r3, [r0, #229]	; 0xe5
}
   23f0a:	2001      	movs	r0, #1
   23f0c:	4770      	bx	lr

Disassembly of section .text.btohexa_low%1142:

00023f0e <btohexa_low>:
  Returns:
  	The lower hexadecimal ASCII byte '0'-'9' or 'a'-'f'.
  ***************************************************************************/
uint8_t btohexa_low(uint8_t b)
{
	b &= 0x0F;
   23f0e:	f000 000f 	and.w	r0, r0, #15
	return (b>9u) ? b+'a'-10:b+'0';
   23f12:	2809      	cmp	r0, #9
   23f14:	bf8c      	ite	hi
   23f16:	3057      	addhi	r0, #87	; 0x57
   23f18:	3030      	addls	r0, #48	; 0x30
}
   23f1a:	4770      	bx	lr

Disassembly of section .text.TCPIP_Helper_ChecksumFold%1143:

00023f1c <TCPIP_Helper_ChecksumFold>:
    checksum.Val = (uint32_t)checksum.w[0] + (uint32_t)checksum.w[1];
   23f1c:	b283      	uxth	r3, r0
   23f1e:	eb03 4010 	add.w	r0, r3, r0, lsr #16
    checksum.w[0] += checksum.w[1];
   23f22:	eb00 4010 	add.w	r0, r0, r0, lsr #16
}
   23f26:	b280      	uxth	r0, r0
   23f28:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetIndexGet%1144:

00023f2a <TCPIP_STACK_NetIndexGet>:
    if(pNetIf)
   23f2a:	b110      	cbz	r0, 23f32 <TCPIP_STACK_NetIndexGet+0x8>
        return pNetIf->netIfIx;
   23f2c:	f8b0 0058 	ldrh.w	r0, [r0, #88]	; 0x58
   23f30:	4770      	bx	lr
    return -1;
   23f32:	f04f 30ff 	mov.w	r0, #4294967295
}
   23f36:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetIxGet%1145:

00023f38 <TCPIP_STACK_NetIxGet>:
    if(pNetIf)
   23f38:	b110      	cbz	r0, 23f40 <TCPIP_STACK_NetIxGet+0x8>
        return pNetIf->netIfIx;
   23f3a:	f8b0 0058 	ldrh.w	r0, [r0, #88]	; 0x58
   23f3e:	4770      	bx	lr
    return -1;
   23f40:	f04f 30ff 	mov.w	r0, #4294967295
}
   23f44:	4770      	bx	lr

Disassembly of section .text._TCPIPStackSignalHandlerDeregister%1146:

00023f46 <_TCPIPStackSignalHandlerDeregister>:
    if((pSignalEntry = (TCPIP_MODULE_SIGNAL_ENTRY*)handle) != 0)
   23f46:	b120      	cbz	r0, 23f52 <_TCPIPStackSignalHandlerDeregister+0xc>
        memset(pSignalEntry, 0x0, sizeof(*pSignalEntry));
   23f48:	2200      	movs	r2, #0
   23f4a:	6002      	str	r2, [r0, #0]
   23f4c:	6042      	str	r2, [r0, #4]
   23f4e:	6082      	str	r2, [r0, #8]
   23f50:	60c2      	str	r2, [r0, #12]
}
   23f52:	4770      	bx	lr

Disassembly of section .text._DHCPSRemoveCacheEntries%1147:

00023f54 <_DHCPSRemoveCacheEntries>:
    if(pDHCPSHashDcpt->hashDcpt)
   23f54:	6800      	ldr	r0, [r0, #0]
   23f56:	b118      	cbz	r0, 23f60 <_DHCPSRemoveCacheEntries+0xc>
{
   23f58:	b508      	push	{r3, lr}
        TCPIP_OAHASH_EntriesRemoveAll(pDHCPSHashDcpt->hashDcpt);
   23f5a:	f7fd f98f 	bl	2127c <TCPIP_OAHASH_EntriesRemoveAll>
}
   23f5e:	bd08      	pop	{r3, pc}
   23f60:	4770      	bx	lr

Disassembly of section .text.main%1148:

00023f62 <main>:
// Section: Main Entry Point
// *****************************************************************************
// *****************************************************************************

int main ( void )
{
   23f62:	b508      	push	{r3, lr}
    /* Initialize all modules */
    SYS_Initialize ( NULL );
   23f64:	2000      	movs	r0, #0
   23f66:	f7f7 facd 	bl	1b504 <SYS_Initialize>

    while ( true )
    {
        /* Maintain state machines of all polled MPLAB Harmony modules. */
        SYS_Tasks ( );
   23f6a:	f7f7 fa8d 	bl	1b488 <SYS_Tasks>
   23f6e:	e7fc      	b.n	23f6a <main+0x8>

Disassembly of section .text.abort%1149:

00023f70 <abort>:
   23f70:	b508      	push	{r3, lr}
   23f72:	2006      	movs	r0, #6
   23f74:	f7ff ffac 	bl	23ed0 <raise>
   23f78:	2001      	movs	r0, #1
   23f7a:	f7f8 fc66 	bl	1c84a <_exit>

Disassembly of section .rodata._DRV_PHY_LinkStatPhasesTbl%1150:

000226f4 <_DRV_PHY_LinkStatPhasesTbl>:
   226f4:	35dd 0002 e745 0001 1971 0002               .5..E...q...

Disassembly of section .rodata._DRV_PHY_NegRestartPhasesTbl%1151:

00023f80 <_DRV_PHY_NegRestartPhasesTbl>:
   23f80:	3625 0002 043f 0002 4305 0002               %6..?....C..

Disassembly of section .rodata._DRV_PHY_ResetPhasesTbl%1152:

00023f8c <_DRV_PHY_ResetPhasesTbl>:
   23f8c:	2f4f 0002 f8a5 0001 cc59 0001               O/......Y...

Disassembly of section .text._DRV_GMAC_GetTxOctetLow%1153:

00023f98 <_DRV_GMAC_GetTxOctetLow>:
	return GMAC_REGS->GMAC_OTLO;	
   23f98:	4b01      	ldr	r3, [pc, #4]	; (23fa0 <_DRV_GMAC_GetTxOctetLow+0x8>)
   23f9a:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
}
   23f9e:	4770      	bx	lr
   23fa0:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxOctetHigh%1154:

00023fa4 <_DRV_GMAC_GetTxOctetHigh>:
	return GMAC_REGS->GMAC_OTHI;
   23fa4:	4b01      	ldr	r3, [pc, #4]	; (23fac <_DRV_GMAC_GetTxOctetHigh+0x8>)
   23fa6:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
}
   23faa:	4770      	bx	lr
   23fac:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxFrameCount%1155:

00023fb0 <_DRV_GMAC_GetTxFrameCount>:
	return GMAC_REGS->GMAC_FT;
   23fb0:	4b01      	ldr	r3, [pc, #4]	; (23fb8 <_DRV_GMAC_GetTxFrameCount+0x8>)
   23fb2:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
}
   23fb6:	4770      	bx	lr
   23fb8:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxBCastFrameCount%1156:

00023fbc <_DRV_GMAC_GetTxBCastFrameCount>:
	return GMAC_REGS->GMAC_BCFT;
   23fbc:	4b01      	ldr	r3, [pc, #4]	; (23fc4 <_DRV_GMAC_GetTxBCastFrameCount+0x8>)
   23fbe:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
}
   23fc2:	4770      	bx	lr
   23fc4:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxMCastFrameCount%1157:

00023fc8 <_DRV_GMAC_GetTxMCastFrameCount>:
	return GMAC_REGS->GMAC_MFT;
   23fc8:	4b01      	ldr	r3, [pc, #4]	; (23fd0 <_DRV_GMAC_GetTxMCastFrameCount+0x8>)
   23fca:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
}
   23fce:	4770      	bx	lr
   23fd0:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxPauseFrameCount%1158:

00023fd4 <_DRV_GMAC_GetTxPauseFrameCount>:
	return GMAC_REGS->GMAC_PFT;
   23fd4:	4b01      	ldr	r3, [pc, #4]	; (23fdc <_DRV_GMAC_GetTxPauseFrameCount+0x8>)
   23fd6:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
}
   23fda:	4770      	bx	lr
   23fdc:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTx64ByteFrameCount%1159:

00023fe0 <_DRV_GMAC_GetTx64ByteFrameCount>:
	return GMAC_REGS->GMAC_BFT64;
   23fe0:	4b01      	ldr	r3, [pc, #4]	; (23fe8 <_DRV_GMAC_GetTx64ByteFrameCount+0x8>)
   23fe2:	f8d3 0118 	ldr.w	r0, [r3, #280]	; 0x118
}
   23fe6:	4770      	bx	lr
   23fe8:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTx127ByteFrameCount%1160:

00023fec <_DRV_GMAC_GetTx127ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFT127;
   23fec:	4b01      	ldr	r3, [pc, #4]	; (23ff4 <_DRV_GMAC_GetTx127ByteFrameCount+0x8>)
   23fee:	f8d3 011c 	ldr.w	r0, [r3, #284]	; 0x11c
}
   23ff2:	4770      	bx	lr
   23ff4:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTx255ByteFrameCount%1161:

00023ff8 <_DRV_GMAC_GetTx255ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFT255;
   23ff8:	4b01      	ldr	r3, [pc, #4]	; (24000 <_DRV_GMAC_GetTx255ByteFrameCount+0x8>)
   23ffa:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
}
   23ffe:	4770      	bx	lr
   24000:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTx511ByteFrameCount%1162:

00024004 <_DRV_GMAC_GetTx511ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFT511;
   24004:	4b01      	ldr	r3, [pc, #4]	; (2400c <_DRV_GMAC_GetTx511ByteFrameCount+0x8>)
   24006:	f8d3 0124 	ldr.w	r0, [r3, #292]	; 0x124
}
   2400a:	4770      	bx	lr
   2400c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTx1023ByteFrameCount%1163:

00024010 <_DRV_GMAC_GetTx1023ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFT1023;
   24010:	4b01      	ldr	r3, [pc, #4]	; (24018 <_DRV_GMAC_GetTx1023ByteFrameCount+0x8>)
   24012:	f8d3 0128 	ldr.w	r0, [r3, #296]	; 0x128
}
   24016:	4770      	bx	lr
   24018:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTx1518ByteFrameCount%1164:

0002401c <_DRV_GMAC_GetTx1518ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFT1518;
   2401c:	4b01      	ldr	r3, [pc, #4]	; (24024 <_DRV_GMAC_GetTx1518ByteFrameCount+0x8>)
   2401e:	f8d3 012c 	ldr.w	r0, [r3, #300]	; 0x12c
}
   24022:	4770      	bx	lr
   24024:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxGT1518ByteFrameCount%1165:

00024028 <_DRV_GMAC_GetTxGT1518ByteFrameCount>:
	return GMAC_REGS->GMAC_GTBFT1518;
   24028:	4b01      	ldr	r3, [pc, #4]	; (24030 <_DRV_GMAC_GetTxGT1518ByteFrameCount+0x8>)
   2402a:	f8d3 0130 	ldr.w	r0, [r3, #304]	; 0x130
}
   2402e:	4770      	bx	lr
   24030:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxUnderRunFrameCount%1166:

00024034 <_DRV_GMAC_GetTxUnderRunFrameCount>:
	return GMAC_REGS->GMAC_TUR;
   24034:	4b01      	ldr	r3, [pc, #4]	; (2403c <_DRV_GMAC_GetTxUnderRunFrameCount+0x8>)
   24036:	f8d3 0134 	ldr.w	r0, [r3, #308]	; 0x134
}
   2403a:	4770      	bx	lr
   2403c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxSingleCollFrameCount%1167:

00024040 <_DRV_GMAC_GetTxSingleCollFrameCount>:
	return GMAC_REGS->GMAC_SCF;
   24040:	4b01      	ldr	r3, [pc, #4]	; (24048 <_DRV_GMAC_GetTxSingleCollFrameCount+0x8>)
   24042:	f8d3 0138 	ldr.w	r0, [r3, #312]	; 0x138
}
   24046:	4770      	bx	lr
   24048:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxMultiCollFrameCount%1168:

0002404c <_DRV_GMAC_GetTxMultiCollFrameCount>:
	return GMAC_REGS->GMAC_MCF;
   2404c:	4b01      	ldr	r3, [pc, #4]	; (24054 <_DRV_GMAC_GetTxMultiCollFrameCount+0x8>)
   2404e:	f8d3 013c 	ldr.w	r0, [r3, #316]	; 0x13c
}
   24052:	4770      	bx	lr
   24054:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxExcessCollFrameCount%1169:

00024058 <_DRV_GMAC_GetTxExcessCollFrameCount>:
	return GMAC_REGS->GMAC_EC;
   24058:	4b01      	ldr	r3, [pc, #4]	; (24060 <_DRV_GMAC_GetTxExcessCollFrameCount+0x8>)
   2405a:	f8d3 0140 	ldr.w	r0, [r3, #320]	; 0x140
}
   2405e:	4770      	bx	lr
   24060:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxLateCollFrameCount%1170:

00024064 <_DRV_GMAC_GetTxLateCollFrameCount>:
	return GMAC_REGS->GMAC_LC;
   24064:	4b01      	ldr	r3, [pc, #4]	; (2406c <_DRV_GMAC_GetTxLateCollFrameCount+0x8>)
   24066:	f8d3 0144 	ldr.w	r0, [r3, #324]	; 0x144
}
   2406a:	4770      	bx	lr
   2406c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxDeferFrameCount%1171:

00024070 <_DRV_GMAC_GetTxDeferFrameCount>:
	return GMAC_REGS->GMAC_DTF;
   24070:	4b01      	ldr	r3, [pc, #4]	; (24078 <_DRV_GMAC_GetTxDeferFrameCount+0x8>)
   24072:	f8d3 0148 	ldr.w	r0, [r3, #328]	; 0x148
}
   24076:	4770      	bx	lr
   24078:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxCSErrorFrameCount%1172:

0002407c <_DRV_GMAC_GetTxCSErrorFrameCount>:
	return GMAC_REGS->GMAC_CSE;
   2407c:	4b01      	ldr	r3, [pc, #4]	; (24084 <_DRV_GMAC_GetTxCSErrorFrameCount+0x8>)
   2407e:	f8d3 014c 	ldr.w	r0, [r3, #332]	; 0x14c
}
   24082:	4770      	bx	lr
   24084:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxOctetLow%1173:

00024088 <_DRV_GMAC_GetRxOctetLow>:
	return GMAC_REGS->GMAC_ORLO;
   24088:	4b01      	ldr	r3, [pc, #4]	; (24090 <_DRV_GMAC_GetRxOctetLow+0x8>)
   2408a:	f8d3 0150 	ldr.w	r0, [r3, #336]	; 0x150
}
   2408e:	4770      	bx	lr
   24090:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxOctetHigh%1174:

00024094 <_DRV_GMAC_GetRxOctetHigh>:
	return GMAC_REGS->GMAC_ORHI;
   24094:	4b01      	ldr	r3, [pc, #4]	; (2409c <_DRV_GMAC_GetRxOctetHigh+0x8>)
   24096:	f8d3 0154 	ldr.w	r0, [r3, #340]	; 0x154
}
   2409a:	4770      	bx	lr
   2409c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxFrameCount%1175:

000240a0 <_DRV_GMAC_GetRxFrameCount>:
	return GMAC_REGS->GMAC_FR;
   240a0:	4b01      	ldr	r3, [pc, #4]	; (240a8 <_DRV_GMAC_GetRxFrameCount+0x8>)
   240a2:	f8d3 0158 	ldr.w	r0, [r3, #344]	; 0x158
}
   240a6:	4770      	bx	lr
   240a8:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxBCastFrameCount%1176:

000240ac <_DRV_GMAC_GetRxBCastFrameCount>:
	return GMAC_REGS->GMAC_BCFR;
   240ac:	4b01      	ldr	r3, [pc, #4]	; (240b4 <_DRV_GMAC_GetRxBCastFrameCount+0x8>)
   240ae:	f8d3 015c 	ldr.w	r0, [r3, #348]	; 0x15c
}
   240b2:	4770      	bx	lr
   240b4:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxMCastFrameCount%1177:

000240b8 <_DRV_GMAC_GetRxMCastFrameCount>:
	return GMAC_REGS->GMAC_MFR;
   240b8:	4b01      	ldr	r3, [pc, #4]	; (240c0 <_DRV_GMAC_GetRxMCastFrameCount+0x8>)
   240ba:	f8d3 0160 	ldr.w	r0, [r3, #352]	; 0x160
}
   240be:	4770      	bx	lr
   240c0:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxPauseFrameCount%1178:

000240c4 <_DRV_GMAC_GetRxPauseFrameCount>:
	return GMAC_REGS->GMAC_PFR;
   240c4:	4b01      	ldr	r3, [pc, #4]	; (240cc <_DRV_GMAC_GetRxPauseFrameCount+0x8>)
   240c6:	f8d3 0164 	ldr.w	r0, [r3, #356]	; 0x164
}
   240ca:	4770      	bx	lr
   240cc:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRx64ByteFrameCount%1179:

000240d0 <_DRV_GMAC_GetRx64ByteFrameCount>:
	return GMAC_REGS->GMAC_BFR64;
   240d0:	4b01      	ldr	r3, [pc, #4]	; (240d8 <_DRV_GMAC_GetRx64ByteFrameCount+0x8>)
   240d2:	f8d3 0168 	ldr.w	r0, [r3, #360]	; 0x168
}
   240d6:	4770      	bx	lr
   240d8:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRx127ByteFrameCount%1180:

000240dc <_DRV_GMAC_GetRx127ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFR127;
   240dc:	4b01      	ldr	r3, [pc, #4]	; (240e4 <_DRV_GMAC_GetRx127ByteFrameCount+0x8>)
   240de:	f8d3 016c 	ldr.w	r0, [r3, #364]	; 0x16c
}
   240e2:	4770      	bx	lr
   240e4:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRx255ByteFrameCount%1181:

000240e8 <_DRV_GMAC_GetRx255ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFR255;
   240e8:	4b01      	ldr	r3, [pc, #4]	; (240f0 <_DRV_GMAC_GetRx255ByteFrameCount+0x8>)
   240ea:	f8d3 0170 	ldr.w	r0, [r3, #368]	; 0x170
}
   240ee:	4770      	bx	lr
   240f0:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRx511ByteFrameCount%1182:

000240f4 <_DRV_GMAC_GetRx511ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFR511;
   240f4:	4b01      	ldr	r3, [pc, #4]	; (240fc <_DRV_GMAC_GetRx511ByteFrameCount+0x8>)
   240f6:	f8d3 0174 	ldr.w	r0, [r3, #372]	; 0x174
}
   240fa:	4770      	bx	lr
   240fc:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRx1023ByteFrameCount%1183:

00024100 <_DRV_GMAC_GetRx1023ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFR1023;
   24100:	4b01      	ldr	r3, [pc, #4]	; (24108 <_DRV_GMAC_GetRx1023ByteFrameCount+0x8>)
   24102:	f8d3 0178 	ldr.w	r0, [r3, #376]	; 0x178
}
   24106:	4770      	bx	lr
   24108:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRx1518ByteFrameCount%1184:

0002410c <_DRV_GMAC_GetRx1518ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFR1518;
   2410c:	4b01      	ldr	r3, [pc, #4]	; (24114 <_DRV_GMAC_GetRx1518ByteFrameCount+0x8>)
   2410e:	f8d3 017c 	ldr.w	r0, [r3, #380]	; 0x17c
}
   24112:	4770      	bx	lr
   24114:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxGT1518ByteFrameCount%1185:

00024118 <_DRV_GMAC_GetRxGT1518ByteFrameCount>:
	return GMAC_REGS->GMAC_TMXBFR;
   24118:	4b01      	ldr	r3, [pc, #4]	; (24120 <_DRV_GMAC_GetRxGT1518ByteFrameCount+0x8>)
   2411a:	f8d3 0180 	ldr.w	r0, [r3, #384]	; 0x180
}
   2411e:	4770      	bx	lr
   24120:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxUnderSizeFrameCount%1186:

00024124 <_DRV_GMAC_GetRxUnderSizeFrameCount>:
	return GMAC_REGS->GMAC_UFR;
   24124:	4b01      	ldr	r3, [pc, #4]	; (2412c <_DRV_GMAC_GetRxUnderSizeFrameCount+0x8>)
   24126:	f8d3 0184 	ldr.w	r0, [r3, #388]	; 0x184
}
   2412a:	4770      	bx	lr
   2412c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxOverSizeFrameCount%1187:

00024130 <_DRV_GMAC_GetRxOverSizeFrameCount>:
	return GMAC_REGS->GMAC_OFR;
   24130:	4b01      	ldr	r3, [pc, #4]	; (24138 <_DRV_GMAC_GetRxOverSizeFrameCount+0x8>)
   24132:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
}
   24136:	4770      	bx	lr
   24138:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxJabberFrameCount%1188:

0002413c <_DRV_GMAC_GetRxJabberFrameCount>:
	return GMAC_REGS->GMAC_JR;
   2413c:	4b01      	ldr	r3, [pc, #4]	; (24144 <_DRV_GMAC_GetRxJabberFrameCount+0x8>)
   2413e:	f8d3 018c 	ldr.w	r0, [r3, #396]	; 0x18c
}
   24142:	4770      	bx	lr
   24144:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxFCSErrorFrameCount%1189:

00024148 <_DRV_GMAC_GetRxFCSErrorFrameCount>:
	return GMAC_REGS->GMAC_FCSE;
   24148:	4b01      	ldr	r3, [pc, #4]	; (24150 <_DRV_GMAC_GetRxFCSErrorFrameCount+0x8>)
   2414a:	f8d3 0190 	ldr.w	r0, [r3, #400]	; 0x190
}
   2414e:	4770      	bx	lr
   24150:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxLFErrorFrameCount%1190:

00024154 <_DRV_GMAC_GetRxLFErrorFrameCount>:
	return GMAC_REGS->GMAC_LFFE;
   24154:	4b01      	ldr	r3, [pc, #4]	; (2415c <_DRV_GMAC_GetRxLFErrorFrameCount+0x8>)
   24156:	f8d3 0194 	ldr.w	r0, [r3, #404]	; 0x194
}
   2415a:	4770      	bx	lr
   2415c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxSymErrorFrameCount%1191:

00024160 <_DRV_GMAC_GetRxSymErrorFrameCount>:
	return GMAC_REGS->GMAC_RSE;
   24160:	4b01      	ldr	r3, [pc, #4]	; (24168 <_DRV_GMAC_GetRxSymErrorFrameCount+0x8>)
   24162:	f8d3 0198 	ldr.w	r0, [r3, #408]	; 0x198
}
   24166:	4770      	bx	lr
   24168:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxAlignErrorFrameCount%1192:

0002416c <_DRV_GMAC_GetRxAlignErrorFrameCount>:
	return GMAC_REGS->GMAC_AE;
   2416c:	4b01      	ldr	r3, [pc, #4]	; (24174 <_DRV_GMAC_GetRxAlignErrorFrameCount+0x8>)
   2416e:	f8d3 019c 	ldr.w	r0, [r3, #412]	; 0x19c
}
   24172:	4770      	bx	lr
   24174:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxResErrorFrameCount%1193:

00024178 <_DRV_GMAC_GetRxResErrorFrameCount>:
	return GMAC_REGS->GMAC_RRE;
   24178:	4b01      	ldr	r3, [pc, #4]	; (24180 <_DRV_GMAC_GetRxResErrorFrameCount+0x8>)
   2417a:	f8d3 01a0 	ldr.w	r0, [r3, #416]	; 0x1a0
}
   2417e:	4770      	bx	lr
   24180:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxOverRunFrameCount%1194:

00024184 <_DRV_GMAC_GetRxOverRunFrameCount>:
	return GMAC_REGS->GMAC_ROE;
   24184:	4b01      	ldr	r3, [pc, #4]	; (2418c <_DRV_GMAC_GetRxOverRunFrameCount+0x8>)
   24186:	f8d3 01a4 	ldr.w	r0, [r3, #420]	; 0x1a4
}
   2418a:	4770      	bx	lr
   2418c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxIPHdrCSErrorFrameCount%1195:

00024190 <_DRV_GMAC_GetRxIPHdrCSErrorFrameCount>:
	return GMAC_REGS->GMAC_IHCE;
   24190:	4b01      	ldr	r3, [pc, #4]	; (24198 <_DRV_GMAC_GetRxIPHdrCSErrorFrameCount+0x8>)
   24192:	f8d3 01a8 	ldr.w	r0, [r3, #424]	; 0x1a8
}
   24196:	4770      	bx	lr
   24198:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxTCPCSErrorFrameCount%1196:

0002419c <_DRV_GMAC_GetRxTCPCSErrorFrameCount>:
	return GMAC_REGS->GMAC_TCE;
   2419c:	4b01      	ldr	r3, [pc, #4]	; (241a4 <_DRV_GMAC_GetRxTCPCSErrorFrameCount+0x8>)
   2419e:	f8d3 01ac 	ldr.w	r0, [r3, #428]	; 0x1ac
}
   241a2:	4770      	bx	lr
   241a4:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxUDPCSErrorFrameCount%1197:

000241a8 <_DRV_GMAC_GetRxUDPCSErrorFrameCount>:
	return GMAC_REGS->GMAC_UCE;
   241a8:	4b01      	ldr	r3, [pc, #4]	; (241b0 <_DRV_GMAC_GetRxUDPCSErrorFrameCount+0x8>)
   241aa:	f8d3 01b0 	ldr.w	r0, [r3, #432]	; 0x1b0
}
   241ae:	4770      	bx	lr
   241b0:	42000800 	.word	0x42000800

Disassembly of section .text.DRV_PIC32CGMAC_LibReadInterruptStatus%1198:

000241b4 <DRV_PIC32CGMAC_LibReadInterruptStatus>:
    return GMAC_REGS->GMAC_ISR;
   241b4:	4b01      	ldr	r3, [pc, #4]	; (241bc <DRV_PIC32CGMAC_LibReadInterruptStatus+0x8>)
   241b6:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
   241b8:	4770      	bx	lr
   241ba:	bf00      	nop
   241bc:	42000800 	.word	0x42000800

Disassembly of section .text.DRV_PIC32CGMAC_LibEnableInterrupt%1199:

000241c0 <DRV_PIC32CGMAC_LibEnableInterrupt>:
    GMAC_REGS->GMAC_IER = ethEvents;
   241c0:	4b01      	ldr	r3, [pc, #4]	; (241c8 <DRV_PIC32CGMAC_LibEnableInterrupt+0x8>)
   241c2:	6299      	str	r1, [r3, #40]	; 0x28
}
   241c4:	4770      	bx	lr
   241c6:	bf00      	nop
   241c8:	42000800 	.word	0x42000800

Disassembly of section .text.DRV_PIC32CGMAC_LibDisableInterrupt%1200:

000241cc <DRV_PIC32CGMAC_LibDisableInterrupt>:
    GMAC_REGS->GMAC_IDR = ethEvents;
   241cc:	4b01      	ldr	r3, [pc, #4]	; (241d4 <DRV_PIC32CGMAC_LibDisableInterrupt+0x8>)
   241ce:	62d9      	str	r1, [r3, #44]	; 0x2c
}
   241d0:	4770      	bx	lr
   241d2:	bf00      	nop
   241d4:	42000800 	.word	0x42000800

Disassembly of section .text.btohexa_high%1201:

000241d8 <btohexa_high>:
	b >>= 4;
   241d8:	0900      	lsrs	r0, r0, #4
	return (b>0x9u) ? b+'a'-10:b+'0';
   241da:	2809      	cmp	r0, #9
   241dc:	bf8c      	ite	hi
   241de:	3057      	addhi	r0, #87	; 0x57
   241e0:	3030      	addls	r0, #48	; 0x30
}
   241e2:	4770      	bx	lr

Disassembly of section .text.TCPIP_ARP_HashKeyCompare%1202:

000241e4 <TCPIP_ARP_HashKeyCompare>:


int TCPIP_ARP_HashKeyCompare(OA_HASH_DCPT* pOH, OA_HASH_ENTRY* hEntry, const void* key)
{
    return ((ARP_HASH_ENTRY*)hEntry)->ipAddress.Val != ((ARP_UNALIGNED_KEY*)key)->v;
   241e4:	6813      	ldr	r3, [r2, #0]
   241e6:	6888      	ldr	r0, [r1, #8]
}
   241e8:	1ac0      	subs	r0, r0, r3
   241ea:	bf18      	it	ne
   241ec:	2001      	movne	r0, #1
   241ee:	4770      	bx	lr

Disassembly of section .text.TCPIP_IPV4_PacketTransmit%1203:

000241f0 <TCPIP_IPV4_PacketTransmit>:
{
   241f0:	b508      	push	{r3, lr}
    return TCPIP_IPV4_PktTx(pPkt, &pPkt->macPkt, true);
   241f2:	2201      	movs	r2, #1
   241f4:	4601      	mov	r1, r0
   241f6:	f7eb fcbd 	bl	fb74 <TCPIP_IPV4_PktTx>
}
   241fa:	bd08      	pop	{r3, pc}

Disassembly of section .text._TCPIP_HEAP_Size%1204:

000241fc <_TCPIP_HEAP_Size>:
    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   241fc:	b110      	cbz	r0, 24204 <_TCPIP_HEAP_Size+0x8>
        return hDcpt->_heapUnits * sizeof(_headNode);   
   241fe:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   24200:	0100      	lsls	r0, r0, #4
   24202:	4770      	bx	lr
    return 0;
   24204:	2000      	movs	r0, #0
}
   24206:	4770      	bx	lr

Disassembly of section .text._TCPIP_HEAP_HighWatermark%1205:

00024208 <_TCPIP_HEAP_HighWatermark>:
    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   24208:	b110      	cbz	r0, 24210 <_TCPIP_HEAP_HighWatermark+0x8>
        return hDcpt->_heapWatermark * sizeof(_headNode);
   2420a:	6b40      	ldr	r0, [r0, #52]	; 0x34
   2420c:	0100      	lsls	r0, r0, #4
   2420e:	4770      	bx	lr
    return 0;
   24210:	2000      	movs	r0, #0
}
   24212:	4770      	bx	lr

Disassembly of section .text.TCPIP_DNS_OAHASH_KeyCompare%1206:

00024214 <TCPIP_DNS_OAHASH_KeyCompare>:
{
   24214:	b508      	push	{r3, lr}
    return strcmp(pDnsHE->pHostName, (const char*)dnsHostNameKey);
   24216:	6a08      	ldr	r0, [r1, #32]
   24218:	4611      	mov	r1, r2
   2421a:	f7ff fcef 	bl	23bfc <strcmp>
}
   2421e:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_DNS_Enable%1207:

00024220 <TCPIP_DNS_Enable>:
{
   24220:	b508      	push	{r3, lr}
    return _DNS_Enable(hNet, true, flags);
   24222:	460a      	mov	r2, r1
   24224:	2101      	movs	r1, #1
   24226:	f7f9 fbf3 	bl	1da10 <_DNS_Enable>
}
   2422a:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_STACK_NetDefaultGet%1208:

0002422c <TCPIP_STACK_NetDefaultGet>:
}
   2422c:	4b01      	ldr	r3, [pc, #4]	; (24234 <TCPIP_STACK_NetDefaultGet+0x8>)
   2422e:	6818      	ldr	r0, [r3, #0]
   24230:	4770      	bx	lr
   24232:	bf00      	nop
   24234:	2000ee70 	.word	0x2000ee70

Disassembly of section .text.TCPIP_STACK_NumberOfNetworksGet%1209:

00024238 <TCPIP_STACK_NumberOfNetworksGet>:
}
   24238:	4b01      	ldr	r3, [pc, #4]	; (24240 <TCPIP_STACK_NumberOfNetworksGet+0x8>)
   2423a:	6818      	ldr	r0, [r3, #0]
   2423c:	4770      	bx	lr
   2423e:	bf00      	nop
   24240:	2000eae4 	.word	0x2000eae4

Disassembly of section .rodata.TCPIP_STACK_IF_ALIAS_NAME_TBL%1210:

00024244 <TCPIP_STACK_IF_ALIAS_NAME_TBL>:
   24244:	00009874 00009878 0000987c              t...x...|...

Disassembly of section .text.TCPIP_PKT_Deinitialize%1211:

00024250 <TCPIP_PKT_Deinitialize>:
    pktMemH = 0;
   24250:	4b01      	ldr	r3, [pc, #4]	; (24258 <TCPIP_PKT_Deinitialize+0x8>)
   24252:	2200      	movs	r2, #0
   24254:	601a      	str	r2, [r3, #0]
}
   24256:	4770      	bx	lr
   24258:	2000ee84 	.word	0x2000ee84

Disassembly of section .text.SERCOM0_SPI_Write%1212:

0002425c <SERCOM0_SPI_Write>:
{
   2425c:	b508      	push	{r3, lr}
    return SERCOM0_SPI_WriteRead(pTransmitData, txSize, NULL, 0U);
   2425e:	2300      	movs	r3, #0
   24260:	461a      	mov	r2, r3
   24262:	f7ef fd1d 	bl	13ca0 <SERCOM0_SPI_WriteRead>
}
   24266:	bd08      	pop	{r3, pc}

Disassembly of section .text.TC0_TimerCallbackRegister%1213:

00024268 <TC0_TimerCallbackRegister>:
    TC0_CallbackObject.callback = callback;
   24268:	4b01      	ldr	r3, [pc, #4]	; (24270 <TC0_TimerCallbackRegister+0x8>)
   2426a:	6018      	str	r0, [r3, #0]
    TC0_CallbackObject.context = context;
   2426c:	6059      	str	r1, [r3, #4]
}
   2426e:	4770      	bx	lr
   24270:	2000ed84 	.word	0x2000ed84

Disassembly of section .text.SYS_DEBUG_ConsoleInstanceGet%1214:

00024274 <SYS_DEBUG_ConsoleInstanceGet>:


SYS_MODULE_INDEX SYS_DEBUG_ConsoleInstanceGet(void)
{
    return sysDebugInstance.debugConsole;
}
   24274:	4b01      	ldr	r3, [pc, #4]	; (2427c <SYS_DEBUG_ConsoleInstanceGet+0x8>)
   24276:	8858      	ldrh	r0, [r3, #2]
   24278:	4770      	bx	lr
   2427a:	bf00      	nop
   2427c:	2000eedc 	.word	0x2000eedc

Disassembly of section .text.SYS_DEBUG_ErrorLevelGet%1215:

00024280 <SYS_DEBUG_ErrorLevelGet>:
}

SYS_ERROR_LEVEL SYS_DEBUG_ErrorLevelGet(void)
{
    return gblErrLvl;
}
   24280:	4b01      	ldr	r3, [pc, #4]	; (24288 <SYS_DEBUG_ErrorLevelGet+0x8>)
   24282:	7818      	ldrb	r0, [r3, #0]
   24284:	4770      	bx	lr
   24286:	bf00      	nop
   24288:	2000ef91 	.word	0x2000ef91

Disassembly of section .text.SYS_TIME_FrequencyGet%1216:

0002428c <SYS_TIME_FrequencyGet>:
}
   2428c:	4b01      	ldr	r3, [pc, #4]	; (24294 <SYS_TIME_FrequencyGet+0x8>)
   2428e:	68d8      	ldr	r0, [r3, #12]
   24290:	4770      	bx	lr
   24292:	bf00      	nop
   24294:	2000ea00 	.word	0x2000ea00

Disassembly of section .rodata.sysConsole0Init%1217:

00024298 <sysConsole0Init>:
   24298:	000244a8 00021afc 00000000              .D..........

Disassembly of section .text.vTaskMissedYield%1218:

000242a4 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
   242a4:	4b01      	ldr	r3, [pc, #4]	; (242ac <vTaskMissedYield+0x8>)
   242a6:	2201      	movs	r2, #1
   242a8:	601a      	str	r2, [r3, #0]
}
   242aa:	4770      	bx	lr
   242ac:	2000ef38 	.word	0x2000ef38

Disassembly of section .text.gfx_mono_set_framebuffer%1219:

000242b0 <gfx_mono_set_framebuffer>:
    fbpointer = framebuffer;
   242b0:	4b01      	ldr	r3, [pc, #4]	; (242b8 <gfx_mono_set_framebuffer+0x8>)
   242b2:	6018      	str	r0, [r3, #0]
}
   242b4:	4770      	bx	lr
   242b6:	bf00      	nop
   242b8:	2000ef3c 	.word	0x2000ef3c

Disassembly of section .text.TriggerDHCPSRestart%1220:

000242bc <TriggerDHCPSRestart>:
    DHCPS_Restart = true;
   242bc:	4b01      	ldr	r3, [pc, #4]	; (242c4 <TriggerDHCPSRestart+0x8>)
   242be:	2201      	movs	r2, #1
   242c0:	701a      	strb	r2, [r3, #0]
}
   242c2:	4770      	bx	lr
   242c4:	2000ef92 	.word	0x2000ef92

Disassembly of section .text._cleanup_r%1221:

000242c8 <_cleanup_r>:
   242c8:	4901      	ldr	r1, [pc, #4]	; (242d0 <_cleanup_r+0x8>)
   242ca:	f7fc b87d 	b.w	203c8 <_fwalk_reent>
   242ce:	bf00      	nop
   242d0:	0001e061 	.word	0x0001e061

Disassembly of section .text.__locale_mb_cur_max%1222:

000242d4 <__locale_mb_cur_max>:
   242d4:	4b01      	ldr	r3, [pc, #4]	; (242dc <__locale_mb_cur_max+0x8>)
   242d6:	f893 0128 	ldrb.w	r0, [r3, #296]	; 0x128
   242da:	4770      	bx	lr
   242dc:	2000e014 	.word	0x2000e014

Disassembly of section .rodata.p05.7453%1223:

000242e0 <p05.7453>:
   242e0:	00000005 00000019 0000007d              ........}...

Disassembly of section .text.fstat%1224:

000242ec <fstat>:
   242ec:	f44f 5300 	mov.w	r3, #8192	; 0x2000
   242f0:	604b      	str	r3, [r1, #4]
   242f2:	2000      	movs	r0, #0
   242f4:	4770      	bx	lr
   242f6:	bf00      	nop

Disassembly of section .rodata%1225:

000242f8 <.rodata%1225>:
   242f8:	4f500043 	.word	0x4f500043
   242fc:	00584953 	.word	0x00584953
   24300:	Address 0x00024300 is out of bounds.


Disassembly of section .text._DRV_ETHPHY_NegRestartPhaseWrite%1226:

00024304 <_DRV_ETHPHY_NegRestartPhaseWrite>:
{
   24304:	b508      	push	{r3, lr}
    _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OK);
   24306:	2100      	movs	r1, #0
   24308:	f7fd fd90 	bl	21e2c <_DRV_PHY_SetOperDoneResult>
}
   2430c:	bd08      	pop	{r3, pc}

Disassembly of section .text._ICMPTxPktAcknowledge%1227:

0002430e <_ICMPTxPktAcknowledge>:
{
   2430e:	b508      	push	{r3, lr}
    TCPIP_PKT_PacketFree(pTxPkt);
   24310:	f7fb ff2e 	bl	20170 <_TCPIP_PKT_PacketFree>
}
   24314:	2000      	movs	r0, #0
   24316:	bd08      	pop	{r3, pc}

Disassembly of section .text._Command_ZcllOnOff%1228:

00024318 <_Command_ZcllOnOff>:
{
   24318:	b508      	push	{r3, lr}
    return _Command_AddressService(pCmdIO, argc, argv, TCPIP_STACK_ADDRESS_SERVICE_ZCLL);
   2431a:	2302      	movs	r3, #2
   2431c:	f7ef faf8 	bl	13910 <_Command_AddressService>
}
   24320:	bd08      	pop	{r3, pc}

Disassembly of section .text._Command_DHCPSOnOff%1229:

00024322 <_Command_DHCPSOnOff>:
{
   24322:	b508      	push	{r3, lr}
    return _Command_AddressService(pCmdIO, argc, argv, TCPIP_STACK_ADDRESS_SERVICE_DHCPS);
   24324:	2303      	movs	r3, #3
   24326:	f7ef faf3 	bl	13910 <_Command_AddressService>
}
   2432a:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_DNS_Resolve%1230:

0002432c <TCPIP_DNS_Resolve>:
{
   2432c:	b508      	push	{r3, lr}
    return _DNS_Resolve(hostName, type, false);
   2432e:	2200      	movs	r2, #0
   24330:	f7ef fc1e 	bl	13b70 <_DNS_Resolve>
}
   24334:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_DNS_IsNameResolved%1231:

00024336 <TCPIP_DNS_IsNameResolved>:
{
   24336:	b508      	push	{r3, lr}
    return _DNS_IsNameResolved(hostName, hostIPv4, hostIPv6, false);
   24338:	2300      	movs	r3, #0
   2433a:	f7f1 fe75 	bl	16028 <_DNS_IsNameResolved>
}
   2433e:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_Helper_SingleListInitialize%1232:

00024340 <TCPIP_Helper_SingleListInitialize>:
    pL->head = pL->tail = 0;
   24340:	2300      	movs	r3, #0
   24342:	6043      	str	r3, [r0, #4]
   24344:	6003      	str	r3, [r0, #0]
    pL->nNodes = 0;
   24346:	6083      	str	r3, [r0, #8]
}
   24348:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetNameGet%1233:

0002434a <TCPIP_STACK_NetNameGet>:
    if(pNetIf != 0 && pNetIf->pMacObj != 0)
   2434a:	b110      	cbz	r0, 24352 <TCPIP_STACK_NetNameGet+0x8>
   2434c:	6c40      	ldr	r0, [r0, #68]	; 0x44
   2434e:	b100      	cbz	r0, 24352 <TCPIP_STACK_NetNameGet+0x8>
        return pNetIf->pMacObj->macName;
   24350:	6840      	ldr	r0, [r0, #4]
}
   24352:	4770      	bx	lr

Disassembly of section .text._TCPIPStackAddressServiceIsRunning%1234:

00024354 <_TCPIPStackAddressServiceIsRunning>:
    return (TCPIP_STACK_ADDRESS_SERVICE_TYPE)(pNetIf->Flags.v & TCPIP_STACK_ADDRESS_SERVICE_MASK);
   24354:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
}
   24358:	f000 0007 	and.w	r0, r0, #7
   2435c:	4770      	bx	lr

Disassembly of section .text.TCPIP_UDP_ServerOpen%1235:

0002435e <TCPIP_UDP_ServerOpen>:
{
   2435e:	b508      	push	{r3, lr}
    return TCPIP_UDP_OpenServerSkt(addType, localPort, localAddress, UDP_OPEN_SERVER);
   24360:	2301      	movs	r3, #1
   24362:	f7f3 fb1f 	bl	179a4 <TCPIP_UDP_OpenServerSkt>
}
   24366:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_UDP_ClientOpen%1236:

00024368 <TCPIP_UDP_ClientOpen>:
{
   24368:	b508      	push	{r3, lr}
    return TCPIP_UDP_OpenClientSkt(addType, remotePort, remoteAddress, UDP_OPEN_CLIENT);
   2436a:	2302      	movs	r3, #2
   2436c:	f7fb ff1e 	bl	201ac <TCPIP_UDP_OpenClientSkt>
}
   24370:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_DHCPS_HashMACKeyCopy%1237:

00024372 <TCPIP_DHCPS_HashMACKeyCopy>:
    memcpy(&(((DHCPS_HASH_ENTRY*)dstEntry)->hwAdd), key, DHCPS_HASH_KEY_SIZE);
   24372:	6813      	ldr	r3, [r2, #0]
   24374:	610b      	str	r3, [r1, #16]
   24376:	8893      	ldrh	r3, [r2, #4]
   24378:	828b      	strh	r3, [r1, #20]
}
   2437a:	4770      	bx	lr

Disassembly of section .text.TCPIP_DHCPS_Enable%1238:

0002437c <TCPIP_DHCPS_Enable>:
{
   2437c:	b508      	push	{r3, lr}
    return _DHCPS_Enable(hNet, true);
   2437e:	2101      	movs	r1, #1
   24380:	f7f4 fd52 	bl	18e28 <_DHCPS_Enable>
}
   24384:	bd08      	pop	{r3, pc}

Disassembly of section .text.DRV_EXTPHY_SMIClockGet%1239:

00024388 <DRV_EXTPHY_SMIClockGet>:
}
   24388:	4800      	ldr	r0, [pc, #0]	; (2438c <DRV_EXTPHY_SMIClockGet+0x4>)
   2438a:	4770      	bx	lr
   2438c:	002625a0 	.word	0x002625a0

Disassembly of section .text.TCPIP_HEAP_MallocOutline%1240:

00024390 <TCPIP_HEAP_MallocOutline>:

// functions needed when not inlined
void* TCPIP_HEAP_MallocOutline(TCPIP_STACK_HEAP_HANDLE h, size_t nBytes)
{
   24390:	b508      	push	{r3, lr}
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
   24392:	6843      	ldr	r3, [r0, #4]
   24394:	4798      	blx	r3
}
   24396:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_HEAP_CallocOutline%1241:

00024398 <TCPIP_HEAP_CallocOutline>:

void* TCPIP_HEAP_CallocOutline(TCPIP_STACK_HEAP_HANDLE h, size_t nElems, size_t elemSize)
{
   24398:	b508      	push	{r3, lr}
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Calloc)(h, nElems, elemSize);
   2439a:	6883      	ldr	r3, [r0, #8]
   2439c:	4798      	blx	r3
}
   2439e:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_HEAP_FreeOutline%1242:

000243a0 <TCPIP_HEAP_FreeOutline>:

size_t TCPIP_HEAP_FreeOutline(TCPIP_STACK_HEAP_HANDLE h, const void* ptr)
{
   243a0:	b508      	push	{r3, lr}
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   243a2:	68c3      	ldr	r3, [r0, #12]
   243a4:	4798      	blx	r3
}
   243a6:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_STACK_GatewayAddressSet%1243:

000243a8 <TCPIP_STACK_GatewayAddressSet>:
    if(pNetIf)
   243a8:	b108      	cbz	r0, 243ae <TCPIP_STACK_GatewayAddressSet+0x6>
        pNetIf->netGateway.Val = ipAddress->Val;
   243aa:	680a      	ldr	r2, [r1, #0]
   243ac:	60c2      	str	r2, [r0, #12]
}
   243ae:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_PrimaryDNSAddressSet%1244:

000243b0 <TCPIP_STACK_PrimaryDNSAddressSet>:
    if(pNetIf)
   243b0:	b108      	cbz	r0, 243b6 <TCPIP_STACK_PrimaryDNSAddressSet+0x6>
        pNetIf->dnsServer[0].Val = ipAddress->Val;
   243b2:	680a      	ldr	r2, [r1, #0]
   243b4:	6102      	str	r2, [r0, #16]
}
   243b6:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_SecondaryDNSAddressSet%1245:

000243b8 <TCPIP_STACK_SecondaryDNSAddressSet>:
    if(pNetIf)
   243b8:	b108      	cbz	r0, 243be <TCPIP_STACK_SecondaryDNSAddressSet+0x6>
        pNetIf->dnsServer[1].Val = ipAddress->Val;
   243ba:	680a      	ldr	r2, [r1, #0]
   243bc:	6142      	str	r2, [r0, #20]
}
   243be:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressMac%1246:

000243c0 <TCPIP_STACK_NetAddressMac>:
{
   243c0:	b508      	push	{r3, lr}
    return TCPIP_STACK_NetUpMACAddressGet(pNetIf);
   243c2:	f7ff fb99 	bl	23af8 <TCPIP_STACK_NetUpMACAddressGet>
}
   243c6:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_STACK_NetGetType%1247:

000243c8 <TCPIP_STACK_NetGetType>:
    {
        return _TCPIPStackNetIsPrimary(pNetIf) ? TCPIP_NETWORK_TYPE_PRIMARY : TCPIP_NETWORK_TYPE_ALIAS;
    }

    return TCPIP_NETWORK_TYPE_UNKNOWN; 
}
   243c8:	3000      	adds	r0, #0
   243ca:	bf18      	it	ne
   243cc:	2001      	movne	r0, #1
   243ce:	4770      	bx	lr

Disassembly of section .text.TCPIP_Notification_Initialize%1248:

000243d0 <TCPIP_Notification_Initialize>:
{
   243d0:	b508      	push	{r3, lr}
    return TCPIP_Helper_ProtectedSingleListInitialize(notifyList);
   243d2:	f7fe fa90 	bl	228f6 <TCPIP_Helper_ProtectedSingleListInitialize>
}
   243d6:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_UDP_TxPutIsReady%1249:

000243d8 <TCPIP_UDP_TxPutIsReady>:
{
   243d8:	b508      	push	{r3, lr}
    return TCPIP_UDP_PutIsReady(s);
   243da:	f7fa f98c 	bl	1e6f6 <TCPIP_UDP_PutIsReady>
}
   243de:	bd08      	pop	{r3, pc}

Disassembly of section .text.OSAL_Malloc%1250:

000243e0 <OSAL_Malloc>:
  Remarks:
    None.

 */
void* OSAL_Malloc(size_t size)
{
   243e0:	b508      	push	{r3, lr}
    return pvPortMalloc(size);
   243e2:	f7f8 f991 	bl	1c708 <pvPortMalloc>
}
   243e6:	bd08      	pop	{r3, pc}

Disassembly of section .text.SERCOM1_USART_WriteCountGet%1251:

000243e8 <SERCOM1_USART_WriteCountGet>:
{
   243e8:	b508      	push	{r3, lr}
    nPendingTxBytes = SERCOM1_USART_WritePendingBytesGet();
   243ea:	f7ff f9f3 	bl	237d4 <SERCOM1_USART_WritePendingBytesGet>
}
   243ee:	bd08      	pop	{r3, pc}

Disassembly of section .text.TC0_TimerFrequencyGet%1252:

000243f0 <TC0_TimerFrequencyGet>:
}
   243f0:	4800      	ldr	r0, [pc, #0]	; (243f4 <TC0_TimerFrequencyGet+0x4>)
   243f2:	4770      	bx	lr
   243f4:	03938700 	.word	0x03938700

Disassembly of section .text.SYS_INT_Disable%1253:

000243f8 <SYS_INT_Disable>:
{
   243f8:	b508      	push	{r3, lr}
    return NVIC_INT_Disable();
   243fa:	f7ff fc49 	bl	23c90 <NVIC_INT_Disable>
}
   243fe:	bd08      	pop	{r3, pc}

Disassembly of section .text.SYS_INT_Restore%1254:

00024400 <SYS_INT_Restore>:
{
   24400:	b508      	push	{r3, lr}
    NVIC_INT_Restore(state);
   24402:	f7ff fc4e 	bl	23ca2 <NVIC_INT_Restore>
}
   24406:	bd08      	pop	{r3, pc}

Disassembly of section .text.SYS_TIME_CounterGet%1255:

00024408 <SYS_TIME_CounterGet>:
{
   24408:	b508      	push	{r3, lr}
    counter32 = (uint32_t)SYS_TIME_Counter64Get();
   2440a:	f7fb ff65 	bl	202d8 <SYS_TIME_Counter64Get>
}
   2440e:	bd08      	pop	{r3, pc}

Disassembly of section .rodata.drvMiimInitData%1256:

00024410 <drvMiimInitData>:
   24410:	0000 0000 0800 4200                         .......B

Disassembly of section .rodata.sysTimeInitData%1257:

00024418 <sysTimeInitData>:
   24418:	327c 0002 006b 0000                         |2..k...

Disassembly of section .rodata.tcpipTCPInitData%1258:

00024420 <tcpipTCPInitData>:
   24420:	000a 0000 0200 0200                         ........

Disassembly of section .rodata.tcpipUDPInitData%1259:

00024428 <tcpipUDPInitData>:
   24428:	000a 0200 0000 0000                         ........

Disassembly of section .text.vQueueDelete%1260:

00024430 <vQueueDelete>:
{
   24430:	b508      	push	{r3, lr}
		vPortFree( pxQueue );
   24432:	f7f8 fe04 	bl	1d03e <vPortFree>
}
   24436:	bd08      	pop	{r3, pc}

Disassembly of section .rodata%1261:

00024438 <.rodata%1261>:
   24438:	454c4449 	.word	0x454c4449
   2443c:	00          	.byte	0x00
   2443d:	00          	.byte	0x00
   2443e:	bf00      	nop

Disassembly of section .text.gfx_mono_ssd1306_get_byte%1262:

00024440 <gfx_mono_ssd1306_get_byte>:
uint8_t gfx_mono_ssd1306_get_byte(gfx_coord_t page, gfx_coord_t column) {
   24440:	b508      	push	{r3, lr}
    return gfx_mono_framebuffer_get_byte(page, column);
   24442:	f7ff fd05 	bl	23e50 <gfx_mono_framebuffer_get_byte>
}
   24446:	bd08      	pop	{r3, pc}

Disassembly of section .text.atoi%1263:

00024448 <atoi>:
   24448:	220a      	movs	r2, #10
   2444a:	2100      	movs	r1, #0
   2444c:	f7ff bbe0 	b.w	23c10 <strtol>

Disassembly of section .text._localeconv_r%1264:

00024450 <_localeconv_r>:
   24450:	4800      	ldr	r0, [pc, #0]	; (24454 <_localeconv_r+0x4>)
   24452:	4770      	bx	lr
   24454:	2000e104 	.word	0x2000e104

Disassembly of section .text.__sclose%1265:

00024458 <__sclose>:
   24458:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   2445c:	f7fe bcd0 	b.w	22e00 <_close_r>

Disassembly of section .text.close%1266:

00024460 <close>:
   24460:	f04f 30ff 	mov.w	r0, #4294967295
   24464:	4770      	bx	lr
   24466:	bf00      	nop

Disassembly of section .text.TCPIP_ARP_HashKeyCopy%1267:

00024468 <TCPIP_ARP_HashKeyCopy>:

void TCPIP_ARP_HashKeyCopy(OA_HASH_DCPT* pOH, OA_HASH_ENTRY* dstEntry, const void* key)
{

    ((ARP_HASH_ENTRY*)dstEntry)->ipAddress.Val = ((ARP_UNALIGNED_KEY*)key)->v;
   24468:	6813      	ldr	r3, [r2, #0]
   2446a:	608b      	str	r3, [r1, #8]
}
   2446c:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetBIOSName%1268:

0002446e <TCPIP_STACK_NetBIOSName>:
    if(pNetIf)
   2446e:	b100      	cbz	r0, 24472 <TCPIP_STACK_NetBIOSName+0x4>
        return (const char*)pNetIf->NetBIOSName;
   24470:	302c      	adds	r0, #44	; 0x2c
}
   24472:	4770      	bx	lr

Disassembly of section .text.TCPIP_PKT_GapDcptOffset%1269:

00024474 <TCPIP_PKT_GapDcptOffset>:
}
   24474:	f06f 0007 	mvn.w	r0, #7
   24478:	4770      	bx	lr

Disassembly of section .text.vListInitialiseItem%1270:

0002447a <vListInitialiseItem>:
	pxItem->pxContainer = NULL;
   2447a:	2300      	movs	r3, #0
   2447c:	6103      	str	r3, [r0, #16]
}
   2447e:	4770      	bx	lr

Disassembly of section .text.CRYPT_WCCB_Callback%1271:

00024480 <CRYPT_WCCB_Callback>:
}
   24480:	f46f 7087 	mvn.w	r0, #270	; 0x10e
   24484:	4770      	bx	lr

Disassembly of section .text.DRV_EXTPHY_MDIXConfigure%1272:

00004f8c <DRV_EXTPHY_MDIXConfigure>:
}
    4f8c:	2000      	movs	r0, #0
    4f8e:	4770      	bx	lr

Disassembly of section .text.DRV_GMAC_PowerMode%1273:

00017814 <DRV_GMAC_PowerMode>:
}
   17814:	2001      	movs	r0, #1
   17816:	4770      	bx	lr

Disassembly of section .text.DRV_PIC32CGMAC_LibRxQueFilterInit%1274:

000195dc <DRV_PIC32CGMAC_LibRxQueFilterInit>:
}
   195dc:	2000      	movs	r0, #0
   195de:	4770      	bx	lr

Disassembly of section .text.DRV_PIC32CGMAC_LibGetPriorityFromQueueNum%1275:

0002232c <DRV_PIC32CGMAC_LibGetPriorityFromQueueNum>:
}
   2232c:	4608      	mov	r0, r1
   2232e:	4770      	bx	lr

Disassembly of section .text.TCPIP_IPV4_IsFragmentationEnabled%1276:

00024486 <TCPIP_IPV4_IsFragmentationEnabled>:
#if (_TCPIP_IPV4_FRAGMENTATION != 0)
    return true;
#else
    return false;
#endif  // (_TCPIP_IPV4_FRAGMENTATION != 0)
}
   24486:	2000      	movs	r0, #0
   24488:	4770      	bx	lr

Disassembly of section .text._DHCPOptionProcessEnd%1277:

0002448a <_DHCPOptionProcessEnd>:
}
   2448a:	2000      	movs	r0, #0
   2448c:	4770      	bx	lr

Disassembly of section .rodata._DHCPRequestParamsTbl%1278:

00024490 <_DHCPRequestParamsTbl>:
   24490:	0301 0006                                   ....

Disassembly of section .rodata.dhcpMagicCookie%1279:

00024494 <dhcpMagicCookie>:
   24494:	8263 6353                                   c.Sc

Disassembly of section .text.TCPIP_PKT_GapDcptSize%1280:

00024498 <TCPIP_PKT_GapDcptSize>:
}
   24498:	2008      	movs	r0, #8
   2449a:	4770      	bx	lr

Disassembly of section .text._mon_getc%1281:

0002449c <_mon_getc>:

int _mon_getc(int canblock)
{
   (void)canblock;
   return 0;
}
   2449c:	2000      	movs	r0, #0
   2449e:	4770      	bx	lr

Disassembly of section .text.Console_UART_Flush%1282:

000244a0 <Console_UART_Flush>:
}
   244a0:	2001      	movs	r0, #1
   244a2:	4770      	bx	lr

Disassembly of section .rodata.debugInit%1283:

000244a4 <debugInit>:
   244a4:	0400 0000                                   ....

Disassembly of section .rodata.sysConsole0UARTInitData%1284:

000244a8 <sysConsole0UARTInitData>:
   244a8:	38ac 0002                                   .8..

Disassembly of section .text%1285:

000244ac <__aeabi_idiv0>:
   244ac:	4770      	bx	lr
   244ae:	bf00      	nop

Disassembly of section .rodata._global_impure_ptr%1286:

000244b0 <_global_impure_ptr>:
   244b0:	e914 2000                                   ... 

Disassembly of section .text._getpid_r%1287:

000244b4 <_getpid_r>:
   244b4:	f000 b804 	b.w	244c0 <_getpid>

Disassembly of section .text._close%1288:

000244b8 <_close>:
   244b8:	f7ff bfd2 	b.w	24460 <close>

Disassembly of section .text._fstat%1289:

000244bc <_fstat>:
   244bc:	f7ff bf16 	b.w	242ec <fstat>

Disassembly of section .text._getpid%1290:

000244c0 <_getpid>:
   244c0:	f000 b80a 	b.w	244d8 <getpid>

Disassembly of section .text._isatty%1291:

000244c4 <_isatty>:
   244c4:	f000 b80a 	b.w	244dc <isatty>

Disassembly of section .text._kill%1292:

000244c8 <_kill>:
   244c8:	f000 b80a 	b.w	244e0 <kill>

Disassembly of section .text._lseek%1293:

000244cc <_lseek>:
   244cc:	f000 b80a 	b.w	244e4 <lseek>

Disassembly of section .text._read%1294:

000244d0 <_read>:
   244d0:	f7fd bf42 	b.w	22358 <read>

Disassembly of section .text._write%1295:

000244d4 <_write>:
   244d4:	f7fb bc46 	b.w	1fd64 <write>

Disassembly of section .text.getpid%1296:

000244d8 <getpid>:
   244d8:	2000      	movs	r0, #0
   244da:	4770      	bx	lr

Disassembly of section .text.isatty%1297:

000244dc <isatty>:
   244dc:	2001      	movs	r0, #1
   244de:	4770      	bx	lr

Disassembly of section .text.kill%1298:

000244e0 <kill>:
   244e0:	4770      	bx	lr
   244e2:	bf00      	nop

Disassembly of section .text.lseek%1299:

000244e4 <lseek>:
   244e4:	2000      	movs	r0, #0
   244e6:	4770      	bx	lr

Disassembly of section .text._DRV_ETHPHY_ClientOpNone%1300:

0001191a <_DRV_ETHPHY_ClientOpNone>:
}
   1191a:	4770      	bx	lr

Disassembly of section .text.DRV_GMAC_Reinitialize%1301:

000123be <DRV_GMAC_Reinitialize>:
}
   123be:	4770      	bx	lr

Disassembly of section .text.DRV_MIIM_Reinitialize%1302:

0001355e <DRV_MIIM_Reinitialize>:
}
   1355e:	4770      	bx	lr

Disassembly of section .text._TCPIP_HEAP_BufferMapNonCached%1303:

0001402e <_TCPIP_HEAP_BufferMapNonCached>:
}
   1402e:	4770      	bx	lr

Disassembly of section .text.EVSYS_Initialize%1304:

00015b56 <EVSYS_Initialize>:

void EVSYS_Initialize( void )
{
    /*Event Channel User Configuration*/

}
   15b56:	4770      	bx	lr

Disassembly of section .text._mon_putc%1305:

000166a6 <_mon_putc>:

void _mon_putc(char c)
{
   (void)c;
}
   166a6:	4770      	bx	lr

Disassembly of section .text.Console_UART_Tasks%1306:

00016b1a <Console_UART_Tasks>:

void Console_UART_Tasks(uint32_t index, SYS_MODULE_OBJ object)
{
    /* Do nothing. */
   16b1a:	4770      	bx	lr

Disassembly of section .text.Dummy_Handler%1307:

000170f6 <Dummy_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
    __builtin_software_breakpoint();
#endif
    while (true)
    {
    }
   170f6:	e7fe      	b.n	170f6 <Dummy_Handler>

Disassembly of section .text.NonMaskableInt_Handler%1308:

00018052 <NonMaskableInt_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
    __builtin_software_breakpoint();
#endif
    while (true)
    {
    }
   18052:	e7fe      	b.n	18052 <NonMaskableInt_Handler>

Disassembly of section .text.HardFault_Handler%1309:

000184a2 <HardFault_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
   __builtin_software_breakpoint();
#endif
   while (true)
   {
   }
   184a2:	e7fe      	b.n	184a2 <HardFault_Handler>

Disassembly of section .text.DebugMonitor_Handler%1310:

00018c2e <DebugMonitor_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
   __builtin_software_breakpoint();
#endif
   while (true)
   {
   }
   18c2e:	e7fe      	b.n	18c2e <DebugMonitor_Handler>

Disassembly of section .text.MemoryManagement_Handler%1311:

0001916e <MemoryManagement_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
   __builtin_software_breakpoint();
#endif
   while (true)
   {
   }
   1916e:	e7fe      	b.n	1916e <MemoryManagement_Handler>

Disassembly of section .text.BusFault_Handler%1312:

000193fa <BusFault_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
   __builtin_software_breakpoint();
#endif
   while (true)
   {
   }
   193fa:	e7fe      	b.n	193fa <BusFault_Handler>

Disassembly of section .text.UsageFault_Handler%1313:

00019ac6 <UsageFault_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
   __builtin_software_breakpoint();
#endif
   while (true)
   {
   }
   19ac6:	e7fe      	b.n	19ac6 <UsageFault_Handler>

Disassembly of section .text.Dummy_App_Func%1314:

0001b6ee <Dummy_App_Func>:
}
   1b6ee:	4770      	bx	lr

Disassembly of section .text._exit%1315:

0001c84a <_exit>:
#endif

    /* halt CPU */
    while (true)
    {
    }
   1c84a:	e7fe      	b.n	1c84a <_exit>

Disassembly of section .text.vPortFree%1316:

0001d03e <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
   1d03e:	4770      	bx	lr

Disassembly of section .text.wc_Sha256Free%1317:

0001dc6e <wc_Sha256Free>:
    }
#endif
#ifdef WOLFSSL_IMXRT_DCP
    DCPSha256Free(sha256);
#endif
}
   1dc6e:	4770      	bx	lr

Disassembly of section .text.__malloc_lock%1318:

00020042 <__malloc_lock>:
   20042:	4770      	bx	lr

Disassembly of section .text.__malloc_unlock%1319:

000209f2 <__malloc_unlock>:
   209f2:	4770      	bx	lr
