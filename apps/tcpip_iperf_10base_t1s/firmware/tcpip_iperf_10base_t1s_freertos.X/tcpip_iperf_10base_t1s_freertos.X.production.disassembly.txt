
.\dist\FreeRTOS\production\tcpip_iperf_10base_t1s_freertos.X.production.elf:     file format elf32-littlearm


Disassembly of section .config_00804000:

00804000 <__config_00804000>:
  804000:	39 12 00 3c                                         9..<

Disassembly of section .config_00804008:

00804008 <__config_00804008>:
  804008:	ff ff ff ff                                         ....

Disassembly of section .config_00804004:

00804004 <__config_00804004>:
  804004:	80 00 a8 2a                                         ...*

Disassembly of section .vectors:

00000000 <exception_table>:
   0:	f0 ff 03 20 5d 85 01 00 93 63 01 00 e3 67 01 00     ... ]....c...g..
  10:	53 73 01 00 df 75 01 00 a7 7c 01 00 00 00 00 00     Ss...u...|......
	...
  2c:	91 04 02 00 bb 6e 01 00 00 00 00 00 f1 af 01 00     .....n..........
  3c:	19 f9 01 00 47 54 01 00 47 54 01 00 47 54 01 00     ....GT..GT..GT..
  4c:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
  5c:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
  6c:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
  7c:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
  8c:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
  9c:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
  ac:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
  bc:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
  cc:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
  dc:	47 54 01 00 47 54 01 00 47 54 01 00 00 00 00 00     GT..GT..GT......
	...
  f4:	47 54 01 00 a5 0c 01 00 a5 0c 01 00 a5 0c 01 00     GT..............
 104:	a5 0c 01 00 45 08 01 00 45 08 01 00 45 08 01 00     ....E...E...E...
 114:	45 08 01 00 47 54 01 00 47 54 01 00 47 54 01 00     E...GT..GT..GT..
 124:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
 134:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
 144:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
 154:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
 164:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
 174:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
 184:	47 54 01 00 47 54 01 00 47 54 01 00 f5 ee 01 00     GT..GT..GT......
 194:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
 1a4:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
 1b4:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
 1c4:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
 1d4:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
 1e4:	47 54 01 00 47 54 01 00 69 f8 01 00 47 54 01 00     GT..GT..i...GT..
 1f4:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
 204:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
 214:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
 224:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
 234:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
 244:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..
 254:	47 54 01 00 47 54 01 00 47 54 01 00 47 54 01 00     GT..GT..GT..GT..

Disassembly of section .text:

00000264 <_init>:
 264:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 266:	bf00      	nop
 268:	bcf8      	pop	{r3, r4, r5, r6, r7}
 26a:	bc08      	pop	{r3}
 26c:	469e      	mov	lr, r3
 26e:	4770      	bx	lr

00000270 <__init_array_start>:
 270:	0001d6b9 	.word	0x0001d6b9

00000274 <_fini>:
 274:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 276:	bf00      	nop
 278:	bcf8      	pop	{r3, r4, r5, r6, r7}
 27a:	bc08      	pop	{r3}
 27c:	469e      	mov	lr, r3
 27e:	4770      	bx	lr

00000280 <__fini_array_start>:
 280:	0001d695 	.word	0x0001d695

Disassembly of section .rodata%187:

0000028c <.rodata%187>:
     28c:	67617355 	.word	0x67617355
     290:	6d203a65 	.word	0x6d203a65
     294:	6e696361 	.word	0x6e696361
     298:	0d206f66 	.word	0x0d206f66
     29c:	0000000a 	.word	0x0000000a
     2a0:	203a7845 	.word	0x203a7845
     2a4:	6963616d 	.word	0x6963616d
     2a8:	206f666e 	.word	0x206f666e
     2ac:	00000a0d 	.word	0x00000a0d
     2b0:	65746e49 	.word	0x65746e49
     2b4:	63616672 	.word	0x63616672
     2b8:	25203a65 	.word	0x25203a65
     2bc:	72442073 	.word	0x72442073
     2c0:	72657669 	.word	0x72657669
     2c4:	61745320 	.word	0x61745320
     2c8:	74736974 	.word	0x74736974
     2cc:	0d736369 	.word	0x0d736369
     2d0:	0000000a 	.word	0x0000000a
     2d4:	52200a0d 	.word	0x52200a0d
     2d8:	69656365 	.word	0x69656365
     2dc:	53206576 	.word	0x53206576
     2e0:	69746174 	.word	0x69746174
     2e4:	63697473 	.word	0x63697473
     2e8:	000a0d73 	.word	0x000a0d73
     2ec:	526e2009 	.word	0x526e2009
     2f0:	506b4f78 	.word	0x506b4f78
     2f4:	656b6361 	.word	0x656b6361
     2f8:	203a7374 	.word	0x203a7374
     2fc:	0a0d6425 	.word	0x0a0d6425
     300:	526e2009 	.word	0x526e2009
     304:	6e655078 	.word	0x6e655078
     308:	66754264 	.word	0x66754264
     30c:	73726566 	.word	0x73726566
     310:	6425203a 	.word	0x6425203a
     314:	20090a0d 	.word	0x20090a0d
     318:	5378526e 	.word	0x5378526e
     31c:	64656863 	.word	0x64656863
     320:	66667542 	.word	0x66667542
     324:	3a737265 	.word	0x3a737265
     328:	0d642520 	.word	0x0d642520
     32c:	0000000a 	.word	0x0000000a
     330:	526e2009 	.word	0x526e2009
     334:	72724578 	.word	0x72724578
     338:	6150726f 	.word	0x6150726f
     33c:	74656b63 	.word	0x74656b63
     340:	25203a73 	.word	0x25203a73
     344:	090a0d64 	.word	0x090a0d64
     348:	78526e20 	.word	0x78526e20
     34c:	67617246 	.word	0x67617246
     350:	746e656d 	.word	0x746e656d
     354:	6f727245 	.word	0x6f727245
     358:	203a7372 	.word	0x203a7372
     35c:	0a0d6425 	.word	0x0a0d6425
     360:	526e2009 	.word	0x526e2009
     364:	66754278 	.word	0x66754278
     368:	746f4e66 	.word	0x746f4e66
     36c:	69617641 	.word	0x69617641
     370:	6c62616c 	.word	0x6c62616c
     374:	25203a65 	.word	0x25203a65
     378:	000a0d64 	.word	0x000a0d64
     37c:	54200a0d 	.word	0x54200a0d
     380:	736e6172 	.word	0x736e6172
     384:	2074696d 	.word	0x2074696d
     388:	74617453 	.word	0x74617453
     38c:	69747369 	.word	0x69747369
     390:	0a0d7363 	.word	0x0a0d7363
     394:	00000000 	.word	0x00000000
     398:	546e2009 	.word	0x546e2009
     39c:	506b4f78 	.word	0x506b4f78
     3a0:	656b6361 	.word	0x656b6361
     3a4:	203a7374 	.word	0x203a7374
     3a8:	0a0d6425 	.word	0x0a0d6425
     3ac:	546e2009 	.word	0x546e2009
     3b0:	6e655078 	.word	0x6e655078
     3b4:	66754264 	.word	0x66754264
     3b8:	73726566 	.word	0x73726566
     3bc:	6425203a 	.word	0x6425203a
     3c0:	20090a0d 	.word	0x20090a0d
     3c4:	4578546e 	.word	0x4578546e
     3c8:	726f7272 	.word	0x726f7272
     3cc:	6b636150 	.word	0x6b636150
     3d0:	3a737465 	.word	0x3a737465
     3d4:	0d642520 	.word	0x0d642520
     3d8:	6e20090a 	.word	0x6e20090a
     3dc:	75517854 	.word	0x75517854
     3e0:	46657565 	.word	0x46657565
     3e4:	3a6c6c75 	.word	0x3a6c6c75
     3e8:	0d642520 	.word	0x0d642520
     3ec:	000a0d0a 	.word	0x000a0d0a
     3f0:	746f6e09 	.word	0x746f6e09
     3f4:	70757320 	.word	0x70757320
     3f8:	74726f70 	.word	0x74726f70
     3fc:	0a0d6465 	.word	0x0a0d6465
     400:	00000000 	.word	0x00000000
     404:	65746e49 	.word	0x65746e49
     408:	63616672 	.word	0x63616672
     40c:	25203a65 	.word	0x25203a65
     410:	61482073 	.word	0x61482073
     414:	61776472 	.word	0x61776472
     418:	52206572 	.word	0x52206572
     41c:	73696765 	.word	0x73696765
     420:	20726574 	.word	0x20726574
     424:	74617453 	.word	0x74617453
     428:	0a0d7375 	.word	0x0a0d7375
     42c:	00000000 	.word	0x00000000
     430:	73252009 	.word	0x73252009
     434:	7830203a 	.word	0x7830203a
     438:	0a0d7825 	.word	0x0a0d7825
     43c:	00000000 	.word	0x00000000
     440:	61736964 	.word	0x61736964
     444:	64656c62 	.word	0x64656c62
     448:	00000000 	.word	0x00000000
     44c:	61736964 	.word	0x61736964
     450:	00656c62 	.word	0x00656c62
     454:	62616e65 	.word	0x62616e65
     458:	0064656c 	.word	0x0064656c
     45c:	62616e65 	.word	0x62616e65
     460:	0000656c 	.word	0x0000656c
     464:	67617355 	.word	0x67617355
     468:	25203a65 	.word	0x25203a65
     46c:	693c2073 	.word	0x693c2073
     470:	7265746e 	.word	0x7265746e
     474:	65636166 	.word	0x65636166
     478:	6f3c203e 	.word	0x6f3c203e
     47c:	666f2f6e 	.word	0x666f2f6e
     480:	0d203e66 	.word	0x0d203e66
     484:	0000000a 	.word	0x0000000a
     488:	203a7845 	.word	0x203a7845
     48c:	50207325 	.word	0x50207325
     490:	32334349 	.word	0x32334349
     494:	20544e49 	.word	0x20544e49
     498:	0d206e6f 	.word	0x0d206e6f
     49c:	0000000a 	.word	0x0000000a
     4a0:	6e6b6e55 	.word	0x6e6b6e55
     4a4:	206e776f 	.word	0x206e776f
     4a8:	65746e69 	.word	0x65746e69
     4ac:	63616672 	.word	0x63616672
     4b0:	000a0d65 	.word	0x000a0d65
     4b4:	00006e6f 	.word	0x00006e6f
     4b8:	0066666f 	.word	0x0066666f
     4bc:	6e6b6e55 	.word	0x6e6b6e55
     4c0:	206e776f 	.word	0x206e776f
     4c4:	6974706f 	.word	0x6974706f
     4c8:	0a0d6e6f 	.word	0x0a0d6e6f
     4cc:	00000000 	.word	0x00000000
     4d0:	25207325 	.word	0x25207325
     4d4:	000a0d73 	.word	0x000a0d73
     4d8:	6c696146 	.word	0x6c696146
     4dc:	74206465 	.word	0x74206465
     4e0:	7325206f 	.word	0x7325206f
     4e4:	0d732520 	.word	0x0d732520
     4e8:	0000000a 	.word	0x0000000a
     4ec:	6e6b6e55 	.word	0x6e6b6e55
     4f0:	206e776f 	.word	0x206e776f
     4f4:	76726573 	.word	0x76726573
     4f8:	20656369 	.word	0x20656369
     4fc:	0a0d7325 	.word	0x0a0d7325
     500:	00000000 	.word	0x00000000
     504:	656e6f6e 	.word	0x656e6f6e
     508:	00000000 	.word	0x00000000
     50c:	00001774 	.word	0x00001774
     510:	00000001 	.word	0x00000001
     514:	00001290 	.word	0x00001290
     518:	00000002 	.word	0x00000002
     51c:	000004b4 	.word	0x000004b4
     520:	00000003 	.word	0x00000003
     524:	000004b8 	.word	0x000004b8
     528:	00000003 	.word	0x00000003
     52c:	00001778 	.word	0x00001778
     530:	00000004 	.word	0x00000004
     534:	67617355 	.word	0x67617355
     538:	64203a65 	.word	0x64203a65
     53c:	2063736e 	.word	0x2063736e
     540:	6c65643c 	.word	0x6c65643c
     544:	666e692f 	.word	0x666e692f
     548:	6e6f2f6f 	.word	0x6e6f2f6f
     54c:	66666f2f 	.word	0x66666f2f
     550:	6f6f6c2f 	.word	0x6f6f6c2f
     554:	3e70756b 	.word	0x3e70756b
     558:	000a0d20 	.word	0x000a0d20
     55c:	67617355 	.word	0x67617355
     560:	25203a65 	.word	0x25203a65
     564:	6f3c2073 	.word	0x6f3c2073
     568:	666f2f6e 	.word	0x666f2f6e
     56c:	3c203e66 	.word	0x3c203e66
     570:	65746e69 	.word	0x65746e69
     574:	63616672 	.word	0x63616672
     578:	3c203e65 	.word	0x3c203e65
     57c:	69727473 	.word	0x69727473
     580:	702f7463 	.word	0x702f7463
     584:	3e666572 	.word	0x3e666572
     588:	6c633c2f 	.word	0x6c633c2f
     58c:	3e726165 	.word	0x3e726165
     590:	000a0d20 	.word	0x000a0d20
     594:	203a7845 	.word	0x203a7845
     598:	6f207325 	.word	0x6f207325
     59c:	7465206e 	.word	0x7465206e
     5a0:	0a0d3068 	.word	0x0a0d3068
     5a4:	00000000 	.word	0x00000000
     5a8:	69727473 	.word	0x69727473
     5ac:	00007463 	.word	0x00007463
     5b0:	66657270 	.word	0x66657270
     5b4:	00000000 	.word	0x00000000
     5b8:	61656c63 	.word	0x61656c63
     5bc:	00000072 	.word	0x00000072
     5c0:	67617355 	.word	0x67617355
     5c4:	64203a65 	.word	0x64203a65
     5c8:	2063736e 	.word	0x2063736e
     5cc:	6b6f6f6c 	.word	0x6b6f6f6c
     5d0:	3c207075 	.word	0x3c207075
     5d4:	65707974 	.word	0x65707974
     5d8:	683c203e 	.word	0x683c203e
     5dc:	4e74736f 	.word	0x4e74736f
     5e0:	3e656d61 	.word	0x3e656d61
     5e4:	000a0d20 	.word	0x000a0d20
     5e8:	706c6548 	.word	0x706c6548
     5ec:	683c203a 	.word	0x683c203a
     5f0:	4e74736f 	.word	0x4e74736f
     5f4:	3e656d61 	.word	0x3e656d61
     5f8:	4c525528 	.word	0x4c525528
     5fc:	202d2029 	.word	0x202d2029
     600:	6b6f6f6c 	.word	0x6b6f6f6c
     604:	20707520 	.word	0x20707520
     608:	20726f66 	.word	0x20726f66
     60c:	74736f68 	.word	0x74736f68
     610:	656d616e 	.word	0x656d616e
     614:	00000a0d 	.word	0x00000a0d
     618:	706c6548 	.word	0x706c6548
     61c:	743c203a 	.word	0x743c203a
     620:	3e657079 	.word	0x3e657079
     624:	61203a20 	.word	0x61203a20
     628:	20726f20 	.word	0x20726f20
     62c:	6f662041 	.word	0x6f662041
     630:	50492072 	.word	0x50492072
     634:	61203476 	.word	0x61203476
     638:	65726464 	.word	0x65726464
     63c:	6c207373 	.word	0x6c207373
     640:	756b6f6f 	.word	0x756b6f6f
     644:	000a0d70 	.word	0x000a0d70
     648:	706c6548 	.word	0x706c6548
     64c:	743c203a 	.word	0x743c203a
     650:	3e657079 	.word	0x3e657079
     654:	61203a20 	.word	0x61203a20
     658:	20616161 	.word	0x20616161
     65c:	4120726f 	.word	0x4120726f
     660:	20414141 	.word	0x20414141
     664:	20726f66 	.word	0x20726f66
     668:	36765049 	.word	0x36765049
     66c:	64646120 	.word	0x64646120
     670:	73736572 	.word	0x73736572
     674:	6f6f6c20 	.word	0x6f6f6c20
     678:	0d70756b 	.word	0x0d70756b
     67c:	0000000a 	.word	0x0000000a
     680:	706c6548 	.word	0x706c6548
     684:	743c203a 	.word	0x743c203a
     688:	3e657079 	.word	0x3e657079
     68c:	61203a20 	.word	0x61203a20
     690:	6620796e 	.word	0x6620796e
     694:	6220726f 	.word	0x6220726f
     698:	2068746f 	.word	0x2068746f
     69c:	34765049 	.word	0x34765049
     6a0:	646e6120 	.word	0x646e6120
     6a4:	76504920 	.word	0x76504920
     6a8:	64612036 	.word	0x64612036
     6ac:	73657264 	.word	0x73657264
     6b0:	6f6c2073 	.word	0x6f6c2073
     6b4:	70756b6f 	.word	0x70756b6f
     6b8:	00000a0d 	.word	0x00000a0d
     6bc:	63736e64 	.word	0x63736e64
     6c0:	6f6f6c20 	.word	0x6f6f6c20
     6c4:	3a70756b 	.word	0x3a70756b
     6c8:	6d6f6320 	.word	0x6d6f6320
     6cc:	646e616d 	.word	0x646e616d
     6d0:	206e6920 	.word	0x206e6920
     6d4:	676f7270 	.word	0x676f7270
     6d8:	73736572 	.word	0x73736572
     6dc:	6552202e 	.word	0x6552202e
     6e0:	20797274 	.word	0x20797274
     6e4:	6574616c 	.word	0x6574616c
     6e8:	0a0d2e72 	.word	0x0a0d2e72
     6ec:	00000000 	.word	0x00000000
     6f0:	00000041 	.word	0x00000041
     6f4:	00000061 	.word	0x00000061
     6f8:	41414141 	.word	0x41414141
     6fc:	00000000 	.word	0x00000000
     700:	61616161 	.word	0x61616161
     704:	00000000 	.word	0x00000000
     708:	00594e41 	.word	0x00594e41
     70c:	00796e61 	.word	0x00796e61
     710:	63736e64 	.word	0x63736e64
     714:	6f6f6c20 	.word	0x6f6f6c20
     718:	3a70756b 	.word	0x3a70756b
     71c:	73255b20 	.word	0x73255b20
     720:	6f4c205d 	.word	0x6f4c205d
     724:	70756b6f 	.word	0x70756b6f
     728:	70795420 	.word	0x70795420
     72c:	6f6e2065 	.word	0x6f6e2065
     730:	75732074 	.word	0x75732074
     734:	726f7070 	.word	0x726f7070
     738:	2e646574 	.word	0x2e646574
     73c:	00000a0d 	.word	0x00000a0d
     740:	63736e64 	.word	0x63736e64
     744:	6f6f6c20 	.word	0x6f6f6c20
     748:	3a70756b 	.word	0x3a70756b
     74c:	736f4820 	.word	0x736f4820
     750:	616e2074 	.word	0x616e2074
     754:	7420656d 	.word	0x7420656d
     758:	6c206f6f 	.word	0x6c206f6f
     75c:	2e676e6f 	.word	0x2e676e6f
     760:	74655220 	.word	0x74655220
     764:	0d2e7972 	.word	0x0d2e7972
     768:	0000000a 	.word	0x0000000a
     76c:	63736e64 	.word	0x63736e64
     770:	6f6f6c20 	.word	0x6f6f6c20
     774:	3a70756b 	.word	0x3a70756b
     778:	73657220 	.word	0x73657220
     77c:	69766c6f 	.word	0x69766c6f
     780:	6820676e 	.word	0x6820676e
     784:	3a74736f 	.word	0x3a74736f
     788:	20732520 	.word	0x20732520
     78c:	20726f66 	.word	0x20726f66
     790:	65707974 	.word	0x65707974
     794:	2073253a 	.word	0x2073253a
     798:	00000a0d 	.word	0x00000a0d
     79c:	67617355 	.word	0x67617355
     7a0:	64203a65 	.word	0x64203a65
     7a4:	2063736e 	.word	0x2063736e
     7a8:	206c6564 	.word	0x206c6564
     7ac:	736f683c 	.word	0x736f683c
     7b0:	6d614e74 	.word	0x6d614e74
     7b4:	617c3e65 	.word	0x617c3e65
     7b8:	0d206c6c 	.word	0x0d206c6c
     7bc:	0000000a 	.word	0x0000000a
     7c0:	706c6548 	.word	0x706c6548
     7c4:	683c203a 	.word	0x683c203a
     7c8:	4e74736f 	.word	0x4e74736f
     7cc:	3e656d61 	.word	0x3e656d61
     7d0:	4c525528 	.word	0x4c525528
     7d4:	202d2029 	.word	0x202d2029
     7d8:	6f6d6552 	.word	0x6f6d6552
     7dc:	74206576 	.word	0x74206576
     7e0:	65206568 	.word	0x65206568
     7e4:	7972746e 	.word	0x7972746e
     7e8:	20666920 	.word	0x20666920
     7ec:	73697865 	.word	0x73697865
     7f0:	0d207374 	.word	0x0d207374
     7f4:	0000000a 	.word	0x0000000a
     7f8:	706c6548 	.word	0x706c6548
     7fc:	6c61203a 	.word	0x6c61203a
     800:	202d206c 	.word	0x202d206c
     804:	6f6d6552 	.word	0x6f6d6552
     808:	61206576 	.word	0x61206576
     80c:	74206c6c 	.word	0x74206c6c
     810:	72206568 	.word	0x72206568
     814:	6c6f7365 	.word	0x6c6f7365
     818:	20646576 	.word	0x20646576
     81c:	72746e65 	.word	0x72746e65
     820:	0a0d2079 	.word	0x0a0d2079
     824:	00000000 	.word	0x00000000
     828:	006c6c61 	.word	0x006c6c61
     82c:	5d73255b 	.word	0x5d73255b
     830:	746f6e20 	.word	0x746f6e20
     834:	72617020 	.word	0x72617020
     838:	666f2074 	.word	0x666f2074
     83c:	65687420 	.word	0x65687420
     840:	534e4420 	.word	0x534e4420
     844:	63614320 	.word	0x63614320
     848:	65206568 	.word	0x65206568
     84c:	7972746e 	.word	0x7972746e
     850:	000a0d20 	.word	0x000a0d20
     854:	6f636e49 	.word	0x6f636e49
     858:	656c706d 	.word	0x656c706d
     85c:	63206574 	.word	0x63206574
     860:	616d6d6f 	.word	0x616d6d6f
     864:	0d20646e 	.word	0x0d20646e
     868:	0000000a 	.word	0x0000000a
     86c:	67617355 	.word	0x67617355
     870:	64203a65 	.word	0x64203a65
     874:	2063736e 	.word	0x2063736e
     878:	6f666e69 	.word	0x6f666e69
     87c:	000a0d20 	.word	0x000a0d20
     880:	706c6548 	.word	0x706c6548
     884:	6964203a 	.word	0x6964203a
     888:	616c7073 	.word	0x616c7073
     88c:	68742079 	.word	0x68742079
     890:	4e442065 	.word	0x4e442065
     894:	61632053 	.word	0x61632053
     898:	20656863 	.word	0x20656863
     89c:	72746e65 	.word	0x72746e65
     8a0:	65642079 	.word	0x65642079
     8a4:	6c696174 	.word	0x6c696174
     8a8:	0a0d2073 	.word	0x0a0d2073
     8ac:	00000000 	.word	0x00000000
     8b0:	20534e44 	.word	0x20534e44
     8b4:	65696c43 	.word	0x65696c43
     8b8:	6920746e 	.word	0x6920746e
     8bc:	6f642073 	.word	0x6f642073
     8c0:	0d216e77 	.word	0x0d216e77
     8c4:	0000000a 	.word	0x0000000a
     8c8:	20534e44 	.word	0x20534e44
     8cc:	65696c43 	.word	0x65696c43
     8d0:	4920746e 	.word	0x4920746e
     8d4:	202d2046 	.word	0x202d2046
     8d8:	69727453 	.word	0x69727453
     8dc:	203a7463 	.word	0x203a7463
     8e0:	202c7325 	.word	0x202c7325
     8e4:	66657250 	.word	0x66657250
     8e8:	65727265 	.word	0x65727265
     8ec:	25203a64 	.word	0x25203a64
     8f0:	000a0d73 	.word	0x000a0d73
     8f4:	20534e44 	.word	0x20534e44
     8f8:	65696c43 	.word	0x65696c43
     8fc:	2d20746e 	.word	0x2d20746e
     900:	6d697420 	.word	0x6d697420
     904:	25203a65 	.word	0x25203a65
     908:	70202c64 	.word	0x70202c64
     90c:	69646e65 	.word	0x69646e65
     910:	203a676e 	.word	0x203a676e
     914:	202c6425 	.word	0x202c6425
     918:	72727563 	.word	0x72727563
     91c:	3a746e65 	.word	0x3a746e65
     920:	2c642520 	.word	0x2c642520
     924:	746f7420 	.word	0x746f7420
     928:	203a6c61 	.word	0x203a6c61
     92c:	0a0d6425 	.word	0x0a0d6425
     930:	00000000 	.word	0x00000000
     934:	74736f48 	.word	0x74736f48
     938:	656d616e 	.word	0x656d616e
     93c:	25203d20 	.word	0x25203d20
     940:	0a0d2073 	.word	0x0a0d2073
     944:	656d6954 	.word	0x656d6954
     948:	2074756f 	.word	0x2074756f
     94c:	6425203d 	.word	0x6425203d
     950:	000a0d20 	.word	0x000a0d20
     954:	34765049 	.word	0x34765049
     958:	73253d20 	.word	0x73253d20
     95c:	00000a0d 	.word	0x00000a0d
     960:	36765049 	.word	0x36765049
     964:	25203d20 	.word	0x25203d20
     968:	000a0d73 	.word	0x000a0d73
     96c:	2d2d2d2d 	.word	0x2d2d2d2d
     970:	2d2d2d2d 	.word	0x2d2d2d2d
     974:	2d2d2d2d 	.word	0x2d2d2d2d
     978:	2d2d2d2d 	.word	0x2d2d2d2d
     97c:	2d2d2d2d 	.word	0x2d2d2d2d
     980:	2d2d2d2d 	.word	0x2d2d2d2d
     984:	2d2d2d2d 	.word	0x2d2d2d2d
     988:	2d2d2d2d 	.word	0x2d2d2d2d
     98c:	2d2d2d2d 	.word	0x2d2d2d2d
     990:	2d2d2d2d 	.word	0x2d2d2d2d
     994:	2d2d2d2d 	.word	0x2d2d2d2d
     998:	2d2d2d2d 	.word	0x2d2d2d2d
     99c:	2d2d2d2d 	.word	0x2d2d2d2d
     9a0:	00000a0d 	.word	0x00000a0d
     9a4:	44206f4e 	.word	0x44206f4e
     9a8:	4320534e 	.word	0x4320534e
     9ac:	6e65696c 	.word	0x6e65696c
     9b0:	61432074 	.word	0x61432074
     9b4:	20656863 	.word	0x20656863
     9b8:	72746e65 	.word	0x72746e65
     9bc:	20736569 	.word	0x20736569
     9c0:	00000a0d 	.word	0x00000a0d
     9c4:	61766e49 	.word	0x61766e49
     9c8:	2064696c 	.word	0x2064696c
     9cc:	75706e49 	.word	0x75706e49
     9d0:	6f432074 	.word	0x6f432074
     9d4:	6e616d6d 	.word	0x6e616d6d
     9d8:	5b3a2064 	.word	0x5b3a2064
     9dc:	20732520 	.word	0x20732520
     9e0:	0a0d205d 	.word	0x0a0d205d
     9e4:	00000000 	.word	0x00000000
     9e8:	676e6950 	.word	0x676e6950
     9ec:	6f64203a 	.word	0x6f64203a
     9f0:	202e656e 	.word	0x202e656e
     9f4:	746e6553 	.word	0x746e6553
     9f8:	20642520 	.word	0x20642520
     9fc:	75716572 	.word	0x75716572
     a00:	73747365 	.word	0x73747365
     a04:	6572202c 	.word	0x6572202c
     a08:	76696563 	.word	0x76696563
     a0c:	25206465 	.word	0x25206465
     a10:	65722064 	.word	0x65722064
     a14:	65696c70 	.word	0x65696c70
     a18:	0a0d2e73 	.word	0x0a0d2e73
     a1c:	00000000 	.word	0x00000000
     a20:	676e6950 	.word	0x676e6950
     a24:	61735520 	.word	0x61735520
     a28:	203a6567 	.word	0x203a6567
     a2c:	676e6970 	.word	0x676e6970
     a30:	74733c20 	.word	0x74733c20
     a34:	2f3e706f 	.word	0x2f3e706f
     a38:	6d616e3c 	.word	0x6d616e3c
     a3c:	64612f65 	.word	0x64612f65
     a40:	73657264 	.word	0x73657264
     a44:	3c203e73 	.word	0x3c203e73
     a48:	6e692069 	.word	0x6e692069
     a4c:	66726574 	.word	0x66726574
     a50:	3e656361 	.word	0x3e656361
     a54:	206e3c20 	.word	0x206e3c20
     a58:	6e69506e 	.word	0x6e69506e
     a5c:	203e7367 	.word	0x203e7367
     a60:	6d20743c 	.word	0x6d20743c
     a64:	72655073 	.word	0x72655073
     a68:	3e646f69 	.word	0x3e646f69
     a6c:	20733c20 	.word	0x20733c20
     a70:	657a6973 	.word	0x657a6973
     a74:	000a0d3e 	.word	0x000a0d3e
     a78:	706f7473 	.word	0x706f7473
     a7c:	00000000 	.word	0x00000000
     a80:	676e6950 	.word	0x676e6950
     a84:	6f63203a 	.word	0x6f63203a
     a88:	6e616d6d 	.word	0x6e616d6d
     a8c:	6e692064 	.word	0x6e692064
     a90:	6f727020 	.word	0x6f727020
     a94:	73657267 	.word	0x73657267
     a98:	52202e73 	.word	0x52202e73
     a9c:	79727465 	.word	0x79727465
     aa0:	74616c20 	.word	0x74616c20
     aa4:	0d2e7265 	.word	0x0d2e7265
     aa8:	0000000a 	.word	0x0000000a
     aac:	676e6950 	.word	0x676e6950
     ab0:	6f48203a 	.word	0x6f48203a
     ab4:	6e207473 	.word	0x6e207473
     ab8:	20656d61 	.word	0x20656d61
     abc:	206f6f74 	.word	0x206f6f74
     ac0:	676e6f6c 	.word	0x676e6f6c
     ac4:	6552202e 	.word	0x6552202e
     ac8:	2e797274 	.word	0x2e797274
     acc:	00000a0d 	.word	0x00000a0d
     ad0:	00000069 	.word	0x00000069
     ad4:	0000006e 	.word	0x0000006e
     ad8:	00000074 	.word	0x00000074
     adc:	00000073 	.word	0x00000073
     ae0:	676e6950 	.word	0x676e6950
     ae4:	6144203a 	.word	0x6144203a
     ae8:	73206174 	.word	0x73206174
     aec:	20657a69 	.word	0x20657a69
     af0:	206f6f74 	.word	0x206f6f74
     af4:	2e676962 	.word	0x2e676962
     af8:	78614d20 	.word	0x78614d20
     afc:	6425203a 	.word	0x6425203a
     b00:	6552202e 	.word	0x6552202e
     b04:	0d797274 	.word	0x0d797274
     b08:	0000000a 	.word	0x0000000a
     b0c:	676e6950 	.word	0x676e6950
     b10:	6e55203a 	.word	0x6e55203a
     b14:	776f6e6b 	.word	0x776f6e6b
     b18:	6170206e 	.word	0x6170206e
     b1c:	656d6172 	.word	0x656d6172
     b20:	0d726574 	.word	0x0d726574
     b24:	0000000a 	.word	0x0000000a
     b28:	676e6950 	.word	0x676e6950
     b2c:	6572203a 	.word	0x6572203a
     b30:	766c6f73 	.word	0x766c6f73
     b34:	20676e69 	.word	0x20676e69
     b38:	74736f68 	.word	0x74736f68
     b3c:	7325203a 	.word	0x7325203a
     b40:	00000a0d 	.word	0x00000a0d
     b44:	6e6b6e55 	.word	0x6e6b6e55
     b48:	206e776f 	.word	0x206e776f
     b4c:	70616568 	.word	0x70616568
     b50:	70797420 	.word	0x70797420
     b54:	55202e65 	.word	0x55202e65
     b58:	203a6573 	.word	0x203a6573
     b5c:	202c315b 	.word	0x202c315b
     b60:	0d5d6425 	.word	0x0d5d6425
     b64:	0000000a 	.word	0x0000000a
     b68:	68206f4e 	.word	0x68206f4e
     b6c:	20706165 	.word	0x20706165
     b70:	6f666e69 	.word	0x6f666e69
     b74:	69786520 	.word	0x69786520
     b78:	20737473 	.word	0x20737473
     b7c:	20726f66 	.word	0x20726f66
     b80:	65707974 	.word	0x65707974
     b84:	7325203a 	.word	0x7325203a
     b88:	000a0d21 	.word	0x000a0d21
     b8c:	70616548 	.word	0x70616548
     b90:	70797420 	.word	0x70797420
     b94:	25203a65 	.word	0x25203a65
     b98:	49202e73 	.word	0x49202e73
     b9c:	6974696e 	.word	0x6974696e
     ba0:	63206c61 	.word	0x63206c61
     ba4:	74616572 	.word	0x74616572
     ba8:	68206465 	.word	0x68206465
     bac:	20706165 	.word	0x20706165
     bb0:	657a6973 	.word	0x657a6973
     bb4:	6425203a 	.word	0x6425203a
     bb8:	74794220 	.word	0x74794220
     bbc:	0a0d7365 	.word	0x0a0d7365
     bc0:	00000000 	.word	0x00000000
     bc4:	6f6c6c41 	.word	0x6f6c6c41
     bc8:	6c626163 	.word	0x6c626163
     bcc:	6c622065 	.word	0x6c622065
     bd0:	206b636f 	.word	0x206b636f
     bd4:	70616568 	.word	0x70616568
     bd8:	7a697320 	.word	0x7a697320
     bdc:	25203a65 	.word	0x25203a65
     be0:	79422064 	.word	0x79422064
     be4:	0d736574 	.word	0x0d736574
     be8:	0000000a 	.word	0x0000000a
     bec:	206c6c41 	.word	0x206c6c41
     bf0:	69617661 	.word	0x69617661
     bf4:	6c62616c 	.word	0x6c62616c
     bf8:	65682065 	.word	0x65682065
     bfc:	73207061 	.word	0x73207061
     c00:	3a657a69 	.word	0x3a657a69
     c04:	20642520 	.word	0x20642520
     c08:	65747942 	.word	0x65747942
     c0c:	68202c73 	.word	0x68202c73
     c10:	20686769 	.word	0x20686769
     c14:	65746177 	.word	0x65746177
     c18:	72616d72 	.word	0x72616d72
     c1c:	25203a6b 	.word	0x25203a6b
     c20:	000a0d64 	.word	0x000a0d64
     c24:	7473614c 	.word	0x7473614c
     c28:	61656820 	.word	0x61656820
     c2c:	72652070 	.word	0x72652070
     c30:	3a726f72 	.word	0x3a726f72
     c34:	25783020 	.word	0x25783020
     c38:	000a0d78 	.word	0x000a0d78
     c3c:	54206f4e 	.word	0x54206f4e
     c40:	65636172 	.word	0x65636172
     c44:	666e6920 	.word	0x666e6920
     c48:	7865206f 	.word	0x7865206f
     c4c:	73747369 	.word	0x73747369
     c50:	000a0d2e 	.word	0x000a0d2e
     c54:	63617453 	.word	0x63617453
     c58:	7075206b 	.word	0x7075206b
     c5c:	69616620 	.word	0x69616620
     c60:	0d64656c 	.word	0x0d64656c
     c64:	0000000a 	.word	0x0000000a
     c68:	63617453 	.word	0x63617453
     c6c:	7075206b 	.word	0x7075206b
     c70:	63757320 	.word	0x63757320
     c74:	64656563 	.word	0x64656563
     c78:	0a0d6465 	.word	0x0a0d6465
     c7c:	00000000 	.word	0x00000000
     c80:	67617355 	.word	0x67617355
     c84:	73203a65 	.word	0x73203a65
     c88:	6b636174 	.word	0x6b636174
     c8c:	70753c20 	.word	0x70753c20
     c90:	776f642f 	.word	0x776f642f
     c94:	3c203e6e 	.word	0x3c203e6e
     c98:	73657270 	.word	0x73657270
     c9c:	65767265 	.word	0x65767265
     ca0:	000a0d3e 	.word	0x000a0d3e
     ca4:	203a7845 	.word	0x203a7845
     ca8:	63617473 	.word	0x63617473
     cac:	6f64206b 	.word	0x6f64206b
     cb0:	70206e77 	.word	0x70206e77
     cb4:	65736572 	.word	0x65736572
     cb8:	0d657672 	.word	0x0d657672
     cbc:	0000000a 	.word	0x0000000a
     cc0:	00007075 	.word	0x00007075
     cc4:	63617453 	.word	0x63617453
     cc8:	6c61206b 	.word	0x6c61206b
     ccc:	64616572 	.word	0x64616572
     cd0:	70752079 	.word	0x70752079
     cd4:	000a0d21 	.word	0x000a0d21
     cd8:	6e727554 	.word	0x6e727554
     cdc:	61745320 	.word	0x61745320
     ce0:	64206b63 	.word	0x64206b63
     ce4:	206e776f 	.word	0x206e776f
     ce8:	20646e61 	.word	0x20646e61
     cec:	6e656874 	.word	0x6e656874
     cf0:	21707520 	.word	0x21707520
     cf4:	00000a0d 	.word	0x00000a0d
     cf8:	74736552 	.word	0x74736552
     cfc:	69747261 	.word	0x69747261
     d00:	7420676e 	.word	0x7420676e
     d04:	73206568 	.word	0x73206568
     d08:	6b636174 	.word	0x6b636174
     d0c:	74697720 	.word	0x74697720
     d10:	64252068 	.word	0x64252068
     d14:	746e6920 	.word	0x746e6920
     d18:	61667265 	.word	0x61667265
     d1c:	73286563 	.word	0x73286563
     d20:	000a0d29 	.word	0x000a0d29
     d24:	6e776f64 	.word	0x6e776f64
     d28:	00000000 	.word	0x00000000
     d2c:	63617453 	.word	0x63617453
     d30:	6f64206b 	.word	0x6f64206b
     d34:	203a6e77 	.word	0x203a6e77
     d38:	6e6e6163 	.word	0x6e6e6163
     d3c:	6720746f 	.word	0x6720746f
     d40:	61207465 	.word	0x61207465
     d44:	61747320 	.word	0x61747320
     d48:	68206b63 	.word	0x68206b63
     d4c:	6c646e61 	.word	0x6c646e61
     d50:	000a0d65 	.word	0x000a0d65
     d54:	63617453 	.word	0x63617453
     d58:	6f64206b 	.word	0x6f64206b
     d5c:	73206e77 	.word	0x73206e77
     d60:	65636375 	.word	0x65636375
     d64:	64656465 	.word	0x64656465
     d68:	00000a0d 	.word	0x00000a0d
     d6c:	67617355 	.word	0x67617355
     d70:	69203a65 	.word	0x69203a65
     d74:	693c2066 	.word	0x693c2066
     d78:	7265746e 	.word	0x7265746e
     d7c:	65636166 	.word	0x65636166
     d80:	643c203e 	.word	0x643c203e
     d84:	2f6e776f 	.word	0x2f6e776f
     d88:	203e7075 	.word	0x203e7075
     d8c:	00000a0d 	.word	0x00000a0d
     d90:	203a7845 	.word	0x203a7845
     d94:	50206669 	.word	0x50206669
     d98:	32334349 	.word	0x32334349
     d9c:	20544e49 	.word	0x20544e49
     da0:	6e776f64 	.word	0x6e776f64
     da4:	000a0d20 	.word	0x000a0d20
     da8:	6e6b6e55 	.word	0x6e6b6e55
     dac:	206e776f 	.word	0x206e776f
     db0:	65746e69 	.word	0x65746e69
     db4:	63616672 	.word	0x63616672
     db8:	70732065 	.word	0x70732065
     dbc:	66696365 	.word	0x66696365
     dc0:	20646569 	.word	0x20646569
     dc4:	00000a0d 	.word	0x00000a0d
     dc8:	73696854 	.word	0x73696854
     dcc:	746e6920 	.word	0x746e6920
     dd0:	61667265 	.word	0x61667265
     dd4:	61206563 	.word	0x61206563
     dd8:	6165726c 	.word	0x6165726c
     ddc:	75207964 	.word	0x75207964
     de0:	000a0d70 	.word	0x000a0d70
     de4:	7265704f 	.word	0x7265704f
     de8:	6f697461 	.word	0x6f697461
     dec:	6166206e 	.word	0x6166206e
     df0:	64656c69 	.word	0x64656c69
     df4:	6f4e202e 	.word	0x6f4e202e
     df8:	6e6f6320 	.word	0x6e6f6320
     dfc:	75676966 	.word	0x75676966
     e00:	69746172 	.word	0x69746172
     e04:	0a0d6e6f 	.word	0x0a0d6e6f
     e08:	00000000 	.word	0x00000000
     e0c:	6c6c7566 	.word	0x6c6c7566
     e10:	00000000 	.word	0x00000000
     e14:	73696854 	.word	0x73696854
     e18:	746e6920 	.word	0x746e6920
     e1c:	61667265 	.word	0x61667265
     e20:	61206563 	.word	0x61206563
     e24:	6165726c 	.word	0x6165726c
     e28:	64207964 	.word	0x64207964
     e2c:	0d6e776f 	.word	0x0d6e776f
     e30:	0000000a 	.word	0x0000000a
     e34:	6e6f7257 	.word	0x6e6f7257
     e38:	61702067 	.word	0x61702067
     e3c:	656d6172 	.word	0x656d6172
     e40:	20726574 	.word	0x20726574
     e44:	63657073 	.word	0x63657073
     e48:	65696669 	.word	0x65696669
     e4c:	0a0d2064 	.word	0x0a0d2064
     e50:	00000000 	.word	0x00000000
     e54:	7265704f 	.word	0x7265704f
     e58:	6f697461 	.word	0x6f697461
     e5c:	7573206e 	.word	0x7573206e
     e60:	73656363 	.word	0x73656363
     e64:	6c756673 	.word	0x6c756673
     e68:	000a0d21 	.word	0x000a0d21
     e6c:	7265704f 	.word	0x7265704f
     e70:	6f697461 	.word	0x6f697461
     e74:	6166206e 	.word	0x6166206e
     e78:	64656c69 	.word	0x64656c69
     e7c:	000a0d21 	.word	0x000a0d21
     e80:	67617355 	.word	0x67617355
     e84:	73203a65 	.word	0x73203a65
     e88:	616d7465 	.word	0x616d7465
     e8c:	693c2063 	.word	0x693c2063
     e90:	7265746e 	.word	0x7265746e
     e94:	65636166 	.word	0x65636166
     e98:	783c203e 	.word	0x783c203e
     e9c:	783a783a 	.word	0x783a783a
     ea0:	783a783a 	.word	0x783a783a
     ea4:	203e783a 	.word	0x203e783a
     ea8:	00000a0d 	.word	0x00000a0d
     eac:	203a7845 	.word	0x203a7845
     eb0:	6d746573 	.word	0x6d746573
     eb4:	50206361 	.word	0x50206361
     eb8:	32334349 	.word	0x32334349
     ebc:	20544e49 	.word	0x20544e49
     ec0:	623a6161 	.word	0x623a6161
     ec4:	63633a62 	.word	0x63633a62
     ec8:	3a64643a 	.word	0x3a64643a
     ecc:	663a6565 	.word	0x663a6565
     ed0:	0a0d2066 	.word	0x0a0d2066
     ed4:	00000000 	.word	0x00000000
     ed8:	76677261 	.word	0x76677261
     edc:	3a5d325b 	.word	0x3a5d325b
     ee0:	0d732520 	.word	0x0d732520
     ee4:	0000000a 	.word	0x0000000a
     ee8:	61766e49 	.word	0x61766e49
     eec:	2064696c 	.word	0x2064696c
     ef0:	2043414d 	.word	0x2043414d
     ef4:	72646461 	.word	0x72646461
     ef8:	20737365 	.word	0x20737365
     efc:	69727473 	.word	0x69727473
     f00:	0d20676e 	.word	0x0d20676e
     f04:	0000000a 	.word	0x0000000a
     f08:	20746553 	.word	0x20746553
     f0c:	2043414d 	.word	0x2043414d
     f10:	72646461 	.word	0x72646461
     f14:	20737365 	.word	0x20737365
     f18:	6c696166 	.word	0x6c696166
     f1c:	0a0d6465 	.word	0x0a0d6465
     f20:	00000000 	.word	0x00000000
     f24:	20746553 	.word	0x20746553
     f28:	534f4942 	.word	0x534f4942
     f2c:	6d614e20 	.word	0x6d614e20
     f30:	4b4f2065 	.word	0x4b4f2065
     f34:	00000a0d 	.word	0x00000a0d
     f38:	20746553 	.word	0x20746553
     f3c:	534f4942 	.word	0x534f4942
     f40:	6d614e20 	.word	0x6d614e20
     f44:	61662065 	.word	0x61662065
     f48:	64656c69 	.word	0x64656c69
     f4c:	00000a0d 	.word	0x00000a0d
     f50:	67617355 	.word	0x67617355
     f54:	73203a65 	.word	0x73203a65
     f58:	69627465 	.word	0x69627465
     f5c:	3c20736f 	.word	0x3c20736f
     f60:	65746e69 	.word	0x65746e69
     f64:	63616672 	.word	0x63616672
     f68:	3c203e65 	.word	0x3c203e65
     f6c:	2e782e78 	.word	0x2e782e78
     f70:	3e782e78 	.word	0x3e782e78
     f74:	000a0d20 	.word	0x000a0d20
     f78:	203a7845 	.word	0x203a7845
     f7c:	62746573 	.word	0x62746573
     f80:	20736f69 	.word	0x20736f69
     f84:	33434950 	.word	0x33434950
     f88:	544e4932 	.word	0x544e4932
     f8c:	48434d20 	.word	0x48434d20
     f90:	414f4250 	.word	0x414f4250
     f94:	325f4452 	.word	0x325f4452
     f98:	0a0d2039 	.word	0x0a0d2039
     f9c:	00000000 	.word	0x00000000
     fa0:	20746553 	.word	0x20746553
     fa4:	65746167 	.word	0x65746167
     fa8:	20796177 	.word	0x20796177
     fac:	72646461 	.word	0x72646461
     fb0:	20737365 	.word	0x20737365
     fb4:	0a0d4b4f 	.word	0x0a0d4b4f
     fb8:	00000000 	.word	0x00000000
     fbc:	20746553 	.word	0x20746553
     fc0:	65746167 	.word	0x65746167
     fc4:	20796177 	.word	0x20796177
     fc8:	72646461 	.word	0x72646461
     fcc:	20737365 	.word	0x20737365
     fd0:	6c696166 	.word	0x6c696166
     fd4:	0a0d6465 	.word	0x0a0d6465
     fd8:	00000000 	.word	0x00000000
     fdc:	67617355 	.word	0x67617355
     fe0:	73203a65 	.word	0x73203a65
     fe4:	77677465 	.word	0x77677465
     fe8:	6e693c20 	.word	0x6e693c20
     fec:	66726574 	.word	0x66726574
     ff0:	3e656361 	.word	0x3e656361
     ff4:	70693c20 	.word	0x70693c20
     ff8:	362f3476 	.word	0x362f3476
     ffc:	64646120 	.word	0x64646120
    1000:	73736572 	.word	0x73736572
    1004:	763c203e 	.word	0x763c203e
    1008:	64696c61 	.word	0x64696c61
    100c:	656d6954 	.word	0x656d6954
    1010:	0a0d203e 	.word	0x0a0d203e
    1014:	00000000 	.word	0x00000000
    1018:	203a7845 	.word	0x203a7845
    101c:	67746573 	.word	0x67746573
    1020:	49502077 	.word	0x49502077
    1024:	49323343 	.word	0x49323343
    1028:	3120544e 	.word	0x3120544e
    102c:	312e3239 	.word	0x312e3239
    1030:	302e3836 	.word	0x302e3836
    1034:	0d20312e 	.word	0x0d20312e
    1038:	0000000a 	.word	0x0000000a
    103c:	61766e49 	.word	0x61766e49
    1040:	2064696c 	.word	0x2064696c
    1044:	61205049 	.word	0x61205049
    1048:	65726464 	.word	0x65726464
    104c:	73207373 	.word	0x73207373
    1050:	6e697274 	.word	0x6e697274
    1054:	0a0d2067 	.word	0x0a0d2067
    1058:	00000000 	.word	0x00000000
    105c:	20746553 	.word	0x20746553
    1060:	61207069 	.word	0x61207069
    1064:	65726464 	.word	0x65726464
    1068:	4f207373 	.word	0x4f207373
    106c:	000a0d4b 	.word	0x000a0d4b
    1070:	20746553 	.word	0x20746553
    1074:	61207069 	.word	0x61207069
    1078:	65726464 	.word	0x65726464
    107c:	66207373 	.word	0x66207373
    1080:	656c6961 	.word	0x656c6961
    1084:	000a0d64 	.word	0x000a0d64
    1088:	67617355 	.word	0x67617355
    108c:	73203a65 	.word	0x73203a65
    1090:	70697465 	.word	0x70697465
    1094:	6e693c20 	.word	0x6e693c20
    1098:	66726574 	.word	0x66726574
    109c:	3e656361 	.word	0x3e656361
    10a0:	70693c20 	.word	0x70693c20
    10a4:	362f3476 	.word	0x362f3476
    10a8:	64646120 	.word	0x64646120
    10ac:	73736572 	.word	0x73736572
    10b0:	693c203e 	.word	0x693c203e
    10b4:	6d347670 	.word	0x6d347670
    10b8:	2f6b7361 	.word	0x2f6b7361
    10bc:	36767069 	.word	0x36767069
    10c0:	65727020 	.word	0x65727020
    10c4:	20786966 	.word	0x20786966
    10c8:	3e6e656c 	.word	0x3e6e656c
    10cc:	00000a0d 	.word	0x00000a0d
    10d0:	203a7845 	.word	0x203a7845
    10d4:	69746573 	.word	0x69746573
    10d8:	49502070 	.word	0x49502070
    10dc:	49323343 	.word	0x49323343
    10e0:	3120544e 	.word	0x3120544e
    10e4:	312e3239 	.word	0x312e3239
    10e8:	302e3836 	.word	0x302e3836
    10ec:	3220382e 	.word	0x3220382e
    10f0:	322e3535 	.word	0x322e3535
    10f4:	322e3535 	.word	0x322e3535
    10f8:	302e3535 	.word	0x302e3535
    10fc:	000a0d20 	.word	0x000a0d20
    1100:	73206f4e 	.word	0x73206f4e
    1104:	20686375 	.word	0x20686375
    1108:	65746e69 	.word	0x65746e69
    110c:	63616672 	.word	0x63616672
    1110:	73692065 	.word	0x73692065
    1114:	0d707520 	.word	0x0d707520
    1118:	0000000a 	.word	0x0000000a
    111c:	61206e41 	.word	0x61206e41
    1120:	65726464 	.word	0x65726464
    1124:	73207373 	.word	0x73207373
    1128:	69767265 	.word	0x69767265
    112c:	69206563 	.word	0x69206563
    1130:	6c612073 	.word	0x6c612073
    1134:	64616572 	.word	0x64616572
    1138:	75722079 	.word	0x75722079
    113c:	6e696e6e 	.word	0x6e696e6e
    1140:	53202e67 	.word	0x53202e67
    1144:	20706f74 	.word	0x20706f74
    1148:	50434844 	.word	0x50434844
    114c:	435a202c 	.word	0x435a202c
    1150:	202c4c4c 	.word	0x202c4c4c
    1154:	2e637465 	.word	0x2e637465
    1158:	72696620 	.word	0x72696620
    115c:	0a0d7473 	.word	0x0a0d7473
    1160:	00000000 	.word	0x00000000
    1164:	61766e49 	.word	0x61766e49
    1168:	2064696c 	.word	0x2064696c
    116c:	6d205049 	.word	0x6d205049
    1170:	206b7361 	.word	0x206b7361
    1174:	69727473 	.word	0x69727473
    1178:	0d20676e 	.word	0x0d20676e
    117c:	0000000a 	.word	0x0000000a
    1180:	63637573 	.word	0x63637573
    1184:	00737365 	.word	0x00737365
    1188:	6c696166 	.word	0x6c696166
    118c:	00006465 	.word	0x00006465
    1190:	67617355 	.word	0x67617355
    1194:	73203a65 	.word	0x73203a65
    1198:	6e647465 	.word	0x6e647465
    119c:	2f312073 	.word	0x2f312073
    11a0:	693c2032 	.word	0x693c2032
    11a4:	7265746e 	.word	0x7265746e
    11a8:	65636166 	.word	0x65636166
    11ac:	783c203e 	.word	0x783c203e
    11b0:	782e782e 	.word	0x782e782e
    11b4:	203e782e 	.word	0x203e782e
    11b8:	00000a0d 	.word	0x00000a0d
    11bc:	203a7845 	.word	0x203a7845
    11c0:	64746573 	.word	0x64746573
    11c4:	3120736e 	.word	0x3120736e
    11c8:	68746520 	.word	0x68746520
    11cc:	35322030 	.word	0x35322030
    11d0:	35322e35 	.word	0x35322e35
    11d4:	35322e35 	.word	0x35322e35
    11d8:	20302e35 	.word	0x20302e35
    11dc:	00000a0d 	.word	0x00000a0d
    11e0:	6e6b6e55 	.word	0x6e6b6e55
    11e4:	206e776f 	.word	0x206e776f
    11e8:	20534e44 	.word	0x20534e44
    11ec:	65646e69 	.word	0x65646e69
    11f0:	000a0d78 	.word	0x000a0d78
    11f4:	20746553 	.word	0x20746553
    11f8:	20534e44 	.word	0x20534e44
    11fc:	61206425 	.word	0x61206425
    1200:	65726464 	.word	0x65726464
    1204:	25207373 	.word	0x25207373
    1208:	000a0d73 	.word	0x000a0d73
    120c:	20746f6e 	.word	0x20746f6e
    1210:	65766967 	.word	0x65766967
    1214:	0000006e 	.word	0x0000006e
    1218:	656e6f4e 	.word	0x656e6f4e
    121c:	00000000 	.word	0x00000000
    1220:	6c696166 	.word	0x6c696166
    1224:	00000000 	.word	0x00000000
    1228:	67617355 	.word	0x67617355
    122c:	25203a65 	.word	0x25203a65
    1230:	693c2073 	.word	0x693c2073
    1234:	7265746e 	.word	0x7265746e
    1238:	65636166 	.word	0x65636166
    123c:	6f3c203e 	.word	0x6f3c203e
    1240:	666f2f6e 	.word	0x666f2f6e
    1244:	65722f66 	.word	0x65722f66
    1248:	2f77656e 	.word	0x2f77656e
    124c:	75716572 	.word	0x75716572
    1250:	2f747365 	.word	0x2f747365
    1254:	6f666e69 	.word	0x6f666e69
    1258:	0a0d203e 	.word	0x0a0d203e
    125c:	00000000 	.word	0x00000000
    1260:	656e6572 	.word	0x656e6572
    1264:	00000077 	.word	0x00000077
    1268:	75716572 	.word	0x75716572
    126c:	00747365 	.word	0x00747365
    1270:	75716552 	.word	0x75716552
    1274:	20747365 	.word	0x20747365
    1278:	6465656e 	.word	0x6465656e
    127c:	6e612073 	.word	0x6e612073
    1280:	20504920 	.word	0x20504920
    1284:	72646461 	.word	0x72646461
    1288:	0d737365 	.word	0x0d737365
    128c:	0000000a 	.word	0x0000000a
    1290:	6f666e69 	.word	0x6f666e69
    1294:	00000000 	.word	0x00000000
    1298:	50434844 	.word	0x50434844
    129c:	61747320 	.word	0x61747320
    12a0:	3a737574 	.word	0x3a737574
    12a4:	20642520 	.word	0x20642520
    12a8:	64252028 	.word	0x64252028
    12ac:	203d3d20 	.word	0x203d3d20
    12b0:	6e756f42 	.word	0x6e756f42
    12b4:	202c2964 	.word	0x202c2964
    12b8:	656d6974 	.word	0x656d6974
    12bc:	6425203a 	.word	0x6425203a
    12c0:	00000a0d 	.word	0x00000a0d
    12c4:	50434844 	.word	0x50434844
    12c8:	61656c20 	.word	0x61656c20
    12cc:	73206573 	.word	0x73206573
    12d0:	74726174 	.word	0x74726174
    12d4:	6425203a 	.word	0x6425203a
    12d8:	7564202c 	.word	0x7564202c
    12dc:	69746172 	.word	0x69746172
    12e0:	203a6e6f 	.word	0x203a6e6f
    12e4:	0d736425 	.word	0x0d736425
    12e8:	0000000a 	.word	0x0000000a
    12ec:	50434844 	.word	0x50434844
    12f0:	6e657220 	.word	0x6e657220
    12f4:	74207765 	.word	0x74207765
    12f8:	3a656d69 	.word	0x3a656d69
    12fc:	2c642520 	.word	0x2c642520
    1300:	62657220 	.word	0x62657220
    1304:	20646e69 	.word	0x20646e69
    1308:	656d6974 	.word	0x656d6974
    130c:	6425203a 	.word	0x6425203a
    1310:	00000a0d 	.word	0x00000a0d
    1314:	50434844 	.word	0x50434844
    1318:	64646120 	.word	0x64646120
    131c:	73736572 	.word	0x73736572
    1320:	7325203a 	.word	0x7325203a
    1324:	00000a0d 	.word	0x00000a0d
    1328:	50434844 	.word	0x50434844
    132c:	72657320 	.word	0x72657320
    1330:	3a726576 	.word	0x3a726576
    1334:	0d732520 	.word	0x0d732520
    1338:	0000000a 	.word	0x0000000a
    133c:	50434844 	.word	0x50434844
    1340:	6f6f6220 	.word	0x6f6f6220
    1344:	616e2074 	.word	0x616e2074
    1348:	203a656d 	.word	0x203a656d
    134c:	0a0d7325 	.word	0x0a0d7325
    1350:	00000000 	.word	0x00000000
    1354:	50434844 	.word	0x50434844
    1358:	6d695420 	.word	0x6d695420
    135c:	65732065 	.word	0x65732065
    1360:	72657672 	.word	0x72657672
    1364:	25203a73 	.word	0x25203a73
    1368:	25202c64 	.word	0x25202c64
    136c:	000a0d73 	.word	0x000a0d73
    1370:	50434844 	.word	0x50434844
    1374:	50544e20 	.word	0x50544e20
    1378:	72657320 	.word	0x72657320
    137c:	73726576 	.word	0x73726576
    1380:	6425203a 	.word	0x6425203a
    1384:	7325202c 	.word	0x7325202c
    1388:	00000a0d 	.word	0x00000a0d
    138c:	50434844 	.word	0x50434844
    1390:	6166203a 	.word	0x6166203a
    1394:	64656c69 	.word	0x64656c69
    1398:	206f7420 	.word	0x206f7420
    139c:	20746567 	.word	0x20746567
    13a0:	6f666e69 	.word	0x6f666e69
    13a4:	00000a0d 	.word	0x00000a0d
    13a8:	25207325 	.word	0x25207325
    13ac:	73252073 	.word	0x73252073
    13b0:	00000a0d 	.word	0x00000a0d
    13b4:	63637573 	.word	0x63637573
    13b8:	66737365 	.word	0x66737365
    13bc:	00006c75 	.word	0x00006c75
    13c0:	6c696166 	.word	0x6c696166
    13c4:	00216465 	.word	0x00216465
    13c8:	00746573 	.word	0x00746573
    13cc:	00746567 	.word	0x00746567
    13d0:	61666544 	.word	0x61666544
    13d4:	20746c75 	.word	0x20746c75
    13d8:	65746e69 	.word	0x65746e69
    13dc:	63616672 	.word	0x63616672
    13e0:	65732065 	.word	0x65732065
    13e4:	73252074 	.word	0x73252074
    13e8:	00000a0d 	.word	0x00000a0d
    13ec:	61666544 	.word	0x61666544
    13f0:	20746c75 	.word	0x20746c75
    13f4:	65746e69 	.word	0x65746e69
    13f8:	63616672 	.word	0x63616672
    13fc:	73692065 	.word	0x73692065
    1400:	7325203a 	.word	0x7325203a
    1404:	00000a0d 	.word	0x00000a0d
    1408:	67617355 	.word	0x67617355
    140c:	64203a65 	.word	0x64203a65
    1410:	656e6665 	.word	0x656e6665
    1414:	65732074 	.word	0x65732074
    1418:	65672f74 	.word	0x65672f74
    141c:	693c2074 	.word	0x693c2074
    1420:	7265746e 	.word	0x7265746e
    1424:	65636166 	.word	0x65636166
    1428:	000a0d3e 	.word	0x000a0d3e
    142c:	203a7845 	.word	0x203a7845
    1430:	6e666564 	.word	0x6e666564
    1434:	73207465 	.word	0x73207465
    1438:	65207465 	.word	0x65207465
    143c:	0d306874 	.word	0x0d306874
    1440:	0000000a 	.word	0x0000000a
    1444:	00005055 	.word	0x00005055
    1448:	4e574f44 	.word	0x4e574f44
    144c:	00000000 	.word	0x00000000
    1450:	64616552 	.word	0x64616552
    1454:	00000079 	.word	0x00000079
    1458:	20746f4e 	.word	0x20746f4e
    145c:	64616552 	.word	0x64616552
    1460:	00000079 	.word	0x00000079
    1464:	67617355 	.word	0x67617355
    1468:	6e203a65 	.word	0x6e203a65
    146c:	6e697465 	.word	0x6e697465
    1470:	0a0d6f66 	.word	0x0a0d6f66
    1474:	00000000 	.word	0x00000000
    1478:	203a7845 	.word	0x203a7845
    147c:	6974656e 	.word	0x6974656e
    1480:	0d6f666e 	.word	0x0d6f666e
    1484:	0000000a 	.word	0x0000000a
    1488:	2d2d2d2d 	.word	0x2d2d2d2d
    148c:	2d2d2d2d 	.word	0x2d2d2d2d
    1490:	49202d2d 	.word	0x49202d2d
    1494:	7265746e 	.word	0x7265746e
    1498:	65636166 	.word	0x65636166
    149c:	73253c20 	.word	0x73253c20
    14a0:	3e73252f 	.word	0x3e73252f
    14a4:	2d2d2d20 	.word	0x2d2d2d20
    14a8:	2d2d2d2d 	.word	0x2d2d2d2d
    14ac:	202d2d2d 	.word	0x202d2d2d
    14b0:	00000a0d 	.word	0x00000a0d
    14b4:	65746e49 	.word	0x65746e49
    14b8:	63616672 	.word	0x63616672
    14bc:	73692065 	.word	0x73692065
    14c0:	776f6420 	.word	0x776f6420
    14c4:	000a0d6e 	.word	0x000a0d6e
    14c8:	74736f48 	.word	0x74736f48
    14cc:	6d614e20 	.word	0x6d614e20
    14d0:	25203a65 	.word	0x25203a65
    14d4:	202d2073 	.word	0x202d2073
    14d8:	534e424e 	.word	0x534e424e
    14dc:	73696420 	.word	0x73696420
    14e0:	656c6261 	.word	0x656c6261
    14e4:	0a0d2064 	.word	0x0a0d2064
    14e8:	00000000 	.word	0x00000000
    14ec:	34765049 	.word	0x34765049
    14f0:	64644120 	.word	0x64644120
    14f4:	73736572 	.word	0x73736572
    14f8:	7325203a 	.word	0x7325203a
    14fc:	00000a0d 	.word	0x00000a0d
    1500:	6b73614d 	.word	0x6b73614d
    1504:	7325203a 	.word	0x7325203a
    1508:	00000a0d 	.word	0x00000a0d
    150c:	65746147 	.word	0x65746147
    1510:	3a796177 	.word	0x3a796177
    1514:	0d732520 	.word	0x0d732520
    1518:	0000000a 	.word	0x0000000a
    151c:	31534e44 	.word	0x31534e44
    1520:	7325203a 	.word	0x7325203a
    1524:	00000a0d 	.word	0x00000a0d
    1528:	32534e44 	.word	0x32534e44
    152c:	7325203a 	.word	0x7325203a
    1530:	00000a0d 	.word	0x00000a0d
    1534:	2043414d 	.word	0x2043414d
    1538:	72646441 	.word	0x72646441
    153c:	3a737365 	.word	0x3a737365
    1540:	0d732520 	.word	0x0d732520
    1544:	0000000a 	.word	0x0000000a
    1548:	70636864 	.word	0x70636864
    154c:	20736920 	.word	0x20736920
    1550:	0a0d7325 	.word	0x0a0d7325
    1554:	00000000 	.word	0x00000000
    1558:	6b6e694c 	.word	0x6b6e694c
    155c:	20736920 	.word	0x20736920
    1560:	0a0d7325 	.word	0x0a0d7325
    1564:	00000000 	.word	0x00000000
    1568:	74617453 	.word	0x74617453
    156c:	203a7375 	.word	0x203a7375
    1570:	0a0d7325 	.word	0x0a0d7325
    1574:	00000000 	.word	0x00000000
    1578:	61666564 	.word	0x61666564
    157c:	20746c75 	.word	0x20746c75
    1580:	61205049 	.word	0x61205049
    1584:	65726464 	.word	0x65726464
    1588:	00007373 	.word	0x00007373
    158c:	69207325 	.word	0x69207325
    1590:	4e4f2073 	.word	0x4e4f2073
    1594:	00000a0d 	.word	0x00000a0d
    1598:	70636864 	.word	0x70636864
    159c:	00000000 	.word	0x00000000
    15a0:	676e6950 	.word	0x676e6950
    15a4:	7277203a 	.word	0x7277203a
    15a8:	20676e6f 	.word	0x20676e6f
    15ac:	6c706572 	.word	0x6c706572
    15b0:	65722079 	.word	0x65722079
    15b4:	76696563 	.word	0x76696563
    15b8:	202e6465 	.word	0x202e6465
    15bc:	6b73614d 	.word	0x6b73614d
    15c0:	7830203a 	.word	0x7830203a
    15c4:	0d783225 	.word	0x0d783225
    15c8:	0000000a 	.word	0x0000000a
    15cc:	676e6950 	.word	0x676e6950
    15d0:	6572203a 	.word	0x6572203a
    15d4:	5b796c70 	.word	0x5b796c70
    15d8:	205d6425 	.word	0x205d6425
    15dc:	6d6f7266 	.word	0x6d6f7266
    15e0:	3a732520 	.word	0x3a732520
    15e4:	6d697420 	.word	0x6d697420
    15e8:	203d2065 	.word	0x203d2065
    15ec:	736d6425 	.word	0x736d6425
    15f0:	00000a0d 	.word	0x00000a0d
    15f4:	676e6950 	.word	0x676e6950
    15f8:	4e44203a 	.word	0x4e44203a
    15fc:	61662053 	.word	0x61662053
    1600:	72756c69 	.word	0x72756c69
    1604:	6f662065 	.word	0x6f662065
    1608:	73252072 	.word	0x73252072
    160c:	00000a0d 	.word	0x00000a0d
    1610:	20534e44 	.word	0x20534e44
    1614:	6b6f6f4c 	.word	0x6b6f6f4c
    1618:	203a7075 	.word	0x203a7075
    161c:	20534e44 	.word	0x20534e44
    1620:	6c696166 	.word	0x6c696166
    1624:	20657275 	.word	0x20657275
    1628:	20726f66 	.word	0x20726f66
    162c:	202c7325 	.word	0x202c7325
    1630:	3a727265 	.word	0x3a727265
    1634:	0d642520 	.word	0x0d642520
    1638:	0000000a 	.word	0x0000000a
    163c:	20534e44 	.word	0x20534e44
    1640:	6b6f6f4c 	.word	0x6b6f6f4c
    1644:	203a7075 	.word	0x203a7075
    1648:	75716572 	.word	0x75716572
    164c:	20747365 	.word	0x20747365
    1650:	656d6974 	.word	0x656d6974
    1654:	2e74756f 	.word	0x2e74756f
    1658:	00000a0d 	.word	0x00000a0d
    165c:	6b6f6f4c 	.word	0x6b6f6f4c
    1660:	41207075 	.word	0x41207075
    1664:	6577736e 	.word	0x6577736e
    1668:	0a0d3a72 	.word	0x0a0d3a72
    166c:	2d2d2d2d 	.word	0x2d2d2d2d
    1670:	2d2d2d2d 	.word	0x2d2d2d2d
    1674:	2d2d2d2d 	.word	0x2d2d2d2d
    1678:	2d2d2d2d 	.word	0x2d2d2d2d
    167c:	2d2d2d2d 	.word	0x2d2d2d2d
    1680:	0a0d2d2d 	.word	0x0a0d2d2d
    1684:	00000000 	.word	0x00000000
    1688:	4c206f4e 	.word	0x4c206f4e
    168c:	756b6f6f 	.word	0x756b6f6f
    1690:	6e652070 	.word	0x6e652070
    1694:	20797274 	.word	0x20797274
    1698:	20726f66 	.word	0x20726f66
    169c:	5d73255b 	.word	0x5d73255b
    16a0:	00000a0d 	.word	0x00000a0d
    16a4:	5d73255b 	.word	0x5d73255b
    16a8:	49204120 	.word	0x49204120
    16ac:	20347650 	.word	0x20347650
    16b0:	72646441 	.word	0x72646441
    16b4:	20737365 	.word	0x20737365
    16b8:	6425203a 	.word	0x6425203a
    16bc:	2e64252e 	.word	0x2e64252e
    16c0:	252e6425 	.word	0x252e6425
    16c4:	000a0d64 	.word	0x000a0d64
    16c8:	5d73255b 	.word	0x5d73255b
    16cc:	41414120 	.word	0x41414120
    16d0:	50492041 	.word	0x50492041
    16d4:	41203676 	.word	0x41203676
    16d8:	65726464 	.word	0x65726464
    16dc:	3a207373 	.word	0x3a207373
    16e0:	0a0d7325 	.word	0x0a0d7325
    16e4:	00000000 	.word	0x00000000
    16e8:	7473203a 	.word	0x7473203a
    16ec:	206b6361 	.word	0x206b6361
    16f0:	6d6d6f63 	.word	0x6d6d6f63
    16f4:	73646e61 	.word	0x73646e61
    16f8:	00000000 	.word	0x00000000
    16fc:	69706374 	.word	0x69706374
    1700:	00000070 	.word	0x00000070
    1704:	6c696146 	.word	0x6c696146
    1708:	74206465 	.word	0x74206465
    170c:	7263206f 	.word	0x7263206f
    1710:	65746165 	.word	0x65746165
    1714:	50435420 	.word	0x50435420
    1718:	43205049 	.word	0x43205049
    171c:	616d6d6f 	.word	0x616d6d6f
    1720:	0d73646e 	.word	0x0d73646e
    1724:	0000000a 	.word	0x0000000a
    1728:	49504354 	.word	0x49504354
    172c:	6f632050 	.word	0x6f632050
    1730:	6e616d6d 	.word	0x6e616d6d
    1734:	74207364 	.word	0x74207364
    1738:	206b7361 	.word	0x206b7361
    173c:	69676572 	.word	0x69676572
    1740:	61727473 	.word	0x61727473
    1744:	6e6f6974 	.word	0x6e6f6974
    1748:	69616620 	.word	0x69616620
    174c:	0d64656c 	.word	0x0d64656c
    1750:	0000000a 	.word	0x0000000a
    1754:	65746e69 	.word	0x65746e69
    1758:	6c616e72 	.word	0x6c616e72
    175c:	00000000 	.word	0x00000000
    1760:	6c6f6f70 	.word	0x6c6f6f70
    1764:	00000000 	.word	0x00000000
    1768:	65747865 	.word	0x65747865
    176c:	6c616e72 	.word	0x6c616e72
    1770:	00000000 	.word	0x00000000
    1774:	006c6564 	.word	0x006c6564
    1778:	6b6f6f6c 	.word	0x6b6f6f6c
    177c:	00007075 	.word	0x00007075
    1780:	6974656e 	.word	0x6974656e
    1784:	006f666e 	.word	0x006f666e
    1788:	6547203a 	.word	0x6547203a
    178c:	656e2074 	.word	0x656e2074
    1790:	726f7774 	.word	0x726f7774
    1794:	6e69206b 	.word	0x6e69206b
    1798:	6d726f66 	.word	0x6d726f66
    179c:	6f697461 	.word	0x6f697461
    17a0:	0000006e 	.word	0x0000006e
    17a4:	6e666564 	.word	0x6e666564
    17a8:	00007465 	.word	0x00007465
    17ac:	6553203a 	.word	0x6553203a
    17b0:	65472f74 	.word	0x65472f74
    17b4:	65642074 	.word	0x65642074
    17b8:	6c756166 	.word	0x6c756166
    17bc:	6e692074 	.word	0x6e692074
    17c0:	66726574 	.word	0x66726574
    17c4:	00656361 	.word	0x00656361
    17c8:	4844203a 	.word	0x4844203a
    17cc:	63205043 	.word	0x63205043
    17d0:	6e65696c 	.word	0x6e65696c
    17d4:	6f632074 	.word	0x6f632074
    17d8:	6e616d6d 	.word	0x6e616d6d
    17dc:	00007364 	.word	0x00007364
    17e0:	70636864 	.word	0x70636864
    17e4:	00000073 	.word	0x00000073
    17e8:	7554203a 	.word	0x7554203a
    17ec:	44206e72 	.word	0x44206e72
    17f0:	20504348 	.word	0x20504348
    17f4:	76726573 	.word	0x76726573
    17f8:	6f207265 	.word	0x6f207265
    17fc:	666f2f6e 	.word	0x666f2f6e
    1800:	00000066 	.word	0x00000066
    1804:	6c6c637a 	.word	0x6c6c637a
    1808:	00000000 	.word	0x00000000
    180c:	7554203a 	.word	0x7554203a
    1810:	5a206e72 	.word	0x5a206e72
    1814:	204c4c43 	.word	0x204c4c43
    1818:	6f2f6e6f 	.word	0x6f2f6e6f
    181c:	00006666 	.word	0x00006666
    1820:	64746573 	.word	0x64746573
    1824:	0000736e 	.word	0x0000736e
    1828:	6553203a 	.word	0x6553203a
    182c:	4e442074 	.word	0x4e442074
    1830:	64612053 	.word	0x64612053
    1834:	73657264 	.word	0x73657264
    1838:	00000073 	.word	0x00000073
    183c:	69746573 	.word	0x69746573
    1840:	00000070 	.word	0x00000070
    1844:	6553203a 	.word	0x6553203a
    1848:	50492074 	.word	0x50492074
    184c:	64646120 	.word	0x64646120
    1850:	73736572 	.word	0x73736572
    1854:	646e6120 	.word	0x646e6120
    1858:	73616d20 	.word	0x73616d20
    185c:	0000006b 	.word	0x0000006b
    1860:	67746573 	.word	0x67746573
    1864:	00000077 	.word	0x00000077
    1868:	6553203a 	.word	0x6553203a
    186c:	61472074 	.word	0x61472074
    1870:	61776574 	.word	0x61776574
    1874:	64612079 	.word	0x64612079
    1878:	73657264 	.word	0x73657264
    187c:	00000073 	.word	0x00000073
    1880:	62746573 	.word	0x62746573
    1884:	00736f69 	.word	0x00736f69
    1888:	6553203a 	.word	0x6553203a
    188c:	6f682074 	.word	0x6f682074
    1890:	73277473 	.word	0x73277473
    1894:	74654e20 	.word	0x74654e20
    1898:	534f4942 	.word	0x534f4942
    189c:	6d616e20 	.word	0x6d616e20
    18a0:	00000065 	.word	0x00000065
    18a4:	6d746573 	.word	0x6d746573
    18a8:	00006361 	.word	0x00006361
    18ac:	6553203a 	.word	0x6553203a
    18b0:	414d2074 	.word	0x414d2074
    18b4:	64612043 	.word	0x64612043
    18b8:	73657264 	.word	0x73657264
    18bc:	00000073 	.word	0x00000073
    18c0:	00006669 	.word	0x00006669
    18c4:	7242203a 	.word	0x7242203a
    18c8:	20676e69 	.word	0x20676e69
    18cc:	69206e61 	.word	0x69206e61
    18d0:	7265746e 	.word	0x7265746e
    18d4:	65636166 	.word	0x65636166
    18d8:	2f707520 	.word	0x2f707520
    18dc:	6e776f64 	.word	0x6e776f64
    18e0:	00000000 	.word	0x00000000
    18e4:	63617473 	.word	0x63617473
    18e8:	0000006b 	.word	0x0000006b
    18ec:	7453203a 	.word	0x7453203a
    18f0:	206b6361 	.word	0x206b6361
    18f4:	6e727574 	.word	0x6e727574
    18f8:	2f6e6f20 	.word	0x2f6e6f20
    18fc:	0066666f 	.word	0x0066666f
    1900:	70616568 	.word	0x70616568
    1904:	6f666e69 	.word	0x6f666e69
    1908:	00000000 	.word	0x00000000
    190c:	6843203a 	.word	0x6843203a
    1910:	206b6365 	.word	0x206b6365
    1914:	70616568 	.word	0x70616568
    1918:	61747320 	.word	0x61747320
    191c:	00737574 	.word	0x00737574
    1920:	676e6970 	.word	0x676e6970
    1924:	00000000 	.word	0x00000000
    1928:	6950203a 	.word	0x6950203a
    192c:	6120676e 	.word	0x6120676e
    1930:	5049206e 	.word	0x5049206e
    1934:	64646120 	.word	0x64646120
    1938:	73736572 	.word	0x73736572
    193c:	00000000 	.word	0x00000000
    1940:	63736e64 	.word	0x63736e64
    1944:	00000000 	.word	0x00000000
    1948:	4e44203a 	.word	0x4e44203a
    194c:	6c632053 	.word	0x6c632053
    1950:	746e6569 	.word	0x746e6569
    1954:	6d6f6320 	.word	0x6d6f6320
    1958:	646e616d 	.word	0x646e616d
    195c:	00000073 	.word	0x00000073
    1960:	6963616d 	.word	0x6963616d
    1964:	006f666e 	.word	0x006f666e
    1968:	6843203a 	.word	0x6843203a
    196c:	206b6365 	.word	0x206b6365
    1970:	2043414d 	.word	0x2043414d
    1974:	74617473 	.word	0x74617473
    1978:	69747369 	.word	0x69747369
    197c:	7363      	.short	0x7363
	...

Disassembly of section .text.TCPIP_TCP_Task%188:

00001980 <TCPIP_TCP_Task>:
    return hTCP;		

}

void  TCPIP_TCP_Task(void)
{
    1980:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1984:	b091      	sub	sp, #68	; 0x44
    if((sigPend & (TCPIP_MODULE_SIGNAL_INTERFACE_CHANGE)) != 0)
    { // interface address change occurred
        _TCPAbortSockets(ifMask, TCPIP_TCP_SIGNAL_IF_CHANGE); 
    }
#else
    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    1986:	210f      	movs	r1, #15
    1988:	200a      	movs	r0, #10
    198a:	f01c faef 	bl	1df6c <_TCPIPStackModuleSignalGet>
    198e:	9003      	str	r0, [sp, #12]
#endif  // (_TCPIP_STACK_INTERFACE_CHANGE_SIGNALING != 0)

    if((sigPend & TCPIP_MODULE_SIGNAL_RX_PENDING) != 0)
    1990:	f010 0f01 	tst.w	r0, #1
    1994:	f040 852b 	bne.w	23ee <__ext_attr_.config_00804000+0x3ea>
    { //  RX signal occurred
        TCPIP_TCP_Process();
    }

    if((sigPend & TCPIP_MODULE_SIGNAL_TMO) != 0)
    1998:	9b03      	ldr	r3, [sp, #12]
    199a:	f013 0f02 	tst.w	r3, #2
    199e:	f040 854a 	bne.w	2436 <__ext_attr_.config_00804000+0x432>
    { // regular TMO occurred
        TCPIP_TCP_Tick();
    }
}
    19a2:	b011      	add	sp, #68	; 0x44
    19a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 */
static __inline__ const IPV4_ADDR* TCPIP_IPV4_PacketGetSourceAddress(TCPIP_MAC_PACKET* pPkt);

static __inline__ const IPV4_ADDR* __attribute__((always_inline)) TCPIP_IPV4_PacketGetSourceAddress(TCPIP_MAC_PACKET* pPkt)
{
    return &((IPV4_HEADER*)pPkt->pNetLayer)->SourceAddress;
    19a8:	f8d9 7018 	ldr.w	r7, [r9, #24]
    return &((IPV4_HEADER*)pPkt->pNetLayer)->DestAddress;
    19ac:	f107 0310 	add.w	r3, r7, #16
    19b0:	9307      	str	r3, [sp, #28]

    pPktSrcAdd = TCPIP_IPV4_PacketGetSourceAddress(pRxPkt);
    pPktDstAdd = TCPIP_IPV4_PacketGetDestAddress(pRxPkt);

    // Calculate IP pseudoheader checksum.
    pseudoHdr.SourceAddress.Val = pPktSrcAdd->Val;
    19b2:	68fb      	ldr	r3, [r7, #12]
    19b4:	930d      	str	r3, [sp, #52]	; 0x34
    pseudoHdr.DestAddress.Val = pPktDstAdd->Val;
    19b6:	693b      	ldr	r3, [r7, #16]
    19b8:	930e      	str	r3, [sp, #56]	; 0x38
    pseudoHdr.Zero	= 0;
    19ba:	2200      	movs	r2, #0
    19bc:	f88d 203c 	strb.w	r2, [sp, #60]	; 0x3c
    pseudoHdr.Protocol = IP_PROT_TCP;
    19c0:	2306      	movs	r3, #6
    19c2:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
    return (((hLong & 0x000000ff) << 24) | ((hLong & 0x0000ff00) << 8) | ((hLong & 0x00ff0000) >> 8) | ((hLong & 0xff000000) >> 24));
}

static inline uint16_t __attribute__((always_inline)) TCPIP_Helper_htons(uint16_t hShort)
{
       return (((hShort) << 8) | ((hShort) >> 8));
    19c6:	0a2b      	lsrs	r3, r5, #8
    19c8:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    pseudoHdr.Length = TCPIP_Helper_ntohs(tcpTotLength);
    19cc:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e

    calcChkSum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)&pseudoHdr, sizeof(pseudoHdr), 0);
    19d0:	210c      	movs	r1, #12
    19d2:	a80d      	add	r0, sp, #52	; 0x34
    19d4:	f018 fc72 	bl	1a2bc <TCPIP_Helper_CalcIPChecksum>
    19d8:	43c3      	mvns	r3, r0
    19da:	b29b      	uxth	r3, r3
    // Note: pseudoHdr length is multiple of 4!
    if((pRxPkt->pktFlags & TCPIP_MAC_PKT_FLAG_SPLIT) != 0)
    19dc:	f8b9 2022 	ldrh.w	r2, [r9, #34]	; 0x22
    19e0:	f012 0f04 	tst.w	r2, #4
    19e4:	d033      	beq.n	1a4e <TCPIP_TCP_Task+0xce>
    {
        calcChkSum = TCPIP_Helper_PacketChecksum(pRxPkt, (uint8_t*)pTCPHdr, tcpTotLength, calcChkSum);
    19e6:	462a      	mov	r2, r5
    19e8:	4641      	mov	r1, r8
    19ea:	4648      	mov	r0, r9
    19ec:	f017 fa38 	bl	18e60 <TCPIP_Helper_PacketChecksum>
    19f0:	9004      	str	r0, [sp, #16]
    else
    {
        calcChkSum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pTCPHdr, tcpTotLength, calcChkSum);
    }

    if(calcChkSum != 0)
    19f2:	9b04      	ldr	r3, [sp, #16]
    19f4:	2b00      	cmp	r3, #0
    19f6:	f040 8663 	bne.w	26c0 <__ext_attr_.config_00804000+0x6bc>
    {   // discard packet
        return TCPIP_MAC_PKT_ACK_CHKSUM_ERR;
    }


	_TcpSwapHeader(pTCPHdr);
    19fa:	4640      	mov	r0, r8
    19fc:	f018 ffc2 	bl	1a984 <_TcpSwapHeader>
    TCPIP_TCP_CheckRxPkt(pTCPHdr);

	// Skip over options to retrieve data bytes
	optionsSize = (pTCPHdr->DataOffset.Val << 2) - sizeof(*pTCPHdr);
    1a00:	f898 b00c 	ldrb.w	fp, [r8, #12]
    1a04:	ea4f 1b1b 	mov.w	fp, fp, lsr #4
    1a08:	ea4f 038b 	mov.w	r3, fp, lsl #2
    1a0c:	9306      	str	r3, [sp, #24]
	TCP_SOCKET hTCP;
	uint16_t hash;
    TCB_STUB* pSkt, *partialSkt;
    TCPIP_NET_IF* pPktIf;

    TCP_HEADER* h = (TCP_HEADER*)pRxPkt->pTransportLayer;
    1a0e:	f8d9 b01c 	ldr.w	fp, [r9, #28]
    pPktIf = (TCPIP_NET_IF*)pRxPkt->pktIf;

	// Prevent connections on invalid port 0
	if(h->DestPort == 0)
    1a12:	f8bb 2002 	ldrh.w	r2, [fp, #2]
    1a16:	2a00      	cmp	r2, #0
    1a18:	f000 8655 	beq.w	26c6 <__ext_attr_.config_00804000+0x6c2>
            break;  // OK
#endif  // defined (TCPIP_STACK_USE_IPV6)

#if defined (TCPIP_STACK_USE_IPV4)
        case IP_ADDRESS_TYPE_IPV4:
            hash = (((IPV4_ADDR *)remoteIP)->w[1] + ((IPV4_ADDR *)remoteIP)->w[0] + h->SourcePort) ^ h->DestPort;
    1a1c:	89fe      	ldrh	r6, [r7, #14]
    1a1e:	89bb      	ldrh	r3, [r7, #12]
    1a20:	441e      	add	r6, r3
    1a22:	f8bb 3000 	ldrh.w	r3, [fp]
    1a26:	441e      	add	r6, r3
    1a28:	4056      	eors	r6, r2
    1a2a:	b2b6      	uxth	r6, r6
            return 0;  // shouldn't happen
    }

	// Loop through all sockets looking for a socket that is expecting this 
	// packet or can handle it.
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    1a2c:	4bcc      	ldr	r3, [pc, #816]	; (1d60 <TCPIP_TCP_Task+0x3e0>)
    1a2e:	f8d3 c000 	ldr.w	ip, [r3]
    1a32:	f1bc 0f00 	cmp.w	ip, #0
    1a36:	f000 8649 	beq.w	26cc <__ext_attr_.config_00804000+0x6c8>
    pPktIf = (TCPIP_NET_IF*)pRxPkt->pktIf;
    1a3a:	f8d9 e028 	ldr.w	lr, [r9, #40]	; 0x28
    {
        pSkt = TCBStubs[hTCP];
    1a3e:	4bc9      	ldr	r3, [pc, #804]	; (1d64 <TCPIP_TCP_Task+0x3e4>)
    1a40:	681b      	ldr	r3, [r3, #0]
    1a42:	9305      	str	r3, [sp, #20]
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    1a44:	2300      	movs	r3, #0
	partialSkt = 0;
    1a46:	469a      	mov	sl, r3
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    1a48:	4619      	mov	r1, r3
    1a4a:	4610      	mov	r0, r2
    1a4c:	e00f      	b.n	1a6e <TCPIP_TCP_Task+0xee>
        calcChkSum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pTCPHdr, tcpTotLength, calcChkSum);
    1a4e:	461a      	mov	r2, r3
    1a50:	4629      	mov	r1, r5
    1a52:	4640      	mov	r0, r8
    1a54:	f018 fc32 	bl	1a2bc <TCPIP_Helper_CalcIPChecksum>
    1a58:	9004      	str	r0, [sp, #16]
    1a5a:	e7ca      	b.n	19f2 <TCPIP_TCP_Task+0x72>
            bool found = false;

            if(pSkt->smState == TCPIP_TCP_STATE_LISTEN)
            {
                // For listening ports, check if this is the correct port
                if(pSkt->remoteHash == h->DestPort && partialSkt == 0)
    1a5c:	f8b4 206a 	ldrh.w	r2, [r4, #106]	; 0x6a
    1a60:	4282      	cmp	r2, r0
    1a62:	d02f      	beq.n	1ac4 <TCPIP_TCP_Task+0x144>
    1a64:	3301      	adds	r3, #1
    1a66:	b21b      	sxth	r3, r3
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    1a68:	4619      	mov	r1, r3
    1a6a:	4563      	cmp	r3, ip
    1a6c:	d22f      	bcs.n	1ace <TCPIP_TCP_Task+0x14e>
        pSkt = TCBStubs[hTCP];
    1a6e:	9a05      	ldr	r2, [sp, #20]
    1a70:	f852 4021 	ldr.w	r4, [r2, r1, lsl #2]
        if(pSkt == 0 || pSkt->smState == TCPIP_TCP_STATE_CLIENT_WAIT_CONNECT)
    1a74:	2c00      	cmp	r4, #0
    1a76:	d0f5      	beq.n	1a64 <TCPIP_TCP_Task+0xe4>
    1a78:	f894 206e 	ldrb.w	r2, [r4, #110]	; 0x6e
    1a7c:	2a0b      	cmp	r2, #11
    1a7e:	d0f1      	beq.n	1a64 <TCPIP_TCP_Task+0xe4>
        if( (pSkt->addType == IP_ADDRESS_TYPE_ANY || pSkt->addType == addressType) &&
    1a80:	f894 106f 	ldrb.w	r1, [r4, #111]	; 0x6f
    1a84:	2901      	cmp	r1, #1
    1a86:	d8ed      	bhi.n	1a64 <TCPIP_TCP_Task+0xe4>
                (pSkt->pSktNet == 0 || pSkt->pSktNet == pPktIf) )
    1a88:	6c21      	ldr	r1, [r4, #64]	; 0x40
        if( (pSkt->addType == IP_ADDRESS_TYPE_ANY || pSkt->addType == addressType) &&
    1a8a:	b109      	cbz	r1, 1a90 <TCPIP_TCP_Task+0x110>
                (pSkt->pSktNet == 0 || pSkt->pSktNet == pPktIf) )
    1a8c:	458e      	cmp	lr, r1
    1a8e:	d1e9      	bne.n	1a64 <TCPIP_TCP_Task+0xe4>
            if(pSkt->smState == TCPIP_TCP_STATE_LISTEN)
    1a90:	2a00      	cmp	r2, #0
    1a92:	d0e3      	beq.n	1a5c <TCPIP_TCP_Task+0xdc>
                {
                    partialSkt = pSkt;
                }
                continue;
            }
            else if(pSkt->remoteHash != hash)
    1a94:	f8b4 206a 	ldrh.w	r2, [r4, #106]	; 0x6a
    1a98:	42b2      	cmp	r2, r6
    1a9a:	d1e3      	bne.n	1a64 <TCPIP_TCP_Task+0xe4>
            {// Ignore if the hash doesn't match
                continue;
            }

            while(	h->DestPort == pSkt->localPort && h->SourcePort == pSkt->remotePort )  
    1a9c:	f8db 1000 	ldr.w	r1, [fp]
    1aa0:	6da2      	ldr	r2, [r4, #88]	; 0x58
    1aa2:	4291      	cmp	r1, r2
    1aa4:	d1de      	bne.n	1a64 <TCPIP_TCP_Task+0xe4>
#endif  // defined (TCPIP_STACK_USE_IPV6)

#if defined (TCPIP_STACK_USE_IPV4)
                if (addressType == IP_ADDRESS_TYPE_IPV4)
                {
                    if (pSkt->destAddress.Val == ((IPV4_ADDR *)remoteIP)->Val)
    1aa6:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    1aa8:	68fa      	ldr	r2, [r7, #12]
    1aaa:	4291      	cmp	r1, r2
    1aac:	d1da      	bne.n	1a64 <TCPIP_TCP_Task+0xe4>
                break;
            }

            if(found)
            { 
                pSkt->addType = addressType;
    1aae:	2101      	movs	r1, #1
    1ab0:	f884 106f 	strb.w	r1, [r4, #111]	; 0x6f
    pSkt->pSktNet = pNet;
    1ab4:	f8c4 e040 	str.w	lr, [r4, #64]	; 0x40
    _TCPSetSourceAddress(pSkt, pSkt->addType, srcAddress);
    1ab8:	9a07      	ldr	r2, [sp, #28]
    1aba:	4620      	mov	r0, r4
    1abc:	f01c fe2d 	bl	1e71a <_TCPSetSourceAddress>
        pSkt = TCBStubs[hTCP];
    1ac0:	46a2      	mov	sl, r4
    1ac2:	e021      	b.n	1b08 <TCPIP_TCP_Task+0x188>
    1ac4:	f1ba 0f00 	cmp.w	sl, #0
    1ac8:	bf08      	it	eq
    1aca:	46a2      	moveq	sl, r4
    1acc:	e7ca      	b.n	1a64 <TCPIP_TCP_Task+0xe4>

	// If there is a partial match, then a listening socket is currently 
	// available.  Set up the extended TCB with the info needed 
	// to establish a connection and return this socket to the 
	// caller.
	while(partialSkt != 0)
    1ace:	f1ba 0f00 	cmp.w	sl, #0
    1ad2:	d07f      	beq.n	1bd4 <TCPIP_TCP_Task+0x254>
#endif  // defined (TCPIP_STACK_USE_IPV6)

#if defined (TCPIP_STACK_USE_IPV4)
            case IP_ADDRESS_TYPE_IPV4:
                // IPv4 lazy allocation
                pSkt->destAddress.Val = ((IPV4_ADDR *)remoteIP)->Val;
    1ad4:	68fb      	ldr	r3, [r7, #12]
    1ad6:	f8ca 3038 	str.w	r3, [sl, #56]	; 0x38
            default:    // shouldn't happen
                break;
        }

        // success; bind it
        pSkt->addType = addressType;
    1ada:	2101      	movs	r1, #1
    1adc:	f88a 106f 	strb.w	r1, [sl, #111]	; 0x6f
    pSkt->pSktNet = pNet;
    1ae0:	f8ca e040 	str.w	lr, [sl, #64]	; 0x40
    _TCPSetSourceAddress(pSkt, pSkt->addType, srcAddress);
    1ae4:	9a07      	ldr	r2, [sp, #28]
    1ae6:	4650      	mov	r0, sl
    1ae8:	f01c fe17 	bl	1e71a <_TCPSetSourceAddress>
        _TcpSocketBind(pSkt, pPktIf, (IP_MULTI_ADDRESS*)localIP);
        pSkt->remoteHash = hash;
    1aec:	f8aa 606a 	strh.w	r6, [sl, #106]	; 0x6a
        pSkt->remotePort = h->SourcePort;
    1af0:	f8bb 3000 	ldrh.w	r3, [fp]
    1af4:	f8aa 3058 	strh.w	r3, [sl, #88]	; 0x58
        pSkt->localPort = h->DestPort;
    1af8:	f8bb 3002 	ldrh.w	r3, [fp, #2]
    1afc:	f8aa 305a 	strh.w	r3, [sl, #90]	; 0x5a
        pSkt->txUnackedTail	= pSkt->txStart;
    1b00:	f8da 3000 	ldr.w	r3, [sl]
    1b04:	f8ca 3010 	str.w	r3, [sl, #16]
        pRxPkt->pDSeg->segLen -=  optionsSize + sizeof(*pTCPHdr);    
    1b08:	f8d9 2010 	ldr.w	r2, [r9, #16]
    1b0c:	8993      	ldrh	r3, [r2, #12]
    1b0e:	9906      	ldr	r1, [sp, #24]
    1b10:	1a5b      	subs	r3, r3, r1
    1b12:	8193      	strh	r3, [r2, #12]
    uint16_t nCopiedBytes;
    uint8_t* newRxHead;


     
    localHeaderFlags = h->Flags.byte;
    1b14:	f898 400d 	ldrb.w	r4, [r8, #13]
    localAckNumber = h->AckNumber;
    1b18:	f8d8 7008 	ldr.w	r7, [r8, #8]
    localSeqNumber = h->SeqNumber;
    1b1c:	f8d8 6004 	ldr.w	r6, [r8, #4]

    // We received a packet, reset the keep alive timer and count
    if(pSkt->Flags.keepAlive)
    1b20:	f89a 3037 	ldrb.w	r3, [sl, #55]	; 0x37
    1b24:	f013 0f40 	tst.w	r3, #64	; 0x40
    1b28:	d158      	bne.n	1bdc <TCPIP_TCP_Task+0x25c>
        {
            pSkt->eventTime = SYS_TMR_TickCountGet() + (pSkt->keepAliveTmo * SYS_TMR_TickCounterFrequencyGet())/1000;
        }
    }

    pSkt->flags.ackSent = 0;   // clear the ACK already sent
    1b2a:	f89a 306d 	ldrb.w	r3, [sl, #109]	; 0x6d
    1b2e:	f36f 0300 	bfc	r3, #0, #1
    1b32:	f88a 306d 	strb.w	r3, [sl, #109]	; 0x6d

    // Handle TCPIP_TCP_STATE_LISTEN and TCPIP_TCP_STATE_SYN_SENT states
    // Both of these states will return, so code following this 
    // state machine need not check explicitly for these two 
    // states.
    switch(pSkt->smState)
    1b36:	f89a 306e 	ldrb.w	r3, [sl, #110]	; 0x6e
    1b3a:	2b00      	cmp	r3, #0
    1b3c:	d069      	beq.n	1c12 <TCPIP_TCP_Task+0x292>
    1b3e:	2b01      	cmp	r3, #1
    1b40:	f000 80b6 	beq.w	1cb0 <TCPIP_TCP_Task+0x330>
        _TcpHandleSeg(pSkt, pTCPHdr, tcpTotLength - optionsSize - sizeof(*pTCPHdr), pRxPkt, &sktEvent);
    1b44:	3514      	adds	r5, #20
    1b46:	9a06      	ldr	r2, [sp, #24]
    1b48:	eba5 0b02 	sub.w	fp, r5, r2
    1b4c:	fa1f fb8b 	uxth.w	fp, fp
    1b50:	f1ab 0214 	sub.w	r2, fp, #20
    1b54:	b292      	uxth	r2, r2
    1b56:	9206      	str	r2, [sp, #24]

    //
    // First: check the sequence number
    //
    wSegmentLength = len = tcpLen;
    if(localHeaderFlags & FIN)
    1b58:	f014 0201 	ands.w	r2, r4, #1
    1b5c:	9207      	str	r2, [sp, #28]
    {
        wSegmentLength++;
    1b5e:	bf1a      	itte	ne
    1b60:	f1ab 0b13 	subne.w	fp, fp, #19
    1b64:	fa1f f28b 	uxthne.w	r2, fp
    wSegmentLength = len = tcpLen;
    1b68:	9a06      	ldreq	r2, [sp, #24]
    1b6a:	9205      	str	r2, [sp, #20]
    }
    if(localHeaderFlags & SYN)
    1b6c:	f014 0f02 	tst.w	r4, #2
    1b70:	d003      	beq.n	1b7a <TCPIP_TCP_Task+0x1fa>
    {
        wSegmentLength++;
    1b72:	9a05      	ldr	r2, [sp, #20]
    1b74:	3201      	adds	r2, #1
    1b76:	b292      	uxth	r2, r2
    1b78:	9205      	str	r2, [sp, #20]
    }

    // Calculate the RX FIFO space
    if(pSkt->rxHead >= pSkt->rxTail)
    1b7a:	f8da 501c 	ldr.w	r5, [sl, #28]
    1b7e:	f8da 2020 	ldr.w	r2, [sl, #32]
    1b82:	4295      	cmp	r5, r2
    1b84:	f0c0 80e5 	bcc.w	1d52 <TCPIP_TCP_Task+0x3d2>
    {
        wFreeSpace = (pSkt->rxEnd - pSkt->rxStart) - (pSkt->rxHead - pSkt->rxTail);
    1b88:	f8da 1018 	ldr.w	r1, [sl, #24]
    1b8c:	f8da 0014 	ldr.w	r0, [sl, #20]
    1b90:	1a09      	subs	r1, r1, r0
    1b92:	eba5 0b02 	sub.w	fp, r5, r2
    1b96:	eba1 0b0b 	sub.w	fp, r1, fp
    1b9a:	fa1f fb8b 	uxth.w	fp, fp
    {
        wFreeSpace = pSkt->rxTail - pSkt->rxHead - 1;
    }

    // Calculate the number of bytes ahead of our head pointer this segment skips
    lMissingBytes = localSeqNumber - pSkt->RemoteSEQ;
    1b9e:	f8da 2050 	ldr.w	r2, [sl, #80]	; 0x50
    1ba2:	1ab5      	subs	r5, r6, r2
    wMissingBytes = lMissingBytes; 

    // Run TCP acceptability tests to verify that this packet has a valid sequence number
    bSegmentAcceptable = false;
    if(wSegmentLength)
    1ba4:	9a05      	ldr	r2, [sp, #20]
    1ba6:	2a00      	cmp	r2, #0
    1ba8:	f000 80f0 	beq.w	1d8c <TCPIP_TCP_Task+0x40c>
    {
        // Check to see if we have free space, and if so, if any of the data falls within the freespace
        if(wFreeSpace)
    1bac:	f1bb 0f00 	cmp.w	fp, #0
    1bb0:	f000 80e2 	beq.w	1d78 <TCPIP_TCP_Task+0x3f8>
        {
            // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
            if((lMissingBytes >= 0) && (wFreeSpace > (uint32_t)lMissingBytes))
    1bb4:	2d00      	cmp	r5, #0
    1bb6:	f2c0 80d9 	blt.w	1d6c <TCPIP_TCP_Task+0x3ec>
    1bba:	455d      	cmp	r5, fp
    1bbc:	f0c0 80eb 	bcc.w	1d96 <TCPIP_TCP_Task+0x416>
                bSegmentAcceptable = true;
            }
            else
            {
                // RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND
                if((lMissingBytes + (int32_t)wSegmentLength > 0) && (lMissingBytes <= (int32_t)(wFreeSpace - wSegmentLength)))
    1bc0:	9a05      	ldr	r2, [sp, #20]
    1bc2:	ebab 0202 	sub.w	r2, fp, r2
                {
                    bSegmentAcceptable = true;
                }
            }

            if((lMissingBytes < (int32_t)wFreeSpace) && (wMissingBytes + (int32_t)wSegmentLength > 0))
    1bc6:	45ab      	cmp	fp, r5
    1bc8:	f300 80e5 	bgt.w	1d96 <TCPIP_TCP_Task+0x416>
                bSegmentAcceptable = true;
            }
        }
    }

    if(!bSegmentAcceptable)
    1bcc:	4295      	cmp	r5, r2
    1bce:	f340 80e2 	ble.w	1d96 <TCPIP_TCP_Task+0x416>
    1bd2:	e0d1      	b.n	1d78 <TCPIP_TCP_Task+0x3f8>
            ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    1bd4:	f06f 010e 	mvn.w	r1, #14
    1bd8:	f000 bc05 	b.w	23e6 <__ext_attr_.config_00804000+0x3e2>
        pSkt->keepAliveCount = 0;
    1bdc:	2300      	movs	r3, #0
    1bde:	f88a 3071 	strb.w	r3, [sl, #113]	; 0x71
        if(!pSkt->Flags.bTimerEnabled)
    1be2:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    1be6:	f013 0f02 	tst.w	r3, #2
    1bea:	d19e      	bne.n	1b2a <TCPIP_TCP_Task+0x1aa>
            pSkt->eventTime = SYS_TMR_TickCountGet() + (pSkt->keepAliveTmo * SYS_TMR_TickCounterFrequencyGet())/1000;
    1bec:	f01e f9de 	bl	1ffac <SYS_TMR_TickCountGet>
    1bf0:	4683      	mov	fp, r0
    1bf2:	f8ba 3068 	ldrh.w	r3, [sl, #104]	; 0x68
    1bf6:	9305      	str	r3, [sp, #20]
    1bf8:	f01e fa00 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
    1bfc:	9b05      	ldr	r3, [sp, #20]
    1bfe:	fb00 f003 	mul.w	r0, r0, r3
    1c02:	4b59      	ldr	r3, [pc, #356]	; (1d68 <TCPIP_TCP_Task+0x3e8>)
    1c04:	fba3 3000 	umull	r3, r0, r3, r0
    1c08:	eb0b 1090 	add.w	r0, fp, r0, lsr #6
    1c0c:	f8ca 0024 	str.w	r0, [sl, #36]	; 0x24
    1c10:	e78b      	b.n	1b2a <TCPIP_TCP_Task+0x1aa>
            if(localHeaderFlags & RST)
    1c12:	f014 0f04 	tst.w	r4, #4
    1c16:	d135      	bne.n	1c84 <TCPIP_TCP_Task+0x304>
            if(localHeaderFlags & ACK)
    1c18:	f014 0f10 	tst.w	r4, #16
    1c1c:	d137      	bne.n	1c8e <TCPIP_TCP_Task+0x30e>
            if(localHeaderFlags & SYN)
    1c1e:	f014 0f02 	tst.w	r4, #2
    1c22:	d040      	beq.n	1ca6 <TCPIP_TCP_Task+0x326>
                pSkt->RemoteSEQ = localSeqNumber + 1;
    1c24:	3601      	adds	r6, #1
    1c26:	f8ca 6050 	str.w	r6, [sl, #80]	; 0x50
                pSkt->wRemoteMSS = _GetMaxSegSizeOption(h);
    1c2a:	4640      	mov	r0, r8
    1c2c:	f014 fb54 	bl	162d8 <_GetMaxSegSizeOption>
    1c30:	f8aa 0062 	strh.w	r0, [sl, #98]	; 0x62
                _TCPSetHalfFlushFlag(pSkt);
    1c34:	4650      	mov	r0, sl
    1c36:	f01c f80d 	bl	1dc54 <_TCPSetHalfFlushFlag>
                _TcpSend(pSkt, SYN | ACK, SENDTCP_RESET_TIMERS);
    1c3a:	2201      	movs	r2, #1
    1c3c:	2112      	movs	r1, #18
    1c3e:	4650      	mov	r0, sl
    1c40:	f005 fa22 	bl	7088 <_TcpSend>
    pSkt->smState = newState;
    1c44:	2302      	movs	r3, #2
    1c46:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    1c4a:	2000      	movs	r0, #0
    1c4c:	f01f fc26 	bl	2149c <OSAL_CRIT_Enter>
    *pSigHandler = pSkt->sigHandler;
    1c50:	f8da 5074 	ldr.w	r5, [sl, #116]	; 0x74
    *pSigParam = pSkt->sigParam;
    1c54:	f8da 6078 	ldr.w	r6, [sl, #120]	; 0x78
    uint16_t sigMask = pSkt->sigMask;
    1c58:	f8ba 4072 	ldrh.w	r4, [sl, #114]	; 0x72
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
    1c5c:	4601      	mov	r1, r0
    1c5e:	2000      	movs	r0, #0
    1c60:	f01f fd4b 	bl	216fa <OSAL_CRIT_Leave>
        if((sktEvent &= sigMask) != 0)
    1c64:	9b04      	ldr	r3, [sp, #16]
    1c66:	ea14 0203 	ands.w	r2, r4, r3
    1c6a:	f000 8532 	beq.w	26d2 <__ext_attr_.config_00804000+0x6ce>
            if(sigHandler != 0)
    1c6e:	2d00      	cmp	r5, #0
    1c70:	f000 8531 	beq.w	26d6 <__ext_attr_.config_00804000+0x6d2>
                (*sigHandler)(pSkt->sktIx, pRxPkt->pktIf, sktEvent, sigParam);
    1c74:	4633      	mov	r3, r6
    1c76:	f8d9 1028 	ldr.w	r1, [r9, #40]	; 0x28
    1c7a:	f9ba 0034 	ldrsh.w	r0, [sl, #52]	; 0x34
    1c7e:	47a8      	blx	r5
        ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    1c80:	2102      	movs	r1, #2
    1c82:	e3b0      	b.n	23e6 <__ext_attr_.config_00804000+0x3e2>
                _TcpCloseSocket(pSkt, 0);	// Unbind remote IP address/port info
    1c84:	2100      	movs	r1, #0
    1c86:	4650      	mov	r0, sl
    1c88:	f00e fe9a 	bl	109c0 <_TcpCloseSocket>
                return;
    1c8c:	e7dd      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                pSkt->MySEQ = localAckNumber;
    1c8e:	f8ca 704c 	str.w	r7, [sl, #76]	; 0x4c
                _TcpSend(pSkt, RST, 0);
    1c92:	2200      	movs	r2, #0
    1c94:	2104      	movs	r1, #4
    1c96:	4650      	mov	r0, sl
    1c98:	f005 f9f6 	bl	7088 <_TcpSend>
                _TcpCloseSocket(pSkt, 0);	// Unbind remote IP address/port info
    1c9c:	2100      	movs	r1, #0
    1c9e:	4650      	mov	r0, sl
    1ca0:	f00e fe8e 	bl	109c0 <_TcpCloseSocket>
                return;
    1ca4:	e7d1      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                _TcpCloseSocket(pSkt, 0);	// Unbind remote IP address/port info
    1ca6:	2100      	movs	r1, #0
    1ca8:	4650      	mov	r0, sl
    1caa:	f00e fe89 	bl	109c0 <_TcpCloseSocket>
    1cae:	e7cc      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
            if(localHeaderFlags & RST)
    1cb0:	f014 0f04 	tst.w	r4, #4
    1cb4:	d1c9      	bne.n	1c4a <TCPIP_TCP_Task+0x2ca>
            if(localHeaderFlags & ACK)
    1cb6:	f014 0f10 	tst.w	r4, #16
    1cba:	f000 850e 	beq.w	26da <__ext_attr_.config_00804000+0x6d6>
                if(localAckNumber != pSkt->MySEQ)
    1cbe:	f8da 504c 	ldr.w	r5, [sl, #76]	; 0x4c
    1cc2:	42af      	cmp	r7, r5
    1cc4:	d12a      	bne.n	1d1c <TCPIP_TCP_Task+0x39c>
            if(localHeaderFlags & SYN)
    1cc6:	f014 0f02 	tst.w	r4, #2
    1cca:	d0be      	beq.n	1c4a <TCPIP_TCP_Task+0x2ca>
                pSkt->RemoteSEQ = localSeqNumber + 1;
    1ccc:	3601      	adds	r6, #1
    1cce:	f8ca 6050 	str.w	r6, [sl, #80]	; 0x50
                pSkt->remoteWindow = pSkt->maxRemoteWindow = h->Window;
    1cd2:	f8b8 300e 	ldrh.w	r3, [r8, #14]
    1cd6:	f8aa 3066 	strh.w	r3, [sl, #102]	; 0x66
    1cda:	f8aa 305c 	strh.w	r3, [sl, #92]	; 0x5c
                pSkt->wRemoteMSS = _GetMaxSegSizeOption(h);
    1cde:	4640      	mov	r0, r8
    1ce0:	f014 fafa 	bl	162d8 <_GetMaxSegSizeOption>
    1ce4:	f8aa 0062 	strh.w	r0, [sl, #98]	; 0x62
                _TCPSetHalfFlushFlag(pSkt);
    1ce8:	4650      	mov	r0, sl
    1cea:	f01b ffb3 	bl	1dc54 <_TCPSetHalfFlushFlag>
                    _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
    1cee:	2201      	movs	r2, #1
    1cf0:	2110      	movs	r1, #16
    1cf2:	4650      	mov	r0, sl
    1cf4:	f005 f9c8 	bl	7088 <_TcpSend>
    pSkt->smState = newState;
    1cf8:	2303      	movs	r3, #3
    1cfa:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
                    if(pSkt->Flags.keepAlive)
    1cfe:	f89a 3037 	ldrb.w	r3, [sl, #55]	; 0x37
    1d02:	f013 0f40 	tst.w	r3, #64	; 0x40
    1d06:	d113      	bne.n	1d30 <TCPIP_TCP_Task+0x3b0>
                    pSkt->Flags.bTimerEnabled = 0;
    1d08:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    1d0c:	f36f 0341 	bfc	r3, #1, #1
    1d10:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36
                    *pSktEvent |= TCPIP_TCP_SIGNAL_ESTABLISHED;
    1d14:	f44f 7380 	mov.w	r3, #256	; 0x100
    1d18:	9304      	str	r3, [sp, #16]
    1d1a:	e796      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                    pSkt->MySEQ = localAckNumber;	// Set SEQ = SEG.ACK
    1d1c:	f8ca 704c 	str.w	r7, [sl, #76]	; 0x4c
                    _TcpSend(pSkt, RST, SENDTCP_RESET_TIMERS);		// Send the RST
    1d20:	2201      	movs	r2, #1
    1d22:	2104      	movs	r1, #4
    1d24:	4650      	mov	r0, sl
    1d26:	f005 f9af 	bl	7088 <_TcpSend>
                    pSkt->MySEQ = localSeqNumber;	// Restore original SEQ number
    1d2a:	f8ca 504c 	str.w	r5, [sl, #76]	; 0x4c
                    return;
    1d2e:	e78c      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                        pSkt->eventTime = SYS_TMR_TickCountGet() + (pSkt->keepAliveTmo * SYS_TMR_TickCounterFrequencyGet())/1000;
    1d30:	f01e f93c 	bl	1ffac <SYS_TMR_TickCountGet>
    1d34:	4605      	mov	r5, r0
    1d36:	f8ba 4068 	ldrh.w	r4, [sl, #104]	; 0x68
    1d3a:	f01e f95f 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
    1d3e:	fb00 f304 	mul.w	r3, r0, r4
    1d42:	4a09      	ldr	r2, [pc, #36]	; (1d68 <TCPIP_TCP_Task+0x3e8>)
    1d44:	fba2 2303 	umull	r2, r3, r2, r3
    1d48:	eb05 1393 	add.w	r3, r5, r3, lsr #6
    1d4c:	f8ca 3024 	str.w	r3, [sl, #36]	; 0x24
    1d50:	e7da      	b.n	1d08 <TCPIP_TCP_Task+0x388>
        wFreeSpace = pSkt->rxTail - pSkt->rxHead - 1;
    1d52:	eba2 0b05 	sub.w	fp, r2, r5
    1d56:	f10b 3bff 	add.w	fp, fp, #4294967295
    1d5a:	fa1f fb8b 	uxth.w	fp, fp
    1d5e:	e71e      	b.n	1b9e <TCPIP_TCP_Task+0x21e>
    1d60:	2000e598 	.word	0x2000e598
    1d64:	2000e594 	.word	0x2000e594
    1d68:	10624dd3 	.word	0x10624dd3
                if((lMissingBytes + (int32_t)wSegmentLength > 0) && (lMissingBytes <= (int32_t)(wFreeSpace - wSegmentLength)))
    1d6c:	9905      	ldr	r1, [sp, #20]
    1d6e:	460a      	mov	r2, r1
    1d70:	1869      	adds	r1, r5, r1
    1d72:	2900      	cmp	r1, #0
    1d74:	f73f af25 	bgt.w	1bc2 <TCPIP_TCP_Task+0x242>
    {
        // Unacceptable segment, drop it and respond appropriately
        if(!(localHeaderFlags & RST)) 
    1d78:	f014 0f04 	tst.w	r4, #4
    1d7c:	f47f af65 	bne.w	1c4a <TCPIP_TCP_Task+0x2ca>
        {
            _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
    1d80:	2201      	movs	r2, #1
    1d82:	2110      	movs	r1, #16
    1d84:	4650      	mov	r0, sl
    1d86:	f005 f97f 	bl	7088 <_TcpSend>
    1d8a:	e75e      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
        if(lMissingBytes == 0)
    1d8c:	b11d      	cbz	r5, 1d96 <TCPIP_TCP_Task+0x416>
            if((lMissingBytes >= 0) && ((int32_t)wFreeSpace > lMissingBytes))
    1d8e:	2d00      	cmp	r5, #0
    1d90:	dbf2      	blt.n	1d78 <TCPIP_TCP_Task+0x3f8>
    1d92:	455d      	cmp	r5, fp
    1d94:	daf0      	bge.n	1d78 <TCPIP_TCP_Task+0x3f8>
    //
    // Fourth: check the SYN bit
    //
    // Note, that since the third step is not implemented, we can 
    // combine this second and fourth step into a single operation.
    if(localHeaderFlags & (RST | SYN))
    1d96:	f014 0f06 	tst.w	r4, #6
    1d9a:	d111      	bne.n	1dc0 <TCPIP_TCP_Task+0x440>
    // Feature not supported.  Let's process this segment.

    //
    // Fifth: check the ACK bit
    //
    if(!(localHeaderFlags & ACK))
    1d9c:	f014 0f10 	tst.w	r4, #16
    1da0:	f43f af53 	beq.w	1c4a <TCPIP_TCP_Task+0x2ca>
    {
        TCPIP_NDP_NborReachConfirm (pSkt->pSktNet, TCPIP_IPV6_DestAddressGet(pSkt->pV6Pkt));
    }
#endif  // defined (TCPIP_STACK_USE_IPV6)

    switch(pSkt->smState)
    1da4:	3b02      	subs	r3, #2
    1da6:	2b07      	cmp	r3, #7
    1da8:	f200 80fe 	bhi.w	1fa8 <TCPIP_TCP_Task+0x628>
    1dac:	e8df f013 	tbh	[pc, r3, lsl #1]
    1db0:	00240019 	.word	0x00240019
    1db4:	00240024 	.word	0x00240024
    1db8:	00fc0024 	.word	0x00fc0024
    1dbc:	01f90024 	.word	0x01f90024
        if(localHeaderFlags & RST)
    1dc0:	f014 0f04 	tst.w	r4, #4
    1dc4:	d008      	beq.n	1dd8 <TCPIP_TCP_Task+0x458>
            pSkt->Flags.bSocketReset = 1;
    1dc6:	f89a 3037 	ldrb.w	r3, [sl, #55]	; 0x37
    1dca:	f043 0302 	orr.w	r3, r3, #2
    1dce:	f88a 3037 	strb.w	r3, [sl, #55]	; 0x37
            *pSktEvent |= TCPIP_TCP_SIGNAL_RX_RST;
    1dd2:	f44f 6300 	mov.w	r3, #2048	; 0x800
    1dd6:	9304      	str	r3, [sp, #16]
        _TcpCloseSocket(pSkt, 0);
    1dd8:	2100      	movs	r1, #0
    1dda:	4650      	mov	r0, sl
    1ddc:	f00e fdf0 	bl	109c0 <_TcpCloseSocket>
        return;
    1de0:	e733      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
    {
        case TCPIP_TCP_STATE_SYN_RECEIVED:
            if(localAckNumber != pSkt->MySEQ)
    1de2:	f8da 304c 	ldr.w	r3, [sl, #76]	; 0x4c
    1de6:	9308      	str	r3, [sp, #32]
    1de8:	429f      	cmp	r7, r3
    1dea:	d120      	bne.n	1e2e <TCPIP_TCP_Task+0x4ae>
    pSkt->smState = newState;
    1dec:	2303      	movs	r3, #3
    1dee:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
                _TcpSend(pSkt, RST, SENDTCP_RESET_TIMERS);		// Send the RST
                pSkt->MySEQ = localSeqNumber;	// Restore original SEQ number
                return;
            }
            _TcpSocketSetState(pSkt, TCPIP_TCP_STATE_ESTABLISHED);
            *pSktEvent |= TCPIP_TCP_SIGNAL_ESTABLISHED;
    1df2:	f44f 7380 	mov.w	r3, #256	; 0x100
    1df6:	9304      	str	r3, [sp, #16]
        case TCPIP_TCP_STATE_FIN_WAIT_1:
        case TCPIP_TCP_STATE_FIN_WAIT_2:
        case TCPIP_TCP_STATE_CLOSE_WAIT:
        case TCPIP_TCP_STATE_CLOSING:
            // Calculate what the highest possible SEQ number in our TX FIFO is
            wTemp = pSkt->txHead - pSkt->txUnackedTail;
    1df8:	f8da c008 	ldr.w	ip, [sl, #8]
    1dfc:	f8da 3010 	ldr.w	r3, [sl, #16]
            if((int32_t)wTemp < 0)
    1e00:	ebbc 0003 	subs.w	r0, ip, r3
    1e04:	d41e      	bmi.n	1e44 <TCPIP_TCP_Task+0x4c4>
            {
                wTemp += pSkt->txEnd - pSkt->txStart;
            }
            dwTemp = pSkt->MySEQ + wTemp;
    1e06:	f8da 104c 	ldr.w	r1, [sl, #76]	; 0x4c

            // Drop the packet if it ACKs something we haven't sent
            dwTemp = localAckNumber - dwTemp;
    1e0a:	1a7a      	subs	r2, r7, r1
    1e0c:	1a12      	subs	r2, r2, r0
            if((int32_t)dwTemp > 0)
    1e0e:	2a00      	cmp	r2, #0
    1e10:	dd28      	ble.n	1e64 <TCPIP_TCP_Task+0x4e4>
            {   // acknowledged more than we've sent??
                if(!pSkt->flags.bFINSent || pSkt->flags.seqInc || dwTemp != 1)
    1e12:	f8ba 006c 	ldrh.w	r0, [sl, #108]	; 0x6c
    1e16:	f400 7001 	and.w	r0, r0, #516	; 0x204
    1e1a:	2804      	cmp	r0, #4
    1e1c:	d101      	bne.n	1e22 <TCPIP_TCP_Task+0x4a2>
    1e1e:	2a01      	cmp	r2, #1
    1e20:	d017      	beq.n	1e52 <TCPIP_TCP_Task+0x4d2>
                {
                    _TcpSend(pSkt, ACK, 0);
    1e22:	2200      	movs	r2, #0
    1e24:	2110      	movs	r1, #16
    1e26:	4650      	mov	r0, sl
    1e28:	f005 f92e 	bl	7088 <_TcpSend>
                    return;
    1e2c:	e70d      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                pSkt->MySEQ = localAckNumber;	// Set SEQ = SEG.ACK
    1e2e:	f8ca 704c 	str.w	r7, [sl, #76]	; 0x4c
                _TcpSend(pSkt, RST, SENDTCP_RESET_TIMERS);		// Send the RST
    1e32:	2201      	movs	r2, #1
    1e34:	2104      	movs	r1, #4
    1e36:	4650      	mov	r0, sl
    1e38:	f005 f926 	bl	7088 <_TcpSend>
                pSkt->MySEQ = localSeqNumber;	// Restore original SEQ number
    1e3c:	9b08      	ldr	r3, [sp, #32]
    1e3e:	f8ca 304c 	str.w	r3, [sl, #76]	; 0x4c
                return;
    1e42:	e702      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                wTemp += pSkt->txEnd - pSkt->txStart;
    1e44:	f8da 1004 	ldr.w	r1, [sl, #4]
    1e48:	f8da 2000 	ldr.w	r2, [sl]
    1e4c:	1a89      	subs	r1, r1, r2
    1e4e:	4408      	add	r0, r1
    1e50:	e7d9      	b.n	1e06 <TCPIP_TCP_Task+0x486>
                }
                else
                {
                    pSkt->MySEQ++;      // since we didn't count the FIN
    1e52:	3101      	adds	r1, #1
    1e54:	f8ca 104c 	str.w	r1, [sl, #76]	; 0x4c
                    pSkt->flags.seqInc = 1;
    1e58:	f89a 206d 	ldrb.w	r2, [sl, #109]	; 0x6d
    1e5c:	f042 0202 	orr.w	r2, r2, #2
    1e60:	f88a 206d 	strb.w	r2, [sl, #109]	; 0x6d
                }
            }

            // Throw away all ACKnowledged TX data:
            // Calculate what the last acknowledged sequence number was (ignoring any FINs we sent)
            dwTemp = pSkt->MySEQ - (uint32_t)(pSkt->txUnackedTail - pSkt->txTail);
    1e64:	f8da 204c 	ldr.w	r2, [sl, #76]	; 0x4c
    1e68:	9209      	str	r2, [sp, #36]	; 0x24
    1e6a:	f8da 100c 	ldr.w	r1, [sl, #12]
    1e6e:	9108      	str	r1, [sp, #32]
    1e70:	eba3 0e01 	sub.w	lr, r3, r1
            if(pSkt->txUnackedTail < pSkt->txTail)
    1e74:	428b      	cmp	r3, r1
    1e76:	d22f      	bcs.n	1ed8 <TCPIP_TCP_Task+0x558>
            {
                dwTemp -= pSkt->txEnd - pSkt->txStart;
    1e78:	f8da 0004 	ldr.w	r0, [sl, #4]
    1e7c:	f8da 1000 	ldr.w	r1, [sl]
    1e80:	1a41      	subs	r1, r0, r1
            }

            // Calcluate how many bytes were ACKed with this packet
            dwTemp = localAckNumber - dwTemp;
    1e82:	1ab8      	subs	r0, r7, r2
    1e84:	4470      	add	r0, lr
    1e86:	4408      	add	r0, r1
            if(((int32_t)(dwTemp) > 0) && (dwTemp <= pSkt->txEnd - pSkt->txStart))
    1e88:	2800      	cmp	r0, #0
    1e8a:	dd38      	ble.n	1efe <TCPIP_TCP_Task+0x57e>
    1e8c:	f8da 2004 	ldr.w	r2, [sl, #4]
    1e90:	920a      	str	r2, [sp, #40]	; 0x28
    1e92:	f8da 1000 	ldr.w	r1, [sl]
    1e96:	1a52      	subs	r2, r2, r1
    1e98:	920b      	str	r2, [sp, #44]	; 0x2c
    1e9a:	4290      	cmp	r0, r2
    1e9c:	d82c      	bhi.n	1ef8 <TCPIP_TCP_Task+0x578>
            {
                pSkt->flags.bRXNoneACKed1 = 0;
    1e9e:	f89a 106c 	ldrb.w	r1, [sl, #108]	; 0x6c
                pSkt->flags.bRXNoneACKed2 = 0;
    1ea2:	f001 01ef 	and.w	r1, r1, #239	; 0xef
    1ea6:	f36f 1145 	bfc	r1, #5, #1
    1eaa:	f88a 106c 	strb.w	r1, [sl, #108]	; 0x6c
                pSkt->Flags.bHalfFullFlush = false;
    1eae:	f89a 1036 	ldrb.w	r1, [sl, #54]	; 0x36
    1eb2:	f36f 1145 	bfc	r1, #5, #1
    1eb6:	f88a 1036 	strb.w	r1, [sl, #54]	; 0x36

                // Bytes ACKed, free up the TX FIFO space
                ptrTemp = pSkt->txTail;
                pSkt->txTail += dwTemp;
    1eba:	9a08      	ldr	r2, [sp, #32]
    1ebc:	4402      	add	r2, r0
    1ebe:	f8ca 200c 	str.w	r2, [sl, #12]
                        pSkt->txUnackedTail = pSkt->txTail;
                    }
                }
                else
                {
                    ptrTemp = pSkt->txUnackedTail + (pSkt->txEnd - pSkt->txStart);
    1ec2:	990b      	ldr	r1, [sp, #44]	; 0x2c
    1ec4:	440b      	add	r3, r1
                    if(ptrTemp < pSkt->txTail)
    1ec6:	4293      	cmp	r3, r2
    1ec8:	f0c0 80ff 	bcc.w	20ca <__ext_attr_.config_00804000+0xc6>
                    {
                        pSkt->MySEQ += pSkt->txTail - ptrTemp;
                        pSkt->txUnackedTail = pSkt->txTail;
                    }
                }
                if(pSkt->txTail >= pSkt->txEnd)
    1ecc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1ece:	429a      	cmp	r2, r3
    1ed0:	f0c0 8455 	bcc.w	277e <__ext_attr_.config_00804000+0x77a>
    1ed4:	f000 bc4f 	b.w	2776 <__ext_attr_.config_00804000+0x772>
            dwTemp = localAckNumber - dwTemp;
    1ed8:	9909      	ldr	r1, [sp, #36]	; 0x24
    1eda:	1a78      	subs	r0, r7, r1
    1edc:	4470      	add	r0, lr
            if(((int32_t)(dwTemp) > 0) && (dwTemp <= pSkt->txEnd - pSkt->txStart))
    1ede:	2800      	cmp	r0, #0
    1ee0:	dd0a      	ble.n	1ef8 <TCPIP_TCP_Task+0x578>
    1ee2:	f8da 1004 	ldr.w	r1, [sl, #4]
    1ee6:	460a      	mov	r2, r1
    1ee8:	910a      	str	r1, [sp, #40]	; 0x28
    1eea:	f8da 1000 	ldr.w	r1, [sl]
    1eee:	1a52      	subs	r2, r2, r1
    1ef0:	920b      	str	r2, [sp, #44]	; 0x2c
    1ef2:	4290      	cmp	r0, r2
    1ef4:	f240 8420 	bls.w	2738 <__ext_attr_.config_00804000+0x734>
                }
            }
            else
            {   // no acknowledge
                // See if we have outstanding TX data that is waiting for an ACK
                if(pSkt->txTail != pSkt->txUnackedTail)
    1ef8:	9a08      	ldr	r2, [sp, #32]
    1efa:	4293      	cmp	r3, r2
    1efc:	d02c      	beq.n	1f58 <TCPIP_TCP_Task+0x5d8>
                {
                    if(pSkt->flags.bRXNoneACKed1)
    1efe:	f89a 106c 	ldrb.w	r1, [sl, #108]	; 0x6c
    1f02:	f011 0f10 	tst.w	r1, #16
    1f06:	d021      	beq.n	1f4c <TCPIP_TCP_Task+0x5cc>
                    {
                        if(pSkt->flags.bRXNoneACKed2)
    1f08:	f011 0f20 	tst.w	r1, #32
    1f0c:	d018      	beq.n	1f40 <TCPIP_TCP_Task+0x5c0>
            dwTemp = pSkt->MySEQ - (uint32_t)(pSkt->txUnackedTail - pSkt->txTail);
    1f0e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    1f10:	eba2 010e 	sub.w	r1, r2, lr
                        {
                            // Set up to perform a fast retransmission
                            // Roll back unacknowledged TX tail pointer to cause retransmit to occur
                            pSkt->MySEQ -= (pSkt->txUnackedTail - pSkt->txTail);
    1f14:	f8ca 104c 	str.w	r1, [sl, #76]	; 0x4c
                            if(pSkt->txUnackedTail < pSkt->txTail)
    1f18:	9a08      	ldr	r2, [sp, #32]
    1f1a:	4293      	cmp	r3, r2
    1f1c:	d207      	bcs.n	1f2e <TCPIP_TCP_Task+0x5ae>
                            {
                                pSkt->MySEQ -= (pSkt->txEnd - pSkt->txStart);
    1f1e:	f8da 3004 	ldr.w	r3, [sl, #4]
    1f22:	f8da 0000 	ldr.w	r0, [sl]
    1f26:	1a1b      	subs	r3, r3, r0
    1f28:	1acb      	subs	r3, r1, r3
    1f2a:	f8ca 304c 	str.w	r3, [sl, #76]	; 0x4c
                            }
                            pSkt->txUnackedTail = pSkt->txTail;
    1f2e:	9b08      	ldr	r3, [sp, #32]
    1f30:	f8ca 3010 	str.w	r3, [sl, #16]
                            pSkt->Flags.bTXASAPWithoutTimerReset = 1;
    1f34:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    1f38:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    1f3c:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36
                        }
                        pSkt->flags.bRXNoneACKed2 = 1;
    1f40:	f89a 306c 	ldrb.w	r3, [sl, #108]	; 0x6c
    1f44:	f043 0320 	orr.w	r3, r3, #32
    1f48:	f88a 306c 	strb.w	r3, [sl, #108]	; 0x6c
                    }
                    pSkt->flags.bRXNoneACKed1 = 1;
    1f4c:	f89a 306c 	ldrb.w	r3, [sl, #108]	; 0x6c
    1f50:	f043 0310 	orr.w	r3, r3, #16
    1f54:	f88a 306c 	strb.w	r3, [sl, #108]	; 0x6c
                }
            }

            // No need to keep our retransmit timer going if we have nothing that needs ACKing anymore
            if(pSkt->txTail == pSkt->txHead)
    1f58:	f8da 300c 	ldr.w	r3, [sl, #12]
    1f5c:	459c      	cmp	ip, r3
    1f5e:	f000 80bc 	beq.w	20da <__ext_attr_.config_00804000+0xd6>
                    }
                }
            }

            // update the max window
            if(h->Window > pSkt->maxRemoteWindow)
    1f62:	f8b8 300e 	ldrh.w	r3, [r8, #14]
    1f66:	f8ba 2066 	ldrh.w	r2, [sl, #102]	; 0x66
    1f6a:	429a      	cmp	r2, r3
            {
                pSkt->maxRemoteWindow = h->Window;
    1f6c:	bf38      	it	cc
    1f6e:	f8aa 3066 	strhcc.w	r3, [sl, #102]	; 0x66
            }
            // The window size advertised in this packet is adjusted to account 
            // for any bytes that we have transmitted but haven't been ACKed yet 
            // by this segment.
            wNewWindow = h->Window - ((uint16_t)(pSkt->MySEQ - localAckNumber));
    1f72:	f8da 204c 	ldr.w	r2, [sl, #76]	; 0x4c
    1f76:	f8b8 300e 	ldrh.w	r3, [r8, #14]
    1f7a:	443b      	add	r3, r7
    1f7c:	1a9b      	subs	r3, r3, r2
    1f7e:	b29b      	uxth	r3, r3

            // Update the local stored copy of the RemoteWindow.
            // If previously we had a zero window, and now we don't, then 
            // immediately send whatever was pending.
            if((pSkt->remoteWindow == 0u) && wNewWindow)
    1f80:	f8ba 105c 	ldrh.w	r1, [sl, #92]	; 0x5c
    1f84:	b931      	cbnz	r1, 1f94 <TCPIP_TCP_Task+0x614>
    1f86:	b12b      	cbz	r3, 1f94 <TCPIP_TCP_Task+0x614>
            {
                pSkt->Flags.bTXASAP = 1;
    1f88:	f89a 1036 	ldrb.w	r1, [sl, #54]	; 0x36
    1f8c:	f041 0140 	orr.w	r1, r1, #64	; 0x40
    1f90:	f88a 1036 	strb.w	r1, [sl, #54]	; 0x36
            }
            pSkt->remoteWindow = wNewWindow;
    1f94:	f8aa 305c 	strh.w	r3, [sl, #92]	; 0x5c

            // A couple of states must do all of the TCPIP_TCP_STATE_ESTABLISHED stuff, but also a little more
            if(pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1)
    1f98:	f89a 306e 	ldrb.w	r3, [sl, #110]	; 0x6e
    1f9c:	2b04      	cmp	r3, #4
    1f9e:	f000 80d7 	beq.w	2150 <__ext_attr_.config_00804000+0x14c>
                    // doesn't send us a FIN in a timely manner.
                    pSkt->closeWaitTime = SYS_TMR_TickCountGet() + (TCPIP_TCP_FIN_WAIT_2_TIMEOUT * SYS_TMR_TickCounterFrequencyGet())/1000;
                    _TcpSocketSetState(pSkt, TCPIP_TCP_STATE_FIN_WAIT_2);
                }
            }
            else if(pSkt->smState == TCPIP_TCP_STATE_CLOSING)
    1fa2:	2b06      	cmp	r3, #6
    1fa4:	f000 80f5 	beq.w	2192 <__ext_attr_.config_00804000+0x18e>
    //
    // Sixth: Check the URG bit
    //
    // Urgent packets are not supported in this stack, so we
    // will throw them away instead
    if(localHeaderFlags & URG)
    1fa8:	f014 0f20 	tst.w	r4, #32
    1fac:	f47f ae4d 	bne.w	1c4a <TCPIP_TCP_Task+0x2ca>

    //
    // Seventh: Process the segment text
    //
    // Throw data away if in a state that doesn't accept data
    if(pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT || pSkt->smState == TCPIP_TCP_STATE_CLOSING || pSkt->smState == TCPIP_TCP_STATE_LAST_ACK)
    1fb0:	f89a 206e 	ldrb.w	r2, [sl, #110]	; 0x6e
    1fb4:	f1a2 0308 	sub.w	r3, r2, #8
    1fb8:	b2db      	uxtb	r3, r3
    1fba:	2b01      	cmp	r3, #1
    1fbc:	f67f ae45 	bls.w	1c4a <TCPIP_TCP_Task+0x2ca>
    1fc0:	2a06      	cmp	r2, #6
    1fc2:	f43f ae42 	beq.w	1c4a <TCPIP_TCP_Task+0x2ca>
    {
        return;
    }

    // Copy any valid segment data into our RX FIFO, if any
    if(len)
    1fc6:	9a06      	ldr	r2, [sp, #24]
    1fc8:	2a00      	cmp	r2, #0
    1fca:	d03d      	beq.n	2048 <__ext_attr_.config_00804000+0x44>
    {
        // See if there are bytes we must skip
        // wMissingBytes == 0: this new data is in sync with what we expect
        // wMissingBytes  < 0: this packet contains old data that needs to be skipped
        if(wMissingBytes <= 0)
    1fcc:	2d00      	cmp	r5, #0
    1fce:	f340 80f3 	ble.w	21b8 <__ext_attr_.config_00804000+0x1b4>
        } 
        else if(wMissingBytes > 0)
        {   // wMissingBytes  > 0: this packet contains ahead data
            // This packet is out of order or we lost a packet, see if we can generate a hole to accomodate it
            // Truncate packets that would overflow our TCP RX FIFO
            if(len + wMissingBytes > wFreeSpace)
    1fd2:	9b06      	ldr	r3, [sp, #24]
    1fd4:	442b      	add	r3, r5
    1fd6:	455b      	cmp	r3, fp
    1fd8:	dd04      	ble.n	1fe4 <TCPIP_TCP_Task+0x664>
            {
                len = wFreeSpace - wMissingBytes;
    1fda:	ebab 0b05 	sub.w	fp, fp, r5
    1fde:	fa1f f38b 	uxth.w	r3, fp
    1fe2:	9306      	str	r3, [sp, #24]
            }

            // Position packet read pointer to start of useful data area.
            pSegSrc = (uint8_t*)h + (h->DataOffset.Val << 2);
    1fe4:	f898 300c 	ldrb.w	r3, [r8, #12]
    1fe8:	091b      	lsrs	r3, r3, #4
    1fea:	eb08 0383 	add.w	r3, r8, r3, lsl #2
    1fee:	930c      	str	r3, [sp, #48]	; 0x30

            // See if we need a two part copy (spans rxEnd->rxStart)
            if(pSkt->rxHead + wMissingBytes + len > pSkt->rxEnd)
    1ff0:	f8da 101c 	ldr.w	r1, [sl, #28]
    1ff4:	f8da 3018 	ldr.w	r3, [sl, #24]
    1ff8:	9a06      	ldr	r2, [sp, #24]
    1ffa:	442a      	add	r2, r5
    1ffc:	440a      	add	r2, r1
    1ffe:	4293      	cmp	r3, r2
    2000:	f080 8169 	bcs.w	22d6 <__ext_attr_.config_00804000+0x2d2>
            {
                // Calculate number of data bytes to copy before wraparound
                wTemp = pSkt->rxEnd - pSkt->rxHead + 1 - wMissingBytes;
    2004:	1a5a      	subs	r2, r3, r1
    2006:	3201      	adds	r2, #1
                if((int32_t)wTemp >= 0)
    2008:	1b52      	subs	r2, r2, r5
    200a:	f100 8156 	bmi.w	22ba <__ext_attr_.config_00804000+0x2b6>
                {
                    nCopiedBytes = TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxHead + wMissingBytes, &pSegSrc, wTemp, true);
    200e:	fa1f f882 	uxth.w	r8, r2
    2012:	2401      	movs	r4, #1
    2014:	9400      	str	r4, [sp, #0]
    2016:	4643      	mov	r3, r8
    2018:	a80c      	add	r0, sp, #48	; 0x30
    201a:	4602      	mov	r2, r0
    201c:	4429      	add	r1, r5
    201e:	4648      	mov	r0, r9
    2020:	f017 fcfe 	bl	19a20 <TCPIP_Helper_PacketCopy>
    2024:	4683      	mov	fp, r0
                    nCopiedBytes += TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxStart, &pSegSrc, len - wTemp, true);
    2026:	9a06      	ldr	r2, [sp, #24]
    2028:	eba2 0308 	sub.w	r3, r2, r8
    202c:	9400      	str	r4, [sp, #0]
    202e:	b29b      	uxth	r3, r3
    2030:	aa0c      	add	r2, sp, #48	; 0x30
    2032:	f8da 1014 	ldr.w	r1, [sl, #20]
    2036:	4648      	mov	r0, r9
    2038:	f017 fcf2 	bl	19a20 <TCPIP_Helper_PacketCopy>
    203c:	4458      	add	r0, fp
    203e:	b280      	uxth	r0, r0
            else
            {
                nCopiedBytes = TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxHead + wMissingBytes, &pSegSrc, len, true);
            }

            if(nCopiedBytes == len)
    2040:	9b06      	ldr	r3, [sp, #24]
    2042:	4283      	cmp	r3, r0
    2044:	f000 8150 	beq.w	22e8 <__ext_attr_.config_00804000+0x2e4>
    // Send back an ACK of the data (+SYN | FIN) we just received, 
    // if any.  To minimize bandwidth waste, we are implementing 
    // the delayed acknowledgement algorithm here, only sending 
    // back an immediate ACK if this is the second segment received.  
    // Otherwise, a 200ms timer will cause the ACK to be transmitted.
    if(wSegmentLength)
    2048:	9b05      	ldr	r3, [sp, #20]
    204a:	b1cb      	cbz	r3, 2080 <__ext_attr_.config_00804000+0x7c>
        // For non-established sockets, delete all data in 
        // the RX buffer immediately after receiving it.
        // That'll ensure that the RX window is nonzero and 
        // the remote node will be able to send a FIN response, 
        // which needs an RX window of at least 1.
        if(pSkt->smState != TCPIP_TCP_STATE_ESTABLISHED && pSkt->smState != TCPIP_TCP_STATE_FIN_WAIT_1 && pSkt->smState != TCPIP_TCP_STATE_FIN_WAIT_2)
    204c:	f89a 306e 	ldrb.w	r3, [sl, #110]	; 0x6e
    2050:	3b03      	subs	r3, #3
    2052:	b2db      	uxtb	r3, r3
    2054:	2b02      	cmp	r3, #2
        {
            pSkt->rxTail = pSkt->rxHead;
    2056:	bf84      	itt	hi
    2058:	f8da 301c 	ldrhi.w	r3, [sl, #28]
    205c:	f8ca 3020 	strhi.w	r3, [sl, #32]
        }

        if(pSkt->Flags.bOneSegmentReceived)
    2060:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    2064:	f013 0f10 	tst.w	r3, #16
    2068:	f040 816d 	bne.w	2346 <__ext_attr_.config_00804000+0x342>
            _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
            // bOneSegmentReceived is cleared in _TcpSend(pSkt, ), so no need here
        }
        else
        {
            pSkt->Flags.bOneSegmentReceived = true;	
    206c:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    2070:	f043 0310 	orr.w	r3, r3, #16
    2074:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36

            // Do not send an ACK immediately back.  Instead, we will 
            // perform delayed acknowledgements.  To do this, we will 
            // just start a timer
            if(!pSkt->Flags.bDelayedACKTimerEnabled)
    2078:	f013 0f08 	tst.w	r3, #8
    207c:	f000 8169 	beq.w	2352 <__ext_attr_.config_00804000+0x34e>
    }

    //
    // Eighth: check the FIN bit
    //
    if(localHeaderFlags & FIN)
    2080:	9b07      	ldr	r3, [sp, #28]
    2082:	2b00      	cmp	r3, #0
    2084:	f43f ade1 	beq.w	1c4a <TCPIP_TCP_Task+0x2ca>
    {
        // Note: Since we don't have a good means of storing "FIN bytes" 
        // in our TCP RX FIFO, we must ensure that FINs are processed 
        // in-order.
        if(pSkt->RemoteSEQ + 1 == localSeqNumber + (uint32_t)wSegmentLength)
    2088:	f8da 3050 	ldr.w	r3, [sl, #80]	; 0x50
    208c:	3301      	adds	r3, #1
    208e:	9a05      	ldr	r2, [sp, #20]
    2090:	4432      	add	r2, r6
    2092:	4293      	cmp	r3, r2
    2094:	f47f add9 	bne.w	1c4a <TCPIP_TCP_Task+0x2ca>
        {
            // FINs are treated as one byte of data for ACK sequencing
            pSkt->RemoteSEQ++;
    2098:	f8ca 3050 	str.w	r3, [sl, #80]	; 0x50

            *pSktEvent |= TCPIP_TCP_SIGNAL_RX_FIN;
    209c:	9b04      	ldr	r3, [sp, #16]
    209e:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
    20a2:	b293      	uxth	r3, r2
    20a4:	9304      	str	r3, [sp, #16]
            pSkt->Flags.bRxFin = 1;
    20a6:	f89a 3037 	ldrb.w	r3, [sl, #55]	; 0x37
    20aa:	f043 0304 	orr.w	r3, r3, #4
    20ae:	f88a 3037 	strb.w	r3, [sl, #55]	; 0x37
            switch(pSkt->smState)
    20b2:	f89a 306e 	ldrb.w	r3, [sl, #110]	; 0x6e
    20b6:	3b02      	subs	r3, #2
    20b8:	2b03      	cmp	r3, #3
    20ba:	f200 8178 	bhi.w	23ae <__ext_attr_.config_00804000+0x3aa>
    20be:	e8df f013 	tbh	[pc, r3, lsl #1]
    20c2:	015d      	.short	0x015d
    20c4:	016f0166 	.word	0x016f0166
    20c8:	0186      	.short	0x0186
                        pSkt->MySEQ += pSkt->txTail - ptrTemp;
    20ca:	1ad3      	subs	r3, r2, r3
    20cc:	9909      	ldr	r1, [sp, #36]	; 0x24
    20ce:	440b      	add	r3, r1
    20d0:	f8ca 304c 	str.w	r3, [sl, #76]	; 0x4c
                        pSkt->txUnackedTail = pSkt->txTail;
    20d4:	f8ca 2010 	str.w	r2, [sl, #16]
    20d8:	e34a      	b.n	2770 <__ext_attr_.config_00804000+0x76c>
                if(pSkt->Flags.bTXFIN == 0u)
    20da:	f89a 3037 	ldrb.w	r3, [sl, #55]	; 0x37
    20de:	f013 0f01 	tst.w	r3, #1
    20e2:	d11d      	bne.n	2120 <__ext_attr_.config_00804000+0x11c>
                    if(pSkt->Flags.keepAlive)
    20e4:	f013 0f40 	tst.w	r3, #64	; 0x40
    20e8:	d106      	bne.n	20f8 <__ext_attr_.config_00804000+0xf4>
                    pSkt->Flags.bTimerEnabled = 0;
    20ea:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    20ee:	f36f 0341 	bfc	r3, #1, #1
    20f2:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36
    20f6:	e734      	b.n	1f62 <TCPIP_TCP_Task+0x5e2>
                        pSkt->eventTime = SYS_TMR_TickCountGet() + (pSkt->keepAliveTmo * SYS_TMR_TickCounterFrequencyGet())/1000;
    20f8:	f01d ff58 	bl	1ffac <SYS_TMR_TickCountGet>
    20fc:	9008      	str	r0, [sp, #32]
    20fe:	f8ba 3068 	ldrh.w	r3, [sl, #104]	; 0x68
    2102:	9309      	str	r3, [sp, #36]	; 0x24
    2104:	f01d ff7a 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
    2108:	9b09      	ldr	r3, [sp, #36]	; 0x24
    210a:	fb00 f303 	mul.w	r3, r0, r3
    210e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    2112:	fbb3 f3f2 	udiv	r3, r3, r2
    2116:	9a08      	ldr	r2, [sp, #32]
    2118:	4413      	add	r3, r2
    211a:	f8ca 3024 	str.w	r3, [sl, #36]	; 0x24
    211e:	e7e4      	b.n	20ea <__ext_attr_.config_00804000+0xe6>
                    if((pSkt->MySEQ == localAckNumber) && pSkt->flags.bFINSent)
    2120:	f8da 304c 	ldr.w	r3, [sl, #76]	; 0x4c
    2124:	429f      	cmp	r7, r3
    2126:	f47f af1c 	bne.w	1f62 <TCPIP_TCP_Task+0x5e2>
    212a:	f89a 306c 	ldrb.w	r3, [sl, #108]	; 0x6c
    212e:	f013 0f04 	tst.w	r3, #4
    2132:	f43f af16 	beq.w	1f62 <TCPIP_TCP_Task+0x5e2>
                        pSkt->Flags.bTimerEnabled = 0;
    2136:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    213a:	f36f 0341 	bfc	r3, #1, #1
    213e:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36
                        pSkt->Flags.bTXFIN = 0;
    2142:	f89a 3037 	ldrb.w	r3, [sl, #55]	; 0x37
    2146:	f36f 0300 	bfc	r3, #0, #1
    214a:	f88a 3037 	strb.w	r3, [sl, #55]	; 0x37
    214e:	e708      	b.n	1f62 <TCPIP_TCP_Task+0x5e2>
                if((pSkt->MySEQ == localAckNumber) && pSkt->flags.bFINSent)
    2150:	4297      	cmp	r7, r2
    2152:	d004      	beq.n	215e <__ext_attr_.config_00804000+0x15a>
    if(localHeaderFlags & URG)
    2154:	f014 0f20 	tst.w	r4, #32
    2158:	f43f af35 	beq.w	1fc6 <TCPIP_TCP_Task+0x646>
    215c:	e575      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                if((pSkt->MySEQ == localAckNumber) && pSkt->flags.bFINSent)
    215e:	f89a 306c 	ldrb.w	r3, [sl, #108]	; 0x6c
    2162:	f013 0f04 	tst.w	r3, #4
    2166:	d0f5      	beq.n	2154 <__ext_attr_.config_00804000+0x150>
                    pSkt->closeWaitTime = SYS_TMR_TickCountGet() + (TCPIP_TCP_FIN_WAIT_2_TIMEOUT * SYS_TMR_TickCounterFrequencyGet())/1000;
    2168:	f01d ff20 	bl	1ffac <SYS_TMR_TickCountGet>
    216c:	9008      	str	r0, [sp, #32]
    216e:	f01d ff45 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
    2172:	f241 3388 	movw	r3, #5000	; 0x1388
    2176:	fb03 f300 	mul.w	r3, r3, r0
    217a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    217e:	fbb3 f3f2 	udiv	r3, r3, r2
    2182:	9a08      	ldr	r2, [sp, #32]
    2184:	4413      	add	r3, r2
    2186:	f8ca 3030 	str.w	r3, [sl, #48]	; 0x30
    pSkt->smState = newState;
    218a:	2305      	movs	r3, #5
    218c:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
    2190:	e7e0      	b.n	2154 <__ext_attr_.config_00804000+0x150>
                if(pSkt->MySEQ == localAckNumber)
    2192:	4297      	cmp	r7, r2
    2194:	f47f ad59 	bne.w	1c4a <TCPIP_TCP_Task+0x2ca>
                    _TcpCloseSocket(pSkt, 0);
    2198:	2100      	movs	r1, #0
    219a:	4650      	mov	r0, sl
    219c:	f00e fc10 	bl	109c0 <_TcpCloseSocket>
    21a0:	e553      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
            if(pSkt->MySEQ + 1 == localAckNumber)
    21a2:	f8da 304c 	ldr.w	r3, [sl, #76]	; 0x4c
    21a6:	3301      	adds	r3, #1
    21a8:	429f      	cmp	r7, r3
    21aa:	f47f ad4e 	bne.w	1c4a <TCPIP_TCP_Task+0x2ca>
                _TcpCloseSocket(pSkt, 0);
    21ae:	2100      	movs	r1, #0
    21b0:	4650      	mov	r0, sl
    21b2:	f00e fc05 	bl	109c0 <_TcpCloseSocket>
    21b6:	e548      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
            pSegSrc = (uint8_t*)h + ((h->DataOffset.Val << 2) - wMissingBytes);
    21b8:	f898 300c 	ldrb.w	r3, [r8, #12]
    21bc:	091b      	lsrs	r3, r3, #4
    21be:	ebc5 0383 	rsb	r3, r5, r3, lsl #2
    21c2:	4443      	add	r3, r8
    21c4:	930c      	str	r3, [sp, #48]	; 0x30
            len += wMissingBytes;		
    21c6:	442a      	add	r2, r5
    21c8:	b293      	uxth	r3, r2
            if(len > wFreeSpace)
    21ca:	459b      	cmp	fp, r3
    21cc:	bf28      	it	cs
    21ce:	469b      	movcs	fp, r3
            if(pSkt->rxHead + len > pSkt->rxEnd)
    21d0:	f8da 101c 	ldr.w	r1, [sl, #28]
    21d4:	f8da 3018 	ldr.w	r3, [sl, #24]
    21d8:	eb01 020b 	add.w	r2, r1, fp
    21dc:	4293      	cmp	r3, r2
    21de:	d25c      	bcs.n	229a <__ext_attr_.config_00804000+0x296>
                wTemp = pSkt->rxEnd - pSkt->rxHead + 1;
    21e0:	1a5b      	subs	r3, r3, r1
    21e2:	f103 0801 	add.w	r8, r3, #1
                nCopiedBytes = TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxHead, &pSegSrc, wTemp, true);
    21e6:	fa1f f588 	uxth.w	r5, r8
    21ea:	2401      	movs	r4, #1
    21ec:	9400      	str	r4, [sp, #0]
    21ee:	462b      	mov	r3, r5
    21f0:	aa0c      	add	r2, sp, #48	; 0x30
    21f2:	4648      	mov	r0, r9
    21f4:	f017 fc14 	bl	19a20 <TCPIP_Helper_PacketCopy>
    21f8:	9006      	str	r0, [sp, #24]
                nCopiedBytes += TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxStart, &pSegSrc, len - wTemp, true);
    21fa:	ebab 0305 	sub.w	r3, fp, r5
    21fe:	9400      	str	r4, [sp, #0]
    2200:	b29b      	uxth	r3, r3
    2202:	aa0c      	add	r2, sp, #48	; 0x30
    2204:	f8da 1014 	ldr.w	r1, [sl, #20]
    2208:	4648      	mov	r0, r9
    220a:	f017 fc09 	bl	19a20 <TCPIP_Helper_PacketCopy>
    220e:	9b06      	ldr	r3, [sp, #24]
    2210:	4403      	add	r3, r0
    2212:	b298      	uxth	r0, r3
                newRxHead = pSkt->rxStart + (len - wTemp);
    2214:	ebab 0308 	sub.w	r3, fp, r8
    2218:	f8da 2014 	ldr.w	r2, [sl, #20]
    221c:	4413      	add	r3, r2
            if(nCopiedBytes == len)
    221e:	4558      	cmp	r0, fp
    2220:	f47f af12 	bne.w	2048 <__ext_attr_.config_00804000+0x44>
                pSkt->RemoteSEQ += (uint32_t)len;
    2224:	f8da 1050 	ldr.w	r1, [sl, #80]	; 0x50
    2228:	4459      	add	r1, fp
    222a:	f8ca 1050 	str.w	r1, [sl, #80]	; 0x50
                pSkt->rxHead = newRxHead;
    222e:	f8ca 301c 	str.w	r3, [sl, #28]
                if(pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1 || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2)
    2232:	f89a 206e 	ldrb.w	r2, [sl, #110]	; 0x6e
    2236:	3a03      	subs	r2, #3
    2238:	b2d2      	uxtb	r2, r2
    223a:	2a02      	cmp	r2, #2
    223c:	d804      	bhi.n	2248 <__ext_attr_.config_00804000+0x244>
                    *pSktEvent |= TCPIP_TCP_SIGNAL_RX_DATA;
    223e:	9a04      	ldr	r2, [sp, #16]
    2240:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    2244:	b292      	uxth	r2, r2
    2246:	9204      	str	r2, [sp, #16]
                if(pSkt->sHoleSize != -1)
    2248:	f8da 2054 	ldr.w	r2, [sl, #84]	; 0x54
    224c:	f1b2 3fff 	cmp.w	r2, #4294967295
    2250:	f43f aefa 	beq.w	2048 <__ext_attr_.config_00804000+0x44>
                    pSkt->sHoleSize -= len;
    2254:	eba2 0b0b 	sub.w	fp, r2, fp
    2258:	f8ca b054 	str.w	fp, [sl, #84]	; 0x54
                    wTemp = pSkt->wFutureDataSize + pSkt->sHoleSize;
    225c:	f8ba 2060 	ldrh.w	r2, [sl, #96]	; 0x60
                    if((int32_t)wTemp < 0)
    2260:	eb12 020b 	adds.w	r2, r2, fp
    2264:	d424      	bmi.n	22b0 <__ext_attr_.config_00804000+0x2ac>
                    else if(pSkt->sHoleSize <= 0)
    2266:	f1bb 0f00 	cmp.w	fp, #0
    226a:	f73f aeed 	bgt.w	2048 <__ext_attr_.config_00804000+0x44>
                        pSkt->RemoteSEQ += wTemp;
    226e:	4411      	add	r1, r2
    2270:	f8ca 1050 	str.w	r1, [sl, #80]	; 0x50
                        pSkt->rxHead += wTemp;
    2274:	4413      	add	r3, r2
    2276:	f8ca 301c 	str.w	r3, [sl, #28]
                        if(pSkt->rxHead > pSkt->rxEnd)
    227a:	f8da 2018 	ldr.w	r2, [sl, #24]
    227e:	4293      	cmp	r3, r2
    2280:	d906      	bls.n	2290 <__ext_attr_.config_00804000+0x28c>
                            pSkt->rxHead -= pSkt->rxEnd - pSkt->rxStart + 1;							
    2282:	f8da 1014 	ldr.w	r1, [sl, #20]
    2286:	1a52      	subs	r2, r2, r1
    2288:	43d2      	mvns	r2, r2
    228a:	4413      	add	r3, r2
    228c:	f8ca 301c 	str.w	r3, [sl, #28]
                        pSkt->sHoleSize = -1;
    2290:	f04f 33ff 	mov.w	r3, #4294967295
    2294:	f8ca 3054 	str.w	r3, [sl, #84]	; 0x54
    2298:	e6d6      	b.n	2048 <__ext_attr_.config_00804000+0x44>
                nCopiedBytes = TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxHead, &pSegSrc, len, true);
    229a:	2301      	movs	r3, #1
    229c:	9300      	str	r3, [sp, #0]
    229e:	465b      	mov	r3, fp
    22a0:	aa0c      	add	r2, sp, #48	; 0x30
    22a2:	4648      	mov	r0, r9
    22a4:	f017 fbbc 	bl	19a20 <TCPIP_Helper_PacketCopy>
                newRxHead = pSkt->rxHead + len;
    22a8:	f8da 301c 	ldr.w	r3, [sl, #28]
    22ac:	445b      	add	r3, fp
    22ae:	e7b6      	b.n	221e <__ext_attr_.config_00804000+0x21a>
                        pSkt->sHoleSize = -1;
    22b0:	f04f 33ff 	mov.w	r3, #4294967295
    22b4:	f8ca 3054 	str.w	r3, [sl, #84]	; 0x54
    22b8:	e6c6      	b.n	2048 <__ext_attr_.config_00804000+0x44>
                    nCopiedBytes = TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxHead + wMissingBytes - (pSkt->rxEnd - pSkt->rxStart + 1), &pSegSrc, len, true);
    22ba:	1e68      	subs	r0, r5, #1
    22bc:	f8da 2014 	ldr.w	r2, [sl, #20]
    22c0:	1a9b      	subs	r3, r3, r2
    22c2:	1ac0      	subs	r0, r0, r3
    22c4:	2301      	movs	r3, #1
    22c6:	9300      	str	r3, [sp, #0]
    22c8:	9b06      	ldr	r3, [sp, #24]
    22ca:	aa0c      	add	r2, sp, #48	; 0x30
    22cc:	4401      	add	r1, r0
    22ce:	4648      	mov	r0, r9
    22d0:	f017 fba6 	bl	19a20 <TCPIP_Helper_PacketCopy>
    22d4:	e6b4      	b.n	2040 <__ext_attr_.config_00804000+0x3c>
                nCopiedBytes = TCPIP_Helper_PacketCopy(pRxPkt, pSkt->rxHead + wMissingBytes, &pSegSrc, len, true);
    22d6:	2301      	movs	r3, #1
    22d8:	9300      	str	r3, [sp, #0]
    22da:	9b06      	ldr	r3, [sp, #24]
    22dc:	aa0c      	add	r2, sp, #48	; 0x30
    22de:	4429      	add	r1, r5
    22e0:	4648      	mov	r0, r9
    22e2:	f017 fb9d 	bl	19a20 <TCPIP_Helper_PacketCopy>
    22e6:	e6ab      	b.n	2040 <__ext_attr_.config_00804000+0x3c>
                if(pSkt->sHoleSize == -1)
    22e8:	f8da 3054 	ldr.w	r3, [sl, #84]	; 0x54
    22ec:	f1b3 3fff 	cmp.w	r3, #4294967295
    22f0:	d013      	beq.n	231a <__ext_attr_.config_00804000+0x316>
                    if(wMissingBytes < (uint32_t)pSkt->sHoleSize)
    22f2:	429d      	cmp	r5, r3
    22f4:	d217      	bcs.n	2326 <__ext_attr_.config_00804000+0x322>
                        if((wMissingBytes + len > (uint32_t)pSkt->sHoleSize + pSkt->wFutureDataSize) || (wMissingBytes + len < (uint32_t)pSkt->sHoleSize))
    22f6:	9a06      	ldr	r2, [sp, #24]
    22f8:	1951      	adds	r1, r2, r5
    22fa:	f8ba 2060 	ldrh.w	r2, [sl, #96]	; 0x60
    22fe:	18d0      	adds	r0, r2, r3
    2300:	4281      	cmp	r1, r0
    2302:	d804      	bhi.n	230e <__ext_attr_.config_00804000+0x30a>
    2304:	428b      	cmp	r3, r1
    2306:	d802      	bhi.n	230e <__ext_attr_.config_00804000+0x30a>
                            pSkt->wFutureDataSize = (uint32_t)pSkt->sHoleSize + pSkt->wFutureDataSize - wMissingBytes;
    2308:	1b43      	subs	r3, r0, r5
    230a:	b29b      	uxth	r3, r3
    230c:	9306      	str	r3, [sp, #24]
    230e:	9b06      	ldr	r3, [sp, #24]
    2310:	f8aa 3060 	strh.w	r3, [sl, #96]	; 0x60
                        pSkt->sHoleSize = wMissingBytes;
    2314:	f8ca 5054 	str.w	r5, [sl, #84]	; 0x54
    2318:	e696      	b.n	2048 <__ext_attr_.config_00804000+0x44>
                    pSkt->sHoleSize = wMissingBytes;
    231a:	f8ca 5054 	str.w	r5, [sl, #84]	; 0x54
                    pSkt->wFutureDataSize = len;
    231e:	9b06      	ldr	r3, [sp, #24]
    2320:	f8aa 3060 	strh.w	r3, [sl, #96]	; 0x60
    2324:	e690      	b.n	2048 <__ext_attr_.config_00804000+0x44>
                    else if(wMissingBytes + len > (uint32_t)pSkt->sHoleSize + pSkt->wFutureDataSize)
    2326:	f8ba 2060 	ldrh.w	r2, [sl, #96]	; 0x60
    232a:	441a      	add	r2, r3
    232c:	9806      	ldr	r0, [sp, #24]
    232e:	1941      	adds	r1, r0, r5
    2330:	4291      	cmp	r1, r2
    2332:	f67f ae89 	bls.w	2048 <__ext_attr_.config_00804000+0x44>
                        if(wMissingBytes <= (uint32_t)pSkt->sHoleSize + pSkt->wFutureDataSize)
    2336:	4295      	cmp	r5, r2
    2338:	f63f ae86 	bhi.w	2048 <__ext_attr_.config_00804000+0x44>
                            pSkt->wFutureDataSize += wMissingBytes + len - (uint32_t)pSkt->sHoleSize - pSkt->wFutureDataSize;
    233c:	1aeb      	subs	r3, r5, r3
    233e:	4418      	add	r0, r3
    2340:	f8aa 0060 	strh.w	r0, [sl, #96]	; 0x60
    2344:	e680      	b.n	2048 <__ext_attr_.config_00804000+0x44>
            _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
    2346:	2201      	movs	r2, #1
    2348:	2110      	movs	r1, #16
    234a:	4650      	mov	r0, sl
    234c:	f004 fe9c 	bl	7088 <_TcpSend>
    2350:	e696      	b.n	2080 <__ext_attr_.config_00804000+0x7c>
                pSkt->Flags.bDelayedACKTimerEnabled = 1;
    2352:	b2db      	uxtb	r3, r3
    2354:	f043 0308 	orr.w	r3, r3, #8
    2358:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36
                pSkt->delayedACKTime = SYS_TMR_TickCountGet() + (TCPIP_TCP_DELAYED_ACK_TIMEOUT * SYS_TMR_TickCounterFrequencyGet())/1000;
    235c:	f01d fe26 	bl	1ffac <SYS_TMR_TickCountGet>
    2360:	4604      	mov	r4, r0
    2362:	f01d fe4b 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
    2366:	2364      	movs	r3, #100	; 0x64
    2368:	fb03 f300 	mul.w	r3, r3, r0
    236c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    2370:	fbb3 f3f2 	udiv	r3, r3, r2
    2374:	441c      	add	r4, r3
    2376:	f8ca 402c 	str.w	r4, [sl, #44]	; 0x2c
    237a:	e681      	b.n	2080 <__ext_attr_.config_00804000+0x7c>
    pSkt->smState = newState;
    237c:	2309      	movs	r3, #9
    237e:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
                    // to explicitly close a socket that never really 
                    // got opened fully in the first place, so just 
                    // transmit a FIN automatically and jump to 
                    // TCPIP_TCP_STATE_LAST_ACK
                    _TcpSocketSetState(pSkt, TCPIP_TCP_STATE_LAST_ACK);
                    _TcpSend(pSkt, FIN | ACK, SENDTCP_RESET_TIMERS);
    2382:	2201      	movs	r2, #1
    2384:	2111      	movs	r1, #17
    2386:	4650      	mov	r0, sl
    2388:	f004 fe7e 	bl	7088 <_TcpSend>
                    return;
    238c:	e45d      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
    pSkt->smState = newState;
    238e:	2308      	movs	r3, #8
    2390:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
                    // remote node sends a FIN, a timer is started so 
                    // that the socket will eventually be closed automatically
                    pSkt->closeWaitTime = SYS_TMR_TickCountGet() + (TCPIP_TCP_CLOSE_WAIT_TIMEOUT * SYS_TMR_TickCounterFrequencyGet())/1000;
#endif  // (TCPIP_TCP_CLOSE_WAIT_TIMEOUT != 0)

                    if(pSkt->flags.ackSent)
    2394:	f89a 306d 	ldrb.w	r3, [sl, #109]	; 0x6d
    2398:	f013 0f01 	tst.w	r3, #1
    239c:	d007      	beq.n	23ae <__ext_attr_.config_00804000+0x3aa>
    239e:	e454      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                    }

                    break;

                case TCPIP_TCP_STATE_FIN_WAIT_1:
                    if(pSkt->MySEQ == localAckNumber)
    23a0:	f8da 304c 	ldr.w	r3, [sl, #76]	; 0x4c
    23a4:	429f      	cmp	r7, r3
    23a6:	d008      	beq.n	23ba <__ext_attr_.config_00804000+0x3b6>
    pSkt->smState = newState;
    23a8:	2306      	movs	r3, #6
    23aa:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
                default:    // case TCPIP_TCP_STATE_TIME_WAIT: reacknowledge
                    break;
            }

            // Acknowledge receipt of FIN
            _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
    23ae:	2201      	movs	r2, #1
    23b0:	2110      	movs	r1, #16
    23b2:	4650      	mov	r0, sl
    23b4:	f004 fe68 	bl	7088 <_TcpSend>
    23b8:	e447      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                        _TcpSend(pSkt, ACK, 0);
    23ba:	2200      	movs	r2, #0
    23bc:	2110      	movs	r1, #16
    23be:	4650      	mov	r0, sl
    23c0:	f004 fe62 	bl	7088 <_TcpSend>
                        _TcpCloseSocket(pSkt, 0);
    23c4:	2100      	movs	r1, #0
    23c6:	4650      	mov	r0, sl
    23c8:	f00e fafa 	bl	109c0 <_TcpCloseSocket>
                        return;
    23cc:	e43d      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                    _TcpSend(pSkt, ACK, 0);
    23ce:	2200      	movs	r2, #0
    23d0:	2110      	movs	r1, #16
    23d2:	4650      	mov	r0, sl
    23d4:	f004 fe58 	bl	7088 <_TcpSend>
                    _TcpCloseSocket(pSkt, 0);
    23d8:	2100      	movs	r1, #0
    23da:	4650      	mov	r0, sl
    23dc:	f00e faf0 	bl	109c0 <_TcpCloseSocket>
                    return;
    23e0:	e433      	b.n	1c4a <TCPIP_TCP_Task+0x2ca>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    23e2:	f06f 010d 	mvn.w	r1, #13
            TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
    23e6:	220a      	movs	r2, #10
    23e8:	4648      	mov	r0, r9
    23ea:	f01b fad3 	bl	1d994 <_TCPIP_PKT_PacketAcknowledge>
    while((pRxPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
    23ee:	200a      	movs	r0, #10
    23f0:	f01d f9e2 	bl	1f7b8 <_TCPIPStackModuleRxExtract>
    23f4:	4681      	mov	r9, r0
    23f6:	2800      	cmp	r0, #0
    23f8:	f43f aace 	beq.w	1998 <TCPIP_TCP_Task+0x18>
        uint16_t tcpTotLength = pRxPkt->totTransportLen;
    23fc:	f8b9 5020 	ldrh.w	r5, [r9, #32]
        if(tcpTotLength < sizeof(TCP_HEADER))
    2400:	2d13      	cmp	r5, #19
    2402:	d9ee      	bls.n	23e2 <__ext_attr_.config_00804000+0x3de>
        TCP_HEADER* pHdr = (TCP_HEADER*)pRxPkt->pTransportLayer;
    2404:	f8d9 801c 	ldr.w	r8, [r9, #28]
        uint8_t optionsField = pHdr->DataOffset.Val;
    2408:	f898 300c 	ldrb.w	r3, [r8, #12]
    240c:	091b      	lsrs	r3, r3, #4
        if(optionsField < TCP_DATA_OFFSET_VAL_MIN)
    240e:	2b04      	cmp	r3, #4
    2410:	d90b      	bls.n	242a <__ext_attr_.config_00804000+0x426>
        if(tcpTotLength < optionsField << 2)
    2412:	ebb5 0f83 	cmp.w	r5, r3, lsl #2
    2416:	db0b      	blt.n	2430 <__ext_attr_.config_00804000+0x42c>
            else if((pRxPkt->pktFlags & TCPIP_MAC_PKT_FLAG_NET_TYPE) == TCPIP_MAC_PKT_FLAG_IPV4) 
    2418:	f8b9 3022 	ldrh.w	r3, [r9, #34]	; 0x22
    241c:	f413 7f00 	tst.w	r3, #512	; 0x200
    2420:	f43f aac2 	beq.w	19a8 <TCPIP_TCP_Task+0x28>
        ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    2424:	f06f 010e 	mvn.w	r1, #14
    2428:	e7dd      	b.n	23e6 <__ext_attr_.config_00804000+0x3e2>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    242a:	f06f 010d 	mvn.w	r1, #13
    242e:	e7da      	b.n	23e6 <__ext_attr_.config_00804000+0x3e2>
    2430:	f06f 010d 	mvn.w	r1, #13
    2434:	e7d7      	b.n	23e6 <__ext_attr_.config_00804000+0x3e2>
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    2436:	4bbd      	ldr	r3, [pc, #756]	; (272c <__ext_attr_.config_00804000+0x728>)
    2438:	681b      	ldr	r3, [r3, #0]
    243a:	2b00      	cmp	r3, #0
    243c:	f43f aab1 	beq.w	19a2 <TCPIP_TCP_Task+0x22>
    2440:	2500      	movs	r5, #0
    2442:	462b      	mov	r3, r5
        pSkt = TCBStubs[hTCP];
    2444:	f8df 92e8 	ldr.w	r9, [pc, #744]	; 2730 <__ext_attr_.config_00804000+0x72c>
                        pSkt->retryInterval = ((TCPIP_TCP_START_TIMEOUT_VAL * SYS_TMR_TickCounterFrequencyGet())/1000) << (TCPIP_TCP_MAX_RETRIES-1);
    2448:	f8df a2e8 	ldr.w	sl, [pc, #744]	; 2734 <__ext_attr_.config_00804000+0x730>
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    244c:	f8df 82dc 	ldr.w	r8, [pc, #732]	; 272c <__ext_attr_.config_00804000+0x728>
    2450:	e0de      	b.n	2610 <__ext_attr_.config_00804000+0x60c>
                if((int32_t)(SYS_TMR_TickCountGet() - pSkt->eventTime2) >= 0)
    2452:	f01d fdab 	bl	1ffac <SYS_TMR_TickCountGet>
    2456:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2458:	1ac0      	subs	r0, r0, r3
                    vFlags = ACK;
    245a:	2800      	cmp	r0, #0
    245c:	bfa8      	it	ge
    245e:	2610      	movge	r6, #16
    2460:	e0ed      	b.n	263e <__ext_attr_.config_00804000+0x63a>
                if((int32_t)(SYS_TMR_TickCountGet() - pSkt->delayedACKTime) >= 0)
    2462:	f01d fda3 	bl	1ffac <SYS_TMR_TickCountGet>
    2466:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2468:	1ac0      	subs	r0, r0, r3
    246a:	2800      	cmp	r0, #0
    246c:	f2c0 80ed 	blt.w	264a <__ext_attr_.config_00804000+0x646>
            if(pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2)
    2470:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
    2474:	2b05      	cmp	r3, #5
    2476:	f000 8199 	beq.w	27ac <__ext_attr_.config_00804000+0x7a8>
                    vFlags = ACK;
    247a:	2610      	movs	r6, #16
                _TcpSend(pSkt, vFlags, bRetransmit ? 0 : SENDTCP_RESET_TIMERS);
    247c:	f087 0201 	eor.w	r2, r7, #1
    2480:	4631      	mov	r1, r6
    2482:	4620      	mov	r0, r4
    2484:	f004 fe00 	bl	7088 <_TcpSend>
    2488:	e0e7      	b.n	265a <__ext_attr_.config_00804000+0x656>
                if((int32_t)(SYS_TMR_TickCountGet() - pSkt->closeWaitTime) >= 0)
    248a:	f01d fd8f 	bl	1ffac <SYS_TMR_TickCountGet>
    248e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    2490:	1ac0      	subs	r0, r0, r3
    2492:	2800      	cmp	r0, #0
    2494:	f2c0 80de 	blt.w	2654 <__ext_attr_.config_00804000+0x650>
                    _TcpSend(pSkt, RST | ACK, SENDTCP_RESET_TIMERS);
    2498:	2201      	movs	r2, #1
    249a:	2114      	movs	r1, #20
    249c:	4620      	mov	r0, r4
    249e:	f004 fdf3 	bl	7088 <_TcpSend>
                    _TcpCloseSocket(pSkt, 0);
    24a2:	2100      	movs	r1, #0
    24a4:	4620      	mov	r0, r4
    24a6:	f00e fa8b 	bl	109c0 <_TcpCloseSocket>
                    continue;
    24aa:	e0a9      	b.n	2600 <__ext_attr_.config_00804000+0x5fc>
                            vFlags = pSkt->Flags.bServer;
    24ac:	f894 6036 	ldrb.w	r6, [r4, #54]	; 0x36
    24b0:	f006 0601 	and.w	r6, r6, #1
                            _TcpDisconnect(pSkt, true);
    24b4:	2101      	movs	r1, #1
    24b6:	4620      	mov	r0, r4
    24b8:	f014 fc00 	bl	16cbc <_TcpDisconnect>
                            pSkt->Flags.bServer = 1;    // force client socket non-closing
    24bc:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    24c0:	f043 0301 	orr.w	r3, r3, #1
    24c4:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
                            _TcpAbort(pSkt, _TCP_ABORT_FLAG_REGULAR, TCPIP_TCP_SIGNAL_KEEP_ALIVE_TMO);
    24c8:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    24cc:	2100      	movs	r1, #0
    24ce:	4620      	mov	r0, r4
    24d0:	f019 fe08 	bl	1c0e4 <_TcpAbort>
                            if(!vFlags)
    24d4:	2e00      	cmp	r6, #0
    24d6:	f040 8093 	bne.w	2600 <__ext_attr_.config_00804000+0x5fc>
                                pSkt->Flags.bServer = 0;    // restore the client socket
    24da:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    24de:	f36f 0300 	bfc	r3, #0, #1
    24e2:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
    pSkt->smState = newState;
    24e6:	230a      	movs	r3, #10
    24e8:	f884 306e 	strb.w	r3, [r4, #110]	; 0x6e
    24ec:	e088      	b.n	2600 <__ext_attr_.config_00804000+0x5fc>
            if((int32_t)(SYS_TMR_TickCountGet() - pSkt->eventTime) < 0 )
    24ee:	f01d fd5d 	bl	1ffac <SYS_TMR_TickCountGet>
    24f2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    24f4:	1ac0      	subs	r0, r0, r3
    24f6:	2800      	cmp	r0, #0
    24f8:	f2c0 8082 	blt.w	2600 <__ext_attr_.config_00804000+0x5fc>
            switch(pSkt->smState)
    24fc:	f894 106e 	ldrb.w	r1, [r4, #110]	; 0x6e
    2500:	1e4b      	subs	r3, r1, #1
    2502:	2b08      	cmp	r3, #8
    2504:	d87a      	bhi.n	25fc <__ext_attr_.config_00804000+0x5f8>
    2506:	e8df f003 	tbb	[pc, r3]
    250a:	4205      	.short	0x4205
    250c:	69796156 	.word	0x69796156
    2510:	7979      	.short	0x7979
    2512:	71          	.byte	0x71
    2513:	00          	.byte	0x00
                    if(pSkt->retryCount >= (TCPIP_TCP_MAX_RETRIES - 1))
    2514:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    2518:	2b03      	cmp	r3, #3
    251a:	d828      	bhi.n	256e <__ext_attr_.config_00804000+0x56a>
                    vFlags = SYN;
    251c:	2102      	movs	r1, #2
            bCloseSocket = false;
    251e:	2600      	movs	r6, #0
                    pSkt->retryCount++;
    2520:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    2524:	3301      	adds	r3, #1
    2526:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
                    pSkt->retryInterval <<= 1;
    252a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    252c:	005b      	lsls	r3, r3, #1
    252e:	64a3      	str	r3, [r4, #72]	; 0x48
                    w = pSkt->txUnackedTail - pSkt->txTail;
    2530:	6920      	ldr	r0, [r4, #16]
    2532:	68e2      	ldr	r2, [r4, #12]
    2534:	1a83      	subs	r3, r0, r2
    2536:	b29b      	uxth	r3, r3
                    if(pSkt->txUnackedTail < pSkt->txTail)
    2538:	4290      	cmp	r0, r2
    253a:	d204      	bcs.n	2546 <__ext_attr_.config_00804000+0x542>
                        w += pSkt->txEnd - pSkt->txStart;
    253c:	6860      	ldr	r0, [r4, #4]
    253e:	6827      	ldr	r7, [r4, #0]
    2540:	1bc0      	subs	r0, r0, r7
    2542:	4403      	add	r3, r0
    2544:	b29b      	uxth	r3, r3
                    pSkt->MySEQ -= w;
    2546:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    2548:	1ac0      	subs	r0, r0, r3
    254a:	64e0      	str	r0, [r4, #76]	; 0x4c
                    pSkt->remoteWindow += w;
    254c:	f8b4 005c 	ldrh.w	r0, [r4, #92]	; 0x5c
    2550:	4403      	add	r3, r0
    2552:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
                    pSkt->txUnackedTail = pSkt->txTail;		
    2556:	6122      	str	r2, [r4, #16]
                    _TcpSend(pSkt, vFlags, 0);
    2558:	2200      	movs	r2, #0
    255a:	4620      	mov	r0, r4
    255c:	f004 fd94 	bl	7088 <_TcpSend>
            if(bCloseSocket)
    2560:	2e00      	cmp	r6, #0
    2562:	d04d      	beq.n	2600 <__ext_attr_.config_00804000+0x5fc>
                _TcpCloseSocket(pSkt, 0);
    2564:	2100      	movs	r1, #0
    2566:	4620      	mov	r0, r4
    2568:	f00e fa2a 	bl	109c0 <_TcpCloseSocket>
    256c:	e048      	b.n	2600 <__ext_attr_.config_00804000+0x5fc>
                        pSkt->retryCount = TCPIP_TCP_MAX_RETRIES - 1;
    256e:	2304      	movs	r3, #4
    2570:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
                        pSkt->retryInterval = ((TCPIP_TCP_START_TIMEOUT_VAL * SYS_TMR_TickCounterFrequencyGet())/1000) << (TCPIP_TCP_MAX_RETRIES-1);
    2574:	f01d fd42 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
    2578:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    257c:	fb03 f300 	mul.w	r3, r3, r0
    2580:	fbaa 2303 	umull	r2, r3, sl, r3
    2584:	099b      	lsrs	r3, r3, #6
    2586:	011b      	lsls	r3, r3, #4
    2588:	64a3      	str	r3, [r4, #72]	; 0x48
                    vFlags = SYN;
    258a:	2102      	movs	r1, #2
    258c:	e7c7      	b.n	251e <__ext_attr_.config_00804000+0x51a>
                    if(pSkt->retryCount < TCPIP_TCP_MAX_SYN_RETRIES)
    258e:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    2592:	2b02      	cmp	r3, #2
    2594:	f240 80c0 	bls.w	2718 <__ext_attr_.config_00804000+0x714>
                        if(pSkt->Flags.bServer)
    2598:	f894 6036 	ldrb.w	r6, [r4, #54]	; 0x36
            bCloseSocket = false;
    259c:	f006 0301 	and.w	r3, r6, #1
    25a0:	461e      	mov	r6, r3
    25a2:	2b00      	cmp	r3, #0
    25a4:	bf18      	it	ne
    25a6:	2114      	movne	r1, #20
                if(bRetransmit)
    25a8:	2f00      	cmp	r7, #0
    25aa:	d1b9      	bne.n	2520 <__ext_attr_.config_00804000+0x51c>
                    _TcpSend(pSkt, vFlags, SENDTCP_RESET_TIMERS);
    25ac:	2201      	movs	r2, #1
    25ae:	4620      	mov	r0, r4
    25b0:	f004 fd6a 	bl	7088 <_TcpSend>
    25b4:	e7d4      	b.n	2560 <__ext_attr_.config_00804000+0x55c>
                    if(pSkt->retryCount < TCPIP_TCP_MAX_RETRIES)
    25b6:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    25ba:	2b04      	cmp	r3, #4
    25bc:	f240 80ae 	bls.w	271c <__ext_attr_.config_00804000+0x718>
    pSkt->smState = newState;
    25c0:	2304      	movs	r3, #4
    25c2:	f884 306e 	strb.w	r3, [r4, #110]	; 0x6e
                        vFlags = FIN | ACK;
    25c6:	2111      	movs	r1, #17
            bCloseSocket = false;
    25c8:	2600      	movs	r6, #0
    25ca:	e7ed      	b.n	25a8 <__ext_attr_.config_00804000+0x5a4>
                    if(pSkt->retryCount < TCPIP_TCP_MAX_RETRIES)
    25cc:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    25d0:	2b04      	cmp	r3, #4
    25d2:	f240 80a5 	bls.w	2720 <__ext_attr_.config_00804000+0x71c>
                        vFlags = RST | ACK;
    25d6:	2114      	movs	r1, #20
                        bCloseSocket = true;
    25d8:	2601      	movs	r6, #1
    25da:	e7e5      	b.n	25a8 <__ext_attr_.config_00804000+0x5a4>
                    if(pSkt->retryCount < TCPIP_TCP_MAX_RETRIES)
    25dc:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    25e0:	2b04      	cmp	r3, #4
    25e2:	f240 809f 	bls.w	2724 <__ext_attr_.config_00804000+0x720>
                        vFlags = RST | ACK;
    25e6:	2114      	movs	r1, #20
                        bCloseSocket = true;
    25e8:	2601      	movs	r6, #1
    25ea:	e7dd      	b.n	25a8 <__ext_attr_.config_00804000+0x5a4>
                    if(pSkt->retryCount < TCPIP_TCP_MAX_RETRIES)
    25ec:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    25f0:	2b04      	cmp	r3, #4
    25f2:	f240 8099 	bls.w	2728 <__ext_attr_.config_00804000+0x724>
                        vFlags = RST | ACK;
    25f6:	2114      	movs	r1, #20
                        bCloseSocket = true;
    25f8:	2601      	movs	r6, #1
    25fa:	e7d5      	b.n	25a8 <__ext_attr_.config_00804000+0x5a4>
            if(vFlags)
    25fc:	2e00      	cmp	r6, #0
    25fe:	d15c      	bne.n	26ba <__ext_attr_.config_00804000+0x6b6>
    2600:	3501      	adds	r5, #1
    2602:	b22d      	sxth	r5, r5
	for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    2604:	462b      	mov	r3, r5
    2606:	f8d8 2000 	ldr.w	r2, [r8]
    260a:	4295      	cmp	r5, r2
    260c:	f4bf a9c9 	bcs.w	19a2 <TCPIP_TCP_Task+0x22>
        pSkt = TCBStubs[hTCP];
    2610:	f8d9 2000 	ldr.w	r2, [r9]
    2614:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
        if(pSkt != 0 && pSkt->smState != TCPIP_TCP_STATE_CLIENT_WAIT_CONNECT)
    2618:	2c00      	cmp	r4, #0
    261a:	d0f1      	beq.n	2600 <__ext_attr_.config_00804000+0x5fc>
    261c:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
    2620:	2b0b      	cmp	r3, #11
    2622:	d0ed      	beq.n	2600 <__ext_attr_.config_00804000+0x5fc>
            if(pSkt->Flags.bTXASAP || pSkt->Flags.bTXASAPWithoutTimerReset)
    2624:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    2628:	f013 06c0 	ands.w	r6, r3, #192	; 0xc0
                bRetransmit = pSkt->Flags.bTXASAPWithoutTimerReset;
    262c:	bf1d      	ittte	ne
    262e:	461f      	movne	r7, r3
    2630:	09df      	lsrne	r7, r3, #7
                vFlags = ACK;
    2632:	2610      	movne	r6, #16
            bRetransmit = false;
    2634:	2700      	moveq	r7, #0
            if(pSkt->Flags.bTimer2Enabled)
    2636:	f013 0f04 	tst.w	r3, #4
    263a:	f47f af0a 	bne.w	2452 <__ext_attr_.config_00804000+0x44e>
            if(pSkt->Flags.bDelayedACKTimerEnabled)
    263e:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    2642:	f013 0f08 	tst.w	r3, #8
    2646:	f47f af0c 	bne.w	2462 <__ext_attr_.config_00804000+0x45e>
            if(pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2)
    264a:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
    264e:	2b05      	cmp	r3, #5
    2650:	f43f af1b 	beq.w	248a <__ext_attr_.config_00804000+0x486>
            if(vFlags)
    2654:	2e00      	cmp	r6, #0
    2656:	f47f af11 	bne.w	247c <__ext_attr_.config_00804000+0x478>
            if(!pSkt->Flags.bTimerEnabled)
    265a:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    265e:	f013 0f02 	tst.w	r3, #2
    2662:	f47f af44 	bne.w	24ee <__ext_attr_.config_00804000+0x4ea>
                if(pSkt->Flags.keepAlive)
    2666:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
    266a:	f013 0f40 	tst.w	r3, #64	; 0x40
    266e:	d0c7      	beq.n	2600 <__ext_attr_.config_00804000+0x5fc>
                    if(pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED)
    2670:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
    2674:	2b03      	cmp	r3, #3
    2676:	d1c3      	bne.n	2600 <__ext_attr_.config_00804000+0x5fc>
                        if((int32_t)(SYS_TMR_TickCountGet() - pSkt->eventTime) < 0)
    2678:	f01d fc98 	bl	1ffac <SYS_TMR_TickCountGet>
    267c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    267e:	1ac0      	subs	r0, r0, r3
    2680:	2800      	cmp	r0, #0
    2682:	dbbd      	blt.n	2600 <__ext_attr_.config_00804000+0x5fc>
                        if(pSkt->keepAliveCount == pSkt->keepAliveLim)
    2684:	f894 2071 	ldrb.w	r2, [r4, #113]	; 0x71
    2688:	f894 307c 	ldrb.w	r3, [r4, #124]	; 0x7c
    268c:	429a      	cmp	r2, r3
    268e:	f43f af0d 	beq.w	24ac <__ext_attr_.config_00804000+0x4a8>
                        _TcpSend(pSkt, ACK, SENDTCP_KEEP_ALIVE);
    2692:	2202      	movs	r2, #2
    2694:	2110      	movs	r1, #16
    2696:	4620      	mov	r0, r4
    2698:	f004 fcf6 	bl	7088 <_TcpSend>
                        pSkt->eventTime = SYS_TMR_TickCountGet() + (pSkt->keepAliveTmo * SYS_TMR_TickCounterFrequencyGet())/1000;
    269c:	f01d fc86 	bl	1ffac <SYS_TMR_TickCountGet>
    26a0:	4607      	mov	r7, r0
    26a2:	f8b4 6068 	ldrh.w	r6, [r4, #104]	; 0x68
    26a6:	f01d fca9 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
    26aa:	fb00 f006 	mul.w	r0, r0, r6
    26ae:	fbaa 3000 	umull	r3, r0, sl, r0
    26b2:	eb07 1090 	add.w	r0, r7, r0, lsr #6
    26b6:	6260      	str	r0, [r4, #36]	; 0x24
    26b8:	e7a2      	b.n	2600 <__ext_attr_.config_00804000+0x5fc>
            if(vFlags)
    26ba:	4631      	mov	r1, r6
            bCloseSocket = false;
    26bc:	2600      	movs	r6, #0
    26be:	e773      	b.n	25a8 <__ext_attr_.config_00804000+0x5a4>
        return TCPIP_MAC_PKT_ACK_CHKSUM_ERR;
    26c0:	f06f 0109 	mvn.w	r1, #9
    26c4:	e68f      	b.n	23e6 <__ext_attr_.config_00804000+0x3e2>
            ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    26c6:	f06f 010e 	mvn.w	r1, #14
    26ca:	e68c      	b.n	23e6 <__ext_attr_.config_00804000+0x3e2>
    26cc:	f06f 010e 	mvn.w	r1, #14
    26d0:	e689      	b.n	23e6 <__ext_attr_.config_00804000+0x3e2>
        ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    26d2:	2102      	movs	r1, #2
    26d4:	e687      	b.n	23e6 <__ext_attr_.config_00804000+0x3e2>
    26d6:	2102      	movs	r1, #2
        if(ackRes != TCPIP_MAC_PKT_ACK_NONE)
    26d8:	e685      	b.n	23e6 <__ext_attr_.config_00804000+0x3e2>
            if(localHeaderFlags & SYN)
    26da:	f014 0f02 	tst.w	r4, #2
    26de:	f43f aab4 	beq.w	1c4a <TCPIP_TCP_Task+0x2ca>
                pSkt->RemoteSEQ = localSeqNumber + 1;
    26e2:	3601      	adds	r6, #1
    26e4:	f8ca 6050 	str.w	r6, [sl, #80]	; 0x50
                pSkt->remoteWindow = pSkt->maxRemoteWindow = h->Window;
    26e8:	f8b8 300e 	ldrh.w	r3, [r8, #14]
    26ec:	f8aa 3066 	strh.w	r3, [sl, #102]	; 0x66
    26f0:	f8aa 305c 	strh.w	r3, [sl, #92]	; 0x5c
                pSkt->wRemoteMSS = _GetMaxSegSizeOption(h);
    26f4:	4640      	mov	r0, r8
    26f6:	f013 fdef 	bl	162d8 <_GetMaxSegSizeOption>
    26fa:	f8aa 0062 	strh.w	r0, [sl, #98]	; 0x62
                _TCPSetHalfFlushFlag(pSkt);
    26fe:	4650      	mov	r0, sl
    2700:	f01b faa8 	bl	1dc54 <_TCPSetHalfFlushFlag>
                    _TcpSend(pSkt, SYN | ACK, SENDTCP_RESET_TIMERS);
    2704:	2201      	movs	r2, #1
    2706:	2112      	movs	r1, #18
    2708:	4650      	mov	r0, sl
    270a:	f004 fcbd 	bl	7088 <_TcpSend>
    pSkt->smState = newState;
    270e:	2302      	movs	r3, #2
    2710:	f88a 306e 	strb.w	r3, [sl, #110]	; 0x6e
    2714:	f7ff ba99 	b.w	1c4a <TCPIP_TCP_Task+0x2ca>
                        vFlags = SYN | ACK;
    2718:	2112      	movs	r1, #18
    271a:	e700      	b.n	251e <__ext_attr_.config_00804000+0x51a>
                        vFlags = ACK;
    271c:	2110      	movs	r1, #16
    271e:	e6fe      	b.n	251e <__ext_attr_.config_00804000+0x51a>
                        vFlags = FIN | ACK;
    2720:	2111      	movs	r1, #17
    2722:	e6fc      	b.n	251e <__ext_attr_.config_00804000+0x51a>
                        vFlags = ACK;
    2724:	2110      	movs	r1, #16
    2726:	e6fa      	b.n	251e <__ext_attr_.config_00804000+0x51a>
                        vFlags = FIN | ACK;
    2728:	2111      	movs	r1, #17
    272a:	e6f8      	b.n	251e <__ext_attr_.config_00804000+0x51a>
    272c:	2000e598 	.word	0x2000e598
    2730:	2000e594 	.word	0x2000e594
    2734:	10624dd3 	.word	0x10624dd3
                pSkt->flags.bRXNoneACKed1 = 0;
    2738:	f89a 106c 	ldrb.w	r1, [sl, #108]	; 0x6c
                pSkt->flags.bRXNoneACKed2 = 0;
    273c:	f001 01ef 	and.w	r1, r1, #239	; 0xef
    2740:	f36f 1145 	bfc	r1, #5, #1
    2744:	f88a 106c 	strb.w	r1, [sl, #108]	; 0x6c
                pSkt->Flags.bHalfFullFlush = false;
    2748:	f89a 1036 	ldrb.w	r1, [sl, #54]	; 0x36
    274c:	f36f 1145 	bfc	r1, #5, #1
    2750:	f88a 1036 	strb.w	r1, [sl, #54]	; 0x36
                pSkt->txTail += dwTemp;
    2754:	9a08      	ldr	r2, [sp, #32]
    2756:	4402      	add	r2, r0
    2758:	f8ca 200c 	str.w	r2, [sl, #12]
                    if(pSkt->txUnackedTail < pSkt->txTail)
    275c:	4293      	cmp	r3, r2
    275e:	f4bf abb5 	bcs.w	1ecc <TCPIP_TCP_Task+0x54c>
                        pSkt->MySEQ += pSkt->txTail - pSkt->txUnackedTail;
    2762:	1ad3      	subs	r3, r2, r3
    2764:	9909      	ldr	r1, [sp, #36]	; 0x24
    2766:	440b      	add	r3, r1
    2768:	f8ca 304c 	str.w	r3, [sl, #76]	; 0x4c
                        pSkt->txUnackedTail = pSkt->txTail;
    276c:	f8ca 2010 	str.w	r2, [sl, #16]
                if(pSkt->txTail >= pSkt->txEnd)
    2770:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    2772:	4293      	cmp	r3, r2
    2774:	d80c      	bhi.n	2790 <__ext_attr_.config_00804000+0x78c>
                    pSkt->txTail -= pSkt->txEnd - pSkt->txStart;
    2776:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    2778:	1ad2      	subs	r2, r2, r3
    277a:	f8ca 200c 	str.w	r2, [sl, #12]
                if(pSkt->txUnackedTail >= pSkt->txEnd)
    277e:	f8da 3010 	ldr.w	r3, [sl, #16]
    2782:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    2784:	429a      	cmp	r2, r3
    2786:	d803      	bhi.n	2790 <__ext_attr_.config_00804000+0x78c>
                    pSkt->txUnackedTail -= pSkt->txEnd - pSkt->txStart;
    2788:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    278a:	1a9b      	subs	r3, r3, r2
    278c:	f8ca 3010 	str.w	r3, [sl, #16]
                if(pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT)
    2790:	f89a 306e 	ldrb.w	r3, [sl, #110]	; 0x6e
    2794:	2b03      	cmp	r3, #3
    2796:	d002      	beq.n	279e <__ext_attr_.config_00804000+0x79a>
    2798:	2b08      	cmp	r3, #8
    279a:	f47f abdd 	bne.w	1f58 <TCPIP_TCP_Task+0x5d8>
                    *pSktEvent |= TCPIP_TCP_SIGNAL_TX_SPACE; 
    279e:	9b04      	ldr	r3, [sp, #16]
    27a0:	f043 0204 	orr.w	r2, r3, #4
    27a4:	b293      	uxth	r3, r2
    27a6:	9304      	str	r3, [sp, #16]
    27a8:	f7ff bbd6 	b.w	1f58 <TCPIP_TCP_Task+0x5d8>
                if((int32_t)(SYS_TMR_TickCountGet() - pSkt->closeWaitTime) >= 0)
    27ac:	f01d fbfe 	bl	1ffac <SYS_TMR_TickCountGet>
    27b0:	6b23      	ldr	r3, [r4, #48]	; 0x30
    27b2:	1ac0      	subs	r0, r0, r3
    27b4:	2800      	cmp	r0, #0
    27b6:	f6bf ae6f 	bge.w	2498 <__ext_attr_.config_00804000+0x494>
                    vFlags = ACK;
    27ba:	2610      	movs	r6, #16
    27bc:	e65e      	b.n	247c <__ext_attr_.config_00804000+0x478>
    27be:	bf00      	nop

Disassembly of section .text.TCPIP_IPERF_Task%189:

000027c0 <TCPIP_IPERF_Task>:

}
#endif  // (TCPIP_STACK_DOWN_OPERATION != 0)

void TCPIP_IPERF_Task(void)
{
    27c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    27c4:	ed2d 8b02 	vpush	{d8}
    27c8:	b09b      	sub	sp, #108	; 0x6c
    TCPIP_MODULE_SIGNAL sigPend;

    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    27ca:	210f      	movs	r1, #15
    27cc:	2020      	movs	r0, #32
    27ce:	f01b fbcd 	bl	1df6c <_TCPIPStackModuleSignalGet>

    if(sigPend != 0)
    27d2:	2800      	cmp	r0, #0
    27d4:	f000 8688 	beq.w	34e8 <TCPIP_IPERF_Task+0xd28>
    {
		int i = 0;
		// ASYNC or RX signals occurred
	    tIperfState* pIState;	
        for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
    27d8:	4b82      	ldr	r3, [pc, #520]	; (29e4 <TCPIP_IPERF_Task+0x224>)
    27da:	681b      	ldr	r3, [r3, #0]
    27dc:	2b00      	cmp	r3, #0
    27de:	f340 8683 	ble.w	34e8 <TCPIP_IPERF_Task+0xd28>
    27e2:	4c81      	ldr	r4, [pc, #516]	; (29e8 <TCPIP_IPERF_Task+0x228>)
    27e4:	2600      	movs	r6, #0
    uint16_t chunk;
    uint16_t remainingTxData;
    uint16_t txData = 0;

    /* Fill the buffer with ASCII char U */
    memset( g_bfr, 0x55, MAX_BUFFER);
    27e6:	4f81      	ldr	r7, [pc, #516]	; (29ec <TCPIP_IPERF_Task+0x22c>)
            (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: TCP Client connection timeout\r\n");
    27e8:	f8df 8210 	ldr.w	r8, [pc, #528]	; 29fc <TCPIP_IPERF_Task+0x23c>

      /* get the remainder of the ticks using modulus */
      tmp2 = ((pIState->stopTime - pIState->startTime) % tickFreq);

      /* normalize  to uSecs */
      tmp2 =  tmp2 * 1000 / tickFreq; /* Convert to mSec */
    27ec:	ed9f 8a80 	vldr	s16, [pc, #512]	; 29f0 <TCPIP_IPERF_Task+0x230>
      }

      // never decrease pktId (e.g. if we get an out-of-order packet)
      if ( pIState->pktId == pIState->lastPktId )
      {
         (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Recv duplicated pkt\r\n");
    27f0:	f508 63ee 	add.w	r3, r8, #1904	; 0x770
    27f4:	9305      	str	r3, [sp, #20]
    27f6:	e3a3      	b.n	2f40 <TCPIP_IPERF_Task+0x780>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    27f8:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    27fc:	685d      	ldr	r5, [r3, #4]
    if ( !pIState->mServerMode )
    27fe:	f894 20d1 	ldrb.w	r2, [r4, #209]	; 0xd1
    2802:	b332      	cbz	r2, 2852 <TCPIP_IPERF_Task+0x92>
    switch ( pIState->mProtocol )
    2804:	7c22      	ldrb	r2, [r4, #16]
    2806:	2a01      	cmp	r2, #1
    2808:	d045      	beq.n	2896 <TCPIP_IPERF_Task+0xd6>
    280a:	2a02      	cmp	r2, #2
    280c:	d165      	bne.n	28da <TCPIP_IPERF_Task+0x11a>
        if ( (pIState->tcpServerSock == INVALID_SOCKET) &&
    280e:	f9b4 3038 	ldrsh.w	r3, [r4, #56]	; 0x38
    2812:	f1b3 3fff 	cmp.w	r3, #4294967295
    2816:	d027      	beq.n	2868 <TCPIP_IPERF_Task+0xa8>
        TCPIP_TCP_SignalHandlerRegister(pIState->tcpServerSock, TCPIP_TCP_SIGNAL_RX_DATA, _IperfTCPRxSignalHandler, 0);
    2818:	2300      	movs	r3, #0
    281a:	4a76      	ldr	r2, [pc, #472]	; (29f4 <TCPIP_IPERF_Task+0x234>)
    281c:	f44f 7100 	mov.w	r1, #512	; 0x200
    2820:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2824:	f01a fd1a 	bl	1d25c <TCPIP_TCP_SignalHandlerRegister>
        if(!TCPIP_TCP_OptionsSet(pIState->tcpServerSock, TCP_OPTION_RX_BUFF, (void*)pIState->rxBuffSize))
    2828:	f8d4 20bc 	ldr.w	r2, [r4, #188]	; 0xbc
    282c:	2102      	movs	r1, #2
    282e:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2832:	f011 f910 	bl	13a56 <TCPIP_TCP_OptionsSet>
    2836:	b938      	cbnz	r0, 2848 <TCPIP_IPERF_Task+0x88>
            (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Set of RX buffer size failed\r\n");
    2838:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    283c:	681b      	ldr	r3, [r3, #0]
    283e:	681b      	ldr	r3, [r3, #0]
    2840:	f508 61d8 	add.w	r1, r8, #1728	; 0x6c0
    2844:	4628      	mov	r0, r5
    2846:	4798      	blx	r3
        IperfSetState(pIState, IPERF_TCP_RX_LISTEN_STATE);
    2848:	2106      	movs	r1, #6
    284a:	4620      	mov	r0, r4
    284c:	f019 fa7c 	bl	1bd48 <IperfSetState>
        break;
    2850:	e36f      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Unsupported Configuration\r\n");
    2852:	681b      	ldr	r3, [r3, #0]
    2854:	681b      	ldr	r3, [r3, #0]
    2856:	f508 61cf 	add.w	r1, r8, #1656	; 0x678
    285a:	4628      	mov	r0, r5
    285c:	4798      	blx	r3
        IperfSetState(pIState, IPERF_STANDBY_STATE);
    285e:	2101      	movs	r1, #1
    2860:	4620      	mov	r0, r4
    2862:	f019 fa71 	bl	1bd48 <IperfSetState>
        return;
    2866:	e364      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
            (pIState->tcpServerSock = TCPIP_TCP_ServerOpen(IP_ADDRESS_TYPE_IPV4, pIState->mServerPort, (IP_MULTI_ADDRESS*)&pIState->localAddr)) == INVALID_SOCKET )
    2868:	f104 0280 	add.w	r2, r4, #128	; 0x80
    286c:	8a61      	ldrh	r1, [r4, #18]
    286e:	2001      	movs	r0, #1
    2870:	f014 fbcc 	bl	1700c <TCPIP_TCP_ServerOpen>
    2874:	8720      	strh	r0, [r4, #56]	; 0x38
        if ( (pIState->tcpServerSock == INVALID_SOCKET) &&
    2876:	f1b0 3fff 	cmp.w	r0, #4294967295
    287a:	d1cd      	bne.n	2818 <TCPIP_IPERF_Task+0x58>
            (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Create TCP socket failed\r\n");
    287c:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2880:	681b      	ldr	r3, [r3, #0]
    2882:	681b      	ldr	r3, [r3, #0]
    2884:	f208 619c 	addw	r1, r8, #1692	; 0x69c
    2888:	4628      	mov	r0, r5
    288a:	4798      	blx	r3
            IperfSetState(pIState, IPERF_STANDBY_STATE);
    288c:	2101      	movs	r1, #1
    288e:	4620      	mov	r0, r4
    2890:	f019 fa5a 	bl	1bd48 <IperfSetState>
            return;
    2894:	e34d      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        if ( (pIState->udpSock = TCPIP_UDP_ServerOpen(IP_ADDRESS_TYPE_IPV4, pIState->mServerPort, (IP_MULTI_ADDRESS*)&pIState->localAddr)) == INVALID_UDP_SOCKET )
    2896:	f104 0280 	add.w	r2, r4, #128	; 0x80
    289a:	8a61      	ldrh	r1, [r4, #18]
    289c:	2001      	movs	r0, #1
    289e:	f01f fbbe 	bl	2201e <TCPIP_UDP_ServerOpen>
    28a2:	87a0      	strh	r0, [r4, #60]	; 0x3c
    28a4:	f1b0 3fff 	cmp.w	r0, #4294967295
    28a8:	d00a      	beq.n	28c0 <TCPIP_IPERF_Task+0x100>
        TCPIP_UDP_SignalHandlerRegister(pIState->udpSock, TCPIP_UDP_SIGNAL_RX_DATA, _IperfUDPRxSignalHandler, 0);
    28aa:	2300      	movs	r3, #0
    28ac:	4a52      	ldr	r2, [pc, #328]	; (29f8 <TCPIP_IPERF_Task+0x238>)
    28ae:	f44f 7180 	mov.w	r1, #256	; 0x100
    28b2:	f01a fc4a 	bl	1d14a <TCPIP_UDP_SignalHandlerRegister>
        IperfSetState(pIState, IPERF_UDP_RX_STATE);
    28b6:	2103      	movs	r1, #3
    28b8:	4620      	mov	r0, r4
    28ba:	f019 fa45 	bl	1bd48 <IperfSetState>
        break;
    28be:	e338      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
            (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Create UDP socket failed\r\n");
    28c0:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    28c4:	681b      	ldr	r3, [r3, #0]
    28c6:	681b      	ldr	r3, [r3, #0]
    28c8:	f508 61dd 	add.w	r1, r8, #1768	; 0x6e8
    28cc:	4628      	mov	r0, r5
    28ce:	4798      	blx	r3
             IperfSetState(pIState, IPERF_STANDBY_STATE);
    28d0:	2101      	movs	r1, #1
    28d2:	4620      	mov	r0, r4
    28d4:	f019 fa38 	bl	1bd48 <IperfSetState>
            return;
    28d8:	e32b      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Protocol error\r\n");
    28da:	681b      	ldr	r3, [r3, #0]
    28dc:	681b      	ldr	r3, [r3, #0]
    28de:	f208 710c 	addw	r1, r8, #1804	; 0x70c
    28e2:	4628      	mov	r0, r5
    28e4:	4798      	blx	r3
        IperfSetState(pIState, IPERF_STANDBY_STATE);
    28e6:	2101      	movs	r1, #1
    28e8:	4620      	mov	r0, r4
    28ea:	f019 fa2d 	bl	1bd48 <IperfSetState>
        return;
    28ee:	e320      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    28f0:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    28f4:	f8d3 b004 	ldr.w	fp, [r3, #4]
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: instance %d session started ...\r\n", pIState - gIperfState);
    28f8:	4b3b      	ldr	r3, [pc, #236]	; (29e8 <TCPIP_IPERF_Task+0x228>)
    28fa:	1ae3      	subs	r3, r4, r3
    28fc:	10db      	asrs	r3, r3, #3
    28fe:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
    2902:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    2906:	ebc3 2343 	rsb	r3, r3, r3, lsl #9
    290a:	eb03 4383 	add.w	r3, r3, r3, lsl #18
    290e:	f1c3 0a00 	rsb	sl, r3, #0
    2912:	e086      	b.n	2a22 <TCPIP_IPERF_Task+0x262>
          (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: UDP Get Array Failed\r\n");
    2914:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2918:	681b      	ldr	r3, [r3, #0]
    291a:	681b      	ldr	r3, [r3, #0]
    291c:	f208 7124 	addw	r1, r8, #1828	; 0x724
    2920:	4658      	mov	r0, fp
    2922:	4798      	blx	r3
          IperfSetState(pIState, IPERF_UDP_RX_DRAIN_STATE);
    2924:	2104      	movs	r1, #4
    2926:	4620      	mov	r0, r4
    2928:	f019 fa0e 	bl	1bd48 <IperfSetState>
          return;
    292c:	e301      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
          TCPIP_UDP_Discard(pIState->udpSock);
    292e:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2932:	f01d feca 	bl	206ca <TCPIP_UDP_Discard>
          return;
    2936:	e2fc      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
       pIState->pktCount++;
    2938:	3301      	adds	r3, #1
    293a:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      pIState->totalLen += length;
    293e:	4628      	mov	r0, r5
    2940:	f008 f91c 	bl	ab7c <__aeabi_i2d>
    2944:	4602      	mov	r2, r0
    2946:	460b      	mov	r3, r1
    2948:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    294c:	f007 ffca 	bl	a8e4 <__adddf3>
    2950:	e9c4 0108 	strd	r0, r1, [r4, #32]
      if ( pIState->pktId < 0 )
    2954:	f1b9 0f00 	cmp.w	r9, #0
    2958:	db1a      	blt.n	2990 <TCPIP_IPERF_Task+0x1d0>
      if ( pIState->pktId != pIState->lastPktId+1 )
    295a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    295c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    295e:	1c51      	adds	r1, r2, #1
    2960:	428b      	cmp	r3, r1
    2962:	d030      	beq.n	29c6 <TCPIP_IPERF_Task+0x206>
         if ( pIState->pktId < pIState->lastPktId+1 )
    2964:	4293      	cmp	r3, r2
    2966:	dc22      	bgt.n	29ae <TCPIP_IPERF_Task+0x1ee>
            pIState->outofOrder++;
    2968:	6b61      	ldr	r1, [r4, #52]	; 0x34
    296a:	f101 0101 	add.w	r1, r1, #1
    296e:	6361      	str	r1, [r4, #52]	; 0x34
      if ( pIState->pktId == pIState->lastPktId )
    2970:	d02b      	beq.n	29ca <TCPIP_IPERF_Task+0x20a>
    2972:	e022      	b.n	29ba <TCPIP_IPERF_Task+0x1fa>
             (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf: - First pkt id = %ld (should be 0)\r\n",
    2974:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2978:	681b      	ldr	r3, [r3, #0]
    297a:	685b      	ldr	r3, [r3, #4]
    297c:	f208 7144 	addw	r1, r8, #1860	; 0x744
    2980:	4658      	mov	r0, fp
    2982:	4798      	blx	r3
             pIState->errorCount	+= 	pIState->pktId - 1;
    2984:	6b23      	ldr	r3, [r4, #48]	; 0x30
    2986:	3b01      	subs	r3, #1
    2988:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    298a:	4413      	add	r3, r2
    298c:	6323      	str	r3, [r4, #48]	; 0x30
    298e:	e083      	b.n	2a98 <TCPIP_IPERF_Task+0x2d8>
         pIState->pktId = - pIState->pktId;
    2990:	f1c9 0300 	rsb	r3, r9, #0
    2994:	62a3      	str	r3, [r4, #40]	; 0x28
         pIState->stopTime = SYS_TMR_TickCountGet();
    2996:	f01d fb09 	bl	1ffac <SYS_TMR_TickCountGet>
    299a:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
        pIState->nAttempts = 0;
    299e:	2300      	movs	r3, #0
    29a0:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
        IperfSetState(pIState, IPERF_UDP_RX_DRAIN_STATE);
    29a4:	2104      	movs	r1, #4
    29a6:	4620      	mov	r0, r4
    29a8:	f019 f9ce 	bl	1bd48 <IperfSetState>
    29ac:	e7d5      	b.n	295a <TCPIP_IPERF_Task+0x19a>
            pIState->errorCount += pIState->pktId - (pIState->lastPktId+1);
    29ae:	1a5b      	subs	r3, r3, r1
    29b0:	6b22      	ldr	r2, [r4, #48]	; 0x30
    29b2:	4413      	add	r3, r2
    29b4:	6323      	str	r3, [r4, #48]	; 0x30
      }

      if ( pIState->pktId > pIState->lastPktId )
    29b6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      {
         pIState->lastPktId = pIState->pktId;
    29b8:	62e3      	str	r3, [r4, #44]	; 0x2c
      }

      /* read the remaining datagram payload - the full payload */
      /* a UdpDiscard would be disingenuous, because it would not reflect the bandwidth at L7 */
      length -=  sizeof(tIperfPktInfo);
    29ba:	3d0c      	subs	r5, #12
    29bc:	b2ad      	uxth	r5, r5
      while ( length > 0 )
    29be:	b385      	cbz	r5, 2a22 <TCPIP_IPERF_Task+0x262>
         if ( length <  (uint16_t)MAX_BUFFER )
            chunk = length;
         else
            chunk = MAX_BUFFER;

         TCPIP_UDP_ArrayGet(pIState->udpSock, (uint8_t*)g_bfr, chunk);
    29c0:	f04f 0934 	mov.w	r9, #52	; 0x34
    29c4:	e025      	b.n	2a12 <TCPIP_IPERF_Task+0x252>
      if ( pIState->pktId == pIState->lastPktId )
    29c6:	4293      	cmp	r3, r2
    29c8:	d106      	bne.n	29d8 <TCPIP_IPERF_Task+0x218>
         (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Recv duplicated pkt\r\n");
    29ca:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    29ce:	681b      	ldr	r3, [r3, #0]
    29d0:	681b      	ldr	r3, [r3, #0]
    29d2:	9905      	ldr	r1, [sp, #20]
    29d4:	4658      	mov	r0, fp
    29d6:	4798      	blx	r3
      if ( pIState->pktId > pIState->lastPktId )
    29d8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    29da:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    29dc:	4293      	cmp	r3, r2
    29de:	ddec      	ble.n	29ba <TCPIP_IPERF_Task+0x1fa>
    29e0:	e7ea      	b.n	29b8 <TCPIP_IPERF_Task+0x1f8>
    29e2:	bf00      	nop
    29e4:	2000e5f8 	.word	0x2000e5f8
    29e8:	2000dbb0 	.word	0x2000dbb0
    29ec:	2000e268 	.word	0x2000e268
    29f0:	447a0000 	.word	0x447a0000
    29f4:	00021677 	.word	0x00021677
    29f8:	00021661 	.word	0x00021661
    29fc:	00004c44 	.word	0x00004c44
         TCPIP_UDP_ArrayGet(pIState->udpSock, (uint8_t*)g_bfr, chunk);
    2a00:	464a      	mov	r2, r9
    2a02:	4639      	mov	r1, r7
    2a04:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2a08:	f012 fa2c 	bl	14e64 <TCPIP_UDP_ArrayGet>
         length -= chunk;
    2a0c:	3d34      	subs	r5, #52	; 0x34
    2a0e:	b2ad      	uxth	r5, r5
      while ( length > 0 )
    2a10:	b13d      	cbz	r5, 2a22 <TCPIP_IPERF_Task+0x262>
         if ( length <  (uint16_t)MAX_BUFFER )
    2a12:	2d33      	cmp	r5, #51	; 0x33
    2a14:	d8f4      	bhi.n	2a00 <TCPIP_IPERF_Task+0x240>
         TCPIP_UDP_ArrayGet(pIState->udpSock, (uint8_t*)g_bfr, chunk);
    2a16:	462a      	mov	r2, r5
    2a18:	4639      	mov	r1, r7
    2a1a:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2a1e:	f012 fa21 	bl	14e64 <TCPIP_UDP_ArrayGet>
    while( (length = TCPIP_UDP_GetIsReady(pIState->udpSock)) >= (uint16_t)(sizeof(tIperfPktInfo)) )
    2a22:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2a26:	f01d fa85 	bl	1ff34 <TCPIP_UDP_GetIsReady>
    2a2a:	4605      	mov	r5, r0
    2a2c:	280b      	cmp	r0, #11
    2a2e:	f240 8082 	bls.w	2b36 <TCPIP_IPERF_Task+0x376>
       if ( TCPIP_UDP_ArrayGet(pIState->udpSock, (uint8_t*)g_bfr, sizeof(tIperfPktInfo)) != sizeof(tIperfPktInfo) )
    2a32:	220c      	movs	r2, #12
    2a34:	4639      	mov	r1, r7
    2a36:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2a3a:	f012 fa13 	bl	14e64 <TCPIP_UDP_ArrayGet>
    2a3e:	280c      	cmp	r0, #12
    2a40:	f47f af68 	bne.w	2914 <TCPIP_IPERF_Task+0x154>
       pIState->pktId = TCPIP_Helper_htonl(pPktInfo->id);
    2a44:	683b      	ldr	r3, [r7, #0]
    return (((hLong & 0x000000ff) << 24) | ((hLong & 0x0000ff00) << 8) | ((hLong & 0x00ff0000) >> 8) | ((hLong & 0xff000000) >> 24));
    2a46:	ea4f 6913 	mov.w	r9, r3, lsr #24
    2a4a:	ea49 6903 	orr.w	r9, r9, r3, lsl #24
    2a4e:	021a      	lsls	r2, r3, #8
    2a50:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
    2a54:	ea49 0902 	orr.w	r9, r9, r2
    2a58:	0a1b      	lsrs	r3, r3, #8
    2a5a:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2a5e:	ea49 0903 	orr.w	r9, r9, r3
    2a62:	f8c4 9028 	str.w	r9, [r4, #40]	; 0x28
       if ( (pIState->pktCount == (uint32_t)0) && (pIState->pktId < (long)0) )
    2a66:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    2a6a:	2b00      	cmp	r3, #0
    2a6c:	f47f af64 	bne.w	2938 <TCPIP_IPERF_Task+0x178>
    2a70:	f1b9 0f00 	cmp.w	r9, #0
    2a74:	f6ff af5b 	blt.w	292e <TCPIP_IPERF_Task+0x16e>
       pIState->pktCount++;
    2a78:	2301      	movs	r3, #1
    2a7a:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: instance %d session started ...\r\n", pIState - gIperfState);
    2a7e:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2a82:	681b      	ldr	r3, [r3, #0]
    2a84:	685b      	ldr	r3, [r3, #4]
    2a86:	4652      	mov	r2, sl
    2a88:	f508 61f5 	add.w	r1, r8, #1960	; 0x7a8
    2a8c:	4658      	mov	r0, fp
    2a8e:	4798      	blx	r3
          if ( pIState->pktId != 0 )
    2a90:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    2a92:	2a00      	cmp	r2, #0
    2a94:	f47f af6e 	bne.w	2974 <TCPIP_IPERF_Task+0x1b4>
          pIState->lastPktId = pIState->pktId;
    2a98:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2a9a:	62e3      	str	r3, [r4, #44]	; 0x2c
		  TCPIP_UDP_SocketInfoGet(pIState->udpSock, &UdpSkt);
    2a9c:	a906      	add	r1, sp, #24
    2a9e:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2aa2:	f018 fa3b 	bl	1af1c <TCPIP_UDP_SocketInfoGet>
          lclIpAddr.Val = TCPIP_STACK_NetAddress(TCPIP_UDP_SocketNetGet(pIState->udpSock));
    2aa6:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2aaa:	f01e ffef 	bl	21a8c <TCPIP_UDP_SocketNetGet>
    2aae:	f01e f8bc 	bl	20c2a <TCPIP_STACK_NetAddress>
          remIpAddr.Val = UdpSkt.remoteIPaddress.v4Add.Val;
    2ab2:	9d07      	ldr	r5, [sp, #28]
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Local  %u.%u.%u.%u port %u connected with\r\n",
    2ab4:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2ab8:	681b      	ldr	r3, [r3, #0]
    2aba:	8a62      	ldrh	r2, [r4, #18]
    2abc:	9202      	str	r2, [sp, #8]
    2abe:	0e02      	lsrs	r2, r0, #24
    2ac0:	9201      	str	r2, [sp, #4]
    2ac2:	f3c0 4207 	ubfx	r2, r0, #16, #8
    2ac6:	9200      	str	r2, [sp, #0]
    2ac8:	f8d3 9004 	ldr.w	r9, [r3, #4]
    2acc:	f3c0 2307 	ubfx	r3, r0, #8, #8
    2ad0:	b2c2      	uxtb	r2, r0
    2ad2:	f208 515c 	addw	r1, r8, #1372	; 0x55c
    2ad6:	4658      	mov	r0, fp
    2ad8:	47c8      	blx	r9
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Remote %u.%u.%u.%u port %u\r\n",      
    2ada:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2ade:	681b      	ldr	r3, [r3, #0]
    2ae0:	f8bd 205c 	ldrh.w	r2, [sp, #92]	; 0x5c
    2ae4:	9202      	str	r2, [sp, #8]
    2ae6:	0e2a      	lsrs	r2, r5, #24
    2ae8:	9201      	str	r2, [sp, #4]
    2aea:	f3c5 4207 	ubfx	r2, r5, #16, #8
    2aee:	9200      	str	r2, [sp, #0]
    2af0:	f8d3 9004 	ldr.w	r9, [r3, #4]
    2af4:	f3c5 2307 	ubfx	r3, r5, #8, #8
    2af8:	b2ea      	uxtb	r2, r5
    2afa:	f508 61b2 	add.w	r1, r8, #1424	; 0x590
    2afe:	4658      	mov	r0, fp
    2b00:	47c8      	blx	r9
          pIState->remoteSide.remoteIPaddress.v4Add.Val = remIpAddr.Val;
    2b02:	6465      	str	r5, [r4, #68]	; 0x44
          pIState->remoteSide.remotePort =  UdpSkt.remotePort;
    2b04:	f8bd 305c 	ldrh.w	r3, [sp, #92]	; 0x5c
    2b08:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
          pIState->startTime = SYS_TMR_TickCountGet();
    2b0c:	f01d fa4e 	bl	1ffac <SYS_TMR_TickCountGet>
    2b10:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
          pIState->lastCheckTime = 	pIState->startTime;
    2b14:	f8c4 00a8 	str.w	r0, [r4, #168]	; 0xa8
          pIState->lastCheckPktId = pIState->pktId;
    2b18:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2b1a:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
          pIState->lastCheckPktCount = pIState->pktCount;
    2b1e:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    2b22:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
          pIState->lastCheckErrorCount = pIState->errorCount;
    2b26:	6b23      	ldr	r3, [r4, #48]	; 0x30
    2b28:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
          TCPIP_UDP_Discard(pIState->udpSock);
    2b2c:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2b30:	f01d fdcb 	bl	206ca <TCPIP_UDP_Discard>
          continue;
    2b34:	e775      	b.n	2a22 <TCPIP_IPERF_Task+0x262>
      }


    }  /* end got a datagram */

    if ( (pIState->pktCount != (uint32_t)0) &&
    2b36:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    2b3a:	b94b      	cbnz	r3, 2b50 <TCPIP_IPERF_Task+0x390>
        {
          ReportBW_Jitter_Loss(pIState, INTERVAL_REPORT);
        }
    }

    if ( pIState->stopRequested == true )
    2b3c:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
    2b40:	2b01      	cmp	r3, #1
    2b42:	f040 81f6 	bne.w	2f32 <TCPIP_IPERF_Task+0x772>
    {
        IperfSetState(pIState, IPERF_UDP_RX_DRAIN_STATE);
    2b46:	2104      	movs	r1, #4
    2b48:	4620      	mov	r0, r4
    2b4a:	f019 f8fd 	bl	1bd48 <IperfSetState>
        return;
    2b4e:	e1f0      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
         ((int32_t)(SYS_TMR_TickCountGet() - pIState->lastCheckTime) > pIState->mInterval) )
    2b50:	f01d fa2c 	bl	1ffac <SYS_TMR_TickCountGet>
    2b54:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
    2b58:	1ac3      	subs	r3, r0, r3
    if ( (pIState->pktCount != (uint32_t)0) &&
    2b5a:	6822      	ldr	r2, [r4, #0]
    2b5c:	4293      	cmp	r3, r2
    2b5e:	d9ed      	bls.n	2b3c <TCPIP_IPERF_Task+0x37c>
        if ( pIState->pktCount == pIState->lastCheckPktCount )
    2b60:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
    2b64:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
    2b68:	429a      	cmp	r2, r3
    2b6a:	d113      	bne.n	2b94 <TCPIP_IPERF_Task+0x3d4>
          (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Rx timed out\r\n");
    2b6c:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2b70:	681b      	ldr	r3, [r3, #0]
    2b72:	681b      	ldr	r3, [r3, #0]
    2b74:	f508 61f2 	add.w	r1, r8, #1936	; 0x790
    2b78:	4658      	mov	r0, fp
    2b7a:	4798      	blx	r3
          pIState->stopTime = SYS_TMR_TickCountGet();
    2b7c:	f01d fa16 	bl	1ffac <SYS_TMR_TickCountGet>
    2b80:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
          pIState->nAttempts = 0;
    2b84:	2300      	movs	r3, #0
    2b86:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
          IperfSetState(pIState, IPERF_UDP_RX_DRAIN_STATE);
    2b8a:	2104      	movs	r1, #4
    2b8c:	4620      	mov	r0, r4
    2b8e:	f019 f8db 	bl	1bd48 <IperfSetState>
    2b92:	e7d3      	b.n	2b3c <TCPIP_IPERF_Task+0x37c>
          ReportBW_Jitter_Loss(pIState, INTERVAL_REPORT);
    2b94:	2100      	movs	r1, #0
    2b96:	4620      	mov	r0, r4
    2b98:	f00a f844 	bl	cc24 <ReportBW_Jitter_Loss>
    2b9c:	e7ce      	b.n	2b3c <TCPIP_IPERF_Task+0x37c>
    if( TCPIP_UDP_GetIsReady(pIState->udpSock) > (uint8_t)0 )
    2b9e:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2ba2:	f01d f9c7 	bl	1ff34 <TCPIP_UDP_GetIsReady>
    2ba6:	b938      	cbnz	r0, 2bb8 <TCPIP_IPERF_Task+0x3f8>
   if ( pIState->stopRequested )
    2ba8:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
    2bac:	b14b      	cbz	r3, 2bc2 <TCPIP_IPERF_Task+0x402>
       IperfSetState(pIState, IPERF_RX_DONE_STATE);
    2bae:	2109      	movs	r1, #9
    2bb0:	4620      	mov	r0, r4
    2bb2:	f019 f8c9 	bl	1bd48 <IperfSetState>
    2bb6:	e1bc      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
         TCPIP_UDP_Discard(pIState->udpSock);
    2bb8:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2bbc:	f01d fd85 	bl	206ca <TCPIP_UDP_Discard>
         return;
    2bc0:	e1b7      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
       IperfSetState(pIState, IPERF_UDP_RX_DONE_STATE);
    2bc2:	2105      	movs	r1, #5
    2bc4:	4620      	mov	r0, r4
    2bc6:	f019 f8bf 	bl	1bd48 <IperfSetState>
    2bca:	e1b2      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    if ( pIState->statusReported == 0u )
    2bcc:	f894 30cd 	ldrb.w	r3, [r4, #205]	; 0xcd
    2bd0:	2b00      	cmp	r3, #0
    2bd2:	f000 80b5 	beq.w	2d40 <TCPIP_IPERF_Task+0x580>
    if (  TCPIP_UDP_GetIsReady(pIState->udpSock)  )
    2bd6:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2bda:	f01d f9ab 	bl	1ff34 <TCPIP_UDP_GetIsReady>
    2bde:	2800      	cmp	r0, #0
    2be0:	f040 80b6 	bne.w	2d50 <TCPIP_IPERF_Task+0x590>
    if ( pIState->nAttempts++ > 10u )
    2be4:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
    2be8:	1c5a      	adds	r2, r3, #1
    2bea:	f884 20cc 	strb.w	r2, [r4, #204]	; 0xcc
    2bee:	2b0a      	cmp	r3, #10
    2bf0:	f200 80b3 	bhi.w	2d5a <TCPIP_IPERF_Task+0x59a>
    if ( TCPIP_UDP_TxPutIsReady(pIState->udpSock, 128 ) > 0u )
    2bf4:	2180      	movs	r1, #128	; 0x80
    2bf6:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2bfa:	f01f fa3e 	bl	2207a <TCPIP_UDP_TxPutIsReady>
    2bfe:	2800      	cmp	r0, #0
    2c00:	f000 8197 	beq.w	2f32 <TCPIP_IPERF_Task+0x772>
      pPktInfo->id = TCPIP_Helper_htonl( -pIState->lastPktId );
    2c04:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2c06:	425b      	negs	r3, r3
    2c08:	0e1a      	lsrs	r2, r3, #24
    2c0a:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    2c0e:	0219      	lsls	r1, r3, #8
    2c10:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    2c14:	430a      	orrs	r2, r1
    2c16:	0a1b      	lsrs	r3, r3, #8
    2c18:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2c1c:	4313      	orrs	r3, r2
    2c1e:	603b      	str	r3, [r7, #0]
      pPktInfo->tv_sec = 0;
    2c20:	2500      	movs	r5, #0
    2c22:	607d      	str	r5, [r7, #4]
      pPktInfo->tv_usec = 0;
    2c24:	60bd      	str	r5, [r7, #8]
      pServer_hdr->flags = TCPIP_Helper_htonl(HEADER_VERSION1);
    2c26:	2380      	movs	r3, #128	; 0x80
    2c28:	60fb      	str	r3, [r7, #12]
      pServer_hdr->total_len1 = 0;
    2c2a:	613d      	str	r5, [r7, #16]
      pServer_hdr->total_len2 = TCPIP_Helper_htonl( (uint32_t) pIState->totalLen);
    2c2c:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    2c30:	f01a ffb0 	bl	1db94 <__aeabi_d2uiz>
    2c34:	0e02      	lsrs	r2, r0, #24
    2c36:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    2c3a:	0203      	lsls	r3, r0, #8
    2c3c:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    2c40:	431a      	orrs	r2, r3
    2c42:	0a03      	lsrs	r3, r0, #8
    2c44:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2c48:	4313      	orrs	r3, r2
    2c4a:	617b      	str	r3, [r7, #20]
      uint32_t tickFreq = SYS_TMR_TickCounterFrequencyGet(); 
    2c4c:	f01d f9d6 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
      pServer_hdr->stop_sec =  TCPIP_Helper_htonl( (uint32_t) (pIState->stopTime - pIState->startTime) / tickFreq);
    2c50:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
    2c54:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    2c58:	1ac9      	subs	r1, r1, r3
    2c5a:	fbb1 f3f0 	udiv	r3, r1, r0
    2c5e:	0e1a      	lsrs	r2, r3, #24
    2c60:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    2c64:	ea4f 2c03 	mov.w	ip, r3, lsl #8
    2c68:	f40c 0c7f 	and.w	ip, ip, #16711680	; 0xff0000
    2c6c:	ea42 020c 	orr.w	r2, r2, ip
    2c70:	ea4f 2c13 	mov.w	ip, r3, lsr #8
    2c74:	f40c 4c7f 	and.w	ip, ip, #65280	; 0xff00
    2c78:	ea42 020c 	orr.w	r2, r2, ip
    2c7c:	61ba      	str	r2, [r7, #24]
      tmp2 = ((pIState->stopTime - pIState->startTime) % tickFreq);
    2c7e:	fb00 1313 	mls	r3, r0, r3, r1
    2c82:	ee07 3a10 	vmov	s14, r3
    2c86:	eeb8 7a47 	vcvt.f32.u32	s14, s14
      tmp2 =  tmp2 * 1000 / tickFreq; /* Convert to mSec */
    2c8a:	ee27 7a08 	vmul.f32	s14, s14, s16
    2c8e:	ee07 0a90 	vmov	s15, r0
    2c92:	eef8 6a67 	vcvt.f32.u32	s13, s15
    2c96:	eec7 7a26 	vdiv.f32	s15, s14, s13
      tmp2 *= 1000;   /* 1000 uSecs per mSec */
    2c9a:	ee67 7a88 	vmul.f32	s15, s15, s16
      pServer_hdr->stop_usec = TCPIP_Helper_htonl( (uint32_t) tmp2 );
    2c9e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    2ca2:	ee17 3a90 	vmov	r3, s15
    2ca6:	0e1a      	lsrs	r2, r3, #24
    2ca8:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    2cac:	0219      	lsls	r1, r3, #8
    2cae:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    2cb2:	430a      	orrs	r2, r1
    2cb4:	0a1b      	lsrs	r3, r3, #8
    2cb6:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2cba:	4313      	orrs	r3, r2
    2cbc:	61fb      	str	r3, [r7, #28]
      pServer_hdr->error_cnt = TCPIP_Helper_htonl( (uint32_t)  pIState->errorCount);;
    2cbe:	6b23      	ldr	r3, [r4, #48]	; 0x30
    2cc0:	0e1a      	lsrs	r2, r3, #24
    2cc2:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    2cc6:	0219      	lsls	r1, r3, #8
    2cc8:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    2ccc:	430a      	orrs	r2, r1
    2cce:	0a1b      	lsrs	r3, r3, #8
    2cd0:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2cd4:	4313      	orrs	r3, r2
    2cd6:	623b      	str	r3, [r7, #32]
      pServer_hdr->outorder_cnt = TCPIP_Helper_htonl( (uint32_t) pIState->outofOrder);
    2cd8:	6b63      	ldr	r3, [r4, #52]	; 0x34
    2cda:	0e1a      	lsrs	r2, r3, #24
    2cdc:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    2ce0:	0219      	lsls	r1, r3, #8
    2ce2:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    2ce6:	430a      	orrs	r2, r1
    2ce8:	0a1b      	lsrs	r3, r3, #8
    2cea:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2cee:	4313      	orrs	r3, r2
    2cf0:	627b      	str	r3, [r7, #36]	; 0x24
      pServer_hdr->datagrams = TCPIP_Helper_htonl( (uint32_t) pIState->lastPktId);
    2cf2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2cf4:	0e1a      	lsrs	r2, r3, #24
    2cf6:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    2cfa:	0219      	lsls	r1, r3, #8
    2cfc:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    2d00:	430a      	orrs	r2, r1
    2d02:	0a1b      	lsrs	r3, r3, #8
    2d04:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    2d08:	4313      	orrs	r3, r2
    2d0a:	62bb      	str	r3, [r7, #40]	; 0x28
      pServer_hdr->jitter1 = 0;
    2d0c:	62fd      	str	r5, [r7, #44]	; 0x2c
      pServer_hdr->jitter2 = 0;
    2d0e:	633d      	str	r5, [r7, #48]	; 0x30
      TCPIP_UDP_ArrayPut(pIState->udpSock, (uint8_t*)g_bfr, MAX_BUFFER);
    2d10:	2234      	movs	r2, #52	; 0x34
    2d12:	4639      	mov	r1, r7
    2d14:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2d18:	f019 fe07 	bl	1c92a <TCPIP_UDP_ArrayPut>
      memset(tmpBuffer, 0, sizeof(tmpBuffer));
    2d1c:	f04f 094c 	mov.w	r9, #76	; 0x4c
    2d20:	464a      	mov	r2, r9
    2d22:	4629      	mov	r1, r5
    2d24:	a806      	add	r0, sp, #24
    2d26:	f01e ff29 	bl	21b7c <memset>
      TCPIP_UDP_ArrayPut(pIState->udpSock, tmpBuffer, sizeof(tmpBuffer));
    2d2a:	464a      	mov	r2, r9
    2d2c:	a906      	add	r1, sp, #24
    2d2e:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2d32:	f019 fdfa 	bl	1c92a <TCPIP_UDP_ArrayPut>
      TCPIP_UDP_Flush(pIState->udpSock );
    2d36:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2d3a:	f00b f8bf 	bl	debc <TCPIP_UDP_Flush>
    2d3e:	e0f8      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        ReportBW_Jitter_Loss(pIState, SESSION_REPORT);
    2d40:	2102      	movs	r1, #2
    2d42:	4620      	mov	r0, r4
    2d44:	f009 ff6e 	bl	cc24 <ReportBW_Jitter_Loss>
        pIState->statusReported = 1;
    2d48:	2301      	movs	r3, #1
    2d4a:	f884 30cd 	strb.w	r3, [r4, #205]	; 0xcd
    2d4e:	e742      	b.n	2bd6 <TCPIP_IPERF_Task+0x416>
        TCPIP_UDP_Discard(pIState->udpSock);
    2d50:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    2d54:	f01d fcb9 	bl	206ca <TCPIP_UDP_Discard>
        return;
    2d58:	e0eb      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        IperfSetState(pIState, IPERF_RX_DONE_STATE);
    2d5a:	2109      	movs	r1, #9
    2d5c:	4620      	mov	r0, r4
    2d5e:	f018 fff3 	bl	1bd48 <IperfSetState>
        return;
    2d62:	e0e6      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
   if ( pIState->stopRequested == true )
    2d64:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
    2d68:	2b01      	cmp	r3, #1
    2d6a:	d024      	beq.n	2db6 <TCPIP_IPERF_Task+0x5f6>
   if( TCPIP_TCP_IsConnected(pIState->tcpServerSock) )
    2d6c:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2d70:	f01d f9e4 	bl	2013c <TCPIP_TCP_IsConnected>
    2d74:	2800      	cmp	r0, #0
    2d76:	f000 80dc 	beq.w	2f32 <TCPIP_IPERF_Task+0x772>
	  TCPIP_TCP_SocketInfoGet( pIState->tcpServerSock, &tcpSocketInfo);
    2d7a:	a906      	add	r1, sp, #24
    2d7c:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2d80:	f016 fce4 	bl	1974c <TCPIP_TCP_SocketInfoGet>
      memcpy ( (void *) &pIState->remoteSide, &tcpSocketInfo, sizeof ( TCP_SOCKET_INFO) );
    2d84:	f104 0c40 	add.w	ip, r4, #64	; 0x40
    2d88:	ad06      	add	r5, sp, #24
    2d8a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2d8c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2d90:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2d92:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2d96:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2d98:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2d9c:	e895 0003 	ldmia.w	r5, {r0, r1}
    2da0:	e88c 0003 	stmia.w	ip, {r0, r1}
      IperfSetState(pIState, IPERF_TCP_RX_STATE);
    2da4:	2107      	movs	r1, #7
    2da6:	4620      	mov	r0, r4
    2da8:	f018 ffce 	bl	1bd48 <IperfSetState>
      TCPIP_TCP_WasReset(pIState->tcpServerSock);
    2dac:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2db0:	f01c fe77 	bl	1faa2 <TCPIP_TCP_WasReset>
    2db4:	e0bd      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        IperfSetState(pIState, IPERF_RX_DONE_STATE);
    2db6:	2109      	movs	r1, #9
    2db8:	4620      	mov	r0, r4
    2dba:	f018 ffc5 	bl	1bd48 <IperfSetState>
        return;
    2dbe:	e0b8      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    2dc0:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2dc4:	f8d3 9004 	ldr.w	r9, [r3, #4]
    if( (length = TCPIP_TCP_GetIsReady(pIState->tcpServerSock)) == 0 )
    2dc8:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2dcc:	f01e fdb3 	bl	21936 <TCPIP_TCP_GetIsReady>
    2dd0:	4605      	mov	r5, r0
    2dd2:	2800      	cmp	r0, #0
    2dd4:	d066      	beq.n	2ea4 <TCPIP_IPERF_Task+0x6e4>
       if ( pIState->pktId == 0)
    2dd6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2dd8:	2b00      	cmp	r3, #0
    2dda:	d14c      	bne.n	2e76 <TCPIP_IPERF_Task+0x6b6>
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: instance %d session started ...\r\n", pIState - gIperfState);
    2ddc:	4bc7      	ldr	r3, [pc, #796]	; (30fc <TCPIP_IPERF_Task+0x93c>)
    2dde:	1ae3      	subs	r3, r4, r3
    2de0:	10db      	asrs	r3, r3, #3
    2de2:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
    2de6:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    2dea:	ebc3 2343 	rsb	r3, r3, r3, lsl #9
    2dee:	eb03 4383 	add.w	r3, r3, r3, lsl #18
    2df2:	f8d4 20c4 	ldr.w	r2, [r4, #196]	; 0xc4
    2df6:	6812      	ldr	r2, [r2, #0]
    2df8:	f8d2 a004 	ldr.w	sl, [r2, #4]
    2dfc:	425a      	negs	r2, r3
    2dfe:	f508 61f5 	add.w	r1, r8, #1960	; 0x7a8
    2e02:	4648      	mov	r0, r9
    2e04:	47d0      	blx	sl
          pIState->startTime = SYS_TMR_TickCountGet();
    2e06:	f01d f8d1 	bl	1ffac <SYS_TMR_TickCountGet>
    2e0a:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
          pIState->lastCheckTime = 	pIState->startTime;
    2e0e:	f8c4 00a8 	str.w	r0, [r4, #168]	; 0xa8
          pIState->lastCheckPktId = pIState->pktId;
    2e12:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2e14:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
          lclAddress.Val = TCPIP_STACK_NetAddress(TCPIP_TCP_SocketNetGet(pIState->tcpServerSock));
    2e18:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2e1c:	f01e fe0e 	bl	21a3c <TCPIP_TCP_SocketNetGet>
    2e20:	f01d ff03 	bl	20c2a <TCPIP_STACK_NetAddress>
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Local  %u.%u.%u.%u port %u connected with\r\n",
    2e24:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2e28:	681b      	ldr	r3, [r3, #0]
    2e2a:	8a62      	ldrh	r2, [r4, #18]
    2e2c:	9202      	str	r2, [sp, #8]
    2e2e:	0e02      	lsrs	r2, r0, #24
    2e30:	9201      	str	r2, [sp, #4]
    2e32:	f3c0 4207 	ubfx	r2, r0, #16, #8
    2e36:	9200      	str	r2, [sp, #0]
    2e38:	f8d3 a004 	ldr.w	sl, [r3, #4]
    2e3c:	f3c0 2307 	ubfx	r3, r0, #8, #8
    2e40:	b2c2      	uxtb	r2, r0
    2e42:	f208 515c 	addw	r1, r8, #1372	; 0x55c
    2e46:	4648      	mov	r0, r9
    2e48:	47d0      	blx	sl
          (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Remote %u.%u.%u.%u port %u\r\n",
    2e4a:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2e4e:	681b      	ldr	r3, [r3, #0]
    2e50:	f8b4 2064 	ldrh.w	r2, [r4, #100]	; 0x64
    2e54:	9202      	str	r2, [sp, #8]
    2e56:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
    2e5a:	9201      	str	r2, [sp, #4]
    2e5c:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
    2e60:	9200      	str	r2, [sp, #0]
    2e62:	f8d3 a004 	ldr.w	sl, [r3, #4]
    2e66:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    2e6a:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
    2e6e:	f508 61b2 	add.w	r1, r8, #1424	; 0x590
    2e72:	4648      	mov	r0, r9
    2e74:	47d0      	blx	sl
       pIState->pktId++;
    2e76:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2e78:	3301      	adds	r3, #1
    2e7a:	62a3      	str	r3, [r4, #40]	; 0x28
       pIState->pktCount++;
    2e7c:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
    2e80:	3201      	adds	r2, #1
    2e82:	f8c4 2094 	str.w	r2, [r4, #148]	; 0x94
       pIState->lastPktId = pIState->pktId;
    2e86:	62e3      	str	r3, [r4, #44]	; 0x2c
       pIState->totalLen += length;
    2e88:	4628      	mov	r0, r5
    2e8a:	f007 fe77 	bl	ab7c <__aeabi_i2d>
    2e8e:	4602      	mov	r2, r0
    2e90:	460b      	mov	r3, r1
    2e92:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    2e96:	f007 fd25 	bl	a8e4 <__adddf3>
    2e9a:	e9c4 0108 	strd	r0, r1, [r4, #32]
          TCPIP_TCP_ArrayGet( pIState->tcpServerSock, (uint8_t*)g_bfr, chunk);
    2e9e:	f04f 0934 	mov.w	r9, #52	; 0x34
    2ea2:	e01b      	b.n	2edc <TCPIP_IPERF_Task+0x71c>
      if ( TCPIP_TCP_WasReset(pIState->tcpServerSock) || TCPIP_TCP_WasDisconnected(pIState->tcpServerSock)  )
    2ea4:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2ea8:	f01c fdfb 	bl	1faa2 <TCPIP_TCP_WasReset>
    2eac:	b920      	cbnz	r0, 2eb8 <TCPIP_IPERF_Task+0x6f8>
    2eae:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2eb2:	f01e fbca 	bl	2164a <TCPIP_TCP_WasDisconnected>
    2eb6:	b1c8      	cbz	r0, 2eec <TCPIP_IPERF_Task+0x72c>
          pIState->stopTime = SYS_TMR_TickCountGet();
    2eb8:	f01d f878 	bl	1ffac <SYS_TMR_TickCountGet>
    2ebc:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
          IperfSetState(pIState, IPERF_TCP_RX_DONE_STATE);
    2ec0:	2108      	movs	r1, #8
    2ec2:	4620      	mov	r0, r4
    2ec4:	f018 ff40 	bl	1bd48 <IperfSetState>
          return;
    2ec8:	e033      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
          TCPIP_TCP_ArrayGet( pIState->tcpServerSock, (uint8_t*)g_bfr, chunk);
    2eca:	464a      	mov	r2, r9
    2ecc:	4639      	mov	r1, r7
    2ece:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2ed2:	f012 fb1f 	bl	15514 <TCPIP_TCP_ArrayGet>
          length -= chunk;
    2ed6:	3d34      	subs	r5, #52	; 0x34
    2ed8:	b2ad      	uxth	r5, r5
       while ( length > 0 )
    2eda:	b13d      	cbz	r5, 2eec <TCPIP_IPERF_Task+0x72c>
          if ( length <  (uint16_t)MAX_BUFFER )
    2edc:	2d33      	cmp	r5, #51	; 0x33
    2ede:	d8f4      	bhi.n	2eca <TCPIP_IPERF_Task+0x70a>
          TCPIP_TCP_ArrayGet( pIState->tcpServerSock, (uint8_t*)g_bfr, chunk);
    2ee0:	462a      	mov	r2, r5
    2ee2:	4639      	mov	r1, r7
    2ee4:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    2ee8:	f012 fb14 	bl	15514 <TCPIP_TCP_ArrayGet>
    if ((pIState->pktId != (long)0) &&
    2eec:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2eee:	b963      	cbnz	r3, 2f0a <TCPIP_IPERF_Task+0x74a>
    if ( pIState->stopRequested == true )
    2ef0:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
    2ef4:	2b01      	cmp	r3, #1
    2ef6:	d11c      	bne.n	2f32 <TCPIP_IPERF_Task+0x772>
       IperfSetState(pIState, IPERF_TCP_RX_DONE_STATE);
    2ef8:	2108      	movs	r1, #8
    2efa:	4620      	mov	r0, r4
    2efc:	f018 ff24 	bl	1bd48 <IperfSetState>
       pIState->stopTime = SYS_TMR_TickCountGet();
    2f00:	f01d f854 	bl	1ffac <SYS_TMR_TickCountGet>
    2f04:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
       return;
    2f08:	e013      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
       ((int32_t)(SYS_TMR_TickCountGet() - pIState->lastCheckTime) > pIState->mInterval) )
    2f0a:	f01d f84f 	bl	1ffac <SYS_TMR_TickCountGet>
    2f0e:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
    2f12:	1ac3      	subs	r3, r0, r3
    if ((pIState->pktId != (long)0) &&
    2f14:	6822      	ldr	r2, [r4, #0]
    2f16:	4293      	cmp	r3, r2
    2f18:	d9ea      	bls.n	2ef0 <TCPIP_IPERF_Task+0x730>
         ReportBW_Jitter_Loss(pIState, INTERVAL_REPORT);
    2f1a:	2100      	movs	r1, #0
    2f1c:	4620      	mov	r0, r4
    2f1e:	f009 fe81 	bl	cc24 <ReportBW_Jitter_Loss>
    2f22:	e7e5      	b.n	2ef0 <TCPIP_IPERF_Task+0x730>
    if ( pIState->statusReported == 0u )
    2f24:	f894 30cd 	ldrb.w	r3, [r4, #205]	; 0xcd
    2f28:	b3c3      	cbz	r3, 2f9c <TCPIP_IPERF_Task+0x7dc>
    IperfSetState(pIState, IPERF_RX_DONE_STATE);
    2f2a:	2109      	movs	r1, #9
    2f2c:	4620      	mov	r0, r4
    2f2e:	f018 ff0b 	bl	1bd48 <IperfSetState>
        for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
    2f32:	3601      	adds	r6, #1
    2f34:	34d8      	adds	r4, #216	; 0xd8
    2f36:	4b72      	ldr	r3, [pc, #456]	; (3100 <TCPIP_IPERF_Task+0x940>)
    2f38:	681b      	ldr	r3, [r3, #0]
    2f3a:	42b3      	cmp	r3, r6
    2f3c:	f340 82d4 	ble.w	34e8 <TCPIP_IPERF_Task+0xd28>
	if (pIState->state == IPERF_STANDBY_STATE)
    2f40:	f894 30ce 	ldrb.w	r3, [r4, #206]	; 0xce
    2f44:	2b01      	cmp	r3, #1
    2f46:	d0f4      	beq.n	2f32 <TCPIP_IPERF_Task+0x772>
    switch ( pIState->state )
    2f48:	3b02      	subs	r3, #2
    2f4a:	2b10      	cmp	r3, #16
    2f4c:	f200 82b1 	bhi.w	34b2 <TCPIP_IPERF_Task+0xcf2>
    2f50:	a201      	add	r2, pc, #4	; (adr r2, 2f58 <TCPIP_IPERF_Task+0x798>)
    2f52:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    2f56:	bf00      	nop
    2f58:	000027f9 	.word	0x000027f9
    2f5c:	000028f1 	.word	0x000028f1
    2f60:	00002b9f 	.word	0x00002b9f
    2f64:	00002bcd 	.word	0x00002bcd
    2f68:	00002d65 	.word	0x00002d65
    2f6c:	00002dc1 	.word	0x00002dc1
    2f70:	00002f25 	.word	0x00002f25
    2f74:	00002fad 	.word	0x00002fad
    2f78:	00003051 	.word	0x00003051
    2f7c:	0000306f 	.word	0x0000306f
    2f80:	00003233 	.word	0x00003233
    2f84:	00003317 	.word	0x00003317
    2f88:	0000339f 	.word	0x0000339f
    2f8c:	0000348d 	.word	0x0000348d
    2f90:	00003143 	.word	0x00003143
    2f94:	000033ff 	.word	0x000033ff
    2f98:	000034a3 	.word	0x000034a3
        ReportBW_Jitter_Loss(pIState, SESSION_REPORT);
    2f9c:	2102      	movs	r1, #2
    2f9e:	4620      	mov	r0, r4
    2fa0:	f009 fe40 	bl	cc24 <ReportBW_Jitter_Loss>
        pIState->statusReported = 1;
    2fa4:	2301      	movs	r3, #1
    2fa6:	f884 30cd 	strb.w	r3, [r4, #205]	; 0xcd
    2faa:	e7be      	b.n	2f2a <TCPIP_IPERF_Task+0x76a>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    2fac:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2fb0:	685d      	ldr	r5, [r3, #4]
   switch( pIState->mProtocol)
    2fb2:	7c23      	ldrb	r3, [r4, #16]
    2fb4:	2b01      	cmp	r3, #1
    2fb6:	d02c      	beq.n	3012 <TCPIP_IPERF_Task+0x852>
    2fb8:	2b02      	cmp	r3, #2
    2fba:	d02f      	beq.n	301c <TCPIP_IPERF_Task+0x85c>
    (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf instance %d: Rx done. Socket closed.\r\n", pIState - gIperfState);
    2fbc:	4b4f      	ldr	r3, [pc, #316]	; (30fc <TCPIP_IPERF_Task+0x93c>)
    2fbe:	1ae3      	subs	r3, r4, r3
    2fc0:	10db      	asrs	r3, r3, #3
    2fc2:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
    2fc6:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    2fca:	ebc3 2343 	rsb	r3, r3, r3, lsl #9
    2fce:	eb03 4383 	add.w	r3, r3, r3, lsl #18
    2fd2:	f1c3 0900 	rsb	r9, r3, #0
    2fd6:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2fda:	681b      	ldr	r3, [r3, #0]
    2fdc:	685b      	ldr	r3, [r3, #4]
    2fde:	464a      	mov	r2, r9
    2fe0:	f208 71d4 	addw	r1, r8, #2004	; 0x7d4
    2fe4:	4628      	mov	r0, r5
    2fe6:	4798      	blx	r3
    ResetIperfCounters(pIState);
    2fe8:	4620      	mov	r0, r4
    2fea:	f019 fb6f 	bl	1c6cc <ResetIperfCounters>
    if ((pIState->mServerMode == true) 	&&
    2fee:	f894 30d1 	ldrb.w	r3, [r4, #209]	; 0xd1
    2ff2:	2b01      	cmp	r3, #1
    2ff4:	d01a      	beq.n	302c <TCPIP_IPERF_Task+0x86c>
        (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf instance %d: completed.\r\n", pIState - gIperfState);
    2ff6:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    2ffa:	681b      	ldr	r3, [r3, #0]
    2ffc:	685b      	ldr	r3, [r3, #4]
    2ffe:	464a      	mov	r2, r9
    3000:	f608 0138 	addw	r1, r8, #2104	; 0x838
    3004:	4628      	mov	r0, r5
    3006:	4798      	blx	r3
        IperfSetState(pIState, IPERF_STANDBY_STATE);
    3008:	2101      	movs	r1, #1
    300a:	4620      	mov	r0, r4
    300c:	f018 fe9c 	bl	1bd48 <IperfSetState>
    3010:	e78f      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
           TCPIP_UDP_Close(  pIState->udpSock );
    3012:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    3016:	f01c f8a5 	bl	1f164 <TCPIP_UDP_Close>
           break;
    301a:	e7cf      	b.n	2fbc <TCPIP_IPERF_Task+0x7fc>
           TCPIP_TCP_Close( pIState->tcpServerSock );
    301c:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
    3020:	f01a ff2b 	bl	1de7a <TCPIP_TCP_Close>
           pIState->tcpServerSock = INVALID_SOCKET;
    3024:	f64f 73ff 	movw	r3, #65535	; 0xffff
    3028:	8723      	strh	r3, [r4, #56]	; 0x38
           break;
    302a:	e7c7      	b.n	2fbc <TCPIP_IPERF_Task+0x7fc>
    if ((pIState->mServerMode == true) 	&&
    302c:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
    3030:	2b00      	cmp	r3, #0
    3032:	d1e0      	bne.n	2ff6 <TCPIP_IPERF_Task+0x836>
        (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf instance %d: Ready for the next session.\r\n", pIState - gIperfState);
    3034:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    3038:	681b      	ldr	r3, [r3, #0]
    303a:	685b      	ldr	r3, [r3, #4]
    303c:	464a      	mov	r2, r9
    303e:	f608 0104 	addw	r1, r8, #2052	; 0x804
    3042:	4628      	mov	r0, r5
    3044:	4798      	blx	r3
        IperfSetState(pIState, IPERF_RX_START_STATE);
    3046:	2102      	movs	r1, #2
    3048:	4620      	mov	r0, r4
    304a:	f018 fe7d 	bl	1bd48 <IperfSetState>
    304e:	e770      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
   TCPIP_ARP_Resolve(pIState->pNetIf, &pIState->remoteSide.remoteIPaddress.v4Add);
    3050:	f104 0144 	add.w	r1, r4, #68	; 0x44
    3054:	f8d4 00c8 	ldr.w	r0, [r4, #200]	; 0xc8
    3058:	f019 ffeb 	bl	1d032 <TCPIP_ARP_Resolve>
   IperfSetState(pIState, IPERF_TX_ARP_RESOLVE_STATE);
    305c:	210b      	movs	r1, #11
    305e:	4620      	mov	r0, r4
    3060:	f018 fe72 	bl	1bd48 <IperfSetState>
   pIState->timer = SYS_TMR_TickCountGet();
    3064:	f01c ffa2 	bl	1ffac <SYS_TMR_TickCountGet>
    3068:	f8c4 00ac 	str.w	r0, [r4, #172]	; 0xac
    306c:	e761      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    306e:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    3072:	685d      	ldr	r5, [r3, #4]
  if ( pIState->stopRequested == true )
    3074:	f894 20cf 	ldrb.w	r2, [r4, #207]	; 0xcf
    3078:	2a01      	cmp	r2, #1
    307a:	d011      	beq.n	30a0 <TCPIP_IPERF_Task+0x8e0>
  if(!(TCPIP_Helper_IsMcastAddress(&pIState->remoteSide.remoteIPaddress.v4Add)))
    307c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    3080:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    3084:	2be0      	cmp	r3, #224	; 0xe0
    3086:	d116      	bne.n	30b6 <TCPIP_IPERF_Task+0x8f6>
  if ( pIState->mProtocol == UDP_PROTOCOL )
    3088:	7c23      	ldrb	r3, [r4, #16]
    308a:	2b01      	cmp	r3, #1
    308c:	d054      	beq.n	3138 <TCPIP_IPERF_Task+0x978>
  if ( pIState->mProtocol == TCP_PROTOCOL )
    308e:	7c23      	ldrb	r3, [r4, #16]
    3090:	2b02      	cmp	r3, #2
    3092:	f47f af4e 	bne.w	2f32 <TCPIP_IPERF_Task+0x772>
     IperfSetState(pIState, IPERF_TCP_TX_OPEN_STATE);
    3096:	210c      	movs	r1, #12
    3098:	4620      	mov	r0, r4
    309a:	f018 fe55 	bl	1bd48 <IperfSetState>
    309e:	e748      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
     (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: client session closed.\r\n");
    30a0:	681b      	ldr	r3, [r3, #0]
    30a2:	681b      	ldr	r3, [r3, #0]
    30a4:	f608 0158 	addw	r1, r8, #2136	; 0x858
    30a8:	4628      	mov	r0, r5
    30aa:	4798      	blx	r3
     IperfSetState(pIState, IPERF_STANDBY_STATE);
    30ac:	2101      	movs	r1, #1
    30ae:	4620      	mov	r0, r4
    30b0:	f018 fe4a 	bl	1bd48 <IperfSetState>
     return;
    30b4:	e73d      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    if(!TCPIP_ARP_IsResolved(pIState->pNetIf, &pIState->remoteSide.remoteIPaddress.v4Add, &pIState->remoteMACAddr))
    30b6:	f104 0278 	add.w	r2, r4, #120	; 0x78
    30ba:	f104 0144 	add.w	r1, r4, #68	; 0x44
    30be:	f8d4 00c8 	ldr.w	r0, [r4, #200]	; 0xc8
    30c2:	f015 f84f 	bl	18164 <TCPIP_ARP_IsResolved>
    30c6:	b1e8      	cbz	r0, 3104 <TCPIP_IPERF_Task+0x944>
    (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - RemoteNode MAC: %x %x %x %x %x %x\r\n",
    30c8:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    30cc:	681b      	ldr	r3, [r3, #0]
    30ce:	f894 207d 	ldrb.w	r2, [r4, #125]	; 0x7d
    30d2:	9203      	str	r2, [sp, #12]
    30d4:	f894 207c 	ldrb.w	r2, [r4, #124]	; 0x7c
    30d8:	9202      	str	r2, [sp, #8]
    30da:	f894 207b 	ldrb.w	r2, [r4, #123]	; 0x7b
    30de:	9201      	str	r2, [sp, #4]
    30e0:	f894 207a 	ldrb.w	r2, [r4, #122]	; 0x7a
    30e4:	9200      	str	r2, [sp, #0]
    30e6:	f8d3 9004 	ldr.w	r9, [r3, #4]
    30ea:	f894 3079 	ldrb.w	r3, [r4, #121]	; 0x79
    30ee:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
    30f2:	f608 01b8 	addw	r1, r8, #2232	; 0x8b8
    30f6:	4628      	mov	r0, r5
    30f8:	47c8      	blx	r9
    30fa:	e7c5      	b.n	3088 <TCPIP_IPERF_Task+0x8c8>
    30fc:	2000dbb0 	.word	0x2000dbb0
    3100:	2000e5f8 	.word	0x2000e5f8
        if( SYS_TMR_TickCountGet() - pIState->timer > 5 * SYS_TMR_TickCounterFrequencyGet() )
    3104:	f01c ff52 	bl	1ffac <SYS_TMR_TickCountGet>
    3108:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
    310c:	eba0 0903 	sub.w	r9, r0, r3
    3110:	f01c ff74 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
    3114:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    3118:	4581      	cmp	r9, r0
    311a:	f67f af0a 	bls.w	2f32 <TCPIP_IPERF_Task+0x772>
            (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: ARP unable to resolve the MAC address of remote side.\r\n");
    311e:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    3122:	681b      	ldr	r3, [r3, #0]
    3124:	681b      	ldr	r3, [r3, #0]
    3126:	f608 0178 	addw	r1, r8, #2168	; 0x878
    312a:	4628      	mov	r0, r5
    312c:	4798      	blx	r3
            pIState->timer = SYS_TMR_TickCountGet();
    312e:	f01c ff3d 	bl	1ffac <SYS_TMR_TickCountGet>
    3132:	f8c4 00ac 	str.w	r0, [r4, #172]	; 0xac
    3136:	e6fc      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
     IperfSetState(pIState, IPERF_UDP_TX_OPEN_STATE);
    3138:	2110      	movs	r1, #16
    313a:	4620      	mov	r0, r4
    313c:	f018 fe04 	bl	1bd48 <IperfSetState>
    3140:	e7a5      	b.n	308e <TCPIP_IPERF_Task+0x8ce>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    3142:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    3146:	685d      	ldr	r5, [r3, #4]
    if ( (pIState->udpSock = TCPIP_UDP_ClientOpen(IP_ADDRESS_TYPE_IPV4, pIState->mServerPort, (IP_MULTI_ADDRESS*)&pIState->remoteSide.remoteIPaddress.v4Add)) == INVALID_UDP_SOCKET )
    3148:	f104 0244 	add.w	r2, r4, #68	; 0x44
    314c:	8a61      	ldrh	r1, [r4, #18]
    314e:	2001      	movs	r0, #1
    3150:	f01e ff6a 	bl	22028 <TCPIP_UDP_ClientOpen>
    3154:	87a0      	strh	r0, [r4, #60]	; 0x3c
    3156:	f1b0 3fff 	cmp.w	r0, #4294967295
    315a:	d05d      	beq.n	3218 <TCPIP_IPERF_Task+0xa58>
    TCPIP_UDP_SignalHandlerRegister(pIState->udpSock, TCPIP_UDP_SIGNAL_RX_DATA, _IperfUDPRxSignalHandler, 0);
    315c:	2300      	movs	r3, #0
    315e:	4ac9      	ldr	r2, [pc, #804]	; (3484 <TCPIP_IPERF_Task+0xcc4>)
    3160:	f44f 7180 	mov.w	r1, #256	; 0x100
    3164:	f019 fff1 	bl	1d14a <TCPIP_UDP_SignalHandlerRegister>
    if(!TCPIP_UDP_OptionsSet(pIState->udpSock, UDP_OPTION_TX_BUFF, (void*)pIState->mDatagramSize))
    3168:	68e2      	ldr	r2, [r4, #12]
    316a:	2105      	movs	r1, #5
    316c:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    3170:	f00b fac8 	bl	e704 <TCPIP_UDP_OptionsSet>
    3174:	b938      	cbnz	r0, 3186 <TCPIP_IPERF_Task+0x9c6>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Set of TX buffer size failed\r\n");
    3176:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    317a:	681b      	ldr	r3, [r3, #0]
    317c:	681b      	ldr	r3, [r3, #0]
    317e:	f608 01e4 	addw	r1, r8, #2276	; 0x8e4
    3182:	4628      	mov	r0, r5
    3184:	4798      	blx	r3
    if(!TCPIP_UDP_OptionsSet(pIState->udpSock, UDP_OPTION_TX_QUEUE_LIMIT, (void*)TCPIP_IPERF_TX_QUEUE_LIMIT))
    3186:	2202      	movs	r2, #2
    3188:	2106      	movs	r1, #6
    318a:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    318e:	f00b fab9 	bl	e704 <TCPIP_UDP_OptionsSet>
    3192:	b938      	cbnz	r0, 31a4 <TCPIP_IPERF_Task+0x9e4>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Set of TX queuing limit failed\r\n");
    3194:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    3198:	681b      	ldr	r3, [r3, #0]
    319a:	681b      	ldr	r3, [r3, #0]
    319c:	f608 110c 	addw	r1, r8, #2316	; 0x90c
    31a0:	4628      	mov	r0, r5
    31a2:	4798      	blx	r3
    TCPIP_UDP_SocketNetSet(pIState->udpSock, pIState->pNetIf);
    31a4:	f8d4 10c8 	ldr.w	r1, [r4, #200]	; 0xc8
    31a8:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    31ac:	f01a fc32 	bl	1da14 <TCPIP_UDP_SocketNetSet>
	TCPIP_UDP_SocketInfoGet(pIState->udpSock, &UdpSkt);
    31b0:	a906      	add	r1, sp, #24
    31b2:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    31b6:	f017 feb1 	bl	1af1c <TCPIP_UDP_SocketInfoGet>
    pIState->localPort = UdpSkt.localPort;
    31ba:	f8bd 305e 	ldrh.w	r3, [sp, #94]	; 0x5e
    31be:	f8a4 307e 	strh.w	r3, [r4, #126]	; 0x7e
    (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "---------------------------------------------------------\r\n");
    31c2:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    31c6:	681b      	ldr	r3, [r3, #0]
    31c8:	681b      	ldr	r3, [r3, #0]
    31ca:	f508 7167 	add.w	r1, r8, #924	; 0x39c
    31ce:	4628      	mov	r0, r5
    31d0:	4798      	blx	r3
    (pIState->pCmdIO->pCmdApi->print)(cmdIoParam,  "iperf: Client connecting to %u.%u.%u.%u, UDP port %u\r\n",
    31d2:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    31d6:	681b      	ldr	r3, [r3, #0]
    31d8:	8a62      	ldrh	r2, [r4, #18]
    31da:	9202      	str	r2, [sp, #8]
    31dc:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
    31e0:	9201      	str	r2, [sp, #4]
    31e2:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
    31e6:	9200      	str	r2, [sp, #0]
    31e8:	f8d3 9004 	ldr.w	r9, [r3, #4]
    31ec:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    31f0:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
    31f4:	f608 1134 	addw	r1, r8, #2356	; 0x934
    31f8:	4628      	mov	r0, r5
    31fa:	47c8      	blx	r9
    IperfSetState(pIState, IPERF_UDP_TX_DATAGRAM_STATE);
    31fc:	2111      	movs	r1, #17
    31fe:	4620      	mov	r0, r4
    3200:	f018 fda2 	bl	1bd48 <IperfSetState>
    pIState->startTime = SYS_TMR_TickCountGet();
    3204:	f01c fed2 	bl	1ffac <SYS_TMR_TickCountGet>
    3208:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
    pIState->nextTxTime = pIState->startTime + pIState->mPktPeriod;
    320c:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
    3210:	4403      	add	r3, r0
    3212:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
    3216:	e68c      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Create UDP socket failed\r\n");
    3218:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    321c:	681b      	ldr	r3, [r3, #0]
    321e:	681b      	ldr	r3, [r3, #0]
    3220:	f508 61dd 	add.w	r1, r8, #1768	; 0x6e8
    3224:	4628      	mov	r0, r5
    3226:	4798      	blx	r3
        IperfSetState(pIState, IPERF_STANDBY_STATE);
    3228:	2101      	movs	r1, #1
    322a:	4620      	mov	r0, r4
    322c:	f018 fd8c 	bl	1bd48 <IperfSetState>
        return;
    3230:	e67f      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    3232:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    3236:	685d      	ldr	r5, [r3, #4]
   if  ( (pIState->tcpClientSock = TCPIP_TCP_ClientOpen(IP_ADDRESS_TYPE_IPV4, pIState->mServerPort, 0)) == INVALID_SOCKET )
    3238:	2200      	movs	r2, #0
    323a:	8a61      	ldrh	r1, [r4, #18]
    323c:	2001      	movs	r0, #1
    323e:	f01d ff88 	bl	21152 <TCPIP_TCP_ClientOpen>
    3242:	8760      	strh	r0, [r4, #58]	; 0x3a
    3244:	f1b0 3fff 	cmp.w	r0, #4294967295
    3248:	d04f      	beq.n	32ea <TCPIP_IPERF_Task+0xb2a>
   TCPIP_TCP_SignalHandlerRegister(pIState->tcpClientSock, TCPIP_TCP_SIGNAL_RX_DATA, _IperfTCPRxSignalHandler, 0);
    324a:	2300      	movs	r3, #0
    324c:	4a8e      	ldr	r2, [pc, #568]	; (3488 <TCPIP_IPERF_Task+0xcc8>)
    324e:	f44f 7100 	mov.w	r1, #512	; 0x200
    3252:	f01a f803 	bl	1d25c <TCPIP_TCP_SignalHandlerRegister>
   if(pIState->localAddr.Val != 0)
    3256:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
    325a:	2b00      	cmp	r3, #0
    325c:	d152      	bne.n	3304 <TCPIP_IPERF_Task+0xb44>
   TCPIP_TCP_RemoteBind(pIState->tcpClientSock, IP_ADDRESS_TYPE_IPV4, 0,  (IP_MULTI_ADDRESS*)&pIState->remoteSide.remoteIPaddress);
    325e:	f104 0344 	add.w	r3, r4, #68	; 0x44
    3262:	2200      	movs	r2, #0
    3264:	2101      	movs	r1, #1
    3266:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    326a:	f018 ff64 	bl	1c136 <TCPIP_TCP_RemoteBind>
    pIState->localPort = TCPIP_IPERF_TCP_LOCAL_PORT_START_NUMBER;
    326e:	f44f 6380 	mov.w	r3, #1024	; 0x400
    3272:	f8a4 307e 	strh.w	r3, [r4, #126]	; 0x7e
    (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "---------------------------------------------------------\r\n");
    3276:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    327a:	681b      	ldr	r3, [r3, #0]
    327c:	681b      	ldr	r3, [r3, #0]
    327e:	f508 7167 	add.w	r1, r8, #924	; 0x39c
    3282:	4628      	mov	r0, r5
    3284:	4798      	blx	r3
    (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf: Client connecting to %u.%u.%u.%u, TCP port %u\r\n",
    3286:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    328a:	681b      	ldr	r3, [r3, #0]
    328c:	8a62      	ldrh	r2, [r4, #18]
    328e:	9202      	str	r2, [sp, #8]
    3290:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
    3294:	9201      	str	r2, [sp, #4]
    3296:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
    329a:	9200      	str	r2, [sp, #0]
    329c:	f8d3 9004 	ldr.w	r9, [r3, #4]
    32a0:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    32a4:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
    32a8:	f608 116c 	addw	r1, r8, #2412	; 0x96c
    32ac:	4628      	mov	r0, r5
    32ae:	47c8      	blx	r9
    IperfSetState(pIState, IPERF_TCP_TX_CONNECT_STATE);
    32b0:	210d      	movs	r1, #13
    32b2:	4620      	mov	r0, r4
    32b4:	f018 fd48 	bl	1bd48 <IperfSetState>
    if(!TCPIP_TCP_OptionsSet(pIState->tcpClientSock, TCP_OPTION_TX_BUFF, (void*)pIState->txBuffSize))
    32b8:	f8d4 20b8 	ldr.w	r2, [r4, #184]	; 0xb8
    32bc:	2103      	movs	r1, #3
    32be:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    32c2:	f010 fbc8 	bl	13a56 <TCPIP_TCP_OptionsSet>
    32c6:	b938      	cbnz	r0, 32d8 <TCPIP_IPERF_Task+0xb18>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Set of TX buffer size failed\r\n");
    32c8:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    32cc:	681b      	ldr	r3, [r3, #0]
    32ce:	681b      	ldr	r3, [r3, #0]
    32d0:	f608 01e4 	addw	r1, r8, #2276	; 0x8e4
    32d4:	4628      	mov	r0, r5
    32d6:	4798      	blx	r3
    TCPIP_TCP_Connect(pIState->tcpClientSock);
    32d8:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    32dc:	f01c f8a7 	bl	1f42e <TCPIP_TCP_Connect>
    pIState->timer = SYS_TMR_TickCountGet();
    32e0:	f01c fe64 	bl	1ffac <SYS_TMR_TickCountGet>
    32e4:	f8c4 00ac 	str.w	r0, [r4, #172]	; 0xac
    32e8:	e623      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Create TCP socket failed\r\n");
    32ea:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    32ee:	681b      	ldr	r3, [r3, #0]
    32f0:	681b      	ldr	r3, [r3, #0]
    32f2:	f208 619c 	addw	r1, r8, #1692	; 0x69c
    32f6:	4628      	mov	r0, r5
    32f8:	4798      	blx	r3
        IperfSetState(pIState, IPERF_STANDBY_STATE);
    32fa:	2101      	movs	r1, #1
    32fc:	4620      	mov	r0, r4
    32fe:	f018 fd23 	bl	1bd48 <IperfSetState>
        return;
    3302:	e616      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
       TCPIP_TCP_Bind(pIState->tcpClientSock, IP_ADDRESS_TYPE_IPV4, pIState->mServerPort, (IP_MULTI_ADDRESS*)&pIState->localAddr);
    3304:	f104 0380 	add.w	r3, r4, #128	; 0x80
    3308:	8a62      	ldrh	r2, [r4, #18]
    330a:	2101      	movs	r1, #1
    330c:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    3310:	f012 fcea 	bl	15ce8 <TCPIP_TCP_Bind>
    3314:	e7a3      	b.n	325e <TCPIP_IPERF_Task+0xa9e>
    if ( pIState->stopRequested == true )
    3316:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
    331a:	2b01      	cmp	r3, #1
    331c:	d01a      	beq.n	3354 <TCPIP_IPERF_Task+0xb94>
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    331e:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    3322:	f8d3 9004 	ldr.w	r9, [r3, #4]
    if( !TCPIP_TCP_IsConnected(pIState->tcpClientSock) )
    3326:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    332a:	f01c ff07 	bl	2013c <TCPIP_TCP_IsConnected>
    332e:	b1b0      	cbz	r0, 335e <TCPIP_IPERF_Task+0xb9e>
    TCPIP_TCP_WasReset(pIState->tcpClientSock);
    3330:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    3334:	f01c fbb5 	bl	1faa2 <TCPIP_TCP_WasReset>
    pIState->startTime = SYS_TMR_TickCountGet();
    3338:	f01c fe38 	bl	1ffac <SYS_TMR_TickCountGet>
    333c:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
    pIState->nextTxTime = pIState->startTime + pIState->mPktPeriod;
    3340:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
    3344:	4403      	add	r3, r0
    3346:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
    IperfSetState(pIState, IPERF_TCP_TX_SEGMENT_STATE);
    334a:	210e      	movs	r1, #14
    334c:	4620      	mov	r0, r4
    334e:	f018 fcfb 	bl	1bd48 <IperfSetState>
    3352:	e5ee      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        IperfSetState(pIState, IPERF_TCP_TX_DONE_STATE);
    3354:	210f      	movs	r1, #15
    3356:	4620      	mov	r0, r4
    3358:	f018 fcf6 	bl	1bd48 <IperfSetState>
        return;
    335c:	e5e9      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        if(SYS_TMR_TickCountGet()- pIState->timer > 5*SYS_TMR_TickCounterFrequencyGet())
    335e:	f01c fe25 	bl	1ffac <SYS_TMR_TickCountGet>
    3362:	f8d4 50ac 	ldr.w	r5, [r4, #172]	; 0xac
    3366:	1b45      	subs	r5, r0, r5
    3368:	f01c fe48 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
    336c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    3370:	4285      	cmp	r5, r0
    3372:	f67f adde 	bls.w	2f32 <TCPIP_IPERF_Task+0x772>
            TCPIP_TCP_Close(pIState->tcpClientSock);
    3376:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    337a:	f01a fd7e 	bl	1de7a <TCPIP_TCP_Close>
            pIState->tcpClientSock = INVALID_SOCKET;
    337e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    3382:	8763      	strh	r3, [r4, #58]	; 0x3a
            (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: TCP Client connection timeout\r\n");
    3384:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    3388:	681b      	ldr	r3, [r3, #0]
    338a:	681b      	ldr	r3, [r3, #0]
    338c:	f608 11a4 	addw	r1, r8, #2468	; 0x9a4
    3390:	4648      	mov	r0, r9
    3392:	4798      	blx	r3
            IperfSetState(pIState, IPERF_TCP_TX_DONE_STATE);
    3394:	210f      	movs	r1, #15
    3396:	4620      	mov	r0, r4
    3398:	f018 fcd6 	bl	1bd48 <IperfSetState>
    339c:	e5c9      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    tIperfTxResult txRes = GenericTxStart(pIState);
    339e:	4620      	mov	r0, r4
    33a0:	f006 fd2e 	bl	9e00 <GenericTxStart>
    if(txRes == IPERF_TX_OK)
    33a4:	2801      	cmp	r0, #1
    33a6:	d00b      	beq.n	33c0 <TCPIP_IPERF_Task+0xc00>
    else if(txRes == IPERF_TX_FAIL)
    33a8:	2802      	cmp	r0, #2
    33aa:	f47f adc2 	bne.w	2f32 <TCPIP_IPERF_Task+0x772>
        IperfSetState(pIState, IPERF_TCP_TX_DONE_STATE);
    33ae:	210f      	movs	r1, #15
    33b0:	4620      	mov	r0, r4
    33b2:	f018 fcc9 	bl	1bd48 <IperfSetState>
        pIState->stopTime = SYS_TMR_TickCountGet();
    33b6:	f01c fdf9 	bl	1ffac <SYS_TMR_TickCountGet>
    33ba:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    33be:	e5b8      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
  memset( g_bfr, 0x54, MAX_BUFFER);
    33c0:	2234      	movs	r2, #52	; 0x34
    33c2:	2154      	movs	r1, #84	; 0x54
    33c4:	4638      	mov	r0, r7
    33c6:	f01e fbd9 	bl	21b7c <memset>
  while( pIState->remainingTxData > 0u )
    33ca:	f8b4 30b0 	ldrh.w	r3, [r4, #176]	; 0xb0
    33ce:	b173      	cbz	r3, 33ee <TCPIP_IPERF_Task+0xc2e>
      chunk = pIState->remainingTxData;
    33d0:	2b33      	cmp	r3, #51	; 0x33
    33d2:	bf94      	ite	ls
    33d4:	461d      	movls	r5, r3
    33d6:	2534      	movhi	r5, #52	; 0x34
    pIState->remainingTxData -= chunk;
    33d8:	1b5b      	subs	r3, r3, r5
    33da:	f8a4 30b0 	strh.w	r3, [r4, #176]	; 0xb0
    if ( TCPIP_TCP_ArrayPut( pIState->tcpClientSock, (uint8_t *) g_bfr, chunk) != chunk )
    33de:	462a      	mov	r2, r5
    33e0:	4639      	mov	r1, r7
    33e2:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    33e6:	f00d fba5 	bl	10b34 <TCPIP_TCP_ArrayPut>
    33ea:	4285      	cmp	r5, r0
    33ec:	d0ed      	beq.n	33ca <TCPIP_IPERF_Task+0xc0a>
       TCPIP_TCP_Flush(pIState->tcpClientSock);
    33ee:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    33f2:	f01c feb6 	bl	20162 <TCPIP_TCP_Flush>
       GenericTxEnd(pIState);
    33f6:	4620      	mov	r0, r4
    33f8:	f00c f83a 	bl	f470 <GenericTxEnd>
    33fc:	e599      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    TCPIP_UDP_OptionsSet(pIState->udpSock, UDP_OPTION_TOS, (void*)(unsigned int)pIState->mTypeOfService);   
    33fe:	7d22      	ldrb	r2, [r4, #20]
    3400:	210b      	movs	r1, #11
    3402:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    3406:	f00b f97d 	bl	e704 <TCPIP_UDP_OptionsSet>
    tIperfTxResult txRes = GenericTxStart(pIState);
    340a:	4620      	mov	r0, r4
    340c:	f006 fcf8 	bl	9e00 <GenericTxStart>
    if ( txRes == IPERF_TX_OK )
    3410:	2801      	cmp	r0, #1
    3412:	d00b      	beq.n	342c <TCPIP_IPERF_Task+0xc6c>
    else if(txRes == IPERF_TX_FAIL)
    3414:	2802      	cmp	r0, #2
    3416:	f47f ad8c 	bne.w	2f32 <TCPIP_IPERF_Task+0x772>
        IperfSetState(pIState, IPERF_UDP_TX_DONE_STATE);
    341a:	2112      	movs	r1, #18
    341c:	4620      	mov	r0, r4
    341e:	f018 fc93 	bl	1bd48 <IperfSetState>
        pIState->stopTime = SYS_TMR_TickCountGet();
    3422:	f01c fdc3 	bl	1ffac <SYS_TMR_TickCountGet>
    3426:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    342a:	e582      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    memset( g_bfr, 0x55, MAX_BUFFER);
    342c:	2234      	movs	r2, #52	; 0x34
    342e:	2155      	movs	r1, #85	; 0x55
    3430:	4638      	mov	r0, r7
    3432:	f01e fba3 	bl	21b7c <memset>
    remainingTxData = pIState->remainingTxData;
    3436:	f8b4 50b0 	ldrh.w	r5, [r4, #176]	; 0xb0
    while( remainingTxData > 0u )
    343a:	b1bd      	cbz	r5, 346c <TCPIP_IPERF_Task+0xcac>
    uint16_t txData = 0;
    343c:	f04f 0900 	mov.w	r9, #0
        if (  TCPIP_UDP_ArrayPut(pIState->udpSock, (uint8_t *) g_bfr, chunk) != chunk )
    3440:	f04f 0a34 	mov.w	sl, #52	; 0x34
    3444:	e001      	b.n	344a <TCPIP_IPERF_Task+0xc8a>
    while( remainingTxData > 0u )
    3446:	2d00      	cmp	r5, #0
    3448:	d041      	beq.n	34ce <TCPIP_IPERF_Task+0xd0e>
        if ( remainingTxData < MAX_BUFFER )
    344a:	2d33      	cmp	r5, #51	; 0x33
    344c:	d936      	bls.n	34bc <TCPIP_IPERF_Task+0xcfc>
        remainingTxData -= chunk;
    344e:	3d34      	subs	r5, #52	; 0x34
    3450:	b2ad      	uxth	r5, r5
        txData += chunk;
    3452:	f109 0934 	add.w	r9, r9, #52	; 0x34
    3456:	fa1f f989 	uxth.w	r9, r9
        if (  TCPIP_UDP_ArrayPut(pIState->udpSock, (uint8_t *) g_bfr, chunk) != chunk )
    345a:	4652      	mov	r2, sl
    345c:	4639      	mov	r1, r7
    345e:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    3462:	f019 fa62 	bl	1c92a <TCPIP_UDP_ArrayPut>
    3466:	2834      	cmp	r0, #52	; 0x34
    3468:	d0ed      	beq.n	3446 <TCPIP_IPERF_Task+0xc86>
    346a:	e030      	b.n	34ce <TCPIP_IPERF_Task+0xd0e>
    uint16_t txData = 0;
    346c:	46a9      	mov	r9, r5
    346e:	e02e      	b.n	34ce <TCPIP_IPERF_Task+0xd0e>
           pIState->remainingTxData -= txData;
    3470:	f8b4 30b0 	ldrh.w	r3, [r4, #176]	; 0xb0
    3474:	eba3 0909 	sub.w	r9, r3, r9
    3478:	f8a4 90b0 	strh.w	r9, [r4, #176]	; 0xb0
           GenericTxEnd(pIState);
    347c:	4620      	mov	r0, r4
    347e:	f00b fff7 	bl	f470 <GenericTxEnd>
    3482:	e556      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    3484:	00021661 	.word	0x00021661
    3488:	00021677 	.word	0x00021677
    GenericTxDone(pIState);
    348c:	4620      	mov	r0, r4
    348e:	f01c fc4d 	bl	1fd2c <GenericTxDone>
    TCPIP_TCP_Close(pIState->tcpClientSock);
    3492:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    3496:	f01a fcf0 	bl	1de7a <TCPIP_TCP_Close>
    pIState->tcpClientSock = INVALID_SOCKET;
    349a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    349e:	8763      	strh	r3, [r4, #58]	; 0x3a
    34a0:	e547      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
    GenericTxDone(pIState);
    34a2:	4620      	mov	r0, r4
    34a4:	f01c fc42 	bl	1fd2c <GenericTxDone>
    TCPIP_UDP_Close(pIState->udpSock );
    34a8:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    34ac:	f01b fe5a 	bl	1f164 <TCPIP_UDP_Close>
    34b0:	e53f      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
			IperfSetState(pIState, IPERF_STANDBY_STATE);
    34b2:	2101      	movs	r1, #1
    34b4:	4620      	mov	r0, r4
    34b6:	f018 fc47 	bl	1bd48 <IperfSetState>
			break;
    34ba:	e53a      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
        txData += chunk;
    34bc:	44a9      	add	r9, r5
    34be:	fa1f f989 	uxth.w	r9, r9
        if (  TCPIP_UDP_ArrayPut(pIState->udpSock, (uint8_t *) g_bfr, chunk) != chunk )
    34c2:	462a      	mov	r2, r5
    34c4:	4639      	mov	r1, r7
    34c6:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    34ca:	f019 fa2e 	bl	1c92a <TCPIP_UDP_ArrayPut>
       if(TCPIP_UDP_Flush(pIState->udpSock) == 0)
    34ce:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    34d2:	f00a fcf3 	bl	debc <TCPIP_UDP_Flush>
    34d6:	2800      	cmp	r0, #0
    34d8:	d1ca      	bne.n	3470 <TCPIP_IPERF_Task+0xcb0>
           TCPIP_UDP_TxOffsetSet(pIState->udpSock, 0, 0);
    34da:	2200      	movs	r2, #0
    34dc:	4611      	mov	r1, r2
    34de:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    34e2:	f01a fc14 	bl	1dd0e <TCPIP_UDP_TxOffsetSet>
    34e6:	e524      	b.n	2f32 <TCPIP_IPERF_Task+0x772>
}
    34e8:	b01b      	add	sp, #108	; 0x6c
    34ea:	ecbd 8b02 	vpop	{d8}
    34ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    34f2:	bf00      	nop

Disassembly of section .dinit%190:

000034f4 <.dinit>:
    34f4:	2000e3b0 	.word	0x2000e3b0
    34f8:	0000001c 	.word	0x0000001c
    34fc:	00000000 	.word	0x00000000
    3500:	2000e018 	.word	0x2000e018
    3504:	00000068 	.word	0x00000068
    3508:	00000000 	.word	0x00000000
    350c:	2000df14 	.word	0x2000df14
    3510:	00000004 	.word	0x00000004
    3514:	00000000 	.word	0x00000000
    3518:	2000dab8 	.word	0x2000dab8
    351c:	000000f8 	.word	0x000000f8
    3520:	00000001 	.word	0x00000001
    3524:	0001ba3c 	.word	0x0001ba3c
	...
    361c:	2000e38f 	.word	0x2000e38f
    3620:	00000001 	.word	0x00000001
    3624:	00000001 	.word	0x00000001
    3628:	000000ff 	.word	0x000000ff
    362c:	2000e578 	.word	0x2000e578
    3630:	00000004 	.word	0x00000004
    3634:	00000000 	.word	0x00000000
    3638:	2000df18 	.word	0x2000df18
    363c:	00000080 	.word	0x00000080
    3640:	00000000 	.word	0x00000000
    3644:	2000e714 	.word	0x2000e714
    3648:	00000002 	.word	0x00000002
    364c:	00000001 	.word	0x00000001
    3650:	00000054 	.word	0x00000054
    3654:	2000ddf0 	.word	0x2000ddf0
    3658:	00000094 	.word	0x00000094
    365c:	00000000 	.word	0x00000000
    3660:	2000e3cc 	.word	0x2000e3cc
    3664:	00000018 	.word	0x00000018
    3668:	00000000 	.word	0x00000000
    366c:	2000e57c 	.word	0x2000e57c
    3670:	00000004 	.word	0x00000004
    3674:	00000000 	.word	0x00000000
    3678:	2000e580 	.word	0x2000e580
    367c:	00000004 	.word	0x00000004
    3680:	00000000 	.word	0x00000000
    3684:	2000e584 	.word	0x2000e584
    3688:	00000004 	.word	0x00000004
    368c:	00000000 	.word	0x00000000
    3690:	2000e588 	.word	0x2000e588
    3694:	00000004 	.word	0x00000004
    3698:	00000000 	.word	0x00000000
    369c:	2000e414 	.word	0x2000e414
    36a0:	00000014 	.word	0x00000014
    36a4:	00000000 	.word	0x00000000
    36a8:	2000e58c 	.word	0x2000e58c
    36ac:	00000004 	.word	0x00000004
    36b0:	00000000 	.word	0x00000000
    36b4:	2000e590 	.word	0x2000e590
    36b8:	00000004 	.word	0x00000004
    36bc:	00000000 	.word	0x00000000
    36c0:	2000e594 	.word	0x2000e594
    36c4:	00000004 	.word	0x00000004
    36c8:	00000000 	.word	0x00000000
    36cc:	2000e598 	.word	0x2000e598
    36d0:	00000004 	.word	0x00000004
    36d4:	00000000 	.word	0x00000000
    36d8:	2000e516 	.word	0x2000e516
    36dc:	00000002 	.word	0x00000002
    36e0:	00000000 	.word	0x00000000
    36e4:	2000e712 	.word	0x2000e712
    36e8:	00000002 	.word	0x00000002
    36ec:	00000000 	.word	0x00000000
    36f0:	2000e59c 	.word	0x2000e59c
    36f4:	00000004 	.word	0x00000004
    36f8:	00000000 	.word	0x00000000
    36fc:	2000e5a0 	.word	0x2000e5a0
    3700:	00000004 	.word	0x00000004
    3704:	00000000 	.word	0x00000000
    3708:	2000e5a4 	.word	0x2000e5a4
    370c:	00000004 	.word	0x00000004
    3710:	00000000 	.word	0x00000000
    3714:	2000e5a8 	.word	0x2000e5a8
    3718:	00000004 	.word	0x00000004
    371c:	00000000 	.word	0x00000000
    3720:	2000e5ac 	.word	0x2000e5ac
    3724:	00000004 	.word	0x00000004
    3728:	00000000 	.word	0x00000000
    372c:	2000e1a4 	.word	0x2000e1a4
    3730:	0000004c 	.word	0x0000004c
    3734:	00000000 	.word	0x00000000
    3738:	2000e570 	.word	0x2000e570
    373c:	00000006 	.word	0x00000006
    3740:	00000001 	.word	0x00000001
    3744:	ffffffff 	.word	0xffffffff
    3748:	0000ffff 	.word	0x0000ffff
    374c:	2000e3e4 	.word	0x2000e3e4
    3750:	00000018 	.word	0x00000018
    3754:	00000000 	.word	0x00000000
    3758:	2000e5b0 	.word	0x2000e5b0
    375c:	00000004 	.word	0x00000004
    3760:	00000000 	.word	0x00000000
    3764:	2000e5b4 	.word	0x2000e5b4
    3768:	00000004 	.word	0x00000004
    376c:	00000000 	.word	0x00000000
    3770:	2000e5b8 	.word	0x2000e5b8
    3774:	00000004 	.word	0x00000004
    3778:	00000000 	.word	0x00000000
    377c:	2000e370 	.word	0x2000e370
    3780:	0000001f 	.word	0x0000001f
    3784:	00000000 	.word	0x00000000
    3788:	2000e5bc 	.word	0x2000e5bc
    378c:	00000004 	.word	0x00000004
    3790:	00000000 	.word	0x00000000
    3794:	2000e5c0 	.word	0x2000e5c0
    3798:	00000004 	.word	0x00000004
    379c:	00000000 	.word	0x00000000
    37a0:	2000e716 	.word	0x2000e716
    37a4:	00000002 	.word	0x00000002
    37a8:	00000000 	.word	0x00000000
    37ac:	2000e5c4 	.word	0x2000e5c4
    37b0:	00000004 	.word	0x00000004
    37b4:	00000000 	.word	0x00000000
    37b8:	2000ca04 	.word	0x2000ca04
    37bc:	000007d0 	.word	0x000007d0
    37c0:	00000000 	.word	0x00000000
    37c4:	2000e5c8 	.word	0x2000e5c8
    37c8:	00000004 	.word	0x00000004
    37cc:	00000000 	.word	0x00000000
    37d0:	2000e5cc 	.word	0x2000e5cc
    37d4:	00000004 	.word	0x00000004
    37d8:	00000000 	.word	0x00000000
    37dc:	2000e5d0 	.word	0x2000e5d0
    37e0:	00000004 	.word	0x00000004
    37e4:	00000000 	.word	0x00000000
    37e8:	2000e5d4 	.word	0x2000e5d4
    37ec:	00000004 	.word	0x00000004
    37f0:	00000000 	.word	0x00000000
    37f4:	2000e718 	.word	0x2000e718
    37f8:	00000002 	.word	0x00000002
    37fc:	00000000 	.word	0x00000000
    3800:	2000e5d8 	.word	0x2000e5d8
    3804:	00000004 	.word	0x00000004
    3808:	00000000 	.word	0x00000000
    380c:	2000e5dc 	.word	0x2000e5dc
    3810:	00000004 	.word	0x00000004
    3814:	00000000 	.word	0x00000000
    3818:	2000e504 	.word	0x2000e504
    381c:	00000011 	.word	0x00000011
    3820:	00000000 	.word	0x00000000
    3824:	2000e390 	.word	0x2000e390
    3828:	0000001f 	.word	0x0000001f
    382c:	00000000 	.word	0x00000000
    3830:	2000e5e0 	.word	0x2000e5e0
    3834:	00000004 	.word	0x00000004
    3838:	00000000 	.word	0x00000000
    383c:	2000e5e4 	.word	0x2000e5e4
    3840:	00000004 	.word	0x00000004
    3844:	00000000 	.word	0x00000000
    3848:	2000e5e8 	.word	0x2000e5e8
    384c:	00000004 	.word	0x00000004
    3850:	00000000 	.word	0x00000000
    3854:	2000e5ec 	.word	0x2000e5ec
    3858:	00000004 	.word	0x00000004
    385c:	00000000 	.word	0x00000000
    3860:	2000e3af 	.word	0x2000e3af
    3864:	00000001 	.word	0x00000001
    3868:	00000000 	.word	0x00000000
    386c:	2000e515 	.word	0x2000e515
    3870:	00000001 	.word	0x00000001
    3874:	00000001 	.word	0x00000001
    3878:	00000001 	.word	0x00000001
    387c:	2000e5f0 	.word	0x2000e5f0
    3880:	00000004 	.word	0x00000004
    3884:	00000001 	.word	0x00000001
    3888:	00000064 	.word	0x00000064
    388c:	2000dbb0 	.word	0x2000dbb0
    3890:	000000d8 	.word	0x000000d8
    3894:	00000000 	.word	0x00000000
    3898:	2000e268 	.word	0x2000e268
    389c:	00000034 	.word	0x00000034
    38a0:	00000000 	.word	0x00000000
    38a4:	2000e5f4 	.word	0x2000e5f4
    38a8:	00000004 	.word	0x00000004
    38ac:	00000000 	.word	0x00000000
    38b0:	2000e711 	.word	0x2000e711
    38b4:	00000001 	.word	0x00000001
    38b8:	00000000 	.word	0x00000000
    38bc:	2000e5f8 	.word	0x2000e5f8
    38c0:	00000004 	.word	0x00000004
    38c4:	00000000 	.word	0x00000000
    38c8:	2000e5fc 	.word	0x2000e5fc
    38cc:	00000004 	.word	0x00000004
    38d0:	00000000 	.word	0x00000000
    38d4:	2000e600 	.word	0x2000e600
    38d8:	00000004 	.word	0x00000004
    38dc:	00000000 	.word	0x00000000
    38e0:	2000e604 	.word	0x2000e604
    38e4:	00000004 	.word	0x00000004
    38e8:	00000000 	.word	0x00000000
    38ec:	2000e528 	.word	0x2000e528
    38f0:	0000000c 	.word	0x0000000c
    38f4:	00000000 	.word	0x00000000
    38f8:	2000e428 	.word	0x2000e428
    38fc:	00000014 	.word	0x00000014
    3900:	00000000 	.word	0x00000000
    3904:	2000e728 	.word	0x2000e728
    3908:	00000001 	.word	0x00000001
    390c:	00000000 	.word	0x00000000
    3910:	2000e71a 	.word	0x2000e71a
    3914:	00000002 	.word	0x00000002
    3918:	00000000 	.word	0x00000000
    391c:	2000e71c 	.word	0x2000e71c
    3920:	00000002 	.word	0x00000002
    3924:	00000000 	.word	0x00000000
    3928:	2000e608 	.word	0x2000e608
    392c:	00000004 	.word	0x00000004
    3930:	00000000 	.word	0x00000000
    3934:	2000e43c 	.word	0x2000e43c
    3938:	00000014 	.word	0x00000014
    393c:	00000000 	.word	0x00000000
    3940:	2000e60c 	.word	0x2000e60c
    3944:	00000004 	.word	0x00000004
    3948:	00000000 	.word	0x00000000
    394c:	2000e610 	.word	0x2000e610
    3950:	00000004 	.word	0x00000004
    3954:	00000000 	.word	0x00000000
    3958:	2000e71e 	.word	0x2000e71e
    395c:	00000002 	.word	0x00000002
    3960:	00000000 	.word	0x00000000
    3964:	2000e720 	.word	0x2000e720
    3968:	00000002 	.word	0x00000002
    396c:	00000000 	.word	0x00000000
    3970:	2000e614 	.word	0x2000e614
    3974:	00000004 	.word	0x00000004
    3978:	00000000 	.word	0x00000000
    397c:	2000e618 	.word	0x2000e618
    3980:	00000004 	.word	0x00000004
    3984:	00000000 	.word	0x00000000
    3988:	2000e61c 	.word	0x2000e61c
    398c:	00000004 	.word	0x00000004
    3990:	00000000 	.word	0x00000000
    3994:	2000e450 	.word	0x2000e450
    3998:	00000014 	.word	0x00000014
    399c:	00000000 	.word	0x00000000
    39a0:	2000e620 	.word	0x2000e620
    39a4:	00000004 	.word	0x00000004
    39a8:	00000000 	.word	0x00000000
    39ac:	2000e722 	.word	0x2000e722
    39b0:	00000002 	.word	0x00000002
    39b4:	00000000 	.word	0x00000000
    39b8:	2000e624 	.word	0x2000e624
    39bc:	00000004 	.word	0x00000004
    39c0:	00000000 	.word	0x00000000
    39c4:	2000e628 	.word	0x2000e628
    39c8:	00000004 	.word	0x00000004
    39cc:	00000000 	.word	0x00000000
    39d0:	2000e2c8 	.word	0x2000e2c8
    39d4:	00000028 	.word	0x00000028
    39d8:	00000000 	.word	0x00000000
    39dc:	2000e62c 	.word	0x2000e62c
    39e0:	00000004 	.word	0x00000004
    39e4:	00000000 	.word	0x00000000
    39e8:	2000de84 	.word	0x2000de84
    39ec:	00000090 	.word	0x00000090
    39f0:	00000000 	.word	0x00000000
    39f4:	2000d1d4 	.word	0x2000d1d4
    39f8:	00000270 	.word	0x00000270
    39fc:	00000000 	.word	0x00000000
    3a00:	2000e630 	.word	0x2000e630
    3a04:	00000004 	.word	0x00000004
    3a08:	00000000 	.word	0x00000000
    3a0c:	2000e634 	.word	0x2000e634
    3a10:	00000004 	.word	0x00000004
    3a14:	00000000 	.word	0x00000000
    3a18:	2000e638 	.word	0x2000e638
    3a1c:	00000004 	.word	0x00000004
    3a20:	00000000 	.word	0x00000000
    3a24:	2000e63c 	.word	0x2000e63c
    3a28:	00000004 	.word	0x00000004
    3a2c:	00000000 	.word	0x00000000
    3a30:	2000e640 	.word	0x2000e640
    3a34:	00000004 	.word	0x00000004
    3a38:	00000000 	.word	0x00000000
    3a3c:	2000e644 	.word	0x2000e644
    3a40:	00000004 	.word	0x00000004
    3a44:	00000000 	.word	0x00000000
    3a48:	2000e648 	.word	0x2000e648
    3a4c:	00000004 	.word	0x00000004
    3a50:	00000000 	.word	0x00000000
    3a54:	2000e518 	.word	0x2000e518
    3a58:	00000010 	.word	0x00000010
    3a5c:	00000000 	.word	0x00000000
    3a60:	2000e3fc 	.word	0x2000e3fc
    3a64:	00000018 	.word	0x00000018
    3a68:	00000000 	.word	0x00000000
    3a6c:	2000e2f0 	.word	0x2000e2f0
    3a70:	00000020 	.word	0x00000020
    3a74:	00000000 	.word	0x00000000
    3a78:	2000e64c 	.word	0x2000e64c
    3a7c:	00000004 	.word	0x00000004
    3a80:	00000000 	.word	0x00000000
    3a84:	2000e729 	.word	0x2000e729
    3a88:	00000001 	.word	0x00000001
    3a8c:	00000000 	.word	0x00000000
    3a90:	2000e650 	.word	0x2000e650
    3a94:	00000004 	.word	0x00000004
    3a98:	00000000 	.word	0x00000000
    3a9c:	2000e654 	.word	0x2000e654
    3aa0:	00000004 	.word	0x00000004
    3aa4:	00000001 	.word	0x00000001
    3aa8:	ffffffff 	.word	0xffffffff
    3aac:	2000e658 	.word	0x2000e658
    3ab0:	00000004 	.word	0x00000004
    3ab4:	00000000 	.word	0x00000000
    3ab8:	2000e65c 	.word	0x2000e65c
    3abc:	00000004 	.word	0x00000004
    3ac0:	00000000 	.word	0x00000000
    3ac4:	2000e660 	.word	0x2000e660
    3ac8:	00000004 	.word	0x00000004
    3acc:	00000000 	.word	0x00000000
    3ad0:	2000e664 	.word	0x2000e664
    3ad4:	00000004 	.word	0x00000004
    3ad8:	00000000 	.word	0x00000000
    3adc:	2000e724 	.word	0x2000e724
    3ae0:	00000002 	.word	0x00000002
    3ae4:	00000000 	.word	0x00000000
    3ae8:	2000e668 	.word	0x2000e668
    3aec:	00000004 	.word	0x00000004
    3af0:	00000000 	.word	0x00000000
    3af4:	2000e66c 	.word	0x2000e66c
    3af8:	00000004 	.word	0x00000004
    3afc:	00000000 	.word	0x00000000
    3b00:	2000e670 	.word	0x2000e670
    3b04:	00000004 	.word	0x00000004
    3b08:	00000000 	.word	0x00000000
    3b0c:	2000e72a 	.word	0x2000e72a
    3b10:	00000001 	.word	0x00000001
    3b14:	00000000 	.word	0x00000000
    3b18:	2000e29c 	.word	0x2000e29c
    3b1c:	0000002c 	.word	0x0000002c
    3b20:	00000000 	.word	0x00000000
    3b24:	2000a004 	.word	0x2000a004
    3b28:	00001000 	.word	0x00001000
    3b2c:	00000000 	.word	0x00000000
    3b30:	2000b004 	.word	0x2000b004
    3b34:	00001000 	.word	0x00001000
    3b38:	00000000 	.word	0x00000000
    3b3c:	2000e1f0 	.word	0x2000e1f0
    3b40:	00000040 	.word	0x00000040
    3b44:	00000000 	.word	0x00000000
    3b48:	2000e558 	.word	0x2000e558
    3b4c:	00000008 	.word	0x00000008
    3b50:	00000000 	.word	0x00000000
    3b54:	2000e674 	.word	0x2000e674
    3b58:	00000004 	.word	0x00000004
    3b5c:	00000000 	.word	0x00000000
    3b60:	2000df98 	.word	0x2000df98
    3b64:	00000080 	.word	0x00000080
    3b68:	00000000 	.word	0x00000000
    3b6c:	2000e560 	.word	0x2000e560
    3b70:	00000008 	.word	0x00000008
    3b74:	00000000 	.word	0x00000000
    3b78:	2000c004 	.word	0x2000c004
    3b7c:	00000a00 	.word	0x00000a00
    3b80:	00000000 	.word	0x00000000
    3b84:	2000e678 	.word	0x2000e678
    3b88:	00000004 	.word	0x00000004
    3b8c:	00000000 	.word	0x00000000
    3b90:	2000e534 	.word	0x2000e534
    3b94:	0000000c 	.word	0x0000000c
    3b98:	00000000 	.word	0x00000000
    3b9c:	2000e540 	.word	0x2000e540
    3ba0:	0000000c 	.word	0x0000000c
    3ba4:	00000000 	.word	0x00000000
    3ba8:	2000dc88 	.word	0x2000dc88
    3bac:	000000c8 	.word	0x000000c8
    3bb0:	00000000 	.word	0x00000000
    3bb4:	2000e67c 	.word	0x2000e67c
    3bb8:	00000004 	.word	0x00000004
    3bbc:	00000000 	.word	0x00000000
    3bc0:	2000e72b 	.word	0x2000e72b
    3bc4:	00000001 	.word	0x00000001
    3bc8:	00000000 	.word	0x00000000
    3bcc:	2000e72c 	.word	0x2000e72c
    3bd0:	00000001 	.word	0x00000001
    3bd4:	00000000 	.word	0x00000000
    3bd8:	2000e680 	.word	0x2000e680
    3bdc:	00000004 	.word	0x00000004
    3be0:	00000000 	.word	0x00000000
    3be4:	2000e230 	.word	0x2000e230
    3be8:	00000038 	.word	0x00000038
    3bec:	00000000 	.word	0x00000000
    3bf0:	2000dd50 	.word	0x2000dd50
    3bf4:	000000a0 	.word	0x000000a0
    3bf8:	00000000 	.word	0x00000000
    3bfc:	2000e726 	.word	0x2000e726
    3c00:	00000002 	.word	0x00000002
    3c04:	00000001 	.word	0x00000001
    3c08:	00000001 	.word	0x00000001
    3c0c:	2000e684 	.word	0x2000e684
    3c10:	00000004 	.word	0x00000004
    3c14:	00000000 	.word	0x00000000
    3c18:	2000e688 	.word	0x2000e688
    3c1c:	00000004 	.word	0x00000004
    3c20:	00000000 	.word	0x00000000
    3c24:	2000e68c 	.word	0x2000e68c
    3c28:	00000004 	.word	0x00000004
    3c2c:	00000000 	.word	0x00000000
    3c30:	2000d9b0 	.word	0x2000d9b0
    3c34:	00000108 	.word	0x00000108
    3c38:	00000000 	.word	0x00000000
    3c3c:	2000e690 	.word	0x2000e690
    3c40:	00000004 	.word	0x00000004
    3c44:	00000000 	.word	0x00000000
    3c48:	2000e694 	.word	0x2000e694
    3c4c:	00000004 	.word	0x00000004
    3c50:	00000000 	.word	0x00000000
    3c54:	2000e464 	.word	0x2000e464
    3c58:	00000014 	.word	0x00000014
    3c5c:	00000000 	.word	0x00000000
    3c60:	2000e478 	.word	0x2000e478
    3c64:	00000014 	.word	0x00000014
    3c68:	00000001 	.word	0x00000001
    3c6c:	00000101 	.word	0x00000101
    3c70:	00021b5d 	.word	0x00021b5d
    3c74:	00021b4d 	.word	0x00021b4d
    3c78:	00021b6d 	.word	0x00021b6d
    3c7c:	00009952 	.word	0x00009952
    3c80:	2000e698 	.word	0x2000e698
    3c84:	00000004 	.word	0x00000004
    3c88:	00000001 	.word	0x00000001
    3c8c:	aaaaaaaa 	.word	0xaaaaaaaa
    3c90:	2000e69c 	.word	0x2000e69c
    3c94:	00000004 	.word	0x00000004
    3c98:	00000000 	.word	0x00000000
    3c9c:	20000004 	.word	0x20000004
    3ca0:	0000a000 	.word	0x0000a000
    3ca4:	00000000 	.word	0x00000000
    3ca8:	2000e6a0 	.word	0x2000e6a0
    3cac:	00000004 	.word	0x00000004
    3cb0:	00000000 	.word	0x00000000
    3cb4:	2000e6a4 	.word	0x2000e6a4
    3cb8:	00000004 	.word	0x00000004
    3cbc:	00000000 	.word	0x00000000
    3cc0:	2000e6a8 	.word	0x2000e6a8
    3cc4:	00000004 	.word	0x00000004
    3cc8:	00000000 	.word	0x00000000
    3ccc:	2000e6ac 	.word	0x2000e6ac
    3cd0:	00000004 	.word	0x00000004
    3cd4:	00000000 	.word	0x00000000
    3cd8:	2000e080 	.word	0x2000e080
    3cdc:	00000064 	.word	0x00000064
    3ce0:	00000000 	.word	0x00000000
    3ce4:	2000e6b0 	.word	0x2000e6b0
    3ce8:	00000004 	.word	0x00000004
    3cec:	00000000 	.word	0x00000000
    3cf0:	2000e6b4 	.word	0x2000e6b4
    3cf4:	00000004 	.word	0x00000004
    3cf8:	00000000 	.word	0x00000000
    3cfc:	2000e6b8 	.word	0x2000e6b8
    3d00:	00000004 	.word	0x00000004
    3d04:	00000000 	.word	0x00000000
    3d08:	2000e6bc 	.word	0x2000e6bc
    3d0c:	00000004 	.word	0x00000004
    3d10:	00000000 	.word	0x00000000
    3d14:	2000e6c0 	.word	0x2000e6c0
    3d18:	00000004 	.word	0x00000004
    3d1c:	00000000 	.word	0x00000000
    3d20:	2000e48c 	.word	0x2000e48c
    3d24:	00000014 	.word	0x00000014
    3d28:	00000000 	.word	0x00000000
    3d2c:	2000e4a0 	.word	0x2000e4a0
    3d30:	00000014 	.word	0x00000014
    3d34:	00000000 	.word	0x00000000
    3d38:	2000e6c4 	.word	0x2000e6c4
    3d3c:	00000004 	.word	0x00000004
    3d40:	00000000 	.word	0x00000000
    3d44:	2000e6c8 	.word	0x2000e6c8
    3d48:	00000004 	.word	0x00000004
    3d4c:	00000000 	.word	0x00000000
    3d50:	2000e6cc 	.word	0x2000e6cc
    3d54:	00000004 	.word	0x00000004
    3d58:	00000000 	.word	0x00000000
    3d5c:	2000e6d0 	.word	0x2000e6d0
    3d60:	00000004 	.word	0x00000004
    3d64:	00000000 	.word	0x00000000
    3d68:	2000e4b4 	.word	0x2000e4b4
    3d6c:	00000014 	.word	0x00000014
    3d70:	00000000 	.word	0x00000000
    3d74:	2000e6d4 	.word	0x2000e6d4
    3d78:	00000004 	.word	0x00000004
    3d7c:	00000000 	.word	0x00000000
    3d80:	2000e4c8 	.word	0x2000e4c8
    3d84:	00000014 	.word	0x00000014
    3d88:	00000000 	.word	0x00000000
    3d8c:	2000e4dc 	.word	0x2000e4dc
    3d90:	00000014 	.word	0x00000014
    3d94:	00000000 	.word	0x00000000
    3d98:	2000e6d8 	.word	0x2000e6d8
    3d9c:	00000004 	.word	0x00000004
    3da0:	00000000 	.word	0x00000000
    3da4:	2000e6dc 	.word	0x2000e6dc
    3da8:	00000004 	.word	0x00000004
    3dac:	00000000 	.word	0x00000000
    3db0:	2000e6e0 	.word	0x2000e6e0
    3db4:	00000004 	.word	0x00000004
    3db8:	00000000 	.word	0x00000000
    3dbc:	2000d444 	.word	0x2000d444
    3dc0:	00000200 	.word	0x00000200
    3dc4:	00000000 	.word	0x00000000
    3dc8:	2000e54c 	.word	0x2000e54c
    3dcc:	0000000c 	.word	0x0000000c
    3dd0:	00000001 	.word	0x00000001
    3dd4:	00000000 	.word	0x00000000
    3dd8:	0000c700 	.word	0x0000c700
    3ddc:	7d200706 	.word	0x7d200706
    3de0:	2000e0e4 	.word	0x2000e0e4
    3de4:	00000060 	.word	0x00000060
    3de8:	00000000 	.word	0x00000000
    3dec:	2000e6e4 	.word	0x2000e6e4
    3df0:	00000004 	.word	0x00000004
    3df4:	00000000 	.word	0x00000000
    3df8:	2000e6e8 	.word	0x2000e6e8
    3dfc:	00000004 	.word	0x00000004
    3e00:	00000000 	.word	0x00000000
    3e04:	2000e568 	.word	0x2000e568
    3e08:	00000008 	.word	0x00000008
    3e0c:	00000001 	.word	0x00000001
    3e10:	ffffffff 	.word	0xffffffff
    3e14:	ffffffff 	.word	0xffffffff
    3e18:	2000e4f0 	.word	0x2000e4f0
    3e1c:	00000014 	.word	0x00000014
    3e20:	00000000 	.word	0x00000000
    3e24:	2000d644 	.word	0x2000d644
    3e28:	00000200 	.word	0x00000200
    3e2c:	00000000 	.word	0x00000000
    3e30:	2000e6ec 	.word	0x2000e6ec
    3e34:	00000004 	.word	0x00000004
    3e38:	00000000 	.word	0x00000000
    3e3c:	2000e6f0 	.word	0x2000e6f0
    3e40:	00000004 	.word	0x00000004
    3e44:	00000000 	.word	0x00000000
    3e48:	2000e710 	.word	0x2000e710
    3e4c:	00000001 	.word	0x00000001
    3e50:	00000000 	.word	0x00000000
    3e54:	2000e576 	.word	0x2000e576
    3e58:	00000002 	.word	0x00000002
    3e5c:	00000000 	.word	0x00000000
    3e60:	2000e6f4 	.word	0x2000e6f4
    3e64:	00000004 	.word	0x00000004
    3e68:	00000000 	.word	0x00000000
    3e6c:	2000e6f8 	.word	0x2000e6f8
    3e70:	00000004 	.word	0x00000004
    3e74:	00000000 	.word	0x00000000
    3e78:	2000e6fc 	.word	0x2000e6fc
    3e7c:	00000004 	.word	0x00000004
    3e80:	00000000 	.word	0x00000000
    3e84:	2000e700 	.word	0x2000e700
    3e88:	00000004 	.word	0x00000004
    3e8c:	00000001 	.word	0x00000001
    3e90:	2000e144 	.word	0x2000e144
    3e94:	2000e144 	.word	0x2000e144
    3e98:	00000060 	.word	0x00000060
    3e9c:	00000001 	.word	0x00000001
    3ea0:	00000000 	.word	0x00000000
    3ea4:	2000e330 	.word	0x2000e330
    3ea8:	2000e350 	.word	0x2000e350
    3eac:	2000e310 	.word	0x2000e310
	...
    3f00:	2000e704 	.word	0x2000e704
    3f04:	00000004 	.word	0x00000004
    3f08:	00000000 	.word	0x00000000
    3f0c:	2000e708 	.word	0x2000e708
    3f10:	00000004 	.word	0x00000004
    3f14:	00000000 	.word	0x00000000
    3f18:	2000e310 	.word	0x2000e310
    3f1c:	00000020 	.word	0x00000020
    3f20:	00000000 	.word	0x00000000
    3f24:	2000e330 	.word	0x2000e330
    3f28:	00000020 	.word	0x00000020
    3f2c:	00000000 	.word	0x00000000
    3f30:	2000e350 	.word	0x2000e350
    3f34:	00000020 	.word	0x00000020
    3f38:	00000000 	.word	0x00000000
    3f3c:	2000d844 	.word	0x2000d844
    3f40:	0000016c 	.word	0x0000016c
    3f44:	00000001 	.word	0x00000001
    3f48:	00000043 	.word	0x00000043
	...
    3f68:	00000043 	.word	0x00000043
	...
    3f88:	00000043 	.word	0x00000043
	...
    3fa8:	00000043 	.word	0x00000043
	...
    3fc8:	00000043 	.word	0x00000043
	...
    3fe8:	00000043 	.word	0x00000043
	...
    4008:	00000043 	.word	0x00000043
	...
    4028:	00021271 	.word	0x00021271
    402c:	00020569 	.word	0x00020569
    4030:	00000000 	.word	0x00000000
    4034:	00013c60 	.word	0x00013c60
    4038:	00021fc1 	.word	0x00021fc1
    403c:	00021fc0 	.word	0x00021fc0
    4040:	00021fc0 	.word	0x00021fc0
    4044:	00021fc0 	.word	0x00021fc0
    4048:	00021fc0 	.word	0x00021fc0
    404c:	00021fc0 	.word	0x00021fc0
    4050:	00021fc0 	.word	0x00021fc0
    4054:	00021fc0 	.word	0x00021fc0
    4058:	00021fc0 	.word	0x00021fc0
    405c:	00021fc0 	.word	0x00021fc0
    4060:	ffffffff 	.word	0xffffffff
    4064:	ffffffff 	.word	0xffffffff
    4068:	ffffffff 	.word	0xffffffff
    406c:	0000ffff 	.word	0x0000ffff
    4070:	53410001 	.word	0x53410001
    4074:	00494943 	.word	0x00494943
	...
    4090:	53410000 	.word	0x53410000
    4094:	00494943 	.word	0x00494943
	...
    40b4:	20000000 	.word	0x20000000
    40b8:	00000004 	.word	0x00000004
    40bc:	00000000 	.word	0x00000000
    40c0:	2000e70c 	.word	0x2000e70c
    40c4:	00000004 	.word	0x00000004
	...

Disassembly of section .text._dtoa_r%191:

000040d8 <_dtoa_r>:
    40d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    40dc:	ec55 4b10 	vmov	r4, r5, d0
    40e0:	b099      	sub	sp, #100	; 0x64
    40e2:	6a47      	ldr	r7, [r0, #36]	; 0x24
    40e4:	9108      	str	r1, [sp, #32]
    40e6:	4683      	mov	fp, r0
    40e8:	920d      	str	r2, [sp, #52]	; 0x34
    40ea:	9314      	str	r3, [sp, #80]	; 0x50
    40ec:	9e22      	ldr	r6, [sp, #136]	; 0x88
    40ee:	e9cd 4504 	strd	r4, r5, [sp, #16]
    40f2:	b947      	cbnz	r7, 4106 <_dtoa_r+0x2e>
    40f4:	2010      	movs	r0, #16
    40f6:	f01d fd31 	bl	21b5c <malloc>
    40fa:	e9c0 7701 	strd	r7, r7, [r0, #4]
    40fe:	f8cb 0024 	str.w	r0, [fp, #36]	; 0x24
    4102:	6007      	str	r7, [r0, #0]
    4104:	60c7      	str	r7, [r0, #12]
    4106:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
    410a:	6819      	ldr	r1, [r3, #0]
    410c:	b159      	cbz	r1, 4126 <_dtoa_r+0x4e>
    410e:	685a      	ldr	r2, [r3, #4]
    4110:	604a      	str	r2, [r1, #4]
    4112:	2301      	movs	r3, #1
    4114:	4093      	lsls	r3, r2
    4116:	608b      	str	r3, [r1, #8]
    4118:	4658      	mov	r0, fp
    411a:	f01b fa9c 	bl	1f656 <_Bfree>
    411e:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
    4122:	2200      	movs	r2, #0
    4124:	601a      	str	r2, [r3, #0]
    4126:	2d00      	cmp	r5, #0
    4128:	bfbf      	itttt	lt
    412a:	2301      	movlt	r3, #1
    412c:	6033      	strlt	r3, [r6, #0]
    412e:	f025 4300 	biclt.w	r3, r5, #2147483648	; 0x80000000
    4132:	9305      	strlt	r3, [sp, #20]
    4134:	bfa4      	itt	ge
    4136:	2300      	movge	r3, #0
    4138:	6033      	strge	r3, [r6, #0]
    413a:	9c05      	ldr	r4, [sp, #20]
    413c:	4bb2      	ldr	r3, [pc, #712]	; (4408 <_dtoa_r+0x330>)
    413e:	43a3      	bics	r3, r4
    4140:	d11a      	bne.n	4178 <_dtoa_r+0xa0>
    4142:	9a14      	ldr	r2, [sp, #80]	; 0x50
    4144:	f242 730f 	movw	r3, #9999	; 0x270f
    4148:	6013      	str	r3, [r2, #0]
    414a:	9b04      	ldr	r3, [sp, #16]
    414c:	f3c4 0413 	ubfx	r4, r4, #0, #20
    4150:	4323      	orrs	r3, r4
    4152:	f000 854f 	beq.w	4bf4 <_dtoa_r+0xb1c>
    4156:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    4158:	b953      	cbnz	r3, 4170 <_dtoa_r+0x98>
    415a:	4bac      	ldr	r3, [pc, #688]	; (440c <_dtoa_r+0x334>)
    415c:	e023      	b.n	41a6 <_dtoa_r+0xce>
    415e:	4bac      	ldr	r3, [pc, #688]	; (4410 <_dtoa_r+0x338>)
    4160:	9301      	str	r3, [sp, #4]
    4162:	3308      	adds	r3, #8
    4164:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    4166:	6013      	str	r3, [r2, #0]
    4168:	9801      	ldr	r0, [sp, #4]
    416a:	b019      	add	sp, #100	; 0x64
    416c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4170:	4ba6      	ldr	r3, [pc, #664]	; (440c <_dtoa_r+0x334>)
    4172:	9301      	str	r3, [sp, #4]
    4174:	3303      	adds	r3, #3
    4176:	e7f5      	b.n	4164 <_dtoa_r+0x8c>
    4178:	ed9d 7b04 	vldr	d7, [sp, #16]
    417c:	2200      	movs	r2, #0
    417e:	2300      	movs	r3, #0
    4180:	ec51 0b17 	vmov	r0, r1, d7
    4184:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
    4188:	f00f faa2 	bl	136d0 <__aeabi_dcmpeq>
    418c:	4607      	mov	r7, r0
    418e:	b160      	cbz	r0, 41aa <_dtoa_r+0xd2>
    4190:	9a14      	ldr	r2, [sp, #80]	; 0x50
    4192:	2301      	movs	r3, #1
    4194:	6013      	str	r3, [r2, #0]
    4196:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    4198:	2b00      	cmp	r3, #0
    419a:	f000 8528 	beq.w	4bee <_dtoa_r+0xb16>
    419e:	4b9d      	ldr	r3, [pc, #628]	; (4414 <_dtoa_r+0x33c>)
    41a0:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    41a2:	6013      	str	r3, [r2, #0]
    41a4:	3b01      	subs	r3, #1
    41a6:	9301      	str	r3, [sp, #4]
    41a8:	e7de      	b.n	4168 <_dtoa_r+0x90>
    41aa:	aa16      	add	r2, sp, #88	; 0x58
    41ac:	a917      	add	r1, sp, #92	; 0x5c
    41ae:	ed9d 0b0e 	vldr	d0, [sp, #56]	; 0x38
    41b2:	4658      	mov	r0, fp
    41b4:	f013 fba3 	bl	178fe <__d2b>
    41b8:	f3c4 560a 	ubfx	r6, r4, #20, #11
    41bc:	4680      	mov	r8, r0
    41be:	2e00      	cmp	r6, #0
    41c0:	d07f      	beq.n	42c2 <_dtoa_r+0x1ea>
    41c2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    41c4:	9715      	str	r7, [sp, #84]	; 0x54
    41c6:	f3c3 0313 	ubfx	r3, r3, #0, #20
    41ca:	e9dd 450e 	ldrd	r4, r5, [sp, #56]	; 0x38
    41ce:	f043 557f 	orr.w	r5, r3, #1069547520	; 0x3fc00000
    41d2:	f445 1540 	orr.w	r5, r5, #3145728	; 0x300000
    41d6:	f2a6 36ff 	subw	r6, r6, #1023	; 0x3ff
    41da:	2200      	movs	r2, #0
    41dc:	4b8e      	ldr	r3, [pc, #568]	; (4418 <_dtoa_r+0x340>)
    41de:	4620      	mov	r0, r4
    41e0:	4629      	mov	r1, r5
    41e2:	f006 fb7d 	bl	a8e0 <__aeabi_dsub>
    41e6:	a382      	add	r3, pc, #520	; (adr r3, 43f0 <_dtoa_r+0x318>)
    41e8:	e9d3 2300 	ldrd	r2, r3, [r3]
    41ec:	f005 f812 	bl	9214 <__aeabi_dmul>
    41f0:	a381      	add	r3, pc, #516	; (adr r3, 43f8 <_dtoa_r+0x320>)
    41f2:	e9d3 2300 	ldrd	r2, r3, [r3]
    41f6:	f006 fb75 	bl	a8e4 <__adddf3>
    41fa:	4604      	mov	r4, r0
    41fc:	4630      	mov	r0, r6
    41fe:	460d      	mov	r5, r1
    4200:	f006 fcbc 	bl	ab7c <__aeabi_i2d>
    4204:	a37e      	add	r3, pc, #504	; (adr r3, 4400 <_dtoa_r+0x328>)
    4206:	e9d3 2300 	ldrd	r2, r3, [r3]
    420a:	f005 f803 	bl	9214 <__aeabi_dmul>
    420e:	4602      	mov	r2, r0
    4210:	460b      	mov	r3, r1
    4212:	4620      	mov	r0, r4
    4214:	4629      	mov	r1, r5
    4216:	f006 fb65 	bl	a8e4 <__adddf3>
    421a:	4604      	mov	r4, r0
    421c:	460d      	mov	r5, r1
    421e:	f018 f945 	bl	1c4ac <__aeabi_d2iz>
    4222:	2200      	movs	r2, #0
    4224:	4682      	mov	sl, r0
    4226:	2300      	movs	r3, #0
    4228:	4620      	mov	r0, r4
    422a:	4629      	mov	r1, r5
    422c:	f00f fa5a 	bl	136e4 <__aeabi_dcmplt>
    4230:	b148      	cbz	r0, 4246 <_dtoa_r+0x16e>
    4232:	4650      	mov	r0, sl
    4234:	f006 fca2 	bl	ab7c <__aeabi_i2d>
    4238:	4622      	mov	r2, r4
    423a:	462b      	mov	r3, r5
    423c:	f00f fa48 	bl	136d0 <__aeabi_dcmpeq>
    4240:	b908      	cbnz	r0, 4246 <_dtoa_r+0x16e>
    4242:	f10a 3aff 	add.w	sl, sl, #4294967295
    4246:	f1ba 0f16 	cmp.w	sl, #22
    424a:	d859      	bhi.n	4300 <_dtoa_r+0x228>
    424c:	4b73      	ldr	r3, [pc, #460]	; (441c <_dtoa_r+0x344>)
    424e:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
    4252:	e9d3 2300 	ldrd	r2, r3, [r3]
    4256:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
    425a:	f00f fa43 	bl	136e4 <__aeabi_dcmplt>
    425e:	2800      	cmp	r0, #0
    4260:	d050      	beq.n	4304 <_dtoa_r+0x22c>
    4262:	f10a 3aff 	add.w	sl, sl, #4294967295
    4266:	2300      	movs	r3, #0
    4268:	9311      	str	r3, [sp, #68]	; 0x44
    426a:	9b16      	ldr	r3, [sp, #88]	; 0x58
    426c:	1b9e      	subs	r6, r3, r6
    426e:	1e73      	subs	r3, r6, #1
    4270:	9307      	str	r3, [sp, #28]
    4272:	bf45      	ittet	mi
    4274:	f1c6 0301 	rsbmi	r3, r6, #1
    4278:	9306      	strmi	r3, [sp, #24]
    427a:	2300      	movpl	r3, #0
    427c:	2300      	movmi	r3, #0
    427e:	bf4c      	ite	mi
    4280:	9307      	strmi	r3, [sp, #28]
    4282:	9306      	strpl	r3, [sp, #24]
    4284:	f1ba 0f00 	cmp.w	sl, #0
    4288:	db3e      	blt.n	4308 <_dtoa_r+0x230>
    428a:	9b07      	ldr	r3, [sp, #28]
    428c:	f8cd a040 	str.w	sl, [sp, #64]	; 0x40
    4290:	4453      	add	r3, sl
    4292:	9307      	str	r3, [sp, #28]
    4294:	2300      	movs	r3, #0
    4296:	9309      	str	r3, [sp, #36]	; 0x24
    4298:	9b08      	ldr	r3, [sp, #32]
    429a:	2b09      	cmp	r3, #9
    429c:	f200 808e 	bhi.w	43bc <_dtoa_r+0x2e4>
    42a0:	2b05      	cmp	r3, #5
    42a2:	bfc4      	itt	gt
    42a4:	3b04      	subgt	r3, #4
    42a6:	9308      	strgt	r3, [sp, #32]
    42a8:	9b08      	ldr	r3, [sp, #32]
    42aa:	f1a3 0302 	sub.w	r3, r3, #2
    42ae:	bfcc      	ite	gt
    42b0:	2400      	movgt	r4, #0
    42b2:	2401      	movle	r4, #1
    42b4:	2b03      	cmp	r3, #3
    42b6:	f200 808c 	bhi.w	43d2 <_dtoa_r+0x2fa>
    42ba:	e8df f003 	tbb	[pc, r3]
    42be:	712f      	.short	0x712f
    42c0:	7d6f      	.short	0x7d6f
    42c2:	e9dd 6316 	ldrd	r6, r3, [sp, #88]	; 0x58
    42c6:	441e      	add	r6, r3
    42c8:	f206 4032 	addw	r0, r6, #1074	; 0x432
    42cc:	2820      	cmp	r0, #32
    42ce:	dd11      	ble.n	42f4 <_dtoa_r+0x21c>
    42d0:	f1c0 0040 	rsb	r0, r0, #64	; 0x40
    42d4:	9b04      	ldr	r3, [sp, #16]
    42d6:	4084      	lsls	r4, r0
    42d8:	f206 4012 	addw	r0, r6, #1042	; 0x412
    42dc:	fa23 f000 	lsr.w	r0, r3, r0
    42e0:	4320      	orrs	r0, r4
    42e2:	f006 fc3b 	bl	ab5c <__aeabi_ui2d>
    42e6:	2301      	movs	r3, #1
    42e8:	4604      	mov	r4, r0
    42ea:	f1a1 75f8 	sub.w	r5, r1, #32505856	; 0x1f00000
    42ee:	3e01      	subs	r6, #1
    42f0:	9315      	str	r3, [sp, #84]	; 0x54
    42f2:	e772      	b.n	41da <_dtoa_r+0x102>
    42f4:	9b04      	ldr	r3, [sp, #16]
    42f6:	f1c0 0020 	rsb	r0, r0, #32
    42fa:	fa03 f000 	lsl.w	r0, r3, r0
    42fe:	e7f0      	b.n	42e2 <_dtoa_r+0x20a>
    4300:	2301      	movs	r3, #1
    4302:	e7b1      	b.n	4268 <_dtoa_r+0x190>
    4304:	9011      	str	r0, [sp, #68]	; 0x44
    4306:	e7b0      	b.n	426a <_dtoa_r+0x192>
    4308:	9b06      	ldr	r3, [sp, #24]
    430a:	eba3 030a 	sub.w	r3, r3, sl
    430e:	9306      	str	r3, [sp, #24]
    4310:	f1ca 0300 	rsb	r3, sl, #0
    4314:	9309      	str	r3, [sp, #36]	; 0x24
    4316:	2300      	movs	r3, #0
    4318:	9310      	str	r3, [sp, #64]	; 0x40
    431a:	e7bd      	b.n	4298 <_dtoa_r+0x1c0>
    431c:	2300      	movs	r3, #0
    431e:	930c      	str	r3, [sp, #48]	; 0x30
    4320:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    4322:	2b00      	cmp	r3, #0
    4324:	dc59      	bgt.n	43da <_dtoa_r+0x302>
    4326:	2301      	movs	r3, #1
    4328:	9302      	str	r3, [sp, #8]
    432a:	4699      	mov	r9, r3
    432c:	930d      	str	r3, [sp, #52]	; 0x34
    432e:	f8db 5024 	ldr.w	r5, [fp, #36]	; 0x24
    4332:	2200      	movs	r2, #0
    4334:	606a      	str	r2, [r5, #4]
    4336:	2204      	movs	r2, #4
    4338:	f102 0014 	add.w	r0, r2, #20
    433c:	4298      	cmp	r0, r3
    433e:	6869      	ldr	r1, [r5, #4]
    4340:	d94f      	bls.n	43e2 <_dtoa_r+0x30a>
    4342:	4658      	mov	r0, fp
    4344:	f016 fc8a 	bl	1ac5c <_Balloc>
    4348:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
    434c:	6028      	str	r0, [r5, #0]
    434e:	681b      	ldr	r3, [r3, #0]
    4350:	9301      	str	r3, [sp, #4]
    4352:	f1b9 0f0e 	cmp.w	r9, #14
    4356:	f200 80e6 	bhi.w	4526 <_dtoa_r+0x44e>
    435a:	2c00      	cmp	r4, #0
    435c:	f000 80e3 	beq.w	4526 <_dtoa_r+0x44e>
    4360:	f1ba 0f00 	cmp.w	sl, #0
    4364:	dd78      	ble.n	4458 <_dtoa_r+0x380>
    4366:	4a2d      	ldr	r2, [pc, #180]	; (441c <_dtoa_r+0x344>)
    4368:	f00a 030f 	and.w	r3, sl, #15
    436c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    4370:	ed93 7b00 	vldr	d7, [r3]
    4374:	ea4f 142a 	mov.w	r4, sl, asr #4
    4378:	06e2      	lsls	r2, r4, #27
    437a:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
    437e:	d569      	bpl.n	4454 <_dtoa_r+0x37c>
    4380:	4b27      	ldr	r3, [pc, #156]	; (4420 <_dtoa_r+0x348>)
    4382:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
    4386:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
    438a:	f005 f86d 	bl	9468 <__aeabi_ddiv>
    438e:	e9cd 0104 	strd	r0, r1, [sp, #16]
    4392:	f004 040f 	and.w	r4, r4, #15
    4396:	2603      	movs	r6, #3
    4398:	4d21      	ldr	r5, [pc, #132]	; (4420 <_dtoa_r+0x348>)
    439a:	e050      	b.n	443e <_dtoa_r+0x366>
    439c:	2301      	movs	r3, #1
    439e:	e7be      	b.n	431e <_dtoa_r+0x246>
    43a0:	2300      	movs	r3, #0
    43a2:	930c      	str	r3, [sp, #48]	; 0x30
    43a4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    43a6:	4453      	add	r3, sl
    43a8:	f103 0901 	add.w	r9, r3, #1
    43ac:	9302      	str	r3, [sp, #8]
    43ae:	464b      	mov	r3, r9
    43b0:	2b01      	cmp	r3, #1
    43b2:	bfb8      	it	lt
    43b4:	2301      	movlt	r3, #1
    43b6:	e7ba      	b.n	432e <_dtoa_r+0x256>
    43b8:	2301      	movs	r3, #1
    43ba:	e7f2      	b.n	43a2 <_dtoa_r+0x2ca>
    43bc:	2300      	movs	r3, #0
    43be:	2401      	movs	r4, #1
    43c0:	9308      	str	r3, [sp, #32]
    43c2:	940c      	str	r4, [sp, #48]	; 0x30
    43c4:	3b01      	subs	r3, #1
    43c6:	2200      	movs	r2, #0
    43c8:	9302      	str	r3, [sp, #8]
    43ca:	4699      	mov	r9, r3
    43cc:	920d      	str	r2, [sp, #52]	; 0x34
    43ce:	2312      	movs	r3, #18
    43d0:	e7ad      	b.n	432e <_dtoa_r+0x256>
    43d2:	2301      	movs	r3, #1
    43d4:	930c      	str	r3, [sp, #48]	; 0x30
    43d6:	3b02      	subs	r3, #2
    43d8:	e7f5      	b.n	43c6 <_dtoa_r+0x2ee>
    43da:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    43dc:	9302      	str	r3, [sp, #8]
    43de:	4699      	mov	r9, r3
    43e0:	e7a5      	b.n	432e <_dtoa_r+0x256>
    43e2:	3101      	adds	r1, #1
    43e4:	6069      	str	r1, [r5, #4]
    43e6:	0052      	lsls	r2, r2, #1
    43e8:	e7a6      	b.n	4338 <_dtoa_r+0x260>
    43ea:	bf00      	nop
    43ec:	f3af 8000 	nop.w
    43f0:	636f4361 	.word	0x636f4361
    43f4:	3fd287a7 	.word	0x3fd287a7
    43f8:	8b60c8b3 	.word	0x8b60c8b3
    43fc:	3fc68a28 	.word	0x3fc68a28
    4400:	509f79fb 	.word	0x509f79fb
    4404:	3fd34413 	.word	0x3fd34413
    4408:	7ff00000 	.word	0x7ff00000
    440c:	00021bd5 	.word	0x00021bd5
    4410:	00021bcc 	.word	0x00021bcc
    4414:	00021bda 	.word	0x00021bda
    4418:	3ff80000 	.word	0x3ff80000
    441c:	00015a98 	.word	0x00015a98
    4420:	000200a0 	.word	0x000200a0
    4424:	07e3      	lsls	r3, r4, #31
    4426:	d508      	bpl.n	443a <_dtoa_r+0x362>
    4428:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    442c:	e9d5 2300 	ldrd	r2, r3, [r5]
    4430:	f004 fef0 	bl	9214 <__aeabi_dmul>
    4434:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
    4438:	3601      	adds	r6, #1
    443a:	1064      	asrs	r4, r4, #1
    443c:	3508      	adds	r5, #8
    443e:	2c00      	cmp	r4, #0
    4440:	d1f0      	bne.n	4424 <_dtoa_r+0x34c>
    4442:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
    4446:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    444a:	f005 f80d 	bl	9468 <__aeabi_ddiv>
    444e:	e9cd 0104 	strd	r0, r1, [sp, #16]
    4452:	e01a      	b.n	448a <_dtoa_r+0x3b2>
    4454:	2602      	movs	r6, #2
    4456:	e79f      	b.n	4398 <_dtoa_r+0x2c0>
    4458:	f000 809f 	beq.w	459a <_dtoa_r+0x4c2>
    445c:	f1ca 0400 	rsb	r4, sl, #0
    4460:	4b9f      	ldr	r3, [pc, #636]	; (46e0 <_dtoa_r+0x608>)
    4462:	4da0      	ldr	r5, [pc, #640]	; (46e4 <_dtoa_r+0x60c>)
    4464:	f004 020f 	and.w	r2, r4, #15
    4468:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    446c:	e9d3 2300 	ldrd	r2, r3, [r3]
    4470:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
    4474:	f004 fece 	bl	9214 <__aeabi_dmul>
    4478:	e9cd 0104 	strd	r0, r1, [sp, #16]
    447c:	1124      	asrs	r4, r4, #4
    447e:	2300      	movs	r3, #0
    4480:	2602      	movs	r6, #2
    4482:	2c00      	cmp	r4, #0
    4484:	d17e      	bne.n	4584 <_dtoa_r+0x4ac>
    4486:	2b00      	cmp	r3, #0
    4488:	d1e1      	bne.n	444e <_dtoa_r+0x376>
    448a:	9b11      	ldr	r3, [sp, #68]	; 0x44
    448c:	2b00      	cmp	r3, #0
    448e:	f000 8086 	beq.w	459e <_dtoa_r+0x4c6>
    4492:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
    4496:	2200      	movs	r2, #0
    4498:	4b93      	ldr	r3, [pc, #588]	; (46e8 <_dtoa_r+0x610>)
    449a:	4620      	mov	r0, r4
    449c:	4629      	mov	r1, r5
    449e:	f00f f921 	bl	136e4 <__aeabi_dcmplt>
    44a2:	2800      	cmp	r0, #0
    44a4:	d07b      	beq.n	459e <_dtoa_r+0x4c6>
    44a6:	f1b9 0f00 	cmp.w	r9, #0
    44aa:	d078      	beq.n	459e <_dtoa_r+0x4c6>
    44ac:	9b02      	ldr	r3, [sp, #8]
    44ae:	2b00      	cmp	r3, #0
    44b0:	dd35      	ble.n	451e <_dtoa_r+0x446>
    44b2:	f10a 33ff 	add.w	r3, sl, #4294967295
    44b6:	930a      	str	r3, [sp, #40]	; 0x28
    44b8:	4620      	mov	r0, r4
    44ba:	2200      	movs	r2, #0
    44bc:	4b8b      	ldr	r3, [pc, #556]	; (46ec <_dtoa_r+0x614>)
    44be:	4629      	mov	r1, r5
    44c0:	f004 fea8 	bl	9214 <__aeabi_dmul>
    44c4:	e9cd 0104 	strd	r0, r1, [sp, #16]
    44c8:	9c02      	ldr	r4, [sp, #8]
    44ca:	3601      	adds	r6, #1
    44cc:	4630      	mov	r0, r6
    44ce:	f006 fb55 	bl	ab7c <__aeabi_i2d>
    44d2:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    44d6:	f004 fe9d 	bl	9214 <__aeabi_dmul>
    44da:	2200      	movs	r2, #0
    44dc:	4b84      	ldr	r3, [pc, #528]	; (46f0 <_dtoa_r+0x618>)
    44de:	f006 fa01 	bl	a8e4 <__adddf3>
    44e2:	4606      	mov	r6, r0
    44e4:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
    44e8:	2c00      	cmp	r4, #0
    44ea:	d15c      	bne.n	45a6 <_dtoa_r+0x4ce>
    44ec:	2200      	movs	r2, #0
    44ee:	4b81      	ldr	r3, [pc, #516]	; (46f4 <_dtoa_r+0x61c>)
    44f0:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    44f4:	f006 f9f4 	bl	a8e0 <__aeabi_dsub>
    44f8:	4632      	mov	r2, r6
    44fa:	463b      	mov	r3, r7
    44fc:	e9cd 0104 	strd	r0, r1, [sp, #16]
    4500:	f00f f90e 	bl	13720 <__aeabi_dcmpgt>
    4504:	2800      	cmp	r0, #0
    4506:	f040 8289 	bne.w	4a1c <_dtoa_r+0x944>
    450a:	4632      	mov	r2, r6
    450c:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
    4510:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    4514:	f00f f8e6 	bl	136e4 <__aeabi_dcmplt>
    4518:	2800      	cmp	r0, #0
    451a:	f040 827d 	bne.w	4a18 <_dtoa_r+0x940>
    451e:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
    4522:	e9cd 3404 	strd	r3, r4, [sp, #16]
    4526:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    4528:	2b00      	cmp	r3, #0
    452a:	f2c0 814f 	blt.w	47cc <_dtoa_r+0x6f4>
    452e:	f1ba 0f0e 	cmp.w	sl, #14
    4532:	f300 814b 	bgt.w	47cc <_dtoa_r+0x6f4>
    4536:	4b6a      	ldr	r3, [pc, #424]	; (46e0 <_dtoa_r+0x608>)
    4538:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
    453c:	ed93 7b00 	vldr	d7, [r3]
    4540:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    4542:	2b00      	cmp	r3, #0
    4544:	ed8d 7b02 	vstr	d7, [sp, #8]
    4548:	f280 80d8 	bge.w	46fc <_dtoa_r+0x624>
    454c:	f1b9 0f00 	cmp.w	r9, #0
    4550:	f300 80d4 	bgt.w	46fc <_dtoa_r+0x624>
    4554:	f040 825f 	bne.w	4a16 <_dtoa_r+0x93e>
    4558:	2200      	movs	r2, #0
    455a:	4b66      	ldr	r3, [pc, #408]	; (46f4 <_dtoa_r+0x61c>)
    455c:	ec51 0b17 	vmov	r0, r1, d7
    4560:	f004 fe58 	bl	9214 <__aeabi_dmul>
    4564:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    4568:	f00f f8d0 	bl	1370c <__aeabi_dcmpge>
    456c:	464c      	mov	r4, r9
    456e:	464e      	mov	r6, r9
    4570:	2800      	cmp	r0, #0
    4572:	f040 8238 	bne.w	49e6 <_dtoa_r+0x90e>
    4576:	9d01      	ldr	r5, [sp, #4]
    4578:	2331      	movs	r3, #49	; 0x31
    457a:	f805 3b01 	strb.w	r3, [r5], #1
    457e:	f10a 0a01 	add.w	sl, sl, #1
    4582:	e234      	b.n	49ee <_dtoa_r+0x916>
    4584:	07e7      	lsls	r7, r4, #31
    4586:	d505      	bpl.n	4594 <_dtoa_r+0x4bc>
    4588:	e9d5 2300 	ldrd	r2, r3, [r5]
    458c:	f004 fe42 	bl	9214 <__aeabi_dmul>
    4590:	3601      	adds	r6, #1
    4592:	2301      	movs	r3, #1
    4594:	1064      	asrs	r4, r4, #1
    4596:	3508      	adds	r5, #8
    4598:	e773      	b.n	4482 <_dtoa_r+0x3aa>
    459a:	2602      	movs	r6, #2
    459c:	e775      	b.n	448a <_dtoa_r+0x3b2>
    459e:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
    45a2:	464c      	mov	r4, r9
    45a4:	e792      	b.n	44cc <_dtoa_r+0x3f4>
    45a6:	4b4e      	ldr	r3, [pc, #312]	; (46e0 <_dtoa_r+0x608>)
    45a8:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
    45ac:	e953 0102 	ldrd	r0, r1, [r3, #-8]
    45b0:	9b01      	ldr	r3, [sp, #4]
    45b2:	441c      	add	r4, r3
    45b4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    45b6:	2b00      	cmp	r3, #0
    45b8:	d046      	beq.n	4648 <_dtoa_r+0x570>
    45ba:	4602      	mov	r2, r0
    45bc:	460b      	mov	r3, r1
    45be:	2000      	movs	r0, #0
    45c0:	494d      	ldr	r1, [pc, #308]	; (46f8 <_dtoa_r+0x620>)
    45c2:	f004 ff51 	bl	9468 <__aeabi_ddiv>
    45c6:	4632      	mov	r2, r6
    45c8:	463b      	mov	r3, r7
    45ca:	f006 f989 	bl	a8e0 <__aeabi_dsub>
    45ce:	9d01      	ldr	r5, [sp, #4]
    45d0:	4606      	mov	r6, r0
    45d2:	460f      	mov	r7, r1
    45d4:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    45d8:	f017 ff68 	bl	1c4ac <__aeabi_d2iz>
    45dc:	9012      	str	r0, [sp, #72]	; 0x48
    45de:	f006 facd 	bl	ab7c <__aeabi_i2d>
    45e2:	4602      	mov	r2, r0
    45e4:	460b      	mov	r3, r1
    45e6:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    45ea:	f006 f979 	bl	a8e0 <__aeabi_dsub>
    45ee:	9b12      	ldr	r3, [sp, #72]	; 0x48
    45f0:	3330      	adds	r3, #48	; 0x30
    45f2:	f805 3b01 	strb.w	r3, [r5], #1
    45f6:	4632      	mov	r2, r6
    45f8:	463b      	mov	r3, r7
    45fa:	e9cd 0104 	strd	r0, r1, [sp, #16]
    45fe:	f00f f871 	bl	136e4 <__aeabi_dcmplt>
    4602:	2800      	cmp	r0, #0
    4604:	d160      	bne.n	46c8 <_dtoa_r+0x5f0>
    4606:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    460a:	2000      	movs	r0, #0
    460c:	4936      	ldr	r1, [pc, #216]	; (46e8 <_dtoa_r+0x610>)
    460e:	f006 f967 	bl	a8e0 <__aeabi_dsub>
    4612:	4632      	mov	r2, r6
    4614:	463b      	mov	r3, r7
    4616:	f00f f865 	bl	136e4 <__aeabi_dcmplt>
    461a:	2800      	cmp	r0, #0
    461c:	f040 80b4 	bne.w	4788 <_dtoa_r+0x6b0>
    4620:	42a5      	cmp	r5, r4
    4622:	f43f af7c 	beq.w	451e <_dtoa_r+0x446>
    4626:	2200      	movs	r2, #0
    4628:	4b30      	ldr	r3, [pc, #192]	; (46ec <_dtoa_r+0x614>)
    462a:	4630      	mov	r0, r6
    462c:	4639      	mov	r1, r7
    462e:	f004 fdf1 	bl	9214 <__aeabi_dmul>
    4632:	2200      	movs	r2, #0
    4634:	4606      	mov	r6, r0
    4636:	460f      	mov	r7, r1
    4638:	4b2c      	ldr	r3, [pc, #176]	; (46ec <_dtoa_r+0x614>)
    463a:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    463e:	f004 fde9 	bl	9214 <__aeabi_dmul>
    4642:	e9cd 0104 	strd	r0, r1, [sp, #16]
    4646:	e7c5      	b.n	45d4 <_dtoa_r+0x4fc>
    4648:	4632      	mov	r2, r6
    464a:	463b      	mov	r3, r7
    464c:	f004 fde2 	bl	9214 <__aeabi_dmul>
    4650:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
    4654:	9e01      	ldr	r6, [sp, #4]
    4656:	4625      	mov	r5, r4
    4658:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    465c:	f017 ff26 	bl	1c4ac <__aeabi_d2iz>
    4660:	4607      	mov	r7, r0
    4662:	f006 fa8b 	bl	ab7c <__aeabi_i2d>
    4666:	3730      	adds	r7, #48	; 0x30
    4668:	4602      	mov	r2, r0
    466a:	460b      	mov	r3, r1
    466c:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    4670:	f006 f936 	bl	a8e0 <__aeabi_dsub>
    4674:	f806 7b01 	strb.w	r7, [r6], #1
    4678:	42a6      	cmp	r6, r4
    467a:	e9cd 0104 	strd	r0, r1, [sp, #16]
    467e:	f04f 0200 	mov.w	r2, #0
    4682:	d126      	bne.n	46d2 <_dtoa_r+0x5fa>
    4684:	4b1c      	ldr	r3, [pc, #112]	; (46f8 <_dtoa_r+0x620>)
    4686:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
    468a:	f006 f92b 	bl	a8e4 <__adddf3>
    468e:	4602      	mov	r2, r0
    4690:	460b      	mov	r3, r1
    4692:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    4696:	f00f f843 	bl	13720 <__aeabi_dcmpgt>
    469a:	2800      	cmp	r0, #0
    469c:	d174      	bne.n	4788 <_dtoa_r+0x6b0>
    469e:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
    46a2:	2000      	movs	r0, #0
    46a4:	4914      	ldr	r1, [pc, #80]	; (46f8 <_dtoa_r+0x620>)
    46a6:	f006 f91b 	bl	a8e0 <__aeabi_dsub>
    46aa:	4602      	mov	r2, r0
    46ac:	460b      	mov	r3, r1
    46ae:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    46b2:	f00f f817 	bl	136e4 <__aeabi_dcmplt>
    46b6:	2800      	cmp	r0, #0
    46b8:	f43f af31 	beq.w	451e <_dtoa_r+0x446>
    46bc:	f815 3c01 	ldrb.w	r3, [r5, #-1]
    46c0:	2b30      	cmp	r3, #48	; 0x30
    46c2:	f105 32ff 	add.w	r2, r5, #4294967295
    46c6:	d002      	beq.n	46ce <_dtoa_r+0x5f6>
    46c8:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
    46cc:	e04a      	b.n	4764 <_dtoa_r+0x68c>
    46ce:	4615      	mov	r5, r2
    46d0:	e7f4      	b.n	46bc <_dtoa_r+0x5e4>
    46d2:	4b06      	ldr	r3, [pc, #24]	; (46ec <_dtoa_r+0x614>)
    46d4:	f004 fd9e 	bl	9214 <__aeabi_dmul>
    46d8:	e9cd 0104 	strd	r0, r1, [sp, #16]
    46dc:	e7bc      	b.n	4658 <_dtoa_r+0x580>
    46de:	bf00      	nop
    46e0:	00015a98 	.word	0x00015a98
    46e4:	000200a0 	.word	0x000200a0
    46e8:	3ff00000 	.word	0x3ff00000
    46ec:	40240000 	.word	0x40240000
    46f0:	401c0000 	.word	0x401c0000
    46f4:	40140000 	.word	0x40140000
    46f8:	3fe00000 	.word	0x3fe00000
    46fc:	e9dd 6704 	ldrd	r6, r7, [sp, #16]
    4700:	9d01      	ldr	r5, [sp, #4]
    4702:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    4706:	4630      	mov	r0, r6
    4708:	4639      	mov	r1, r7
    470a:	f004 fead 	bl	9468 <__aeabi_ddiv>
    470e:	f017 fecd 	bl	1c4ac <__aeabi_d2iz>
    4712:	4604      	mov	r4, r0
    4714:	f006 fa32 	bl	ab7c <__aeabi_i2d>
    4718:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    471c:	f004 fd7a 	bl	9214 <__aeabi_dmul>
    4720:	4602      	mov	r2, r0
    4722:	460b      	mov	r3, r1
    4724:	4630      	mov	r0, r6
    4726:	4639      	mov	r1, r7
    4728:	f104 0630 	add.w	r6, r4, #48	; 0x30
    472c:	f006 f8d8 	bl	a8e0 <__aeabi_dsub>
    4730:	f805 6b01 	strb.w	r6, [r5], #1
    4734:	9e01      	ldr	r6, [sp, #4]
    4736:	1bae      	subs	r6, r5, r6
    4738:	45b1      	cmp	r9, r6
    473a:	4602      	mov	r2, r0
    473c:	460b      	mov	r3, r1
    473e:	d138      	bne.n	47b2 <_dtoa_r+0x6da>
    4740:	f006 f8d0 	bl	a8e4 <__adddf3>
    4744:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    4748:	4606      	mov	r6, r0
    474a:	460f      	mov	r7, r1
    474c:	f00e ffe8 	bl	13720 <__aeabi_dcmpgt>
    4750:	b9c0      	cbnz	r0, 4784 <_dtoa_r+0x6ac>
    4752:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    4756:	4630      	mov	r0, r6
    4758:	4639      	mov	r1, r7
    475a:	f00e ffb9 	bl	136d0 <__aeabi_dcmpeq>
    475e:	b108      	cbz	r0, 4764 <_dtoa_r+0x68c>
    4760:	07e1      	lsls	r1, r4, #31
    4762:	d40f      	bmi.n	4784 <_dtoa_r+0x6ac>
    4764:	4641      	mov	r1, r8
    4766:	4658      	mov	r0, fp
    4768:	f01a ff75 	bl	1f656 <_Bfree>
    476c:	2300      	movs	r3, #0
    476e:	9a14      	ldr	r2, [sp, #80]	; 0x50
    4770:	702b      	strb	r3, [r5, #0]
    4772:	f10a 0301 	add.w	r3, sl, #1
    4776:	6013      	str	r3, [r2, #0]
    4778:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    477a:	2b00      	cmp	r3, #0
    477c:	f43f acf4 	beq.w	4168 <_dtoa_r+0x90>
    4780:	601d      	str	r5, [r3, #0]
    4782:	e4f1      	b.n	4168 <_dtoa_r+0x90>
    4784:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
    4788:	f815 2c01 	ldrb.w	r2, [r5, #-1]
    478c:	2a39      	cmp	r2, #57	; 0x39
    478e:	f105 33ff 	add.w	r3, r5, #4294967295
    4792:	d108      	bne.n	47a6 <_dtoa_r+0x6ce>
    4794:	9a01      	ldr	r2, [sp, #4]
    4796:	429a      	cmp	r2, r3
    4798:	d109      	bne.n	47ae <_dtoa_r+0x6d6>
    479a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    479c:	9901      	ldr	r1, [sp, #4]
    479e:	3201      	adds	r2, #1
    47a0:	920a      	str	r2, [sp, #40]	; 0x28
    47a2:	2230      	movs	r2, #48	; 0x30
    47a4:	700a      	strb	r2, [r1, #0]
    47a6:	781a      	ldrb	r2, [r3, #0]
    47a8:	3201      	adds	r2, #1
    47aa:	701a      	strb	r2, [r3, #0]
    47ac:	e78c      	b.n	46c8 <_dtoa_r+0x5f0>
    47ae:	461d      	mov	r5, r3
    47b0:	e7ea      	b.n	4788 <_dtoa_r+0x6b0>
    47b2:	2200      	movs	r2, #0
    47b4:	4b9b      	ldr	r3, [pc, #620]	; (4a24 <_dtoa_r+0x94c>)
    47b6:	f004 fd2d 	bl	9214 <__aeabi_dmul>
    47ba:	2200      	movs	r2, #0
    47bc:	2300      	movs	r3, #0
    47be:	4606      	mov	r6, r0
    47c0:	460f      	mov	r7, r1
    47c2:	f00e ff85 	bl	136d0 <__aeabi_dcmpeq>
    47c6:	2800      	cmp	r0, #0
    47c8:	d09b      	beq.n	4702 <_dtoa_r+0x62a>
    47ca:	e7cb      	b.n	4764 <_dtoa_r+0x68c>
    47cc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    47ce:	2a00      	cmp	r2, #0
    47d0:	f000 80cb 	beq.w	496a <_dtoa_r+0x892>
    47d4:	9a08      	ldr	r2, [sp, #32]
    47d6:	2a01      	cmp	r2, #1
    47d8:	f300 80ae 	bgt.w	4938 <_dtoa_r+0x860>
    47dc:	9a15      	ldr	r2, [sp, #84]	; 0x54
    47de:	2a00      	cmp	r2, #0
    47e0:	f000 80a6 	beq.w	4930 <_dtoa_r+0x858>
    47e4:	f203 4333 	addw	r3, r3, #1075	; 0x433
    47e8:	9c09      	ldr	r4, [sp, #36]	; 0x24
    47ea:	9d06      	ldr	r5, [sp, #24]
    47ec:	9a06      	ldr	r2, [sp, #24]
    47ee:	441a      	add	r2, r3
    47f0:	9206      	str	r2, [sp, #24]
    47f2:	9a07      	ldr	r2, [sp, #28]
    47f4:	2101      	movs	r1, #1
    47f6:	441a      	add	r2, r3
    47f8:	4658      	mov	r0, fp
    47fa:	9207      	str	r2, [sp, #28]
    47fc:	f01d f8ec 	bl	219d8 <__i2b>
    4800:	4606      	mov	r6, r0
    4802:	2d00      	cmp	r5, #0
    4804:	dd0c      	ble.n	4820 <_dtoa_r+0x748>
    4806:	9b07      	ldr	r3, [sp, #28]
    4808:	2b00      	cmp	r3, #0
    480a:	dd09      	ble.n	4820 <_dtoa_r+0x748>
    480c:	42ab      	cmp	r3, r5
    480e:	9a06      	ldr	r2, [sp, #24]
    4810:	bfa8      	it	ge
    4812:	462b      	movge	r3, r5
    4814:	1ad2      	subs	r2, r2, r3
    4816:	9206      	str	r2, [sp, #24]
    4818:	9a07      	ldr	r2, [sp, #28]
    481a:	1aed      	subs	r5, r5, r3
    481c:	1ad3      	subs	r3, r2, r3
    481e:	9307      	str	r3, [sp, #28]
    4820:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4822:	b1f3      	cbz	r3, 4862 <_dtoa_r+0x78a>
    4824:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    4826:	2b00      	cmp	r3, #0
    4828:	f000 80a3 	beq.w	4972 <_dtoa_r+0x89a>
    482c:	2c00      	cmp	r4, #0
    482e:	dd10      	ble.n	4852 <_dtoa_r+0x77a>
    4830:	4631      	mov	r1, r6
    4832:	4622      	mov	r2, r4
    4834:	4658      	mov	r0, fp
    4836:	f013 f99b 	bl	17b70 <__pow5mult>
    483a:	4642      	mov	r2, r8
    483c:	4601      	mov	r1, r0
    483e:	4606      	mov	r6, r0
    4840:	4658      	mov	r0, fp
    4842:	f00d fde7 	bl	12414 <__multiply>
    4846:	4641      	mov	r1, r8
    4848:	4607      	mov	r7, r0
    484a:	4658      	mov	r0, fp
    484c:	f01a ff03 	bl	1f656 <_Bfree>
    4850:	46b8      	mov	r8, r7
    4852:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4854:	1b1a      	subs	r2, r3, r4
    4856:	d004      	beq.n	4862 <_dtoa_r+0x78a>
    4858:	4641      	mov	r1, r8
    485a:	4658      	mov	r0, fp
    485c:	f013 f988 	bl	17b70 <__pow5mult>
    4860:	4680      	mov	r8, r0
    4862:	2101      	movs	r1, #1
    4864:	4658      	mov	r0, fp
    4866:	f01d f8b7 	bl	219d8 <__i2b>
    486a:	9b10      	ldr	r3, [sp, #64]	; 0x40
    486c:	2b00      	cmp	r3, #0
    486e:	4604      	mov	r4, r0
    4870:	f340 8081 	ble.w	4976 <_dtoa_r+0x89e>
    4874:	461a      	mov	r2, r3
    4876:	4601      	mov	r1, r0
    4878:	4658      	mov	r0, fp
    487a:	f013 f979 	bl	17b70 <__pow5mult>
    487e:	9b08      	ldr	r3, [sp, #32]
    4880:	2b01      	cmp	r3, #1
    4882:	4604      	mov	r4, r0
    4884:	dd7a      	ble.n	497c <_dtoa_r+0x8a4>
    4886:	2700      	movs	r7, #0
    4888:	6923      	ldr	r3, [r4, #16]
    488a:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    488e:	6918      	ldr	r0, [r3, #16]
    4890:	f019 f9a0 	bl	1dbd4 <__hi0bits>
    4894:	f1c0 0020 	rsb	r0, r0, #32
    4898:	9b07      	ldr	r3, [sp, #28]
    489a:	4418      	add	r0, r3
    489c:	f010 001f 	ands.w	r0, r0, #31
    48a0:	f000 8088 	beq.w	49b4 <_dtoa_r+0x8dc>
    48a4:	f1c0 0320 	rsb	r3, r0, #32
    48a8:	2b04      	cmp	r3, #4
    48aa:	f340 8081 	ble.w	49b0 <_dtoa_r+0x8d8>
    48ae:	f1c0 001c 	rsb	r0, r0, #28
    48b2:	9b06      	ldr	r3, [sp, #24]
    48b4:	4403      	add	r3, r0
    48b6:	9306      	str	r3, [sp, #24]
    48b8:	9b07      	ldr	r3, [sp, #28]
    48ba:	4403      	add	r3, r0
    48bc:	4405      	add	r5, r0
    48be:	9307      	str	r3, [sp, #28]
    48c0:	9b06      	ldr	r3, [sp, #24]
    48c2:	2b00      	cmp	r3, #0
    48c4:	dd05      	ble.n	48d2 <_dtoa_r+0x7fa>
    48c6:	4641      	mov	r1, r8
    48c8:	461a      	mov	r2, r3
    48ca:	4658      	mov	r0, fp
    48cc:	f012 fcee 	bl	172ac <__lshift>
    48d0:	4680      	mov	r8, r0
    48d2:	9b07      	ldr	r3, [sp, #28]
    48d4:	2b00      	cmp	r3, #0
    48d6:	dd05      	ble.n	48e4 <_dtoa_r+0x80c>
    48d8:	4621      	mov	r1, r4
    48da:	461a      	mov	r2, r3
    48dc:	4658      	mov	r0, fp
    48de:	f012 fce5 	bl	172ac <__lshift>
    48e2:	4604      	mov	r4, r0
    48e4:	9b11      	ldr	r3, [sp, #68]	; 0x44
    48e6:	2b00      	cmp	r3, #0
    48e8:	d066      	beq.n	49b8 <_dtoa_r+0x8e0>
    48ea:	4621      	mov	r1, r4
    48ec:	4640      	mov	r0, r8
    48ee:	f01a fa09 	bl	1ed04 <__mcmp>
    48f2:	2800      	cmp	r0, #0
    48f4:	da60      	bge.n	49b8 <_dtoa_r+0x8e0>
    48f6:	2300      	movs	r3, #0
    48f8:	4641      	mov	r1, r8
    48fa:	220a      	movs	r2, #10
    48fc:	4658      	mov	r0, fp
    48fe:	f014 fdb0 	bl	19462 <__multadd>
    4902:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    4904:	f10a 3aff 	add.w	sl, sl, #4294967295
    4908:	4680      	mov	r8, r0
    490a:	2b00      	cmp	r3, #0
    490c:	f000 8179 	beq.w	4c02 <_dtoa_r+0xb2a>
    4910:	2300      	movs	r3, #0
    4912:	4631      	mov	r1, r6
    4914:	220a      	movs	r2, #10
    4916:	4658      	mov	r0, fp
    4918:	f014 fda3 	bl	19462 <__multadd>
    491c:	9b02      	ldr	r3, [sp, #8]
    491e:	2b00      	cmp	r3, #0
    4920:	4606      	mov	r6, r0
    4922:	f300 8089 	bgt.w	4a38 <_dtoa_r+0x960>
    4926:	9b08      	ldr	r3, [sp, #32]
    4928:	2b02      	cmp	r3, #2
    492a:	f340 8085 	ble.w	4a38 <_dtoa_r+0x960>
    492e:	e04b      	b.n	49c8 <_dtoa_r+0x8f0>
    4930:	9b16      	ldr	r3, [sp, #88]	; 0x58
    4932:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
    4936:	e757      	b.n	47e8 <_dtoa_r+0x710>
    4938:	9b09      	ldr	r3, [sp, #36]	; 0x24
    493a:	f109 34ff 	add.w	r4, r9, #4294967295
    493e:	42a3      	cmp	r3, r4
    4940:	bfbf      	itttt	lt
    4942:	9b09      	ldrlt	r3, [sp, #36]	; 0x24
    4944:	9409      	strlt	r4, [sp, #36]	; 0x24
    4946:	1ae2      	sublt	r2, r4, r3
    4948:	9b10      	ldrlt	r3, [sp, #64]	; 0x40
    494a:	bfbb      	ittet	lt
    494c:	189b      	addlt	r3, r3, r2
    494e:	9310      	strlt	r3, [sp, #64]	; 0x40
    4950:	1b1c      	subge	r4, r3, r4
    4952:	2400      	movlt	r4, #0
    4954:	f1b9 0f00 	cmp.w	r9, #0
    4958:	bfb5      	itete	lt
    495a:	9b06      	ldrlt	r3, [sp, #24]
    495c:	9d06      	ldrge	r5, [sp, #24]
    495e:	eba3 0509 	sublt.w	r5, r3, r9
    4962:	464b      	movge	r3, r9
    4964:	bfb8      	it	lt
    4966:	2300      	movlt	r3, #0
    4968:	e740      	b.n	47ec <_dtoa_r+0x714>
    496a:	9c09      	ldr	r4, [sp, #36]	; 0x24
    496c:	9d06      	ldr	r5, [sp, #24]
    496e:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    4970:	e747      	b.n	4802 <_dtoa_r+0x72a>
    4972:	9a09      	ldr	r2, [sp, #36]	; 0x24
    4974:	e770      	b.n	4858 <_dtoa_r+0x780>
    4976:	9b08      	ldr	r3, [sp, #32]
    4978:	2b01      	cmp	r3, #1
    497a:	dc15      	bgt.n	49a8 <_dtoa_r+0x8d0>
    497c:	9b04      	ldr	r3, [sp, #16]
    497e:	b99b      	cbnz	r3, 49a8 <_dtoa_r+0x8d0>
    4980:	9b05      	ldr	r3, [sp, #20]
    4982:	f3c3 0213 	ubfx	r2, r3, #0, #20
    4986:	b98a      	cbnz	r2, 49ac <_dtoa_r+0x8d4>
    4988:	4f27      	ldr	r7, [pc, #156]	; (4a28 <_dtoa_r+0x950>)
    498a:	401f      	ands	r7, r3
    498c:	b137      	cbz	r7, 499c <_dtoa_r+0x8c4>
    498e:	9b06      	ldr	r3, [sp, #24]
    4990:	3301      	adds	r3, #1
    4992:	9306      	str	r3, [sp, #24]
    4994:	9b07      	ldr	r3, [sp, #28]
    4996:	3301      	adds	r3, #1
    4998:	9307      	str	r3, [sp, #28]
    499a:	2701      	movs	r7, #1
    499c:	9b10      	ldr	r3, [sp, #64]	; 0x40
    499e:	2b00      	cmp	r3, #0
    49a0:	f47f af72 	bne.w	4888 <_dtoa_r+0x7b0>
    49a4:	2001      	movs	r0, #1
    49a6:	e777      	b.n	4898 <_dtoa_r+0x7c0>
    49a8:	2700      	movs	r7, #0
    49aa:	e7f7      	b.n	499c <_dtoa_r+0x8c4>
    49ac:	9f04      	ldr	r7, [sp, #16]
    49ae:	e7f5      	b.n	499c <_dtoa_r+0x8c4>
    49b0:	d086      	beq.n	48c0 <_dtoa_r+0x7e8>
    49b2:	4618      	mov	r0, r3
    49b4:	301c      	adds	r0, #28
    49b6:	e77c      	b.n	48b2 <_dtoa_r+0x7da>
    49b8:	f1b9 0f00 	cmp.w	r9, #0
    49bc:	dc36      	bgt.n	4a2c <_dtoa_r+0x954>
    49be:	9b08      	ldr	r3, [sp, #32]
    49c0:	2b02      	cmp	r3, #2
    49c2:	dd33      	ble.n	4a2c <_dtoa_r+0x954>
    49c4:	f8cd 9008 	str.w	r9, [sp, #8]
    49c8:	9b02      	ldr	r3, [sp, #8]
    49ca:	b963      	cbnz	r3, 49e6 <_dtoa_r+0x90e>
    49cc:	4621      	mov	r1, r4
    49ce:	2205      	movs	r2, #5
    49d0:	4658      	mov	r0, fp
    49d2:	f014 fd46 	bl	19462 <__multadd>
    49d6:	4601      	mov	r1, r0
    49d8:	4604      	mov	r4, r0
    49da:	4640      	mov	r0, r8
    49dc:	f01a f992 	bl	1ed04 <__mcmp>
    49e0:	2800      	cmp	r0, #0
    49e2:	f73f adc8 	bgt.w	4576 <_dtoa_r+0x49e>
    49e6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    49e8:	9d01      	ldr	r5, [sp, #4]
    49ea:	ea6f 0a03 	mvn.w	sl, r3
    49ee:	2700      	movs	r7, #0
    49f0:	4621      	mov	r1, r4
    49f2:	4658      	mov	r0, fp
    49f4:	f01a fe2f 	bl	1f656 <_Bfree>
    49f8:	2e00      	cmp	r6, #0
    49fa:	f43f aeb3 	beq.w	4764 <_dtoa_r+0x68c>
    49fe:	b12f      	cbz	r7, 4a0c <_dtoa_r+0x934>
    4a00:	42b7      	cmp	r7, r6
    4a02:	d003      	beq.n	4a0c <_dtoa_r+0x934>
    4a04:	4639      	mov	r1, r7
    4a06:	4658      	mov	r0, fp
    4a08:	f01a fe25 	bl	1f656 <_Bfree>
    4a0c:	4631      	mov	r1, r6
    4a0e:	4658      	mov	r0, fp
    4a10:	f01a fe21 	bl	1f656 <_Bfree>
    4a14:	e6a6      	b.n	4764 <_dtoa_r+0x68c>
    4a16:	2400      	movs	r4, #0
    4a18:	4626      	mov	r6, r4
    4a1a:	e7e4      	b.n	49e6 <_dtoa_r+0x90e>
    4a1c:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
    4a20:	4626      	mov	r6, r4
    4a22:	e5a8      	b.n	4576 <_dtoa_r+0x49e>
    4a24:	40240000 	.word	0x40240000
    4a28:	7ff00000 	.word	0x7ff00000
    4a2c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    4a2e:	f8cd 9008 	str.w	r9, [sp, #8]
    4a32:	2b00      	cmp	r3, #0
    4a34:	f000 80ec 	beq.w	4c10 <_dtoa_r+0xb38>
    4a38:	2d00      	cmp	r5, #0
    4a3a:	dd05      	ble.n	4a48 <_dtoa_r+0x970>
    4a3c:	4631      	mov	r1, r6
    4a3e:	462a      	mov	r2, r5
    4a40:	4658      	mov	r0, fp
    4a42:	f012 fc33 	bl	172ac <__lshift>
    4a46:	4606      	mov	r6, r0
    4a48:	2f00      	cmp	r7, #0
    4a4a:	d056      	beq.n	4afa <_dtoa_r+0xa22>
    4a4c:	6871      	ldr	r1, [r6, #4]
    4a4e:	4658      	mov	r0, fp
    4a50:	f016 f904 	bl	1ac5c <_Balloc>
    4a54:	6932      	ldr	r2, [r6, #16]
    4a56:	3202      	adds	r2, #2
    4a58:	4605      	mov	r5, r0
    4a5a:	0092      	lsls	r2, r2, #2
    4a5c:	f106 010c 	add.w	r1, r6, #12
    4a60:	300c      	adds	r0, #12
    4a62:	f01c fafd 	bl	21060 <memcpy>
    4a66:	2201      	movs	r2, #1
    4a68:	4629      	mov	r1, r5
    4a6a:	4658      	mov	r0, fp
    4a6c:	f012 fc1e 	bl	172ac <__lshift>
    4a70:	9b01      	ldr	r3, [sp, #4]
    4a72:	f103 0901 	add.w	r9, r3, #1
    4a76:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
    4a7a:	4413      	add	r3, r2
    4a7c:	9309      	str	r3, [sp, #36]	; 0x24
    4a7e:	9b04      	ldr	r3, [sp, #16]
    4a80:	f003 0301 	and.w	r3, r3, #1
    4a84:	4637      	mov	r7, r6
    4a86:	9307      	str	r3, [sp, #28]
    4a88:	4606      	mov	r6, r0
    4a8a:	f109 33ff 	add.w	r3, r9, #4294967295
    4a8e:	4621      	mov	r1, r4
    4a90:	4640      	mov	r0, r8
    4a92:	9302      	str	r3, [sp, #8]
    4a94:	f00d fd56 	bl	12544 <quorem>
    4a98:	4603      	mov	r3, r0
    4a9a:	3330      	adds	r3, #48	; 0x30
    4a9c:	9004      	str	r0, [sp, #16]
    4a9e:	4639      	mov	r1, r7
    4aa0:	4640      	mov	r0, r8
    4aa2:	930a      	str	r3, [sp, #40]	; 0x28
    4aa4:	f01a f92e 	bl	1ed04 <__mcmp>
    4aa8:	4632      	mov	r2, r6
    4aaa:	9006      	str	r0, [sp, #24]
    4aac:	4621      	mov	r1, r4
    4aae:	4658      	mov	r0, fp
    4ab0:	f010 ff8e 	bl	159d0 <__mdiff>
    4ab4:	68c2      	ldr	r2, [r0, #12]
    4ab6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4ab8:	4605      	mov	r5, r0
    4aba:	bb02      	cbnz	r2, 4afe <_dtoa_r+0xa26>
    4abc:	4601      	mov	r1, r0
    4abe:	4640      	mov	r0, r8
    4ac0:	f01a f920 	bl	1ed04 <__mcmp>
    4ac4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4ac6:	4602      	mov	r2, r0
    4ac8:	4629      	mov	r1, r5
    4aca:	4658      	mov	r0, fp
    4acc:	920c      	str	r2, [sp, #48]	; 0x30
    4ace:	930a      	str	r3, [sp, #40]	; 0x28
    4ad0:	f01a fdc1 	bl	1f656 <_Bfree>
    4ad4:	9b08      	ldr	r3, [sp, #32]
    4ad6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    4ad8:	ea43 0102 	orr.w	r1, r3, r2
    4adc:	9b07      	ldr	r3, [sp, #28]
    4ade:	430b      	orrs	r3, r1
    4ae0:	464d      	mov	r5, r9
    4ae2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4ae4:	d10d      	bne.n	4b02 <_dtoa_r+0xa2a>
    4ae6:	2b39      	cmp	r3, #57	; 0x39
    4ae8:	d027      	beq.n	4b3a <_dtoa_r+0xa62>
    4aea:	9a06      	ldr	r2, [sp, #24]
    4aec:	2a00      	cmp	r2, #0
    4aee:	dd01      	ble.n	4af4 <_dtoa_r+0xa1c>
    4af0:	9b04      	ldr	r3, [sp, #16]
    4af2:	3331      	adds	r3, #49	; 0x31
    4af4:	9a02      	ldr	r2, [sp, #8]
    4af6:	7013      	strb	r3, [r2, #0]
    4af8:	e77a      	b.n	49f0 <_dtoa_r+0x918>
    4afa:	4630      	mov	r0, r6
    4afc:	e7b8      	b.n	4a70 <_dtoa_r+0x998>
    4afe:	2201      	movs	r2, #1
    4b00:	e7e2      	b.n	4ac8 <_dtoa_r+0x9f0>
    4b02:	9906      	ldr	r1, [sp, #24]
    4b04:	2900      	cmp	r1, #0
    4b06:	db04      	blt.n	4b12 <_dtoa_r+0xa3a>
    4b08:	9808      	ldr	r0, [sp, #32]
    4b0a:	4301      	orrs	r1, r0
    4b0c:	9807      	ldr	r0, [sp, #28]
    4b0e:	4301      	orrs	r1, r0
    4b10:	d11e      	bne.n	4b50 <_dtoa_r+0xa78>
    4b12:	2a00      	cmp	r2, #0
    4b14:	ddee      	ble.n	4af4 <_dtoa_r+0xa1c>
    4b16:	4641      	mov	r1, r8
    4b18:	2201      	movs	r2, #1
    4b1a:	4658      	mov	r0, fp
    4b1c:	9306      	str	r3, [sp, #24]
    4b1e:	f012 fbc5 	bl	172ac <__lshift>
    4b22:	4621      	mov	r1, r4
    4b24:	4680      	mov	r8, r0
    4b26:	f01a f8ed 	bl	1ed04 <__mcmp>
    4b2a:	2800      	cmp	r0, #0
    4b2c:	9b06      	ldr	r3, [sp, #24]
    4b2e:	dc02      	bgt.n	4b36 <_dtoa_r+0xa5e>
    4b30:	d1e0      	bne.n	4af4 <_dtoa_r+0xa1c>
    4b32:	07da      	lsls	r2, r3, #31
    4b34:	d5de      	bpl.n	4af4 <_dtoa_r+0xa1c>
    4b36:	2b39      	cmp	r3, #57	; 0x39
    4b38:	d1da      	bne.n	4af0 <_dtoa_r+0xa18>
    4b3a:	9a02      	ldr	r2, [sp, #8]
    4b3c:	2339      	movs	r3, #57	; 0x39
    4b3e:	7013      	strb	r3, [r2, #0]
    4b40:	f815 3c01 	ldrb.w	r3, [r5, #-1]
    4b44:	2b39      	cmp	r3, #57	; 0x39
    4b46:	f105 32ff 	add.w	r2, r5, #4294967295
    4b4a:	d046      	beq.n	4bda <_dtoa_r+0xb02>
    4b4c:	3301      	adds	r3, #1
    4b4e:	e7d2      	b.n	4af6 <_dtoa_r+0xa1e>
    4b50:	2a00      	cmp	r2, #0
    4b52:	dd03      	ble.n	4b5c <_dtoa_r+0xa84>
    4b54:	2b39      	cmp	r3, #57	; 0x39
    4b56:	d0f0      	beq.n	4b3a <_dtoa_r+0xa62>
    4b58:	3301      	adds	r3, #1
    4b5a:	e7cb      	b.n	4af4 <_dtoa_r+0xa1c>
    4b5c:	9a09      	ldr	r2, [sp, #36]	; 0x24
    4b5e:	f809 3c01 	strb.w	r3, [r9, #-1]
    4b62:	4591      	cmp	r9, r2
    4b64:	d020      	beq.n	4ba8 <_dtoa_r+0xad0>
    4b66:	4641      	mov	r1, r8
    4b68:	2300      	movs	r3, #0
    4b6a:	220a      	movs	r2, #10
    4b6c:	4658      	mov	r0, fp
    4b6e:	f014 fc78 	bl	19462 <__multadd>
    4b72:	42b7      	cmp	r7, r6
    4b74:	4680      	mov	r8, r0
    4b76:	f04f 0300 	mov.w	r3, #0
    4b7a:	f04f 020a 	mov.w	r2, #10
    4b7e:	4639      	mov	r1, r7
    4b80:	4658      	mov	r0, fp
    4b82:	d106      	bne.n	4b92 <_dtoa_r+0xaba>
    4b84:	f014 fc6d 	bl	19462 <__multadd>
    4b88:	4607      	mov	r7, r0
    4b8a:	4606      	mov	r6, r0
    4b8c:	f109 0901 	add.w	r9, r9, #1
    4b90:	e77b      	b.n	4a8a <_dtoa_r+0x9b2>
    4b92:	f014 fc66 	bl	19462 <__multadd>
    4b96:	2300      	movs	r3, #0
    4b98:	4607      	mov	r7, r0
    4b9a:	220a      	movs	r2, #10
    4b9c:	4631      	mov	r1, r6
    4b9e:	4658      	mov	r0, fp
    4ba0:	f014 fc5f 	bl	19462 <__multadd>
    4ba4:	e7f1      	b.n	4b8a <_dtoa_r+0xab2>
    4ba6:	2700      	movs	r7, #0
    4ba8:	4641      	mov	r1, r8
    4baa:	2201      	movs	r2, #1
    4bac:	4658      	mov	r0, fp
    4bae:	9302      	str	r3, [sp, #8]
    4bb0:	f012 fb7c 	bl	172ac <__lshift>
    4bb4:	4621      	mov	r1, r4
    4bb6:	4680      	mov	r8, r0
    4bb8:	f01a f8a4 	bl	1ed04 <__mcmp>
    4bbc:	2800      	cmp	r0, #0
    4bbe:	dcbf      	bgt.n	4b40 <_dtoa_r+0xa68>
    4bc0:	d102      	bne.n	4bc8 <_dtoa_r+0xaf0>
    4bc2:	9b02      	ldr	r3, [sp, #8]
    4bc4:	07db      	lsls	r3, r3, #31
    4bc6:	d4bb      	bmi.n	4b40 <_dtoa_r+0xa68>
    4bc8:	f815 3c01 	ldrb.w	r3, [r5, #-1]
    4bcc:	2b30      	cmp	r3, #48	; 0x30
    4bce:	f105 32ff 	add.w	r2, r5, #4294967295
    4bd2:	f47f af0d 	bne.w	49f0 <_dtoa_r+0x918>
    4bd6:	4615      	mov	r5, r2
    4bd8:	e7f6      	b.n	4bc8 <_dtoa_r+0xaf0>
    4bda:	9b01      	ldr	r3, [sp, #4]
    4bdc:	4293      	cmp	r3, r2
    4bde:	d104      	bne.n	4bea <_dtoa_r+0xb12>
    4be0:	f10a 0a01 	add.w	sl, sl, #1
    4be4:	2331      	movs	r3, #49	; 0x31
    4be6:	9a01      	ldr	r2, [sp, #4]
    4be8:	e785      	b.n	4af6 <_dtoa_r+0xa1e>
    4bea:	4615      	mov	r5, r2
    4bec:	e7a8      	b.n	4b40 <_dtoa_r+0xa68>
    4bee:	4b13      	ldr	r3, [pc, #76]	; (4c3c <_dtoa_r+0xb64>)
    4bf0:	f7ff bad9 	b.w	41a6 <_dtoa_r+0xce>
    4bf4:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    4bf6:	2b00      	cmp	r3, #0
    4bf8:	f47f aab1 	bne.w	415e <_dtoa_r+0x86>
    4bfc:	4b10      	ldr	r3, [pc, #64]	; (4c40 <_dtoa_r+0xb68>)
    4bfe:	f7ff bad2 	b.w	41a6 <_dtoa_r+0xce>
    4c02:	9b02      	ldr	r3, [sp, #8]
    4c04:	2b00      	cmp	r3, #0
    4c06:	dc03      	bgt.n	4c10 <_dtoa_r+0xb38>
    4c08:	9b08      	ldr	r3, [sp, #32]
    4c0a:	2b02      	cmp	r3, #2
    4c0c:	f73f aedc 	bgt.w	49c8 <_dtoa_r+0x8f0>
    4c10:	9d01      	ldr	r5, [sp, #4]
    4c12:	4621      	mov	r1, r4
    4c14:	4640      	mov	r0, r8
    4c16:	f00d fc95 	bl	12544 <quorem>
    4c1a:	f100 0330 	add.w	r3, r0, #48	; 0x30
    4c1e:	f805 3b01 	strb.w	r3, [r5], #1
    4c22:	9a01      	ldr	r2, [sp, #4]
    4c24:	9902      	ldr	r1, [sp, #8]
    4c26:	1aaa      	subs	r2, r5, r2
    4c28:	4291      	cmp	r1, r2
    4c2a:	ddbc      	ble.n	4ba6 <_dtoa_r+0xace>
    4c2c:	4641      	mov	r1, r8
    4c2e:	2300      	movs	r3, #0
    4c30:	220a      	movs	r2, #10
    4c32:	4658      	mov	r0, fp
    4c34:	f014 fc15 	bl	19462 <__multadd>
    4c38:	4680      	mov	r8, r0
    4c3a:	e7ea      	b.n	4c12 <_dtoa_r+0xb3a>
    4c3c:	00021bd9 	.word	0x00021bd9
    4c40:	00021bcc 	.word	0x00021bcc

Disassembly of section .rodata%192:

00004c44 <.rodata%192>:
    4c44:	67617355 	.word	0x67617355
    4c48:	69203a65 	.word	0x69203a65
    4c4c:	66726570 	.word	0x66726570
    4c50:	2d3c2073 	.word	0x2d3c2073
    4c54:	73207874 	.word	0x73207874
    4c58:	3e657a69 	.word	0x3e657a69
    4c5c:	722d3c20 	.word	0x722d3c20
    4c60:	69732078 	.word	0x69732078
    4c64:	203e657a 	.word	0x203e657a
    4c68:	20692d3c 	.word	0x20692d3c
    4c6c:	65646e69 	.word	0x65646e69
    4c70:	0a0d3e78 	.word	0x0a0d3e78
    4c74:	00000000 	.word	0x00000000
    4c78:	0078742d 	.word	0x0078742d
    4c7c:	0078722d 	.word	0x0078722d
    4c80:	0000692d 	.word	0x0000692d
    4c84:	6e692d2d 	.word	0x6e692d2d
    4c88:	00786564 	.word	0x00786564
    4c8c:	72657069 	.word	0x72657069
    4c90:	203a6966 	.word	0x203a6966
    4c94:	6e6b6e55 	.word	0x6e6b6e55
    4c98:	206e776f 	.word	0x206e776f
    4c9c:	61726170 	.word	0x61726170
    4ca0:	6574656d 	.word	0x6574656d
    4ca4:	000a0d72 	.word	0x000a0d72
    4ca8:	70690a0d 	.word	0x70690a0d
    4cac:	3a667265 	.word	0x3a667265
    4cb0:	766e4920 	.word	0x766e4920
    4cb4:	64696c61 	.word	0x64696c61
    4cb8:	73657320 	.word	0x73657320
    4cbc:	6e6f6973 	.word	0x6e6f6973
    4cc0:	6d756e20 	.word	0x6d756e20
    4cc4:	2e726562 	.word	0x2e726562
    4cc8:	6e694d20 	.word	0x6e694d20
    4ccc:	2c30203a 	.word	0x2c30203a
    4cd0:	78614d20 	.word	0x78614d20
    4cd4:	6425203a 	.word	0x6425203a
    4cd8:	00000a0d 	.word	0x00000a0d
    4cdc:	72657069 	.word	0x72657069
    4ce0:	203a7366 	.word	0x203a7366
    4ce4:	203c2030 	.word	0x203c2030
    4ce8:	657a6973 	.word	0x657a6973
    4cec:	36203c20 	.word	0x36203c20
    4cf0:	36333535 	.word	0x36333535
    4cf4:	00000a0d 	.word	0x00000a0d
    4cf8:	72657069 	.word	0x72657069
    4cfc:	203a7366 	.word	0x203a7366
    4d00:	202c4b4f 	.word	0x202c4b4f
    4d04:	20746573 	.word	0x20746573
    4d08:	74736e69 	.word	0x74736e69
    4d0c:	65636e61 	.word	0x65636e61
    4d10:	20642520 	.word	0x20642520
    4d14:	73207872 	.word	0x73207872
    4d18:	20657a69 	.word	0x20657a69
    4d1c:	25206f74 	.word	0x25206f74
    4d20:	000a0d64 	.word	0x000a0d64
    4d24:	72657069 	.word	0x72657069
    4d28:	203a7366 	.word	0x203a7366
    4d2c:	202c4b4f 	.word	0x202c4b4f
    4d30:	20746573 	.word	0x20746573
    4d34:	74736e69 	.word	0x74736e69
    4d38:	65636e61 	.word	0x65636e61
    4d3c:	20642520 	.word	0x20642520
    4d40:	73207874 	.word	0x73207874
    4d44:	20657a69 	.word	0x20657a69
    4d48:	25206f74 	.word	0x25206f74
    4d4c:	000a0d64 	.word	0x000a0d64
    4d50:	72657069 	.word	0x72657069
    4d54:	203a6b66 	.word	0x203a6b66
    4d58:	6e697355 	.word	0x6e697355
    4d5c:	6e692067 	.word	0x6e692067
    4d60:	20786564 	.word	0x20786564
    4d64:	000a0d30 	.word	0x000a0d30
    4d68:	70690a0d 	.word	0x70690a0d
    4d6c:	20667265 	.word	0x20667265
    4d70:	73736573 	.word	0x73736573
    4d74:	3a6e6f69 	.word	0x3a6e6f69
    4d78:	746f6e20 	.word	0x746f6e20
    4d7c:	61747320 	.word	0x61747320
    4d80:	64657472 	.word	0x64657472
    4d84:	000a0d21 	.word	0x000a0d21
    4d88:	70690a0d 	.word	0x70690a0d
    4d8c:	3a667265 	.word	0x3a667265
    4d90:	79727420 	.word	0x79727420
    4d94:	20676e69 	.word	0x20676e69
    4d98:	73206f74 	.word	0x73206f74
    4d9c:	20706f74 	.word	0x20706f74
    4da0:	72657069 	.word	0x72657069
    4da4:	6e692066 	.word	0x6e692066
    4da8:	6e617473 	.word	0x6e617473
    4dac:	25206563 	.word	0x25206563
    4db0:	2e2e2e64 	.word	0x2e2e2e64
    4db4:	00000a0d 	.word	0x00000a0d
    4db8:	67617355 	.word	0x67617355
    4dbc:	69203a65 	.word	0x69203a65
    4dc0:	66726570 	.word	0x66726570
    4dc4:	2d3c206b 	.word	0x2d3c206b
    4dc8:	6e692069 	.word	0x6e692069
    4dcc:	3e786564 	.word	0x3e786564
    4dd0:	00000a0d 	.word	0x00000a0d
    4dd4:	0000612d 	.word	0x0000612d
    4dd8:	72657069 	.word	0x72657069
    4ddc:	203a6966 	.word	0x203a6966
    4de0:	20657375 	.word	0x20657375
    4de4:	61762061 	.word	0x61762061
    4de8:	2064696c 	.word	0x2064696c
    4dec:	61205049 	.word	0x61205049
    4df0:	65726464 	.word	0x65726464
    4df4:	0d217373 	.word	0x0d217373
    4df8:	0000000a 	.word	0x0000000a
    4dfc:	67617355 	.word	0x67617355
    4e00:	69203a65 	.word	0x69203a65
    4e04:	66726570 	.word	0x66726570
    4e08:	612d2069 	.word	0x612d2069
    4e0c:	64646120 	.word	0x64646120
    4e10:	73736572 	.word	0x73736572
    4e14:	692d3c20 	.word	0x692d3c20
    4e18:	646e6920 	.word	0x646e6920
    4e1c:	0d3e7865 	.word	0x0d3e7865
    4e20:	0000000a 	.word	0x0000000a
    4e24:	70690a0d 	.word	0x70690a0d
    4e28:	69667265 	.word	0x69667265
    4e2c:	6163203a 	.word	0x6163203a
    4e30:	746f6e6e 	.word	0x746f6e6e
    4e34:	61686320 	.word	0x61686320
    4e38:	2065676e 	.word	0x2065676e
    4e3c:	20656874 	.word	0x20656874
    4e40:	61207069 	.word	0x61207069
    4e44:	65726464 	.word	0x65726464
    4e48:	77207373 	.word	0x77207373
    4e4c:	656c6968 	.word	0x656c6968
    4e50:	73657320 	.word	0x73657320
    4e54:	6e6f6973 	.word	0x6e6f6973
    4e58:	6425203a 	.word	0x6425203a
    4e5c:	6e757220 	.word	0x6e757220
    4e60:	676e696e 	.word	0x676e696e
    4e64:	000a0d21 	.word	0x000a0d21
    4e68:	72657069 	.word	0x72657069
    4e6c:	203a6966 	.word	0x203a6966
    4e70:	202c4b4f 	.word	0x202c4b4f
    4e74:	20746573 	.word	0x20746573
    4e78:	20656874 	.word	0x20656874
    4e7c:	61205049 	.word	0x61205049
    4e80:	65726464 	.word	0x65726464
    4e84:	74207373 	.word	0x74207373
    4e88:	6e69206f 	.word	0x6e69206f
    4e8c:	6e617473 	.word	0x6e617473
    4e90:	203a6563 	.word	0x203a6563
    4e94:	0a0d6425 	.word	0x0a0d6425
    4e98:	00000000 	.word	0x00000000
    4e9c:	0000732d 	.word	0x0000732d
    4ea0:	65732d2d 	.word	0x65732d2d
    4ea4:	72657672 	.word	0x72657672
    4ea8:	00000000 	.word	0x00000000
    4eac:	0000752d 	.word	0x0000752d
    4eb0:	64752d2d 	.word	0x64752d2d
    4eb4:	00000070 	.word	0x00000070
    4eb8:	0000622d 	.word	0x0000622d
    4ebc:	61622d2d 	.word	0x61622d2d
    4ec0:	6977646e 	.word	0x6977646e
    4ec4:	00687464 	.word	0x00687464
    4ec8:	0000004d 	.word	0x0000004d
    4ecc:	0000004b 	.word	0x0000004b
    4ed0:	7669470a 	.word	0x7669470a
    4ed4:	69206e65 	.word	0x69206e65
    4ed8:	5742206e 	.word	0x5742206e
    4edc:	6c25203a 	.word	0x6c25203a
    4ee0:	6c252b75 	.word	0x6c252b75
    4ee4:	6c253d75 	.word	0x6c253d75
    4ee8:	00000075 	.word	0x00000075
    4eec:	0000782d 	.word	0x0000782d
    4ef0:	6d782d2d 	.word	0x6d782d2d
    4ef4:	61727469 	.word	0x61727469
    4ef8:	00006574 	.word	0x00006574
    4efc:	0000632d 	.word	0x0000632d
    4f00:	6c632d2d 	.word	0x6c632d2d
    4f04:	746e6569 	.word	0x746e6569
    4f08:	00000000 	.word	0x00000000
    4f0c:	0000742d 	.word	0x0000742d
    4f10:	69742d2d 	.word	0x69742d2d
    4f14:	0000656d 	.word	0x0000656d
    4f18:	00006e2d 	.word	0x00006e2d
    4f1c:	756e2d2d 	.word	0x756e2d2d
    4f20:	0000006d 	.word	0x0000006d
    4f24:	0000532d 	.word	0x0000532d
    4f28:	6f742d2d 	.word	0x6f742d2d
    4f2c:	00000073 	.word	0x00000073
    4f30:	7669470a 	.word	0x7669470a
    4f34:	54206e65 	.word	0x54206e65
    4f38:	7620534f 	.word	0x7620534f
    4f3c:	65756c61 	.word	0x65756c61
    4f40:	20736920 	.word	0x20736920
    4f44:	202c6425 	.word	0x202c6425
    4f48:	7079546d 	.word	0x7079546d
    4f4c:	53664f65 	.word	0x53664f65
    4f50:	69767265 	.word	0x69767265
    4f54:	253a6563 	.word	0x253a6563
    4f58:	00000064 	.word	0x00000064
    4f5c:	00004d2d 	.word	0x00004d2d
    4f60:	736d2d2d 	.word	0x736d2d2d
    4f64:	00000073 	.word	0x00000073
    4f68:	6e692d2d 	.word	0x6e692d2d
    4f6c:	76726574 	.word	0x76726574
    4f70:	00006c61 	.word	0x00006c61
    4f74:	0000702d 	.word	0x0000702d
    4f78:	6f702d2d 	.word	0x6f702d2d
    4f7c:	00007472 	.word	0x00007472
    4f80:	00006c2d 	.word	0x00006c2d
    4f84:	656c2d2d 	.word	0x656c2d2d
    4f88:	0000006e 	.word	0x0000006e
    4f8c:	72657069 	.word	0x72657069
    4f90:	54203a66 	.word	0x54203a66
    4f94:	6d206568 	.word	0x6d206568
    4f98:	6d696e69 	.word	0x6d696e69
    4f9c:	64206d75 	.word	0x64206d75
    4fa0:	67617461 	.word	0x67617461
    4fa4:	206d6172 	.word	0x206d6172
    4fa8:	657a6973 	.word	0x657a6973
    4fac:	20736920 	.word	0x20736920
    4fb0:	0a0d6425 	.word	0x0a0d6425
    4fb4:	00000000 	.word	0x00000000
    4fb8:	72657069 	.word	0x72657069
    4fbc:	55203a66 	.word	0x55203a66
    4fc0:	676e6973 	.word	0x676e6973
    4fc4:	65687420 	.word	0x65687420
    4fc8:	66656420 	.word	0x66656420
    4fcc:	746c7561 	.word	0x746c7561
    4fd0:	746e6920 	.word	0x746e6920
    4fd4:	61667265 	.word	0x61667265
    4fd8:	0d216563 	.word	0x0d216563
    4fdc:	0000000a 	.word	0x0000000a
    4fe0:	2d2d2d2d 	.word	0x2d2d2d2d
    4fe4:	2d2d2d2d 	.word	0x2d2d2d2d
    4fe8:	2d2d2d2d 	.word	0x2d2d2d2d
    4fec:	2d2d2d2d 	.word	0x2d2d2d2d
    4ff0:	2d2d2d2d 	.word	0x2d2d2d2d
    4ff4:	2d2d2d2d 	.word	0x2d2d2d2d
    4ff8:	2d2d2d2d 	.word	0x2d2d2d2d
    4ffc:	2d2d2d2d 	.word	0x2d2d2d2d
    5000:	2d2d2d2d 	.word	0x2d2d2d2d
    5004:	2d2d2d2d 	.word	0x2d2d2d2d
    5008:	2d2d2d2d 	.word	0x2d2d2d2d
    500c:	2d2d2d2d 	.word	0x2d2d2d2d
    5010:	2d2d2d2d 	.word	0x2d2d2d2d
    5014:	2d2d2d2d 	.word	0x2d2d2d2d
    5018:	000a0d2d 	.word	0x000a0d2d
    501c:	72657069 	.word	0x72657069
    5020:	53203a66 	.word	0x53203a66
    5024:	65767265 	.word	0x65767265
    5028:	696c2072 	.word	0x696c2072
    502c:	6e657473 	.word	0x6e657473
    5030:	20676e69 	.word	0x20676e69
    5034:	00206e6f 	.word	0x00206e6f
    5038:	00504455 	.word	0x00504455
    503c:	00504354 	.word	0x00504354
    5040:	726f7020 	.word	0x726f7020
    5044:	64252074 	.word	0x64252074
    5048:	00000a0d 	.word	0x00000a0d
    504c:	70690a0d 	.word	0x70690a0d
    5050:	3a667265 	.word	0x3a667265
    5054:	6c6c4120 	.word	0x6c6c4120
    5058:	736e6920 	.word	0x736e6920
    505c:	636e6174 	.word	0x636e6174
    5060:	62207365 	.word	0x62207365
    5064:	2e797375 	.word	0x2e797375
    5068:	74655220 	.word	0x74655220
    506c:	6c207972 	.word	0x6c207972
    5070:	72657461 	.word	0x72657461
    5074:	000a0d21 	.word	0x000a0d21
    5078:	70690a0d 	.word	0x70690a0d
    507c:	3a667265 	.word	0x3a667265
    5080:	61745320 	.word	0x61745320
    5084:	6e697472 	.word	0x6e697472
    5088:	65732067 	.word	0x65732067
    508c:	6f697373 	.word	0x6f697373
    5090:	6e69206e 	.word	0x6e69206e
    5094:	6e617473 	.word	0x6e617473
    5098:	25206563 	.word	0x25206563
    509c:	000a0d64 	.word	0x000a0d64
    50a0:	756c3425 	.word	0x756c3425
    50a4:	70624b20 	.word	0x70624b20
    50a8:	00000073 	.word	0x00000073
    50ac:	20202020 	.word	0x20202020
    50b0:	255b202d 	.word	0x255b202d
    50b4:	2d756c32 	.word	0x2d756c32
    50b8:	6c322520 	.word	0x6c322520
    50bc:	65732075 	.word	0x65732075
    50c0:	25205d63 	.word	0x25205d63
    50c4:	2f756c33 	.word	0x2f756c33
    50c8:	6c332520 	.word	0x6c332520
    50cc:	25282075 	.word	0x25282075
    50d0:	25756c32 	.word	0x25756c32
    50d4:	20202925 	.word	0x20202925
    50d8:	34252020 	.word	0x34252020
    50dc:	4b20756c 	.word	0x4b20756c
    50e0:	0d737062 	.word	0x0d737062
    50e4:	0000000a 	.word	0x0000000a
    50e8:	3a475641 	.word	0x3a475641
    50ec:	6c342520 	.word	0x6c342520
    50f0:	624b2075 	.word	0x624b2075
    50f4:	00007370 	.word	0x00007370
    50f8:	72657069 	.word	0x72657069
    50fc:	6f642066 	.word	0x6f642066
    5100:	0000656e 	.word	0x0000656e
    5104:	20202020 	.word	0x20202020
    5108:	305b202d 	.word	0x305b202d
    510c:	202d302e 	.word	0x202d302e
    5110:	2e756c25 	.word	0x2e756c25
    5114:	20756c25 	.word	0x20756c25
    5118:	5d636573 	.word	0x5d636573
    511c:	6c332520 	.word	0x6c332520
    5120:	25202f75 	.word	0x25202f75
    5124:	20756c33 	.word	0x20756c33
    5128:	6c322528 	.word	0x6c322528
    512c:	29252575 	.word	0x29252575
    5130:	20202020 	.word	0x20202020
    5134:	756c3425 	.word	0x756c3425
    5138:	70624b20 	.word	0x70624b20
    513c:	000a0d73 	.word	0x000a0d73
    5140:	72657069 	.word	0x72657069
    5144:	69203a66 	.word	0x69203a66
    5148:	6174736e 	.word	0x6174736e
    514c:	2065636e 	.word	0x2065636e
    5150:	63206425 	.word	0x63206425
    5154:	6c706d6f 	.word	0x6c706d6f
    5158:	64657465 	.word	0x64657465
    515c:	00000d0a 	.word	0x00000d0a
    5160:	72657069 	.word	0x72657069
    5164:	53203a66 	.word	0x53203a66
    5168:	656b636f 	.word	0x656b636f
    516c:	65732074 	.word	0x65732074
    5170:	6620646e 	.word	0x6620646e
    5174:	656c6961 	.word	0x656c6961
    5178:	000a0d64 	.word	0x000a0d64
    517c:	70690a0d 	.word	0x70690a0d
    5180:	3a667265 	.word	0x3a667265
    5184:	736e6920 	.word	0x736e6920
    5188:	636e6174 	.word	0x636e6174
    518c:	64252065 	.word	0x64252065
    5190:	61747320 	.word	0x61747320
    5194:	64657472 	.word	0x64657472
    5198:	2e2e2e20 	.word	0x2e2e2e20
    519c:	00000a0d 	.word	0x00000a0d
    51a0:	20202020 	.word	0x20202020
    51a4:	6f4c202d 	.word	0x6f4c202d
    51a8:	206c6163 	.word	0x206c6163
    51ac:	2e752520 	.word	0x2e752520
    51b0:	252e7525 	.word	0x252e7525
    51b4:	75252e75 	.word	0x75252e75
    51b8:	726f7020 	.word	0x726f7020
    51bc:	75252074 	.word	0x75252074
    51c0:	6e6f6320 	.word	0x6e6f6320
    51c4:	7463656e 	.word	0x7463656e
    51c8:	77206465 	.word	0x77206465
    51cc:	0d687469 	.word	0x0d687469
    51d0:	0000000a 	.word	0x0000000a
    51d4:	20202020 	.word	0x20202020
    51d8:	6552202d 	.word	0x6552202d
    51dc:	65746f6d 	.word	0x65746f6d
    51e0:	2e752520 	.word	0x2e752520
    51e4:	252e7525 	.word	0x252e7525
    51e8:	75252e75 	.word	0x75252e75
    51ec:	726f7020 	.word	0x726f7020
    51f0:	75252074 	.word	0x75252074
    51f4:	00000a0d 	.word	0x00000a0d
    51f8:	20202020 	.word	0x20202020
    51fc:	6154202d 	.word	0x6154202d
    5200:	74656772 	.word	0x74656772
    5204:	74617220 	.word	0x74617220
    5208:	203d2065 	.word	0x203d2065
    520c:	20646c25 	.word	0x20646c25
    5210:	2c737062 	.word	0x2c737062
    5214:	72657020 	.word	0x72657020
    5218:	20646f69 	.word	0x20646f69
    521c:	6c25203d 	.word	0x6c25203d
    5220:	736d2064 	.word	0x736d2064
    5224:	00000a0d 	.word	0x00000a0d
    5228:	20202020 	.word	0x20202020
    522c:	2d2d2d2d 	.word	0x2d2d2d2d
    5230:	2d2d2d2d 	.word	0x2d2d2d2d
    5234:	2d2d2d2d 	.word	0x2d2d2d2d
    5238:	2d2d2d2d 	.word	0x2d2d2d2d
    523c:	2d2d2d2d 	.word	0x2d2d2d2d
    5240:	2d2d2d2d 	.word	0x2d2d2d2d
    5244:	2d2d2d2d 	.word	0x2d2d2d2d
    5248:	2d2d2d2d 	.word	0x2d2d2d2d
    524c:	2d2d2d2d 	.word	0x2d2d2d2d
    5250:	2d2d2d2d 	.word	0x2d2d2d2d
    5254:	000a0d2d 	.word	0x000a0d2d
    5258:	70690a0d 	.word	0x70690a0d
    525c:	3a667265 	.word	0x3a667265
    5260:	72615720 	.word	0x72615720
    5264:	676e696e 	.word	0x676e696e
    5268:	4354202c 	.word	0x4354202c
    526c:	65732050 	.word	0x65732050
    5270:	72657672 	.word	0x72657672
    5274:	73696420 	.word	0x73696420
    5278:	6e6e6f63 	.word	0x6e6e6f63
    527c:	20746365 	.word	0x20746365
    5280:	65746564 	.word	0x65746564
    5284:	64657463 	.word	0x64657463
    5288:	00000a0d 	.word	0x00000a0d
    528c:	72657069 	.word	0x72657069
    5290:	46203a66 	.word	0x46203a66
    5294:	656c6961 	.word	0x656c6961
    5298:	6f742064 	.word	0x6f742064
    529c:	74656720 	.word	0x74656720
    52a0:	20642520 	.word	0x20642520
    52a4:	65747962 	.word	0x65747962
    52a8:	6f732073 	.word	0x6f732073
    52ac:	74656b63 	.word	0x74656b63
    52b0:	20585420 	.word	0x20585420
    52b4:	63617073 	.word	0x63617073
    52b8:	000a0d65 	.word	0x000a0d65
    52bc:	72657069 	.word	0x72657069
    52c0:	55203a66 	.word	0x55203a66
    52c4:	7075736e 	.word	0x7075736e
    52c8:	74726f70 	.word	0x74726f70
    52cc:	43206465 	.word	0x43206465
    52d0:	69666e6f 	.word	0x69666e6f
    52d4:	61727567 	.word	0x61727567
    52d8:	6e6f6974 	.word	0x6e6f6974
    52dc:	00000a0d 	.word	0x00000a0d
    52e0:	72657069 	.word	0x72657069
    52e4:	43203a66 	.word	0x43203a66
    52e8:	74616572 	.word	0x74616572
    52ec:	43542065 	.word	0x43542065
    52f0:	6f732050 	.word	0x6f732050
    52f4:	74656b63 	.word	0x74656b63
    52f8:	69616620 	.word	0x69616620
    52fc:	0d64656c 	.word	0x0d64656c
    5300:	0000000a 	.word	0x0000000a
    5304:	72657069 	.word	0x72657069
    5308:	53203a66 	.word	0x53203a66
    530c:	6f207465 	.word	0x6f207465
    5310:	58522066 	.word	0x58522066
    5314:	66756220 	.word	0x66756220
    5318:	20726566 	.word	0x20726566
    531c:	657a6973 	.word	0x657a6973
    5320:	69616620 	.word	0x69616620
    5324:	0d64656c 	.word	0x0d64656c
    5328:	0000000a 	.word	0x0000000a
    532c:	72657069 	.word	0x72657069
    5330:	43203a66 	.word	0x43203a66
    5334:	74616572 	.word	0x74616572
    5338:	44552065 	.word	0x44552065
    533c:	6f732050 	.word	0x6f732050
    5340:	74656b63 	.word	0x74656b63
    5344:	69616620 	.word	0x69616620
    5348:	0d64656c 	.word	0x0d64656c
    534c:	0000000a 	.word	0x0000000a
    5350:	72657069 	.word	0x72657069
    5354:	50203a66 	.word	0x50203a66
    5358:	6f746f72 	.word	0x6f746f72
    535c:	206c6f63 	.word	0x206c6f63
    5360:	6f727265 	.word	0x6f727265
    5364:	000a0d72 	.word	0x000a0d72
    5368:	72657069 	.word	0x72657069
    536c:	55203a66 	.word	0x55203a66
    5370:	47205044 	.word	0x47205044
    5374:	41207465 	.word	0x41207465
    5378:	79617272 	.word	0x79617272
    537c:	69614620 	.word	0x69614620
    5380:	0d64656c 	.word	0x0d64656c
    5384:	0000000a 	.word	0x0000000a
    5388:	72657069 	.word	0x72657069
    538c:	2d203a66 	.word	0x2d203a66
    5390:	72694620 	.word	0x72694620
    5394:	70207473 	.word	0x70207473
    5398:	6920746b 	.word	0x6920746b
    539c:	203d2064 	.word	0x203d2064
    53a0:	20646c25 	.word	0x20646c25
    53a4:	6f687328 	.word	0x6f687328
    53a8:	20646c75 	.word	0x20646c75
    53ac:	30206562 	.word	0x30206562
    53b0:	000a0d29 	.word	0x000a0d29
    53b4:	72657069 	.word	0x72657069
    53b8:	52203a66 	.word	0x52203a66
    53bc:	20766365 	.word	0x20766365
    53c0:	6c707564 	.word	0x6c707564
    53c4:	74616369 	.word	0x74616369
    53c8:	70206465 	.word	0x70206465
    53cc:	0a0d746b 	.word	0x0a0d746b
    53d0:	00000000 	.word	0x00000000
    53d4:	72657069 	.word	0x72657069
    53d8:	52203a66 	.word	0x52203a66
    53dc:	69742078 	.word	0x69742078
    53e0:	2064656d 	.word	0x2064656d
    53e4:	0d74756f 	.word	0x0d74756f
    53e8:	0000000a 	.word	0x0000000a
    53ec:	70690a0d 	.word	0x70690a0d
    53f0:	3a667265 	.word	0x3a667265
    53f4:	736e6920 	.word	0x736e6920
    53f8:	636e6174 	.word	0x636e6174
    53fc:	64252065 	.word	0x64252065
    5400:	73657320 	.word	0x73657320
    5404:	6e6f6973 	.word	0x6e6f6973
    5408:	61747320 	.word	0x61747320
    540c:	64657472 	.word	0x64657472
    5410:	2e2e2e20 	.word	0x2e2e2e20
    5414:	00000a0d 	.word	0x00000a0d
    5418:	70690a0d 	.word	0x70690a0d
    541c:	20667265 	.word	0x20667265
    5420:	74736e69 	.word	0x74736e69
    5424:	65636e61 	.word	0x65636e61
    5428:	3a642520 	.word	0x3a642520
    542c:	20785220 	.word	0x20785220
    5430:	656e6f64 	.word	0x656e6f64
    5434:	6f53202e 	.word	0x6f53202e
    5438:	74656b63 	.word	0x74656b63
    543c:	6f6c6320 	.word	0x6f6c6320
    5440:	2e646573 	.word	0x2e646573
    5444:	00000a0d 	.word	0x00000a0d
    5448:	72657069 	.word	0x72657069
    544c:	6e692066 	.word	0x6e692066
    5450:	6e617473 	.word	0x6e617473
    5454:	25206563 	.word	0x25206563
    5458:	52203a64 	.word	0x52203a64
    545c:	79646165 	.word	0x79646165
    5460:	726f6620 	.word	0x726f6620
    5464:	65687420 	.word	0x65687420
    5468:	78656e20 	.word	0x78656e20
    546c:	65732074 	.word	0x65732074
    5470:	6f697373 	.word	0x6f697373
    5474:	0a0d2e6e 	.word	0x0a0d2e6e
    5478:	00000000 	.word	0x00000000
    547c:	72657069 	.word	0x72657069
    5480:	6e692066 	.word	0x6e692066
    5484:	6e617473 	.word	0x6e617473
    5488:	25206563 	.word	0x25206563
    548c:	63203a64 	.word	0x63203a64
    5490:	6c706d6f 	.word	0x6c706d6f
    5494:	64657465 	.word	0x64657465
    5498:	000a0d2e 	.word	0x000a0d2e
    549c:	72657069 	.word	0x72657069
    54a0:	63203a66 	.word	0x63203a66
    54a4:	6e65696c 	.word	0x6e65696c
    54a8:	65732074 	.word	0x65732074
    54ac:	6f697373 	.word	0x6f697373
    54b0:	6c63206e 	.word	0x6c63206e
    54b4:	6465736f 	.word	0x6465736f
    54b8:	000a0d2e 	.word	0x000a0d2e
    54bc:	72657069 	.word	0x72657069
    54c0:	41203a66 	.word	0x41203a66
    54c4:	75205052 	.word	0x75205052
    54c8:	6c62616e 	.word	0x6c62616e
    54cc:	6f742065 	.word	0x6f742065
    54d0:	73657220 	.word	0x73657220
    54d4:	65766c6f 	.word	0x65766c6f
    54d8:	65687420 	.word	0x65687420
    54dc:	43414d20 	.word	0x43414d20
    54e0:	64646120 	.word	0x64646120
    54e4:	73736572 	.word	0x73736572
    54e8:	20666f20 	.word	0x20666f20
    54ec:	6f6d6572 	.word	0x6f6d6572
    54f0:	73206574 	.word	0x73206574
    54f4:	2e656469 	.word	0x2e656469
    54f8:	00000a0d 	.word	0x00000a0d
    54fc:	20202020 	.word	0x20202020
    5500:	6552202d 	.word	0x6552202d
    5504:	65746f6d 	.word	0x65746f6d
    5508:	65646f4e 	.word	0x65646f4e
    550c:	43414d20 	.word	0x43414d20
    5510:	7825203a 	.word	0x7825203a
    5514:	20782520 	.word	0x20782520
    5518:	25207825 	.word	0x25207825
    551c:	78252078 	.word	0x78252078
    5520:	0d782520 	.word	0x0d782520
    5524:	0000000a 	.word	0x0000000a
    5528:	72657069 	.word	0x72657069
    552c:	53203a66 	.word	0x53203a66
    5530:	6f207465 	.word	0x6f207465
    5534:	58542066 	.word	0x58542066
    5538:	66756220 	.word	0x66756220
    553c:	20726566 	.word	0x20726566
    5540:	657a6973 	.word	0x657a6973
    5544:	69616620 	.word	0x69616620
    5548:	0d64656c 	.word	0x0d64656c
    554c:	0000000a 	.word	0x0000000a
    5550:	72657069 	.word	0x72657069
    5554:	53203a66 	.word	0x53203a66
    5558:	6f207465 	.word	0x6f207465
    555c:	58542066 	.word	0x58542066
    5560:	65757120 	.word	0x65757120
    5564:	676e6975 	.word	0x676e6975
    5568:	6d696c20 	.word	0x6d696c20
    556c:	66207469 	.word	0x66207469
    5570:	656c6961 	.word	0x656c6961
    5574:	000a0d64 	.word	0x000a0d64
    5578:	72657069 	.word	0x72657069
    557c:	43203a66 	.word	0x43203a66
    5580:	6e65696c 	.word	0x6e65696c
    5584:	6f632074 	.word	0x6f632074
    5588:	63656e6e 	.word	0x63656e6e
    558c:	676e6974 	.word	0x676e6974
    5590:	206f7420 	.word	0x206f7420
    5594:	252e7525 	.word	0x252e7525
    5598:	75252e75 	.word	0x75252e75
    559c:	2c75252e 	.word	0x2c75252e
    55a0:	50445520 	.word	0x50445520
    55a4:	726f7020 	.word	0x726f7020
    55a8:	75252074 	.word	0x75252074
    55ac:	00000a0d 	.word	0x00000a0d
    55b0:	72657069 	.word	0x72657069
    55b4:	43203a66 	.word	0x43203a66
    55b8:	6e65696c 	.word	0x6e65696c
    55bc:	6f632074 	.word	0x6f632074
    55c0:	63656e6e 	.word	0x63656e6e
    55c4:	676e6974 	.word	0x676e6974
    55c8:	206f7420 	.word	0x206f7420
    55cc:	252e7525 	.word	0x252e7525
    55d0:	75252e75 	.word	0x75252e75
    55d4:	2c75252e 	.word	0x2c75252e
    55d8:	50435420 	.word	0x50435420
    55dc:	726f7020 	.word	0x726f7020
    55e0:	75252074 	.word	0x75252074
    55e4:	00000a0d 	.word	0x00000a0d
    55e8:	72657069 	.word	0x72657069
    55ec:	54203a66 	.word	0x54203a66
    55f0:	43205043 	.word	0x43205043
    55f4:	6e65696c 	.word	0x6e65696c
    55f8:	6f632074 	.word	0x6f632074
    55fc:	63656e6e 	.word	0x63656e6e
    5600:	6e6f6974 	.word	0x6e6f6974
    5604:	6d697420 	.word	0x6d697420
    5608:	74756f65 	.word	0x74756f65
    560c:	00000a0d 	.word	0x00000a0d
    5610:	7069203a 	.word	0x7069203a
    5614:	20667265 	.word	0x20667265
    5618:	6d6d6f63 	.word	0x6d6d6f63
    561c:	73646e61 	.word	0x73646e61
    5620:	00000000 	.word	0x00000000
    5624:	72657069 	.word	0x72657069
    5628:	00000066 	.word	0x00000066
    562c:	3c20203a 	.word	0x3c20203a
    5630:	72657069 	.word	0x72657069
    5634:	73203e66 	.word	0x73203e66
    5638:	74726174 	.word	0x74726174
    563c:	646d6320 	.word	0x646d6320
    5640:	00000000 	.word	0x00000000
    5644:	72657069 	.word	0x72657069
    5648:	00006b66 	.word	0x00006b66
    564c:	693c203a 	.word	0x693c203a
    5650:	66726570 	.word	0x66726570
    5654:	6b203e6b 	.word	0x6b203e6b
    5658:	206c6c69 	.word	0x206c6c69
    565c:	00646d63 	.word	0x00646d63
    5660:	72657069 	.word	0x72657069
    5664:	00006966 	.word	0x00006966
    5668:	693c203a 	.word	0x693c203a
    566c:	66726570 	.word	0x66726570
    5670:	64612069 	.word	0x64612069
    5674:	73657264 	.word	0x73657264
    5678:	20203e73 	.word	0x20203e73
    567c:	65746e69 	.word	0x65746e69
    5680:	63616672 	.word	0x63616672
    5684:	6d632065 	.word	0x6d632065
    5688:	00000064 	.word	0x00000064
    568c:	72657069 	.word	0x72657069
    5690:	00007366 	.word	0x00007366
    5694:	693c203a 	.word	0x693c203a
    5698:	66726570 	.word	0x66726570
    569c:	78742073 	.word	0x78742073
    56a0:	2078722f 	.word	0x2078722f
    56a4:	657a6973 	.word	0x657a6973
    56a8:	7874203e 	.word	0x7874203e
    56ac:	2078722f 	.word	0x2078722f
    56b0:	657a6973 	.word	0x657a6973
    56b4:	646d6320 	.word	0x646d6320
    56b8:	00          	.byte	0x00
    56b9:	00          	.byte	0x00
    56ba:	bf00      	nop

Disassembly of section .rodata.macPIC32CHwRegDcpt%193:

000056bc <macPIC32CHwRegDcpt>:
    56bc:	7854 4220 7479 2065 6f43 6e75 2d74 6f6c     Tx Byte Count-lo
    56cc:	6577 2072 3233 6962 7374 5428 4f78 4c54     wer 32bits(TxOTL
    56dc:	294f 0000 1c65 0002 7854 4220 7479 2065     O)..e...Tx Byte 
    56ec:	6f43 6e75 2d74 7075 6570 2072 3631 6962     Count-upper 16bi
    56fc:	7374 5428 4f78 4854 2949 0000 1c71 0002     ts(TxOTHI)..q...
    570c:	7854 4620 6172 656d 2073 2f77 206f 7265     Tx Frames w/o er
    571c:	6f72 2872 7854 5446 4e43 2954 0000 0000     ror(TxFTCNT)....
    572c:	0000 0000 1c7d 0002 7854 4220 6f72 6461     ....}...Tx Broad
    573c:	6163 7473 4620 6172 656d 2873 7854 4342     cast Frames(TxBC
    574c:	5446 0029 0000 0000 0000 0000 1c89 0002     FT).............
    575c:	7854 4d20 6c75 6974 6163 7473 4620 6172     Tx Multicast Fra
    576c:	656d 2873 7854 464d 2954 0000 0000 0000     mes(TxMFT)......
    577c:	0000 0000 1c95 0002 7854 5020 7561 6573     ........Tx Pause
    578c:	4620 6172 656d 2873 7854 4650 2954 0000      Frames(TxPFT)..
	...
    57a8:	1ca1 0002 7854 3620 2d34 7962 6574 4620     ....Tx 64-byte F
    57b8:	6172 656d 2873 7854 4642 3654 2934 0000     rames(TxBFT64)..
	...
    57d0:	1cad 0002 7854 3620 2d35 3231 2037 7962     ....Tx 65-127 by
    57e0:	6574 4620 6172 656d 2873 4254 5446 3231     te Frames(TBFT12
    57f0:	2937 0000 0000 0000 1cb9 0002 7854 3120     7)..........Tx 1
    5800:	3832 322d 3535 6220 7479 2065 7246 6d61     28-255 byte Fram
    5810:	7365 5428 4642 3254 3535 0029 0000 0000     es(TBFT255).....
    5820:	1cc5 0002 7854 3220 3635 352d 3131 6220     ....Tx 256-511 b
    5830:	7479 2065 7246 6d61 7365 5428 4642 3554     yte Frames(TBFT5
    5840:	3131 0029 0000 0000 1cd1 0002 7854 3520     11).........Tx 5
    5850:	3231 312d 3230 2033 7962 6574 4620 6172     12-1023 byte Fra
    5860:	656d 2873 4254 5446 3031 3332 0029 0000     mes(TBFT1023)...
    5870:	1cdd 0002 7854 3120 3230 2d34 3531 3831     ....Tx 1024-1518
    5880:	6220 7479 2065 7246 6d61 7365 5428 4642      byte Frames(TBF
    5890:	3154 3135 2938 0000 1ce9 0002 7854 4620     T1518)......Tx F
    58a0:	6172 656d 2073 3d3e 3120 3135 2038 7962     rames >= 1518 by
    58b0:	6574 4728 4254 3146 3135 2938 0000 0000     te(GTBF1518)....
    58c0:	1cf5 0002 7854 5520 646e 7265 7572 206e     ....Tx Underrun 
    58d0:	7246 6d61 7365 6e20 746f 5420 6558 2864     Frames not TXed(
    58e0:	7854 5554 2952 0000 1d01 0002 7854 5320     TxTUR)......Tx S
    58f0:	6e69 6c67 2065 6f43 6c6c 7369 6f69 206e     ingle Collision 
    5900:	7246 6d61 7365 5428 5378 4643 0029 0000     Frames(TxSCF)...
    5910:	1d0d 0002 7854 3220 312d 2035 6f43 6c6c     ....Tx 2-15 Coll
    5920:	7369 6f69 206e 7246 6d61 7365 5428 4d78     ision Frames(TxM
    5930:	4643 0029 0000 0000 1d19 0002 7854 3120     CF).........Tx 1
    5940:	2036 6f43 6c6c 7369 6f69 206e 7246 6d61     6 Collision Fram
    5950:	7365 5428 4578 4343 544e 0029 0000 0000     es(TxECCNT).....
    5960:	1d25 0002 7854 6c20 7461 2065 6f43 6c6c     %...Tx late Coll
    5970:	7369 6f69 206e 7246 6d61 7365 5428 4c78     ision Frames(TxL
    5980:	4343 544e 0029 0000 1d31 0002 7854 4420     CCNT)...1...Tx D
    5990:	6665 7265 6572 2064 7246 6d61 7365 5428     eferred Frames(T
    59a0:	4478 4654 0029 0000 0000 0000 0000 0000     xDTF)...........
    59b0:	1d3d 0002 7854 4320 7261 6972 7265 5320     =...Tx Carrier S
    59c0:	6e65 6573 6520 7272 726f 4620 6172 656d     ense error Frame
    59d0:	2873 7854 5343 2945 1d49 0002 7852 4220     s(TxCSE)I...Rx B
    59e0:	7479 2065 6f43 6e75 2d74 6f6c 6577 2072     yte Count-lower 
    59f0:	3233 6962 7374 5228 4f78 4c52 294f 0000     32bits(RxORLO)..
    5a00:	1d55 0002 7852 4220 7479 2065 6f43 6e75     U...Rx Byte Coun
    5a10:	2d74 7075 6570 2072 3631 6962 7374 5228     t-upper 16bits(R
    5a20:	4f78 4852 2949 0000 1d61 0002 7852 4620     xORHI)..a...Rx F
    5a30:	6172 656d 2073 2f77 206f 7265 6f72 2872     rames w/o error(
    5a40:	7852 5246 4e43 2954 0000 0000 0000 0000     RxFRCNT)........
    5a50:	1d6d 0002 7852 4220 6f72 6461 6163 7473     m...Rx Broadcast
    5a60:	4620 6172 656d 2873 7852 4342 5246 0029      Frames(RxBCFR).
	...
    5a78:	1d79 0002 7852 4d20 6c75 6974 6163 7473     y...Rx Multicast
    5a88:	4620 6172 656d 2073 5228 4d78 5246 0029      Frames (RxMFR).
	...
    5aa0:	1d85 0002 7852 5020 7561 6573 4620 6172     ....Rx Pause Fra
    5ab0:	656d 2873 7852 4650 2952 0000 0000 0000     mes(RxPFR)......
	...
    5ac8:	1d91 0002 7852 3620 2d34 7962 6574 4620     ....Rx 64-byte F
    5ad8:	6172 656d 2873 7852 4642 3652 2934 0000     rames(RxBFR64)..
	...
    5af0:	1d9d 0002 7852 3620 2d35 3231 2037 7962     ....Rx 65-127 by
    5b00:	6574 4620 6172 656d 2873 4254 5246 3231     te Frames(TBFR12
    5b10:	2937 0000 0000 0000 1da9 0002 7852 3120     7)..........Rx 1
    5b20:	3832 322d 3535 6220 7479 2065 7246 6d61     28-255 byte Fram
    5b30:	7365 5428 4642 3252 3535 0029 0000 0000     es(TBFR255).....
    5b40:	1db5 0002 7852 3220 3635 352d 3131 6220     ....Rx 256-511 b
    5b50:	7479 2065 7246 6d61 7365 5428 4642 3552     yte Frames(TBFR5
    5b60:	3131 0029 0000 0000 1dc1 0002 7852 3520     11).........Rx 5
    5b70:	3231 312d 3230 2033 7962 6574 4620 6172     12-1023 byte Fra
    5b80:	656d 2873 4254 5246 3031 3332 0029 0000     mes(TBFR1023)...
    5b90:	1dcd 0002 7852 3120 3230 2d34 3531 3831     ....Rx 1024-1518
    5ba0:	6220 7479 2065 7246 6d61 7365 5428 4642      byte Frames(TBF
    5bb0:	3152 3135 2938 0000 1dd9 0002 7852 4620     R1518)......Rx F
    5bc0:	6172 656d 2073 3d3e 3120 3135 2039 7962     rames >= 1519 by
    5bd0:	6574 2873 4d54 4258 5246 0029 0000 0000     tes(TMXBFR).....
    5be0:	1de5 0002 7852 4620 6172 656d 2073 203c     ....Rx Frames < 
    5bf0:	3436 6220 7479 7365 5228 5578 5246 0029     64 bytes(RxUFR).
	...
    5c08:	1df1 0002 7852 4620 6172 656d 2073 203e     ....Rx Frames > 
    5c18:	3531 3831 6220 7479 7365 5228 4f78 5246     1518 bytes(RxOFR
    5c28:	0029 0000 0000 0000 1dfd 0002 7852 6520     )...........Rx e
    5c38:	7272 726f 4620 6172 656d 2073 203e 3531     rror Frames > 15
    5c48:	3831 6220 7479 7365 5228 4a78 2952 0000     18 bytes(RxJR)..
    5c58:	1e09 0002 7852 4320 4352 6520 7272 726f     ....Rx CRC error
    5c68:	4620 6172 656d 2873 7852 4346 4553 0029      Frames(RxFCSE).
	...
    5c80:	1e15 0002 7852 4c20 6e65 7467 2068 6966     ....Rx Length fi
    5c90:	6c65 2064 7265 6f72 2072 7246 6d61 7365     eld error Frames
    5ca0:	5228 4c78 4646 2945 1e21 0002 7852 7320     (RxLFFE)!...Rx s
    5cb0:	6d79 6f62 206c 7265 6f72 2072 7246 6d61     ymbol error Fram
    5cc0:	7365 5228 5278 4553 0029 0000 0000 0000     es(RxRSE).......
    5cd0:	1e2d 0002 7852 6120 696c 6e67 656d 746e     -...Rx alignment
    5ce0:	6520 7272 726f 4620 6172 656d 2873 7852      error Frames(Rx
    5cf0:	4541 0029 0000 0000 1e39 0002 7852 5220     AE).....9...Rx R
    5d00:	7365 756f 6372 2065 7245 6f72 2072 5228     esource Error (R
    5d10:	5278 4552 0029 0000 0000 0000 0000 0000     xRRE)...........
    5d20:	1e45 0002 7852 6f20 6576 7272 6e75 6520     E...Rx overrun e
    5d30:	7272 726f 4620 6172 656d 2873 7852 4f52     rror Frames(RxRO
    5d40:	2945 0000 0000 0000 1e51 0002 7852 4920     E)......Q...Rx I
    5d50:	4850 7264 4320 6b68 7573 206d 7265 6f72     PHdr Chksum erro
    5d60:	2072 7246 6d61 7365 5228 4978 4348 2945     r Frames(RxIHCE)
    5d70:	1e5d 0002 7852 5420 5043 4320 6b68 7573     ]...Rx TCP Chksu
    5d80:	206d 7265 6f72 2072 7246 6d61 7365 5228     m error Frames(R
    5d90:	5478 4543 0029 0000 1e69 0002 7852 5520     xTCE)...i...Rx U
    5da0:	5044 4320 6b68 7573 206d 7265 6f72 2072     DP Chksum error 
    5db0:	7246 6d61 7365 5228 5578 4543 0029 0000     Frames(RxUCE)...
    5dc0:	1e75 0002                                   u...

Disassembly of section .text.Transform%194:

00005dc4 <Transform>:

#define MD5STEP(f, w, x, y, z, data, s) \
        w = rotlFixed(w + f(x, y, z) + data, s) + x

static int Transform(wc_Md5* md5, const byte* data)
{
    5dc4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5dc8:	b08d      	sub	sp, #52	; 0x34
    word32* buffer = (word32*)data;
    /* Copy context->state[] to working vars  */
    word32 a = md5->digest[0];
    word32 b = md5->digest[1];
    5dca:	f8d0 a050 	ldr.w	sl, [r0, #80]	; 0x50
    word32 c = md5->digest[2];
    word32 d = md5->digest[3];

    MD5STEP(F1, a, b, c, d, buffer[0]  + 0xd76aa478,  7);
    5dce:	680a      	ldr	r2, [r1, #0]
    5dd0:	6d43      	ldr	r3, [r0, #84]	; 0x54
    5dd2:	6d84      	ldr	r4, [r0, #88]	; 0x58
    5dd4:	ea83 0e04 	eor.w	lr, r3, r4
    5dd8:	ea0e 0e0a 	and.w	lr, lr, sl
    5ddc:	ea8e 0e04 	eor.w	lr, lr, r4
    5de0:	4bd8      	ldr	r3, [pc, #864]	; (6144 <Transform+0x380>)
    5de2:	6cc4      	ldr	r4, [r0, #76]	; 0x4c
    5de4:	4423      	add	r3, r4
    5de6:	920a      	str	r2, [sp, #40]	; 0x28
    5de8:	4413      	add	r3, r2
    5dea:	449e      	add	lr, r3
    5dec:	eb0a 6e7e 	add.w	lr, sl, lr, ror #25
    MD5STEP(F1, d, a, b, c, buffer[1]  + 0xe8c7b756, 12);
    5df0:	684e      	ldr	r6, [r1, #4]
    5df2:	6d43      	ldr	r3, [r0, #84]	; 0x54
    5df4:	ea8a 0703 	eor.w	r7, sl, r3
    5df8:	ea07 070e 	and.w	r7, r7, lr
    5dfc:	405f      	eors	r7, r3
    5dfe:	4bd2      	ldr	r3, [pc, #840]	; (6148 <Transform+0x384>)
    5e00:	6d85      	ldr	r5, [r0, #88]	; 0x58
    5e02:	442b      	add	r3, r5
    5e04:	9600      	str	r6, [sp, #0]
    5e06:	4433      	add	r3, r6
    5e08:	441f      	add	r7, r3
    5e0a:	eb0e 5737 	add.w	r7, lr, r7, ror #20
    MD5STEP(F1, c, d, a, b, buffer[2]  + 0x242070db, 17);
    5e0e:	688b      	ldr	r3, [r1, #8]
    5e10:	461a      	mov	r2, r3
    5e12:	ea8a 050e 	eor.w	r5, sl, lr
    5e16:	403d      	ands	r5, r7
    5e18:	ea85 050a 	eor.w	r5, r5, sl
    5e1c:	4bcb      	ldr	r3, [pc, #812]	; (614c <Transform+0x388>)
    5e1e:	6d44      	ldr	r4, [r0, #84]	; 0x54
    5e20:	4423      	add	r3, r4
    5e22:	9201      	str	r2, [sp, #4]
    5e24:	4413      	add	r3, r2
    5e26:	441d      	add	r5, r3
    5e28:	eb07 35f5 	add.w	r5, r7, r5, ror #15
    MD5STEP(F1, b, c, d, a, buffer[3]  + 0xc1bdceee, 22);
    5e2c:	68cb      	ldr	r3, [r1, #12]
    5e2e:	461c      	mov	r4, r3
    5e30:	ea8e 0607 	eor.w	r6, lr, r7
    5e34:	402e      	ands	r6, r5
    5e36:	ea86 060e 	eor.w	r6, r6, lr
    5e3a:	4bc5      	ldr	r3, [pc, #788]	; (6150 <Transform+0x38c>)
    5e3c:	4453      	add	r3, sl
    5e3e:	9402      	str	r4, [sp, #8]
    5e40:	4423      	add	r3, r4
    5e42:	441e      	add	r6, r3
    5e44:	eb05 26b6 	add.w	r6, r5, r6, ror #10
    MD5STEP(F1, a, b, c, d, buffer[4]  + 0xf57c0faf,  7);
    5e48:	690b      	ldr	r3, [r1, #16]
    5e4a:	461c      	mov	r4, r3
    5e4c:	ea87 0305 	eor.w	r3, r7, r5
    5e50:	4033      	ands	r3, r6
    5e52:	407b      	eors	r3, r7
    5e54:	4abf      	ldr	r2, [pc, #764]	; (6154 <Transform+0x390>)
    5e56:	9403      	str	r4, [sp, #12]
    5e58:	4422      	add	r2, r4
    5e5a:	4496      	add	lr, r2
    5e5c:	4473      	add	r3, lr
    5e5e:	eb06 6973 	add.w	r9, r6, r3, ror #25
    MD5STEP(F1, d, a, b, c, buffer[5]  + 0x4787c62a, 12);
    5e62:	694a      	ldr	r2, [r1, #20]
    5e64:	4613      	mov	r3, r2
    5e66:	ea85 0406 	eor.w	r4, r5, r6
    5e6a:	ea04 0409 	and.w	r4, r4, r9
    5e6e:	406c      	eors	r4, r5
    5e70:	4ab9      	ldr	r2, [pc, #740]	; (6158 <Transform+0x394>)
    5e72:	9304      	str	r3, [sp, #16]
    5e74:	441a      	add	r2, r3
    5e76:	4417      	add	r7, r2
    5e78:	443c      	add	r4, r7
    5e7a:	eb09 5434 	add.w	r4, r9, r4, ror #20
    MD5STEP(F1, c, d, a, b, buffer[6]  + 0xa8304613, 17);
    5e7e:	698b      	ldr	r3, [r1, #24]
    5e80:	ea86 0209 	eor.w	r2, r6, r9
    5e84:	4022      	ands	r2, r4
    5e86:	4072      	eors	r2, r6
    5e88:	4fb4      	ldr	r7, [pc, #720]	; (615c <Transform+0x398>)
    5e8a:	9305      	str	r3, [sp, #20]
    5e8c:	441f      	add	r7, r3
    5e8e:	443d      	add	r5, r7
    5e90:	442a      	add	r2, r5
    5e92:	eb04 32f2 	add.w	r2, r4, r2, ror #15
    MD5STEP(F1, b, c, d, a, buffer[7]  + 0xfd469501, 22);
    5e96:	69cf      	ldr	r7, [r1, #28]
    5e98:	ea89 0804 	eor.w	r8, r9, r4
    5e9c:	ea08 0802 	and.w	r8, r8, r2
    5ea0:	ea88 0809 	eor.w	r8, r8, r9
    5ea4:	4dae      	ldr	r5, [pc, #696]	; (6160 <Transform+0x39c>)
    5ea6:	9706      	str	r7, [sp, #24]
    5ea8:	443d      	add	r5, r7
    5eaa:	442e      	add	r6, r5
    5eac:	44b0      	add	r8, r6
    5eae:	eb02 28b8 	add.w	r8, r2, r8, ror #10
    MD5STEP(F1, a, b, c, d, buffer[8]  + 0x698098d8,  7);
    5eb2:	6a0f      	ldr	r7, [r1, #32]
    5eb4:	ea84 0c02 	eor.w	ip, r4, r2
    5eb8:	ea0c 0c08 	and.w	ip, ip, r8
    5ebc:	ea8c 0c04 	eor.w	ip, ip, r4
    5ec0:	4da8      	ldr	r5, [pc, #672]	; (6164 <Transform+0x3a0>)
    5ec2:	9707      	str	r7, [sp, #28]
    5ec4:	443d      	add	r5, r7
    5ec6:	eb09 0305 	add.w	r3, r9, r5
    5eca:	449c      	add	ip, r3
    5ecc:	eb08 6c7c 	add.w	ip, r8, ip, ror #25
    MD5STEP(F1, d, a, b, c, buffer[9]  + 0x8b44f7af, 12);
    5ed0:	6a4d      	ldr	r5, [r1, #36]	; 0x24
    5ed2:	ea82 0908 	eor.w	r9, r2, r8
    5ed6:	ea09 090c 	and.w	r9, r9, ip
    5eda:	ea89 0902 	eor.w	r9, r9, r2
    5ede:	4ba2      	ldr	r3, [pc, #648]	; (6168 <Transform+0x3a4>)
    5ee0:	9508      	str	r5, [sp, #32]
    5ee2:	442b      	add	r3, r5
    5ee4:	441c      	add	r4, r3
    5ee6:	44a1      	add	r9, r4
    5ee8:	eb0c 5939 	add.w	r9, ip, r9, ror #20
    MD5STEP(F1, c, d, a, b, buffer[10] + 0xffff5bb1, 17);
    5eec:	6a8b      	ldr	r3, [r1, #40]	; 0x28
    5eee:	ea88 0e0c 	eor.w	lr, r8, ip
    5ef2:	ea0e 0e09 	and.w	lr, lr, r9
    5ef6:	ea8e 0e08 	eor.w	lr, lr, r8
    5efa:	9309      	str	r3, [sp, #36]	; 0x24
    5efc:	f5a3 4324 	sub.w	r3, r3, #41984	; 0xa400
    5f00:	3b4f      	subs	r3, #79	; 0x4f
    5f02:	441a      	add	r2, r3
    5f04:	4496      	add	lr, r2
    5f06:	eb09 3efe 	add.w	lr, r9, lr, ror #15
    MD5STEP(F1, b, c, d, a, buffer[11] + 0x895cd7be, 22);
    5f0a:	6aca      	ldr	r2, [r1, #44]	; 0x2c
    5f0c:	4616      	mov	r6, r2
    5f0e:	ea8c 0509 	eor.w	r5, ip, r9
    5f12:	ea05 050e 	and.w	r5, r5, lr
    5f16:	ea85 050c 	eor.w	r5, r5, ip
    5f1a:	4b94      	ldr	r3, [pc, #592]	; (616c <Transform+0x3a8>)
    5f1c:	4413      	add	r3, r2
    5f1e:	4498      	add	r8, r3
    5f20:	4445      	add	r5, r8
    5f22:	eb0e 25b5 	add.w	r5, lr, r5, ror #10
    MD5STEP(F1, a, b, c, d, buffer[12] + 0x6b901122,  7);
    5f26:	f8d1 8030 	ldr.w	r8, [r1, #48]	; 0x30
    5f2a:	ea89 070e 	eor.w	r7, r9, lr
    5f2e:	402f      	ands	r7, r5
    5f30:	ea87 0709 	eor.w	r7, r7, r9
    5f34:	4b8e      	ldr	r3, [pc, #568]	; (6170 <Transform+0x3ac>)
    5f36:	4443      	add	r3, r8
    5f38:	449c      	add	ip, r3
    5f3a:	4467      	add	r7, ip
    5f3c:	eb05 6777 	add.w	r7, r5, r7, ror #25
    MD5STEP(F1, d, a, b, c, buffer[13] + 0xfd987193, 12);
    5f40:	f8d1 c034 	ldr.w	ip, [r1, #52]	; 0x34
    5f44:	ea8e 0305 	eor.w	r3, lr, r5
    5f48:	403b      	ands	r3, r7
    5f4a:	ea83 030e 	eor.w	r3, r3, lr
    5f4e:	4a89      	ldr	r2, [pc, #548]	; (6174 <Transform+0x3b0>)
    5f50:	4462      	add	r2, ip
    5f52:	4491      	add	r9, r2
    5f54:	444b      	add	r3, r9
    5f56:	eb07 5333 	add.w	r3, r7, r3, ror #20
    MD5STEP(F1, c, d, a, b, buffer[14] + 0xa679438e, 17);
    5f5a:	f8d1 9038 	ldr.w	r9, [r1, #56]	; 0x38
    5f5e:	ea85 0407 	eor.w	r4, r5, r7
    5f62:	401c      	ands	r4, r3
    5f64:	406c      	eors	r4, r5
    5f66:	4a84      	ldr	r2, [pc, #528]	; (6178 <Transform+0x3b4>)
    5f68:	444a      	add	r2, r9
    5f6a:	4496      	add	lr, r2
    5f6c:	4474      	add	r4, lr
    5f6e:	eb03 34f4 	add.w	r4, r3, r4, ror #15
    MD5STEP(F1, b, c, d, a, buffer[15] + 0x49b40821, 22);
    5f72:	f8d1 e03c 	ldr.w	lr, [r1, #60]	; 0x3c
    5f76:	ea87 0203 	eor.w	r2, r7, r3
    5f7a:	4022      	ands	r2, r4
    5f7c:	407a      	eors	r2, r7
    5f7e:	497f      	ldr	r1, [pc, #508]	; (617c <Transform+0x3b8>)
    5f80:	4471      	add	r1, lr
    5f82:	440d      	add	r5, r1
    5f84:	442a      	add	r2, r5
    5f86:	eb04 22b2 	add.w	r2, r4, r2, ror #10

    MD5STEP(F2, a, b, c, d, buffer[1]  + 0xf61e2562,  5);
    5f8a:	ea84 0b02 	eor.w	fp, r4, r2
    5f8e:	ea0b 0b03 	and.w	fp, fp, r3
    5f92:	ea8b 0b04 	eor.w	fp, fp, r4
    5f96:	497a      	ldr	r1, [pc, #488]	; (6180 <Transform+0x3bc>)
    5f98:	9d00      	ldr	r5, [sp, #0]
    5f9a:	4429      	add	r1, r5
    5f9c:	440f      	add	r7, r1
    5f9e:	44bb      	add	fp, r7
    5fa0:	eb02 6bfb 	add.w	fp, r2, fp, ror #27
    MD5STEP(F2, d, a, b, c, buffer[6]  + 0xc040b340,  9);
    5fa4:	ea82 070b 	eor.w	r7, r2, fp
    5fa8:	4027      	ands	r7, r4
    5faa:	4057      	eors	r7, r2
    5fac:	4975      	ldr	r1, [pc, #468]	; (6184 <Transform+0x3c0>)
    5fae:	9d05      	ldr	r5, [sp, #20]
    5fb0:	4429      	add	r1, r5
    5fb2:	440b      	add	r3, r1
    5fb4:	441f      	add	r7, r3
    5fb6:	eb0b 57f7 	add.w	r7, fp, r7, ror #23
    MD5STEP(F2, c, d, a, b, buffer[11] + 0x265e5a51, 14);
    5fba:	ea8b 0307 	eor.w	r3, fp, r7
    5fbe:	4013      	ands	r3, r2
    5fc0:	ea83 030b 	eor.w	r3, r3, fp
    5fc4:	4970      	ldr	r1, [pc, #448]	; (6188 <Transform+0x3c4>)
    5fc6:	960b      	str	r6, [sp, #44]	; 0x2c
    5fc8:	4431      	add	r1, r6
    5fca:	440c      	add	r4, r1
    5fcc:	4423      	add	r3, r4
    5fce:	eb07 43b3 	add.w	r3, r7, r3, ror #18
    MD5STEP(F2, b, c, d, a, buffer[0]  + 0xe9b6c7aa, 20);
    5fd2:	ea87 0503 	eor.w	r5, r7, r3
    5fd6:	ea05 050b 	and.w	r5, r5, fp
    5fda:	407d      	eors	r5, r7
    5fdc:	496b      	ldr	r1, [pc, #428]	; (618c <Transform+0x3c8>)
    5fde:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    5fe0:	4421      	add	r1, r4
    5fe2:	440a      	add	r2, r1
    5fe4:	4415      	add	r5, r2
    5fe6:	eb03 3535 	add.w	r5, r3, r5, ror #12
    MD5STEP(F2, a, b, c, d, buffer[5]  + 0xd62f105d,  5);
    5fea:	ea83 0205 	eor.w	r2, r3, r5
    5fee:	403a      	ands	r2, r7
    5ff0:	405a      	eors	r2, r3
    5ff2:	4967      	ldr	r1, [pc, #412]	; (6190 <Transform+0x3cc>)
    5ff4:	9e04      	ldr	r6, [sp, #16]
    5ff6:	4431      	add	r1, r6
    5ff8:	448b      	add	fp, r1
    5ffa:	445a      	add	r2, fp
    5ffc:	eb05 62f2 	add.w	r2, r5, r2, ror #27
    MD5STEP(F2, d, a, b, c, buffer[10] + 0x02441453,  9);
    6000:	ea85 0102 	eor.w	r1, r5, r2
    6004:	4019      	ands	r1, r3
    6006:	4069      	eors	r1, r5
    6008:	4c62      	ldr	r4, [pc, #392]	; (6194 <Transform+0x3d0>)
    600a:	9e09      	ldr	r6, [sp, #36]	; 0x24
    600c:	4434      	add	r4, r6
    600e:	4427      	add	r7, r4
    6010:	4439      	add	r1, r7
    6012:	eb02 51f1 	add.w	r1, r2, r1, ror #23
    MD5STEP(F2, c, d, a, b, buffer[15] + 0xd8a1e681, 14);
    6016:	ea82 0401 	eor.w	r4, r2, r1
    601a:	402c      	ands	r4, r5
    601c:	4054      	eors	r4, r2
    601e:	4f5e      	ldr	r7, [pc, #376]	; (6198 <Transform+0x3d4>)
    6020:	4477      	add	r7, lr
    6022:	443b      	add	r3, r7
    6024:	441c      	add	r4, r3
    6026:	eb01 44b4 	add.w	r4, r1, r4, ror #18
    MD5STEP(F2, b, c, d, a, buffer[4]  + 0xe7d3fbc8, 20);
    602a:	ea81 0304 	eor.w	r3, r1, r4
    602e:	4013      	ands	r3, r2
    6030:	404b      	eors	r3, r1
    6032:	4f5a      	ldr	r7, [pc, #360]	; (619c <Transform+0x3d8>)
    6034:	9e03      	ldr	r6, [sp, #12]
    6036:	4437      	add	r7, r6
    6038:	443d      	add	r5, r7
    603a:	442b      	add	r3, r5
    603c:	eb04 3333 	add.w	r3, r4, r3, ror #12
    MD5STEP(F2, a, b, c, d, buffer[9]  + 0x21e1cde6,  5);
    6040:	ea84 0b03 	eor.w	fp, r4, r3
    6044:	ea0b 0b01 	and.w	fp, fp, r1
    6048:	ea8b 0b04 	eor.w	fp, fp, r4
    604c:	4d54      	ldr	r5, [pc, #336]	; (61a0 <Transform+0x3dc>)
    604e:	9e08      	ldr	r6, [sp, #32]
    6050:	4435      	add	r5, r6
    6052:	442a      	add	r2, r5
    6054:	4493      	add	fp, r2
    6056:	eb03 6bfb 	add.w	fp, r3, fp, ror #27
    MD5STEP(F2, d, a, b, c, buffer[14] + 0xc33707d6,  9);
    605a:	ea83 070b 	eor.w	r7, r3, fp
    605e:	4027      	ands	r7, r4
    6060:	405f      	eors	r7, r3
    6062:	4a50      	ldr	r2, [pc, #320]	; (61a4 <Transform+0x3e0>)
    6064:	444a      	add	r2, r9
    6066:	4411      	add	r1, r2
    6068:	440f      	add	r7, r1
    606a:	eb0b 57f7 	add.w	r7, fp, r7, ror #23
    MD5STEP(F2, c, d, a, b, buffer[3]  + 0xf4d50d87, 14);
    606e:	ea8b 0507 	eor.w	r5, fp, r7
    6072:	401d      	ands	r5, r3
    6074:	ea85 050b 	eor.w	r5, r5, fp
    6078:	4a4b      	ldr	r2, [pc, #300]	; (61a8 <Transform+0x3e4>)
    607a:	9902      	ldr	r1, [sp, #8]
    607c:	440a      	add	r2, r1
    607e:	4414      	add	r4, r2
    6080:	4425      	add	r5, r4
    6082:	eb07 45b5 	add.w	r5, r7, r5, ror #18
    MD5STEP(F2, b, c, d, a, buffer[8]  + 0x455a14ed, 20);
    6086:	ea87 0205 	eor.w	r2, r7, r5
    608a:	ea02 020b 	and.w	r2, r2, fp
    608e:	407a      	eors	r2, r7
    6090:	4946      	ldr	r1, [pc, #280]	; (61ac <Transform+0x3e8>)
    6092:	9e07      	ldr	r6, [sp, #28]
    6094:	4431      	add	r1, r6
    6096:	440b      	add	r3, r1
    6098:	441a      	add	r2, r3
    609a:	eb05 3232 	add.w	r2, r5, r2, ror #12
    MD5STEP(F2, a, b, c, d, buffer[13] + 0xa9e3e905,  5);
    609e:	ea85 0302 	eor.w	r3, r5, r2
    60a2:	403b      	ands	r3, r7
    60a4:	406b      	eors	r3, r5
    60a6:	4942      	ldr	r1, [pc, #264]	; (61b0 <Transform+0x3ec>)
    60a8:	4461      	add	r1, ip
    60aa:	448b      	add	fp, r1
    60ac:	445b      	add	r3, fp
    60ae:	eb02 63f3 	add.w	r3, r2, r3, ror #27
    MD5STEP(F2, d, a, b, c, buffer[2]  + 0xfcefa3f8,  9);
    60b2:	ea82 0103 	eor.w	r1, r2, r3
    60b6:	4029      	ands	r1, r5
    60b8:	4051      	eors	r1, r2
    60ba:	4c3e      	ldr	r4, [pc, #248]	; (61b4 <Transform+0x3f0>)
    60bc:	9e01      	ldr	r6, [sp, #4]
    60be:	4434      	add	r4, r6
    60c0:	4427      	add	r7, r4
    60c2:	4439      	add	r1, r7
    60c4:	eb03 51f1 	add.w	r1, r3, r1, ror #23
    MD5STEP(F2, c, d, a, b, buffer[7]  + 0x676f02d9, 14);
    60c8:	ea83 0401 	eor.w	r4, r3, r1
    60cc:	4014      	ands	r4, r2
    60ce:	405c      	eors	r4, r3
    60d0:	4f39      	ldr	r7, [pc, #228]	; (61b8 <Transform+0x3f4>)
    60d2:	9e06      	ldr	r6, [sp, #24]
    60d4:	4437      	add	r7, r6
    60d6:	443d      	add	r5, r7
    60d8:	442c      	add	r4, r5
    60da:	eb01 44b4 	add.w	r4, r1, r4, ror #18
    MD5STEP(F2, b, c, d, a, buffer[12] + 0x8d2a4c8a, 20);
    60de:	ea81 0b04 	eor.w	fp, r1, r4
    60e2:	ea0b 0503 	and.w	r5, fp, r3
    60e6:	404d      	eors	r5, r1
    60e8:	4f34      	ldr	r7, [pc, #208]	; (61bc <Transform+0x3f8>)
    60ea:	4447      	add	r7, r8
    60ec:	443a      	add	r2, r7
    60ee:	4415      	add	r5, r2
    60f0:	eb04 3535 	add.w	r5, r4, r5, ror #12

    MD5STEP(F3, a, b, c, d, buffer[5]  + 0xfffa3942,  4);
    60f4:	9f04      	ldr	r7, [sp, #16]
    60f6:	f5a7 22b8 	sub.w	r2, r7, #376832	; 0x5c000
    60fa:	f2a2 62be 	subw	r2, r2, #1726	; 0x6be
    60fe:	4413      	add	r3, r2
    6100:	ea8b 0b05 	eor.w	fp, fp, r5
    6104:	445b      	add	r3, fp
    6106:	eb05 7333 	add.w	r3, r5, r3, ror #28
    MD5STEP(F3, d, a, b, c, buffer[8]  + 0x8771f681, 11);
    610a:	ea84 0205 	eor.w	r2, r4, r5
    610e:	405a      	eors	r2, r3
    6110:	4f2b      	ldr	r7, [pc, #172]	; (61c0 <Transform+0x3fc>)
    6112:	9e07      	ldr	r6, [sp, #28]
    6114:	4437      	add	r7, r6
    6116:	4439      	add	r1, r7
    6118:	4411      	add	r1, r2
    611a:	eb03 5171 	add.w	r1, r3, r1, ror #21
    MD5STEP(F3, c, d, a, b, buffer[11] + 0x6d9d6122, 16);
    611e:	ea85 0b03 	eor.w	fp, r5, r3
    6122:	ea8b 0b01 	eor.w	fp, fp, r1
    6126:	4a27      	ldr	r2, [pc, #156]	; (61c4 <Transform+0x400>)
    6128:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    612a:	443a      	add	r2, r7
    612c:	4414      	add	r4, r2
    612e:	445c      	add	r4, fp
    6130:	eb01 4434 	add.w	r4, r1, r4, ror #16
    MD5STEP(F3, b, c, d, a, buffer[14] + 0xfde5380c, 23);
    6134:	ea83 0701 	eor.w	r7, r3, r1
    6138:	4067      	eors	r7, r4
    613a:	4a23      	ldr	r2, [pc, #140]	; (61c8 <Transform+0x404>)
    613c:	444a      	add	r2, r9
    613e:	4415      	add	r5, r2
    6140:	442f      	add	r7, r5
    6142:	e043      	b.n	61cc <Transform+0x408>
    6144:	d76aa478 	.word	0xd76aa478
    6148:	e8c7b756 	.word	0xe8c7b756
    614c:	242070db 	.word	0x242070db
    6150:	c1bdceee 	.word	0xc1bdceee
    6154:	f57c0faf 	.word	0xf57c0faf
    6158:	4787c62a 	.word	0x4787c62a
    615c:	a8304613 	.word	0xa8304613
    6160:	fd469501 	.word	0xfd469501
    6164:	698098d8 	.word	0x698098d8
    6168:	8b44f7af 	.word	0x8b44f7af
    616c:	895cd7be 	.word	0x895cd7be
    6170:	6b901122 	.word	0x6b901122
    6174:	fd987193 	.word	0xfd987193
    6178:	a679438e 	.word	0xa679438e
    617c:	49b40821 	.word	0x49b40821
    6180:	f61e2562 	.word	0xf61e2562
    6184:	c040b340 	.word	0xc040b340
    6188:	265e5a51 	.word	0x265e5a51
    618c:	e9b6c7aa 	.word	0xe9b6c7aa
    6190:	d62f105d 	.word	0xd62f105d
    6194:	02441453 	.word	0x02441453
    6198:	d8a1e681 	.word	0xd8a1e681
    619c:	e7d3fbc8 	.word	0xe7d3fbc8
    61a0:	21e1cde6 	.word	0x21e1cde6
    61a4:	c33707d6 	.word	0xc33707d6
    61a8:	f4d50d87 	.word	0xf4d50d87
    61ac:	455a14ed 	.word	0x455a14ed
    61b0:	a9e3e905 	.word	0xa9e3e905
    61b4:	fcefa3f8 	.word	0xfcefa3f8
    61b8:	676f02d9 	.word	0x676f02d9
    61bc:	8d2a4c8a 	.word	0x8d2a4c8a
    61c0:	8771f681 	.word	0x8771f681
    61c4:	6d9d6122 	.word	0x6d9d6122
    61c8:	fde5380c 	.word	0xfde5380c
    61cc:	eb04 2777 	add.w	r7, r4, r7, ror #9
    MD5STEP(F3, a, b, c, d, buffer[1]  + 0xa4beea44,  4);
    61d0:	ea81 0204 	eor.w	r2, r1, r4
    61d4:	407a      	eors	r2, r7
    61d6:	4d94      	ldr	r5, [pc, #592]	; (6428 <Transform+0x664>)
    61d8:	9e00      	ldr	r6, [sp, #0]
    61da:	4435      	add	r5, r6
    61dc:	442b      	add	r3, r5
    61de:	4413      	add	r3, r2
    61e0:	eb07 7333 	add.w	r3, r7, r3, ror #28
    MD5STEP(F3, d, a, b, c, buffer[4]  + 0x4bdecfa9, 11);
    61e4:	ea84 0207 	eor.w	r2, r4, r7
    61e8:	405a      	eors	r2, r3
    61ea:	4d90      	ldr	r5, [pc, #576]	; (642c <Transform+0x668>)
    61ec:	9e03      	ldr	r6, [sp, #12]
    61ee:	4435      	add	r5, r6
    61f0:	4429      	add	r1, r5
    61f2:	4411      	add	r1, r2
    61f4:	eb03 5171 	add.w	r1, r3, r1, ror #21
    MD5STEP(F3, c, d, a, b, buffer[7]  + 0xf6bb4b60, 16);
    61f8:	ea87 0b03 	eor.w	fp, r7, r3
    61fc:	ea8b 0b01 	eor.w	fp, fp, r1
    6200:	4a8b      	ldr	r2, [pc, #556]	; (6430 <Transform+0x66c>)
    6202:	9d06      	ldr	r5, [sp, #24]
    6204:	442a      	add	r2, r5
    6206:	4414      	add	r4, r2
    6208:	44a3      	add	fp, r4
    620a:	eb01 4b3b 	add.w	fp, r1, fp, ror #16
    MD5STEP(F3, b, c, d, a, buffer[10] + 0xbebfbc70, 23);
    620e:	ea83 0201 	eor.w	r2, r3, r1
    6212:	ea82 020b 	eor.w	r2, r2, fp
    6216:	4c87      	ldr	r4, [pc, #540]	; (6434 <Transform+0x670>)
    6218:	9d09      	ldr	r5, [sp, #36]	; 0x24
    621a:	442c      	add	r4, r5
    621c:	4427      	add	r7, r4
    621e:	443a      	add	r2, r7
    6220:	eb0b 2272 	add.w	r2, fp, r2, ror #9
    MD5STEP(F3, a, b, c, d, buffer[13] + 0x289b7ec6,  4);
    6224:	ea81 040b 	eor.w	r4, r1, fp
    6228:	4054      	eors	r4, r2
    622a:	4d83      	ldr	r5, [pc, #524]	; (6438 <Transform+0x674>)
    622c:	4465      	add	r5, ip
    622e:	442b      	add	r3, r5
    6230:	4423      	add	r3, r4
    6232:	eb02 7333 	add.w	r3, r2, r3, ror #28
    MD5STEP(F3, d, a, b, c, buffer[0]  + 0xeaa127fa, 11);
    6236:	ea8b 0702 	eor.w	r7, fp, r2
    623a:	405f      	eors	r7, r3
    623c:	4c7f      	ldr	r4, [pc, #508]	; (643c <Transform+0x678>)
    623e:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    6240:	4434      	add	r4, r6
    6242:	4421      	add	r1, r4
    6244:	440f      	add	r7, r1
    6246:	eb03 5777 	add.w	r7, r3, r7, ror #21
    MD5STEP(F3, c, d, a, b, buffer[3]  + 0xd4ef3085, 16);
    624a:	ea82 0503 	eor.w	r5, r2, r3
    624e:	407d      	eors	r5, r7
    6250:	497b      	ldr	r1, [pc, #492]	; (6440 <Transform+0x67c>)
    6252:	9c02      	ldr	r4, [sp, #8]
    6254:	4421      	add	r1, r4
    6256:	448b      	add	fp, r1
    6258:	445d      	add	r5, fp
    625a:	eb07 4535 	add.w	r5, r7, r5, ror #16
    MD5STEP(F3, b, c, d, a, buffer[6]  + 0x04881d05, 23);
    625e:	ea83 0b07 	eor.w	fp, r3, r7
    6262:	ea8b 0b05 	eor.w	fp, fp, r5
    6266:	4977      	ldr	r1, [pc, #476]	; (6444 <Transform+0x680>)
    6268:	9c05      	ldr	r4, [sp, #20]
    626a:	4421      	add	r1, r4
    626c:	440a      	add	r2, r1
    626e:	4493      	add	fp, r2
    6270:	eb05 2b7b 	add.w	fp, r5, fp, ror #9
    MD5STEP(F3, a, b, c, d, buffer[9]  + 0xd9d4d039,  4);
    6274:	ea87 0405 	eor.w	r4, r7, r5
    6278:	ea84 040b 	eor.w	r4, r4, fp
    627c:	4a72      	ldr	r2, [pc, #456]	; (6448 <Transform+0x684>)
    627e:	9908      	ldr	r1, [sp, #32]
    6280:	440a      	add	r2, r1
    6282:	4413      	add	r3, r2
    6284:	441c      	add	r4, r3
    6286:	eb0b 7434 	add.w	r4, fp, r4, ror #28
    MD5STEP(F3, d, a, b, c, buffer[12] + 0xe6db99e5, 11);
    628a:	ea85 010b 	eor.w	r1, r5, fp
    628e:	4061      	eors	r1, r4
    6290:	4b6e      	ldr	r3, [pc, #440]	; (644c <Transform+0x688>)
    6292:	4443      	add	r3, r8
    6294:	441f      	add	r7, r3
    6296:	4439      	add	r1, r7
    6298:	eb04 5171 	add.w	r1, r4, r1, ror #21
    MD5STEP(F3, c, d, a, b, buffer[15] + 0x1fa27cf8, 16);
    629c:	ea8b 0304 	eor.w	r3, fp, r4
    62a0:	404b      	eors	r3, r1
    62a2:	4a6b      	ldr	r2, [pc, #428]	; (6450 <Transform+0x68c>)
    62a4:	4472      	add	r2, lr
    62a6:	4415      	add	r5, r2
    62a8:	441d      	add	r5, r3
    62aa:	eb01 4535 	add.w	r5, r1, r5, ror #16
    MD5STEP(F3, b, c, d, a, buffer[2]  + 0xc4ac5665, 23);
    62ae:	ea84 0201 	eor.w	r2, r4, r1
    62b2:	406a      	eors	r2, r5
    62b4:	4b67      	ldr	r3, [pc, #412]	; (6454 <Transform+0x690>)
    62b6:	9f01      	ldr	r7, [sp, #4]
    62b8:	443b      	add	r3, r7
    62ba:	449b      	add	fp, r3
    62bc:	445a      	add	r2, fp
    62be:	eb05 2272 	add.w	r2, r5, r2, ror #9

    MD5STEP(F4, a, b, c, d, buffer[0]  + 0xf4292244,  6);
    62c2:	ea62 0301 	orn	r3, r2, r1
    62c6:	406b      	eors	r3, r5
    62c8:	4f63      	ldr	r7, [pc, #396]	; (6458 <Transform+0x694>)
    62ca:	4437      	add	r7, r6
    62cc:	443c      	add	r4, r7
    62ce:	4423      	add	r3, r4
    62d0:	eb02 63b3 	add.w	r3, r2, r3, ror #26
    MD5STEP(F4, d, a, b, c, buffer[7]  + 0x432aff97, 10);
    62d4:	ea63 0b05 	orn	fp, r3, r5
    62d8:	ea8b 0b02 	eor.w	fp, fp, r2
    62dc:	4c5f      	ldr	r4, [pc, #380]	; (645c <Transform+0x698>)
    62de:	9f06      	ldr	r7, [sp, #24]
    62e0:	443c      	add	r4, r7
    62e2:	4421      	add	r1, r4
    62e4:	448b      	add	fp, r1
    62e6:	eb03 5bbb 	add.w	fp, r3, fp, ror #22
    MD5STEP(F4, c, d, a, b, buffer[14] + 0xab9423a7, 15);
    62ea:	ea6b 0702 	orn	r7, fp, r2
    62ee:	405f      	eors	r7, r3
    62f0:	495b      	ldr	r1, [pc, #364]	; (6460 <Transform+0x69c>)
    62f2:	4449      	add	r1, r9
    62f4:	440d      	add	r5, r1
    62f6:	442f      	add	r7, r5
    62f8:	eb0b 4777 	add.w	r7, fp, r7, ror #17
    MD5STEP(F4, b, c, d, a, buffer[5]  + 0xfc93a039, 21);
    62fc:	ea67 0403 	orn	r4, r7, r3
    6300:	ea84 040b 	eor.w	r4, r4, fp
    6304:	4957      	ldr	r1, [pc, #348]	; (6464 <Transform+0x6a0>)
    6306:	9d04      	ldr	r5, [sp, #16]
    6308:	4429      	add	r1, r5
    630a:	440a      	add	r2, r1
    630c:	4414      	add	r4, r2
    630e:	eb07 24f4 	add.w	r4, r7, r4, ror #11
    MD5STEP(F4, a, b, c, d, buffer[12] + 0x655b59c3,  6);
    6312:	ea64 050b 	orn	r5, r4, fp
    6316:	407d      	eors	r5, r7
    6318:	4a53      	ldr	r2, [pc, #332]	; (6468 <Transform+0x6a4>)
    631a:	4442      	add	r2, r8
    631c:	4413      	add	r3, r2
    631e:	441d      	add	r5, r3
    6320:	eb04 65b5 	add.w	r5, r4, r5, ror #26
    MD5STEP(F4, d, a, b, c, buffer[3]  + 0x8f0ccc92, 10);
    6324:	ea65 0807 	orn	r8, r5, r7
    6328:	ea88 0804 	eor.w	r8, r8, r4
    632c:	4b4f      	ldr	r3, [pc, #316]	; (646c <Transform+0x6a8>)
    632e:	9902      	ldr	r1, [sp, #8]
    6330:	440b      	add	r3, r1
    6332:	449b      	add	fp, r3
    6334:	44d8      	add	r8, fp
    6336:	eb05 58b8 	add.w	r8, r5, r8, ror #22
    MD5STEP(F4, c, d, a, b, buffer[10] + 0xffeff47d, 15);
    633a:	ea68 0304 	orn	r3, r8, r4
    633e:	406b      	eors	r3, r5
    6340:	9a09      	ldr	r2, [sp, #36]	; 0x24
    6342:	f5a2 1680 	sub.w	r6, r2, #1048576	; 0x100000
    6346:	f6a6 3683 	subw	r6, r6, #2947	; 0xb83
    634a:	443e      	add	r6, r7
    634c:	4433      	add	r3, r6
    634e:	eb08 4373 	add.w	r3, r8, r3, ror #17
    MD5STEP(F4, b, c, d, a, buffer[1]  + 0x85845dd1, 21);
    6352:	ea63 0905 	orn	r9, r3, r5
    6356:	ea89 0908 	eor.w	r9, r9, r8
    635a:	4945      	ldr	r1, [pc, #276]	; (6470 <Transform+0x6ac>)
    635c:	9e00      	ldr	r6, [sp, #0]
    635e:	4431      	add	r1, r6
    6360:	440c      	add	r4, r1
    6362:	44a1      	add	r9, r4
    6364:	eb03 29f9 	add.w	r9, r3, r9, ror #11
    MD5STEP(F4, a, b, c, d, buffer[8]  + 0x6fa87e4f,  6);
    6368:	ea69 0608 	orn	r6, r9, r8
    636c:	405e      	eors	r6, r3
    636e:	4a41      	ldr	r2, [pc, #260]	; (6474 <Transform+0x6b0>)
    6370:	9907      	ldr	r1, [sp, #28]
    6372:	440a      	add	r2, r1
    6374:	4415      	add	r5, r2
    6376:	442e      	add	r6, r5
    6378:	eb09 66b6 	add.w	r6, r9, r6, ror #26
    MD5STEP(F4, d, a, b, c, buffer[15] + 0xfe2ce6e0, 10);
    637c:	ea66 0103 	orn	r1, r6, r3
    6380:	ea81 0109 	eor.w	r1, r1, r9
    6384:	4a3c      	ldr	r2, [pc, #240]	; (6478 <Transform+0x6b4>)
    6386:	4472      	add	r2, lr
    6388:	4490      	add	r8, r2
    638a:	4441      	add	r1, r8
    638c:	eb06 51b1 	add.w	r1, r6, r1, ror #22
    MD5STEP(F4, c, d, a, b, buffer[6]  + 0xa3014314, 15);
    6390:	ea61 0409 	orn	r4, r1, r9
    6394:	4074      	eors	r4, r6
    6396:	4a39      	ldr	r2, [pc, #228]	; (647c <Transform+0x6b8>)
    6398:	9d05      	ldr	r5, [sp, #20]
    639a:	442a      	add	r2, r5
    639c:	4413      	add	r3, r2
    639e:	441c      	add	r4, r3
    63a0:	eb01 4474 	add.w	r4, r1, r4, ror #17
    MD5STEP(F4, b, c, d, a, buffer[13] + 0x4e0811a1, 21);
    63a4:	ea64 0506 	orn	r5, r4, r6
    63a8:	404d      	eors	r5, r1
    63aa:	4b35      	ldr	r3, [pc, #212]	; (6480 <Transform+0x6bc>)
    63ac:	4463      	add	r3, ip
    63ae:	4499      	add	r9, r3
    63b0:	444d      	add	r5, r9
    63b2:	eb04 25f5 	add.w	r5, r4, r5, ror #11
    MD5STEP(F4, a, b, c, d, buffer[4]  + 0xf7537e82,  6);
    63b6:	ea65 0701 	orn	r7, r5, r1
    63ba:	4067      	eors	r7, r4
    63bc:	4a31      	ldr	r2, [pc, #196]	; (6484 <Transform+0x6c0>)
    63be:	9b03      	ldr	r3, [sp, #12]
    63c0:	441a      	add	r2, r3
    63c2:	4416      	add	r6, r2
    63c4:	4437      	add	r7, r6
    63c6:	eb05 67b7 	add.w	r7, r5, r7, ror #26
    MD5STEP(F4, d, a, b, c, buffer[11] + 0xbd3af235, 10);
    63ca:	ea67 0304 	orn	r3, r7, r4
    63ce:	406b      	eors	r3, r5
    63d0:	4a2d      	ldr	r2, [pc, #180]	; (6488 <Transform+0x6c4>)
    63d2:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    63d4:	4432      	add	r2, r6
    63d6:	4411      	add	r1, r2
    63d8:	4419      	add	r1, r3
    63da:	eb07 51b1 	add.w	r1, r7, r1, ror #22
    MD5STEP(F4, c, d, a, b, buffer[2]  + 0x2ad7d2bb, 15);
    63de:	ea61 0605 	orn	r6, r1, r5
    63e2:	407e      	eors	r6, r7
    63e4:	4a29      	ldr	r2, [pc, #164]	; (648c <Transform+0x6c8>)
    63e6:	9b01      	ldr	r3, [sp, #4]
    63e8:	441a      	add	r2, r3
    63ea:	4414      	add	r4, r2
    63ec:	4434      	add	r4, r6
    63ee:	eb01 4474 	add.w	r4, r1, r4, ror #17
    MD5STEP(F4, b, c, d, a, buffer[9]  + 0xeb86d391, 21);

    /* Add the working vars back into digest state[]  */
    md5->digest[0] += a;
    63f2:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    63f4:	443b      	add	r3, r7
    63f6:	64c3      	str	r3, [r0, #76]	; 0x4c
    MD5STEP(F4, b, c, d, a, buffer[9]  + 0xeb86d391, 21);
    63f8:	ea64 0707 	orn	r7, r4, r7
    63fc:	404f      	eors	r7, r1
    63fe:	4b24      	ldr	r3, [pc, #144]	; (6490 <Transform+0x6cc>)
    6400:	9a08      	ldr	r2, [sp, #32]
    6402:	4413      	add	r3, r2
    6404:	441d      	add	r5, r3
    6406:	442f      	add	r7, r5
    md5->digest[1] += b;
    6408:	eb0a 0504 	add.w	r5, sl, r4
    640c:	eb05 25f7 	add.w	r5, r5, r7, ror #11
    6410:	6505      	str	r5, [r0, #80]	; 0x50
    md5->digest[2] += c;
    6412:	6d43      	ldr	r3, [r0, #84]	; 0x54
    6414:	441c      	add	r4, r3
    6416:	6544      	str	r4, [r0, #84]	; 0x54
    md5->digest[3] += d;
    6418:	6d83      	ldr	r3, [r0, #88]	; 0x58
    641a:	4419      	add	r1, r3
    641c:	6581      	str	r1, [r0, #88]	; 0x58

    return 0;
}
    641e:	2000      	movs	r0, #0
    6420:	b00d      	add	sp, #52	; 0x34
    6422:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6426:	bf00      	nop
    6428:	a4beea44 	.word	0xa4beea44
    642c:	4bdecfa9 	.word	0x4bdecfa9
    6430:	f6bb4b60 	.word	0xf6bb4b60
    6434:	bebfbc70 	.word	0xbebfbc70
    6438:	289b7ec6 	.word	0x289b7ec6
    643c:	eaa127fa 	.word	0xeaa127fa
    6440:	d4ef3085 	.word	0xd4ef3085
    6444:	04881d05 	.word	0x04881d05
    6448:	d9d4d039 	.word	0xd9d4d039
    644c:	e6db99e5 	.word	0xe6db99e5
    6450:	1fa27cf8 	.word	0x1fa27cf8
    6454:	c4ac5665 	.word	0xc4ac5665
    6458:	f4292244 	.word	0xf4292244
    645c:	432aff97 	.word	0x432aff97
    6460:	ab9423a7 	.word	0xab9423a7
    6464:	fc93a039 	.word	0xfc93a039
    6468:	655b59c3 	.word	0x655b59c3
    646c:	8f0ccc92 	.word	0x8f0ccc92
    6470:	85845dd1 	.word	0x85845dd1
    6474:	6fa87e4f 	.word	0x6fa87e4f
    6478:	fe2ce6e0 	.word	0xfe2ce6e0
    647c:	a3014314 	.word	0xa3014314
    6480:	4e0811a1 	.word	0x4e0811a1
    6484:	f7537e82 	.word	0xf7537e82
    6488:	bd3af235 	.word	0xbd3af235
    648c:	2ad7d2bb 	.word	0x2ad7d2bb
    6490:	eb86d391 	.word	0xeb86d391

Disassembly of section .text.TCPIP_STACK_Task%195:

00006494 <TCPIP_STACK_Task>:
#if defined(TCPIP_STACK_USE_EVENT_NOTIFICATION) && (TCPIP_STACK_USER_NOTIFICATION != 0)
    TCPIP_EVENT         tcpipEvent;
    TCPIP_EVENT_LIST_NODE* tNode;
#endif  // defined(TCPIP_STACK_USE_EVENT_NOTIFICATION) && (TCPIP_STACK_USER_NOTIFICATION != 0)   

    if(object != (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data)
    6494:	4bb2      	ldr	r3, [pc, #712]	; (6760 <TCPIP_STACK_Task+0x2cc>)
    6496:	4283      	cmp	r3, r0
    6498:	f040 82f9 	bne.w	6a8e <TCPIP_STACK_Task+0x5fa>
    {   // invalid handle/nothing to do
        return;
    }

    if(tcpip_stack_status != SYS_STATUS_BUSY && tcpip_stack_status != SYS_STATUS_READY)
    649c:	4bb1      	ldr	r3, [pc, #708]	; (6764 <TCPIP_STACK_Task+0x2d0>)
    649e:	f993 2000 	ldrsb.w	r2, [r3]
    64a2:	1e53      	subs	r3, r2, #1
    64a4:	b2db      	uxtb	r3, r3
    64a6:	2b01      	cmp	r3, #1
    64a8:	f200 82f1 	bhi.w	6a8e <TCPIP_STACK_Task+0x5fa>
{
    64ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    64b0:	b084      	sub	sp, #16
    {   // some error state
        return;
    }

    if(tcpipNetIf == 0)
    64b2:	4bad      	ldr	r3, [pc, #692]	; (6768 <TCPIP_STACK_Task+0x2d4>)
    64b4:	681b      	ldr	r3, [r3, #0]
    64b6:	b163      	cbz	r3, 64d2 <TCPIP_STACK_Task+0x3e>
    int             aliasIx;
    TCPIP_NET_IF   *pAliasIf;
#endif  // (_TCPIP_STACK_ALIAS_INTERFACE_SUPPORT)

    // check that we've created the needed timer
    if(tcpip_stack_status == SYS_STATUS_BUSY && tcpip_stack_tickH == SYS_TMR_HANDLE_INVALID)
    64b8:	2a01      	cmp	r2, #1
    64ba:	d01b      	beq.n	64f4 <TCPIP_STACK_Task+0x60>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Initialization SYS TMR failed: %d - Aborting! \r\n", tmrStat);
            return false;
        }
    }

    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    64bc:	4baa      	ldr	r3, [pc, #680]	; (6768 <TCPIP_STACK_Task+0x2d4>)
    64be:	681c      	ldr	r4, [r3, #0]
    64c0:	4ba7      	ldr	r3, [pc, #668]	; (6760 <TCPIP_STACK_Task+0x2cc>)
    64c2:	681b      	ldr	r3, [r3, #0]
    64c4:	2b00      	cmp	r3, #0
    64c6:	f340 82d4 	ble.w	6a72 <TCPIP_STACK_Task+0x5de>
    64ca:	2500      	movs	r5, #0
                    pNetIf->Flags.bMacInitDone = true;
                }
                else if(macStat == SYS_STATUS_READY)
                {   // get the MAC address and MAC processing flags
                    // set the default MTU; MAC driver will override if needed
                    TCPIP_MAC_PARAMETERS macParams = {{{0}}};
    64cc:	462f      	mov	r7, r5
                    TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pNetIf, TCPIP_STACK_ACTION_IF_DOWN, TCPIP_MAC_POWER_DOWN);
    64ce:	4ea4      	ldr	r6, [pc, #656]	; (6760 <TCPIP_STACK_Task+0x2cc>)
    64d0:	e072      	b.n	65b8 <TCPIP_STACK_Task+0x124>
        _TCPIP_InitCallback(tcpip_stack_init_cb);
    64d2:	4ba6      	ldr	r3, [pc, #664]	; (676c <TCPIP_STACK_Task+0x2d8>)
    int cRes = (*cback)(&pInit);
    64d4:	681b      	ldr	r3, [r3, #0]
    64d6:	4668      	mov	r0, sp
    64d8:	4798      	blx	r3
    if(cRes > 0)
    64da:	2800      	cmp	r0, #0
    64dc:	f300 82b4 	bgt.w	6a48 <TCPIP_STACK_Task+0x5b4>
    if (cRes == 0 && pInit != 0)
    64e0:	b920      	cbnz	r0, 64ec <TCPIP_STACK_Task+0x58>
    64e2:	9800      	ldr	r0, [sp, #0]
    64e4:	b110      	cbz	r0, 64ec <TCPIP_STACK_Task+0x58>
        _TCPIP_DoInitialize(pInit);
    64e6:	f002 fa71 	bl	89cc <_TCPIP_DoInitialize>
    64ea:	e2ad      	b.n	6a48 <TCPIP_STACK_Task+0x5b4>
        tcpip_stack_status = SYS_STATUS_UNINITIALIZED;
    64ec:	4b9d      	ldr	r3, [pc, #628]	; (6764 <TCPIP_STACK_Task+0x2d0>)
    64ee:	2200      	movs	r2, #0
    64f0:	701a      	strb	r2, [r3, #0]
    64f2:	e2a9      	b.n	6a48 <TCPIP_STACK_Task+0x5b4>
    if(tcpip_stack_status == SYS_STATUS_BUSY && tcpip_stack_tickH == SYS_TMR_HANDLE_INVALID)
    64f4:	4b9e      	ldr	r3, [pc, #632]	; (6770 <TCPIP_STACK_Task+0x2dc>)
    64f6:	681b      	ldr	r3, [r3, #0]
    64f8:	f1b3 3fff 	cmp.w	r3, #4294967295
    64fc:	d1de      	bne.n	64bc <TCPIP_STACK_Task+0x28>
    tcpip_stack_tickH = SYS_TMR_CallbackPeriodic(TCPIP_STACK_TICK_RATE, 0, _TCPIP_STACK_TickHandler);
    64fe:	4a9d      	ldr	r2, [pc, #628]	; (6774 <TCPIP_STACK_Task+0x2e0>)
    6500:	2100      	movs	r1, #0
    6502:	2005      	movs	r0, #5
    6504:	f01a fd66 	bl	20fd4 <SYS_TMR_CallbackPeriodic>
    6508:	4b99      	ldr	r3, [pc, #612]	; (6770 <TCPIP_STACK_Task+0x2dc>)
    650a:	6018      	str	r0, [r3, #0]
    if(tcpip_stack_tickH != SYS_TMR_HANDLE_INVALID)
    650c:	f1b0 3fff 	cmp.w	r0, #4294967295
    6510:	d025      	beq.n	655e <TCPIP_STACK_Task+0xca>
        uint32_t sysRes = SYS_TMR_TickCounterFrequencyGet();
    6512:	f019 fd73 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
        uint32_t rateMs = ((sysRes * TCPIP_STACK_TICK_RATE) + 999 )/1000;    // round up
    6516:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    651a:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
    651e:	4a96      	ldr	r2, [pc, #600]	; (6778 <TCPIP_STACK_Task+0x2e4>)
    6520:	fba2 2303 	umull	r2, r3, r2, r3
    6524:	099b      	lsrs	r3, r3, #6
        stackTaskRate = (rateMs * 1000) / sysRes;
    6526:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    652a:	fb02 f303 	mul.w	r3, r2, r3
    652e:	fbb3 f3f0 	udiv	r3, r3, r0
    6532:	4a92      	ldr	r2, [pc, #584]	; (677c <TCPIP_STACK_Task+0x2e8>)
    6534:	6013      	str	r3, [r2, #0]
    for(modIx = TCPIP_MODULE_LAYER1; modIx < sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL)/sizeof(*TCPIP_STACK_MODULE_SIGNAL_TBL); modIx++, pSigEntry++)
    6536:	2502      	movs	r5, #2
    pSigEntry = TCPIP_STACK_MODULE_SIGNAL_TBL + TCPIP_MODULE_LAYER1;
    6538:	4c91      	ldr	r4, [pc, #580]	; (6780 <TCPIP_STACK_Task+0x2ec>)
    653a:	e003      	b.n	6544 <TCPIP_STACK_Task+0xb0>
    for(modIx = TCPIP_MODULE_LAYER1; modIx < sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL)/sizeof(*TCPIP_STACK_MODULE_SIGNAL_TBL); modIx++, pSigEntry++)
    653c:	3501      	adds	r5, #1
    653e:	3410      	adds	r4, #16
    6540:	2d27      	cmp	r5, #39	; 0x27
    6542:	d0bb      	beq.n	64bc <TCPIP_STACK_Task+0x28>
        if(pSigEntry->signalHandler != 0 && pSigEntry->asyncTmo != 0)
    6544:	6823      	ldr	r3, [r4, #0]
    6546:	2b00      	cmp	r3, #0
    6548:	d0f8      	beq.n	653c <TCPIP_STACK_Task+0xa8>
    654a:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
    654e:	2a00      	cmp	r2, #0
    6550:	d0f4      	beq.n	653c <TCPIP_STACK_Task+0xa8>
            if(!_TCPIPStackSignalHandlerSetParams((TCPIP_STACK_MODULE)modIx, pSigEntry, pSigEntry->asyncTmo))
    6552:	4621      	mov	r1, r4
    6554:	b2a8      	uxth	r0, r5
    6556:	f019 fcb1 	bl	1febc <_TCPIPStackSignalHandlerSetParams>
    655a:	2800      	cmp	r0, #0
    655c:	d1ee      	bne.n	653c <TCPIP_STACK_Task+0xa8>
        SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Tick registration failed: %d\r\n", TCPIP_STACK_TICK_RATE);
    655e:	f01b fcf5 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
    6562:	b988      	cbnz	r0, 6588 <TCPIP_STACK_Task+0xf4>
            TCPIP_STACK_KillStack();
    6564:	f00f fdfc 	bl	16160 <TCPIP_STACK_KillStack>
            tcpip_stack_status = SYS_STATUS_ERROR;
    6568:	4b7e      	ldr	r3, [pc, #504]	; (6764 <TCPIP_STACK_Task+0x2d0>)
    656a:	22ff      	movs	r2, #255	; 0xff
    656c:	701a      	strb	r2, [r3, #0]
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Initialization SYS TMR failed: %d - Aborting! \r\n", tmrStat);
    656e:	f01b fced 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
    6572:	2800      	cmp	r0, #0
    6574:	f000 8268 	beq.w	6a48 <TCPIP_STACK_Task+0x5b4>
    6578:	f01b fce2 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
    657c:	f04f 32ff 	mov.w	r2, #4294967295
    6580:	4980      	ldr	r1, [pc, #512]	; (6784 <TCPIP_STACK_Task+0x2f0>)
    6582:	f014 f8f3 	bl	1a76c <SYS_CONSOLE_Print>
    6586:	e25f      	b.n	6a48 <TCPIP_STACK_Task+0x5b4>
        SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Tick registration failed: %d\r\n", TCPIP_STACK_TICK_RATE);
    6588:	f01b fcda 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
    658c:	2205      	movs	r2, #5
    658e:	497e      	ldr	r1, [pc, #504]	; (6788 <TCPIP_STACK_Task+0x2f4>)
    6590:	f014 f8ec 	bl	1a76c <SYS_CONSOLE_Print>
    6594:	e7e6      	b.n	6564 <TCPIP_STACK_Task+0xd0>
                    TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pNetIf, TCPIP_STACK_ACTION_IF_DOWN, TCPIP_MAC_POWER_DOWN);
    6596:	2303      	movs	r3, #3
    6598:	2204      	movs	r2, #4
    659a:	4621      	mov	r1, r4
    659c:	4630      	mov	r0, r6
    659e:	f014 fc8b 	bl	1aeb8 <TCPIP_STACK_BringNetDown>
                    pNetIf->Flags.bMacInitDone = true;
    65a2:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    65a6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    65aa:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    65ae:	3501      	adds	r5, #1
    65b0:	346c      	adds	r4, #108	; 0x6c
    65b2:	6833      	ldr	r3, [r6, #0]
    65b4:	429d      	cmp	r5, r3
    65b6:	da42      	bge.n	663e <TCPIP_STACK_Task+0x1aa>
        if(pNetIf->macObjHandle != 0 && _TCPIPStackNetIsPrimary(pNetIf))
    65b8:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    65ba:	2800      	cmp	r0, #0
    65bc:	d0f7      	beq.n	65ae <TCPIP_STACK_Task+0x11a>
            (*pNetIf->pMacObj->TCPIP_MAC_Tasks)(pNetIf->macObjHandle);
    65be:	6c63      	ldr	r3, [r4, #68]	; 0x44
    65c0:	699b      	ldr	r3, [r3, #24]
    65c2:	4798      	blx	r3
            if(pNetIf->Flags.bMacInitialize)
    65c4:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    65c8:	f013 0f40 	tst.w	r3, #64	; 0x40
    65cc:	d0ef      	beq.n	65ae <TCPIP_STACK_Task+0x11a>
                SYS_STATUS macStat = (*pNetIf->pMacObj->TCPIP_MAC_Status)(pNetIf->macObjHandle);
    65ce:	6c63      	ldr	r3, [r4, #68]	; 0x44
    65d0:	695b      	ldr	r3, [r3, #20]
    65d2:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    65d4:	4798      	blx	r3
                if(macStat < 0)
    65d6:	2800      	cmp	r0, #0
    65d8:	dbdd      	blt.n	6596 <TCPIP_STACK_Task+0x102>
                else if(macStat == SYS_STATUS_READY)
    65da:	2802      	cmp	r0, #2
    65dc:	d1e7      	bne.n	65ae <TCPIP_STACK_Task+0x11a>
                    TCPIP_MAC_PARAMETERS macParams = {{{0}}};
    65de:	9700      	str	r7, [sp, #0]
    65e0:	9701      	str	r7, [sp, #4]
    65e2:	9702      	str	r7, [sp, #8]
    65e4:	9703      	str	r7, [sp, #12]
                    macParams.linkMtu = TCPIP_MAC_LINK_MTU_DEFAULT; 
    65e6:	f240 53dc 	movw	r3, #1500	; 0x5dc
    65ea:	f8ad 300a 	strh.w	r3, [sp, #10]
                    (*pNetIf->pMacObj->TCPIP_MAC_ParametersGet)(pNetIf->hIfMac, &macParams);
    65ee:	6c63      	ldr	r3, [r4, #68]	; 0x44
    65f0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    65f2:	4669      	mov	r1, sp
    65f4:	6d20      	ldr	r0, [r4, #80]	; 0x50
    65f6:	4798      	blx	r3
                    memcpy(pNetIf->netMACAddr.v, macParams.ifPhyAddress.v, sizeof(pNetIf->netMACAddr));
    65f8:	9800      	ldr	r0, [sp, #0]
    65fa:	63e0      	str	r0, [r4, #60]	; 0x3c
    65fc:	f8bd 3004 	ldrh.w	r3, [sp, #4]
    6600:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
                    pNetIf->Flags.bMacProcessOnEvent = macParams.processFlags != TCPIP_MAC_PROCESS_FLAG_NONE;
    6604:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    6608:	3300      	adds	r3, #0
    660a:	bf18      	it	ne
    660c:	2301      	movne	r3, #1
    660e:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
    6612:	f363 1245 	bfi	r2, r3, #5, #1
    6616:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
                    pNetIf->linkMtu = macParams.linkMtu;
    661a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    661e:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
                    // enable this interface
                    pNetIf->Flags.bInterfaceEnabled = true;
    6622:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
    6626:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    662a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
                    pNetIf->Flags.bMacInitialize = false;
    662e:	b2d3      	uxtb	r3, r2
                    pNetIf->Flags.bMacInitDone = true;
    6630:	f003 03bf 	and.w	r3, r3, #191	; 0xbf
    6634:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    6638:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    663c:	e7b7      	b.n	65ae <TCPIP_STACK_Task+0x11a>
            }
        }
    }

    // check we're getting out of Initialize procedure
    if(tcpip_stack_status == SYS_STATUS_BUSY)
    663e:	4a49      	ldr	r2, [pc, #292]	; (6764 <TCPIP_STACK_Task+0x2d0>)
    6640:	f992 2000 	ldrsb.w	r2, [r2]
    6644:	2a01      	cmp	r2, #1
    6646:	d027      	beq.n	6698 <TCPIP_STACK_Task+0x204>
    _TCPIP_SelectDefaultNet(0);
    6648:	2000      	movs	r0, #0
    664a:	f014 feb9 	bl	1b3c0 <_TCPIP_SelectDefaultNet>

// returns true if the stack needs processing time because of events
static bool TCPIP_STACK_CheckEventsPending(void)
{
#if defined(TCPIP_STACK_USE_EVENT_NOTIFICATION)
    return (newTcpipTickAvlbl != 0 || totTcpipEventsCnt != 0);
    664e:	4b4f      	ldr	r3, [pc, #316]	; (678c <TCPIP_STACK_Task+0x2f8>)
    6650:	681b      	ldr	r3, [r3, #0]
    6652:	b933      	cbnz	r3, 6662 <TCPIP_STACK_Task+0x1ce>
    6654:	4b4e      	ldr	r3, [pc, #312]	; (6790 <TCPIP_STACK_Task+0x2fc>)
    6656:	681a      	ldr	r2, [r3, #0]
    if(eventPending == 0 && stackAsyncSignalCount == 0)
    6658:	4b4e      	ldr	r3, [pc, #312]	; (6794 <TCPIP_STACK_Task+0x300>)
    665a:	681b      	ldr	r3, [r3, #0]
    665c:	4313      	orrs	r3, r2
    665e:	f000 81f3 	beq.w	6a48 <TCPIP_STACK_Task+0x5b4>
    if(newTcpipTickAvlbl != 0)
    6662:	4b4a      	ldr	r3, [pc, #296]	; (678c <TCPIP_STACK_Task+0x2f8>)
    6664:	681b      	ldr	r3, [r3, #0]
    6666:	2b00      	cmp	r3, #0
    6668:	d16c      	bne.n	6744 <TCPIP_STACK_Task+0x2b0>
        wasTickEvent = false;
    666a:	2600      	movs	r6, #0
    if( totTcpipEventsCnt)
    666c:	4b48      	ldr	r3, [pc, #288]	; (6790 <TCPIP_STACK_Task+0x2fc>)
    666e:	681b      	ldr	r3, [r3, #0]
    6670:	2b00      	cmp	r3, #0
    6672:	f000 8166 	beq.w	6942 <TCPIP_STACK_Task+0x4ae>
        totTcpipEventsCnt = 0;
    6676:	4b46      	ldr	r3, [pc, #280]	; (6790 <TCPIP_STACK_Task+0x2fc>)
    6678:	2200      	movs	r2, #0
    667a:	601a      	str	r2, [r3, #0]
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    667c:	4b3a      	ldr	r3, [pc, #232]	; (6768 <TCPIP_STACK_Task+0x2d4>)
    667e:	681c      	ldr	r4, [r3, #0]
    6680:	4b37      	ldr	r3, [pc, #220]	; (6760 <TCPIP_STACK_Task+0x2cc>)
    6682:	681b      	ldr	r3, [r3, #0]
    6684:	4293      	cmp	r3, r2
    6686:	f340 80fc 	ble.w	6882 <TCPIP_STACK_Task+0x3ee>
    668a:	4690      	mov	r8, r2
    return OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
    668c:	2701      	movs	r7, #1
                newTcpipStackEventCnt++;
    668e:	f8df a10c 	ldr.w	sl, [pc, #268]	; 679c <TCPIP_STACK_Task+0x308>
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    6692:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 6760 <TCPIP_STACK_Task+0x2cc>
    6696:	e0c7      	b.n	6828 <TCPIP_STACK_Task+0x394>
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    6698:	4a33      	ldr	r2, [pc, #204]	; (6768 <TCPIP_STACK_Task+0x2d4>)
    669a:	6816      	ldr	r6, [r2, #0]
    669c:	2b00      	cmp	r3, #0
    669e:	f340 81ee 	ble.w	6a7e <TCPIP_STACK_Task+0x5ea>
    66a2:	4631      	mov	r1, r6
        uint32_t    ifUpMask = 0;   // masks of interfaces that are up;
    66a4:	2500      	movs	r5, #0
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    66a6:	462a      	mov	r2, r5
                ifUpMask |= (1 << netIx);
    66a8:	2701      	movs	r7, #1
    66aa:	e006      	b.n	66ba <TCPIP_STACK_Task+0x226>
    66ac:	fa07 f002 	lsl.w	r0, r7, r2
    66b0:	4305      	orrs	r5, r0
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    66b2:	3201      	adds	r2, #1
    66b4:	316c      	adds	r1, #108	; 0x6c
    66b6:	4293      	cmp	r3, r2
    66b8:	d012      	beq.n	66e0 <TCPIP_STACK_Task+0x24c>
            if(pPriIf->Flags.powerMode == TCPIP_MAC_POWER_FULL)
    66ba:	f891 0043 	ldrb.w	r0, [r1, #67]	; 0x43
    66be:	f000 040c 	and.w	r4, r0, #12
    66c2:	2c04      	cmp	r4, #4
    66c4:	d1f2      	bne.n	66ac <TCPIP_STACK_Task+0x218>
                if(pPriIf->Flags.bMacInitDone == 0)
    66c6:	f010 0f80 	tst.w	r0, #128	; 0x80
    66ca:	f000 81bd 	beq.w	6a48 <TCPIP_STACK_Task+0x5b4>
                else if(pPriIf->Flags.bInterfaceEnabled != 0)
    66ce:	f891 0042 	ldrb.w	r0, [r1, #66]	; 0x42
    66d2:	f010 0f40 	tst.w	r0, #64	; 0x40
    66d6:	d0ec      	beq.n	66b2 <TCPIP_STACK_Task+0x21e>
                    ifUpMask |= (1 << netIx);
    66d8:	fa07 f002 	lsl.w	r0, r7, r2
    66dc:	4305      	orrs	r5, r0
    66de:	e7e8      	b.n	66b2 <TCPIP_STACK_Task+0x21e>
        if(ifUpMask == ((1 << netIx) - 1))
    66e0:	2201      	movs	r2, #1
    66e2:	fa02 f303 	lsl.w	r3, r2, r3
    66e6:	3b01      	subs	r3, #1
    66e8:	42ab      	cmp	r3, r5
    66ea:	f000 81c8 	beq.w	6a7e <TCPIP_STACK_Task+0x5ea>
            for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    66ee:	4b1c      	ldr	r3, [pc, #112]	; (6760 <TCPIP_STACK_Task+0x2cc>)
    66f0:	681b      	ldr	r3, [r3, #0]
    66f2:	2b00      	cmp	r3, #0
    66f4:	dd17      	ble.n	6726 <TCPIP_STACK_Task+0x292>
    66f6:	2400      	movs	r4, #0
                if(pNetIf->Flags.bInterfaceEnabled || pNetIf->Flags.bMacInitialize)
    66f8:	f244 0840 	movw	r8, #16448	; 0x4040
                    TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pNetIf, TCPIP_STACK_ACTION_IF_DOWN, TCPIP_MAC_POWER_DOWN);
    66fc:	4f18      	ldr	r7, [pc, #96]	; (6760 <TCPIP_STACK_Task+0x2cc>)
    66fe:	f04f 0903 	mov.w	r9, #3
    6702:	e004      	b.n	670e <TCPIP_STACK_Task+0x27a>
            for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    6704:	3401      	adds	r4, #1
    6706:	366c      	adds	r6, #108	; 0x6c
    6708:	683b      	ldr	r3, [r7, #0]
    670a:	429c      	cmp	r4, r3
    670c:	da0b      	bge.n	6726 <TCPIP_STACK_Task+0x292>
                if(pNetIf->Flags.bInterfaceEnabled || pNetIf->Flags.bMacInitialize)
    670e:	f8b6 3042 	ldrh.w	r3, [r6, #66]	; 0x42
    6712:	ea18 0f03 	tst.w	r8, r3
    6716:	d0f5      	beq.n	6704 <TCPIP_STACK_Task+0x270>
                    TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pNetIf, TCPIP_STACK_ACTION_IF_DOWN, TCPIP_MAC_POWER_DOWN);
    6718:	464b      	mov	r3, r9
    671a:	2204      	movs	r2, #4
    671c:	4631      	mov	r1, r6
    671e:	4638      	mov	r0, r7
    6720:	f014 fbca 	bl	1aeb8 <TCPIP_STACK_BringNetDown>
    6724:	e7ee      	b.n	6704 <TCPIP_STACK_Task+0x270>
            tcpip_stack_status = SYS_STATUS_ERROR;
    6726:	4b0f      	ldr	r3, [pc, #60]	; (6764 <TCPIP_STACK_Task+0x2d0>)
    6728:	22ff      	movs	r2, #255	; 0xff
    672a:	701a      	strb	r2, [r3, #0]
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Initialization failed: 0x%x - Aborting! \r\n", ifUpMask);
    672c:	f01b fc0e 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
    6730:	2800      	cmp	r0, #0
    6732:	f000 8189 	beq.w	6a48 <TCPIP_STACK_Task+0x5b4>
    6736:	f01b fc03 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
    673a:	462a      	mov	r2, r5
    673c:	4916      	ldr	r1, [pc, #88]	; (6798 <TCPIP_STACK_Task+0x304>)
    673e:	f014 f815 	bl	1a76c <SYS_CONSOLE_Print>
    6742:	e181      	b.n	6a48 <TCPIP_STACK_Task+0x5b4>
    newTcpipTickAvlbl = 0;
    6744:	4b11      	ldr	r3, [pc, #68]	; (678c <TCPIP_STACK_Task+0x2f8>)
    6746:	2200      	movs	r2, #0
    6748:	601a      	str	r2, [r3, #0]
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    674a:	4b07      	ldr	r3, [pc, #28]	; (6768 <TCPIP_STACK_Task+0x2d4>)
    674c:	681c      	ldr	r4, [r3, #0]
    674e:	4b04      	ldr	r3, [pc, #16]	; (6760 <TCPIP_STACK_Task+0x2cc>)
    6750:	681b      	ldr	r3, [r3, #0]
    6752:	4293      	cmp	r3, r2
    6754:	f340 8182 	ble.w	6a5c <TCPIP_STACK_Task+0x5c8>
    6758:	4615      	mov	r5, r2
    675a:	4e01      	ldr	r6, [pc, #4]	; (6760 <TCPIP_STACK_Task+0x2cc>)
    675c:	e025      	b.n	67aa <TCPIP_STACK_Task+0x316>
    675e:	bf00      	nop
    6760:	2000e2f0 	.word	0x2000e2f0
    6764:	2000e729 	.word	0x2000e729
    6768:	2000e648 	.word	0x2000e648
    676c:	2000e64c 	.word	0x2000e64c
    6770:	2000e654 	.word	0x2000e654
    6774:	0001fdcd 	.word	0x0001fdcd
    6778:	10624dd3 	.word	0x10624dd3
    677c:	2000e640 	.word	0x2000e640
    6780:	2000d1f4 	.word	0x2000d1f4
    6784:	00008904 	.word	0x00008904
    6788:	000088d4 	.word	0x000088d4
    678c:	2000e638 	.word	0x2000e638
    6790:	2000e650 	.word	0x2000e650
    6794:	2000e63c 	.word	0x2000e63c
    6798:	00008974 	.word	0x00008974
    679c:	2000e634 	.word	0x2000e634
    67a0:	3501      	adds	r5, #1
    67a2:	346c      	adds	r4, #108	; 0x6c
    67a4:	6833      	ldr	r3, [r6, #0]
    67a6:	429d      	cmp	r5, r3
    67a8:	da19      	bge.n	67de <TCPIP_STACK_Task+0x34a>
        if(pNetIf->Flags.bInterfaceEnabled)
    67aa:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
    67ae:	f013 0f40 	tst.w	r3, #64	; 0x40
    67b2:	d0f5      	beq.n	67a0 <TCPIP_STACK_Task+0x30c>
            linkCurr = (*pNetIf->pMacObj->TCPIP_MAC_LinkCheck)(pNetIf->hIfMac);     // check link status
    67b4:	6c63      	ldr	r3, [r4, #68]	; 0x44
    67b6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    67b8:	6d20      	ldr	r0, [r4, #80]	; 0x50
    67ba:	4798      	blx	r3
            linkPrev = pNetIf->exFlags.linkPrev != 0;
    67bc:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
            if(linkPrev != linkCurr)
    67c0:	f003 0301 	and.w	r3, r3, #1
    67c4:	4298      	cmp	r0, r3
    67c6:	d0eb      	beq.n	67a0 <TCPIP_STACK_Task+0x30c>
                pNetIf->exFlags.connEvent = 1;
    67c8:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
                pNetIf->exFlags.connEventType = linkCurr ? 1 : 0 ;
    67cc:	f043 0302 	orr.w	r3, r3, #2
    67d0:	f360 0382 	bfi	r3, r0, #2, #1
                pNetIf->exFlags.linkPrev = linkCurr;
    67d4:	f360 0300 	bfi	r3, r0, #0, #1
    67d8:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
    67dc:	e7e0      	b.n	67a0 <TCPIP_STACK_Task+0x30c>
        wasTickEvent = true;
    67de:	2601      	movs	r6, #1
    67e0:	e744      	b.n	666c <TCPIP_STACK_Task+0x1d8>
    67e2:	2601      	movs	r6, #1
    67e4:	e747      	b.n	6676 <TCPIP_STACK_Task+0x1e2>
    while((pRxPkt = (*pNetIf->pMacObj->TCPIP_MAC_PacketRx)(pNetIf->hIfMac, 0, 0)) != 0)
    67e6:	2500      	movs	r5, #0
    67e8:	e004      	b.n	67f4 <TCPIP_STACK_Task+0x360>
    pRxPkt->pktIf = pNetIf;
    67ea:	628c      	str	r4, [r1, #40]	; 0x28
    _TCPIPStackModuleRxInsert(TCPIP_MODULE_MANAGER, pRxPkt, 0);
    67ec:	462a      	mov	r2, r5
    67ee:	4638      	mov	r0, r7
    67f0:	f016 fdbc 	bl	1d36c <_TCPIPStackModuleRxInsert>
    while((pRxPkt = (*pNetIf->pMacObj->TCPIP_MAC_PacketRx)(pNetIf->hIfMac, 0, 0)) != 0)
    67f4:	6c63      	ldr	r3, [r4, #68]	; 0x44
    67f6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    67f8:	462a      	mov	r2, r5
    67fa:	4629      	mov	r1, r5
    67fc:	6d20      	ldr	r0, [r4, #80]	; 0x50
    67fe:	4798      	blx	r3
    6800:	4601      	mov	r1, r0
    6802:	2800      	cmp	r0, #0
    6804:	d1f1      	bne.n	67ea <TCPIP_STACK_Task+0x356>
                newTcpipStackEventCnt++;
    6806:	f8da 3000 	ldr.w	r3, [sl]
    680a:	3301      	adds	r3, #1
    680c:	f8ca 3000 	str.w	r3, [sl]
    6810:	e031      	b.n	6876 <TCPIP_STACK_Task+0x3e2>
                (*pNetIf->pMacObj->TCPIP_MAC_Process)(pNetIf->hIfMac);
    6812:	6c63      	ldr	r3, [r4, #68]	; 0x44
    6814:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    6816:	6d20      	ldr	r0, [r4, #80]	; 0x50
    6818:	4798      	blx	r3
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    681a:	f108 0801 	add.w	r8, r8, #1
    681e:	346c      	adds	r4, #108	; 0x6c
    6820:	f8d9 3000 	ldr.w	r3, [r9]
    6824:	4543      	cmp	r3, r8
    6826:	dd2c      	ble.n	6882 <TCPIP_STACK_Task+0x3ee>
            if (!pNetIf->Flags.bInterfaceEnabled || !_TCPIPStackNetIsPrimary(pNetIf))
    6828:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
    682c:	f013 0f40 	tst.w	r3, #64	; 0x40
    6830:	d0f3      	beq.n	681a <TCPIP_STACK_Task+0x386>
            activeEvents =  pNetIf->activeEvents;
    6832:	f8b4 505a 	ldrh.w	r5, [r4, #90]	; 0x5a
            activeEvents |= (*pNetIf->pMacObj->TCPIP_MAC_EventPendingGet)(pNetIf->hIfMac);
    6836:	6c63      	ldr	r3, [r4, #68]	; 0x44
    6838:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    683a:	6d20      	ldr	r0, [r4, #80]	; 0x50
    683c:	4798      	blx	r3
    683e:	4305      	orrs	r5, r0
    6840:	b2ad      	uxth	r5, r5
    return OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
    6842:	4638      	mov	r0, r7
    6844:	f01a fe2a 	bl	2149c <OSAL_CRIT_Enter>
    pNetIf->activeEvents &= ~event;
    6848:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
    684c:	ea23 0305 	bic.w	r3, r3, r5
    6850:	f8a4 305a 	strh.w	r3, [r4, #90]	; 0x5a
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, suspLevel);
    6854:	4601      	mov	r1, r0
    6856:	4638      	mov	r0, r7
    6858:	f01a ff4f 	bl	216fa <OSAL_CRIT_Leave>
            pNetIf->currEvents |= activeEvents;     // store all the processed events
    685c:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
    6860:	432b      	orrs	r3, r5
    6862:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
            (*pNetIf->pMacObj->TCPIP_MAC_EventAcknowledge)(pNetIf->hIfMac, activeEvents);
    6866:	6c63      	ldr	r3, [r4, #68]	; 0x44
    6868:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    686a:	4629      	mov	r1, r5
    686c:	6d20      	ldr	r0, [r4, #80]	; 0x50
    686e:	4798      	blx	r3
            if((activeEvents & (TCPIP_STACK_MAC_ACTIVE_RX_EVENTS)) != 0)
    6870:	f015 0f16 	tst.w	r5, #22
    6874:	d1b7      	bne.n	67e6 <TCPIP_STACK_Task+0x352>
            if(pNetIf->Flags.bMacProcessOnEvent != 0)
    6876:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    687a:	f013 0f20 	tst.w	r3, #32
    687e:	d0cc      	beq.n	681a <TCPIP_STACK_Task+0x386>
    6880:	e7c7      	b.n	6812 <TCPIP_STACK_Task+0x37e>
    uint32_t                    procFrameMask = 0;
    6882:	2500      	movs	r5, #0
    while((pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(pPktQueue)))
    6884:	4c82      	ldr	r4, [pc, #520]	; (6a90 <TCPIP_STACK_Task+0x5fc>)
        pFrameEntry = TCPIP_FRAME_PROCESS_TBL;
    6886:	4f83      	ldr	r7, [pc, #524]	; (6a94 <TCPIP_STACK_Task+0x600>)
        for(frameIx = 0; frameIx < sizeof(TCPIP_FRAME_PROCESS_TBL) / sizeof(*TCPIP_FRAME_PROCESS_TBL); frameIx++, pFrameEntry++)
    6888:	f107 0806 	add.w	r8, r7, #6
    while((pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(pPktQueue)))
    688c:	4620      	mov	r0, r4
    688e:	f01a fab3 	bl	20df8 <TCPIP_Helper_SingleListHeadRemove>
    6892:	4684      	mov	ip, r0
    6894:	2800      	cmp	r0, #0
    6896:	d048      	beq.n	692a <TCPIP_STACK_Task+0x496>
        frameType = TCPIP_Helper_ntohs(pMacHdr->Type);
    6898:	f8dc 3014 	ldr.w	r3, [ip, #20]
    689c:	899a      	ldrh	r2, [r3, #12]
       return (((hShort) << 8) | ((hShort) >> 8));
    689e:	0a13      	lsrs	r3, r2, #8
    68a0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    68a4:	b29b      	uxth	r3, r3
            if(pFrameEntry->frameType == frameType)
    68a6:	f640 0206 	movw	r2, #2054	; 0x806
    68aa:	4293      	cmp	r3, r2
    68ac:	d016      	beq.n	68dc <TCPIP_STACK_Task+0x448>
    68ae:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
    68b2:	d00a      	beq.n	68ca <TCPIP_STACK_Task+0x436>
    68b4:	f64f 72ff 	movw	r2, #65535	; 0xffff
    68b8:	4293      	cmp	r3, r2
    68ba:	d00a      	beq.n	68d2 <TCPIP_STACK_Task+0x43e>
            TCPIP_PKT_PacketAcknowledge(pRxPkt, TCPIP_MAC_PKT_ACK_TYPE_ERR); 
    68bc:	2201      	movs	r2, #1
    68be:	f06f 010c 	mvn.w	r1, #12
    68c2:	4660      	mov	r0, ip
    68c4:	f017 f866 	bl	1d994 <_TCPIP_PKT_PacketAcknowledge>
    68c8:	e7e0      	b.n	688c <TCPIP_STACK_Task+0x3f8>
        for(frameIx = 0; frameIx < sizeof(TCPIP_FRAME_PROCESS_TBL) / sizeof(*TCPIP_FRAME_PROCESS_TBL); frameIx++, pFrameEntry++)
    68ca:	46c1      	mov	r9, r8
    68cc:	f04f 0a01 	mov.w	sl, #1
    68d0:	e007      	b.n	68e2 <TCPIP_STACK_Task+0x44e>
    68d2:	f107 090c 	add.w	r9, r7, #12
    68d6:	f04f 0a02 	mov.w	sl, #2
    68da:	e002      	b.n	68e2 <TCPIP_STACK_Task+0x44e>
    68dc:	f04f 0a00 	mov.w	sl, #0
        pFrameEntry = TCPIP_FRAME_PROCESS_TBL;
    68e0:	46b9      	mov	r9, r7
                pRxPkt->pktFlags &= ~TCPIP_MAC_PKT_FLAG_TYPE_MASK;
    68e2:	f8bc 3022 	ldrh.w	r3, [ip, #34]	; 0x22
    68e6:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
    68ea:	b29b      	uxth	r3, r3
    68ec:	f8ac 3022 	strh.w	r3, [ip, #34]	; 0x22
                pRxPkt->pktFlags |= pFrameEntry->pktTypeFlags;
    68f0:	f8b9 2002 	ldrh.w	r2, [r9, #2]
    68f4:	4313      	orrs	r3, r2
    68f6:	f8ac 3022 	strh.w	r3, [ip, #34]	; 0x22
                _TCPIPStackModuleRxInsert(pFrameEntry->moduleId, pRxPkt, 0);
    68fa:	2200      	movs	r2, #0
    68fc:	4661      	mov	r1, ip
    68fe:	f8b9 0004 	ldrh.w	r0, [r9, #4]
    6902:	f016 fd33 	bl	1d36c <_TCPIPStackModuleRxInsert>
                    if((procFrameMask & (1 << frameIx)) == 0)
    6906:	2301      	movs	r3, #1
    6908:	fa03 fa0a 	lsl.w	sl, r3, sl
    690c:	ea1a 0f05 	tst.w	sl, r5
    6910:	d1bc      	bne.n	688c <TCPIP_STACK_Task+0x3f8>
                        procFrameMask |= 1 << frameIx;
    6912:	ea45 050a 	orr.w	r5, r5, sl
    return TCPIP_STACK_MODULE_SIGNAL_TBL + modId;
    6916:	f8b9 0004 	ldrh.w	r0, [r9, #4]
    _TCPIPSignalEntrySetNotify(_TCPIPModuleToSignalEntry(modId), signals, 0);
    691a:	2200      	movs	r2, #0
    691c:	4619      	mov	r1, r3
    691e:	4b5e      	ldr	r3, [pc, #376]	; (6a98 <TCPIP_STACK_Task+0x604>)
    6920:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    6924:	f019 fa66 	bl	1fdf4 <_TCPIPSignalEntrySetNotify>
    6928:	e7b0      	b.n	688c <TCPIP_STACK_Task+0x3f8>
    tmoMask = clrMask & TCPIP_MODULE_SIGNAL_TMO;
    rxMask = clrMask & TCPIP_MODULE_SIGNAL_RX_PENDING;


    // protect against ISRs (MAC + TMR) and other threads too!
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
    692a:	2001      	movs	r0, #1
    692c:	f01a fdb6 	bl	2149c <OSAL_CRIT_Enter>
    {
        pTmoEntry->signalVal &= (uint16_t)(~TCPIP_MODULE_SIGNAL_TMO);
    }
    if(rxMask)
    {
        pMgrEntry->signalVal &= (uint16_t)(~TCPIP_MODULE_SIGNAL_RX_PENDING);
    6930:	4a59      	ldr	r2, [pc, #356]	; (6a98 <TCPIP_STACK_Task+0x604>)
    6932:	8b13      	ldrh	r3, [r2, #24]
    6934:	f023 0301 	bic.w	r3, r3, #1
    6938:	8313      	strh	r3, [r2, #24]
    }
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, critSect);
    693a:	4601      	mov	r1, r0
    693c:	2001      	movs	r0, #1
    693e:	f01a fedc 	bl	216fa <OSAL_CRIT_Leave>
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    6942:	4b56      	ldr	r3, [pc, #344]	; (6a9c <TCPIP_STACK_Task+0x608>)
    6944:	681c      	ldr	r4, [r3, #0]
    6946:	4b56      	ldr	r3, [pc, #344]	; (6aa0 <TCPIP_STACK_Task+0x60c>)
    6948:	681b      	ldr	r3, [r3, #0]
    694a:	2b00      	cmp	r3, #0
    694c:	dd35      	ble.n	69ba <TCPIP_STACK_Task+0x526>
    694e:	2500      	movs	r5, #0
        if((activeEvents & TCPIP_MAC_EV_RXTX_ERRORS) != 0)
    6950:	f240 6886 	movw	r8, #1670	; 0x686
    newTcpipErrorEventCnt++;
    6954:	f8df 9168 	ldr.w	r9, [pc, #360]	; 6ac0 <TCPIP_STACK_Task+0x62c>
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    6958:	4f51      	ldr	r7, [pc, #324]	; (6aa0 <TCPIP_STACK_Task+0x60c>)
    695a:	e00c      	b.n	6976 <TCPIP_STACK_Task+0x4e2>
        if(pNetIf->exFlags.connEvent != 0)
    695c:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
    6960:	f012 0f02 	tst.w	r2, #2
    6964:	d117      	bne.n	6996 <TCPIP_STACK_Task+0x502>
        pNetIf->currEvents = 0;
    6966:	2300      	movs	r3, #0
    6968:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    696c:	3501      	adds	r5, #1
    696e:	346c      	adds	r4, #108	; 0x6c
    6970:	683b      	ldr	r3, [r7, #0]
    6972:	42ab      	cmp	r3, r5
    6974:	dd21      	ble.n	69ba <TCPIP_STACK_Task+0x526>
        if (!pNetIf->Flags.bInterfaceEnabled || !_TCPIPStackNetIsPrimary(pNetIf))
    6976:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
    697a:	f013 0f40 	tst.w	r3, #64	; 0x40
    697e:	d0f5      	beq.n	696c <TCPIP_STACK_Task+0x4d8>
        activeEvents = pNetIf->currEvents;
    6980:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
        if((activeEvents & TCPIP_MAC_EV_RXTX_ERRORS) != 0)
    6984:	ea13 0f08 	tst.w	r3, r8
    6988:	d0e8      	beq.n	695c <TCPIP_STACK_Task+0x4c8>
    newTcpipErrorEventCnt++;
    698a:	f8d9 2000 	ldr.w	r2, [r9]
    698e:	3201      	adds	r2, #1
    6990:	f8c9 2000 	str.w	r2, [r9]
    6994:	e7e2      	b.n	695c <TCPIP_STACK_Task+0x4c8>
            activeEvents |= pNetIf->exFlags.connEventType ? TCPIP_MAC_EV_CONN_ESTABLISHED : TCPIP_MAC_EV_CONN_LOST;
    6996:	f012 0f04 	tst.w	r2, #4
    699a:	bf14      	ite	ne
    699c:	f44f 6100 	movne.w	r1, #2048	; 0x800
    69a0:	f44f 5180 	moveq.w	r1, #4096	; 0x1000
            pNetIf->exFlags.connEvent = 0;
    69a4:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
    69a8:	f36f 0241 	bfc	r2, #1, #1
    69ac:	f884 2060 	strb.w	r2, [r4, #96]	; 0x60
                    (*TCPIP_STACK_CONN_EVENT_TBL[modIx])(pAliasIf, activeEvents);
    69b0:	4319      	orrs	r1, r3
    69b2:	4620      	mov	r0, r4
    69b4:	f013 fa48 	bl	19e48 <TCPIP_DHCP_ConnectionHandler>
    69b8:	e7d5      	b.n	6966 <TCPIP_STACK_Task+0x4d2>
    if(wasTickEvent)
    69ba:	2e00      	cmp	r6, #0
    69bc:	d153      	bne.n	6a66 <TCPIP_STACK_Task+0x5d2>
    69be:	4b36      	ldr	r3, [pc, #216]	; (6a98 <TCPIP_STACK_Task+0x604>)
    69c0:	f103 0430 	add.w	r4, r3, #48	; 0x30
    69c4:	f503 7820 	add.w	r8, r3, #640	; 0x280
        critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    69c8:	2600      	movs	r6, #0
    69ca:	e029      	b.n	6a20 <TCPIP_STACK_Task+0x58c>
            continue;
        }

        if((pSigEntry->currTmo -= stackTaskRate) <= 0)
        {   // timeout: send a signal to this module
            pSigEntry->currTmo += pSigEntry->asyncTmo;
    69cc:	4413      	add	r3, r2
    69ce:	81a3      	strh	r3, [r4, #12]
            _TCPIPSignalEntrySetNotify(pSigEntry, TCPIP_MODULE_SIGNAL_TMO, 0); 
    69d0:	463a      	mov	r2, r7
    69d2:	2102      	movs	r1, #2
    69d4:	4620      	mov	r0, r4
    69d6:	f019 fa0d 	bl	1fdf4 <_TCPIPSignalEntrySetNotify>
    for(ix = TCPIP_MODULE_LAYER1; ix < sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL)/sizeof(*TCPIP_STACK_MODULE_SIGNAL_TBL); ix++, pSigEntry++)
    69da:	3410      	adds	r4, #16
    69dc:	42ac      	cmp	r4, r5
    69de:	d00f      	beq.n	6a00 <TCPIP_STACK_Task+0x56c>
        if(pSigEntry->signalHandler == 0 || pSigEntry->asyncTmo == 0)
    69e0:	6823      	ldr	r3, [r4, #0]
    69e2:	2b00      	cmp	r3, #0
    69e4:	d0f9      	beq.n	69da <TCPIP_STACK_Task+0x546>
    69e6:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
    69ea:	2a00      	cmp	r2, #0
    69ec:	d0f5      	beq.n	69da <TCPIP_STACK_Task+0x546>
        if((pSigEntry->currTmo -= stackTaskRate) <= 0)
    69ee:	6831      	ldr	r1, [r6, #0]
    69f0:	89a3      	ldrh	r3, [r4, #12]
    69f2:	1a5b      	subs	r3, r3, r1
    69f4:	b29b      	uxth	r3, r3
    69f6:	b219      	sxth	r1, r3
    69f8:	2900      	cmp	r1, #0
    69fa:	dde7      	ble.n	69cc <TCPIP_STACK_Task+0x538>
    69fc:	81a1      	strh	r1, [r4, #12]
    69fe:	e7ec      	b.n	69da <TCPIP_STACK_Task+0x546>
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
    6a00:	2001      	movs	r0, #1
    6a02:	f01a fd4b 	bl	2149c <OSAL_CRIT_Enter>
        pTmoEntry->signalVal &= (uint16_t)(~TCPIP_MODULE_SIGNAL_TMO);
    6a06:	4a24      	ldr	r2, [pc, #144]	; (6a98 <TCPIP_STACK_Task+0x604>)
    6a08:	8913      	ldrh	r3, [r2, #8]
    6a0a:	f023 0302 	bic.w	r3, r3, #2
    6a0e:	8113      	strh	r3, [r2, #8]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, critSect);
    6a10:	4601      	mov	r1, r0
    6a12:	2001      	movs	r0, #1
    6a14:	f01a fe71 	bl	216fa <OSAL_CRIT_Leave>
    return mgrSignal;
    6a18:	e7d1      	b.n	69be <TCPIP_STACK_Task+0x52a>
    6a1a:	3410      	adds	r4, #16
    for(modIx = TCPIP_MODULE_LAYER1; modIx < sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL)/sizeof(*TCPIP_STACK_MODULE_SIGNAL_TBL); modIx++, pSigEntry++)
    6a1c:	4544      	cmp	r4, r8
    6a1e:	d010      	beq.n	6a42 <TCPIP_STACK_Task+0x5ae>
        critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    6a20:	4630      	mov	r0, r6
    6a22:	f01a fd3b 	bl	2149c <OSAL_CRIT_Enter>
        signalHandler = pSigEntry->signalHandler;
    6a26:	f854 5c10 	ldr.w	r5, [r4, #-16]
        signalVal = pSigEntry->signalVal;
    6a2a:	f834 7c08 	ldrh.w	r7, [r4, #-8]
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
    6a2e:	4601      	mov	r1, r0
    6a30:	4630      	mov	r0, r6
    6a32:	f01a fe62 	bl	216fa <OSAL_CRIT_Leave>
        if(signalHandler == 0 || signalVal == 0)
    6a36:	2d00      	cmp	r5, #0
    6a38:	d0ef      	beq.n	6a1a <TCPIP_STACK_Task+0x586>
    6a3a:	2f00      	cmp	r7, #0
    6a3c:	d0ed      	beq.n	6a1a <TCPIP_STACK_Task+0x586>
        (*signalHandler)();
    6a3e:	47a8      	blx	r5
    6a40:	e7eb      	b.n	6a1a <TCPIP_STACK_Task+0x586>
    if(stackAsyncSignalCount != 0)
    6a42:	4b18      	ldr	r3, [pc, #96]	; (6aa4 <TCPIP_STACK_Task+0x610>)
    6a44:	681b      	ldr	r3, [r3, #0]
    6a46:	b913      	cbnz	r3, 6a4e <TCPIP_STACK_Task+0x5ba>
}
    6a48:	b004      	add	sp, #16
    6a4a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        _TCPIPSignalEntryNotify(_TCPIPModuleToSignalEntry(TCPIP_MODULE_MANAGER), TCPIP_MODULE_SIGNAL_ASYNC, 0);
    6a4e:	2200      	movs	r2, #0
    6a50:	f44f 7180 	mov.w	r1, #256	; 0x100
    6a54:	4814      	ldr	r0, [pc, #80]	; (6aa8 <TCPIP_STACK_Task+0x614>)
    6a56:	f01a f9eb 	bl	20e30 <_TCPIPSignalEntryNotify>
    6a5a:	e7f5      	b.n	6a48 <TCPIP_STACK_Task+0x5b4>
    if( totTcpipEventsCnt)
    6a5c:	4b13      	ldr	r3, [pc, #76]	; (6aac <TCPIP_STACK_Task+0x618>)
    6a5e:	681b      	ldr	r3, [r3, #0]
    6a60:	2b00      	cmp	r3, #0
    6a62:	f47f aebe 	bne.w	67e2 <TCPIP_STACK_Task+0x34e>
    pSigEntry = TCPIP_STACK_MODULE_SIGNAL_TBL + TCPIP_MODULE_LAYER1;
    6a66:	4c12      	ldr	r4, [pc, #72]	; (6ab0 <TCPIP_STACK_Task+0x61c>)
        if((pSigEntry->currTmo -= stackTaskRate) <= 0)
    6a68:	4e12      	ldr	r6, [pc, #72]	; (6ab4 <TCPIP_STACK_Task+0x620>)
            _TCPIPSignalEntrySetNotify(pSigEntry, TCPIP_MODULE_SIGNAL_TMO, 0); 
    6a6a:	2700      	movs	r7, #0
    for(ix = TCPIP_MODULE_LAYER1; ix < sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL)/sizeof(*TCPIP_STACK_MODULE_SIGNAL_TBL); ix++, pSigEntry++)
    6a6c:	f504 7514 	add.w	r5, r4, #592	; 0x250
    6a70:	e7b6      	b.n	69e0 <TCPIP_STACK_Task+0x54c>
    if(tcpip_stack_status == SYS_STATUS_BUSY)
    6a72:	4b11      	ldr	r3, [pc, #68]	; (6ab8 <TCPIP_STACK_Task+0x624>)
    6a74:	f993 3000 	ldrsb.w	r3, [r3]
    6a78:	2b01      	cmp	r3, #1
    6a7a:	f47f ade5 	bne.w	6648 <TCPIP_STACK_Task+0x1b4>
            tcpip_stack_status = SYS_STATUS_READY;
    6a7e:	4b0e      	ldr	r3, [pc, #56]	; (6ab8 <TCPIP_STACK_Task+0x624>)
    6a80:	2202      	movs	r2, #2
    6a82:	701a      	strb	r2, [r3, #0]
            SYS_CONSOLE_MESSAGE(TCPIP_STACK_HDR_MESSAGE "Initialization Ended - success \r\n");
    6a84:	490d      	ldr	r1, [pc, #52]	; (6abc <TCPIP_STACK_Task+0x628>)
    6a86:	2000      	movs	r0, #0
    6a88:	f018 fbcc 	bl	1f224 <SYS_CONSOLE_Message>
    6a8c:	e5dc      	b.n	6648 <TCPIP_STACK_Task+0x1b4>
    6a8e:	4770      	bx	lr
    6a90:	2000de90 	.word	0x2000de90
    6a94:	00021484 	.word	0x00021484
    6a98:	2000d1d4 	.word	0x2000d1d4
    6a9c:	2000e648 	.word	0x2000e648
    6aa0:	2000e2f0 	.word	0x2000e2f0
    6aa4:	2000e63c 	.word	0x2000e63c
    6aa8:	2000d1e4 	.word	0x2000d1e4
    6aac:	2000e650 	.word	0x2000e650
    6ab0:	2000d1f4 	.word	0x2000d1f4
    6ab4:	2000e640 	.word	0x2000e640
    6ab8:	2000e729 	.word	0x2000e729
    6abc:	00008944 	.word	0x00008944
    6ac0:	2000e630 	.word	0x2000e630

Disassembly of section .text.CommandIperfStart%196:

00006ac4 <CommandIperfStart>:
	}
	return 0;
}

static void CommandIperfStart(SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char** argv)
{
    6ac4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6ac8:	b08d      	sub	sp, #52	; 0x34
    6aca:	4682      	mov	sl, r0
    6acc:	468b      	mov	fp, r1
    uint32_t tickFreq;
    uint32_t values[4], bw=0;
    
    float pktRate;
    uint16_t payloadSize = 0, asciTos;
    const void* cmdIoParam = pCmdIO->cmdIoParam;
    6ace:	6843      	ldr	r3, [r0, #4]
    6ad0:	9302      	str	r3, [sp, #8]
    for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
    6ad2:	4bae      	ldr	r3, [pc, #696]	; (6d8c <CommandIperfStart+0x2c8>)
    6ad4:	6819      	ldr	r1, [r3, #0]
    6ad6:	2900      	cmp	r1, #0
    6ad8:	f340 82ba 	ble.w	7050 <CommandIperfStart+0x58c>
    6adc:	4691      	mov	r9, r2
		if(pIState->state == (uint8_t)IPERF_STANDBY_STATE)
    6ade:	4bac      	ldr	r3, [pc, #688]	; (6d90 <CommandIperfStart+0x2cc>)
    6ae0:	f893 30ce 	ldrb.w	r3, [r3, #206]	; 0xce
    6ae4:	2b01      	cmp	r3, #1
    6ae6:	f000 82ba 	beq.w	705e <CommandIperfStart+0x59a>
    for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
    6aea:	2300      	movs	r3, #0
    6aec:	4da8      	ldr	r5, [pc, #672]	; (6d90 <CommandIperfStart+0x2cc>)
    6aee:	3301      	adds	r3, #1
    6af0:	35d8      	adds	r5, #216	; 0xd8
    6af2:	428b      	cmp	r3, r1
    6af4:	f000 82ac 	beq.w	7050 <CommandIperfStart+0x58c>
		if(pIState->state == (uint8_t)IPERF_STANDBY_STATE)
    6af8:	f895 20ce 	ldrb.w	r2, [r5, #206]	; 0xce
    6afc:	2a01      	cmp	r2, #1
    6afe:	d1f6      	bne.n	6aee <CommandIperfStart+0x2a>
    {
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "\r\niperf: All instances busy. Retry later!\r\n");
        return;
    }

    (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: Starting session instance %d\r\n", pIState - gIperfState);
    6b00:	4ba3      	ldr	r3, [pc, #652]	; (6d90 <CommandIperfStart+0x2cc>)
    6b02:	1aeb      	subs	r3, r5, r3
    6b04:	10db      	asrs	r3, r3, #3
    6b06:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
    6b0a:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    6b0e:	ebc3 2343 	rsb	r3, r3, r3, lsl #9
    6b12:	eb03 4383 	add.w	r3, r3, r3, lsl #18
    6b16:	f8da 2000 	ldr.w	r2, [sl]
    6b1a:	6854      	ldr	r4, [r2, #4]
    6b1c:	425a      	negs	r2, r3
    6b1e:	499d      	ldr	r1, [pc, #628]	; (6d94 <CommandIperfStart+0x2d0>)
    6b20:	9802      	ldr	r0, [sp, #8]
    6b22:	47a0      	blx	r4

	// preparation for new iperf test
    pIState->mServerMode = false;
    6b24:	2400      	movs	r4, #0
    6b26:	f885 40d1 	strb.w	r4, [r5, #209]	; 0xd1
#if defined(TCPIP_STACK_USE_TCP)
    pIState->mProtocol = TCP_PROTOCOL;   			// default is TCP mode.
    6b2a:	2302      	movs	r3, #2
    6b2c:	742b      	strb	r3, [r5, #16]
#else
    pIState->mProtocol = UDP_PROTOCOL;
#endif  // defined(TCPIP_STACK_USE_TCP)
    pIState->stopRequested = false;
    6b2e:	f885 40cf 	strb.w	r4, [r5, #207]	; 0xcf

    pIState->mServerPort = TCPIP_IPERF_SERVER_PORT;		// -p. default: server port 5001
    6b32:	f241 3389 	movw	r3, #5001	; 0x1389
    6b36:	826b      	strh	r3, [r5, #18]

    pIState->mTxRate = ((uint32_t) TCPIP_IPERF_TX_BW_LIMIT*1000)*((uint32_t) 1000);		// -b or -x. Target tx rate.
    6b38:	4b97      	ldr	r3, [pc, #604]	; (6d98 <CommandIperfStart+0x2d4>)
    6b3a:	61ab      	str	r3, [r5, #24]
    // KS: default tx rate for iperf is actually 1Mbps.

    tickFreq = SYS_TMR_TickCounterFrequencyGet(); 
    6b3c:	f019 fa5e 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
    6b40:	9004      	str	r0, [sp, #16]
    pIState->mAmount = 0;			// -n: default 0.
    6b42:	606c      	str	r4, [r5, #4]
    pIState->mDuration = ((uint32_t) 10)*(tickFreq); // -t: default 10 sec.
    6b44:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    6b48:	005b      	lsls	r3, r3, #1
    6b4a:	60ab      	str	r3, [r5, #8]
    pIState->mInterval =  tickFreq; 	// -i: default 1 sec.
    6b4c:	6028      	str	r0, [r5, #0]

    pIState->mTypeOfService = 0;       //-S, --tos (Type Of Service): default 0: BestEffort
    6b4e:	752c      	strb	r4, [r5, #20]
    // remember the console we've been invoked from
    pIState->pCmdIO = pCmdIO;
    6b50:	f8c5 a0c4 	str.w	sl, [r5, #196]	; 0xc4

    
    // Initialize statistics

    ResetIperfCounters(pIState);
    6b54:	4628      	mov	r0, r5
    6b56:	f015 fdb9 	bl	1c6cc <ResetIperfCounters>

    for (i = 1; i < argc; i++)
    6b5a:	f1bb 0f01 	cmp.w	fp, #1
    6b5e:	f340 81e1 	ble.w	6f24 <CommandIperfStart+0x460>
    6b62:	2401      	movs	r4, #1
    {
        if ((memcmp(argv[i], "-s", 2) == 0) || (memcmp(argv[i], "--server", 5) == 0) )
    6b64:	4e8d      	ldr	r6, [pc, #564]	; (6d9c <CommandIperfStart+0x2d8>)
                 mpf2 = mpf2/10;
    6b66:	f8cd a00c 	str.w	sl, [sp, #12]
    6b6a:	e007      	b.n	6b7c <CommandIperfStart+0xb8>
        {
            // Function as an iperf server.

            pIState->mServerMode = true;
    6b6c:	2301      	movs	r3, #1
    6b6e:	f885 30d1 	strb.w	r3, [r5, #209]	; 0xd1
    for (i = 1; i < argc; i++)
    6b72:	3401      	adds	r4, #1
    6b74:	b2e4      	uxtb	r4, r4
    6b76:	455c      	cmp	r4, fp
    6b78:	f280 81d2 	bge.w	6f20 <CommandIperfStart+0x45c>
        if ((memcmp(argv[i], "-s", 2) == 0) || (memcmp(argv[i], "--server", 5) == 0) )
    6b7c:	f859 7024 	ldr.w	r7, [r9, r4, lsl #2]
    6b80:	2202      	movs	r2, #2
    6b82:	4987      	ldr	r1, [pc, #540]	; (6da0 <CommandIperfStart+0x2dc>)
    6b84:	4638      	mov	r0, r7
    6b86:	f01a fa5d 	bl	21044 <memcmp>
    6b8a:	2800      	cmp	r0, #0
    6b8c:	d0ee      	beq.n	6b6c <CommandIperfStart+0xa8>
    6b8e:	2205      	movs	r2, #5
    6b90:	f506 7117 	add.w	r1, r6, #604	; 0x25c
    6b94:	4638      	mov	r0, r7
    6b96:	f01a fa55 	bl	21044 <memcmp>
    6b9a:	2800      	cmp	r0, #0
    6b9c:	d0e6      	beq.n	6b6c <CommandIperfStart+0xa8>
        }
#if defined(TCPIP_STACK_USE_UDP)
        else if ((memcmp(argv[i], "-u", 2) == 0) || (memcmp(argv[i], "--udp", 5) == 0) )
    6b9e:	2202      	movs	r2, #2
    6ba0:	f506 711a 	add.w	r1, r6, #616	; 0x268
    6ba4:	4638      	mov	r0, r7
    6ba6:	f01a fa4d 	bl	21044 <memcmp>
    6baa:	b130      	cbz	r0, 6bba <CommandIperfStart+0xf6>
    6bac:	2205      	movs	r2, #5
    6bae:	f506 711b 	add.w	r1, r6, #620	; 0x26c
    6bb2:	4638      	mov	r0, r7
    6bb4:	f01a fa46 	bl	21044 <memcmp>
    6bb8:	b910      	cbnz	r0, 6bc0 <CommandIperfStart+0xfc>
        {
            // iperf UDP mode.
            pIState->mProtocol = UDP_PROTOCOL;
    6bba:	2301      	movs	r3, #1
    6bbc:	742b      	strb	r3, [r5, #16]
    6bbe:	e7d8      	b.n	6b72 <CommandIperfStart+0xae>
        }
        else if ((memcmp(argv[i], "-b", 2) == 0) || (memcmp(argv[i], "--bandwidth", 5) == 0) )
    6bc0:	2202      	movs	r2, #2
    6bc2:	f506 711d 	add.w	r1, r6, #628	; 0x274
    6bc6:	4638      	mov	r0, r7
    6bc8:	f01a fa3c 	bl	21044 <memcmp>
    6bcc:	b138      	cbz	r0, 6bde <CommandIperfStart+0x11a>
    6bce:	2205      	movs	r2, #5
    6bd0:	f506 711e 	add.w	r1, r6, #632	; 0x278
    6bd4:	4638      	mov	r0, r7
    6bd6:	f01a fa35 	bl	21044 <memcmp>
    6bda:	2800      	cmp	r0, #0
    6bdc:	d15d      	bne.n	6c9a <CommandIperfStart+0x1d6>
        {
            // iperf UDP mode.
            pIState->mProtocol = UDP_PROTOCOL;
    6bde:	2301      	movs	r3, #1
    6be0:	742b      	strb	r3, [r5, #16]

            // Next argument should be the target rate, in bps.
            i++;
    6be2:	441c      	add	r4, r3
    6be4:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
    6be6:	f859 8024 	ldr.w	r8, [r9, r4, lsl #2]
            len = strlen(ptr);
    6bea:	4640      	mov	r0, r8
    6bec:	f01a ffd6 	bl	21b9c <strlen>
            
            if((strcmp((ptr+(len-1)),"M")==0) || (strcmp((ptr+(len-1)),"K")==0))
    6bf0:	b2c7      	uxtb	r7, r0
    6bf2:	f107 3aff 	add.w	sl, r7, #4294967295
    6bf6:	44c2      	add	sl, r8
    6bf8:	f506 7121 	add.w	r1, r6, #644	; 0x284
    6bfc:	4650      	mov	r0, sl
    6bfe:	f01a fe7d 	bl	218fc <strcmp>
    6c02:	b1a8      	cbz	r0, 6c30 <CommandIperfStart+0x16c>
    6c04:	f506 7122 	add.w	r1, r6, #648	; 0x288
    6c08:	4650      	mov	r0, sl
    6c0a:	f01a fe77 	bl	218fc <strcmp>
    6c0e:	2800      	cmp	r0, #0
    6c10:	d13c      	bne.n	6c8c <CommandIperfStart+0x1c8>
        mpf1 = 100 * 10;
    6c12:	f44f 7a7a 	mov.w	sl, #1000	; 0x3e8
        for(j=0;j<len-1;j++)
    6c16:	f107 3eff 	add.w	lr, r7, #4294967295
    6c1a:	f1be 0f00 	cmp.w	lr, #0
    6c1e:	dd32      	ble.n	6c86 <CommandIperfStart+0x1c2>
    uint32_t bw1=0, bw2=0,  mpf1=0, mpf2 = 1000000;
    6c20:	f04f 0c00 	mov.w	ip, #0
    6c24:	4662      	mov	r2, ip
    uint8_t j, len, decimal=1;
    6c26:	2701      	movs	r7, #1
        for(j=0;j<len-1;j++)
    6c28:	4663      	mov	r3, ip
                decimal = 0;
    6c2a:	9405      	str	r4, [sp, #20]
    6c2c:	4654      	mov	r4, sl
    6c2e:	e1f8      	b.n	7022 <CommandIperfStart+0x55e>
    if(strcmp((ptr+(len-1)),"K")==0)
    6c30:	f506 7122 	add.w	r1, r6, #648	; 0x288
    6c34:	4650      	mov	r0, sl
    6c36:	f01a fe61 	bl	218fc <strcmp>
    6c3a:	2800      	cmp	r0, #0
        mpf1 = 1000 * 1000;
    6c3c:	4b59      	ldr	r3, [pc, #356]	; (6da4 <CommandIperfStart+0x2e0>)
    6c3e:	bf0c      	ite	eq
    6c40:	f44f 7a7a 	moveq.w	sl, #1000	; 0x3e8
    6c44:	469a      	movne	sl, r3
    6c46:	e7e6      	b.n	6c16 <CommandIperfStart+0x152>
                bw1 = bw1*10 + *(ptr+j) - '0';
    6c48:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    6c4c:	eb00 0242 	add.w	r2, r0, r2, lsl #1
    6c50:	3a30      	subs	r2, #48	; 0x30
    6c52:	e1f0      	b.n	7036 <CommandIperfStart+0x572>
    6c54:	4623      	mov	r3, r4
    6c56:	9c05      	ldr	r4, [sp, #20]
        bw2 = bw2 * mpf2;
    6c58:	fb03 f30c 	mul.w	r3, r3, ip
        if(bw1 < mpf1)
    6c5c:	4552      	cmp	r2, sl
    6c5e:	d201      	bcs.n	6c64 <CommandIperfStart+0x1a0>
            bw1 = bw1 * mpf1;
    6c60:	fb0a f202 	mul.w	r2, sl, r2
        values[0] = bw1;
    6c64:	9208      	str	r2, [sp, #32]
        values[1] = bw2;
    6c66:	9309      	str	r3, [sp, #36]	; 0x24
        (*pCmdIO->pCmdApi->print)(pCmdIO->cmdIoParam, "\nGiven in BW: %lu+%lu=%lu",bw1,bw2,bw1+bw2);
    6c68:	9903      	ldr	r1, [sp, #12]
    6c6a:	6809      	ldr	r1, [r1, #0]
    6c6c:	1898      	adds	r0, r3, r2
    6c6e:	9000      	str	r0, [sp, #0]
    6c70:	684f      	ldr	r7, [r1, #4]
    6c72:	f506 7123 	add.w	r1, r6, #652	; 0x28c
    6c76:	9803      	ldr	r0, [sp, #12]
    6c78:	6840      	ldr	r0, [r0, #4]
    6c7a:	47b8      	blx	r7
            {  
                bw_conversion(pCmdIO, ptr, values);
                bw = values[0]+values[1];
    6c7c:	9b08      	ldr	r3, [sp, #32]
    6c7e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    6c80:	4413      	add	r3, r2
                ascii_to_u32s(ptr, values, 1);
                bw = values[0];
            }

            //(*pCmdIO->pCmdApi->print)(cmdIoParam, "\nGiven BW:%d",bw);            
            pIState->mTxRate = bw;
    6c82:	61ab      	str	r3, [r5, #24]
    6c84:	e775      	b.n	6b72 <CommandIperfStart+0xae>
    uint32_t bw1=0, bw2=0,  mpf1=0, mpf2 = 1000000;
    6c86:	2200      	movs	r2, #0
        bw2 = bw2 * mpf2;
    6c88:	4613      	mov	r3, r2
    6c8a:	e7e9      	b.n	6c60 <CommandIperfStart+0x19c>
                ascii_to_u32s(ptr, values, 1);
    6c8c:	2201      	movs	r2, #1
    6c8e:	a908      	add	r1, sp, #32
    6c90:	4640      	mov	r0, r8
    6c92:	f011 fab1 	bl	181f8 <ascii_to_u32s>
                bw = values[0];
    6c96:	9b08      	ldr	r3, [sp, #32]
    6c98:	e7f3      	b.n	6c82 <CommandIperfStart+0x1be>
        }
#endif  // defined(TCPIP_STACK_USE_UDP)
#if defined(TCPIP_STACK_USE_TCP)
        else if ((memcmp(argv[i], "-x", 2) == 0) || (memcmp(argv[i], "--xmitrate", 5) == 0) )
    6c9a:	2202      	movs	r2, #2
    6c9c:	f506 712a 	add.w	r1, r6, #680	; 0x2a8
    6ca0:	4638      	mov	r0, r7
    6ca2:	f01a f9cf 	bl	21044 <memcmp>
    6ca6:	b130      	cbz	r0, 6cb6 <CommandIperfStart+0x1f2>
    6ca8:	2205      	movs	r2, #5
    6caa:	f506 712b 	add.w	r1, r6, #684	; 0x2ac
    6cae:	4638      	mov	r0, r7
    6cb0:	f01a f9c8 	bl	21044 <memcmp>
    6cb4:	b950      	cbnz	r0, 6ccc <CommandIperfStart+0x208>
        {
            // NON-STANDARD IPERF OPTION. Set the max TCP tx rate.
            // Next argument should be the target rate, in bps.
            i++;
    6cb6:	3401      	adds	r4, #1
    6cb8:	b2e4      	uxtb	r4, r4
            ptr = argv[i];

            ascii_to_u32s(ptr, values, 1);
    6cba:	2201      	movs	r2, #1
    6cbc:	a908      	add	r1, sp, #32
    6cbe:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    6cc2:	f011 fa99 	bl	181f8 <ascii_to_u32s>

            pIState->mTxRate = values[0];
    6cc6:	9b08      	ldr	r3, [sp, #32]
    6cc8:	61ab      	str	r3, [r5, #24]
    6cca:	e752      	b.n	6b72 <CommandIperfStart+0xae>
        }
#endif  // defined(TCPIP_STACK_USE_TCP)
        else if ((memcmp(argv[i], "-c", 2) == 0) || (memcmp(argv[i], "--client", 5) == 0) )
    6ccc:	2202      	movs	r2, #2
    6cce:	f506 712e 	add.w	r1, r6, #696	; 0x2b8
    6cd2:	4638      	mov	r0, r7
    6cd4:	f01a f9b6 	bl	21044 <memcmp>
    6cd8:	b130      	cbz	r0, 6ce8 <CommandIperfStart+0x224>
    6cda:	2205      	movs	r2, #5
    6cdc:	f506 712f 	add.w	r1, r6, #700	; 0x2bc
    6ce0:	4638      	mov	r0, r7
    6ce2:	f01a f9af 	bl	21044 <memcmp>
    6ce6:	b9b8      	cbnz	r0, 6d18 <CommandIperfStart+0x254>
        {
            // Function as an iperf client.
            pIState->mServerMode = false;
    6ce8:	2300      	movs	r3, #0
    6cea:	f885 30d1 	strb.w	r3, [r5, #209]	; 0xd1

            // Next argument should be the server IP, such as "192.168.1.100".
            i++;
    6cee:	3401      	adds	r4, #1
    6cf0:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
            ascii_to_u32s(ptr, values, 4);
    6cf2:	2204      	movs	r2, #4
    6cf4:	a908      	add	r1, sp, #32
    6cf6:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    6cfa:	f011 fa7d 	bl	181f8 <ascii_to_u32s>

            pIState->remoteSide.remoteIPaddress.v4Add.v[0] = values[0];
    6cfe:	9b08      	ldr	r3, [sp, #32]
    6d00:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
            pIState->remoteSide.remoteIPaddress.v4Add.v[1] = values[1];
    6d04:	9b09      	ldr	r3, [sp, #36]	; 0x24
    6d06:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
            pIState->remoteSide.remoteIPaddress.v4Add.v[2] = values[2];
    6d0a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    6d0c:	f885 3046 	strb.w	r3, [r5, #70]	; 0x46
            pIState->remoteSide.remoteIPaddress.v4Add.v[3] = values[3]; 
    6d10:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    6d12:	f885 3047 	strb.w	r3, [r5, #71]	; 0x47
    6d16:	e72c      	b.n	6b72 <CommandIperfStart+0xae>
        }
        else if ((memcmp(argv[i], "-t", 2) == 0) || (memcmp(argv[i], "--time", 5) == 0) )
    6d18:	2202      	movs	r2, #2
    6d1a:	f506 7132 	add.w	r1, r6, #712	; 0x2c8
    6d1e:	4638      	mov	r0, r7
    6d20:	f01a f990 	bl	21044 <memcmp>
    6d24:	b130      	cbz	r0, 6d34 <CommandIperfStart+0x270>
    6d26:	2205      	movs	r2, #5
    6d28:	f506 7133 	add.w	r1, r6, #716	; 0x2cc
    6d2c:	4638      	mov	r0, r7
    6d2e:	f01a f989 	bl	21044 <memcmp>
    6d32:	b978      	cbnz	r0, 6d54 <CommandIperfStart+0x290>
        {
            // Next argument should be the (client tx) duration, in seconds.
            i++;
    6d34:	3401      	adds	r4, #1
    6d36:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
            ascii_to_u32s(ptr, values, 1);
    6d38:	2201      	movs	r2, #1
    6d3a:	a908      	add	r1, sp, #32
    6d3c:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    6d40:	f011 fa5a 	bl	181f8 <ascii_to_u32s>

            pIState->mDuration = values[0] * tickFreq;
    6d44:	9b08      	ldr	r3, [sp, #32]
    6d46:	9a04      	ldr	r2, [sp, #16]
    6d48:	fb02 f303 	mul.w	r3, r2, r3
    6d4c:	60ab      	str	r3, [r5, #8]
            pIState->mAmount = 0;
    6d4e:	2300      	movs	r3, #0
    6d50:	606b      	str	r3, [r5, #4]
    6d52:	e70e      	b.n	6b72 <CommandIperfStart+0xae>
        }
        else if ((memcmp(argv[i], "-n", 2) == 0) || (memcmp(argv[i], "--num", 5) == 0) )
    6d54:	2202      	movs	r2, #2
    6d56:	f506 7135 	add.w	r1, r6, #724	; 0x2d4
    6d5a:	4638      	mov	r0, r7
    6d5c:	f01a f972 	bl	21044 <memcmp>
    6d60:	b130      	cbz	r0, 6d70 <CommandIperfStart+0x2ac>
    6d62:	2205      	movs	r2, #5
    6d64:	f506 7136 	add.w	r1, r6, #728	; 0x2d8
    6d68:	4638      	mov	r0, r7
    6d6a:	f01a f96b 	bl	21044 <memcmp>
    6d6e:	b9d8      	cbnz	r0, 6da8 <CommandIperfStart+0x2e4>
        {
            // Next argument should be the (client tx) size, in bytes.
            i++;
    6d70:	3401      	adds	r4, #1
    6d72:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
            ascii_to_u32s(ptr, values, 1);
    6d74:	2201      	movs	r2, #1
    6d76:	a908      	add	r1, sp, #32
    6d78:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    6d7c:	f011 fa3c 	bl	181f8 <ascii_to_u32s>

            pIState->mAmount = values[0];
    6d80:	9b08      	ldr	r3, [sp, #32]
    6d82:	606b      	str	r3, [r5, #4]
            pIState->mDuration = 0;
    6d84:	2300      	movs	r3, #0
    6d86:	60ab      	str	r3, [r5, #8]
    6d88:	e6f3      	b.n	6b72 <CommandIperfStart+0xae>
    6d8a:	bf00      	nop
    6d8c:	2000e5f8 	.word	0x2000e5f8
    6d90:	2000dbb0 	.word	0x2000dbb0
    6d94:	00005078 	.word	0x00005078
    6d98:	00989680 	.word	0x00989680
    6d9c:	00004c44 	.word	0x00004c44
    6da0:	00004e9c 	.word	0x00004e9c
    6da4:	000f4240 	.word	0x000f4240
        }
        else if ((memcmp(argv[i], "-S", 2) == 0) || (memcmp(argv[i], "--tos", 5) == 0) )
    6da8:	2202      	movs	r2, #2
    6daa:	f506 7138 	add.w	r1, r6, #736	; 0x2e0
    6dae:	4638      	mov	r0, r7
    6db0:	f01a f948 	bl	21044 <memcmp>
    6db4:	b138      	cbz	r0, 6dc6 <CommandIperfStart+0x302>
    6db6:	2205      	movs	r2, #5
    6db8:	f506 7139 	add.w	r1, r6, #740	; 0x2e4
    6dbc:	4638      	mov	r0, r7
    6dbe:	f01a f941 	bl	21044 <memcmp>
    6dc2:	2800      	cmp	r0, #0
    6dc4:	d137      	bne.n	6e36 <CommandIperfStart+0x372>
        {
            // Next argument should be the (client tx) TOS
            i++;
    6dc6:	3401      	adds	r4, #1
    6dc8:	b2e4      	uxtb	r4, r4
            if(argv[i][1] == 'x')
    6dca:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    6dce:	7843      	ldrb	r3, [r0, #1]
    6dd0:	2b78      	cmp	r3, #120	; 0x78
    6dd2:	d018      	beq.n	6e06 <CommandIperfStart+0x342>
                tos = hexatob(asciTos);
            }
            else
            {
                ptr = argv[i];
                ascii_to_u32s(ptr, values, 1);
    6dd4:	2201      	movs	r2, #1
    6dd6:	a908      	add	r1, sp, #32
    6dd8:	f011 fa0e 	bl	181f8 <ascii_to_u32s>
                tos = values[0];                
    6ddc:	f89d 0020 	ldrb.w	r0, [sp, #32]
            }

            switch(tos)
    6de0:	4602      	mov	r2, r0
    6de2:	2820      	cmp	r0, #32
    6de4:	d021      	beq.n	6e2a <CommandIperfStart+0x366>
    6de6:	d919      	bls.n	6e1c <CommandIperfStart+0x358>
    6de8:	28a0      	cmp	r0, #160	; 0xa0
    6dea:	d01b      	beq.n	6e24 <CommandIperfStart+0x360>
    6dec:	28c0      	cmp	r0, #192	; 0xc0
    6dee:	d11f      	bne.n	6e30 <CommandIperfStart+0x36c>
            {
                case IPERF_TOS_VO:
                    pIState->mTypeOfService = TCPIP_IPV4_THROUGHPUT_HIGH;                  
    6df0:	2310      	movs	r3, #16
    6df2:	752b      	strb	r3, [r5, #20]
                    break;
                 default:   
                    pIState->mTypeOfService = TCPIP_IPV4_TOS_DEFAULT;                                                          
            }

            (*pCmdIO->pCmdApi->print)(cmdIoParam, "\nGiven TOS value is %d, mTypeOfService:%d",tos,pIState->mTypeOfService);
    6df4:	9b03      	ldr	r3, [sp, #12]
    6df6:	681b      	ldr	r3, [r3, #0]
    6df8:	685f      	ldr	r7, [r3, #4]
    6dfa:	7d2b      	ldrb	r3, [r5, #20]
    6dfc:	f506 713b 	add.w	r1, r6, #748	; 0x2ec
    6e00:	9802      	ldr	r0, [sp, #8]
    6e02:	47b8      	blx	r7
    6e04:	e6b5      	b.n	6b72 <CommandIperfStart+0xae>
                ((uint8_t*)&asciTos)[1] = argv[i][2];
    6e06:	7883      	ldrb	r3, [r0, #2]
    6e08:	f88d 301f 	strb.w	r3, [sp, #31]
                ((uint8_t*)&asciTos)[0] = argv[i][3];                    
    6e0c:	78c3      	ldrb	r3, [r0, #3]
    6e0e:	f88d 301e 	strb.w	r3, [sp, #30]
                tos = hexatob(asciTos);
    6e12:	f8bd 001e 	ldrh.w	r0, [sp, #30]
    6e16:	f017 f812 	bl	1de3e <hexatob>
    6e1a:	e7e1      	b.n	6de0 <CommandIperfStart+0x31c>
            switch(tos)
    6e1c:	b940      	cbnz	r0, 6e30 <CommandIperfStart+0x36c>
                    pIState->mTypeOfService = TCPIP_IPV4_TOS_DEFAULT;                                      
    6e1e:	2300      	movs	r3, #0
    6e20:	752b      	strb	r3, [r5, #20]
                    break;
    6e22:	e7e7      	b.n	6df4 <CommandIperfStart+0x330>
                    pIState->mTypeOfService = TCPIP_IPV4_RELIABILITY_HIGH;                                      
    6e24:	2320      	movs	r3, #32
    6e26:	752b      	strb	r3, [r5, #20]
                    break;
    6e28:	e7e4      	b.n	6df4 <CommandIperfStart+0x330>
                    pIState->mTypeOfService = TCPIP_IPV4_DELAY_LOW;                                      
    6e2a:	2308      	movs	r3, #8
    6e2c:	752b      	strb	r3, [r5, #20]
                    break;
    6e2e:	e7e1      	b.n	6df4 <CommandIperfStart+0x330>
                    pIState->mTypeOfService = TCPIP_IPV4_TOS_DEFAULT;                                                          
    6e30:	2300      	movs	r3, #0
    6e32:	752b      	strb	r3, [r5, #20]
    6e34:	e7de      	b.n	6df4 <CommandIperfStart+0x330>
            
        }
        
#if defined(TCPIP_STACK_USE_TCP)
        else if ((memcmp(argv[i], "-M", 2) == 0) ||
    6e36:	2202      	movs	r2, #2
    6e38:	f506 7146 	add.w	r1, r6, #792	; 0x318
    6e3c:	4638      	mov	r0, r7
    6e3e:	f01a f901 	bl	21044 <memcmp>
    6e42:	b130      	cbz	r0, 6e52 <CommandIperfStart+0x38e>
                (memcmp(argv[i], "--mss", 5) == 0) )
    6e44:	2205      	movs	r2, #5
    6e46:	f506 7147 	add.w	r1, r6, #796	; 0x31c
    6e4a:	4638      	mov	r0, r7
    6e4c:	f01a f8fa 	bl	21044 <memcmp>
        else if ((memcmp(argv[i], "-M", 2) == 0) ||
    6e50:	b958      	cbnz	r0, 6e6a <CommandIperfStart+0x3a6>
        {
            // Next argument should be the (client tcp tx) MSS size, in bytes.

            i++;
    6e52:	3401      	adds	r4, #1
    6e54:	b2e4      	uxtb	r4, r4
            ptr = argv[i];

            ascii_to_u32s(ptr, values, 1);
    6e56:	2201      	movs	r2, #1
    6e58:	a908      	add	r1, sp, #32
    6e5a:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    6e5e:	f011 f9cb 	bl	181f8 <ascii_to_u32s>

            pIState->mMSS = values[0];
    6e62:	9b08      	ldr	r3, [sp, #32]
    6e64:	f8a5 30d2 	strh.w	r3, [r5, #210]	; 0xd2
    6e68:	e683      	b.n	6b72 <CommandIperfStart+0xae>
        }
#endif  // defined(TCPIP_STACK_USE_TCP)

        else if ((memcmp(argv[i], "-i", 2) == 0) || (memcmp(argv[i], "--interval", 5) == 0) )
    6e6a:	2202      	movs	r2, #2
    6e6c:	f106 013c 	add.w	r1, r6, #60	; 0x3c
    6e70:	4638      	mov	r0, r7
    6e72:	f01a f8e7 	bl	21044 <memcmp>
    6e76:	b130      	cbz	r0, 6e86 <CommandIperfStart+0x3c2>
    6e78:	2205      	movs	r2, #5
    6e7a:	f506 7149 	add.w	r1, r6, #804	; 0x324
    6e7e:	4638      	mov	r0, r7
    6e80:	f01a f8e0 	bl	21044 <memcmp>
    6e84:	b968      	cbnz	r0, 6ea2 <CommandIperfStart+0x3de>
        {
            // Next argument should be the report interval, in seconds.
            i++;
    6e86:	3401      	adds	r4, #1
    6e88:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
            ascii_to_u32s(ptr, values, 1);
    6e8a:	2201      	movs	r2, #1
    6e8c:	a908      	add	r1, sp, #32
    6e8e:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    6e92:	f011 f9b1 	bl	181f8 <ascii_to_u32s>

            pIState->mInterval = values[0] * tickFreq; // Convert to msec
    6e96:	9b08      	ldr	r3, [sp, #32]
    6e98:	9a04      	ldr	r2, [sp, #16]
    6e9a:	fb02 f303 	mul.w	r3, r2, r3
    6e9e:	602b      	str	r3, [r5, #0]
    6ea0:	e667      	b.n	6b72 <CommandIperfStart+0xae>
        }
        else if ((memcmp(argv[i], "-p", 2) == 0) || (memcmp(argv[i], "--port", 6) == 0) )
    6ea2:	2202      	movs	r2, #2
    6ea4:	f506 714c 	add.w	r1, r6, #816	; 0x330
    6ea8:	4638      	mov	r0, r7
    6eaa:	f01a f8cb 	bl	21044 <memcmp>
    6eae:	b130      	cbz	r0, 6ebe <CommandIperfStart+0x3fa>
    6eb0:	2206      	movs	r2, #6
    6eb2:	f506 714d 	add.w	r1, r6, #820	; 0x334
    6eb6:	4638      	mov	r0, r7
    6eb8:	f01a f8c4 	bl	21044 <memcmp>
    6ebc:	b950      	cbnz	r0, 6ed4 <CommandIperfStart+0x410>
        {
            // Next argument should be the port number.
            i++;
    6ebe:	3401      	adds	r4, #1
    6ec0:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
            ascii_to_u32s(ptr, values, 1);
    6ec2:	2201      	movs	r2, #1
    6ec4:	a908      	add	r1, sp, #32
    6ec6:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    6eca:	f011 f995 	bl	181f8 <ascii_to_u32s>

		    pIState->mServerPort = values[0];		// -p. default: server port 5001
    6ece:	9b08      	ldr	r3, [sp, #32]
    6ed0:	826b      	strh	r3, [r5, #18]
    6ed2:	e64e      	b.n	6b72 <CommandIperfStart+0xae>
        }
#if defined(TCPIP_STACK_USE_UDP)
        else if ((memcmp(argv[i], "-l", 2) == 0) || (memcmp(argv[i], "--len", 5) == 0) )
    6ed4:	2202      	movs	r2, #2
    6ed6:	f506 714f 	add.w	r1, r6, #828	; 0x33c
    6eda:	4638      	mov	r0, r7
    6edc:	f01a f8b2 	bl	21044 <memcmp>
    6ee0:	b140      	cbz	r0, 6ef4 <CommandIperfStart+0x430>
    6ee2:	2205      	movs	r2, #5
    6ee4:	f506 7150 	add.w	r1, r6, #832	; 0x340
    6ee8:	4638      	mov	r0, r7
    6eea:	f01a f8ab 	bl	21044 <memcmp>
    6eee:	2800      	cmp	r0, #0
    6ef0:	f47f ae3f 	bne.w	6b72 <CommandIperfStart+0xae>
        {
            // Next argument should be the buffer length, in bytes.
            // This is used as the UDP datagram size.
            i++;
    6ef4:	3401      	adds	r4, #1
    6ef6:	b2e4      	uxtb	r4, r4
            ptr = argv[i];
            ascii_to_u32s(ptr, values, 1);
    6ef8:	2201      	movs	r2, #1
    6efa:	a908      	add	r1, sp, #32
    6efc:	f859 0024 	ldr.w	r0, [r9, r4, lsl #2]
    6f00:	f011 f97a 	bl	181f8 <ascii_to_u32s>

            if ( values[0] <  MAX_BUFFER  )
    6f04:	9b08      	ldr	r3, [sp, #32]
    6f06:	2b33      	cmp	r3, #51	; 0x33
    6f08:	d901      	bls.n	6f0e <CommandIperfStart+0x44a>
            {
               (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf: The minimum datagram size is %d\r\n", (int)MAX_BUFFER);
               return;
            }

            pIState->mDatagramSize = values[0];
    6f0a:	60eb      	str	r3, [r5, #12]
    6f0c:	e631      	b.n	6b72 <CommandIperfStart+0xae>
               (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf: The minimum datagram size is %d\r\n", (int)MAX_BUFFER);
    6f0e:	f8d5 30c4 	ldr.w	r3, [r5, #196]	; 0xc4
    6f12:	681b      	ldr	r3, [r3, #0]
    6f14:	685b      	ldr	r3, [r3, #4]
    6f16:	2234      	movs	r2, #52	; 0x34
    6f18:	4952      	ldr	r1, [pc, #328]	; (7064 <CommandIperfStart+0x5a0>)
    6f1a:	9802      	ldr	r0, [sp, #8]
    6f1c:	4798      	blx	r3
               return;
    6f1e:	e006      	b.n	6f2e <CommandIperfStart+0x46a>
    6f20:	f8dd a00c 	ldr.w	sl, [sp, #12]
        }
#endif  // defined(TCPIP_STACK_USE_UDP)
    }

    switch (pIState->mServerMode)
    6f24:	f895 30d1 	ldrb.w	r3, [r5, #209]	; 0xd1
    6f28:	b123      	cbz	r3, 6f34 <CommandIperfStart+0x470>
    6f2a:	2b01      	cmp	r3, #1
    6f2c:	d03d      	beq.n	6faa <CommandIperfStart+0x4e6>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, " port %d\r\n", pIState->mServerPort);
            IperfSetState(pIState, IPERF_RX_START_STATE);
            break;
    }
    
}
    6f2e:	b00d      	add	sp, #52	; 0x34
    6f30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if((pIState->pNetIf = TCPIP_STACK_IPAddToNet(&pIState->localAddr, false)) == 0)
    6f34:	2100      	movs	r1, #0
    6f36:	f105 0080 	add.w	r0, r5, #128	; 0x80
    6f3a:	f019 fa4b 	bl	203d4 <TCPIP_STACK_IPAddToNet>
    6f3e:	f8c5 00c8 	str.w	r0, [r5, #200]	; 0xc8
    6f42:	b310      	cbz	r0, 6f8a <CommandIperfStart+0x4c6>
            if(pIState->mProtocol == TCP_PROTOCOL)
    6f44:	7c2b      	ldrb	r3, [r5, #16]
    6f46:	2b02      	cmp	r3, #2
    6f48:	d02a      	beq.n	6fa0 <CommandIperfStart+0x4dc>
            if(pIState->mProtocol == UDP_PROTOCOL)
    6f4a:	2b01      	cmp	r3, #1
                payloadSize = 	pIState->mDatagramSize;
    6f4c:	bf06      	itte	eq
    6f4e:	89ab      	ldrheq	r3, [r5, #12]
    6f50:	ee07 3a10 	vmoveq	s14, r3
    uint16_t payloadSize = 0, asciTos;
    6f54:	ed9f 7a44 	vldrne	s14, [pc, #272]	; 7068 <CommandIperfStart+0x5a4>
            pIState->mPktPeriod =  (uint32_t) ( (float) tickFreq / pktRate );
    6f58:	eddd 7a04 	vldr	s15, [sp, #16]
    6f5c:	eeb8 6a67 	vcvt.f32.u32	s12, s15
            pktRate =  (float) (pIState->mTxRate / 8) / (float) payloadSize;
    6f60:	69ab      	ldr	r3, [r5, #24]
    6f62:	08db      	lsrs	r3, r3, #3
    6f64:	ee07 3a90 	vmov	s15, r3
    6f68:	eef8 7a67 	vcvt.f32.u32	s15, s15
    6f6c:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    6f70:	eec7 6a87 	vdiv.f32	s13, s15, s14
            pIState->mPktPeriod =  (uint32_t) ( (float) tickFreq / pktRate );
    6f74:	eec6 7a26 	vdiv.f32	s15, s12, s13
    6f78:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    6f7c:	edc5 7a21 	vstr	s15, [r5, #132]	; 0x84
            IperfSetState(pIState, IPERF_TX_START_STATE);
    6f80:	210a      	movs	r1, #10
    6f82:	4628      	mov	r0, r5
    6f84:	f014 fee0 	bl	1bd48 <IperfSetState>
            break;
    6f88:	e7d1      	b.n	6f2e <CommandIperfStart+0x46a>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Using the default interface!\r\n");
    6f8a:	f8da 3000 	ldr.w	r3, [sl]
    6f8e:	681b      	ldr	r3, [r3, #0]
    6f90:	4936      	ldr	r1, [pc, #216]	; (706c <CommandIperfStart+0x5a8>)
    6f92:	9802      	ldr	r0, [sp, #8]
    6f94:	4798      	blx	r3
                pIState->pNetIf = TCPIP_STACK_NetDefaultGet();
    6f96:	f01a ffaf 	bl	21ef8 <TCPIP_STACK_NetDefaultGet>
    6f9a:	f8c5 00c8 	str.w	r0, [r5, #200]	; 0xc8
    6f9e:	e7d1      	b.n	6f44 <CommandIperfStart+0x480>
                payloadSize = 	pIState->mMSS;
    6fa0:	f8b5 30d2 	ldrh.w	r3, [r5, #210]	; 0xd2
    6fa4:	ee07 3a10 	vmov	s14, r3
            if(pIState->mProtocol == UDP_PROTOCOL)
    6fa8:	e7d6      	b.n	6f58 <CommandIperfStart+0x494>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "---------------------------------------------------------\r\n");
    6faa:	4c31      	ldr	r4, [pc, #196]	; (7070 <CommandIperfStart+0x5ac>)
    6fac:	f8da 3000 	ldr.w	r3, [sl]
    6fb0:	681b      	ldr	r3, [r3, #0]
    6fb2:	f504 7167 	add.w	r1, r4, #924	; 0x39c
    6fb6:	9e02      	ldr	r6, [sp, #8]
    6fb8:	4630      	mov	r0, r6
    6fba:	4798      	blx	r3
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Server listening on ");
    6fbc:	f8da 3000 	ldr.w	r3, [sl]
    6fc0:	681b      	ldr	r3, [r3, #0]
    6fc2:	f504 7176 	add.w	r1, r4, #984	; 0x3d8
    6fc6:	4630      	mov	r0, r6
    6fc8:	4798      	blx	r3
            if (pIState->mProtocol == UDP_PROTOCOL)
    6fca:	7c2b      	ldrb	r3, [r5, #16]
    6fcc:	2b01      	cmp	r3, #1
    6fce:	d00f      	beq.n	6ff0 <CommandIperfStart+0x52c>
            if (pIState->mProtocol == TCP_PROTOCOL)
    6fd0:	7c2b      	ldrb	r3, [r5, #16]
    6fd2:	2b02      	cmp	r3, #2
    6fd4:	d014      	beq.n	7000 <CommandIperfStart+0x53c>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, " port %d\r\n", pIState->mServerPort);
    6fd6:	f8d5 30c4 	ldr.w	r3, [r5, #196]	; 0xc4
    6fda:	681b      	ldr	r3, [r3, #0]
    6fdc:	685b      	ldr	r3, [r3, #4]
    6fde:	8a6a      	ldrh	r2, [r5, #18]
    6fe0:	4924      	ldr	r1, [pc, #144]	; (7074 <CommandIperfStart+0x5b0>)
    6fe2:	9802      	ldr	r0, [sp, #8]
    6fe4:	4798      	blx	r3
            IperfSetState(pIState, IPERF_RX_START_STATE);
    6fe6:	2102      	movs	r1, #2
    6fe8:	4628      	mov	r0, r5
    6fea:	f014 fead 	bl	1bd48 <IperfSetState>
            break;
    6fee:	e79e      	b.n	6f2e <CommandIperfStart+0x46a>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, (const char *)"UDP");
    6ff0:	f8da 3000 	ldr.w	r3, [sl]
    6ff4:	681b      	ldr	r3, [r3, #0]
    6ff6:	f504 717d 	add.w	r1, r4, #1012	; 0x3f4
    6ffa:	9802      	ldr	r0, [sp, #8]
    6ffc:	4798      	blx	r3
    6ffe:	e7e7      	b.n	6fd0 <CommandIperfStart+0x50c>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, (const char *)"TCP");
    7000:	f8da 3000 	ldr.w	r3, [sl]
    7004:	681b      	ldr	r3, [r3, #0]
    7006:	491c      	ldr	r1, [pc, #112]	; (7078 <CommandIperfStart+0x5b4>)
    7008:	9802      	ldr	r0, [sp, #8]
    700a:	4798      	blx	r3
    700c:	e7e3      	b.n	6fd6 <CommandIperfStart+0x512>
            if(*(ptr+j) == (int8_t)'.')
    700e:	282e      	cmp	r0, #46	; 0x2e
    7010:	d102      	bne.n	7018 <CommandIperfStart+0x554>
                bw1 = bw1 * mpf1;
    7012:	fb0a f202 	mul.w	r2, sl, r2
                decimal = 0;
    7016:	2700      	movs	r7, #0
        for(j=0;j<len-1;j++)
    7018:	3301      	adds	r3, #1
    701a:	b2db      	uxtb	r3, r3
    701c:	4573      	cmp	r3, lr
    701e:	f6bf ae19 	bge.w	6c54 <CommandIperfStart+0x190>
            if ( (*(ptr+j) <= (int8_t)'9') && (*(ptr+j) >= (int8_t)'0') && (decimal == 1) )
    7022:	f818 0003 	ldrb.w	r0, [r8, r3]
    7026:	f1a0 0130 	sub.w	r1, r0, #48	; 0x30
    702a:	b2c9      	uxtb	r1, r1
    702c:	2909      	cmp	r1, #9
    702e:	d8ee      	bhi.n	700e <CommandIperfStart+0x54a>
    7030:	2f00      	cmp	r7, #0
    7032:	f47f ae09 	bne.w	6c48 <CommandIperfStart+0x184>
            if ( (*(ptr+j) <= (int8_t)'9') && (*(ptr+j) >= (int8_t)'0') && (decimal == 0) )
    7036:	2f00      	cmp	r7, #0
    7038:	d1ee      	bne.n	7018 <CommandIperfStart+0x554>
                 bw2 = bw2*10 + *(ptr+j) - '0';
    703a:	eb0c 0c8c 	add.w	ip, ip, ip, lsl #2
    703e:	eb00 004c 	add.w	r0, r0, ip, lsl #1
    7042:	f1a0 0c30 	sub.w	ip, r0, #48	; 0x30
                 mpf2 = mpf2/10;
    7046:	490d      	ldr	r1, [pc, #52]	; (707c <CommandIperfStart+0x5b8>)
    7048:	fba1 0104 	umull	r0, r1, r1, r4
    704c:	08cc      	lsrs	r4, r1, #3
    704e:	e7e3      	b.n	7018 <CommandIperfStart+0x554>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "\r\niperf: All instances busy. Retry later!\r\n");
    7050:	f8da 3000 	ldr.w	r3, [sl]
    7054:	681b      	ldr	r3, [r3, #0]
    7056:	490a      	ldr	r1, [pc, #40]	; (7080 <CommandIperfStart+0x5bc>)
    7058:	9802      	ldr	r0, [sp, #8]
    705a:	4798      	blx	r3
        return;
    705c:	e767      	b.n	6f2e <CommandIperfStart+0x46a>
    for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
    705e:	4d09      	ldr	r5, [pc, #36]	; (7084 <CommandIperfStart+0x5c0>)
    7060:	e54e      	b.n	6b00 <CommandIperfStart+0x3c>
    7062:	bf00      	nop
    7064:	00004f8c 	.word	0x00004f8c
    7068:	00000000 	.word	0x00000000
    706c:	00004fb8 	.word	0x00004fb8
    7070:	00004c44 	.word	0x00004c44
    7074:	00005040 	.word	0x00005040
    7078:	0000503c 	.word	0x0000503c
    707c:	cccccccd 	.word	0xcccccccd
    7080:	0000504c 	.word	0x0000504c
    7084:	2000dbb0 	.word	0x2000dbb0

Disassembly of section .text._TcpSend%197:

00007088 <_TcpSend>:
    switch(pSkt->addType)
    7088:	f890 306f 	ldrb.w	r3, [r0, #111]	; 0x6f
    708c:	2b01      	cmp	r3, #1
    708e:	f040 828d 	bne.w	75ac <_TcpSend+0x524>
{
    7092:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7096:	b087      	sub	sp, #28
    7098:	4604      	mov	r4, r0
    709a:	460f      	mov	r7, r1
    709c:	4692      	mov	sl, r2
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    709e:	2000      	movs	r0, #0
    70a0:	f01a f9fc 	bl	2149c <OSAL_CRIT_Enter>
    if(pSkt->pV4Pkt != 0)
    70a4:	6c62      	ldr	r2, [r4, #68]	; 0x44
    70a6:	2a00      	cmp	r2, #0
    70a8:	f000 8292 	beq.w	75d0 <_TcpSend+0x548>
        if((pSkt->pV4Pkt->macPkt.pktFlags & TCPIP_MAC_PKT_FLAG_QUEUED) == 0)
    70ac:	8c53      	ldrh	r3, [r2, #34]	; 0x22
    70ae:	f013 0f08 	tst.w	r3, #8
    70b2:	f040 828d 	bne.w	75d0 <_TcpSend+0x548>
            pSkt->pV4Pkt->macPkt.pktFlags |= TCPIP_MAC_PKT_FLAG_QUEUED;
    70b6:	f043 0308 	orr.w	r3, r3, #8
    70ba:	8453      	strh	r3, [r2, #34]	; 0x22
            pktValid = (TCP_V4_PACKET*)pSkt->pV4Pkt;
    70bc:	6c66      	ldr	r6, [r4, #68]	; 0x44
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
    70be:	4601      	mov	r1, r0
    70c0:	2000      	movs	r0, #0
    70c2:	f01a fb1a 	bl	216fa <OSAL_CRIT_Leave>
    if(!oldPkt)
    70c6:	2e00      	cmp	r6, #0
    70c8:	f000 8286 	beq.w	75d8 <_TcpSend+0x550>
    pSeg->segLen = pSeg->segSize = 0;
    70cc:	2300      	movs	r3, #0
    70ce:	f8a6 3052 	strh.w	r3, [r6, #82]	; 0x52
    70d2:	f8a6 3050 	strh.w	r3, [r6, #80]	; 0x50
    pSeg->next = 0;
    70d6:	6473      	str	r3, [r6, #68]	; 0x44
    pSeg->segLen = pSeg->segSize = 0;
    70d8:	f8a6 306a 	strh.w	r3, [r6, #106]	; 0x6a
    70dc:	f8a6 3068 	strh.w	r3, [r6, #104]	; 0x68
    pSeg->next = 0;
    70e0:	65f3      	str	r3, [r6, #92]	; 0x5c
    pTcpPkt->v4Pkt.macPkt.pDSeg->next = 0;    // unlink to the 1st data seg; leave header only
    70e2:	6932      	ldr	r2, [r6, #16]
    70e4:	6013      	str	r3, [r2, #0]
    pTcpPkt->v4Pkt.macPkt.pDSeg->segLen = 0;  // clear the payload
    70e6:	6932      	ldr	r2, [r6, #16]
    70e8:	8193      	strh	r3, [r2, #12]
        if(vTCPFlags & FIN)
    70ea:	f017 0f01 	tst.w	r7, #1
    70ee:	d007      	beq.n	7100 <_TcpSend+0x78>
            pSkt->Flags.bTXFIN = 1;
    70f0:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
    70f4:	f043 0301 	orr.w	r3, r3, #1
    70f8:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37
            vTCPFlags &= ~FIN;
    70fc:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
        pSkt->Flags.bTimer2Enabled = 0;
    7100:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
        pSkt->Flags.bHalfFullFlush = 0;
    7104:	f003 0323 	and.w	r3, r3, #35	; 0x23
    7108:	f36f 1345 	bfc	r3, #5, #1
    710c:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
        if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
    7110:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    7114:	2b01      	cmp	r3, #1
            header = (TCP_HEADER*)((TCP_V4_PACKET*)pSendPkt)->v4Pkt.macPkt.pTransportLayer;
    7116:	bf0c      	ite	eq
    7118:	69f5      	ldreq	r5, [r6, #28]
    TCP_HEADER *    header = 0;
    711a:	2500      	movne	r5, #0
        header->DataOffset.Val = 0;
    711c:	7b2b      	ldrb	r3, [r5, #12]
    711e:	f36f 1307 	bfc	r3, #4, #4
    7122:	732b      	strb	r3, [r5, #12]
        if(vTCPFlags & (SYN | RST))
    7124:	f017 0f06 	tst.w	r7, #6
    7128:	d049      	beq.n	71be <_TcpSend+0x136>
            if(vTCPFlags & SYN)
    712a:	f017 0f02 	tst.w	r7, #2
    712e:	f000 8100 	beq.w	7332 <_TcpSend+0x2aa>
                options.Kind = TCP_OPTIONS_MAX_SEG_SIZE;
    7132:	2302      	movs	r3, #2
    7134:	f88d 3014 	strb.w	r3, [sp, #20]
                options.Length = 0x04;
    7138:	2304      	movs	r3, #4
    713a:	f88d 3015 	strb.w	r3, [sp, #21]
                if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
    713e:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    7142:	2b01      	cmp	r3, #1
    7144:	d01b      	beq.n	717e <_TcpSend+0xf6>
    uint16_t 		mss = 0;
    7146:	2000      	movs	r0, #0
                options.MaxSegSize.Val = (((mss)&0x00FF)<<8) | (((mss)&0xFF00)>>8);
    7148:	0a03      	lsrs	r3, r0, #8
    714a:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
    714e:	f8ad 3016 	strh.w	r3, [sp, #22]
                pSkt->localMSS = mss;
    7152:	f8a4 0064 	strh.w	r0, [r4, #100]	; 0x64
                header->DataOffset.Val   += sizeof(options) >> 2;
    7156:	7b2b      	ldrb	r3, [r5, #12]
    7158:	f3c3 1203 	ubfx	r2, r3, #4, #4
    715c:	3201      	adds	r2, #1
    715e:	f362 1307 	bfi	r3, r2, #4, #4
    7162:	732b      	strb	r3, [r5, #12]
                if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
    7164:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    7168:	2b01      	cmp	r3, #1
                    memcpy(header + 1, &options, sizeof(options));
    716a:	bf04      	itt	eq
    716c:	9b05      	ldreq	r3, [sp, #20]
    716e:	616b      	streq	r3, [r5, #20]
                if(pSkt->MySEQ == 0)
    7170:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    7172:	b1eb      	cbz	r3, 71b0 <_TcpSend+0x128>
    loadLen = (uint16_t)len;  // save the TCP payload size
    7174:	f04f 0800 	mov.w	r8, #0
    7178:	e0dd      	b.n	7336 <_TcpSend+0x2ae>
                pSkt->pTxPkt = pPkt;
    717a:	6466      	str	r6, [r4, #68]	; 0x44
    717c:	e249      	b.n	7612 <_TcpSend+0x58a>
                    if(pSkt->pSktNet == 0)
    717e:	6c23      	ldr	r3, [r4, #64]	; 0x40
    7180:	b12b      	cbz	r3, 718e <_TcpSend+0x106>
                    mss = TCPIP_IPV4_MaxDatagramDataSizeGet(pSkt->pSktNet) - sizeof(TCP_HEADER);
    7182:	6c20      	ldr	r0, [r4, #64]	; 0x40
    7184:	f019 fe0e 	bl	20da4 <TCPIP_IPV4_MaxDatagramDataSizeGet>
    7188:	3814      	subs	r0, #20
    718a:	b280      	uxth	r0, r0
    718c:	e7dc      	b.n	7148 <_TcpSend+0xc0>
                        if(!_TcpSocketSetSourceInterface(pSkt))
    718e:	4620      	mov	r0, r4
    7190:	f016 fa1d 	bl	1d5ce <_TcpSocketSetSourceInterface>
    7194:	2800      	cmp	r0, #0
    7196:	d1f4      	bne.n	7182 <_TcpSend+0xfa>
                            sendRes = _TCP_SEND_NO_IF;
    7198:	f06f 0003 	mvn.w	r0, #3
    if(sendRes != _TCP_SEND_OK && pSkt->addType == IP_ADDRESS_TYPE_IPV4)
    719c:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    71a0:	2b01      	cmp	r3, #1
    71a2:	f040 8179 	bne.w	7498 <_TcpSend+0x410>
        ((TCP_V4_PACKET*)pSendPkt)->v4Pkt.macPkt.pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED ;
    71a6:	8c73      	ldrh	r3, [r6, #34]	; 0x22
    71a8:	f023 0308 	bic.w	r3, r3, #8
    71ac:	8473      	strh	r3, [r6, #34]	; 0x22
    if(sendRes == _TCP_SEND_OK && (vTCPFlags & RST) != 0 )
    71ae:	e173      	b.n	7498 <_TcpSend+0x410>
                    pSkt->MySEQ = _TCP_SktSetSequenceNo(pSkt);
    71b0:	4620      	mov	r0, r4
    71b2:	f00f fed7 	bl	16f64 <_TCP_SktSetSequenceNo>
    71b6:	64e0      	str	r0, [r4, #76]	; 0x4c
    loadLen = (uint16_t)len;  // save the TCP payload size
    71b8:	f04f 0800 	mov.w	r8, #0
    71bc:	e0bb      	b.n	7336 <_TcpSend+0x2ae>
            maxPayload = pSkt->wRemoteMSS;
    71be:	f8b4 b062 	ldrh.w	fp, [r4, #98]	; 0x62
            if(pSkt->txHead == pSkt->txUnackedTail)
    71c2:	68a2      	ldr	r2, [r4, #8]
    71c4:	6923      	ldr	r3, [r4, #16]
    71c6:	429a      	cmp	r2, r3
    71c8:	f000 81fa 	beq.w	75c0 <_TcpSend+0x538>
                if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
    71cc:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    71d0:	2b01      	cmp	r3, #1
    71d2:	d039      	beq.n	7248 <_TcpSend+0x1c0>
                    if(pSkt->localMSS < maxPayload)
    71d4:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    71d8:	459b      	cmp	fp, r3
    71da:	bf28      	it	cs
    71dc:	469b      	movcs	fp, r3
                if(pSkt->txHead > pSkt->txUnackedTail)
    71de:	68a3      	ldr	r3, [r4, #8]
    71e0:	6921      	ldr	r1, [r4, #16]
    71e2:	428b      	cmp	r3, r1
    71e4:	d948      	bls.n	7278 <_TcpSend+0x1f0>
                    len = pSkt->txHead - pSkt->txUnackedTail;
    71e6:	1a5b      	subs	r3, r3, r1
                    if(len > pSkt->remoteWindow)
    71e8:	f8b4 905c 	ldrh.w	r9, [r4, #92]	; 0x5c
    71ec:	4599      	cmp	r9, r3
    71ee:	bf28      	it	cs
    71f0:	4699      	movcs	r9, r3
                    if(len > maxPayload)
    71f2:	45cb      	cmp	fp, r9
    71f4:	d206      	bcs.n	7204 <_TcpSend+0x17c>
                        pSkt->Flags.bTXASAPWithoutTimerReset = 1;
    71f6:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    71fa:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    71fe:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
                        len = maxPayload;
    7202:	46d9      	mov	r9, fp
}


static void _TCP_PayloadSet(TCB_STUB * pSkt, void* pPkt, uint8_t* payload1, uint16_t len1, uint8_t* payload2, uint16_t len2)
{
    switch(pSkt->addType)
    7204:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    7208:	2b01      	cmp	r3, #1
    720a:	d022      	beq.n	7252 <_TcpSend+0x1ca>
                    pSkt->txUnackedTail += len;
    720c:	6923      	ldr	r3, [r4, #16]
    720e:	444b      	add	r3, r9
    7210:	6123      	str	r3, [r4, #16]
            if(pSkt->Flags.bTXFIN)
    7212:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
    7216:	f013 0f01 	tst.w	r3, #1
    721a:	d007      	beq.n	722c <_TcpSend+0x1a4>
                if((len != pSkt->remoteWindow) && (len != maxPayload))
    721c:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
    7220:	454b      	cmp	r3, r9
    7222:	d003      	beq.n	722c <_TcpSend+0x1a4>
    7224:	45cb      	cmp	fp, r9
                    vTCPFlags |= FIN;
    7226:	bf18      	it	ne
    7228:	f047 0701 	orrne.w	r7, r7, #1
    loadLen = (uint16_t)len;  // save the TCP payload size
    722c:	fa1f f889 	uxth.w	r8, r9
        if(len || (vTCPFlags & (SYN | FIN)))
    7230:	f1b9 0f00 	cmp.w	r9, #0
    7234:	d07f      	beq.n	7336 <_TcpSend+0x2ae>
            pSkt->remoteWindow -= len;
    7236:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
    723a:	eba3 0308 	sub.w	r3, r3, r8
    723e:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
                vTCPFlags |= PSH;
    7242:	f047 0708 	orr.w	r7, r7, #8
    7246:	e07b      	b.n	7340 <_TcpSend+0x2b8>
                    isFragmSupported = TCPIP_IPV4_IsFragmentationEnabled();
    7248:	f01a ff73 	bl	22132 <TCPIP_IPV4_IsFragmentationEnabled>
                if(!isFragmSupported)
    724c:	2800      	cmp	r0, #0
    724e:	d1c6      	bne.n	71de <_TcpSend+0x156>
    7250:	e7c0      	b.n	71d4 <_TcpSend+0x14c>
        pSeg0->next = 0;
    7252:	2300      	movs	r3, #0
    7254:	6473      	str	r3, [r6, #68]	; 0x44
    if(pBuff1)
    7256:	b159      	cbz	r1, 7270 <_TcpSend+0x1e8>
                    _TCP_PayloadSet(pSkt, pSendPkt, pSkt->txUnackedTail, len, 0, 0);
    7258:	fa1f f389 	uxth.w	r3, r9
        pSeg0->segLen = pSeg0->segSize = bSize1;
    725c:	f8a6 3052 	strh.w	r3, [r6, #82]	; 0x52
    7260:	f8a6 3050 	strh.w	r3, [r6, #80]	; 0x50
        pSeg0->segLoad = pBuff1;
    7264:	64f1      	str	r1, [r6, #76]	; 0x4c
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = pSeg0;  // link to the 1st data seg to be transmitted
    7266:	6933      	ldr	r3, [r6, #16]
    TCPIP_MAC_DATA_SEGMENT* pSeg0 = pTcpPkt->tcpSeg + 0;
    7268:	f106 0244 	add.w	r2, r6, #68	; 0x44
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = pSeg0;  // link to the 1st data seg to be transmitted
    726c:	601a      	str	r2, [r3, #0]
    726e:	e7cd      	b.n	720c <_TcpSend+0x184>
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = 0;  // link to the 1st data seg to be transmitted
    7270:	6933      	ldr	r3, [r6, #16]
    7272:	2200      	movs	r2, #0
    7274:	601a      	str	r2, [r3, #0]
    7276:	e7c9      	b.n	720c <_TcpSend+0x184>
                    lenEnd = pSkt->txEnd - pSkt->txUnackedTail;
    7278:	6862      	ldr	r2, [r4, #4]
    727a:	1a52      	subs	r2, r2, r1
                    len = lenEnd + pSkt->txHead - pSkt->txStart;
    727c:	6820      	ldr	r0, [r4, #0]
    727e:	4413      	add	r3, r2
    7280:	1a1b      	subs	r3, r3, r0
                    if(len > pSkt->remoteWindow)
    7282:	f8b4 905c 	ldrh.w	r9, [r4, #92]	; 0x5c
    7286:	4599      	cmp	r9, r3
    7288:	bf28      	it	cs
    728a:	4699      	movcs	r9, r3
                    if(len > maxPayload)
    728c:	45cb      	cmp	fp, r9
    728e:	d206      	bcs.n	729e <_TcpSend+0x216>
                        pSkt->Flags.bTXASAPWithoutTimerReset = 1;
    7290:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    7294:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    7298:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
                        len = maxPayload;
    729c:	46d9      	mov	r9, fp
                    if (lenEnd > len)
    729e:	4613      	mov	r3, r2
    72a0:	454a      	cmp	r2, r9
    72a2:	bf28      	it	cs
    72a4:	464b      	movcs	r3, r9
                    if(lenStart)
    72a6:	ebb9 0203 	subs.w	r2, r9, r3
    72aa:	d02c      	beq.n	7306 <_TcpSend+0x27e>
    switch(pSkt->addType)
    72ac:	f894 c06f 	ldrb.w	ip, [r4, #111]	; 0x6f
    72b0:	f1bc 0f01 	cmp.w	ip, #1
    72b4:	d00a      	beq.n	72cc <_TcpSend+0x244>
                    pSkt->txUnackedTail += len;
    72b6:	6923      	ldr	r3, [r4, #16]
    72b8:	444b      	add	r3, r9
    72ba:	6123      	str	r3, [r4, #16]
                    if(pSkt->txUnackedTail >= pSkt->txEnd)
    72bc:	6862      	ldr	r2, [r4, #4]
    72be:	4293      	cmp	r3, r2
    72c0:	d3a7      	bcc.n	7212 <_TcpSend+0x18a>
                        pSkt->txUnackedTail -= pSkt->txEnd-pSkt->txStart;
    72c2:	6821      	ldr	r1, [r4, #0]
    72c4:	1a52      	subs	r2, r2, r1
    72c6:	1a9b      	subs	r3, r3, r2
    72c8:	6123      	str	r3, [r4, #16]
    72ca:	e7a2      	b.n	7212 <_TcpSend+0x18a>
    if(pBuff2)
    72cc:	b1a0      	cbz	r0, 72f8 <_TcpSend+0x270>
                        _TCP_PayloadSet(pSkt, pSendPkt, pSkt->txUnackedTail, lenEnd, pSkt->txStart, lenStart);
    72ce:	b292      	uxth	r2, r2
        pSeg1->segLen = pSeg1->segSize = bSize2;
    72d0:	f8a6 206a 	strh.w	r2, [r6, #106]	; 0x6a
    72d4:	f8a6 2068 	strh.w	r2, [r6, #104]	; 0x68
        pSeg1->segLoad = pBuff2;
    72d8:	6670      	str	r0, [r6, #100]	; 0x64
    TCPIP_MAC_DATA_SEGMENT* pSeg1 = pTcpPkt->tcpSeg + 1;
    72da:	f106 025c 	add.w	r2, r6, #92	; 0x5c
        pSeg0->next = pSeg1;
    72de:	6472      	str	r2, [r6, #68]	; 0x44
    if(pBuff1)
    72e0:	b169      	cbz	r1, 72fe <_TcpSend+0x276>
                        _TCP_PayloadSet(pSkt, pSendPkt, pSkt->txUnackedTail, lenEnd, pSkt->txStart, lenStart);
    72e2:	b29b      	uxth	r3, r3
        pSeg0->segLen = pSeg0->segSize = bSize1;
    72e4:	f8a6 3052 	strh.w	r3, [r6, #82]	; 0x52
    72e8:	f8a6 3050 	strh.w	r3, [r6, #80]	; 0x50
        pSeg0->segLoad = pBuff1;
    72ec:	64f1      	str	r1, [r6, #76]	; 0x4c
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = pSeg0;  // link to the 1st data seg to be transmitted
    72ee:	6933      	ldr	r3, [r6, #16]
    TCPIP_MAC_DATA_SEGMENT* pSeg0 = pTcpPkt->tcpSeg + 0;
    72f0:	f106 0244 	add.w	r2, r6, #68	; 0x44
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = pSeg0;  // link to the 1st data seg to be transmitted
    72f4:	601a      	str	r2, [r3, #0]
    72f6:	e7de      	b.n	72b6 <_TcpSend+0x22e>
        pSeg0->next = 0;
    72f8:	2200      	movs	r2, #0
    72fa:	6472      	str	r2, [r6, #68]	; 0x44
    72fc:	e7f0      	b.n	72e0 <_TcpSend+0x258>
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = 0;  // link to the 1st data seg to be transmitted
    72fe:	6933      	ldr	r3, [r6, #16]
    7300:	2200      	movs	r2, #0
    7302:	601a      	str	r2, [r3, #0]
    7304:	e7d7      	b.n	72b6 <_TcpSend+0x22e>
    switch(pSkt->addType)
    7306:	f894 206f 	ldrb.w	r2, [r4, #111]	; 0x6f
    730a:	2a01      	cmp	r2, #1
    730c:	d1d3      	bne.n	72b6 <_TcpSend+0x22e>
        pSeg0->next = 0;
    730e:	2200      	movs	r2, #0
    7310:	6472      	str	r2, [r6, #68]	; 0x44
    if(pBuff1)
    7312:	b151      	cbz	r1, 732a <_TcpSend+0x2a2>
                        _TCP_PayloadSet(pSkt, pSendPkt, pSkt->txUnackedTail, lenEnd, 0, 0);
    7314:	b29b      	uxth	r3, r3
        pSeg0->segLen = pSeg0->segSize = bSize1;
    7316:	f8a6 3052 	strh.w	r3, [r6, #82]	; 0x52
    731a:	f8a6 3050 	strh.w	r3, [r6, #80]	; 0x50
        pSeg0->segLoad = pBuff1;
    731e:	64f1      	str	r1, [r6, #76]	; 0x4c
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = pSeg0;  // link to the 1st data seg to be transmitted
    7320:	6933      	ldr	r3, [r6, #16]
    TCPIP_MAC_DATA_SEGMENT* pSeg0 = pTcpPkt->tcpSeg + 0;
    7322:	f106 0244 	add.w	r2, r6, #68	; 0x44
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = pSeg0;  // link to the 1st data seg to be transmitted
    7326:	601a      	str	r2, [r3, #0]
    7328:	e7c5      	b.n	72b6 <_TcpSend+0x22e>
        pTcpPkt->v4Pkt.macPkt.pDSeg->next = 0;  // link to the 1st data seg to be transmitted
    732a:	6933      	ldr	r3, [r6, #16]
    732c:	2200      	movs	r2, #0
    732e:	601a      	str	r2, [r3, #0]
    7330:	e7c1      	b.n	72b6 <_TcpSend+0x22e>
    loadLen = (uint16_t)len;  // save the TCP payload size
    7332:	f04f 0800 	mov.w	r8, #0
        if(len || (vTCPFlags & (SYN | FIN)))
    7336:	f017 0f03 	tst.w	r7, #3
    733a:	d046      	beq.n	73ca <_TcpSend+0x342>
    733c:	f04f 0900 	mov.w	r9, #0
            if(vSendFlags & SENDTCP_RESET_TIMERS)
    7340:	f01a 0f01 	tst.w	sl, #1
    7344:	d132      	bne.n	73ac <_TcpSend+0x324>
            pSkt->eventTime = SYS_TMR_TickCountGet() + pSkt->retryInterval;
    7346:	f018 fe31 	bl	1ffac <SYS_TMR_TickCountGet>
    734a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    734c:	4418      	add	r0, r3
    734e:	6260      	str	r0, [r4, #36]	; 0x24
            pSkt->Flags.bTimerEnabled = 1;
    7350:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    7354:	f043 0302 	orr.w	r3, r3, #2
    7358:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
        header->SourcePort			= pSkt->localPort;
    735c:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
    7360:	802b      	strh	r3, [r5, #0]
        header->DestPort			= pSkt->remotePort;
    7362:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
    7366:	806b      	strh	r3, [r5, #2]
        header->SeqNumber			= pSkt->MySEQ;
    7368:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    736a:	606b      	str	r3, [r5, #4]
        header->AckNumber			= pSkt->RemoteSEQ;
    736c:	6d23      	ldr	r3, [r4, #80]	; 0x50
    736e:	60ab      	str	r3, [r5, #8]
        header->DataOffset.Reserved3	= 0;
    7370:	7b2b      	ldrb	r3, [r5, #12]
    7372:	f36f 0303 	bfc	r3, #0, #4
    7376:	732b      	strb	r3, [r5, #12]
        header->Flags.byte			= vTCPFlags;
    7378:	736f      	strb	r7, [r5, #13]
        header->UrgentPointer       = 0;
    737a:	2300      	movs	r3, #0
    737c:	826b      	strh	r3, [r5, #18]
        header->Checksum            = 0;
    737e:	822b      	strh	r3, [r5, #16]
        pSkt->MySEQ += (uint32_t)len;
    7380:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    7382:	444b      	add	r3, r9
    7384:	64e3      	str	r3, [r4, #76]	; 0x4c
        if(vTCPFlags & SYN)
    7386:	f017 0f02 	tst.w	r7, #2
    738a:	d054      	beq.n	7436 <_TcpSend+0x3ae>
            if(!(vTCPFlags & ACK))
    738c:	f017 0f10 	tst.w	r7, #16
                header->AckNumber = 0;
    7390:	bf04      	itt	eq
    7392:	2300      	moveq	r3, #0
    7394:	60ab      	streq	r3, [r5, #8]
            if(pSkt->flags.bSYNSent)
    7396:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
    739a:	f013 0f08 	tst.w	r3, #8
    739e:	d03e      	beq.n	741e <_TcpSend+0x396>
                header->SeqNumber--;
    73a0:	686b      	ldr	r3, [r5, #4]
    73a2:	3b01      	subs	r3, #1
    73a4:	606b      	str	r3, [r5, #4]
            hdrLen = sizeof(options);
    73a6:	f04f 0904 	mov.w	r9, #4
    73aa:	e046      	b.n	743a <_TcpSend+0x3b2>
                pSkt->retryCount = 0;
    73ac:	2300      	movs	r3, #0
    73ae:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
                pSkt->retryInterval = (TCPIP_TCP_START_TIMEOUT_VAL * SYS_TMR_TickCounterFrequencyGet())/1000;
    73b2:	f018 fe23 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
    73b6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    73ba:	fb03 f300 	mul.w	r3, r3, r0
    73be:	489c      	ldr	r0, [pc, #624]	; (7630 <_TcpSend+0x5a8>)
    73c0:	fba0 2303 	umull	r2, r3, r0, r3
    73c4:	099b      	lsrs	r3, r3, #6
    73c6:	64a3      	str	r3, [r4, #72]	; 0x48
    73c8:	e7bd      	b.n	7346 <_TcpSend+0x2be>
        else if(vSendFlags & SENDTCP_KEEP_ALIVE)
    73ca:	f01a 0f02 	tst.w	sl, #2
    73ce:	d00a      	beq.n	73e6 <_TcpSend+0x35e>
            pSkt->keepAliveCount++;
    73d0:	f894 3071 	ldrb.w	r3, [r4, #113]	; 0x71
    73d4:	3301      	adds	r3, #1
    73d6:	f884 3071 	strb.w	r3, [r4, #113]	; 0x71
            pSkt->MySEQ -= 1;
    73da:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    73dc:	3b01      	subs	r3, #1
    73de:	64e3      	str	r3, [r4, #76]	; 0x4c
            len = 1;
    73e0:	f04f 0901 	mov.w	r9, #1
    73e4:	e7ba      	b.n	735c <_TcpSend+0x2d4>
        else if(pSkt->Flags.bTimerEnabled) 
    73e6:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    73ea:	f013 0f02 	tst.w	r3, #2
    73ee:	d013      	beq.n	7418 <_TcpSend+0x390>
            if(!(vSendFlags & SENDTCP_RESET_TIMERS))
    73f0:	f01a 0f01 	tst.w	sl, #1
    73f4:	d108      	bne.n	7408 <_TcpSend+0x380>
                if(pSkt->retryCount)
    73f6:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
    73fa:	b12b      	cbz	r3, 7408 <_TcpSend+0x380>
                    pSkt->retryCount--;
    73fc:	3b01      	subs	r3, #1
    73fe:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
                    pSkt->retryInterval >>= 1;
    7402:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    7404:	085b      	lsrs	r3, r3, #1
    7406:	64a3      	str	r3, [r4, #72]	; 0x48
            pSkt->eventTime = SYS_TMR_TickCountGet() + pSkt->retryInterval;
    7408:	f018 fdd0 	bl	1ffac <SYS_TMR_TickCountGet>
    740c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    740e:	4418      	add	r0, r3
    7410:	6260      	str	r0, [r4, #36]	; 0x24
    7412:	f04f 0900 	mov.w	r9, #0
    7416:	e7a1      	b.n	735c <_TcpSend+0x2d4>
    7418:	f04f 0900 	mov.w	r9, #0
    741c:	e79e      	b.n	735c <_TcpSend+0x2d4>
                pSkt->MySEQ++;
    741e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    7420:	3301      	adds	r3, #1
    7422:	64e3      	str	r3, [r4, #76]	; 0x4c
                pSkt->flags.bSYNSent = 1;
    7424:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
    7428:	f043 0308 	orr.w	r3, r3, #8
    742c:	f884 306c 	strb.w	r3, [r4, #108]	; 0x6c
            hdrLen = sizeof(options);
    7430:	f04f 0904 	mov.w	r9, #4
    7434:	e001      	b.n	743a <_TcpSend+0x3b2>
            hdrLen = 0;
    7436:	f04f 0900 	mov.w	r9, #0
        if(vTCPFlags & FIN)
    743a:	f017 0f01 	tst.w	r7, #1
    743e:	d005      	beq.n	744c <_TcpSend+0x3c4>
            pSkt->flags.bFINSent = 1;   // do not advance the seq no for FIN!
    7440:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
    7444:	f043 0304 	orr.w	r3, r3, #4
    7448:	f884 306c 	strb.w	r3, [r4, #108]	; 0x6c
        if(vTCPFlags & ACK)
    744c:	f017 0f10 	tst.w	r7, #16
    7450:	d005      	beq.n	745e <_TcpSend+0x3d6>
            pSkt->flags.ackSent = 1;   // store the ACK already sent
    7452:	f894 306d 	ldrb.w	r3, [r4, #109]	; 0x6d
    7456:	f043 0301 	orr.w	r3, r3, #1
    745a:	f884 306d 	strb.w	r3, [r4, #109]	; 0x6d
        if(pSkt->rxHead >= pSkt->rxTail)
    745e:	69e3      	ldr	r3, [r4, #28]
    7460:	6a22      	ldr	r2, [r4, #32]
    7462:	4293      	cmp	r3, r2
    7464:	d31b      	bcc.n	749e <_TcpSend+0x416>
            header->Window = (pSkt->rxEnd - pSkt->rxStart) - (pSkt->rxHead - pSkt->rxTail);
    7466:	69a1      	ldr	r1, [r4, #24]
    7468:	6960      	ldr	r0, [r4, #20]
    746a:	1a09      	subs	r1, r1, r0
    746c:	1a9b      	subs	r3, r3, r2
    746e:	1acb      	subs	r3, r1, r3
    7470:	b29b      	uxth	r3, r3
    7472:	81eb      	strh	r3, [r5, #14]
        pSkt->localWindow = header->Window; // store the last advertised window
    7474:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
        _TcpSwapHeader(header);
    7478:	4628      	mov	r0, r5
    747a:	f013 fa83 	bl	1a984 <_TcpSwapHeader>
        header->DataOffset.Val   += sizeof(TCP_HEADER) >> 2;
    747e:	7b2b      	ldrb	r3, [r5, #12]
    7480:	f3c3 1203 	ubfx	r2, r3, #4, #4
    7484:	3205      	adds	r2, #5
    7486:	f362 1307 	bfi	r3, r2, #4, #4
    748a:	732b      	strb	r3, [r5, #12]
}


static bool _TCP_Flush(TCB_STUB * pSkt, void* pPkt, uint16_t hdrLen, uint16_t loadLen)
{
    switch(pSkt->addType)
    748c:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
    7490:	2b01      	cmp	r3, #1
    7492:	d008      	beq.n	74a6 <_TcpSend+0x41e>
        sendRes = _TCP_Flush (pSkt, pSendPkt, hdrLen, loadLen) ? _TCP_SEND_OK : _TCP_SEND_IP_FAIL;
    7494:	f04f 30ff 	mov.w	r0, #4294967295
}
    7498:	b007      	add	sp, #28
    749a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            header->Window = pSkt->rxTail - pSkt->rxHead - 1;
    749e:	1ad3      	subs	r3, r2, r3
    74a0:	3b01      	subs	r3, #1
    74a2:	b29b      	uxth	r3, r3
    74a4:	e7e5      	b.n	7472 <_TcpSend+0x3ea>
    if(pSkt->destAddress.Val == 0)
    74a6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    74a8:	b913      	cbnz	r3, 74b0 <_TcpSend+0x428>
        sendRes = _TCP_Flush (pSkt, pSendPkt, hdrLen, loadLen) ? _TCP_SEND_OK : _TCP_SEND_IP_FAIL;
    74aa:	f04f 30ff 	mov.w	r0, #4294967295
    74ae:	e675      	b.n	719c <_TcpSend+0x114>
    if(!_TcpSocketSetSourceInterface(pSkt))
    74b0:	4620      	mov	r0, r4
    74b2:	f016 f88c 	bl	1d5ce <_TcpSocketSetSourceInterface>
    74b6:	2800      	cmp	r0, #0
    74b8:	d0f7      	beq.n	74aa <_TcpSend+0x422>
        hdrLen += sizeof(TCP_HEADER);
    74ba:	f109 0914 	add.w	r9, r9, #20
    pv4Pkt->srcAddress.Val = pSkt->srcAddress.Val;
    74be:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    74c0:	6373      	str	r3, [r6, #52]	; 0x34
    pv4Pkt->destAddress.Val = pSkt->destAddress.Val;
    74c2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    74c4:	63b3      	str	r3, [r6, #56]	; 0x38
    pv4Pkt->netIfH = pSkt->pSktNet;
    74c6:	6c23      	ldr	r3, [r4, #64]	; 0x40
    74c8:	63f3      	str	r3, [r6, #60]	; 0x3c
    pv4Pkt->macPkt.pDSeg->segLen += hdrLen;
    74ca:	6932      	ldr	r2, [r6, #16]
    74cc:	8993      	ldrh	r3, [r2, #12]
    74ce:	444b      	add	r3, r9
    74d0:	8193      	strh	r3, [r2, #12]
    pseudoHdr.SourceAddress.Val = pv4Pkt->srcAddress.Val;
    74d2:	6b73      	ldr	r3, [r6, #52]	; 0x34
    74d4:	9302      	str	r3, [sp, #8]
    pseudoHdr.DestAddress.Val = pv4Pkt->destAddress.Val;
    74d6:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    74d8:	9303      	str	r3, [sp, #12]
    pseudoHdr.Zero = 0;
    74da:	2200      	movs	r2, #0
    74dc:	f88d 2010 	strb.w	r2, [sp, #16]
    pseudoHdr.Protocol = IP_PROT_TCP;
    74e0:	2306      	movs	r3, #6
    74e2:	f88d 3011 	strb.w	r3, [sp, #17]
    pseudoHdr.Length = TCPIP_Helper_htons(hdrLen + loadLen);
    74e6:	eb09 0508 	add.w	r5, r9, r8
    74ea:	b2ad      	uxth	r5, r5
    74ec:	0a2b      	lsrs	r3, r5, #8
    74ee:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    74f2:	f8ad 3012 	strh.w	r3, [sp, #18]
    checksum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)&pseudoHdr, sizeof(pseudoHdr), 0);
    74f6:	210c      	movs	r1, #12
    74f8:	a802      	add	r0, sp, #8
    74fa:	f012 fedf 	bl	1a2bc <TCPIP_Helper_CalcIPChecksum>
    pTCPHdr = (TCP_HEADER*)pv4Pkt->macPkt.pTransportLayer;
    74fe:	f8d6 a01c 	ldr.w	sl, [r6, #28]
    checksum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)&pseudoHdr, sizeof(pseudoHdr), 0);
    7502:	43c2      	mvns	r2, r0
    checksum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)pTCPHdr, hdrLen, checksum);
    7504:	b292      	uxth	r2, r2
    7506:	4649      	mov	r1, r9
    7508:	4650      	mov	r0, sl
    750a:	f012 fed7 	bl	1a2bc <TCPIP_Helper_CalcIPChecksum>
    750e:	43c3      	mvns	r3, r0
    7510:	b29b      	uxth	r3, r3
    if(loadLen)
    7512:	f1b8 0f00 	cmp.w	r8, #0
    7516:	d125      	bne.n	7564 <_TcpSend+0x4dc>
        pv4Pkt->macPkt.pDSeg->segFlags &= ~TCPIP_MAC_SEG_FLAG_USER_PAYLOAD;
    7518:	6931      	ldr	r1, [r6, #16]
    751a:	8a0a      	ldrh	r2, [r1, #16]
    751c:	f022 0208 	bic.w	r2, r2, #8
    7520:	820a      	strh	r2, [r1, #16]
    pTCPHdr->Checksum = ~checksum;
    7522:	43db      	mvns	r3, r3
    7524:	f8aa 3010 	strh.w	r3, [sl, #16]
    pktParams.ttl = pSkt->ttl;
    7528:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
    752c:	f88d 3005 	strb.w	r3, [sp, #5]
    pktParams.tosFlags = pSkt->tos;
    7530:	f894 307f 	ldrb.w	r3, [r4, #127]	; 0x7f
    7534:	f88d 3004 	strb.w	r3, [sp, #4]
    pktParams.df = 0;
    7538:	f04f 0800 	mov.w	r8, #0
    753c:	f88d 8006 	strb.w	r8, [sp, #6]
    TCPIP_IPV4_PacketFormatTx(pv4Pkt, IP_PROT_TCP, hdrLen + loadLen, &pktParams);
    7540:	ab01      	add	r3, sp, #4
    7542:	462a      	mov	r2, r5
    7544:	2106      	movs	r1, #6
    7546:	4630      	mov	r0, r6
    7548:	f00b fc90 	bl	12e6c <TCPIP_IPV4_PacketFormatTx>
    pv4Pkt->macPkt.next = 0;    // single packet
    754c:	f8c6 8000 	str.w	r8, [r6]
    if(TCPIP_IPV4_PacketTransmit(pv4Pkt))
    7550:	4630      	mov	r0, r6
    7552:	f01a fcb3 	bl	21ebc <TCPIP_IPV4_PacketTransmit>
    if(sendRes != _TCP_SEND_OK && pSkt->addType == IP_ADDRESS_TYPE_IPV4)
    7556:	2800      	cmp	r0, #0
    7558:	d0a7      	beq.n	74aa <_TcpSend+0x422>
    if(sendRes == _TCP_SEND_OK && (vTCPFlags & RST) != 0 )
    755a:	f017 0f04 	tst.w	r7, #4
    755e:	d10e      	bne.n	757e <_TcpSend+0x4f6>
    7560:	2000      	movs	r0, #0
    7562:	e799      	b.n	7498 <_TcpSend+0x410>
        pv4Pkt->macPkt.pDSeg->segFlags |= TCPIP_MAC_SEG_FLAG_USER_PAYLOAD;
    7564:	6931      	ldr	r1, [r6, #16]
    7566:	8a0a      	ldrh	r2, [r1, #16]
    7568:	f042 0208 	orr.w	r2, r2, #8
    756c:	820a      	strh	r2, [r1, #16]
        checksum = ~TCPIP_Helper_PacketChecksum(&pv4Pkt->macPkt, ((TCP_V4_PACKET*)pv4Pkt)->tcpSeg[0].segLoad, loadLen, checksum);
    756e:	4642      	mov	r2, r8
    7570:	6cf1      	ldr	r1, [r6, #76]	; 0x4c
    7572:	4630      	mov	r0, r6
    7574:	f011 fc74 	bl	18e60 <TCPIP_Helper_PacketChecksum>
    7578:	43c3      	mvns	r3, r0
    757a:	b29b      	uxth	r3, r3
    757c:	e7d1      	b.n	7522 <_TcpSend+0x49a>
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    757e:	2000      	movs	r0, #0
    7580:	f019 ff8c 	bl	2149c <OSAL_CRIT_Enter>
    *pSigHandler = pSkt->sigHandler;
    7584:	6f65      	ldr	r5, [r4, #116]	; 0x74
    *pSigParam = pSkt->sigParam;
    7586:	6fa7      	ldr	r7, [r4, #120]	; 0x78
    uint16_t sigMask = pSkt->sigMask;
    7588:	f8b4 6072 	ldrh.w	r6, [r4, #114]	; 0x72
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
    758c:	4601      	mov	r1, r0
    758e:	2000      	movs	r0, #0
    7590:	f01a f8b3 	bl	216fa <OSAL_CRIT_Leave>
        if(sigHandler != 0 && (sigMask & TCPIP_TCP_SIGNAL_TX_RST) != 0)
    7594:	b185      	cbz	r5, 75b8 <_TcpSend+0x530>
    7596:	f016 0f08 	tst.w	r6, #8
    759a:	d00f      	beq.n	75bc <_TcpSend+0x534>
            (*sigHandler)(pSkt->sktIx, pSkt->pSktNet, TCPIP_TCP_SIGNAL_TX_RST, sigParam);
    759c:	463b      	mov	r3, r7
    759e:	2208      	movs	r2, #8
    75a0:	6c21      	ldr	r1, [r4, #64]	; 0x40
    75a2:	f9b4 0034 	ldrsh.w	r0, [r4, #52]	; 0x34
    75a6:	47a8      	blx	r5
    75a8:	2000      	movs	r0, #0
    75aa:	e775      	b.n	7498 <_TcpSend+0x410>
            return _TCP_SEND_NO_PKT; 
    75ac:	f06f 0001 	mvn.w	r0, #1
}
    75b0:	4770      	bx	lr
        return _TCP_SEND_NO_MEMORY;
    75b2:	f06f 0002 	mvn.w	r0, #2
    75b6:	e76f      	b.n	7498 <_TcpSend+0x410>
    75b8:	2000      	movs	r0, #0
    75ba:	e76d      	b.n	7498 <_TcpSend+0x410>
    75bc:	2000      	movs	r0, #0
    75be:	e76b      	b.n	7498 <_TcpSend+0x410>
            if(pSkt->Flags.bTXFIN)
    75c0:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
    75c4:	f013 0f01 	tst.w	r3, #1
    75c8:	d128      	bne.n	761c <_TcpSend+0x594>
    loadLen = (uint16_t)len;  // save the TCP payload size
    75ca:	f04f 0800 	mov.w	r8, #0
    75ce:	e6b2      	b.n	7336 <_TcpSend+0x2ae>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
    75d0:	4601      	mov	r1, r0
    75d2:	2000      	movs	r0, #0
    75d4:	f01a f891 	bl	216fa <OSAL_CRIT_Leave>
    pv4Pkt = (TCP_V4_PACKET*)TCPIP_PKT_SocketAlloc(sizeof(TCP_V4_PACKET), sizeof(TCP_HEADER), sizeof(TCP_OPTIONS), allocFlags);
    75d8:	f242 0306 	movw	r3, #8198	; 0x2006
    75dc:	2204      	movs	r2, #4
    75de:	2114      	movs	r1, #20
    75e0:	2074      	movs	r0, #116	; 0x74
    75e2:	f018 f8ff 	bl	1f7e4 <_TCPIP_PKT_SocketAlloc>
    if(pv4Pkt)
    75e6:	4606      	mov	r6, r0
    75e8:	2800      	cmp	r0, #0
    75ea:	d0e2      	beq.n	75b2 <_TcpSend+0x52a>
// will be automatically freed by this function.
void            TCPIP_PKT_PacketFree(TCPIP_MAC_PACKET* pPkt);

static __inline__ void __attribute__((always_inline)) TCPIP_PKT_PacketAcknowledgeSet(TCPIP_MAC_PACKET* pPkt, TCPIP_MAC_PACKET_ACK_FUNC ackFunc, const void* ackParam)
{
    pPkt->ackFunc = ackFunc;
    75ec:	4b11      	ldr	r3, [pc, #68]	; (7634 <_TcpSend+0x5ac>)
    75ee:	6083      	str	r3, [r0, #8]
    pPkt->ackParam = ackParam;
    75f0:	60c4      	str	r4, [r0, #12]
        pv4Pkt->tcpSeg[0].segFlags = pv4Pkt->tcpSeg[1].segFlags = TCPIP_MAC_SEG_FLAG_STATIC; // embedded in packet itself
    75f2:	2301      	movs	r3, #1
    75f4:	f8a0 306c 	strh.w	r3, [r0, #108]	; 0x6c
    75f8:	f8a0 3054 	strh.w	r3, [r0, #84]	; 0x54
            pPkt->v4Pkt.macPkt.pktFlags |= TCPIP_MAC_PKT_FLAG_QUEUED;
    75fc:	8c43      	ldrh	r3, [r0, #34]	; 0x22
    75fe:	f043 0308 	orr.w	r3, r3, #8
    7602:	8443      	strh	r3, [r0, #34]	; 0x22
            OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    7604:	2000      	movs	r0, #0
    7606:	f019 ff49 	bl	2149c <OSAL_CRIT_Enter>
            if(pSkt->pV4Pkt == 0)
    760a:	6c63      	ldr	r3, [r4, #68]	; 0x44
    760c:	2b00      	cmp	r3, #0
    760e:	f43f adb4 	beq.w	717a <_TcpSend+0xf2>
            OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
    7612:	4601      	mov	r1, r0
    7614:	2000      	movs	r0, #0
    7616:	f01a f870 	bl	216fa <OSAL_CRIT_Leave>
    761a:	e566      	b.n	70ea <_TcpSend+0x62>
                if((len != pSkt->remoteWindow) && (len != maxPayload))
    761c:	f8b4 805c 	ldrh.w	r8, [r4, #92]	; 0x5c
    7620:	f1b8 0f00 	cmp.w	r8, #0
    7624:	f43f ae87 	beq.w	7336 <_TcpSend+0x2ae>
                len = 0;
    7628:	f04f 0900 	mov.w	r9, #0
    762c:	e5fa      	b.n	7224 <_TcpSend+0x19c>
    762e:	bf00      	nop
    7630:	10624dd3 	.word	0x10624dd3
    7634:	00013735 	.word	0x00013735

Disassembly of section .text._printf_float%198:

00007638 <_printf_float>:
    7638:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    763c:	b08d      	sub	sp, #52	; 0x34
    763e:	460c      	mov	r4, r1
    7640:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
    7644:	4693      	mov	fp, r2
    7646:	461f      	mov	r7, r3
    7648:	4606      	mov	r6, r0
    764a:	f01a fd53 	bl	220f4 <_localeconv_r>
    764e:	6803      	ldr	r3, [r0, #0]
    7650:	9305      	str	r3, [sp, #20]
    7652:	4618      	mov	r0, r3
    7654:	f01a faa2 	bl	21b9c <strlen>
    7658:	f8d8 3000 	ldr.w	r3, [r8]
    765c:	9006      	str	r0, [sp, #24]
    765e:	3307      	adds	r3, #7
    7660:	f023 0307 	bic.w	r3, r3, #7
    7664:	f103 0208 	add.w	r2, r3, #8
    7668:	f894 a018 	ldrb.w	sl, [r4, #24]
    766c:	6825      	ldr	r5, [r4, #0]
    766e:	f8c8 2000 	str.w	r2, [r8]
    7672:	e9d3 2300 	ldrd	r2, r3, [r3]
    7676:	e9c4 2312 	strd	r2, r3, [r4, #72]	; 0x48
    767a:	ed94 7b12 	vldr	d7, [r4, #72]	; 0x48
    767e:	ed8d 7b02 	vstr	d7, [sp, #8]
    7682:	e9dd 8302 	ldrd	r8, r3, [sp, #8]
    7686:	f023 4900 	bic.w	r9, r3, #2147483648	; 0x80000000
    768a:	f04f 32ff 	mov.w	r2, #4294967295
    768e:	4ba2      	ldr	r3, [pc, #648]	; (7918 <_printf_float+0x2e0>)
    7690:	4640      	mov	r0, r8
    7692:	4649      	mov	r1, r9
    7694:	f018 f9da 	bl	1fa4c <__aeabi_dcmpun>
    7698:	bb70      	cbnz	r0, 76f8 <_printf_float+0xc0>
    769a:	f04f 32ff 	mov.w	r2, #4294967295
    769e:	4b9e      	ldr	r3, [pc, #632]	; (7918 <_printf_float+0x2e0>)
    76a0:	4640      	mov	r0, r8
    76a2:	4649      	mov	r1, r9
    76a4:	f00c f828 	bl	136f8 <__aeabi_dcmple>
    76a8:	bb30      	cbnz	r0, 76f8 <_printf_float+0xc0>
    76aa:	2200      	movs	r2, #0
    76ac:	2300      	movs	r3, #0
    76ae:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    76b2:	f00c f817 	bl	136e4 <__aeabi_dcmplt>
    76b6:	b110      	cbz	r0, 76be <_printf_float+0x86>
    76b8:	232d      	movs	r3, #45	; 0x2d
    76ba:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    76be:	4b97      	ldr	r3, [pc, #604]	; (791c <_printf_float+0x2e4>)
    76c0:	1d1a      	adds	r2, r3, #4
    76c2:	f025 0504 	bic.w	r5, r5, #4
    76c6:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
    76ca:	bf94      	ite	ls
    76cc:	4699      	movls	r9, r3
    76ce:	4691      	movhi	r9, r2
    76d0:	6025      	str	r5, [r4, #0]
    76d2:	2303      	movs	r3, #3
    76d4:	2500      	movs	r5, #0
    76d6:	6123      	str	r3, [r4, #16]
    76d8:	46a8      	mov	r8, r5
    76da:	9700      	str	r7, [sp, #0]
    76dc:	465b      	mov	r3, fp
    76de:	aa0a      	add	r2, sp, #40	; 0x28
    76e0:	4621      	mov	r1, r4
    76e2:	4630      	mov	r0, r6
    76e4:	f00d f9ee 	bl	14ac4 <_printf_common>
    76e8:	3001      	adds	r0, #1
    76ea:	f040 8109 	bne.w	7900 <_printf_float+0x2c8>
    76ee:	f04f 30ff 	mov.w	r0, #4294967295
    76f2:	b00d      	add	sp, #52	; 0x34
    76f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    76f8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    76fc:	4610      	mov	r0, r2
    76fe:	4619      	mov	r1, r3
    7700:	f018 f9a4 	bl	1fa4c <__aeabi_dcmpun>
    7704:	b138      	cbz	r0, 7716 <_printf_float+0xde>
    7706:	9b03      	ldr	r3, [sp, #12]
    7708:	2b00      	cmp	r3, #0
    770a:	bfbc      	itt	lt
    770c:	232d      	movlt	r3, #45	; 0x2d
    770e:	f884 3043 	strblt.w	r3, [r4, #67]	; 0x43
    7712:	4b83      	ldr	r3, [pc, #524]	; (7920 <_printf_float+0x2e8>)
    7714:	e7d4      	b.n	76c0 <_printf_float+0x88>
    7716:	6863      	ldr	r3, [r4, #4]
    7718:	1c59      	adds	r1, r3, #1
    771a:	f00a 08df 	and.w	r8, sl, #223	; 0xdf
    771e:	d11c      	bne.n	775a <_printf_float+0x122>
    7720:	2306      	movs	r3, #6
    7722:	6063      	str	r3, [r4, #4]
    7724:	f445 6380 	orr.w	r3, r5, #1024	; 0x400
    7728:	6023      	str	r3, [r4, #0]
    772a:	6863      	ldr	r3, [r4, #4]
    772c:	9304      	str	r3, [sp, #16]
    772e:	9b03      	ldr	r3, [sp, #12]
    7730:	2b00      	cmp	r3, #0
    7732:	da19      	bge.n	7768 <_printf_float+0x130>
    7734:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
    7738:	f081 4300 	eor.w	r3, r1, #2147483648	; 0x80000000
    773c:	e9cd 2302 	strd	r2, r3, [sp, #8]
    7740:	232d      	movs	r3, #45	; 0x2d
    7742:	f1b8 0f46 	cmp.w	r8, #70	; 0x46
    7746:	9307      	str	r3, [sp, #28]
    7748:	d010      	beq.n	776c <_printf_float+0x134>
    774a:	f1b8 0f45 	cmp.w	r8, #69	; 0x45
    774e:	d102      	bne.n	7756 <_printf_float+0x11e>
    7750:	9b04      	ldr	r3, [sp, #16]
    7752:	3301      	adds	r3, #1
    7754:	9304      	str	r3, [sp, #16]
    7756:	2102      	movs	r1, #2
    7758:	e009      	b.n	776e <_printf_float+0x136>
    775a:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
    775e:	d1e1      	bne.n	7724 <_printf_float+0xec>
    7760:	2b00      	cmp	r3, #0
    7762:	d1df      	bne.n	7724 <_printf_float+0xec>
    7764:	2301      	movs	r3, #1
    7766:	e7dc      	b.n	7722 <_printf_float+0xea>
    7768:	2300      	movs	r3, #0
    776a:	e7ea      	b.n	7742 <_printf_float+0x10a>
    776c:	2103      	movs	r1, #3
    776e:	ab0a      	add	r3, sp, #40	; 0x28
    7770:	9301      	str	r3, [sp, #4]
    7772:	ab09      	add	r3, sp, #36	; 0x24
    7774:	9300      	str	r3, [sp, #0]
    7776:	9a04      	ldr	r2, [sp, #16]
    7778:	ab08      	add	r3, sp, #32
    777a:	ed9d 0b02 	vldr	d0, [sp, #8]
    777e:	4630      	mov	r0, r6
    7780:	f7fc fcaa 	bl	40d8 <_dtoa_r>
    7784:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
    7788:	4681      	mov	r9, r0
    778a:	d150      	bne.n	782e <_printf_float+0x1f6>
    778c:	07ea      	lsls	r2, r5, #31
    778e:	d44e      	bmi.n	782e <_printf_float+0x1f6>
    7790:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    7792:	9a08      	ldr	r2, [sp, #32]
    7794:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
    7798:	eba5 0509 	sub.w	r5, r5, r9
    779c:	d171      	bne.n	7882 <_printf_float+0x24a>
    779e:	1cd3      	adds	r3, r2, #3
    77a0:	db03      	blt.n	77aa <_printf_float+0x172>
    77a2:	6863      	ldr	r3, [r4, #4]
    77a4:	4293      	cmp	r3, r2
    77a6:	f280 809a 	bge.w	78de <_printf_float+0x2a6>
    77aa:	f1aa 0a02 	sub.w	sl, sl, #2
    77ae:	fa5f fa8a 	uxtb.w	sl, sl
    77b2:	1e53      	subs	r3, r2, #1
    77b4:	2b00      	cmp	r3, #0
    77b6:	9308      	str	r3, [sp, #32]
    77b8:	bfb6      	itet	lt
    77ba:	f1c2 0301 	rsblt	r3, r2, #1
    77be:	222b      	movge	r2, #43	; 0x2b
    77c0:	222d      	movlt	r2, #45	; 0x2d
    77c2:	2b09      	cmp	r3, #9
    77c4:	f104 0850 	add.w	r8, r4, #80	; 0x50
    77c8:	f884 a050 	strb.w	sl, [r4, #80]	; 0x50
    77cc:	f884 2051 	strb.w	r2, [r4, #81]	; 0x51
    77d0:	dd74      	ble.n	78bc <_printf_float+0x284>
    77d2:	f10d 022f 	add.w	r2, sp, #47	; 0x2f
    77d6:	f04f 0e0a 	mov.w	lr, #10
    77da:	fb93 f1fe 	sdiv	r1, r3, lr
    77de:	fb0e 3011 	mls	r0, lr, r1, r3
    77e2:	3030      	adds	r0, #48	; 0x30
    77e4:	2b63      	cmp	r3, #99	; 0x63
    77e6:	f102 3cff 	add.w	ip, r2, #4294967295
    77ea:	f802 0c01 	strb.w	r0, [r2, #-1]
    77ee:	dc5d      	bgt.n	78ac <_printf_float+0x274>
    77f0:	3130      	adds	r1, #48	; 0x30
    77f2:	3a02      	subs	r2, #2
    77f4:	f80c 1c01 	strb.w	r1, [ip, #-1]
    77f8:	f104 0352 	add.w	r3, r4, #82	; 0x52
    77fc:	f10d 002f 	add.w	r0, sp, #47	; 0x2f
    7800:	4282      	cmp	r2, r0
    7802:	4619      	mov	r1, r3
    7804:	d355      	bcc.n	78b2 <_printf_float+0x27a>
    7806:	eba1 0808 	sub.w	r8, r1, r8
    780a:	eb05 0308 	add.w	r3, r5, r8
    780e:	2d01      	cmp	r5, #1
    7810:	6123      	str	r3, [r4, #16]
    7812:	dc02      	bgt.n	781a <_printf_float+0x1e2>
    7814:	6822      	ldr	r2, [r4, #0]
    7816:	07d0      	lsls	r0, r2, #31
    7818:	d501      	bpl.n	781e <_printf_float+0x1e6>
    781a:	3301      	adds	r3, #1
    781c:	6123      	str	r3, [r4, #16]
    781e:	9b07      	ldr	r3, [sp, #28]
    7820:	2b00      	cmp	r3, #0
    7822:	f43f af5a 	beq.w	76da <_printf_float+0xa2>
    7826:	232d      	movs	r3, #45	; 0x2d
    7828:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    782c:	e755      	b.n	76da <_printf_float+0xa2>
    782e:	9b04      	ldr	r3, [sp, #16]
    7830:	f1b8 0f46 	cmp.w	r8, #70	; 0x46
    7834:	eb09 0503 	add.w	r5, r9, r3
    7838:	d110      	bne.n	785c <_printf_float+0x224>
    783a:	f899 3000 	ldrb.w	r3, [r9]
    783e:	2b30      	cmp	r3, #48	; 0x30
    7840:	d10a      	bne.n	7858 <_printf_float+0x220>
    7842:	2200      	movs	r2, #0
    7844:	2300      	movs	r3, #0
    7846:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    784a:	f00b ff41 	bl	136d0 <__aeabi_dcmpeq>
    784e:	b918      	cbnz	r0, 7858 <_printf_float+0x220>
    7850:	9b04      	ldr	r3, [sp, #16]
    7852:	f1c3 0301 	rsb	r3, r3, #1
    7856:	9308      	str	r3, [sp, #32]
    7858:	9b08      	ldr	r3, [sp, #32]
    785a:	441d      	add	r5, r3
    785c:	2200      	movs	r2, #0
    785e:	2300      	movs	r3, #0
    7860:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    7864:	f00b ff34 	bl	136d0 <__aeabi_dcmpeq>
    7868:	b100      	cbz	r0, 786c <_printf_float+0x234>
    786a:	950a      	str	r5, [sp, #40]	; 0x28
    786c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    786e:	429d      	cmp	r5, r3
    7870:	d98e      	bls.n	7790 <_printf_float+0x158>
    7872:	2230      	movs	r2, #48	; 0x30
    7874:	1c59      	adds	r1, r3, #1
    7876:	910a      	str	r1, [sp, #40]	; 0x28
    7878:	701a      	strb	r2, [r3, #0]
    787a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    787c:	429d      	cmp	r5, r3
    787e:	d8f9      	bhi.n	7874 <_printf_float+0x23c>
    7880:	e786      	b.n	7790 <_printf_float+0x158>
    7882:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
    7886:	d994      	bls.n	77b2 <_printf_float+0x17a>
    7888:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
    788c:	d129      	bne.n	78e2 <_printf_float+0x2aa>
    788e:	2a00      	cmp	r2, #0
    7890:	6863      	ldr	r3, [r4, #4]
    7892:	dd1c      	ble.n	78ce <_printf_float+0x296>
    7894:	6122      	str	r2, [r4, #16]
    7896:	b913      	cbnz	r3, 789e <_printf_float+0x266>
    7898:	6821      	ldr	r1, [r4, #0]
    789a:	07c9      	lsls	r1, r1, #31
    789c:	d502      	bpl.n	78a4 <_printf_float+0x26c>
    789e:	3301      	adds	r3, #1
    78a0:	4413      	add	r3, r2
    78a2:	6123      	str	r3, [r4, #16]
    78a4:	65a2      	str	r2, [r4, #88]	; 0x58
    78a6:	f04f 0800 	mov.w	r8, #0
    78aa:	e7b8      	b.n	781e <_printf_float+0x1e6>
    78ac:	4662      	mov	r2, ip
    78ae:	460b      	mov	r3, r1
    78b0:	e793      	b.n	77da <_printf_float+0x1a2>
    78b2:	f812 1b01 	ldrb.w	r1, [r2], #1
    78b6:	f803 1b01 	strb.w	r1, [r3], #1
    78ba:	e7a1      	b.n	7800 <_printf_float+0x1c8>
    78bc:	2230      	movs	r2, #48	; 0x30
    78be:	4413      	add	r3, r2
    78c0:	f884 2052 	strb.w	r2, [r4, #82]	; 0x52
    78c4:	f104 0154 	add.w	r1, r4, #84	; 0x54
    78c8:	f884 3053 	strb.w	r3, [r4, #83]	; 0x53
    78cc:	e79b      	b.n	7806 <_printf_float+0x1ce>
    78ce:	b913      	cbnz	r3, 78d6 <_printf_float+0x29e>
    78d0:	6821      	ldr	r1, [r4, #0]
    78d2:	07c8      	lsls	r0, r1, #31
    78d4:	d501      	bpl.n	78da <_printf_float+0x2a2>
    78d6:	3302      	adds	r3, #2
    78d8:	e7e3      	b.n	78a2 <_printf_float+0x26a>
    78da:	2301      	movs	r3, #1
    78dc:	e7e1      	b.n	78a2 <_printf_float+0x26a>
    78de:	f04f 0a67 	mov.w	sl, #103	; 0x67
    78e2:	42aa      	cmp	r2, r5
    78e4:	db05      	blt.n	78f2 <_printf_float+0x2ba>
    78e6:	6823      	ldr	r3, [r4, #0]
    78e8:	6122      	str	r2, [r4, #16]
    78ea:	07d9      	lsls	r1, r3, #31
    78ec:	d5da      	bpl.n	78a4 <_printf_float+0x26c>
    78ee:	1c53      	adds	r3, r2, #1
    78f0:	e7d7      	b.n	78a2 <_printf_float+0x26a>
    78f2:	2a00      	cmp	r2, #0
    78f4:	bfd4      	ite	le
    78f6:	f1c2 0302 	rsble	r3, r2, #2
    78fa:	2301      	movgt	r3, #1
    78fc:	442b      	add	r3, r5
    78fe:	e7d0      	b.n	78a2 <_printf_float+0x26a>
    7900:	6823      	ldr	r3, [r4, #0]
    7902:	055a      	lsls	r2, r3, #21
    7904:	d40e      	bmi.n	7924 <_printf_float+0x2ec>
    7906:	6923      	ldr	r3, [r4, #16]
    7908:	464a      	mov	r2, r9
    790a:	4659      	mov	r1, fp
    790c:	4630      	mov	r0, r6
    790e:	47b8      	blx	r7
    7910:	3001      	adds	r0, #1
    7912:	d12f      	bne.n	7974 <_printf_float+0x33c>
    7914:	e6eb      	b.n	76ee <_printf_float+0xb6>
    7916:	bf00      	nop
    7918:	7fefffff 	.word	0x7fefffff
    791c:	000219c6 	.word	0x000219c6
    7920:	000219ce 	.word	0x000219ce
    7924:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
    7928:	f240 80c9 	bls.w	7abe <_printf_float+0x486>
    792c:	2200      	movs	r2, #0
    792e:	2300      	movs	r3, #0
    7930:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
    7934:	f00b fecc 	bl	136d0 <__aeabi_dcmpeq>
    7938:	b388      	cbz	r0, 799e <_printf_float+0x366>
    793a:	2301      	movs	r3, #1
    793c:	4a88      	ldr	r2, [pc, #544]	; (7b60 <_printf_float+0x528>)
    793e:	4659      	mov	r1, fp
    7940:	4630      	mov	r0, r6
    7942:	47b8      	blx	r7
    7944:	3001      	adds	r0, #1
    7946:	f43f aed2 	beq.w	76ee <_printf_float+0xb6>
    794a:	9b08      	ldr	r3, [sp, #32]
    794c:	42ab      	cmp	r3, r5
    794e:	db02      	blt.n	7956 <_printf_float+0x31e>
    7950:	6823      	ldr	r3, [r4, #0]
    7952:	07d8      	lsls	r0, r3, #31
    7954:	d50e      	bpl.n	7974 <_printf_float+0x33c>
    7956:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
    795a:	4659      	mov	r1, fp
    795c:	4630      	mov	r0, r6
    795e:	47b8      	blx	r7
    7960:	3001      	adds	r0, #1
    7962:	f43f aec4 	beq.w	76ee <_printf_float+0xb6>
    7966:	f04f 0800 	mov.w	r8, #0
    796a:	3d01      	subs	r5, #1
    796c:	f104 091a 	add.w	r9, r4, #26
    7970:	4545      	cmp	r5, r8
    7972:	dc09      	bgt.n	7988 <_printf_float+0x350>
    7974:	6823      	ldr	r3, [r4, #0]
    7976:	079d      	lsls	r5, r3, #30
    7978:	f100 80ed 	bmi.w	7b56 <_printf_float+0x51e>
    797c:	68e0      	ldr	r0, [r4, #12]
    797e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    7980:	4298      	cmp	r0, r3
    7982:	bfb8      	it	lt
    7984:	4618      	movlt	r0, r3
    7986:	e6b4      	b.n	76f2 <_printf_float+0xba>
    7988:	2301      	movs	r3, #1
    798a:	464a      	mov	r2, r9
    798c:	4659      	mov	r1, fp
    798e:	4630      	mov	r0, r6
    7990:	47b8      	blx	r7
    7992:	3001      	adds	r0, #1
    7994:	f43f aeab 	beq.w	76ee <_printf_float+0xb6>
    7998:	f108 0801 	add.w	r8, r8, #1
    799c:	e7e8      	b.n	7970 <_printf_float+0x338>
    799e:	9b08      	ldr	r3, [sp, #32]
    79a0:	2b00      	cmp	r3, #0
    79a2:	dc2a      	bgt.n	79fa <_printf_float+0x3c2>
    79a4:	2301      	movs	r3, #1
    79a6:	4a6e      	ldr	r2, [pc, #440]	; (7b60 <_printf_float+0x528>)
    79a8:	4659      	mov	r1, fp
    79aa:	4630      	mov	r0, r6
    79ac:	47b8      	blx	r7
    79ae:	3001      	adds	r0, #1
    79b0:	f43f ae9d 	beq.w	76ee <_printf_float+0xb6>
    79b4:	9b08      	ldr	r3, [sp, #32]
    79b6:	432b      	orrs	r3, r5
    79b8:	d102      	bne.n	79c0 <_printf_float+0x388>
    79ba:	6823      	ldr	r3, [r4, #0]
    79bc:	07d9      	lsls	r1, r3, #31
    79be:	d5d9      	bpl.n	7974 <_printf_float+0x33c>
    79c0:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
    79c4:	4659      	mov	r1, fp
    79c6:	4630      	mov	r0, r6
    79c8:	47b8      	blx	r7
    79ca:	3001      	adds	r0, #1
    79cc:	f43f ae8f 	beq.w	76ee <_printf_float+0xb6>
    79d0:	f04f 0800 	mov.w	r8, #0
    79d4:	f104 0a1a 	add.w	sl, r4, #26
    79d8:	9b08      	ldr	r3, [sp, #32]
    79da:	425b      	negs	r3, r3
    79dc:	4543      	cmp	r3, r8
    79de:	dc01      	bgt.n	79e4 <_printf_float+0x3ac>
    79e0:	462b      	mov	r3, r5
    79e2:	e791      	b.n	7908 <_printf_float+0x2d0>
    79e4:	2301      	movs	r3, #1
    79e6:	4652      	mov	r2, sl
    79e8:	4659      	mov	r1, fp
    79ea:	4630      	mov	r0, r6
    79ec:	47b8      	blx	r7
    79ee:	3001      	adds	r0, #1
    79f0:	f43f ae7d 	beq.w	76ee <_printf_float+0xb6>
    79f4:	f108 0801 	add.w	r8, r8, #1
    79f8:	e7ee      	b.n	79d8 <_printf_float+0x3a0>
    79fa:	6da3      	ldr	r3, [r4, #88]	; 0x58
    79fc:	42ab      	cmp	r3, r5
    79fe:	bfa8      	it	ge
    7a00:	462b      	movge	r3, r5
    7a02:	2b00      	cmp	r3, #0
    7a04:	4698      	mov	r8, r3
    7a06:	dd06      	ble.n	7a16 <_printf_float+0x3de>
    7a08:	464a      	mov	r2, r9
    7a0a:	4659      	mov	r1, fp
    7a0c:	4630      	mov	r0, r6
    7a0e:	47b8      	blx	r7
    7a10:	3001      	adds	r0, #1
    7a12:	f43f ae6c 	beq.w	76ee <_printf_float+0xb6>
    7a16:	2300      	movs	r3, #0
    7a18:	9302      	str	r3, [sp, #8]
    7a1a:	f104 031a 	add.w	r3, r4, #26
    7a1e:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
    7a22:	9304      	str	r3, [sp, #16]
    7a24:	e00a      	b.n	7a3c <_printf_float+0x404>
    7a26:	2301      	movs	r3, #1
    7a28:	9a04      	ldr	r2, [sp, #16]
    7a2a:	4659      	mov	r1, fp
    7a2c:	4630      	mov	r0, r6
    7a2e:	47b8      	blx	r7
    7a30:	3001      	adds	r0, #1
    7a32:	f43f ae5c 	beq.w	76ee <_printf_float+0xb6>
    7a36:	9b02      	ldr	r3, [sp, #8]
    7a38:	3301      	adds	r3, #1
    7a3a:	9302      	str	r3, [sp, #8]
    7a3c:	f8d4 a058 	ldr.w	sl, [r4, #88]	; 0x58
    7a40:	9a02      	ldr	r2, [sp, #8]
    7a42:	ebaa 0308 	sub.w	r3, sl, r8
    7a46:	4293      	cmp	r3, r2
    7a48:	dced      	bgt.n	7a26 <_printf_float+0x3ee>
    7a4a:	9b08      	ldr	r3, [sp, #32]
    7a4c:	42ab      	cmp	r3, r5
    7a4e:	db1a      	blt.n	7a86 <_printf_float+0x44e>
    7a50:	6823      	ldr	r3, [r4, #0]
    7a52:	07da      	lsls	r2, r3, #31
    7a54:	d417      	bmi.n	7a86 <_printf_float+0x44e>
    7a56:	9b08      	ldr	r3, [sp, #32]
    7a58:	459a      	cmp	sl, r3
    7a5a:	db1c      	blt.n	7a96 <_printf_float+0x45e>
    7a5c:	eba5 080a 	sub.w	r8, r5, sl
    7a60:	f1b8 0f00 	cmp.w	r8, #0
    7a64:	dd08      	ble.n	7a78 <_printf_float+0x440>
    7a66:	4643      	mov	r3, r8
    7a68:	eb09 020a 	add.w	r2, r9, sl
    7a6c:	4659      	mov	r1, fp
    7a6e:	4630      	mov	r0, r6
    7a70:	47b8      	blx	r7
    7a72:	3001      	adds	r0, #1
    7a74:	f43f ae3b 	beq.w	76ee <_printf_float+0xb6>
    7a78:	f04f 0900 	mov.w	r9, #0
    7a7c:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
    7a80:	f104 0a1a 	add.w	sl, r4, #26
    7a84:	e014      	b.n	7ab0 <_printf_float+0x478>
    7a86:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
    7a8a:	4659      	mov	r1, fp
    7a8c:	4630      	mov	r0, r6
    7a8e:	47b8      	blx	r7
    7a90:	3001      	adds	r0, #1
    7a92:	d1e0      	bne.n	7a56 <_printf_float+0x41e>
    7a94:	e62b      	b.n	76ee <_printf_float+0xb6>
    7a96:	eba5 0803 	sub.w	r8, r5, r3
    7a9a:	e7e1      	b.n	7a60 <_printf_float+0x428>
    7a9c:	2301      	movs	r3, #1
    7a9e:	4652      	mov	r2, sl
    7aa0:	4659      	mov	r1, fp
    7aa2:	4630      	mov	r0, r6
    7aa4:	47b8      	blx	r7
    7aa6:	3001      	adds	r0, #1
    7aa8:	f43f ae21 	beq.w	76ee <_printf_float+0xb6>
    7aac:	f109 0901 	add.w	r9, r9, #1
    7ab0:	9b08      	ldr	r3, [sp, #32]
    7ab2:	1aeb      	subs	r3, r5, r3
    7ab4:	eba3 0308 	sub.w	r3, r3, r8
    7ab8:	454b      	cmp	r3, r9
    7aba:	dcef      	bgt.n	7a9c <_printf_float+0x464>
    7abc:	e75a      	b.n	7974 <_printf_float+0x33c>
    7abe:	2d01      	cmp	r5, #1
    7ac0:	dc01      	bgt.n	7ac6 <_printf_float+0x48e>
    7ac2:	07db      	lsls	r3, r3, #31
    7ac4:	d535      	bpl.n	7b32 <_printf_float+0x4fa>
    7ac6:	2301      	movs	r3, #1
    7ac8:	464a      	mov	r2, r9
    7aca:	4659      	mov	r1, fp
    7acc:	4630      	mov	r0, r6
    7ace:	47b8      	blx	r7
    7ad0:	3001      	adds	r0, #1
    7ad2:	f43f ae0c 	beq.w	76ee <_printf_float+0xb6>
    7ad6:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
    7ada:	4659      	mov	r1, fp
    7adc:	4630      	mov	r0, r6
    7ade:	47b8      	blx	r7
    7ae0:	3001      	adds	r0, #1
    7ae2:	f43f ae04 	beq.w	76ee <_printf_float+0xb6>
    7ae6:	2200      	movs	r2, #0
    7ae8:	2300      	movs	r3, #0
    7aea:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
    7aee:	3d01      	subs	r5, #1
    7af0:	f00b fdee 	bl	136d0 <__aeabi_dcmpeq>
    7af4:	b9c0      	cbnz	r0, 7b28 <_printf_float+0x4f0>
    7af6:	462b      	mov	r3, r5
    7af8:	f109 0201 	add.w	r2, r9, #1
    7afc:	4659      	mov	r1, fp
    7afe:	4630      	mov	r0, r6
    7b00:	47b8      	blx	r7
    7b02:	3001      	adds	r0, #1
    7b04:	d10c      	bne.n	7b20 <_printf_float+0x4e8>
    7b06:	e5f2      	b.n	76ee <_printf_float+0xb6>
    7b08:	2301      	movs	r3, #1
    7b0a:	4652      	mov	r2, sl
    7b0c:	4659      	mov	r1, fp
    7b0e:	4630      	mov	r0, r6
    7b10:	47b8      	blx	r7
    7b12:	3001      	adds	r0, #1
    7b14:	f43f adeb 	beq.w	76ee <_printf_float+0xb6>
    7b18:	f109 0901 	add.w	r9, r9, #1
    7b1c:	454d      	cmp	r5, r9
    7b1e:	dcf3      	bgt.n	7b08 <_printf_float+0x4d0>
    7b20:	4643      	mov	r3, r8
    7b22:	f104 0250 	add.w	r2, r4, #80	; 0x50
    7b26:	e6f0      	b.n	790a <_printf_float+0x2d2>
    7b28:	f04f 0900 	mov.w	r9, #0
    7b2c:	f104 0a1a 	add.w	sl, r4, #26
    7b30:	e7f4      	b.n	7b1c <_printf_float+0x4e4>
    7b32:	2301      	movs	r3, #1
    7b34:	464a      	mov	r2, r9
    7b36:	e7e1      	b.n	7afc <_printf_float+0x4c4>
    7b38:	2301      	movs	r3, #1
    7b3a:	4642      	mov	r2, r8
    7b3c:	4659      	mov	r1, fp
    7b3e:	4630      	mov	r0, r6
    7b40:	47b8      	blx	r7
    7b42:	3001      	adds	r0, #1
    7b44:	f43f add3 	beq.w	76ee <_printf_float+0xb6>
    7b48:	3501      	adds	r5, #1
    7b4a:	68e3      	ldr	r3, [r4, #12]
    7b4c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    7b4e:	1a9b      	subs	r3, r3, r2
    7b50:	42ab      	cmp	r3, r5
    7b52:	dcf1      	bgt.n	7b38 <_printf_float+0x500>
    7b54:	e712      	b.n	797c <_printf_float+0x344>
    7b56:	2500      	movs	r5, #0
    7b58:	f104 0819 	add.w	r8, r4, #25
    7b5c:	e7f5      	b.n	7b4a <_printf_float+0x512>
    7b5e:	bf00      	nop
    7b60:	000219d6 	.word	0x000219d6

Disassembly of section .text._Command_DNS_Service%199:

00007b64 <_Command_DNS_Service>:
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Failed to %s %s\r\n", msgFail, argv[0]);
    }
    return true;
}
static int _Command_DNS_Service(SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char** argv)
{
    7b64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7b68:	b0c3      	sub	sp, #268	; 0x10c
    7b6a:	4605      	mov	r5, r0
    7b6c:	4688      	mov	r8, r1
    7b6e:	4691      	mov	r9, r2
    uint8_t             *hostName;
    const void* cmdIoParam = pCmdIO->cmdIoParam;
    7b70:	6846      	ldr	r6, [r0, #4]
    TCPIP_DNS_RESULT res;
    DNS_SERVICE_COMD_TYPE val=DNS_SERVICE_COMD_NONE;
    DNSS_COMMAND_MAP dnssComnd[]=
    7b72:	ac38      	add	r4, sp, #224	; 0xe0
    7b74:	4fa0      	ldr	r7, [pc, #640]	; (7df8 <_Command_DNS_Service+0x294>)
    7b76:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    7b78:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    7b7a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    7b7c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    7b7e:	e897 0003 	ldmia.w	r7, {r0, r1}
    7b82:	e884 0003 	stmia.w	r4, {r0, r1}
                {"off",         DNS_SERVICE_COMD_ENABLE_INTF},
                {"lookup",      DNS_SERVICE_COMD_LOOKUP},
            };
    int i=0;

    if (argc < 2) {
    7b86:	f1b8 0f01 	cmp.w	r8, #1
    7b8a:	dd16      	ble.n	7bba <_Command_DNS_Service+0x56>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: dnsc <del/info/on/off/lookup> \r\n");
        return false;
    }
    for(i=0;i<(sizeof(dnssComnd)/sizeof(DNSS_COMMAND_MAP));i++)
    {
        if(strcmp(argv[1],dnssComnd[i].command) ==0)
    7b8c:	f8d9 a004 	ldr.w	sl, [r9, #4]
    for(i=0;i<(sizeof(dnssComnd)/sizeof(DNSS_COMMAND_MAP));i++)
    7b90:	2700      	movs	r7, #0
        if(strcmp(argv[1],dnssComnd[i].command) ==0)
    7b92:	f10d 0be0 	add.w	fp, sp, #224	; 0xe0
    7b96:	f85b 1037 	ldr.w	r1, [fp, r7, lsl #3]
    7b9a:	4650      	mov	r0, sl
    7b9c:	f019 feae 	bl	218fc <strcmp>
    7ba0:	4604      	mov	r4, r0
    7ba2:	b1a8      	cbz	r0, 7bd0 <_Command_DNS_Service+0x6c>
    for(i=0;i<(sizeof(dnssComnd)/sizeof(DNSS_COMMAND_MAP));i++)
    7ba4:	3701      	adds	r7, #1
    7ba6:	2f05      	cmp	r7, #5
    7ba8:	d1f5      	bne.n	7b96 <_Command_DNS_Service+0x32>
            break;
        case DNS_SERVICE_COMD_INFO:
            _Command_ShowDNSResolvedInfo(pCmdIO,argc,argv);
            break;
        default:
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Invalid Input Command :[ %s ] \r\n", argv[1]);
    7baa:	682b      	ldr	r3, [r5, #0]
    7bac:	685b      	ldr	r3, [r3, #4]
    7bae:	4652      	mov	r2, sl
    7bb0:	4992      	ldr	r1, [pc, #584]	; (7dfc <_Command_DNS_Service+0x298>)
    7bb2:	4630      	mov	r0, r6
    7bb4:	4798      	blx	r3
            return false;
    7bb6:	2400      	movs	r4, #0
    7bb8:	e006      	b.n	7bc8 <_Command_DNS_Service+0x64>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: dnsc <del/info/on/off/lookup> \r\n");
    7bba:	682b      	ldr	r3, [r5, #0]
    7bbc:	681b      	ldr	r3, [r3, #0]
    7bbe:	f107 0108 	add.w	r1, r7, #8
    7bc2:	4630      	mov	r0, r6
    7bc4:	4798      	blx	r3
        return false;
    7bc6:	2400      	movs	r4, #0
    }
    return true;
}
    7bc8:	4620      	mov	r0, r4
    7bca:	b043      	add	sp, #268	; 0x10c
    7bcc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            val = dnssComnd[i].val;
    7bd0:	ab42      	add	r3, sp, #264	; 0x108
    7bd2:	eb03 07c7 	add.w	r7, r3, r7, lsl #3
    switch(val)
    7bd6:	f817 3c24 	ldrb.w	r3, [r7, #-36]
    7bda:	3b01      	subs	r3, #1
    7bdc:	2b03      	cmp	r3, #3
    7bde:	d8e4      	bhi.n	7baa <_Command_DNS_Service+0x46>
    7be0:	e8df f013 	tbh	[pc, r3, lsl #1]
    7be4:	016a00f3 	.word	0x016a00f3
    7be8:	00680004 	.word	0x00680004
    if (argc < 3)
    7bec:	f1b8 0f02 	cmp.w	r8, #2
    7bf0:	dc12      	bgt.n	7c18 <_Command_DNS_Service+0xb4>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Usage: %s <on/off> <interface> <strict/pref>/<clear> \r\n", argv[0]);
    7bf2:	4c83      	ldr	r4, [pc, #524]	; (7e00 <_Command_DNS_Service+0x29c>)
    7bf4:	682b      	ldr	r3, [r5, #0]
    7bf6:	685b      	ldr	r3, [r3, #4]
    7bf8:	f8d9 2000 	ldr.w	r2, [r9]
    7bfc:	f504 7134 	add.w	r1, r4, #720	; 0x2d0
    7c00:	4630      	mov	r0, r6
    7c02:	4798      	blx	r3
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Ex: %s on eth0\r\n", argv[0]);
    7c04:	682b      	ldr	r3, [r5, #0]
    7c06:	685b      	ldr	r3, [r3, #4]
    7c08:	f8d9 2000 	ldr.w	r2, [r9]
    7c0c:	f504 7142 	add.w	r1, r4, #776	; 0x308
    7c10:	4630      	mov	r0, r6
    7c12:	4798      	blx	r3
    return true;
    7c14:	2401      	movs	r4, #1
    7c16:	e7d7      	b.n	7bc8 <_Command_DNS_Service+0x64>
    netH = TCPIP_STACK_NetHandleGet(argv[2]);
    7c18:	f8d9 0008 	ldr.w	r0, [r9, #8]
    7c1c:	f015 fe9a 	bl	1d954 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
    7c20:	4607      	mov	r7, r0
    7c22:	b1e8      	cbz	r0, 7c60 <_Command_DNS_Service+0xfc>
    if (memcmp(argv[1], "on", 2) == 0)
    7c24:	f8d9 4004 	ldr.w	r4, [r9, #4]
    7c28:	2202      	movs	r2, #2
    7c2a:	4976      	ldr	r1, [pc, #472]	; (7e04 <_Command_DNS_Service+0x2a0>)
    7c2c:	4620      	mov	r0, r4
    7c2e:	f019 fa09 	bl	21044 <memcmp>
    7c32:	b9e0      	cbnz	r0, 7c6e <_Command_DNS_Service+0x10a>
        if(argc > 3)
    7c34:	f1b8 0f03 	cmp.w	r8, #3
    7c38:	f340 81ed 	ble.w	8016 <_Command_DNS_Service+0x4b2>
            if(strcmp(argv[3], "strict") == 0)
    7c3c:	f8d9 400c 	ldr.w	r4, [r9, #12]
    7c40:	4971      	ldr	r1, [pc, #452]	; (7e08 <_Command_DNS_Service+0x2a4>)
    7c42:	4620      	mov	r0, r4
    7c44:	f019 fe5a 	bl	218fc <strcmp>
    7c48:	2800      	cmp	r0, #0
    7c4a:	f000 81f9 	beq.w	8040 <_Command_DNS_Service+0x4dc>
            else if(strcmp(argv[3], "pref") == 0)
    7c4e:	496f      	ldr	r1, [pc, #444]	; (7e0c <_Command_DNS_Service+0x2a8>)
    7c50:	4620      	mov	r0, r4
    7c52:	f019 fe53 	bl	218fc <strcmp>
    7c56:	2800      	cmp	r0, #0
                enableFlags = TCPIP_DNS_ENABLE_PREFERRED;
    7c58:	bf14      	ite	ne
    7c5a:	2100      	movne	r1, #0
    7c5c:	2102      	moveq	r1, #2
    7c5e:	e1db      	b.n	8018 <_Command_DNS_Service+0x4b4>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface\r\n");
    7c60:	682b      	ldr	r3, [r5, #0]
    7c62:	681b      	ldr	r3, [r3, #0]
    7c64:	496a      	ldr	r1, [pc, #424]	; (7e10 <_Command_DNS_Service+0x2ac>)
    7c66:	4630      	mov	r0, r6
    7c68:	4798      	blx	r3
    return true;
    7c6a:	2401      	movs	r4, #1
    7c6c:	e7ac      	b.n	7bc8 <_Command_DNS_Service+0x64>
    else if (memcmp(argv[1], "off", 2) == 0)
    7c6e:	2202      	movs	r2, #2
    7c70:	4968      	ldr	r1, [pc, #416]	; (7e14 <_Command_DNS_Service+0x2b0>)
    7c72:	4620      	mov	r0, r4
    7c74:	f019 f9e6 	bl	21044 <memcmp>
    7c78:	b960      	cbnz	r0, 7c94 <_Command_DNS_Service+0x130>
        if(argc > 3)
    7c7a:	f1b8 0f03 	cmp.w	r8, #3
    7c7e:	f340 81e1 	ble.w	8044 <_Command_DNS_Service+0x4e0>
            if(strcmp(argv[3], "clear") == 0)
    7c82:	4965      	ldr	r1, [pc, #404]	; (7e18 <_Command_DNS_Service+0x2b4>)
    7c84:	f8d9 000c 	ldr.w	r0, [r9, #12]
    7c88:	f019 fe38 	bl	218fc <strcmp>
    7c8c:	fab0 f180 	clz	r1, r0
    7c90:	0949      	lsrs	r1, r1, #5
    7c92:	e1d8      	b.n	8046 <_Command_DNS_Service+0x4e2>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown option\r\n");
    7c94:	682b      	ldr	r3, [r5, #0]
    7c96:	681b      	ldr	r3, [r3, #0]
    7c98:	4960      	ldr	r1, [pc, #384]	; (7e1c <_Command_DNS_Service+0x2b8>)
    7c9a:	4630      	mov	r0, r6
    7c9c:	4798      	blx	r3
    return true;
    7c9e:	2401      	movs	r4, #1
    7ca0:	e792      	b.n	7bc8 <_Command_DNS_Service+0x64>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Failed to %s %s\r\n", msgFail, argv[0]);
    7ca2:	682b      	ldr	r3, [r5, #0]
    7ca4:	685c      	ldr	r4, [r3, #4]
    7ca6:	f8d9 3000 	ldr.w	r3, [r9]
    7caa:	495d      	ldr	r1, [pc, #372]	; (7e20 <_Command_DNS_Service+0x2bc>)
    7cac:	4630      	mov	r0, r6
    7cae:	47a0      	blx	r4
    return true;
    7cb0:	2401      	movs	r4, #1
    7cb2:	e789      	b.n	7bc8 <_Command_DNS_Service+0x64>
            if (argc != 4) {
    7cb4:	f1b8 0f04 	cmp.w	r8, #4
    7cb8:	d01f      	beq.n	7cfa <_Command_DNS_Service+0x196>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: dnsc lookup <type> <hostName> \r\n");
    7cba:	4f51      	ldr	r7, [pc, #324]	; (7e00 <_Command_DNS_Service+0x29c>)
    7cbc:	682b      	ldr	r3, [r5, #0]
    7cbe:	681b      	ldr	r3, [r3, #0]
    7cc0:	f507 714d 	add.w	r1, r7, #820	; 0x334
    7cc4:	4630      	mov	r0, r6
    7cc6:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: <hostName>(URL) - look up for hostname\r\n");
    7cc8:	682b      	ldr	r3, [r5, #0]
    7cca:	681b      	ldr	r3, [r3, #0]
    7ccc:	f507 7157 	add.w	r1, r7, #860	; 0x35c
    7cd0:	4630      	mov	r0, r6
    7cd2:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: <type> : a or A for IPv4 address lookup\r\n");
    7cd4:	682b      	ldr	r3, [r5, #0]
    7cd6:	681b      	ldr	r3, [r3, #0]
    7cd8:	f507 7163 	add.w	r1, r7, #908	; 0x38c
    7cdc:	4630      	mov	r0, r6
    7cde:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: <type> : aaaa or AAAA for IPv6 address lookup\r\n");
    7ce0:	682b      	ldr	r3, [r5, #0]
    7ce2:	681b      	ldr	r3, [r3, #0]
    7ce4:	f507 716f 	add.w	r1, r7, #956	; 0x3bc
    7ce8:	4630      	mov	r0, r6
    7cea:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: <type> : any for both IPv4 and IPv6 address lookup\r\n");
    7cec:	682b      	ldr	r3, [r5, #0]
    7cee:	681b      	ldr	r3, [r3, #0]
    7cf0:	f507 717d 	add.w	r1, r7, #1012	; 0x3f4
    7cf4:	4630      	mov	r0, r6
    7cf6:	4798      	blx	r3
                return false;
    7cf8:	e766      	b.n	7bc8 <_Command_DNS_Service+0x64>


static int _Command_DNSLookUP(SYS_CMD_DEVICE_NODE* pCmdIO, char** argv)
{
    if(tcpipCmdStat != TCPIP_CMD_STAT_IDLE)
    7cfa:	4b4a      	ldr	r3, [pc, #296]	; (7e24 <_Command_DNS_Service+0x2c0>)
    7cfc:	781b      	ldrb	r3, [r3, #0]
    7cfe:	b9e3      	cbnz	r3, 7d3a <_Command_DNS_Service+0x1d6>
    {
        (*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, "dnsc lookup: command in progress. Retry later.\r\n");
        return true;
    }

    if((strcmp(argv[2], "A") == 0) || (strcmp(argv[2], "a") == 0))
    7d00:	f8d9 4008 	ldr.w	r4, [r9, #8]
    7d04:	4948      	ldr	r1, [pc, #288]	; (7e28 <_Command_DNS_Service+0x2c4>)
    7d06:	4620      	mov	r0, r4
    7d08:	f019 fdf8 	bl	218fc <strcmp>
    7d0c:	b120      	cbz	r0, 7d18 <_Command_DNS_Service+0x1b4>
    7d0e:	4947      	ldr	r1, [pc, #284]	; (7e2c <_Command_DNS_Service+0x2c8>)
    7d10:	4620      	mov	r0, r4
    7d12:	f019 fdf3 	bl	218fc <strcmp>
    7d16:	b9b8      	cbnz	r0, 7d48 <_Command_DNS_Service+0x1e4>
    {
        dnsType=TCPIP_DNS_TYPE_A;
    7d18:	4b45      	ldr	r3, [pc, #276]	; (7e30 <_Command_DNS_Service+0x2cc>)
    7d1a:	2201      	movs	r2, #1
    7d1c:	701a      	strb	r2, [r3, #0]
    {
        (*pCmdIO->pCmdApi->print)(pCmdIO->cmdIoParam, "dnsc lookup: [%s] Lookup Type not supported.\r\n",argv[2]);
        return true;
    }

    if(strlen(argv[3]) > sizeof(dnslookupTargetHost) - 1)
    7d1e:	f8d9 400c 	ldr.w	r4, [r9, #12]
    7d22:	4620      	mov	r0, r4
    7d24:	f019 ff3a 	bl	21b9c <strlen>
    7d28:	281e      	cmp	r0, #30
    7d2a:	d931      	bls.n	7d90 <_Command_DNS_Service+0x22c>
    {
        (*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, "dnsc lookup: Host name too long. Retry.\r\n");
    7d2c:	682b      	ldr	r3, [r5, #0]
    7d2e:	681b      	ldr	r3, [r3, #0]
    7d30:	4940      	ldr	r1, [pc, #256]	; (7e34 <_Command_DNS_Service+0x2d0>)
    7d32:	4630      	mov	r0, r6
    7d34:	4798      	blx	r3
    return true;
    7d36:	2401      	movs	r4, #1
    7d38:	e746      	b.n	7bc8 <_Command_DNS_Service+0x64>
        (*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, "dnsc lookup: command in progress. Retry later.\r\n");
    7d3a:	682b      	ldr	r3, [r5, #0]
    7d3c:	681b      	ldr	r3, [r3, #0]
    7d3e:	493e      	ldr	r1, [pc, #248]	; (7e38 <_Command_DNS_Service+0x2d4>)
    7d40:	4630      	mov	r0, r6
    7d42:	4798      	blx	r3
    return true;
    7d44:	2401      	movs	r4, #1
    7d46:	e73f      	b.n	7bc8 <_Command_DNS_Service+0x64>
    else if((strcmp(argv[2], "AAAA") == 0) || (strcmp(argv[2], "aaaa") == 0))
    7d48:	493c      	ldr	r1, [pc, #240]	; (7e3c <_Command_DNS_Service+0x2d8>)
    7d4a:	4620      	mov	r0, r4
    7d4c:	f019 fdd6 	bl	218fc <strcmp>
    7d50:	b120      	cbz	r0, 7d5c <_Command_DNS_Service+0x1f8>
    7d52:	493b      	ldr	r1, [pc, #236]	; (7e40 <_Command_DNS_Service+0x2dc>)
    7d54:	4620      	mov	r0, r4
    7d56:	f019 fdd1 	bl	218fc <strcmp>
    7d5a:	b918      	cbnz	r0, 7d64 <_Command_DNS_Service+0x200>
        dnsType=TCPIP_DNS_TYPE_AAAA;
    7d5c:	4b34      	ldr	r3, [pc, #208]	; (7e30 <_Command_DNS_Service+0x2cc>)
    7d5e:	221c      	movs	r2, #28
    7d60:	701a      	strb	r2, [r3, #0]
    7d62:	e7dc      	b.n	7d1e <_Command_DNS_Service+0x1ba>
    else if((strcmp(argv[2], "ANY") == 0) || (strcmp(argv[2], "any") == 0))
    7d64:	4937      	ldr	r1, [pc, #220]	; (7e44 <_Command_DNS_Service+0x2e0>)
    7d66:	4620      	mov	r0, r4
    7d68:	f019 fdc8 	bl	218fc <strcmp>
    7d6c:	b120      	cbz	r0, 7d78 <_Command_DNS_Service+0x214>
    7d6e:	4936      	ldr	r1, [pc, #216]	; (7e48 <_Command_DNS_Service+0x2e4>)
    7d70:	4620      	mov	r0, r4
    7d72:	f019 fdc3 	bl	218fc <strcmp>
    7d76:	b918      	cbnz	r0, 7d80 <_Command_DNS_Service+0x21c>
        dnsType=TCPIP_DNS_TYPE_ANY;
    7d78:	4b2d      	ldr	r3, [pc, #180]	; (7e30 <_Command_DNS_Service+0x2cc>)
    7d7a:	22ff      	movs	r2, #255	; 0xff
    7d7c:	701a      	strb	r2, [r3, #0]
    7d7e:	e7ce      	b.n	7d1e <_Command_DNS_Service+0x1ba>
        (*pCmdIO->pCmdApi->print)(pCmdIO->cmdIoParam, "dnsc lookup: [%s] Lookup Type not supported.\r\n",argv[2]);
    7d80:	682b      	ldr	r3, [r5, #0]
    7d82:	685b      	ldr	r3, [r3, #4]
    7d84:	4622      	mov	r2, r4
    7d86:	4931      	ldr	r1, [pc, #196]	; (7e4c <_Command_DNS_Service+0x2e8>)
    7d88:	4630      	mov	r0, r6
    7d8a:	4798      	blx	r3
    return true;
    7d8c:	2401      	movs	r4, #1
    7d8e:	e71b      	b.n	7bc8 <_Command_DNS_Service+0x64>
        return true;
    }
    strcpy(dnslookupTargetHost, argv[3]);
    7d90:	4e2f      	ldr	r6, [pc, #188]	; (7e50 <_Command_DNS_Service+0x2ec>)
    7d92:	4621      	mov	r1, r4
    7d94:	4630      	mov	r0, r6
    7d96:	f019 fef9 	bl	21b8c <strcpy>

    dnsLookupCmdIoParam = pCmdIO->cmdIoParam;
    7d9a:	686a      	ldr	r2, [r5, #4]
    7d9c:	4b2d      	ldr	r3, [pc, #180]	; (7e54 <_Command_DNS_Service+0x2f0>)
    7d9e:	601a      	str	r2, [r3, #0]
    (*pCmdIO->pCmdApi->print)(pCmdIO, "dnsc lookup: resolving host: %s for type:%s \r\n", dnslookupTargetHost,argv[2]);
    7da0:	682b      	ldr	r3, [r5, #0]
    7da2:	685c      	ldr	r4, [r3, #4]
    7da4:	f8d9 3008 	ldr.w	r3, [r9, #8]
    7da8:	4632      	mov	r2, r6
    7daa:	492b      	ldr	r1, [pc, #172]	; (7e58 <_Command_DNS_Service+0x2f4>)
    7dac:	4628      	mov	r0, r5
    7dae:	47a0      	blx	r4
    tcpipCmdStat = TCPIP_DNS_LOOKUP_CMD_GET;
    7db0:	4b1c      	ldr	r3, [pc, #112]	; (7e24 <_Command_DNS_Service+0x2c0>)
    7db2:	2208      	movs	r2, #8
    7db4:	701a      	strb	r2, [r3, #0]
    pTcpipCmdDevice = pCmdIO;
    7db6:	4b29      	ldr	r3, [pc, #164]	; (7e5c <_Command_DNS_Service+0x2f8>)
    7db8:	601d      	str	r5, [r3, #0]
    _TCPIPStackSignalHandlerSetParams(TCPIP_THIS_MODULE_ID, tcpipCmdSignalHandle, TCPIP_DNS_CLIENT_TASK_PROCESS_RATE);
    7dba:	22c8      	movs	r2, #200	; 0xc8
    7dbc:	4b28      	ldr	r3, [pc, #160]	; (7e60 <_Command_DNS_Service+0x2fc>)
    7dbe:	6819      	ldr	r1, [r3, #0]
    7dc0:	201f      	movs	r0, #31
    7dc2:	f018 f87b 	bl	1febc <_TCPIPStackSignalHandlerSetParams>
    return true;
    7dc6:	2401      	movs	r4, #1
    7dc8:	e6fe      	b.n	7bc8 <_Command_DNS_Service+0x64>
            if (argc != 3) {
    7dca:	f1b8 0f03 	cmp.w	r8, #3
    7dce:	d049      	beq.n	7e64 <_Command_DNS_Service+0x300>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: dnsc del <hostName>|all \r\n");
    7dd0:	4f0b      	ldr	r7, [pc, #44]	; (7e00 <_Command_DNS_Service+0x29c>)
    7dd2:	682b      	ldr	r3, [r5, #0]
    7dd4:	681b      	ldr	r3, [r3, #0]
    7dd6:	f507 61a2 	add.w	r1, r7, #1296	; 0x510
    7dda:	4630      	mov	r0, r6
    7ddc:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: <hostName>(URL) - Remove the entry if exists \r\n");
    7dde:	682b      	ldr	r3, [r5, #0]
    7de0:	681b      	ldr	r3, [r3, #0]
    7de2:	f207 5134 	addw	r1, r7, #1332	; 0x534
    7de6:	4630      	mov	r0, r6
    7de8:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: all - Remove all the resolved entry \r\n");
    7dea:	682b      	ldr	r3, [r5, #0]
    7dec:	681b      	ldr	r3, [r3, #0]
    7dee:	f207 516c 	addw	r1, r7, #1388	; 0x56c
    7df2:	4630      	mov	r0, r6
    7df4:	4798      	blx	r3
                return false;
    7df6:	e6e7      	b.n	7bc8 <_Command_DNS_Service+0x64>
    7df8:	0000050c 	.word	0x0000050c
    7dfc:	000009c4 	.word	0x000009c4
    7e00:	0000028c 	.word	0x0000028c
    7e04:	000004b4 	.word	0x000004b4
    7e08:	000005a8 	.word	0x000005a8
    7e0c:	000005b0 	.word	0x000005b0
    7e10:	000004a0 	.word	0x000004a0
    7e14:	000004b8 	.word	0x000004b8
    7e18:	000005b8 	.word	0x000005b8
    7e1c:	000004bc 	.word	0x000004bc
    7e20:	000004d8 	.word	0x000004d8
    7e24:	2000e3af 	.word	0x2000e3af
    7e28:	000006f0 	.word	0x000006f0
    7e2c:	000006f4 	.word	0x000006f4
    7e30:	2000e515 	.word	0x2000e515
    7e34:	00000740 	.word	0x00000740
    7e38:	000006bc 	.word	0x000006bc
    7e3c:	000006f8 	.word	0x000006f8
    7e40:	00000700 	.word	0x00000700
    7e44:	00000708 	.word	0x00000708
    7e48:	0000070c 	.word	0x0000070c
    7e4c:	00000710 	.word	0x00000710
    7e50:	2000e370 	.word	0x2000e370
    7e54:	2000e5b8 	.word	0x2000e5b8
    7e58:	0000076c 	.word	0x0000076c
    7e5c:	2000e5e8 	.word	0x2000e5e8
    7e60:	2000e5ec 	.word	0x2000e5ec
            hostName = (uint8_t*)argv[2];
    7e64:	f8d9 7008 	ldr.w	r7, [r9, #8]
            if (hostName == 0)
    7e68:	b14f      	cbz	r7, 7e7e <_Command_DNS_Service+0x31a>
            if(strcmp((char*)hostName,(char*)"all")==0)
    7e6a:	497b      	ldr	r1, [pc, #492]	; (8058 <_Command_DNS_Service+0x4f4>)
    7e6c:	4638      	mov	r0, r7
    7e6e:	f019 fd45 	bl	218fc <strcmp>
    7e72:	4680      	mov	r8, r0
    7e74:	b948      	cbnz	r0, 7e8a <_Command_DNS_Service+0x326>
                TCPIP_DNS_RemoveAll();
    7e76:	f014 f839 	bl	1beec <TCPIP_DNS_RemoveAll>
                    return false;
    7e7a:	4644      	mov	r4, r8
    7e7c:	e6a4      	b.n	7bc8 <_Command_DNS_Service+0x64>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown option\r\n");
    7e7e:	682b      	ldr	r3, [r5, #0]
    7e80:	681b      	ldr	r3, [r3, #0]
    7e82:	4976      	ldr	r1, [pc, #472]	; (805c <_Command_DNS_Service+0x4f8>)
    7e84:	4630      	mov	r0, r6
    7e86:	4798      	blx	r3
                return false;
    7e88:	e69e      	b.n	7bc8 <_Command_DNS_Service+0x64>
                res = TCPIP_DNS_RemoveEntry((const char*)hostName);
    7e8a:	4638      	mov	r0, r7
    7e8c:	f015 fd22 	bl	1d8d4 <TCPIP_DNS_RemoveEntry>
            switch(res)
    7e90:	f110 0f06 	cmn.w	r0, #6
    7e94:	d00a      	beq.n	7eac <_Command_DNS_Service+0x348>
    7e96:	f1b0 3fff 	cmp.w	r0, #4294967295
    7e9a:	f47f ae95 	bne.w	7bc8 <_Command_DNS_Service+0x64>
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "[%s] not part of the DNS Cache entry \r\n",hostName);
    7e9e:	682b      	ldr	r3, [r5, #0]
    7ea0:	685b      	ldr	r3, [r3, #4]
    7ea2:	463a      	mov	r2, r7
    7ea4:	496e      	ldr	r1, [pc, #440]	; (8060 <_Command_DNS_Service+0x4fc>)
    7ea6:	4630      	mov	r0, r6
    7ea8:	4798      	blx	r3
                    return false;
    7eaa:	e68d      	b.n	7bc8 <_Command_DNS_Service+0x64>
                    (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Incomplete command \r\n");
    7eac:	682b      	ldr	r3, [r5, #0]
    7eae:	681b      	ldr	r3, [r3, #0]
    7eb0:	496c      	ldr	r1, [pc, #432]	; (8064 <_Command_DNS_Service+0x500>)
    7eb2:	4630      	mov	r0, r6
    7eb4:	4798      	blx	r3
                    return false;
    7eb6:	e687      	b.n	7bc8 <_Command_DNS_Service+0x64>
    bool entryPresent= false;
    IPV6_ADDR   ipv6Addr[TCPIP_DNS_CLIENT_CACHE_PER_IPV6_ADDRESS];
    char        addrPrintBuff[44];
    const char* strictName, *prefName;

    if (argc != 2) {
    7eb8:	f1b8 0f02 	cmp.w	r8, #2
    7ebc:	d00e      	beq.n	7edc <_Command_DNS_Service+0x378>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: dnsc info \r\n");
    7ebe:	4c6a      	ldr	r4, [pc, #424]	; (8068 <_Command_DNS_Service+0x504>)
    7ec0:	682b      	ldr	r3, [r5, #0]
    7ec2:	681b      	ldr	r3, [r3, #0]
    7ec4:	f504 61bc 	add.w	r1, r4, #1504	; 0x5e0
    7ec8:	4630      	mov	r0, r6
    7eca:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Help: display the DNS cache entry details \r\n");
    7ecc:	682b      	ldr	r3, [r5, #0]
    7ece:	681b      	ldr	r3, [r3, #0]
    7ed0:	f204 51f4 	addw	r1, r4, #1524	; 0x5f4
    7ed4:	4630      	mov	r0, r6
    7ed6:	4798      	blx	r3
    return true;
    7ed8:	2401      	movs	r4, #1
    7eda:	e675      	b.n	7bc8 <_Command_DNS_Service+0x64>
        return false;
    }


    dnsQuery.hostName = hostName;
    7edc:	ab27      	add	r3, sp, #156	; 0x9c
    7ede:	931b      	str	r3, [sp, #108]	; 0x6c
    dnsQuery.nameLen = sizeof(hostName);
    7ee0:	2341      	movs	r3, #65	; 0x41
    7ee2:	931c      	str	r3, [sp, #112]	; 0x70
    dnsQuery.ipv4Entry = ipv4Addr;
    7ee4:	ab0b      	add	r3, sp, #44	; 0x2c
    7ee6:	931d      	str	r3, [sp, #116]	; 0x74
    dnsQuery.nIPv4Entries = sizeof(ipv4Addr) / sizeof(*ipv4Addr);
    7ee8:	2305      	movs	r3, #5
    7eea:	931e      	str	r3, [sp, #120]	; 0x78

    dnsQuery.ipv6Entry = ipv6Addr;
    7eec:	ab02      	add	r3, sp, #8
    7eee:	931f      	str	r3, [sp, #124]	; 0x7c
    dnsQuery.nIPv6Entries = sizeof(ipv6Addr) / sizeof(*ipv6Addr);
    7ef0:	2301      	movs	r3, #1
    7ef2:	9320      	str	r3, [sp, #128]	; 0x80

    res = TCPIP_DNS_ClientInfoGet(&clientInfo);
    7ef4:	a806      	add	r0, sp, #24
    7ef6:	f016 fb15 	bl	1e524 <TCPIP_DNS_ClientInfoGet>
    if(res != TCPIP_DNS_RES_OK)
    7efa:	b128      	cbz	r0, 7f08 <_Command_DNS_Service+0x3a4>
    {
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "DNS Client is down!\r\n");
    7efc:	682b      	ldr	r3, [r5, #0]
    7efe:	681b      	ldr	r3, [r3, #0]
    7f00:	495a      	ldr	r1, [pc, #360]	; (806c <_Command_DNS_Service+0x508>)
    7f02:	4630      	mov	r0, r6
    7f04:	4798      	blx	r3
        return false;
    7f06:	e7e7      	b.n	7ed8 <_Command_DNS_Service+0x374>
    }

    strictName = TCPIP_STACK_NetNameGet(clientInfo.strictNet);
    7f08:	9806      	ldr	r0, [sp, #24]
    7f0a:	f01a f87e 	bl	2200a <TCPIP_STACK_NetNameGet>
    if(strictName == 0)
    {
        strictName = "none";
    7f0e:	2800      	cmp	r0, #0
    7f10:	4f57      	ldr	r7, [pc, #348]	; (8070 <_Command_DNS_Service+0x50c>)
    7f12:	bf18      	it	ne
    7f14:	4607      	movne	r7, r0
    }
    prefName = TCPIP_STACK_NetNameGet(clientInfo.prefNet);
    7f16:	9807      	ldr	r0, [sp, #28]
    7f18:	f01a f877 	bl	2200a <TCPIP_STACK_NetNameGet>
    if(prefName == 0)
    {
        prefName = "none";
    7f1c:	2800      	cmp	r0, #0
    7f1e:	4b54      	ldr	r3, [pc, #336]	; (8070 <_Command_DNS_Service+0x50c>)
    7f20:	bf18      	it	ne
    7f22:	4603      	movne	r3, r0
    }

    (*pCmdIO->pCmdApi->print)(cmdIoParam, "DNS Client IF - Strict: %s, Preferred: %s\r\n", strictName, prefName);
    7f24:	f8df 8140 	ldr.w	r8, [pc, #320]	; 8068 <_Command_DNS_Service+0x504>
    7f28:	682a      	ldr	r2, [r5, #0]
    7f2a:	f8d2 9004 	ldr.w	r9, [r2, #4]
    7f2e:	463a      	mov	r2, r7
    7f30:	f208 613c 	addw	r1, r8, #1596	; 0x63c
    7f34:	4630      	mov	r0, r6
    7f36:	47c8      	blx	r9
    (*pCmdIO->pCmdApi->print)(cmdIoParam, "DNS Client - time: %d, pending: %d, current: %d, total: %d\r\n", clientInfo.dnsTime, clientInfo.pendingEntries, clientInfo.currentEntries, clientInfo.totalEntries);
    7f38:	682b      	ldr	r3, [r5, #0]
    7f3a:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
    7f3e:	9201      	str	r2, [sp, #4]
    7f40:	f8bd 2026 	ldrh.w	r2, [sp, #38]	; 0x26
    7f44:	9200      	str	r2, [sp, #0]
    7f46:	685f      	ldr	r7, [r3, #4]
    7f48:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    7f4c:	9a08      	ldr	r2, [sp, #32]
    7f4e:	f508 61cd 	add.w	r1, r8, #1640	; 0x668
    7f52:	4630      	mov	r0, r6
    7f54:	47b8      	blx	r7

    index = 0;
    7f56:	46a0      	mov	r8, r4
    bool entryPresent= false;
    7f58:	2700      	movs	r7, #0
    {
        res = TCPIP_DNS_EntryQuery(&dnsQuery, index);
        if(res == TCPIP_DNS_RES_OK)
        {
            entryPresent = true;
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Hostname = %s \r\nTimeout = %d \r\n", hostName, dnsQuery.ttlTime);
    7f5a:	f8df 910c 	ldr.w	r9, [pc, #268]	; 8068 <_Command_DNS_Service+0x504>
    7f5e:	f509 6bd5 	add.w	fp, r9, #1704	; 0x6a8
        res = TCPIP_DNS_EntryQuery(&dnsQuery, index);
    7f62:	4641      	mov	r1, r8
    7f64:	a81b      	add	r0, sp, #108	; 0x6c
    7f66:	f009 facf 	bl	11508 <TCPIP_DNS_EntryQuery>
        if(res == TCPIP_DNS_RES_OK)
    7f6a:	2800      	cmp	r0, #0
    7f6c:	d144      	bne.n	7ff8 <_Command_DNS_Service+0x494>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Hostname = %s \r\nTimeout = %d \r\n", hostName, dnsQuery.ttlTime);
    7f6e:	682b      	ldr	r3, [r5, #0]
    7f70:	685f      	ldr	r7, [r3, #4]
    7f72:	9b22      	ldr	r3, [sp, #136]	; 0x88
    7f74:	aa27      	add	r2, sp, #156	; 0x9c
    7f76:	4659      	mov	r1, fp
    7f78:	4630      	mov	r0, r6
    7f7a:	47b8      	blx	r7
            if(dnsQuery.nIPv4ValidEntries > 0)
    7f7c:	9b25      	ldr	r3, [sp, #148]	; 0x94
    7f7e:	2b00      	cmp	r3, #0
    7f80:	dc0d      	bgt.n	7f9e <_Command_DNS_Service+0x43a>
                {                    
                    TCPIP_Helper_IPAddressToString(dnsQuery.ipv4Entry + ix, addrPrintBuff, sizeof(addrPrintBuff)); 
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv4 =%s\r\n", addrPrintBuff);
                }
            }
            if(dnsQuery.nIPv6Entries > 0)
    7f82:	9b20      	ldr	r3, [sp, #128]	; 0x80
    7f84:	2b00      	cmp	r3, #0
    7f86:	dc1f      	bgt.n	7fc8 <_Command_DNS_Service+0x464>
                {
                    TCPIP_Helper_IPv6AddressToString(dnsQuery.ipv6Entry + ix, addrPrintBuff, sizeof(addrPrintBuff));                   
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv6 = %s\r\n",addrPrintBuff);
                }
            }
            (*pCmdIO->pCmdApi->print)(cmdIoParam,"----------------------------------------------------\r\n",0);
    7f88:	682b      	ldr	r3, [r5, #0]
    7f8a:	685b      	ldr	r3, [r3, #4]
    7f8c:	2200      	movs	r2, #0
    7f8e:	f509 61dc 	add.w	r1, r9, #1760	; 0x6e0
    7f92:	4630      	mov	r0, r6
    7f94:	4798      	blx	r3
            entryPresent = true;
    7f96:	2701      	movs	r7, #1
        }
        if(res == TCPIP_DNS_RES_OK || res == TCPIP_DNS_RES_PENDING || res == TCPIP_DNS_RES_EMPTY_IX_ENTRY)
        {
            index++;
    7f98:	f108 0801 	add.w	r8, r8, #1
            continue;
    7f9c:	e7e1      	b.n	7f62 <_Command_DNS_Service+0x3fe>
                for(ix = 0; ix < dnsQuery.nIPv4ValidEntries; ix++)
    7f9e:	4627      	mov	r7, r4
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv4 =%s\r\n", addrPrintBuff);
    7fa0:	f509 6ad9 	add.w	sl, r9, #1736	; 0x6c8
                    TCPIP_Helper_IPAddressToString(dnsQuery.ipv4Entry + ix, addrPrintBuff, sizeof(addrPrintBuff)); 
    7fa4:	222c      	movs	r2, #44	; 0x2c
    7fa6:	a910      	add	r1, sp, #64	; 0x40
    7fa8:	981d      	ldr	r0, [sp, #116]	; 0x74
    7faa:	eb00 0087 	add.w	r0, r0, r7, lsl #2
    7fae:	f014 fbd9 	bl	1c764 <TCPIP_Helper_IPAddressToString>
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv4 =%s\r\n", addrPrintBuff);
    7fb2:	682b      	ldr	r3, [r5, #0]
    7fb4:	685b      	ldr	r3, [r3, #4]
    7fb6:	aa10      	add	r2, sp, #64	; 0x40
    7fb8:	4651      	mov	r1, sl
    7fba:	4630      	mov	r0, r6
    7fbc:	4798      	blx	r3
                for(ix = 0; ix < dnsQuery.nIPv4ValidEntries; ix++)
    7fbe:	3701      	adds	r7, #1
    7fc0:	9b25      	ldr	r3, [sp, #148]	; 0x94
    7fc2:	429f      	cmp	r7, r3
    7fc4:	dbee      	blt.n	7fa4 <_Command_DNS_Service+0x440>
    7fc6:	e7dc      	b.n	7f82 <_Command_DNS_Service+0x41e>
                for(ix = 0; ix < dnsQuery.nIPv6ValidEntries; ix++)
    7fc8:	9b26      	ldr	r3, [sp, #152]	; 0x98
    7fca:	2b00      	cmp	r3, #0
    7fcc:	dddc      	ble.n	7f88 <_Command_DNS_Service+0x424>
    7fce:	4627      	mov	r7, r4
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv6 = %s\r\n",addrPrintBuff);
    7fd0:	f209 6ad4 	addw	sl, r9, #1748	; 0x6d4
                    TCPIP_Helper_IPv6AddressToString(dnsQuery.ipv6Entry + ix, addrPrintBuff, sizeof(addrPrintBuff));                   
    7fd4:	222c      	movs	r2, #44	; 0x2c
    7fd6:	a910      	add	r1, sp, #64	; 0x40
    7fd8:	981f      	ldr	r0, [sp, #124]	; 0x7c
    7fda:	eb00 1007 	add.w	r0, r0, r7, lsl #4
    7fde:	f00f fa5c 	bl	1749a <TCPIP_Helper_IPv6AddressToString>
                    (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv6 = %s\r\n",addrPrintBuff);
    7fe2:	682b      	ldr	r3, [r5, #0]
    7fe4:	685b      	ldr	r3, [r3, #4]
    7fe6:	aa10      	add	r2, sp, #64	; 0x40
    7fe8:	4651      	mov	r1, sl
    7fea:	4630      	mov	r0, r6
    7fec:	4798      	blx	r3
                for(ix = 0; ix < dnsQuery.nIPv6ValidEntries; ix++)
    7fee:	3701      	adds	r7, #1
    7ff0:	9b26      	ldr	r3, [sp, #152]	; 0x98
    7ff2:	429f      	cmp	r7, r3
    7ff4:	dbee      	blt.n	7fd4 <_Command_DNS_Service+0x470>
    7ff6:	e7c7      	b.n	7f88 <_Command_DNS_Service+0x424>
        if(res == TCPIP_DNS_RES_OK || res == TCPIP_DNS_RES_PENDING || res == TCPIP_DNS_RES_EMPTY_IX_ENTRY)
    7ff8:	b2c2      	uxtb	r2, r0
    7ffa:	2a01      	cmp	r2, #1
    7ffc:	d9cc      	bls.n	7f98 <_Command_DNS_Service+0x434>
    7ffe:	f110 0f04 	cmn.w	r0, #4
    8002:	d0c9      	beq.n	7f98 <_Command_DNS_Service+0x434>
        }

        // some error
        if(entryPresent == false)
    8004:	2f00      	cmp	r7, #0
    8006:	f47f af67 	bne.w	7ed8 <_Command_DNS_Service+0x374>
        {
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "No DNS Client Cache entries \r\n");
    800a:	682b      	ldr	r3, [r5, #0]
    800c:	681b      	ldr	r3, [r3, #0]
    800e:	4919      	ldr	r1, [pc, #100]	; (8074 <_Command_DNS_Service+0x510>)
    8010:	4630      	mov	r0, r6
    8012:	4798      	blx	r3
    8014:	e760      	b.n	7ed8 <_Command_DNS_Service+0x374>
    TCPIP_DNS_ENABLE_FLAGS enableFlags = TCPIP_DNS_ENABLE_DEFAULT;
    8016:	2100      	movs	r1, #0
        addRes = TCPIP_DNS_Enable(netH, enableFlags);
    8018:	4638      	mov	r0, r7
    801a:	f019 ff67 	bl	21eec <TCPIP_DNS_Enable>
        msgFail = "enable";
    801e:	4b12      	ldr	r3, [pc, #72]	; (8068 <_Command_DNS_Service+0x504>)
    8020:	f503 72e8 	add.w	r2, r3, #464	; 0x1d0
        msgOK   = "enabled";
    8024:	f503 73e4 	add.w	r3, r3, #456	; 0x1c8
    if(addRes)
    8028:	2800      	cmp	r0, #0
    802a:	f43f ae3a 	beq.w	7ca2 <_Command_DNS_Service+0x13e>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "%s %s\r\n", argv[0], msgOK);
    802e:	682a      	ldr	r2, [r5, #0]
    8030:	6854      	ldr	r4, [r2, #4]
    8032:	f8d9 2000 	ldr.w	r2, [r9]
    8036:	4910      	ldr	r1, [pc, #64]	; (8078 <_Command_DNS_Service+0x514>)
    8038:	4630      	mov	r0, r6
    803a:	47a0      	blx	r4
    return true;
    803c:	2401      	movs	r4, #1
    803e:	e5c3      	b.n	7bc8 <_Command_DNS_Service+0x64>
                enableFlags = TCPIP_DNS_ENABLE_STRICT;
    8040:	2101      	movs	r1, #1
    8042:	e7e9      	b.n	8018 <_Command_DNS_Service+0x4b4>
    bool             clearCache = false;
    8044:	2100      	movs	r1, #0
        addRes = TCPIP_DNS_Disable(netH, clearCache);
    8046:	4638      	mov	r0, r7
    8048:	f012 faee 	bl	1a628 <TCPIP_DNS_Disable>
        msgFail = "disable";
    804c:	4b06      	ldr	r3, [pc, #24]	; (8068 <_Command_DNS_Service+0x504>)
    804e:	f503 72e0 	add.w	r2, r3, #448	; 0x1c0
        msgOK   = "disabled";
    8052:	f503 73da 	add.w	r3, r3, #436	; 0x1b4
    8056:	e7e7      	b.n	8028 <_Command_DNS_Service+0x4c4>
    8058:	00000828 	.word	0x00000828
    805c:	000004bc 	.word	0x000004bc
    8060:	0000082c 	.word	0x0000082c
    8064:	00000854 	.word	0x00000854
    8068:	0000028c 	.word	0x0000028c
    806c:	000008b0 	.word	0x000008b0
    8070:	00000504 	.word	0x00000504
    8074:	000009a4 	.word	0x000009a4
    8078:	000004d0 	.word	0x000004d0

Disassembly of section .text.TCPIP_DHCP_Task%200:

0000807c <TCPIP_DHCP_Task>:
    return false;
}


void TCPIP_DHCP_Task(void)
{
    807c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8080:	b087      	sub	sp, #28
    TCPIP_MODULE_SIGNAL sigPend;
    bool                isTmo = false;

    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    8082:	210f      	movs	r1, #15
    8084:	200c      	movs	r0, #12
    8086:	f015 ff71 	bl	1df6c <_TCPIPStackModuleSignalGet>

    if((sigPend & TCPIP_MODULE_SIGNAL_TMO) != 0)
    808a:	f010 0f02 	tst.w	r0, #2
    808e:	f040 822c 	bne.w	84ea <TCPIP_DHCP_Task+0x46e>
    { // regular TMO occurred
        isTmo = true;
    }

    if(isTmo || (sigPend & TCPIP_MODULE_SIGNAL_RX_PENDING) != 0)
    8092:	f010 0f01 	tst.w	r0, #1
    8096:	f000 8225 	beq.w	84e4 <TCPIP_DHCP_Task+0x468>
    if(isTmo)
    {   // update DHCP time keeping
        _DHCPSecondCountSet();
    }

    nNets = TCPIP_STACK_NumberOfNetworksGet();
    809a:	f019 ff33 	bl	21f04 <TCPIP_STACK_NumberOfNetworksGet>
    for(netIx = 0; netIx < nNets; netIx++) 
    809e:	f1b0 0900 	subs.w	r9, r0, #0
    80a2:	f340 821a 	ble.w	84da <TCPIP_DHCP_Task+0x45e>
    80a6:	2500      	movs	r5, #0
        if(!TCPIP_STACK_NetworkIsUp(pNetIf))
        {   // inactive interface
            continue;
        }

        pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf); 
    80a8:	f8df a3e8 	ldr.w	sl, [pc, #1000]	; 8494 <TCPIP_DHCP_Task+0x418>
    80ac:	f04f 0b5c 	mov.w	fp, #92	; 0x5c
    80b0:	e13d      	b.n	832e <TCPIP_DHCP_Task+0x2b2>
    {   // don't have a current lease
        if(pClient->flags.bReportFail && pClient->tOpStart != 0)
        {
            if((_DHCPSecondCountGet() - pClient->tOpStart) >= pClient->tOpFailTmo)
            {   // initialization time out
                TCPIP_STACK_AddressServiceEvent(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_DHCPC, TCPIP_STACK_ADDRESS_SERVICE_EVENT_RUN_FAIL);
    80b2:	2201      	movs	r2, #1
    80b4:	4611      	mov	r1, r2
    80b6:	4630      	mov	r0, r6
    80b8:	f015 f936 	bl	1d328 <TCPIP_STACK_AddressServiceEvent>
                _DHCPDbgAddServiceEvent(pClient, TCPIP_STACK_ADDRESS_SERVICE_EVENT_RUN_FAIL, "init tmo");
                pClient->flags.bReportFail = 0;   // reported
    80bc:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
    80c0:	f36f 1345 	bfc	r3, #5, #1
    80c4:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    80c8:	e15d      	b.n	8386 <TCPIP_DHCP_Task+0x30a>
                if(!TCPIP_STACK_NetworkIsLinked(pNetIf))
    80ca:	4630      	mov	r0, r6
    80cc:	f018 fdbc 	bl	20c48 <TCPIP_STACK_NetworkIsLinked>
    80d0:	2800      	cmp	r0, #0
    80d2:	f000 8128 	beq.w	8326 <TCPIP_DHCP_Task+0x2aa>
                if(pClient->dhcpOp == TCPIP_DHCP_OPER_INIT_REBOOT)
    80d6:	f8b4 3054 	ldrh.w	r3, [r4, #84]	; 0x54
    80da:	2b02      	cmp	r3, #2
    80dc:	d00d      	beq.n	80fa <TCPIP_DHCP_Task+0x7e>
                else if(pClient->dhcpOp == TCPIP_DHCP_OPER_RENEW)
    80de:	2b03      	cmp	r3, #3
    pClient->smState = newState;
    80e0:	bf0c      	ite	eq
    80e2:	2309      	moveq	r3, #9
    80e4:	2302      	movne	r3, #2
    80e6:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    if(pClient->dhcpFilterHandle != 0)
    80ea:	6ca0      	ldr	r0, [r4, #72]	; 0x48
    80ec:	2800      	cmp	r0, #0
    80ee:	f000 811a 	beq.w	8326 <TCPIP_DHCP_Task+0x2aa>
        Ipv4FilterSetActive(pClient->dhcpFilterHandle, active);
    80f2:	2101      	movs	r1, #1
    80f4:	f013 f874 	bl	1b1e0 <Ipv4FilterSetActive>
    80f8:	e115      	b.n	8326 <TCPIP_DHCP_Task+0x2aa>
    pClient->smState = newState;
    80fa:	2304      	movs	r3, #4
    80fc:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    8100:	e7f3      	b.n	80ea <TCPIP_DHCP_Task+0x6e>
                _DHCPSetLeaseTimeParams(pClient, 0);
    8102:	2100      	movs	r1, #0
    8104:	4620      	mov	r0, r4
    8106:	f010 fc11 	bl	1892c <_DHCPSetLeaseTimeParams>
                pClient->validValues.val = 0x00;
    810a:	2200      	movs	r2, #0
    810c:	f884 2059 	strb.w	r2, [r4, #89]	; 0x59
                pClient->flags.bIsBound = false;	
    8110:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
                pClient->flags.bOfferReceived = false;
    8114:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    8118:	f362 0382 	bfi	r3, r2, #2, #1
    811c:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
                pClient->serverAddress.Val = 0;
    8120:	62a2      	str	r2, [r4, #40]	; 0x28
                if(!_DHCPSend(pClient, pNetIf, TCPIP_DHCP_DISCOVER_MESSAGE, TCPIP_DHCP_FLAG_SEND_ZERO_ADD | TCPIP_DHCP_FLAG_SEND_BCAST))
    8122:	2303      	movs	r3, #3
    8124:	2201      	movs	r2, #1
    8126:	4631      	mov	r1, r6
    8128:	4620      	mov	r0, r4
    812a:	f007 fc4f 	bl	f9cc <_DHCPSend>
    812e:	2800      	cmp	r0, #0
    8130:	f000 80f9 	beq.w	8326 <TCPIP_DHCP_Task+0x2aa>
                _DHCPNotifyClients(pNetIf, DHCP_EVENT_DISCOVER);
    8134:	2101      	movs	r1, #1
    8136:	4630      	mov	r0, r6
    8138:	f015 fedc 	bl	1def4 <_DHCPNotifyClients>
                _DHCPSetTimeout(pClient);
    813c:	4620      	mov	r0, r4
    813e:	f017 f9e9 	bl	1f514 <_DHCPSetTimeout>
    pClient->smState = newState;
    8142:	2303      	movs	r3, #3
    8144:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    8148:	e0ed      	b.n	8326 <TCPIP_DHCP_Task+0x2aa>
                recvMsg = _DHCPProcessReceiveData(pClient, pNetIf);
    814a:	4631      	mov	r1, r6
    814c:	4620      	mov	r0, r4
    814e:	f00f f901 	bl	17354 <_DHCPProcessReceiveData>
                if(recvMsg == TCPIP_DHCP_TIMEOUT_MESSAGE)
    8152:	280a      	cmp	r0, #10
    8154:	d02a      	beq.n	81ac <TCPIP_DHCP_Task+0x130>
                else if(recvMsg != TCPIP_DHCP_UNKNOWN_MESSAGE)
    8156:	2800      	cmp	r0, #0
    8158:	f000 80e5 	beq.w	8326 <TCPIP_DHCP_Task+0x2aa>
                    pClient->flags.bDHCPServerDetected = true;
    815c:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
    8160:	f043 0308 	orr.w	r3, r3, #8
    8164:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
                if(recvMsg != TCPIP_DHCP_OFFER_MESSAGE)
    8168:	2802      	cmp	r0, #2
    816a:	f040 80dc 	bne.w	8326 <TCPIP_DHCP_Task+0x2aa>
    pClient->smState = newState;
    816e:	2304      	movs	r3, #4
    8170:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
                if(!_DHCPSend(pClient, pNetIf, TCPIP_DHCP_REQUEST_MESSAGE, (pClient->dhcpOp == TCPIP_DHCP_OPER_INIT_REBOOT) ? TCPIP_DHCP_FLAG_SEND_BCAST : TCPIP_DHCP_FLAG_SEND_ZERO_ADD | TCPIP_DHCP_FLAG_SEND_BCAST))
    8174:	f8b4 3054 	ldrh.w	r3, [r4, #84]	; 0x54
    8178:	2b02      	cmp	r3, #2
    817a:	9b01      	ldr	r3, [sp, #4]
    817c:	bf18      	it	ne
    817e:	2303      	movne	r3, #3
    8180:	2203      	movs	r2, #3
    8182:	4631      	mov	r1, r6
    8184:	4620      	mov	r0, r4
    8186:	f007 fc21 	bl	f9cc <_DHCPSend>
    818a:	2800      	cmp	r0, #0
    818c:	f000 80cb 	beq.w	8326 <TCPIP_DHCP_Task+0x2aa>
                pClient->tRequest = _DHCPSecondCountGet();
    8190:	4bbf      	ldr	r3, [pc, #764]	; (8490 <TCPIP_DHCP_Task+0x414>)
    8192:	681b      	ldr	r3, [r3, #0]
    8194:	60a3      	str	r3, [r4, #8]
                _DHCPNotifyClients(pNetIf, DHCP_EVENT_REQUEST);
    8196:	2102      	movs	r1, #2
    8198:	4630      	mov	r0, r6
    819a:	f015 feab 	bl	1def4 <_DHCPNotifyClients>
                _DHCPSetTimeout(pClient);
    819e:	4620      	mov	r0, r4
    81a0:	f017 f9b8 	bl	1f514 <_DHCPSetTimeout>
    pClient->smState = newState;
    81a4:	2305      	movs	r3, #5
    81a6:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    81aa:	e0bc      	b.n	8326 <TCPIP_DHCP_Task+0x2aa>
                    if((SYS_TMR_TickCountGet() - pClient->startWait) >= pClient->waitTicks)
    81ac:	f017 fefe 	bl	1ffac <SYS_TMR_TickCountGet>
    81b0:	6863      	ldr	r3, [r4, #4]
    81b2:	1ac3      	subs	r3, r0, r3
    81b4:	f858 2007 	ldr.w	r2, [r8, r7]
    81b8:	4293      	cmp	r3, r2
    81ba:	f0c0 80b4 	bcc.w	8326 <TCPIP_DHCP_Task+0x2aa>
                        _DHCPSetRunFail(pClient, TCPIP_DHCP_SEND_DISCOVERY, true);  
    81be:	2201      	movs	r2, #1
    81c0:	2102      	movs	r1, #2
    81c2:	4620      	mov	r0, r4
    81c4:	f014 faa8 	bl	1c718 <_DHCPSetRunFail>
                        _DHCPNotifyClients(pNetIf, DHCP_EVENT_TIMEOUT);
    81c8:	2107      	movs	r1, #7
    81ca:	4630      	mov	r0, r6
    81cc:	f015 fe92 	bl	1def4 <_DHCPNotifyClients>
    81d0:	e0a9      	b.n	8326 <TCPIP_DHCP_Task+0x2aa>
                if(_DHCPProcessReceiveData(pClient, pNetIf) == TCPIP_DHCP_TIMEOUT_MESSAGE)
    81d2:	4631      	mov	r1, r6
    81d4:	4620      	mov	r0, r4
    81d6:	f00f f8bd 	bl	17354 <_DHCPProcessReceiveData>
    81da:	280a      	cmp	r0, #10
    81dc:	f040 80a3 	bne.w	8326 <TCPIP_DHCP_Task+0x2aa>
                    if((SYS_TMR_TickCountGet() - pClient->startWait) >= pClient->waitTicks)
    81e0:	f017 fee4 	bl	1ffac <SYS_TMR_TickCountGet>
    81e4:	6863      	ldr	r3, [r4, #4]
    81e6:	1ac3      	subs	r3, r0, r3
    81e8:	f858 2007 	ldr.w	r2, [r8, r7]
    81ec:	4293      	cmp	r3, r2
    81ee:	f0c0 809a 	bcc.w	8326 <TCPIP_DHCP_Task+0x2aa>
                        _DHCPSetRunFail(pClient, TCPIP_DHCP_SEND_DISCOVERY, true);
    81f2:	2201      	movs	r2, #1
    81f4:	2102      	movs	r1, #2
    81f6:	4620      	mov	r0, r4
    81f8:	f014 fa8e 	bl	1c718 <_DHCPSetRunFail>
                        _DHCPNotifyClients(pNetIf, DHCP_EVENT_TIMEOUT);
    81fc:	2107      	movs	r1, #7
    81fe:	4630      	mov	r0, r6
    8200:	f015 fe78 	bl	1def4 <_DHCPNotifyClients>
    8204:	e08f      	b.n	8326 <TCPIP_DHCP_Task+0x2aa>
                    arpCheck.Val = pClient->dhcpIPAddress.Val;
    8206:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    8208:	9302      	str	r3, [sp, #8]
                    if(TCPIP_ARP_IsResolved(pNetIf, &arpCheck, 0))
    820a:	2200      	movs	r2, #0
    820c:	a902      	add	r1, sp, #8
    820e:	4630      	mov	r0, r6
    8210:	f00f ffa8 	bl	18164 <TCPIP_ARP_IsResolved>
    8214:	2800      	cmp	r0, #0
    8216:	f040 8177 	bne.w	8508 <TCPIP_DHCP_Task+0x48c>
                    else if((_DHCPSecondCountGet() - pClient->startWait) >= pClient->tLeaseCheck)
    821a:	4b9d      	ldr	r3, [pc, #628]	; (8490 <TCPIP_DHCP_Task+0x414>)
    821c:	681b      	ldr	r3, [r3, #0]
    821e:	6862      	ldr	r2, [r4, #4]
    8220:	1a9b      	subs	r3, r3, r2
    8222:	f8b4 2052 	ldrh.w	r2, [r4, #82]	; 0x52
    8226:	4293      	cmp	r3, r2
    8228:	d37d      	bcc.n	8326 <TCPIP_DHCP_Task+0x2aa>
    oldNetIp.Val = TCPIP_STACK_NetAddressGet(pNetIf);
    822a:	4630      	mov	r0, r6
    822c:	f019 f912 	bl	21454 <TCPIP_STACK_NetAddressGet>
    8230:	9003      	str	r0, [sp, #12]
    oldNetMask.Val = TCPIP_STACK_NetMaskGet(pNetIf);
    8232:	4630      	mov	r0, r6
    8234:	f019 f91a 	bl	2146c <TCPIP_STACK_NetMaskGet>
    8238:	9004      	str	r0, [sp, #16]
    _TCPIPStackSetConfigAddress(pNetIf, &pClient->dhcpIPAddress, &pClient->dhcpMask, false);
    823a:	f104 072c 	add.w	r7, r4, #44	; 0x2c
    823e:	2300      	movs	r3, #0
    8240:	f104 0234 	add.w	r2, r4, #52	; 0x34
    8244:	4639      	mov	r1, r7
    8246:	4630      	mov	r0, r6
    8248:	f016 fa9d 	bl	1e786 <_TCPIPStackSetConfigAddress>
    if(pClient->validValues.Gateway)
    824c:	f894 3059 	ldrb.w	r3, [r4, #89]	; 0x59
    8250:	f013 0f02 	tst.w	r3, #2
    8254:	d136      	bne.n	82c4 <TCPIP_DHCP_Task+0x248>
    if(pNetIf->Flags.bIsDNSServerAuto != 0)
    8256:	f896 3042 	ldrb.w	r3, [r6, #66]	; 0x42
    825a:	f013 0f20 	tst.w	r3, #32
    825e:	d011      	beq.n	8284 <TCPIP_DHCP_Task+0x208>
        if(pClient->validValues.DNS)
    8260:	f894 3059 	ldrb.w	r3, [r4, #89]	; 0x59
    8264:	f013 0f08 	tst.w	r3, #8
    8268:	d132      	bne.n	82d0 <TCPIP_DHCP_Task+0x254>
        if(pClient->validValues.DNS2)
    826a:	f894 3059 	ldrb.w	r3, [r4, #89]	; 0x59
    826e:	f013 0f10 	tst.w	r3, #16
            TCPIP_STACK_SecondaryDNSAddressSet(pNetIf, &pClient->dhcpDNS2);
    8272:	bf11      	iteee	ne
    8274:	f104 013c 	addne.w	r1, r4, #60	; 0x3c
            IPV4_ADDR zeroAdd = {0};
    8278:	2300      	moveq	r3, #0
    827a:	9305      	streq	r3, [sp, #20]
            TCPIP_STACK_SecondaryDNSAddressSet(pNetIf, &zeroAdd);
    827c:	a905      	addeq	r1, sp, #20
    827e:	4630      	mov	r0, r6
    8280:	f019 feeb 	bl	2205a <TCPIP_STACK_SecondaryDNSAddressSet>
    TCPIP_STACK_AddressServiceEvent(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_DHCPC, TCPIP_STACK_ADDRESS_SERVICE_EVENT_RUN_RESTORE); 
    8284:	2204      	movs	r2, #4
    8286:	2101      	movs	r1, #1
    8288:	4630      	mov	r0, r6
    828a:	f015 f84d 	bl	1d328 <TCPIP_STACK_AddressServiceEvent>
    TCPIP_ARP_Probe(pNetIf, &pClient->dhcpIPAddress, &pClient->dhcpIPAddress, ARP_OPERATION_RESP | ARP_OPERATION_CONFIGURE | ARP_OPERATION_PROBE_ONLY);
    828e:	f245 0302 	movw	r3, #20482	; 0x5002
    8292:	463a      	mov	r2, r7
    8294:	4639      	mov	r1, r7
    8296:	4630      	mov	r0, r6
    8298:	f013 f9dc 	bl	1b654 <TCPIP_ARP_Probe>
    if((pClient->dhcpIPAddress.Val & pClient->dhcpMask.Val) != (oldNetIp.Val & oldNetMask.Val))
    829c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    829e:	6b62      	ldr	r2, [r4, #52]	; 0x34
    82a0:	401a      	ands	r2, r3
    82a2:	9b03      	ldr	r3, [sp, #12]
    82a4:	9904      	ldr	r1, [sp, #16]
    82a6:	400b      	ands	r3, r1
    82a8:	429a      	cmp	r2, r3
    82aa:	d117      	bne.n	82dc <TCPIP_DHCP_Task+0x260>
    _DHCPSetBoundState(pClient);
    82ac:	4620      	mov	r0, r4
    82ae:	f015 fad1 	bl	1d854 <_DHCPSetBoundState>
    _DHCPNotifyClients(pNetIf, DHCP_EVENT_BOUND);
    82b2:	2108      	movs	r1, #8
    82b4:	4630      	mov	r0, r6
    82b6:	f015 fe1d 	bl	1def4 <_DHCPNotifyClients>
                        TCPIP_ARP_EntryRemove(pNetIf,  &arpCheck);
    82ba:	a902      	add	r1, sp, #8
    82bc:	4630      	mov	r0, r6
    82be:	f011 fd89 	bl	19dd4 <TCPIP_ARP_EntryRemove>
                break;
    82c2:	e030      	b.n	8326 <TCPIP_DHCP_Task+0x2aa>
        TCPIP_STACK_GatewayAddressSet(pNetIf, &pClient->dhcpGateway);
    82c4:	f104 0130 	add.w	r1, r4, #48	; 0x30
    82c8:	4630      	mov	r0, r6
    82ca:	f019 febe 	bl	2204a <TCPIP_STACK_GatewayAddressSet>
    82ce:	e7c2      	b.n	8256 <TCPIP_DHCP_Task+0x1da>
            TCPIP_STACK_PrimaryDNSAddressSet(pNetIf, &pClient->dhcpDNS);
    82d0:	f104 0138 	add.w	r1, r4, #56	; 0x38
    82d4:	4630      	mov	r0, r6
    82d6:	f019 febc 	bl	22052 <TCPIP_STACK_PrimaryDNSAddressSet>
    82da:	e7c6      	b.n	826a <TCPIP_DHCP_Task+0x1ee>
        TCPIP_ARP_EntryRemoveNet(pNetIf, &oldNetIp, &oldNetMask, ARP_ENTRY_TYPE_ANY);
    82dc:	2304      	movs	r3, #4
    82de:	aa04      	add	r2, sp, #16
    82e0:	a903      	add	r1, sp, #12
    82e2:	4630      	mov	r0, r6
    82e4:	f00c f8ac 	bl	14440 <TCPIP_ARP_EntryRemoveNet>
    82e8:	e7e0      	b.n	82ac <TCPIP_DHCP_Task+0x230>
                if((_DHCPSecondCountGet() - pClient->startWait) >= TCPIP_DHCP_WAIT_FAIL_CHECK_TMO)
    82ea:	4b69      	ldr	r3, [pc, #420]	; (8490 <TCPIP_DHCP_Task+0x414>)
    82ec:	681b      	ldr	r3, [r3, #0]
    82ee:	6862      	ldr	r2, [r4, #4]
    82f0:	1a9b      	subs	r3, r3, r2
    82f2:	2b09      	cmp	r3, #9
    82f4:	d917      	bls.n	8326 <TCPIP_DHCP_Task+0x2aa>
                    _DHCPSetRunFail(pClient, TCPIP_DHCP_SEND_DISCOVERY, false);
    82f6:	2200      	movs	r2, #0
    82f8:	2102      	movs	r1, #2
    82fa:	4620      	mov	r0, r4
    82fc:	f014 fa0c 	bl	1c718 <_DHCPSetRunFail>
    8300:	e011      	b.n	8326 <TCPIP_DHCP_Task+0x2aa>
                if((_DHCPSecondCountGet() - pClient->tRequest) < pClient->t1Seconds)
    8302:	4b63      	ldr	r3, [pc, #396]	; (8490 <TCPIP_DHCP_Task+0x414>)
    8304:	681b      	ldr	r3, [r3, #0]
    8306:	68a2      	ldr	r2, [r4, #8]
    8308:	1a9b      	subs	r3, r3, r2
    830a:	6922      	ldr	r2, [r4, #16]
    830c:	4293      	cmp	r3, r2
    830e:	d30a      	bcc.n	8326 <TCPIP_DHCP_Task+0x2aa>
    pClient->smState = newState;
    8310:	2309      	movs	r3, #9
    8312:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
                if(!_DHCPSend(pClient, pNetIf, TCPIP_DHCP_REQUEST_RENEW_MESSAGE, 0))
    8316:	2300      	movs	r3, #0
    8318:	2209      	movs	r2, #9
    831a:	4631      	mov	r1, r6
    831c:	4620      	mov	r0, r4
    831e:	f007 fb55 	bl	f9cc <_DHCPSend>
    8322:	2800      	cmp	r0, #0
    8324:	d150      	bne.n	83c8 <TCPIP_DHCP_Task+0x34c>
    for(netIx = 0; netIx < nNets; netIx++) 
    8326:	3501      	adds	r5, #1
    8328:	45a9      	cmp	r9, r5
    832a:	f000 80d6 	beq.w	84da <TCPIP_DHCP_Task+0x45e>
        pNetIf = (TCPIP_NET_IF*)TCPIP_STACK_IndexToNet (netIx);
    832e:	4628      	mov	r0, r5
    8330:	f017 fd74 	bl	1fe1c <TCPIP_STACK_IndexToNet>
TCPIP_NET_IF*  TCPIP_Stack_UserHandleToNet(TCPIP_NET_HANDLE hNet);


static __inline__ bool  __attribute__((always_inline)) TCPIP_STACK_NetworkIsUp(TCPIP_NET_IF* pNetIf)
{
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
    8334:	4606      	mov	r6, r0
    8336:	2800      	cmp	r0, #0
    8338:	d0f5      	beq.n	8326 <TCPIP_DHCP_Task+0x2aa>
    833a:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
    833e:	f013 0f40 	tst.w	r3, #64	; 0x40
    8342:	d0f0      	beq.n	8326 <TCPIP_DHCP_Task+0x2aa>
        pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf); 
    8344:	f8da 8000 	ldr.w	r8, [sl]
    8348:	f019 fc64 	bl	21c14 <TCPIP_STACK_NetIxGet>
    834c:	fb0b f700 	mul.w	r7, fp, r0
    8350:	eb08 0407 	add.w	r4, r8, r7
        if(pClient->flags.bDHCPEnabled == false)
    8354:	f894 2058 	ldrb.w	r2, [r4, #88]	; 0x58
    8358:	f012 0301 	ands.w	r3, r2, #1
    835c:	9301      	str	r3, [sp, #4]
    835e:	d0e2      	beq.n	8326 <TCPIP_DHCP_Task+0x2aa>
    if(pClient->smState > TCPIP_DHCP_WAIT_LINK && pClient->smState < TCPIP_DHCP_BOUND)
    8360:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
    8364:	3b02      	subs	r3, #2
    8366:	b29b      	uxth	r3, r3
    8368:	2b05      	cmp	r3, #5
    836a:	d80c      	bhi.n	8386 <TCPIP_DHCP_Task+0x30a>
        if(pClient->flags.bReportFail && pClient->tOpStart != 0)
    836c:	f012 0f20 	tst.w	r2, #32
    8370:	d009      	beq.n	8386 <TCPIP_DHCP_Task+0x30a>
    8372:	6a23      	ldr	r3, [r4, #32]
    8374:	b13b      	cbz	r3, 8386 <TCPIP_DHCP_Task+0x30a>
            if((_DHCPSecondCountGet() - pClient->tOpStart) >= pClient->tOpFailTmo)
    8376:	4a46      	ldr	r2, [pc, #280]	; (8490 <TCPIP_DHCP_Task+0x414>)
    8378:	6812      	ldr	r2, [r2, #0]
    837a:	1ad3      	subs	r3, r2, r3
    837c:	f8b4 2050 	ldrh.w	r2, [r4, #80]	; 0x50
    8380:	4293      	cmp	r3, r2
    8382:	f4bf ae96 	bcs.w	80b2 <TCPIP_DHCP_Task+0x36>
        switch(pClient->smState)
    8386:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
    838a:	3b01      	subs	r3, #1
    838c:	2b0b      	cmp	r3, #11
    838e:	d8ca      	bhi.n	8326 <TCPIP_DHCP_Task+0x2aa>
    8390:	a201      	add	r2, pc, #4	; (adr r2, 8398 <TCPIP_DHCP_Task+0x31c>)
    8392:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    8396:	bf00      	nop
    8398:	000080cb 	.word	0x000080cb
    839c:	00008103 	.word	0x00008103
    83a0:	0000814b 	.word	0x0000814b
    83a4:	00008175 	.word	0x00008175
    83a8:	000081d3 	.word	0x000081d3
    83ac:	00008207 	.word	0x00008207
    83b0:	000082eb 	.word	0x000082eb
    83b4:	00008303 	.word	0x00008303
    83b8:	00008317 	.word	0x00008317
    83bc:	00008409 	.word	0x00008409
    83c0:	0000843f 	.word	0x0000843f
    83c4:	00008499 	.word	0x00008499
                pClient->tRenewRequest = _DHCPSecondCountGet();
    83c8:	4b31      	ldr	r3, [pc, #196]	; (8490 <TCPIP_DHCP_Task+0x414>)
    83ca:	681b      	ldr	r3, [r3, #0]
    83cc:	60e3      	str	r3, [r4, #12]
                _DHCPNotifyClients(pNetIf, DHCP_EVENT_REQUEST_RENEW);
    83ce:	2109      	movs	r1, #9
    83d0:	4630      	mov	r0, r6
    83d2:	f015 fd8f 	bl	1def4 <_DHCPNotifyClients>
                pClient->flags.bOfferReceived = false;
    83d6:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
    83da:	f36f 0382 	bfc	r3, #2, #1
    83de:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
                pClient->t3Seconds = ((pClient->t2Seconds - pClient->t1Seconds) - (pClient->tRenewRequest - pClient->tRequest)) >> 1;
    83e2:	6963      	ldr	r3, [r4, #20]
    83e4:	68a2      	ldr	r2, [r4, #8]
    83e6:	4413      	add	r3, r2
    83e8:	6922      	ldr	r2, [r4, #16]
    83ea:	1a9b      	subs	r3, r3, r2
    83ec:	68e2      	ldr	r2, [r4, #12]
    83ee:	1a9b      	subs	r3, r3, r2
    83f0:	085b      	lsrs	r3, r3, #1
                if( pClient->t3Seconds < TCPIP_DHCP_RENEW_RETRY_TIMEOUT)
    83f2:	2b3b      	cmp	r3, #59	; 0x3b
                    pClient->t3Seconds = TCPIP_DHCP_RENEW_RETRY_TIMEOUT;
    83f4:	bf98      	it	ls
    83f6:	233c      	movls	r3, #60	; 0x3c
    83f8:	61e3      	str	r3, [r4, #28]
                pClient->startWait = _DHCPSecondCountGet();
    83fa:	4b25      	ldr	r3, [pc, #148]	; (8490 <TCPIP_DHCP_Task+0x414>)
    83fc:	681b      	ldr	r3, [r3, #0]
    83fe:	6063      	str	r3, [r4, #4]
    pClient->smState = newState;
    8400:	230a      	movs	r3, #10
    8402:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    8406:	e78e      	b.n	8326 <TCPIP_DHCP_Task+0x2aa>
                if(_DHCPProcessReceiveData(pClient, pNetIf) == TCPIP_DHCP_TIMEOUT_MESSAGE)
    8408:	4631      	mov	r1, r6
    840a:	4620      	mov	r0, r4
    840c:	f00e ffa2 	bl	17354 <_DHCPProcessReceiveData>
    8410:	280a      	cmp	r0, #10
    8412:	d188      	bne.n	8326 <TCPIP_DHCP_Task+0x2aa>
    return dhcpSecondCount;
    8414:	4b1e      	ldr	r3, [pc, #120]	; (8490 <TCPIP_DHCP_Task+0x414>)
    8416:	681a      	ldr	r2, [r3, #0]
                    if((_DHCPSecondCountGet() - pClient->tRequest) >= pClient->t2Seconds)
    8418:	68a3      	ldr	r3, [r4, #8]
    841a:	1ad3      	subs	r3, r2, r3
    841c:	6961      	ldr	r1, [r4, #20]
    841e:	428b      	cmp	r3, r1
    8420:	d303      	bcc.n	842a <TCPIP_DHCP_Task+0x3ae>
    pClient->smState = newState;
    8422:	230b      	movs	r3, #11
    8424:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    8428:	e77d      	b.n	8326 <TCPIP_DHCP_Task+0x2aa>
                    else if((_DHCPSecondCountGet() - pClient->startWait) >= pClient->t3Seconds)
    842a:	6863      	ldr	r3, [r4, #4]
    842c:	1ad2      	subs	r2, r2, r3
    842e:	69e3      	ldr	r3, [r4, #28]
    8430:	429a      	cmp	r2, r3
    8432:	f4ff af78 	bcc.w	8326 <TCPIP_DHCP_Task+0x2aa>
    pClient->smState = newState;
    8436:	2309      	movs	r3, #9
    8438:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    843c:	e773      	b.n	8326 <TCPIP_DHCP_Task+0x2aa>
                if(!_DHCPSend(pClient, pNetIf, TCPIP_DHCP_REQUEST_RENEW_MESSAGE, TCPIP_DHCP_FLAG_SEND_BCAST))
    843e:	2301      	movs	r3, #1
    8440:	2209      	movs	r2, #9
    8442:	4631      	mov	r1, r6
    8444:	4620      	mov	r0, r4
    8446:	f007 fac1 	bl	f9cc <_DHCPSend>
    844a:	2800      	cmp	r0, #0
    844c:	f43f af6b 	beq.w	8326 <TCPIP_DHCP_Task+0x2aa>
                pClient->tRenewRequest = _DHCPSecondCountGet();
    8450:	4b0f      	ldr	r3, [pc, #60]	; (8490 <TCPIP_DHCP_Task+0x414>)
    8452:	681b      	ldr	r3, [r3, #0]
    8454:	60e3      	str	r3, [r4, #12]
                _DHCPNotifyClients(pNetIf, DHCP_EVENT_REQUEST_REBIND);
    8456:	210a      	movs	r1, #10
    8458:	4630      	mov	r0, r6
    845a:	f015 fd4b 	bl	1def4 <_DHCPNotifyClients>
                pClient->flags.bOfferReceived = false;
    845e:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
    8462:	f36f 0382 	bfc	r3, #2, #1
    8466:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
                pClient->t3Seconds = ((pClient->tExpSeconds - pClient->t2Seconds) - (pClient->tRenewRequest - pClient->tRequest)) >> 1;
    846a:	69a3      	ldr	r3, [r4, #24]
    846c:	68a2      	ldr	r2, [r4, #8]
    846e:	4413      	add	r3, r2
    8470:	6962      	ldr	r2, [r4, #20]
    8472:	1a9b      	subs	r3, r3, r2
    8474:	68e2      	ldr	r2, [r4, #12]
    8476:	1a9b      	subs	r3, r3, r2
    8478:	085b      	lsrs	r3, r3, #1
                if( pClient->t3Seconds < TCPIP_DHCP_REBIND_RETRY_TIMEOUT)
    847a:	2b3b      	cmp	r3, #59	; 0x3b
                    pClient->t3Seconds = TCPIP_DHCP_REBIND_RETRY_TIMEOUT;
    847c:	bf98      	it	ls
    847e:	233c      	movls	r3, #60	; 0x3c
    8480:	61e3      	str	r3, [r4, #28]
                pClient->startWait = _DHCPSecondCountGet();
    8482:	4b03      	ldr	r3, [pc, #12]	; (8490 <TCPIP_DHCP_Task+0x414>)
    8484:	681b      	ldr	r3, [r3, #0]
    8486:	6063      	str	r3, [r4, #4]
    pClient->smState = newState;
    8488:	230c      	movs	r3, #12
    848a:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    848e:	e74a      	b.n	8326 <TCPIP_DHCP_Task+0x2aa>
    8490:	2000e620 	.word	0x2000e620
    8494:	2000e610 	.word	0x2000e610
                if(_DHCPProcessReceiveData(pClient, pNetIf) == TCPIP_DHCP_TIMEOUT_MESSAGE)
    8498:	4631      	mov	r1, r6
    849a:	4620      	mov	r0, r4
    849c:	f00e ff5a 	bl	17354 <_DHCPProcessReceiveData>
    84a0:	280a      	cmp	r0, #10
    84a2:	f47f af40 	bne.w	8326 <TCPIP_DHCP_Task+0x2aa>
    return dhcpSecondCount;
    84a6:	4b23      	ldr	r3, [pc, #140]	; (8534 <TCPIP_DHCP_Task+0x4b8>)
    84a8:	681b      	ldr	r3, [r3, #0]
                    if((_DHCPSecondCountGet() - pClient->tRequest) >= pClient->tExpSeconds)
    84aa:	68a2      	ldr	r2, [r4, #8]
    84ac:	1a9a      	subs	r2, r3, r2
    84ae:	69a1      	ldr	r1, [r4, #24]
    84b0:	428a      	cmp	r2, r1
    84b2:	d208      	bcs.n	84c6 <TCPIP_DHCP_Task+0x44a>
                    else if((_DHCPSecondCountGet() - pClient->startWait) >= pClient->t3Seconds)
    84b4:	6862      	ldr	r2, [r4, #4]
    84b6:	1a9b      	subs	r3, r3, r2
    84b8:	69e2      	ldr	r2, [r4, #28]
    84ba:	4293      	cmp	r3, r2
    pClient->smState = newState;
    84bc:	bf24      	itt	cs
    84be:	230b      	movcs	r3, #11
    84c0:	f8a4 3056 	strhcs.w	r3, [r4, #86]	; 0x56
    _DHCPDbgStatus(pClient);
    84c4:	e72f      	b.n	8326 <TCPIP_DHCP_Task+0x2aa>
                        _DHCPSetRunFail(pClient, TCPIP_DHCP_SEND_DISCOVERY, false);
    84c6:	2200      	movs	r2, #0
    84c8:	2102      	movs	r1, #2
    84ca:	4620      	mov	r0, r4
    84cc:	f014 f924 	bl	1c718 <_DHCPSetRunFail>
                        _DHCPNotifyClients(pNetIf, DHCP_EVENT_TIMEOUT);
    84d0:	2107      	movs	r1, #7
    84d2:	4630      	mov	r0, r6
    84d4:	f015 fd0e 	bl	1def4 <_DHCPNotifyClients>
    84d8:	e725      	b.n	8326 <TCPIP_DHCP_Task+0x2aa>
    TCPIP_UDP_Discard(dhcpClientSocket);
    84da:	4b17      	ldr	r3, [pc, #92]	; (8538 <TCPIP_DHCP_Task+0x4bc>)
    84dc:	f9b3 0000 	ldrsh.w	r0, [r3]
    84e0:	f018 f8f3 	bl	206ca <TCPIP_UDP_Discard>
}
    84e4:	b007      	add	sp, #28
    84e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    None.
*/

static __inline__ uint64_t __attribute__((always_inline)) SYS_TMR_SystemCountGet(void)
{
	return SYS_TIME_Counter64Get();
    84ea:	f015 fe11 	bl	1e110 <SYS_TIME_Counter64Get>
    84ee:	4604      	mov	r4, r0
    84f0:	460d      	mov	r5, r1
	return SYS_TIME_FrequencyGet();
    84f2:	f019 fd31 	bl	21f58 <SYS_TIME_FrequencyGet>
    dhcpSecondCount = SYS_TMR_SystemCountGet() / SYS_TMR_SystemCountFrequencyGet(); 
    84f6:	4602      	mov	r2, r0
    84f8:	2300      	movs	r3, #0
    84fa:	4620      	mov	r0, r4
    84fc:	4629      	mov	r1, r5
    84fe:	f016 ff39 	bl	1f374 <__aeabi_uldivmod>
    8502:	4b0c      	ldr	r3, [pc, #48]	; (8534 <TCPIP_DHCP_Task+0x4b8>)
    8504:	6018      	str	r0, [r3, #0]
    8506:	e5c8      	b.n	809a <TCPIP_DHCP_Task+0x1e>
                        TCPIP_ARP_EntryRemove(pNetIf,  &arpCheck);
    8508:	a902      	add	r1, sp, #8
    850a:	4630      	mov	r0, r6
    850c:	f011 fc62 	bl	19dd4 <TCPIP_ARP_EntryRemove>
                        _DHCPSend(pClient, pNetIf, TCPIP_DHCP_DECLINE_MESSAGE, TCPIP_DHCP_FLAG_SEND_ZERO_ADD | TCPIP_DHCP_FLAG_SEND_BCAST);
    8510:	2303      	movs	r3, #3
    8512:	2204      	movs	r2, #4
    8514:	4631      	mov	r1, r6
    8516:	4620      	mov	r0, r4
    8518:	f007 fa58 	bl	f9cc <_DHCPSend>
    pClient->smState = newState;
    851c:	2307      	movs	r3, #7
    851e:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
                        pClient->startWait = _DHCPSecondCountGet();
    8522:	4b04      	ldr	r3, [pc, #16]	; (8534 <TCPIP_DHCP_Task+0x4b8>)
    8524:	681b      	ldr	r3, [r3, #0]
    8526:	6063      	str	r3, [r4, #4]
                        _DHCPNotifyClients(pNetIf, DHCP_EVENT_DECLINE);
    8528:	2105      	movs	r1, #5
    852a:	4630      	mov	r0, r6
    852c:	f015 fce2 	bl	1def4 <_DHCPNotifyClients>
    8530:	e6f9      	b.n	8326 <TCPIP_DHCP_Task+0x2aa>
    8532:	bf00      	nop
    8534:	2000e620 	.word	0x2000e620
    8538:	2000e720 	.word	0x2000e720

Disassembly of section .rodata%201:

0000853c <.rodata%201>:
    853c:	2f504354 	.word	0x2f504354
    8540:	53205049 	.word	0x53205049
    8544:	6b636174 	.word	0x6b636174
    8548:	7325203a 	.word	0x7325203a
    854c:	43414d20 	.word	0x43414d20
    8550:	696e6920 	.word	0x696e6920
    8554:	6c616974 	.word	0x6c616974
    8558:	74617a69 	.word	0x74617a69
    855c:	206e6f69 	.word	0x206e6f69
    8560:	6c696166 	.word	0x6c696166
    8564:	0a0d6465 	.word	0x0a0d6465
    8568:	00000000 	.word	0x00000000
    856c:	2f504354 	.word	0x2f504354
    8570:	53205049 	.word	0x53205049
    8574:	6b636174 	.word	0x6b636174
    8578:	7325203a 	.word	0x7325203a
    857c:	43414d20 	.word	0x43414d20
    8580:	65704f20 	.word	0x65704f20
    8584:	6166206e 	.word	0x6166206e
    8588:	64656c69 	.word	0x64656c69
    858c:	00000a0d 	.word	0x00000a0d
    8590:	2f504354 	.word	0x2f504354
    8594:	53205049 	.word	0x53205049
    8598:	6b636174 	.word	0x6b636174
    859c:	6f4d203a 	.word	0x6f4d203a
    85a0:	656c7564 	.word	0x656c7564
    85a4:	3a6f6e20 	.word	0x3a6f6e20
    85a8:	20642520 	.word	0x20642520
    85ac:	74696e49 	.word	0x74696e49
    85b0:	696c6169 	.word	0x696c6169
    85b4:	6974617a 	.word	0x6974617a
    85b8:	66206e6f 	.word	0x66206e6f
    85bc:	656c6961 	.word	0x656c6961
    85c0:	000a0d64 	.word	0x000a0d64
    85c4:	2f504354 	.word	0x2f504354
    85c8:	53205049 	.word	0x53205049
    85cc:	6b636174 	.word	0x6b636174
    85d0:	7325203a 	.word	0x7325203a
    85d4:	43414d20 	.word	0x43414d20
    85d8:	65766520 	.word	0x65766520
    85dc:	6e20746e 	.word	0x6e20746e
    85e0:	6669746f 	.word	0x6669746f
    85e4:	74616369 	.word	0x74616369
    85e8:	206e6f69 	.word	0x206e6f69
    85ec:	74746573 	.word	0x74746573
    85f0:	20676e69 	.word	0x20676e69
    85f4:	6c696166 	.word	0x6c696166
    85f8:	0a0d6465 	.word	0x0a0d6465
    85fc:	00000000 	.word	0x00000000
    8600:	2f504354 	.word	0x2f504354
    8604:	53205049 	.word	0x53205049
    8608:	6b636174 	.word	0x6b636174
    860c:	6548203a 	.word	0x6548203a
    8610:	44207061 	.word	0x44207061
    8614:	74656c65 	.word	0x74656c65
    8618:	61662065 	.word	0x61662065
    861c:	0d216c69 	.word	0x0d216c69
    8620:	0000000a 	.word	0x0000000a
    8624:	2f504354 	.word	0x2f504354
    8628:	53205049 	.word	0x53205049
    862c:	6b636174 	.word	0x6b636174
    8630:	6548203a 	.word	0x6548203a
    8634:	63207061 	.word	0x63207061
    8638:	74616572 	.word	0x74616572
    863c:	206e6f69 	.word	0x206e6f69
    8640:	6c696166 	.word	0x6c696166
    8644:	202c6465 	.word	0x202c6465
    8648:	65707974 	.word	0x65707974
    864c:	6425203a 	.word	0x6425203a
    8650:	00000a0d 	.word	0x00000a0d
    8654:	2f504354 	.word	0x2f504354
    8658:	53205049 	.word	0x53205049
    865c:	6b636174 	.word	0x6b636174
    8660:	654e203a 	.word	0x654e203a
    8664:	726f7774 	.word	0x726f7774
    8668:	6f63206b 	.word	0x6f63206b
    866c:	6769666e 	.word	0x6769666e
    8670:	74617275 	.word	0x74617275
    8674:	206e6f69 	.word	0x206e6f69
    8678:	6f6c6c61 	.word	0x6f6c6c61
    867c:	69746163 	.word	0x69746163
    8680:	66206e6f 	.word	0x66206e6f
    8684:	656c6961 	.word	0x656c6961
    8688:	25203a64 	.word	0x25203a64
    868c:	0a0d756c 	.word	0x0a0d756c
    8690:	00000000 	.word	0x00000000
    8694:	2f504354 	.word	0x2f504354
    8698:	53205049 	.word	0x53205049
    869c:	6b636174 	.word	0x6b636174
    86a0:	6150203a 	.word	0x6150203a
    86a4:	74656b63 	.word	0x74656b63
    86a8:	696e6920 	.word	0x696e6920
    86ac:	6c616974 	.word	0x6c616974
    86b0:	74617a69 	.word	0x74617a69
    86b4:	206e6f69 	.word	0x206e6f69
    86b8:	6c696166 	.word	0x6c696166
    86bc:	203a6465 	.word	0x203a6465
    86c0:	78257830 	.word	0x78257830
    86c4:	00000a0d 	.word	0x00000a0d
    86c8:	2f504354 	.word	0x2f504354
    86cc:	53205049 	.word	0x53205049
    86d0:	6b636174 	.word	0x6b636174
    86d4:	6544203a 	.word	0x6544203a
    86d8:	6c756166 	.word	0x6c756166
    86dc:	6c462074 	.word	0x6c462074
    86e0:	20687361 	.word	0x20687361
    86e4:	7774654e 	.word	0x7774654e
    86e8:	206b726f 	.word	0x206b726f
    86ec:	666e6f63 	.word	0x666e6f63
    86f0:	72756769 	.word	0x72756769
    86f4:	6f697461 	.word	0x6f697461
    86f8:	6f6c206e 	.word	0x6f6c206e
    86fc:	66206461 	.word	0x66206461
    8700:	656c6961 	.word	0x656c6961
    8704:	64252064 	.word	0x64252064
    8708:	00000a0d 	.word	0x00000a0d
    870c:	2f504354 	.word	0x2f504354
    8710:	53205049 	.word	0x53205049
    8714:	6b636174 	.word	0x6b636174
    8718:	654e203a 	.word	0x654e203a
    871c:	726f7774 	.word	0x726f7774
    8720:	6f63206b 	.word	0x6f63206b
    8724:	6769666e 	.word	0x6769666e
    8728:	74617275 	.word	0x74617275
    872c:	206e6f69 	.word	0x206e6f69
    8730:	74696e69 	.word	0x74696e69
    8734:	696c6169 	.word	0x696c6169
    8738:	6974617a 	.word	0x6974617a
    873c:	66206e6f 	.word	0x66206e6f
    8740:	656c6961 	.word	0x656c6961
    8744:	25203a64 	.word	0x25203a64
    8748:	000a0d64 	.word	0x000a0d64
    874c:	2f504354 	.word	0x2f504354
    8750:	53205049 	.word	0x53205049
    8754:	6b636174 	.word	0x6b636174
    8758:	654e203a 	.word	0x654e203a
    875c:	726f7774 	.word	0x726f7774
    8760:	6f63206b 	.word	0x6f63206b
    8764:	6769666e 	.word	0x6769666e
    8768:	74617275 	.word	0x74617275
    876c:	3a6e6f69 	.word	0x3a6e6f69
    8770:	696c4120 	.word	0x696c4120
    8774:	73657361 	.word	0x73657361
    8778:	746f6e20 	.word	0x746f6e20
    877c:	70757320 	.word	0x70757320
    8780:	74726f70 	.word	0x74726f70
    8784:	203a6465 	.word	0x203a6465
    8788:	0a0d6425 	.word	0x0a0d6425
    878c:	00000000 	.word	0x00000000
    8790:	2f504354 	.word	0x2f504354
    8794:	53205049 	.word	0x53205049
    8798:	6b636174 	.word	0x6b636174
    879c:	654e203a 	.word	0x654e203a
    87a0:	726f7774 	.word	0x726f7774
    87a4:	6f63206b 	.word	0x6f63206b
    87a8:	6769666e 	.word	0x6769666e
    87ac:	74617275 	.word	0x74617275
    87b0:	3a6e6f69 	.word	0x3a6e6f69
    87b4:	766e6920 	.word	0x766e6920
    87b8:	64696c61 	.word	0x64696c61
    87bc:	20504920 	.word	0x20504920
    87c0:	72646461 	.word	0x72646461
    87c4:	3a737365 	.word	0x3a737365
    87c8:	25783020 	.word	0x25783020
    87cc:	0a0d7838 	.word	0x0a0d7838
    87d0:	00000000 	.word	0x00000000
    87d4:	64257325 	.word	0x64257325
    87d8:	00000000 	.word	0x00000000
    87dc:	2f504354 	.word	0x2f504354
    87e0:	53205049 	.word	0x53205049
    87e4:	6b636174 	.word	0x6b636174
    87e8:	6f50203a 	.word	0x6f50203a
    87ec:	20726577 	.word	0x20726577
    87f0:	65646f4d 	.word	0x65646f4d
    87f4:	696e6920 	.word	0x696e6920
    87f8:	6c616974 	.word	0x6c616974
    87fc:	74617a69 	.word	0x74617a69
    8800:	206e6f69 	.word	0x206e6f69
    8804:	6c696166 	.word	0x6c696166
    8808:	6425203a 	.word	0x6425203a
    880c:	00000a0d 	.word	0x00000a0d
    8810:	2f504354 	.word	0x2f504354
    8814:	53205049 	.word	0x53205049
    8818:	6b636174 	.word	0x6b636174
    881c:	7944203a 	.word	0x7944203a
    8820:	696d616e 	.word	0x696d616e
    8824:	656d2063 	.word	0x656d2063
    8828:	79726f6d 	.word	0x79726f6d
    882c:	20736920 	.word	0x20736920
    8830:	3a776f6c 	.word	0x3a776f6c
    8834:	756c2520 	.word	0x756c2520
    8838:	00000a0d 	.word	0x00000a0d
    883c:	2f504354 	.word	0x2f504354
    8840:	53205049 	.word	0x53205049
    8844:	6b636174 	.word	0x6b636174
    8848:	6e49203a 	.word	0x6e49203a
    884c:	61697469 	.word	0x61697469
    8850:	617a696c 	.word	0x617a696c
    8854:	6e6f6974 	.word	0x6e6f6974
    8858:	69616620 	.word	0x69616620
    885c:	2064656c 	.word	0x2064656c
    8860:	2d206425 	.word	0x2d206425
    8864:	6f624120 	.word	0x6f624120
    8868:	6e697472 	.word	0x6e697472
    886c:	0d202167 	.word	0x0d202167
    8870:	0000000a 	.word	0x0000000a
    8874:	2f504354 	.word	0x2f504354
    8878:	53205049 	.word	0x53205049
    887c:	6b636174 	.word	0x6b636174
    8880:	6e49203a 	.word	0x6e49203a
    8884:	61697469 	.word	0x61697469
    8888:	617a696c 	.word	0x617a696c
    888c:	6e6f6974 	.word	0x6e6f6974
    8890:	61745320 	.word	0x61745320
    8894:	64657472 	.word	0x64657472
    8898:	000a0d20 	.word	0x000a0d20
    889c:	2f504354 	.word	0x2f504354
    88a0:	53205049 	.word	0x53205049
    88a4:	6b636174 	.word	0x6b636174
    88a8:	654e203a 	.word	0x654e203a
    88ac:	726f7774 	.word	0x726f7774
    88b0:	6f63206b 	.word	0x6f63206b
    88b4:	6769666e 	.word	0x6769666e
    88b8:	74617275 	.word	0x74617275
    88bc:	206e6f69 	.word	0x206e6f69
    88c0:	64616f6c 	.word	0x64616f6c
    88c4:	69616620 	.word	0x69616620
    88c8:	3a64656c 	.word	0x3a64656c
    88cc:	0d642520 	.word	0x0d642520
    88d0:	0000000a 	.word	0x0000000a
    88d4:	2f504354 	.word	0x2f504354
    88d8:	53205049 	.word	0x53205049
    88dc:	6b636174 	.word	0x6b636174
    88e0:	6954203a 	.word	0x6954203a
    88e4:	72206b63 	.word	0x72206b63
    88e8:	73696765 	.word	0x73696765
    88ec:	74617274 	.word	0x74617274
    88f0:	206e6f69 	.word	0x206e6f69
    88f4:	6c696166 	.word	0x6c696166
    88f8:	203a6465 	.word	0x203a6465
    88fc:	0a0d6425 	.word	0x0a0d6425
    8900:	00000000 	.word	0x00000000
    8904:	2f504354 	.word	0x2f504354
    8908:	53205049 	.word	0x53205049
    890c:	6b636174 	.word	0x6b636174
    8910:	6e49203a 	.word	0x6e49203a
    8914:	61697469 	.word	0x61697469
    8918:	617a696c 	.word	0x617a696c
    891c:	6e6f6974 	.word	0x6e6f6974
    8920:	53595320 	.word	0x53595320
    8924:	524d5420 	.word	0x524d5420
    8928:	69616620 	.word	0x69616620
    892c:	3a64656c 	.word	0x3a64656c
    8930:	20642520 	.word	0x20642520
    8934:	6241202d 	.word	0x6241202d
    8938:	6974726f 	.word	0x6974726f
    893c:	2021676e 	.word	0x2021676e
    8940:	00000a0d 	.word	0x00000a0d
    8944:	2f504354 	.word	0x2f504354
    8948:	53205049 	.word	0x53205049
    894c:	6b636174 	.word	0x6b636174
    8950:	6e49203a 	.word	0x6e49203a
    8954:	61697469 	.word	0x61697469
    8958:	617a696c 	.word	0x617a696c
    895c:	6e6f6974 	.word	0x6e6f6974
    8960:	646e4520 	.word	0x646e4520
    8964:	2d206465 	.word	0x2d206465
    8968:	63757320 	.word	0x63757320
    896c:	73736563 	.word	0x73736563
    8970:	000a0d20 	.word	0x000a0d20
    8974:	2f504354 	.word	0x2f504354
    8978:	53205049 	.word	0x53205049
    897c:	6b636174 	.word	0x6b636174
    8980:	6e49203a 	.word	0x6e49203a
    8984:	61697469 	.word	0x61697469
    8988:	617a696c 	.word	0x617a696c
    898c:	6e6f6974 	.word	0x6e6f6974
    8990:	69616620 	.word	0x69616620
    8994:	3a64656c 	.word	0x3a64656c
    8998:	25783020 	.word	0x25783020
    899c:	202d2078 	.word	0x202d2078
    89a0:	726f6241 	.word	0x726f6241
    89a4:	676e6974 	.word	0x676e6974
    89a8:	0a0d2021 	.word	0x0a0d2021
    89ac:	00000000 	.word	0x00000000
    89b0:	30312e38 	.word	0x30312e38
    89b4:	48202d20 	.word	0x48202d20
    89b8:	00000033 	.word	0x00000033
    89bc:	006b6e75 	.word	0x006b6e75
    89c0:	00687465 	.word	0x00687465
    89c4:	6e616c77 	.word	0x6e616c77
    89c8:	00          	.byte	0x00
    89c9:	00          	.byte	0x00
    89ca:	bf00      	nop

Disassembly of section .text._TCPIP_DoInitialize%202:

000089cc <_TCPIP_DoInitialize>:
{
    89cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    89d0:	b08b      	sub	sp, #44	; 0x2c
    nNets = init->nNets;
    89d2:	6884      	ldr	r4, [r0, #8]
    if(nNets == 0 || pUsrConfig == 0 || pUsrConfig->pMacObject == 0 || pModConfig == 0 || nModules == 0)
    89d4:	2c00      	cmp	r4, #0
    89d6:	f000 81c3 	beq.w	8d60 <_TCPIP_DoInitialize+0x394>
    pUsrConfig = init->pNetConf;
    89da:	6845      	ldr	r5, [r0, #4]
    if(nNets == 0 || pUsrConfig == 0 || pUsrConfig->pMacObject == 0 || pModConfig == 0 || nModules == 0)
    89dc:	2d00      	cmp	r5, #0
    89de:	f000 81c5 	beq.w	8d6c <_TCPIP_DoInitialize+0x3a0>
    89e2:	6aab      	ldr	r3, [r5, #40]	; 0x28
    89e4:	2b00      	cmp	r3, #0
    89e6:	f000 81c4 	beq.w	8d72 <_TCPIP_DoInitialize+0x3a6>
    pModConfig = init->pModConfig;
    89ea:	f8d0 900c 	ldr.w	r9, [r0, #12]
    if(nNets == 0 || pUsrConfig == 0 || pUsrConfig->pMacObject == 0 || pModConfig == 0 || nModules == 0)
    89ee:	f1b9 0f00 	cmp.w	r9, #0
    89f2:	f000 81c1 	beq.w	8d78 <_TCPIP_DoInitialize+0x3ac>
    nModules = init->nModules;
    89f6:	f8d0 b010 	ldr.w	fp, [r0, #16]
    if(nNets == 0 || pUsrConfig == 0 || pUsrConfig->pMacObject == 0 || pModConfig == 0 || nModules == 0)
    89fa:	f1bb 0f00 	cmp.w	fp, #0
    89fe:	f000 81be 	beq.w	8d7e <_TCPIP_DoInitialize+0x3b2>
    tcpip_init_data = *init;
    8a02:	4fb3      	ldr	r7, [pc, #716]	; (8cd0 <_TCPIP_DoInitialize+0x304>)
    8a04:	4606      	mov	r6, r0
    8a06:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    8a08:	c70f      	stmia	r7!, {r0, r1, r2, r3}
    8a0a:	e896 0003 	ldmia.w	r6, {r0, r1}
    8a0e:	e887 0003 	stmia.w	r7, {r0, r1}
        if(pModConfig->moduleId == moduleId)
    8a12:	f8b9 3000 	ldrh.w	r3, [r9]
    8a16:	2b01      	cmp	r3, #1
    8a18:	f000 81c8 	beq.w	8dac <_TCPIP_DoInitialize+0x3e0>
    8a1c:	f1ab 0202 	sub.w	r2, fp, #2
    8a20:	464b      	mov	r3, r9
        pModConfig++;
    8a22:	3308      	adds	r3, #8
    while(nModules--)
    8a24:	f1b2 3fff 	cmp.w	r2, #4294967295
    8a28:	d03f      	beq.n	8aaa <_TCPIP_DoInitialize+0xde>
        if(pModConfig->moduleId == moduleId)
    8a2a:	3a01      	subs	r2, #1
    8a2c:	8819      	ldrh	r1, [r3, #0]
    8a2e:	2901      	cmp	r1, #1
    8a30:	d1f7      	bne.n	8a22 <_TCPIP_DoInitialize+0x56>
        heapData = (pHeapConfig != 0) ? (const TCPIP_STACK_HEAP_CONFIG*)pHeapConfig->configData : 0;
    8a32:	f8d3 a004 	ldr.w	sl, [r3, #4]
        if( heapData == 0 || heapData->malloc_fnc == 0 || heapData->calloc_fnc == 0 || heapData->free_fnc == 0)
    8a36:	f1ba 0f00 	cmp.w	sl, #0
    8a3a:	d038      	beq.n	8aae <_TCPIP_DoInitialize+0xe2>
    8a3c:	f8da 3004 	ldr.w	r3, [sl, #4]
    8a40:	2b00      	cmp	r3, #0
    8a42:	d034      	beq.n	8aae <_TCPIP_DoInitialize+0xe2>
    8a44:	f8da 3008 	ldr.w	r3, [sl, #8]
    8a48:	2b00      	cmp	r3, #0
    8a4a:	d030      	beq.n	8aae <_TCPIP_DoInitialize+0xe2>
    8a4c:	f8da 300c 	ldr.w	r3, [sl, #12]
    8a50:	b36b      	cbz	r3, 8aae <_TCPIP_DoInitialize+0xe2>
            heapH = TCPIP_HEAP_Create(heapData, 0);
    8a52:	2100      	movs	r1, #0
    8a54:	4650      	mov	r0, sl
    8a56:	f018 fec5 	bl	217e4 <TCPIP_HEAP_Create>
    8a5a:	9005      	str	r0, [sp, #20]
        if((tcpip_stack_ctrl_data.memH = heapH) == 0)
    8a5c:	4b9d      	ldr	r3, [pc, #628]	; (8cd4 <_TCPIP_DoInitialize+0x308>)
    8a5e:	60d8      	str	r0, [r3, #12]
    8a60:	2800      	cmp	r0, #0
    8a62:	f000 81a8 	beq.w	8db6 <_TCPIP_DoInitialize+0x3ea>
        tcpip_stack_ctrl_data.heapType = heapData->heapType;
    8a66:	f89a 2000 	ldrb.w	r2, [sl]
    8a6a:	4b9a      	ldr	r3, [pc, #616]	; (8cd4 <_TCPIP_DoInitialize+0x308>)
    8a6c:	741a      	strb	r2, [r3, #16]
// out of line version
void*   TCPIP_HEAP_MallocOutline(TCPIP_STACK_HEAP_HANDLE heapH, size_t nBytes);

static __inline__ void* __attribute__((always_inline)) TCPIP_HEAP_CallocInline(TCPIP_STACK_HEAP_HANDLE h, size_t nElems, size_t elemSize)
{
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Calloc)(h, nElems, elemSize);
    8a6e:	9805      	ldr	r0, [sp, #20]
    8a70:	6883      	ldr	r3, [r0, #8]
    8a72:	226c      	movs	r2, #108	; 0x6c
    8a74:	4621      	mov	r1, r4
    8a76:	4798      	blx	r3
        tcpipNetIf = (TCPIP_NET_IF*)TCPIP_HEAP_Calloc(heapH, nNets, sizeof(TCPIP_NET_IF)); // allocate for each network interface
    8a78:	4b97      	ldr	r3, [pc, #604]	; (8cd8 <_TCPIP_DoInitialize+0x30c>)
    8a7a:	6018      	str	r0, [r3, #0]
        if(tcpipNetIf == 0)
    8a7c:	b368      	cbz	r0, 8ada <_TCPIP_DoInitialize+0x10e>
        if(TCPIP_PKT_Initialize(heapH, pUsrConfig, nNets) == false)
    8a7e:	4622      	mov	r2, r4
    8a80:	4629      	mov	r1, r5
    8a82:	9805      	ldr	r0, [sp, #20]
    8a84:	f016 fb56 	bl	1f134 <TCPIP_PKT_Initialize>
    8a88:	9003      	str	r0, [sp, #12]
    8a8a:	2800      	cmp	r0, #0
    8a8c:	d13c      	bne.n	8b08 <_TCPIP_DoInitialize+0x13c>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Packet initialization failed: 0x%x\r\n", (uint32_t)heapH);
    8a8e:	f019 fa5d 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
    8a92:	bb88      	cbnz	r0, 8af8 <_TCPIP_DoInitialize+0x12c>
            initFail = 3;
    8a94:	2403      	movs	r4, #3
    SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Initialization failed %d - Aborting! \r\n", initFail);
    8a96:	f019 fa59 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
    8a9a:	2800      	cmp	r0, #0
    8a9c:	f040 8159 	bne.w	8d52 <_TCPIP_DoInitialize+0x386>
    TCPIP_STACK_KillStack();
    8aa0:	f00d fb5e 	bl	16160 <TCPIP_STACK_KillStack>
    return false;
    8aa4:	2300      	movs	r3, #0
    8aa6:	9303      	str	r3, [sp, #12]
    8aa8:	e15c      	b.n	8d64 <_TCPIP_DoInitialize+0x398>
        heapData = (pHeapConfig != 0) ? (const TCPIP_STACK_HEAP_CONFIG*)pHeapConfig->configData : 0;
    8aaa:	f04f 0a00 	mov.w	sl, #0
        if((tcpip_stack_ctrl_data.memH = heapH) == 0)
    8aae:	4b89      	ldr	r3, [pc, #548]	; (8cd4 <_TCPIP_DoInitialize+0x308>)
    8ab0:	2200      	movs	r2, #0
    8ab2:	60da      	str	r2, [r3, #12]
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Heap creation failed, type: %d\r\n", heapData ? heapData->heapType : TCPIP_STACK_HEAP_TYPE_NONE);
    8ab4:	f019 fa4a 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
    8ab8:	b908      	cbnz	r0, 8abe <_TCPIP_DoInitialize+0xf2>
            initFail = 1;
    8aba:	2401      	movs	r4, #1
    8abc:	e7eb      	b.n	8a96 <_TCPIP_DoInitialize+0xca>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Heap creation failed, type: %d\r\n", heapData ? heapData->heapType : TCPIP_STACK_HEAP_TYPE_NONE);
    8abe:	f019 fa3f 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
    8ac2:	f1ba 0f00 	cmp.w	sl, #0
    8ac6:	d006      	beq.n	8ad6 <_TCPIP_DoInitialize+0x10a>
    8ac8:	f89a 2000 	ldrb.w	r2, [sl]
    8acc:	4983      	ldr	r1, [pc, #524]	; (8cdc <_TCPIP_DoInitialize+0x310>)
    8ace:	f011 fe4d 	bl	1a76c <SYS_CONSOLE_Print>
            initFail = 1;
    8ad2:	2401      	movs	r4, #1
    8ad4:	e7df      	b.n	8a96 <_TCPIP_DoInitialize+0xca>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Heap creation failed, type: %d\r\n", heapData ? heapData->heapType : TCPIP_STACK_HEAP_TYPE_NONE);
    8ad6:	2200      	movs	r2, #0
    8ad8:	e7f8      	b.n	8acc <_TCPIP_DoInitialize+0x100>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration allocation failed: %lu\r\n", nNets * sizeof(TCPIP_NET_IF));
    8ada:	f019 fa37 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
    8ade:	b908      	cbnz	r0, 8ae4 <_TCPIP_DoInitialize+0x118>
            initFail = 2;
    8ae0:	2402      	movs	r4, #2
    8ae2:	e7d8      	b.n	8a96 <_TCPIP_DoInitialize+0xca>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration allocation failed: %lu\r\n", nNets * sizeof(TCPIP_NET_IF));
    8ae4:	f019 fa2c 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
    8ae8:	226c      	movs	r2, #108	; 0x6c
    8aea:	fb02 f204 	mul.w	r2, r2, r4
    8aee:	497c      	ldr	r1, [pc, #496]	; (8ce0 <_TCPIP_DoInitialize+0x314>)
    8af0:	f011 fe3c 	bl	1a76c <SYS_CONSOLE_Print>
            initFail = 2;
    8af4:	2402      	movs	r4, #2
    8af6:	e7ce      	b.n	8a96 <_TCPIP_DoInitialize+0xca>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Packet initialization failed: 0x%x\r\n", (uint32_t)heapH);
    8af8:	f019 fa22 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
    8afc:	9a05      	ldr	r2, [sp, #20]
    8afe:	4979      	ldr	r1, [pc, #484]	; (8ce4 <_TCPIP_DoInitialize+0x318>)
    8b00:	f011 fe34 	bl	1a76c <SYS_CONSOLE_Print>
            initFail = 3;
    8b04:	2403      	movs	r4, #3
    8b06:	e7c6      	b.n	8a96 <_TCPIP_DoInitialize+0xca>
        tcpip_stack_ctrl_data.nIfs = nNets;
    8b08:	4b72      	ldr	r3, [pc, #456]	; (8cd4 <_TCPIP_DoInitialize+0x308>)
    8b0a:	601c      	str	r4, [r3, #0]
        tcpip_stack_ctrl_data.nModules = nModules;
    8b0c:	f8c3 b008 	str.w	fp, [r3, #8]
    for(ix =0, pConfigIf = tcpipNetIf; ix < nNets; ix++, pConfigIf++, pUsrConfig++)
    8b10:	4b71      	ldr	r3, [pc, #452]	; (8cd8 <_TCPIP_DoInitialize+0x30c>)
    8b12:	681e      	ldr	r6, [r3, #0]
    8b14:	2c00      	cmp	r4, #0
    8b16:	f340 8154 	ble.w	8dc2 <_TCPIP_DoInitialize+0x3f6>
    8b1a:	462f      	mov	r7, r5
    8b1c:	f04f 0800 	mov.w	r8, #0
        if(!_LoadNetworkConfig(pUsrConfig, pConfigIf, false))
    8b20:	2200      	movs	r2, #0
    8b22:	4631      	mov	r1, r6
    8b24:	4638      	mov	r0, r7
    8b26:	f009 fa11 	bl	11f4c <_LoadNetworkConfig>
    8b2a:	b328      	cbz	r0, 8b78 <_TCPIP_DoInitialize+0x1ac>
    for(ix =0, pConfigIf = tcpipNetIf; ix < nNets; ix++, pConfigIf++, pUsrConfig++)
    8b2c:	f108 0801 	add.w	r8, r8, #1
    8b30:	366c      	adds	r6, #108	; 0x6c
    8b32:	3738      	adds	r7, #56	; 0x38
    8b34:	4544      	cmp	r4, r8
    8b36:	d1f3      	bne.n	8b20 <_TCPIP_DoInitialize+0x154>
        for(netIx = 0, pIf = tcpipNetIf; netIx < nNets; netIx++, pIf++)
    8b38:	4a67      	ldr	r2, [pc, #412]	; (8cd8 <_TCPIP_DoInitialize+0x30c>)
    8b3a:	f8d2 e000 	ldr.w	lr, [r2]
    8b3e:	4a65      	ldr	r2, [pc, #404]	; (8cd4 <_TCPIP_DoInitialize+0x308>)
    8b40:	6856      	ldr	r6, [r2, #4]
    8b42:	46f4      	mov	ip, lr
    8b44:	2100      	movs	r1, #0
                    tcpip_stack_ctrl_data.nAliases++;
    8b46:	4680      	mov	r8, r0
    8b48:	4670      	mov	r0, lr
    8b4a:	468e      	mov	lr, r1
            pPriMac = pIf->pMacObj;
    8b4c:	f8dc 7044 	ldr.w	r7, [ip, #68]	; 0x44
            for(ix = netIx + 1, pScanIf = pIf + 1; ix < nNets; ix++, pScanIf++)
    8b50:	f10e 0e01 	add.w	lr, lr, #1
    8b54:	f10c 0c6c 	add.w	ip, ip, #108	; 0x6c
    8b58:	4574      	cmp	r4, lr
    8b5a:	d024      	beq.n	8ba6 <_TCPIP_DoInitialize+0x1da>
    8b5c:	4662      	mov	r2, ip
    8b5e:	4673      	mov	r3, lr
    8b60:	9004      	str	r0, [sp, #16]
                if(pScanIf->pMacObj == pPriMac)
    8b62:	6c50      	ldr	r0, [r2, #68]	; 0x44
    8b64:	42b8      	cmp	r0, r7
                    tcpip_stack_ctrl_data.nAliases++;
    8b66:	bf04      	itt	eq
    8b68:	3601      	addeq	r6, #1
    8b6a:	4641      	moveq	r1, r8
            for(ix = netIx + 1, pScanIf = pIf + 1; ix < nNets; ix++, pScanIf++)
    8b6c:	3301      	adds	r3, #1
    8b6e:	326c      	adds	r2, #108	; 0x6c
    8b70:	429c      	cmp	r4, r3
    8b72:	d1f6      	bne.n	8b62 <_TCPIP_DoInitialize+0x196>
    8b74:	9804      	ldr	r0, [sp, #16]
    8b76:	e7e9      	b.n	8b4c <_TCPIP_DoInitialize+0x180>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Default Flash Network configuration load failed %d\r\n", ix);
    8b78:	f019 f9e8 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
    8b7c:	b920      	cbnz	r0, 8b88 <_TCPIP_DoInitialize+0x1bc>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration initialization failed: %d\r\n", nNets);
    8b7e:	f019 f9e5 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
    8b82:	b940      	cbnz	r0, 8b96 <_TCPIP_DoInitialize+0x1ca>
            initFail = 4;   // failed the initialization
    8b84:	2404      	movs	r4, #4
    8b86:	e786      	b.n	8a96 <_TCPIP_DoInitialize+0xca>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Default Flash Network configuration load failed %d\r\n", ix);
    8b88:	f019 f9da 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
    8b8c:	4642      	mov	r2, r8
    8b8e:	4956      	ldr	r1, [pc, #344]	; (8ce8 <_TCPIP_DoInitialize+0x31c>)
    8b90:	f011 fdec 	bl	1a76c <SYS_CONSOLE_Print>
    8b94:	e7f3      	b.n	8b7e <_TCPIP_DoInitialize+0x1b2>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration initialization failed: %d\r\n", nNets);
    8b96:	f019 f9d3 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
    8b9a:	4622      	mov	r2, r4
    8b9c:	4953      	ldr	r1, [pc, #332]	; (8cec <_TCPIP_DoInitialize+0x320>)
    8b9e:	f011 fde5 	bl	1a76c <SYS_CONSOLE_Print>
            initFail = 4;   // failed the initialization
    8ba2:	2404      	movs	r4, #4
    8ba4:	e777      	b.n	8a96 <_TCPIP_DoInitialize+0xca>
    8ba6:	4686      	mov	lr, r0
    8ba8:	b109      	cbz	r1, 8bae <_TCPIP_DoInitialize+0x1e2>
    8baa:	4b4a      	ldr	r3, [pc, #296]	; (8cd4 <_TCPIP_DoInitialize+0x308>)
    8bac:	605e      	str	r6, [r3, #4]
        if(tcpip_stack_ctrl_data.nAliases != 0)
    8bae:	4b49      	ldr	r3, [pc, #292]	; (8cd4 <_TCPIP_DoInitialize+0x308>)
    8bb0:	685b      	ldr	r3, [r3, #4]
    8bb2:	2b00      	cmp	r3, #0
    8bb4:	f040 810d 	bne.w	8dd2 <_TCPIP_DoInitialize+0x406>
    8bb8:	f10e 006c 	add.w	r0, lr, #108	; 0x6c
    8bbc:	2701      	movs	r7, #1
    8bbe:	e00c      	b.n	8bda <_TCPIP_DoInitialize+0x20e>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration: Aliases not supported: %d\r\n", tcpip_stack_ctrl_data.nAliases);
    8bc0:	f019 f9be 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
    8bc4:	4b43      	ldr	r3, [pc, #268]	; (8cd4 <_TCPIP_DoInitialize+0x308>)
    8bc6:	685a      	ldr	r2, [r3, #4]
    8bc8:	4949      	ldr	r1, [pc, #292]	; (8cf0 <_TCPIP_DoInitialize+0x324>)
    8bca:	f011 fdcf 	bl	1a76c <SYS_CONSOLE_Print>
            initFail = 5;
    8bce:	2405      	movs	r4, #5
    8bd0:	e761      	b.n	8a96 <_TCPIP_DoInitialize+0xca>
        for(netIx = 0, pIf = tcpipNetIf; netIx < nNets && !initFail; netIx++, pIf++)
    8bd2:	42bc      	cmp	r4, r7
    8bd4:	dd20      	ble.n	8c18 <_TCPIP_DoInitialize+0x24c>
    8bd6:	3701      	adds	r7, #1
    8bd8:	306c      	adds	r0, #108	; 0x6c
            if((dupIpAddr.Val = pIf->DefaultIPAddr.Val) != 0)
    8bda:	4603      	mov	r3, r0
    8bdc:	f850 1c54 	ldr.w	r1, [r0, #-84]
    8be0:	2900      	cmp	r1, #0
    8be2:	d0f6      	beq.n	8bd2 <_TCPIP_DoInitialize+0x206>
                for(ix = netIx + 1, pScanIf = pIf + 1; ix < nNets; ix++, pScanIf++)
    8be4:	463a      	mov	r2, r7
    8be6:	42bc      	cmp	r4, r7
    8be8:	dd16      	ble.n	8c18 <_TCPIP_DoInitialize+0x24c>
                    if(pScanIf->DefaultIPAddr.Val == dupIpAddr.Val)
    8bea:	6986      	ldr	r6, [r0, #24]
    8bec:	42b1      	cmp	r1, r6
    8bee:	d006      	beq.n	8bfe <_TCPIP_DoInitialize+0x232>
                for(ix = netIx + 1, pScanIf = pIf + 1; ix < nNets; ix++, pScanIf++)
    8bf0:	3201      	adds	r2, #1
    8bf2:	336c      	adds	r3, #108	; 0x6c
    8bf4:	4294      	cmp	r4, r2
    8bf6:	d0ee      	beq.n	8bd6 <_TCPIP_DoInitialize+0x20a>
                    if(pScanIf->DefaultIPAddr.Val == dupIpAddr.Val)
    8bf8:	699e      	ldr	r6, [r3, #24]
    8bfa:	42b1      	cmp	r1, r6
    8bfc:	d1f8      	bne.n	8bf0 <_TCPIP_DoInitialize+0x224>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration: invalid IP address: 0x%8x\r\n", dupIpAddr.Val);
    8bfe:	f019 f9a5 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
    8c02:	b908      	cbnz	r0, 8c08 <_TCPIP_DoInitialize+0x23c>
    8c04:	2406      	movs	r4, #6
    8c06:	e746      	b.n	8a96 <_TCPIP_DoInitialize+0xca>
    8c08:	f019 f99a 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
    8c0c:	4632      	mov	r2, r6
    8c0e:	4939      	ldr	r1, [pc, #228]	; (8cf4 <_TCPIP_DoInitialize+0x328>)
    8c10:	f011 fdac 	bl	1a76c <SYS_CONSOLE_Print>
    8c14:	2406      	movs	r4, #6
    8c16:	e73e      	b.n	8a96 <_TCPIP_DoInitialize+0xca>
        tcpipDefIf.defaultNet = 0;
    8c18:	2300      	movs	r3, #0
    8c1a:	4a37      	ldr	r2, [pc, #220]	; (8cf8 <_TCPIP_DoInitialize+0x32c>)
    8c1c:	6013      	str	r3, [r2, #0]
    memset(ifNumber, 0, sizeof(ifNumber));
    8c1e:	9307      	str	r3, [sp, #28]
    8c20:	9308      	str	r3, [sp, #32]
    8c22:	9309      	str	r3, [sp, #36]	; 0x24
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    8c24:	4b2b      	ldr	r3, [pc, #172]	; (8cd4 <_TCPIP_DoInitialize+0x308>)
    8c26:	681b      	ldr	r3, [r3, #0]
    8c28:	2b00      	cmp	r3, #0
    8c2a:	dd24      	ble.n	8c76 <_TCPIP_DoInitialize+0x2aa>
    8c2c:	f10e 0662 	add.w	r6, lr, #98	; 0x62
    8c30:	f04f 0800 	mov.w	r8, #0
    8c34:	f8cd a010 	str.w	sl, [sp, #16]
        pNetIf->netIfIx = netIx;
    8c38:	f826 8c0a 	strh.w	r8, [r6, #-10]
            const char* ifName = TCPIP_STACK_IF_ALIAS_NAME_TBL[macType]; 
    8c3c:	79f3      	ldrb	r3, [r6, #7]
            snprintf(pNetIf->ifName, sizeof(pNetIf->ifName), "%s%d", ifName, ifNumber[macType]);
    8c3e:	aa0a      	add	r2, sp, #40	; 0x28
    8c40:	eb02 0a83 	add.w	sl, r2, r3, lsl #2
    8c44:	f85a 7c0c 	ldr.w	r7, [sl, #-12]
    8c48:	9700      	str	r7, [sp, #0]
    8c4a:	4a2c      	ldr	r2, [pc, #176]	; (8cfc <_TCPIP_DoInitialize+0x330>)
    8c4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c50:	4a2b      	ldr	r2, [pc, #172]	; (8d00 <_TCPIP_DoInitialize+0x334>)
    8c52:	2107      	movs	r1, #7
    8c54:	4630      	mov	r0, r6
    8c56:	f011 fdf5 	bl	1a844 <sniprintf>
            pNetIf->ifName[sizeof(pNetIf->ifName) - 1] = 0;
    8c5a:	2300      	movs	r3, #0
    8c5c:	71b3      	strb	r3, [r6, #6]
            ifNumber[macType]++;
    8c5e:	3701      	adds	r7, #1
    8c60:	f84a 7c0c 	str.w	r7, [sl, #-12]
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
    8c64:	f108 0801 	add.w	r8, r8, #1
    8c68:	366c      	adds	r6, #108	; 0x6c
    8c6a:	4b1a      	ldr	r3, [pc, #104]	; (8cd4 <_TCPIP_DoInitialize+0x308>)
    8c6c:	681b      	ldr	r3, [r3, #0]
    8c6e:	4598      	cmp	r8, r3
    8c70:	dbe2      	blt.n	8c38 <_TCPIP_DoInitialize+0x26c>
    8c72:	f8dd a010 	ldr.w	sl, [sp, #16]
        memset(TCPIP_STACK_MODULE_SIGNAL_TBL, 0x0, sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL));
    8c76:	f44f 721c 	mov.w	r2, #624	; 0x270
    8c7a:	2100      	movs	r1, #0
    8c7c:	4821      	ldr	r0, [pc, #132]	; (8d04 <_TCPIP_DoInitialize+0x338>)
    8c7e:	f018 ff7d 	bl	21b7c <memset>
        stackAsyncSignalCount = 0;
    8c82:	4b21      	ldr	r3, [pc, #132]	; (8d08 <_TCPIP_DoInitialize+0x33c>)
    8c84:	2200      	movs	r2, #0
    8c86:	601a      	str	r2, [r3, #0]
        tcpip_heap_config = *heapData; 
    8c88:	4e20      	ldr	r6, [pc, #128]	; (8d0c <_TCPIP_DoInitialize+0x340>)
    8c8a:	e89a 000f 	ldmia.w	sl, {r0, r1, r2, r3}
    8c8e:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
        for(ix = 0; ix < sizeof(TCPIP_MODULES_QUEUE_TBL)/sizeof(*TCPIP_MODULES_QUEUE_TBL); ix++)
    8c92:	4e1f      	ldr	r6, [pc, #124]	; (8d10 <_TCPIP_DoInitialize+0x344>)
    8c94:	f106 0790 	add.w	r7, r6, #144	; 0x90
            TCPIP_Helper_SingleListInitialize(TCPIP_MODULES_QUEUE_TBL + ix);
    8c98:	4630      	mov	r0, r6
    8c9a:	f019 f9b1 	bl	22000 <TCPIP_Helper_SingleListInitialize>
    8c9e:	360c      	adds	r6, #12
        for(ix = 0; ix < sizeof(TCPIP_MODULES_QUEUE_TBL)/sizeof(*TCPIP_MODULES_QUEUE_TBL); ix++)
    8ca0:	42be      	cmp	r6, r7
    8ca2:	d1f9      	bne.n	8c98 <_TCPIP_DoInitialize+0x2cc>
        tcpip_stack_ctrl_data.stackAction = TCPIP_STACK_ACTION_INIT;
    8ca4:	4b0b      	ldr	r3, [pc, #44]	; (8cd4 <_TCPIP_DoInitialize+0x308>)
    8ca6:	2200      	movs	r2, #0
    8ca8:	771a      	strb	r2, [r3, #28]
        for(netIx = 0, pIf = tcpipNetIf; netIx < nNets; netIx++, pIf++, pUsrConfig++)
    8caa:	4b0b      	ldr	r3, [pc, #44]	; (8cd8 <_TCPIP_DoInitialize+0x30c>)
    8cac:	f8d3 a000 	ldr.w	sl, [r3]
    8cb0:	4294      	cmp	r4, r2
    8cb2:	dd69      	ble.n	8d88 <_TCPIP_DoInitialize+0x3bc>
    8cb4:	4617      	mov	r7, r2
            tcpip_stack_ctrl_data.powerMode = powerMode;
    8cb6:	4e07      	ldr	r6, [pc, #28]	; (8cd4 <_TCPIP_DoInitialize+0x308>)
    8cb8:	46a0      	mov	r8, r4
    8cba:	4654      	mov	r4, sl
    8cbc:	e03b      	b.n	8d36 <_TCPIP_DoInitialize+0x36a>
                SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Power Mode initialization fail: %d\r\n", powerMode);
    8cbe:	f019 f93f 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
    8cc2:	4642      	mov	r2, r8
    8cc4:	4913      	ldr	r1, [pc, #76]	; (8d14 <_TCPIP_DoInitialize+0x348>)
    8cc6:	f011 fd51 	bl	1a76c <SYS_CONSOLE_Print>
                initFail = 7;
    8cca:	2407      	movs	r4, #7
    8ccc:	e6e3      	b.n	8a96 <_TCPIP_DoInitialize+0xca>
    8cce:	bf00      	nop
    8cd0:	2000e3fc 	.word	0x2000e3fc
    8cd4:	2000e2f0 	.word	0x2000e2f0
    8cd8:	2000e648 	.word	0x2000e648
    8cdc:	00008624 	.word	0x00008624
    8ce0:	00008654 	.word	0x00008654
    8ce4:	00008694 	.word	0x00008694
    8ce8:	000086c8 	.word	0x000086c8
    8cec:	0000870c 	.word	0x0000870c
    8cf0:	0000874c 	.word	0x0000874c
    8cf4:	00008790 	.word	0x00008790
    8cf8:	2000e644 	.word	0x2000e644
    8cfc:	00021f10 	.word	0x00021f10
    8d00:	000087d4 	.word	0x000087d4
    8d04:	2000d1d4 	.word	0x2000d1d4
    8d08:	2000e63c 	.word	0x2000e63c
    8d0c:	2000e518 	.word	0x2000e518
    8d10:	2000de84 	.word	0x2000de84
    8d14:	000087dc 	.word	0x000087dc
            tcpip_stack_ctrl_data.powerMode = powerMode;
    8d18:	7770      	strb	r0, [r6, #29]
            tcpip_stack_ctrl_data.pNetIf = pIf;
    8d1a:	6174      	str	r4, [r6, #20]
            tcpip_stack_ctrl_data.netIx = netIx;
    8d1c:	61b7      	str	r7, [r6, #24]
            if(!TCPIP_STACK_BringNetUp(&tcpip_stack_ctrl_data, pUsrConfig, pModConfig, nModules))
    8d1e:	465b      	mov	r3, fp
    8d20:	464a      	mov	r2, r9
    8d22:	4629      	mov	r1, r5
    8d24:	4630      	mov	r0, r6
    8d26:	f004 fd7d 	bl	d824 <TCPIP_STACK_BringNetUp>
    8d2a:	b358      	cbz	r0, 8d84 <_TCPIP_DoInitialize+0x3b8>
        for(netIx = 0, pIf = tcpipNetIf; netIx < nNets; netIx++, pIf++, pUsrConfig++)
    8d2c:	3701      	adds	r7, #1
    8d2e:	346c      	adds	r4, #108	; 0x6c
    8d30:	3538      	adds	r5, #56	; 0x38
    8d32:	45b8      	cmp	r8, r7
    8d34:	d028      	beq.n	8d88 <_TCPIP_DoInitialize+0x3bc>
            powerMode = TCPIP_Helper_StringToPowerMode(pUsrConfig->powerMode);
    8d36:	6a28      	ldr	r0, [r5, #32]
    8d38:	f016 f99c 	bl	1f074 <TCPIP_Helper_StringToPowerMode>
            if(powerMode != TCPIP_MAC_POWER_FULL && powerMode != TCPIP_MAC_POWER_DOWN)
    8d3c:	f000 03fd 	and.w	r3, r0, #253	; 0xfd
    8d40:	2b01      	cmp	r3, #1
    8d42:	d0e9      	beq.n	8d18 <_TCPIP_DoInitialize+0x34c>
    8d44:	4680      	mov	r8, r0
                SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Power Mode initialization fail: %d\r\n", powerMode);
    8d46:	f019 f901 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
    8d4a:	2800      	cmp	r0, #0
    8d4c:	d1b7      	bne.n	8cbe <_TCPIP_DoInitialize+0x2f2>
                initFail = 7;
    8d4e:	2407      	movs	r4, #7
    8d50:	e6a1      	b.n	8a96 <_TCPIP_DoInitialize+0xca>
    SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Initialization failed %d - Aborting! \r\n", initFail);
    8d52:	f019 f8f5 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
    8d56:	4622      	mov	r2, r4
    8d58:	4921      	ldr	r1, [pc, #132]	; (8de0 <_TCPIP_DoInitialize+0x414>)
    8d5a:	f011 fd07 	bl	1a76c <SYS_CONSOLE_Print>
    8d5e:	e69f      	b.n	8aa0 <_TCPIP_DoInitialize+0xd4>
        return false;
    8d60:	2300      	movs	r3, #0
    8d62:	9303      	str	r3, [sp, #12]
}
    8d64:	9803      	ldr	r0, [sp, #12]
    8d66:	b00b      	add	sp, #44	; 0x2c
    8d68:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return false;
    8d6c:	2300      	movs	r3, #0
    8d6e:	9303      	str	r3, [sp, #12]
    8d70:	e7f8      	b.n	8d64 <_TCPIP_DoInitialize+0x398>
    8d72:	2300      	movs	r3, #0
    8d74:	9303      	str	r3, [sp, #12]
    8d76:	e7f5      	b.n	8d64 <_TCPIP_DoInitialize+0x398>
    8d78:	2300      	movs	r3, #0
    8d7a:	9303      	str	r3, [sp, #12]
    8d7c:	e7f2      	b.n	8d64 <_TCPIP_DoInitialize+0x398>
    8d7e:	2300      	movs	r3, #0
    8d80:	9303      	str	r3, [sp, #12]
    8d82:	e7ef      	b.n	8d64 <_TCPIP_DoInitialize+0x398>
                initFail = 8;
    8d84:	2408      	movs	r4, #8
    if(!initFail)
    8d86:	e686      	b.n	8a96 <_TCPIP_DoInitialize+0xca>
}
#define TCPIP_HEAP_MaxSize(h) TCPIP_HEAP_MaxSizeInline(h)

static __inline__ size_t __attribute__((always_inline)) TCPIP_HEAP_FreeSizeInline(TCPIP_STACK_HEAP_HANDLE h)
{
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_FreeSize)(h);
    8d88:	9805      	ldr	r0, [sp, #20]
    8d8a:	6983      	ldr	r3, [r0, #24]
    8d8c:	4798      	blx	r3
    8d8e:	4604      	mov	r4, r0
        if(heapLeft < TCPIP_STACK_DRAM_RUN_LIMIT)
    8d90:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
    8d94:	d2e6      	bcs.n	8d64 <_TCPIP_DoInitialize+0x398>
            SYS_ERROR_PRINT(SYS_ERROR_WARNING, TCPIP_STACK_HDR_MESSAGE "Dynamic memory is low: %lu\r\n", heapLeft);
    8d96:	f019 f8d9 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
    8d9a:	2801      	cmp	r0, #1
    8d9c:	d9e2      	bls.n	8d64 <_TCPIP_DoInitialize+0x398>
    8d9e:	f019 f8cf 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
    8da2:	4622      	mov	r2, r4
    8da4:	490f      	ldr	r1, [pc, #60]	; (8de4 <_TCPIP_DoInitialize+0x418>)
    8da6:	f011 fce1 	bl	1a76c <SYS_CONSOLE_Print>
    8daa:	e7db      	b.n	8d64 <_TCPIP_DoInitialize+0x398>
        if(pModConfig->moduleId == moduleId)
    8dac:	464b      	mov	r3, r9
    8dae:	e640      	b.n	8a32 <_TCPIP_DoInitialize+0x66>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Heap creation failed, type: %d\r\n", heapData ? heapData->heapType : TCPIP_STACK_HEAP_TYPE_NONE);
    8db0:	f019 f8c6 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
    8db4:	e688      	b.n	8ac8 <_TCPIP_DoInitialize+0xfc>
    8db6:	f019 f8c9 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
    8dba:	2800      	cmp	r0, #0
    8dbc:	d1f8      	bne.n	8db0 <_TCPIP_DoInitialize+0x3e4>
            initFail = 1;
    8dbe:	2401      	movs	r4, #1
    8dc0:	e669      	b.n	8a96 <_TCPIP_DoInitialize+0xca>
        for(netIx = 0, pIf = tcpipNetIf; netIx < nNets; netIx++, pIf++)
    8dc2:	4b09      	ldr	r3, [pc, #36]	; (8de8 <_TCPIP_DoInitialize+0x41c>)
    8dc4:	f8d3 e000 	ldr.w	lr, [r3]
        if(tcpip_stack_ctrl_data.nAliases != 0)
    8dc8:	4b08      	ldr	r3, [pc, #32]	; (8dec <_TCPIP_DoInitialize+0x420>)
    8dca:	685b      	ldr	r3, [r3, #4]
    8dcc:	2b00      	cmp	r3, #0
    8dce:	f43f af23 	beq.w	8c18 <_TCPIP_DoInitialize+0x24c>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration: Aliases not supported: %d\r\n", tcpip_stack_ctrl_data.nAliases);
    8dd2:	f019 f8bb 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
    8dd6:	2800      	cmp	r0, #0
    8dd8:	f47f aef2 	bne.w	8bc0 <_TCPIP_DoInitialize+0x1f4>
            initFail = 5;
    8ddc:	2405      	movs	r4, #5
    8dde:	e65a      	b.n	8a96 <_TCPIP_DoInitialize+0xca>
    8de0:	0000883c 	.word	0x0000883c
    8de4:	00008810 	.word	0x00008810
    8de8:	2000e648 	.word	0x2000e648
    8dec:	2000e2f0 	.word	0x2000e2f0

Disassembly of section .text.SYS_CMD_Tasks%203:

00008df0 <SYS_CMD_Tasks>:

}

// Maintains the Command Processor System Service's internal state machine.
bool SYS_CMD_Tasks(void)
{
    8df0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8df4:	b0a3      	sub	sp, #140	; 0x8c
    SYS_CMD_IO_DCPT* pCmdIO;
    for(pCmdIO = cmdIODevList.head; pCmdIO != 0; pCmdIO = pCmdIO->next)
    8df6:	4bb4      	ldr	r3, [pc, #720]	; (90c8 <SYS_CMD_Tasks+0x2d8>)
    8df8:	f8d3 b000 	ldr.w	fp, [r3]
    8dfc:	f1bb 0f00 	cmp.w	fp, #0
    8e00:	f000 81f9 	beq.w	91f6 <SYS_CMD_Tasks+0x406>
        if(pCmdIO->seqChars == VT100_DETECT_SEQ_SIZE)
        {   // detect the exact escape sequence
            pCmdIO->seqBuff[pCmdIO->seqChars] = 0;
            pKeyDcpt = keySeqTbl;
            pFoundSeq = 0;
            for(ix = 0; ix < sizeof(keySeqTbl) / sizeof(*keySeqTbl); ix++, pKeyDcpt++)
    8e04:	465e      	mov	r6, fp
    8e06:	e0be      	b.n	8f86 <SYS_CMD_Tasks+0x196>
            pCmdIO->seqBuff[pCmdIO->seqChars] = 0;
    8e08:	2300      	movs	r3, #0
    8e0a:	7573      	strb	r3, [r6, #21]
            pKeyDcpt = keySeqTbl;
    8e0c:	4daf      	ldr	r5, [pc, #700]	; (90cc <SYS_CMD_Tasks+0x2dc>)
            {
                if(strncmp(pCmdIO->seqBuff, pKeyDcpt->keyCode, VT100_DETECT_SEQ_SIZE) == 0)
    8e0e:	f106 0812 	add.w	r8, r6, #18
    8e12:	2703      	movs	r7, #3
    8e14:	463a      	mov	r2, r7
    8e16:	6829      	ldr	r1, [r5, #0]
    8e18:	4640      	mov	r0, r8
    8e1a:	f017 fb93 	bl	20544 <strncmp>
    8e1e:	2800      	cmp	r0, #0
    8e20:	f000 81e7 	beq.w	91f2 <SYS_CMD_Tasks+0x402>
            for(ix = 0; ix < sizeof(keySeqTbl) / sizeof(*keySeqTbl); ix++, pKeyDcpt++)
    8e24:	350c      	adds	r5, #12
    8e26:	4baa      	ldr	r3, [pc, #680]	; (90d0 <SYS_CMD_Tasks+0x2e0>)
    8e28:	429d      	cmp	r5, r3
    8e2a:	d1f3      	bne.n	8e14 <SYS_CMD_Tasks+0x24>
                }
            }

            if(pFoundSeq == 0)
            {   // unknown escape sequence
                pCmdIO->seqChars = 0;
    8e2c:	2300      	movs	r3, #0
    8e2e:	8233      	strh	r3, [r6, #16]
                return;
    8e30:	e0a5      	b.n	8f7e <SYS_CMD_Tasks+0x18e>
        }

        return;

    }
    else if((newCh == '\r') || (newCh == '\n'))
    8e32:	280d      	cmp	r0, #13
    8e34:	d03a      	beq.n	8eac <SYS_CMD_Tasks+0xbc>
    8e36:	280a      	cmp	r0, #10
    8e38:	d038      	beq.n	8eac <SYS_CMD_Tasks+0xbc>
        pCmdIO->cmdPnt = pCmdIO->cmdEnd = pCmdIO->cmdBuff;

        ParseCmdBuffer(pCmdIO);
        (*pCmdApi->msg)(cmdIoParam, _promptStr);
    }
    else if(newCh == '\b')
    8e3a:	2808      	cmp	r0, #8
    8e3c:	f000 8166 	beq.w	910c <SYS_CMD_Tasks+0x31c>
                (*pCmdApi->msg)(cmdIoParam, "\b\x1b[K");
                pCmdIO->cmdPnt--; pCmdIO->cmdEnd--;
            }
        }
    }
    else if(newCh == 0x7f)
    8e40:	287f      	cmp	r0, #127	; 0x7f
    8e42:	f000 819a 	beq.w	917a <SYS_CMD_Tasks+0x38a>
            *pCmdIO->cmdEnd = '\0';
            sprintf(pCmdIO->ctrlBuff, "\x1b[K%s\x1b[%dD", pCmdIO->cmdPnt, len);
            (*pCmdApi->msg)(cmdIoParam, pCmdIO->ctrlBuff);
        }
    }
    else if(newCh == 0x1b)
    8e46:	281b      	cmp	r0, #27
    8e48:	f000 81ba 	beq.w	91c0 <SYS_CMD_Tasks+0x3d0>
    {   // start escape sequence... wait for complete sequence
        pCmdIO->seqBuff[0] = newCh;
        pCmdIO->seqChars = 1;
    }
    else if(pCmdIO->cmdEnd - pCmdIO->cmdBuff < sizeof(pCmdIO->cmdBuff) - 1)
    8e4c:	69f2      	ldr	r2, [r6, #28]
    8e4e:	f106 0520 	add.w	r5, r6, #32
    8e52:	1b53      	subs	r3, r2, r5
    8e54:	2b4f      	cmp	r3, #79	; 0x4f
    8e56:	f200 81bc 	bhi.w	91d2 <SYS_CMD_Tasks+0x3e2>
    {   // valid char; insert and echo it back
        int n_chars = pCmdIO->cmdEnd - pCmdIO->cmdPnt;  // existent chars
    8e5a:	69b3      	ldr	r3, [r6, #24]
        if(n_chars != 0)
    8e5c:	1ad3      	subs	r3, r2, r3
    8e5e:	f000 81b4 	beq.w	91ca <SYS_CMD_Tasks+0x3da>
        {   // move the existing chars to the right, for insertion...
            char* pSrc = pCmdIO->cmdEnd - 1;
            char* pDst = pCmdIO->cmdEnd;
            for(ix = 0; ix < n_chars; ix++)
    8e62:	2b00      	cmp	r3, #0
    8e64:	dd05      	ble.n	8e72 <SYS_CMD_Tasks+0x82>
    8e66:	1ad0      	subs	r0, r2, r3
            {
                *pDst-- = *pSrc--;
    8e68:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
    8e6c:	7051      	strb	r1, [r2, #1]
            for(ix = 0; ix < n_chars; ix++)
    8e6e:	4282      	cmp	r2, r0
    8e70:	d1fa      	bne.n	8e68 <SYS_CMD_Tasks+0x78>
            }
            pCmdIO->cmdEnd++;
    8e72:	69f2      	ldr	r2, [r6, #28]
    8e74:	1c51      	adds	r1, r2, #1
    8e76:	61f1      	str	r1, [r6, #28]
            *pCmdIO->cmdEnd = '\0';
    8e78:	2100      	movs	r1, #0
    8e7a:	7051      	strb	r1, [r2, #1]
            sprintf(pCmdIO->ctrlBuff + 1, "%s\x1b[%dD", pCmdIO->cmdPnt + 1, n_chars);
    8e7c:	69b2      	ldr	r2, [r6, #24]
    8e7e:	3201      	adds	r2, #1
    8e80:	4994      	ldr	r1, [pc, #592]	; (90d4 <SYS_CMD_Tasks+0x2e4>)
    8e82:	f106 0072 	add.w	r0, r6, #114	; 0x72
    8e86:	f014 fb5f 	bl	1d548 <siprintf>
        }
        else
        {
            pCmdIO->ctrlBuff[1] = 0;
        }
        pCmdIO->ctrlBuff[0] = newCh;
    8e8a:	4631      	mov	r1, r6
    8e8c:	f801 4f71 	strb.w	r4, [r1, #113]!

        (*pCmdApi->msg)(cmdIoParam, pCmdIO->ctrlBuff);
    8e90:	f8da 3000 	ldr.w	r3, [sl]
    8e94:	4648      	mov	r0, r9
    8e96:	4798      	blx	r3
        *pCmdIO->cmdPnt++ = newCh;
    8e98:	69b3      	ldr	r3, [r6, #24]
    8e9a:	1c5a      	adds	r2, r3, #1
    8e9c:	61b2      	str	r2, [r6, #24]
    8e9e:	701c      	strb	r4, [r3, #0]
    return pN;
}

static void CmdAdjustPointers(SYS_CMD_IO_DCPT* pCmdIO)
{
    if(pCmdIO->cmdPnt > pCmdIO->cmdEnd)
    8ea0:	69b3      	ldr	r3, [r6, #24]
    8ea2:	69f2      	ldr	r2, [r6, #28]
    8ea4:	4293      	cmp	r3, r2
    8ea6:	d96a      	bls.n	8f7e <SYS_CMD_Tasks+0x18e>
    {
        pCmdIO->cmdEnd = pCmdIO->cmdPnt;
    8ea8:	61f3      	str	r3, [r6, #28]
    8eaa:	e068      	b.n	8f7e <SYS_CMD_Tasks+0x18e>
        if(pCmdIO->cmdEnd ==  pCmdIO->cmdBuff)
    8eac:	f106 0320 	add.w	r3, r6, #32
    8eb0:	461a      	mov	r2, r3
    8eb2:	9302      	str	r3, [sp, #8]
    8eb4:	69f3      	ldr	r3, [r6, #28]
    8eb6:	4293      	cmp	r3, r2
    8eb8:	d01a      	beq.n	8ef0 <SYS_CMD_Tasks+0x100>
        (*pCmdApi->msg)(cmdIoParam, LINE_TERM);
    8eba:	f8da 3000 	ldr.w	r3, [sl]
    8ebe:	4986      	ldr	r1, [pc, #536]	; (90d8 <SYS_CMD_Tasks+0x2e8>)
    8ec0:	4648      	mov	r0, r9
    8ec2:	4798      	blx	r3
        *pCmdIO->cmdEnd = 0;
    8ec4:	69f3      	ldr	r3, [r6, #28]
    8ec6:	2500      	movs	r5, #0
    8ec8:	701d      	strb	r5, [r3, #0]
        pCmdIO->cmdPnt = pCmdIO->cmdEnd = pCmdIO->cmdBuff;
    8eca:	9c02      	ldr	r4, [sp, #8]
    8ecc:	61f4      	str	r4, [r6, #28]
    8ece:	61b4      	str	r4, [r6, #24]
    char *argv[MAX_CMD_ARGS] = {0};
    8ed0:	2220      	movs	r2, #32
    8ed2:	4629      	mov	r1, r5
    8ed4:	a805      	add	r0, sp, #20
    8ed6:	f018 fe51 	bl	21b7c <memset>
    const void* cmdIoParam = pCmdIO->devNode.cmdIoParam;
    8eda:	6873      	ldr	r3, [r6, #4]
    8edc:	9303      	str	r3, [sp, #12]
    strncpy(saveCmd, pCmdIO->cmdBuff, sizeof(saveCmd));     // make a copy of the command
    8ede:	2251      	movs	r2, #81	; 0x51
    8ee0:	4621      	mov	r1, r4
    8ee2:	a80d      	add	r0, sp, #52	; 0x34
    8ee4:	f017 f9af 	bl	20246 <strncpy>
    8ee8:	ac0d      	add	r4, sp, #52	; 0x34
            *qStart = 0;
    8eea:	46ab      	mov	fp, r5
            str = 0;
    8eec:	9501      	str	r5, [sp, #4]
    8eee:	e01e      	b.n	8f2e <SYS_CMD_Tasks+0x13e>
            (*pCmdApi->msg)(cmdIoParam, LINE_TERM _promptStr);
    8ef0:	f8da 3000 	ldr.w	r3, [sl]
    8ef4:	4979      	ldr	r1, [pc, #484]	; (90dc <SYS_CMD_Tasks+0x2ec>)
    8ef6:	4648      	mov	r0, r9
    8ef8:	4798      	blx	r3
            return;
    8efa:	e040      	b.n	8f7e <SYS_CMD_Tasks+0x18e>
        if(qStart == 0)
    8efc:	b397      	cbz	r7, 8f64 <SYS_CMD_Tasks+0x174>
        qStart++;
    8efe:	3701      	adds	r7, #1
        qEnd = strchr(qStart, '"');
    8f00:	2122      	movs	r1, #34	; 0x22
    8f02:	4638      	mov	r0, r7
    8f04:	f018 f9a7 	bl	21256 <strchr>
        if(qEnd == 0 || qEnd - qStart == 0)
    8f08:	4604      	mov	r4, r0
    8f0a:	2800      	cmp	r0, #0
    8f0c:	f000 80f8 	beq.w	9100 <SYS_CMD_Tasks+0x310>
    8f10:	4287      	cmp	r7, r0
    8f12:	f000 80f5 	beq.w	9100 <SYS_CMD_Tasks+0x310>
        *qEnd = 0;
    8f16:	f880 b000 	strb.w	fp, [r0]
        if(nArgs < argvSize)
    8f1a:	2d07      	cmp	r5, #7
    8f1c:	d804      	bhi.n	8f28 <SYS_CMD_Tasks+0x138>
            argv[nArgs] = qStart;
    8f1e:	ab22      	add	r3, sp, #136	; 0x88
    8f20:	eb03 0385 	add.w	r3, r3, r5, lsl #2
    8f24:	f843 7c74 	str.w	r7, [r3, #-116]
        nArgs++;
    8f28:	3501      	adds	r5, #1
    while(str)
    8f2a:	3401      	adds	r4, #1
    8f2c:	d01a      	beq.n	8f64 <SYS_CMD_Tasks+0x174>
        qStart = strchr(str, '"');
    8f2e:	2122      	movs	r1, #34	; 0x22
    8f30:	4620      	mov	r0, r4
    8f32:	f018 f990 	bl	21256 <strchr>
        if(qStart != 0)
    8f36:	4607      	mov	r7, r0
    8f38:	b108      	cbz	r0, 8f3e <SYS_CMD_Tasks+0x14e>
            *qStart = 0;
    8f3a:	f880 b000 	strb.w	fp, [r0]
    8f3e:	ab05      	add	r3, sp, #20
    8f40:	eb03 0885 	add.w	r8, r3, r5, lsl #2
    8f44:	4620      	mov	r0, r4
        while((pTkn = strtok(str, " \t,")) != 0)
    8f46:	4966      	ldr	r1, [pc, #408]	; (90e0 <SYS_CMD_Tasks+0x2f0>)
    8f48:	f013 f878 	bl	1c03c <strtok>
    8f4c:	4603      	mov	r3, r0
    8f4e:	2800      	cmp	r0, #0
    8f50:	d0d4      	beq.n	8efc <SYS_CMD_Tasks+0x10c>
            if(nArgs < argvSize)
    8f52:	2d07      	cmp	r5, #7
                argv[nArgs] = pTkn;
    8f54:	bf98      	it	ls
    8f56:	f8c8 3000 	strls.w	r3, [r8]
            nArgs++;
    8f5a:	3501      	adds	r5, #1
    8f5c:	f108 0804 	add.w	r8, r8, #4
            str = 0;
    8f60:	9801      	ldr	r0, [sp, #4]
    8f62:	e7f0      	b.n	8f46 <SYS_CMD_Tasks+0x156>
    if(argc > MAX_CMD_ARGS)
    8f64:	2d08      	cmp	r5, #8
    8f66:	dd3d      	ble.n	8fe4 <SYS_CMD_Tasks+0x1f4>
        (*pCmdIO->devNode.pCmdApi->print)(cmdIoParam, "\n\r Too many arguments. Maximum args supported: %d!\r\n", MAX_CMD_ARGS);
    8f68:	6833      	ldr	r3, [r6, #0]
    8f6a:	685b      	ldr	r3, [r3, #4]
    8f6c:	2208      	movs	r2, #8
    8f6e:	495d      	ldr	r1, [pc, #372]	; (90e4 <SYS_CMD_Tasks+0x2f4>)
    8f70:	9803      	ldr	r0, [sp, #12]
    8f72:	4798      	blx	r3
        (*pCmdApi->msg)(cmdIoParam, _promptStr);
    8f74:	f8da 3000 	ldr.w	r3, [sl]
    8f78:	495b      	ldr	r1, [pc, #364]	; (90e8 <SYS_CMD_Tasks+0x2f8>)
    8f7a:	4648      	mov	r0, r9
    8f7c:	4798      	blx	r3
    for(pCmdIO = cmdIODevList.head; pCmdIO != 0; pCmdIO = pCmdIO->next)
    8f7e:	68b6      	ldr	r6, [r6, #8]
    8f80:	2e00      	cmp	r6, #0
    8f82:	f000 8138 	beq.w	91f6 <SYS_CMD_Tasks+0x406>
    const SYS_CMD_API* pCmdApi = pCmdIO->devNode.pCmdApi;
    8f86:	f8d6 a000 	ldr.w	sl, [r6]
    const void* cmdIoParam = pCmdIO->devNode.cmdIoParam;
    8f8a:	f8d6 9004 	ldr.w	r9, [r6, #4]
    if(!(*pCmdApi->isRdy)(cmdIoParam))
    8f8e:	f8da 300c 	ldr.w	r3, [sl, #12]
    8f92:	4648      	mov	r0, r9
    8f94:	4798      	blx	r3
    8f96:	2800      	cmp	r0, #0
    8f98:	d0f1      	beq.n	8f7e <SYS_CMD_Tasks+0x18e>
    newCh = (*pCmdApi->getc)(cmdIoParam); /* Read data from console. */
    8f9a:	f8da 3010 	ldr.w	r3, [sl, #16]
    8f9e:	4648      	mov	r0, r9
    8fa0:	4798      	blx	r3
    8fa2:	4604      	mov	r4, r0
    if(pCmdIO->seqChars != 0)
    8fa4:	f9b6 3010 	ldrsh.w	r3, [r6, #16]
    8fa8:	2b00      	cmp	r3, #0
    8faa:	f43f af42 	beq.w	8e32 <SYS_CMD_Tasks+0x42>
        pCmdIO->seqBuff[pCmdIO->seqChars] = newCh;
    8fae:	18f2      	adds	r2, r6, r3
    8fb0:	7490      	strb	r0, [r2, #18]
        pCmdIO->seqChars++;
    8fb2:	3301      	adds	r3, #1
    8fb4:	b21c      	sxth	r4, r3
    8fb6:	8234      	strh	r4, [r6, #16]
        if(pCmdIO->seqChars == VT100_DETECT_SEQ_SIZE)
    8fb8:	2c03      	cmp	r4, #3
    8fba:	f43f af25 	beq.w	8e08 <SYS_CMD_Tasks+0x18>
        if(pCmdIO->seqChars >= VT100_DETECT_SEQ_SIZE && pCmdIO->seqChars == pCmdIO->pSeqDcpt->keySize)
    8fbe:	2c02      	cmp	r4, #2
    8fc0:	dddd      	ble.n	8f7e <SYS_CMD_Tasks+0x18e>
    8fc2:	68f5      	ldr	r5, [r6, #12]
    8fc4:	68ab      	ldr	r3, [r5, #8]
    8fc6:	429c      	cmp	r4, r3
    8fc8:	d1d9      	bne.n	8f7e <SYS_CMD_Tasks+0x18e>
            if(strcmp(pCmdIO->seqBuff, pCmdIO->pSeqDcpt->keyCode) == 0)
    8fca:	6829      	ldr	r1, [r5, #0]
    8fcc:	f106 0012 	add.w	r0, r6, #18
    8fd0:	f018 fc94 	bl	218fc <strcmp>
    8fd4:	b918      	cbnz	r0, 8fde <SYS_CMD_Tasks+0x1ee>
                (*pCmdIO->pSeqDcpt->keyFnc)(pCmdIO, pCmdIO->pSeqDcpt);
    8fd6:	686b      	ldr	r3, [r5, #4]
    8fd8:	4629      	mov	r1, r5
    8fda:	4630      	mov	r0, r6
    8fdc:	4798      	blx	r3
            pCmdIO->seqChars = 0;
    8fde:	2300      	movs	r3, #0
    8fe0:	8233      	strh	r3, [r6, #16]
            return;
    8fe2:	e7cc      	b.n	8f7e <SYS_CMD_Tasks+0x18e>
    else if(argc == 0)
    8fe4:	b92d      	cbnz	r5, 8ff2 <SYS_CMD_Tasks+0x202>
        (*pCmdIO->devNode.pCmdApi->msg)(cmdIoParam, " *** Command Processor: Please type in a command***" LINE_TERM);
    8fe6:	6833      	ldr	r3, [r6, #0]
    8fe8:	681b      	ldr	r3, [r3, #0]
    8fea:	4940      	ldr	r1, [pc, #256]	; (90ec <SYS_CMD_Tasks+0x2fc>)
    8fec:	9803      	ldr	r0, [sp, #12]
    8fee:	4798      	blx	r3
    8ff0:	e7c0      	b.n	8f74 <SYS_CMD_Tasks+0x184>
        if(argc > 0)
    8ff2:	2d00      	cmp	r5, #0
    8ff4:	f340 8084 	ble.w	9100 <SYS_CMD_Tasks+0x310>
    if(pL->head == pL->tail)
    8ff8:	f8d6 30cc 	ldr.w	r3, [r6, #204]	; 0xcc
    8ffc:	f8d6 40d0 	ldr.w	r4, [r6, #208]	; 0xd0
    9000:	42a3      	cmp	r3, r4
    9002:	d02e      	beq.n	9062 <SYS_CMD_Tasks+0x272>
        pL->tail = pN->prev;
    9004:	6862      	ldr	r2, [r4, #4]
    9006:	f8c6 20d0 	str.w	r2, [r6, #208]	; 0xd0
        pL->tail->next = pL->head;
    900a:	6013      	str	r3, [r2, #0]
        pL->head->prev = pL->tail;
    900c:	f8d6 30cc 	ldr.w	r3, [r6, #204]	; 0xcc
    9010:	f8d6 20d0 	ldr.w	r2, [r6, #208]	; 0xd0
    9014:	605a      	str	r2, [r3, #4]
            strncpy(pN->cmdBuff, pCmdIO->cmdBuff, sizeof(saveCmd)); // Need save non-parsed string
    9016:	2251      	movs	r2, #81	; 0x51
    9018:	9902      	ldr	r1, [sp, #8]
    901a:	f104 0008 	add.w	r0, r4, #8
    901e:	f017 f912 	bl	20246 <strncpy>
    if(pL->head == 0)
    9022:	f8d6 30cc 	ldr.w	r3, [r6, #204]	; 0xcc
    9026:	b31b      	cbz	r3, 9070 <SYS_CMD_Tasks+0x280>
        pN->next = pL->head;
    9028:	6023      	str	r3, [r4, #0]
        pN->prev = pL->tail;
    902a:	f8d6 30d0 	ldr.w	r3, [r6, #208]	; 0xd0
    902e:	6063      	str	r3, [r4, #4]
        pL->tail->next = pN;
    9030:	601c      	str	r4, [r3, #0]
        pL->head->prev = pN;
    9032:	f8d6 30cc 	ldr.w	r3, [r6, #204]	; 0xcc
    9036:	605c      	str	r4, [r3, #4]
        pL->head = pN;
    9038:	f8c6 40cc 	str.w	r4, [r6, #204]	; 0xcc
            pCmdIO->currHistN = 0;
    903c:	2300      	movs	r3, #0
    903e:	f8c6 30d4 	str.w	r3, [r6, #212]	; 0xd4
                if(!strcmp(argv[0], pDcpt->cmdStr))
    9042:	9b05      	ldr	r3, [sp, #20]
    9044:	9301      	str	r3, [sp, #4]
            for(ix = 0, pDcpt = _builtinCmdTbl; ix < sizeof(_builtinCmdTbl)/sizeof(*_builtinCmdTbl); ix++, pDcpt++)
    9046:	4c2a      	ldr	r4, [pc, #168]	; (90f0 <SYS_CMD_Tasks+0x300>)
                if(!strcmp(argv[0], pDcpt->cmdStr))
    9048:	6821      	ldr	r1, [r4, #0]
    904a:	9801      	ldr	r0, [sp, #4]
    904c:	f018 fc56 	bl	218fc <strcmp>
    9050:	b1a8      	cbz	r0, 907e <SYS_CMD_Tasks+0x28e>
            for(ix = 0, pDcpt = _builtinCmdTbl; ix < sizeof(_builtinCmdTbl)/sizeof(*_builtinCmdTbl); ix++, pDcpt++)
    9052:	340c      	adds	r4, #12
    9054:	4b27      	ldr	r3, [pc, #156]	; (90f4 <SYS_CMD_Tasks+0x304>)
    9056:	429c      	cmp	r4, r3
    9058:	d1f6      	bne.n	9048 <SYS_CMD_Tasks+0x258>
    905a:	f8df b0a0 	ldr.w	fp, [pc, #160]	; 90fc <SYS_CMD_Tasks+0x30c>
    905e:	46a8      	mov	r8, r5
    9060:	e01e      	b.n	90a0 <SYS_CMD_Tasks+0x2b0>
        pL->head = pL->tail = 0;
    9062:	2200      	movs	r2, #0
    9064:	f8c6 20d0 	str.w	r2, [r6, #208]	; 0xd0
    9068:	f8c6 20cc 	str.w	r2, [r6, #204]	; 0xcc
        pN = pL->head;
    906c:	461c      	mov	r4, r3
    906e:	e7d2      	b.n	9016 <SYS_CMD_Tasks+0x226>
        pL->head = pL->tail = pN;
    9070:	f8c6 40d0 	str.w	r4, [r6, #208]	; 0xd0
    9074:	f8c6 40cc 	str.w	r4, [r6, #204]	; 0xcc
        pN->next = pN->prev = pN;
    9078:	6064      	str	r4, [r4, #4]
    907a:	6024      	str	r4, [r4, #0]
    907c:	e7de      	b.n	903c <SYS_CMD_Tasks+0x24c>
                    (*pDcpt->cmdFnc)(&pCmdIO->devNode, argc, argv);     // call command handler
    907e:	6863      	ldr	r3, [r4, #4]
    9080:	aa05      	add	r2, sp, #20
    9082:	4629      	mov	r1, r5
    9084:	4630      	mov	r0, r6
    9086:	4798      	blx	r3
                    return;
    9088:	e774      	b.n	8f74 <SYS_CMD_Tasks+0x184>
                        (*pDcpt->cmdFnc)(&pCmdIO->devNode, argc, argv);
    908a:	6863      	ldr	r3, [r4, #4]
    908c:	aa05      	add	r2, sp, #20
    908e:	4641      	mov	r1, r8
    9090:	4630      	mov	r0, r6
    9092:	4798      	blx	r3
                        return;
    9094:	e76e      	b.n	8f74 <SYS_CMD_Tasks+0x184>
    9096:	f10b 0b10 	add.w	fp, fp, #16
            for (grp_ix=0; grp_ix < MAX_CMD_GROUP; grp_ix++)
    909a:	4b17      	ldr	r3, [pc, #92]	; (90f8 <SYS_CMD_Tasks+0x308>)
    909c:	459b      	cmp	fp, r3
    909e:	d02f      	beq.n	9100 <SYS_CMD_Tasks+0x310>
                if (_usrCmdTbl[grp_ix].pCmd == 0)
    90a0:	f8db 4004 	ldr.w	r4, [fp, #4]
    90a4:	2c00      	cmp	r4, #0
    90a6:	d0f6      	beq.n	9096 <SYS_CMD_Tasks+0x2a6>
                for(ix = 0, pDcpt = _usrCmdTbl[grp_ix].pCmd; ix < _usrCmdTbl[grp_ix].nCmds; ix++, pDcpt++)
    90a8:	f8db 5000 	ldr.w	r5, [fp]
    90ac:	2d00      	cmp	r5, #0
    90ae:	ddf2      	ble.n	9096 <SYS_CMD_Tasks+0x2a6>
    90b0:	2700      	movs	r7, #0
                    if(!strcmp(argv[0], pDcpt->cmdStr))
    90b2:	6821      	ldr	r1, [r4, #0]
    90b4:	9801      	ldr	r0, [sp, #4]
    90b6:	f018 fc21 	bl	218fc <strcmp>
    90ba:	2800      	cmp	r0, #0
    90bc:	d0e5      	beq.n	908a <SYS_CMD_Tasks+0x29a>
                for(ix = 0, pDcpt = _usrCmdTbl[grp_ix].pCmd; ix < _usrCmdTbl[grp_ix].nCmds; ix++, pDcpt++)
    90be:	3701      	adds	r7, #1
    90c0:	340c      	adds	r4, #12
    90c2:	42af      	cmp	r7, r5
    90c4:	d1f5      	bne.n	90b2 <SYS_CMD_Tasks+0x2c2>
    90c6:	e7e6      	b.n	9096 <SYS_CMD_Tasks+0x2a6>
    90c8:	2000e560 	.word	0x2000e560
    90cc:	0001cd20 	.word	0x0001cd20
    90d0:	0001cd68 	.word	0x0001cd68
    90d4:	0000d2dc 	.word	0x0000d2dc
    90d8:	0000d18c 	.word	0x0000d18c
    90dc:	0000d120 	.word	0x0000d120
    90e0:	0000d214 	.word	0x0000d214
    90e4:	0000d218 	.word	0x0000d218
    90e8:	0000d2b8 	.word	0x0000d2b8
    90ec:	0000d250 	.word	0x0000d250
    90f0:	0002041c 	.word	0x0002041c
    90f4:	00020440 	.word	0x00020440
    90f8:	2000e018 	.word	0x2000e018
    90fc:	2000df98 	.word	0x2000df98
        (*pCmdIO->devNode.pCmdApi->msg)(cmdIoParam, " *** Command Processor: unknown command. ***\r\n");
    9100:	6833      	ldr	r3, [r6, #0]
    9102:	681b      	ldr	r3, [r3, #0]
    9104:	493e      	ldr	r1, [pc, #248]	; (9200 <SYS_CMD_Tasks+0x410>)
    9106:	9803      	ldr	r0, [sp, #12]
    9108:	4798      	blx	r3
    910a:	e733      	b.n	8f74 <SYS_CMD_Tasks+0x184>
        if(pCmdIO->cmdPnt > pCmdIO->cmdBuff)
    910c:	69b1      	ldr	r1, [r6, #24]
    910e:	f106 0320 	add.w	r3, r6, #32
    9112:	4299      	cmp	r1, r3
    9114:	f67f af33 	bls.w	8f7e <SYS_CMD_Tasks+0x18e>
            if(pCmdIO->cmdEnd > pCmdIO->cmdPnt)
    9118:	69f3      	ldr	r3, [r6, #28]
    911a:	4299      	cmp	r1, r3
    911c:	d221      	bcs.n	9162 <SYS_CMD_Tasks+0x372>
                char* pDst = pCmdIO->cmdPnt - 1;
    911e:	1e4a      	subs	r2, r1, #1
                len = pCmdIO->cmdEnd - pSrc;
    9120:	1a5b      	subs	r3, r3, r1
                for(ix = 0; ix < len; ix++)
    9122:	2b00      	cmp	r3, #0
    9124:	dd07      	ble.n	9136 <SYS_CMD_Tasks+0x346>
    9126:	1e58      	subs	r0, r3, #1
    9128:	4401      	add	r1, r0
                    *pDst++ = *pSrc++;
    912a:	f812 0f01 	ldrb.w	r0, [r2, #1]!
    912e:	f802 0c01 	strb.w	r0, [r2, #-1]
                for(ix = 0; ix < len; ix++)
    9132:	428a      	cmp	r2, r1
    9134:	d1f9      	bne.n	912a <SYS_CMD_Tasks+0x33a>
                pCmdIO->cmdPnt--; pCmdIO->cmdEnd--;
    9136:	69b2      	ldr	r2, [r6, #24]
    9138:	3a01      	subs	r2, #1
    913a:	61b2      	str	r2, [r6, #24]
    913c:	69f2      	ldr	r2, [r6, #28]
    913e:	1e51      	subs	r1, r2, #1
    9140:	61f1      	str	r1, [r6, #28]
                *pCmdIO->cmdEnd = '\0';
    9142:	2100      	movs	r1, #0
    9144:	f802 1c01 	strb.w	r1, [r2, #-1]
                sprintf(pCmdIO->ctrlBuff, "\b\x1b[K%s\x1b[%dD", pCmdIO->cmdPnt, len);
    9148:	f106 0471 	add.w	r4, r6, #113	; 0x71
    914c:	69b2      	ldr	r2, [r6, #24]
    914e:	492d      	ldr	r1, [pc, #180]	; (9204 <SYS_CMD_Tasks+0x414>)
    9150:	4620      	mov	r0, r4
    9152:	f014 f9f9 	bl	1d548 <siprintf>
                (*pCmdApi->msg)(cmdIoParam, pCmdIO->ctrlBuff);
    9156:	f8da 3000 	ldr.w	r3, [sl]
    915a:	4621      	mov	r1, r4
    915c:	4648      	mov	r0, r9
    915e:	4798      	blx	r3
    9160:	e70d      	b.n	8f7e <SYS_CMD_Tasks+0x18e>
                (*pCmdApi->msg)(cmdIoParam, "\b\x1b[K");
    9162:	f8da 3000 	ldr.w	r3, [sl]
    9166:	4928      	ldr	r1, [pc, #160]	; (9208 <SYS_CMD_Tasks+0x418>)
    9168:	4648      	mov	r0, r9
    916a:	4798      	blx	r3
                pCmdIO->cmdPnt--; pCmdIO->cmdEnd--;
    916c:	69b3      	ldr	r3, [r6, #24]
    916e:	3b01      	subs	r3, #1
    9170:	61b3      	str	r3, [r6, #24]
    9172:	69f3      	ldr	r3, [r6, #28]
    9174:	3b01      	subs	r3, #1
    9176:	61f3      	str	r3, [r6, #28]
    9178:	e701      	b.n	8f7e <SYS_CMD_Tasks+0x18e>
        if(pCmdIO->cmdEnd > pCmdIO->cmdPnt)
    917a:	69f3      	ldr	r3, [r6, #28]
    917c:	69b2      	ldr	r2, [r6, #24]
    917e:	4293      	cmp	r3, r2
    9180:	f67f aefd 	bls.w	8f7e <SYS_CMD_Tasks+0x18e>
            char* pSrc = pCmdIO->cmdPnt + 1;
    9184:	1c51      	adds	r1, r2, #1
            len = pCmdIO->cmdEnd - pSrc;
    9186:	1a5b      	subs	r3, r3, r1
            for(ix = 0; ix < len; ix++)
    9188:	2b00      	cmp	r3, #0
    918a:	dd06      	ble.n	919a <SYS_CMD_Tasks+0x3aa>
    918c:	18d0      	adds	r0, r2, r3
                *pDst++ = *pSrc++;
    918e:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    9192:	f802 1c01 	strb.w	r1, [r2, #-1]
            for(ix = 0; ix < len; ix++)
    9196:	4282      	cmp	r2, r0
    9198:	d1f9      	bne.n	918e <SYS_CMD_Tasks+0x39e>
            pCmdIO->cmdEnd--;
    919a:	69f2      	ldr	r2, [r6, #28]
    919c:	1e51      	subs	r1, r2, #1
    919e:	61f1      	str	r1, [r6, #28]
            *pCmdIO->cmdEnd = '\0';
    91a0:	2100      	movs	r1, #0
    91a2:	f802 1c01 	strb.w	r1, [r2, #-1]
            sprintf(pCmdIO->ctrlBuff, "\x1b[K%s\x1b[%dD", pCmdIO->cmdPnt, len);
    91a6:	f106 0471 	add.w	r4, r6, #113	; 0x71
    91aa:	69b2      	ldr	r2, [r6, #24]
    91ac:	4917      	ldr	r1, [pc, #92]	; (920c <SYS_CMD_Tasks+0x41c>)
    91ae:	4620      	mov	r0, r4
    91b0:	f014 f9ca 	bl	1d548 <siprintf>
            (*pCmdApi->msg)(cmdIoParam, pCmdIO->ctrlBuff);
    91b4:	f8da 3000 	ldr.w	r3, [sl]
    91b8:	4621      	mov	r1, r4
    91ba:	4648      	mov	r0, r9
    91bc:	4798      	blx	r3
    91be:	e6de      	b.n	8f7e <SYS_CMD_Tasks+0x18e>
        pCmdIO->seqBuff[0] = newCh;
    91c0:	231b      	movs	r3, #27
    91c2:	74b3      	strb	r3, [r6, #18]
        pCmdIO->seqChars = 1;
    91c4:	2301      	movs	r3, #1
    91c6:	8233      	strh	r3, [r6, #16]
    91c8:	e6d9      	b.n	8f7e <SYS_CMD_Tasks+0x18e>
            pCmdIO->ctrlBuff[1] = 0;
    91ca:	2300      	movs	r3, #0
    91cc:	f886 3072 	strb.w	r3, [r6, #114]	; 0x72
    91d0:	e65b      	b.n	8e8a <SYS_CMD_Tasks+0x9a>
        (*pCmdApi->msg)(cmdIoParam, " *** Command Processor buffer exceeded. Retry. ***" LINE_TERM);
    91d2:	4c0f      	ldr	r4, [pc, #60]	; (9210 <SYS_CMD_Tasks+0x420>)
    91d4:	f8da 3000 	ldr.w	r3, [sl]
    91d8:	f504 71e6 	add.w	r1, r4, #460	; 0x1cc
    91dc:	4648      	mov	r0, r9
    91de:	4798      	blx	r3
        pCmdIO->cmdPnt = pCmdIO->cmdEnd = pCmdIO->cmdBuff;
    91e0:	61f5      	str	r5, [r6, #28]
    91e2:	61b5      	str	r5, [r6, #24]
        (*pCmdApi->msg)(cmdIoParam, _promptStr);
    91e4:	f8da 3000 	ldr.w	r3, [sl]
    91e8:	f504 71d0 	add.w	r1, r4, #416	; 0x1a0
    91ec:	4648      	mov	r0, r9
    91ee:	4798      	blx	r3
    91f0:	e6c5      	b.n	8f7e <SYS_CMD_Tasks+0x18e>
            pCmdIO->pSeqDcpt = pFoundSeq;
    91f2:	60f5      	str	r5, [r6, #12]
        if(pCmdIO->seqChars >= VT100_DETECT_SEQ_SIZE && pCmdIO->seqChars == pCmdIO->pSeqDcpt->keySize)
    91f4:	e6e5      	b.n	8fc2 <SYS_CMD_Tasks+0x1d2>
}
    91f6:	2001      	movs	r0, #1
    91f8:	b023      	add	sp, #140	; 0x8c
    91fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    91fe:	bf00      	nop
    9200:	0000d288 	.word	0x0000d288
    9204:	0000d2bc 	.word	0x0000d2bc
    9208:	0000d2c8 	.word	0x0000d2c8
    920c:	0000d2d0 	.word	0x0000d2d0
    9210:	0000d118 	.word	0x0000d118

Disassembly of section .text%204:

00009214 <__aeabi_dmul>:
    9214:	b570      	push	{r4, r5, r6, lr}
    9216:	f04f 0cff 	mov.w	ip, #255	; 0xff
    921a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    921e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    9222:	bf1d      	ittte	ne
    9224:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    9228:	ea94 0f0c 	teqne	r4, ip
    922c:	ea95 0f0c 	teqne	r5, ip
    9230:	f000 f8de 	bleq	93f0 <__aeabi_dmul+0x1dc>
    9234:	442c      	add	r4, r5
    9236:	ea81 0603 	eor.w	r6, r1, r3
    923a:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
    923e:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
    9242:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
    9246:	bf18      	it	ne
    9248:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
    924c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    9250:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    9254:	d038      	beq.n	92c8 <__aeabi_dmul+0xb4>
    9256:	fba0 ce02 	umull	ip, lr, r0, r2
    925a:	f04f 0500 	mov.w	r5, #0
    925e:	fbe1 e502 	umlal	lr, r5, r1, r2
    9262:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
    9266:	fbe0 e503 	umlal	lr, r5, r0, r3
    926a:	f04f 0600 	mov.w	r6, #0
    926e:	fbe1 5603 	umlal	r5, r6, r1, r3
    9272:	f09c 0f00 	teq	ip, #0
    9276:	bf18      	it	ne
    9278:	f04e 0e01 	orrne.w	lr, lr, #1
    927c:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
    9280:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
    9284:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
    9288:	d204      	bcs.n	9294 <__aeabi_dmul+0x80>
    928a:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
    928e:	416d      	adcs	r5, r5
    9290:	eb46 0606 	adc.w	r6, r6, r6
    9294:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
    9298:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
    929c:	ea4f 20c5 	mov.w	r0, r5, lsl #11
    92a0:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
    92a4:	ea4f 2ece 	mov.w	lr, lr, lsl #11
    92a8:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    92ac:	bf88      	it	hi
    92ae:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    92b2:	d81e      	bhi.n	92f2 <__aeabi_dmul+0xde>
    92b4:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
    92b8:	bf08      	it	eq
    92ba:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
    92be:	f150 0000 	adcs.w	r0, r0, #0
    92c2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    92c6:	bd70      	pop	{r4, r5, r6, pc}
    92c8:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
    92cc:	ea46 0101 	orr.w	r1, r6, r1
    92d0:	ea40 0002 	orr.w	r0, r0, r2
    92d4:	ea81 0103 	eor.w	r1, r1, r3
    92d8:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
    92dc:	bfc2      	ittt	gt
    92de:	ebd4 050c 	rsbsgt	r5, r4, ip
    92e2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    92e6:	bd70      	popgt	{r4, r5, r6, pc}
    92e8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    92ec:	f04f 0e00 	mov.w	lr, #0
    92f0:	3c01      	subs	r4, #1
    92f2:	f300 80ab 	bgt.w	944c <__aeabi_dmul+0x238>
    92f6:	f114 0f36 	cmn.w	r4, #54	; 0x36
    92fa:	bfde      	ittt	le
    92fc:	2000      	movle	r0, #0
    92fe:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
    9302:	bd70      	pople	{r4, r5, r6, pc}
    9304:	f1c4 0400 	rsb	r4, r4, #0
    9308:	3c20      	subs	r4, #32
    930a:	da35      	bge.n	9378 <__aeabi_dmul+0x164>
    930c:	340c      	adds	r4, #12
    930e:	dc1b      	bgt.n	9348 <__aeabi_dmul+0x134>
    9310:	f104 0414 	add.w	r4, r4, #20
    9314:	f1c4 0520 	rsb	r5, r4, #32
    9318:	fa00 f305 	lsl.w	r3, r0, r5
    931c:	fa20 f004 	lsr.w	r0, r0, r4
    9320:	fa01 f205 	lsl.w	r2, r1, r5
    9324:	ea40 0002 	orr.w	r0, r0, r2
    9328:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
    932c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    9330:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    9334:	fa21 f604 	lsr.w	r6, r1, r4
    9338:	eb42 0106 	adc.w	r1, r2, r6
    933c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    9340:	bf08      	it	eq
    9342:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    9346:	bd70      	pop	{r4, r5, r6, pc}
    9348:	f1c4 040c 	rsb	r4, r4, #12
    934c:	f1c4 0520 	rsb	r5, r4, #32
    9350:	fa00 f304 	lsl.w	r3, r0, r4
    9354:	fa20 f005 	lsr.w	r0, r0, r5
    9358:	fa01 f204 	lsl.w	r2, r1, r4
    935c:	ea40 0002 	orr.w	r0, r0, r2
    9360:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    9364:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    9368:	f141 0100 	adc.w	r1, r1, #0
    936c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    9370:	bf08      	it	eq
    9372:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    9376:	bd70      	pop	{r4, r5, r6, pc}
    9378:	f1c4 0520 	rsb	r5, r4, #32
    937c:	fa00 f205 	lsl.w	r2, r0, r5
    9380:	ea4e 0e02 	orr.w	lr, lr, r2
    9384:	fa20 f304 	lsr.w	r3, r0, r4
    9388:	fa01 f205 	lsl.w	r2, r1, r5
    938c:	ea43 0302 	orr.w	r3, r3, r2
    9390:	fa21 f004 	lsr.w	r0, r1, r4
    9394:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    9398:	fa21 f204 	lsr.w	r2, r1, r4
    939c:	ea20 0002 	bic.w	r0, r0, r2
    93a0:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
    93a4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    93a8:	bf08      	it	eq
    93aa:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    93ae:	bd70      	pop	{r4, r5, r6, pc}
    93b0:	f094 0f00 	teq	r4, #0
    93b4:	d10f      	bne.n	93d6 <__aeabi_dmul+0x1c2>
    93b6:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
    93ba:	0040      	lsls	r0, r0, #1
    93bc:	eb41 0101 	adc.w	r1, r1, r1
    93c0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    93c4:	bf08      	it	eq
    93c6:	3c01      	subeq	r4, #1
    93c8:	d0f7      	beq.n	93ba <__aeabi_dmul+0x1a6>
    93ca:	ea41 0106 	orr.w	r1, r1, r6
    93ce:	f095 0f00 	teq	r5, #0
    93d2:	bf18      	it	ne
    93d4:	4770      	bxne	lr
    93d6:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
    93da:	0052      	lsls	r2, r2, #1
    93dc:	eb43 0303 	adc.w	r3, r3, r3
    93e0:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    93e4:	bf08      	it	eq
    93e6:	3d01      	subeq	r5, #1
    93e8:	d0f7      	beq.n	93da <__aeabi_dmul+0x1c6>
    93ea:	ea43 0306 	orr.w	r3, r3, r6
    93ee:	4770      	bx	lr
    93f0:	ea94 0f0c 	teq	r4, ip
    93f4:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    93f8:	bf18      	it	ne
    93fa:	ea95 0f0c 	teqne	r5, ip
    93fe:	d00c      	beq.n	941a <__aeabi_dmul+0x206>
    9400:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    9404:	bf18      	it	ne
    9406:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    940a:	d1d1      	bne.n	93b0 <__aeabi_dmul+0x19c>
    940c:	ea81 0103 	eor.w	r1, r1, r3
    9410:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    9414:	f04f 0000 	mov.w	r0, #0
    9418:	bd70      	pop	{r4, r5, r6, pc}
    941a:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    941e:	bf06      	itte	eq
    9420:	4610      	moveq	r0, r2
    9422:	4619      	moveq	r1, r3
    9424:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    9428:	d019      	beq.n	945e <__aeabi_dmul+0x24a>
    942a:	ea94 0f0c 	teq	r4, ip
    942e:	d102      	bne.n	9436 <__aeabi_dmul+0x222>
    9430:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
    9434:	d113      	bne.n	945e <__aeabi_dmul+0x24a>
    9436:	ea95 0f0c 	teq	r5, ip
    943a:	d105      	bne.n	9448 <__aeabi_dmul+0x234>
    943c:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
    9440:	bf1c      	itt	ne
    9442:	4610      	movne	r0, r2
    9444:	4619      	movne	r1, r3
    9446:	d10a      	bne.n	945e <__aeabi_dmul+0x24a>
    9448:	ea81 0103 	eor.w	r1, r1, r3
    944c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    9450:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    9454:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    9458:	f04f 0000 	mov.w	r0, #0
    945c:	bd70      	pop	{r4, r5, r6, pc}
    945e:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    9462:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
    9466:	bd70      	pop	{r4, r5, r6, pc}

00009468 <__aeabi_ddiv>:
    9468:	b570      	push	{r4, r5, r6, lr}
    946a:	f04f 0cff 	mov.w	ip, #255	; 0xff
    946e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    9472:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    9476:	bf1d      	ittte	ne
    9478:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    947c:	ea94 0f0c 	teqne	r4, ip
    9480:	ea95 0f0c 	teqne	r5, ip
    9484:	f000 f8a7 	bleq	95d6 <__aeabi_ddiv+0x16e>
    9488:	eba4 0405 	sub.w	r4, r4, r5
    948c:	ea81 0e03 	eor.w	lr, r1, r3
    9490:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    9494:	ea4f 3101 	mov.w	r1, r1, lsl #12
    9498:	f000 8088 	beq.w	95ac <__aeabi_ddiv+0x144>
    949c:	ea4f 3303 	mov.w	r3, r3, lsl #12
    94a0:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
    94a4:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
    94a8:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    94ac:	ea4f 2202 	mov.w	r2, r2, lsl #8
    94b0:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
    94b4:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
    94b8:	ea4f 2600 	mov.w	r6, r0, lsl #8
    94bc:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
    94c0:	429d      	cmp	r5, r3
    94c2:	bf08      	it	eq
    94c4:	4296      	cmpeq	r6, r2
    94c6:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
    94ca:	f504 7440 	add.w	r4, r4, #768	; 0x300
    94ce:	d202      	bcs.n	94d6 <__aeabi_ddiv+0x6e>
    94d0:	085b      	lsrs	r3, r3, #1
    94d2:	ea4f 0232 	mov.w	r2, r2, rrx
    94d6:	1ab6      	subs	r6, r6, r2
    94d8:	eb65 0503 	sbc.w	r5, r5, r3
    94dc:	085b      	lsrs	r3, r3, #1
    94de:	ea4f 0232 	mov.w	r2, r2, rrx
    94e2:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    94e6:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
    94ea:	ebb6 0e02 	subs.w	lr, r6, r2
    94ee:	eb75 0e03 	sbcs.w	lr, r5, r3
    94f2:	bf22      	ittt	cs
    94f4:	1ab6      	subcs	r6, r6, r2
    94f6:	4675      	movcs	r5, lr
    94f8:	ea40 000c 	orrcs.w	r0, r0, ip
    94fc:	085b      	lsrs	r3, r3, #1
    94fe:	ea4f 0232 	mov.w	r2, r2, rrx
    9502:	ebb6 0e02 	subs.w	lr, r6, r2
    9506:	eb75 0e03 	sbcs.w	lr, r5, r3
    950a:	bf22      	ittt	cs
    950c:	1ab6      	subcs	r6, r6, r2
    950e:	4675      	movcs	r5, lr
    9510:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    9514:	085b      	lsrs	r3, r3, #1
    9516:	ea4f 0232 	mov.w	r2, r2, rrx
    951a:	ebb6 0e02 	subs.w	lr, r6, r2
    951e:	eb75 0e03 	sbcs.w	lr, r5, r3
    9522:	bf22      	ittt	cs
    9524:	1ab6      	subcs	r6, r6, r2
    9526:	4675      	movcs	r5, lr
    9528:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    952c:	085b      	lsrs	r3, r3, #1
    952e:	ea4f 0232 	mov.w	r2, r2, rrx
    9532:	ebb6 0e02 	subs.w	lr, r6, r2
    9536:	eb75 0e03 	sbcs.w	lr, r5, r3
    953a:	bf22      	ittt	cs
    953c:	1ab6      	subcs	r6, r6, r2
    953e:	4675      	movcs	r5, lr
    9540:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    9544:	ea55 0e06 	orrs.w	lr, r5, r6
    9548:	d018      	beq.n	957c <__aeabi_ddiv+0x114>
    954a:	ea4f 1505 	mov.w	r5, r5, lsl #4
    954e:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
    9552:	ea4f 1606 	mov.w	r6, r6, lsl #4
    9556:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    955a:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
    955e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    9562:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
    9566:	d1c0      	bne.n	94ea <__aeabi_ddiv+0x82>
    9568:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    956c:	d10b      	bne.n	9586 <__aeabi_ddiv+0x11e>
    956e:	ea41 0100 	orr.w	r1, r1, r0
    9572:	f04f 0000 	mov.w	r0, #0
    9576:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
    957a:	e7b6      	b.n	94ea <__aeabi_ddiv+0x82>
    957c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    9580:	bf04      	itt	eq
    9582:	4301      	orreq	r1, r0
    9584:	2000      	moveq	r0, #0
    9586:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    958a:	bf88      	it	hi
    958c:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    9590:	f63f aeaf 	bhi.w	92f2 <__aeabi_dmul+0xde>
    9594:	ebb5 0c03 	subs.w	ip, r5, r3
    9598:	bf04      	itt	eq
    959a:	ebb6 0c02 	subseq.w	ip, r6, r2
    959e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    95a2:	f150 0000 	adcs.w	r0, r0, #0
    95a6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    95aa:	bd70      	pop	{r4, r5, r6, pc}
    95ac:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
    95b0:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
    95b4:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
    95b8:	bfc2      	ittt	gt
    95ba:	ebd4 050c 	rsbsgt	r5, r4, ip
    95be:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    95c2:	bd70      	popgt	{r4, r5, r6, pc}
    95c4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    95c8:	f04f 0e00 	mov.w	lr, #0
    95cc:	3c01      	subs	r4, #1
    95ce:	e690      	b.n	92f2 <__aeabi_dmul+0xde>
    95d0:	ea45 0e06 	orr.w	lr, r5, r6
    95d4:	e68d      	b.n	92f2 <__aeabi_dmul+0xde>
    95d6:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    95da:	ea94 0f0c 	teq	r4, ip
    95de:	bf08      	it	eq
    95e0:	ea95 0f0c 	teqeq	r5, ip
    95e4:	f43f af3b 	beq.w	945e <__aeabi_dmul+0x24a>
    95e8:	ea94 0f0c 	teq	r4, ip
    95ec:	d10a      	bne.n	9604 <__aeabi_ddiv+0x19c>
    95ee:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    95f2:	f47f af34 	bne.w	945e <__aeabi_dmul+0x24a>
    95f6:	ea95 0f0c 	teq	r5, ip
    95fa:	f47f af25 	bne.w	9448 <__aeabi_dmul+0x234>
    95fe:	4610      	mov	r0, r2
    9600:	4619      	mov	r1, r3
    9602:	e72c      	b.n	945e <__aeabi_dmul+0x24a>
    9604:	ea95 0f0c 	teq	r5, ip
    9608:	d106      	bne.n	9618 <__aeabi_ddiv+0x1b0>
    960a:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    960e:	f43f aefd 	beq.w	940c <__aeabi_dmul+0x1f8>
    9612:	4610      	mov	r0, r2
    9614:	4619      	mov	r1, r3
    9616:	e722      	b.n	945e <__aeabi_dmul+0x24a>
    9618:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    961c:	bf18      	it	ne
    961e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    9622:	f47f aec5 	bne.w	93b0 <__aeabi_dmul+0x19c>
    9626:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
    962a:	f47f af0d 	bne.w	9448 <__aeabi_dmul+0x234>
    962e:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
    9632:	f47f aeeb 	bne.w	940c <__aeabi_dmul+0x1f8>
    9636:	e712      	b.n	945e <__aeabi_dmul+0x24a>

Disassembly of section .text._DNS_ProcessPacket%205:

00009638 <_DNS_ProcessPacket>:

// process a DNS packet
// returns true if info updated
// false if no entry was completed
static bool _DNS_ProcessPacket(TCPIP_DNS_DCPT* pDnsDcpt)
{
    9638:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    963c:	f5ad 7d29 	sub.w	sp, sp, #676	; 0x2a4
    9640:	9004      	str	r0, [sp, #16]
    TCPIP_DNS_DBG_EVENT_TYPE evDbgType = TCPIP_DNS_DBG_EVENT_NONE;
    TCPIP_DNS_RR_PROCESS    procRR;


    // Get DNS Reply packet
    dnsPacketSize = TCPIP_UDP_ArrayGet(pDnsDcpt->dnsSocket, dnsRxBuffer, sizeof(dnsRxBuffer));
    9642:	ae22      	add	r6, sp, #136	; 0x88
    9644:	f44f 7200 	mov.w	r2, #512	; 0x200
    9648:	4631      	mov	r1, r6
    964a:	f9b0 0024 	ldrsh.w	r0, [r0, #36]	; 0x24
    964e:	f00b fc09 	bl	14e64 <TCPIP_UDP_ArrayGet>
    rxData->head = rxData->rdPtr = buffer;
    9652:	96a3      	str	r6, [sp, #652]	; 0x28c
    9654:	96a2      	str	r6, [sp, #648]	; 0x288
    rxData->endPtr = buffer + bufferSize;
    9656:	4406      	add	r6, r0
    9658:	96a4      	str	r6, [sp, #656]	; 0x290

    _DNSInitRxData(&dnsRxData, dnsRxBuffer, dnsPacketSize);

    // Retrieve the DNS header and de-big-endian it
    if(!_DNSGetData(&dnsRxData, &DNSHeader, sizeof(DNSHeader)))
    965a:	220c      	movs	r2, #12
    965c:	a9a5      	add	r1, sp, #660	; 0x294
    965e:	a8a2      	add	r0, sp, #648	; 0x288
    9660:	f015 f962 	bl	1e928 <_DNSGetData>
    9664:	9001      	str	r0, [sp, #4]
    9666:	b920      	cbnz	r0, 9672 <_DNS_ProcessPacket+0x3a>
    {
        _DNS_DbgEvent(pDnsDcpt, dnsHE, evDbgType);
    }

    return !procFail;
}
    9668:	9801      	ldr	r0, [sp, #4]
    966a:	f50d 7d29 	add.w	sp, sp, #676	; 0x2a4
    966e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    p->TransactionID.Val = TCPIP_Helper_htons(p->TransactionID.Val);
    9672:	f8bd 2294 	ldrh.w	r2, [sp, #660]	; 0x294
    9676:	0a13      	lsrs	r3, r2, #8
    9678:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    967c:	f8ad 3294 	strh.w	r3, [sp, #660]	; 0x294
    p->Flags.Val = TCPIP_Helper_htons(p->Flags.Val);
    9680:	f8bd 2296 	ldrh.w	r2, [sp, #662]	; 0x296
    9684:	0a13      	lsrs	r3, r2, #8
    9686:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    968a:	b21b      	sxth	r3, r3
    968c:	f8ad 3296 	strh.w	r3, [sp, #662]	; 0x296
    p->AdditionalRecords.Val = TCPIP_Helper_htons(p->AdditionalRecords.Val);
    9690:	f8bd 129e 	ldrh.w	r1, [sp, #670]	; 0x29e
    9694:	0a0a      	lsrs	r2, r1, #8
    9696:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    969a:	f8ad 229e 	strh.w	r2, [sp, #670]	; 0x29e
    p->Answers.Val = TCPIP_Helper_htons(p->Answers.Val);
    969e:	f8bd 129a 	ldrh.w	r1, [sp, #666]	; 0x29a
    96a2:	0a0a      	lsrs	r2, r1, #8
    96a4:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    96a8:	f8ad 229a 	strh.w	r2, [sp, #666]	; 0x29a
    p->AuthoritativeRecords.Val = TCPIP_Helper_htons(p->AuthoritativeRecords.Val);
    96ac:	f8bd 129c 	ldrh.w	r1, [sp, #668]	; 0x29c
    96b0:	0a0a      	lsrs	r2, r1, #8
    96b2:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    96b6:	f8ad 229c 	strh.w	r2, [sp, #668]	; 0x29c
    p->Questions.Val = TCPIP_Helper_htons(p->Questions.Val);
    96ba:	f8bd 1298 	ldrh.w	r1, [sp, #664]	; 0x298
    96be:	0a0a      	lsrs	r2, r1, #8
    96c0:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    96c4:	f8ad 2298 	strh.w	r2, [sp, #664]	; 0x298
        if((DNSHeader.Flags.v[0] & 0x03) != 0)
    96c8:	f013 0f03 	tst.w	r3, #3
    96cc:	d13c      	bne.n	9748 <_DNS_ProcessPacket+0x110>
    procRR.dnsHE = 0;
    96ce:	f04f 0b00 	mov.w	fp, #0
        for(ix = TCPIP_DNS_RR_TYPE_QUESTION; ix < TCPIP_DNS_RR_TYPES; ix++) 
    96d2:	f8cd b00c 	str.w	fp, [sp, #12]
                nameLen++;
            }
        }
        if(discardLen != 0)
        {
            if(!_DNSGetData(xtractBuff, 0, discardLen))
    96d6:	f8cd b000 	str.w	fp, [sp]
    96da:	9607      	str	r6, [sp, #28]
    96dc:	e116      	b.n	990c <_DNS_ProcessPacket+0x2d4>
           nRR = pProc->dnsHeader->Questions.Val;
    96de:	f8bd 3298 	ldrh.w	r3, [sp, #664]	; 0x298
    96e2:	9305      	str	r3, [sp, #20]
    while(nRR--)
    96e4:	b93b      	cbnz	r3, 96f6 <_DNS_ProcessPacket+0xbe>
    96e6:	e02f      	b.n	9748 <_DNS_ProcessPacket+0x110>
           nRR = pProc->dnsHeader->Answers.Val;
    96e8:	f8bd 329a 	ldrh.w	r3, [sp, #666]	; 0x29a
    96ec:	9305      	str	r3, [sp, #20]
    while(nRR--)
    96ee:	9b05      	ldr	r3, [sp, #20]
    96f0:	2b00      	cmp	r3, #0
    96f2:	f000 8106 	beq.w	9902 <_DNS_ProcessPacket+0x2ca>
        for(ix = TCPIP_DNS_RR_TYPE_QUESTION; ix < TCPIP_DNS_RR_TYPES; ix++) 
    96f6:	f04f 0900 	mov.w	r9, #0
        *wPtr = 0;
    96fa:	f04f 0300 	mov.w	r3, #0
    96fe:	f88d 301b 	strb.w	r3, [sp, #27]
    9702:	e167      	b.n	99d4 <_DNS_ProcessPacket+0x39c>
           nRR = pProc->dnsHeader->AuthoritativeRecords.Val;
    9704:	f8bd 329c 	ldrh.w	r3, [sp, #668]	; 0x29c
    9708:	9305      	str	r3, [sp, #20]
           break;
    970a:	e7f0      	b.n	96ee <_DNS_ProcessPacket+0xb6>
           nRR = pProc->dnsHeader->AdditionalRecords.Val;
    970c:	f8bd 329e 	ldrh.w	r3, [sp, #670]	; 0x29e
    9710:	9305      	str	r3, [sp, #20]
           break;
    9712:	e7ec      	b.n	96ee <_DNS_ProcessPacket+0xb6>
            xtractBuff = &pktBuff;
    9714:	f10d 0834 	add.w	r8, sp, #52	; 0x34
    9718:	e022      	b.n	9760 <_DNS_ProcessPacket+0x128>
            labelOffset = (uint16_t)(labelLen & 0x3f) << 8;
    971a:	022d      	lsls	r5, r5, #8
    971c:	f405 557c 	and.w	r5, r5, #16128	; 0x3f00
            if(!_DNSGetData(xtractBuff, &offset, sizeof(offset)))
    9720:	2201      	movs	r2, #1
    9722:	a90a      	add	r1, sp, #40	; 0x28
    9724:	4640      	mov	r0, r8
    9726:	f015 f8ff 	bl	1e928 <_DNSGetData>
    972a:	b168      	cbz	r0, 9748 <_DNS_ProcessPacket+0x110>
            labelOffset += offset; 
    972c:	f89d 2028 	ldrb.w	r2, [sp, #40]	; 0x28
    rxData->head = rxData->rdPtr = buffer;
    9730:	ab22      	add	r3, sp, #136	; 0x88
    9732:	930e      	str	r3, [sp, #56]	; 0x38
    9734:	930d      	str	r3, [sp, #52]	; 0x34
    rxData->endPtr = buffer + bufferSize;
    9736:	9b07      	ldr	r3, [sp, #28]
    9738:	930f      	str	r3, [sp, #60]	; 0x3c
            if(!_DNSGetData(xtractBuff, 0, labelOffset))
    973a:	442a      	add	r2, r5
    973c:	9900      	ldr	r1, [sp, #0]
    973e:	a80d      	add	r0, sp, #52	; 0x34
    9740:	f015 f8f2 	bl	1e928 <_DNSGetData>
    9744:	2800      	cmp	r0, #0
    9746:	d1e5      	bne.n	9714 <_DNS_ProcessPacket+0xdc>
    return !procFail;
    9748:	9b01      	ldr	r3, [sp, #4]
    974a:	f083 0301 	eor.w	r3, r3, #1
    974e:	b2db      	uxtb	r3, r3
    9750:	9301      	str	r3, [sp, #4]
    9752:	e789      	b.n	9668 <_DNS_ProcessPacket+0x30>
                discardLen = labelLen - avlblLen;
    9754:	1aed      	subs	r5, r5, r3
                copyLen = avlblLen;
    9756:	461e      	mov	r6, r3
        if(copyLen != 0)
    9758:	b9d3      	cbnz	r3, 9790 <_DNS_ProcessPacket+0x158>
        if(discardLen != 0)
    975a:	bb4d      	cbnz	r5, 97b0 <_DNS_ProcessPacket+0x178>
                nameFail = true;
                break;
            }
        }

        nameLen += copyLen + discardLen;
    975c:	4435      	add	r5, r6
    975e:	442f      	add	r7, r5
        if(!_DNSGetData(xtractBuff, &labelLen, sizeof(labelLen)))
    9760:	2201      	movs	r2, #1
    9762:	f10d 0127 	add.w	r1, sp, #39	; 0x27
    9766:	4640      	mov	r0, r8
    9768:	f015 f8de 	bl	1e928 <_DNSGetData>
    976c:	2800      	cmp	r0, #0
    976e:	d0eb      	beq.n	9748 <_DNS_ProcessPacket+0x110>
        if(labelLen == 0)
    9770:	f89d 5027 	ldrb.w	r5, [sp, #39]	; 0x27
    9774:	2d00      	cmp	r5, #0
    9776:	f000 8136 	beq.w	99e6 <_DNS_ProcessPacket+0x3ae>
        if((labelLen & 0xc0) == 0xc0)
    977a:	462e      	mov	r6, r5
    977c:	f005 03c0 	and.w	r3, r5, #192	; 0xc0
    9780:	2bc0      	cmp	r3, #192	; 0xc0
    9782:	d0ca      	beq.n	971a <_DNS_ProcessPacket+0xe2>
        if(wPtr != 0)
    9784:	b1bc      	cbz	r4, 97b6 <_DNS_ProcessPacket+0x17e>
            avlblLen = ePtr - wPtr;
    9786:	ab21      	add	r3, sp, #132	; 0x84
    9788:	1b1b      	subs	r3, r3, r4
            if(labelLen > avlblLen)
    978a:	429d      	cmp	r5, r3
    978c:	dce2      	bgt.n	9754 <_DNS_ProcessPacket+0x11c>
                discardLen = 0;
    978e:	9d00      	ldr	r5, [sp, #0]
            if(!_DNSGetData(xtractBuff, wPtr, copyLen))
    9790:	4632      	mov	r2, r6
    9792:	4621      	mov	r1, r4
    9794:	4640      	mov	r0, r8
    9796:	f015 f8c7 	bl	1e928 <_DNSGetData>
    979a:	2800      	cmp	r0, #0
    979c:	d0d4      	beq.n	9748 <_DNS_ProcessPacket+0x110>
            wPtr += copyLen;
    979e:	4434      	add	r4, r6
            if(wPtr < ePtr)
    97a0:	ab21      	add	r3, sp, #132	; 0x84
    97a2:	429c      	cmp	r4, r3
    97a4:	d2d9      	bcs.n	975a <_DNS_ProcessPacket+0x122>
                *wPtr++ = '.';
    97a6:	232e      	movs	r3, #46	; 0x2e
    97a8:	f804 3b01 	strb.w	r3, [r4], #1
                nameLen++;
    97ac:	3701      	adds	r7, #1
    97ae:	e7d4      	b.n	975a <_DNS_ProcessPacket+0x122>
        if(discardLen != 0)
    97b0:	9602      	str	r6, [sp, #8]
    97b2:	462e      	mov	r6, r5
    97b4:	e001      	b.n	97ba <_DNS_ProcessPacket+0x182>
            copyLen = 0;
    97b6:	9b00      	ldr	r3, [sp, #0]
    97b8:	9302      	str	r3, [sp, #8]
            if(!_DNSGetData(xtractBuff, 0, discardLen))
    97ba:	4632      	mov	r2, r6
    97bc:	9900      	ldr	r1, [sp, #0]
    97be:	4640      	mov	r0, r8
    97c0:	f015 f8b2 	bl	1e928 <_DNSGetData>
    97c4:	2800      	cmp	r0, #0
    97c6:	d0bf      	beq.n	9748 <_DNS_ProcessPacket+0x110>
    97c8:	4635      	mov	r5, r6
    97ca:	9e02      	ldr	r6, [sp, #8]
    97cc:	e7c6      	b.n	975c <_DNS_ProcessPacket+0x124>

    if(wPtr != 0)
    {
        if(wPtr != nameBuff && *(wPtr - 1) == '.')
        {
            wPtr--; // remove the last '.' 
    97ce:	3c01      	subs	r4, #1
            nameLen--;
    97d0:	3f01      	subs	r7, #1
    97d2:	e112      	b.n	99fa <_DNS_ProcessPacket+0x3c2>
        if(wPtr != nameBuff && *(wPtr - 1) == '.')
    97d4:	ac11      	add	r4, sp, #68	; 0x44
    97d6:	e110      	b.n	99fa <_DNS_ProcessPacket+0x3c2>
            return pDnsHE;
    97d8:	469b      	mov	fp, r3
    97da:	e0ea      	b.n	99b2 <_DNS_ProcessPacket+0x37a>
    if(!_DNSGetData(dnsRxData, (uint8_t *)&DNSAnswerHeader, sizeof(TCPIP_DNS_ANSWER_HEADER)))
    97dc:	220a      	movs	r2, #10
    97de:	a90a      	add	r1, sp, #40	; 0x28
    97e0:	a8a2      	add	r0, sp, #648	; 0x288
    97e2:	f015 f8a1 	bl	1e928 <_DNSGetData>
    97e6:	2800      	cmp	r0, #0
    97e8:	d0ae      	beq.n	9748 <_DNS_ProcessPacket+0x110>
    p->ResponseClass.Val = TCPIP_Helper_htons(p->ResponseClass.Val);
    97ea:	f8bd 302a 	ldrh.w	r3, [sp, #42]	; 0x2a
    97ee:	0a18      	lsrs	r0, r3, #8
    97f0:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
    97f4:	b280      	uxth	r0, r0
    97f6:	f8ad 002a 	strh.w	r0, [sp, #42]	; 0x2a
    p->ResponseLen.Val = TCPIP_Helper_htons(p->ResponseLen.Val);
    97fa:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
    97fe:	0a1a      	lsrs	r2, r3, #8
    9800:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
    9804:	b292      	uxth	r2, r2
    9806:	f8ad 2030 	strh.w	r2, [sp, #48]	; 0x30
    p->ResponseTTL.Val = TCPIP_Helper_htonl(p->ResponseTTL.Val);
    980a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    return (((hLong & 0x000000ff) << 24) | ((hLong & 0x0000ff00) << 8) | ((hLong & 0x00ff0000) >> 8) | ((hLong & 0xff000000) >> 24));
    980c:	0e19      	lsrs	r1, r3, #24
    980e:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
    9812:	021c      	lsls	r4, r3, #8
    9814:	f404 047f 	and.w	r4, r4, #16711680	; 0xff0000
    9818:	4321      	orrs	r1, r4
    981a:	0a1b      	lsrs	r3, r3, #8
    981c:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    9820:	430b      	orrs	r3, r1
    9822:	930b      	str	r3, [sp, #44]	; 0x2c
    p->ResponseType.Val = TCPIP_Helper_htons(p->ResponseType.Val);
    9824:	f8bd 1028 	ldrh.w	r1, [sp, #40]	; 0x28
       return (((hShort) << 8) | ((hShort) >> 8));
    9828:	0a0b      	lsrs	r3, r1, #8
    982a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    982e:	b29b      	uxth	r3, r3
    9830:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
    while( dnsHE != 0 && (DNSAnswerHeader.ResponseClass.Val == 1)) // Internet class
    9834:	f1bb 0f00 	cmp.w	fp, #0
    9838:	d001      	beq.n	983e <_DNS_ProcessPacket+0x206>
    983a:	2801      	cmp	r0, #1
    983c:	d007      	beq.n	984e <_DNS_ProcessPacket+0x216>
        if(!_DNSGetData(dnsRxData, 0, DNSAnswerHeader.ResponseLen.Val))
    983e:	9900      	ldr	r1, [sp, #0]
    9840:	a8a2      	add	r0, sp, #648	; 0x288
    9842:	f015 f871 	bl	1e928 <_DNSGetData>
            if(entryUpdate == false)
    9846:	2800      	cmp	r0, #0
    9848:	f040 80bf 	bne.w	99ca <_DNS_ProcessPacket+0x392>
    984c:	e77c      	b.n	9748 <_DNS_ProcessPacket+0x110>
        if (DNSAnswerHeader.ResponseType.Val == TCPIP_DNS_TYPE_A && DNSAnswerHeader.ResponseLen.Val == 4)
    984e:	2b01      	cmp	r3, #1
    9850:	d02f      	beq.n	98b2 <_DNS_ProcessPacket+0x27a>
        if (DNSAnswerHeader.ResponseType.Val == TCPIP_DNS_TYPE_AAAA && DNSAnswerHeader.ResponseLen.Val == 16)
    9852:	2b1c      	cmp	r3, #28
    9854:	d1f3      	bne.n	983e <_DNS_ProcessPacket+0x206>
    9856:	2a10      	cmp	r2, #16
    9858:	d1f1      	bne.n	983e <_DNS_ProcessPacket+0x206>
            if((dnsHE->recordMask & TCPIP_DNS_ADDRESS_REC_IPV6) == 0 || (dnsHE->nIPv6Entries >= pDnsDcpt->nIPv6Entries))
    985a:	f89b 302a 	ldrb.w	r3, [fp, #42]	; 0x2a
    985e:	f013 0f02 	tst.w	r3, #2
    9862:	d0ec      	beq.n	983e <_DNS_ProcessPacket+0x206>
    9864:	f89b 1027 	ldrb.w	r1, [fp, #39]	; 0x27
    9868:	9b04      	ldr	r3, [sp, #16]
    986a:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
    986c:	4299      	cmp	r1, r3
    986e:	d2e6      	bcs.n	983e <_DNS_ProcessPacket+0x206>
            if(!_DNSGetData(dnsRxData, ipAddr.v6Add.v, sizeof (IPV6_ADDR)))
    9870:	a90d      	add	r1, sp, #52	; 0x34
    9872:	a8a2      	add	r0, sp, #648	; 0x288
    9874:	f015 f858 	bl	1e928 <_DNSGetData>
    9878:	2800      	cmp	r0, #0
    987a:	f43f af65 	beq.w	9748 <_DNS_ProcessPacket+0x110>
            memcpy( &dnsHE->pip6Address[dnsHE->nIPv6Entries], ipAddr.v6Add.v, sizeof(IPV6_ADDR));
    987e:	f89b 5027 	ldrb.w	r5, [fp, #39]	; 0x27
    9882:	012d      	lsls	r5, r5, #4
    9884:	f8db 7014 	ldr.w	r7, [fp, #20]
    9888:	197e      	adds	r6, r7, r5
    988a:	ac0d      	add	r4, sp, #52	; 0x34
    988c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    988e:	5178      	str	r0, [r7, r5]
    9890:	6071      	str	r1, [r6, #4]
    9892:	60b2      	str	r2, [r6, #8]
    9894:	60f3      	str	r3, [r6, #12]
            if((DNSAnswerHeader.ResponseTTL.Val < dnsHE->ipTTL.Val) || (dnsHE->ipTTL.Val == 0))
    9896:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    9898:	f8db 2018 	ldr.w	r2, [fp, #24]
    989c:	4293      	cmp	r3, r2
    989e:	d300      	bcc.n	98a2 <_DNS_ProcessPacket+0x26a>
    98a0:	b90a      	cbnz	r2, 98a6 <_DNS_ProcessPacket+0x26e>
                dnsHE->ipTTL.Val = DNSAnswerHeader.ResponseTTL.Val;
    98a2:	f8cb 3018 	str.w	r3, [fp, #24]
            dnsHE->nIPv6Entries++;
    98a6:	f89b 3027 	ldrb.w	r3, [fp, #39]	; 0x27
    98aa:	3301      	adds	r3, #1
    98ac:	f88b 3027 	strb.w	r3, [fp, #39]	; 0x27
    if(discardData)
    98b0:	e08b      	b.n	99ca <_DNS_ProcessPacket+0x392>
        if (DNSAnswerHeader.ResponseType.Val == TCPIP_DNS_TYPE_A && DNSAnswerHeader.ResponseLen.Val == 4)
    98b2:	2a04      	cmp	r2, #4
    98b4:	d1c3      	bne.n	983e <_DNS_ProcessPacket+0x206>
            if(dnsHE->nIPv4Entries >= pDnsDcpt->nIPv4Entries)
    98b6:	f89b 1026 	ldrb.w	r1, [fp, #38]	; 0x26
    98ba:	9b04      	ldr	r3, [sp, #16]
    98bc:	8c1b      	ldrh	r3, [r3, #32]
    98be:	4299      	cmp	r1, r3
    98c0:	d2bd      	bcs.n	983e <_DNS_ProcessPacket+0x206>
            if(!_DNSGetData(dnsRxData, ipAddr.v4Add.v, sizeof(IPV4_ADDR)))
    98c2:	a90d      	add	r1, sp, #52	; 0x34
    98c4:	a8a2      	add	r0, sp, #648	; 0x288
    98c6:	f015 f82f 	bl	1e928 <_DNSGetData>
    98ca:	2800      	cmp	r0, #0
    98cc:	f43f af3c 	beq.w	9748 <_DNS_ProcessPacket+0x110>
            dnsHE->pip4Address[dnsHE->nIPv4Entries].Val = ipAddr.v4Add.Val;
    98d0:	990d      	ldr	r1, [sp, #52]	; 0x34
    98d2:	f89b 2026 	ldrb.w	r2, [fp, #38]	; 0x26
    98d6:	f8db 3010 	ldr.w	r3, [fp, #16]
    98da:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            if((DNSAnswerHeader.ResponseTTL.Val < dnsHE->ipTTL.Val) || (dnsHE->ipTTL.Val == 0))
    98de:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    98e0:	f8db 2018 	ldr.w	r2, [fp, #24]
    98e4:	4293      	cmp	r3, r2
    98e6:	d300      	bcc.n	98ea <_DNS_ProcessPacket+0x2b2>
    98e8:	b90a      	cbnz	r2, 98ee <_DNS_ProcessPacket+0x2b6>
                dnsHE->ipTTL.Val = DNSAnswerHeader.ResponseTTL.Val;
    98ea:	f8cb 3018 	str.w	r3, [fp, #24]
            dnsHE->nIPv4Entries++;
    98ee:	f89b 3026 	ldrb.w	r3, [fp, #38]	; 0x26
    98f2:	3301      	adds	r3, #1
    98f4:	f88b 3026 	strb.w	r3, [fp, #38]	; 0x26
    if(discardData)
    98f8:	e067      	b.n	99ca <_DNS_ProcessPacket+0x392>
        if(rrType == TCPIP_DNS_RR_TYPE_QUESTION)
    98fa:	f1ba 0f00 	cmp.w	sl, #0
    98fe:	f43f af23 	beq.w	9748 <_DNS_ProcessPacket+0x110>
        for(ix = TCPIP_DNS_RR_TYPE_QUESTION; ix < TCPIP_DNS_RR_TYPES; ix++) 
    9902:	9b03      	ldr	r3, [sp, #12]
    9904:	3301      	adds	r3, #1
    9906:	9303      	str	r3, [sp, #12]
    9908:	2b04      	cmp	r3, #4
    990a:	d00f      	beq.n	992c <_DNS_ProcessPacket+0x2f4>
            _DNS_ProcessRR(pDnsDcpt, &procRR, (TCPIP_DNS_RR_TYPE)ix);
    990c:	f89d a00c 	ldrb.w	sl, [sp, #12]
    switch(rrType)
    9910:	f1ba 0f03 	cmp.w	sl, #3
    9914:	d8f1      	bhi.n	98fa <_DNS_ProcessPacket+0x2c2>
    9916:	a301      	add	r3, pc, #4	; (adr r3, 991c <_DNS_ProcessPacket+0x2e4>)
    9918:	f853 f02a 	ldr.w	pc, [r3, sl, lsl #2]
    991c:	000096df 	.word	0x000096df
    9920:	000096e9 	.word	0x000096e9
    9924:	00009705 	.word	0x00009705
    9928:	0000970d 	.word	0x0000970d
        if(dnsHE != 0 && (dnsHE->nIPv4Entries > 0 || dnsHE->nIPv6Entries > 0))
    992c:	f1bb 0f00 	cmp.w	fp, #0
    9930:	f43f af0a 	beq.w	9748 <_DNS_ProcessPacket+0x110>
    9934:	f8bb 3026 	ldrh.w	r3, [fp, #38]	; 0x26
    9938:	2b00      	cmp	r3, #0
    993a:	f43f af05 	beq.w	9748 <_DNS_ProcessPacket+0x110>
    dnsHE->hEntry.flags.value &= ~TCPIP_DNS_FLAG_ENTRY_TIMEOUT;
    993e:	f8bb 3000 	ldrh.w	r3, [fp]
    9942:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    dnsHE->hEntry.flags.value |= TCPIP_DNS_FLAG_ENTRY_COMPLETE;
    9946:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    994a:	f8ab 3000 	strh.w	r3, [fp]
    dnsHE->recordMask = TCPIP_DNS_ADDRESS_REC_NONE;
    994e:	2300      	movs	r3, #0
    9950:	f88b 302a 	strb.w	r3, [fp, #42]	; 0x2a
    if(dnsHE->nIPv4Entries != 0)
    9954:	f89b 3026 	ldrb.w	r3, [fp, #38]	; 0x26
    9958:	b113      	cbz	r3, 9960 <_DNS_ProcessPacket+0x328>
        dnsHE->recordMask |= TCPIP_DNS_ADDRESS_REC_IPV4;
    995a:	2301      	movs	r3, #1
    995c:	f88b 302a 	strb.w	r3, [fp, #42]	; 0x2a
    if(dnsHE->nIPv6Entries != 0)
    9960:	f89b 3027 	ldrb.w	r3, [fp, #39]	; 0x27
    9964:	b12b      	cbz	r3, 9972 <_DNS_ProcessPacket+0x33a>
        dnsHE->recordMask |= TCPIP_DNS_ADDRESS_REC_IPV6;
    9966:	f89b 302a 	ldrb.w	r3, [fp, #42]	; 0x2a
    996a:	f043 0302 	orr.w	r3, r3, #2
    996e:	f88b 302a 	strb.w	r3, [fp, #42]	; 0x2a
    if(dnsHE->ipTTL.Val == 0)
    9972:	f8db 3018 	ldr.w	r3, [fp, #24]
    9976:	b91b      	cbnz	r3, 9980 <_DNS_ProcessPacket+0x348>
        dnsHE->ipTTL.Val = TCPIP_DNS_CLIENT_CACHE_DEFAULT_TTL_VAL;
    9978:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
    997c:	f8cb 3018 	str.w	r3, [fp, #24]
    dnsHE->tRetry = dnsHE->tInsert = pDnsDcpt->dnsTime; 
    9980:	9a04      	ldr	r2, [sp, #16]
    9982:	69d3      	ldr	r3, [r2, #28]
    9984:	f8cb 3008 	str.w	r3, [fp, #8]
    9988:	f8cb 300c 	str.w	r3, [fp, #12]
    pDnsDcpt->unsolvedEntries--;
    998c:	8cd3      	ldrh	r3, [r2, #38]	; 0x26
    998e:	3b01      	subs	r3, #1
    9990:	84d3      	strh	r3, [r2, #38]	; 0x26
        procFail = false;
    9992:	2300      	movs	r3, #0
    9994:	9301      	str	r3, [sp, #4]
    9996:	e6d7      	b.n	9748 <_DNS_ProcessPacket+0x110>
            if((dnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) != 0)
    9998:	8802      	ldrh	r2, [r0, #0]
    999a:	f012 0f80 	tst.w	r2, #128	; 0x80
    999e:	f47f aed3 	bne.w	9748 <_DNS_ProcessPacket+0x110>
            if(pProc->dnsHE == 0)
    99a2:	f1bb 0f00 	cmp.w	fp, #0
    99a6:	f43f af17 	beq.w	97d8 <_DNS_ProcessPacket+0x1a0>
            else if(pProc->dnsHE != dnsHE)
    99aa:	459b      	cmp	fp, r3
    99ac:	f47f aecc 	bne.w	9748 <_DNS_ProcessPacket+0x110>
            return pDnsHE;
    99b0:	469b      	mov	fp, r3
        if(rrType == TCPIP_DNS_RR_TYPE_QUESTION)
    99b2:	f1ba 0f00 	cmp.w	sl, #0
    99b6:	f47f af11 	bne.w	97dc <_DNS_ProcessPacket+0x1a4>
            if(!_DNSGetData(pProc->dnsRxData, 0, 4))
    99ba:	2204      	movs	r2, #4
    99bc:	9900      	ldr	r1, [sp, #0]
    99be:	a8a2      	add	r0, sp, #648	; 0x288
    99c0:	f014 ffb2 	bl	1e928 <_DNSGetData>
    99c4:	2800      	cmp	r0, #0
    99c6:	f43f aebf 	beq.w	9748 <_DNS_ProcessPacket+0x110>
        nRecords++;
    99ca:	f109 0901 	add.w	r9, r9, #1
    while(nRR--)
    99ce:	9b05      	ldr	r3, [sp, #20]
    99d0:	4599      	cmp	r9, r3
    99d2:	d096      	beq.n	9902 <_DNS_ProcessPacket+0x2ca>
        *wPtr = 0;
    99d4:	f89d 301b 	ldrb.w	r3, [sp, #27]
    99d8:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
    TCPIP_DNS_RX_DATA* xtractBuff = pProc->dnsRxData;
    99dc:	f50d 7822 	add.w	r8, sp, #648	; 0x288
        *wPtr = 0;
    99e0:	ac11      	add	r4, sp, #68	; 0x44
    nameLen = 0;
    99e2:	2700      	movs	r7, #0
    99e4:	e6bc      	b.n	9760 <_DNS_ProcessPacket+0x128>
    if(wPtr != 0)
    99e6:	b15c      	cbz	r4, 9a00 <_DNS_ProcessPacket+0x3c8>
        if(wPtr != nameBuff && *(wPtr - 1) == '.')
    99e8:	ab11      	add	r3, sp, #68	; 0x44
    99ea:	429c      	cmp	r4, r3
    99ec:	f43f aef2 	beq.w	97d4 <_DNS_ProcessPacket+0x19c>
    99f0:	f814 3c01 	ldrb.w	r3, [r4, #-1]
    99f4:	2b2e      	cmp	r3, #46	; 0x2e
    99f6:	f43f aeea 	beq.w	97ce <_DNS_ProcessPacket+0x196>
        }

        *wPtr = 0;  // end the nameBuff properly
    99fa:	f04f 0300 	mov.w	r3, #0
    99fe:	7023      	strb	r3, [r4, #0]
        if(nameLen <= 0)
    9a00:	2f00      	cmp	r7, #0
    9a02:	f77f aea1 	ble.w	9748 <_DNS_ProcessPacket+0x110>
        dnsHE = _DNSHashEntryFromTransactionId(pDnsDcpt, nameBuffer, pProc->dnsHeader->TransactionID.Val);
    9a06:	f8bd 4294 	ldrh.w	r4, [sp, #660]	; 0x294
    pDnsHE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryLookup(pDnsDcpt->hashDcpt, hostName);
    9a0a:	a911      	add	r1, sp, #68	; 0x44
    9a0c:	9b04      	ldr	r3, [sp, #16]
    9a0e:	6818      	ldr	r0, [r3, #0]
    9a10:	f011 f820 	bl	1aa54 <TCPIP_OAHASH_EntryLookup>
    if(pDnsHE != 0)
    9a14:	4603      	mov	r3, r0
    9a16:	b110      	cbz	r0, 9a1e <_DNS_ProcessPacket+0x3e6>
        if(pDnsHE->transactionId.Val == transactionId)
    9a18:	8c82      	ldrh	r2, [r0, #36]	; 0x24
    9a1a:	42a2      	cmp	r2, r4
    9a1c:	d0bc      	beq.n	9998 <_DNS_ProcessPacket+0x360>
            if(pProc->dnsHE != 0)
    9a1e:	f1bb 0f00 	cmp.w	fp, #0
    9a22:	d0c6      	beq.n	99b2 <_DNS_ProcessPacket+0x37a>
            if((dnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) != 0)
    9a24:	f8bb 3000 	ldrh.w	r3, [fp]
    9a28:	f013 0f80 	tst.w	r3, #128	; 0x80
    9a2c:	d0c1      	beq.n	99b2 <_DNS_ProcessPacket+0x37a>
    9a2e:	e68b      	b.n	9748 <_DNS_ProcessPacket+0x110>

Disassembly of section .text.TCPIP_COMMAND_Task%206:

00009a30 <TCPIP_COMMAND_Task>:
}

#endif  // defined(_TCPIP_COMMAND_PING4) || defined(_TCPIP_COMMAND_PING6)

void TCPIP_COMMAND_Task(void)
{
    9a30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9a34:	b095      	sub	sp, #84	; 0x54
    TCPIP_MODULE_SIGNAL sigPend;

    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    9a36:	210f      	movs	r1, #15
    9a38:	201f      	movs	r0, #31
    9a3a:	f014 fa97 	bl	1df6c <_TCPIPStackModuleSignalGet>

    if((sigPend & TCPIP_MODULE_SIGNAL_TMO) != 0)
    9a3e:	f010 0f02 	tst.w	r0, #2
    9a42:	d00d      	beq.n	9a60 <TCPIP_COMMAND_Task+0x30>
    { // regular TMO occurred

#if  defined(_TCPIP_COMMAND_PING4) || defined(_TCPIP_COMMAND_PING6)
        if(TCPIP_CMD_STAT_PING_START <= tcpipCmdStat && tcpipCmdStat <= TCPIP_CMD_STAT_PING_STOP)
    9a44:	4b93      	ldr	r3, [pc, #588]	; (9c94 <TCPIP_COMMAND_Task+0x264>)
    9a46:	781a      	ldrb	r2, [r3, #0]
    9a48:	1e53      	subs	r3, r2, #1
    9a4a:	b2db      	uxtb	r3, r3
    9a4c:	2b06      	cmp	r3, #6
    9a4e:	d90a      	bls.n	9a66 <TCPIP_COMMAND_Task+0x36>
            TCPIPCmdPingTask();
        }
#endif  // defined(_TCPIP_COMMAND_PING4) || defined(_TCPIP_COMMAND_PING6)

#if defined(TCPIP_STACK_USE_DNS)
        if(TCPIP_CMD_STAT_DNS_START <= tcpipCmdStat && tcpipCmdStat <= TCPIP_CMD_STAT_DNS_STOP)
    9a50:	4b90      	ldr	r3, [pc, #576]	; (9c94 <TCPIP_COMMAND_Task+0x264>)
    9a52:	781a      	ldrb	r2, [r3, #0]
    9a54:	f1a2 0308 	sub.w	r3, r2, #8
    9a58:	b2db      	uxtb	r3, r3
    9a5a:	2b01      	cmp	r3, #1
    9a5c:	f240 80c7 	bls.w	9bee <TCPIP_COMMAND_Task+0x1be>
        {
            TCPIPCmdMiimTask();
        }
#endif  // defined(_TCPIP_COMMANDS_MIIM)
    }
}
    9a60:	b015      	add	sp, #84	; 0x54
    9a62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    switch(tcpipCmdStat)
    9a66:	3a01      	subs	r2, #1
    9a68:	2a03      	cmp	r2, #3
    9a6a:	d840      	bhi.n	9aee <TCPIP_COMMAND_Task+0xbe>
    9a6c:	e8df f002 	tbb	[pc, r2]
    9a70:	39331702 	.word	0x39331702
            dnsRes = TCPIP_DNS_Resolve(icmpTargetHost, TCPIP_DNS_TYPE_A);
    9a74:	2101      	movs	r1, #1
    9a76:	4888      	ldr	r0, [pc, #544]	; (9c98 <TCPIP_COMMAND_Task+0x268>)
    9a78:	f018 fab8 	bl	21fec <TCPIP_DNS_Resolve>
            if(dnsRes != TCPIP_DNS_RES_OK && dnsRes != TCPIP_DNS_RES_PENDING && dnsRes != TCPIP_DNS_RES_NAME_IS_IPADDRESS)
    9a7c:	b2c0      	uxtb	r0, r0
    9a7e:	2802      	cmp	r0, #2
    9a80:	d909      	bls.n	9a96 <TCPIP_COMMAND_Task+0x66>
                (*pTcpipCmdDevice->pCmdApi->print)(icmpCmdIoParam, "Ping: DNS failure for %s\r\n", icmpTargetHost);
    9a82:	4b86      	ldr	r3, [pc, #536]	; (9c9c <TCPIP_COMMAND_Task+0x26c>)
    9a84:	681b      	ldr	r3, [r3, #0]
    9a86:	681b      	ldr	r3, [r3, #0]
    9a88:	685b      	ldr	r3, [r3, #4]
    9a8a:	4a83      	ldr	r2, [pc, #524]	; (9c98 <TCPIP_COMMAND_Task+0x268>)
    9a8c:	4984      	ldr	r1, [pc, #528]	; (9ca0 <TCPIP_COMMAND_Task+0x270>)
    9a8e:	4885      	ldr	r0, [pc, #532]	; (9ca4 <TCPIP_COMMAND_Task+0x274>)
    9a90:	6800      	ldr	r0, [r0, #0]
    9a92:	4798      	blx	r3
    if(killIcmp)
    9a94:	e02b      	b.n	9aee <TCPIP_COMMAND_Task+0xbe>
            tcpipCmdStat = TCPIP_PING_CMD_DNS_WAIT;
    9a96:	4b7f      	ldr	r3, [pc, #508]	; (9c94 <TCPIP_COMMAND_Task+0x264>)
    9a98:	2202      	movs	r2, #2
    9a9a:	701a      	strb	r2, [r3, #0]
    if(killIcmp)
    9a9c:	e7d8      	b.n	9a50 <TCPIP_COMMAND_Task+0x20>
            dnsRes = TCPIP_DNS_IsNameResolved(icmpTargetHost, &icmpTargetAddr, 0);
    9a9e:	2200      	movs	r2, #0
    9aa0:	4981      	ldr	r1, [pc, #516]	; (9ca8 <TCPIP_COMMAND_Task+0x278>)
    9aa2:	487d      	ldr	r0, [pc, #500]	; (9c98 <TCPIP_COMMAND_Task+0x268>)
    9aa4:	f018 faa7 	bl	21ff6 <TCPIP_DNS_IsNameResolved>
            if(dnsRes == TCPIP_DNS_RES_PENDING)
    9aa8:	2801      	cmp	r0, #1
    9aaa:	d0d1      	beq.n	9a50 <TCPIP_COMMAND_Task+0x20>
            else if(dnsRes < 0 )
    9aac:	2800      	cmp	r0, #0
    9aae:	da09      	bge.n	9ac4 <TCPIP_COMMAND_Task+0x94>
                (*pTcpipCmdDevice->pCmdApi->print)(icmpCmdIoParam, "Ping: DNS failure for %s\r\n", icmpTargetHost);
    9ab0:	4b7a      	ldr	r3, [pc, #488]	; (9c9c <TCPIP_COMMAND_Task+0x26c>)
    9ab2:	681b      	ldr	r3, [r3, #0]
    9ab4:	681b      	ldr	r3, [r3, #0]
    9ab6:	685b      	ldr	r3, [r3, #4]
    9ab8:	4a77      	ldr	r2, [pc, #476]	; (9c98 <TCPIP_COMMAND_Task+0x268>)
    9aba:	4979      	ldr	r1, [pc, #484]	; (9ca0 <TCPIP_COMMAND_Task+0x270>)
    9abc:	4879      	ldr	r0, [pc, #484]	; (9ca4 <TCPIP_COMMAND_Task+0x274>)
    9abe:	6800      	ldr	r0, [r0, #0]
    9ac0:	4798      	blx	r3
    if(killIcmp)
    9ac2:	e014      	b.n	9aee <TCPIP_COMMAND_Task+0xbe>
            TCPIP_Helper_IPAddressToString(&icmpTargetAddr, icmpTargetAddrStr, sizeof(icmpTargetAddrStr));
    9ac4:	2211      	movs	r2, #17
    9ac6:	4979      	ldr	r1, [pc, #484]	; (9cac <TCPIP_COMMAND_Task+0x27c>)
    9ac8:	4877      	ldr	r0, [pc, #476]	; (9ca8 <TCPIP_COMMAND_Task+0x278>)
    9aca:	f012 fe4b 	bl	1c764 <TCPIP_Helper_IPAddressToString>
            tcpipCmdStat = TCPIP_PING_CMD_START_PING;            
    9ace:	4b71      	ldr	r3, [pc, #452]	; (9c94 <TCPIP_COMMAND_Task+0x264>)
    9ad0:	2203      	movs	r2, #3
    9ad2:	701a      	strb	r2, [r3, #0]
    if(killIcmp)
    9ad4:	e7bc      	b.n	9a50 <TCPIP_COMMAND_Task+0x20>
            icmpStartTick = 0;  // try to start as quickly as possible
    9ad6:	4b76      	ldr	r3, [pc, #472]	; (9cb0 <TCPIP_COMMAND_Task+0x280>)
    9ad8:	2200      	movs	r2, #0
    9ada:	601a      	str	r2, [r3, #0]
            tcpipCmdStat = TCPIP_PING_CMD_DO_PING;            
    9adc:	4b6d      	ldr	r3, [pc, #436]	; (9c94 <TCPIP_COMMAND_Task+0x264>)
    9ade:	2204      	movs	r2, #4
    9ae0:	701a      	strb	r2, [r3, #0]
            if(icmpReqCount == icmpReqNo)
    9ae2:	4b74      	ldr	r3, [pc, #464]	; (9cb4 <TCPIP_COMMAND_Task+0x284>)
    9ae4:	681a      	ldr	r2, [r3, #0]
    9ae6:	4b74      	ldr	r3, [pc, #464]	; (9cb8 <TCPIP_COMMAND_Task+0x288>)
    9ae8:	681b      	ldr	r3, [r3, #0]
    9aea:	429a      	cmp	r2, r3
    9aec:	d106      	bne.n	9afc <TCPIP_COMMAND_Task+0xcc>
        _PingStop(pTcpipCmdDevice, icmpCmdIoParam);
    9aee:	4b6d      	ldr	r3, [pc, #436]	; (9ca4 <TCPIP_COMMAND_Task+0x274>)
    9af0:	6819      	ldr	r1, [r3, #0]
    9af2:	4b6a      	ldr	r3, [pc, #424]	; (9c9c <TCPIP_COMMAND_Task+0x26c>)
    9af4:	6818      	ldr	r0, [r3, #0]
    9af6:	f011 fb43 	bl	1b180 <_PingStop>
    9afa:	e7a9      	b.n	9a50 <TCPIP_COMMAND_Task+0x20>
            if(SYS_TMR_TickCountGet() - icmpStartTick > (SYS_TMR_TickCounterFrequencyGet() * icmpReqDelay) / 1000)
    9afc:	f016 fa56 	bl	1ffac <SYS_TMR_TickCountGet>
    9b00:	4b6b      	ldr	r3, [pc, #428]	; (9cb0 <TCPIP_COMMAND_Task+0x280>)
    9b02:	681c      	ldr	r4, [r3, #0]
    9b04:	1b04      	subs	r4, r0, r4
    9b06:	f016 fa79 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
    9b0a:	4b6c      	ldr	r3, [pc, #432]	; (9cbc <TCPIP_COMMAND_Task+0x28c>)
    9b0c:	681b      	ldr	r3, [r3, #0]
    9b0e:	fb03 f300 	mul.w	r3, r3, r0
    9b12:	486b      	ldr	r0, [pc, #428]	; (9cc0 <TCPIP_COMMAND_Task+0x290>)
    9b14:	fba0 2303 	umull	r2, r3, r0, r3
    9b18:	ebb4 1f93 	cmp.w	r4, r3, lsr #6
    9b1c:	d943      	bls.n	9ba6 <TCPIP_COMMAND_Task+0x176>
                cancelReq = icmpReqCount != icmpAckRecv && icmpReqHandle != 0;    // cancel if there is another one ongoing
    9b1e:	4b65      	ldr	r3, [pc, #404]	; (9cb4 <TCPIP_COMMAND_Task+0x284>)
    9b20:	681a      	ldr	r2, [r3, #0]
    9b22:	4b68      	ldr	r3, [pc, #416]	; (9cc4 <TCPIP_COMMAND_Task+0x294>)
    9b24:	681b      	ldr	r3, [r3, #0]
    9b26:	429a      	cmp	r2, r3
    9b28:	d03b      	beq.n	9ba2 <TCPIP_COMMAND_Task+0x172>
    9b2a:	4b67      	ldr	r3, [pc, #412]	; (9cc8 <TCPIP_COMMAND_Task+0x298>)
    9b2c:	681b      	ldr	r3, [r3, #0]
    9b2e:	3300      	adds	r3, #0
    9b30:	bf18      	it	ne
    9b32:	2301      	movne	r3, #1
            if(cancelReq)
    9b34:	2b00      	cmp	r3, #0
    9b36:	d155      	bne.n	9be4 <TCPIP_COMMAND_Task+0x1b4>
            echoRequest.netH = icmpNetH;
    9b38:	4b64      	ldr	r3, [pc, #400]	; (9ccc <TCPIP_COMMAND_Task+0x29c>)
    9b3a:	681b      	ldr	r3, [r3, #0]
    9b3c:	9309      	str	r3, [sp, #36]	; 0x24
            echoRequest.targetAddr = icmpTargetAddr;
    9b3e:	4b5a      	ldr	r3, [pc, #360]	; (9ca8 <TCPIP_COMMAND_Task+0x278>)
    9b40:	681b      	ldr	r3, [r3, #0]
    9b42:	930a      	str	r3, [sp, #40]	; 0x28
            echoRequest.sequenceNumber = ++icmpSequenceNo;
    9b44:	4a62      	ldr	r2, [pc, #392]	; (9cd0 <TCPIP_COMMAND_Task+0x2a0>)
    9b46:	8813      	ldrh	r3, [r2, #0]
    9b48:	3301      	adds	r3, #1
    9b4a:	b29b      	uxth	r3, r3
    9b4c:	8013      	strh	r3, [r2, #0]
    9b4e:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
            echoRequest.identifier = icmpIdentifier;
    9b52:	4b60      	ldr	r3, [pc, #384]	; (9cd4 <TCPIP_COMMAND_Task+0x2a4>)
    9b54:	881b      	ldrh	r3, [r3, #0]
    9b56:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
            echoRequest.pData = icmpPingBuff;
    9b5a:	4b5f      	ldr	r3, [pc, #380]	; (9cd8 <TCPIP_COMMAND_Task+0x2a8>)
    9b5c:	930c      	str	r3, [sp, #48]	; 0x30
            echoRequest.dataSize = icmpPingSize;
    9b5e:	4b5f      	ldr	r3, [pc, #380]	; (9cdc <TCPIP_COMMAND_Task+0x2ac>)
    9b60:	681b      	ldr	r3, [r3, #0]
    9b62:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
            echoRequest.callback = CommandPingHandler;
    9b66:	4a5e      	ldr	r2, [pc, #376]	; (9ce0 <TCPIP_COMMAND_Task+0x2b0>)
    9b68:	920e      	str	r2, [sp, #56]	; 0x38
                for(ix = 0; ix < icmpPingSize; ix++)
    9b6a:	2b00      	cmp	r3, #0
    9b6c:	dd0a      	ble.n	9b84 <TCPIP_COMMAND_Task+0x154>
    9b6e:	2400      	movs	r4, #0
                uint8_t* pBuff = icmpPingBuff;
    9b70:	4d59      	ldr	r5, [pc, #356]	; (9cd8 <TCPIP_COMMAND_Task+0x2a8>)
                for(ix = 0; ix < icmpPingSize; ix++)
    9b72:	4e5a      	ldr	r6, [pc, #360]	; (9cdc <TCPIP_COMMAND_Task+0x2ac>)
    srand(seed);
}

static __inline__ uint32_t __attribute__((always_inline)) SYS_RANDOM_PseudoGet( void )
{
    return (uint32_t)rand();
    9b74:	f011 f83e 	bl	1abf4 <rand>
                    *pBuff++ = SYS_RANDOM_PseudoGet();
    9b78:	f805 0b01 	strb.w	r0, [r5], #1
                for(ix = 0; ix < icmpPingSize; ix++)
    9b7c:	3401      	adds	r4, #1
    9b7e:	6833      	ldr	r3, [r6, #0]
    9b80:	429c      	cmp	r4, r3
    9b82:	dbf7      	blt.n	9b74 <TCPIP_COMMAND_Task+0x144>
            echoRes = TCPIP_ICMP_EchoRequest (&echoRequest, &icmpReqHandle);
    9b84:	4950      	ldr	r1, [pc, #320]	; (9cc8 <TCPIP_COMMAND_Task+0x298>)
    9b86:	a809      	add	r0, sp, #36	; 0x24
    9b88:	f00a f9ec 	bl	13f64 <TCPIP_ICMP_EchoRequest>
            if(echoRes >= 0 )
    9b8c:	2800      	cmp	r0, #0
    9b8e:	dbae      	blt.n	9aee <TCPIP_COMMAND_Task+0xbe>
                icmpStartTick = SYS_TMR_TickCountGet();
    9b90:	f016 fa0c 	bl	1ffac <SYS_TMR_TickCountGet>
    9b94:	4b46      	ldr	r3, [pc, #280]	; (9cb0 <TCPIP_COMMAND_Task+0x280>)
    9b96:	6018      	str	r0, [r3, #0]
                icmpReqCount++;
    9b98:	4a46      	ldr	r2, [pc, #280]	; (9cb4 <TCPIP_COMMAND_Task+0x284>)
    9b9a:	6813      	ldr	r3, [r2, #0]
    9b9c:	3301      	adds	r3, #1
    9b9e:	6013      	str	r3, [r2, #0]
    if(killIcmp)
    9ba0:	e756      	b.n	9a50 <TCPIP_COMMAND_Task+0x20>
                cancelReq = icmpReqCount != icmpAckRecv && icmpReqHandle != 0;    // cancel if there is another one ongoing
    9ba2:	2300      	movs	r3, #0
                newReq = true;
    9ba4:	e7c6      	b.n	9b34 <TCPIP_COMMAND_Task+0x104>
            else if(icmpReqCount != icmpAckRecv)
    9ba6:	4b43      	ldr	r3, [pc, #268]	; (9cb4 <TCPIP_COMMAND_Task+0x284>)
    9ba8:	681a      	ldr	r2, [r3, #0]
    9baa:	4b46      	ldr	r3, [pc, #280]	; (9cc4 <TCPIP_COMMAND_Task+0x294>)
    9bac:	681b      	ldr	r3, [r3, #0]
    9bae:	429a      	cmp	r2, r3
    9bb0:	f43f af4e 	beq.w	9a50 <TCPIP_COMMAND_Task+0x20>
                if(SYS_TMR_TickCountGet() - icmpStartTick > (SYS_TMR_TickCounterFrequencyGet() * TCPIP_STACK_COMMANDS_ICMP_ECHO_TIMEOUT) / 1000)
    9bb4:	f016 f9fa 	bl	1ffac <SYS_TMR_TickCountGet>
    9bb8:	4b3d      	ldr	r3, [pc, #244]	; (9cb0 <TCPIP_COMMAND_Task+0x280>)
    9bba:	681c      	ldr	r4, [r3, #0]
    9bbc:	1b04      	subs	r4, r0, r4
    9bbe:	f016 fa1d 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
    9bc2:	f241 3388 	movw	r3, #5000	; 0x1388
    9bc6:	fb03 f300 	mul.w	r3, r3, r0
    9bca:	4a3d      	ldr	r2, [pc, #244]	; (9cc0 <TCPIP_COMMAND_Task+0x290>)
    9bcc:	fba2 2303 	umull	r2, r3, r2, r3
    9bd0:	ebb4 1f93 	cmp.w	r4, r3, lsr #6
    9bd4:	f67f af3c 	bls.w	9a50 <TCPIP_COMMAND_Task+0x20>
                    cancelReq = icmpReqHandle != 0;    // cancel if there is another one ongoing
    9bd8:	4b3b      	ldr	r3, [pc, #236]	; (9cc8 <TCPIP_COMMAND_Task+0x298>)
    9bda:	681b      	ldr	r3, [r3, #0]
    9bdc:	3300      	adds	r3, #0
    9bde:	bf18      	it	ne
    9be0:	2301      	movne	r3, #1
                    newReq = true;
    9be2:	e7a7      	b.n	9b34 <TCPIP_COMMAND_Task+0x104>
                TCPIP_ICMP_EchoRequestCancel(icmpReqHandle);
    9be4:	4b38      	ldr	r3, [pc, #224]	; (9cc8 <TCPIP_COMMAND_Task+0x298>)
    9be6:	6818      	ldr	r0, [r3, #0]
    9be8:	f016 fb88 	bl	202fc <TCPIP_ICMP_EchoRequestCancel>
    9bec:	e7a4      	b.n	9b38 <TCPIP_COMMAND_Task+0x108>
    switch(tcpipCmdStat)
    9bee:	2a08      	cmp	r2, #8
    9bf0:	d01f      	beq.n	9c32 <TCPIP_COMMAND_Task+0x202>
    9bf2:	2a09      	cmp	r2, #9
    9bf4:	f47f af34 	bne.w	9a60 <TCPIP_COMMAND_Task+0x30>
            dnsRes = TCPIP_DNS_IsResolved(dnslookupTargetHost, 0, IP_ADDRESS_TYPE_ANY);
    9bf8:	2200      	movs	r2, #0
    9bfa:	4611      	mov	r1, r2
    9bfc:	4839      	ldr	r0, [pc, #228]	; (9ce4 <TCPIP_COMMAND_Task+0x2b4>)
    9bfe:	f017 fac2 	bl	21186 <TCPIP_DNS_IsResolved>
    9c02:	4605      	mov	r5, r0
            timeout = (SYS_TMR_TickCountGet() - dnsLookUpStartTick)/SYS_TMR_TickCounterFrequencyGet();
    9c04:	f016 f9d2 	bl	1ffac <SYS_TMR_TickCountGet>
    9c08:	4b37      	ldr	r3, [pc, #220]	; (9ce8 <TCPIP_COMMAND_Task+0x2b8>)
    9c0a:	681c      	ldr	r4, [r3, #0]
    9c0c:	1b04      	subs	r4, r0, r4
    9c0e:	f016 f9f5 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
    9c12:	fbb4 f0f0 	udiv	r0, r4, r0
            if(timeout >= (TCPIP_DNS_CLIENT_SERVER_TMO/2))
    9c16:	281d      	cmp	r0, #29
    9c18:	d929      	bls.n	9c6e <TCPIP_COMMAND_Task+0x23e>
                (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "DNS Lookup: request timeout.\r\n");
    9c1a:	4b20      	ldr	r3, [pc, #128]	; (9c9c <TCPIP_COMMAND_Task+0x26c>)
    9c1c:	681b      	ldr	r3, [r3, #0]
    9c1e:	681b      	ldr	r3, [r3, #0]
    9c20:	685b      	ldr	r3, [r3, #4]
    9c22:	4932      	ldr	r1, [pc, #200]	; (9cec <TCPIP_COMMAND_Task+0x2bc>)
    9c24:	4a32      	ldr	r2, [pc, #200]	; (9cf0 <TCPIP_COMMAND_Task+0x2c0>)
    9c26:	6810      	ldr	r0, [r2, #0]
    9c28:	4798      	blx	r3
                tcpipCmdStat = TCPIP_CMD_STAT_IDLE;
    9c2a:	4b1a      	ldr	r3, [pc, #104]	; (9c94 <TCPIP_COMMAND_Task+0x264>)
    9c2c:	2200      	movs	r2, #0
    9c2e:	701a      	strb	r2, [r3, #0]
                break;
    9c30:	e716      	b.n	9a60 <TCPIP_COMMAND_Task+0x30>
            dnsRes = TCPIP_DNS_Resolve(dnslookupTargetHost, dnsType);
    9c32:	4b30      	ldr	r3, [pc, #192]	; (9cf4 <TCPIP_COMMAND_Task+0x2c4>)
    9c34:	7819      	ldrb	r1, [r3, #0]
    9c36:	482b      	ldr	r0, [pc, #172]	; (9ce4 <TCPIP_COMMAND_Task+0x2b4>)
    9c38:	f018 f9d8 	bl	21fec <TCPIP_DNS_Resolve>
            if(dnsRes != TCPIP_DNS_RES_OK && dnsRes != TCPIP_DNS_RES_PENDING && dnsRes != TCPIP_DNS_RES_NAME_IS_IPADDRESS)
    9c3c:	b2c3      	uxtb	r3, r0
    9c3e:	2b02      	cmp	r3, #2
    9c40:	d90d      	bls.n	9c5e <TCPIP_COMMAND_Task+0x22e>
                (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "DNS Lookup: DNS failure for %s, err: %d\r\n", dnslookupTargetHost, dnsRes);
    9c42:	4b16      	ldr	r3, [pc, #88]	; (9c9c <TCPIP_COMMAND_Task+0x26c>)
    9c44:	681b      	ldr	r3, [r3, #0]
    9c46:	681b      	ldr	r3, [r3, #0]
    9c48:	685c      	ldr	r4, [r3, #4]
    9c4a:	4603      	mov	r3, r0
    9c4c:	4a25      	ldr	r2, [pc, #148]	; (9ce4 <TCPIP_COMMAND_Task+0x2b4>)
    9c4e:	492a      	ldr	r1, [pc, #168]	; (9cf8 <TCPIP_COMMAND_Task+0x2c8>)
    9c50:	4827      	ldr	r0, [pc, #156]	; (9cf0 <TCPIP_COMMAND_Task+0x2c0>)
    9c52:	6800      	ldr	r0, [r0, #0]
    9c54:	47a0      	blx	r4
                tcpipCmdStat = TCPIP_CMD_STAT_IDLE;
    9c56:	4b0f      	ldr	r3, [pc, #60]	; (9c94 <TCPIP_COMMAND_Task+0x264>)
    9c58:	2200      	movs	r2, #0
    9c5a:	701a      	strb	r2, [r3, #0]
                break;
    9c5c:	e700      	b.n	9a60 <TCPIP_COMMAND_Task+0x30>
            tcpipCmdStat = TCPIP_DNS_LOOKUP_CMD_WAIT;
    9c5e:	4b0d      	ldr	r3, [pc, #52]	; (9c94 <TCPIP_COMMAND_Task+0x264>)
    9c60:	2209      	movs	r2, #9
    9c62:	701a      	strb	r2, [r3, #0]
            dnsLookUpStartTick = SYS_TMR_TickCountGet();
    9c64:	f016 f9a2 	bl	1ffac <SYS_TMR_TickCountGet>
    9c68:	4b1f      	ldr	r3, [pc, #124]	; (9ce8 <TCPIP_COMMAND_Task+0x2b8>)
    9c6a:	6018      	str	r0, [r3, #0]
            break;
    9c6c:	e6f8      	b.n	9a60 <TCPIP_COMMAND_Task+0x30>
            if(dnsRes == TCPIP_DNS_RES_PENDING)
    9c6e:	2d01      	cmp	r5, #1
    9c70:	f43f aef6 	beq.w	9a60 <TCPIP_COMMAND_Task+0x30>
            else if(dnsRes < 0 )
    9c74:	2d00      	cmp	r5, #0
    9c76:	da41      	bge.n	9cfc <TCPIP_COMMAND_Task+0x2cc>
                (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "DNS Lookup: DNS failure for %s, err: %d\r\n", dnslookupTargetHost, dnsRes);
    9c78:	4b08      	ldr	r3, [pc, #32]	; (9c9c <TCPIP_COMMAND_Task+0x26c>)
    9c7a:	681b      	ldr	r3, [r3, #0]
    9c7c:	681b      	ldr	r3, [r3, #0]
    9c7e:	685c      	ldr	r4, [r3, #4]
    9c80:	462b      	mov	r3, r5
    9c82:	4a18      	ldr	r2, [pc, #96]	; (9ce4 <TCPIP_COMMAND_Task+0x2b4>)
    9c84:	491c      	ldr	r1, [pc, #112]	; (9cf8 <TCPIP_COMMAND_Task+0x2c8>)
    9c86:	481a      	ldr	r0, [pc, #104]	; (9cf0 <TCPIP_COMMAND_Task+0x2c0>)
    9c88:	6800      	ldr	r0, [r0, #0]
    9c8a:	47a0      	blx	r4
                tcpipCmdStat = TCPIP_CMD_STAT_IDLE;
    9c8c:	4b01      	ldr	r3, [pc, #4]	; (9c94 <TCPIP_COMMAND_Task+0x264>)
    9c8e:	2200      	movs	r2, #0
    9c90:	701a      	strb	r2, [r3, #0]
                break;
    9c92:	e6e5      	b.n	9a60 <TCPIP_COMMAND_Task+0x30>
    9c94:	2000e3af 	.word	0x2000e3af
    9c98:	2000e390 	.word	0x2000e390
    9c9c:	2000e5e8 	.word	0x2000e5e8
    9ca0:	000015f4 	.word	0x000015f4
    9ca4:	2000e5c0 	.word	0x2000e5c0
    9ca8:	2000e5dc 	.word	0x2000e5dc
    9cac:	2000e504 	.word	0x2000e504
    9cb0:	2000e5d8 	.word	0x2000e5d8
    9cb4:	2000e5c8 	.word	0x2000e5c8
    9cb8:	2000e5d4 	.word	0x2000e5d4
    9cbc:	2000e5cc 	.word	0x2000e5cc
    9cc0:	10624dd3 	.word	0x10624dd3
    9cc4:	2000e5bc 	.word	0x2000e5bc
    9cc8:	2000e5d0 	.word	0x2000e5d0
    9ccc:	2000e5c4 	.word	0x2000e5c4
    9cd0:	2000e718 	.word	0x2000e718
    9cd4:	2000e716 	.word	0x2000e716
    9cd8:	2000ca04 	.word	0x2000ca04
    9cdc:	2000e5f0 	.word	0x2000e5f0
    9ce0:	00013515 	.word	0x00013515
    9ce4:	2000e370 	.word	0x2000e370
    9ce8:	2000e5b4 	.word	0x2000e5b4
    9cec:	0000163c 	.word	0x0000163c
    9cf0:	2000e5b8 	.word	0x2000e5b8
    9cf4:	2000e515 	.word	0x2000e515
    9cf8:	00001610 	.word	0x00001610
            _TCPIPStackSignalHandlerSetParams(TCPIP_THIS_MODULE_ID, tcpipCmdSignalHandle, 0);
    9cfc:	2200      	movs	r2, #0
    9cfe:	4b38      	ldr	r3, [pc, #224]	; (9de0 <TCPIP_COMMAND_Task+0x3b0>)
    9d00:	6819      	ldr	r1, [r3, #0]
    9d02:	201f      	movs	r0, #31
    9d04:	f016 f8da 	bl	1febc <_TCPIPStackSignalHandlerSetParams>
            tcpipCmdStat = TCPIP_CMD_STAT_IDLE;
    9d08:	4b36      	ldr	r3, [pc, #216]	; (9de4 <TCPIP_COMMAND_Task+0x3b4>)
    9d0a:	2200      	movs	r2, #0
    9d0c:	701a      	strb	r2, [r3, #0]
            (*pTcpipCmdDevice->pCmdApi->msg)(dnsLookupCmdIoParam, "Lookup Answer:\r\n----------------------\r\n");
    9d0e:	4b36      	ldr	r3, [pc, #216]	; (9de8 <TCPIP_COMMAND_Task+0x3b8>)
    9d10:	681b      	ldr	r3, [r3, #0]
    9d12:	681b      	ldr	r3, [r3, #0]
    9d14:	681b      	ldr	r3, [r3, #0]
    9d16:	4935      	ldr	r1, [pc, #212]	; (9dec <TCPIP_COMMAND_Task+0x3bc>)
    9d18:	4a35      	ldr	r2, [pc, #212]	; (9df0 <TCPIP_COMMAND_Task+0x3c0>)
    9d1a:	6810      	ldr	r0, [r2, #0]
    9d1c:	4798      	blx	r3
            nIPv4Entries = TCPIP_DNS_GetIPAddressesNumber(dnslookupTargetHost,IP_ADDRESS_TYPE_IPV4);
    9d1e:	4c35      	ldr	r4, [pc, #212]	; (9df4 <TCPIP_COMMAND_Task+0x3c4>)
    9d20:	2101      	movs	r1, #1
    9d22:	4620      	mov	r0, r4
    9d24:	f011 fb1c 	bl	1b360 <TCPIP_DNS_GetIPAddressesNumber>
    9d28:	4680      	mov	r8, r0
            nIPv6Entries = TCPIP_DNS_GetIPAddressesNumber(dnslookupTargetHost,IP_ADDRESS_TYPE_IPV6);
    9d2a:	2102      	movs	r1, #2
    9d2c:	4620      	mov	r0, r4
    9d2e:	f011 fb17 	bl	1b360 <TCPIP_DNS_GetIPAddressesNumber>
    9d32:	4681      	mov	r9, r0
            if((nIPv4Entries == 0) && (nIPv6Entries == 0))
    9d34:	ea58 0300 	orrs.w	r3, r8, r0
    9d38:	d109      	bne.n	9d4e <TCPIP_COMMAND_Task+0x31e>
                (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "No Lookup entry for [%s]\r\n",dnslookupTargetHost);
    9d3a:	4b2b      	ldr	r3, [pc, #172]	; (9de8 <TCPIP_COMMAND_Task+0x3b8>)
    9d3c:	681b      	ldr	r3, [r3, #0]
    9d3e:	681b      	ldr	r3, [r3, #0]
    9d40:	685b      	ldr	r3, [r3, #4]
    9d42:	4622      	mov	r2, r4
    9d44:	492c      	ldr	r1, [pc, #176]	; (9df8 <TCPIP_COMMAND_Task+0x3c8>)
    9d46:	482a      	ldr	r0, [pc, #168]	; (9df0 <TCPIP_COMMAND_Task+0x3c0>)
    9d48:	6800      	ldr	r0, [r0, #0]
    9d4a:	4798      	blx	r3
                break;
    9d4c:	e688      	b.n	9a60 <TCPIP_COMMAND_Task+0x30>
            if((nIPv4Entries == 0) && (nIPv6Entries == 0))
    9d4e:	2400      	movs	r4, #0
    9d50:	4625      	mov	r5, r4
                    TCPIP_DNS_GetIPv6Addresses(dnslookupTargetHost, ipv6Index, &ip6Address, 1);
    9d52:	4e28      	ldr	r6, [pc, #160]	; (9df4 <TCPIP_COMMAND_Task+0x3c4>)
                    (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "[%s] AAAA IPv6 Address :%s\r\n",dnslookupTargetHost,addrBuf);
    9d54:	f8df b0a4 	ldr.w	fp, [pc, #164]	; 9dfc <TCPIP_COMMAND_Task+0x3cc>
    9d58:	f50b 7a51 	add.w	sl, fp, #836	; 0x344
    9d5c:	e01c      	b.n	9d98 <TCPIP_COMMAND_Task+0x368>
                    TCPIP_DNS_GetIPv4Addresses(dnslookupTargetHost, ipv4Index, &ip4Address, 1);
    9d5e:	2301      	movs	r3, #1
    9d60:	aa04      	add	r2, sp, #16
    9d62:	4629      	mov	r1, r5
    9d64:	4630      	mov	r0, r6
    9d66:	f017 fe79 	bl	21a5c <TCPIP_DNS_GetIPv4Addresses>
                    (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "[%s] A IPv4 Address : %d.%d.%d.%d\r\n",dnslookupTargetHost,ip4Address.v[0],
    9d6a:	4b1f      	ldr	r3, [pc, #124]	; (9de8 <TCPIP_COMMAND_Task+0x3b8>)
    9d6c:	681b      	ldr	r3, [r3, #0]
    9d6e:	681b      	ldr	r3, [r3, #0]
    9d70:	f89d 2013 	ldrb.w	r2, [sp, #19]
    9d74:	9202      	str	r2, [sp, #8]
    9d76:	f89d 2012 	ldrb.w	r2, [sp, #18]
    9d7a:	9201      	str	r2, [sp, #4]
    9d7c:	f89d 2011 	ldrb.w	r2, [sp, #17]
    9d80:	9200      	str	r2, [sp, #0]
    9d82:	685f      	ldr	r7, [r3, #4]
    9d84:	f89d 3010 	ldrb.w	r3, [sp, #16]
    9d88:	4632      	mov	r2, r6
    9d8a:	f50b 7148 	add.w	r1, fp, #800	; 0x320
    9d8e:	4818      	ldr	r0, [pc, #96]	; (9df0 <TCPIP_COMMAND_Task+0x3c0>)
    9d90:	6800      	ldr	r0, [r0, #0]
    9d92:	47b8      	blx	r7
                    ipv4Index++;
    9d94:	3501      	adds	r5, #1
    9d96:	b2ed      	uxtb	r5, r5
                if(ipv4Index<nIPv4Entries)
    9d98:	45a8      	cmp	r8, r5
    9d9a:	dce0      	bgt.n	9d5e <TCPIP_COMMAND_Task+0x32e>
                else if(ipv6Index<nIPv6Entries)
    9d9c:	45a1      	cmp	r9, r4
    9d9e:	f77f ae5f 	ble.w	9a60 <TCPIP_COMMAND_Task+0x30>
                    TCPIP_DNS_GetIPv6Addresses(dnslookupTargetHost, ipv6Index, &ip6Address, 1);
    9da2:	2301      	movs	r3, #1
    9da4:	aa05      	add	r2, sp, #20
    9da6:	4621      	mov	r1, r4
    9da8:	4630      	mov	r0, r6
    9daa:	f017 fe5f 	bl	21a6c <TCPIP_DNS_GetIPv6Addresses>
                    memset(addrBuf,0,sizeof(addrBuf));
    9dae:	272c      	movs	r7, #44	; 0x2c
    9db0:	463a      	mov	r2, r7
    9db2:	2100      	movs	r1, #0
    9db4:	a809      	add	r0, sp, #36	; 0x24
    9db6:	f017 fee1 	bl	21b7c <memset>
                    TCPIP_Helper_IPv6AddressToString(&ip6Address,(char*)addrBuf,sizeof(addrBuf));
    9dba:	463a      	mov	r2, r7
    9dbc:	a909      	add	r1, sp, #36	; 0x24
    9dbe:	a805      	add	r0, sp, #20
    9dc0:	f00d fb6b 	bl	1749a <TCPIP_Helper_IPv6AddressToString>
                    (*pTcpipCmdDevice->pCmdApi->print)(dnsLookupCmdIoParam, "[%s] AAAA IPv6 Address :%s\r\n",dnslookupTargetHost,addrBuf);
    9dc4:	4b08      	ldr	r3, [pc, #32]	; (9de8 <TCPIP_COMMAND_Task+0x3b8>)
    9dc6:	681b      	ldr	r3, [r3, #0]
    9dc8:	681b      	ldr	r3, [r3, #0]
    9dca:	685f      	ldr	r7, [r3, #4]
    9dcc:	ab09      	add	r3, sp, #36	; 0x24
    9dce:	4632      	mov	r2, r6
    9dd0:	4651      	mov	r1, sl
    9dd2:	4807      	ldr	r0, [pc, #28]	; (9df0 <TCPIP_COMMAND_Task+0x3c0>)
    9dd4:	6800      	ldr	r0, [r0, #0]
    9dd6:	47b8      	blx	r7
                    ipv6Index++;
    9dd8:	3401      	adds	r4, #1
    9dda:	b2e4      	uxtb	r4, r4
    9ddc:	e7dc      	b.n	9d98 <TCPIP_COMMAND_Task+0x368>
    9dde:	bf00      	nop
    9de0:	2000e5ec 	.word	0x2000e5ec
    9de4:	2000e3af 	.word	0x2000e3af
    9de8:	2000e5e8 	.word	0x2000e5e8
    9dec:	0000165c 	.word	0x0000165c
    9df0:	2000e5b8 	.word	0x2000e5b8
    9df4:	2000e370 	.word	0x2000e370
    9df8:	00001688 	.word	0x00001688
    9dfc:	00001384 	.word	0x00001384

Disassembly of section .text.GenericTxStart%207:

00009e00 <GenericTxStart>:
{
    9e00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9e04:	4604      	mov	r4, r0
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;    
    9e06:	f8d0 30c4 	ldr.w	r3, [r0, #196]	; 0xc4
    9e0a:	685f      	ldr	r7, [r3, #4]
    currentTime = SYS_TMR_TickCountGet();
    9e0c:	f016 f8ce 	bl	1ffac <SYS_TMR_TickCountGet>
   	if ( currentTime < (pIState->nextTxTime - TCPIP_IPERF_TIMING_ERROR_MARGIN))
    9e10:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
    9e14:	4283      	cmp	r3, r0
    9e16:	f200 81c0 	bhi.w	a19a <GenericTxStart+0x39a>
    9e1a:	4605      	mov	r5, r0
    iperfKilled = pIState->stopRequested;
    9e1c:	f894 60cf 	ldrb.w	r6, [r4, #207]	; 0xcf
    if ((iperfKilled == true) ||
    9e20:	b98e      	cbnz	r6, 9e46 <GenericTxStart+0x46>
            ((pIState->mDuration != 0u) &&
    9e22:	68a3      	ldr	r3, [r4, #8]
    if ((iperfKilled == true) ||
    9e24:	b123      	cbz	r3, 9e30 <GenericTxStart+0x30>
             (currentTime > (pIState->startTime + pIState->mDuration))) ||
    9e26:	f8d4 2088 	ldr.w	r2, [r4, #136]	; 0x88
    9e2a:	4413      	add	r3, r2
            ((pIState->mDuration != 0u) &&
    9e2c:	4283      	cmp	r3, r0
    9e2e:	d30a      	bcc.n	9e46 <GenericTxStart+0x46>
            ((pIState->mAmount != 0u) &&
    9e30:	6860      	ldr	r0, [r4, #4]
             (currentTime > (pIState->startTime + pIState->mDuration))) ||
    9e32:	b158      	cbz	r0, 9e4c <GenericTxStart+0x4c>
             (pIState->totalLen > pIState->mAmount)))
    9e34:	f000 fe92 	bl	ab5c <__aeabi_ui2d>
            ((pIState->mAmount != 0u) &&
    9e38:	4602      	mov	r2, r0
    9e3a:	460b      	mov	r3, r1
    9e3c:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    9e40:	f009 fc6e 	bl	13720 <__aeabi_dcmpgt>
    9e44:	b110      	cbz	r0, 9e4c <GenericTxStart+0x4c>
        pIState->isLastTransmit = true;
    9e46:	2301      	movs	r3, #1
    9e48:	f884 30d0 	strb.w	r3, [r4, #208]	; 0xd0
    if ( pIState->pktId == 0 )
    9e4c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    9e4e:	b973      	cbnz	r3, 9e6e <GenericTxStart+0x6e>
        pIState->startTime = currentTime;
    9e50:	f8c4 5088 	str.w	r5, [r4, #136]	; 0x88
        pIState->lastCheckTime = 	pIState->startTime;
    9e54:	f8c4 50a8 	str.w	r5, [r4, #168]	; 0xa8
        pIState->lastCheckPktId = pIState->pktId;
    9e58:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
        pIState->lastCheckPktCount = pIState->pktCount;
    9e5c:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
    9e60:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
        pIState->lastCheckErrorCount = pIState->errorCount;
    9e64:	6b22      	ldr	r2, [r4, #48]	; 0x30
    9e66:	f8c4 20a0 	str.w	r2, [r4, #160]	; 0xa0
        pIState->nAttempts = 0;
    9e6a:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
    pIState->nextTxTime = currentTime + pIState->mPktPeriod;
    9e6e:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
    9e72:	441d      	add	r5, r3
    9e74:	f8c4 5090 	str.w	r5, [r4, #144]	; 0x90
    switch(pIState->mProtocol)
    9e78:	7c23      	ldrb	r3, [r4, #16]
    9e7a:	2b01      	cmp	r3, #1
    9e7c:	d02a      	beq.n	9ed4 <GenericTxStart+0xd4>
    9e7e:	2b02      	cmp	r3, #2
    9e80:	f040 80b9 	bne.w	9ff6 <GenericTxStart+0x1f6>
            if( TCPIP_TCP_GetIsReady(pIState->tcpClientSock) > 0u )
    9e84:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    9e88:	f017 fd55 	bl	21936 <TCPIP_TCP_GetIsReady>
    9e8c:	b9e0      	cbnz	r0, 9ec8 <GenericTxStart+0xc8>
            if ( TCPIP_TCP_WasReset(pIState->tcpClientSock) )
    9e8e:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    9e92:	f015 fe06 	bl	1faa2 <TCPIP_TCP_WasReset>
    9e96:	b148      	cbz	r0, 9eac <GenericTxStart+0xac>
                (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "\r\niperf: Warning, TCP server disconnect detected\r\n");
    9e98:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    9e9c:	681b      	ldr	r3, [r3, #0]
    9e9e:	681b      	ldr	r3, [r3, #0]
    9ea0:	49c2      	ldr	r1, [pc, #776]	; (a1ac <GenericTxStart+0x3ac>)
    9ea2:	4638      	mov	r0, r7
    9ea4:	4798      	blx	r3
                pIState->stopRequested = 1;
    9ea6:	2301      	movs	r3, #1
    9ea8:	f884 30cf 	strb.w	r3, [r4, #207]	; 0xcf
            if  (( TCPIP_TCP_PutIsReady(pIState->tcpClientSock) <= pIState->mMSS ) && (!iperfKilled))
    9eac:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    9eb0:	f017 f95c 	bl	2116c <TCPIP_TCP_PutIsReady>
    9eb4:	f8b4 30d2 	ldrh.w	r3, [r4, #210]	; 0xd2
    9eb8:	4283      	cmp	r3, r0
    9eba:	f0c0 809c 	bcc.w	9ff6 <GenericTxStart+0x1f6>
    9ebe:	2e00      	cmp	r6, #0
    9ec0:	f040 8099 	bne.w	9ff6 <GenericTxStart+0x1f6>
                return IPERF_TX_WAIT;
    9ec4:	4635      	mov	r5, r6
    9ec6:	e169      	b.n	a19c <GenericTxStart+0x39c>
                TCPIP_TCP_Discard(pIState->tcpClientSock);
    9ec8:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    9ecc:	f016 f95c 	bl	20188 <TCPIP_TCP_Discard>
                return IPERF_TX_WAIT;
    9ed0:	2500      	movs	r5, #0
    9ed2:	e163      	b.n	a19c <GenericTxStart+0x39c>
            if( TCPIP_UDP_GetIsReady(pIState->udpSock) > 0u )
    9ed4:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    9ed8:	f016 f82c 	bl	1ff34 <TCPIP_UDP_GetIsReady>
    9edc:	b938      	cbnz	r0, 9eee <GenericTxStart+0xee>
            for(i = 0, mpIState = gIperfState; i < nIperfSessions; i++, mpIState++)
    9ede:	4bb4      	ldr	r3, [pc, #720]	; (a1b0 <GenericTxStart+0x3b0>)
    9ee0:	6818      	ldr	r0, [r3, #0]
    9ee2:	2800      	cmp	r0, #0
    9ee4:	dd49      	ble.n	9f7a <GenericTxStart+0x17a>
    9ee6:	2300      	movs	r3, #0
    9ee8:	49b2      	ldr	r1, [pc, #712]	; (a1b4 <GenericTxStart+0x3b4>)
                if(mpIState->waitCount == 3) mpIState->waitCount = 0;
    9eea:	469c      	mov	ip, r3
    9eec:	e027      	b.n	9f3e <GenericTxStart+0x13e>
                TCPIP_UDP_Discard(pIState->udpSock);
    9eee:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    9ef2:	f016 fbea 	bl	206ca <TCPIP_UDP_Discard>
                return IPERF_TX_WAIT;
    9ef6:	2500      	movs	r5, #0
    9ef8:	e150      	b.n	a19c <GenericTxStart+0x39c>
                        if(mpIState->mTypeOfService == TCPIP_IPV4_RELIABILITY_HIGH || mpIState->mTypeOfService == TCPIP_IPV4_THROUGHPUT_HIGH || mpIState->mTypeOfService == TCPIP_IPV4_TOS_DEFAULT)
    9efa:	7d0d      	ldrb	r5, [r1, #20]
    9efc:	2d20      	cmp	r5, #32
    9efe:	d002      	beq.n	9f06 <GenericTxStart+0x106>
    9f00:	f015 0fef 	tst.w	r5, #239	; 0xef
    9f04:	d116      	bne.n	9f34 <GenericTxStart+0x134>
                            if(mpIState->sockWaitToSend)
    9f06:	f891 50d4 	ldrb.w	r5, [r1, #212]	; 0xd4
    9f0a:	b19d      	cbz	r5, 9f34 <GenericTxStart+0x134>
                                mpIState->waitCount += 1;
    9f0c:	3201      	adds	r2, #1
    9f0e:	f881 20d5 	strb.w	r2, [r1, #213]	; 0xd5
                                return IPERF_TX_WAIT;
    9f12:	2500      	movs	r5, #0
    9f14:	e142      	b.n	a19c <GenericTxStart+0x39c>
                        if(mpIState->mTypeOfService == TCPIP_IPV4_THROUGHPUT_HIGH)
    9f16:	7d0d      	ldrb	r5, [r1, #20]
    9f18:	2d10      	cmp	r5, #16
    9f1a:	d10b      	bne.n	9f34 <GenericTxStart+0x134>
                            if(mpIState->sockWaitToSend)
    9f1c:	f891 50d4 	ldrb.w	r5, [r1, #212]	; 0xd4
    9f20:	b145      	cbz	r5, 9f34 <GenericTxStart+0x134>
                                mpIState->waitCount += 1;
    9f22:	3201      	adds	r2, #1
    9f24:	f881 20d5 	strb.w	r2, [r1, #213]	; 0xd5
                                return IPERF_TX_WAIT;
    9f28:	2500      	movs	r5, #0
    9f2a:	e137      	b.n	a19c <GenericTxStart+0x39c>
                if(mpIState->waitCount == 3) mpIState->waitCount = 0;
    9f2c:	2a03      	cmp	r2, #3
    9f2e:	bf08      	it	eq
    9f30:	f881 c0d5 	strbeq.w	ip, [r1, #213]	; 0xd5
            for(i = 0, mpIState = gIperfState; i < nIperfSessions; i++, mpIState++)
    9f34:	3301      	adds	r3, #1
    9f36:	b2db      	uxtb	r3, r3
    9f38:	31d8      	adds	r1, #216	; 0xd8
    9f3a:	4283      	cmp	r3, r0
    9f3c:	da1d      	bge.n	9f7a <GenericTxStart+0x17a>
    	        if(mpIState == pIState) continue;
    9f3e:	428c      	cmp	r4, r1
    9f40:	d0f8      	beq.n	9f34 <GenericTxStart+0x134>
                if(mpIState->waitCount < 3)    
    9f42:	f891 20d5 	ldrb.w	r2, [r1, #213]	; 0xd5
    9f46:	2a02      	cmp	r2, #2
    9f48:	d8f0      	bhi.n	9f2c <GenericTxStart+0x12c>
                switch(pIState->mTypeOfService)
    9f4a:	7d25      	ldrb	r5, [r4, #20]
    9f4c:	2d08      	cmp	r5, #8
    9f4e:	d0d4      	beq.n	9efa <GenericTxStart+0xfa>
    9f50:	2d20      	cmp	r5, #32
    9f52:	d0e0      	beq.n	9f16 <GenericTxStart+0x116>
    9f54:	2d00      	cmp	r5, #0
    9f56:	d1e9      	bne.n	9f2c <GenericTxStart+0x12c>
                        if(mpIState->mTypeOfService == TCPIP_IPV4_RELIABILITY_HIGH || mpIState->mTypeOfService == TCPIP_IPV4_THROUGHPUT_HIGH )
    9f58:	f891 e014 	ldrb.w	lr, [r1, #20]
    9f5c:	f1be 0f20 	cmp.w	lr, #32
    9f60:	d002      	beq.n	9f68 <GenericTxStart+0x168>
    9f62:	f1be 0f10 	cmp.w	lr, #16
    9f66:	d1e5      	bne.n	9f34 <GenericTxStart+0x134>
                            if(mpIState->sockWaitToSend)
    9f68:	f891 e0d4 	ldrb.w	lr, [r1, #212]	; 0xd4
    9f6c:	f1be 0f00 	cmp.w	lr, #0
    9f70:	d0e0      	beq.n	9f34 <GenericTxStart+0x134>
                                mpIState->waitCount += 1;
    9f72:	3201      	adds	r2, #1
    9f74:	f881 20d5 	strb.w	r2, [r1, #213]	; 0xd5
                                return IPERF_TX_WAIT;
    9f78:	e110      	b.n	a19c <GenericTxStart+0x39c>
            if ( TCPIP_UDP_TxPutIsReady(pIState->udpSock, pIState->mDatagramSize) < pIState->mDatagramSize )
    9f7a:	89a1      	ldrh	r1, [r4, #12]
    9f7c:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    9f80:	f018 f87b 	bl	2207a <TCPIP_UDP_TxPutIsReady>
    9f84:	68e3      	ldr	r3, [r4, #12]
    9f86:	4298      	cmp	r0, r3
    9f88:	d22d      	bcs.n	9fe6 <GenericTxStart+0x1e6>
                pIState->sockWaitToSend += 1;
    9f8a:	f894 30d4 	ldrb.w	r3, [r4, #212]	; 0xd4
    9f8e:	3301      	adds	r3, #1
    9f90:	f884 30d4 	strb.w	r3, [r4, #212]	; 0xd4
                if(pIState->txWaitTick == 0)
    9f94:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
    9f98:	b143      	cbz	r3, 9fac <GenericTxStart+0x1ac>
                else if((int32_t)(SYS_TMR_TickCountGet() - pIState->txWaitTick) < 0)
    9f9a:	f016 f807 	bl	1ffac <SYS_TMR_TickCountGet>
    9f9e:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
    9fa2:	1ac3      	subs	r3, r0, r3
    9fa4:	2b00      	cmp	r3, #0
    9fa6:	da14      	bge.n	9fd2 <GenericTxStart+0x1d2>
					return IPERF_TX_WAIT;
    9fa8:	2500      	movs	r5, #0
    9faa:	e0f7      	b.n	a19c <GenericTxStart+0x39c>
                    pIState->txWaitTick = SYS_TMR_TickCountGet() + ((TCPIP_IPERF_TX_WAIT_TMO * SYS_TMR_TickCounterFrequencyGet()) + 999)/1000;
    9fac:	f015 fffe 	bl	1ffac <SYS_TMR_TickCountGet>
    9fb0:	4605      	mov	r5, r0
    9fb2:	f016 f823 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
    9fb6:	2364      	movs	r3, #100	; 0x64
    9fb8:	fb03 f300 	mul.w	r3, r3, r0
    9fbc:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
    9fc0:	4a7d      	ldr	r2, [pc, #500]	; (a1b8 <GenericTxStart+0x3b8>)
    9fc2:	fba2 2303 	umull	r2, r3, r2, r3
    9fc6:	eb05 1393 	add.w	r3, r5, r3, lsr #6
    9fca:	f8c4 30b4 	str.w	r3, [r4, #180]	; 0xb4
                    return IPERF_TX_WAIT;
    9fce:	2500      	movs	r5, #0
    9fd0:	e0e4      	b.n	a19c <GenericTxStart+0x39c>
                (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf: Failed to get %d bytes socket TX space\r\n", pIState->mDatagramSize);
    9fd2:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    9fd6:	681b      	ldr	r3, [r3, #0]
    9fd8:	685b      	ldr	r3, [r3, #4]
    9fda:	68e2      	ldr	r2, [r4, #12]
    9fdc:	4977      	ldr	r1, [pc, #476]	; (a1bc <GenericTxStart+0x3bc>)
    9fde:	4638      	mov	r0, r7
    9fe0:	4798      	blx	r3
                return IPERF_TX_FAIL;
    9fe2:	2502      	movs	r5, #2
    9fe4:	e0da      	b.n	a19c <GenericTxStart+0x39c>
                pIState->txWaitTick = 0;
    9fe6:	2300      	movs	r3, #0
    9fe8:	f8c4 30b4 	str.w	r3, [r4, #180]	; 0xb4
                pIState->sockWaitToSend -= 1;                
    9fec:	f894 30d4 	ldrb.w	r3, [r4, #212]	; 0xd4
    9ff0:	3b01      	subs	r3, #1
    9ff2:	f884 30d4 	strb.w	r3, [r4, #212]	; 0xd4
    GenericTxHeaderPreparation(pIState, g_bfr, pIState->isLastTransmit);
    9ff6:	f894 10d0 	ldrb.w	r1, [r4, #208]	; 0xd0
    switch ( pIState->mProtocol )
    9ffa:	7c23      	ldrb	r3, [r4, #16]
    9ffc:	2b01      	cmp	r3, #1
    9ffe:	f000 808b 	beq.w	a118 <GenericTxStart+0x318>
    a002:	2b02      	cmp	r3, #2
    a004:	f000 808c 	beq.w	a120 <GenericTxStart+0x320>
    tClientHdr *pClientHdr = NULL;
    a008:	2300      	movs	r3, #0
    tIperfPktInfo *pPktInfo = NULL;
    a00a:	461d      	mov	r5, r3
    pClientHdr->flags = TCPIP_Helper_htonl( (uint32_t) 0);
    a00c:	2000      	movs	r0, #0
    a00e:	6018      	str	r0, [r3, #0]
    pClientHdr->numThreads = TCPIP_Helper_htonl((uint32_t) 1);
    a010:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    a014:	605a      	str	r2, [r3, #4]
    pClientHdr->mPort = TCPIP_Helper_htonl((uint32_t) pIState->mServerPort);
    a016:	f8b4 c012 	ldrh.w	ip, [r4, #18]
    return (((hLong & 0x000000ff) << 24) | ((hLong & 0x0000ff00) << 8) | ((hLong & 0x00ff0000) >> 8) | ((hLong & 0xff000000) >> 24));
    a01a:	ea4f 220c 	mov.w	r2, ip, lsl #8
    a01e:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
    a022:	ea42 620c 	orr.w	r2, r2, ip, lsl #24
    a026:	609a      	str	r2, [r3, #8]
    pClientHdr->bufferlen = TCPIP_Helper_htonl( (uint32_t) 0);
    a028:	60d8      	str	r0, [r3, #12]
    pClientHdr->mWinBand = TCPIP_Helper_htonl(pIState->mTxRate);
    a02a:	69a2      	ldr	r2, [r4, #24]
    a02c:	0e10      	lsrs	r0, r2, #24
    a02e:	ea40 6002 	orr.w	r0, r0, r2, lsl #24
    a032:	ea4f 2c02 	mov.w	ip, r2, lsl #8
    a036:	f40c 0c7f 	and.w	ip, ip, #16711680	; 0xff0000
    a03a:	ea40 000c 	orr.w	r0, r0, ip
    a03e:	0a12      	lsrs	r2, r2, #8
    a040:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
    a044:	4302      	orrs	r2, r0
    a046:	611a      	str	r2, [r3, #16]
    if ( pIState->mAmount != 0u )
    a048:	6860      	ldr	r0, [r4, #4]
    a04a:	2800      	cmp	r0, #0
    a04c:	d06c      	beq.n	a128 <GenericTxStart+0x328>
    a04e:	0e02      	lsrs	r2, r0, #24
    a050:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    a054:	ea4f 2c00 	mov.w	ip, r0, lsl #8
    a058:	f40c 0c7f 	and.w	ip, ip, #16711680	; 0xff0000
    a05c:	ea42 020c 	orr.w	r2, r2, ip
    a060:	0a00      	lsrs	r0, r0, #8
    a062:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
    a066:	4302      	orrs	r2, r0
    a068:	615a      	str	r2, [r3, #20]
    if ( isTheLastTransmit == true )
    a06a:	2900      	cmp	r1, #0
    a06c:	d070      	beq.n	a150 <GenericTxStart+0x350>
        pPktInfo->id = - ( (long) (pIState->pktId - pIState->nAttempts) );
    a06e:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
    a072:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    a074:	1a9b      	subs	r3, r3, r2
    a076:	0e1a      	lsrs	r2, r3, #24
    a078:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    a07c:	0219      	lsls	r1, r3, #8
    a07e:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    a082:	430a      	orrs	r2, r1
    a084:	0a1b      	lsrs	r3, r3, #8
    a086:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    a08a:	4313      	orrs	r3, r2
    pPktInfo->id = TCPIP_Helper_htonl(pPktInfo->id);
    a08c:	602b      	str	r3, [r5, #0]
    currentTime = SYS_TMR_TickCountGet();
    a08e:	f015 ff8d 	bl	1ffac <SYS_TMR_TickCountGet>
    a092:	4680      	mov	r8, r0
    uint32_t tickFreq = SYS_TMR_TickCounterFrequencyGet(); 
    a094:	f015 ffb2 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
    pPktInfo->tv_sec = TCPIP_Helper_htonl(currentTime / tickFreq);
    a098:	fbb8 f3f0 	udiv	r3, r8, r0
    a09c:	0e1a      	lsrs	r2, r3, #24
    a09e:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
    a0a2:	0219      	lsls	r1, r3, #8
    a0a4:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    a0a8:	430a      	orrs	r2, r1
    a0aa:	0a1b      	lsrs	r3, r3, #8
    a0ac:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    a0b0:	4313      	orrs	r3, r2
    a0b2:	606b      	str	r3, [r5, #4]
    tmp2 = ((pIState->stopTime - pIState->startTime) % tickFreq);
    a0b4:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
    a0b8:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    a0bc:	1ad3      	subs	r3, r2, r3
    a0be:	fbb3 f2f0 	udiv	r2, r3, r0
    a0c2:	fb00 3212 	mls	r2, r0, r2, r3
    tmp2 =  tmp2 * 1000 / tickFreq; /* Convert to mSec */
    a0c6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    a0ca:	fb03 f202 	mul.w	r2, r3, r2
    a0ce:	fbb2 f0f0 	udiv	r0, r2, r0
    tmp2 *= 1000;   /* 1000 uSecs per mSec */
    a0d2:	fb03 f000 	mul.w	r0, r3, r0
    a0d6:	0e03      	lsrs	r3, r0, #24
    a0d8:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
    a0dc:	0202      	lsls	r2, r0, #8
    a0de:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
    a0e2:	4313      	orrs	r3, r2
    a0e4:	0a00      	lsrs	r0, r0, #8
    a0e6:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
    a0ea:	4318      	orrs	r0, r3
    pPktInfo->tv_usec = TCPIP_Helper_htonl( tmp2 );
    a0ec:	60a8      	str	r0, [r5, #8]
    switch( pIState->mProtocol)
    a0ee:	7c25      	ldrb	r5, [r4, #16]
    a0f0:	2d01      	cmp	r5, #1
    a0f2:	d03a      	beq.n	a16a <GenericTxStart+0x36a>
    a0f4:	2d02      	cmp	r5, #2
    a0f6:	d154      	bne.n	a1a2 <GenericTxStart+0x3a2>
            pIState->remainingTxData = (pIState->mMSS - MAX_BUFFER);
    a0f8:	f8b4 30d2 	ldrh.w	r3, [r4, #210]	; 0xd2
    a0fc:	3b34      	subs	r3, #52	; 0x34
    a0fe:	f8a4 30b0 	strh.w	r3, [r4, #176]	; 0xb0
            if (( TCPIP_TCP_ArrayPut(pIState->tcpClientSock, (uint8_t*) g_bfr, MAX_BUFFER) != MAX_BUFFER ) && (!iperfKilled))
    a102:	2234      	movs	r2, #52	; 0x34
    a104:	492e      	ldr	r1, [pc, #184]	; (a1c0 <GenericTxStart+0x3c0>)
    a106:	f9b4 003a 	ldrsh.w	r0, [r4, #58]	; 0x3a
    a10a:	f006 fd13 	bl	10b34 <TCPIP_TCP_ArrayPut>
    a10e:	2834      	cmp	r0, #52	; 0x34
    a110:	d049      	beq.n	a1a6 <GenericTxStart+0x3a6>
    a112:	b1fe      	cbz	r6, a154 <GenericTxStart+0x354>
    return IPERF_TX_OK;
    a114:	2501      	movs	r5, #1
    a116:	e041      	b.n	a19c <GenericTxStart+0x39c>
            pClientHdr = (tClientHdr *) (pPktInfo + 1);
    a118:	4d29      	ldr	r5, [pc, #164]	; (a1c0 <GenericTxStart+0x3c0>)
    a11a:	f105 030c 	add.w	r3, r5, #12
    a11e:	e775      	b.n	a00c <GenericTxStart+0x20c>
            pClientHdr = (tClientHdr *) pData;
    a120:	4b27      	ldr	r3, [pc, #156]	; (a1c0 <GenericTxStart+0x3c0>)
            pPktInfo = (tIperfPktInfo *) (pClientHdr + 1);
    a122:	f103 0518 	add.w	r5, r3, #24
    a126:	e771      	b.n	a00c <GenericTxStart+0x20c>
        pClientHdr->mAmount = TCPIP_Helper_htonl( - (long) (pIState->mDuration/10) );
    a128:	68a2      	ldr	r2, [r4, #8]
    a12a:	4826      	ldr	r0, [pc, #152]	; (a1c4 <GenericTxStart+0x3c4>)
    a12c:	fba0 2002 	umull	r2, r0, r0, r2
    a130:	08c0      	lsrs	r0, r0, #3
    a132:	4240      	negs	r0, r0
    a134:	0e02      	lsrs	r2, r0, #24
    a136:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    a13a:	ea4f 2c00 	mov.w	ip, r0, lsl #8
    a13e:	f40c 0c7f 	and.w	ip, ip, #16711680	; 0xff0000
    a142:	ea42 020c 	orr.w	r2, r2, ip
    a146:	0a00      	lsrs	r0, r0, #8
    a148:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
    a14c:	4302      	orrs	r2, r0
    a14e:	e78b      	b.n	a068 <GenericTxStart+0x268>
        pPktInfo->id = pIState->pktId;
    a150:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    a152:	e790      	b.n	a076 <GenericTxStart+0x276>
                (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Socket send failed\r\n");
    a154:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    a158:	681b      	ldr	r3, [r3, #0]
    a15a:	681b      	ldr	r3, [r3, #0]
    a15c:	491a      	ldr	r1, [pc, #104]	; (a1c8 <GenericTxStart+0x3c8>)
    a15e:	4638      	mov	r0, r7
    a160:	4798      	blx	r3
                pIState->errorCount++;
    a162:	6b23      	ldr	r3, [r4, #48]	; 0x30
    a164:	3301      	adds	r3, #1
    a166:	6323      	str	r3, [r4, #48]	; 0x30
                return IPERF_TX_FAIL;
    a168:	e018      	b.n	a19c <GenericTxStart+0x39c>
            pIState->remainingTxData = (pIState->mDatagramSize - MAX_BUFFER);
    a16a:	68e3      	ldr	r3, [r4, #12]
    a16c:	3b34      	subs	r3, #52	; 0x34
    a16e:	f8a4 30b0 	strh.w	r3, [r4, #176]	; 0xb0
            if ( TCPIP_UDP_ArrayPut(pIState->udpSock, g_bfr, MAX_BUFFER) != MAX_BUFFER )
    a172:	2234      	movs	r2, #52	; 0x34
    a174:	4912      	ldr	r1, [pc, #72]	; (a1c0 <GenericTxStart+0x3c0>)
    a176:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
    a17a:	f012 fbd6 	bl	1c92a <TCPIP_UDP_ArrayPut>
    a17e:	2834      	cmp	r0, #52	; 0x34
    a180:	d00c      	beq.n	a19c <GenericTxStart+0x39c>
                (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Socket send failed\r\n");
    a182:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    a186:	681b      	ldr	r3, [r3, #0]
    a188:	681b      	ldr	r3, [r3, #0]
    a18a:	490f      	ldr	r1, [pc, #60]	; (a1c8 <GenericTxStart+0x3c8>)
    a18c:	4638      	mov	r0, r7
    a18e:	4798      	blx	r3
                pIState->errorCount++;
    a190:	6b23      	ldr	r3, [r4, #48]	; 0x30
    a192:	3301      	adds	r3, #1
    a194:	6323      	str	r3, [r4, #48]	; 0x30
                return IPERF_TX_FAIL;
    a196:	2502      	movs	r5, #2
    a198:	e000      	b.n	a19c <GenericTxStart+0x39c>
       	return IPERF_TX_WAIT;
    a19a:	2500      	movs	r5, #0
}
    a19c:	4628      	mov	r0, r5
    a19e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return IPERF_TX_OK;
    a1a2:	2501      	movs	r5, #1
    a1a4:	e7fa      	b.n	a19c <GenericTxStart+0x39c>
    a1a6:	2501      	movs	r5, #1
    a1a8:	e7f8      	b.n	a19c <GenericTxStart+0x39c>
    a1aa:	bf00      	nop
    a1ac:	00005258 	.word	0x00005258
    a1b0:	2000e5f8 	.word	0x2000e5f8
    a1b4:	2000dbb0 	.word	0x2000dbb0
    a1b8:	10624dd3 	.word	0x10624dd3
    a1bc:	0000528c 	.word	0x0000528c
    a1c0:	2000e268 	.word	0x2000e268
    a1c4:	cccccccd 	.word	0xcccccccd
    a1c8:	00005160 	.word	0x00005160

Disassembly of section .text.APP_Tasks%208:

0000a1cc <APP_Tasks>:


//                     vTaskDelay( pdMS_TO_TICKS( 1000 ) );

void __attribute__((optimize("-O0"))) APP_Tasks(void)
{
    a1cc:	b590      	push	{r4, r7, lr}
    a1ce:	b0a3      	sub	sp, #140	; 0x8c
    a1d0:	af02      	add	r7, sp, #8
	DRV_MIIM_RESULT opRes = DRV_MIIM_RES_OK;
    a1d2:	2300      	movs	r3, #0
    a1d4:	f887 307b 	strb.w	r3, [r7, #123]	; 0x7b
    IPV4_ADDR ipAddr;
    TCPIP_NET_HANDLE netH;
    
    {
        static int old_but1 = 0;        
        int temp_but1 = BUTTON1_Get();
    a1d8:	4bb8      	ldr	r3, [pc, #736]	; (a4bc <APP_Tasks+0x2f0>)
    a1da:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
    a1de:	0adb      	lsrs	r3, r3, #11
    a1e0:	f003 0301 	and.w	r3, r3, #1
    a1e4:	677b      	str	r3, [r7, #116]	; 0x74
        if( temp_but1 && !old_but1 ){
    a1e6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    a1e8:	2b00      	cmp	r3, #0
    a1ea:	d008      	beq.n	a1fe <APP_Tasks+0x32>
    a1ec:	4bb4      	ldr	r3, [pc, #720]	; (a4c0 <APP_Tasks+0x2f4>)
    a1ee:	681b      	ldr	r3, [r3, #0]
    a1f0:	2b00      	cmp	r3, #0
    a1f2:	d104      	bne.n	a1fe <APP_Tasks+0x32>
            LED1_Set();            
    a1f4:	4bb1      	ldr	r3, [pc, #708]	; (a4bc <APP_Tasks+0x2f0>)
    a1f6:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    a1fa:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        }
        if( !temp_but1 && old_but1 ){
    a1fe:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    a200:	2b00      	cmp	r3, #0
    a202:	d10e      	bne.n	a222 <APP_Tasks+0x56>
    a204:	4bae      	ldr	r3, [pc, #696]	; (a4c0 <APP_Tasks+0x2f4>)
    a206:	681b      	ldr	r3, [r3, #0]
    a208:	2b00      	cmp	r3, #0
    a20a:	d00a      	beq.n	a222 <APP_Tasks+0x56>
            LED1_Clear();
    a20c:	4bab      	ldr	r3, [pc, #684]	; (a4bc <APP_Tasks+0x2f0>)
    a20e:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    a212:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
            SERCOM1_USART_Virtual_Send("iperf -c 192.168.1.1\n");
    a216:	48ab      	ldr	r0, [pc, #684]	; (a4c4 <APP_Tasks+0x2f8>)
    a218:	f00f fc7a 	bl	19b10 <SERCOM1_USART_Virtual_Send>
            gfx_mono_print_scroll("iperf TCP client");
    a21c:	48aa      	ldr	r0, [pc, #680]	; (a4c8 <APP_Tasks+0x2fc>)
    a21e:	f00e fd5b 	bl	18cd8 <gfx_mono_print_scroll>
        }
        old_but1 = temp_but1;
    a222:	4aa7      	ldr	r2, [pc, #668]	; (a4c0 <APP_Tasks+0x2f4>)
    a224:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    a226:	6013      	str	r3, [r2, #0]

        static int old_but2 = 0;        
        int temp_but2 = BUTTON2_Get();
    a228:	4ba4      	ldr	r3, [pc, #656]	; (a4bc <APP_Tasks+0x2f0>)
    a22a:	6a1b      	ldr	r3, [r3, #32]
    a22c:	0a1b      	lsrs	r3, r3, #8
    a22e:	f003 0301 	and.w	r3, r3, #1
    a232:	673b      	str	r3, [r7, #112]	; 0x70
        if( temp_but2 && !old_but2 ){
    a234:	6f3b      	ldr	r3, [r7, #112]	; 0x70
    a236:	2b00      	cmp	r3, #0
    a238:	d008      	beq.n	a24c <APP_Tasks+0x80>
    a23a:	4ba4      	ldr	r3, [pc, #656]	; (a4cc <APP_Tasks+0x300>)
    a23c:	681b      	ldr	r3, [r3, #0]
    a23e:	2b00      	cmp	r3, #0
    a240:	d104      	bne.n	a24c <APP_Tasks+0x80>
            LED2_Set();            
    a242:	4b9e      	ldr	r3, [pc, #632]	; (a4bc <APP_Tasks+0x2f0>)
    a244:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    a248:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        }
        if( !temp_but2 && old_but2 ){
    a24c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
    a24e:	2b00      	cmp	r3, #0
    a250:	d10e      	bne.n	a270 <APP_Tasks+0xa4>
    a252:	4b9e      	ldr	r3, [pc, #632]	; (a4cc <APP_Tasks+0x300>)
    a254:	681b      	ldr	r3, [r3, #0]
    a256:	2b00      	cmp	r3, #0
    a258:	d00a      	beq.n	a270 <APP_Tasks+0xa4>
            LED2_Clear();
    a25a:	4b98      	ldr	r3, [pc, #608]	; (a4bc <APP_Tasks+0x2f0>)
    a25c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    a260:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
            SERCOM1_USART_Virtual_Send("iperf -c 192.168.1.1 -u\n");
    a264:	489a      	ldr	r0, [pc, #616]	; (a4d0 <APP_Tasks+0x304>)
    a266:	f00f fc53 	bl	19b10 <SERCOM1_USART_Virtual_Send>
            gfx_mono_print_scroll("iperf UDP client");
    a26a:	489a      	ldr	r0, [pc, #616]	; (a4d4 <APP_Tasks+0x308>)
    a26c:	f00e fd34 	bl	18cd8 <gfx_mono_print_scroll>
        }
        old_but2 = temp_but2;
    a270:	4a96      	ldr	r2, [pc, #600]	; (a4cc <APP_Tasks+0x300>)
    a272:	6f3b      	ldr	r3, [r7, #112]	; 0x70
    a274:	6013      	str	r3, [r2, #0]

        if(BUTTON3_Get())LED3_Set();else LED3_Clear();
    a276:	4b91      	ldr	r3, [pc, #580]	; (a4bc <APP_Tasks+0x2f0>)
    a278:	6a1b      	ldr	r3, [r3, #32]
    a27a:	0a5b      	lsrs	r3, r3, #9
    a27c:	f003 0301 	and.w	r3, r3, #1
    a280:	2b00      	cmp	r3, #0
    a282:	d005      	beq.n	a290 <APP_Tasks+0xc4>
    a284:	4b8d      	ldr	r3, [pc, #564]	; (a4bc <APP_Tasks+0x2f0>)
    a286:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    a28a:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
    a28e:	e004      	b.n	a29a <APP_Tasks+0xce>
    a290:	4b8a      	ldr	r3, [pc, #552]	; (a4bc <APP_Tasks+0x2f0>)
    a292:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    a296:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194
    }
    
    
	/* Check the application's current state. */
	switch (appData.state)
    a29a:	4b8f      	ldr	r3, [pc, #572]	; (a4d8 <APP_Tasks+0x30c>)
    a29c:	781b      	ldrb	r3, [r3, #0]
    a29e:	2b08      	cmp	r3, #8
    a2a0:	f200 814e 	bhi.w	a540 <APP_Tasks+0x374>
    a2a4:	a201      	add	r2, pc, #4	; (adr r2, a2ac <APP_Tasks+0xe0>)
    a2a6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    a2aa:	bf00      	nop
    a2ac:	0000a309 	.word	0x0000a309
    a2b0:	0000a2d1 	.word	0x0000a2d1
    a2b4:	0000a2dd 	.word	0x0000a2dd
    a2b8:	0000a323 	.word	0x0000a323
    a2bc:	0000a395 	.word	0x0000a395
    a2c0:	0000a541 	.word	0x0000a541
    a2c4:	0000a40f 	.word	0x0000a40f
    a2c8:	0000a41b 	.word	0x0000a41b
    a2cc:	0000a541 	.word	0x0000a541
    {
        
        case APP_DISPLAY_INIT:
        {
            gfx_mono_ssd1306_init();
    a2d0:	f012 faba 	bl	1c848 <gfx_mono_ssd1306_init>
            appData.state = APP_WAIT_STACK_INIT;
    a2d4:	4b80      	ldr	r3, [pc, #512]	; (a4d8 <APP_Tasks+0x30c>)
    a2d6:	2202      	movs	r2, #2
    a2d8:	701a      	strb	r2, [r3, #0]
            break;
    a2da:	e138      	b.n	a54e <APP_Tasks+0x382>
        }
        
        /* Wait till TCP stack is initialized. */
        case APP_WAIT_STACK_INIT:
        {
            if (TCPIP_STACK_Status(sysObj.tcpip) == SYS_STATUS_READY)
    a2dc:	4b7f      	ldr	r3, [pc, #508]	; (a4dc <APP_Tasks+0x310>)
    a2de:	689b      	ldr	r3, [r3, #8]
    a2e0:	4618      	mov	r0, r3
    a2e2:	f016 fdb3 	bl	20e4c <TCPIP_STACK_Status>
    a2e6:	4603      	mov	r3, r0
    a2e8:	2b02      	cmp	r3, #2
    a2ea:	f040 812b 	bne.w	a544 <APP_Tasks+0x378>
            {
                TCPIP_DHCP_HandlerRegister(TCPIP_STACK_IndexToNet(0), MONITOR_DHCP_eth_Handler, &dhcp_eth_hParam);
    a2ee:	2000      	movs	r0, #0
    a2f0:	f015 fd94 	bl	1fe1c <TCPIP_STACK_IndexToNet>
    a2f4:	4603      	mov	r3, r0
    a2f6:	4a7a      	ldr	r2, [pc, #488]	; (a4e0 <APP_Tasks+0x314>)
    a2f8:	497a      	ldr	r1, [pc, #488]	; (a4e4 <APP_Tasks+0x318>)
    a2fa:	4618      	mov	r0, r3
    a2fc:	f014 fae0 	bl	1e8c0 <TCPIP_DHCP_HandlerRegister>
                appData.state = APP_MIIM_INIT;
    a300:	4b75      	ldr	r3, [pc, #468]	; (a4d8 <APP_Tasks+0x30c>)
    a302:	2200      	movs	r2, #0
    a304:	701a      	strb	r2, [r3, #0]
            }
            break;
    a306:	e11d      	b.n	a544 <APP_Tasks+0x378>

        /* Initialize the MIIM instance. */
        case APP_MIIM_INIT:
        {
            /*  Setup the MIIM driver instance. */
            if (local_miim_init() < 0)
    a308:	f00f f82c 	bl	19364 <local_miim_init>
    a30c:	4603      	mov	r3, r0
    a30e:	2b00      	cmp	r3, #0
    a310:	da03      	bge.n	a31a <APP_Tasks+0x14e>
            {
                SYS_CONSOLE_PRINT("App: miim setup failed !\r\n");
    a312:	4975      	ldr	r1, [pc, #468]	; (a4e8 <APP_Tasks+0x31c>)
    a314:	2000      	movs	r0, #0
    a316:	f010 fa29 	bl	1a76c <SYS_CONSOLE_Print>
            }

            appData.state = APP_READ_OPERATION_MODE;
    a31a:	4b6f      	ldr	r3, [pc, #444]	; (a4d8 <APP_Tasks+0x30c>)
    a31c:	2203      	movs	r2, #3
    a31e:	701a      	strb	r2, [r3, #0]
            break;
    a320:	e115      	b.n	a54e <APP_Tasks+0x382>

        /* Read in which mode of 10BaseT1s is working, CSMA/CD or PLCA. */
        case APP_READ_OPERATION_MODE:
        {
            // Example for Read register.
            opRes = Read_Phy_Register(&clientObj, 0, PHY_PLCA_CONTROL_0, &data);
    a322:	4b72      	ldr	r3, [pc, #456]	; (a4ec <APP_Tasks+0x320>)
    a324:	4a72      	ldr	r2, [pc, #456]	; (a4f0 <APP_Tasks+0x324>)
    a326:	2100      	movs	r1, #0
    a328:	4872      	ldr	r0, [pc, #456]	; (a4f4 <APP_Tasks+0x328>)
    a32a:	f017 fc07 	bl	21b3c <Read_Phy_Register>
    a32e:	4603      	mov	r3, r0
    a330:	f887 307b 	strb.w	r3, [r7, #123]	; 0x7b

            if (opRes < 0)
    a334:	f997 307b 	ldrsb.w	r3, [r7, #123]	; 0x7b
    a338:	2b00      	cmp	r3, #0
    a33a:	da0a      	bge.n	a352 <APP_Tasks+0x186>
            {
                /* In case of an error, report and close miim instance. */
                SYS_CONSOLE_PRINT("Error occured:%d\r\n", opRes);
    a33c:	f997 307b 	ldrsb.w	r3, [r7, #123]	; 0x7b
    a340:	461a      	mov	r2, r3
    a342:	496d      	ldr	r1, [pc, #436]	; (a4f8 <APP_Tasks+0x32c>)
    a344:	2000      	movs	r0, #0
    a346:	f010 fa11 	bl	1a76c <SYS_CONSOLE_Print>
                appData.state = APP_MIIM_CLOSE;
    a34a:	4b63      	ldr	r3, [pc, #396]	; (a4d8 <APP_Tasks+0x30c>)
    a34c:	2206      	movs	r2, #6
    a34e:	701a      	strb	r2, [r3, #0]
                {
                    SYS_CONSOLE_PRINT(" Lan867x is in CSMA mode. \r\n", data);
                    appData.state = APP_MIIM_CLOSE;
                }
            }
            break;
    a350:	e0fa      	b.n	a548 <APP_Tasks+0x37c>
            else if (opRes == DRV_MIIM_RES_OK) /* Check operation is completed. */
    a352:	f997 307b 	ldrsb.w	r3, [r7, #123]	; 0x7b
    a356:	2b00      	cmp	r3, #0
    a358:	f040 80f6 	bne.w	a548 <APP_Tasks+0x37c>
                if(1 == R2F(data, PHY_PLCA_CTRL0_EN))
    a35c:	4b63      	ldr	r3, [pc, #396]	; (a4ec <APP_Tasks+0x320>)
    a35e:	881b      	ldrh	r3, [r3, #0]
    a360:	0bdb      	lsrs	r3, r3, #15
    a362:	b29b      	uxth	r3, r3
    a364:	2b01      	cmp	r3, #1
    a366:	d10a      	bne.n	a37e <APP_Tasks+0x1b2>
                    SYS_CONSOLE_PRINT(" Lan867x is in PLCA mode. \r\n", data);
    a368:	4b60      	ldr	r3, [pc, #384]	; (a4ec <APP_Tasks+0x320>)
    a36a:	881b      	ldrh	r3, [r3, #0]
    a36c:	461a      	mov	r2, r3
    a36e:	4963      	ldr	r1, [pc, #396]	; (a4fc <APP_Tasks+0x330>)
    a370:	2000      	movs	r0, #0
    a372:	f010 f9fb 	bl	1a76c <SYS_CONSOLE_Print>
                    appData.state = APP_READ_PLCA_CONFIGURATION;
    a376:	4b58      	ldr	r3, [pc, #352]	; (a4d8 <APP_Tasks+0x30c>)
    a378:	2204      	movs	r2, #4
    a37a:	701a      	strb	r2, [r3, #0]
            break;
    a37c:	e0e4      	b.n	a548 <APP_Tasks+0x37c>
                    SYS_CONSOLE_PRINT(" Lan867x is in CSMA mode. \r\n", data);
    a37e:	4b5b      	ldr	r3, [pc, #364]	; (a4ec <APP_Tasks+0x320>)
    a380:	881b      	ldrh	r3, [r3, #0]
    a382:	461a      	mov	r2, r3
    a384:	495e      	ldr	r1, [pc, #376]	; (a500 <APP_Tasks+0x334>)
    a386:	2000      	movs	r0, #0
    a388:	f010 f9f0 	bl	1a76c <SYS_CONSOLE_Print>
                    appData.state = APP_MIIM_CLOSE;
    a38c:	4b52      	ldr	r3, [pc, #328]	; (a4d8 <APP_Tasks+0x30c>)
    a38e:	2206      	movs	r2, #6
    a390:	701a      	strb	r2, [r3, #0]
            break;
    a392:	e0d9      	b.n	a548 <APP_Tasks+0x37c>
#endif

        /* Read the PLCA configuration. */
        case APP_READ_PLCA_CONFIGURATION:
        {
            opRes = Read_Phy_Register(&clientObj, 0, PHY_PLCA_CONTROL_1, &data);
    a394:	4b55      	ldr	r3, [pc, #340]	; (a4ec <APP_Tasks+0x320>)
    a396:	4a5b      	ldr	r2, [pc, #364]	; (a504 <APP_Tasks+0x338>)
    a398:	2100      	movs	r1, #0
    a39a:	4856      	ldr	r0, [pc, #344]	; (a4f4 <APP_Tasks+0x328>)
    a39c:	f017 fbce 	bl	21b3c <Read_Phy_Register>
    a3a0:	4603      	mov	r3, r0
    a3a2:	f887 307b 	strb.w	r3, [r7, #123]	; 0x7b
            if (opRes < 0)
    a3a6:	f997 307b 	ldrsb.w	r3, [r7, #123]	; 0x7b
    a3aa:	2b00      	cmp	r3, #0
    a3ac:	da0a      	bge.n	a3c4 <APP_Tasks+0x1f8>
            {
                /* In case of an error, report and close miim instance. */
                SYS_CONSOLE_PRINT("Error occured:%d\r\n", opRes);
    a3ae:	f997 307b 	ldrsb.w	r3, [r7, #123]	; 0x7b
    a3b2:	461a      	mov	r2, r3
    a3b4:	4950      	ldr	r1, [pc, #320]	; (a4f8 <APP_Tasks+0x32c>)
    a3b6:	2000      	movs	r0, #0
    a3b8:	f010 f9d8 	bl	1a76c <SYS_CONSOLE_Print>
                appData.state = APP_MIIM_CLOSE;
    a3bc:	4b46      	ldr	r3, [pc, #280]	; (a4d8 <APP_Tasks+0x30c>)
    a3be:	2206      	movs	r2, #6
    a3c0:	701a      	strb	r2, [r3, #0]
                    gfx_mono_print_scroll(TCPIP_NETWORK_DEFAULT_IP_ADDRESS_IDX0);
                    gfx_mono_print_scroll("Id: %d Count: %d", R2F(data, PHY_PLCA_CTRL1_ID0), R2F(data, PHY_PLCA_CTRL1_NCNT));                  
                }
                appData.state = APP_MIIM_CLOSE;
            }
            break;
    a3c2:	e0c3      	b.n	a54c <APP_Tasks+0x380>
            else if (opRes == DRV_MIIM_RES_OK) /* Check operation is completed. */
    a3c4:	f997 307b 	ldrsb.w	r3, [r7, #123]	; 0x7b
    a3c8:	2b00      	cmp	r3, #0
    a3ca:	f040 80bf 	bne.w	a54c <APP_Tasks+0x380>
                SYS_CONSOLE_PRINT(" Node Id: %d, Node count: %d. \r\n", R2F(data, PHY_PLCA_CTRL1_ID0), R2F(data, PHY_PLCA_CTRL1_NCNT));
    a3ce:	4b47      	ldr	r3, [pc, #284]	; (a4ec <APP_Tasks+0x320>)
    a3d0:	881b      	ldrh	r3, [r3, #0]
    a3d2:	b2da      	uxtb	r2, r3
    a3d4:	4b45      	ldr	r3, [pc, #276]	; (a4ec <APP_Tasks+0x320>)
    a3d6:	881b      	ldrh	r3, [r3, #0]
    a3d8:	0a1b      	lsrs	r3, r3, #8
    a3da:	b29b      	uxth	r3, r3
    a3dc:	494a      	ldr	r1, [pc, #296]	; (a508 <APP_Tasks+0x33c>)
    a3de:	2000      	movs	r0, #0
    a3e0:	f010 f9c4 	bl	1a76c <SYS_CONSOLE_Print>
                    gfx_mono_print_scroll("LAN867x PLCA"); 
    a3e4:	4849      	ldr	r0, [pc, #292]	; (a50c <APP_Tasks+0x340>)
    a3e6:	f00e fc77 	bl	18cd8 <gfx_mono_print_scroll>
                    gfx_mono_print_scroll(TCPIP_NETWORK_DEFAULT_IP_ADDRESS_IDX0);
    a3ea:	4849      	ldr	r0, [pc, #292]	; (a510 <APP_Tasks+0x344>)
    a3ec:	f00e fc74 	bl	18cd8 <gfx_mono_print_scroll>
                    gfx_mono_print_scroll("Id: %d Count: %d", R2F(data, PHY_PLCA_CTRL1_ID0), R2F(data, PHY_PLCA_CTRL1_NCNT));                  
    a3f0:	4b3e      	ldr	r3, [pc, #248]	; (a4ec <APP_Tasks+0x320>)
    a3f2:	881b      	ldrh	r3, [r3, #0]
    a3f4:	b2d9      	uxtb	r1, r3
    a3f6:	4b3d      	ldr	r3, [pc, #244]	; (a4ec <APP_Tasks+0x320>)
    a3f8:	881b      	ldrh	r3, [r3, #0]
    a3fa:	0a1b      	lsrs	r3, r3, #8
    a3fc:	b29b      	uxth	r3, r3
    a3fe:	461a      	mov	r2, r3
    a400:	4844      	ldr	r0, [pc, #272]	; (a514 <APP_Tasks+0x348>)
    a402:	f00e fc69 	bl	18cd8 <gfx_mono_print_scroll>
                appData.state = APP_MIIM_CLOSE;
    a406:	4b34      	ldr	r3, [pc, #208]	; (a4d8 <APP_Tasks+0x30c>)
    a408:	2206      	movs	r2, #6
    a40a:	701a      	strb	r2, [r3, #0]
            break;
    a40c:	e09e      	b.n	a54c <APP_Tasks+0x380>

        /* Close miim driver instance. */
        case APP_MIIM_CLOSE:
        {
            /* Close and release the handle(instance) to miim, as I do not need access to miim register anymore. */
            local_miim_close();
    a40e:	f016 fb9f 	bl	20b50 <local_miim_close>

            appData.state = APP_TCPIP_WAIT_FOR_IP;
    a412:	4b31      	ldr	r3, [pc, #196]	; (a4d8 <APP_Tasks+0x30c>)
    a414:	2207      	movs	r2, #7
    a416:	701a      	strb	r2, [r3, #0]
            break;
    a418:	e099      	b.n	a54e <APP_Tasks+0x382>

        case APP_TCPIP_WAIT_FOR_IP:

            // if the IP address of an interface has changed
            // display the new value on the system console
            nNets = TCPIP_STACK_NumberOfNetworksGet();
    a41a:	f017 fd73 	bl	21f04 <TCPIP_STACK_NumberOfNetworksGet>
    a41e:	66f8      	str	r0, [r7, #108]	; 0x6c

            for (i = 0; i < nNets; i++) {
    a420:	2300      	movs	r3, #0
    a422:	67fb      	str	r3, [r7, #124]	; 0x7c
    a424:	e086      	b.n	a534 <APP_Tasks+0x368>
                netH = TCPIP_STACK_IndexToNet(i);
    a426:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
    a428:	f015 fcf8 	bl	1fe1c <TCPIP_STACK_IndexToNet>
    a42c:	66b8      	str	r0, [r7, #104]	; 0x68
                if (!TCPIP_STACK_NetIsReady(netH)) {
    a42e:	6eb8      	ldr	r0, [r7, #104]	; 0x68
    a430:	f016 fed0 	bl	211d4 <TCPIP_STACK_NetIsReady>
    a434:	4603      	mov	r3, r0
    a436:	f083 0301 	eor.w	r3, r3, #1
    a43a:	b2db      	uxtb	r3, r3
    a43c:	2b00      	cmp	r3, #0
    a43e:	d175      	bne.n	a52c <APP_Tasks+0x360>
                    continue; // interface not ready yet! , 
                    //looking for another interface, that can be used for communication.
                }
                // Now. there is a ready interface that we can use
                ipAddr.Val = TCPIP_STACK_NetAddress(netH);
    a440:	6eb8      	ldr	r0, [r7, #104]	; 0x68
    a442:	f016 fbf2 	bl	20c2a <TCPIP_STACK_NetAddress>
    a446:	4603      	mov	r3, r0
    a448:	667b      	str	r3, [r7, #100]	; 0x64
                // display the changed IP address
                if (dwLastIP[i].Val != ipAddr.Val) {
    a44a:	4a33      	ldr	r2, [pc, #204]	; (a518 <APP_Tasks+0x34c>)
    a44c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
    a44e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    a452:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    a454:	429a      	cmp	r2, r3
    a456:	d02d      	beq.n	a4b4 <APP_Tasks+0x2e8>
                    dwLastIP[i].Val = ipAddr.Val;
    a458:	6e7a      	ldr	r2, [r7, #100]	; 0x64
    a45a:	492f      	ldr	r1, [pc, #188]	; (a518 <APP_Tasks+0x34c>)
    a45c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
    a45e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

                    SYS_CONSOLE_PRINT(TCPIP_STACK_NetNameGet(netH));
    a462:	6eb8      	ldr	r0, [r7, #104]	; 0x68
    a464:	f017 fdd1 	bl	2200a <TCPIP_STACK_NetNameGet>
    a468:	4603      	mov	r3, r0
    a46a:	4619      	mov	r1, r3
    a46c:	2000      	movs	r0, #0
    a46e:	f010 f97d 	bl	1a76c <SYS_CONSOLE_Print>
                    SYS_CONSOLE_PRINT(" IP Address: ");
    a472:	492a      	ldr	r1, [pc, #168]	; (a51c <APP_Tasks+0x350>)
    a474:	2000      	movs	r0, #0
    a476:	f010 f979 	bl	1a76c <SYS_CONSOLE_Print>
                    char str[100];
                    sprintf(str,"%d.%d.%d.%d", ipAddr.v[0], ipAddr.v[1], ipAddr.v[2], ipAddr.v[3]);
    a47a:	f897 3064 	ldrb.w	r3, [r7, #100]	; 0x64
    a47e:	4619      	mov	r1, r3
    a480:	f897 3065 	ldrb.w	r3, [r7, #101]	; 0x65
    a484:	461c      	mov	r4, r3
    a486:	f897 3066 	ldrb.w	r3, [r7, #102]	; 0x66
    a48a:	f897 2067 	ldrb.w	r2, [r7, #103]	; 0x67
    a48e:	4638      	mov	r0, r7
    a490:	9201      	str	r2, [sp, #4]
    a492:	9300      	str	r3, [sp, #0]
    a494:	4623      	mov	r3, r4
    a496:	460a      	mov	r2, r1
    a498:	4921      	ldr	r1, [pc, #132]	; (a520 <APP_Tasks+0x354>)
    a49a:	f013 f855 	bl	1d548 <siprintf>
                    SYS_CONSOLE_PRINT("%s\r\n", str);
    a49e:	463b      	mov	r3, r7
    a4a0:	461a      	mov	r2, r3
    a4a2:	4920      	ldr	r1, [pc, #128]	; (a524 <APP_Tasks+0x358>)
    a4a4:	2000      	movs	r0, #0
    a4a6:	f010 f961 	bl	1a76c <SYS_CONSOLE_Print>
                    gfx_mono_print_scroll("new:%s",str);
    a4aa:	463b      	mov	r3, r7
    a4ac:	4619      	mov	r1, r3
    a4ae:	481e      	ldr	r0, [pc, #120]	; (a528 <APP_Tasks+0x35c>)
    a4b0:	f00e fc12 	bl	18cd8 <gfx_mono_print_scroll>
                }
                appData.state = APP_STATE_SERVICE_TASKS;
    a4b4:	4b08      	ldr	r3, [pc, #32]	; (a4d8 <APP_Tasks+0x30c>)
    a4b6:	2208      	movs	r2, #8
    a4b8:	701a      	strb	r2, [r3, #0]
    a4ba:	e038      	b.n	a52e <APP_Tasks+0x362>
    a4bc:	41008000 	.word	0x41008000
    a4c0:	2000e6e4 	.word	0x2000e6e4
    a4c4:	0000afb4 	.word	0x0000afb4
    a4c8:	0000afcc 	.word	0x0000afcc
    a4cc:	2000e6e8 	.word	0x2000e6e8
    a4d0:	0000afe0 	.word	0x0000afe0
    a4d4:	0000affc 	.word	0x0000affc
    a4d8:	2000e710 	.word	0x2000e710
    a4dc:	2000e464 	.word	0x2000e464
    a4e0:	2000e6f4 	.word	0x2000e6f4
    a4e4:	00014711 	.word	0x00014711
    a4e8:	0000b010 	.word	0x0000b010
    a4ec:	2000e576 	.word	0x2000e576
    a4f0:	001fca01 	.word	0x001fca01
    a4f4:	2000e4f0 	.word	0x2000e4f0
    a4f8:	0000b02c 	.word	0x0000b02c
    a4fc:	0000b040 	.word	0x0000b040
    a500:	0000b060 	.word	0x0000b060
    a504:	001fca02 	.word	0x001fca02
    a508:	0000b080 	.word	0x0000b080
    a50c:	0000b0a4 	.word	0x0000b0a4
    a510:	0000b0b4 	.word	0x0000b0b4
    a514:	0000b0c4 	.word	0x0000b0c4
    a518:	2000e568 	.word	0x2000e568
    a51c:	0000b0d8 	.word	0x0000b0d8
    a520:	0000b0e8 	.word	0x0000b0e8
    a524:	0000b0f4 	.word	0x0000b0f4
    a528:	0000b0fc 	.word	0x0000b0fc
                    continue; // interface not ready yet! , 
    a52c:	bf00      	nop
            for (i = 0; i < nNets; i++) {
    a52e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
    a530:	3301      	adds	r3, #1
    a532:	67fb      	str	r3, [r7, #124]	; 0x7c
    a534:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
    a536:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    a538:	429a      	cmp	r2, r3
    a53a:	f6ff af74 	blt.w	a426 <APP_Tasks+0x25a>
            }
            break;
    a53e:	e006      	b.n	a54e <APP_Tasks+0x382>

        /* The default state should never be executed. */
        default:
        {
            /* TODO: Handle error in application's state machine. */
            break;
    a540:	bf00      	nop
    a542:	e004      	b.n	a54e <APP_Tasks+0x382>
            break;
    a544:	bf00      	nop
    a546:	e002      	b.n	a54e <APP_Tasks+0x382>
            break;
    a548:	bf00      	nop
    a54a:	e000      	b.n	a54e <APP_Tasks+0x382>
            break;
    a54c:	bf00      	nop
        }
	}
}
    a54e:	bf00      	nop
    a550:	3784      	adds	r7, #132	; 0x84
    a552:	46bd      	mov	sp, r7
    a554:	bd90      	pop	{r4, r7, pc}
    a556:	bf00      	nop

Disassembly of section .text.DRV_PIC32CGMAC_LibRxGetPacket%209:

0000a558 <DRV_PIC32CGMAC_LibRxGetPacket>:
/****************************************************************************
 * Function: DRV_PIC32CGMAC_LibRxGetPacket
 * Summary: extract  RX packet from the RX descriptor
 *****************************************************************************/
DRV_PIC32CGMAC_RESULT DRV_PIC32CGMAC_LibRxGetPacket(DRV_GMAC_DRIVER * pMACDrv, TCPIP_MAC_PACKET** pRxPkt, int* pnBuffs, DRV_GMAC_RXDCPT_STATUS* pRxStat, GMAC_QUE_LIST queueIdx)  
{	
    a558:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a55c:	b08b      	sub	sp, #44	; 0x2c
    a55e:	f89d 4050 	ldrb.w	r4, [sp, #80]	; 0x50
    a562:	9402      	str	r4, [sp, #8]
 * Summary: Check if 'Buffer Not Available' set by GMAC; if set, clear the BNA status bit
 * Return : True if BNA is set; False for no BNA status
 *****************************************************************************/
static bool _IsBufferNotAvailable(DRV_GMAC_DRIVER * pMACDrv)
{
    if(GMAC_REGS->GMAC_RSR & GMAC_RSR_BNA_Msk ) //Check for BNA error due to shortage of Rx Buffers
    a564:	4cac      	ldr	r4, [pc, #688]	; (a818 <DRV_PIC32CGMAC_LibRxGetPacket+0x2c0>)
    a566:	6a24      	ldr	r4, [r4, #32]
    a568:	f014 0f01 	tst.w	r4, #1
    a56c:	d028      	beq.n	a5c0 <DRV_PIC32CGMAC_LibRxGetPacket+0x68>
    {       
		//Clear GMAC 'Buffer Not Available' Flag			
		GMAC_REGS->GMAC_RSR = GMAC_RSR_BNA_Msk ;             
    a56e:	2401      	movs	r4, #1
    a570:	4da9      	ldr	r5, [pc, #676]	; (a818 <DRV_PIC32CGMAC_LibRxGetPacket+0x2c0>)
    a572:	622c      	str	r4, [r5, #32]
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    a574:	f3bf 8f5f 	dmb	sy
		__DMB();  
		return true;
    a578:	9404      	str	r4, [sp, #16]
	if(!pRxPkt)
    a57a:	2900      	cmp	r1, #0
    a57c:	f000 815a 	beq.w	a834 <DRV_PIC32CGMAC_LibRxGetPacket+0x2dc>
    a580:	9308      	str	r3, [sp, #32]
    a582:	9207      	str	r2, [sp, #28]
    a584:	9106      	str	r1, [sp, #24]
    a586:	4606      	mov	r6, r0
 * end rx descriptor indexes of valid rx data packet  
 * Return : frame search status
 *****************************************************************************/
static GMAC_RXFRAME_STATE _SearchRxPacket(DRV_GMAC_DRIVER * pMACDrv,DRV_PIC32CGMAC_RX_FRAME_INFO *rx_frame_state, GMAC_QUE_LIST queueIdx)  
{
    DRV_PIC32CGMAC_HW_RXDCPT *pRxDesc = pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc;
    a588:	9a02      	ldr	r2, [sp, #8]
    a58a:	4691      	mov	r9, r2
    a58c:	232c      	movs	r3, #44	; 0x2c
    a58e:	fb03 0302 	mla	r3, r3, r2, r0
    a592:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
    a596:	9105      	str	r1, [sp, #20]
    TCPIP_MAC_PACKET* pRxPkt;
    GMAC_RXFRAME_STATE frameState = GMAC_RX_NO_FRAME_STATE;
    uint16_t search_count = 0;
	uint16_t nRxDscCnt =  pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxDescCnt;
    a598:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
    a59c:	eb00 0242 	add.w	r2, r0, r2, lsl #1
    a5a0:	f8b2 70be 	ldrh.w	r7, [r2, #190]	; 0xbe
	uint16_t nRxDescIndex = pMACDrv->sGmacData.gmac_queue[queueIdx].nRxDescIndex;		
    a5a4:	f8b3 40b0 	ldrh.w	r4, [r3, #176]	; 0xb0
	uint16_t rx_index;
	uint16_t nRx_buffer;	
	
	//search the descriptors for valid data frame; search maximum of descriptor count
	while ( search_count < nRxDscCnt)
    a5a8:	2f00      	cmp	r7, #0
    a5aa:	f000 8145 	beq.w	a838 <DRV_PIC32CGMAC_LibRxGetPacket+0x2e0>
	DRV_PIC32CGMAC_RX_FRAME_INFO rx_frame_state = {0,0,0};
    a5ae:	2300      	movs	r3, #0
    a5b0:	9301      	str	r3, [sp, #4]
    a5b2:	9303      	str	r3, [sp, #12]
    uint16_t search_count = 0;
    a5b4:	4698      	mov	r8, r3
    GMAC_RXFRAME_STATE frameState = GMAC_RX_NO_FRAME_STATE;
    a5b6:	461d      	mov	r5, r3
                
				//clear all the descriptors before the error				
				while(nRx_buffer--)
				{                  
                    //Get Rx Packet assigned to Rx Descriptor with error
                    pRxPkt = pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[rx_index];
    a5b8:	232c      	movs	r3, #44	; 0x2c
    a5ba:	fb03 0909 	mla	r9, r3, r9, r0
    a5be:	e078      	b.n	a6b2 <DRV_PIC32CGMAC_LibRxGetPacket+0x15a>
		return false; 
    a5c0:	2400      	movs	r4, #0
    a5c2:	9404      	str	r4, [sp, #16]
    a5c4:	e7d9      	b.n	a57a <DRV_PIC32CGMAC_LibRxGetPacket+0x22>
                    if(GMAC_RX_SOF_BIT == ((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_status.val) & GMAC_RX_SOF_BIT))
    a5c6:	6859      	ldr	r1, [r3, #4]
    a5c8:	f411 4f80 	tst.w	r1, #16384	; 0x4000
    a5cc:	d108      	bne.n	a5e0 <DRV_PIC32CGMAC_LibRxGetPacket+0x88>
                        rx_frame_state->buffer_count++; 
    a5ce:	9901      	ldr	r1, [sp, #4]
    a5d0:	3101      	adds	r1, #1
    a5d2:	b289      	uxth	r1, r1
    a5d4:	9101      	str	r1, [sp, #4]
                        if(GMAC_RX_EOF_BIT == ((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_status.val) & GMAC_RX_EOF_BIT))
    a5d6:	685b      	ldr	r3, [r3, #4]
    a5d8:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    a5dc:	d05a      	beq.n	a694 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
    a5de:	e13d      	b.n	a85c <DRV_PIC32CGMAC_LibRxGetPacket+0x304>
                        rx_index =  fixed_mod(((rx_frame_state->startIndex) + (rx_frame_state->buffer_count) -1),nRxDscCnt);	
    a5e0:	9b03      	ldr	r3, [sp, #12]
    a5e2:	9a01      	ldr	r2, [sp, #4]
    a5e4:	189d      	adds	r5, r3, r2
    a5e6:	1e6b      	subs	r3, r5, #1
 * If both operands are non-negative then the remainder is non-negative;
 * if not, the sign of the remainder is implementation-defined 74).
 */
__STATIC_INLINE int fixed_mod(int a, int b)
{
	int rem = a % b;
    a5e8:	fb93 f5f7 	sdiv	r5, r3, r7
    a5ec:	fb07 3515 	mls	r5, r7, r5, r3

	while (rem < 0)
    a5f0:	2d00      	cmp	r5, #0
		rem += b;
    a5f2:	bfb8      	it	lt
    a5f4:	19ed      	addlt	r5, r5, r7
    a5f6:	b2ad      	uxth	r5, r5
                        nRx_buffer = rx_frame_state->buffer_count;
    a5f8:	f8dd a004 	ldr.w	sl, [sp, #4]
    a5fc:	e001      	b.n	a602 <DRV_PIC32CGMAC_LibRxGetPacket+0xaa>
                            GCIRC_DEC(rx_index, nRxDscCnt); 
    a5fe:	3d01      	subs	r5, #1
    a600:	b2ad      	uxth	r5, r5
                        while(nRx_buffer--)
    a602:	f10a 3aff 	add.w	sl, sl, #4294967295
    a606:	fa1f fa8a 	uxth.w	sl, sl
    a60a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    a60e:	459a      	cmp	sl, r3
    a610:	d025      	beq.n	a65e <DRV_PIC32CGMAC_LibRxGetPacket+0x106>
                            pRxPkt = pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[rx_index];
    a612:	46ab      	mov	fp, r5
    a614:	f8d9 308c 	ldr.w	r3, [r9, #140]	; 0x8c
    a618:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
                            (pRxPkt->ackFunc)(pRxPkt, pRxPkt->ackParam);
    a61c:	6883      	ldr	r3, [r0, #8]
    a61e:	68c1      	ldr	r1, [r0, #12]
    a620:	4798      	blx	r3
                            pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[rx_index] = 0; 
    a622:	f8d9 308c 	ldr.w	r3, [r9, #140]	; 0x8c
    a626:	2200      	movs	r2, #0
    a628:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
	if(pMACDrv->sGmacData._synchF != 0)
    a62c:	6b33      	ldr	r3, [r6, #48]	; 0x30
    a62e:	b11b      	cbz	r3, a638 <DRV_PIC32CGMAC_LibRxGetPacket+0xe0>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
    a630:	2105      	movs	r1, #5
    a632:	f106 005c 	add.w	r0, r6, #92	; 0x5c
    a636:	4798      	blx	r3
                            pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc[rx_index].rx_desc_buffaddr.val &= ~GMAC_RX_ADDRESS_MASK; 
    a638:	f8d9 2090 	ldr.w	r2, [r9, #144]	; 0x90
    a63c:	f852 303b 	ldr.w	r3, [r2, fp, lsl #3]
    a640:	f003 0303 	and.w	r3, r3, #3
    a644:	f842 303b 	str.w	r3, [r2, fp, lsl #3]
	if(pMACDrv->sGmacData._synchF != 0)
    a648:	6b33      	ldr	r3, [r6, #48]	; 0x30
    a64a:	b11b      	cbz	r3, a654 <DRV_PIC32CGMAC_LibRxGetPacket+0xfc>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_LEAVE);
    a64c:	2106      	movs	r1, #6
    a64e:	f106 005c 	add.w	r0, r6, #92	; 0x5c
    a652:	4798      	blx	r3
                            GCIRC_DEC(rx_index, nRxDscCnt); 
    a654:	2d00      	cmp	r5, #0
    a656:	d1d2      	bne.n	a5fe <DRV_PIC32CGMAC_LibRxGetPacket+0xa6>
    a658:	1e7d      	subs	r5, r7, #1
    a65a:	b2ad      	uxth	r5, r5
    a65c:	e7d1      	b.n	a602 <DRV_PIC32CGMAC_LibRxGetPacket+0xaa>
                        DRV_PIC32CGMAC_LibRxBuffersAppend(pMACDrv, queueIdx, (rx_frame_state->startIndex), (rx_frame_state->buffer_count));
    a65e:	9b01      	ldr	r3, [sp, #4]
    a660:	9a03      	ldr	r2, [sp, #12]
    a662:	9902      	ldr	r1, [sp, #8]
    a664:	4630      	mov	r0, r6
    a666:	f008 fae1 	bl	12c2c <DRV_PIC32CGMAC_LibRxBuffersAppend>
                        search_count--; 
    a66a:	f108 38ff 	add.w	r8, r8, #4294967295
    a66e:	fa1f f888 	uxth.w	r8, r8
                        GCIRC_DEC(nRxDescIndex, nRxDscCnt); 
    a672:	b91c      	cbnz	r4, a67c <DRV_PIC32CGMAC_LibRxGetPacket+0x124>
    a674:	1e7c      	subs	r4, r7, #1
    a676:	b2a4      	uxth	r4, r4
                        frameState = GMAC_RX_NO_FRAME_STATE;
    a678:	2500      	movs	r5, #0
    a67a:	e00b      	b.n	a694 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
                        GCIRC_DEC(nRxDescIndex, nRxDscCnt); 
    a67c:	3c01      	subs	r4, #1
    a67e:	b2a4      	uxth	r4, r4
                        frameState = GMAC_RX_NO_FRAME_STATE;
    a680:	2500      	movs	r5, #0
    a682:	e007      	b.n	a694 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
                DRV_PIC32CGMAC_LibRxBuffersAppend(pMACDrv, queueIdx, nRxDescIndex, 1);
    a684:	2301      	movs	r3, #1
    a686:	4622      	mov	r2, r4
    a688:	9902      	ldr	r1, [sp, #8]
    a68a:	4630      	mov	r0, r6
    a68c:	f008 face 	bl	12c2c <DRV_PIC32CGMAC_LibRxBuffersAppend>
    a690:	e000      	b.n	a694 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
			if(frameState == GMAC_RX_SOF_DETECTED_STATE)
    a692:	bb6d      	cbnz	r5, a6f0 <DRV_PIC32CGMAC_LibRxGetPacket+0x198>
				GCIRC_DEC(nRxDescIndex, nRxDscCnt); 		
			}
		}
		
        // increment rx index and continue search
		GCIRC_INC(nRxDescIndex, nRxDscCnt);
    a694:	3401      	adds	r4, #1
    a696:	b2a4      	uxth	r4, r4
    a698:	42a7      	cmp	r7, r4
    a69a:	bf98      	it	ls
    a69c:	2400      	movls	r4, #0
        // when search count exceeded number of rx descriptors, exit the search
		if ((search_count++) >  nRxDscCnt)
    a69e:	f108 0301 	add.w	r3, r8, #1
    a6a2:	b29b      	uxth	r3, r3
    a6a4:	4547      	cmp	r7, r8
    a6a6:	f0c0 80c7 	bcc.w	a838 <DRV_PIC32CGMAC_LibRxGetPacket+0x2e0>
	while ( search_count < nRxDscCnt)
    a6aa:	429f      	cmp	r7, r3
    a6ac:	f240 80c4 	bls.w	a838 <DRV_PIC32CGMAC_LibRxGetPacket+0x2e0>
		if ((search_count++) >  nRxDscCnt)
    a6b0:	4698      	mov	r8, r3
		if ((((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_buffaddr.val) & GMAC_RX_OWNERSHIP_BIT) == GMAC_RX_OWNERSHIP_BIT))
    a6b2:	00e2      	lsls	r2, r4, #3
    a6b4:	9805      	ldr	r0, [sp, #20]
    a6b6:	1883      	adds	r3, r0, r2
    a6b8:	f850 1034 	ldr.w	r1, [r0, r4, lsl #3]
    a6bc:	f011 0f01 	tst.w	r1, #1
    a6c0:	d0e7      	beq.n	a692 <DRV_PIC32CGMAC_LibRxGetPacket+0x13a>
            if(((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_buffaddr.val) & GMAC_RX_ADDRESS_MASK) != (uint32_t)0)
    a6c2:	f850 1034 	ldr.w	r1, [r0, r4, lsl #3]
    a6c6:	f031 0103 	bics.w	r1, r1, #3
    a6ca:	d0db      	beq.n	a684 <DRV_PIC32CGMAC_LibRxGetPacket+0x12c>
                if(frameState == GMAC_RX_NO_FRAME_STATE)
    a6cc:	2d00      	cmp	r5, #0
    a6ce:	f47f af7a 	bne.w	a5c6 <DRV_PIC32CGMAC_LibRxGetPacket+0x6e>
                    if(GMAC_RX_SOF_BIT == ((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_status.val) & GMAC_RX_SOF_BIT))
    a6d2:	6859      	ldr	r1, [r3, #4]
    a6d4:	f411 4f80 	tst.w	r1, #16384	; 0x4000
    a6d8:	d0dc      	beq.n	a694 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
                        if(GMAC_RX_EOF_BIT == ((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_status.val) & GMAC_RX_EOF_BIT))
    a6da:	685b      	ldr	r3, [r3, #4]
    a6dc:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    a6e0:	f040 80b9 	bne.w	a856 <DRV_PIC32CGMAC_LibRxGetPacket+0x2fe>
    a6e4:	9403      	str	r4, [sp, #12]
                        rx_frame_state->buffer_count = 1; 
    a6e6:	2301      	movs	r3, #1
    a6e8:	9301      	str	r3, [sp, #4]
                        search_count = 1;  
    a6ea:	4698      	mov	r8, r3
                        frameState = GMAC_RX_SOF_DETECTED_STATE;
    a6ec:	461d      	mov	r5, r3
    a6ee:	e7d1      	b.n	a694 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
				rx_index = fixed_mod(((rx_frame_state->startIndex) + (rx_frame_state->buffer_count) -1),nRxDscCnt);	
    a6f0:	9b03      	ldr	r3, [sp, #12]
    a6f2:	9a01      	ldr	r2, [sp, #4]
    a6f4:	189d      	adds	r5, r3, r2
    a6f6:	1e6b      	subs	r3, r5, #1
	int rem = a % b;
    a6f8:	fb93 f5f7 	sdiv	r5, r3, r7
    a6fc:	fb07 3515 	mls	r5, r7, r5, r3
	while (rem < 0)
    a700:	2d00      	cmp	r5, #0
		rem += b;
    a702:	bfb8      	it	lt
    a704:	19ed      	addlt	r5, r5, r7
    a706:	b2ad      	uxth	r5, r5
				nRx_buffer = rx_frame_state->buffer_count;
    a708:	f8dd a004 	ldr.w	sl, [sp, #4]
    a70c:	e001      	b.n	a712 <DRV_PIC32CGMAC_LibRxGetPacket+0x1ba>
                    GCIRC_DEC(rx_index, nRxDscCnt);
    a70e:	3d01      	subs	r5, #1
    a710:	b2ad      	uxth	r5, r5
				while(nRx_buffer--)
    a712:	f10a 3aff 	add.w	sl, sl, #4294967295
    a716:	fa1f fa8a 	uxth.w	sl, sl
    a71a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    a71e:	459a      	cmp	sl, r3
    a720:	d025      	beq.n	a76e <DRV_PIC32CGMAC_LibRxGetPacket+0x216>
                    pRxPkt = pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[rx_index];
    a722:	46ab      	mov	fp, r5
    a724:	f8d9 308c 	ldr.w	r3, [r9, #140]	; 0x8c
    a728:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
                    (pRxPkt->ackFunc)(pRxPkt, pRxPkt->ackParam);	
    a72c:	6883      	ldr	r3, [r0, #8]
    a72e:	68c1      	ldr	r1, [r0, #12]
    a730:	4798      	blx	r3
					pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[rx_index] = 0;
    a732:	f8d9 308c 	ldr.w	r3, [r9, #140]	; 0x8c
    a736:	2200      	movs	r2, #0
    a738:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
	if(pMACDrv->sGmacData._synchF != 0)
    a73c:	6b33      	ldr	r3, [r6, #48]	; 0x30
    a73e:	b11b      	cbz	r3, a748 <DRV_PIC32CGMAC_LibRxGetPacket+0x1f0>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
    a740:	2105      	movs	r1, #5
    a742:	f106 005c 	add.w	r0, r6, #92	; 0x5c
    a746:	4798      	blx	r3
					pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc[rx_index].rx_desc_buffaddr.val &= ~GMAC_RX_ADDRESS_MASK; 
    a748:	f8d9 2090 	ldr.w	r2, [r9, #144]	; 0x90
    a74c:	f852 303b 	ldr.w	r3, [r2, fp, lsl #3]
    a750:	f003 0303 	and.w	r3, r3, #3
    a754:	f842 303b 	str.w	r3, [r2, fp, lsl #3]
	if(pMACDrv->sGmacData._synchF != 0)
    a758:	6b33      	ldr	r3, [r6, #48]	; 0x30
    a75a:	b11b      	cbz	r3, a764 <DRV_PIC32CGMAC_LibRxGetPacket+0x20c>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_LEAVE);
    a75c:	2106      	movs	r1, #6
    a75e:	f106 005c 	add.w	r0, r6, #92	; 0x5c
    a762:	4798      	blx	r3
                    GCIRC_DEC(rx_index, nRxDscCnt);
    a764:	2d00      	cmp	r5, #0
    a766:	d1d2      	bne.n	a70e <DRV_PIC32CGMAC_LibRxGetPacket+0x1b6>
    a768:	1e7d      	subs	r5, r7, #1
    a76a:	b2ad      	uxth	r5, r5
    a76c:	e7d1      	b.n	a712 <DRV_PIC32CGMAC_LibRxGetPacket+0x1ba>
				DRV_PIC32CGMAC_LibRxBuffersAppend(pMACDrv, queueIdx, (rx_frame_state->startIndex), (rx_frame_state->buffer_count));
    a76e:	9b01      	ldr	r3, [sp, #4]
    a770:	9a03      	ldr	r2, [sp, #12]
    a772:	9902      	ldr	r1, [sp, #8]
    a774:	4630      	mov	r0, r6
    a776:	f008 fa59 	bl	12c2c <DRV_PIC32CGMAC_LibRxBuffersAppend>
                search_count--; 
    a77a:	f108 38ff 	add.w	r8, r8, #4294967295
    a77e:	fa1f f888 	uxth.w	r8, r8
				GCIRC_DEC(nRxDescIndex, nRxDscCnt); 		
    a782:	b91c      	cbnz	r4, a78c <DRV_PIC32CGMAC_LibRxGetPacket+0x234>
    a784:	1e7c      	subs	r4, r7, #1
    a786:	b2a4      	uxth	r4, r4
				frameState = GMAC_RX_NO_FRAME_STATE;
    a788:	2500      	movs	r5, #0
    a78a:	e783      	b.n	a694 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
				GCIRC_DEC(nRxDescIndex, nRxDscCnt); 		
    a78c:	3c01      	subs	r4, #1
    a78e:	b2a4      	uxth	r4, r4
				frameState = GMAC_RX_NO_FRAME_STATE;
    a790:	2500      	movs	r5, #0
    a792:	e77f      	b.n	a694 <DRV_PIC32CGMAC_LibRxGetPacket+0x13c>
	pDseg = (*pRxPkt)->pDSeg; 
	
	if(nRx_buffer)
    {
		//process all the packet buffers
		while(nRx_buffer--) 
    a794:	3d01      	subs	r5, #1
    a796:	b2ad      	uxth	r5, r5
    a798:	f64f 73ff 	movw	r3, #65535	; 0xffff
    a79c:	429d      	cmp	r5, r3
    a79e:	d03d      	beq.n	a81c <DRV_PIC32CGMAC_LibRxGetPacket+0x2c4>
		{
            // Segment length based on received frame length and Rx buffer size
			(*pRxPkt)->pDSeg->segLen = (frameSize >= gmac_queue_config.rxBufferSize) ?
    a7a0:	f8da 3000 	ldr.w	r3, [sl]
    a7a4:	691b      	ldr	r3, [r3, #16]
												gmac_queue_config.rxBufferSize :frameSize;
    a7a6:	4642      	mov	r2, r8
    a7a8:	45b8      	cmp	r8, r7
    a7aa:	bf28      	it	cs
    a7ac:	463a      	movcs	r2, r7
			(*pRxPkt)->pDSeg->segLen = (frameSize >= gmac_queue_config.rxBufferSize) ?
    a7ae:	819a      	strh	r2, [r3, #12]
													
			(*pRxPkt)->pDSeg->segSize = gmac_queue_config.rxBufferSize;
    a7b0:	f8da 3000 	ldr.w	r3, [sl]
    a7b4:	691b      	ldr	r3, [r3, #16]
    a7b6:	f8a3 800e 	strh.w	r8, [r3, #14]
			
			// RX frame bigger than GMAC RX buffer?
			if(frameSize >= gmac_queue_config.rxBufferSize)
    a7ba:	45b8      	cmp	r8, r7
            {
                //more Rx buffers used for Rx packet
				frameSize = frameSize - gmac_queue_config.rxBufferSize;
    a7bc:	bf94      	ite	ls
    a7be:	eba7 0708 	subls.w	r7, r7, r8
            }
			else
            {   // last Rx buffer of Rx Packet
				frameSize = 0;		
    a7c2:	2700      	movhi	r7, #0
            }
			
			//release the rx packets from GMAC queue
			gmac_queue.pRxPckt[rx_index] = 0; 
    a7c4:	9405      	str	r4, [sp, #20]
    a7c6:	2300      	movs	r3, #0
    a7c8:	f849 3024 	str.w	r3, [r9, r4, lsl #2]
	if(pMACDrv->sGmacData._synchF != 0)
    a7cc:	6b33      	ldr	r3, [r6, #48]	; 0x30
    a7ce:	b113      	cbz	r3, a7d6 <DRV_PIC32CGMAC_LibRxGetPacket+0x27e>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
    a7d0:	2105      	movs	r1, #5
    a7d2:	9807      	ldr	r0, [sp, #28]
    a7d4:	4798      	blx	r3
			
			_DRV_GMAC_RxLock(pMACDrv);
			//clear the buffer address bit-fields
			gmac_queue.pRxDesc[rx_index].rx_desc_buffaddr.val &= ~GMAC_RX_ADDRESS_MASK; 
    a7d6:	9a05      	ldr	r2, [sp, #20]
    a7d8:	f85b 3032 	ldr.w	r3, [fp, r2, lsl #3]
    a7dc:	f003 0303 	and.w	r3, r3, #3
    a7e0:	f84b 3032 	str.w	r3, [fp, r2, lsl #3]
	if(pMACDrv->sGmacData._synchF != 0)
    a7e4:	6b33      	ldr	r3, [r6, #48]	; 0x30
    a7e6:	b113      	cbz	r3, a7ee <DRV_PIC32CGMAC_LibRxGetPacket+0x296>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_LEAVE);
    a7e8:	2106      	movs	r1, #6
    a7ea:	9807      	ldr	r0, [sp, #28]
    a7ec:	4798      	blx	r3
			_DRV_GMAC_RxUnlock(pMACDrv);

			//more Rx buffers needed for Rx packet
			if(frameSize)
    a7ee:	2f00      	cmp	r7, #0
    a7f0:	d0d0      	beq.n	a794 <DRV_PIC32CGMAC_LibRxGetPacket+0x23c>
			{
				GCIRC_INC(rx_index, gmac_queue_config.nRxDescCnt);
    a7f2:	3401      	adds	r4, #1
    a7f4:	b2a4      	uxth	r4, r4
    a7f6:	9b08      	ldr	r3, [sp, #32]
    a7f8:	42a3      	cmp	r3, r4
    a7fa:	bf98      	it	ls
    a7fc:	2400      	movls	r4, #0
				
				(*pRxPkt)->pDSeg->next = gmac_queue.pRxPckt[rx_index]->pDSeg;
    a7fe:	f8da 3000 	ldr.w	r3, [sl]
    a802:	691b      	ldr	r3, [r3, #16]
    a804:	f859 2024 	ldr.w	r2, [r9, r4, lsl #2]
    a808:	6912      	ldr	r2, [r2, #16]
    a80a:	601a      	str	r2, [r3, #0]
				(*pRxPkt)->pDSeg = (*pRxPkt)->pDSeg->next;	
    a80c:	f8da 3000 	ldr.w	r3, [sl]
    a810:	691a      	ldr	r2, [r3, #16]
    a812:	6812      	ldr	r2, [r2, #0]
    a814:	611a      	str	r2, [r3, #16]
    a816:	e7bd      	b.n	a794 <DRV_PIC32CGMAC_LibRxGetPacket+0x23c>
    a818:	42000800 	.word	0x42000800
			}			
			
		}
			
		// restore to first data segment
		(*pRxPkt)->pDSeg = (TCPIP_MAC_DATA_SEGMENT*)pDseg; 
    a81c:	9b06      	ldr	r3, [sp, #24]
    a81e:	681b      	ldr	r3, [r3, #0]
    a820:	9a09      	ldr	r2, [sp, #36]	; 0x24
    a822:	611a      	str	r2, [r3, #16]
		
		//allocate new packets in place of used buffers
		DRV_PIC32CGMAC_LibRxBuffersAppend(pMACDrv, queueIdx, rx_frame_state->startIndex, rx_frame_state->buffer_count); 
    a824:	9b01      	ldr	r3, [sp, #4]
    a826:	9a03      	ldr	r2, [sp, #12]
    a828:	9902      	ldr	r1, [sp, #8]
    a82a:	4630      	mov	r0, r6
    a82c:	f008 f9fe 	bl	12c2c <DRV_PIC32CGMAC_LibRxBuffersAppend>
		res = DRV_PIC32CGMAC_RES_OK;
    a830:	2000      	movs	r0, #0
    a832:	e008      	b.n	a846 <DRV_PIC32CGMAC_LibRxGetPacket+0x2ee>
		return res;
    a834:	2001      	movs	r0, #1
    a836:	e00b      	b.n	a850 <DRV_PIC32CGMAC_LibRxGetPacket+0x2f8>
	pMACDrv->sGmacData.gmac_queue[queueIdx].nRxDescIndex = nRxDescIndex;	
    a838:	202c      	movs	r0, #44	; 0x2c
    a83a:	9b02      	ldr	r3, [sp, #8]
    a83c:	fb00 6603 	mla	r6, r0, r3, r6
    a840:	f8a6 40b0 	strh.w	r4, [r6, #176]	; 0xb0
    DRV_PIC32CGMAC_RESULT   res = DRV_PIC32CGMAC_RES_NO_PACKET;
    a844:	2001      	movs	r0, #1
    if(bna_flag == true)
    a846:	9b04      	ldr	r3, [sp, #16]
    a848:	b113      	cbz	r3, a850 <DRV_PIC32CGMAC_LibRxGetPacket+0x2f8>
        GMAC_REGS->GMAC_RSR = GMAC_RSR_BNA_Msk ; 
    a84a:	4b22      	ldr	r3, [pc, #136]	; (a8d4 <DRV_PIC32CGMAC_LibRxGetPacket+0x37c>)
    a84c:	2201      	movs	r2, #1
    a84e:	621a      	str	r2, [r3, #32]
} //DRV_PIC32CGMAC_LibRxGetPacket
    a850:	b00b      	add	sp, #44	; 0x2c
    a852:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                        if(GMAC_RX_EOF_BIT == ((uint32_t)(pRxDesc[nRxDescIndex].rx_desc_status.val) & GMAC_RX_EOF_BIT))
    a856:	9403      	str	r4, [sp, #12]
                        rx_frame_state->buffer_count = 1; 
    a858:	2301      	movs	r3, #1
    a85a:	9301      	str	r3, [sp, #4]
	pMACDrv->sGmacData.gmac_queue[queueIdx].nRxDescIndex = nRxDescIndex;	
    a85c:	232c      	movs	r3, #44	; 0x2c
    a85e:	9d02      	ldr	r5, [sp, #8]
    a860:	fb03 6105 	mla	r1, r3, r5, r6
    a864:	f8a1 40b0 	strh.w	r4, [r1, #176]	; 0xb0
		*pRxStat = (pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc[rx_frame_state.endIndex].rx_desc_status);		
    a868:	f8d1 0090 	ldr.w	r0, [r1, #144]	; 0x90
    a86c:	4410      	add	r0, r2
    a86e:	6840      	ldr	r0, [r0, #4]
    a870:	9c08      	ldr	r4, [sp, #32]
    a872:	6020      	str	r0, [r4, #0]
		*pnBuffs = rx_frame_state.buffer_count;		
    a874:	9807      	ldr	r0, [sp, #28]
    a876:	9c01      	ldr	r4, [sp, #4]
    a878:	6004      	str	r4, [r0, #0]
    DRV_PIC32CGMAC_HW_RXDCPT *pRxDesc = pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc;
    a87a:	f8d1 1090 	ldr.w	r1, [r1, #144]	; 0x90
    DRV_GMAC_QUEUE gmac_queue = pMACDrv->sGmacData.gmac_queue[queueIdx];
    a87e:	fb03 f305 	mul.w	r3, r3, r5
    a882:	338c      	adds	r3, #140	; 0x8c
    a884:	18f0      	adds	r0, r6, r3
    a886:	f856 a003 	ldr.w	sl, [r6, r3]
    a88a:	f8d0 b004 	ldr.w	fp, [r0, #4]
    TCPIP_MODULE_GMAC_QUEUE_CONFIG gmac_queue_config = pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx];
    a88e:	eb05 03c5 	add.w	r3, r5, r5, lsl #3
    a892:	005b      	lsls	r3, r3, #1
    a894:	33be      	adds	r3, #190	; 0xbe
    a896:	18f0      	adds	r0, r6, r3
    a898:	5af3      	ldrh	r3, [r6, r3]
    a89a:	9308      	str	r3, [sp, #32]
    a89c:	f8b0 800e 	ldrh.w	r8, [r0, #14]
	*pRxPkt = gmac_queue.pRxPckt[rx_frame_state->startIndex]; 
    a8a0:	9b03      	ldr	r3, [sp, #12]
    a8a2:	f85a 3023 	ldr.w	r3, [sl, r3, lsl #2]
    a8a6:	9806      	ldr	r0, [sp, #24]
    a8a8:	6003      	str	r3, [r0, #0]
	frameSize = (pRxDesc[rx_frame_state->endIndex].rx_desc_status.val & GMAC_LENGTH_FRAME); 
    a8aa:	440a      	add	r2, r1
    a8ac:	6857      	ldr	r7, [r2, #4]
	if(nRx_buffer)
    a8ae:	b90c      	cbnz	r4, a8b4 <DRV_PIC32CGMAC_LibRxGetPacket+0x35c>
	}
	else
    {
        res = DRV_PIC32CGMAC_RES_NO_PACKET;
    a8b0:	2001      	movs	r0, #1
    a8b2:	e7c8      	b.n	a846 <DRV_PIC32CGMAC_LibRxGetPacket+0x2ee>
	frameSize = (pRxDesc[rx_frame_state->endIndex].rx_desc_status.val & GMAC_LENGTH_FRAME); 
    a8b4:	f3c7 070d 	ubfx	r7, r7, #0, #14
	pDseg = (*pRxPkt)->pDSeg; 
    a8b8:	691b      	ldr	r3, [r3, #16]
    a8ba:	9309      	str	r3, [sp, #36]	; 0x24
		while(nRx_buffer--) 
    a8bc:	9b01      	ldr	r3, [sp, #4]
    a8be:	1e5d      	subs	r5, r3, #1
    a8c0:	b2ad      	uxth	r5, r5
    a8c2:	9c03      	ldr	r4, [sp, #12]
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
    a8c4:	f106 035c 	add.w	r3, r6, #92	; 0x5c
    a8c8:	9307      	str	r3, [sp, #28]
    a8ca:	46d1      	mov	r9, sl
    a8cc:	f8dd a018 	ldr.w	sl, [sp, #24]
    a8d0:	e766      	b.n	a7a0 <DRV_PIC32CGMAC_LibRxGetPacket+0x248>
    a8d2:	bf00      	nop
    a8d4:	42000800 	.word	0x42000800

Disassembly of section .text%210:

0000a8d8 <__aeabi_drsub>:
    a8d8:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
    a8dc:	e002      	b.n	a8e4 <__adddf3>
    a8de:	bf00      	nop

0000a8e0 <__aeabi_dsub>:
    a8e0:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0000a8e4 <__adddf3>:
    a8e4:	b530      	push	{r4, r5, lr}
    a8e6:	ea4f 0441 	mov.w	r4, r1, lsl #1
    a8ea:	ea4f 0543 	mov.w	r5, r3, lsl #1
    a8ee:	ea94 0f05 	teq	r4, r5
    a8f2:	bf08      	it	eq
    a8f4:	ea90 0f02 	teqeq	r0, r2
    a8f8:	bf1f      	itttt	ne
    a8fa:	ea54 0c00 	orrsne.w	ip, r4, r0
    a8fe:	ea55 0c02 	orrsne.w	ip, r5, r2
    a902:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
    a906:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    a90a:	f000 80e2 	beq.w	aad2 <__adddf3+0x1ee>
    a90e:	ea4f 5454 	mov.w	r4, r4, lsr #21
    a912:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
    a916:	bfb8      	it	lt
    a918:	426d      	neglt	r5, r5
    a91a:	dd0c      	ble.n	a936 <__adddf3+0x52>
    a91c:	442c      	add	r4, r5
    a91e:	ea80 0202 	eor.w	r2, r0, r2
    a922:	ea81 0303 	eor.w	r3, r1, r3
    a926:	ea82 0000 	eor.w	r0, r2, r0
    a92a:	ea83 0101 	eor.w	r1, r3, r1
    a92e:	ea80 0202 	eor.w	r2, r0, r2
    a932:	ea81 0303 	eor.w	r3, r1, r3
    a936:	2d36      	cmp	r5, #54	; 0x36
    a938:	bf88      	it	hi
    a93a:	bd30      	pophi	{r4, r5, pc}
    a93c:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    a940:	ea4f 3101 	mov.w	r1, r1, lsl #12
    a944:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
    a948:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
    a94c:	d002      	beq.n	a954 <__adddf3+0x70>
    a94e:	4240      	negs	r0, r0
    a950:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    a954:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
    a958:	ea4f 3303 	mov.w	r3, r3, lsl #12
    a95c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
    a960:	d002      	beq.n	a968 <__adddf3+0x84>
    a962:	4252      	negs	r2, r2
    a964:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    a968:	ea94 0f05 	teq	r4, r5
    a96c:	f000 80a7 	beq.w	aabe <__adddf3+0x1da>
    a970:	f1a4 0401 	sub.w	r4, r4, #1
    a974:	f1d5 0e20 	rsbs	lr, r5, #32
    a978:	db0d      	blt.n	a996 <__adddf3+0xb2>
    a97a:	fa02 fc0e 	lsl.w	ip, r2, lr
    a97e:	fa22 f205 	lsr.w	r2, r2, r5
    a982:	1880      	adds	r0, r0, r2
    a984:	f141 0100 	adc.w	r1, r1, #0
    a988:	fa03 f20e 	lsl.w	r2, r3, lr
    a98c:	1880      	adds	r0, r0, r2
    a98e:	fa43 f305 	asr.w	r3, r3, r5
    a992:	4159      	adcs	r1, r3
    a994:	e00e      	b.n	a9b4 <__adddf3+0xd0>
    a996:	f1a5 0520 	sub.w	r5, r5, #32
    a99a:	f10e 0e20 	add.w	lr, lr, #32
    a99e:	2a01      	cmp	r2, #1
    a9a0:	fa03 fc0e 	lsl.w	ip, r3, lr
    a9a4:	bf28      	it	cs
    a9a6:	f04c 0c02 	orrcs.w	ip, ip, #2
    a9aa:	fa43 f305 	asr.w	r3, r3, r5
    a9ae:	18c0      	adds	r0, r0, r3
    a9b0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
    a9b4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    a9b8:	d507      	bpl.n	a9ca <__adddf3+0xe6>
    a9ba:	f04f 0e00 	mov.w	lr, #0
    a9be:	f1dc 0c00 	rsbs	ip, ip, #0
    a9c2:	eb7e 0000 	sbcs.w	r0, lr, r0
    a9c6:	eb6e 0101 	sbc.w	r1, lr, r1
    a9ca:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    a9ce:	d31b      	bcc.n	aa08 <__adddf3+0x124>
    a9d0:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    a9d4:	d30c      	bcc.n	a9f0 <__adddf3+0x10c>
    a9d6:	0849      	lsrs	r1, r1, #1
    a9d8:	ea5f 0030 	movs.w	r0, r0, rrx
    a9dc:	ea4f 0c3c 	mov.w	ip, ip, rrx
    a9e0:	f104 0401 	add.w	r4, r4, #1
    a9e4:	ea4f 5244 	mov.w	r2, r4, lsl #21
    a9e8:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
    a9ec:	f080 809a 	bcs.w	ab24 <__adddf3+0x240>
    a9f0:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    a9f4:	bf08      	it	eq
    a9f6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    a9fa:	f150 0000 	adcs.w	r0, r0, #0
    a9fe:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    aa02:	ea41 0105 	orr.w	r1, r1, r5
    aa06:	bd30      	pop	{r4, r5, pc}
    aa08:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
    aa0c:	4140      	adcs	r0, r0
    aa0e:	eb41 0101 	adc.w	r1, r1, r1
    aa12:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    aa16:	f1a4 0401 	sub.w	r4, r4, #1
    aa1a:	d1e9      	bne.n	a9f0 <__adddf3+0x10c>
    aa1c:	f091 0f00 	teq	r1, #0
    aa20:	bf04      	itt	eq
    aa22:	4601      	moveq	r1, r0
    aa24:	2000      	moveq	r0, #0
    aa26:	fab1 f381 	clz	r3, r1
    aa2a:	bf08      	it	eq
    aa2c:	3320      	addeq	r3, #32
    aa2e:	f1a3 030b 	sub.w	r3, r3, #11
    aa32:	f1b3 0220 	subs.w	r2, r3, #32
    aa36:	da0c      	bge.n	aa52 <__adddf3+0x16e>
    aa38:	320c      	adds	r2, #12
    aa3a:	dd08      	ble.n	aa4e <__adddf3+0x16a>
    aa3c:	f102 0c14 	add.w	ip, r2, #20
    aa40:	f1c2 020c 	rsb	r2, r2, #12
    aa44:	fa01 f00c 	lsl.w	r0, r1, ip
    aa48:	fa21 f102 	lsr.w	r1, r1, r2
    aa4c:	e00c      	b.n	aa68 <__adddf3+0x184>
    aa4e:	f102 0214 	add.w	r2, r2, #20
    aa52:	bfd8      	it	le
    aa54:	f1c2 0c20 	rsble	ip, r2, #32
    aa58:	fa01 f102 	lsl.w	r1, r1, r2
    aa5c:	fa20 fc0c 	lsr.w	ip, r0, ip
    aa60:	bfdc      	itt	le
    aa62:	ea41 010c 	orrle.w	r1, r1, ip
    aa66:	4090      	lslle	r0, r2
    aa68:	1ae4      	subs	r4, r4, r3
    aa6a:	bfa2      	ittt	ge
    aa6c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
    aa70:	4329      	orrge	r1, r5
    aa72:	bd30      	popge	{r4, r5, pc}
    aa74:	ea6f 0404 	mvn.w	r4, r4
    aa78:	3c1f      	subs	r4, #31
    aa7a:	da1c      	bge.n	aab6 <__adddf3+0x1d2>
    aa7c:	340c      	adds	r4, #12
    aa7e:	dc0e      	bgt.n	aa9e <__adddf3+0x1ba>
    aa80:	f104 0414 	add.w	r4, r4, #20
    aa84:	f1c4 0220 	rsb	r2, r4, #32
    aa88:	fa20 f004 	lsr.w	r0, r0, r4
    aa8c:	fa01 f302 	lsl.w	r3, r1, r2
    aa90:	ea40 0003 	orr.w	r0, r0, r3
    aa94:	fa21 f304 	lsr.w	r3, r1, r4
    aa98:	ea45 0103 	orr.w	r1, r5, r3
    aa9c:	bd30      	pop	{r4, r5, pc}
    aa9e:	f1c4 040c 	rsb	r4, r4, #12
    aaa2:	f1c4 0220 	rsb	r2, r4, #32
    aaa6:	fa20 f002 	lsr.w	r0, r0, r2
    aaaa:	fa01 f304 	lsl.w	r3, r1, r4
    aaae:	ea40 0003 	orr.w	r0, r0, r3
    aab2:	4629      	mov	r1, r5
    aab4:	bd30      	pop	{r4, r5, pc}
    aab6:	fa21 f004 	lsr.w	r0, r1, r4
    aaba:	4629      	mov	r1, r5
    aabc:	bd30      	pop	{r4, r5, pc}
    aabe:	f094 0f00 	teq	r4, #0
    aac2:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
    aac6:	bf06      	itte	eq
    aac8:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
    aacc:	3401      	addeq	r4, #1
    aace:	3d01      	subne	r5, #1
    aad0:	e74e      	b.n	a970 <__adddf3+0x8c>
    aad2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    aad6:	bf18      	it	ne
    aad8:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    aadc:	d029      	beq.n	ab32 <__adddf3+0x24e>
    aade:	ea94 0f05 	teq	r4, r5
    aae2:	bf08      	it	eq
    aae4:	ea90 0f02 	teqeq	r0, r2
    aae8:	d005      	beq.n	aaf6 <__adddf3+0x212>
    aaea:	ea54 0c00 	orrs.w	ip, r4, r0
    aaee:	bf04      	itt	eq
    aaf0:	4619      	moveq	r1, r3
    aaf2:	4610      	moveq	r0, r2
    aaf4:	bd30      	pop	{r4, r5, pc}
    aaf6:	ea91 0f03 	teq	r1, r3
    aafa:	bf1e      	ittt	ne
    aafc:	2100      	movne	r1, #0
    aafe:	2000      	movne	r0, #0
    ab00:	bd30      	popne	{r4, r5, pc}
    ab02:	ea5f 5c54 	movs.w	ip, r4, lsr #21
    ab06:	d105      	bne.n	ab14 <__adddf3+0x230>
    ab08:	0040      	lsls	r0, r0, #1
    ab0a:	4149      	adcs	r1, r1
    ab0c:	bf28      	it	cs
    ab0e:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
    ab12:	bd30      	pop	{r4, r5, pc}
    ab14:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
    ab18:	bf3c      	itt	cc
    ab1a:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
    ab1e:	bd30      	popcc	{r4, r5, pc}
    ab20:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    ab24:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
    ab28:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    ab2c:	f04f 0000 	mov.w	r0, #0
    ab30:	bd30      	pop	{r4, r5, pc}
    ab32:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    ab36:	bf1a      	itte	ne
    ab38:	4619      	movne	r1, r3
    ab3a:	4610      	movne	r0, r2
    ab3c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
    ab40:	bf1c      	itt	ne
    ab42:	460b      	movne	r3, r1
    ab44:	4602      	movne	r2, r0
    ab46:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    ab4a:	bf06      	itte	eq
    ab4c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
    ab50:	ea91 0f03 	teqeq	r1, r3
    ab54:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
    ab58:	bd30      	pop	{r4, r5, pc}
    ab5a:	bf00      	nop

0000ab5c <__aeabi_ui2d>:
    ab5c:	f090 0f00 	teq	r0, #0
    ab60:	bf04      	itt	eq
    ab62:	2100      	moveq	r1, #0
    ab64:	4770      	bxeq	lr
    ab66:	b530      	push	{r4, r5, lr}
    ab68:	f44f 6480 	mov.w	r4, #1024	; 0x400
    ab6c:	f104 0432 	add.w	r4, r4, #50	; 0x32
    ab70:	f04f 0500 	mov.w	r5, #0
    ab74:	f04f 0100 	mov.w	r1, #0
    ab78:	e750      	b.n	aa1c <__adddf3+0x138>
    ab7a:	bf00      	nop

0000ab7c <__aeabi_i2d>:
    ab7c:	f090 0f00 	teq	r0, #0
    ab80:	bf04      	itt	eq
    ab82:	2100      	moveq	r1, #0
    ab84:	4770      	bxeq	lr
    ab86:	b530      	push	{r4, r5, lr}
    ab88:	f44f 6480 	mov.w	r4, #1024	; 0x400
    ab8c:	f104 0432 	add.w	r4, r4, #50	; 0x32
    ab90:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
    ab94:	bf48      	it	mi
    ab96:	4240      	negmi	r0, r0
    ab98:	f04f 0100 	mov.w	r1, #0
    ab9c:	e73e      	b.n	aa1c <__adddf3+0x138>
    ab9e:	bf00      	nop

0000aba0 <__aeabi_f2d>:
    aba0:	0042      	lsls	r2, r0, #1
    aba2:	ea4f 01e2 	mov.w	r1, r2, asr #3
    aba6:	ea4f 0131 	mov.w	r1, r1, rrx
    abaa:	ea4f 7002 	mov.w	r0, r2, lsl #28
    abae:	bf1f      	itttt	ne
    abb0:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
    abb4:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    abb8:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
    abbc:	4770      	bxne	lr
    abbe:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
    abc2:	bf08      	it	eq
    abc4:	4770      	bxeq	lr
    abc6:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
    abca:	bf04      	itt	eq
    abcc:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
    abd0:	4770      	bxeq	lr
    abd2:	b530      	push	{r4, r5, lr}
    abd4:	f44f 7460 	mov.w	r4, #896	; 0x380
    abd8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    abdc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    abe0:	e71c      	b.n	aa1c <__adddf3+0x138>
    abe2:	bf00      	nop

0000abe4 <__aeabi_ul2d>:
    abe4:	ea50 0201 	orrs.w	r2, r0, r1
    abe8:	bf08      	it	eq
    abea:	4770      	bxeq	lr
    abec:	b530      	push	{r4, r5, lr}
    abee:	f04f 0500 	mov.w	r5, #0
    abf2:	e00a      	b.n	ac0a <__aeabi_l2d+0x16>

0000abf4 <__aeabi_l2d>:
    abf4:	ea50 0201 	orrs.w	r2, r0, r1
    abf8:	bf08      	it	eq
    abfa:	4770      	bxeq	lr
    abfc:	b530      	push	{r4, r5, lr}
    abfe:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
    ac02:	d502      	bpl.n	ac0a <__aeabi_l2d+0x16>
    ac04:	4240      	negs	r0, r0
    ac06:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    ac0a:	f44f 6480 	mov.w	r4, #1024	; 0x400
    ac0e:	f104 0432 	add.w	r4, r4, #50	; 0x32
    ac12:	ea5f 5c91 	movs.w	ip, r1, lsr #22
    ac16:	f43f aed8 	beq.w	a9ca <__adddf3+0xe6>
    ac1a:	f04f 0203 	mov.w	r2, #3
    ac1e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    ac22:	bf18      	it	ne
    ac24:	3203      	addne	r2, #3
    ac26:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    ac2a:	bf18      	it	ne
    ac2c:	3203      	addne	r2, #3
    ac2e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
    ac32:	f1c2 0320 	rsb	r3, r2, #32
    ac36:	fa00 fc03 	lsl.w	ip, r0, r3
    ac3a:	fa20 f002 	lsr.w	r0, r0, r2
    ac3e:	fa01 fe03 	lsl.w	lr, r1, r3
    ac42:	ea40 000e 	orr.w	r0, r0, lr
    ac46:	fa21 f102 	lsr.w	r1, r1, r2
    ac4a:	4414      	add	r4, r2
    ac4c:	e6bd      	b.n	a9ca <__adddf3+0xe6>
    ac4e:	bf00      	nop

Disassembly of section .text.TCPIP_Helper_StringToIPv6Address%211:

0000ac50 <TCPIP_Helper_StringToIPv6Address>:
  Return Values:
  	true - an IP address was successfully decoded
  	false - no IP address could be found, or the format was incorrect
  ***************************************************************************/
bool TCPIP_Helper_StringToIPv6Address(const char * addStr, IPV6_ADDR * addr)
{
    ac50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ac54:	b099      	sub	sp, #100	; 0x64
    char * endPtr;
    char*  str;
    IPV6_ADDR   convAddr;
    char   str_buff[64 + 1];     // enough space for longest address: 1111:2222:3333:4444:5555:6666:192.250.250.250

    if(addr)
    ac56:	460d      	mov	r5, r1
    ac58:	b121      	cbz	r1, ac64 <TCPIP_Helper_StringToIPv6Address+0x14>
    {
        memset(addr, 0, sizeof(*addr));
    ac5a:	2300      	movs	r3, #0
    ac5c:	600b      	str	r3, [r1, #0]
    ac5e:	604b      	str	r3, [r1, #4]
    ac60:	608b      	str	r3, [r1, #8]
    ac62:	60cb      	str	r3, [r1, #12]
    }

    if(addStr == 0 || (len = strlen(addStr)) == 0)
    ac64:	2800      	cmp	r0, #0
    ac66:	f000 812f 	beq.w	aec8 <TCPIP_Helper_StringToIPv6Address+0x278>
    ac6a:	4604      	mov	r4, r0
    ac6c:	f016 ff96 	bl	21b9c <strlen>
    ac70:	4603      	mov	r3, r0
    ac72:	b918      	cbnz	r0, ac7c <TCPIP_Helper_StringToIPv6Address+0x2c>
    {
        return true;
    ac74:	2001      	movs	r0, #1
    {
        memcpy(addr, convAddr.v, sizeof(*addr));
    }

    return true;
}
    ac76:	b019      	add	sp, #100	; 0x64
    ac78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memset(convAddr.v, 0, sizeof(convAddr));
    ac7c:	2200      	movs	r2, #0
    ac7e:	9211      	str	r2, [sp, #68]	; 0x44
    ac80:	9212      	str	r2, [sp, #72]	; 0x48
    ac82:	9213      	str	r2, [sp, #76]	; 0x4c
    ac84:	9214      	str	r2, [sp, #80]	; 0x50
    while(isspace(*addStr))
    ac86:	7821      	ldrb	r1, [r4, #0]
    ac88:	4abf      	ldr	r2, [pc, #764]	; (af88 <TCPIP_Helper_StringToIPv6Address+0x338>)
    ac8a:	5c8a      	ldrb	r2, [r1, r2]
    ac8c:	f012 0f08 	tst.w	r2, #8
    ac90:	d024      	beq.n	acdc <TCPIP_Helper_StringToIPv6Address+0x8c>
    ac92:	1c62      	adds	r2, r4, #1
    ac94:	4420      	add	r0, r4
    ac96:	4ebc      	ldr	r6, [pc, #752]	; (af88 <TCPIP_Helper_StringToIPv6Address+0x338>)
        addStr++;
    ac98:	4611      	mov	r1, r2
        len--;
    ac9a:	1a83      	subs	r3, r0, r2
    ac9c:	3201      	adds	r2, #1
    while(isspace(*addStr))
    ac9e:	780c      	ldrb	r4, [r1, #0]
    aca0:	5da4      	ldrb	r4, [r4, r6]
    aca2:	f014 0f08 	tst.w	r4, #8
    aca6:	d1f7      	bne.n	ac98 <TCPIP_Helper_StringToIPv6Address+0x48>
    while(isspace(*(addStr + len - 1)))
    aca8:	461a      	mov	r2, r3
    acaa:	1e5f      	subs	r7, r3, #1
    acac:	19c8      	adds	r0, r1, r7
    acae:	5dce      	ldrb	r6, [r1, r7]
    acb0:	4cb5      	ldr	r4, [pc, #724]	; (af88 <TCPIP_Helper_StringToIPv6Address+0x338>)
    acb2:	5d34      	ldrb	r4, [r6, r4]
    acb4:	f014 0f08 	tst.w	r4, #8
    acb8:	d012      	beq.n	ace0 <TCPIP_Helper_StringToIPv6Address+0x90>
    acba:	f8df c2cc 	ldr.w	ip, [pc, #716]	; af88 <TCPIP_Helper_StringToIPv6Address+0x338>
        len--;
    acbe:	1e5e      	subs	r6, r3, #1
    acc0:	4632      	mov	r2, r6
    while(isspace(*(addStr + len - 1)))
    acc2:	1e9f      	subs	r7, r3, #2
        len--;
    acc4:	4633      	mov	r3, r6
    while(isspace(*(addStr + len - 1)))
    acc6:	f810 4d01 	ldrb.w	r4, [r0, #-1]!
    acca:	f814 400c 	ldrb.w	r4, [r4, ip]
    acce:	f014 0f08 	tst.w	r4, #8
    acd2:	d1f4      	bne.n	acbe <TCPIP_Helper_StringToIPv6Address+0x6e>
    if(len > sizeof(str_buff) - 1)
    acd4:	2a40      	cmp	r2, #64	; 0x40
    acd6:	d905      	bls.n	ace4 <TCPIP_Helper_StringToIPv6Address+0x94>
        return false;
    acd8:	2000      	movs	r0, #0
    acda:	e7cc      	b.n	ac76 <TCPIP_Helper_StringToIPv6Address+0x26>
    while(isspace(*addStr))
    acdc:	4621      	mov	r1, r4
    acde:	e7e3      	b.n	aca8 <TCPIP_Helper_StringToIPv6Address+0x58>
    while(isspace(*(addStr + len - 1)))
    ace0:	461e      	mov	r6, r3
    ace2:	e7f7      	b.n	acd4 <TCPIP_Helper_StringToIPv6Address+0x84>
    strncpy(str_buff, addStr, len);
    ace4:	4668      	mov	r0, sp
    ace6:	f015 faae 	bl	20246 <strncpy>
    str_buff[len] = 0;
    acea:	2200      	movs	r2, #0
    acec:	ab18      	add	r3, sp, #96	; 0x60
    acee:	4433      	add	r3, r6
    acf0:	f803 2c60 	strb.w	r2, [r3, #-96]
    if (*str == '[')
    acf4:	f89d 3000 	ldrb.w	r3, [sp]
    acf8:	2b5b      	cmp	r3, #91	; 0x5b
    acfa:	f000 8086 	beq.w	ae0a <TCPIP_Helper_StringToIPv6Address+0x1ba>
    str = str_buff;
    acfe:	466c      	mov	r4, sp
    while(isspace(*str))
    ad00:	7822      	ldrb	r2, [r4, #0]
    ad02:	4ba1      	ldr	r3, [pc, #644]	; (af88 <TCPIP_Helper_StringToIPv6Address+0x338>)
    ad04:	5cd3      	ldrb	r3, [r2, r3]
    ad06:	f013 0f08 	tst.w	r3, #8
    ad0a:	d00a      	beq.n	ad22 <TCPIP_Helper_StringToIPv6Address+0xd2>
    ad0c:	1c63      	adds	r3, r4, #1
    ad0e:	19a1      	adds	r1, r4, r6
    ad10:	489d      	ldr	r0, [pc, #628]	; (af88 <TCPIP_Helper_StringToIPv6Address+0x338>)
        str++;
    ad12:	461c      	mov	r4, r3
        len--;
    ad14:	1ace      	subs	r6, r1, r3
    ad16:	3301      	adds	r3, #1
    while(isspace(*str))
    ad18:	7822      	ldrb	r2, [r4, #0]
    ad1a:	5c12      	ldrb	r2, [r2, r0]
    ad1c:	f012 0f08 	tst.w	r2, #8
    ad20:	d1f7      	bne.n	ad12 <TCPIP_Helper_StringToIPv6Address+0xc2>
    endPtr = str + len;
    ad22:	4426      	add	r6, r4
    ad24:	9615      	str	r6, [sp, #84]	; 0x54
    while(isspace(*(endPtr - 1)))
    ad26:	f816 2c01 	ldrb.w	r2, [r6, #-1]
    ad2a:	4b97      	ldr	r3, [pc, #604]	; (af88 <TCPIP_Helper_StringToIPv6Address+0x338>)
    ad2c:	5cd3      	ldrb	r3, [r2, r3]
    ad2e:	f013 0f08 	tst.w	r3, #8
    ad32:	d009      	beq.n	ad48 <TCPIP_Helper_StringToIPv6Address+0xf8>
    ad34:	1e73      	subs	r3, r6, #1
    ad36:	4994      	ldr	r1, [pc, #592]	; (af88 <TCPIP_Helper_StringToIPv6Address+0x338>)
        endPtr--;
    ad38:	461e      	mov	r6, r3
    ad3a:	9315      	str	r3, [sp, #84]	; 0x54
    while(isspace(*(endPtr - 1)))
    ad3c:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
    ad40:	5c52      	ldrb	r2, [r2, r1]
    ad42:	f012 0f08 	tst.w	r2, #8
    ad46:	d1f7      	bne.n	ad38 <TCPIP_Helper_StringToIPv6Address+0xe8>
    *endPtr = 0;
    ad48:	2300      	movs	r3, #0
    ad4a:	7033      	strb	r3, [r6, #0]
    if(*str == ':')
    ad4c:	7823      	ldrb	r3, [r4, #0]
    ad4e:	2b3a      	cmp	r3, #58	; 0x3a
    ad50:	d065      	beq.n	ae1e <TCPIP_Helper_StringToIPv6Address+0x1ce>
    uint8_t shiftIndex = 0xFF;
    ad52:	27ff      	movs	r7, #255	; 0xff
    if(!isxdigit(*str))
    ad54:	7826      	ldrb	r6, [r4, #0]
    ad56:	4b8c      	ldr	r3, [pc, #560]	; (af88 <TCPIP_Helper_StringToIPv6Address+0x338>)
    ad58:	5cf3      	ldrb	r3, [r6, r3]
    ad5a:	f013 0f44 	tst.w	r3, #68	; 0x44
    ad5e:	f000 80b9 	beq.w	aed4 <TCPIP_Helper_StringToIPv6Address+0x284>
    i = *str++;
    ad62:	3401      	adds	r4, #1
    while (i != ':' && i != 0u && i != '.' && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
    ad64:	2e3a      	cmp	r6, #58	; 0x3a
    ad66:	d074      	beq.n	ae52 <TCPIP_Helper_StringToIPv6Address+0x202>
    ad68:	f016 02df 	ands.w	r2, r6, #223	; 0xdf
    ad6c:	d072      	beq.n	ae54 <TCPIP_Helper_StringToIPv6Address+0x204>
    ad6e:	f1a6 032e 	sub.w	r3, r6, #46	; 0x2e
    ad72:	b2db      	uxtb	r3, r3
    ad74:	2b01      	cmp	r3, #1
    ad76:	f240 80a3 	bls.w	aec0 <TCPIP_Helper_StringToIPv6Address+0x270>
    ad7a:	2e0d      	cmp	r6, #13
    ad7c:	f000 80a2 	beq.w	aec4 <TCPIP_Helper_StringToIPv6Address+0x274>
    ad80:	f1a6 0309 	sub.w	r3, r6, #9
    ad84:	b2db      	uxtb	r3, r3
    ad86:	2b01      	cmp	r3, #1
    ad88:	bf98      	it	ls
    ad8a:	2200      	movls	r2, #0
    ad8c:	d962      	bls.n	ae54 <TCPIP_Helper_StringToIPv6Address+0x204>
    currentWord = 0;
    ad8e:	f04f 0900 	mov.w	r9, #0
    int conv_base = 16;
    ad92:	f04f 0b10 	mov.w	fp, #16
        subString[j] = 0;
    ad96:	46ca      	mov	sl, r9
        while (i != ':' && i != 0u && i != '.' && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
    ad98:	2e3a      	cmp	r6, #58	; 0x3a
    ad9a:	f000 8100 	beq.w	af9e <TCPIP_Helper_StringToIPv6Address+0x34e>
    ad9e:	2e00      	cmp	r6, #0
    ada0:	f000 80a6 	beq.w	aef0 <TCPIP_Helper_StringToIPv6Address+0x2a0>
    ada4:	2e2e      	cmp	r6, #46	; 0x2e
    ada6:	f000 80f1 	beq.w	af8c <TCPIP_Helper_StringToIPv6Address+0x33c>
    adaa:	2e2f      	cmp	r6, #47	; 0x2f
    adac:	f000 80e1 	beq.w	af72 <TCPIP_Helper_StringToIPv6Address+0x322>
    adb0:	2e0d      	cmp	r6, #13
    adb2:	f000 80e0 	beq.w	af76 <TCPIP_Helper_StringToIPv6Address+0x326>
    adb6:	2e0a      	cmp	r6, #10
    adb8:	f000 80df 	beq.w	af7a <TCPIP_Helper_StringToIPv6Address+0x32a>
    adbc:	2e20      	cmp	r6, #32
    adbe:	f000 80de 	beq.w	af7e <TCPIP_Helper_StringToIPv6Address+0x32e>
    adc2:	2e09      	cmp	r6, #9
    adc4:	f000 80dd 	beq.w	af82 <TCPIP_Helper_StringToIPv6Address+0x332>
    adc8:	aa16      	add	r2, sp, #88	; 0x58
    adca:	2301      	movs	r3, #1
            subString[j++] = i;
    adcc:	fa5f f883 	uxtb.w	r8, r3
    add0:	f802 6b01 	strb.w	r6, [r2], #1
            i = *str++;
    add4:	f814 6b01 	ldrb.w	r6, [r4], #1
        while (i != ':' && i != 0u && i != '.' && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
    add8:	2e3a      	cmp	r6, #58	; 0x3a
    adda:	f000 80e1 	beq.w	afa0 <TCPIP_Helper_StringToIPv6Address+0x350>
    adde:	2e00      	cmp	r6, #0
    ade0:	f000 8087 	beq.w	aef2 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    ade4:	2e2e      	cmp	r6, #46	; 0x2e
    ade6:	f000 80d2 	beq.w	af8e <TCPIP_Helper_StringToIPv6Address+0x33e>
    adea:	2e2f      	cmp	r6, #47	; 0x2f
    adec:	f000 8081 	beq.w	aef2 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    adf0:	2e0d      	cmp	r6, #13
    adf2:	d07e      	beq.n	aef2 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    adf4:	2e0a      	cmp	r6, #10
    adf6:	d07c      	beq.n	aef2 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    adf8:	2e20      	cmp	r6, #32
    adfa:	d07a      	beq.n	aef2 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    adfc:	2e09      	cmp	r6, #9
    adfe:	d078      	beq.n	aef2 <TCPIP_Helper_StringToIPv6Address+0x2a2>
            if (j == 4)
    ae00:	3301      	adds	r3, #1
    ae02:	2b05      	cmp	r3, #5
    ae04:	d1e2      	bne.n	adcc <TCPIP_Helper_StringToIPv6Address+0x17c>
                return false;
    ae06:	2000      	movs	r0, #0
    ae08:	e735      	b.n	ac76 <TCPIP_Helper_StringToIPv6Address+0x26>
        if(str[len - 1] != ']')
    ae0a:	f81d 3007 	ldrb.w	r3, [sp, r7]
    ae0e:	2b5d      	cmp	r3, #93	; 0x5d
    ae10:	d15c      	bne.n	aecc <TCPIP_Helper_StringToIPv6Address+0x27c>
        str[len - 1] = 0;   // delete trailing ]
    ae12:	f80d 2007 	strb.w	r2, [sp, r7]
        len--;
    ae16:	3e02      	subs	r6, #2
        str++;  // skip leading [
    ae18:	f10d 0401 	add.w	r4, sp, #1
    ae1c:	e770      	b.n	ad00 <TCPIP_Helper_StringToIPv6Address+0xb0>
        if(*++str != ':')
    ae1e:	7863      	ldrb	r3, [r4, #1]
    ae20:	2b3a      	cmp	r3, #58	; 0x3a
    ae22:	d155      	bne.n	aed0 <TCPIP_Helper_StringToIPv6Address+0x280>
        str++;
    ae24:	3402      	adds	r4, #2
        shiftIndex = 0;
    ae26:	2700      	movs	r7, #0
    ae28:	e794      	b.n	ad54 <TCPIP_Helper_StringToIPv6Address+0x104>
            if (*str == ':')
    ae2a:	7823      	ldrb	r3, [r4, #0]
    ae2c:	2b3a      	cmp	r3, #58	; 0x3a
    ae2e:	d002      	beq.n	ae36 <TCPIP_Helper_StringToIPv6Address+0x1e6>
        i = *str++;
    ae30:	f814 6b01 	ldrb.w	r6, [r4], #1
    ae34:	e088      	b.n	af48 <TCPIP_Helper_StringToIPv6Address+0x2f8>
                if (shiftIndex == 0xFF)
    ae36:	2fff      	cmp	r7, #255	; 0xff
    ae38:	d150      	bne.n	aedc <TCPIP_Helper_StringToIPv6Address+0x28c>
                i = *str++;
    ae3a:	3401      	adds	r4, #1
        convAddr.w[currentWord++] = TCPIP_Helper_htons(convertedValue);
    ae3c:	4617      	mov	r7, r2
    ae3e:	e07e      	b.n	af3e <TCPIP_Helper_StringToIPv6Address+0x2ee>
    if(currentWord > 8 || (currentWord < 8 && shiftIndex == 0xff))
    ae40:	2a08      	cmp	r2, #8
    ae42:	d901      	bls.n	ae48 <TCPIP_Helper_StringToIPv6Address+0x1f8>
        return false;
    ae44:	2000      	movs	r0, #0
    ae46:	e716      	b.n	ac76 <TCPIP_Helper_StringToIPv6Address+0x26>
    if(currentWord > 8 || (currentWord < 8 && shiftIndex == 0xff))
    ae48:	2a07      	cmp	r2, #7
    ae4a:	d903      	bls.n	ae54 <TCPIP_Helper_StringToIPv6Address+0x204>
    if (shiftIndex != 0xFF)
    ae4c:	2fff      	cmp	r7, #255	; 0xff
    ae4e:	d02e      	beq.n	aeae <TCPIP_Helper_StringToIPv6Address+0x25e>
    ae50:	e002      	b.n	ae58 <TCPIP_Helper_StringToIPv6Address+0x208>
    while (i != ':' && i != 0u && i != '.' && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
    ae52:	2200      	movs	r2, #0
    if(currentWord > 8 || (currentWord < 8 && shiftIndex == 0xff))
    ae54:	2fff      	cmp	r7, #255	; 0xff
    ae56:	d045      	beq.n	aee4 <TCPIP_Helper_StringToIPv6Address+0x294>
        for (i = 7, j = currentWord - 1; (int8_t)j >= (int8_t)shiftIndex; i--, j--)
    ae58:	1e53      	subs	r3, r2, #1
    ae5a:	b2db      	uxtb	r3, r3
    ae5c:	b27c      	sxtb	r4, r7
    ae5e:	b259      	sxtb	r1, r3
    ae60:	42a1      	cmp	r1, r4
    ae62:	db13      	blt.n	ae8c <TCPIP_Helper_StringToIPv6Address+0x23c>
            convAddr.w[i] = convAddr.w[j];
    ae64:	f1c2 0608 	rsb	r6, r2, #8
    ae68:	a918      	add	r1, sp, #96	; 0x60
    ae6a:	eb01 0143 	add.w	r1, r1, r3, lsl #1
    ae6e:	f831 0c1c 	ldrh.w	r0, [r1, #-28]
    ae72:	1999      	adds	r1, r3, r6
    ae74:	b2c9      	uxtb	r1, r1
    ae76:	f10d 0c60 	add.w	ip, sp, #96	; 0x60
    ae7a:	eb0c 0141 	add.w	r1, ip, r1, lsl #1
    ae7e:	f821 0c1c 	strh.w	r0, [r1, #-28]
        for (i = 7, j = currentWord - 1; (int8_t)j >= (int8_t)shiftIndex; i--, j--)
    ae82:	3b01      	subs	r3, #1
    ae84:	b2db      	uxtb	r3, r3
    ae86:	b259      	sxtb	r1, r3
    ae88:	428c      	cmp	r4, r1
    ae8a:	dded      	ble.n	ae68 <TCPIP_Helper_StringToIPv6Address+0x218>
        for (i = shiftIndex; i <= 7 - (currentWord - shiftIndex); i++)
    ae8c:	4639      	mov	r1, r7
    ae8e:	1bd3      	subs	r3, r2, r7
    ae90:	f1c3 0307 	rsb	r3, r3, #7
    ae94:	429f      	cmp	r7, r3
    ae96:	dc0a      	bgt.n	aeae <TCPIP_Helper_StringToIPv6Address+0x25e>
            convAddr.w[i] = 0x0000;
    ae98:	2200      	movs	r2, #0
    ae9a:	a818      	add	r0, sp, #96	; 0x60
    ae9c:	eb00 0141 	add.w	r1, r0, r1, lsl #1
    aea0:	f821 2c1c 	strh.w	r2, [r1, #-28]
        for (i = shiftIndex; i <= 7 - (currentWord - shiftIndex); i++)
    aea4:	3701      	adds	r7, #1
    aea6:	b2ff      	uxtb	r7, r7
    aea8:	4639      	mov	r1, r7
    aeaa:	429f      	cmp	r7, r3
    aeac:	ddf5      	ble.n	ae9a <TCPIP_Helper_StringToIPv6Address+0x24a>
    if(addr)
    aeae:	b1dd      	cbz	r5, aee8 <TCPIP_Helper_StringToIPv6Address+0x298>
        memcpy(addr, convAddr.v, sizeof(*addr));
    aeb0:	ac11      	add	r4, sp, #68	; 0x44
    aeb2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    aeb4:	6028      	str	r0, [r5, #0]
    aeb6:	6069      	str	r1, [r5, #4]
    aeb8:	60aa      	str	r2, [r5, #8]
    aeba:	60eb      	str	r3, [r5, #12]
    return true;
    aebc:	2001      	movs	r0, #1
    aebe:	e6da      	b.n	ac76 <TCPIP_Helper_StringToIPv6Address+0x26>
    while (i != ':' && i != 0u && i != '.' && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
    aec0:	2200      	movs	r2, #0
    aec2:	e7c7      	b.n	ae54 <TCPIP_Helper_StringToIPv6Address+0x204>
    aec4:	2200      	movs	r2, #0
    aec6:	e7c5      	b.n	ae54 <TCPIP_Helper_StringToIPv6Address+0x204>
        return true;
    aec8:	2001      	movs	r0, #1
    aeca:	e6d4      	b.n	ac76 <TCPIP_Helper_StringToIPv6Address+0x26>
            return false;
    aecc:	2000      	movs	r0, #0
    aece:	e6d2      	b.n	ac76 <TCPIP_Helper_StringToIPv6Address+0x26>
            return false;
    aed0:	2000      	movs	r0, #0
    aed2:	e6d0      	b.n	ac76 <TCPIP_Helper_StringToIPv6Address+0x26>
        return false;
    aed4:	2000      	movs	r0, #0
    aed6:	e6ce      	b.n	ac76 <TCPIP_Helper_StringToIPv6Address+0x26>
            return false;
    aed8:	2000      	movs	r0, #0
    aeda:	e6cc      	b.n	ac76 <TCPIP_Helper_StringToIPv6Address+0x26>
                    return false;
    aedc:	2000      	movs	r0, #0
    aede:	e6ca      	b.n	ac76 <TCPIP_Helper_StringToIPv6Address+0x26>
            return false;
    aee0:	2000      	movs	r0, #0
    aee2:	e6c8      	b.n	ac76 <TCPIP_Helper_StringToIPv6Address+0x26>
        return false;
    aee4:	2000      	movs	r0, #0
    aee6:	e6c6      	b.n	ac76 <TCPIP_Helper_StringToIPv6Address+0x26>
    return true;
    aee8:	2001      	movs	r0, #1
    aeea:	e6c4      	b.n	ac76 <TCPIP_Helper_StringToIPv6Address+0x26>
            return false;
    aeec:	2000      	movs	r0, #0
    aeee:	e6c2      	b.n	ac76 <TCPIP_Helper_StringToIPv6Address+0x26>
        j = 0;
    aef0:	46b0      	mov	r8, r6
        subString[j] = 0;
    aef2:	ab18      	add	r3, sp, #96	; 0x60
    aef4:	4443      	add	r3, r8
    aef6:	f803 ac08 	strb.w	sl, [r3, #-8]
        convertedValue = (uint16_t)strtol((const char *)subString, &endPtr, conv_base);
    aefa:	465a      	mov	r2, fp
    aefc:	a915      	add	r1, sp, #84	; 0x54
    aefe:	a816      	add	r0, sp, #88	; 0x58
    af00:	f016 fd06 	bl	21910 <strtol>
    af04:	b281      	uxth	r1, r0
        if(convertedValue == 0 && endPtr != (char*)subString + j)
    af06:	b921      	cbnz	r1, af12 <TCPIP_Helper_StringToIPv6Address+0x2c2>
    af08:	ab16      	add	r3, sp, #88	; 0x58
    af0a:	4498      	add	r8, r3
    af0c:	9b15      	ldr	r3, [sp, #84]	; 0x54
    af0e:	4543      	cmp	r3, r8
    af10:	d1e2      	bne.n	aed8 <TCPIP_Helper_StringToIPv6Address+0x288>
        convAddr.w[currentWord++] = TCPIP_Helper_htons(convertedValue);
    af12:	f109 0201 	add.w	r2, r9, #1
    af16:	b2d2      	uxtb	r2, r2
    af18:	ab18      	add	r3, sp, #96	; 0x60
    af1a:	eb03 0949 	add.w	r9, r3, r9, lsl #1
       return (((hShort) << 8) | ((hShort) >> 8));
    af1e:	0203      	lsls	r3, r0, #8
    af20:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    af24:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    af28:	ea43 2311 	orr.w	r3, r3, r1, lsr #8
    af2c:	f829 3c1c 	strh.w	r3, [r9, #-28]
        if(i == 0)
    af30:	2e00      	cmp	r6, #0
    af32:	d085      	beq.n	ae40 <TCPIP_Helper_StringToIPv6Address+0x1f0>
        if (i == ':')
    af34:	2e3a      	cmp	r6, #58	; 0x3a
    af36:	f43f af78 	beq.w	ae2a <TCPIP_Helper_StringToIPv6Address+0x1da>
        if (i == ',')
    af3a:	2e2c      	cmp	r6, #44	; 0x2c
    af3c:	d0d0      	beq.n	aee0 <TCPIP_Helper_StringToIPv6Address+0x290>
        i = *str++;
    af3e:	f814 6b01 	ldrb.w	r6, [r4], #1
    while (i != ':' && i != 0u && i != '.' && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
    af42:	2e3a      	cmp	r6, #58	; 0x3a
    af44:	f43f af7c 	beq.w	ae40 <TCPIP_Helper_StringToIPv6Address+0x1f0>
    af48:	f016 0fdf 	tst.w	r6, #223	; 0xdf
    af4c:	f43f af78 	beq.w	ae40 <TCPIP_Helper_StringToIPv6Address+0x1f0>
    af50:	f1a6 032e 	sub.w	r3, r6, #46	; 0x2e
    af54:	b2db      	uxtb	r3, r3
    af56:	2b01      	cmp	r3, #1
    af58:	f67f af72 	bls.w	ae40 <TCPIP_Helper_StringToIPv6Address+0x1f0>
    af5c:	2e0d      	cmp	r6, #13
    af5e:	f43f af6f 	beq.w	ae40 <TCPIP_Helper_StringToIPv6Address+0x1f0>
    af62:	f1a6 0309 	sub.w	r3, r6, #9
    af66:	b2db      	uxtb	r3, r3
    af68:	2b01      	cmp	r3, #1
    af6a:	f67f af69 	bls.w	ae40 <TCPIP_Helper_StringToIPv6Address+0x1f0>
        convAddr.w[currentWord++] = TCPIP_Helper_htons(convertedValue);
    af6e:	4691      	mov	r9, r2
    af70:	e712      	b.n	ad98 <TCPIP_Helper_StringToIPv6Address+0x148>
        j = 0;
    af72:	46d0      	mov	r8, sl
    af74:	e7bd      	b.n	aef2 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    af76:	46d0      	mov	r8, sl
    af78:	e7bb      	b.n	aef2 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    af7a:	46d0      	mov	r8, sl
    af7c:	e7b9      	b.n	aef2 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    af7e:	46d0      	mov	r8, sl
    af80:	e7b7      	b.n	aef2 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    af82:	46d0      	mov	r8, sl
    af84:	e7b5      	b.n	aef2 <TCPIP_Helper_StringToIPv6Address+0x2a2>
    af86:	bf00      	nop
    af88:	00013c61 	.word	0x00013c61
    af8c:	46d0      	mov	r8, sl
        subString[j] = 0;
    af8e:	ab18      	add	r3, sp, #96	; 0x60
    af90:	4443      	add	r3, r8
    af92:	f803 ac08 	strb.w	sl, [r3, #-8]
    af96:	262e      	movs	r6, #46	; 0x2e
            conv_base = 10;
    af98:	f04f 0b0a 	mov.w	fp, #10
    af9c:	e7ad      	b.n	aefa <TCPIP_Helper_StringToIPv6Address+0x2aa>
        j = 0;
    af9e:	46d0      	mov	r8, sl
        subString[j] = 0;
    afa0:	ab18      	add	r3, sp, #96	; 0x60
    afa2:	4443      	add	r3, r8
    afa4:	f803 ac08 	strb.w	sl, [r3, #-8]
        else if(i == ':' && conv_base == 10)
    afa8:	f1bb 0f0a 	cmp.w	fp, #10
    afac:	d09e      	beq.n	aeec <TCPIP_Helper_StringToIPv6Address+0x29c>
    afae:	263a      	movs	r6, #58	; 0x3a
    afb0:	e7a3      	b.n	aefa <TCPIP_Helper_StringToIPv6Address+0x2aa>
    afb2:	bf00      	nop

Disassembly of section .rodata%212:

0000afb4 <.rodata%212>:
    afb4:	72657069 	.word	0x72657069
    afb8:	632d2066 	.word	0x632d2066
    afbc:	32393120 	.word	0x32393120
    afc0:	3836312e 	.word	0x3836312e
    afc4:	312e312e 	.word	0x312e312e
    afc8:	000a      	.short	0x000a
    afca:	bf00      	nop
    afcc:	72657069 	.word	0x72657069
    afd0:	43542066 	.word	0x43542066
    afd4:	6c632050 	.word	0x6c632050
    afd8:	746e6569 	.word	0x746e6569
    afdc:	00          	.byte	0x00
    afdd:	00          	.byte	0x00
    afde:	bf00      	nop
    afe0:	72657069 	.word	0x72657069
    afe4:	632d2066 	.word	0x632d2066
    afe8:	32393120 	.word	0x32393120
    afec:	3836312e 	.word	0x3836312e
    aff0:	312e312e 	.word	0x312e312e
    aff4:	0a752d20 	.word	0x0a752d20
    aff8:	00          	.byte	0x00
    aff9:	00          	.byte	0x00
    affa:	bf00      	nop
    affc:	72657069 	.word	0x72657069
    b000:	44552066 	.word	0x44552066
    b004:	6c632050 	.word	0x6c632050
    b008:	746e6569 	.word	0x746e6569
    b00c:	00          	.byte	0x00
    b00d:	00          	.byte	0x00
    b00e:	bf00      	nop
    b010:	3a707041 	.word	0x3a707041
    b014:	69696d20 	.word	0x69696d20
    b018:	6573206d 	.word	0x6573206d
    b01c:	20707574 	.word	0x20707574
    b020:	6c696166 	.word	0x6c696166
    b024:	21206465 	.word	0x21206465
    b028:	0a0d      	.short	0x0a0d
    b02a:	00          	.byte	0x00
    b02b:	00          	.byte	0x00
    b02c:	6f727245 	.word	0x6f727245
    b030:	636f2072 	.word	0x636f2072
    b034:	65727563 	.word	0x65727563
    b038:	64253a64 	.word	0x64253a64
    b03c:	0a0d      	.short	0x0a0d
    b03e:	00          	.byte	0x00
    b03f:	00          	.byte	0x00
    b040:	6e614c20 	.word	0x6e614c20
    b044:	78373638 	.word	0x78373638
    b048:	20736920 	.word	0x20736920
    b04c:	50206e69 	.word	0x50206e69
    b050:	2041434c 	.word	0x2041434c
    b054:	65646f6d 	.word	0x65646f6d
    b058:	0a0d202e 	.word	0x0a0d202e
    b05c:	00          	.byte	0x00
    b05d:	00          	.byte	0x00
    b05e:	bf00      	nop
    b060:	6e614c20 	.word	0x6e614c20
    b064:	78373638 	.word	0x78373638
    b068:	20736920 	.word	0x20736920
    b06c:	43206e69 	.word	0x43206e69
    b070:	20414d53 	.word	0x20414d53
    b074:	65646f6d 	.word	0x65646f6d
    b078:	0a0d202e 	.word	0x0a0d202e
    b07c:	00          	.byte	0x00
    b07d:	00          	.byte	0x00
    b07e:	bf00      	nop
    b080:	646f4e20 	.word	0x646f4e20
    b084:	64492065 	.word	0x64492065
    b088:	6425203a 	.word	0x6425203a
    b08c:	6f4e202c 	.word	0x6f4e202c
    b090:	63206564 	.word	0x63206564
    b094:	746e756f 	.word	0x746e756f
    b098:	6425203a 	.word	0x6425203a
    b09c:	0a0d202e 	.word	0x0a0d202e
    b0a0:	00          	.byte	0x00
    b0a1:	00          	.byte	0x00
    b0a2:	bf00      	nop
    b0a4:	384e414c 	.word	0x384e414c
    b0a8:	20783736 	.word	0x20783736
    b0ac:	41434c50 	.word	0x41434c50
    b0b0:	00          	.byte	0x00
    b0b1:	00          	.byte	0x00
    b0b2:	bf00      	nop
    b0b4:	2e323931 	.word	0x2e323931
    b0b8:	2e383631 	.word	0x2e383631
    b0bc:	30322e31 	.word	0x30322e31
    b0c0:	0030      	.short	0x0030
    b0c2:	bf00      	nop
    b0c4:	203a6449 	.word	0x203a6449
    b0c8:	43206425 	.word	0x43206425
    b0cc:	746e756f 	.word	0x746e756f
    b0d0:	6425203a 	.word	0x6425203a
    b0d4:	00          	.byte	0x00
    b0d5:	00          	.byte	0x00
    b0d6:	bf00      	nop
    b0d8:	20504920 	.word	0x20504920
    b0dc:	72646441 	.word	0x72646441
    b0e0:	3a737365 	.word	0x3a737365
    b0e4:	0020      	.short	0x0020
    b0e6:	bf00      	nop
    b0e8:	252e6425 	.word	0x252e6425
    b0ec:	64252e64 	.word	0x64252e64
    b0f0:	0064252e 	.word	0x0064252e
    b0f4:	0a0d7325 	.word	0x0a0d7325
    b0f8:	00          	.byte	0x00
    b0f9:	00          	.byte	0x00
    b0fa:	bf00      	nop
    b0fc:	3a77656e 	.word	0x3a77656e
    b100:	7325      	.short	0x7325
    b102:	00          	.byte	0x00
    b103:	00          	.byte	0x00
    b104:	6f4c203e 	.word	0x6f4c203e
    b108:	206c6163 	.word	0x206c6163
    b10c:	6d69696d 	.word	0x6d69696d
    b110:	65706f20 	.word	0x65706f20
    b114:	66203a6e 	.word	0x66203a6e
    b118:	656c6961 	.word	0x656c6961
    b11c:	0a0d2164 	.word	0x0a0d2164
    b120:	00000000 	.word	0x00000000
    b124:	6f4c203e 	.word	0x6f4c203e
    b128:	206c6163 	.word	0x206c6163
    b12c:	6d69696d 	.word	0x6d69696d
    b130:	74657320 	.word	0x74657320
    b134:	203a7075 	.word	0x203a7075
    b138:	6c696166 	.word	0x6c696166
    b13c:	0d216465 	.word	0x0d216465
    b140:	0000000a 	.word	0x0000000a
    b144:	694d203e 	.word	0x694d203e
    b148:	53206d69 	.word	0x53206d69
    b14c:	65636375 	.word	0x65636375
    b150:	75667373 	.word	0x75667373
    b154:	20796c6c 	.word	0x20796c6c
    b158:	6e65706f 	.word	0x6e65706f
    b15c:	202e6465 	.word	0x202e6465
    b160:	00000a0d 	.word	0x00000a0d
    b164:	694d203e 	.word	0x694d203e
    b168:	63206d69 	.word	0x63206d69
    b16c:	65736f6c 	.word	0x65736f6c
    b170:	0d202e64 	.word	0x0d202e64
    b174:	0000000a 	.word	0x0000000a
    b178:	2d207325 	.word	0x2d207325
    b17c:	00000020 	.word	0x00000020
    b180:	50434844 	.word	0x50434844
    b184:	4556455f 	.word	0x4556455f
    b188:	4e5f544e 	.word	0x4e5f544e
    b18c:	0a454e4f 	.word	0x0a454e4f
    b190:	0000000d 	.word	0x0000000d
    b194:	50434844 	.word	0x50434844
    b198:	4556455f 	.word	0x4556455f
    b19c:	445f544e 	.word	0x445f544e
    b1a0:	4f435349 	.word	0x4f435349
    b1a4:	0a524556 	.word	0x0a524556
    b1a8:	0000000d 	.word	0x0000000d
    b1ac:	50434844 	.word	0x50434844
    b1b0:	4556455f 	.word	0x4556455f
    b1b4:	525f544e 	.word	0x525f544e
    b1b8:	45555145 	.word	0x45555145
    b1bc:	0d0a5453 	.word	0x0d0a5453
    b1c0:	00000000 	.word	0x00000000
    b1c4:	50434844 	.word	0x50434844
    b1c8:	4556455f 	.word	0x4556455f
    b1cc:	415f544e 	.word	0x415f544e
    b1d0:	0d0a4b43 	.word	0x0d0a4b43
    b1d4:	00000000 	.word	0x00000000
    b1d8:	50434844 	.word	0x50434844
    b1dc:	4556455f 	.word	0x4556455f
    b1e0:	415f544e 	.word	0x415f544e
    b1e4:	495f4b43 	.word	0x495f4b43
    b1e8:	4c41564e 	.word	0x4c41564e
    b1ec:	0d0a4449 	.word	0x0d0a4449
    b1f0:	00000000 	.word	0x00000000
    b1f4:	50434844 	.word	0x50434844
    b1f8:	4556455f 	.word	0x4556455f
    b1fc:	445f544e 	.word	0x445f544e
    b200:	494c4345 	.word	0x494c4345
    b204:	0d0a454e 	.word	0x0d0a454e
    b208:	00000000 	.word	0x00000000
    b20c:	50434844 	.word	0x50434844
    b210:	4556455f 	.word	0x4556455f
    b214:	4e5f544e 	.word	0x4e5f544e
    b218:	0a4b4341 	.word	0x0a4b4341
    b21c:	0000000d 	.word	0x0000000d
    b220:	50434844 	.word	0x50434844
    b224:	4556455f 	.word	0x4556455f
    b228:	545f544e 	.word	0x545f544e
    b22c:	4f454d49 	.word	0x4f454d49
    b230:	0d0a5455 	.word	0x0d0a5455
    b234:	00000000 	.word	0x00000000
    b238:	50434844 	.word	0x50434844
    b23c:	4556455f 	.word	0x4556455f
    b240:	425f544e 	.word	0x425f544e
    b244:	444e554f 	.word	0x444e554f
    b248:	00000d0a 	.word	0x00000d0a
    b24c:	50434844 	.word	0x50434844
    b250:	4556455f 	.word	0x4556455f
    b254:	525f544e 	.word	0x525f544e
    b258:	45555145 	.word	0x45555145
    b25c:	525f5453 	.word	0x525f5453
    b260:	57454e45 	.word	0x57454e45
    b264:	00000d0a 	.word	0x00000d0a
    b268:	50434844 	.word	0x50434844
    b26c:	4556455f 	.word	0x4556455f
    b270:	525f544e 	.word	0x525f544e
    b274:	45555145 	.word	0x45555145
    b278:	525f5453 	.word	0x525f5453
    b27c:	4e494245 	.word	0x4e494245
    b280:	000d0a44 	.word	0x000d0a44
    b284:	50434844 	.word	0x50434844
    b288:	4556455f 	.word	0x4556455f
    b28c:	435f544e 	.word	0x435f544e
    b290:	5f4e4e4f 	.word	0x5f4e4e4f
    b294:	54534f4c 	.word	0x54534f4c
    b298:	00000d0a 	.word	0x00000d0a
    b29c:	50434844 	.word	0x50434844
    b2a0:	4556455f 	.word	0x4556455f
    b2a4:	435f544e 	.word	0x435f544e
    b2a8:	5f4e4e4f 	.word	0x5f4e4e4f
    b2ac:	41545345 	.word	0x41545345
    b2b0:	53494c42 	.word	0x53494c42
    b2b4:	0a444548 	.word	0x0a444548
    b2b8:	0000000d 	.word	0x0000000d
    b2bc:	50434844 	.word	0x50434844
    b2c0:	4556455f 	.word	0x4556455f
    b2c4:	535f544e 	.word	0x535f544e
    b2c8:	49565245 	.word	0x49565245
    b2cc:	445f4543 	.word	0x445f4543
    b2d0:	42415349 	.word	0x42415349
    b2d4:	0a44454c 	.word	0x0a44454c
    b2d8:	000d      	.short	0x000d
    b2da:	bf00      	nop

Disassembly of section .text.Transform_Sha256%213:

0000b2dc <Transform_Sha256>:
         t1 = Sigma0(a(j)) + Maj(a(j), b(j), c(j)); \
         d(j) += t0; \
         h(j)  = t0 + t1

    static int Transform_Sha256(wc_Sha256* sha256, const byte* data)
    {
    b2dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b2e0:	b0cb      	sub	sp, #300	; 0x12c
    #else
        word32 W[WC_SHA256_BLOCK_SIZE];
    #endif

        /* Copy context->state[] to working vars */
        for (i = 0; i < 8; i++)
    b2e2:	f1a0 0a04 	sub.w	sl, r0, #4
    b2e6:	aa41      	add	r2, sp, #260	; 0x104
    b2e8:	9200      	str	r2, [sp, #0]
    b2ea:	f100 041c 	add.w	r4, r0, #28
    b2ee:	9401      	str	r4, [sp, #4]
    {
    b2f0:	4653      	mov	r3, sl
            S[i] = sha256->digest[i];
    b2f2:	f853 0f04 	ldr.w	r0, [r3, #4]!
    b2f6:	f842 0f04 	str.w	r0, [r2, #4]!
        for (i = 0; i < 8; i++)
    b2fa:	42a3      	cmp	r3, r4
    b2fc:	d1f9      	bne.n	b2f2 <Transform_Sha256+0x16>
    b2fe:	3904      	subs	r1, #4
    b300:	f10d 0908 	add.w	r9, sp, #8
    b304:	a812      	add	r0, sp, #72	; 0x48
    b306:	464b      	mov	r3, r9

        for (i = 0; i < 16; i++)
            W[i] = *((word32*)&data[i*sizeof(word32)]);
    b308:	f851 2f04 	ldr.w	r2, [r1, #4]!
    b30c:	f843 2b04 	str.w	r2, [r3], #4
        for (i = 0; i < 16; i++)
    b310:	4283      	cmp	r3, r0
    b312:	d1f9      	bne.n	b308 <Transform_Sha256+0x2c>
    b314:	f109 00c0 	add.w	r0, r9, #192	; 0xc0
    b318:	464a      	mov	r2, r9

        for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
            W[i] = Gamma1(W[i-2]) + W[i-7] + Gamma0(W[i-15]) + W[i-16];
    b31a:	4615      	mov	r5, r2
    b31c:	6b91      	ldr	r1, [r2, #56]	; 0x38
    b31e:	f852 4f04 	ldr.w	r4, [r2, #4]!
    }

/* This routine performs a right circular arithmetic shift of <x> by <y> value. */
    WC_STATIC WC_INLINE word32 rotrFixed(word32 x, word32 y)
    {
        return (x >> y) | (x << (sizeof(y) * 8 - y));
    b322:	ea4f 43f1 	mov.w	r3, r1, ror #19
    b326:	ea83 4371 	eor.w	r3, r3, r1, ror #17
    b32a:	ea83 2391 	eor.w	r3, r3, r1, lsr #10
    b32e:	6a69      	ldr	r1, [r5, #36]	; 0x24
    b330:	682d      	ldr	r5, [r5, #0]
    b332:	4429      	add	r1, r5
    b334:	440b      	add	r3, r1
    b336:	ea4f 41b4 	mov.w	r1, r4, ror #18
    b33a:	ea81 11f4 	eor.w	r1, r1, r4, ror #7
    b33e:	ea81 01d4 	eor.w	r1, r1, r4, lsr #3
    b342:	440b      	add	r3, r1
    b344:	63d3      	str	r3, [r2, #60]	; 0x3c
        for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
    b346:	4282      	cmp	r2, r0
    b348:	d1e7      	bne.n	b31a <Transform_Sha256+0x3e>
    b34a:	f8dd e124 	ldr.w	lr, [sp, #292]	; 0x124
    b34e:	9a45      	ldr	r2, [sp, #276]	; 0x114
    b350:	f8dd c120 	ldr.w	ip, [sp, #288]	; 0x120
    b354:	9944      	ldr	r1, [sp, #272]	; 0x110
    b356:	9f47      	ldr	r7, [sp, #284]	; 0x11c
    b358:	9843      	ldr	r0, [sp, #268]	; 0x10c
    b35a:	9b46      	ldr	r3, [sp, #280]	; 0x118
    b35c:	9c42      	ldr	r4, [sp, #264]	; 0x108
    b35e:	f8df 8284 	ldr.w	r8, [pc, #644]	; b5e4 <Transform_Sha256+0x308>
    b362:	46d3      	mov	fp, sl
    b364:	46ca      	mov	sl, r9
    b366:	46c1      	mov	r9, r8
    b368:	ea4f 25f3 	mov.w	r5, r3, ror #11
            }
        }
    #else
        /* partially loop unrolled */
        for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
            RND(0); RND(1); RND(2); RND(3);
    b36c:	ea85 15b3 	eor.w	r5, r5, r3, ror #6
    b370:	ea85 6873 	eor.w	r8, r5, r3, ror #25
    b374:	f8d9 5000 	ldr.w	r5, [r9]
    b378:	f8da 6000 	ldr.w	r6, [sl]
    b37c:	4435      	add	r5, r6
    b37e:	4445      	add	r5, r8
    b380:	ea8c 0607 	eor.w	r6, ip, r7
    b384:	401e      	ands	r6, r3
    b386:	ea86 060c 	eor.w	r6, r6, ip
    b38a:	4435      	add	r5, r6
    b38c:	44ae      	add	lr, r5
    b38e:	4472      	add	r2, lr
    b390:	ea4f 3574 	mov.w	r5, r4, ror #13
    b394:	ea85 05b4 	eor.w	r5, r5, r4, ror #2
    b398:	ea85 55b4 	eor.w	r5, r5, r4, ror #22
    b39c:	ea44 0600 	orr.w	r6, r4, r0
    b3a0:	400e      	ands	r6, r1
    b3a2:	ea04 0800 	and.w	r8, r4, r0
    b3a6:	ea46 0608 	orr.w	r6, r6, r8
    b3aa:	4435      	add	r5, r6
    b3ac:	44ae      	add	lr, r5
    b3ae:	f8d9 5004 	ldr.w	r5, [r9, #4]
    b3b2:	f8da 6004 	ldr.w	r6, [sl, #4]
    b3b6:	4435      	add	r5, r6
    b3b8:	4465      	add	r5, ip
    b3ba:	ea83 0c07 	eor.w	ip, r3, r7
    b3be:	ea0c 0c02 	and.w	ip, ip, r2
    b3c2:	ea8c 0c07 	eor.w	ip, ip, r7
    b3c6:	4465      	add	r5, ip
    b3c8:	ea4f 2cf2 	mov.w	ip, r2, ror #11
    b3cc:	ea8c 1cb2 	eor.w	ip, ip, r2, ror #6
    b3d0:	ea8c 6c72 	eor.w	ip, ip, r2, ror #25
    b3d4:	4465      	add	r5, ip
    b3d6:	eb01 0c05 	add.w	ip, r1, r5
    b3da:	ea4f 317e 	mov.w	r1, lr, ror #13
    b3de:	ea81 01be 	eor.w	r1, r1, lr, ror #2
    b3e2:	ea81 51be 	eor.w	r1, r1, lr, ror #22
    b3e6:	ea4e 0604 	orr.w	r6, lr, r4
    b3ea:	4006      	ands	r6, r0
    b3ec:	ea0e 0804 	and.w	r8, lr, r4
    b3f0:	ea46 0608 	orr.w	r6, r6, r8
    b3f4:	4431      	add	r1, r6
    b3f6:	4429      	add	r1, r5
    b3f8:	f8d9 5008 	ldr.w	r5, [r9, #8]
    b3fc:	f8da 6008 	ldr.w	r6, [sl, #8]
    b400:	4435      	add	r5, r6
    b402:	442f      	add	r7, r5
    b404:	ea83 0502 	eor.w	r5, r3, r2
    b408:	ea05 050c 	and.w	r5, r5, ip
    b40c:	405d      	eors	r5, r3
    b40e:	442f      	add	r7, r5
    b410:	ea4f 25fc 	mov.w	r5, ip, ror #11
    b414:	ea85 15bc 	eor.w	r5, r5, ip, ror #6
    b418:	ea85 657c 	eor.w	r5, r5, ip, ror #25
    b41c:	442f      	add	r7, r5
    b41e:	eb00 0807 	add.w	r8, r0, r7
    b422:	ea4f 3071 	mov.w	r0, r1, ror #13
    b426:	ea80 00b1 	eor.w	r0, r0, r1, ror #2
    b42a:	ea80 50b1 	eor.w	r0, r0, r1, ror #22
    b42e:	ea4e 0501 	orr.w	r5, lr, r1
    b432:	4025      	ands	r5, r4
    b434:	ea0e 0601 	and.w	r6, lr, r1
    b438:	4335      	orrs	r5, r6
    b43a:	4428      	add	r0, r5
    b43c:	4438      	add	r0, r7
    b43e:	f8d9 500c 	ldr.w	r5, [r9, #12]
    b442:	f8da 600c 	ldr.w	r6, [sl, #12]
    b446:	4435      	add	r5, r6
    b448:	442b      	add	r3, r5
    b44a:	ea82 050c 	eor.w	r5, r2, ip
    b44e:	ea05 0508 	and.w	r5, r5, r8
    b452:	4055      	eors	r5, r2
    b454:	442b      	add	r3, r5
    b456:	ea4f 25f8 	mov.w	r5, r8, ror #11
    b45a:	ea85 15b8 	eor.w	r5, r5, r8, ror #6
    b45e:	ea85 6578 	eor.w	r5, r5, r8, ror #25
    b462:	441d      	add	r5, r3
    b464:	1966      	adds	r6, r4, r5
    b466:	ea4f 3370 	mov.w	r3, r0, ror #13
    b46a:	ea83 03b0 	eor.w	r3, r3, r0, ror #2
    b46e:	ea83 53b0 	eor.w	r3, r3, r0, ror #22
    b472:	ea41 0400 	orr.w	r4, r1, r0
    b476:	ea04 040e 	and.w	r4, r4, lr
    b47a:	ea01 0700 	and.w	r7, r1, r0
    b47e:	433c      	orrs	r4, r7
    b480:	4423      	add	r3, r4
    b482:	442b      	add	r3, r5
            RND(4); RND(5); RND(6); RND(7);
    b484:	f8d9 4010 	ldr.w	r4, [r9, #16]
    b488:	f8da 5010 	ldr.w	r5, [sl, #16]
    b48c:	442c      	add	r4, r5
    b48e:	4422      	add	r2, r4
    b490:	ea8c 0408 	eor.w	r4, ip, r8
    b494:	4034      	ands	r4, r6
    b496:	ea84 040c 	eor.w	r4, r4, ip
    b49a:	4422      	add	r2, r4
    b49c:	ea4f 24f6 	mov.w	r4, r6, ror #11
    b4a0:	ea84 14b6 	eor.w	r4, r4, r6, ror #6
    b4a4:	ea84 6476 	eor.w	r4, r4, r6, ror #25
    b4a8:	4414      	add	r4, r2
    b4aa:	44a6      	add	lr, r4
    b4ac:	ea4f 3273 	mov.w	r2, r3, ror #13
    b4b0:	ea82 02b3 	eor.w	r2, r2, r3, ror #2
    b4b4:	ea82 52b3 	eor.w	r2, r2, r3, ror #22
    b4b8:	ea40 0503 	orr.w	r5, r0, r3
    b4bc:	400d      	ands	r5, r1
    b4be:	ea00 0703 	and.w	r7, r0, r3
    b4c2:	433d      	orrs	r5, r7
    b4c4:	442a      	add	r2, r5
    b4c6:	4422      	add	r2, r4
    b4c8:	f8d9 4014 	ldr.w	r4, [r9, #20]
    b4cc:	f8da 5014 	ldr.w	r5, [sl, #20]
    b4d0:	442c      	add	r4, r5
    b4d2:	4464      	add	r4, ip
    b4d4:	ea88 0c06 	eor.w	ip, r8, r6
    b4d8:	ea0c 0c0e 	and.w	ip, ip, lr
    b4dc:	ea8c 0c08 	eor.w	ip, ip, r8
    b4e0:	4464      	add	r4, ip
    b4e2:	ea4f 2cfe 	mov.w	ip, lr, ror #11
    b4e6:	ea8c 1cbe 	eor.w	ip, ip, lr, ror #6
    b4ea:	ea8c 6c7e 	eor.w	ip, ip, lr, ror #25
    b4ee:	4464      	add	r4, ip
    b4f0:	eb01 0c04 	add.w	ip, r1, r4
    b4f4:	ea4f 3172 	mov.w	r1, r2, ror #13
    b4f8:	ea81 01b2 	eor.w	r1, r1, r2, ror #2
    b4fc:	ea81 51b2 	eor.w	r1, r1, r2, ror #22
    b500:	ea43 0502 	orr.w	r5, r3, r2
    b504:	4005      	ands	r5, r0
    b506:	ea03 0702 	and.w	r7, r3, r2
    b50a:	433d      	orrs	r5, r7
    b50c:	4429      	add	r1, r5
    b50e:	4421      	add	r1, r4
    b510:	f8d9 4018 	ldr.w	r4, [r9, #24]
    b514:	f8da 5018 	ldr.w	r5, [sl, #24]
    b518:	442c      	add	r4, r5
    b51a:	44a0      	add	r8, r4
    b51c:	ea86 040e 	eor.w	r4, r6, lr
    b520:	ea04 040c 	and.w	r4, r4, ip
    b524:	4074      	eors	r4, r6
    b526:	44a0      	add	r8, r4
    b528:	ea4f 24fc 	mov.w	r4, ip, ror #11
    b52c:	ea84 14bc 	eor.w	r4, r4, ip, ror #6
    b530:	ea84 647c 	eor.w	r4, r4, ip, ror #25
    b534:	44a0      	add	r8, r4
    b536:	eb00 0708 	add.w	r7, r0, r8
    b53a:	ea4f 3071 	mov.w	r0, r1, ror #13
    b53e:	ea80 00b1 	eor.w	r0, r0, r1, ror #2
    b542:	ea80 50b1 	eor.w	r0, r0, r1, ror #22
    b546:	ea42 0401 	orr.w	r4, r2, r1
    b54a:	401c      	ands	r4, r3
    b54c:	ea02 0501 	and.w	r5, r2, r1
    b550:	432c      	orrs	r4, r5
    b552:	4420      	add	r0, r4
    b554:	4440      	add	r0, r8
    b556:	f8d9 401c 	ldr.w	r4, [r9, #28]
    b55a:	f8da 501c 	ldr.w	r5, [sl, #28]
    b55e:	442c      	add	r4, r5
    b560:	4434      	add	r4, r6
    b562:	ea8e 060c 	eor.w	r6, lr, ip
    b566:	403e      	ands	r6, r7
    b568:	ea86 060e 	eor.w	r6, r6, lr
    b56c:	4434      	add	r4, r6
    b56e:	ea4f 26f7 	mov.w	r6, r7, ror #11
    b572:	ea86 16b7 	eor.w	r6, r6, r7, ror #6
    b576:	ea86 6677 	eor.w	r6, r6, r7, ror #25
    b57a:	4426      	add	r6, r4
    b57c:	4433      	add	r3, r6
    b57e:	ea4f 3470 	mov.w	r4, r0, ror #13
    b582:	ea84 04b0 	eor.w	r4, r4, r0, ror #2
    b586:	ea84 54b0 	eor.w	r4, r4, r0, ror #22
    b58a:	ea41 0500 	orr.w	r5, r1, r0
    b58e:	4015      	ands	r5, r2
    b590:	ea01 0800 	and.w	r8, r1, r0
    b594:	ea45 0508 	orr.w	r5, r5, r8
    b598:	442c      	add	r4, r5
    b59a:	4434      	add	r4, r6
    b59c:	f109 0920 	add.w	r9, r9, #32
    b5a0:	f10a 0a20 	add.w	sl, sl, #32
        for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
    b5a4:	4d0e      	ldr	r5, [pc, #56]	; (b5e0 <Transform_Sha256+0x304>)
    b5a6:	45a9      	cmp	r9, r5
    b5a8:	f47f aede 	bne.w	b368 <Transform_Sha256+0x8c>
    b5ac:	46da      	mov	sl, fp
    b5ae:	f8cd e124 	str.w	lr, [sp, #292]	; 0x124
    b5b2:	9346      	str	r3, [sp, #280]	; 0x118
    b5b4:	f8cd c120 	str.w	ip, [sp, #288]	; 0x120
    b5b8:	9747      	str	r7, [sp, #284]	; 0x11c
    b5ba:	9442      	str	r4, [sp, #264]	; 0x108
    b5bc:	9043      	str	r0, [sp, #268]	; 0x10c
    b5be:	9144      	str	r1, [sp, #272]	; 0x110
    b5c0:	9245      	str	r2, [sp, #276]	; 0x114
    b5c2:	9a00      	ldr	r2, [sp, #0]
    b5c4:	9801      	ldr	r0, [sp, #4]
        }
    #endif /* USE_SLOW_SHA256 */

        /* Add the working vars back into digest state[] */
        for (i = 0; i < 8; i++) {
            sha256->digest[i] += S[i];
    b5c6:	f85a 3f04 	ldr.w	r3, [sl, #4]!
    b5ca:	f852 1f04 	ldr.w	r1, [r2, #4]!
    b5ce:	440b      	add	r3, r1
    b5d0:	f8ca 3000 	str.w	r3, [sl]
        for (i = 0; i < 8; i++) {
    b5d4:	4582      	cmp	sl, r0
    b5d6:	d1f6      	bne.n	b5c6 <Transform_Sha256+0x2ea>

    #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SMALL_STACK_CACHE)
        XFREE(W, NULL, DYNAMIC_TYPE_TMP_BUFFER);
    #endif
        return 0;
    }
    b5d8:	2000      	movs	r0, #0
    b5da:	b04b      	add	sp, #300	; 0x12c
    b5dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b5e0:	00013e64 	.word	0x00013e64
    b5e4:	00013d64 	.word	0x00013d64

Disassembly of section .text.DRV_GMAC_Initialize%214:

0000b5e8 <DRV_GMAC_Initialize>:
 *                  It should be called to be able to schedule any MAC transmit or receive operation.
 *
 * Note:            Only one client per MAC supported. 
 *****************************************************************************/
SYS_MODULE_OBJ DRV_GMAC_Initialize(const SYS_MODULE_INDEX index, const SYS_MODULE_INIT * const init)
{
    b5e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b5ec:	b084      	sub	sp, #16
    if(macIx >= 0 && macIx < sizeof(_gmac_drv_dcpt)/sizeof(*_gmac_drv_dcpt))
    b5ee:	f241 0350 	movw	r3, #4176	; 0x1050
    b5f2:	4298      	cmp	r0, r3
    b5f4:	f040 8142 	bne.w	b87c <DRV_GMAC_Initialize+0x294>
		return SYS_MODULE_OBJ_INVALID;      // no such type supported
	}
   
    pMACDrv = _gmac_drv_dcpt + macIx;

	if(pMACDrv->sGmacData._macFlags._init != 0)
    b5f8:	4bb9      	ldr	r3, [pc, #740]	; (b8e0 <DRV_GMAC_Initialize+0x2f8>)
    b5fa:	7d9b      	ldrb	r3, [r3, #22]
    b5fc:	f013 0f01 	tst.w	r3, #1
    b600:	f040 8131 	bne.w	b866 <DRV_GMAC_Initialize+0x27e>
	{   // already initialized	
		return (SYS_MODULE_OBJ)pMACDrv;
	}
	    	
	if(pMACDrv->sGmacData._macFlags._open != 0)
    b604:	f013 0602 	ands.w	r6, r3, #2
    b608:	f040 813b 	bne.w	b882 <DRV_GMAC_Initialize+0x29a>
	const TCPIP_MAC_MODULE_CTRL* const macControl = ((TCPIP_MAC_INIT*)init)->macControl;	
    b60c:	684f      	ldr	r7, [r1, #4]
	{
		return SYS_MODULE_OBJ_INVALID;     // have a client connected
	}

	if(macControl->memH == 0)
    b60e:	68fb      	ldr	r3, [r7, #12]
    b610:	2b00      	cmp	r3, #0
    b612:	f000 8139 	beq.w	b888 <DRV_GMAC_Initialize+0x2a0>
    const TCPIP_MODULE_MAC_PIC32C_CONFIG* initData = (const TCPIP_MODULE_MAC_PIC32C_CONFIG*)((TCPIP_MAC_INIT*)init)->moduleData;
    b616:	688c      	ldr	r4, [r1, #8]
	{
		return SYS_MODULE_OBJ_INVALID;     // not possible without dynamic memory!
	}

	if(initData == 0)
    b618:	2c00      	cmp	r4, #0
    b61a:	f000 8138 	beq.w	b88e <DRV_GMAC_Initialize+0x2a6>
	{
		return SYS_MODULE_OBJ_INVALID;     // not possible without init data!
	}

	if(initData->pPhyBase == 0 || initData->pPhyInit == 0)
    b61e:	6a23      	ldr	r3, [r4, #32]
    b620:	2b00      	cmp	r3, #0
    b622:	f000 8137 	beq.w	b894 <DRV_GMAC_Initialize+0x2ac>
    b626:	6a63      	ldr	r3, [r4, #36]	; 0x24
    b628:	2b00      	cmp	r3, #0
    b62a:	f000 8136 	beq.w	b89a <DRV_GMAC_Initialize+0x2b2>
	{
		return SYS_MODULE_OBJ_INVALID;     // not possible without a PHY!
	}
	
	// init the MAC object
    memset(&pMACDrv->sGmacData, 0x0, sizeof(pMACDrv->sGmacData)); 
    b62e:	4dac      	ldr	r5, [pc, #688]	; (b8e0 <DRV_GMAC_Initialize+0x2f8>)
    b630:	22e4      	movs	r2, #228	; 0xe4
    b632:	2100      	movs	r1, #0
    b634:	f105 0014 	add.w	r0, r5, #20
    b638:	f016 faa0 	bl	21b7c <memset>
    pMACDrv->sGmacData.hPhyClient = DRV_HANDLE_INVALID;
    b63c:	f04f 33ff 	mov.w	r3, #4294967295
    b640:	612b      	str	r3, [r5, #16]
    pMACDrv->sGmacData.hPhySysObject = SYS_MODULE_OBJ_INVALID;
    b642:	60eb      	str	r3, [r5, #12]
    pMACDrv->sGmacData.sysStat = SYS_STATUS_UNINITIALIZED;
    b644:	2300      	movs	r3, #0
    b646:	752b      	strb	r3, [r5, #20]
	
    pMACDrv->sGmacData._macIx = macIx;
    b648:	606b      	str	r3, [r5, #4]
    pMACDrv->sGmacData._phyIx = macIx;    // use the same index for the associated PHY
    b64a:	60ab      	str	r3, [r5, #8]
    pMACDrv->sGmacData._macFlags._linkPrev = 0;	
    b64c:	f04f 0200 	mov.w	r2, #0
    b650:	f363 1204 	bfi	r2, r3, #4, #1
    b654:	75aa      	strb	r2, [r5, #22]

    // update interrupt source for GMAC priority queues
	DRV_PIC32CGMAC_LibSetInterruptSrc(pMACDrv);
    b656:	4628      	mov	r0, r5
    b658:	f016 f9e8 	bl	21a2c <DRV_PIC32CGMAC_LibSetInterruptSrc>
    // use initialization data
    pMACDrv->sGmacData._AllocH = macControl->memH;
    b65c:	68fb      	ldr	r3, [r7, #12]
    b65e:	61ab      	str	r3, [r5, #24]
    pMACDrv->sGmacData._callocF = macControl->callocF;
    b660:	687b      	ldr	r3, [r7, #4]
    b662:	61eb      	str	r3, [r5, #28]
    pMACDrv->sGmacData._freeF = macControl->freeF;
    b664:	68bb      	ldr	r3, [r7, #8]
    b666:	622b      	str	r3, [r5, #32]
    pMACDrv->sGmacData._dcptOffset = macControl->gapDcptOffset;
    b668:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
    b66c:	f8a5 30ec 	strh.w	r3, [r5, #236]	; 0xec


    pMACDrv->sGmacData.pktAllocF = macControl->pktAllocF;
    b670:	693b      	ldr	r3, [r7, #16]
    b672:	626b      	str	r3, [r5, #36]	; 0x24
    pMACDrv->sGmacData.pktFreeF = macControl->pktFreeF;
    b674:	697b      	ldr	r3, [r7, #20]
    b676:	62ab      	str	r3, [r5, #40]	; 0x28
    pMACDrv->sGmacData.pktAckF = macControl->pktAckF;
    b678:	69bb      	ldr	r3, [r7, #24]
    b67a:	62eb      	str	r3, [r5, #44]	; 0x2c

    pMACDrv->sGmacData._synchF = macControl->synchF;
    b67c:	69fb      	ldr	r3, [r7, #28]
    b67e:	632b      	str	r3, [r5, #48]	; 0x30
	
    pMACDrv->sGmacData._controlFlags = macControl->controlFlags;
    b680:	8efb      	ldrh	r3, [r7, #54]	; 0x36
    b682:	f8a5 30f4 	strh.w	r3, [r5, #244]	; 0xf4
    pMACDrv->sGmacData._dataOffset = (macControl->controlFlags & TCPIP_MAC_CONTROL_PAYLOAD_OFFSET_2) == 0 ? 0 : 2;
    b686:	f013 0f01 	tst.w	r3, #1
    b68a:	bf18      	it	ne
    b68c:	2602      	movne	r6, #2
    b68e:	f885 60f6 	strb.w	r6, [r5, #246]	; 0xf6
    pMACDrv->sGmacData._dataOffsetMask = (macControl->controlFlags & TCPIP_MAC_CONTROL_PAYLOAD_OFFSET_2) != 0 ? 0xfffffffc : 0xffffffff;
    b692:	8efb      	ldrh	r3, [r7, #54]	; 0x36
    b694:	f013 0f01 	tst.w	r3, #1
    b698:	bf14      	ite	ne
    b69a:	f06f 0303 	mvnne.w	r3, #3
    b69e:	f04f 33ff 	moveq.w	r3, #4294967295
    b6a2:	462e      	mov	r6, r5
    b6a4:	f8c5 30f0 	str.w	r3, [r5, #240]	; 0xf0
    pMACDrv->sGmacData._txDiscard = false;
    b6a8:	2300      	movs	r3, #0
    b6aa:	f885 30f7 	strb.w	r3, [r5, #247]	; 0xf7
	// copy the configuration data
	pMACDrv->sGmacData.gmacConfig = *initData;	
    b6ae:	35b8      	adds	r5, #184	; 0xb8
    b6b0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    b6b2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    b6b4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    b6b6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    b6b8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    b6ba:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    b6bc:	6823      	ldr	r3, [r4, #0]
    b6be:	602b      	str	r3, [r5, #0]
	
    DRV_GMAC_LibDescriptorsPoolAdd (pMACDrv, DRV_GMAC_DCPT_TYPE_RX);
    b6c0:	2101      	movs	r1, #1
    b6c2:	4630      	mov	r0, r6
    b6c4:	f015 f924 	bl	20910 <DRV_GMAC_LibDescriptorsPoolAdd>
    DRV_GMAC_LibDescriptorsPoolAdd (pMACDrv, DRV_GMAC_DCPT_TYPE_TX);
    b6c8:	2102      	movs	r1, #2
    b6ca:	4630      	mov	r0, r6
    b6cc:	f015 f920 	bl	20910 <DRV_GMAC_LibDescriptorsPoolAdd>
    
	for(queueIdx = GMAC_QUE_0; queueIdx < DRV_GMAC_NUMBER_OF_QUEUES; queueIdx++)
	{
		if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt < DRV_GMAC_MIN_TX_DESCRIPTORS)
    b6d0:	f8b6 30c8 	ldrh.w	r3, [r6, #200]	; 0xc8
    b6d4:	2b00      	cmp	r3, #0
    b6d6:	f000 80e3 	beq.w	b8a0 <DRV_GMAC_Initialize+0x2b8>
		{
			return SYS_MODULE_OBJ_INVALID; //return invalid than setting min dscp count
		}
        
        uint16_t rxBufferSize = pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].rxBufferSize;
    b6da:	f8b6 30cc 	ldrh.w	r3, [r6, #204]	; 0xcc

		if(rxBufferSize < DRV_GMAC_MIN_RX_SIZE)
    b6de:	2b3f      	cmp	r3, #63	; 0x3f
    b6e0:	f240 80e1 	bls.w	b8a6 <DRV_GMAC_Initialize+0x2be>
        if(rxBufferSize > TCPIP_GMAC_RX_MAX_FRAME)
        {   // no need to exceed the max allowed RX frame
            rxBufferSize = TCPIP_GMAC_RX_MAX_FRAME;
        }
        // GMAC RX buffer size needs to be multiple of 64
        rxBufferSize = ((rxBufferSize + 63) / 64) * 64;
    b6e4:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
    b6e8:	bf28      	it	cs
    b6ea:	f44f 63c0 	movcs.w	r3, #1536	; 0x600
    b6ee:	333f      	adds	r3, #63	; 0x3f
        pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].rxBufferSize = rxBufferSize;
    b6f0:	487b      	ldr	r0, [pc, #492]	; (b8e0 <DRV_GMAC_Initialize+0x2f8>)
        rxBufferSize = ((rxBufferSize + 63) / 64) * 64;
    b6f2:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
        pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].rxBufferSize = rxBufferSize;
    b6f6:	f8a0 30cc 	strh.w	r3, [r0, #204]	; 0xcc
	}
	
    if(!DRV_PIC32CGMAC_LibSetPriorityToQueueNum(pMACDrv))
    b6fa:	f016 fa6f 	bl	21bdc <DRV_PIC32CGMAC_LibSetPriorityToQueueNum>
    b6fe:	2800      	cmp	r0, #0
    b700:	f000 80d7 	beq.w	b8b2 <DRV_GMAC_Initialize+0x2ca>
    {
        return SYS_MODULE_OBJ_INVALID; //return invalid
    }
        
	//set the MAC address received from system config
	memcpy((pMACDrv->sGmacData.gmacConfig.macAddress.v), (macControl->ifPhyAddress.v),sizeof(macControl->ifPhyAddress));	
    b704:	4b76      	ldr	r3, [pc, #472]	; (b8e0 <DRV_GMAC_Initialize+0x2f8>)
    b706:	463a      	mov	r2, r7
    b708:	f852 0f38 	ldr.w	r0, [r2, #56]!
    b70c:	f8c3 00b8 	str.w	r0, [r3, #184]	; 0xb8
    b710:	8892      	ldrh	r2, [r2, #4]
    b712:	f8a3 20bc 	strh.w	r2, [r3, #188]	; 0xbc
	return (pMACDrv->sGmacData._synchF == 0) ? true : (*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_CREATE);
    b716:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    b718:	b12b      	cbz	r3, b726 <DRV_GMAC_Initialize+0x13e>
    b71a:	2101      	movs	r1, #1
    b71c:	4871      	ldr	r0, [pc, #452]	; (b8e4 <DRV_GMAC_Initialize+0x2fc>)
    b71e:	4798      	blx	r3
    b720:	2800      	cmp	r0, #0
    b722:	f000 80c3 	beq.w	b8ac <DRV_GMAC_Initialize+0x2c4>
	while(1)
	{
		uint32_t rxfilter= 0;

		// start the initialization sequence
		DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, NULL);
    b726:	4c6e      	ldr	r4, [pc, #440]	; (b8e0 <DRV_GMAC_Initialize+0x2f8>)
    b728:	2200      	movs	r2, #0
    b72a:	213f      	movs	r1, #63	; 0x3f
    b72c:	4620      	mov	r0, r4
    b72e:	f014 fdc1 	bl	202b4 <DRV_PIC32CGMAC_LibSysInt_Disable>
	const DRV_ETHPHY_OBJECT_BASE* pPhyBase;	
	int phyIx = pMACDrv->sGmacData._phyIx;
	TCPIP_MAC_RES   initRes;
	DRV_ETHPHY_RESULT   phyInitRes;	

	pPhyBase =  pMACDrv->sGmacData.gmacConfig.pPhyBase; 
    b732:	f8d4 50d8 	ldr.w	r5, [r4, #216]	; 0xd8

	hPhySysObject = pPhyBase->DRV_ETHPHY_Initialize(phyIx,  (SYS_MODULE_INIT *)pMACDrv->sGmacData.gmacConfig.pPhyInit);
    b736:	8926      	ldrh	r6, [r4, #8]
    b738:	682b      	ldr	r3, [r5, #0]
    b73a:	f8d4 10dc 	ldr.w	r1, [r4, #220]	; 0xdc
    b73e:	4630      	mov	r0, r6
    b740:	4798      	blx	r3
	if ( hPhySysObject == SYS_MODULE_OBJ_INVALID )
    b742:	f1b0 3fff 	cmp.w	r0, #4294967295
    b746:	f000 8093 	beq.w	b870 <DRV_GMAC_Initialize+0x288>
	{
		initRes = TCPIP_MAC_RES_PHY_INIT_FAIL;
		return initRes;
	}

	pMACDrv->sGmacData.hPhySysObject = hPhySysObject;
    b74a:	60e0      	str	r0, [r4, #12]
	hPhyClient = pPhyBase->DRV_ETHPHY_Open(phyIx, DRV_IO_INTENT_READWRITE);
    b74c:	696b      	ldr	r3, [r5, #20]
    b74e:	2103      	movs	r1, #3
    b750:	4630      	mov	r0, r6
    b752:	4798      	blx	r3
	if ( DRV_HANDLE_INVALID == hPhyClient )
    b754:	f1b0 3fff 	cmp.w	r0, #4294967295
    b758:	f000 808a 	beq.w	b870 <DRV_GMAC_Initialize+0x288>
	{
		initRes = TCPIP_MAC_RES_PHY_INIT_FAIL;
		return initRes;
	}
	
	pMACDrv->sGmacData.hPhyClient = hPhyClient;
    b75c:	4622      	mov	r2, r4
    b75e:	6120      	str	r0, [r4, #16]
	phySetup.phyAddress = pMACDrv->sGmacData.gmacConfig.pPhyInit->phyAddress;
    b760:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
    b764:	8919      	ldrh	r1, [r3, #8]
    b766:	9100      	str	r1, [sp, #0]
	phySetup.openFlags = pMACDrv->sGmacData.gmacConfig.ethFlags;
    b768:	f8b4 10d2 	ldrh.w	r1, [r4, #210]	; 0xd2
    b76c:	f8ad 1004 	strh.w	r1, [sp, #4]
	phySetup.configFlags = pMACDrv->sGmacData.gmacConfig.pPhyInit->phyFlags;
    b770:	7a99      	ldrb	r1, [r3, #10]
    b772:	f88d 1006 	strb.w	r1, [sp, #6]
	phySetup.macPauseType = DRV_GMAC_PAUSE_CPBL_MASK;
    b776:	210f      	movs	r1, #15
    b778:	f88d 1007 	strb.w	r1, [sp, #7]
	phySetup.resetFunction = pMACDrv->sGmacData.gmacConfig.pPhyInit->resetFunction;
    b77c:	691b      	ldr	r3, [r3, #16]
    b77e:	9302      	str	r3, [sp, #8]
		
	phyInitRes = pPhyBase->DRV_ETHPHY_Setup(hPhyClient, &phySetup, &pMACDrv->sGmacData._linkResFlags);
    b780:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    b782:	3234      	adds	r2, #52	; 0x34
    b784:	4669      	mov	r1, sp
    b786:	4798      	blx	r3
	
	if(phyInitRes < 0)
    b788:	2800      	cmp	r0, #0
    b78a:	db71      	blt.n	b870 <DRV_GMAC_Initialize+0x288>
		DRV_PIC32CGMAC_LibInit(pMACDrv);
    b78c:	4c54      	ldr	r4, [pc, #336]	; (b8e0 <DRV_GMAC_Initialize+0x2f8>)
    b78e:	4620      	mov	r0, r4
    b790:	f00d fee4 	bl	1955c <DRV_PIC32CGMAC_LibInit>
            hash.hash_value = -1; //Set 64-bit Hash value to all 1s, to receive all multi-cast
    b794:	f04f 32ff 	mov.w	r2, #4294967295
    b798:	f04f 33ff 	mov.w	r3, #4294967295
    b79c:	e9cd 2300 	strd	r2, r3, [sp]
            hash.calculate_hash = false; // No hash calculation; directly set hash register
    b7a0:	2300      	movs	r3, #0
    b7a2:	f88d 300c 	strb.w	r3, [sp, #12]
            DRV_PIC32CGMAC_LibRxFilterHash_Calculate(pMACDrv, &hash);
    b7a6:	4669      	mov	r1, sp
    b7a8:	4620      	mov	r0, r4
    b7aa:	f004 fac5 	bl	fd38 <DRV_PIC32CGMAC_LibRxFilterHash_Calculate>
		rxfilter = (uint32_t)(GMAC_REGS->GMAC_NCFGR) & (~GMAC_FILT_ALL_FILTERS); 
    b7ae:	4a4e      	ldr	r2, [pc, #312]	; (b8e8 <DRV_GMAC_Initialize+0x300>)
    b7b0:	6853      	ldr	r3, [r2, #4]
    b7b2:	f023 5310 	bic.w	r3, r3, #603979776	; 0x24000000
    b7b6:	f423 73fc 	bic.w	r3, r3, #504	; 0x1f8
		GMAC_REGS->GMAC_NCFGR  = (rxfilter|gmacRxFilt) ;
    b7ba:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    b7be:	6053      	str	r3, [r2, #4]
        if(DRV_PIC32CGMAC_LibRxQueFilterInit(pMACDrv) != DRV_PIC32CGMAC_RES_OK)
    b7c0:	4620      	mov	r0, r4
    b7c2:	f016 fcb2 	bl	2212a <DRV_PIC32CGMAC_LibRxQueFilterInit>
    b7c6:	2800      	cmp	r0, #0
    b7c8:	d152      	bne.n	b870 <DRV_GMAC_Initialize+0x288>
		if(DRV_PIC32CGMAC_LibRxInit(pMACDrv) != DRV_PIC32CGMAC_RES_OK)
    b7ca:	4845      	ldr	r0, [pc, #276]	; (b8e0 <DRV_GMAC_Initialize+0x2f8>)
    b7cc:	f009 ffd4 	bl	15778 <DRV_PIC32CGMAC_LibRxInit>
    b7d0:	2800      	cmp	r0, #0
    b7d2:	d14d      	bne.n	b870 <DRV_GMAC_Initialize+0x288>
		if(DRV_PIC32CGMAC_LibTxInit(pMACDrv) != DRV_PIC32CGMAC_RES_OK)
    b7d4:	4842      	ldr	r0, [pc, #264]	; (b8e0 <DRV_GMAC_Initialize+0x2f8>)
    b7d6:	f00e f833 	bl	19840 <DRV_PIC32CGMAC_LibTxInit>
    b7da:	2800      	cmp	r0, #0
    b7dc:	d148      	bne.n	b870 <DRV_GMAC_Initialize+0x288>
            if(DRV_PIC32CGMAC_LibInitTransfer(pMACDrv,queueIdx) != DRV_PIC32CGMAC_RES_OK)
    b7de:	2100      	movs	r1, #0
    b7e0:	483f      	ldr	r0, [pc, #252]	; (b8e0 <DRV_GMAC_Initialize+0x2f8>)
    b7e2:	f00c fc75 	bl	180d0 <DRV_PIC32CGMAC_LibInitTransfer>
    b7e6:	4606      	mov	r6, r0
    b7e8:	2800      	cmp	r0, #0
    b7ea:	d165      	bne.n	b8b8 <DRV_GMAC_Initialize+0x2d0>
        DRV_PIC32CGMAC_LibSysIntStatus_Clear(pMACDrv, GMAC_ALL_QUE_MASK);
    b7ec:	4d3c      	ldr	r5, [pc, #240]	; (b8e0 <DRV_GMAC_Initialize+0x2f8>)
    b7ee:	213f      	movs	r1, #63	; 0x3f
    b7f0:	4628      	mov	r0, r5
    b7f2:	f014 fa0f 	bl	1fc14 <DRV_PIC32CGMAC_LibSysIntStatus_Clear>
        DRV_PIC32CGMAC_LibSysInt_Enable(pMACDrv, GMAC_ALL_QUE_MASK);
    b7f6:	213f      	movs	r1, #63	; 0x3f
    b7f8:	4628      	mov	r0, r5
    b7fa:	f014 fa1f 	bl	1fc3c <DRV_PIC32CGMAC_LibSysInt_Enable>
		DRV_PIC32CGMAC_LibTransferEnable(pMACDrv); //enable Transmit and Receive of GMAC
    b7fe:	4628      	mov	r0, r5
    b800:	f015 f876 	bl	208f0 <DRV_PIC32CGMAC_LibTransferEnable>
        if(DRV_GMAC_EventInit((DRV_HANDLE)pMACDrv, macControl->eventF, macControl->eventParam) != TCPIP_MAC_RES_OK)
    b804:	462c      	mov	r4, r5
	if(_hEventMac == hMac)
    b806:	4b39      	ldr	r3, [pc, #228]	; (b8ec <DRV_GMAC_Initialize+0x304>)
    b808:	681b      	ldr	r3, [r3, #0]
    b80a:	42ab      	cmp	r3, r5
    b80c:	d01c      	beq.n	b848 <DRV_GMAC_Initialize+0x260>
	else if(_hEventMac != 0)
    b80e:	bb7b      	cbnz	r3, b870 <DRV_GMAC_Initialize+0x288>
        if(DRV_GMAC_EventInit((DRV_HANDLE)pMACDrv, macControl->eventF, macControl->eventParam) != TCPIP_MAC_RES_OK)
    b810:	f8d7 8020 	ldr.w	r8, [r7, #32]
    b814:	6a7f      	ldr	r7, [r7, #36]	; 0x24
    DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, NULL);
    b816:	4d32      	ldr	r5, [pc, #200]	; (b8e0 <DRV_GMAC_Initialize+0x2f8>)
    b818:	2200      	movs	r2, #0
    b81a:	213f      	movs	r1, #63	; 0x3f
    b81c:	4628      	mov	r0, r5
    b81e:	f014 fd49 	bl	202b4 <DRV_PIC32CGMAC_LibSysInt_Disable>
    DRV_PIC32CGMAC_LibSysIntStatus_Clear(pMACDrv, GMAC_ALL_QUE_MASK);
    b822:	213f      	movs	r1, #63	; 0x3f
    b824:	4628      	mov	r0, r5
    b826:	f014 f9f5 	bl	1fc14 <DRV_PIC32CGMAC_LibSysIntStatus_Clear>
	pDcpt->_TcpEnabledEvents = pDcpt->_TcpPendingEvents = TCPIP_MAC_EV_NONE;
    b82a:	2300      	movs	r3, #0
    b82c:	f8a5 304e 	strh.w	r3, [r5, #78]	; 0x4e
    b830:	f8a5 304c 	strh.w	r3, [r5, #76]	; 0x4c
	pDcpt->_EthEnabledEvents = pDcpt->_EthPendingEvents = 0;
    b834:	f8a5 3052 	strh.w	r3, [r5, #82]	; 0x52
    b838:	f8a5 3050 	strh.w	r3, [r5, #80]	; 0x50
	pDcpt->_TcpNotifyFnc = eventF;
    b83c:	f8c5 8054 	str.w	r8, [r5, #84]	; 0x54
	pDcpt->_TcpNotifyParam = eventParam;
    b840:	65af      	str	r7, [r5, #88]	; 0x58
	_hEventMac = hMac;
    b842:	4b2a      	ldr	r3, [pc, #168]	; (b8ec <DRV_GMAC_Initialize+0x304>)
    b844:	601c      	str	r4, [r3, #0]
	if(initRes != TCPIP_MAC_RES_OK)
    b846:	b99e      	cbnz	r6, b870 <DRV_GMAC_Initialize+0x288>
	pMACDrv->sGmacData._macFlags._init = 1;	
    b848:	4b25      	ldr	r3, [pc, #148]	; (b8e0 <DRV_GMAC_Initialize+0x2f8>)
    b84a:	7d9a      	ldrb	r2, [r3, #22]
    b84c:	f042 0201 	orr.w	r2, r2, #1
    b850:	759a      	strb	r2, [r3, #22]
	pMACDrv->sGmacData.sysStat = SYS_STATUS_BUSY;
    b852:	2201      	movs	r2, #1
    b854:	751a      	strb	r2, [r3, #20]
    pMACDrv->sGmacData._rxStat.nRxErrorPackets = 0;
    b856:	2200      	movs	r2, #0
    b858:	671a      	str	r2, [r3, #112]	; 0x70
    pMACDrv->sGmacData._rxStat.nRxFragmentErrors = -1;
    b85a:	f04f 31ff 	mov.w	r1, #4294967295
    b85e:	6759      	str	r1, [r3, #116]	; 0x74
    pMACDrv->sGmacData._rxStat.nRxPendBuffers = 0;
    b860:	669a      	str	r2, [r3, #104]	; 0x68
    pMACDrv->sGmacData._rxStat.nRxSchedBuffers = 0;
    b862:	66da      	str	r2, [r3, #108]	; 0x6c
	return (SYS_MODULE_OBJ)pMACDrv;
    b864:	e000      	b.n	b868 <DRV_GMAC_Initialize+0x280>
		return (SYS_MODULE_OBJ)pMACDrv;
    b866:	4c1e      	ldr	r4, [pc, #120]	; (b8e0 <DRV_GMAC_Initialize+0x2f8>)
}
    b868:	4620      	mov	r0, r4
    b86a:	b004      	add	sp, #16
    b86c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		_MACDeinit(pMACDrv);
    b870:	481b      	ldr	r0, [pc, #108]	; (b8e0 <DRV_GMAC_Initialize+0x2f8>)
    b872:	f006 fa2f 	bl	11cd4 <_MACDeinit>
		return SYS_MODULE_OBJ_INVALID;
    b876:	f04f 34ff 	mov.w	r4, #4294967295
    b87a:	e7f5      	b.n	b868 <DRV_GMAC_Initialize+0x280>
		return SYS_MODULE_OBJ_INVALID;      // no such type supported
    b87c:	f04f 34ff 	mov.w	r4, #4294967295
    b880:	e7f2      	b.n	b868 <DRV_GMAC_Initialize+0x280>
		return SYS_MODULE_OBJ_INVALID;     // have a client connected
    b882:	f04f 34ff 	mov.w	r4, #4294967295
    b886:	e7ef      	b.n	b868 <DRV_GMAC_Initialize+0x280>
		return SYS_MODULE_OBJ_INVALID;     // not possible without dynamic memory!
    b888:	f04f 34ff 	mov.w	r4, #4294967295
    b88c:	e7ec      	b.n	b868 <DRV_GMAC_Initialize+0x280>
		return SYS_MODULE_OBJ_INVALID;     // not possible without init data!
    b88e:	f04f 34ff 	mov.w	r4, #4294967295
    b892:	e7e9      	b.n	b868 <DRV_GMAC_Initialize+0x280>
		return SYS_MODULE_OBJ_INVALID;     // not possible without a PHY!
    b894:	f04f 34ff 	mov.w	r4, #4294967295
    b898:	e7e6      	b.n	b868 <DRV_GMAC_Initialize+0x280>
    b89a:	f04f 34ff 	mov.w	r4, #4294967295
    b89e:	e7e3      	b.n	b868 <DRV_GMAC_Initialize+0x280>
			return SYS_MODULE_OBJ_INVALID; //return invalid than setting min dscp count
    b8a0:	f04f 34ff 	mov.w	r4, #4294967295
    b8a4:	e7e0      	b.n	b868 <DRV_GMAC_Initialize+0x280>
			return SYS_MODULE_OBJ_INVALID; //return invalid than setting min Rx buffer size
    b8a6:	f04f 34ff 	mov.w	r4, #4294967295
    b8aa:	e7dd      	b.n	b868 <DRV_GMAC_Initialize+0x280>
        return SYS_MODULE_OBJ_INVALID;     // failed to create synch lock
    b8ac:	f04f 34ff 	mov.w	r4, #4294967295
    b8b0:	e7da      	b.n	b868 <DRV_GMAC_Initialize+0x280>
        return SYS_MODULE_OBJ_INVALID; //return invalid
    b8b2:	f04f 34ff 	mov.w	r4, #4294967295
    b8b6:	e7d7      	b.n	b868 <DRV_GMAC_Initialize+0x280>
        DRV_PIC32CGMAC_LibSysIntStatus_Clear(pMACDrv, GMAC_ALL_QUE_MASK);
    b8b8:	4d09      	ldr	r5, [pc, #36]	; (b8e0 <DRV_GMAC_Initialize+0x2f8>)
    b8ba:	213f      	movs	r1, #63	; 0x3f
    b8bc:	4628      	mov	r0, r5
    b8be:	f014 f9a9 	bl	1fc14 <DRV_PIC32CGMAC_LibSysIntStatus_Clear>
        DRV_PIC32CGMAC_LibSysInt_Enable(pMACDrv, GMAC_ALL_QUE_MASK);
    b8c2:	213f      	movs	r1, #63	; 0x3f
    b8c4:	4628      	mov	r0, r5
    b8c6:	f014 f9b9 	bl	1fc3c <DRV_PIC32CGMAC_LibSysInt_Enable>
		DRV_PIC32CGMAC_LibTransferEnable(pMACDrv); //enable Transmit and Receive of GMAC
    b8ca:	4628      	mov	r0, r5
    b8cc:	f015 f810 	bl	208f0 <DRV_PIC32CGMAC_LibTransferEnable>
        if(DRV_GMAC_EventInit((DRV_HANDLE)pMACDrv, macControl->eventF, macControl->eventParam) != TCPIP_MAC_RES_OK)
    b8d0:	462c      	mov	r4, r5
	if(_hEventMac == hMac)
    b8d2:	4b06      	ldr	r3, [pc, #24]	; (b8ec <DRV_GMAC_Initialize+0x304>)
    b8d4:	681b      	ldr	r3, [r3, #0]
    b8d6:	42ab      	cmp	r3, r5
    b8d8:	d0ca      	beq.n	b870 <DRV_GMAC_Initialize+0x288>
                initRes = TCPIP_MAC_RES_INIT_FAIL;
    b8da:	f06f 0602 	mvn.w	r6, #2
    b8de:	e796      	b.n	b80e <DRV_GMAC_Initialize+0x226>
    b8e0:	2000dab8 	.word	0x2000dab8
    b8e4:	2000db18 	.word	0x2000db18
    b8e8:	42000800 	.word	0x42000800
    b8ec:	2000df14 	.word	0x2000df14

Disassembly of section .text.TCPIP_TCP_FifoSizeAdjust%215:

0000b8f0 <TCPIP_TCP_FifoSizeAdjust>:
{
    b8f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b8f4:	b085      	sub	sp, #20
    if((vFlags & (TCP_ADJUST_TX_ONLY | TCP_ADJUST_RX_ONLY)) == (TCP_ADJUST_TX_ONLY | TCP_ADJUST_RX_ONLY))
    b8f6:	f003 0430 	and.w	r4, r3, #48	; 0x30
    b8fa:	2c30      	cmp	r4, #48	; 0x30
    b8fc:	f000 80d2 	beq.w	baa4 <TCPIP_TCP_FifoSizeAdjust+0x1b4>
    b900:	461f      	mov	r7, r3
    b902:	4615      	mov	r5, r2
    b904:	460e      	mov	r6, r1
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
    b906:	f014 f9d5 	bl	1fcb4 <_TcpSocketChk>
    if(pSkt == 0)
    b90a:	4604      	mov	r4, r0
    b90c:	2800      	cmp	r0, #0
    b90e:	f000 80cb 	beq.w	baa8 <TCPIP_TCP_FifoSizeAdjust+0x1b8>
    if(wMinTXSize < TCP_MIN_TX_BUFF_SIZE)
    b912:	2d19      	cmp	r5, #25
    b914:	bf38      	it	cc
    b916:	2519      	movcc	r5, #25
    oldTxSize = pSkt->txEnd - pSkt->txStart -1;
    b918:	6843      	ldr	r3, [r0, #4]
    b91a:	6802      	ldr	r2, [r0, #0]
    b91c:	1a9b      	subs	r3, r3, r2
    b91e:	3b01      	subs	r3, #1
    b920:	b29b      	uxth	r3, r3
    oldRxSize = pSkt->rxEnd - pSkt->rxStart;
    b922:	6982      	ldr	r2, [r0, #24]
    b924:	6941      	ldr	r1, [r0, #20]
    b926:	1a52      	subs	r2, r2, r1
    b928:	fa1f f982 	uxth.w	r9, r2
    if((vFlags & TCP_ADJUST_TX_ONLY) != 0)
    b92c:	f017 0f10 	tst.w	r7, #16
    b930:	d121      	bne.n	b976 <TCPIP_TCP_FifoSizeAdjust+0x86>
    b932:	2e19      	cmp	r6, #25
    b934:	bf38      	it	cc
    b936:	2619      	movcc	r6, #25
    else if((vFlags & TCP_ADJUST_RX_ONLY) != 0)
    b938:	f017 0f20 	tst.w	r7, #32
    b93c:	d121      	bne.n	b982 <TCPIP_TCP_FifoSizeAdjust+0x92>
    else if(oldTxSize + oldRxSize > wMinRXSize + wMinTXSize)
    b93e:	fa13 f282 	uxtah	r2, r3, r2
    b942:	1971      	adds	r1, r6, r5
    b944:	428a      	cmp	r2, r1
    b946:	dd17      	ble.n	b978 <TCPIP_TCP_FifoSizeAdjust+0x88>
        uint16_t leftSpace = (oldTxSize + oldRxSize) - (wMinRXSize + wMinTXSize);
    b948:	eba9 0201 	sub.w	r2, r9, r1
    b94c:	441a      	add	r2, r3
    b94e:	b292      	uxth	r2, r2
        if((vFlags & equalMask) == 0 || (vFlags & equalMask) == equalMask)
    b950:	f017 0103 	ands.w	r1, r7, #3
    b954:	d008      	beq.n	b968 <TCPIP_TCP_FifoSizeAdjust+0x78>
    b956:	2903      	cmp	r1, #3
    b958:	d006      	beq.n	b968 <TCPIP_TCP_FifoSizeAdjust+0x78>
        else if((vFlags & equalMask) == TCP_ADJUST_GIVE_REST_TO_TX)
    b95a:	2902      	cmp	r1, #2
            wMinTXSize += leftSpace;
    b95c:	bf07      	ittee	eq
    b95e:	18ad      	addeq	r5, r5, r2
    b960:	b2ad      	uxtheq	r5, r5
            wMinRXSize += leftSpace;
    b962:	18b6      	addne	r6, r6, r2
    b964:	b2b6      	uxthne	r6, r6
    b966:	e007      	b.n	b978 <TCPIP_TCP_FifoSizeAdjust+0x88>
            wMinRXSize += (leftSpace + 1) >> 1;
    b968:	3201      	adds	r2, #1
    b96a:	0852      	lsrs	r2, r2, #1
    b96c:	4416      	add	r6, r2
    b96e:	b2b6      	uxth	r6, r6
            wMinTXSize += (leftSpace +1) >> 1;
    b970:	4415      	add	r5, r2
    b972:	b2ad      	uxth	r5, r5
    b974:	e000      	b.n	b978 <TCPIP_TCP_FifoSizeAdjust+0x88>
        wMinRXSize = oldRxSize;
    b976:	464e      	mov	r6, r9
    if(wMinTXSize >= oldTxSize)
    b978:	429d      	cmp	r5, r3
    b97a:	d203      	bcs.n	b984 <TCPIP_TCP_FifoSizeAdjust+0x94>
        diffChange = oldTxSize - wMinTXSize;
    b97c:	1b5b      	subs	r3, r3, r5
    b97e:	b29b      	uxth	r3, r3
    b980:	e002      	b.n	b988 <TCPIP_TCP_FifoSizeAdjust+0x98>
        wMinTXSize = oldTxSize;
    b982:	461d      	mov	r5, r3
        diffChange = wMinTXSize - oldTxSize;
    b984:	1aeb      	subs	r3, r5, r3
    b986:	b29b      	uxth	r3, r3
    if(diffChange >= TCP_MIN_BUFF_CHANGE)
    b988:	2b1f      	cmp	r3, #31
    b98a:	d908      	bls.n	b99e <TCPIP_TCP_FifoSizeAdjust+0xae>
        newTxBuff = (uint8_t*)TCPIP_HEAP_Malloc(tcpHeapH, wMinTXSize + 1);
    b98c:	4b93      	ldr	r3, [pc, #588]	; (bbdc <TCPIP_TCP_FifoSizeAdjust+0x2ec>)
    b98e:	6818      	ldr	r0, [r3, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
    b990:	6843      	ldr	r3, [r0, #4]
    b992:	1c69      	adds	r1, r5, #1
    b994:	4798      	blx	r3
        if(newTxBuff == 0)
    b996:	4680      	mov	r8, r0
    b998:	b918      	cbnz	r0, b9a2 <TCPIP_TCP_FifoSizeAdjust+0xb2>
            return false;
    b99a:	2000      	movs	r0, #0
    b99c:	e0b9      	b.n	bb12 <TCPIP_TCP_FifoSizeAdjust+0x222>
        newTxBuff = 0;
    b99e:	f04f 0800 	mov.w	r8, #0
    if(wMinRXSize >= oldRxSize)
    b9a2:	45b1      	cmp	r9, r6
        diffChange = wMinRXSize - oldRxSize;
    b9a4:	bf94      	ite	ls
    b9a6:	eba6 0909 	subls.w	r9, r6, r9
        diffChange = oldRxSize - wMinRXSize;
    b9aa:	eba9 0906 	subhi.w	r9, r9, r6
    b9ae:	fa1f f989 	uxth.w	r9, r9
    if(diffChange >= TCP_MIN_BUFF_CHANGE)
    b9b2:	f1b9 0f1f 	cmp.w	r9, #31
    b9b6:	d90d      	bls.n	b9d4 <TCPIP_TCP_FifoSizeAdjust+0xe4>
        newRxBuff = (uint8_t*)TCPIP_HEAP_Malloc(tcpHeapH, wMinRXSize + 1);
    b9b8:	4b88      	ldr	r3, [pc, #544]	; (bbdc <TCPIP_TCP_FifoSizeAdjust+0x2ec>)
    b9ba:	6818      	ldr	r0, [r3, #0]
    b9bc:	6843      	ldr	r3, [r0, #4]
    b9be:	1c71      	adds	r1, r6, #1
    b9c0:	4798      	blx	r3
        if(newRxBuff == 0)
    b9c2:	4682      	mov	sl, r0
    b9c4:	b940      	cbnz	r0, b9d8 <TCPIP_TCP_FifoSizeAdjust+0xe8>
            TCPIP_HEAP_Free(tcpHeapH, newTxBuff);
    b9c6:	4b85      	ldr	r3, [pc, #532]	; (bbdc <TCPIP_TCP_FifoSizeAdjust+0x2ec>)
    b9c8:	6818      	ldr	r0, [r3, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
    b9ca:	68c3      	ldr	r3, [r0, #12]
    b9cc:	4641      	mov	r1, r8
    b9ce:	4798      	blx	r3
            return false;
    b9d0:	2000      	movs	r0, #0
    b9d2:	e09e      	b.n	bb12 <TCPIP_TCP_FifoSizeAdjust+0x222>
        newRxBuff = 0;
    b9d4:	f04f 0a00 	mov.w	sl, #0
    while(newTxBuff != 0)
    b9d8:	f1b8 0f00 	cmp.w	r8, #0
    b9dc:	f000 80aa 	beq.w	bb34 <TCPIP_TCP_FifoSizeAdjust+0x244>
        if((vFlags & TCP_ADJUST_PRESERVE_TX) != 0)
    b9e0:	f017 0f08 	tst.w	r7, #8
    b9e4:	f000 80b7 	beq.w	bb56 <TCPIP_TCP_FifoSizeAdjust+0x266>
            txHead = pSkt->txHead;
    b9e8:	68a3      	ldr	r3, [r4, #8]
            if(txHead < pSkt->txTail)
    b9ea:	68e1      	ldr	r1, [r4, #12]
    b9ec:	4299      	cmp	r1, r3
    b9ee:	d925      	bls.n	ba3c <TCPIP_TCP_FifoSizeAdjust+0x14c>
                pendTxEnd = pSkt->txEnd - pSkt->txTail;
    b9f0:	6862      	ldr	r2, [r4, #4]
    b9f2:	1a52      	subs	r2, r2, r1
    b9f4:	b292      	uxth	r2, r2
    b9f6:	9201      	str	r2, [sp, #4]
                pendTxBeg = txHead - pSkt->txStart;
    b9f8:	f8d4 b000 	ldr.w	fp, [r4]
    b9fc:	eba3 090b 	sub.w	r9, r3, fp
    ba00:	fa1f f989 	uxth.w	r9, r9
            if((pendTxEnd + pendTxBeg) != 0)
    ba04:	9a01      	ldr	r2, [sp, #4]
    ba06:	eb12 0309 	adds.w	r3, r2, r9
    ba0a:	f000 80e1 	beq.w	bbd0 <TCPIP_TCP_FifoSizeAdjust+0x2e0>
                if(pendTxEnd + pendTxBeg > wMinTXSize)
    ba0e:	42ab      	cmp	r3, r5
    ba10:	f300 8085 	bgt.w	bb1e <TCPIP_TCP_FifoSizeAdjust+0x22e>
                if(pendTxEnd)
    ba14:	b9ea      	cbnz	r2, ba52 <TCPIP_TCP_FifoSizeAdjust+0x162>
                if(pendTxBeg)
    ba16:	f1b9 0f00 	cmp.w	r9, #0
    ba1a:	d11e      	bne.n	ba5a <TCPIP_TCP_FifoSizeAdjust+0x16a>
                txUnackOffs = pSkt->txUnackedTail - pSkt->txTail;
    ba1c:	6922      	ldr	r2, [r4, #16]
    ba1e:	68e3      	ldr	r3, [r4, #12]
    ba20:	eba2 0b03 	sub.w	fp, r2, r3
    ba24:	fa1f fb8b 	uxth.w	fp, fp
                if(pSkt->txUnackedTail < pSkt->txTail)
    ba28:	429a      	cmp	r2, r3
    ba2a:	f080 8099 	bcs.w	bb60 <TCPIP_TCP_FifoSizeAdjust+0x270>
                    txUnackOffs += pSkt->txEnd - pSkt->txStart;
    ba2e:	6863      	ldr	r3, [r4, #4]
    ba30:	6822      	ldr	r2, [r4, #0]
    ba32:	1a9b      	subs	r3, r3, r2
    ba34:	449b      	add	fp, r3
    ba36:	fa1f fb8b 	uxth.w	fp, fp
    ba3a:	e091      	b.n	bb60 <TCPIP_TCP_FifoSizeAdjust+0x270>
            else if(txHead > pSkt->txTail)
    ba3c:	4299      	cmp	r1, r3
    ba3e:	f080 80c1 	bcs.w	bbc4 <TCPIP_TCP_FifoSizeAdjust+0x2d4>
                pendTxBeg = txHead - pSkt->txTail;
    ba42:	eba3 0901 	sub.w	r9, r3, r1
    ba46:	fa1f f989 	uxth.w	r9, r9
                srcOffs = pSkt->txTail;
    ba4a:	468b      	mov	fp, r1
                pendTxEnd = 0;
    ba4c:	2300      	movs	r3, #0
    ba4e:	9301      	str	r3, [sp, #4]
    ba50:	e7d8      	b.n	ba04 <TCPIP_TCP_FifoSizeAdjust+0x114>
                    memcpy(newTxBuff, pSkt->txTail, pendTxEnd);
    ba52:	4640      	mov	r0, r8
    ba54:	f015 fb04 	bl	21060 <memcpy>
    ba58:	e7dd      	b.n	ba16 <TCPIP_TCP_FifoSizeAdjust+0x126>
                    memcpy(newTxBuff + pendTxEnd,  srcOffs, pendTxBeg);
    ba5a:	464a      	mov	r2, r9
    ba5c:	4659      	mov	r1, fp
    ba5e:	9b01      	ldr	r3, [sp, #4]
    ba60:	eb08 0003 	add.w	r0, r8, r3
    ba64:	f015 fafc 	bl	21060 <memcpy>
    ba68:	e7d8      	b.n	ba1c <TCPIP_TCP_FifoSizeAdjust+0x12c>
    txUnackOffs = 0;
    ba6a:	f04f 0b00 	mov.w	fp, #0
    pendTxEnd = pendTxBeg = 0;
    ba6e:	46d9      	mov	r9, fp
    ba70:	f8cd b004 	str.w	fp, [sp, #4]
    ba74:	e077      	b.n	bb66 <TCPIP_TCP_FifoSizeAdjust+0x276>
            else if(rxHead < pSkt->rxTail)
    ba76:	42b9      	cmp	r1, r7
    ba78:	d94e      	bls.n	bb18 <TCPIP_TCP_FifoSizeAdjust+0x228>
                avlblRxEnd = pSkt->rxEnd + 1 - pSkt->rxTail;
    ba7a:	69a3      	ldr	r3, [r4, #24]
    ba7c:	3301      	adds	r3, #1
    ba7e:	1a5b      	subs	r3, r3, r1
    ba80:	b29b      	uxth	r3, r3
    ba82:	9302      	str	r3, [sp, #8]
                avlblRxBeg = rxHead - pSkt->rxStart;
    ba84:	6963      	ldr	r3, [r4, #20]
    ba86:	9303      	str	r3, [sp, #12]
    ba88:	1aff      	subs	r7, r7, r3
    ba8a:	b2bf      	uxth	r7, r7
                srcOffs = pSkt->rxStart;
    ba8c:	e087      	b.n	bb9e <TCPIP_TCP_FifoSizeAdjust+0x2ae>
                    memcpy(newRxBuff, pSkt->rxTail, avlblRxEnd);
    ba8e:	4650      	mov	r0, sl
    ba90:	f015 fae6 	bl	21060 <memcpy>
    ba94:	e08b      	b.n	bbae <TCPIP_TCP_FifoSizeAdjust+0x2be>
            _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
    ba96:	2201      	movs	r2, #1
    ba98:	2110      	movs	r1, #16
    ba9a:	4620      	mov	r0, r4
    ba9c:	f7fb faf4 	bl	7088 <_TcpSend>
    return true;
    baa0:	2001      	movs	r0, #1
    baa2:	e036      	b.n	bb12 <TCPIP_TCP_FifoSizeAdjust+0x222>
        return false;
    baa4:	2000      	movs	r0, #0
    baa6:	e034      	b.n	bb12 <TCPIP_TCP_FifoSizeAdjust+0x222>
        return false;
    baa8:	2000      	movs	r0, #0
    baaa:	e032      	b.n	bb12 <TCPIP_TCP_FifoSizeAdjust+0x222>
    avlblRxEnd = avlblRxBeg = 0;
    baac:	2700      	movs	r7, #0
    baae:	9702      	str	r7, [sp, #8]
    if(newTxBuff)
    bab0:	f1b8 0f00 	cmp.w	r8, #0
    bab4:	d04a      	beq.n	bb4c <TCPIP_TCP_FifoSizeAdjust+0x25c>
        TCPIP_HEAP_Free(tcpHeapH, (void*)pSkt->txStart);
    bab6:	4b49      	ldr	r3, [pc, #292]	; (bbdc <TCPIP_TCP_FifoSizeAdjust+0x2ec>)
    bab8:	6818      	ldr	r0, [r3, #0]
    baba:	68c3      	ldr	r3, [r0, #12]
    babc:	6821      	ldr	r1, [r4, #0]
    babe:	4798      	blx	r3
        pSkt->txStart =  newTxBuff;
    bac0:	f8c4 8000 	str.w	r8, [r4]
        pSkt->txEnd = newTxBuff + wMinTXSize + 1;
    bac4:	3501      	adds	r5, #1
    bac6:	4445      	add	r5, r8
    bac8:	6065      	str	r5, [r4, #4]
        pSkt->txTail = pSkt->txStart;
    baca:	f8c4 800c 	str.w	r8, [r4, #12]
        pSkt->txHead = pSkt->txStart + (pendTxEnd + pendTxBeg);
    bace:	9b01      	ldr	r3, [sp, #4]
    bad0:	444b      	add	r3, r9
    bad2:	4443      	add	r3, r8
    bad4:	60a3      	str	r3, [r4, #8]
        pSkt->txUnackedTail = pSkt->txTail + txUnackOffs;
    bad6:	eb08 030b 	add.w	r3, r8, fp
    bada:	6123      	str	r3, [r4, #16]
        _TCPSetHalfFlushFlag(pSkt);
    badc:	4620      	mov	r0, r4
    bade:	f012 f8b9 	bl	1dc54 <_TCPSetHalfFlushFlag>
    if(newRxBuff)
    bae2:	f1ba 0f00 	cmp.w	sl, #0
    bae6:	d00f      	beq.n	bb08 <TCPIP_TCP_FifoSizeAdjust+0x218>
        TCPIP_HEAP_Free(tcpHeapH, (void*)pSkt->rxStart);
    bae8:	4b3c      	ldr	r3, [pc, #240]	; (bbdc <TCPIP_TCP_FifoSizeAdjust+0x2ec>)
    baea:	6818      	ldr	r0, [r3, #0]
    baec:	68c3      	ldr	r3, [r0, #12]
    baee:	6961      	ldr	r1, [r4, #20]
    baf0:	4798      	blx	r3
        pSkt->rxStart = newRxBuff;
    baf2:	f8c4 a014 	str.w	sl, [r4, #20]
        pSkt->rxEnd = newRxBuff + wMinRXSize;
    baf6:	4456      	add	r6, sl
    baf8:	61a6      	str	r6, [r4, #24]
        pSkt->rxTail = pSkt->rxStart;
    bafa:	f8c4 a020 	str.w	sl, [r4, #32]
        pSkt->rxHead = pSkt->rxStart + (avlblRxEnd + avlblRxBeg);
    bafe:	9b02      	ldr	r3, [sp, #8]
    bb00:	443b      	add	r3, r7
    bb02:	461f      	mov	r7, r3
    bb04:	4457      	add	r7, sl
    bb06:	61e7      	str	r7, [r4, #28]
        if(pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED)
    bb08:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
    bb0c:	2b03      	cmp	r3, #3
    bb0e:	d0c2      	beq.n	ba96 <TCPIP_TCP_FifoSizeAdjust+0x1a6>
    return true;
    bb10:	2001      	movs	r0, #1
}
    bb12:	b005      	add	sp, #20
    bb14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    avlblRxEnd = avlblRxBeg = 0;
    bb18:	2700      	movs	r7, #0
    bb1a:	9702      	str	r7, [sp, #8]
    bb1c:	e7c8      	b.n	bab0 <TCPIP_TCP_FifoSizeAdjust+0x1c0>
        TCPIP_HEAP_Free(tcpHeapH, newRxBuff);
    bb1e:	4c2f      	ldr	r4, [pc, #188]	; (bbdc <TCPIP_TCP_FifoSizeAdjust+0x2ec>)
    bb20:	6820      	ldr	r0, [r4, #0]
    bb22:	68c3      	ldr	r3, [r0, #12]
    bb24:	4651      	mov	r1, sl
    bb26:	4798      	blx	r3
        TCPIP_HEAP_Free(tcpHeapH, newTxBuff);
    bb28:	6820      	ldr	r0, [r4, #0]
    bb2a:	68c3      	ldr	r3, [r0, #12]
    bb2c:	4641      	mov	r1, r8
    bb2e:	4798      	blx	r3
        return false;
    bb30:	2000      	movs	r0, #0
    bb32:	e7ee      	b.n	bb12 <TCPIP_TCP_FifoSizeAdjust+0x222>
    while(adjustFail != true && newRxBuff != 0)
    bb34:	f1ba 0f00 	cmp.w	sl, #0
    bb38:	d197      	bne.n	ba6a <TCPIP_TCP_FifoSizeAdjust+0x17a>
    txUnackOffs = 0;
    bb3a:	f04f 0b00 	mov.w	fp, #0
    pendTxEnd = pendTxBeg = 0;
    bb3e:	46d9      	mov	r9, fp
    bb40:	f8cd b004 	str.w	fp, [sp, #4]
    avlblRxEnd = avlblRxBeg = 0;
    bb44:	465f      	mov	r7, fp
    bb46:	f8cd b008 	str.w	fp, [sp, #8]
    bb4a:	e7b1      	b.n	bab0 <TCPIP_TCP_FifoSizeAdjust+0x1c0>
    if(newRxBuff)
    bb4c:	f1ba 0f00 	cmp.w	sl, #0
    bb50:	d1ca      	bne.n	bae8 <TCPIP_TCP_FifoSizeAdjust+0x1f8>
    return true;
    bb52:	2001      	movs	r0, #1
    bb54:	e7dd      	b.n	bb12 <TCPIP_TCP_FifoSizeAdjust+0x222>
    txUnackOffs = 0;
    bb56:	f04f 0b00 	mov.w	fp, #0
    pendTxEnd = pendTxBeg = 0;
    bb5a:	46d9      	mov	r9, fp
    bb5c:	f8cd b004 	str.w	fp, [sp, #4]
    while(adjustFail != true && newRxBuff != 0)
    bb60:	f1ba 0f00 	cmp.w	sl, #0
    bb64:	d037      	beq.n	bbd6 <TCPIP_TCP_FifoSizeAdjust+0x2e6>
        if((vFlags & TCP_ADJUST_PRESERVE_RX) != 0)
    bb66:	f017 0f04 	tst.w	r7, #4
    bb6a:	d09f      	beq.n	baac <TCPIP_TCP_FifoSizeAdjust+0x1bc>
            rxHead = pSkt->rxHead;
    bb6c:	69e7      	ldr	r7, [r4, #28]
            if(pSkt->sHoleSize != -1)
    bb6e:	6d63      	ldr	r3, [r4, #84]	; 0x54
    bb70:	f1b3 3fff 	cmp.w	r3, #4294967295
    bb74:	d00a      	beq.n	bb8c <TCPIP_TCP_FifoSizeAdjust+0x29c>
                rxHead += pSkt->sHoleSize + pSkt->wFutureDataSize;
    bb76:	f8b4 2060 	ldrh.w	r2, [r4, #96]	; 0x60
    bb7a:	4413      	add	r3, r2
    bb7c:	441f      	add	r7, r3
                if(rxHead > pSkt->rxEnd)
    bb7e:	69a3      	ldr	r3, [r4, #24]
    bb80:	42bb      	cmp	r3, r7
    bb82:	d203      	bcs.n	bb8c <TCPIP_TCP_FifoSizeAdjust+0x29c>
                    rxHead -= pSkt->rxEnd - pSkt->rxStart + 1;
    bb84:	6962      	ldr	r2, [r4, #20]
    bb86:	1a9b      	subs	r3, r3, r2
    bb88:	43db      	mvns	r3, r3
    bb8a:	441f      	add	r7, r3
            if(rxHead > pSkt->rxTail)
    bb8c:	6a21      	ldr	r1, [r4, #32]
    bb8e:	42b9      	cmp	r1, r7
    bb90:	f4bf af71 	bcs.w	ba76 <TCPIP_TCP_FifoSizeAdjust+0x186>
                avlblRxBeg = rxHead - pSkt->rxTail;
    bb94:	1a7f      	subs	r7, r7, r1
    bb96:	b2bf      	uxth	r7, r7
                srcOffs = pSkt->rxTail;
    bb98:	9103      	str	r1, [sp, #12]
                avlblRxEnd = 0;
    bb9a:	2300      	movs	r3, #0
    bb9c:	9302      	str	r3, [sp, #8]
            if((avlblRxEnd + avlblRxBeg) != 0)
    bb9e:	9a02      	ldr	r2, [sp, #8]
    bba0:	19d3      	adds	r3, r2, r7
    bba2:	d085      	beq.n	bab0 <TCPIP_TCP_FifoSizeAdjust+0x1c0>
                if(avlblRxEnd + avlblRxBeg > wMinRXSize)
    bba4:	42b3      	cmp	r3, r6
    bba6:	dcba      	bgt.n	bb1e <TCPIP_TCP_FifoSizeAdjust+0x22e>
                if(avlblRxEnd)
    bba8:	2a00      	cmp	r2, #0
    bbaa:	f47f af70 	bne.w	ba8e <TCPIP_TCP_FifoSizeAdjust+0x19e>
                if(avlblRxBeg)
    bbae:	2f00      	cmp	r7, #0
    bbb0:	f43f af7e 	beq.w	bab0 <TCPIP_TCP_FifoSizeAdjust+0x1c0>
                    memcpy(newRxBuff + avlblRxEnd, srcOffs, avlblRxBeg);
    bbb4:	463a      	mov	r2, r7
    bbb6:	9903      	ldr	r1, [sp, #12]
    bbb8:	9b02      	ldr	r3, [sp, #8]
    bbba:	eb0a 0003 	add.w	r0, sl, r3
    bbbe:	f015 fa4f 	bl	21060 <memcpy>
    bbc2:	e775      	b.n	bab0 <TCPIP_TCP_FifoSizeAdjust+0x1c0>
    txUnackOffs = 0;
    bbc4:	f04f 0b00 	mov.w	fp, #0
    pendTxEnd = pendTxBeg = 0;
    bbc8:	46d9      	mov	r9, fp
    bbca:	f8cd b004 	str.w	fp, [sp, #4]
    bbce:	e7c7      	b.n	bb60 <TCPIP_TCP_FifoSizeAdjust+0x270>
    txUnackOffs = 0;
    bbd0:	f04f 0b00 	mov.w	fp, #0
    bbd4:	e7c4      	b.n	bb60 <TCPIP_TCP_FifoSizeAdjust+0x270>
    avlblRxEnd = avlblRxBeg = 0;
    bbd6:	2700      	movs	r7, #0
    bbd8:	9702      	str	r7, [sp, #8]
    bbda:	e76c      	b.n	bab6 <TCPIP_TCP_FifoSizeAdjust+0x1c6>
    bbdc:	2000e59c 	.word	0x2000e59c

Disassembly of section .text.Hash_DRBG_Generate%216:

0000bbe0 <Hash_DRBG_Generate>:
    }
}

/* Returns: DRBG_SUCCESS, DRBG_NEED_RESEED, or DRBG_FAILURE */
static int Hash_DRBG_Generate(DRBG_internal* drbg, byte* out, word32 outSz)
{
    bbe0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bbe4:	b0d7      	sub	sp, #348	; 0x15c
    wc_Sha256 sha[1];
#endif
    byte type;
    word32 reseedCtr;

    if (drbg->reseedCtr == RESEED_INTERVAL) {
    bbe6:	f8d0 b000 	ldr.w	fp, [r0]
    bbea:	4bb0      	ldr	r3, [pc, #704]	; (beac <Hash_DRBG_Generate+0x2cc>)
    bbec:	459b      	cmp	fp, r3
    bbee:	f000 813c 	beq.w	be6a <Hash_DRBG_Generate+0x28a>
    bbf2:	4604      	mov	r4, r0
    bbf4:	460f      	mov	r7, r1
    bbf6:	4690      	mov	r8, r2
        if (digest == NULL)
            return MEMORY_E;
    #else
        byte digest[WC_SHA256_DIGEST_SIZE];
    #endif
        type = drbgGenerateH;
    bbf8:	2303      	movs	r3, #3
    bbfa:	f88d 30db 	strb.w	r3, [sp, #219]	; 0xdb
        reseedCtr = drbg->reseedCtr;
    bbfe:	f8cd b0d4 	str.w	fp, [sp, #212]	; 0xd4
    if (outSz == 0) outSz = 1;
    bc02:	2a00      	cmp	r2, #0
    bc04:	f000 8135 	beq.w	be72 <Hash_DRBG_Generate+0x292>
    len = (outSz / OUTPUT_BLOCK_LEN) + ((outSz % OUTPUT_BLOCK_LEN) ? 1 : 0);
    bc08:	f012 091f 	ands.w	r9, r2, #31
    bc0c:	bf18      	it	ne
    bc0e:	f04f 0901 	movne.w	r9, #1
    bc12:	eb09 1952 	add.w	r9, r9, r2, lsr #5
    XMEMCPY(data, V, sizeof(data));
    bc16:	f100 0508 	add.w	r5, r0, #8
    bc1a:	f10d 0c20 	add.w	ip, sp, #32
    bc1e:	f100 0e38 	add.w	lr, r0, #56	; 0x38
    bc22:	4666      	mov	r6, ip
    bc24:	6828      	ldr	r0, [r5, #0]
    bc26:	6869      	ldr	r1, [r5, #4]
    bc28:	68aa      	ldr	r2, [r5, #8]
    bc2a:	68eb      	ldr	r3, [r5, #12]
    bc2c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    bc2e:	3510      	adds	r5, #16
    bc30:	46b4      	mov	ip, r6
    bc32:	4575      	cmp	r5, lr
    bc34:	d1f5      	bne.n	bc22 <Hash_DRBG_Generate+0x42>
    bc36:	6828      	ldr	r0, [r5, #0]
    bc38:	6030      	str	r0, [r6, #0]
    bc3a:	88aa      	ldrh	r2, [r5, #4]
    bc3c:	79ab      	ldrb	r3, [r5, #6]
    bc3e:	80b2      	strh	r2, [r6, #4]
    bc40:	71b3      	strb	r3, [r6, #6]
    for (i = 0; i < len; i++) {
    bc42:	f1b9 0f00 	cmp.w	r9, #0
    bc46:	f300 812d 	bgt.w	bea4 <Hash_DRBG_Generate+0x2c4>
    int ret = DRBG_FAILURE;
    bc4a:	2501      	movs	r5, #1
    bc4c:	e036      	b.n	bcbc <Hash_DRBG_Generate+0xdc>
            ret = wc_Sha256Update(sha, data, sizeof(data));
    bc4e:	2237      	movs	r2, #55	; 0x37
    bc50:	4651      	mov	r1, sl
    bc52:	a816      	add	r0, sp, #88	; 0x58
    bc54:	f005 fefc 	bl	11a50 <wc_Sha256Update>
        if (ret == 0)
    bc58:	4605      	mov	r5, r0
    bc5a:	bb60      	cbnz	r0, bcb6 <Hash_DRBG_Generate+0xd6>
            ret = wc_Sha256Final(sha, digest);
    bc5c:	4669      	mov	r1, sp
    bc5e:	a816      	add	r0, sp, #88	; 0x58
    bc60:	f004 fc6a 	bl	10538 <wc_Sha256Final>
    bc64:	4605      	mov	r5, r0
        wc_Sha256Free(sha);
    bc66:	a816      	add	r0, sp, #88	; 0x58
    bc68:	f010 f843 	bl	1bcf2 <wc_Sha256Free>
        if (ret == 0) {
    bc6c:	bb35      	cbnz	r5, bcbc <Hash_DRBG_Generate+0xdc>
            XMEMCPY(&checkBlock, digest, sizeof(word32));
    bc6e:	9b00      	ldr	r3, [sp, #0]
            if (drbg->reseedCtr > 1 && checkBlock == drbg->lastBlock) {
    bc70:	6822      	ldr	r2, [r4, #0]
    bc72:	2a01      	cmp	r2, #1
    bc74:	d902      	bls.n	bc7c <Hash_DRBG_Generate+0x9c>
    bc76:	6862      	ldr	r2, [r4, #4]
    bc78:	4293      	cmp	r3, r2
    bc7a:	d03b      	beq.n	bcf4 <Hash_DRBG_Generate+0x114>
                drbg->matchCount = 0;
    bc7c:	2200      	movs	r2, #0
    bc7e:	f884 2080 	strb.w	r2, [r4, #128]	; 0x80
                drbg->lastBlock = checkBlock;
    bc82:	6063      	str	r3, [r4, #4]
            if (out != NULL && outSz != 0) {
    bc84:	b167      	cbz	r7, bca0 <Hash_DRBG_Generate+0xc0>
    bc86:	f1b8 0f00 	cmp.w	r8, #0
    bc8a:	d009      	beq.n	bca0 <Hash_DRBG_Generate+0xc0>
                if (outSz >= OUTPUT_BLOCK_LEN) {
    bc8c:	f1b8 0f1f 	cmp.w	r8, #31
    bc90:	d83f      	bhi.n	bd12 <Hash_DRBG_Generate+0x132>
                    XMEMCPY(out, digest, outSz);
    bc92:	4642      	mov	r2, r8
    bc94:	4669      	mov	r1, sp
    bc96:	4638      	mov	r0, r7
    bc98:	f015 f9e2 	bl	21060 <memcpy>
                    outSz = 0;
    bc9c:	f04f 0800 	mov.w	r8, #0
    for (i = 0; i < len; i++) {
    bca0:	3601      	adds	r6, #1
    bca2:	454e      	cmp	r6, r9
    bca4:	da0a      	bge.n	bcbc <Hash_DRBG_Generate+0xdc>
        ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
    bca6:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
    bca8:	6fa1      	ldr	r1, [r4, #120]	; 0x78
    bcaa:	a816      	add	r0, sp, #88	; 0x58
    bcac:	f00f fa04 	bl	1b0b8 <wc_InitSha256_ex>
        if (ret == 0)
    bcb0:	4605      	mov	r5, r0
    bcb2:	2800      	cmp	r0, #0
    bcb4:	d0cb      	beq.n	bc4e <Hash_DRBG_Generate+0x6e>
        wc_Sha256Free(sha);
    bcb6:	a816      	add	r0, sp, #88	; 0x58
    bcb8:	f010 f81b 	bl	1bcf2 <wc_Sha256Free>
#ifndef WOLFSSL_NO_FORCE_ZERO
/* This routine fills the first len bytes of the memory area pointed by mem
   with zeros. It ensures compiler optimizations doesn't skip it  */
WC_STATIC WC_INLINE void ForceZero(const void* mem, word32 len)
{
    volatile byte* z = (volatile byte*)mem;
    bcbc:	aa08      	add	r2, sp, #32
    for (w = (volatile word64*)z; len >= sizeof(*w); len -= sizeof(*w))
        *w++ = 0;
    z = (volatile byte*)w;
#endif

    while (len--) *z++ = 0;
    bcbe:	2000      	movs	r0, #0
    bcc0:	f10d 0157 	add.w	r1, sp, #87	; 0x57
    bcc4:	4613      	mov	r3, r2
    bcc6:	f803 0b01 	strb.w	r0, [r3], #1
    bcca:	461a      	mov	r2, r3
    bccc:	428b      	cmp	r3, r1
    bcce:	d1f9      	bne.n	bcc4 <Hash_DRBG_Generate+0xe4>

        ret = Hash_gen(drbg, out, outSz, drbg->V);
        if (ret == DRBG_SUCCESS) {
    bcd0:	2d00      	cmp	r5, #0
    bcd2:	d043      	beq.n	bd5c <Hash_DRBG_Generate+0x17c>
    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
    bcd4:	2501      	movs	r5, #1
    volatile byte* z = (volatile byte*)mem;
    bcd6:	aa16      	add	r2, sp, #88	; 0x58
    while (len--) *z++ = 0;
    bcd8:	2000      	movs	r0, #0
    bcda:	a91e      	add	r1, sp, #120	; 0x78
    bcdc:	4613      	mov	r3, r2
    bcde:	f803 0b01 	strb.w	r0, [r3], #1
    bce2:	461a      	mov	r2, r3
    bce4:	428b      	cmp	r3, r1
    bce6:	d1f9      	bne.n	bcdc <Hash_DRBG_Generate+0xfc>
    #ifdef WC_ASYNC_ENABLE_SHA256
        FREE_VAR(digest, drbg->heap);
    #endif
    }

    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
    bce8:	1c28      	adds	r0, r5, #0
    bcea:	bf18      	it	ne
    bcec:	2001      	movne	r0, #1
}
    bcee:	b057      	add	sp, #348	; 0x15c
    bcf0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if (drbg->matchCount == 1) {
    bcf4:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
    bcf8:	2b01      	cmp	r3, #1
    bcfa:	f000 80b8 	beq.w	be6e <Hash_DRBG_Generate+0x28e>
                    if (i == (len-1)) {
    bcfe:	f109 33ff 	add.w	r3, r9, #4294967295
    bd02:	42b3      	cmp	r3, r6
                        len++;
    bd04:	bf08      	it	eq
    bd06:	f109 0901 	addeq.w	r9, r9, #1
                    drbg->matchCount = 1;
    bd0a:	2301      	movs	r3, #1
    bd0c:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
    bd10:	e7b8      	b.n	bc84 <Hash_DRBG_Generate+0xa4>
                    XMEMCPY(out, digest, OUTPUT_BLOCK_LEN);
    bd12:	46ec      	mov	ip, sp
    bd14:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    bd18:	6038      	str	r0, [r7, #0]
    bd1a:	6079      	str	r1, [r7, #4]
    bd1c:	60ba      	str	r2, [r7, #8]
    bd1e:	60fb      	str	r3, [r7, #12]
    bd20:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    bd24:	6138      	str	r0, [r7, #16]
    bd26:	6179      	str	r1, [r7, #20]
    bd28:	61ba      	str	r2, [r7, #24]
    bd2a:	61fb      	str	r3, [r7, #28]
                    outSz -= OUTPUT_BLOCK_LEN;
    bd2c:	f1a8 0820 	sub.w	r8, r8, #32
                    out += OUTPUT_BLOCK_LEN;
    bd30:	3720      	adds	r7, #32
        data[i]++;
    bd32:	f89a 3036 	ldrb.w	r3, [sl, #54]	; 0x36
    bd36:	3301      	adds	r3, #1
    bd38:	b2db      	uxtb	r3, r3
    bd3a:	f88a 3036 	strb.w	r3, [sl, #54]	; 0x36
        if (data[i] != 0) break;
    bd3e:	2b00      	cmp	r3, #0
    bd40:	d1ae      	bne.n	bca0 <Hash_DRBG_Generate+0xc0>
    bd42:	f10d 0256 	add.w	r2, sp, #86	; 0x56
    bd46:	4651      	mov	r1, sl
        data[i]++;
    bd48:	f812 3d01 	ldrb.w	r3, [r2, #-1]!
    bd4c:	3301      	adds	r3, #1
    bd4e:	b2db      	uxtb	r3, r3
    bd50:	7013      	strb	r3, [r2, #0]
        if (data[i] != 0) break;
    bd52:	2b00      	cmp	r3, #0
    bd54:	d1a4      	bne.n	bca0 <Hash_DRBG_Generate+0xc0>
    for (i = dataSz - 1; i >= 0; i--)
    bd56:	428a      	cmp	r2, r1
    bd58:	d1f6      	bne.n	bd48 <Hash_DRBG_Generate+0x168>
    bd5a:	e7a1      	b.n	bca0 <Hash_DRBG_Generate+0xc0>
            ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
    bd5c:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
    bd5e:	6fa1      	ldr	r1, [r4, #120]	; 0x78
    bd60:	a837      	add	r0, sp, #220	; 0xdc
    bd62:	f00f f9a9 	bl	1b0b8 <wc_InitSha256_ex>
            if (ret == 0)
    bd66:	4605      	mov	r5, r0
    bd68:	b130      	cbz	r0, bd78 <Hash_DRBG_Generate+0x198>
            wc_Sha256Free(sha);
    bd6a:	a837      	add	r0, sp, #220	; 0xdc
    bd6c:	f00f ffc1 	bl	1bcf2 <wc_Sha256Free>
            drbg->reseedCtr++;
    bd70:	6823      	ldr	r3, [r4, #0]
    bd72:	3301      	adds	r3, #1
    bd74:	6023      	str	r3, [r4, #0]
    bd76:	e7ae      	b.n	bcd6 <Hash_DRBG_Generate+0xf6>
                ret = wc_Sha256Update(sha, &type, sizeof(type));
    bd78:	2201      	movs	r2, #1
    bd7a:	f10d 01db 	add.w	r1, sp, #219	; 0xdb
    bd7e:	a837      	add	r0, sp, #220	; 0xdc
    bd80:	f005 fe66 	bl	11a50 <wc_Sha256Update>
            if (ret == 0)
    bd84:	4605      	mov	r5, r0
    bd86:	2800      	cmp	r0, #0
    bd88:	d1ef      	bne.n	bd6a <Hash_DRBG_Generate+0x18a>
                ret = wc_Sha256Update(sha, drbg->V, sizeof(drbg->V));
    bd8a:	2237      	movs	r2, #55	; 0x37
    bd8c:	f104 0108 	add.w	r1, r4, #8
    bd90:	a837      	add	r0, sp, #220	; 0xdc
    bd92:	f005 fe5d 	bl	11a50 <wc_Sha256Update>
            if (ret == 0)
    bd96:	4605      	mov	r5, r0
    bd98:	2800      	cmp	r0, #0
    bd9a:	d1e6      	bne.n	bd6a <Hash_DRBG_Generate+0x18a>
                ret = wc_Sha256Final(sha, digest);
    bd9c:	a916      	add	r1, sp, #88	; 0x58
    bd9e:	a837      	add	r0, sp, #220	; 0xdc
    bda0:	f004 fbca 	bl	10538 <wc_Sha256Final>
    bda4:	4605      	mov	r5, r0
            wc_Sha256Free(sha);
    bda6:	a837      	add	r0, sp, #220	; 0xdc
    bda8:	f00f ffa3 	bl	1bcf2 <wc_Sha256Free>
            if (ret == 0) {
    bdac:	2d00      	cmp	r5, #0
    bdae:	d1df      	bne.n	bd70 <Hash_DRBG_Generate+0x190>
    bdb0:	f104 023f 	add.w	r2, r4, #63	; 0x3f
    bdb4:	f10d 0777 	add.w	r7, sp, #119	; 0x77
    bdb8:	f10d 0e58 	add.w	lr, sp, #88	; 0x58
    bdbc:	4616      	mov	r6, r2
    word16 carry = 0;
    bdbe:	2100      	movs	r1, #0
    bdc0:	e000      	b.n	bdc4 <Hash_DRBG_Generate+0x1e4>
        for (sIdx = sLen - 1, dIdx = dLen - 1; sIdx >= 0; dIdx--, sIdx--) {
    bdc2:	4607      	mov	r7, r0
            carry += (word16)d[dIdx] + (word16)s[sIdx];
    bdc4:	4638      	mov	r0, r7
    bdc6:	f816 3d01 	ldrb.w	r3, [r6, #-1]!
    bdca:	f810 c901 	ldrb.w	ip, [r0], #-1
    bdce:	4463      	add	r3, ip
    bdd0:	440b      	add	r3, r1
            d[dIdx] = (byte)carry;
    bdd2:	7033      	strb	r3, [r6, #0]
            carry >>= 8;
    bdd4:	f3c3 210f 	ubfx	r1, r3, #8, #16
        for (sIdx = sLen - 1, dIdx = dLen - 1; sIdx >= 0; dIdx--, sIdx--) {
    bdd8:	4577      	cmp	r7, lr
    bdda:	d1f2      	bne.n	bdc2 <Hash_DRBG_Generate+0x1e2>
        for (; carry != 0 && dIdx >= 0; dIdx--) {
    bddc:	b161      	cbz	r1, bdf8 <Hash_DRBG_Generate+0x218>
    bdde:	f104 001f 	add.w	r0, r4, #31
    bde2:	f104 0608 	add.w	r6, r4, #8
            carry += (word16)d[dIdx];
    bde6:	f810 3d01 	ldrb.w	r3, [r0, #-1]!
    bdea:	440b      	add	r3, r1
    bdec:	b29b      	uxth	r3, r3
            d[dIdx] = (byte)carry;
    bdee:	7003      	strb	r3, [r0, #0]
        for (; carry != 0 && dIdx >= 0; dIdx--) {
    bdf0:	0a19      	lsrs	r1, r3, #8
    bdf2:	d001      	beq.n	bdf8 <Hash_DRBG_Generate+0x218>
    bdf4:	42b0      	cmp	r0, r6
    bdf6:	d1f6      	bne.n	bde6 <Hash_DRBG_Generate+0x206>
        for (sIdx = sLen - 1, dIdx = dLen - 1; sIdx >= 0; dIdx--, sIdx--) {
    bdf8:	f104 0008 	add.w	r0, r4, #8
    bdfc:	4611      	mov	r1, r2
    word16 carry = 0;
    bdfe:	2300      	movs	r3, #0
            carry += (word16)d[dIdx] + (word16)s[sIdx];
    be00:	f811 6c01 	ldrb.w	r6, [r1, #-1]
    be04:	f891 7036 	ldrb.w	r7, [r1, #54]	; 0x36
    be08:	443e      	add	r6, r7
    be0a:	4433      	add	r3, r6
            d[dIdx] = (byte)carry;
    be0c:	f801 3d01 	strb.w	r3, [r1, #-1]!
            carry >>= 8;
    be10:	f3c3 230f 	ubfx	r3, r3, #8, #16
        for (sIdx = sLen - 1, dIdx = dLen - 1; sIdx >= 0; dIdx--, sIdx--) {
    be14:	4281      	cmp	r1, r0
    be16:	d1f3      	bne.n	be00 <Hash_DRBG_Generate+0x220>
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
    be18:	ea4f 231b 	mov.w	r3, fp, lsr #8
    be1c:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
    be20:	ea4f 210b 	mov.w	r1, fp, lsl #8
    be24:	f001 21ff 	and.w	r1, r1, #4278255360	; 0xff00ff00
    be28:	430b      	orrs	r3, r1
        return (x << y) | (x >> (sizeof(y) * 8 - y));
    be2a:	ea4f 4333 	mov.w	r3, r3, ror #16
                reseedCtr = ByteReverseWord32(reseedCtr);
    be2e:	9335      	str	r3, [sp, #212]	; 0xd4
        for (sIdx = sLen - 1, dIdx = dLen - 1; sIdx >= 0; dIdx--, sIdx--) {
    be30:	ae36      	add	r6, sp, #216	; 0xd8
    be32:	f104 0c3b 	add.w	ip, r4, #59	; 0x3b
    word16 carry = 0;
    be36:	2300      	movs	r3, #0
            carry += (word16)d[dIdx] + (word16)s[sIdx];
    be38:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
    be3c:	f816 7d01 	ldrb.w	r7, [r6, #-1]!
    be40:	4439      	add	r1, r7
    be42:	440b      	add	r3, r1
            d[dIdx] = (byte)carry;
    be44:	7013      	strb	r3, [r2, #0]
            carry >>= 8;
    be46:	f3c3 230f 	ubfx	r3, r3, #8, #16
        for (sIdx = sLen - 1, dIdx = dLen - 1; sIdx >= 0; dIdx--, sIdx--) {
    be4a:	4594      	cmp	ip, r2
    be4c:	d1f4      	bne.n	be38 <Hash_DRBG_Generate+0x258>
        for (; carry != 0 && dIdx >= 0; dIdx--) {
    be4e:	2b00      	cmp	r3, #0
    be50:	d08e      	beq.n	bd70 <Hash_DRBG_Generate+0x190>
    be52:	f104 023b 	add.w	r2, r4, #59	; 0x3b
            carry += (word16)d[dIdx];
    be56:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
    be5a:	440b      	add	r3, r1
    be5c:	b29b      	uxth	r3, r3
            d[dIdx] = (byte)carry;
    be5e:	7013      	strb	r3, [r2, #0]
        for (; carry != 0 && dIdx >= 0; dIdx--) {
    be60:	0a1b      	lsrs	r3, r3, #8
    be62:	d085      	beq.n	bd70 <Hash_DRBG_Generate+0x190>
    be64:	4282      	cmp	r2, r0
    be66:	d1f6      	bne.n	be56 <Hash_DRBG_Generate+0x276>
    be68:	e782      	b.n	bd70 <Hash_DRBG_Generate+0x190>
        return DRBG_NEED_RESEED;
    be6a:	2002      	movs	r0, #2
    be6c:	e73f      	b.n	bcee <Hash_DRBG_Generate+0x10e>
                    return DRBG_CONT_FAILURE;
    be6e:	2503      	movs	r5, #3
    be70:	e731      	b.n	bcd6 <Hash_DRBG_Generate+0xf6>
    XMEMCPY(data, V, sizeof(data));
    be72:	f100 0508 	add.w	r5, r0, #8
    be76:	f10d 0c20 	add.w	ip, sp, #32
    be7a:	f100 0e38 	add.w	lr, r0, #56	; 0x38
    be7e:	4666      	mov	r6, ip
    be80:	6828      	ldr	r0, [r5, #0]
    be82:	6869      	ldr	r1, [r5, #4]
    be84:	68aa      	ldr	r2, [r5, #8]
    be86:	68eb      	ldr	r3, [r5, #12]
    be88:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    be8a:	3510      	adds	r5, #16
    be8c:	46b4      	mov	ip, r6
    be8e:	4575      	cmp	r5, lr
    be90:	d1f5      	bne.n	be7e <Hash_DRBG_Generate+0x29e>
    be92:	6828      	ldr	r0, [r5, #0]
    be94:	6030      	str	r0, [r6, #0]
    be96:	88aa      	ldrh	r2, [r5, #4]
    be98:	79ab      	ldrb	r3, [r5, #6]
    be9a:	80b2      	strh	r2, [r6, #4]
    be9c:	71b3      	strb	r3, [r6, #6]
    if (outSz == 0) outSz = 1;
    be9e:	f04f 0801 	mov.w	r8, #1
    len = (outSz / OUTPUT_BLOCK_LEN) + ((outSz % OUTPUT_BLOCK_LEN) ? 1 : 0);
    bea2:	46c1      	mov	r9, r8
    bea4:	2600      	movs	r6, #0
            ret = wc_Sha256Update(sha, data, sizeof(data));
    bea6:	f10d 0a20 	add.w	sl, sp, #32
    beaa:	e6fc      	b.n	bca6 <Hash_DRBG_Generate+0xc6>
    beac:	000f4240 	.word	0x000f4240

Disassembly of section .text%217:

0000beb0 <__udivmoddi4>:
    beb0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    beb4:	9e08      	ldr	r6, [sp, #32]
    beb6:	4604      	mov	r4, r0
    beb8:	4688      	mov	r8, r1
    beba:	2b00      	cmp	r3, #0
    bebc:	f040 8085 	bne.w	bfca <__udivmoddi4+0x11a>
    bec0:	428a      	cmp	r2, r1
    bec2:	4615      	mov	r5, r2
    bec4:	d948      	bls.n	bf58 <__udivmoddi4+0xa8>
    bec6:	fab2 f282 	clz	r2, r2
    beca:	b14a      	cbz	r2, bee0 <__udivmoddi4+0x30>
    becc:	f1c2 0720 	rsb	r7, r2, #32
    bed0:	fa01 f302 	lsl.w	r3, r1, r2
    bed4:	fa20 f707 	lsr.w	r7, r0, r7
    bed8:	4095      	lsls	r5, r2
    beda:	ea47 0803 	orr.w	r8, r7, r3
    bede:	4094      	lsls	r4, r2
    bee0:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    bee4:	0c23      	lsrs	r3, r4, #16
    bee6:	fbb8 f7fe 	udiv	r7, r8, lr
    beea:	fa1f fc85 	uxth.w	ip, r5
    beee:	fb0e 8817 	mls	r8, lr, r7, r8
    bef2:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
    bef6:	fb07 f10c 	mul.w	r1, r7, ip
    befa:	4299      	cmp	r1, r3
    befc:	d909      	bls.n	bf12 <__udivmoddi4+0x62>
    befe:	18eb      	adds	r3, r5, r3
    bf00:	f107 30ff 	add.w	r0, r7, #4294967295
    bf04:	f080 80e3 	bcs.w	c0ce <__udivmoddi4+0x21e>
    bf08:	4299      	cmp	r1, r3
    bf0a:	f240 80e0 	bls.w	c0ce <__udivmoddi4+0x21e>
    bf0e:	3f02      	subs	r7, #2
    bf10:	442b      	add	r3, r5
    bf12:	1a5b      	subs	r3, r3, r1
    bf14:	b2a4      	uxth	r4, r4
    bf16:	fbb3 f0fe 	udiv	r0, r3, lr
    bf1a:	fb0e 3310 	mls	r3, lr, r0, r3
    bf1e:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
    bf22:	fb00 fc0c 	mul.w	ip, r0, ip
    bf26:	45a4      	cmp	ip, r4
    bf28:	d909      	bls.n	bf3e <__udivmoddi4+0x8e>
    bf2a:	192c      	adds	r4, r5, r4
    bf2c:	f100 33ff 	add.w	r3, r0, #4294967295
    bf30:	f080 80cb 	bcs.w	c0ca <__udivmoddi4+0x21a>
    bf34:	45a4      	cmp	ip, r4
    bf36:	f240 80c8 	bls.w	c0ca <__udivmoddi4+0x21a>
    bf3a:	3802      	subs	r0, #2
    bf3c:	442c      	add	r4, r5
    bf3e:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
    bf42:	eba4 040c 	sub.w	r4, r4, ip
    bf46:	2700      	movs	r7, #0
    bf48:	b11e      	cbz	r6, bf52 <__udivmoddi4+0xa2>
    bf4a:	40d4      	lsrs	r4, r2
    bf4c:	2300      	movs	r3, #0
    bf4e:	e9c6 4300 	strd	r4, r3, [r6]
    bf52:	4639      	mov	r1, r7
    bf54:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    bf58:	2a00      	cmp	r2, #0
    bf5a:	d053      	beq.n	c004 <__udivmoddi4+0x154>
    bf5c:	fab2 f282 	clz	r2, r2
    bf60:	2a00      	cmp	r2, #0
    bf62:	f040 80b6 	bne.w	c0d2 <__udivmoddi4+0x222>
    bf66:	1b49      	subs	r1, r1, r5
    bf68:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    bf6c:	fa1f f885 	uxth.w	r8, r5
    bf70:	2701      	movs	r7, #1
    bf72:	fbb1 fcfe 	udiv	ip, r1, lr
    bf76:	0c23      	lsrs	r3, r4, #16
    bf78:	fb0e 111c 	mls	r1, lr, ip, r1
    bf7c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    bf80:	fb08 f10c 	mul.w	r1, r8, ip
    bf84:	4299      	cmp	r1, r3
    bf86:	d907      	bls.n	bf98 <__udivmoddi4+0xe8>
    bf88:	18eb      	adds	r3, r5, r3
    bf8a:	f10c 30ff 	add.w	r0, ip, #4294967295
    bf8e:	d202      	bcs.n	bf96 <__udivmoddi4+0xe6>
    bf90:	4299      	cmp	r1, r3
    bf92:	f200 80ec 	bhi.w	c16e <__udivmoddi4+0x2be>
    bf96:	4684      	mov	ip, r0
    bf98:	1a59      	subs	r1, r3, r1
    bf9a:	b2a3      	uxth	r3, r4
    bf9c:	fbb1 f0fe 	udiv	r0, r1, lr
    bfa0:	fb0e 1410 	mls	r4, lr, r0, r1
    bfa4:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
    bfa8:	fb08 f800 	mul.w	r8, r8, r0
    bfac:	45a0      	cmp	r8, r4
    bfae:	d907      	bls.n	bfc0 <__udivmoddi4+0x110>
    bfb0:	192c      	adds	r4, r5, r4
    bfb2:	f100 33ff 	add.w	r3, r0, #4294967295
    bfb6:	d202      	bcs.n	bfbe <__udivmoddi4+0x10e>
    bfb8:	45a0      	cmp	r8, r4
    bfba:	f200 80dc 	bhi.w	c176 <__udivmoddi4+0x2c6>
    bfbe:	4618      	mov	r0, r3
    bfc0:	eba4 0408 	sub.w	r4, r4, r8
    bfc4:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
    bfc8:	e7be      	b.n	bf48 <__udivmoddi4+0x98>
    bfca:	428b      	cmp	r3, r1
    bfcc:	d908      	bls.n	bfe0 <__udivmoddi4+0x130>
    bfce:	2e00      	cmp	r6, #0
    bfd0:	d078      	beq.n	c0c4 <__udivmoddi4+0x214>
    bfd2:	2700      	movs	r7, #0
    bfd4:	e9c6 0100 	strd	r0, r1, [r6]
    bfd8:	4638      	mov	r0, r7
    bfda:	4639      	mov	r1, r7
    bfdc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    bfe0:	fab3 f783 	clz	r7, r3
    bfe4:	b97f      	cbnz	r7, c006 <__udivmoddi4+0x156>
    bfe6:	428b      	cmp	r3, r1
    bfe8:	d302      	bcc.n	bff0 <__udivmoddi4+0x140>
    bfea:	4282      	cmp	r2, r0
    bfec:	f200 80bd 	bhi.w	c16a <__udivmoddi4+0x2ba>
    bff0:	1a84      	subs	r4, r0, r2
    bff2:	eb61 0303 	sbc.w	r3, r1, r3
    bff6:	2001      	movs	r0, #1
    bff8:	4698      	mov	r8, r3
    bffa:	2e00      	cmp	r6, #0
    bffc:	d0a9      	beq.n	bf52 <__udivmoddi4+0xa2>
    bffe:	e9c6 4800 	strd	r4, r8, [r6]
    c002:	e7a6      	b.n	bf52 <__udivmoddi4+0xa2>
    c004:	deff      	udf	#255	; 0xff
    c006:	f1c7 0520 	rsb	r5, r7, #32
    c00a:	40bb      	lsls	r3, r7
    c00c:	fa22 fc05 	lsr.w	ip, r2, r5
    c010:	ea4c 0c03 	orr.w	ip, ip, r3
    c014:	fa01 f407 	lsl.w	r4, r1, r7
    c018:	fa20 f805 	lsr.w	r8, r0, r5
    c01c:	fa21 f305 	lsr.w	r3, r1, r5
    c020:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
    c024:	ea48 0404 	orr.w	r4, r8, r4
    c028:	fbb3 f9fe 	udiv	r9, r3, lr
    c02c:	0c21      	lsrs	r1, r4, #16
    c02e:	fb0e 3319 	mls	r3, lr, r9, r3
    c032:	fa1f f88c 	uxth.w	r8, ip
    c036:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
    c03a:	fb09 fa08 	mul.w	sl, r9, r8
    c03e:	459a      	cmp	sl, r3
    c040:	fa02 f207 	lsl.w	r2, r2, r7
    c044:	fa00 f107 	lsl.w	r1, r0, r7
    c048:	d90b      	bls.n	c062 <__udivmoddi4+0x1b2>
    c04a:	eb1c 0303 	adds.w	r3, ip, r3
    c04e:	f109 30ff 	add.w	r0, r9, #4294967295
    c052:	f080 8088 	bcs.w	c166 <__udivmoddi4+0x2b6>
    c056:	459a      	cmp	sl, r3
    c058:	f240 8085 	bls.w	c166 <__udivmoddi4+0x2b6>
    c05c:	f1a9 0902 	sub.w	r9, r9, #2
    c060:	4463      	add	r3, ip
    c062:	eba3 030a 	sub.w	r3, r3, sl
    c066:	b2a4      	uxth	r4, r4
    c068:	fbb3 f0fe 	udiv	r0, r3, lr
    c06c:	fb0e 3310 	mls	r3, lr, r0, r3
    c070:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
    c074:	fb00 f808 	mul.w	r8, r0, r8
    c078:	45a0      	cmp	r8, r4
    c07a:	d908      	bls.n	c08e <__udivmoddi4+0x1de>
    c07c:	eb1c 0404 	adds.w	r4, ip, r4
    c080:	f100 33ff 	add.w	r3, r0, #4294967295
    c084:	d26b      	bcs.n	c15e <__udivmoddi4+0x2ae>
    c086:	45a0      	cmp	r8, r4
    c088:	d969      	bls.n	c15e <__udivmoddi4+0x2ae>
    c08a:	3802      	subs	r0, #2
    c08c:	4464      	add	r4, ip
    c08e:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
    c092:	eba4 0408 	sub.w	r4, r4, r8
    c096:	fba0 8902 	umull	r8, r9, r0, r2
    c09a:	454c      	cmp	r4, r9
    c09c:	46c6      	mov	lr, r8
    c09e:	464b      	mov	r3, r9
    c0a0:	d354      	bcc.n	c14c <__udivmoddi4+0x29c>
    c0a2:	d051      	beq.n	c148 <__udivmoddi4+0x298>
    c0a4:	2e00      	cmp	r6, #0
    c0a6:	d069      	beq.n	c17c <__udivmoddi4+0x2cc>
    c0a8:	ebb1 020e 	subs.w	r2, r1, lr
    c0ac:	eb64 0403 	sbc.w	r4, r4, r3
    c0b0:	fa04 f505 	lsl.w	r5, r4, r5
    c0b4:	fa22 f307 	lsr.w	r3, r2, r7
    c0b8:	40fc      	lsrs	r4, r7
    c0ba:	431d      	orrs	r5, r3
    c0bc:	e9c6 5400 	strd	r5, r4, [r6]
    c0c0:	2700      	movs	r7, #0
    c0c2:	e746      	b.n	bf52 <__udivmoddi4+0xa2>
    c0c4:	4637      	mov	r7, r6
    c0c6:	4630      	mov	r0, r6
    c0c8:	e743      	b.n	bf52 <__udivmoddi4+0xa2>
    c0ca:	4618      	mov	r0, r3
    c0cc:	e737      	b.n	bf3e <__udivmoddi4+0x8e>
    c0ce:	4607      	mov	r7, r0
    c0d0:	e71f      	b.n	bf12 <__udivmoddi4+0x62>
    c0d2:	f1c2 0320 	rsb	r3, r2, #32
    c0d6:	fa20 f703 	lsr.w	r7, r0, r3
    c0da:	4095      	lsls	r5, r2
    c0dc:	fa01 f002 	lsl.w	r0, r1, r2
    c0e0:	fa21 f303 	lsr.w	r3, r1, r3
    c0e4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    c0e8:	4338      	orrs	r0, r7
    c0ea:	0c01      	lsrs	r1, r0, #16
    c0ec:	fbb3 f7fe 	udiv	r7, r3, lr
    c0f0:	fa1f f885 	uxth.w	r8, r5
    c0f4:	fb0e 3317 	mls	r3, lr, r7, r3
    c0f8:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    c0fc:	fb07 f308 	mul.w	r3, r7, r8
    c100:	428b      	cmp	r3, r1
    c102:	fa04 f402 	lsl.w	r4, r4, r2
    c106:	d907      	bls.n	c118 <__udivmoddi4+0x268>
    c108:	1869      	adds	r1, r5, r1
    c10a:	f107 3cff 	add.w	ip, r7, #4294967295
    c10e:	d228      	bcs.n	c162 <__udivmoddi4+0x2b2>
    c110:	428b      	cmp	r3, r1
    c112:	d926      	bls.n	c162 <__udivmoddi4+0x2b2>
    c114:	3f02      	subs	r7, #2
    c116:	4429      	add	r1, r5
    c118:	1acb      	subs	r3, r1, r3
    c11a:	b281      	uxth	r1, r0
    c11c:	fbb3 f0fe 	udiv	r0, r3, lr
    c120:	fb0e 3310 	mls	r3, lr, r0, r3
    c124:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    c128:	fb00 f308 	mul.w	r3, r0, r8
    c12c:	428b      	cmp	r3, r1
    c12e:	d907      	bls.n	c140 <__udivmoddi4+0x290>
    c130:	1869      	adds	r1, r5, r1
    c132:	f100 3cff 	add.w	ip, r0, #4294967295
    c136:	d210      	bcs.n	c15a <__udivmoddi4+0x2aa>
    c138:	428b      	cmp	r3, r1
    c13a:	d90e      	bls.n	c15a <__udivmoddi4+0x2aa>
    c13c:	3802      	subs	r0, #2
    c13e:	4429      	add	r1, r5
    c140:	1ac9      	subs	r1, r1, r3
    c142:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
    c146:	e714      	b.n	bf72 <__udivmoddi4+0xc2>
    c148:	4541      	cmp	r1, r8
    c14a:	d2ab      	bcs.n	c0a4 <__udivmoddi4+0x1f4>
    c14c:	ebb8 0e02 	subs.w	lr, r8, r2
    c150:	eb69 020c 	sbc.w	r2, r9, ip
    c154:	3801      	subs	r0, #1
    c156:	4613      	mov	r3, r2
    c158:	e7a4      	b.n	c0a4 <__udivmoddi4+0x1f4>
    c15a:	4660      	mov	r0, ip
    c15c:	e7f0      	b.n	c140 <__udivmoddi4+0x290>
    c15e:	4618      	mov	r0, r3
    c160:	e795      	b.n	c08e <__udivmoddi4+0x1de>
    c162:	4667      	mov	r7, ip
    c164:	e7d8      	b.n	c118 <__udivmoddi4+0x268>
    c166:	4681      	mov	r9, r0
    c168:	e77b      	b.n	c062 <__udivmoddi4+0x1b2>
    c16a:	4638      	mov	r0, r7
    c16c:	e745      	b.n	bffa <__udivmoddi4+0x14a>
    c16e:	f1ac 0c02 	sub.w	ip, ip, #2
    c172:	442b      	add	r3, r5
    c174:	e710      	b.n	bf98 <__udivmoddi4+0xe8>
    c176:	3802      	subs	r0, #2
    c178:	442c      	add	r4, r5
    c17a:	e721      	b.n	bfc0 <__udivmoddi4+0x110>
    c17c:	4637      	mov	r7, r6
    c17e:	e6e8      	b.n	bf52 <__udivmoddi4+0xa2>

Disassembly of section .text._TCP_Open%218:

0000c180 <_TCP_Open>:
{
    c180:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c184:	b083      	sub	sp, #12
    c186:	4680      	mov	r8, r0
    c188:	468a      	mov	sl, r1
    c18a:	9200      	str	r2, [sp, #0]
    c18c:	9301      	str	r3, [sp, #4]
    if(opType == TCP_OPEN_CLIENT)
    c18e:	2901      	cmp	r1, #1
    c190:	d000      	beq.n	c194 <_TCP_Open+0x14>
    if(localPort == 0)
    c192:	bb02      	cbnz	r2, c1d6 <_TCP_Open+0x56>
        localPort = _TCP_EphemeralPortAllocate();
    c194:	f012 f98e 	bl	1e4b4 <_TCP_EphemeralPortAllocate>
        if(localPort  == 0)
    c198:	4683      	mov	fp, r0
    c19a:	2800      	cmp	r0, #0
    c19c:	f000 8124 	beq.w	c3e8 <_TCP_Open+0x268>
    if (OSAL_SEM_Pend(&tcpSemaphore, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
    c1a0:	f64f 71ff 	movw	r1, #65535	; 0xffff
    c1a4:	489f      	ldr	r0, [pc, #636]	; (c424 <_TCP_Open+0x2a4>)
    c1a6:	f014 fd6d 	bl	20c84 <OSAL_SEM_Pend>
    for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    c1aa:	4b9f      	ldr	r3, [pc, #636]	; (c428 <_TCP_Open+0x2a8>)
    c1ac:	681a      	ldr	r2, [r3, #0]
    c1ae:	2a00      	cmp	r2, #0
    c1b0:	f000 80cc 	beq.w	c34c <_TCP_Open+0x1cc>
        pSkt = TCBStubs[hTCP];
    c1b4:	4b9d      	ldr	r3, [pc, #628]	; (c42c <_TCP_Open+0x2ac>)
    c1b6:	6819      	ldr	r1, [r3, #0]
    c1b8:	680b      	ldr	r3, [r1, #0]
        if(pSkt == 0)
    c1ba:	2b00      	cmp	r3, #0
    c1bc:	f000 8117 	beq.w	c3ee <_TCP_Open+0x26e>
    for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    c1c0:	2400      	movs	r4, #0
    c1c2:	3401      	adds	r4, #1
    c1c4:	b224      	sxth	r4, r4
    c1c6:	4626      	mov	r6, r4
    c1c8:	4294      	cmp	r4, r2
    c1ca:	d209      	bcs.n	c1e0 <_TCP_Open+0x60>
        pSkt = TCBStubs[hTCP];
    c1cc:	f851 3024 	ldr.w	r3, [r1, r4, lsl #2]
        if(pSkt == 0)
    c1d0:	2b00      	cmp	r3, #0
    c1d2:	d1f6      	bne.n	c1c2 <_TCP_Open+0x42>
    c1d4:	e007      	b.n	c1e6 <_TCP_Open+0x66>
        localPort = port;
    c1d6:	f8dd b000 	ldr.w	fp, [sp]
        remotePort = 0;
    c1da:	2300      	movs	r3, #0
    c1dc:	9300      	str	r3, [sp, #0]
    c1de:	e7df      	b.n	c1a0 <_TCP_Open+0x20>
    if(pSkt != 0)
    c1e0:	2b00      	cmp	r3, #0
    c1e2:	f040 80b3 	bne.w	c34c <_TCP_Open+0x1cc>
    pSkt = (TCB_STUB*)TCPIP_HEAP_Calloc(tcpHeapH, 1, sizeof(*pSkt));
    c1e6:	f8df 9250 	ldr.w	r9, [pc, #592]	; c438 <_TCP_Open+0x2b8>
    c1ea:	f8d9 0000 	ldr.w	r0, [r9]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Calloc)(h, nElems, elemSize);
    c1ee:	6883      	ldr	r3, [r0, #8]
    c1f0:	2280      	movs	r2, #128	; 0x80
    c1f2:	2101      	movs	r1, #1
    c1f4:	4798      	blx	r3
    c1f6:	4605      	mov	r5, r0
    txBuff = (uint8_t*)TCPIP_HEAP_Malloc(tcpHeapH, tcpDefTxSize + 1);
    c1f8:	f8d9 0000 	ldr.w	r0, [r9]
    c1fc:	4b8c      	ldr	r3, [pc, #560]	; (c430 <_TCP_Open+0x2b0>)
    c1fe:	8819      	ldrh	r1, [r3, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
    c200:	6843      	ldr	r3, [r0, #4]
    c202:	3101      	adds	r1, #1
    c204:	4798      	blx	r3
    c206:	4607      	mov	r7, r0
    rxBuff = (uint8_t*)TCPIP_HEAP_Malloc(tcpHeapH, tcpDefRxSize + 1);
    c208:	f8d9 0000 	ldr.w	r0, [r9]
    c20c:	4b89      	ldr	r3, [pc, #548]	; (c434 <_TCP_Open+0x2b4>)
    c20e:	8819      	ldrh	r1, [r3, #0]
    c210:	6843      	ldr	r3, [r0, #4]
    c212:	3101      	adds	r1, #1
    c214:	4798      	blx	r3
    if(pSkt == 0 || txBuff == 0 || rxBuff == 0)
    c216:	2d00      	cmp	r5, #0
    c218:	f000 809e 	beq.w	c358 <_TCP_Open+0x1d8>
    c21c:	2f00      	cmp	r7, #0
    c21e:	f000 809b 	beq.w	c358 <_TCP_Open+0x1d8>
    c222:	2800      	cmp	r0, #0
    c224:	f000 8098 	beq.w	c358 <_TCP_Open+0x1d8>
    _TcpSocketInitialize(pSkt, hTCP, txBuff, tcpDefTxSize, rxBuff, tcpDefRxSize);
    c228:	4b81      	ldr	r3, [pc, #516]	; (c430 <_TCP_Open+0x2b0>)
    c22a:	881b      	ldrh	r3, [r3, #0]
    c22c:	4a81      	ldr	r2, [pc, #516]	; (c434 <_TCP_Open+0x2b4>)
    c22e:	8811      	ldrh	r1, [r2, #0]
    pSkt->sktIx = hTCP;     // hTCP is the index of this socket!
    c230:	86ac      	strh	r4, [r5, #52]	; 0x34
    pSkt->txStart	= txBuff;
    c232:	602f      	str	r7, [r5, #0]
    pSkt->txEnd	    = txBuff + txBuffSize + 1;
    c234:	3301      	adds	r3, #1
    c236:	441f      	add	r7, r3
    c238:	606f      	str	r7, [r5, #4]
    pSkt->rxStart	= rxBuff;
    c23a:	6168      	str	r0, [r5, #20]
    pSkt->rxEnd		= rxBuff + rxBuffSize;
    c23c:	4408      	add	r0, r1
    c23e:	61a8      	str	r0, [r5, #24]
    pSkt->wRemoteMSS = TCP_MIN_DEFAULT_MTU;
    c240:	f44f 7306 	mov.w	r3, #536	; 0x218
    c244:	f8a5 3062 	strh.w	r3, [r5, #98]	; 0x62
    TCBStubs[hTCP] = pSkt;  // store it
    c248:	4b78      	ldr	r3, [pc, #480]	; (c42c <_TCP_Open+0x2ac>)
    c24a:	681b      	ldr	r3, [r3, #0]
    c24c:	f843 5026 	str.w	r5, [r3, r6, lsl #2]
    if (OSAL_SEM_Post(&tcpSemaphore) != OSAL_RESULT_TRUE)
    c250:	4874      	ldr	r0, [pc, #464]	; (c424 <_TCP_Open+0x2a4>)
    c252:	f015 f92f 	bl	214b4 <OSAL_SEM_Post>
	pSkt->remoteHash = pSkt->localPort;
    c256:	f8b5 305a 	ldrh.w	r3, [r5, #90]	; 0x5a
    c25a:	f8a5 306a 	strh.w	r3, [r5, #106]	; 0x6a
	pSkt->txHead = pSkt->txStart;
    c25e:	682b      	ldr	r3, [r5, #0]
    c260:	60ab      	str	r3, [r5, #8]
	pSkt->txTail = pSkt->txStart;
    c262:	60eb      	str	r3, [r5, #12]
	pSkt->txUnackedTail = pSkt->txStart;
    c264:	612b      	str	r3, [r5, #16]
	pSkt->rxHead = pSkt->rxStart;
    c266:	696b      	ldr	r3, [r5, #20]
    c268:	61eb      	str	r3, [r5, #28]
	pSkt->rxTail = pSkt->rxStart;
    c26a:	622b      	str	r3, [r5, #32]
	pSkt->Flags.bTimerEnabled = 0;
    c26c:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
	pSkt->Flags.bTXASAPWithoutTimerReset = 0;
    c270:	f003 0381 	and.w	r3, r3, #129	; 0x81
    c274:	f36f 13c7 	bfc	r3, #7, #1
    c278:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
	pSkt->Flags.bTXFIN = 0;
    c27c:	f895 3037 	ldrb.w	r3, [r5, #55]	; 0x37
	pSkt->Flags.bSocketReset = 1;
    c280:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	pSkt->Flags.bRxFin = 0;
    c284:	f043 0302 	orr.w	r3, r3, #2
    c288:	f36f 0382 	bfc	r3, #2, #1
    c28c:	f885 3037 	strb.w	r3, [r5, #55]	; 0x37
	pSkt->flags.bFINSent = 0;
    c290:	f895 306c 	ldrb.w	r3, [r5, #108]	; 0x6c
    pSkt->flags.seqInc = 0;
    c294:	f895 206d 	ldrb.w	r2, [r5, #109]	; 0x6d
    c298:	f36f 0241 	bfc	r2, #1, #1
    c29c:	f885 206d 	strb.w	r2, [r5, #109]	; 0x6d
	pSkt->flags.bRXNoneACKed2 = 0;
    c2a0:	f003 03e3 	and.w	r3, r3, #227	; 0xe3
    c2a4:	f36f 1345 	bfc	r3, #5, #1
    c2a8:	f885 306c 	strb.w	r3, [r5, #108]	; 0x6c
    pSkt->MySEQ = 0;
    c2ac:	2100      	movs	r1, #0
    c2ae:	64e9      	str	r1, [r5, #76]	; 0x4c
	pSkt->sHoleSize = -1;
    c2b0:	f04f 30ff 	mov.w	r0, #4294967295
    c2b4:	6568      	str	r0, [r5, #84]	; 0x54
	pSkt->remoteWindow = 1;
    c2b6:	2001      	movs	r0, #1
    c2b8:	f8a5 005c 	strh.w	r0, [r5, #92]	; 0x5c
    pSkt->maxRemoteWindow = 1;
    c2bc:	f8a5 0066 	strh.w	r0, [r5, #102]	; 0x66
    pSkt->remotePort = 0;
    c2c0:	f8a5 1058 	strh.w	r1, [r5, #88]	; 0x58
    pSkt->destAddress.Val = 0;
    c2c4:	63a9      	str	r1, [r5, #56]	; 0x38
	pSkt->keepAliveCount = 0;
    c2c6:	f885 1071 	strb.w	r1, [r5, #113]	; 0x71
    pSkt->addType = (IP_ADDRESS_TYPE)pSkt->flags.openAddType;
    c2ca:	f003 0303 	and.w	r3, r3, #3
    c2ce:	f885 306f 	strb.w	r3, [r5, #111]	; 0x6f
    if(pSkt->flags.openBindIf == 0)
    c2d2:	b2d2      	uxtb	r2, r2
    c2d4:	f012 0f20 	tst.w	r2, #32
        pSkt->pSktNet = 0;
    c2d8:	bf04      	itt	eq
    c2da:	460b      	moveq	r3, r1
    c2dc:	6429      	streq	r1, [r5, #64]	; 0x40
    if(pSkt->flags.openBindAdd == 0)
    c2de:	f012 0f40 	tst.w	r2, #64	; 0x40
        pSkt->srcAddress.Val = 0;
    c2e2:	bf04      	itt	eq
    c2e4:	2300      	moveq	r3, #0
    c2e6:	63eb      	streq	r3, [r5, #60]	; 0x3c
    pSkt->dbgFlags.val = 0;
    c2e8:	2300      	movs	r3, #0
    c2ea:	f885 307d 	strb.w	r3, [r5, #125]	; 0x7d
    pSkt->addType = addType;
    c2ee:	f885 806f 	strb.w	r8, [r5, #111]	; 0x6f
    switch(addType)
    c2f2:	f1b8 0f01 	cmp.w	r8, #1
    c2f6:	d043      	beq.n	c380 <_TCP_Open+0x200>
            pSkt->pTxPkt = 0;   // default for IP_ADDRESS_TYPE_ANY
    c2f8:	2300      	movs	r3, #0
    c2fa:	646b      	str	r3, [r5, #68]	; 0x44
    if (pSkt->pTxPkt == 0 && pSkt->addType != IP_ADDRESS_TYPE_ANY)
    c2fc:	f895 306f 	ldrb.w	r3, [r5, #111]	; 0x6f
    c300:	2b00      	cmp	r3, #0
    c302:	d16b      	bne.n	c3dc <_TCP_Open+0x25c>
    pSkt->flags.openAddType = addType;
    c304:	f895 306c 	ldrb.w	r3, [r5, #108]	; 0x6c
    c308:	f368 0301 	bfi	r3, r8, #0, #2
    c30c:	f885 306c 	strb.w	r3, [r5, #108]	; 0x6c
    if(opType == TCP_OPEN_SERVER)
    c310:	f1ba 0f00 	cmp.w	sl, #0
    c314:	d051      	beq.n	c3ba <_TCP_Open+0x23a>
        pSkt->localPort = localPort;
    c316:	f8a5 b05a 	strh.w	fp, [r5, #90]	; 0x5a
        pSkt->remotePort = remotePort;
    c31a:	9b00      	ldr	r3, [sp, #0]
    c31c:	f8a5 3058 	strh.w	r3, [r5, #88]	; 0x58
        pSkt->eventTime = SYS_TMR_TickCountGet();
    c320:	f013 fe44 	bl	1ffac <SYS_TMR_TickCountGet>
    c324:	6268      	str	r0, [r5, #36]	; 0x24
        pSkt->Flags.bTimerEnabled = 1;
    c326:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
    c32a:	f043 0302 	orr.w	r3, r3, #2
    c32e:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
        switch(addType)
    c332:	f1b8 0f01 	cmp.w	r8, #1
    c336:	d06b      	beq.n	c410 <_TCP_Open+0x290>
        _TcpSocketSetState(pSkt, (_TcpClientSocketConnect(pSkt) >= 0) ? TCPIP_TCP_STATE_SYN_SENT : TCPIP_TCP_STATE_CLIENT_WAIT_CONNECT);
    c338:	4628      	mov	r0, r5
    c33a:	f00f f95d 	bl	1b5f8 <_TcpClientSocketConnect>
    c33e:	2800      	cmp	r0, #0
    c340:	bfac      	ite	ge
    c342:	2301      	movge	r3, #1
    c344:	230b      	movlt	r3, #11
    pSkt->smState = newState;
    c346:	f885 306e 	strb.w	r3, [r5, #110]	; 0x6e
    c34a:	e043      	b.n	c3d4 <_TCP_Open+0x254>
        if (OSAL_SEM_Post(&tcpSemaphore) != OSAL_RESULT_TRUE)
    c34c:	4835      	ldr	r0, [pc, #212]	; (c424 <_TCP_Open+0x2a4>)
    c34e:	f015 f8b1 	bl	214b4 <OSAL_SEM_Post>
        return INVALID_SOCKET;
    c352:	f04f 34ff 	mov.w	r4, #4294967295
    c356:	e03d      	b.n	c3d4 <_TCP_Open+0x254>
        TCPIP_HEAP_Free(tcpHeapH, rxBuff);
    c358:	4c37      	ldr	r4, [pc, #220]	; (c438 <_TCP_Open+0x2b8>)
    c35a:	6823      	ldr	r3, [r4, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
    c35c:	68da      	ldr	r2, [r3, #12]
    c35e:	4601      	mov	r1, r0
    c360:	4618      	mov	r0, r3
    c362:	4790      	blx	r2
        TCPIP_HEAP_Free(tcpHeapH, txBuff);
    c364:	6820      	ldr	r0, [r4, #0]
    c366:	68c3      	ldr	r3, [r0, #12]
    c368:	4639      	mov	r1, r7
    c36a:	4798      	blx	r3
        TCPIP_HEAP_Free(tcpHeapH, pSkt);
    c36c:	6820      	ldr	r0, [r4, #0]
    c36e:	68c3      	ldr	r3, [r0, #12]
    c370:	4629      	mov	r1, r5
    c372:	4798      	blx	r3
        if (OSAL_SEM_Post(&tcpSemaphore) != OSAL_RESULT_TRUE)
    c374:	482b      	ldr	r0, [pc, #172]	; (c424 <_TCP_Open+0x2a4>)
    c376:	f015 f89d 	bl	214b4 <OSAL_SEM_Post>
        return INVALID_SOCKET;
    c37a:	f04f 34ff 	mov.w	r4, #4294967295
    c37e:	e029      	b.n	c3d4 <_TCP_Open+0x254>
    pv4Pkt = (TCP_V4_PACKET*)TCPIP_PKT_SocketAlloc(sizeof(TCP_V4_PACKET), sizeof(TCP_HEADER), sizeof(TCP_OPTIONS), allocFlags);
    c380:	f242 0306 	movw	r3, #8198	; 0x2006
    c384:	2204      	movs	r2, #4
    c386:	2114      	movs	r1, #20
    c388:	2074      	movs	r0, #116	; 0x74
    c38a:	f013 fa2b 	bl	1f7e4 <_TCPIP_PKT_SocketAlloc>
    if(pv4Pkt)
    c38e:	2800      	cmp	r0, #0
    c390:	d046      	beq.n	c420 <_TCP_Open+0x2a0>
    pPkt->ackFunc = ackFunc;
    c392:	4a2a      	ldr	r2, [pc, #168]	; (c43c <_TCP_Open+0x2bc>)
    c394:	6082      	str	r2, [r0, #8]
    pPkt->ackParam = ackParam;
    c396:	60c5      	str	r5, [r0, #12]
        pv4Pkt->tcpSeg[0].segFlags = pv4Pkt->tcpSeg[1].segFlags = TCPIP_MAC_SEG_FLAG_STATIC; // embedded in packet itself
    c398:	2201      	movs	r2, #1
    c39a:	f8a0 206c 	strh.w	r2, [r0, #108]	; 0x6c
    c39e:	f8a0 2054 	strh.w	r2, [r0, #84]	; 0x54
            pSkt->pTxPkt = _TcpAllocateTxPacket (pSkt, IP_ADDRESS_TYPE_IPV4);
    c3a2:	6468      	str	r0, [r5, #68]	; 0x44
    if (pSkt->pTxPkt == 0 && pSkt->addType != IP_ADDRESS_TYPE_ANY)
    c3a4:	2800      	cmp	r0, #0
    c3a6:	d0a9      	beq.n	c2fc <_TCP_Open+0x17c>
    pSkt->flags.openAddType = addType;
    c3a8:	f895 306c 	ldrb.w	r3, [r5, #108]	; 0x6c
    c3ac:	f368 0301 	bfi	r3, r8, #0, #2
    c3b0:	f885 306c 	strb.w	r3, [r5, #108]	; 0x6c
    if(opType == TCP_OPEN_SERVER)
    c3b4:	f1ba 0f00 	cmp.w	sl, #0
    c3b8:	d11c      	bne.n	c3f4 <_TCP_Open+0x274>
        pSkt->localPort = localPort;
    c3ba:	f8a5 b05a 	strh.w	fp, [r5, #90]	; 0x5a
        pSkt->Flags.bServer = true;
    c3be:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
    c3c2:	f043 0301 	orr.w	r3, r3, #1
    c3c6:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
    pSkt->smState = newState;
    c3ca:	2300      	movs	r3, #0
    c3cc:	f885 306e 	strb.w	r3, [r5, #110]	; 0x6e
        pSkt->remoteHash = localPort;
    c3d0:	f8a5 b06a 	strh.w	fp, [r5, #106]	; 0x6a
}
    c3d4:	4620      	mov	r0, r4
    c3d6:	b003      	add	sp, #12
    c3d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        _TcpSocketKill(pSkt);
    c3dc:	4628      	mov	r0, r5
    c3de:	f010 f94f 	bl	1c680 <_TcpSocketKill>
        return INVALID_SOCKET;
    c3e2:	f04f 34ff 	mov.w	r4, #4294967295
    c3e6:	e7f5      	b.n	c3d4 <_TCP_Open+0x254>
            return INVALID_SOCKET;
    c3e8:	f04f 34ff 	mov.w	r4, #4294967295
    c3ec:	e7f2      	b.n	c3d4 <_TCP_Open+0x254>
    for(hTCP = 0; hTCP < TcpSockets; hTCP++)
    c3ee:	2400      	movs	r4, #0
    c3f0:	4626      	mov	r6, r4
    if(pSkt != 0)
    c3f2:	e6f8      	b.n	c1e6 <_TCP_Open+0x66>
        pSkt->localPort = localPort;
    c3f4:	f8a5 b05a 	strh.w	fp, [r5, #90]	; 0x5a
        pSkt->remotePort = remotePort;
    c3f8:	9b00      	ldr	r3, [sp, #0]
    c3fa:	f8a5 3058 	strh.w	r3, [r5, #88]	; 0x58
        pSkt->eventTime = SYS_TMR_TickCountGet();
    c3fe:	f013 fdd5 	bl	1ffac <SYS_TMR_TickCountGet>
    c402:	6268      	str	r0, [r5, #36]	; 0x24
        pSkt->Flags.bTimerEnabled = 1;
    c404:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
    c408:	f043 0302 	orr.w	r3, r3, #2
    c40c:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
                if(hostAddress != 0 && hostAddress->v4Add.Val != 0)
    c410:	9b01      	ldr	r3, [sp, #4]
    c412:	2b00      	cmp	r3, #0
    c414:	d090      	beq.n	c338 <_TCP_Open+0x1b8>
    c416:	681b      	ldr	r3, [r3, #0]
    c418:	2b00      	cmp	r3, #0
    c41a:	d08d      	beq.n	c338 <_TCP_Open+0x1b8>
                    pSkt->destAddress.Val = hostAddress->v4Add.Val;
    c41c:	63ab      	str	r3, [r5, #56]	; 0x38
    c41e:	e78b      	b.n	c338 <_TCP_Open+0x1b8>
            pSkt->pTxPkt = _TcpAllocateTxPacket (pSkt, IP_ADDRESS_TYPE_IPV4);
    c420:	6468      	str	r0, [r5, #68]	; 0x44
    if (pSkt->pTxPkt == 0 && pSkt->addType != IP_ADDRESS_TYPE_ANY)
    c422:	e76b      	b.n	c2fc <_TCP_Open+0x17c>
    c424:	2000e5a8 	.word	0x2000e5a8
    c428:	2000e598 	.word	0x2000e598
    c42c:	2000e594 	.word	0x2000e594
    c430:	2000e712 	.word	0x2000e712
    c434:	2000e516 	.word	0x2000e516
    c438:	2000e59c 	.word	0x2000e59c
    c43c:	00013735 	.word	0x00013735

Disassembly of section .text.TCPIP_ARP_Task%219:

0000c440 <TCPIP_ARP_Task>:

// called after service needed reported
// maintain the queues, processes, etc.

void TCPIP_ARP_Task(void)
{
    c440:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c444:	b087      	sub	sp, #28
               TCPIP_ARP_Probe(pIf, &pIf->netIPAddr, &pIf->netIPAddr, ARP_OPERATION_RESP | ARP_OPERATION_CONFIGURE | ARP_OPERATION_PROBE_ONLY);
           }
        }
    }
#else
    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    c446:	210f      	movs	r1, #15
    c448:	2002      	movs	r0, #2
    c44a:	f011 fd8f 	bl	1df6c <_TCPIPStackModuleSignalGet>
    c44e:	4606      	mov	r6, r0
#endif  // (_TCPIP_STACK_INTERFACE_CHANGE_SIGNALING != 0)
    
    if((sigPend & TCPIP_MODULE_SIGNAL_RX_PENDING) != 0)
    c450:	f010 0f01 	tst.w	r0, #1
    c454:	d106      	bne.n	c464 <TCPIP_ARP_Task+0x24>
    { //  RX signal occurred
        TCPIP_ARP_Process();
    }

    if((sigPend & TCPIP_MODULE_SIGNAL_TMO) != 0)
    c456:	f016 0f02 	tst.w	r6, #2
    c45a:	f040 8085 	bne.w	c568 <TCPIP_ARP_Task+0x128>
    { // regular TMO occurred
        TCPIP_ARP_Timeout();
    }

}
    c45e:	b007      	add	sp, #28
    c460:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    IPV4_ADDR targetAdd;
    IPV4_ADDR   algnSenderIpAddr;


    // extract queued ARP packets
    while((pPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
    c464:	2702      	movs	r7, #2
        // Validate the ARP packet
        if ( pArpPkt->HardwareType != HW_ETHERNET     ||
                pArpPkt->MACAddrLen != sizeof(TCPIP_MAC_ADDR)  ||
                pArpPkt->ProtocolLen != sizeof(IPV4_ADDR) )
        {
            ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    c466:	f06f 090d 	mvn.w	r9, #13
    c46a:	e009      	b.n	c480 <TCPIP_ARP_Task+0x40>
                pArpPkt->MACAddrLen != sizeof(TCPIP_MAC_ADDR)  ||
    c46c:	88a2      	ldrh	r2, [r4, #4]
    c46e:	f240 4306 	movw	r3, #1030	; 0x406
    c472:	429a      	cmp	r2, r3
    c474:	d013      	beq.n	c49e <TCPIP_ARP_Task+0x5e>
            ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    c476:	4649      	mov	r1, r9

        if(arpReqRes != ARP_RES_OK)
        {
        }

        TCPIP_PKT_PacketAcknowledge(pPkt, ackRes); 
    c478:	463a      	mov	r2, r7
    c47a:	4628      	mov	r0, r5
    c47c:	f011 fa8a 	bl	1d994 <_TCPIP_PKT_PacketAcknowledge>
    while((pPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
    c480:	4638      	mov	r0, r7
    c482:	f013 f999 	bl	1f7b8 <_TCPIPStackModuleRxExtract>
    c486:	4605      	mov	r5, r0
    c488:	2800      	cmp	r0, #0
    c48a:	d0e4      	beq.n	c456 <TCPIP_ARP_Task+0x16>
        pArpPkt = (ARP_PACKET*)pPkt->pNetLayer;
    c48c:	69ac      	ldr	r4, [r5, #24]
        _SwapARPPacket(pArpPkt);
    c48e:	4620      	mov	r0, r4
    c490:	f014 fa4e 	bl	20930 <_SwapARPPacket>
        if ( pArpPkt->HardwareType != HW_ETHERNET     ||
    c494:	8823      	ldrh	r3, [r4, #0]
    c496:	2b01      	cmp	r3, #1
    c498:	d0e8      	beq.n	c46c <TCPIP_ARP_Task+0x2c>
            ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    c49a:	4649      	mov	r1, r9
    c49c:	e7ec      	b.n	c478 <TCPIP_ARP_Task+0x38>
            targetAdd.Val = pArpPkt->TargetIPAddr.Val;
    c49e:	f8d4 a018 	ldr.w	sl, [r4, #24]
            pPkt->pktIf = pInIf = _TCPIPStackMapAliasInterface((TCPIP_NET_IF*)pPkt->pktIf, &targetAdd);
    c4a2:	f8d5 8028 	ldr.w	r8, [r5, #40]	; 0x28
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
    c4a6:	4b93      	ldr	r3, [pc, #588]	; (c6f4 <TCPIP_ARP_Task+0x2b4>)
    c4a8:	f8d3 b004 	ldr.w	fp, [r3, #4]
    c4ac:	4640      	mov	r0, r8
    c4ae:	f015 fbb1 	bl	21c14 <TCPIP_STACK_NetIxGet>
            algnSenderIpAddr.Val = pArpPkt->SenderIPAddr.Val;
    c4b2:	f8d4 300e 	ldr.w	r3, [r4, #14]
    c4b6:	9305      	str	r3, [sp, #20]
            hE = TCPIP_OAHASH_EntryLookup(pArpDcpt->hashDcpt, &algnSenderIpAddr.Val);
    c4b8:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
    c4bc:	a905      	add	r1, sp, #20
    c4be:	f85b 0030 	ldr.w	r0, [fp, r0, lsl #3]
    c4c2:	f00e fac7 	bl	1aa54 <TCPIP_OAHASH_EntryLookup>
            if(hE != 0)
    c4c6:	4683      	mov	fp, r0
    c4c8:	b128      	cbz	r0, c4d6 <TCPIP_ARP_Task+0x96>
                _ARPUpdateEntry(pInIf, (ARP_HASH_ENTRY*)hE, &pArpPkt->SenderMACAddr);
    c4ca:	f104 0208 	add.w	r2, r4, #8
    c4ce:	4601      	mov	r1, r0
    c4d0:	4640      	mov	r0, r8
    c4d2:	f00d fc45 	bl	19d60 <_ARPUpdateEntry>
            if(targetAdd.Val == pInIf->netIPAddr.Val)
    c4d6:	f8d8 3004 	ldr.w	r3, [r8, #4]
    c4da:	459a      	cmp	sl, r3
    c4dc:	d03d      	beq.n	c55a <TCPIP_ARP_Task+0x11a>
            ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    c4de:	4639      	mov	r1, r7
    c4e0:	e7ca      	b.n	c478 <TCPIP_ARP_Task+0x38>
                if(hE == 0)
    c4e2:	f1bb 0f00 	cmp.w	fp, #0
    c4e6:	d004      	beq.n	c4f2 <TCPIP_ARP_Task+0xb2>
                if(pArpPkt->Operation == ARP_OPERATION_REQ)
    c4e8:	88e3      	ldrh	r3, [r4, #6]
    c4ea:	2b01      	cmp	r3, #1
    c4ec:	d026      	beq.n	c53c <TCPIP_ARP_Task+0xfc>
            ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    c4ee:	4639      	mov	r1, r7
    c4f0:	e7c2      	b.n	c478 <TCPIP_ARP_Task+0x38>
                    arpReqRes = _ARPAddCompleteEntry(pInIf, &algnSenderIpAddr, &pArpPkt->SenderMACAddr);
    c4f2:	f104 0308 	add.w	r3, r4, #8
    c4f6:	9302      	str	r3, [sp, #8]
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
    c4f8:	497e      	ldr	r1, [pc, #504]	; (c6f4 <TCPIP_ARP_Task+0x2b4>)
    c4fa:	f8d1 a004 	ldr.w	sl, [r1, #4]
    c4fe:	4640      	mov	r0, r8
    c500:	f015 fb88 	bl	21c14 <TCPIP_STACK_NetIxGet>
    c504:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
    c508:	eb0a 0bc0 	add.w	fp, sl, r0, lsl #3
    hE = TCPIP_OAHASH_EntryLookupOrInsert(pArpDcpt->hashDcpt, pIPAddr);
    c50c:	a905      	add	r1, sp, #20
    c50e:	f85a 0030 	ldr.w	r0, [sl, r0, lsl #3]
    c512:	f00e fc9f 	bl	1ae54 <TCPIP_OAHASH_EntryLookupOrInsert>
    if(hE == 0)
    c516:	2800      	cmp	r0, #0
    c518:	d0e6      	beq.n	c4e8 <TCPIP_ARP_Task+0xa8>
    if(arpHE->hEntry.flags.newEntry != 0)
    c51a:	7803      	ldrb	r3, [r0, #0]
    c51c:	f013 0f02 	tst.w	r3, #2
    c520:	d006      	beq.n	c530 <TCPIP_ARP_Task+0xf0>
        _ARPSetEntry(arpHE, ARP_FLAG_ENTRY_COMPLETE, hwAdd, &pArpDcpt->completeList);
    c522:	f10b 0318 	add.w	r3, fp, #24
    c526:	9a02      	ldr	r2, [sp, #8]
    c528:	2180      	movs	r1, #128	; 0x80
    c52a:	f012 f995 	bl	1e858 <_ARPSetEntry>
    c52e:	e7db      	b.n	c4e8 <TCPIP_ARP_Task+0xa8>
        _ARPUpdateEntry(pIf, arpHE, hwAdd);
    c530:	9a02      	ldr	r2, [sp, #8]
    c532:	4601      	mov	r1, r0
    c534:	4640      	mov	r0, r8
    c536:	f00d fc13 	bl	19d60 <_ARPUpdateEntry>
    c53a:	e7d5      	b.n	c4e8 <TCPIP_ARP_Task+0xa8>
                    if(!_ARPSendIfPkt(pInIf, ARP_OPERATION_RESP, (uint32_t)pTgtIf->netIPAddr.Val, (uint32_t)pArpPkt->SenderIPAddr.Val, &pArpPkt->SenderMACAddr, &pTgtIf->netMACAddr))
    c53c:	f8d4 300e 	ldr.w	r3, [r4, #14]
    c540:	f8d8 2004 	ldr.w	r2, [r8, #4]
    c544:	f108 013c 	add.w	r1, r8, #60	; 0x3c
    c548:	9101      	str	r1, [sp, #4]
    c54a:	3408      	adds	r4, #8
    c54c:	9400      	str	r4, [sp, #0]
    c54e:	4639      	mov	r1, r7
    c550:	4640      	mov	r0, r8
    c552:	f00a f947 	bl	167e4 <_ARPSendIfPkt>
            ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    c556:	4639      	mov	r1, r7
    c558:	e78e      	b.n	c478 <TCPIP_ARP_Task+0x38>
// helper to check if an address service is running
TCPIP_STACK_ADDRESS_SERVICE_TYPE _TCPIPStackAddressServiceIsRunning(TCPIP_NET_IF* pNetIf);

static __inline__ bool __attribute__((always_inline)) _TCPIPStackIsConfig(TCPIP_NET_IF* pNetIf)
{
    return pNetIf->Flags.bInConfig != 0;
    c55a:	f898 3043 	ldrb.w	r3, [r8, #67]	; 0x43
            while( pTgtIf != 0 && !_TCPIPStackIsConfig(pTgtIf))
    c55e:	f013 0f10 	tst.w	r3, #16
    c562:	d0be      	beq.n	c4e2 <TCPIP_ARP_Task+0xa2>
            ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    c564:	4639      	mov	r1, r7
    c566:	e787      	b.n	c478 <TCPIP_ARP_Task+0x38>
    arpMod.timeMs += TCPIP_ARP_TASK_PROCESS_RATE;
    c568:	4c62      	ldr	r4, [pc, #392]	; (c6f4 <TCPIP_ARP_Task+0x2b4>)
    c56a:	69a3      	ldr	r3, [r4, #24]
    c56c:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
    c570:	61a3      	str	r3, [r4, #24]
    arpMod.timeSeconds = arpMod.timeMs / 1000;
    c572:	4a61      	ldr	r2, [pc, #388]	; (c6f8 <TCPIP_ARP_Task+0x2b8>)
    c574:	fba2 2303 	umull	r2, r3, r2, r3
    c578:	099b      	lsrs	r3, r3, #6
    c57a:	6163      	str	r3, [r4, #20]
    nArpIfs = TCPIP_STACK_NumberOfNetworksGet();
    c57c:	f015 fcc2 	bl	21f04 <TCPIP_STACK_NumberOfNetworksGet>
    pArpDcpt = arpMod.arpCacheDcpt;
    c580:	6867      	ldr	r7, [r4, #4]
    for(netIx = 0; netIx < nArpIfs; netIx++)
    c582:	1e03      	subs	r3, r0, #0
    c584:	9303      	str	r3, [sp, #12]
    c586:	f77f af6a 	ble.w	c45e <TCPIP_ARP_Task+0x1e>
    c58a:	f107 0648 	add.w	r6, r7, #72	; 0x48
    c58e:	3718      	adds	r7, #24
    c590:	f04f 0b00 	mov.w	fp, #0
    c594:	e05c      	b.n	c650 <TCPIP_ARP_Task+0x210>
                    _ARPSendIfPkt(pIf, ARP_OPERATION_REQ, (uint32_t)pIf->netIPAddr.Val, pE->ipAddress.Val, &arpBcastAdd, 0);
    c596:	686b      	ldr	r3, [r5, #4]
    c598:	9802      	ldr	r0, [sp, #8]
    c59a:	6842      	ldr	r2, [r0, #4]
    c59c:	f8cd a004 	str.w	sl, [sp, #4]
    c5a0:	4956      	ldr	r1, [pc, #344]	; (c6fc <TCPIP_ARP_Task+0x2bc>)
    c5a2:	9100      	str	r1, [sp, #0]
    c5a4:	2101      	movs	r1, #1
    c5a6:	f00a f91d 	bl	167e4 <_ARPSendIfPkt>
                    pE->nRetries++;
    c5aa:	8a6b      	ldrh	r3, [r5, #18]
    c5ac:	3301      	adds	r3, #1
    c5ae:	826b      	strh	r3, [r5, #18]
        for(pN = pArpDcpt->incompleteList.list.head; pN != 0; pN = pN->next)
    c5b0:	682d      	ldr	r5, [r5, #0]
    c5b2:	b1d5      	cbz	r5, c5ea <TCPIP_ARP_Task+0x1aa>
            if((pE->hEntry.flags.value & ARP_FLAG_ENTRY_GRATUITOUS) != 0)
    c5b4:	f835 1c04 	ldrh.w	r1, [r5, #-4]
    c5b8:	f411 7f00 	tst.w	r1, #512	; 0x200
                maxRetries = arpMod.entryGratRetries;
    c5bc:	bf14      	ite	ne
    c5be:	f8b4 3046 	ldrhne.w	r3, [r4, #70]	; 0x46
                maxRetries = arpMod.entryRetries;
    c5c2:	f8b4 3044 	ldrheq.w	r3, [r4, #68]	; 0x44
            if( pE->nRetries < maxRetries && (arpMod.timeSeconds - pE->tInsert) >= pE->nRetries * arpMod.entryRetryTmo)
    c5c6:	8a68      	ldrh	r0, [r5, #18]
    c5c8:	4298      	cmp	r0, r3
    c5ca:	d2f1      	bcs.n	c5b0 <TCPIP_ARP_Task+0x170>
    c5cc:	6962      	ldr	r2, [r4, #20]
    c5ce:	68ab      	ldr	r3, [r5, #8]
    c5d0:	1ad2      	subs	r2, r2, r3
    c5d2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c5d4:	fb03 f300 	mul.w	r3, r3, r0
    c5d8:	429a      	cmp	r2, r3
    c5da:	d3e9      	bcc.n	c5b0 <TCPIP_ARP_Task+0x170>
                if(isConfig == false || (pE->hEntry.flags.value & ARP_FLAG_ENTRY_CONFIGURE) != 0 )
    c5dc:	f1b9 0f00 	cmp.w	r9, #0
    c5e0:	d0d9      	beq.n	c596 <TCPIP_ARP_Task+0x156>
    c5e2:	f411 7f80 	tst.w	r1, #256	; 0x100
    c5e6:	d0e3      	beq.n	c5b0 <TCPIP_ARP_Task+0x170>
    c5e8:	e7d5      	b.n	c596 <TCPIP_ARP_Task+0x156>
        while( (pN = pArpDcpt->completeList.list.head) != 0)
    c5ea:	f858 5c30 	ldr.w	r5, [r8, #-48]
    c5ee:	b305      	cbz	r5, c632 <TCPIP_ARP_Task+0x1f2>
            if( (arpMod.timeSeconds - pE->tInsert) >= arpMod.entrySolvedTmo)
    c5f0:	6963      	ldr	r3, [r4, #20]
    c5f2:	68aa      	ldr	r2, [r5, #8]
    c5f4:	1a9b      	subs	r3, r3, r2
    c5f6:	6b62      	ldr	r2, [r4, #52]	; 0x34
    c5f8:	4293      	cmp	r3, r2
    c5fa:	d31a      	bcc.n	c632 <TCPIP_ARP_Task+0x1f2>
                _ARPNotifyClients(pIf, &pE->ipAddress, 0, ARP_EVENT_REMOVED_EXPIRED);
    c5fc:	f06f 0a02 	mvn.w	sl, #2
    c600:	f04f 0900 	mov.w	r9, #0
                TCPIP_OAHASH_EntryRemove(pArpDcpt->hashDcpt, &pE->hEntry);
    c604:	1f29      	subs	r1, r5, #4
    c606:	f858 0c48 	ldr.w	r0, [r8, #-72]
    c60a:	f014 fef3 	bl	213f4 <TCPIP_OAHASH_EntryRemove>
                TCPIP_Helper_ProtectedSingleListHeadRemove(&pArpDcpt->completeList);
    c60e:	4638      	mov	r0, r7
    c610:	f013 f8a6 	bl	1f760 <TCPIP_Helper_ProtectedSingleListHeadRemove>
                _ARPNotifyClients(pIf, &pE->ipAddress, 0, ARP_EVENT_REMOVED_EXPIRED);
    c614:	4653      	mov	r3, sl
    c616:	464a      	mov	r2, r9
    c618:	1d29      	adds	r1, r5, #4
    c61a:	9802      	ldr	r0, [sp, #8]
    c61c:	f00f fb6a 	bl	1bcf4 <_ARPNotifyClients>
        while( (pN = pArpDcpt->completeList.list.head) != 0)
    c620:	f858 5c30 	ldr.w	r5, [r8, #-48]
    c624:	b12d      	cbz	r5, c632 <TCPIP_ARP_Task+0x1f2>
            if( (arpMod.timeSeconds - pE->tInsert) >= arpMod.entrySolvedTmo)
    c626:	6963      	ldr	r3, [r4, #20]
    c628:	68aa      	ldr	r2, [r5, #8]
    c62a:	1a9b      	subs	r3, r3, r2
    c62c:	6b62      	ldr	r2, [r4, #52]	; 0x34
    c62e:	4293      	cmp	r3, r2
    c630:	d2e8      	bcs.n	c604 <TCPIP_ARP_Task+0x1c4>
        if(pArpDcpt->hashDcpt->fullSlots >= pArpDcpt->purgeThres)
    c632:	f858 3c48 	ldr.w	r3, [r8, #-72]
    c636:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    c638:	f858 3c08 	ldr.w	r3, [r8, #-8]
    c63c:	429a      	cmp	r2, r3
    c63e:	d23a      	bcs.n	c6b6 <TCPIP_ARP_Task+0x276>
    for(netIx = 0; netIx < nArpIfs; netIx++)
    c640:	f10b 0b01 	add.w	fp, fp, #1
    c644:	3648      	adds	r6, #72	; 0x48
    c646:	3748      	adds	r7, #72	; 0x48
    c648:	9b03      	ldr	r3, [sp, #12]
    c64a:	455b      	cmp	r3, fp
    c64c:	f43f af07 	beq.w	c45e <TCPIP_ARP_Task+0x1e>
        pIf = (TCPIP_NET_IF*)TCPIP_STACK_IndexToNet(netIx);
    c650:	4658      	mov	r0, fp
    c652:	f013 fbe3 	bl	1fe1c <TCPIP_STACK_IndexToNet>
    c656:	9002      	str	r0, [sp, #8]
TCPIP_NET_IF* _TCPIPStackMapAliasInterface(TCPIP_NET_IF* pNetIf, const IPV4_ADDR* pDestAddress);

#else
static __inline__ bool  __attribute__((always_inline)) _TCPIPStackNetIsPrimary(TCPIP_NET_IF* pNetIf)
{
    return true;
    c658:	46b0      	mov	r8, r6
        while( (pN = pArpDcpt->incompleteList.list.head) != 0)
    c65a:	f856 5c1c 	ldr.w	r5, [r6, #-28]
    c65e:	2d00      	cmp	r5, #0
    c660:	d0c3      	beq.n	c5ea <TCPIP_ARP_Task+0x1aa>
            if( (arpMod.timeSeconds - pE->tInsert) >= arpMod.entryPendingTmo)
    c662:	6963      	ldr	r3, [r4, #20]
    c664:	68aa      	ldr	r2, [r5, #8]
    c666:	1a9b      	subs	r3, r3, r2
    c668:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    c66a:	4293      	cmp	r3, r2
    c66c:	d31b      	bcc.n	c6a6 <TCPIP_ARP_Task+0x266>
                TCPIP_Helper_ProtectedSingleListHeadRemove(&pArpDcpt->incompleteList);
    c66e:	f107 0a14 	add.w	sl, r7, #20
                _ARPNotifyClients(pIf, &pE->ipAddress, 0, ARP_EVENT_REMOVED_TMO);
    c672:	f04f 39ff 	mov.w	r9, #4294967295
                TCPIP_OAHASH_EntryRemove(pArpDcpt->hashDcpt, &pE->hEntry);
    c676:	1f29      	subs	r1, r5, #4
    c678:	f858 0c48 	ldr.w	r0, [r8, #-72]
    c67c:	f014 feba 	bl	213f4 <TCPIP_OAHASH_EntryRemove>
                TCPIP_Helper_ProtectedSingleListHeadRemove(&pArpDcpt->incompleteList);
    c680:	4650      	mov	r0, sl
    c682:	f013 f86d 	bl	1f760 <TCPIP_Helper_ProtectedSingleListHeadRemove>
                _ARPNotifyClients(pIf, &pE->ipAddress, 0, ARP_EVENT_REMOVED_TMO);
    c686:	464b      	mov	r3, r9
    c688:	2200      	movs	r2, #0
    c68a:	1d29      	adds	r1, r5, #4
    c68c:	9802      	ldr	r0, [sp, #8]
    c68e:	f00f fb31 	bl	1bcf4 <_ARPNotifyClients>
        while( (pN = pArpDcpt->incompleteList.list.head) != 0)
    c692:	f858 5c1c 	ldr.w	r5, [r8, #-28]
    c696:	2d00      	cmp	r5, #0
    c698:	d0a7      	beq.n	c5ea <TCPIP_ARP_Task+0x1aa>
            if( (arpMod.timeSeconds - pE->tInsert) >= arpMod.entryPendingTmo)
    c69a:	6963      	ldr	r3, [r4, #20]
    c69c:	68aa      	ldr	r2, [r5, #8]
    c69e:	1a9b      	subs	r3, r3, r2
    c6a0:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    c6a2:	4293      	cmp	r3, r2
    c6a4:	d2e7      	bcs.n	c676 <TCPIP_ARP_Task+0x236>
    return pNetIf->Flags.bInConfig != 0;
    c6a6:	9b02      	ldr	r3, [sp, #8]
    c6a8:	f893 9043 	ldrb.w	r9, [r3, #67]	; 0x43
    c6ac:	f009 0910 	and.w	r9, r9, #16
                    _ARPSendIfPkt(pIf, ARP_OPERATION_REQ, (uint32_t)pIf->netIPAddr.Val, pE->ipAddress.Val, &arpBcastAdd, 0);
    c6b0:	f04f 0a00 	mov.w	sl, #0
    c6b4:	e77e      	b.n	c5b4 <TCPIP_ARP_Task+0x174>
            for(purgeIx = 0; purgeIx < pArpDcpt->purgeQuanta; purgeIx++)
    c6b6:	f858 3c04 	ldr.w	r3, [r8, #-4]
    c6ba:	2b00      	cmp	r3, #0
    c6bc:	d0c0      	beq.n	c640 <TCPIP_ARP_Task+0x200>
    c6be:	2500      	movs	r5, #0
                    _ARPNotifyClients(pIf, &pE->ipAddress, 0, ARP_EVENT_REMOVED_PURGED);
    c6c0:	f06f 0a03 	mvn.w	sl, #3
                pN = TCPIP_Helper_ProtectedSingleListHeadRemove(&pArpDcpt->completeList);
    c6c4:	4638      	mov	r0, r7
    c6c6:	f013 f84b 	bl	1f760 <TCPIP_Helper_ProtectedSingleListHeadRemove>
                if(pN)
    c6ca:	4681      	mov	r9, r0
    c6cc:	2800      	cmp	r0, #0
    c6ce:	d0b7      	beq.n	c640 <TCPIP_ARP_Task+0x200>
                    TCPIP_OAHASH_EntryRemove(pArpDcpt->hashDcpt, &pE->hEntry);
    c6d0:	1f01      	subs	r1, r0, #4
    c6d2:	f858 0c48 	ldr.w	r0, [r8, #-72]
    c6d6:	f014 fe8d 	bl	213f4 <TCPIP_OAHASH_EntryRemove>
                    _ARPNotifyClients(pIf, &pE->ipAddress, 0, ARP_EVENT_REMOVED_PURGED);
    c6da:	4653      	mov	r3, sl
    c6dc:	2200      	movs	r2, #0
    c6de:	f109 0104 	add.w	r1, r9, #4
    c6e2:	9802      	ldr	r0, [sp, #8]
    c6e4:	f00f fb06 	bl	1bcf4 <_ARPNotifyClients>
            for(purgeIx = 0; purgeIx < pArpDcpt->purgeQuanta; purgeIx++)
    c6e8:	3501      	adds	r5, #1
    c6ea:	f858 3c04 	ldr.w	r3, [r8, #-4]
    c6ee:	429d      	cmp	r5, r3
    c6f0:	d3e8      	bcc.n	c6c4 <TCPIP_ARP_Task+0x284>
    c6f2:	e7a5      	b.n	c640 <TCPIP_ARP_Task+0x200>
    c6f4:	2000e1a4 	.word	0x2000e1a4
    c6f8:	10624dd3 	.word	0x10624dd3
    c6fc:	2000e570 	.word	0x2000e570

Disassembly of section .rodata.sysfont_glyphs%220:

0000c700 <sysfont_glyphs>:
    c700:	00000000 20000000 20202020 50502000     .......     . PP
    c710:	00000050 f8505000 5050f850 70a07820     P....PP.P.PP x.p
    c720:	c020f028 402010c8 90601898 90a840a0     (. ... @..`..@..
    c730:	40206068 00000000 40402010 40102040     h` @..... @@@ .@
    c740:	10101020 50004020 5020f820 20200000      ... @.P . P..  
    c750:	002020f8 00000000 00402060 00f80000     .  .....` @.....
    c760:	00000000 60000000 10080060 00804020     .......``... @..
    c770:	a8988870 207088c8 20202060 88707020     p.....p `    pp.
    c780:	40201008 2010f8f8 70880810 90503010     .. @... ...p.0P.
    c790:	f81010f8 0808f080 40307088 8888f080     .........p0@....
    c7a0:	1008f870 40404020 70888870 70708888     p... @@@p..p..pp
    c7b0:	08788888 60006010 60600060 60600000     ..x..`.``.``..``
    c7c0:	40206000 40201008 00081020 f800f800     .` @.. @ .......
    c7d0:	40800000 40201020 08887080 20002010     ...@ . @.p... . 
    c7e0:	68088870 7070a8a8 f8888888 88f08888     p..h..pp........
    c7f0:	8888f088 808870f0 70888080 888890e0     .....p.....p....
    c800:	f8e09088 80f08080 80f8f880 8080e080     ................
    c810:	80887080 70889880 f8888888 70888888     .p.....p.......p
    c820:	20202020 10387020 90101010 a0908860          p8.....`...
    c830:	8890a0c0 80808080 88f88080 8888a8d8     ................
    c840:	88888888 8898a8c8 88887088 70888888     .........p.....p
    c850:	f08888f0 70808080 a8888888 88f06890     .......p.....h..
    c860:	90a0f088 80807888 f0080870 202020f8     .....x..p....   
    c870:	88202020 88888888 88887088 50888888        ......p.....P
    c880:	88888820 88d8a8a8 20508888 88888850      .........P P...
    c890:	20205088 08f82020 80402010 202038f8     .P    ... @..8  
    c8a0:	38202020 20408000 e0000810 20202020        8..@ ....    
    c8b0:	5020e020 00000088 00000000 f8000000      . P............
    c8c0:	00102040 00000000 78087000 80807888     @ .......p.x.x..
    c8d0:	8888c8b0 700000f0 70888080 98680808     .......p...p..h.
    c8e0:	00788888 f8887000 48307080 4040e040     ..x..p...p0H@.@@
    c8f0:	78000040 30087888 c8b08080 20888888     @..x.x.0....... 
    c900:	20206000 00107020 90101030 48404060     .`   p..0...`@@H
    c910:	48506050 20202060 00702020 a8a8d000     P`PH`     p.....
    c920:	00008888 8888c8b0 70000088 70888888     ...........p...p
    c930:	88f00000 008080f0 78986800 00000808     .........h.x....
    c940:	8080c8b0 70000080 f0087080 40e04040     .......p.p..@@.@
    c950:	00304840 88888800 00006898 50888888     @H0......h.....P
    c960:	88000020 50a8a888 50880000 00885020      ......P...P P..
    c970:	78888800 00007008 402010f8 202010f8     ...x.p.... @..  
    c980:	10202040 20202020 40202020 20102020     @  .       @  . 
    c990:	bf004020                                 @..

Disassembly of section .text._DNS_Send_Query%221:

0000c994 <_DNS_Send_Query>:
{
    c994:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c998:	b089      	sub	sp, #36	; 0x24
    c99a:	4680      	mov	r8, r0
    c99c:	460c      	mov	r4, r1
    UDP_SOCKET          dnsSocket = pDnsDcpt->dnsSocket;
    c99e:	f9b0 6024 	ldrsh.w	r6, [r0, #36]	; 0x24
    pDnsHE->hEntry.flags.value &= ~TCPIP_DNS_FLAG_ENTRY_COMPLETE;
    c9a2:	880b      	ldrh	r3, [r1, #0]
    c9a4:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    c9a8:	800b      	strh	r3, [r1, #0]
        int oldServerIx = pDnsHE->currServerIx; // store the previously used DNS server index
    c9aa:	f891 5029 	ldrb.w	r5, [r1, #41]	; 0x29
        TCPIP_NET_IF* oldIf = pDnsHE->currNet;
    c9ae:	f8d1 901c 	ldr.w	r9, [r1, #28]
    if(pDnsDcpt->strictNet != 0)
    c9b2:	6840      	ldr	r0, [r0, #4]
    c9b4:	2800      	cmp	r0, #0
    c9b6:	d065      	beq.n	ca84 <_DNS_Send_Query+0xf0>
        return _DNS_ValidateIf(pDnsDcpt->strictNet, pDnsHE, true);
    c9b8:	2201      	movs	r2, #1
    c9ba:	f00c fa10 	bl	18dde <_DNS_ValidateIf>
        if(!_DNS_SelectIntf(pDnsDcpt, pDnsHE))
    c9be:	2800      	cmp	r0, #0
    c9c0:	d05e      	beq.n	ca80 <_DNS_Send_Query+0xec>
        if(oldIf == 0)
    c9c2:	f1b9 0f00 	cmp.w	r9, #0
    c9c6:	f000 80af 	beq.w	cb28 <_DNS_Send_Query+0x194>
        if(pDnsHE->currServerIx != oldServerIx || pDnsHE->currNet != oldIf )
    c9ca:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
    c9ce:	42ab      	cmp	r3, r5
    c9d0:	f000 80b2 	beq.w	cb38 <_DNS_Send_Query+0x1a4>
            IPV4_ADDR oldDns = oldIf->dnsServer[oldServerIx];
    c9d4:	3504      	adds	r5, #4
    c9d6:	f859 3025 	ldr.w	r3, [r9, r5, lsl #2]
    c9da:	9300      	str	r3, [sp, #0]
            if(oldDns.Val != 0)
    c9dc:	2b00      	cmp	r3, #0
    c9de:	f040 80b0 	bne.w	cb42 <_DNS_Send_Query+0x1ae>
        if(!TCPIP_UDP_PutIsReady(dnsSocket))
    c9e2:	4630      	mov	r0, r6
    c9e4:	f00f fdff 	bl	1c5e6 <TCPIP_UDP_PutIsReady>
    c9e8:	2800      	cmp	r0, #0
    c9ea:	f000 80af 	beq.w	cb4c <_DNS_Send_Query+0x1b8>
        TCPIP_UDP_TxOffsetSet(dnsSocket, 0, false);    
    c9ee:	2200      	movs	r2, #0
    c9f0:	4611      	mov	r1, r2
    c9f2:	4630      	mov	r0, r6
    c9f4:	f011 f98b 	bl	1dd0e <TCPIP_UDP_TxOffsetSet>
        wrPtr = TCPIP_UDP_TxPointerGet(dnsSocket);
    c9f8:	4630      	mov	r0, r6
    c9fa:	f014 fc12 	bl	21222 <TCPIP_UDP_TxPointerGet>
        if(wrPtr == 0)
    c9fe:	4607      	mov	r7, r0
    ca00:	2800      	cmp	r0, #0
    ca02:	f000 80a6 	beq.w	cb52 <_DNS_Send_Query+0x1be>
        TCPIP_UDP_Bind(dnsSocket, IP_ADDRESS_TYPE_IPV4, 0, (IP_MULTI_ADDRESS*)&pDnsHE->currNet->netIPAddr);
    ca06:	69e3      	ldr	r3, [r4, #28]
    ca08:	3304      	adds	r3, #4
    ca0a:	2200      	movs	r2, #0
    ca0c:	2101      	movs	r1, #1
    ca0e:	4630      	mov	r0, r6
    ca10:	f005 ff58 	bl	128c4 <TCPIP_UDP_Bind>
        dnsServerAdd.Val = pDnsHE->currNet->dnsServer[pDnsHE->currServerIx].Val;
    ca14:	69e2      	ldr	r2, [r4, #28]
    ca16:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
    ca1a:	3304      	adds	r3, #4
    ca1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ca20:	9304      	str	r3, [sp, #16]
        TCPIP_UDP_DestinationIPAddressSet(dnsSocket, pDnsDcpt->ipAddressType, (IP_MULTI_ADDRESS*)&dnsServerAdd);
    ca22:	aa04      	add	r2, sp, #16
    ca24:	f898 1018 	ldrb.w	r1, [r8, #24]
    ca28:	4630      	mov	r0, r6
    ca2a:	f00f ffa3 	bl	1c974 <TCPIP_UDP_DestinationIPAddressSet>
        TCPIP_UDP_DestinationPortSet(dnsSocket, TCPIP_DNS_SERVER_PORT);
    ca2e:	2135      	movs	r1, #53	; 0x35
    ca30:	4630      	mov	r0, r6
    ca32:	f013 fffd 	bl	20a30 <TCPIP_UDP_DestinationPortSet>
    ca36:	f00e f8dd 	bl	1abf4 <rand>
        pDnsHE->transactionId.Val = (uint16_t)SYS_RANDOM_PseudoGet();
    ca3a:	b283      	uxth	r3, r0
    ca3c:	84a3      	strh	r3, [r4, #36]	; 0x24
    ca3e:	0200      	lsls	r0, r0, #8
    ca40:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    ca44:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
    ca48:	ea40 2013 	orr.w	r0, r0, r3, lsr #8
        DNSPutHeader.TransactionID.Val = TCPIP_Helper_htons(pDnsHE->transactionId.Val);
    ca4c:	f8ad 0014 	strh.w	r0, [sp, #20]
        DNSPutHeader.Flags.Val = TCPIP_Helper_htons(0x0100); // Standard query with recursion
    ca50:	2301      	movs	r3, #1
    ca52:	f8ad 3016 	strh.w	r3, [sp, #22]
        DNSPutHeader.Questions.Val = TCPIP_Helper_htons(0x0001); // questions
    ca56:	f44f 7380 	mov.w	r3, #256	; 0x100
    ca5a:	f8ad 3018 	strh.w	r3, [sp, #24]
        DNSPutHeader.Answers.Val = DNSPutHeader.AuthoritativeRecords.Val = DNSPutHeader.AdditionalRecords.Val = 0;
    ca5e:	2300      	movs	r3, #0
    ca60:	f8ad 301e 	strh.w	r3, [sp, #30]
    ca64:	f8ad 301c 	strh.w	r3, [sp, #28]
    ca68:	f8ad 301a 	strh.w	r3, [sp, #26]
        memcpy(wrPtr, &DNSPutHeader, sizeof(TCPIP_DNS_HEADER));
    ca6c:	ab05      	add	r3, sp, #20
    ca6e:	cb07      	ldmia	r3!, {r0, r1, r2}
    ca70:	6038      	str	r0, [r7, #0]
    ca72:	6079      	str	r1, [r7, #4]
    ca74:	60ba      	str	r2, [r7, #8]
        wrPtr += sizeof(TCPIP_DNS_HEADER);
    ca76:	f107 050c 	add.w	r5, r7, #12
        _DNSPutString(&wrPtr, pDnsHE->pHostName);
    ca7a:	6a21      	ldr	r1, [r4, #32]
    rightPtr = string;
    ca7c:	4688      	mov	r8, r1
    ca7e:	e0b8      	b.n	cbf2 <_DNS_Send_Query+0x25e>
            res = TCPIP_DNS_RES_NO_INTERFACE;
    ca80:	3807      	subs	r0, #7
    ca82:	e09a      	b.n	cbba <_DNS_Send_Query+0x226>
    memset(dnsSelectIfs, 0, sizeof(dnsSelectIfs));
    ca84:	2300      	movs	r3, #0
    ca86:	9300      	str	r3, [sp, #0]
    ca88:	9301      	str	r3, [sp, #4]
    ca8a:	9302      	str	r3, [sp, #8]
    ca8c:	9303      	str	r3, [sp, #12]
    _DNS_AddSelectionIf(pDnsDcpt->prefNet, dnsSelectIfs, sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs));
    ca8e:	2204      	movs	r2, #4
    ca90:	4669      	mov	r1, sp
    ca92:	f8d8 0008 	ldr.w	r0, [r8, #8]
    ca96:	f00d ffa9 	bl	1a9ec <_DNS_AddSelectionIf>
    _DNS_AddSelectionIf(pDnsHE->currNet, dnsSelectIfs, sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs));
    ca9a:	2204      	movs	r2, #4
    ca9c:	4669      	mov	r1, sp
    ca9e:	69e0      	ldr	r0, [r4, #28]
    caa0:	f00d ffa4 	bl	1a9ec <_DNS_AddSelectionIf>
    _DNS_AddSelectionIf((TCPIP_NET_IF*)TCPIP_STACK_NetDefaultGet(), dnsSelectIfs, sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs));
    caa4:	f015 fa28 	bl	21ef8 <TCPIP_STACK_NetDefaultGet>
    caa8:	2204      	movs	r2, #4
    caaa:	4669      	mov	r1, sp
    caac:	f00d ff9e 	bl	1a9ec <_DNS_AddSelectionIf>
    nIfs = TCPIP_STACK_NumberOfNetworksGet();
    cab0:	f015 fa28 	bl	21f04 <TCPIP_STACK_NumberOfNetworksGet>
    for(ix = 0; ix < nIfs; ix++)
    cab4:	f1b0 0a00 	subs.w	sl, r0, #0
    cab8:	dd0d      	ble.n	cad6 <_DNS_Send_Query+0x142>
    caba:	2700      	movs	r7, #0
       if(!_DNS_AddSelectionIf((TCPIP_NET_IF*)TCPIP_STACK_IndexToNet(ix), dnsSelectIfs, sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs)))
    cabc:	f04f 0b04 	mov.w	fp, #4
    cac0:	4638      	mov	r0, r7
    cac2:	f013 f9ab 	bl	1fe1c <TCPIP_STACK_IndexToNet>
    cac6:	465a      	mov	r2, fp
    cac8:	4669      	mov	r1, sp
    caca:	f00d ff8f 	bl	1a9ec <_DNS_AddSelectionIf>
    cace:	b110      	cbz	r0, cad6 <_DNS_Send_Query+0x142>
    for(ix = 0; ix < nIfs; ix++)
    cad0:	3701      	adds	r7, #1
    cad2:	45ba      	cmp	sl, r7
    cad4:	d1f4      	bne.n	cac0 <_DNS_Send_Query+0x12c>
    for(ix = 0; ix < sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs); ix++)
    cad6:	46eb      	mov	fp, sp
    cad8:	a904      	add	r1, sp, #16
    for(ix = 0; ix < nIfs; ix++)
    cada:	465b      	mov	r3, fp
    nIfs = 0;
    cadc:	f04f 0a00 	mov.w	sl, #0
    cae0:	e001      	b.n	cae6 <_DNS_Send_Query+0x152>
    for(ix = 0; ix < sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs); ix++)
    cae2:	428b      	cmp	r3, r1
    cae4:	d006      	beq.n	caf4 <_DNS_Send_Query+0x160>
        if(dnsSelectIfs[ix] != 0)
    cae6:	f853 2b04 	ldr.w	r2, [r3], #4
    caea:	2a00      	cmp	r2, #0
    caec:	d0f9      	beq.n	cae2 <_DNS_Send_Query+0x14e>
            nIfs++;
    caee:	f10a 0a01 	add.w	sl, sl, #1
    caf2:	e7f6      	b.n	cae2 <_DNS_Send_Query+0x14e>
    for(ix = 0; ix < sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs); ix++)
    caf4:	2700      	movs	r7, #0
            if(_DNS_ValidateIf(pDnsIf, pDnsHE, (ix == nIfs - 1)))
    caf6:	f10a 3aff 	add.w	sl, sl, #4294967295
    cafa:	e002      	b.n	cb02 <_DNS_Send_Query+0x16e>
    for(ix = 0; ix < sizeof(dnsSelectIfs) / sizeof(*dnsSelectIfs); ix++)
    cafc:	3701      	adds	r7, #1
    cafe:	2f04      	cmp	r7, #4
    cb00:	d00d      	beq.n	cb1e <_DNS_Send_Query+0x18a>
        if((pDnsIf = dnsSelectIfs[ix]) != 0)
    cb02:	f85b 0b04 	ldr.w	r0, [fp], #4
    cb06:	2800      	cmp	r0, #0
    cb08:	d0f8      	beq.n	cafc <_DNS_Send_Query+0x168>
            if(_DNS_ValidateIf(pDnsIf, pDnsHE, (ix == nIfs - 1)))
    cb0a:	45ba      	cmp	sl, r7
    cb0c:	bf14      	ite	ne
    cb0e:	2200      	movne	r2, #0
    cb10:	2201      	moveq	r2, #1
    cb12:	4621      	mov	r1, r4
    cb14:	f00c f963 	bl	18dde <_DNS_ValidateIf>
    cb18:	2800      	cmp	r0, #0
    cb1a:	d0ef      	beq.n	cafc <_DNS_Send_Query+0x168>
    cb1c:	e751      	b.n	c9c2 <_DNS_Send_Query+0x2e>
    pDnsHE->currNet = 0;    // make sure next time we start with a fresh interface
    cb1e:	2300      	movs	r3, #0
    cb20:	61e3      	str	r3, [r4, #28]
            res = TCPIP_DNS_RES_NO_INTERFACE;
    cb22:	f06f 0006 	mvn.w	r0, #6
    cb26:	e048      	b.n	cbba <_DNS_Send_Query+0x226>
            oldIf = pDnsHE->currNet; 
    cb28:	f8d4 901c 	ldr.w	r9, [r4, #28]
        if(pDnsHE->currServerIx != oldServerIx || pDnsHE->currNet != oldIf )
    cb2c:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
    cb30:	42ab      	cmp	r3, r5
    cb32:	f47f af4f 	bne.w	c9d4 <_DNS_Send_Query+0x40>
    cb36:	e754      	b.n	c9e2 <_DNS_Send_Query+0x4e>
    cb38:	69e3      	ldr	r3, [r4, #28]
    cb3a:	454b      	cmp	r3, r9
    cb3c:	f47f af4a 	bne.w	c9d4 <_DNS_Send_Query+0x40>
    cb40:	e74f      	b.n	c9e2 <_DNS_Send_Query+0x4e>
                TCPIP_ARP_EntryRemove(oldIf, &oldDns);
    cb42:	4669      	mov	r1, sp
    cb44:	4648      	mov	r0, r9
    cb46:	f00d f945 	bl	19dd4 <TCPIP_ARP_EntryRemove>
                _DNS_DbgArpFlush(oldIf, oldServerIx, pDnsHE->currNet, pDnsHE->currServerIx, &oldDns);
    cb4a:	e74a      	b.n	c9e2 <_DNS_Send_Query+0x4e>
            res = TCPIP_DNS_RES_SOCKET_ERROR;
    cb4c:	f06f 0009 	mvn.w	r0, #9
    cb50:	e033      	b.n	cbba <_DNS_Send_Query+0x226>
            res = TCPIP_DNS_RES_SOCKET_ERROR;
    cb52:	f06f 0009 	mvn.w	r0, #9
    cb56:	e030      	b.n	cbba <_DNS_Send_Query+0x226>
        len = rightPtr - string - 1;
    cb58:	eba8 0801 	sub.w	r8, r8, r1
    cb5c:	f108 38ff 	add.w	r8, r8, #4294967295
        *pPutDnsStr++ = (uint8_t)len;
    cb60:	f805 8b01 	strb.w	r8, [r5], #1
        memcpy(pPutDnsStr, string, len);
    cb64:	4642      	mov	r2, r8
    cb66:	4628      	mov	r0, r5
    cb68:	f014 fa7a 	bl	21060 <memcpy>
        pPutDnsStr = pPutDnsStr + len;
    cb6c:	eb05 0008 	add.w	r0, r5, r8
        if(i == 0 || i == '/' || i == ',' || i == '>')
    cb70:	e00b      	b.n	cb8a <_DNS_Send_Query+0x1f6>
        len = rightPtr - string - 1;
    cb72:	eba8 0801 	sub.w	r8, r8, r1
    cb76:	f108 38ff 	add.w	r8, r8, #4294967295
        *pPutDnsStr++ = (uint8_t)len;
    cb7a:	f805 8b01 	strb.w	r8, [r5], #1
        memcpy(pPutDnsStr, string, len);
    cb7e:	4642      	mov	r2, r8
    cb80:	4628      	mov	r0, r5
    cb82:	f014 fa6d 	bl	21060 <memcpy>
        pPutDnsStr = pPutDnsStr + len;
    cb86:	eb05 0008 	add.w	r0, r5, r8
    *pPutDnsStr++ = 0;
    cb8a:	2200      	movs	r2, #0
    cb8c:	7002      	strb	r2, [r0, #0]
        *wrPtr++ = 0x00;
    cb8e:	7042      	strb	r2, [r0, #1]
        *wrPtr++ = pDnsHE->resolve_type;
    cb90:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
    cb94:	7083      	strb	r3, [r0, #2]
        *wrPtr++ = 0x00;
    cb96:	70c2      	strb	r2, [r0, #3]
        *wrPtr++ = 0x01; // 0x0001
    cb98:	2301      	movs	r3, #1
    cb9a:	7103      	strb	r3, [r0, #4]
    cb9c:	1d44      	adds	r4, r0, #5
        sktPayload = (uint16_t)(wrPtr - startPtr);
    cb9e:	1be4      	subs	r4, r4, r7
    cba0:	b2a4      	uxth	r4, r4
        TCPIP_UDP_TxOffsetSet(dnsSocket, sktPayload, false);
    cba2:	4621      	mov	r1, r4
    cba4:	4630      	mov	r0, r6
    cba6:	f011 f8b2 	bl	1dd0e <TCPIP_UDP_TxOffsetSet>
        if(TCPIP_UDP_Flush(dnsSocket) != sktPayload)
    cbaa:	4630      	mov	r0, r6
    cbac:	f001 f986 	bl	debc <TCPIP_UDP_Flush>
            res = TCPIP_DNS_RES_PENDING;
    cbb0:	42a0      	cmp	r0, r4
    cbb2:	bf14      	ite	ne
    cbb4:	f06f 0009 	mvnne.w	r0, #9
    cbb8:	2001      	moveq	r0, #1
}
    cbba:	b009      	add	sp, #36	; 0x24
    cbbc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        len = rightPtr - string - 1;
    cbc0:	eba8 0801 	sub.w	r8, r8, r1
    cbc4:	f108 38ff 	add.w	r8, r8, #4294967295
        *pPutDnsStr++ = (uint8_t)len;
    cbc8:	f805 8b01 	strb.w	r8, [r5], #1
        memcpy(pPutDnsStr, string, len);
    cbcc:	4642      	mov	r2, r8
    cbce:	4628      	mov	r0, r5
    cbd0:	f014 fa46 	bl	21060 <memcpy>
        pPutDnsStr = pPutDnsStr + len;
    cbd4:	eb05 0008 	add.w	r0, r5, r8
        if(i == 0 || i == '/' || i == ',' || i == '>')
    cbd8:	e7d7      	b.n	cb8a <_DNS_Send_Query+0x1f6>
        len = rightPtr - string - 1;
    cbda:	eba8 0901 	sub.w	r9, r8, r1
    cbde:	f109 39ff 	add.w	r9, r9, #4294967295
        *pPutDnsStr++ = (uint8_t)len;
    cbe2:	f805 9b01 	strb.w	r9, [r5], #1
        memcpy(pPutDnsStr, string, len);
    cbe6:	464a      	mov	r2, r9
    cbe8:	4628      	mov	r0, r5
    cbea:	f014 fa39 	bl	21060 <memcpy>
        pPutDnsStr = pPutDnsStr + len;
    cbee:	444d      	add	r5, r9
            i = *rightPtr++;
    cbf0:	4641      	mov	r1, r8
    cbf2:	f818 3b01 	ldrb.w	r3, [r8], #1
        }while((i != 0) && (i != '.') && (i != '/') && (i != ',') && (i != '>'));
    cbf6:	2b00      	cmp	r3, #0
    cbf8:	d0bb      	beq.n	cb72 <_DNS_Send_Query+0x1de>
    cbfa:	2b2e      	cmp	r3, #46	; 0x2e
    cbfc:	d0ed      	beq.n	cbda <_DNS_Send_Query+0x246>
    cbfe:	2b2f      	cmp	r3, #47	; 0x2f
    cc00:	d0de      	beq.n	cbc0 <_DNS_Send_Query+0x22c>
    cc02:	2b2c      	cmp	r3, #44	; 0x2c
    cc04:	d0a8      	beq.n	cb58 <_DNS_Send_Query+0x1c4>
    cc06:	2b3e      	cmp	r3, #62	; 0x3e
    cc08:	d1f3      	bne.n	cbf2 <_DNS_Send_Query+0x25e>
        len = rightPtr - string - 1;
    cc0a:	eba8 0801 	sub.w	r8, r8, r1
    cc0e:	f108 38ff 	add.w	r8, r8, #4294967295
        *pPutDnsStr++ = (uint8_t)len;
    cc12:	f805 8b01 	strb.w	r8, [r5], #1
        memcpy(pPutDnsStr, string, len);
    cc16:	4642      	mov	r2, r8
    cc18:	4628      	mov	r0, r5
    cc1a:	f014 fa21 	bl	21060 <memcpy>
        pPutDnsStr = pPutDnsStr + len;
    cc1e:	eb05 0008 	add.w	r0, r5, r8
        if(i == 0 || i == '/' || i == ',' || i == '>')
    cc22:	e7b2      	b.n	cb8a <_DNS_Send_Query+0x1f6>

Disassembly of section .text.ReportBW_Jitter_Loss%222:

0000cc24 <ReportBW_Jitter_Loss>:
{
    cc24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cc28:	b087      	sub	sp, #28
    cc2a:	4604      	mov	r4, r0
    cc2c:	460d      	mov	r5, r1
    uint32_t tickFreq = SYS_TMR_TickCounterFrequencyGet(); 
    cc2e:	f013 f9e5 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
    cc32:	4607      	mov	r7, r0
    currentTime = SYS_TMR_TickCountGet();
    cc34:	f013 f9ba 	bl	1ffac <SYS_TMR_TickCountGet>
    cc38:	4606      	mov	r6, r0
    cmdIoParam = pIState->pCmdIO->cmdIoParam;
    cc3a:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    cc3e:	f8d3 9004 	ldr.w	r9, [r3, #4]
    switch ( reportType )
    cc42:	2d00      	cmp	r5, #0
    cc44:	f000 809a 	beq.w	cd7c <ReportBW_Jitter_Loss+0x158>
    cc48:	2d02      	cmp	r5, #2
    cc4a:	d86d      	bhi.n	cd28 <ReportBW_Jitter_Loss+0x104>
           nDropped = pIState->errorCount;
    cc4c:	f8d4 a030 	ldr.w	sl, [r4, #48]	; 0x30
           if (pIState->state == (uint8_t)IPERF_UDP_TX_DONE_STATE)
    cc50:	f894 30ce 	ldrb.w	r3, [r4, #206]	; 0xce
    cc54:	2b12      	cmp	r3, #18
               nAttempted = pIState->lastPktId + nDropped;
    cc56:	bf06      	itte	eq
    cc58:	6ae3      	ldreq	r3, [r4, #44]	; 0x2c
    cc5a:	eb0a 0803 	addeq.w	r8, sl, r3
                nAttempted = pIState->lastPktId;
    cc5e:	f8d4 802c 	ldrne.w	r8, [r4, #44]	; 0x2c
			msec = (uint32_t)(((double) (pIState->stopTime - pIState->startTime)) / (((double)(tickFreq))/1000));
    cc62:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
    cc66:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    cc6a:	1ac0      	subs	r0, r0, r3
    cc6c:	f7fd ff76 	bl	ab5c <__aeabi_ui2d>
    cc70:	e9cd 0104 	strd	r0, r1, [sp, #16]
    cc74:	4638      	mov	r0, r7
    cc76:	f7fd ff71 	bl	ab5c <__aeabi_ui2d>
    cc7a:	2200      	movs	r2, #0
    cc7c:	4b7f      	ldr	r3, [pc, #508]	; (ce7c <ReportBW_Jitter_Loss+0x258>)
    cc7e:	f7fc fbf3 	bl	9468 <__aeabi_ddiv>
    cc82:	4602      	mov	r2, r0
    cc84:	460b      	mov	r3, r1
    cc86:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    cc8a:	f7fc fbed 	bl	9468 <__aeabi_ddiv>
    cc8e:	f010 ff81 	bl	1db94 <__aeabi_d2uiz>
			if ( msec == 0u )
    cc92:	4607      	mov	r7, r0
    cc94:	2800      	cmp	r0, #0
    cc96:	f000 80eb 	beq.w	ce70 <ReportBW_Jitter_Loss+0x24c>
   				kbps = (pIState->totalLen * ((double) 8)) / msec;
    cc9a:	2200      	movs	r2, #0
    cc9c:	4b78      	ldr	r3, [pc, #480]	; (ce80 <ReportBW_Jitter_Loss+0x25c>)
    cc9e:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    cca2:	f7fc fab7 	bl	9214 <__aeabi_dmul>
    cca6:	e9cd 0104 	strd	r0, r1, [sp, #16]
    ccaa:	4638      	mov	r0, r7
    ccac:	f7fd ff56 	bl	ab5c <__aeabi_ui2d>
    ccb0:	4602      	mov	r2, r0
    ccb2:	460b      	mov	r3, r1
    ccb4:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    ccb8:	f7fc fbd6 	bl	9468 <__aeabi_ddiv>
            gfx_mono_print_scroll("AVG: %4lu Kbps",(unsigned long) (kbps + ((double) 0.5)));
    ccbc:	2200      	movs	r2, #0
    ccbe:	4b71      	ldr	r3, [pc, #452]	; (ce84 <ReportBW_Jitter_Loss+0x260>)
    ccc0:	f7fd fe10 	bl	a8e4 <__adddf3>
    ccc4:	f010 ff66 	bl	1db94 <__aeabi_d2uiz>
    ccc8:	4601      	mov	r1, r0
    ccca:	9004      	str	r0, [sp, #16]
    cccc:	f8df b1d4 	ldr.w	fp, [pc, #468]	; cea4 <ReportBW_Jitter_Loss+0x280>
    ccd0:	f20b 40a4 	addw	r0, fp, #1188	; 0x4a4
    ccd4:	f00c f800 	bl	18cd8 <gfx_mono_print_scroll>
            gfx_mono_print_scroll("iperf done");
    ccd8:	f20b 40b4 	addw	r0, fp, #1204	; 0x4b4
    ccdc:	f00b fffc 	bl	18cd8 <gfx_mono_print_scroll>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [0.0- %lu.%lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    cce0:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    cce4:	681b      	ldr	r3, [r3, #0]
    cce6:	f8d3 b004 	ldr.w	fp, [r3, #4]
    ccea:	4a67      	ldr	r2, [pc, #412]	; (ce88 <ReportBW_Jitter_Loss+0x264>)
    ccec:	fba2 3207 	umull	r3, r2, r2, r7
    ccf0:	0992      	lsrs	r2, r2, #6
                             (unsigned long)((msec%1000)/100),
    ccf2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    ccf6:	fb03 7312 	mls	r3, r3, r2, r7
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [0.0- %lu.%lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    ccfa:	4f64      	ldr	r7, [pc, #400]	; (ce8c <ReportBW_Jitter_Loss+0x268>)
    ccfc:	fba7 1303 	umull	r1, r3, r7, r3
    cd00:	095b      	lsrs	r3, r3, #5
    cd02:	f1b8 0f00 	cmp.w	r8, #0
    cd06:	f000 80b6 	beq.w	ce76 <ReportBW_Jitter_Loss+0x252>
                             (nAttempted == 0u) ? 0 : ((unsigned long)nDropped*100/(unsigned long)nAttempted),
    cd0a:	2164      	movs	r1, #100	; 0x64
    cd0c:	fb01 f10a 	mul.w	r1, r1, sl
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [0.0- %lu.%lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    cd10:	fbb1 f1f8 	udiv	r1, r1, r8
    cd14:	9804      	ldr	r0, [sp, #16]
    cd16:	9003      	str	r0, [sp, #12]
    cd18:	9102      	str	r1, [sp, #8]
    cd1a:	f8cd 8004 	str.w	r8, [sp, #4]
    cd1e:	f8cd a000 	str.w	sl, [sp]
    cd22:	495b      	ldr	r1, [pc, #364]	; (ce90 <ReportBW_Jitter_Loss+0x26c>)
    cd24:	4648      	mov	r0, r9
    cd26:	47d8      	blx	fp
    if ( reportType == 	SESSION_REPORT )
    cd28:	2d02      	cmp	r5, #2
    cd2a:	d112      	bne.n	cd52 <ReportBW_Jitter_Loss+0x12e>
      (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "iperf: instance %d completed\n\r", pIState - gIperfState);
    cd2c:	4a59      	ldr	r2, [pc, #356]	; (ce94 <ReportBW_Jitter_Loss+0x270>)
    cd2e:	1aa2      	subs	r2, r4, r2
    cd30:	10d2      	asrs	r2, r2, #3
    cd32:	eb02 03c2 	add.w	r3, r2, r2, lsl #3
    cd36:	eb02 0243 	add.w	r2, r2, r3, lsl #1
    cd3a:	ebc2 2242 	rsb	r2, r2, r2, lsl #9
    cd3e:	eb02 4282 	add.w	r2, r2, r2, lsl #18
    cd42:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    cd46:	681b      	ldr	r3, [r3, #0]
    cd48:	685b      	ldr	r3, [r3, #4]
    cd4a:	4252      	negs	r2, r2
    cd4c:	4952      	ldr	r1, [pc, #328]	; (ce98 <ReportBW_Jitter_Loss+0x274>)
    cd4e:	4648      	mov	r0, r9
    cd50:	4798      	blx	r3
    pIState->lastCheckPktId = pIState->pktId;
    cd52:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    cd54:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
    pIState->lastCheckErrorCount = pIState->errorCount;
    cd58:	6b23      	ldr	r3, [r4, #48]	; 0x30
    cd5a:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
    pIState->lastCheckPktCount = pIState->pktCount;
    cd5e:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    cd62:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
    pIState->lastCheckTime = currentTime;
    cd66:	f8c4 60a8 	str.w	r6, [r4, #168]	; 0xa8
    pIState->lastCheckTotalLen = (uint32_t)pIState->totalLen;
    cd6a:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    cd6e:	f010 ff11 	bl	1db94 <__aeabi_d2uiz>
    cd72:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4
}
    cd76:	b007      	add	sp, #28
    cd78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            nDropped = pIState->errorCount - pIState->lastCheckErrorCount;
    cd7c:	6b22      	ldr	r2, [r4, #48]	; 0x30
    cd7e:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    cd82:	eba2 0a03 	sub.w	sl, r2, r3
            sec = (currentTime- pIState->lastCheckTime) / tickFreq;
    cd86:	f8d4 50a8 	ldr.w	r5, [r4, #168]	; 0xa8
			msec = (uint32_t)(((double) (currentTime - pIState->lastCheckTime)) / (((double)(tickFreq))/1000));
    cd8a:	1b40      	subs	r0, r0, r5
    cd8c:	f7fd fee6 	bl	ab5c <__aeabi_ui2d>
    cd90:	e9cd 0104 	strd	r0, r1, [sp, #16]
    cd94:	4638      	mov	r0, r7
    cd96:	f7fd fee1 	bl	ab5c <__aeabi_ui2d>
    cd9a:	2200      	movs	r2, #0
    cd9c:	4b37      	ldr	r3, [pc, #220]	; (ce7c <ReportBW_Jitter_Loss+0x258>)
    cd9e:	f7fc fb63 	bl	9468 <__aeabi_ddiv>
    cda2:	4602      	mov	r2, r0
    cda4:	460b      	mov	r3, r1
    cda6:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    cdaa:	f7fc fb5d 	bl	9468 <__aeabi_ddiv>
    cdae:	f010 fef1 	bl	1db94 <__aeabi_d2uiz>
    cdb2:	4683      	mov	fp, r0
            if ( pIState->state == (uint8_t)IPERF_UDP_TX_DONE_STATE )
    cdb4:	f894 30ce 	ldrb.w	r3, [r4, #206]	; 0xce
    cdb8:	2b12      	cmp	r3, #18
    cdba:	d04d      	beq.n	ce58 <ReportBW_Jitter_Loss+0x234>
                nAttempted = pIState->pktId - pIState->lastCheckPktId;
    cdbc:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    cdbe:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
    cdc2:	eba2 0803 	sub.w	r8, r2, r3
			if ( msec == 0u )
    cdc6:	f1bb 0f00 	cmp.w	fp, #0
    cdca:	d04c      	beq.n	ce66 <ReportBW_Jitter_Loss+0x242>
				kbps = ((pIState->totalLen - pIState->lastCheckTotalLen)*((double) 8)) / msec;
    cdcc:	f8d4 00a4 	ldr.w	r0, [r4, #164]	; 0xa4
    cdd0:	f7fd fec4 	bl	ab5c <__aeabi_ui2d>
    cdd4:	4602      	mov	r2, r0
    cdd6:	460b      	mov	r3, r1
    cdd8:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    cddc:	f7fd fd80 	bl	a8e0 <__aeabi_dsub>
    cde0:	2200      	movs	r2, #0
    cde2:	4b27      	ldr	r3, [pc, #156]	; (ce80 <ReportBW_Jitter_Loss+0x25c>)
    cde4:	f7fc fa16 	bl	9214 <__aeabi_dmul>
    cde8:	e9cd 0104 	strd	r0, r1, [sp, #16]
    cdec:	4658      	mov	r0, fp
    cdee:	f7fd feb5 	bl	ab5c <__aeabi_ui2d>
    cdf2:	4602      	mov	r2, r0
    cdf4:	460b      	mov	r3, r1
    cdf6:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    cdfa:	f7fc fb35 	bl	9468 <__aeabi_ddiv>
            sec = (pIState->lastCheckTime - pIState->startTime) / tickFreq;
    cdfe:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    ce02:	1aed      	subs	r5, r5, r3
    ce04:	fbb5 f5f7 	udiv	r5, r5, r7
            gfx_mono_print_scroll("%4lu Kbps",(unsigned long) (kbps + ((double) 0.5)));
    ce08:	2200      	movs	r2, #0
    ce0a:	4b1e      	ldr	r3, [pc, #120]	; (ce84 <ReportBW_Jitter_Loss+0x260>)
    ce0c:	f7fd fd6a 	bl	a8e4 <__adddf3>
    ce10:	f010 fec0 	bl	1db94 <__aeabi_d2uiz>
    ce14:	4601      	mov	r1, r0
    ce16:	9004      	str	r0, [sp, #16]
    ce18:	4820      	ldr	r0, [pc, #128]	; (ce9c <ReportBW_Jitter_Loss+0x278>)
    ce1a:	f00b ff5d 	bl	18cd8 <gfx_mono_print_scroll>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [%2lu- %2lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    ce1e:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    ce22:	681b      	ldr	r3, [r3, #0]
    ce24:	f8d3 b004 	ldr.w	fp, [r3, #4]
                      (unsigned long)sec + ( (unsigned long) (pIState->mInterval / tickFreq) ),
    ce28:	6823      	ldr	r3, [r4, #0]
    ce2a:	fbb3 f3f7 	udiv	r3, r3, r7
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [%2lu- %2lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    ce2e:	442b      	add	r3, r5
    ce30:	f1b8 0f00 	cmp.w	r8, #0
    ce34:	d01a      	beq.n	ce6c <ReportBW_Jitter_Loss+0x248>
                      (nAttempted == 0u) ? 0 : ((unsigned long)nDropped*100/(unsigned long)nAttempted),
    ce36:	2264      	movs	r2, #100	; 0x64
    ce38:	fb02 f20a 	mul.w	r2, r2, sl
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [%2lu- %2lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    ce3c:	fbb2 f2f8 	udiv	r2, r2, r8
    ce40:	9904      	ldr	r1, [sp, #16]
    ce42:	9103      	str	r1, [sp, #12]
    ce44:	9202      	str	r2, [sp, #8]
    ce46:	f8cd 8004 	str.w	r8, [sp, #4]
    ce4a:	f8cd a000 	str.w	sl, [sp]
    ce4e:	462a      	mov	r2, r5
    ce50:	4913      	ldr	r1, [pc, #76]	; (cea0 <ReportBW_Jitter_Loss+0x27c>)
    ce52:	4648      	mov	r0, r9
    ce54:	47d8      	blx	fp
    if ( reportType == 	SESSION_REPORT )
    ce56:	e77c      	b.n	cd52 <ReportBW_Jitter_Loss+0x12e>
               nAttempted = (pIState->lastPktId - pIState->lastCheckPktId) + nDropped;
    ce58:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    ce5a:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
    ce5e:	1a9b      	subs	r3, r3, r2
    ce60:	eb03 080a 	add.w	r8, r3, sl
    ce64:	e7af      	b.n	cdc6 <ReportBW_Jitter_Loss+0x1a2>
                kbps = 0;
    ce66:	2000      	movs	r0, #0
    ce68:	2100      	movs	r1, #0
    ce6a:	e7c8      	b.n	cdfe <ReportBW_Jitter_Loss+0x1da>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [%2lu- %2lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    ce6c:	4642      	mov	r2, r8
    ce6e:	e7e7      	b.n	ce40 <ReportBW_Jitter_Loss+0x21c>
                kbps = 0;
    ce70:	2000      	movs	r0, #0
    ce72:	2100      	movs	r1, #0
    ce74:	e722      	b.n	ccbc <ReportBW_Jitter_Loss+0x98>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - [0.0- %lu.%lu sec] %3lu/ %3lu (%2lu%%)    %4lu Kbps\r\n",
    ce76:	4641      	mov	r1, r8
    ce78:	e74c      	b.n	cd14 <ReportBW_Jitter_Loss+0xf0>
    ce7a:	bf00      	nop
    ce7c:	408f4000 	.word	0x408f4000
    ce80:	40200000 	.word	0x40200000
    ce84:	3fe00000 	.word	0x3fe00000
    ce88:	10624dd3 	.word	0x10624dd3
    ce8c:	51eb851f 	.word	0x51eb851f
    ce90:	00005104 	.word	0x00005104
    ce94:	2000dbb0 	.word	0x2000dbb0
    ce98:	00005140 	.word	0x00005140
    ce9c:	000050a0 	.word	0x000050a0
    cea0:	000050ac 	.word	0x000050ac
    cea4:	00004c44 	.word	0x00004c44

Disassembly of section .text._CommandDhcpOptions%223:

0000cea8 <_CommandDhcpOptions>:
{
    cea8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ceac:	b096      	sub	sp, #88	; 0x58
    ceae:	4604      	mov	r4, r0
    ceb0:	4615      	mov	r5, r2
    const void* cmdIoParam = pCmdIO->cmdIoParam;
    ceb2:	6846      	ldr	r6, [r0, #4]
    if (argc < 3)
    ceb4:	2902      	cmp	r1, #2
    ceb6:	dc13      	bgt.n	cee0 <_CommandDhcpOptions+0x38>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Usage: %s <interface> <on/off/renew/request/info> \r\n", argv[0]);
    ceb8:	4f83      	ldr	r7, [pc, #524]	; (d0c8 <_CommandDhcpOptions+0x220>)
    ceba:	6803      	ldr	r3, [r0, #0]
    cebc:	685b      	ldr	r3, [r3, #4]
    cebe:	6812      	ldr	r2, [r2, #0]
    cec0:	f607 719c 	addw	r1, r7, #3996	; 0xf9c
    cec4:	4630      	mov	r0, r6
    cec6:	4798      	blx	r3
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Ex: %s PIC32INT on \r\n", argv[0]);
    cec8:	6823      	ldr	r3, [r4, #0]
    ceca:	685b      	ldr	r3, [r3, #4]
    cecc:	682a      	ldr	r2, [r5, #0]
    cece:	f507 71fe 	add.w	r1, r7, #508	; 0x1fc
    ced2:	4630      	mov	r0, r6
    ced4:	4798      	blx	r3
        return false;
    ced6:	2700      	movs	r7, #0
}
    ced8:	4638      	mov	r0, r7
    ceda:	b016      	add	sp, #88	; 0x58
    cedc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    cee0:	4688      	mov	r8, r1
    reqIpAddr.Val = 0;
    cee2:	2300      	movs	r3, #0
    cee4:	9315      	str	r3, [sp, #84]	; 0x54
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
    cee6:	6850      	ldr	r0, [r2, #4]
    cee8:	f010 fd34 	bl	1d954 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
    ceec:	4682      	mov	sl, r0
    ceee:	b328      	cbz	r0, cf3c <_CommandDhcpOptions+0x94>
    if (strcmp(argv[2], "on") == 0)
    cef0:	f8d5 9008 	ldr.w	r9, [r5, #8]
    cef4:	4975      	ldr	r1, [pc, #468]	; (d0cc <_CommandDhcpOptions+0x224>)
    cef6:	4648      	mov	r0, r9
    cef8:	f014 fd00 	bl	218fc <strcmp>
    cefc:	2800      	cmp	r0, #0
    cefe:	f000 80c2 	beq.w	d086 <_CommandDhcpOptions+0x1de>
    else if (strcmp(argv[2], "off") == 0)
    cf02:	4973      	ldr	r1, [pc, #460]	; (d0d0 <_CommandDhcpOptions+0x228>)
    cf04:	4648      	mov	r0, r9
    cf06:	f014 fcf9 	bl	218fc <strcmp>
    cf0a:	2800      	cmp	r0, #0
    cf0c:	f000 80d7 	beq.w	d0be <_CommandDhcpOptions+0x216>
    else if (strcmp(argv[2], "renew") == 0)
    cf10:	4970      	ldr	r1, [pc, #448]	; (d0d4 <_CommandDhcpOptions+0x22c>)
    cf12:	4648      	mov	r0, r9
    cf14:	f014 fcf2 	bl	218fc <strcmp>
    cf18:	2800      	cmp	r0, #0
    cf1a:	f000 80cc 	beq.w	d0b6 <_CommandDhcpOptions+0x20e>
    else if (strcmp(argv[2], "request") == 0)
    cf1e:	496e      	ldr	r1, [pc, #440]	; (d0d8 <_CommandDhcpOptions+0x230>)
    cf20:	4648      	mov	r0, r9
    cf22:	f014 fceb 	bl	218fc <strcmp>
    cf26:	4607      	mov	r7, r0
    cf28:	b9e0      	cbnz	r0, cf64 <_CommandDhcpOptions+0xbc>
        if(argc < 4)
    cf2a:	f1b8 0f03 	cmp.w	r8, #3
    cf2e:	dc0c      	bgt.n	cf4a <_CommandDhcpOptions+0xa2>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Request needs an IP address\r\n");
    cf30:	6823      	ldr	r3, [r4, #0]
    cf32:	681b      	ldr	r3, [r3, #0]
    cf34:	4969      	ldr	r1, [pc, #420]	; (d0dc <_CommandDhcpOptions+0x234>)
    cf36:	4630      	mov	r0, r6
    cf38:	4798      	blx	r3
            return false;
    cf3a:	e7cd      	b.n	ced8 <_CommandDhcpOptions+0x30>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface\r\n");
    cf3c:	6823      	ldr	r3, [r4, #0]
    cf3e:	681b      	ldr	r3, [r3, #0]
    cf40:	4967      	ldr	r1, [pc, #412]	; (d0e0 <_CommandDhcpOptions+0x238>)
    cf42:	4630      	mov	r0, r6
    cf44:	4798      	blx	r3
        return false;
    cf46:	2700      	movs	r7, #0
    cf48:	e7c6      	b.n	ced8 <_CommandDhcpOptions+0x30>
        if (!TCPIP_Helper_StringToIPAddress(argv[3], &reqIpAddr))
    cf4a:	a915      	add	r1, sp, #84	; 0x54
    cf4c:	68e8      	ldr	r0, [r5, #12]
    cf4e:	f006 f81d 	bl	12f8c <TCPIP_Helper_StringToIPAddress>
    cf52:	2800      	cmp	r0, #0
    cf54:	f040 80aa 	bne.w	d0ac <_CommandDhcpOptions+0x204>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Invalid IP address string \r\n");
    cf58:	6823      	ldr	r3, [r4, #0]
    cf5a:	681b      	ldr	r3, [r3, #0]
    cf5c:	4961      	ldr	r1, [pc, #388]	; (d0e4 <_CommandDhcpOptions+0x23c>)
    cf5e:	4630      	mov	r0, r6
    cf60:	4798      	blx	r3
            return false;
    cf62:	e7b9      	b.n	ced8 <_CommandDhcpOptions+0x30>
    else if (strcmp(argv[2], "info") == 0)
    cf64:	4960      	ldr	r1, [pc, #384]	; (d0e8 <_CommandDhcpOptions+0x240>)
    cf66:	4648      	mov	r0, r9
    cf68:	f014 fcc8 	bl	218fc <strcmp>
    cf6c:	4607      	mov	r7, r0
    cf6e:	b130      	cbz	r0, cf7e <_CommandDhcpOptions+0xd6>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown option\r\n");
    cf70:	6823      	ldr	r3, [r4, #0]
    cf72:	681b      	ldr	r3, [r3, #0]
    cf74:	495d      	ldr	r1, [pc, #372]	; (d0ec <_CommandDhcpOptions+0x244>)
    cf76:	4630      	mov	r0, r6
    cf78:	4798      	blx	r3
        return false;
    cf7a:	2700      	movs	r7, #0
    cf7c:	e7ac      	b.n	ced8 <_CommandDhcpOptions+0x30>
        if(TCPIP_DHCP_InfoGet(netH, &dhcpInfo))
    cf7e:	a908      	add	r1, sp, #32
    cf80:	4650      	mov	r0, sl
    cf82:	f00a ffc1 	bl	17f08 <TCPIP_DHCP_InfoGet>
    cf86:	2800      	cmp	r0, #0
    cf88:	d077      	beq.n	d07a <_CommandDhcpOptions+0x1d2>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP status: %d ( %d == Bound), time: %d\r\n", dhcpInfo.status, TCPIP_DHCP_BOUND, dhcpInfo.dhcpTime);
    cf8a:	6823      	ldr	r3, [r4, #0]
    cf8c:	9a09      	ldr	r2, [sp, #36]	; 0x24
    cf8e:	9200      	str	r2, [sp, #0]
    cf90:	685d      	ldr	r5, [r3, #4]
    cf92:	2308      	movs	r3, #8
    cf94:	f89d 2020 	ldrb.w	r2, [sp, #32]
    cf98:	4955      	ldr	r1, [pc, #340]	; (d0f0 <_CommandDhcpOptions+0x248>)
    cf9a:	4630      	mov	r0, r6
    cf9c:	47a8      	blx	r5
            if(dhcpInfo.status >= TCPIP_DHCP_BOUND)
    cf9e:	f89d 3020 	ldrb.w	r3, [sp, #32]
    cfa2:	2b07      	cmp	r3, #7
    cfa4:	d998      	bls.n	ced8 <_CommandDhcpOptions+0x30>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP lease start: %d, duration: %ds\r\n", dhcpInfo.leaseStartTime, dhcpInfo.leaseDuration);
    cfa6:	4d53      	ldr	r5, [pc, #332]	; (d0f4 <_CommandDhcpOptions+0x24c>)
    cfa8:	6823      	ldr	r3, [r4, #0]
    cfaa:	f8d3 8004 	ldr.w	r8, [r3, #4]
    cfae:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    cfb0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    cfb2:	f1a5 01c0 	sub.w	r1, r5, #192	; 0xc0
    cfb6:	4630      	mov	r0, r6
    cfb8:	47c0      	blx	r8
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP renew time: %d, rebind time: %d\r\n", dhcpInfo.renewTime, dhcpInfo.rebindTime);
    cfba:	6823      	ldr	r3, [r4, #0]
    cfbc:	f8d3 8004 	ldr.w	r8, [r3, #4]
    cfc0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    cfc2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    cfc4:	f1a5 0198 	sub.w	r1, r5, #152	; 0x98
    cfc8:	4630      	mov	r0, r6
    cfca:	47c0      	blx	r8
                TCPIP_Helper_IPAddressToString(&dhcpInfo.dhcpAddress, addBuff, sizeof(addBuff));
    cfcc:	2214      	movs	r2, #20
    cfce:	a903      	add	r1, sp, #12
    cfd0:	a80e      	add	r0, sp, #56	; 0x38
    cfd2:	f00f fbc7 	bl	1c764 <TCPIP_Helper_IPAddressToString>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP address: %s\r\n", addBuff);
    cfd6:	6823      	ldr	r3, [r4, #0]
    cfd8:	685b      	ldr	r3, [r3, #4]
    cfda:	aa03      	add	r2, sp, #12
    cfdc:	f1a5 0170 	sub.w	r1, r5, #112	; 0x70
    cfe0:	4630      	mov	r0, r6
    cfe2:	4798      	blx	r3
                TCPIP_Helper_IPAddressToString(&dhcpInfo.serverAddress, addBuff, sizeof(addBuff));
    cfe4:	2214      	movs	r2, #20
    cfe6:	a903      	add	r1, sp, #12
    cfe8:	a810      	add	r0, sp, #64	; 0x40
    cfea:	f00f fbbb 	bl	1c764 <TCPIP_Helper_IPAddressToString>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP server: %s\r\n", addBuff);
    cfee:	6823      	ldr	r3, [r4, #0]
    cff0:	685b      	ldr	r3, [r3, #4]
    cff2:	aa03      	add	r2, sp, #12
    cff4:	f1a5 015c 	sub.w	r1, r5, #92	; 0x5c
    cff8:	4630      	mov	r0, r6
    cffa:	4798      	blx	r3
                if(dhcpInfo.bootFileName == 0 || strlen(dhcpInfo.bootFileName) == 0)
    cffc:	9a11      	ldr	r2, [sp, #68]	; 0x44
    cffe:	b18a      	cbz	r2, d024 <_CommandDhcpOptions+0x17c>
    d000:	7813      	ldrb	r3, [r2, #0]
                    bootName = "not given";
    d002:	2b00      	cmp	r3, #0
    d004:	4b3c      	ldr	r3, [pc, #240]	; (d0f8 <_CommandDhcpOptions+0x250>)
    d006:	bf08      	it	eq
    d008:	461a      	moveq	r2, r3
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP boot name: %s\r\n", bootName);
    d00a:	6823      	ldr	r3, [r4, #0]
    d00c:	685b      	ldr	r3, [r3, #4]
    d00e:	493b      	ldr	r1, [pc, #236]	; (d0fc <_CommandDhcpOptions+0x254>)
    d010:	4630      	mov	r0, r6
    d012:	4798      	blx	r3
                if(dhcpInfo.timeServersNo)
    d014:	f89d 3048 	ldrb.w	r3, [sp, #72]	; 0x48
    d018:	b933      	cbnz	r3, d028 <_CommandDhcpOptions+0x180>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP Time servers: %d, %s\r\n", dhcpInfo.timeServersNo, dhcpInfo.timeServersNo ? addBuff: "None");
    d01a:	6823      	ldr	r3, [r4, #0]
    d01c:	685d      	ldr	r5, [r3, #4]
    d01e:	463a      	mov	r2, r7
    d020:	4b37      	ldr	r3, [pc, #220]	; (d100 <_CommandDhcpOptions+0x258>)
    d022:	e00c      	b.n	d03e <_CommandDhcpOptions+0x196>
                    bootName = "not given";
    d024:	4a34      	ldr	r2, [pc, #208]	; (d0f8 <_CommandDhcpOptions+0x250>)
    d026:	e7f0      	b.n	d00a <_CommandDhcpOptions+0x162>
                    TCPIP_Helper_IPAddressToString(dhcpInfo.timeServers, addBuff, sizeof(addBuff));
    d028:	2214      	movs	r2, #20
    d02a:	a903      	add	r1, sp, #12
    d02c:	9813      	ldr	r0, [sp, #76]	; 0x4c
    d02e:	f00f fb99 	bl	1c764 <TCPIP_Helper_IPAddressToString>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP Time servers: %d, %s\r\n", dhcpInfo.timeServersNo, dhcpInfo.timeServersNo ? addBuff: "None");
    d032:	6823      	ldr	r3, [r4, #0]
    d034:	685d      	ldr	r5, [r3, #4]
    d036:	f89d 2048 	ldrb.w	r2, [sp, #72]	; 0x48
    d03a:	ab03      	add	r3, sp, #12
    d03c:	b152      	cbz	r2, d054 <_CommandDhcpOptions+0x1ac>
    d03e:	4931      	ldr	r1, [pc, #196]	; (d104 <_CommandDhcpOptions+0x25c>)
    d040:	4630      	mov	r0, r6
    d042:	47a8      	blx	r5
                if(dhcpInfo.ntpServersNo)
    d044:	f89d 3049 	ldrb.w	r3, [sp, #73]	; 0x49
    d048:	b933      	cbnz	r3, d058 <_CommandDhcpOptions+0x1b0>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP NTP servers: %d, %s\r\n", dhcpInfo.ntpServersNo, dhcpInfo.ntpServersNo ? addBuff :  "None");
    d04a:	6823      	ldr	r3, [r4, #0]
    d04c:	685c      	ldr	r4, [r3, #4]
    d04e:	463a      	mov	r2, r7
    d050:	4b2b      	ldr	r3, [pc, #172]	; (d100 <_CommandDhcpOptions+0x258>)
    d052:	e00c      	b.n	d06e <_CommandDhcpOptions+0x1c6>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP Time servers: %d, %s\r\n", dhcpInfo.timeServersNo, dhcpInfo.timeServersNo ? addBuff: "None");
    d054:	4b2a      	ldr	r3, [pc, #168]	; (d100 <_CommandDhcpOptions+0x258>)
    d056:	e7f2      	b.n	d03e <_CommandDhcpOptions+0x196>
                    TCPIP_Helper_IPAddressToString(dhcpInfo.ntpServers, addBuff, sizeof(addBuff));
    d058:	2214      	movs	r2, #20
    d05a:	a903      	add	r1, sp, #12
    d05c:	9814      	ldr	r0, [sp, #80]	; 0x50
    d05e:	f00f fb81 	bl	1c764 <TCPIP_Helper_IPAddressToString>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "DHCP NTP servers: %d, %s\r\n", dhcpInfo.ntpServersNo, dhcpInfo.ntpServersNo ? addBuff :  "None");
    d062:	6823      	ldr	r3, [r4, #0]
    d064:	685c      	ldr	r4, [r3, #4]
    d066:	f89d 2049 	ldrb.w	r2, [sp, #73]	; 0x49
    d06a:	ab03      	add	r3, sp, #12
    d06c:	b11a      	cbz	r2, d076 <_CommandDhcpOptions+0x1ce>
    d06e:	4926      	ldr	r1, [pc, #152]	; (d108 <_CommandDhcpOptions+0x260>)
    d070:	4630      	mov	r0, r6
    d072:	47a0      	blx	r4
    d074:	e730      	b.n	ced8 <_CommandDhcpOptions+0x30>
    d076:	4b22      	ldr	r3, [pc, #136]	; (d100 <_CommandDhcpOptions+0x258>)
    d078:	e7f9      	b.n	d06e <_CommandDhcpOptions+0x1c6>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "DHCP: failed to get info\r\n");
    d07a:	6823      	ldr	r3, [r4, #0]
    d07c:	681b      	ldr	r3, [r3, #0]
    d07e:	4923      	ldr	r1, [pc, #140]	; (d10c <_CommandDhcpOptions+0x264>)
    d080:	4630      	mov	r0, r6
    d082:	4798      	blx	r3
        return false;
    d084:	e728      	b.n	ced8 <_CommandDhcpOptions+0x30>
            dhcpRes = TCPIP_DHCP_Enable(netH);
    d086:	4650      	mov	r0, sl
    d088:	f00e fb12 	bl	1b6b0 <TCPIP_DHCP_Enable>
    (*pCmdIO->pCmdApi->print)(cmdIoParam, "%s %s %s\r\n", argv[0], argv[2], dhcpRes ? "success" : "fail");
    d08c:	6823      	ldr	r3, [r4, #0]
    d08e:	685c      	ldr	r4, [r3, #4]
    d090:	682a      	ldr	r2, [r5, #0]
    d092:	68ab      	ldr	r3, [r5, #8]
    d094:	2800      	cmp	r0, #0
    d096:	491e      	ldr	r1, [pc, #120]	; (d110 <_CommandDhcpOptions+0x268>)
    d098:	f101 00a0 	add.w	r0, r1, #160	; 0xa0
    d09c:	bf08      	it	eq
    d09e:	4601      	moveq	r1, r0
    d0a0:	9100      	str	r1, [sp, #0]
    d0a2:	491c      	ldr	r1, [pc, #112]	; (d114 <_CommandDhcpOptions+0x26c>)
    d0a4:	4630      	mov	r0, r6
    d0a6:	47a0      	blx	r4
    return true;
    d0a8:	2701      	movs	r7, #1
    d0aa:	e715      	b.n	ced8 <_CommandDhcpOptions+0x30>
            dhcpRes = TCPIP_DHCP_Request(netH, reqIpAddr);
    d0ac:	9915      	ldr	r1, [sp, #84]	; 0x54
    d0ae:	4650      	mov	r0, sl
    d0b0:	f00a fede 	bl	17e70 <TCPIP_DHCP_Request>
            break;
    d0b4:	e7ea      	b.n	d08c <_CommandDhcpOptions+0x1e4>
            dhcpRes = TCPIP_DHCP_Renew(netH);
    d0b6:	4650      	mov	r0, sl
    d0b8:	f00f f930 	bl	1c31c <TCPIP_DHCP_Renew>
            break;
    d0bc:	e7e6      	b.n	d08c <_CommandDhcpOptions+0x1e4>
            dhcpRes = TCPIP_DHCP_Disable(netH);
    d0be:	4650      	mov	r0, sl
    d0c0:	f00e f8ee 	bl	1b2a0 <TCPIP_DHCP_Disable>
            break;
    d0c4:	e7e2      	b.n	d08c <_CommandDhcpOptions+0x1e4>
    d0c6:	bf00      	nop
    d0c8:	0000028c 	.word	0x0000028c
    d0cc:	000004b4 	.word	0x000004b4
    d0d0:	000004b8 	.word	0x000004b8
    d0d4:	00001260 	.word	0x00001260
    d0d8:	00001268 	.word	0x00001268
    d0dc:	00001270 	.word	0x00001270
    d0e0:	000004a0 	.word	0x000004a0
    d0e4:	0000103c 	.word	0x0000103c
    d0e8:	00001290 	.word	0x00001290
    d0ec:	000004bc 	.word	0x000004bc
    d0f0:	00001298 	.word	0x00001298
    d0f4:	00001384 	.word	0x00001384
    d0f8:	0000120c 	.word	0x0000120c
    d0fc:	0000133c 	.word	0x0000133c
    d100:	00001218 	.word	0x00001218
    d104:	00001354 	.word	0x00001354
    d108:	00001370 	.word	0x00001370
    d10c:	0000138c 	.word	0x0000138c
    d110:	00001180 	.word	0x00001180
    d114:	000013a8 	.word	0x000013a8

Disassembly of section .rodata%224:

0000d118 <.rodata%224>:
    d118:	00082008 	.word	0x00082008
    d11c:	00000008 	.word	0x00000008
    d120:	003e0a0d 	.word	0x003e0a0d
    d124:	2d2d0a0d 	.word	0x2d2d0a0d
    d128:	2d2d2d2d 	.word	0x2d2d2d2d
    d12c:	7553202d 	.word	0x7553202d
    d130:	726f7070 	.word	0x726f7070
    d134:	20646574 	.word	0x20646574
    d138:	6d6d6f63 	.word	0x6d6d6f63
    d13c:	20646e61 	.word	0x20646e61
    d140:	756f7267 	.word	0x756f7267
    d144:	2d207370 	.word	0x2d207370
    d148:	2d2d2d2d 	.word	0x2d2d2d2d
    d14c:	0000002d 	.word	0x0000002d
    d150:	2a200a0d 	.word	0x2a200a0d
    d154:	00202a2a 	.word	0x00202a2a
    d158:	2a2a2a20 	.word	0x2a2a2a20
    d15c:	00000000 	.word	0x00000000
    d160:	2d2d0a0d 	.word	0x2d2d0a0d
    d164:	2d2d2d2d 	.word	0x2d2d2d2d
    d168:	2d2d2d2d 	.word	0x2d2d2d2d
    d16c:	69754220 	.word	0x69754220
    d170:	6920746c 	.word	0x6920746c
    d174:	6f63206e 	.word	0x6f63206e
    d178:	6e616d6d 	.word	0x6e616d6d
    d17c:	2d207364 	.word	0x2d207364
    d180:	2d2d2d2d 	.word	0x2d2d2d2d
    d184:	2d2d2d2d 	.word	0x2d2d2d2d
    d188:	0000002d 	.word	0x0000002d
    d18c:	00000a0d 	.word	0x00000a0d
    d190:	6e550a0d 	.word	0x6e550a0d
    d194:	776f6e6b 	.word	0x776f6e6b
    d198:	6f63206e 	.word	0x6f63206e
    d19c:	6e616d6d 	.word	0x6e616d6d
    d1a0:	72672064 	.word	0x72672064
    d1a4:	2e70756f 	.word	0x2e70756f
    d1a8:	79725420 	.word	0x79725420
    d1ac:	6c656820 	.word	0x6c656820
    d1b0:	000a0d70 	.word	0x000a0d70
    d1b4:	64255b1b 	.word	0x64255b1b
    d1b8:	00000043 	.word	0x00000043
    d1bc:	64255b1b 	.word	0x64255b1b
    d1c0:	00000044 	.word	0x00000044
    d1c4:	2a200a0d 	.word	0x2a200a0d
    d1c8:	51202a2a 	.word	0x51202a2a
    d1cc:	74746975 	.word	0x74746975
    d1d0:	20676e69 	.word	0x20676e69
    d1d4:	20656874 	.word	0x20656874
    d1d8:	6d6d6f43 	.word	0x6d6d6f43
    d1dc:	20646e61 	.word	0x20646e61
    d1e0:	636f7250 	.word	0x636f7250
    d1e4:	6f737365 	.word	0x6f737365
    d1e8:	42202e72 	.word	0x42202e72
    d1ec:	2a206579 	.word	0x2a206579
    d1f0:	0a0d2a2a 	.word	0x0a0d2a2a
    d1f4:	00000000 	.word	0x00000000
    d1f8:	2a200a0d 	.word	0x2a200a0d
    d1fc:	53202a2a 	.word	0x53202a2a
    d200:	65747379 	.word	0x65747379
    d204:	6552206d 	.word	0x6552206d
    d208:	746f6f62 	.word	0x746f6f62
    d20c:	2a2a2a20 	.word	0x2a2a2a20
    d210:	00000a0d 	.word	0x00000a0d
    d214:	002c0920 	.word	0x002c0920
    d218:	54200d0a 	.word	0x54200d0a
    d21c:	6d206f6f 	.word	0x6d206f6f
    d220:	20796e61 	.word	0x20796e61
    d224:	75677261 	.word	0x75677261
    d228:	746e656d 	.word	0x746e656d
    d22c:	4d202e73 	.word	0x4d202e73
    d230:	6d697861 	.word	0x6d697861
    d234:	61206d75 	.word	0x61206d75
    d238:	20736772 	.word	0x20736772
    d23c:	70707573 	.word	0x70707573
    d240:	6574726f 	.word	0x6574726f
    d244:	25203a64 	.word	0x25203a64
    d248:	0a0d2164 	.word	0x0a0d2164
    d24c:	00000000 	.word	0x00000000
    d250:	2a2a2a20 	.word	0x2a2a2a20
    d254:	6d6f4320 	.word	0x6d6f4320
    d258:	646e616d 	.word	0x646e616d
    d25c:	6f725020 	.word	0x6f725020
    d260:	73736563 	.word	0x73736563
    d264:	203a726f 	.word	0x203a726f
    d268:	61656c50 	.word	0x61656c50
    d26c:	74206573 	.word	0x74206573
    d270:	20657079 	.word	0x20657079
    d274:	61206e69 	.word	0x61206e69
    d278:	6d6f6320 	.word	0x6d6f6320
    d27c:	646e616d 	.word	0x646e616d
    d280:	0d2a2a2a 	.word	0x0d2a2a2a
    d284:	0000000a 	.word	0x0000000a
    d288:	2a2a2a20 	.word	0x2a2a2a20
    d28c:	6d6f4320 	.word	0x6d6f4320
    d290:	646e616d 	.word	0x646e616d
    d294:	6f725020 	.word	0x6f725020
    d298:	73736563 	.word	0x73736563
    d29c:	203a726f 	.word	0x203a726f
    d2a0:	6e6b6e75 	.word	0x6e6b6e75
    d2a4:	206e776f 	.word	0x206e776f
    d2a8:	6d6d6f63 	.word	0x6d6d6f63
    d2ac:	2e646e61 	.word	0x2e646e61
    d2b0:	2a2a2a20 	.word	0x2a2a2a20
    d2b4:	00000a0d 	.word	0x00000a0d
    d2b8:	0000003e 	.word	0x0000003e
    d2bc:	4b5b1b08 	.word	0x4b5b1b08
    d2c0:	5b1b7325 	.word	0x5b1b7325
    d2c4:	00446425 	.word	0x00446425
    d2c8:	4b5b1b08 	.word	0x4b5b1b08
    d2cc:	00000000 	.word	0x00000000
    d2d0:	254b5b1b 	.word	0x254b5b1b
    d2d4:	255b1b73 	.word	0x255b1b73
    d2d8:	00004464 	.word	0x00004464
    d2dc:	5b1b7325 	.word	0x5b1b7325
    d2e0:	00446425 	.word	0x00446425
    d2e4:	2a2a2a20 	.word	0x2a2a2a20
    d2e8:	6d6f4320 	.word	0x6d6f4320
    d2ec:	646e616d 	.word	0x646e616d
    d2f0:	6f725020 	.word	0x6f725020
    d2f4:	73736563 	.word	0x73736563
    d2f8:	6220726f 	.word	0x6220726f
    d2fc:	65666675 	.word	0x65666675
    d300:	78652072 	.word	0x78652072
    d304:	64656563 	.word	0x64656563
    d308:	202e6465 	.word	0x202e6465
    d30c:	72746552 	.word	0x72746552
    d310:	2a202e79 	.word	0x2a202e79
    d314:	0a0d2a2a 	.word	0x0a0d2a2a
    d318:	00000000 	.word	0x00000000
    d31c:	65736572 	.word	0x65736572
    d320:	00000074 	.word	0x00000074
    d324:	6552203a 	.word	0x6552203a
    d328:	20746573 	.word	0x20746573
    d32c:	74736f68 	.word	0x74736f68
    d330:	00000000 	.word	0x00000000
    d334:	00000071 	.word	0x00000071
    d338:	7571203a 	.word	0x7571203a
    d33c:	63207469 	.word	0x63207469
    d340:	616d6d6f 	.word	0x616d6d6f
    d344:	7020646e 	.word	0x7020646e
    d348:	65636f72 	.word	0x65636f72
    d34c:	726f7373 	.word	0x726f7373
    d350:	00000000 	.word	0x00000000
    d354:	706c6568 	.word	0x706c6568
    d358:	00000000 	.word	0x00000000
    d35c:	6568203a 	.word	0x6568203a
    d360:	0000706c 	.word	0x0000706c
    d364:	00415b1b 	.word	0x00415b1b
    d368:	00425b1b 	.word	0x00425b1b
    d36c:	00435b1b 	.word	0x00435b1b
    d370:	00445b1b 	.word	0x00445b1b
    d374:	7e315b1b 	.word	0x7e315b1b
    d378:	00000000 	.word	0x00000000
    d37c:	7e345b1b 	.word	0x7e345b1b
    d380:	00          	.byte	0x00
    d381:	00          	.byte	0x00
    d382:	bf00      	nop

Disassembly of section .text._CommandPing%225:

0000d384 <_CommandPing>:
{
    d384:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d388:	b083      	sub	sp, #12
    const void* cmdIoParam = pCmdIO->cmdIoParam;
    d38a:	f8d0 b004 	ldr.w	fp, [r0, #4]
    if (argc < 2)
    d38e:	2901      	cmp	r1, #1
    d390:	dd12      	ble.n	d3b8 <_CommandPing+0x34>
    d392:	4682      	mov	sl, r0
    d394:	460f      	mov	r7, r1
    d396:	4614      	mov	r4, r2
    if(strcmp(argv[1], "stop") == 0)
    d398:	6856      	ldr	r6, [r2, #4]
    d39a:	4978      	ldr	r1, [pc, #480]	; (d57c <_CommandPing+0x1f8>)
    d39c:	4630      	mov	r0, r6
    d39e:	f014 faad 	bl	218fc <strcmp>
    d3a2:	b190      	cbz	r0, d3ca <_CommandPing+0x46>
    if(tcpipCmdStat != TCPIP_CMD_STAT_IDLE)
    d3a4:	4b76      	ldr	r3, [pc, #472]	; (d580 <_CommandPing+0x1fc>)
    d3a6:	781b      	ldrb	r3, [r3, #0]
    d3a8:	b1c3      	cbz	r3, d3dc <_CommandPing+0x58>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ping: command in progress. Retry later.\r\n");
    d3aa:	f8da 3000 	ldr.w	r3, [sl]
    d3ae:	681b      	ldr	r3, [r3, #0]
    d3b0:	4974      	ldr	r1, [pc, #464]	; (d584 <_CommandPing+0x200>)
    d3b2:	4658      	mov	r0, fp
    d3b4:	4798      	blx	r3
        return true;
    d3b6:	e004      	b.n	d3c2 <_CommandPing+0x3e>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ping Usage: ping <stop>/<name/address> <i interface> <n nPings> <t msPeriod> <s size>\r\n");
    d3b8:	6803      	ldr	r3, [r0, #0]
    d3ba:	681b      	ldr	r3, [r3, #0]
    d3bc:	4972      	ldr	r1, [pc, #456]	; (d588 <_CommandPing+0x204>)
    d3be:	4658      	mov	r0, fp
    d3c0:	4798      	blx	r3
}
    d3c2:	2001      	movs	r0, #1
    d3c4:	b003      	add	sp, #12
    d3c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(tcpipCmdStat != TCPIP_CMD_STAT_IDLE)
    d3ca:	4b6d      	ldr	r3, [pc, #436]	; (d580 <_CommandPing+0x1fc>)
    d3cc:	781b      	ldrb	r3, [r3, #0]
    d3ce:	2b00      	cmp	r3, #0
    d3d0:	d0f7      	beq.n	d3c2 <_CommandPing+0x3e>
            _PingStop(pCmdIO, cmdIoParam);
    d3d2:	4659      	mov	r1, fp
    d3d4:	4650      	mov	r0, sl
    d3d6:	f00d fed3 	bl	1b180 <_PingStop>
    d3da:	e7f2      	b.n	d3c2 <_CommandPing+0x3e>
    if(TCPIP_Helper_StringToIPAddress(argv[1], &icmpTargetAddr))
    d3dc:	496b      	ldr	r1, [pc, #428]	; (d58c <_CommandPing+0x208>)
    d3de:	4630      	mov	r0, r6
    d3e0:	f005 fdd4 	bl	12f8c <TCPIP_Helper_StringToIPAddress>
    d3e4:	b960      	cbnz	r0, d400 <_CommandPing+0x7c>
        if(strlen(argv[1]) > sizeof(icmpTargetHost) - 1)
    d3e6:	6866      	ldr	r6, [r4, #4]
    d3e8:	4630      	mov	r0, r6
    d3ea:	f014 fbd7 	bl	21b9c <strlen>
    d3ee:	281e      	cmp	r0, #30
    d3f0:	d922      	bls.n	d438 <_CommandPing+0xb4>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ping: Host name too long. Retry.\r\n");
    d3f2:	f8da 3000 	ldr.w	r3, [sl]
    d3f6:	681b      	ldr	r3, [r3, #0]
    d3f8:	4965      	ldr	r1, [pc, #404]	; (d590 <_CommandPing+0x20c>)
    d3fa:	4658      	mov	r0, fp
    d3fc:	4798      	blx	r3
            return true;
    d3fe:	e7e0      	b.n	d3c2 <_CommandPing+0x3e>
        strncpy(icmpTargetAddrStr, argv[1], sizeof(icmpTargetAddrStr) - 1);
    d400:	4e64      	ldr	r6, [pc, #400]	; (d594 <_CommandPing+0x210>)
    d402:	2210      	movs	r2, #16
    d404:	6861      	ldr	r1, [r4, #4]
    d406:	4630      	mov	r0, r6
    d408:	f012 ff1d 	bl	20246 <strncpy>
        icmpTargetAddrStr[sizeof(icmpTargetAddrStr) - 1] = 0;
    d40c:	2300      	movs	r3, #0
    d40e:	7433      	strb	r3, [r6, #16]
        icmpTargetHost[0] = '\0';
    d410:	4a61      	ldr	r2, [pc, #388]	; (d598 <_CommandPing+0x214>)
    d412:	7013      	strb	r3, [r2, #0]
    icmpReqNo = 0;
    d414:	4a61      	ldr	r2, [pc, #388]	; (d59c <_CommandPing+0x218>)
    d416:	6013      	str	r3, [r2, #0]
    icmpReqDelay = 0;
    d418:	4a61      	ldr	r2, [pc, #388]	; (d5a0 <_CommandPing+0x21c>)
    d41a:	6013      	str	r3, [r2, #0]
    while(currIx + 1 < argc)
    d41c:	2f03      	cmp	r7, #3
    d41e:	f340 80a8 	ble.w	d572 <_CommandPing+0x1ee>
        newCmdStat = TCPIP_PING_CMD_START_PING;
    d422:	2303      	movs	r3, #3
    d424:	9301      	str	r3, [sp, #4]
    d426:	3f04      	subs	r7, #4
    d428:	f027 0701 	bic.w	r7, r7, #1
    d42c:	3704      	adds	r7, #4
    currIx = 2;
    d42e:	2602      	movs	r6, #2
        if(strcmp(param, "i") == 0)
    d430:	f8df 91a0 	ldr.w	r9, [pc, #416]	; d5d4 <_CommandPing+0x250>
            icmpReqDelay = atoi(paramVal);
    d434:	46b8      	mov	r8, r7
    d436:	e018      	b.n	d46a <_CommandPing+0xe6>
        strcpy(icmpTargetHost, argv[1]);
    d438:	4631      	mov	r1, r6
    d43a:	4857      	ldr	r0, [pc, #348]	; (d598 <_CommandPing+0x214>)
    d43c:	f014 fba6 	bl	21b8c <strcpy>
    icmpReqNo = 0;
    d440:	2300      	movs	r3, #0
    d442:	4a56      	ldr	r2, [pc, #344]	; (d59c <_CommandPing+0x218>)
    d444:	6013      	str	r3, [r2, #0]
    icmpReqDelay = 0;
    d446:	4a56      	ldr	r2, [pc, #344]	; (d5a0 <_CommandPing+0x21c>)
    d448:	6013      	str	r3, [r2, #0]
    while(currIx + 1 < argc)
    d44a:	2f03      	cmp	r7, #3
    d44c:	f340 8086 	ble.w	d55c <_CommandPing+0x1d8>
        newCmdStat = TCPIP_PING_CMD_DNS_GET;
    d450:	2301      	movs	r3, #1
    d452:	9301      	str	r3, [sp, #4]
    d454:	e7e7      	b.n	d426 <_CommandPing+0xa2>
            if((icmpNetH = TCPIP_STACK_NetHandleGet(paramVal)) == 0)
    d456:	4638      	mov	r0, r7
    d458:	f010 fa7c 	bl	1d954 <TCPIP_STACK_NetHandleGet>
    d45c:	4b51      	ldr	r3, [pc, #324]	; (d5a4 <_CommandPing+0x220>)
    d45e:	6018      	str	r0, [r3, #0]
    d460:	b328      	cbz	r0, d4ae <_CommandPing+0x12a>
        currIx += 2;
    d462:	3602      	adds	r6, #2
    d464:	3408      	adds	r4, #8
    while(currIx + 1 < argc)
    d466:	4546      	cmp	r6, r8
    d468:	d044      	beq.n	d4f4 <_CommandPing+0x170>
        char* param = argv[currIx];
    d46a:	68a5      	ldr	r5, [r4, #8]
        char* paramVal = argv[currIx + 1];
    d46c:	68e7      	ldr	r7, [r4, #12]
        if(strcmp(param, "i") == 0)
    d46e:	494e      	ldr	r1, [pc, #312]	; (d5a8 <_CommandPing+0x224>)
    d470:	4628      	mov	r0, r5
    d472:	f014 fa43 	bl	218fc <strcmp>
    d476:	2800      	cmp	r0, #0
    d478:	d0ed      	beq.n	d456 <_CommandPing+0xd2>
        else if(strcmp(param, "n") == 0)
    d47a:	f609 0148 	addw	r1, r9, #2120	; 0x848
    d47e:	4628      	mov	r0, r5
    d480:	f014 fa3c 	bl	218fc <strcmp>
    d484:	b1c0      	cbz	r0, d4b8 <_CommandPing+0x134>
        else if(strcmp(param, "t") == 0)
    d486:	f609 014c 	addw	r1, r9, #2124	; 0x84c
    d48a:	4628      	mov	r0, r5
    d48c:	f014 fa36 	bl	218fc <strcmp>
    d490:	b1c0      	cbz	r0, d4c4 <_CommandPing+0x140>
        else if(strcmp(param, "s") == 0)
    d492:	f509 6105 	add.w	r1, r9, #2128	; 0x850
    d496:	4628      	mov	r0, r5
    d498:	f014 fa30 	bl	218fc <strcmp>
    d49c:	b1c0      	cbz	r0, d4d0 <_CommandPing+0x14c>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ping: Unknown parameter\r\n");
    d49e:	f8da 3000 	ldr.w	r3, [sl]
    d4a2:	681b      	ldr	r3, [r3, #0]
    d4a4:	f509 6108 	add.w	r1, r9, #2176	; 0x880
    d4a8:	4658      	mov	r0, fp
    d4aa:	4798      	blx	r3
    d4ac:	e7d9      	b.n	d462 <_CommandPing+0xde>
                icmpNetH = TCPIP_STACK_NetDefaultGet();
    d4ae:	f014 fd23 	bl	21ef8 <TCPIP_STACK_NetDefaultGet>
    d4b2:	4b3c      	ldr	r3, [pc, #240]	; (d5a4 <_CommandPing+0x220>)
    d4b4:	6018      	str	r0, [r3, #0]
    d4b6:	e7d4      	b.n	d462 <_CommandPing+0xde>
            icmpReqNo = atoi(paramVal);
    d4b8:	4638      	mov	r0, r7
    d4ba:	f014 fe17 	bl	220ec <atoi>
    d4be:	4b37      	ldr	r3, [pc, #220]	; (d59c <_CommandPing+0x218>)
    d4c0:	6018      	str	r0, [r3, #0]
    d4c2:	e7ce      	b.n	d462 <_CommandPing+0xde>
            icmpReqDelay = atoi(paramVal);
    d4c4:	4638      	mov	r0, r7
    d4c6:	f014 fe11 	bl	220ec <atoi>
    d4ca:	4b35      	ldr	r3, [pc, #212]	; (d5a0 <_CommandPing+0x21c>)
    d4cc:	6018      	str	r0, [r3, #0]
    d4ce:	e7c8      	b.n	d462 <_CommandPing+0xde>
            int pingSize = atoi(paramVal);
    d4d0:	4638      	mov	r0, r7
    d4d2:	f014 fe0b 	bl	220ec <atoi>
            if(pingSize <= sizeof(icmpPingBuff))
    d4d6:	f5b0 6ffa 	cmp.w	r0, #2000	; 0x7d0
    d4da:	d802      	bhi.n	d4e2 <_CommandPing+0x15e>
                icmpPingSize = pingSize;
    d4dc:	4b33      	ldr	r3, [pc, #204]	; (d5ac <_CommandPing+0x228>)
    d4de:	6018      	str	r0, [r3, #0]
    d4e0:	e7bf      	b.n	d462 <_CommandPing+0xde>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "Ping: Data size too big. Max: %d. Retry\r\n", sizeof(icmpPingBuff));
    d4e2:	f8da 3000 	ldr.w	r3, [sl]
    d4e6:	685b      	ldr	r3, [r3, #4]
    d4e8:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
    d4ec:	4930      	ldr	r1, [pc, #192]	; (d5b0 <_CommandPing+0x22c>)
    d4ee:	4658      	mov	r0, fp
    d4f0:	4798      	blx	r3
                return true;
    d4f2:	e766      	b.n	d3c2 <_CommandPing+0x3e>
    tcpipCmdStat = newCmdStat;
    d4f4:	4b22      	ldr	r3, [pc, #136]	; (d580 <_CommandPing+0x1fc>)
    d4f6:	9a01      	ldr	r2, [sp, #4]
    d4f8:	701a      	strb	r2, [r3, #0]
    if(tcpipCmdStat == TCPIP_PING_CMD_DNS_GET)
    d4fa:	2a01      	cmp	r2, #1
    d4fc:	d031      	beq.n	d562 <_CommandPing+0x1de>
    d4fe:	f00d fb79 	bl	1abf4 <rand>
    icmpSequenceNo = SYS_RANDOM_PseudoGet();
    d502:	4b2c      	ldr	r3, [pc, #176]	; (d5b4 <_CommandPing+0x230>)
    d504:	8018      	strh	r0, [r3, #0]
    d506:	f00d fb75 	bl	1abf4 <rand>
    icmpIdentifier = SYS_RANDOM_PseudoGet();
    d50a:	4b2b      	ldr	r3, [pc, #172]	; (d5b8 <_CommandPing+0x234>)
    d50c:	8018      	strh	r0, [r3, #0]
    if(icmpReqNo == 0)
    d50e:	4b23      	ldr	r3, [pc, #140]	; (d59c <_CommandPing+0x218>)
    d510:	681b      	ldr	r3, [r3, #0]
    d512:	b913      	cbnz	r3, d51a <_CommandPing+0x196>
        icmpReqNo = TCPIP_STACK_COMMANDS_ICMP_ECHO_REQUESTS;
    d514:	4b21      	ldr	r3, [pc, #132]	; (d59c <_CommandPing+0x218>)
    d516:	2204      	movs	r2, #4
    d518:	601a      	str	r2, [r3, #0]
    if(icmpReqDelay == 0)
    d51a:	4b21      	ldr	r3, [pc, #132]	; (d5a0 <_CommandPing+0x21c>)
    d51c:	681b      	ldr	r3, [r3, #0]
    d51e:	b9bb      	cbnz	r3, d550 <_CommandPing+0x1cc>
        icmpReqDelay = TCPIP_STACK_COMMANDS_ICMP_ECHO_REQUEST_DELAY;
    d520:	4b1f      	ldr	r3, [pc, #124]	; (d5a0 <_CommandPing+0x21c>)
    d522:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    d526:	601a      	str	r2, [r3, #0]
    pTcpipCmdDevice = pCmdIO;
    d528:	4b24      	ldr	r3, [pc, #144]	; (d5bc <_CommandPing+0x238>)
    d52a:	f8c3 a000 	str.w	sl, [r3]
    icmpCmdIoParam = cmdIoParam; 
    d52e:	4b24      	ldr	r3, [pc, #144]	; (d5c0 <_CommandPing+0x23c>)
    d530:	f8c3 b000 	str.w	fp, [r3]
    icmpAckRecv = 0;
    d534:	2300      	movs	r3, #0
    d536:	4a23      	ldr	r2, [pc, #140]	; (d5c4 <_CommandPing+0x240>)
    d538:	6013      	str	r3, [r2, #0]
    icmpReqCount = 0;
    d53a:	4a23      	ldr	r2, [pc, #140]	; (d5c8 <_CommandPing+0x244>)
    d53c:	6013      	str	r3, [r2, #0]
    _TCPIPStackSignalHandlerSetParams(TCPIP_THIS_MODULE_ID, tcpipCmdSignalHandle, icmpReqDelay);
    d53e:	4b18      	ldr	r3, [pc, #96]	; (d5a0 <_CommandPing+0x21c>)
    d540:	f9b3 2000 	ldrsh.w	r2, [r3]
    d544:	4b21      	ldr	r3, [pc, #132]	; (d5cc <_CommandPing+0x248>)
    d546:	6819      	ldr	r1, [r3, #0]
    d548:	201f      	movs	r0, #31
    d54a:	f012 fcb7 	bl	1febc <_TCPIPStackSignalHandlerSetParams>
    return true;
    d54e:	e738      	b.n	d3c2 <_CommandPing+0x3e>
    if(icmpReqDelay < TCPIP_COMMAND_ICMP_ECHO_REQUEST_MIN_DELAY)
    d550:	2b04      	cmp	r3, #4
    d552:	dce9      	bgt.n	d528 <_CommandPing+0x1a4>
        icmpReqDelay = TCPIP_COMMAND_ICMP_ECHO_REQUEST_MIN_DELAY;
    d554:	4b12      	ldr	r3, [pc, #72]	; (d5a0 <_CommandPing+0x21c>)
    d556:	2205      	movs	r2, #5
    d558:	601a      	str	r2, [r3, #0]
    d55a:	e7e5      	b.n	d528 <_CommandPing+0x1a4>
    tcpipCmdStat = newCmdStat;
    d55c:	4b08      	ldr	r3, [pc, #32]	; (d580 <_CommandPing+0x1fc>)
    d55e:	2201      	movs	r2, #1
    d560:	701a      	strb	r2, [r3, #0]
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Ping: resolving host: %s\r\n", icmpTargetHost);
    d562:	f8da 3000 	ldr.w	r3, [sl]
    d566:	685b      	ldr	r3, [r3, #4]
    d568:	4a0b      	ldr	r2, [pc, #44]	; (d598 <_CommandPing+0x214>)
    d56a:	4919      	ldr	r1, [pc, #100]	; (d5d0 <_CommandPing+0x24c>)
    d56c:	4658      	mov	r0, fp
    d56e:	4798      	blx	r3
    d570:	e7c5      	b.n	d4fe <_CommandPing+0x17a>
    tcpipCmdStat = newCmdStat;
    d572:	4b03      	ldr	r3, [pc, #12]	; (d580 <_CommandPing+0x1fc>)
    d574:	2203      	movs	r2, #3
    d576:	701a      	strb	r2, [r3, #0]
    if(tcpipCmdStat == TCPIP_PING_CMD_DNS_GET)
    d578:	e7c1      	b.n	d4fe <_CommandPing+0x17a>
    d57a:	bf00      	nop
    d57c:	00000a78 	.word	0x00000a78
    d580:	2000e3af 	.word	0x2000e3af
    d584:	00000a80 	.word	0x00000a80
    d588:	00000a20 	.word	0x00000a20
    d58c:	2000e5dc 	.word	0x2000e5dc
    d590:	00000aac 	.word	0x00000aac
    d594:	2000e504 	.word	0x2000e504
    d598:	2000e390 	.word	0x2000e390
    d59c:	2000e5d4 	.word	0x2000e5d4
    d5a0:	2000e5cc 	.word	0x2000e5cc
    d5a4:	2000e5c4 	.word	0x2000e5c4
    d5a8:	00000ad0 	.word	0x00000ad0
    d5ac:	2000e5f0 	.word	0x2000e5f0
    d5b0:	00000ae0 	.word	0x00000ae0
    d5b4:	2000e718 	.word	0x2000e718
    d5b8:	2000e716 	.word	0x2000e716
    d5bc:	2000e5e8 	.word	0x2000e5e8
    d5c0:	2000e5c0 	.word	0x2000e5c0
    d5c4:	2000e5bc 	.word	0x2000e5bc
    d5c8:	2000e5c8 	.word	0x2000e5c8
    d5cc:	2000e5ec 	.word	0x2000e5ec
    d5d0:	00000b28 	.word	0x00000b28
    d5d4:	0000028c 	.word	0x0000028c

Disassembly of section .text.TCPIP_UDP_Task%226:

0000d5d8 <TCPIP_UDP_Task>:
    return TCPIP_PKT_SocketAlloc(pktSize, sizeof(UDP_HEADER), txBuffSize, allocFlags);
}
#endif // defined (TCPIP_STACK_USE_IPV4) || (TCPIP_UDP_USE_POOL_BUFFERS != 0)

void TCPIP_UDP_Task(void)
{
    d5d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d5dc:	b08b      	sub	sp, #44	; 0x2c
    if((sigPend & (TCPIP_MODULE_SIGNAL_INTERFACE_CHANGE)) != 0)
    { // interface address change occurred
        _UDPAbortSockets(netMask, TCPIP_UDP_SIGNAL_IF_CHANGE); 
    }
#else
    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    d5de:	210f      	movs	r1, #15
    d5e0:	2009      	movs	r0, #9
    d5e2:	f010 fcc3 	bl	1df6c <_TCPIPStackModuleSignalGet>
#endif  // (_TCPIP_STACK_INTERFACE_CHANGE_SIGNALING != 0)

    if((sigPend & TCPIP_MODULE_SIGNAL_RX_PENDING) != 0)
    d5e6:	f010 0f01 	tst.w	r0, #1
    d5ea:	d102      	bne.n	d5f2 <TCPIP_UDP_Task+0x1a>
    { //  RX signal occurred
        TCPIP_UDP_Process();
    }

}
    d5ec:	b00b      	add	sp, #44	; 0x2c
    d5ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    // and (IPv4 only for now)
    // 5. packet source address matches the socket expected source address or looseRemAddress flag is set
    

    pPktIf = (TCPIP_NET_IF*)pRxPkt->pktIf;
    for(sktIx = 0; sktIx < nUdpSockets; sktIx++)
    d5f2:	f8df b22c 	ldr.w	fp, [pc, #556]	; d820 <TCPIP_UDP_Task+0x248>
    d5f6:	e096      	b.n	d726 <TCPIP_UDP_Task+0x14e>
    pUDPHdr = (UDP_HEADER*)pRxPkt->pTransportLayer;
    d5f8:	f8d9 801c 	ldr.w	r8, [r9, #28]
    udpTotLength = TCPIP_Helper_ntohs(pUDPHdr->Length);
    d5fc:	f8b8 2004 	ldrh.w	r2, [r8, #4]
    d600:	0a14      	lsrs	r4, r2, #8
    d602:	ea44 2402 	orr.w	r4, r4, r2, lsl #8
    d606:	b2a4      	uxth	r4, r4
    if(udpTotLength != pRxPkt->totTransportLen)
    d608:	42a3      	cmp	r3, r4
    d60a:	f040 80a0 	bne.w	d74e <TCPIP_UDP_Task+0x176>
    return &((IPV4_HEADER*)pPkt->pNetLayer)->SourceAddress;
    d60e:	f8d9 2018 	ldr.w	r2, [r9, #24]
    d612:	9205      	str	r2, [sp, #20]
	if((pUDPHdr->Checksum != 0))
    d614:	f8b8 3006 	ldrh.w	r3, [r8, #6]
    d618:	b30b      	cbz	r3, d65e <TCPIP_UDP_Task+0x86>
	    pseudoHdr.SourceAddress.Val = pPktSrcAdd->Val;
    d61a:	68d3      	ldr	r3, [r2, #12]
    d61c:	9307      	str	r3, [sp, #28]
	    pseudoHdr.DestAddress.Val = pPktDstAdd->Val;
    d61e:	6913      	ldr	r3, [r2, #16]
    d620:	9308      	str	r3, [sp, #32]
	    pseudoHdr.Zero	= 0;
    d622:	2200      	movs	r2, #0
    d624:	f88d 2024 	strb.w	r2, [sp, #36]	; 0x24
	    pseudoHdr.Protocol = IP_PROT_UDP;
    d628:	2311      	movs	r3, #17
    d62a:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
	    pseudoHdr.Length = pUDPHdr->Length;
    d62e:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    d632:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
	    calcChkSum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)&pseudoHdr, sizeof(pseudoHdr), 0);
    d636:	210c      	movs	r1, #12
    d638:	a807      	add	r0, sp, #28
    d63a:	f00c fe3f 	bl	1a2bc <TCPIP_Helper_CalcIPChecksum>
    d63e:	43c0      	mvns	r0, r0
    d640:	b283      	uxth	r3, r0
        if((pRxPkt->pktFlags & TCPIP_MAC_PKT_FLAG_SPLIT) != 0)
    d642:	f8b9 2022 	ldrh.w	r2, [r9, #34]	; 0x22
    d646:	f012 0f04 	tst.w	r2, #4
    d64a:	d023      	beq.n	d694 <TCPIP_UDP_Task+0xbc>
            calcChkSum = TCPIP_Helper_PacketChecksum(pRxPkt, (uint8_t*)pUDPHdr, udpTotLength, calcChkSum);
    d64c:	4622      	mov	r2, r4
    d64e:	4641      	mov	r1, r8
    d650:	4648      	mov	r0, r9
    d652:	f00b fc05 	bl	18e60 <TCPIP_Helper_PacketChecksum>
            return TCPIP_MAC_PKT_ACK_CHKSUM_ERR;
    d656:	f06f 0109 	mvn.w	r1, #9
        if(calcChkSum != 0)
    d65a:	2800      	cmp	r0, #0
    d65c:	d15f      	bne.n	d71e <TCPIP_UDP_Task+0x146>
    pUDPHdr->SourcePort = TCPIP_Helper_ntohs(pUDPHdr->SourcePort);
    d65e:	f8b8 2000 	ldrh.w	r2, [r8]
    d662:	0a13      	lsrs	r3, r2, #8
    d664:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    d668:	f8a8 3000 	strh.w	r3, [r8]
    pUDPHdr->DestinationPort = TCPIP_Helper_ntohs(pUDPHdr->DestinationPort);
    d66c:	f8b8 2002 	ldrh.w	r2, [r8, #2]
    d670:	0a13      	lsrs	r3, r2, #8
    d672:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    d676:	f8a8 3002 	strh.w	r3, [r8, #2]
    pUDPHdr->Length = udpTotLength - sizeof(UDP_HEADER);    
    d67a:	3c08      	subs	r4, #8
    d67c:	f8a8 4004 	strh.w	r4, [r8, #4]
    pPktIf = (TCPIP_NET_IF*)pRxPkt->pktIf;
    d680:	f8d9 3028 	ldr.w	r3, [r9, #40]	; 0x28
    d684:	9304      	str	r3, [sp, #16]
    for(sktIx = 0; sktIx < nUdpSockets; sktIx++)
    d686:	f8db 3000 	ldr.w	r3, [fp]
    d68a:	2b00      	cmp	r3, #0
    d68c:	dd6a      	ble.n	d764 <TCPIP_UDP_Task+0x18c>
    d68e:	f04f 0a00 	mov.w	sl, #0
    d692:	e073      	b.n	d77c <TCPIP_UDP_Task+0x1a4>
            calcChkSum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pUDPHdr, udpTotLength, calcChkSum);
    d694:	461a      	mov	r2, r3
    d696:	4621      	mov	r1, r4
    d698:	4640      	mov	r0, r8
    d69a:	f00c fe0f 	bl	1a2bc <TCPIP_Helper_CalcIPChecksum>
    d69e:	e7da      	b.n	d656 <TCPIP_UDP_Task+0x7e>
        if(_localPort != h->DestinationPort)
        {   // cannot handle this port
            continue;
        }
       
        exactMatch = looseMatch = 0;
    d6a0:	2200      	movs	r2, #0

        // 2. packet address type
        if(_addType == addressType)
        {
            exactMatch = TCPIP_UDP_PKT_MATCH_IP_TYPE;
    d6a2:	2301      	movs	r3, #1
    d6a4:	e097      	b.n	d7d6 <TCPIP_UDP_Task+0x1fe>
        }

        // 3. packet source port
        if(_remotePort == h->SourcePort)
        {
            exactMatch |= TCPIP_UDP_PKT_MATCH_SRC_PORT;
    d6a6:	f043 0302 	orr.w	r3, r3, #2
    d6aa:	e09f      	b.n	d7ec <TCPIP_UDP_Task+0x214>
#if defined (TCPIP_STACK_USE_IPV4)
        if(addressType == IP_ADDRESS_TYPE_IPV4)
        {
            if(_pSktNet == pPktIf)
            {
                exactMatch |= TCPIP_UDP_PKT_MATCH_NET;
    d6ac:	f043 0304 	orr.w	r3, r3, #4
    d6b0:	e0a6      	b.n	d800 <TCPIP_UDP_Task+0x228>
        {
            if(_pktSrcAddress.Val == 0 || _flags.looseRemAddress != 0)
            {
                looseMatch |= TCPIP_UDP_PKT_MACTH_SRC_ADD;
            }
            else if(_pktSrcAddress.Val == TCPIP_IPV4_PacketGetSourceAddress(pRxPkt)->Val)
    d6b2:	f8d9 1018 	ldr.w	r1, [r9, #24]
    d6b6:	68c9      	ldr	r1, [r1, #12]
    d6b8:	9801      	ldr	r0, [sp, #4]
    d6ba:	4288      	cmp	r0, r1
    d6bc:	d158      	bne.n	d770 <TCPIP_UDP_Task+0x198>
            {
                exactMatch |= TCPIP_UDP_PKT_MACTH_SRC_ADD;
    d6be:	f043 0308 	orr.w	r3, r3, #8
            exactMatch |= TCPIP_UDP_PKT_MACTH_SRC_ADD;
        }
#endif // defined(TCPIP_STACK_USE_IPV6)

        // finally check the match we got
        if(exactMatch == TCPIP_UDP_PKT_MACTH_MASK)
    d6c2:	2b0f      	cmp	r3, #15
    d6c4:	f040 80a4 	bne.w	d810 <TCPIP_UDP_Task+0x238>
        if(pSkt->extFlags.mcastOnly != 0)
    d6c8:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
    d6cc:	f013 0f40 	tst.w	r3, #64	; 0x40
    d6d0:	d005      	beq.n	d6de <TCPIP_UDP_Task+0x106>
            if(!TCPIP_Helper_IsMcastAddress(pPktDstAdd))
    d6d2:	9b05      	ldr	r3, [sp, #20]
    d6d4:	7c1b      	ldrb	r3, [r3, #16]
    d6d6:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    d6da:	2be0      	cmp	r3, #224	; 0xe0
    d6dc:	d13a      	bne.n	d754 <TCPIP_UDP_Task+0x17c>
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    d6de:	2000      	movs	r0, #0
    d6e0:	f013 fedc 	bl	2149c <OSAL_CRIT_Enter>
    d6e4:	4606      	mov	r6, r0
    TCPIP_Helper_SingleListTailAdd(&pSkt->rxQueue, (SGL_LIST_NODE*)pNode);
    d6e6:	4649      	mov	r1, r9
    d6e8:	f104 0044 	add.w	r0, r4, #68	; 0x44
    d6ec:	f013 fd58 	bl	211a0 <TCPIP_Helper_SingleListTailAdd>
    if((pSkt->sigMask & TCPIP_UDP_SIGNAL_RX_DATA) != 0)
    d6f0:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
    d6f4:	f413 7f80 	tst.w	r3, #256	; 0x100
    d6f8:	d02f      	beq.n	d75a <TCPIP_UDP_Task+0x182>
        sigHandler = pSkt->sigHandler;
    d6fa:	6d25      	ldr	r5, [r4, #80]	; 0x50
        *pSigParam = pSkt->sigParam;
    d6fc:	6d67      	ldr	r7, [r4, #84]	; 0x54
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
    d6fe:	4631      	mov	r1, r6
    d700:	2000      	movs	r0, #0
    d702:	f013 fffa 	bl	216fa <OSAL_CRIT_Leave>
        if(sigHandler)
    d706:	b175      	cbz	r5, d726 <TCPIP_UDP_Task+0x14e>
            (*sigHandler)(pSkt->sktIx, pRxPkt->pktIf, TCPIP_UDP_SIGNAL_RX_DATA, sigParam);
    d708:	463b      	mov	r3, r7
    d70a:	f44f 7280 	mov.w	r2, #256	; 0x100
    d70e:	f8d9 1028 	ldr.w	r1, [r9, #40]	; 0x28
    d712:	f9b4 0012 	ldrsh.w	r0, [r4, #18]
    d716:	47a8      	blx	r5
    d718:	e005      	b.n	d726 <TCPIP_UDP_Task+0x14e>
            ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    d71a:	f06f 010d 	mvn.w	r1, #13
    TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
    d71e:	2209      	movs	r2, #9
    d720:	4648      	mov	r0, r9
    d722:	f010 f937 	bl	1d994 <_TCPIP_PKT_PacketAcknowledge>
    while((pRxPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
    d726:	2009      	movs	r0, #9
    d728:	f012 f846 	bl	1f7b8 <_TCPIPStackModuleRxExtract>
    d72c:	4681      	mov	r9, r0
    d72e:	2800      	cmp	r0, #0
    d730:	f43f af5c 	beq.w	d5ec <TCPIP_UDP_Task+0x14>
        if(pRxPkt->totTransportLen < sizeof(UDP_HEADER))
    d734:	f8b9 3020 	ldrh.w	r3, [r9, #32]
    d738:	2b07      	cmp	r3, #7
    d73a:	d9ee      	bls.n	d71a <TCPIP_UDP_Task+0x142>
        else if((pRxPkt->pktFlags & TCPIP_MAC_PKT_FLAG_NET_TYPE) == TCPIP_MAC_PKT_FLAG_IPV4) 
    d73c:	f8b9 2022 	ldrh.w	r2, [r9, #34]	; 0x22
    d740:	f412 7f00 	tst.w	r2, #512	; 0x200
    d744:	f43f af58 	beq.w	d5f8 <TCPIP_UDP_Task+0x20>
        ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    d748:	f06f 010e 	mvn.w	r1, #14
    d74c:	e7e7      	b.n	d71e <TCPIP_UDP_Task+0x146>
        return TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    d74e:	f06f 010d 	mvn.w	r1, #13
    d752:	e7e4      	b.n	d71e <TCPIP_UDP_Task+0x146>
                ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    d754:	f06f 010e 	mvn.w	r1, #14
        if(ackRes != TCPIP_MAC_PKT_ACK_NONE)
    d758:	e7e1      	b.n	d71e <TCPIP_UDP_Task+0x146>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
    d75a:	4631      	mov	r1, r6
    d75c:	2000      	movs	r0, #0
    d75e:	f013 ffcc 	bl	216fa <OSAL_CRIT_Leave>
        if(sigHandler)
    d762:	e7e0      	b.n	d726 <TCPIP_UDP_Task+0x14e>
            ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    d764:	f06f 010e 	mvn.w	r1, #14
    d768:	e7d9      	b.n	d71e <TCPIP_UDP_Task+0x146>
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critStatus);
    d76a:	2000      	movs	r0, #0
    d76c:	f013 ffc5 	bl	216fa <OSAL_CRIT_Leave>
    for(sktIx = 0; sktIx < nUdpSockets; sktIx++)
    d770:	f10a 0a01 	add.w	sl, sl, #1
    d774:	f8db 3000 	ldr.w	r3, [fp]
    d778:	459a      	cmp	sl, r3
    d77a:	daf3      	bge.n	d764 <TCPIP_UDP_Task+0x18c>
        critStatus = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
    d77c:	2000      	movs	r0, #0
    d77e:	f013 fe8d 	bl	2149c <OSAL_CRIT_Enter>
    d782:	4601      	mov	r1, r0
            pSkt = UDPSocketDcpt[sktIx];
    d784:	4b25      	ldr	r3, [pc, #148]	; (d81c <TCPIP_UDP_Task+0x244>)
    d786:	681b      	ldr	r3, [r3, #0]
    d788:	f853 402a 	ldr.w	r4, [r3, sl, lsl #2]
            if(pSkt == 0) 
    d78c:	2c00      	cmp	r4, #0
    d78e:	d0ec      	beq.n	d76a <TCPIP_UDP_Task+0x192>
    return (pSkt->extFlags.rxEnable == 0);
    d790:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
            if(_RxSktIsLocked(pSkt)) 
    d794:	f013 0f02 	tst.w	r3, #2
    d798:	d0e7      	beq.n	d76a <TCPIP_UDP_Task+0x192>
            if(TCPIP_Helper_SingleListCount(&pSkt->rxQueue) >= pSkt->rxQueueLimit)
    d79a:	f894 305a 	ldrb.w	r3, [r4, #90]	; 0x5a
    d79e:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
    d7a0:	429a      	cmp	r2, r3
    d7a2:	dae2      	bge.n	d76a <TCPIP_UDP_Task+0x192>
            _localPort = pSkt->localPort;
    d7a4:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    d7a6:	9302      	str	r3, [sp, #8]
            _addType = pSkt->addType;
    d7a8:	8fa6      	ldrh	r6, [r4, #60]	; 0x3c
            _remotePort = pSkt->remotePort;
    d7aa:	8d20      	ldrh	r0, [r4, #40]	; 0x28
    d7ac:	9003      	str	r0, [sp, #12]
            _flags.Val = pSkt->flags.Val;
    d7ae:	f8b4 5040 	ldrh.w	r5, [r4, #64]	; 0x40
            _pSktNet = pSkt->pSktNet;
    d7b2:	6a67      	ldr	r7, [r4, #36]	; 0x24
            _pktSrcAddress.Val = pSkt->pktSrcAddress.Val;
    d7b4:	69e0      	ldr	r0, [r4, #28]
    d7b6:	9001      	str	r0, [sp, #4]
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critStatus);
    d7b8:	2000      	movs	r0, #0
    d7ba:	f013 ff9e 	bl	216fa <OSAL_CRIT_Leave>
        if(_localPort != h->DestinationPort)
    d7be:	f8b8 3002 	ldrh.w	r3, [r8, #2]
    d7c2:	9a02      	ldr	r2, [sp, #8]
    d7c4:	4293      	cmp	r3, r2
    d7c6:	d1d3      	bne.n	d770 <TCPIP_UDP_Task+0x198>
        if(_addType == addressType)
    d7c8:	2e01      	cmp	r6, #1
    d7ca:	f43f af69 	beq.w	d6a0 <TCPIP_UDP_Task+0xc8>
        else if(_addType == IP_ADDRESS_TYPE_ANY)
    d7ce:	2e00      	cmp	r6, #0
    d7d0:	d1ce      	bne.n	d770 <TCPIP_UDP_Task+0x198>
            looseMatch = TCPIP_UDP_PKT_MATCH_IP_TYPE;
    d7d2:	2201      	movs	r2, #1
        exactMatch = looseMatch = 0;
    d7d4:	2300      	movs	r3, #0
        if(_remotePort == h->SourcePort)
    d7d6:	f8b8 1000 	ldrh.w	r1, [r8]
    d7da:	9803      	ldr	r0, [sp, #12]
    d7dc:	4281      	cmp	r1, r0
    d7de:	f43f af62 	beq.w	d6a6 <TCPIP_UDP_Task+0xce>
        else if(_flags.looseRemPort != 0)
    d7e2:	f015 0f04 	tst.w	r5, #4
            looseMatch |= TCPIP_UDP_PKT_MATCH_SRC_PORT;
    d7e6:	bf18      	it	ne
    d7e8:	f042 0202 	orrne.w	r2, r2, #2
            if(_pSktNet == pPktIf)
    d7ec:	9904      	ldr	r1, [sp, #16]
    d7ee:	42b9      	cmp	r1, r7
    d7f0:	f43f af5c 	beq.w	d6ac <TCPIP_UDP_Task+0xd4>
            else if(_pSktNet == 0 || _flags.looseNetIf != 0)
    d7f4:	b117      	cbz	r7, d7fc <TCPIP_UDP_Task+0x224>
    d7f6:	f015 0f08 	tst.w	r5, #8
    d7fa:	d001      	beq.n	d800 <TCPIP_UDP_Task+0x228>
                looseMatch |= TCPIP_UDP_PKT_MATCH_NET;
    d7fc:	f042 0204 	orr.w	r2, r2, #4
            if(_pktSrcAddress.Val == 0 || _flags.looseRemAddress != 0)
    d800:	9901      	ldr	r1, [sp, #4]
    d802:	b119      	cbz	r1, d80c <TCPIP_UDP_Task+0x234>
    d804:	f015 0f10 	tst.w	r5, #16
    d808:	f43f af53 	beq.w	d6b2 <TCPIP_UDP_Task+0xda>
                looseMatch |= TCPIP_UDP_PKT_MACTH_SRC_ADD;
    d80c:	f042 0208 	orr.w	r2, r2, #8
        {   // perfect match
            return pSkt;
        }
        else if( (looseMatch | exactMatch) == TCPIP_UDP_PKT_MACTH_MASK )
    d810:	4313      	orrs	r3, r2
    d812:	2b0f      	cmp	r3, #15
    d814:	d1ac      	bne.n	d770 <TCPIP_UDP_Task+0x198>
                    }
                }
            }
#endif  // defined (TCPIP_STACK_USE_IPV6)
            
            pSkt->addType = addressType;
    d816:	2301      	movs	r3, #1
    d818:	87a3      	strh	r3, [r4, #60]	; 0x3c
        if(pSkt == 0)
    d81a:	e755      	b.n	d6c8 <TCPIP_UDP_Task+0xf0>
    d81c:	2000e65c 	.word	0x2000e65c
    d820:	2000e660 	.word	0x2000e660

Disassembly of section .text.TCPIP_STACK_BringNetUp%227:

0000d824 <TCPIP_STACK_BringNetUp>:
{
    d824:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d828:	b095      	sub	sp, #84	; 0x54
    d82a:	4606      	mov	r6, r0
    d82c:	461f      	mov	r7, r3
    pNetIf = stackCtrlData->pNetIf;
    d82e:	f8d0 8014 	ldr.w	r8, [r0, #20]
    pNetIf->netIfIx = stackCtrlData->netIx;
    d832:	6983      	ldr	r3, [r0, #24]
    d834:	f8a8 3058 	strh.w	r3, [r8, #88]	; 0x58
    pNetIf->Flags.powerMode = stackCtrlData->powerMode;
    d838:	f898 3043 	ldrb.w	r3, [r8, #67]	; 0x43
    d83c:	7f41      	ldrb	r1, [r0, #29]
    d83e:	f361 0383 	bfi	r3, r1, #2, #2
    d842:	f888 3043 	strb.w	r3, [r8, #67]	; 0x43
    pMacObj = pNetIf->pMacObj;
    d846:	f8d8 4044 	ldr.w	r4, [r8, #68]	; 0x44
            macConfig = pNetIf->pMacConfig;
    d84a:	f8d8 9054 	ldr.w	r9, [r8, #84]	; 0x54
            if (pModConfig != 0)
    d84e:	4615      	mov	r5, r2
    d850:	b19a      	cbz	r2, d87a <TCPIP_STACK_BringNetUp+0x56>
                pConfig = _TCPIP_STACK_FindModuleData(pMacObj->macId, pModConfig, nModules);
    d852:	8820      	ldrh	r0, [r4, #0]
    while(nModules--)
    d854:	b18f      	cbz	r7, d87a <TCPIP_STACK_BringNetUp+0x56>
        if(pModConfig->moduleId == moduleId)
    d856:	8813      	ldrh	r3, [r2, #0]
    d858:	4283      	cmp	r3, r0
    d85a:	f000 80e4 	beq.w	da26 <TCPIP_STACK_BringNetUp+0x202>
    d85e:	1eba      	subs	r2, r7, #2
    d860:	462b      	mov	r3, r5
        pModConfig++;
    d862:	3308      	adds	r3, #8
    while(nModules--)
    d864:	f1b2 3fff 	cmp.w	r2, #4294967295
    d868:	d007      	beq.n	d87a <TCPIP_STACK_BringNetUp+0x56>
        if(pModConfig->moduleId == moduleId)
    d86a:	3a01      	subs	r2, #1
    d86c:	8819      	ldrh	r1, [r3, #0]
    d86e:	4281      	cmp	r1, r0
    d870:	d1f7      	bne.n	d862 <TCPIP_STACK_BringNetUp+0x3e>
                    pNetIf->pMacConfig = macConfig = pConfig->configData;
    d872:	f8d3 9004 	ldr.w	r9, [r3, #4]
    d876:	f8c8 9054 	str.w	r9, [r8, #84]	; 0x54
            if(stackCtrlData->powerMode == TCPIP_MAC_POWER_FULL)
    d87a:	7f73      	ldrb	r3, [r6, #29]
    d87c:	2b01      	cmp	r3, #1
    d87e:	d004      	beq.n	d88a <TCPIP_STACK_BringNetUp+0x66>
        if(pModConfig->moduleId == moduleId)
    d880:	4c6a      	ldr	r4, [pc, #424]	; (da2c <TCPIP_STACK_BringNetUp+0x208>)
            configData = 0;
    d882:	46aa      	mov	sl, r5
        for(modIx = 0; modIx < sizeof(TCPIP_STACK_MODULE_ENTRY_TBL)/sizeof(*TCPIP_STACK_MODULE_ENTRY_TBL); modIx++)
    d884:	f104 096c 	add.w	r9, r4, #108	; 0x6c
    d888:	e0ba      	b.n	da00 <TCPIP_STACK_BringNetUp+0x1dc>
    TCPIP_NET_IF* pNetIf = stackCtrlData->pNetIf;
    d88a:	f8d6 b014 	ldr.w	fp, [r6, #20]
    memset(pMacCtrl, 0, sizeof(*pMacCtrl));
    d88e:	f04f 0a00 	mov.w	sl, #0
    d892:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
    d896:	f8cd a040 	str.w	sl, [sp, #64]	; 0x40
    d89a:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
    d89e:	f8cd a048 	str.w	sl, [sp, #72]	; 0x48
    d8a2:	f8cd a04c 	str.w	sl, [sp, #76]	; 0x4c
    pMacCtrl->nIfs = stackCtrlData->nIfs;
    d8a6:	6833      	ldr	r3, [r6, #0]
    d8a8:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
    pMacCtrl->mallocF = TCPIP_HEAP_MallocOutline;
    d8ac:	4b60      	ldr	r3, [pc, #384]	; (da30 <TCPIP_STACK_BringNetUp+0x20c>)
    d8ae:	9304      	str	r3, [sp, #16]
    pMacCtrl->callocF = TCPIP_HEAP_CallocOutline;
    d8b0:	4b60      	ldr	r3, [pc, #384]	; (da34 <TCPIP_STACK_BringNetUp+0x210>)
    d8b2:	9305      	str	r3, [sp, #20]
    pMacCtrl->freeF = TCPIP_HEAP_FreeOutline;
    d8b4:	4b60      	ldr	r3, [pc, #384]	; (da38 <TCPIP_STACK_BringNetUp+0x214>)
    d8b6:	9306      	str	r3, [sp, #24]
    pMacCtrl->memH = stackCtrlData->memH;
    d8b8:	68f3      	ldr	r3, [r6, #12]
    d8ba:	9307      	str	r3, [sp, #28]
    pMacCtrl->pktAllocF = (TCPIP_MAC_PKT_AllocF)_TCPIP_PKT_ALLOC_FNC;
    d8bc:	4b5f      	ldr	r3, [pc, #380]	; (da3c <TCPIP_STACK_BringNetUp+0x218>)
    d8be:	9308      	str	r3, [sp, #32]
    pMacCtrl->pktFreeF = (TCPIP_MAC_PKT_FreeF)_TCPIP_PKT_FREE_FNC;
    d8c0:	4b5f      	ldr	r3, [pc, #380]	; (da40 <TCPIP_STACK_BringNetUp+0x21c>)
    d8c2:	9309      	str	r3, [sp, #36]	; 0x24
    pMacCtrl->pktAckF = (TCPIP_MAC_PKT_AckF)_TCPIP_PKT_ACK_FNC;
    d8c4:	4b5f      	ldr	r3, [pc, #380]	; (da44 <TCPIP_STACK_BringNetUp+0x220>)
    d8c6:	930a      	str	r3, [sp, #40]	; 0x28
    pMacCtrl->synchF = _TCPIP_StackSyncFunction;
    d8c8:	4b5f      	ldr	r3, [pc, #380]	; (da48 <TCPIP_STACK_BringNetUp+0x224>)
    d8ca:	930b      	str	r3, [sp, #44]	; 0x2c
    pMacCtrl->eventF = _TCPIP_MacEventCB;
    d8cc:	4b5f      	ldr	r3, [pc, #380]	; (da4c <TCPIP_STACK_BringNetUp+0x228>)
    d8ce:	930c      	str	r3, [sp, #48]	; 0x30
    pMacCtrl->eventParam = pNetIf;
    d8d0:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
    pMacCtrl->netIx = stackCtrlData->netIx;
    d8d4:	69b3      	ldr	r3, [r6, #24]
    d8d6:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
    pMacCtrl->gapDcptOffset = TCPIP_PKT_GapDcptOffset();
    d8da:	f014 fc1d 	bl	22118 <TCPIP_PKT_GapDcptOffset>
    d8de:	f8ad 0040 	strh.w	r0, [sp, #64]	; 0x40
    pMacCtrl->gapDcptSize = TCPIP_PKT_GapDcptSize();
    d8e2:	f014 fc2f 	bl	22144 <TCPIP_PKT_GapDcptSize>
    d8e6:	f8ad 0042 	strh.w	r0, [sp, #66]	; 0x42
    pMacCtrl->macAction = TCPIP_STACK_StackToMacAction(stackCtrlData->stackAction);
    d8ea:	7f33      	ldrb	r3, [r6, #28]
    d8ec:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
    pMacCtrl->powerMode = stackCtrlData->powerMode;
    d8f0:	7f73      	ldrb	r3, [r6, #29]
    d8f2:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45
    pMacCtrl->controlFlags = TCPIP_MAC_CONTROL_PAYLOAD_OFFSET_2;
    d8f6:	2301      	movs	r3, #1
    d8f8:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
    memcpy(pMacCtrl->ifPhyAddress.v, pNetIf->netMACAddr.v, sizeof(pMacCtrl->ifPhyAddress));
    d8fc:	465b      	mov	r3, fp
    d8fe:	f853 0f3c 	ldr.w	r0, [r3, #60]!
    d902:	9012      	str	r0, [sp, #72]	; 0x48
    d904:	889b      	ldrh	r3, [r3, #4]
    d906:	f8ad 304c 	strh.w	r3, [sp, #76]	; 0x4c
                TCPIP_MAC_INIT macInit =
    d90a:	f88d a004 	strb.w	sl, [sp, #4]
    d90e:	ab04      	add	r3, sp, #16
    d910:	9302      	str	r3, [sp, #8]
    d912:	f8cd 900c 	str.w	r9, [sp, #12]
                pNetIf->macObjHandle = (*pMacObj->TCPIP_MAC_Initialize)(pMacObj->macId, &macInit.moduleInit);
    d916:	68a3      	ldr	r3, [r4, #8]
    d918:	a901      	add	r1, sp, #4
    d91a:	8820      	ldrh	r0, [r4, #0]
    d91c:	4798      	blx	r3
    d91e:	f8c8 004c 	str.w	r0, [r8, #76]	; 0x4c
                if( pNetIf->macObjHandle == SYS_MODULE_OBJ_INVALID)
    d922:	f1b0 3fff 	cmp.w	r0, #4294967295
    d926:	d017      	beq.n	d958 <TCPIP_STACK_BringNetUp+0x134>
                pNetIf->hIfMac = (*pMacObj->TCPIP_MAC_Open)(pMacObj->macId, DRV_IO_INTENT_READWRITE);
    d928:	69e3      	ldr	r3, [r4, #28]
    d92a:	2103      	movs	r1, #3
    d92c:	8820      	ldrh	r0, [r4, #0]
    d92e:	4798      	blx	r3
    d930:	f8c8 0050 	str.w	r0, [r8, #80]	; 0x50
                if(pNetIf->hIfMac == DRV_HANDLE_INVALID)
    d934:	f1b0 3fff 	cmp.w	r0, #4294967295
    d938:	d1a2      	bne.n	d880 <TCPIP_STACK_BringNetUp+0x5c>
                    pNetIf->hIfMac = 0;
    d93a:	2300      	movs	r3, #0
    d93c:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
                    pNetIf->macObjHandle = 0;
    d940:	f8c8 304c 	str.w	r3, [r8, #76]	; 0x4c
                    SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "%s MAC Open failed\r\n", pMacObj->macName);
    d944:	f014 fb02 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
    d948:	b158      	cbz	r0, d962 <TCPIP_STACK_BringNetUp+0x13e>
    d94a:	f014 faf9 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
    d94e:	6862      	ldr	r2, [r4, #4]
    d950:	493f      	ldr	r1, [pc, #252]	; (da50 <TCPIP_STACK_BringNetUp+0x22c>)
    d952:	f00c ff0b 	bl	1a76c <SYS_CONSOLE_Print>
    d956:	e004      	b.n	d962 <TCPIP_STACK_BringNetUp+0x13e>
                    pNetIf->macObjHandle = 0;
    d958:	f8c8 a04c 	str.w	sl, [r8, #76]	; 0x4c
                    SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "%s MAC initialization failed\r\n", pMacObj->macName);
    d95c:	f014 faf6 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
    d960:	b908      	cbnz	r0, d966 <TCPIP_STACK_BringNetUp+0x142>
        return false;
    d962:	2400      	movs	r4, #0
    d964:	e03e      	b.n	d9e4 <TCPIP_STACK_BringNetUp+0x1c0>
                    SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "%s MAC initialization failed\r\n", pMacObj->macName);
    d966:	f014 faeb 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
    d96a:	6862      	ldr	r2, [r4, #4]
    d96c:	4939      	ldr	r1, [pc, #228]	; (da54 <TCPIP_STACK_BringNetUp+0x230>)
    d96e:	f00c fefd 	bl	1a76c <SYS_CONSOLE_Print>
    d972:	e7f6      	b.n	d962 <TCPIP_STACK_BringNetUp+0x13e>
            configData = 0;
    d974:	2100      	movs	r1, #0
    d976:	e03b      	b.n	d9f0 <TCPIP_STACK_BringNetUp+0x1cc>
    d978:	4651      	mov	r1, sl
    d97a:	e039      	b.n	d9f0 <TCPIP_STACK_BringNetUp+0x1cc>
    d97c:	2100      	movs	r1, #0
    d97e:	e037      	b.n	d9f0 <TCPIP_STACK_BringNetUp+0x1cc>
                SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Module no: %d Initialization failed\r\n", pEntry->moduleId);
    d980:	f014 fae4 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
    d984:	b908      	cbnz	r0, d98a <TCPIP_STACK_BringNetUp+0x166>
                netUpFail = 1;
    d986:	2401      	movs	r4, #1
    d988:	e02a      	b.n	d9e0 <TCPIP_STACK_BringNetUp+0x1bc>
                SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Module no: %d Initialization failed\r\n", pEntry->moduleId);
    d98a:	f014 fad9 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
    d98e:	8822      	ldrh	r2, [r4, #0]
    d990:	4931      	ldr	r1, [pc, #196]	; (da58 <TCPIP_STACK_BringNetUp+0x234>)
    d992:	f00c feeb 	bl	1a76c <SYS_CONSOLE_Print>
                netUpFail = 1;
    d996:	2401      	movs	r4, #1
    d998:	e022      	b.n	d9e0 <TCPIP_STACK_BringNetUp+0x1bc>
        if(!netUpFail && pNetIf->hIfMac != 0)
    d99a:	f8d8 0050 	ldr.w	r0, [r8, #80]	; 0x50
    d99e:	b1f0      	cbz	r0, d9de <TCPIP_STACK_BringNetUp+0x1ba>
                if(!(*pNetIf->pMacObj->TCPIP_MAC_EventMaskSet)(pNetIf->hIfMac, TCPIP_STACK_MAC_ALL_EVENTS, true))
    d9a0:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
    d9a4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    d9a6:	2201      	movs	r2, #1
    d9a8:	f240 7196 	movw	r1, #1942	; 0x796
    d9ac:	4798      	blx	r3
    d9ae:	4604      	mov	r4, r0
    d9b0:	b148      	cbz	r0, d9c6 <TCPIP_STACK_BringNetUp+0x1a2>
            pNetIf->Flags.bMacInitialize = true;
    d9b2:	f898 3043 	ldrb.w	r3, [r8, #67]	; 0x43
            pNetIf->Flags.bMacInitDone = false;
    d9b6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    d9ba:	f36f 13c7 	bfc	r3, #7, #1
    d9be:	f888 3043 	strb.w	r3, [r8, #67]	; 0x43
    netUpFail = false;
    d9c2:	2400      	movs	r4, #0
    d9c4:	e00c      	b.n	d9e0 <TCPIP_STACK_BringNetUp+0x1bc>
                    SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "%s MAC event notification setting failed\r\n", pNetIf->pMacObj->macName);
    d9c6:	f014 fac1 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
    d9ca:	b158      	cbz	r0, d9e4 <TCPIP_STACK_BringNetUp+0x1c0>
    d9cc:	f014 fab8 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
    d9d0:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
    d9d4:	685a      	ldr	r2, [r3, #4]
    d9d6:	4921      	ldr	r1, [pc, #132]	; (da5c <TCPIP_STACK_BringNetUp+0x238>)
    d9d8:	f00c fec8 	bl	1a76c <SYS_CONSOLE_Print>
    d9dc:	e002      	b.n	d9e4 <TCPIP_STACK_BringNetUp+0x1c0>
    netUpFail = false;
    d9de:	2400      	movs	r4, #0
    if(netUpFail)
    d9e0:	f084 0401 	eor.w	r4, r4, #1
}
    d9e4:	4620      	mov	r0, r4
    d9e6:	b015      	add	sp, #84	; 0x54
    d9e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(pModConfig->moduleId == moduleId)
    d9ec:	462b      	mov	r3, r5
                    configData = pConfig->configData;
    d9ee:	6859      	ldr	r1, [r3, #4]
            if(!pEntry->initFunc(stackCtrlData, configData))
    d9f0:	6863      	ldr	r3, [r4, #4]
    d9f2:	4630      	mov	r0, r6
    d9f4:	4798      	blx	r3
    d9f6:	2800      	cmp	r0, #0
    d9f8:	d0c2      	beq.n	d980 <TCPIP_STACK_BringNetUp+0x15c>
            pEntry++;
    d9fa:	340c      	adds	r4, #12
        for(modIx = 0; modIx < sizeof(TCPIP_STACK_MODULE_ENTRY_TBL)/sizeof(*TCPIP_STACK_MODULE_ENTRY_TBL); modIx++)
    d9fc:	454c      	cmp	r4, r9
    d9fe:	d0cc      	beq.n	d99a <TCPIP_STACK_BringNetUp+0x176>
            if (pModConfig != 0)
    da00:	2d00      	cmp	r5, #0
    da02:	d0b9      	beq.n	d978 <TCPIP_STACK_BringNetUp+0x154>
                pConfig = _TCPIP_STACK_FindModuleData(pEntry->moduleId, pModConfig, nModules);
    da04:	8821      	ldrh	r1, [r4, #0]
    while(nModules--)
    da06:	2f00      	cmp	r7, #0
    da08:	d0b8      	beq.n	d97c <TCPIP_STACK_BringNetUp+0x158>
        if(pModConfig->moduleId == moduleId)
    da0a:	882b      	ldrh	r3, [r5, #0]
    da0c:	428b      	cmp	r3, r1
    da0e:	d0ed      	beq.n	d9ec <TCPIP_STACK_BringNetUp+0x1c8>
    da10:	1eba      	subs	r2, r7, #2
    da12:	462b      	mov	r3, r5
        pModConfig++;
    da14:	3308      	adds	r3, #8
    while(nModules--)
    da16:	f1b2 3fff 	cmp.w	r2, #4294967295
    da1a:	d0ab      	beq.n	d974 <TCPIP_STACK_BringNetUp+0x150>
        if(pModConfig->moduleId == moduleId)
    da1c:	3a01      	subs	r2, #1
    da1e:	8818      	ldrh	r0, [r3, #0]
    da20:	4288      	cmp	r0, r1
    da22:	d1f7      	bne.n	da14 <TCPIP_STACK_BringNetUp+0x1f0>
    da24:	e7e3      	b.n	d9ee <TCPIP_STACK_BringNetUp+0x1ca>
    da26:	4613      	mov	r3, r2
    da28:	e723      	b.n	d872 <TCPIP_STACK_BringNetUp+0x4e>
    da2a:	bf00      	nop
    da2c:	0001a694 	.word	0x0001a694
    da30:	00022033 	.word	0x00022033
    da34:	0002203b 	.word	0x0002203b
    da38:	00022043 	.word	0x00022043
    da3c:	00018c55 	.word	0x00018c55
    da40:	0001dfa9 	.word	0x0001dfa9
    da44:	0001d995 	.word	0x0001d995
    da48:	0001a017 	.word	0x0001a017
    da4c:	0001c7b1 	.word	0x0001c7b1
    da50:	0000856c 	.word	0x0000856c
    da54:	0000853c 	.word	0x0000853c
    da58:	00008590 	.word	0x00008590
    da5c:	000085c4 	.word	0x000085c4

Disassembly of section .text.TCPIP_IPV4_Task%228:

0000da60 <TCPIP_IPV4_Task>:
    TCPIP_Helper_ProtectedSingleListUnlock(&ipv4ArpQueue);

}

void  TCPIP_IPV4_Task(void)
{
    da60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    da64:	b087      	sub	sp, #28
    TCPIP_MODULE_SIGNAL sigPend;

    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    da66:	210f      	movs	r1, #15
    da68:	2003      	movs	r0, #3
    da6a:	f010 fa7f 	bl	1df6c <_TCPIPStackModuleSignalGet>

    if((sigPend & TCPIP_MODULE_SIGNAL_RX_PENDING) != 0)
    da6e:	f010 0f01 	tst.w	r0, #1
    da72:	d102      	bne.n	da7a <TCPIP_IPV4_Task+0x1a>
    { // regular TMO occurred
        TCPIP_IPV4_Timeout();
    }
#endif  // (_TCPIP_IPV4_FRAGMENTATION != 0)

}
    da74:	b007      	add	sp, #28
    da76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    uint32_t cnt1, cnt2;

    // get a consistent reading
    do
    {
        cnt1 = ipv4ActFilterCount;
    da7a:	f8df 8214 	ldr.w	r8, [pc, #532]	; dc90 <TCPIP_IPV4_Task+0x230>
  Remarks:
    None
*/
static __inline__ void __attribute__((always_inline)) TCPIP_Notification_Lock(PROTECTED_SINGLE_LIST* notifyList)
{
    TCPIP_Helper_ProtectedSingleListLock(notifyList);
    da7e:	4f81      	ldr	r7, [pc, #516]	; (dc84 <TCPIP_IPV4_Task+0x224>)
        return TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    da80:	f06f 090e 	mvn.w	r9, #14
    da84:	e0b8      	b.n	dbf8 <TCPIP_IPV4_Task+0x198>
            payloadLen = TCPIP_PKT_PayloadLen(pRxPkt);
    da86:	4628      	mov	r0, r5
    da88:	f013 f8ed 	bl	20c66 <TCPIP_PKT_PayloadLen>
            if(totalLength > payloadLen)
    da8c:	4582      	cmp	sl, r0
    da8e:	f200 80df 	bhi.w	dc50 <TCPIP_IPV4_Task+0x1f0>
            pNetIf = _TCPIPStackMapAliasInterface((TCPIP_NET_IF*)pRxPkt->pktIf, &pHeader->DestAddress);
    da92:	f8d5 a028 	ldr.w	sl, [r5, #40]	; 0x28
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
    da96:	f1ba 0f00 	cmp.w	sl, #0
    da9a:	f000 80e8 	beq.w	dc6e <TCPIP_IPV4_Task+0x20e>
    da9e:	f89a 3042 	ldrb.w	r3, [sl, #66]	; 0x42
    daa2:	f013 0f40 	tst.w	r3, #64	; 0x40
    daa6:	d102      	bne.n	daae <TCPIP_IPV4_Task+0x4e>
                ackRes = TCPIP_MAC_PKT_ACK_IP_REJECT_ERR;
    daa8:	f06f 0112 	mvn.w	r1, #18
    daac:	e0a0      	b.n	dbf0 <TCPIP_IPV4_Task+0x190>
    return (pIpAdd->Val == 0xFFFFFFFF) ||  (pIpAdd->Val == (pNetIf->netIPAddr.Val | ~pNetIf->netMask.Val));
    daae:	68f3      	ldr	r3, [r6, #12]
    dab0:	f1b3 3fff 	cmp.w	r3, #4294967295
    dab4:	f000 80cf 	beq.w	dc56 <TCPIP_IPV4_Task+0x1f6>
    dab8:	f8da 1008 	ldr.w	r1, [sl, #8]
    dabc:	f8da 2004 	ldr.w	r2, [sl, #4]
    dac0:	ea62 0201 	orn	r2, r2, r1
            if(_TCPIPStack_IsBcastAddress(pNetIf, &pHeader->SourceAddress))
    dac4:	4293      	cmp	r3, r2
    dac6:	f000 80c9 	beq.w	dc5c <TCPIP_IPV4_Task+0x1fc>
            if(pHeader->DestAddress.Val == 0)
    daca:	6933      	ldr	r3, [r6, #16]
    dacc:	b913      	cbnz	r3, dad4 <TCPIP_IPV4_Task+0x74>
                ackRes = TCPIP_MAC_PKT_ACK_DEST_ERR;
    dace:	f06f 010b 	mvn.w	r1, #11
    dad2:	e08d      	b.n	dbf0 <TCPIP_IPV4_Task+0x190>
            headerChecksum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pHeader, headerLen, 0);
    dad4:	2200      	movs	r2, #0
    dad6:	4659      	mov	r1, fp
    dad8:	4630      	mov	r0, r6
    dada:	f00c fbef 	bl	1a2bc <TCPIP_Helper_CalcIPChecksum>
            if(headerChecksum)
    dade:	2800      	cmp	r0, #0
    dae0:	f040 80bf 	bne.w	dc62 <TCPIP_IPV4_Task+0x202>
            cIpv4Hdr = *pHeader;
    dae4:	f10d 0c04 	add.w	ip, sp, #4
    dae8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    daea:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    daee:	6833      	ldr	r3, [r6, #0]
    daf0:	f8cc 3000 	str.w	r3, [ip]
            pCHeader->FragmentInfo.val = TCPIP_Helper_ntohs(pCHeader->FragmentInfo.val);
    daf4:	f8bd 200a 	ldrh.w	r2, [sp, #10]
    daf8:	0a13      	lsrs	r3, r2, #8
    dafa:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
            if(pCHeader->FragmentInfo.MF != 0 || pCHeader->FragmentInfo.fragOffset != 0)
    dafe:	f3c3 030d 	ubfx	r3, r3, #0, #14
    db02:	2b00      	cmp	r3, #0
    db04:	f040 80b0 	bne.w	dc68 <TCPIP_IPV4_Task+0x208>
    return ((pIf->netIPAddr.Val ^ pIpAddress->Val) & pIf->netMask.Val) == 0;
    db08:	f8da 0004 	ldr.w	r0, [sl, #4]
    db0c:	9b05      	ldr	r3, [sp, #20]
    db0e:	f8da 2008 	ldr.w	r2, [sl, #8]
            if(_TCPIPStackHostPartAddress(pNetIf, pktDestIP) == 0)
    db12:	ea00 0102 	and.w	r1, r0, r2
    db16:	428b      	cmp	r3, r1
    db18:	d01a      	beq.n	db50 <TCPIP_IPV4_Task+0xf0>
        currFilter = ipv4FilterType;
    db1a:	495b      	ldr	r1, [pc, #364]	; (dc88 <TCPIP_IPV4_Task+0x228>)
    db1c:	7809      	ldrb	r1, [r1, #0]
    return (pIpAdd->Val == 0xFFFFFFFF) ||  (pIpAdd->Val == (pNetIf->netIPAddr.Val | ~pNetIf->netMask.Val));
    db1e:	f1b3 3fff 	cmp.w	r3, #4294967295
    db22:	d012      	beq.n	db4a <TCPIP_IPV4_Task+0xea>
    db24:	ea60 0202 	orn	r2, r0, r2
        if(_TCPIPStack_IsBcastAddress(pNetIf, pktDestIP))
    db28:	4293      	cmp	r3, r2
    db2a:	d00e      	beq.n	db4a <TCPIP_IPV4_Task+0xea>
        if(TCPIP_Helper_IsMcastAddress(pktDestIP))
    db2c:	f89d 2014 	ldrb.w	r2, [sp, #20]
    db30:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
    db34:	2ae0      	cmp	r2, #224	; 0xe0
    db36:	d015      	beq.n	db64 <TCPIP_IPV4_Task+0x104>
    return (pIpAdd->Val == 0x0100007f || pNetIf->netIPAddr.Val == pIpAdd->Val);
    db38:	4a54      	ldr	r2, [pc, #336]	; (dc8c <TCPIP_IPV4_Task+0x22c>)
    db3a:	4293      	cmp	r3, r2
    db3c:	d001      	beq.n	db42 <TCPIP_IPV4_Task+0xe2>
        if(TCPIP_STACK_AddressIsOfNet(pNetIf, pktDestIP))
    db3e:	4298      	cmp	r0, r3
    db40:	d106      	bne.n	db50 <TCPIP_IPV4_Task+0xf0>
            procType = ((currFilter & TCPIP_IPV4_FILTER_UNICAST) == 0) ? (IPV4_PKT_DEST_HOST | IPV4_PKT_TYPE_UNICAST) : (IPV4_PKT_TYPE_UNICAST);
    db42:	f011 0f01 	tst.w	r1, #1
    db46:	d103      	bne.n	db50 <TCPIP_IPV4_Task+0xf0>
    db48:	e00f      	b.n	db6a <TCPIP_IPV4_Task+0x10a>
            procType = ((currFilter & TCPIP_IPV4_FILTER_BROADCAST) == 0) ? (IPV4_PKT_DEST_HOST | IPV4_PKT_TYPE_BCAST) : (IPV4_PKT_TYPE_BCAST);
    db4a:	f011 0f02 	tst.w	r1, #2
    db4e:	d00c      	beq.n	db6a <TCPIP_IPV4_Task+0x10a>
        cnt1 = ipv4ActFilterCount;
    db50:	f8d8 2000 	ldr.w	r2, [r8]
        cnt2 = ipv4ActFilterCount;
    db54:	f8d8 3000 	ldr.w	r3, [r8]
    }while(cnt1 != cnt2);
    db58:	429a      	cmp	r2, r3
    db5a:	d1f9      	bne.n	db50 <TCPIP_IPV4_Task+0xf0>


    _IPv4FiltCountDbg("verify");
    if(cnt1 != 0)
    db5c:	bb53      	cbnz	r3, dbb4 <TCPIP_IPV4_Task+0x154>
                ackRes = TCPIP_MAC_PKT_ACK_IP_REJECT_ERR;
    db5e:	f06f 0112 	mvn.w	r1, #18
    db62:	e045      	b.n	dbf0 <TCPIP_IPV4_Task+0x190>
            procType = ((currFilter & TCPIP_IPV4_FILTER_MULTICAST) == 0) ? (IPV4_PKT_DEST_HOST | IPV4_PKT_TYPE_MCAST) : (IPV4_PKT_TYPE_MCAST);
    db64:	f011 0f04 	tst.w	r1, #4
    db68:	d1f2      	bne.n	db50 <TCPIP_IPV4_Task+0xf0>
    pHeader = (IPV4_HEADER*)pRxPkt->pNetLayer;
    db6a:	69a9      	ldr	r1, [r5, #24]
    headerLen = pHeader->IHL << 2;
    db6c:	780b      	ldrb	r3, [r1, #0]
    db6e:	009b      	lsls	r3, r3, #2
    db70:	f003 033c 	and.w	r3, r3, #60	; 0x3c
    pRxPkt->pTransportLayer = pRxPkt->pNetLayer + headerLen;
    db74:	18ca      	adds	r2, r1, r3
    db76:	61ea      	str	r2, [r5, #28]
    pRxPkt->pDSeg->segLen -= headerLen;
    db78:	6928      	ldr	r0, [r5, #16]
    db7a:	b29b      	uxth	r3, r3
    db7c:	8982      	ldrh	r2, [r0, #12]
    db7e:	1ad2      	subs	r2, r2, r3
    db80:	8182      	strh	r2, [r0, #12]
    pHeader->TotalLength = TCPIP_Helper_ntohs(pHeader->TotalLength);
    db82:	8848      	ldrh	r0, [r1, #2]
    db84:	0a02      	lsrs	r2, r0, #8
    db86:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
    db8a:	b292      	uxth	r2, r2
    db8c:	804a      	strh	r2, [r1, #2]
    pRxPkt->totTransportLen = pHeader->TotalLength - headerLen;
    db8e:	1ad3      	subs	r3, r2, r3
    db90:	842b      	strh	r3, [r5, #32]
    pHeader->FragmentInfo.val = TCPIP_Helper_ntohs(pHeader->FragmentInfo.val);
    db92:	88ca      	ldrh	r2, [r1, #6]
    db94:	0a13      	lsrs	r3, r2, #8
    db96:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    db9a:	b29b      	uxth	r3, r3
    db9c:	80cb      	strh	r3, [r1, #6]
    isFragment = pHeader->FragmentInfo.MF != 0 || pHeader->FragmentInfo.fragOffset != 0;
    db9e:	f3c3 030d 	ubfx	r3, r3, #0, #14
    switch(pHeader->Protocol)
    dba2:	7a4a      	ldrb	r2, [r1, #9]
    dba4:	2a06      	cmp	r2, #6
    dba6:	d065      	beq.n	dc74 <TCPIP_IPV4_Task+0x214>
    dba8:	2a11      	cmp	r2, #17
    dbaa:	d065      	beq.n	dc78 <TCPIP_IPV4_Task+0x218>
    dbac:	2a01      	cmp	r2, #1
    dbae:	d016      	beq.n	dbde <TCPIP_IPV4_Task+0x17e>
        return TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;
    dbb0:	4649      	mov	r1, r9
    dbb2:	e01d      	b.n	dbf0 <TCPIP_IPV4_Task+0x190>
    dbb4:	4638      	mov	r0, r7
    dbb6:	f012 fedb 	bl	20970 <TCPIP_Helper_ProtectedSingleListLock>
    {   // active filters
        TCPIP_Notification_Lock(&ipv4PacketFilters);
        for(fNode = (IPV4_FILTER_LIST_NODE*)ipv4PacketFilters.list.head; fNode != 0; fNode = fNode->next)
    dbba:	683e      	ldr	r6, [r7, #0]
    dbbc:	e000      	b.n	dbc0 <TCPIP_IPV4_Task+0x160>
    dbbe:	6836      	ldr	r6, [r6, #0]
    dbc0:	2e00      	cmp	r6, #0
    dbc2:	d05b      	beq.n	dc7c <TCPIP_IPV4_Task+0x21c>
        {
            if(fNode->active != 0)
    dbc4:	7a33      	ldrb	r3, [r6, #8]
    dbc6:	2b00      	cmp	r3, #0
    dbc8:	d0f9      	beq.n	dbbe <TCPIP_IPV4_Task+0x15e>
            {
                if((*fNode->handler)(pRxPkt, hdrlen))
    dbca:	6873      	ldr	r3, [r6, #4]
    dbcc:	4621      	mov	r1, r4
    dbce:	4628      	mov	r0, r5
    dbd0:	4798      	blx	r3
    dbd2:	2800      	cmp	r0, #0
    dbd4:	d0f3      	beq.n	dbbe <TCPIP_IPV4_Task+0x15e>
  Remarks:
    None
*/
static __inline__ void __attribute__((always_inline)) TCPIP_Notification_Unlock(PROTECTED_SINGLE_LIST* notifyList)
{
    TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
    dbd6:	4638      	mov	r0, r7
    dbd8:	f013 f91c 	bl	20e14 <TCPIP_Helper_ProtectedSingleListUnlock>
            }
        }
        TCPIP_Notification_Unlock(&ipv4PacketFilters);
    }
        
    return pktOk;
    dbdc:	e7c5      	b.n	db6a <TCPIP_IPV4_Task+0x10a>
            destId = TCPIP_MODULE_ICMP;
    dbde:	2006      	movs	r0, #6
    if(!isFragment)
    dbe0:	b953      	cbnz	r3, dbf8 <TCPIP_IPV4_Task+0x198>
        _TCPIPStackModuleRxInsert(destId, pRxPkt, true);
    dbe2:	2201      	movs	r2, #1
    dbe4:	4629      	mov	r1, r5
    dbe6:	f00f fbc1 	bl	1d36c <_TCPIPStackModuleRxInsert>
    dbea:	e005      	b.n	dbf8 <TCPIP_IPV4_Task+0x198>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    dbec:	f06f 010d 	mvn.w	r1, #13
            TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes); 
    dbf0:	2203      	movs	r2, #3
    dbf2:	4628      	mov	r0, r5
    dbf4:	f00f fece 	bl	1d994 <_TCPIP_PKT_PacketAcknowledge>
    while((pRxPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
    dbf8:	2003      	movs	r0, #3
    dbfa:	f011 fddd 	bl	1f7b8 <_TCPIPStackModuleRxExtract>
    dbfe:	4605      	mov	r5, r0
    dc00:	2800      	cmp	r0, #0
    dc02:	f43f af37 	beq.w	da74 <TCPIP_IPV4_Task+0x14>
            pHeader = (IPV4_HEADER*)pRxPkt->pNetLayer;
    dc06:	69ae      	ldr	r6, [r5, #24]
            if((pHeader->Version) != IPv4_VERSION)
    dc08:	7833      	ldrb	r3, [r6, #0]
    dc0a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    dc0e:	2b40      	cmp	r3, #64	; 0x40
    dc10:	d1ec      	bne.n	dbec <TCPIP_IPV4_Task+0x18c>
            headerLen = pHeader->IHL << 2;
    dc12:	7834      	ldrb	r4, [r6, #0]
    dc14:	00a4      	lsls	r4, r4, #2
    dc16:	f004 043c 	and.w	r4, r4, #60	; 0x3c
            if(headerLen < sizeof(IPV4_HEADER) || (uint16_t)headerLen > pRxPkt->pDSeg->segLen)
    dc1a:	2c13      	cmp	r4, #19
    dc1c:	d912      	bls.n	dc44 <TCPIP_IPV4_Task+0x1e4>
    dc1e:	fa1f fb84 	uxth.w	fp, r4
    dc22:	692b      	ldr	r3, [r5, #16]
    dc24:	899b      	ldrh	r3, [r3, #12]
    dc26:	455b      	cmp	r3, fp
    dc28:	d30f      	bcc.n	dc4a <TCPIP_IPV4_Task+0x1ea>
            totalLength = TCPIP_Helper_ntohs(pHeader->TotalLength);
    dc2a:	8873      	ldrh	r3, [r6, #2]
    dc2c:	ea4f 2a13 	mov.w	sl, r3, lsr #8
    dc30:	ea4a 2a03 	orr.w	sl, sl, r3, lsl #8
    dc34:	fa1f fa8a 	uxth.w	sl, sl
            if(totalLength < (uint16_t)headerLen)
    dc38:	45d3      	cmp	fp, sl
    dc3a:	f67f af24 	bls.w	da86 <TCPIP_IPV4_Task+0x26>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    dc3e:	f06f 010d 	mvn.w	r1, #13
    dc42:	e7d5      	b.n	dbf0 <TCPIP_IPV4_Task+0x190>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    dc44:	f06f 010d 	mvn.w	r1, #13
    dc48:	e7d2      	b.n	dbf0 <TCPIP_IPV4_Task+0x190>
    dc4a:	f06f 010d 	mvn.w	r1, #13
    dc4e:	e7cf      	b.n	dbf0 <TCPIP_IPV4_Task+0x190>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    dc50:	f06f 010d 	mvn.w	r1, #13
    dc54:	e7cc      	b.n	dbf0 <TCPIP_IPV4_Task+0x190>
                ackRes = TCPIP_MAC_PKT_ACK_SOURCE_ERR;
    dc56:	f06f 010a 	mvn.w	r1, #10
    dc5a:	e7c9      	b.n	dbf0 <TCPIP_IPV4_Task+0x190>
    dc5c:	f06f 010a 	mvn.w	r1, #10
    dc60:	e7c6      	b.n	dbf0 <TCPIP_IPV4_Task+0x190>
                ackRes = TCPIP_MAC_PKT_ACK_CHKSUM_ERR;
    dc62:	f06f 0109 	mvn.w	r1, #9
    dc66:	e7c3      	b.n	dbf0 <TCPIP_IPV4_Task+0x190>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    dc68:	f06f 010d 	mvn.w	r1, #13
    dc6c:	e7c0      	b.n	dbf0 <TCPIP_IPV4_Task+0x190>
                ackRes = TCPIP_MAC_PKT_ACK_IP_REJECT_ERR;
    dc6e:	f06f 0112 	mvn.w	r1, #18
        if(ackRes != TCPIP_MAC_PKT_ACK_NONE)
    dc72:	e7bd      	b.n	dbf0 <TCPIP_IPV4_Task+0x190>
            destId = TCPIP_MODULE_TCP;
    dc74:	200a      	movs	r0, #10
    dc76:	e7b3      	b.n	dbe0 <TCPIP_IPV4_Task+0x180>
            destId = TCPIP_MODULE_UDP;
    dc78:	2009      	movs	r0, #9
    if(destId == TCPIP_MODULE_NONE)
    dc7a:	e7b1      	b.n	dbe0 <TCPIP_IPV4_Task+0x180>
    dc7c:	4638      	mov	r0, r7
    dc7e:	f013 f8c9 	bl	20e14 <TCPIP_Helper_ProtectedSingleListUnlock>
    return pktOk;
    dc82:	e76c      	b.n	db5e <TCPIP_IPV4_Task+0xfe>
    dc84:	2000e43c 	.word	0x2000e43c
    dc88:	2000e728 	.word	0x2000e728
    dc8c:	0100007f 	.word	0x0100007f
    dc90:	2000e5fc 	.word	0x2000e5fc

Disassembly of section .text._printf_i%229:

0000dc94 <_printf_i>:
    dc94:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    dc98:	4606      	mov	r6, r0
    dc9a:	460c      	mov	r4, r1
    dc9c:	f101 0043 	add.w	r0, r1, #67	; 0x43
    dca0:	7e09      	ldrb	r1, [r1, #24]
    dca2:	b085      	sub	sp, #20
    dca4:	296e      	cmp	r1, #110	; 0x6e
    dca6:	4698      	mov	r8, r3
    dca8:	4617      	mov	r7, r2
    dcaa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    dcac:	f000 80ba 	beq.w	de24 <_printf_i+0x190>
    dcb0:	d824      	bhi.n	dcfc <_printf_i+0x68>
    dcb2:	2963      	cmp	r1, #99	; 0x63
    dcb4:	d039      	beq.n	dd2a <_printf_i+0x96>
    dcb6:	d80a      	bhi.n	dcce <_printf_i+0x3a>
    dcb8:	2900      	cmp	r1, #0
    dcba:	f000 80c3 	beq.w	de44 <_printf_i+0x1b0>
    dcbe:	2958      	cmp	r1, #88	; 0x58
    dcc0:	f000 8091 	beq.w	dde6 <_printf_i+0x152>
    dcc4:	f104 0542 	add.w	r5, r4, #66	; 0x42
    dcc8:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
    dccc:	e035      	b.n	dd3a <_printf_i+0xa6>
    dcce:	2964      	cmp	r1, #100	; 0x64
    dcd0:	d001      	beq.n	dcd6 <_printf_i+0x42>
    dcd2:	2969      	cmp	r1, #105	; 0x69
    dcd4:	d1f6      	bne.n	dcc4 <_printf_i+0x30>
    dcd6:	6825      	ldr	r5, [r4, #0]
    dcd8:	681a      	ldr	r2, [r3, #0]
    dcda:	f015 0f80 	tst.w	r5, #128	; 0x80
    dcde:	f102 0104 	add.w	r1, r2, #4
    dce2:	d02c      	beq.n	dd3e <_printf_i+0xaa>
    dce4:	6812      	ldr	r2, [r2, #0]
    dce6:	6019      	str	r1, [r3, #0]
    dce8:	2a00      	cmp	r2, #0
    dcea:	da03      	bge.n	dcf4 <_printf_i+0x60>
    dcec:	232d      	movs	r3, #45	; 0x2d
    dcee:	4252      	negs	r2, r2
    dcf0:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    dcf4:	f8df c1bc 	ldr.w	ip, [pc, #444]	; deb4 <_printf_i+0x220>
    dcf8:	230a      	movs	r3, #10
    dcfa:	e03f      	b.n	dd7c <_printf_i+0xe8>
    dcfc:	2973      	cmp	r1, #115	; 0x73
    dcfe:	f000 80a5 	beq.w	de4c <_printf_i+0x1b8>
    dd02:	d808      	bhi.n	dd16 <_printf_i+0x82>
    dd04:	296f      	cmp	r1, #111	; 0x6f
    dd06:	d021      	beq.n	dd4c <_printf_i+0xb8>
    dd08:	2970      	cmp	r1, #112	; 0x70
    dd0a:	d1db      	bne.n	dcc4 <_printf_i+0x30>
    dd0c:	6822      	ldr	r2, [r4, #0]
    dd0e:	f042 0220 	orr.w	r2, r2, #32
    dd12:	6022      	str	r2, [r4, #0]
    dd14:	e003      	b.n	dd1e <_printf_i+0x8a>
    dd16:	2975      	cmp	r1, #117	; 0x75
    dd18:	d018      	beq.n	dd4c <_printf_i+0xb8>
    dd1a:	2978      	cmp	r1, #120	; 0x78
    dd1c:	d1d2      	bne.n	dcc4 <_printf_i+0x30>
    dd1e:	2278      	movs	r2, #120	; 0x78
    dd20:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
    dd24:	f8df c190 	ldr.w	ip, [pc, #400]	; deb8 <_printf_i+0x224>
    dd28:	e061      	b.n	ddee <_printf_i+0x15a>
    dd2a:	681a      	ldr	r2, [r3, #0]
    dd2c:	1d11      	adds	r1, r2, #4
    dd2e:	6019      	str	r1, [r3, #0]
    dd30:	6813      	ldr	r3, [r2, #0]
    dd32:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    dd36:	f104 0542 	add.w	r5, r4, #66	; 0x42
    dd3a:	2301      	movs	r3, #1
    dd3c:	e093      	b.n	de66 <_printf_i+0x1d2>
    dd3e:	6812      	ldr	r2, [r2, #0]
    dd40:	6019      	str	r1, [r3, #0]
    dd42:	f015 0f40 	tst.w	r5, #64	; 0x40
    dd46:	bf18      	it	ne
    dd48:	b212      	sxthne	r2, r2
    dd4a:	e7cd      	b.n	dce8 <_printf_i+0x54>
    dd4c:	f8d4 c000 	ldr.w	ip, [r4]
    dd50:	681a      	ldr	r2, [r3, #0]
    dd52:	f01c 0f80 	tst.w	ip, #128	; 0x80
    dd56:	f102 0504 	add.w	r5, r2, #4
    dd5a:	601d      	str	r5, [r3, #0]
    dd5c:	d001      	beq.n	dd62 <_printf_i+0xce>
    dd5e:	6812      	ldr	r2, [r2, #0]
    dd60:	e003      	b.n	dd6a <_printf_i+0xd6>
    dd62:	f01c 0f40 	tst.w	ip, #64	; 0x40
    dd66:	d0fa      	beq.n	dd5e <_printf_i+0xca>
    dd68:	8812      	ldrh	r2, [r2, #0]
    dd6a:	f8df c148 	ldr.w	ip, [pc, #328]	; deb4 <_printf_i+0x220>
    dd6e:	296f      	cmp	r1, #111	; 0x6f
    dd70:	bf0c      	ite	eq
    dd72:	2308      	moveq	r3, #8
    dd74:	230a      	movne	r3, #10
    dd76:	2100      	movs	r1, #0
    dd78:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
    dd7c:	6865      	ldr	r5, [r4, #4]
    dd7e:	60a5      	str	r5, [r4, #8]
    dd80:	2d00      	cmp	r5, #0
    dd82:	bfa2      	ittt	ge
    dd84:	6821      	ldrge	r1, [r4, #0]
    dd86:	f021 0104 	bicge.w	r1, r1, #4
    dd8a:	6021      	strge	r1, [r4, #0]
    dd8c:	b90a      	cbnz	r2, dd92 <_printf_i+0xfe>
    dd8e:	2d00      	cmp	r5, #0
    dd90:	d046      	beq.n	de20 <_printf_i+0x18c>
    dd92:	4605      	mov	r5, r0
    dd94:	fbb2 f1f3 	udiv	r1, r2, r3
    dd98:	fb03 2e11 	mls	lr, r3, r1, r2
    dd9c:	4293      	cmp	r3, r2
    dd9e:	f81c e00e 	ldrb.w	lr, [ip, lr]
    dda2:	f805 ed01 	strb.w	lr, [r5, #-1]!
    dda6:	d939      	bls.n	de1c <_printf_i+0x188>
    dda8:	2b08      	cmp	r3, #8
    ddaa:	d10b      	bne.n	ddc4 <_printf_i+0x130>
    ddac:	6823      	ldr	r3, [r4, #0]
    ddae:	07da      	lsls	r2, r3, #31
    ddb0:	d508      	bpl.n	ddc4 <_printf_i+0x130>
    ddb2:	6923      	ldr	r3, [r4, #16]
    ddb4:	6862      	ldr	r2, [r4, #4]
    ddb6:	429a      	cmp	r2, r3
    ddb8:	bfde      	ittt	le
    ddba:	2330      	movle	r3, #48	; 0x30
    ddbc:	f805 3c01 	strble.w	r3, [r5, #-1]
    ddc0:	f105 35ff 	addle.w	r5, r5, #4294967295
    ddc4:	1b40      	subs	r0, r0, r5
    ddc6:	6120      	str	r0, [r4, #16]
    ddc8:	f8cd 8000 	str.w	r8, [sp]
    ddcc:	463b      	mov	r3, r7
    ddce:	aa03      	add	r2, sp, #12
    ddd0:	4621      	mov	r1, r4
    ddd2:	4630      	mov	r0, r6
    ddd4:	f006 fe76 	bl	14ac4 <_printf_common>
    ddd8:	3001      	adds	r0, #1
    ddda:	d149      	bne.n	de70 <_printf_i+0x1dc>
    dddc:	f04f 30ff 	mov.w	r0, #4294967295
    dde0:	b005      	add	sp, #20
    dde2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    dde6:	f8df c0cc 	ldr.w	ip, [pc, #204]	; deb4 <_printf_i+0x220>
    ddea:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
    ddee:	681d      	ldr	r5, [r3, #0]
    ddf0:	6821      	ldr	r1, [r4, #0]
    ddf2:	f855 2b04 	ldr.w	r2, [r5], #4
    ddf6:	601d      	str	r5, [r3, #0]
    ddf8:	060d      	lsls	r5, r1, #24
    ddfa:	d50b      	bpl.n	de14 <_printf_i+0x180>
    ddfc:	07cd      	lsls	r5, r1, #31
    ddfe:	bf44      	itt	mi
    de00:	f041 0120 	orrmi.w	r1, r1, #32
    de04:	6021      	strmi	r1, [r4, #0]
    de06:	b91a      	cbnz	r2, de10 <_printf_i+0x17c>
    de08:	6823      	ldr	r3, [r4, #0]
    de0a:	f023 0320 	bic.w	r3, r3, #32
    de0e:	6023      	str	r3, [r4, #0]
    de10:	2310      	movs	r3, #16
    de12:	e7b0      	b.n	dd76 <_printf_i+0xe2>
    de14:	064b      	lsls	r3, r1, #25
    de16:	bf48      	it	mi
    de18:	b292      	uxthmi	r2, r2
    de1a:	e7ef      	b.n	ddfc <_printf_i+0x168>
    de1c:	460a      	mov	r2, r1
    de1e:	e7b9      	b.n	dd94 <_printf_i+0x100>
    de20:	4605      	mov	r5, r0
    de22:	e7c1      	b.n	dda8 <_printf_i+0x114>
    de24:	681a      	ldr	r2, [r3, #0]
    de26:	f8d4 c000 	ldr.w	ip, [r4]
    de2a:	6961      	ldr	r1, [r4, #20]
    de2c:	1d15      	adds	r5, r2, #4
    de2e:	601d      	str	r5, [r3, #0]
    de30:	f01c 0f80 	tst.w	ip, #128	; 0x80
    de34:	6813      	ldr	r3, [r2, #0]
    de36:	d001      	beq.n	de3c <_printf_i+0x1a8>
    de38:	6019      	str	r1, [r3, #0]
    de3a:	e003      	b.n	de44 <_printf_i+0x1b0>
    de3c:	f01c 0f40 	tst.w	ip, #64	; 0x40
    de40:	d0fa      	beq.n	de38 <_printf_i+0x1a4>
    de42:	8019      	strh	r1, [r3, #0]
    de44:	2300      	movs	r3, #0
    de46:	6123      	str	r3, [r4, #16]
    de48:	4605      	mov	r5, r0
    de4a:	e7bd      	b.n	ddc8 <_printf_i+0x134>
    de4c:	681a      	ldr	r2, [r3, #0]
    de4e:	1d11      	adds	r1, r2, #4
    de50:	6019      	str	r1, [r3, #0]
    de52:	6815      	ldr	r5, [r2, #0]
    de54:	6862      	ldr	r2, [r4, #4]
    de56:	2100      	movs	r1, #0
    de58:	4628      	mov	r0, r5
    de5a:	f009 fcb1 	bl	177c0 <memchr>
    de5e:	b108      	cbz	r0, de64 <_printf_i+0x1d0>
    de60:	1b40      	subs	r0, r0, r5
    de62:	6060      	str	r0, [r4, #4]
    de64:	6863      	ldr	r3, [r4, #4]
    de66:	6123      	str	r3, [r4, #16]
    de68:	2300      	movs	r3, #0
    de6a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    de6e:	e7ab      	b.n	ddc8 <_printf_i+0x134>
    de70:	6923      	ldr	r3, [r4, #16]
    de72:	462a      	mov	r2, r5
    de74:	4639      	mov	r1, r7
    de76:	4630      	mov	r0, r6
    de78:	47c0      	blx	r8
    de7a:	3001      	adds	r0, #1
    de7c:	d0ae      	beq.n	dddc <_printf_i+0x148>
    de7e:	6823      	ldr	r3, [r4, #0]
    de80:	079b      	lsls	r3, r3, #30
    de82:	d413      	bmi.n	deac <_printf_i+0x218>
    de84:	68e0      	ldr	r0, [r4, #12]
    de86:	9b03      	ldr	r3, [sp, #12]
    de88:	4298      	cmp	r0, r3
    de8a:	bfb8      	it	lt
    de8c:	4618      	movlt	r0, r3
    de8e:	e7a7      	b.n	dde0 <_printf_i+0x14c>
    de90:	2301      	movs	r3, #1
    de92:	464a      	mov	r2, r9
    de94:	4639      	mov	r1, r7
    de96:	4630      	mov	r0, r6
    de98:	47c0      	blx	r8
    de9a:	3001      	adds	r0, #1
    de9c:	d09e      	beq.n	dddc <_printf_i+0x148>
    de9e:	3501      	adds	r5, #1
    dea0:	68e3      	ldr	r3, [r4, #12]
    dea2:	9a03      	ldr	r2, [sp, #12]
    dea4:	1a9b      	subs	r3, r3, r2
    dea6:	42ab      	cmp	r3, r5
    dea8:	dcf2      	bgt.n	de90 <_printf_i+0x1fc>
    deaa:	e7eb      	b.n	de84 <_printf_i+0x1f0>
    deac:	2500      	movs	r5, #0
    deae:	f104 0919 	add.w	r9, r4, #25
    deb2:	e7f5      	b.n	dea0 <_printf_i+0x20c>
    deb4:	000206ec 	.word	0x000206ec
    deb8:	000206fd 	.word	0x000206fd

Disassembly of section .text.TCPIP_UDP_Flush%230:

0000debc <TCPIP_UDP_Flush>:
{
    debc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    dec0:	b085      	sub	sp, #20
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
    dec2:	f012 f80f 	bl	1fee4 <_UDPSocketDcpt>
    if(pSkt && _UDPTxPktValid(pSkt))
    dec6:	2800      	cmp	r0, #0
    dec8:	f000 8101 	beq.w	e0ce <TCPIP_UDP_Flush+0x212>
    decc:	4605      	mov	r5, r0
    dece:	f013 f99b 	bl	21208 <_UDPTxPktValid>
    ded2:	2800      	cmp	r0, #0
    ded4:	f000 8100 	beq.w	e0d8 <TCPIP_UDP_Flush+0x21c>
        if(pSkt->flags.txSplitAlloc == 0)
    ded8:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    dedc:	f013 0f02 	tst.w	r3, #2
    dee0:	f040 80b9 	bne.w	e056 <TCPIP_UDP_Flush+0x19a>
            payload = pSkt->txWrite - pSkt->txStart;
    dee4:	68ac      	ldr	r4, [r5, #8]
    dee6:	682b      	ldr	r3, [r5, #0]
    dee8:	1ae4      	subs	r4, r4, r3
    deea:	b2a4      	uxth	r4, r4
        if(payload)
    deec:	2c00      	cmp	r4, #0
    deee:	f000 80ef 	beq.w	e0d0 <TCPIP_UDP_Flush+0x214>
            switch(pSkt->addType)
    def2:	8fab      	ldrh	r3, [r5, #60]	; 0x3c
    def4:	2b01      	cmp	r3, #1
    return 0;
    def6:	bf18      	it	ne
    def8:	2400      	movne	r4, #0
            switch(pSkt->addType)
    defa:	f040 80e9 	bne.w	e0d0 <TCPIP_UDP_Flush+0x214>
    if(pSkt->destAddress.Val == 0)
    defe:	696b      	ldr	r3, [r5, #20]
    df00:	2b00      	cmp	r3, #0
    df02:	f000 80e0 	beq.w	e0c6 <TCPIP_UDP_Flush+0x20a>
    if(pSkt->flags.srcSolved == 0 || pSkt->pSktNet == 0)
    df06:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
    df0a:	f013 0f80 	tst.w	r3, #128	; 0x80
    df0e:	d001      	beq.n	df14 <TCPIP_UDP_Flush+0x58>
    df10:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    df12:	b992      	cbnz	r2, df3a <TCPIP_UDP_Flush+0x7e>
        pSkt->pSktNet = (TCPIP_NET_IF*)TCPIP_IPV4_SelectSourceInterface(pSkt->pSktNet, &pSkt->destAddress, &pSkt->srcAddress, pSkt->flags.srcValid != 0);
    df14:	f3c3 1380 	ubfx	r3, r3, #6, #1
    df18:	f105 0218 	add.w	r2, r5, #24
    df1c:	f105 0114 	add.w	r1, r5, #20
    df20:	6a68      	ldr	r0, [r5, #36]	; 0x24
    df22:	f00e fcdd 	bl	1c8e0 <TCPIP_IPV4_SelectSourceInterface>
    df26:	6268      	str	r0, [r5, #36]	; 0x24
        if(pSkt->pSktNet == 0)
    df28:	2800      	cmp	r0, #0
    df2a:	f000 80ce 	beq.w	e0ca <TCPIP_UDP_Flush+0x20e>
        pSkt->flags.srcSolved = 1;
    df2e:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
        pSkt->flags.srcValid = 1;
    df32:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
    df36:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
    if(pSkt->flags.bcastForceType == UDP_BCAST_NETWORK_DIRECTED)
    df3a:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
    df3e:	f003 0303 	and.w	r3, r3, #3
    df42:	2b02      	cmp	r3, #2
    df44:	f000 808b 	beq.w	e05e <TCPIP_UDP_Flush+0x1a2>
    pv4Pkt = pSkt->pV4Pkt;
    df48:	68ee      	ldr	r6, [r5, #12]
    pv4Pkt->srcAddress.Val = pSkt->srcAddress.Val;
    df4a:	69ab      	ldr	r3, [r5, #24]
    df4c:	6373      	str	r3, [r6, #52]	; 0x34
    pv4Pkt->destAddress.Val = pSkt->destAddress.Val;
    df4e:	696b      	ldr	r3, [r5, #20]
    df50:	63b3      	str	r3, [r6, #56]	; 0x38
    pv4Pkt->netIfH = pSkt->pSktNet;
    df52:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    df54:	63f3      	str	r3, [r6, #60]	; 0x3c
    pUDPHdr = (UDP_HEADER*)pv4Pkt->macPkt.pTransportLayer;
    df56:	69f7      	ldr	r7, [r6, #28]
    if(pSkt->flags.txSplitAlloc != 0)
    df58:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    df5c:	f013 0f02 	tst.w	r3, #2
    df60:	f000 8082 	beq.w	e068 <TCPIP_UDP_Flush+0x1ac>
        pZSeg = ((UDP_V4_PACKET*)pv4Pkt)->zcSeg;
    df64:	f106 0944 	add.w	r9, r6, #68	; 0x44
        udpLoadLen = pZSeg->segLen;
    df68:	f8b6 4050 	ldrh.w	r4, [r6, #80]	; 0x50
        rootLen = sizeof(UDP_HEADER);
    df6c:	2308      	movs	r3, #8
    pv4Pkt->macPkt.pDSeg->segLen += rootLen;
    df6e:	6932      	ldr	r2, [r6, #16]
    df70:	8991      	ldrh	r1, [r2, #12]
    df72:	440b      	add	r3, r1
    df74:	8193      	strh	r3, [r2, #12]
    udpTotLen = udpLoadLen + sizeof(UDP_HEADER);
    df76:	f104 0808 	add.w	r8, r4, #8
    df7a:	fa1f f888 	uxth.w	r8, r8
    pUDPHdr->SourcePort = TCPIP_Helper_htons(pSkt->localPort);
    df7e:	8d6a      	ldrh	r2, [r5, #42]	; 0x2a
    df80:	0a13      	lsrs	r3, r2, #8
    df82:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    df86:	803b      	strh	r3, [r7, #0]
    pUDPHdr->DestinationPort = TCPIP_Helper_htons(pSkt->remotePort);
    df88:	8d2a      	ldrh	r2, [r5, #40]	; 0x28
    df8a:	0a13      	lsrs	r3, r2, #8
    df8c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    df90:	807b      	strh	r3, [r7, #2]
    df92:	ea4f 2318 	mov.w	r3, r8, lsr #8
    df96:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
    pUDPHdr->Length = TCPIP_Helper_htons(udpTotLen);
    df9a:	80bb      	strh	r3, [r7, #4]
    pUDPHdr->Checksum = 0;
    df9c:	2200      	movs	r2, #0
    df9e:	80fa      	strh	r2, [r7, #6]
    pseudoHdr.SourceAddress.Val = pv4Pkt->srcAddress.Val;
    dfa0:	6b73      	ldr	r3, [r6, #52]	; 0x34
    dfa2:	9301      	str	r3, [sp, #4]
    pseudoHdr.DestAddress.Val = pv4Pkt->destAddress.Val;
    dfa4:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    dfa6:	9302      	str	r3, [sp, #8]
    pseudoHdr.Zero = 0;
    dfa8:	f88d 200c 	strb.w	r2, [sp, #12]
    pseudoHdr.Protocol = IP_PROT_UDP;
    dfac:	2311      	movs	r3, #17
    dfae:	f88d 300d 	strb.w	r3, [sp, #13]
    pseudoHdr.Length = pUDPHdr->Length;
    dfb2:	88bb      	ldrh	r3, [r7, #4]
    dfb4:	f8ad 300e 	strh.w	r3, [sp, #14]
    checksum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)&pseudoHdr, sizeof(pseudoHdr), 0);
    dfb8:	210c      	movs	r1, #12
    dfba:	a801      	add	r0, sp, #4
    dfbc:	f00c f97e 	bl	1a2bc <TCPIP_Helper_CalcIPChecksum>
    dfc0:	43c0      	mvns	r0, r0
    dfc2:	b282      	uxth	r2, r0
    if(pSkt->flags.txSplitAlloc != 0)
    dfc4:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    dfc8:	f013 0f02 	tst.w	r3, #2
    dfcc:	d056      	beq.n	e07c <TCPIP_UDP_Flush+0x1c0>
        checksum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)pUDPHdr, sizeof(UDP_HEADER), checksum);
    dfce:	2108      	movs	r1, #8
    dfd0:	4638      	mov	r0, r7
    dfd2:	f00c f973 	bl	1a2bc <TCPIP_Helper_CalcIPChecksum>
    dfd6:	43c2      	mvns	r2, r0
        checksum = ~TCPIP_Helper_CalcIPChecksum(pZSeg->segLoad, udpLoadLen, checksum);
    dfd8:	b292      	uxth	r2, r2
    dfda:	4621      	mov	r1, r4
    dfdc:	f8d9 0008 	ldr.w	r0, [r9, #8]
    dfe0:	f00c f96c 	bl	1a2bc <TCPIP_Helper_CalcIPChecksum>
    dfe4:	43c3      	mvns	r3, r0
    dfe6:	b29b      	uxth	r3, r3
    pUDPHdr->Checksum = ~checksum;
    dfe8:	43db      	mvns	r3, r3
    dfea:	80fb      	strh	r3, [r7, #6]
    if(isMcastDest)
    dfec:	f896 3038 	ldrb.w	r3, [r6, #56]	; 0x38
    dff0:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    dff4:	2be0      	cmp	r3, #224	; 0xe0
    dff6:	d048      	beq.n	e08a <TCPIP_UDP_Flush+0x1ce>
        pktParams.ttl = pSkt->ttl;
    dff8:	f895 305b 	ldrb.w	r3, [r5, #91]	; 0x5b
    dffc:	f88d 3001 	strb.w	r3, [sp, #1]
    pktParams.tosFlags = pSkt->extFlags.tos;
    e000:	f895 3043 	ldrb.w	r3, [r5, #67]	; 0x43
    e004:	f3c3 0205 	ubfx	r2, r3, #0, #6
    e008:	f88d 2000 	strb.w	r2, [sp]
    pktParams.df = pSkt->extFlags.df;
    e00c:	f3c3 1380 	ubfx	r3, r3, #6, #1
    e010:	f88d 3002 	strb.w	r3, [sp, #2]
    TCPIP_IPV4_PacketFormatTx(pv4Pkt, IP_PROT_UDP, udpTotLen, &pktParams);
    e014:	466b      	mov	r3, sp
    e016:	4642      	mov	r2, r8
    e018:	2111      	movs	r1, #17
    e01a:	4630      	mov	r0, r6
    e01c:	f004 ff26 	bl	12e6c <TCPIP_IPV4_PacketFormatTx>
    pv4Pkt->macPkt.next = 0;    // single packet
    e020:	2300      	movs	r3, #0
    e022:	6033      	str	r3, [r6, #0]
    if(isMcastDest && pSkt->extFlags.mcastLoop)
    e024:	8673      	strh	r3, [r6, #50]	; 0x32
    if(TCPIP_IPV4_PacketTransmit(pv4Pkt))
    e026:	4630      	mov	r0, r6
    e028:	f013 ff48 	bl	21ebc <TCPIP_IPV4_PacketTransmit>
    e02c:	2800      	cmp	r0, #0
    e02e:	d14f      	bne.n	e0d0 <TCPIP_UDP_Flush+0x214>
    pPkt->macPkt.pDSeg->segLen = 0;
    e030:	6933      	ldr	r3, [r6, #16]
    e032:	2200      	movs	r2, #0
    e034:	819a      	strh	r2, [r3, #12]
    if(pSkt->flags.txSplitAlloc)
    e036:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    e03a:	f013 0f02 	tst.w	r3, #2
        ((UDP_V4_PACKET*)pPkt)->zcSeg->segLen = 0;
    e03e:	bf19      	ittee	ne
    e040:	4613      	movne	r3, r2
    e042:	f8a6 2050 	strhne.w	r2, [r6, #80]	; 0x50
        pSkt->txWrite = pSkt->txStart;
    e046:	682b      	ldreq	r3, [r5, #0]
    e048:	60ab      	streq	r3, [r5, #8]
    pPkt->macPkt.pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED;
    e04a:	8c73      	ldrh	r3, [r6, #34]	; 0x22
    e04c:	f023 0308 	bic.w	r3, r3, #8
    e050:	8473      	strh	r3, [r6, #34]	; 0x22
    return 0;
    e052:	2400      	movs	r4, #0
    e054:	e03c      	b.n	e0d0 <TCPIP_UDP_Flush+0x214>
            payload = ((UDP_V4_PACKET*)pSkt->pPkt)->zcSeg->segLen;
    e056:	68eb      	ldr	r3, [r5, #12]
    e058:	f8b3 4050 	ldrh.w	r4, [r3, #80]	; 0x50
    e05c:	e746      	b.n	deec <TCPIP_UDP_Flush+0x30>
        pSkt->destAddress.Val = TCPIP_STACK_NetAddressBcast(pSkt->pSktNet);
    e05e:	6a68      	ldr	r0, [r5, #36]	; 0x24
    e060:	f012 fdd4 	bl	20c0c <TCPIP_STACK_NetAddressBcast>
    e064:	6168      	str	r0, [r5, #20]
    e066:	e76f      	b.n	df48 <TCPIP_UDP_Flush+0x8c>
        udpLoadLen = pSkt->txWrite - pSkt->txStart;
    e068:	68ab      	ldr	r3, [r5, #8]
    e06a:	682c      	ldr	r4, [r5, #0]
    e06c:	1b1b      	subs	r3, r3, r4
    e06e:	b29c      	uxth	r4, r3
        rootLen = udpLoadLen + sizeof(UDP_HEADER); 
    e070:	f104 0308 	add.w	r3, r4, #8
    e074:	b29b      	uxth	r3, r3
        pZSeg = 0;
    e076:	f04f 0900 	mov.w	r9, #0
    e07a:	e778      	b.n	df6e <TCPIP_UDP_Flush+0xb2>
        checksum = ~TCPIP_Helper_CalcIPChecksum((uint8_t*)pUDPHdr, udpTotLen, checksum);
    e07c:	4641      	mov	r1, r8
    e07e:	4638      	mov	r0, r7
    e080:	f00c f91c 	bl	1a2bc <TCPIP_Helper_CalcIPChecksum>
    e084:	43c3      	mvns	r3, r0
    e086:	b29b      	uxth	r3, r3
    e088:	e7ae      	b.n	dfe8 <TCPIP_UDP_Flush+0x12c>
        pktParams.ttl = pSkt->ttl == 0 ? UDP_MULTICAST_DEFAULT_TTL : pSkt->ttl;
    e08a:	f895 305b 	ldrb.w	r3, [r5, #91]	; 0x5b
    e08e:	2b00      	cmp	r3, #0
    e090:	bf08      	it	eq
    e092:	2301      	moveq	r3, #1
    e094:	f88d 3001 	strb.w	r3, [sp, #1]
    pktParams.tosFlags = pSkt->extFlags.tos;
    e098:	f895 3043 	ldrb.w	r3, [r5, #67]	; 0x43
    e09c:	f3c3 0205 	ubfx	r2, r3, #0, #6
    e0a0:	f88d 2000 	strb.w	r2, [sp]
    pktParams.df = pSkt->extFlags.df;
    e0a4:	f3c3 1380 	ubfx	r3, r3, #6, #1
    e0a8:	f88d 3002 	strb.w	r3, [sp, #2]
    TCPIP_IPV4_PacketFormatTx(pv4Pkt, IP_PROT_UDP, udpTotLen, &pktParams);
    e0ac:	466b      	mov	r3, sp
    e0ae:	4642      	mov	r2, r8
    e0b0:	2111      	movs	r1, #17
    e0b2:	4630      	mov	r0, r6
    e0b4:	f004 feda 	bl	12e6c <TCPIP_IPV4_PacketFormatTx>
    pv4Pkt->macPkt.next = 0;    // single packet
    e0b8:	2300      	movs	r3, #0
    e0ba:	6033      	str	r3, [r6, #0]
    if(isMcastDest && pSkt->extFlags.mcastLoop)
    e0bc:	f895 3042 	ldrb.w	r3, [r5, #66]	; 0x42
        pv4Pkt->macPkt.modPktData = 1;
    e0c0:	f3c3 0380 	ubfx	r3, r3, #2, #1
    e0c4:	e7ae      	b.n	e024 <TCPIP_UDP_Flush+0x168>
        return 0;
    e0c6:	2400      	movs	r4, #0
    e0c8:	e002      	b.n	e0d0 <TCPIP_UDP_Flush+0x214>
            return 0;
    e0ca:	2400      	movs	r4, #0
                    return _UDPv4Flush(pSkt);
    e0cc:	e000      	b.n	e0d0 <TCPIP_UDP_Flush+0x214>
    return 0;
    e0ce:	2400      	movs	r4, #0
}
    e0d0:	4620      	mov	r0, r4
    e0d2:	b005      	add	sp, #20
    e0d4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return 0;
    e0d8:	2400      	movs	r4, #0
    e0da:	e7f9      	b.n	e0d0 <TCPIP_UDP_Flush+0x214>

Disassembly of section .text.TCPIP_IPV4_PktTx%231:

0000e0dc <TCPIP_IPV4_PktTx>:
{
    e0dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    e0e0:	b084      	sub	sp, #16
    if(isPersistent)
    e0e2:	bb9a      	cbnz	r2, e14c <TCPIP_IPV4_PktTx+0x70>
        arpPkt = pMacPkt; 
    e0e4:	460f      	mov	r7, r1
        arpType = IPV4_ARP_PKT_TYPE_MAC;
    e0e6:	f04f 0802 	mov.w	r8, #2
    pNetIf = _TCPIPStackHandleToNet(pPkt->netIfH);
    e0ea:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
    if(pNetIf == 0)
    e0ec:	2b00      	cmp	r3, #0
    e0ee:	f000 80e5 	beq.w	e2bc <TCPIP_IPV4_PktTx+0x1e0>
    e0f2:	460d      	mov	r5, r1
    e0f4:	4604      	mov	r4, r0
    if((pHostIf = TCPIP_STACK_MatchNetAddress(pNetIf, &pPkt->destAddress)))
    e0f6:	f100 0138 	add.w	r1, r0, #56	; 0x38
    e0fa:	4618      	mov	r0, r3
    e0fc:	f00e fda4 	bl	1cc48 <TCPIP_STACK_MatchNetAddress>
    e100:	4606      	mov	r6, r0
    e102:	b338      	cbz	r0, e154 <TCPIP_IPV4_PktTx+0x78>
        memcpy(pMacDst, _TCPIPStack_NetMACAddressGet(pHostIf), sizeof(*pMacDst));
    e104:	4603      	mov	r3, r0
    e106:	f853 0f3c 	ldr.w	r0, [r3, #60]!
    e10a:	9002      	str	r0, [sp, #8]
    e10c:	889b      	ldrh	r3, [r3, #4]
    e10e:	f8ad 300c 	strh.w	r3, [sp, #12]
        pPkt->netIfH = pHostIf;
    e112:	63e6      	str	r6, [r4, #60]	; 0x3c
    pNetIf = TCPIP_IPV4_CheckPktTx(pPkt->netIfH, pMacPkt);
    e114:	4629      	mov	r1, r5
    e116:	4630      	mov	r0, r6
    e118:	f010 ff64 	bl	1efe4 <TCPIP_IPV4_CheckPktTx>
    if(pNetIf == 0)
    e11c:	4604      	mov	r4, r0
    e11e:	2800      	cmp	r0, #0
    e120:	f000 80d0 	beq.w	e2c4 <TCPIP_IPV4_PktTx+0x1e8>
    pMacPkt->pktIf = pNetIf;
    e124:	62a8      	str	r0, [r5, #40]	; 0x28
    TCPIP_PKT_PacketMACFormat(pMacPkt, pMacDst, (const TCPIP_MAC_ADDR*)_TCPIPStack_NetMACAddressGet(pNetIf), TCPIP_ETHER_TYPE_IPV4);
    e126:	f44f 6300 	mov.w	r3, #2048	; 0x800
    e12a:	f100 023c 	add.w	r2, r0, #60	; 0x3c
    e12e:	a902      	add	r1, sp, #8
    e130:	4628      	mov	r0, r5
    e132:	f010 fa13 	bl	1e55c <TCPIP_PKT_PacketMACFormat>
    pTxPkt->pktFlags |= flags;
    e136:	8c6b      	ldrh	r3, [r5, #34]	; 0x22
    e138:	f043 0310 	orr.w	r3, r3, #16
    e13c:	846b      	strh	r3, [r5, #34]	; 0x22
    _TCPIPStackInsertRxPacket(pNetIf, pTxPkt, signal);
    e13e:	2201      	movs	r2, #1
    e140:	4629      	mov	r1, r5
    e142:	4620      	mov	r0, r4
    e144:	f00c fcba 	bl	1aabc <_TCPIPStackInsertRxPacket>
        return true;
    e148:	2001      	movs	r0, #1
    e14a:	e0b8      	b.n	e2be <TCPIP_IPV4_PktTx+0x1e2>
        arpPkt = pPkt;
    e14c:	4607      	mov	r7, r0
        arpType = IPV4_ARP_PKT_TYPE_TX;
    e14e:	f04f 0801 	mov.w	r8, #1
    e152:	e7ca      	b.n	e0ea <TCPIP_IPV4_PktTx+0xe>
{
    TCPIP_ARP_RESULT  arpRes;
    TCPIP_MAC_ADDR*   pMacDst = *ppMacAdd;
    TCPIP_NET_IF* pNetIf = (TCPIP_NET_IF*)pPkt->netIfH;

    if(pIpAdd->Val == 0xffffffff || pIpAdd->Val == TCPIP_STACK_NetAddressBcast(pNetIf))
    e154:	f8d4 a038 	ldr.w	sl, [r4, #56]	; 0x38
    e158:	f1ba 3fff 	cmp.w	sl, #4294967295
    e15c:	d028      	beq.n	e1b0 <TCPIP_IPV4_PktTx+0xd4>
    TCPIP_NET_IF* pNetIf = (TCPIP_NET_IF*)pPkt->netIfH;
    e15e:	f8d4 903c 	ldr.w	r9, [r4, #60]	; 0x3c
    if(pIpAdd->Val == 0xffffffff || pIpAdd->Val == TCPIP_STACK_NetAddressBcast(pNetIf))
    e162:	4648      	mov	r0, r9
    e164:	f012 fd52 	bl	20c0c <TCPIP_STACK_NetAddressBcast>
    e168:	4582      	cmp	sl, r0
    e16a:	d021      	beq.n	e1b0 <TCPIP_IPV4_PktTx+0xd4>
        return TCPIP_IPV4_DEST_NETWORK;
    }

    // check IP multicast address range from 224.0.0.0 to 239.255.255.255
    // can be done locally; No need for an ARP request.
    if ((pIpAdd->v[0] >= 224) && (pIpAdd->v[0] <= 239))
    e16c:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
    e170:	3320      	adds	r3, #32
    e172:	b2db      	uxtb	r3, r3
    e174:	2b0f      	cmp	r3, #15
    e176:	d943      	bls.n	e200 <TCPIP_IPV4_PktTx+0x124>
    return ((pIf->netIPAddr.Val ^ pIpAddress->Val) & pIf->netMask.Val) == 0;
    e178:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    e17a:	f8d9 3004 	ldr.w	r3, [r9, #4]
    e17e:	4053      	eors	r3, r2
    e180:	f8d9 1008 	ldr.w	r1, [r9, #8]
        return TCPIP_IPV4_DEST_NETWORK;
    }

    TCPIP_IPV4_DEST_TYPE destType;

    if(_TCPIPStackIpAddFromLAN(pNetIf, pIpAdd))
    e184:	420b      	tst	r3, r1
        arpTarget->Val  = pIpAdd->Val;
        destType = TCPIP_IPV4_DEST_NETWORK;
    }
    else
    {   // not this LAN
        arpTarget->Val  = pNetIf->netGateway.Val;
    e186:	bf18      	it	ne
    e188:	f8d9 200c 	ldrne.w	r2, [r9, #12]
        destType = TCPIP_IPV4_DEST_GW;
    e18c:	9201      	str	r2, [sp, #4]
    }

    arpRes = TCPIP_ARP_EntryGet(pNetIf, arpTarget, pMacDst, true);
    e18e:	2301      	movs	r3, #1
    e190:	aa02      	add	r2, sp, #8
    e192:	a901      	add	r1, sp, #4
    e194:	4648      	mov	r0, r9
    e196:	f00c ffc1 	bl	1b11c <TCPIP_ARP_EntryGet>
    if(arpRes == ARP_RES_ENTRY_SOLVED)
    e19a:	2802      	cmp	r0, #2
    e19c:	f000 8098 	beq.w	e2d0 <TCPIP_IPV4_PktTx+0x1f4>
    {   // good to transmit
    }
    else if(arpRes == ARP_RES_ENTRY_QUEUED || arpRes == ARP_RES_ENTRY_NEW)
    e1a0:	f020 0002 	bic.w	r0, r0, #2
    e1a4:	b240      	sxtb	r0, r0
    e1a6:	2801      	cmp	r0, #1
            return false;
    e1a8:	bf18      	it	ne
    e1aa:	2000      	movne	r0, #0
    else if(arpRes == ARP_RES_ENTRY_QUEUED || arpRes == ARP_RES_ENTRY_NEW)
    e1ac:	d006      	beq.n	e1bc <TCPIP_IPV4_PktTx+0xe0>
    e1ae:	e086      	b.n	e2be <TCPIP_IPV4_PktTx+0x1e2>
        memset(pMacDst, 0xff, sizeof(*pMacDst));
    e1b0:	f04f 33ff 	mov.w	r3, #4294967295
    e1b4:	9302      	str	r3, [sp, #8]
    e1b6:	f8ad 300c 	strh.w	r3, [sp, #12]
    pMacDst = &destMacAdd;
    e1ba:	ae02      	add	r6, sp, #8
    pNetIf = TCPIP_IPV4_CheckPktTx(pPkt->netIfH, pMacPkt);
    e1bc:	4629      	mov	r1, r5
    e1be:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    e1c0:	f010 ff10 	bl	1efe4 <TCPIP_IPV4_CheckPktTx>
    if(pNetIf == 0)
    e1c4:	4604      	mov	r4, r0
    e1c6:	2800      	cmp	r0, #0
    e1c8:	d07e      	beq.n	e2c8 <TCPIP_IPV4_PktTx+0x1ec>
    pMacPkt->pktIf = pNetIf;
    e1ca:	62a8      	str	r0, [r5, #40]	; 0x28
    TCPIP_PKT_PacketMACFormat(pMacPkt, pMacDst, (const TCPIP_MAC_ADDR*)_TCPIPStack_NetMACAddressGet(pNetIf), TCPIP_ETHER_TYPE_IPV4);
    e1cc:	f44f 6300 	mov.w	r3, #2048	; 0x800
    e1d0:	f100 023c 	add.w	r2, r0, #60	; 0x3c
    e1d4:	4631      	mov	r1, r6
    e1d6:	4628      	mov	r0, r5
    e1d8:	f010 f9c0 	bl	1e55c <TCPIP_PKT_PacketMACFormat>
        pktPayload = TCPIP_PKT_PayloadLen(pMacPkt) - sizeof(TCPIP_MAC_ETHERNET_HEADER);
    e1dc:	4628      	mov	r0, r5
    e1de:	f012 fd42 	bl	20c66 <TCPIP_PKT_PayloadLen>
    e1e2:	380e      	subs	r0, #14
        if(pktPayload > linkMtu)
    e1e4:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
    e1e8:	b280      	uxth	r0, r0
    e1ea:	4283      	cmp	r3, r0
    e1ec:	d36e      	bcc.n	e2cc <TCPIP_IPV4_PktTx+0x1f0>
    if(pMacDst == 0)
    e1ee:	b306      	cbz	r6, e232 <TCPIP_IPV4_PktTx+0x156>
    return _TCPIPStackPacketTx(pNetIf, pPkt) == TCPIP_MAC_RES_OK;
    e1f0:	4629      	mov	r1, r5
    e1f2:	4620      	mov	r0, r4
    e1f4:	f013 fa76 	bl	216e4 <_TCPIPStackPacketTx>
    e1f8:	fab0 f080 	clz	r0, r0
    e1fc:	0940      	lsrs	r0, r0, #5
    return txRes;
    e1fe:	e05e      	b.n	e2be <TCPIP_IPV4_PktTx+0x1e2>
        pMacDst->v[0] = 0x01;
    e200:	2301      	movs	r3, #1
    e202:	f88d 3008 	strb.w	r3, [sp, #8]
        pMacDst->v[1] = 0x00;
    e206:	2300      	movs	r3, #0
    e208:	f88d 3009 	strb.w	r3, [sp, #9]
        pMacDst->v[2] = 0x5E;
    e20c:	235e      	movs	r3, #94	; 0x5e
    e20e:	f88d 300a 	strb.w	r3, [sp, #10]
        pMacDst->v[3] = 0x7f & pIpAdd->v[1];
    e212:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
    e216:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    e21a:	f88d 300b 	strb.w	r3, [sp, #11]
        pMacDst->v[4] = pIpAdd->v[2];
    e21e:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
    e222:	f88d 300c 	strb.w	r3, [sp, #12]
        pMacDst->v[5] = pIpAdd->v[3];
    e226:	f894 303b 	ldrb.w	r3, [r4, #59]	; 0x3b
    e22a:	f88d 300d 	strb.w	r3, [sp, #13]
    pMacDst = &destMacAdd;
    e22e:	ae02      	add	r6, sp, #8
    e230:	e7c4      	b.n	e1bc <TCPIP_IPV4_PktTx+0xe0>
        if(ipv4ArpHandle == 0)
    e232:	4b28      	ldr	r3, [pc, #160]	; (e2d4 <TCPIP_IPV4_PktTx+0x1f8>)
    e234:	681b      	ldr	r3, [r3, #0]
    e236:	b1e3      	cbz	r3, e272 <TCPIP_IPV4_PktTx+0x196>
    return pIf->netIfIx;
    e238:	f8b4 4058 	ldrh.w	r4, [r4, #88]	; 0x58
    TCPIP_Helper_ProtectedSingleListLock(pList);
    e23c:	4826      	ldr	r0, [pc, #152]	; (e2d8 <TCPIP_IPV4_PktTx+0x1fc>)
    e23e:	f012 fb97 	bl	20970 <TCPIP_Helper_ProtectedSingleListLock>
    IPV4_ARP_ENTRY* pEntry = (IPV4_ARP_ENTRY*)TCPIP_Helper_SingleListHeadRemove(&ipv4ArpPool);
    e242:	4826      	ldr	r0, [pc, #152]	; (e2dc <TCPIP_IPV4_PktTx+0x200>)
    e244:	f012 fdd8 	bl	20df8 <TCPIP_Helper_SingleListHeadRemove>
    if(pEntry == 0)
    e248:	4601      	mov	r1, r0
    e24a:	b340      	cbz	r0, e29e <TCPIP_IPV4_PktTx+0x1c2>
    pEntry->type = (uint8_t)type;
    e24c:	f880 8004 	strb.w	r8, [r0, #4]
    pEntry->arpIfIx = (uint8_t)arpIfIx;
    e250:	7144      	strb	r4, [r0, #5]
    pEntry->pPkt = pPkt;     
    e252:	6087      	str	r7, [r0, #8]
    pEntry->arpTarget.Val = arpTarget->Val;
    e254:	9b01      	ldr	r3, [sp, #4]
    e256:	60c3      	str	r3, [r0, #12]
    TCPIP_Helper_SingleListTailAdd(&pList->list, (SGL_LIST_NODE*)pEntry);
    e258:	4c1f      	ldr	r4, [pc, #124]	; (e2d8 <TCPIP_IPV4_PktTx+0x1fc>)
    e25a:	4620      	mov	r0, r4
    e25c:	f012 ffa0 	bl	211a0 <TCPIP_Helper_SingleListTailAdd>
    TCPIP_Helper_ProtectedSingleListUnlock(pList);
    e260:	4620      	mov	r0, r4
    e262:	f012 fdd7 	bl	20e14 <TCPIP_Helper_ProtectedSingleListUnlock>
       pMacPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_QUEUED;
    e266:	8c6b      	ldrh	r3, [r5, #34]	; 0x22
    e268:	f043 0308 	orr.w	r3, r3, #8
    e26c:	846b      	strh	r3, [r5, #34]	; 0x22
        return true;
    e26e:	2001      	movs	r0, #1
    e270:	e025      	b.n	e2be <TCPIP_IPV4_PktTx+0x1e2>
            if((ipv4ArpHandle = TCPIP_ARP_HandlerRegister(0, TCPIP_IPV4_ArpHandler, 0)) == 0)
    e272:	2200      	movs	r2, #0
    e274:	491a      	ldr	r1, [pc, #104]	; (e2e0 <TCPIP_IPV4_PktTx+0x204>)
    e276:	4610      	mov	r0, r2
    e278:	f010 fb08 	bl	1e88c <TCPIP_ARP_HandlerRegister>
    e27c:	4b15      	ldr	r3, [pc, #84]	; (e2d4 <TCPIP_IPV4_PktTx+0x1f8>)
    e27e:	6018      	str	r0, [r3, #0]
    e280:	2800      	cmp	r0, #0
    e282:	d1d9      	bne.n	e238 <TCPIP_IPV4_PktTx+0x15c>
                SYS_ERROR(SYS_ERROR_WARNING, "IPv4: Failed to register ARP notification! \r\n");
    e284:	f013 fe62 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
    e288:	2801      	cmp	r0, #1
    e28a:	d801      	bhi.n	e290 <TCPIP_IPV4_PktTx+0x1b4>
                return false;
    e28c:	2000      	movs	r0, #0
    e28e:	e016      	b.n	e2be <TCPIP_IPV4_PktTx+0x1e2>
                SYS_ERROR(SYS_ERROR_WARNING, "IPv4: Failed to register ARP notification! \r\n");
    e290:	f013 fe56 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
    e294:	4913      	ldr	r1, [pc, #76]	; (e2e4 <TCPIP_IPV4_PktTx+0x208>)
    e296:	f00c fa69 	bl	1a76c <SYS_CONSOLE_Print>
                return false;
    e29a:	2000      	movs	r0, #0
    e29c:	e00f      	b.n	e2be <TCPIP_IPV4_PktTx+0x1e2>
        SYS_ERROR(SYS_ERROR_WARNING, "IPv4: ARP entries pool empty!\r\n");
    e29e:	f013 fe55 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
    e2a2:	2801      	cmp	r0, #1
    e2a4:	d804      	bhi.n	e2b0 <TCPIP_IPV4_PktTx+0x1d4>
        TCPIP_Helper_ProtectedSingleListUnlock(pList);
    e2a6:	480c      	ldr	r0, [pc, #48]	; (e2d8 <TCPIP_IPV4_PktTx+0x1fc>)
    e2a8:	f012 fdb4 	bl	20e14 <TCPIP_Helper_ProtectedSingleListUnlock>
            return false;
    e2ac:	2000      	movs	r0, #0
    e2ae:	e006      	b.n	e2be <TCPIP_IPV4_PktTx+0x1e2>
        SYS_ERROR(SYS_ERROR_WARNING, "IPv4: ARP entries pool empty!\r\n");
    e2b0:	f013 fe46 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
    e2b4:	490c      	ldr	r1, [pc, #48]	; (e2e8 <TCPIP_IPV4_PktTx+0x20c>)
    e2b6:	f00c fa59 	bl	1a76c <SYS_CONSOLE_Print>
    e2ba:	e7f4      	b.n	e2a6 <TCPIP_IPV4_PktTx+0x1ca>
        return false;
    e2bc:	2000      	movs	r0, #0
}
    e2be:	b004      	add	sp, #16
    e2c0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return false;
    e2c4:	2000      	movs	r0, #0
    e2c6:	e7fa      	b.n	e2be <TCPIP_IPV4_PktTx+0x1e2>
    e2c8:	2000      	movs	r0, #0
    e2ca:	e7f8      	b.n	e2be <TCPIP_IPV4_PktTx+0x1e2>
            return false;
    e2cc:	2000      	movs	r0, #0
    e2ce:	e7f6      	b.n	e2be <TCPIP_IPV4_PktTx+0x1e2>
    pMacDst = &destMacAdd;
    e2d0:	ae02      	add	r6, sp, #8
    e2d2:	e773      	b.n	e1bc <TCPIP_IPV4_PktTx+0xe0>
    e2d4:	2000e604 	.word	0x2000e604
    e2d8:	2000e428 	.word	0x2000e428
    e2dc:	2000e528 	.word	0x2000e528
    e2e0:	00016505 	.word	0x00016505
    e2e4:	000199d0 	.word	0x000199d0
    e2e8:	00019a00 	.word	0x00019a00

Disassembly of section .text._Command_NetInfo%232:

0000e2ec <_Command_NetInfo>:
{
    e2ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e2f0:	b089      	sub	sp, #36	; 0x24
    e2f2:	4606      	mov	r6, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
    e2f4:	6847      	ldr	r7, [r0, #4]
    if (argc > 2)
    e2f6:	2902      	cmp	r1, #2
    e2f8:	dc11      	bgt.n	e31e <_Command_NetInfo+0x32>
    for (i=0; i<initialNetIfs; i++)
    e2fa:	4b7c      	ldr	r3, [pc, #496]	; (e4ec <_Command_NetInfo+0x200>)
    e2fc:	681b      	ldr	r3, [r3, #0]
    e2fe:	2b00      	cmp	r3, #0
    return true;
    e300:	bfd8      	it	le
    e302:	2001      	movle	r0, #1
    for (i=0; i<initialNetIfs; i++)
    e304:	f340 80a5 	ble.w	e452 <_Command_NetInfo+0x166>
    e308:	f04f 0800 	mov.w	r8, #0
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "---------- Interface <%s/%s> ---------- \r\n", addrBuff, TCPIP_STACK_NetNameGet(netH));
    e30c:	4d78      	ldr	r5, [pc, #480]	; (e4f0 <_Command_NetInfo+0x204>)
    e30e:	f505 7a82 	add.w	sl, r5, #260	; 0x104
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "dhcp is %s\r\n", TCPIP_DHCP_IsEnabled(netH) ? "enabled" : "disabled");
    e312:	f8df b1e0 	ldr.w	fp, [pc, #480]	; e4f4 <_Command_NetInfo+0x208>
    e316:	f50b 73e4 	add.w	r3, fp, #456	; 0x1c8
    e31a:	9301      	str	r3, [sp, #4]
    e31c:	e0c6      	b.n	e4ac <_Command_NetInfo+0x1c0>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: netinfo\r\n");
    e31e:	4c74      	ldr	r4, [pc, #464]	; (e4f0 <_Command_NetInfo+0x204>)
    e320:	6803      	ldr	r3, [r0, #0]
    e322:	681b      	ldr	r3, [r3, #0]
    e324:	f104 01e0 	add.w	r1, r4, #224	; 0xe0
    e328:	4638      	mov	r0, r7
    e32a:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: netinfo\r\n");
    e32c:	6833      	ldr	r3, [r6, #0]
    e32e:	681b      	ldr	r3, [r3, #0]
    e330:	f104 01f4 	add.w	r1, r4, #244	; 0xf4
    e334:	4638      	mov	r0, r7
    e336:	4798      	blx	r3
        return false;
    e338:	2000      	movs	r0, #0
    e33a:	e08a      	b.n	e452 <_Command_NetInfo+0x166>
        hostName = TCPIP_STACK_NetBIOSName(netH); 
    e33c:	4620      	mov	r0, r4
    e33e:	f013 fee8 	bl	22112 <TCPIP_STACK_NetBIOSName>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Host Name: %s - NBNS disabled \r\n", hostName);
    e342:	6833      	ldr	r3, [r6, #0]
    e344:	685b      	ldr	r3, [r3, #4]
    e346:	4602      	mov	r2, r0
    e348:	f505 71a2 	add.w	r1, r5, #324	; 0x144
    e34c:	4638      	mov	r0, r7
    e34e:	4798      	blx	r3
        ipAddr.Val = TCPIP_STACK_NetAddress(netH);
    e350:	4620      	mov	r0, r4
    e352:	f012 fc6a 	bl	20c2a <TCPIP_STACK_NetAddress>
    e356:	9007      	str	r0, [sp, #28]
        TCPIP_Helper_IPAddressToString(&ipAddr, addrBuff, sizeof(addrBuff));
    e358:	2214      	movs	r2, #20
    e35a:	a902      	add	r1, sp, #8
    e35c:	a807      	add	r0, sp, #28
    e35e:	f00e fa01 	bl	1c764 <TCPIP_Helper_IPAddressToString>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "IPv4 Address: %s\r\n", addrBuff);
    e362:	6833      	ldr	r3, [r6, #0]
    e364:	685b      	ldr	r3, [r3, #4]
    e366:	aa02      	add	r2, sp, #8
    e368:	f505 71b4 	add.w	r1, r5, #360	; 0x168
    e36c:	4638      	mov	r0, r7
    e36e:	4798      	blx	r3
        ipAddr.Val = TCPIP_STACK_NetMask(netH);
    e370:	4620      	mov	r0, r4
    e372:	f012 fdb1 	bl	20ed8 <TCPIP_STACK_NetMask>
    e376:	9007      	str	r0, [sp, #28]
        TCPIP_Helper_IPAddressToString(&ipAddr, addrBuff, sizeof(addrBuff));
    e378:	2214      	movs	r2, #20
    e37a:	a902      	add	r1, sp, #8
    e37c:	a807      	add	r0, sp, #28
    e37e:	f00e f9f1 	bl	1c764 <TCPIP_Helper_IPAddressToString>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Mask: %s\r\n", addrBuff);
    e382:	6833      	ldr	r3, [r6, #0]
    e384:	685b      	ldr	r3, [r3, #4]
    e386:	aa02      	add	r2, sp, #8
    e388:	f505 71be 	add.w	r1, r5, #380	; 0x17c
    e38c:	4638      	mov	r0, r7
    e38e:	4798      	blx	r3
        ipAddr.Val = TCPIP_STACK_NetAddressGateway(netH);
    e390:	4620      	mov	r0, r4
    e392:	f013 f83b 	bl	2140c <TCPIP_STACK_NetAddressGateway>
    e396:	9007      	str	r0, [sp, #28]
        TCPIP_Helper_IPAddressToString(&ipAddr, addrBuff, sizeof(addrBuff));
    e398:	2214      	movs	r2, #20
    e39a:	a902      	add	r1, sp, #8
    e39c:	a807      	add	r0, sp, #28
    e39e:	f00e f9e1 	bl	1c764 <TCPIP_Helper_IPAddressToString>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Gateway: %s\r\n", addrBuff);
    e3a2:	6833      	ldr	r3, [r6, #0]
    e3a4:	685b      	ldr	r3, [r3, #4]
    e3a6:	aa02      	add	r2, sp, #8
    e3a8:	f505 71c4 	add.w	r1, r5, #392	; 0x188
    e3ac:	4638      	mov	r0, r7
    e3ae:	4798      	blx	r3
        ipAddr.Val = TCPIP_STACK_NetAddressDnsPrimary(netH);
    e3b0:	4620      	mov	r0, r4
    e3b2:	f013 f837 	bl	21424 <TCPIP_STACK_NetAddressDnsPrimary>
    e3b6:	9007      	str	r0, [sp, #28]
        TCPIP_Helper_IPAddressToString(&ipAddr, addrBuff, sizeof(addrBuff));
    e3b8:	2214      	movs	r2, #20
    e3ba:	a902      	add	r1, sp, #8
    e3bc:	a807      	add	r0, sp, #28
    e3be:	f00e f9d1 	bl	1c764 <TCPIP_Helper_IPAddressToString>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "DNS1: %s\r\n", addrBuff);
    e3c2:	6833      	ldr	r3, [r6, #0]
    e3c4:	685b      	ldr	r3, [r3, #4]
    e3c6:	aa02      	add	r2, sp, #8
    e3c8:	f505 71cc 	add.w	r1, r5, #408	; 0x198
    e3cc:	4638      	mov	r0, r7
    e3ce:	4798      	blx	r3
        ipAddr.Val = TCPIP_STACK_NetAddressDnsSecond(netH);
    e3d0:	4620      	mov	r0, r4
    e3d2:	f013 f833 	bl	2143c <TCPIP_STACK_NetAddressDnsSecond>
    e3d6:	9007      	str	r0, [sp, #28]
        TCPIP_Helper_IPAddressToString(&ipAddr, addrBuff, sizeof(addrBuff));
    e3d8:	2214      	movs	r2, #20
    e3da:	a902      	add	r1, sp, #8
    e3dc:	a807      	add	r0, sp, #28
    e3de:	f00e f9c1 	bl	1c764 <TCPIP_Helper_IPAddressToString>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "DNS2: %s\r\n", addrBuff);
    e3e2:	6833      	ldr	r3, [r6, #0]
    e3e4:	685b      	ldr	r3, [r3, #4]
    e3e6:	aa02      	add	r2, sp, #8
    e3e8:	f505 71d2 	add.w	r1, r5, #420	; 0x1a4
    e3ec:	4638      	mov	r0, r7
    e3ee:	4798      	blx	r3
        pMac = (const TCPIP_MAC_ADDR*)TCPIP_STACK_NetAddressMac(netH);
    e3f0:	4620      	mov	r0, r4
    e3f2:	f013 fe36 	bl	22062 <TCPIP_STACK_NetAddressMac>
        TCPIP_Helper_MACAddressToString(pMac, addrBuff, sizeof(addrBuff));
    e3f6:	2214      	movs	r2, #20
    e3f8:	a902      	add	r1, sp, #8
    e3fa:	f00e ff51 	bl	1d2a0 <TCPIP_Helper_MACAddressToString>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "MAC Address: %s\r\n", addrBuff);
    e3fe:	6833      	ldr	r3, [r6, #0]
    e400:	685b      	ldr	r3, [r3, #4]
    e402:	aa02      	add	r2, sp, #8
    e404:	f505 71d8 	add.w	r1, r5, #432	; 0x1b0
    e408:	4638      	mov	r0, r7
    e40a:	4798      	blx	r3
        if(TCPIP_DHCP_IsActive(netH))
    e40c:	4620      	mov	r0, r4
    e40e:	f011 fcc9 	bl	1fda4 <TCPIP_DHCP_IsActive>
    e412:	bb08      	cbnz	r0, e458 <_Command_NetInfo+0x16c>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "%s is ON\r\n", msgAdd);
    e414:	6833      	ldr	r3, [r6, #0]
    e416:	685b      	ldr	r3, [r3, #4]
    e418:	f505 72fa 	add.w	r2, r5, #500	; 0x1f4
    e41c:	f505 7102 	add.w	r1, r5, #520	; 0x208
    e420:	4638      	mov	r0, r7
    e422:	4798      	blx	r3
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "dhcp is %s\r\n", TCPIP_DHCP_IsEnabled(netH) ? "enabled" : "disabled");
    e424:	6833      	ldr	r3, [r6, #0]
    e426:	f8d3 9004 	ldr.w	r9, [r3, #4]
    e42a:	4620      	mov	r0, r4
    e42c:	f00f fd80 	bl	1df30 <TCPIP_DHCP_IsEnabled>
    e430:	b930      	cbnz	r0, e440 <_Command_NetInfo+0x154>
    e432:	f50b 72da 	add.w	r2, fp, #436	; 0x1b4
    e436:	f505 71e2 	add.w	r1, r5, #452	; 0x1c4
    e43a:	4638      	mov	r0, r7
    e43c:	47c8      	blx	r9
    e43e:	e013      	b.n	e468 <_Command_NetInfo+0x17c>
    e440:	9a01      	ldr	r2, [sp, #4]
    e442:	e7f8      	b.n	e436 <_Command_NetInfo+0x14a>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Link is %s\r\n", TCPIP_STACK_NetIsLinked(netH) ? "UP" : "DOWN");
    e444:	f105 02c0 	add.w	r2, r5, #192	; 0xc0
    e448:	e018      	b.n	e47c <_Command_NetInfo+0x190>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Status: %s\r\n", TCPIP_STACK_NetIsReady(netH) ? "Ready" : "Not Ready");
    e44a:	f105 02cc 	add.w	r2, r5, #204	; 0xcc
    e44e:	e023      	b.n	e498 <_Command_NetInfo+0x1ac>
    return true;
    e450:	2001      	movs	r0, #1
}
    e452:	b009      	add	sp, #36	; 0x24
    e454:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "%s is ON\r\n", msgAdd);
    e458:	6833      	ldr	r3, [r6, #0]
    e45a:	685b      	ldr	r3, [r3, #4]
    e45c:	f505 7205 	add.w	r2, r5, #532	; 0x214
    e460:	f505 7102 	add.w	r1, r5, #520	; 0x208
    e464:	4638      	mov	r0, r7
    e466:	4798      	blx	r3
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Link is %s\r\n", TCPIP_STACK_NetIsLinked(netH) ? "UP" : "DOWN");
    e468:	6833      	ldr	r3, [r6, #0]
    e46a:	f8d3 9004 	ldr.w	r9, [r3, #4]
    e46e:	4620      	mov	r0, r4
    e470:	f012 fd40 	bl	20ef4 <TCPIP_STACK_NetIsLinked>
    e474:	2800      	cmp	r0, #0
    e476:	d1e5      	bne.n	e444 <_Command_NetInfo+0x158>
    e478:	f105 02c4 	add.w	r2, r5, #196	; 0xc4
    e47c:	f505 71ea 	add.w	r1, r5, #468	; 0x1d4
    e480:	4638      	mov	r0, r7
    e482:	47c8      	blx	r9
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Status: %s\r\n", TCPIP_STACK_NetIsReady(netH) ? "Ready" : "Not Ready");
    e484:	6833      	ldr	r3, [r6, #0]
    e486:	f8d3 9004 	ldr.w	r9, [r3, #4]
    e48a:	4620      	mov	r0, r4
    e48c:	f012 fea2 	bl	211d4 <TCPIP_STACK_NetIsReady>
    e490:	2800      	cmp	r0, #0
    e492:	d1da      	bne.n	e44a <_Command_NetInfo+0x15e>
    e494:	f105 02d4 	add.w	r2, r5, #212	; 0xd4
    e498:	f505 71f2 	add.w	r1, r5, #484	; 0x1e4
    e49c:	4638      	mov	r0, r7
    e49e:	47c8      	blx	r9
    for (i=0; i<initialNetIfs; i++)
    e4a0:	f108 0801 	add.w	r8, r8, #1
    e4a4:	4b11      	ldr	r3, [pc, #68]	; (e4ec <_Command_NetInfo+0x200>)
    e4a6:	681b      	ldr	r3, [r3, #0]
    e4a8:	4543      	cmp	r3, r8
    e4aa:	ddd1      	ble.n	e450 <_Command_NetInfo+0x164>
        netH = TCPIP_STACK_IndexToNet(i);
    e4ac:	4640      	mov	r0, r8
    e4ae:	f011 fcb5 	bl	1fe1c <TCPIP_STACK_IndexToNet>
    e4b2:	4604      	mov	r4, r0
        TCPIP_STACK_NetAliasNameGet(netH, addrBuff, sizeof(addrBuff));
    e4b4:	2214      	movs	r2, #20
    e4b6:	a902      	add	r1, sp, #8
    e4b8:	f00f ff6e 	bl	1e398 <TCPIP_STACK_NetAliasNameGet>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "---------- Interface <%s/%s> ---------- \r\n", addrBuff, TCPIP_STACK_NetNameGet(netH));
    e4bc:	6833      	ldr	r3, [r6, #0]
    e4be:	f8d3 9004 	ldr.w	r9, [r3, #4]
    e4c2:	4620      	mov	r0, r4
    e4c4:	f013 fda1 	bl	2200a <TCPIP_STACK_NetNameGet>
    e4c8:	4603      	mov	r3, r0
    e4ca:	aa02      	add	r2, sp, #8
    e4cc:	4651      	mov	r1, sl
    e4ce:	4638      	mov	r0, r7
    e4d0:	47c8      	blx	r9
        if(!TCPIP_STACK_NetIsUp(netH))
    e4d2:	4620      	mov	r0, r4
    e4d4:	f012 fcf2 	bl	20ebc <TCPIP_STACK_NetIsUp>
    e4d8:	2800      	cmp	r0, #0
    e4da:	f47f af2f 	bne.w	e33c <_Command_NetInfo+0x50>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Interface is down\r\n");
    e4de:	6833      	ldr	r3, [r6, #0]
    e4e0:	681b      	ldr	r3, [r3, #0]
    e4e2:	f505 7198 	add.w	r1, r5, #304	; 0x130
    e4e6:	4638      	mov	r0, r7
    e4e8:	4798      	blx	r3
            continue;
    e4ea:	e7d9      	b.n	e4a0 <_Command_NetInfo+0x1b4>
    e4ec:	2000e5e0 	.word	0x2000e5e0
    e4f0:	00001384 	.word	0x00001384
    e4f4:	0000028c 	.word	0x0000028c

Disassembly of section .text.TCPIP_DNS_ClientInitialize%233:

0000e4f8 <TCPIP_DNS_ClientInitialize>:
{
    e4f8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(stackData->stackAction == TCPIP_STACK_ACTION_IF_UP)
    e4fc:	7f03      	ldrb	r3, [r0, #28]
    e4fe:	2b03      	cmp	r3, #3
    e500:	d013      	beq.n	e52a <TCPIP_DNS_ClientInitialize+0x32>
    e502:	4682      	mov	sl, r0
    e504:	4689      	mov	r9, r1
    if(dnsInitCount == 0)
    e506:	4b76      	ldr	r3, [pc, #472]	; (e6e0 <TCPIP_DNS_ClientInitialize+0x1e8>)
    e508:	681d      	ldr	r5, [r3, #0]
    e50a:	b1e5      	cbz	r5, e546 <TCPIP_DNS_ClientInitialize+0x4e>
    if(stackData->pNetIf->Flags.bIsDnsClientEnabled != 0)
    e50c:	f8da 0014 	ldr.w	r0, [sl, #20]
    e510:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
    e514:	f013 0f08 	tst.w	r3, #8
    e518:	f040 80d5 	bne.w	e6c6 <TCPIP_DNS_ClientInitialize+0x1ce>
    dnsInitCount++;
    e51c:	4a70      	ldr	r2, [pc, #448]	; (e6e0 <TCPIP_DNS_ClientInitialize+0x1e8>)
    e51e:	6813      	ldr	r3, [r2, #0]
    e520:	3301      	adds	r3, #1
    e522:	6013      	str	r3, [r2, #0]
    return true;
    e524:	2001      	movs	r0, #1
}
    e526:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(stackData->pNetIf->Flags.bIsDnsClientEnabled != 0)
    e52a:	6940      	ldr	r0, [r0, #20]
    e52c:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
    e530:	f013 0f08 	tst.w	r3, #8
    e534:	d101      	bne.n	e53a <TCPIP_DNS_ClientInitialize+0x42>
        return true;
    e536:	2001      	movs	r0, #1
    e538:	e7f5      	b.n	e526 <TCPIP_DNS_ClientInitialize+0x2e>
            _DNS_Enable(stackData->pNetIf, false, TCPIP_DNS_ENABLE_DEFAULT);
    e53a:	2200      	movs	r2, #0
    e53c:	4611      	mov	r1, r2
    e53e:	f00d faa9 	bl	1ba94 <_DNS_Enable>
        return true;
    e542:	2001      	movs	r0, #1
    e544:	e7ef      	b.n	e526 <TCPIP_DNS_ClientInitialize+0x2e>
        memset(pDnsDcpt, 0, sizeof(*pDnsDcpt));
    e546:	2228      	movs	r2, #40	; 0x28
    e548:	2100      	movs	r1, #0
    e54a:	4866      	ldr	r0, [pc, #408]	; (e6e4 <TCPIP_DNS_ClientInitialize+0x1ec>)
    e54c:	f013 fb16 	bl	21b7c <memset>
        if(dnsData == 0 || TCPIP_DNS_CLIENT_MAX_HOSTNAME_LEN == 0)
    e550:	f1b9 0f00 	cmp.w	r9, #0
    e554:	f000 80bc 	beq.w	e6d0 <TCPIP_DNS_ClientInitialize+0x1d8>
        pDnsDcpt->memH = stackData->memH;
    e558:	f8da 000c 	ldr.w	r0, [sl, #12]
    e55c:	4b61      	ldr	r3, [pc, #388]	; (e6e4 <TCPIP_DNS_ClientInitialize+0x1ec>)
    e55e:	6118      	str	r0, [r3, #16]
        hashMemSize = sizeof(OA_HASH_DCPT) + dnsData->cacheEntries * sizeof(TCPIP_DNS_HASH_ENTRY);
    e560:	f8d9 3004 	ldr.w	r3, [r9, #4]
    e564:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    e568:	011c      	lsls	r4, r3, #4
    e56a:	3428      	adds	r4, #40	; 0x28
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
    e56c:	6843      	ldr	r3, [r0, #4]
    e56e:	4621      	mov	r1, r4
    e570:	4798      	blx	r3
        if(hashDcpt == 0)
    e572:	4680      	mov	r8, r0
    e574:	2800      	cmp	r0, #0
    e576:	f000 80ad 	beq.w	e6d4 <TCPIP_DNS_ClientInitialize+0x1dc>
        memset(hashDcpt, 0, hashMemSize);
    e57a:	4622      	mov	r2, r4
    e57c:	2100      	movs	r1, #0
    e57e:	f013 fafd 	bl	21b7c <memset>
        hashDcpt->memBlk = hashDcpt + 1;
    e582:	f108 0328 	add.w	r3, r8, #40	; 0x28
    e586:	f8c8 3000 	str.w	r3, [r8]
        hashDcpt->hParam = hashDcpt;    // store the descriptor it belongs to
    e58a:	f8c8 8004 	str.w	r8, [r8, #4]
        hashDcpt->hEntrySize = sizeof(TCPIP_DNS_HASH_ENTRY);
    e58e:	2330      	movs	r3, #48	; 0x30
    e590:	f8c8 3008 	str.w	r3, [r8, #8]
        hashDcpt->hEntries = dnsData->cacheEntries;
    e594:	f8d9 3004 	ldr.w	r3, [r9, #4]
    e598:	f8c8 300c 	str.w	r3, [r8, #12]
        hashDcpt->probeStep = TCPIP_DNS_HASH_PROBE_STEP;
    e59c:	2401      	movs	r4, #1
    e59e:	f8c8 4010 	str.w	r4, [r8, #16]
        hashDcpt->hashF = TCPIP_DNS_OAHASH_KeyHash;
    e5a2:	4b51      	ldr	r3, [pc, #324]	; (e6e8 <TCPIP_DNS_ClientInitialize+0x1f0>)
    e5a4:	f8c8 3014 	str.w	r3, [r8, #20]
        hashDcpt->delF = TCPIP_DNS_OAHASH_DeleteEntry;
    e5a8:	4b50      	ldr	r3, [pc, #320]	; (e6ec <TCPIP_DNS_ClientInitialize+0x1f4>)
    e5aa:	f8c8 3018 	str.w	r3, [r8, #24]
        hashDcpt->cmpF = TCPIP_DNS_OAHASH_KeyCompare;
    e5ae:	4b50      	ldr	r3, [pc, #320]	; (e6f0 <TCPIP_DNS_ClientInitialize+0x1f8>)
    e5b0:	f8c8 301c 	str.w	r3, [r8, #28]
        hashDcpt->cpyF = TCPIP_DNS_OAHASH_KeyCopy;
    e5b4:	4b4f      	ldr	r3, [pc, #316]	; (e6f4 <TCPIP_DNS_ClientInitialize+0x1fc>)
    e5b6:	f8c8 3020 	str.w	r3, [r8, #32]
        TCPIP_OAHASH_Initialize(hashDcpt);
    e5ba:	4640      	mov	r0, r8
    e5bc:	f011 fdf7 	bl	201ae <TCPIP_OAHASH_Initialize>
        pDnsDcpt->hashDcpt = hashDcpt;
    e5c0:	4a48      	ldr	r2, [pc, #288]	; (e6e4 <TCPIP_DNS_ClientInitialize+0x1ec>)
    e5c2:	f8c2 8000 	str.w	r8, [r2]
        pDnsDcpt->dnsSocket =  INVALID_UDP_SOCKET;
    e5c6:	f64f 73ff 	movw	r3, #65535	; 0xffff
    e5ca:	8493      	strh	r3, [r2, #36]	; 0x24
        pDnsDcpt->cacheEntryTMO = dnsData->entrySolvedTmo;
    e5cc:	f8d9 3008 	ldr.w	r3, [r9, #8]
    e5d0:	6153      	str	r3, [r2, #20]
        pDnsDcpt->nIPv4Entries= dnsData->nIPv4Entries;
    e5d2:	f8d9 300c 	ldr.w	r3, [r9, #12]
    e5d6:	8413      	strh	r3, [r2, #32]
        pDnsDcpt->nIPv6Entries = dnsData->nIPv6Entries;
    e5d8:	f8d9 1014 	ldr.w	r1, [r9, #20]
    e5dc:	8451      	strh	r1, [r2, #34]	; 0x22
        pDnsDcpt->ipAddressType = IP_ADDRESS_TYPE_IPV4;     // dnsData->ipAddressType;
    e5de:	7614      	strb	r4, [r2, #24]
            + pDnsDcpt->nIPv6Entries * sizeof(IPV6_ADDR)
    e5e0:	b289      	uxth	r1, r1
        memoryBlockSize = pDnsDcpt->nIPv4Entries * sizeof(IPV4_ADDR)
    e5e2:	fa1f fb83 	uxth.w	fp, r3
            + TCPIP_DNS_CLIENT_MAX_HOSTNAME_LEN ;
    e5e6:	f10b 0b10 	add.w	fp, fp, #16
    e5ea:	eb0b 0b81 	add.w	fp, fp, r1, lsl #2
        memoryBlockSize = pDnsDcpt->nIPv4Entries * sizeof(IPV4_ADDR)
    e5ee:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
        for(hashCnt = 0; hashCnt < dnsData->cacheEntries; hashCnt++)
    e5f2:	f8d9 3004 	ldr.w	r3, [r9, #4]
    e5f6:	2b00      	cmp	r3, #0
    e5f8:	dd2a      	ble.n	e650 <TCPIP_DNS_ClientInitialize+0x158>
            pMemoryBlock = (uint8_t *)TCPIP_HEAP_Malloc(pDnsDcpt->memH, memoryBlockSize);
    e5fa:	4616      	mov	r6, r2
            pE->pHostName = 0;
    e5fc:	2700      	movs	r7, #0
    e5fe:	e00a      	b.n	e616 <TCPIP_DNS_ClientInitialize+0x11e>
                _DNS_DeleteHash(pDnsDcpt);
    e600:	4838      	ldr	r0, [pc, #224]	; (e6e4 <TCPIP_DNS_ClientInitialize+0x1ec>)
    e602:	f00d fc49 	bl	1be98 <_DNS_DeleteHash>
                return false;
    e606:	2000      	movs	r0, #0
    e608:	e78d      	b.n	e526 <TCPIP_DNS_ClientInitialize+0x2e>
            pE->pHostName = (char*)pMemoryBlock;
    e60a:	6220      	str	r0, [r4, #32]
        for(hashCnt = 0; hashCnt < dnsData->cacheEntries; hashCnt++)
    e60c:	3501      	adds	r5, #1
    e60e:	f8d9 3004 	ldr.w	r3, [r9, #4]
    e612:	42ab      	cmp	r3, r5
    e614:	dd1c      	ble.n	e650 <TCPIP_DNS_ClientInitialize+0x158>
            pBkt = TCPIP_OAHASH_EntryGet(hashDcpt, hashCnt);
    e616:	4629      	mov	r1, r5
    e618:	4640      	mov	r0, r8
    e61a:	f013 f99e 	bl	2195a <TCPIP_OAHASH_EntryGet>
    e61e:	4604      	mov	r4, r0
            pMemoryBlock = (uint8_t *)TCPIP_HEAP_Malloc(pDnsDcpt->memH, memoryBlockSize);
    e620:	6930      	ldr	r0, [r6, #16]
    e622:	6843      	ldr	r3, [r0, #4]
    e624:	4659      	mov	r1, fp
    e626:	4798      	blx	r3
            if((pE->memblk = pMemoryBlock) == 0)
    e628:	6060      	str	r0, [r4, #4]
    e62a:	2800      	cmp	r0, #0
    e62c:	d0e8      	beq.n	e600 <TCPIP_DNS_ClientInitialize+0x108>
            pE->pHostName = 0;
    e62e:	6227      	str	r7, [r4, #32]
            pE->pip4Address = 0;
    e630:	6127      	str	r7, [r4, #16]
            pE->pip6Address = 0;
    e632:	6167      	str	r7, [r4, #20]
            if(pDnsDcpt->nIPv4Entries)
    e634:	8c33      	ldrh	r3, [r6, #32]
    e636:	b11b      	cbz	r3, e640 <TCPIP_DNS_ClientInitialize+0x148>
                pE->pip4Address = (IPV4_ADDR *)pMemoryBlock;
    e638:	6120      	str	r0, [r4, #16]
                pMemoryBlock += pDnsDcpt->nIPv4Entries * (sizeof(IPV4_ADDR));
    e63a:	8c33      	ldrh	r3, [r6, #32]
    e63c:	eb00 0083 	add.w	r0, r0, r3, lsl #2
            if(pDnsDcpt->nIPv6Entries)
    e640:	8c73      	ldrh	r3, [r6, #34]	; 0x22
    e642:	2b00      	cmp	r3, #0
    e644:	d0e1      	beq.n	e60a <TCPIP_DNS_ClientInitialize+0x112>
                pE->pip6Address = (IPV6_ADDR *)pMemoryBlock;
    e646:	6160      	str	r0, [r4, #20]
                pMemoryBlock += pDnsDcpt->nIPv6Entries * (sizeof(IPV6_ADDR));
    e648:	8c73      	ldrh	r3, [r6, #34]	; 0x22
    e64a:	eb00 1003 	add.w	r0, r0, r3, lsl #4
    e64e:	e7dc      	b.n	e60a <TCPIP_DNS_ClientInitialize+0x112>
            if((pDnsDcpt->dnsSignalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_DNS_ClientTask, TCPIP_DNS_CLIENT_TASK_PROCESS_RATE)) == 0)
    e650:	22c8      	movs	r2, #200	; 0xc8
    e652:	4929      	ldr	r1, [pc, #164]	; (e6f8 <TCPIP_DNS_ClientInitialize+0x200>)
    e654:	200f      	movs	r0, #15
    e656:	f00e fb1b 	bl	1cc90 <_TCPIPStackSignalHandlerRegister>
    e65a:	4b22      	ldr	r3, [pc, #136]	; (e6e4 <TCPIP_DNS_ClientInitialize+0x1ec>)
    e65c:	60d8      	str	r0, [r3, #12]
    e65e:	b190      	cbz	r0, e686 <TCPIP_DNS_ClientInitialize+0x18e>
    if(pDnsDcpt->dnsSocket != INVALID_UDP_SOCKET)
    e660:	f9b3 3024 	ldrsh.w	r3, [r3, #36]	; 0x24
    e664:	f1b3 3fff 	cmp.w	r3, #4294967295
    e668:	d003      	beq.n	e672 <TCPIP_DNS_ClientInitialize+0x17a>
        pgDnsDcpt = &gDnsDcpt;
    e66a:	4b24      	ldr	r3, [pc, #144]	; (e6fc <TCPIP_DNS_ClientInitialize+0x204>)
    e66c:	4a1d      	ldr	r2, [pc, #116]	; (e6e4 <TCPIP_DNS_ClientInitialize+0x1ec>)
    e66e:	601a      	str	r2, [r3, #0]
    e670:	e74c      	b.n	e50c <TCPIP_DNS_ClientInitialize+0x14>
        dnsSocket = TCPIP_UDP_ClientOpen(pDnsDcpt->ipAddressType, TCPIP_DNS_SERVER_PORT, 0);
    e672:	2200      	movs	r2, #0
    e674:	2135      	movs	r1, #53	; 0x35
    e676:	4b1b      	ldr	r3, [pc, #108]	; (e6e4 <TCPIP_DNS_ClientInitialize+0x1ec>)
    e678:	7e18      	ldrb	r0, [r3, #24]
    e67a:	f013 fcd5 	bl	22028 <TCPIP_UDP_ClientOpen>
    e67e:	4604      	mov	r4, r0
        if(dnsSocket == INVALID_UDP_SOCKET)
    e680:	f1b0 3fff 	cmp.w	r0, #4294967295
    e684:	d104      	bne.n	e690 <TCPIP_DNS_ClientInitialize+0x198>
            _DNSClientCleanup(pDnsDcpt);
    e686:	4817      	ldr	r0, [pc, #92]	; (e6e4 <TCPIP_DNS_ClientInitialize+0x1ec>)
    e688:	f010 ff72 	bl	1f570 <_DNSClientCleanup>
            return false;
    e68c:	2000      	movs	r0, #0
    e68e:	e74a      	b.n	e526 <TCPIP_DNS_ClientInitialize+0x2e>
        bufferSize = TCPIP_UDP_TxPutIsReady(dnsSocket, minDnsTxSize);
    e690:	2153      	movs	r1, #83	; 0x53
    e692:	f013 fcf2 	bl	2207a <TCPIP_UDP_TxPutIsReady>
        if(bufferSize < minDnsTxSize)
    e696:	2852      	cmp	r0, #82	; 0x52
    e698:	d805      	bhi.n	e6a6 <TCPIP_DNS_ClientInitialize+0x1ae>
            if(!TCPIP_UDP_OptionsSet(dnsSocket, UDP_OPTION_TX_BUFF, (void*)minDnsTxSize))
    e69a:	2253      	movs	r2, #83	; 0x53
    e69c:	2105      	movs	r1, #5
    e69e:	4620      	mov	r0, r4
    e6a0:	f000 f830 	bl	e704 <TCPIP_UDP_OptionsSet>
    e6a4:	b1c0      	cbz	r0, e6d8 <TCPIP_DNS_ClientInitialize+0x1e0>
        TCPIP_UDP_OptionsSet(dnsSocket, UDP_OPTION_STRICT_ADDRESS, (void*)false);
    e6a6:	2200      	movs	r2, #0
    e6a8:	2102      	movs	r1, #2
    e6aa:	4620      	mov	r0, r4
    e6ac:	f000 f82a 	bl	e704 <TCPIP_UDP_OptionsSet>
        if(TCPIP_UDP_SignalHandlerRegister(dnsSocket, TCPIP_UDP_SIGNAL_RX_DATA, _DNSSocketRxSignalHandler, 0) == 0)
    e6b0:	2300      	movs	r3, #0
    e6b2:	4a13      	ldr	r2, [pc, #76]	; (e700 <TCPIP_DNS_ClientInitialize+0x208>)
    e6b4:	f44f 7180 	mov.w	r1, #256	; 0x100
    e6b8:	4620      	mov	r0, r4
    e6ba:	f00e fd46 	bl	1d14a <TCPIP_UDP_SignalHandlerRegister>
    e6be:	b158      	cbz	r0, e6d8 <TCPIP_DNS_ClientInitialize+0x1e0>
        pDnsDcpt->dnsSocket = dnsSocket;
    e6c0:	4b08      	ldr	r3, [pc, #32]	; (e6e4 <TCPIP_DNS_ClientInitialize+0x1ec>)
    e6c2:	849c      	strh	r4, [r3, #36]	; 0x24
    if(!success && dnsSocket != INVALID_UDP_SOCKET)
    e6c4:	e7d1      	b.n	e66a <TCPIP_DNS_ClientInitialize+0x172>
        _DNS_Enable(stackData->pNetIf, false, TCPIP_DNS_ENABLE_DEFAULT);
    e6c6:	2200      	movs	r2, #0
    e6c8:	4611      	mov	r1, r2
    e6ca:	f00d f9e3 	bl	1ba94 <_DNS_Enable>
    e6ce:	e725      	b.n	e51c <TCPIP_DNS_ClientInitialize+0x24>
            return false;
    e6d0:	2000      	movs	r0, #0
    e6d2:	e728      	b.n	e526 <TCPIP_DNS_ClientInitialize+0x2e>
            return false;
    e6d4:	2000      	movs	r0, #0
    e6d6:	e726      	b.n	e526 <TCPIP_DNS_ClientInitialize+0x2e>
        TCPIP_UDP_Close(dnsSocket);
    e6d8:	4620      	mov	r0, r4
    e6da:	f010 fd43 	bl	1f164 <TCPIP_UDP_Close>
    e6de:	e7d2      	b.n	e686 <TCPIP_DNS_ClientInitialize+0x18e>
    e6e0:	2000e628 	.word	0x2000e628
    e6e4:	2000e2c8 	.word	0x2000e2c8
    e6e8:	00020951 	.word	0x00020951
    e6ec:	0001c36d 	.word	0x0001c36d
    e6f0:	00021ee1 	.word	0x00021ee1
    e6f4:	0001facd 	.word	0x0001facd
    e6f8:	00014621 	.word	0x00014621
    e6fc:	2000e62c 	.word	0x2000e62c
    e700:	000216b9 	.word	0x000216b9

Disassembly of section .text.TCPIP_UDP_OptionsSet%234:

0000e704 <TCPIP_UDP_OptionsSet>:
    return true;
}

// Allows setting options to a socket like enable broadcast, Rx/Tx buffer size, etc
bool TCPIP_UDP_OptionsSet(UDP_SOCKET hUDP, UDP_SOCKET_OPTION option, void* optParam)
{
    e704:	b570      	push	{r4, r5, r6, lr}
    e706:	460d      	mov	r5, r1
    e708:	4614      	mov	r4, r2
    UDP_SOCKET_DCPT*  pSkt = _UDPSocketDcpt(hUDP);
    e70a:	f011 fbeb 	bl	1fee4 <_UDPSocketDcpt>

    if(pSkt)
    e70e:	2800      	cmp	r0, #0
    e710:	f000 80f0 	beq.w	e8f4 <TCPIP_UDP_OptionsSet+0x1f0>
    e714:	4606      	mov	r6, r0
    {
        switch(option)
    e716:	2d0c      	cmp	r5, #12
    e718:	f200 80ee 	bhi.w	e8f8 <TCPIP_UDP_OptionsSet+0x1f4>
    e71c:	e8df f005 	tbb	[pc, r5]
    e720:	281d1207 	.word	0x281d1207
    e724:	68645f46 	.word	0x68645f46
    e728:	d77b776c 	.word	0xd77b776c
    e72c:	df          	.byte	0xdf
    e72d:	00          	.byte	0x00
        {
            case UDP_OPTION_STRICT_PORT:
                pSkt->flags.looseRemPort = (optParam == 0);
    e72e:	fab4 f484 	clz	r4, r4
    e732:	0964      	lsrs	r4, r4, #5
    e734:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    e738:	f364 0382 	bfi	r3, r4, #2, #1
    e73c:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
                return true;
    e740:	2001      	movs	r0, #1
    e742:	e0d8      	b.n	e8f6 <TCPIP_UDP_OptionsSet+0x1f2>


            case UDP_OPTION_STRICT_NET:
                pSkt->flags.looseNetIf = (optParam == 0);
    e744:	fab4 f484 	clz	r4, r4
    e748:	0964      	lsrs	r4, r4, #5
    e74a:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    e74e:	f364 03c3 	bfi	r3, r4, #3, #1
    e752:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
                return true;
    e756:	2001      	movs	r0, #1
    e758:	e0cd      	b.n	e8f6 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_STRICT_ADDRESS:
                pSkt->flags.looseRemAddress = (optParam == 0);
    e75a:	fab4 f484 	clz	r4, r4
    e75e:	0964      	lsrs	r4, r4, #5
    e760:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    e764:	f364 1304 	bfi	r3, r4, #4, #1
    e768:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
                return true;
    e76c:	2001      	movs	r0, #1
    e76e:	e0c2      	b.n	e8f6 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_BROADCAST:
                if((pSkt->flags.bcastForceType = (int)optParam) != UDP_BCAST_NONE)
    e770:	f004 0403 	and.w	r4, r4, #3
    e774:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    e778:	f364 0301 	bfi	r3, r4, #0, #2
    e77c:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
    e780:	b154      	cbz	r4, e798 <TCPIP_UDP_OptionsSet+0x94>
                {   // set limited broadcast address (for now)
                    pSkt->destAddress.Val = 0xffffffff;
    e782:	f04f 33ff 	mov.w	r3, #4294967295
    e786:	6143      	str	r3, [r0, #20]
                    pSkt->flags.destSet = 1;
    e788:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
    e78c:	f043 0301 	orr.w	r3, r3, #1
    e790:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
                {   // the discrete address will have to be set and take effect
                    pSkt->destAddress.Val = 0;
                    pSkt->flags.destSet = 0;
                }

                return true;
    e794:	2001      	movs	r0, #1
    e796:	e0ae      	b.n	e8f6 <TCPIP_UDP_OptionsSet+0x1f2>
                    pSkt->destAddress.Val = 0;
    e798:	2200      	movs	r2, #0
    e79a:	6142      	str	r2, [r0, #20]
                    pSkt->flags.destSet = 0;
    e79c:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
    e7a0:	f362 0300 	bfi	r3, r2, #0, #1
    e7a4:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
                return true;
    e7a8:	2001      	movs	r0, #1
    e7aa:	e0a4      	b.n	e8f6 <TCPIP_UDP_OptionsSet+0x1f2>
                if(pSkt->addType == IP_ADDRESS_TYPE_IPV6)
                {   
                    return false;
                }
#endif  // defined (TCPIP_STACK_USE_IPV6)
                if(pSkt->flags.txSplitAlloc != 0)
    e7ac:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
    e7b0:	f013 0f02 	tst.w	r3, #2
    e7b4:	f040 80a2 	bne.w	e8fc <TCPIP_UDP_OptionsSet+0x1f8>
                {   // no support for external payload sockets
                    return false;
                }

                if(pSkt->flags.usePool != (optParam != 0))
    e7b8:	3400      	adds	r4, #0
    e7ba:	bf18      	it	ne
    e7bc:	2401      	movne	r4, #1
    e7be:	f3c3 0380 	ubfx	r3, r3, #2, #1
    e7c2:	42a3      	cmp	r3, r4
    e7c4:	d101      	bne.n	e7ca <TCPIP_UDP_OptionsSet+0xc6>
                {   // changed the buffer type; just release the packet
                    _UDPFreeTxResources(pSkt);
                    pSkt->flags.usePool = (optParam != 0);
                }
                return true;
    e7c6:	2001      	movs	r0, #1
    e7c8:	e095      	b.n	e8f6 <TCPIP_UDP_OptionsSet+0x1f2>
                    _UDPFreeTxResources(pSkt);
    e7ca:	f011 f821 	bl	1f810 <_UDPFreeTxResources>
                    pSkt->flags.usePool = (optParam != 0);
    e7ce:	f896 3041 	ldrb.w	r3, [r6, #65]	; 0x41
    e7d2:	f364 0382 	bfi	r3, r4, #2, #1
    e7d6:	f886 3041 	strb.w	r3, [r6, #65]	; 0x41
                return true;
    e7da:	2001      	movs	r0, #1
    e7dc:	e08b      	b.n	e8f6 <TCPIP_UDP_OptionsSet+0x1f2>


            case UDP_OPTION_TX_BUFF:
                // just release the packet
                _UDPFreeTxResources(pSkt);
    e7de:	f011 f817 	bl	1f810 <_UDPFreeTxResources>
                pSkt->txSize = (uint16_t)(unsigned int)optParam;
    e7e2:	8234      	strh	r4, [r6, #16]
                return true;
    e7e4:	2001      	movs	r0, #1
    e7e6:	e086      	b.n	e8f6 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_TX_QUEUE_LIMIT:
                pSkt->txAllocLimit = (uint8_t)(unsigned int)optParam;
    e7e8:	f880 403e 	strb.w	r4, [r0, #62]	; 0x3e
                return true;
    e7ec:	2001      	movs	r0, #1
    e7ee:	e082      	b.n	e8f6 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_RX_QUEUE_LIMIT:
                pSkt->rxQueueLimit = (uint8_t)(unsigned int)optParam;
    e7f0:	f880 405a 	strb.w	r4, [r0, #90]	; 0x5a
                return true;
    e7f4:	2001      	movs	r0, #1
    e7f6:	e07e      	b.n	e8f6 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_RX_AUTO_ADVANCE:
                pSkt->extFlags.rxAutoAdvance = (optParam != 0);
    e7f8:	3400      	adds	r4, #0
    e7fa:	bf18      	it	ne
    e7fc:	2401      	movne	r4, #1
    e7fe:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
    e802:	f364 0300 	bfi	r3, r4, #0, #1
    e806:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
                return true;
    e80a:	2001      	movs	r0, #1
    e80c:	e073      	b.n	e8f6 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_TX_TTL:
                pSkt->ttl = (uint8_t)(unsigned int)optParam;
    e80e:	f880 405b 	strb.w	r4, [r0, #91]	; 0x5b
                return true;
    e812:	2001      	movs	r0, #1
    e814:	e06f      	b.n	e8f6 <TCPIP_UDP_OptionsSet+0x1f2>

            case UDP_OPTION_MULTICAST:
                {
                    UDP_OPTION_MULTICAST_DATA* pMcOpt = (UDP_OPTION_MULTICAST_DATA*)optParam;
                    if(pMcOpt!= 0)
    e816:	2c00      	cmp	r4, #0
    e818:	d072      	beq.n	e900 <TCPIP_UDP_OptionsSet+0x1fc>
                    {
                        if((pMcOpt->flagsMask & UDP_MCAST_FLAG_LOOSE_NET_SOURCE_PORT) != 0)
    e81a:	7823      	ldrb	r3, [r4, #0]
    e81c:	f013 0f01 	tst.w	r3, #1
    e820:	d012      	beq.n	e848 <TCPIP_UDP_OptionsSet+0x144>
                        {   // change the source/net/source/port value
                            pSkt->flags.looseNetIf = (pMcOpt->flagsValue & UDP_MCAST_FLAG_LOOSE_NET_SOURCE_PORT) != 0;
    e822:	7862      	ldrb	r2, [r4, #1]
    e824:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    e828:	f362 03c3 	bfi	r3, r2, #3, #1
    e82c:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
                            pSkt->flags.looseRemAddress = (pMcOpt->flagsValue & UDP_MCAST_FLAG_LOOSE_NET_SOURCE_PORT) != 0;
    e830:	7862      	ldrb	r2, [r4, #1]
    e832:	b2db      	uxtb	r3, r3
    e834:	f362 1304 	bfi	r3, r2, #4, #1
    e838:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
                            pSkt->flags.looseRemPort = (pMcOpt->flagsValue & UDP_MCAST_FLAG_LOOSE_NET_SOURCE_PORT) != 0;
    e83c:	7862      	ldrb	r2, [r4, #1]
    e83e:	b2db      	uxtb	r3, r3
    e840:	f362 0382 	bfi	r3, r2, #2, #1
    e844:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
                        }
                        if((pMcOpt->flagsMask & UDP_MCAST_FLAG_IGNORE_SOURCE_ADD) != 0)
    e848:	7823      	ldrb	r3, [r4, #0]
    e84a:	f013 0f02 	tst.w	r3, #2
    e84e:	d008      	beq.n	e862 <TCPIP_UDP_OptionsSet+0x15e>
                        {
                            pSkt->extFlags.ignoreSrcAdd = (pMcOpt->flagsValue & UDP_MCAST_FLAG_IGNORE_SOURCE_ADD) != 0;
    e850:	7863      	ldrb	r3, [r4, #1]
    e852:	f3c3 0340 	ubfx	r3, r3, #1, #1
    e856:	f896 2042 	ldrb.w	r2, [r6, #66]	; 0x42
    e85a:	f363 1204 	bfi	r2, r3, #4, #1
    e85e:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42
                        }
                        if((pMcOpt->flagsMask & UDP_MCAST_FLAG_IGNORE_SOURCE_PORT) != 0)
    e862:	7823      	ldrb	r3, [r4, #0]
    e864:	f013 0f04 	tst.w	r3, #4
    e868:	d008      	beq.n	e87c <TCPIP_UDP_OptionsSet+0x178>
                        {
                            pSkt->extFlags.ignoreSrcPort = (pMcOpt->flagsValue & UDP_MCAST_FLAG_IGNORE_SOURCE_PORT) != 0;
    e86a:	7863      	ldrb	r3, [r4, #1]
    e86c:	f3c3 0380 	ubfx	r3, r3, #2, #1
    e870:	f896 2042 	ldrb.w	r2, [r6, #66]	; 0x42
    e874:	f363 1245 	bfi	r2, r3, #5, #1
    e878:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42
                        }
                        if((pMcOpt->flagsMask & UDP_MCAST_FLAG_IGNORE_UNICAST) != 0)
    e87c:	7823      	ldrb	r3, [r4, #0]
    e87e:	f013 0f08 	tst.w	r3, #8
    e882:	d008      	beq.n	e896 <TCPIP_UDP_OptionsSet+0x192>
                        {
                            pSkt->extFlags.mcastOnly = (pMcOpt->flagsValue & UDP_MCAST_FLAG_IGNORE_UNICAST) != 0;
    e884:	7863      	ldrb	r3, [r4, #1]
    e886:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    e88a:	f896 2042 	ldrb.w	r2, [r6, #66]	; 0x42
    e88e:	f363 1286 	bfi	r2, r3, #6, #1
    e892:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42
                        }
                        if((pMcOpt->flagsMask & UDP_MCAST_FLAG_LOOP) != 0)
    e896:	7823      	ldrb	r3, [r4, #0]
    e898:	f013 0f10 	tst.w	r3, #16
    e89c:	d008      	beq.n	e8b0 <TCPIP_UDP_OptionsSet+0x1ac>
                        {
                            pSkt->extFlags.mcastLoop = (pMcOpt->flagsValue & UDP_MCAST_FLAG_LOOP) != 0;
    e89e:	7863      	ldrb	r3, [r4, #1]
    e8a0:	f3c3 1300 	ubfx	r3, r3, #4, #1
    e8a4:	f896 2042 	ldrb.w	r2, [r6, #66]	; 0x42
    e8a8:	f363 0282 	bfi	r2, r3, #2, #1
    e8ac:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42
                        }
                        if((pMcOpt->flagsMask & UDP_MCAST_FLAG_DISABLE_SOURCE_CHECK) != 0)
    e8b0:	7823      	ldrb	r3, [r4, #0]
    e8b2:	f013 0f20 	tst.w	r3, #32
    e8b6:	d025      	beq.n	e904 <TCPIP_UDP_OptionsSet+0x200>
                        {
                            pSkt->extFlags.mcastSkipCheck = (pMcOpt->flagsValue & UDP_MCAST_FLAG_DISABLE_SOURCE_CHECK) != 0;
    e8b8:	7863      	ldrb	r3, [r4, #1]
    e8ba:	f3c3 1340 	ubfx	r3, r3, #5, #1
    e8be:	f896 2042 	ldrb.w	r2, [r6, #66]	; 0x42
    e8c2:	f363 02c3 	bfi	r2, r3, #3, #1
    e8c6:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42
                        }

                        return true;
    e8ca:	2001      	movs	r0, #1
    e8cc:	e013      	b.n	e8f6 <TCPIP_UDP_OptionsSet+0x1f2>
                    }
                }
                return false;

            case UDP_OPTION_TOS:
                pSkt->extFlags.tos = (uint8_t)(unsigned int)optParam;
    e8ce:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
    e8d2:	f364 0305 	bfi	r3, r4, #0, #6
    e8d6:	f880 3043 	strb.w	r3, [r0, #67]	; 0x43
                return true;
    e8da:	2001      	movs	r0, #1
    e8dc:	e00b      	b.n	e8f6 <TCPIP_UDP_OptionsSet+0x1f2>
                
            case UDP_OPTION_DF:
                pSkt->extFlags.df = (optParam != 0);
    e8de:	3400      	adds	r4, #0
    e8e0:	bf18      	it	ne
    e8e2:	2401      	movne	r4, #1
    e8e4:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
    e8e8:	f364 1386 	bfi	r3, r4, #6, #1
    e8ec:	f880 3043 	strb.w	r3, [r0, #67]	; 0x43
                return true;
    e8f0:	2001      	movs	r0, #1
    e8f2:	e000      	b.n	e8f6 <TCPIP_UDP_OptionsSet+0x1f2>
            default:
                break;
        }
    }    

    return false;
    e8f4:	2000      	movs	r0, #0
}
    e8f6:	bd70      	pop	{r4, r5, r6, pc}
    return false;
    e8f8:	2000      	movs	r0, #0
    e8fa:	e7fc      	b.n	e8f6 <TCPIP_UDP_OptionsSet+0x1f2>
                    return false;
    e8fc:	2000      	movs	r0, #0
    e8fe:	e7fa      	b.n	e8f6 <TCPIP_UDP_OptionsSet+0x1f2>
                return false;
    e900:	2000      	movs	r0, #0
    e902:	e7f8      	b.n	e8f6 <TCPIP_UDP_OptionsSet+0x1f2>
                        return true;
    e904:	2001      	movs	r0, #1
    e906:	e7f6      	b.n	e8f6 <TCPIP_UDP_OptionsSet+0x1f2>

Disassembly of section .text._vfprintf_r%235:

0000e908 <_vfiprintf_r>:
    e908:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e90c:	460d      	mov	r5, r1
    e90e:	b09d      	sub	sp, #116	; 0x74
    e910:	4614      	mov	r4, r2
    e912:	461e      	mov	r6, r3
    e914:	4607      	mov	r7, r0
    e916:	b118      	cbz	r0, e920 <_vfiprintf_r+0x18>
    e918:	6983      	ldr	r3, [r0, #24]
    e91a:	b90b      	cbnz	r3, e920 <_vfiprintf_r+0x18>
    e91c:	f00c fdb0 	bl	1b480 <__sinit>
    e920:	4b70      	ldr	r3, [pc, #448]	; (eae4 <_vfiprintf_r+0x1dc>)
    e922:	429d      	cmp	r5, r3
    e924:	d15c      	bne.n	e9e0 <_vfiprintf_r+0xd8>
    e926:	687d      	ldr	r5, [r7, #4]
    e928:	89ab      	ldrh	r3, [r5, #12]
    e92a:	071b      	lsls	r3, r3, #28
    e92c:	d562      	bpl.n	e9f4 <_vfiprintf_r+0xec>
    e92e:	692b      	ldr	r3, [r5, #16]
    e930:	2b00      	cmp	r3, #0
    e932:	d05f      	beq.n	e9f4 <_vfiprintf_r+0xec>
    e934:	2300      	movs	r3, #0
    e936:	9309      	str	r3, [sp, #36]	; 0x24
    e938:	f8df 91ac 	ldr.w	r9, [pc, #428]	; eae8 <_vfiprintf_r+0x1e0>
    e93c:	9603      	str	r6, [sp, #12]
    e93e:	2320      	movs	r3, #32
    e940:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
    e944:	2330      	movs	r3, #48	; 0x30
    e946:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    e94a:	f04f 38ff 	mov.w	r8, #4294967295
    e94e:	f109 0a06 	add.w	sl, r9, #6
    e952:	4623      	mov	r3, r4
    e954:	461e      	mov	r6, r3
    e956:	f813 2b01 	ldrb.w	r2, [r3], #1
    e95a:	b10a      	cbz	r2, e960 <_vfiprintf_r+0x58>
    e95c:	2a25      	cmp	r2, #37	; 0x25
    e95e:	d1f9      	bne.n	e954 <_vfiprintf_r+0x4c>
    e960:	ebb6 0b04 	subs.w	fp, r6, r4
    e964:	d00b      	beq.n	e97e <_vfiprintf_r+0x76>
    e966:	465b      	mov	r3, fp
    e968:	4622      	mov	r2, r4
    e96a:	4629      	mov	r1, r5
    e96c:	4638      	mov	r0, r7
    e96e:	f00e f826 	bl	1c9be <__ssfputs_r>
    e972:	3001      	adds	r0, #1
    e974:	f000 80b0 	beq.w	ead8 <_vfiprintf_r+0x1d0>
    e978:	9b09      	ldr	r3, [sp, #36]	; 0x24
    e97a:	445b      	add	r3, fp
    e97c:	9309      	str	r3, [sp, #36]	; 0x24
    e97e:	7833      	ldrb	r3, [r6, #0]
    e980:	2b00      	cmp	r3, #0
    e982:	f000 80a9 	beq.w	ead8 <_vfiprintf_r+0x1d0>
    e986:	2300      	movs	r3, #0
    e988:	e9cd 8305 	strd	r8, r3, [sp, #20]
    e98c:	3601      	adds	r6, #1
    e98e:	9304      	str	r3, [sp, #16]
    e990:	9307      	str	r3, [sp, #28]
    e992:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    e996:	931a      	str	r3, [sp, #104]	; 0x68
    e998:	f04f 0b01 	mov.w	fp, #1
    e99c:	4634      	mov	r4, r6
    e99e:	2205      	movs	r2, #5
    e9a0:	f814 1b01 	ldrb.w	r1, [r4], #1
    e9a4:	4850      	ldr	r0, [pc, #320]	; (eae8 <_vfiprintf_r+0x1e0>)
    e9a6:	f008 ff0b 	bl	177c0 <memchr>
    e9aa:	9b04      	ldr	r3, [sp, #16]
    e9ac:	bb68      	cbnz	r0, ea0a <_vfiprintf_r+0x102>
    e9ae:	06d8      	lsls	r0, r3, #27
    e9b0:	bf44      	itt	mi
    e9b2:	2220      	movmi	r2, #32
    e9b4:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    e9b8:	0719      	lsls	r1, r3, #28
    e9ba:	bf44      	itt	mi
    e9bc:	222b      	movmi	r2, #43	; 0x2b
    e9be:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    e9c2:	7832      	ldrb	r2, [r6, #0]
    e9c4:	2a2a      	cmp	r2, #42	; 0x2a
    e9c6:	d028      	beq.n	ea1a <_vfiprintf_r+0x112>
    e9c8:	9a07      	ldr	r2, [sp, #28]
    e9ca:	4634      	mov	r4, r6
    e9cc:	2000      	movs	r0, #0
    e9ce:	260a      	movs	r6, #10
    e9d0:	4621      	mov	r1, r4
    e9d2:	f811 3b01 	ldrb.w	r3, [r1], #1
    e9d6:	3b30      	subs	r3, #48	; 0x30
    e9d8:	2b09      	cmp	r3, #9
    e9da:	d960      	bls.n	ea9e <_vfiprintf_r+0x196>
    e9dc:	bb18      	cbnz	r0, ea26 <_vfiprintf_r+0x11e>
    e9de:	e029      	b.n	ea34 <_vfiprintf_r+0x12c>
    e9e0:	4b42      	ldr	r3, [pc, #264]	; (eaec <_vfiprintf_r+0x1e4>)
    e9e2:	429d      	cmp	r5, r3
    e9e4:	d101      	bne.n	e9ea <_vfiprintf_r+0xe2>
    e9e6:	68bd      	ldr	r5, [r7, #8]
    e9e8:	e79e      	b.n	e928 <_vfiprintf_r+0x20>
    e9ea:	4b41      	ldr	r3, [pc, #260]	; (eaf0 <_vfiprintf_r+0x1e8>)
    e9ec:	429d      	cmp	r5, r3
    e9ee:	bf08      	it	eq
    e9f0:	68fd      	ldreq	r5, [r7, #12]
    e9f2:	e799      	b.n	e928 <_vfiprintf_r+0x20>
    e9f4:	4629      	mov	r1, r5
    e9f6:	4638      	mov	r0, r7
    e9f8:	f006 fb12 	bl	15020 <__swsetup_r>
    e9fc:	2800      	cmp	r0, #0
    e9fe:	d099      	beq.n	e934 <_vfiprintf_r+0x2c>
    ea00:	f04f 30ff 	mov.w	r0, #4294967295
    ea04:	b01d      	add	sp, #116	; 0x74
    ea06:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ea0a:	eba0 0009 	sub.w	r0, r0, r9
    ea0e:	fa0b f000 	lsl.w	r0, fp, r0
    ea12:	4318      	orrs	r0, r3
    ea14:	9004      	str	r0, [sp, #16]
    ea16:	4626      	mov	r6, r4
    ea18:	e7c0      	b.n	e99c <_vfiprintf_r+0x94>
    ea1a:	9a03      	ldr	r2, [sp, #12]
    ea1c:	1d11      	adds	r1, r2, #4
    ea1e:	6812      	ldr	r2, [r2, #0]
    ea20:	9103      	str	r1, [sp, #12]
    ea22:	2a00      	cmp	r2, #0
    ea24:	db01      	blt.n	ea2a <_vfiprintf_r+0x122>
    ea26:	9207      	str	r2, [sp, #28]
    ea28:	e004      	b.n	ea34 <_vfiprintf_r+0x12c>
    ea2a:	4252      	negs	r2, r2
    ea2c:	f043 0302 	orr.w	r3, r3, #2
    ea30:	9207      	str	r2, [sp, #28]
    ea32:	9304      	str	r3, [sp, #16]
    ea34:	7823      	ldrb	r3, [r4, #0]
    ea36:	2b2e      	cmp	r3, #46	; 0x2e
    ea38:	d10b      	bne.n	ea52 <_vfiprintf_r+0x14a>
    ea3a:	7863      	ldrb	r3, [r4, #1]
    ea3c:	2b2a      	cmp	r3, #42	; 0x2a
    ea3e:	d133      	bne.n	eaa8 <_vfiprintf_r+0x1a0>
    ea40:	9b03      	ldr	r3, [sp, #12]
    ea42:	1d1a      	adds	r2, r3, #4
    ea44:	681b      	ldr	r3, [r3, #0]
    ea46:	9203      	str	r2, [sp, #12]
    ea48:	2b00      	cmp	r3, #0
    ea4a:	bfb8      	it	lt
    ea4c:	4643      	movlt	r3, r8
    ea4e:	3402      	adds	r4, #2
    ea50:	9305      	str	r3, [sp, #20]
    ea52:	2203      	movs	r2, #3
    ea54:	7821      	ldrb	r1, [r4, #0]
    ea56:	4827      	ldr	r0, [pc, #156]	; (eaf4 <_vfiprintf_r+0x1ec>)
    ea58:	f008 feb2 	bl	177c0 <memchr>
    ea5c:	b140      	cbz	r0, ea70 <_vfiprintf_r+0x168>
    ea5e:	2340      	movs	r3, #64	; 0x40
    ea60:	eba0 000a 	sub.w	r0, r0, sl
    ea64:	fa03 f000 	lsl.w	r0, r3, r0
    ea68:	9b04      	ldr	r3, [sp, #16]
    ea6a:	4303      	orrs	r3, r0
    ea6c:	3401      	adds	r4, #1
    ea6e:	9304      	str	r3, [sp, #16]
    ea70:	f814 1b01 	ldrb.w	r1, [r4], #1
    ea74:	4820      	ldr	r0, [pc, #128]	; (eaf8 <_vfiprintf_r+0x1f0>)
    ea76:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
    ea7a:	2206      	movs	r2, #6
    ea7c:	f008 fea0 	bl	177c0 <memchr>
    ea80:	ab03      	add	r3, sp, #12
    ea82:	9300      	str	r3, [sp, #0]
    ea84:	462a      	mov	r2, r5
    ea86:	4b1d      	ldr	r3, [pc, #116]	; (eafc <_vfiprintf_r+0x1f4>)
    ea88:	a904      	add	r1, sp, #16
    ea8a:	b308      	cbz	r0, ead0 <_vfiprintf_r+0x1c8>
    ea8c:	4638      	mov	r0, r7
    ea8e:	f7f8 fdd3 	bl	7638 <_printf_float>
    ea92:	1c42      	adds	r2, r0, #1
    ea94:	d020      	beq.n	ead8 <_vfiprintf_r+0x1d0>
    ea96:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ea98:	4403      	add	r3, r0
    ea9a:	9309      	str	r3, [sp, #36]	; 0x24
    ea9c:	e759      	b.n	e952 <_vfiprintf_r+0x4a>
    ea9e:	fb06 3202 	mla	r2, r6, r2, r3
    eaa2:	2001      	movs	r0, #1
    eaa4:	460c      	mov	r4, r1
    eaa6:	e793      	b.n	e9d0 <_vfiprintf_r+0xc8>
    eaa8:	2300      	movs	r3, #0
    eaaa:	3401      	adds	r4, #1
    eaac:	9305      	str	r3, [sp, #20]
    eaae:	4619      	mov	r1, r3
    eab0:	260a      	movs	r6, #10
    eab2:	4620      	mov	r0, r4
    eab4:	f810 2b01 	ldrb.w	r2, [r0], #1
    eab8:	3a30      	subs	r2, #48	; 0x30
    eaba:	2a09      	cmp	r2, #9
    eabc:	d903      	bls.n	eac6 <_vfiprintf_r+0x1be>
    eabe:	2b00      	cmp	r3, #0
    eac0:	d0c7      	beq.n	ea52 <_vfiprintf_r+0x14a>
    eac2:	9105      	str	r1, [sp, #20]
    eac4:	e7c5      	b.n	ea52 <_vfiprintf_r+0x14a>
    eac6:	fb06 2101 	mla	r1, r6, r1, r2
    eaca:	2301      	movs	r3, #1
    eacc:	4604      	mov	r4, r0
    eace:	e7f0      	b.n	eab2 <_vfiprintf_r+0x1aa>
    ead0:	4638      	mov	r0, r7
    ead2:	f7ff f8df 	bl	dc94 <_printf_i>
    ead6:	e7dc      	b.n	ea92 <_vfiprintf_r+0x18a>
    ead8:	89ab      	ldrh	r3, [r5, #12]
    eada:	065b      	lsls	r3, r3, #25
    eadc:	d490      	bmi.n	ea00 <_vfiprintf_r+0xf8>
    eade:	9809      	ldr	r0, [sp, #36]	; 0x24
    eae0:	e790      	b.n	ea04 <_vfiprintf_r+0xfc>
    eae2:	bf00      	nop
    eae4:	2000e330 	.word	0x2000e330
    eae8:	000219ea 	.word	0x000219ea
    eaec:	2000e350 	.word	0x2000e350
    eaf0:	2000e310 	.word	0x2000e310
    eaf4:	000219f0 	.word	0x000219f0
    eaf8:	000219f4 	.word	0x000219f4
    eafc:	0001c9bf 	.word	0x0001c9bf

Disassembly of section .text.Lan867x_Miim_Task%236:

0000eb00 <Lan867x_Miim_Task>:
 *
 * Note:
 *****************************************************************************/
static DRV_MIIM_RESULT Lan867x_Miim_Task(LAN867X_REG_OBJ *clientObj, DRV_MIIM_OP_TYPE opType,
                                         uint32_t regAddr, uint16_t *data)
{
    eb00:	b5f0      	push	{r4, r5, r6, r7, lr}
    eb02:	b085      	sub	sp, #20
    eb04:	4604      	mov	r4, r0
    eb06:	460d      	mov	r5, r1
    eb08:	4611      	mov	r1, r2
    uint16_t mmdData = 0;
    DRV_MIIM_RESULT opRes = DRV_MIIM_RES_OK;
    eb0a:	2000      	movs	r0, #0
    eb0c:	f88d 000f 	strb.w	r0, [sp, #15]

    switch (R2F(clientObj->vendorData, VENDOR_INTERNAL_STATE)) {
    eb10:	6860      	ldr	r0, [r4, #4]
    eb12:	0e40      	lsrs	r0, r0, #25
    eb14:	2808      	cmp	r0, #8
    eb16:	f200 80e3 	bhi.w	ece0 <Lan867x_Miim_Task+0x1e0>
    eb1a:	e8df f010 	tbh	[pc, r0, lsl #1]
    eb1e:	0020      	.short	0x0020
    eb20:	00090024 	.word	0x00090024
    eb24:	0050003d 	.word	0x0050003d
    eb28:	0088006c 	.word	0x0088006c
    eb2c:	00c600ab 	.word	0x00c600ab
    case WRITE_22_PHASE: /* Write to clause 22 register. */
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Write(
    eb30:	6925      	ldr	r5, [r4, #16]
    eb32:	68e2      	ldr	r2, [r4, #12]
    eb34:	f10d 000f 	add.w	r0, sp, #15
    eb38:	9001      	str	r0, [sp, #4]
    eb3a:	2001      	movs	r0, #1
    eb3c:	9000      	str	r0, [sp, #0]
    eb3e:	6b16      	ldr	r6, [r2, #48]	; 0x30
    eb40:	881b      	ldrh	r3, [r3, #0]
    eb42:	6822      	ldr	r2, [r4, #0]
    eb44:	68a0      	ldr	r0, [r4, #8]
    eb46:	47b0      	blx	r6
    eb48:	6028      	str	r0, [r5, #0]
            clientObj->miimHandle, regAddr, clientObj->phyAddress, *data,
            DRV_MIIM_OPERATION_FLAG_DISCARD, &opRes);
        /* If success in queuing the request, go to next state, else retry. */
        if (*clientObj->miimOpHandle != 0) {
    eb4a:	6923      	ldr	r3, [r4, #16]
    eb4c:	681b      	ldr	r3, [r3, #0]
    eb4e:	b133      	cbz	r3, eb5e <Lan867x_Miim_Task+0x5e>
            /* Operation successfully completed.*/
            clientObj->vendorData =
                F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
    eb50:	6863      	ldr	r3, [r4, #4]
    eb52:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
            clientObj->vendorData =
    eb56:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_OK;
    eb58:	2300      	movs	r3, #0
    eb5a:	f88d 300f 	strb.w	r3, [sp, #15]
        /* shouldn't happen */
        opRes = DRV_MIIM_RES_OP_INTERNAL_ERR;
        break;
    }
    return opRes;
}
    eb5e:	f99d 000f 	ldrsb.w	r0, [sp, #15]
    eb62:	b005      	add	sp, #20
    eb64:	bdf0      	pop	{r4, r5, r6, r7, pc}
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Read(
    eb66:	6925      	ldr	r5, [r4, #16]
    eb68:	68e3      	ldr	r3, [r4, #12]
    eb6a:	f10d 020f 	add.w	r2, sp, #15
    eb6e:	9200      	str	r2, [sp, #0]
    eb70:	6ade      	ldr	r6, [r3, #44]	; 0x2c
    eb72:	2300      	movs	r3, #0
    eb74:	6822      	ldr	r2, [r4, #0]
    eb76:	68a0      	ldr	r0, [r4, #8]
    eb78:	47b0      	blx	r6
    eb7a:	6028      	str	r0, [r5, #0]
        if (*clientObj->miimOpHandle != 0) {
    eb7c:	6923      	ldr	r3, [r4, #16]
    eb7e:	681b      	ldr	r3, [r3, #0]
    eb80:	2b00      	cmp	r3, #0
    eb82:	d0ec      	beq.n	eb5e <Lan867x_Miim_Task+0x5e>
                F2R(READ_RESULT_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
    eb84:	6863      	ldr	r3, [r4, #4]
    eb86:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    eb8a:	f043 63c0 	orr.w	r3, r3, #100663296	; 0x6000000
            clientObj->vendorData =
    eb8e:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_PENDING;
    eb90:	2301      	movs	r3, #1
    eb92:	f88d 300f 	strb.w	r3, [sp, #15]
    eb96:	e7e2      	b.n	eb5e <Lan867x_Miim_Task+0x5e>
        opRes = clientObj->miimBase->DRV_MIIM_OperationResult(clientObj->miimHandle,
    eb98:	6921      	ldr	r1, [r4, #16]
    eb9a:	68e2      	ldr	r2, [r4, #12]
    eb9c:	6b95      	ldr	r5, [r2, #56]	; 0x38
    eb9e:	461a      	mov	r2, r3
    eba0:	6809      	ldr	r1, [r1, #0]
    eba2:	68a0      	ldr	r0, [r4, #8]
    eba4:	47a8      	blx	r5
    eba6:	f88d 000f 	strb.w	r0, [sp, #15]
        if (opRes != DRV_MIIM_RES_PENDING) /* Check operation is in progress or not. */
    ebaa:	2801      	cmp	r0, #1
    ebac:	d0d7      	beq.n	eb5e <Lan867x_Miim_Task+0x5e>
                F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
    ebae:	6863      	ldr	r3, [r4, #4]
    ebb0:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
            clientObj->vendorData =
    ebb4:	6063      	str	r3, [r4, #4]
            *clientObj->miimOpHandle = 0;
    ebb6:	6923      	ldr	r3, [r4, #16]
    ebb8:	2200      	movs	r2, #0
    ebba:	601a      	str	r2, [r3, #0]
    ebbc:	e7cf      	b.n	eb5e <Lan867x_Miim_Task+0x5e>
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Write(
    ebbe:	6925      	ldr	r5, [r4, #16]
    ebc0:	68e3      	ldr	r3, [r4, #12]
    ebc2:	f10d 020f 	add.w	r2, sp, #15
    ebc6:	9201      	str	r2, [sp, #4]
    ebc8:	2201      	movs	r2, #1
    ebca:	9200      	str	r2, [sp, #0]
    ebcc:	6b1e      	ldr	r6, [r3, #48]	; 0x30
    ebce:	0c0b      	lsrs	r3, r1, #16
    ebd0:	6822      	ldr	r2, [r4, #0]
    ebd2:	210d      	movs	r1, #13
    ebd4:	68a0      	ldr	r0, [r4, #8]
    ebd6:	47b0      	blx	r6
    ebd8:	6028      	str	r0, [r5, #0]
        if (*clientObj->miimOpHandle != 0) {
    ebda:	6923      	ldr	r3, [r4, #16]
    ebdc:	681b      	ldr	r3, [r3, #0]
    ebde:	2b00      	cmp	r3, #0
    ebe0:	d0bd      	beq.n	eb5e <Lan867x_Miim_Task+0x5e>
                F2R(MMD_ADDR_SET_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
    ebe2:	6863      	ldr	r3, [r4, #4]
    ebe4:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    ebe8:	f043 6320 	orr.w	r3, r3, #167772160	; 0xa000000
            clientObj->vendorData =
    ebec:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_PENDING;
    ebee:	2301      	movs	r3, #1
    ebf0:	f88d 300f 	strb.w	r3, [sp, #15]
    ebf4:	e7b3      	b.n	eb5e <Lan867x_Miim_Task+0x5e>
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Write(
    ebf6:	6925      	ldr	r5, [r4, #16]
    ebf8:	68e3      	ldr	r3, [r4, #12]
    ebfa:	f10d 020f 	add.w	r2, sp, #15
    ebfe:	9201      	str	r2, [sp, #4]
    ec00:	2201      	movs	r2, #1
    ec02:	9200      	str	r2, [sp, #0]
    ec04:	6b1e      	ldr	r6, [r3, #48]	; 0x30
    ec06:	b28b      	uxth	r3, r1
    ec08:	6822      	ldr	r2, [r4, #0]
    ec0a:	210e      	movs	r1, #14
    ec0c:	68a0      	ldr	r0, [r4, #8]
    ec0e:	47b0      	blx	r6
    ec10:	6028      	str	r0, [r5, #0]
        if (*clientObj->miimOpHandle != 0) {
    ec12:	6923      	ldr	r3, [r4, #16]
    ec14:	681b      	ldr	r3, [r3, #0]
    ec16:	2b00      	cmp	r3, #0
    ec18:	d0a1      	beq.n	eb5e <Lan867x_Miim_Task+0x5e>
                F2R(MMD_DATA_CONFIG_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
    ec1a:	6863      	ldr	r3, [r4, #4]
    ec1c:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    ec20:	f043 6340 	orr.w	r3, r3, #201326592	; 0xc000000
            clientObj->vendorData =
    ec24:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_PENDING;
    ec26:	2301      	movs	r3, #1
    ec28:	f88d 300f 	strb.w	r3, [sp, #15]
    ec2c:	e797      	b.n	eb5e <Lan867x_Miim_Task+0x5e>
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Write(
    ec2e:	6926      	ldr	r6, [r4, #16]
        mmdData = (F2R_((regAddr >> 16), PHY_MMDCTRL_DEVAD) | F2R_(1, PHY_MMDCTRL_FNCTN));
    ec30:	f3c1 4304 	ubfx	r3, r1, #16, #5
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Write(
    ec34:	68e2      	ldr	r2, [r4, #12]
    ec36:	f10d 010f 	add.w	r1, sp, #15
    ec3a:	9101      	str	r1, [sp, #4]
    ec3c:	2101      	movs	r1, #1
    ec3e:	9100      	str	r1, [sp, #0]
    ec40:	6b17      	ldr	r7, [r2, #48]	; 0x30
    ec42:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    ec46:	6822      	ldr	r2, [r4, #0]
    ec48:	210d      	movs	r1, #13
    ec4a:	68a0      	ldr	r0, [r4, #8]
    ec4c:	47b8      	blx	r7
    ec4e:	6030      	str	r0, [r6, #0]
        if (*clientObj->miimOpHandle != 0) {
    ec50:	6923      	ldr	r3, [r4, #16]
    ec52:	681b      	ldr	r3, [r3, #0]
    ec54:	2b00      	cmp	r3, #0
    ec56:	d082      	beq.n	eb5e <Lan867x_Miim_Task+0x5e>
            if (opType == DRV_MIIM_OP_READ) {
    ec58:	2d01      	cmp	r5, #1
                    F2R(MMD_DATA_READ_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
    ec5a:	6863      	ldr	r3, [r4, #4]
    ec5c:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    ec60:	bf0c      	ite	eq
    ec62:	f043 6360 	orreq.w	r3, r3, #234881024	; 0xe000000
                    F2R(MMD_DATA_WRITE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
    ec66:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
    ec6a:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_PENDING;
    ec6c:	2301      	movs	r3, #1
    ec6e:	f88d 300f 	strb.w	r3, [sp, #15]
    ec72:	e774      	b.n	eb5e <Lan867x_Miim_Task+0x5e>
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Read(
    ec74:	6925      	ldr	r5, [r4, #16]
    ec76:	68e3      	ldr	r3, [r4, #12]
    ec78:	f10d 020f 	add.w	r2, sp, #15
    ec7c:	9200      	str	r2, [sp, #0]
    ec7e:	6ade      	ldr	r6, [r3, #44]	; 0x2c
    ec80:	2300      	movs	r3, #0
    ec82:	6822      	ldr	r2, [r4, #0]
    ec84:	210e      	movs	r1, #14
    ec86:	68a0      	ldr	r0, [r4, #8]
    ec88:	47b0      	blx	r6
    ec8a:	6028      	str	r0, [r5, #0]
        if (*clientObj->miimOpHandle != 0) {
    ec8c:	6923      	ldr	r3, [r4, #16]
    ec8e:	681b      	ldr	r3, [r3, #0]
    ec90:	2b00      	cmp	r3, #0
    ec92:	f43f af64 	beq.w	eb5e <Lan867x_Miim_Task+0x5e>
                F2R(READ_RESULT_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
    ec96:	6863      	ldr	r3, [r4, #4]
    ec98:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
    ec9c:	f043 63c0 	orr.w	r3, r3, #100663296	; 0x6000000
            clientObj->vendorData =
    eca0:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_PENDING;
    eca2:	2301      	movs	r3, #1
    eca4:	f88d 300f 	strb.w	r3, [sp, #15]
    eca8:	e759      	b.n	eb5e <Lan867x_Miim_Task+0x5e>
        *clientObj->miimOpHandle = clientObj->miimBase->DRV_MIIM_Write(
    ecaa:	6925      	ldr	r5, [r4, #16]
    ecac:	68e2      	ldr	r2, [r4, #12]
    ecae:	f10d 010f 	add.w	r1, sp, #15
    ecb2:	9101      	str	r1, [sp, #4]
    ecb4:	2101      	movs	r1, #1
    ecb6:	9100      	str	r1, [sp, #0]
    ecb8:	6b16      	ldr	r6, [r2, #48]	; 0x30
    ecba:	881b      	ldrh	r3, [r3, #0]
    ecbc:	6822      	ldr	r2, [r4, #0]
    ecbe:	210e      	movs	r1, #14
    ecc0:	68a0      	ldr	r0, [r4, #8]
    ecc2:	47b0      	blx	r6
    ecc4:	6028      	str	r0, [r5, #0]
        if (*clientObj->miimOpHandle != 0) {
    ecc6:	6923      	ldr	r3, [r4, #16]
    ecc8:	681b      	ldr	r3, [r3, #0]
    ecca:	2b00      	cmp	r3, #0
    eccc:	f43f af47 	beq.w	eb5e <Lan867x_Miim_Task+0x5e>
                F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
    ecd0:	6863      	ldr	r3, [r4, #4]
    ecd2:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
            clientObj->vendorData =
    ecd6:	6063      	str	r3, [r4, #4]
            opRes = DRV_MIIM_RES_OK;
    ecd8:	2300      	movs	r3, #0
    ecda:	f88d 300f 	strb.w	r3, [sp, #15]
    ecde:	e73e      	b.n	eb5e <Lan867x_Miim_Task+0x5e>
        opRes = DRV_MIIM_RES_OP_INTERNAL_ERR;
    ece0:	23ec      	movs	r3, #236	; 0xec
    ece2:	f88d 300f 	strb.w	r3, [sp, #15]
        break;
    ece6:	e73a      	b.n	eb5e <Lan867x_Miim_Task+0x5e>

Disassembly of section .text.TCPIP_ICMP_Task%237:

0000ece8 <TCPIP_ICMP_Task>:


#endif

void  TCPIP_ICMP_Task(void)
{
    ece8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ecec:	b093      	sub	sp, #76	; 0x4c
    TCPIP_MODULE_SIGNAL sigPend;

    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
    ecee:	210f      	movs	r1, #15
    ecf0:	2006      	movs	r0, #6
    ecf2:	f00f f93b 	bl	1df6c <_TCPIPStackModuleSignalGet>
    ecf6:	4606      	mov	r6, r0

    if((sigPend & TCPIP_MODULE_SIGNAL_RX_PENDING) != 0)
    ecf8:	f010 0f01 	tst.w	r0, #1
    ecfc:	d106      	bne.n	ed0c <TCPIP_ICMP_Task+0x24>
    { //  RX signal occurred
        TCPIP_ICMP_Process();
    }

#if defined(TCPIP_STACK_USE_ICMP_CLIENT)
    if((sigPend & TCPIP_MODULE_SIGNAL_TMO) != 0)
    ecfe:	f016 0f02 	tst.w	r6, #2
    ed02:	f040 80ac 	bne.w	ee5e <TCPIP_ICMP_Task+0x176>
    { // regular TMO occurred
        TCPIP_ICMP_Timeout();
    }
#endif  // defined(TCPIP_STACK_USE_ICMP_CLIENT)

}
    ed06:	b013      	add	sp, #76	; 0x4c
    ed08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    TCPIP_MAC_PKT_ACK_RES   ackRes;



    // extract queued ICMP packets
    while((pRxPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
    ed0c:	2706      	movs	r7, #6

#if defined(TCPIP_STACK_USE_ICMP_CLIENT)
            if(pRxHdr->vType == ICMP_TYPE_ECHO_REPLY && pRxHdr->vCode == ICMP_CODE_ECHO_REPLY)
            {   // echo reply; check if our own
                // Get the sequence number and identifier fields
                if(pIcmpEchoRequest != 0)
    ed0e:	f8df 91ac 	ldr.w	r9, [pc, #428]	; eebc <TCPIP_ICMP_Task+0x1d4>
    TCPIP_Helper_ProtectedSingleListLock(notifyList);
    ed12:	f8df a1b4 	ldr.w	sl, [pc, #436]	; eec8 <TCPIP_ICMP_Task+0x1e0>
    ed16:	e077      	b.n	ee08 <TCPIP_ICMP_Task+0x120>
                if(TCPIP_STACK_IsBcastAddress((TCPIP_NET_IF*)pRxPkt->pktIf, &pIpv4Header->DestAddress))
    ed18:	f108 0110 	add.w	r1, r8, #16
    ed1c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    ed1e:	f010 fd35 	bl	1f78c <TCPIP_STACK_IsBcastAddress>
    ed22:	b110      	cbz	r0, ed2a <TCPIP_ICMP_Task+0x42>
                    ackRes = TCPIP_MAC_PKT_ACK_PROTO_DEST_ERR;  // ignore request
    ed24:	f06f 010e 	mvn.w	r1, #14
    ed28:	e06a      	b.n	ee00 <TCPIP_ICMP_Task+0x118>
                _ICMPProcessEchoRequest((TCPIP_NET_IF*)pRxPkt->pktIf, pRxPkt, pIpv4Header->DestAddress.Val, srcAdd);
    ed2a:	6aa5      	ldr	r5, [r4, #40]	; 0x28
    TCPIP_UINT16_VAL checksum;
    IPV4_PACKET ipv4Pkt;
    IPV4_HEADER* pIpv4Hdr;

    // adjust the checksum
    pTxHdr = (ICMP_PACKET*)pRxPkt->pTransportLayer;
    ed2c:	69e2      	ldr	r2, [r4, #28]

    pTxHdr->vType = ICMP_TYPE_ECHO_REPLY;
    ed2e:	2300      	movs	r3, #0
    ed30:	7013      	strb	r3, [r2, #0]
    pTxHdr->vCode = ICMP_CODE_ECHO_REPLY;
    ed32:	7053      	strb	r3, [r2, #1]
    checksum.Val = pTxHdr->wChecksum;
    ed34:	8853      	ldrh	r3, [r2, #2]
    ed36:	4618      	mov	r0, r3
    checksum.v[0] += 8;	// Subtract 0x0800 from the checksum
    ed38:	fa5f fc83 	uxtb.w	ip, r3
    ed3c:	f10c 0108 	add.w	r1, ip, #8
    ed40:	b2c9      	uxtb	r1, r1
    ed42:	f361 0007 	bfi	r0, r1, #0, #8
    if(checksum.v[0] < 8u)
    ed46:	2907      	cmp	r1, #7
    ed48:	d80a      	bhi.n	ed60 <TCPIP_ICMP_Task+0x78>
    {
        checksum.v[1]++;
    ed4a:	f3c3 2307 	ubfx	r3, r3, #8, #8
    ed4e:	3301      	adds	r3, #1
    ed50:	b2db      	uxtb	r3, r3
    ed52:	f363 200f 	bfi	r0, r3, #8, #8
        if(checksum.v[1] == 0u)
    ed56:	b91b      	cbnz	r3, ed60 <TCPIP_ICMP_Task+0x78>
        {
            checksum.v[0]++;
    ed58:	f10c 0c09 	add.w	ip, ip, #9
    ed5c:	f36c 0007 	bfi	r0, ip, #0, #8
        }
    }

    pTxHdr->wChecksum = checksum.Val;
    ed60:	8050      	strh	r0, [r2, #2]
    pRxPkt->next = 0; // single packet
    ed62:	f04f 0800 	mov.w	r8, #0
    ed66:	f8c4 8000 	str.w	r8, [r4]
            TCPIP_PKT_PacketAcknowledge(pFragPkt, TCPIP_MAC_PKT_ACK_MAC_REJECT_ERR);
        }
        return false;
    }
#else
    TCPIP_IPV4_MacPacketSwitchTxToRx(pRxPkt, true, false); 
    ed6a:	4642      	mov	r2, r8
    ed6c:	2101      	movs	r1, #1
    ed6e:	4620      	mov	r0, r4
    ed70:	f009 feec 	bl	18b4c <TCPIP_IPV4_MacPacketSwitchTxToRx>

    // set proper address fields
    pIpv4Hdr = (IPV4_HEADER*)pRxPkt->pNetLayer;
    ed74:	69a3      	ldr	r3, [r4, #24]
    ipv4Pkt.srcAddress.Val = pIpv4Hdr->SourceAddress.Val;
    ed76:	68da      	ldr	r2, [r3, #12]
    ed78:	920e      	str	r2, [sp, #56]	; 0x38
    ipv4Pkt.destAddress.Val = pIpv4Hdr->DestAddress.Val;
    ed7a:	691b      	ldr	r3, [r3, #16]
    ed7c:	930f      	str	r3, [sp, #60]	; 0x3c
    ipv4Pkt.netIfH = pNetIf;
    ed7e:	9510      	str	r5, [sp, #64]	; 0x40
    
    TCPIP_PKT_FlightLogTx(pRxPkt, TCPIP_THIS_MODULE_ID);
    if(!TCPIP_IPV4_PktTx(&ipv4Pkt, pRxPkt, false))
    ed80:	4642      	mov	r2, r8
    ed82:	4621      	mov	r1, r4
    ed84:	a801      	add	r0, sp, #4
    ed86:	f7ff f9a9 	bl	e0dc <TCPIP_IPV4_PktTx>
    ed8a:	2800      	cmp	r0, #0
    ed8c:	d13c      	bne.n	ee08 <TCPIP_ICMP_Task+0x120>
    {
        TCPIP_PKT_PacketAcknowledge(pRxPkt, TCPIP_MAC_PKT_ACK_MAC_REJECT_ERR);
    ed8e:	463a      	mov	r2, r7
    ed90:	f06f 0105 	mvn.w	r1, #5
    ed94:	4620      	mov	r0, r4
    ed96:	f00e fdfd 	bl	1d994 <_TCPIP_PKT_PacketAcknowledge>
        return false;
    ed9a:	e035      	b.n	ee08 <TCPIP_ICMP_Task+0x120>
                    if(pIcmpEchoRequest->identifier == pRxHdr->wIdentifier && pIcmpEchoRequest->sequenceNumber == pRxHdr->wSequenceNumber)
    ed9c:	8902      	ldrh	r2, [r0, #8]
    ed9e:	88eb      	ldrh	r3, [r5, #6]
    eda0:	429a      	cmp	r2, r3
    eda2:	d002      	beq.n	edaa <TCPIP_ICMP_Task+0xc2>
            ackRes = TCPIP_MAC_PKT_ACK_TYPE_ERR;
    eda4:	f06f 010c 	mvn.w	r1, #12
    eda8:	e02a      	b.n	ee00 <TCPIP_ICMP_Task+0x118>
                        if(pIcmpEchoRequest->callback)
    edaa:	6943      	ldr	r3, [r0, #20]
    edac:	b123      	cbz	r3, edb8 <TCPIP_ICMP_Task+0xd0>
                            pIcmpEchoRequest->targetAddr.Val = srcAdd; 
    edae:	f8c0 b004 	str.w	fp, [r0, #4]
                            (*pIcmpEchoRequest->callback)(pIcmpEchoRequest, pIcmpEchoRequest, TCPIP_ICMP_ECHO_REQUEST_RES_OK);
    edb2:	2200      	movs	r2, #0
    edb4:	4601      	mov	r1, r0
    edb6:	4798      	blx	r3
                        pIcmpEchoRequest = 0;    // free
    edb8:	2300      	movs	r3, #0
    edba:	f8c9 3000 	str.w	r3, [r9]
                        ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    edbe:	2102      	movs	r1, #2
    edc0:	e01e      	b.n	ee00 <TCPIP_ICMP_Task+0x118>
                    userData.w[0] = pRxHdr->wIdentifier;
    edc2:	88ab      	ldrh	r3, [r5, #4]
    edc4:	f8ad 3000 	strh.w	r3, [sp]
                    userData.w[1] = pRxHdr->wSequenceNumber;
    edc8:	88eb      	ldrh	r3, [r5, #6]
    edca:	f8ad 3002 	strh.w	r3, [sp, #2]
                    remoteIPAddr.Val = srcAdd;
    edce:	f8cd b004 	str.w	fp, [sp, #4]
                    _ICMPNotifyClients((TCPIP_NET_IF*)pRxPkt->pktIf, &remoteIPAddr, (void *)userData.v);
    edd2:	f8d4 8028 	ldr.w	r8, [r4, #40]	; 0x28
    edd6:	4650      	mov	r0, sl
    edd8:	f011 fdca 	bl	20970 <TCPIP_Helper_ProtectedSingleListLock>
static void _ICMPNotifyClients(TCPIP_NET_HANDLE hNetIf, IPV4_ADDR * remoteIP, void * data)
{
    ICMP_LIST_NODE* dNode;

    TCPIP_Notification_Lock(&icmpRegisteredUsers);
    for(dNode = (ICMP_LIST_NODE*)icmpRegisteredUsers.list.head; dNode != 0; dNode = dNode->next)
    eddc:	f8da 5000 	ldr.w	r5, [sl]
    ede0:	b13d      	cbz	r5, edf2 <TCPIP_ICMP_Task+0x10a>
    {
        (*dNode->callback)(hNetIf, remoteIP, data);
    ede2:	686b      	ldr	r3, [r5, #4]
    ede4:	466a      	mov	r2, sp
    ede6:	a901      	add	r1, sp, #4
    ede8:	4640      	mov	r0, r8
    edea:	4798      	blx	r3
    for(dNode = (ICMP_LIST_NODE*)icmpRegisteredUsers.list.head; dNode != 0; dNode = dNode->next)
    edec:	682d      	ldr	r5, [r5, #0]
    edee:	2d00      	cmp	r5, #0
    edf0:	d1f7      	bne.n	ede2 <TCPIP_ICMP_Task+0xfa>
    TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
    edf2:	4650      	mov	r0, sl
    edf4:	f012 f80e 	bl	20e14 <TCPIP_Helper_ProtectedSingleListUnlock>
                    ackRes = TCPIP_MAC_PKT_ACK_RX_OK;
    edf8:	2102      	movs	r1, #2
    edfa:	e001      	b.n	ee00 <TCPIP_ICMP_Task+0x118>
                ackRes = TCPIP_MAC_PKT_ACK_STRUCT_ERR;
    edfc:	f06f 010d 	mvn.w	r1, #13
    TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
    ee00:	463a      	mov	r2, r7
    ee02:	4620      	mov	r0, r4
    ee04:	f00e fdc6 	bl	1d994 <_TCPIP_PKT_PacketAcknowledge>
    while((pRxPkt = _TCPIPStackModuleRxExtract(TCPIP_THIS_MODULE_ID)) != 0)
    ee08:	4638      	mov	r0, r7
    ee0a:	f010 fcd5 	bl	1f7b8 <_TCPIPStackModuleRxExtract>
    ee0e:	4604      	mov	r4, r0
    ee10:	2800      	cmp	r0, #0
    ee12:	f43f af74 	beq.w	ecfe <TCPIP_ICMP_Task+0x16>
            icmpTotLength = pRxPkt->totTransportLen;    // length of the 1st segment (if fragmented)
    ee16:	8c22      	ldrh	r2, [r4, #32]
            if(icmpTotLength < sizeof(*pRxHdr))
    ee18:	2a07      	cmp	r2, #7
    ee1a:	d9ef      	bls.n	edfc <TCPIP_ICMP_Task+0x114>
        pRxHdr = (ICMP_PACKET*)pRxPkt->pTransportLayer;
    ee1c:	69e5      	ldr	r5, [r4, #28]
        pIpv4Header = (IPV4_HEADER*)pRxPkt->pNetLayer;
    ee1e:	f8d4 8018 	ldr.w	r8, [r4, #24]
        srcAdd =  pIpv4Header->SourceAddress.Val;
    ee22:	f8d8 b00c 	ldr.w	fp, [r8, #12]
            checksum = TCPIP_Helper_PacketChecksum(pRxPkt, (uint8_t*)pRxHdr, icmpTotLength, 0);
    ee26:	2300      	movs	r3, #0
    ee28:	4629      	mov	r1, r5
    ee2a:	4620      	mov	r0, r4
    ee2c:	f00a f818 	bl	18e60 <TCPIP_Helper_PacketChecksum>
            if(checksum != 0)
    ee30:	b978      	cbnz	r0, ee52 <TCPIP_ICMP_Task+0x16a>
            if(pRxHdr->vType == ICMP_TYPE_ECHO_REQUEST && pRxHdr->vCode == ICMP_CODE_ECHO_REQUEST)
    ee32:	882b      	ldrh	r3, [r5, #0]
    ee34:	2b08      	cmp	r3, #8
    ee36:	f43f af6f 	beq.w	ed18 <TCPIP_ICMP_Task+0x30>
            if(pRxHdr->vType == ICMP_TYPE_ECHO_REPLY && pRxHdr->vCode == ICMP_CODE_ECHO_REPLY)
    ee3a:	b96b      	cbnz	r3, ee58 <TCPIP_ICMP_Task+0x170>
                if(pIcmpEchoRequest != 0)
    ee3c:	f8d9 0000 	ldr.w	r0, [r9]
    ee40:	2800      	cmp	r0, #0
    ee42:	d0be      	beq.n	edc2 <TCPIP_ICMP_Task+0xda>
                    if(pIcmpEchoRequest->identifier == pRxHdr->wIdentifier && pIcmpEchoRequest->sequenceNumber == pRxHdr->wSequenceNumber)
    ee44:	8942      	ldrh	r2, [r0, #10]
    ee46:	88ab      	ldrh	r3, [r5, #4]
    ee48:	429a      	cmp	r2, r3
    ee4a:	d0a7      	beq.n	ed9c <TCPIP_ICMP_Task+0xb4>
            ackRes = TCPIP_MAC_PKT_ACK_TYPE_ERR;
    ee4c:	f06f 010c 	mvn.w	r1, #12
    ee50:	e7d6      	b.n	ee00 <TCPIP_ICMP_Task+0x118>
                ackRes = TCPIP_MAC_PKT_ACK_CHKSUM_ERR;
    ee52:	f06f 0109 	mvn.w	r1, #9
    ee56:	e7d3      	b.n	ee00 <TCPIP_ICMP_Task+0x118>
            ackRes = TCPIP_MAC_PKT_ACK_TYPE_ERR;
    ee58:	f06f 010c 	mvn.w	r1, #12
    ee5c:	e7d0      	b.n	ee00 <TCPIP_ICMP_Task+0x118>
    if(icmpEchoTmo == 0)
    ee5e:	4b16      	ldr	r3, [pc, #88]	; (eeb8 <TCPIP_ICMP_Task+0x1d0>)
    ee60:	681b      	ldr	r3, [r3, #0]
    ee62:	b1d3      	cbz	r3, ee9a <TCPIP_ICMP_Task+0x1b2>
    if(pIcmpEchoRequest != 0)
    ee64:	4b15      	ldr	r3, [pc, #84]	; (eebc <TCPIP_ICMP_Task+0x1d4>)
    ee66:	681b      	ldr	r3, [r3, #0]
    ee68:	2b00      	cmp	r3, #0
    ee6a:	f43f af4c 	beq.w	ed06 <TCPIP_ICMP_Task+0x1e>
        if((SYS_TMR_TickCountGet() - icmpEchoStart) >= icmpEchoTmo) 
    ee6e:	f011 f89d 	bl	1ffac <SYS_TMR_TickCountGet>
    ee72:	4b13      	ldr	r3, [pc, #76]	; (eec0 <TCPIP_ICMP_Task+0x1d8>)
    ee74:	681b      	ldr	r3, [r3, #0]
    ee76:	1ac0      	subs	r0, r0, r3
    ee78:	4b0f      	ldr	r3, [pc, #60]	; (eeb8 <TCPIP_ICMP_Task+0x1d0>)
    ee7a:	681b      	ldr	r3, [r3, #0]
    ee7c:	4298      	cmp	r0, r3
    ee7e:	f4ff af42 	bcc.w	ed06 <TCPIP_ICMP_Task+0x1e>
            if(pIcmpEchoRequest->callback)
    ee82:	4b0e      	ldr	r3, [pc, #56]	; (eebc <TCPIP_ICMP_Task+0x1d4>)
    ee84:	6818      	ldr	r0, [r3, #0]
    ee86:	6943      	ldr	r3, [r0, #20]
    ee88:	b11b      	cbz	r3, ee92 <TCPIP_ICMP_Task+0x1aa>
                (*pIcmpEchoRequest->callback)(pIcmpEchoRequest, pIcmpEchoRequest, TCPIP_ICMP_ECHO_REQUEST_RES_TMO);
    ee8a:	f04f 32ff 	mov.w	r2, #4294967295
    ee8e:	4601      	mov	r1, r0
    ee90:	4798      	blx	r3
            pIcmpEchoRequest = 0;    // free
    ee92:	4b0a      	ldr	r3, [pc, #40]	; (eebc <TCPIP_ICMP_Task+0x1d4>)
    ee94:	2200      	movs	r2, #0
    ee96:	601a      	str	r2, [r3, #0]
}
    ee98:	e735      	b.n	ed06 <TCPIP_ICMP_Task+0x1e>
        icmpEchoTmo = (TCPIP_ICMP_ECHO_REQUEST_TIMEOUT * SYS_TMR_TickCounterFrequencyGet() + 999) / 1000;
    ee9a:	f011 f8af 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
    ee9e:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
    eea2:	fb03 f300 	mul.w	r3, r3, r0
    eea6:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
    eeaa:	4806      	ldr	r0, [pc, #24]	; (eec4 <TCPIP_ICMP_Task+0x1dc>)
    eeac:	fba0 2303 	umull	r2, r3, r0, r3
    eeb0:	099b      	lsrs	r3, r3, #6
    eeb2:	4a01      	ldr	r2, [pc, #4]	; (eeb8 <TCPIP_ICMP_Task+0x1d0>)
    eeb4:	6013      	str	r3, [r2, #0]
    eeb6:	e7d5      	b.n	ee64 <TCPIP_ICMP_Task+0x17c>
    eeb8:	2000e580 	.word	0x2000e580
    eebc:	2000e58c 	.word	0x2000e58c
    eec0:	2000e57c 	.word	0x2000e57c
    eec4:	10624dd3 	.word	0x10624dd3
    eec8:	2000e414 	.word	0x2000e414

Disassembly of section .text.TCPIP_ARP_Initialize%238:

0000eecc <TCPIP_ARP_Initialize>:
{
    eecc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    eed0:	b083      	sub	sp, #12
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_UP)
    eed2:	7f03      	ldrb	r3, [r0, #28]
    eed4:	2b03      	cmp	r3, #3
    eed6:	d03e      	beq.n	ef56 <TCPIP_ARP_Initialize+0x8a>
    eed8:	4681      	mov	r9, r0
    eeda:	460d      	mov	r5, r1
    if(arpMod.initCount == 0)
    eedc:	4b6d      	ldr	r3, [pc, #436]	; (f094 <TCPIP_ARP_Initialize+0x1c8>)
    eede:	f8d3 800c 	ldr.w	r8, [r3, #12]
    eee2:	f1b8 0f00 	cmp.w	r8, #0
    eee6:	d123      	bne.n	ef30 <TCPIP_ARP_Initialize+0x64>
        if(arpData == 0)
    eee8:	2900      	cmp	r1, #0
    eeea:	f000 80cf 	beq.w	f08c <TCPIP_ARP_Initialize+0x1c0>
        arpMod.deleteOld = arpData->deleteOld;
    eeee:	790a      	ldrb	r2, [r1, #4]
    eef0:	741a      	strb	r2, [r3, #16]
        nArpIfs = stackCtrl->nIfs;
    eef2:	6804      	ldr	r4, [r0, #0]
        if(arpMod.arpCacheDcpt != 0 && (arpData->deleteOld || arpMod.nIfs != nArpIfs))
    eef4:	685b      	ldr	r3, [r3, #4]
    eef6:	b133      	cbz	r3, ef06 <TCPIP_ARP_Initialize+0x3a>
    eef8:	b91a      	cbnz	r2, ef02 <TCPIP_ARP_Initialize+0x36>
    eefa:	4b66      	ldr	r3, [pc, #408]	; (f094 <TCPIP_ARP_Initialize+0x1c8>)
    eefc:	681b      	ldr	r3, [r3, #0]
    eefe:	42a3      	cmp	r3, r4
    ef00:	d001      	beq.n	ef06 <TCPIP_ARP_Initialize+0x3a>
            _ARPDeleteResources();
    ef02:	f008 fb6d 	bl	175e0 <_ARPDeleteResources>
        arpMod.memH = stackCtrl->memH;
    ef06:	f8d9 000c 	ldr.w	r0, [r9, #12]
    ef0a:	4b62      	ldr	r3, [pc, #392]	; (f094 <TCPIP_ARP_Initialize+0x1c8>)
    ef0c:	6098      	str	r0, [r3, #8]
        arpMod.nIfs =  nArpIfs;
    ef0e:	601c      	str	r4, [r3, #0]
        arpMod.entrySolvedTmo = arpData->entrySolvedTmo;
    ef10:	68aa      	ldr	r2, [r5, #8]
    ef12:	635a      	str	r2, [r3, #52]	; 0x34
        arpMod.entryPendingTmo = arpData->entryPendingTmo;
    ef14:	68ea      	ldr	r2, [r5, #12]
    ef16:	639a      	str	r2, [r3, #56]	; 0x38
        arpMod.entryRetryTmo = arpData->entryRetryTmo;
    ef18:	692a      	ldr	r2, [r5, #16]
    ef1a:	63da      	str	r2, [r3, #60]	; 0x3c
        arpMod.permQuota = arpData->permQuota;
    ef1c:	696a      	ldr	r2, [r5, #20]
    ef1e:	641a      	str	r2, [r3, #64]	; 0x40
        arpMod.entryRetries = arpData->retries;
    ef20:	6a2a      	ldr	r2, [r5, #32]
    ef22:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
        arpMod.entryGratRetries =  arpData->gratProbeCount;
    ef26:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    ef28:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
        if(arpMod.arpCacheDcpt == 0)
    ef2c:	685b      	ldr	r3, [r3, #4]
    ef2e:	b313      	cbz	r3, ef76 <TCPIP_ARP_Initialize+0xaa>
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
    ef30:	4c58      	ldr	r4, [pc, #352]	; (f094 <TCPIP_ARP_Initialize+0x1c8>)
    ef32:	6865      	ldr	r5, [r4, #4]
    ef34:	f8d9 0014 	ldr.w	r0, [r9, #20]
    ef38:	f012 fe6c 	bl	21c14 <TCPIP_STACK_NetIxGet>
    if(arpMod.deleteOld)
    ef3c:	7c23      	ldrb	r3, [r4, #16]
    ef3e:	2b00      	cmp	r3, #0
    ef40:	f040 809d 	bne.w	f07e <TCPIP_ARP_Initialize+0x1b2>
    arpMod.initCount++;
    ef44:	4a53      	ldr	r2, [pc, #332]	; (f094 <TCPIP_ARP_Initialize+0x1c8>)
    ef46:	68d3      	ldr	r3, [r2, #12]
    ef48:	3301      	adds	r3, #1
    ef4a:	60d3      	str	r3, [r2, #12]
    return true;
    ef4c:	2401      	movs	r4, #1
}
    ef4e:	4620      	mov	r0, r4
    ef50:	b003      	add	sp, #12
    ef52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(arpMod.deleteOld)
    ef56:	4b4f      	ldr	r3, [pc, #316]	; (f094 <TCPIP_ARP_Initialize+0x1c8>)
    ef58:	7c1c      	ldrb	r4, [r3, #16]
    ef5a:	b90c      	cbnz	r4, ef60 <TCPIP_ARP_Initialize+0x94>
        return true;
    ef5c:	2401      	movs	r4, #1
    ef5e:	e7f6      	b.n	ef4e <TCPIP_ARP_Initialize+0x82>
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
    ef60:	685d      	ldr	r5, [r3, #4]
    ef62:	6940      	ldr	r0, [r0, #20]
    ef64:	f012 fe56 	bl	21c14 <TCPIP_STACK_NetIxGet>
    ef68:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
            _ARPRemoveCacheEntries(pArpDcpt);
    ef6c:	eb05 00c0 	add.w	r0, r5, r0, lsl #3
    ef70:	f010 fec8 	bl	1fd04 <_ARPRemoveCacheEntries>
    ef74:	e7eb      	b.n	ef4e <TCPIP_ARP_Initialize+0x82>
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Calloc)(h, nElems, elemSize);
    ef76:	6883      	ldr	r3, [r0, #8]
    ef78:	2248      	movs	r2, #72	; 0x48
    ef7a:	4621      	mov	r1, r4
    ef7c:	4798      	blx	r3
            arpMod.arpCacheDcpt = (ARP_CACHE_DCPT*)TCPIP_HEAP_Calloc(arpMod.memH, arpMod.nIfs, sizeof(*arpMod.arpCacheDcpt)); 
    ef7e:	4b45      	ldr	r3, [pc, #276]	; (f094 <TCPIP_ARP_Initialize+0x1c8>)
    ef80:	6058      	str	r0, [r3, #4]
            if(arpMod.arpCacheDcpt == 0)
    ef82:	2800      	cmp	r0, #0
    ef84:	f000 8084 	beq.w	f090 <TCPIP_ARP_Initialize+0x1c4>
            hashMemSize = sizeof(OA_HASH_DCPT) + arpData->cacheEntries * sizeof(ARP_HASH_ENTRY);
    ef88:	682b      	ldr	r3, [r5, #0]
    ef8a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    ef8e:	00db      	lsls	r3, r3, #3
    ef90:	3328      	adds	r3, #40	; 0x28
    ef92:	9301      	str	r3, [sp, #4]
            for(ix = 0, pArpDcpt = arpMod.arpCacheDcpt; ix < arpMod.nIfs; ix++, pArpDcpt++)
    ef94:	4b3f      	ldr	r3, [pc, #252]	; (f094 <TCPIP_ARP_Initialize+0x1c8>)
    ef96:	681b      	ldr	r3, [r3, #0]
    ef98:	2b00      	cmp	r3, #0
    ef9a:	dd53      	ble.n	f044 <TCPIP_ARP_Initialize+0x178>
    ef9c:	f100 062c 	add.w	r6, r0, #44	; 0x2c
                hashDcpt = (OA_HASH_DCPT*)TCPIP_HEAP_Malloc(arpMod.memH, hashMemSize);
    efa0:	f8df a0f0 	ldr.w	sl, [pc, #240]	; f094 <TCPIP_ARP_Initialize+0x1c8>
                pArpDcpt->purgeThres = (arpData->purgeThres * pArpDcpt->hashDcpt->hEntries + 99)/100;
    efa4:	f8df b104 	ldr.w	fp, [pc, #260]	; f0ac <TCPIP_ARP_Initialize+0x1e0>
    efa8:	e022      	b.n	eff0 <TCPIP_ARP_Initialize+0x124>
                    _ARPDeleteResources();
    efaa:	f008 fb19 	bl	175e0 <_ARPDeleteResources>
                    return false;
    efae:	2400      	movs	r4, #0
    efb0:	e7cd      	b.n	ef4e <TCPIP_ARP_Initialize+0x82>
                    if((iniRes = TCPIP_Helper_ProtectedSingleListInitialize(&pArpDcpt->completeList)) == false)
    efb2:	f1a6 0014 	sub.w	r0, r6, #20
    efb6:	f011 fb66 	bl	20686 <TCPIP_Helper_ProtectedSingleListInitialize>
    efba:	2800      	cmp	r0, #0
    efbc:	d03e      	beq.n	f03c <TCPIP_ARP_Initialize+0x170>
                    iniRes = TCPIP_Helper_ProtectedSingleListInitialize(&pArpDcpt->incompleteList);
    efbe:	4630      	mov	r0, r6
    efc0:	f011 fb61 	bl	20686 <TCPIP_Helper_ProtectedSingleListInitialize>
                if(iniRes == false)
    efc4:	2800      	cmp	r0, #0
    efc6:	d039      	beq.n	f03c <TCPIP_ARP_Initialize+0x170>
                pArpDcpt->purgeThres = (arpData->purgeThres * pArpDcpt->hashDcpt->hEntries + 99)/100;
    efc8:	f856 3c2c 	ldr.w	r3, [r6, #-44]
    efcc:	68da      	ldr	r2, [r3, #12]
    efce:	69ab      	ldr	r3, [r5, #24]
    efd0:	fb03 f302 	mul.w	r3, r3, r2
    efd4:	3363      	adds	r3, #99	; 0x63
    efd6:	fbab 2303 	umull	r2, r3, fp, r3
    efda:	095b      	lsrs	r3, r3, #5
    efdc:	6173      	str	r3, [r6, #20]
                pArpDcpt->purgeQuanta = arpData->purgeQuanta;
    efde:	69eb      	ldr	r3, [r5, #28]
    efe0:	61b3      	str	r3, [r6, #24]
            for(ix = 0, pArpDcpt = arpMod.arpCacheDcpt; ix < arpMod.nIfs; ix++, pArpDcpt++)
    efe2:	f108 0801 	add.w	r8, r8, #1
    efe6:	3648      	adds	r6, #72	; 0x48
    efe8:	f8da 3000 	ldr.w	r3, [sl]
    efec:	4543      	cmp	r3, r8
    efee:	dd29      	ble.n	f044 <TCPIP_ARP_Initialize+0x178>
    eff0:	f1a6 072c 	sub.w	r7, r6, #44	; 0x2c
                hashDcpt = (OA_HASH_DCPT*)TCPIP_HEAP_Malloc(arpMod.memH, hashMemSize);
    eff4:	f8da 0008 	ldr.w	r0, [sl, #8]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
    eff8:	6843      	ldr	r3, [r0, #4]
    effa:	9901      	ldr	r1, [sp, #4]
    effc:	4798      	blx	r3
                if(hashDcpt == 0)
    effe:	4604      	mov	r4, r0
    f000:	2800      	cmp	r0, #0
    f002:	d0d2      	beq.n	efaa <TCPIP_ARP_Initialize+0xde>
                hashDcpt->memBlk = hashDcpt + 1;
    f004:	f100 0328 	add.w	r3, r0, #40	; 0x28
    f008:	6003      	str	r3, [r0, #0]
                hashDcpt->hParam = pArpDcpt;    // store the descriptor it belongs to
    f00a:	6047      	str	r7, [r0, #4]
                hashDcpt->hEntrySize = sizeof(ARP_HASH_ENTRY);
    f00c:	2318      	movs	r3, #24
    f00e:	6083      	str	r3, [r0, #8]
                hashDcpt->hEntries = arpData->cacheEntries;
    f010:	682b      	ldr	r3, [r5, #0]
    f012:	60c3      	str	r3, [r0, #12]
                hashDcpt->probeStep = ARP_HASH_PROBE_STEP;
    f014:	2301      	movs	r3, #1
    f016:	6103      	str	r3, [r0, #16]
                hashDcpt->hashF = TCPIP_ARP_HashKeyHash;
    f018:	4b1f      	ldr	r3, [pc, #124]	; (f098 <TCPIP_ARP_Initialize+0x1cc>)
    f01a:	6143      	str	r3, [r0, #20]
                hashDcpt->delF = TCPIP_ARP_HashEntryDelete;
    f01c:	4b1f      	ldr	r3, [pc, #124]	; (f09c <TCPIP_ARP_Initialize+0x1d0>)
    f01e:	6183      	str	r3, [r0, #24]
                hashDcpt->cmpF = TCPIP_ARP_HashKeyCompare;
    f020:	4b1f      	ldr	r3, [pc, #124]	; (f0a0 <TCPIP_ARP_Initialize+0x1d4>)
    f022:	61c3      	str	r3, [r0, #28]
                hashDcpt->cpyF = TCPIP_ARP_HashKeyCopy; 
    f024:	4b1f      	ldr	r3, [pc, #124]	; (f0a4 <TCPIP_ARP_Initialize+0x1d8>)
    f026:	6203      	str	r3, [r0, #32]
                TCPIP_OAHASH_Initialize(hashDcpt);
    f028:	f011 f8c1 	bl	201ae <TCPIP_OAHASH_Initialize>
                pArpDcpt->hashDcpt = hashDcpt;
    f02c:	f846 4c2c 	str.w	r4, [r6, #-44]
                    if((iniRes = TCPIP_Helper_ProtectedSingleListInitialize(&pArpDcpt->permList)) == false)
    f030:	f1a6 0028 	sub.w	r0, r6, #40	; 0x28
    f034:	f011 fb27 	bl	20686 <TCPIP_Helper_ProtectedSingleListInitialize>
    f038:	2800      	cmp	r0, #0
    f03a:	d1ba      	bne.n	efb2 <TCPIP_ARP_Initialize+0xe6>
                    _ARPDeleteResources();
    f03c:	f008 fad0 	bl	175e0 <_ARPDeleteResources>
                    return false;
    f040:	2400      	movs	r4, #0
    f042:	e784      	b.n	ef4e <TCPIP_ARP_Initialize+0x82>
            arpMod.pMacPkt = _ARPAllocateTxPacket();
    f044:	f011 f96c 	bl	20320 <_ARPAllocateTxPacket>
    f048:	4c12      	ldr	r4, [pc, #72]	; (f094 <TCPIP_ARP_Initialize+0x1c8>)
    f04a:	64a0      	str	r0, [r4, #72]	; 0x48
            arpMod.timerHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_ARP_Task, TCPIP_ARP_TASK_PROCESS_RATE);
    f04c:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
    f050:	4915      	ldr	r1, [pc, #84]	; (f0a8 <TCPIP_ARP_Initialize+0x1dc>)
    f052:	2002      	movs	r0, #2
    f054:	f00d fe1c 	bl	1cc90 <_TCPIPStackSignalHandlerRegister>
    f058:	61e0      	str	r0, [r4, #28]
            iniRes = TCPIP_Notification_Initialize(&arpMod.registeredUsers);
    f05a:	f104 0020 	add.w	r0, r4, #32
    f05e:	f013 f808 	bl	22072 <TCPIP_Notification_Initialize>
            if(arpMod.pMacPkt == 0 || arpMod.timerHandle == 0 || iniRes == false)
    f062:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    f064:	b13b      	cbz	r3, f076 <TCPIP_ARP_Initialize+0x1aa>
    f066:	69e3      	ldr	r3, [r4, #28]
    f068:	b12b      	cbz	r3, f076 <TCPIP_ARP_Initialize+0x1aa>
    f06a:	b120      	cbz	r0, f076 <TCPIP_ARP_Initialize+0x1aa>
            arpMod.timeSeconds = arpMod.timeMs = 0;
    f06c:	4b09      	ldr	r3, [pc, #36]	; (f094 <TCPIP_ARP_Initialize+0x1c8>)
    f06e:	2200      	movs	r2, #0
    f070:	619a      	str	r2, [r3, #24]
    f072:	615a      	str	r2, [r3, #20]
    f074:	e75c      	b.n	ef30 <TCPIP_ARP_Initialize+0x64>
                _ARPDeleteResources();
    f076:	f008 fab3 	bl	175e0 <_ARPDeleteResources>
                return false;
    f07a:	2400      	movs	r4, #0
    f07c:	e767      	b.n	ef4e <TCPIP_ARP_Initialize+0x82>
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
    f07e:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
        _ARPRemoveCacheEntries(pArpDcpt);
    f082:	eb05 00c0 	add.w	r0, r5, r0, lsl #3
    f086:	f010 fe3d 	bl	1fd04 <_ARPRemoveCacheEntries>
    f08a:	e75b      	b.n	ef44 <TCPIP_ARP_Initialize+0x78>
            return false;
    f08c:	2400      	movs	r4, #0
    f08e:	e75e      	b.n	ef4e <TCPIP_ARP_Initialize+0x82>
                return false;
    f090:	2400      	movs	r4, #0
    f092:	e75c      	b.n	ef4e <TCPIP_ARP_Initialize+0x82>
    f094:	2000e1a4 	.word	0x2000e1a4
    f098:	000213dd 	.word	0x000213dd
    f09c:	0001ef85 	.word	0x0001ef85
    f0a0:	00021eb1 	.word	0x00021eb1
    f0a4:	0002210d 	.word	0x0002210d
    f0a8:	0000c441 	.word	0x0000c441
    f0ac:	51eb851f 	.word	0x51eb851f

Disassembly of section .text.xTaskCreate%239:

0000f0b0 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    f0b0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f0b4:	4680      	mov	r8, r0
    f0b6:	460e      	mov	r6, r1
    f0b8:	4699      	mov	r9, r3
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    f0ba:	0095      	lsls	r5, r2, #2
    f0bc:	4628      	mov	r0, r5
    f0be:	f00b fb8b 	bl	1a7d8 <pvPortMalloc>

			if( pxStack != NULL )
    f0c2:	2800      	cmp	r0, #0
    f0c4:	f000 80c2 	beq.w	f24c <xTaskCreate+0x19c>
    f0c8:	4607      	mov	r7, r0
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    f0ca:	2054      	movs	r0, #84	; 0x54
    f0cc:	f00b fb84 	bl	1a7d8 <pvPortMalloc>

				if( pxNewTCB != NULL )
    f0d0:	4604      	mov	r4, r0
    f0d2:	2800      	cmp	r0, #0
    f0d4:	f000 8081 	beq.w	f1da <xTaskCreate+0x12a>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    f0d8:	6307      	str	r7, [r0, #48]	; 0x30

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    f0da:	462a      	mov	r2, r5
    f0dc:	21a5      	movs	r1, #165	; 0xa5
    f0de:	4638      	mov	r0, r7
    f0e0:	f012 fd4c 	bl	21b7c <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    f0e4:	6b27      	ldr	r7, [r4, #48]	; 0x30
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    f0e6:	2e00      	cmp	r6, #0
    f0e8:	d07d      	beq.n	f1e6 <xTaskCreate+0x136>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    f0ea:	7833      	ldrb	r3, [r6, #0]
    f0ec:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    f0f0:	b153      	cbz	r3, f108 <xTaskCreate+0x58>
    f0f2:	4633      	mov	r3, r6
    f0f4:	f104 0134 	add.w	r1, r4, #52	; 0x34
    f0f8:	360f      	adds	r6, #15
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    f0fa:	f813 2f01 	ldrb.w	r2, [r3, #1]!
    f0fe:	f801 2f01 	strb.w	r2, [r1, #1]!
			if( pcName[ x ] == ( char ) 0x00 )
    f102:	b10a      	cbz	r2, f108 <xTaskCreate+0x58>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    f104:	42b3      	cmp	r3, r6
    f106:	d1f8      	bne.n	f0fa <xTaskCreate+0x4a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    f108:	2300      	movs	r3, #0
    f10a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    f10e:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    f110:	2e04      	cmp	r6, #4
    f112:	bf28      	it	cs
    f114:	2604      	movcs	r6, #4
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    f116:	62e6      	str	r6, [r4, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    f118:	6466      	str	r6, [r4, #68]	; 0x44
		pxNewTCB->uxMutexesHeld = 0;
    f11a:	f04f 0b00 	mov.w	fp, #0
    f11e:	f8c4 b048 	str.w	fp, [r4, #72]	; 0x48
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    f122:	f104 0a04 	add.w	sl, r4, #4
    f126:	4650      	mov	r0, sl
    f128:	f012 fff9 	bl	2211e <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    f12c:	f104 0018 	add.w	r0, r4, #24
    f130:	f012 fff5 	bl	2211e <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    f134:	6124      	str	r4, [r4, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    f136:	f1c6 0605 	rsb	r6, r6, #5
    f13a:	61a6      	str	r6, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    f13c:	6264      	str	r4, [r4, #36]	; 0x24
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    f13e:	f8c4 b04c 	str.w	fp, [r4, #76]	; 0x4c
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    f142:	f884 b050 	strb.w	fp, [r4, #80]	; 0x50
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    f146:	3d04      	subs	r5, #4
    f148:	443d      	add	r5, r7
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    f14a:	464a      	mov	r2, r9
    f14c:	4641      	mov	r1, r8
    f14e:	f025 0007 	bic.w	r0, r5, #7
    f152:	f010 fbcb 	bl	1f8ec <pxPortInitialiseStack>
    f156:	6020      	str	r0, [r4, #0]
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    f158:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f15a:	b103      	cbz	r3, f15e <xTaskCreate+0xae>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    f15c:	601c      	str	r4, [r3, #0]

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    f15e:	f011 fcd7 	bl	20b10 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
    f162:	4a3e      	ldr	r2, [pc, #248]	; (f25c <xTaskCreate+0x1ac>)
    f164:	6813      	ldr	r3, [r2, #0]
    f166:	3301      	adds	r3, #1
    f168:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
    f16a:	4b3d      	ldr	r3, [pc, #244]	; (f260 <xTaskCreate+0x1b0>)
    f16c:	681b      	ldr	r3, [r3, #0]
    f16e:	2b00      	cmp	r3, #0
    f170:	d03d      	beq.n	f1ee <xTaskCreate+0x13e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    f172:	4b3c      	ldr	r3, [pc, #240]	; (f264 <xTaskCreate+0x1b4>)
    f174:	681b      	ldr	r3, [r3, #0]
    f176:	b93b      	cbnz	r3, f188 <xTaskCreate+0xd8>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    f178:	4b39      	ldr	r3, [pc, #228]	; (f260 <xTaskCreate+0x1b0>)
    f17a:	681b      	ldr	r3, [r3, #0]
    f17c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    f17e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    f180:	429a      	cmp	r2, r3
				{
					pxCurrentTCB = pxNewTCB;
    f182:	bf9c      	itt	ls
    f184:	4b36      	ldrls	r3, [pc, #216]	; (f260 <xTaskCreate+0x1b0>)
    f186:	601c      	strls	r4, [r3, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    f188:	4a37      	ldr	r2, [pc, #220]	; (f268 <xTaskCreate+0x1b8>)
    f18a:	6813      	ldr	r3, [r2, #0]
    f18c:	3301      	adds	r3, #1
    f18e:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    f190:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    f192:	4a36      	ldr	r2, [pc, #216]	; (f26c <xTaskCreate+0x1bc>)
    f194:	6811      	ldr	r1, [r2, #0]
    f196:	2301      	movs	r3, #1
    f198:	4083      	lsls	r3, r0
    f19a:	430b      	orrs	r3, r1
    f19c:	6013      	str	r3, [r2, #0]
    f19e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    f1a2:	4651      	mov	r1, sl
    f1a4:	4b32      	ldr	r3, [pc, #200]	; (f270 <xTaskCreate+0x1c0>)
    f1a6:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    f1aa:	f012 fabc 	bl	21726 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    f1ae:	f012 fb87 	bl	218c0 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
    f1b2:	4b2c      	ldr	r3, [pc, #176]	; (f264 <xTaskCreate+0x1b4>)
    f1b4:	681b      	ldr	r3, [r3, #0]
    f1b6:	2b00      	cmp	r3, #0
    f1b8:	d04c      	beq.n	f254 <xTaskCreate+0x1a4>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    f1ba:	4b29      	ldr	r3, [pc, #164]	; (f260 <xTaskCreate+0x1b0>)
    f1bc:	681b      	ldr	r3, [r3, #0]
    f1be:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    f1c0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    f1c2:	429a      	cmp	r2, r3
    f1c4:	d248      	bcs.n	f258 <xTaskCreate+0x1a8>
		{
			taskYIELD_IF_USING_PREEMPTION();
    f1c6:	4b2b      	ldr	r3, [pc, #172]	; (f274 <xTaskCreate+0x1c4>)
    f1c8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    f1cc:	601a      	str	r2, [r3, #0]
    f1ce:	f3bf 8f4f 	dsb	sy
    f1d2:	f3bf 8f6f 	isb	sy
			xReturn = pdPASS;
    f1d6:	2001      	movs	r0, #1
    f1d8:	e03a      	b.n	f250 <xTaskCreate+0x1a0>
					vPortFree( pxStack );
    f1da:	4638      	mov	r0, r7
    f1dc:	f00b ffcf 	bl	1b17e <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    f1e0:	f04f 30ff 	mov.w	r0, #4294967295
    f1e4:	e034      	b.n	f250 <xTaskCreate+0x1a0>
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    f1e6:	2300      	movs	r3, #0
    f1e8:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    f1ec:	e78f      	b.n	f10e <xTaskCreate+0x5e>
			pxCurrentTCB = pxNewTCB;
    f1ee:	4b1c      	ldr	r3, [pc, #112]	; (f260 <xTaskCreate+0x1b0>)
    f1f0:	601c      	str	r4, [r3, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    f1f2:	6813      	ldr	r3, [r2, #0]
    f1f4:	2b01      	cmp	r3, #1
    f1f6:	d1c7      	bne.n	f188 <xTaskCreate+0xd8>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    f1f8:	4d1d      	ldr	r5, [pc, #116]	; (f270 <xTaskCreate+0x1c0>)
    f1fa:	4628      	mov	r0, r5
    f1fc:	f012 fa88 	bl	21710 <vListInitialise>
    f200:	f105 0014 	add.w	r0, r5, #20
    f204:	f012 fa84 	bl	21710 <vListInitialise>
    f208:	f105 0028 	add.w	r0, r5, #40	; 0x28
    f20c:	f012 fa80 	bl	21710 <vListInitialise>
    f210:	f105 003c 	add.w	r0, r5, #60	; 0x3c
    f214:	f012 fa7c 	bl	21710 <vListInitialise>
    f218:	f105 0050 	add.w	r0, r5, #80	; 0x50
    f21c:	f012 fa78 	bl	21710 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
    f220:	4e15      	ldr	r6, [pc, #84]	; (f278 <xTaskCreate+0x1c8>)
    f222:	4630      	mov	r0, r6
    f224:	f012 fa74 	bl	21710 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    f228:	4d14      	ldr	r5, [pc, #80]	; (f27c <xTaskCreate+0x1cc>)
    f22a:	4628      	mov	r0, r5
    f22c:	f012 fa70 	bl	21710 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    f230:	4813      	ldr	r0, [pc, #76]	; (f280 <xTaskCreate+0x1d0>)
    f232:	f012 fa6d 	bl	21710 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    f236:	4813      	ldr	r0, [pc, #76]	; (f284 <xTaskCreate+0x1d4>)
    f238:	f012 fa6a 	bl	21710 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    f23c:	4812      	ldr	r0, [pc, #72]	; (f288 <xTaskCreate+0x1d8>)
    f23e:	f012 fa67 	bl	21710 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    f242:	4b12      	ldr	r3, [pc, #72]	; (f28c <xTaskCreate+0x1dc>)
    f244:	601e      	str	r6, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    f246:	4b12      	ldr	r3, [pc, #72]	; (f290 <xTaskCreate+0x1e0>)
    f248:	601d      	str	r5, [r3, #0]
    f24a:	e79d      	b.n	f188 <xTaskCreate+0xd8>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    f24c:	f04f 30ff 	mov.w	r0, #4294967295
	}
    f250:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			xReturn = pdPASS;
    f254:	2001      	movs	r0, #1
    f256:	e7fb      	b.n	f250 <xTaskCreate+0x1a0>
    f258:	2001      	movs	r0, #1
		return xReturn;
    f25a:	e7f9      	b.n	f250 <xTaskCreate+0x1a0>
    f25c:	2000e6b0 	.word	0x2000e6b0
    f260:	2000e6a4 	.word	0x2000e6a4
    f264:	2000e6d4 	.word	0x2000e6d4
    f268:	2000e6bc 	.word	0x2000e6bc
    f26c:	2000e6c0 	.word	0x2000e6c0
    f270:	2000e080 	.word	0x2000e080
    f274:	e000ed04 	.word	0xe000ed04
    f278:	2000e48c 	.word	0x2000e48c
    f27c:	2000e4a0 	.word	0x2000e4a0
    f280:	2000e4b4 	.word	0x2000e4b4
    f284:	2000e4dc 	.word	0x2000e4dc
    f288:	2000e4c8 	.word	0x2000e4c8
    f28c:	2000e6a8 	.word	0x2000e6a8
    f290:	2000e6ac 	.word	0x2000e6ac

Disassembly of section .text._DHCPReceive%240:

0000f294 <_DHCPReceive>:
{
    f294:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f298:	b0e1      	sub	sp, #388	; 0x184
    f29a:	4606      	mov	r6, r0
    s = dhcpClientSocket;
    f29c:	4b70      	ldr	r3, [pc, #448]	; (f460 <_DHCPReceive+0x1cc>)
    f29e:	f9b3 4000 	ldrsh.w	r4, [r3]
        TCPIP_UDP_ArrayGet(s, &dhcpHdr.op, sizeof(dhcpHdr));
    f2a2:	222c      	movs	r2, #44	; 0x2c
    f2a4:	a955      	add	r1, sp, #340	; 0x154
    f2a6:	4620      	mov	r0, r4
    f2a8:	f005 fddc 	bl	14e64 <TCPIP_UDP_ArrayGet>
        if ( dhcpHdr.op != TCPIP_BOOT_REPLY )
    f2ac:	f89d 3154 	ldrb.w	r3, [sp, #340]	; 0x154
    f2b0:	2b02      	cmp	r3, #2
    f2b2:	d004      	beq.n	f2be <_DHCPReceive+0x2a>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
    f2b4:	2500      	movs	r5, #0
        TCPIP_UDP_Discard(s);                     
    f2b6:	4620      	mov	r0, r4
    f2b8:	f011 fa07 	bl	206ca <TCPIP_UDP_Discard>
    return msgType;
    f2bc:	e05a      	b.n	f374 <_DHCPReceive+0xe0>
        if(TCPIP_UDP_ArrayGet(s, 0, sizeof(TCPIP_DHCP_FRAME_OPT_HEADER)) != sizeof(TCPIP_DHCP_FRAME_OPT_HEADER))
    f2be:	22c0      	movs	r2, #192	; 0xc0
    f2c0:	2100      	movs	r1, #0
    f2c2:	4620      	mov	r0, r4
    f2c4:	f005 fdce 	bl	14e64 <TCPIP_UDP_ArrayGet>
    f2c8:	28c0      	cmp	r0, #192	; 0xc0
    f2ca:	d001      	beq.n	f2d0 <_DHCPReceive+0x3c>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
    f2cc:	2500      	movs	r5, #0
    f2ce:	e7f2      	b.n	f2b6 <_DHCPReceive+0x22>
        optSize = (int32_t)TCPIP_UDP_ArrayGet(s, dhcpOpt.cookie, sizeof(dhcpOpt));
    f2d0:	f44f 729c 	mov.w	r2, #312	; 0x138
    f2d4:	a907      	add	r1, sp, #28
    f2d6:	4620      	mov	r0, r4
    f2d8:	f005 fdc4 	bl	14e64 <TCPIP_UDP_ArrayGet>
    f2dc:	4681      	mov	r9, r0
        if(optSize < sizeof(dhcpOpt.cookie) || (memcmp(dhcpOpt.cookie, dhcpMagicCookie, sizeof(dhcpOpt.cookie)) != 0))
    f2de:	2803      	cmp	r0, #3
    f2e0:	f240 8091 	bls.w	f406 <_DHCPReceive+0x172>
    f2e4:	2204      	movs	r2, #4
    f2e6:	495f      	ldr	r1, [pc, #380]	; (f464 <_DHCPReceive+0x1d0>)
    f2e8:	a807      	add	r0, sp, #28
    f2ea:	f011 feab 	bl	21044 <memcmp>
    f2ee:	4605      	mov	r5, r0
    f2f0:	b108      	cbz	r0, f2f6 <_DHCPReceive+0x62>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
    f2f2:	2500      	movs	r5, #0
    f2f4:	e7df      	b.n	f2b6 <_DHCPReceive+0x22>
        nNets = TCPIP_STACK_NumberOfNetworksGet();
    f2f6:	f012 fe05 	bl	21f04 <TCPIP_STACK_NumberOfNetworksGet>
        pSrchClient = DHCPClients; 
    f2fa:	4b5b      	ldr	r3, [pc, #364]	; (f468 <_DHCPReceive+0x1d4>)
    f2fc:	681f      	ldr	r7, [r3, #0]
        for(netIx = 0; netIx < nNets; netIx++, pSrchClient++) 
    f2fe:	f1b0 0800 	subs.w	r8, r0, #0
    f302:	f340 808d 	ble.w	f420 <_DHCPReceive+0x18c>
            if(pSrchClient->smState == TCPIP_DHCP_GET_OFFER || pSrchClient->smState == TCPIP_DHCP_GET_REQUEST_ACK ||
    f306:	f240 2a85 	movw	sl, #645	; 0x285
                if(dhcpHdr.xid == pSrchClient->transactionID.Val && memcmp(dhcpHdr.chaddr, _TCPIPStack_NetMACAddressGet(pIf), sizeof(TCPIP_MAC_ADDR)) == 0)
    f30a:	f04f 0b06 	mov.w	fp, #6
    f30e:	e007      	b.n	f320 <_DHCPReceive+0x8c>
    f310:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    f312:	9a56      	ldr	r2, [sp, #344]	; 0x158
    f314:	429a      	cmp	r2, r3
    f316:	d01f      	beq.n	f358 <_DHCPReceive+0xc4>
        for(netIx = 0; netIx < nNets; netIx++, pSrchClient++) 
    f318:	3501      	adds	r5, #1
    f31a:	375c      	adds	r7, #92	; 0x5c
    f31c:	45a8      	cmp	r8, r5
    f31e:	d07f      	beq.n	f420 <_DHCPReceive+0x18c>
            pIf = (TCPIP_NET_IF*)TCPIP_STACK_IndexToNet (netIx);
    f320:	4628      	mov	r0, r5
    f322:	f010 fd7b 	bl	1fe1c <TCPIP_STACK_IndexToNet>
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
    f326:	4601      	mov	r1, r0
    f328:	2800      	cmp	r0, #0
    f32a:	d0f5      	beq.n	f318 <_DHCPReceive+0x84>
    f32c:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
    f330:	f013 0f40 	tst.w	r3, #64	; 0x40
    f334:	d0f0      	beq.n	f318 <_DHCPReceive+0x84>
            if(!TCPIP_STACK_NetworkIsUp(pIf) || pSrchClient->flags.bDHCPEnabled == false)
    f336:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
    f33a:	f013 0f01 	tst.w	r3, #1
    f33e:	d0eb      	beq.n	f318 <_DHCPReceive+0x84>
            if(pSrchClient->smState == TCPIP_DHCP_GET_OFFER || pSrchClient->smState == TCPIP_DHCP_GET_REQUEST_ACK ||
    f340:	f8b7 3056 	ldrh.w	r3, [r7, #86]	; 0x56
    f344:	3b03      	subs	r3, #3
    f346:	b29b      	uxth	r3, r3
    f348:	2b09      	cmp	r3, #9
    f34a:	d8e5      	bhi.n	f318 <_DHCPReceive+0x84>
    f34c:	fa2a f303 	lsr.w	r3, sl, r3
    f350:	f013 0f01 	tst.w	r3, #1
    f354:	d1dc      	bne.n	f310 <_DHCPReceive+0x7c>
    f356:	e7df      	b.n	f318 <_DHCPReceive+0x84>
                if(dhcpHdr.xid == pSrchClient->transactionID.Val && memcmp(dhcpHdr.chaddr, _TCPIPStack_NetMACAddressGet(pIf), sizeof(TCPIP_MAC_ADDR)) == 0)
    f358:	465a      	mov	r2, fp
    f35a:	313c      	adds	r1, #60	; 0x3c
    f35c:	a85c      	add	r0, sp, #368	; 0x170
    f35e:	f011 fe71 	bl	21044 <memcmp>
    f362:	2800      	cmp	r0, #0
    f364:	d1d8      	bne.n	f318 <_DHCPReceive+0x84>
        if(pClient != pOwner)
    f366:	42be      	cmp	r6, r7
    f368:	d05c      	beq.n	f424 <_DHCPReceive+0x190>
        TCPIP_UDP_RxOffsetSet(s, 0);
    f36a:	2100      	movs	r1, #0
    f36c:	4620      	mov	r0, r4
    f36e:	f00f fb0f 	bl	1e990 <TCPIP_UDP_RxOffsetSet>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
    f372:	2500      	movs	r5, #0
}
    f374:	4628      	mov	r0, r5
    f376:	b061      	add	sp, #388	; 0x184
    f378:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        pEntry = _DHCPOptProcTbl;
    f37c:	4b3b      	ldr	r3, [pc, #236]	; (f46c <_DHCPReceive+0x1d8>)
                optLen = (*pEntry->dhcpProcFnc)(pClient, pOptData);
    f37e:	685b      	ldr	r3, [r3, #4]
    f380:	4669      	mov	r1, sp
    f382:	4630      	mov	r0, r6
    f384:	4798      	blx	r3
                if(optLen > 0)
    f386:	2800      	cmp	r0, #0
    f388:	dd06      	ble.n	f398 <_DHCPReceive+0x104>
                    pOptData->pOpt += optLen;
    f38a:	9b00      	ldr	r3, [sp, #0]
    f38c:	4403      	add	r3, r0
    f38e:	9300      	str	r3, [sp, #0]
                    pOptData->optSize -= optLen;
    f390:	9b01      	ldr	r3, [sp, #4]
    f392:	1a1b      	subs	r3, r3, r0
    f394:	9301      	str	r3, [sp, #4]
        if(optFound == false)
    f396:	e009      	b.n	f3ac <_DHCPReceive+0x118>
                else if(optLen == 0)
    f398:	2800      	cmp	r0, #0
    f39a:	d036      	beq.n	f40a <_DHCPReceive+0x176>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
    f39c:	2500      	movs	r5, #0
    f39e:	e78a      	b.n	f2b6 <_DHCPReceive+0x22>
            optLen = *(pOptData->pOpt + 1);
    f3a0:	7843      	ldrb	r3, [r0, #1]
            pOptData->pOpt += optLen + 2;
    f3a2:	3302      	adds	r3, #2
    f3a4:	4418      	add	r0, r3
    f3a6:	9000      	str	r0, [sp, #0]
            pOptData->optSize -= optLen + 2;
    f3a8:	1ad3      	subs	r3, r2, r3
    f3aa:	9301      	str	r3, [sp, #4]
    while(pOptData->optSize > 0)
    f3ac:	9a01      	ldr	r2, [sp, #4]
    f3ae:	2a00      	cmp	r2, #0
    f3b0:	ddf4      	ble.n	f39c <_DHCPReceive+0x108>
        opt = *pOptData->pOpt;
    f3b2:	9800      	ldr	r0, [sp, #0]
            if(opt == pEntry->option)
    f3b4:	7801      	ldrb	r1, [r0, #0]
    f3b6:	2935      	cmp	r1, #53	; 0x35
    f3b8:	d0e0      	beq.n	f37c <_DHCPReceive+0xe8>
        for(optIx = 0; optIx < sizeof(_DHCPOptProcTbl) / sizeof(*_DHCPOptProcTbl); optIx++, pEntry++)
    f3ba:	f108 0308 	add.w	r3, r8, #8
            if(opt == pEntry->option)
    f3be:	681f      	ldr	r7, [r3, #0]
    f3c0:	428f      	cmp	r7, r1
    f3c2:	d0dc      	beq.n	f37e <_DHCPReceive+0xea>
        for(optIx = 0; optIx < sizeof(_DHCPOptProcTbl) / sizeof(*_DHCPOptProcTbl); optIx++, pEntry++)
    f3c4:	3308      	adds	r3, #8
    f3c6:	42ab      	cmp	r3, r5
    f3c8:	d1f9      	bne.n	f3be <_DHCPReceive+0x12a>
    f3ca:	e7e9      	b.n	f3a0 <_DHCPReceive+0x10c>
        if ( dhcpOptData.msgType == TCPIP_DHCP_OFFER_MESSAGE || (dhcpOptData.msgType == TCPIP_DHCP_ACK_MESSAGE && pClient->dhcpOp == TCPIP_DHCP_OPER_INIT_REBOOT))
    f3cc:	f8b6 3054 	ldrh.w	r3, [r6, #84]	; 0x54
    f3d0:	2b02      	cmp	r3, #2
    f3d2:	d005      	beq.n	f3e0 <_DHCPReceive+0x14c>
        else if(pClient->dwServerID != dhcpOptData.serverID.Val)
    f3d4:	9a03      	ldr	r2, [sp, #12]
    f3d6:	6a73      	ldr	r3, [r6, #36]	; 0x24
    f3d8:	429a      	cmp	r2, r3
    f3da:	d00c      	beq.n	f3f6 <_DHCPReceive+0x162>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
    f3dc:	2500      	movs	r5, #0
    if(pOwner == 0)
    f3de:	e76a      	b.n	f2b6 <_DHCPReceive+0x22>
            pClient->dwServerID = dhcpOptData.serverID.Val;
    f3e0:	9b03      	ldr	r3, [sp, #12]
    f3e2:	6273      	str	r3, [r6, #36]	; 0x24
            pClient->flags.bOfferReceived = true;
    f3e4:	f896 3058 	ldrb.w	r3, [r6, #88]	; 0x58
    f3e8:	f043 0304 	orr.w	r3, r3, #4
    f3ec:	f886 3058 	strb.w	r3, [r6, #88]	; 0x58
        if(msgType == TCPIP_DHCP_ACK_MESSAGE)
    f3f0:	2d05      	cmp	r5, #5
    f3f2:	f47f af60 	bne.w	f2b6 <_DHCPReceive+0x22>
            _DHCPSetLeaseTimeParams(pClient, &dhcpOptData);
    f3f6:	4669      	mov	r1, sp
    f3f8:	4630      	mov	r0, r6
    f3fa:	f009 fa97 	bl	1892c <_DHCPSetLeaseTimeParams>
        msgType = dhcpOptData.msgType;
    f3fe:	2505      	movs	r5, #5
    f400:	e759      	b.n	f2b6 <_DHCPReceive+0x22>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
    f402:	2500      	movs	r5, #0
    f404:	e757      	b.n	f2b6 <_DHCPReceive+0x22>
    f406:	2500      	movs	r5, #0
    f408:	e755      	b.n	f2b6 <_DHCPReceive+0x22>
        if ( dhcpOptData.msgType == TCPIP_DHCP_OFFER_MESSAGE || (dhcpOptData.msgType == TCPIP_DHCP_ACK_MESSAGE && pClient->dhcpOp == TCPIP_DHCP_OPER_INIT_REBOOT))
    f40a:	9d02      	ldr	r5, [sp, #8]
    f40c:	2d02      	cmp	r5, #2
    f40e:	d0e7      	beq.n	f3e0 <_DHCPReceive+0x14c>
    f410:	2d05      	cmp	r5, #5
    f412:	d0db      	beq.n	f3cc <_DHCPReceive+0x138>
        else if(pClient->dwServerID != dhcpOptData.serverID.Val)
    f414:	6a72      	ldr	r2, [r6, #36]	; 0x24
    f416:	9b03      	ldr	r3, [sp, #12]
    f418:	429a      	cmp	r2, r3
    f41a:	d0e9      	beq.n	f3f0 <_DHCPReceive+0x15c>
    msgType = TCPIP_DHCP_UNKNOWN_MESSAGE;
    f41c:	2500      	movs	r5, #0
    f41e:	e74a      	b.n	f2b6 <_DHCPReceive+0x22>
        if(pClient != pOwner)
    f420:	2e00      	cmp	r6, #0
    f422:	d1ee      	bne.n	f402 <_DHCPReceive+0x16e>
        if(!pClient->flags.bOfferReceived)
    f424:	f896 3058 	ldrb.w	r3, [r6, #88]	; 0x58
    f428:	f013 0f04 	tst.w	r3, #4
    f42c:	d107      	bne.n	f43e <_DHCPReceive+0x1aa>
            pClient->dhcpIPAddress.Val = dhcpHdr.yiaddr;
    f42e:	9b59      	ldr	r3, [sp, #356]	; 0x164
    f430:	62f3      	str	r3, [r6, #44]	; 0x2c
            pClient->validValues.IPAddress = 1;
    f432:	f896 3059 	ldrb.w	r3, [r6, #89]	; 0x59
    f436:	f043 0301 	orr.w	r3, r3, #1
    f43a:	f886 3059 	strb.w	r3, [r6, #89]	; 0x59
        memset(&dhcpOptData, 0, sizeof(dhcpOptData));
    f43e:	2300      	movs	r3, #0
    f440:	9302      	str	r3, [sp, #8]
    f442:	9303      	str	r3, [sp, #12]
    f444:	9304      	str	r3, [sp, #16]
    f446:	9305      	str	r3, [sp, #20]
    f448:	9306      	str	r3, [sp, #24]
        dhcpOptData.pOpt = dhcpOpt.options;
    f44a:	ab08      	add	r3, sp, #32
    f44c:	9300      	str	r3, [sp, #0]
        dhcpOptData.optSize = optSize - sizeof(dhcpMagicCookie);   // eat up the cookie
    f44e:	f1a9 0304 	sub.w	r3, r9, #4
    f452:	9301      	str	r3, [sp, #4]
        for(optIx = 0; optIx < sizeof(_DHCPOptProcTbl) / sizeof(*_DHCPOptProcTbl); optIx++, pEntry++)
    f454:	f8df 8014 	ldr.w	r8, [pc, #20]	; f46c <_DHCPReceive+0x1d8>
    f458:	f108 0548 	add.w	r5, r8, #72	; 0x48
    f45c:	e7a6      	b.n	f3ac <_DHCPReceive+0x118>
    f45e:	bf00      	nop
    f460:	2000e720 	.word	0x2000e720
    f464:	00022140 	.word	0x00022140
    f468:	2000e610 	.word	0x2000e610
    f46c:	0001cbb8 	.word	0x0001cbb8

Disassembly of section .text.GenericTxEnd%241:

0000f470 <GenericTxEnd>:
{
    f470:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    f474:	b085      	sub	sp, #20
    f476:	4604      	mov	r4, r0
    const void* cmdIoParam = pIState->pCmdIO->cmdIoParam;
    f478:	f8d0 20c4 	ldr.w	r2, [r0, #196]	; 0xc4
    f47c:	6855      	ldr	r5, [r2, #4]
    if(  pIState->remainingTxData  > 0u )
    f47e:	f8b0 30b0 	ldrh.w	r3, [r0, #176]	; 0xb0
    f482:	b1db      	cbz	r3, f4bc <GenericTxEnd+0x4c>
        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "iperf: Socket send failed\r\n");
    f484:	6813      	ldr	r3, [r2, #0]
    f486:	681b      	ldr	r3, [r3, #0]
    f488:	4968      	ldr	r1, [pc, #416]	; (f62c <GenericTxEnd+0x1bc>)
    f48a:	4628      	mov	r0, r5
    f48c:	4798      	blx	r3
        pIState->errorCount++;
    f48e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    f490:	3301      	adds	r3, #1
    f492:	6323      	str	r3, [r4, #48]	; 0x30
    pIState->lastPktId = pIState->pktId - 1;
    f494:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    f496:	3b01      	subs	r3, #1
    f498:	62e3      	str	r3, [r4, #44]	; 0x2c
    if ( (int32_t)(SYS_TMR_TickCountGet() - pIState->lastCheckTime) >= (pIState->mInterval - TCPIP_IPERF_TIMING_ERROR_MARGIN) )
    f49a:	f010 fd87 	bl	1ffac <SYS_TMR_TickCountGet>
    f49e:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
    f4a2:	1ac0      	subs	r0, r0, r3
    f4a4:	6823      	ldr	r3, [r4, #0]
    f4a6:	4298      	cmp	r0, r3
    f4a8:	f080 8086 	bcs.w	f5b8 <GenericTxEnd+0x148>
    if ( pIState->isLastTransmit == true )
    f4ac:	f894 30d0 	ldrb.w	r3, [r4, #208]	; 0xd0
    f4b0:	2b01      	cmp	r3, #1
    f4b2:	f000 8086 	beq.w	f5c2 <GenericTxEnd+0x152>
}
    f4b6:	b005      	add	sp, #20
    f4b8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if ( pIState->pktCount == 0u )
    f4bc:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
    f4c0:	2b00      	cmp	r3, #0
    f4c2:	d153      	bne.n	f56c <GenericTxEnd+0xfc>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: instance %d started ...\r\n", pIState - gIperfState);
    f4c4:	4b5a      	ldr	r3, [pc, #360]	; (f630 <GenericTxEnd+0x1c0>)
    f4c6:	1ac3      	subs	r3, r0, r3
    f4c8:	10db      	asrs	r3, r3, #3
    f4ca:	eb03 01c3 	add.w	r1, r3, r3, lsl #3
    f4ce:	eb03 0341 	add.w	r3, r3, r1, lsl #1
    f4d2:	ebc3 2343 	rsb	r3, r3, r3, lsl #9
    f4d6:	eb03 4383 	add.w	r3, r3, r3, lsl #18
    f4da:	4e56      	ldr	r6, [pc, #344]	; (f634 <GenericTxEnd+0x1c4>)
    f4dc:	6812      	ldr	r2, [r2, #0]
    f4de:	6857      	ldr	r7, [r2, #4]
    f4e0:	425a      	negs	r2, r3
    f4e2:	f506 61a7 	add.w	r1, r6, #1336	; 0x538
    f4e6:	4628      	mov	r0, r5
    f4e8:	47b8      	blx	r7
            lclAddress.Val = TCPIP_STACK_NetAddress(pIState->pNetIf);
    f4ea:	f8d4 00c8 	ldr.w	r0, [r4, #200]	; 0xc8
    f4ee:	f011 fb9c 	bl	20c2a <TCPIP_STACK_NetAddress>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Local  %u.%u.%u.%u port %u connected with\r\n",
    f4f2:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    f4f6:	681b      	ldr	r3, [r3, #0]
    f4f8:	f8b4 207e 	ldrh.w	r2, [r4, #126]	; 0x7e
    f4fc:	9202      	str	r2, [sp, #8]
    f4fe:	0e02      	lsrs	r2, r0, #24
    f500:	9201      	str	r2, [sp, #4]
    f502:	f3c0 4207 	ubfx	r2, r0, #16, #8
    f506:	9200      	str	r2, [sp, #0]
    f508:	685f      	ldr	r7, [r3, #4]
    f50a:	f3c0 2307 	ubfx	r3, r0, #8, #8
    f50e:	b2c2      	uxtb	r2, r0
    f510:	f206 515c 	addw	r1, r6, #1372	; 0x55c
    f514:	4628      	mov	r0, r5
    f516:	47b8      	blx	r7
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Remote %u.%u.%u.%u port %u\r\n",
    f518:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    f51c:	681b      	ldr	r3, [r3, #0]
    f51e:	8a62      	ldrh	r2, [r4, #18]
    f520:	9202      	str	r2, [sp, #8]
    f522:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
    f526:	9201      	str	r2, [sp, #4]
    f528:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
    f52c:	9200      	str	r2, [sp, #0]
    f52e:	685f      	ldr	r7, [r3, #4]
    f530:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    f534:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
    f538:	f506 61b2 	add.w	r1, r6, #1424	; 0x590
    f53c:	4628      	mov	r0, r5
    f53e:	47b8      	blx	r7
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Target rate = %ld bps, period = %ld ms\r\n",
    f540:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    f544:	681b      	ldr	r3, [r3, #0]
    f546:	f8d3 8004 	ldr.w	r8, [r3, #4]
                    (unsigned long)pIState->mTxRate, 
    f54a:	f8d4 9018 	ldr.w	r9, [r4, #24]
                    (unsigned long)(pIState->mPktPeriod*1000/SYS_TMR_TickCounterFrequencyGet()) );
    f54e:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
    f552:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
    f556:	fb07 f703 	mul.w	r7, r7, r3
    f55a:	f010 fd4f 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
            (pIState->pCmdIO->pCmdApi->print)(cmdIoParam, "    - Target rate = %ld bps, period = %ld ms\r\n",
    f55e:	fbb7 f3f0 	udiv	r3, r7, r0
    f562:	464a      	mov	r2, r9
    f564:	f206 51b4 	addw	r1, r6, #1460	; 0x5b4
    f568:	4628      	mov	r0, r5
    f56a:	47c0      	blx	r8
        pIState->pktId++;
    f56c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    f56e:	3301      	adds	r3, #1
    f570:	62a3      	str	r3, [r4, #40]	; 0x28
        pIState->pktCount++;
    f572:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    f576:	3301      	adds	r3, #1
    f578:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
        if ( pIState->mProtocol == UDP_PROTOCOL )
    f57c:	7c23      	ldrb	r3, [r4, #16]
    f57e:	2b01      	cmp	r3, #1
    f580:	d00e      	beq.n	f5a0 <GenericTxEnd+0x130>
        if ( pIState->mProtocol == TCP_PROTOCOL )
    f582:	2b02      	cmp	r3, #2
    f584:	d186      	bne.n	f494 <GenericTxEnd+0x24>
            pIState->totalLen += pIState->mMSS;
    f586:	f8b4 00d2 	ldrh.w	r0, [r4, #210]	; 0xd2
    f58a:	f7fb faf7 	bl	ab7c <__aeabi_i2d>
    f58e:	4602      	mov	r2, r0
    f590:	460b      	mov	r3, r1
    f592:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    f596:	f7fb f9a5 	bl	a8e4 <__adddf3>
    f59a:	e9c4 0108 	strd	r0, r1, [r4, #32]
    f59e:	e779      	b.n	f494 <GenericTxEnd+0x24>
            pIState->totalLen += pIState->mDatagramSize;
    f5a0:	68e0      	ldr	r0, [r4, #12]
    f5a2:	f7fb fadb 	bl	ab5c <__aeabi_ui2d>
    f5a6:	4602      	mov	r2, r0
    f5a8:	460b      	mov	r3, r1
    f5aa:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    f5ae:	f7fb f999 	bl	a8e4 <__adddf3>
    f5b2:	e9c4 0108 	strd	r0, r1, [r4, #32]
        if ( pIState->mProtocol == TCP_PROTOCOL )
    f5b6:	e76d      	b.n	f494 <GenericTxEnd+0x24>
        ReportBW_Jitter_Loss(pIState, INTERVAL_REPORT);
    f5b8:	2100      	movs	r1, #0
    f5ba:	4620      	mov	r0, r4
    f5bc:	f7fd fb32 	bl	cc24 <ReportBW_Jitter_Loss>
    f5c0:	e774      	b.n	f4ac <GenericTxEnd+0x3c>
        switch(pIState->mProtocol)
    f5c2:	7c23      	ldrb	r3, [r4, #16]
    f5c4:	2b01      	cmp	r3, #1
    f5c6:	d009      	beq.n	f5dc <GenericTxEnd+0x16c>
    f5c8:	2b02      	cmp	r3, #2
    f5ca:	d02a      	beq.n	f622 <GenericTxEnd+0x1b2>
        pIState->sockWaitToSend = 0;
    f5cc:	2300      	movs	r3, #0
    f5ce:	f884 30d4 	strb.w	r3, [r4, #212]	; 0xd4
        pIState->stopTime = SYS_TMR_TickCountGet();
    f5d2:	f010 fceb 	bl	1ffac <SYS_TMR_TickCountGet>
    f5d6:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
}
    f5da:	e76c      	b.n	f4b6 <GenericTxEnd+0x46>
                if(++pIState->nAttempts < UDP_FIN_RETRANSMIT_COUNT)
    f5dc:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
    f5e0:	3301      	adds	r3, #1
    f5e2:	b2db      	uxtb	r3, r3
    f5e4:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
    f5e8:	2b09      	cmp	r3, #9
    f5ea:	d815      	bhi.n	f618 <GenericTxEnd+0x1a8>
                    if ( pIState->nAttempts == 1u )
    f5ec:	2b01      	cmp	r3, #1
    f5ee:	d003      	beq.n	f5f8 <GenericTxEnd+0x188>
                    pIState->mPktPeriod = UDP_FIN_RETRANSMIT_PERIOD;
    f5f0:	230a      	movs	r3, #10
    f5f2:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
    f5f6:	e7e9      	b.n	f5cc <GenericTxEnd+0x15c>
                        pIState->stopTime = SYS_TMR_TickCountGet();
    f5f8:	f010 fcd8 	bl	1ffac <SYS_TMR_TickCountGet>
    f5fc:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
                        ReportBW_Jitter_Loss(pIState, SUBTOTAL_REPORT);
    f600:	2101      	movs	r1, #1
    f602:	4620      	mov	r0, r4
    f604:	f7fd fb0e 	bl	cc24 <ReportBW_Jitter_Loss>
                        (pIState->pCmdIO->pCmdApi->msg)(cmdIoParam, "    -----------------------------------------\r\n"); 
    f608:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    f60c:	681b      	ldr	r3, [r3, #0]
    f60e:	681b      	ldr	r3, [r3, #0]
    f610:	4909      	ldr	r1, [pc, #36]	; (f638 <GenericTxEnd+0x1c8>)
    f612:	4628      	mov	r0, r5
    f614:	4798      	blx	r3
    f616:	e7eb      	b.n	f5f0 <GenericTxEnd+0x180>
                    IperfSetState(pIState, IPERF_UDP_TX_DONE_STATE);
    f618:	2112      	movs	r1, #18
    f61a:	4620      	mov	r0, r4
    f61c:	f00c fb94 	bl	1bd48 <IperfSetState>
    f620:	e7d4      	b.n	f5cc <GenericTxEnd+0x15c>
                IperfSetState(pIState, IPERF_TCP_TX_DONE_STATE);
    f622:	210f      	movs	r1, #15
    f624:	4620      	mov	r0, r4
    f626:	f00c fb8f 	bl	1bd48 <IperfSetState>
                break;
    f62a:	e7cf      	b.n	f5cc <GenericTxEnd+0x15c>
    f62c:	00005160 	.word	0x00005160
    f630:	2000dbb0 	.word	0x2000dbb0
    f634:	00004c44 	.word	0x00004c44
    f638:	00005228 	.word	0x00005228

Disassembly of section .text._svfprintf_r%242:

0000f63c <_svfiprintf_r>:
    f63c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f640:	461e      	mov	r6, r3
    f642:	898b      	ldrh	r3, [r1, #12]
    f644:	061b      	lsls	r3, r3, #24
    f646:	b09d      	sub	sp, #116	; 0x74
    f648:	4607      	mov	r7, r0
    f64a:	460d      	mov	r5, r1
    f64c:	4614      	mov	r4, r2
    f64e:	d50e      	bpl.n	f66e <_svfiprintf_r+0x32>
    f650:	690b      	ldr	r3, [r1, #16]
    f652:	b963      	cbnz	r3, f66e <_svfiprintf_r+0x32>
    f654:	2140      	movs	r1, #64	; 0x40
    f656:	f007 f979 	bl	1694c <_malloc_r>
    f65a:	6028      	str	r0, [r5, #0]
    f65c:	6128      	str	r0, [r5, #16]
    f65e:	b920      	cbnz	r0, f66a <_svfiprintf_r+0x2e>
    f660:	230c      	movs	r3, #12
    f662:	603b      	str	r3, [r7, #0]
    f664:	f04f 30ff 	mov.w	r0, #4294967295
    f668:	e0c3      	b.n	f7f2 <_svfiprintf_r+0x1b6>
    f66a:	2340      	movs	r3, #64	; 0x40
    f66c:	616b      	str	r3, [r5, #20]
    f66e:	2300      	movs	r3, #0
    f670:	9309      	str	r3, [sp, #36]	; 0x24
    f672:	f8df 9184 	ldr.w	r9, [pc, #388]	; f7f8 <_svfiprintf_r+0x1bc>
    f676:	9603      	str	r6, [sp, #12]
    f678:	2320      	movs	r3, #32
    f67a:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
    f67e:	2330      	movs	r3, #48	; 0x30
    f680:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    f684:	f04f 38ff 	mov.w	r8, #4294967295
    f688:	f109 0a06 	add.w	sl, r9, #6
    f68c:	4623      	mov	r3, r4
    f68e:	461e      	mov	r6, r3
    f690:	f813 2b01 	ldrb.w	r2, [r3], #1
    f694:	b10a      	cbz	r2, f69a <_svfiprintf_r+0x5e>
    f696:	2a25      	cmp	r2, #37	; 0x25
    f698:	d1f9      	bne.n	f68e <_svfiprintf_r+0x52>
    f69a:	ebb6 0b04 	subs.w	fp, r6, r4
    f69e:	d00b      	beq.n	f6b8 <_svfiprintf_r+0x7c>
    f6a0:	465b      	mov	r3, fp
    f6a2:	4622      	mov	r2, r4
    f6a4:	4629      	mov	r1, r5
    f6a6:	4638      	mov	r0, r7
    f6a8:	f007 f840 	bl	1672c <__ssputs_r>
    f6ac:	3001      	adds	r0, #1
    f6ae:	f000 809b 	beq.w	f7e8 <_svfiprintf_r+0x1ac>
    f6b2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    f6b4:	445b      	add	r3, fp
    f6b6:	9309      	str	r3, [sp, #36]	; 0x24
    f6b8:	7833      	ldrb	r3, [r6, #0]
    f6ba:	2b00      	cmp	r3, #0
    f6bc:	f000 8094 	beq.w	f7e8 <_svfiprintf_r+0x1ac>
    f6c0:	2300      	movs	r3, #0
    f6c2:	e9cd 8305 	strd	r8, r3, [sp, #20]
    f6c6:	3601      	adds	r6, #1
    f6c8:	9304      	str	r3, [sp, #16]
    f6ca:	9307      	str	r3, [sp, #28]
    f6cc:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    f6d0:	931a      	str	r3, [sp, #104]	; 0x68
    f6d2:	f04f 0b01 	mov.w	fp, #1
    f6d6:	4634      	mov	r4, r6
    f6d8:	2205      	movs	r2, #5
    f6da:	f814 1b01 	ldrb.w	r1, [r4], #1
    f6de:	4846      	ldr	r0, [pc, #280]	; (f7f8 <_svfiprintf_r+0x1bc>)
    f6e0:	f008 f86e 	bl	177c0 <memchr>
    f6e4:	9b04      	ldr	r3, [sp, #16]
    f6e6:	b9c0      	cbnz	r0, f71a <_svfiprintf_r+0xde>
    f6e8:	06d8      	lsls	r0, r3, #27
    f6ea:	bf44      	itt	mi
    f6ec:	2220      	movmi	r2, #32
    f6ee:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    f6f2:	0719      	lsls	r1, r3, #28
    f6f4:	bf44      	itt	mi
    f6f6:	222b      	movmi	r2, #43	; 0x2b
    f6f8:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    f6fc:	7832      	ldrb	r2, [r6, #0]
    f6fe:	2a2a      	cmp	r2, #42	; 0x2a
    f700:	d013      	beq.n	f72a <_svfiprintf_r+0xee>
    f702:	9a07      	ldr	r2, [sp, #28]
    f704:	4634      	mov	r4, r6
    f706:	2000      	movs	r0, #0
    f708:	260a      	movs	r6, #10
    f70a:	4621      	mov	r1, r4
    f70c:	f811 3b01 	ldrb.w	r3, [r1], #1
    f710:	3b30      	subs	r3, #48	; 0x30
    f712:	2b09      	cmp	r3, #9
    f714:	d94b      	bls.n	f7ae <_svfiprintf_r+0x172>
    f716:	b970      	cbnz	r0, f736 <_svfiprintf_r+0xfa>
    f718:	e014      	b.n	f744 <_svfiprintf_r+0x108>
    f71a:	eba0 0009 	sub.w	r0, r0, r9
    f71e:	fa0b f000 	lsl.w	r0, fp, r0
    f722:	4318      	orrs	r0, r3
    f724:	9004      	str	r0, [sp, #16]
    f726:	4626      	mov	r6, r4
    f728:	e7d5      	b.n	f6d6 <_svfiprintf_r+0x9a>
    f72a:	9a03      	ldr	r2, [sp, #12]
    f72c:	1d11      	adds	r1, r2, #4
    f72e:	6812      	ldr	r2, [r2, #0]
    f730:	9103      	str	r1, [sp, #12]
    f732:	2a00      	cmp	r2, #0
    f734:	db01      	blt.n	f73a <_svfiprintf_r+0xfe>
    f736:	9207      	str	r2, [sp, #28]
    f738:	e004      	b.n	f744 <_svfiprintf_r+0x108>
    f73a:	4252      	negs	r2, r2
    f73c:	f043 0302 	orr.w	r3, r3, #2
    f740:	9207      	str	r2, [sp, #28]
    f742:	9304      	str	r3, [sp, #16]
    f744:	7823      	ldrb	r3, [r4, #0]
    f746:	2b2e      	cmp	r3, #46	; 0x2e
    f748:	d10b      	bne.n	f762 <_svfiprintf_r+0x126>
    f74a:	7863      	ldrb	r3, [r4, #1]
    f74c:	2b2a      	cmp	r3, #42	; 0x2a
    f74e:	d133      	bne.n	f7b8 <_svfiprintf_r+0x17c>
    f750:	9b03      	ldr	r3, [sp, #12]
    f752:	1d1a      	adds	r2, r3, #4
    f754:	681b      	ldr	r3, [r3, #0]
    f756:	9203      	str	r2, [sp, #12]
    f758:	2b00      	cmp	r3, #0
    f75a:	bfb8      	it	lt
    f75c:	4643      	movlt	r3, r8
    f75e:	3402      	adds	r4, #2
    f760:	9305      	str	r3, [sp, #20]
    f762:	2203      	movs	r2, #3
    f764:	7821      	ldrb	r1, [r4, #0]
    f766:	4825      	ldr	r0, [pc, #148]	; (f7fc <_svfiprintf_r+0x1c0>)
    f768:	f008 f82a 	bl	177c0 <memchr>
    f76c:	b140      	cbz	r0, f780 <_svfiprintf_r+0x144>
    f76e:	2340      	movs	r3, #64	; 0x40
    f770:	eba0 000a 	sub.w	r0, r0, sl
    f774:	fa03 f000 	lsl.w	r0, r3, r0
    f778:	9b04      	ldr	r3, [sp, #16]
    f77a:	4303      	orrs	r3, r0
    f77c:	3401      	adds	r4, #1
    f77e:	9304      	str	r3, [sp, #16]
    f780:	f814 1b01 	ldrb.w	r1, [r4], #1
    f784:	481e      	ldr	r0, [pc, #120]	; (f800 <_svfiprintf_r+0x1c4>)
    f786:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
    f78a:	2206      	movs	r2, #6
    f78c:	f008 f818 	bl	177c0 <memchr>
    f790:	ab03      	add	r3, sp, #12
    f792:	9300      	str	r3, [sp, #0]
    f794:	462a      	mov	r2, r5
    f796:	4b1b      	ldr	r3, [pc, #108]	; (f804 <_svfiprintf_r+0x1c8>)
    f798:	a904      	add	r1, sp, #16
    f79a:	b308      	cbz	r0, f7e0 <_svfiprintf_r+0x1a4>
    f79c:	4638      	mov	r0, r7
    f79e:	f7f7 ff4b 	bl	7638 <_printf_float>
    f7a2:	1c42      	adds	r2, r0, #1
    f7a4:	d020      	beq.n	f7e8 <_svfiprintf_r+0x1ac>
    f7a6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    f7a8:	4403      	add	r3, r0
    f7aa:	9309      	str	r3, [sp, #36]	; 0x24
    f7ac:	e76e      	b.n	f68c <_svfiprintf_r+0x50>
    f7ae:	fb06 3202 	mla	r2, r6, r2, r3
    f7b2:	2001      	movs	r0, #1
    f7b4:	460c      	mov	r4, r1
    f7b6:	e7a8      	b.n	f70a <_svfiprintf_r+0xce>
    f7b8:	2300      	movs	r3, #0
    f7ba:	3401      	adds	r4, #1
    f7bc:	9305      	str	r3, [sp, #20]
    f7be:	4619      	mov	r1, r3
    f7c0:	260a      	movs	r6, #10
    f7c2:	4620      	mov	r0, r4
    f7c4:	f810 2b01 	ldrb.w	r2, [r0], #1
    f7c8:	3a30      	subs	r2, #48	; 0x30
    f7ca:	2a09      	cmp	r2, #9
    f7cc:	d903      	bls.n	f7d6 <_svfiprintf_r+0x19a>
    f7ce:	2b00      	cmp	r3, #0
    f7d0:	d0c7      	beq.n	f762 <_svfiprintf_r+0x126>
    f7d2:	9105      	str	r1, [sp, #20]
    f7d4:	e7c5      	b.n	f762 <_svfiprintf_r+0x126>
    f7d6:	fb06 2101 	mla	r1, r6, r1, r2
    f7da:	2301      	movs	r3, #1
    f7dc:	4604      	mov	r4, r0
    f7de:	e7f0      	b.n	f7c2 <_svfiprintf_r+0x186>
    f7e0:	4638      	mov	r0, r7
    f7e2:	f7fe fa57 	bl	dc94 <_printf_i>
    f7e6:	e7dc      	b.n	f7a2 <_svfiprintf_r+0x166>
    f7e8:	89ab      	ldrh	r3, [r5, #12]
    f7ea:	065b      	lsls	r3, r3, #25
    f7ec:	f53f af3a 	bmi.w	f664 <_svfiprintf_r+0x28>
    f7f0:	9809      	ldr	r0, [sp, #36]	; 0x24
    f7f2:	b01d      	add	sp, #116	; 0x74
    f7f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f7f8:	000219fb 	.word	0x000219fb
    f7fc:	00021a01 	.word	0x00021a01
    f800:	00021a05 	.word	0x00021a05
    f804:	0001672d 	.word	0x0001672d

Disassembly of section .text.DRV_EXTPHY_MIIConfigure%243:

0000f808 <DRV_EXTPHY_MIIConfigure>:
{
    f808:	b5f0      	push	{r4, r5, r6, r7, lr}
    f80a:	b087      	sub	sp, #28
    f80c:	4606      	mov	r6, r0
    f80e:	460d      	mov	r5, r1
    LAN867X_REG_OBJ clientObj = {0};
    f810:	2100      	movs	r1, #0
    f812:	9101      	str	r1, [sp, #4]
    f814:	9102      	str	r1, [sp, #8]
    clientObj.miimBase =
    f816:	692b      	ldr	r3, [r5, #16]
    f818:	9304      	str	r3, [sp, #16]
    clientObj.miimHandle =
    f81a:	696b      	ldr	r3, [r5, #20]
    f81c:	9303      	str	r3, [sp, #12]
    clientObj.miimOpHandle = &((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)
    f81e:	f105 0318 	add.w	r3, r5, #24
    f822:	9305      	str	r3, [sp, #20]
    pBaseObj->DRV_ETHPHY_PhyAddressGet(hClientObj, DRV_ETHPHY_INF_IDX_ALL_EXTERNAL,
    f824:	6a83      	ldr	r3, [r0, #40]	; 0x28
    f826:	aa01      	add	r2, sp, #4
    f828:	4628      	mov	r0, r5
    f82a:	4798      	blx	r3
    pBaseObj->DRV_ETHPHY_VendorDataGet(hClientObj, &clientObj.vendorData);
    f82c:	6cb3      	ldr	r3, [r6, #72]	; 0x48
    f82e:	a902      	add	r1, sp, #8
    f830:	4628      	mov	r0, r5
    f832:	4798      	blx	r3
    state = R2F(clientObj.vendorData, VENDOR_STATE);
    f834:	f89d 400a 	ldrb.w	r4, [sp, #10]
    switch (state) {
    f838:	2c0e      	cmp	r4, #14
    f83a:	f200 809d 	bhi.w	f978 <DRV_EXTPHY_MIIConfigure+0x170>
    f83e:	e8df f004 	tbb	[pc, r4]
    f842:	2a08      	.short	0x2a08
    f844:	4b423b32 	.word	0x4b423b32
    f848:	6d655c53 	.word	0x6d655c53
    f84c:	8d877e76 	.word	0x8d877e76
    f850:	94          	.byte	0x94
    f851:	00          	.byte	0x00
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F00D0, 0x0E03, 0x0002);
    f852:	2302      	movs	r3, #2
    f854:	f640 6203 	movw	r2, #3587	; 0xe03
    f858:	494d      	ldr	r1, [pc, #308]	; (f990 <DRV_EXTPHY_MIIConfigure+0x188>)
    f85a:	a801      	add	r0, sp, #4
    f85c:	f008 f9d6 	bl	17c0c <Lan867x_Write_Bit_Register>
        if (miimRes < 0) {
    f860:	2800      	cmp	r0, #0
    f862:	f2c0 808f 	blt.w	f984 <DRV_EXTPHY_MIIConfigure+0x17c>
        } else if (miimRes != DRV_MIIM_RES_OK) {
    f866:	2800      	cmp	r0, #0
    f868:	f040 808f 	bne.w	f98a <DRV_EXTPHY_MIIConfigure+0x182>
            ++state;
    f86c:	3401      	adds	r4, #1
    f86e:	b2a4      	uxth	r4, r4
                F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj.vendorData);
    f870:	9b02      	ldr	r3, [sp, #8]
    f872:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
            clientObj.vendorData =
    f876:	9302      	str	r3, [sp, #8]
            res = DRV_ETHPHY_RES_PENDING;
    f878:	2701      	movs	r7, #1
    clientObj.vendorData = F2R(state, VENDOR_STATE, clientObj.vendorData);
    f87a:	9902      	ldr	r1, [sp, #8]
    f87c:	f421 017f 	bic.w	r1, r1, #16711680	; 0xff0000
    f880:	0424      	lsls	r4, r4, #16
    f882:	f404 047f 	and.w	r4, r4, #16711680	; 0xff0000
    f886:	4321      	orrs	r1, r4
    f888:	9102      	str	r1, [sp, #8]
    pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, clientObj.vendorData);
    f88a:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
    f88c:	4628      	mov	r0, r5
    f88e:	4798      	blx	r3
}
    f890:	4638      	mov	r0, r7
    f892:	b007      	add	sp, #28
    f894:	bdf0      	pop	{r4, r5, r6, r7, pc}
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F00D1, 0x0300, 0x0000);
    f896:	2300      	movs	r3, #0
    f898:	f44f 7240 	mov.w	r2, #768	; 0x300
    f89c:	493d      	ldr	r1, [pc, #244]	; (f994 <DRV_EXTPHY_MIIConfigure+0x18c>)
    f89e:	a801      	add	r0, sp, #4
    f8a0:	f008 f9b4 	bl	17c0c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    f8a4:	e7dc      	b.n	f860 <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0084, 0xFFC0, 0x3380);
    f8a6:	f44f 534e 	mov.w	r3, #13184	; 0x3380
    f8aa:	f64f 72c0 	movw	r2, #65472	; 0xffc0
    f8ae:	493a      	ldr	r1, [pc, #232]	; (f998 <DRV_EXTPHY_MIIConfigure+0x190>)
    f8b0:	a801      	add	r0, sp, #4
    f8b2:	f008 f9ab 	bl	17c0c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    f8b6:	e7d3      	b.n	f860 <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0085, 0x000F, 0x0006);
    f8b8:	2306      	movs	r3, #6
    f8ba:	220f      	movs	r2, #15
    f8bc:	4937      	ldr	r1, [pc, #220]	; (f99c <DRV_EXTPHY_MIIConfigure+0x194>)
    f8be:	a801      	add	r0, sp, #4
    f8c0:	f008 f9a4 	bl	17c0c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    f8c4:	e7cc      	b.n	f860 <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F008A, 0xF800, 0xC000);
    f8c6:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    f8ca:	f44f 4278 	mov.w	r2, #63488	; 0xf800
    f8ce:	4934      	ldr	r1, [pc, #208]	; (f9a0 <DRV_EXTPHY_MIIConfigure+0x198>)
    f8d0:	a801      	add	r0, sp, #4
    f8d2:	f008 f99b 	bl	17c0c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    f8d6:	e7c3      	b.n	f860 <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0087, 0x801C, 0x801C);
    f8d8:	f248 031c 	movw	r3, #32796	; 0x801c
    f8dc:	461a      	mov	r2, r3
    f8de:	4931      	ldr	r1, [pc, #196]	; (f9a4 <DRV_EXTPHY_MIIConfigure+0x19c>)
    f8e0:	a801      	add	r0, sp, #4
    f8e2:	f008 f993 	bl	17c0c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    f8e6:	e7bb      	b.n	f860 <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0088, 0x1FFF, 0x033F);
    f8e8:	f240 333f 	movw	r3, #831	; 0x33f
    f8ec:	f641 72ff 	movw	r2, #8191	; 0x1fff
    f8f0:	492d      	ldr	r1, [pc, #180]	; (f9a8 <DRV_EXTPHY_MIIConfigure+0x1a0>)
    f8f2:	a801      	add	r0, sp, #4
    f8f4:	f008 f98a 	bl	17c0c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    f8f8:	e7b2      	b.n	f860 <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F008B, 0xFFFF, 0x0404);
    f8fa:	f240 4304 	movw	r3, #1028	; 0x404
    f8fe:	f64f 72ff 	movw	r2, #65535	; 0xffff
    f902:	492a      	ldr	r1, [pc, #168]	; (f9ac <DRV_EXTPHY_MIIConfigure+0x1a4>)
    f904:	a801      	add	r0, sp, #4
    f906:	f008 f981 	bl	17c0c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    f90a:	e7a9      	b.n	f860 <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0080, 0x0600, 0x0600);
    f90c:	f44f 63c0 	mov.w	r3, #1536	; 0x600
    f910:	461a      	mov	r2, r3
    f912:	4927      	ldr	r1, [pc, #156]	; (f9b0 <DRV_EXTPHY_MIIConfigure+0x1a8>)
    f914:	a801      	add	r0, sp, #4
    f916:	f008 f979 	bl	17c0c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    f91a:	e7a1      	b.n	f860 <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F00F1, 0x7F00, 0x2400);
    f91c:	f44f 5310 	mov.w	r3, #9216	; 0x2400
    f920:	f44f 42fe 	mov.w	r2, #32512	; 0x7f00
    f924:	4923      	ldr	r1, [pc, #140]	; (f9b4 <DRV_EXTPHY_MIIConfigure+0x1ac>)
    f926:	a801      	add	r0, sp, #4
    f928:	f008 f970 	bl	17c0c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    f92c:	e798      	b.n	f860 <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0096, 0x2000, 0x2000);
    f92e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    f932:	461a      	mov	r2, r3
    f934:	4920      	ldr	r1, [pc, #128]	; (f9b8 <DRV_EXTPHY_MIIConfigure+0x1b0>)
    f936:	a801      	add	r0, sp, #4
    f938:	f008 f968 	bl	17c0c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    f93c:	e790      	b.n	f860 <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Bit_Register(&clientObj, 0x1F0099, 0xFFFF, 0x7F80);
    f93e:	f44f 43ff 	mov.w	r3, #32640	; 0x7f80
    f942:	f64f 72ff 	movw	r2, #65535	; 0xffff
    f946:	491d      	ldr	r1, [pc, #116]	; (f9bc <DRV_EXTPHY_MIIConfigure+0x1b4>)
    f948:	a801      	add	r0, sp, #4
    f94a:	f008 f95f 	bl	17c0c <Lan867x_Write_Bit_Register>
    if (inProgress == true) {
    f94e:	e787      	b.n	f860 <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Register(&clientObj, PHY_PLCA_BURST, registerValue);
    f950:	2200      	movs	r2, #0
    f952:	491b      	ldr	r1, [pc, #108]	; (f9c0 <DRV_EXTPHY_MIIConfigure+0x1b8>)
    f954:	a801      	add	r0, sp, #4
    f956:	f00d fb03 	bl	1cf60 <Lan867x_Write_Register>
    if (inProgress == true) {
    f95a:	e781      	b.n	f860 <DRV_EXTPHY_MIIConfigure+0x58>
        miimRes = Lan867x_Write_Register(&clientObj, PHY_PLCA_CONTROL_1, registerValue);
    f95c:	f640 0201 	movw	r2, #2049	; 0x801
    f960:	4918      	ldr	r1, [pc, #96]	; (f9c4 <DRV_EXTPHY_MIIConfigure+0x1bc>)
    f962:	a801      	add	r0, sp, #4
    f964:	f00d fafc 	bl	1cf60 <Lan867x_Write_Register>
    if (inProgress == true) {
    f968:	e77a      	b.n	f860 <DRV_EXTPHY_MIIConfigure+0x58>
            Lan867x_Write_Register(&clientObj, PHY_PLCA_CONTROL_0, F2R_(1, PHY_PLCA_CTRL0_EN));
    f96a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    f96e:	4916      	ldr	r1, [pc, #88]	; (f9c8 <DRV_EXTPHY_MIIConfigure+0x1c0>)
    f970:	a801      	add	r0, sp, #4
    f972:	f00d faf5 	bl	1cf60 <Lan867x_Write_Register>
    if (inProgress == true) {
    f976:	e773      	b.n	f860 <DRV_EXTPHY_MIIConfigure+0x58>
        ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->operRes = DRV_ETHPHY_RES_OK;
    f978:	2700      	movs	r7, #0
    f97a:	f885 702c 	strb.w	r7, [r5, #44]	; 0x2c
        ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->miimOpHandle = 0;
    f97e:	61af      	str	r7, [r5, #24]
        ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
    f980:	86af      	strh	r7, [r5, #52]	; 0x34
    if (inProgress == true) {
    f982:	e77a      	b.n	f87a <DRV_EXTPHY_MIIConfigure+0x72>
            res = DRV_ETHPHY_RES_MIIM_ERR;
    f984:	f06f 070c 	mvn.w	r7, #12
    f988:	e777      	b.n	f87a <DRV_EXTPHY_MIIConfigure+0x72>
            res = DRV_ETHPHY_RES_PENDING;
    f98a:	2701      	movs	r7, #1
    f98c:	e775      	b.n	f87a <DRV_EXTPHY_MIIConfigure+0x72>
    f98e:	bf00      	nop
    f990:	001f00d0 	.word	0x001f00d0
    f994:	001f00d1 	.word	0x001f00d1
    f998:	001f0084 	.word	0x001f0084
    f99c:	001f0085 	.word	0x001f0085
    f9a0:	001f008a 	.word	0x001f008a
    f9a4:	001f0087 	.word	0x001f0087
    f9a8:	001f0088 	.word	0x001f0088
    f9ac:	001f008b 	.word	0x001f008b
    f9b0:	001f0080 	.word	0x001f0080
    f9b4:	001f00f1 	.word	0x001f00f1
    f9b8:	001f0096 	.word	0x001f0096
    f9bc:	001f0099 	.word	0x001f0099
    f9c0:	001fca05 	.word	0x001fca05
    f9c4:	001fca02 	.word	0x001fca02
    f9c8:	001fca01 	.word	0x001fca01

Disassembly of section .text._DHCPSend%244:

0000f9cc <_DHCPSend>:
{
    f9cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f9d0:	b0d4      	sub	sp, #336	; 0x150
    f9d2:	4606      	mov	r6, r0
    f9d4:	460d      	mov	r5, r1
    f9d6:	4617      	mov	r7, r2
    f9d8:	4698      	mov	r8, r3
    s = dhcpClientSocket;
    f9da:	4b68      	ldr	r3, [pc, #416]	; (fb7c <_DHCPSend+0x1b0>)
    f9dc:	f9b3 4000 	ldrsh.w	r4, [r3]
    if(TCPIP_UDP_PutIsReady(s) < TCPIP_DHCP_MIN_UDP_TX_AVLBL_SIZE)
    f9e0:	4620      	mov	r0, r4
    f9e2:	f00c fe00 	bl	1c5e6 <TCPIP_UDP_PutIsReady>
    f9e6:	f5b0 7f96 	cmp.w	r0, #300	; 0x12c
    f9ea:	d338      	bcc.n	fa5e <_DHCPSend+0x92>
    TCPIP_UDP_SocketNetSet(s, pNetIf);
    f9ec:	4629      	mov	r1, r5
    f9ee:	4620      	mov	r0, r4
    f9f0:	f00e f810 	bl	1da14 <TCPIP_UDP_SocketNetSet>
    TCPIP_UDP_OptionsSet(s, UDP_OPTION_STRICT_NET, (void*)0);
    f9f4:	2200      	movs	r2, #0
    f9f6:	2101      	movs	r1, #1
    f9f8:	4620      	mov	r0, r4
    f9fa:	f7fe fe83 	bl	e704 <TCPIP_UDP_OptionsSet>
    if((dhcpFlags & TCPIP_DHCP_FLAG_SEND_BCAST) != 0 || pClient->serverAddress.Val == 0)
    f9fe:	f018 0f01 	tst.w	r8, #1
    fa02:	d101      	bne.n	fa08 <_DHCPSend+0x3c>
    fa04:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    fa06:	bb7b      	cbnz	r3, fa68 <_DHCPSend+0x9c>
        TCPIP_UDP_BcastIPV4AddressSet(s, UDP_BCAST_NETWORK_LIMITED, pNetIf);
    fa08:	462a      	mov	r2, r5
    fa0a:	2101      	movs	r1, #1
    fa0c:	4620      	mov	r0, r4
    fa0e:	f00b ff90 	bl	1b932 <TCPIP_UDP_BcastIPV4AddressSet>
    if((dhcpFlags & TCPIP_DHCP_FLAG_SEND_ZERO_ADD) != 0)
    fa12:	f018 0f02 	tst.w	r8, #2
    return pNetIf->netIPAddr.Val;
    fa16:	bf0c      	ite	eq
    fa18:	686b      	ldreq	r3, [r5, #4]
        sourceIp.Val = 0;
    fa1a:	2300      	movne	r3, #0
    fa1c:	9353      	str	r3, [sp, #332]	; 0x14c
    TCPIP_UDP_SourceIPAddressSet(s, IP_ADDRESS_TYPE_IPV4, (IP_MULTI_ADDRESS*) & sourceIp);
    fa1e:	aa53      	add	r2, sp, #332	; 0x14c
    fa20:	2101      	movs	r1, #1
    fa22:	4620      	mov	r0, r4
    fa24:	f00d fe15 	bl	1d652 <TCPIP_UDP_SourceIPAddressSet>
    newTransaction = (messageType == TCPIP_DHCP_DISCOVER_MESSAGE || messageType == TCPIP_DHCP_REQUEST_RENEW_MESSAGE || (messageType == TCPIP_DHCP_REQUEST_MESSAGE && pClient->dhcpOp == TCPIP_DHCP_OPER_INIT_REBOOT));
    fa28:	f027 0308 	bic.w	r3, r7, #8
    fa2c:	2b01      	cmp	r3, #1
    fa2e:	d032      	beq.n	fa96 <_DHCPSend+0xca>
    fa30:	2f03      	cmp	r7, #3
    fa32:	d13a      	bne.n	faaa <_DHCPSend+0xde>
    fa34:	f8b6 3054 	ldrh.w	r3, [r6, #84]	; 0x54
    fa38:	2b02      	cmp	r3, #2
    fa3a:	d02c      	beq.n	fa96 <_DHCPSend+0xca>
    memset(pDhcpHdr, 0, sizeof(*pDhcpHdr));
    fa3c:	222a      	movs	r2, #42	; 0x2a
    fa3e:	2100      	movs	r1, #0
    fa40:	f10d 0016 	add.w	r0, sp, #22
    fa44:	f012 f89a 	bl	21b7c <memset>
    pDhcpHdr->op = TCPIP_BOOT_REQUEST;
    fa48:	2301      	movs	r3, #1
    fa4a:	f88d 3014 	strb.w	r3, [sp, #20]
    pDhcpHdr->htype = TCPIP_BOOT_HW_TYPE;
    fa4e:	f88d 3015 	strb.w	r3, [sp, #21]
    pDhcpHdr->hlen = TCPIP_BOOT_LEN_OF_HW_TYPE;
    fa52:	2306      	movs	r3, #6
    fa54:	f88d 3016 	strb.w	r3, [sp, #22]
    pDhcpHdr->xid = pClient->transactionID.Val;
    fa58:	6c33      	ldr	r3, [r6, #64]	; 0x40
    fa5a:	9306      	str	r3, [sp, #24]
    if( messageType == TCPIP_DHCP_RELEASE_MESSAGE || messageType == TCPIP_DHCP_REQUEST_RENEW_MESSAGE) 
    fa5c:	e03b      	b.n	fad6 <_DHCPSend+0x10a>
        TCPIP_UDP_Flush(s); // discard old data that may be there
    fa5e:	4620      	mov	r0, r4
    fa60:	f7fe fa2c 	bl	debc <TCPIP_UDP_Flush>
        return false;
    fa64:	2000      	movs	r0, #0
    fa66:	e085      	b.n	fb74 <_DHCPSend+0x1a8>
        TCPIP_UDP_DestinationIPAddressSet(s, IP_ADDRESS_TYPE_IPV4, (IP_MULTI_ADDRESS*)&pClient->serverAddress);
    fa68:	f106 0228 	add.w	r2, r6, #40	; 0x28
    fa6c:	2101      	movs	r1, #1
    fa6e:	4620      	mov	r0, r4
    fa70:	f00c ff80 	bl	1c974 <TCPIP_UDP_DestinationIPAddressSet>
    fa74:	e7cd      	b.n	fa12 <_DHCPSend+0x46>
    fa76:	f00b f8bd 	bl	1abf4 <rand>
            pClient->transactionID.Val = SYS_RANDOM_PseudoGet(); 
    fa7a:	6430      	str	r0, [r6, #64]	; 0x40
    fa7c:	e00f      	b.n	fa9e <_DHCPSend+0xd2>
    return pNetIf ? pNetIf->netMACAddr.v : 0;
    fa7e:	462b      	mov	r3, r5
    fa80:	e02d      	b.n	fade <_DHCPSend+0x112>
        dhcpWriteData.writeBytes = TCPIP_DHCP_MIN_TX_FRAME_SIZE - sizeof (*pDhcpHdr) - sizeof(*pOptHdr);
    fa82:	2340      	movs	r3, #64	; 0x40
    fa84:	9303      	str	r3, [sp, #12]
    fa86:	e06b      	b.n	fb60 <_DHCPSend+0x194>
        TCPIP_UDP_TxOffsetSet(s , 0, false);
    fa88:	2200      	movs	r2, #0
    fa8a:	4611      	mov	r1, r2
    fa8c:	4620      	mov	r0, r4
    fa8e:	f00e f93e 	bl	1dd0e <TCPIP_UDP_TxOffsetSet>
        return false;
    fa92:	2000      	movs	r0, #0
    fa94:	e06e      	b.n	fb74 <_DHCPSend+0x1a8>
        if(pClient->flags.bRetry == false)
    fa96:	f996 3058 	ldrsb.w	r3, [r6, #88]	; 0x58
    fa9a:	2b00      	cmp	r3, #0
    fa9c:	daeb      	bge.n	fa76 <_DHCPSend+0xaa>
        pClient->flags.bOfferReceived = false;
    fa9e:	f896 3058 	ldrb.w	r3, [r6, #88]	; 0x58
    faa2:	f36f 0382 	bfc	r3, #2, #1
    faa6:	f886 3058 	strb.w	r3, [r6, #88]	; 0x58
    memset(pDhcpHdr, 0, sizeof(*pDhcpHdr));
    faaa:	222a      	movs	r2, #42	; 0x2a
    faac:	2100      	movs	r1, #0
    faae:	f10d 0016 	add.w	r0, sp, #22
    fab2:	f012 f863 	bl	21b7c <memset>
    pDhcpHdr->op = TCPIP_BOOT_REQUEST;
    fab6:	2301      	movs	r3, #1
    fab8:	f88d 3014 	strb.w	r3, [sp, #20]
    pDhcpHdr->htype = TCPIP_BOOT_HW_TYPE;
    fabc:	f88d 3015 	strb.w	r3, [sp, #21]
    pDhcpHdr->hlen = TCPIP_BOOT_LEN_OF_HW_TYPE;
    fac0:	2306      	movs	r3, #6
    fac2:	f88d 3016 	strb.w	r3, [sp, #22]
    pDhcpHdr->xid = pClient->transactionID.Val;
    fac6:	6c33      	ldr	r3, [r6, #64]	; 0x40
    fac8:	9306      	str	r3, [sp, #24]
    if( messageType == TCPIP_DHCP_RELEASE_MESSAGE || messageType == TCPIP_DHCP_REQUEST_RENEW_MESSAGE) 
    faca:	2f07      	cmp	r7, #7
    facc:	d001      	beq.n	fad2 <_DHCPSend+0x106>
    face:	2f09      	cmp	r7, #9
    fad0:	d101      	bne.n	fad6 <_DHCPSend+0x10a>
        pDhcpHdr->ciaddr = pClient->dhcpIPAddress.Val;
    fad2:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    fad4:	9308      	str	r3, [sp, #32]
    fad6:	2d00      	cmp	r5, #0
    fad8:	d0d1      	beq.n	fa7e <_DHCPSend+0xb2>
    fada:	f105 033c 	add.w	r3, r5, #60	; 0x3c
    memcpy(pDhcpHdr->chaddr, _TCPIPStack_NetMACAddressGet(pNetIf), sizeof(TCPIP_MAC_ADDR));
    fade:	6818      	ldr	r0, [r3, #0]
    fae0:	900c      	str	r0, [sp, #48]	; 0x30
    fae2:	889b      	ldrh	r3, [r3, #4]
    fae4:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
    TCPIP_UDP_ArrayPut(s, (uint8_t*)pDhcpHdr, sizeof (*pDhcpHdr));
    fae8:	222c      	movs	r2, #44	; 0x2c
    faea:	a905      	add	r1, sp, #20
    faec:	4620      	mov	r0, r4
    faee:	f00c ff1c 	bl	1c92a <TCPIP_UDP_ArrayPut>
    memset(pOptHdr, 0, sizeof(*pOptHdr));
    faf2:	26c0      	movs	r6, #192	; 0xc0
    faf4:	4632      	mov	r2, r6
    faf6:	2100      	movs	r1, #0
    faf8:	a805      	add	r0, sp, #20
    fafa:	f012 f83f 	bl	21b7c <memset>
    TCPIP_UDP_ArrayPut(s, (uint8_t*)pOptHdr, sizeof(*pOptHdr));
    fafe:	4632      	mov	r2, r6
    fb00:	a905      	add	r1, sp, #20
    fb02:	4620      	mov	r0, r4
    fb04:	f00c ff11 	bl	1c92a <TCPIP_UDP_ArrayPut>
    memset(pDOpt, 0, sizeof(*pDOpt));
    fb08:	f44f 729c 	mov.w	r2, #312	; 0x138
    fb0c:	2100      	movs	r1, #0
    fb0e:	a805      	add	r0, sp, #20
    fb10:	f012 f834 	bl	21b7c <memset>
    memcpy(pDOpt->cookie, dhcpMagicCookie, sizeof(pDOpt->cookie)); 
    fb14:	4b1a      	ldr	r3, [pc, #104]	; (fb80 <_DHCPSend+0x1b4>)
    fb16:	681b      	ldr	r3, [r3, #0]
    fb18:	9305      	str	r3, [sp, #20]
    dhcpWriteData.pOpt = pDOpt->options;
    fb1a:	ab06      	add	r3, sp, #24
    fb1c:	9301      	str	r3, [sp, #4]
    dhcpWriteData.writeSpace = TCPIP_UDP_PutIsReady(s) - sizeof(pDOpt->cookie);
    fb1e:	4620      	mov	r0, r4
    fb20:	f00c fd61 	bl	1c5e6 <TCPIP_UDP_PutIsReady>
    fb24:	3804      	subs	r0, #4
    fb26:	9002      	str	r0, [sp, #8]
    dhcpWriteData.writeBytes = sizeof(pDOpt->cookie);
    fb28:	2304      	movs	r3, #4
    fb2a:	9303      	str	r3, [sp, #12]
    dhcpWriteData.msgType = messageType;
    fb2c:	9704      	str	r7, [sp, #16]
    for(optIx = 0; optIx < sizeof(_DHCPOptWriteTbl) / sizeof(*_DHCPOptWriteTbl); optIx++, pEntry++)
    fb2e:	4f15      	ldr	r7, [pc, #84]	; (fb84 <_DHCPSend+0x1b8>)
    fb30:	1f3e      	subs	r6, r7, #4
    fb32:	3718      	adds	r7, #24
        optSize = (*pEntry->dhcpWriteFnc)(pNetIf, pSendData);
    fb34:	f856 3f04 	ldr.w	r3, [r6, #4]!
    fb38:	a901      	add	r1, sp, #4
    fb3a:	4628      	mov	r0, r5
    fb3c:	4798      	blx	r3
        if(optSize < 0)
    fb3e:	2800      	cmp	r0, #0
    fb40:	dba2      	blt.n	fa88 <_DHCPSend+0xbc>
        pSendData->writeSpace -= optSize;
    fb42:	9b02      	ldr	r3, [sp, #8]
    fb44:	1a1b      	subs	r3, r3, r0
    fb46:	9302      	str	r3, [sp, #8]
        pSendData->writeBytes += optSize;
    fb48:	9b03      	ldr	r3, [sp, #12]
    fb4a:	4403      	add	r3, r0
    fb4c:	9303      	str	r3, [sp, #12]
        pSendData->pOpt += optSize;
    fb4e:	9a01      	ldr	r2, [sp, #4]
    fb50:	4402      	add	r2, r0
    fb52:	9201      	str	r2, [sp, #4]
    for(optIx = 0; optIx < sizeof(_DHCPOptWriteTbl) / sizeof(*_DHCPOptWriteTbl); optIx++, pEntry++)
    fb54:	42b7      	cmp	r7, r6
    fb56:	d1ed      	bne.n	fb34 <_DHCPSend+0x168>
    if(sizeof (*pDhcpHdr) + sizeof(*pOptHdr) + dhcpWriteData.writeBytes < TCPIP_DHCP_MIN_TX_FRAME_SIZE)
    fb58:	33ec      	adds	r3, #236	; 0xec
    fb5a:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
    fb5e:	d390      	bcc.n	fa82 <_DHCPSend+0xb6>
    TCPIP_UDP_ArrayPut(s, pDOpt->cookie, dhcpWriteData.writeBytes);
    fb60:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    fb64:	a905      	add	r1, sp, #20
    fb66:	4620      	mov	r0, r4
    fb68:	f00c fedf 	bl	1c92a <TCPIP_UDP_ArrayPut>
    TCPIP_UDP_Flush(s);
    fb6c:	4620      	mov	r0, r4
    fb6e:	f7fe f9a5 	bl	debc <TCPIP_UDP_Flush>
    return true;
    fb72:	2001      	movs	r0, #1
}
    fb74:	b054      	add	sp, #336	; 0x150
    fb76:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    fb7a:	bf00      	nop
    fb7c:	2000e720 	.word	0x2000e720
    fb80:	00022140 	.word	0x00022140
    fb84:	00020ddc 	.word	0x00020ddc

Disassembly of section .text.DRV_GMAC_PacketRx%245:

0000fb88 <DRV_GMAC_PacketRx>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
    fb88:	4b69      	ldr	r3, [pc, #420]	; (fd30 <DRV_GMAC_PacketRx+0x1a8>)
    fb8a:	4283      	cmp	r3, r0
    fb8c:	f040 80b0 	bne.w	fcf0 <DRV_GMAC_PacketRx+0x168>
    if(pMACDrv == 0)
    fb90:	2800      	cmp	r0, #0
    fb92:	f000 80af 	beq.w	fcf4 <DRV_GMAC_PacketRx+0x16c>
{
    fb96:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    fb9a:	b086      	sub	sp, #24
    fb9c:	4690      	mov	r8, r2
    fb9e:	468a      	mov	sl, r1
	TCPIP_MAC_PACKET		*pRxPkt = NULL;
    fba0:	2300      	movs	r3, #0
    fba2:	9305      	str	r3, [sp, #20]
	DRV_GMAC_RXDCPT_STATUS	pRxPktStat = {0};
    fba4:	9304      	str	r3, [sp, #16]
	int                     buffsPerRxPkt = 0;
    fba6:	9303      	str	r3, [sp, #12]
    queueIndex = DRV_PIC32CGMAC_LibGetHighPrioReadyQue();      
    fba8:	f011 fe08 	bl	217bc <DRV_PIC32CGMAC_LibGetHighPrioReadyQue>
    fbac:	4b61      	ldr	r3, [pc, #388]	; (fd34 <DRV_GMAC_PacketRx+0x1ac>)
    fbae:	7018      	strb	r0, [r3, #0]
    while(queueIndex != DRV_GMAC_NO_ACTIVE_QUEUE)
    fbb0:	28ff      	cmp	r0, #255	; 0xff
    fbb2:	d025      	beq.n	fc00 <DRV_GMAC_PacketRx+0x78>
	if(pMACDrv->sGmacData._synchF != 0)
    fbb4:	4c5e      	ldr	r4, [pc, #376]	; (fd30 <DRV_GMAC_PacketRx+0x1a8>)
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
    fbb6:	f104 065c 	add.w	r6, r4, #92	; 0x5c
        ethRes = DRV_PIC32CGMAC_LibRxGetPacket (pMACDrv, &pRxPkt, &buffsPerRxPkt, &pRxPktStat, queueIndex);
    fbba:	461d      	mov	r5, r3
    fbbc:	e00b      	b.n	fbd6 <DRV_GMAC_PacketRx+0x4e>
        if(ethRes == DRV_PIC32CGMAC_RES_OK)
    fbbe:	2f00      	cmp	r7, #0
    fbc0:	f000 809e 	beq.w	fd00 <DRV_GMAC_PacketRx+0x178>
            DRV_PIC32CGMAC_LibClearPriorityQue(pMACDrv,queueIndex);
    fbc4:	7829      	ldrb	r1, [r5, #0]
    fbc6:	4620      	mov	r0, r4
    fbc8:	f00e fe12 	bl	1e7f0 <DRV_PIC32CGMAC_LibClearPriorityQue>
            queueIndex = DRV_PIC32CGMAC_LibGetHighPrioReadyQue();
    fbcc:	f011 fdf6 	bl	217bc <DRV_PIC32CGMAC_LibGetHighPrioReadyQue>
    fbd0:	7028      	strb	r0, [r5, #0]
    while(queueIndex != DRV_GMAC_NO_ACTIVE_QUEUE)
    fbd2:	28ff      	cmp	r0, #255	; 0xff
    fbd4:	d015      	beq.n	fc02 <DRV_GMAC_PacketRx+0x7a>
	if(pMACDrv->sGmacData._synchF != 0)
    fbd6:	6b23      	ldr	r3, [r4, #48]	; 0x30
    fbd8:	b113      	cbz	r3, fbe0 <DRV_GMAC_PacketRx+0x58>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
    fbda:	2105      	movs	r1, #5
    fbdc:	4630      	mov	r0, r6
    fbde:	4798      	blx	r3
        ethRes = DRV_PIC32CGMAC_LibRxGetPacket (pMACDrv, &pRxPkt, &buffsPerRxPkt, &pRxPktStat, queueIndex);
    fbe0:	782b      	ldrb	r3, [r5, #0]
    fbe2:	9300      	str	r3, [sp, #0]
    fbe4:	ab04      	add	r3, sp, #16
    fbe6:	aa03      	add	r2, sp, #12
    fbe8:	a905      	add	r1, sp, #20
    fbea:	4620      	mov	r0, r4
    fbec:	f7fa fcb4 	bl	a558 <DRV_PIC32CGMAC_LibRxGetPacket>
    fbf0:	4607      	mov	r7, r0
	if(pMACDrv->sGmacData._synchF != 0)
    fbf2:	6b23      	ldr	r3, [r4, #48]	; 0x30
    fbf4:	2b00      	cmp	r3, #0
    fbf6:	d0e2      	beq.n	fbbe <DRV_GMAC_PacketRx+0x36>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_LEAVE);
    fbf8:	2106      	movs	r1, #6
    fbfa:	4630      	mov	r0, r6
    fbfc:	4798      	blx	r3
    fbfe:	e7de      	b.n	fbbe <DRV_GMAC_PacketRx+0x36>
	DRV_PIC32CGMAC_RESULT	ethRes = DRV_PIC32CGMAC_RES_NO_PACKET;	
    fc00:	2701      	movs	r7, #1
	if(buffsPerRxPkt > 1)
    fc02:	9b03      	ldr	r3, [sp, #12]
    fc04:	2b01      	cmp	r3, #1
    fc06:	f340 8089 	ble.w	fd1c <DRV_GMAC_PacketRx+0x194>
        pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_SPLIT;
    fc0a:	9a05      	ldr	r2, [sp, #20]
    fc0c:	8c53      	ldrh	r3, [r2, #34]	; 0x22
    fc0e:	f043 0304 	orr.w	r3, r3, #4
    fc12:	8453      	strh	r3, [r2, #34]	; 0x22
	if(ethRes == DRV_PIC32CGMAC_RES_PACKET_QUEUED || ethRes == DRV_PIC32CGMAC_RES_NO_PACKET)
    fc14:	1e7b      	subs	r3, r7, #1
    fc16:	b2db      	uxtb	r3, r3
    fc18:	2b01      	cmp	r3, #1
    fc1a:	d81b      	bhi.n	fc54 <DRV_GMAC_PacketRx+0xcc>
		mRes = TCPIP_MAC_RES_PENDING;
    fc1c:	2301      	movs	r3, #1
	if(pRes)
    fc1e:	f1ba 0f00 	cmp.w	sl, #0
    fc22:	d06b      	beq.n	fcfc <DRV_GMAC_PacketRx+0x174>
		*pRes = mRes;
    fc24:	f88a 3000 	strb.w	r3, [sl]
	if(mRes == TCPIP_MAC_RES_OK)
    fc28:	2b00      	cmp	r3, #0
    fc2a:	d165      	bne.n	fcf8 <DRV_GMAC_PacketRx+0x170>
        pDSeg = pRxPkt->pDSeg;
    fc2c:	9c05      	ldr	r4, [sp, #20]
    fc2e:	6921      	ldr	r1, [r4, #16]
        pDSeg->segLoad = pDSeg->segBuffer + pMACDrv->sGmacData._dataOffset;
    fc30:	4b3f      	ldr	r3, [pc, #252]	; (fd30 <DRV_GMAC_PacketRx+0x1a8>)
    fc32:	f893 20f6 	ldrb.w	r2, [r3, #246]	; 0xf6
    fc36:	684b      	ldr	r3, [r1, #4]
    fc38:	4413      	add	r3, r2
    fc3a:	608b      	str	r3, [r1, #8]
        pDSeg->segLen = pDSeg->segLen - sizeof(TCPIP_MAC_ETHERNET_HEADER);
    fc3c:	898a      	ldrh	r2, [r1, #12]
    fc3e:	3a0e      	subs	r2, #14
    fc40:	b292      	uxth	r2, r2
    fc42:	818a      	strh	r2, [r1, #12]
        if(pDSeg->next)
    fc44:	680b      	ldr	r3, [r1, #0]
    fc46:	b1d3      	cbz	r3, fc7e <DRV_GMAC_PacketRx+0xf6>
            pDSeg->segLen = pDSeg->segLen - pMACDrv->sGmacData._dataOffset;
    fc48:	4839      	ldr	r0, [pc, #228]	; (fd30 <DRV_GMAC_PacketRx+0x1a8>)
    fc4a:	f890 00f6 	ldrb.w	r0, [r0, #246]	; 0xf6
    fc4e:	1a12      	subs	r2, r2, r0
    fc50:	818a      	strh	r2, [r1, #12]
            while (pDSeg->next)
    fc52:	e009      	b.n	fc68 <DRV_GMAC_PacketRx+0xe0>
	else if(ethRes == DRV_PIC32CGMAC_RES_OK)
    fc54:	2f00      	cmp	r7, #0
    fc56:	d056      	beq.n	fd06 <DRV_GMAC_PacketRx+0x17e>
		pMACDrv->sGmacData._rxStat.nRxErrorPackets++;
    fc58:	4a35      	ldr	r2, [pc, #212]	; (fd30 <DRV_GMAC_PacketRx+0x1a8>)
    fc5a:	6f13      	ldr	r3, [r2, #112]	; 0x70
    fc5c:	3301      	adds	r3, #1
    fc5e:	6713      	str	r3, [r2, #112]	; 0x70
		mRes = TCPIP_MAC_RES_PACKET_ERR;
    fc60:	f06f 0309 	mvn.w	r3, #9
    fc64:	e7db      	b.n	fc1e <DRV_GMAC_PacketRx+0x96>
            while (pDSeg->next)
    fc66:	4613      	mov	r3, r2
                pDSeg->segLoad = pDSeg->segBuffer;                
    fc68:	685a      	ldr	r2, [r3, #4]
    fc6a:	609a      	str	r2, [r3, #8]
            while (pDSeg->next)
    fc6c:	681a      	ldr	r2, [r3, #0]
    fc6e:	2a00      	cmp	r2, #0
    fc70:	d1f9      	bne.n	fc66 <DRV_GMAC_PacketRx+0xde>
            pDSeg->segLen = pDSeg->segLen + pMACDrv->sGmacData._dataOffset;
    fc72:	4a2f      	ldr	r2, [pc, #188]	; (fd30 <DRV_GMAC_PacketRx+0x1a8>)
    fc74:	f892 20f6 	ldrb.w	r2, [r2, #246]	; 0xf6
    fc78:	8999      	ldrh	r1, [r3, #12]
    fc7a:	440a      	add	r2, r1
    fc7c:	819a      	strh	r2, [r3, #12]
		pRxPkt->pMacLayer = pRxPkt->pDSeg->segLoad;
    fc7e:	6923      	ldr	r3, [r4, #16]
    fc80:	689b      	ldr	r3, [r3, #8]
    fc82:	6163      	str	r3, [r4, #20]
		pRxPkt->pNetLayer = pRxPkt->pMacLayer + sizeof(TCPIP_MAC_ETHERNET_HEADER);
    fc84:	330e      	adds	r3, #14
    fc86:	61a3      	str	r3, [r4, #24]
		pRxPkt->tStamp = SYS_TMR_TickCountGet();
    fc88:	f010 f990 	bl	1ffac <SYS_TMR_TickCountGet>
    fc8c:	6260      	str	r0, [r4, #36]	; 0x24
		pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_QUEUED;
    fc8e:	9c05      	ldr	r4, [sp, #20]
		pRxPkt->pktFlags &= ~TCPIP_MAC_PKT_FLAG_CAST_MASK;
    fc90:	8c63      	ldrh	r3, [r4, #34]	; 0x22
    fc92:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    fc96:	b29b      	uxth	r3, r3
    fc98:	f043 0208 	orr.w	r2, r3, #8
    fc9c:	8462      	strh	r2, [r4, #34]	; 0x22
		if(pRxPktStat.bm.bBroadcastDetected)
    fc9e:	f89d 2013 	ldrb.w	r2, [sp, #19]
    fca2:	f012 0f80 	tst.w	r2, #128	; 0x80
    fca6:	d106      	bne.n	fcb6 <DRV_GMAC_PacketRx+0x12e>
		else if(pRxPktStat.bm.bMultiHashMatch)
    fca8:	f012 0f40 	tst.w	r2, #64	; 0x40
    fcac:	d019      	beq.n	fce2 <DRV_GMAC_PacketRx+0x15a>
			pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_MCAST;
    fcae:	f043 0348 	orr.w	r3, r3, #72	; 0x48
    fcb2:	8463      	strh	r3, [r4, #34]	; 0x22
    fcb4:	e002      	b.n	fcbc <DRV_GMAC_PacketRx+0x134>
			pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_BCAST;
    fcb6:	f043 0328 	orr.w	r3, r3, #40	; 0x28
    fcba:	8463      	strh	r3, [r4, #34]	; 0x22
		if(pPktStat)
    fcbc:	f1b8 0f00 	cmp.w	r8, #0
    fcc0:	d004      	beq.n	fccc <DRV_GMAC_PacketRx+0x144>
			*pPktStat = *(TCPIP_MAC_PACKET_RX_STAT*)&pRxPktStat;
    fcc2:	ab06      	add	r3, sp, #24
    fcc4:	e913 0003 	ldmdb	r3, {r0, r1}
    fcc8:	e888 0003 	stmia.w	r8, {r0, r1}
        pRxPkt->pktPriority = DRV_PIC32CGMAC_LibGetPriorityFromQueueNum(pMACDrv, queueIndex);
    fccc:	4b19      	ldr	r3, [pc, #100]	; (fd34 <DRV_GMAC_PacketRx+0x1ac>)
    fcce:	7819      	ldrb	r1, [r3, #0]
    fcd0:	4817      	ldr	r0, [pc, #92]	; (fd30 <DRV_GMAC_PacketRx+0x1a8>)
    fcd2:	f012 fa2c 	bl	2212e <DRV_PIC32CGMAC_LibGetPriorityFromQueueNum>
    fcd6:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
		return pRxPkt;
    fcda:	9805      	ldr	r0, [sp, #20]
}
    fcdc:	b006      	add	sp, #24
    fcde:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		else if(pRxPktStat.bm.bUniHashMatch)
    fce2:	f012 0f20 	tst.w	r2, #32
			pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_UNICAST;
    fce6:	bf1c      	itt	ne
    fce8:	f043 0318 	orrne.w	r3, r3, #24
    fcec:	8463      	strhne	r3, [r4, #34]	; 0x22
    fcee:	e7e5      	b.n	fcbc <DRV_GMAC_PacketRx+0x134>
        return 0;
    fcf0:	2000      	movs	r0, #0
    fcf2:	4770      	bx	lr
    fcf4:	2000      	movs	r0, #0
}
    fcf6:	4770      	bx	lr
    return 0;
    fcf8:	2000      	movs	r0, #0
    fcfa:	e7ef      	b.n	fcdc <DRV_GMAC_PacketRx+0x154>
    fcfc:	4650      	mov	r0, sl
    fcfe:	e7ed      	b.n	fcdc <DRV_GMAC_PacketRx+0x154>
	if(buffsPerRxPkt > 1)
    fd00:	9b03      	ldr	r3, [sp, #12]
    fd02:	2b01      	cmp	r3, #1
    fd04:	dc81      	bgt.n	fc0a <DRV_GMAC_PacketRx+0x82>
		pMACDrv->sGmacData._rxStat.nRxOkPackets++;		
    fd06:	4a0a      	ldr	r2, [pc, #40]	; (fd30 <DRV_GMAC_PacketRx+0x1a8>)
    fd08:	6e53      	ldr	r3, [r2, #100]	; 0x64
    fd0a:	3301      	adds	r3, #1
    fd0c:	6653      	str	r3, [r2, #100]	; 0x64
	if(pRes)
    fd0e:	f1ba 0f00 	cmp.w	sl, #0
    fd12:	d08b      	beq.n	fc2c <DRV_GMAC_PacketRx+0xa4>
		*pRes = mRes;
    fd14:	2300      	movs	r3, #0
    fd16:	f88a 3000 	strb.w	r3, [sl]
	if(mRes == TCPIP_MAC_RES_OK)
    fd1a:	e787      	b.n	fc2c <DRV_GMAC_PacketRx+0xa4>
	if(ethRes == DRV_PIC32CGMAC_RES_PACKET_QUEUED || ethRes == DRV_PIC32CGMAC_RES_NO_PACKET)
    fd1c:	f107 39ff 	add.w	r9, r7, #4294967295
    fd20:	fa5f f989 	uxtb.w	r9, r9
    fd24:	f1b9 0f01 	cmp.w	r9, #1
    fd28:	d896      	bhi.n	fc58 <DRV_GMAC_PacketRx+0xd0>
		mRes = TCPIP_MAC_RES_PENDING;
    fd2a:	2301      	movs	r3, #1
    fd2c:	e777      	b.n	fc1e <DRV_GMAC_PacketRx+0x96>
    fd2e:	bf00      	nop
    fd30:	2000dab8 	.word	0x2000dab8
    fd34:	2000e38f 	.word	0x2000e38f

Disassembly of section .text.DRV_PIC32CGMAC_LibRxFilterHash_Calculate%246:

0000fd38 <DRV_PIC32CGMAC_LibRxFilterHash_Calculate>:
    if(hash->calculate_hash == true) // Calculate hash for given MAC address
    fd38:	7b0b      	ldrb	r3, [r1, #12]
    fd3a:	2b01      	cmp	r3, #1
    fd3c:	d008      	beq.n	fd50 <DRV_PIC32CGMAC_LibRxFilterHash_Calculate+0x18>
        hash_value = hash->hash_value;
    fd3e:	680b      	ldr	r3, [r1, #0]
    fd40:	6849      	ldr	r1, [r1, #4]
    GMAC_REGS->GMAC_HRB = hash_value & 0xffffffff;
    fd42:	4a68      	ldr	r2, [pc, #416]	; (fee4 <DRV_PIC32CGMAC_LibRxFilterHash_Calculate+0x1ac>)
    fd44:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
    GMAC_REGS->GMAC_HRT = (hash_value >> 32) & 0xffffffff;    
    fd48:	f8c2 1084 	str.w	r1, [r2, #132]	; 0x84
}
    fd4c:	2000      	movs	r0, #0
    fd4e:	4770      	bx	lr
{
    fd50:	b4f0      	push	{r4, r5, r6, r7}
        mac_addr = (DRV_GMAC_MAC_ADDR*)(hash->DestMACAddr);
    fd52:	6888      	ldr	r0, [r1, #8]
        hash_Index.index = 0;      
    fd54:	f04f 0100 	mov.w	r1, #0
        hash_Index.bits.b0 = (mac_addr[5].bits.b0)^(mac_addr[5].bits.b6)^(mac_addr[4].bits.b4)^(mac_addr[3].bits.b2)^(mac_addr[2].bits.b0)^(mac_addr[2].bits.b6)^(mac_addr[1].bits.b4)^(mac_addr[0].bits.b2);
    fd58:	7943      	ldrb	r3, [r0, #5]
    fd5a:	f3c3 0200 	ubfx	r2, r3, #0, #1
    fd5e:	f3c3 1480 	ubfx	r4, r3, #6, #1
    fd62:	4062      	eors	r2, r4
    fd64:	7907      	ldrb	r7, [r0, #4]
    fd66:	f3c7 1400 	ubfx	r4, r7, #4, #1
    fd6a:	4062      	eors	r2, r4
    fd6c:	78c6      	ldrb	r6, [r0, #3]
    fd6e:	f3c6 0480 	ubfx	r4, r6, #2, #1
    fd72:	4062      	eors	r2, r4
    fd74:	7885      	ldrb	r5, [r0, #2]
    fd76:	f3c5 0400 	ubfx	r4, r5, #0, #1
    fd7a:	4062      	eors	r2, r4
    fd7c:	f3c5 1480 	ubfx	r4, r5, #6, #1
    fd80:	4062      	eors	r2, r4
    fd82:	7844      	ldrb	r4, [r0, #1]
    fd84:	f3c4 1c00 	ubfx	ip, r4, #4, #1
    fd88:	ea82 020c 	eor.w	r2, r2, ip
    fd8c:	7800      	ldrb	r0, [r0, #0]
    fd8e:	f3c0 0c80 	ubfx	ip, r0, #2, #1
    fd92:	ea82 020c 	eor.w	r2, r2, ip
    fd96:	f362 0100 	bfi	r1, r2, #0, #1
        hash_Index.bits.b1 = (mac_addr[5].bits.b1)^(mac_addr[5].bits.b7)^(mac_addr[4].bits.b5)^(mac_addr[3].bits.b3)^(mac_addr[2].bits.b1)^(mac_addr[2].bits.b7)^(mac_addr[1].bits.b5)^(mac_addr[0].bits.b3);
    fd9a:	f3c3 0240 	ubfx	r2, r3, #1, #1
    fd9e:	f3c3 1cc0 	ubfx	ip, r3, #7, #1
    fda2:	ea82 020c 	eor.w	r2, r2, ip
    fda6:	f3c7 1c40 	ubfx	ip, r7, #5, #1
    fdaa:	ea82 020c 	eor.w	r2, r2, ip
    fdae:	f3c6 0cc0 	ubfx	ip, r6, #3, #1
    fdb2:	ea82 020c 	eor.w	r2, r2, ip
    fdb6:	f3c5 0c40 	ubfx	ip, r5, #1, #1
    fdba:	ea82 12d5 	eor.w	r2, r2, r5, lsr #7
    fdbe:	ea82 020c 	eor.w	r2, r2, ip
    fdc2:	f3c4 1c40 	ubfx	ip, r4, #5, #1
    fdc6:	ea82 020c 	eor.w	r2, r2, ip
    fdca:	f3c0 0cc0 	ubfx	ip, r0, #3, #1
    fdce:	ea82 020c 	eor.w	r2, r2, ip
    fdd2:	f362 0141 	bfi	r1, r2, #1, #1
        hash_Index.bits.b2 = (mac_addr[5].bits.b2)^(mac_addr[4].bits.b0)^(mac_addr[4].bits.b6)^(mac_addr[3].bits.b4)^(mac_addr[2].bits.b2)^(mac_addr[1].bits.b0)^(mac_addr[1].bits.b6)^(mac_addr[0].bits.b4);
    fdd6:	f3c3 0280 	ubfx	r2, r3, #2, #1
    fdda:	f3c7 0c00 	ubfx	ip, r7, #0, #1
    fdde:	ea82 020c 	eor.w	r2, r2, ip
    fde2:	f3c7 1c80 	ubfx	ip, r7, #6, #1
    fde6:	ea82 020c 	eor.w	r2, r2, ip
    fdea:	f3c6 1c00 	ubfx	ip, r6, #4, #1
    fdee:	ea82 020c 	eor.w	r2, r2, ip
    fdf2:	f3c5 0c80 	ubfx	ip, r5, #2, #1
    fdf6:	ea82 020c 	eor.w	r2, r2, ip
    fdfa:	f3c4 0c00 	ubfx	ip, r4, #0, #1
    fdfe:	ea82 020c 	eor.w	r2, r2, ip
    fe02:	f3c4 1c80 	ubfx	ip, r4, #6, #1
    fe06:	ea82 020c 	eor.w	r2, r2, ip
    fe0a:	f3c0 1c00 	ubfx	ip, r0, #4, #1
    fe0e:	ea82 020c 	eor.w	r2, r2, ip
    fe12:	f362 0182 	bfi	r1, r2, #2, #1
        hash_Index.bits.b3 = (mac_addr[5].bits.b3)^(mac_addr[4].bits.b1)^(mac_addr[4].bits.b7)^(mac_addr[3].bits.b5)^(mac_addr[2].bits.b3)^(mac_addr[1].bits.b1)^(mac_addr[1].bits.b7)^(mac_addr[0].bits.b5);
    fe16:	f3c3 02c0 	ubfx	r2, r3, #3, #1
    fe1a:	f3c7 0c40 	ubfx	ip, r7, #1, #1
    fe1e:	ea82 12d7 	eor.w	r2, r2, r7, lsr #7
    fe22:	ea82 020c 	eor.w	r2, r2, ip
    fe26:	f3c6 1c40 	ubfx	ip, r6, #5, #1
    fe2a:	ea82 020c 	eor.w	r2, r2, ip
    fe2e:	f3c5 0cc0 	ubfx	ip, r5, #3, #1
    fe32:	ea82 020c 	eor.w	r2, r2, ip
    fe36:	f3c4 0c40 	ubfx	ip, r4, #1, #1
    fe3a:	ea82 12d4 	eor.w	r2, r2, r4, lsr #7
    fe3e:	ea82 020c 	eor.w	r2, r2, ip
    fe42:	f3c0 1c40 	ubfx	ip, r0, #5, #1
    fe46:	ea82 020c 	eor.w	r2, r2, ip
    fe4a:	f362 01c3 	bfi	r1, r2, #3, #1
        hash_Index.bits.b4 = (mac_addr[5].bits.b4)^(mac_addr[4].bits.b2)^(mac_addr[3].bits.b0)^(mac_addr[3].bits.b6)^(mac_addr[2].bits.b4)^(mac_addr[1].bits.b2)^(mac_addr[0].bits.b0)^(mac_addr[0].bits.b6);
    fe4e:	f3c3 1200 	ubfx	r2, r3, #4, #1
    fe52:	f3c7 0c80 	ubfx	ip, r7, #2, #1
    fe56:	ea82 020c 	eor.w	r2, r2, ip
    fe5a:	f3c6 0c00 	ubfx	ip, r6, #0, #1
    fe5e:	ea82 020c 	eor.w	r2, r2, ip
    fe62:	f3c6 1c80 	ubfx	ip, r6, #6, #1
    fe66:	ea82 020c 	eor.w	r2, r2, ip
    fe6a:	f3c5 1c00 	ubfx	ip, r5, #4, #1
    fe6e:	ea82 020c 	eor.w	r2, r2, ip
    fe72:	f3c4 0c80 	ubfx	ip, r4, #2, #1
    fe76:	ea82 020c 	eor.w	r2, r2, ip
    fe7a:	f3c0 0c00 	ubfx	ip, r0, #0, #1
    fe7e:	ea82 020c 	eor.w	r2, r2, ip
    fe82:	f3c0 1c80 	ubfx	ip, r0, #6, #1
    fe86:	ea82 020c 	eor.w	r2, r2, ip
    fe8a:	f362 1104 	bfi	r1, r2, #4, #1
        hash_Index.bits.b5 = (mac_addr[5].bits.b5)^(mac_addr[4].bits.b3)^(mac_addr[3].bits.b1)^(mac_addr[3].bits.b7)^(mac_addr[2].bits.b5)^(mac_addr[1].bits.b3)^(mac_addr[0].bits.b1)^(mac_addr[0].bits.b7);
    fe8e:	f3c3 1340 	ubfx	r3, r3, #5, #1
    fe92:	f3c7 07c0 	ubfx	r7, r7, #3, #1
    fe96:	407b      	eors	r3, r7
    fe98:	f3c6 0240 	ubfx	r2, r6, #1, #1
    fe9c:	ea83 13d6 	eor.w	r3, r3, r6, lsr #7
    fea0:	4053      	eors	r3, r2
    fea2:	f3c5 1540 	ubfx	r5, r5, #5, #1
    fea6:	406b      	eors	r3, r5
    fea8:	f3c4 04c0 	ubfx	r4, r4, #3, #1
    feac:	4063      	eors	r3, r4
    feae:	f3c0 0240 	ubfx	r2, r0, #1, #1
    feb2:	ea83 13d0 	eor.w	r3, r3, r0, lsr #7
    feb6:	4053      	eors	r3, r2
    feb8:	f363 1145 	bfi	r1, r3, #5, #1
    hash_value = GMAC_REGS->GMAC_HRT;
    febc:	4b09      	ldr	r3, [pc, #36]	; (fee4 <DRV_PIC32CGMAC_LibRxFilterHash_Calculate+0x1ac>)
    febe:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
    hash_value = (hash_value << 32) | GMAC_REGS->GMAC_HRB;
    fec2:	f8d3 4080 	ldr.w	r4, [r3, #128]	; 0x80
        hash_value  |= (1 << (hash_Index.index));
    fec6:	b2c9      	uxtb	r1, r1
    fec8:	2301      	movs	r3, #1
    feca:	408b      	lsls	r3, r1
    fecc:	17d9      	asrs	r1, r3, #31
    fece:	4323      	orrs	r3, r4
    fed0:	4311      	orrs	r1, r2
    GMAC_REGS->GMAC_HRB = hash_value & 0xffffffff;
    fed2:	4a04      	ldr	r2, [pc, #16]	; (fee4 <DRV_PIC32CGMAC_LibRxFilterHash_Calculate+0x1ac>)
    fed4:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
    GMAC_REGS->GMAC_HRT = (hash_value >> 32) & 0xffffffff;    
    fed8:	f8c2 1084 	str.w	r1, [r2, #132]	; 0x84
}
    fedc:	2000      	movs	r0, #0
    fede:	bcf0      	pop	{r4, r5, r6, r7}
    fee0:	4770      	bx	lr
    fee2:	bf00      	nop
    fee4:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_ETHPHY_DefaultDetect%247:

0000fee8 <_DRV_ETHPHY_DefaultDetect>:
}


// default PHY detection procedure
static DRV_ETHPHY_RESULT _DRV_ETHPHY_DefaultDetect( const struct DRV_ETHPHY_OBJECT_BASE_TYPE* pBaseObj, DRV_HANDLE hClientObj)
{
    fee8:	b570      	push	{r4, r5, r6, lr}
    feea:	b084      	sub	sp, #16
    feec:	4605      	mov	r5, r0
    feee:	460c      	mov	r4, r1
            uint16_t high;
        };
    }vendorData;

    __BMCONbits_t bmcon;
    uint16_t    phyReg = 0;
    fef0:	2300      	movs	r3, #0
    fef2:	f8ad 300a 	strh.w	r3, [sp, #10]
    uint16_t    detectPhase = 0;
    int         phyAddress = 0;
    fef6:	9301      	str	r3, [sp, #4]

    DRV_ETHPHY_RESULT res = pBaseObj->DRV_ETHPHY_VendorDataGet(hClientObj, &vendorData.w);
    fef8:	6c83      	ldr	r3, [r0, #72]	; 0x48
    fefa:	a903      	add	r1, sp, #12
    fefc:	4620      	mov	r0, r4
    fefe:	4798      	blx	r3

    if(res < 0)
    ff00:	2800      	cmp	r0, #0
    ff02:	db20      	blt.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
    {   // some error occurred
        return res;
    }

    pBaseObj->DRV_ETHPHY_PhyAddressGet(hClientObj, DRV_ETHPHY_INF_IDX_ALL_EXTERNAL, &phyAddress);
    ff04:	6aab      	ldr	r3, [r5, #40]	; 0x28
    ff06:	aa01      	add	r2, sp, #4
    ff08:	2100      	movs	r1, #0
    ff0a:	4620      	mov	r0, r4
    ff0c:	4798      	blx	r3

    _PhyDetectPhase(detectPhase);

    // try to detect the PHY and reset it

    switch (detectPhase)
    ff0e:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    ff12:	2b07      	cmp	r3, #7
    ff14:	f200 80b5 	bhi.w	10082 <_DRV_ETHPHY_DefaultDetect+0x19a>
    ff18:	e8df f003 	tbb	[pc, r3]
    ff1c:	48341704 	.word	0x48341704
    ff20:	9f8c765a 	.word	0x9f8c765a
    {
        case 0:
            // initiate a read of the BMCON register
            res = pBaseObj->DRV_ETHPHY_VendorSMIReadStart(hClientObj, PHY_REG_BMCON, phyAddress);
    ff24:	6d2b      	ldr	r3, [r5, #80]	; 0x50
    ff26:	9a01      	ldr	r2, [sp, #4]
    ff28:	2100      	movs	r1, #0
    ff2a:	4620      	mov	r0, r4
    ff2c:	4798      	blx	r3
            if(res < 0)
    ff2e:	2800      	cmp	r0, #0
    ff30:	db09      	blt.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            {   // some error
                return res;
            }
            else if(res == DRV_ETHPHY_RES_PENDING)
    ff32:	2801      	cmp	r0, #1
    ff34:	d007      	beq.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            {   // retry
                return DRV_ETHPHY_RES_PENDING;
            }

            // advance to the next phase
            vendorData.low = ++detectPhase;
    ff36:	2601      	movs	r6, #1
    ff38:	f8ad 600c 	strh.w	r6, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
    ff3c:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
    ff3e:	9903      	ldr	r1, [sp, #12]
    ff40:	4620      	mov	r0, r4
    ff42:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
    ff44:	4630      	mov	r0, r6

        default:
            // shouldn't happen
            return DRV_ETHPHY_RES_OPERATION_ERR;
    }
}
    ff46:	b004      	add	sp, #16
    ff48:	bd70      	pop	{r4, r5, r6, pc}
            res = pBaseObj->DRV_ETHPHY_VendorSMIReadResultGet(hClientObj, &phyReg);
    ff4a:	6d6b      	ldr	r3, [r5, #84]	; 0x54
    ff4c:	f10d 010a 	add.w	r1, sp, #10
    ff50:	4620      	mov	r0, r4
    ff52:	4798      	blx	r3
            if(res < 0)
    ff54:	2800      	cmp	r0, #0
    ff56:	dbf6      	blt.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
    ff58:	2801      	cmp	r0, #1
    ff5a:	d0f4      	beq.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            if(bmcon.RESET == 0)
    ff5c:	f99d 300b 	ldrsb.w	r3, [sp, #11]
    ff60:	2b00      	cmp	r3, #0
    ff62:	da06      	bge.n	ff72 <_DRV_ETHPHY_DefaultDetect+0x8a>
            vendorData.w = 0;
    ff64:	2100      	movs	r1, #0
    ff66:	9103      	str	r1, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
    ff68:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
    ff6a:	4620      	mov	r0, r4
    ff6c:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
    ff6e:	2001      	movs	r0, #1
    ff70:	e7e9      	b.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
                vendorData.low = ++detectPhase;
    ff72:	2302      	movs	r3, #2
    ff74:	f8ad 300c 	strh.w	r3, [sp, #12]
                pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
    ff78:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
    ff7a:	9903      	ldr	r1, [sp, #12]
    ff7c:	4620      	mov	r0, r4
    ff7e:	4798      	blx	r3
                return DRV_ETHPHY_RES_PENDING;
    ff80:	2001      	movs	r0, #1
    ff82:	e7e0      	b.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            res = pBaseObj->DRV_ETHPHY_VendorSMIWriteStart(hClientObj, PHY_REG_BMCON, bmcon.w, phyAddress);
    ff84:	6dae      	ldr	r6, [r5, #88]	; 0x58
    ff86:	9b01      	ldr	r3, [sp, #4]
    ff88:	f44f 4282 	mov.w	r2, #16640	; 0x4100
    ff8c:	2100      	movs	r1, #0
    ff8e:	4620      	mov	r0, r4
    ff90:	47b0      	blx	r6
            if(res < 0)
    ff92:	2800      	cmp	r0, #0
    ff94:	dbd7      	blt.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
    ff96:	2801      	cmp	r0, #1
    ff98:	d0d5      	beq.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            vendorData.low = ++detectPhase;
    ff9a:	2303      	movs	r3, #3
    ff9c:	f8ad 300c 	strh.w	r3, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
    ffa0:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
    ffa2:	9903      	ldr	r1, [sp, #12]
    ffa4:	4620      	mov	r0, r4
    ffa6:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
    ffa8:	2001      	movs	r0, #1
    ffaa:	e7cc      	b.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            res = pBaseObj->DRV_ETHPHY_VendorSMIReadStart(hClientObj, PHY_REG_BMCON, phyAddress);
    ffac:	6d2b      	ldr	r3, [r5, #80]	; 0x50
    ffae:	9a01      	ldr	r2, [sp, #4]
    ffb0:	2100      	movs	r1, #0
    ffb2:	4620      	mov	r0, r4
    ffb4:	4798      	blx	r3
            if(res < 0)
    ffb6:	2800      	cmp	r0, #0
    ffb8:	dbc5      	blt.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
    ffba:	2801      	cmp	r0, #1
    ffbc:	d0c3      	beq.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            vendorData.low = ++detectPhase;
    ffbe:	2304      	movs	r3, #4
    ffc0:	f8ad 300c 	strh.w	r3, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
    ffc4:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
    ffc6:	9903      	ldr	r1, [sp, #12]
    ffc8:	4620      	mov	r0, r4
    ffca:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
    ffcc:	2001      	movs	r0, #1
    ffce:	e7ba      	b.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            res = pBaseObj->DRV_ETHPHY_VendorSMIReadResultGet(hClientObj, &phyReg);
    ffd0:	6d6b      	ldr	r3, [r5, #84]	; 0x54
    ffd2:	f10d 010a 	add.w	r1, sp, #10
    ffd6:	4620      	mov	r0, r4
    ffd8:	4798      	blx	r3
            if(res < 0)
    ffda:	2800      	cmp	r0, #0
    ffdc:	dbb3      	blt.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
    ffde:	2801      	cmp	r0, #1
    ffe0:	d0b1      	beq.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            bmcon.w = phyReg;
    ffe2:	f8bd 200a 	ldrh.w	r2, [sp, #10]
            if( (bmcon.LOOPBACK == 0) || (bmcon.DUPLEX == 0) )
    ffe6:	f3c2 2307 	ubfx	r3, r2, #8, #8
    ffea:	f003 0341 	and.w	r3, r3, #65	; 0x41
    ffee:	2b41      	cmp	r3, #65	; 0x41
    fff0:	d14a      	bne.n	10088 <_DRV_ETHPHY_DefaultDetect+0x1a0>
            vendorData.high = phyReg;
    fff2:	f8ad 200e 	strh.w	r2, [sp, #14]
            vendorData.low = ++detectPhase;
    fff6:	2305      	movs	r3, #5
    fff8:	f8ad 300c 	strh.w	r3, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
    fffc:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
    fffe:	9903      	ldr	r1, [sp, #12]
   10000:	4620      	mov	r0, r4
   10002:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
   10004:	2001      	movs	r0, #1
   10006:	e79e      	b.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            bmcon.w ^= _BMCON_LOOPBACK_MASK | _BMCON_DUPLEX_MASK;
   10008:	f8bd 200e 	ldrh.w	r2, [sp, #14]
            res = pBaseObj->DRV_ETHPHY_VendorSMIWriteStart(hClientObj, PHY_REG_BMCON, bmcon.w, phyAddress);
   1000c:	6dae      	ldr	r6, [r5, #88]	; 0x58
   1000e:	9b01      	ldr	r3, [sp, #4]
   10010:	f482 4282 	eor.w	r2, r2, #16640	; 0x4100
   10014:	2100      	movs	r1, #0
   10016:	4620      	mov	r0, r4
   10018:	47b0      	blx	r6
            if(res < 0)
   1001a:	2800      	cmp	r0, #0
   1001c:	db93      	blt.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
   1001e:	2801      	cmp	r0, #1
   10020:	d091      	beq.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            vendorData.low = ++detectPhase;
   10022:	2306      	movs	r3, #6
   10024:	f8ad 300c 	strh.w	r3, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
   10028:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   1002a:	9903      	ldr	r1, [sp, #12]
   1002c:	4620      	mov	r0, r4
   1002e:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
   10030:	2001      	movs	r0, #1
   10032:	e788      	b.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            res = pBaseObj->DRV_ETHPHY_VendorSMIReadStart(hClientObj, PHY_REG_BMCON, phyAddress);
   10034:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   10036:	9a01      	ldr	r2, [sp, #4]
   10038:	2100      	movs	r1, #0
   1003a:	4620      	mov	r0, r4
   1003c:	4798      	blx	r3
            if(res < 0)
   1003e:	2800      	cmp	r0, #0
   10040:	db81      	blt.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
   10042:	2801      	cmp	r0, #1
   10044:	f43f af7f 	beq.w	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            vendorData.low = ++detectPhase;
   10048:	2307      	movs	r3, #7
   1004a:	f8ad 300c 	strh.w	r3, [sp, #12]
            pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, vendorData.w);
   1004e:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   10050:	9903      	ldr	r1, [sp, #12]
   10052:	4620      	mov	r0, r4
   10054:	4798      	blx	r3
            return DRV_ETHPHY_RES_PENDING;
   10056:	2001      	movs	r0, #1
   10058:	e775      	b.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            res = pBaseObj->DRV_ETHPHY_VendorSMIReadResultGet(hClientObj, &phyReg);
   1005a:	6d6b      	ldr	r3, [r5, #84]	; 0x54
   1005c:	f10d 010a 	add.w	r1, sp, #10
   10060:	4620      	mov	r0, r4
   10062:	4798      	blx	r3
            if(res < 0)
   10064:	2800      	cmp	r0, #0
   10066:	f6ff af6e 	blt.w	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            else if(res == DRV_ETHPHY_RES_PENDING)
   1006a:	2801      	cmp	r0, #1
   1006c:	f43f af6b 	beq.w	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            if(bmcon.LOOPBACK || bmcon.DUPLEX)
   10070:	f89d 300b 	ldrb.w	r3, [sp, #11]
   10074:	f013 0f41 	tst.w	r3, #65	; 0x41
   10078:	bf14      	ite	ne
   1007a:	f04f 30ff 	movne.w	r0, #4294967295
   1007e:	2000      	moveq	r0, #0
   10080:	e761      	b.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
            return DRV_ETHPHY_RES_OPERATION_ERR;
   10082:	f06f 0008 	mvn.w	r0, #8
   10086:	e75e      	b.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>
                return DRV_ETHPHY_RES_DTCT_ERR; 
   10088:	f04f 30ff 	mov.w	r0, #4294967295
   1008c:	e75b      	b.n	ff46 <_DRV_ETHPHY_DefaultDetect+0x5e>

Disassembly of section .text.CommandIperfSize%248:

00010090 <CommandIperfSize>:
    (*pCmdIO->pCmdApi->print)(cmdIoParam, "iperfi: OK, set the IP address to instance: %d\r\n", iperfIndex);

}

static void CommandIperfSize(SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char** argv)
{
   10090:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10094:	b087      	sub	sp, #28
    bool        setTx, setRx;
    uint32_t    txBuffSize, rxBuffSize;
    tIperfState* pIState;	
    int iperfIndex;

    const void* cmdIoParam = pCmdIO->cmdIoParam;
   10096:	6843      	ldr	r3, [r0, #4]
   10098:	9302      	str	r3, [sp, #8]


    if (argc < 3)
   1009a:	2902      	cmp	r1, #2
   1009c:	dd18      	ble.n	100d0 <CommandIperfSize+0x40>
   1009e:	4682      	mov	sl, r0
   100a0:	4614      	mov	r4, r2
   100a2:	3903      	subs	r1, #3
   100a4:	0849      	lsrs	r1, r1, #1
   100a6:	3208      	adds	r2, #8
   100a8:	eb02 07c1 	add.w	r7, r2, r1, lsl #3
        return;
    }

    setTx = setRx = 0;
    txBuffSize = rxBuffSize = 0;
    iperfIndex = 0;     // assume index 0 if not specified
   100ac:	f04f 0800 	mov.w	r8, #0
    txBuffSize = rxBuffSize = 0;
   100b0:	f8cd 8014 	str.w	r8, [sp, #20]
   100b4:	f8cd 800c 	str.w	r8, [sp, #12]
    setTx = setRx = 0;
   100b8:	f8cd 8010 	str.w	r8, [sp, #16]
   100bc:	46c3      	mov	fp, r8
    while(currIx + 1 < argc)
    { 
        char* param = argv[currIx];
        char* paramVal = argv[currIx + 1];

        if(strcmp(param, "-tx") == 0)
   100be:	f8df 9140 	ldr.w	r9, [pc, #320]	; 10200 <CommandIperfSize+0x170>
        {
            setTx = true;
            txBuffSize = atoi(paramVal);
        }
        else if(strcmp(param, "-rx") == 0)
   100c2:	f109 0338 	add.w	r3, r9, #56	; 0x38
   100c6:	9300      	str	r3, [sp, #0]
        {
            setRx = true;
            rxBuffSize = atoi(paramVal);
        }
        else if((strcmp(param, "-i") == 0) || (strcmp(param, "--index") == 0))
   100c8:	f109 033c 	add.w	r3, r9, #60	; 0x3c
   100cc:	9301      	str	r3, [sp, #4]
   100ce:	e010      	b.n	100f2 <CommandIperfSize+0x62>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: iperfs <-tx size> <-rx size> <-i index>\r\n");
   100d0:	6803      	ldr	r3, [r0, #0]
   100d2:	681b      	ldr	r3, [r3, #0]
   100d4:	494a      	ldr	r1, [pc, #296]	; (10200 <CommandIperfSize+0x170>)
   100d6:	9802      	ldr	r0, [sp, #8]
   100d8:	4798      	blx	r3
    {
        pIState->rxBuffSize = rxBuffSize;
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "iperfs: OK, set instance %d rx size to %d\r\n", iperfIndex, rxBuffSize);
    }

}
   100da:	b007      	add	sp, #28
   100dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            txBuffSize = atoi(paramVal);
   100e0:	4630      	mov	r0, r6
   100e2:	f012 f803 	bl	220ec <atoi>
   100e6:	9003      	str	r0, [sp, #12]
            setTx = true;
   100e8:	f04f 0b01 	mov.w	fp, #1
        currIx += 2;
   100ec:	3408      	adds	r4, #8
    while(currIx + 1 < argc)
   100ee:	42a7      	cmp	r7, r4
   100f0:	d02b      	beq.n	1014a <CommandIperfSize+0xba>
        char* param = argv[currIx];
   100f2:	6865      	ldr	r5, [r4, #4]
        char* paramVal = argv[currIx + 1];
   100f4:	68a6      	ldr	r6, [r4, #8]
        if(strcmp(param, "-tx") == 0)
   100f6:	4943      	ldr	r1, [pc, #268]	; (10204 <CommandIperfSize+0x174>)
   100f8:	4628      	mov	r0, r5
   100fa:	f011 fbff 	bl	218fc <strcmp>
   100fe:	2800      	cmp	r0, #0
   10100:	d0ee      	beq.n	100e0 <CommandIperfSize+0x50>
        else if(strcmp(param, "-rx") == 0)
   10102:	9900      	ldr	r1, [sp, #0]
   10104:	4628      	mov	r0, r5
   10106:	f011 fbf9 	bl	218fc <strcmp>
   1010a:	b178      	cbz	r0, 1012c <CommandIperfSize+0x9c>
        else if((strcmp(param, "-i") == 0) || (strcmp(param, "--index") == 0))
   1010c:	9901      	ldr	r1, [sp, #4]
   1010e:	4628      	mov	r0, r5
   10110:	f011 fbf4 	bl	218fc <strcmp>
   10114:	b128      	cbz	r0, 10122 <CommandIperfSize+0x92>
   10116:	f109 0140 	add.w	r1, r9, #64	; 0x40
   1011a:	4628      	mov	r0, r5
   1011c:	f011 fbee 	bl	218fc <strcmp>
   10120:	b958      	cbnz	r0, 1013a <CommandIperfSize+0xaa>
            iperfIndex = atoi(paramVal);
   10122:	4630      	mov	r0, r6
   10124:	f011 ffe2 	bl	220ec <atoi>
   10128:	4680      	mov	r8, r0
   1012a:	e7df      	b.n	100ec <CommandIperfSize+0x5c>
            rxBuffSize = atoi(paramVal);
   1012c:	4630      	mov	r0, r6
   1012e:	f011 ffdd 	bl	220ec <atoi>
   10132:	9005      	str	r0, [sp, #20]
            setRx = true;
   10134:	2301      	movs	r3, #1
   10136:	9304      	str	r3, [sp, #16]
   10138:	e7d8      	b.n	100ec <CommandIperfSize+0x5c>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperfi: Unknown parameter\r\n");
   1013a:	f8da 3000 	ldr.w	r3, [sl]
   1013e:	681b      	ldr	r3, [r3, #0]
   10140:	f109 0148 	add.w	r1, r9, #72	; 0x48
   10144:	9802      	ldr	r0, [sp, #8]
   10146:	4798      	blx	r3
   10148:	e7d0      	b.n	100ec <CommandIperfSize+0x5c>
    if(iperfIndex < 0 || iperfIndex >= nIperfSessions)
   1014a:	f1b8 0f00 	cmp.w	r8, #0
   1014e:	db1e      	blt.n	1018e <CommandIperfSize+0xfe>
   10150:	4b2d      	ldr	r3, [pc, #180]	; (10208 <CommandIperfSize+0x178>)
   10152:	681b      	ldr	r3, [r3, #0]
   10154:	4543      	cmp	r3, r8
   10156:	dd1a      	ble.n	1018e <CommandIperfSize+0xfe>
    if((setTx && (txBuffSize <= 0 || txBuffSize >= 65536)) || (setRx && (rxBuffSize <= 0 || rxBuffSize >= 65536)))
   10158:	f1bb 0f00 	cmp.w	fp, #0
   1015c:	d028      	beq.n	101b0 <CommandIperfSize+0x120>
   1015e:	9b03      	ldr	r3, [sp, #12]
   10160:	1e5a      	subs	r2, r3, #1
   10162:	f64f 73fe 	movw	r3, #65534	; 0xfffe
   10166:	429a      	cmp	r2, r3
   10168:	d81b      	bhi.n	101a2 <CommandIperfSize+0x112>
   1016a:	9b04      	ldr	r3, [sp, #16]
   1016c:	bb1b      	cbnz	r3, 101b6 <CommandIperfSize+0x126>
        pIState->txBuffSize = txBuffSize;
   1016e:	4a27      	ldr	r2, [pc, #156]	; (1020c <CommandIperfSize+0x17c>)
   10170:	23d8      	movs	r3, #216	; 0xd8
   10172:	fb03 2308 	mla	r3, r3, r8, r2
   10176:	9a03      	ldr	r2, [sp, #12]
   10178:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "iperfs: OK, set instance %d tx size to %d\r\n", iperfIndex, txBuffSize);
   1017c:	f8da 3000 	ldr.w	r3, [sl]
   10180:	685c      	ldr	r4, [r3, #4]
   10182:	4613      	mov	r3, r2
   10184:	4642      	mov	r2, r8
   10186:	4922      	ldr	r1, [pc, #136]	; (10210 <CommandIperfSize+0x180>)
   10188:	9802      	ldr	r0, [sp, #8]
   1018a:	47a0      	blx	r4
    if(setRx)
   1018c:	e7a5      	b.n	100da <CommandIperfSize+0x4a>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: Invalid session number. Min: 0, Max: %d\r\n", nIperfSessions - 1);
   1018e:	4b1e      	ldr	r3, [pc, #120]	; (10208 <CommandIperfSize+0x178>)
   10190:	681a      	ldr	r2, [r3, #0]
   10192:	f8da 3000 	ldr.w	r3, [sl]
   10196:	685b      	ldr	r3, [r3, #4]
   10198:	3a01      	subs	r2, #1
   1019a:	491e      	ldr	r1, [pc, #120]	; (10214 <CommandIperfSize+0x184>)
   1019c:	9802      	ldr	r0, [sp, #8]
   1019e:	4798      	blx	r3
        return;
   101a0:	e79b      	b.n	100da <CommandIperfSize+0x4a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperfs: 0 < size < 65536\r\n");
   101a2:	f8da 3000 	ldr.w	r3, [sl]
   101a6:	681b      	ldr	r3, [r3, #0]
   101a8:	491b      	ldr	r1, [pc, #108]	; (10218 <CommandIperfSize+0x188>)
   101aa:	9802      	ldr	r0, [sp, #8]
   101ac:	4798      	blx	r3
        return;
   101ae:	e794      	b.n	100da <CommandIperfSize+0x4a>
    if((setTx && (txBuffSize <= 0 || txBuffSize >= 65536)) || (setRx && (rxBuffSize <= 0 || rxBuffSize >= 65536)))
   101b0:	9b04      	ldr	r3, [sp, #16]
   101b2:	2b00      	cmp	r3, #0
   101b4:	d091      	beq.n	100da <CommandIperfSize+0x4a>
   101b6:	9b05      	ldr	r3, [sp, #20]
   101b8:	1e5a      	subs	r2, r3, #1
   101ba:	f64f 73fe 	movw	r3, #65534	; 0xfffe
   101be:	429a      	cmp	r2, r3
   101c0:	d8ef      	bhi.n	101a2 <CommandIperfSize+0x112>
    pIState = gIperfState + iperfIndex;	
   101c2:	4b12      	ldr	r3, [pc, #72]	; (1020c <CommandIperfSize+0x17c>)
   101c4:	24d8      	movs	r4, #216	; 0xd8
   101c6:	fb04 3408 	mla	r4, r4, r8, r3
    if(setTx)
   101ca:	f1bb 0f00 	cmp.w	fp, #0
   101ce:	d00a      	beq.n	101e6 <CommandIperfSize+0x156>
        pIState->txBuffSize = txBuffSize;
   101d0:	9a03      	ldr	r2, [sp, #12]
   101d2:	f8c4 20b8 	str.w	r2, [r4, #184]	; 0xb8
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "iperfs: OK, set instance %d tx size to %d\r\n", iperfIndex, txBuffSize);
   101d6:	f8da 3000 	ldr.w	r3, [sl]
   101da:	685d      	ldr	r5, [r3, #4]
   101dc:	4613      	mov	r3, r2
   101de:	4642      	mov	r2, r8
   101e0:	490b      	ldr	r1, [pc, #44]	; (10210 <CommandIperfSize+0x180>)
   101e2:	9802      	ldr	r0, [sp, #8]
   101e4:	47a8      	blx	r5
        pIState->rxBuffSize = rxBuffSize;
   101e6:	9a05      	ldr	r2, [sp, #20]
   101e8:	f8c4 20bc 	str.w	r2, [r4, #188]	; 0xbc
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "iperfs: OK, set instance %d rx size to %d\r\n", iperfIndex, rxBuffSize);
   101ec:	f8da 3000 	ldr.w	r3, [sl]
   101f0:	685c      	ldr	r4, [r3, #4]
   101f2:	4613      	mov	r3, r2
   101f4:	4642      	mov	r2, r8
   101f6:	4909      	ldr	r1, [pc, #36]	; (1021c <CommandIperfSize+0x18c>)
   101f8:	9802      	ldr	r0, [sp, #8]
   101fa:	47a0      	blx	r4
   101fc:	e76d      	b.n	100da <CommandIperfSize+0x4a>
   101fe:	bf00      	nop
   10200:	00004c44 	.word	0x00004c44
   10204:	00004c78 	.word	0x00004c78
   10208:	2000e5f8 	.word	0x2000e5f8
   1020c:	2000dbb0 	.word	0x2000dbb0
   10210:	00004d24 	.word	0x00004d24
   10214:	00004ca8 	.word	0x00004ca8
   10218:	00004cdc 	.word	0x00004cdc
   1021c:	00004cf8 	.word	0x00004cf8

Disassembly of section .text.TCPIP_DHCP_Initialize%249:

00010220 <TCPIP_DHCP_Initialize>:
{
   10220:	b5f0      	push	{r4, r5, r6, r7, lr}
   10222:	b083      	sub	sp, #12
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_UP)
   10224:	7f03      	ldrb	r3, [r0, #28]
   10226:	2b03      	cmp	r3, #3
   10228:	d062      	beq.n	102f0 <TCPIP_DHCP_Initialize+0xd0>
   1022a:	4604      	mov	r4, r0
   1022c:	460d      	mov	r5, r1
    if(dhcpInitCount == 0)
   1022e:	4b55      	ldr	r3, [pc, #340]	; (10384 <TCPIP_DHCP_Initialize+0x164>)
   10230:	681b      	ldr	r3, [r3, #0]
   10232:	2b00      	cmp	r3, #0
   10234:	d13b      	bne.n	102ae <TCPIP_DHCP_Initialize+0x8e>
        if(pDhcpConfig == 0)
   10236:	2900      	cmp	r1, #0
   10238:	f000 809f 	beq.w	1037a <TCPIP_DHCP_Initialize+0x15a>
        dhcpMemH = stackCtrl->memH;
   1023c:	68c0      	ldr	r0, [r0, #12]
   1023e:	4b52      	ldr	r3, [pc, #328]	; (10388 <TCPIP_DHCP_Initialize+0x168>)
   10240:	6018      	str	r0, [r3, #0]
        dhcpClientSocket = INVALID_UDP_SOCKET;
   10242:	4b52      	ldr	r3, [pc, #328]	; (1038c <TCPIP_DHCP_Initialize+0x16c>)
   10244:	f64f 72ff 	movw	r2, #65535	; 0xffff
   10248:	801a      	strh	r2, [r3, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Calloc)(h, nElems, elemSize);
   1024a:	6883      	ldr	r3, [r0, #8]
   1024c:	225c      	movs	r2, #92	; 0x5c
   1024e:	6821      	ldr	r1, [r4, #0]
   10250:	4798      	blx	r3
        DHCPClients = (DHCP_CLIENT_VARS*)TCPIP_HEAP_Calloc(dhcpMemH,  stackCtrl->nIfs, sizeof(DHCP_CLIENT_VARS));
   10252:	4b4f      	ldr	r3, [pc, #316]	; (10390 <TCPIP_DHCP_Initialize+0x170>)
   10254:	6018      	str	r0, [r3, #0]
        if(DHCPClients == 0)
   10256:	2800      	cmp	r0, #0
   10258:	f000 8091 	beq.w	1037e <TCPIP_DHCP_Initialize+0x15e>
        dhcpSignalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_DHCP_Task, TCPIP_DHCP_TASK_TICK_RATE);
   1025c:	2205      	movs	r2, #5
   1025e:	494d      	ldr	r1, [pc, #308]	; (10394 <TCPIP_DHCP_Initialize+0x174>)
   10260:	200c      	movs	r0, #12
   10262:	f00c fd15 	bl	1cc90 <_TCPIPStackSignalHandlerRegister>
   10266:	4b4c      	ldr	r3, [pc, #304]	; (10398 <TCPIP_DHCP_Initialize+0x178>)
   10268:	6018      	str	r0, [r3, #0]
        iniRes = TCPIP_Notification_Initialize(&dhcpRegisteredUsers);
   1026a:	484c      	ldr	r0, [pc, #304]	; (1039c <TCPIP_DHCP_Initialize+0x17c>)
   1026c:	f011 ff01 	bl	22072 <TCPIP_Notification_Initialize>
   10270:	4607      	mov	r7, r0
        dhcpClientPort = pDhcpConfig->dhcpCliPort;
   10272:	68aa      	ldr	r2, [r5, #8]
   10274:	4b4a      	ldr	r3, [pc, #296]	; (103a0 <TCPIP_DHCP_Initialize+0x180>)
   10276:	801a      	strh	r2, [r3, #0]
        dhcpServerPort = pDhcpConfig->dhcpSrvPort;
   10278:	89a9      	ldrh	r1, [r5, #12]
   1027a:	4b4a      	ldr	r3, [pc, #296]	; (103a4 <TCPIP_DHCP_Initialize+0x184>)
   1027c:	8019      	strh	r1, [r3, #0]
    UDP_SOCKET dhcpSkt = TCPIP_UDP_OpenClientSkt(IP_ADDRESS_TYPE_IPV4, dhcpServerPort, 0, UDP_OPEN_CLIENT | UDP_OPEN_CONFIG_SERVICE);
   1027e:	f44f 7381 	mov.w	r3, #258	; 0x102
   10282:	2200      	movs	r2, #0
   10284:	2001      	movs	r0, #1
   10286:	f00d fead 	bl	1dfe4 <TCPIP_UDP_OpenClientSkt>
   1028a:	4606      	mov	r6, r0
    while(dhcpSkt != INVALID_UDP_SOCKET)
   1028c:	f1b0 3fff 	cmp.w	r0, #4294967295
   10290:	d13b      	bne.n	1030a <TCPIP_DHCP_Initialize+0xea>
        dhcpClientSocket = _DHCPOpenSocket();
   10292:	4b3e      	ldr	r3, [pc, #248]	; (1038c <TCPIP_DHCP_Initialize+0x16c>)
   10294:	801e      	strh	r6, [r3, #0]
        if(dhcpSignalHandle == 0 || iniRes == 0 || dhcpClientSocket == INVALID_UDP_SOCKET)
   10296:	4b40      	ldr	r3, [pc, #256]	; (10398 <TCPIP_DHCP_Initialize+0x178>)
   10298:	681b      	ldr	r3, [r3, #0]
   1029a:	2b00      	cmp	r3, #0
   1029c:	d065      	beq.n	1036a <TCPIP_DHCP_Initialize+0x14a>
   1029e:	2f00      	cmp	r7, #0
   102a0:	d063      	beq.n	1036a <TCPIP_DHCP_Initialize+0x14a>
   102a2:	f1b6 3fff 	cmp.w	r6, #4294967295
   102a6:	d060      	beq.n	1036a <TCPIP_DHCP_Initialize+0x14a>
        dhcpInterfaces = stackCtrl->nIfs;
   102a8:	6822      	ldr	r2, [r4, #0]
   102aa:	4b3f      	ldr	r3, [pc, #252]	; (103a8 <TCPIP_DHCP_Initialize+0x188>)
   102ac:	601a      	str	r2, [r3, #0]
    pClient = DHCPClients + stackCtrl->netIx;
   102ae:	69a3      	ldr	r3, [r4, #24]
   102b0:	4a37      	ldr	r2, [pc, #220]	; (10390 <TCPIP_DHCP_Initialize+0x170>)
   102b2:	6812      	ldr	r2, [r2, #0]
   102b4:	215c      	movs	r1, #92	; 0x5c
   102b6:	fb01 2303 	mla	r3, r1, r3, r2
    pClient->flags.val = 0;
   102ba:	2200      	movs	r2, #0
   102bc:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
    pClient->tOpFailTmo = (pDhcpConfig->dhcpTmo < 1) ? TCPIP_DHCP_INIT_FAIL_TMO : (uint16_t)pDhcpConfig->dhcpTmo;
   102c0:	686a      	ldr	r2, [r5, #4]
   102c2:	2a00      	cmp	r2, #0
   102c4:	bfd8      	it	le
   102c6:	220a      	movle	r2, #10
   102c8:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
    pClient->dhcpTmoBase = (TCPIP_DHCP_EXP_BACKOFF_BASE < TCPIP_DHCP_EXP_BACKOFF_FUZZ + 1) ? TCPIP_DHCP_EXP_BACKOFF_FUZZ + 1 : TCPIP_DHCP_EXP_BACKOFF_BASE;
   102cc:	2202      	movs	r2, #2
   102ce:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    pClient->tLeaseCheck = TCPIP_DHCP_LEASE_CHECK_TMO;
   102d2:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
    if(stackCtrl->pNetIf->Flags.bIsDHCPEnabled != 0)
   102d6:	6960      	ldr	r0, [r4, #20]
   102d8:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   102dc:	f013 0f01 	tst.w	r3, #1
   102e0:	d147      	bne.n	10372 <TCPIP_DHCP_Initialize+0x152>
    dhcpInitCount++;
   102e2:	4a28      	ldr	r2, [pc, #160]	; (10384 <TCPIP_DHCP_Initialize+0x164>)
   102e4:	6813      	ldr	r3, [r2, #0]
   102e6:	3301      	adds	r3, #1
   102e8:	6013      	str	r3, [r2, #0]
    return true;
   102ea:	2001      	movs	r0, #1
}
   102ec:	b003      	add	sp, #12
   102ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if(stackCtrl->pNetIf->Flags.bIsDHCPEnabled != 0)
   102f0:	6940      	ldr	r0, [r0, #20]
   102f2:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   102f6:	f013 0f01 	tst.w	r3, #1
   102fa:	d101      	bne.n	10300 <TCPIP_DHCP_Initialize+0xe0>
        return true;
   102fc:	2001      	movs	r0, #1
   102fe:	e7f5      	b.n	102ec <TCPIP_DHCP_Initialize+0xcc>
            _DHCPEnable(stackCtrl->pNetIf, TCPIP_DHCP_OPER_INIT);
   10300:	2101      	movs	r1, #1
   10302:	f007 fd69 	bl	17dd8 <_DHCPEnable>
        return true;
   10306:	2001      	movs	r0, #1
   10308:	e7f0      	b.n	102ec <TCPIP_DHCP_Initialize+0xcc>
        TCPIP_UDP_OptionsGet(dhcpSkt, UDP_OPTION_TX_BUFF, (void*)&txBuffSize);
   1030a:	f10d 0206 	add.w	r2, sp, #6
   1030e:	2105      	movs	r1, #5
   10310:	f002 fa44 	bl	1279c <TCPIP_UDP_OptionsGet>
        if(txBuffSize < TCPIP_DHCP_MIN_UDP_TX_BUFFER_SIZE)
   10314:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   10318:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   1031c:	d208      	bcs.n	10330 <TCPIP_DHCP_Initialize+0x110>
            txBuffSize = TCPIP_DHCP_MIN_UDP_TX_BUFFER_SIZE;
   1031e:	f44f 7200 	mov.w	r2, #512	; 0x200
   10322:	f8ad 2006 	strh.w	r2, [sp, #6]
            if(!TCPIP_UDP_OptionsSet(dhcpSkt, UDP_OPTION_TX_BUFF, (void*)(uintptr_t)txBuffSize))
   10326:	2105      	movs	r1, #5
   10328:	4630      	mov	r0, r6
   1032a:	f7fe f9eb 	bl	e704 <TCPIP_UDP_OptionsSet>
   1032e:	b138      	cbz	r0, 10340 <TCPIP_DHCP_Initialize+0x120>
        if(!TCPIP_UDP_Bind(dhcpSkt, IP_ADDRESS_TYPE_IPV4, dhcpClientPort,  0))
   10330:	2300      	movs	r3, #0
   10332:	4a1b      	ldr	r2, [pc, #108]	; (103a0 <TCPIP_DHCP_Initialize+0x180>)
   10334:	8812      	ldrh	r2, [r2, #0]
   10336:	2101      	movs	r1, #1
   10338:	4630      	mov	r0, r6
   1033a:	f002 fac3 	bl	128c4 <TCPIP_UDP_Bind>
   1033e:	b928      	cbnz	r0, 1034c <TCPIP_DHCP_Initialize+0x12c>
        TCPIP_UDP_Close(dhcpSkt);
   10340:	4630      	mov	r0, r6
   10342:	f00e ff0f 	bl	1f164 <TCPIP_UDP_Close>
        dhcpSkt = INVALID_UDP_SOCKET;
   10346:	f04f 36ff 	mov.w	r6, #4294967295
   1034a:	e7a2      	b.n	10292 <TCPIP_DHCP_Initialize+0x72>
        TCPIP_UDP_OptionsSet(dhcpSkt, UDP_OPTION_STRICT_ADDRESS, 0);
   1034c:	2200      	movs	r2, #0
   1034e:	2102      	movs	r1, #2
   10350:	4630      	mov	r0, r6
   10352:	f7fe f9d7 	bl	e704 <TCPIP_UDP_OptionsSet>
        sigHandle = TCPIP_UDP_SignalHandlerRegister(dhcpSkt, TCPIP_UDP_SIGNAL_RX_DATA, _DHCPSocketRxSignalHandler, 0);
   10356:	2300      	movs	r3, #0
   10358:	4a14      	ldr	r2, [pc, #80]	; (103ac <TCPIP_DHCP_Initialize+0x18c>)
   1035a:	f44f 7180 	mov.w	r1, #256	; 0x100
   1035e:	4630      	mov	r0, r6
   10360:	f00c fef3 	bl	1d14a <TCPIP_UDP_SignalHandlerRegister>
        if(sigHandle == 0)
   10364:	2800      	cmp	r0, #0
   10366:	d194      	bne.n	10292 <TCPIP_DHCP_Initialize+0x72>
   10368:	e7ea      	b.n	10340 <TCPIP_DHCP_Initialize+0x120>
            _DHCPCleanup();
   1036a:	f007 ffd7 	bl	1831c <_DHCPCleanup>
            return false;
   1036e:	2000      	movs	r0, #0
   10370:	e7bc      	b.n	102ec <TCPIP_DHCP_Initialize+0xcc>
        _DHCPEnable(stackCtrl->pNetIf, TCPIP_DHCP_OPER_INIT);
   10372:	2101      	movs	r1, #1
   10374:	f007 fd30 	bl	17dd8 <_DHCPEnable>
   10378:	e7b3      	b.n	102e2 <TCPIP_DHCP_Initialize+0xc2>
            return false;
   1037a:	2000      	movs	r0, #0
   1037c:	e7b6      	b.n	102ec <TCPIP_DHCP_Initialize+0xcc>
            return false;
   1037e:	2000      	movs	r0, #0
   10380:	e7b4      	b.n	102ec <TCPIP_DHCP_Initialize+0xcc>
   10382:	bf00      	nop
   10384:	2000e614 	.word	0x2000e614
   10388:	2000e61c 	.word	0x2000e61c
   1038c:	2000e720 	.word	0x2000e720
   10390:	2000e610 	.word	0x2000e610
   10394:	0000807d 	.word	0x0000807d
   10398:	2000e624 	.word	0x2000e624
   1039c:	2000e450 	.word	0x2000e450
   103a0:	2000e71e 	.word	0x2000e71e
   103a4:	2000e722 	.word	0x2000e722
   103a8:	2000e618 	.word	0x2000e618
   103ac:	000216a3 	.word	0x000216a3

Disassembly of section .text._Command_MacInfo%250:

000103b0 <_Command_MacInfo>:
{
   103b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   103b4:	f6ad 0d3c 	subw	sp, sp, #2108	; 0x83c
   103b8:	4606      	mov	r6, r0
   103ba:	9102      	str	r1, [sp, #8]
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   103bc:	f8d0 a004 	ldr.w	sl, [r0, #4]
    if (argc != 1) {
   103c0:	2901      	cmp	r1, #1
   103c2:	d010      	beq.n	103e6 <_Command_MacInfo+0x36>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: macinfo \r\n");
   103c4:	4c5a      	ldr	r4, [pc, #360]	; (10530 <_Command_MacInfo+0x180>)
   103c6:	6803      	ldr	r3, [r0, #0]
   103c8:	681b      	ldr	r3, [r3, #0]
   103ca:	4621      	mov	r1, r4
   103cc:	4650      	mov	r0, sl
   103ce:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: macinfo \r\n");
   103d0:	6833      	ldr	r3, [r6, #0]
   103d2:	681b      	ldr	r3, [r3, #0]
   103d4:	f104 0114 	add.w	r1, r4, #20
   103d8:	4650      	mov	r0, sl
   103da:	4798      	blx	r3
        return false;
   103dc:	2000      	movs	r0, #0
}
   103de:	f60d 0d3c 	addw	sp, sp, #2108	; 0x83c
   103e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    netNo = TCPIP_STACK_NumberOfNetworksGet();
   103e6:	f011 fd8d 	bl	21f04 <TCPIP_STACK_NumberOfNetworksGet>
    for(netIx = 0; netIx < netNo; netIx++)
   103ea:	f1b0 0b00 	subs.w	fp, r0, #0
   103ee:	f340 809c 	ble.w	1052a <_Command_MacInfo+0x17a>
   103f2:	2700      	movs	r7, #0
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Interface: %s Driver Statistics\r\n", netName);
   103f4:	f8df 9138 	ldr.w	r9, [pc, #312]	; 10530 <_Command_MacInfo+0x180>
   103f8:	f109 0324 	add.w	r3, r9, #36	; 0x24
   103fc:	9303      	str	r3, [sp, #12]
   103fe:	e01d      	b.n	1043c <_Command_MacInfo+0x8c>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "\tnot supported\r\n");
   10400:	6833      	ldr	r3, [r6, #0]
   10402:	681b      	ldr	r3, [r3, #0]
   10404:	f509 71b2 	add.w	r1, r9, #356	; 0x164
   10408:	4650      	mov	r0, sl
   1040a:	4798      	blx	r3
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Interface: %s Hardware Register Status\r\n", netName);
   1040c:	6833      	ldr	r3, [r6, #0]
   1040e:	685b      	ldr	r3, [r3, #4]
   10410:	462a      	mov	r2, r5
   10412:	f509 71bc 	add.w	r1, r9, #376	; 0x178
   10416:	4650      	mov	r0, sl
   10418:	4798      	blx	r3
        if(TCPIP_STACK_NetMACRegisterStatisticsGet(netH, regEntries, sizeof(regEntries)/sizeof(*regEntries), &hwEntries))
   1041a:	ab0f      	add	r3, sp, #60	; 0x3c
   1041c:	2232      	movs	r2, #50	; 0x32
   1041e:	a910      	add	r1, sp, #64	; 0x40
   10420:	4620      	mov	r0, r4
   10422:	f00f fd23 	bl	1fe6c <TCPIP_STACK_NetMACRegisterStatisticsGet>
   10426:	2800      	cmp	r0, #0
   10428:	d15d      	bne.n	104e6 <_Command_MacInfo+0x136>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "\tnot supported\r\n");
   1042a:	6833      	ldr	r3, [r6, #0]
   1042c:	681b      	ldr	r3, [r3, #0]
   1042e:	f509 71b2 	add.w	r1, r9, #356	; 0x164
   10432:	4650      	mov	r0, sl
   10434:	4798      	blx	r3
    for(netIx = 0; netIx < netNo; netIx++)
   10436:	3701      	adds	r7, #1
   10438:	45bb      	cmp	fp, r7
   1043a:	d074      	beq.n	10526 <_Command_MacInfo+0x176>
        netH = TCPIP_STACK_IndexToNet(netIx);
   1043c:	4638      	mov	r0, r7
   1043e:	f00f fced 	bl	1fe1c <TCPIP_STACK_IndexToNet>
   10442:	4604      	mov	r4, r0
        if(TCPIP_STACK_NetGetType(netH) != TCPIP_NETWORK_TYPE_PRIMARY)
   10444:	f011 fe11 	bl	2206a <TCPIP_STACK_NetGetType>
   10448:	2801      	cmp	r0, #1
   1044a:	d1f4      	bne.n	10436 <_Command_MacInfo+0x86>
        netName = TCPIP_STACK_NetNameGet(netH);
   1044c:	4620      	mov	r0, r4
   1044e:	f011 fddc 	bl	2200a <TCPIP_STACK_NetNameGet>
   10452:	4605      	mov	r5, r0
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Interface: %s Driver Statistics\r\n", netName);
   10454:	6833      	ldr	r3, [r6, #0]
   10456:	685b      	ldr	r3, [r3, #4]
   10458:	4602      	mov	r2, r0
   1045a:	9903      	ldr	r1, [sp, #12]
   1045c:	4650      	mov	r0, sl
   1045e:	4798      	blx	r3
        if(TCPIP_STACK_NetMACStatisticsGet(netH, &rxStatistics, &txStatistics))
   10460:	f50d 6201 	add.w	r2, sp, #2064	; 0x810
   10464:	f50d 6102 	add.w	r1, sp, #2080	; 0x820
   10468:	4620      	mov	r0, r4
   1046a:	f00f fceb 	bl	1fe44 <TCPIP_STACK_NetMACStatisticsGet>
   1046e:	2800      	cmp	r0, #0
   10470:	d0c6      	beq.n	10400 <_Command_MacInfo+0x50>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\n Receive Statistics\r\n");
   10472:	6833      	ldr	r3, [r6, #0]
   10474:	685b      	ldr	r3, [r3, #4]
   10476:	f109 0148 	add.w	r1, r9, #72	; 0x48
   1047a:	4650      	mov	r0, sl
   1047c:	4798      	blx	r3
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "\t nRxOkPackets: %d\r\n\t nRxPendBuffers: %d\r\n\t nRxSchedBuffers: %d\r\n",
   1047e:	6833      	ldr	r3, [r6, #0]
   10480:	f8dd 2828 	ldr.w	r2, [sp, #2088]	; 0x828
   10484:	9200      	str	r2, [sp, #0]
   10486:	f8d3 8004 	ldr.w	r8, [r3, #4]
   1048a:	f8dd 3824 	ldr.w	r3, [sp, #2084]	; 0x824
   1048e:	f8dd 2820 	ldr.w	r2, [sp, #2080]	; 0x820
   10492:	f109 0160 	add.w	r1, r9, #96	; 0x60
   10496:	4650      	mov	r0, sl
   10498:	47c0      	blx	r8
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "\t nRxErrorPackets: %d\r\n\t nRxFragmentErrors: %d\r\n\t nRxBuffNotAvailable: %d\r\n", rxStatistics.nRxErrorPackets, rxStatistics.nRxFragmentErrors,rxStatistics.nRxBuffNotAvailable);
   1049a:	6833      	ldr	r3, [r6, #0]
   1049c:	f8dd 2834 	ldr.w	r2, [sp, #2100]	; 0x834
   104a0:	9200      	str	r2, [sp, #0]
   104a2:	f8d3 8004 	ldr.w	r8, [r3, #4]
   104a6:	f8dd 3830 	ldr.w	r3, [sp, #2096]	; 0x830
   104aa:	f8dd 282c 	ldr.w	r2, [sp, #2092]	; 0x82c
   104ae:	f109 01a4 	add.w	r1, r9, #164	; 0xa4
   104b2:	4650      	mov	r0, sl
   104b4:	47c0      	blx	r8
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\n Transmit Statistics\r\n");
   104b6:	6833      	ldr	r3, [r6, #0]
   104b8:	685b      	ldr	r3, [r3, #4]
   104ba:	f109 01f0 	add.w	r1, r9, #240	; 0xf0
   104be:	4650      	mov	r0, sl
   104c0:	4798      	blx	r3
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "\t nTxOkPackets: %d\r\n\t nTxPendBuffers: %d\r\n\t nTxErrorPackets: %d\r\n\t nTxQueueFull: %d\r\n\r\n",
   104c2:	6833      	ldr	r3, [r6, #0]
   104c4:	f8dd 281c 	ldr.w	r2, [sp, #2076]	; 0x81c
   104c8:	9201      	str	r2, [sp, #4]
   104ca:	f8dd 2818 	ldr.w	r2, [sp, #2072]	; 0x818
   104ce:	9200      	str	r2, [sp, #0]
   104d0:	f8d3 8004 	ldr.w	r8, [r3, #4]
   104d4:	f8dd 3814 	ldr.w	r3, [sp, #2068]	; 0x814
   104d8:	f8dd 2810 	ldr.w	r2, [sp, #2064]	; 0x810
   104dc:	f509 7186 	add.w	r1, r9, #268	; 0x10c
   104e0:	4650      	mov	r0, sl
   104e2:	47c0      	blx	r8
   104e4:	e792      	b.n	1040c <_Command_MacInfo+0x5c>
            entryName[sizeof(entryName) - 1] = 0;
   104e6:	2300      	movs	r3, #0
   104e8:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
            for(jx = 0, pRegEntry = regEntries; jx < hwEntries && jx < sizeof(regEntries)/sizeof(*regEntries); jx++, pRegEntry++)
   104ec:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   104ee:	2b00      	cmp	r3, #0
   104f0:	dda1      	ble.n	10436 <_Command_MacInfo+0x86>
   104f2:	2500      	movs	r5, #0
   104f4:	ac10      	add	r4, sp, #64	; 0x40
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "\t %s: 0x%x\r\n", entryName, pRegEntry->registerValue);
   104f6:	46b8      	mov	r8, r7
                strncpy(entryName, pRegEntry->registerName, sizeof(entryName) - 1);
   104f8:	2224      	movs	r2, #36	; 0x24
   104fa:	4621      	mov	r1, r4
   104fc:	a805      	add	r0, sp, #20
   104fe:	f00f fea2 	bl	20246 <strncpy>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "\t %s: 0x%x\r\n", entryName, pRegEntry->registerValue);
   10502:	6833      	ldr	r3, [r6, #0]
   10504:	685f      	ldr	r7, [r3, #4]
   10506:	6a63      	ldr	r3, [r4, #36]	; 0x24
   10508:	aa05      	add	r2, sp, #20
   1050a:	490a      	ldr	r1, [pc, #40]	; (10534 <_Command_MacInfo+0x184>)
   1050c:	4650      	mov	r0, sl
   1050e:	47b8      	blx	r7
            for(jx = 0, pRegEntry = regEntries; jx < hwEntries && jx < sizeof(regEntries)/sizeof(*regEntries); jx++, pRegEntry++)
   10510:	3501      	adds	r5, #1
   10512:	3428      	adds	r4, #40	; 0x28
   10514:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   10516:	42ab      	cmp	r3, r5
   10518:	dd03      	ble.n	10522 <_Command_MacInfo+0x172>
   1051a:	2d32      	cmp	r5, #50	; 0x32
   1051c:	d1ec      	bne.n	104f8 <_Command_MacInfo+0x148>
   1051e:	4647      	mov	r7, r8
   10520:	e789      	b.n	10436 <_Command_MacInfo+0x86>
   10522:	4647      	mov	r7, r8
   10524:	e787      	b.n	10436 <_Command_MacInfo+0x86>
    return true;
   10526:	9802      	ldr	r0, [sp, #8]
   10528:	e759      	b.n	103de <_Command_MacInfo+0x2e>
   1052a:	9802      	ldr	r0, [sp, #8]
   1052c:	e757      	b.n	103de <_Command_MacInfo+0x2e>
   1052e:	bf00      	nop
   10530:	0000028c 	.word	0x0000028c
   10534:	00000430 	.word	0x00000430

Disassembly of section .text.wc_Sha256Final%251:

00010538 <wc_Sha256Final>:

        return 0;
    }

    int wc_Sha256Final(wc_Sha256* sha256, byte* hash)
    {
   10538:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        int ret;

        if (sha256 == NULL || hash == NULL) {
   1053a:	2800      	cmp	r0, #0
   1053c:	f000 80ab 	beq.w	10696 <wc_Sha256Final+0x15e>
   10540:	4604      	mov	r4, r0
   10542:	2900      	cmp	r1, #0
   10544:	f000 80aa 	beq.w	1069c <wc_Sha256Final+0x164>
   10548:	460d      	mov	r5, r1
            return BAD_FUNC_ARG;
        }

    #ifdef WOLF_CRYPTO_CB
        if (sha256->devId != INVALID_DEVID) {
   1054a:	6f03      	ldr	r3, [r0, #112]	; 0x70
   1054c:	f113 0f02 	cmn.w	r3, #2
   10550:	d00a      	beq.n	10568 <wc_Sha256Final+0x30>
            ret = wc_CryptoCb_Sha256Hash(sha256, NULL, 0, hash);
   10552:	460b      	mov	r3, r1
   10554:	2200      	movs	r2, #0
   10556:	4611      	mov	r1, r2
   10558:	f00a f9aa 	bl	1a8b0 <wc_CryptoCb_Sha256Hash>
   1055c:	4607      	mov	r7, r0
            if (ret != CRYPTOCB_UNAVAILABLE)
   1055e:	f46f 7387 	mvn.w	r3, #270	; 0x10e
   10562:	4298      	cmp	r0, r3
   10564:	f040 8095 	bne.w	10692 <wc_Sha256Final+0x15a>
        local = (byte*)sha256->buffer;
   10568:	f104 0620 	add.w	r6, r4, #32
        local[sha256->buffLen++] = 0x80; /* add 1 */
   1056c:	6e23      	ldr	r3, [r4, #96]	; 0x60
   1056e:	1c5a      	adds	r2, r3, #1
   10570:	6622      	str	r2, [r4, #96]	; 0x60
   10572:	2280      	movs	r2, #128	; 0x80
   10574:	54f2      	strb	r2, [r6, r3]
        if (sha256->buffLen > WC_SHA256_PAD_SIZE) {
   10576:	6e20      	ldr	r0, [r4, #96]	; 0x60
   10578:	2838      	cmp	r0, #56	; 0x38
   1057a:	d922      	bls.n	105c2 <wc_Sha256Final+0x8a>
            XMEMSET(&local[sha256->buffLen], 0,
   1057c:	f1c0 0240 	rsb	r2, r0, #64	; 0x40
   10580:	2100      	movs	r1, #0
   10582:	4430      	add	r0, r6
   10584:	f011 fafa 	bl	21b7c <memset>
            sha256->buffLen += WC_SHA256_BLOCK_SIZE - sha256->buffLen;
   10588:	2340      	movs	r3, #64	; 0x40
   1058a:	6623      	str	r3, [r4, #96]	; 0x60
    for (i = 0; i < count; i++)
   1058c:	f104 011c 	add.w	r1, r4, #28
   10590:	f104 005c 	add.w	r0, r4, #92	; 0x5c
        out[i] = ByteReverseWord32(in[i]);
   10594:	f851 2f04 	ldr.w	r2, [r1, #4]!
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
   10598:	0a13      	lsrs	r3, r2, #8
   1059a:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
   1059e:	0212      	lsls	r2, r2, #8
   105a0:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
   105a4:	4313      	orrs	r3, r2
        return (x << y) | (x >> (sizeof(y) * 8 - y));
   105a6:	ea4f 4333 	mov.w	r3, r3, ror #16
        out[i] = ByteReverseWord32(in[i]);
   105aa:	600b      	str	r3, [r1, #0]
    for (i = 0; i < count; i++)
   105ac:	4281      	cmp	r1, r0
   105ae:	d1f1      	bne.n	10594 <wc_Sha256Final+0x5c>
            ret = XTRANSFORM(sha256, (const byte*)local);
   105b0:	4631      	mov	r1, r6
   105b2:	4620      	mov	r0, r4
   105b4:	f7fa fe92 	bl	b2dc <Transform_Sha256>
            if (ret != 0)
   105b8:	4607      	mov	r7, r0
   105ba:	2800      	cmp	r0, #0
   105bc:	d169      	bne.n	10692 <wc_Sha256Final+0x15a>
            sha256->buffLen = 0;
   105be:	2300      	movs	r3, #0
   105c0:	6623      	str	r3, [r4, #96]	; 0x60
        XMEMSET(&local[sha256->buffLen], 0,
   105c2:	6e20      	ldr	r0, [r4, #96]	; 0x60
   105c4:	f1c0 0238 	rsb	r2, r0, #56	; 0x38
   105c8:	2100      	movs	r1, #0
   105ca:	4430      	add	r0, r6
   105cc:	f011 fad6 	bl	21b7c <memset>
        sha256->hiLen = (sha256->loLen >> (8 * sizeof(sha256->loLen) - 3)) +
   105d0:	6e63      	ldr	r3, [r4, #100]	; 0x64
                                                         (sha256->hiLen << 3);
   105d2:	6ea1      	ldr	r1, [r4, #104]	; 0x68
        sha256->hiLen = (sha256->loLen >> (8 * sizeof(sha256->loLen) - 3)) +
   105d4:	0f5a      	lsrs	r2, r3, #29
   105d6:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
   105da:	66a2      	str	r2, [r4, #104]	; 0x68
        sha256->loLen = sha256->loLen << 3;
   105dc:	00db      	lsls	r3, r3, #3
   105de:	6663      	str	r3, [r4, #100]	; 0x64
   105e0:	f104 011c 	add.w	r1, r4, #28
   105e4:	f104 005c 	add.w	r0, r4, #92	; 0x5c
        out[i] = ByteReverseWord32(in[i]);
   105e8:	f851 2f04 	ldr.w	r2, [r1, #4]!
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
   105ec:	0a13      	lsrs	r3, r2, #8
   105ee:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
   105f2:	0212      	lsls	r2, r2, #8
   105f4:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
   105f8:	4313      	orrs	r3, r2
        return (x << y) | (x >> (sizeof(y) * 8 - y));
   105fa:	ea4f 4333 	mov.w	r3, r3, ror #16
        out[i] = ByteReverseWord32(in[i]);
   105fe:	600b      	str	r3, [r1, #0]
    for (i = 0; i < count; i++)
   10600:	4281      	cmp	r1, r0
   10602:	d1f1      	bne.n	105e8 <wc_Sha256Final+0xb0>
        XMEMCPY(&local[WC_SHA256_PAD_SIZE], &sha256->hiLen, sizeof(word32));
   10604:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   10606:	65a3      	str	r3, [r4, #88]	; 0x58
        XMEMCPY(&local[WC_SHA256_PAD_SIZE + sizeof(word32)], &sha256->loLen,
   10608:	6e63      	ldr	r3, [r4, #100]	; 0x64
   1060a:	65e3      	str	r3, [r4, #92]	; 0x5c
        ret = XTRANSFORM(sha256, (const byte*)local);
   1060c:	4631      	mov	r1, r6
   1060e:	4620      	mov	r0, r4
   10610:	f7fa fe64 	bl	b2dc <Transform_Sha256>
        #endif
        }
    #endif /* WOLFSSL_ASYNC_CRYPT */

        ret = Sha256Final(sha256);
        if (ret != 0)
   10614:	4607      	mov	r7, r0
   10616:	2800      	cmp	r0, #0
   10618:	d13b      	bne.n	10692 <wc_Sha256Final+0x15a>
            return ret;

    #if defined(LITTLE_ENDIAN_ORDER)
        ByteReverseWords(sha256->digest, sha256->digest, WC_SHA256_DIGEST_SIZE);
   1061a:	4626      	mov	r6, r4
   1061c:	1f21      	subs	r1, r4, #4
   1061e:	f104 001c 	add.w	r0, r4, #28
        out[i] = ByteReverseWord32(in[i]);
   10622:	f851 2f04 	ldr.w	r2, [r1, #4]!
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
   10626:	0a13      	lsrs	r3, r2, #8
   10628:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
   1062c:	0212      	lsls	r2, r2, #8
   1062e:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
   10632:	4313      	orrs	r3, r2
        return (x << y) | (x >> (sizeof(y) * 8 - y));
   10634:	ea4f 4333 	mov.w	r3, r3, ror #16
        out[i] = ByteReverseWord32(in[i]);
   10638:	600b      	str	r3, [r1, #0]
    for (i = 0; i < count; i++)
   1063a:	4288      	cmp	r0, r1
   1063c:	d1f1      	bne.n	10622 <wc_Sha256Final+0xea>
    #endif
        XMEMCPY(hash, sha256->digest, WC_SHA256_DIGEST_SIZE);
   1063e:	6830      	ldr	r0, [r6, #0]
   10640:	6871      	ldr	r1, [r6, #4]
   10642:	68b2      	ldr	r2, [r6, #8]
   10644:	68f3      	ldr	r3, [r6, #12]
   10646:	6028      	str	r0, [r5, #0]
   10648:	6069      	str	r1, [r5, #4]
   1064a:	60aa      	str	r2, [r5, #8]
   1064c:	60eb      	str	r3, [r5, #12]
   1064e:	6930      	ldr	r0, [r6, #16]
   10650:	6971      	ldr	r1, [r6, #20]
   10652:	69b2      	ldr	r2, [r6, #24]
   10654:	69f3      	ldr	r3, [r6, #28]
   10656:	6128      	str	r0, [r5, #16]
   10658:	6169      	str	r1, [r5, #20]
   1065a:	61aa      	str	r2, [r5, #24]
   1065c:	61eb      	str	r3, [r5, #28]
    sha256->digest[0] = 0x6A09E667L;
   1065e:	4b11      	ldr	r3, [pc, #68]	; (106a4 <wc_Sha256Final+0x16c>)
   10660:	6023      	str	r3, [r4, #0]
    sha256->digest[1] = 0xBB67AE85L;
   10662:	4b11      	ldr	r3, [pc, #68]	; (106a8 <wc_Sha256Final+0x170>)
   10664:	6063      	str	r3, [r4, #4]
    sha256->digest[2] = 0x3C6EF372L;
   10666:	4b11      	ldr	r3, [pc, #68]	; (106ac <wc_Sha256Final+0x174>)
   10668:	60a3      	str	r3, [r4, #8]
    sha256->digest[3] = 0xA54FF53AL;
   1066a:	4b11      	ldr	r3, [pc, #68]	; (106b0 <wc_Sha256Final+0x178>)
   1066c:	60e3      	str	r3, [r4, #12]
    sha256->digest[4] = 0x510E527FL;
   1066e:	4b11      	ldr	r3, [pc, #68]	; (106b4 <wc_Sha256Final+0x17c>)
   10670:	6123      	str	r3, [r4, #16]
    sha256->digest[5] = 0x9B05688CL;
   10672:	4b11      	ldr	r3, [pc, #68]	; (106b8 <wc_Sha256Final+0x180>)
   10674:	6163      	str	r3, [r4, #20]
    sha256->digest[6] = 0x1F83D9ABL;
   10676:	4b11      	ldr	r3, [pc, #68]	; (106bc <wc_Sha256Final+0x184>)
   10678:	61a3      	str	r3, [r4, #24]
    sha256->digest[7] = 0x5BE0CD19L;
   1067a:	f103 5374 	add.w	r3, r3, #1023410176	; 0x3d000000
   1067e:	f5a3 0323 	sub.w	r3, r3, #10682368	; 0xa30000
   10682:	f6a3 4392 	subw	r3, r3, #3218	; 0xc92
   10686:	61e3      	str	r3, [r4, #28]
    sha256->buffLen = 0;
   10688:	2300      	movs	r3, #0
   1068a:	6623      	str	r3, [r4, #96]	; 0x60
    sha256->loLen   = 0;
   1068c:	6663      	str	r3, [r4, #100]	; 0x64
    sha256->hiLen   = 0;
   1068e:	66a3      	str	r3, [r4, #104]	; 0x68
    sha256->flags = 0;
   10690:	67a3      	str	r3, [r4, #120]	; 0x78

        return InitSha256(sha256);  /* reset state */
    }
   10692:	4638      	mov	r0, r7
   10694:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return BAD_FUNC_ARG;
   10696:	f06f 07ac 	mvn.w	r7, #172	; 0xac
   1069a:	e7fa      	b.n	10692 <wc_Sha256Final+0x15a>
   1069c:	f06f 07ac 	mvn.w	r7, #172	; 0xac
   106a0:	e7f7      	b.n	10692 <wc_Sha256Final+0x15a>
   106a2:	bf00      	nop
   106a4:	6a09e667 	.word	0x6a09e667
   106a8:	bb67ae85 	.word	0xbb67ae85
   106ac:	3c6ef372 	.word	0x3c6ef372
   106b0:	a54ff53a 	.word	0xa54ff53a
   106b4:	510e527f 	.word	0x510e527f
   106b8:	9b05688c 	.word	0x9b05688c
   106bc:	1f83d9ab 	.word	0x1f83d9ab

Disassembly of section .text._InitRng%252:

000106c0 <_InitRng>:
/* End NIST DRBG Code */


static int _InitRng(WC_RNG* rng, byte* nonce, word32 nonceSz,
                    void* heap, int devId)
{
   106c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   106c4:	b0a9      	sub	sp, #164	; 0xa4
   106c6:	f8dd b0c8 	ldr.w	fp, [sp, #200]	; 0xc8
#endif

    (void)nonce;
    (void)nonceSz;

    if (rng == NULL)
   106ca:	2800      	cmp	r0, #0
   106cc:	f000 80af 	beq.w	1082e <_InitRng+0x16e>
   106d0:	4604      	mov	r4, r0
        return BAD_FUNC_ARG;
    if (nonce == NULL && nonceSz != 0)
   106d2:	2900      	cmp	r1, #0
   106d4:	d064      	beq.n	107a0 <_InitRng+0xe0>

#ifdef WOLFSSL_HEAP_TEST
    rng->heap = (void*)WOLFSSL_HEAP_TEST;
    (void)heap;
#else
    rng->heap = heap;
   106d6:	6083      	str	r3, [r0, #8]
#endif
#if defined(WOLFSSL_ASYNC_CRYPT) || defined(WOLF_CRYPTO_CB)
    rng->devId = devId;
   106d8:	f8c0 b014 	str.w	fp, [r0, #20]
    #if defined(WOLF_CRYPTO_CB)
        rng->seed.devId = devId;
   106dc:	f8c0 b004 	str.w	fp, [r0, #4]
    (void)devId;
#endif

#ifdef HAVE_HASHDRBG
    /* init the DBRG to known values */
    rng->drbg = NULL;
   106e0:	2300      	movs	r3, #0
   106e2:	60c3      	str	r3, [r0, #12]
    rng->status = DRBG_NOT_INIT;
   106e4:	7403      	strb	r3, [r0, #16]
#ifdef CUSTOM_RAND_GENERATE_BLOCK
    ret = 0; /* success */
#else
#ifdef HAVE_HASHDRBG
    if (nonceSz == 0)
        seedSz = MAX_SEED_SZ;
   106e6:	429a      	cmp	r2, r3
   106e8:	bf14      	ite	ne
   106ea:	2724      	movne	r7, #36	; 0x24
   106ec:	2734      	moveq	r7, #52	; 0x34
   106ee:	4691      	mov	r9, r2
   106f0:	4688      	mov	r8, r1
            XMEMCPY_P(outputB, outputB_data, sizeof(outputB_data));
#else
        const byte* seedB = seedB_data;
        const byte* outputB = outputB_data;
#endif
        ret = wc_RNG_HealthTest(0, seedB, sizeof(seedB_data),
   106f2:	2380      	movs	r3, #128	; 0x80
   106f4:	9302      	str	r3, [sp, #8]
   106f6:	ab08      	add	r3, sp, #32
   106f8:	9301      	str	r3, [sp, #4]
   106fa:	2000      	movs	r0, #0
   106fc:	9000      	str	r0, [sp, #0]
   106fe:	4603      	mov	r3, r0
   10700:	2230      	movs	r2, #48	; 0x30
   10702:	494e      	ldr	r1, [pc, #312]	; (1083c <_InitRng+0x17c>)
   10704:	f00f f934 	bl	1f970 <wc_RNG_HealthTest>
                                NULL, 0,
                                check, RNG_HEALTH_TEST_CHECK_SIZE);
        if (ret == 0) {
   10708:	4601      	mov	r1, r0
   1070a:	2800      	cmp	r0, #0
   1070c:	f040 808a 	bne.w	10824 <_InitRng+0x164>
   10710:	f10d 051f 	add.w	r5, sp, #31
   10714:	f8df a128 	ldr.w	sl, [pc, #296]	; 10840 <_InitRng+0x180>
   10718:	f10d 069f 	add.w	r6, sp, #159	; 0x9f
   1071c:	4650      	mov	r0, sl
   1071e:	462a      	mov	r2, r5
{
    int i;
    int compareSum = 0;

    for (i = 0; i < length; i++) {
        compareSum |= a[i] ^ b[i];
   10720:	f812 3f01 	ldrb.w	r3, [r2, #1]!
   10724:	f810 cf01 	ldrb.w	ip, [r0, #1]!
   10728:	ea83 030c 	eor.w	r3, r3, ip
   1072c:	4319      	orrs	r1, r3
    for (i = 0; i < length; i++) {
   1072e:	42b2      	cmp	r2, r6
   10730:	d1f6      	bne.n	10720 <_InitRng+0x60>
            if (ConstantCompare(check, outputB,
   10732:	2900      	cmp	r1, #0
   10734:	d176      	bne.n	10824 <_InitRng+0x164>
        /* The previous test cases use a large seed instead of a seed and nonce.
         * seedB is actually from a test case with a seed and nonce, and
         * just concatenates them. The pivot point between seed and nonce is
         * byte 32, feed them into the health test separately. */
        if (ret == 0) {
            ret = wc_RNG_HealthTest_ex(0,
   10736:	4941      	ldr	r1, [pc, #260]	; (1083c <_InitRng+0x17c>)
   10738:	f06f 0301 	mvn.w	r3, #1
   1073c:	9306      	str	r3, [sp, #24]
   1073e:	2000      	movs	r0, #0
   10740:	9005      	str	r0, [sp, #20]
   10742:	2380      	movs	r3, #128	; 0x80
   10744:	9304      	str	r3, [sp, #16]
   10746:	ab08      	add	r3, sp, #32
   10748:	9303      	str	r3, [sp, #12]
   1074a:	9002      	str	r0, [sp, #8]
   1074c:	9001      	str	r0, [sp, #4]
   1074e:	2320      	movs	r3, #32
   10750:	9300      	str	r3, [sp, #0]
   10752:	460b      	mov	r3, r1
   10754:	2210      	movs	r2, #16
   10756:	3120      	adds	r1, #32
   10758:	f006 fef0 	bl	1753c <wc_RNG_HealthTest_ex>
                                    seedB + 32, sizeof(seedB_data) - 32,
                                    seedB, 32,
                                    NULL, 0,
                                    check, RNG_HEALTH_TEST_CHECK_SIZE,
                                    NULL, INVALID_DEVID);
            if (ret == 0) {
   1075c:	4602      	mov	r2, r0
   1075e:	2800      	cmp	r0, #0
   10760:	d160      	bne.n	10824 <_InitRng+0x164>
        compareSum |= a[i] ^ b[i];
   10762:	f815 3f01 	ldrb.w	r3, [r5, #1]!
   10766:	f81a 1f01 	ldrb.w	r1, [sl, #1]!
   1076a:	404b      	eors	r3, r1
   1076c:	431a      	orrs	r2, r3
    for (i = 0; i < length; i++) {
   1076e:	42b5      	cmp	r5, r6
   10770:	d1f7      	bne.n	10762 <_InitRng+0xa2>
                if (ConstantCompare(check, outputB, sizeof(outputB_data)) != 0)
   10772:	2a00      	cmp	r2, #0
   10774:	d156      	bne.n	10824 <_InitRng+0x164>
                (struct DRBG*)XMALLOC(sizeof(DRBG_internal), rng->heap,
   10776:	2084      	movs	r0, #132	; 0x84
   10778:	f011 f9f0 	bl	21b5c <malloc>
        rng->drbg =
   1077c:	60e0      	str	r0, [r4, #12]
        if (rng->drbg == NULL) {
   1077e:	b1d8      	cbz	r0, 107b8 <_InitRng+0xf8>
            ret = wc_GenerateSeed(&rng->seed, seed, seedSz);
   10780:	463a      	mov	r2, r7
   10782:	a908      	add	r1, sp, #32
   10784:	4620      	mov	r0, r4
   10786:	f009 fbd3 	bl	19f30 <wc_GenerateSeed>
            if (ret == 0)
   1078a:	b338      	cbz	r0, 107dc <_InitRng+0x11c>
                rng->status = DRBG_FAILED;
   1078c:	2302      	movs	r3, #2
   1078e:	7423      	strb	r3, [r4, #16]
                ret = DRBG_FAILURE;
   10790:	2501      	movs	r5, #1
                XFREE(rng->drbg, rng->heap, DYNAMIC_TYPE_RNG);
   10792:	68e0      	ldr	r0, [r4, #12]
   10794:	b108      	cbz	r0, 1079a <_InitRng+0xda>
   10796:	f011 f9e9 	bl	21b6c <free>
                rng->drbg = NULL;
   1079a:	2300      	movs	r3, #0
   1079c:	60e3      	str	r3, [r4, #12]
   1079e:	e00f      	b.n	107c0 <_InitRng+0x100>
    if (nonce == NULL && nonceSz != 0)
   107a0:	2a00      	cmp	r2, #0
   107a2:	d147      	bne.n	10834 <_InitRng+0x174>
    rng->heap = heap;
   107a4:	6083      	str	r3, [r0, #8]
    rng->devId = devId;
   107a6:	f8c0 b014 	str.w	fp, [r0, #20]
        rng->seed.devId = devId;
   107aa:	f8c0 b004 	str.w	fp, [r0, #4]
    rng->drbg = NULL;
   107ae:	2300      	movs	r3, #0
   107b0:	60c3      	str	r3, [r0, #12]
    rng->status = DRBG_NOT_INIT;
   107b2:	7403      	strb	r3, [r0, #16]
        seedSz = MAX_SEED_SZ;
   107b4:	2734      	movs	r7, #52	; 0x34
   107b6:	e79a      	b.n	106ee <_InitRng+0x2e>
            rng->status = DRBG_FAILED;
   107b8:	2302      	movs	r3, #2
   107ba:	7423      	strb	r3, [r4, #16]
            ret = MEMORY_E;
   107bc:	f06f 057c 	mvn.w	r5, #124	; 0x7c
    while (len--) *z++ = 0;
   107c0:	ab08      	add	r3, sp, #32
   107c2:	441f      	add	r7, r3
    volatile byte* z = (volatile byte*)mem;
   107c4:	461a      	mov	r2, r3
    while (len--) *z++ = 0;
   107c6:	2100      	movs	r1, #0
   107c8:	4613      	mov	r3, r2
   107ca:	f803 1b01 	strb.w	r1, [r3], #1
   107ce:	461a      	mov	r2, r3
   107d0:	42bb      	cmp	r3, r7
   107d2:	d1f9      	bne.n	107c8 <_InitRng+0x108>
    if (ret == DRBG_SUCCESS) {
   107d4:	b9cd      	cbnz	r5, 1080a <_InitRng+0x14a>
        rng->status = DRBG_OK;
   107d6:	2301      	movs	r3, #1
   107d8:	7423      	strb	r3, [r4, #16]
        ret = 0;
   107da:	e01f      	b.n	1081c <_InitRng+0x15c>
                ret = wc_RNG_TestSeed(seed, seedSz);
   107dc:	4639      	mov	r1, r7
   107de:	a808      	add	r0, sp, #32
   107e0:	f00a f9d4 	bl	1ab8c <wc_RNG_TestSeed>
            if (ret == DRBG_SUCCESS)
   107e4:	4605      	mov	r5, r0
   107e6:	2800      	cmp	r0, #0
   107e8:	d1d3      	bne.n	10792 <_InitRng+0xd2>
	      ret = Hash_DRBG_Instantiate((DRBG_internal *)rng->drbg,
   107ea:	f8cd b008 	str.w	fp, [sp, #8]
   107ee:	68a3      	ldr	r3, [r4, #8]
   107f0:	9301      	str	r3, [sp, #4]
   107f2:	f8cd 9000 	str.w	r9, [sp]
   107f6:	4643      	mov	r3, r8
   107f8:	1f3a      	subs	r2, r7, #4
   107fa:	a909      	add	r1, sp, #36	; 0x24
   107fc:	68e0      	ldr	r0, [r4, #12]
   107fe:	f009 fc7c 	bl	1a0fa <Hash_DRBG_Instantiate>
            if (ret != DRBG_SUCCESS) {
   10802:	4605      	mov	r5, r0
   10804:	2800      	cmp	r0, #0
   10806:	d0db      	beq.n	107c0 <_InitRng+0x100>
   10808:	e7c3      	b.n	10792 <_InitRng+0xd2>
    else if (ret == DRBG_CONT_FAILURE) {
   1080a:	2d03      	cmp	r5, #3
   1080c:	d00a      	beq.n	10824 <_InitRng+0x164>
    else if (ret == DRBG_FAILURE) {
   1080e:	2d01      	cmp	r5, #1
        rng->status = DRBG_FAILED;
   10810:	f04f 0302 	mov.w	r3, #2
   10814:	7423      	strb	r3, [r4, #16]
        ret = RNG_FAILURE_E;
   10816:	bf08      	it	eq
   10818:	f06f 05c6 	mvneq.w	r5, #198	; 0xc6
}
   1081c:	4628      	mov	r0, r5
   1081e:	b029      	add	sp, #164	; 0xa4
   10820:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        rng->status = DRBG_CONT_FAILED;
   10824:	2303      	movs	r3, #3
   10826:	7423      	strb	r3, [r4, #16]
        ret = DRBG_CONT_FIPS_E;
   10828:	f06f 05d0 	mvn.w	r5, #208	; 0xd0
   1082c:	e7f6      	b.n	1081c <_InitRng+0x15c>
        return BAD_FUNC_ARG;
   1082e:	f06f 05ac 	mvn.w	r5, #172	; 0xac
   10832:	e7f3      	b.n	1081c <_InitRng+0x15c>
        return BAD_FUNC_ARG;
   10834:	f06f 05ac 	mvn.w	r5, #172	; 0xac
   10838:	e7f0      	b.n	1081c <_InitRng+0x15c>
   1083a:	bf00      	nop
   1083c:	0001f314 	.word	0x0001f314
   10840:	000192e3 	.word	0x000192e3

Disassembly of section .text.SERCOM1_USART_InterruptHandler%253:

00010844 <SERCOM1_USART_InterruptHandler>:
        }
    }
}

void SERCOM1_USART_InterruptHandler( void )
{
   10844:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    bool testCondition = false;
    if(SERCOM1_REGS->USART_INT.SERCOM_INTENSET != 0U)
   10846:	4b5a      	ldr	r3, [pc, #360]	; (109b0 <SERCOM1_USART_InterruptHandler+0x16c>)
   10848:	7d9b      	ldrb	r3, [r3, #22]
   1084a:	2b00      	cmp	r3, #0
   1084c:	f000 80ae 	beq.w	109ac <SERCOM1_USART_InterruptHandler+0x168>
    {
        /* Checks for error flag */
        testCondition = ((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_ERROR_Msk) == SERCOM_USART_INT_INTFLAG_ERROR_Msk);
   10850:	4a57      	ldr	r2, [pc, #348]	; (109b0 <SERCOM1_USART_InterruptHandler+0x16c>)
   10852:	7e13      	ldrb	r3, [r2, #24]
   10854:	b2db      	uxtb	r3, r3
        testCondition = ((SERCOM1_REGS->USART_INT.SERCOM_INTENSET & SERCOM_USART_INT_INTENSET_ERROR_Msk) == SERCOM_USART_INT_INTENSET_ERROR_Msk) && testCondition;
   10856:	7d92      	ldrb	r2, [r2, #22]
   10858:	f012 0f80 	tst.w	r2, #128	; 0x80
   1085c:	d13e      	bne.n	108dc <SERCOM1_USART_InterruptHandler+0x98>
        if(testCondition)
        {
            SERCOM1_USART_ISR_ERR_Handler();
        }

        testCondition = ((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_DRE_Msk) == SERCOM_USART_INT_INTFLAG_DRE_Msk);
   1085e:	4a54      	ldr	r2, [pc, #336]	; (109b0 <SERCOM1_USART_InterruptHandler+0x16c>)
   10860:	7e13      	ldrb	r3, [r2, #24]
   10862:	b2db      	uxtb	r3, r3
        testCondition = ((SERCOM1_REGS->USART_INT.SERCOM_INTENSET & SERCOM_USART_INT_INTENSET_DRE_Msk) == SERCOM_USART_INT_INTENSET_DRE_Msk) && testCondition;
   10864:	7d92      	ldrb	r2, [r2, #22]
   10866:	f012 0f01 	tst.w	r2, #1
   1086a:	f000 8092 	beq.w	10992 <SERCOM1_USART_InterruptHandler+0x14e>
   1086e:	f013 0f01 	tst.w	r3, #1
   10872:	f000 808e 	beq.w	10992 <SERCOM1_USART_InterruptHandler+0x14e>
    while ((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_DRE_Msk) == SERCOM_USART_INT_INTFLAG_DRE_Msk)
   10876:	4d4e      	ldr	r5, [pc, #312]	; (109b0 <SERCOM1_USART_InterruptHandler+0x16c>)
    uint32_t wrInIndex = sercom1USARTObj.wrInIndex;
   10878:	4c4e      	ldr	r4, [pc, #312]	; (109b4 <SERCOM1_USART_InterruptHandler+0x170>)
            *pWrByte = ((uint16_t*)&SERCOM1_USART_WriteBuffer)[wrOutIndex++];
   1087a:	4e4f      	ldr	r6, [pc, #316]	; (109b8 <SERCOM1_USART_InterruptHandler+0x174>)
    while ((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_DRE_Msk) == SERCOM_USART_INT_INTFLAG_DRE_Msk)
   1087c:	7e2b      	ldrb	r3, [r5, #24]
   1087e:	f013 0f01 	tst.w	r3, #1
   10882:	f000 8086 	beq.w	10992 <SERCOM1_USART_InterruptHandler+0x14e>
    uint32_t wrInIndex = sercom1USARTObj.wrInIndex;
   10886:	68a3      	ldr	r3, [r4, #8]
    uint32_t wrOutIndex = sercom1USARTObj.wrOutIndex;
   10888:	68e2      	ldr	r2, [r4, #12]
    if (wrOutIndex != wrInIndex)
   1088a:	4293      	cmp	r3, r2
   1088c:	d07e      	beq.n	1098c <SERCOM1_USART_InterruptHandler+0x148>
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   1088e:	686b      	ldr	r3, [r5, #4]
   10890:	f003 0307 	and.w	r3, r3, #7
   10894:	2b01      	cmp	r3, #1
            *pWrByte = SERCOM1_USART_WriteBuffer[wrOutIndex++];
   10896:	f102 0301 	add.w	r3, r2, #1
   1089a:	bf14      	ite	ne
   1089c:	5cb2      	ldrbne	r2, [r6, r2]
            *pWrByte = ((uint16_t*)&SERCOM1_USART_WriteBuffer)[wrOutIndex++];
   1089e:	f836 2012 	ldrheq.w	r2, [r6, r2, lsl #1]
        if (wrOutIndex >= sercom1USARTObj.wrBufferSize)
   108a2:	6921      	ldr	r1, [r4, #16]
            wrOutIndex = 0U;
   108a4:	4299      	cmp	r1, r3
   108a6:	bf98      	it	ls
   108a8:	2300      	movls	r3, #0
        sercom1USARTObj.wrOutIndex = wrOutIndex;
   108aa:	60e3      	str	r3, [r4, #12]
            if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   108ac:	686b      	ldr	r3, [r5, #4]
   108ae:	f003 0307 	and.w	r3, r3, #7
   108b2:	2b01      	cmp	r3, #1
                SERCOM1_REGS->USART_INT.SERCOM_DATA = (uint8_t)wrByte;
   108b4:	bf18      	it	ne
   108b6:	b2d2      	uxtbne	r2, r2
                SERCOM1_REGS->USART_INT.SERCOM_DATA = wrByte;
   108b8:	62aa      	str	r2, [r5, #40]	; 0x28
    if (sercom1USARTObj.isWrNotificationEnabled == true)
   108ba:	7d23      	ldrb	r3, [r4, #20]
   108bc:	2b00      	cmp	r3, #0
   108be:	d0dd      	beq.n	1087c <SERCOM1_USART_InterruptHandler+0x38>
        nFreeWrBufferCount = SERCOM1_USART_WriteFreeBufferCountGet();
   108c0:	f010 ffc2 	bl	21848 <SERCOM1_USART_WriteFreeBufferCountGet>
        if(sercom1USARTObj.wrCallback != NULL)
   108c4:	6823      	ldr	r3, [r4, #0]
   108c6:	2b00      	cmp	r3, #0
   108c8:	d0d8      	beq.n	1087c <SERCOM1_USART_InterruptHandler+0x38>
            if (sercom1USARTObj.isWrNotifyPersistently == true)
   108ca:	7f22      	ldrb	r2, [r4, #28]
   108cc:	b342      	cbz	r2, 10920 <SERCOM1_USART_InterruptHandler+0xdc>
                if (nFreeWrBufferCount >= sercom1USARTObj.wrThreshold)
   108ce:	69a2      	ldr	r2, [r4, #24]
   108d0:	4290      	cmp	r0, r2
   108d2:	d3d3      	bcc.n	1087c <SERCOM1_USART_InterruptHandler+0x38>
                    sercom1USARTObj.wrCallback(SERCOM_USART_EVENT_WRITE_THRESHOLD_REACHED, sercom1USARTObj.wrContext);
   108d4:	6861      	ldr	r1, [r4, #4]
   108d6:	2003      	movs	r0, #3
   108d8:	4798      	blx	r3
   108da:	e7cf      	b.n	1087c <SERCOM1_USART_InterruptHandler+0x38>
        testCondition = ((SERCOM1_REGS->USART_INT.SERCOM_INTENSET & SERCOM_USART_INT_INTENSET_ERROR_Msk) == SERCOM_USART_INT_INTENSET_ERROR_Msk) && testCondition;
   108dc:	f013 0f80 	tst.w	r3, #128	; 0x80
   108e0:	d0bd      	beq.n	1085e <SERCOM1_USART_InterruptHandler+0x1a>
    USART_ERROR errorStatus = (USART_ERROR)(SERCOM1_REGS->USART_INT.SERCOM_STATUS & (SERCOM_USART_INT_STATUS_PERR_Msk | SERCOM_USART_INT_STATUS_FERR_Msk | SERCOM_USART_INT_STATUS_BUFOVF_Msk ));
   108e2:	4b33      	ldr	r3, [pc, #204]	; (109b0 <SERCOM1_USART_InterruptHandler+0x16c>)
   108e4:	8b5b      	ldrh	r3, [r3, #26]
    if(errorStatus != USART_ERROR_NONE)
   108e6:	f013 0307 	ands.w	r3, r3, #7
   108ea:	d0b8      	beq.n	1085e <SERCOM1_USART_InterruptHandler+0x1a>
        sercom1USARTObj.errorStatus = errorStatus;
   108ec:	4a31      	ldr	r2, [pc, #196]	; (109b4 <SERCOM1_USART_InterruptHandler+0x170>)
   108ee:	87d3      	strh	r3, [r2, #62]	; 0x3e
    SERCOM1_REGS->USART_INT.SERCOM_INTFLAG = SERCOM_USART_INT_INTFLAG_ERROR_Msk;
   108f0:	4b2f      	ldr	r3, [pc, #188]	; (109b0 <SERCOM1_USART_InterruptHandler+0x16c>)
   108f2:	2280      	movs	r2, #128	; 0x80
   108f4:	761a      	strb	r2, [r3, #24]
    SERCOM1_REGS->USART_INT.SERCOM_STATUS = SERCOM_USART_INT_STATUS_PERR_Msk | SERCOM_USART_INT_STATUS_FERR_Msk | SERCOM_USART_INT_STATUS_BUFOVF_Msk ;
   108f6:	2207      	movs	r2, #7
   108f8:	835a      	strh	r2, [r3, #26]
    while((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_RXC_Msk) == SERCOM_USART_INT_INTFLAG_RXC_Msk)
   108fa:	7e1b      	ldrb	r3, [r3, #24]
   108fc:	f013 0f04 	tst.w	r3, #4
   10900:	d005      	beq.n	1090e <SERCOM1_USART_InterruptHandler+0xca>
        u8dummyData = SERCOM1_REGS->USART_INT.SERCOM_DATA;
   10902:	4b2b      	ldr	r3, [pc, #172]	; (109b0 <SERCOM1_USART_InterruptHandler+0x16c>)
   10904:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    while((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_RXC_Msk) == SERCOM_USART_INT_INTFLAG_RXC_Msk)
   10906:	7e1a      	ldrb	r2, [r3, #24]
   10908:	f012 0f04 	tst.w	r2, #4
   1090c:	d1fa      	bne.n	10904 <SERCOM1_USART_InterruptHandler+0xc0>
        if(sercom1USARTObj.rdCallback != NULL)
   1090e:	4b29      	ldr	r3, [pc, #164]	; (109b4 <SERCOM1_USART_InterruptHandler+0x170>)
   10910:	6a1b      	ldr	r3, [r3, #32]
   10912:	2b00      	cmp	r3, #0
   10914:	d0a3      	beq.n	1085e <SERCOM1_USART_InterruptHandler+0x1a>
            sercom1USARTObj.rdCallback(SERCOM_USART_EVENT_READ_ERROR, sercom1USARTObj.rdContext);
   10916:	4a27      	ldr	r2, [pc, #156]	; (109b4 <SERCOM1_USART_InterruptHandler+0x170>)
   10918:	6a51      	ldr	r1, [r2, #36]	; 0x24
   1091a:	2002      	movs	r0, #2
   1091c:	4798      	blx	r3
   1091e:	e79e      	b.n	1085e <SERCOM1_USART_InterruptHandler+0x1a>
                if (nFreeWrBufferCount == sercom1USARTObj.wrThreshold)
   10920:	69a2      	ldr	r2, [r4, #24]
   10922:	4290      	cmp	r0, r2
   10924:	d1aa      	bne.n	1087c <SERCOM1_USART_InterruptHandler+0x38>
                    sercom1USARTObj.wrCallback(SERCOM_USART_EVENT_WRITE_THRESHOLD_REACHED, sercom1USARTObj.wrContext);
   10926:	6861      	ldr	r1, [r4, #4]
   10928:	2003      	movs	r0, #3
   1092a:	4798      	blx	r3
   1092c:	e7a6      	b.n	1087c <SERCOM1_USART_InterruptHandler+0x38>
        if(sercom1USARTObj.rdCallback != NULL)
   1092e:	6a22      	ldr	r2, [r4, #32]
   10930:	b1e2      	cbz	r2, 1096c <SERCOM1_USART_InterruptHandler+0x128>
            sercom1USARTObj.rdCallback(SERCOM_USART_EVENT_READ_BUFFER_FULL, sercom1USARTObj.rdContext);
   10932:	6a61      	ldr	r1, [r4, #36]	; 0x24
   10934:	4638      	mov	r0, r7
   10936:	4790      	blx	r2
            tempInIndex = sercom1USARTObj.rdInIndex + 1U;
   10938:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1093a:	3301      	adds	r3, #1
            if (tempInIndex >= sercom1USARTObj.rdBufferSize)
   1093c:	6b22      	ldr	r2, [r4, #48]	; 0x30
                tempInIndex = 0U;
   1093e:	4293      	cmp	r3, r2
   10940:	bf28      	it	cs
   10942:	2300      	movcs	r3, #0
   10944:	e012      	b.n	1096c <SERCOM1_USART_InterruptHandler+0x128>
            ((uint16_t*)&SERCOM1_USART_ReadBuffer)[sercom1USARTObj.rdInIndex] = rdByte;
   10946:	6aa1      	ldr	r1, [r4, #40]	; 0x28
   10948:	4a1c      	ldr	r2, [pc, #112]	; (109bc <SERCOM1_USART_InterruptHandler+0x178>)
        if (SERCOM1_USART_RxPushByte( (uint16_t)SERCOM1_REGS->USART_INT.SERCOM_DATA) == true)
   1094a:	f822 6011 	strh.w	r6, [r2, r1, lsl #1]
   1094e:	e018      	b.n	10982 <SERCOM1_USART_InterruptHandler+0x13e>
    while ((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_RXC_Msk) == SERCOM_USART_INT_INTFLAG_RXC_Msk)
   10950:	7e2b      	ldrb	r3, [r5, #24]
   10952:	f013 0f04 	tst.w	r3, #4
   10956:	d029      	beq.n	109ac <SERCOM1_USART_InterruptHandler+0x168>
        if (SERCOM1_USART_RxPushByte( (uint16_t)SERCOM1_REGS->USART_INT.SERCOM_DATA) == true)
   10958:	6aae      	ldr	r6, [r5, #40]	; 0x28
    tempInIndex = sercom1USARTObj.rdInIndex + 1U;
   1095a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1095c:	3301      	adds	r3, #1
    if (tempInIndex >= sercom1USARTObj.rdBufferSize)
   1095e:	6b22      	ldr	r2, [r4, #48]	; 0x30
        tempInIndex = 0U;
   10960:	4293      	cmp	r3, r2
   10962:	bf28      	it	cs
   10964:	2300      	movcs	r3, #0
    if (tempInIndex == sercom1USARTObj.rdOutIndex)
   10966:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   10968:	429a      	cmp	r2, r3
   1096a:	d0e0      	beq.n	1092e <SERCOM1_USART_InterruptHandler+0xea>
    if (tempInIndex != sercom1USARTObj.rdOutIndex)
   1096c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   1096e:	429a      	cmp	r2, r3
   10970:	d0ee      	beq.n	10950 <SERCOM1_USART_InterruptHandler+0x10c>
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   10972:	686a      	ldr	r2, [r5, #4]
   10974:	f002 0207 	and.w	r2, r2, #7
   10978:	2a01      	cmp	r2, #1
   1097a:	d0e4      	beq.n	10946 <SERCOM1_USART_InterruptHandler+0x102>
            SERCOM1_USART_ReadBuffer[sercom1USARTObj.rdInIndex] = (uint8_t)rdByte;
   1097c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   1097e:	490f      	ldr	r1, [pc, #60]	; (109bc <SERCOM1_USART_InterruptHandler+0x178>)
   10980:	548e      	strb	r6, [r1, r2]
        sercom1USARTObj.rdInIndex = tempInIndex;
   10982:	62a3      	str	r3, [r4, #40]	; 0x28
            SERCOM1_USART_ReadNotificationSend();
   10984:	f00c f9a8 	bl	1ccd8 <SERCOM1_USART_ReadNotificationSend>
            sercom1USARTObj.rdCallback(SERCOM_USART_EVENT_READ_BUFFER_FULL, sercom1USARTObj.rdContext);
   10988:	2701      	movs	r7, #1
   1098a:	e7e1      	b.n	10950 <SERCOM1_USART_InterruptHandler+0x10c>
            SERCOM1_USART_TX_INT_DISABLE();
   1098c:	4b08      	ldr	r3, [pc, #32]	; (109b0 <SERCOM1_USART_InterruptHandler+0x16c>)
   1098e:	2201      	movs	r2, #1
   10990:	751a      	strb	r2, [r3, #20]
        {
            SERCOM1_USART_ISR_TX_Handler();
        }

        /* Checks for receive complete empty flag */
        testCondition = (SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_RXC_Msk);
   10992:	4a07      	ldr	r2, [pc, #28]	; (109b0 <SERCOM1_USART_InterruptHandler+0x16c>)
   10994:	7e13      	ldrb	r3, [r2, #24]
   10996:	b2db      	uxtb	r3, r3
        testCondition = (SERCOM1_REGS->USART_INT.SERCOM_INTENSET & SERCOM_USART_INT_INTENSET_RXC_Msk) && testCondition;
   10998:	7d92      	ldrb	r2, [r2, #22]
   1099a:	f012 0f04 	tst.w	r2, #4
   1099e:	d005      	beq.n	109ac <SERCOM1_USART_InterruptHandler+0x168>
   109a0:	f013 0f04 	tst.w	r3, #4
   109a4:	d002      	beq.n	109ac <SERCOM1_USART_InterruptHandler+0x168>
    while ((SERCOM1_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_RXC_Msk) == SERCOM_USART_INT_INTFLAG_RXC_Msk)
   109a6:	4d02      	ldr	r5, [pc, #8]	; (109b0 <SERCOM1_USART_InterruptHandler+0x16c>)
    tempInIndex = sercom1USARTObj.rdInIndex + 1U;
   109a8:	4c02      	ldr	r4, [pc, #8]	; (109b4 <SERCOM1_USART_InterruptHandler+0x170>)
   109aa:	e7ed      	b.n	10988 <SERCOM1_USART_InterruptHandler+0x144>
        if(testCondition)
        {
            SERCOM1_USART_ISR_RX_Handler();
        }
    }
   109ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   109ae:	bf00      	nop
   109b0:	40003400 	.word	0x40003400
   109b4:	2000e1f0 	.word	0x2000e1f0
   109b8:	2000b004 	.word	0x2000b004
   109bc:	2000a004 	.word	0x2000a004

Disassembly of section .text._TcpCloseSocket%254:

000109c0 <_TcpCloseSocket>:
{
   109c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   109c4:	4604      	mov	r4, r0
   109c6:	460d      	mov	r5, r1
    if(pSkt->Flags.bServer !=  0 && pSkt->flags.forceKill == 0)
   109c8:	f890 3036 	ldrb.w	r3, [r0, #54]	; 0x36
   109cc:	f013 0f01 	tst.w	r3, #1
   109d0:	d024      	beq.n	10a1c <_TcpCloseSocket+0x5c>
   109d2:	f890 306d 	ldrb.w	r3, [r0, #109]	; 0x6d
   109d6:	f013 0f04 	tst.w	r3, #4
   109da:	d13b      	bne.n	10a54 <_TcpCloseSocket+0x94>
        freePkt = (pSkt->flags.openAddType == IP_ADDRESS_TYPE_ANY) ? true : false;
   109dc:	f890 306c 	ldrb.w	r3, [r0, #108]	; 0x6c
   109e0:	f013 0f03 	tst.w	r3, #3
   109e4:	bf0c      	ite	eq
   109e6:	2201      	moveq	r2, #1
   109e8:	2200      	movne	r2, #0
        sktIsKilled = false;
   109ea:	f04f 0a00 	mov.w	sl, #0
        freePkt = (pSkt->flags.openAddType == IP_ADDRESS_TYPE_ANY) ? true : false;
   109ee:	e017      	b.n	10a20 <_TcpCloseSocket+0x60>
            if(freePkt)
   109f0:	b1e2      	cbz	r2, 10a2c <_TcpCloseSocket+0x6c>
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   109f2:	2000      	movs	r0, #0
   109f4:	f010 fd52 	bl	2149c <OSAL_CRIT_Enter>
   109f8:	4601      	mov	r1, r0
    if(pSkt->pV4Pkt != 0)
   109fa:	6c66      	ldr	r6, [r4, #68]	; 0x44
   109fc:	2e00      	cmp	r6, #0
   109fe:	f000 808f 	beq.w	10b20 <_TcpCloseSocket+0x160>
        if((pSkt->pV4Pkt->macPkt.pktFlags & TCPIP_MAC_PKT_FLAG_QUEUED) == 0)
   10a02:	8c73      	ldrh	r3, [r6, #34]	; 0x22
   10a04:	f013 0f08 	tst.w	r3, #8
   10a08:	f040 808e 	bne.w	10b28 <_TcpCloseSocket+0x168>
        pSkt->pTxPkt = 0;
   10a0c:	2000      	movs	r0, #0
   10a0e:	6460      	str	r0, [r4, #68]	; 0x44
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   10a10:	f010 fe73 	bl	216fa <OSAL_CRIT_Leave>
                    TCPIP_PKT_PacketFree(pFreePkt);
   10a14:	4630      	mov	r0, r6
   10a16:	f00d fac7 	bl	1dfa8 <_TCPIP_PKT_PacketFree>
   10a1a:	e007      	b.n	10a2c <_TcpCloseSocket+0x6c>
        freePkt = true;
   10a1c:	2201      	movs	r2, #1
        sktIsKilled = true;
   10a1e:	4692      	mov	sl, r2
    while(pSkt->pTxPkt != NULL)
   10a20:	6c63      	ldr	r3, [r4, #68]	; 0x44
   10a22:	b11b      	cbz	r3, 10a2c <_TcpCloseSocket+0x6c>
        if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   10a24:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
   10a28:	2b01      	cmp	r3, #1
   10a2a:	d0e1      	beq.n	109f0 <_TcpCloseSocket+0x30>
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   10a2c:	2000      	movs	r0, #0
   10a2e:	f010 fd35 	bl	2149c <OSAL_CRIT_Enter>
    *pSigHandler = pSkt->sigHandler;
   10a32:	6f67      	ldr	r7, [r4, #116]	; 0x74
    *pSigParam = pSkt->sigParam;
   10a34:	f8d4 9078 	ldr.w	r9, [r4, #120]	; 0x78
    uint16_t sigMask = pSkt->sigMask;
   10a38:	f8b4 6072 	ldrh.w	r6, [r4, #114]	; 0x72
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   10a3c:	4601      	mov	r1, r0
   10a3e:	2000      	movs	r0, #0
   10a40:	f010 fe5b 	bl	216fa <OSAL_CRIT_Leave>
    if((tcpEvent &= sigMask))
   10a44:	4035      	ands	r5, r6
   10a46:	d008      	beq.n	10a5a <_TcpCloseSocket+0x9a>
        if(sigHandler != 0)
   10a48:	b1bf      	cbz	r7, 10a7a <_TcpCloseSocket+0xba>
            sktIx = pSkt->sktIx;
   10a4a:	f9b4 6034 	ldrsh.w	r6, [r4, #52]	; 0x34
            pSktNet = pSkt->pSktNet;
   10a4e:	f8d4 8040 	ldr.w	r8, [r4, #64]	; 0x40
   10a52:	e004      	b.n	10a5e <_TcpCloseSocket+0x9e>
        freePkt = true;
   10a54:	2201      	movs	r2, #1
        sktIsKilled = true;
   10a56:	4692      	mov	sl, r2
   10a58:	e7e2      	b.n	10a20 <_TcpCloseSocket+0x60>
    TCP_SOCKET   sktIx = 0; 
   10a5a:	2600      	movs	r6, #0
    TCPIP_NET_HANDLE pSktNet = 0;
   10a5c:	46b0      	mov	r8, r6
    if(sktIsKilled)
   10a5e:	f1ba 0f00 	cmp.w	sl, #0
   10a62:	d00e      	beq.n	10a82 <_TcpCloseSocket+0xc2>
        _TcpSocketKill(pSkt);
   10a64:	4620      	mov	r0, r4
   10a66:	f00b fe0b 	bl	1c680 <_TcpSocketKill>
    if(tcpEvent)
   10a6a:	b125      	cbz	r5, 10a76 <_TcpCloseSocket+0xb6>
        (*sigHandler)(sktIx, pSktNet, tcpEvent, sigParam);
   10a6c:	464b      	mov	r3, r9
   10a6e:	462a      	mov	r2, r5
   10a70:	4641      	mov	r1, r8
   10a72:	4630      	mov	r0, r6
   10a74:	47b8      	blx	r7
}
   10a76:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    TCP_SOCKET   sktIx = 0; 
   10a7a:	2600      	movs	r6, #0
    TCPIP_NET_HANDLE pSktNet = 0;
   10a7c:	46b0      	mov	r8, r6
            tcpEvent = 0;
   10a7e:	4635      	mov	r5, r6
   10a80:	e7ed      	b.n	10a5e <_TcpCloseSocket+0x9e>
	pSkt->remoteHash = pSkt->localPort;
   10a82:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
   10a86:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
	pSkt->txHead = pSkt->txStart;
   10a8a:	6823      	ldr	r3, [r4, #0]
   10a8c:	60a3      	str	r3, [r4, #8]
	pSkt->txTail = pSkt->txStart;
   10a8e:	60e3      	str	r3, [r4, #12]
	pSkt->txUnackedTail = pSkt->txStart;
   10a90:	6123      	str	r3, [r4, #16]
	pSkt->rxHead = pSkt->rxStart;
   10a92:	6963      	ldr	r3, [r4, #20]
   10a94:	61e3      	str	r3, [r4, #28]
	pSkt->rxTail = pSkt->rxStart;
   10a96:	6223      	str	r3, [r4, #32]
	pSkt->Flags.bTimerEnabled = 0;
   10a98:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
	pSkt->Flags.bTXASAPWithoutTimerReset = 0;
   10a9c:	f003 0381 	and.w	r3, r3, #129	; 0x81
   10aa0:	f36f 13c7 	bfc	r3, #7, #1
   10aa4:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
	pSkt->Flags.bTXFIN = 0;
   10aa8:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
	pSkt->Flags.bSocketReset = 1;
   10aac:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	pSkt->Flags.bRxFin = 0;
   10ab0:	f043 0302 	orr.w	r3, r3, #2
   10ab4:	f36f 0382 	bfc	r3, #2, #1
   10ab8:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37
	pSkt->flags.bFINSent = 0;
   10abc:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
    pSkt->flags.seqInc = 0;
   10ac0:	f894 206d 	ldrb.w	r2, [r4, #109]	; 0x6d
   10ac4:	f36f 0241 	bfc	r2, #1, #1
   10ac8:	f884 206d 	strb.w	r2, [r4, #109]	; 0x6d
	pSkt->flags.bRXNoneACKed2 = 0;
   10acc:	f003 03e3 	and.w	r3, r3, #227	; 0xe3
   10ad0:	f36f 1345 	bfc	r3, #5, #1
   10ad4:	f884 306c 	strb.w	r3, [r4, #108]	; 0x6c
    pSkt->MySEQ = 0;
   10ad8:	2100      	movs	r1, #0
   10ada:	64e1      	str	r1, [r4, #76]	; 0x4c
	pSkt->sHoleSize = -1;
   10adc:	f04f 30ff 	mov.w	r0, #4294967295
   10ae0:	6560      	str	r0, [r4, #84]	; 0x54
	pSkt->remoteWindow = 1;
   10ae2:	2001      	movs	r0, #1
   10ae4:	f8a4 005c 	strh.w	r0, [r4, #92]	; 0x5c
    pSkt->maxRemoteWindow = 1;
   10ae8:	f8a4 0066 	strh.w	r0, [r4, #102]	; 0x66
    pSkt->remotePort = 0;
   10aec:	f8a4 1058 	strh.w	r1, [r4, #88]	; 0x58
    pSkt->destAddress.Val = 0;
   10af0:	63a1      	str	r1, [r4, #56]	; 0x38
	pSkt->keepAliveCount = 0;
   10af2:	f884 1071 	strb.w	r1, [r4, #113]	; 0x71
    pSkt->addType = (IP_ADDRESS_TYPE)pSkt->flags.openAddType;
   10af6:	f003 0303 	and.w	r3, r3, #3
   10afa:	f884 306f 	strb.w	r3, [r4, #111]	; 0x6f
    if(pSkt->flags.openBindIf == 0)
   10afe:	b2d2      	uxtb	r2, r2
   10b00:	f012 0f20 	tst.w	r2, #32
        pSkt->pSktNet = 0;
   10b04:	bf04      	itt	eq
   10b06:	460b      	moveq	r3, r1
   10b08:	6421      	streq	r1, [r4, #64]	; 0x40
    if(pSkt->flags.openBindAdd == 0)
   10b0a:	f012 0f40 	tst.w	r2, #64	; 0x40
        pSkt->srcAddress.Val = 0;
   10b0e:	bf04      	itt	eq
   10b10:	2300      	moveq	r3, #0
   10b12:	63e3      	streq	r3, [r4, #60]	; 0x3c
    pSkt->dbgFlags.val = 0;
   10b14:	2300      	movs	r3, #0
   10b16:	f884 307d 	strb.w	r3, [r4, #125]	; 0x7d
    pSkt->smState = newState;
   10b1a:	f884 306e 	strb.w	r3, [r4, #110]	; 0x6e
   10b1e:	e7a4      	b.n	10a6a <_TcpCloseSocket+0xaa>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   10b20:	2000      	movs	r0, #0
   10b22:	f010 fdea 	bl	216fa <OSAL_CRIT_Leave>
                if(pFreePkt)
   10b26:	e781      	b.n	10a2c <_TcpCloseSocket+0x6c>
        pSkt->pTxPkt = 0;
   10b28:	2000      	movs	r0, #0
   10b2a:	6460      	str	r0, [r4, #68]	; 0x44
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   10b2c:	f010 fde5 	bl	216fa <OSAL_CRIT_Leave>
                if(pFreePkt)
   10b30:	e77c      	b.n	10a2c <_TcpCloseSocket+0x6c>

Disassembly of section .text.TCPIP_TCP_ArrayPut%255:

00010b34 <TCPIP_TCP_ArrayPut>:
{
   10b34:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    if(len == 0 || data == 0 || (pSkt = _TcpSocketChk(hTCP)) == 0)
   10b38:	2a00      	cmp	r2, #0
   10b3a:	f000 809e 	beq.w	10c7a <TCPIP_TCP_ArrayPut+0x146>
   10b3e:	460f      	mov	r7, r1
   10b40:	4615      	mov	r5, r2
   10b42:	2900      	cmp	r1, #0
   10b44:	f000 809d 	beq.w	10c82 <TCPIP_TCP_ArrayPut+0x14e>
   10b48:	f00f f8b4 	bl	1fcb4 <_TcpSocketChk>
   10b4c:	4604      	mov	r4, r0
   10b4e:	2800      	cmp	r0, #0
   10b50:	f000 8099 	beq.w	10c86 <TCPIP_TCP_ArrayPut+0x152>
    if(pSkt->pTxPkt == 0)
   10b54:	6c43      	ldr	r3, [r0, #68]	; 0x44
   10b56:	2b00      	cmp	r3, #0
   10b58:	f000 8097 	beq.w	10c8a <TCPIP_TCP_ArrayPut+0x156>
    return _TCPSocketTxFreeSize(pSkt);
   10b5c:	f00e f9fa 	bl	1ef54 <_TCPSocketTxFreeSize>
	if(wFreeTxSpace == 0)
   10b60:	4606      	mov	r6, r0
   10b62:	2800      	cmp	r0, #0
   10b64:	f000 8093 	beq.w	10c8e <TCPIP_TCP_ArrayPut+0x15a>
    wActualLen = len >= wFreeTxSpace ? wFreeTxSpace : len;
   10b68:	4285      	cmp	r5, r0
   10b6a:	bf28      	it	cs
   10b6c:	4605      	movcs	r5, r0
   10b6e:	b2ad      	uxth	r5, r5
	if(pSkt->txHead + wActualLen >= pSkt->txEnd)
   10b70:	68a0      	ldr	r0, [r4, #8]
   10b72:	6863      	ldr	r3, [r4, #4]
   10b74:	1942      	adds	r2, r0, r5
   10b76:	4293      	cmp	r3, r2
   10b78:	d930      	bls.n	10bdc <TCPIP_TCP_ArrayPut+0xa8>
    wActualLen = len >= wFreeTxSpace ? wFreeTxSpace : len;
   10b7a:	46a8      	mov	r8, r5
	uint16_t wRightLen = 0;
   10b7c:	f04f 0900 	mov.w	r9, #0
    memcpy((uint8_t*)pSkt->txHead, data, wActualLen);
   10b80:	4642      	mov	r2, r8
   10b82:	4639      	mov	r1, r7
   10b84:	68a0      	ldr	r0, [r4, #8]
   10b86:	f010 fa6b 	bl	21060 <memcpy>
	pSkt->txHead += wActualLen;
   10b8a:	68a3      	ldr	r3, [r4, #8]
   10b8c:	4443      	add	r3, r8
   10b8e:	60a3      	str	r3, [r4, #8]
    if(pSkt->txHead != pSkt->txUnackedTail)
   10b90:	6922      	ldr	r2, [r4, #16]
   10b92:	4293      	cmp	r3, r2
   10b94:	d019      	beq.n	10bca <TCPIP_TCP_ArrayPut+0x96>
        if(pSkt->flags.halfThresFlush != 0)
   10b96:	f894 706d 	ldrb.w	r7, [r4, #109]	; 0x6d
   10b9a:	f017 0f80 	tst.w	r7, #128	; 0x80
   10b9e:	d12d      	bne.n	10bfc <TCPIP_TCP_ArrayPut+0xc8>
        if(pSkt->txHead > pSkt->txUnackedTail)
   10ba0:	4293      	cmp	r3, r2
   10ba2:	d942      	bls.n	10c2a <TCPIP_TCP_ArrayPut+0xf6>
            toSendData = pSkt->txHead - pSkt->txUnackedTail;
   10ba4:	1a9b      	subs	r3, r3, r2
   10ba6:	b29b      	uxth	r3, r3
        if(toSendData > pSkt->remoteWindow)
   10ba8:	f8b4 005c 	ldrh.w	r0, [r4, #92]	; 0x5c
   10bac:	4601      	mov	r1, r0
   10bae:	4298      	cmp	r0, r3
   10bb0:	bf28      	it	cs
   10bb2:	4619      	movcs	r1, r3
        if(canSend >= pSkt->wRemoteMSS || canSend >= (pSkt->maxRemoteWindow >> 1))
   10bb4:	f8b4 5062 	ldrh.w	r5, [r4, #98]	; 0x62
   10bb8:	428d      	cmp	r5, r1
   10bba:	d947      	bls.n	10c4c <TCPIP_TCP_ArrayPut+0x118>
   10bbc:	f8b4 5066 	ldrh.w	r5, [r4, #102]	; 0x66
   10bc0:	ebb1 0f55 	cmp.w	r1, r5, lsr #1
   10bc4:	d242      	bcs.n	10c4c <TCPIP_TCP_ArrayPut+0x118>
        if(canSend == toSendData)
   10bc6:	4298      	cmp	r0, r3
   10bc8:	d236      	bcs.n	10c38 <TCPIP_TCP_ArrayPut+0x104>
	else if(!pSkt->Flags.bTimer2Enabled)
   10bca:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
   10bce:	f013 0f04 	tst.w	r3, #4
   10bd2:	d03f      	beq.n	10c54 <TCPIP_TCP_ArrayPut+0x120>
	return wActualLen + wRightLen;
   10bd4:	eb08 0609 	add.w	r6, r8, r9
   10bd8:	b2b6      	uxth	r6, r6
   10bda:	e04f      	b.n	10c7c <TCPIP_TCP_ArrayPut+0x148>
		wRightLen = pSkt->txEnd-pSkt->txHead;
   10bdc:	eba3 0900 	sub.w	r9, r3, r0
   10be0:	fa1f f989 	uxth.w	r9, r9
        memcpy((uint8_t*)pSkt->txHead, data, wRightLen);
   10be4:	464a      	mov	r2, r9
   10be6:	4639      	mov	r1, r7
   10be8:	f010 fa3a 	bl	21060 <memcpy>
		data += wRightLen;
   10bec:	444f      	add	r7, r9
		wActualLen -= wRightLen;
   10bee:	eba5 0809 	sub.w	r8, r5, r9
   10bf2:	fa1f f888 	uxth.w	r8, r8
		pSkt->txHead = pSkt->txStart;
   10bf6:	6823      	ldr	r3, [r4, #0]
   10bf8:	60a3      	str	r3, [r4, #8]
   10bfa:	e7c1      	b.n	10b80 <TCPIP_TCP_ArrayPut+0x4c>
            if(pSkt->Flags.bHalfFullFlush == 0 && wFreeTxSpace <=  ((pSkt->txEnd - pSkt->txStart) >> 1) )
   10bfc:	f894 1036 	ldrb.w	r1, [r4, #54]	; 0x36
   10c00:	f011 0f20 	tst.w	r1, #32
   10c04:	d1cc      	bne.n	10ba0 <TCPIP_TCP_ArrayPut+0x6c>
    wFreeTxSpace -= wActualLen; // new free space
   10c06:	1b75      	subs	r5, r6, r5
            if(pSkt->Flags.bHalfFullFlush == 0 && wFreeTxSpace <=  ((pSkt->txEnd - pSkt->txStart) >> 1) )
   10c08:	b2ad      	uxth	r5, r5
   10c0a:	6861      	ldr	r1, [r4, #4]
   10c0c:	6820      	ldr	r0, [r4, #0]
   10c0e:	1a09      	subs	r1, r1, r0
        if(toFlush == false)
   10c10:	ebb5 0f61 	cmp.w	r5, r1, asr #1
   10c14:	dcc4      	bgt.n	10ba0 <TCPIP_TCP_ArrayPut+0x6c>
        _TcpFlush(pSkt);
   10c16:	4620      	mov	r0, r4
   10c18:	f00f f860 	bl	1fcdc <_TcpFlush>
            pSkt->Flags.bHalfFullFlush = true;
   10c1c:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
   10c20:	f043 0320 	orr.w	r3, r3, #32
   10c24:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
   10c28:	e7d4      	b.n	10bd4 <TCPIP_TCP_ArrayPut+0xa0>
            toSendData = (pSkt->txEnd - pSkt->txUnackedTail) + (pSkt->txHead - pSkt->txStart);
   10c2a:	6861      	ldr	r1, [r4, #4]
   10c2c:	1a89      	subs	r1, r1, r2
   10c2e:	6820      	ldr	r0, [r4, #0]
   10c30:	1a1b      	subs	r3, r3, r0
   10c32:	440b      	add	r3, r1
   10c34:	b29b      	uxth	r3, r3
   10c36:	e7b7      	b.n	10ba8 <TCPIP_TCP_ArrayPut+0x74>
            if(pSkt->flags.forceFlush || (pSkt->Flags.delayAckSend == 0 && pSkt->txTail == pSkt->txUnackedTail))
   10c38:	f017 0f08 	tst.w	r7, #8
   10c3c:	d106      	bne.n	10c4c <TCPIP_TCP_ArrayPut+0x118>
   10c3e:	f994 3037 	ldrsb.w	r3, [r4, #55]	; 0x37
   10c42:	2b00      	cmp	r3, #0
   10c44:	dbc1      	blt.n	10bca <TCPIP_TCP_ArrayPut+0x96>
   10c46:	68e3      	ldr	r3, [r4, #12]
   10c48:	429a      	cmp	r2, r3
   10c4a:	d1be      	bne.n	10bca <TCPIP_TCP_ArrayPut+0x96>
        _TcpFlush(pSkt);
   10c4c:	4620      	mov	r0, r4
   10c4e:	f00f f845 	bl	1fcdc <_TcpFlush>
        if(toSetFlag)
   10c52:	e7bf      	b.n	10bd4 <TCPIP_TCP_ArrayPut+0xa0>
		pSkt->Flags.bTimer2Enabled = true;
   10c54:	f043 0304 	orr.w	r3, r3, #4
   10c58:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
		pSkt->eventTime2 = SYS_TMR_TickCountGet() + (TCPIP_TCP_AUTO_TRANSMIT_TIMEOUT_VAL * SYS_TMR_TickCounterFrequencyGet())/1000;
   10c5c:	f00f f9a6 	bl	1ffac <SYS_TMR_TickCountGet>
   10c60:	4605      	mov	r5, r0
   10c62:	f00f f9cb 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
   10c66:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   10c6a:	00c0      	lsls	r0, r0, #3
   10c6c:	4b0c      	ldr	r3, [pc, #48]	; (10ca0 <TCPIP_TCP_ArrayPut+0x16c>)
   10c6e:	fba3 3000 	umull	r3, r0, r3, r0
   10c72:	eb05 1090 	add.w	r0, r5, r0, lsr #6
   10c76:	62a0      	str	r0, [r4, #40]	; 0x28
   10c78:	e7ac      	b.n	10bd4 <TCPIP_TCP_ArrayPut+0xa0>
        return 0;
   10c7a:	4616      	mov	r6, r2
}
   10c7c:	4630      	mov	r0, r6
   10c7e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return 0;
   10c82:	2600      	movs	r6, #0
   10c84:	e7fa      	b.n	10c7c <TCPIP_TCP_ArrayPut+0x148>
   10c86:	2600      	movs	r6, #0
   10c88:	e7f8      	b.n	10c7c <TCPIP_TCP_ArrayPut+0x148>
        return 0;
   10c8a:	2600      	movs	r6, #0
   10c8c:	e7f6      	b.n	10c7c <TCPIP_TCP_ArrayPut+0x148>
    switch(pSkt->addType)
   10c8e:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
   10c92:	2b01      	cmp	r3, #1
   10c94:	d1f2      	bne.n	10c7c <TCPIP_TCP_ArrayPut+0x148>
            _TcpFlush(pSkt);
   10c96:	4620      	mov	r0, r4
   10c98:	f00f f820 	bl	1fcdc <_TcpFlush>
   10c9c:	e7ee      	b.n	10c7c <TCPIP_TCP_ArrayPut+0x148>
   10c9e:	bf00      	nop
   10ca0:	10624dd3 	.word	0x10624dd3

Disassembly of section .text.SERCOM0_SPI_InterruptHandler%256:

00010ca4 <SERCOM0_SPI_InterruptHandler>:
{
    uint32_t dataBits = 0U;
    uint32_t receivedData = 0U;
    static bool isLastByteTransferInProgress = false;

    if(SERCOM0_REGS->SPIM.SERCOM_INTENSET != 0U)
   10ca4:	4b58      	ldr	r3, [pc, #352]	; (10e08 <SERCOM0_SPI_InterruptHandler+0x164>)
   10ca6:	7d9b      	ldrb	r3, [r3, #22]
   10ca8:	2b00      	cmp	r3, #0
   10caa:	f000 80ab 	beq.w	10e04 <SERCOM0_SPI_InterruptHandler+0x160>
{
   10cae:	b510      	push	{r4, lr}
    {
        dataBits = SERCOM0_REGS->SPIM.SERCOM_CTRLB & SERCOM_SPIM_CTRLB_CHSIZE_Msk;
   10cb0:	4a55      	ldr	r2, [pc, #340]	; (10e08 <SERCOM0_SPI_InterruptHandler+0x164>)
   10cb2:	6853      	ldr	r3, [r2, #4]
   10cb4:	f003 0307 	and.w	r3, r3, #7

        if((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_RXC_Msk) == SERCOM_SPIM_INTFLAG_RXC_Msk)
   10cb8:	7e12      	ldrb	r2, [r2, #24]
   10cba:	f012 0f04 	tst.w	r2, #4
   10cbe:	d05b      	beq.n	10d78 <SERCOM0_SPI_InterruptHandler+0xd4>
        {
            receivedData =  SERCOM0_REGS->SPIM.SERCOM_DATA;
   10cc0:	4a51      	ldr	r2, [pc, #324]	; (10e08 <SERCOM0_SPI_InterruptHandler+0x164>)
   10cc2:	6a90      	ldr	r0, [r2, #40]	; 0x28

            if(sercom0SPIObj.rxCount < sercom0SPIObj.rxSize)
   10cc4:	4a51      	ldr	r2, [pc, #324]	; (10e0c <SERCOM0_SPI_InterruptHandler+0x168>)
   10cc6:	6951      	ldr	r1, [r2, #20]
   10cc8:	68d2      	ldr	r2, [r2, #12]
   10cca:	4291      	cmp	r1, r2
   10ccc:	d254      	bcs.n	10d78 <SERCOM0_SPI_InterruptHandler+0xd4>
            {
                if(dataBits == (uint32_t)SPI_DATA_BITS_8)
   10cce:	2b00      	cmp	r3, #0
   10cd0:	d143      	bne.n	10d5a <SERCOM0_SPI_InterruptHandler+0xb6>
                {
                    ((uint8_t*)sercom0SPIObj.rxBuffer)[sercom0SPIObj.rxCount++] = (uint8_t)receivedData;
   10cd2:	4b4e      	ldr	r3, [pc, #312]	; (10e0c <SERCOM0_SPI_InterruptHandler+0x168>)
   10cd4:	685a      	ldr	r2, [r3, #4]
   10cd6:	1c4c      	adds	r4, r1, #1
   10cd8:	615c      	str	r4, [r3, #20]
   10cda:	5450      	strb	r0, [r2, r1]
                }
            }
        }

        /* If there are more words to be transmitted, then transmit them here and keep track of the count */
        if((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_DRE_Msk) == SERCOM_SPIM_INTFLAG_DRE_Msk)
   10cdc:	4b4a      	ldr	r3, [pc, #296]	; (10e08 <SERCOM0_SPI_InterruptHandler+0x164>)
   10cde:	7e1b      	ldrb	r3, [r3, #24]
   10ce0:	f013 0f01 	tst.w	r3, #1
   10ce4:	d018      	beq.n	10d18 <SERCOM0_SPI_InterruptHandler+0x74>
        {
            /* Disable the DRE interrupt. This will be enabled back if more than
             * one byte is pending to be transmitted */
            SERCOM0_REGS->SPIM.SERCOM_INTENCLR = (uint8_t)SERCOM_SPIM_INTENCLR_DRE_Msk;
   10ce6:	4b48      	ldr	r3, [pc, #288]	; (10e08 <SERCOM0_SPI_InterruptHandler+0x164>)
   10ce8:	2201      	movs	r2, #1
   10cea:	751a      	strb	r2, [r3, #20]

            if(dataBits == (uint32_t)SPI_DATA_BITS_8)
            {
                if(sercom0SPIObj.txCount < sercom0SPIObj.txSize)
   10cec:	4b47      	ldr	r3, [pc, #284]	; (10e0c <SERCOM0_SPI_InterruptHandler+0x168>)
   10cee:	699a      	ldr	r2, [r3, #24]
   10cf0:	689b      	ldr	r3, [r3, #8]
   10cf2:	429a      	cmp	r2, r3
   10cf4:	d258      	bcs.n	10da8 <SERCOM0_SPI_InterruptHandler+0x104>
                {
                    SERCOM0_REGS->SPIM.SERCOM_DATA = ((uint8_t*)sercom0SPIObj.txBuffer)[sercom0SPIObj.txCount++];
   10cf6:	4b45      	ldr	r3, [pc, #276]	; (10e0c <SERCOM0_SPI_InterruptHandler+0x168>)
   10cf8:	6819      	ldr	r1, [r3, #0]
   10cfa:	1c50      	adds	r0, r2, #1
   10cfc:	6198      	str	r0, [r3, #24]
   10cfe:	5c8a      	ldrb	r2, [r1, r2]
   10d00:	4b41      	ldr	r3, [pc, #260]	; (10e08 <SERCOM0_SPI_InterruptHandler+0x164>)
   10d02:	629a      	str	r2, [r3, #40]	; 0x28
                {
                    /* Do nothing */
                }
            }

            if((sercom0SPIObj.txCount == sercom0SPIObj.txSize) && (sercom0SPIObj.dummySize == 0U))
   10d04:	4b41      	ldr	r3, [pc, #260]	; (10e0c <SERCOM0_SPI_InterruptHandler+0x168>)
   10d06:	699a      	ldr	r2, [r3, #24]
   10d08:	689b      	ldr	r3, [r3, #8]
   10d0a:	429a      	cmp	r2, r3
   10d0c:	d061      	beq.n	10dd2 <SERCOM0_SPI_InterruptHandler+0x12e>
                 * the TXC interrupt is not enabled until the very end.
                 */

                isLastByteTransferInProgress = true;
            }
            else if(sercom0SPIObj.rxCount == sercom0SPIObj.rxSize)
   10d0e:	4b3f      	ldr	r3, [pc, #252]	; (10e0c <SERCOM0_SPI_InterruptHandler+0x168>)
   10d10:	695a      	ldr	r2, [r3, #20]
   10d12:	68db      	ldr	r3, [r3, #12]
   10d14:	429a      	cmp	r2, r3
   10d16:	d069      	beq.n	10dec <SERCOM0_SPI_InterruptHandler+0x148>
            {
                /* Do nothing */
            }
        }

        if(((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_TXC_Msk) == SERCOM_SPIM_INTFLAG_TXC_Msk) && (isLastByteTransferInProgress == true))
   10d18:	4b3b      	ldr	r3, [pc, #236]	; (10e08 <SERCOM0_SPI_InterruptHandler+0x164>)
   10d1a:	7e1b      	ldrb	r3, [r3, #24]
   10d1c:	f013 0f02 	tst.w	r3, #2
   10d20:	d014      	beq.n	10d4c <SERCOM0_SPI_InterruptHandler+0xa8>
   10d22:	4b3b      	ldr	r3, [pc, #236]	; (10e10 <SERCOM0_SPI_InterruptHandler+0x16c>)
   10d24:	781b      	ldrb	r3, [r3, #0]
   10d26:	b1bb      	cbz	r3, 10d58 <SERCOM0_SPI_InterruptHandler+0xb4>
        {
            if(sercom0SPIObj.rxCount == sercom0SPIObj.rxSize)
   10d28:	4b38      	ldr	r3, [pc, #224]	; (10e0c <SERCOM0_SPI_InterruptHandler+0x168>)
   10d2a:	695a      	ldr	r2, [r3, #20]
   10d2c:	68db      	ldr	r3, [r3, #12]
   10d2e:	429a      	cmp	r2, r3
   10d30:	d10f      	bne.n	10d52 <SERCOM0_SPI_InterruptHandler+0xae>
            {
                sercom0SPIObj.transferIsBusy = false;
   10d32:	4b36      	ldr	r3, [pc, #216]	; (10e0c <SERCOM0_SPI_InterruptHandler+0x168>)
   10d34:	2200      	movs	r2, #0
   10d36:	771a      	strb	r2, [r3, #28]

                /* Disable the Data Register empty and Receive Complete Interrupt flags */
                SERCOM0_REGS->SPIM.SERCOM_INTENCLR = (uint8_t)(SERCOM_SPIM_INTENCLR_DRE_Msk | SERCOM_SPIM_INTENCLR_RXC_Msk | SERCOM_SPIM_INTENSET_TXC_Msk);
   10d38:	4933      	ldr	r1, [pc, #204]	; (10e08 <SERCOM0_SPI_InterruptHandler+0x164>)
   10d3a:	2007      	movs	r0, #7
   10d3c:	7508      	strb	r0, [r1, #20]

                isLastByteTransferInProgress = false;
   10d3e:	4934      	ldr	r1, [pc, #208]	; (10e10 <SERCOM0_SPI_InterruptHandler+0x16c>)
   10d40:	700a      	strb	r2, [r1, #0]

                if(sercom0SPIObj.callback != NULL)
   10d42:	6a1b      	ldr	r3, [r3, #32]
   10d44:	b143      	cbz	r3, 10d58 <SERCOM0_SPI_InterruptHandler+0xb4>
                {
                    sercom0SPIObj.callback(sercom0SPIObj.context);
   10d46:	4a31      	ldr	r2, [pc, #196]	; (10e0c <SERCOM0_SPI_InterruptHandler+0x168>)
   10d48:	6a50      	ldr	r0, [r2, #36]	; 0x24
   10d4a:	4798      	blx	r3
                }
            }
        }

        if(isLastByteTransferInProgress == true)
   10d4c:	4b30      	ldr	r3, [pc, #192]	; (10e10 <SERCOM0_SPI_InterruptHandler+0x16c>)
   10d4e:	781b      	ldrb	r3, [r3, #0]
   10d50:	b113      	cbz	r3, 10d58 <SERCOM0_SPI_InterruptHandler+0xb4>
        {
            /* For the last byte transfer, the DRE interrupt is already disabled.
             * Enable TXC interrupt to ensure no data is present in the shift
             * register before application callback is called.
             */
            SERCOM0_REGS->SPIM.SERCOM_INTENSET = (uint8_t)SERCOM_SPIM_INTENSET_TXC_Msk;
   10d52:	4b2d      	ldr	r3, [pc, #180]	; (10e08 <SERCOM0_SPI_InterruptHandler+0x164>)
   10d54:	2202      	movs	r2, #2
   10d56:	759a      	strb	r2, [r3, #22]
        }
    }
}
   10d58:	bd10      	pop	{r4, pc}
                    ((uint16_t*)sercom0SPIObj.rxBuffer)[sercom0SPIObj.rxCount++] = (uint16_t)receivedData;
   10d5a:	4b2c      	ldr	r3, [pc, #176]	; (10e0c <SERCOM0_SPI_InterruptHandler+0x168>)
   10d5c:	685a      	ldr	r2, [r3, #4]
   10d5e:	1c4c      	adds	r4, r1, #1
   10d60:	615c      	str	r4, [r3, #20]
   10d62:	f822 0011 	strh.w	r0, [r2, r1, lsl #1]
        if((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_DRE_Msk) == SERCOM_SPIM_INTFLAG_DRE_Msk)
   10d66:	4b28      	ldr	r3, [pc, #160]	; (10e08 <SERCOM0_SPI_InterruptHandler+0x164>)
   10d68:	7e1b      	ldrb	r3, [r3, #24]
   10d6a:	f013 0f01 	tst.w	r3, #1
   10d6e:	d0d3      	beq.n	10d18 <SERCOM0_SPI_InterruptHandler+0x74>
            SERCOM0_REGS->SPIM.SERCOM_INTENCLR = (uint8_t)SERCOM_SPIM_INTENCLR_DRE_Msk;
   10d70:	4b25      	ldr	r3, [pc, #148]	; (10e08 <SERCOM0_SPI_InterruptHandler+0x164>)
   10d72:	2201      	movs	r2, #1
   10d74:	751a      	strb	r2, [r3, #20]
            if(dataBits == (uint32_t)SPI_DATA_BITS_8)
   10d76:	e009      	b.n	10d8c <SERCOM0_SPI_InterruptHandler+0xe8>
        if((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_DRE_Msk) == SERCOM_SPIM_INTFLAG_DRE_Msk)
   10d78:	4a23      	ldr	r2, [pc, #140]	; (10e08 <SERCOM0_SPI_InterruptHandler+0x164>)
   10d7a:	7e12      	ldrb	r2, [r2, #24]
   10d7c:	f012 0f01 	tst.w	r2, #1
   10d80:	d0ca      	beq.n	10d18 <SERCOM0_SPI_InterruptHandler+0x74>
            SERCOM0_REGS->SPIM.SERCOM_INTENCLR = (uint8_t)SERCOM_SPIM_INTENCLR_DRE_Msk;
   10d82:	4a21      	ldr	r2, [pc, #132]	; (10e08 <SERCOM0_SPI_InterruptHandler+0x164>)
   10d84:	2101      	movs	r1, #1
   10d86:	7511      	strb	r1, [r2, #20]
            if(dataBits == (uint32_t)SPI_DATA_BITS_8)
   10d88:	2b00      	cmp	r3, #0
   10d8a:	d0af      	beq.n	10cec <SERCOM0_SPI_InterruptHandler+0x48>
                if(sercom0SPIObj.txCount < sercom0SPIObj.txSize)
   10d8c:	4b1f      	ldr	r3, [pc, #124]	; (10e0c <SERCOM0_SPI_InterruptHandler+0x168>)
   10d8e:	699a      	ldr	r2, [r3, #24]
   10d90:	689b      	ldr	r3, [r3, #8]
   10d92:	429a      	cmp	r2, r3
   10d94:	d212      	bcs.n	10dbc <SERCOM0_SPI_InterruptHandler+0x118>
                    SERCOM0_REGS->SPIM.SERCOM_DATA = ((uint16_t*)sercom0SPIObj.txBuffer)[sercom0SPIObj.txCount++];
   10d96:	4b1d      	ldr	r3, [pc, #116]	; (10e0c <SERCOM0_SPI_InterruptHandler+0x168>)
   10d98:	6819      	ldr	r1, [r3, #0]
   10d9a:	1c50      	adds	r0, r2, #1
   10d9c:	6198      	str	r0, [r3, #24]
   10d9e:	f831 2012 	ldrh.w	r2, [r1, r2, lsl #1]
   10da2:	4b19      	ldr	r3, [pc, #100]	; (10e08 <SERCOM0_SPI_InterruptHandler+0x164>)
   10da4:	629a      	str	r2, [r3, #40]	; 0x28
   10da6:	e7ad      	b.n	10d04 <SERCOM0_SPI_InterruptHandler+0x60>
                else if(sercom0SPIObj.dummySize > 0U)
   10da8:	4b18      	ldr	r3, [pc, #96]	; (10e0c <SERCOM0_SPI_InterruptHandler+0x168>)
   10daa:	691b      	ldr	r3, [r3, #16]
   10dac:	b323      	cbz	r3, 10df8 <SERCOM0_SPI_InterruptHandler+0x154>
                    SERCOM0_REGS->SPIM.SERCOM_DATA = 0xFFU;
   10dae:	4a16      	ldr	r2, [pc, #88]	; (10e08 <SERCOM0_SPI_InterruptHandler+0x164>)
   10db0:	21ff      	movs	r1, #255	; 0xff
   10db2:	6291      	str	r1, [r2, #40]	; 0x28
                    sercom0SPIObj.dummySize--;
   10db4:	3b01      	subs	r3, #1
   10db6:	4a15      	ldr	r2, [pc, #84]	; (10e0c <SERCOM0_SPI_InterruptHandler+0x168>)
   10db8:	6113      	str	r3, [r2, #16]
   10dba:	e7a3      	b.n	10d04 <SERCOM0_SPI_InterruptHandler+0x60>
                else if(sercom0SPIObj.dummySize > 0U)
   10dbc:	4b13      	ldr	r3, [pc, #76]	; (10e0c <SERCOM0_SPI_InterruptHandler+0x168>)
   10dbe:	691b      	ldr	r3, [r3, #16]
   10dc0:	b1d3      	cbz	r3, 10df8 <SERCOM0_SPI_InterruptHandler+0x154>
                    SERCOM0_REGS->SPIM.SERCOM_DATA = 0xFFFFU;
   10dc2:	4a11      	ldr	r2, [pc, #68]	; (10e08 <SERCOM0_SPI_InterruptHandler+0x164>)
   10dc4:	f64f 71ff 	movw	r1, #65535	; 0xffff
   10dc8:	6291      	str	r1, [r2, #40]	; 0x28
                    sercom0SPIObj.dummySize--;
   10dca:	3b01      	subs	r3, #1
   10dcc:	4a0f      	ldr	r2, [pc, #60]	; (10e0c <SERCOM0_SPI_InterruptHandler+0x168>)
   10dce:	6113      	str	r3, [r2, #16]
   10dd0:	e798      	b.n	10d04 <SERCOM0_SPI_InterruptHandler+0x60>
            if((sercom0SPIObj.txCount == sercom0SPIObj.txSize) && (sercom0SPIObj.dummySize == 0U))
   10dd2:	4b0e      	ldr	r3, [pc, #56]	; (10e0c <SERCOM0_SPI_InterruptHandler+0x168>)
   10dd4:	691b      	ldr	r3, [r3, #16]
   10dd6:	2b00      	cmp	r3, #0
   10dd8:	d199      	bne.n	10d0e <SERCOM0_SPI_InterruptHandler+0x6a>
                isLastByteTransferInProgress = true;
   10dda:	4b0d      	ldr	r3, [pc, #52]	; (10e10 <SERCOM0_SPI_InterruptHandler+0x16c>)
   10ddc:	2201      	movs	r2, #1
   10dde:	701a      	strb	r2, [r3, #0]
        if(((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_TXC_Msk) == SERCOM_SPIM_INTFLAG_TXC_Msk) && (isLastByteTransferInProgress == true))
   10de0:	4b09      	ldr	r3, [pc, #36]	; (10e08 <SERCOM0_SPI_InterruptHandler+0x164>)
   10de2:	7e1b      	ldrb	r3, [r3, #24]
   10de4:	f013 0f02 	tst.w	r3, #2
   10de8:	d19e      	bne.n	10d28 <SERCOM0_SPI_InterruptHandler+0x84>
   10dea:	e7b2      	b.n	10d52 <SERCOM0_SPI_InterruptHandler+0xae>
                SERCOM0_REGS->SPIM.SERCOM_INTENSET = (uint8_t)SERCOM_SPIM_INTENSET_DRE_Msk;
   10dec:	4b06      	ldr	r3, [pc, #24]	; (10e08 <SERCOM0_SPI_InterruptHandler+0x164>)
   10dee:	2201      	movs	r2, #1
   10df0:	759a      	strb	r2, [r3, #22]
                SERCOM0_REGS->SPIM.SERCOM_INTENCLR = (uint8_t)SERCOM_SPIM_INTENCLR_RXC_Msk;
   10df2:	2204      	movs	r2, #4
   10df4:	751a      	strb	r2, [r3, #20]
   10df6:	e78f      	b.n	10d18 <SERCOM0_SPI_InterruptHandler+0x74>
            if((sercom0SPIObj.txCount == sercom0SPIObj.txSize) && (sercom0SPIObj.dummySize == 0U))
   10df8:	4b04      	ldr	r3, [pc, #16]	; (10e0c <SERCOM0_SPI_InterruptHandler+0x168>)
   10dfa:	699a      	ldr	r2, [r3, #24]
   10dfc:	689b      	ldr	r3, [r3, #8]
   10dfe:	429a      	cmp	r2, r3
   10e00:	d185      	bne.n	10d0e <SERCOM0_SPI_InterruptHandler+0x6a>
   10e02:	e7ea      	b.n	10dda <SERCOM0_SPI_InterruptHandler+0x136>
   10e04:	4770      	bx	lr
   10e06:	bf00      	nop
   10e08:	40003000 	.word	0x40003000
   10e0c:	2000e29c 	.word	0x2000e29c
   10e10:	2000e72a 	.word	0x2000e72a

Disassembly of section .text._DHCPOptionHostName%257:

00010e14 <_DHCPOptionHostName>:
{
   10e14:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   10e18:	b087      	sub	sp, #28
   10e1a:	4681      	mov	r9, r0
   10e1c:	4688      	mov	r8, r1
    pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   10e1e:	4b56      	ldr	r3, [pc, #344]	; (10f78 <_DHCPOptionHostName+0x164>)
   10e20:	681c      	ldr	r4, [r3, #0]
   10e22:	f010 fef7 	bl	21c14 <TCPIP_STACK_NetIxGet>
   10e26:	275c      	movs	r7, #92	; 0x5c
   10e28:	fb07 4700 	mla	r7, r7, r0, r4
    if(pClient->nameCallback != 0)
   10e2c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   10e2e:	b173      	cbz	r3, 10e4e <_DHCPOptionHostName+0x3a>
        if((cbName = (*pClient->nameCallback)(pNetIf)) != 0)
   10e30:	4648      	mov	r0, r9
   10e32:	4798      	blx	r3
   10e34:	4606      	mov	r6, r0
   10e36:	b150      	cbz	r0, 10e4e <_DHCPOptionHostName+0x3a>
            if(strlen(cbName) >= 2)
   10e38:	f010 feb0 	bl	21b9c <strlen>
   10e3c:	2801      	cmp	r0, #1
   10e3e:	d906      	bls.n	10e4e <_DHCPOptionHostName+0x3a>
                if(pClient->flags.bWriteBack != 0)
   10e40:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
   10e44:	f013 0f40 	tst.w	r3, #64	; 0x40
   10e48:	d02b      	beq.n	10ea2 <_DHCPOptionHostName+0x8e>
                    writeBackLen = strlen(cbName) + 1;
   10e4a:	1c45      	adds	r5, r0, #1
   10e4c:	e004      	b.n	10e58 <_DHCPOptionHostName+0x44>
        srcName = (char*)TCPIP_STACK_NetBIOSName(pNetIf);
   10e4e:	4648      	mov	r0, r9
   10e50:	f011 f95f 	bl	22112 <TCPIP_STACK_NetBIOSName>
   10e54:	4606      	mov	r6, r0
   10e56:	2500      	movs	r5, #0
    memset(destBuffer, 0x0, destSize);
   10e58:	2300      	movs	r3, #0
   10e5a:	9300      	str	r3, [sp, #0]
   10e5c:	9301      	str	r3, [sp, #4]
   10e5e:	9302      	str	r3, [sp, #8]
   10e60:	9303      	str	r3, [sp, #12]
   10e62:	9304      	str	r3, [sp, #16]
   10e64:	f88d 3014 	strb.w	r3, [sp, #20]
    for(ix = 0; ix < destSize - 1; ix++)
   10e68:	f106 0414 	add.w	r4, r6, #20
    memset(destBuffer, 0x0, destSize);
   10e6c:	4632      	mov	r2, r6
    d = destBuffer;
   10e6e:	466b      	mov	r3, sp
        if(!isspace(currC))
   10e70:	4842      	ldr	r0, [pc, #264]	; (10f7c <_DHCPOptionHostName+0x168>)
        currC = *srcBuffer++;
   10e72:	f812 1b01 	ldrb.w	r1, [r2], #1
        if(!isspace(currC))
   10e76:	5c0f      	ldrb	r7, [r1, r0]
   10e78:	f017 0f08 	tst.w	r7, #8
            *d++ = currC;
   10e7c:	bf08      	it	eq
   10e7e:	f803 1b01 	strbeq.w	r1, [r3], #1
    for(ix = 0; ix < destSize - 1; ix++)
   10e82:	42a2      	cmp	r2, r4
   10e84:	d1f5      	bne.n	10e72 <_DHCPOptionHostName+0x5e>
    len = strlen(destBuffer);
   10e86:	4668      	mov	r0, sp
   10e88:	f010 fe88 	bl	21b9c <strlen>
   10e8c:	4604      	mov	r4, r0
   10e8e:	4607      	mov	r7, r0
    if(len)
   10e90:	2800      	cmp	r0, #0
   10e92:	d057      	beq.n	10f44 <_DHCPOptionHostName+0x130>
   10e94:	4669      	mov	r1, sp
        for(ix = 0; ix < len; ix++)
   10e96:	2200      	movs	r2, #0
            if(currC != '-' && currC != '.' && !isalnum(currC))
   10e98:	f8df e0e0 	ldr.w	lr, [pc, #224]	; 10f7c <_DHCPOptionHostName+0x168>
                *d = TCPIP_DHCP_HOST_REPLACE_CHAR;
   10e9c:	f04f 0c78 	mov.w	ip, #120	; 0x78
   10ea0:	e004      	b.n	10eac <_DHCPOptionHostName+0x98>
    int     writeBackLen = 0;
   10ea2:	2500      	movs	r5, #0
   10ea4:	e7d8      	b.n	10e58 <_DHCPOptionHostName+0x44>
        for(ix = 0; ix < len; ix++)
   10ea6:	3201      	adds	r2, #1
   10ea8:	4297      	cmp	r7, r2
   10eaa:	dd0e      	ble.n	10eca <_DHCPOptionHostName+0xb6>
            currC = *d;
   10eac:	f811 0b01 	ldrb.w	r0, [r1], #1
            if(currC != '-' && currC != '.' && !isalnum(currC))
   10eb0:	f1a0 032d 	sub.w	r3, r0, #45	; 0x2d
   10eb4:	b2db      	uxtb	r3, r3
   10eb6:	2b01      	cmp	r3, #1
   10eb8:	d9f5      	bls.n	10ea6 <_DHCPOptionHostName+0x92>
   10eba:	f810 300e 	ldrb.w	r3, [r0, lr]
   10ebe:	f013 0f07 	tst.w	r3, #7
                *d = TCPIP_DHCP_HOST_REPLACE_CHAR;
   10ec2:	bf08      	it	eq
   10ec4:	f801 cc01 	strbeq.w	ip, [r1, #-1]
   10ec8:	e7ed      	b.n	10ea6 <_DHCPOptionHostName+0x92>
        if(!isalpha(currC))
   10eca:	f89d 2000 	ldrb.w	r2, [sp]
   10ece:	4b2b      	ldr	r3, [pc, #172]	; (10f7c <_DHCPOptionHostName+0x168>)
   10ed0:	5cd3      	ldrb	r3, [r2, r3]
   10ed2:	f013 0f03 	tst.w	r3, #3
            destBuffer[0] = TCPIP_DHCP_HOST_REPLACE_CHAR;
   10ed6:	bf04      	itt	eq
   10ed8:	2378      	moveq	r3, #120	; 0x78
   10eda:	f88d 3000 	strbeq.w	r3, [sp]
        currC = destBuffer[len - 1];
   10ede:	1e63      	subs	r3, r4, #1
        if(!isalnum(currC))
   10ee0:	f81d 1003 	ldrb.w	r1, [sp, r3]
   10ee4:	4a25      	ldr	r2, [pc, #148]	; (10f7c <_DHCPOptionHostName+0x168>)
   10ee6:	5c8a      	ldrb	r2, [r1, r2]
   10ee8:	f012 0f07 	tst.w	r2, #7
   10eec:	d102      	bne.n	10ef4 <_DHCPOptionHostName+0xe0>
            destBuffer[len - 1] = TCPIP_DHCP_HOST_REPLACE_CHAR;
   10eee:	2278      	movs	r2, #120	; 0x78
   10ef0:	f80d 2003 	strb.w	r2, [sp, r3]
    if(writeBackLen)
   10ef4:	b365      	cbz	r5, 10f50 <_DHCPOptionHostName+0x13c>
        srcName[0] = 0;
   10ef6:	2300      	movs	r3, #0
   10ef8:	7033      	strb	r3, [r6, #0]
    if(pSendData->writeSpace >= sizeof(*pHost) + hostLen)
   10efa:	1ca7      	adds	r7, r4, #2
   10efc:	f8d8 3004 	ldr.w	r3, [r8, #4]
   10f00:	42bb      	cmp	r3, r7
    return -1;
   10f02:	bf38      	it	cc
   10f04:	f04f 35ff 	movcc.w	r5, #4294967295
    if(pSendData->writeSpace >= sizeof(*pHost) + hostLen)
   10f08:	d318      	bcc.n	10f3c <_DHCPOptionHostName+0x128>
        pHost = (TCPIP_DHCP_OPTION_DATA_HOST_NAME*)pSendData->pOpt;
   10f0a:	f8d8 0000 	ldr.w	r0, [r8]
        pHost->opt = TCPIP_DHCP_HOST_NAME;
   10f0e:	230c      	movs	r3, #12
   10f10:	7003      	strb	r3, [r0, #0]
        pHost->len = hostLen;
   10f12:	7044      	strb	r4, [r0, #1]
        memcpy(pHost->hostname, hostName, hostLen);
   10f14:	4622      	mov	r2, r4
   10f16:	4669      	mov	r1, sp
   10f18:	3002      	adds	r0, #2
   10f1a:	f010 f8a1 	bl	21060 <memcpy>
        if(writeBackLen)
   10f1e:	b165      	cbz	r5, 10f3a <_DHCPOptionHostName+0x126>
            if(writeBackLen > hostLen + 1)
   10f20:	3401      	adds	r4, #1
            memcpy(srcName, hostName, writeBackLen);
   10f22:	42a5      	cmp	r5, r4
   10f24:	bfa8      	it	ge
   10f26:	4625      	movge	r5, r4
   10f28:	462a      	mov	r2, r5
   10f2a:	4669      	mov	r1, sp
   10f2c:	4630      	mov	r0, r6
   10f2e:	f010 f897 	bl	21060 <memcpy>
            srcName[writeBackLen - 1] = 0;
   10f32:	4435      	add	r5, r6
   10f34:	2300      	movs	r3, #0
   10f36:	f805 3c01 	strb.w	r3, [r5, #-1]
        return sizeof(*pHost) + hostLen;
   10f3a:	463d      	mov	r5, r7
}
   10f3c:	4628      	mov	r0, r5
   10f3e:	b007      	add	sp, #28
   10f40:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if(writeBackLen)
   10f44:	2d00      	cmp	r5, #0
   10f46:	d0f9      	beq.n	10f3c <_DHCPOptionHostName+0x128>
        srcName[0] = 0;
   10f48:	2300      	movs	r3, #0
   10f4a:	7033      	strb	r3, [r6, #0]
        return 0;
   10f4c:	4605      	mov	r5, r0
   10f4e:	e7f5      	b.n	10f3c <_DHCPOptionHostName+0x128>
    if(pSendData->writeSpace >= sizeof(*pHost) + hostLen)
   10f50:	1ca7      	adds	r7, r4, #2
   10f52:	f8d8 3004 	ldr.w	r3, [r8, #4]
   10f56:	42bb      	cmp	r3, r7
    return -1;
   10f58:	bf38      	it	cc
   10f5a:	f04f 35ff 	movcc.w	r5, #4294967295
    if(pSendData->writeSpace >= sizeof(*pHost) + hostLen)
   10f5e:	d3ed      	bcc.n	10f3c <_DHCPOptionHostName+0x128>
        pHost = (TCPIP_DHCP_OPTION_DATA_HOST_NAME*)pSendData->pOpt;
   10f60:	f8d8 0000 	ldr.w	r0, [r8]
        pHost->opt = TCPIP_DHCP_HOST_NAME;
   10f64:	230c      	movs	r3, #12
   10f66:	7003      	strb	r3, [r0, #0]
        pHost->len = hostLen;
   10f68:	7044      	strb	r4, [r0, #1]
        memcpy(pHost->hostname, hostName, hostLen);
   10f6a:	4622      	mov	r2, r4
   10f6c:	4669      	mov	r1, sp
   10f6e:	3002      	adds	r0, #2
   10f70:	f010 f876 	bl	21060 <memcpy>
        if(writeBackLen)
   10f74:	e7e1      	b.n	10f3a <_DHCPOptionHostName+0x126>
   10f76:	bf00      	nop
   10f78:	2000e610 	.word	0x2000e610
   10f7c:	00013c61 	.word	0x00013c61

Disassembly of section .text.DRV_PIC32CGMAC_LibTxAckPacket%258:

00010f80 <DRV_PIC32CGMAC_LibTxAckPacket>:
{
   10f80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10f84:	b083      	sub	sp, #12
    DRV_PIC32CGMAC_HW_TXDCPT *pTxDesc = pMACDrv->sGmacData.gmac_queue[queueIdx].pTxDesc;
   10f86:	232c      	movs	r3, #44	; 0x2c
   10f88:	fb03 0301 	mla	r3, r3, r1, r0
   10f8c:	f8d3 60a0 	ldr.w	r6, [r3, #160]	; 0xa0
	uint16_t tailIndex = pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail;
   10f90:	f8b3 40b4 	ldrh.w	r4, [r3, #180]	; 0xb4
	uint16_t headIndex = pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescHead;
   10f94:	f8b3 80b2 	ldrh.w	r8, [r3, #178]	; 0xb2
    while((tailIndex != headIndex) &&
   10f98:	4544      	cmp	r4, r8
   10f9a:	f000 8096 	beq.w	110ca <DRV_PIC32CGMAC_LibTxAckPacket+0x14a>
          ((pTxDesc[tailIndex].tx_desc_status.val) & GMAC_TX_USED_BIT) &&
   10f9e:	00e3      	lsls	r3, r4, #3
   10fa0:	18f2      	adds	r2, r6, r3
   10fa2:	6855      	ldr	r5, [r2, #4]
    while((tailIndex != headIndex) &&
   10fa4:	2d00      	cmp	r5, #0
   10fa6:	f280 8092 	bge.w	110ce <DRV_PIC32CGMAC_LibTxAckPacket+0x14e>
          (pTxDesc[tailIndex].tx_desc_buffaddr != 0))
   10faa:	f856 5034 	ldr.w	r5, [r6, r4, lsl #3]
          ((pTxDesc[tailIndex].tx_desc_status.val) & GMAC_TX_USED_BIT) &&
   10fae:	2d00      	cmp	r5, #0
   10fb0:	f000 808f 	beq.w	110d2 <DRV_PIC32CGMAC_LibTxAckPacket+0x152>
   10fb4:	468b      	mov	fp, r1
   10fb6:	4682      	mov	sl, r0
        if(GMAC_TX_ERR_BITS & (pTxDesc[tailIndex].tx_desc_status.val) )
   10fb8:	6852      	ldr	r2, [r2, #4]
   10fba:	f012 5f60 	tst.w	r2, #939524096	; 0x38000000
   10fbe:	d10f      	bne.n	10fe0 <DRV_PIC32CGMAC_LibTxAckPacket+0x60>
        pbuff = (uint8_t*)((uint32_t)pTxDesc[tailIndex].tx_desc_buffaddr & pMACDrv->sGmacData._dataOffsetMask);
   10fc0:	58f3      	ldr	r3, [r6, r3]
   10fc2:	f8d0 20f0 	ldr.w	r2, [r0, #240]	; 0xf0
   10fc6:	4013      	ands	r3, r2
        TCPIP_MAC_SEGMENT_GAP_DCPT* pGap = (TCPIP_MAC_SEGMENT_GAP_DCPT*)(pbuff + pMACDrv->sGmacData._dcptOffset);
   10fc8:	f9b0 20ec 	ldrsh.w	r2, [r0, #236]	; 0xec
        pPkt = pGap->segmentPktPtr;
   10fcc:	5898      	ldr	r0, [r3, r2]
	DRV_PIC32CGMAC_RESULT res = DRV_PIC32CGMAC_RES_NO_PACKET;
   10fce:	2101      	movs	r1, #1
            pTxDesc[tailIndex].tx_desc_status.val &= GMAC_TX_USED_BIT | GMAC_TX_WRAP_BIT | GMAC_TX_LAST_BUFFER_BIT;
   10fd0:	f8df 910c 	ldr.w	r9, [pc, #268]	; 110e0 <DRV_PIC32CGMAC_LibTxAckPacket+0x160>
            pTxDesc[tailIndex].tx_desc_buffaddr = 0;
   10fd4:	2700      	movs	r7, #0
        pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail = tailIndex;
   10fd6:	232c      	movs	r3, #44	; 0x2c
   10fd8:	fb03 a30b 	mla	r3, r3, fp, sl
   10fdc:	9301      	str	r3, [sp, #4]
   10fde:	e03d      	b.n	1105c <DRV_PIC32CGMAC_LibTxAckPacket+0xdc>
            pMACDrv->sGmacData._txDiscard = true;
   10fe0:	2301      	movs	r3, #1
   10fe2:	f88a 30f7 	strb.w	r3, [sl, #247]	; 0xf7
            res = DRV_PIC32CGMAC_RES_TX_ERR;
   10fe6:	f06f 0106 	mvn.w	r1, #6
            break;
   10fea:	e06a      	b.n	110c2 <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
                pPkt->pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED;
   10fec:	8c43      	ldrh	r3, [r0, #34]	; 0x22
   10fee:	f023 0308 	bic.w	r3, r3, #8
   10ff2:	8443      	strh	r3, [r0, #34]	; 0x22
                (pMACDrv->sGmacData.pktAckF)(pPkt, TCPIP_MAC_PKT_ACK_TX_OK, TCPIP_THIS_MODULE_ID);				
   10ff4:	f8da 302c 	ldr.w	r3, [sl, #44]	; 0x2c
   10ff8:	f241 0250 	movw	r2, #4176	; 0x1050
   10ffc:	2101      	movs	r1, #1
   10ffe:	4798      	blx	r3
                pMACDrv->sGmacData._txStat.nTxOkPackets++;
   11000:	f8da 307c 	ldr.w	r3, [sl, #124]	; 0x7c
   11004:	3301      	adds	r3, #1
   11006:	f8ca 307c 	str.w	r3, [sl, #124]	; 0x7c
                pTxDesc[tailIndex].tx_desc_status.val &= ~GMAC_TX_LAST_BUFFER_BIT;
   1100a:	686b      	ldr	r3, [r5, #4]
   1100c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
   11010:	606b      	str	r3, [r5, #4]
                GCIRC_INC(tailIndex, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt);   
   11012:	3401      	adds	r4, #1
   11014:	b2a4      	uxth	r4, r4
   11016:	eb0b 03cb 	add.w	r3, fp, fp, lsl #3
   1101a:	eb0a 0343 	add.w	r3, sl, r3, lsl #1
   1101e:	f8b3 30c8 	ldrh.w	r3, [r3, #200]	; 0xc8
   11022:	42a3      	cmp	r3, r4
   11024:	bf98      	it	ls
   11026:	2400      	movls	r4, #0
        pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail = tailIndex;
   11028:	9b01      	ldr	r3, [sp, #4]
   1102a:	f8a3 40b4 	strh.w	r4, [r3, #180]	; 0xb4
    while((tailIndex != headIndex) &&
   1102e:	4544      	cmp	r4, r8
   11030:	d051      	beq.n	110d6 <DRV_PIC32CGMAC_LibTxAckPacket+0x156>
          ((pTxDesc[tailIndex].tx_desc_status.val) & GMAC_TX_USED_BIT) &&
   11032:	00e2      	lsls	r2, r4, #3
   11034:	18b3      	adds	r3, r6, r2
   11036:	6859      	ldr	r1, [r3, #4]
    while((tailIndex != headIndex) &&
   11038:	2900      	cmp	r1, #0
   1103a:	da4e      	bge.n	110da <DRV_PIC32CGMAC_LibTxAckPacket+0x15a>
          (pTxDesc[tailIndex].tx_desc_buffaddr != 0))
   1103c:	f856 1034 	ldr.w	r1, [r6, r4, lsl #3]
          ((pTxDesc[tailIndex].tx_desc_status.val) & GMAC_TX_USED_BIT) &&
   11040:	2900      	cmp	r1, #0
   11042:	d03e      	beq.n	110c2 <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
        if(GMAC_TX_ERR_BITS & (pTxDesc[tailIndex].tx_desc_status.val) )
   11044:	685b      	ldr	r3, [r3, #4]
   11046:	f013 5f60 	tst.w	r3, #939524096	; 0x38000000
   1104a:	d1c9      	bne.n	10fe0 <DRV_PIC32CGMAC_LibTxAckPacket+0x60>
        pbuff = (uint8_t*)((uint32_t)pTxDesc[tailIndex].tx_desc_buffaddr & pMACDrv->sGmacData._dataOffsetMask);
   1104c:	58b3      	ldr	r3, [r6, r2]
   1104e:	f8da 20f0 	ldr.w	r2, [sl, #240]	; 0xf0
   11052:	4013      	ands	r3, r2
        TCPIP_MAC_SEGMENT_GAP_DCPT* pGap = (TCPIP_MAC_SEGMENT_GAP_DCPT*)(pbuff + pMACDrv->sGmacData._dcptOffset);
   11054:	f9ba 20ec 	ldrsh.w	r2, [sl, #236]	; 0xec
        pPkt = pGap->segmentPktPtr;
   11058:	5898      	ldr	r0, [r3, r2]
            GCIRC_INC(tailIndex, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt);  
   1105a:	4639      	mov	r1, r7
            pTxDesc[tailIndex].tx_desc_status.val |= GMAC_TX_USED_BIT;
   1105c:	eb06 05c4 	add.w	r5, r6, r4, lsl #3
   11060:	686b      	ldr	r3, [r5, #4]
   11062:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   11066:	606b      	str	r3, [r5, #4]
            pTxDesc[tailIndex].tx_desc_status.val &= GMAC_TX_USED_BIT | GMAC_TX_WRAP_BIT | GMAC_TX_LAST_BUFFER_BIT;
   11068:	686b      	ldr	r3, [r5, #4]
   1106a:	ea03 0309 	and.w	r3, r3, r9
   1106e:	606b      	str	r3, [r5, #4]
            pTxDesc[tailIndex].tx_desc_buffaddr = 0;
   11070:	f846 7034 	str.w	r7, [r6, r4, lsl #3]
            if(GMAC_TX_LAST_BUFFER_BIT & (pTxDesc[tailIndex].tx_desc_status.val) )
   11074:	686b      	ldr	r3, [r5, #4]
   11076:	f413 4f00 	tst.w	r3, #32768	; 0x8000
   1107a:	d1b7      	bne.n	10fec <DRV_PIC32CGMAC_LibTxAckPacket+0x6c>
            GCIRC_INC(tailIndex, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt);  
   1107c:	eb0b 02cb 	add.w	r2, fp, fp, lsl #3
   11080:	eb0a 0242 	add.w	r2, sl, r2, lsl #1
   11084:	3401      	adds	r4, #1
   11086:	b2a4      	uxth	r4, r4
   11088:	f8b2 30c8 	ldrh.w	r3, [r2, #200]	; 0xc8
   1108c:	42a3      	cmp	r3, r4
   1108e:	bf98      	it	ls
   11090:	2400      	movls	r4, #0
        while(tailIndex != headIndex)
   11092:	4544      	cmp	r4, r8
   11094:	d010      	beq.n	110b8 <DRV_PIC32CGMAC_LibTxAckPacket+0x138>
            pTxDesc[tailIndex].tx_desc_status.val |= GMAC_TX_USED_BIT;
   11096:	eb06 05c4 	add.w	r5, r6, r4, lsl #3
   1109a:	686b      	ldr	r3, [r5, #4]
   1109c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   110a0:	606b      	str	r3, [r5, #4]
            pTxDesc[tailIndex].tx_desc_status.val &= GMAC_TX_USED_BIT | GMAC_TX_WRAP_BIT | GMAC_TX_LAST_BUFFER_BIT;
   110a2:	686b      	ldr	r3, [r5, #4]
   110a4:	ea03 0309 	and.w	r3, r3, r9
   110a8:	606b      	str	r3, [r5, #4]
            pTxDesc[tailIndex].tx_desc_buffaddr = 0;
   110aa:	f846 7034 	str.w	r7, [r6, r4, lsl #3]
            if(GMAC_TX_LAST_BUFFER_BIT & (pTxDesc[tailIndex].tx_desc_status.val) )
   110ae:	686b      	ldr	r3, [r5, #4]
   110b0:	f413 4f00 	tst.w	r3, #32768	; 0x8000
   110b4:	d0e6      	beq.n	11084 <DRV_PIC32CGMAC_LibTxAckPacket+0x104>
   110b6:	e799      	b.n	10fec <DRV_PIC32CGMAC_LibTxAckPacket+0x6c>
        pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail = tailIndex;
   110b8:	232c      	movs	r3, #44	; 0x2c
   110ba:	fb03 aa0b 	mla	sl, r3, fp, sl
   110be:	f8aa 80b4 	strh.w	r8, [sl, #180]	; 0xb4
} //DRV_PIC32CGMAC_LibTxAckPacket
   110c2:	4608      	mov	r0, r1
   110c4:	b003      	add	sp, #12
   110c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	DRV_PIC32CGMAC_RESULT res = DRV_PIC32CGMAC_RES_NO_PACKET;
   110ca:	2101      	movs	r1, #1
   110cc:	e7f9      	b.n	110c2 <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
   110ce:	2101      	movs	r1, #1
   110d0:	e7f7      	b.n	110c2 <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
   110d2:	2101      	movs	r1, #1
   110d4:	e7f5      	b.n	110c2 <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
   110d6:	2100      	movs	r1, #0
   110d8:	e7f3      	b.n	110c2 <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
   110da:	2100      	movs	r1, #0
	return res;	
   110dc:	e7f1      	b.n	110c2 <DRV_PIC32CGMAC_LibTxAckPacket+0x142>
   110de:	bf00      	nop
   110e0:	c0008000 	.word	0xc0008000

Disassembly of section .text._Command_NetworkOnOff%259:

000110e4 <_Command_NetworkOnOff>:
{
   110e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   110e8:	b094      	sub	sp, #80	; 0x50
   110ea:	4604      	mov	r4, r0
    TCPIP_STACK_INIT    tcpip_init_data = {{0}};
   110ec:	2300      	movs	r3, #0
   110ee:	9300      	str	r3, [sp, #0]
   110f0:	9301      	str	r3, [sp, #4]
   110f2:	9302      	str	r3, [sp, #8]
   110f4:	9303      	str	r3, [sp, #12]
   110f6:	9304      	str	r3, [sp, #16]
   110f8:	9305      	str	r3, [sp, #20]
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   110fa:	6845      	ldr	r5, [r0, #4]
    if (argc != 3)
   110fc:	2903      	cmp	r1, #3
   110fe:	d010      	beq.n	11122 <_Command_NetworkOnOff+0x3e>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: if <interface> <down/up> \r\n");
   11100:	4e46      	ldr	r6, [pc, #280]	; (1121c <_Command_NetworkOnOff+0x138>)
   11102:	6803      	ldr	r3, [r0, #0]
   11104:	681b      	ldr	r3, [r3, #0]
   11106:	f506 612e 	add.w	r1, r6, #2784	; 0xae0
   1110a:	4628      	mov	r0, r5
   1110c:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: if PIC32INT down \r\n");
   1110e:	6823      	ldr	r3, [r4, #0]
   11110:	681b      	ldr	r3, [r3, #0]
   11112:	f606 3104 	addw	r1, r6, #2820	; 0xb04
   11116:	4628      	mov	r0, r5
   11118:	4798      	blx	r3
        return false;
   1111a:	2000      	movs	r0, #0
}
   1111c:	b014      	add	sp, #80	; 0x50
   1111e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11122:	4616      	mov	r6, r2
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
   11124:	6850      	ldr	r0, [r2, #4]
   11126:	f00c fc15 	bl	1d954 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
   1112a:	4607      	mov	r7, r0
   1112c:	b1b8      	cbz	r0, 1115e <_Command_NetworkOnOff+0x7a>
    net_ix = TCPIP_STACK_NetIndexGet(netH);
   1112e:	f010 fd6a 	bl	21c06 <TCPIP_STACK_NetIndexGet>
   11132:	4680      	mov	r8, r0
    if (memcmp(argv[2], "up", 2) == 0)
   11134:	68b6      	ldr	r6, [r6, #8]
   11136:	2202      	movs	r2, #2
   11138:	4939      	ldr	r1, [pc, #228]	; (11220 <_Command_NetworkOnOff+0x13c>)
   1113a:	4630      	mov	r0, r6
   1113c:	f00f ff82 	bl	21044 <memcmp>
   11140:	b1a0      	cbz	r0, 1116c <_Command_NetworkOnOff+0x88>
    else if (memcmp(argv[2], "down", 4) == 0)
   11142:	2204      	movs	r2, #4
   11144:	4937      	ldr	r1, [pc, #220]	; (11224 <_Command_NetworkOnOff+0x140>)
   11146:	4630      	mov	r0, r6
   11148:	f00f ff7c 	bl	21044 <memcmp>
   1114c:	2800      	cmp	r0, #0
   1114e:	d048      	beq.n	111e2 <_Command_NetworkOnOff+0xfe>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Wrong parameter specified \r\n");
   11150:	6823      	ldr	r3, [r4, #0]
   11152:	681b      	ldr	r3, [r3, #0]
   11154:	4934      	ldr	r1, [pc, #208]	; (11228 <_Command_NetworkOnOff+0x144>)
   11156:	4628      	mov	r0, r5
   11158:	4798      	blx	r3
        return false;
   1115a:	2000      	movs	r0, #0
   1115c:	e7de      	b.n	1111c <_Command_NetworkOnOff+0x38>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   1115e:	6823      	ldr	r3, [r4, #0]
   11160:	681b      	ldr	r3, [r3, #0]
   11162:	4932      	ldr	r1, [pc, #200]	; (1122c <_Command_NetworkOnOff+0x148>)
   11164:	4628      	mov	r0, r5
   11166:	4798      	blx	r3
        return false;
   11168:	2000      	movs	r0, #0
   1116a:	e7d7      	b.n	1111c <_Command_NetworkOnOff+0x38>
        if(TCPIP_STACK_NetIsUp(netH))
   1116c:	4638      	mov	r0, r7
   1116e:	f00f fea5 	bl	20ebc <TCPIP_STACK_NetIsUp>
   11172:	b130      	cbz	r0, 11182 <_Command_NetworkOnOff+0x9e>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "This interface already up\r\n");
   11174:	6823      	ldr	r3, [r4, #0]
   11176:	681b      	ldr	r3, [r3, #0]
   11178:	492d      	ldr	r1, [pc, #180]	; (11230 <_Command_NetworkOnOff+0x14c>)
   1117a:	4628      	mov	r0, r5
   1117c:	4798      	blx	r3
            return true;
   1117e:	2001      	movs	r0, #1
   11180:	e7cc      	b.n	1111c <_Command_NetworkOnOff+0x38>
        tcpipStackObj = TCPIP_STACK_Initialize(0, 0);
   11182:	2100      	movs	r1, #0
   11184:	4608      	mov	r0, r1
   11186:	f007 fa77 	bl	18678 <TCPIP_STACK_Initialize>
        TCPIP_STACK_InitializeDataGet(tcpipStackObj, &tcpip_init_data);
   1118a:	4669      	mov	r1, sp
   1118c:	f00d ffba 	bl	1f104 <TCPIP_STACK_InitializeDataGet>
        if(tcpip_init_data.pNetConf == 0)
   11190:	9e01      	ldr	r6, [sp, #4]
   11192:	b1fe      	cbz	r6, 111d4 <_Command_NetworkOnOff+0xf0>
        memcpy(pIfConf, tcpip_init_data.pNetConf + net_ix, sizeof(*pIfConf));
   11194:	fa1f f888 	uxth.w	r8, r8
   11198:	ebc8 08c8 	rsb	r8, r8, r8, lsl #3
   1119c:	eb06 06c8 	add.w	r6, r6, r8, lsl #3
   111a0:	f10d 0e18 	add.w	lr, sp, #24
   111a4:	f106 0830 	add.w	r8, r6, #48	; 0x30
   111a8:	46f4      	mov	ip, lr
   111aa:	6830      	ldr	r0, [r6, #0]
   111ac:	6871      	ldr	r1, [r6, #4]
   111ae:	68b2      	ldr	r2, [r6, #8]
   111b0:	68f3      	ldr	r3, [r6, #12]
   111b2:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   111b6:	3610      	adds	r6, #16
   111b8:	46e6      	mov	lr, ip
   111ba:	4546      	cmp	r6, r8
   111bc:	d1f4      	bne.n	111a8 <_Command_NetworkOnOff+0xc4>
   111be:	6830      	ldr	r0, [r6, #0]
   111c0:	6871      	ldr	r1, [r6, #4]
   111c2:	e8ae 0003 	stmia.w	lr!, {r0, r1}
        pIfConf->powerMode = TCPIP_STACK_IF_POWER_FULL;
   111c6:	4b1b      	ldr	r3, [pc, #108]	; (11234 <_Command_NetworkOnOff+0x150>)
   111c8:	930e      	str	r3, [sp, #56]	; 0x38
        res = TCPIP_STACK_NetUp(netH, pIfConf);
   111ca:	a906      	add	r1, sp, #24
   111cc:	4638      	mov	r0, r7
   111ce:	f005 fc17 	bl	16a00 <TCPIP_STACK_NetUp>
   111d2:	e014      	b.n	111fe <_Command_NetworkOnOff+0x11a>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Operation failed. No configuration\r\n");
   111d4:	6823      	ldr	r3, [r4, #0]
   111d6:	681b      	ldr	r3, [r3, #0]
   111d8:	4917      	ldr	r1, [pc, #92]	; (11238 <_Command_NetworkOnOff+0x154>)
   111da:	4628      	mov	r0, r5
   111dc:	4798      	blx	r3
            return true;
   111de:	2001      	movs	r0, #1
   111e0:	e79c      	b.n	1111c <_Command_NetworkOnOff+0x38>
        if(TCPIP_STACK_NetIsUp(netH) == 0)
   111e2:	4638      	mov	r0, r7
   111e4:	f00f fe6a 	bl	20ebc <TCPIP_STACK_NetIsUp>
   111e8:	b930      	cbnz	r0, 111f8 <_Command_NetworkOnOff+0x114>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "This interface already down\r\n");
   111ea:	6823      	ldr	r3, [r4, #0]
   111ec:	681b      	ldr	r3, [r3, #0]
   111ee:	4913      	ldr	r1, [pc, #76]	; (1123c <_Command_NetworkOnOff+0x158>)
   111f0:	4628      	mov	r0, r5
   111f2:	4798      	blx	r3
            return true;
   111f4:	2001      	movs	r0, #1
   111f6:	e791      	b.n	1111c <_Command_NetworkOnOff+0x38>
        res = TCPIP_STACK_NetDown(netH);
   111f8:	4638      	mov	r0, r7
   111fa:	f00d fbaf 	bl	1e95c <TCPIP_STACK_NetDown>
    if (res == true)
   111fe:	b130      	cbz	r0, 1120e <_Command_NetworkOnOff+0x12a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Operation successful!\r\n");
   11200:	6823      	ldr	r3, [r4, #0]
   11202:	681b      	ldr	r3, [r3, #0]
   11204:	490e      	ldr	r1, [pc, #56]	; (11240 <_Command_NetworkOnOff+0x15c>)
   11206:	4628      	mov	r0, r5
   11208:	4798      	blx	r3
    return true;
   1120a:	2001      	movs	r0, #1
   1120c:	e786      	b.n	1111c <_Command_NetworkOnOff+0x38>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Operation failed!\r\n");
   1120e:	6823      	ldr	r3, [r4, #0]
   11210:	681b      	ldr	r3, [r3, #0]
   11212:	490c      	ldr	r1, [pc, #48]	; (11244 <_Command_NetworkOnOff+0x160>)
   11214:	4628      	mov	r0, r5
   11216:	4798      	blx	r3
    return true;
   11218:	2001      	movs	r0, #1
   1121a:	e77f      	b.n	1111c <_Command_NetworkOnOff+0x38>
   1121c:	0000028c 	.word	0x0000028c
   11220:	00000cc0 	.word	0x00000cc0
   11224:	00000d24 	.word	0x00000d24
   11228:	00000e34 	.word	0x00000e34
   1122c:	00000da8 	.word	0x00000da8
   11230:	00000dc8 	.word	0x00000dc8
   11234:	00000e0c 	.word	0x00000e0c
   11238:	00000de4 	.word	0x00000de4
   1123c:	00000e14 	.word	0x00000e14
   11240:	00000e54 	.word	0x00000e54
   11244:	00000e6c 	.word	0x00000e6c

Disassembly of section .text.CommandHelp%260:

00011248 <CommandHelp>:
{
   11248:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1124c:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   1124e:	6845      	ldr	r5, [r0, #4]
    if(argc == 1)
   11250:	2901      	cmp	r1, #1
   11252:	d004      	beq.n	1125e <CommandHelp+0x16>
   11254:	4691      	mov	r9, r2
        pTbl = _usrCmdTbl;
   11256:	4e4f      	ldr	r6, [pc, #316]	; (11394 <CommandHelp+0x14c>)
        for (groupIx=0; groupIx < MAX_CMD_GROUP; groupIx++)
   11258:	f106 0780 	add.w	r7, r6, #128	; 0x80
   1125c:	e05c      	b.n	11318 <CommandHelp+0xd0>
        bool hadHeader = false;
   1125e:	2200      	movs	r2, #0
        pTbl = _usrCmdTbl;
   11260:	4e4c      	ldr	r6, [pc, #304]	; (11394 <CommandHelp+0x14c>)
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** ");
   11262:	4f4d      	ldr	r7, [pc, #308]	; (11398 <CommandHelp+0x150>)
   11264:	f107 0938 	add.w	r9, r7, #56	; 0x38
        for (groupIx=0; groupIx < MAX_CMD_GROUP; groupIx++)
   11268:	f106 0880 	add.w	r8, r6, #128	; 0x80
   1126c:	e018      	b.n	112a0 <CommandHelp+0x58>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** ");
   1126e:	6823      	ldr	r3, [r4, #0]
   11270:	681b      	ldr	r3, [r3, #0]
   11272:	4649      	mov	r1, r9
   11274:	4628      	mov	r0, r5
   11276:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, pTbl->cmdGroupName);
   11278:	6823      	ldr	r3, [r4, #0]
   1127a:	681b      	ldr	r3, [r3, #0]
   1127c:	68b1      	ldr	r1, [r6, #8]
   1127e:	4628      	mov	r0, r5
   11280:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, pTbl->cmdMenuStr);
   11282:	6823      	ldr	r3, [r4, #0]
   11284:	681b      	ldr	r3, [r3, #0]
   11286:	68f1      	ldr	r1, [r6, #12]
   11288:	4628      	mov	r0, r5
   1128a:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, " ***");
   1128c:	6823      	ldr	r3, [r4, #0]
   1128e:	681b      	ldr	r3, [r3, #0]
   11290:	f107 0140 	add.w	r1, r7, #64	; 0x40
   11294:	4628      	mov	r0, r5
   11296:	4798      	blx	r3
   11298:	2201      	movs	r2, #1
            pTbl++;
   1129a:	3610      	adds	r6, #16
        for (groupIx=0; groupIx < MAX_CMD_GROUP; groupIx++)
   1129c:	4546      	cmp	r6, r8
   1129e:	d00b      	beq.n	112b8 <CommandHelp+0x70>
            if (pTbl->pCmd)
   112a0:	6873      	ldr	r3, [r6, #4]
   112a2:	2b00      	cmp	r3, #0
   112a4:	d0f9      	beq.n	1129a <CommandHelp+0x52>
                if(!hadHeader)
   112a6:	2a00      	cmp	r2, #0
   112a8:	d1e1      	bne.n	1126e <CommandHelp+0x26>
                    (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM "------- Supported command groups ------");
   112aa:	6823      	ldr	r3, [r4, #0]
   112ac:	681b      	ldr	r3, [r3, #0]
   112ae:	f107 010c 	add.w	r1, r7, #12
   112b2:	4628      	mov	r0, r5
   112b4:	4798      	blx	r3
                    hadHeader = true;
   112b6:	e7da      	b.n	1126e <CommandHelp+0x26>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM "---------- Built in commands ----------");
   112b8:	6823      	ldr	r3, [r4, #0]
   112ba:	681b      	ldr	r3, [r3, #0]
   112bc:	4937      	ldr	r1, [pc, #220]	; (1139c <CommandHelp+0x154>)
   112be:	4628      	mov	r0, r5
   112c0:	4798      	blx	r3
        for(ix = 0, pDcpt = _builtinCmdTbl; ix < sizeof(_builtinCmdTbl)/sizeof(*_builtinCmdTbl); ix++, pDcpt++)
   112c2:	4b37      	ldr	r3, [pc, #220]	; (113a0 <CommandHelp+0x158>)
   112c4:	f103 060c 	add.w	r6, r3, #12
   112c8:	f103 0830 	add.w	r8, r3, #48	; 0x30
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** ");
   112cc:	4f32      	ldr	r7, [pc, #200]	; (11398 <CommandHelp+0x150>)
   112ce:	f107 0938 	add.w	r9, r7, #56	; 0x38
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, " ***");
   112d2:	3740      	adds	r7, #64	; 0x40
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** ");
   112d4:	6823      	ldr	r3, [r4, #0]
   112d6:	681b      	ldr	r3, [r3, #0]
   112d8:	4649      	mov	r1, r9
   112da:	4628      	mov	r0, r5
   112dc:	4798      	blx	r3
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, pDcpt->cmdStr);
   112de:	6823      	ldr	r3, [r4, #0]
   112e0:	681b      	ldr	r3, [r3, #0]
   112e2:	f856 1c0c 	ldr.w	r1, [r6, #-12]
   112e6:	4628      	mov	r0, r5
   112e8:	4798      	blx	r3
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, pDcpt->cmdDescr);
   112ea:	6823      	ldr	r3, [r4, #0]
   112ec:	681b      	ldr	r3, [r3, #0]
   112ee:	f856 1c04 	ldr.w	r1, [r6, #-4]
   112f2:	4628      	mov	r0, r5
   112f4:	4798      	blx	r3
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, " ***");
   112f6:	6823      	ldr	r3, [r4, #0]
   112f8:	681b      	ldr	r3, [r3, #0]
   112fa:	4639      	mov	r1, r7
   112fc:	4628      	mov	r0, r5
   112fe:	4798      	blx	r3
   11300:	360c      	adds	r6, #12
        for(ix = 0, pDcpt = _builtinCmdTbl; ix < sizeof(_builtinCmdTbl)/sizeof(*_builtinCmdTbl); ix++, pDcpt++)
   11302:	45b0      	cmp	r8, r6
   11304:	d1e6      	bne.n	112d4 <CommandHelp+0x8c>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM);
   11306:	6823      	ldr	r3, [r4, #0]
   11308:	681b      	ldr	r3, [r3, #0]
   1130a:	4926      	ldr	r1, [pc, #152]	; (113a4 <CommandHelp+0x15c>)
   1130c:	4628      	mov	r0, r5
   1130e:	4798      	blx	r3
   11310:	e038      	b.n	11384 <CommandHelp+0x13c>
            pTbl++;
   11312:	3610      	adds	r6, #16
        for (groupIx=0; groupIx < MAX_CMD_GROUP; groupIx++)
   11314:	42be      	cmp	r6, r7
   11316:	d037      	beq.n	11388 <CommandHelp+0x140>
            if (pTbl->pCmd)
   11318:	6873      	ldr	r3, [r6, #4]
   1131a:	2b00      	cmp	r3, #0
   1131c:	d0f9      	beq.n	11312 <CommandHelp+0xca>
                if(strcmp(pTbl->cmdGroupName, argv[1]) == 0)
   1131e:	f8d9 1004 	ldr.w	r1, [r9, #4]
   11322:	68b0      	ldr	r0, [r6, #8]
   11324:	f010 faea 	bl	218fc <strcmp>
   11328:	4680      	mov	r8, r0
   1132a:	2800      	cmp	r0, #0
   1132c:	d1f1      	bne.n	11312 <CommandHelp+0xca>
            for(ix = 0, pDcpt = pDTbl->pCmd; ix < pDTbl->nCmds; ix++, pDcpt++)
   1132e:	6877      	ldr	r7, [r6, #4]
   11330:	6833      	ldr	r3, [r6, #0]
   11332:	2b00      	cmp	r3, #0
   11334:	dd21      	ble.n	1137a <CommandHelp+0x132>
   11336:	370c      	adds	r7, #12
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** ");
   11338:	4b17      	ldr	r3, [pc, #92]	; (11398 <CommandHelp+0x150>)
   1133a:	f103 0a38 	add.w	sl, r3, #56	; 0x38
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, " ***");
   1133e:	f103 0940 	add.w	r9, r3, #64	; 0x40
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** ");
   11342:	6823      	ldr	r3, [r4, #0]
   11344:	681b      	ldr	r3, [r3, #0]
   11346:	4651      	mov	r1, sl
   11348:	4628      	mov	r0, r5
   1134a:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, pDcpt->cmdStr);
   1134c:	6823      	ldr	r3, [r4, #0]
   1134e:	681b      	ldr	r3, [r3, #0]
   11350:	f857 1c0c 	ldr.w	r1, [r7, #-12]
   11354:	4628      	mov	r0, r5
   11356:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, pDcpt->cmdDescr);
   11358:	6823      	ldr	r3, [r4, #0]
   1135a:	681b      	ldr	r3, [r3, #0]
   1135c:	f857 1c04 	ldr.w	r1, [r7, #-4]
   11360:	4628      	mov	r0, r5
   11362:	4798      	blx	r3
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, " ***");
   11364:	6823      	ldr	r3, [r4, #0]
   11366:	681b      	ldr	r3, [r3, #0]
   11368:	4649      	mov	r1, r9
   1136a:	4628      	mov	r0, r5
   1136c:	4798      	blx	r3
            for(ix = 0, pDcpt = pDTbl->pCmd; ix < pDTbl->nCmds; ix++, pDcpt++)
   1136e:	f108 0801 	add.w	r8, r8, #1
   11372:	370c      	adds	r7, #12
   11374:	6833      	ldr	r3, [r6, #0]
   11376:	4543      	cmp	r3, r8
   11378:	dce3      	bgt.n	11342 <CommandHelp+0xfa>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM);
   1137a:	6823      	ldr	r3, [r4, #0]
   1137c:	681b      	ldr	r3, [r3, #0]
   1137e:	4909      	ldr	r1, [pc, #36]	; (113a4 <CommandHelp+0x15c>)
   11380:	4628      	mov	r0, r5
   11382:	4798      	blx	r3
}
   11384:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM "Unknown command group. Try help" LINE_TERM );
   11388:	6823      	ldr	r3, [r4, #0]
   1138a:	681b      	ldr	r3, [r3, #0]
   1138c:	4906      	ldr	r1, [pc, #24]	; (113a8 <CommandHelp+0x160>)
   1138e:	4628      	mov	r0, r5
   11390:	4798      	blx	r3
   11392:	e7f7      	b.n	11384 <CommandHelp+0x13c>
   11394:	2000df98 	.word	0x2000df98
   11398:	0000d118 	.word	0x0000d118
   1139c:	0000d160 	.word	0x0000d160
   113a0:	0002041c 	.word	0x0002041c
   113a4:	0000d18c 	.word	0x0000d18c
   113a8:	0000d190 	.word	0x0000d190

Disassembly of section .text._UDPOpen%261:

000113ac <_UDPOpen>:
{
   113ac:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   113b0:	4699      	mov	r9, r3
    if(UDPSocketDcpt == 0)
   113b2:	4b50      	ldr	r3, [pc, #320]	; (114f4 <_UDPOpen+0x148>)
   113b4:	681b      	ldr	r3, [r3, #0]
   113b6:	2b00      	cmp	r3, #0
   113b8:	f000 808a 	beq.w	114d0 <_UDPOpen+0x124>
   113bc:	4606      	mov	r6, r0
   113be:	460d      	mov	r5, r1
   113c0:	4617      	mov	r7, r2
    if((opType & UDP_OPEN_CLIENT) != 0)
   113c2:	f011 0802 	ands.w	r8, r1, #2
   113c6:	f040 8088 	bne.w	114da <_UDPOpen+0x12e>
    OSAL_SEM_Pend(&userSem, OSAL_WAIT_FOREVER);
   113ca:	f64f 71ff 	movw	r1, #65535	; 0xffff
   113ce:	484a      	ldr	r0, [pc, #296]	; (114f8 <_UDPOpen+0x14c>)
   113d0:	f00f fc58 	bl	20c84 <OSAL_SEM_Pend>
        if(localPort == 0)
   113d4:	2f00      	cmp	r7, #0
   113d6:	f000 8085 	beq.w	114e4 <_UDPOpen+0x138>
        for ( sktIx = 0; sktIx < nUdpSockets; sktIx++ )
   113da:	4b48      	ldr	r3, [pc, #288]	; (114fc <_UDPOpen+0x150>)
   113dc:	6819      	ldr	r1, [r3, #0]
   113de:	2900      	cmp	r1, #0
   113e0:	dd59      	ble.n	11496 <_UDPOpen+0xea>
            pSkt = UDPSocketDcpt[sktIx];
   113e2:	4b44      	ldr	r3, [pc, #272]	; (114f4 <_UDPOpen+0x148>)
   113e4:	681b      	ldr	r3, [r3, #0]
   113e6:	681a      	ldr	r2, [r3, #0]
            if(pSkt == 0)
   113e8:	2a00      	cmp	r2, #0
   113ea:	d074      	beq.n	114d6 <_UDPOpen+0x12a>
        for ( sktIx = 0; sktIx < nUdpSockets; sktIx++ )
   113ec:	2400      	movs	r4, #0
   113ee:	3401      	adds	r4, #1
   113f0:	428c      	cmp	r4, r1
   113f2:	d04f      	beq.n	11494 <_UDPOpen+0xe8>
            pSkt = UDPSocketDcpt[sktIx];
   113f4:	f853 2f04 	ldr.w	r2, [r3, #4]!
            if(pSkt == 0)
   113f8:	2a00      	cmp	r2, #0
   113fa:	d1f8      	bne.n	113ee <_UDPOpen+0x42>
        pSkt = (UDP_SOCKET_DCPT*)TCPIP_HEAP_Calloc(udpMemH, 1, sizeof(*pSkt));
   113fc:	4b40      	ldr	r3, [pc, #256]	; (11500 <_UDPOpen+0x154>)
   113fe:	6818      	ldr	r0, [r3, #0]
   11400:	6883      	ldr	r3, [r0, #8]
   11402:	225c      	movs	r2, #92	; 0x5c
   11404:	2101      	movs	r1, #1
   11406:	4798      	blx	r3
    if(newSktValid)
   11408:	4682      	mov	sl, r0
   1140a:	2800      	cmp	r0, #0
   1140c:	d043      	beq.n	11496 <_UDPOpen+0xea>
        pSkt->sktIx = sktIx;
   1140e:	fa0f fb84 	sxth.w	fp, r4
   11412:	f8a0 b012 	strh.w	fp, [r0, #18]
        UDPSocketDcpt[sktIx] = pSkt;
   11416:	4b37      	ldr	r3, [pc, #220]	; (114f4 <_UDPOpen+0x148>)
   11418:	681b      	ldr	r3, [r3, #0]
   1141a:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
    OSAL_SEM_Post(&userSem);
   1141e:	4836      	ldr	r0, [pc, #216]	; (114f8 <_UDPOpen+0x14c>)
   11420:	f010 f848 	bl	214b4 <OSAL_SEM_Post>
    pSkt->localPort = localPort;	
   11424:	f8aa 702a 	strh.w	r7, [sl, #42]	; 0x2a
    pSkt->remotePort = remotePort;
   11428:	f8aa 8028 	strh.w	r8, [sl, #40]	; 0x28
    pSkt->addType = addType;
   1142c:	f8aa 603c 	strh.w	r6, [sl, #60]	; 0x3c
    pSkt->txAllocLimit = TCPIP_UDP_SOCKET_DEFAULT_TX_QUEUE_LIMIT; 
   11430:	2303      	movs	r3, #3
   11432:	f88a 303e 	strb.w	r3, [sl, #62]	; 0x3e
    pSkt->rxQueueLimit = TCPIP_UDP_SOCKET_DEFAULT_RX_QUEUE_LIMIT;
   11436:	f88a 305a 	strb.w	r3, [sl, #90]	; 0x5a
    pSkt->flags.openAddType = addType;
   1143a:	f89a 3041 	ldrb.w	r3, [sl, #65]	; 0x41
   1143e:	f366 1305 	bfi	r3, r6, #4, #2
   11442:	f88a 3041 	strb.w	r3, [sl, #65]	; 0x41
    if((opType & UDP_OPEN_TX_SPLIT) != 0)
   11446:	f015 0f80 	tst.w	r5, #128	; 0x80
   1144a:	d02c      	beq.n	114a6 <_UDPOpen+0xfa>
        pSkt->txSize = 0;
   1144c:	2300      	movs	r3, #0
   1144e:	f8aa 3010 	strh.w	r3, [sl, #16]
        pSkt->flags.txSplitAlloc = 1;
   11452:	f89a 3041 	ldrb.w	r3, [sl, #65]	; 0x41
   11456:	f043 0302 	orr.w	r3, r3, #2
   1145a:	f88a 3041 	strb.w	r3, [sl, #65]	; 0x41
    if((opType & UDP_OPEN_CONFIG_SERVICE) != 0)
   1145e:	f415 7f80 	tst.w	r5, #256	; 0x100
   11462:	d005      	beq.n	11470 <_UDPOpen+0xc4>
        pSkt->flags.stackConfig = 1;
   11464:	f89a 3041 	ldrb.w	r3, [sl, #65]	; 0x41
   11468:	f043 0308 	orr.w	r3, r3, #8
   1146c:	f88a 3041 	strb.w	r3, [sl, #65]	; 0x41
    if((opType & UDP_OPEN_SERVER) != 0)
   11470:	f015 0f01 	tst.w	r5, #1
   11474:	d01c      	beq.n	114b0 <_UDPOpen+0x104>
        pSkt->flags.looseRemPort = pSkt->flags.looseNetIf = pSkt->flags.looseRemAddress = 1; 
   11476:	f89a 3040 	ldrb.w	r3, [sl, #64]	; 0x40
   1147a:	f043 031c 	orr.w	r3, r3, #28
   1147e:	f88a 3040 	strb.w	r3, [sl, #64]	; 0x40
        pSkt->extFlags.serverSkt = 1;
   11482:	f89a 3042 	ldrb.w	r3, [sl, #66]	; 0x42
   11486:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   1148a:	f88a 3042 	strb.w	r3, [sl, #66]	; 0x42
}
   1148e:	4658      	mov	r0, fp
   11490:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(pSkt != 0)
   11494:	b12a      	cbz	r2, 114a2 <_UDPOpen+0xf6>
    OSAL_SEM_Post(&userSem);
   11496:	4818      	ldr	r0, [pc, #96]	; (114f8 <_UDPOpen+0x14c>)
   11498:	f010 f80c 	bl	214b4 <OSAL_SEM_Post>
        return (UDP_SOCKET)INVALID_UDP_SOCKET;
   1149c:	f04f 3bff 	mov.w	fp, #4294967295
   114a0:	e7f5      	b.n	1148e <_UDPOpen+0xe2>
        for ( sktIx = 0; sktIx < nUdpSockets; sktIx++ )
   114a2:	460c      	mov	r4, r1
   114a4:	e7aa      	b.n	113fc <_UDPOpen+0x50>
        pSkt->txSize = udpDefTxSize;
   114a6:	4b17      	ldr	r3, [pc, #92]	; (11504 <_UDPOpen+0x158>)
   114a8:	881b      	ldrh	r3, [r3, #0]
   114aa:	f8aa 3010 	strh.w	r3, [sl, #16]
   114ae:	e7d6      	b.n	1145e <_UDPOpen+0xb2>
        switch(addType)
   114b0:	2e01      	cmp	r6, #1
   114b2:	d1ec      	bne.n	1148e <_UDPOpen+0xe2>
                if(hostAddress)
   114b4:	f1b9 0f00 	cmp.w	r9, #0
   114b8:	d0e9      	beq.n	1148e <_UDPOpen+0xe2>
                    pSkt->destAddress.Val = hostAddress->v4Add.Val;
   114ba:	f8d9 3000 	ldr.w	r3, [r9]
   114be:	f8ca 3014 	str.w	r3, [sl, #20]
                    pSkt->flags.destSet = 1;
   114c2:	f89a 3041 	ldrb.w	r3, [sl, #65]	; 0x41
   114c6:	f043 0301 	orr.w	r3, r3, #1
   114ca:	f88a 3041 	strb.w	r3, [sl, #65]	; 0x41
    return (UDP_SOCKET)sktIx;
   114ce:	e7de      	b.n	1148e <_UDPOpen+0xe2>
        return (UDP_SOCKET)INVALID_UDP_SOCKET;
   114d0:	f04f 3bff 	mov.w	fp, #4294967295
   114d4:	e7db      	b.n	1148e <_UDPOpen+0xe2>
        for ( sktIx = 0; sktIx < nUdpSockets; sktIx++ )
   114d6:	2400      	movs	r4, #0
        if(pSkt != 0)
   114d8:	e790      	b.n	113fc <_UDPOpen+0x50>
    OSAL_SEM_Pend(&userSem, OSAL_WAIT_FOREVER);
   114da:	f64f 71ff 	movw	r1, #65535	; 0xffff
   114de:	4806      	ldr	r0, [pc, #24]	; (114f8 <_UDPOpen+0x14c>)
   114e0:	f00f fbd0 	bl	20c84 <OSAL_SEM_Pend>
            localPort = _UDPAllocateEphemeralPort();
   114e4:	f00d f856 	bl	1e594 <_UDPAllocateEphemeralPort>
            if(localPort == 0)
   114e8:	2800      	cmp	r0, #0
   114ea:	d0d4      	beq.n	11496 <_UDPOpen+0xea>
   114ec:	46b8      	mov	r8, r7
            localPort = _UDPAllocateEphemeralPort();
   114ee:	4607      	mov	r7, r0
   114f0:	e773      	b.n	113da <_UDPOpen+0x2e>
   114f2:	bf00      	nop
   114f4:	2000e65c 	.word	0x2000e65c
   114f8:	2000e670 	.word	0x2000e670
   114fc:	2000e660 	.word	0x2000e660
   11500:	2000e66c 	.word	0x2000e66c
   11504:	2000e724 	.word	0x2000e724

Disassembly of section .text.TCPIP_DNS_EntryQuery%262:

00011508 <TCPIP_DNS_EntryQuery>:
{
   11508:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    pDnsDcpt = pgDnsDcpt;
   1150a:	4b53      	ldr	r3, [pc, #332]	; (11658 <TCPIP_DNS_EntryQuery+0x150>)
   1150c:	681e      	ldr	r6, [r3, #0]
    if(pDnsDcpt == 0 || pDnsDcpt->hashDcpt == 0)
   1150e:	2e00      	cmp	r6, #0
   11510:	f000 808d 	beq.w	1162e <TCPIP_DNS_EntryQuery+0x126>
   11514:	4604      	mov	r4, r0
   11516:	6830      	ldr	r0, [r6, #0]
   11518:	2800      	cmp	r0, #0
   1151a:	f000 808b 	beq.w	11634 <TCPIP_DNS_EntryQuery+0x12c>
    if(pDnsQuery == 0 || pDnsQuery->hostName == 0 || pDnsQuery->nameLen == 0)
   1151e:	2c00      	cmp	r4, #0
   11520:	f000 808b 	beq.w	1163a <TCPIP_DNS_EntryQuery+0x132>
   11524:	6823      	ldr	r3, [r4, #0]
   11526:	2b00      	cmp	r3, #0
   11528:	f000 808a 	beq.w	11640 <TCPIP_DNS_EntryQuery+0x138>
   1152c:	6863      	ldr	r3, [r4, #4]
   1152e:	2b00      	cmp	r3, #0
   11530:	f000 8089 	beq.w	11646 <TCPIP_DNS_EntryQuery+0x13e>
    pBkt = TCPIP_OAHASH_EntryGet(pDnsDcpt->hashDcpt, queryIndex);
   11534:	f010 fa11 	bl	2195a <TCPIP_OAHASH_EntryGet>
    if(pBkt == 0)
   11538:	4605      	mov	r5, r0
   1153a:	2800      	cmp	r0, #0
   1153c:	f000 8086 	beq.w	1164c <TCPIP_DNS_EntryQuery+0x144>
    if(pBkt->flags.busy != 0)
   11540:	7803      	ldrb	r3, [r0, #0]
   11542:	f013 0f01 	tst.w	r3, #1
   11546:	f000 8084 	beq.w	11652 <TCPIP_DNS_EntryQuery+0x14a>
        strncpy(pDnsQuery->hostName, pE->pHostName, pDnsQuery->nameLen - 1);
   1154a:	6862      	ldr	r2, [r4, #4]
   1154c:	3a01      	subs	r2, #1
   1154e:	6a01      	ldr	r1, [r0, #32]
   11550:	6820      	ldr	r0, [r4, #0]
   11552:	f00e fe78 	bl	20246 <strncpy>
        pDnsQuery->hostName[pDnsQuery->nameLen - 1] = 0;
   11556:	6823      	ldr	r3, [r4, #0]
   11558:	6862      	ldr	r2, [r4, #4]
   1155a:	4413      	add	r3, r2
   1155c:	2200      	movs	r2, #0
   1155e:	f803 2c01 	strb.w	r2, [r3, #-1]
        pDnsQuery->hNet = pE->currNet;
   11562:	69eb      	ldr	r3, [r5, #28]
   11564:	6223      	str	r3, [r4, #32]
        pDnsQuery->serverIx = pE->currServerIx;
   11566:	f895 3029 	ldrb.w	r3, [r5, #41]	; 0x29
   1156a:	6263      	str	r3, [r4, #36]	; 0x24
        if((pBkt->flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) != 0)
   1156c:	882b      	ldrh	r3, [r5, #0]
   1156e:	f013 0f80 	tst.w	r3, #128	; 0x80
   11572:	d04f      	beq.n	11614 <TCPIP_DNS_EntryQuery+0x10c>
            pDnsQuery->status = TCPIP_DNS_RES_OK;
   11574:	7622      	strb	r2, [r4, #24]
            currTime = pDnsDcpt->dnsTime;
   11576:	69f2      	ldr	r2, [r6, #28]
            if(pDnsDcpt->cacheEntryTMO > 0)
   11578:	6973      	ldr	r3, [r6, #20]
   1157a:	2b00      	cmp	r3, #0
   1157c:	d03d      	beq.n	115fa <TCPIP_DNS_EntryQuery+0xf2>
                pDnsQuery->ttlTime = pDnsDcpt->cacheEntryTMO - (currTime - pE->tInsert);
   1157e:	1a9b      	subs	r3, r3, r2
   11580:	68aa      	ldr	r2, [r5, #8]
   11582:	4413      	add	r3, r2
   11584:	61e3      	str	r3, [r4, #28]
            for(ix = 0; ix < pE->nIPv4Entries && ix < pDnsQuery->nIPv4Entries; ix++)
   11586:	f895 3026 	ldrb.w	r3, [r5, #38]	; 0x26
   1158a:	2b00      	cmp	r3, #0
   1158c:	d03a      	beq.n	11604 <TCPIP_DNS_EntryQuery+0xfc>
   1158e:	68e3      	ldr	r3, [r4, #12]
   11590:	2b00      	cmp	r3, #0
   11592:	dd39      	ble.n	11608 <TCPIP_DNS_EntryQuery+0x100>
   11594:	2300      	movs	r3, #0
                pDnsQuery->ipv4Entry[ix].Val = pE->pip4Address[ix].Val;
   11596:	692a      	ldr	r2, [r5, #16]
   11598:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
   1159c:	68a2      	ldr	r2, [r4, #8]
   1159e:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            for(ix = 0; ix < pE->nIPv4Entries && ix < pDnsQuery->nIPv4Entries; ix++)
   115a2:	3301      	adds	r3, #1
   115a4:	f895 2026 	ldrb.w	r2, [r5, #38]	; 0x26
   115a8:	429a      	cmp	r2, r3
   115aa:	dd02      	ble.n	115b2 <TCPIP_DNS_EntryQuery+0xaa>
   115ac:	68e2      	ldr	r2, [r4, #12]
   115ae:	429a      	cmp	r2, r3
   115b0:	dcf1      	bgt.n	11596 <TCPIP_DNS_EntryQuery+0x8e>
            pDnsQuery->nIPv4ValidEntries = ix;
   115b2:	62a3      	str	r3, [r4, #40]	; 0x28
            for(ix = 0; ix < pE->nIPv6Entries && ix < pDnsQuery->nIPv6Entries; ix++)
   115b4:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
   115b8:	b343      	cbz	r3, 1160c <TCPIP_DNS_EntryQuery+0x104>
   115ba:	6963      	ldr	r3, [r4, #20]
   115bc:	2b00      	cmp	r3, #0
   115be:	dd27      	ble.n	11610 <TCPIP_DNS_EntryQuery+0x108>
   115c0:	2200      	movs	r2, #0
                memcpy(pDnsQuery->ipv6Entry[ix].v, pE->pip6Address[ix].v, sizeof(IPV6_ADDR));
   115c2:	0110      	lsls	r0, r2, #4
   115c4:	6926      	ldr	r6, [r4, #16]
   115c6:	1831      	adds	r1, r6, r0
   115c8:	696b      	ldr	r3, [r5, #20]
   115ca:	4403      	add	r3, r0
   115cc:	f8d3 e000 	ldr.w	lr, [r3]
   115d0:	f8d3 c004 	ldr.w	ip, [r3, #4]
   115d4:	689f      	ldr	r7, [r3, #8]
   115d6:	68db      	ldr	r3, [r3, #12]
   115d8:	f846 e000 	str.w	lr, [r6, r0]
   115dc:	f8c1 c004 	str.w	ip, [r1, #4]
   115e0:	608f      	str	r7, [r1, #8]
   115e2:	60cb      	str	r3, [r1, #12]
            for(ix = 0; ix < pE->nIPv6Entries && ix < pDnsQuery->nIPv6Entries; ix++)
   115e4:	3201      	adds	r2, #1
   115e6:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
   115ea:	4293      	cmp	r3, r2
   115ec:	dd02      	ble.n	115f4 <TCPIP_DNS_EntryQuery+0xec>
   115ee:	6963      	ldr	r3, [r4, #20]
   115f0:	4293      	cmp	r3, r2
   115f2:	dce6      	bgt.n	115c2 <TCPIP_DNS_EntryQuery+0xba>
            pDnsQuery->nIPv6ValidEntries = ix;
   115f4:	62e2      	str	r2, [r4, #44]	; 0x2c
            return TCPIP_DNS_RES_OK;
   115f6:	2000      	movs	r0, #0
   115f8:	e018      	b.n	1162c <TCPIP_DNS_EntryQuery+0x124>
                pDnsQuery->ttlTime = pE->ipTTL.Val - (currTime - pE->tInsert);
   115fa:	69ab      	ldr	r3, [r5, #24]
   115fc:	68a9      	ldr	r1, [r5, #8]
   115fe:	440b      	add	r3, r1
   11600:	1a9b      	subs	r3, r3, r2
   11602:	e7bf      	b.n	11584 <TCPIP_DNS_EntryQuery+0x7c>
            for(ix = 0; ix < pE->nIPv4Entries && ix < pDnsQuery->nIPv4Entries; ix++)
   11604:	2300      	movs	r3, #0
   11606:	e7d4      	b.n	115b2 <TCPIP_DNS_EntryQuery+0xaa>
   11608:	2300      	movs	r3, #0
   1160a:	e7d2      	b.n	115b2 <TCPIP_DNS_EntryQuery+0xaa>
            for(ix = 0; ix < pE->nIPv6Entries && ix < pDnsQuery->nIPv6Entries; ix++)
   1160c:	2200      	movs	r2, #0
   1160e:	e7f1      	b.n	115f4 <TCPIP_DNS_EntryQuery+0xec>
   11610:	2200      	movs	r2, #0
   11612:	e7ef      	b.n	115f4 <TCPIP_DNS_EntryQuery+0xec>
            pDnsQuery->status = (pE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_TIMEOUT) == 0 ? TCPIP_DNS_RES_PENDING : TCPIP_DNS_RES_SERVER_TMO; 
   11614:	f403 7380 	and.w	r3, r3, #256	; 0x100
   11618:	2b00      	cmp	r3, #0
   1161a:	bf0c      	ite	eq
   1161c:	2301      	moveq	r3, #1
   1161e:	f06f 0304 	mvnne.w	r3, #4
   11622:	7623      	strb	r3, [r4, #24]
            pDnsQuery->ttlTime = 0;
   11624:	2000      	movs	r0, #0
   11626:	61e0      	str	r0, [r4, #28]
            pDnsQuery->nIPv4ValidEntries = 0;
   11628:	62a0      	str	r0, [r4, #40]	; 0x28
            pDnsQuery->nIPv6ValidEntries = 0;
   1162a:	62e0      	str	r0, [r4, #44]	; 0x2c
}
   1162c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return TCPIP_DNS_RES_NO_SERVICE;
   1162e:	f06f 0005 	mvn.w	r0, #5
   11632:	e7fb      	b.n	1162c <TCPIP_DNS_EntryQuery+0x124>
   11634:	f06f 0005 	mvn.w	r0, #5
   11638:	e7f8      	b.n	1162c <TCPIP_DNS_EntryQuery+0x124>
        return TCPIP_DNS_RES_INVALID_HOSTNAME;
   1163a:	f06f 0008 	mvn.w	r0, #8
   1163e:	e7f5      	b.n	1162c <TCPIP_DNS_EntryQuery+0x124>
   11640:	f06f 0008 	mvn.w	r0, #8
   11644:	e7f2      	b.n	1162c <TCPIP_DNS_EntryQuery+0x124>
   11646:	f06f 0008 	mvn.w	r0, #8
   1164a:	e7ef      	b.n	1162c <TCPIP_DNS_EntryQuery+0x124>
        return TCPIP_DNS_RES_NO_IX_ENTRY;
   1164c:	f06f 0002 	mvn.w	r0, #2
   11650:	e7ec      	b.n	1162c <TCPIP_DNS_EntryQuery+0x124>
    return TCPIP_DNS_RES_EMPTY_IX_ENTRY;
   11652:	f06f 0003 	mvn.w	r0, #3
   11656:	e7e9      	b.n	1162c <TCPIP_DNS_EntryQuery+0x124>
   11658:	2000e62c 	.word	0x2000e62c

Disassembly of section .text.xQueueSemaphoreTake%263:

0001165c <xQueueSemaphoreTake>:
	} /*lint -restore */
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
   1165c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11660:	b084      	sub	sp, #16
   11662:	4604      	mov	r4, r0
   11664:	9101      	str	r1, [sp, #4]
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
   11666:	f04f 0800 	mov.w	r8, #0
BaseType_t xEntryTimeSet = pdFALSE;
   1166a:	4646      	mov	r6, r8

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
   1166c:	4645      	mov	r5, r8

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
				{
					portYIELD_WITHIN_API();
   1166e:	4f4f      	ldr	r7, [pc, #316]	; (117ac <xQueueSemaphoreTake+0x150>)
   11670:	e043      	b.n	116fa <xQueueSemaphoreTake+0x9e>
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
   11672:	3b01      	subs	r3, #1
   11674:	63a3      	str	r3, [r4, #56]	; 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   11676:	6823      	ldr	r3, [r4, #0]
   11678:	b14b      	cbz	r3, 1168e <xQueueSemaphoreTake+0x32>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1167a:	6923      	ldr	r3, [r4, #16]
   1167c:	b95b      	cbnz	r3, 11696 <xQueueSemaphoreTake+0x3a>
				taskEXIT_CRITICAL();
   1167e:	f010 f91f 	bl	218c0 <vPortExitCritical>
				return pdPASS;
   11682:	f04f 0801 	mov.w	r8, #1
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
   11686:	4640      	mov	r0, r8
   11688:	b004      	add	sp, #16
   1168a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
   1168e:	f00f fccb 	bl	21028 <pvTaskIncrementMutexHeldCount>
   11692:	60a0      	str	r0, [r4, #8]
   11694:	e7f1      	b.n	1167a <xQueueSemaphoreTake+0x1e>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   11696:	f104 0010 	add.w	r0, r4, #16
   1169a:	f008 fc0f 	bl	19ebc <xTaskRemoveFromEventList>
   1169e:	2800      	cmp	r0, #0
   116a0:	d0ed      	beq.n	1167e <xQueueSemaphoreTake+0x22>
						queueYIELD_IF_USING_PREEMPTION();
   116a2:	4b42      	ldr	r3, [pc, #264]	; (117ac <xQueueSemaphoreTake+0x150>)
   116a4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   116a8:	601a      	str	r2, [r3, #0]
   116aa:	f3bf 8f4f 	dsb	sy
   116ae:	f3bf 8f6f 	isb	sy
   116b2:	e7e4      	b.n	1167e <xQueueSemaphoreTake+0x22>
					taskEXIT_CRITICAL();
   116b4:	f010 f904 	bl	218c0 <vPortExitCritical>
					return errQUEUE_EMPTY;
   116b8:	f04f 0800 	mov.w	r8, #0
   116bc:	e7e3      	b.n	11686 <xQueueSemaphoreTake+0x2a>
					vTaskInternalSetTimeOutState( &xTimeOut );
   116be:	a802      	add	r0, sp, #8
   116c0:	f00f ffa0 	bl	21604 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   116c4:	e023      	b.n	1170e <xQueueSemaphoreTake+0xb2>
						taskENTER_CRITICAL();
   116c6:	f00f fa23 	bl	20b10 <vPortEnterCritical>
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
   116ca:	68a0      	ldr	r0, [r4, #8]
   116cc:	f005 fd9a 	bl	17204 <xTaskPriorityInherit>
   116d0:	4680      	mov	r8, r0
						taskEXIT_CRITICAL();
   116d2:	f010 f8f5 	bl	218c0 <vPortExitCritical>
   116d6:	e040      	b.n	1175a <xQueueSemaphoreTake+0xfe>
				prvUnlockQueue( pxQueue );
   116d8:	4620      	mov	r0, r4
   116da:	f007 fe83 	bl	193e4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
   116de:	f003 fb4f 	bl	14d80 <xTaskResumeAll>
   116e2:	e009      	b.n	116f8 <xQueueSemaphoreTake+0x9c>
			prvUnlockQueue( pxQueue );
   116e4:	4620      	mov	r0, r4
   116e6:	f007 fe7d 	bl	193e4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
   116ea:	f003 fb49 	bl	14d80 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   116ee:	4620      	mov	r0, r4
   116f0:	f010 f824 	bl	2173c <prvIsQueueEmpty>
   116f4:	2800      	cmp	r0, #0
   116f6:	d144      	bne.n	11782 <xQueueSemaphoreTake+0x126>
   116f8:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
   116fa:	f00f fa09 	bl	20b10 <vPortEnterCritical>
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
   116fe:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
   11700:	2b00      	cmp	r3, #0
   11702:	d1b6      	bne.n	11672 <xQueueSemaphoreTake+0x16>
				if( xTicksToWait == ( TickType_t ) 0 )
   11704:	9b01      	ldr	r3, [sp, #4]
   11706:	2b00      	cmp	r3, #0
   11708:	d0d4      	beq.n	116b4 <xQueueSemaphoreTake+0x58>
				else if( xEntryTimeSet == pdFALSE )
   1170a:	2e00      	cmp	r6, #0
   1170c:	d0d7      	beq.n	116be <xQueueSemaphoreTake+0x62>
		taskEXIT_CRITICAL();
   1170e:	f010 f8d7 	bl	218c0 <vPortExitCritical>
		vTaskSuspendAll();
   11712:	f010 fa03 	bl	21b1c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   11716:	f00f f9fb 	bl	20b10 <vPortEnterCritical>
   1171a:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
   1171e:	b25b      	sxtb	r3, r3
   11720:	f1b3 3fff 	cmp.w	r3, #4294967295
   11724:	bf08      	it	eq
   11726:	f884 5044 	strbeq.w	r5, [r4, #68]	; 0x44
   1172a:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
   1172e:	b25b      	sxtb	r3, r3
   11730:	f1b3 3fff 	cmp.w	r3, #4294967295
   11734:	bf08      	it	eq
   11736:	f884 5045 	strbeq.w	r5, [r4, #69]	; 0x45
   1173a:	f010 f8c1 	bl	218c0 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   1173e:	a901      	add	r1, sp, #4
   11740:	a802      	add	r0, sp, #8
   11742:	f00a f83f 	bl	1b7c4 <xTaskCheckForTimeOut>
   11746:	2800      	cmp	r0, #0
   11748:	d1cc      	bne.n	116e4 <xQueueSemaphoreTake+0x88>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   1174a:	4620      	mov	r0, r4
   1174c:	f00f fff6 	bl	2173c <prvIsQueueEmpty>
   11750:	2800      	cmp	r0, #0
   11752:	d0c1      	beq.n	116d8 <xQueueSemaphoreTake+0x7c>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   11754:	6823      	ldr	r3, [r4, #0]
   11756:	2b00      	cmp	r3, #0
   11758:	d0b5      	beq.n	116c6 <xQueueSemaphoreTake+0x6a>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   1175a:	9901      	ldr	r1, [sp, #4]
   1175c:	f104 0024 	add.w	r0, r4, #36	; 0x24
   11760:	f00f fc54 	bl	2100c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
   11764:	4620      	mov	r0, r4
   11766:	f007 fe3d 	bl	193e4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
   1176a:	f003 fb09 	bl	14d80 <xTaskResumeAll>
   1176e:	2800      	cmp	r0, #0
   11770:	d1c2      	bne.n	116f8 <xQueueSemaphoreTake+0x9c>
					portYIELD_WITHIN_API();
   11772:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   11776:	603b      	str	r3, [r7, #0]
   11778:	f3bf 8f4f 	dsb	sy
   1177c:	f3bf 8f6f 	isb	sy
   11780:	e7ba      	b.n	116f8 <xQueueSemaphoreTake+0x9c>
					if( xInheritanceOccurred != pdFALSE )
   11782:	f1b8 0f00 	cmp.w	r8, #0
   11786:	f43f af7e 	beq.w	11686 <xQueueSemaphoreTake+0x2a>
						taskENTER_CRITICAL();
   1178a:	f00f f9c1 	bl	20b10 <vPortEnterCritical>
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
   1178e:	6a61      	ldr	r1, [r4, #36]	; 0x24
   11790:	b119      	cbz	r1, 1179a <xQueueSemaphoreTake+0x13e>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
   11792:	6b23      	ldr	r3, [r4, #48]	; 0x30
   11794:	6819      	ldr	r1, [r3, #0]
   11796:	f1c1 0105 	rsb	r1, r1, #5
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
   1179a:	68a0      	ldr	r0, [r4, #8]
   1179c:	f007 fd22 	bl	191e4 <vTaskPriorityDisinheritAfterTimeout>
						taskEXIT_CRITICAL();
   117a0:	f010 f88e 	bl	218c0 <vPortExitCritical>
				return errQUEUE_EMPTY;
   117a4:	f04f 0800 	mov.w	r8, #0
   117a8:	e76d      	b.n	11686 <xQueueSemaphoreTake+0x2a>
   117aa:	bf00      	nop
   117ac:	e000ed04 	.word	0xe000ed04

Disassembly of section .text.DRV_MIIM_Tasks%264:

000117b0 <DRV_MIIM_Tasks>:
    _DRV_MIIM_ObjUnlock(pMiimObj);
    return res;
}

void DRV_MIIM_Tasks( SYS_MODULE_OBJ hSysObj )
{
   117b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    DRV_MIIM_OP_DCPT *pOpDcpt, *pHead;
    DRV_MIIM_REPORT_ACT repAct;
    DRV_MIIM_OBJ * pMiimObj = _DRV_MIIM_GetObjectAndLock(hSysObj);
   117b4:	f00d fe0d 	bl	1f3d2 <_DRV_MIIM_GetObjectAndLock>

    if(pMiimObj == 0)
   117b8:	2800      	cmp	r0, #0
   117ba:	f000 808d 	beq.w	118d8 <DRV_MIIM_Tasks+0x128>
   117be:	4605      	mov	r5, r0
            }
            break;

        default:
            _MIIMAssertCond(false, __func__, __LINE__);
            pOpDcpt->opStat = DRV_MIIM_TXFER_ERROR;
   117c0:	f04f 0808 	mov.w	r8, #8
       GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_MPE_Msk;
    }
    
    static  __inline__ bool __attribute__((always_inline))_DRV_MIIM_IS_BUSY(uintptr_t ethPhyId)
    {
       if ((GMAC_REGS->GMAC_NSR & GMAC_NSR_IDLE_Msk) != GMAC_NSR_IDLE_Msk)
   117c4:	4e4d      	ldr	r6, [pc, #308]	; (118fc <DRV_MIIM_Tasks+0x14c>)
            pOpDcpt->opStat = DRV_MIIM_TXFER_DONE;
   117c6:	2705      	movs	r7, #5
    while((pOpDcpt = (DRV_MIIM_OP_DCPT*)pMiimObj->busyOpList.head) != 0)
   117c8:	6fec      	ldr	r4, [r5, #124]	; 0x7c
   117ca:	2c00      	cmp	r4, #0
   117cc:	f000 8081 	beq.w	118d2 <DRV_MIIM_Tasks+0x122>
    switch(pOpDcpt->opStat)
   117d0:	7aa3      	ldrb	r3, [r4, #10]
   117d2:	3b01      	subs	r3, #1
   117d4:	2b03      	cmp	r3, #3
   117d6:	d871      	bhi.n	118bc <DRV_MIIM_Tasks+0x10c>
   117d8:	e8df f003 	tbb	[pc, r3]
   117dc:	2c2c6002 	.word	0x2c2c6002
        GMAC_REGS->GMAC_NCR |=	GMAC_NCR_MPE_Msk;
   117e0:	6833      	ldr	r3, [r6, #0]
   117e2:	f043 0310 	orr.w	r3, r3, #16
   117e6:	6033      	str	r3, [r6, #0]
       if ((GMAC_REGS->GMAC_NSR & GMAC_NSR_IDLE_Msk) != GMAC_NSR_IDLE_Msk)
   117e8:	68b3      	ldr	r3, [r6, #8]
   117ea:	f013 0f04 	tst.w	r3, #4
   117ee:	d021      	beq.n	11834 <DRV_MIIM_Tasks+0x84>
            if(pOpDcpt->opType == DRV_MIIM_OP_SCAN)
   117f0:	7923      	ldrb	r3, [r4, #4]
   117f2:	2b03      	cmp	r3, #3
   117f4:	d01d      	beq.n	11832 <DRV_MIIM_Tasks+0x82>
            else if(pOpDcpt->opType == DRV_MIIM_OP_WRITE)
   117f6:	2b02      	cmp	r3, #2
   117f8:	d004      	beq.n	11804 <DRV_MIIM_Tasks+0x54>
            else if(pOpDcpt->opType == DRV_MIIM_OP_READ)
   117fa:	2b01      	cmp	r3, #1
   117fc:	d03f      	beq.n	1187e <DRV_MIIM_Tasks+0xce>
                pOpDcpt->opStat = DRV_MIIM_TXFER_ERROR; 
   117fe:	f884 800a 	strb.w	r8, [r4, #10]
                break;
   11802:	e059      	b.n	118b8 <DRV_MIIM_Tasks+0x108>
    {
        GMAC_REGS->GMAC_MAN = 
                                (~GMAC_MAN_WZO_Msk & GMAC_MAN_CLTTO_Msk)
                                 | (GMAC_MAN_OP(0x1)) 
                                 | GMAC_MAN_WTN(0x02) 
                                 | GMAC_MAN_PHYA(pOpDcpt->phyAdd) 
   11804:	79a3      	ldrb	r3, [r4, #6]
   11806:	05db      	lsls	r3, r3, #23
   11808:	f003 6378 	and.w	r3, r3, #260046848	; 0xf800000
                                 | GMAC_MAN_REGA(pOpDcpt->regIx) 
   1180c:	7962      	ldrb	r2, [r4, #5]
   1180e:	0492      	lsls	r2, r2, #18
   11810:	f402 02f8 	and.w	r2, r2, #8126464	; 0x7c0000
   11814:	4313      	orrs	r3, r2
                                 | GMAC_MAN_DATA(pOpDcpt->opData);
   11816:	8922      	ldrh	r2, [r4, #8]
   11818:	4313      	orrs	r3, r2
   1181a:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
   1181e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
        GMAC_REGS->GMAC_MAN = 
   11822:	6373      	str	r3, [r6, #52]	; 0x34
                newStat = ((pOpDcpt->opFlags & DRV_MIIM_OPERATION_FLAG_DISCARD) == 0) ? DRV_MIIM_TXFER_RDWR_WAIT_COMPLETE : DRV_MIIM_TXFER_DONE;
   11824:	79e3      	ldrb	r3, [r4, #7]
   11826:	f003 0301 	and.w	r3, r3, #1
   1182a:	2b00      	cmp	r3, #0
   1182c:	bf0c      	ite	eq
   1182e:	2302      	moveq	r3, #2
   11830:	2305      	movne	r3, #5
            pOpDcpt->opStat = newStat;
   11832:	72a3      	strb	r3, [r4, #10]
        if(pOpDcpt->opStat >= DRV_MIIM_TXFER_REPORT_STATE)
   11834:	7aa3      	ldrb	r3, [r4, #10]
   11836:	2b03      	cmp	r3, #3
   11838:	d94b      	bls.n	118d2 <DRV_MIIM_Tasks+0x122>

    _MIIMAssertCond(pClient->parentObj == pMiimObj, __func__, __LINE__);

    while(true)
    {
        if((pOpDcpt->opFlags & DRV_MIIM_OPERATION_FLAG_DISCARD) == 0)
   1183a:	79e2      	ldrb	r2, [r4, #7]
   1183c:	f012 0f01 	tst.w	r2, #1
   11840:	d112      	bne.n	11868 <DRV_MIIM_Tasks+0xb8>
    DRV_MIIM_CLIENT_DCPT* pClient = pOpDcpt->pOwner;
   11842:	68e0      	ldr	r0, [r4, #12]
        {   // need to signal to client that we're done...
            if(pClient->cbackHandler != 0)
   11844:	6882      	ldr	r2, [r0, #8]
   11846:	2a00      	cmp	r2, #0
   11848:	d048      	beq.n	118dc <DRV_MIIM_Tasks+0x12c>
{
    if(DRV_MIIM_TXFER_START <= pOpDcpt->opStat &&  pOpDcpt->opStat < DRV_MIIM_TXFER_SCAN_VALID)
    {
        return DRV_MIIM_RES_PENDING;
    }
    else if(pOpDcpt->opStat <= DRV_MIIM_TXFER_DONE)
   1184a:	2b05      	cmp	r3, #5
   1184c:	d939      	bls.n	118c2 <DRV_MIIM_Tasks+0x112>
        {
            pOpDcpt->opStat = DRV_MIIM_TXFER_SCAN_STALE;
        }
        return DRV_MIIM_RES_OK;
    }
    else if(pOpDcpt->opStat == DRV_MIIM_TXFER_TMO_START || pOpDcpt->opStat == DRV_MIIM_TXFER_TMO_END)
   1184e:	3b06      	subs	r3, #6
   11850:	b2db      	uxtb	r3, r3
    {
        return DRV_MIIM_RES_OP_TIMEOUT_ERR;
   11852:	2b01      	cmp	r3, #1
   11854:	bf8c      	ite	hi
   11856:	f06f 0213 	mvnhi.w	r2, #19
   1185a:	f06f 0208 	mvnls.w	r2, #8
                (*pClient->cbackHandler)((DRV_HANDLE)pClient, pOpDcpt, opResult, pOpDcpt->opData);
   1185e:	f8d0 9008 	ldr.w	r9, [r0, #8]
   11862:	8923      	ldrh	r3, [r4, #8]
   11864:	4621      	mov	r1, r4
   11866:	47c8      	blx	r9
        if(pOpDcpt->opType == DRV_MIIM_OP_SCAN)
   11868:	7923      	ldrb	r3, [r4, #4]
   1186a:	2b03      	cmp	r3, #3
   1186c:	d031      	beq.n	118d2 <DRV_MIIM_Tasks+0x122>
                _DRV_MIIM_ReleaseOpDcpt(pMiimObj, pOpDcpt, &pMiimObj->busyOpList, DRV_MIIM_QTYPE_BUSY);
   1186e:	2302      	movs	r3, #2
   11870:	f105 027c 	add.w	r2, r5, #124	; 0x7c
   11874:	4621      	mov	r1, r4
   11876:	4628      	mov	r0, r5
   11878:	f00c fd1a 	bl	1e2b0 <_DRV_MIIM_ReleaseOpDcpt>
                continue;
   1187c:	e7a4      	b.n	117c8 <DRV_MIIM_Tasks+0x18>
    static  __inline__ void __attribute__((always_inline))_DRV_MIIM_OP_READ_START(uintptr_t ethPhyId, DRV_MIIM_OP_DCPT* pOpDcpt)
    {
        GMAC_REGS->GMAC_MAN =    (~GMAC_MAN_WZO_Msk & GMAC_MAN_CLTTO_Msk) 
                                    | (GMAC_MAN_OP(0x2)) 
                                    | GMAC_MAN_WTN(0x02) 
                                    | GMAC_MAN_PHYA(pOpDcpt->phyAdd) 
   1187e:	79a3      	ldrb	r3, [r4, #6]
   11880:	05db      	lsls	r3, r3, #23
   11882:	f003 6378 	and.w	r3, r3, #260046848	; 0xf800000
                                    | GMAC_MAN_REGA(pOpDcpt->regIx) 
   11886:	7962      	ldrb	r2, [r4, #5]
   11888:	0492      	lsls	r2, r2, #18
   1188a:	f402 02f8 	and.w	r2, r2, #8126464	; 0x7c0000
   1188e:	4313      	orrs	r3, r2
                                    | GMAC_MAN_DATA(0);
   11890:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
   11894:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
        GMAC_REGS->GMAC_MAN =    (~GMAC_MAN_WZO_Msk & GMAC_MAN_CLTTO_Msk) 
   11898:	6373      	str	r3, [r6, #52]	; 0x34
            if(checkDiscard)
   1189a:	e7c3      	b.n	11824 <DRV_MIIM_Tasks+0x74>
       if ((GMAC_REGS->GMAC_NSR & GMAC_NSR_IDLE_Msk) != GMAC_NSR_IDLE_Msk)
   1189c:	68b3      	ldr	r3, [r6, #8]
   1189e:	f013 0f04 	tst.w	r3, #4
   118a2:	d016      	beq.n	118d2 <DRV_MIIM_Tasks+0x122>
            if(pOpDcpt->opType == DRV_MIIM_OP_READ)
   118a4:	7923      	ldrb	r3, [r4, #4]
   118a6:	2b01      	cmp	r3, #1
    }
    
                                 
    static  __inline__ uint16_t __attribute__((always_inline))_DRV_MIIM_OP_READ_DATA_GET(uintptr_t ethPhyId)
    {
       return (uint16_t)(GMAC_REGS->GMAC_MAN & GMAC_MAN_DATA_Msk) ;
   118a8:	bf04      	itt	eq
   118aa:	6b73      	ldreq	r3, [r6, #52]	; 0x34
   118ac:	8123      	strheq	r3, [r4, #8]
       GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_MPE_Msk;
   118ae:	6833      	ldr	r3, [r6, #0]
   118b0:	f023 0310 	bic.w	r3, r3, #16
   118b4:	6033      	str	r3, [r6, #0]
            pOpDcpt->opStat = DRV_MIIM_TXFER_DONE;
   118b6:	72a7      	strb	r7, [r4, #10]
        if(pOpDcpt->opStat >= DRV_MIIM_TXFER_REPORT_STATE)
   118b8:	7aa3      	ldrb	r3, [r4, #10]
   118ba:	e7be      	b.n	1183a <DRV_MIIM_Tasks+0x8a>
            pOpDcpt->opStat = DRV_MIIM_TXFER_ERROR;
   118bc:	f884 800a 	strb.w	r8, [r4, #10]
            break;
   118c0:	e7fa      	b.n	118b8 <DRV_MIIM_Tasks+0x108>
        if(scanAck && pOpDcpt->opStat == DRV_MIIM_TXFER_SCAN_VALID)
   118c2:	2b04      	cmp	r3, #4
   118c4:	d001      	beq.n	118ca <DRV_MIIM_Tasks+0x11a>
        return DRV_MIIM_RES_OK;
   118c6:	2200      	movs	r2, #0
   118c8:	e7c9      	b.n	1185e <DRV_MIIM_Tasks+0xae>
            pOpDcpt->opStat = DRV_MIIM_TXFER_SCAN_STALE;
   118ca:	2303      	movs	r3, #3
   118cc:	72a3      	strb	r3, [r4, #10]
        return DRV_MIIM_RES_OK;
   118ce:	2200      	movs	r2, #0
   118d0:	e7c5      	b.n	1185e <DRV_MIIM_Tasks+0xae>
    OSAL_SEM_Post(&pMiimObj->objSem);
   118d2:	4628      	mov	r0, r5
   118d4:	f00f fdee 	bl	214b4 <OSAL_SEM_Post>
} 
   118d8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if(pOpDcpt->opType == DRV_MIIM_OP_SCAN)
   118dc:	7923      	ldrb	r3, [r4, #4]
   118de:	2b03      	cmp	r3, #3
   118e0:	d0f7      	beq.n	118d2 <DRV_MIIM_Tasks+0x122>
    DRV_MIIM_OP_DCPT* pOpDcpt = (DRV_MIIM_OP_DCPT*)Helper_SingleListHeadRemove(pL);
   118e2:	f105 007c 	add.w	r0, r5, #124	; 0x7c
   118e6:	f00f fa41 	bl	20d6c <Helper_SingleListHeadRemove>
   118ea:	4604      	mov	r4, r0
    Helper_SingleListTailAdd(pL, (SGL_LIST_NODE*)pOpDcpt);
   118ec:	4601      	mov	r1, r0
   118ee:	f105 0088 	add.w	r0, r5, #136	; 0x88
   118f2:	f00f fbfa 	bl	210ea <Helper_SingleListTailAdd>
    pOpDcpt->qType = qType;
   118f6:	2303      	movs	r3, #3
   118f8:	72e3      	strb	r3, [r4, #11]
                continue;
   118fa:	e765      	b.n	117c8 <DRV_MIIM_Tasks+0x18>
   118fc:	42000800 	.word	0x42000800

Disassembly of section .text.TCPIP_TCP_Initialize%265:

00011900 <TCPIP_TCP_Initialize>:
{
   11900:	b538      	push	{r3, r4, r5, lr}
   11902:	4605      	mov	r5, r0
   11904:	460c      	mov	r4, r1
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);  // System Lock
   11906:	2000      	movs	r0, #0
   11908:	f00f fdc8 	bl	2149c <OSAL_CRIT_Enter>
    if(tcpLockCount == 0)
   1190c:	4b44      	ldr	r3, [pc, #272]	; (11a20 <TCPIP_TCP_Initialize+0x120>)
   1190e:	681b      	ldr	r3, [r3, #0]
   11910:	2b00      	cmp	r3, #0
   11912:	d142      	bne.n	1199a <TCPIP_TCP_Initialize+0x9a>
        if(tcpInitCount != 0 || stackInit->stackAction != TCPIP_STACK_ACTION_INIT)
   11914:	4b43      	ldr	r3, [pc, #268]	; (11a24 <TCPIP_TCP_Initialize+0x124>)
   11916:	681b      	ldr	r3, [r3, #0]
   11918:	2b00      	cmp	r3, #0
   1191a:	d177      	bne.n	11a0c <TCPIP_TCP_Initialize+0x10c>
   1191c:	7f2b      	ldrb	r3, [r5, #28]
   1191e:	2b00      	cmp	r3, #0
   11920:	d174      	bne.n	11a0c <TCPIP_TCP_Initialize+0x10c>
            tcpLockCount = 2;     // get a lock
   11922:	4b3f      	ldr	r3, [pc, #252]	; (11a20 <TCPIP_TCP_Initialize+0x120>)
   11924:	2202      	movs	r2, #2
   11926:	601a      	str	r2, [r3, #0]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);  // System unlock
   11928:	4601      	mov	r1, r0
   1192a:	2000      	movs	r0, #0
   1192c:	f00f fee5 	bl	216fa <OSAL_CRIT_Leave>
    if(stackInit->memH == 0 || pTcpInit == 0 || pTcpInit->nSockets == 0)
   11930:	68e8      	ldr	r0, [r5, #12]
   11932:	2800      	cmp	r0, #0
   11934:	d044      	beq.n	119c0 <TCPIP_TCP_Initialize+0xc0>
   11936:	2c00      	cmp	r4, #0
   11938:	d042      	beq.n	119c0 <TCPIP_TCP_Initialize+0xc0>
   1193a:	6825      	ldr	r5, [r4, #0]
   1193c:	2d00      	cmp	r5, #0
   1193e:	d03f      	beq.n	119c0 <TCPIP_TCP_Initialize+0xc0>
    tcpHeapH = stackInit->memH;
   11940:	4b39      	ldr	r3, [pc, #228]	; (11a28 <TCPIP_TCP_Initialize+0x128>)
   11942:	6018      	str	r0, [r3, #0]
    tcpDefTxSize = pTcpInit->sktTxBuffSize;
   11944:	88a2      	ldrh	r2, [r4, #4]
   11946:	4b39      	ldr	r3, [pc, #228]	; (11a2c <TCPIP_TCP_Initialize+0x12c>)
   11948:	801a      	strh	r2, [r3, #0]
    tcpDefRxSize = pTcpInit->sktRxBuffSize;
   1194a:	88e2      	ldrh	r2, [r4, #6]
   1194c:	4b38      	ldr	r3, [pc, #224]	; (11a30 <TCPIP_TCP_Initialize+0x130>)
   1194e:	801a      	strh	r2, [r3, #0]
   11950:	6883      	ldr	r3, [r0, #8]
   11952:	2204      	movs	r2, #4
   11954:	4629      	mov	r1, r5
   11956:	4798      	blx	r3
    TCBStubs = (TCB_STUB**)TCPIP_HEAP_Calloc(tcpHeapH, nSockets, sizeof(*TCBStubs));
   11958:	4b36      	ldr	r3, [pc, #216]	; (11a34 <TCPIP_TCP_Initialize+0x134>)
   1195a:	6018      	str	r0, [r3, #0]
    if(TCBStubs == 0)
   1195c:	2800      	cmp	r0, #0
   1195e:	d03c      	beq.n	119da <TCPIP_TCP_Initialize+0xda>
    TcpSockets = nSockets;
   11960:	4b35      	ldr	r3, [pc, #212]	; (11a38 <TCPIP_TCP_Initialize+0x138>)
   11962:	601d      	str	r5, [r3, #0]
    tcpSignalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_TCP_Task, TCPIP_TCP_TASK_TICK_RATE);
   11964:	2205      	movs	r2, #5
   11966:	4935      	ldr	r1, [pc, #212]	; (11a3c <TCPIP_TCP_Initialize+0x13c>)
   11968:	200a      	movs	r0, #10
   1196a:	f00b f991 	bl	1cc90 <_TCPIPStackSignalHandlerRegister>
   1196e:	4b34      	ldr	r3, [pc, #208]	; (11a40 <TCPIP_TCP_Initialize+0x140>)
   11970:	6018      	str	r0, [r3, #0]
    if(tcpSignalHandle == 0)
   11972:	2800      	cmp	r0, #0
   11974:	d03e      	beq.n	119f4 <TCPIP_TCP_Initialize+0xf4>
    tcpInitCount++;
   11976:	4a2b      	ldr	r2, [pc, #172]	; (11a24 <TCPIP_TCP_Initialize+0x124>)
   11978:	6813      	ldr	r3, [r2, #0]
   1197a:	3301      	adds	r3, #1
   1197c:	6013      	str	r3, [r2, #0]
    tcpSemaphoreEnabled = OSAL_SEM_Create(&tcpSemaphore, OSAL_SEM_TYPE_BINARY, 1, 1) == OSAL_RESULT_TRUE;
   1197e:	2301      	movs	r3, #1
   11980:	461a      	mov	r2, r3
   11982:	2100      	movs	r1, #0
   11984:	482f      	ldr	r0, [pc, #188]	; (11a44 <TCPIP_TCP_Initialize+0x144>)
   11986:	f00a f8dd 	bl	1bb44 <OSAL_SEM_Create>
    if(!tcpSemaphoreEnabled)
   1198a:	2801      	cmp	r0, #1
   1198c:	d138      	bne.n	11a00 <TCPIP_TCP_Initialize+0x100>
    tcpInitCount = 1; // initialized
   1198e:	2401      	movs	r4, #1
   11990:	4b24      	ldr	r3, [pc, #144]	; (11a24 <TCPIP_TCP_Initialize+0x124>)
   11992:	601c      	str	r4, [r3, #0]
    tcpLockCount = 1; // release the lock
   11994:	4b22      	ldr	r3, [pc, #136]	; (11a20 <TCPIP_TCP_Initialize+0x120>)
   11996:	601c      	str	r4, [r3, #0]
    return true;
   11998:	e03d      	b.n	11a16 <TCPIP_TCP_Initialize+0x116>
    else if(tcpLockCount == 1)
   1199a:	2b01      	cmp	r3, #1
   1199c:	d005      	beq.n	119aa <TCPIP_TCP_Initialize+0xaa>
    bool    initRes = false;
   1199e:	2400      	movs	r4, #0
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);  // System unlock
   119a0:	4601      	mov	r1, r0
   119a2:	2000      	movs	r0, #0
   119a4:	f00f fea9 	bl	216fa <OSAL_CRIT_Leave>
    if(initFault)
   119a8:	e035      	b.n	11a16 <TCPIP_TCP_Initialize+0x116>
        if(tcpInitCount <= 0)
   119aa:	4b1e      	ldr	r3, [pc, #120]	; (11a24 <TCPIP_TCP_Initialize+0x124>)
   119ac:	681b      	ldr	r3, [r3, #0]
   119ae:	2b00      	cmp	r3, #0
   119b0:	dd2c      	ble.n	11a0c <TCPIP_TCP_Initialize+0x10c>
            if(stackInit->stackAction == TCPIP_STACK_ACTION_INIT)
   119b2:	7f2a      	ldrb	r2, [r5, #28]
   119b4:	bb8a      	cbnz	r2, 11a1a <TCPIP_TCP_Initialize+0x11a>
                tcpInitCount++;
   119b6:	3301      	adds	r3, #1
   119b8:	4a1a      	ldr	r2, [pc, #104]	; (11a24 <TCPIP_TCP_Initialize+0x124>)
   119ba:	6013      	str	r3, [r2, #0]
            initRes = true;
   119bc:	2401      	movs	r4, #1
   119be:	e7ef      	b.n	119a0 <TCPIP_TCP_Initialize+0xa0>
        SYS_ERROR(SYS_ERROR_ERROR, "TCP NULL dynamic allocation handle/init data");
   119c0:	f010 fac4 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
   119c4:	b918      	cbnz	r0, 119ce <TCPIP_TCP_Initialize+0xce>
        tcpLockCount = 0; // leave it uninitialized
   119c6:	2400      	movs	r4, #0
   119c8:	4b15      	ldr	r3, [pc, #84]	; (11a20 <TCPIP_TCP_Initialize+0x120>)
   119ca:	601c      	str	r4, [r3, #0]
        return false;
   119cc:	e023      	b.n	11a16 <TCPIP_TCP_Initialize+0x116>
        SYS_ERROR(SYS_ERROR_ERROR, "TCP NULL dynamic allocation handle/init data");
   119ce:	f010 fab7 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
   119d2:	491d      	ldr	r1, [pc, #116]	; (11a48 <TCPIP_TCP_Initialize+0x148>)
   119d4:	f008 feca 	bl	1a76c <SYS_CONSOLE_Print>
   119d8:	e7f5      	b.n	119c6 <TCPIP_TCP_Initialize+0xc6>
        SYS_ERROR(SYS_ERROR_ERROR, " TCP Dynamic allocation failed");
   119da:	f010 fab7 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
   119de:	b918      	cbnz	r0, 119e8 <TCPIP_TCP_Initialize+0xe8>
        tcpLockCount = 0; // leave it uninitialized
   119e0:	2400      	movs	r4, #0
   119e2:	4b0f      	ldr	r3, [pc, #60]	; (11a20 <TCPIP_TCP_Initialize+0x120>)
   119e4:	601c      	str	r4, [r3, #0]
        return false;
   119e6:	e016      	b.n	11a16 <TCPIP_TCP_Initialize+0x116>
        SYS_ERROR(SYS_ERROR_ERROR, " TCP Dynamic allocation failed");
   119e8:	f010 faaa 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
   119ec:	4917      	ldr	r1, [pc, #92]	; (11a4c <TCPIP_TCP_Initialize+0x14c>)
   119ee:	f008 febd 	bl	1a76c <SYS_CONSOLE_Print>
   119f2:	e7f5      	b.n	119e0 <TCPIP_TCP_Initialize+0xe0>
        _TcpCleanup();
   119f4:	f008 fdac 	bl	1a550 <_TcpCleanup>
        tcpLockCount = 0; // leave it uninitialized
   119f8:	2400      	movs	r4, #0
   119fa:	4b09      	ldr	r3, [pc, #36]	; (11a20 <TCPIP_TCP_Initialize+0x120>)
   119fc:	601c      	str	r4, [r3, #0]
        return false;
   119fe:	e00a      	b.n	11a16 <TCPIP_TCP_Initialize+0x116>
        _TcpCleanup();
   11a00:	f008 fda6 	bl	1a550 <_TcpCleanup>
        tcpLockCount = 0; // leave it uninitialized
   11a04:	2400      	movs	r4, #0
   11a06:	4b06      	ldr	r3, [pc, #24]	; (11a20 <TCPIP_TCP_Initialize+0x120>)
   11a08:	601c      	str	r4, [r3, #0]
        return false;
   11a0a:	e004      	b.n	11a16 <TCPIP_TCP_Initialize+0x116>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);  // System unlock
   11a0c:	4601      	mov	r1, r0
   11a0e:	2000      	movs	r0, #0
   11a10:	f00f fe73 	bl	216fa <OSAL_CRIT_Leave>
        return false;
   11a14:	2400      	movs	r4, #0
}
   11a16:	4620      	mov	r0, r4
   11a18:	bd38      	pop	{r3, r4, r5, pc}
            initRes = true;
   11a1a:	2401      	movs	r4, #1
   11a1c:	e7c0      	b.n	119a0 <TCPIP_TCP_Initialize+0xa0>
   11a1e:	bf00      	nop
   11a20:	2000e5a4 	.word	0x2000e5a4
   11a24:	2000e5a0 	.word	0x2000e5a0
   11a28:	2000e59c 	.word	0x2000e59c
   11a2c:	2000e712 	.word	0x2000e712
   11a30:	2000e516 	.word	0x2000e516
   11a34:	2000e594 	.word	0x2000e594
   11a38:	2000e598 	.word	0x2000e598
   11a3c:	00001981 	.word	0x00001981
   11a40:	2000e5ac 	.word	0x2000e5ac
   11a44:	2000e5a8 	.word	0x2000e5a8
   11a48:	0001c27c 	.word	0x0001c27c
   11a4c:	0001c2ac 	.word	0x0001c2ac

Disassembly of section .text.wc_Sha256Update%266:

00011a50 <wc_Sha256Update>:
    {
   11a50:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        if (sha256 == NULL || (data == NULL && len > 0)) {
   11a54:	2800      	cmp	r0, #0
   11a56:	f000 8097 	beq.w	11b88 <wc_Sha256Update+0x138>
   11a5a:	460d      	mov	r5, r1
   11a5c:	4616      	mov	r6, r2
   11a5e:	4604      	mov	r4, r0
   11a60:	b1f9      	cbz	r1, 11aa2 <wc_Sha256Update+0x52>
        if (sha256->devId != INVALID_DEVID) {
   11a62:	6f03      	ldr	r3, [r0, #112]	; 0x70
   11a64:	f113 0f02 	cmn.w	r3, #2
   11a68:	d007      	beq.n	11a7a <wc_Sha256Update+0x2a>
            int ret = wc_CryptoCb_Sha256Hash(sha256, data, len, NULL);
   11a6a:	2300      	movs	r3, #0
   11a6c:	f008 ff20 	bl	1a8b0 <wc_CryptoCb_Sha256Hash>
   11a70:	4603      	mov	r3, r0
            if (ret != CRYPTOCB_UNAVAILABLE)
   11a72:	f46f 7287 	mvn.w	r2, #270	; 0x10e
   11a76:	4290      	cmp	r0, r2
   11a78:	d118      	bne.n	11aac <wc_Sha256Update+0x5c>
        if (sha256->buffLen >= WC_SHA256_BLOCK_SIZE) {
   11a7a:	6e20      	ldr	r0, [r4, #96]	; 0x60
   11a7c:	283f      	cmp	r0, #63	; 0x3f
   11a7e:	f200 8086 	bhi.w	11b8e <wc_Sha256Update+0x13e>
        word32 tmp = sha256->loLen;
   11a82:	6e62      	ldr	r2, [r4, #100]	; 0x64
        if ((sha256->loLen += len) < tmp) {
   11a84:	18b3      	adds	r3, r6, r2
   11a86:	6663      	str	r3, [r4, #100]	; 0x64
   11a88:	429a      	cmp	r2, r3
   11a8a:	d902      	bls.n	11a92 <wc_Sha256Update+0x42>
            sha256->hiLen++;                       /* carry low to high */
   11a8c:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   11a8e:	3301      	adds	r3, #1
   11a90:	66a3      	str	r3, [r4, #104]	; 0x68
        local = (byte*)sha256->buffer;
   11a92:	f104 0720 	add.w	r7, r4, #32
        if (sha256->buffLen > 0) {
   11a96:	b960      	cbnz	r0, 11ab2 <wc_Sha256Update+0x62>
            while (len >= WC_SHA256_BLOCK_SIZE) {
   11a98:	2e3f      	cmp	r6, #63	; 0x3f
   11a9a:	d96a      	bls.n	11b72 <wc_Sha256Update+0x122>
   11a9c:	f104 085c 	add.w	r8, r4, #92	; 0x5c
   11aa0:	e03e      	b.n	11b20 <wc_Sha256Update+0xd0>
            return 0;
   11aa2:	2a00      	cmp	r2, #0
   11aa4:	bf14      	ite	ne
   11aa6:	f06f 03ac 	mvnne.w	r3, #172	; 0xac
   11aaa:	2300      	moveq	r3, #0
    }
   11aac:	4618      	mov	r0, r3
   11aae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            blocksLen = min(len, WC_SHA256_BLOCK_SIZE - sha256->buffLen);
   11ab2:	f1c0 0840 	rsb	r8, r0, #64	; 0x40
        #define min min
    #endif
    /* returns the smaller of a and b */
    WC_STATIC WC_INLINE word32 min(word32 a, word32 b)
    {
        return a > b ? b : a;
   11ab6:	45b0      	cmp	r8, r6
   11ab8:	bf28      	it	cs
   11aba:	46b0      	movcs	r8, r6
            XMEMCPY(&local[sha256->buffLen], data, blocksLen);
   11abc:	4642      	mov	r2, r8
   11abe:	4629      	mov	r1, r5
   11ac0:	4438      	add	r0, r7
   11ac2:	f00f facd 	bl	21060 <memcpy>
            sha256->buffLen += blocksLen;
   11ac6:	6e23      	ldr	r3, [r4, #96]	; 0x60
   11ac8:	4443      	add	r3, r8
   11aca:	6623      	str	r3, [r4, #96]	; 0x60
            data            += blocksLen;
   11acc:	4445      	add	r5, r8
            len             -= blocksLen;
   11ace:	eba6 0608 	sub.w	r6, r6, r8
            if (sha256->buffLen == WC_SHA256_BLOCK_SIZE) {
   11ad2:	2b40      	cmp	r3, #64	; 0x40
   11ad4:	d1e0      	bne.n	11a98 <wc_Sha256Update+0x48>
   11ad6:	f104 011c 	add.w	r1, r4, #28
   11ada:	f104 005c 	add.w	r0, r4, #92	; 0x5c
        out[i] = ByteReverseWord32(in[i]);
   11ade:	f851 2f04 	ldr.w	r2, [r1, #4]!
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
   11ae2:	0a13      	lsrs	r3, r2, #8
   11ae4:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
   11ae8:	0212      	lsls	r2, r2, #8
   11aea:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
   11aee:	4313      	orrs	r3, r2
        return (x << y) | (x >> (sizeof(y) * 8 - y));
   11af0:	ea4f 4333 	mov.w	r3, r3, ror #16
        out[i] = ByteReverseWord32(in[i]);
   11af4:	600b      	str	r3, [r1, #0]
    for (i = 0; i < count; i++)
   11af6:	4281      	cmp	r1, r0
   11af8:	d1f1      	bne.n	11ade <wc_Sha256Update+0x8e>
                ret = XTRANSFORM(sha256, (const byte*)local);
   11afa:	4639      	mov	r1, r7
   11afc:	4620      	mov	r0, r4
   11afe:	f7f9 fbed 	bl	b2dc <Transform_Sha256>
                if (ret == 0)
   11b02:	4603      	mov	r3, r0
   11b04:	2800      	cmp	r0, #0
   11b06:	d1d1      	bne.n	11aac <wc_Sha256Update+0x5c>
                    sha256->buffLen = 0;
   11b08:	2300      	movs	r3, #0
   11b0a:	6623      	str	r3, [r4, #96]	; 0x60
   11b0c:	e7c4      	b.n	11a98 <wc_Sha256Update+0x48>
                ret = XTRANSFORM(sha256, (const byte*)local32);
   11b0e:	4639      	mov	r1, r7
   11b10:	4620      	mov	r0, r4
   11b12:	f7f9 fbe3 	bl	b2dc <Transform_Sha256>
                if (ret != 0)
   11b16:	4603      	mov	r3, r0
   11b18:	2800      	cmp	r0, #0
   11b1a:	d1c7      	bne.n	11aac <wc_Sha256Update+0x5c>
            while (len >= WC_SHA256_BLOCK_SIZE) {
   11b1c:	2e3f      	cmp	r6, #63	; 0x3f
   11b1e:	d928      	bls.n	11b72 <wc_Sha256Update+0x122>
                    XMEMCPY(local32, data, WC_SHA256_BLOCK_SIZE);
   11b20:	462b      	mov	r3, r5
   11b22:	463a      	mov	r2, r7
   11b24:	f105 0140 	add.w	r1, r5, #64	; 0x40
   11b28:	f8d3 9000 	ldr.w	r9, [r3]
   11b2c:	f8d3 e004 	ldr.w	lr, [r3, #4]
   11b30:	f8d3 c008 	ldr.w	ip, [r3, #8]
   11b34:	68d8      	ldr	r0, [r3, #12]
   11b36:	f8c2 9000 	str.w	r9, [r2]
   11b3a:	f8c2 e004 	str.w	lr, [r2, #4]
   11b3e:	f8c2 c008 	str.w	ip, [r2, #8]
   11b42:	60d0      	str	r0, [r2, #12]
   11b44:	3310      	adds	r3, #16
   11b46:	3210      	adds	r2, #16
   11b48:	428b      	cmp	r3, r1
   11b4a:	d1ed      	bne.n	11b28 <wc_Sha256Update+0xd8>
                data += WC_SHA256_BLOCK_SIZE;
   11b4c:	3540      	adds	r5, #64	; 0x40
                len  -= WC_SHA256_BLOCK_SIZE;
   11b4e:	3e40      	subs	r6, #64	; 0x40
   11b50:	f104 011c 	add.w	r1, r4, #28
        out[i] = ByteReverseWord32(in[i]);
   11b54:	f851 2f04 	ldr.w	r2, [r1, #4]!
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
   11b58:	0a13      	lsrs	r3, r2, #8
   11b5a:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
   11b5e:	0212      	lsls	r2, r2, #8
   11b60:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
   11b64:	4313      	orrs	r3, r2
        return (x << y) | (x >> (sizeof(y) * 8 - y));
   11b66:	ea4f 4333 	mov.w	r3, r3, ror #16
        out[i] = ByteReverseWord32(in[i]);
   11b6a:	600b      	str	r3, [r1, #0]
    for (i = 0; i < count; i++)
   11b6c:	4588      	cmp	r8, r1
   11b6e:	d1f1      	bne.n	11b54 <wc_Sha256Update+0x104>
   11b70:	e7cd      	b.n	11b0e <wc_Sha256Update+0xbe>
        if (ret == 0 && len > 0) {
   11b72:	b90e      	cbnz	r6, 11b78 <wc_Sha256Update+0x128>
        return ret;
   11b74:	2300      	movs	r3, #0
   11b76:	e799      	b.n	11aac <wc_Sha256Update+0x5c>
            XMEMCPY(local, data, len);
   11b78:	4632      	mov	r2, r6
   11b7a:	4629      	mov	r1, r5
   11b7c:	4638      	mov	r0, r7
   11b7e:	f00f fa6f 	bl	21060 <memcpy>
            sha256->buffLen = len;
   11b82:	6626      	str	r6, [r4, #96]	; 0x60
        return ret;
   11b84:	2300      	movs	r3, #0
   11b86:	e791      	b.n	11aac <wc_Sha256Update+0x5c>
            return BAD_FUNC_ARG;
   11b88:	f06f 03ac 	mvn.w	r3, #172	; 0xac
   11b8c:	e78e      	b.n	11aac <wc_Sha256Update+0x5c>
            return BUFFER_E;
   11b8e:	f06f 0383 	mvn.w	r3, #131	; 0x83
   11b92:	e78b      	b.n	11aac <wc_Sha256Update+0x5c>

Disassembly of section .text.Hash_df%267:

00011b94 <Hash_df>:
{
   11b94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11b98:	b0ad      	sub	sp, #180	; 0xb4
   11b9a:	4690      	mov	r8, r2
   11b9c:	f8dd a0e0 	ldr.w	sl, [sp, #224]	; 0xe0
   11ba0:	f88d 3007 	strb.w	r3, [sp, #7]
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
   11ba4:	f3c2 1357 	ubfx	r3, r2, #5, #24
   11ba8:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
   11bac:	02d2      	lsls	r2, r2, #11
   11bae:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
   11bb2:	4313      	orrs	r3, r2
        return (x << y) | (x >> (sizeof(y) * 8 - y));
   11bb4:	ea4f 4333 	mov.w	r3, r3, ror #16
    bits = ByteReverseWord32(bits);
   11bb8:	932a      	str	r3, [sp, #168]	; 0xa8
        + ((outSz % OUTPUT_BLOCK_LEN) ? 1 : 0);
   11bba:	f018 091f 	ands.w	r9, r8, #31
   11bbe:	bf18      	it	ne
   11bc0:	f04f 0901 	movne.w	r9, #1
    for (i = 0, ctr = 1; i < len; i++, ctr++) {
   11bc4:	2301      	movs	r3, #1
   11bc6:	f88d 30af 	strb.w	r3, [sp, #175]	; 0xaf
   11bca:	eb19 1958 	adds.w	r9, r9, r8, lsr #5
   11bce:	d070      	beq.n	11cb2 <Hash_df+0x11e>
   11bd0:	4607      	mov	r7, r0
   11bd2:	460d      	mov	r5, r1
   11bd4:	2600      	movs	r6, #0
            ret = wc_Sha256Update(sha, &ctr, sizeof(ctr));
   11bd6:	469b      	mov	fp, r3
   11bd8:	e03e      	b.n	11c58 <Hash_df+0xc4>
            ret = wc_Sha256Update(sha, (byte*)&bits, sizeof(bits));
   11bda:	2204      	movs	r2, #4
   11bdc:	a92a      	add	r1, sp, #168	; 0xa8
   11bde:	a80b      	add	r0, sp, #44	; 0x2c
   11be0:	f7ff ff36 	bl	11a50 <wc_Sha256Update>
        if (ret == 0) {
   11be4:	4604      	mov	r4, r0
   11be6:	2800      	cmp	r0, #0
   11be8:	d146      	bne.n	11c78 <Hash_df+0xe4>
            if (type != drbgInitV)
   11bea:	f89d 3007 	ldrb.w	r3, [sp, #7]
   11bee:	2b04      	cmp	r3, #4
   11bf0:	d146      	bne.n	11c80 <Hash_df+0xec>
            ret = wc_Sha256Update(sha, inA, inASz);
   11bf2:	9a37      	ldr	r2, [sp, #220]	; 0xdc
   11bf4:	9936      	ldr	r1, [sp, #216]	; 0xd8
   11bf6:	a80b      	add	r0, sp, #44	; 0x2c
   11bf8:	f7ff ff2a 	bl	11a50 <wc_Sha256Update>
        if (ret == 0) {
   11bfc:	4604      	mov	r4, r0
   11bfe:	2800      	cmp	r0, #0
   11c00:	d13a      	bne.n	11c78 <Hash_df+0xe4>
            if (inB != NULL && inBSz > 0)
   11c02:	f1ba 0f00 	cmp.w	sl, #0
   11c06:	d002      	beq.n	11c0e <Hash_df+0x7a>
   11c08:	9b39      	ldr	r3, [sp, #228]	; 0xe4
   11c0a:	2b00      	cmp	r3, #0
   11c0c:	d142      	bne.n	11c94 <Hash_df+0x100>
            ret = wc_Sha256Final(sha, digest);
   11c0e:	a903      	add	r1, sp, #12
   11c10:	a80b      	add	r0, sp, #44	; 0x2c
   11c12:	f7fe fc91 	bl	10538 <wc_Sha256Final>
   11c16:	4604      	mov	r4, r0
        wc_Sha256Free(sha);
   11c18:	a80b      	add	r0, sp, #44	; 0x2c
   11c1a:	f00a f86a 	bl	1bcf2 <wc_Sha256Free>
        if (ret == 0) {
   11c1e:	b99c      	cbnz	r4, 11c48 <Hash_df+0xb4>
            if (outSz > OUTPUT_BLOCK_LEN) {
   11c20:	f1b8 0f20 	cmp.w	r8, #32
   11c24:	d93f      	bls.n	11ca6 <Hash_df+0x112>
                XMEMCPY(out, digest, OUTPUT_BLOCK_LEN);
   11c26:	f10d 0c0c 	add.w	ip, sp, #12
   11c2a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   11c2e:	6028      	str	r0, [r5, #0]
   11c30:	6069      	str	r1, [r5, #4]
   11c32:	60aa      	str	r2, [r5, #8]
   11c34:	60eb      	str	r3, [r5, #12]
   11c36:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   11c3a:	6128      	str	r0, [r5, #16]
   11c3c:	6169      	str	r1, [r5, #20]
   11c3e:	61aa      	str	r2, [r5, #24]
   11c40:	61eb      	str	r3, [r5, #28]
                outSz -= OUTPUT_BLOCK_LEN;
   11c42:	f1a8 0820 	sub.w	r8, r8, #32
                out += OUTPUT_BLOCK_LEN;
   11c46:	3520      	adds	r5, #32
    for (i = 0, ctr = 1; i < len; i++, ctr++) {
   11c48:	3601      	adds	r6, #1
   11c4a:	f89d 30af 	ldrb.w	r3, [sp, #175]	; 0xaf
   11c4e:	3301      	adds	r3, #1
   11c50:	f88d 30af 	strb.w	r3, [sp, #175]	; 0xaf
   11c54:	45b1      	cmp	r9, r6
   11c56:	d02d      	beq.n	11cb4 <Hash_df+0x120>
        ret = wc_InitSha256_ex(sha, drbg->heap, drbg->devId);
   11c58:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
   11c5a:	6fb9      	ldr	r1, [r7, #120]	; 0x78
   11c5c:	a80b      	add	r0, sp, #44	; 0x2c
   11c5e:	f009 fa2b 	bl	1b0b8 <wc_InitSha256_ex>
        if (ret != 0)
   11c62:	4604      	mov	r4, r0
   11c64:	bb30      	cbnz	r0, 11cb4 <Hash_df+0x120>
            ret = wc_Sha256Update(sha, &ctr, sizeof(ctr));
   11c66:	465a      	mov	r2, fp
   11c68:	f10d 01af 	add.w	r1, sp, #175	; 0xaf
   11c6c:	a80b      	add	r0, sp, #44	; 0x2c
   11c6e:	f7ff feef 	bl	11a50 <wc_Sha256Update>
        if (ret == 0)
   11c72:	4604      	mov	r4, r0
   11c74:	2800      	cmp	r0, #0
   11c76:	d0b0      	beq.n	11bda <Hash_df+0x46>
        wc_Sha256Free(sha);
   11c78:	a80b      	add	r0, sp, #44	; 0x2c
   11c7a:	f00a f83a 	bl	1bcf2 <wc_Sha256Free>
        if (ret == 0) {
   11c7e:	e7e3      	b.n	11c48 <Hash_df+0xb4>
                ret = wc_Sha256Update(sha, &type, sizeof(type));
   11c80:	465a      	mov	r2, fp
   11c82:	f10d 0107 	add.w	r1, sp, #7
   11c86:	a80b      	add	r0, sp, #44	; 0x2c
   11c88:	f7ff fee2 	bl	11a50 <wc_Sha256Update>
        if (ret == 0)
   11c8c:	4604      	mov	r4, r0
   11c8e:	2800      	cmp	r0, #0
   11c90:	d1f2      	bne.n	11c78 <Hash_df+0xe4>
   11c92:	e7ae      	b.n	11bf2 <Hash_df+0x5e>
                ret = wc_Sha256Update(sha, inB, inBSz);
   11c94:	461a      	mov	r2, r3
   11c96:	4651      	mov	r1, sl
   11c98:	a80b      	add	r0, sp, #44	; 0x2c
   11c9a:	f7ff fed9 	bl	11a50 <wc_Sha256Update>
        if (ret == 0)
   11c9e:	4604      	mov	r4, r0
   11ca0:	2800      	cmp	r0, #0
   11ca2:	d1e9      	bne.n	11c78 <Hash_df+0xe4>
   11ca4:	e7b3      	b.n	11c0e <Hash_df+0x7a>
                XMEMCPY(out, digest, outSz);
   11ca6:	4642      	mov	r2, r8
   11ca8:	a903      	add	r1, sp, #12
   11caa:	4628      	mov	r0, r5
   11cac:	f00f f9d8 	bl	21060 <memcpy>
   11cb0:	e7ca      	b.n	11c48 <Hash_df+0xb4>
    int ret = DRBG_FAILURE;
   11cb2:	2401      	movs	r4, #1
    volatile byte* z = (volatile byte*)mem;
   11cb4:	aa03      	add	r2, sp, #12
    while (len--) *z++ = 0;
   11cb6:	2000      	movs	r0, #0
   11cb8:	a90b      	add	r1, sp, #44	; 0x2c
   11cba:	4613      	mov	r3, r2
   11cbc:	f803 0b01 	strb.w	r0, [r3], #1
   11cc0:	461a      	mov	r2, r3
   11cc2:	428b      	cmp	r3, r1
   11cc4:	d1f9      	bne.n	11cba <Hash_df+0x126>
    return (ret == 0) ? DRBG_SUCCESS : DRBG_FAILURE;
   11cc6:	1c20      	adds	r0, r4, #0
   11cc8:	bf18      	it	ne
   11cca:	2001      	movne	r0, #1
}
   11ccc:	b02d      	add	sp, #180	; 0xb4
   11cce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

Disassembly of section .text._MACDeinit%268:

00011cd4 <_MACDeinit>:
{
   11cd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11cd8:	b08c      	sub	sp, #48	; 0x30
   11cda:	4604      	mov	r4, r0
     DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, NULL);
   11cdc:	2200      	movs	r2, #0
   11cde:	213f      	movs	r1, #63	; 0x3f
   11ce0:	f00e fae8 	bl	202b4 <DRV_PIC32CGMAC_LibSysInt_Disable>
	 DRV_PIC32CGMAC_LibClose(pMACDrv, DRV_PIC32CGMAC_CLOSE_DEFAULT);
   11ce4:	2100      	movs	r1, #0
   11ce6:	4620      	mov	r0, r4
   11ce8:	f00f f824 	bl	20d34 <DRV_PIC32CGMAC_LibClose>
     DRV_PIC32CGMAC_LibSysIntStatus_Clear(pMACDrv, GMAC_ALL_QUE_MASK);
   11cec:	213f      	movs	r1, #63	; 0x3f
   11cee:	4620      	mov	r0, r4
   11cf0:	f00d ff90 	bl	1fc14 <DRV_PIC32CGMAC_LibSysIntStatus_Clear>
	if(_hEventMac != hMac)
   11cf4:	4b45      	ldr	r3, [pc, #276]	; (11e0c <_MACDeinit+0x138>)
   11cf6:	681b      	ldr	r3, [r3, #0]
   11cf8:	429c      	cmp	r4, r3
   11cfa:	d114      	bne.n	11d26 <_MACDeinit+0x52>
    DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, NULL);
   11cfc:	2200      	movs	r2, #0
   11cfe:	213f      	movs	r1, #63	; 0x3f
   11d00:	4620      	mov	r0, r4
   11d02:	f00e fad7 	bl	202b4 <DRV_PIC32CGMAC_LibSysInt_Disable>
    DRV_PIC32CGMAC_LibSysIntStatus_Clear(pMACDrv, GMAC_ALL_QUE_MASK);
   11d06:	213f      	movs	r1, #63	; 0x3f
   11d08:	4620      	mov	r0, r4
   11d0a:	f00d ff83 	bl	1fc14 <DRV_PIC32CGMAC_LibSysIntStatus_Clear>
	pDcpt->_TcpNotifyFnc = 0;
   11d0e:	2300      	movs	r3, #0
   11d10:	6563      	str	r3, [r4, #84]	; 0x54
	pDcpt->_TcpEnabledEvents = pDcpt->_TcpPendingEvents = TCPIP_MAC_EV_NONE;
   11d12:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
   11d16:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
	pDcpt->_EthEnabledEvents = pDcpt->_EthPendingEvents = 0;
   11d1a:	f8a4 3052 	strh.w	r3, [r4, #82]	; 0x52
   11d1e:	f8a4 3050 	strh.w	r3, [r4, #80]	; 0x50
	_hEventMac = 0;
   11d22:	4a3a      	ldr	r2, [pc, #232]	; (11e0c <_MACDeinit+0x138>)
   11d24:	6013      	str	r3, [r2, #0]
	 const DRV_ETHPHY_OBJECT_BASE* pPhyBase =  pMACDrv->sGmacData.gmacConfig.pPhyBase;
   11d26:	f8d4 50d8 	ldr.w	r5, [r4, #216]	; 0xd8
	 if(pMACDrv->sGmacData.hPhyClient != DRV_HANDLE_INVALID)
   11d2a:	6920      	ldr	r0, [r4, #16]
   11d2c:	f1b0 3fff 	cmp.w	r0, #4294967295
   11d30:	d004      	beq.n	11d3c <_MACDeinit+0x68>
		 pPhyBase->DRV_ETHPHY_Close(pMACDrv->sGmacData.hPhyClient);
   11d32:	69ab      	ldr	r3, [r5, #24]
   11d34:	4798      	blx	r3
		 pMACDrv->sGmacData.hPhyClient = DRV_HANDLE_INVALID;
   11d36:	f04f 33ff 	mov.w	r3, #4294967295
   11d3a:	6123      	str	r3, [r4, #16]
	 if(pMACDrv->sGmacData.hPhySysObject != SYS_MODULE_OBJ_INVALID)
   11d3c:	68e0      	ldr	r0, [r4, #12]
   11d3e:	f1b0 3fff 	cmp.w	r0, #4294967295
   11d42:	d004      	beq.n	11d4e <_MACDeinit+0x7a>
		 pPhyBase->DRV_ETHPHY_Deinitialize(pMACDrv->sGmacData.hPhySysObject);
   11d44:	68ab      	ldr	r3, [r5, #8]
   11d46:	4798      	blx	r3
		 pMACDrv->sGmacData.hPhySysObject = SYS_MODULE_OBJ_INVALID;
   11d48:	f04f 33ff 	mov.w	r3, #4294967295
   11d4c:	60e3      	str	r3, [r4, #12]
	if(pMACDrv->sGmacData._synchF != 0)
   11d4e:	6b23      	ldr	r3, [r4, #48]	; 0x30
   11d50:	b11b      	cbz	r3, 11d5a <_MACDeinit+0x86>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_LOCK);
   11d52:	2103      	movs	r1, #3
   11d54:	f104 0060 	add.w	r0, r4, #96	; 0x60
   11d58:	4798      	blx	r3
    _MacTxDiscardQueues(pMACDrv,TCPIP_MAC_PKT_ACK_NET_DOWN);
   11d5a:	f06f 0101 	mvn.w	r1, #1
   11d5e:	4620      	mov	r0, r4
   11d60:	f00b fa38 	bl	1d1d4 <_MacTxDiscardQueues>
	if(pMACDrv->sGmacData._synchF != 0)
   11d64:	6b23      	ldr	r3, [r4, #48]	; 0x30
   11d66:	b11b      	cbz	r3, 11d70 <_MACDeinit+0x9c>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_UNLOCK);
   11d68:	2104      	movs	r1, #4
   11d6a:	f104 0060 	add.w	r0, r4, #96	; 0x60
   11d6e:	4798      	blx	r3
        gmac_queue = pMACDrv->sGmacData.gmac_queue[queueIdx];
   11d70:	ad01      	add	r5, sp, #4
   11d72:	f104 068c 	add.w	r6, r4, #140	; 0x8c
   11d76:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   11d78:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   11d7a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   11d7c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   11d7e:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
   11d82:	e885 0007 	stmia.w	r5, {r0, r1, r2}
        while((pRxPkt = (TCPIP_MAC_PACKET*)DRV_PIC32CGMAC_SingleListHeadRemove(&gmac_queue._RxQueue))!= NULL)
   11d86:	a803      	add	r0, sp, #12
   11d88:	f00e ffe2 	bl	20d50 <DRV_PIC32CGMAC_SingleListHeadRemove>
   11d8c:	4603      	mov	r3, r0
   11d8e:	b118      	cbz	r0, 11d98 <_MACDeinit+0xc4>
            (*pMACDrv->sGmacData.pktFreeF)(pRxPkt);                   
   11d90:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   11d92:	4618      	mov	r0, r3
   11d94:	4790      	blx	r2
   11d96:	e7f6      	b.n	11d86 <_MACDeinit+0xb2>
        for(index = 0; index < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxDescCnt; index++ )
   11d98:	f8b4 30be 	ldrh.w	r3, [r4, #190]	; 0xbe
   11d9c:	b30b      	cbz	r3, 11de2 <_MACDeinit+0x10e>
   11d9e:	2500      	movs	r5, #0
				gmac_queue.nRxDescIndex = 0;
   11da0:	462e      	mov	r6, r5
   11da2:	e011      	b.n	11dc8 <_MACDeinit+0xf4>
   11da4:	f8ad 6028 	strh.w	r6, [sp, #40]	; 0x28
				gmac_queue.pRxPckt[index] = 0;
   11da8:	9b01      	ldr	r3, [sp, #4]
   11daa:	f843 6008 	str.w	r6, [r3, r8]
				gmac_queue.pRxDesc[index].rx_desc_buffaddr.val = 0;
   11dae:	9b02      	ldr	r3, [sp, #8]
   11db0:	f843 6037 	str.w	r6, [r3, r7, lsl #3]
				gmac_queue.pRxDesc[index].rx_desc_status.val = 0;
   11db4:	9b02      	ldr	r3, [sp, #8]
   11db6:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
   11dba:	605e      	str	r6, [r3, #4]
        for(index = 0; index < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxDescCnt; index++ )
   11dbc:	3501      	adds	r5, #1
   11dbe:	b2ed      	uxtb	r5, r5
   11dc0:	f8b4 30be 	ldrh.w	r3, [r4, #190]	; 0xbe
   11dc4:	42ab      	cmp	r3, r5
   11dc6:	d90c      	bls.n	11de2 <_MACDeinit+0x10e>
            if(gmac_queue.pRxPckt != NULL)
   11dc8:	9b01      	ldr	r3, [sp, #4]
   11dca:	2b00      	cmp	r3, #0
   11dcc:	d0f6      	beq.n	11dbc <_MACDeinit+0xe8>
				pRxPkt = gmac_queue.pRxPckt[index];
   11dce:	462f      	mov	r7, r5
   11dd0:	ea4f 0885 	mov.w	r8, r5, lsl #2
   11dd4:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
				if(pRxPkt)
   11dd8:	2800      	cmp	r0, #0
   11dda:	d0e3      	beq.n	11da4 <_MACDeinit+0xd0>
					(*pMACDrv->sGmacData.pktFreeF)(pRxPkt);
   11ddc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   11dde:	4798      	blx	r3
   11de0:	e7e0      	b.n	11da4 <_MACDeinit+0xd0>
        if(gmac_queue.pRxPckt != NULL)
   11de2:	9901      	ldr	r1, [sp, #4]
   11de4:	b121      	cbz	r1, 11df0 <_MACDeinit+0x11c>
            (*pMACDrv->sGmacData._freeF)(pMACDrv->sGmacData._AllocH, gmac_queue.pRxPckt); 
   11de6:	6a23      	ldr	r3, [r4, #32]
   11de8:	69a0      	ldr	r0, [r4, #24]
   11dea:	4798      	blx	r3
            gmac_queue.pRxPckt = NULL;
   11dec:	2300      	movs	r3, #0
   11dee:	9301      	str	r3, [sp, #4]
   11df0:	f3bf 8f5f 	dmb	sy
	if(pMACDrv->sGmacData._synchF != 0)
   11df4:	6b23      	ldr	r3, [r4, #48]	; 0x30
   11df6:	b11b      	cbz	r3, 11e00 <_MACDeinit+0x12c>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_DELETE);
   11df8:	2102      	movs	r1, #2
   11dfa:	f104 0060 	add.w	r0, r4, #96	; 0x60
   11dfe:	4798      	blx	r3
	pMACDrv->sGmacData.sysStat = SYS_STATUS_UNINITIALIZED;
   11e00:	2300      	movs	r3, #0
   11e02:	7523      	strb	r3, [r4, #20]
	pMACDrv->sGmacData._macFlags.val = 0;
   11e04:	82e3      	strh	r3, [r4, #22]
}
   11e06:	b00c      	add	sp, #48	; 0x30
   11e08:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11e0c:	2000df14 	.word	0x2000df14

Disassembly of section .text.TCPIP_UDP_Deinitialize%269:

00011e10 <TCPIP_UDP_Deinitialize>:
    if(udpInitCount == 0)
   11e10:	4b48      	ldr	r3, [pc, #288]	; (11f34 <TCPIP_UDP_Deinitialize+0x124>)
   11e12:	681b      	ldr	r3, [r3, #0]
   11e14:	b903      	cbnz	r3, 11e18 <TCPIP_UDP_Deinitialize+0x8>
   11e16:	4770      	bx	lr
{
   11e18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11e1c:	b085      	sub	sp, #20
   11e1e:	4683      	mov	fp, r0
    OSAL_SEM_Pend(&userSem, OSAL_WAIT_FOREVER);
   11e20:	f64f 71ff 	movw	r1, #65535	; 0xffff
   11e24:	4844      	ldr	r0, [pc, #272]	; (11f38 <TCPIP_UDP_Deinitialize+0x128>)
   11e26:	f00e ff2d 	bl	20c84 <OSAL_SEM_Pend>
    _UDPAbortSockets(1 << stackCtrl->netIx, TCPIP_UDP_SIGNAL_IF_DOWN); 
   11e2a:	f8db 3018 	ldr.w	r3, [fp, #24]
   11e2e:	2601      	movs	r6, #1
   11e30:	409e      	lsls	r6, r3
    for(ix = 0; ix < nUdpSockets; ix++)
   11e32:	4b42      	ldr	r3, [pc, #264]	; (11f3c <TCPIP_UDP_Deinitialize+0x12c>)
   11e34:	681b      	ldr	r3, [r3, #0]
   11e36:	2b00      	cmp	r3, #0
   11e38:	dd3f      	ble.n	11eba <TCPIP_UDP_Deinitialize+0xaa>
   11e3a:	2500      	movs	r5, #0
        if((pSkt = UDPSocketDcpt[ix]) != 0)  
   11e3c:	f8df 9100 	ldr.w	r9, [pc, #256]	; 11f40 <TCPIP_UDP_Deinitialize+0x130>
                uint32_t sktIfMask = 1 << sktIfIx;
   11e40:	f04f 0a01 	mov.w	sl, #1
    for(ix = 0; ix < nUdpSockets; ix++)
   11e44:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 11f3c <TCPIP_UDP_Deinitialize+0x12c>
   11e48:	e004      	b.n	11e54 <TCPIP_UDP_Deinitialize+0x44>
   11e4a:	3501      	adds	r5, #1
   11e4c:	f8d8 3000 	ldr.w	r3, [r8]
   11e50:	429d      	cmp	r5, r3
   11e52:	da32      	bge.n	11eba <TCPIP_UDP_Deinitialize+0xaa>
        if((pSkt = UDPSocketDcpt[ix]) != 0)  
   11e54:	f8d9 3000 	ldr.w	r3, [r9]
   11e58:	f853 4025 	ldr.w	r4, [r3, r5, lsl #2]
   11e5c:	2c00      	cmp	r4, #0
   11e5e:	d0f4      	beq.n	11e4a <TCPIP_UDP_Deinitialize+0x3a>
            sktIf = pSkt->pSktNet;
   11e60:	6a67      	ldr	r7, [r4, #36]	; 0x24
            sktIfIx = TCPIP_STACK_NetIxGet(sktIf); 
   11e62:	4638      	mov	r0, r7
   11e64:	f00f fed6 	bl	21c14 <TCPIP_STACK_NetIxGet>
            if(sktIfIx >= 0)
   11e68:	2800      	cmp	r0, #0
   11e6a:	dbee      	blt.n	11e4a <TCPIP_UDP_Deinitialize+0x3a>
                uint32_t sktIfMask = 1 << sktIfIx;
   11e6c:	fa0a f000 	lsl.w	r0, sl, r0
                if((sktIfMask & netMask) != 0)
   11e70:	4230      	tst	r0, r6
   11e72:	d0ea      	beq.n	11e4a <TCPIP_UDP_Deinitialize+0x3a>
                    TCPIP_UDP_Disconnect(pSkt->sktIx, true);
   11e74:	4651      	mov	r1, sl
   11e76:	f9b4 0012 	ldrsh.w	r0, [r4, #18]
   11e7a:	f005 fc51 	bl	17720 <TCPIP_UDP_Disconnect>
                    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   11e7e:	2000      	movs	r0, #0
   11e80:	f00f fb0c 	bl	2149c <OSAL_CRIT_Enter>
                    sigHandler = pSkt->sigHandler;
   11e84:	6d23      	ldr	r3, [r4, #80]	; 0x50
   11e86:	9301      	str	r3, [sp, #4]
                    sigParam = pSkt->sigParam;
   11e88:	6d61      	ldr	r1, [r4, #84]	; 0x54
   11e8a:	9103      	str	r1, [sp, #12]
                    sigMask = pSkt->sigMask;
   11e8c:	f8b4 1058 	ldrh.w	r1, [r4, #88]	; 0x58
   11e90:	9102      	str	r1, [sp, #8]
                    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   11e92:	4601      	mov	r1, r0
   11e94:	2000      	movs	r0, #0
   11e96:	f00f fc30 	bl	216fa <OSAL_CRIT_Leave>
                    if(sigHandler != 0 && (sigMask & sigType) != 0)
   11e9a:	9a01      	ldr	r2, [sp, #4]
   11e9c:	2a00      	cmp	r2, #0
   11e9e:	d0d4      	beq.n	11e4a <TCPIP_UDP_Deinitialize+0x3a>
   11ea0:	9902      	ldr	r1, [sp, #8]
   11ea2:	f411 5f00 	tst.w	r1, #8192	; 0x2000
   11ea6:	d0d0      	beq.n	11e4a <TCPIP_UDP_Deinitialize+0x3a>
                        (*sigHandler)(pSkt->sktIx, (TCPIP_NET_HANDLE)sktIf, sigType, sigParam);
   11ea8:	9b03      	ldr	r3, [sp, #12]
   11eaa:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   11eae:	4639      	mov	r1, r7
   11eb0:	f9b4 0012 	ldrsh.w	r0, [r4, #18]
   11eb4:	9c01      	ldr	r4, [sp, #4]
   11eb6:	47a0      	blx	r4
   11eb8:	e7c7      	b.n	11e4a <TCPIP_UDP_Deinitialize+0x3a>
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_DEINIT)
   11eba:	f89b 301c 	ldrb.w	r3, [fp, #28]
   11ebe:	2b02      	cmp	r3, #2
   11ec0:	d131      	bne.n	11f26 <TCPIP_UDP_Deinitialize+0x116>
        if(--udpInitCount == 0)
   11ec2:	4b1c      	ldr	r3, [pc, #112]	; (11f34 <TCPIP_UDP_Deinitialize+0x124>)
   11ec4:	681c      	ldr	r4, [r3, #0]
   11ec6:	3c01      	subs	r4, #1
   11ec8:	601c      	str	r4, [r3, #0]
   11eca:	2c00      	cmp	r4, #0
   11ecc:	d12b      	bne.n	11f26 <TCPIP_UDP_Deinitialize+0x116>
            for(ix = 0; ix < nUdpSockets; ix++)
   11ece:	4b1b      	ldr	r3, [pc, #108]	; (11f3c <TCPIP_UDP_Deinitialize+0x12c>)
   11ed0:	681b      	ldr	r3, [r3, #0]
   11ed2:	2b00      	cmp	r3, #0
   11ed4:	dd0e      	ble.n	11ef4 <TCPIP_UDP_Deinitialize+0xe4>
                pSkt = UDPSocketDcpt[ix];
   11ed6:	4e1a      	ldr	r6, [pc, #104]	; (11f40 <TCPIP_UDP_Deinitialize+0x130>)
            for(ix = 0; ix < nUdpSockets; ix++)
   11ed8:	4d18      	ldr	r5, [pc, #96]	; (11f3c <TCPIP_UDP_Deinitialize+0x12c>)
   11eda:	e005      	b.n	11ee8 <TCPIP_UDP_Deinitialize+0xd8>
                    _UDPClose(pSkt);
   11edc:	f00a fc8e 	bl	1c7fc <_UDPClose>
            for(ix = 0; ix < nUdpSockets; ix++)
   11ee0:	3401      	adds	r4, #1
   11ee2:	682b      	ldr	r3, [r5, #0]
   11ee4:	42a3      	cmp	r3, r4
   11ee6:	dd05      	ble.n	11ef4 <TCPIP_UDP_Deinitialize+0xe4>
                pSkt = UDPSocketDcpt[ix];
   11ee8:	6833      	ldr	r3, [r6, #0]
   11eea:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
                if(pSkt) 
   11eee:	2800      	cmp	r0, #0
   11ef0:	d1f4      	bne.n	11edc <TCPIP_UDP_Deinitialize+0xcc>
   11ef2:	e7f5      	b.n	11ee0 <TCPIP_UDP_Deinitialize+0xd0>
            TCPIP_HEAP_Free(udpMemH, UDPSocketDcpt);
   11ef4:	4b13      	ldr	r3, [pc, #76]	; (11f44 <TCPIP_UDP_Deinitialize+0x134>)
   11ef6:	6818      	ldr	r0, [r3, #0]
   11ef8:	4c11      	ldr	r4, [pc, #68]	; (11f40 <TCPIP_UDP_Deinitialize+0x130>)
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   11efa:	68c3      	ldr	r3, [r0, #12]
   11efc:	6821      	ldr	r1, [r4, #0]
   11efe:	4798      	blx	r3
            UDPSocketDcpt = 0;
   11f00:	2300      	movs	r3, #0
   11f02:	6023      	str	r3, [r4, #0]
            if(signalHandle)
   11f04:	4b10      	ldr	r3, [pc, #64]	; (11f48 <TCPIP_UDP_Deinitialize+0x138>)
   11f06:	6818      	ldr	r0, [r3, #0]
   11f08:	b120      	cbz	r0, 11f14 <TCPIP_UDP_Deinitialize+0x104>
                _TCPIPStackSignalHandlerDeregister(signalHandle);
   11f0a:	f00f fe8a 	bl	21c22 <_TCPIPStackSignalHandlerDeregister>
                signalHandle = 0;
   11f0e:	4b0e      	ldr	r3, [pc, #56]	; (11f48 <TCPIP_UDP_Deinitialize+0x138>)
   11f10:	2200      	movs	r2, #0
   11f12:	601a      	str	r2, [r3, #0]
            udpMemH = 0;
   11f14:	2300      	movs	r3, #0
   11f16:	4a0b      	ldr	r2, [pc, #44]	; (11f44 <TCPIP_UDP_Deinitialize+0x134>)
   11f18:	6013      	str	r3, [r2, #0]
            nUdpSockets = 0;
   11f1a:	4a08      	ldr	r2, [pc, #32]	; (11f3c <TCPIP_UDP_Deinitialize+0x12c>)
   11f1c:	6013      	str	r3, [r2, #0]
    OSAL_SEM_Delete(&userSem);
   11f1e:	4806      	ldr	r0, [pc, #24]	; (11f38 <TCPIP_UDP_Deinitialize+0x128>)
   11f20:	f00f fd24 	bl	2196c <OSAL_SEM_Delete>
   11f24:	e002      	b.n	11f2c <TCPIP_UDP_Deinitialize+0x11c>
    OSAL_SEM_Post(&userSem);
   11f26:	4804      	ldr	r0, [pc, #16]	; (11f38 <TCPIP_UDP_Deinitialize+0x128>)
   11f28:	f00f fac4 	bl	214b4 <OSAL_SEM_Post>
}
   11f2c:	b005      	add	sp, #20
   11f2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11f32:	bf00      	nop
   11f34:	2000e668 	.word	0x2000e668
   11f38:	2000e670 	.word	0x2000e670
   11f3c:	2000e660 	.word	0x2000e660
   11f40:	2000e65c 	.word	0x2000e65c
   11f44:	2000e66c 	.word	0x2000e66c
   11f48:	2000e664 	.word	0x2000e664

Disassembly of section .text._LoadNetworkConfig%270:

00011f4c <_LoadNetworkConfig>:
{
   11f4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11f50:	b082      	sub	sp, #8
   11f52:	4605      	mov	r5, r0
   11f54:	460c      	mov	r4, r1
    if(restartIf)
   11f56:	4617      	mov	r7, r2
   11f58:	2a00      	cmp	r2, #0
   11f5a:	d13b      	bne.n	11fd4 <_LoadNetworkConfig+0x88>
    const void*  pMacConfig = 0;             // MAC configuration save
   11f5c:	2600      	movs	r6, #0
    int     netIfIx = 0;
   11f5e:	46b0      	mov	r8, r6
        memset(pNetIf, 0, sizeof(*pNetIf));
   11f60:	226c      	movs	r2, #108	; 0x6c
   11f62:	2100      	movs	r1, #0
   11f64:	4620      	mov	r0, r4
   11f66:	f00f fe09 	bl	21b7c <memset>
        if(pUsrConfig->macAddr != 0)
   11f6a:	68a8      	ldr	r0, [r5, #8]
   11f6c:	2800      	cmp	r0, #0
   11f6e:	d03a      	beq.n	11fe6 <_LoadNetworkConfig+0x9a>
            TCPIP_Helper_StringToMACAddress(pUsrConfig->macAddr, pNetIf->netMACAddr.v);
   11f70:	f104 013c 	add.w	r1, r4, #60	; 0x3c
   11f74:	f003 ffd8 	bl	15f28 <TCPIP_Helper_StringToMACAddress>
        TCPIP_Helper_StringToIPAddress(pUsrConfig->ipAddr, &pNetIf->DefaultIPAddr);
   11f78:	f104 0118 	add.w	r1, r4, #24
   11f7c:	68e8      	ldr	r0, [r5, #12]
   11f7e:	f001 f805 	bl	12f8c <TCPIP_Helper_StringToIPAddress>
        TCPIP_Helper_StringToIPAddress(pUsrConfig->ipMask, &pNetIf->DefaultMask);
   11f82:	f104 011c 	add.w	r1, r4, #28
   11f86:	6928      	ldr	r0, [r5, #16]
   11f88:	f001 f800 	bl	12f8c <TCPIP_Helper_StringToIPAddress>
        TCPIP_Helper_StringToIPAddress(pUsrConfig->gateway, &pNetIf->DefaultGateway);
   11f8c:	f104 0120 	add.w	r1, r4, #32
   11f90:	6968      	ldr	r0, [r5, #20]
   11f92:	f000 fffb 	bl	12f8c <TCPIP_Helper_StringToIPAddress>
        TCPIP_Helper_StringToIPAddress(pUsrConfig->priDNS, &pNetIf->DefaultDNSServer[0]);
   11f96:	f104 0124 	add.w	r1, r4, #36	; 0x24
   11f9a:	69a8      	ldr	r0, [r5, #24]
   11f9c:	f000 fff6 	bl	12f8c <TCPIP_Helper_StringToIPAddress>
        TCPIP_Helper_StringToIPAddress(pUsrConfig->secondDNS, &pNetIf->DefaultDNSServer[1]);
   11fa0:	f104 0128 	add.w	r1, r4, #40	; 0x28
   11fa4:	69e8      	ldr	r0, [r5, #28]
   11fa6:	f000 fff1 	bl	12f8c <TCPIP_Helper_StringToIPAddress>
        if((pNetIf->pMacObj = pUsrConfig->pMacObject) == 0)
   11faa:	6aab      	ldr	r3, [r5, #40]	; 0x28
   11fac:	6463      	str	r3, [r4, #68]	; 0x44
   11fae:	2b00      	cmp	r3, #0
   11fb0:	d055      	beq.n	1205e <_LoadNetworkConfig+0x112>
        pNetIf->macId = pNetIf->pMacObj->macId;
   11fb2:	881a      	ldrh	r2, [r3, #0]
   11fb4:	8062      	strh	r2, [r4, #2]
        pNetIf->macType = pNetIf->pMacObj->macType;
   11fb6:	789b      	ldrb	r3, [r3, #2]
   11fb8:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69
        if(pNetIf->macType == 0 || pNetIf->macType >= TCPIP_MAC_TYPES)
   11fbc:	3b01      	subs	r3, #1
   11fbe:	b2db      	uxtb	r3, r3
   11fc0:	2b01      	cmp	r3, #1
   11fc2:	d915      	bls.n	11ff0 <_LoadNetworkConfig+0xa4>
            loadFault = true;       // no such MAC type
   11fc4:	2301      	movs	r3, #1
    if(restartIf)
   11fc6:	2f00      	cmp	r7, #0
   11fc8:	d14d      	bne.n	12066 <_LoadNetworkConfig+0x11a>
}
   11fca:	f083 0001 	eor.w	r0, r3, #1
   11fce:	b002      	add	sp, #8
   11fd0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        strncpy(oldIfName, pNetIf->ifName, sizeof(oldIfName) - 1); 
   11fd4:	2207      	movs	r2, #7
   11fd6:	3162      	adds	r1, #98	; 0x62
   11fd8:	4668      	mov	r0, sp
   11fda:	f00e f934 	bl	20246 <strncpy>
        pMacConfig = pNetIf->pMacConfig;
   11fde:	6d66      	ldr	r6, [r4, #84]	; 0x54
        netIfIx = pNetIf->netIfIx;
   11fe0:	f8b4 8058 	ldrh.w	r8, [r4, #88]	; 0x58
   11fe4:	e7bc      	b.n	11f60 <_LoadNetworkConfig+0x14>
            memset(pNetIf->netMACAddr.v, 0, sizeof(pNetIf->netMACAddr.v));
   11fe6:	2200      	movs	r2, #0
   11fe8:	63e2      	str	r2, [r4, #60]	; 0x3c
   11fea:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
   11fee:	e7c3      	b.n	11f78 <_LoadNetworkConfig+0x2c>
        memcpy(pNetIf->NetBIOSName, pUsrConfig->hostName, sizeof(tcpipNetIf[0].NetBIOSName));
   11ff0:	f104 002c 	add.w	r0, r4, #44	; 0x2c
   11ff4:	686b      	ldr	r3, [r5, #4]
   11ff6:	f8d3 c000 	ldr.w	ip, [r3]
   11ffa:	6859      	ldr	r1, [r3, #4]
   11ffc:	689a      	ldr	r2, [r3, #8]
   11ffe:	68db      	ldr	r3, [r3, #12]
   12000:	f8c4 c02c 	str.w	ip, [r4, #44]	; 0x2c
   12004:	6041      	str	r1, [r0, #4]
   12006:	6082      	str	r2, [r0, #8]
   12008:	60c3      	str	r3, [r0, #12]
        TCPIP_Helper_FormatNetBIOSName(pNetIf->NetBIOSName);
   1200a:	f00a f9d7 	bl	1c3bc <TCPIP_Helper_FormatNetBIOSName>
        pNetIf->startFlags = pUsrConfig->startFlags;
   1200e:	8cab      	ldrh	r3, [r5, #36]	; 0x24
   12010:	64a3      	str	r3, [r4, #72]	; 0x48
    pNetIf->Flags.bInConfig = config;
   12012:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   12016:	f043 0310 	orr.w	r3, r3, #16
   1201a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
        startAddService = TCPIP_STACK_AddressServiceSelect(pNetIf, pUsrConfig->startFlags);
   1201e:	8ca9      	ldrh	r1, [r5, #36]	; 0x24
   12020:	4620      	mov	r0, r4
   12022:	f00e f8ea 	bl	201fa <TCPIP_STACK_AddressServiceSelect>
        if(startAddService == TCPIP_STACK_ADDRESS_SERVICE_NONE)
   12026:	b1b0      	cbz	r0, 12056 <_LoadNetworkConfig+0x10a>
    pNetIf->dnsServer[0].Val = pNetIf->DefaultDNSServer[0].Val;
   12028:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1202a:	6123      	str	r3, [r4, #16]
    pNetIf->dnsServer[1].Val = pNetIf->DefaultDNSServer[1].Val;
   1202c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1202e:	6163      	str	r3, [r4, #20]
        pNetIf->Flags.bIsDNSServerAuto = 1;
   12030:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   12034:	f043 0320 	orr.w	r3, r3, #32
   12038:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        TCPIP_STACK_DNS_SERVICE_TYPE addDynamicNameService = TCPIP_STACK_DNSServiceSelect(pNetIf, pUsrConfig->startFlags);
   1203c:	8ca9      	ldrh	r1, [r5, #36]	; 0x24
   1203e:	4620      	mov	r0, r4
   12040:	f00e f8c8 	bl	201d4 <TCPIP_STACK_DNSServiceSelect>
        if(addDynamicNameService == TCPIP_STACK_DNS_SERVICE_NONE)
   12044:	b968      	cbnz	r0, 12062 <_LoadNetworkConfig+0x116>
            pNetIf->Flags.bIsDnsClientEnabled = 1;
   12046:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   1204a:	f043 0308 	orr.w	r3, r3, #8
   1204e:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        loadFault = false;
   12052:	2300      	movs	r3, #0
   12054:	e7b7      	b.n	11fc6 <_LoadNetworkConfig+0x7a>
            TCPIP_STACK_AddressServiceDefaultSet(pNetIf);
   12056:	4620      	mov	r0, r4
   12058:	f00b fe3a 	bl	1dcd0 <TCPIP_STACK_AddressServiceDefaultSet>
   1205c:	e7e4      	b.n	12028 <_LoadNetworkConfig+0xdc>
            loadFault = true;       // no such MAC interface
   1205e:	2301      	movs	r3, #1
   12060:	e7b1      	b.n	11fc6 <_LoadNetworkConfig+0x7a>
        loadFault = false;
   12062:	2300      	movs	r3, #0
   12064:	e7af      	b.n	11fc6 <_LoadNetworkConfig+0x7a>
        memcpy(pNetIf->ifName, oldIfName, sizeof(pNetIf->ifName)); 
   12066:	9800      	ldr	r0, [sp, #0]
   12068:	f8c4 0062 	str.w	r0, [r4, #98]	; 0x62
   1206c:	f8bd 0004 	ldrh.w	r0, [sp, #4]
   12070:	f89d 1006 	ldrb.w	r1, [sp, #6]
   12074:	f8a4 0066 	strh.w	r0, [r4, #102]	; 0x66
   12078:	f884 1068 	strb.w	r1, [r4, #104]	; 0x68
        pNetIf->pMacConfig = pMacConfig;
   1207c:	6566      	str	r6, [r4, #84]	; 0x54
        pNetIf->netIfIx = netIfIx;
   1207e:	f8a4 8058 	strh.w	r8, [r4, #88]	; 0x58
   12082:	e7a2      	b.n	11fca <_LoadNetworkConfig+0x7e>

Disassembly of section .text.CommandIperfNetIf%271:

00012084 <CommandIperfNetIf>:
{
   12084:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12088:	b087      	sub	sp, #28
   1208a:	4682      	mov	sl, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   1208c:	6843      	ldr	r3, [r0, #4]
   1208e:	9301      	str	r3, [sp, #4]
    ipAddr.Val = 0;
   12090:	2300      	movs	r3, #0
   12092:	9305      	str	r3, [sp, #20]
    if (argc >= 3)
   12094:	2902      	cmp	r1, #2
   12096:	dd5c      	ble.n	12152 <CommandIperfNetIf+0xce>
   12098:	4614      	mov	r4, r2
   1209a:	f1a1 0803 	sub.w	r8, r1, #3
   1209e:	f028 0801 	bic.w	r8, r8, #1
   120a2:	f108 0803 	add.w	r8, r8, #3
        int currIx = 1; // 1st param is always the command name, skip it
   120a6:	2601      	movs	r6, #1
    bool addFound = false;
   120a8:	9303      	str	r3, [sp, #12]
    int iperfIndex = 0;     // assume index 0 if not specified
   120aa:	4699      	mov	r9, r3
            if(strcmp(param, "-a") == 0)
   120ac:	f8df b100 	ldr.w	fp, [pc, #256]	; 121b0 <CommandIperfNetIf+0x12c>
            else if((strcmp(param, "-i") == 0) || (strcmp(param, "--index") == 0))
   120b0:	f10b 033c 	add.w	r3, fp, #60	; 0x3c
   120b4:	9300      	str	r3, [sp, #0]
   120b6:	f10b 0340 	add.w	r3, fp, #64	; 0x40
   120ba:	9302      	str	r3, [sp, #8]
   120bc:	e014      	b.n	120e8 <CommandIperfNetIf+0x64>
                if(!TCPIP_Helper_StringToIPAddress(paramVal, &ipAddr))
   120be:	a905      	add	r1, sp, #20
   120c0:	4638      	mov	r0, r7
   120c2:	f000 ff63 	bl	12f8c <TCPIP_Helper_StringToIPAddress>
   120c6:	9003      	str	r0, [sp, #12]
   120c8:	b950      	cbnz	r0, 120e0 <CommandIperfNetIf+0x5c>
                    (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperfi: use a valid IP address!\r\n");
   120ca:	f8da 3000 	ldr.w	r3, [sl]
   120ce:	681b      	ldr	r3, [r3, #0]
   120d0:	492f      	ldr	r1, [pc, #188]	; (12190 <CommandIperfNetIf+0x10c>)
   120d2:	9801      	ldr	r0, [sp, #4]
   120d4:	4798      	blx	r3
                    return;
   120d6:	e042      	b.n	1215e <CommandIperfNetIf+0xda>
                iperfIndex = atoi(paramVal);
   120d8:	4638      	mov	r0, r7
   120da:	f010 f807 	bl	220ec <atoi>
   120de:	4681      	mov	r9, r0
            currIx += 2;
   120e0:	3602      	adds	r6, #2
   120e2:	3408      	adds	r4, #8
        while(currIx + 1 < argc)
   120e4:	45b0      	cmp	r8, r6
   120e6:	d01b      	beq.n	12120 <CommandIperfNetIf+0x9c>
            char* param = argv[currIx];
   120e8:	6865      	ldr	r5, [r4, #4]
            char* paramVal = argv[currIx + 1];
   120ea:	68a7      	ldr	r7, [r4, #8]
            if(strcmp(param, "-a") == 0)
   120ec:	4929      	ldr	r1, [pc, #164]	; (12194 <CommandIperfNetIf+0x110>)
   120ee:	4628      	mov	r0, r5
   120f0:	f00f fc04 	bl	218fc <strcmp>
   120f4:	2800      	cmp	r0, #0
   120f6:	d0e2      	beq.n	120be <CommandIperfNetIf+0x3a>
            else if((strcmp(param, "-i") == 0) || (strcmp(param, "--index") == 0))
   120f8:	9900      	ldr	r1, [sp, #0]
   120fa:	4628      	mov	r0, r5
   120fc:	f00f fbfe 	bl	218fc <strcmp>
   12100:	2800      	cmp	r0, #0
   12102:	d0e9      	beq.n	120d8 <CommandIperfNetIf+0x54>
   12104:	9902      	ldr	r1, [sp, #8]
   12106:	4628      	mov	r0, r5
   12108:	f00f fbf8 	bl	218fc <strcmp>
   1210c:	2800      	cmp	r0, #0
   1210e:	d0e3      	beq.n	120d8 <CommandIperfNetIf+0x54>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperfi: Unknown parameter\r\n");
   12110:	f8da 3000 	ldr.w	r3, [sl]
   12114:	681b      	ldr	r3, [r3, #0]
   12116:	f10b 0148 	add.w	r1, fp, #72	; 0x48
   1211a:	9801      	ldr	r0, [sp, #4]
   1211c:	4798      	blx	r3
   1211e:	e7df      	b.n	120e0 <CommandIperfNetIf+0x5c>
    if (!addFound)
   12120:	9b03      	ldr	r3, [sp, #12]
   12122:	b1b3      	cbz	r3, 12152 <CommandIperfNetIf+0xce>
    if(iperfIndex < 0 || iperfIndex >= nIperfSessions)
   12124:	f1b9 0f00 	cmp.w	r9, #0
   12128:	db1c      	blt.n	12164 <CommandIperfNetIf+0xe0>
   1212a:	4b1b      	ldr	r3, [pc, #108]	; (12198 <CommandIperfNetIf+0x114>)
   1212c:	681b      	ldr	r3, [r3, #0]
   1212e:	454b      	cmp	r3, r9
   12130:	dd18      	ble.n	12164 <CommandIperfNetIf+0xe0>
    pIState = gIperfState + iperfIndex;	
   12132:	4a1a      	ldr	r2, [pc, #104]	; (1219c <CommandIperfNetIf+0x118>)
   12134:	23d8      	movs	r3, #216	; 0xd8
   12136:	fb03 2309 	mla	r3, r3, r9, r2
    if (pIState->state != IPERF_STANDBY_STATE)
   1213a:	f893 20ce 	ldrb.w	r2, [r3, #206]	; 0xce
   1213e:	2a01      	cmp	r2, #1
   12140:	d01a      	beq.n	12178 <CommandIperfNetIf+0xf4>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperfi: cannot change the ip address while session: %d running!\r\n", iperfIndex);
   12142:	f8da 3000 	ldr.w	r3, [sl]
   12146:	685b      	ldr	r3, [r3, #4]
   12148:	464a      	mov	r2, r9
   1214a:	4915      	ldr	r1, [pc, #84]	; (121a0 <CommandIperfNetIf+0x11c>)
   1214c:	9801      	ldr	r0, [sp, #4]
   1214e:	4798      	blx	r3
        return;
   12150:	e005      	b.n	1215e <CommandIperfNetIf+0xda>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: iperfi -a address <-i index>\r\n");
   12152:	f8da 3000 	ldr.w	r3, [sl]
   12156:	681b      	ldr	r3, [r3, #0]
   12158:	4912      	ldr	r1, [pc, #72]	; (121a4 <CommandIperfNetIf+0x120>)
   1215a:	9801      	ldr	r0, [sp, #4]
   1215c:	4798      	blx	r3
}
   1215e:	b007      	add	sp, #28
   12160:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: Invalid session number. Min: 0, Max: %d\r\n", nIperfSessions - 1);
   12164:	4b0c      	ldr	r3, [pc, #48]	; (12198 <CommandIperfNetIf+0x114>)
   12166:	681a      	ldr	r2, [r3, #0]
   12168:	f8da 3000 	ldr.w	r3, [sl]
   1216c:	685b      	ldr	r3, [r3, #4]
   1216e:	3a01      	subs	r2, #1
   12170:	490d      	ldr	r1, [pc, #52]	; (121a8 <CommandIperfNetIf+0x124>)
   12172:	9801      	ldr	r0, [sp, #4]
   12174:	4798      	blx	r3
        return;
   12176:	e7f2      	b.n	1215e <CommandIperfNetIf+0xda>
    pIState->localAddr.Val = ipAddr.Val;
   12178:	9a05      	ldr	r2, [sp, #20]
   1217a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    (*pCmdIO->pCmdApi->print)(cmdIoParam, "iperfi: OK, set the IP address to instance: %d\r\n", iperfIndex);
   1217e:	f8da 3000 	ldr.w	r3, [sl]
   12182:	685b      	ldr	r3, [r3, #4]
   12184:	464a      	mov	r2, r9
   12186:	4909      	ldr	r1, [pc, #36]	; (121ac <CommandIperfNetIf+0x128>)
   12188:	9801      	ldr	r0, [sp, #4]
   1218a:	4798      	blx	r3
   1218c:	e7e7      	b.n	1215e <CommandIperfNetIf+0xda>
   1218e:	bf00      	nop
   12190:	00004dd8 	.word	0x00004dd8
   12194:	00004dd4 	.word	0x00004dd4
   12198:	2000e5f8 	.word	0x2000e5f8
   1219c:	2000dbb0 	.word	0x2000dbb0
   121a0:	00004e24 	.word	0x00004e24
   121a4:	00004dfc 	.word	0x00004dfc
   121a8:	00004ca8 	.word	0x00004ca8
   121ac:	00004e68 	.word	0x00004e68
   121b0:	00004c44 	.word	0x00004c44

Disassembly of section .text._DNS_Resolve%272:

000121b4 <_DNS_Resolve>:
{
   121b4:	b5f0      	push	{r4, r5, r6, r7, lr}
   121b6:	b085      	sub	sp, #20
    pDnsDcpt = pgDnsDcpt;
   121b8:	4b49      	ldr	r3, [pc, #292]	; (122e0 <_DNS_Resolve+0x12c>)
   121ba:	681d      	ldr	r5, [r3, #0]
    if(pDnsDcpt == 0)
   121bc:	2d00      	cmp	r5, #0
   121be:	d07a      	beq.n	122b6 <_DNS_Resolve+0x102>
    if(hostName == 0 || strlen(hostName) == 0 || strlen(hostName)  >= TCPIP_DNS_CLIENT_MAX_HOSTNAME_LEN)
   121c0:	2800      	cmp	r0, #0
   121c2:	d07b      	beq.n	122bc <_DNS_Resolve+0x108>
   121c4:	7803      	ldrb	r3, [r0, #0]
   121c6:	2b00      	cmp	r3, #0
   121c8:	d07b      	beq.n	122c2 <_DNS_Resolve+0x10e>
   121ca:	4617      	mov	r7, r2
   121cc:	460e      	mov	r6, r1
   121ce:	4604      	mov	r4, r0
   121d0:	f00f fce4 	bl	21b9c <strlen>
   121d4:	283f      	cmp	r0, #63	; 0x3f
   121d6:	d877      	bhi.n	122c8 <_DNS_Resolve+0x114>
    if(TCPIP_Helper_StringToIPAddress(hostName, &ipAddr.v4Add) || TCPIP_Helper_StringToIPv6Address (hostName, &ipAddr.v6Add))
   121d8:	4669      	mov	r1, sp
   121da:	4620      	mov	r0, r4
   121dc:	f000 fed6 	bl	12f8c <TCPIP_Helper_StringToIPAddress>
   121e0:	2800      	cmp	r0, #0
   121e2:	d174      	bne.n	122ce <_DNS_Resolve+0x11a>
   121e4:	4669      	mov	r1, sp
   121e6:	4620      	mov	r0, r4
   121e8:	f7f8 fd32 	bl	ac50 <TCPIP_Helper_StringToIPv6Address>
   121ec:	2800      	cmp	r0, #0
   121ee:	d170      	bne.n	122d2 <_DNS_Resolve+0x11e>
    dnsHE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryLookupOrInsert(pDnsDcpt->hashDcpt, (void*)hostName);
   121f0:	4621      	mov	r1, r4
   121f2:	6828      	ldr	r0, [r5, #0]
   121f4:	f008 fe2e 	bl	1ae54 <TCPIP_OAHASH_EntryLookupOrInsert>
    if(dnsHE == 0)
   121f8:	4604      	mov	r4, r0
   121fa:	2800      	cmp	r0, #0
   121fc:	d06b      	beq.n	122d6 <_DNS_Resolve+0x122>
    if(type == TCPIP_DNS_TYPE_A)
   121fe:	2e01      	cmp	r6, #1
   12200:	d019      	beq.n	12236 <_DNS_Resolve+0x82>
        recMask = TCPIP_DNS_ADDRESS_REC_IPV4 | TCPIP_DNS_ADDRESS_REC_IPV6;
   12202:	2e1c      	cmp	r6, #28
   12204:	bf0c      	ite	eq
   12206:	2302      	moveq	r3, #2
   12208:	2303      	movne	r3, #3
    if(forceQuery == 0 && dnsHE->hEntry.flags.newEntry == 0)
   1220a:	b9b7      	cbnz	r7, 1223a <_DNS_Resolve+0x86>
   1220c:	7822      	ldrb	r2, [r4, #0]
   1220e:	f012 0f02 	tst.w	r2, #2
   12212:	d127      	bne.n	12264 <_DNS_Resolve+0xb0>
        if((dnsHE->recordMask & recMask) == recMask)
   12214:	f894 202a 	ldrb.w	r2, [r4, #42]	; 0x2a
   12218:	ea33 0202 	bics.w	r2, r3, r2
   1221c:	d111      	bne.n	12242 <_DNS_Resolve+0x8e>
            if((dnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) != 0)
   1221e:	8823      	ldrh	r3, [r4, #0]
   12220:	f013 0f80 	tst.w	r3, #128	; 0x80
   12224:	d15a      	bne.n	122dc <_DNS_Resolve+0x128>
            return (dnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_TIMEOUT) == 0 ? TCPIP_DNS_RES_PENDING : TCPIP_DNS_RES_SERVER_TMO; 
   12226:	f403 7380 	and.w	r3, r3, #256	; 0x100
   1222a:	2b00      	cmp	r3, #0
   1222c:	bf0c      	ite	eq
   1222e:	2001      	moveq	r0, #1
   12230:	f06f 0004 	mvnne.w	r0, #4
   12234:	e03a      	b.n	122ac <_DNS_Resolve+0xf8>
        recMask = TCPIP_DNS_ADDRESS_REC_IPV4;
   12236:	4633      	mov	r3, r6
   12238:	e7e7      	b.n	1220a <_DNS_Resolve+0x56>
    if(dnsHE->hEntry.flags.newEntry != 0)
   1223a:	7822      	ldrb	r2, [r4, #0]
   1223c:	f012 0f02 	tst.w	r2, #2
   12240:	d110      	bne.n	12264 <_DNS_Resolve+0xb0>
        if((recMask & TCPIP_DNS_ADDRESS_REC_IPV4) != 0)
   12242:	f013 0f01 	tst.w	r3, #1
            dnsHE->nIPv4Entries = 0;
   12246:	bf1c      	itt	ne
   12248:	2200      	movne	r2, #0
   1224a:	f884 2026 	strbne.w	r2, [r4, #38]	; 0x26
        if((recMask & TCPIP_DNS_ADDRESS_REC_IPV6) != 0)
   1224e:	f013 0f02 	tst.w	r3, #2
            dnsHE->nIPv6Entries = 0;
   12252:	bf1c      	itt	ne
   12254:	2200      	movne	r2, #0
   12256:	f884 2027 	strbne.w	r2, [r4, #39]	; 0x27
        dnsHE->hEntry.flags.value &= ~TCPIP_DNS_FLAG_ENTRY_COMPLETE;
   1225a:	8822      	ldrh	r2, [r4, #0]
   1225c:	f022 0280 	bic.w	r2, r2, #128	; 0x80
   12260:	8022      	strh	r2, [r4, #0]
   12262:	e008      	b.n	12276 <_DNS_Resolve+0xc2>
        dnsHE->nIPv4Entries = 0;
   12264:	2200      	movs	r2, #0
   12266:	f884 2026 	strb.w	r2, [r4, #38]	; 0x26
        dnsHE->nIPv6Entries = 0;
   1226a:	f884 2027 	strb.w	r2, [r4, #39]	; 0x27
        dnsHE->hEntry.flags.value &= ~(TCPIP_DNS_FLAG_ENTRY_COMPLETE | TCPIP_DNS_FLAG_ENTRY_TIMEOUT);
   1226e:	8822      	ldrh	r2, [r4, #0]
   12270:	f422 72c0 	bic.w	r2, r2, #384	; 0x180
   12274:	8022      	strh	r2, [r4, #0]
    dnsHE->ipTTL.Val = 0;
   12276:	2200      	movs	r2, #0
   12278:	61a2      	str	r2, [r4, #24]
    dnsHE->resolve_type = type;
   1227a:	f884 6028 	strb.w	r6, [r4, #40]	; 0x28
    dnsHE->recordMask |= recMask;
   1227e:	f894 102a 	ldrb.w	r1, [r4, #42]	; 0x2a
   12282:	430b      	orrs	r3, r1
   12284:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
    dnsHE->tRetry = dnsHE->tInsert = pDnsDcpt->dnsTime;
   12288:	69eb      	ldr	r3, [r5, #28]
   1228a:	60a3      	str	r3, [r4, #8]
   1228c:	60e3      	str	r3, [r4, #12]
    dnsHE->currRetry = 0;
   1228e:	f884 202b 	strb.w	r2, [r4, #43]	; 0x2b
    int retryIfs = (pDnsDcpt->strictNet == 0) ? TCPIP_STACK_NumberOfNetworksGet() : 1;
   12292:	686b      	ldr	r3, [r5, #4]
   12294:	b163      	cbz	r3, 122b0 <_DNS_Resolve+0xfc>
   12296:	2001      	movs	r0, #1
    dnsHE->nRetries = retryIfs * _TCPIP_DNS_IF_RETRY_COUNT;
   12298:	0040      	lsls	r0, r0, #1
   1229a:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    pDnsDcpt->unsolvedEntries++;
   1229e:	8ceb      	ldrh	r3, [r5, #38]	; 0x26
   122a0:	3301      	adds	r3, #1
   122a2:	84eb      	strh	r3, [r5, #38]	; 0x26
    return _DNS_Send_Query(pDnsDcpt, dnsHE);
   122a4:	4621      	mov	r1, r4
   122a6:	4628      	mov	r0, r5
   122a8:	f7fa fb74 	bl	c994 <_DNS_Send_Query>
}
   122ac:	b005      	add	sp, #20
   122ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
    int retryIfs = (pDnsDcpt->strictNet == 0) ? TCPIP_STACK_NumberOfNetworksGet() : 1;
   122b0:	f00f fe28 	bl	21f04 <TCPIP_STACK_NumberOfNetworksGet>
   122b4:	e7f0      	b.n	12298 <_DNS_Resolve+0xe4>
        return TCPIP_DNS_RES_NO_SERVICE;
   122b6:	f06f 0005 	mvn.w	r0, #5
   122ba:	e7f7      	b.n	122ac <_DNS_Resolve+0xf8>
        return TCPIP_DNS_RES_INVALID_HOSTNAME; 
   122bc:	f06f 0008 	mvn.w	r0, #8
   122c0:	e7f4      	b.n	122ac <_DNS_Resolve+0xf8>
   122c2:	f06f 0008 	mvn.w	r0, #8
   122c6:	e7f1      	b.n	122ac <_DNS_Resolve+0xf8>
   122c8:	f06f 0008 	mvn.w	r0, #8
   122cc:	e7ee      	b.n	122ac <_DNS_Resolve+0xf8>
        return  TCPIP_DNS_RES_NAME_IS_IPADDRESS;
   122ce:	2002      	movs	r0, #2
   122d0:	e7ec      	b.n	122ac <_DNS_Resolve+0xf8>
   122d2:	2002      	movs	r0, #2
   122d4:	e7ea      	b.n	122ac <_DNS_Resolve+0xf8>
        return TCPIP_DNS_RES_CACHE_FULL; 
   122d6:	f06f 0007 	mvn.w	r0, #7
   122da:	e7e7      	b.n	122ac <_DNS_Resolve+0xf8>
               return TCPIP_DNS_RES_OK; 
   122dc:	2000      	movs	r0, #0
   122de:	e7e5      	b.n	122ac <_DNS_Resolve+0xf8>
   122e0:	2000e62c 	.word	0x2000e62c

Disassembly of section .text.SERCOM0_SPI_WriteRead%273:

000122e4 <SERCOM0_SPI_WriteRead>:
{
   122e4:	b430      	push	{r4, r5}
    if((((txSize > 0U) && (pTransmitData != NULL)) || ((rxSize > 0U) && (pReceiveData != NULL))) && (sercom0SPIObj.transferIsBusy == false))
   122e6:	460c      	mov	r4, r1
   122e8:	2900      	cmp	r1, #0
   122ea:	d04d      	beq.n	12388 <SERCOM0_SPI_WriteRead+0xa4>
   122ec:	2800      	cmp	r0, #0
   122ee:	d04b      	beq.n	12388 <SERCOM0_SPI_WriteRead+0xa4>
   122f0:	4946      	ldr	r1, [pc, #280]	; (1240c <SERCOM0_SPI_WriteRead+0x128>)
   122f2:	7f09      	ldrb	r1, [r1, #28]
   122f4:	2900      	cmp	r1, #0
   122f6:	f040 8086 	bne.w	12406 <SERCOM0_SPI_WriteRead+0x122>
        if((SERCOM0_REGS->SPIM.SERCOM_CTRLB & SERCOM_SPIM_CTRLB_CHSIZE_Msk) == (uint32_t)SPI_DATA_BITS_9)
   122fa:	4d45      	ldr	r5, [pc, #276]	; (12410 <SERCOM0_SPI_WriteRead+0x12c>)
   122fc:	686d      	ldr	r5, [r5, #4]
   122fe:	f005 0507 	and.w	r5, r5, #7
   12302:	2d01      	cmp	r5, #1
   12304:	d046      	beq.n	12394 <SERCOM0_SPI_WriteRead+0xb0>
        sercom0SPIObj.txBuffer = pTransmitData;
   12306:	4941      	ldr	r1, [pc, #260]	; (1240c <SERCOM0_SPI_WriteRead+0x128>)
   12308:	6008      	str	r0, [r1, #0]
        sercom0SPIObj.rxBuffer = pReceiveData;
   1230a:	604a      	str	r2, [r1, #4]
        sercom0SPIObj.rxCount = 0U;
   1230c:	2500      	movs	r5, #0
   1230e:	614d      	str	r5, [r1, #20]
        sercom0SPIObj.txCount = 0U;
   12310:	618d      	str	r5, [r1, #24]
        sercom0SPIObj.dummySize = 0U;
   12312:	610d      	str	r5, [r1, #16]
            sercom0SPIObj.txSize = 0U;
   12314:	42a8      	cmp	r0, r5
   12316:	bf08      	it	eq
   12318:	462c      	moveq	r4, r5
   1231a:	608c      	str	r4, [r1, #8]
            sercom0SPIObj.rxSize = 0U;
   1231c:	42aa      	cmp	r2, r5
   1231e:	bf18      	it	ne
   12320:	461d      	movne	r5, r3
   12322:	460a      	mov	r2, r1
   12324:	60cd      	str	r5, [r1, #12]
        sercom0SPIObj.transferIsBusy = true;
   12326:	2101      	movs	r1, #1
   12328:	7711      	strb	r1, [r2, #28]
        while((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_RXC_Msk) == SERCOM_SPIM_INTFLAG_RXC_Msk)
   1232a:	4a39      	ldr	r2, [pc, #228]	; (12410 <SERCOM0_SPI_WriteRead+0x12c>)
   1232c:	7e12      	ldrb	r2, [r2, #24]
   1232e:	f012 0f04 	tst.w	r2, #4
   12332:	d005      	beq.n	12340 <SERCOM0_SPI_WriteRead+0x5c>
            dummyData = SERCOM0_REGS->SPIM.SERCOM_DATA;
   12334:	4a36      	ldr	r2, [pc, #216]	; (12410 <SERCOM0_SPI_WriteRead+0x12c>)
   12336:	6a91      	ldr	r1, [r2, #40]	; 0x28
        while((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_RXC_Msk) == SERCOM_SPIM_INTFLAG_RXC_Msk)
   12338:	7e11      	ldrb	r1, [r2, #24]
   1233a:	f011 0f04 	tst.w	r1, #4
   1233e:	d1fa      	bne.n	12336 <SERCOM0_SPI_WriteRead+0x52>
        SERCOM0_REGS->SPIM.SERCOM_STATUS |= (uint16_t)SERCOM_SPIM_STATUS_BUFOVF_Msk;
   12340:	4a33      	ldr	r2, [pc, #204]	; (12410 <SERCOM0_SPI_WriteRead+0x12c>)
   12342:	8b51      	ldrh	r1, [r2, #26]
   12344:	f041 0104 	orr.w	r1, r1, #4
   12348:	8351      	strh	r1, [r2, #26]
        SERCOM0_REGS->SPIM.SERCOM_INTFLAG |= (uint8_t)SERCOM_SPIM_INTFLAG_ERROR_Msk;
   1234a:	7e11      	ldrb	r1, [r2, #24]
   1234c:	f041 0180 	orr.w	r1, r1, #128	; 0x80
   12350:	7611      	strb	r1, [r2, #24]
        if(sercom0SPIObj.rxSize > sercom0SPIObj.txSize)
   12352:	42a5      	cmp	r5, r4
   12354:	d902      	bls.n	1235c <SERCOM0_SPI_WriteRead+0x78>
            sercom0SPIObj.dummySize = sercom0SPIObj.rxSize - sercom0SPIObj.txSize;
   12356:	1b2a      	subs	r2, r5, r4
   12358:	492c      	ldr	r1, [pc, #176]	; (1240c <SERCOM0_SPI_WriteRead+0x128>)
   1235a:	610a      	str	r2, [r1, #16]
        if((SERCOM0_REGS->SPIM.SERCOM_CTRLB & SERCOM_SPIM_CTRLB_CHSIZE_Msk) == (uint32_t)SPI_DATA_BITS_8)
   1235c:	4a2c      	ldr	r2, [pc, #176]	; (12410 <SERCOM0_SPI_WriteRead+0x12c>)
   1235e:	6852      	ldr	r2, [r2, #4]
   12360:	f012 0f07 	tst.w	r2, #7
   12364:	d12b      	bne.n	123be <SERCOM0_SPI_WriteRead+0xda>
            if(sercom0SPIObj.txCount < sercom0SPIObj.txSize)
   12366:	4a29      	ldr	r2, [pc, #164]	; (1240c <SERCOM0_SPI_WriteRead+0x128>)
   12368:	6992      	ldr	r2, [r2, #24]
   1236a:	42a2      	cmp	r2, r4
   1236c:	d21c      	bcs.n	123a8 <SERCOM0_SPI_WriteRead+0xc4>
                SERCOM0_REGS->SPIM.SERCOM_DATA = *((uint8_t*)sercom0SPIObj.txBuffer);
   1236e:	7800      	ldrb	r0, [r0, #0]
   12370:	4927      	ldr	r1, [pc, #156]	; (12410 <SERCOM0_SPI_WriteRead+0x12c>)
   12372:	6288      	str	r0, [r1, #40]	; 0x28
                sercom0SPIObj.txCount++;
   12374:	3201      	adds	r2, #1
   12376:	4925      	ldr	r1, [pc, #148]	; (1240c <SERCOM0_SPI_WriteRead+0x128>)
   12378:	618a      	str	r2, [r1, #24]
        if(rxSize > 0U)
   1237a:	2b00      	cmp	r3, #0
   1237c:	d03b      	beq.n	123f6 <SERCOM0_SPI_WriteRead+0x112>
            SERCOM0_REGS->SPIM.SERCOM_INTENSET = (uint8_t)SERCOM_SPIM_INTENSET_RXC_Msk;
   1237e:	4b24      	ldr	r3, [pc, #144]	; (12410 <SERCOM0_SPI_WriteRead+0x12c>)
   12380:	2204      	movs	r2, #4
   12382:	759a      	strb	r2, [r3, #22]
        isRequestAccepted = true;
   12384:	2101      	movs	r1, #1
   12386:	e03b      	b.n	12400 <SERCOM0_SPI_WriteRead+0x11c>
    if((((txSize > 0U) && (pTransmitData != NULL)) || ((rxSize > 0U) && (pReceiveData != NULL))) && (sercom0SPIObj.transferIsBusy == false))
   12388:	2b00      	cmp	r3, #0
   1238a:	d038      	beq.n	123fe <SERCOM0_SPI_WriteRead+0x11a>
   1238c:	2a00      	cmp	r2, #0
   1238e:	d1af      	bne.n	122f0 <SERCOM0_SPI_WriteRead+0xc>
    bool isRequestAccepted = false;
   12390:	2100      	movs	r1, #0
   12392:	e035      	b.n	12400 <SERCOM0_SPI_WriteRead+0x11c>
            if(((txSize > 0U) && ((txSize & 0x01U) != 0U)) || ((rxSize > 0U) && ((rxSize & 0x01U) != 0U)))
   12394:	b114      	cbz	r4, 1239c <SERCOM0_SPI_WriteRead+0xb8>
   12396:	f014 0f01 	tst.w	r4, #1
   1239a:	d131      	bne.n	12400 <SERCOM0_SPI_WriteRead+0x11c>
   1239c:	2b00      	cmp	r3, #0
   1239e:	d0b2      	beq.n	12306 <SERCOM0_SPI_WriteRead+0x22>
   123a0:	f013 0f01 	tst.w	r3, #1
   123a4:	d0af      	beq.n	12306 <SERCOM0_SPI_WriteRead+0x22>
   123a6:	e02b      	b.n	12400 <SERCOM0_SPI_WriteRead+0x11c>
            else if(sercom0SPIObj.dummySize > 0U)
   123a8:	4a18      	ldr	r2, [pc, #96]	; (1240c <SERCOM0_SPI_WriteRead+0x128>)
   123aa:	6912      	ldr	r2, [r2, #16]
   123ac:	2a00      	cmp	r2, #0
   123ae:	d0e4      	beq.n	1237a <SERCOM0_SPI_WriteRead+0x96>
                SERCOM0_REGS->SPIM.SERCOM_DATA = 0xFFU;
   123b0:	4917      	ldr	r1, [pc, #92]	; (12410 <SERCOM0_SPI_WriteRead+0x12c>)
   123b2:	20ff      	movs	r0, #255	; 0xff
   123b4:	6288      	str	r0, [r1, #40]	; 0x28
                sercom0SPIObj.dummySize--;
   123b6:	3a01      	subs	r2, #1
   123b8:	4914      	ldr	r1, [pc, #80]	; (1240c <SERCOM0_SPI_WriteRead+0x128>)
   123ba:	610a      	str	r2, [r1, #16]
   123bc:	e7dd      	b.n	1237a <SERCOM0_SPI_WriteRead+0x96>
            sercom0SPIObj.txSize >>= 1U;
   123be:	0864      	lsrs	r4, r4, #1
   123c0:	4a12      	ldr	r2, [pc, #72]	; (1240c <SERCOM0_SPI_WriteRead+0x128>)
   123c2:	6094      	str	r4, [r2, #8]
            sercom0SPIObj.dummySize >>= 1U;
   123c4:	6911      	ldr	r1, [r2, #16]
   123c6:	0849      	lsrs	r1, r1, #1
   123c8:	6111      	str	r1, [r2, #16]
            sercom0SPIObj.rxSize >>= 1U;
   123ca:	086d      	lsrs	r5, r5, #1
   123cc:	60d5      	str	r5, [r2, #12]
            if(sercom0SPIObj.txCount < sercom0SPIObj.txSize)
   123ce:	6992      	ldr	r2, [r2, #24]
   123d0:	4294      	cmp	r4, r2
   123d2:	d906      	bls.n	123e2 <SERCOM0_SPI_WriteRead+0xfe>
                SERCOM0_REGS->SPIM.SERCOM_DATA = *((uint16_t*)sercom0SPIObj.txBuffer) & SERCOM_SPIM_DATA_Msk;
   123d4:	8800      	ldrh	r0, [r0, #0]
   123d6:	490e      	ldr	r1, [pc, #56]	; (12410 <SERCOM0_SPI_WriteRead+0x12c>)
   123d8:	6288      	str	r0, [r1, #40]	; 0x28
                sercom0SPIObj.txCount++;
   123da:	3201      	adds	r2, #1
   123dc:	490b      	ldr	r1, [pc, #44]	; (1240c <SERCOM0_SPI_WriteRead+0x128>)
   123de:	618a      	str	r2, [r1, #24]
   123e0:	e7cb      	b.n	1237a <SERCOM0_SPI_WriteRead+0x96>
            else if(sercom0SPIObj.dummySize > 0U)
   123e2:	2900      	cmp	r1, #0
   123e4:	d0c9      	beq.n	1237a <SERCOM0_SPI_WriteRead+0x96>
                SERCOM0_REGS->SPIM.SERCOM_DATA = 0xFFFFU & SERCOM_SPIM_DATA_Msk;
   123e6:	4a0a      	ldr	r2, [pc, #40]	; (12410 <SERCOM0_SPI_WriteRead+0x12c>)
   123e8:	f64f 70ff 	movw	r0, #65535	; 0xffff
   123ec:	6290      	str	r0, [r2, #40]	; 0x28
                sercom0SPIObj.dummySize--;
   123ee:	3901      	subs	r1, #1
   123f0:	4a06      	ldr	r2, [pc, #24]	; (1240c <SERCOM0_SPI_WriteRead+0x128>)
   123f2:	6111      	str	r1, [r2, #16]
   123f4:	e7c1      	b.n	1237a <SERCOM0_SPI_WriteRead+0x96>
            SERCOM0_REGS->SPIM.SERCOM_INTENSET = (uint8_t)SERCOM_SPIM_INTENSET_DRE_Msk;
   123f6:	2101      	movs	r1, #1
   123f8:	4b05      	ldr	r3, [pc, #20]	; (12410 <SERCOM0_SPI_WriteRead+0x12c>)
   123fa:	7599      	strb	r1, [r3, #22]
   123fc:	e000      	b.n	12400 <SERCOM0_SPI_WriteRead+0x11c>
    bool isRequestAccepted = false;
   123fe:	2100      	movs	r1, #0
}
   12400:	4608      	mov	r0, r1
   12402:	bc30      	pop	{r4, r5}
   12404:	4770      	bx	lr
    bool isRequestAccepted = false;
   12406:	2100      	movs	r1, #0
   12408:	e7fa      	b.n	12400 <SERCOM0_SPI_WriteRead+0x11c>
   1240a:	bf00      	nop
   1240c:	2000e29c 	.word	0x2000e29c
   12410:	40003000 	.word	0x40003000

Disassembly of section .text.__multiply%274:

00012414 <__multiply>:
   12414:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12418:	4615      	mov	r5, r2
   1241a:	690a      	ldr	r2, [r1, #16]
   1241c:	692b      	ldr	r3, [r5, #16]
   1241e:	429a      	cmp	r2, r3
   12420:	460c      	mov	r4, r1
   12422:	bfbc      	itt	lt
   12424:	462c      	movlt	r4, r5
   12426:	460d      	movlt	r5, r1
   12428:	f8d4 9010 	ldr.w	r9, [r4, #16]
   1242c:	f8d5 8010 	ldr.w	r8, [r5, #16]
   12430:	68a3      	ldr	r3, [r4, #8]
   12432:	6861      	ldr	r1, [r4, #4]
   12434:	eb09 0708 	add.w	r7, r9, r8
   12438:	42bb      	cmp	r3, r7
   1243a:	b085      	sub	sp, #20
   1243c:	bfb8      	it	lt
   1243e:	3101      	addlt	r1, #1
   12440:	f008 fc0c 	bl	1ac5c <_Balloc>
   12444:	f100 0614 	add.w	r6, r0, #20
   12448:	eb06 0e87 	add.w	lr, r6, r7, lsl #2
   1244c:	4633      	mov	r3, r6
   1244e:	2200      	movs	r2, #0
   12450:	4573      	cmp	r3, lr
   12452:	d319      	bcc.n	12488 <__multiply+0x74>
   12454:	f104 0314 	add.w	r3, r4, #20
   12458:	eb03 0389 	add.w	r3, r3, r9, lsl #2
   1245c:	f105 0214 	add.w	r2, r5, #20
   12460:	9300      	str	r3, [sp, #0]
   12462:	eb02 0388 	add.w	r3, r2, r8, lsl #2
   12466:	9301      	str	r3, [sp, #4]
   12468:	f64f 75ff 	movw	r5, #65535	; 0xffff
   1246c:	9b01      	ldr	r3, [sp, #4]
   1246e:	9202      	str	r2, [sp, #8]
   12470:	4293      	cmp	r3, r2
   12472:	d80c      	bhi.n	1248e <__multiply+0x7a>
   12474:	2f00      	cmp	r7, #0
   12476:	dd03      	ble.n	12480 <__multiply+0x6c>
   12478:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
   1247c:	2b00      	cmp	r3, #0
   1247e:	d05f      	beq.n	12540 <__multiply+0x12c>
   12480:	6107      	str	r7, [r0, #16]
   12482:	b005      	add	sp, #20
   12484:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12488:	f843 2b04 	str.w	r2, [r3], #4
   1248c:	e7e0      	b.n	12450 <__multiply+0x3c>
   1248e:	6813      	ldr	r3, [r2, #0]
   12490:	ea13 0c05 	ands.w	ip, r3, r5
   12494:	d027      	beq.n	124e6 <__multiply+0xd2>
   12496:	f104 0a14 	add.w	sl, r4, #20
   1249a:	46b0      	mov	r8, r6
   1249c:	f04f 0900 	mov.w	r9, #0
   124a0:	f85a 1b04 	ldr.w	r1, [sl], #4
   124a4:	ea01 0305 	and.w	r3, r1, r5
   124a8:	9303      	str	r3, [sp, #12]
   124aa:	f8d8 3000 	ldr.w	r3, [r8]
   124ae:	ea03 0b05 	and.w	fp, r3, r5
   124b2:	9b03      	ldr	r3, [sp, #12]
   124b4:	fb0c b303 	mla	r3, ip, r3, fp
   124b8:	ea4f 4b11 	mov.w	fp, r1, lsr #16
   124bc:	f8d8 1000 	ldr.w	r1, [r8]
   124c0:	444b      	add	r3, r9
   124c2:	ea4f 4911 	mov.w	r9, r1, lsr #16
   124c6:	fb0c 910b 	mla	r1, ip, fp, r9
   124ca:	eb01 4113 	add.w	r1, r1, r3, lsr #16
   124ce:	402b      	ands	r3, r5
   124d0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   124d4:	f848 3b04 	str.w	r3, [r8], #4
   124d8:	9b00      	ldr	r3, [sp, #0]
   124da:	4553      	cmp	r3, sl
   124dc:	ea4f 4911 	mov.w	r9, r1, lsr #16
   124e0:	d8de      	bhi.n	124a0 <__multiply+0x8c>
   124e2:	f8c8 9000 	str.w	r9, [r8]
   124e6:	9b02      	ldr	r3, [sp, #8]
   124e8:	f8b3 9002 	ldrh.w	r9, [r3, #2]
   124ec:	3204      	adds	r2, #4
   124ee:	f1b9 0f00 	cmp.w	r9, #0
   124f2:	d023      	beq.n	1253c <__multiply+0x128>
   124f4:	6833      	ldr	r3, [r6, #0]
   124f6:	f104 0814 	add.w	r8, r4, #20
   124fa:	46b4      	mov	ip, r6
   124fc:	f04f 0a00 	mov.w	sl, #0
   12500:	f8d8 1000 	ldr.w	r1, [r8]
   12504:	f8bc b002 	ldrh.w	fp, [ip, #2]
   12508:	4029      	ands	r1, r5
   1250a:	fb09 b101 	mla	r1, r9, r1, fp
   1250e:	448a      	add	sl, r1
   12510:	402b      	ands	r3, r5
   12512:	ea43 430a 	orr.w	r3, r3, sl, lsl #16
   12516:	f84c 3b04 	str.w	r3, [ip], #4
   1251a:	f858 3b04 	ldr.w	r3, [r8], #4
   1251e:	f8dc 1000 	ldr.w	r1, [ip]
   12522:	0c1b      	lsrs	r3, r3, #16
   12524:	4029      	ands	r1, r5
   12526:	fb09 1303 	mla	r3, r9, r3, r1
   1252a:	9900      	ldr	r1, [sp, #0]
   1252c:	eb03 431a 	add.w	r3, r3, sl, lsr #16
   12530:	4541      	cmp	r1, r8
   12532:	ea4f 4a13 	mov.w	sl, r3, lsr #16
   12536:	d8e3      	bhi.n	12500 <__multiply+0xec>
   12538:	f8cc 3000 	str.w	r3, [ip]
   1253c:	3604      	adds	r6, #4
   1253e:	e795      	b.n	1246c <__multiply+0x58>
   12540:	3f01      	subs	r7, #1
   12542:	e797      	b.n	12474 <__multiply+0x60>

Disassembly of section .text.quorem%275:

00012544 <quorem>:
   12544:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12548:	6903      	ldr	r3, [r0, #16]
   1254a:	690c      	ldr	r4, [r1, #16]
   1254c:	42a3      	cmp	r3, r4
   1254e:	4680      	mov	r8, r0
   12550:	f2c0 808d 	blt.w	1266e <quorem+0x12a>
   12554:	3c01      	subs	r4, #1
   12556:	f101 0714 	add.w	r7, r1, #20
   1255a:	ea4f 0c84 	mov.w	ip, r4, lsl #2
   1255e:	eb07 030c 	add.w	r3, r7, ip
   12562:	f100 0514 	add.w	r5, r0, #20
   12566:	9300      	str	r3, [sp, #0]
   12568:	eb05 030c 	add.w	r3, r5, ip
   1256c:	9301      	str	r3, [sp, #4]
   1256e:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
   12572:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
   12576:	3301      	adds	r3, #1
   12578:	429a      	cmp	r2, r3
   1257a:	fbb2 f6f3 	udiv	r6, r2, r3
   1257e:	d336      	bcc.n	125ee <quorem+0xaa>
   12580:	f04f 0a00 	mov.w	sl, #0
   12584:	46be      	mov	lr, r7
   12586:	46a9      	mov	r9, r5
   12588:	46d3      	mov	fp, sl
   1258a:	f64f 70ff 	movw	r0, #65535	; 0xffff
   1258e:	f85e 2b04 	ldr.w	r2, [lr], #4
   12592:	ea02 0300 	and.w	r3, r2, r0
   12596:	fb06 a303 	mla	r3, r6, r3, sl
   1259a:	ea4f 4a13 	mov.w	sl, r3, lsr #16
   1259e:	4003      	ands	r3, r0
   125a0:	ebab 0303 	sub.w	r3, fp, r3
   125a4:	0c12      	lsrs	r2, r2, #16
   125a6:	f8d9 b000 	ldr.w	fp, [r9]
   125aa:	fb06 a202 	mla	r2, r6, r2, sl
   125ae:	fa13 f38b 	uxtah	r3, r3, fp
   125b2:	ea4f 4a12 	mov.w	sl, r2, lsr #16
   125b6:	ea02 0b00 	and.w	fp, r2, r0
   125ba:	f8d9 2000 	ldr.w	r2, [r9]
   125be:	ebcb 4212 	rsb	r2, fp, r2, lsr #16
   125c2:	eb02 4223 	add.w	r2, r2, r3, asr #16
   125c6:	4003      	ands	r3, r0
   125c8:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   125cc:	f849 3b04 	str.w	r3, [r9], #4
   125d0:	9b00      	ldr	r3, [sp, #0]
   125d2:	4573      	cmp	r3, lr
   125d4:	ea4f 4b22 	mov.w	fp, r2, asr #16
   125d8:	d2d9      	bcs.n	1258e <quorem+0x4a>
   125da:	f855 300c 	ldr.w	r3, [r5, ip]
   125de:	b933      	cbnz	r3, 125ee <quorem+0xaa>
   125e0:	9b01      	ldr	r3, [sp, #4]
   125e2:	3b04      	subs	r3, #4
   125e4:	429d      	cmp	r5, r3
   125e6:	461a      	mov	r2, r3
   125e8:	d335      	bcc.n	12656 <quorem+0x112>
   125ea:	f8c8 4010 	str.w	r4, [r8, #16]
   125ee:	4640      	mov	r0, r8
   125f0:	f00c fb88 	bl	1ed04 <__mcmp>
   125f4:	2800      	cmp	r0, #0
   125f6:	db2a      	blt.n	1264e <quorem+0x10a>
   125f8:	3601      	adds	r6, #1
   125fa:	4628      	mov	r0, r5
   125fc:	f04f 0e00 	mov.w	lr, #0
   12600:	f64f 7cff 	movw	ip, #65535	; 0xffff
   12604:	f857 2b04 	ldr.w	r2, [r7], #4
   12608:	f8d0 9000 	ldr.w	r9, [r0]
   1260c:	ea02 030c 	and.w	r3, r2, ip
   12610:	ebae 0303 	sub.w	r3, lr, r3
   12614:	0c12      	lsrs	r2, r2, #16
   12616:	fa13 f389 	uxtah	r3, r3, r9
   1261a:	ebc2 4219 	rsb	r2, r2, r9, lsr #16
   1261e:	eb02 4223 	add.w	r2, r2, r3, asr #16
   12622:	ea03 030c 	and.w	r3, r3, ip
   12626:	ea4f 4e22 	mov.w	lr, r2, asr #16
   1262a:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
   1262e:	9b00      	ldr	r3, [sp, #0]
   12630:	f840 2b04 	str.w	r2, [r0], #4
   12634:	42bb      	cmp	r3, r7
   12636:	d2e5      	bcs.n	12604 <quorem+0xc0>
   12638:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
   1263c:	eb05 0384 	add.w	r3, r5, r4, lsl #2
   12640:	b92a      	cbnz	r2, 1264e <quorem+0x10a>
   12642:	3b04      	subs	r3, #4
   12644:	429d      	cmp	r5, r3
   12646:	461a      	mov	r2, r3
   12648:	d30b      	bcc.n	12662 <quorem+0x11e>
   1264a:	f8c8 4010 	str.w	r4, [r8, #16]
   1264e:	4630      	mov	r0, r6
   12650:	b003      	add	sp, #12
   12652:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12656:	6812      	ldr	r2, [r2, #0]
   12658:	3b04      	subs	r3, #4
   1265a:	2a00      	cmp	r2, #0
   1265c:	d1c5      	bne.n	125ea <quorem+0xa6>
   1265e:	3c01      	subs	r4, #1
   12660:	e7c0      	b.n	125e4 <quorem+0xa0>
   12662:	6812      	ldr	r2, [r2, #0]
   12664:	3b04      	subs	r3, #4
   12666:	2a00      	cmp	r2, #0
   12668:	d1ef      	bne.n	1264a <quorem+0x106>
   1266a:	3c01      	subs	r4, #1
   1266c:	e7ea      	b.n	12644 <quorem+0x100>
   1266e:	2000      	movs	r0, #0
   12670:	e7ee      	b.n	12650 <quorem+0x10c>

Disassembly of section .text.TCPIP_IPV4_Initialize%276:

00012674 <TCPIP_IPV4_Initialize>:
{
   12674:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(stackInit->stackAction == TCPIP_STACK_ACTION_IF_UP)
   12676:	7f03      	ldrb	r3, [r0, #28]
   12678:	2b03      	cmp	r3, #3
   1267a:	d076      	beq.n	1276a <TCPIP_IPV4_Initialize+0xf6>
    if(ipv4InitCount == 0)
   1267c:	4b3c      	ldr	r3, [pc, #240]	; (12770 <TCPIP_IPV4_Initialize+0xfc>)
   1267e:	881b      	ldrh	r3, [r3, #0]
   12680:	b12b      	cbz	r3, 1268e <TCPIP_IPV4_Initialize+0x1a>
    ipv4InitCount++;
   12682:	4a3b      	ldr	r2, [pc, #236]	; (12770 <TCPIP_IPV4_Initialize+0xfc>)
   12684:	8813      	ldrh	r3, [r2, #0]
   12686:	3301      	adds	r3, #1
   12688:	8013      	strh	r3, [r2, #0]
    return true;
   1268a:	2001      	movs	r0, #1
}
   1268c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1268e:	460c      	mov	r4, r1
            ipv4MemH = stackInit->memH;
   12690:	68c2      	ldr	r2, [r0, #12]
   12692:	4b38      	ldr	r3, [pc, #224]	; (12774 <TCPIP_IPV4_Initialize+0x100>)
   12694:	601a      	str	r2, [r3, #0]
            ipv4ArpHandle = 0;
   12696:	2300      	movs	r3, #0
   12698:	4a37      	ldr	r2, [pc, #220]	; (12778 <TCPIP_IPV4_Initialize+0x104>)
   1269a:	6013      	str	r3, [r2, #0]
            signalHandle = 0;
   1269c:	4a37      	ldr	r2, [pc, #220]	; (1277c <TCPIP_IPV4_Initialize+0x108>)
   1269e:	6013      	str	r3, [r2, #0]
            memset(&ipv4ArpQueue, 0, sizeof(ipv4ArpQueue));
   126a0:	4a37      	ldr	r2, [pc, #220]	; (12780 <TCPIP_IPV4_Initialize+0x10c>)
   126a2:	6013      	str	r3, [r2, #0]
   126a4:	6053      	str	r3, [r2, #4]
   126a6:	6093      	str	r3, [r2, #8]
   126a8:	60d3      	str	r3, [r2, #12]
   126aa:	6113      	str	r3, [r2, #16]
            memset(&ipv4ArpPool, 0, sizeof(ipv4ArpPool));
   126ac:	4a35      	ldr	r2, [pc, #212]	; (12784 <TCPIP_IPV4_Initialize+0x110>)
   126ae:	6013      	str	r3, [r2, #0]
   126b0:	6053      	str	r3, [r2, #4]
   126b2:	6093      	str	r3, [r2, #8]
            ipv4ArpEntries = 0;
   126b4:	4a34      	ldr	r2, [pc, #208]	; (12788 <TCPIP_IPV4_Initialize+0x114>)
   126b6:	6013      	str	r3, [r2, #0]
            memset(&ipv4PacketFilters, 0, sizeof(ipv4PacketFilters));
   126b8:	4a34      	ldr	r2, [pc, #208]	; (1278c <TCPIP_IPV4_Initialize+0x118>)
   126ba:	6013      	str	r3, [r2, #0]
   126bc:	6053      	str	r3, [r2, #4]
   126be:	6093      	str	r3, [r2, #8]
   126c0:	60d3      	str	r3, [r2, #12]
   126c2:	6113      	str	r3, [r2, #16]
            ipv4ActFilterCount = 0;
   126c4:	4a32      	ldr	r2, [pc, #200]	; (12790 <TCPIP_IPV4_Initialize+0x11c>)
   126c6:	6013      	str	r3, [r2, #0]
            if(pIpInit == 0 || pIpInit->arpEntries == 0)
   126c8:	2900      	cmp	r1, #0
   126ca:	d03b      	beq.n	12744 <TCPIP_IPV4_Initialize+0xd0>
   126cc:	680b      	ldr	r3, [r1, #0]
   126ce:	b94b      	cbnz	r3, 126e4 <TCPIP_IPV4_Initialize+0x70>
                iniRes = TCPIP_IPV4_RES_INIT_VAL_ERR;
   126d0:	f04f 34ff 	mov.w	r4, #4294967295
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, "IPv4 Init: Failed to initalize: %d! \r\n", iniRes);
   126d4:	f00f fc3a 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
   126d8:	2800      	cmp	r0, #0
   126da:	d13f      	bne.n	1275c <TCPIP_IPV4_Initialize+0xe8>
            TCPIP_IPV4_Cleanup();
   126dc:	f007 fdb6 	bl	1a24c <TCPIP_IPV4_Cleanup>
            return false;
   126e0:	2000      	movs	r0, #0
   126e2:	e7d3      	b.n	1268c <TCPIP_IPV4_Initialize+0x18>
            signalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_IPV4_Task, 0);
   126e4:	2200      	movs	r2, #0
   126e6:	492b      	ldr	r1, [pc, #172]	; (12794 <TCPIP_IPV4_Initialize+0x120>)
   126e8:	2003      	movs	r0, #3
   126ea:	f00a fad1 	bl	1cc90 <_TCPIPStackSignalHandlerRegister>
   126ee:	4b23      	ldr	r3, [pc, #140]	; (1277c <TCPIP_IPV4_Initialize+0x108>)
   126f0:	6018      	str	r0, [r3, #0]
            if(signalHandle == 0)
   126f2:	b350      	cbz	r0, 1274a <TCPIP_IPV4_Initialize+0xd6>
            if(!TCPIP_Helper_ProtectedSingleListInitialize (&ipv4ArpQueue))
   126f4:	4822      	ldr	r0, [pc, #136]	; (12780 <TCPIP_IPV4_Initialize+0x10c>)
   126f6:	f00d ffc6 	bl	20686 <TCPIP_Helper_ProtectedSingleListInitialize>
   126fa:	b910      	cbnz	r0, 12702 <TCPIP_IPV4_Initialize+0x8e>
                iniRes = TCPIP_IPV4_RES_ARP_ERR;
   126fc:	f06f 0402 	mvn.w	r4, #2
   12700:	e7e8      	b.n	126d4 <TCPIP_IPV4_Initialize+0x60>
            if(!TCPIP_Notification_Initialize(&ipv4PacketFilters))
   12702:	4822      	ldr	r0, [pc, #136]	; (1278c <TCPIP_IPV4_Initialize+0x118>)
   12704:	f00f fcb5 	bl	22072 <TCPIP_Notification_Initialize>
   12708:	b310      	cbz	r0, 12750 <TCPIP_IPV4_Initialize+0xdc>
            ipv4ArpEntries = (IPV4_ARP_ENTRY*)TCPIP_HEAP_Calloc(ipv4MemH, pIpInit->arpEntries , sizeof(*ipv4ArpEntries));
   1270a:	4b1a      	ldr	r3, [pc, #104]	; (12774 <TCPIP_IPV4_Initialize+0x100>)
   1270c:	6818      	ldr	r0, [r3, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Calloc)(h, nElems, elemSize);
   1270e:	6883      	ldr	r3, [r0, #8]
   12710:	2210      	movs	r2, #16
   12712:	6821      	ldr	r1, [r4, #0]
   12714:	4798      	blx	r3
   12716:	4b1c      	ldr	r3, [pc, #112]	; (12788 <TCPIP_IPV4_Initialize+0x114>)
   12718:	6018      	str	r0, [r3, #0]
            if(ipv4ArpEntries == 0)
   1271a:	b1e0      	cbz	r0, 12756 <TCPIP_IPV4_Initialize+0xe2>
            TCPIP_Helper_SingleListInitialize(&ipv4ArpPool);
   1271c:	4819      	ldr	r0, [pc, #100]	; (12784 <TCPIP_IPV4_Initialize+0x110>)
   1271e:	f00f fc6f 	bl	22000 <TCPIP_Helper_SingleListInitialize>
            pEntry = ipv4ArpEntries;
   12722:	4b19      	ldr	r3, [pc, #100]	; (12788 <TCPIP_IPV4_Initialize+0x114>)
   12724:	681d      	ldr	r5, [r3, #0]
            for(ix = 0; ix < pIpInit->arpEntries; ix++, pEntry++)
   12726:	6823      	ldr	r3, [r4, #0]
   12728:	2b00      	cmp	r3, #0
   1272a:	d0aa      	beq.n	12682 <TCPIP_IPV4_Initialize+0xe>
   1272c:	2600      	movs	r6, #0
                TCPIP_Helper_SingleListTailAdd(&ipv4ArpPool, (SGL_LIST_NODE*)pEntry); 
   1272e:	4f15      	ldr	r7, [pc, #84]	; (12784 <TCPIP_IPV4_Initialize+0x110>)
   12730:	4629      	mov	r1, r5
   12732:	4638      	mov	r0, r7
   12734:	f00e fd34 	bl	211a0 <TCPIP_Helper_SingleListTailAdd>
            for(ix = 0; ix < pIpInit->arpEntries; ix++, pEntry++)
   12738:	3601      	adds	r6, #1
   1273a:	3510      	adds	r5, #16
   1273c:	6823      	ldr	r3, [r4, #0]
   1273e:	42b3      	cmp	r3, r6
   12740:	d8f6      	bhi.n	12730 <TCPIP_IPV4_Initialize+0xbc>
   12742:	e79e      	b.n	12682 <TCPIP_IPV4_Initialize+0xe>
                iniRes = TCPIP_IPV4_RES_INIT_VAL_ERR;
   12744:	f04f 34ff 	mov.w	r4, #4294967295
   12748:	e7c4      	b.n	126d4 <TCPIP_IPV4_Initialize+0x60>
                iniRes = TCPIP_IPV4_RES_SIGNAL_ERR;
   1274a:	f06f 0401 	mvn.w	r4, #1
   1274e:	e7c1      	b.n	126d4 <TCPIP_IPV4_Initialize+0x60>
                iniRes = TCPIP_IPV4_RES_NOTIFY_ERR;
   12750:	f06f 0403 	mvn.w	r4, #3
   12754:	e7be      	b.n	126d4 <TCPIP_IPV4_Initialize+0x60>
                iniRes = TCPIP_IPV4_RES_MEM_ERR;
   12756:	f06f 0404 	mvn.w	r4, #4
   1275a:	e7bb      	b.n	126d4 <TCPIP_IPV4_Initialize+0x60>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, "IPv4 Init: Failed to initalize: %d! \r\n", iniRes);
   1275c:	f00f fbf0 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
   12760:	4622      	mov	r2, r4
   12762:	490d      	ldr	r1, [pc, #52]	; (12798 <TCPIP_IPV4_Initialize+0x124>)
   12764:	f008 f802 	bl	1a76c <SYS_CONSOLE_Print>
   12768:	e7b8      	b.n	126dc <TCPIP_IPV4_Initialize+0x68>
        return true;
   1276a:	2001      	movs	r0, #1
   1276c:	e78e      	b.n	1268c <TCPIP_IPV4_Initialize+0x18>
   1276e:	bf00      	nop
   12770:	2000e71c 	.word	0x2000e71c
   12774:	2000e608 	.word	0x2000e608
   12778:	2000e604 	.word	0x2000e604
   1277c:	2000e60c 	.word	0x2000e60c
   12780:	2000e428 	.word	0x2000e428
   12784:	2000e528 	.word	0x2000e528
   12788:	2000e600 	.word	0x2000e600
   1278c:	2000e43c 	.word	0x2000e43c
   12790:	2000e5fc 	.word	0x2000e5fc
   12794:	0000da61 	.word	0x0000da61
   12798:	000199a8 	.word	0x000199a8

Disassembly of section .text.TCPIP_UDP_OptionsGet%277:

0001279c <TCPIP_UDP_OptionsGet>:

// Allows getting options to a socket like enable broadcast, Rx/Tx buffer size, etc
bool TCPIP_UDP_OptionsGet(UDP_SOCKET hUDP, UDP_SOCKET_OPTION option, void* optParam)
{
   1279c:	b538      	push	{r3, r4, r5, lr}
   1279e:	460d      	mov	r5, r1
   127a0:	4614      	mov	r4, r2
    UDP_SOCKET_DCPT *pSkt = _UDPSocketDcpt(hUDP);
   127a2:	f00d fb9f 	bl	1fee4 <_UDPSocketDcpt>

    if(pSkt && optParam)
   127a6:	2800      	cmp	r0, #0
   127a8:	f000 8086 	beq.w	128b8 <TCPIP_UDP_OptionsGet+0x11c>
   127ac:	2c00      	cmp	r4, #0
   127ae:	f000 8085 	beq.w	128bc <TCPIP_UDP_OptionsGet+0x120>
    {
        switch(option)
   127b2:	2d0c      	cmp	r5, #12
   127b4:	f200 8084 	bhi.w	128c0 <TCPIP_UDP_OptionsGet+0x124>
   127b8:	e8df f005 	tbb	[pc, r5]
   127bc:	22191007 	.word	0x22191007
   127c0:	39343029 	.word	0x39343029
   127c4:	704a453e 	.word	0x704a453e
   127c8:	77          	.byte	0x77
   127c9:	00          	.byte	0x00
        {
            case UDP_OPTION_STRICT_PORT:
                *(bool*)optParam = pSkt->flags.looseRemPort == 0;
   127ca:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   127ce:	f083 0304 	eor.w	r3, r3, #4
   127d2:	f3c3 0380 	ubfx	r3, r3, #2, #1
   127d6:	7023      	strb	r3, [r4, #0]
                return true;
   127d8:	2001      	movs	r0, #1
   127da:	e06e      	b.n	128ba <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_STRICT_NET:
                *(bool*)optParam = pSkt->flags.looseNetIf == 0;
   127dc:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   127e0:	f083 0308 	eor.w	r3, r3, #8
   127e4:	f3c3 03c0 	ubfx	r3, r3, #3, #1
   127e8:	7023      	strb	r3, [r4, #0]
                return true;
   127ea:	2001      	movs	r0, #1
   127ec:	e065      	b.n	128ba <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_STRICT_ADDRESS:
                *(bool*)optParam = pSkt->flags.looseRemAddress == 0;
   127ee:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   127f2:	f083 0310 	eor.w	r3, r3, #16
   127f6:	f3c3 1300 	ubfx	r3, r3, #4, #1
   127fa:	7023      	strb	r3, [r4, #0]
                return true;
   127fc:	2001      	movs	r0, #1
   127fe:	e05c      	b.n	128ba <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_BROADCAST:
                *(UDP_SOCKET_BCAST_TYPE*)optParam = (UDP_SOCKET_BCAST_TYPE)pSkt->flags.bcastForceType;
   12800:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   12804:	f3c3 0301 	ubfx	r3, r3, #0, #2
   12808:	7023      	strb	r3, [r4, #0]
                return true;
   1280a:	2001      	movs	r0, #1
   1280c:	e055      	b.n	128ba <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_BUFFER_POOL:
                *(bool*)optParam = pSkt->flags.usePool != 0;
   1280e:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
   12812:	f3c3 0380 	ubfx	r3, r3, #2, #1
   12816:	7023      	strb	r3, [r4, #0]
                return true;
   12818:	2001      	movs	r0, #1
   1281a:	e04e      	b.n	128ba <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_TX_BUFF:
                *(uint16_t*)optParam = pSkt->txSize;
   1281c:	8a03      	ldrh	r3, [r0, #16]
   1281e:	8023      	strh	r3, [r4, #0]
                return true;
   12820:	2001      	movs	r0, #1
   12822:	e04a      	b.n	128ba <TCPIP_UDP_OptionsGet+0x11e>
                
            case UDP_OPTION_TX_QUEUE_LIMIT:
                *(uint8_t*)optParam = pSkt->txAllocLimit;
   12824:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
   12828:	7023      	strb	r3, [r4, #0]
                return true;
   1282a:	2001      	movs	r0, #1
   1282c:	e045      	b.n	128ba <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_RX_QUEUE_LIMIT:
                *(uint8_t*)optParam = pSkt->rxQueueLimit;
   1282e:	f890 305a 	ldrb.w	r3, [r0, #90]	; 0x5a
   12832:	7023      	strb	r3, [r4, #0]
                return true;
   12834:	2001      	movs	r0, #1
   12836:	e040      	b.n	128ba <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_RX_AUTO_ADVANCE:
                *(bool*)optParam = pSkt->extFlags.rxAutoAdvance != 0;
   12838:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   1283c:	f003 0301 	and.w	r3, r3, #1
   12840:	7023      	strb	r3, [r4, #0]
                return true;
   12842:	2001      	movs	r0, #1
   12844:	e039      	b.n	128ba <TCPIP_UDP_OptionsGet+0x11e>

            case UDP_OPTION_TX_TTL:
                *(uint8_t*)optParam = pSkt->ttl;
   12846:	f890 305b 	ldrb.w	r3, [r0, #91]	; 0x5b
   1284a:	7023      	strb	r3, [r4, #0]
                return true;
   1284c:	2001      	movs	r0, #1
   1284e:	e034      	b.n	128ba <TCPIP_UDP_OptionsGet+0x11e>
                    UDP_MULTICAST_FLAGS* pMcFlags = (UDP_MULTICAST_FLAGS*)optParam;
                    if(pMcFlags!= 0)
                    {
                        UDP_MULTICAST_FLAGS mcFlags = 0;

                        if(pSkt->flags.looseNetIf == 1 && pSkt->flags.looseRemAddress == 1 && pSkt->flags.looseRemPort == 1)
   12850:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
   12854:	f002 021c 	and.w	r2, r2, #28
                        UDP_MULTICAST_FLAGS mcFlags = 0;
   12858:	2a1c      	cmp	r2, #28
   1285a:	bf14      	ite	ne
   1285c:	2200      	movne	r2, #0
   1285e:	2201      	moveq	r2, #1
                        {
                            mcFlags |= UDP_MCAST_FLAG_LOOSE_NET_SOURCE_PORT;
                        }
                        if(pSkt->extFlags.ignoreSrcAdd != 0)
   12860:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   12864:	f013 0f10 	tst.w	r3, #16
                        {
                            mcFlags |= UDP_MCAST_FLAG_IGNORE_SOURCE_ADD;
   12868:	bf18      	it	ne
   1286a:	f042 0202 	orrne.w	r2, r2, #2
                        }
                        if(pSkt->extFlags.ignoreSrcPort != 0)
   1286e:	f013 0f20 	tst.w	r3, #32
                        {
                            mcFlags |= UDP_MCAST_FLAG_IGNORE_SOURCE_PORT;
   12872:	bf18      	it	ne
   12874:	f042 0204 	orrne.w	r2, r2, #4
                        }
                        if(pSkt->extFlags.mcastOnly != 0)
   12878:	f013 0f40 	tst.w	r3, #64	; 0x40
                        {
                            mcFlags |= UDP_MCAST_FLAG_IGNORE_UNICAST;
   1287c:	bf18      	it	ne
   1287e:	f042 0208 	orrne.w	r2, r2, #8
                        }
                        if(pSkt->extFlags.mcastLoop != 0)
   12882:	f013 0f04 	tst.w	r3, #4
                        {
                            mcFlags |= UDP_MCAST_FLAG_LOOP;
   12886:	bf18      	it	ne
   12888:	f042 0210 	orrne.w	r2, r2, #16
                        }
                        if(pSkt->extFlags.mcastSkipCheck != 0)
   1288c:	f013 0f08 	tst.w	r3, #8
                        {
                            mcFlags |= UDP_MCAST_FLAG_DISABLE_SOURCE_CHECK;
   12890:	bf18      	it	ne
   12892:	f042 0220 	orrne.w	r2, r2, #32
                        }

                        *pMcFlags = mcFlags;
   12896:	7022      	strb	r2, [r4, #0]
                        return true;
   12898:	2001      	movs	r0, #1
   1289a:	e00e      	b.n	128ba <TCPIP_UDP_OptionsGet+0x11e>
                }

                return false;

             case UDP_OPTION_TOS:
                *(uint8_t*)optParam = pSkt->extFlags.tos;
   1289c:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
   128a0:	f3c3 0305 	ubfx	r3, r3, #0, #6
   128a4:	7023      	strb	r3, [r4, #0]
                return true;
   128a6:	2001      	movs	r0, #1
   128a8:	e007      	b.n	128ba <TCPIP_UDP_OptionsGet+0x11e>
                
             case UDP_OPTION_DF:
                *(bool*)optParam = pSkt->extFlags.df != 0;
   128aa:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
   128ae:	f3c3 1380 	ubfx	r3, r3, #6, #1
   128b2:	7023      	strb	r3, [r4, #0]
                return true;
   128b4:	2001      	movs	r0, #1
   128b6:	e000      	b.n	128ba <TCPIP_UDP_OptionsGet+0x11e>
           default:
                break;
        }
    }    

    return false;
   128b8:	2000      	movs	r0, #0
}
   128ba:	bd38      	pop	{r3, r4, r5, pc}
    return false;
   128bc:	2000      	movs	r0, #0
   128be:	e7fc      	b.n	128ba <TCPIP_UDP_OptionsGet+0x11e>
   128c0:	2000      	movs	r0, #0
   128c2:	e7fa      	b.n	128ba <TCPIP_UDP_OptionsGet+0x11e>

Disassembly of section .text.TCPIP_UDP_Bind%278:

000128c4 <TCPIP_UDP_Bind>:
{
   128c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   128c8:	460d      	mov	r5, r1
   128ca:	4616      	mov	r6, r2
   128cc:	461f      	mov	r7, r3
    pSkt = _UDPSocketDcpt(s);
   128ce:	f00d fb09 	bl	1fee4 <_UDPSocketDcpt>
    if(pSkt == 0)
   128d2:	2800      	cmp	r0, #0
   128d4:	d07d      	beq.n	129d2 <TCPIP_UDP_Bind+0x10e>
   128d6:	4604      	mov	r4, r0
    oldAddType = pSkt->addType;
   128d8:	f8b0 803c 	ldrh.w	r8, [r0, #60]	; 0x3c
   128dc:	fa5f f288 	uxtb.w	r2, r8
    if(addType == IP_ADDRESS_TYPE_ANY)
   128e0:	bb65      	cbnz	r5, 1293c <TCPIP_UDP_Bind+0x78>
        if(oldAddType != IP_ADDRESS_TYPE_ANY)
   128e2:	2a00      	cmp	r2, #0
   128e4:	d177      	bne.n	129d6 <TCPIP_UDP_Bind+0x112>
        localAddress = 0;
   128e6:	2700      	movs	r7, #0
    pSktIf = 0;
   128e8:	46ba      	mov	sl, r7
    OSAL_SEM_Pend(&userSem, OSAL_WAIT_FOREVER);
   128ea:	f64f 71ff 	movw	r1, #65535	; 0xffff
   128ee:	483d      	ldr	r0, [pc, #244]	; (129e4 <TCPIP_UDP_Bind+0x120>)
   128f0:	f00e f9c8 	bl	20c84 <OSAL_SEM_Pend>
    if(localPort == 0)
   128f4:	2e00      	cmp	r6, #0
   128f6:	d146      	bne.n	12986 <TCPIP_UDP_Bind+0xc2>
        if((localPort = pSkt->localPort) == 0)
   128f8:	8d66      	ldrh	r6, [r4, #42]	; 0x2a
   128fa:	2e00      	cmp	r6, #0
   128fc:	d03b      	beq.n	12976 <TCPIP_UDP_Bind+0xb2>
    OSAL_SEM_Post(&userSem);
   128fe:	4839      	ldr	r0, [pc, #228]	; (129e4 <TCPIP_UDP_Bind+0x120>)
   12900:	f00e fdd8 	bl	214b4 <OSAL_SEM_Post>
    pSkt->extFlags.rxEnable = 0;
   12904:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   12908:	f36f 0341 	bfc	r3, #1, #1
   1290c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    pSkt->addType = addType;
   12910:	87a5      	strh	r5, [r4, #60]	; 0x3c
    if((pSkt->pSktNet = pNet) != 0)
   12912:	f8c4 a024 	str.w	sl, [r4, #36]	; 0x24
   12916:	f1ba 0f00 	cmp.w	sl, #0
   1291a:	d005      	beq.n	12928 <TCPIP_UDP_Bind+0x64>
        pSkt->flags.looseNetIf = 0;
   1291c:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
   12920:	f36f 03c3 	bfc	r3, #3, #1
   12924:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    if(localAddress == 0)
   12928:	2f00      	cmp	r7, #0
   1292a:	d049      	beq.n	129c0 <TCPIP_UDP_Bind+0xfc>
        if (addType == IP_ADDRESS_TYPE_IPV4)
   1292c:	2d01      	cmp	r5, #1
   1292e:	d03d      	beq.n	129ac <TCPIP_UDP_Bind+0xe8>
        pSkt->addType = oldAddType;
   12930:	fa5f f888 	uxtb.w	r8, r8
   12934:	f8a4 803c 	strh.w	r8, [r4, #60]	; 0x3c
    bindSuccess = _UDPSocketBind(pSkt, pSktIf, localAddress);
   12938:	2000      	movs	r0, #0
   1293a:	e043      	b.n	129c4 <TCPIP_UDP_Bind+0x100>
        if(addType != IP_ADDRESS_TYPE_IPV4 && addType != IP_ADDRESS_TYPE_IPV6) 
   1293c:	1e6b      	subs	r3, r5, #1
   1293e:	b2db      	uxtb	r3, r3
   12940:	2b01      	cmp	r3, #1
   12942:	d84a      	bhi.n	129da <TCPIP_UDP_Bind+0x116>
        if(oldAddType != IP_ADDRESS_TYPE_ANY && oldAddType != addType)
   12944:	b10a      	cbz	r2, 1294a <TCPIP_UDP_Bind+0x86>
   12946:	42aa      	cmp	r2, r5
   12948:	d149      	bne.n	129de <TCPIP_UDP_Bind+0x11a>
    if(localAddress != 0)
   1294a:	b197      	cbz	r7, 12972 <TCPIP_UDP_Bind+0xae>
        if (addType == IP_ADDRESS_TYPE_IPV4 && localAddress->v4Add.Val != 0)
   1294c:	2d01      	cmp	r5, #1
   1294e:	d002      	beq.n	12956 <TCPIP_UDP_Bind+0x92>
    pSktIf = 0;
   12950:	f04f 0a00 	mov.w	sl, #0
   12954:	e7c9      	b.n	128ea <TCPIP_UDP_Bind+0x26>
        if (addType == IP_ADDRESS_TYPE_IPV4 && localAddress->v4Add.Val != 0)
   12956:	683b      	ldr	r3, [r7, #0]
   12958:	b913      	cbnz	r3, 12960 <TCPIP_UDP_Bind+0x9c>
    pSktIf = 0;
   1295a:	f04f 0a00 	mov.w	sl, #0
   1295e:	e7c4      	b.n	128ea <TCPIP_UDP_Bind+0x26>
            if((pSktIf = TCPIP_STACK_IPAddToNet(&localAddress->v4Add, false)) == 0)
   12960:	2100      	movs	r1, #0
   12962:	4638      	mov	r0, r7
   12964:	f00d fd36 	bl	203d4 <TCPIP_STACK_IPAddToNet>
   12968:	4682      	mov	sl, r0
   1296a:	2800      	cmp	r0, #0
   1296c:	d1bd      	bne.n	128ea <TCPIP_UDP_Bind+0x26>
                return false;
   1296e:	2000      	movs	r0, #0
   12970:	e01a      	b.n	129a8 <TCPIP_UDP_Bind+0xe4>
    pSktIf = 0;
   12972:	46ba      	mov	sl, r7
   12974:	e7b9      	b.n	128ea <TCPIP_UDP_Bind+0x26>
            localPort = _UDPAllocateEphemeralPort();
   12976:	f00b fe0d 	bl	1e594 <_UDPAllocateEphemeralPort>
            if(localPort == 0)
   1297a:	4606      	mov	r6, r0
   1297c:	fab0 f980 	clz	r9, r0
   12980:	ea4f 1959 	mov.w	r9, r9, lsr #5
   12984:	e009      	b.n	1299a <TCPIP_UDP_Bind+0xd6>
    else if(localPort != pSkt->localPort && _UDPIsAvailablePort(localPort) == false)
   12986:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
   12988:	42b3      	cmp	r3, r6
   1298a:	d0b8      	beq.n	128fe <TCPIP_UDP_Bind+0x3a>
   1298c:	4630      	mov	r0, r6
   1298e:	f00b f821 	bl	1d9d4 <_UDPIsAvailablePort>
   12992:	f080 0001 	eor.w	r0, r0, #1
   12996:	fa5f f980 	uxtb.w	r9, r0
    OSAL_SEM_Post(&userSem);
   1299a:	4812      	ldr	r0, [pc, #72]	; (129e4 <TCPIP_UDP_Bind+0x120>)
   1299c:	f00e fd8a 	bl	214b4 <OSAL_SEM_Post>
        return false;
   129a0:	2000      	movs	r0, #0
    if(portFail)
   129a2:	f1b9 0f00 	cmp.w	r9, #0
   129a6:	d0ad      	beq.n	12904 <TCPIP_UDP_Bind+0x40>
}
   129a8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            pSkt->srcAddress.Val = localAddress->v4Add.Val;
   129ac:	683b      	ldr	r3, [r7, #0]
   129ae:	61a3      	str	r3, [r4, #24]
            pSkt->flags.srcSet = 1;
   129b0:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
            pSkt->flags.srcSolved = 0;
   129b4:	f043 0360 	orr.w	r3, r3, #96	; 0x60
   129b8:	f36f 13c7 	bfc	r3, #7, #1
   129bc:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        pSkt->localPort = localPort;
   129c0:	8566      	strh	r6, [r4, #42]	; 0x2a
   129c2:	2001      	movs	r0, #1
    pSkt->extFlags.rxEnable = 1;
   129c4:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   129c8:	f043 0302 	orr.w	r3, r3, #2
   129cc:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    return bindSuccess;
   129d0:	e7ea      	b.n	129a8 <TCPIP_UDP_Bind+0xe4>
        return false;
   129d2:	2000      	movs	r0, #0
   129d4:	e7e8      	b.n	129a8 <TCPIP_UDP_Bind+0xe4>
            return false;
   129d6:	2000      	movs	r0, #0
   129d8:	e7e6      	b.n	129a8 <TCPIP_UDP_Bind+0xe4>
            return false;
   129da:	2000      	movs	r0, #0
   129dc:	e7e4      	b.n	129a8 <TCPIP_UDP_Bind+0xe4>
            return false;
   129de:	2000      	movs	r0, #0
   129e0:	e7e2      	b.n	129a8 <TCPIP_UDP_Bind+0xe4>
   129e2:	bf00      	nop
   129e4:	2000e670 	.word	0x2000e670

Disassembly of section .text.xQueueGenericSend%279:

000129e8 <xQueueGenericSend>:
{
   129e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   129ec:	b084      	sub	sp, #16
   129ee:	4604      	mov	r4, r0
   129f0:	4688      	mov	r8, r1
   129f2:	9201      	str	r2, [sp, #4]
   129f4:	461d      	mov	r5, r3
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
   129f6:	f04f 0900 	mov.w	r9, #0
		prvLockQueue( pxQueue );
   129fa:	464e      	mov	r6, r9
					portYIELD_WITHIN_API();
   129fc:	4f42      	ldr	r7, [pc, #264]	; (12b08 <xQueueGenericSend+0x120>)
   129fe:	e033      	b.n	12a68 <xQueueGenericSend+0x80>
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   12a00:	462a      	mov	r2, r5
   12a02:	4641      	mov	r1, r8
   12a04:	4620      	mov	r0, r4
   12a06:	f007 f936 	bl	19c76 <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   12a0a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   12a0c:	b973      	cbnz	r3, 12a2c <xQueueGenericSend+0x44>
					else if( xYieldRequired != pdFALSE )
   12a0e:	b138      	cbz	r0, 12a20 <xQueueGenericSend+0x38>
						queueYIELD_IF_USING_PREEMPTION();
   12a10:	4b3d      	ldr	r3, [pc, #244]	; (12b08 <xQueueGenericSend+0x120>)
   12a12:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   12a16:	601a      	str	r2, [r3, #0]
   12a18:	f3bf 8f4f 	dsb	sy
   12a1c:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
   12a20:	f00e ff4e 	bl	218c0 <vPortExitCritical>
				return pdPASS;
   12a24:	2001      	movs	r0, #1
}
   12a26:	b004      	add	sp, #16
   12a28:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   12a2c:	f104 0024 	add.w	r0, r4, #36	; 0x24
   12a30:	f007 fa44 	bl	19ebc <xTaskRemoveFromEventList>
   12a34:	2800      	cmp	r0, #0
   12a36:	d0f3      	beq.n	12a20 <xQueueGenericSend+0x38>
							queueYIELD_IF_USING_PREEMPTION();
   12a38:	4b33      	ldr	r3, [pc, #204]	; (12b08 <xQueueGenericSend+0x120>)
   12a3a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   12a3e:	601a      	str	r2, [r3, #0]
   12a40:	f3bf 8f4f 	dsb	sy
   12a44:	f3bf 8f6f 	isb	sy
   12a48:	e7ea      	b.n	12a20 <xQueueGenericSend+0x38>
					taskEXIT_CRITICAL();
   12a4a:	f00e ff39 	bl	218c0 <vPortExitCritical>
					return errQUEUE_FULL;
   12a4e:	2000      	movs	r0, #0
   12a50:	e7e9      	b.n	12a26 <xQueueGenericSend+0x3e>
					vTaskInternalSetTimeOutState( &xTimeOut );
   12a52:	a802      	add	r0, sp, #8
   12a54:	f00e fdd6 	bl	21604 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   12a58:	e014      	b.n	12a84 <xQueueGenericSend+0x9c>
				prvUnlockQueue( pxQueue );
   12a5a:	4620      	mov	r0, r4
   12a5c:	f006 fcc2 	bl	193e4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
   12a60:	f002 f98e 	bl	14d80 <xTaskResumeAll>
   12a64:	f04f 0901 	mov.w	r9, #1
		taskENTER_CRITICAL();
   12a68:	f00e f852 	bl	20b10 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   12a6c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   12a6e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   12a70:	429a      	cmp	r2, r3
   12a72:	d3c5      	bcc.n	12a00 <xQueueGenericSend+0x18>
   12a74:	2d02      	cmp	r5, #2
   12a76:	d0c3      	beq.n	12a00 <xQueueGenericSend+0x18>
				if( xTicksToWait == ( TickType_t ) 0 )
   12a78:	9b01      	ldr	r3, [sp, #4]
   12a7a:	2b00      	cmp	r3, #0
   12a7c:	d0e5      	beq.n	12a4a <xQueueGenericSend+0x62>
				else if( xEntryTimeSet == pdFALSE )
   12a7e:	f1b9 0f00 	cmp.w	r9, #0
   12a82:	d0e6      	beq.n	12a52 <xQueueGenericSend+0x6a>
		taskEXIT_CRITICAL();
   12a84:	f00e ff1c 	bl	218c0 <vPortExitCritical>
		vTaskSuspendAll();
   12a88:	f00f f848 	bl	21b1c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   12a8c:	f00e f840 	bl	20b10 <vPortEnterCritical>
   12a90:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
   12a94:	b25b      	sxtb	r3, r3
   12a96:	f1b3 3fff 	cmp.w	r3, #4294967295
   12a9a:	bf08      	it	eq
   12a9c:	f884 6044 	strbeq.w	r6, [r4, #68]	; 0x44
   12aa0:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
   12aa4:	b25b      	sxtb	r3, r3
   12aa6:	f1b3 3fff 	cmp.w	r3, #4294967295
   12aaa:	bf08      	it	eq
   12aac:	f884 6045 	strbeq.w	r6, [r4, #69]	; 0x45
   12ab0:	f00e ff06 	bl	218c0 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   12ab4:	a901      	add	r1, sp, #4
   12ab6:	a802      	add	r0, sp, #8
   12ab8:	f008 fe84 	bl	1b7c4 <xTaskCheckForTimeOut>
   12abc:	b9e8      	cbnz	r0, 12afa <xQueueGenericSend+0x112>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
   12abe:	f00e f827 	bl	20b10 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   12ac2:	f8d4 a038 	ldr.w	sl, [r4, #56]	; 0x38
   12ac6:	f8d4 903c 	ldr.w	r9, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
   12aca:	f00e fef9 	bl	218c0 <vPortExitCritical>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
   12ace:	45ca      	cmp	sl, r9
   12ad0:	d1c3      	bne.n	12a5a <xQueueGenericSend+0x72>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
   12ad2:	9901      	ldr	r1, [sp, #4]
   12ad4:	f104 0010 	add.w	r0, r4, #16
   12ad8:	f00e fa98 	bl	2100c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
   12adc:	4620      	mov	r0, r4
   12ade:	f006 fc81 	bl	193e4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
   12ae2:	f002 f94d 	bl	14d80 <xTaskResumeAll>
   12ae6:	2800      	cmp	r0, #0
   12ae8:	d1bc      	bne.n	12a64 <xQueueGenericSend+0x7c>
					portYIELD_WITHIN_API();
   12aea:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   12aee:	603b      	str	r3, [r7, #0]
   12af0:	f3bf 8f4f 	dsb	sy
   12af4:	f3bf 8f6f 	isb	sy
   12af8:	e7b4      	b.n	12a64 <xQueueGenericSend+0x7c>
			prvUnlockQueue( pxQueue );
   12afa:	4620      	mov	r0, r4
   12afc:	f006 fc72 	bl	193e4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
   12b00:	f002 f93e 	bl	14d80 <xTaskResumeAll>
			return errQUEUE_FULL;
   12b04:	2000      	movs	r0, #0
   12b06:	e78e      	b.n	12a26 <xQueueGenericSend+0x3e>
   12b08:	e000ed04 	.word	0xe000ed04

Disassembly of section .text.DRV_GMAC_Tasks%280:

00012b0c <DRV_GMAC_Tasks>:
{
   12b0c:	b538      	push	{r3, r4, r5, lr}
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   12b0e:	4b43      	ldr	r3, [pc, #268]	; (12c1c <DRV_GMAC_Tasks+0x110>)
   12b10:	4283      	cmp	r3, r0
   12b12:	d135      	bne.n	12b80 <DRV_GMAC_Tasks+0x74>
    if(pMACDrv == 0 || (pMACDrv->sGmacData._macFlags._init == 0))
   12b14:	2800      	cmp	r0, #0
   12b16:	d033      	beq.n	12b80 <DRV_GMAC_Tasks+0x74>
   12b18:	7d9b      	ldrb	r3, [r3, #22]
   12b1a:	f013 0f01 	tst.w	r3, #1
   12b1e:	d02f      	beq.n	12b80 <DRV_GMAC_Tasks+0x74>
	pPhyBase =  pMACDrv->sGmacData.gmacConfig.pPhyBase;
   12b20:	4c3e      	ldr	r4, [pc, #248]	; (12c1c <DRV_GMAC_Tasks+0x110>)
   12b22:	f8d4 50d8 	ldr.w	r5, [r4, #216]	; 0xd8
	pPhyBase->DRV_ETHPHY_Tasks(pMACDrv->sGmacData.hPhySysObject);
   12b26:	692b      	ldr	r3, [r5, #16]
   12b28:	68e0      	ldr	r0, [r4, #12]
   12b2a:	4798      	blx	r3
	switch(pMACDrv->sGmacData.sysStat)
   12b2c:	f994 3014 	ldrsb.w	r3, [r4, #20]
   12b30:	2b01      	cmp	r3, #1
   12b32:	d026      	beq.n	12b82 <DRV_GMAC_Tasks+0x76>
            if(((pMACDrv->sGmacData._controlFlags & TCPIP_MAC_CONTROL_NO_LINK_CHECK) == 0 && pMACDrv->sGmacData._macFlags._linkPrev == false) ||
   12b34:	4b39      	ldr	r3, [pc, #228]	; (12c1c <DRV_GMAC_Tasks+0x110>)
   12b36:	f8b3 30f4 	ldrh.w	r3, [r3, #244]	; 0xf4
   12b3a:	f013 0f04 	tst.w	r3, #4
   12b3e:	d104      	bne.n	12b4a <DRV_GMAC_Tasks+0x3e>
   12b40:	4b36      	ldr	r3, [pc, #216]	; (12c1c <DRV_GMAC_Tasks+0x110>)
   12b42:	7d9b      	ldrb	r3, [r3, #22]
   12b44:	f013 0f10 	tst.w	r3, #16
   12b48:	d004      	beq.n	12b54 <DRV_GMAC_Tasks+0x48>
                    (pMACDrv->sGmacData._txDiscard == true))
   12b4a:	4b34      	ldr	r3, [pc, #208]	; (12c1c <DRV_GMAC_Tasks+0x110>)
            if(((pMACDrv->sGmacData._controlFlags & TCPIP_MAC_CONTROL_NO_LINK_CHECK) == 0 && pMACDrv->sGmacData._macFlags._linkPrev == false) ||
   12b4c:	f893 30f7 	ldrb.w	r3, [r3, #247]	; 0xf7
   12b50:	2b01      	cmp	r3, #1
   12b52:	d115      	bne.n	12b80 <DRV_GMAC_Tasks+0x74>
	if(pMACDrv->sGmacData._synchF != 0)
   12b54:	4b31      	ldr	r3, [pc, #196]	; (12c1c <DRV_GMAC_Tasks+0x110>)
   12b56:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   12b58:	b113      	cbz	r3, 12b60 <DRV_GMAC_Tasks+0x54>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_LOCK);
   12b5a:	2103      	movs	r1, #3
   12b5c:	4830      	ldr	r0, [pc, #192]	; (12c20 <DRV_GMAC_Tasks+0x114>)
   12b5e:	4798      	blx	r3
                _MacTxDiscardQueues(pMACDrv, TCPIP_MAC_PKT_ACK_LINK_DOWN); 
   12b60:	4c2e      	ldr	r4, [pc, #184]	; (12c1c <DRV_GMAC_Tasks+0x110>)
   12b62:	f04f 31ff 	mov.w	r1, #4294967295
   12b66:	4620      	mov	r0, r4
   12b68:	f00a fb34 	bl	1d1d4 <_MacTxDiscardQueues>
	if(pMACDrv->sGmacData._synchF != 0)
   12b6c:	6b23      	ldr	r3, [r4, #48]	; 0x30
   12b6e:	b11b      	cbz	r3, 12b78 <DRV_GMAC_Tasks+0x6c>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_UNLOCK);
   12b70:	2104      	movs	r1, #4
   12b72:	f104 0060 	add.w	r0, r4, #96	; 0x60
   12b76:	4798      	blx	r3
                pMACDrv->sGmacData._txDiscard = false;
   12b78:	4b28      	ldr	r3, [pc, #160]	; (12c1c <DRV_GMAC_Tasks+0x110>)
   12b7a:	2200      	movs	r2, #0
   12b7c:	f883 20f7 	strb.w	r2, [r3, #247]	; 0xf7
}
   12b80:	bd38      	pop	{r3, r4, r5, pc}
            hPhyClient = pMACDrv->sGmacData.hPhyClient;
   12b82:	6924      	ldr	r4, [r4, #16]
            phyStat = pPhyBase->DRV_ETHPHY_ClientStatus(hPhyClient);
   12b84:	69eb      	ldr	r3, [r5, #28]
   12b86:	4620      	mov	r0, r4
   12b88:	4798      	blx	r3
            if(phyStat == DRV_ETHPHY_CLIENT_STATUS_BUSY)
   12b8a:	2801      	cmp	r0, #1
   12b8c:	d0f8      	beq.n	12b80 <DRV_GMAC_Tasks+0x74>
            phyInitRes = pPhyBase->DRV_ETHPHY_ClientOperationResult(hPhyClient);
   12b8e:	6a2b      	ldr	r3, [r5, #32]
   12b90:	4620      	mov	r0, r4
   12b92:	4798      	blx	r3
            if ( phyInitRes != DRV_ETHPHY_RES_OK)
   12b94:	4604      	mov	r4, r0
   12b96:	bb28      	cbnz	r0, 12be4 <DRV_GMAC_Tasks+0xd8>
            pMACDrv->sGmacData._macFlags._linkPresent = 1;
   12b98:	4b20      	ldr	r3, [pc, #128]	; (12c1c <DRV_GMAC_Tasks+0x110>)
   12b9a:	7d9a      	ldrb	r2, [r3, #22]
   12b9c:	f042 0204 	orr.w	r2, r2, #4
   12ba0:	759a      	strb	r2, [r3, #22]
            if((pMACDrv->sGmacData.gmacConfig.ethFlags & TCPIP_ETH_OPEN_AUTO) != 0)
   12ba2:	f8b3 30d2 	ldrh.w	r3, [r3, #210]	; 0xd2
   12ba6:	f013 0f01 	tst.w	r3, #1
   12baa:	d02c      	beq.n	12c06 <DRV_GMAC_Tasks+0xfa>
                pMACDrv->sGmacData._macFlags._linkNegotiation = 1;	// performing the negotiation
   12bac:	4a1b      	ldr	r2, [pc, #108]	; (12c1c <DRV_GMAC_Tasks+0x110>)
   12bae:	7d93      	ldrb	r3, [r2, #22]
   12bb0:	f043 0308 	orr.w	r3, r3, #8
   12bb4:	7593      	strb	r3, [r2, #22]
            pMACDrv->sGmacData._linkUpTick = SYS_TMR_TickCountGet();     // the initialization time
   12bb6:	f00d f9f9 	bl	1ffac <SYS_TMR_TickCountGet>
   12bba:	4c18      	ldr	r4, [pc, #96]	; (12c1c <DRV_GMAC_Tasks+0x110>)
   12bbc:	63a0      	str	r0, [r4, #56]	; 0x38
            pMACDrv->sGmacData._linkWaitTick = ((SYS_TMR_TickCounterFrequencyGet() * pMACDrv->sGmacData.gmacConfig.linkInitDelay) + 999 ) / 1000;
   12bbe:	f00d fa1d 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
   12bc2:	f8b4 30d0 	ldrh.w	r3, [r4, #208]	; 0xd0
   12bc6:	fb00 f303 	mul.w	r3, r0, r3
   12bca:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
   12bce:	4a15      	ldr	r2, [pc, #84]	; (12c24 <DRV_GMAC_Tasks+0x118>)
   12bd0:	fba2 2303 	umull	r2, r3, r2, r3
   12bd4:	099b      	lsrs	r3, r3, #6
   12bd6:	63e3      	str	r3, [r4, #60]	; 0x3c
            pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_START_LINK;
   12bd8:	2300      	movs	r3, #0
   12bda:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
            pMACDrv->sGmacData.sysStat = SYS_STATUS_READY;
   12bde:	2302      	movs	r3, #2
   12be0:	7523      	strb	r3, [r4, #20]
            break;
   12be2:	e7cd      	b.n	12b80 <DRV_GMAC_Tasks+0x74>
                _MACDeinit(pMACDrv);
   12be4:	4d0d      	ldr	r5, [pc, #52]	; (12c1c <DRV_GMAC_Tasks+0x110>)
   12be6:	4628      	mov	r0, r5
   12be8:	f7ff f874 	bl	11cd4 <_MACDeinit>
                pMACDrv->sGmacData.sysStat = SYS_STATUS_ERROR;
   12bec:	23ff      	movs	r3, #255	; 0xff
   12bee:	752b      	strb	r3, [r5, #20]
                SYS_ERROR_PRINT(SYS_ERROR_ERROR, "DRV PHY init failed: %d\r\n", phyInitRes);
   12bf0:	f00f f9ac 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
   12bf4:	2800      	cmp	r0, #0
   12bf6:	d0c3      	beq.n	12b80 <DRV_GMAC_Tasks+0x74>
   12bf8:	f00f f9a2 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
   12bfc:	4622      	mov	r2, r4
   12bfe:	490a      	ldr	r1, [pc, #40]	; (12c28 <DRV_GMAC_Tasks+0x11c>)
   12c00:	f007 fdb4 	bl	1a76c <SYS_CONSOLE_Print>
   12c04:	e7bc      	b.n	12b80 <DRV_GMAC_Tasks+0x74>
                pauseType = (pMACDrv->sGmacData.gmacConfig.ethFlags & TCPIP_ETH_OPEN_FDUPLEX) ? DRV_GMAC_PAUSE_CPBL_MASK : TCPIP_ETH_PAUSE_TYPE_NONE;
   12c06:	f003 0302 	and.w	r3, r3, #2
   12c0a:	2b00      	cmp	r3, #0
                DRV_PIC32CGMAC_LibMACOpen(pMACDrv, pMACDrv->sGmacData._linkResFlags, pauseType);
   12c0c:	4803      	ldr	r0, [pc, #12]	; (12c1c <DRV_GMAC_Tasks+0x110>)
   12c0e:	bf14      	ite	ne
   12c10:	220f      	movne	r2, #15
   12c12:	2200      	moveq	r2, #0
   12c14:	8e81      	ldrh	r1, [r0, #52]	; 0x34
   12c16:	f007 fbf9 	bl	1a40c <DRV_PIC32CGMAC_LibMACOpen>
   12c1a:	e7cc      	b.n	12bb6 <DRV_GMAC_Tasks+0xaa>
   12c1c:	2000dab8 	.word	0x2000dab8
   12c20:	2000db18 	.word	0x2000db18
   12c24:	10624dd3 	.word	0x10624dd3
   12c28:	00020290 	.word	0x00020290

Disassembly of section .text.DRV_PIC32CGMAC_LibRxBuffersAppend%281:

00012c2c <DRV_PIC32CGMAC_LibRxBuffersAppend>:
{ 
   12c2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12c30:	b085      	sub	sp, #20
   12c32:	4607      	mov	r7, r0
   12c34:	9101      	str	r1, [sp, #4]
   12c36:	461c      	mov	r4, r3
	uint16_t nRxDescCnt = pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxDescCnt;	
   12c38:	460e      	mov	r6, r1
   12c3a:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
   12c3e:	eb00 0343 	add.w	r3, r0, r3, lsl #1
   12c42:	f8b3 30be 	ldrh.w	r3, [r3, #190]	; 0xbe
   12c46:	9303      	str	r3, [sp, #12]
	uint8_t desc_idx = start_index;
   12c48:	b2d5      	uxtb	r5, r2
			if((pPacket = (TCPIP_MAC_PACKET *)DRV_PIC32CGMAC_SingleListHeadRemove(&pMACDrv->sGmacData.gmac_queue[queueIdx]._RxQueue))!= NULL)
   12c4a:	232c      	movs	r3, #44	; 0x2c
   12c4c:	fb03 0301 	mla	r3, r3, r1, r0
   12c50:	3394      	adds	r3, #148	; 0x94
   12c52:	9302      	str	r3, [sp, #8]
	DRV_PIC32CGMAC_RESULT gmacRes = DRV_PIC32CGMAC_RES_OK;
   12c54:	f04f 0900 	mov.w	r9, #0
		if((pMACDrv->sGmacData.gmac_queue[queueIdx]._RxQueue.nNodes) < (pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxBuffCntThres))
   12c58:	f04f 082c 	mov.w	r8, #44	; 0x2c
   12c5c:	fb08 0801 	mla	r8, r8, r1, r0
	while (nDesc_Cnt--)
   12c60:	e009      	b.n	12c76 <DRV_PIC32CGMAC_LibRxBuffersAppend+0x4a>
		if(pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[desc_idx] == 0)
   12c62:	9500      	str	r5, [sp, #0]
   12c64:	ea4f 0a85 	mov.w	sl, r5, lsl #2
   12c68:	f8d8 308c 	ldr.w	r3, [r8, #140]	; 0x8c
   12c6c:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
   12c70:	b313      	cbz	r3, 12cb8 <DRV_PIC32CGMAC_LibRxBuffersAppend+0x8c>
   12c72:	3c01      	subs	r4, #1
   12c74:	b2a4      	uxth	r4, r4
	while (nDesc_Cnt--)
   12c76:	b1dc      	cbz	r4, 12cb0 <DRV_PIC32CGMAC_LibRxBuffersAppend+0x84>
		if((pMACDrv->sGmacData.gmac_queue[queueIdx]._RxQueue.nNodes) < (pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxBuffCntThres))
   12c78:	eb06 03c6 	add.w	r3, r6, r6, lsl #3
   12c7c:	eb07 0343 	add.w	r3, r7, r3, lsl #1
   12c80:	f8b3 30c4 	ldrh.w	r3, [r3, #196]	; 0xc4
   12c84:	f8d8 209c 	ldr.w	r2, [r8, #156]	; 0x9c
   12c88:	429a      	cmp	r2, r3
   12c8a:	daea      	bge.n	12c62 <DRV_PIC32CGMAC_LibRxBuffersAppend+0x36>
            gmacRes = _AllocateRxPacket(pMACDrv, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxBuffAllocCnt, queueIdx, GMAC_RX_DYNAMIC_BUFFERS);
   12c8c:	eb06 01c6 	add.w	r1, r6, r6, lsl #3
   12c90:	eb07 0141 	add.w	r1, r7, r1, lsl #1
   12c94:	2300      	movs	r3, #0
   12c96:	9a01      	ldr	r2, [sp, #4]
   12c98:	f8b1 10c6 	ldrh.w	r1, [r1, #198]	; 0xc6
   12c9c:	4638      	mov	r0, r7
   12c9e:	f007 fbeb 	bl	1a478 <_AllocateRxPacket>
   12ca2:	4681      	mov	r9, r0
            if(gmacRes == DRV_PIC32CGMAC_RES_OUT_OF_MEMORY)
   12ca4:	f1b0 3fff 	cmp.w	r0, #4294967295
   12ca8:	d1db      	bne.n	12c62 <DRV_PIC32CGMAC_LibRxBuffersAppend+0x36>
                pMACDrv->sGmacData._rxStat.nRxBuffNotAvailable++;			
   12caa:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   12cac:	3301      	adds	r3, #1
   12cae:	67bb      	str	r3, [r7, #120]	; 0x78
} //DRV_PIC32CGMAC_LibRxBuffersAppend
   12cb0:	4648      	mov	r0, r9
   12cb2:	b005      	add	sp, #20
   12cb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if((pPacket = (TCPIP_MAC_PACKET *)DRV_PIC32CGMAC_SingleListHeadRemove(&pMACDrv->sGmacData.gmac_queue[queueIdx]._RxQueue))!= NULL)
   12cb8:	9802      	ldr	r0, [sp, #8]
   12cba:	f00e f849 	bl	20d50 <DRV_PIC32CGMAC_SingleListHeadRemove>
   12cbe:	4683      	mov	fp, r0
   12cc0:	2800      	cmp	r0, #0
   12cc2:	d0d6      	beq.n	12c72 <DRV_PIC32CGMAC_LibRxBuffersAppend+0x46>
	if(pMACDrv->sGmacData._synchF != 0)
   12cc4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   12cc6:	b11b      	cbz	r3, 12cd0 <DRV_PIC32CGMAC_LibRxBuffersAppend+0xa4>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
   12cc8:	2105      	movs	r1, #5
   12cca:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   12cce:	4798      	blx	r3
				pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc[desc_idx].rx_desc_status.val = 0;
   12cd0:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
   12cd4:	9a00      	ldr	r2, [sp, #0]
   12cd6:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   12cda:	2200      	movs	r2, #0
   12cdc:	605a      	str	r2, [r3, #4]
                uint32_t segBuffer = (uint32_t)(pPacket->pDSeg->segBuffer) & GMAC_RX_ADDRESS_MASK;   // should be 4-byte aligned
   12cde:	f8db 3010 	ldr.w	r3, [fp, #16]
   12ce2:	685a      	ldr	r2, [r3, #4]
   12ce4:	f022 0203 	bic.w	r2, r2, #3
				if (desc_idx == pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxDescCnt - 1)
   12ce8:	eb06 03c6 	add.w	r3, r6, r6, lsl #3
   12cec:	eb07 0343 	add.w	r3, r7, r3, lsl #1
   12cf0:	f8b3 30be 	ldrh.w	r3, [r3, #190]	; 0xbe
   12cf4:	3b01      	subs	r3, #1
   12cf6:	429d      	cmp	r5, r3
   12cf8:	d01e      	beq.n	12d38 <DRV_PIC32CGMAC_LibRxBuffersAppend+0x10c>
                    pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc[desc_idx].rx_desc_buffaddr.val =  segBuffer;            
   12cfa:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
   12cfe:	9900      	ldr	r1, [sp, #0]
   12d00:	f843 2031 	str.w	r2, [r3, r1, lsl #3]
	if(pMACDrv->sGmacData._synchF != 0)
   12d04:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   12d06:	b11b      	cbz	r3, 12d10 <DRV_PIC32CGMAC_LibRxBuffersAppend+0xe4>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_LEAVE);
   12d08:	2106      	movs	r1, #6
   12d0a:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   12d0e:	4798      	blx	r3
				pPacket->ackFunc = (TCPIP_MAC_PACKET_ACK_FUNC)_MacRxPacketAck;
   12d10:	4b0d      	ldr	r3, [pc, #52]	; (12d48 <DRV_PIC32CGMAC_LibRxBuffersAppend+0x11c>)
   12d12:	f8cb 3008 	str.w	r3, [fp, #8]
				pPacket->ackParam = pMACDrv;
   12d16:	f8cb 700c 	str.w	r7, [fp, #12]
				pMACDrv->sGmacData.gmac_queue[queueIdx].pRxPckt[desc_idx] = pPacket;
   12d1a:	f8d8 308c 	ldr.w	r3, [r8, #140]	; 0x8c
   12d1e:	f843 b00a 	str.w	fp, [r3, sl]
				pPacket->next = 0;
   12d22:	2300      	movs	r3, #0
   12d24:	f8cb 3000 	str.w	r3, [fp]
				GCIRC_INC(desc_idx,nRxDescCnt );
   12d28:	3501      	adds	r5, #1
   12d2a:	b2ed      	uxtb	r5, r5
   12d2c:	b2ab      	uxth	r3, r5
   12d2e:	9a03      	ldr	r2, [sp, #12]
   12d30:	4293      	cmp	r3, r2
   12d32:	bf28      	it	cs
   12d34:	2500      	movcs	r5, #0
   12d36:	e79c      	b.n	12c72 <DRV_PIC32CGMAC_LibRxBuffersAppend+0x46>
                    pMACDrv->sGmacData.gmac_queue[queueIdx].pRxDesc[desc_idx].rx_desc_buffaddr.val =  segBuffer | GMAC_RX_WRAP_BIT;
   12d38:	f8d8 1090 	ldr.w	r1, [r8, #144]	; 0x90
   12d3c:	f042 0202 	orr.w	r2, r2, #2
   12d40:	9b00      	ldr	r3, [sp, #0]
   12d42:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
   12d46:	e7dd      	b.n	12d04 <DRV_PIC32CGMAC_LibRxBuffersAppend+0xd8>
   12d48:	0001adf1 	.word	0x0001adf1

Disassembly of section .text._Command_StackOnOff%282:

00012d4c <_Command_StackOnOff>:
{
   12d4c:	b5f0      	push	{r4, r5, r6, r7, lr}
   12d4e:	b087      	sub	sp, #28
   12d50:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   12d52:	6845      	ldr	r5, [r0, #4]
    if (argc < 2)
   12d54:	2901      	cmp	r1, #1
   12d56:	dd10      	ble.n	12d7a <_Command_StackOnOff+0x2e>
    if (memcmp(argv[1], "up", 2) == 0)
   12d58:	6856      	ldr	r6, [r2, #4]
   12d5a:	2202      	movs	r2, #2
   12d5c:	4938      	ldr	r1, [pc, #224]	; (12e40 <_Command_StackOnOff+0xf4>)
   12d5e:	4630      	mov	r0, r6
   12d60:	f00e f970 	bl	21044 <memcmp>
   12d64:	b1c0      	cbz	r0, 12d98 <_Command_StackOnOff+0x4c>
    else if (memcmp(argv[1], "down", 4) == 0)
   12d66:	2204      	movs	r2, #4
   12d68:	4936      	ldr	r1, [pc, #216]	; (12e44 <_Command_StackOnOff+0xf8>)
   12d6a:	4630      	mov	r0, r6
   12d6c:	f00e f96a 	bl	21044 <memcmp>
   12d70:	2800      	cmp	r0, #0
   12d72:	d046      	beq.n	12e02 <_Command_StackOnOff+0xb6>
    return true;
   12d74:	2001      	movs	r0, #1
}
   12d76:	b007      	add	sp, #28
   12d78:	bdf0      	pop	{r4, r5, r6, r7, pc}
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: stack <up/down> <preserve>\r\n");
   12d7a:	4e33      	ldr	r6, [pc, #204]	; (12e48 <_Command_StackOnOff+0xfc>)
   12d7c:	6803      	ldr	r3, [r0, #0]
   12d7e:	681b      	ldr	r3, [r3, #0]
   12d80:	f606 11f4 	addw	r1, r6, #2548	; 0x9f4
   12d84:	4628      	mov	r0, r5
   12d86:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: stack down preserve\r\n");
   12d88:	6823      	ldr	r3, [r4, #0]
   12d8a:	681b      	ldr	r3, [r3, #0]
   12d8c:	f606 2118 	addw	r1, r6, #2584	; 0xa18
   12d90:	4628      	mov	r0, r5
   12d92:	4798      	blx	r3
        return false;
   12d94:	2000      	movs	r0, #0
   12d96:	e7ee      	b.n	12d76 <_Command_StackOnOff+0x2a>
        tcpipStackObj = TCPIP_STACK_Initialize(0, 0);
   12d98:	2100      	movs	r1, #0
   12d9a:	4608      	mov	r0, r1
   12d9c:	f005 fc6c 	bl	18678 <TCPIP_STACK_Initialize>
        if ( tcpipStackObj != SYS_MODULE_OBJ_INVALID)
   12da0:	f1b0 3fff 	cmp.w	r0, #4294967295
   12da4:	d006      	beq.n	12db4 <_Command_StackOnOff+0x68>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Stack already up!\r\n");
   12da6:	6823      	ldr	r3, [r4, #0]
   12da8:	681b      	ldr	r3, [r3, #0]
   12daa:	4928      	ldr	r1, [pc, #160]	; (12e4c <_Command_StackOnOff+0x100>)
   12dac:	4628      	mov	r0, r5
   12dae:	4798      	blx	r3
            return true;
   12db0:	2001      	movs	r0, #1
   12db2:	e7e0      	b.n	12d76 <_Command_StackOnOff+0x2a>
        if(pCmdTcpipInitData == 0)
   12db4:	4b26      	ldr	r3, [pc, #152]	; (12e50 <_Command_StackOnOff+0x104>)
   12db6:	681e      	ldr	r6, [r3, #0]
   12db8:	b1e6      	cbz	r6, 12df4 <_Command_StackOnOff+0xa8>
        tcpipInit = *pCmdTcpipInitData;
   12dba:	466f      	mov	r7, sp
   12dbc:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   12dbe:	c70f      	stmia	r7!, {r0, r1, r2, r3}
   12dc0:	e896 0003 	ldmia.w	r6, {r0, r1}
   12dc4:	e887 0003 	stmia.w	r7, {r0, r1}
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Restarting the stack with %d interface(s)\r\n", tcpipInit.nNets);
   12dc8:	6823      	ldr	r3, [r4, #0]
   12dca:	685b      	ldr	r3, [r3, #4]
   12dcc:	4921      	ldr	r1, [pc, #132]	; (12e54 <_Command_StackOnOff+0x108>)
   12dce:	4628      	mov	r0, r5
   12dd0:	4798      	blx	r3
        tcpipStackObj = TCPIP_STACK_Initialize(0, &tcpipInit.moduleInit);     // init the stack
   12dd2:	4669      	mov	r1, sp
   12dd4:	2000      	movs	r0, #0
   12dd6:	f005 fc4f 	bl	18678 <TCPIP_STACK_Initialize>
        if ( tcpipStackObj == SYS_MODULE_OBJ_INVALID)
   12dda:	f1b0 3fff 	cmp.w	r0, #4294967295
            msg = "Stack up succeeded\r\n";
   12dde:	491e      	ldr	r1, [pc, #120]	; (12e58 <_Command_StackOnOff+0x10c>)
   12de0:	f101 0314 	add.w	r3, r1, #20
   12de4:	bf18      	it	ne
   12de6:	4619      	movne	r1, r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, msg);
   12de8:	6823      	ldr	r3, [r4, #0]
   12dea:	681b      	ldr	r3, [r3, #0]
   12dec:	4628      	mov	r0, r5
   12dee:	4798      	blx	r3
    return true;
   12df0:	2001      	movs	r0, #1
   12df2:	e7c0      	b.n	12d76 <_Command_StackOnOff+0x2a>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Turn Stack down and then up!\r\n");
   12df4:	6823      	ldr	r3, [r4, #0]
   12df6:	681b      	ldr	r3, [r3, #0]
   12df8:	4918      	ldr	r1, [pc, #96]	; (12e5c <_Command_StackOnOff+0x110>)
   12dfa:	4628      	mov	r0, r5
   12dfc:	4798      	blx	r3
            return true;
   12dfe:	2001      	movs	r0, #1
   12e00:	e7b9      	b.n	12d76 <_Command_StackOnOff+0x2a>
        tcpipStackObj = TCPIP_STACK_Initialize(0, 0);
   12e02:	2100      	movs	r1, #0
   12e04:	4608      	mov	r0, r1
   12e06:	f005 fc37 	bl	18678 <TCPIP_STACK_Initialize>
   12e0a:	4606      	mov	r6, r0
        if ( tcpipStackObj == SYS_MODULE_OBJ_INVALID)
   12e0c:	f1b0 3fff 	cmp.w	r0, #4294967295
   12e10:	d106      	bne.n	12e20 <_Command_StackOnOff+0xd4>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, msg);
   12e12:	6823      	ldr	r3, [r4, #0]
   12e14:	681b      	ldr	r3, [r3, #0]
   12e16:	4912      	ldr	r1, [pc, #72]	; (12e60 <_Command_StackOnOff+0x114>)
   12e18:	4628      	mov	r0, r5
   12e1a:	4798      	blx	r3
    return true;
   12e1c:	2001      	movs	r0, #1
   12e1e:	e7aa      	b.n	12d76 <_Command_StackOnOff+0x2a>
            TCPIP_STACK_InitializeDataGet(tcpipStackObj, &cmdTcpipInitData);
   12e20:	4f10      	ldr	r7, [pc, #64]	; (12e64 <_Command_StackOnOff+0x118>)
   12e22:	4639      	mov	r1, r7
   12e24:	f00c f96e 	bl	1f104 <TCPIP_STACK_InitializeDataGet>
            pCmdTcpipInitData = &cmdTcpipInitData;
   12e28:	4b09      	ldr	r3, [pc, #36]	; (12e50 <_Command_StackOnOff+0x104>)
   12e2a:	601f      	str	r7, [r3, #0]
            TCPIP_STACK_Deinitialize(tcpipStackObj);
   12e2c:	4630      	mov	r0, r6
   12e2e:	f00e f86f 	bl	20f10 <TCPIP_STACK_Deinitialize>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Stack down succeeded\r\n");
   12e32:	6823      	ldr	r3, [r4, #0]
   12e34:	681b      	ldr	r3, [r3, #0]
   12e36:	490c      	ldr	r1, [pc, #48]	; (12e68 <_Command_StackOnOff+0x11c>)
   12e38:	4628      	mov	r0, r5
   12e3a:	4798      	blx	r3
    return true;
   12e3c:	2001      	movs	r0, #1
   12e3e:	e79a      	b.n	12d76 <_Command_StackOnOff+0x2a>
   12e40:	00000cc0 	.word	0x00000cc0
   12e44:	00000d24 	.word	0x00000d24
   12e48:	0000028c 	.word	0x0000028c
   12e4c:	00000cc4 	.word	0x00000cc4
   12e50:	2000e5e4 	.word	0x2000e5e4
   12e54:	00000cf8 	.word	0x00000cf8
   12e58:	00000c54 	.word	0x00000c54
   12e5c:	00000cd8 	.word	0x00000cd8
   12e60:	00000d2c 	.word	0x00000d2c
   12e64:	2000e3e4 	.word	0x2000e3e4
   12e68:	00000d54 	.word	0x00000d54

Disassembly of section .text.TCPIP_IPV4_PacketFormatTx%283:

00012e6c <TCPIP_IPV4_PacketFormatTx>:
{
   12e6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12e70:	4605      	mov	r5, r0
    IPV4_HEADER*    pHdr = (IPV4_HEADER*)pPkt->macPkt.pNetLayer;
   12e72:	6984      	ldr	r4, [r0, #24]
    uint16_t hdrLen = sizeof(IPV4_HEADER) + pPkt->optionLen;
   12e74:	f890 6040 	ldrb.w	r6, [r0, #64]	; 0x40
   12e78:	3614      	adds	r6, #20
    pHdr->Version = IPv4_VERSION;
   12e7a:	7820      	ldrb	r0, [r4, #0]
   12e7c:	2704      	movs	r7, #4
   12e7e:	f367 1007 	bfi	r0, r7, #4, #4
    pHdr->IHL = hdrLen >> 2;
   12e82:	08b7      	lsrs	r7, r6, #2
   12e84:	f367 0003 	bfi	r0, r7, #0, #4
   12e88:	7020      	strb	r0, [r4, #0]
    if((pPkt->optionMask & IPV4_OPTION_MASK_ROUTER_ALERT) != 0)
   12e8a:	f8b5 0042 	ldrh.w	r0, [r5, #66]	; 0x42
   12e8e:	f010 0f01 	tst.w	r0, #1
   12e92:	d01f      	beq.n	12ed4 <TCPIP_IPV4_PacketFormatTx+0x68>
        pOpt = (IPV4_ROUTER_ALERT_OPTION*)pHdr->options + pPkt->optionOffset;
   12e94:	f104 0714 	add.w	r7, r4, #20
   12e98:	f895 e041 	ldrb.w	lr, [r5, #65]	; 0x41
   12e9c:	eb07 0c8e 	add.w	ip, r7, lr, lsl #2
        pOpt->optCopied = IPV4_ROUTER_ALERT_OPTION_COPIED;
   12ea0:	f817 002e 	ldrb.w	r0, [r7, lr, lsl #2]
        pOpt->optClass = IPV4_ROUTER_ALERT_OPTION_CLASS;
   12ea4:	f060 007f 	orn	r0, r0, #127	; 0x7f
        pOpt->optNumber = TCPIP_IPV4_OPTION_ROUTER_ALERT;
   12ea8:	f000 009f 	and.w	r0, r0, #159	; 0x9f
   12eac:	f04f 0814 	mov.w	r8, #20
   12eb0:	f368 0004 	bfi	r0, r8, #0, #5
   12eb4:	f807 002e 	strb.w	r0, [r7, lr, lsl #2]
        pOpt->optLength = IPV4_ROUTER_ALERT_OPTION_SIZE;
   12eb8:	2004      	movs	r0, #4
   12eba:	f88c 0001 	strb.w	r0, [ip, #1]
        pOpt->optValue = IPV4_ROUTER_ALERT_OPTION_DATA;
   12ebe:	2000      	movs	r0, #0
   12ec0:	f8ac 0002 	strh.w	r0, [ip, #2]
        pEndOpt = (uint8_t*)(pOpt + 1);
   12ec4:	f10c 0704 	add.w	r7, ip, #4
        pEndHdr = (uint8_t*)pHdr + hdrLen;
   12ec8:	19a0      	adds	r0, r4, r6
        if(pEndOpt < pEndHdr)
   12eca:	4287      	cmp	r7, r0
            *pEndOpt = 0;
   12ecc:	bf3c      	itt	cc
   12ece:	2000      	movcc	r0, #0
   12ed0:	f88c 0004 	strbcc.w	r0, [ip, #4]
    pHdr->TypeOfService.val = 0;
   12ed4:	2000      	movs	r0, #0
   12ed6:	7060      	strb	r0, [r4, #1]
    if(pParams)
   12ed8:	b1fb      	cbz	r3, 12f1a <TCPIP_IPV4_PacketFormatTx+0xae>
        if((pParams->tosFlags & TCPIP_IPV4_RELIABILITY_HIGH) != 0)
   12eda:	7818      	ldrb	r0, [r3, #0]
   12edc:	f010 0f20 	tst.w	r0, #32
   12ee0:	d003      	beq.n	12eea <TCPIP_IPV4_PacketFormatTx+0x7e>
            pHdr->TypeOfService.reliability = 1;
   12ee2:	7860      	ldrb	r0, [r4, #1]
   12ee4:	f040 0004 	orr.w	r0, r0, #4
   12ee8:	7060      	strb	r0, [r4, #1]
        if((pParams->tosFlags & TCPIP_IPV4_THROUGHPUT_HIGH) != 0)
   12eea:	7818      	ldrb	r0, [r3, #0]
   12eec:	f010 0f10 	tst.w	r0, #16
   12ef0:	d003      	beq.n	12efa <TCPIP_IPV4_PacketFormatTx+0x8e>
            pHdr->TypeOfService.throughput = 1;
   12ef2:	7860      	ldrb	r0, [r4, #1]
   12ef4:	f040 0008 	orr.w	r0, r0, #8
   12ef8:	7060      	strb	r0, [r4, #1]
        if((pParams->tosFlags & TCPIP_IPV4_DELAY_LOW) != 0)
   12efa:	7818      	ldrb	r0, [r3, #0]
   12efc:	f010 0f08 	tst.w	r0, #8
   12f00:	d003      	beq.n	12f0a <TCPIP_IPV4_PacketFormatTx+0x9e>
            pHdr->TypeOfService.delay = 1;
   12f02:	7860      	ldrb	r0, [r4, #1]
   12f04:	f040 0010 	orr.w	r0, r0, #16
   12f08:	7060      	strb	r0, [r4, #1]
        if((pParams->tosFlags & TCPIP_IPV4_PRECEDENCE_MASK) != 0)
   12f0a:	7818      	ldrb	r0, [r3, #0]
   12f0c:	f010 0f07 	tst.w	r0, #7
   12f10:	d003      	beq.n	12f1a <TCPIP_IPV4_PacketFormatTx+0xae>
            pHdr->TypeOfService.precedence = pParams->tosFlags & TCPIP_IPV4_PRECEDENCE_MASK;
   12f12:	7867      	ldrb	r7, [r4, #1]
   12f14:	f360 1747 	bfi	r7, r0, #5, #3
   12f18:	7067      	strb	r7, [r4, #1]
    pHdr->TotalLength = TCPIP_Helper_htons(hdrLen + ipLoadLen);
   12f1a:	4432      	add	r2, r6
   12f1c:	b292      	uxth	r2, r2
   12f1e:	0a10      	lsrs	r0, r2, #8
   12f20:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
   12f24:	8062      	strh	r2, [r4, #2]
    pHdr->Identification = TCPIP_Helper_htons(++ipv4Identifier);
   12f26:	4818      	ldr	r0, [pc, #96]	; (12f88 <TCPIP_IPV4_PacketFormatTx+0x11c>)
   12f28:	8802      	ldrh	r2, [r0, #0]
   12f2a:	3201      	adds	r2, #1
   12f2c:	b292      	uxth	r2, r2
   12f2e:	8002      	strh	r2, [r0, #0]
   12f30:	0a10      	lsrs	r0, r2, #8
   12f32:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
   12f36:	80a2      	strh	r2, [r4, #4]
    pHdr->FragmentInfo.val = TCPIP_Helper_htons(0);
   12f38:	2200      	movs	r2, #0
   12f3a:	80e2      	strh	r2, [r4, #6]
    if(pParams !=0 && pParams->df != 0)
   12f3c:	b30b      	cbz	r3, 12f82 <TCPIP_IPV4_PacketFormatTx+0x116>
   12f3e:	789a      	ldrb	r2, [r3, #2]
   12f40:	b11a      	cbz	r2, 12f4a <TCPIP_IPV4_PacketFormatTx+0xde>
        pHdr->FragmentInfo.DF = 1;
   12f42:	79e2      	ldrb	r2, [r4, #7]
   12f44:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   12f48:	71e2      	strb	r2, [r4, #7]
    pHdr->TimeToLive = (pParams != 0 && pParams->ttl != 0) ? pParams->ttl : IPV4_DEFAULT_TTL;
   12f4a:	785b      	ldrb	r3, [r3, #1]
   12f4c:	2b00      	cmp	r3, #0
   12f4e:	bf08      	it	eq
   12f50:	2364      	moveq	r3, #100	; 0x64
   12f52:	7223      	strb	r3, [r4, #8]
    pHdr->Protocol = protocol;
   12f54:	7261      	strb	r1, [r4, #9]
    pHdr->HeaderChecksum = 0;
   12f56:	2200      	movs	r2, #0
   12f58:	8162      	strh	r2, [r4, #10]
    pHdr->SourceAddress.Val = pPkt->srcAddress.Val;
   12f5a:	6b6b      	ldr	r3, [r5, #52]	; 0x34
   12f5c:	60e3      	str	r3, [r4, #12]
    pHdr->DestAddress.Val = pPkt->destAddress.Val;
   12f5e:	6bab      	ldr	r3, [r5, #56]	; 0x38
   12f60:	6123      	str	r3, [r4, #16]
    pHdr->HeaderChecksum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pHdr, hdrLen, 0);
   12f62:	4631      	mov	r1, r6
   12f64:	4620      	mov	r0, r4
   12f66:	f007 f9a9 	bl	1a2bc <TCPIP_Helper_CalcIPChecksum>
   12f6a:	8160      	strh	r0, [r4, #10]
    pPkt->macPkt.pDSeg->segLen += hdrLen;
   12f6c:	692a      	ldr	r2, [r5, #16]
   12f6e:	8993      	ldrh	r3, [r2, #12]
   12f70:	4433      	add	r3, r6
   12f72:	8193      	strh	r3, [r2, #12]
    pPkt->macPkt.pTransportLayer = pPkt->macPkt.pNetLayer + hdrLen;
   12f74:	69ab      	ldr	r3, [r5, #24]
   12f76:	441e      	add	r6, r3
   12f78:	61ee      	str	r6, [r5, #28]
    pPkt->macPkt.pktIf = pPkt->netIfH;
   12f7a:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   12f7c:	62ab      	str	r3, [r5, #40]	; 0x28
}
   12f7e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    pHdr->TimeToLive = (pParams != 0 && pParams->ttl != 0) ? pParams->ttl : IPV4_DEFAULT_TTL;
   12f82:	2364      	movs	r3, #100	; 0x64
   12f84:	e7e5      	b.n	12f52 <TCPIP_IPV4_PacketFormatTx+0xe6>
   12f86:	bf00      	nop
   12f88:	2000e71a 	.word	0x2000e71a

Disassembly of section .text.TCPIP_Helper_StringToIPAddress%284:

00012f8c <TCPIP_Helper_StringToIPAddress>:
{
   12f8c:	b4f0      	push	{r4, r5, r6, r7}
   12f8e:	b082      	sub	sp, #8
    if(addr)
   12f90:	460d      	mov	r5, r1
   12f92:	b109      	cbz	r1, 12f98 <TCPIP_Helper_StringToIPAddress+0xc>
        addr->Val = 0;
   12f94:	2300      	movs	r3, #0
   12f96:	600b      	str	r3, [r1, #0]
    if(str == 0 || strlen(str) == 0)
   12f98:	2800      	cmp	r0, #0
   12f9a:	d071      	beq.n	13080 <TCPIP_Helper_StringToIPAddress+0xf4>
   12f9c:	7803      	ldrb	r3, [r0, #0]
   12f9e:	2b00      	cmp	r3, #0
   12fa0:	d070      	beq.n	13084 <TCPIP_Helper_StringToIPAddress+0xf8>
	dwVal.Val = 0;
   12fa2:	2100      	movs	r1, #0
	while((i = *str++))
   12fa4:	3001      	adds	r0, #1
	currentOctet = 0;
   12fa6:	460c      	mov	r4, r1
	charLen = 0;
   12fa8:	460a      	mov	r2, r1
				if(dwVal.Val > 0x00020505ul)
   12faa:	4e3f      	ldr	r6, [pc, #252]	; (130a8 <TCPIP_Helper_StringToIPAddress+0x11c>)
   12fac:	e010      	b.n	12fd0 <TCPIP_Helper_StringToIPAddress+0x44>
		else if(charLen == 3u)
   12fae:	2a03      	cmp	r2, #3
   12fb0:	d016      	beq.n	12fe0 <TCPIP_Helper_StringToIPAddress+0x54>
			if(i == (uint8_t)('.' - '0'))
   12fb2:	2bfe      	cmp	r3, #254	; 0xfe
   12fb4:	d031      	beq.n	1301a <TCPIP_Helper_StringToIPAddress+0x8e>
			if(i > 9u)
   12fb6:	2b09      	cmp	r3, #9
   12fb8:	d86c      	bhi.n	13094 <TCPIP_Helper_StringToIPAddress+0x108>
		charLen++;
   12fba:	3201      	adds	r2, #1
   12fbc:	b2d2      	uxtb	r2, r2
		dwVal.Val <<= 8;
   12fbe:	0209      	lsls	r1, r1, #8
		dwVal.v[0] = i;
   12fc0:	f363 0107 	bfi	r1, r3, #0, #8
	while((i = *str++))
   12fc4:	f810 3b01 	ldrb.w	r3, [r0], #1
   12fc8:	2b00      	cmp	r3, #0
   12fca:	d069      	beq.n	130a0 <TCPIP_Helper_StringToIPAddress+0x114>
		if(currentOctet > 3u)
   12fcc:	2c03      	cmp	r4, #3
   12fce:	d85d      	bhi.n	1308c <TCPIP_Helper_StringToIPAddress+0x100>
		i -= '0';
   12fd0:	3b30      	subs	r3, #48	; 0x30
   12fd2:	b2db      	uxtb	r3, r3
		if(charLen == 0u)
   12fd4:	2a00      	cmp	r2, #0
   12fd6:	d1ea      	bne.n	12fae <TCPIP_Helper_StringToIPAddress+0x22>
			if(i > 9u)
   12fd8:	2b09      	cmp	r3, #9
   12fda:	d9ee      	bls.n	12fba <TCPIP_Helper_StringToIPAddress+0x2e>
				return false;
   12fdc:	2000      	movs	r0, #0
   12fde:	e052      	b.n	13086 <TCPIP_Helper_StringToIPAddress+0xfa>
			if(i != (uint8_t)('.' - '0'))
   12fe0:	2bfe      	cmp	r3, #254	; 0xfe
   12fe2:	d155      	bne.n	13090 <TCPIP_Helper_StringToIPAddress+0x104>
			if(dwVal.Val > 0x00020505ul)
   12fe4:	42b1      	cmp	r1, r6
   12fe6:	d901      	bls.n	12fec <TCPIP_Helper_StringToIPAddress+0x60>
				return false;
   12fe8:	2000      	movs	r0, #0
   12fea:	e04c      	b.n	13086 <TCPIP_Helper_StringToIPAddress+0xfa>
			convAddr.v[currentOctet++] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
   12fec:	1c62      	adds	r2, r4, #1
   12fee:	ab02      	add	r3, sp, #8
   12ff0:	441c      	add	r4, r3
   12ff2:	f3c1 4307 	ubfx	r3, r1, #16, #8
   12ff6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   12ffa:	eb03 0783 	add.w	r7, r3, r3, lsl #2
   12ffe:	f3c1 2307 	ubfx	r3, r1, #8, #8
   13002:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   13006:	005b      	lsls	r3, r3, #1
   13008:	eb03 0387 	add.w	r3, r3, r7, lsl #2
   1300c:	4419      	add	r1, r3
   1300e:	f804 1c04 	strb.w	r1, [r4, #-4]
			dwVal.Val = 0;
   13012:	2100      	movs	r1, #0
			convAddr.v[currentOctet++] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
   13014:	b2d4      	uxtb	r4, r2
			charLen = 0;
   13016:	460a      	mov	r2, r1
			continue;
   13018:	e7d4      	b.n	12fc4 <TCPIP_Helper_StringToIPAddress+0x38>
				if(dwVal.Val > 0x00020505ul)
   1301a:	42b1      	cmp	r1, r6
   1301c:	d901      	bls.n	13022 <TCPIP_Helper_StringToIPAddress+0x96>
					return false;
   1301e:	2000      	movs	r0, #0
   13020:	e031      	b.n	13086 <TCPIP_Helper_StringToIPAddress+0xfa>
				convAddr.v[currentOctet++] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
   13022:	1c62      	adds	r2, r4, #1
   13024:	ab02      	add	r3, sp, #8
   13026:	441c      	add	r4, r3
   13028:	f3c1 4307 	ubfx	r3, r1, #16, #8
   1302c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   13030:	eb03 0783 	add.w	r7, r3, r3, lsl #2
   13034:	f3c1 2307 	ubfx	r3, r1, #8, #8
   13038:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   1303c:	005b      	lsls	r3, r3, #1
   1303e:	eb03 0387 	add.w	r3, r3, r7, lsl #2
   13042:	4419      	add	r1, r3
   13044:	f804 1c04 	strb.w	r1, [r4, #-4]
				dwVal.Val = 0;
   13048:	2100      	movs	r1, #0
				convAddr.v[currentOctet++] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
   1304a:	b2d4      	uxtb	r4, r2
				charLen = 0;
   1304c:	460a      	mov	r2, r1
				continue;
   1304e:	e7b9      	b.n	12fc4 <TCPIP_Helper_StringToIPAddress+0x38>
	if(dwVal.Val > 0x00020505ul)
   13050:	4b15      	ldr	r3, [pc, #84]	; (130a8 <TCPIP_Helper_StringToIPAddress+0x11c>)
   13052:	4299      	cmp	r1, r3
   13054:	d820      	bhi.n	13098 <TCPIP_Helper_StringToIPAddress+0x10c>
	convAddr.v[3] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
   13056:	f3c1 4307 	ubfx	r3, r1, #16, #8
   1305a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   1305e:	eb03 0283 	add.w	r2, r3, r3, lsl #2
   13062:	f3c1 2307 	ubfx	r3, r1, #8, #8
   13066:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   1306a:	005b      	lsls	r3, r3, #1
   1306c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   13070:	4419      	add	r1, r3
   13072:	f88d 1007 	strb.w	r1, [sp, #7]
    if(addr)
   13076:	b18d      	cbz	r5, 1309c <TCPIP_Helper_StringToIPAddress+0x110>
        addr->Val = convAddr.Val;
   13078:	9b01      	ldr	r3, [sp, #4]
   1307a:	602b      	str	r3, [r5, #0]
	return true;
   1307c:	2001      	movs	r0, #1
   1307e:	e002      	b.n	13086 <TCPIP_Helper_StringToIPAddress+0xfa>
        return true;
   13080:	2001      	movs	r0, #1
   13082:	e000      	b.n	13086 <TCPIP_Helper_StringToIPAddress+0xfa>
   13084:	2001      	movs	r0, #1
}
   13086:	b002      	add	sp, #8
   13088:	bcf0      	pop	{r4, r5, r6, r7}
   1308a:	4770      	bx	lr
		return false;
   1308c:	2000      	movs	r0, #0
   1308e:	e7fa      	b.n	13086 <TCPIP_Helper_StringToIPAddress+0xfa>
				return false;
   13090:	2000      	movs	r0, #0
   13092:	e7f8      	b.n	13086 <TCPIP_Helper_StringToIPAddress+0xfa>
				return false;
   13094:	2000      	movs	r0, #0
   13096:	e7f6      	b.n	13086 <TCPIP_Helper_StringToIPAddress+0xfa>
		return false;
   13098:	2000      	movs	r0, #0
   1309a:	e7f4      	b.n	13086 <TCPIP_Helper_StringToIPAddress+0xfa>
	return true;
   1309c:	2001      	movs	r0, #1
   1309e:	e7f2      	b.n	13086 <TCPIP_Helper_StringToIPAddress+0xfa>
	if(currentOctet != 3 || (i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t' && i != ':'))
   130a0:	2c03      	cmp	r4, #3
   130a2:	d0d5      	beq.n	13050 <TCPIP_Helper_StringToIPAddress+0xc4>
		return false;
   130a4:	2000      	movs	r0, #0
   130a6:	e7ee      	b.n	13086 <TCPIP_Helper_StringToIPAddress+0xfa>
   130a8:	00020505 	.word	0x00020505

Disassembly of section .text.DRV_GMAC_EventMaskSet%285:

000130ac <DRV_GMAC_EventMaskSet>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   130ac:	4b45      	ldr	r3, [pc, #276]	; (131c4 <DRV_GMAC_EventMaskSet+0x118>)
   130ae:	4283      	cmp	r3, r0
   130b0:	f040 8082 	bne.w	131b8 <DRV_GMAC_EventMaskSet+0x10c>
    if(pMACDrv == 0)
   130b4:	2800      	cmp	r0, #0
   130b6:	f000 8081 	beq.w	131bc <DRV_GMAC_EventMaskSet+0x110>
{
   130ba:	b570      	push	{r4, r5, r6, lr}
   130bc:	b082      	sub	sp, #8
   130be:	4615      	mov	r5, r2
   130c0:	460c      	mov	r4, r1
	if(enable)
   130c2:	2a00      	cmp	r2, #0
   130c4:	d03d      	beq.n	13142 <DRV_GMAC_EventMaskSet+0x96>
		ethSetEvents = _XtlEventsTcp2Eth(macEvMask);
   130c6:	4608      	mov	r0, r1
   130c8:	f00c f96c 	bl	1f3a4 <_XtlEventsTcp2Eth>
   130cc:	4606      	mov	r6, r0
		if(pDcpt->_TcpEnabledEvents != 0)
   130ce:	4b3d      	ldr	r3, [pc, #244]	; (131c4 <DRV_GMAC_EventMaskSet+0x118>)
   130d0:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
   130d4:	bb7b      	cbnz	r3, 13136 <DRV_GMAC_EventMaskSet+0x8a>
		pDcpt->_TcpEnabledEvents |= macEvMask;        // add more
   130d6:	4b3b      	ldr	r3, [pc, #236]	; (131c4 <DRV_GMAC_EventMaskSet+0x118>)
   130d8:	f8b3 104c 	ldrh.w	r1, [r3, #76]	; 0x4c
   130dc:	430c      	orrs	r4, r1
   130de:	f8a3 404c 	strh.w	r4, [r3, #76]	; 0x4c
		pDcpt->_EthEnabledEvents |= ethSetEvents;
   130e2:	f8b3 2050 	ldrh.w	r2, [r3, #80]	; 0x50
   130e6:	4332      	orrs	r2, r6
   130e8:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
		if(pDcpt->_TcpEnabledEvents != 0)
   130ec:	2c00      	cmp	r4, #0
   130ee:	d067      	beq.n	131c0 <DRV_GMAC_EventMaskSet+0x114>
			ethSetEvents &= ~pDcpt->_EthPendingEvents;		// keep just the new un-ack events			
   130f0:	f8b3 4052 	ldrh.w	r4, [r3, #82]	; 0x52
   130f4:	ea26 0404 	bic.w	r4, r6, r4
   130f8:	b2a4      	uxth	r4, r4
                if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queIdx].queueTxEnable != true)
   130fa:	f893 30ce 	ldrb.w	r3, [r3, #206]	; 0xce
   130fe:	2b01      	cmp	r3, #1
                    ethEvents = ethEvents & (~GMAC_EV_TX_ALL);
   13100:	bf1c      	itt	ne
   13102:	f024 04d0 	bicne.w	r4, r4, #208	; 0xd0
   13106:	b2a4      	uxthne	r4, r4
                if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queIdx].queueRxEnable != true)
   13108:	4b2e      	ldr	r3, [pc, #184]	; (131c4 <DRV_GMAC_EventMaskSet+0x118>)
   1310a:	f893 30cf 	ldrb.w	r3, [r3, #207]	; 0xcf
   1310e:	2b01      	cmp	r3, #1
   13110:	d004      	beq.n	1311c <DRV_GMAC_EventMaskSet+0x70>
                    ethEvents = ethEvents & (~GMAC_EV_RX_ALL);
   13112:	f424 6480 	bic.w	r4, r4, #1024	; 0x400
   13116:	f024 0406 	bic.w	r4, r4, #6
   1311a:	b2a4      	uxth	r4, r4
                DRV_PIC32CGMAC_LibReadInterruptStatus(queIdx);
   1311c:	2000      	movs	r0, #0
   1311e:	f00e feaf 	bl	21e80 <DRV_PIC32CGMAC_LibReadInterruptStatus>
                DRV_PIC32CGMAC_LibEnableInterrupt(queIdx, ethEvents);
   13122:	4621      	mov	r1, r4
   13124:	2000      	movs	r0, #0
   13126:	f00e feb1 	bl	21e8c <DRV_PIC32CGMAC_LibEnableInterrupt>
            DRV_PIC32CGMAC_LibSysInt_Enable(pMACDrv, GMAC_ALL_QUE_MASK);
   1312a:	213f      	movs	r1, #63	; 0x3f
   1312c:	4825      	ldr	r0, [pc, #148]	; (131c4 <DRV_GMAC_EventMaskSet+0x118>)
   1312e:	f00c fd85 	bl	1fc3c <DRV_PIC32CGMAC_LibSysInt_Enable>
	return true;
   13132:	4628      	mov	r0, r5
   13134:	e032      	b.n	1319c <DRV_GMAC_EventMaskSet+0xf0>
            DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, NULL);
   13136:	2200      	movs	r2, #0
   13138:	213f      	movs	r1, #63	; 0x3f
   1313a:	4822      	ldr	r0, [pc, #136]	; (131c4 <DRV_GMAC_EventMaskSet+0x118>)
   1313c:	f00d f8ba 	bl	202b4 <DRV_PIC32CGMAC_LibSysInt_Disable>
   13140:	e7c9      	b.n	130d6 <DRV_GMAC_EventMaskSet+0x2a>
		macEvMask &= pDcpt->_TcpEnabledEvents;                  // keep just the enabled ones
   13142:	4b20      	ldr	r3, [pc, #128]	; (131c4 <DRV_GMAC_EventMaskSet+0x118>)
   13144:	f8b3 604c 	ldrh.w	r6, [r3, #76]	; 0x4c
   13148:	4034      	ands	r4, r6
		ethClrEvents = _XtlEventsTcp2Eth(macEvMask);
   1314a:	4620      	mov	r0, r4
   1314c:	f00c f92a 	bl	1f3a4 <_XtlEventsTcp2Eth>
   13150:	4605      	mov	r5, r0
		if(pDcpt->_TcpEnabledEvents != 0)
   13152:	bb2e      	cbnz	r6, 131a0 <DRV_GMAC_EventMaskSet+0xf4>
		pDcpt->_TcpEnabledEvents &= ~macEvMask;     // clear some of them
   13154:	43e4      	mvns	r4, r4
   13156:	b224      	sxth	r4, r4
   13158:	4e1a      	ldr	r6, [pc, #104]	; (131c4 <DRV_GMAC_EventMaskSet+0x118>)
   1315a:	f8b6 304c 	ldrh.w	r3, [r6, #76]	; 0x4c
   1315e:	4023      	ands	r3, r4
   13160:	f8a6 304c 	strh.w	r3, [r6, #76]	; 0x4c
		pDcpt->_EthEnabledEvents &= ~ethClrEvents;
   13164:	43eb      	mvns	r3, r5
   13166:	b21b      	sxth	r3, r3
   13168:	f8b6 2050 	ldrh.w	r2, [r6, #80]	; 0x50
   1316c:	401a      	ands	r2, r3
   1316e:	f8a6 2050 	strh.w	r2, [r6, #80]	; 0x50
		pDcpt->_TcpPendingEvents &= ~macEvMask;     // remove them from un-ack list
   13172:	f8b6 204e 	ldrh.w	r2, [r6, #78]	; 0x4e
   13176:	4014      	ands	r4, r2
   13178:	f8a6 404e 	strh.w	r4, [r6, #78]	; 0x4e
		pDcpt->_EthPendingEvents &= ~ethClrEvents;
   1317c:	f8b6 2052 	ldrh.w	r2, [r6, #82]	; 0x52
   13180:	4013      	ands	r3, r2
   13182:	f8a6 3052 	strh.w	r3, [r6, #82]	; 0x52
            DRV_PIC32CGMAC_LibDisableInterrupt(queIdx, ethClrEvents);
   13186:	4629      	mov	r1, r5
   13188:	2000      	movs	r0, #0
   1318a:	f00e fe85 	bl	21e98 <DRV_PIC32CGMAC_LibDisableInterrupt>
            DRV_PIC32CGMAC_LibReadInterruptStatus(queIdx);
   1318e:	2000      	movs	r0, #0
   13190:	f00e fe76 	bl	21e80 <DRV_PIC32CGMAC_LibReadInterruptStatus>
		if(pDcpt->_TcpEnabledEvents != 0)
   13194:	f8b6 304c 	ldrh.w	r3, [r6, #76]	; 0x4c
   13198:	b943      	cbnz	r3, 131ac <DRV_GMAC_EventMaskSet+0x100>
	return true;
   1319a:	2001      	movs	r0, #1
}
   1319c:	b002      	add	sp, #8
   1319e:	bd70      	pop	{r4, r5, r6, pc}
            DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, intStat);
   131a0:	aa01      	add	r2, sp, #4
   131a2:	213f      	movs	r1, #63	; 0x3f
   131a4:	4807      	ldr	r0, [pc, #28]	; (131c4 <DRV_GMAC_EventMaskSet+0x118>)
   131a6:	f00d f885 	bl	202b4 <DRV_PIC32CGMAC_LibSysInt_Disable>
   131aa:	e7d3      	b.n	13154 <DRV_GMAC_EventMaskSet+0xa8>
            DRV_PIC32CGMAC_LibSysInt_Restore(pMACDrv, GMAC_ALL_QUE_MASK, intStat);
   131ac:	aa01      	add	r2, sp, #4
   131ae:	213f      	movs	r1, #63	; 0x3f
   131b0:	4630      	mov	r0, r6
   131b2:	f00e f8fb 	bl	213ac <DRV_PIC32CGMAC_LibSysInt_Restore>
   131b6:	e7f0      	b.n	1319a <DRV_GMAC_EventMaskSet+0xee>
        return false;
   131b8:	2000      	movs	r0, #0
   131ba:	4770      	bx	lr
   131bc:	2000      	movs	r0, #0
}
   131be:	4770      	bx	lr
	return true;
   131c0:	4628      	mov	r0, r5
   131c2:	e7eb      	b.n	1319c <DRV_GMAC_EventMaskSet+0xf0>
   131c4:	2000dab8 	.word	0x2000dab8

Disassembly of section .text._UDPv4TxAckFnc%286:

000131c8 <_UDPv4TxAckFnc>:
{
   131c8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   131cc:	4606      	mov	r6, r0
	while(pSkt != 0)
   131ce:	2900      	cmp	r1, #0
   131d0:	d071      	beq.n	132b6 <_UDPv4TxAckFnc+0xee>
   131d2:	460c      	mov	r4, r1
        status =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   131d4:	2000      	movs	r0, #0
   131d6:	f00e f961 	bl	2149c <OSAL_CRIT_Enter>
   131da:	4601      	mov	r1, r0
        sktIx = pSkt->sktIx;
   131dc:	f9b4 5012 	ldrsh.w	r5, [r4, #18]
        if(UDPSocketDcpt == 0 || sktIx < 0 || sktIx >= nUdpSockets || pSkt != UDPSocketDcpt[sktIx])
   131e0:	4b3e      	ldr	r3, [pc, #248]	; (132dc <_UDPv4TxAckFnc+0x114>)
   131e2:	681b      	ldr	r3, [r3, #0]
   131e4:	2b00      	cmp	r3, #0
   131e6:	d073      	beq.n	132d0 <_UDPv4TxAckFnc+0x108>
   131e8:	2d00      	cmp	r5, #0
   131ea:	db73      	blt.n	132d4 <_UDPv4TxAckFnc+0x10c>
   131ec:	4a3c      	ldr	r2, [pc, #240]	; (132e0 <_UDPv4TxAckFnc+0x118>)
   131ee:	6812      	ldr	r2, [r2, #0]
   131f0:	4295      	cmp	r5, r2
   131f2:	da71      	bge.n	132d8 <_UDPv4TxAckFnc+0x110>
   131f4:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
   131f8:	42a3      	cmp	r3, r4
   131fa:	d001      	beq.n	13200 <_UDPv4TxAckFnc+0x38>
        critLock = true;
   131fc:	2401      	movs	r4, #1
   131fe:	e05d      	b.n	132bc <_UDPv4TxAckFnc+0xf4>
        if(pPkt->modPktData != 0)
   13200:	8e73      	ldrh	r3, [r6, #50]	; 0x32
   13202:	b14b      	cbz	r3, 13218 <_UDPv4TxAckFnc+0x50>
            pPkt->modPktData = 0;
   13204:	f04f 0900 	mov.w	r9, #0
   13208:	f8a6 9032 	strh.w	r9, [r6, #50]	; 0x32
    const void* sigParam = 0;
   1320c:	46c8      	mov	r8, r9
    TCPIP_UDP_SIGNAL_FUNCTION sigHandler = 0;
   1320e:	464f      	mov	r7, r9
            loopPkt = true;
   13210:	f04f 0a01 	mov.w	sl, #1
    bool freePkt = true;
   13214:	2400      	movs	r4, #0
   13216:	e014      	b.n	13242 <_UDPv4TxAckFnc+0x7a>
        if((pSkt->sigMask & TCPIP_UDP_SIGNAL_TX_DONE) != 0)
   13218:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
   1321c:	f013 0f01 	tst.w	r3, #1
   13220:	d020      	beq.n	13264 <_UDPv4TxAckFnc+0x9c>
            sigHandler = pSkt->sigHandler;
   13222:	6d27      	ldr	r7, [r4, #80]	; 0x50
            sigParam = pSkt->sigParam;
   13224:	f8d4 8054 	ldr.w	r8, [r4, #84]	; 0x54
            pktIf = pPkt->pktIf;
   13228:	f8d6 9028 	ldr.w	r9, [r6, #40]	; 0x28
        if(pSkt->pV4Pkt != (IPV4_PACKET*)pPkt)
   1322c:	68e3      	ldr	r3, [r4, #12]
   1322e:	42b3      	cmp	r3, r6
   13230:	d01d      	beq.n	1326e <_UDPv4TxAckFnc+0xa6>
        pSkt->txAllocCnt--;
   13232:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
   13236:	3b01      	subs	r3, #1
   13238:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
    bool    loopPkt = false;
   1323c:	f04f 0a00 	mov.w	sl, #0
    bool freePkt = true;
   13240:	2401      	movs	r4, #1
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   13242:	2000      	movs	r0, #0
   13244:	f00e fa59 	bl	216fa <OSAL_CRIT_Leave>
    if(loopPkt)
   13248:	f1ba 0f00 	cmp.w	sl, #0
   1324c:	d129      	bne.n	132a2 <_UDPv4TxAckFnc+0xda>
    if(freePkt)
   1324e:	2c00      	cmp	r4, #0
   13250:	d13a      	bne.n	132c8 <_UDPv4TxAckFnc+0x100>
    if(sigHandler)
   13252:	b127      	cbz	r7, 1325e <_UDPv4TxAckFnc+0x96>
        (*sigHandler)(sktIx, pktIf, TCPIP_UDP_SIGNAL_TX_DONE, sigParam);
   13254:	4643      	mov	r3, r8
   13256:	2201      	movs	r2, #1
   13258:	4649      	mov	r1, r9
   1325a:	4628      	mov	r0, r5
   1325c:	47b8      	blx	r7
}
   1325e:	2000      	movs	r0, #0
   13260:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    const void* sigParam = 0;
   13264:	f04f 0800 	mov.w	r8, #0
    TCPIP_UDP_SIGNAL_FUNCTION sigHandler = 0;
   13268:	4647      	mov	r7, r8
    TCPIP_NET_HANDLE pktIf = 0;
   1326a:	46c1      	mov	r9, r8
   1326c:	e7de      	b.n	1322c <_UDPv4TxAckFnc+0x64>
    pPkt->macPkt.pDSeg->segLen = 0;
   1326e:	6933      	ldr	r3, [r6, #16]
   13270:	2200      	movs	r2, #0
   13272:	819a      	strh	r2, [r3, #12]
    if(pSkt->flags.txSplitAlloc)
   13274:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
   13278:	f013 0f02 	tst.w	r3, #2
        ((UDP_V4_PACKET*)pPkt)->zcSeg->segLen = 0;
   1327c:	bf19      	ittee	ne
   1327e:	4613      	movne	r3, r2
   13280:	f8a6 2050 	strhne.w	r2, [r6, #80]	; 0x50
        pSkt->txWrite = pSkt->txStart;
   13284:	6823      	ldreq	r3, [r4, #0]
   13286:	60a3      	streq	r3, [r4, #8]
    pPkt->macPkt.pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED;
   13288:	8c73      	ldrh	r3, [r6, #34]	; 0x22
   1328a:	f023 0308 	bic.w	r3, r3, #8
   1328e:	8473      	strh	r3, [r6, #34]	; 0x22
    bool    loopPkt = false;
   13290:	f04f 0a00 	mov.w	sl, #0
   13294:	e7be      	b.n	13214 <_UDPv4TxAckFnc+0x4c>
    if(critLock)
   13296:	f04f 0800 	mov.w	r8, #0
   1329a:	4647      	mov	r7, r8
   1329c:	46c2      	mov	sl, r8
   1329e:	46c1      	mov	r9, r8
   132a0:	e7cf      	b.n	13242 <_UDPv4TxAckFnc+0x7a>
        pPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_MCAST;
   132a2:	8c73      	ldrh	r3, [r6, #34]	; 0x22
   132a4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   132a8:	8473      	strh	r3, [r6, #34]	; 0x22
        _TCPIPStackInsertRxPacket((TCPIP_NET_IF*)pPkt->pktIf, pPkt, true);
   132aa:	2201      	movs	r2, #1
   132ac:	4631      	mov	r1, r6
   132ae:	6ab0      	ldr	r0, [r6, #40]	; 0x28
   132b0:	f007 fc04 	bl	1aabc <_TCPIPStackInsertRxPacket>
        return false;
   132b4:	e7d3      	b.n	1325e <_UDPv4TxAckFnc+0x96>
    OSAL_CRITSECT_DATA_TYPE status = 0;
   132b6:	2100      	movs	r1, #0
    bool critLock = false;
   132b8:	460c      	mov	r4, r1
    UDP_SOCKET   sktIx = 0;
   132ba:	460d      	mov	r5, r1
    if(critLock)
   132bc:	2c00      	cmp	r4, #0
   132be:	d1ea      	bne.n	13296 <_UDPv4TxAckFnc+0xce>
   132c0:	f04f 0800 	mov.w	r8, #0
   132c4:	4647      	mov	r7, r8
   132c6:	46c1      	mov	r9, r8
            TCPIP_PKT_PacketFree(pPkt);
   132c8:	4630      	mov	r0, r6
   132ca:	f00a fe6d 	bl	1dfa8 <_TCPIP_PKT_PacketFree>
   132ce:	e7c0      	b.n	13252 <_UDPv4TxAckFnc+0x8a>
        critLock = true;
   132d0:	2401      	movs	r4, #1
   132d2:	e7f3      	b.n	132bc <_UDPv4TxAckFnc+0xf4>
   132d4:	2401      	movs	r4, #1
   132d6:	e7f1      	b.n	132bc <_UDPv4TxAckFnc+0xf4>
   132d8:	2401      	movs	r4, #1
   132da:	e7ef      	b.n	132bc <_UDPv4TxAckFnc+0xf4>
   132dc:	2000e65c 	.word	0x2000e65c
   132e0:	2000e660 	.word	0x2000e660

Disassembly of section .text.wc_RNG_GenerateBlock%287:

000132e4 <wc_RNG_GenerateBlock>:
    if (rng == NULL || output == NULL)
   132e4:	2800      	cmp	r0, #0
   132e6:	d074      	beq.n	133d2 <wc_RNG_GenerateBlock+0xee>
{
   132e8:	b5f0      	push	{r4, r5, r6, r7, lr}
   132ea:	b0a5      	sub	sp, #148	; 0x94
   132ec:	4606      	mov	r6, r0
    if (rng == NULL || output == NULL)
   132ee:	2900      	cmp	r1, #0
   132f0:	d073      	beq.n	133da <wc_RNG_GenerateBlock+0xf6>
    if (sz == 0)
   132f2:	2a00      	cmp	r2, #0
   132f4:	d074      	beq.n	133e0 <wc_RNG_GenerateBlock+0xfc>
   132f6:	4615      	mov	r5, r2
   132f8:	460c      	mov	r4, r1
    if (rng->devId != INVALID_DEVID) {
   132fa:	6943      	ldr	r3, [r0, #20]
   132fc:	f113 0f02 	cmn.w	r3, #2
   13300:	d116      	bne.n	13330 <wc_RNG_GenerateBlock+0x4c>
    if (sz > RNG_MAX_BLOCK_LEN)
   13302:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
   13306:	d86f      	bhi.n	133e8 <wc_RNG_GenerateBlock+0x104>
    if (rng->status != DRBG_OK)
   13308:	7c33      	ldrb	r3, [r6, #16]
   1330a:	2b01      	cmp	r3, #1
   1330c:	d16f      	bne.n	133ee <wc_RNG_GenerateBlock+0x10a>
    ret = Hash_DRBG_Generate((DRBG_internal *)rng->drbg, output, sz);
   1330e:	462a      	mov	r2, r5
   13310:	4621      	mov	r1, r4
   13312:	68f0      	ldr	r0, [r6, #12]
   13314:	f7f8 fc64 	bl	bbe0 <Hash_DRBG_Generate>
   13318:	4603      	mov	r3, r0
    if (ret == DRBG_NEED_RESEED) {
   1331a:	2802      	cmp	r0, #2
   1331c:	d010      	beq.n	13340 <wc_RNG_GenerateBlock+0x5c>
    if (ret == DRBG_SUCCESS) {
   1331e:	2b00      	cmp	r3, #0
   13320:	d05f      	beq.n	133e2 <wc_RNG_GenerateBlock+0xfe>
    else if (ret == DRBG_CONT_FAILURE) {
   13322:	2b03      	cmp	r3, #3
   13324:	d050      	beq.n	133c8 <wc_RNG_GenerateBlock+0xe4>
        rng->status = DRBG_FAILED;
   13326:	2302      	movs	r3, #2
   13328:	7433      	strb	r3, [r6, #16]
        ret = RNG_FAILURE_E;
   1332a:	f06f 03c6 	mvn.w	r3, #198	; 0xc6
   1332e:	e058      	b.n	133e2 <wc_RNG_GenerateBlock+0xfe>
        ret = wc_CryptoCb_RandomBlock(rng, output, sz);
   13330:	f008 fa76 	bl	1b820 <wc_CryptoCb_RandomBlock>
   13334:	4603      	mov	r3, r0
        if (ret != CRYPTOCB_UNAVAILABLE)
   13336:	f46f 7287 	mvn.w	r2, #270	; 0x10e
   1333a:	4290      	cmp	r0, r2
   1333c:	d151      	bne.n	133e2 <wc_RNG_GenerateBlock+0xfe>
   1333e:	e7e0      	b.n	13302 <wc_RNG_GenerateBlock+0x1e>
        ret = wc_RNG_HealthTest(1, seedA, sizeof(seedA_data),
   13340:	2380      	movs	r3, #128	; 0x80
   13342:	9302      	str	r3, [sp, #8]
   13344:	ab04      	add	r3, sp, #16
   13346:	9301      	str	r3, [sp, #4]
   13348:	2320      	movs	r3, #32
   1334a:	9300      	str	r3, [sp, #0]
   1334c:	4b29      	ldr	r3, [pc, #164]	; (133f4 <wc_RNG_GenerateBlock+0x110>)
   1334e:	2230      	movs	r2, #48	; 0x30
   13350:	4929      	ldr	r1, [pc, #164]	; (133f8 <wc_RNG_GenerateBlock+0x114>)
   13352:	2001      	movs	r0, #1
   13354:	f00c fb0c 	bl	1f970 <wc_RNG_HealthTest>
        if (ret == 0) {
   13358:	4601      	mov	r1, r0
   1335a:	2800      	cmp	r0, #0
   1335c:	d134      	bne.n	133c8 <wc_RNG_GenerateBlock+0xe4>
   1335e:	f10d 020f 	add.w	r2, sp, #15
   13362:	4826      	ldr	r0, [pc, #152]	; (133fc <wc_RNG_GenerateBlock+0x118>)
   13364:	f10d 0c8f 	add.w	ip, sp, #143	; 0x8f
        compareSum |= a[i] ^ b[i];
   13368:	f812 3f01 	ldrb.w	r3, [r2, #1]!
   1336c:	f810 7f01 	ldrb.w	r7, [r0, #1]!
   13370:	407b      	eors	r3, r7
   13372:	4319      	orrs	r1, r3
    for (i = 0; i < length; i++) {
   13374:	4562      	cmp	r2, ip
   13376:	d1f7      	bne.n	13368 <wc_RNG_GenerateBlock+0x84>
            if (ConstantCompare(check, outputA,
   13378:	bb31      	cbnz	r1, 133c8 <wc_RNG_GenerateBlock+0xe4>
            ret = wc_GenerateSeed(&rng->seed, newSeed,
   1337a:	2224      	movs	r2, #36	; 0x24
   1337c:	a904      	add	r1, sp, #16
   1337e:	4630      	mov	r0, r6
   13380:	f006 fdd6 	bl	19f30 <wc_GenerateSeed>
            if (ret != 0)
   13384:	b150      	cbz	r0, 1339c <wc_RNG_GenerateBlock+0xb8>
                ret = DRBG_FAILURE;
   13386:	2301      	movs	r3, #1
    volatile byte* z = (volatile byte*)mem;
   13388:	a904      	add	r1, sp, #16
    while (len--) *z++ = 0;
   1338a:	2400      	movs	r4, #0
   1338c:	a80d      	add	r0, sp, #52	; 0x34
   1338e:	460a      	mov	r2, r1
   13390:	f802 4b01 	strb.w	r4, [r2], #1
   13394:	4611      	mov	r1, r2
   13396:	4282      	cmp	r2, r0
   13398:	d1f9      	bne.n	1338e <wc_RNG_GenerateBlock+0xaa>
   1339a:	e7c0      	b.n	1331e <wc_RNG_GenerateBlock+0x3a>
                ret = wc_RNG_TestSeed(newSeed, SEED_SZ + SEED_BLOCK_SZ);
   1339c:	2124      	movs	r1, #36	; 0x24
   1339e:	a804      	add	r0, sp, #16
   133a0:	f007 fbf4 	bl	1ab8c <wc_RNG_TestSeed>
            if (ret == DRBG_SUCCESS)
   133a4:	4603      	mov	r3, r0
   133a6:	2800      	cmp	r0, #0
   133a8:	d1ee      	bne.n	13388 <wc_RNG_GenerateBlock+0xa4>
	      ret = Hash_DRBG_Reseed((DRBG_internal *)rng->drbg, newSeed + SEED_BLOCK_SZ,
   133aa:	2220      	movs	r2, #32
   133ac:	a905      	add	r1, sp, #20
   133ae:	68f0      	ldr	r0, [r6, #12]
   133b0:	f003 fd2e 	bl	16e10 <Hash_DRBG_Reseed>
            if (ret == DRBG_SUCCESS)
   133b4:	4603      	mov	r3, r0
   133b6:	2800      	cmp	r0, #0
   133b8:	d1e6      	bne.n	13388 <wc_RNG_GenerateBlock+0xa4>
	      ret = Hash_DRBG_Generate((DRBG_internal *)rng->drbg, output, sz);
   133ba:	462a      	mov	r2, r5
   133bc:	4621      	mov	r1, r4
   133be:	68f0      	ldr	r0, [r6, #12]
   133c0:	f7f8 fc0e 	bl	bbe0 <Hash_DRBG_Generate>
   133c4:	4603      	mov	r3, r0
   133c6:	e7df      	b.n	13388 <wc_RNG_GenerateBlock+0xa4>
        rng->status = DRBG_CONT_FAILED;
   133c8:	2303      	movs	r3, #3
   133ca:	7433      	strb	r3, [r6, #16]
        ret = DRBG_CONT_FIPS_E;
   133cc:	f06f 03d0 	mvn.w	r3, #208	; 0xd0
   133d0:	e007      	b.n	133e2 <wc_RNG_GenerateBlock+0xfe>
        return BAD_FUNC_ARG;
   133d2:	f06f 03ac 	mvn.w	r3, #172	; 0xac
}
   133d6:	4618      	mov	r0, r3
   133d8:	4770      	bx	lr
        return BAD_FUNC_ARG;
   133da:	f06f 03ac 	mvn.w	r3, #172	; 0xac
   133de:	e000      	b.n	133e2 <wc_RNG_GenerateBlock+0xfe>
        return 0; 
   133e0:	2300      	movs	r3, #0
}
   133e2:	4618      	mov	r0, r3
   133e4:	b025      	add	sp, #148	; 0x94
   133e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return BAD_FUNC_ARG;
   133e8:	f06f 03ac 	mvn.w	r3, #172	; 0xac
   133ec:	e7f9      	b.n	133e2 <wc_RNG_GenerateBlock+0xfe>
        return RNG_FAILURE_E;
   133ee:	f06f 03c6 	mvn.w	r3, #198	; 0xc6
   133f2:	e7f6      	b.n	133e2 <wc_RNG_GenerateBlock+0xfe>
   133f4:	00020b30 	.word	0x00020b30
   133f8:	0001f2e4 	.word	0x0001f2e4
   133fc:	00019263 	.word	0x00019263

Disassembly of section .text.xTaskIncrementTick%288:

00013400 <xTaskIncrementTick>:
{
   13400:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   13404:	4b38      	ldr	r3, [pc, #224]	; (134e8 <xTaskIncrementTick+0xe8>)
   13406:	681b      	ldr	r3, [r3, #0]
   13408:	2b00      	cmp	r3, #0
   1340a:	d167      	bne.n	134dc <xTaskIncrementTick+0xdc>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
   1340c:	4b37      	ldr	r3, [pc, #220]	; (134ec <xTaskIncrementTick+0xec>)
   1340e:	681f      	ldr	r7, [r3, #0]
   13410:	3701      	adds	r7, #1
		xTickCount = xConstTickCount;
   13412:	601f      	str	r7, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
   13414:	b1bf      	cbz	r7, 13446 <xTaskIncrementTick+0x46>
		if( xConstTickCount >= xNextTaskUnblockTime )
   13416:	4b36      	ldr	r3, [pc, #216]	; (134f0 <xTaskIncrementTick+0xf0>)
   13418:	681b      	ldr	r3, [r3, #0]
   1341a:	42bb      	cmp	r3, r7
   1341c:	d920      	bls.n	13460 <xTaskIncrementTick+0x60>
BaseType_t xSwitchRequired = pdFALSE;
   1341e:	2500      	movs	r5, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   13420:	4b34      	ldr	r3, [pc, #208]	; (134f4 <xTaskIncrementTick+0xf4>)
   13422:	681b      	ldr	r3, [r3, #0]
   13424:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13426:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   1342a:	009b      	lsls	r3, r3, #2
   1342c:	4a32      	ldr	r2, [pc, #200]	; (134f8 <xTaskIncrementTick+0xf8>)
   1342e:	58d3      	ldr	r3, [r2, r3]
				xSwitchRequired = pdTRUE;
   13430:	2b02      	cmp	r3, #2
   13432:	bf28      	it	cs
   13434:	2501      	movcs	r5, #1
			if( xYieldPending != pdFALSE )
   13436:	4b31      	ldr	r3, [pc, #196]	; (134fc <xTaskIncrementTick+0xfc>)
   13438:	681b      	ldr	r3, [r3, #0]
				xSwitchRequired = pdTRUE;
   1343a:	2b00      	cmp	r3, #0
   1343c:	bf18      	it	ne
   1343e:	2501      	movne	r5, #1
}
   13440:	4628      	mov	r0, r5
   13442:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			taskSWITCH_DELAYED_LISTS();
   13446:	4a2e      	ldr	r2, [pc, #184]	; (13500 <xTaskIncrementTick+0x100>)
   13448:	6811      	ldr	r1, [r2, #0]
   1344a:	4b2e      	ldr	r3, [pc, #184]	; (13504 <xTaskIncrementTick+0x104>)
   1344c:	6818      	ldr	r0, [r3, #0]
   1344e:	6010      	str	r0, [r2, #0]
   13450:	6019      	str	r1, [r3, #0]
   13452:	4a2d      	ldr	r2, [pc, #180]	; (13508 <xTaskIncrementTick+0x108>)
   13454:	6813      	ldr	r3, [r2, #0]
   13456:	3301      	adds	r3, #1
   13458:	6013      	str	r3, [r2, #0]
   1345a:	f00c fa73 	bl	1f944 <prvResetNextTaskUnblockTime>
   1345e:	e7da      	b.n	13416 <xTaskIncrementTick+0x16>
BaseType_t xSwitchRequired = pdFALSE;
   13460:	2500      	movs	r5, #0
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   13462:	f8df 809c 	ldr.w	r8, [pc, #156]	; 13500 <xTaskIncrementTick+0x100>
					prvAddTaskToReadyList( pxTCB );
   13466:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 13510 <xTaskIncrementTick+0x110>
   1346a:	f8df a08c 	ldr.w	sl, [pc, #140]	; 134f8 <xTaskIncrementTick+0xf8>
   1346e:	e021      	b.n	134b4 <xTaskIncrementTick+0xb4>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   13470:	4b1f      	ldr	r3, [pc, #124]	; (134f0 <xTaskIncrementTick+0xf0>)
   13472:	f04f 32ff 	mov.w	r2, #4294967295
   13476:	601a      	str	r2, [r3, #0]
					break;
   13478:	e7d2      	b.n	13420 <xTaskIncrementTick+0x20>
						xNextTaskUnblockTime = xItemValue;
   1347a:	4a1d      	ldr	r2, [pc, #116]	; (134f0 <xTaskIncrementTick+0xf0>)
   1347c:	6013      	str	r3, [r2, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
   1347e:	e7cf      	b.n	13420 <xTaskIncrementTick+0x20>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   13480:	f104 0018 	add.w	r0, r4, #24
   13484:	f00d f816 	bl	204b4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   13488:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   1348a:	f8d9 2000 	ldr.w	r2, [r9]
   1348e:	2301      	movs	r3, #1
   13490:	4083      	lsls	r3, r0
   13492:	4313      	orrs	r3, r2
   13494:	f8c9 3000 	str.w	r3, [r9]
   13498:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   1349c:	4631      	mov	r1, r6
   1349e:	eb0a 0080 	add.w	r0, sl, r0, lsl #2
   134a2:	f00e f940 	bl	21726 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   134a6:	4b13      	ldr	r3, [pc, #76]	; (134f4 <xTaskIncrementTick+0xf4>)
   134a8:	681b      	ldr	r3, [r3, #0]
   134aa:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   134ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
   134ae:	429a      	cmp	r2, r3
   134b0:	bf28      	it	cs
   134b2:	2501      	movcs	r5, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   134b4:	f8d8 3000 	ldr.w	r3, [r8]
   134b8:	681b      	ldr	r3, [r3, #0]
   134ba:	2b00      	cmp	r3, #0
   134bc:	d0d8      	beq.n	13470 <xTaskIncrementTick+0x70>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   134be:	f8d8 3000 	ldr.w	r3, [r8]
   134c2:	68db      	ldr	r3, [r3, #12]
   134c4:	68dc      	ldr	r4, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
   134c6:	6863      	ldr	r3, [r4, #4]
					if( xConstTickCount < xItemValue )
   134c8:	429f      	cmp	r7, r3
   134ca:	d3d6      	bcc.n	1347a <xTaskIncrementTick+0x7a>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   134cc:	1d26      	adds	r6, r4, #4
   134ce:	4630      	mov	r0, r6
   134d0:	f00c fff0 	bl	204b4 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   134d4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   134d6:	2b00      	cmp	r3, #0
   134d8:	d1d2      	bne.n	13480 <xTaskIncrementTick+0x80>
   134da:	e7d5      	b.n	13488 <xTaskIncrementTick+0x88>
		++xPendedTicks;
   134dc:	4a0b      	ldr	r2, [pc, #44]	; (1350c <xTaskIncrementTick+0x10c>)
   134de:	6813      	ldr	r3, [r2, #0]
   134e0:	3301      	adds	r3, #1
   134e2:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
   134e4:	2500      	movs	r5, #0
	return xSwitchRequired;
   134e6:	e7ab      	b.n	13440 <xTaskIncrementTick+0x40>
   134e8:	2000e6b8 	.word	0x2000e6b8
   134ec:	2000e6d8 	.word	0x2000e6d8
   134f0:	2000e6c8 	.word	0x2000e6c8
   134f4:	2000e6a4 	.word	0x2000e6a4
   134f8:	2000e080 	.word	0x2000e080
   134fc:	2000e6dc 	.word	0x2000e6dc
   13500:	2000e6a8 	.word	0x2000e6a8
   13504:	2000e6ac 	.word	0x2000e6ac
   13508:	2000e6cc 	.word	0x2000e6cc
   1350c:	2000e6d0 	.word	0x2000e6d0
   13510:	2000e6c0 	.word	0x2000e6c0

Disassembly of section .text.CommandPingHandler%289:

00013514 <CommandPingHandler>:
    if(result == TCPIP_ICMP_ECHO_REQUEST_RES_OK)
   13514:	2a00      	cmp	r2, #0
   13516:	d168      	bne.n	135ea <CommandPingHandler+0xd6>
{
   13518:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1351c:	b088      	sub	sp, #32
        if(pEchoReq->identifier != icmpIdentifier)
   1351e:	8943      	ldrh	r3, [r0, #10]
   13520:	4a34      	ldr	r2, [pc, #208]	; (135f4 <CommandPingHandler+0xe0>)
   13522:	8812      	ldrh	r2, [r2, #0]
   13524:	1a9a      	subs	r2, r3, r2
   13526:	bf18      	it	ne
   13528:	2201      	movne	r2, #1
        if(pEchoReq->sequenceNumber != icmpSequenceNo)
   1352a:	8901      	ldrh	r1, [r0, #8]
   1352c:	4b32      	ldr	r3, [pc, #200]	; (135f8 <CommandPingHandler+0xe4>)
   1352e:	881b      	ldrh	r3, [r3, #0]
   13530:	4299      	cmp	r1, r3
            errorMask |= 0x2;
   13532:	bf18      	it	ne
   13534:	f042 0202 	orrne.w	r2, r2, #2
   13538:	4680      	mov	r8, r0
        if(pEchoReq->dataSize != icmpPingSize)
   1353a:	8a03      	ldrh	r3, [r0, #16]
   1353c:	492f      	ldr	r1, [pc, #188]	; (135fc <CommandPingHandler+0xe8>)
   1353e:	680f      	ldr	r7, [r1, #0]
   13540:	42bb      	cmp	r3, r7
   13542:	d028      	beq.n	13596 <CommandPingHandler+0x82>
            errorMask |= 0x8;
   13544:	f042 0208 	orr.w	r2, r2, #8
        int checkSize = pEchoReq->dataSize < icmpPingSize ? pEchoReq->dataSize : icmpPingSize;
   13548:	429f      	cmp	r7, r3
   1354a:	bfa8      	it	ge
   1354c:	461f      	movge	r7, r3
        uint8_t* pDst = pEchoReq->pData;
   1354e:	68c1      	ldr	r1, [r0, #12]
        for(ix = 0; ix < checkSize; ix++)
   13550:	2f00      	cmp	r7, #0
   13552:	dd12      	ble.n	1357a <CommandPingHandler+0x66>
            if(*pSrc++ != *pDst++)
   13554:	4b2a      	ldr	r3, [pc, #168]	; (13600 <CommandPingHandler+0xec>)
   13556:	7818      	ldrb	r0, [r3, #0]
   13558:	f811 3b01 	ldrb.w	r3, [r1], #1
   1355c:	4298      	cmp	r0, r3
   1355e:	d10a      	bne.n	13576 <CommandPingHandler+0x62>
   13560:	4c28      	ldr	r4, [pc, #160]	; (13604 <CommandPingHandler+0xf0>)
        for(ix = 0; ix < checkSize; ix++)
   13562:	2300      	movs	r3, #0
   13564:	3301      	adds	r3, #1
   13566:	42bb      	cmp	r3, r7
   13568:	da18      	bge.n	1359c <CommandPingHandler+0x88>
            if(*pSrc++ != *pDst++)
   1356a:	f814 6b01 	ldrb.w	r6, [r4], #1
   1356e:	f811 5b01 	ldrb.w	r5, [r1], #1
   13572:	42ae      	cmp	r6, r5
   13574:	d0f6      	beq.n	13564 <CommandPingHandler+0x50>
                errorMask |= 0x10;
   13576:	f042 0210 	orr.w	r2, r2, #16
            (*pTcpipCmdDevice->pCmdApi->print)(icmpCmdIoParam, "Ping: wrong reply received. Mask: 0x%2x\r\n", errorMask);
   1357a:	4b23      	ldr	r3, [pc, #140]	; (13608 <CommandPingHandler+0xf4>)
   1357c:	681b      	ldr	r3, [r3, #0]
   1357e:	681b      	ldr	r3, [r3, #0]
   13580:	685b      	ldr	r3, [r3, #4]
   13582:	4922      	ldr	r1, [pc, #136]	; (1360c <CommandPingHandler+0xf8>)
   13584:	4822      	ldr	r0, [pc, #136]	; (13610 <CommandPingHandler+0xfc>)
   13586:	6800      	ldr	r0, [r0, #0]
   13588:	4798      	blx	r3
    icmpReqHandle = 0;
   1358a:	4b22      	ldr	r3, [pc, #136]	; (13614 <CommandPingHandler+0x100>)
   1358c:	2200      	movs	r2, #0
   1358e:	601a      	str	r2, [r3, #0]
}
   13590:	b008      	add	sp, #32
   13592:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        uint8_t* pDst = pEchoReq->pData;
   13596:	68c1      	ldr	r1, [r0, #12]
        for(ix = 0; ix < checkSize; ix++)
   13598:	2f00      	cmp	r7, #0
   1359a:	dcdb      	bgt.n	13554 <CommandPingHandler+0x40>
        if(errorMask != 0)
   1359c:	2a00      	cmp	r2, #0
   1359e:	d1ec      	bne.n	1357a <CommandPingHandler+0x66>
            uint32_t pingTicks = SYS_TMR_TickCountGet() - icmpStartTick;
   135a0:	f00c fd04 	bl	1ffac <SYS_TMR_TickCountGet>
   135a4:	4b1c      	ldr	r3, [pc, #112]	; (13618 <CommandPingHandler+0x104>)
   135a6:	681c      	ldr	r4, [r3, #0]
   135a8:	1b00      	subs	r0, r0, r4
            int pingMs = (pingTicks * 1000) / SYS_TMR_TickCounterFrequencyGet();
   135aa:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
   135ae:	fb04 f400 	mul.w	r4, r4, r0
   135b2:	f00c fd23 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
   135b6:	fbb4 f4f0 	udiv	r4, r4, r0
                pingMs = 1;
   135ba:	2c00      	cmp	r4, #0
   135bc:	bf08      	it	eq
   135be:	2401      	moveq	r4, #1
            TCPIP_Helper_IPAddressToString(&pEchoReq->targetAddr, addBuff, sizeof(addBuff));
   135c0:	2214      	movs	r2, #20
   135c2:	a903      	add	r1, sp, #12
   135c4:	f108 0004 	add.w	r0, r8, #4
   135c8:	f009 f8cc 	bl	1c764 <TCPIP_Helper_IPAddressToString>
            (*pTcpipCmdDevice->pCmdApi->print)(icmpCmdIoParam, "Ping: reply[%d] from %s: time = %dms\r\n", ++icmpAckRecv, addBuff, pingMs);
   135cc:	4b0e      	ldr	r3, [pc, #56]	; (13608 <CommandPingHandler+0xf4>)
   135ce:	681b      	ldr	r3, [r3, #0]
   135d0:	681b      	ldr	r3, [r3, #0]
   135d2:	685d      	ldr	r5, [r3, #4]
   135d4:	4b11      	ldr	r3, [pc, #68]	; (1361c <CommandPingHandler+0x108>)
   135d6:	681a      	ldr	r2, [r3, #0]
   135d8:	3201      	adds	r2, #1
   135da:	601a      	str	r2, [r3, #0]
   135dc:	9400      	str	r4, [sp, #0]
   135de:	ab03      	add	r3, sp, #12
   135e0:	490f      	ldr	r1, [pc, #60]	; (13620 <CommandPingHandler+0x10c>)
   135e2:	480b      	ldr	r0, [pc, #44]	; (13610 <CommandPingHandler+0xfc>)
   135e4:	6800      	ldr	r0, [r0, #0]
   135e6:	47a8      	blx	r5
   135e8:	e7cf      	b.n	1358a <CommandPingHandler+0x76>
    icmpReqHandle = 0;
   135ea:	4b0a      	ldr	r3, [pc, #40]	; (13614 <CommandPingHandler+0x100>)
   135ec:	2200      	movs	r2, #0
   135ee:	601a      	str	r2, [r3, #0]
   135f0:	4770      	bx	lr
   135f2:	bf00      	nop
   135f4:	2000e716 	.word	0x2000e716
   135f8:	2000e718 	.word	0x2000e718
   135fc:	2000e5f0 	.word	0x2000e5f0
   13600:	2000ca04 	.word	0x2000ca04
   13604:	2000ca05 	.word	0x2000ca05
   13608:	2000e5e8 	.word	0x2000e5e8
   1360c:	000015a0 	.word	0x000015a0
   13610:	2000e5c0 	.word	0x2000e5c0
   13614:	2000e5d0 	.word	0x2000e5d0
   13618:	2000e5d8 	.word	0x2000e5d8
   1361c:	2000e5bc 	.word	0x2000e5bc
   13620:	000015cc 	.word	0x000015cc

Disassembly of section .text%290:

00013624 <__gedf2>:
   13624:	f04f 3cff 	mov.w	ip, #4294967295
   13628:	e006      	b.n	13638 <__cmpdf2+0x4>
   1362a:	bf00      	nop

0001362c <__ledf2>:
   1362c:	f04f 0c01 	mov.w	ip, #1
   13630:	e002      	b.n	13638 <__cmpdf2+0x4>
   13632:	bf00      	nop

00013634 <__cmpdf2>:
   13634:	f04f 0c01 	mov.w	ip, #1
   13638:	f84d cd04 	str.w	ip, [sp, #-4]!
   1363c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   13640:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   13644:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   13648:	bf18      	it	ne
   1364a:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
   1364e:	d01b      	beq.n	13688 <__cmpdf2+0x54>
   13650:	b001      	add	sp, #4
   13652:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
   13656:	bf0c      	ite	eq
   13658:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
   1365c:	ea91 0f03 	teqne	r1, r3
   13660:	bf02      	ittt	eq
   13662:	ea90 0f02 	teqeq	r0, r2
   13666:	2000      	moveq	r0, #0
   13668:	4770      	bxeq	lr
   1366a:	f110 0f00 	cmn.w	r0, #0
   1366e:	ea91 0f03 	teq	r1, r3
   13672:	bf58      	it	pl
   13674:	4299      	cmppl	r1, r3
   13676:	bf08      	it	eq
   13678:	4290      	cmpeq	r0, r2
   1367a:	bf2c      	ite	cs
   1367c:	17d8      	asrcs	r0, r3, #31
   1367e:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
   13682:	f040 0001 	orr.w	r0, r0, #1
   13686:	4770      	bx	lr
   13688:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   1368c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   13690:	d102      	bne.n	13698 <__cmpdf2+0x64>
   13692:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
   13696:	d107      	bne.n	136a8 <__cmpdf2+0x74>
   13698:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   1369c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   136a0:	d1d6      	bne.n	13650 <__cmpdf2+0x1c>
   136a2:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
   136a6:	d0d3      	beq.n	13650 <__cmpdf2+0x1c>
   136a8:	f85d 0b04 	ldr.w	r0, [sp], #4
   136ac:	4770      	bx	lr
   136ae:	bf00      	nop

000136b0 <__aeabi_cdrcmple>:
   136b0:	4684      	mov	ip, r0
   136b2:	4610      	mov	r0, r2
   136b4:	4662      	mov	r2, ip
   136b6:	468c      	mov	ip, r1
   136b8:	4619      	mov	r1, r3
   136ba:	4663      	mov	r3, ip
   136bc:	e000      	b.n	136c0 <__aeabi_cdcmpeq>
   136be:	bf00      	nop

000136c0 <__aeabi_cdcmpeq>:
   136c0:	b501      	push	{r0, lr}
   136c2:	f7ff ffb7 	bl	13634 <__cmpdf2>
   136c6:	2800      	cmp	r0, #0
   136c8:	bf48      	it	mi
   136ca:	f110 0f00 	cmnmi.w	r0, #0
   136ce:	bd01      	pop	{r0, pc}

000136d0 <__aeabi_dcmpeq>:
   136d0:	f84d ed08 	str.w	lr, [sp, #-8]!
   136d4:	f7ff fff4 	bl	136c0 <__aeabi_cdcmpeq>
   136d8:	bf0c      	ite	eq
   136da:	2001      	moveq	r0, #1
   136dc:	2000      	movne	r0, #0
   136de:	f85d fb08 	ldr.w	pc, [sp], #8
   136e2:	bf00      	nop

000136e4 <__aeabi_dcmplt>:
   136e4:	f84d ed08 	str.w	lr, [sp, #-8]!
   136e8:	f7ff ffea 	bl	136c0 <__aeabi_cdcmpeq>
   136ec:	bf34      	ite	cc
   136ee:	2001      	movcc	r0, #1
   136f0:	2000      	movcs	r0, #0
   136f2:	f85d fb08 	ldr.w	pc, [sp], #8
   136f6:	bf00      	nop

000136f8 <__aeabi_dcmple>:
   136f8:	f84d ed08 	str.w	lr, [sp, #-8]!
   136fc:	f7ff ffe0 	bl	136c0 <__aeabi_cdcmpeq>
   13700:	bf94      	ite	ls
   13702:	2001      	movls	r0, #1
   13704:	2000      	movhi	r0, #0
   13706:	f85d fb08 	ldr.w	pc, [sp], #8
   1370a:	bf00      	nop

0001370c <__aeabi_dcmpge>:
   1370c:	f84d ed08 	str.w	lr, [sp, #-8]!
   13710:	f7ff ffce 	bl	136b0 <__aeabi_cdrcmple>
   13714:	bf94      	ite	ls
   13716:	2001      	movls	r0, #1
   13718:	2000      	movhi	r0, #0
   1371a:	f85d fb08 	ldr.w	pc, [sp], #8
   1371e:	bf00      	nop

00013720 <__aeabi_dcmpgt>:
   13720:	f84d ed08 	str.w	lr, [sp, #-8]!
   13724:	f7ff ffc4 	bl	136b0 <__aeabi_cdrcmple>
   13728:	bf34      	ite	cc
   1372a:	2001      	movcc	r0, #1
   1372c:	2000      	movcs	r0, #0
   1372e:	f85d fb08 	ldr.w	pc, [sp], #8
   13732:	bf00      	nop

Disassembly of section .text._Tcpv4TxAckFnc%291:

00013734 <_Tcpv4TxAckFnc>:
{
   13734:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13738:	4681      	mov	r9, r0
    while(pSkt != 0)
   1373a:	460e      	mov	r6, r1
   1373c:	2900      	cmp	r1, #0
   1373e:	d051      	beq.n	137e4 <_Tcpv4TxAckFnc+0xb0>
        status =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   13740:	2000      	movs	r0, #0
   13742:	f00d feab 	bl	2149c <OSAL_CRIT_Enter>
   13746:	4601      	mov	r1, r0
        sktIx = pSkt->sktIx;
   13748:	f9b6 7034 	ldrsh.w	r7, [r6, #52]	; 0x34
        if(TCBStubs == 0 || sktIx < 0 || sktIx >= TcpSockets || pSkt != TCBStubs[sktIx])
   1374c:	4b3a      	ldr	r3, [pc, #232]	; (13838 <_Tcpv4TxAckFnc+0x104>)
   1374e:	681c      	ldr	r4, [r3, #0]
   13750:	2c00      	cmp	r4, #0
   13752:	d04f      	beq.n	137f4 <_Tcpv4TxAckFnc+0xc0>
   13754:	2f00      	cmp	r7, #0
   13756:	db61      	blt.n	1381c <_Tcpv4TxAckFnc+0xe8>
   13758:	4b38      	ldr	r3, [pc, #224]	; (1383c <_Tcpv4TxAckFnc+0x108>)
   1375a:	681b      	ldr	r3, [r3, #0]
   1375c:	429f      	cmp	r7, r3
   1375e:	d264      	bcs.n	1382a <_Tcpv4TxAckFnc+0xf6>
   13760:	f854 3027 	ldr.w	r3, [r4, r7, lsl #2]
   13764:	42b3      	cmp	r3, r6
   13766:	d006      	beq.n	13776 <_Tcpv4TxAckFnc+0x42>
    const void* sigParam = 0;
   13768:	2400      	movs	r4, #0
    TCPIP_TCP_SIGNAL_FUNCTION sigHandler = 0;
   1376a:	4625      	mov	r5, r4
    bool freePkt = true;
   1376c:	f04f 0a01 	mov.w	sl, #1
    TCPIP_TCP_SIGNAL_TYPE sigType = 0;
   13770:	46a0      	mov	r8, r4
    TCPIP_NET_HANDLE pktIf = 0;
   13772:	4626      	mov	r6, r4
   13774:	e043      	b.n	137fe <_Tcpv4TxAckFnc+0xca>
        if((pPkt->pDSeg->segFlags & TCPIP_MAC_SEG_FLAG_USER_PAYLOAD) != 0)
   13776:	f8d9 3010 	ldr.w	r3, [r9, #16]
   1377a:	8a1b      	ldrh	r3, [r3, #16]
   1377c:	f003 0308 	and.w	r3, r3, #8
            sigType = TCPIP_TCP_SIGNAL_TX_DONE;
   13780:	2b00      	cmp	r3, #0
   13782:	bf14      	ite	ne
   13784:	f04f 0803 	movne.w	r8, #3
   13788:	f04f 0801 	moveq.w	r8, #1
        if((sigType &= pSkt->sigMask) != 0)
   1378c:	f8b6 3072 	ldrh.w	r3, [r6, #114]	; 0x72
   13790:	ea18 0803 	ands.w	r8, r8, r3
   13794:	d00a      	beq.n	137ac <_Tcpv4TxAckFnc+0x78>
            sigHandler = pSkt->sigHandler;
   13796:	6f75      	ldr	r5, [r6, #116]	; 0x74
            sigParam = pSkt->sigParam;
   13798:	6fb4      	ldr	r4, [r6, #120]	; 0x78
            pktIf = pPkt->pktIf;
   1379a:	f8d9 0028 	ldr.w	r0, [r9, #40]	; 0x28
        if(pSkt->pV4Pkt != &((TCP_V4_PACKET*)pPkt)->v4Pkt)
   1379e:	6c72      	ldr	r2, [r6, #68]	; 0x44
   137a0:	454a      	cmp	r2, r9
   137a2:	d007      	beq.n	137b4 <_Tcpv4TxAckFnc+0x80>
   137a4:	4606      	mov	r6, r0
    bool freePkt = true;
   137a6:	f04f 0a01 	mov.w	sl, #1
   137aa:	e028      	b.n	137fe <_Tcpv4TxAckFnc+0xca>
    const void* sigParam = 0;
   137ac:	2400      	movs	r4, #0
    TCPIP_TCP_SIGNAL_FUNCTION sigHandler = 0;
   137ae:	4625      	mov	r5, r4
    TCPIP_NET_HANDLE pktIf = 0;
   137b0:	4620      	mov	r0, r4
   137b2:	e7f4      	b.n	1379e <_Tcpv4TxAckFnc+0x6a>
    pSeg->segLen = pSeg->segSize = 0;
   137b4:	2300      	movs	r3, #0
   137b6:	f8a2 3052 	strh.w	r3, [r2, #82]	; 0x52
   137ba:	f8a2 3050 	strh.w	r3, [r2, #80]	; 0x50
    pSeg->next = 0;
   137be:	6453      	str	r3, [r2, #68]	; 0x44
    pSeg->segLen = pSeg->segSize = 0;
   137c0:	f8a2 306a 	strh.w	r3, [r2, #106]	; 0x6a
   137c4:	f8a2 3068 	strh.w	r3, [r2, #104]	; 0x68
    pSeg->next = 0;
   137c8:	65d3      	str	r3, [r2, #92]	; 0x5c
    pTcpPkt->v4Pkt.macPkt.pDSeg->next = 0;    // unlink to the 1st data seg; leave header only
   137ca:	6916      	ldr	r6, [r2, #16]
   137cc:	6033      	str	r3, [r6, #0]
    pTcpPkt->v4Pkt.macPkt.pDSeg->segLen = 0;  // clear the payload
   137ce:	6912      	ldr	r2, [r2, #16]
   137d0:	8193      	strh	r3, [r2, #12]
        pPkt->pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED;
   137d2:	f8b9 2022 	ldrh.w	r2, [r9, #34]	; 0x22
   137d6:	f022 0208 	bic.w	r2, r2, #8
   137da:	f8a9 2022 	strh.w	r2, [r9, #34]	; 0x22
        break;
   137de:	4606      	mov	r6, r0
        freePkt = false;
   137e0:	469a      	mov	sl, r3
        break;
   137e2:	e00c      	b.n	137fe <_Tcpv4TxAckFnc+0xca>
    const void* sigParam = 0;
   137e4:	460c      	mov	r4, r1
    TCPIP_TCP_SIGNAL_FUNCTION sigHandler = 0;
   137e6:	2500      	movs	r5, #0
    TCP_SOCKET   sktIx = 0;
   137e8:	462f      	mov	r7, r5
    TCPIP_TCP_SIGNAL_TYPE sigType = 0;
   137ea:	46a8      	mov	r8, r5
        TCPIP_PKT_PacketFree(pPkt);
   137ec:	4648      	mov	r0, r9
   137ee:	f00a fbdb 	bl	1dfa8 <_TCPIP_PKT_PacketFree>
   137f2:	e00a      	b.n	1380a <_Tcpv4TxAckFnc+0xd6>
    TCPIP_NET_HANDLE pktIf = 0;
   137f4:	4626      	mov	r6, r4
    TCPIP_TCP_SIGNAL_FUNCTION sigHandler = 0;
   137f6:	2500      	movs	r5, #0
    bool freePkt = true;
   137f8:	f04f 0a01 	mov.w	sl, #1
    TCPIP_TCP_SIGNAL_TYPE sigType = 0;
   137fc:	46a8      	mov	r8, r5
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   137fe:	2000      	movs	r0, #0
   13800:	f00d ff7b 	bl	216fa <OSAL_CRIT_Leave>
    if(freePkt)
   13804:	f1ba 0f00 	cmp.w	sl, #0
   13808:	d1f0      	bne.n	137ec <_Tcpv4TxAckFnc+0xb8>
    if(sigHandler)
   1380a:	b125      	cbz	r5, 13816 <_Tcpv4TxAckFnc+0xe2>
        (*sigHandler)(sktIx, pktIf, sigType, sigParam);
   1380c:	4623      	mov	r3, r4
   1380e:	4642      	mov	r2, r8
   13810:	4631      	mov	r1, r6
   13812:	4638      	mov	r0, r7
   13814:	47a8      	blx	r5
}
   13816:	2000      	movs	r0, #0
   13818:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    const void* sigParam = 0;
   1381c:	2400      	movs	r4, #0
    TCPIP_TCP_SIGNAL_FUNCTION sigHandler = 0;
   1381e:	4625      	mov	r5, r4
    bool freePkt = true;
   13820:	f04f 0a01 	mov.w	sl, #1
    TCPIP_TCP_SIGNAL_TYPE sigType = 0;
   13824:	46a0      	mov	r8, r4
    TCPIP_NET_HANDLE pktIf = 0;
   13826:	4626      	mov	r6, r4
   13828:	e7e9      	b.n	137fe <_Tcpv4TxAckFnc+0xca>
    const void* sigParam = 0;
   1382a:	2400      	movs	r4, #0
    TCPIP_TCP_SIGNAL_FUNCTION sigHandler = 0;
   1382c:	4625      	mov	r5, r4
    bool freePkt = true;
   1382e:	f04f 0a01 	mov.w	sl, #1
    TCPIP_TCP_SIGNAL_TYPE sigType = 0;
   13832:	46a0      	mov	r8, r4
    TCPIP_NET_HANDLE pktIf = 0;
   13834:	4626      	mov	r6, r4
   13836:	e7e2      	b.n	137fe <_Tcpv4TxAckFnc+0xca>
   13838:	2000e594 	.word	0x2000e594
   1383c:	2000e598 	.word	0x2000e598

Disassembly of section .text.__sflush_r%292:

00013840 <__sflush_r>:
   13840:	898a      	ldrh	r2, [r1, #12]
   13842:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13846:	4605      	mov	r5, r0
   13848:	0710      	lsls	r0, r2, #28
   1384a:	460c      	mov	r4, r1
   1384c:	d458      	bmi.n	13900 <__sflush_r+0xc0>
   1384e:	684b      	ldr	r3, [r1, #4]
   13850:	2b00      	cmp	r3, #0
   13852:	dc05      	bgt.n	13860 <__sflush_r+0x20>
   13854:	6c0b      	ldr	r3, [r1, #64]	; 0x40
   13856:	2b00      	cmp	r3, #0
   13858:	dc02      	bgt.n	13860 <__sflush_r+0x20>
   1385a:	2000      	movs	r0, #0
   1385c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   13860:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   13862:	2e00      	cmp	r6, #0
   13864:	d0f9      	beq.n	1385a <__sflush_r+0x1a>
   13866:	2300      	movs	r3, #0
   13868:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
   1386c:	682f      	ldr	r7, [r5, #0]
   1386e:	602b      	str	r3, [r5, #0]
   13870:	d032      	beq.n	138d8 <__sflush_r+0x98>
   13872:	6d60      	ldr	r0, [r4, #84]	; 0x54
   13874:	89a3      	ldrh	r3, [r4, #12]
   13876:	075a      	lsls	r2, r3, #29
   13878:	d505      	bpl.n	13886 <__sflush_r+0x46>
   1387a:	6863      	ldr	r3, [r4, #4]
   1387c:	1ac0      	subs	r0, r0, r3
   1387e:	6b63      	ldr	r3, [r4, #52]	; 0x34
   13880:	b10b      	cbz	r3, 13886 <__sflush_r+0x46>
   13882:	6c23      	ldr	r3, [r4, #64]	; 0x40
   13884:	1ac0      	subs	r0, r0, r3
   13886:	2300      	movs	r3, #0
   13888:	4602      	mov	r2, r0
   1388a:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   1388c:	6a21      	ldr	r1, [r4, #32]
   1388e:	4628      	mov	r0, r5
   13890:	47b0      	blx	r6
   13892:	1c43      	adds	r3, r0, #1
   13894:	89a3      	ldrh	r3, [r4, #12]
   13896:	d106      	bne.n	138a6 <__sflush_r+0x66>
   13898:	6829      	ldr	r1, [r5, #0]
   1389a:	291d      	cmp	r1, #29
   1389c:	d82c      	bhi.n	138f8 <__sflush_r+0xb8>
   1389e:	4a2a      	ldr	r2, [pc, #168]	; (13948 <__sflush_r+0x108>)
   138a0:	40ca      	lsrs	r2, r1
   138a2:	07d6      	lsls	r6, r2, #31
   138a4:	d528      	bpl.n	138f8 <__sflush_r+0xb8>
   138a6:	2200      	movs	r2, #0
   138a8:	6062      	str	r2, [r4, #4]
   138aa:	04d9      	lsls	r1, r3, #19
   138ac:	6922      	ldr	r2, [r4, #16]
   138ae:	6022      	str	r2, [r4, #0]
   138b0:	d504      	bpl.n	138bc <__sflush_r+0x7c>
   138b2:	1c42      	adds	r2, r0, #1
   138b4:	d101      	bne.n	138ba <__sflush_r+0x7a>
   138b6:	682b      	ldr	r3, [r5, #0]
   138b8:	b903      	cbnz	r3, 138bc <__sflush_r+0x7c>
   138ba:	6560      	str	r0, [r4, #84]	; 0x54
   138bc:	6b61      	ldr	r1, [r4, #52]	; 0x34
   138be:	602f      	str	r7, [r5, #0]
   138c0:	2900      	cmp	r1, #0
   138c2:	d0ca      	beq.n	1385a <__sflush_r+0x1a>
   138c4:	f104 0344 	add.w	r3, r4, #68	; 0x44
   138c8:	4299      	cmp	r1, r3
   138ca:	d002      	beq.n	138d2 <__sflush_r+0x92>
   138cc:	4628      	mov	r0, r5
   138ce:	f004 f901 	bl	17ad4 <_free_r>
   138d2:	2000      	movs	r0, #0
   138d4:	6360      	str	r0, [r4, #52]	; 0x34
   138d6:	e7c1      	b.n	1385c <__sflush_r+0x1c>
   138d8:	6a21      	ldr	r1, [r4, #32]
   138da:	2301      	movs	r3, #1
   138dc:	4628      	mov	r0, r5
   138de:	47b0      	blx	r6
   138e0:	1c41      	adds	r1, r0, #1
   138e2:	d1c7      	bne.n	13874 <__sflush_r+0x34>
   138e4:	682b      	ldr	r3, [r5, #0]
   138e6:	2b00      	cmp	r3, #0
   138e8:	d0c4      	beq.n	13874 <__sflush_r+0x34>
   138ea:	2b1d      	cmp	r3, #29
   138ec:	d001      	beq.n	138f2 <__sflush_r+0xb2>
   138ee:	2b16      	cmp	r3, #22
   138f0:	d101      	bne.n	138f6 <__sflush_r+0xb6>
   138f2:	602f      	str	r7, [r5, #0]
   138f4:	e7b1      	b.n	1385a <__sflush_r+0x1a>
   138f6:	89a3      	ldrh	r3, [r4, #12]
   138f8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   138fc:	81a3      	strh	r3, [r4, #12]
   138fe:	e7ad      	b.n	1385c <__sflush_r+0x1c>
   13900:	690f      	ldr	r7, [r1, #16]
   13902:	2f00      	cmp	r7, #0
   13904:	d0a9      	beq.n	1385a <__sflush_r+0x1a>
   13906:	0793      	lsls	r3, r2, #30
   13908:	680e      	ldr	r6, [r1, #0]
   1390a:	bf08      	it	eq
   1390c:	694b      	ldreq	r3, [r1, #20]
   1390e:	600f      	str	r7, [r1, #0]
   13910:	bf18      	it	ne
   13912:	2300      	movne	r3, #0
   13914:	eba6 0807 	sub.w	r8, r6, r7
   13918:	608b      	str	r3, [r1, #8]
   1391a:	f1b8 0f00 	cmp.w	r8, #0
   1391e:	dd9c      	ble.n	1385a <__sflush_r+0x1a>
   13920:	4643      	mov	r3, r8
   13922:	463a      	mov	r2, r7
   13924:	6a21      	ldr	r1, [r4, #32]
   13926:	6aa6      	ldr	r6, [r4, #40]	; 0x28
   13928:	4628      	mov	r0, r5
   1392a:	47b0      	blx	r6
   1392c:	2800      	cmp	r0, #0
   1392e:	dc06      	bgt.n	1393e <__sflush_r+0xfe>
   13930:	89a3      	ldrh	r3, [r4, #12]
   13932:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   13936:	81a3      	strh	r3, [r4, #12]
   13938:	f04f 30ff 	mov.w	r0, #4294967295
   1393c:	e78e      	b.n	1385c <__sflush_r+0x1c>
   1393e:	4407      	add	r7, r0
   13940:	eba8 0800 	sub.w	r8, r8, r0
   13944:	e7e9      	b.n	1391a <__sflush_r+0xda>
   13946:	bf00      	nop
   13948:	20400001 	.word	0x20400001

Disassembly of section .text._TCPIP_HEAP_Free%293:

0001394c <_TCPIP_HEAP_Free>:
// null if invalid
static __inline__ TCPIP_HEAP_DCPT* __attribute__((always_inline)) _TCPIP_HEAP_ObjDcpt(TCPIP_STACK_HEAP_HANDLE heapH)
{
    TCPIP_HEAP_OBJ_INSTANCE* hInst = _TCPIP_HEAP_ObjInstance(heapH);

    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   1394c:	2800      	cmp	r0, #0
   1394e:	d07e      	beq.n	13a4e <_TCPIP_HEAP_Free+0x102>
    return pBuff;

}

static size_t _TCPIP_HEAP_Free(TCPIP_STACK_HEAP_HANDLE heapH, const void* pBuff)
{  
   13950:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13954:	4604      	mov	r4, r0
    int         fail;
    size_t      freedUnits;

    hDcpt = _TCPIP_HEAP_ObjDcpt(heapH);

    if(hDcpt == 0 || pBuff == 0)
   13956:	2900      	cmp	r1, #0
   13958:	d07b      	beq.n	13a52 <_TCPIP_HEAP_Free+0x106>
   1395a:	460e      	mov	r6, r1
	{
        return 0;
    }

    ptr = (_headNode*)pBuff-1;
   1395c:	f1a1 0510 	sub.w	r5, r1, #16

    OSAL_SEM_Pend(&hDcpt->_heapSemaphore, OSAL_WAIT_FOREVER);
   13960:	f100 0844 	add.w	r8, r0, #68	; 0x44
   13964:	f64f 71ff 	movw	r1, #65535	; 0xffff
   13968:	4640      	mov	r0, r8
   1396a:	f00d f98b 	bl	20c84 <OSAL_SEM_Pend>
        OSAL_SEM_Post(&hDcpt->_heapSemaphore);
        return 0;
    }
#endif
    
    freedUnits = ptr->units;
   1396e:	f856 7c0c 	ldr.w	r7, [r6, #-12]
    
    fail = 0;
    
    if(!hDcpt->_heapHead)
   13972:	6a63      	ldr	r3, [r4, #36]	; 0x24
   13974:	b18b      	cbz	r3, 1399a <_TCPIP_HEAP_Free+0x4e>
    {
        ptr->next=0;
        hDcpt->_heapHead = hDcpt->_heapTail = ptr;
    }
    else if(ptr < hDcpt->_heapHead)
   13976:	42ab      	cmp	r3, r5
   13978:	d922      	bls.n	139c0 <_TCPIP_HEAP_Free+0x74>
    {   // put it in front
        if(ptr+ptr->units == hDcpt->_heapHead)
   1397a:	eb05 1207 	add.w	r2, r5, r7, lsl #4
   1397e:	4293      	cmp	r3, r2
   13980:	d010      	beq.n	139a4 <_TCPIP_HEAP_Free+0x58>
                hDcpt->_heapTail = ptr;
            }
        }
        else
        {
            ptr->next = hDcpt->_heapHead;
   13982:	f846 3c10 	str.w	r3, [r6, #-16]
        }
        hDcpt->_heapHead = ptr;    // new head
   13986:	6265      	str	r5, [r4, #36]	; 0x24
        hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_PTR_ERR;   // corrupted pointer!!!
        OSAL_SEM_Post(&hDcpt->_heapSemaphore);
        return 0;
    }
    
    hDcpt->_heapAllocatedUnits -= freedUnits;
   13988:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1398a:	1bdb      	subs	r3, r3, r7
   1398c:	6323      	str	r3, [r4, #48]	; 0x30
    OSAL_SEM_Post(&hDcpt->_heapSemaphore);
   1398e:	4640      	mov	r0, r8
   13990:	f00d fd90 	bl	214b4 <OSAL_SEM_Post>
    return freedUnits * sizeof(_headNode);
   13994:	0138      	lsls	r0, r7, #4
}
   13996:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        ptr->next=0;
   1399a:	f846 3c10 	str.w	r3, [r6, #-16]
        hDcpt->_heapHead = hDcpt->_heapTail = ptr;
   1399e:	62a5      	str	r5, [r4, #40]	; 0x28
   139a0:	6265      	str	r5, [r4, #36]	; 0x24
    if(fail)
   139a2:	e7f1      	b.n	13988 <_TCPIP_HEAP_Free+0x3c>
            ptr->units += hDcpt->_heapHead->units;
   139a4:	685b      	ldr	r3, [r3, #4]
   139a6:	443b      	add	r3, r7
   139a8:	f846 3c0c 	str.w	r3, [r6, #-12]
            ptr->next = hDcpt->_heapHead->next;
   139ac:	6a63      	ldr	r3, [r4, #36]	; 0x24
   139ae:	681b      	ldr	r3, [r3, #0]
   139b0:	f846 3c10 	str.w	r3, [r6, #-16]
            if(hDcpt->_heapTail == hDcpt->_heapHead)
   139b4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   139b6:	6a63      	ldr	r3, [r4, #36]	; 0x24
   139b8:	429a      	cmp	r2, r3
   139ba:	d1e4      	bne.n	13986 <_TCPIP_HEAP_Free+0x3a>
                hDcpt->_heapTail = ptr;
   139bc:	62a5      	str	r5, [r4, #40]	; 0x28
   139be:	e7e2      	b.n	13986 <_TCPIP_HEAP_Free+0x3a>
    else if(ptr > hDcpt->_heapTail)
   139c0:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   139c2:	42aa      	cmp	r2, r5
   139c4:	d229      	bcs.n	13a1a <_TCPIP_HEAP_Free+0xce>
        if(hDcpt->_heapTail + hDcpt->_heapTail->units == ptr)
   139c6:	6853      	ldr	r3, [r2, #4]
   139c8:	eb02 1103 	add.w	r1, r2, r3, lsl #4
   139cc:	428d      	cmp	r5, r1
   139ce:	d005      	beq.n	139dc <_TCPIP_HEAP_Free+0x90>
            hDcpt->_heapTail->next = ptr;
   139d0:	6015      	str	r5, [r2, #0]
            ptr->next = 0;
   139d2:	2300      	movs	r3, #0
   139d4:	f846 3c10 	str.w	r3, [r6, #-16]
            hDcpt->_heapTail = ptr;
   139d8:	62a5      	str	r5, [r4, #40]	; 0x28
    if(fail)
   139da:	e7d5      	b.n	13988 <_TCPIP_HEAP_Free+0x3c>
            hDcpt->_heapTail->units += ptr->units;
   139dc:	443b      	add	r3, r7
   139de:	6053      	str	r3, [r2, #4]
    if(fail)
   139e0:	e7d2      	b.n	13988 <_TCPIP_HEAP_Free+0x3c>
                    ptr->units += hdr->next->units;
   139e2:	6852      	ldr	r2, [r2, #4]
   139e4:	443a      	add	r2, r7
   139e6:	f846 2c0c 	str.w	r2, [r6, #-12]
                    ptr->next = hdr->next->next;
   139ea:	681a      	ldr	r2, [r3, #0]
   139ec:	6812      	ldr	r2, [r2, #0]
   139ee:	f846 2c10 	str.w	r2, [r6, #-16]
                    if(hDcpt->_heapTail == hdr->next)
   139f2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
   139f4:	681a      	ldr	r2, [r3, #0]
   139f6:	4291      	cmp	r1, r2
   139f8:	d11a      	bne.n	13a30 <_TCPIP_HEAP_Free+0xe4>
                        hDcpt->_heapTail = ptr;
   139fa:	62a5      	str	r5, [r4, #40]	; 0x28
   139fc:	e018      	b.n	13a30 <_TCPIP_HEAP_Free+0xe4>
                    hdr->units += ptr->units;
   139fe:	f856 1c0c 	ldr.w	r1, [r6, #-12]
   13a02:	440a      	add	r2, r1
   13a04:	605a      	str	r2, [r3, #4]
                    hdr->next = ptr->next;
   13a06:	f856 2c10 	ldr.w	r2, [r6, #-16]
   13a0a:	601a      	str	r2, [r3, #0]
                    if(hDcpt->_heapTail == ptr)
   13a0c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   13a0e:	42aa      	cmp	r2, r5
   13a10:	d1ba      	bne.n	13988 <_TCPIP_HEAP_Free+0x3c>
                        hDcpt->_heapTail = hdr;
   13a12:	62a3      	str	r3, [r4, #40]	; 0x28
   13a14:	e7b8      	b.n	13988 <_TCPIP_HEAP_Free+0x3c>
        for(hdr = hDcpt->_heapHead; hdr != 0; hdr = hdr->next)
   13a16:	681b      	ldr	r3, [r3, #0]
   13a18:	b18b      	cbz	r3, 13a3e <_TCPIP_HEAP_Free+0xf2>
            if(hdr<ptr && ptr<hdr->next)
   13a1a:	429d      	cmp	r5, r3
   13a1c:	d9fb      	bls.n	13a16 <_TCPIP_HEAP_Free+0xca>
   13a1e:	681a      	ldr	r2, [r3, #0]
   13a20:	42aa      	cmp	r2, r5
   13a22:	d9f8      	bls.n	13a16 <_TCPIP_HEAP_Free+0xca>
                if(ptr+ptr->units == hdr->next)
   13a24:	eb05 1107 	add.w	r1, r5, r7, lsl #4
   13a28:	428a      	cmp	r2, r1
   13a2a:	d0da      	beq.n	139e2 <_TCPIP_HEAP_Free+0x96>
                    ptr->next = hdr->next;
   13a2c:	f846 2c10 	str.w	r2, [r6, #-16]
                if(hdr+hdr->units == ptr)
   13a30:	685a      	ldr	r2, [r3, #4]
   13a32:	eb03 1102 	add.w	r1, r3, r2, lsl #4
   13a36:	428d      	cmp	r5, r1
   13a38:	d0e1      	beq.n	139fe <_TCPIP_HEAP_Free+0xb2>
                    hdr->next = ptr;
   13a3a:	601d      	str	r5, [r3, #0]
   13a3c:	e7a4      	b.n	13988 <_TCPIP_HEAP_Free+0x3c>
        hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_PTR_ERR;   // corrupted pointer!!!
   13a3e:	23f8      	movs	r3, #248	; 0xf8
   13a40:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
        OSAL_SEM_Post(&hDcpt->_heapSemaphore);
   13a44:	4640      	mov	r0, r8
   13a46:	f00d fd35 	bl	214b4 <OSAL_SEM_Post>
        return 0;
   13a4a:	2000      	movs	r0, #0
   13a4c:	e7a3      	b.n	13996 <_TCPIP_HEAP_Free+0x4a>
        return 0;
   13a4e:	2000      	movs	r0, #0
}
   13a50:	4770      	bx	lr
        return 0;
   13a52:	2000      	movs	r0, #0
   13a54:	e79f      	b.n	13996 <_TCPIP_HEAP_Free+0x4a>

Disassembly of section .text.TCPIP_TCP_OptionsSet%294:

00013a56 <TCPIP_TCP_OptionsSet>:
{
   13a56:	b570      	push	{r4, r5, r6, lr}
   13a58:	4606      	mov	r6, r0
   13a5a:	460c      	mov	r4, r1
   13a5c:	4615      	mov	r5, r2
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   13a5e:	f00c f929 	bl	1fcb4 <_TcpSocketChk>
    if(pSkt)
   13a62:	2800      	cmp	r0, #0
   13a64:	d070      	beq.n	13b48 <TCPIP_TCP_OptionsSet+0xf2>
   13a66:	4603      	mov	r3, r0
        switch(option)
   13a68:	2c0b      	cmp	r4, #11
   13a6a:	d86f      	bhi.n	13b4c <TCPIP_TCP_OptionsSet+0xf6>
   13a6c:	e8df f004 	tbb	[pc, r4]
   13a70:	3f381b06 	.word	0x3f381b06
   13a74:	6e466e6e 	.word	0x6e466e6e
   13a78:	68645951 	.word	0x68645951
                if(optParam)
   13a7c:	2d00      	cmp	r5, #0
   13a7e:	d067      	beq.n	13b50 <TCPIP_TCP_OptionsSet+0xfa>
                    pSkt->flags.nonLinger = pLData->lingerEnable == 0;
   13a80:	782a      	ldrb	r2, [r5, #0]
   13a82:	f082 0201 	eor.w	r2, r2, #1
   13a86:	f890 106c 	ldrb.w	r1, [r0, #108]	; 0x6c
   13a8a:	f362 1186 	bfi	r1, r2, #6, #1
   13a8e:	f880 106c 	strb.w	r1, [r0, #108]	; 0x6c
                    pSkt->flags.nonGraceful = pLData->gracefulEnable == 0;
   13a92:	786a      	ldrb	r2, [r5, #1]
   13a94:	f082 0201 	eor.w	r2, r2, #1
   13a98:	b2c9      	uxtb	r1, r1
   13a9a:	f362 11c7 	bfi	r1, r2, #7, #1
   13a9e:	f880 106c 	strb.w	r1, [r0, #108]	; 0x6c
                    return true;
   13aa2:	2001      	movs	r0, #1
   13aa4:	e051      	b.n	13b4a <TCPIP_TCP_OptionsSet+0xf4>
                if(optParam)
   13aa6:	2d00      	cmp	r5, #0
   13aa8:	d054      	beq.n	13b54 <TCPIP_TCP_OptionsSet+0xfe>
                    if((pSkt->Flags.keepAlive = pKData->keepAliveEnable))
   13aaa:	7828      	ldrb	r0, [r5, #0]
   13aac:	f893 2037 	ldrb.w	r2, [r3, #55]	; 0x37
   13ab0:	f360 1286 	bfi	r2, r0, #6, #1
   13ab4:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
   13ab8:	2800      	cmp	r0, #0
   13aba:	d04d      	beq.n	13b58 <TCPIP_TCP_OptionsSet+0x102>
                        pSkt->keepAliveCount = 0;
   13abc:	2200      	movs	r2, #0
   13abe:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
                        pSkt->keepAliveTmo = pKData->keepAliveTmo ? pKData->keepAliveTmo : TCPIP_TCP_KEEP_ALIVE_TIMEOUT;
   13ac2:	886a      	ldrh	r2, [r5, #2]
   13ac4:	f242 7110 	movw	r1, #10000	; 0x2710
   13ac8:	2a00      	cmp	r2, #0
   13aca:	bf08      	it	eq
   13acc:	460a      	moveq	r2, r1
   13ace:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
                        pSkt->keepAliveLim = pKData->keepAliveUnackLim ? pKData->keepAliveUnackLim : TCPIP_TCP_MAX_UNACKED_KEEP_ALIVES;
   13ad2:	792a      	ldrb	r2, [r5, #4]
   13ad4:	2a00      	cmp	r2, #0
   13ad6:	bf08      	it	eq
   13ad8:	2206      	moveq	r2, #6
   13ada:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
   13ade:	e034      	b.n	13b4a <TCPIP_TCP_OptionsSet+0xf4>
                return TCPIP_TCP_FifoSizeAdjust(hTCP, (uint16_t)((unsigned int)optParam), 0, TCP_ADJUST_RX_ONLY | TCP_ADJUST_PRESERVE_RX);
   13ae0:	2324      	movs	r3, #36	; 0x24
   13ae2:	2200      	movs	r2, #0
   13ae4:	b2a9      	uxth	r1, r5
   13ae6:	4630      	mov	r0, r6
   13ae8:	f7f7 ff02 	bl	b8f0 <TCPIP_TCP_FifoSizeAdjust>
   13aec:	e02d      	b.n	13b4a <TCPIP_TCP_OptionsSet+0xf4>
                return TCPIP_TCP_FifoSizeAdjust(hTCP, 0, (uint16_t)((unsigned int)optParam), TCP_ADJUST_TX_ONLY | TCP_ADJUST_PRESERVE_TX);
   13aee:	2318      	movs	r3, #24
   13af0:	b2aa      	uxth	r2, r5
   13af2:	2100      	movs	r1, #0
   13af4:	4630      	mov	r0, r6
   13af6:	f7f7 fefb 	bl	b8f0 <TCPIP_TCP_FifoSizeAdjust>
   13afa:	e026      	b.n	13b4a <TCPIP_TCP_OptionsSet+0xf4>
                pSkt->flags.forceFlush = (int)optParam != 0;
   13afc:	3500      	adds	r5, #0
   13afe:	bf18      	it	ne
   13b00:	2501      	movne	r5, #1
   13b02:	f890 206d 	ldrb.w	r2, [r0, #109]	; 0x6d
   13b06:	f365 02c3 	bfi	r2, r5, #3, #1
   13b0a:	f880 206d 	strb.w	r2, [r0, #109]	; 0x6d
                return true;
   13b0e:	2001      	movs	r0, #1
   13b10:	e01b      	b.n	13b4a <TCPIP_TCP_OptionsSet+0xf4>
                pSkt->Flags.halfThresType = (TCP_OPTION_THRES_FLUSH_TYPE)(uint32_t)optParam;
   13b12:	f890 2037 	ldrb.w	r2, [r0, #55]	; 0x37
   13b16:	f365 1205 	bfi	r2, r5, #4, #2
   13b1a:	f880 2037 	strb.w	r2, [r0, #55]	; 0x37
                return true;
   13b1e:	2001      	movs	r0, #1
   13b20:	e013      	b.n	13b4a <TCPIP_TCP_OptionsSet+0xf4>
                pSkt->Flags.delayAckSend = (int)optParam != 0;
   13b22:	3500      	adds	r5, #0
   13b24:	bf18      	it	ne
   13b26:	2501      	movne	r5, #1
   13b28:	f890 2037 	ldrb.w	r2, [r0, #55]	; 0x37
   13b2c:	f365 12c7 	bfi	r2, r5, #7, #1
   13b30:	f880 2037 	strb.w	r2, [r0, #55]	; 0x37
                return true;
   13b34:	2001      	movs	r0, #1
   13b36:	e008      	b.n	13b4a <TCPIP_TCP_OptionsSet+0xf4>
                pSkt->ttl = (uint8_t)(unsigned int)optParam;
   13b38:	f880 507e 	strb.w	r5, [r0, #126]	; 0x7e
                return true;
   13b3c:	2001      	movs	r0, #1
   13b3e:	e004      	b.n	13b4a <TCPIP_TCP_OptionsSet+0xf4>
                pSkt->tos = (uint8_t)(unsigned int)optParam;
   13b40:	f880 507f 	strb.w	r5, [r0, #127]	; 0x7f
                return true;
   13b44:	2001      	movs	r0, #1
   13b46:	e000      	b.n	13b4a <TCPIP_TCP_OptionsSet+0xf4>
    return false;
   13b48:	2000      	movs	r0, #0
}
   13b4a:	bd70      	pop	{r4, r5, r6, pc}
                return false;   // not supported option
   13b4c:	2000      	movs	r0, #0
   13b4e:	e7fc      	b.n	13b4a <TCPIP_TCP_OptionsSet+0xf4>
                return false;
   13b50:	2000      	movs	r0, #0
   13b52:	e7fa      	b.n	13b4a <TCPIP_TCP_OptionsSet+0xf4>
                return false;
   13b54:	2000      	movs	r0, #0
   13b56:	e7f8      	b.n	13b4a <TCPIP_TCP_OptionsSet+0xf4>
                    return true;
   13b58:	2001      	movs	r0, #1
   13b5a:	e7f6      	b.n	13b4a <TCPIP_TCP_OptionsSet+0xf4>

Disassembly of section .text.TCPIP_UDP_Initialize%295:

00013b5c <TCPIP_UDP_Initialize>:
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_UP)
   13b5c:	7f03      	ldrb	r3, [r0, #28]
   13b5e:	2b03      	cmp	r3, #3
   13b60:	d065      	beq.n	13c2e <TCPIP_UDP_Initialize+0xd2>
    if(udpInitCount != 0)
   13b62:	4b35      	ldr	r3, [pc, #212]	; (13c38 <TCPIP_UDP_Initialize+0xdc>)
   13b64:	681b      	ldr	r3, [r3, #0]
   13b66:	b983      	cbnz	r3, 13b8a <TCPIP_UDP_Initialize+0x2e>
{
   13b68:	b570      	push	{r4, r5, r6, lr}
   13b6a:	460d      	mov	r5, r1
   13b6c:	4604      	mov	r4, r0
    if(stackCtrl->memH == 0)
   13b6e:	68c3      	ldr	r3, [r0, #12]
   13b70:	b183      	cbz	r3, 13b94 <TCPIP_UDP_Initialize+0x38>
    if(pUdpInit == 0)
   13b72:	2900      	cmp	r1, #0
   13b74:	d05d      	beq.n	13c32 <TCPIP_UDP_Initialize+0xd6>
    return OSAL_SEM_Create(&userSem, OSAL_SEM_TYPE_BINARY, 1, 1);
   13b76:	2301      	movs	r3, #1
   13b78:	461a      	mov	r2, r3
   13b7a:	2100      	movs	r1, #0
   13b7c:	482f      	ldr	r0, [pc, #188]	; (13c3c <TCPIP_UDP_Initialize+0xe0>)
   13b7e:	f007 ffe1 	bl	1bb44 <OSAL_SEM_Create>
    if(_UserGblLockCreate() != OSAL_RESULT_TRUE)
   13b82:	2801      	cmp	r0, #1
   13b84:	d012      	beq.n	13bac <TCPIP_UDP_Initialize+0x50>
        return false;
   13b86:	2000      	movs	r0, #0
}
   13b88:	bd70      	pop	{r4, r5, r6, pc}
        udpInitCount++;
   13b8a:	3301      	adds	r3, #1
   13b8c:	4a2a      	ldr	r2, [pc, #168]	; (13c38 <TCPIP_UDP_Initialize+0xdc>)
   13b8e:	6013      	str	r3, [r2, #0]
        return true;
   13b90:	2001      	movs	r0, #1
   13b92:	4770      	bx	lr
        SYS_ERROR(SYS_ERROR_ERROR, "UDP NULL dynamic allocation handle");
   13b94:	f00e f9da 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
   13b98:	b908      	cbnz	r0, 13b9e <TCPIP_UDP_Initialize+0x42>
        return false;
   13b9a:	2000      	movs	r0, #0
   13b9c:	e7f4      	b.n	13b88 <TCPIP_UDP_Initialize+0x2c>
        SYS_ERROR(SYS_ERROR_ERROR, "UDP NULL dynamic allocation handle");
   13b9e:	f00e f9cf 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
   13ba2:	4927      	ldr	r1, [pc, #156]	; (13c40 <TCPIP_UDP_Initialize+0xe4>)
   13ba4:	f006 fde2 	bl	1a76c <SYS_CONSOLE_Print>
        return false;
   13ba8:	2000      	movs	r0, #0
   13baa:	e7ed      	b.n	13b88 <TCPIP_UDP_Initialize+0x2c>
    signalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_UDP_Task, 0);
   13bac:	2200      	movs	r2, #0
   13bae:	4925      	ldr	r1, [pc, #148]	; (13c44 <TCPIP_UDP_Initialize+0xe8>)
   13bb0:	2009      	movs	r0, #9
   13bb2:	f009 f86d 	bl	1cc90 <_TCPIPStackSignalHandlerRegister>
   13bb6:	4b24      	ldr	r3, [pc, #144]	; (13c48 <TCPIP_UDP_Initialize+0xec>)
   13bb8:	6018      	str	r0, [r3, #0]
    if(signalHandle == 0)
   13bba:	b308      	cbz	r0, 13c00 <TCPIP_UDP_Initialize+0xa4>
    newSktDcpt = (UDP_SOCKET_DCPT**)TCPIP_HEAP_Calloc(stackCtrl->memH, pUdpInit->nSockets, sizeof(UDP_SOCKET_DCPT*));
   13bbc:	68e0      	ldr	r0, [r4, #12]
   13bbe:	6883      	ldr	r3, [r0, #8]
   13bc0:	2204      	movs	r2, #4
   13bc2:	8829      	ldrh	r1, [r5, #0]
   13bc4:	4798      	blx	r3
    if(newSktDcpt == 0)
   13bc6:	4606      	mov	r6, r0
   13bc8:	b1f8      	cbz	r0, 13c0a <TCPIP_UDP_Initialize+0xae>
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   13bca:	2000      	movs	r0, #0
   13bcc:	f00d fc66 	bl	2149c <OSAL_CRIT_Enter>
    udpMemH = stackCtrl->memH;
   13bd0:	68e2      	ldr	r2, [r4, #12]
   13bd2:	4b1e      	ldr	r3, [pc, #120]	; (13c4c <TCPIP_UDP_Initialize+0xf0>)
   13bd4:	601a      	str	r2, [r3, #0]
    nUdpSockets = pUdpInit->nSockets;
   13bd6:	882a      	ldrh	r2, [r5, #0]
   13bd8:	4b1d      	ldr	r3, [pc, #116]	; (13c50 <TCPIP_UDP_Initialize+0xf4>)
   13bda:	601a      	str	r2, [r3, #0]
    udpDefTxSize = pUdpInit->sktTxBuffSize;
   13bdc:	886a      	ldrh	r2, [r5, #2]
   13bde:	4b1d      	ldr	r3, [pc, #116]	; (13c54 <TCPIP_UDP_Initialize+0xf8>)
   13be0:	801a      	strh	r2, [r3, #0]
    UDPSocketDcpt = newSktDcpt;
   13be2:	4b1d      	ldr	r3, [pc, #116]	; (13c58 <TCPIP_UDP_Initialize+0xfc>)
   13be4:	601e      	str	r6, [r3, #0]
    udpInitCount++;
   13be6:	4a14      	ldr	r2, [pc, #80]	; (13c38 <TCPIP_UDP_Initialize+0xdc>)
   13be8:	6813      	ldr	r3, [r2, #0]
   13bea:	3301      	adds	r3, #1
   13bec:	6013      	str	r3, [r2, #0]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   13bee:	4601      	mov	r1, r0
   13bf0:	2000      	movs	r0, #0
   13bf2:	f00d fd82 	bl	216fa <OSAL_CRIT_Leave>
    OSAL_SEM_Post(&userSem);
   13bf6:	4811      	ldr	r0, [pc, #68]	; (13c3c <TCPIP_UDP_Initialize+0xe0>)
   13bf8:	f00d fc5c 	bl	214b4 <OSAL_SEM_Post>
    return true;
   13bfc:	2001      	movs	r0, #1
   13bfe:	e7c3      	b.n	13b88 <TCPIP_UDP_Initialize+0x2c>
    OSAL_SEM_Delete(&userSem);
   13c00:	480e      	ldr	r0, [pc, #56]	; (13c3c <TCPIP_UDP_Initialize+0xe0>)
   13c02:	f00d feb3 	bl	2196c <OSAL_SEM_Delete>
        return false;
   13c06:	2000      	movs	r0, #0
   13c08:	e7be      	b.n	13b88 <TCPIP_UDP_Initialize+0x2c>
        SYS_ERROR(SYS_ERROR_ERROR, "UDP Dynamic allocation failed");
   13c0a:	f00e f99f 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
   13c0e:	b940      	cbnz	r0, 13c22 <TCPIP_UDP_Initialize+0xc6>
    OSAL_SEM_Delete(&userSem);
   13c10:	480a      	ldr	r0, [pc, #40]	; (13c3c <TCPIP_UDP_Initialize+0xe0>)
   13c12:	f00d feab 	bl	2196c <OSAL_SEM_Delete>
        _TCPIPStackSignalHandlerDeregister(signalHandle);
   13c16:	4b0c      	ldr	r3, [pc, #48]	; (13c48 <TCPIP_UDP_Initialize+0xec>)
   13c18:	6818      	ldr	r0, [r3, #0]
   13c1a:	f00e f802 	bl	21c22 <_TCPIPStackSignalHandlerDeregister>
        return false;
   13c1e:	2000      	movs	r0, #0
   13c20:	e7b2      	b.n	13b88 <TCPIP_UDP_Initialize+0x2c>
        SYS_ERROR(SYS_ERROR_ERROR, "UDP Dynamic allocation failed");
   13c22:	f00e f98d 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
   13c26:	490d      	ldr	r1, [pc, #52]	; (13c5c <TCPIP_UDP_Initialize+0x100>)
   13c28:	f006 fda0 	bl	1a76c <SYS_CONSOLE_Print>
   13c2c:	e7f0      	b.n	13c10 <TCPIP_UDP_Initialize+0xb4>
        return true;    // do not store per interface data
   13c2e:	2001      	movs	r0, #1
}
   13c30:	4770      	bx	lr
        return false;
   13c32:	2000      	movs	r0, #0
   13c34:	e7a8      	b.n	13b88 <TCPIP_UDP_Initialize+0x2c>
   13c36:	bf00      	nop
   13c38:	2000e668 	.word	0x2000e668
   13c3c:	2000e670 	.word	0x2000e670
   13c40:	0001d3b0 	.word	0x0001d3b0
   13c44:	0000d5d9 	.word	0x0000d5d9
   13c48:	2000e664 	.word	0x2000e664
   13c4c:	2000e66c 	.word	0x2000e66c
   13c50:	2000e660 	.word	0x2000e660
   13c54:	2000e724 	.word	0x2000e724
   13c58:	2000e65c 	.word	0x2000e65c
   13c5c:	0001d3d4 	.word	0x0001d3d4

Disassembly of section .rodata._ctype_%296:

00013c60 <_ctype_>:
   13c60:	20202000 20202020 28282020 20282828     .         ((((( 
   13c70:	20202020 20202020 20202020 20202020                     
   13c80:	10108820 10101010 10101010 10101010      ...............
   13c90:	04040410 04040404 10040404 10101010     ................
   13ca0:	41411010 41414141 01010101 01010101     ..AAAAAA........
   13cb0:	01010101 01010101 01010101 10101010     ................
   13cc0:	42421010 42424242 02020202 02020202     ..BBBBBB........
   13cd0:	02020202 02020202 02020202 10101010     ................
   13ce0:	00000020 00000000 00000000 00000000      ...............
	...

Disassembly of section .rodata.K%297:

00013d64 <K>:
   13d64:	428a2f98 71374491 b5c0fbcf e9b5dba5     ./.B.D7q........
   13d74:	3956c25b 59f111f1 923f82a4 ab1c5ed5     [.V9...Y..?..^..
   13d84:	d807aa98 12835b01 243185be 550c7dc3     .....[....1$.}.U
   13d94:	72be5d74 80deb1fe 9bdc06a7 c19bf174     t].r........t...
   13da4:	e49b69c1 efbe4786 0fc19dc6 240ca1cc     .i...G.........$
   13db4:	2de92c6f 4a7484aa 5cb0a9dc 76f988da     o,.-..tJ...\...v
   13dc4:	983e5152 a831c66d b00327c8 bf597fc7     RQ>.m.1..'....Y.
   13dd4:	c6e00bf3 d5a79147 06ca6351 14292967     ....G...Qc..g)).
   13de4:	27b70a85 2e1b2138 4d2c6dfc 53380d13     ...'8!...m,M..8S
   13df4:	650a7354 766a0abb 81c2c92e 92722c85     Ts.e..jv.....,r.
   13e04:	a2bfe8a1 a81a664b c24b8b70 c76c51a3     ....Kf..p.K..Ql.
   13e14:	d192e819 d6990624 f40e3585 106aa070     ....$....5..p.j.
   13e24:	19a4c116 1e376c08 2748774c 34b0bcb5     .....l7.LwH'...4
   13e34:	391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3     ...9J..NO..[.o.h
   13e44:	748f82ee 78a5636f 84c87814 8cc70208     ...toc.x.x......
   13e54:	90befffa a4506ceb bef9a3f7 c67178f2     .....lP......xq.

Disassembly of section .text.wc_Md5Update%298:

00013e64 <wc_Md5Update>:
    return ret;
}

/* do block size increments/updates */
int wc_Md5Update(wc_Md5* md5, const byte* data, word32 len)
{
   13e64:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    int ret = 0;
    word32 blocksLen;
    byte* local;

    if (md5 == NULL || (data == NULL && len > 0)) {
   13e68:	2800      	cmp	r0, #0
   13e6a:	d071      	beq.n	13f50 <wc_Md5Update+0xec>
   13e6c:	460c      	mov	r4, r1
   13e6e:	4690      	mov	r8, r2
   13e70:	4606      	mov	r6, r0
   13e72:	2900      	cmp	r1, #0
   13e74:	d03b      	beq.n	13eee <wc_Md5Update+0x8a>
#endif
    }
#endif /* WOLFSSL_ASYNC_CRYPT */

    /* check that internal buffLen is valid */
    if (md5->buffLen >= WC_MD5_BLOCK_SIZE)
   13e76:	6800      	ldr	r0, [r0, #0]
   13e78:	283f      	cmp	r0, #63	; 0x3f
   13e7a:	d86f      	bhi.n	13f5c <wc_Md5Update+0xf8>
    word32 tmp = md5->loLen;
   13e7c:	6872      	ldr	r2, [r6, #4]
    if ((md5->loLen += len) < tmp) {
   13e7e:	eb08 0302 	add.w	r3, r8, r2
   13e82:	6073      	str	r3, [r6, #4]
   13e84:	429a      	cmp	r2, r3
   13e86:	d902      	bls.n	13e8e <wc_Md5Update+0x2a>
        md5->hiLen++;                       /* carry low to high */
   13e88:	68b3      	ldr	r3, [r6, #8]
   13e8a:	3301      	adds	r3, #1
   13e8c:	60b3      	str	r3, [r6, #8]
    }

    /* add length for final */
    AddLength(md5, len);

    local = (byte*)md5->buffer;
   13e8e:	f106 050c 	add.w	r5, r6, #12

    /* process any remainder from previous operation */
    if (md5->buffLen > 0) {
   13e92:	bba8      	cbnz	r0, 13f00 <wc_Md5Update+0x9c>
        XTRANSFORM_LEN(md5, data, blocksLen);
        data += blocksLen;
        len  -= blocksLen;
    }
#else
    while (len >= WC_MD5_BLOCK_SIZE) {
   13e94:	f1b8 0f3f 	cmp.w	r8, #63	; 0x3f
   13e98:	d94e      	bls.n	13f38 <wc_Md5Update+0xd4>
   13e9a:	f1a8 0740 	sub.w	r7, r8, #64	; 0x40
   13e9e:	f027 073f 	bic.w	r7, r7, #63	; 0x3f
   13ea2:	3740      	adds	r7, #64	; 0x40
   13ea4:	4427      	add	r7, r4
            local32 = (word32*)data;
        }
        else
    #endif
        {
            XMEMCPY(local32, data, WC_MD5_BLOCK_SIZE);
   13ea6:	4623      	mov	r3, r4
   13ea8:	462a      	mov	r2, r5
   13eaa:	f104 0940 	add.w	r9, r4, #64	; 0x40
   13eae:	f8d3 e000 	ldr.w	lr, [r3]
   13eb2:	f8d3 c004 	ldr.w	ip, [r3, #4]
   13eb6:	6898      	ldr	r0, [r3, #8]
   13eb8:	68d9      	ldr	r1, [r3, #12]
   13eba:	f8c2 e000 	str.w	lr, [r2]
   13ebe:	f8c2 c004 	str.w	ip, [r2, #4]
   13ec2:	6090      	str	r0, [r2, #8]
   13ec4:	60d1      	str	r1, [r2, #12]
   13ec6:	3310      	adds	r3, #16
   13ec8:	3210      	adds	r2, #16
   13eca:	454b      	cmp	r3, r9
   13ecc:	d1ef      	bne.n	13eae <wc_Md5Update+0x4a>
        }

        data += WC_MD5_BLOCK_SIZE;
   13ece:	3440      	adds	r4, #64	; 0x40

    #if defined(BIG_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
        ByteReverseWords(local32, local32, WC_MD5_BLOCK_SIZE);
    #endif

        ret = XTRANSFORM(md5, (const byte*)local32);
   13ed0:	4629      	mov	r1, r5
   13ed2:	4630      	mov	r0, r6
   13ed4:	f7f1 ff76 	bl	5dc4 <Transform>
   13ed8:	4681      	mov	r9, r0
    while (len >= WC_MD5_BLOCK_SIZE) {
   13eda:	42bc      	cmp	r4, r7
   13edc:	d1e3      	bne.n	13ea6 <wc_Md5Update+0x42>
   13ede:	f008 083f 	and.w	r8, r8, #63	; 0x3f
    }
#endif /* XTRANSFORM_LEN */

    /* save remainder */
    if (len > 0) {
   13ee2:	f1b8 0f00 	cmp.w	r8, #0
   13ee6:	d12b      	bne.n	13f40 <wc_Md5Update+0xdc>
        XMEMCPY(local, data, len);
        md5->buffLen = len;
    }

    return ret;
}
   13ee8:	4648      	mov	r0, r9
   13eea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (md5 == NULL || (data == NULL && len > 0)) {
   13eee:	bb92      	cbnz	r2, 13f56 <wc_Md5Update+0xf2>
    if (md5->buffLen >= WC_MD5_BLOCK_SIZE)
   13ef0:	6803      	ldr	r3, [r0, #0]
        return BUFFER_E;
   13ef2:	2b40      	cmp	r3, #64	; 0x40
   13ef4:	bf34      	ite	cc
   13ef6:	f04f 0900 	movcc.w	r9, #0
   13efa:	f06f 0983 	mvncs.w	r9, #131	; 0x83
   13efe:	e7f3      	b.n	13ee8 <wc_Md5Update+0x84>
        blocksLen = min(len, WC_MD5_BLOCK_SIZE - md5->buffLen);
   13f00:	f1c0 0740 	rsb	r7, r0, #64	; 0x40
        return a > b ? b : a;
   13f04:	4547      	cmp	r7, r8
   13f06:	bf28      	it	cs
   13f08:	4647      	movcs	r7, r8
        XMEMCPY(&local[md5->buffLen], data, blocksLen);
   13f0a:	463a      	mov	r2, r7
   13f0c:	4621      	mov	r1, r4
   13f0e:	4428      	add	r0, r5
   13f10:	f00d f8a6 	bl	21060 <memcpy>
        md5->buffLen += blocksLen;
   13f14:	6833      	ldr	r3, [r6, #0]
   13f16:	443b      	add	r3, r7
   13f18:	6033      	str	r3, [r6, #0]
        data         += blocksLen;
   13f1a:	443c      	add	r4, r7
        len          -= blocksLen;
   13f1c:	eba8 0807 	sub.w	r8, r8, r7
        if (md5->buffLen == WC_MD5_BLOCK_SIZE) {
   13f20:	2b40      	cmp	r3, #64	; 0x40
   13f22:	d1b7      	bne.n	13e94 <wc_Md5Update+0x30>
            ret = XTRANSFORM(md5, (const byte*)local);
   13f24:	4629      	mov	r1, r5
   13f26:	4630      	mov	r0, r6
   13f28:	f7f1 ff4c 	bl	5dc4 <Transform>
            if (ret != 0)
   13f2c:	4681      	mov	r9, r0
   13f2e:	2800      	cmp	r0, #0
   13f30:	d1da      	bne.n	13ee8 <wc_Md5Update+0x84>
            md5->buffLen = 0;
   13f32:	2300      	movs	r3, #0
   13f34:	6033      	str	r3, [r6, #0]
   13f36:	e7ad      	b.n	13e94 <wc_Md5Update+0x30>
    while (len >= WC_MD5_BLOCK_SIZE) {
   13f38:	4627      	mov	r7, r4
   13f3a:	f04f 0900 	mov.w	r9, #0
   13f3e:	e7d0      	b.n	13ee2 <wc_Md5Update+0x7e>
        XMEMCPY(local, data, len);
   13f40:	4642      	mov	r2, r8
   13f42:	4639      	mov	r1, r7
   13f44:	4628      	mov	r0, r5
   13f46:	f00d f88b 	bl	21060 <memcpy>
        md5->buffLen = len;
   13f4a:	f8c6 8000 	str.w	r8, [r6]
   13f4e:	e7cb      	b.n	13ee8 <wc_Md5Update+0x84>
        return BAD_FUNC_ARG;
   13f50:	f06f 09ac 	mvn.w	r9, #172	; 0xac
   13f54:	e7c8      	b.n	13ee8 <wc_Md5Update+0x84>
   13f56:	f06f 09ac 	mvn.w	r9, #172	; 0xac
   13f5a:	e7c5      	b.n	13ee8 <wc_Md5Update+0x84>
        return BUFFER_E;
   13f5c:	f06f 0983 	mvn.w	r9, #131	; 0x83
   13f60:	e7c2      	b.n	13ee8 <wc_Md5Update+0x84>

Disassembly of section .text.TCPIP_ICMP_EchoRequest%299:

00013f64 <TCPIP_ICMP_EchoRequest>:
{
   13f64:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    if(pHandle)
   13f68:	4688      	mov	r8, r1
   13f6a:	b109      	cbz	r1, 13f70 <TCPIP_ICMP_EchoRequest+0xc>
        *pHandle = 0;
   13f6c:	2300      	movs	r3, #0
   13f6e:	600b      	str	r3, [r1, #0]
    if(pIcmpEchoRequest != 0)
   13f70:	4b38      	ldr	r3, [pc, #224]	; (14054 <TCPIP_ICMP_EchoRequest+0xf0>)
   13f72:	681b      	ldr	r3, [r3, #0]
   13f74:	2b00      	cmp	r3, #0
   13f76:	d15a      	bne.n	1402e <TCPIP_ICMP_EchoRequest+0xca>
    if(pEchoRequest == 0)
   13f78:	2800      	cmp	r0, #0
   13f7a:	d05b      	beq.n	14034 <TCPIP_ICMP_EchoRequest+0xd0>
   13f7c:	4604      	mov	r4, r0
        pktSize = sizeof(ICMP_PACKET) + pEchoRequest->dataSize;
   13f7e:	8a05      	ldrh	r5, [r0, #16]
   13f80:	3508      	adds	r5, #8
   13f82:	b2ad      	uxth	r5, r5
        pTxPkt = _ICMPAllocateTxPacketStruct(pktSize);
   13f84:	4628      	mov	r0, r5
   13f86:	f00c f9a7 	bl	202d8 <_ICMPAllocateTxPacketStruct>
        if(pTxPkt == 0)
   13f8a:	4607      	mov	r7, r0
   13f8c:	2800      	cmp	r0, #0
   13f8e:	d054      	beq.n	1403a <TCPIP_ICMP_EchoRequest+0xd6>
        pICMPPkt = (ICMP_PACKET*)pTxPkt->macPkt.pTransportLayer;
   13f90:	69c6      	ldr	r6, [r0, #28]
        pICMPPkt->vType = ICMP_TYPE_ECHO_REQUEST; 
   13f92:	2308      	movs	r3, #8
   13f94:	7033      	strb	r3, [r6, #0]
        pICMPPkt->vCode = ICMP_CODE_ECHO_REQUEST;
   13f96:	f04f 0900 	mov.w	r9, #0
   13f9a:	f886 9001 	strb.w	r9, [r6, #1]
        pICMPPkt->wChecksum = 0x0000;
   13f9e:	f8a6 9002 	strh.w	r9, [r6, #2]
        pICMPPkt->wIdentifier = pEchoRequest->identifier;
   13fa2:	8963      	ldrh	r3, [r4, #10]
   13fa4:	80b3      	strh	r3, [r6, #4]
        pICMPPkt->wSequenceNumber = pEchoRequest->sequenceNumber;
   13fa6:	8923      	ldrh	r3, [r4, #8]
   13fa8:	80f3      	strh	r3, [r6, #6]
        memcpy(pICMPPkt->wData, pEchoRequest->pData, pEchoRequest->dataSize);
   13faa:	8a22      	ldrh	r2, [r4, #16]
   13fac:	68e1      	ldr	r1, [r4, #12]
   13fae:	f106 0008 	add.w	r0, r6, #8
   13fb2:	f00d f855 	bl	21060 <memcpy>
        pICMPPkt->wChecksum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pICMPPkt, pktSize, 0);
   13fb6:	464a      	mov	r2, r9
   13fb8:	4629      	mov	r1, r5
   13fba:	4630      	mov	r0, r6
   13fbc:	f006 f97e 	bl	1a2bc <TCPIP_Helper_CalcIPChecksum>
   13fc0:	8070      	strh	r0, [r6, #2]
        pTxPkt->destAddress.Val = pEchoRequest->targetAddr.Val;
   13fc2:	6863      	ldr	r3, [r4, #4]
   13fc4:	63bb      	str	r3, [r7, #56]	; 0x38
        pTxPkt->netIfH = TCPIP_IPV4_SelectSourceInterface(pEchoRequest->netH, &pTxPkt->destAddress, &pTxPkt->srcAddress, false);
   13fc6:	464b      	mov	r3, r9
   13fc8:	f107 0234 	add.w	r2, r7, #52	; 0x34
   13fcc:	f107 0138 	add.w	r1, r7, #56	; 0x38
   13fd0:	6820      	ldr	r0, [r4, #0]
   13fd2:	f008 fc85 	bl	1c8e0 <TCPIP_IPV4_SelectSourceInterface>
   13fd6:	63f8      	str	r0, [r7, #60]	; 0x3c
        if(pTxPkt->netIfH == 0)
   13fd8:	2800      	cmp	r0, #0
   13fda:	d033      	beq.n	14044 <TCPIP_ICMP_EchoRequest+0xe0>
        icmpEchoRequest = *pEchoRequest;
   13fdc:	4e1e      	ldr	r6, [pc, #120]	; (14058 <TCPIP_ICMP_EchoRequest+0xf4>)
   13fde:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   13fe0:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   13fe2:	e894 0003 	ldmia.w	r4, {r0, r1}
   13fe6:	e886 0003 	stmia.w	r6, {r0, r1}
        pTxPkt->macPkt.pDSeg->segLen += pktSize;
   13fea:	693a      	ldr	r2, [r7, #16]
   13fec:	8993      	ldrh	r3, [r2, #12]
   13fee:	442b      	add	r3, r5
   13ff0:	8193      	strh	r3, [r2, #12]
        TCPIP_IPV4_PacketFormatTx(pTxPkt, IP_PROT_ICMP, pktSize, 0);
   13ff2:	464b      	mov	r3, r9
   13ff4:	462a      	mov	r2, r5
   13ff6:	2101      	movs	r1, #1
   13ff8:	4638      	mov	r0, r7
   13ffa:	f7fe ff37 	bl	12e6c <TCPIP_IPV4_PacketFormatTx>
        if(!TCPIP_IPV4_PacketTransmit(pTxPkt))
   13ffe:	4638      	mov	r0, r7
   14000:	f00d ff5c 	bl	21ebc <TCPIP_IPV4_PacketTransmit>
   14004:	b910      	cbnz	r0, 1400c <TCPIP_ICMP_EchoRequest+0xa8>
            res = ICMP_ECHO_TRANSMIT_ERROR;
   14006:	f06f 0402 	mvn.w	r4, #2
   1400a:	e01d      	b.n	14048 <TCPIP_ICMP_EchoRequest+0xe4>
        pIcmpEchoRequest = &icmpEchoRequest; // mark as busy
   1400c:	4b11      	ldr	r3, [pc, #68]	; (14054 <TCPIP_ICMP_EchoRequest+0xf0>)
   1400e:	f1a6 0210 	sub.w	r2, r6, #16
   14012:	601a      	str	r2, [r3, #0]
        icmpEchoStart = SYS_TMR_TickCountGet();
   14014:	f00b ffca 	bl	1ffac <SYS_TMR_TickCountGet>
   14018:	4b10      	ldr	r3, [pc, #64]	; (1405c <TCPIP_ICMP_EchoRequest+0xf8>)
   1401a:	6018      	str	r0, [r3, #0]
        if(pHandle)
   1401c:	f1b8 0f00 	cmp.w	r8, #0
   14020:	d00e      	beq.n	14040 <TCPIP_ICMP_EchoRequest+0xdc>
            *pHandle = pIcmpEchoRequest;
   14022:	4b0c      	ldr	r3, [pc, #48]	; (14054 <TCPIP_ICMP_EchoRequest+0xf0>)
   14024:	681b      	ldr	r3, [r3, #0]
   14026:	f8c8 3000 	str.w	r3, [r8]
        res = ICMP_ECHO_OK;
   1402a:	464c      	mov	r4, r9
   1402c:	e00f      	b.n	1404e <TCPIP_ICMP_EchoRequest+0xea>
        return ICMP_ECHO_BUSY;
   1402e:	f06f 0404 	mvn.w	r4, #4
   14032:	e00c      	b.n	1404e <TCPIP_ICMP_EchoRequest+0xea>
        return ICMP_ECHO_PARAMETER_ERROR;
   14034:	f06f 0403 	mvn.w	r4, #3
   14038:	e009      	b.n	1404e <TCPIP_ICMP_EchoRequest+0xea>
            res = ICMP_ECHO_ALLOC_ERROR;
   1403a:	f04f 34ff 	mov.w	r4, #4294967295
   1403e:	e006      	b.n	1404e <TCPIP_ICMP_EchoRequest+0xea>
        res = ICMP_ECHO_OK;
   14040:	2400      	movs	r4, #0
   14042:	e004      	b.n	1404e <TCPIP_ICMP_EchoRequest+0xea>
            res = ICMP_ECHO_ROUTE_ERROR;
   14044:	f06f 0401 	mvn.w	r4, #1
        TCPIP_PKT_PacketFree(&pTxPkt->macPkt);
   14048:	4638      	mov	r0, r7
   1404a:	f009 ffad 	bl	1dfa8 <_TCPIP_PKT_PacketFree>
}
   1404e:	4620      	mov	r0, r4
   14050:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   14054:	2000e58c 	.word	0x2000e58c
   14058:	2000e3cc 	.word	0x2000e3cc
   1405c:	2000e57c 	.word	0x2000e57c

Disassembly of section .text._Command_AddressService%300:

00014060 <_Command_AddressService>:
{ 
   14060:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   14064:	4604      	mov	r4, r0
   14066:	4615      	mov	r5, r2
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   14068:	6846      	ldr	r6, [r0, #4]
    if (argc != 3)
   1406a:	2903      	cmp	r1, #3
   1406c:	d011      	beq.n	14092 <_Command_AddressService+0x32>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Usage: %s <interface> <on/off> \r\n", argv[0]);
   1406e:	4f31      	ldr	r7, [pc, #196]	; (14134 <_Command_AddressService+0xd4>)
   14070:	6803      	ldr	r3, [r0, #0]
   14072:	685b      	ldr	r3, [r3, #4]
   14074:	6812      	ldr	r2, [r2, #0]
   14076:	f507 71ec 	add.w	r1, r7, #472	; 0x1d8
   1407a:	4630      	mov	r0, r6
   1407c:	4798      	blx	r3
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Ex: %s PIC32INT on \r\n", argv[0]);
   1407e:	6823      	ldr	r3, [r4, #0]
   14080:	685b      	ldr	r3, [r3, #4]
   14082:	682a      	ldr	r2, [r5, #0]
   14084:	f507 71fe 	add.w	r1, r7, #508	; 0x1fc
   14088:	4630      	mov	r0, r6
   1408a:	4798      	blx	r3
        return false;
   1408c:	2000      	movs	r0, #0
}
   1408e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   14092:	461f      	mov	r7, r3
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
   14094:	6850      	ldr	r0, [r2, #4]
   14096:	f009 fc5d 	bl	1d954 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
   1409a:	4681      	mov	r9, r0
   1409c:	b310      	cbz	r0, 140e4 <_Command_AddressService+0x84>
    if (memcmp(argv[2], "on", 2) == 0)
   1409e:	f8d5 8008 	ldr.w	r8, [r5, #8]
   140a2:	2202      	movs	r2, #2
   140a4:	4924      	ldr	r1, [pc, #144]	; (14138 <_Command_AddressService+0xd8>)
   140a6:	4640      	mov	r0, r8
   140a8:	f00c ffcc 	bl	21044 <memcmp>
   140ac:	2800      	cmp	r0, #0
   140ae:	d037      	beq.n	14120 <_Command_AddressService+0xc0>
    else if (memcmp(argv[2], "off", 2) == 0)
   140b0:	2202      	movs	r2, #2
   140b2:	4922      	ldr	r1, [pc, #136]	; (1413c <_Command_AddressService+0xdc>)
   140b4:	4640      	mov	r0, r8
   140b6:	f00c ffc5 	bl	21044 <memcmp>
   140ba:	b9d0      	cbnz	r0, 140f2 <_Command_AddressService+0x92>
    switch(svcType)
   140bc:	2f01      	cmp	r7, #1
   140be:	d131      	bne.n	14124 <_Command_AddressService+0xc4>
            addFnc = svcEnable?TCPIP_DHCP_Enable:TCPIP_DHCP_Disable;
   140c0:	4b1f      	ldr	r3, [pc, #124]	; (14140 <_Command_AddressService+0xe0>)
        msgOK   = svcEnable?"enabled":"disabled";
   140c2:	4a1c      	ldr	r2, [pc, #112]	; (14134 <_Command_AddressService+0xd4>)
   140c4:	f502 77da 	add.w	r7, r2, #436	; 0x1b4
        msgFail = svcEnable?"enable":"disable";
   140c8:	f502 78e0 	add.w	r8, r2, #448	; 0x1c0
        addRes = (*addFnc)(netH);
   140cc:	4648      	mov	r0, r9
   140ce:	4798      	blx	r3
        if(addRes)
   140d0:	b1e8      	cbz	r0, 1410e <_Command_AddressService+0xae>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "%s %s\r\n", argv[0], msgOK);
   140d2:	6823      	ldr	r3, [r4, #0]
   140d4:	685c      	ldr	r4, [r3, #4]
   140d6:	463b      	mov	r3, r7
   140d8:	682a      	ldr	r2, [r5, #0]
   140da:	491a      	ldr	r1, [pc, #104]	; (14144 <_Command_AddressService+0xe4>)
   140dc:	4630      	mov	r0, r6
   140de:	47a0      	blx	r4
    return true;
   140e0:	2001      	movs	r0, #1
   140e2:	e7d4      	b.n	1408e <_Command_AddressService+0x2e>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface\r\n");
   140e4:	6823      	ldr	r3, [r4, #0]
   140e6:	681b      	ldr	r3, [r3, #0]
   140e8:	4917      	ldr	r1, [pc, #92]	; (14148 <_Command_AddressService+0xe8>)
   140ea:	4630      	mov	r0, r6
   140ec:	4798      	blx	r3
        return false;
   140ee:	2000      	movs	r0, #0
   140f0:	e7cd      	b.n	1408e <_Command_AddressService+0x2e>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown option\r\n");
   140f2:	6823      	ldr	r3, [r4, #0]
   140f4:	681b      	ldr	r3, [r3, #0]
   140f6:	4915      	ldr	r1, [pc, #84]	; (1414c <_Command_AddressService+0xec>)
   140f8:	4630      	mov	r0, r6
   140fa:	4798      	blx	r3
        return false;
   140fc:	2000      	movs	r0, #0
   140fe:	e7c6      	b.n	1408e <_Command_AddressService+0x2e>
            addFnc = svcEnable?TCPIP_DHCP_Enable:TCPIP_DHCP_Disable;
   14100:	4b13      	ldr	r3, [pc, #76]	; (14150 <_Command_AddressService+0xf0>)
        msgOK   = svcEnable?"enabled":"disabled";
   14102:	4a0c      	ldr	r2, [pc, #48]	; (14134 <_Command_AddressService+0xd4>)
   14104:	f502 77e4 	add.w	r7, r2, #456	; 0x1c8
        msgFail = svcEnable?"enable":"disable";
   14108:	f502 78e8 	add.w	r8, r2, #464	; 0x1d0
   1410c:	e7de      	b.n	140cc <_Command_AddressService+0x6c>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Failed to %s %s\r\n", msgFail, argv[0]);
   1410e:	6823      	ldr	r3, [r4, #0]
   14110:	685c      	ldr	r4, [r3, #4]
   14112:	682b      	ldr	r3, [r5, #0]
   14114:	4642      	mov	r2, r8
   14116:	490f      	ldr	r1, [pc, #60]	; (14154 <_Command_AddressService+0xf4>)
   14118:	4630      	mov	r0, r6
   1411a:	47a0      	blx	r4
    return true;
   1411c:	2001      	movs	r0, #1
   1411e:	e7b6      	b.n	1408e <_Command_AddressService+0x2e>
    switch(svcType)
   14120:	2f01      	cmp	r7, #1
   14122:	d0ed      	beq.n	14100 <_Command_AddressService+0xa0>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Unknown service %s\r\n", argv[0]);
   14124:	6823      	ldr	r3, [r4, #0]
   14126:	685b      	ldr	r3, [r3, #4]
   14128:	682a      	ldr	r2, [r5, #0]
   1412a:	490b      	ldr	r1, [pc, #44]	; (14158 <_Command_AddressService+0xf8>)
   1412c:	4630      	mov	r0, r6
   1412e:	4798      	blx	r3
    return true;
   14130:	2001      	movs	r0, #1
   14132:	e7ac      	b.n	1408e <_Command_AddressService+0x2e>
   14134:	0000028c 	.word	0x0000028c
   14138:	000004b4 	.word	0x000004b4
   1413c:	000004b8 	.word	0x000004b8
   14140:	0001b2a1 	.word	0x0001b2a1
   14144:	000004d0 	.word	0x000004d0
   14148:	000004a0 	.word	0x000004a0
   1414c:	000004bc 	.word	0x000004bc
   14150:	0001b6b1 	.word	0x0001b6b1
   14154:	000004d8 	.word	0x000004d8
   14158:	000004ec 	.word	0x000004ec

Disassembly of section .text._Command_HeapInfo%301:

0001415c <_Command_HeapInfo>:
{
   1415c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14160:	b085      	sub	sp, #20
   14162:	4605      	mov	r5, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   14164:	6843      	ldr	r3, [r0, #4]
   14166:	9301      	str	r3, [sp, #4]
    if (argc > 1)
   14168:	2901      	cmp	r1, #1
   1416a:	dc51      	bgt.n	14210 <_Command_HeapInfo+0xb4>
    bool hasArgs = false;
   1416c:	2300      	movs	r3, #0
   1416e:	9303      	str	r3, [sp, #12]
        endType = TCPIP_STACK_HEAP_TYPES;
   14170:	2704      	movs	r7, #4
        startType = TCPIP_STACK_HEAP_TYPE_NONE + 1;
   14172:	2601      	movs	r6, #1
    for(hType = startType; hType < endType; hType++)
   14174:	4b35      	ldr	r3, [pc, #212]	; (1424c <_Command_HeapInfo+0xf0>)
   14176:	eb03 0986 	add.w	r9, r3, r6, lsl #2
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Heap type: %s. Initial created heap size: %d Bytes\r\n", typeMsg, heapSize);
   1417a:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 14254 <_Command_HeapInfo+0xf8>
   1417e:	f508 6310 	add.w	r3, r8, #2304	; 0x900
   14182:	9302      	str	r3, [sp, #8]
   14184:	46ba      	mov	sl, r7
        typeMsg = heapTypeStr[hType];
   14186:	f859 7b04 	ldr.w	r7, [r9], #4
        heapH = TCPIP_STACK_HeapHandleGet(hType, 0);
   1418a:	2100      	movs	r1, #0
   1418c:	b2f0      	uxtb	r0, r6
   1418e:	f00d fb47 	bl	21820 <TCPIP_STACK_HeapHandleGet>
        if(heapH == 0)
   14192:	4604      	mov	r4, r0
   14194:	2800      	cmp	r0, #0
   14196:	d04e      	beq.n	14236 <_Command_HeapInfo+0xda>
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Size)(h);
   14198:	6903      	ldr	r3, [r0, #16]
   1419a:	4798      	blx	r3
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Heap type: %s. Initial created heap size: %d Bytes\r\n", typeMsg, heapSize);
   1419c:	682b      	ldr	r3, [r5, #0]
   1419e:	f8d3 b004 	ldr.w	fp, [r3, #4]
   141a2:	4603      	mov	r3, r0
   141a4:	463a      	mov	r2, r7
   141a6:	9902      	ldr	r1, [sp, #8]
   141a8:	9801      	ldr	r0, [sp, #4]
   141aa:	47d8      	blx	fp
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Allocable block heap size: %d Bytes\r\n", TCPIP_HEAP_MaxSize(heapH));
   141ac:	682b      	ldr	r3, [r5, #0]
   141ae:	685f      	ldr	r7, [r3, #4]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_MaxSize)(h);
   141b0:	6963      	ldr	r3, [r4, #20]
   141b2:	4620      	mov	r0, r4
   141b4:	4798      	blx	r3
   141b6:	4602      	mov	r2, r0
   141b8:	f608 1138 	addw	r1, r8, #2360	; 0x938
   141bc:	9801      	ldr	r0, [sp, #4]
   141be:	47b8      	blx	r7
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "All available heap size: %d Bytes, high watermark: %d\r\n", TCPIP_HEAP_FreeSize(heapH), TCPIP_HEAP_HighWatermark(heapH));
   141c0:	682b      	ldr	r3, [r5, #0]
   141c2:	685f      	ldr	r7, [r3, #4]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_FreeSize)(h);
   141c4:	69a3      	ldr	r3, [r4, #24]
   141c6:	4620      	mov	r0, r4
   141c8:	4798      	blx	r3
   141ca:	4683      	mov	fp, r0
}
#define TCPIP_HEAP_FreeSize(h) TCPIP_HEAP_FreeSizeInline(h)

static __inline__ size_t __attribute__((always_inline)) TCPIP_HEAP_HighWatermarkInline(TCPIP_STACK_HEAP_HANDLE h)
{
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_HighWatermark)(h);
   141cc:	69e3      	ldr	r3, [r4, #28]
   141ce:	4620      	mov	r0, r4
   141d0:	4798      	blx	r3
   141d2:	4603      	mov	r3, r0
   141d4:	465a      	mov	r2, fp
   141d6:	f508 6116 	add.w	r1, r8, #2400	; 0x960
   141da:	f8dd b004 	ldr.w	fp, [sp, #4]
   141de:	4658      	mov	r0, fp
   141e0:	47b8      	blx	r7
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Last heap error: 0x%x\r\n", TCPIP_HEAP_LastError(heapH));
   141e2:	682b      	ldr	r3, [r5, #0]
   141e4:	685f      	ldr	r7, [r3, #4]
}
#define TCPIP_HEAP_HighWatermark(h) TCPIP_HEAP_HighWatermarkInline(h)

static __inline__ TCPIP_STACK_HEAP_RES __attribute__((always_inline)) TCPIP_HEAP_LastErrorInline(TCPIP_STACK_HEAP_HANDLE h)
{
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_LastError)(h);
   141e6:	6a23      	ldr	r3, [r4, #32]
   141e8:	4620      	mov	r0, r4
   141ea:	4798      	blx	r3
   141ec:	4602      	mov	r2, r0
   141ee:	f608 1198 	addw	r1, r8, #2456	; 0x998
   141f2:	4658      	mov	r0, fp
   141f4:	47b8      	blx	r7
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "No Trace info exists.\r\n");
   141f6:	682b      	ldr	r3, [r5, #0]
   141f8:	681b      	ldr	r3, [r3, #0]
   141fa:	f508 611b 	add.w	r1, r8, #2480	; 0x9b0
   141fe:	4658      	mov	r0, fp
   14200:	4798      	blx	r3
    for(hType = startType; hType < endType; hType++)
   14202:	3601      	adds	r6, #1
   14204:	45b2      	cmp	sl, r6
   14206:	d8be      	bhi.n	14186 <_Command_HeapInfo+0x2a>
    return true;
   14208:	2001      	movs	r0, #1
}
   1420a:	b005      	add	sp, #20
   1420c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        hType = (unsigned int)atoi(argv[1]);
   14210:	6850      	ldr	r0, [r2, #4]
   14212:	f00d ff6b 	bl	220ec <atoi>
   14216:	4606      	mov	r6, r0
        if(hType == TCPIP_STACK_HEAP_TYPE_NONE || hType >= TCPIP_STACK_HEAP_TYPES)
   14218:	1e43      	subs	r3, r0, #1
   1421a:	2b02      	cmp	r3, #2
   1421c:	d803      	bhi.n	14226 <_Command_HeapInfo+0xca>
        endType = hType + 1;
   1421e:	1c47      	adds	r7, r0, #1
        hasArgs = true;
   14220:	2301      	movs	r3, #1
   14222:	9303      	str	r3, [sp, #12]
   14224:	e7a6      	b.n	14174 <_Command_HeapInfo+0x18>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Unknown heap type. Use: [1, %d]\r\n", TCPIP_STACK_HEAP_TYPES - 1);
   14226:	682b      	ldr	r3, [r5, #0]
   14228:	685b      	ldr	r3, [r3, #4]
   1422a:	2203      	movs	r2, #3
   1422c:	4908      	ldr	r1, [pc, #32]	; (14250 <_Command_HeapInfo+0xf4>)
   1422e:	9801      	ldr	r0, [sp, #4]
   14230:	4798      	blx	r3
            return false;
   14232:	2000      	movs	r0, #0
   14234:	e7e9      	b.n	1420a <_Command_HeapInfo+0xae>
            if(hasArgs == true)
   14236:	9b03      	ldr	r3, [sp, #12]
   14238:	2b00      	cmp	r3, #0
   1423a:	d0e2      	beq.n	14202 <_Command_HeapInfo+0xa6>
                (*pCmdIO->pCmdApi->print)(cmdIoParam, "No heap info exists for type: %s!\r\n", typeMsg);
   1423c:	682b      	ldr	r3, [r5, #0]
   1423e:	685b      	ldr	r3, [r3, #4]
   14240:	463a      	mov	r2, r7
   14242:	f608 01dc 	addw	r1, r8, #2268	; 0x8dc
   14246:	9801      	ldr	r0, [sp, #4]
   14248:	4798      	blx	r3
   1424a:	e7da      	b.n	14202 <_Command_HeapInfo+0xa6>
   1424c:	00021a4c 	.word	0x00021a4c
   14250:	00000b44 	.word	0x00000b44
   14254:	0000028c 	.word	0x0000028c

Disassembly of section .text.CLOCK_Initialize%302:

00014258 <CLOCK_Initialize>:
}

static void OSC32KCTRL_Initialize(void)
{

    OSC32KCTRL_REGS->OSC32KCTRL_RTCCTRL = OSC32KCTRL_RTCCTRL_RTCSEL(0);
   14258:	4b36      	ldr	r3, [pc, #216]	; (14334 <CLOCK_Initialize+0xdc>)
   1425a:	2200      	movs	r2, #0
   1425c:	741a      	strb	r2, [r3, #16]
    }
}

static void GCLK2_Initialize(void)
{
    GCLK_REGS->GCLK_GENCTRL[2] = GCLK_GENCTRL_DIV(48) | GCLK_GENCTRL_SRC(6) | GCLK_GENCTRL_GENEN_Msk;
   1425e:	f503 6300 	add.w	r3, r3, #2048	; 0x800
   14262:	4a35      	ldr	r2, [pc, #212]	; (14338 <CLOCK_Initialize+0xe0>)
   14264:	629a      	str	r2, [r3, #40]	; 0x28

    while((GCLK_REGS->GCLK_SYNCBUSY & GCLK_SYNCBUSY_GENCTRL_GCLK2) == GCLK_SYNCBUSY_GENCTRL_GCLK2)
   14266:	461a      	mov	r2, r3
   14268:	6853      	ldr	r3, [r2, #4]
   1426a:	f013 0f10 	tst.w	r3, #16
   1426e:	d1fb      	bne.n	14268 <CLOCK_Initialize+0x10>
    GCLK_REGS->GCLK_PCHCTRL[1] = GCLK_PCHCTRL_GEN(0x2)  | GCLK_PCHCTRL_CHEN_Msk;
   14270:	4b32      	ldr	r3, [pc, #200]	; (1433c <CLOCK_Initialize+0xe4>)
   14272:	2242      	movs	r2, #66	; 0x42
   14274:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    while ((GCLK_REGS->GCLK_PCHCTRL[1] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
   14278:	461a      	mov	r2, r3
   1427a:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
   1427e:	f013 0f40 	tst.w	r3, #64	; 0x40
   14282:	d0fa      	beq.n	1427a <CLOCK_Initialize+0x22>
    OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLCTRLB = OSCCTRL_DPLLCTRLB_FILTER(0) | OSCCTRL_DPLLCTRLB_LTIME(0x0)| OSCCTRL_DPLLCTRLB_REFCLK(0) ;
   14284:	4b2e      	ldr	r3, [pc, #184]	; (14340 <CLOCK_Initialize+0xe8>)
   14286:	2200      	movs	r2, #0
   14288:	639a      	str	r2, [r3, #56]	; 0x38
    OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLRATIO = OSCCTRL_DPLLRATIO_LDRFRAC(0) | OSCCTRL_DPLLRATIO_LDR(119);
   1428a:	2277      	movs	r2, #119	; 0x77
   1428c:	635a      	str	r2, [r3, #52]	; 0x34
    while((OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLSYNCBUSY & OSCCTRL_DPLLSYNCBUSY_DPLLRATIO_Msk) == OSCCTRL_DPLLSYNCBUSY_DPLLRATIO_Msk)
   1428e:	461a      	mov	r2, r3
   14290:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   14292:	f013 0f04 	tst.w	r3, #4
   14296:	d1fb      	bne.n	14290 <CLOCK_Initialize+0x38>
    OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLCTRLA = OSCCTRL_DPLLCTRLA_ENABLE_Msk   ;
   14298:	4b29      	ldr	r3, [pc, #164]	; (14340 <CLOCK_Initialize+0xe8>)
   1429a:	2202      	movs	r2, #2
   1429c:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    while((OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLSYNCBUSY & OSCCTRL_DPLLSYNCBUSY_ENABLE_Msk) == OSCCTRL_DPLLSYNCBUSY_ENABLE_Msk )
   142a0:	461a      	mov	r2, r3
   142a2:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
   142a4:	f013 0f02 	tst.w	r3, #2
   142a8:	d1fb      	bne.n	142a2 <CLOCK_Initialize+0x4a>
    while((OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLSTATUS & (OSCCTRL_DPLLSTATUS_LOCK_Msk | OSCCTRL_DPLLSTATUS_CLKRDY_Msk)) !=
   142aa:	4a25      	ldr	r2, [pc, #148]	; (14340 <CLOCK_Initialize+0xe8>)
   142ac:	6c13      	ldr	r3, [r2, #64]	; 0x40
   142ae:	f003 0303 	and.w	r3, r3, #3
   142b2:	2b03      	cmp	r3, #3
   142b4:	d1fa      	bne.n	142ac <CLOCK_Initialize+0x54>
    MCLK_REGS->MCLK_CPUDIV = MCLK_CPUDIV_DIV(0x01);
   142b6:	4b23      	ldr	r3, [pc, #140]	; (14344 <CLOCK_Initialize+0xec>)
   142b8:	2201      	movs	r2, #1
   142ba:	715a      	strb	r2, [r3, #5]
    while((MCLK_REGS->MCLK_INTFLAG & MCLK_INTFLAG_CKRDY_Msk) != MCLK_INTFLAG_CKRDY_Msk)
   142bc:	461a      	mov	r2, r3
   142be:	78d3      	ldrb	r3, [r2, #3]
   142c0:	f013 0f01 	tst.w	r3, #1
   142c4:	d0fb      	beq.n	142be <CLOCK_Initialize+0x66>
    GCLK_REGS->GCLK_GENCTRL[0] = GCLK_GENCTRL_DIV(1) | GCLK_GENCTRL_SRC(7) | GCLK_GENCTRL_GENEN_Msk;
   142c6:	4b1d      	ldr	r3, [pc, #116]	; (1433c <CLOCK_Initialize+0xe4>)
   142c8:	4a1f      	ldr	r2, [pc, #124]	; (14348 <CLOCK_Initialize+0xf0>)
   142ca:	621a      	str	r2, [r3, #32]
    while((GCLK_REGS->GCLK_SYNCBUSY & GCLK_SYNCBUSY_GENCTRL_GCLK0) == GCLK_SYNCBUSY_GENCTRL_GCLK0)
   142cc:	461a      	mov	r2, r3
   142ce:	6853      	ldr	r3, [r2, #4]
   142d0:	f013 0f04 	tst.w	r3, #4
   142d4:	d1fb      	bne.n	142ce <CLOCK_Initialize+0x76>
    GCLK_REGS->GCLK_GENCTRL[1] = GCLK_GENCTRL_DIV(2) | GCLK_GENCTRL_SRC(7) | GCLK_GENCTRL_GENEN_Msk;
   142d6:	4b19      	ldr	r3, [pc, #100]	; (1433c <CLOCK_Initialize+0xe4>)
   142d8:	4a1c      	ldr	r2, [pc, #112]	; (1434c <CLOCK_Initialize+0xf4>)
   142da:	625a      	str	r2, [r3, #36]	; 0x24
    while((GCLK_REGS->GCLK_SYNCBUSY & GCLK_SYNCBUSY_GENCTRL_GCLK1) == GCLK_SYNCBUSY_GENCTRL_GCLK1)
   142dc:	461a      	mov	r2, r3
   142de:	6853      	ldr	r3, [r2, #4]
   142e0:	f013 0f08 	tst.w	r3, #8
   142e4:	d1fb      	bne.n	142de <CLOCK_Initialize+0x86>
    GCLK1_Initialize();



    /* Selection of the Generator and write Lock for SERCOM0_CORE */
    GCLK_REGS->GCLK_PCHCTRL[7] = GCLK_PCHCTRL_GEN(0x1)  | GCLK_PCHCTRL_CHEN_Msk;
   142e6:	4b15      	ldr	r3, [pc, #84]	; (1433c <CLOCK_Initialize+0xe4>)
   142e8:	2241      	movs	r2, #65	; 0x41
   142ea:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c

    while ((GCLK_REGS->GCLK_PCHCTRL[7] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
   142ee:	461a      	mov	r2, r3
   142f0:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
   142f4:	f013 0f40 	tst.w	r3, #64	; 0x40
   142f8:	d0fa      	beq.n	142f0 <CLOCK_Initialize+0x98>
    {
        /* Wait for synchronization */
    }
    /* Selection of the Generator and write Lock for SERCOM1_CORE */
    GCLK_REGS->GCLK_PCHCTRL[8] = GCLK_PCHCTRL_GEN(0x1)  | GCLK_PCHCTRL_CHEN_Msk;
   142fa:	4b10      	ldr	r3, [pc, #64]	; (1433c <CLOCK_Initialize+0xe4>)
   142fc:	2241      	movs	r2, #65	; 0x41
   142fe:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

    while ((GCLK_REGS->GCLK_PCHCTRL[8] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
   14302:	461a      	mov	r2, r3
   14304:	f8d2 30a0 	ldr.w	r3, [r2, #160]	; 0xa0
   14308:	f013 0f40 	tst.w	r3, #64	; 0x40
   1430c:	d0fa      	beq.n	14304 <CLOCK_Initialize+0xac>
    {
        /* Wait for synchronization */
    }
    /* Selection of the Generator and write Lock for TC0 TC1 */
    GCLK_REGS->GCLK_PCHCTRL[9] = GCLK_PCHCTRL_GEN(0x1)  | GCLK_PCHCTRL_CHEN_Msk;
   1430e:	4b0b      	ldr	r3, [pc, #44]	; (1433c <CLOCK_Initialize+0xe4>)
   14310:	2241      	movs	r2, #65	; 0x41
   14312:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4

    while ((GCLK_REGS->GCLK_PCHCTRL[9] & GCLK_PCHCTRL_CHEN_Msk) != GCLK_PCHCTRL_CHEN_Msk)
   14316:	461a      	mov	r2, r3
   14318:	f8d2 30a4 	ldr.w	r3, [r2, #164]	; 0xa4
   1431c:	f013 0f40 	tst.w	r3, #64	; 0x40
   14320:	d0fa      	beq.n	14318 <CLOCK_Initialize+0xc0>
    {
        /* Wait for synchronization */
    }

    /* Configure the AHB Bridge Clocks */
    MCLK_REGS->MCLK_AHBMASK = 0xffffff;
   14322:	4b08      	ldr	r3, [pc, #32]	; (14344 <CLOCK_Initialize+0xec>)
   14324:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
   14328:	611a      	str	r2, [r3, #16]

    /* Configure the APBA Bridge Clocks */
    MCLK_REGS->MCLK_APBAMASK = 0x77ff;
   1432a:	f247 72ff 	movw	r2, #30719	; 0x77ff
   1432e:	615a      	str	r2, [r3, #20]


}
   14330:	4770      	bx	lr
   14332:	bf00      	nop
   14334:	40001400 	.word	0x40001400
   14338:	00300106 	.word	0x00300106
   1433c:	40001c00 	.word	0x40001c00
   14340:	40001000 	.word	0x40001000
   14344:	40000800 	.word	0x40000800
   14348:	00010107 	.word	0x00010107
   1434c:	00020107 	.word	0x00020107

Disassembly of section .text.TCPIP_TCP_Deinitialize%303:

00014350 <TCPIP_TCP_Deinitialize>:
{
   14350:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14354:	4606      	mov	r6, r0
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);  // System Lock
   14356:	2000      	movs	r0, #0
   14358:	f00d f8a0 	bl	2149c <OSAL_CRIT_Enter>
    if(tcpLockCount == 1)
   1435c:	4b33      	ldr	r3, [pc, #204]	; (1442c <TCPIP_TCP_Deinitialize+0xdc>)
   1435e:	681b      	ldr	r3, [r3, #0]
   14360:	2b01      	cmp	r3, #1
   14362:	d005      	beq.n	14370 <TCPIP_TCP_Deinitialize+0x20>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);  // System unlock
   14364:	4601      	mov	r1, r0
   14366:	2000      	movs	r0, #0
   14368:	f00d f9c7 	bl	216fa <OSAL_CRIT_Leave>
}
   1436c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(tcpInitCount <= 0)
   14370:	4b2f      	ldr	r3, [pc, #188]	; (14430 <TCPIP_TCP_Deinitialize+0xe0>)
   14372:	681b      	ldr	r3, [r3, #0]
   14374:	2b00      	cmp	r3, #0
   14376:	dd54      	ble.n	14422 <TCPIP_TCP_Deinitialize+0xd2>
            tcpLockCount = 2;   // get lock
   14378:	4b2c      	ldr	r3, [pc, #176]	; (1442c <TCPIP_TCP_Deinitialize+0xdc>)
   1437a:	2202      	movs	r2, #2
   1437c:	601a      	str	r2, [r3, #0]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);  // System unlock
   1437e:	4601      	mov	r1, r0
   14380:	2000      	movs	r0, #0
   14382:	f00d f9ba 	bl	216fa <OSAL_CRIT_Leave>
        _TCPAbortSockets(1 << stackInit->netIx, TCPIP_TCP_SIGNAL_IF_DOWN); 
   14386:	69b3      	ldr	r3, [r6, #24]
   14388:	f04f 0901 	mov.w	r9, #1
   1438c:	fa09 f903 	lsl.w	r9, r9, r3
    for(ix = 0; ix < TcpSockets; ix++)
   14390:	4b28      	ldr	r3, [pc, #160]	; (14434 <TCPIP_TCP_Deinitialize+0xe4>)
   14392:	681b      	ldr	r3, [r3, #0]
   14394:	b37b      	cbz	r3, 143f6 <TCPIP_TCP_Deinitialize+0xa6>
   14396:	2400      	movs	r4, #0
        if((pSkt = TCBStubs[ix]) != 0)  
   14398:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 1443c <TCPIP_TCP_Deinitialize+0xec>
                uint32_t sktIfMask = 1 << netIx;
   1439c:	f04f 0a01 	mov.w	sl, #1
    for(ix = 0; ix < TcpSockets; ix++)
   143a0:	4f24      	ldr	r7, [pc, #144]	; (14434 <TCPIP_TCP_Deinitialize+0xe4>)
   143a2:	e017      	b.n	143d4 <TCPIP_TCP_Deinitialize+0x84>
                    bool isServer = pSkt->Flags.bServer;
   143a4:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
   143a8:	f003 0b01 	and.w	fp, r3, #1
                    pSkt->Flags.bServer = 1;
   143ac:	f043 0301 	orr.w	r3, r3, #1
   143b0:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
                    _TcpAbort(pSkt, _TCP_ABORT_FLAG_REGULAR, sigType);
   143b4:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   143b8:	2100      	movs	r1, #0
   143ba:	4628      	mov	r0, r5
   143bc:	f007 fe92 	bl	1c0e4 <_TcpAbort>
                    pSkt->Flags.bServer = isServer;
   143c0:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
   143c4:	f36b 0300 	bfi	r3, fp, #0, #1
   143c8:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
    for(ix = 0; ix < TcpSockets; ix++)
   143cc:	3401      	adds	r4, #1
   143ce:	683b      	ldr	r3, [r7, #0]
   143d0:	42a3      	cmp	r3, r4
   143d2:	d910      	bls.n	143f6 <TCPIP_TCP_Deinitialize+0xa6>
        if((pSkt = TCBStubs[ix]) != 0)  
   143d4:	f8d8 3000 	ldr.w	r3, [r8]
   143d8:	f853 5024 	ldr.w	r5, [r3, r4, lsl #2]
   143dc:	2d00      	cmp	r5, #0
   143de:	d0f5      	beq.n	143cc <TCPIP_TCP_Deinitialize+0x7c>
            int netIx = TCPIP_STACK_NetIxGet(pSkt->pSktNet);
   143e0:	6c28      	ldr	r0, [r5, #64]	; 0x40
   143e2:	f00d fc17 	bl	21c14 <TCPIP_STACK_NetIxGet>
            if(netIx >= 0 )
   143e6:	2800      	cmp	r0, #0
   143e8:	dbf0      	blt.n	143cc <TCPIP_TCP_Deinitialize+0x7c>
                uint32_t sktIfMask = 1 << netIx;
   143ea:	fa0a f000 	lsl.w	r0, sl, r0
                if((sktIfMask & netMask) != 0)
   143ee:	ea10 0f09 	tst.w	r0, r9
   143f2:	d0eb      	beq.n	143cc <TCPIP_TCP_Deinitialize+0x7c>
   143f4:	e7d6      	b.n	143a4 <TCPIP_TCP_Deinitialize+0x54>
        if(stackInit->stackAction == TCPIP_STACK_ACTION_DEINIT && --tcpInitCount == 0)
   143f6:	7f33      	ldrb	r3, [r6, #28]
   143f8:	2b02      	cmp	r3, #2
   143fa:	d003      	beq.n	14404 <TCPIP_TCP_Deinitialize+0xb4>
            tcpLockCount = 1;   // release lock
   143fc:	4b0b      	ldr	r3, [pc, #44]	; (1442c <TCPIP_TCP_Deinitialize+0xdc>)
   143fe:	2201      	movs	r2, #1
   14400:	601a      	str	r2, [r3, #0]
}
   14402:	e7b3      	b.n	1436c <TCPIP_TCP_Deinitialize+0x1c>
        if(stackInit->stackAction == TCPIP_STACK_ACTION_DEINIT && --tcpInitCount == 0)
   14404:	4a0a      	ldr	r2, [pc, #40]	; (14430 <TCPIP_TCP_Deinitialize+0xe0>)
   14406:	6813      	ldr	r3, [r2, #0]
   14408:	3b01      	subs	r3, #1
   1440a:	6013      	str	r3, [r2, #0]
   1440c:	2b00      	cmp	r3, #0
   1440e:	d1f5      	bne.n	143fc <TCPIP_TCP_Deinitialize+0xac>
            _TcpCleanup();
   14410:	f006 f89e 	bl	1a550 <_TcpCleanup>
            OSAL_SEM_Delete(&tcpSemaphore);
   14414:	4808      	ldr	r0, [pc, #32]	; (14438 <TCPIP_TCP_Deinitialize+0xe8>)
   14416:	f00d faa9 	bl	2196c <OSAL_SEM_Delete>
            tcpLockCount = 0;   // leave it uninitialized
   1441a:	4b04      	ldr	r3, [pc, #16]	; (1442c <TCPIP_TCP_Deinitialize+0xdc>)
   1441c:	2200      	movs	r2, #0
   1441e:	601a      	str	r2, [r3, #0]
   14420:	e7a4      	b.n	1436c <TCPIP_TCP_Deinitialize+0x1c>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);  // System unlock
   14422:	4601      	mov	r1, r0
   14424:	2000      	movs	r0, #0
   14426:	f00d f968 	bl	216fa <OSAL_CRIT_Leave>
    if(deinitFault)
   1442a:	e79f      	b.n	1436c <TCPIP_TCP_Deinitialize+0x1c>
   1442c:	2000e5a4 	.word	0x2000e5a4
   14430:	2000e5a0 	.word	0x2000e5a0
   14434:	2000e598 	.word	0x2000e598
   14438:	2000e5a8 	.word	0x2000e5a8
   1443c:	2000e594 	.word	0x2000e594

Disassembly of section .text.TCPIP_ARP_EntryRemoveNet%304:

00014440 <TCPIP_ARP_EntryRemoveNet>:
    TCPIP_NET_IF    *pIf;
    int             index;
    uint16_t        andFlags, resFlags;
    uint32_t        matchAdd;

    if(ipAdd == 0 || ipAdd->Val == 0)
   14440:	2900      	cmp	r1, #0
   14442:	d064      	beq.n	1450e <TCPIP_ARP_EntryRemoveNet+0xce>
{
   14444:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14448:	b083      	sub	sp, #12
   1444a:	460c      	mov	r4, r1
    if(ipAdd == 0 || ipAdd->Val == 0)
   1444c:	6809      	ldr	r1, [r1, #0]
   1444e:	2900      	cmp	r1, #0
   14450:	d060      	beq.n	14514 <TCPIP_ARP_EntryRemoveNet+0xd4>
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   14452:	2800      	cmp	r0, #0
   14454:	d061      	beq.n	1451a <TCPIP_ARP_EntryRemoveNet+0xda>
   14456:	f890 1042 	ldrb.w	r1, [r0, #66]	; 0x42
   1445a:	f011 0f40 	tst.w	r1, #64	; 0x40
   1445e:	d104      	bne.n	1446a <TCPIP_ARP_EntryRemoveNet+0x2a>
    }

    pIf = _TCPIPStackHandleToNetUp(hNet);
    if(!pIf)
    {
        return ARP_RES_NO_INTERFACE;
   14460:	f06f 0005 	mvn.w	r0, #5
            }
        }
    }

    return ARP_RES_OK;
}
   14464:	b003      	add	sp, #12
   14466:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    switch (type)
   1446a:	3b01      	subs	r3, #1
   1446c:	2b03      	cmp	r3, #3
   1446e:	d857      	bhi.n	14520 <TCPIP_ARP_EntryRemoveNet+0xe0>
   14470:	e8df f003 	tbb	[pc, r3]
   14474:	0b06020f 	.word	0x0b06020f
            andFlags = resFlags =  ARP_FLAG_ENTRY_COMPLETE;
   14478:	f04f 0980 	mov.w	r9, #128	; 0x80
   1447c:	46ca      	mov	sl, r9
   1447e:	e00b      	b.n	14498 <TCPIP_ARP_EntryRemoveNet+0x58>
            resFlags = 0;
   14480:	f04f 0900 	mov.w	r9, #0
            andFlags = (ARP_FLAG_ENTRY_PERM | ARP_FLAG_ENTRY_COMPLETE);
   14484:	f04f 0ac0 	mov.w	sl, #192	; 0xc0
            break;
   14488:	e006      	b.n	14498 <TCPIP_ARP_EntryRemoveNet+0x58>
            andFlags = resFlags = 0;
   1448a:	f04f 0900 	mov.w	r9, #0
   1448e:	46ca      	mov	sl, r9
            break;
   14490:	e002      	b.n	14498 <TCPIP_ARP_EntryRemoveNet+0x58>
            andFlags = resFlags = ARP_FLAG_ENTRY_PERM;
   14492:	f04f 0940 	mov.w	r9, #64	; 0x40
   14496:	46ca      	mov	sl, r9
   14498:	4617      	mov	r7, r2
   1449a:	9001      	str	r0, [sp, #4]
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   1449c:	4b23      	ldr	r3, [pc, #140]	; (1452c <TCPIP_ARP_EntryRemoveNet+0xec>)
   1449e:	685d      	ldr	r5, [r3, #4]
   144a0:	f00d fbb8 	bl	21c14 <TCPIP_STACK_NetIxGet>
   144a4:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   144a8:	00c0      	lsls	r0, r0, #3
   144aa:	eb05 0800 	add.w	r8, r5, r0
    pOH = pArpDcpt->hashDcpt;
   144ae:	582e      	ldr	r6, [r5, r0]
    matchAdd = ipAdd->Val & mask->Val;
   144b0:	6822      	ldr	r2, [r4, #0]
   144b2:	683b      	ldr	r3, [r7, #0]
   144b4:	ea02 0b03 	and.w	fp, r2, r3
    for(index = 0; index < pOH->hEntries; index++)
   144b8:	68f3      	ldr	r3, [r6, #12]
   144ba:	b3a3      	cbz	r3, 14526 <TCPIP_ARP_EntryRemoveNet+0xe6>
   144bc:	2400      	movs	r4, #0
   144be:	e003      	b.n	144c8 <TCPIP_ARP_EntryRemoveNet+0x88>
   144c0:	3401      	adds	r4, #1
   144c2:	68f3      	ldr	r3, [r6, #12]
   144c4:	42a3      	cmp	r3, r4
   144c6:	d920      	bls.n	1450a <TCPIP_ARP_EntryRemoveNet+0xca>
        hE = TCPIP_OAHASH_EntryGet(pArpDcpt->hashDcpt, index);
   144c8:	4621      	mov	r1, r4
   144ca:	f8d8 0000 	ldr.w	r0, [r8]
   144ce:	f00d fa44 	bl	2195a <TCPIP_OAHASH_EntryGet>
   144d2:	4605      	mov	r5, r0
        if(hE->flags.busy != 0)
   144d4:	7803      	ldrb	r3, [r0, #0]
   144d6:	f013 0f01 	tst.w	r3, #1
   144da:	d0f1      	beq.n	144c0 <TCPIP_ARP_EntryRemoveNet+0x80>
            if((hE->flags.value & andFlags) == resFlags)
   144dc:	8803      	ldrh	r3, [r0, #0]
   144de:	ea0a 0303 	and.w	r3, sl, r3
   144e2:	454b      	cmp	r3, r9
   144e4:	d1ec      	bne.n	144c0 <TCPIP_ARP_EntryRemoveNet+0x80>
                if((arpHE->ipAddress.Val & mask->Val) == matchAdd)
   144e6:	6883      	ldr	r3, [r0, #8]
   144e8:	683a      	ldr	r2, [r7, #0]
   144ea:	4013      	ands	r3, r2
   144ec:	455b      	cmp	r3, fp
   144ee:	d1e7      	bne.n	144c0 <TCPIP_ARP_EntryRemoveNet+0x80>
                    _ARPRemoveEntry(pArpDcpt, hE);
   144f0:	4601      	mov	r1, r0
   144f2:	4640      	mov	r0, r8
   144f4:	f00b f91e 	bl	1f734 <_ARPRemoveEntry>
                    _ARPNotifyClients(pIf, &arpHE->ipAddress, 0, ARP_EVENT_REMOVED_USER);
   144f8:	f06f 0301 	mvn.w	r3, #1
   144fc:	2200      	movs	r2, #0
   144fe:	f105 0108 	add.w	r1, r5, #8
   14502:	9801      	ldr	r0, [sp, #4]
   14504:	f007 fbf6 	bl	1bcf4 <_ARPNotifyClients>
   14508:	e7da      	b.n	144c0 <TCPIP_ARP_EntryRemoveNet+0x80>
    return ARP_RES_OK;
   1450a:	2000      	movs	r0, #0
   1450c:	e7aa      	b.n	14464 <TCPIP_ARP_EntryRemoveNet+0x24>
        return ARP_RES_BAD_ADDRESS;
   1450e:	f06f 0004 	mvn.w	r0, #4
}
   14512:	4770      	bx	lr
        return ARP_RES_BAD_ADDRESS;
   14514:	f06f 0004 	mvn.w	r0, #4
   14518:	e7a4      	b.n	14464 <TCPIP_ARP_EntryRemoveNet+0x24>
        return ARP_RES_NO_INTERFACE;
   1451a:	f06f 0005 	mvn.w	r0, #5
   1451e:	e7a1      	b.n	14464 <TCPIP_ARP_EntryRemoveNet+0x24>
            return ARP_RES_BAD_TYPE;
   14520:	f06f 0006 	mvn.w	r0, #6
   14524:	e79e      	b.n	14464 <TCPIP_ARP_EntryRemoveNet+0x24>
    return ARP_RES_OK;
   14526:	2000      	movs	r0, #0
   14528:	e79c      	b.n	14464 <TCPIP_ARP_EntryRemoveNet+0x24>
   1452a:	bf00      	nop
   1452c:	2000e1a4 	.word	0x2000e1a4

Disassembly of section .text._DNS_IsNameResolved%305:

00014530 <_DNS_IsNameResolved>:
{    
   14530:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14534:	b084      	sub	sp, #16
    if(hostIPv4)
   14536:	460e      	mov	r6, r1
   14538:	b109      	cbz	r1, 1453e <_DNS_IsNameResolved+0xe>
        hostIPv4->Val = 0;
   1453a:	2100      	movs	r1, #0
   1453c:	6031      	str	r1, [r6, #0]
    if(hostIPv6)
   1453e:	b122      	cbz	r2, 1454a <_DNS_IsNameResolved+0x1a>
        memset(hostIPv6->v, 0, sizeof(*hostIPv6));
   14540:	2100      	movs	r1, #0
   14542:	6011      	str	r1, [r2, #0]
   14544:	6051      	str	r1, [r2, #4]
   14546:	6091      	str	r1, [r2, #8]
   14548:	60d1      	str	r1, [r2, #12]
    pDnsDcpt = pgDnsDcpt;
   1454a:	4934      	ldr	r1, [pc, #208]	; (1461c <_DNS_IsNameResolved+0xec>)
   1454c:	680f      	ldr	r7, [r1, #0]
    if(pDnsDcpt == 0)
   1454e:	2f00      	cmp	r7, #0
   14550:	d055      	beq.n	145fe <_DNS_IsNameResolved+0xce>
   14552:	4698      	mov	r8, r3
   14554:	4614      	mov	r4, r2
   14556:	4605      	mov	r5, r0
    if(TCPIP_Helper_StringToIPAddress(hostName, &mAddr.v4Add))
   14558:	4669      	mov	r1, sp
   1455a:	f7fe fd17 	bl	12f8c <TCPIP_Helper_StringToIPAddress>
   1455e:	b138      	cbz	r0, 14570 <_DNS_IsNameResolved+0x40>
        if(hostIPv4)
   14560:	2e00      	cmp	r6, #0
   14562:	d04f      	beq.n	14604 <_DNS_IsNameResolved+0xd4>
            hostIPv4->Val = mAddr.v4Add.Val;
   14564:	9b00      	ldr	r3, [sp, #0]
   14566:	6033      	str	r3, [r6, #0]
        return  TCPIP_DNS_RES_OK; 
   14568:	2000      	movs	r0, #0
}
   1456a:	b004      	add	sp, #16
   1456c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (TCPIP_Helper_StringToIPv6Address (hostName, &mAddr.v6Add))
   14570:	4669      	mov	r1, sp
   14572:	4628      	mov	r0, r5
   14574:	f7f6 fb6c 	bl	ac50 <TCPIP_Helper_StringToIPv6Address>
   14578:	b148      	cbz	r0, 1458e <_DNS_IsNameResolved+0x5e>
        if(hostIPv6)
   1457a:	2c00      	cmp	r4, #0
   1457c:	d044      	beq.n	14608 <_DNS_IsNameResolved+0xd8>
            memcpy (hostIPv6->v, mAddr.v6Add.v, sizeof (IPV6_ADDR));
   1457e:	466d      	mov	r5, sp
   14580:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   14582:	6020      	str	r0, [r4, #0]
   14584:	6061      	str	r1, [r4, #4]
   14586:	60a2      	str	r2, [r4, #8]
   14588:	60e3      	str	r3, [r4, #12]
        return  TCPIP_DNS_RES_OK; 
   1458a:	2000      	movs	r0, #0
   1458c:	e7ed      	b.n	1456a <_DNS_IsNameResolved+0x3a>
    pDnsHE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryLookup(pDnsDcpt->hashDcpt, hostName);
   1458e:	4629      	mov	r1, r5
   14590:	6838      	ldr	r0, [r7, #0]
   14592:	f006 fa5f 	bl	1aa54 <TCPIP_OAHASH_EntryLookup>
    if(pDnsHE == 0)
   14596:	4603      	mov	r3, r0
   14598:	2800      	cmp	r0, #0
   1459a:	d037      	beq.n	1460c <_DNS_IsNameResolved+0xdc>
    if((pDnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) == 0)
   1459c:	8802      	ldrh	r2, [r0, #0]
   1459e:	f012 0f80 	tst.w	r2, #128	; 0x80
   145a2:	d00e      	beq.n	145c2 <_DNS_IsNameResolved+0x92>
    nIPv6Entries = pDnsHE->nIPv6Entries;
   145a4:	f890 2027 	ldrb.w	r2, [r0, #39]	; 0x27
    nIPv4Entries = pDnsHE->nIPv4Entries;
   145a8:	f890 1026 	ldrb.w	r1, [r0, #38]	; 0x26
    if(nIPv6Entries || nIPv4Entries)
   145ac:	b98a      	cbnz	r2, 145d2 <_DNS_IsNameResolved+0xa2>
    return TCPIP_DNS_RES_NO_IP_ENTRY;
   145ae:	f06f 0001 	mvn.w	r0, #1
    if(nIPv6Entries || nIPv4Entries)
   145b2:	2900      	cmp	r1, #0
   145b4:	d0d9      	beq.n	1456a <_DNS_IsNameResolved+0x3a>
            if(hostIPv4)
   145b6:	b376      	cbz	r6, 14616 <_DNS_IsNameResolved+0xe6>
                hostIPv4->Val = (pDnsHE->pip4Address + 0)->Val;
   145b8:	691b      	ldr	r3, [r3, #16]
   145ba:	681b      	ldr	r3, [r3, #0]
   145bc:	6033      	str	r3, [r6, #0]
        return TCPIP_DNS_RES_OK;
   145be:	2000      	movs	r0, #0
   145c0:	e7d3      	b.n	1456a <_DNS_IsNameResolved+0x3a>
        return (pDnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_TIMEOUT) == 0 ? TCPIP_DNS_RES_PENDING : TCPIP_DNS_RES_SERVER_TMO; 
   145c2:	f402 7280 	and.w	r2, r2, #256	; 0x100
   145c6:	2a00      	cmp	r2, #0
   145c8:	bf0c      	ite	eq
   145ca:	2001      	moveq	r0, #1
   145cc:	f06f 0004 	mvnne.w	r0, #4
   145d0:	e7cb      	b.n	1456a <_DNS_IsNameResolved+0x3a>
            if(hostIPv6)
   145d2:	b184      	cbz	r4, 145f6 <_DNS_IsNameResolved+0xc6>
                memcpy (hostIPv6->v, pDnsHE->pip6Address + nIPv6Entries - 1, sizeof (IPV6_ADDR));
   145d4:	f102 5280 	add.w	r2, r2, #268435456	; 0x10000000
   145d8:	3a01      	subs	r2, #1
   145da:	6940      	ldr	r0, [r0, #20]
   145dc:	eb00 1202 	add.w	r2, r0, r2, lsl #4
   145e0:	6817      	ldr	r7, [r2, #0]
   145e2:	6855      	ldr	r5, [r2, #4]
   145e4:	6890      	ldr	r0, [r2, #8]
   145e6:	68d2      	ldr	r2, [r2, #12]
   145e8:	6027      	str	r7, [r4, #0]
   145ea:	6065      	str	r5, [r4, #4]
   145ec:	60a0      	str	r0, [r4, #8]
   145ee:	60e2      	str	r2, [r4, #12]
                if(singleAddress)
   145f0:	f1b8 0f00 	cmp.w	r8, #0
   145f4:	d10d      	bne.n	14612 <_DNS_IsNameResolved+0xe2>
        return TCPIP_DNS_RES_OK;
   145f6:	2000      	movs	r0, #0
        if(nIPv4Entries)
   145f8:	2900      	cmp	r1, #0
   145fa:	d0b6      	beq.n	1456a <_DNS_IsNameResolved+0x3a>
   145fc:	e7db      	b.n	145b6 <_DNS_IsNameResolved+0x86>
        return TCPIP_DNS_RES_NO_SERVICE;
   145fe:	f06f 0005 	mvn.w	r0, #5
   14602:	e7b2      	b.n	1456a <_DNS_IsNameResolved+0x3a>
        return  TCPIP_DNS_RES_OK; 
   14604:	2000      	movs	r0, #0
   14606:	e7b0      	b.n	1456a <_DNS_IsNameResolved+0x3a>
        return  TCPIP_DNS_RES_OK; 
   14608:	2000      	movs	r0, #0
   1460a:	e7ae      	b.n	1456a <_DNS_IsNameResolved+0x3a>
        return TCPIP_DNS_RES_NO_NAME_ENTRY;
   1460c:	f04f 30ff 	mov.w	r0, #4294967295
   14610:	e7ab      	b.n	1456a <_DNS_IsNameResolved+0x3a>
        return TCPIP_DNS_RES_OK;
   14612:	2000      	movs	r0, #0
   14614:	e7a9      	b.n	1456a <_DNS_IsNameResolved+0x3a>
   14616:	2000      	movs	r0, #0
   14618:	e7a7      	b.n	1456a <_DNS_IsNameResolved+0x3a>
   1461a:	bf00      	nop
   1461c:	2000e62c 	.word	0x2000e62c

Disassembly of section .text.TCPIP_DNS_ClientTask%306:

00014620 <TCPIP_DNS_ClientTask>:
{
   14620:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    sigPend = _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_MASK_ALL);
   14622:	210f      	movs	r1, #15
   14624:	4608      	mov	r0, r1
   14626:	f009 fca1 	bl	1df6c <_TCPIPStackModuleSignalGet>
    if(sigPend != 0)
   1462a:	b900      	cbnz	r0, 1462e <TCPIP_DNS_ClientTask+0xe>
}
   1462c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        TCPIP_DNS_ClientProcess((sigPend & TCPIP_MODULE_SIGNAL_TMO) != 0);
   1462e:	f000 0302 	and.w	r3, r0, #2
    if((pDnsDcpt = pgDnsDcpt) == 0)
   14632:	4a36      	ldr	r2, [pc, #216]	; (1470c <TCPIP_DNS_ClientTask+0xec>)
   14634:	6814      	ldr	r4, [r2, #0]
   14636:	2c00      	cmp	r4, #0
   14638:	d0f8      	beq.n	1462c <TCPIP_DNS_ClientTask+0xc>
    if(isTmo)
   1463a:	2b00      	cmp	r3, #0
   1463c:	d05a      	beq.n	146f4 <TCPIP_DNS_ClientTask+0xd4>
        pDnsDcpt->dnsTime = SYS_TMR_TickCountGetLong() / SYS_TMR_TickCounterFrequencyGet();
   1463e:	f00b fcc9 	bl	1ffd4 <SYS_TMR_TickCountGetLong>
   14642:	4606      	mov	r6, r0
   14644:	460f      	mov	r7, r1
   14646:	f00b fcd9 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
   1464a:	4602      	mov	r2, r0
   1464c:	2300      	movs	r3, #0
   1464e:	4630      	mov	r0, r6
   14650:	4639      	mov	r1, r7
   14652:	f00a fe8f 	bl	1f374 <__aeabi_uldivmod>
   14656:	4607      	mov	r7, r0
   14658:	61e0      	str	r0, [r4, #28]
    pOH = pDnsDcpt->hashDcpt;
   1465a:	6826      	ldr	r6, [r4, #0]
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   1465c:	68f3      	ldr	r3, [r6, #12]
   1465e:	2b00      	cmp	r3, #0
   14660:	d048      	beq.n	146f4 <TCPIP_DNS_ClientTask+0xd4>
   14662:	2500      	movs	r5, #0
   14664:	e008      	b.n	14678 <TCPIP_DNS_ClientTask+0x58>
                    timeout = pDnsHE->ipTTL.Val;
   14666:	6982      	ldr	r2, [r0, #24]
                if((currTime - pDnsHE->tInsert) >= timeout)
   14668:	6883      	ldr	r3, [r0, #8]
   1466a:	1afb      	subs	r3, r7, r3
   1466c:	4293      	cmp	r3, r2
   1466e:	d213      	bcs.n	14698 <TCPIP_DNS_ClientTask+0x78>
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   14670:	3501      	adds	r5, #1
   14672:	68f3      	ldr	r3, [r6, #12]
   14674:	42ab      	cmp	r3, r5
   14676:	d93d      	bls.n	146f4 <TCPIP_DNS_ClientTask+0xd4>
        pDnsHE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryGet(pOH, bktIx);
   14678:	4629      	mov	r1, r5
   1467a:	4630      	mov	r0, r6
   1467c:	f00d f96d 	bl	2195a <TCPIP_OAHASH_EntryGet>
        if(pDnsHE->hEntry.flags.busy != 0)
   14680:	7803      	ldrb	r3, [r0, #0]
   14682:	f013 0f01 	tst.w	r3, #1
   14686:	d0f3      	beq.n	14670 <TCPIP_DNS_ClientTask+0x50>
            if((pDnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) != 0)
   14688:	8803      	ldrh	r3, [r0, #0]
   1468a:	f013 0f80 	tst.w	r3, #128	; 0x80
   1468e:	d008      	beq.n	146a2 <TCPIP_DNS_ClientTask+0x82>
                if((timeout = pDnsDcpt->cacheEntryTMO) == 0)
   14690:	6962      	ldr	r2, [r4, #20]
   14692:	2a00      	cmp	r2, #0
   14694:	d1e8      	bne.n	14668 <TCPIP_DNS_ClientTask+0x48>
   14696:	e7e6      	b.n	14666 <TCPIP_DNS_ClientTask+0x46>
    _DNS_CleanCacheEntry(pDnsDcpt, pDnsHE);
   14698:	4601      	mov	r1, r0
   1469a:	4620      	mov	r0, r4
   1469c:	f00a ff51 	bl	1f542 <_DNS_CleanCacheEntry>
   146a0:	e7e6      	b.n	14670 <TCPIP_DNS_ClientTask+0x50>
                if((pDnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_TIMEOUT) == 0)
   146a2:	f413 7f80 	tst.w	r3, #256	; 0x100
   146a6:	d116      	bne.n	146d6 <TCPIP_DNS_ClientTask+0xb6>
                    if((currTime - pDnsHE->tRetry) >= TCPIP_DNS_CLIENT_LOOKUP_RETRY_TMO)
   146a8:	68c2      	ldr	r2, [r0, #12]
   146aa:	1aba      	subs	r2, r7, r2
   146ac:	2a01      	cmp	r2, #1
   146ae:	d9df      	bls.n	14670 <TCPIP_DNS_ClientTask+0x50>
                        pDnsHE->tRetry = currTime;
   146b0:	60c7      	str	r7, [r0, #12]
                        if(pDnsHE->currRetry < pDnsHE->nRetries)
   146b2:	f890 202b 	ldrb.w	r2, [r0, #43]	; 0x2b
   146b6:	f890 102c 	ldrb.w	r1, [r0, #44]	; 0x2c
   146ba:	4291      	cmp	r1, r2
   146bc:	d803      	bhi.n	146c6 <TCPIP_DNS_ClientTask+0xa6>
                            pDnsHE->hEntry.flags.value |= TCPIP_DNS_FLAG_ENTRY_TIMEOUT;
   146be:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   146c2:	8003      	strh	r3, [r0, #0]
   146c4:	e7d4      	b.n	14670 <TCPIP_DNS_ClientTask+0x50>
                            pDnsHE->currRetry++;
   146c6:	3201      	adds	r2, #1
   146c8:	f880 202b 	strb.w	r2, [r0, #43]	; 0x2b
                            _DNS_Send_Query(pDnsDcpt, pDnsHE);
   146cc:	4601      	mov	r1, r0
   146ce:	4620      	mov	r0, r4
   146d0:	f7f8 f960 	bl	c994 <_DNS_Send_Query>
   146d4:	e7cc      	b.n	14670 <TCPIP_DNS_ClientTask+0x50>
                    if((currTime - pDnsHE->tRetry) >= _TCPIP_DNS_CLIENT_CACHE_UNSOLVED_EXPIRE_TMO)
   146d6:	68c3      	ldr	r3, [r0, #12]
   146d8:	429f      	cmp	r7, r3
   146da:	d0c9      	beq.n	14670 <TCPIP_DNS_ClientTask+0x50>
    _DNS_CleanCacheEntry(pDnsDcpt, pDnsHE);
   146dc:	4601      	mov	r1, r0
   146de:	4620      	mov	r0, r4
   146e0:	f00a ff2f 	bl	1f542 <_DNS_CleanCacheEntry>
   146e4:	e7c4      	b.n	14670 <TCPIP_DNS_ClientTask+0x50>
            _DNS_ProcessPacket(pDnsDcpt);
   146e6:	4620      	mov	r0, r4
   146e8:	f7f4 ffa6 	bl	9638 <_DNS_ProcessPacket>
        TCPIP_UDP_Discard(pDnsDcpt->dnsSocket);
   146ec:	f9b4 0024 	ldrsh.w	r0, [r4, #36]	; 0x24
   146f0:	f00b ffeb 	bl	206ca <TCPIP_UDP_Discard>
        if(!TCPIP_UDP_GetIsReady(pDnsDcpt->dnsSocket))
   146f4:	f9b4 0024 	ldrsh.w	r0, [r4, #36]	; 0x24
   146f8:	f00b fc1c 	bl	1ff34 <TCPIP_UDP_GetIsReady>
   146fc:	2800      	cmp	r0, #0
   146fe:	d095      	beq.n	1462c <TCPIP_DNS_ClientTask+0xc>
        if(pDnsDcpt->unsolvedEntries != 0)
   14700:	f9b4 3026 	ldrsh.w	r3, [r4, #38]	; 0x26
   14704:	2b00      	cmp	r3, #0
   14706:	d0f1      	beq.n	146ec <TCPIP_DNS_ClientTask+0xcc>
   14708:	e7ed      	b.n	146e6 <TCPIP_DNS_ClientTask+0xc6>
   1470a:	bf00      	nop
   1470c:	2000e62c 	.word	0x2000e62c

Disassembly of section .text.MONITOR_DHCP_eth_Handler%307:

00014710 <MONITOR_DHCP_eth_Handler>:
{
	clientObj->phyAddress = phyAddress;
	return Lan867x_Read_Register(clientObj, regAddr, rData);
}

void MONITOR_DHCP_eth_Handler(TCPIP_NET_HANDLE hNet, TCPIP_DHCP_EVENT_TYPE evType, const void* param) {
   14710:	b510      	push	{r4, lr}
   14712:	460c      	mov	r4, r1

    SYS_CONSOLE_PRINT("%s - ", TCPIP_STACK_NetNameGet(hNet));
   14714:	f00d fc79 	bl	2200a <TCPIP_STACK_NetNameGet>
   14718:	4602      	mov	r2, r0
   1471a:	492a      	ldr	r1, [pc, #168]	; (147c4 <MONITOR_DHCP_eth_Handler+0xb4>)
   1471c:	2000      	movs	r0, #0
   1471e:	f006 f825 	bl	1a76c <SYS_CONSOLE_Print>

    switch (evType) {
   14722:	2c0d      	cmp	r4, #13
   14724:	d80c      	bhi.n	14740 <MONITOR_DHCP_eth_Handler+0x30>
   14726:	e8df f004 	tbb	[pc, r4]
   1472a:	0c07      	.short	0x0c07
   1472c:	201b1611 	.word	0x201b1611
   14730:	342f2a25 	.word	0x342f2a25
   14734:	48433e39 	.word	0x48433e39
        case DHCP_EVENT_NONE: SYS_CONSOLE_PRINT("DHCP_EVENT_NONE\n\r");
   14738:	4923      	ldr	r1, [pc, #140]	; (147c8 <MONITOR_DHCP_eth_Handler+0xb8>)
   1473a:	2000      	movs	r0, #0
   1473c:	f006 f816 	bl	1a76c <SYS_CONSOLE_Print>
            break;
        case DHCP_EVENT_SERVICE_DISABLED: SYS_CONSOLE_PRINT("DHCP_EVENT_SERVICE_DISABLED\n\r");
            break;

    }
}
   14740:	bd10      	pop	{r4, pc}
        case DHCP_EVENT_DISCOVER: SYS_CONSOLE_PRINT("DHCP_EVENT_DISCOVER\n\r");
   14742:	4922      	ldr	r1, [pc, #136]	; (147cc <MONITOR_DHCP_eth_Handler+0xbc>)
   14744:	2000      	movs	r0, #0
   14746:	f006 f811 	bl	1a76c <SYS_CONSOLE_Print>
            break;
   1474a:	e7f9      	b.n	14740 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_REQUEST: SYS_CONSOLE_PRINT("DHCP_EVENT_REQUEST\n\r");
   1474c:	4920      	ldr	r1, [pc, #128]	; (147d0 <MONITOR_DHCP_eth_Handler+0xc0>)
   1474e:	2000      	movs	r0, #0
   14750:	f006 f80c 	bl	1a76c <SYS_CONSOLE_Print>
            break;
   14754:	e7f4      	b.n	14740 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_ACK: SYS_CONSOLE_PRINT("DHCP_EVENT_ACK\n\r");
   14756:	491f      	ldr	r1, [pc, #124]	; (147d4 <MONITOR_DHCP_eth_Handler+0xc4>)
   14758:	2000      	movs	r0, #0
   1475a:	f006 f807 	bl	1a76c <SYS_CONSOLE_Print>
            break;
   1475e:	e7ef      	b.n	14740 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_ACK_INVALID: SYS_CONSOLE_PRINT("DHCP_EVENT_ACK_INVALID\n\r");
   14760:	491d      	ldr	r1, [pc, #116]	; (147d8 <MONITOR_DHCP_eth_Handler+0xc8>)
   14762:	2000      	movs	r0, #0
   14764:	f006 f802 	bl	1a76c <SYS_CONSOLE_Print>
            break;
   14768:	e7ea      	b.n	14740 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_DECLINE: SYS_CONSOLE_PRINT("DHCP_EVENT_DECLINE\n\r");
   1476a:	491c      	ldr	r1, [pc, #112]	; (147dc <MONITOR_DHCP_eth_Handler+0xcc>)
   1476c:	2000      	movs	r0, #0
   1476e:	f005 fffd 	bl	1a76c <SYS_CONSOLE_Print>
            break;
   14772:	e7e5      	b.n	14740 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_NACK: SYS_CONSOLE_PRINT("DHCP_EVENT_NACK\n\r");
   14774:	491a      	ldr	r1, [pc, #104]	; (147e0 <MONITOR_DHCP_eth_Handler+0xd0>)
   14776:	2000      	movs	r0, #0
   14778:	f005 fff8 	bl	1a76c <SYS_CONSOLE_Print>
            break;
   1477c:	e7e0      	b.n	14740 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_TIMEOUT: SYS_CONSOLE_PRINT("DHCP_EVENT_TIMEOUT\n\r");
   1477e:	4919      	ldr	r1, [pc, #100]	; (147e4 <MONITOR_DHCP_eth_Handler+0xd4>)
   14780:	2000      	movs	r0, #0
   14782:	f005 fff3 	bl	1a76c <SYS_CONSOLE_Print>
            break;
   14786:	e7db      	b.n	14740 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_BOUND: SYS_CONSOLE_PRINT("DHCP_EVENT_BOUND\n\r");
   14788:	4917      	ldr	r1, [pc, #92]	; (147e8 <MONITOR_DHCP_eth_Handler+0xd8>)
   1478a:	2000      	movs	r0, #0
   1478c:	f005 ffee 	bl	1a76c <SYS_CONSOLE_Print>
            break;
   14790:	e7d6      	b.n	14740 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_REQUEST_RENEW: SYS_CONSOLE_PRINT("DHCP_EVENT_REQUEST_RENEW\n\r");
   14792:	4916      	ldr	r1, [pc, #88]	; (147ec <MONITOR_DHCP_eth_Handler+0xdc>)
   14794:	2000      	movs	r0, #0
   14796:	f005 ffe9 	bl	1a76c <SYS_CONSOLE_Print>
            break;
   1479a:	e7d1      	b.n	14740 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_REQUEST_REBIND: SYS_CONSOLE_PRINT("DHCP_EVENT_REQUEST_REBIND\n\r");
   1479c:	4914      	ldr	r1, [pc, #80]	; (147f0 <MONITOR_DHCP_eth_Handler+0xe0>)
   1479e:	2000      	movs	r0, #0
   147a0:	f005 ffe4 	bl	1a76c <SYS_CONSOLE_Print>
            break;
   147a4:	e7cc      	b.n	14740 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_CONN_LOST: SYS_CONSOLE_PRINT("DHCP_EVENT_CONN_LOST\n\r");
   147a6:	4913      	ldr	r1, [pc, #76]	; (147f4 <MONITOR_DHCP_eth_Handler+0xe4>)
   147a8:	2000      	movs	r0, #0
   147aa:	f005 ffdf 	bl	1a76c <SYS_CONSOLE_Print>
            break;
   147ae:	e7c7      	b.n	14740 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_CONN_ESTABLISHED: SYS_CONSOLE_PRINT("DHCP_EVENT_CONN_ESTABLISHED\n\r");
   147b0:	4911      	ldr	r1, [pc, #68]	; (147f8 <MONITOR_DHCP_eth_Handler+0xe8>)
   147b2:	2000      	movs	r0, #0
   147b4:	f005 ffda 	bl	1a76c <SYS_CONSOLE_Print>
            break;
   147b8:	e7c2      	b.n	14740 <MONITOR_DHCP_eth_Handler+0x30>
        case DHCP_EVENT_SERVICE_DISABLED: SYS_CONSOLE_PRINT("DHCP_EVENT_SERVICE_DISABLED\n\r");
   147ba:	4910      	ldr	r1, [pc, #64]	; (147fc <MONITOR_DHCP_eth_Handler+0xec>)
   147bc:	2000      	movs	r0, #0
   147be:	f005 ffd5 	bl	1a76c <SYS_CONSOLE_Print>
}
   147c2:	e7bd      	b.n	14740 <MONITOR_DHCP_eth_Handler+0x30>
   147c4:	0000b178 	.word	0x0000b178
   147c8:	0000b180 	.word	0x0000b180
   147cc:	0000b194 	.word	0x0000b194
   147d0:	0000b1ac 	.word	0x0000b1ac
   147d4:	0000b1c4 	.word	0x0000b1c4
   147d8:	0000b1d8 	.word	0x0000b1d8
   147dc:	0000b1f4 	.word	0x0000b1f4
   147e0:	0000b20c 	.word	0x0000b20c
   147e4:	0000b220 	.word	0x0000b220
   147e8:	0000b238 	.word	0x0000b238
   147ec:	0000b24c 	.word	0x0000b24c
   147f0:	0000b268 	.word	0x0000b268
   147f4:	0000b284 	.word	0x0000b284
   147f8:	0000b29c 	.word	0x0000b29c
   147fc:	0000b2bc 	.word	0x0000b2bc

Disassembly of section .text._ARPProbeAddress%308:

00014800 <_ARPProbeAddress>:
{
   14800:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   14804:	b083      	sub	sp, #12
   14806:	461c      	mov	r4, r3
    if((opType & ARP_OPERATION_PROBE_ONLY) != 0)
   14808:	f413 4f80 	tst.w	r3, #16384	; 0x4000
   1480c:	d11c      	bne.n	14848 <_ARPProbeAddress+0x48>
   1480e:	4606      	mov	r6, r0
   14810:	460d      	mov	r5, r1
   14812:	4690      	mov	r8, r2
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   14814:	4b33      	ldr	r3, [pc, #204]	; (148e4 <_ARPProbeAddress+0xe4>)
   14816:	685f      	ldr	r7, [r3, #4]
   14818:	f00d f9fc 	bl	21c14 <TCPIP_STACK_NetIxGet>
   1481c:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   14820:	00c0      	lsls	r0, r0, #3
   14822:	eb07 0900 	add.w	r9, r7, r0
    hE = TCPIP_OAHASH_EntryLookupOrInsert(pArpDcpt->hashDcpt, &IPAddr->Val);
   14826:	4629      	mov	r1, r5
   14828:	5838      	ldr	r0, [r7, r0]
   1482a:	f006 fb13 	bl	1ae54 <TCPIP_OAHASH_EntryLookupOrInsert>
    if(hE == 0)
   1482e:	4605      	mov	r5, r0
   14830:	2800      	cmp	r0, #0
   14832:	d053      	beq.n	148dc <_ARPProbeAddress+0xdc>
    if(hE->flags.newEntry != 0)
   14834:	7803      	ldrb	r3, [r0, #0]
   14836:	f013 0f02 	tst.w	r3, #2
   1483a:	d117      	bne.n	1486c <_ARPProbeAddress+0x6c>
    if((hE->flags.value & ARP_FLAG_ENTRY_VALID_MASK) != 0)
   1483c:	8803      	ldrh	r3, [r0, #0]
   1483e:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   14842:	bb73      	cbnz	r3, 148a2 <_ARPProbeAddress+0xa2>
    return ARP_RES_ENTRY_QUEUED;
   14844:	2003      	movs	r0, #3
   14846:	e00e      	b.n	14866 <_ARPProbeAddress+0x66>
        return _ARPSendIfPkt(pIf, (opType & ARP_OPERATION_MASK), (uint32_t)srcAddr->Val, (uint32_t)IPAddr->Val, &arpBcastAdd, 0) ? ARP_RES_PROBE_OK : ARP_RES_PROBE_FAILED;
   14848:	2300      	movs	r3, #0
   1484a:	9301      	str	r3, [sp, #4]
   1484c:	4b26      	ldr	r3, [pc, #152]	; (148e8 <_ARPProbeAddress+0xe8>)
   1484e:	9300      	str	r3, [sp, #0]
   14850:	680b      	ldr	r3, [r1, #0]
   14852:	6812      	ldr	r2, [r2, #0]
   14854:	f004 010f 	and.w	r1, r4, #15
   14858:	f001 ffc4 	bl	167e4 <_ARPSendIfPkt>
   1485c:	2800      	cmp	r0, #0
   1485e:	bf14      	ite	ne
   14860:	2006      	movne	r0, #6
   14862:	f06f 0008 	mvneq.w	r0, #8
}
   14866:	b003      	add	sp, #12
   14868:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        ARP_ENTRY_FLAGS newFlags = (opType & ARP_OPERATION_CONFIGURE) != 0 ? ARP_FLAG_ENTRY_CONFIGURE : 0;
   1486c:	1121      	asrs	r1, r4, #4
   1486e:	f401 7180 	and.w	r1, r1, #256	; 0x100
        if((opType & ARP_OPERATION_GRATUITOUS) != 0) 
   14872:	f414 5f00 	tst.w	r4, #8192	; 0x2000
            newFlags |= ARP_FLAG_ENTRY_GRATUITOUS;
   14876:	bf18      	it	ne
   14878:	f441 7100 	orrne.w	r1, r1, #512	; 0x200
        _ARPSetEntry((ARP_HASH_ENTRY*)hE, newFlags, 0, &pArpDcpt->incompleteList);
   1487c:	f109 032c 	add.w	r3, r9, #44	; 0x2c
   14880:	2200      	movs	r2, #0
   14882:	f009 ffe9 	bl	1e858 <_ARPSetEntry>
        _ARPSendIfPkt(pIf, (opType & ARP_OPERATION_MASK), (uint32_t)srcAddr->Val, ((ARP_HASH_ENTRY*)hE)->ipAddress.Val, &arpBcastAdd, 0);
   14886:	68ab      	ldr	r3, [r5, #8]
   14888:	2200      	movs	r2, #0
   1488a:	9201      	str	r2, [sp, #4]
   1488c:	4a16      	ldr	r2, [pc, #88]	; (148e8 <_ARPProbeAddress+0xe8>)
   1488e:	9200      	str	r2, [sp, #0]
   14890:	f8d8 2000 	ldr.w	r2, [r8]
   14894:	f004 010f 	and.w	r1, r4, #15
   14898:	4630      	mov	r0, r6
   1489a:	f001 ffa3 	bl	167e4 <_ARPSendIfPkt>
        return ARP_RES_ENTRY_NEW;
   1489e:	2001      	movs	r0, #1
   148a0:	e7e1      	b.n	14866 <_ARPProbeAddress+0x66>
        if(pHwAdd)
   148a2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   148a4:	b123      	cbz	r3, 148b0 <_ARPProbeAddress+0xb0>
            *pHwAdd = arpHE->hwAdd;
   148a6:	6900      	ldr	r0, [r0, #16]
   148a8:	6018      	str	r0, [r3, #0]
   148aa:	8aab      	ldrh	r3, [r5, #20]
   148ac:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   148ae:	8093      	strh	r3, [r2, #4]
        if((hE->flags.value & ARP_FLAG_ENTRY_COMPLETE) != 0 )
   148b0:	882b      	ldrh	r3, [r5, #0]
   148b2:	f013 0f80 	tst.w	r3, #128	; 0x80
   148b6:	d101      	bne.n	148bc <_ARPProbeAddress+0xbc>
        return ARP_RES_ENTRY_SOLVED;
   148b8:	2002      	movs	r0, #2
   148ba:	e7d4      	b.n	14866 <_ARPProbeAddress+0x66>
            _ARPRefreshEntry(arpHE, &pArpDcpt->completeList);
   148bc:	f109 0918 	add.w	r9, r9, #24
    TCPIP_Helper_ProtectedSingleListNodeRemove(pL, (SGL_LIST_NODE*)&arpHE->next);
   148c0:	1d2c      	adds	r4, r5, #4
   148c2:	4621      	mov	r1, r4
   148c4:	4648      	mov	r0, r9
   148c6:	f00a fc05 	bl	1f0d4 <TCPIP_Helper_ProtectedSingleListNodeRemove>
    arpHE->tInsert = arpMod.timeSeconds;
   148ca:	4b06      	ldr	r3, [pc, #24]	; (148e4 <_ARPProbeAddress+0xe4>)
   148cc:	695b      	ldr	r3, [r3, #20]
   148ce:	60eb      	str	r3, [r5, #12]
    TCPIP_Helper_ProtectedSingleListTailAdd(pL, (SGL_LIST_NODE*)&arpHE->next);
   148d0:	4621      	mov	r1, r4
   148d2:	4648      	mov	r0, r9
   148d4:	f00b f90f 	bl	1faf6 <TCPIP_Helper_ProtectedSingleListTailAdd>
        return ARP_RES_ENTRY_SOLVED;
   148d8:	2002      	movs	r0, #2
   148da:	e7c4      	b.n	14866 <_ARPProbeAddress+0x66>
        return ARP_RES_CACHE_FULL;
   148dc:	f06f 0001 	mvn.w	r0, #1
   148e0:	e7c1      	b.n	14866 <_ARPProbeAddress+0x66>
   148e2:	bf00      	nop
   148e4:	2000e1a4 	.word	0x2000e1a4
   148e8:	2000e570 	.word	0x2000e570

Disassembly of section .text._DNS_GetAddresses%309:

000148ec <_DNS_GetAddresses>:
{
   148ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   148f0:	f89d 7018 	ldrb.w	r7, [sp, #24]
    pDnsDcpt = pgDnsDcpt;
   148f4:	4c37      	ldr	r4, [pc, #220]	; (149d4 <_DNS_GetAddresses+0xe8>)
   148f6:	6825      	ldr	r5, [r4, #0]
    if(pDnsDcpt == 0 || hostName == 0 || pIPAddr == 0 || nIPAddresses == 0)
   148f8:	2d00      	cmp	r5, #0
   148fa:	d057      	beq.n	149ac <_DNS_GetAddresses+0xc0>
   148fc:	2800      	cmp	r0, #0
   148fe:	d057      	beq.n	149b0 <_DNS_GetAddresses+0xc4>
   14900:	2a00      	cmp	r2, #0
   14902:	d057      	beq.n	149b4 <_DNS_GetAddresses+0xc8>
   14904:	b913      	cbnz	r3, 1490c <_DNS_GetAddresses+0x20>
        return 0;
   14906:	4618      	mov	r0, r3
}
   14908:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1490c:	461c      	mov	r4, r3
   1490e:	4690      	mov	r8, r2
   14910:	460e      	mov	r6, r1
   14912:	4601      	mov	r1, r0
    dnsHashEntry = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryLookup(pDnsDcpt->hashDcpt, hostName);
   14914:	6828      	ldr	r0, [r5, #0]
   14916:	f006 f89d 	bl	1aa54 <TCPIP_OAHASH_EntryLookup>
    if(dnsHashEntry == 0 || (dnsHashEntry->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) == 0)
   1491a:	4601      	mov	r1, r0
   1491c:	2800      	cmp	r0, #0
   1491e:	d04b      	beq.n	149b8 <_DNS_GetAddresses+0xcc>
   14920:	8803      	ldrh	r3, [r0, #0]
   14922:	f013 0f80 	tst.w	r3, #128	; 0x80
   14926:	d049      	beq.n	149bc <_DNS_GetAddresses+0xd0>
    recMask &= (TCPIP_DNS_ADDRESS_REC_MASK)dnsHashEntry->recordMask;
   14928:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
    if(recMask == 0)
   1492c:	401f      	ands	r7, r3
   1492e:	d047      	beq.n	149c0 <_DNS_GetAddresses+0xd4>
    if(recMask == TCPIP_DNS_ADDRESS_REC_IPV4)
   14930:	2f01      	cmp	r7, #1
   14932:	d020      	beq.n	14976 <_DNS_GetAddresses+0x8a>
        pDst6Addr = &pIPAddr->v6Add;
   14934:	4642      	mov	r2, r8
        pSrc6Addr =  dnsHashEntry->pip6Address + startIndex;
   14936:	46b6      	mov	lr, r6
   14938:	6943      	ldr	r3, [r0, #20]
   1493a:	eb03 1306 	add.w	r3, r3, r6, lsl #4
        for(ix = startIndex; ix <= dnsHashEntry->nIPv6Entries && nAddrs < nIPAddresses; ix++, nAddrs++, pDst6Addr++)
   1493e:	f890 0027 	ldrb.w	r0, [r0, #39]	; 0x27
   14942:	4286      	cmp	r6, r0
   14944:	dc42      	bgt.n	149cc <_DNS_GetAddresses+0xe0>
   14946:	2c00      	cmp	r4, #0
   14948:	dd42      	ble.n	149d0 <_DNS_GetAddresses+0xe4>
    nAddrs = 0;
   1494a:	2000      	movs	r0, #0
            memcpy(pDst6Addr->v, pSrc6Addr->v, sizeof(*pDst6Addr));
   1494c:	f8d3 c000 	ldr.w	ip, [r3]
   14950:	685f      	ldr	r7, [r3, #4]
   14952:	689e      	ldr	r6, [r3, #8]
   14954:	68dd      	ldr	r5, [r3, #12]
   14956:	f8c2 c000 	str.w	ip, [r2]
   1495a:	6057      	str	r7, [r2, #4]
   1495c:	6096      	str	r6, [r2, #8]
   1495e:	60d5      	str	r5, [r2, #12]
        for(ix = startIndex; ix <= dnsHashEntry->nIPv6Entries && nAddrs < nIPAddresses; ix++, nAddrs++, pDst6Addr++)
   14960:	3001      	adds	r0, #1
   14962:	3210      	adds	r2, #16
   14964:	f891 6027 	ldrb.w	r6, [r1, #39]	; 0x27
   14968:	eb00 050e 	add.w	r5, r0, lr
   1496c:	42ae      	cmp	r6, r5
   1496e:	dbcb      	blt.n	14908 <_DNS_GetAddresses+0x1c>
   14970:	4284      	cmp	r4, r0
   14972:	d1eb      	bne.n	1494c <_DNS_GetAddresses+0x60>
   14974:	e7c8      	b.n	14908 <_DNS_GetAddresses+0x1c>
        pSrc4Addr =  dnsHashEntry->pip4Address + startIndex;
   14976:	6903      	ldr	r3, [r0, #16]
   14978:	4637      	mov	r7, r6
   1497a:	00b2      	lsls	r2, r6, #2
        for(ix = startIndex; ix <= dnsHashEntry->nIPv4Entries && nAddrs < nIPAddresses; ix++, nAddrs++, pDst4Addr++, pSrc4Addr++)
   1497c:	f890 0026 	ldrb.w	r0, [r0, #38]	; 0x26
   14980:	4286      	cmp	r6, r0
   14982:	dc1f      	bgt.n	149c4 <_DNS_GetAddresses+0xd8>
   14984:	2c00      	cmp	r4, #0
   14986:	dd1f      	ble.n	149c8 <_DNS_GetAddresses+0xdc>
   14988:	3a04      	subs	r2, #4
   1498a:	4413      	add	r3, r2
   1498c:	f1a8 0204 	sub.w	r2, r8, #4
    nAddrs = 0;
   14990:	2000      	movs	r0, #0
            pDst4Addr->Val = pSrc4Addr->Val;
   14992:	f853 5f04 	ldr.w	r5, [r3, #4]!
   14996:	f842 5f04 	str.w	r5, [r2, #4]!
        for(ix = startIndex; ix <= dnsHashEntry->nIPv4Entries && nAddrs < nIPAddresses; ix++, nAddrs++, pDst4Addr++, pSrc4Addr++)
   1499a:	3001      	adds	r0, #1
   1499c:	f891 6026 	ldrb.w	r6, [r1, #38]	; 0x26
   149a0:	19c5      	adds	r5, r0, r7
   149a2:	42ae      	cmp	r6, r5
   149a4:	dbb0      	blt.n	14908 <_DNS_GetAddresses+0x1c>
   149a6:	4284      	cmp	r4, r0
   149a8:	d1f3      	bne.n	14992 <_DNS_GetAddresses+0xa6>
   149aa:	e7ad      	b.n	14908 <_DNS_GetAddresses+0x1c>
        return 0;
   149ac:	2000      	movs	r0, #0
   149ae:	e7ab      	b.n	14908 <_DNS_GetAddresses+0x1c>
   149b0:	2000      	movs	r0, #0
   149b2:	e7a9      	b.n	14908 <_DNS_GetAddresses+0x1c>
   149b4:	2000      	movs	r0, #0
   149b6:	e7a7      	b.n	14908 <_DNS_GetAddresses+0x1c>
        return 0;
   149b8:	2000      	movs	r0, #0
   149ba:	e7a5      	b.n	14908 <_DNS_GetAddresses+0x1c>
   149bc:	2000      	movs	r0, #0
   149be:	e7a3      	b.n	14908 <_DNS_GetAddresses+0x1c>
        return 0; 
   149c0:	2000      	movs	r0, #0
   149c2:	e7a1      	b.n	14908 <_DNS_GetAddresses+0x1c>
    nAddrs = 0;
   149c4:	2000      	movs	r0, #0
   149c6:	e79f      	b.n	14908 <_DNS_GetAddresses+0x1c>
   149c8:	2000      	movs	r0, #0
   149ca:	e79d      	b.n	14908 <_DNS_GetAddresses+0x1c>
   149cc:	2000      	movs	r0, #0
   149ce:	e79b      	b.n	14908 <_DNS_GetAddresses+0x1c>
   149d0:	2000      	movs	r0, #0
   149d2:	e799      	b.n	14908 <_DNS_GetAddresses+0x1c>
   149d4:	2000e62c 	.word	0x2000e62c

Disassembly of section .text._strtol_l.isra.0%310:

000149d8 <_strtol_l.isra.0>:
   149d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   149dc:	4f38      	ldr	r7, [pc, #224]	; (14ac0 <_strtol_l.isra.0+0xe8>)
   149de:	4686      	mov	lr, r0
   149e0:	4608      	mov	r0, r1
   149e2:	4605      	mov	r5, r0
   149e4:	f815 4b01 	ldrb.w	r4, [r5], #1
   149e8:	5de6      	ldrb	r6, [r4, r7]
   149ea:	f016 0608 	ands.w	r6, r6, #8
   149ee:	d136      	bne.n	14a5e <_strtol_l.isra.0+0x86>
   149f0:	2c2d      	cmp	r4, #45	; 0x2d
   149f2:	d136      	bne.n	14a62 <_strtol_l.isra.0+0x8a>
   149f4:	782c      	ldrb	r4, [r5, #0]
   149f6:	2601      	movs	r6, #1
   149f8:	1c85      	adds	r5, r0, #2
   149fa:	2b00      	cmp	r3, #0
   149fc:	d05c      	beq.n	14ab8 <_strtol_l.isra.0+0xe0>
   149fe:	2b10      	cmp	r3, #16
   14a00:	d109      	bne.n	14a16 <_strtol_l.isra.0+0x3e>
   14a02:	2c30      	cmp	r4, #48	; 0x30
   14a04:	d107      	bne.n	14a16 <_strtol_l.isra.0+0x3e>
   14a06:	7828      	ldrb	r0, [r5, #0]
   14a08:	f000 00df 	and.w	r0, r0, #223	; 0xdf
   14a0c:	2858      	cmp	r0, #88	; 0x58
   14a0e:	d14e      	bne.n	14aae <_strtol_l.isra.0+0xd6>
   14a10:	786c      	ldrb	r4, [r5, #1]
   14a12:	2310      	movs	r3, #16
   14a14:	3502      	adds	r5, #2
   14a16:	2e00      	cmp	r6, #0
   14a18:	bf14      	ite	ne
   14a1a:	f04f 4c00 	movne.w	ip, #2147483648	; 0x80000000
   14a1e:	f06f 4c00 	mvneq.w	ip, #2147483648	; 0x80000000
   14a22:	2700      	movs	r7, #0
   14a24:	fbbc f8f3 	udiv	r8, ip, r3
   14a28:	4638      	mov	r0, r7
   14a2a:	fb03 ca18 	mls	sl, r3, r8, ip
   14a2e:	f04f 39ff 	mov.w	r9, #4294967295
   14a32:	f1a4 0b30 	sub.w	fp, r4, #48	; 0x30
   14a36:	f1bb 0f09 	cmp.w	fp, #9
   14a3a:	d817      	bhi.n	14a6c <_strtol_l.isra.0+0x94>
   14a3c:	465c      	mov	r4, fp
   14a3e:	42a3      	cmp	r3, r4
   14a40:	dd24      	ble.n	14a8c <_strtol_l.isra.0+0xb4>
   14a42:	f1b7 3fff 	cmp.w	r7, #4294967295
   14a46:	d007      	beq.n	14a58 <_strtol_l.isra.0+0x80>
   14a48:	4580      	cmp	r8, r0
   14a4a:	d31d      	bcc.n	14a88 <_strtol_l.isra.0+0xb0>
   14a4c:	d101      	bne.n	14a52 <_strtol_l.isra.0+0x7a>
   14a4e:	45a2      	cmp	sl, r4
   14a50:	db1a      	blt.n	14a88 <_strtol_l.isra.0+0xb0>
   14a52:	fb00 4003 	mla	r0, r0, r3, r4
   14a56:	2701      	movs	r7, #1
   14a58:	f815 4b01 	ldrb.w	r4, [r5], #1
   14a5c:	e7e9      	b.n	14a32 <_strtol_l.isra.0+0x5a>
   14a5e:	4628      	mov	r0, r5
   14a60:	e7bf      	b.n	149e2 <_strtol_l.isra.0+0xa>
   14a62:	2c2b      	cmp	r4, #43	; 0x2b
   14a64:	bf04      	itt	eq
   14a66:	782c      	ldrbeq	r4, [r5, #0]
   14a68:	1c85      	addeq	r5, r0, #2
   14a6a:	e7c6      	b.n	149fa <_strtol_l.isra.0+0x22>
   14a6c:	f1a4 0b41 	sub.w	fp, r4, #65	; 0x41
   14a70:	f1bb 0f19 	cmp.w	fp, #25
   14a74:	d801      	bhi.n	14a7a <_strtol_l.isra.0+0xa2>
   14a76:	3c37      	subs	r4, #55	; 0x37
   14a78:	e7e1      	b.n	14a3e <_strtol_l.isra.0+0x66>
   14a7a:	f1a4 0b61 	sub.w	fp, r4, #97	; 0x61
   14a7e:	f1bb 0f19 	cmp.w	fp, #25
   14a82:	d803      	bhi.n	14a8c <_strtol_l.isra.0+0xb4>
   14a84:	3c57      	subs	r4, #87	; 0x57
   14a86:	e7da      	b.n	14a3e <_strtol_l.isra.0+0x66>
   14a88:	464f      	mov	r7, r9
   14a8a:	e7e5      	b.n	14a58 <_strtol_l.isra.0+0x80>
   14a8c:	1c7b      	adds	r3, r7, #1
   14a8e:	d106      	bne.n	14a9e <_strtol_l.isra.0+0xc6>
   14a90:	2322      	movs	r3, #34	; 0x22
   14a92:	f8ce 3000 	str.w	r3, [lr]
   14a96:	4660      	mov	r0, ip
   14a98:	b932      	cbnz	r2, 14aa8 <_strtol_l.isra.0+0xd0>
   14a9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   14a9e:	b106      	cbz	r6, 14aa2 <_strtol_l.isra.0+0xca>
   14aa0:	4240      	negs	r0, r0
   14aa2:	2a00      	cmp	r2, #0
   14aa4:	d0f9      	beq.n	14a9a <_strtol_l.isra.0+0xc2>
   14aa6:	b107      	cbz	r7, 14aaa <_strtol_l.isra.0+0xd2>
   14aa8:	1e69      	subs	r1, r5, #1
   14aaa:	6011      	str	r1, [r2, #0]
   14aac:	e7f5      	b.n	14a9a <_strtol_l.isra.0+0xc2>
   14aae:	2430      	movs	r4, #48	; 0x30
   14ab0:	2b00      	cmp	r3, #0
   14ab2:	d1b0      	bne.n	14a16 <_strtol_l.isra.0+0x3e>
   14ab4:	2308      	movs	r3, #8
   14ab6:	e7ae      	b.n	14a16 <_strtol_l.isra.0+0x3e>
   14ab8:	2c30      	cmp	r4, #48	; 0x30
   14aba:	d0a4      	beq.n	14a06 <_strtol_l.isra.0+0x2e>
   14abc:	230a      	movs	r3, #10
   14abe:	e7aa      	b.n	14a16 <_strtol_l.isra.0+0x3e>
   14ac0:	00013c61 	.word	0x00013c61

Disassembly of section .text._printf_common%311:

00014ac4 <_printf_common>:
   14ac4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   14ac8:	4691      	mov	r9, r2
   14aca:	461f      	mov	r7, r3
   14acc:	688a      	ldr	r2, [r1, #8]
   14ace:	690b      	ldr	r3, [r1, #16]
   14ad0:	f8dd 8020 	ldr.w	r8, [sp, #32]
   14ad4:	4293      	cmp	r3, r2
   14ad6:	bfb8      	it	lt
   14ad8:	4613      	movlt	r3, r2
   14ada:	f8c9 3000 	str.w	r3, [r9]
   14ade:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
   14ae2:	4606      	mov	r6, r0
   14ae4:	460c      	mov	r4, r1
   14ae6:	b112      	cbz	r2, 14aee <_printf_common+0x2a>
   14ae8:	3301      	adds	r3, #1
   14aea:	f8c9 3000 	str.w	r3, [r9]
   14aee:	6823      	ldr	r3, [r4, #0]
   14af0:	0699      	lsls	r1, r3, #26
   14af2:	bf42      	ittt	mi
   14af4:	f8d9 3000 	ldrmi.w	r3, [r9]
   14af8:	3302      	addmi	r3, #2
   14afa:	f8c9 3000 	strmi.w	r3, [r9]
   14afe:	6825      	ldr	r5, [r4, #0]
   14b00:	f015 0506 	ands.w	r5, r5, #6
   14b04:	d107      	bne.n	14b16 <_printf_common+0x52>
   14b06:	f104 0a19 	add.w	sl, r4, #25
   14b0a:	68e3      	ldr	r3, [r4, #12]
   14b0c:	f8d9 2000 	ldr.w	r2, [r9]
   14b10:	1a9b      	subs	r3, r3, r2
   14b12:	42ab      	cmp	r3, r5
   14b14:	dc28      	bgt.n	14b68 <_printf_common+0xa4>
   14b16:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   14b1a:	6822      	ldr	r2, [r4, #0]
   14b1c:	3300      	adds	r3, #0
   14b1e:	bf18      	it	ne
   14b20:	2301      	movne	r3, #1
   14b22:	0692      	lsls	r2, r2, #26
   14b24:	d42d      	bmi.n	14b82 <_printf_common+0xbe>
   14b26:	f104 0243 	add.w	r2, r4, #67	; 0x43
   14b2a:	4639      	mov	r1, r7
   14b2c:	4630      	mov	r0, r6
   14b2e:	47c0      	blx	r8
   14b30:	3001      	adds	r0, #1
   14b32:	d020      	beq.n	14b76 <_printf_common+0xb2>
   14b34:	6823      	ldr	r3, [r4, #0]
   14b36:	68e5      	ldr	r5, [r4, #12]
   14b38:	f8d9 2000 	ldr.w	r2, [r9]
   14b3c:	f003 0306 	and.w	r3, r3, #6
   14b40:	2b04      	cmp	r3, #4
   14b42:	bf08      	it	eq
   14b44:	1aad      	subeq	r5, r5, r2
   14b46:	68a3      	ldr	r3, [r4, #8]
   14b48:	6922      	ldr	r2, [r4, #16]
   14b4a:	bf0c      	ite	eq
   14b4c:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
   14b50:	2500      	movne	r5, #0
   14b52:	4293      	cmp	r3, r2
   14b54:	bfc4      	itt	gt
   14b56:	1a9b      	subgt	r3, r3, r2
   14b58:	18ed      	addgt	r5, r5, r3
   14b5a:	f04f 0900 	mov.w	r9, #0
   14b5e:	341a      	adds	r4, #26
   14b60:	454d      	cmp	r5, r9
   14b62:	d11a      	bne.n	14b9a <_printf_common+0xd6>
   14b64:	2000      	movs	r0, #0
   14b66:	e008      	b.n	14b7a <_printf_common+0xb6>
   14b68:	2301      	movs	r3, #1
   14b6a:	4652      	mov	r2, sl
   14b6c:	4639      	mov	r1, r7
   14b6e:	4630      	mov	r0, r6
   14b70:	47c0      	blx	r8
   14b72:	3001      	adds	r0, #1
   14b74:	d103      	bne.n	14b7e <_printf_common+0xba>
   14b76:	f04f 30ff 	mov.w	r0, #4294967295
   14b7a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   14b7e:	3501      	adds	r5, #1
   14b80:	e7c3      	b.n	14b0a <_printf_common+0x46>
   14b82:	18e1      	adds	r1, r4, r3
   14b84:	1c5a      	adds	r2, r3, #1
   14b86:	2030      	movs	r0, #48	; 0x30
   14b88:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
   14b8c:	4422      	add	r2, r4
   14b8e:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
   14b92:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
   14b96:	3302      	adds	r3, #2
   14b98:	e7c5      	b.n	14b26 <_printf_common+0x62>
   14b9a:	2301      	movs	r3, #1
   14b9c:	4622      	mov	r2, r4
   14b9e:	4639      	mov	r1, r7
   14ba0:	4630      	mov	r0, r6
   14ba2:	47c0      	blx	r8
   14ba4:	3001      	adds	r0, #1
   14ba6:	d0e6      	beq.n	14b76 <_printf_common+0xb2>
   14ba8:	f109 0901 	add.w	r9, r9, #1
   14bac:	e7d8      	b.n	14b60 <_printf_common+0x9c>

Disassembly of section .text.DRV_PIC32CGMAC_LibTxSendPacket%312:

00014bb0 <DRV_PIC32CGMAC_LibTxSendPacket>:
{
   14bb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	DRV_PIC32CGMAC_HW_TXDCPT *pTxDesc = pMACDrv->sGmacData.gmac_queue[queueIdx].pTxDesc;
   14bb4:	232c      	movs	r3, #44	; 0x2c
   14bb6:	fb03 0302 	mla	r3, r3, r2, r0
   14bba:	f8d3 70a0 	ldr.w	r7, [r3, #160]	; 0xa0
	uint16_t wTxIndex = pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescHead ;
   14bbe:	f8b3 30b2 	ldrh.w	r3, [r3, #178]	; 0xb2
	uint16_t wTxDescCount =pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt;
   14bc2:	eb02 04c2 	add.w	r4, r2, r2, lsl #3
   14bc6:	eb00 0444 	add.w	r4, r0, r4, lsl #1
   14bca:	f8b4 c0c8 	ldrh.w	ip, [r4, #200]	; 0xc8
    while (pPktDSeg)
   14bce:	b371      	cbz	r1, 14c2e <DRV_PIC32CGMAC_LibTxSendPacket+0x7e>
   14bd0:	460d      	mov	r5, r1
    uint8_t nLoopCnt =0;
   14bd2:	2400      	movs	r4, #0
        if((_DRV_GMAC_DescSpace(wTxIndex, pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail, wTxDescCount)) &&
   14bd4:	f04f 0e2c 	mov.w	lr, #44	; 0x2c
   14bd8:	fb0e 0e02 	mla	lr, lr, r2, r0
   14bdc:	e01d      	b.n	14c1a <DRV_PIC32CGMAC_LibTxSendPacket+0x6a>
           (pTxDesc[wTxIndex].tx_desc_buffaddr == 0))
   14bde:	eb07 06c3 	add.w	r6, r7, r3, lsl #3
   14be2:	f857 1033 	ldr.w	r1, [r7, r3, lsl #3]
        if((_DRV_GMAC_DescSpace(wTxIndex, pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail, wTxDescCount)) &&
   14be6:	2900      	cmp	r1, #0
   14be8:	d152      	bne.n	14c90 <DRV_PIC32CGMAC_LibTxSendPacket+0xe0>
            pTxDesc[wTxIndex].tx_desc_status.val &= (GMAC_TX_WRAP_BIT |GMAC_TX_USED_BIT); //clear all Tx Status except Wrap Bit and Used Bit
   14bea:	6871      	ldr	r1, [r6, #4]
   14bec:	f001 4140 	and.w	r1, r1, #3221225472	; 0xc0000000
   14bf0:	6071      	str	r1, [r6, #4]
            pTxDesc[wTxIndex].tx_desc_buffaddr = (uint32_t)((uint8_t *)pPktDSeg->segLoad);	//set the buffer address
   14bf2:	68a9      	ldr	r1, [r5, #8]
   14bf4:	f847 1033 	str.w	r1, [r7, r3, lsl #3]
            pTxDesc[wTxIndex].tx_desc_status.val |= (pPktDSeg->segLen) & GMAC_LENGTH_FRAME; //Set Length for each frame
   14bf8:	f8d6 8004 	ldr.w	r8, [r6, #4]
   14bfc:	89a9      	ldrh	r1, [r5, #12]
   14bfe:	f3c1 010d 	ubfx	r1, r1, #0, #14
   14c02:	ea41 0108 	orr.w	r1, r1, r8
   14c06:	6071      	str	r1, [r6, #4]
            GCIRC_INC(wTxIndex,wTxDescCount); //Increment the index of Tx Desc
   14c08:	3301      	adds	r3, #1
   14c0a:	b29b      	uxth	r3, r3
   14c0c:	459c      	cmp	ip, r3
   14c0e:	bf98      	it	ls
   14c10:	2300      	movls	r3, #0
            pPktDSeg = pPktDSeg->next;
   14c12:	682d      	ldr	r5, [r5, #0]
            nLoopCnt++;
   14c14:	3401      	adds	r4, #1
   14c16:	b2e4      	uxtb	r4, r4
    while (pPktDSeg)
   14c18:	b155      	cbz	r5, 14c30 <DRV_PIC32CGMAC_LibTxSendPacket+0x80>
        if((_DRV_GMAC_DescSpace(wTxIndex, pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail, wTxDescCount)) &&
   14c1a:	f8be 10b4 	ldrh.w	r1, [lr, #180]	; 0xb4
    return (tail > head)? (tail - head) : (size - head + tail);
   14c1e:	4299      	cmp	r1, r3
   14c20:	d8dd      	bhi.n	14bde <DRV_PIC32CGMAC_LibTxSendPacket+0x2e>
   14c22:	4461      	add	r1, ip
   14c24:	b289      	uxth	r1, r1
   14c26:	4299      	cmp	r1, r3
   14c28:	d1d9      	bne.n	14bde <DRV_PIC32CGMAC_LibTxSendPacket+0x2e>
            return DRV_PIC32CGMAC_RES_NO_DESCRIPTORS;
   14c2a:	2003      	movs	r0, #3
   14c2c:	e02e      	b.n	14c8c <DRV_PIC32CGMAC_LibTxSendPacket+0xdc>
    uint8_t nLoopCnt =0;
   14c2e:	2400      	movs	r4, #0
    pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescHead = wTxIndex;
   14c30:	212c      	movs	r1, #44	; 0x2c
   14c32:	fb01 0002 	mla	r0, r1, r2, r0
   14c36:	f8a0 30b2 	strh.w	r3, [r0, #178]	; 0xb2
    GCIRC_DEC(wTxIndex,wTxDescCount);
   14c3a:	b973      	cbnz	r3, 14c5a <DRV_PIC32CGMAC_LibTxSendPacket+0xaa>
   14c3c:	f10c 33ff 	add.w	r3, ip, #4294967295
   14c40:	b29b      	uxth	r3, r3
    pTxDesc[wTxIndex].tx_desc_status.val |= GMAC_TX_LAST_BUFFER_BIT;
   14c42:	eb07 01c3 	add.w	r1, r7, r3, lsl #3
   14c46:	684a      	ldr	r2, [r1, #4]
   14c48:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
   14c4c:	604a      	str	r2, [r1, #4]
    while(nLoopCnt)
   14c4e:	b1bc      	cbz	r4, 14c80 <DRV_PIC32CGMAC_LibTxSendPacket+0xd0>
        GCIRC_DEC(wTxIndex,wTxDescCount);
   14c50:	f10c 3cff 	add.w	ip, ip, #4294967295
   14c54:	fa1f fc8c 	uxth.w	ip, ip
   14c58:	e008      	b.n	14c6c <DRV_PIC32CGMAC_LibTxSendPacket+0xbc>
    GCIRC_DEC(wTxIndex,wTxDescCount);
   14c5a:	3b01      	subs	r3, #1
   14c5c:	b29b      	uxth	r3, r3
   14c5e:	e7f0      	b.n	14c42 <DRV_PIC32CGMAC_LibTxSendPacket+0x92>
        GCIRC_DEC(wTxIndex,wTxDescCount);
   14c60:	3b01      	subs	r3, #1
   14c62:	b29b      	uxth	r3, r3
        nLoopCnt--;
   14c64:	3c01      	subs	r4, #1
    while(nLoopCnt)
   14c66:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
   14c6a:	d009      	beq.n	14c80 <DRV_PIC32CGMAC_LibTxSendPacket+0xd0>
        pTxDesc[wTxIndex].tx_desc_status.val &= ~GMAC_TX_USED_BIT;
   14c6c:	eb07 01c3 	add.w	r1, r7, r3, lsl #3
   14c70:	684a      	ldr	r2, [r1, #4]
   14c72:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
   14c76:	604a      	str	r2, [r1, #4]
        GCIRC_DEC(wTxIndex,wTxDescCount);
   14c78:	2b00      	cmp	r3, #0
   14c7a:	d1f1      	bne.n	14c60 <DRV_PIC32CGMAC_LibTxSendPacket+0xb0>
   14c7c:	4663      	mov	r3, ip
   14c7e:	e7f1      	b.n	14c64 <DRV_PIC32CGMAC_LibTxSendPacket+0xb4>
    GMAC_REGS->GMAC_NCR |= GMAC_NCR_TSTART_Msk;	
   14c80:	4a04      	ldr	r2, [pc, #16]	; (14c94 <DRV_PIC32CGMAC_LibTxSendPacket+0xe4>)
   14c82:	6813      	ldr	r3, [r2, #0]
   14c84:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   14c88:	6013      	str	r3, [r2, #0]
	return DRV_PIC32CGMAC_RES_OK;
   14c8a:	2000      	movs	r0, #0
} //DRV_PIC32CGMAC_LibTxSendPacket
   14c8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            return DRV_PIC32CGMAC_RES_NO_DESCRIPTORS;
   14c90:	2003      	movs	r0, #3
   14c92:	e7fb      	b.n	14c8c <DRV_PIC32CGMAC_LibTxSendPacket+0xdc>
   14c94:	42000800 	.word	0x42000800

Disassembly of section .text._Command_IPAddressSet%313:

00014c98 <_Command_IPAddressSet>:
{
   14c98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14c9c:	b082      	sub	sp, #8
   14c9e:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   14ca0:	6845      	ldr	r5, [r0, #4]
    if (argc < 3)
   14ca2:	2902      	cmp	r1, #2
   14ca4:	dc10      	bgt.n	14cc8 <_Command_IPAddressSet+0x30>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: setip <interface> <ipv4/6 address> <ipv4mask/ipv6 prefix len>\r\n");
   14ca6:	4e2f      	ldr	r6, [pc, #188]	; (14d64 <_Command_IPAddressSet+0xcc>)
   14ca8:	6803      	ldr	r3, [r0, #0]
   14caa:	681b      	ldr	r3, [r3, #0]
   14cac:	f606 51fc 	addw	r1, r6, #3580	; 0xdfc
   14cb0:	4628      	mov	r0, r5
   14cb2:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: setip PIC32INT 192.168.0.8 255.255.255.0 \r\n");
   14cb4:	6823      	ldr	r3, [r4, #0]
   14cb6:	681b      	ldr	r3, [r3, #0]
   14cb8:	f606 6144 	addw	r1, r6, #3652	; 0xe44
   14cbc:	4628      	mov	r0, r5
   14cbe:	4798      	blx	r3
}
   14cc0:	2000      	movs	r0, #0
   14cc2:	b002      	add	sp, #8
   14cc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14cc8:	460e      	mov	r6, r1
   14cca:	4617      	mov	r7, r2
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
   14ccc:	6850      	ldr	r0, [r2, #4]
   14cce:	f008 fe41 	bl	1d954 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
   14cd2:	4680      	mov	r8, r0
   14cd4:	b150      	cbz	r0, 14cec <_Command_IPAddressSet+0x54>
   14cd6:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   14cda:	f013 0f40 	tst.w	r3, #64	; 0x40
   14cde:	d10b      	bne.n	14cf8 <_Command_IPAddressSet+0x60>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "No such interface is up\r\n");
   14ce0:	6823      	ldr	r3, [r4, #0]
   14ce2:	681b      	ldr	r3, [r3, #0]
   14ce4:	4920      	ldr	r1, [pc, #128]	; (14d68 <_Command_IPAddressSet+0xd0>)
   14ce6:	4628      	mov	r0, r5
   14ce8:	4798      	blx	r3
        return false;
   14cea:	e7e9      	b.n	14cc0 <_Command_IPAddressSet+0x28>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   14cec:	6823      	ldr	r3, [r4, #0]
   14cee:	681b      	ldr	r3, [r3, #0]
   14cf0:	491e      	ldr	r1, [pc, #120]	; (14d6c <_Command_IPAddressSet+0xd4>)
   14cf2:	4628      	mov	r0, r5
   14cf4:	4798      	blx	r3
        return false;
   14cf6:	e7e3      	b.n	14cc0 <_Command_IPAddressSet+0x28>
    if (TCPIP_Helper_StringToIPAddress(argv[2], &ipAddr))
   14cf8:	a901      	add	r1, sp, #4
   14cfa:	68b8      	ldr	r0, [r7, #8]
   14cfc:	f7fe f946 	bl	12f8c <TCPIP_Helper_StringToIPAddress>
   14d00:	b928      	cbnz	r0, 14d0e <_Command_IPAddressSet+0x76>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Invalid IP address string \r\n");
   14d02:	6823      	ldr	r3, [r4, #0]
   14d04:	681b      	ldr	r3, [r3, #0]
   14d06:	491a      	ldr	r1, [pc, #104]	; (14d70 <_Command_IPAddressSet+0xd8>)
   14d08:	4628      	mov	r0, r5
   14d0a:	4798      	blx	r3
        return false;
   14d0c:	e7d8      	b.n	14cc0 <_Command_IPAddressSet+0x28>
        if(_TCPIPStackAddressServiceIsRunning(pNetIf) != TCPIP_STACK_ADDRESS_SERVICE_NONE)
   14d0e:	4640      	mov	r0, r8
   14d10:	f00d f980 	bl	22014 <_TCPIPStackAddressServiceIsRunning>
   14d14:	b940      	cbnz	r0, 14d28 <_Command_IPAddressSet+0x90>
        if(argc > 3)
   14d16:	2e03      	cmp	r6, #3
   14d18:	dd12      	ble.n	14d40 <_Command_IPAddressSet+0xa8>
            if (!TCPIP_Helper_StringToIPAddress(argv[3], &ipMask))
   14d1a:	4669      	mov	r1, sp
   14d1c:	68f8      	ldr	r0, [r7, #12]
   14d1e:	f7fe f935 	bl	12f8c <TCPIP_Helper_StringToIPAddress>
   14d22:	b138      	cbz	r0, 14d34 <_Command_IPAddressSet+0x9c>
            pMask = &ipMask;
   14d24:	466a      	mov	r2, sp
   14d26:	e00c      	b.n	14d42 <_Command_IPAddressSet+0xaa>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "An address service is already running. Stop DHCP, ZCLL, etc. first\r\n");
   14d28:	6823      	ldr	r3, [r4, #0]
   14d2a:	681b      	ldr	r3, [r3, #0]
   14d2c:	4911      	ldr	r1, [pc, #68]	; (14d74 <_Command_IPAddressSet+0xdc>)
   14d2e:	4628      	mov	r0, r5
   14d30:	4798      	blx	r3
            return false;
   14d32:	e7c5      	b.n	14cc0 <_Command_IPAddressSet+0x28>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Invalid IP mask string \r\n");
   14d34:	6823      	ldr	r3, [r4, #0]
   14d36:	681b      	ldr	r3, [r3, #0]
   14d38:	490f      	ldr	r1, [pc, #60]	; (14d78 <_Command_IPAddressSet+0xe0>)
   14d3a:	4628      	mov	r0, r5
   14d3c:	4798      	blx	r3
                return false;
   14d3e:	e7bf      	b.n	14cc0 <_Command_IPAddressSet+0x28>
            pMask = 0;
   14d40:	2200      	movs	r2, #0
        if(TCPIP_STACK_NetAddressSet(netH, &ipAddr, pMask, true))
   14d42:	2301      	movs	r3, #1
   14d44:	a901      	add	r1, sp, #4
   14d46:	4640      	mov	r0, r8
   14d48:	f003 ff42 	bl	18bd0 <TCPIP_STACK_NetAddressSet>
    (*pCmdIO->pCmdApi->msg)(cmdIoParam, success ? "Set ip address OK\r\n" : "Set ip address failed\r\n");
   14d4c:	6823      	ldr	r3, [r4, #0]
   14d4e:	681b      	ldr	r3, [r3, #0]
   14d50:	2800      	cmp	r0, #0
   14d52:	490a      	ldr	r1, [pc, #40]	; (14d7c <_Command_IPAddressSet+0xe4>)
   14d54:	f101 0214 	add.w	r2, r1, #20
   14d58:	bf08      	it	eq
   14d5a:	4611      	moveq	r1, r2
   14d5c:	4628      	mov	r0, r5
   14d5e:	4798      	blx	r3
    return false;
   14d60:	e7ae      	b.n	14cc0 <_Command_IPAddressSet+0x28>
   14d62:	bf00      	nop
   14d64:	0000028c 	.word	0x0000028c
   14d68:	00001100 	.word	0x00001100
   14d6c:	00000da8 	.word	0x00000da8
   14d70:	0000103c 	.word	0x0000103c
   14d74:	0000111c 	.word	0x0000111c
   14d78:	00001164 	.word	0x00001164
   14d7c:	0000105c 	.word	0x0000105c

Disassembly of section .text.xTaskResumeAll%314:

00014d80 <xTaskResumeAll>:
{
   14d80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	taskENTER_CRITICAL();
   14d84:	f00b fec4 	bl	20b10 <vPortEnterCritical>
		--uxSchedulerSuspended;
   14d88:	4b2d      	ldr	r3, [pc, #180]	; (14e40 <xTaskResumeAll+0xc0>)
   14d8a:	681a      	ldr	r2, [r3, #0]
   14d8c:	3a01      	subs	r2, #1
   14d8e:	601a      	str	r2, [r3, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   14d90:	681b      	ldr	r3, [r3, #0]
   14d92:	2b00      	cmp	r3, #0
   14d94:	d14d      	bne.n	14e32 <xTaskResumeAll+0xb2>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   14d96:	4b2b      	ldr	r3, [pc, #172]	; (14e44 <xTaskResumeAll+0xc4>)
   14d98:	681b      	ldr	r3, [r3, #0]
   14d9a:	b90b      	cbnz	r3, 14da0 <xTaskResumeAll+0x20>
BaseType_t xAlreadyYielded = pdFALSE;
   14d9c:	2400      	movs	r4, #0
   14d9e:	e049      	b.n	14e34 <xTaskResumeAll+0xb4>
TCB_t *pxTCB = NULL;
   14da0:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   14da2:	4e29      	ldr	r6, [pc, #164]	; (14e48 <xTaskResumeAll+0xc8>)
					prvAddTaskToReadyList( pxTCB );
   14da4:	4f29      	ldr	r7, [pc, #164]	; (14e4c <xTaskResumeAll+0xcc>)
   14da6:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 14e60 <xTaskResumeAll+0xe0>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   14daa:	6833      	ldr	r3, [r6, #0]
   14dac:	b303      	cbz	r3, 14df0 <xTaskResumeAll+0x70>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   14dae:	68f3      	ldr	r3, [r6, #12]
   14db0:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   14db2:	f104 0018 	add.w	r0, r4, #24
   14db6:	f00b fb7d 	bl	204b4 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   14dba:	1d25      	adds	r5, r4, #4
   14dbc:	4628      	mov	r0, r5
   14dbe:	f00b fb79 	bl	204b4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   14dc2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   14dc4:	683a      	ldr	r2, [r7, #0]
   14dc6:	2301      	movs	r3, #1
   14dc8:	4083      	lsls	r3, r0
   14dca:	4313      	orrs	r3, r2
   14dcc:	603b      	str	r3, [r7, #0]
   14dce:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   14dd2:	4629      	mov	r1, r5
   14dd4:	eb08 0080 	add.w	r0, r8, r0, lsl #2
   14dd8:	f00c fca5 	bl	21726 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   14ddc:	4b1c      	ldr	r3, [pc, #112]	; (14e50 <xTaskResumeAll+0xd0>)
   14dde:	681b      	ldr	r3, [r3, #0]
   14de0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   14de2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   14de4:	429a      	cmp	r2, r3
   14de6:	d3e0      	bcc.n	14daa <xTaskResumeAll+0x2a>
						xYieldPending = pdTRUE;
   14de8:	4b1a      	ldr	r3, [pc, #104]	; (14e54 <xTaskResumeAll+0xd4>)
   14dea:	2201      	movs	r2, #1
   14dec:	601a      	str	r2, [r3, #0]
   14dee:	e7dc      	b.n	14daa <xTaskResumeAll+0x2a>
				if( pxTCB != NULL )
   14df0:	b10c      	cbz	r4, 14df6 <xTaskResumeAll+0x76>
					prvResetNextTaskUnblockTime();
   14df2:	f00a fda7 	bl	1f944 <prvResetNextTaskUnblockTime>
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
   14df6:	4b18      	ldr	r3, [pc, #96]	; (14e58 <xTaskResumeAll+0xd8>)
   14df8:	681c      	ldr	r4, [r3, #0]
					if( xPendedCounts > ( TickType_t ) 0U )
   14dfa:	b16c      	cbz	r4, 14e18 <xTaskResumeAll+0x98>
								xYieldPending = pdTRUE;
   14dfc:	4e15      	ldr	r6, [pc, #84]	; (14e54 <xTaskResumeAll+0xd4>)
   14dfe:	2501      	movs	r5, #1
   14e00:	e001      	b.n	14e06 <xTaskResumeAll+0x86>
						} while( xPendedCounts > ( TickType_t ) 0U );
   14e02:	3c01      	subs	r4, #1
   14e04:	d005      	beq.n	14e12 <xTaskResumeAll+0x92>
							if( xTaskIncrementTick() != pdFALSE )
   14e06:	f7fe fafb 	bl	13400 <xTaskIncrementTick>
   14e0a:	2800      	cmp	r0, #0
   14e0c:	d0f9      	beq.n	14e02 <xTaskResumeAll+0x82>
								xYieldPending = pdTRUE;
   14e0e:	6035      	str	r5, [r6, #0]
   14e10:	e7f7      	b.n	14e02 <xTaskResumeAll+0x82>
						xPendedTicks = 0;
   14e12:	4b11      	ldr	r3, [pc, #68]	; (14e58 <xTaskResumeAll+0xd8>)
   14e14:	2200      	movs	r2, #0
   14e16:	601a      	str	r2, [r3, #0]
				if( xYieldPending != pdFALSE )
   14e18:	4b0e      	ldr	r3, [pc, #56]	; (14e54 <xTaskResumeAll+0xd4>)
   14e1a:	681c      	ldr	r4, [r3, #0]
   14e1c:	b154      	cbz	r4, 14e34 <xTaskResumeAll+0xb4>
					taskYIELD_IF_USING_PREEMPTION();
   14e1e:	4b0f      	ldr	r3, [pc, #60]	; (14e5c <xTaskResumeAll+0xdc>)
   14e20:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   14e24:	601a      	str	r2, [r3, #0]
   14e26:	f3bf 8f4f 	dsb	sy
   14e2a:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
   14e2e:	2401      	movs	r4, #1
   14e30:	e000      	b.n	14e34 <xTaskResumeAll+0xb4>
BaseType_t xAlreadyYielded = pdFALSE;
   14e32:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
   14e34:	f00c fd44 	bl	218c0 <vPortExitCritical>
}
   14e38:	4620      	mov	r0, r4
   14e3a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14e3e:	bf00      	nop
   14e40:	2000e6b8 	.word	0x2000e6b8
   14e44:	2000e6b0 	.word	0x2000e6b0
   14e48:	2000e4b4 	.word	0x2000e4b4
   14e4c:	2000e6c0 	.word	0x2000e6c0
   14e50:	2000e6a4 	.word	0x2000e6a4
   14e54:	2000e6dc 	.word	0x2000e6dc
   14e58:	2000e6d0 	.word	0x2000e6d0
   14e5c:	e000ed04 	.word	0xe000ed04
   14e60:	2000e080 	.word	0x2000e080

Disassembly of section .text.TCPIP_UDP_ArrayGet%315:

00014e64 <TCPIP_UDP_ArrayGet>:
{
   14e64:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    if(reqBytes == 0 || pSkt == 0)
   14e68:	2a00      	cmp	r2, #0
   14e6a:	d063      	beq.n	14f34 <TCPIP_UDP_ArrayGet+0xd0>
   14e6c:	4689      	mov	r9, r1
   14e6e:	4616      	mov	r6, r2
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   14e70:	f00b f838 	bl	1fee4 <_UDPSocketDcpt>
    if(reqBytes == 0 || pSkt == 0)
   14e74:	4604      	mov	r4, r0
   14e76:	2800      	cmp	r0, #0
   14e78:	d060      	beq.n	14f3c <TCPIP_UDP_ArrayGet+0xd8>
    if(pSkt->pCurrRxSeg == 0 && pSkt->extFlags.rxAutoAdvance != 0)
   14e7a:	6b03      	ldr	r3, [r0, #48]	; 0x30
   14e7c:	b133      	cbz	r3, 14e8c <TCPIP_UDP_ArrayGet+0x28>
    while(reqBytes != 0 && (pSeg = pSkt->pCurrRxSeg) != 0 && pSkt->rxTotLen != 0)
   14e7e:	6b07      	ldr	r7, [r0, #48]	; 0x30
   14e80:	8ee5      	ldrh	r5, [r4, #54]	; 0x36
   14e82:	46a8      	mov	r8, r5
   14e84:	b1c5      	cbz	r5, 14eb8 <TCPIP_UDP_ArrayGet+0x54>
   14e86:	f04f 0800 	mov.w	r8, #0
   14e8a:	e026      	b.n	14eda <TCPIP_UDP_ArrayGet+0x76>
    if(pSkt->pCurrRxSeg == 0 && pSkt->extFlags.rxAutoAdvance != 0)
   14e8c:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   14e90:	f013 0f01 	tst.w	r3, #1
   14e94:	d102      	bne.n	14e9c <TCPIP_UDP_ArrayGet+0x38>
   14e96:	f04f 0800 	mov.w	r8, #0
   14e9a:	e00a      	b.n	14eb2 <TCPIP_UDP_ArrayGet+0x4e>
        _UDPUpdatePacketLock(pSkt);
   14e9c:	f00b f836 	bl	1ff0c <_UDPUpdatePacketLock>
    while(reqBytes != 0 && (pSeg = pSkt->pCurrRxSeg) != 0 && pSkt->rxTotLen != 0)
   14ea0:	6b27      	ldr	r7, [r4, #48]	; 0x30
   14ea2:	f04f 0800 	mov.w	r8, #0
   14ea6:	2f00      	cmp	r7, #0
   14ea8:	d1ea      	bne.n	14e80 <TCPIP_UDP_ArrayGet+0x1c>
   14eaa:	e002      	b.n	14eb2 <TCPIP_UDP_ArrayGet+0x4e>
                pSkt->rxSegLen = 0;
   14eac:	2300      	movs	r3, #0
   14eae:	86a3      	strh	r3, [r4, #52]	; 0x34
                pSkt->rxCurr = 0;
   14eb0:	63a3      	str	r3, [r4, #56]	; 0x38
    if(pSkt->rxTotLen == 0 && pSkt->extFlags.rxAutoAdvance != 0)
   14eb2:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   14eb4:	2b00      	cmp	r3, #0
   14eb6:	d13e      	bne.n	14f36 <TCPIP_UDP_ArrayGet+0xd2>
   14eb8:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   14ebc:	f013 0f01 	tst.w	r3, #1
   14ec0:	d039      	beq.n	14f36 <TCPIP_UDP_ArrayGet+0xd2>
        _UDPUpdatePacketLock(pSkt);
   14ec2:	4620      	mov	r0, r4
   14ec4:	f00b f822 	bl	1ff0c <_UDPUpdatePacketLock>
   14ec8:	e035      	b.n	14f36 <TCPIP_UDP_ArrayGet+0xd2>
    while(reqBytes != 0 && (pSeg = pSkt->pCurrRxSeg) != 0 && pSkt->rxTotLen != 0)
   14eca:	2e00      	cmp	r6, #0
   14ecc:	d0f1      	beq.n	14eb2 <TCPIP_UDP_ArrayGet+0x4e>
   14ece:	6b27      	ldr	r7, [r4, #48]	; 0x30
   14ed0:	2f00      	cmp	r7, #0
   14ed2:	d0ee      	beq.n	14eb2 <TCPIP_UDP_ArrayGet+0x4e>
   14ed4:	8ee5      	ldrh	r5, [r4, #54]	; 0x36
   14ed6:	2d00      	cmp	r5, #0
   14ed8:	d0ee      	beq.n	14eb8 <TCPIP_UDP_ArrayGet+0x54>
        xtractBytes = reqBytes <= pSkt->rxSegLen ? reqBytes : pSkt->rxSegLen;
   14eda:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
   14edc:	42b3      	cmp	r3, r6
   14ede:	bf28      	it	cs
   14ee0:	4633      	movcs	r3, r6
        if(xtractBytes > pSkt->rxTotLen)
   14ee2:	429d      	cmp	r5, r3
   14ee4:	bf28      	it	cs
   14ee6:	461d      	movcs	r5, r3
        if(xtractBytes)
   14ee8:	b1b5      	cbz	r5, 14f18 <TCPIP_UDP_ArrayGet+0xb4>
            if(cData != 0)
   14eea:	f1b9 0f00 	cmp.w	r9, #0
   14eee:	d005      	beq.n	14efc <TCPIP_UDP_ArrayGet+0x98>
                memcpy(cData, pSkt->rxCurr, xtractBytes);
   14ef0:	462a      	mov	r2, r5
   14ef2:	6ba1      	ldr	r1, [r4, #56]	; 0x38
   14ef4:	4648      	mov	r0, r9
   14ef6:	f00c f8b3 	bl	21060 <memcpy>
                cData += xtractBytes;
   14efa:	44a9      	add	r9, r5
            reqBytes -= xtractBytes;
   14efc:	1b76      	subs	r6, r6, r5
   14efe:	b2b6      	uxth	r6, r6
            avlblBytes += xtractBytes;
   14f00:	44a8      	add	r8, r5
   14f02:	fa1f f888 	uxth.w	r8, r8
            pSkt->rxTotLen -= xtractBytes;
   14f06:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   14f08:	1b5b      	subs	r3, r3, r5
   14f0a:	86e3      	strh	r3, [r4, #54]	; 0x36
            pSkt->rxSegLen -= xtractBytes;
   14f0c:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
   14f0e:	1b5b      	subs	r3, r3, r5
   14f10:	86a3      	strh	r3, [r4, #52]	; 0x34
            pSkt->rxCurr += xtractBytes;
   14f12:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   14f14:	441d      	add	r5, r3
   14f16:	63a5      	str	r5, [r4, #56]	; 0x38
        if(pSkt->rxSegLen == 0)
   14f18:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
   14f1a:	2b00      	cmp	r3, #0
   14f1c:	d1d5      	bne.n	14eca <TCPIP_UDP_ArrayGet+0x66>
            pSeg = pSeg->next;
   14f1e:	683f      	ldr	r7, [r7, #0]
            if((pSkt->pCurrRxSeg = pSeg) != 0)
   14f20:	6327      	str	r7, [r4, #48]	; 0x30
   14f22:	2f00      	cmp	r7, #0
   14f24:	d0c2      	beq.n	14eac <TCPIP_UDP_ArrayGet+0x48>
                pSkt->rxSegLen = pSeg->segLen;
   14f26:	89bb      	ldrh	r3, [r7, #12]
   14f28:	86a3      	strh	r3, [r4, #52]	; 0x34
                pSkt->rxCurr = pSeg->segLoad;
   14f2a:	68bb      	ldr	r3, [r7, #8]
   14f2c:	63a3      	str	r3, [r4, #56]	; 0x38
    while(reqBytes != 0 && (pSeg = pSkt->pCurrRxSeg) != 0 && pSkt->rxTotLen != 0)
   14f2e:	2e00      	cmp	r6, #0
   14f30:	d1d0      	bne.n	14ed4 <TCPIP_UDP_ArrayGet+0x70>
   14f32:	e7be      	b.n	14eb2 <TCPIP_UDP_ArrayGet+0x4e>
        return 0;
   14f34:	4690      	mov	r8, r2
}
   14f36:	4640      	mov	r0, r8
   14f38:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return 0;
   14f3c:	f04f 0800 	mov.w	r8, #0
   14f40:	e7f9      	b.n	14f36 <TCPIP_UDP_ArrayGet+0xd2>

Disassembly of section .text.DRV_ETHPHY_Setup%316:

00014f44 <DRV_ETHPHY_Setup>:
    if(hClientObj == 0)
   14f44:	2800      	cmp	r0, #0
   14f46:	d045      	beq.n	14fd4 <DRV_ETHPHY_Setup+0x90>
{
   14f48:	b5f0      	push	{r4, r5, r6, r7, lr}
   14f4a:	b085      	sub	sp, #20
   14f4c:	4604      	mov	r4, r0
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   14f4e:	68c0      	ldr	r0, [r0, #12]
   14f50:	4b30      	ldr	r3, [pc, #192]	; (15014 <DRV_ETHPHY_Setup+0xd0>)
   14f52:	4298      	cmp	r0, r3
   14f54:	d141      	bne.n	14fda <DRV_ETHPHY_Setup+0x96>
    if(hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_READY)
   14f56:	f994 3008 	ldrsb.w	r3, [r4, #8]
   14f5a:	2b02      	cmp	r3, #2
   14f5c:	d141      	bne.n	14fe2 <DRV_ETHPHY_Setup+0x9e>
    if(pSetUp == 0 || pSetupFlags == 0)
   14f5e:	2900      	cmp	r1, #0
   14f60:	d042      	beq.n	14fe8 <DRV_ETHPHY_Setup+0xa4>
   14f62:	2a00      	cmp	r2, #0
   14f64:	d043      	beq.n	14fee <DRV_ETHPHY_Setup+0xaa>
    pPhyObj = phyInst->pPhyObj;
   14f66:	4b2b      	ldr	r3, [pc, #172]	; (15014 <DRV_ETHPHY_Setup+0xd0>)
   14f68:	695f      	ldr	r7, [r3, #20]
    if(pPhyObj == 0 || pPhyObj->miiConfigure == 0 || pPhyObj->mdixConfigure == 0 || pPhyObj->smiClockGet == 0)
   14f6a:	2f00      	cmp	r7, #0
   14f6c:	d042      	beq.n	14ff4 <DRV_ETHPHY_Setup+0xb0>
   14f6e:	683b      	ldr	r3, [r7, #0]
   14f70:	2b00      	cmp	r3, #0
   14f72:	d042      	beq.n	14ffa <DRV_ETHPHY_Setup+0xb6>
   14f74:	687b      	ldr	r3, [r7, #4]
   14f76:	2b00      	cmp	r3, #0
   14f78:	d042      	beq.n	15000 <DRV_ETHPHY_Setup+0xbc>
   14f7a:	68bb      	ldr	r3, [r7, #8]
   14f7c:	2b00      	cmp	r3, #0
   14f7e:	d042      	beq.n	15006 <DRV_ETHPHY_Setup+0xc2>
   14f80:	4616      	mov	r6, r2
   14f82:	460d      	mov	r5, r1
    if(pSetUp->resetFunction)
   14f84:	688b      	ldr	r3, [r1, #8]
   14f86:	b10b      	cbz	r3, 14f8c <DRV_ETHPHY_Setup+0x48>
        (*pSetUp->resetFunction)(gDrvEthBaseObj);
   14f88:	4823      	ldr	r0, [pc, #140]	; (15018 <DRV_ETHPHY_Setup+0xd4>)
   14f8a:	4798      	blx	r3
	miimSetup.hostClockFreq = (uint32_t)TCPIP_INTMAC_PERIPHERAL_CLK;
   14f8c:	4b23      	ldr	r3, [pc, #140]	; (1501c <DRV_ETHPHY_Setup+0xd8>)
   14f8e:	9301      	str	r3, [sp, #4]
    miimSetup.maxBusFreq = (*pPhyObj->smiClockGet)(gDrvEthBaseObj, handle);
   14f90:	68bb      	ldr	r3, [r7, #8]
   14f92:	4621      	mov	r1, r4
   14f94:	4820      	ldr	r0, [pc, #128]	; (15018 <DRV_ETHPHY_Setup+0xd4>)
   14f96:	4798      	blx	r3
   14f98:	9002      	str	r0, [sp, #8]
    miimSetup.setupFlags = DRV_MIIM_SETUP_FLAG_NONE;
   14f9a:	2300      	movs	r3, #0
   14f9c:	f88d 300c 	strb.w	r3, [sp, #12]
    DRV_MIIM_RESULT miimRes = hClientObj->pMiimBase->DRV_MIIM_Setup(hClientObj->miimHandle, &miimSetup); 
   14fa0:	6923      	ldr	r3, [r4, #16]
   14fa2:	699b      	ldr	r3, [r3, #24]
   14fa4:	a901      	add	r1, sp, #4
   14fa6:	6960      	ldr	r0, [r4, #20]
   14fa8:	4798      	blx	r3
    if(miimRes < 0)
   14faa:	2800      	cmp	r0, #0
   14fac:	db2e      	blt.n	1500c <DRV_ETHPHY_Setup+0xc8>
    phyInst->phyAddress = pSetUp->phyAddress;
   14fae:	682a      	ldr	r2, [r5, #0]
   14fb0:	4b18      	ldr	r3, [pc, #96]	; (15014 <DRV_ETHPHY_Setup+0xd0>)
   14fb2:	611a      	str	r2, [r3, #16]
    phyInst->openFlags = pSetUp->openFlags;
   14fb4:	88aa      	ldrh	r2, [r5, #4]
   14fb6:	819a      	strh	r2, [r3, #12]
    phyInst->configFlags = pSetUp->configFlags;
   14fb8:	79aa      	ldrb	r2, [r5, #6]
   14fba:	739a      	strb	r2, [r3, #14]
    phyInst->macPauseType = pSetUp->macPauseType;
   14fbc:	79ea      	ldrb	r2, [r5, #7]
   14fbe:	73da      	strb	r2, [r3, #15]
    hClientObj->operParam = (uintptr_t)pSetupFlags;
   14fc0:	6326      	str	r6, [r4, #48]	; 0x30
    hClientObj->operType = opType;
   14fc2:	2001      	movs	r0, #1
   14fc4:	83a0      	strh	r0, [r4, #28]
    hClientObj->operPhase = hClientObj->operSubPhase = 0; 
   14fc6:	2300      	movs	r3, #0
   14fc8:	8423      	strh	r3, [r4, #32]
   14fca:	83e3      	strh	r3, [r4, #30]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_BUSY; 
   14fcc:	7220      	strb	r0, [r4, #8]
    hClientObj->operRes = res;
   14fce:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
   14fd2:	e004      	b.n	14fde <DRV_ETHPHY_Setup+0x9a>
        return DRV_ETHPHY_RES_HANDLE_ERR;
   14fd4:	f06f 000a 	mvn.w	r0, #10
}
   14fd8:	4770      	bx	lr
        return DRV_ETHPHY_RES_HANDLE_ERR;
   14fda:	f06f 000a 	mvn.w	r0, #10
}
   14fde:	b005      	add	sp, #20
   14fe0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   14fe2:	f06f 0009 	mvn.w	r0, #9
   14fe6:	e7fa      	b.n	14fde <DRV_ETHPHY_Setup+0x9a>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   14fe8:	f06f 0008 	mvn.w	r0, #8
   14fec:	e7f7      	b.n	14fde <DRV_ETHPHY_Setup+0x9a>
   14fee:	f06f 0008 	mvn.w	r0, #8
   14ff2:	e7f4      	b.n	14fde <DRV_ETHPHY_Setup+0x9a>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   14ff4:	f06f 0008 	mvn.w	r0, #8
   14ff8:	e7f1      	b.n	14fde <DRV_ETHPHY_Setup+0x9a>
   14ffa:	f06f 0008 	mvn.w	r0, #8
   14ffe:	e7ee      	b.n	14fde <DRV_ETHPHY_Setup+0x9a>
   15000:	f06f 0008 	mvn.w	r0, #8
   15004:	e7eb      	b.n	14fde <DRV_ETHPHY_Setup+0x9a>
   15006:	f06f 0008 	mvn.w	r0, #8
   1500a:	e7e8      	b.n	14fde <DRV_ETHPHY_Setup+0x9a>
        return DRV_ETHPHY_RES_MIIM_ERR;
   1500c:	f06f 000c 	mvn.w	r0, #12
   15010:	e7e5      	b.n	14fde <DRV_ETHPHY_Setup+0x9a>
   15012:	bf00      	nop
   15014:	2000e018 	.word	0x2000e018
   15018:	0001b540 	.word	0x0001b540
   1501c:	07270e00 	.word	0x07270e00

Disassembly of section .text.__swsetup_r%317:

00015020 <__swsetup_r>:
   15020:	4b32      	ldr	r3, [pc, #200]	; (150ec <__swsetup_r+0xcc>)
   15022:	b570      	push	{r4, r5, r6, lr}
   15024:	681d      	ldr	r5, [r3, #0]
   15026:	4606      	mov	r6, r0
   15028:	460c      	mov	r4, r1
   1502a:	b125      	cbz	r5, 15036 <__swsetup_r+0x16>
   1502c:	69ab      	ldr	r3, [r5, #24]
   1502e:	b913      	cbnz	r3, 15036 <__swsetup_r+0x16>
   15030:	4628      	mov	r0, r5
   15032:	f006 fa25 	bl	1b480 <__sinit>
   15036:	4b2e      	ldr	r3, [pc, #184]	; (150f0 <__swsetup_r+0xd0>)
   15038:	429c      	cmp	r4, r3
   1503a:	d10f      	bne.n	1505c <__swsetup_r+0x3c>
   1503c:	686c      	ldr	r4, [r5, #4]
   1503e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   15042:	b29a      	uxth	r2, r3
   15044:	0715      	lsls	r5, r2, #28
   15046:	d42c      	bmi.n	150a2 <__swsetup_r+0x82>
   15048:	06d0      	lsls	r0, r2, #27
   1504a:	d411      	bmi.n	15070 <__swsetup_r+0x50>
   1504c:	2209      	movs	r2, #9
   1504e:	6032      	str	r2, [r6, #0]
   15050:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   15054:	81a3      	strh	r3, [r4, #12]
   15056:	f04f 30ff 	mov.w	r0, #4294967295
   1505a:	e03e      	b.n	150da <__swsetup_r+0xba>
   1505c:	4b25      	ldr	r3, [pc, #148]	; (150f4 <__swsetup_r+0xd4>)
   1505e:	429c      	cmp	r4, r3
   15060:	d101      	bne.n	15066 <__swsetup_r+0x46>
   15062:	68ac      	ldr	r4, [r5, #8]
   15064:	e7eb      	b.n	1503e <__swsetup_r+0x1e>
   15066:	4b24      	ldr	r3, [pc, #144]	; (150f8 <__swsetup_r+0xd8>)
   15068:	429c      	cmp	r4, r3
   1506a:	bf08      	it	eq
   1506c:	68ec      	ldreq	r4, [r5, #12]
   1506e:	e7e6      	b.n	1503e <__swsetup_r+0x1e>
   15070:	0751      	lsls	r1, r2, #29
   15072:	d512      	bpl.n	1509a <__swsetup_r+0x7a>
   15074:	6b61      	ldr	r1, [r4, #52]	; 0x34
   15076:	b141      	cbz	r1, 1508a <__swsetup_r+0x6a>
   15078:	f104 0344 	add.w	r3, r4, #68	; 0x44
   1507c:	4299      	cmp	r1, r3
   1507e:	d002      	beq.n	15086 <__swsetup_r+0x66>
   15080:	4630      	mov	r0, r6
   15082:	f002 fd27 	bl	17ad4 <_free_r>
   15086:	2300      	movs	r3, #0
   15088:	6363      	str	r3, [r4, #52]	; 0x34
   1508a:	89a3      	ldrh	r3, [r4, #12]
   1508c:	f023 0324 	bic.w	r3, r3, #36	; 0x24
   15090:	81a3      	strh	r3, [r4, #12]
   15092:	2300      	movs	r3, #0
   15094:	6063      	str	r3, [r4, #4]
   15096:	6923      	ldr	r3, [r4, #16]
   15098:	6023      	str	r3, [r4, #0]
   1509a:	89a3      	ldrh	r3, [r4, #12]
   1509c:	f043 0308 	orr.w	r3, r3, #8
   150a0:	81a3      	strh	r3, [r4, #12]
   150a2:	6923      	ldr	r3, [r4, #16]
   150a4:	b94b      	cbnz	r3, 150ba <__swsetup_r+0x9a>
   150a6:	89a3      	ldrh	r3, [r4, #12]
   150a8:	f403 7320 	and.w	r3, r3, #640	; 0x280
   150ac:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   150b0:	d003      	beq.n	150ba <__swsetup_r+0x9a>
   150b2:	4621      	mov	r1, r4
   150b4:	4630      	mov	r0, r6
   150b6:	f003 fb6b 	bl	18790 <__smakebuf_r>
   150ba:	89a2      	ldrh	r2, [r4, #12]
   150bc:	f012 0301 	ands.w	r3, r2, #1
   150c0:	d00c      	beq.n	150dc <__swsetup_r+0xbc>
   150c2:	2300      	movs	r3, #0
   150c4:	60a3      	str	r3, [r4, #8]
   150c6:	6963      	ldr	r3, [r4, #20]
   150c8:	425b      	negs	r3, r3
   150ca:	61a3      	str	r3, [r4, #24]
   150cc:	6923      	ldr	r3, [r4, #16]
   150ce:	b953      	cbnz	r3, 150e6 <__swsetup_r+0xc6>
   150d0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   150d4:	f013 0080 	ands.w	r0, r3, #128	; 0x80
   150d8:	d1ba      	bne.n	15050 <__swsetup_r+0x30>
   150da:	bd70      	pop	{r4, r5, r6, pc}
   150dc:	0792      	lsls	r2, r2, #30
   150de:	bf58      	it	pl
   150e0:	6963      	ldrpl	r3, [r4, #20]
   150e2:	60a3      	str	r3, [r4, #8]
   150e4:	e7f2      	b.n	150cc <__swsetup_r+0xac>
   150e6:	2000      	movs	r0, #0
   150e8:	e7f7      	b.n	150da <__swsetup_r+0xba>
   150ea:	bf00      	nop
   150ec:	2000e700 	.word	0x2000e700
   150f0:	2000e330 	.word	0x2000e330
   150f4:	2000e350 	.word	0x2000e350
   150f8:	2000e310 	.word	0x2000e310

Disassembly of section .text.SYS_TIME_PLIBCallback%318:

000150fc <SYS_TIME_PLIBCallback>:
        }
    }
}

static void SYS_TIME_PLIBCallback(uint32_t status, uintptr_t context)
{
   150fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    SYS_TIME_COUNTER_OBJ* counterObj = (SYS_TIME_COUNTER_OBJ *)&gSystemCounterObj;
    SYS_TIME_TIMER_OBJ* tmrActive = counterObj->tmrActive;
   150fe:	4c32      	ldr	r4, [pc, #200]	; (151c8 <SYS_TIME_PLIBCallback+0xcc>)
   15100:	6b25      	ldr	r5, [r4, #48]	; 0x30
    uint32_t elapsedCount = 0;
    bool interruptState;

    counterObj->hwTimerCurrentValue = counterObj->timePlib->timerCounterGet();
   15102:	6863      	ldr	r3, [r4, #4]
   15104:	699b      	ldr	r3, [r3, #24]
   15106:	4798      	blx	r3
   15108:	6160      	str	r0, [r4, #20]

    elapsedCount = SYS_TIME_GetElapsedCount(counterObj->hwTimerCurrentValue);
   1510a:	6960      	ldr	r0, [r4, #20]
   1510c:	f00b ff46 	bl	20f9c <SYS_TIME_GetElapsedCount>
   15110:	4606      	mov	r6, r0
	
	SYS_TIME_Counter64Update(elapsedCount);
   15112:	f00b ff35 	bl	20f80 <SYS_TIME_Counter64Update>

    if (tmrActive != NULL)
   15116:	2d00      	cmp	r5, #0
   15118:	d04d      	beq.n	151b6 <SYS_TIME_PLIBCallback+0xba>
    {
        counterObj->interruptNestingCount++;
   1511a:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
   1511e:	3301      	adds	r3, #1
   15120:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
    SYS_TIME_UpdateTimerList(elapsedCounts);
   15124:	4630      	mov	r0, r6
   15126:	f00a f895 	bl	1f254 <SYS_TIME_UpdateTimerList>
    SYS_TIME_TIMER_OBJ* tmrActive = counterObj->tmrActive;
   1512a:	6b24      	ldr	r4, [r4, #48]	; 0x30
    while (tmrActive != NULL)
   1512c:	b12c      	cbz	r4, 1513a <SYS_TIME_PLIBCallback+0x3e>
        if(tmrActive->relativeTimePending == 0)
   1512e:	68a3      	ldr	r3, [r4, #8]
   15130:	b91b      	cbnz	r3, 1513a <SYS_TIME_PLIBCallback+0x3e>
            tmrActive->tmrElapsedFlag = true;
   15132:	2501      	movs	r5, #1
                    tmrActive->active = false;
   15134:	2700      	movs	r7, #0
            tmrActive = counterObj->tmrActive;
   15136:	4e24      	ldr	r6, [pc, #144]	; (151c8 <SYS_TIME_PLIBCallback+0xcc>)
   15138:	e011      	b.n	1515e <SYS_TIME_PLIBCallback+0x62>
   1513a:	4d24      	ldr	r5, [pc, #144]	; (151cc <SYS_TIME_PLIBCallback+0xd0>)
{
   1513c:	2400      	movs	r4, #0
        if (timers[i].tmrElapsed == true)
   1513e:	462e      	mov	r6, r5
            timers[i].tmrElapsed = false;
   15140:	4627      	mov	r7, r4
   15142:	e01f      	b.n	15184 <SYS_TIME_PLIBCallback+0x88>
                SYS_TIME_TimerDestroy(tmrActive->tmrHandle);
   15144:	69e0      	ldr	r0, [r4, #28]
   15146:	f009 f801 	bl	1e14c <SYS_TIME_TimerDestroy>
            if(tmrActive->callback != NULL)
   1514a:	68e3      	ldr	r3, [r4, #12]
   1514c:	b10b      	cbz	r3, 15152 <SYS_TIME_PLIBCallback+0x56>
                tmrActive->callback(tmrActive->context);
   1514e:	6920      	ldr	r0, [r4, #16]
   15150:	4798      	blx	r3
            tmrActive = counterObj->tmrActive;
   15152:	6b34      	ldr	r4, [r6, #48]	; 0x30
    while (tmrActive != NULL)
   15154:	2c00      	cmp	r4, #0
   15156:	d0f0      	beq.n	1513a <SYS_TIME_PLIBCallback+0x3e>
        if(tmrActive->relativeTimePending == 0)
   15158:	68a3      	ldr	r3, [r4, #8]
   1515a:	2b00      	cmp	r3, #0
   1515c:	d1ed      	bne.n	1513a <SYS_TIME_PLIBCallback+0x3e>
            tmrActive->tmrElapsedFlag = true;
   1515e:	7525      	strb	r5, [r4, #20]
            tmrActive->tmrElapsed = true;
   15160:	7565      	strb	r5, [r4, #21]
            if ((tmrActive->type == SYS_TIME_SINGLE) && (tmrActive->callback != NULL))
   15162:	78a3      	ldrb	r3, [r4, #2]
   15164:	b913      	cbnz	r3, 1516c <SYS_TIME_PLIBCallback+0x70>
   15166:	68e3      	ldr	r3, [r4, #12]
   15168:	2b00      	cmp	r3, #0
   1516a:	d1eb      	bne.n	15144 <SYS_TIME_PLIBCallback+0x48>
                SYS_TIME_RemoveFromList(tmrActive);
   1516c:	4620      	mov	r0, r4
   1516e:	f006 fafb 	bl	1b768 <SYS_TIME_RemoveFromList>
                if (tmrActive->type == SYS_TIME_SINGLE)
   15172:	78a3      	ldrb	r3, [r4, #2]
   15174:	2b00      	cmp	r3, #0
   15176:	d1e8      	bne.n	1514a <SYS_TIME_PLIBCallback+0x4e>
                    tmrActive->active = false;
   15178:	7067      	strb	r7, [r4, #1]
   1517a:	e7e6      	b.n	1514a <SYS_TIME_PLIBCallback+0x4e>
   1517c:	3401      	adds	r4, #1
   1517e:	3520      	adds	r5, #32
    for ( i = 0; i < SYS_TIME_MAX_TIMERS; i++)
   15180:	2c05      	cmp	r4, #5
   15182:	d012      	beq.n	151aa <SYS_TIME_PLIBCallback+0xae>
        if (timers[i].tmrElapsed == true)
   15184:	eb06 1344 	add.w	r3, r6, r4, lsl #5
   15188:	7d5b      	ldrb	r3, [r3, #21]
   1518a:	2b00      	cmp	r3, #0
   1518c:	d0f6      	beq.n	1517c <SYS_TIME_PLIBCallback+0x80>
            timers[i].tmrElapsed = false;
   1518e:	eb06 1344 	add.w	r3, r6, r4, lsl #5
   15192:	755f      	strb	r7, [r3, #21]
            if (timers[i].type == SYS_TIME_PERIODIC)
   15194:	78ab      	ldrb	r3, [r5, #2]
   15196:	2b01      	cmp	r3, #1
   15198:	d1f0      	bne.n	1517c <SYS_TIME_PLIBCallback+0x80>
                timers[i].relativeTimePending = timers[i].requestedTime;
   1519a:	686b      	ldr	r3, [r5, #4]
   1519c:	eb06 1244 	add.w	r2, r6, r4, lsl #5
   151a0:	6093      	str	r3, [r2, #8]
                SYS_TIME_AddToList(&timers[i]);
   151a2:	4628      	mov	r0, r5
   151a4:	f003 f992 	bl	184cc <SYS_TIME_AddToList>
   151a8:	e7e8      	b.n	1517c <SYS_TIME_PLIBCallback+0x80>

        SYS_TIME_UpdateTime(elapsedCount);

        counterObj->interruptNestingCount--;
   151aa:	4a07      	ldr	r2, [pc, #28]	; (151c8 <SYS_TIME_PLIBCallback+0xcc>)
   151ac:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
   151b0:	3b01      	subs	r3, #1
   151b2:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
    }
    
    interruptState = SYS_INT_Disable();
   151b6:	f00c ff71 	bl	2209c <SYS_INT_Disable>
   151ba:	4604      	mov	r4, r0
    SYS_TIME_HwTimerCompareUpdate();
   151bc:	f001 fb6c 	bl	16898 <SYS_TIME_HwTimerCompareUpdate>
    SYS_INT_Restore(interruptState);
   151c0:	4620      	mov	r0, r4
   151c2:	f00c ff6f 	bl	220a4 <SYS_INT_Restore>
}
   151c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   151c8:	2000e230 	.word	0x2000e230
   151cc:	2000dd50 	.word	0x2000dd50

Disassembly of section .text.ssd1306_init%319:

000151d0 <ssd1306_init>:
 *
 * Call this function to initialize the hardware interface and the OLED
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void ssd1306_init(void) {
   151d0:	b530      	push	{r4, r5, lr}
   151d2:	b083      	sub	sp, #12
     * \brief Perform a hard reset of the OLED controller
     *
     * This functions will reset the OLED controller by setting the reset pin low.
     */
    static inline void ssd1306_hard_reset(void) {
        GFX_DELAY_FUNCTION(20); // At least 10us	
   151d4:	2014      	movs	r0, #20
   151d6:	f009 fcf9 	bl	1ebcc <vTaskDelay>
        GFX_DISPLAY_RESET_CLEAR();
   151da:	4c31      	ldr	r4, [pc, #196]	; (152a0 <ssd1306_init+0xd0>)
   151dc:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   151e0:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
        GFX_DELAY_FUNCTION(20); // At least 10us	
   151e4:	2014      	movs	r0, #20
   151e6:	f009 fcf1 	bl	1ebcc <vTaskDelay>
        GFX_DISPLAY_RESET_SET();
   151ea:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98
        GFX_DELAY_FUNCTION(20); // At least 10us	
   151ee:	2014      	movs	r0, #20
   151f0:	f009 fcec 	bl	1ebcc <vTaskDelay>

    // Do a hard reset of the OLED display controller
    ssd1306_hard_reset();

    // Set the reset pin to the default state	
    GFX_DISPLAY_RESET_SET();
   151f4:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98

    // 1/32 Duty (0x0F~0x3F)
    ssd1306_write_command(SSD1306_CMD_SET_MULTIPLEX_RATIO);
   151f8:	20a8      	movs	r0, #168	; 0xa8
   151fa:	f008 fc8b 	bl	1db14 <ssd1306_write_command>
    ssd1306_write_command(0x1F);
   151fe:	201f      	movs	r0, #31
   15200:	f008 fc88 	bl	1db14 <ssd1306_write_command>

    // Shift Mapping RAM Counter (0x00~0x3F)
    ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_OFFSET);
   15204:	20d3      	movs	r0, #211	; 0xd3
   15206:	f008 fc85 	bl	1db14 <ssd1306_write_command>
    ssd1306_write_command(0x00);
   1520a:	2000      	movs	r0, #0
   1520c:	f008 fc82 	bl	1db14 <ssd1306_write_command>

    // Set Mapping RAM Display Start Line (0x00~0x3F)
    ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_START_LINE(0x00));
   15210:	2040      	movs	r0, #64	; 0x40
   15212:	f008 fc7f 	bl	1db14 <ssd1306_write_command>

    // Set Column Address 0 Mapped to SEG0
    ssd1306_write_command(SSD1306_CMD_SET_SEGMENT_RE_MAP_COL127_SEG0);
   15216:	20a1      	movs	r0, #161	; 0xa1
   15218:	f008 fc7c 	bl	1db14 <ssd1306_write_command>

    // Set COM/Row Scan Scan from COM63 to 0
    ssd1306_write_command(SSD1306_CMD_SET_COM_OUTPUT_SCAN_DOWN);
   1521c:	20c8      	movs	r0, #200	; 0xc8
   1521e:	f008 fc79 	bl	1db14 <ssd1306_write_command>

    // Set COM Pins hardware configuration
    ssd1306_write_command(SSD1306_CMD_SET_COM_PINS);
   15222:	20da      	movs	r0, #218	; 0xda
   15224:	f008 fc76 	bl	1db14 <ssd1306_write_command>
    ssd1306_write_command(0x02);
   15228:	2002      	movs	r0, #2
   1522a:	f008 fc73 	bl	1db14 <ssd1306_write_command>
     * \param contrast a number between 0 and 0xFF
     *
     * \retval contrast the contrast value written to the OLED controller
     */
    static inline uint8_t ssd1306_set_contrast(uint8_t contrast) {
        ssd1306_write_command(SSD1306_CMD_SET_CONTRAST_CONTROL_FOR_BANK0);
   1522e:	2081      	movs	r0, #129	; 0x81
   15230:	f008 fc70 	bl	1db14 <ssd1306_write_command>
        ssd1306_write_command(contrast);
   15234:	208f      	movs	r0, #143	; 0x8f
   15236:	f008 fc6d 	bl	1db14 <ssd1306_write_command>

    ssd1306_set_contrast(0x8F);

    // Disable Entire display On
    ssd1306_write_command(SSD1306_CMD_ENTIRE_DISPLAY_AND_GDDRAM_ON);
   1523a:	20a4      	movs	r0, #164	; 0xa4
   1523c:	f008 fc6a 	bl	1db14 <ssd1306_write_command>
     *
     * This function will disable invert on all pixels on the OLED
     *
     */
    static inline void ssd1306_display_invert_disable(void) {
        ssd1306_write_command(SSD1306_CMD_SET_NORMAL_DISPLAY);
   15240:	20a6      	movs	r0, #166	; 0xa6
   15242:	f008 fc67 	bl	1db14 <ssd1306_write_command>

    ssd1306_display_invert_disable();

    // Set Display Clock Divide Ratio / Oscillator Frequency (Default => 0x80)
    ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_CLOCK_DIVIDE_RATIO);
   15246:	20d5      	movs	r0, #213	; 0xd5
   15248:	f008 fc64 	bl	1db14 <ssd1306_write_command>
    ssd1306_write_command(0x80);
   1524c:	2080      	movs	r0, #128	; 0x80
   1524e:	f008 fc61 	bl	1db14 <ssd1306_write_command>

    // Enable charge pump regulator
    ssd1306_write_command(SSD1306_CMD_SET_CHARGE_PUMP_SETTING);
   15252:	208d      	movs	r0, #141	; 0x8d
   15254:	f008 fc5e 	bl	1db14 <ssd1306_write_command>
    ssd1306_write_command(0x14);
   15258:	2014      	movs	r0, #20
   1525a:	f008 fc5b 	bl	1db14 <ssd1306_write_command>

    // Set VCOMH Deselect Level
    ssd1306_write_command(SSD1306_CMD_SET_VCOMH_DESELECT_LEVEL);
   1525e:	20db      	movs	r0, #219	; 0xdb
   15260:	f008 fc58 	bl	1db14 <ssd1306_write_command>
    ssd1306_write_command(0x40); // Default => 0x20 (0.77*VCC)
   15264:	2040      	movs	r0, #64	; 0x40
   15266:	f008 fc55 	bl	1db14 <ssd1306_write_command>

    // Set Pre-Charge as 15 Clocks & Discharge as 1 Clock
    ssd1306_write_command(SSD1306_CMD_SET_PRE_CHARGE_PERIOD);
   1526a:	20d9      	movs	r0, #217	; 0xd9
   1526c:	f008 fc52 	bl	1db14 <ssd1306_write_command>
    ssd1306_write_command(0xF1);
   15270:	20f1      	movs	r0, #241	; 0xf1
   15272:	f008 fc4f 	bl	1db14 <ssd1306_write_command>
        ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_ON);
   15276:	20af      	movs	r0, #175	; 0xaf
   15278:	f008 fc4c 	bl	1db14 <ssd1306_write_command>

    ssd1306_display_on();

    gfx_mono_draw_filled_rect(0, 0, 128, 32, GFX_PIXEL_SET);
   1527c:	2301      	movs	r3, #1
   1527e:	9300      	str	r3, [sp, #0]
   15280:	2320      	movs	r3, #32
   15282:	2280      	movs	r2, #128	; 0x80
   15284:	2100      	movs	r1, #0
   15286:	4608      	mov	r0, r1
   15288:	f009 fcd4 	bl	1ec34 <gfx_mono_generic_draw_filled_rect>
    gfx_mono_draw_filled_rect(0, 0, 128, 32, GFX_PIXEL_CLR);
   1528c:	2000      	movs	r0, #0
   1528e:	9000      	str	r0, [sp, #0]
   15290:	2320      	movs	r3, #32
   15292:	2280      	movs	r2, #128	; 0x80
   15294:	4601      	mov	r1, r0
   15296:	f009 fccd 	bl	1ec34 <gfx_mono_generic_draw_filled_rect>
}
   1529a:	b003      	add	sp, #12
   1529c:	bd30      	pop	{r4, r5, pc}
   1529e:	bf00      	nop
   152a0:	41008000 	.word	0x41008000

Disassembly of section .text._DRV_ETHPHY_NegResultPhase_ANAD%320:

000152a4 <_DRV_ETHPHY_NegResultPhase_ANAD>:
        _DRV_PHY_SetOperPhase(hClientObj, DRV_ETHPHY_NEG_RESULT_PHASE_ANAD, 0);
    }
}

static void _DRV_ETHPHY_NegResultPhase_ANAD(DRV_ETHPHY_CLIENT_OBJ * hClientObj)
{
   152a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   152a6:	4604      	mov	r4, r0
    DRV_ETHPHY_LINK_STATUS  linkStat;
    TCPIP_ETH_OPEN_FLAGS   oFlags;
    TCPIP_ETH_PAUSE_TYPE   pauseType;

    // wait the ANAD read to complete
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   152a8:	f00b f9dc 	bl	20664 <_DRV_PHY_SMITransfer_Wait>
   152ac:	2800      	cmp	r0, #0
   152ae:	d059      	beq.n	15364 <_DRV_ETHPHY_NegResultPhase_ANAD+0xc0>
    {
        return;
    }

    anadReg.w = hClientObj->smiData;
   152b0:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
    // restore ANEXP
    phyExp.w = hClientObj->operReg[0];
    // restore ANLPAD
    lpAD.w = hClientObj->operReg[1];
   152b2:	8ca5      	ldrh	r5, [r4, #36]	; 0x24

    oFlags = 0;   // don't know the result yet
    pauseType = TCPIP_ETH_PAUSE_TYPE_NONE;
    linkStat = DRV_ETHPHY_LINK_ST_UP;

    lcl_Pause  = (hClientObj->hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_PAUSE) ? 1 : 0;
   152b4:	68e2      	ldr	r2, [r4, #12]
   152b6:	7bd7      	ldrb	r7, [r2, #15]
    lcl_AsmDir = (hClientObj->hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_ASM_DIR) ? 1 : 0;
    lp_Pause   = lp_AsmDir = 0;         // in case negotiation failed

    if(phyExp.LP_AN_ABLE)
   152b8:	f894 2022 	ldrb.w	r2, [r4, #34]	; 0x22
   152bc:	f012 0101 	ands.w	r1, r2, #1
   152c0:	d025      	beq.n	1530e <_DRV_ETHPHY_NegResultPhase_ANAD+0x6a>
    {   // ok,valid auto negotiation info

        if(lpAD.REM_FAULT)
   152c2:	0a29      	lsrs	r1, r5, #8
   152c4:	f001 0220 	and.w	r2, r1, #32
        {
            linkStat |= DRV_ETHPHY_LINK_ST_REMOTE_FAULT;
   152c8:	2a00      	cmp	r2, #0
   152ca:	bf0c      	ite	eq
   152cc:	2001      	moveq	r0, #1
   152ce:	2005      	movne	r0, #5
        }

        if(lpAD.PAUSE)
   152d0:	f011 0f04 	tst.w	r1, #4
        {
            linkStat |= DRV_ETHPHY_LINK_ST_LP_PAUSE;
   152d4:	bf1a      	itte	ne
   152d6:	f040 0010 	orrne.w	r0, r0, #16
            lp_Pause = 1;
   152da:	2601      	movne	r6, #1
    lp_Pause   = lp_AsmDir = 0;         // in case negotiation failed
   152dc:	2600      	moveq	r6, #0
        }
        if(lpAD.ASM_DIR)
   152de:	f011 0f08 	tst.w	r1, #8
   152e2:	d021      	beq.n	15328 <_DRV_ETHPHY_NegResultPhase_ANAD+0x84>
        {
            linkStat |= DRV_ETHPHY_LINK_ST_LP_ASM_DIR;
   152e4:	f040 0020 	orr.w	r0, r0, #32
            lp_AsmDir = 1;
   152e8:	2201      	movs	r2, #1
        }
    }

    // set the PHY connection params
    // advertised capabilities & the matching ones
    anadReg.w &= lpAD.w;
   152ea:	402b      	ands	r3, r5
    // get the settings, according to IEEE 802.3 Annex 28B.3 Priority Resolution
    // Note: we don't support 100BaseT4 !

    if(anadReg.w & _ANAD_BASE100TX_FDX_MASK)
   152ec:	f413 7f80 	tst.w	r3, #256	; 0x100
   152f0:	d121      	bne.n	15336 <_DRV_ETHPHY_NegResultPhase_ANAD+0x92>
    {
        oFlags = (TCPIP_ETH_OPEN_100|TCPIP_ETH_OPEN_FDUPLEX);
    }
    else if(anadReg.w & _ANAD_BASE100TX_MASK)
   152f2:	f013 0f80 	tst.w	r3, #128	; 0x80
   152f6:	d119      	bne.n	1532c <_DRV_ETHPHY_NegResultPhase_ANAD+0x88>
    {
        oFlags = (TCPIP_ETH_OPEN_100 | TCPIP_ETH_OPEN_HDUPLEX);
    }
    else if(anadReg.w & _ANAD_BASE10T_FDX_MASK)
   152f8:	f013 0f40 	tst.w	r3, #64	; 0x40
   152fc:	d133      	bne.n	15366 <_DRV_ETHPHY_NegResultPhase_ANAD+0xc2>
    {
        oFlags = (TCPIP_ETH_OPEN_10 | TCPIP_ETH_OPEN_FDUPLEX);
    }
    else if(anadReg.w & _ANAD_BASE10T_MASK)
   152fe:	f013 0320 	ands.w	r3, r3, #32
   15302:	d116      	bne.n	15332 <_DRV_ETHPHY_NegResultPhase_ANAD+0x8e>
        oFlags = (TCPIP_ETH_OPEN_10 | TCPIP_ETH_OPEN_HDUPLEX);
    }
    else
    {   // this should NOT happen!
        linkStat |= DRV_ETHPHY_LINK_ST_NEG_FATAL_ERR;
        linkStat &= ~DRV_ETHPHY_LINK_ST_UP;      // make sure we stop...!
   15304:	f020 0001 	bic.w	r0, r0, #1
   15308:	f440 5000 	orr.w	r0, r0, #8192	; 0x2000
   1530c:	e00f      	b.n	1532e <_DRV_ETHPHY_NegResultPhase_ANAD+0x8a>
        if(phyExp.PDF)
   1530e:	f002 0210 	and.w	r2, r2, #16
        linkStat |= DRV_ETHPHY_LINK_ST_LP_NEG_UNABLE;
   15312:	2a00      	cmp	r2, #0
   15314:	bf14      	ite	ne
   15316:	200b      	movne	r0, #11
   15318:	2003      	moveq	r0, #3
    anadReg.w &= lpAD.w;
   1531a:	402b      	ands	r3, r5
    if(anadReg.w & _ANAD_BASE100TX_FDX_MASK)
   1531c:	f413 7f80 	tst.w	r3, #256	; 0x100
   15320:	d123      	bne.n	1536a <_DRV_ETHPHY_NegResultPhase_ANAD+0xc6>
   15322:	2200      	movs	r2, #0
   15324:	4616      	mov	r6, r2
   15326:	e7e4      	b.n	152f2 <_DRV_ETHPHY_NegResultPhase_ANAD+0x4e>
    lp_Pause   = lp_AsmDir = 0;         // in case negotiation failed
   15328:	2200      	movs	r2, #0
   1532a:	e7de      	b.n	152ea <_DRV_ETHPHY_NegResultPhase_ANAD+0x46>
        oFlags = (TCPIP_ETH_OPEN_100 | TCPIP_ETH_OPEN_HDUPLEX);
   1532c:	230c      	movs	r3, #12
    pauseType = TCPIP_ETH_PAUSE_TYPE_NONE;
   1532e:	2100      	movs	r1, #0
   15330:	e00f      	b.n	15352 <_DRV_ETHPHY_NegResultPhase_ANAD+0xae>
        oFlags = (TCPIP_ETH_OPEN_10 | TCPIP_ETH_OPEN_HDUPLEX);
   15332:	2314      	movs	r3, #20
   15334:	e7fb      	b.n	1532e <_DRV_ETHPHY_NegResultPhase_ANAD+0x8a>
        oFlags = (TCPIP_ETH_OPEN_100|TCPIP_ETH_OPEN_FDUPLEX);
   15336:	230a      	movs	r3, #10
    lcl_Pause  = (hClientObj->hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_PAUSE) ? 1 : 0;
   15338:	f007 0501 	and.w	r5, r7, #1

    // set the pause type for the MAC
    // according to IEEE Std 802.3-2002 Tables 28B-2, 28B-3
    if(oFlags & TCPIP_ETH_OPEN_FDUPLEX)
    {   // pause type relevant for full duplex only
        if(lp_Pause & (lcl_Pause | (lcl_AsmDir & lp_AsmDir)))
   1533c:	ea02 0267 	and.w	r2, r2, r7, asr #1
   15340:	ea45 0102 	orr.w	r1, r5, r2
   15344:	4031      	ands	r1, r6
    pauseType = TCPIP_ETH_PAUSE_TYPE_NONE;
   15346:	0089      	lsls	r1, r1, #2
        {
            pauseType = TCPIP_ETH_PAUSE_TYPE_EN_TX;
        }
        if(lcl_Pause & (lp_Pause | (lcl_AsmDir & lp_AsmDir)))
   15348:	4332      	orrs	r2, r6
   1534a:	422a      	tst	r2, r5
        {
            pauseType |= TCPIP_ETH_PAUSE_TYPE_EN_RX;
   1534c:	bf18      	it	ne
   1534e:	f041 0108 	orrne.w	r1, r1, #8


static void _DRV_PHY_NegResultSetOperResult(DRV_ETHPHY_CLIENT_OBJ* hClientObj, DRV_ETHPHY_LINK_STATUS linkStatus,
       TCPIP_ETH_OPEN_FLAGS openFlags, TCPIP_ETH_PAUSE_TYPE pauseType, DRV_ETHPHY_RESULT res)
{
    DRV_ETHPHY_NEGOTIATION_RESULT* pNegResult = (DRV_ETHPHY_NEGOTIATION_RESULT*)hClientObj->operParam;
   15352:	6b22      	ldr	r2, [r4, #48]	; 0x30

    if(pNegResult)
   15354:	b112      	cbz	r2, 1535c <_DRV_ETHPHY_NegResultPhase_ANAD+0xb8>
    {
        pNegResult->linkStatus = linkStatus;
   15356:	8010      	strh	r0, [r2, #0]
        pNegResult->linkFlags = openFlags;
   15358:	8053      	strh	r3, [r2, #2]
        pNegResult->pauseType = pauseType;
   1535a:	7111      	strb	r1, [r2, #4]
    }

    _DRV_PHY_SetOperDoneResult(hClientObj, res);
   1535c:	2100      	movs	r1, #0
   1535e:	4620      	mov	r0, r4
   15360:	f00a fc30 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
}
   15364:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        oFlags = (TCPIP_ETH_OPEN_10 | TCPIP_ETH_OPEN_FDUPLEX);
   15366:	2312      	movs	r3, #18
   15368:	e7e6      	b.n	15338 <_DRV_ETHPHY_NegResultPhase_ANAD+0x94>
    lcl_Pause  = (hClientObj->hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_PAUSE) ? 1 : 0;
   1536a:	f007 0501 	and.w	r5, r7, #1
        oFlags = (TCPIP_ETH_OPEN_100|TCPIP_ETH_OPEN_FDUPLEX);
   1536e:	230a      	movs	r3, #10
    lcl_Pause  = (hClientObj->hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_PAUSE) ? 1 : 0;
   15370:	2600      	movs	r6, #0
        if(lp_Pause & (lcl_Pause | (lcl_AsmDir & lp_AsmDir)))
   15372:	4632      	mov	r2, r6
   15374:	e7e8      	b.n	15348 <_DRV_ETHPHY_NegResultPhase_ANAD+0xa4>

Disassembly of section .text.DRV_ETHPHY_Detect%321:

00015376 <DRV_ETHPHY_Detect>:
{
   15376:	b5f0      	push	{r4, r5, r6, r7, lr}
   15378:	b087      	sub	sp, #28
   1537a:	4606      	mov	r6, r0
   1537c:	460c      	mov	r4, r1
    uint16_t registerValue = 0;
   1537e:	2100      	movs	r1, #0
   15380:	f8ad 1016 	strh.w	r1, [sp, #22]
    LAN867X_REG_OBJ clientObj = {0};
   15384:	9100      	str	r1, [sp, #0]
   15386:	9101      	str	r1, [sp, #4]
    clientObj.miimBase = ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->pMiimBase;
   15388:	6923      	ldr	r3, [r4, #16]
   1538a:	9303      	str	r3, [sp, #12]
    clientObj.miimHandle = ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->miimHandle;
   1538c:	6963      	ldr	r3, [r4, #20]
   1538e:	9302      	str	r3, [sp, #8]
    clientObj.miimOpHandle = &((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->miimOpHandle;
   15390:	f104 0318 	add.w	r3, r4, #24
   15394:	9304      	str	r3, [sp, #16]
    pBaseObj->DRV_ETHPHY_PhyAddressGet(hClientObj, DRV_ETHPHY_INF_IDX_ALL_EXTERNAL,
   15396:	6a83      	ldr	r3, [r0, #40]	; 0x28
   15398:	466a      	mov	r2, sp
   1539a:	4620      	mov	r0, r4
   1539c:	4798      	blx	r3
    pBaseObj->DRV_ETHPHY_VendorDataGet(hClientObj, &clientObj.vendorData);
   1539e:	6cb3      	ldr	r3, [r6, #72]	; 0x48
   153a0:	a901      	add	r1, sp, #4
   153a2:	4620      	mov	r0, r4
   153a4:	4798      	blx	r3
    state = R2F(clientObj.vendorData, VENDOR_STATE);
   153a6:	f89d 5006 	ldrb.w	r5, [sp, #6]
    switch (state) {
   153aa:	b195      	cbz	r5, 153d2 <DRV_ETHPHY_Detect+0x5c>
   153ac:	2d01      	cmp	r5, #1
   153ae:	d024      	beq.n	153fa <DRV_ETHPHY_Detect+0x84>
        ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->operRes = DRV_ETHPHY_RES_OK;
   153b0:	2700      	movs	r7, #0
   153b2:	f884 702c 	strb.w	r7, [r4, #44]	; 0x2c
        ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->miimOpHandle = 0;
   153b6:	61a7      	str	r7, [r4, #24]
        ((DRV_ETHPHY_CLIENT_OBJ *)hClientObj)->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
   153b8:	86a7      	strh	r7, [r4, #52]	; 0x34
    clientObj.vendorData = F2R(state, VENDOR_STATE, clientObj.vendorData);
   153ba:	9901      	ldr	r1, [sp, #4]
   153bc:	f421 017f 	bic.w	r1, r1, #16711680	; 0xff0000
   153c0:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
   153c4:	9101      	str	r1, [sp, #4]
    pBaseObj->DRV_ETHPHY_VendorDataSet(hClientObj, clientObj.vendorData);
   153c6:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
   153c8:	4620      	mov	r0, r4
   153ca:	4798      	blx	r3
}
   153cc:	4638      	mov	r0, r7
   153ce:	b007      	add	sp, #28
   153d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        miimRes = Lan867x_Read_Register(&clientObj, PHY_REG_PHYID1, &registerValue);
   153d2:	f10d 0216 	add.w	r2, sp, #22
   153d6:	2102      	movs	r1, #2
   153d8:	4668      	mov	r0, sp
   153da:	f008 fcf4 	bl	1ddc6 <Lan867x_Read_Register>
        if (miimRes < 0) {
   153de:	2800      	cmp	r0, #0
   153e0:	db21      	blt.n	15426 <DRV_ETHPHY_Detect+0xb0>
        } else if (miimRes != DRV_MIIM_RES_OK) {
   153e2:	bb18      	cbnz	r0, 1542c <DRV_ETHPHY_Detect+0xb6>
            if (registerValue != (uint16_t)0x07) {
   153e4:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   153e8:	2b07      	cmp	r3, #7
   153ea:	d121      	bne.n	15430 <DRV_ETHPHY_Detect+0xba>
                    F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj.vendorData);
   153ec:	9b01      	ldr	r3, [sp, #4]
   153ee:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
                clientObj.vendorData =
   153f2:	9301      	str	r3, [sp, #4]
                res = DRV_ETHPHY_RES_PENDING;
   153f4:	2701      	movs	r7, #1
                ++state;
   153f6:	463d      	mov	r5, r7
   153f8:	e7df      	b.n	153ba <DRV_ETHPHY_Detect+0x44>
        miimRes = Lan867x_Read_Register(&clientObj, PHY_REG_PHYID2, &registerValue);
   153fa:	f10d 0216 	add.w	r2, sp, #22
   153fe:	2103      	movs	r1, #3
   15400:	4668      	mov	r0, sp
   15402:	f008 fce0 	bl	1ddc6 <Lan867x_Read_Register>
        if (miimRes < 0) {
   15406:	2800      	cmp	r0, #0
   15408:	db15      	blt.n	15436 <DRV_ETHPHY_Detect+0xc0>
        } else if (miimRes != DRV_MIIM_RES_OK) {
   1540a:	b9b8      	cbnz	r0, 1543c <DRV_ETHPHY_Detect+0xc6>
            if (registerValue != (uint16_t)0xC162) {
   1540c:	f8bd 2016 	ldrh.w	r2, [sp, #22]
   15410:	f24c 1362 	movw	r3, #49506	; 0xc162
   15414:	429a      	cmp	r2, r3
   15416:	d113      	bne.n	15440 <DRV_ETHPHY_Detect+0xca>
                    F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj.vendorData);
   15418:	9b01      	ldr	r3, [sp, #4]
   1541a:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
                clientObj.vendorData =
   1541e:	9301      	str	r3, [sp, #4]
                res = DRV_ETHPHY_RES_PENDING;
   15420:	2701      	movs	r7, #1
                ++state;
   15422:	2502      	movs	r5, #2
   15424:	e7c9      	b.n	153ba <DRV_ETHPHY_Detect+0x44>
            res = DRV_ETHPHY_RES_MIIM_ERR;
   15426:	f06f 070c 	mvn.w	r7, #12
   1542a:	e7c6      	b.n	153ba <DRV_ETHPHY_Detect+0x44>
            res = DRV_ETHPHY_RES_PENDING;
   1542c:	2701      	movs	r7, #1
   1542e:	e7c4      	b.n	153ba <DRV_ETHPHY_Detect+0x44>
                res = DRV_ETHPHY_RES_CPBL_ERR;
   15430:	f06f 0702 	mvn.w	r7, #2
   15434:	e7c1      	b.n	153ba <DRV_ETHPHY_Detect+0x44>
            res = DRV_ETHPHY_RES_MIIM_ERR;
   15436:	f06f 070c 	mvn.w	r7, #12
   1543a:	e7be      	b.n	153ba <DRV_ETHPHY_Detect+0x44>
            res = DRV_ETHPHY_RES_PENDING;
   1543c:	2701      	movs	r7, #1
   1543e:	e7bc      	b.n	153ba <DRV_ETHPHY_Detect+0x44>
                res = DRV_ETHPHY_RES_CPBL_ERR;
   15440:	f06f 0702 	mvn.w	r7, #2
   15444:	e7b9      	b.n	153ba <DRV_ETHPHY_Detect+0x44>

Disassembly of section .text.DRV_GMAC_PacketTx%322:

00015448 <DRV_GMAC_PacketTx>:
{
   15448:	b538      	push	{r3, r4, r5, lr}
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1544a:	4b2e      	ldr	r3, [pc, #184]	; (15504 <DRV_GMAC_PacketTx+0xbc>)
   1544c:	4283      	cmp	r3, r0
   1544e:	d141      	bne.n	154d4 <DRV_GMAC_PacketTx+0x8c>
   15450:	460c      	mov	r4, r1
    if(pMACDrv == 0)
   15452:	2800      	cmp	r0, #0
   15454:	d041      	beq.n	154da <DRV_GMAC_PacketTx+0x92>
    if ((ptrPacket->pktPriority) >= DRV_GMAC_NUMBER_OF_QUEUES)
   15456:	f891 302d 	ldrb.w	r3, [r1, #45]	; 0x2d
   1545a:	2b00      	cmp	r3, #0
   1545c:	d140      	bne.n	154e0 <DRV_GMAC_PacketTx+0x98>
	queueIdx = (GMAC_QUE_LIST)(pMACDrv->sGmacData.gmacConfig.txPrioNumToQueIndx[ptrPacket->pktPriority]);
   1545e:	4b29      	ldr	r3, [pc, #164]	; (15504 <DRV_GMAC_PacketTx+0xbc>)
    else if(queueIdx >= DRV_GMAC_NUMBER_OF_QUEUES)
   15460:	f893 30e3 	ldrb.w	r3, [r3, #227]	; 0xe3
   15464:	3b01      	subs	r3, #1
   15466:	b2db      	uxtb	r3, r3
   15468:	2bfd      	cmp	r3, #253	; 0xfd
   1546a:	d93c      	bls.n	154e6 <DRV_GMAC_PacketTx+0x9e>
	if(pMACDrv->sGmacData._synchF != 0)
   1546c:	4b25      	ldr	r3, [pc, #148]	; (15504 <DRV_GMAC_PacketTx+0xbc>)
   1546e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   15470:	2b00      	cmp	r3, #0
   15472:	d040      	beq.n	154f6 <DRV_GMAC_PacketTx+0xae>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_LOCK);
   15474:	2103      	movs	r1, #3
   15476:	4824      	ldr	r0, [pc, #144]	; (15508 <DRV_GMAC_PacketTx+0xc0>)
   15478:	4798      	blx	r3
        if(pSeg == 0)
   1547a:	6923      	ldr	r3, [r4, #16]
   1547c:	b16b      	cbz	r3, 1549a <DRV_GMAC_PacketTx+0x52>
            DRV_PIC32CGMAC_SingleListTailAdd(&pMACDrv->sGmacData.gmac_queue[queueIdx]._TxQueue, (DRV_PIC32CGMAC_SGL_LIST_NODE*)ptrPacket);
   1547e:	4d23      	ldr	r5, [pc, #140]	; (1550c <DRV_GMAC_PacketTx+0xc4>)
   15480:	4621      	mov	r1, r4
   15482:	4628      	mov	r0, r5
   15484:	f00b fe24 	bl	210d0 <DRV_PIC32CGMAC_SingleListTailAdd>
            ptrPacket->pktFlags |= TCPIP_MAC_PKT_FLAG_QUEUED;
   15488:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   1548a:	f043 0308 	orr.w	r3, r3, #8
   1548e:	8463      	strh	r3, [r4, #34]	; 0x22
            ptrPacket = ptrPacket->next;
   15490:	6824      	ldr	r4, [r4, #0]
	while(ptrPacket)
   15492:	b15c      	cbz	r4, 154ac <DRV_GMAC_PacketTx+0x64>
        if(pSeg == 0)
   15494:	6923      	ldr	r3, [r4, #16]
   15496:	2b00      	cmp	r3, #0
   15498:	d1f2      	bne.n	15480 <DRV_GMAC_PacketTx+0x38>
	if(pMACDrv->sGmacData._synchF != 0)
   1549a:	4b1a      	ldr	r3, [pc, #104]	; (15504 <DRV_GMAC_PacketTx+0xbc>)
   1549c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   1549e:	b32b      	cbz	r3, 154ec <DRV_GMAC_PacketTx+0xa4>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_UNLOCK);
   154a0:	2104      	movs	r1, #4
   154a2:	4819      	ldr	r0, [pc, #100]	; (15508 <DRV_GMAC_PacketTx+0xc0>)
   154a4:	4798      	blx	r3
            return TCPIP_MAC_RES_PACKET_ERR;
   154a6:	f06f 0009 	mvn.w	r0, #9
   154aa:	e015      	b.n	154d8 <DRV_GMAC_PacketTx+0x90>
	_MacTxPendingPackets(pMACDrv,queueIdx);
   154ac:	4c15      	ldr	r4, [pc, #84]	; (15504 <DRV_GMAC_PacketTx+0xbc>)
   154ae:	2100      	movs	r1, #0
   154b0:	4620      	mov	r0, r4
   154b2:	f004 fd77 	bl	19fa4 <_MacTxPendingPackets>
    GMAC_REGS->GMAC_TSR = GMAC_TSR_TXCOMP_Msk;
   154b6:	4b16      	ldr	r3, [pc, #88]	; (15510 <DRV_GMAC_PacketTx+0xc8>)
   154b8:	2220      	movs	r2, #32
   154ba:	615a      	str	r2, [r3, #20]
    DRV_PIC32CGMAC_LibTxAckPacket(pMACDrv,queueIdx);
   154bc:	2100      	movs	r1, #0
   154be:	4620      	mov	r0, r4
   154c0:	f7fb fd5e 	bl	10f80 <DRV_PIC32CGMAC_LibTxAckPacket>
	if(pMACDrv->sGmacData._synchF != 0)
   154c4:	6b23      	ldr	r3, [r4, #48]	; 0x30
   154c6:	b1a3      	cbz	r3, 154f2 <DRV_GMAC_PacketTx+0xaa>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_UNLOCK);
   154c8:	2104      	movs	r1, #4
   154ca:	f104 0060 	add.w	r0, r4, #96	; 0x60
   154ce:	4798      	blx	r3
	return TCPIP_MAC_RES_OK;
   154d0:	2000      	movs	r0, #0
   154d2:	e001      	b.n	154d8 <DRV_GMAC_PacketTx+0x90>
        return TCPIP_MAC_RES_OP_ERR;
   154d4:	f06f 0005 	mvn.w	r0, #5
}
   154d8:	bd38      	pop	{r3, r4, r5, pc}
        return TCPIP_MAC_RES_OP_ERR;
   154da:	f06f 0005 	mvn.w	r0, #5
   154de:	e7fb      	b.n	154d8 <DRV_GMAC_PacketTx+0x90>
        return TCPIP_MAC_RES_PACKET_ERR; 	        
   154e0:	f06f 0009 	mvn.w	r0, #9
   154e4:	e7f8      	b.n	154d8 <DRV_GMAC_PacketTx+0x90>
        return TCPIP_MAC_RES_PACKET_ERR; 
   154e6:	f06f 0009 	mvn.w	r0, #9
   154ea:	e7f5      	b.n	154d8 <DRV_GMAC_PacketTx+0x90>
            return TCPIP_MAC_RES_PACKET_ERR;
   154ec:	f06f 0009 	mvn.w	r0, #9
   154f0:	e7f2      	b.n	154d8 <DRV_GMAC_PacketTx+0x90>
	return TCPIP_MAC_RES_OK;
   154f2:	2000      	movs	r0, #0
   154f4:	e7f0      	b.n	154d8 <DRV_GMAC_PacketTx+0x90>
        if(pSeg == 0)
   154f6:	690b      	ldr	r3, [r1, #16]
   154f8:	2b00      	cmp	r3, #0
   154fa:	d1c0      	bne.n	1547e <DRV_GMAC_PacketTx+0x36>
            return TCPIP_MAC_RES_PACKET_ERR;
   154fc:	f06f 0009 	mvn.w	r0, #9
   15500:	e7ea      	b.n	154d8 <DRV_GMAC_PacketTx+0x90>
   15502:	bf00      	nop
   15504:	2000dab8 	.word	0x2000dab8
   15508:	2000db18 	.word	0x2000db18
   1550c:	2000db5c 	.word	0x2000db5c
   15510:	42000800 	.word	0x42000800

Disassembly of section .text.TCPIP_TCP_ArrayGet%323:

00015514 <TCPIP_TCP_ArrayGet>:
{
   15514:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if(len == 0 || (pSkt= _TcpSocketChk(hTCP)) == 0 || (wGetReadyCount = _TCPIsGetReady(pSkt)) == 0)
   15518:	4614      	mov	r4, r2
   1551a:	2a00      	cmp	r2, #0
   1551c:	d05a      	beq.n	155d4 <TCPIP_TCP_ArrayGet+0xc0>
   1551e:	4688      	mov	r8, r1
   15520:	f00a fbc8 	bl	1fcb4 <_TcpSocketChk>
   15524:	4605      	mov	r5, r0
   15526:	2800      	cmp	r0, #0
   15528:	d051      	beq.n	155ce <TCPIP_TCP_ArrayGet+0xba>
   1552a:	f00b fb60 	bl	20bee <_TCPIsGetReady>
   1552e:	4607      	mov	r7, r0
   15530:	2800      	cmp	r0, #0
   15532:	d04e      	beq.n	155d2 <TCPIP_TCP_ArrayGet+0xbe>
	if(len > wGetReadyCount)
   15534:	4284      	cmp	r4, r0
   15536:	bf28      	it	cs
   15538:	4604      	movcs	r4, r0
   1553a:	b2a4      	uxth	r4, r4
	if(pSkt->rxTail + len > pSkt->rxEnd)
   1553c:	6a29      	ldr	r1, [r5, #32]
   1553e:	69ae      	ldr	r6, [r5, #24]
   15540:	190b      	adds	r3, r1, r4
   15542:	429e      	cmp	r6, r3
   15544:	d229      	bcs.n	1559a <TCPIP_TCP_ArrayGet+0x86>
		RightLen = pSkt->rxEnd - pSkt->rxTail + 1;
   15546:	1a76      	subs	r6, r6, r1
   15548:	3601      	adds	r6, #1
   1554a:	b2b6      	uxth	r6, r6
		if(buffer)
   1554c:	f1b8 0f00 	cmp.w	r8, #0
   15550:	d004      	beq.n	1555c <TCPIP_TCP_ArrayGet+0x48>
			memcpy(buffer, (uint8_t*)pSkt->rxTail, RightLen);
   15552:	4632      	mov	r2, r6
   15554:	4640      	mov	r0, r8
   15556:	f00b fd83 	bl	21060 <memcpy>
			buffer += RightLen;
   1555a:	44b0      	add	r8, r6
		len -= RightLen;
   1555c:	1ba4      	subs	r4, r4, r6
   1555e:	b2a4      	uxth	r4, r4
		pSkt->rxTail = pSkt->rxStart;
   15560:	696b      	ldr	r3, [r5, #20]
   15562:	622b      	str	r3, [r5, #32]
	if(buffer)
   15564:	f1b8 0f00 	cmp.w	r8, #0
   15568:	d004      	beq.n	15574 <TCPIP_TCP_ArrayGet+0x60>
		memcpy(buffer, (uint8_t*)pSkt->rxTail, len);
   1556a:	4622      	mov	r2, r4
   1556c:	6a29      	ldr	r1, [r5, #32]
   1556e:	4640      	mov	r0, r8
   15570:	f00b fd76 	bl	21060 <memcpy>
	pSkt->rxTail += len;
   15574:	6a2b      	ldr	r3, [r5, #32]
   15576:	4423      	add	r3, r4
   15578:	622b      	str	r3, [r5, #32]
	len += RightLen;
   1557a:	4434      	add	r4, r6
   1557c:	b2a4      	uxth	r4, r4
    if(!_TCPSendWinIncUpdate(pSkt))
   1557e:	4628      	mov	r0, r5
   15580:	f007 faae 	bl	1cae0 <_TCPSendWinIncUpdate>
   15584:	bb30      	cbnz	r0, 155d4 <TCPIP_TCP_ArrayGet+0xc0>
        if(wGetReadyCount - len <= len)
   15586:	1b3f      	subs	r7, r7, r4
   15588:	42bc      	cmp	r4, r7
   1558a:	db08      	blt.n	1559e <TCPIP_TCP_ArrayGet+0x8a>
            pSkt->Flags.bTXASAPWithoutTimerReset = 1;
   1558c:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
   15590:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   15594:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
   15598:	e01c      	b.n	155d4 <TCPIP_TCP_ArrayGet+0xc0>
	uint16_t RightLen = 0;
   1559a:	2600      	movs	r6, #0
   1559c:	e7e2      	b.n	15564 <TCPIP_TCP_ArrayGet+0x50>
        else if(!pSkt->Flags.bTimer2Enabled)
   1559e:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
   155a2:	f013 0f04 	tst.w	r3, #4
   155a6:	d115      	bne.n	155d4 <TCPIP_TCP_ArrayGet+0xc0>
            pSkt->Flags.bTimer2Enabled = true;
   155a8:	f043 0304 	orr.w	r3, r3, #4
   155ac:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
            pSkt->eventTime2 = SYS_TMR_TickCountGet() + (TCPIP_TCP_WINDOW_UPDATE_TIMEOUT_VAL * SYS_TMR_TickCounterFrequencyGet())/1000;
   155b0:	f00a fcfc 	bl	1ffac <SYS_TMR_TickCountGet>
   155b4:	4606      	mov	r6, r0
   155b6:	f00a fd21 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
   155ba:	23c8      	movs	r3, #200	; 0xc8
   155bc:	fb03 f300 	mul.w	r3, r3, r0
   155c0:	4806      	ldr	r0, [pc, #24]	; (155dc <TCPIP_TCP_ArrayGet+0xc8>)
   155c2:	fba0 2303 	umull	r2, r3, r0, r3
   155c6:	eb06 1393 	add.w	r3, r6, r3, lsr #6
   155ca:	62ab      	str	r3, [r5, #40]	; 0x28
   155cc:	e002      	b.n	155d4 <TCPIP_TCP_ArrayGet+0xc0>
        return 0;
   155ce:	2400      	movs	r4, #0
   155d0:	e000      	b.n	155d4 <TCPIP_TCP_ArrayGet+0xc0>
   155d2:	4604      	mov	r4, r0
}
   155d4:	4620      	mov	r0, r4
   155d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   155da:	bf00      	nop
   155dc:	10624dd3 	.word	0x10624dd3

Disassembly of section .text.TCPIP_HEAP_CreateInternal%324:

000155e0 <TCPIP_HEAP_CreateInternal>:
{
   155e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   155e4:	4688      	mov	r8, r1
        if( pHeapConfig == 0)
   155e6:	2800      	cmp	r0, #0
   155e8:	d04b      	beq.n	15682 <TCPIP_HEAP_CreateInternal+0xa2>
   155ea:	4606      	mov	r6, r0
        heapBufferSize = pHeapConfig->heapSize;
   155ec:	6904      	ldr	r4, [r0, #16]
        allocatedHeapBuffer = (uint8_t*)(*pHeapConfig->malloc_fnc)(heapBufferSize);
   155ee:	6843      	ldr	r3, [r0, #4]
   155f0:	4620      	mov	r0, r4
   155f2:	4798      	blx	r3
        if(allocatedHeapBuffer == 0)
   155f4:	4607      	mov	r7, r0
   155f6:	2800      	cmp	r0, #0
   155f8:	d047      	beq.n	1568a <TCPIP_HEAP_CreateInternal+0xaa>
        alignBuffer = ((uintptr_t)allocatedHeapBuffer + sizeof(_heap_Align)-1 ) & ~(sizeof(_heap_Align)-1);
   155fa:	300f      	adds	r0, #15
   155fc:	f020 000f 	bic.w	r0, r0, #15
        heapBufferSize -= (uint8_t*)alignBuffer - allocatedHeapBuffer ;
   15600:	1bc1      	subs	r1, r0, r7
   15602:	1a61      	subs	r1, r4, r1
        heapBufferSize &= ~(sizeof(_heap_Align)-1) ;
   15604:	f021 010f 	bic.w	r1, r1, #15
        heapSize = heapBufferSize - headerSize;
   15608:	f1a1 0950 	sub.w	r9, r1, #80	; 0x50
        if(heapUnits < _TCPIP_HEAP_MIN_BLKS_)
   1560c:	f5b9 6f80 	cmp.w	r9, #1024	; 0x400
   15610:	d33f      	bcc.n	15692 <TCPIP_HEAP_CreateInternal+0xb2>
        heapUnits = heapSize / sizeof(_headNode);           // adjust to multiple of heads
   15612:	ea4f 1919 	mov.w	r9, r9, lsr #4
            alignHeapBuffer = (uint8_t*)_TCPIP_HEAP_BufferMapNonCached(alignHeapBuffer, heapBufferSize);
   15616:	f7fd f82c 	bl	12672 <_TCPIP_HEAP_BufferMapNonCached>
   1561a:	4604      	mov	r4, r0
        heapStart = alignHeapBuffer + headerSize; 
   1561c:	f100 0e50 	add.w	lr, r0, #80	; 0x50
        hInst->heapObj = _tcpip_heap_object;
   15620:	4605      	mov	r5, r0
   15622:	f8df c084 	ldr.w	ip, [pc, #132]	; 156a8 <TCPIP_HEAP_CreateInternal+0xc8>
   15626:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   1562a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   1562c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   15630:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   15632:	f8dc 3000 	ldr.w	r3, [ip]
   15636:	602b      	str	r3, [r5, #0]
        hDcpt->_heapHead = (_headNode*)heapStart;
   15638:	f8c4 e024 	str.w	lr, [r4, #36]	; 0x24
        hDcpt->_heapHead->units = heapUnits;
   1563c:	f8c4 9054 	str.w	r9, [r4, #84]	; 0x54
        hDcpt->_heapHead->next = 0;
   15640:	2100      	movs	r1, #0
   15642:	6521      	str	r1, [r4, #80]	; 0x50
        hDcpt->_heapTail = hDcpt->_heapHead;
   15644:	f8c4 e028 	str.w	lr, [r4, #40]	; 0x28
        hDcpt->_heapUnits = heapUnits;
   15648:	f8c4 902c 	str.w	r9, [r4, #44]	; 0x2c
        hDcpt->_heapAllocatedUnits = 0;
   1564c:	6321      	str	r1, [r4, #48]	; 0x30
        hDcpt->_heapWatermark = 0;
   1564e:	6361      	str	r1, [r4, #52]	; 0x34
        hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_OK;
   15650:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
        hDcpt->_heapFlags = pHeapConfig->heapFlags;
   15654:	7873      	ldrb	r3, [r6, #1]
   15656:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
        hDcpt->allocatedBuffer = allocatedHeapBuffer;
   1565a:	63e7      	str	r7, [r4, #60]	; 0x3c
        hDcpt->free_fnc = pHeapConfig->free_fnc;
   1565c:	68f3      	ldr	r3, [r6, #12]
   1565e:	6423      	str	r3, [r4, #64]	; 0x40
        if(OSAL_SEM_Create(&hDcpt->_heapSemaphore, OSAL_SEM_TYPE_BINARY, 1, 1) != OSAL_RESULT_TRUE)
   15660:	2301      	movs	r3, #1
   15662:	461a      	mov	r2, r3
   15664:	f104 0044 	add.w	r0, r4, #68	; 0x44
   15668:	f006 fa6c 	bl	1bb44 <OSAL_SEM_Create>
   1566c:	2801      	cmp	r0, #1
   1566e:	d101      	bne.n	15674 <TCPIP_HEAP_CreateInternal+0x94>
        res = TCPIP_STACK_HEAP_RES_OK;
   15670:	2300      	movs	r3, #0
   15672:	e011      	b.n	15698 <TCPIP_HEAP_CreateInternal+0xb8>
            (*pHeapConfig->free_fnc)(allocatedHeapBuffer);
   15674:	68f3      	ldr	r3, [r6, #12]
   15676:	4638      	mov	r0, r7
   15678:	4798      	blx	r3
            res = TCPIP_STACK_HEAP_RES_SYNCH_ERR;
   1567a:	f06f 0302 	mvn.w	r3, #2
            hInst = 0;
   1567e:	2400      	movs	r4, #0
            break;
   15680:	e00a      	b.n	15698 <TCPIP_HEAP_CreateInternal+0xb8>
        hInst = 0;
   15682:	4604      	mov	r4, r0
            res = TCPIP_STACK_HEAP_RES_INIT_ERR;
   15684:	f04f 33ff 	mov.w	r3, #4294967295
   15688:	e006      	b.n	15698 <TCPIP_HEAP_CreateInternal+0xb8>
        hInst = 0;
   1568a:	4604      	mov	r4, r0
            res = TCPIP_STACK_HEAP_RES_CREATE_ERR;
   1568c:	f06f 0301 	mvn.w	r3, #1
   15690:	e002      	b.n	15698 <TCPIP_HEAP_CreateInternal+0xb8>
            res = TCPIP_STACK_HEAP_RES_BUFF_SIZE_ERR;
   15692:	f06f 0303 	mvn.w	r3, #3
        hInst = 0;
   15696:	2400      	movs	r4, #0
    if(pRes)
   15698:	f1b8 0f00 	cmp.w	r8, #0
   1569c:	d001      	beq.n	156a2 <TCPIP_HEAP_CreateInternal+0xc2>
        *pRes = res;
   1569e:	f888 3000 	strb.w	r3, [r8]
}
   156a2:	4620      	mov	r0, r4
   156a4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   156a8:	00020368 	.word	0x00020368

Disassembly of section .text.PORT_Initialize%325:

000156ac <PORT_Initialize>:
  Remarks:
    Refer plib_port.h file for more information.
*/

void PORT_Initialize(void)
{
   156ac:	b430      	push	{r4, r5}
   /************************** GROUP 0 Initialization *************************/
   PORT_REGS->GROUP[0].PORT_OUT = 0x300;
   156ae:	4b30      	ldr	r3, [pc, #192]	; (15770 <PORT_Initialize+0xc4>)
   156b0:	f44f 7240 	mov.w	r2, #768	; 0x300
   156b4:	611a      	str	r2, [r3, #16]
   PORT_REGS->GROUP[0].PORT_PINCFG[8] = 0x6;
   156b6:	2406      	movs	r4, #6
   156b8:	f883 4048 	strb.w	r4, [r3, #72]	; 0x48
   PORT_REGS->GROUP[0].PORT_PINCFG[9] = 0x6;
   156bc:	f883 4049 	strb.w	r4, [r3, #73]	; 0x49
   PORT_REGS->GROUP[0].PORT_PINCFG[12] = 0x1;
   156c0:	2201      	movs	r2, #1
   156c2:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
   PORT_REGS->GROUP[0].PORT_PINCFG[13] = 0x1;
   156c6:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
   PORT_REGS->GROUP[0].PORT_PINCFG[14] = 0x1;
   156ca:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
   PORT_REGS->GROUP[0].PORT_PINCFG[15] = 0x1;
   156ce:	f883 204f 	strb.w	r2, [r3, #79]	; 0x4f
   PORT_REGS->GROUP[0].PORT_PINCFG[17] = 0x1;
   156d2:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
   PORT_REGS->GROUP[0].PORT_PINCFG[18] = 0x1;
   156d6:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
   PORT_REGS->GROUP[0].PORT_PINCFG[19] = 0x1;
   156da:	f883 2053 	strb.w	r2, [r3, #83]	; 0x53

   PORT_REGS->GROUP[0].PORT_PMUX[6] = 0xbb;
   156de:	20bb      	movs	r0, #187	; 0xbb
   156e0:	f883 0036 	strb.w	r0, [r3, #54]	; 0x36
   PORT_REGS->GROUP[0].PORT_PMUX[7] = 0xbb;
   156e4:	f883 0037 	strb.w	r0, [r3, #55]	; 0x37
   PORT_REGS->GROUP[0].PORT_PMUX[8] = 0xb0;
   156e8:	21b0      	movs	r1, #176	; 0xb0
   156ea:	f883 1038 	strb.w	r1, [r3, #56]	; 0x38
   PORT_REGS->GROUP[0].PORT_PMUX[9] = 0xbb;
   156ee:	f883 0039 	strb.w	r0, [r3, #57]	; 0x39

   /************************** GROUP 1 Initialization *************************/
   PORT_REGS->GROUP[1].PORT_DIR = 0x1000c000;
   156f2:	4920      	ldr	r1, [pc, #128]	; (15774 <PORT_Initialize+0xc8>)
   156f4:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
   PORT_REGS->GROUP[1].PORT_PINCFG[14] = 0x0;
   156f8:	2100      	movs	r1, #0
   156fa:	f883 10ce 	strb.w	r1, [r3, #206]	; 0xce
   PORT_REGS->GROUP[1].PORT_PINCFG[15] = 0x0;
   156fe:	f883 10cf 	strb.w	r1, [r3, #207]	; 0xcf
   PORT_REGS->GROUP[1].PORT_PINCFG[24] = 0x1;
   15702:	f883 20d8 	strb.w	r2, [r3, #216]	; 0xd8
   PORT_REGS->GROUP[1].PORT_PINCFG[25] = 0x1;
   15706:	f883 20d9 	strb.w	r2, [r3, #217]	; 0xd9
   PORT_REGS->GROUP[1].PORT_PINCFG[28] = 0x0;
   1570a:	f883 10dc 	strb.w	r1, [r3, #220]	; 0xdc

   PORT_REGS->GROUP[1].PORT_PMUX[12] = 0x22;
   1570e:	2522      	movs	r5, #34	; 0x22
   15710:	f883 50bc 	strb.w	r5, [r3, #188]	; 0xbc

   /************************** GROUP 2 Initialization *************************/
   PORT_REGS->GROUP[2].PORT_DIR = 0x1000000;
   15714:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000
   15718:	f8c3 5100 	str.w	r5, [r3, #256]	; 0x100
   PORT_REGS->GROUP[2].PORT_OUT = 0x1000000;
   1571c:	f8c3 5110 	str.w	r5, [r3, #272]	; 0x110
   PORT_REGS->GROUP[2].PORT_PINCFG[20] = 0x1;
   15720:	f883 2154 	strb.w	r2, [r3, #340]	; 0x154
   PORT_REGS->GROUP[2].PORT_PINCFG[22] = 0x1;
   15724:	f883 2156 	strb.w	r2, [r3, #342]	; 0x156
   PORT_REGS->GROUP[2].PORT_PINCFG[23] = 0x1;
   15728:	f883 2157 	strb.w	r2, [r3, #343]	; 0x157
   PORT_REGS->GROUP[2].PORT_PINCFG[24] = 0x0;
   1572c:	f883 1158 	strb.w	r1, [r3, #344]	; 0x158
   PORT_REGS->GROUP[2].PORT_PINCFG[27] = 0x1;
   15730:	f883 215b 	strb.w	r2, [r3, #347]	; 0x15b
   PORT_REGS->GROUP[2].PORT_PINCFG[28] = 0x1;
   15734:	f883 215c 	strb.w	r2, [r3, #348]	; 0x15c

   PORT_REGS->GROUP[2].PORT_PMUX[10] = 0xb;
   15738:	220b      	movs	r2, #11
   1573a:	f883 213a 	strb.w	r2, [r3, #314]	; 0x13a
   PORT_REGS->GROUP[2].PORT_PMUX[11] = 0xbb;
   1573e:	f883 013b 	strb.w	r0, [r3, #315]	; 0x13b
   PORT_REGS->GROUP[2].PORT_PMUX[13] = 0x20;
   15742:	2220      	movs	r2, #32
   15744:	f883 213d 	strb.w	r2, [r3, #317]	; 0x13d
   PORT_REGS->GROUP[2].PORT_PMUX[14] = 0x2;
   15748:	2202      	movs	r2, #2
   1574a:	f883 213e 	strb.w	r2, [r3, #318]	; 0x13e

   /************************** GROUP 3 Initialization *************************/
   PORT_REGS->GROUP[3].PORT_DIR = 0x1400;
   1574e:	f44f 52a0 	mov.w	r2, #5120	; 0x1400
   15752:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
   PORT_REGS->GROUP[3].PORT_OUT = 0x800;
   15756:	f44f 6200 	mov.w	r2, #2048	; 0x800
   1575a:	f8c3 2190 	str.w	r2, [r3, #400]	; 0x190
   PORT_REGS->GROUP[3].PORT_PINCFG[10] = 0x0;
   1575e:	f883 11ca 	strb.w	r1, [r3, #458]	; 0x1ca
   PORT_REGS->GROUP[3].PORT_PINCFG[11] = 0x6;
   15762:	f883 41cb 	strb.w	r4, [r3, #459]	; 0x1cb
   PORT_REGS->GROUP[3].PORT_PINCFG[12] = 0x0;
   15766:	f883 11cc 	strb.w	r1, [r3, #460]	; 0x1cc


}
   1576a:	bc30      	pop	{r4, r5}
   1576c:	4770      	bx	lr
   1576e:	bf00      	nop
   15770:	41008000 	.word	0x41008000
   15774:	1000c000 	.word	0x1000c000

Disassembly of section .text.DRV_PIC32CGMAC_LibRxInit%326:

00015778 <DRV_PIC32CGMAC_LibRxInit>:
{	   
   15778:	b510      	push	{r4, lr}
   1577a:	4604      	mov	r4, r0
}DRV_PIC32CGMAC_SGL_LIST;	// single linked list

//Initialize Single List
static  __inline__ void  __attribute__((always_inline)) DRV_PIC32CGMAC_SingleListInitialize(DRV_PIC32CGMAC_SGL_LIST* pL)
{
    pL->head = pL->tail = 0;
   1577c:	2300      	movs	r3, #0
   1577e:	f8c0 3098 	str.w	r3, [r0, #152]	; 0x98
   15782:	f8c0 3094 	str.w	r3, [r0, #148]	; 0x94
    pL->nNodes = 0;
   15786:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
        pRxPcktAlloc = (*pMACDrv->sGmacData._callocF)(pMACDrv->sGmacData._AllocH,pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt, sizeof(TCPIP_MAC_PACKET *));
   1578a:	69c3      	ldr	r3, [r0, #28]
   1578c:	2204      	movs	r2, #4
   1578e:	f8b0 10be 	ldrh.w	r1, [r0, #190]	; 0xbe
   15792:	6980      	ldr	r0, [r0, #24]
   15794:	4798      	blx	r3
		if(pRxPcktAlloc == NULL)
   15796:	2800      	cmp	r0, #0
   15798:	d04c      	beq.n	15834 <DRV_PIC32CGMAC_LibRxInit+0xbc>
        (pMACDrv->sGmacData.gmac_queue[queue_idx].pRxPckt) = pRxPcktAlloc;
   1579a:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
		for(desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt; desc_idx++)
   1579e:	f8b4 30be 	ldrh.w	r3, [r4, #190]	; 0xbe
   157a2:	2b00      	cmp	r3, #0
   157a4:	d044      	beq.n	15830 <DRV_PIC32CGMAC_LibRxInit+0xb8>
   157a6:	2300      	movs	r3, #0
            pMACDrv->sGmacData.gmac_queue[queue_idx].nRxDescIndex = 0;
   157a8:	461a      	mov	r2, r3
   157aa:	f8a4 20b0 	strh.w	r2, [r4, #176]	; 0xb0
			pMACDrv->sGmacData.gmac_queue[queue_idx].pRxPckt[desc_idx] = 0;
   157ae:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
   157b2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
			pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc[desc_idx].rx_desc_buffaddr.val = 0;
   157b6:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
   157ba:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
			pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc[desc_idx].rx_desc_status.val = 0;
   157be:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
   157c2:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
   157c6:	604a      	str	r2, [r1, #4]
		for(desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt; desc_idx++)
   157c8:	3301      	adds	r3, #1
   157ca:	b2db      	uxtb	r3, r3
   157cc:	f8b4 10be 	ldrh.w	r1, [r4, #190]	; 0xbe
   157d0:	4299      	cmp	r1, r3
   157d2:	d8ea      	bhi.n	157aa <DRV_PIC32CGMAC_LibRxInit+0x32>
		pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc[desc_idx-1].rx_desc_buffaddr.val |= GMAC_RX_WRAP_BIT;
   157d4:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
   157d8:	3b01      	subs	r3, #1
   157da:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
   157de:	f851 2033 	ldr.w	r2, [r1, r3, lsl #3]
   157e2:	f042 0202 	orr.w	r2, r2, #2
   157e6:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
        gmacRes = _AllocateRxPacket(pMACDrv, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDedicatedBuffers, queue_idx, GMAC_RX_STICKY_BUFFERS);	
   157ea:	2301      	movs	r3, #1
   157ec:	2200      	movs	r2, #0
   157ee:	f8b4 10c0 	ldrh.w	r1, [r4, #192]	; 0xc0
   157f2:	4620      	mov	r0, r4
   157f4:	f004 fe40 	bl	1a478 <_AllocateRxPacket>
        if(gmacRes != DRV_PIC32CGMAC_RES_OK)
   157f8:	4603      	mov	r3, r0
   157fa:	b9b8      	cbnz	r0, 1582c <DRV_PIC32CGMAC_LibRxInit+0xb4>
		gmacRes = _AllocateRxPacket(pMACDrv, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxAddlBuffCount, queue_idx, GMAC_RX_DYNAMIC_BUFFERS);	
   157fc:	2300      	movs	r3, #0
   157fe:	461a      	mov	r2, r3
   15800:	f8b4 10c2 	ldrh.w	r1, [r4, #194]	; 0xc2
   15804:	4620      	mov	r0, r4
   15806:	f004 fe37 	bl	1a478 <_AllocateRxPacket>
        if(gmacRes != DRV_PIC32CGMAC_RES_OK)
   1580a:	4603      	mov	r3, r0
   1580c:	b970      	cbnz	r0, 1582c <DRV_PIC32CGMAC_LibRxInit+0xb4>
		gmacRes = DRV_PIC32CGMAC_LibRxBuffersAppend(pMACDrv, queue_idx,0,pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt);		
   1580e:	f8b4 30be 	ldrh.w	r3, [r4, #190]	; 0xbe
   15812:	2200      	movs	r2, #0
   15814:	4611      	mov	r1, r2
   15816:	4620      	mov	r0, r4
   15818:	f7fd fa08 	bl	12c2c <DRV_PIC32CGMAC_LibRxBuffersAppend>
		if(gmacRes != DRV_PIC32CGMAC_RES_OK)
   1581c:	4603      	mov	r3, r0
   1581e:	b928      	cbnz	r0, 1582c <DRV_PIC32CGMAC_LibRxInit+0xb4>
		GMAC_REGS->GMAC_RBQB = GMAC_RBQB_ADDR_Msk & ((uint32_t)pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc);
   15820:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
   15824:	f022 0203 	bic.w	r2, r2, #3
   15828:	4904      	ldr	r1, [pc, #16]	; (1583c <DRV_PIC32CGMAC_LibRxInit+0xc4>)
   1582a:	618a      	str	r2, [r1, #24]
}//DRV_PIC32CGMAC_LibRxInit
   1582c:	4618      	mov	r0, r3
   1582e:	bd10      	pop	{r4, pc}
		for(desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt; desc_idx++)
   15830:	2300      	movs	r3, #0
   15832:	e7cf      	b.n	157d4 <DRV_PIC32CGMAC_LibRxInit+0x5c>
			gmacRes = DRV_PIC32CGMAC_RES_OUT_OF_MEMORY;
   15834:	f04f 33ff 	mov.w	r3, #4294967295
   15838:	e7f8      	b.n	1582c <DRV_PIC32CGMAC_LibRxInit+0xb4>
   1583a:	bf00      	nop
   1583c:	42000800 	.word	0x42000800

Disassembly of section .text._Command_DNSAddressSet%327:

00015840 <_Command_DNSAddressSet>:
{
   15840:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15844:	b082      	sub	sp, #8
   15846:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   15848:	6845      	ldr	r5, [r0, #4]
    if (argc != 4)
   1584a:	2904      	cmp	r1, #4
   1584c:	d010      	beq.n	15870 <_Command_DNSAddressSet+0x30>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: setdns 1/2 <interface> <x.x.x.x> \r\n");
   1584e:	4e28      	ldr	r6, [pc, #160]	; (158f0 <_Command_DNSAddressSet+0xb0>)
   15850:	6803      	ldr	r3, [r0, #0]
   15852:	681b      	ldr	r3, [r3, #0]
   15854:	f606 7104 	addw	r1, r6, #3844	; 0xf04
   15858:	4628      	mov	r0, r5
   1585a:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: setdns 1 eth0 255.255.255.0 \r\n");
   1585c:	6823      	ldr	r3, [r4, #0]
   1585e:	681b      	ldr	r3, [r3, #0]
   15860:	f506 6173 	add.w	r1, r6, #3888	; 0xf30
   15864:	4628      	mov	r0, r5
   15866:	4798      	blx	r3
        return false;
   15868:	2000      	movs	r0, #0
}
   1586a:	b002      	add	sp, #8
   1586c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   15870:	4616      	mov	r6, r2
    int dnsIx = atoi(argv[1]);
   15872:	6850      	ldr	r0, [r2, #4]
   15874:	f00c fc3a 	bl	220ec <atoi>
   15878:	4607      	mov	r7, r0
    if(dnsIx != 1 && dnsIx != 2)
   1587a:	1e43      	subs	r3, r0, #1
   1587c:	2b01      	cmp	r3, #1
   1587e:	d906      	bls.n	1588e <_Command_DNSAddressSet+0x4e>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown DNS index\r\n");
   15880:	6823      	ldr	r3, [r4, #0]
   15882:	681b      	ldr	r3, [r3, #0]
   15884:	491b      	ldr	r1, [pc, #108]	; (158f4 <_Command_DNSAddressSet+0xb4>)
   15886:	4628      	mov	r0, r5
   15888:	4798      	blx	r3
        return false;
   1588a:	2000      	movs	r0, #0
   1588c:	e7ed      	b.n	1586a <_Command_DNSAddressSet+0x2a>
    netH = TCPIP_STACK_NetHandleGet(argv[2]);
   1588e:	68b0      	ldr	r0, [r6, #8]
   15890:	f008 f860 	bl	1d954 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
   15894:	4680      	mov	r8, r0
   15896:	b1c0      	cbz	r0, 158ca <_Command_DNSAddressSet+0x8a>
    if (!TCPIP_Helper_StringToIPAddress(argv[3], &ipDNS))
   15898:	a901      	add	r1, sp, #4
   1589a:	68f0      	ldr	r0, [r6, #12]
   1589c:	f7fd fb76 	bl	12f8c <TCPIP_Helper_StringToIPAddress>
   158a0:	b1d0      	cbz	r0, 158d8 <_Command_DNSAddressSet+0x98>
    bool res = dnsIx == 1 ? TCPIP_STACK_NetAddressDnsPrimarySet(netH, &ipDNS) : TCPIP_STACK_NetAddressDnsSecondSet(netH, &ipDNS); 
   158a2:	2f01      	cmp	r7, #1
   158a4:	d01f      	beq.n	158e6 <_Command_DNSAddressSet+0xa6>
   158a6:	a901      	add	r1, sp, #4
   158a8:	4640      	mov	r0, r8
   158aa:	f00b faf9 	bl	20ea0 <TCPIP_STACK_NetAddressDnsSecondSet>
    (*pCmdIO->pCmdApi->print)(cmdIoParam, "Set DNS %d address %s\r\n", dnsIx, res ? "success" : "failed");
   158ae:	6823      	ldr	r3, [r4, #0]
   158b0:	685c      	ldr	r4, [r3, #4]
   158b2:	2800      	cmp	r0, #0
   158b4:	4b10      	ldr	r3, [pc, #64]	; (158f8 <_Command_DNSAddressSet+0xb8>)
   158b6:	f103 0208 	add.w	r2, r3, #8
   158ba:	bf08      	it	eq
   158bc:	4613      	moveq	r3, r2
   158be:	463a      	mov	r2, r7
   158c0:	490e      	ldr	r1, [pc, #56]	; (158fc <_Command_DNSAddressSet+0xbc>)
   158c2:	4628      	mov	r0, r5
   158c4:	47a0      	blx	r4
    return true;
   158c6:	2001      	movs	r0, #1
   158c8:	e7cf      	b.n	1586a <_Command_DNSAddressSet+0x2a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   158ca:	6823      	ldr	r3, [r4, #0]
   158cc:	681b      	ldr	r3, [r3, #0]
   158ce:	490c      	ldr	r1, [pc, #48]	; (15900 <_Command_DNSAddressSet+0xc0>)
   158d0:	4628      	mov	r0, r5
   158d2:	4798      	blx	r3
        return false;
   158d4:	2000      	movs	r0, #0
   158d6:	e7c8      	b.n	1586a <_Command_DNSAddressSet+0x2a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Invalid IP address string \r\n");
   158d8:	6823      	ldr	r3, [r4, #0]
   158da:	681b      	ldr	r3, [r3, #0]
   158dc:	4909      	ldr	r1, [pc, #36]	; (15904 <_Command_DNSAddressSet+0xc4>)
   158de:	4628      	mov	r0, r5
   158e0:	4798      	blx	r3
        return false;
   158e2:	2000      	movs	r0, #0
   158e4:	e7c1      	b.n	1586a <_Command_DNSAddressSet+0x2a>
    bool res = dnsIx == 1 ? TCPIP_STACK_NetAddressDnsPrimarySet(netH, &ipDNS) : TCPIP_STACK_NetAddressDnsSecondSet(netH, &ipDNS); 
   158e6:	a901      	add	r1, sp, #4
   158e8:	4640      	mov	r0, r8
   158ea:	f00b facb 	bl	20e84 <TCPIP_STACK_NetAddressDnsPrimarySet>
   158ee:	e7de      	b.n	158ae <_Command_DNSAddressSet+0x6e>
   158f0:	0000028c 	.word	0x0000028c
   158f4:	000011e0 	.word	0x000011e0
   158f8:	00001180 	.word	0x00001180
   158fc:	000011f4 	.word	0x000011f4
   15900:	00000da8 	.word	0x00000da8
   15904:	0000103c 	.word	0x0000103c

Disassembly of section .text.gfx_mono_generic_draw_horizontal_line%328:

00015908 <gfx_mono_generic_draw_horizontal_line>:
        gfx_coord_t length, enum gfx_mono_color color) {
    uint8_t page;
    uint8_t pixelmask;
    uint8_t temp;

    if (x > GFX_MONO_LCD_WIDTH) {
   15908:	2880      	cmp	r0, #128	; 0x80
   1590a:	d860      	bhi.n	159ce <gfx_mono_generic_draw_horizontal_line+0xc6>
        gfx_coord_t length, enum gfx_mono_color color) {
   1590c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15910:	4606      	mov	r6, r0
        return;
    }

    /* Clip line length if too long */
    if (x + length > GFX_MONO_LCD_WIDTH) {
   15912:	4410      	add	r0, r2
   15914:	2880      	cmp	r0, #128	; 0x80
        length = GFX_MONO_LCD_WIDTH - x;
   15916:	bfc4      	itt	gt
   15918:	f1c6 0480 	rsbgt	r4, r6, #128	; 0x80
   1591c:	b2e2      	uxtbgt	r2, r4
    }

    page = y / 8;
    pixelmask = (1 << (y - (page * 8)));

    if (length == 0) {
   1591e:	b382      	cbz	r2, 15982 <gfx_mono_generic_draw_horizontal_line+0x7a>
    page = y / 8;
   15920:	08cd      	lsrs	r5, r1, #3
    pixelmask = (1 << (y - (page * 8)));
   15922:	eba1 01c5 	sub.w	r1, r1, r5, lsl #3
   15926:	2701      	movs	r7, #1
   15928:	fa07 f101 	lsl.w	r1, r7, r1
   1592c:	b2cf      	uxtb	r7, r1
        /* Nothing to do. Move along. */
        return;
    }

    switch (color) {
   1592e:	2b01      	cmp	r3, #1
   15930:	d009      	beq.n	15946 <gfx_mono_generic_draw_horizontal_line+0x3e>
   15932:	b258      	sxtb	r0, r3
   15934:	b168      	cbz	r0, 15952 <gfx_mono_generic_draw_horizontal_line+0x4a>
   15936:	2b02      	cmp	r3, #2
   15938:	d123      	bne.n	15982 <gfx_mono_generic_draw_horizontal_line+0x7a>
   1593a:	1e73      	subs	r3, r6, #1
   1593c:	18d4      	adds	r4, r2, r3
   1593e:	b2e4      	uxtb	r4, r4

        case GFX_PIXEL_XOR:
            while (length-- > 0) {
                temp = gfx_mono_get_byte(page, x + length);
                temp ^= pixelmask;
                gfx_mono_put_byte(page, x + length, temp);
   15940:	f04f 0800 	mov.w	r8, #0
   15944:	e032      	b.n	159ac <gfx_mono_generic_draw_horizontal_line+0xa4>
   15946:	1e73      	subs	r3, r6, #1
   15948:	18d4      	adds	r4, r2, r3
   1594a:	b2e4      	uxtb	r4, r4
                gfx_mono_put_byte(page, x + length, temp);
   1594c:	f04f 0800 	mov.w	r8, #0
   15950:	e007      	b.n	15962 <gfx_mono_generic_draw_horizontal_line+0x5a>
   15952:	1e74      	subs	r4, r6, #1
   15954:	4414      	add	r4, r2
   15956:	b2e4      	uxtb	r4, r4
                temp &= ~pixelmask;
   15958:	43cf      	mvns	r7, r1
                gfx_mono_put_byte(page, x + length, temp);
   1595a:	f04f 0800 	mov.w	r8, #0
   1595e:	e013      	b.n	15988 <gfx_mono_generic_draw_horizontal_line+0x80>
   15960:	461c      	mov	r4, r3
                temp = gfx_mono_get_byte(page, x + length);
   15962:	4621      	mov	r1, r4
   15964:	4628      	mov	r0, r5
   15966:	f00c fbbd 	bl	220e4 <gfx_mono_ssd1306_get_byte>
                temp |= pixelmask;
   1596a:	ea47 0200 	orr.w	r2, r7, r0
                gfx_mono_put_byte(page, x + length, temp);
   1596e:	4643      	mov	r3, r8
   15970:	b2d2      	uxtb	r2, r2
   15972:	4621      	mov	r1, r4
   15974:	4628      	mov	r0, r5
   15976:	f007 fdc5 	bl	1d504 <gfx_mono_ssd1306_put_byte>
   1597a:	1e63      	subs	r3, r4, #1
   1597c:	b2db      	uxtb	r3, r3
            while (length-- > 0) {
   1597e:	42a6      	cmp	r6, r4
   15980:	d1ee      	bne.n	15960 <gfx_mono_generic_draw_horizontal_line+0x58>
            break;

        default:
            break;
    }
}
   15982:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   15986:	461c      	mov	r4, r3
                temp = gfx_mono_get_byte(page, x + length);
   15988:	4621      	mov	r1, r4
   1598a:	4628      	mov	r0, r5
   1598c:	f00c fbaa 	bl	220e4 <gfx_mono_ssd1306_get_byte>
                temp &= ~pixelmask;
   15990:	ea07 0200 	and.w	r2, r7, r0
                gfx_mono_put_byte(page, x + length, temp);
   15994:	4643      	mov	r3, r8
   15996:	b2d2      	uxtb	r2, r2
   15998:	4621      	mov	r1, r4
   1599a:	4628      	mov	r0, r5
   1599c:	f007 fdb2 	bl	1d504 <gfx_mono_ssd1306_put_byte>
   159a0:	1e63      	subs	r3, r4, #1
   159a2:	b2db      	uxtb	r3, r3
            while (length-- > 0) {
   159a4:	42a6      	cmp	r6, r4
   159a6:	d1ee      	bne.n	15986 <gfx_mono_generic_draw_horizontal_line+0x7e>
   159a8:	e7eb      	b.n	15982 <gfx_mono_generic_draw_horizontal_line+0x7a>
   159aa:	461c      	mov	r4, r3
                temp = gfx_mono_get_byte(page, x + length);
   159ac:	4621      	mov	r1, r4
   159ae:	4628      	mov	r0, r5
   159b0:	f00c fb98 	bl	220e4 <gfx_mono_ssd1306_get_byte>
                temp ^= pixelmask;
   159b4:	ea87 0200 	eor.w	r2, r7, r0
                gfx_mono_put_byte(page, x + length, temp);
   159b8:	4643      	mov	r3, r8
   159ba:	b2d2      	uxtb	r2, r2
   159bc:	4621      	mov	r1, r4
   159be:	4628      	mov	r0, r5
   159c0:	f007 fda0 	bl	1d504 <gfx_mono_ssd1306_put_byte>
   159c4:	1e63      	subs	r3, r4, #1
   159c6:	b2db      	uxtb	r3, r3
            while (length-- > 0) {
   159c8:	42b4      	cmp	r4, r6
   159ca:	d1ee      	bne.n	159aa <gfx_mono_generic_draw_horizontal_line+0xa2>
   159cc:	e7d9      	b.n	15982 <gfx_mono_generic_draw_horizontal_line+0x7a>
   159ce:	4770      	bx	lr

Disassembly of section .text.__mdiff%329:

000159d0 <__mdiff>:
   159d0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   159d4:	460d      	mov	r5, r1
   159d6:	4607      	mov	r7, r0
   159d8:	4611      	mov	r1, r2
   159da:	4628      	mov	r0, r5
   159dc:	4614      	mov	r4, r2
   159de:	f009 f991 	bl	1ed04 <__mcmp>
   159e2:	1e06      	subs	r6, r0, #0
   159e4:	d108      	bne.n	159f8 <__mdiff+0x28>
   159e6:	4631      	mov	r1, r6
   159e8:	4638      	mov	r0, r7
   159ea:	f005 f937 	bl	1ac5c <_Balloc>
   159ee:	2301      	movs	r3, #1
   159f0:	e9c0 3604 	strd	r3, r6, [r0, #16]
   159f4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   159f8:	bfa4      	itt	ge
   159fa:	4623      	movge	r3, r4
   159fc:	462c      	movge	r4, r5
   159fe:	4638      	mov	r0, r7
   15a00:	6861      	ldr	r1, [r4, #4]
   15a02:	bfa6      	itte	ge
   15a04:	461d      	movge	r5, r3
   15a06:	2600      	movge	r6, #0
   15a08:	2601      	movlt	r6, #1
   15a0a:	f005 f927 	bl	1ac5c <_Balloc>
   15a0e:	692b      	ldr	r3, [r5, #16]
   15a10:	6927      	ldr	r7, [r4, #16]
   15a12:	60c6      	str	r6, [r0, #12]
   15a14:	f104 0214 	add.w	r2, r4, #20
   15a18:	f105 0614 	add.w	r6, r5, #20
   15a1c:	eb02 0887 	add.w	r8, r2, r7, lsl #2
   15a20:	eb06 0e83 	add.w	lr, r6, r3, lsl #2
   15a24:	f100 0514 	add.w	r5, r0, #20
   15a28:	f04f 0a00 	mov.w	sl, #0
   15a2c:	f64f 79ff 	movw	r9, #65535	; 0xffff
   15a30:	f852 bb04 	ldr.w	fp, [r2], #4
   15a34:	f856 3b04 	ldr.w	r3, [r6], #4
   15a38:	fa1a fa8b 	uxtah	sl, sl, fp
   15a3c:	ea03 0109 	and.w	r1, r3, r9
   15a40:	0c1b      	lsrs	r3, r3, #16
   15a42:	ebaa 0101 	sub.w	r1, sl, r1
   15a46:	ebc3 431b 	rsb	r3, r3, fp, lsr #16
   15a4a:	eb03 4321 	add.w	r3, r3, r1, asr #16
   15a4e:	ea01 0109 	and.w	r1, r1, r9
   15a52:	ea4f 4a23 	mov.w	sl, r3, asr #16
   15a56:	45b6      	cmp	lr, r6
   15a58:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
   15a5c:	4694      	mov	ip, r2
   15a5e:	f845 3b04 	str.w	r3, [r5], #4
   15a62:	d8e5      	bhi.n	15a30 <__mdiff+0x60>
   15a64:	f64f 74ff 	movw	r4, #65535	; 0xffff
   15a68:	45c4      	cmp	ip, r8
   15a6a:	d304      	bcc.n	15a76 <__mdiff+0xa6>
   15a6c:	f855 3d04 	ldr.w	r3, [r5, #-4]!
   15a70:	b183      	cbz	r3, 15a94 <__mdiff+0xc4>
   15a72:	6107      	str	r7, [r0, #16]
   15a74:	e7be      	b.n	159f4 <__mdiff+0x24>
   15a76:	f85c 1b04 	ldr.w	r1, [ip], #4
   15a7a:	fa1a f381 	uxtah	r3, sl, r1
   15a7e:	141a      	asrs	r2, r3, #16
   15a80:	eb02 4211 	add.w	r2, r2, r1, lsr #16
   15a84:	4023      	ands	r3, r4
   15a86:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   15a8a:	ea4f 4a22 	mov.w	sl, r2, asr #16
   15a8e:	f845 3b04 	str.w	r3, [r5], #4
   15a92:	e7e9      	b.n	15a68 <__mdiff+0x98>
   15a94:	3f01      	subs	r7, #1
   15a96:	e7e9      	b.n	15a6c <__mdiff+0x9c>

Disassembly of section .rodata.__mprec_tens%330:

00015a98 <__mprec_tens>:
   15a98:	0000 0000 0000 3ff0 0000 0000 0000 4024     .......?......$@
   15aa8:	0000 0000 0000 4059 0000 0000 4000 408f     ......Y@.....@.@
   15ab8:	0000 0000 8800 40c3 0000 0000 6a00 40f8     .......@.....j.@
   15ac8:	0000 0000 8480 412e 0000 0000 12d0 4163     .......A......cA
   15ad8:	0000 0000 d784 4197 0000 0000 cd65 41cd     .......A....e..A
   15ae8:	0000 2000 a05f 4202 0000 e800 4876 4237     ... _..B....vH7B
   15af8:	0000 a200 1a94 426d 0000 e540 309c 42a2     ......mB..@..0.B
   15b08:	0000 1e90 bcc4 42d6 0000 2634 6bf5 430c     .......B..4&.k.C
   15b18:	8000 37e0 c379 4341 a000 85d8 3457 4376     ...7y.AC....W4vC
   15b28:	c800 674e c16d 43ab 3d00 6091 58e4 43e1     ..Ngm..C.=.`.X.C
   15b38:	8c40 78b5 af1d 4415 ef50 d6e2 1ae4 444b     @..x...DP.....KD
   15b48:	d592 064d f0cf 4480 4af6 c7e1 2d02 44b5     ..M....D.J...-.D
   15b58:	9db4 79d9 7843 44ea                         ...yCx.D

Disassembly of section .text._DRV_MIIM_StartOp%331:

00015b60 <_DRV_MIIM_StartOp>:
{
   15b60:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15b64:	460f      	mov	r7, r1
   15b66:	4690      	mov	r8, r2
   15b68:	469a      	mov	sl, r3
   15b6a:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   15b6c:	f89d 9030 	ldrb.w	r9, [sp, #48]	; 0x30
        if((pClient = _DRV_MIIM_GetClientAndLock(handle, true)) == 0)
   15b70:	2101      	movs	r1, #1
   15b72:	f006 fcea 	bl	1c54a <_DRV_MIIM_GetClientAndLock>
   15b76:	b3c8      	cbz	r0, 15bec <_DRV_MIIM_StartOp+0x8c>
   15b78:	4606      	mov	r6, r0
        pMiimObj = pClient->parentObj;
   15b7a:	6844      	ldr	r4, [r0, #4]
        if(pSchedData->regIx > DRV_MIIM_MAX_REG_INDEX_VALUE)
   15b7c:	2f1f      	cmp	r7, #31
   15b7e:	d839      	bhi.n	15bf4 <_DRV_MIIM_StartOp+0x94>
        if(pSchedData->phyAdd > DRV_MIIM_MAX_ADDRESS_VALUE)
   15b80:	f1b8 0f1f 	cmp.w	r8, #31
   15b84:	d83e      	bhi.n	15c04 <_DRV_MIIM_StartOp+0xa4>
        if((pMiimObj->objFlags & DRV_MIIM_OBJ_FLAG_SETUP_DONE) == 0)
   15b86:	88a3      	ldrh	r3, [r4, #4]
   15b88:	f013 0f02 	tst.w	r3, #2
   15b8c:	d03d      	beq.n	15c0a <_DRV_MIIM_StartOp+0xaa>
        if((pMiimObj->objFlags & DRV_MIIM_OBJ_FLAG_IS_SCANNING) != 0)
   15b8e:	f013 0f08 	tst.w	r3, #8
   15b92:	d002      	beq.n	15b9a <_DRV_MIIM_StartOp+0x3a>
            res = DRV_MIIM_RES_OP_SCAN_ERR;
   15b94:	f06f 0607 	mvn.w	r6, #7
   15b98:	e039      	b.n	15c0e <_DRV_MIIM_StartOp+0xae>
    DRV_MIIM_OP_DCPT* pOpDcpt = (DRV_MIIM_OP_DCPT*)Helper_SingleListHeadRemove(pL);
   15b9a:	f104 0070 	add.w	r0, r4, #112	; 0x70
   15b9e:	f00b f8e5 	bl	20d6c <Helper_SingleListHeadRemove>
        if(pOpDcpt == 0)
   15ba2:	4683      	mov	fp, r0
   15ba4:	b3e0      	cbz	r0, 15c20 <_DRV_MIIM_StartOp+0xc0>
        pOpDcpt->opType = pSchedData->opType;
   15ba6:	f880 9004 	strb.w	r9, [r0, #4]
        pOpDcpt->regIx = (uint8_t)pSchedData->regIx;
   15baa:	7147      	strb	r7, [r0, #5]
        pOpDcpt->phyAdd = (uint8_t)pSchedData->phyAdd;
   15bac:	f880 8006 	strb.w	r8, [r0, #6]
        pOpDcpt->opFlags = pSchedData->opFlags;
   15bb0:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
   15bb4:	71c3      	strb	r3, [r0, #7]
        pOpDcpt->opData = pSchedData->opData;
   15bb6:	f8a0 a008 	strh.w	sl, [r0, #8]
        pOpDcpt->opStat = DRV_MIIM_TXFER_START;
   15bba:	2301      	movs	r3, #1
   15bbc:	7283      	strb	r3, [r0, #10]
        pOpDcpt->pOwner = pClient;
   15bbe:	60c6      	str	r6, [r0, #12]
        if(pOpDcpt->opType == DRV_MIIM_OP_SCAN)
   15bc0:	f1b9 0f03 	cmp.w	r9, #3
   15bc4:	d00d      	beq.n	15be2 <_DRV_MIIM_StartOp+0x82>
    Helper_SingleListTailAdd(pL, (SGL_LIST_NODE*)pOpDcpt);
   15bc6:	4659      	mov	r1, fp
   15bc8:	f104 007c 	add.w	r0, r4, #124	; 0x7c
   15bcc:	f00b fa8d 	bl	210ea <Helper_SingleListTailAdd>
    pOpDcpt->qType = qType;
   15bd0:	2302      	movs	r3, #2
   15bd2:	f88b 300b 	strb.w	r3, [fp, #11]
    OSAL_SEM_Post(&pMiimObj->objSem);
   15bd6:	4620      	mov	r0, r4
   15bd8:	f00b fc6c 	bl	214b4 <OSAL_SEM_Post>
        pSchedData->opHandle = opHandle;
   15bdc:	465c      	mov	r4, fp
    OSAL_SEM_Post(&pMiimObj->objSem);
   15bde:	2600      	movs	r6, #0
   15be0:	e019      	b.n	15c16 <_DRV_MIIM_StartOp+0xb6>
            pMiimObj->objFlags |= DRV_MIIM_OBJ_FLAG_IS_SCANNING;
   15be2:	88a3      	ldrh	r3, [r4, #4]
   15be4:	f043 0308 	orr.w	r3, r3, #8
   15be8:	80a3      	strh	r3, [r4, #4]
   15bea:	e7ec      	b.n	15bc6 <_DRV_MIIM_StartOp+0x66>
        opHandle = 0;
   15bec:	4604      	mov	r4, r0
            res = DRV_MIIM_RES_HANDLE_ERR;
   15bee:	f04f 36ff 	mov.w	r6, #4294967295
   15bf2:	e010      	b.n	15c16 <_DRV_MIIM_StartOp+0xb6>
            res = DRV_MIIM_RES_REGISTER_ERR;
   15bf4:	f06f 0604 	mvn.w	r6, #4
    if(pMiimObj != 0)
   15bf8:	b16c      	cbz	r4, 15c16 <_DRV_MIIM_StartOp+0xb6>
    OSAL_SEM_Post(&pMiimObj->objSem);
   15bfa:	4620      	mov	r0, r4
   15bfc:	f00b fc5a 	bl	214b4 <OSAL_SEM_Post>
        opHandle = 0;
   15c00:	2400      	movs	r4, #0
   15c02:	e008      	b.n	15c16 <_DRV_MIIM_StartOp+0xb6>
            res = DRV_MIIM_RES_ADDRESS_ERR;
   15c04:	f06f 0605 	mvn.w	r6, #5
   15c08:	e7f6      	b.n	15bf8 <_DRV_MIIM_StartOp+0x98>
            res = DRV_MIIM_RES_SETUP_ERR;
   15c0a:	f06f 0603 	mvn.w	r6, #3
    OSAL_SEM_Post(&pMiimObj->objSem);
   15c0e:	4620      	mov	r0, r4
   15c10:	f00b fc50 	bl	214b4 <OSAL_SEM_Post>
        opHandle = 0;
   15c14:	2400      	movs	r4, #0
    if(pOpResult)
   15c16:	b105      	cbz	r5, 15c1a <_DRV_MIIM_StartOp+0xba>
        *pOpResult = opRes;
   15c18:	702e      	strb	r6, [r5, #0]
}
   15c1a:	4620      	mov	r0, r4
   15c1c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
            res = DRV_MIIM_RES_BUSY;
   15c20:	2602      	movs	r6, #2
   15c22:	e7f4      	b.n	15c0e <_DRV_MIIM_StartOp+0xae>

Disassembly of section .text.TCPIP_UDP_OpenServerSkt%332:

00015c24 <TCPIP_UDP_OpenServerSkt>:
   if(addType == IP_ADDRESS_TYPE_IPV6)
   15c24:	2802      	cmp	r0, #2
   15c26:	d056      	beq.n	15cd6 <TCPIP_UDP_OpenServerSkt+0xb2>
{
   15c28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   15c2a:	461d      	mov	r5, r3
   15c2c:	4614      	mov	r4, r2
   15c2e:	460e      	mov	r6, r1
   if(addType == IP_ADDRESS_TYPE_IPV4 && localAddress != 0)
   15c30:	b10a      	cbz	r2, 15c36 <TCPIP_UDP_OpenServerSkt+0x12>
       if(localAddress->v4Add.Val == 0)
   15c32:	6813      	ldr	r3, [r2, #0]
   15c34:	b9ab      	cbnz	r3, 15c62 <TCPIP_UDP_OpenServerSkt+0x3e>
    skt = _UDPOpen(addType, opType, localPort, 0);
   15c36:	2300      	movs	r3, #0
   15c38:	4632      	mov	r2, r6
   15c3a:	4629      	mov	r1, r5
   15c3c:	2001      	movs	r0, #1
   15c3e:	f7fb fbb5 	bl	113ac <_UDPOpen>
    if(skt != INVALID_UDP_SOCKET)
   15c42:	f1b0 3fff 	cmp.w	r0, #4294967295
   15c46:	d00b      	beq.n	15c60 <TCPIP_UDP_OpenServerSkt+0x3c>
        UDP_SOCKET_DCPT* pSkt = UDPSocketDcpt[skt];
   15c48:	4b26      	ldr	r3, [pc, #152]	; (15ce4 <TCPIP_UDP_OpenServerSkt+0xc0>)
   15c4a:	681b      	ldr	r3, [r3, #0]
   15c4c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    if((pSkt->pSktNet = pNet) != 0)
   15c50:	2200      	movs	r2, #0
   15c52:	625a      	str	r2, [r3, #36]	; 0x24
    pSkt->extFlags.rxEnable = 1;
   15c54:	f893 2042 	ldrb.w	r2, [r3, #66]	; 0x42
   15c58:	f042 0202 	orr.w	r2, r2, #2
   15c5c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
}
   15c60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
           pDefIf = TCPIP_STACK_IPAddToNet(&localAddress->v4Add, false);
   15c62:	2100      	movs	r1, #0
   15c64:	4610      	mov	r0, r2
   15c66:	f00a fbb5 	bl	203d4 <TCPIP_STACK_IPAddToNet>
           if(pDefIf == 0)
   15c6a:	4607      	mov	r7, r0
   15c6c:	b3b0      	cbz	r0, 15cdc <TCPIP_UDP_OpenServerSkt+0xb8>
    skt = _UDPOpen(addType, opType, localPort, 0);
   15c6e:	2300      	movs	r3, #0
   15c70:	4632      	mov	r2, r6
   15c72:	4629      	mov	r1, r5
   15c74:	2001      	movs	r0, #1
   15c76:	f7fb fb99 	bl	113ac <_UDPOpen>
    if(skt != INVALID_UDP_SOCKET)
   15c7a:	f1b0 3fff 	cmp.w	r0, #4294967295
   15c7e:	d0ef      	beq.n	15c60 <TCPIP_UDP_OpenServerSkt+0x3c>
        UDP_SOCKET_DCPT* pSkt = UDPSocketDcpt[skt];
   15c80:	4b18      	ldr	r3, [pc, #96]	; (15ce4 <TCPIP_UDP_OpenServerSkt+0xc0>)
   15c82:	681b      	ldr	r3, [r3, #0]
   15c84:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    if((pSkt->pSktNet = pNet) != 0)
   15c88:	625f      	str	r7, [r3, #36]	; 0x24
        pSkt->flags.looseNetIf = 0;
   15c8a:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
   15c8e:	f36f 02c3 	bfc	r2, #3, #1
   15c92:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    return _UDPSetSourceAddress(pSkt, pSkt->addType, srcAddress);
   15c96:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
    while(pSkt->addType == addType)
   15c98:	b2d1      	uxtb	r1, r2
   15c9a:	428a      	cmp	r2, r1
   15c9c:	d00d      	beq.n	15cba <TCPIP_UDP_OpenServerSkt+0x96>
        if(pDefIf != 0)
   15c9e:	b12f      	cbz	r7, 15cac <TCPIP_UDP_OpenServerSkt+0x88>
            pSkt->flags.openBindIf = 1;
   15ca0:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
   15ca4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   15ca8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
            pSkt->flags.openBindAdd = 1;
   15cac:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
   15cb0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   15cb4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
   15cb8:	e7cc      	b.n	15c54 <TCPIP_UDP_OpenServerSkt+0x30>
        if (addType == IP_ADDRESS_TYPE_IPV4)
   15cba:	b2d2      	uxtb	r2, r2
   15cbc:	2a01      	cmp	r2, #1
   15cbe:	d1ee      	bne.n	15c9e <TCPIP_UDP_OpenServerSkt+0x7a>
            pSkt->srcAddress.Val = localAddress->v4Add.Val;
   15cc0:	6822      	ldr	r2, [r4, #0]
   15cc2:	619a      	str	r2, [r3, #24]
            pSkt->flags.srcSet = 1;
   15cc4:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
            pSkt->flags.srcSolved = 0;
   15cc8:	f042 0260 	orr.w	r2, r2, #96	; 0x60
   15ccc:	f36f 12c7 	bfc	r2, #7, #1
   15cd0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
            return true;
   15cd4:	e7e3      	b.n	15c9e <TCPIP_UDP_OpenServerSkt+0x7a>
       return INVALID_SOCKET;
   15cd6:	f04f 30ff 	mov.w	r0, #4294967295
}
   15cda:	4770      	bx	lr
               return INVALID_UDP_SOCKET;
   15cdc:	f04f 30ff 	mov.w	r0, #4294967295
   15ce0:	e7be      	b.n	15c60 <TCPIP_UDP_OpenServerSkt+0x3c>
   15ce2:	bf00      	nop
   15ce4:	2000e65c 	.word	0x2000e65c

Disassembly of section .text.TCPIP_TCP_Bind%333:

00015ce8 <TCPIP_TCP_Bind>:
{
   15ce8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15cec:	460d      	mov	r5, r1
   15cee:	4616      	mov	r6, r2
   15cf0:	461f      	mov	r7, r3
    pSkt = _TcpSocketChk(hTCP); 
   15cf2:	f009 ffdf 	bl	1fcb4 <_TcpSocketChk>
    if(pSkt == 0 || _TCP_IsConnected(pSkt))
   15cf6:	2800      	cmp	r0, #0
   15cf8:	d04c      	beq.n	15d94 <TCPIP_TCP_Bind+0xac>
   15cfa:	4604      	mov	r4, r0
    return (pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1 || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2 || pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT);
   15cfc:	f890 206e 	ldrb.w	r2, [r0, #110]	; 0x6e
   15d00:	1ed3      	subs	r3, r2, #3
   15d02:	b2db      	uxtb	r3, r3
   15d04:	2b02      	cmp	r3, #2
   15d06:	d947      	bls.n	15d98 <TCPIP_TCP_Bind+0xb0>
    if(pSkt == 0 || _TCP_IsConnected(pSkt))
   15d08:	2a08      	cmp	r2, #8
   15d0a:	d049      	beq.n	15da0 <TCPIP_TCP_Bind+0xb8>
    if(pSkt->addType != IP_ADDRESS_TYPE_ANY && pSkt->addType != addType)
   15d0c:	f890 306f 	ldrb.w	r3, [r0, #111]	; 0x6f
   15d10:	b10b      	cbz	r3, 15d16 <TCPIP_TCP_Bind+0x2e>
   15d12:	42ab      	cmp	r3, r5
   15d14:	d146      	bne.n	15da4 <TCPIP_TCP_Bind+0xbc>
    if(localAddress != 0)
   15d16:	b15f      	cbz	r7, 15d30 <TCPIP_TCP_Bind+0x48>
        if (addType == IP_ADDRESS_TYPE_IPV4)
   15d18:	2d01      	cmp	r5, #1
   15d1a:	d001      	beq.n	15d20 <TCPIP_TCP_Bind+0x38>
            return false;
   15d1c:	2300      	movs	r3, #0
   15d1e:	e03c      	b.n	15d9a <TCPIP_TCP_Bind+0xb2>
            pSktIf = TCPIP_STACK_IPAddToNet(&localAddress->v4Add, false);
   15d20:	2100      	movs	r1, #0
   15d22:	4638      	mov	r0, r7
   15d24:	f00a fb56 	bl	203d4 <TCPIP_STACK_IPAddToNet>
        if(pSktIf == 0)
   15d28:	4680      	mov	r8, r0
   15d2a:	b918      	cbnz	r0, 15d34 <TCPIP_TCP_Bind+0x4c>
            return false;
   15d2c:	2300      	movs	r3, #0
   15d2e:	e034      	b.n	15d9a <TCPIP_TCP_Bind+0xb2>
        pSktIf = pSkt->pSktNet;
   15d30:	f8d4 8040 	ldr.w	r8, [r4, #64]	; 0x40
    if(localPort == 0)
   15d34:	b1e6      	cbz	r6, 15d70 <TCPIP_TCP_Bind+0x88>
    else if(localPort != pSkt->localPort && !_TCP_PortIsAvailable(localPort))
   15d36:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
   15d3a:	42b3      	cmp	r3, r6
   15d3c:	d004      	beq.n	15d48 <TCPIP_TCP_Bind+0x60>
   15d3e:	4630      	mov	r0, r6
   15d40:	f007 fd68 	bl	1d814 <_TCP_PortIsAvailable>
   15d44:	4603      	mov	r3, r0
   15d46:	b340      	cbz	r0, 15d9a <TCPIP_TCP_Bind+0xb2>
    pSkt->addType = addType;
   15d48:	f884 506f 	strb.w	r5, [r4, #111]	; 0x6f
    pSkt->pSktNet = pNet;
   15d4c:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
    _TCPSetSourceAddress(pSkt, pSkt->addType, srcAddress);
   15d50:	463a      	mov	r2, r7
   15d52:	4629      	mov	r1, r5
   15d54:	4620      	mov	r0, r4
   15d56:	f008 fce0 	bl	1e71a <_TCPSetSourceAddress>
    pSkt->localPort = localPort;
   15d5a:	f8a4 605a 	strh.w	r6, [r4, #90]	; 0x5a
    if(pSkt->Flags.bServer)
   15d5e:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
   15d62:	f013 0f01 	tst.w	r3, #1
   15d66:	d00a      	beq.n	15d7e <TCPIP_TCP_Bind+0x96>
        pSkt->remoteHash = localPort;
   15d68:	f8a4 606a 	strh.w	r6, [r4, #106]	; 0x6a
    return true;
   15d6c:	2301      	movs	r3, #1
   15d6e:	e014      	b.n	15d9a <TCPIP_TCP_Bind+0xb2>
        localPort = _TCP_EphemeralPortAllocate();
   15d70:	f008 fba0 	bl	1e4b4 <_TCP_EphemeralPortAllocate>
        if(localPort == 0)
   15d74:	4606      	mov	r6, r0
   15d76:	2800      	cmp	r0, #0
   15d78:	d1e6      	bne.n	15d48 <TCPIP_TCP_Bind+0x60>
            return false;
   15d7a:	2300      	movs	r3, #0
   15d7c:	e00d      	b.n	15d9a <TCPIP_TCP_Bind+0xb2>
    return (pAdd->w[1] + pAdd->w[0] + pSkt->remotePort) ^ pSkt->localPort;
   15d7e:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   15d80:	8f22      	ldrh	r2, [r4, #56]	; 0x38
   15d82:	4413      	add	r3, r2
   15d84:	f8b4 2058 	ldrh.w	r2, [r4, #88]	; 0x58
   15d88:	4413      	add	r3, r2
   15d8a:	405e      	eors	r6, r3
        pSkt->remoteHash = _TCP_ClientIPV4RemoteHash(&pSkt->destAddress, pSkt);
   15d8c:	f8a4 606a 	strh.w	r6, [r4, #106]	; 0x6a
    return true;
   15d90:	2301      	movs	r3, #1
   15d92:	e002      	b.n	15d9a <TCPIP_TCP_Bind+0xb2>
        return false;
   15d94:	2300      	movs	r3, #0
   15d96:	e000      	b.n	15d9a <TCPIP_TCP_Bind+0xb2>
   15d98:	2300      	movs	r3, #0
}
   15d9a:	4618      	mov	r0, r3
   15d9c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return false;
   15da0:	2300      	movs	r3, #0
   15da2:	e7fa      	b.n	15d9a <TCPIP_TCP_Bind+0xb2>
        return false;
   15da4:	2300      	movs	r3, #0
   15da6:	e7f8      	b.n	15d9a <TCPIP_TCP_Bind+0xb2>

Disassembly of section .text._Command_DefaultInterfaceSet%334:

00015da8 <_Command_DefaultInterfaceSet>:
{
   15da8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15dac:	b086      	sub	sp, #24
   15dae:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   15db0:	6845      	ldr	r5, [r0, #4]
    while(argc >= 2)
   15db2:	2901      	cmp	r1, #1
   15db4:	dd0a      	ble.n	15dcc <_Command_DefaultInterfaceSet+0x24>
   15db6:	460e      	mov	r6, r1
   15db8:	4617      	mov	r7, r2
        if(strcmp(argv[1], "set") == 0)
   15dba:	f8d2 8004 	ldr.w	r8, [r2, #4]
   15dbe:	4923      	ldr	r1, [pc, #140]	; (15e4c <_Command_DefaultInterfaceSet+0xa4>)
   15dc0:	4640      	mov	r0, r8
   15dc2:	f00b fd9b 	bl	218fc <strcmp>
   15dc6:	bb50      	cbnz	r0, 15e1e <_Command_DefaultInterfaceSet+0x76>
            if(argc < 3)
   15dc8:	2e02      	cmp	r6, #2
   15dca:	dc10      	bgt.n	15dee <_Command_DefaultInterfaceSet+0x46>
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: defnet set/get <interface>\r\n");
   15dcc:	4e20      	ldr	r6, [pc, #128]	; (15e50 <_Command_DefaultInterfaceSet+0xa8>)
   15dce:	6823      	ldr	r3, [r4, #0]
   15dd0:	681b      	ldr	r3, [r3, #0]
   15dd2:	f106 0184 	add.w	r1, r6, #132	; 0x84
   15dd6:	4628      	mov	r0, r5
   15dd8:	4798      	blx	r3
            (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: defnet set eth0\r\n");
   15dda:	6823      	ldr	r3, [r4, #0]
   15ddc:	681b      	ldr	r3, [r3, #0]
   15dde:	f106 01a8 	add.w	r1, r6, #168	; 0xa8
   15de2:	4628      	mov	r0, r5
   15de4:	4798      	blx	r3
}
   15de6:	2000      	movs	r0, #0
   15de8:	b006      	add	sp, #24
   15dea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            netH = TCPIP_STACK_NetHandleGet(argv[2]);
   15dee:	68b8      	ldr	r0, [r7, #8]
   15df0:	f007 fdb0 	bl	1d954 <TCPIP_STACK_NetHandleGet>
            if (netH == 0)
   15df4:	b168      	cbz	r0, 15e12 <_Command_DefaultInterfaceSet+0x6a>
            res = TCPIP_STACK_NetDefaultSet(netH);
   15df6:	f00a fddb 	bl	209b0 <TCPIP_STACK_NetDefaultSet>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Default interface set %s\r\n", res ? "successful" : "failed!");
   15dfa:	6823      	ldr	r3, [r4, #0]
   15dfc:	685b      	ldr	r3, [r3, #4]
   15dfe:	2800      	cmp	r0, #0
   15e00:	4a14      	ldr	r2, [pc, #80]	; (15e54 <_Command_DefaultInterfaceSet+0xac>)
   15e02:	f102 010c 	add.w	r1, r2, #12
   15e06:	bf08      	it	eq
   15e08:	460a      	moveq	r2, r1
   15e0a:	3110      	adds	r1, #16
   15e0c:	4628      	mov	r0, r5
   15e0e:	4798      	blx	r3
            break;
   15e10:	e7e9      	b.n	15de6 <_Command_DefaultInterfaceSet+0x3e>
                (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   15e12:	6823      	ldr	r3, [r4, #0]
   15e14:	681b      	ldr	r3, [r3, #0]
   15e16:	4910      	ldr	r1, [pc, #64]	; (15e58 <_Command_DefaultInterfaceSet+0xb0>)
   15e18:	4628      	mov	r0, r5
   15e1a:	4798      	blx	r3
                return false;
   15e1c:	e7e3      	b.n	15de6 <_Command_DefaultInterfaceSet+0x3e>
        else if(strcmp(argv[1], "get") == 0)
   15e1e:	490f      	ldr	r1, [pc, #60]	; (15e5c <_Command_DefaultInterfaceSet+0xb4>)
   15e20:	4640      	mov	r0, r8
   15e22:	f00b fd6b 	bl	218fc <strcmp>
   15e26:	2800      	cmp	r0, #0
   15e28:	d1d0      	bne.n	15dcc <_Command_DefaultInterfaceSet+0x24>
            netH = TCPIP_STACK_NetDefaultGet();
   15e2a:	f00c f865 	bl	21ef8 <TCPIP_STACK_NetDefaultGet>
            nameSize = TCPIP_STACK_NetAliasNameGet(netH, nameBuff, sizeof(nameBuff));
   15e2e:	2214      	movs	r2, #20
   15e30:	a901      	add	r1, sp, #4
   15e32:	f008 fab1 	bl	1e398 <TCPIP_STACK_NetAliasNameGet>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Default interface is: %s\r\n", nameSize ? nameBuff : "None");
   15e36:	6823      	ldr	r3, [r4, #0]
   15e38:	685b      	ldr	r3, [r3, #4]
   15e3a:	b920      	cbnz	r0, 15e46 <_Command_DefaultInterfaceSet+0x9e>
   15e3c:	4a08      	ldr	r2, [pc, #32]	; (15e60 <_Command_DefaultInterfaceSet+0xb8>)
   15e3e:	4909      	ldr	r1, [pc, #36]	; (15e64 <_Command_DefaultInterfaceSet+0xbc>)
   15e40:	4628      	mov	r0, r5
   15e42:	4798      	blx	r3
            break;
   15e44:	e7cf      	b.n	15de6 <_Command_DefaultInterfaceSet+0x3e>
            (*pCmdIO->pCmdApi->print)(cmdIoParam, "Default interface is: %s\r\n", nameSize ? nameBuff : "None");
   15e46:	aa01      	add	r2, sp, #4
   15e48:	e7f9      	b.n	15e3e <_Command_DefaultInterfaceSet+0x96>
   15e4a:	bf00      	nop
   15e4c:	000013c8 	.word	0x000013c8
   15e50:	00001384 	.word	0x00001384
   15e54:	000013b4 	.word	0x000013b4
   15e58:	00000da8 	.word	0x00000da8
   15e5c:	000013cc 	.word	0x000013cc
   15e60:	00001218 	.word	0x00001218
   15e64:	000013ec 	.word	0x000013ec

Disassembly of section .rodata.tcpipCmdTbl%335:

00015e68 <tcpipCmdTbl>:
   15e68:	00001780 0000e2ed 00001788 000017a4     ................
   15e78:	00015da9 000017ac 00001598 0000cea9     .]..............
   15e88:	000017c8 000017e0 00021fe3 000017e8     ................
   15e98:	00001804 00021fd9 0000180c 00001820     ............ ...
   15ea8:	00015841 00001828 0000183c 00014c99     AX..(...<....L..
   15eb8:	00001844 00001860 0001881d 00001868     D...`.......h...
   15ec8:	00001880 0001a5bd 00001888 000018a4     ................
   15ed8:	00017a39 000018ac 000018c0 000110e5     9z..............
   15ee8:	000018c4 000018e4 00012d4d 000018ec     ........M-......
   15ef8:	00001900 0001415d 0000190c 00001920     ....]A...... ...
   15f08:	0000d385 00001928 00001940 00007b65     ....(...@...e{..
   15f18:	00001948 00001960 000103b1 00001968     H...`.......h...

Disassembly of section .text.TCPIP_Helper_StringToMACAddress%336:

00015f28 <TCPIP_Helper_StringToMACAddress>:
  Return Values:
  	true - a MAC address was successfully decoded
  	false - no MAC address could be found, or the format was incorrect
  ***************************************************************************/
bool TCPIP_Helper_StringToMACAddress(const char* str, uint8_t macAddr[6])
{
   15f28:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   15f2c:	b083      	sub	sp, #12
    TCPIP_UINT16_VAL    hexDigit;
    uint8_t     convAddr[6];
    uint8_t*    pAdd;
    int         ix;
    
    if(macAddr)
   15f2e:	4688      	mov	r8, r1
   15f30:	b111      	cbz	r1, 15f38 <TCPIP_Helper_StringToMACAddress+0x10>
    {
        memset(macAddr, 0, sizeof(convAddr));
   15f32:	2300      	movs	r3, #0
   15f34:	600b      	str	r3, [r1, #0]
   15f36:	808b      	strh	r3, [r1, #4]
    }

    if(str == 0 || strlen(str) == 0)
   15f38:	2800      	cmp	r0, #0
   15f3a:	d046      	beq.n	15fca <TCPIP_Helper_StringToMACAddress+0xa2>
   15f3c:	7803      	ldrb	r3, [r0, #0]
   15f3e:	2b00      	cmp	r3, #0
   15f40:	d045      	beq.n	15fce <TCPIP_Helper_StringToMACAddress+0xa6>

    beg = str;
    pAdd = convAddr;
    for(ix=0; ix<6; ix++)
    {
        if(!isxdigit(beg[0]) || !isxdigit(beg[1]))
   15f42:	4a28      	ldr	r2, [pc, #160]	; (15fe4 <TCPIP_Helper_StringToMACAddress+0xbc>)
   15f44:	5c9a      	ldrb	r2, [r3, r2]
   15f46:	f012 0f44 	tst.w	r2, #68	; 0x44
   15f4a:	d042      	beq.n	15fd2 <TCPIP_Helper_StringToMACAddress+0xaa>
   15f4c:	7842      	ldrb	r2, [r0, #1]
   15f4e:	4925      	ldr	r1, [pc, #148]	; (15fe4 <TCPIP_Helper_StringToMACAddress+0xbc>)
   15f50:	5c51      	ldrb	r1, [r2, r1]
   15f52:	f011 0f44 	tst.w	r1, #68	; 0x44
   15f56:	d03e      	beq.n	15fd6 <TCPIP_Helper_StringToMACAddress+0xae>
   15f58:	4604      	mov	r4, r0
    for(ix=0; ix<6; ix++)
   15f5a:	2500      	movs	r5, #0
    pAdd = convAddr;
   15f5c:	466f      	mov	r7, sp
        if(!isxdigit(beg[0]) || !isxdigit(beg[1]))
   15f5e:	f8df 9084 	ldr.w	r9, [pc, #132]	; 15fe4 <TCPIP_Helper_StringToMACAddress+0xbc>
   15f62:	e00f      	b.n	15f84 <TCPIP_Helper_StringToMACAddress+0x5c>
    for(ix=0; ix<6; ix++)
   15f64:	3501      	adds	r5, #1
   15f66:	2d06      	cmp	r5, #6
   15f68:	d01e      	beq.n	15fa8 <TCPIP_Helper_StringToMACAddress+0x80>
        if(!isxdigit(beg[0]) || !isxdigit(beg[1]))
   15f6a:	78d3      	ldrb	r3, [r2, #3]
   15f6c:	f813 1009 	ldrb.w	r1, [r3, r9]
   15f70:	f011 0f44 	tst.w	r1, #68	; 0x44
   15f74:	d031      	beq.n	15fda <TCPIP_Helper_StringToMACAddress+0xb2>
   15f76:	7912      	ldrb	r2, [r2, #4]
   15f78:	3403      	adds	r4, #3
   15f7a:	f812 1009 	ldrb.w	r1, [r2, r9]
   15f7e:	f011 0f44 	tst.w	r1, #68	; 0x44
   15f82:	d02c      	beq.n	15fde <TCPIP_Helper_StringToMACAddress+0xb6>
        {
            return false;
        }

        // found valid byte
        hexDigit.v[0] = beg[1];
   15f84:	f362 0607 	bfi	r6, r2, #0, #8
        hexDigit.v[1] = beg[0];
   15f88:	f363 260f 	bfi	r6, r3, #8, #8
        *pAdd++ = hexatob(hexDigit.Val);
   15f8c:	b2b0      	uxth	r0, r6
   15f8e:	f007 ff56 	bl	1de3e <hexatob>
   15f92:	f807 0b01 	strb.w	r0, [r7], #1

        // next colon number
        beg += 2;
        if(beg[0] == '\0')
   15f96:	4622      	mov	r2, r4
   15f98:	78a3      	ldrb	r3, [r4, #2]
   15f9a:	b12b      	cbz	r3, 15fa8 <TCPIP_Helper_StringToMACAddress+0x80>
        {
            break;  // done
        }
        else if(beg[0] != ':' && beg[0] != '-')
   15f9c:	2b3a      	cmp	r3, #58	; 0x3a
   15f9e:	d0e1      	beq.n	15f64 <TCPIP_Helper_StringToMACAddress+0x3c>
   15fa0:	2b2d      	cmp	r3, #45	; 0x2d
   15fa2:	d0df      	beq.n	15f64 <TCPIP_Helper_StringToMACAddress+0x3c>
        {
            return false;   // invalid delimiter
   15fa4:	2000      	movs	r0, #0
   15fa6:	e00d      	b.n	15fc4 <TCPIP_Helper_StringToMACAddress+0x9c>
        }
        beg++; // next digit
    }

    if(macAddr)
   15fa8:	f1b8 0f00 	cmp.w	r8, #0
   15fac:	d006      	beq.n	15fbc <TCPIP_Helper_StringToMACAddress+0x94>
    {
        memcpy(macAddr, convAddr, sizeof(convAddr));
   15fae:	9800      	ldr	r0, [sp, #0]
   15fb0:	f8c8 0000 	str.w	r0, [r8]
   15fb4:	f8bd 3004 	ldrh.w	r3, [sp, #4]
   15fb8:	f8a8 3004 	strh.w	r3, [r8, #4]
    }
    
    return ix == 5 ? true : false;    // false if not enough digits    
   15fbc:	2d05      	cmp	r5, #5
   15fbe:	bf14      	ite	ne
   15fc0:	2000      	movne	r0, #0
   15fc2:	2001      	moveq	r0, #1
    
}
   15fc4:	b003      	add	sp, #12
   15fc6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return true;
   15fca:	2001      	movs	r0, #1
   15fcc:	e7fa      	b.n	15fc4 <TCPIP_Helper_StringToMACAddress+0x9c>
   15fce:	2001      	movs	r0, #1
   15fd0:	e7f8      	b.n	15fc4 <TCPIP_Helper_StringToMACAddress+0x9c>
            return false;
   15fd2:	2000      	movs	r0, #0
   15fd4:	e7f6      	b.n	15fc4 <TCPIP_Helper_StringToMACAddress+0x9c>
   15fd6:	2000      	movs	r0, #0
   15fd8:	e7f4      	b.n	15fc4 <TCPIP_Helper_StringToMACAddress+0x9c>
   15fda:	2000      	movs	r0, #0
   15fdc:	e7f2      	b.n	15fc4 <TCPIP_Helper_StringToMACAddress+0x9c>
   15fde:	2000      	movs	r0, #0
   15fe0:	e7f0      	b.n	15fc4 <TCPIP_Helper_StringToMACAddress+0x9c>
   15fe2:	bf00      	nop
   15fe4:	00013c61 	.word	0x00013c61

Disassembly of section .text._DRV_MIIM_ClientDeallocate%337:

00015fe8 <_DRV_MIIM_ClientDeallocate>:


// de-allocates a client
// MIIM object should be locked
static void _DRV_MIIM_ClientDeallocate( DRV_MIIM_CLIENT_DCPT* pClient)
{
   15fe8:	b570      	push	{r4, r5, r6, lr}
   15fea:	b08a      	sub	sp, #40	; 0x28
   15fec:	4604      	mov	r4, r0
// all operations owned by this client
static void _DRV_MIIM_PurgeClientOp(DRV_MIIM_CLIENT_DCPT* pClient)
{
    DRV_MIIM_OP_DCPT* pOpDcpt;
    SINGLE_LIST delList, busyList, completeList;
    DRV_MIIM_OBJ* pMiimObj = pClient->parentObj;
   15fee:	6845      	ldr	r5, [r0, #4]

}

void  Helper_SingleListInitialize(SINGLE_LIST* pL)
{
    pL->head = pL->tail = 0;
   15ff0:	2300      	movs	r3, #0
   15ff2:	9302      	str	r3, [sp, #8]
   15ff4:	9301      	str	r3, [sp, #4]
    pL->nNodes = 0;
   15ff6:	9303      	str	r3, [sp, #12]
    pL->head = pL->tail = 0;
   15ff8:	9305      	str	r3, [sp, #20]
   15ffa:	9304      	str	r3, [sp, #16]
    pL->nNodes = 0;
   15ffc:	9306      	str	r3, [sp, #24]
    pL->head = pL->tail = 0;
   15ffe:	9308      	str	r3, [sp, #32]
   16000:	9307      	str	r3, [sp, #28]
    pL->nNodes = 0;
   16002:	9309      	str	r3, [sp, #36]	; 0x24
    while((pOpDcpt = _DRV_MIIM_OpListRemove(&pMiimObj->busyOpList, DRV_MIIM_QTYPE_BUSY)) != 0)
   16004:	f105 067c 	add.w	r6, r5, #124	; 0x7c
    DRV_MIIM_OP_DCPT* pOpDcpt = (DRV_MIIM_OP_DCPT*)Helper_SingleListHeadRemove(pL);
   16008:	4630      	mov	r0, r6
   1600a:	f00a feaf 	bl	20d6c <Helper_SingleListHeadRemove>
    while((pOpDcpt = _DRV_MIIM_OpListRemove(&pMiimObj->busyOpList, DRV_MIIM_QTYPE_BUSY)) != 0)
   1600e:	4601      	mov	r1, r0
   16010:	b138      	cbz	r0, 16022 <_DRV_MIIM_ClientDeallocate+0x3a>
        if(pOpDcpt->pOwner == pClient)
   16012:	68cb      	ldr	r3, [r1, #12]
   16014:	429c      	cmp	r4, r3
            Helper_SingleListTailAdd(&delList, (SGL_LIST_NODE*)pOpDcpt);
   16016:	bf0c      	ite	eq
   16018:	a801      	addeq	r0, sp, #4
            Helper_SingleListTailAdd(&busyList, (SGL_LIST_NODE*)pOpDcpt);
   1601a:	a804      	addne	r0, sp, #16
   1601c:	f00b f865 	bl	210ea <Helper_SingleListTailAdd>
   16020:	e7f2      	b.n	16008 <_DRV_MIIM_ClientDeallocate+0x20>
    pMiimObj->busyOpList = busyList;
   16022:	f105 037c 	add.w	r3, r5, #124	; 0x7c
   16026:	aa04      	add	r2, sp, #16
   16028:	ca07      	ldmia	r2, {r0, r1, r2}
   1602a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    while((pOpDcpt = (DRV_MIIM_OP_DCPT*)delList.head) != 0)
   1602e:	9901      	ldr	r1, [sp, #4]
   16030:	b141      	cbz	r1, 16044 <_DRV_MIIM_ClientDeallocate+0x5c>
        _DRV_MIIM_ReleaseOpDcpt(pMiimObj, pOpDcpt, &delList, DRV_MIIM_QTYPE_BUSY);
   16032:	2602      	movs	r6, #2
   16034:	4633      	mov	r3, r6
   16036:	aa01      	add	r2, sp, #4
   16038:	4628      	mov	r0, r5
   1603a:	f008 f939 	bl	1e2b0 <_DRV_MIIM_ReleaseOpDcpt>
    while((pOpDcpt = (DRV_MIIM_OP_DCPT*)delList.head) != 0)
   1603e:	9901      	ldr	r1, [sp, #4]
   16040:	2900      	cmp	r1, #0
   16042:	d1f7      	bne.n	16034 <_DRV_MIIM_ClientDeallocate+0x4c>
    while((pOpDcpt = _DRV_MIIM_OpListRemove(&pMiimObj->completeOpList, DRV_MIIM_QTYPE_COMPLETE)) != 0)
   16044:	f105 0688 	add.w	r6, r5, #136	; 0x88
    DRV_MIIM_OP_DCPT* pOpDcpt = (DRV_MIIM_OP_DCPT*)Helper_SingleListHeadRemove(pL);
   16048:	4630      	mov	r0, r6
   1604a:	f00a fe8f 	bl	20d6c <Helper_SingleListHeadRemove>
    while((pOpDcpt = _DRV_MIIM_OpListRemove(&pMiimObj->completeOpList, DRV_MIIM_QTYPE_COMPLETE)) != 0)
   1604e:	4601      	mov	r1, r0
   16050:	b138      	cbz	r0, 16062 <_DRV_MIIM_ClientDeallocate+0x7a>
        if(pOpDcpt->pOwner == pClient)
   16052:	68cb      	ldr	r3, [r1, #12]
   16054:	429c      	cmp	r4, r3
            Helper_SingleListTailAdd(&delList, (SGL_LIST_NODE*)pOpDcpt);
   16056:	bf0c      	ite	eq
   16058:	a801      	addeq	r0, sp, #4
            Helper_SingleListTailAdd(&completeList, (SGL_LIST_NODE*)pOpDcpt);
   1605a:	a807      	addne	r0, sp, #28
   1605c:	f00b f845 	bl	210ea <Helper_SingleListTailAdd>
   16060:	e7f2      	b.n	16048 <_DRV_MIIM_ClientDeallocate+0x60>
    pMiimObj->completeOpList = completeList;
   16062:	f105 0388 	add.w	r3, r5, #136	; 0x88
   16066:	aa0a      	add	r2, sp, #40	; 0x28
   16068:	e912 0007 	ldmdb	r2, {r0, r1, r2}
   1606c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    while((pOpDcpt = (DRV_MIIM_OP_DCPT*)delList.head) != 0)
   16070:	9901      	ldr	r1, [sp, #4]
   16072:	b141      	cbz	r1, 16086 <_DRV_MIIM_ClientDeallocate+0x9e>
        _DRV_MIIM_ReleaseOpDcpt(pMiimObj, pOpDcpt, &delList, DRV_MIIM_QTYPE_COMPLETE);
   16074:	2603      	movs	r6, #3
   16076:	4633      	mov	r3, r6
   16078:	aa01      	add	r2, sp, #4
   1607a:	4628      	mov	r0, r5
   1607c:	f008 f918 	bl	1e2b0 <_DRV_MIIM_ReleaseOpDcpt>
    while((pOpDcpt = (DRV_MIIM_OP_DCPT*)delList.head) != 0)
   16080:	9901      	ldr	r1, [sp, #4]
   16082:	2900      	cmp	r1, #0
   16084:	d1f7      	bne.n	16076 <_DRV_MIIM_ClientDeallocate+0x8e>
    pClient->clientInUse = false ;
   16086:	2300      	movs	r3, #0
   16088:	8023      	strh	r3, [r4, #0]
    pClient->cliStatus = DRV_CLIENT_STATUS_ERROR;
   1608a:	23ff      	movs	r3, #255	; 0xff
   1608c:	7323      	strb	r3, [r4, #12]
    pClient->parentObj->numClients--;
   1608e:	6862      	ldr	r2, [r4, #4]
   16090:	88d3      	ldrh	r3, [r2, #6]
   16092:	3b01      	subs	r3, #1
   16094:	80d3      	strh	r3, [r2, #6]
    pClient->parentObj->objFlags &= ~DRV_MIIM_OBJ_FLAG_EXCLUSIVE;
   16096:	6862      	ldr	r2, [r4, #4]
   16098:	8893      	ldrh	r3, [r2, #4]
   1609a:	f023 0304 	bic.w	r3, r3, #4
   1609e:	8093      	strh	r3, [r2, #4]
}
   160a0:	b00a      	add	sp, #40	; 0x28
   160a2:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_IPV4_DeInitialize%338:

000160a4 <TCPIP_IPV4_DeInitialize>:
    if(ipv4InitCount > 0)
   160a4:	4b2b      	ldr	r3, [pc, #172]	; (16154 <TCPIP_IPV4_DeInitialize+0xb0>)
   160a6:	881b      	ldrh	r3, [r3, #0]
   160a8:	b903      	cbnz	r3, 160ac <TCPIP_IPV4_DeInitialize+0x8>
   160aa:	4770      	bx	lr
{
   160ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   160b0:	b084      	sub	sp, #16
   160b2:	4607      	mov	r7, r0
        TCPIP_IPV4_ArpListPurge(stackCtrl->pNetIf);
   160b4:	6946      	ldr	r6, [r0, #20]
    TCPIP_Helper_SingleListInitialize (&newList);
   160b6:	a801      	add	r0, sp, #4
   160b8:	f00b ffa2 	bl	22000 <TCPIP_Helper_SingleListInitialize>
    TCPIP_Helper_ProtectedSingleListLock(pList);
   160bc:	4826      	ldr	r0, [pc, #152]	; (16158 <TCPIP_IPV4_DeInitialize+0xb4>)
   160be:	f00a fc57 	bl	20970 <TCPIP_Helper_ProtectedSingleListLock>
    while((pEntry = (IPV4_ARP_ENTRY*)TCPIP_Helper_SingleListHeadRemove(&pList->list)) != 0)
   160c2:	f8df 9094 	ldr.w	r9, [pc, #148]	; 16158 <TCPIP_IPV4_DeInitialize+0xb4>
            TCPIP_Helper_SingleListTailAdd(&ipv4ArpPool, (SGL_LIST_NODE*)pEntry); 
   160c6:	f8df 8094 	ldr.w	r8, [pc, #148]	; 1615c <TCPIP_IPV4_DeInitialize+0xb8>
        TCPIP_PKT_PacketAcknowledge(pTxPkt, ackRes);
   160ca:	f04f 0a03 	mov.w	sl, #3
   160ce:	e00a      	b.n	160e6 <TCPIP_IPV4_DeInitialize+0x42>
            pMacPkt = &pEntry->pTxPkt->macPkt;
   160d0:	68a5      	ldr	r5, [r4, #8]
   160d2:	e013      	b.n	160fc <TCPIP_IPV4_DeInitialize+0x58>
            if(pEntry->type == IPV4_ARP_PKT_TYPE_TX || pEntry->type == IPV4_ARP_PKT_TYPE_MAC)
   160d4:	7923      	ldrb	r3, [r4, #4]
   160d6:	3b01      	subs	r3, #1
   160d8:	b2db      	uxtb	r3, r3
   160da:	2b01      	cmp	r3, #1
   160dc:	d91a      	bls.n	16114 <TCPIP_IPV4_DeInitialize+0x70>
            TCPIP_Helper_SingleListTailAdd(&ipv4ArpPool, (SGL_LIST_NODE*)pEntry); 
   160de:	4621      	mov	r1, r4
   160e0:	4640      	mov	r0, r8
   160e2:	f00b f85d 	bl	211a0 <TCPIP_Helper_SingleListTailAdd>
    while((pEntry = (IPV4_ARP_ENTRY*)TCPIP_Helper_SingleListHeadRemove(&pList->list)) != 0)
   160e6:	4648      	mov	r0, r9
   160e8:	f00a fe86 	bl	20df8 <TCPIP_Helper_SingleListHeadRemove>
   160ec:	4604      	mov	r4, r0
   160ee:	b1c0      	cbz	r0, 16122 <TCPIP_IPV4_DeInitialize+0x7e>
        if(pEntry->type == IPV4_ARP_PKT_TYPE_TX)
   160f0:	7923      	ldrb	r3, [r4, #4]
   160f2:	2b01      	cmp	r3, #1
   160f4:	d0ec      	beq.n	160d0 <TCPIP_IPV4_DeInitialize+0x2c>
        else if(pEntry->type == IPV4_ARP_PKT_TYPE_MAC)
   160f6:	2b02      	cmp	r3, #2
   160f8:	d11c      	bne.n	16134 <TCPIP_IPV4_DeInitialize+0x90>
            pMacPkt = pEntry->pMacPkt; 
   160fa:	68a5      	ldr	r5, [r4, #8]
        pPktIf = (TCPIP_NET_IF*)TCPIP_STACK_IndexToNet(pEntry->arpIfIx);
   160fc:	7960      	ldrb	r0, [r4, #5]
   160fe:	f009 fe8d 	bl	1fe1c <TCPIP_STACK_IndexToNet>
        if(pNetIf == 0 || pNetIf == pPktIf)
   16102:	2e00      	cmp	r6, #0
   16104:	d0e6      	beq.n	160d4 <TCPIP_IPV4_DeInitialize+0x30>
   16106:	4286      	cmp	r6, r0
   16108:	d0e4      	beq.n	160d4 <TCPIP_IPV4_DeInitialize+0x30>
            TCPIP_Helper_SingleListTailAdd(&newList, (SGL_LIST_NODE*)pEntry);
   1610a:	4621      	mov	r1, r4
   1610c:	a801      	add	r0, sp, #4
   1610e:	f00b f847 	bl	211a0 <TCPIP_Helper_SingleListTailAdd>
   16112:	e7e8      	b.n	160e6 <TCPIP_IPV4_DeInitialize+0x42>
        TCPIP_PKT_PacketAcknowledge(pTxPkt, ackRes);
   16114:	4652      	mov	r2, sl
   16116:	f06f 0104 	mvn.w	r1, #4
   1611a:	4628      	mov	r0, r5
   1611c:	f007 fc3a 	bl	1d994 <_TCPIP_PKT_PacketAcknowledge>
   16120:	e7dd      	b.n	160de <TCPIP_IPV4_DeInitialize+0x3a>
    pList->list = newList;
   16122:	4b0d      	ldr	r3, [pc, #52]	; (16158 <TCPIP_IPV4_DeInitialize+0xb4>)
   16124:	aa04      	add	r2, sp, #16
   16126:	e912 0007 	ldmdb	r2, {r0, r1, r2}
   1612a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    TCPIP_Helper_ProtectedSingleListUnlock(pList);
   1612e:	4618      	mov	r0, r3
   16130:	f00a fe70 	bl	20e14 <TCPIP_Helper_ProtectedSingleListUnlock>
        if(stackCtrl->stackAction == TCPIP_STACK_ACTION_DEINIT)
   16134:	7f3b      	ldrb	r3, [r7, #28]
   16136:	2b02      	cmp	r3, #2
   16138:	d002      	beq.n	16140 <TCPIP_IPV4_DeInitialize+0x9c>
}
   1613a:	b004      	add	sp, #16
   1613c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            if (--ipv4InitCount == 0)
   16140:	4a04      	ldr	r2, [pc, #16]	; (16154 <TCPIP_IPV4_DeInitialize+0xb0>)
   16142:	8813      	ldrh	r3, [r2, #0]
   16144:	3b01      	subs	r3, #1
   16146:	b29b      	uxth	r3, r3
   16148:	8013      	strh	r3, [r2, #0]
   1614a:	2b00      	cmp	r3, #0
   1614c:	d1f5      	bne.n	1613a <TCPIP_IPV4_DeInitialize+0x96>
                TCPIP_IPV4_Cleanup();
   1614e:	f004 f87d 	bl	1a24c <TCPIP_IPV4_Cleanup>
}
   16152:	e7f2      	b.n	1613a <TCPIP_IPV4_DeInitialize+0x96>
   16154:	2000e71c 	.word	0x2000e71c
   16158:	2000e428 	.word	0x2000e428
   1615c:	2000e528 	.word	0x2000e528

Disassembly of section .text.TCPIP_STACK_KillStack%339:

00016160 <TCPIP_STACK_KillStack>:
{
   16160:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (tcpip_stack_tickH != SYS_TMR_HANDLE_INVALID)
   16164:	4b26      	ldr	r3, [pc, #152]	; (16200 <TCPIP_STACK_KillStack+0xa0>)
   16166:	6818      	ldr	r0, [r3, #0]
   16168:	f1b0 3fff 	cmp.w	r0, #4294967295
   1616c:	d137      	bne.n	161de <TCPIP_STACK_KillStack+0x7e>
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   1616e:	4b25      	ldr	r3, [pc, #148]	; (16204 <TCPIP_STACK_KillStack+0xa4>)
   16170:	681c      	ldr	r4, [r3, #0]
   16172:	4b25      	ldr	r3, [pc, #148]	; (16208 <TCPIP_STACK_KillStack+0xa8>)
   16174:	681b      	ldr	r3, [r3, #0]
   16176:	2b00      	cmp	r3, #0
   16178:	dd0f      	ble.n	1619a <TCPIP_STACK_KillStack+0x3a>
   1617a:	2500      	movs	r5, #0
        TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pNetIf, TCPIP_STACK_ACTION_DEINIT, TCPIP_MAC_POWER_DOWN);
   1617c:	4e22      	ldr	r6, [pc, #136]	; (16208 <TCPIP_STACK_KillStack+0xa8>)
   1617e:	f04f 0803 	mov.w	r8, #3
   16182:	2702      	movs	r7, #2
   16184:	4643      	mov	r3, r8
   16186:	463a      	mov	r2, r7
   16188:	4621      	mov	r1, r4
   1618a:	4630      	mov	r0, r6
   1618c:	f004 fe94 	bl	1aeb8 <TCPIP_STACK_BringNetDown>
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   16190:	3501      	adds	r5, #1
   16192:	346c      	adds	r4, #108	; 0x6c
   16194:	6833      	ldr	r3, [r6, #0]
   16196:	42ab      	cmp	r3, r5
   16198:	dcf4      	bgt.n	16184 <TCPIP_STACK_KillStack+0x24>
    TCPIP_PKT_Deinitialize();
   1619a:	f00b febf 	bl	21f1c <TCPIP_PKT_Deinitialize>
    if(tcpip_stack_ctrl_data.memH != 0)
   1619e:	4b1a      	ldr	r3, [pc, #104]	; (16208 <TCPIP_STACK_KillStack+0xa8>)
   161a0:	68d8      	ldr	r0, [r3, #12]
   161a2:	b148      	cbz	r0, 161b8 <TCPIP_STACK_KillStack+0x58>
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   161a4:	68c3      	ldr	r3, [r0, #12]
   161a6:	4a17      	ldr	r2, [pc, #92]	; (16204 <TCPIP_STACK_KillStack+0xa4>)
   161a8:	6811      	ldr	r1, [r2, #0]
   161aa:	4798      	blx	r3
        if(TCPIP_HEAP_Delete(tcpip_stack_ctrl_data.memH) < 0)     // destroy the heap
   161ac:	4b16      	ldr	r3, [pc, #88]	; (16208 <TCPIP_STACK_KillStack+0xa8>)
   161ae:	68d8      	ldr	r0, [r3, #12]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Delete)(h);
   161b0:	6803      	ldr	r3, [r0, #0]
   161b2:	4798      	blx	r3
   161b4:	2800      	cmp	r0, #0
   161b6:	db19      	blt.n	161ec <TCPIP_STACK_KillStack+0x8c>
    tcpip_stack_ctrl_data.memH = 0;
   161b8:	4a13      	ldr	r2, [pc, #76]	; (16208 <TCPIP_STACK_KillStack+0xa8>)
   161ba:	2300      	movs	r3, #0
   161bc:	60d3      	str	r3, [r2, #12]
    tcpip_stack_ctrl_data.heapType = 0;
   161be:	7413      	strb	r3, [r2, #16]
    tcpipNetIf = 0;
   161c0:	4910      	ldr	r1, [pc, #64]	; (16204 <TCPIP_STACK_KillStack+0xa4>)
   161c2:	600b      	str	r3, [r1, #0]
    tcpip_stack_ctrl_data.nIfs = 0;
   161c4:	6013      	str	r3, [r2, #0]
    tcpip_stack_ctrl_data.nModules = 0;
   161c6:	6093      	str	r3, [r2, #8]
    tcpip_stack_status = SYS_STATUS_UNINITIALIZED;
   161c8:	4a10      	ldr	r2, [pc, #64]	; (1620c <TCPIP_STACK_KillStack+0xac>)
   161ca:	7013      	strb	r3, [r2, #0]
    stackAsyncSignalCount = 0;
   161cc:	4a10      	ldr	r2, [pc, #64]	; (16210 <TCPIP_STACK_KillStack+0xb0>)
   161ce:	6013      	str	r3, [r2, #0]
    memset(&tcpip_heap_config, 0, sizeof(tcpip_heap_config));
   161d0:	4a10      	ldr	r2, [pc, #64]	; (16214 <TCPIP_STACK_KillStack+0xb4>)
   161d2:	6013      	str	r3, [r2, #0]
   161d4:	6053      	str	r3, [r2, #4]
   161d6:	6093      	str	r3, [r2, #8]
   161d8:	60d3      	str	r3, [r2, #12]
}
   161da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    
*/

static __inline__ void  __attribute__((always_inline)) SYS_TMR_CallbackStop ( SYS_TMR_HANDLE handle )
{
	SYS_TIME_TimerDestroy(handle);
   161de:	f007 ffb5 	bl	1e14c <SYS_TIME_TimerDestroy>
        tcpip_stack_tickH = SYS_TMR_HANDLE_INVALID;
   161e2:	4b07      	ldr	r3, [pc, #28]	; (16200 <TCPIP_STACK_KillStack+0xa0>)
   161e4:	f04f 32ff 	mov.w	r2, #4294967295
   161e8:	601a      	str	r2, [r3, #0]
   161ea:	e7c0      	b.n	1616e <TCPIP_STACK_KillStack+0xe>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Heap Delete fail!\r\n");
   161ec:	f00b feae 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
   161f0:	2800      	cmp	r0, #0
   161f2:	d0e1      	beq.n	161b8 <TCPIP_STACK_KillStack+0x58>
   161f4:	f00b fea4 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
   161f8:	4907      	ldr	r1, [pc, #28]	; (16218 <TCPIP_STACK_KillStack+0xb8>)
   161fa:	f004 fab7 	bl	1a76c <SYS_CONSOLE_Print>
   161fe:	e7db      	b.n	161b8 <TCPIP_STACK_KillStack+0x58>
   16200:	2000e654 	.word	0x2000e654
   16204:	2000e648 	.word	0x2000e648
   16208:	2000e2f0 	.word	0x2000e2f0
   1620c:	2000e729 	.word	0x2000e729
   16210:	2000e63c 	.word	0x2000e63c
   16214:	2000e518 	.word	0x2000e518
   16218:	00008600 	.word	0x00008600

Disassembly of section .text.__swbuf_r%340:

0001621c <__swbuf_r>:
   1621c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1621e:	460e      	mov	r6, r1
   16220:	4614      	mov	r4, r2
   16222:	4605      	mov	r5, r0
   16224:	b118      	cbz	r0, 1622e <__swbuf_r+0x12>
   16226:	6983      	ldr	r3, [r0, #24]
   16228:	b90b      	cbnz	r3, 1622e <__swbuf_r+0x12>
   1622a:	f005 f929 	bl	1b480 <__sinit>
   1622e:	4b27      	ldr	r3, [pc, #156]	; (162cc <__swbuf_r+0xb0>)
   16230:	429c      	cmp	r4, r3
   16232:	d130      	bne.n	16296 <__swbuf_r+0x7a>
   16234:	686c      	ldr	r4, [r5, #4]
   16236:	69a3      	ldr	r3, [r4, #24]
   16238:	60a3      	str	r3, [r4, #8]
   1623a:	89a3      	ldrh	r3, [r4, #12]
   1623c:	0719      	lsls	r1, r3, #28
   1623e:	d534      	bpl.n	162aa <__swbuf_r+0x8e>
   16240:	6923      	ldr	r3, [r4, #16]
   16242:	2b00      	cmp	r3, #0
   16244:	d031      	beq.n	162aa <__swbuf_r+0x8e>
   16246:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   1624a:	b2f6      	uxtb	r6, r6
   1624c:	049a      	lsls	r2, r3, #18
   1624e:	4637      	mov	r7, r6
   16250:	d534      	bpl.n	162bc <__swbuf_r+0xa0>
   16252:	6923      	ldr	r3, [r4, #16]
   16254:	6820      	ldr	r0, [r4, #0]
   16256:	1ac0      	subs	r0, r0, r3
   16258:	6963      	ldr	r3, [r4, #20]
   1625a:	4283      	cmp	r3, r0
   1625c:	dc04      	bgt.n	16268 <__swbuf_r+0x4c>
   1625e:	4621      	mov	r1, r4
   16260:	4628      	mov	r0, r5
   16262:	f005 ff15 	bl	1c090 <_fflush_r>
   16266:	bb30      	cbnz	r0, 162b6 <__swbuf_r+0x9a>
   16268:	68a3      	ldr	r3, [r4, #8]
   1626a:	3b01      	subs	r3, #1
   1626c:	60a3      	str	r3, [r4, #8]
   1626e:	6823      	ldr	r3, [r4, #0]
   16270:	1c5a      	adds	r2, r3, #1
   16272:	6022      	str	r2, [r4, #0]
   16274:	701e      	strb	r6, [r3, #0]
   16276:	6963      	ldr	r3, [r4, #20]
   16278:	3001      	adds	r0, #1
   1627a:	4283      	cmp	r3, r0
   1627c:	d004      	beq.n	16288 <__swbuf_r+0x6c>
   1627e:	89a3      	ldrh	r3, [r4, #12]
   16280:	07db      	lsls	r3, r3, #31
   16282:	d506      	bpl.n	16292 <__swbuf_r+0x76>
   16284:	2e0a      	cmp	r6, #10
   16286:	d104      	bne.n	16292 <__swbuf_r+0x76>
   16288:	4621      	mov	r1, r4
   1628a:	4628      	mov	r0, r5
   1628c:	f005 ff00 	bl	1c090 <_fflush_r>
   16290:	b988      	cbnz	r0, 162b6 <__swbuf_r+0x9a>
   16292:	4638      	mov	r0, r7
   16294:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   16296:	4b0e      	ldr	r3, [pc, #56]	; (162d0 <__swbuf_r+0xb4>)
   16298:	429c      	cmp	r4, r3
   1629a:	d101      	bne.n	162a0 <__swbuf_r+0x84>
   1629c:	68ac      	ldr	r4, [r5, #8]
   1629e:	e7ca      	b.n	16236 <__swbuf_r+0x1a>
   162a0:	4b0c      	ldr	r3, [pc, #48]	; (162d4 <__swbuf_r+0xb8>)
   162a2:	429c      	cmp	r4, r3
   162a4:	bf08      	it	eq
   162a6:	68ec      	ldreq	r4, [r5, #12]
   162a8:	e7c5      	b.n	16236 <__swbuf_r+0x1a>
   162aa:	4621      	mov	r1, r4
   162ac:	4628      	mov	r0, r5
   162ae:	f7fe feb7 	bl	15020 <__swsetup_r>
   162b2:	2800      	cmp	r0, #0
   162b4:	d0c7      	beq.n	16246 <__swbuf_r+0x2a>
   162b6:	f04f 37ff 	mov.w	r7, #4294967295
   162ba:	e7ea      	b.n	16292 <__swbuf_r+0x76>
   162bc:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   162c0:	81a3      	strh	r3, [r4, #12]
   162c2:	6e23      	ldr	r3, [r4, #96]	; 0x60
   162c4:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
   162c8:	6623      	str	r3, [r4, #96]	; 0x60
   162ca:	e7c2      	b.n	16252 <__swbuf_r+0x36>
   162cc:	2000e330 	.word	0x2000e330
   162d0:	2000e350 	.word	0x2000e350
   162d4:	2000e310 	.word	0x2000e310

Disassembly of section .text._GetMaxSegSizeOption%341:

000162d8 <_GetMaxSegSizeOption>:
	vOptionsBytes = (h->DataOffset.Val << 2) - sizeof(*h);
   162d8:	7b03      	ldrb	r3, [r0, #12]
   162da:	f3c3 1303 	ubfx	r3, r3, #4, #4
   162de:	009b      	lsls	r3, r3, #2
   162e0:	3b14      	subs	r3, #20
    if(vOptionsBytes == 0u)
   162e2:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
   162e6:	d043      	beq.n	16370 <_GetMaxSegSizeOption+0x98>
{
   162e8:	b470      	push	{r4, r5, r6}
   162ea:	b083      	sub	sp, #12
    pOption = (uint8_t*)(h + 1);
   162ec:	3014      	adds	r0, #20
    pEnd = pOption + vOptionsBytes;
   162ee:	18c6      	adds	r6, r0, r3
    while(vOptionsBytes-- && pOption < pEnd)
   162f0:	e01f      	b.n	16332 <_GetMaxSegSizeOption+0x5a>
            if(vOptionsBytes < 3u)
   162f2:	2b02      	cmp	r3, #2
   162f4:	d942      	bls.n	1637c <_GetMaxSegSizeOption+0xa4>
            wMSS = 0;
   162f6:	2300      	movs	r3, #0
   162f8:	f8ad 3006 	strh.w	r3, [sp, #6]
            if(vOption == 4u)
   162fc:	7853      	ldrb	r3, [r2, #1]
   162fe:	2b04      	cmp	r3, #4
   16300:	d00c      	beq.n	1631c <_GetMaxSegSizeOption+0x44>
            if(wMSS < TCP_MIN_DEFAULT_MTU)
   16302:	f8bd 0006 	ldrh.w	r0, [sp, #6]
   16306:	f240 53b4 	movw	r3, #1460	; 0x5b4
   1630a:	4298      	cmp	r0, r3
   1630c:	bf28      	it	cs
   1630e:	4618      	movcs	r0, r3
   16310:	f5b0 7f06 	cmp.w	r0, #536	; 0x218
   16314:	bf38      	it	cc
   16316:	f44f 7006 	movcc.w	r0, #536	; 0x218
   1631a:	e037      	b.n	1638c <_GetMaxSegSizeOption+0xb4>
                ((uint8_t*)&wMSS)[1] = *pOption++;
   1631c:	7893      	ldrb	r3, [r2, #2]
   1631e:	f88d 3007 	strb.w	r3, [sp, #7]
                ((uint8_t*)&wMSS)[0] = *pOption++;
   16322:	78d3      	ldrb	r3, [r2, #3]
   16324:	f88d 3006 	strb.w	r3, [sp, #6]
   16328:	e7eb      	b.n	16302 <_GetMaxSegSizeOption+0x2a>
            pOption += vOption;
   1632a:	1c88      	adds	r0, r1, #2
   1632c:	4410      	add	r0, r2
            vOptionsBytes -= vOption;
   1632e:	1a5b      	subs	r3, r3, r1
   16330:	b2db      	uxtb	r3, r3
   16332:	18c5      	adds	r5, r0, r3
{
   16334:	4602      	mov	r2, r0
   16336:	3b01      	subs	r3, #1
   16338:	4418      	add	r0, r3
   1633a:	1a83      	subs	r3, r0, r2
   1633c:	b2db      	uxtb	r3, r3
    while(vOptionsBytes-- && pOption < pEnd)
   1633e:	42aa      	cmp	r2, r5
   16340:	d022      	beq.n	16388 <_GetMaxSegSizeOption+0xb0>
   16342:	42b2      	cmp	r2, r6
   16344:	d211      	bcs.n	1636a <_GetMaxSegSizeOption+0x92>
        vOption = *pOption++;
   16346:	4614      	mov	r4, r2
   16348:	f814 1b01 	ldrb.w	r1, [r4], #1
        if(vOption == 0u)	// End of Options list
   1634c:	b199      	cbz	r1, 16376 <_GetMaxSegSizeOption+0x9e>
        if(vOption == 1u)	// NOP option
   1634e:	2901      	cmp	r1, #1
   16350:	d009      	beq.n	16366 <_GetMaxSegSizeOption+0x8e>
        if(vOption == 2u)	// Maximum Segment Size option
   16352:	2902      	cmp	r1, #2
   16354:	d0cd      	beq.n	162f2 <_GetMaxSegSizeOption+0x1a>
            if(vOptionsBytes < 2u)
   16356:	2b01      	cmp	r3, #1
   16358:	d913      	bls.n	16382 <_GetMaxSegSizeOption+0xaa>
            vOption = *pOption++;
   1635a:	7851      	ldrb	r1, [r2, #1]
            if(vOptionsBytes < vOption)
   1635c:	4299      	cmp	r1, r3
   1635e:	d9e4      	bls.n	1632a <_GetMaxSegSizeOption+0x52>
    return TCP_MIN_DEFAULT_MTU;
   16360:	f44f 7006 	mov.w	r0, #536	; 0x218
   16364:	e012      	b.n	1638c <_GetMaxSegSizeOption+0xb4>
        vOption = *pOption++;
   16366:	4622      	mov	r2, r4
   16368:	e7e7      	b.n	1633a <_GetMaxSegSizeOption+0x62>
    return TCP_MIN_DEFAULT_MTU;
   1636a:	f44f 7006 	mov.w	r0, #536	; 0x218
   1636e:	e00d      	b.n	1638c <_GetMaxSegSizeOption+0xb4>
        return TCP_MIN_DEFAULT_MTU;
   16370:	f44f 7006 	mov.w	r0, #536	; 0x218
}
   16374:	4770      	bx	lr
    return TCP_MIN_DEFAULT_MTU;
   16376:	f44f 7006 	mov.w	r0, #536	; 0x218
   1637a:	e007      	b.n	1638c <_GetMaxSegSizeOption+0xb4>
   1637c:	f44f 7006 	mov.w	r0, #536	; 0x218
   16380:	e004      	b.n	1638c <_GetMaxSegSizeOption+0xb4>
   16382:	f44f 7006 	mov.w	r0, #536	; 0x218
   16386:	e001      	b.n	1638c <_GetMaxSegSizeOption+0xb4>
   16388:	f44f 7006 	mov.w	r0, #536	; 0x218
}
   1638c:	b003      	add	sp, #12
   1638e:	bc70      	pop	{r4, r5, r6}
   16390:	4770      	bx	lr

Disassembly of section .text.CommandIperfStop%342:

00016394 <CommandIperfStop>:
{
   16394:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16396:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   16398:	6845      	ldr	r5, [r0, #4]
    if(argc == 1)
   1639a:	2901      	cmp	r1, #1
   1639c:	d008      	beq.n	163b0 <CommandIperfStop+0x1c>
   1639e:	4616      	mov	r6, r2
    else if(argc == 3)
   163a0:	2903      	cmp	r1, #3
   163a2:	d020      	beq.n	163e6 <CommandIperfStop+0x52>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: iperfk <-i index>\r\n");
   163a4:	6823      	ldr	r3, [r4, #0]
   163a6:	681b      	ldr	r3, [r3, #0]
   163a8:	491f      	ldr	r1, [pc, #124]	; (16428 <CommandIperfStop+0x94>)
   163aa:	4628      	mov	r0, r5
   163ac:	4798      	blx	r3
}
   163ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "iperfk: Using index 0\r\n");
   163b0:	6803      	ldr	r3, [r0, #0]
   163b2:	681b      	ldr	r3, [r3, #0]
   163b4:	491d      	ldr	r1, [pc, #116]	; (1642c <CommandIperfStop+0x98>)
   163b6:	4628      	mov	r0, r5
   163b8:	4798      	blx	r3
    int iperfIndex = 0;
   163ba:	2200      	movs	r2, #0
    if(iperfIndex < 0 || iperfIndex >= nIperfSessions)
   163bc:	4b1c      	ldr	r3, [pc, #112]	; (16430 <CommandIperfStop+0x9c>)
   163be:	681b      	ldr	r3, [r3, #0]
   163c0:	4293      	cmp	r3, r2
   163c2:	dd21      	ble.n	16408 <CommandIperfStop+0x74>
    pIState = gIperfState + iperfIndex;	
   163c4:	491b      	ldr	r1, [pc, #108]	; (16434 <CommandIperfStop+0xa0>)
   163c6:	23d8      	movs	r3, #216	; 0xd8
   163c8:	fb03 1302 	mla	r3, r3, r2, r1
    if(pIState->state == IPERF_STANDBY_STATE)
   163cc:	f893 10ce 	ldrb.w	r1, [r3, #206]	; 0xce
   163d0:	2901      	cmp	r1, #1
   163d2:	d022      	beq.n	1641a <CommandIperfStop+0x86>
        pIState->stopRequested = true;
   163d4:	2101      	movs	r1, #1
   163d6:	f883 10cf 	strb.w	r1, [r3, #207]	; 0xcf
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: trying to stop iperf instance %d...\r\n", iperfIndex);
   163da:	6823      	ldr	r3, [r4, #0]
   163dc:	685b      	ldr	r3, [r3, #4]
   163de:	4916      	ldr	r1, [pc, #88]	; (16438 <CommandIperfStop+0xa4>)
   163e0:	4628      	mov	r0, r5
   163e2:	4798      	blx	r3
   163e4:	e7e3      	b.n	163ae <CommandIperfStop+0x1a>
        if((strcmp(argv[1], "-i") == 0) || (strcmp(argv[1], "--index") == 0))
   163e6:	6857      	ldr	r7, [r2, #4]
   163e8:	4914      	ldr	r1, [pc, #80]	; (1643c <CommandIperfStop+0xa8>)
   163ea:	4638      	mov	r0, r7
   163ec:	f00b fa86 	bl	218fc <strcmp>
   163f0:	b128      	cbz	r0, 163fe <CommandIperfStop+0x6a>
   163f2:	4913      	ldr	r1, [pc, #76]	; (16440 <CommandIperfStop+0xac>)
   163f4:	4638      	mov	r0, r7
   163f6:	f00b fa81 	bl	218fc <strcmp>
   163fa:	2800      	cmp	r0, #0
   163fc:	d1d2      	bne.n	163a4 <CommandIperfStop+0x10>
            iperfIndex = atoi(argv[2]);
   163fe:	68b0      	ldr	r0, [r6, #8]
   16400:	f00b fe74 	bl	220ec <atoi>
    if(iperfIndex < 0 || iperfIndex >= nIperfSessions)
   16404:	1e02      	subs	r2, r0, #0
   16406:	dad9      	bge.n	163bc <CommandIperfStop+0x28>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "\r\niperf: Invalid session number. Min: 0, Max: %d\r\n", nIperfSessions - 1);
   16408:	4b09      	ldr	r3, [pc, #36]	; (16430 <CommandIperfStop+0x9c>)
   1640a:	681a      	ldr	r2, [r3, #0]
   1640c:	6823      	ldr	r3, [r4, #0]
   1640e:	685b      	ldr	r3, [r3, #4]
   16410:	3a01      	subs	r2, #1
   16412:	490c      	ldr	r1, [pc, #48]	; (16444 <CommandIperfStop+0xb0>)
   16414:	4628      	mov	r0, r5
   16416:	4798      	blx	r3
        return;
   16418:	e7c9      	b.n	163ae <CommandIperfStop+0x1a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "\r\niperf session: not started!\r\n");
   1641a:	6823      	ldr	r3, [r4, #0]
   1641c:	681b      	ldr	r3, [r3, #0]
   1641e:	490a      	ldr	r1, [pc, #40]	; (16448 <CommandIperfStop+0xb4>)
   16420:	4628      	mov	r0, r5
   16422:	4798      	blx	r3
   16424:	e7c3      	b.n	163ae <CommandIperfStop+0x1a>
   16426:	bf00      	nop
   16428:	00004db8 	.word	0x00004db8
   1642c:	00004d50 	.word	0x00004d50
   16430:	2000e5f8 	.word	0x2000e5f8
   16434:	2000dbb0 	.word	0x2000dbb0
   16438:	00004d88 	.word	0x00004d88
   1643c:	00004c80 	.word	0x00004c80
   16440:	00004c84 	.word	0x00004c84
   16444:	00004ca8 	.word	0x00004ca8
   16448:	00004d68 	.word	0x00004d68

Disassembly of section .text.TCPIP_IPERF_Initialize%343:

0001644c <TCPIP_IPERF_Initialize>:
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_UP)
   1644c:	7f03      	ldrb	r3, [r0, #28]
   1644e:	2b03      	cmp	r3, #3
   16450:	d047      	beq.n	164e2 <TCPIP_IPERF_Initialize+0x96>
{
   16452:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if(iperfInitCount == 0)
   16456:	4b25      	ldr	r3, [pc, #148]	; (164ec <TCPIP_IPERF_Initialize+0xa0>)
   16458:	681e      	ldr	r6, [r3, #0]
   1645a:	2e00      	cmp	r6, #0
   1645c:	d139      	bne.n	164d2 <TCPIP_IPERF_Initialize+0x86>
        nIperfSessions = sizeof(gIperfState) / sizeof(*gIperfState);
   1645e:	4b24      	ldr	r3, [pc, #144]	; (164f0 <TCPIP_IPERF_Initialize+0xa4>)
   16460:	2201      	movs	r2, #1
   16462:	601a      	str	r2, [r3, #0]
        for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
   16464:	4c23      	ldr	r4, [pc, #140]	; (164f4 <TCPIP_IPERF_Initialize+0xa8>)
	        memset( pIState, 0, sizeof(*pIState) );
   16466:	2500      	movs	r5, #0
	        pIState->signalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_IPERF_Task, 0);
   16468:	4f23      	ldr	r7, [pc, #140]	; (164f8 <TCPIP_IPERF_Initialize+0xac>)
        for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
   1646a:	4698      	mov	r8, r3
	        memset( pIState, 0, sizeof(*pIState) );
   1646c:	22d8      	movs	r2, #216	; 0xd8
   1646e:	4629      	mov	r1, r5
   16470:	4620      	mov	r0, r4
   16472:	f00b fb83 	bl	21b7c <memset>
	        pIState->state = IPERF_STANDBY_STATE;
   16476:	2301      	movs	r3, #1
   16478:	f884 30ce 	strb.w	r3, [r4, #206]	; 0xce
	        pIState->stopRequested = false;
   1647c:	f884 50cf 	strb.w	r5, [r4, #207]	; 0xcf
	        pIState->tcpClientSock = INVALID_SOCKET;
   16480:	f64f 73ff 	movw	r3, #65535	; 0xffff
   16484:	8763      	strh	r3, [r4, #58]	; 0x3a
	        pIState->tcpServerSock = INVALID_SOCKET;
   16486:	8723      	strh	r3, [r4, #56]	; 0x38
	        pIState->udpSock = INVALID_SOCKET;
   16488:	87a3      	strh	r3, [r4, #60]	; 0x3c
	        pIState->txBuffSize = TCPIP_IPERF_TX_BUFFER_SIZE;
   1648a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   1648e:	f8c4 20b8 	str.w	r2, [r4, #184]	; 0xb8
	        pIState->rxBuffSize = TCPIP_IPERF_RX_BUFFER_SIZE;
   16492:	f8c4 20bc 	str.w	r2, [r4, #188]	; 0xbc
               pIState->waitCount = 0;
   16496:	f884 50d5 	strb.w	r5, [r4, #213]	; 0xd5
               pIState->sockWaitToSend = 0;
   1649a:	f884 50d4 	strb.w	r5, [r4, #212]	; 0xd4
               pIState->mTypeOfService = 0xFF;
   1649e:	7523      	strb	r3, [r4, #20]
	        pIState->signalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_IPERF_Task, 0);
   164a0:	462a      	mov	r2, r5
   164a2:	4639      	mov	r1, r7
   164a4:	2020      	movs	r0, #32
   164a6:	f006 fbf3 	bl	1cc90 <_TCPIPStackSignalHandlerRegister>
   164aa:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
	        if(pIState->signalHandle == 0)
   164ae:	b1d8      	cbz	r0, 164e8 <TCPIP_IPERF_Initialize+0x9c>
        for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
   164b0:	3601      	adds	r6, #1
   164b2:	34d8      	adds	r4, #216	; 0xd8
   164b4:	f8d8 3000 	ldr.w	r3, [r8]
   164b8:	42b3      	cmp	r3, r6
   164ba:	dcd7      	bgt.n	1646c <TCPIP_IPERF_Initialize+0x20>
		if(!SYS_CMD_ADDGRP(iperfCmdTbl, sizeof(iperfCmdTbl)/sizeof(*iperfCmdTbl), "iperf", ": iperf commands"))
   164bc:	4a0f      	ldr	r2, [pc, #60]	; (164fc <TCPIP_IPERF_Initialize+0xb0>)
   164be:	f602 13cc 	addw	r3, r2, #2508	; 0x9cc
   164c2:	f502 621e 	add.w	r2, r2, #2528	; 0x9e0
   164c6:	2104      	movs	r1, #4
   164c8:	480d      	ldr	r0, [pc, #52]	; (16500 <TCPIP_IPERF_Initialize+0xb4>)
   164ca:	f004 f919 	bl	1a700 <SYS_CMD_ADDGRP>
   164ce:	4603      	mov	r3, r0
   164d0:	b120      	cbz	r0, 164dc <TCPIP_IPERF_Initialize+0x90>
    iperfInitCount++;
   164d2:	4a06      	ldr	r2, [pc, #24]	; (164ec <TCPIP_IPERF_Initialize+0xa0>)
   164d4:	6813      	ldr	r3, [r2, #0]
   164d6:	3301      	adds	r3, #1
   164d8:	6013      	str	r3, [r2, #0]
    return true;
   164da:	2301      	movs	r3, #1
}
   164dc:	4618      	mov	r0, r3
   164de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return true;
   164e2:	2301      	movs	r3, #1
}
   164e4:	4618      	mov	r0, r3
   164e6:	4770      	bx	lr
	            return false;
   164e8:	2300      	movs	r3, #0
   164ea:	e7f7      	b.n	164dc <TCPIP_IPERF_Initialize+0x90>
   164ec:	2000e5f4 	.word	0x2000e5f4
   164f0:	2000e5f8 	.word	0x2000e5f8
   164f4:	2000dbb0 	.word	0x2000dbb0
   164f8:	000027c1 	.word	0x000027c1
   164fc:	00004c44 	.word	0x00004c44
   16500:	0001efb4 	.word	0x0001efb4

Disassembly of section .text.TCPIP_IPV4_ArpHandler%344:

00016504 <TCPIP_IPV4_ArpHandler>:
{
   16504:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   16508:	b084      	sub	sp, #16
   1650a:	460f      	mov	r7, r1
   1650c:	4690      	mov	r8, r2
   1650e:	469a      	mov	sl, r3
    TCPIP_Helper_SingleListInitialize (&newList);
   16510:	a801      	add	r0, sp, #4
   16512:	f00b fd75 	bl	22000 <TCPIP_Helper_SingleListInitialize>
    TCPIP_Helper_ProtectedSingleListLock(&ipv4ArpQueue);
   16516:	4827      	ldr	r0, [pc, #156]	; (165b4 <TCPIP_IPV4_ArpHandler+0xb0>)
   16518:	f00a fa2a 	bl	20970 <TCPIP_Helper_ProtectedSingleListLock>
    while((pEntry = (IPV4_ARP_ENTRY*)TCPIP_Helper_SingleListHeadRemove(arpList)) != 0)
   1651c:	4e25      	ldr	r6, [pc, #148]	; (165b4 <TCPIP_IPV4_ArpHandler+0xb0>)
            TCPIP_Helper_SingleListTailAdd(&ipv4ArpPool, (SGL_LIST_NODE*)pEntry); 
   1651e:	f8df 9098 	ldr.w	r9, [pc, #152]	; 165b8 <TCPIP_IPV4_ArpHandler+0xb4>
    while((pEntry = (IPV4_ARP_ENTRY*)TCPIP_Helper_SingleListHeadRemove(arpList)) != 0)
   16522:	e00b      	b.n	1653c <TCPIP_IPV4_ArpHandler+0x38>
            pMacPkt = &pEntry->pTxPkt->macPkt;
   16524:	68a5      	ldr	r5, [r4, #8]
   16526:	e014      	b.n	16552 <TCPIP_IPV4_ArpHandler+0x4e>
                pktAckFail = TCPIP_MAC_PKT_ACK_ARP_TMO; 
   16528:	f06f 0103 	mvn.w	r1, #3
        TCPIP_PKT_PacketAcknowledge(pTxPkt, ackRes);
   1652c:	2203      	movs	r2, #3
   1652e:	4628      	mov	r0, r5
   16530:	f007 fa30 	bl	1d994 <_TCPIP_PKT_PacketAcknowledge>
            TCPIP_Helper_SingleListTailAdd(&ipv4ArpPool, (SGL_LIST_NODE*)pEntry); 
   16534:	4621      	mov	r1, r4
   16536:	4648      	mov	r0, r9
   16538:	f00a fe32 	bl	211a0 <TCPIP_Helper_SingleListTailAdd>
    while((pEntry = (IPV4_ARP_ENTRY*)TCPIP_Helper_SingleListHeadRemove(arpList)) != 0)
   1653c:	4630      	mov	r0, r6
   1653e:	f00a fc5b 	bl	20df8 <TCPIP_Helper_SingleListHeadRemove>
   16542:	4604      	mov	r4, r0
   16544:	b348      	cbz	r0, 1659a <TCPIP_IPV4_ArpHandler+0x96>
        if(pEntry->type == IPV4_ARP_PKT_TYPE_TX)
   16546:	7923      	ldrb	r3, [r4, #4]
   16548:	2b01      	cmp	r3, #1
   1654a:	d0eb      	beq.n	16524 <TCPIP_IPV4_ArpHandler+0x20>
        else if(pEntry->type == IPV4_ARP_PKT_TYPE_MAC)
   1654c:	2b02      	cmp	r3, #2
   1654e:	d12d      	bne.n	165ac <TCPIP_IPV4_ArpHandler+0xa8>
            pMacPkt = pEntry->pMacPkt;
   16550:	68a5      	ldr	r5, [r4, #8]
        pPktIf = (TCPIP_NET_IF*)TCPIP_STACK_IndexToNet(pEntry->arpIfIx);
   16552:	7960      	ldrb	r0, [r4, #5]
   16554:	f009 fc62 	bl	1fe1c <TCPIP_STACK_IndexToNet>
        if(pEntry->arpTarget.Val == ipAdd->Val)
   16558:	68e2      	ldr	r2, [r4, #12]
   1655a:	683b      	ldr	r3, [r7, #0]
   1655c:	429a      	cmp	r2, r3
   1655e:	d117      	bne.n	16590 <TCPIP_IPV4_ArpHandler+0x8c>
            if(evType >= 0)
   16560:	f1ba 0f00 	cmp.w	sl, #0
   16564:	dbe0      	blt.n	16528 <TCPIP_IPV4_ArpHandler+0x24>
                memcpy(&macHdr->DestMACAddr, MACAddr, sizeof(*MACAddr));
   16566:	696b      	ldr	r3, [r5, #20]
   16568:	f8d8 2000 	ldr.w	r2, [r8]
   1656c:	601a      	str	r2, [r3, #0]
   1656e:	f8b8 2004 	ldrh.w	r2, [r8, #4]
   16572:	809a      	strh	r2, [r3, #4]
                pMacPkt->next = 0;  // send single packet
   16574:	2300      	movs	r3, #0
   16576:	602b      	str	r3, [r5, #0]
                if(pPktIf == 0 || !TCPIP_IPV4_TxMacPkt(pPktIf, pMacPkt))
   16578:	b138      	cbz	r0, 1658a <TCPIP_IPV4_ArpHandler+0x86>
    return _TCPIPStackPacketTx(pNetIf, pPkt) == TCPIP_MAC_RES_OK;
   1657a:	4629      	mov	r1, r5
   1657c:	f00b f8b2 	bl	216e4 <_TCPIPStackPacketTx>
                if(pPktIf == 0 || !TCPIP_IPV4_TxMacPkt(pPktIf, pMacPkt))
   16580:	2800      	cmp	r0, #0
   16582:	d0d7      	beq.n	16534 <TCPIP_IPV4_ArpHandler+0x30>
                    pktAckFail = TCPIP_MAC_PKT_ACK_ARP_NET_ERR; 
   16584:	f06f 0104 	mvn.w	r1, #4
   16588:	e7d0      	b.n	1652c <TCPIP_IPV4_ArpHandler+0x28>
   1658a:	f06f 0104 	mvn.w	r1, #4
   1658e:	e7cd      	b.n	1652c <TCPIP_IPV4_ArpHandler+0x28>
            TCPIP_Helper_SingleListTailAdd(&newList, (SGL_LIST_NODE*)pEntry);
   16590:	4621      	mov	r1, r4
   16592:	a801      	add	r0, sp, #4
   16594:	f00a fe04 	bl	211a0 <TCPIP_Helper_SingleListTailAdd>
   16598:	e7d0      	b.n	1653c <TCPIP_IPV4_ArpHandler+0x38>
    ipv4ArpQueue.list = newList;
   1659a:	4b06      	ldr	r3, [pc, #24]	; (165b4 <TCPIP_IPV4_ArpHandler+0xb0>)
   1659c:	aa04      	add	r2, sp, #16
   1659e:	e912 0007 	ldmdb	r2, {r0, r1, r2}
   165a2:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    TCPIP_Helper_ProtectedSingleListUnlock(&ipv4ArpQueue);
   165a6:	4618      	mov	r0, r3
   165a8:	f00a fc34 	bl	20e14 <TCPIP_Helper_ProtectedSingleListUnlock>
}
   165ac:	b004      	add	sp, #16
   165ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   165b2:	bf00      	nop
   165b4:	2000e428 	.word	0x2000e428
   165b8:	2000e528 	.word	0x2000e528

Disassembly of section .text.gfx_mono_draw_char%345:

000165bc <gfx_mono_draw_char>:
 * \param[in] x        X coordinate on screen.
 * \param[in] y        Y coordinate on screen.
 * \param[in] font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
        const struct font *font) {
   165bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   165c0:	b085      	sub	sp, #20
   165c2:	4607      	mov	r7, r0
   165c4:	468a      	mov	sl, r1
   165c6:	4615      	mov	r5, r2
   165c8:	461e      	mov	r6, r3
    gfx_mono_draw_filled_rect(x, y, font->width, font->height,
   165ca:	2300      	movs	r3, #0
   165cc:	9300      	str	r3, [sp, #0]
   165ce:	7a73      	ldrb	r3, [r6, #9]
   165d0:	7a32      	ldrb	r2, [r6, #8]
   165d2:	4629      	mov	r1, r5
   165d4:	4650      	mov	r0, sl
   165d6:	f008 fb2d 	bl	1ec34 <gfx_mono_generic_draw_filled_rect>
            GFX_PIXEL_CLR);

    switch (font->type) {
   165da:	7833      	ldrb	r3, [r6, #0]
   165dc:	2b00      	cmp	r3, #0
   165de:	d13b      	bne.n	16658 <gfx_mono_draw_char+0x9c>
    char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
   165e0:	7a32      	ldrb	r2, [r6, #8]
   165e2:	08d1      	lsrs	r1, r2, #3
    if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
   165e4:	f012 0f07 	tst.w	r2, #7
        char_row_size++;
   165e8:	bf18      	it	ne
   165ea:	3101      	addne	r1, #1
    glyph_data_offset = char_row_size * font->height *
   165ec:	f896 8009 	ldrb.w	r8, [r6, #9]
            ((uint8_t) ch - font->first_char);
   165f0:	7ab4      	ldrb	r4, [r6, #10]
   165f2:	1b3c      	subs	r4, r7, r4
    glyph_data_offset = char_row_size * font->height *
   165f4:	fb14 f408 	smulbb	r4, r4, r8
   165f8:	fb14 f401 	smulbb	r4, r4, r1
    glyph_data = font->data.progmem + glyph_data_offset;
   165fc:	6872      	ldr	r2, [r6, #4]
   165fe:	fa12 f484 	uxtah	r4, r2, r4
    rows_left = font->height;
   16602:	44a8      	add	r8, r5
   16604:	fa5f f888 	uxtb.w	r8, r8
        uint8_t glyph_byte = 0;
   16608:	9303      	str	r3, [sp, #12]
                gfx_mono_draw_pixel(inc_x, inc_y,
   1660a:	46a3      	mov	fp, r4
   1660c:	e01d      	b.n	1664a <gfx_mono_draw_char+0x8e>
            glyph_byte <<= 1;
   1660e:	007f      	lsls	r7, r7, #1
   16610:	b2ff      	uxtb	r7, r7
   16612:	f109 0901 	add.w	r9, r9, #1
        for (i = 0; i < pixelsToDraw; i++) {
   16616:	fa5f f389 	uxtb.w	r3, r9
   1661a:	429c      	cmp	r4, r3
   1661c:	d911      	bls.n	16642 <gfx_mono_draw_char+0x86>
   1661e:	fa5f f389 	uxtb.w	r3, r9
   16622:	eb0a 0003 	add.w	r0, sl, r3
   16626:	b2c0      	uxtb	r0, r0
            if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
   16628:	f013 0f07 	tst.w	r3, #7
                glyph_byte = PROGMEM_READ_BYTE(glyph_data);
   1662c:	bf08      	it	eq
   1662e:	f81b 7b01 	ldrbeq.w	r7, [fp], #1
            if ((glyph_byte & 0x80)) {
   16632:	f017 0f80 	tst.w	r7, #128	; 0x80
   16636:	d0ea      	beq.n	1660e <gfx_mono_draw_char+0x52>
                gfx_mono_draw_pixel(inc_x, inc_y,
   16638:	2201      	movs	r2, #1
   1663a:	4629      	mov	r1, r5
   1663c:	f004 fef0 	bl	1b420 <gfx_mono_ssd1306_draw_pixel>
   16640:	e7e5      	b.n	1660e <gfx_mono_draw_char+0x52>
        inc_y += 1;
   16642:	3501      	adds	r5, #1
   16644:	b2ed      	uxtb	r5, r5
    } while (rows_left > 0);
   16646:	4545      	cmp	r5, r8
   16648:	d00d      	beq.n	16666 <gfx_mono_draw_char+0xaa>
        uint8_t pixelsToDraw = font->width;
   1664a:	7a34      	ldrb	r4, [r6, #8]
        for (i = 0; i < pixelsToDraw; i++) {
   1664c:	2c00      	cmp	r4, #0
   1664e:	d0f8      	beq.n	16642 <gfx_mono_draw_char+0x86>
        uint8_t glyph_byte = 0;
   16650:	9f03      	ldr	r7, [sp, #12]
        for (i = 0; i < pixelsToDraw; i++) {
   16652:	f04f 0900 	mov.w	r9, #0
   16656:	e7e2      	b.n	1661e <gfx_mono_draw_char+0x62>
            break;

#endif
        default:
            /* Unsupported mode, call assert */
            assert(false);
   16658:	4804      	ldr	r0, [pc, #16]	; (1666c <gfx_mono_draw_char+0xb0>)
   1665a:	4603      	mov	r3, r0
   1665c:	4a04      	ldr	r2, [pc, #16]	; (16670 <gfx_mono_draw_char+0xb4>)
   1665e:	21f0      	movs	r1, #240	; 0xf0
   16660:	3008      	adds	r0, #8
   16662:	f007 fdaf 	bl	1e1c4 <__assert_func>
            break;
    }
}
   16666:	b005      	add	sp, #20
   16668:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1666c:	0001d438 	.word	0x0001d438
   16670:	000218d4 	.word	0x000218d4

Disassembly of section .text.wc_Md5Final%346:

00016674 <wc_Md5Final>:

int wc_Md5Final(wc_Md5* md5, byte* hash)
{
    byte* local;

    if (md5 == NULL || hash == NULL) {
   16674:	2800      	cmp	r0, #0
   16676:	d051      	beq.n	1671c <wc_Md5Final+0xa8>
{
   16678:	b570      	push	{r4, r5, r6, lr}
   1667a:	4604      	mov	r4, r0
    if (md5 == NULL || hash == NULL) {
   1667c:	2900      	cmp	r1, #0
   1667e:	d050      	beq.n	16722 <wc_Md5Final+0xae>
   16680:	460d      	mov	r5, r1
        return IntelQaSymMd5(&md5->asyncDev, hash, NULL, WC_MD5_DIGEST_SIZE);
#endif
    }
#endif /* WOLFSSL_ASYNC_CRYPT */

    local = (byte*)md5->buffer;
   16682:	4606      	mov	r6, r0

    local[md5->buffLen++] = 0x80;  /* add 1 */
   16684:	f856 3b0c 	ldr.w	r3, [r6], #12
   16688:	1c5a      	adds	r2, r3, #1
   1668a:	6002      	str	r2, [r0, #0]
   1668c:	2280      	movs	r2, #128	; 0x80
   1668e:	54f2      	strb	r2, [r6, r3]

    /* pad with zeros */
    if (md5->buffLen > WC_MD5_PAD_SIZE) {
   16690:	6800      	ldr	r0, [r0, #0]
   16692:	2838      	cmp	r0, #56	; 0x38
   16694:	d833      	bhi.n	166fe <wc_Md5Final+0x8a>
        ByteReverseWords(md5->buffer, md5->buffer, WC_MD5_BLOCK_SIZE);
#endif
        XTRANSFORM(md5, local);
        md5->buffLen = 0;
    }
    XMEMSET(&local[md5->buffLen], 0, WC_MD5_PAD_SIZE - md5->buffLen);
   16696:	6820      	ldr	r0, [r4, #0]
   16698:	f1c0 0238 	rsb	r2, r0, #56	; 0x38
   1669c:	2100      	movs	r1, #0
   1669e:	4430      	add	r0, r6
   166a0:	f00b fa6c 	bl	21b7c <memset>
#if defined(BIG_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
    ByteReverseWords(md5->buffer, md5->buffer, WC_MD5_BLOCK_SIZE);
#endif

    /* put lengths in bits */
    md5->hiLen = (md5->loLen >> (8 * sizeof(md5->loLen) - 3)) +
   166a4:	6863      	ldr	r3, [r4, #4]
                 (md5->hiLen << 3);
   166a6:	68a1      	ldr	r1, [r4, #8]
    md5->hiLen = (md5->loLen >> (8 * sizeof(md5->loLen) - 3)) +
   166a8:	0f5a      	lsrs	r2, r3, #29
   166aa:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
   166ae:	60a2      	str	r2, [r4, #8]
    md5->loLen = md5->loLen << 3;
   166b0:	00db      	lsls	r3, r3, #3
   166b2:	6063      	str	r3, [r4, #4]

    /* store lengths */
    /* ! length ordering dependent on digest endian type ! */
    XMEMCPY(&local[WC_MD5_PAD_SIZE], &md5->loLen, sizeof(word32));
   166b4:	6463      	str	r3, [r4, #68]	; 0x44
    XMEMCPY(&local[WC_MD5_PAD_SIZE + sizeof(word32)], &md5->hiLen, sizeof(word32));
   166b6:	64a2      	str	r2, [r4, #72]	; 0x48

    /* final transform and result to hash */
    XTRANSFORM(md5, local);
   166b8:	4631      	mov	r1, r6
   166ba:	4620      	mov	r0, r4
   166bc:	f7ef fb82 	bl	5dc4 <Transform>
#ifdef BIG_ENDIAN_ORDER
    ByteReverseWords(md5->digest, md5->digest, WC_MD5_DIGEST_SIZE);
#endif
    XMEMCPY(hash, md5->digest, WC_MD5_DIGEST_SIZE);
   166c0:	4623      	mov	r3, r4
   166c2:	f853 0f4c 	ldr.w	r0, [r3, #76]!
   166c6:	6859      	ldr	r1, [r3, #4]
   166c8:	689a      	ldr	r2, [r3, #8]
   166ca:	68db      	ldr	r3, [r3, #12]
   166cc:	6028      	str	r0, [r5, #0]
   166ce:	6069      	str	r1, [r5, #4]
   166d0:	60aa      	str	r2, [r5, #8]
   166d2:	60eb      	str	r3, [r5, #12]
    md5->digest[0] = 0x67452301L;
   166d4:	4b14      	ldr	r3, [pc, #80]	; (16728 <wc_Md5Final+0xb4>)
   166d6:	64e3      	str	r3, [r4, #76]	; 0x4c
    md5->digest[1] = 0xefcdab89L;
   166d8:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
   166dc:	6523      	str	r3, [r4, #80]	; 0x50
    md5->digest[2] = 0x98badcfeL;
   166de:	f103 4329 	add.w	r3, r3, #2835349504	; 0xa9000000
   166e2:	f5a3 1396 	sub.w	r3, r3, #1228800	; 0x12c000
   166e6:	f6a3 638b 	subw	r3, r3, #3723	; 0xe8b
   166ea:	6563      	str	r3, [r4, #84]	; 0x54
    md5->digest[3] = 0x10325476L;
   166ec:	f1a3 3388 	sub.w	r3, r3, #2290649224	; 0x88888888
   166f0:	65a3      	str	r3, [r4, #88]	; 0x58
    md5->buffLen = 0;
   166f2:	2000      	movs	r0, #0
   166f4:	6020      	str	r0, [r4, #0]
    md5->loLen   = 0;
   166f6:	6060      	str	r0, [r4, #4]
    md5->hiLen   = 0;
   166f8:	60a0      	str	r0, [r4, #8]
    md5->flags = 0;
   166fa:	6620      	str	r0, [r4, #96]	; 0x60

    return _InitMd5(md5); /* reset state */
}
   166fc:	bd70      	pop	{r4, r5, r6, pc}
        XMEMSET(&local[md5->buffLen], 0, WC_MD5_BLOCK_SIZE - md5->buffLen);
   166fe:	f1c0 0240 	rsb	r2, r0, #64	; 0x40
   16702:	2100      	movs	r1, #0
   16704:	4430      	add	r0, r6
   16706:	f00b fa39 	bl	21b7c <memset>
        md5->buffLen += WC_MD5_BLOCK_SIZE - md5->buffLen;
   1670a:	2340      	movs	r3, #64	; 0x40
   1670c:	6023      	str	r3, [r4, #0]
        XTRANSFORM(md5, local);
   1670e:	4631      	mov	r1, r6
   16710:	4620      	mov	r0, r4
   16712:	f7ef fb57 	bl	5dc4 <Transform>
        md5->buffLen = 0;
   16716:	2300      	movs	r3, #0
   16718:	6023      	str	r3, [r4, #0]
   1671a:	e7bc      	b.n	16696 <wc_Md5Final+0x22>
        return BAD_FUNC_ARG;
   1671c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
   16720:	4770      	bx	lr
        return BAD_FUNC_ARG;
   16722:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   16726:	e7e9      	b.n	166fc <wc_Md5Final+0x88>
   16728:	67452301 	.word	0x67452301

Disassembly of section .text.__ssputs_r%347:

0001672c <__ssputs_r>:
   1672c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   16730:	688e      	ldr	r6, [r1, #8]
   16732:	429e      	cmp	r6, r3
   16734:	4682      	mov	sl, r0
   16736:	460c      	mov	r4, r1
   16738:	4691      	mov	r9, r2
   1673a:	4698      	mov	r8, r3
   1673c:	d838      	bhi.n	167b0 <__ssputs_r+0x84>
   1673e:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
   16742:	f41c 6f90 	tst.w	ip, #1152	; 0x480
   16746:	d031      	beq.n	167ac <__ssputs_r+0x80>
   16748:	6962      	ldr	r2, [r4, #20]
   1674a:	6825      	ldr	r5, [r4, #0]
   1674c:	6909      	ldr	r1, [r1, #16]
   1674e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   16752:	1a6f      	subs	r7, r5, r1
   16754:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
   16758:	3301      	adds	r3, #1
   1675a:	1055      	asrs	r5, r2, #1
   1675c:	443b      	add	r3, r7
   1675e:	429d      	cmp	r5, r3
   16760:	bf38      	it	cc
   16762:	461d      	movcc	r5, r3
   16764:	f41c 6f80 	tst.w	ip, #1024	; 0x400
   16768:	d030      	beq.n	167cc <__ssputs_r+0xa0>
   1676a:	4629      	mov	r1, r5
   1676c:	f000 f8ee 	bl	1694c <_malloc_r>
   16770:	4606      	mov	r6, r0
   16772:	b950      	cbnz	r0, 1678a <__ssputs_r+0x5e>
   16774:	230c      	movs	r3, #12
   16776:	f8ca 3000 	str.w	r3, [sl]
   1677a:	89a3      	ldrh	r3, [r4, #12]
   1677c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   16780:	81a3      	strh	r3, [r4, #12]
   16782:	f04f 30ff 	mov.w	r0, #4294967295
   16786:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1678a:	463a      	mov	r2, r7
   1678c:	6921      	ldr	r1, [r4, #16]
   1678e:	f00a fc67 	bl	21060 <memcpy>
   16792:	89a3      	ldrh	r3, [r4, #12]
   16794:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
   16798:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   1679c:	81a3      	strh	r3, [r4, #12]
   1679e:	6126      	str	r6, [r4, #16]
   167a0:	6165      	str	r5, [r4, #20]
   167a2:	443e      	add	r6, r7
   167a4:	1bed      	subs	r5, r5, r7
   167a6:	6026      	str	r6, [r4, #0]
   167a8:	60a5      	str	r5, [r4, #8]
   167aa:	4646      	mov	r6, r8
   167ac:	4546      	cmp	r6, r8
   167ae:	d900      	bls.n	167b2 <__ssputs_r+0x86>
   167b0:	4646      	mov	r6, r8
   167b2:	4632      	mov	r2, r6
   167b4:	4649      	mov	r1, r9
   167b6:	6820      	ldr	r0, [r4, #0]
   167b8:	f008 fa8a 	bl	1ecd0 <memmove>
   167bc:	68a3      	ldr	r3, [r4, #8]
   167be:	1b9b      	subs	r3, r3, r6
   167c0:	60a3      	str	r3, [r4, #8]
   167c2:	6823      	ldr	r3, [r4, #0]
   167c4:	441e      	add	r6, r3
   167c6:	6026      	str	r6, [r4, #0]
   167c8:	2000      	movs	r0, #0
   167ca:	e7dc      	b.n	16786 <__ssputs_r+0x5a>
   167cc:	462a      	mov	r2, r5
   167ce:	f006 f861 	bl	1c894 <_realloc_r>
   167d2:	4606      	mov	r6, r0
   167d4:	2800      	cmp	r0, #0
   167d6:	d1e2      	bne.n	1679e <__ssputs_r+0x72>
   167d8:	6921      	ldr	r1, [r4, #16]
   167da:	4650      	mov	r0, sl
   167dc:	f001 f97a 	bl	17ad4 <_free_r>
   167e0:	e7c8      	b.n	16774 <__ssputs_r+0x48>

Disassembly of section .text._ARPSendIfPkt%348:

000167e4 <_ARPSendIfPkt>:
{
   167e4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   167e8:	4607      	mov	r7, r0
   167ea:	468a      	mov	sl, r1
   167ec:	4691      	mov	r9, r2
   167ee:	4698      	mov	r8, r3
   167f0:	9d08      	ldr	r5, [sp, #32]
   167f2:	9e09      	ldr	r6, [sp, #36]	; 0x24
    if(arpMod.pMacPkt != 0 && (arpMod.pMacPkt->pktFlags & TCPIP_MAC_PKT_FLAG_QUEUED) == 0)
   167f4:	4b27      	ldr	r3, [pc, #156]	; (16894 <_ARPSendIfPkt+0xb0>)
   167f6:	6c9c      	ldr	r4, [r3, #72]	; 0x48
   167f8:	b11c      	cbz	r4, 16802 <_ARPSendIfPkt+0x1e>
   167fa:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   167fc:	f013 0f08 	tst.w	r3, #8
   16800:	d006      	beq.n	16810 <_ARPSendIfPkt+0x2c>
        if((pMacPkt = _ARPAllocateTxPacket()) == 0)
   16802:	f009 fd8d 	bl	20320 <_ARPAllocateTxPacket>
   16806:	4604      	mov	r4, r0
   16808:	2800      	cmp	r0, #0
   1680a:	d041      	beq.n	16890 <_ARPSendIfPkt+0xac>
        arpMod.pMacPkt = pMacPkt;   // show we're using this one now
   1680c:	4b21      	ldr	r3, [pc, #132]	; (16894 <_ARPSendIfPkt+0xb0>)
   1680e:	6498      	str	r0, [r3, #72]	; 0x48
    pArp = (ARP_PACKET*)pMacPkt->pNetLayer;
   16810:	69a3      	ldr	r3, [r4, #24]
    pArp->HardwareType  = HW_ETHERNET;
   16812:	2201      	movs	r2, #1
   16814:	801a      	strh	r2, [r3, #0]
    pArp->Protocol      = ARP_IP;
   16816:	f44f 6200 	mov.w	r2, #2048	; 0x800
   1681a:	805a      	strh	r2, [r3, #2]
    pArp->MACAddrLen    = sizeof(TCPIP_MAC_ADDR);
   1681c:	2206      	movs	r2, #6
   1681e:	711a      	strb	r2, [r3, #4]
    pArp->ProtocolLen   = sizeof(IPV4_ADDR);
   16820:	2204      	movs	r2, #4
   16822:	715a      	strb	r2, [r3, #5]
    pArp->Operation = oper;
   16824:	f8a3 a006 	strh.w	sl, [r3, #6]
    if(srcMAC == 0)
   16828:	b30e      	cbz	r6, 1686e <_ARPSendIfPkt+0x8a>
        pArp->SenderMACAddr = *srcMAC;
   1682a:	6832      	ldr	r2, [r6, #0]
   1682c:	609a      	str	r2, [r3, #8]
   1682e:	88b2      	ldrh	r2, [r6, #4]
   16830:	819a      	strh	r2, [r3, #12]
    pArp->SenderIPAddr.Val  = srcIP;
   16832:	f8c3 900e 	str.w	r9, [r3, #14]
    pArp->TargetMACAddr = *dstMAC;
   16836:	682a      	ldr	r2, [r5, #0]
   16838:	f8c3 2012 	str.w	r2, [r3, #18]
   1683c:	88aa      	ldrh	r2, [r5, #4]
   1683e:	82da      	strh	r2, [r3, #22]
    pArp->TargetIPAddr.Val  = dstIP;
   16840:	f8c3 8018 	str.w	r8, [r3, #24]
    _SwapARPPacket(pArp);
   16844:	4618      	mov	r0, r3
   16846:	f00a f873 	bl	20930 <_SwapARPPacket>
    pMacPkt->pDSeg->segLen = sizeof(ARP_PACKET);
   1684a:	6923      	ldr	r3, [r4, #16]
   1684c:	221c      	movs	r2, #28
   1684e:	819a      	strh	r2, [r3, #12]
    if(TCPIP_PKT_PacketMACFormat(pMacPkt, dstMAC, (const TCPIP_MAC_ADDR*)TCPIP_STACK_NetUpMACAddressGet(pIf), TCPIP_ETHER_TYPE_ARP))
   16850:	4638      	mov	r0, r7
   16852:	f00a ffdb 	bl	2180c <TCPIP_STACK_NetUpMACAddressGet>
   16856:	f640 0306 	movw	r3, #2054	; 0x806
   1685a:	4602      	mov	r2, r0
   1685c:	4629      	mov	r1, r5
   1685e:	4620      	mov	r0, r4
   16860:	f007 fe7c 	bl	1e55c <TCPIP_PKT_PacketMACFormat>
   16864:	4603      	mov	r3, r0
   16866:	b940      	cbnz	r0, 1687a <_ARPSendIfPkt+0x96>
}
   16868:	4618      	mov	r0, r3
   1686a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        pArp->SenderMACAddr = pIf->netMACAddr;
   1686e:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   16870:	6098      	str	r0, [r3, #8]
   16872:	f8b7 2040 	ldrh.w	r2, [r7, #64]	; 0x40
   16876:	819a      	strh	r2, [r3, #12]
   16878:	e7db      	b.n	16832 <_ARPSendIfPkt+0x4e>
        pMacPkt->next = 0;  // send single packet
   1687a:	2300      	movs	r3, #0
   1687c:	6023      	str	r3, [r4, #0]
        pMacPkt->pktIf = pIf;
   1687e:	62a7      	str	r7, [r4, #40]	; 0x28
        if(_TCPIPStackPacketTx(pIf, pMacPkt) >= 0)
   16880:	4621      	mov	r1, r4
   16882:	4638      	mov	r0, r7
   16884:	f00a ff2e 	bl	216e4 <_TCPIPStackPacketTx>
   16888:	43c0      	mvns	r0, r0
   1688a:	f3c0 13c0 	ubfx	r3, r0, #7, #1
   1688e:	e7eb      	b.n	16868 <_ARPSendIfPkt+0x84>
            return false;
   16890:	2300      	movs	r3, #0
   16892:	e7e9      	b.n	16868 <_ARPSendIfPkt+0x84>
   16894:	2000e1a4 	.word	0x2000e1a4

Disassembly of section .text.SYS_TIME_HwTimerCompareUpdate%349:

00016898 <SYS_TIME_HwTimerCompareUpdate>:
{
   16898:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    SYS_TIME_TIMER_OBJ* tmrActive = counterObj->tmrActive;
   1689c:	4b2a      	ldr	r3, [pc, #168]	; (16948 <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   1689e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    counterObj->hwTimerPreviousValue = counterObj->hwTimerCurrentValue;
   168a0:	6959      	ldr	r1, [r3, #20]
   168a2:	6119      	str	r1, [r3, #16]
    if (tmrActive != NULL)
   168a4:	2a00      	cmp	r2, #0
   168a6:	d040      	beq.n	1692a <SYS_TIME_HwTimerCompareUpdate+0x92>
        if (tmrActive->relativeTimePending > SYS_TIME_HW_COUNTER_HALF_PERIOD)
   168a8:	6893      	ldr	r3, [r2, #8]
   168aa:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   168ae:	d333      	bcc.n	16918 <SYS_TIME_HwTimerCompareUpdate+0x80>
            nextHwCounterValue = (uint64_t)counterObj->hwTimerCurrentValue + SYS_TIME_HW_COUNTER_HALF_PERIOD;
   168b0:	4b25      	ldr	r3, [pc, #148]	; (16948 <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   168b2:	695b      	ldr	r3, [r3, #20]
   168b4:	f647 74ff 	movw	r4, #32767	; 0x7fff
   168b8:	2500      	movs	r5, #0
   168ba:	eb14 0803 	adds.w	r8, r4, r3
   168be:	f145 0900 	adc.w	r9, r5, #0
    currHwCounterValue = counterObj->timePlib->timerCounterGet();
   168c2:	4e21      	ldr	r6, [pc, #132]	; (16948 <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   168c4:	6873      	ldr	r3, [r6, #4]
   168c6:	699b      	ldr	r3, [r3, #24]
   168c8:	4798      	blx	r3
   168ca:	b282      	uxth	r2, r0
   168cc:	2300      	movs	r3, #0
    if (currHwCounterValue < counterObj->hwTimerPreviousValue)
   168ce:	6931      	ldr	r1, [r6, #16]
   168d0:	4281      	cmp	r1, r0
   168d2:	d906      	bls.n	168e2 <SYS_TIME_HwTimerCompareUpdate+0x4a>
        currHwCounterValue = SYS_TIME_HW_COUNTER_PERIOD + currHwCounterValue;
   168d4:	f64f 71ff 	movw	r1, #65535	; 0xffff
   168d8:	1852      	adds	r2, r2, r1
   168da:	f04f 0100 	mov.w	r1, #0
   168de:	eb41 0303 	adc.w	r3, r1, r3
    if (nextHwCounterValue  < (currHwCounterValue + counterObj->hwTimerCompareMargin))
   168e2:	4919      	ldr	r1, [pc, #100]	; (16948 <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   168e4:	6a09      	ldr	r1, [r1, #32]
   168e6:	1856      	adds	r6, r2, r1
   168e8:	f143 0700 	adc.w	r7, r3, #0
   168ec:	45b9      	cmp	r9, r7
   168ee:	bf08      	it	eq
   168f0:	45b0      	cmpeq	r8, r6
   168f2:	d224      	bcs.n	1693e <SYS_TIME_HwTimerCompareUpdate+0xa6>
        counterObj->hwTimerCompareValue = currHwCounterValue + counterObj->hwTimerCompareMargin;
   168f4:	440a      	add	r2, r1
   168f6:	4b14      	ldr	r3, [pc, #80]	; (16948 <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   168f8:	61da      	str	r2, [r3, #28]
    if ((counterObj->hwTimerCompareValue & SYS_TIME_HW_COUNTER_PERIOD) == 0)
   168fa:	4b13      	ldr	r3, [pc, #76]	; (16948 <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   168fc:	69db      	ldr	r3, [r3, #28]
   168fe:	b29b      	uxth	r3, r3
   16900:	b913      	cbnz	r3, 16908 <SYS_TIME_HwTimerCompareUpdate+0x70>
        counterObj->hwTimerCompareValue = 1;
   16902:	4b11      	ldr	r3, [pc, #68]	; (16948 <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   16904:	2201      	movs	r2, #1
   16906:	61da      	str	r2, [r3, #28]
    counterObj->timePlib->timerCompareSet(counterObj->hwTimerCompareValue);
   16908:	4b0f      	ldr	r3, [pc, #60]	; (16948 <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   1690a:	69d8      	ldr	r0, [r3, #28]
   1690c:	685b      	ldr	r3, [r3, #4]
   1690e:	695b      	ldr	r3, [r3, #20]
   16910:	b280      	uxth	r0, r0
   16912:	4798      	blx	r3
}
   16914:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            uint32_t relativeTimePending = tmrActive->relativeTimePending;
   16918:	6894      	ldr	r4, [r2, #8]
            nextHwCounterValue = (uint64_t)counterObj->hwTimerCurrentValue + relativeTimePending;
   1691a:	4b0b      	ldr	r3, [pc, #44]	; (16948 <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   1691c:	695b      	ldr	r3, [r3, #20]
   1691e:	2500      	movs	r5, #0
   16920:	eb14 0803 	adds.w	r8, r4, r3
   16924:	f145 0900 	adc.w	r9, r5, #0
   16928:	e7cb      	b.n	168c2 <SYS_TIME_HwTimerCompareUpdate+0x2a>
        nextHwCounterValue = (uint64_t)counterObj->hwTimerCurrentValue + SYS_TIME_HW_COUNTER_HALF_PERIOD;
   1692a:	4b07      	ldr	r3, [pc, #28]	; (16948 <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   1692c:	695b      	ldr	r3, [r3, #20]
   1692e:	f647 74ff 	movw	r4, #32767	; 0x7fff
   16932:	2500      	movs	r5, #0
   16934:	eb14 0803 	adds.w	r8, r4, r3
   16938:	f145 0900 	adc.w	r9, r5, #0
   1693c:	e7c1      	b.n	168c2 <SYS_TIME_HwTimerCompareUpdate+0x2a>
        counterObj->hwTimerCompareValue = nextHwCounterValue;
   1693e:	4b02      	ldr	r3, [pc, #8]	; (16948 <SYS_TIME_HwTimerCompareUpdate+0xb0>)
   16940:	f8c3 801c 	str.w	r8, [r3, #28]
   16944:	e7d9      	b.n	168fa <SYS_TIME_HwTimerCompareUpdate+0x62>
   16946:	bf00      	nop
   16948:	2000e230 	.word	0x2000e230

Disassembly of section .text._malloc_r%350:

0001694c <_malloc_r>:
   1694c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1694e:	1ccd      	adds	r5, r1, #3
   16950:	f025 0503 	bic.w	r5, r5, #3
   16954:	3508      	adds	r5, #8
   16956:	2d0c      	cmp	r5, #12
   16958:	bf38      	it	cc
   1695a:	250c      	movcc	r5, #12
   1695c:	2d00      	cmp	r5, #0
   1695e:	4606      	mov	r6, r0
   16960:	db01      	blt.n	16966 <_malloc_r+0x1a>
   16962:	42a9      	cmp	r1, r5
   16964:	d903      	bls.n	1696e <_malloc_r+0x22>
   16966:	230c      	movs	r3, #12
   16968:	6033      	str	r3, [r6, #0]
   1696a:	2000      	movs	r0, #0
   1696c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1696e:	f005 fc34 	bl	1c1da <__malloc_lock>
   16972:	4921      	ldr	r1, [pc, #132]	; (169f8 <_malloc_r+0xac>)
   16974:	680a      	ldr	r2, [r1, #0]
   16976:	4614      	mov	r4, r2
   16978:	b99c      	cbnz	r4, 169a2 <_malloc_r+0x56>
   1697a:	4f20      	ldr	r7, [pc, #128]	; (169fc <_malloc_r+0xb0>)
   1697c:	683b      	ldr	r3, [r7, #0]
   1697e:	b923      	cbnz	r3, 1698a <_malloc_r+0x3e>
   16980:	4621      	mov	r1, r4
   16982:	4630      	mov	r0, r6
   16984:	f00a f8f4 	bl	20b70 <_sbrk_r>
   16988:	6038      	str	r0, [r7, #0]
   1698a:	4629      	mov	r1, r5
   1698c:	4630      	mov	r0, r6
   1698e:	f00a f8ef 	bl	20b70 <_sbrk_r>
   16992:	1c43      	adds	r3, r0, #1
   16994:	d123      	bne.n	169de <_malloc_r+0x92>
   16996:	230c      	movs	r3, #12
   16998:	6033      	str	r3, [r6, #0]
   1699a:	4630      	mov	r0, r6
   1699c:	f007 faa9 	bl	1def2 <__malloc_unlock>
   169a0:	e7e3      	b.n	1696a <_malloc_r+0x1e>
   169a2:	6823      	ldr	r3, [r4, #0]
   169a4:	1b5b      	subs	r3, r3, r5
   169a6:	d417      	bmi.n	169d8 <_malloc_r+0x8c>
   169a8:	2b0b      	cmp	r3, #11
   169aa:	d903      	bls.n	169b4 <_malloc_r+0x68>
   169ac:	6023      	str	r3, [r4, #0]
   169ae:	441c      	add	r4, r3
   169b0:	6025      	str	r5, [r4, #0]
   169b2:	e004      	b.n	169be <_malloc_r+0x72>
   169b4:	6863      	ldr	r3, [r4, #4]
   169b6:	42a2      	cmp	r2, r4
   169b8:	bf0c      	ite	eq
   169ba:	600b      	streq	r3, [r1, #0]
   169bc:	6053      	strne	r3, [r2, #4]
   169be:	4630      	mov	r0, r6
   169c0:	f007 fa97 	bl	1def2 <__malloc_unlock>
   169c4:	f104 000b 	add.w	r0, r4, #11
   169c8:	1d23      	adds	r3, r4, #4
   169ca:	f020 0007 	bic.w	r0, r0, #7
   169ce:	1ac2      	subs	r2, r0, r3
   169d0:	d0cc      	beq.n	1696c <_malloc_r+0x20>
   169d2:	1a1b      	subs	r3, r3, r0
   169d4:	50a3      	str	r3, [r4, r2]
   169d6:	e7c9      	b.n	1696c <_malloc_r+0x20>
   169d8:	4622      	mov	r2, r4
   169da:	6864      	ldr	r4, [r4, #4]
   169dc:	e7cc      	b.n	16978 <_malloc_r+0x2c>
   169de:	1cc4      	adds	r4, r0, #3
   169e0:	f024 0403 	bic.w	r4, r4, #3
   169e4:	42a0      	cmp	r0, r4
   169e6:	d0e3      	beq.n	169b0 <_malloc_r+0x64>
   169e8:	1a21      	subs	r1, r4, r0
   169ea:	4630      	mov	r0, r6
   169ec:	f00a f8c0 	bl	20b70 <_sbrk_r>
   169f0:	3001      	adds	r0, #1
   169f2:	d1dd      	bne.n	169b0 <_malloc_r+0x64>
   169f4:	e7cf      	b.n	16996 <_malloc_r+0x4a>
   169f6:	bf00      	nop
   169f8:	2000e704 	.word	0x2000e704
   169fc:	2000e708 	.word	0x2000e708

Disassembly of section .text.TCPIP_STACK_NetUp%351:

00016a00 <TCPIP_STACK_NetUp>:
{
   16a00:	b570      	push	{r4, r5, r6, lr}
    if(pNetIf)
   16a02:	2800      	cmp	r0, #0
   16a04:	d047      	beq.n	16a96 <TCPIP_STACK_NetUp+0x96>
   16a06:	4605      	mov	r5, r0
        if(pNetIf->Flags.bInterfaceEnabled || pNetIf->Flags.bMacInitialize)
   16a08:	f8b0 2042 	ldrh.w	r2, [r0, #66]	; 0x42
   16a0c:	f244 0040 	movw	r0, #16448	; 0x4040
   16a10:	4210      	tst	r0, r2
   16a12:	d143      	bne.n	16a9c <TCPIP_STACK_NetUp+0x9c>
        if(pUsrConfig == 0)
   16a14:	2900      	cmp	r1, #0
   16a16:	d043      	beq.n	16aa0 <TCPIP_STACK_NetUp+0xa0>
   16a18:	460e      	mov	r6, r1
        tcpip_stack_ctrl_data.pNetIf = pNetIf;
   16a1a:	4b22      	ldr	r3, [pc, #136]	; (16aa4 <TCPIP_STACK_NetUp+0xa4>)
   16a1c:	615d      	str	r5, [r3, #20]
        tcpip_stack_ctrl_data.netIx = pNetIf->netIfIx;
   16a1e:	f8b5 2058 	ldrh.w	r2, [r5, #88]	; 0x58
   16a22:	619a      	str	r2, [r3, #24]
        tcpip_stack_ctrl_data.stackAction = TCPIP_STACK_ACTION_IF_UP;
   16a24:	2203      	movs	r2, #3
   16a26:	771a      	strb	r2, [r3, #28]
        if(!_LoadNetworkConfig(pUsrConfig, pNetIf, true))
   16a28:	2201      	movs	r2, #1
   16a2a:	4629      	mov	r1, r5
   16a2c:	4630      	mov	r0, r6
   16a2e:	f7fb fa8d 	bl	11f4c <_LoadNetworkConfig>
   16a32:	4604      	mov	r4, r0
   16a34:	b160      	cbz	r0, 16a50 <TCPIP_STACK_NetUp+0x50>
        powerMode = TCPIP_Helper_StringToPowerMode(pUsrConfig->powerMode);
   16a36:	6a30      	ldr	r0, [r6, #32]
   16a38:	f008 fb1c 	bl	1f074 <TCPIP_Helper_StringToPowerMode>
   16a3c:	4604      	mov	r4, r0
        if(powerMode != TCPIP_MAC_POWER_FULL && powerMode != TCPIP_MAC_POWER_DOWN)
   16a3e:	f000 03fd 	and.w	r3, r0, #253	; 0xfd
   16a42:	2b01      	cmp	r3, #1
   16a44:	d017      	beq.n	16a76 <TCPIP_STACK_NetUp+0x76>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Power Mode initialization fail: %d\r\n", powerMode);
   16a46:	f00b fa81 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
   16a4a:	b960      	cbnz	r0, 16a66 <TCPIP_STACK_NetUp+0x66>
            return false;
   16a4c:	2400      	movs	r4, #0
   16a4e:	e023      	b.n	16a98 <TCPIP_STACK_NetUp+0x98>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Network configuration load failed: %d\r\n", pNetIf->netIfIx);
   16a50:	f00b fa7c 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
   16a54:	b300      	cbz	r0, 16a98 <TCPIP_STACK_NetUp+0x98>
   16a56:	f00b fa73 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
   16a5a:	f8b5 2058 	ldrh.w	r2, [r5, #88]	; 0x58
   16a5e:	4912      	ldr	r1, [pc, #72]	; (16aa8 <TCPIP_STACK_NetUp+0xa8>)
   16a60:	f003 fe84 	bl	1a76c <SYS_CONSOLE_Print>
   16a64:	e018      	b.n	16a98 <TCPIP_STACK_NetUp+0x98>
            SYS_ERROR_PRINT(SYS_ERROR_ERROR, TCPIP_STACK_HDR_MESSAGE "Power Mode initialization fail: %d\r\n", powerMode);
   16a66:	f00b fa6b 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
   16a6a:	4622      	mov	r2, r4
   16a6c:	490f      	ldr	r1, [pc, #60]	; (16aac <TCPIP_STACK_NetUp+0xac>)
   16a6e:	f003 fe7d 	bl	1a76c <SYS_CONSOLE_Print>
            return false;
   16a72:	2400      	movs	r4, #0
   16a74:	e010      	b.n	16a98 <TCPIP_STACK_NetUp+0x98>
        tcpip_stack_ctrl_data.powerMode = powerMode;
   16a76:	480b      	ldr	r0, [pc, #44]	; (16aa4 <TCPIP_STACK_NetUp+0xa4>)
   16a78:	7744      	strb	r4, [r0, #29]
        success = TCPIP_STACK_BringNetUp(&tcpip_stack_ctrl_data, pUsrConfig, 0, 0);
   16a7a:	2300      	movs	r3, #0
   16a7c:	461a      	mov	r2, r3
   16a7e:	4631      	mov	r1, r6
   16a80:	f7f6 fed0 	bl	d824 <TCPIP_STACK_BringNetUp>
        if(!success)
   16a84:	4604      	mov	r4, r0
   16a86:	b938      	cbnz	r0, 16a98 <TCPIP_STACK_NetUp+0x98>
            TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pNetIf, TCPIP_STACK_ACTION_IF_DOWN, TCPIP_MAC_POWER_DOWN);
   16a88:	2303      	movs	r3, #3
   16a8a:	2204      	movs	r2, #4
   16a8c:	4629      	mov	r1, r5
   16a8e:	4805      	ldr	r0, [pc, #20]	; (16aa4 <TCPIP_STACK_NetUp+0xa4>)
   16a90:	f004 fa12 	bl	1aeb8 <TCPIP_STACK_BringNetDown>
   16a94:	e000      	b.n	16a98 <TCPIP_STACK_NetUp+0x98>
    return false;
   16a96:	2400      	movs	r4, #0
}
   16a98:	4620      	mov	r0, r4
   16a9a:	bd70      	pop	{r4, r5, r6, pc}
            return true;
   16a9c:	2401      	movs	r4, #1
   16a9e:	e7fb      	b.n	16a98 <TCPIP_STACK_NetUp+0x98>
            return false;
   16aa0:	2400      	movs	r4, #0
   16aa2:	e7f9      	b.n	16a98 <TCPIP_STACK_NetUp+0x98>
   16aa4:	2000e2f0 	.word	0x2000e2f0
   16aa8:	0000889c 	.word	0x0000889c
   16aac:	000087dc 	.word	0x000087dc

Disassembly of section .text.SYS_TIME_TimerObjectCreate%352:

00016ab0 <SYS_TIME_TimerObjectCreate>:
    uint32_t period,
    SYS_TIME_CALLBACK callBack,
    uintptr_t context,
    SYS_TIME_CALLBACK_TYPE type
)
{
   16ab0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16ab2:	4605      	mov	r5, r0
   16ab4:	460c      	mov	r4, r1
   16ab6:	4617      	mov	r7, r2
   16ab8:	461e      	mov	r6, r3
    SYS_TIME_HANDLE tmrHandle = SYS_TIME_HANDLE_INVALID;
    SYS_TIME_TIMER_OBJ *tmr;
    uint32_t tmrObjIndex = 0;

    if (SYS_TIME_ResourceLock() == false)
   16aba:	f007 fdbf 	bl	1e63c <SYS_TIME_ResourceLock>
   16abe:	2800      	cmp	r0, #0
   16ac0:	d042      	beq.n	16b48 <SYS_TIME_TimerObjectCreate+0x98>
    {
        return tmrHandle;
    }
    if((gSystemCounterObj.status == SYS_STATUS_READY) && (period > 0) && (period >= count))
   16ac2:	4b23      	ldr	r3, [pc, #140]	; (16b50 <SYS_TIME_TimerObjectCreate+0xa0>)
   16ac4:	f993 3000 	ldrsb.w	r3, [r3]
   16ac8:	2b02      	cmp	r3, #2
   16aca:	d005      	beq.n	16ad8 <SYS_TIME_TimerObjectCreate+0x28>
    SYS_TIME_HANDLE tmrHandle = SYS_TIME_HANDLE_INVALID;
   16acc:	f04f 34ff 	mov.w	r4, #4294967295
            }
            tmrObjIndex++;
        }
    }

    SYS_TIME_ResourceUnlock();
   16ad0:	f007 fb00 	bl	1e0d4 <SYS_TIME_ResourceUnlock>

    return tmrHandle;
}
   16ad4:	4620      	mov	r0, r4
   16ad6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((gSystemCounterObj.status == SYS_STATUS_READY) && (period > 0) && (period >= count))
   16ad8:	2c00      	cmp	r4, #0
   16ada:	d02f      	beq.n	16b3c <SYS_TIME_TimerObjectCreate+0x8c>
   16adc:	42ac      	cmp	r4, r5
   16ade:	d330      	bcc.n	16b42 <SYS_TIME_TimerObjectCreate+0x92>
            if(tmr->inUse == false)
   16ae0:	4b1c      	ldr	r3, [pc, #112]	; (16b54 <SYS_TIME_TimerObjectCreate+0xa4>)
   16ae2:	781b      	ldrb	r3, [r3, #0]
   16ae4:	b153      	cbz	r3, 16afc <SYS_TIME_TimerObjectCreate+0x4c>
        for(tmr = timers; tmr < &timers[SYS_TIME_MAX_TIMERS]; tmr++)
   16ae6:	4a1c      	ldr	r2, [pc, #112]	; (16b58 <SYS_TIME_TimerObjectCreate+0xa8>)
            tmrObjIndex++;
   16ae8:	2301      	movs	r3, #1
            if(tmr->inUse == false)
   16aea:	7811      	ldrb	r1, [r2, #0]
   16aec:	b141      	cbz	r1, 16b00 <SYS_TIME_TimerObjectCreate+0x50>
            tmrObjIndex++;
   16aee:	3301      	adds	r3, #1
        for(tmr = timers; tmr < &timers[SYS_TIME_MAX_TIMERS]; tmr++)
   16af0:	3220      	adds	r2, #32
   16af2:	2b05      	cmp	r3, #5
   16af4:	d1f9      	bne.n	16aea <SYS_TIME_TimerObjectCreate+0x3a>
    SYS_TIME_HANDLE tmrHandle = SYS_TIME_HANDLE_INVALID;
   16af6:	f04f 34ff 	mov.w	r4, #4294967295
   16afa:	e7e9      	b.n	16ad0 <SYS_TIME_TimerObjectCreate+0x20>
    uint32_t tmrObjIndex = 0;
   16afc:	2300      	movs	r3, #0
        for(tmr = timers; tmr < &timers[SYS_TIME_MAX_TIMERS]; tmr++)
   16afe:	4a15      	ldr	r2, [pc, #84]	; (16b54 <SYS_TIME_TimerObjectCreate+0xa4>)
                tmr->inUse = true;
   16b00:	2101      	movs	r1, #1
   16b02:	7011      	strb	r1, [r2, #0]
                tmr->active = false;
   16b04:	2100      	movs	r1, #0
   16b06:	7051      	strb	r1, [r2, #1]
                tmr->tmrElapsedFlag = false;
   16b08:	7511      	strb	r1, [r2, #20]
                tmr->tmrElapsed = false;
   16b0a:	7551      	strb	r1, [r2, #21]
                tmr->type = type;
   16b0c:	f89d 1018 	ldrb.w	r1, [sp, #24]
   16b10:	7091      	strb	r1, [r2, #2]
                tmr->requestedTime = period;
   16b12:	6054      	str	r4, [r2, #4]
                tmr->callback = callBack;
   16b14:	60d7      	str	r7, [r2, #12]
                tmr->context = context;
   16b16:	6116      	str	r6, [r2, #16]
                tmr->relativeTimePending = period - count;
   16b18:	1b64      	subs	r4, r4, r5
   16b1a:	6094      	str	r4, [r2, #8]
                tmr->tmrHandle = (SYS_TIME_HANDLE) SYS_TIME_MAKE_HANDLE(gSysTimeTokenCount, tmrObjIndex);
   16b1c:	490f      	ldr	r1, [pc, #60]	; (16b5c <SYS_TIME_TimerObjectCreate+0xac>)
   16b1e:	8809      	ldrh	r1, [r1, #0]
    return ((token) << 16 | (index));
   16b20:	b29b      	uxth	r3, r3
   16b22:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
                tmr->tmrHandle = (SYS_TIME_HANDLE) SYS_TIME_MAKE_HANDLE(gSysTimeTokenCount, tmrObjIndex);
   16b26:	61d4      	str	r4, [r2, #28]
    token++;
   16b28:	1c4b      	adds	r3, r1, #1
   16b2a:	b29b      	uxth	r3, r3
        token = 1;
   16b2c:	f64f 72ff 	movw	r2, #65535	; 0xffff
   16b30:	4293      	cmp	r3, r2
   16b32:	bf08      	it	eq
   16b34:	2301      	moveq	r3, #1
                gSysTimeTokenCount = SYS_TIME_UPDATE_TOKEN(gSysTimeTokenCount);
   16b36:	4a09      	ldr	r2, [pc, #36]	; (16b5c <SYS_TIME_TimerObjectCreate+0xac>)
   16b38:	8013      	strh	r3, [r2, #0]
                break;
   16b3a:	e7c9      	b.n	16ad0 <SYS_TIME_TimerObjectCreate+0x20>
    SYS_TIME_HANDLE tmrHandle = SYS_TIME_HANDLE_INVALID;
   16b3c:	f04f 34ff 	mov.w	r4, #4294967295
   16b40:	e7c6      	b.n	16ad0 <SYS_TIME_TimerObjectCreate+0x20>
   16b42:	f04f 34ff 	mov.w	r4, #4294967295
   16b46:	e7c3      	b.n	16ad0 <SYS_TIME_TimerObjectCreate+0x20>
        return tmrHandle;
   16b48:	f04f 34ff 	mov.w	r4, #4294967295
   16b4c:	e7c2      	b.n	16ad4 <SYS_TIME_TimerObjectCreate+0x24>
   16b4e:	bf00      	nop
   16b50:	2000e230 	.word	0x2000e230
   16b54:	2000dd50 	.word	0x2000dd50
   16b58:	2000dd70 	.word	0x2000dd70
   16b5c:	2000e726 	.word	0x2000e726

Disassembly of section .text.SYS_TIME_Initialize%353:

00016b60 <SYS_TIME_Initialize>:
// Section: System Interface Functions
// *****************************************************************************
// *****************************************************************************
SYS_MODULE_OBJ SYS_TIME_Initialize( const SYS_MODULE_INDEX index, const SYS_MODULE_INIT * const init )
{
    if(init == 0 || index != SYS_TIME_INDEX_0)
   16b60:	2900      	cmp	r1, #0
   16b62:	d044      	beq.n	16bee <SYS_TIME_Initialize+0x8e>
{
   16b64:	b538      	push	{r3, r4, r5, lr}
   16b66:	460d      	mov	r5, r1
    if(init == 0 || index != SYS_TIME_INDEX_0)
   16b68:	2800      	cmp	r0, #0
   16b6a:	d143      	bne.n	16bf4 <SYS_TIME_Initialize+0x94>
    {
        return SYS_MODULE_OBJ_INVALID;
    }
    /* Create mutex to guard from multiple contesting threads */
    if(OSAL_MUTEX_Create(&gSystemCounterObj.timerMutex) != OSAL_RESULT_TRUE)
   16b6c:	4823      	ldr	r0, [pc, #140]	; (16bfc <SYS_TIME_Initialize+0x9c>)
   16b6e:	f00a fcad 	bl	214cc <OSAL_MUTEX_Create>
   16b72:	2801      	cmp	r0, #1
   16b74:	d002      	beq.n	16b7c <SYS_TIME_Initialize+0x1c>
    {
        return SYS_MODULE_OBJ_INVALID;
   16b76:	f04f 30ff 	mov.w	r0, #4294967295
   16b7a:	e03d      	b.n	16bf8 <SYS_TIME_Initialize+0x98>
    counterObj->timePlib = initData->timePlib;
   16b7c:	682b      	ldr	r3, [r5, #0]
   16b7e:	4c20      	ldr	r4, [pc, #128]	; (16c00 <SYS_TIME_Initialize+0xa0>)
   16b80:	6063      	str	r3, [r4, #4]
    counterObj->hwTimerFrequency = counterObj->timePlib->timerFrequencyGet();
   16b82:	68db      	ldr	r3, [r3, #12]
   16b84:	4798      	blx	r3
   16b86:	60e0      	str	r0, [r4, #12]
    cpuCyclesPerTimerClock=(SYS_TIME_CPU_CLOCK_FREQUENCY/counterObj->hwTimerFrequency);
   16b88:	4b1e      	ldr	r3, [pc, #120]	; (16c04 <SYS_TIME_Initialize+0xa4>)
   16b8a:	fbb3 f3f0 	udiv	r3, r3, r0
    counterObj->hwTimerCompareMargin=(SYS_TIME_COMPARE_UPDATE_EXECUTION_CYCLES/cpuCyclesPerTimerClock) +2;
   16b8e:	20bc      	movs	r0, #188	; 0xbc
   16b90:	fb90 f0f3 	sdiv	r0, r0, r3
   16b94:	3002      	adds	r0, #2
   16b96:	6220      	str	r0, [r4, #32]
    counterObj->hwTimerIntNum = initData->hwTimerIntNum;
   16b98:	f9b5 3004 	ldrsh.w	r3, [r5, #4]
   16b9c:	8123      	strh	r3, [r4, #8]
    counterObj->hwTimerPreviousValue = 0;
   16b9e:	2100      	movs	r1, #0
   16ba0:	6121      	str	r1, [r4, #16]
    counterObj->hwTimerPeriodValue = SYS_TIME_HW_COUNTER_PERIOD;
   16ba2:	f64f 73ff 	movw	r3, #65535	; 0xffff
   16ba6:	61a3      	str	r3, [r4, #24]
    counterObj->hwTimerCompareValue = SYS_TIME_HW_COUNTER_HALF_PERIOD;
   16ba8:	f647 73ff 	movw	r3, #32767	; 0x7fff
   16bac:	61e3      	str	r3, [r4, #28]
    counterObj->swCounter64Low = 0;
   16bae:	6261      	str	r1, [r4, #36]	; 0x24
    counterObj->swCounter64High = 0;
   16bb0:	62a1      	str	r1, [r4, #40]	; 0x28
    counterObj->tmrActive = NULL;
   16bb2:	6321      	str	r1, [r4, #48]	; 0x30
    counterObj->interruptNestingCount = 0;
   16bb4:	f884 102c 	strb.w	r1, [r4, #44]	; 0x2c
    counterObj->timePlib->timerCallbackSet(SYS_TIME_PLIBCallback, 0);
   16bb8:	6863      	ldr	r3, [r4, #4]
   16bba:	681b      	ldr	r3, [r3, #0]
   16bbc:	4812      	ldr	r0, [pc, #72]	; (16c08 <SYS_TIME_Initialize+0xa8>)
   16bbe:	4798      	blx	r3
    if (counterObj->timePlib->timerPeriodSet != NULL)
   16bc0:	6863      	ldr	r3, [r4, #4]
   16bc2:	691b      	ldr	r3, [r3, #16]
   16bc4:	b10b      	cbz	r3, 16bca <SYS_TIME_Initialize+0x6a>
        counterObj->timePlib->timerPeriodSet(counterObj->hwTimerPeriodValue);
   16bc6:	8b20      	ldrh	r0, [r4, #24]
   16bc8:	4798      	blx	r3
    counterObj->timePlib->timerCompareSet(counterObj->hwTimerCompareValue);
   16bca:	4c0d      	ldr	r4, [pc, #52]	; (16c00 <SYS_TIME_Initialize+0xa0>)
   16bcc:	69e0      	ldr	r0, [r4, #28]
   16bce:	6863      	ldr	r3, [r4, #4]
   16bd0:	695b      	ldr	r3, [r3, #20]
   16bd2:	b280      	uxth	r0, r0
   16bd4:	4798      	blx	r3
    counterObj->timePlib->timerStart();
   16bd6:	6863      	ldr	r3, [r4, #4]
   16bd8:	685b      	ldr	r3, [r3, #4]
   16bda:	4798      	blx	r3
    }

    SYS_TIME_CounterInit((SYS_MODULE_INIT *)init);
    memset(timers, 0, sizeof(timers));
   16bdc:	22a0      	movs	r2, #160	; 0xa0
   16bde:	2100      	movs	r1, #0
   16be0:	480a      	ldr	r0, [pc, #40]	; (16c0c <SYS_TIME_Initialize+0xac>)
   16be2:	f00a ffcb 	bl	21b7c <memset>

    gSystemCounterObj.status = SYS_STATUS_READY;
   16be6:	2302      	movs	r3, #2
   16be8:	7023      	strb	r3, [r4, #0]

    return (SYS_MODULE_OBJ)&gSystemCounterObj;
   16bea:	4620      	mov	r0, r4
   16bec:	e004      	b.n	16bf8 <SYS_TIME_Initialize+0x98>
        return SYS_MODULE_OBJ_INVALID;
   16bee:	f04f 30ff 	mov.w	r0, #4294967295
}
   16bf2:	4770      	bx	lr
        return SYS_MODULE_OBJ_INVALID;
   16bf4:	f04f 30ff 	mov.w	r0, #4294967295
}
   16bf8:	bd38      	pop	{r3, r4, r5, pc}
   16bfa:	bf00      	nop
   16bfc:	2000e264 	.word	0x2000e264
   16c00:	2000e230 	.word	0x2000e230
   16c04:	07270e00 	.word	0x07270e00
   16c08:	000150fd 	.word	0x000150fd
   16c0c:	2000dd50 	.word	0x2000dd50

Disassembly of section .text.TCPIP_Commands_Initialize%354:

00016c10 <TCPIP_Commands_Initialize>:
{
   16c10:	b510      	push	{r4, lr}
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_UP)
   16c12:	7f03      	ldrb	r3, [r0, #28]
   16c14:	2b03      	cmp	r3, #3
   16c16:	d03b      	beq.n	16c90 <TCPIP_Commands_Initialize+0x80>
    if(commandInitCount == 0)
   16c18:	4b1e      	ldr	r3, [pc, #120]	; (16c94 <TCPIP_Commands_Initialize+0x84>)
   16c1a:	681b      	ldr	r3, [r3, #0]
   16c1c:	b133      	cbz	r3, 16c2c <TCPIP_Commands_Initialize+0x1c>
    commandInitCount++;
   16c1e:	4a1d      	ldr	r2, [pc, #116]	; (16c94 <TCPIP_Commands_Initialize+0x84>)
   16c20:	6813      	ldr	r3, [r2, #0]
   16c22:	3301      	adds	r3, #1
   16c24:	6013      	str	r3, [r2, #0]
    return true;
   16c26:	2401      	movs	r4, #1
}
   16c28:	4620      	mov	r0, r4
   16c2a:	bd10      	pop	{r4, pc}
        initialNetIfs = stackCtrl->nIfs;
   16c2c:	6802      	ldr	r2, [r0, #0]
   16c2e:	4b1a      	ldr	r3, [pc, #104]	; (16c98 <TCPIP_Commands_Initialize+0x88>)
   16c30:	601a      	str	r2, [r3, #0]
        if (!SYS_CMD_ADDGRP(tcpipCmdTbl, sizeof(tcpipCmdTbl)/sizeof(*tcpipCmdTbl), "tcpip", ": stack commands"))
   16c32:	4a1a      	ldr	r2, [pc, #104]	; (16c9c <TCPIP_Commands_Initialize+0x8c>)
   16c34:	f502 7359 	add.w	r3, r2, #868	; 0x364
   16c38:	f502 725e 	add.w	r2, r2, #888	; 0x378
   16c3c:	2110      	movs	r1, #16
   16c3e:	4818      	ldr	r0, [pc, #96]	; (16ca0 <TCPIP_Commands_Initialize+0x90>)
   16c40:	f003 fd5e 	bl	1a700 <SYS_CMD_ADDGRP>
   16c44:	4604      	mov	r4, r0
   16c46:	b168      	cbz	r0, 16c64 <TCPIP_Commands_Initialize+0x54>
        icmpAckRecv = 0;
   16c48:	2200      	movs	r2, #0
   16c4a:	4b16      	ldr	r3, [pc, #88]	; (16ca4 <TCPIP_Commands_Initialize+0x94>)
   16c4c:	601a      	str	r2, [r3, #0]
        tcpipCmdSignalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_COMMAND_Task, 0);
   16c4e:	4916      	ldr	r1, [pc, #88]	; (16ca8 <TCPIP_Commands_Initialize+0x98>)
   16c50:	201f      	movs	r0, #31
   16c52:	f006 f81d 	bl	1cc90 <_TCPIPStackSignalHandlerRegister>
   16c56:	4b15      	ldr	r3, [pc, #84]	; (16cac <TCPIP_Commands_Initialize+0x9c>)
   16c58:	6018      	str	r0, [r3, #0]
        if(tcpipCmdSignalHandle == 0)
   16c5a:	b168      	cbz	r0, 16c78 <TCPIP_Commands_Initialize+0x68>
        tcpipCmdStat = TCPIP_CMD_STAT_IDLE;
   16c5c:	4b14      	ldr	r3, [pc, #80]	; (16cb0 <TCPIP_Commands_Initialize+0xa0>)
   16c5e:	2200      	movs	r2, #0
   16c60:	701a      	strb	r2, [r3, #0]
   16c62:	e7dc      	b.n	16c1e <TCPIP_Commands_Initialize+0xe>
            SYS_ERROR(SYS_ERROR_ERROR, "Failed to create TCPIP Commands\r\n");
   16c64:	f00b f972 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
   16c68:	2800      	cmp	r0, #0
   16c6a:	d0dd      	beq.n	16c28 <TCPIP_Commands_Initialize+0x18>
   16c6c:	f00b f968 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
   16c70:	4910      	ldr	r1, [pc, #64]	; (16cb4 <TCPIP_Commands_Initialize+0xa4>)
   16c72:	f003 fd7b 	bl	1a76c <SYS_CONSOLE_Print>
   16c76:	e7d7      	b.n	16c28 <TCPIP_Commands_Initialize+0x18>
            SYS_ERROR(SYS_ERROR_ERROR, "TCPIP commands task registration failed\r\n");
   16c78:	f00b f968 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
   16c7c:	b908      	cbnz	r0, 16c82 <TCPIP_Commands_Initialize+0x72>
            return false;
   16c7e:	2400      	movs	r4, #0
   16c80:	e7d2      	b.n	16c28 <TCPIP_Commands_Initialize+0x18>
            SYS_ERROR(SYS_ERROR_ERROR, "TCPIP commands task registration failed\r\n");
   16c82:	f00b f95d 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
   16c86:	490c      	ldr	r1, [pc, #48]	; (16cb8 <TCPIP_Commands_Initialize+0xa8>)
   16c88:	f003 fd70 	bl	1a76c <SYS_CONSOLE_Print>
            return false;
   16c8c:	2400      	movs	r4, #0
   16c8e:	e7cb      	b.n	16c28 <TCPIP_Commands_Initialize+0x18>
        return true;
   16c90:	2401      	movs	r4, #1
   16c92:	e7c9      	b.n	16c28 <TCPIP_Commands_Initialize+0x18>
   16c94:	2000e5b0 	.word	0x2000e5b0
   16c98:	2000e5e0 	.word	0x2000e5e0
   16c9c:	00001384 	.word	0x00001384
   16ca0:	00015e68 	.word	0x00015e68
   16ca4:	2000e5bc 	.word	0x2000e5bc
   16ca8:	00009a31 	.word	0x00009a31
   16cac:	2000e5ec 	.word	0x2000e5ec
   16cb0:	2000e3af 	.word	0x2000e3af
   16cb4:	00001704 	.word	0x00001704
   16cb8:	00001728 	.word	0x00001728

Disassembly of section .text._TcpDisconnect%355:

00016cbc <_TcpDisconnect>:
{
   16cbc:	b570      	push	{r4, r5, r6, lr}
	switch(pSkt->smState)
   16cbe:	f890 306e 	ldrb.w	r3, [r0, #110]	; 0x6e
   16cc2:	3b02      	subs	r3, #2
   16cc4:	2b08      	cmp	r3, #8
   16cc6:	d806      	bhi.n	16cd6 <_TcpDisconnect+0x1a>
   16cc8:	e8df f003 	tbb	[pc, r3]
   16ccc:	4b4b0707 	.word	0x4b4b0707
   16cd0:	4b074b4b 	.word	0x4b074b4b
   16cd4:	46          	.byte	0x46
   16cd5:	00          	.byte	0x00
            sendRes = _TCP_SEND_NOT_CONN;
   16cd6:	2001      	movs	r0, #1
   16cd8:	e044      	b.n	16d64 <_TcpDisconnect+0xa8>
   16cda:	4604      	mov	r4, r0
            if(pSkt->flags.nonLinger != 0)
   16cdc:	f890 306c 	ldrb.w	r3, [r0, #108]	; 0x6c
   16ce0:	f013 0f40 	tst.w	r3, #64	; 0x40
   16ce4:	d114      	bne.n	16d10 <_TcpDisconnect+0x54>
            sendData = (signalFIN || (pSkt->txHead != pSkt->txUnackedTail));
   16ce6:	b9f1      	cbnz	r1, 16d26 <_TcpDisconnect+0x6a>
            if(sendData)
   16ce8:	6882      	ldr	r2, [r0, #8]
   16cea:	6903      	ldr	r3, [r0, #16]
   16cec:	429a      	cmp	r2, r3
   16cee:	d118      	bne.n	16d22 <_TcpDisconnect+0x66>
                sendRes = _TCP_SEND_OK; 
   16cf0:	2000      	movs	r0, #0
                pSkt->Flags.failedDisconnect = 0;
   16cf2:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
   16cf6:	f36f 03c3 	bfc	r3, #3, #1
   16cfa:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37
                _TcpSocketSetState(pSkt, pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT ? TCPIP_TCP_STATE_LAST_ACK : TCPIP_TCP_STATE_FIN_WAIT_1);
   16cfe:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
   16d02:	2b08      	cmp	r3, #8
   16d04:	bf0c      	ite	eq
   16d06:	2309      	moveq	r3, #9
   16d08:	2304      	movne	r3, #4
    pSkt->smState = newState;
   16d0a:	f884 306e 	strb.w	r3, [r4, #110]	; 0x6e
   16d0e:	e029      	b.n	16d64 <_TcpDisconnect+0xa8>
    pSkt->txHead = pSkt->txTail = pSkt->txUnackedTail = pSkt->txStart;
   16d10:	6803      	ldr	r3, [r0, #0]
   16d12:	6103      	str	r3, [r0, #16]
   16d14:	60c3      	str	r3, [r0, #12]
   16d16:	6083      	str	r3, [r0, #8]
            sendData = (signalFIN || (pSkt->txHead != pSkt->txUnackedTail));
   16d18:	b109      	cbz	r1, 16d1e <_TcpDisconnect+0x62>
                tcpFlags = signalFIN? FIN | ACK : ACK;
   16d1a:	2511      	movs	r5, #17
   16d1c:	e004      	b.n	16d28 <_TcpDisconnect+0x6c>
                sendRes = _TCP_SEND_OK; 
   16d1e:	2000      	movs	r0, #0
   16d20:	e7e7      	b.n	16cf2 <_TcpDisconnect+0x36>
                tcpFlags = signalFIN? FIN | ACK : ACK;
   16d22:	2510      	movs	r5, #16
   16d24:	e000      	b.n	16d28 <_TcpDisconnect+0x6c>
   16d26:	2511      	movs	r5, #17
                    sendRes = _TcpSend(pSkt, tcpFlags, SENDTCP_RESET_TIMERS);
   16d28:	2601      	movs	r6, #1
   16d2a:	4632      	mov	r2, r6
   16d2c:	4629      	mov	r1, r5
   16d2e:	4620      	mov	r0, r4
   16d30:	f7f0 f9aa 	bl	7088 <_TcpSend>
                    if(sendRes < 0 || pSkt->remoteWindow == 0u)
   16d34:	2800      	cmp	r0, #0
   16d36:	db08      	blt.n	16d4a <_TcpDisconnect+0x8e>
   16d38:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
   16d3c:	2b00      	cmp	r3, #0
   16d3e:	d0d8      	beq.n	16cf2 <_TcpDisconnect+0x36>
                } while(pSkt->txHead != pSkt->txUnackedTail);
   16d40:	68a2      	ldr	r2, [r4, #8]
   16d42:	6923      	ldr	r3, [r4, #16]
   16d44:	429a      	cmp	r2, r3
   16d46:	d1f0      	bne.n	16d2a <_TcpDisconnect+0x6e>
   16d48:	e7d3      	b.n	16cf2 <_TcpDisconnect+0x36>
                pSkt->Flags.failedDisconnect = 1;
   16d4a:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
   16d4e:	f043 0308 	orr.w	r3, r3, #8
   16d52:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37
   16d56:	e005      	b.n	16d64 <_TcpDisconnect+0xa8>
            _TcpCloseSocket(pSkt, 0);
   16d58:	2100      	movs	r1, #0
   16d5a:	f7f9 fe31 	bl	109c0 <_TcpCloseSocket>
            sendRes = _TCP_SEND_OK;
   16d5e:	2000      	movs	r0, #0
            break;
   16d60:	e000      	b.n	16d64 <_TcpDisconnect+0xa8>
            sendRes = _TCP_SEND_OK;
   16d62:	2000      	movs	r0, #0
}
   16d64:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text._TCPIP_HEAP_Malloc%356:

00016d66 <_TCPIP_HEAP_Malloc>:
    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   16d66:	2800      	cmp	r0, #0
   16d68:	d051      	beq.n	16e0e <_TCPIP_HEAP_Malloc+0xa8>
{
   16d6a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16d6c:	4606      	mov	r6, r0
	if(hDcpt == 0 || nBytes == 0)
   16d6e:	2900      	cmp	r1, #0
   16d70:	d03f      	beq.n	16df2 <_TCPIP_HEAP_Malloc+0x8c>
	nunits=(nBytes+sizeof(_headNode)-1)/sizeof(_headNode)+1;	// allocate units   
   16d72:	f101 050f 	add.w	r5, r1, #15
   16d76:	092d      	lsrs	r5, r5, #4
   16d78:	3501      	adds	r5, #1
    OSAL_SEM_Pend(&hDcpt->_heapSemaphore, OSAL_WAIT_FOREVER);
   16d7a:	f100 0744 	add.w	r7, r0, #68	; 0x44
   16d7e:	f64f 71ff 	movw	r1, #65535	; 0xffff
   16d82:	4638      	mov	r0, r7
   16d84:	f009 ff7e 	bl	20c84 <OSAL_SEM_Pend>
	for(ptr = hDcpt->_heapHead; ptr != 0; prev = ptr, ptr = ptr->next)
   16d88:	6a73      	ldr	r3, [r6, #36]	; 0x24
   16d8a:	b353      	cbz	r3, 16de2 <_TCPIP_HEAP_Malloc+0x7c>
		if(ptr->units >= nunits)
   16d8c:	685a      	ldr	r2, [r3, #4]
   16d8e:	4295      	cmp	r5, r2
   16d90:	d931      	bls.n	16df6 <_TCPIP_HEAP_Malloc+0x90>
	for(ptr = hDcpt->_heapHead; ptr != 0; prev = ptr, ptr = ptr->next)
   16d92:	681c      	ldr	r4, [r3, #0]
   16d94:	b32c      	cbz	r4, 16de2 <_TCPIP_HEAP_Malloc+0x7c>
		if(ptr->units >= nunits)
   16d96:	6862      	ldr	r2, [r4, #4]
   16d98:	42aa      	cmp	r2, r5
   16d9a:	d201      	bcs.n	16da0 <_TCPIP_HEAP_Malloc+0x3a>
	for(ptr = hDcpt->_heapHead; ptr != 0; prev = ptr, ptr = ptr->next)
   16d9c:	4623      	mov	r3, r4
   16d9e:	e7f8      	b.n	16d92 <_TCPIP_HEAP_Malloc+0x2c>
			if(ptr->units-nunits <= _TCPIP_HEAP_MIN_BLK_USIZE_)
   16da0:	1b51      	subs	r1, r2, r5
   16da2:	2902      	cmp	r1, #2
   16da4:	d913      	bls.n	16dce <_TCPIP_HEAP_Malloc+0x68>
            if(ptr->units == nunits)
   16da6:	4295      	cmp	r5, r2
   16da8:	d010      	beq.n	16dcc <_TCPIP_HEAP_Malloc+0x66>
				ptr->units -= nunits;
   16daa:	6061      	str	r1, [r4, #4]
				ptr += ptr->units;
   16dac:	eb04 1401 	add.w	r4, r4, r1, lsl #4
				ptr->units = nunits;
   16db0:	6065      	str	r5, [r4, #4]
            if((hDcpt->_heapAllocatedUnits += nunits) > hDcpt->_heapWatermark)
   16db2:	6b33      	ldr	r3, [r6, #48]	; 0x30
   16db4:	441d      	add	r5, r3
   16db6:	6335      	str	r5, [r6, #48]	; 0x30
   16db8:	6b73      	ldr	r3, [r6, #52]	; 0x34
   16dba:	429d      	cmp	r5, r3
                hDcpt->_heapWatermark = hDcpt->_heapAllocatedUnits;
   16dbc:	bf88      	it	hi
   16dbe:	6375      	strhi	r5, [r6, #52]	; 0x34
            OSAL_SEM_Post(&hDcpt->_heapSemaphore);
   16dc0:	4638      	mov	r0, r7
   16dc2:	f00a fb77 	bl	214b4 <OSAL_SEM_Post>
            return ptr + 1;
   16dc6:	f104 0010 	add.w	r0, r4, #16
   16dca:	e011      	b.n	16df0 <_TCPIP_HEAP_Malloc+0x8a>
				if(prev)
   16dcc:	b13b      	cbz	r3, 16dde <_TCPIP_HEAP_Malloc+0x78>
					prev->next = ptr->next;
   16dce:	6821      	ldr	r1, [r4, #0]
   16dd0:	6019      	str	r1, [r3, #0]
   16dd2:	4615      	mov	r5, r2
                if(hDcpt->_heapTail == ptr)
   16dd4:	6ab2      	ldr	r2, [r6, #40]	; 0x28
   16dd6:	42a2      	cmp	r2, r4
   16dd8:	d1eb      	bne.n	16db2 <_TCPIP_HEAP_Malloc+0x4c>
                    hDcpt->_heapTail = prev;
   16dda:	62b3      	str	r3, [r6, #40]	; 0x28
   16ddc:	e7e9      	b.n	16db2 <_TCPIP_HEAP_Malloc+0x4c>
   16dde:	4623      	mov	r3, r4
   16de0:	e00c      	b.n	16dfc <_TCPIP_HEAP_Malloc+0x96>
    hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_NO_MEM;
   16de2:	23fa      	movs	r3, #250	; 0xfa
   16de4:	f886 3038 	strb.w	r3, [r6, #56]	; 0x38
    OSAL_SEM_Post(&hDcpt->_heapSemaphore);
   16de8:	4638      	mov	r0, r7
   16dea:	f00a fb63 	bl	214b4 <OSAL_SEM_Post>
    return 0;
   16dee:	2000      	movs	r0, #0
}
   16df0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return 0;
   16df2:	2000      	movs	r0, #0
   16df4:	e7fc      	b.n	16df0 <_TCPIP_HEAP_Malloc+0x8a>
			if(ptr->units-nunits <= _TCPIP_HEAP_MIN_BLK_USIZE_)
   16df6:	1b51      	subs	r1, r2, r5
   16df8:	2902      	cmp	r1, #2
   16dfa:	d805      	bhi.n	16e08 <_TCPIP_HEAP_Malloc+0xa2>
					hDcpt->_heapHead = ptr->next;
   16dfc:	6819      	ldr	r1, [r3, #0]
   16dfe:	6271      	str	r1, [r6, #36]	; 0x24
   16e00:	461c      	mov	r4, r3
   16e02:	4615      	mov	r5, r2
                    prev = hDcpt->_heapHead;
   16e04:	460b      	mov	r3, r1
   16e06:	e7e5      	b.n	16dd4 <_TCPIP_HEAP_Malloc+0x6e>
	for(ptr = hDcpt->_heapHead; ptr != 0; prev = ptr, ptr = ptr->next)
   16e08:	461c      	mov	r4, r3
	prev=0;
   16e0a:	2300      	movs	r3, #0
   16e0c:	e7cb      	b.n	16da6 <_TCPIP_HEAP_Malloc+0x40>
}
   16e0e:	4770      	bx	lr

Disassembly of section .text.Hash_DRBG_Reseed%357:

00016e10 <Hash_DRBG_Reseed>:
{
   16e10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   16e14:	b092      	sub	sp, #72	; 0x48
   16e16:	4607      	mov	r7, r0
   16e18:	460d      	mov	r5, r1
   16e1a:	4616      	mov	r6, r2
    XMEMSET(newV, 0, DRBG_SEED_LEN);
   16e1c:	2437      	movs	r4, #55	; 0x37
   16e1e:	4622      	mov	r2, r4
   16e20:	2100      	movs	r1, #0
   16e22:	a804      	add	r0, sp, #16
   16e24:	f00a feaa 	bl	21b7c <memset>
                drbg->V, sizeof(drbg->V), seed, seedSz) != DRBG_SUCCESS) {
   16e28:	f107 0808 	add.w	r8, r7, #8
    if (Hash_df(drbg, newV, sizeof(newV), drbgReseed,
   16e2c:	9603      	str	r6, [sp, #12]
   16e2e:	9502      	str	r5, [sp, #8]
   16e30:	9401      	str	r4, [sp, #4]
   16e32:	f8cd 8000 	str.w	r8, [sp]
   16e36:	2301      	movs	r3, #1
   16e38:	4622      	mov	r2, r4
   16e3a:	a904      	add	r1, sp, #16
   16e3c:	4638      	mov	r0, r7
   16e3e:	f7fa fea9 	bl	11b94 <Hash_df>
   16e42:	2800      	cmp	r0, #0
   16e44:	d135      	bne.n	16eb2 <Hash_DRBG_Reseed+0xa2>
    XMEMCPY(drbg->V, newV, sizeof(drbg->V));
   16e46:	ae04      	add	r6, sp, #16
   16e48:	4644      	mov	r4, r8
   16e4a:	f10d 0c40 	add.w	ip, sp, #64	; 0x40
   16e4e:	4635      	mov	r5, r6
   16e50:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   16e52:	6020      	str	r0, [r4, #0]
   16e54:	6061      	str	r1, [r4, #4]
   16e56:	60a2      	str	r2, [r4, #8]
   16e58:	60e3      	str	r3, [r4, #12]
   16e5a:	462e      	mov	r6, r5
   16e5c:	3410      	adds	r4, #16
   16e5e:	4565      	cmp	r5, ip
   16e60:	d1f5      	bne.n	16e4e <Hash_DRBG_Reseed+0x3e>
   16e62:	6828      	ldr	r0, [r5, #0]
   16e64:	6020      	str	r0, [r4, #0]
   16e66:	88aa      	ldrh	r2, [r5, #4]
   16e68:	79ab      	ldrb	r3, [r5, #6]
   16e6a:	80a2      	strh	r2, [r4, #4]
   16e6c:	71a3      	strb	r3, [r4, #6]
    volatile byte* z = (volatile byte*)mem;
   16e6e:	aa04      	add	r2, sp, #16
    while (len--) *z++ = 0;
   16e70:	2000      	movs	r0, #0
   16e72:	f10d 0147 	add.w	r1, sp, #71	; 0x47
   16e76:	4613      	mov	r3, r2
   16e78:	f803 0b01 	strb.w	r0, [r3], #1
   16e7c:	461a      	mov	r2, r3
   16e7e:	428b      	cmp	r3, r1
   16e80:	d1f9      	bne.n	16e76 <Hash_DRBG_Reseed+0x66>
    if (Hash_df(drbg, drbg->C, sizeof(drbg->C), drbgInitC, drbg->V,
   16e82:	2300      	movs	r3, #0
   16e84:	9303      	str	r3, [sp, #12]
   16e86:	9302      	str	r3, [sp, #8]
   16e88:	2237      	movs	r2, #55	; 0x37
   16e8a:	9201      	str	r2, [sp, #4]
   16e8c:	f8cd 8000 	str.w	r8, [sp]
   16e90:	f107 013f 	add.w	r1, r7, #63	; 0x3f
   16e94:	4638      	mov	r0, r7
   16e96:	f7fa fe7d 	bl	11b94 <Hash_df>
   16e9a:	4603      	mov	r3, r0
   16e9c:	b958      	cbnz	r0, 16eb6 <Hash_DRBG_Reseed+0xa6>
    drbg->reseedCtr = 1;
   16e9e:	2201      	movs	r2, #1
   16ea0:	603a      	str	r2, [r7, #0]
    drbg->lastBlock = 0;
   16ea2:	2200      	movs	r2, #0
   16ea4:	607a      	str	r2, [r7, #4]
    drbg->matchCount = 0;
   16ea6:	f887 2080 	strb.w	r2, [r7, #128]	; 0x80
}
   16eaa:	4618      	mov	r0, r3
   16eac:	b012      	add	sp, #72	; 0x48
   16eae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return DRBG_FAILURE;
   16eb2:	2301      	movs	r3, #1
   16eb4:	e7f9      	b.n	16eaa <Hash_DRBG_Reseed+0x9a>
        return DRBG_FAILURE;
   16eb6:	2301      	movs	r3, #1
   16eb8:	e7f7      	b.n	16eaa <Hash_DRBG_Reseed+0x9a>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseReset%358:

00016ebc <_DRV_ETHPHY_SetupPhaseReset>:
{
   16ebc:	b538      	push	{r3, r4, r5, lr}
   16ebe:	4604      	mov	r4, r0
    switch(hClientObj->operSubPhase)
   16ec0:	8c03      	ldrh	r3, [r0, #32]
   16ec2:	2b01      	cmp	r3, #1
   16ec4:	d014      	beq.n	16ef0 <_DRV_ETHPHY_SetupPhaseReset+0x34>
   16ec6:	b21a      	sxth	r2, r3
   16ec8:	b132      	cbz	r2, 16ed8 <_DRV_ETHPHY_SetupPhaseReset+0x1c>
   16eca:	2b02      	cmp	r3, #2
   16ecc:	d02a      	beq.n	16f24 <_DRV_ETHPHY_SetupPhaseReset+0x68>
            _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_DTCT_ERR);
   16ece:	f04f 31ff 	mov.w	r1, #4294967295
   16ed2:	f008 fe77 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
}
   16ed6:	bd38      	pop	{r3, r4, r5, pc}
            if(_DRV_PHY_SMIWriteStart(hClientObj, PHY_REG_BMCON, _BMCON_RESET_MASK))
   16ed8:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   16edc:	2100      	movs	r1, #0
   16ede:	f007 ff44 	bl	1ed6a <_DRV_PHY_SMIWriteStart>
   16ee2:	2800      	cmp	r0, #0
   16ee4:	d0f7      	beq.n	16ed6 <_DRV_ETHPHY_SetupPhaseReset+0x1a>
    hClientObj->operPhase = operPhase;
   16ee6:	2302      	movs	r3, #2
   16ee8:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   16eea:	2301      	movs	r3, #1
   16eec:	8423      	strh	r3, [r4, #32]
   16eee:	e7f2      	b.n	16ed6 <_DRV_ETHPHY_SetupPhaseReset+0x1a>
            if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMCON))
   16ef0:	2100      	movs	r1, #0
   16ef2:	f007 ff21 	bl	1ed38 <_DRV_PHY_SMIReadStart>
   16ef6:	2800      	cmp	r0, #0
   16ef8:	d0ed      	beq.n	16ed6 <_DRV_ETHPHY_SetupPhaseReset+0x1a>
                hClientObj->operTStamp = SYS_TMR_TickCountGet() + ((DRV_ETHPHY_RESET_CLR_TMO * SYS_TMR_TickCounterFrequencyGet()) + 999) / 1000;
   16efa:	f009 f857 	bl	1ffac <SYS_TMR_TickCountGet>
   16efe:	4605      	mov	r5, r0
   16f00:	f009 f87c 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
   16f04:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   16f08:	fb03 f000 	mul.w	r0, r3, r0
   16f0c:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
   16f10:	4b13      	ldr	r3, [pc, #76]	; (16f60 <_DRV_ETHPHY_SetupPhaseReset+0xa4>)
   16f12:	fba3 3000 	umull	r3, r0, r3, r0
   16f16:	eb05 1090 	add.w	r0, r5, r0, lsr #6
   16f1a:	62a0      	str	r0, [r4, #40]	; 0x28
    hClientObj->operPhase = operPhase;
   16f1c:	2302      	movs	r3, #2
   16f1e:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   16f20:	8423      	strh	r3, [r4, #32]
   16f22:	e7d8      	b.n	16ed6 <_DRV_ETHPHY_SetupPhaseReset+0x1a>
            if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   16f24:	f009 fb9e 	bl	20664 <_DRV_PHY_SMITransfer_Wait>
   16f28:	2800      	cmp	r0, #0
   16f2a:	d0d4      	beq.n	16ed6 <_DRV_ETHPHY_SetupPhaseReset+0x1a>
            if(bmcon.RESET)
   16f2c:	f994 303b 	ldrsb.w	r3, [r4, #59]	; 0x3b
   16f30:	2b00      	cmp	r3, #0
   16f32:	db04      	blt.n	16f3e <_DRV_ETHPHY_SetupPhaseReset+0x82>
    hClientObj->operPhase = operPhase;
   16f34:	2303      	movs	r3, #3
   16f36:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   16f38:	2300      	movs	r3, #0
   16f3a:	8423      	strh	r3, [r4, #32]
   16f3c:	e7cb      	b.n	16ed6 <_DRV_ETHPHY_SetupPhaseReset+0x1a>
                if(SYS_TMR_TickCountGet() < hClientObj->operTStamp)
   16f3e:	f009 f835 	bl	1ffac <SYS_TMR_TickCountGet>
   16f42:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   16f44:	4298      	cmp	r0, r3
   16f46:	d204      	bcs.n	16f52 <_DRV_ETHPHY_SetupPhaseReset+0x96>
    hClientObj->operPhase = operPhase;
   16f48:	2302      	movs	r3, #2
   16f4a:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   16f4c:	2301      	movs	r3, #1
   16f4e:	8423      	strh	r3, [r4, #32]
   16f50:	e7c1      	b.n	16ed6 <_DRV_ETHPHY_SetupPhaseReset+0x1a>
                    _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_DTCT_ERR);
   16f52:	f04f 31ff 	mov.w	r1, #4294967295
   16f56:	4620      	mov	r0, r4
   16f58:	f008 fe34 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
   16f5c:	e7bb      	b.n	16ed6 <_DRV_ETHPHY_SetupPhaseReset+0x1a>
   16f5e:	bf00      	nop
   16f60:	10624dd3 	.word	0x10624dd3

Disassembly of section .text._TCP_SktSetSequenceNo%359:

00016f64 <_TCP_SktSetSequenceNo>:
{
   16f64:	b570      	push	{r4, r5, r6, lr}
   16f66:	b0fa      	sub	sp, #488	; 0x1e8
   16f68:	4604      	mov	r4, r0
    SYS_RANDOM_CryptoBlockGet(secretKey, sizeof(secretKey));
   16f6a:	2110      	movs	r1, #16
   16f6c:	a808      	add	r0, sp, #32
   16f6e:	f009 f957 	bl	20220 <SYS_RANDOM_CryptoBlockGet>
    CRYPT_MD5_Initialize(&md5Ctx);
   16f72:	a80c      	add	r0, sp, #48	; 0x30
   16f74:	f00a fcd6 	bl	21924 <CRYPT_MD5_Initialize>
    if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   16f78:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
   16f7c:	2b01      	cmp	r3, #1
   16f7e:	d033      	beq.n	16fe8 <_TCP_SktSetSequenceNo+0x84>
    size_t dataSize = 0;    // actual data size
   16f80:	2200      	movs	r2, #0
    CRYPT_MD5_DataAdd(&md5Ctx, hashData.data8, dataSize);
   16f82:	a901      	add	r1, sp, #4
   16f84:	a80c      	add	r0, sp, #48	; 0x30
   16f86:	f00a f980 	bl	2128a <CRYPT_MD5_DataAdd>
    CRYPT_MD5_Finalize(&md5Ctx, hashData.data8);
   16f8a:	a901      	add	r1, sp, #4
   16f8c:	a80c      	add	r0, sp, #48	; 0x30
   16f8e:	f00a f988 	bl	212a2 <CRYPT_MD5_Finalize>
    uint32_t m = (SYS_TIME_Counter64Get() * 1000000 / 64 ) / SYS_TIME_FrequencyGet();   // 274 seconds period > MSL = 120 seconds
   16f92:	f007 f8bd 	bl	1e110 <SYS_TIME_Counter64Get>
   16f96:	4604      	mov	r4, r0
   16f98:	460d      	mov	r5, r1
   16f9a:	f00a ffdd 	bl	21f58 <SYS_TIME_FrequencyGet>
   16f9e:	016a      	lsls	r2, r5, #5
   16fa0:	0163      	lsls	r3, r4, #5
   16fa2:	ea42 61d4 	orr.w	r1, r2, r4, lsr #27
   16fa6:	1b1b      	subs	r3, r3, r4
   16fa8:	eb61 0105 	sbc.w	r1, r1, r5
   16fac:	024a      	lsls	r2, r1, #9
   16fae:	ea42 52d3 	orr.w	r2, r2, r3, lsr #23
   16fb2:	025e      	lsls	r6, r3, #9
   16fb4:	4611      	mov	r1, r2
   16fb6:	1933      	adds	r3, r6, r4
   16fb8:	eb45 0101 	adc.w	r1, r5, r1
   16fbc:	018e      	lsls	r6, r1, #6
   16fbe:	ea46 6693 	orr.w	r6, r6, r3, lsr #26
   16fc2:	019a      	lsls	r2, r3, #6
   16fc4:	1ad3      	subs	r3, r2, r3
   16fc6:	eb66 0101 	sbc.w	r1, r6, r1
   16fca:	191b      	adds	r3, r3, r4
   16fcc:	eb45 0101 	adc.w	r1, r5, r1
   16fd0:	099c      	lsrs	r4, r3, #6
   16fd2:	4602      	mov	r2, r0
   16fd4:	2300      	movs	r3, #0
   16fd6:	ea44 6081 	orr.w	r0, r4, r1, lsl #26
   16fda:	0989      	lsrs	r1, r1, #6
   16fdc:	f008 f9ca 	bl	1f374 <__aeabi_uldivmod>
    uint32_t seq = hashData.data32[0] + m;
   16fe0:	9b01      	ldr	r3, [sp, #4]
}
   16fe2:	4418      	add	r0, r3
   16fe4:	b07a      	add	sp, #488	; 0x1e8
   16fe6:	bd70      	pop	{r4, r5, r6, pc}
        hashData.ipv4HashData[0] = pSkt->srcAddress.Val;
   16fe8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   16fea:	9301      	str	r3, [sp, #4]
        hashData.ipv4HashData[1] = pSkt->destAddress.Val;
   16fec:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   16fee:	9302      	str	r3, [sp, #8]
        hashData.ipv4HashData[2] = ((uint32_t)pSkt->localPort << 16) + (uint32_t)pSkt->remotePort;
   16ff0:	f8b4 205a 	ldrh.w	r2, [r4, #90]	; 0x5a
   16ff4:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
   16ff8:	eb03 4302 	add.w	r3, r3, r2, lsl #16
   16ffc:	9303      	str	r3, [sp, #12]
        memcpy(hashData.ipv4HashData + 3, secretKey, sizeof(secretKey));
   16ffe:	ab08      	add	r3, sp, #32
   17000:	ac04      	add	r4, sp, #16
   17002:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   17004:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        dataSize = sizeof(hashData.ipv4HashData);
   17008:	221c      	movs	r2, #28
   1700a:	e7ba      	b.n	16f82 <_TCP_SktSetSequenceNo+0x1e>

Disassembly of section .text.TCPIP_TCP_ServerOpen%360:

0001700c <TCPIP_TCP_ServerOpen>:
{
   1700c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   if(addType == IP_ADDRESS_TYPE_IPV6)
   1700e:	2802      	cmp	r0, #2
   17010:	d038      	beq.n	17084 <TCPIP_TCP_ServerOpen+0x78>
   17012:	4614      	mov	r4, r2
   17014:	460d      	mov	r5, r1
    if(addType == IP_ADDRESS_TYPE_IPV4 && localAddress != 0 && localAddress->v4Add.Val != 0)
   17016:	b10a      	cbz	r2, 1701c <TCPIP_TCP_ServerOpen+0x10>
   17018:	6813      	ldr	r3, [r2, #0]
   1701a:	b95b      	cbnz	r3, 17034 <TCPIP_TCP_ServerOpen+0x28>
    skt = _TCP_Open(addType, TCP_OPEN_SERVER, localPort, 0);
   1701c:	2300      	movs	r3, #0
   1701e:	462a      	mov	r2, r5
   17020:	4619      	mov	r1, r3
   17022:	2001      	movs	r0, #1
   17024:	f7f5 f8ac 	bl	c180 <_TCP_Open>
   17028:	4606      	mov	r6, r0
    if(skt != INVALID_SOCKET)
   1702a:	f1b0 3fff 	cmp.w	r0, #4294967295
   1702e:	d12f      	bne.n	17090 <TCPIP_TCP_ServerOpen+0x84>
}
   17030:	4630      	mov	r0, r6
   17032:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        pDefIf = TCPIP_STACK_IPAddToNet(&localAddress->v4Add, false);
   17034:	2100      	movs	r1, #0
   17036:	4610      	mov	r0, r2
   17038:	f009 f9cc 	bl	203d4 <TCPIP_STACK_IPAddToNet>
        if(pDefIf == 0)
   1703c:	4607      	mov	r7, r0
   1703e:	b320      	cbz	r0, 1708a <TCPIP_TCP_ServerOpen+0x7e>
    skt = _TCP_Open(addType, TCP_OPEN_SERVER, localPort, 0);
   17040:	2300      	movs	r3, #0
   17042:	462a      	mov	r2, r5
   17044:	4619      	mov	r1, r3
   17046:	2001      	movs	r0, #1
   17048:	f7f5 f89a 	bl	c180 <_TCP_Open>
   1704c:	4606      	mov	r6, r0
    if(skt != INVALID_SOCKET)
   1704e:	f1b0 3fff 	cmp.w	r0, #4294967295
   17052:	d0ed      	beq.n	17030 <TCPIP_TCP_ServerOpen+0x24>
        TCB_STUB* pSkt = TCBStubs[skt]; 
   17054:	4b16      	ldr	r3, [pc, #88]	; (170b0 <TCPIP_TCP_ServerOpen+0xa4>)
   17056:	681b      	ldr	r3, [r3, #0]
   17058:	f853 5026 	ldr.w	r5, [r3, r6, lsl #2]
    pSkt->pSktNet = pNet;
   1705c:	642f      	str	r7, [r5, #64]	; 0x40
    _TCPSetSourceAddress(pSkt, pSkt->addType, srcAddress);
   1705e:	4622      	mov	r2, r4
   17060:	f895 106f 	ldrb.w	r1, [r5, #111]	; 0x6f
   17064:	4628      	mov	r0, r5
   17066:	f007 fb58 	bl	1e71a <_TCPSetSourceAddress>
            pSkt->flags.openBindIf = 1;
   1706a:	f895 306d 	ldrb.w	r3, [r5, #109]	; 0x6d
   1706e:	f043 0320 	orr.w	r3, r3, #32
   17072:	f885 306d 	strb.w	r3, [r5, #109]	; 0x6d
            pSkt->flags.openBindAdd = 1;
   17076:	f895 306d 	ldrb.w	r3, [r5, #109]	; 0x6d
   1707a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1707e:	f885 306d 	strb.w	r3, [r5, #109]	; 0x6d
   17082:	e7d5      	b.n	17030 <TCPIP_TCP_ServerOpen+0x24>
       return INVALID_SOCKET;
   17084:	f04f 36ff 	mov.w	r6, #4294967295
   17088:	e7d2      	b.n	17030 <TCPIP_TCP_ServerOpen+0x24>
            return INVALID_SOCKET;
   1708a:	f04f 36ff 	mov.w	r6, #4294967295
   1708e:	e7cf      	b.n	17030 <TCPIP_TCP_ServerOpen+0x24>
        TCB_STUB* pSkt = TCBStubs[skt]; 
   17090:	4b07      	ldr	r3, [pc, #28]	; (170b0 <TCPIP_TCP_ServerOpen+0xa4>)
   17092:	681b      	ldr	r3, [r3, #0]
   17094:	f853 5026 	ldr.w	r5, [r3, r6, lsl #2]
    pSkt->pSktNet = pNet;
   17098:	2300      	movs	r3, #0
   1709a:	642b      	str	r3, [r5, #64]	; 0x40
    _TCPSetSourceAddress(pSkt, pSkt->addType, srcAddress);
   1709c:	4622      	mov	r2, r4
   1709e:	f895 106f 	ldrb.w	r1, [r5, #111]	; 0x6f
   170a2:	4628      	mov	r0, r5
   170a4:	f007 fb39 	bl	1e71a <_TCPSetSourceAddress>
        if(localAddress != 0)
   170a8:	2c00      	cmp	r4, #0
   170aa:	d0c1      	beq.n	17030 <TCPIP_TCP_ServerOpen+0x24>
   170ac:	e7e3      	b.n	17076 <TCPIP_TCP_ServerOpen+0x6a>
   170ae:	bf00      	nop
   170b0:	2000e594 	.word	0x2000e594

Disassembly of section .text.SERCOM1_USART_Write%361:

000170b4 <SERCOM1_USART_Write>:
{
   170b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    while (nBytesWritten < size)
   170b8:	2900      	cmp	r1, #0
   170ba:	d046      	beq.n	1714a <SERCOM1_USART_Write+0x96>
   170bc:	468c      	mov	ip, r1
    if (tempInIndex >= sercom1USARTObj.wrBufferSize)
   170be:	4b24      	ldr	r3, [pc, #144]	; (17150 <SERCOM1_USART_Write+0x9c>)
   170c0:	691f      	ldr	r7, [r3, #16]
   170c2:	2400      	movs	r4, #0
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   170c4:	4923      	ldr	r1, [pc, #140]	; (17154 <SERCOM1_USART_Write+0xa0>)
    uint32_t wrInIndex = sercom1USARTObj.wrInIndex;
   170c6:	461a      	mov	r2, r3
            ((uint16_t*)&SERCOM1_USART_WriteBuffer)[wrInIndex] = wrByte;
   170c8:	f8df e08c 	ldr.w	lr, [pc, #140]	; 17158 <SERCOM1_USART_Write+0xa4>
   170cc:	e00f      	b.n	170ee <SERCOM1_USART_Write+0x3a>
            if (SERCOM1_USART_TxPushByte(pWrBuffer[nBytesWritten]) == true)
   170ce:	f810 8004 	ldrb.w	r8, [r0, r4]
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   170d2:	684e      	ldr	r6, [r1, #4]
   170d4:	f006 0607 	and.w	r6, r6, #7
   170d8:	2e01      	cmp	r6, #1
            SERCOM1_USART_WriteBuffer[wrInIndex] = (uint8_t)wrByte;
   170da:	bf14      	ite	ne
   170dc:	f80e 8005 	strbne.w	r8, [lr, r5]
            if (SERCOM1_USART_TxPushByte(pWrBuffer[nBytesWritten]) == true)
   170e0:	f82e 8015 	strheq.w	r8, [lr, r5, lsl #1]
        sercom1USARTObj.wrInIndex = tempInIndex;
   170e4:	6093      	str	r3, [r2, #8]
                nBytesWritten++;
   170e6:	1c63      	adds	r3, r4, #1
   170e8:	3401      	adds	r4, #1
    while (nBytesWritten < size)
   170ea:	4563      	cmp	r3, ip
   170ec:	d22b      	bcs.n	17146 <SERCOM1_USART_Write+0x92>
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   170ee:	684b      	ldr	r3, [r1, #4]
   170f0:	f003 0307 	and.w	r3, r3, #7
   170f4:	2b01      	cmp	r3, #1
   170f6:	d010      	beq.n	1711a <SERCOM1_USART_Write+0x66>
    uint32_t wrInIndex = sercom1USARTObj.wrInIndex;
   170f8:	6895      	ldr	r5, [r2, #8]
    uint32_t wrOutIndex = sercom1USARTObj.wrOutIndex;
   170fa:	68d6      	ldr	r6, [r2, #12]
    tempInIndex = wrInIndex + 1U;
   170fc:	1c6b      	adds	r3, r5, #1
        tempInIndex = 0U;
   170fe:	42bb      	cmp	r3, r7
   17100:	bf28      	it	cs
   17102:	2300      	movcs	r3, #0
    if (tempInIndex != wrOutIndex)
   17104:	429e      	cmp	r6, r3
   17106:	d1e2      	bne.n	170ce <SERCOM1_USART_Write+0x1a>
    if (SERCOM1_USART_WritePendingBytesGet() > 0U)
   17108:	f00a f9f8 	bl	214fc <SERCOM1_USART_WritePendingBytesGet>
   1710c:	b110      	cbz	r0, 17114 <SERCOM1_USART_Write+0x60>
        SERCOM1_USART_TX_INT_ENABLE();
   1710e:	4b11      	ldr	r3, [pc, #68]	; (17154 <SERCOM1_USART_Write+0xa0>)
   17110:	2201      	movs	r2, #1
   17112:	759a      	strb	r2, [r3, #22]
}
   17114:	4620      	mov	r0, r4
   17116:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    uint32_t wrInIndex = sercom1USARTObj.wrInIndex;
   1711a:	6895      	ldr	r5, [r2, #8]
    uint32_t wrOutIndex = sercom1USARTObj.wrOutIndex;
   1711c:	68d6      	ldr	r6, [r2, #12]
    tempInIndex = wrInIndex + 1U;
   1711e:	1c6b      	adds	r3, r5, #1
        tempInIndex = 0U;
   17120:	42bb      	cmp	r3, r7
   17122:	bf28      	it	cs
   17124:	2300      	movcs	r3, #0
    if (tempInIndex != wrOutIndex)
   17126:	429e      	cmp	r6, r3
   17128:	d0ee      	beq.n	17108 <SERCOM1_USART_Write+0x54>
            if (SERCOM1_USART_TxPushByte(((uint16_t*)pWrBuffer)[nBytesWritten]) == true)
   1712a:	f830 8014 	ldrh.w	r8, [r0, r4, lsl #1]
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   1712e:	684e      	ldr	r6, [r1, #4]
   17130:	f006 0607 	and.w	r6, r6, #7
   17134:	2e01      	cmp	r6, #1
            SERCOM1_USART_WriteBuffer[wrInIndex] = (uint8_t)wrByte;
   17136:	bf14      	ite	ne
   17138:	f80e 8005 	strbne.w	r8, [lr, r5]
            ((uint16_t*)&SERCOM1_USART_WriteBuffer)[wrInIndex] = wrByte;
   1713c:	f82e 8015 	strheq.w	r8, [lr, r5, lsl #1]
        sercom1USARTObj.wrInIndex = tempInIndex;
   17140:	6093      	str	r3, [r2, #8]
                nBytesWritten++;
   17142:	1c63      	adds	r3, r4, #1
   17144:	e7d0      	b.n	170e8 <SERCOM1_USART_Write+0x34>
   17146:	461c      	mov	r4, r3
   17148:	e7de      	b.n	17108 <SERCOM1_USART_Write+0x54>
    size_t nBytesWritten  = 0U;
   1714a:	460c      	mov	r4, r1
   1714c:	e7dc      	b.n	17108 <SERCOM1_USART_Write+0x54>
   1714e:	bf00      	nop
   17150:	2000e1f0 	.word	0x2000e1f0
   17154:	40003400 	.word	0x40003400
   17158:	2000b004 	.word	0x2000b004

Disassembly of section .text.vTaskSwitchContext%362:

0001715c <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   1715c:	4b24      	ldr	r3, [pc, #144]	; (171f0 <vTaskSwitchContext+0x94>)
   1715e:	681b      	ldr	r3, [r3, #0]
   17160:	b11b      	cbz	r3, 1716a <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
   17162:	4b24      	ldr	r3, [pc, #144]	; (171f4 <vTaskSwitchContext+0x98>)
   17164:	2201      	movs	r2, #1
   17166:	601a      	str	r2, [r3, #0]
   17168:	4770      	bx	lr
{
   1716a:	b510      	push	{r4, lr}
		xYieldPending = pdFALSE;
   1716c:	4b21      	ldr	r3, [pc, #132]	; (171f4 <vTaskSwitchContext+0x98>)
   1716e:	2200      	movs	r2, #0
   17170:	601a      	str	r2, [r3, #0]
		taskCHECK_FOR_STACK_OVERFLOW();
   17172:	4b21      	ldr	r3, [pc, #132]	; (171f8 <vTaskSwitchContext+0x9c>)
   17174:	681b      	ldr	r3, [r3, #0]
   17176:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   17178:	681a      	ldr	r2, [r3, #0]
   1717a:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
   1717e:	d103      	bne.n	17188 <vTaskSwitchContext+0x2c>
   17180:	685a      	ldr	r2, [r3, #4]
   17182:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
   17186:	d023      	beq.n	171d0 <vTaskSwitchContext+0x74>
   17188:	4b1b      	ldr	r3, [pc, #108]	; (171f8 <vTaskSwitchContext+0x9c>)
   1718a:	6818      	ldr	r0, [r3, #0]
   1718c:	6819      	ldr	r1, [r3, #0]
   1718e:	3134      	adds	r1, #52	; 0x34
   17190:	f00a fc07 	bl	219a2 <vApplicationStackOverflowHook>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   17194:	4b19      	ldr	r3, [pc, #100]	; (171fc <vTaskSwitchContext+0xa0>)
   17196:	681b      	ldr	r3, [r3, #0]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
	{
	uint8_t ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
   17198:	fab3 f383 	clz	r3, r3
   1719c:	b2db      	uxtb	r3, r3
   1719e:	f1c3 031f 	rsb	r3, r3, #31
   171a2:	4a17      	ldr	r2, [pc, #92]	; (17200 <vTaskSwitchContext+0xa4>)
   171a4:	0099      	lsls	r1, r3, #2
   171a6:	18c8      	adds	r0, r1, r3
   171a8:	eb02 0080 	add.w	r0, r2, r0, lsl #2
   171ac:	6844      	ldr	r4, [r0, #4]
   171ae:	6864      	ldr	r4, [r4, #4]
   171b0:	6044      	str	r4, [r0, #4]
   171b2:	4419      	add	r1, r3
   171b4:	4602      	mov	r2, r0
   171b6:	3208      	adds	r2, #8
   171b8:	4294      	cmp	r4, r2
   171ba:	d012      	beq.n	171e2 <vTaskSwitchContext+0x86>
   171bc:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   171c0:	4a0f      	ldr	r2, [pc, #60]	; (17200 <vTaskSwitchContext+0xa4>)
   171c2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   171c6:	685b      	ldr	r3, [r3, #4]
   171c8:	68da      	ldr	r2, [r3, #12]
   171ca:	4b0b      	ldr	r3, [pc, #44]	; (171f8 <vTaskSwitchContext+0x9c>)
   171cc:	601a      	str	r2, [r3, #0]
}
   171ce:	bd10      	pop	{r4, pc}
		taskCHECK_FOR_STACK_OVERFLOW();
   171d0:	689a      	ldr	r2, [r3, #8]
   171d2:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
   171d6:	d1d7      	bne.n	17188 <vTaskSwitchContext+0x2c>
   171d8:	68db      	ldr	r3, [r3, #12]
   171da:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
   171de:	d1d3      	bne.n	17188 <vTaskSwitchContext+0x2c>
   171e0:	e7d8      	b.n	17194 <vTaskSwitchContext+0x38>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   171e2:	6860      	ldr	r0, [r4, #4]
   171e4:	460a      	mov	r2, r1
   171e6:	4906      	ldr	r1, [pc, #24]	; (17200 <vTaskSwitchContext+0xa4>)
   171e8:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   171ec:	6050      	str	r0, [r2, #4]
   171ee:	e7e5      	b.n	171bc <vTaskSwitchContext+0x60>
   171f0:	2000e6b8 	.word	0x2000e6b8
   171f4:	2000e6dc 	.word	0x2000e6dc
   171f8:	2000e6a4 	.word	0x2000e6a4
   171fc:	2000e6c0 	.word	0x2000e6c0
   17200:	2000e080 	.word	0x2000e080

Disassembly of section .text.xTaskPriorityInherit%363:

00017204 <xTaskPriorityInherit>:
	BaseType_t xReturn = pdFALSE;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
   17204:	2800      	cmp	r0, #0
   17206:	d049      	beq.n	1729c <xTaskPriorityInherit+0x98>
	{
   17208:	b538      	push	{r3, r4, r5, lr}
   1720a:	4604      	mov	r4, r0
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
   1720c:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   1720e:	4924      	ldr	r1, [pc, #144]	; (172a0 <xTaskPriorityInherit+0x9c>)
   17210:	6809      	ldr	r1, [r1, #0]
   17212:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
   17214:	428a      	cmp	r2, r1
   17216:	d238      	bcs.n	1728a <xTaskPriorityInherit+0x86>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   17218:	6981      	ldr	r1, [r0, #24]
   1721a:	2900      	cmp	r1, #0
   1721c:	db05      	blt.n	1722a <xTaskPriorityInherit+0x26>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1721e:	4920      	ldr	r1, [pc, #128]	; (172a0 <xTaskPriorityInherit+0x9c>)
   17220:	6809      	ldr	r1, [r1, #0]
   17222:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
   17224:	f1c1 0105 	rsb	r1, r1, #5
   17228:	6181      	str	r1, [r0, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
   1722a:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   1722e:	491d      	ldr	r1, [pc, #116]	; (172a4 <xTaskPriorityInherit+0xa0>)
   17230:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   17234:	6961      	ldr	r1, [r4, #20]
   17236:	4291      	cmp	r1, r2
   17238:	d005      	beq.n	17246 <xTaskPriorityInherit+0x42>
					prvAddTaskToReadyList( pxMutexHolderTCB );
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   1723a:	4a19      	ldr	r2, [pc, #100]	; (172a0 <xTaskPriorityInherit+0x9c>)
   1723c:	6812      	ldr	r2, [r2, #0]
   1723e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
   17240:	62e2      	str	r2, [r4, #44]	; 0x2c
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
   17242:	2001      	movs	r0, #1
   17244:	e029      	b.n	1729a <xTaskPriorityInherit+0x96>
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   17246:	1d25      	adds	r5, r4, #4
   17248:	4628      	mov	r0, r5
   1724a:	f009 f933 	bl	204b4 <uxListRemove>
   1724e:	b938      	cbnz	r0, 17260 <xTaskPriorityInherit+0x5c>
						portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
   17250:	4915      	ldr	r1, [pc, #84]	; (172a8 <xTaskPriorityInherit+0xa4>)
   17252:	680b      	ldr	r3, [r1, #0]
   17254:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   17256:	2201      	movs	r2, #1
   17258:	4082      	lsls	r2, r0
   1725a:	ea23 0302 	bic.w	r3, r3, r2
   1725e:	600b      	str	r3, [r1, #0]
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   17260:	4b0f      	ldr	r3, [pc, #60]	; (172a0 <xTaskPriorityInherit+0x9c>)
   17262:	681b      	ldr	r3, [r3, #0]
   17264:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
   17266:	62e0      	str	r0, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
   17268:	4a0f      	ldr	r2, [pc, #60]	; (172a8 <xTaskPriorityInherit+0xa4>)
   1726a:	6811      	ldr	r1, [r2, #0]
   1726c:	2401      	movs	r4, #1
   1726e:	fa04 f300 	lsl.w	r3, r4, r0
   17272:	430b      	orrs	r3, r1
   17274:	6013      	str	r3, [r2, #0]
   17276:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   1727a:	4629      	mov	r1, r5
   1727c:	4b09      	ldr	r3, [pc, #36]	; (172a4 <xTaskPriorityInherit+0xa0>)
   1727e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   17282:	f00a fa50 	bl	21726 <vListInsertEnd>
				xReturn = pdTRUE;
   17286:	4620      	mov	r0, r4
   17288:	e007      	b.n	1729a <xTaskPriorityInherit+0x96>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
   1728a:	4a05      	ldr	r2, [pc, #20]	; (172a0 <xTaskPriorityInherit+0x9c>)
   1728c:	6812      	ldr	r2, [r2, #0]
   1728e:	6c40      	ldr	r0, [r0, #68]	; 0x44
   17290:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   17292:	4298      	cmp	r0, r3
   17294:	bf2c      	ite	cs
   17296:	2000      	movcs	r0, #0
   17298:	2001      	movcc	r0, #1
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
   1729a:	bd38      	pop	{r3, r4, r5, pc}
	BaseType_t xReturn = pdFALSE;
   1729c:	2000      	movs	r0, #0
	}
   1729e:	4770      	bx	lr
   172a0:	2000e6a4 	.word	0x2000e6a4
   172a4:	2000e080 	.word	0x2000e080
   172a8:	2000e6c0 	.word	0x2000e6c0

Disassembly of section .text.__lshift%364:

000172ac <__lshift>:
   172ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   172b0:	460c      	mov	r4, r1
   172b2:	ea4f 1a62 	mov.w	sl, r2, asr #5
   172b6:	6923      	ldr	r3, [r4, #16]
   172b8:	6849      	ldr	r1, [r1, #4]
   172ba:	eb0a 0903 	add.w	r9, sl, r3
   172be:	68a3      	ldr	r3, [r4, #8]
   172c0:	4607      	mov	r7, r0
   172c2:	4616      	mov	r6, r2
   172c4:	f109 0501 	add.w	r5, r9, #1
   172c8:	42ab      	cmp	r3, r5
   172ca:	db33      	blt.n	17334 <__lshift+0x88>
   172cc:	4638      	mov	r0, r7
   172ce:	f003 fcc5 	bl	1ac5c <_Balloc>
   172d2:	2300      	movs	r3, #0
   172d4:	4680      	mov	r8, r0
   172d6:	f100 0114 	add.w	r1, r0, #20
   172da:	f100 0210 	add.w	r2, r0, #16
   172de:	4618      	mov	r0, r3
   172e0:	4553      	cmp	r3, sl
   172e2:	db2a      	blt.n	1733a <__lshift+0x8e>
   172e4:	6920      	ldr	r0, [r4, #16]
   172e6:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
   172ea:	f104 0314 	add.w	r3, r4, #20
   172ee:	f016 021f 	ands.w	r2, r6, #31
   172f2:	eb01 018a 	add.w	r1, r1, sl, lsl #2
   172f6:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
   172fa:	d022      	beq.n	17342 <__lshift+0x96>
   172fc:	f1c2 0e20 	rsb	lr, r2, #32
   17300:	2000      	movs	r0, #0
   17302:	681e      	ldr	r6, [r3, #0]
   17304:	4096      	lsls	r6, r2
   17306:	4330      	orrs	r0, r6
   17308:	f841 0b04 	str.w	r0, [r1], #4
   1730c:	f853 0b04 	ldr.w	r0, [r3], #4
   17310:	459c      	cmp	ip, r3
   17312:	fa20 f00e 	lsr.w	r0, r0, lr
   17316:	d8f4      	bhi.n	17302 <__lshift+0x56>
   17318:	6008      	str	r0, [r1, #0]
   1731a:	b108      	cbz	r0, 17320 <__lshift+0x74>
   1731c:	f109 0502 	add.w	r5, r9, #2
   17320:	3d01      	subs	r5, #1
   17322:	4638      	mov	r0, r7
   17324:	f8c8 5010 	str.w	r5, [r8, #16]
   17328:	4621      	mov	r1, r4
   1732a:	f008 f994 	bl	1f656 <_Bfree>
   1732e:	4640      	mov	r0, r8
   17330:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   17334:	3101      	adds	r1, #1
   17336:	005b      	lsls	r3, r3, #1
   17338:	e7c6      	b.n	172c8 <__lshift+0x1c>
   1733a:	f842 0f04 	str.w	r0, [r2, #4]!
   1733e:	3301      	adds	r3, #1
   17340:	e7ce      	b.n	172e0 <__lshift+0x34>
   17342:	3904      	subs	r1, #4
   17344:	f853 2b04 	ldr.w	r2, [r3], #4
   17348:	f841 2f04 	str.w	r2, [r1, #4]!
   1734c:	459c      	cmp	ip, r3
   1734e:	d8f9      	bhi.n	17344 <__lshift+0x98>
   17350:	e7e6      	b.n	17320 <__lshift+0x74>

Disassembly of section .text._DHCPProcessReceiveData%365:

00017354 <_DHCPProcessReceiveData>:
{
   17354:	b5f0      	push	{r4, r5, r6, r7, lr}
   17356:	b083      	sub	sp, #12
   17358:	4605      	mov	r5, r0
   1735a:	460e      	mov	r6, r1
    if(TCPIP_UDP_GetIsReady(dhcpClientSocket) == 0)
   1735c:	4b24      	ldr	r3, [pc, #144]	; (173f0 <_DHCPProcessReceiveData+0x9c>)
   1735e:	f9b3 0000 	ldrsh.w	r0, [r3]
   17362:	f008 fde7 	bl	1ff34 <TCPIP_UDP_GetIsReady>
   17366:	2800      	cmp	r0, #0
   17368:	d03d      	beq.n	173e6 <_DHCPProcessReceiveData+0x92>
    recvRes = _DHCPReceive(pClient, pNetIf);
   1736a:	4631      	mov	r1, r6
   1736c:	4628      	mov	r0, r5
   1736e:	f7f7 ff91 	bl	f294 <_DHCPReceive>
   17372:	4604      	mov	r4, r0
    switch(recvRes)
   17374:	2805      	cmp	r0, #5
   17376:	d00c      	beq.n	17392 <_DHCPProcessReceiveData+0x3e>
   17378:	2806      	cmp	r0, #6
   1737a:	d135      	bne.n	173e8 <_DHCPProcessReceiveData+0x94>
            dhcpEv = DHCP_EVENT_NACK;
   1737c:	2706      	movs	r7, #6
        _DHCPSetRunFail(pClient, TCPIP_DHCP_SEND_DISCOVERY, false);
   1737e:	2200      	movs	r2, #0
   17380:	2102      	movs	r1, #2
   17382:	4628      	mov	r0, r5
   17384:	f005 f9c8 	bl	1c718 <_DHCPSetRunFail>
        _DHCPNotifyClients(pNetIf, dhcpEv);
   17388:	4639      	mov	r1, r7
   1738a:	4630      	mov	r0, r6
   1738c:	f006 fdb2 	bl	1def4 <_DHCPNotifyClients>
   17390:	e02a      	b.n	173e8 <_DHCPProcessReceiveData+0x94>
            if( pClient->smState == TCPIP_DHCP_GET_REQUEST_ACK)
   17392:	f8b5 3056 	ldrh.w	r3, [r5, #86]	; 0x56
   17396:	2b05      	cmp	r3, #5
   17398:	d00a      	beq.n	173b0 <_DHCPProcessReceiveData+0x5c>
            else if( pClient->smState == TCPIP_DHCP_GET_RENEW_ACK || pClient->smState == TCPIP_DHCP_GET_REBIND_ACK)
   1739a:	2b0a      	cmp	r3, #10
   1739c:	d001      	beq.n	173a2 <_DHCPProcessReceiveData+0x4e>
   1739e:	2b0c      	cmp	r3, #12
   173a0:	d122      	bne.n	173e8 <_DHCPProcessReceiveData+0x94>
                pClient->tRequest = pClient->tRenewRequest;
   173a2:	68eb      	ldr	r3, [r5, #12]
   173a4:	60ab      	str	r3, [r5, #8]
                _DHCPSetBoundState(pClient);
   173a6:	4628      	mov	r0, r5
   173a8:	f006 fa54 	bl	1d854 <_DHCPSetBoundState>
                dhcpEv = DHCP_EVENT_BOUND;
   173ac:	2708      	movs	r7, #8
   173ae:	e7eb      	b.n	17388 <_DHCPProcessReceiveData+0x34>
                if(pClient->validValues.IPAddress == 0 || pClient->validValues.Mask == 0)
   173b0:	f895 3059 	ldrb.w	r3, [r5, #89]	; 0x59
   173b4:	f003 0305 	and.w	r3, r3, #5
   173b8:	2b05      	cmp	r3, #5
   173ba:	d001      	beq.n	173c0 <_DHCPProcessReceiveData+0x6c>
                    dhcpEv = DHCP_EVENT_ACK_INVALID;
   173bc:	2704      	movs	r7, #4
   173be:	e7de      	b.n	1737e <_DHCPProcessReceiveData+0x2a>
                IPV4_ADDR zeroAdd = { 0 };
   173c0:	2300      	movs	r3, #0
   173c2:	9301      	str	r3, [sp, #4]
                arpCheck.Val = pClient->dhcpIPAddress.Val;
   173c4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   173c6:	9300      	str	r3, [sp, #0]
                TCPIP_ARP_Probe(pNetIf, &arpCheck, &zeroAdd, ARP_OPERATION_REQ | ARP_OPERATION_CONFIGURE |  ARP_OPERATION_GRATUITOUS);
   173c8:	f243 0301 	movw	r3, #12289	; 0x3001
   173cc:	aa01      	add	r2, sp, #4
   173ce:	4669      	mov	r1, sp
   173d0:	4630      	mov	r0, r6
   173d2:	f004 f93f 	bl	1b654 <TCPIP_ARP_Probe>
    return dhcpSecondCount;
   173d6:	4b07      	ldr	r3, [pc, #28]	; (173f4 <_DHCPProcessReceiveData+0xa0>)
                pClient->startWait = _DHCPSecondCountGet();
   173d8:	681b      	ldr	r3, [r3, #0]
   173da:	606b      	str	r3, [r5, #4]
    pClient->smState = newState;
   173dc:	2306      	movs	r3, #6
   173de:	f8a5 3056 	strh.w	r3, [r5, #86]	; 0x56
                dhcpEv = DHCP_EVENT_ACK;
   173e2:	2703      	movs	r7, #3
   173e4:	e7d0      	b.n	17388 <_DHCPProcessReceiveData+0x34>
        return TCPIP_DHCP_TIMEOUT_MESSAGE;
   173e6:	240a      	movs	r4, #10
}
   173e8:	4620      	mov	r0, r4
   173ea:	b003      	add	sp, #12
   173ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
   173ee:	bf00      	nop
   173f0:	2000e720 	.word	0x2000e720
   173f4:	2000e620 	.word	0x2000e620

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0%366:

000173f8 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0>:
{
   173f8:	b510      	push	{r4, lr}
   173fa:	4604      	mov	r4, r0
    openFlags = hClientObj->hDriver->openFlags;
   173fc:	68c1      	ldr	r1, [r0, #12]
   173fe:	898b      	ldrh	r3, [r1, #12]
    if(!(openFlags & (TCPIP_ETH_OPEN_FDUPLEX|TCPIP_ETH_OPEN_HDUPLEX)))
   17400:	f013 0f06 	tst.w	r3, #6
        openFlags |= TCPIP_ETH_OPEN_HDUPLEX;
   17404:	bf08      	it	eq
   17406:	f043 0304 	orreq.w	r3, r3, #4
    if(!(openFlags & (TCPIP_ETH_OPEN_100|TCPIP_ETH_OPEN_10)))
   1740a:	f013 0f18 	tst.w	r3, #24
        openFlags |= TCPIP_ETH_OPEN_10;
   1740e:	bf08      	it	eq
   17410:	f043 0310 	orreq.w	r3, r3, #16
    if(openFlags & TCPIP_ETH_OPEN_AUTO)
   17414:	f013 0f01 	tst.w	r3, #1
   17418:	d01e      	beq.n	17458 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x60>
        if(openFlags & TCPIP_ETH_OPEN_100)
   1741a:	f013 0f08 	tst.w	r3, #8
   1741e:	d00c      	beq.n	1743a <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x42>
            if(openFlags & TCPIP_ETH_OPEN_FDUPLEX)
   17420:	f003 0202 	and.w	r2, r3, #2
                openReqs |= _BMSTAT_BASE100TX_FDX_MASK;
   17424:	2a00      	cmp	r2, #0
   17426:	f244 0208 	movw	r2, #16392	; 0x4008
   1742a:	bf08      	it	eq
   1742c:	2208      	moveq	r2, #8
            if(openFlags & TCPIP_ETH_OPEN_HDUPLEX)
   1742e:	f013 0f04 	tst.w	r3, #4
   17432:	d003      	beq.n	1743c <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x44>
                openReqs |= _BMSTAT_BASE100TX_HDX_MASK;
   17434:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
   17438:	e000      	b.n	1743c <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x44>
        openReqs = _BMSTAT_AN_ABLE_MASK;
   1743a:	2208      	movs	r2, #8
        if(openFlags & TCPIP_ETH_OPEN_10)
   1743c:	f013 0f10 	tst.w	r3, #16
   17440:	d015      	beq.n	1746e <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x76>
            if(openFlags & TCPIP_ETH_OPEN_FDUPLEX)
   17442:	f013 0f02 	tst.w	r3, #2
                openReqs |= _BMSTAT_BASE10T_FDX_MASK;
   17446:	bf18      	it	ne
   17448:	f442 5280 	orrne.w	r2, r2, #4096	; 0x1000
            if(openFlags & TCPIP_ETH_OPEN_HDUPLEX)
   1744c:	f013 0f04 	tst.w	r3, #4
   17450:	d00d      	beq.n	1746e <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x76>
                openReqs |= _BMSTAT_BASE10T_HDX_MASK;
   17452:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
   17456:	e00a      	b.n	1746e <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x76>
        if(openFlags & TCPIP_ETH_OPEN_100)
   17458:	f013 0f08 	tst.w	r3, #8
   1745c:	d00f      	beq.n	1747e <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x86>
            openReqs = (openFlags & TCPIP_ETH_OPEN_FDUPLEX) ? _BMSTAT_BASE100TX_FDX_MASK : _BMSTAT_BASE100TX_HDX_MASK;
   1745e:	f003 0202 	and.w	r2, r3, #2
   17462:	2a00      	cmp	r2, #0
   17464:	bf14      	ite	ne
   17466:	f44f 4280 	movne.w	r2, #16384	; 0x4000
   1746a:	f44f 5200 	moveq.w	r2, #8192	; 0x2000
    hClientObj->hDriver->openFlags = openFlags;
   1746e:	818b      	strh	r3, [r1, #12]
    hClientObj->operReg[0] = openReqs;
   17470:	8462      	strh	r2, [r4, #34]	; 0x22
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   17472:	2101      	movs	r1, #1
   17474:	4620      	mov	r0, r4
   17476:	f007 fc5f 	bl	1ed38 <_DRV_PHY_SMIReadStart>
   1747a:	b948      	cbnz	r0, 17490 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x98>
}
   1747c:	bd10      	pop	{r4, pc}
            openReqs = (openFlags & TCPIP_ETH_OPEN_FDUPLEX) ? _BMSTAT_BASE10T_FDX_MASK : _BMSTAT_BASE10T_HDX_MASK;
   1747e:	f003 0202 	and.w	r2, r3, #2
   17482:	2a00      	cmp	r2, #0
   17484:	bf14      	ite	ne
   17486:	f44f 5280 	movne.w	r2, #4096	; 0x1000
   1748a:	f44f 6200 	moveq.w	r2, #2048	; 0x800
   1748e:	e7ee      	b.n	1746e <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x76>
    hClientObj->operPhase = operPhase;
   17490:	2303      	movs	r3, #3
   17492:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   17494:	2301      	movs	r3, #1
   17496:	8423      	strh	r3, [r4, #32]
}
   17498:	e7f0      	b.n	1747c <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase0+0x84>

Disassembly of section .text.TCPIP_Helper_IPv6AddressToString%367:

0001749a <TCPIP_Helper_IPv6AddressToString>:
    if(v6Addr && buff && buffSize >= 41)
   1749a:	b3d8      	cbz	r0, 17514 <TCPIP_Helper_IPv6AddressToString+0x7a>
{
   1749c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   174a0:	460e      	mov	r6, r1
   174a2:	4607      	mov	r7, r0
    if(v6Addr && buff && buffSize >= 41)
   174a4:	b3c1      	cbz	r1, 17518 <TCPIP_Helper_IPv6AddressToString+0x7e>
   174a6:	2a28      	cmp	r2, #40	; 0x28
   174a8:	d802      	bhi.n	174b0 <TCPIP_Helper_IPv6AddressToString+0x16>
    return false;
   174aa:	2000      	movs	r0, #0
}
   174ac:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   174b0:	1c45      	adds	r5, r0, #1
   174b2:	4682      	mov	sl, r0
   174b4:	f100 0b11 	add.w	fp, r0, #17
   174b8:	f100 090f 	add.w	r9, r0, #15
   174bc:	e017      	b.n	174ee <TCPIP_Helper_IPv6AddressToString+0x54>
                *str++ = k;
   174be:	f806 0b01 	strb.w	r0, [r6], #1
            k = btohexa_high(v6Addr->v[1 + (i<<1)]);
   174c2:	eba5 080a 	sub.w	r8, r5, sl
   174c6:	7820      	ldrb	r0, [r4, #0]
   174c8:	f00a fcec 	bl	21ea4 <btohexa_high>
                *str++ = k;
   174cc:	4634      	mov	r4, r6
   174ce:	f804 0b01 	strb.w	r0, [r4], #1
            k = btohexa_low(v6Addr->v[1 + (i<<1)]);
   174d2:	f817 0008 	ldrb.w	r0, [r7, r8]
   174d6:	f00a fb88 	bl	21bea <btohexa_low>
            *str++ = k;
   174da:	7020      	strb	r0, [r4, #0]
            if (i != 7)
   174dc:	454d      	cmp	r5, r9
   174de:	d014      	beq.n	1750a <TCPIP_Helper_IPv6AddressToString+0x70>
                *str++ = ':';
   174e0:	1ca6      	adds	r6, r4, #2
   174e2:	f04f 033a 	mov.w	r3, #58	; 0x3a
   174e6:	7063      	strb	r3, [r4, #1]
   174e8:	3502      	adds	r5, #2
        for (i = 0; i < 8; i++)
   174ea:	455d      	cmp	r5, fp
   174ec:	d00e      	beq.n	1750c <TCPIP_Helper_IPv6AddressToString+0x72>
            k = btohexa_high(v6Addr->v[(i<<1)]);
   174ee:	462c      	mov	r4, r5
   174f0:	f815 0c01 	ldrb.w	r0, [r5, #-1]
   174f4:	f00a fcd6 	bl	21ea4 <btohexa_high>
            if (k != '0')
   174f8:	2830      	cmp	r0, #48	; 0x30
   174fa:	d00f      	beq.n	1751c <TCPIP_Helper_IPv6AddressToString+0x82>
                *str++ = k;
   174fc:	f806 0b01 	strb.w	r0, [r6], #1
            k = btohexa_low(v6Addr->v[(i<<1)]);
   17500:	f815 0c01 	ldrb.w	r0, [r5, #-1]
   17504:	f00a fb71 	bl	21bea <btohexa_low>
            if (k != '0' || j == true)
   17508:	e7d9      	b.n	174be <TCPIP_Helper_IPv6AddressToString+0x24>
            *str++ = k;
   1750a:	1c66      	adds	r6, r4, #1
        *str = 0;
   1750c:	2300      	movs	r3, #0
   1750e:	7033      	strb	r3, [r6, #0]
        return true;
   17510:	2001      	movs	r0, #1
   17512:	e7cb      	b.n	174ac <TCPIP_Helper_IPv6AddressToString+0x12>
    return false;
   17514:	2000      	movs	r0, #0
}
   17516:	4770      	bx	lr
    return false;
   17518:	2000      	movs	r0, #0
   1751a:	e7c7      	b.n	174ac <TCPIP_Helper_IPv6AddressToString+0x12>
            k = btohexa_low(v6Addr->v[(i<<1)]);
   1751c:	f815 0c01 	ldrb.w	r0, [r5, #-1]
   17520:	f00a fb63 	bl	21bea <btohexa_low>
            if (k != '0' || j == true)
   17524:	2830      	cmp	r0, #48	; 0x30
   17526:	d1ca      	bne.n	174be <TCPIP_Helper_IPv6AddressToString+0x24>
            k = btohexa_high(v6Addr->v[1 + (i<<1)]);
   17528:	eba5 080a 	sub.w	r8, r5, sl
   1752c:	7820      	ldrb	r0, [r4, #0]
   1752e:	f00a fcb9 	bl	21ea4 <btohexa_high>
            if (k != '0' || j == true)
   17532:	2830      	cmp	r0, #48	; 0x30
   17534:	bf08      	it	eq
   17536:	4634      	moveq	r4, r6
   17538:	d0cb      	beq.n	174d2 <TCPIP_Helper_IPv6AddressToString+0x38>
   1753a:	e7c7      	b.n	174cc <TCPIP_Helper_IPv6AddressToString+0x32>

Disassembly of section .text.wc_RNG_HealthTest_ex%368:

0001753c <wc_RNG_HealthTest_ex>:
{
   1753c:	b570      	push	{r4, r5, r6, lr}
   1753e:	b0a6      	sub	sp, #152	; 0x98
   17540:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
    if (seedA == NULL || output == NULL) {
   17542:	2b00      	cmp	r3, #0
   17544:	d03f      	beq.n	175c6 <wc_RNG_HealthTest_ex+0x8a>
   17546:	461e      	mov	r6, r3
   17548:	2d00      	cmp	r5, #0
   1754a:	d03f      	beq.n	175cc <wc_RNG_HealthTest_ex+0x90>
    if (reseed != 0 && seedB == NULL) {
   1754c:	b110      	cbz	r0, 17554 <wc_RNG_HealthTest_ex+0x18>
   1754e:	9b2b      	ldr	r3, [sp, #172]	; 0xac
   17550:	2b00      	cmp	r3, #0
   17552:	d03e      	beq.n	175d2 <wc_RNG_HealthTest_ex+0x96>
    if (outputSz != RNG_HEALTH_TEST_CHECK_SIZE) {
   17554:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
   17556:	2b80      	cmp	r3, #128	; 0x80
   17558:	d13e      	bne.n	175d8 <wc_RNG_HealthTest_ex+0x9c>
   1755a:	460b      	mov	r3, r1
   1755c:	4604      	mov	r4, r0
    if (Hash_DRBG_Instantiate(drbg, seedA, seedASz, nonce, nonceSz,
   1755e:	9930      	ldr	r1, [sp, #192]	; 0xc0
   17560:	9102      	str	r1, [sp, #8]
   17562:	992f      	ldr	r1, [sp, #188]	; 0xbc
   17564:	9101      	str	r1, [sp, #4]
   17566:	9200      	str	r2, [sp, #0]
   17568:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
   1756a:	4631      	mov	r1, r6
   1756c:	a805      	add	r0, sp, #20
   1756e:	f002 fdc4 	bl	1a0fa <Hash_DRBG_Instantiate>
   17572:	b9c8      	cbnz	r0, 175a8 <wc_RNG_HealthTest_ex+0x6c>
    if (reseed) {
   17574:	b12c      	cbz	r4, 17582 <wc_RNG_HealthTest_ex+0x46>
        if (Hash_DRBG_Reseed(drbg, seedB, seedBSz) != 0) {
   17576:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
   17578:	992b      	ldr	r1, [sp, #172]	; 0xac
   1757a:	a805      	add	r0, sp, #20
   1757c:	f7ff fc48 	bl	16e10 <Hash_DRBG_Reseed>
   17580:	b9f0      	cbnz	r0, 175c0 <wc_RNG_HealthTest_ex+0x84>
    if (Hash_DRBG_Generate(drbg, output, outputSz) != 0) {
   17582:	2280      	movs	r2, #128	; 0x80
   17584:	4629      	mov	r1, r5
   17586:	a805      	add	r0, sp, #20
   17588:	f7f4 fb2a 	bl	bbe0 <Hash_DRBG_Generate>
   1758c:	b110      	cbz	r0, 17594 <wc_RNG_HealthTest_ex+0x58>
    int ret = -1;
   1758e:	f04f 34ff 	mov.w	r4, #4294967295
   17592:	e00b      	b.n	175ac <wc_RNG_HealthTest_ex+0x70>
    if (Hash_DRBG_Generate(drbg, output, outputSz) != 0) {
   17594:	2280      	movs	r2, #128	; 0x80
   17596:	4629      	mov	r1, r5
   17598:	a805      	add	r0, sp, #20
   1759a:	f7f4 fb21 	bl	bbe0 <Hash_DRBG_Generate>
   1759e:	3000      	adds	r0, #0
   175a0:	bf18      	it	ne
   175a2:	2001      	movne	r0, #1
   175a4:	4244      	negs	r4, r0
   175a6:	e001      	b.n	175ac <wc_RNG_HealthTest_ex+0x70>
    int ret = -1;
   175a8:	f04f 34ff 	mov.w	r4, #4294967295
    if (Hash_DRBG_Uninstantiate(drbg) != 0) {
   175ac:	a805      	add	r0, sp, #20
   175ae:	f007 fb75 	bl	1ec9c <Hash_DRBG_Uninstantiate>
   175b2:	2800      	cmp	r0, #0
        ret = -1;
   175b4:	bf18      	it	ne
   175b6:	f04f 34ff 	movne.w	r4, #4294967295
}
   175ba:	4620      	mov	r0, r4
   175bc:	b026      	add	sp, #152	; 0x98
   175be:	bd70      	pop	{r4, r5, r6, pc}
    int ret = -1;
   175c0:	f04f 34ff 	mov.w	r4, #4294967295
   175c4:	e7f2      	b.n	175ac <wc_RNG_HealthTest_ex+0x70>
        return BAD_FUNC_ARG;
   175c6:	f06f 04ac 	mvn.w	r4, #172	; 0xac
   175ca:	e7f6      	b.n	175ba <wc_RNG_HealthTest_ex+0x7e>
   175cc:	f06f 04ac 	mvn.w	r4, #172	; 0xac
   175d0:	e7f3      	b.n	175ba <wc_RNG_HealthTest_ex+0x7e>
        return BAD_FUNC_ARG;
   175d2:	f06f 04ac 	mvn.w	r4, #172	; 0xac
   175d6:	e7f0      	b.n	175ba <wc_RNG_HealthTest_ex+0x7e>
        return ret;
   175d8:	f04f 34ff 	mov.w	r4, #4294967295
   175dc:	e7ed      	b.n	175ba <wc_RNG_HealthTest_ex+0x7e>

Disassembly of section .text._ARPDeleteResources%369:

000175e0 <_ARPDeleteResources>:
{
   175e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(arpMod.arpCacheDcpt)
   175e2:	4b26      	ldr	r3, [pc, #152]	; (1767c <_ARPDeleteResources+0x9c>)
   175e4:	685c      	ldr	r4, [r3, #4]
   175e6:	b364      	cbz	r4, 17642 <_ARPDeleteResources+0x62>
        for(ix = 0, pArpDcpt = arpMod.arpCacheDcpt; ix < arpMod.nIfs; ix++, pArpDcpt++)
   175e8:	681b      	ldr	r3, [r3, #0]
   175ea:	2b00      	cmp	r3, #0
   175ec:	dd22      	ble.n	17634 <_ARPDeleteResources+0x54>
   175ee:	342c      	adds	r4, #44	; 0x2c
   175f0:	2500      	movs	r5, #0
        TCPIP_HEAP_Free(arpMod.memH, pArpDcpt->hashDcpt);
   175f2:	4e22      	ldr	r6, [pc, #136]	; (1767c <_ARPDeleteResources+0x9c>)
        pArpDcpt->hashDcpt = 0;
   175f4:	462f      	mov	r7, r5
   175f6:	e018      	b.n	1762a <_ARPDeleteResources+0x4a>
        TCPIP_OAHASH_EntriesRemoveAll(pArpDcpt->hashDcpt);
   175f8:	f007 fd24 	bl	1f044 <TCPIP_OAHASH_EntriesRemoveAll>
        TCPIP_Helper_ProtectedSingleListDeinitialize(&pArpDcpt->incompleteList);
   175fc:	4620      	mov	r0, r4
   175fe:	f007 fd51 	bl	1f0a4 <TCPIP_Helper_ProtectedSingleListDeinitialize>
        TCPIP_Helper_ProtectedSingleListDeinitialize(&pArpDcpt->completeList);
   17602:	f1a4 0014 	sub.w	r0, r4, #20
   17606:	f007 fd4d 	bl	1f0a4 <TCPIP_Helper_ProtectedSingleListDeinitialize>
        TCPIP_Helper_ProtectedSingleListDeinitialize(&pArpDcpt->permList);
   1760a:	f1a4 0028 	sub.w	r0, r4, #40	; 0x28
   1760e:	f007 fd49 	bl	1f0a4 <TCPIP_Helper_ProtectedSingleListDeinitialize>
        TCPIP_HEAP_Free(arpMod.memH, pArpDcpt->hashDcpt);
   17612:	68b0      	ldr	r0, [r6, #8]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   17614:	68c3      	ldr	r3, [r0, #12]
   17616:	f854 1c2c 	ldr.w	r1, [r4, #-44]
   1761a:	4798      	blx	r3
        pArpDcpt->hashDcpt = 0;
   1761c:	f844 7c2c 	str.w	r7, [r4, #-44]
        for(ix = 0, pArpDcpt = arpMod.arpCacheDcpt; ix < arpMod.nIfs; ix++, pArpDcpt++)
   17620:	3501      	adds	r5, #1
   17622:	3448      	adds	r4, #72	; 0x48
   17624:	6833      	ldr	r3, [r6, #0]
   17626:	42ab      	cmp	r3, r5
   17628:	dd04      	ble.n	17634 <_ARPDeleteResources+0x54>
    if(pArpDcpt->hashDcpt)
   1762a:	f854 0c2c 	ldr.w	r0, [r4, #-44]
   1762e:	2800      	cmp	r0, #0
   17630:	d1e2      	bne.n	175f8 <_ARPDeleteResources+0x18>
   17632:	e7f5      	b.n	17620 <_ARPDeleteResources+0x40>
        TCPIP_HEAP_Free(arpMod.memH, arpMod.arpCacheDcpt);
   17634:	4c11      	ldr	r4, [pc, #68]	; (1767c <_ARPDeleteResources+0x9c>)
   17636:	68a0      	ldr	r0, [r4, #8]
   17638:	68c3      	ldr	r3, [r0, #12]
   1763a:	6861      	ldr	r1, [r4, #4]
   1763c:	4798      	blx	r3
        arpMod.arpCacheDcpt = 0;
   1763e:	2300      	movs	r3, #0
   17640:	6063      	str	r3, [r4, #4]
    TCPIP_Notification_Deinitialize(&arpMod.registeredUsers, arpMod.memH);
   17642:	4c0e      	ldr	r4, [pc, #56]	; (1767c <_ARPDeleteResources+0x9c>)
   17644:	68a1      	ldr	r1, [r4, #8]
   17646:	f104 0020 	add.w	r0, r4, #32
   1764a:	f00a fa17 	bl	21a7c <TCPIP_Notification_Deinitialize>
    arpMod.memH = 0;
   1764e:	2300      	movs	r3, #0
   17650:	60a3      	str	r3, [r4, #8]
    if(arpMod.timerHandle)
   17652:	69e0      	ldr	r0, [r4, #28]
   17654:	b118      	cbz	r0, 1765e <_ARPDeleteResources+0x7e>
        _TCPIPStackSignalHandlerDeregister(arpMod.timerHandle);
   17656:	f00a fae4 	bl	21c22 <_TCPIPStackSignalHandlerDeregister>
        arpMod.timerHandle = 0;
   1765a:	2200      	movs	r2, #0
   1765c:	61e2      	str	r2, [r4, #28]
    if(arpMod.pMacPkt)
   1765e:	4b07      	ldr	r3, [pc, #28]	; (1767c <_ARPDeleteResources+0x9c>)
   17660:	6c98      	ldr	r0, [r3, #72]	; 0x48
   17662:	b130      	cbz	r0, 17672 <_ARPDeleteResources+0x92>
        if((arpMod.pMacPkt->pktFlags & TCPIP_MAC_PKT_FLAG_QUEUED) == 0 )
   17664:	8c43      	ldrh	r3, [r0, #34]	; 0x22
   17666:	f013 0f08 	tst.w	r3, #8
   1766a:	d003      	beq.n	17674 <_ARPDeleteResources+0x94>
        arpMod.pMacPkt = 0;
   1766c:	4b03      	ldr	r3, [pc, #12]	; (1767c <_ARPDeleteResources+0x9c>)
   1766e:	2200      	movs	r2, #0
   17670:	649a      	str	r2, [r3, #72]	; 0x48
}
   17672:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            TCPIP_PKT_PacketFree(arpMod.pMacPkt);
   17674:	f006 fc98 	bl	1dfa8 <_TCPIP_PKT_PacketFree>
   17678:	e7f8      	b.n	1766c <_ARPDeleteResources+0x8c>
   1767a:	bf00      	nop
   1767c:	2000e1a4 	.word	0x2000e1a4

Disassembly of section .text._UDPv4AllocateSktTxBuffer%370:

00017680 <_UDPv4AllocateSktTxBuffer>:
    if(addType != IP_ADDRESS_TYPE_IPV4)
   17680:	2901      	cmp	r1, #1
   17682:	d145      	bne.n	17710 <_UDPv4AllocateSktTxBuffer+0x90>
    if(pSkt->txAllocCnt >= pSkt->txAllocLimit)
   17684:	f890 103f 	ldrb.w	r1, [r0, #63]	; 0x3f
   17688:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
   1768c:	4299      	cmp	r1, r3
   1768e:	d242      	bcs.n	17716 <_UDPv4AllocateSktTxBuffer+0x96>
{
   17690:	b570      	push	{r4, r5, r6, lr}
    if(pSkt->flags.stackConfig != 0)
   17692:	f890 1041 	ldrb.w	r1, [r0, #65]	; 0x41
   17696:	f001 0308 	and.w	r3, r1, #8
        allocFlags |= TCPIP_MAC_PKT_FLAG_CONFIG;
   1769a:	2b00      	cmp	r3, #0
   1769c:	bf0c      	ite	eq
   1769e:	2300      	moveq	r3, #0
   176a0:	f44f 4300 	movne.w	r3, #32768	; 0x8000
    if(pSkt->flags.txSplitAlloc == 0)
   176a4:	f011 0f02 	tst.w	r1, #2
        allocFlags |= TCPIP_MAC_PKT_FLAG_SPLIT;
   176a8:	bf1a      	itte	ne
   176aa:	f043 0304 	orrne.w	r3, r3, #4
        pktSize = sizeof(UDP_V4_PACKET) + sizeof(*((UDP_V4_PACKET*)0)->zcSeg);
   176ae:	265c      	movne	r6, #92	; 0x5c
        pktSize = sizeof(UDP_V4_PACKET);
   176b0:	2644      	moveq	r6, #68	; 0x44
   176b2:	4615      	mov	r5, r2
   176b4:	4604      	mov	r4, r0
    return TCPIP_PKT_SocketAlloc(pktSize, sizeof(UDP_HEADER), txBuffSize, allocFlags);
   176b6:	f043 0302 	orr.w	r3, r3, #2
   176ba:	8a02      	ldrh	r2, [r0, #16]
   176bc:	2108      	movs	r1, #8
   176be:	4630      	mov	r0, r6
   176c0:	f008 f890 	bl	1f7e4 <_TCPIP_PKT_SocketAlloc>
    if(pPkt)
   176c4:	4603      	mov	r3, r0
   176c6:	b1a8      	cbz	r0, 176f4 <_UDPv4AllocateSktTxBuffer+0x74>
    pPkt->ackFunc = ackFunc;
   176c8:	4a14      	ldr	r2, [pc, #80]	; (1771c <_UDPv4AllocateSktTxBuffer+0x9c>)
   176ca:	6082      	str	r2, [r0, #8]
    pPkt->ackParam = ackParam;
   176cc:	60c4      	str	r4, [r0, #12]
        if(pSkt->flags.txSplitAlloc)
   176ce:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
   176d2:	f012 0f02 	tst.w	r2, #2
   176d6:	d00f      	beq.n	176f8 <_UDPv4AllocateSktTxBuffer+0x78>
            pPkt->pDSeg->next = pZSeg;
   176d8:	6902      	ldr	r2, [r0, #16]
            TCPIP_MAC_DATA_SEGMENT* pZSeg = ((UDP_V4_PACKET*)pPkt)->zcSeg;
   176da:	f100 0144 	add.w	r1, r0, #68	; 0x44
            pPkt->pDSeg->next = pZSeg;
   176de:	6011      	str	r1, [r2, #0]
            pZSeg->segFlags = TCPIP_MAC_SEG_FLAG_STATIC;   // embedded in packet itself
   176e0:	2201      	movs	r2, #1
   176e2:	f8a0 2054 	strh.w	r2, [r0, #84]	; 0x54
            pTxBuff = 0;    // will be set as external payload
   176e6:	2200      	movs	r2, #0
        if(update)
   176e8:	b94d      	cbnz	r5, 176fe <_UDPv4AllocateSktTxBuffer+0x7e>
        pSkt->txAllocCnt++;
   176ea:	f894 203f 	ldrb.w	r2, [r4, #63]	; 0x3f
   176ee:	3201      	adds	r2, #1
   176f0:	f884 203f 	strb.w	r2, [r4, #63]	; 0x3f
}
   176f4:	4618      	mov	r0, r3
   176f6:	bd70      	pop	{r4, r5, r6, pc}
            pTxBuff = pPkt->pTransportLayer + sizeof(UDP_HEADER);
   176f8:	69c2      	ldr	r2, [r0, #28]
   176fa:	3208      	adds	r2, #8
   176fc:	e7f4      	b.n	176e8 <_UDPv4AllocateSktTxBuffer+0x68>
    pSkt->txStart = txBuff;
   176fe:	6022      	str	r2, [r4, #0]
    pSkt->txEnd = txBuff + pSkt->txSize;
   17700:	8a21      	ldrh	r1, [r4, #16]
   17702:	4411      	add	r1, r2
   17704:	6061      	str	r1, [r4, #4]
    pSkt->txWrite = txBuff;
   17706:	60a2      	str	r2, [r4, #8]
    pSkt->addType =  addType;
   17708:	2201      	movs	r2, #1
   1770a:	87a2      	strh	r2, [r4, #60]	; 0x3c
    pSkt->pPkt = pTxPkt;
   1770c:	60e3      	str	r3, [r4, #12]
   1770e:	e7ec      	b.n	176ea <_UDPv4AllocateSktTxBuffer+0x6a>
        return 0;
   17710:	2300      	movs	r3, #0
}
   17712:	4618      	mov	r0, r3
   17714:	4770      	bx	lr
        return 0;
   17716:	2300      	movs	r3, #0
   17718:	e7fb      	b.n	17712 <_UDPv4AllocateSktTxBuffer+0x92>
   1771a:	bf00      	nop
   1771c:	000131c9 	.word	0x000131c9

Disassembly of section .text.TCPIP_UDP_Disconnect%371:

00017720 <TCPIP_UDP_Disconnect>:
{
   17720:	b538      	push	{r3, r4, r5, lr}
   17722:	460d      	mov	r5, r1
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   17724:	f008 fbde 	bl	1fee4 <_UDPSocketDcpt>
    if(pSkt)
   17728:	2800      	cmp	r0, #0
   1772a:	d044      	beq.n	177b6 <TCPIP_UDP_Disconnect+0x96>
   1772c:	4604      	mov	r4, r0
        if(pSkt->flags.openAddType == IP_ADDRESS_TYPE_ANY)
   1772e:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
   17732:	f013 0f30 	tst.w	r3, #48	; 0x30
   17736:	d036      	beq.n	177a6 <TCPIP_UDP_Disconnect+0x86>
    pSkt->extFlags.rxEnable = 0;
   17738:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   1773c:	f36f 0341 	bfc	r3, #1, #1
   17740:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        pSkt->addType = (IP_ADDRESS_TYPE)pSkt->flags.openAddType;
   17744:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
   17748:	f3c3 1201 	ubfx	r2, r3, #4, #2
   1774c:	87a2      	strh	r2, [r4, #60]	; 0x3c
        if(pSkt->flags.openBindIf == 0)
   1774e:	f013 0f40 	tst.w	r3, #64	; 0x40
            pSkt->pSktNet = 0;
   17752:	bf04      	itt	eq
   17754:	2200      	moveq	r2, #0
   17756:	6262      	streq	r2, [r4, #36]	; 0x24
        if(pSkt->flags.openBindAdd == 0)
   17758:	f013 0f80 	tst.w	r3, #128	; 0x80
   1775c:	d109      	bne.n	17772 <TCPIP_UDP_Disconnect+0x52>
            pSkt->srcAddress.Val = 0;
   1775e:	2200      	movs	r2, #0
   17760:	61a2      	str	r2, [r4, #24]
            pSkt->flags.srcValid = pSkt->flags.srcSolved = 0;
   17762:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
   17766:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   1776a:	f362 1386 	bfi	r3, r2, #6, #1
   1776e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        if(pSkt->extFlags.serverSkt != 0 && pSkt->flags.looseRemPort != 0)
   17772:	6c22      	ldr	r2, [r4, #64]	; 0x40
   17774:	4b11      	ldr	r3, [pc, #68]	; (177bc <TCPIP_UDP_Disconnect+0x9c>)
   17776:	4393      	bics	r3, r2
            pSkt->remotePort = 0;
   17778:	bf04      	itt	eq
   1777a:	2300      	moveq	r3, #0
   1777c:	8523      	strheq	r3, [r4, #40]	; 0x28
        if(flushRxQueue)
   1777e:	b1ad      	cbz	r5, 177ac <TCPIP_UDP_Disconnect+0x8c>
            _UDPFreeRxQueue(pSkt);
   17780:	4620      	mov	r0, r4
   17782:	f008 fe39 	bl	203f8 <_UDPFreeRxQueue>
    TCPIP_MAC_PACKET* pNextPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(&pSkt->rxQueue);
   17786:	f104 0044 	add.w	r0, r4, #68	; 0x44
   1778a:	f009 fb35 	bl	20df8 <TCPIP_Helper_SingleListHeadRemove>
    _UDPSetNewRxPacket(pSkt, pNextPkt);
   1778e:	4601      	mov	r1, r0
   17790:	4620      	mov	r0, r4
   17792:	f005 ff3d 	bl	1d610 <_UDPSetNewRxPacket>
    pSkt->extFlags.rxEnable = 1;
   17796:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   1779a:	f043 0302 	orr.w	r3, r3, #2
   1779e:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        return true;
   177a2:	2001      	movs	r0, #1
}
   177a4:	bd38      	pop	{r3, r4, r5, pc}
            _UDPFreeTxResources(pSkt);
   177a6:	f008 f833 	bl	1f810 <_UDPFreeTxResources>
   177aa:	e7c5      	b.n	17738 <TCPIP_UDP_Disconnect+0x18>
            _UDPsetPacketInfo(pSkt, pSkt->pCurrRxPkt);
   177ac:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   177ae:	4620      	mov	r0, r4
   177b0:	f000 ffa8 	bl	18704 <_UDPsetPacketInfo>
   177b4:	e7ef      	b.n	17796 <TCPIP_UDP_Disconnect+0x76>
    return false;
   177b6:	2000      	movs	r0, #0
   177b8:	e7f4      	b.n	177a4 <TCPIP_UDP_Disconnect+0x84>
   177ba:	bf00      	nop
   177bc:	00800004 	.word	0x00800004

Disassembly of section .text%372:

000177c0 <memchr>:
   177c0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   177c4:	2a10      	cmp	r2, #16
   177c6:	db2b      	blt.n	17820 <memchr+0x60>
   177c8:	f010 0f07 	tst.w	r0, #7
   177cc:	d008      	beq.n	177e0 <memchr+0x20>
   177ce:	f810 3b01 	ldrb.w	r3, [r0], #1
   177d2:	3a01      	subs	r2, #1
   177d4:	428b      	cmp	r3, r1
   177d6:	d02d      	beq.n	17834 <memchr+0x74>
   177d8:	f010 0f07 	tst.w	r0, #7
   177dc:	b342      	cbz	r2, 17830 <memchr+0x70>
   177de:	d1f6      	bne.n	177ce <memchr+0xe>
   177e0:	b4f0      	push	{r4, r5, r6, r7}
   177e2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
   177e6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
   177ea:	f022 0407 	bic.w	r4, r2, #7
   177ee:	f07f 0700 	mvns.w	r7, #0
   177f2:	2300      	movs	r3, #0
   177f4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
   177f8:	3c08      	subs	r4, #8
   177fa:	ea85 0501 	eor.w	r5, r5, r1
   177fe:	ea86 0601 	eor.w	r6, r6, r1
   17802:	fa85 f547 	uadd8	r5, r5, r7
   17806:	faa3 f587 	sel	r5, r3, r7
   1780a:	fa86 f647 	uadd8	r6, r6, r7
   1780e:	faa5 f687 	sel	r6, r5, r7
   17812:	b98e      	cbnz	r6, 17838 <memchr+0x78>
   17814:	d1ee      	bne.n	177f4 <memchr+0x34>
   17816:	bcf0      	pop	{r4, r5, r6, r7}
   17818:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   1781c:	f002 0207 	and.w	r2, r2, #7
   17820:	b132      	cbz	r2, 17830 <memchr+0x70>
   17822:	f810 3b01 	ldrb.w	r3, [r0], #1
   17826:	3a01      	subs	r2, #1
   17828:	ea83 0301 	eor.w	r3, r3, r1
   1782c:	b113      	cbz	r3, 17834 <memchr+0x74>
   1782e:	d1f8      	bne.n	17822 <memchr+0x62>
   17830:	2000      	movs	r0, #0
   17832:	4770      	bx	lr
   17834:	3801      	subs	r0, #1
   17836:	4770      	bx	lr
   17838:	2d00      	cmp	r5, #0
   1783a:	bf06      	itte	eq
   1783c:	4635      	moveq	r5, r6
   1783e:	3803      	subeq	r0, #3
   17840:	3807      	subne	r0, #7
   17842:	f015 0f01 	tst.w	r5, #1
   17846:	d107      	bne.n	17858 <memchr+0x98>
   17848:	3001      	adds	r0, #1
   1784a:	f415 7f80 	tst.w	r5, #256	; 0x100
   1784e:	bf02      	ittt	eq
   17850:	3001      	addeq	r0, #1
   17852:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
   17856:	3001      	addeq	r0, #1
   17858:	bcf0      	pop	{r4, r5, r6, r7}
   1785a:	3801      	subs	r0, #1
   1785c:	4770      	bx	lr
   1785e:	bf00      	nop

Disassembly of section .text._DRV_PHY_SMITransferStart%373:

00017860 <_DRV_PHY_SMITransferStart>:
    if(hClientObj->miimOpHandle != 0)
   17860:	6983      	ldr	r3, [r0, #24]
   17862:	2b00      	cmp	r3, #0
   17864:	d135      	bne.n	178d2 <_DRV_PHY_SMITransferStart+0x72>
{
   17866:	b530      	push	{r4, r5, lr}
   17868:	b085      	sub	sp, #20
   1786a:	4604      	mov	r4, r0
    DRV_ETHPHY_SMI_XFER_TYPE txType = hClientObj->smiTxferType;
   1786c:	f890 3036 	ldrb.w	r3, [r0, #54]	; 0x36
    if(txType == DRV_ETHPHY_SMI_XFER_TYPE_READ)
   17870:	2b03      	cmp	r3, #3
   17872:	d01b      	beq.n	178ac <_DRV_PHY_SMITransferStart+0x4c>
    else if(txType == DRV_ETHPHY_SMI_XFER_TYPE_WRITE || txType == DRV_ETHPHY_SMI_XFER_TYPE_WRITE_COMPLETE)
   17874:	1e5a      	subs	r2, r3, #1
   17876:	b2d2      	uxtb	r2, r2
   17878:	2a01      	cmp	r2, #1
   1787a:	d82c      	bhi.n	178d6 <_DRV_PHY_SMITransferStart+0x76>
        if(txType == DRV_ETHPHY_SMI_XFER_TYPE_WRITE)
   1787c:	2b01      	cmp	r3, #1
   1787e:	d02d      	beq.n	178dc <_DRV_PHY_SMITransferStart+0x7c>
        miimOpHandle = hClientObj->pMiimBase->DRV_MIIM_Write(hClientObj->miimHandle, hClientObj->smiRIx, hClientObj->smiPhyAddress, hClientObj->smiData, opFlags, &miimRes);
   17880:	6903      	ldr	r3, [r0, #16]
   17882:	f10d 020f 	add.w	r2, sp, #15
   17886:	9201      	str	r2, [sp, #4]
   17888:	2200      	movs	r2, #0
   1788a:	9200      	str	r2, [sp, #0]
   1788c:	6b1d      	ldr	r5, [r3, #48]	; 0x30
   1788e:	8f43      	ldrh	r3, [r0, #58]	; 0x3a
   17890:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
   17892:	8f01      	ldrh	r1, [r0, #56]	; 0x38
   17894:	6940      	ldr	r0, [r0, #20]
   17896:	47a8      	blx	r5
    if(miimOpHandle == 0)
   17898:	4603      	mov	r3, r0
   1789a:	b9a0      	cbnz	r0, 178c6 <_DRV_PHY_SMITransferStart+0x66>
        if(miimRes == DRV_MIIM_RES_BUSY)
   1789c:	f99d 300f 	ldrsb.w	r3, [sp, #15]
            return DRV_ETHPHY_SMI_TXFER_RES_MIIM_ERROR;
   178a0:	2b02      	cmp	r3, #2
   178a2:	bf0c      	ite	eq
   178a4:	2003      	moveq	r0, #3
   178a6:	f06f 0001 	mvnne.w	r0, #1
   178aa:	e010      	b.n	178ce <_DRV_PHY_SMITransferStart+0x6e>
        miimOpHandle = hClientObj->pMiimBase->DRV_MIIM_Read(hClientObj->miimHandle, hClientObj->smiRIx, hClientObj->smiPhyAddress, DRV_MIIM_OPERATION_FLAG_NONE, &miimRes);
   178ac:	6903      	ldr	r3, [r0, #16]
   178ae:	f10d 020f 	add.w	r2, sp, #15
   178b2:	9200      	str	r2, [sp, #0]
   178b4:	6add      	ldr	r5, [r3, #44]	; 0x2c
   178b6:	2300      	movs	r3, #0
   178b8:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
   178ba:	8f01      	ldrh	r1, [r0, #56]	; 0x38
   178bc:	6940      	ldr	r0, [r0, #20]
   178be:	47a8      	blx	r5
    if(miimOpHandle == 0)
   178c0:	4603      	mov	r3, r0
   178c2:	2800      	cmp	r0, #0
   178c4:	d0ea      	beq.n	1789c <_DRV_PHY_SMITransferStart+0x3c>
        hClientObj->miimOpHandle = miimOpHandle;
   178c6:	61a3      	str	r3, [r4, #24]
        txferRes = DRV_ETHPHY_SMI_TXFER_RES_SCHEDULED; 
   178c8:	2302      	movs	r3, #2
   178ca:	2001      	movs	r0, #1
    hClientObj->smiTxferStatus = newTxferStatus;
   178cc:	86a3      	strh	r3, [r4, #52]	; 0x34
}
   178ce:	b005      	add	sp, #20
   178d0:	bd30      	pop	{r4, r5, pc}
        return DRV_ETHPHY_SMI_TXFER_RES_BUSY;
   178d2:	2003      	movs	r0, #3
}
   178d4:	4770      	bx	lr
        return DRV_ETHPHY_SMI_TXFER_RES_ILLEGAL;
   178d6:	f04f 30ff 	mov.w	r0, #4294967295
   178da:	e7f8      	b.n	178ce <_DRV_PHY_SMITransferStart+0x6e>
        miimOpHandle = hClientObj->pMiimBase->DRV_MIIM_Write(hClientObj->miimHandle, hClientObj->smiRIx, hClientObj->smiPhyAddress, hClientObj->smiData, opFlags, &miimRes);
   178dc:	6903      	ldr	r3, [r0, #16]
   178de:	f10d 020f 	add.w	r2, sp, #15
   178e2:	9201      	str	r2, [sp, #4]
   178e4:	2201      	movs	r2, #1
   178e6:	9200      	str	r2, [sp, #0]
   178e8:	6b1d      	ldr	r5, [r3, #48]	; 0x30
   178ea:	8f43      	ldrh	r3, [r0, #58]	; 0x3a
   178ec:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
   178ee:	8f01      	ldrh	r1, [r0, #56]	; 0x38
   178f0:	6940      	ldr	r0, [r0, #20]
   178f2:	47a8      	blx	r5
    if(miimOpHandle == 0)
   178f4:	2800      	cmp	r0, #0
   178f6:	d0d1      	beq.n	1789c <_DRV_PHY_SMITransferStart+0x3c>
            newTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
   178f8:	2300      	movs	r3, #0
        txferRes = DRV_ETHPHY_SMI_TXFER_RES_DONE; 
   178fa:	4618      	mov	r0, r3
   178fc:	e7e6      	b.n	178cc <_DRV_PHY_SMITransferStart+0x6c>

Disassembly of section .text.__d2b%374:

000178fe <__d2b>:
   178fe:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   17902:	ec59 8b10 	vmov	r8, r9, d0
   17906:	460e      	mov	r6, r1
   17908:	f240 74ff 	movw	r4, #2047	; 0x7ff
   1790c:	2101      	movs	r1, #1
   1790e:	4615      	mov	r5, r2
   17910:	f003 f9a4 	bl	1ac5c <_Balloc>
   17914:	f3c9 0313 	ubfx	r3, r9, #0, #20
   17918:	ea14 5419 	ands.w	r4, r4, r9, lsr #20
   1791c:	bf18      	it	ne
   1791e:	f443 1380 	orrne.w	r3, r3, #1048576	; 0x100000
   17922:	9301      	str	r3, [sp, #4]
   17924:	f1b8 0300 	subs.w	r3, r8, #0
   17928:	4607      	mov	r7, r0
   1792a:	d023      	beq.n	17974 <__d2b+0x76>
   1792c:	4668      	mov	r0, sp
   1792e:	9300      	str	r3, [sp, #0]
   17930:	f003 fdd6 	bl	1b4e0 <__lo0bits>
   17934:	9900      	ldr	r1, [sp, #0]
   17936:	b1d8      	cbz	r0, 17970 <__d2b+0x72>
   17938:	9a01      	ldr	r2, [sp, #4]
   1793a:	f1c0 0320 	rsb	r3, r0, #32
   1793e:	fa02 f303 	lsl.w	r3, r2, r3
   17942:	430b      	orrs	r3, r1
   17944:	40c2      	lsrs	r2, r0
   17946:	617b      	str	r3, [r7, #20]
   17948:	9201      	str	r2, [sp, #4]
   1794a:	9b01      	ldr	r3, [sp, #4]
   1794c:	61bb      	str	r3, [r7, #24]
   1794e:	2b00      	cmp	r3, #0
   17950:	bf14      	ite	ne
   17952:	2102      	movne	r1, #2
   17954:	2101      	moveq	r1, #1
   17956:	6139      	str	r1, [r7, #16]
   17958:	b1ac      	cbz	r4, 17986 <__d2b+0x88>
   1795a:	f2a4 4433 	subw	r4, r4, #1075	; 0x433
   1795e:	4404      	add	r4, r0
   17960:	6034      	str	r4, [r6, #0]
   17962:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
   17966:	6028      	str	r0, [r5, #0]
   17968:	4638      	mov	r0, r7
   1796a:	b003      	add	sp, #12
   1796c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   17970:	6179      	str	r1, [r7, #20]
   17972:	e7ea      	b.n	1794a <__d2b+0x4c>
   17974:	a801      	add	r0, sp, #4
   17976:	f003 fdb3 	bl	1b4e0 <__lo0bits>
   1797a:	9b01      	ldr	r3, [sp, #4]
   1797c:	617b      	str	r3, [r7, #20]
   1797e:	2101      	movs	r1, #1
   17980:	6139      	str	r1, [r7, #16]
   17982:	3020      	adds	r0, #32
   17984:	e7e8      	b.n	17958 <__d2b+0x5a>
   17986:	eb07 0381 	add.w	r3, r7, r1, lsl #2
   1798a:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
   1798e:	6030      	str	r0, [r6, #0]
   17990:	6918      	ldr	r0, [r3, #16]
   17992:	f006 f91f 	bl	1dbd4 <__hi0bits>
   17996:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
   1799a:	e7e4      	b.n	17966 <__d2b+0x68>

Disassembly of section .text.DRV_MIIM_Setup%375:

0001799c <DRV_MIIM_Setup>:
    if(pSetUp == 0)
   1799c:	2900      	cmp	r1, #0
   1799e:	d042      	beq.n	17a26 <DRV_MIIM_Setup+0x8a>
{
   179a0:	b510      	push	{r4, lr}
   179a2:	460c      	mov	r4, r1
    if((pClient = _DRV_MIIM_GetClientAndLock(handle, true)) == 0)
   179a4:	2101      	movs	r1, #1
   179a6:	f004 fdd0 	bl	1c54a <_DRV_MIIM_GetClientAndLock>
   179aa:	2800      	cmp	r0, #0
   179ac:	d03e      	beq.n	17a2c <DRV_MIIM_Setup+0x90>
    pMiimObj = pClient->parentObj;
   179ae:	6840      	ldr	r0, [r0, #4]
    
    static  __inline__ void __attribute__((always_inline)) _DRV_MIIM_SMI_CLOCK_SET(uintptr_t ethPhyId, uint32_t hostClock, uint32_t maxMIIMClock )
    { 
    	uint32_t mdc_div; 
        GMAC_MIIM_CLK clock_dividor ; 
        mdc_div = hostClock/maxMIIMClock; 
   179b0:	6823      	ldr	r3, [r4, #0]
   179b2:	6862      	ldr	r2, [r4, #4]
   179b4:	fbb3 f3f2 	udiv	r3, r3, r2
        if (mdc_div <= 8 ) 
   179b8:	2b08      	cmp	r3, #8
   179ba:	d90c      	bls.n	179d6 <DRV_MIIM_Setup+0x3a>
        { 
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_8; 
        } 
        else if (mdc_div <= 16 ) 
   179bc:	2b10      	cmp	r3, #16
   179be:	d92a      	bls.n	17a16 <DRV_MIIM_Setup+0x7a>
        { 
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_16; 
        } 
        else if (mdc_div <= 32 ) 
   179c0:	2b20      	cmp	r3, #32
   179c2:	d92a      	bls.n	17a1a <DRV_MIIM_Setup+0x7e>
        { 
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_32; 
        } 
        else if (mdc_div <= 48 ) 
   179c4:	2b30      	cmp	r3, #48	; 0x30
   179c6:	d92a      	bls.n	17a1e <DRV_MIIM_Setup+0x82>
        { 
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_48; 
        } 
        else if (mdc_div <= 64 ) 
   179c8:	2b40      	cmp	r3, #64	; 0x40
   179ca:	d92a      	bls.n	17a22 <DRV_MIIM_Setup+0x86>
        { 
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_96; 
        } 
        else 
        { 
            clock_dividor = 0; 
   179cc:	2b61      	cmp	r3, #97	; 0x61
   179ce:	bf34      	ite	cc
   179d0:	2405      	movcc	r4, #5
   179d2:	2400      	movcs	r4, #0
   179d4:	e000      	b.n	179d8 <DRV_MIIM_Setup+0x3c>
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_8; 
   179d6:	2400      	movs	r4, #0
        } 
        GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_TXEN_Msk; 
   179d8:	4b16      	ldr	r3, [pc, #88]	; (17a34 <DRV_MIIM_Setup+0x98>)
   179da:	6819      	ldr	r1, [r3, #0]
   179dc:	f021 0108 	bic.w	r1, r1, #8
   179e0:	6019      	str	r1, [r3, #0]
        GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_RXEN_Msk;	
   179e2:	6819      	ldr	r1, [r3, #0]
   179e4:	f021 0104 	bic.w	r1, r1, #4
   179e8:	6019      	str	r1, [r3, #0]
        GMAC_REGS->GMAC_NCFGR = 
                   (GMAC_REGS->GMAC_NCFGR & 
   179ea:	685a      	ldr	r2, [r3, #4]
   179ec:	f422 12e0 	bic.w	r2, r2, #1835008	; 0x1c0000
                        (~GMAC_NCFGR_CLK_Msk)) | (clock_dividor << GMAC_NCFGR_CLK_Pos); 
   179f0:	ea42 4284 	orr.w	r2, r2, r4, lsl #18
        GMAC_REGS->GMAC_NCFGR = 
   179f4:	605a      	str	r2, [r3, #4]
        GMAC_REGS->GMAC_NCR |= GMAC_NCR_TXEN_Msk; 
   179f6:	681a      	ldr	r2, [r3, #0]
   179f8:	f042 0208 	orr.w	r2, r2, #8
   179fc:	601a      	str	r2, [r3, #0]
        GMAC_REGS->GMAC_NCR |= GMAC_NCR_RXEN_Msk;	
   179fe:	681a      	ldr	r2, [r3, #0]
   17a00:	f042 0204 	orr.w	r2, r2, #4
   17a04:	601a      	str	r2, [r3, #0]
    pMiimObj->objFlags |= DRV_MIIM_OBJ_FLAG_SETUP_DONE;
   17a06:	8883      	ldrh	r3, [r0, #4]
   17a08:	f043 0302 	orr.w	r3, r3, #2
   17a0c:	8083      	strh	r3, [r0, #4]
    OSAL_SEM_Post(&pMiimObj->objSem);
   17a0e:	f009 fd51 	bl	214b4 <OSAL_SEM_Post>
    return res;
   17a12:	2000      	movs	r0, #0
}
   17a14:	bd10      	pop	{r4, pc}
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_16; 
   17a16:	2401      	movs	r4, #1
   17a18:	e7de      	b.n	179d8 <DRV_MIIM_Setup+0x3c>
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_32; 
   17a1a:	2402      	movs	r4, #2
   17a1c:	e7dc      	b.n	179d8 <DRV_MIIM_Setup+0x3c>
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_48; 
   17a1e:	2403      	movs	r4, #3
   17a20:	e7da      	b.n	179d8 <DRV_MIIM_Setup+0x3c>
            clock_dividor = GMAC_MIIM_SYSCLK_DIV_BY_64; 
   17a22:	2404      	movs	r4, #4
   17a24:	e7d8      	b.n	179d8 <DRV_MIIM_Setup+0x3c>
        return DRV_MIIM_RES_PARAMETER_ERR;
   17a26:	f06f 0006 	mvn.w	r0, #6
}
   17a2a:	4770      	bx	lr
        return DRV_MIIM_RES_HANDLE_ERR;
   17a2c:	f04f 30ff 	mov.w	r0, #4294967295
   17a30:	e7f0      	b.n	17a14 <DRV_MIIM_Setup+0x78>
   17a32:	bf00      	nop
   17a34:	42000800 	.word	0x42000800

Disassembly of section .text._Command_MACAddressSet%376:

00017a38 <_Command_MACAddressSet>:
{
   17a38:	b5f0      	push	{r4, r5, r6, r7, lr}
   17a3a:	b083      	sub	sp, #12
   17a3c:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   17a3e:	6845      	ldr	r5, [r0, #4]
    if (argc != 3) {
   17a40:	2903      	cmp	r1, #3
   17a42:	d00f      	beq.n	17a64 <_Command_MACAddressSet+0x2c>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: setmac <interface> <x:x:x:x:x:x> \r\n");
   17a44:	4e1e      	ldr	r6, [pc, #120]	; (17ac0 <__MIN_HEAP_SIZE>)
   17a46:	6803      	ldr	r3, [r0, #0]
   17a48:	681b      	ldr	r3, [r3, #0]
   17a4a:	f606 31f4 	addw	r1, r6, #3060	; 0xbf4
   17a4e:	4628      	mov	r0, r5
   17a50:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: setmac PIC32INT aa:bb:cc:dd:ee:ff \r\n");
   17a52:	6823      	ldr	r3, [r4, #0]
   17a54:	681b      	ldr	r3, [r3, #0]
   17a56:	f506 6142 	add.w	r1, r6, #3104	; 0xc20
   17a5a:	4628      	mov	r0, r5
   17a5c:	4798      	blx	r3
        return false;
   17a5e:	2000      	movs	r0, #0
}
   17a60:	b003      	add	sp, #12
   17a62:	bdf0      	pop	{r4, r5, r6, r7, pc}
   17a64:	4616      	mov	r6, r2
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
   17a66:	6850      	ldr	r0, [r2, #4]
   17a68:	f005 ff74 	bl	1d954 <TCPIP_STACK_NetHandleGet>
    if (netH == 0) {
   17a6c:	4607      	mov	r7, r0
   17a6e:	b188      	cbz	r0, 17a94 <_Command_MACAddressSet+0x5c>
    (*pCmdIO->pCmdApi->print)(cmdIoParam, "argv[2]: %s\r\n", argv[2]);
   17a70:	6823      	ldr	r3, [r4, #0]
   17a72:	685b      	ldr	r3, [r3, #4]
   17a74:	68b2      	ldr	r2, [r6, #8]
   17a76:	4913      	ldr	r1, [pc, #76]	; (17ac4 <__MIN_HEAP_SIZE+0x4>)
   17a78:	4628      	mov	r0, r5
   17a7a:	4798      	blx	r3
    if (!TCPIP_Helper_StringToMACAddress(argv[2], macAddr.v)) {
   17a7c:	4669      	mov	r1, sp
   17a7e:	68b0      	ldr	r0, [r6, #8]
   17a80:	f7fe fa52 	bl	15f28 <TCPIP_Helper_StringToMACAddress>
   17a84:	b968      	cbnz	r0, 17aa2 <_Command_MACAddressSet+0x6a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Invalid MAC address string \r\n");
   17a86:	6823      	ldr	r3, [r4, #0]
   17a88:	681b      	ldr	r3, [r3, #0]
   17a8a:	490f      	ldr	r1, [pc, #60]	; (17ac8 <__MIN_HEAP_SIZE+0x8>)
   17a8c:	4628      	mov	r0, r5
   17a8e:	4798      	blx	r3
        return false;
   17a90:	2000      	movs	r0, #0
   17a92:	e7e5      	b.n	17a60 <_Command_MACAddressSet+0x28>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   17a94:	6823      	ldr	r3, [r4, #0]
   17a96:	681b      	ldr	r3, [r3, #0]
   17a98:	490c      	ldr	r1, [pc, #48]	; (17acc <__MIN_HEAP_SIZE+0xc>)
   17a9a:	4628      	mov	r0, r5
   17a9c:	4798      	blx	r3
        return false;
   17a9e:	2000      	movs	r0, #0
   17aa0:	e7de      	b.n	17a60 <_Command_MACAddressSet+0x28>
    if(!TCPIP_STACK_NetAddressMacSet(netH, &macAddr)) {
   17aa2:	4669      	mov	r1, sp
   17aa4:	4638      	mov	r0, r7
   17aa6:	f008 fdff 	bl	206a8 <TCPIP_STACK_NetAddressMacSet>
   17aaa:	b108      	cbz	r0, 17ab0 <_Command_MACAddressSet+0x78>
    return true;
   17aac:	2001      	movs	r0, #1
   17aae:	e7d7      	b.n	17a60 <_Command_MACAddressSet+0x28>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Set MAC address failed\r\n");
   17ab0:	6823      	ldr	r3, [r4, #0]
   17ab2:	681b      	ldr	r3, [r3, #0]
   17ab4:	4906      	ldr	r1, [pc, #24]	; (17ad0 <__MIN_HEAP_SIZE+0x10>)
   17ab6:	4628      	mov	r0, r5
   17ab8:	4798      	blx	r3
        return false;
   17aba:	2000      	movs	r0, #0
   17abc:	e7d0      	b.n	17a60 <_Command_MACAddressSet+0x28>
   17abe:	bf00      	nop
   17ac0:	0000028c 	.word	0x0000028c
   17ac4:	00000ed8 	.word	0x00000ed8
   17ac8:	00000ee8 	.word	0x00000ee8
   17acc:	00000da8 	.word	0x00000da8
   17ad0:	00000f08 	.word	0x00000f08

Disassembly of section .text._free_r%377:

00017ad4 <_free_r>:
   17ad4:	b538      	push	{r3, r4, r5, lr}
   17ad6:	4605      	mov	r5, r0
   17ad8:	2900      	cmp	r1, #0
   17ada:	d045      	beq.n	17b68 <_free_r+0x94>
   17adc:	f851 3c04 	ldr.w	r3, [r1, #-4]
   17ae0:	1f0c      	subs	r4, r1, #4
   17ae2:	2b00      	cmp	r3, #0
   17ae4:	bfb8      	it	lt
   17ae6:	18e4      	addlt	r4, r4, r3
   17ae8:	f004 fb77 	bl	1c1da <__malloc_lock>
   17aec:	4a1f      	ldr	r2, [pc, #124]	; (17b6c <_free_r+0x98>)
   17aee:	6813      	ldr	r3, [r2, #0]
   17af0:	4610      	mov	r0, r2
   17af2:	b933      	cbnz	r3, 17b02 <_free_r+0x2e>
   17af4:	6063      	str	r3, [r4, #4]
   17af6:	6014      	str	r4, [r2, #0]
   17af8:	4628      	mov	r0, r5
   17afa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   17afe:	f006 b9f8 	b.w	1def2 <__malloc_unlock>
   17b02:	42a3      	cmp	r3, r4
   17b04:	d90c      	bls.n	17b20 <_free_r+0x4c>
   17b06:	6821      	ldr	r1, [r4, #0]
   17b08:	1862      	adds	r2, r4, r1
   17b0a:	4293      	cmp	r3, r2
   17b0c:	bf04      	itt	eq
   17b0e:	681a      	ldreq	r2, [r3, #0]
   17b10:	685b      	ldreq	r3, [r3, #4]
   17b12:	6063      	str	r3, [r4, #4]
   17b14:	bf04      	itt	eq
   17b16:	1852      	addeq	r2, r2, r1
   17b18:	6022      	streq	r2, [r4, #0]
   17b1a:	6004      	str	r4, [r0, #0]
   17b1c:	e7ec      	b.n	17af8 <_free_r+0x24>
   17b1e:	4613      	mov	r3, r2
   17b20:	685a      	ldr	r2, [r3, #4]
   17b22:	b10a      	cbz	r2, 17b28 <_free_r+0x54>
   17b24:	42a2      	cmp	r2, r4
   17b26:	d9fa      	bls.n	17b1e <_free_r+0x4a>
   17b28:	6819      	ldr	r1, [r3, #0]
   17b2a:	1858      	adds	r0, r3, r1
   17b2c:	42a0      	cmp	r0, r4
   17b2e:	d10b      	bne.n	17b48 <_free_r+0x74>
   17b30:	6820      	ldr	r0, [r4, #0]
   17b32:	4401      	add	r1, r0
   17b34:	1858      	adds	r0, r3, r1
   17b36:	4282      	cmp	r2, r0
   17b38:	6019      	str	r1, [r3, #0]
   17b3a:	d1dd      	bne.n	17af8 <_free_r+0x24>
   17b3c:	6810      	ldr	r0, [r2, #0]
   17b3e:	6852      	ldr	r2, [r2, #4]
   17b40:	605a      	str	r2, [r3, #4]
   17b42:	4401      	add	r1, r0
   17b44:	6019      	str	r1, [r3, #0]
   17b46:	e7d7      	b.n	17af8 <_free_r+0x24>
   17b48:	d902      	bls.n	17b50 <_free_r+0x7c>
   17b4a:	230c      	movs	r3, #12
   17b4c:	602b      	str	r3, [r5, #0]
   17b4e:	e7d3      	b.n	17af8 <_free_r+0x24>
   17b50:	6820      	ldr	r0, [r4, #0]
   17b52:	1821      	adds	r1, r4, r0
   17b54:	428a      	cmp	r2, r1
   17b56:	bf04      	itt	eq
   17b58:	6811      	ldreq	r1, [r2, #0]
   17b5a:	6852      	ldreq	r2, [r2, #4]
   17b5c:	6062      	str	r2, [r4, #4]
   17b5e:	bf04      	itt	eq
   17b60:	1809      	addeq	r1, r1, r0
   17b62:	6021      	streq	r1, [r4, #0]
   17b64:	605c      	str	r4, [r3, #4]
   17b66:	e7c7      	b.n	17af8 <_free_r+0x24>
   17b68:	bd38      	pop	{r3, r4, r5, pc}
   17b6a:	bf00      	nop
   17b6c:	2000e704 	.word	0x2000e704

Disassembly of section .text.__pow5mult%378:

00017b70 <__pow5mult>:
   17b70:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   17b74:	4615      	mov	r5, r2
   17b76:	f012 0203 	ands.w	r2, r2, #3
   17b7a:	4606      	mov	r6, r0
   17b7c:	460f      	mov	r7, r1
   17b7e:	d007      	beq.n	17b90 <__pow5mult+0x20>
   17b80:	3a01      	subs	r2, #1
   17b82:	4c21      	ldr	r4, [pc, #132]	; (17c08 <__pow5mult+0x98>)
   17b84:	2300      	movs	r3, #0
   17b86:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
   17b8a:	f001 fc6a 	bl	19462 <__multadd>
   17b8e:	4607      	mov	r7, r0
   17b90:	10ad      	asrs	r5, r5, #2
   17b92:	d035      	beq.n	17c00 <__pow5mult+0x90>
   17b94:	6a74      	ldr	r4, [r6, #36]	; 0x24
   17b96:	b93c      	cbnz	r4, 17ba8 <__pow5mult+0x38>
   17b98:	2010      	movs	r0, #16
   17b9a:	f009 ffdf 	bl	21b5c <malloc>
   17b9e:	e9c0 4401 	strd	r4, r4, [r0, #4]
   17ba2:	6270      	str	r0, [r6, #36]	; 0x24
   17ba4:	6004      	str	r4, [r0, #0]
   17ba6:	60c4      	str	r4, [r0, #12]
   17ba8:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
   17bac:	f8d8 4008 	ldr.w	r4, [r8, #8]
   17bb0:	b94c      	cbnz	r4, 17bc6 <__pow5mult+0x56>
   17bb2:	f240 2171 	movw	r1, #625	; 0x271
   17bb6:	4630      	mov	r0, r6
   17bb8:	f009 ff0e 	bl	219d8 <__i2b>
   17bbc:	2300      	movs	r3, #0
   17bbe:	f8c8 0008 	str.w	r0, [r8, #8]
   17bc2:	4604      	mov	r4, r0
   17bc4:	6003      	str	r3, [r0, #0]
   17bc6:	f04f 0800 	mov.w	r8, #0
   17bca:	07eb      	lsls	r3, r5, #31
   17bcc:	d50a      	bpl.n	17be4 <__pow5mult+0x74>
   17bce:	4639      	mov	r1, r7
   17bd0:	4622      	mov	r2, r4
   17bd2:	4630      	mov	r0, r6
   17bd4:	f7fa fc1e 	bl	12414 <__multiply>
   17bd8:	4639      	mov	r1, r7
   17bda:	4681      	mov	r9, r0
   17bdc:	4630      	mov	r0, r6
   17bde:	f007 fd3a 	bl	1f656 <_Bfree>
   17be2:	464f      	mov	r7, r9
   17be4:	106d      	asrs	r5, r5, #1
   17be6:	d00b      	beq.n	17c00 <__pow5mult+0x90>
   17be8:	6820      	ldr	r0, [r4, #0]
   17bea:	b938      	cbnz	r0, 17bfc <__pow5mult+0x8c>
   17bec:	4622      	mov	r2, r4
   17bee:	4621      	mov	r1, r4
   17bf0:	4630      	mov	r0, r6
   17bf2:	f7fa fc0f 	bl	12414 <__multiply>
   17bf6:	6020      	str	r0, [r4, #0]
   17bf8:	f8c0 8000 	str.w	r8, [r0]
   17bfc:	4604      	mov	r4, r0
   17bfe:	e7e4      	b.n	17bca <__pow5mult+0x5a>
   17c00:	4638      	mov	r0, r7
   17c02:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   17c06:	bf00      	nop
   17c08:	00021fa0 	.word	0x00021fa0

Disassembly of section .text.Lan867x_Write_Bit_Register%379:

00017c0c <Lan867x_Write_Bit_Register>:
{
   17c0c:	b5f0      	push	{r4, r5, r6, r7, lr}
   17c0e:	b083      	sub	sp, #12
   17c10:	4604      	mov	r4, r0
   17c12:	460d      	mov	r5, r1
   17c14:	4616      	mov	r6, r2
   17c16:	461f      	mov	r7, r3
    uint16_t regValue = 0;
   17c18:	2300      	movs	r3, #0
   17c1a:	f8ad 3006 	strh.w	r3, [sp, #6]
    if (R2F(clientObj->vendorData, VENDOR_INTERNAL_STATE) == IDLE_PHASE) {
   17c1e:	6843      	ldr	r3, [r0, #4]
   17c20:	0e5a      	lsrs	r2, r3, #25
   17c22:	d00f      	beq.n	17c44 <Lan867x_Write_Bit_Register+0x38>
    if (R2F(clientObj->vendorData, VENDOR_IS_BIT_OP) == true) {
   17c24:	6863      	ldr	r3, [r4, #4]
   17c26:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
   17c2a:	d02b      	beq.n	17c84 <Lan867x_Write_Bit_Register+0x78>
        res = Lan867x_Miim_Task(clientObj, DRV_MIIM_OP_READ, regAddr, &regValue);
   17c2c:	f10d 0306 	add.w	r3, sp, #6
   17c30:	462a      	mov	r2, r5
   17c32:	2101      	movs	r1, #1
   17c34:	4620      	mov	r0, r4
   17c36:	f7f6 ff63 	bl	eb00 <Lan867x_Miim_Task>
        if (res == DRV_MIIM_RES_OK) {
   17c3a:	4603      	mov	r3, r0
   17c3c:	b178      	cbz	r0, 17c5e <Lan867x_Write_Bit_Register+0x52>
}
   17c3e:	4618      	mov	r0, r3
   17c40:	b003      	add	sp, #12
   17c42:	bdf0      	pop	{r4, r5, r6, r7, pc}
            F2R(internalState, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   17c44:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   17c48:	291f      	cmp	r1, #31
   17c4a:	bf94      	ite	ls
   17c4c:	f04f 7200 	movls.w	r2, #33554432	; 0x2000000
   17c50:	f04f 6200 	movhi.w	r2, #134217728	; 0x8000000
   17c54:	4313      	orrs	r3, r2
        clientObj->vendorData = F2R(true, VENDOR_IS_BIT_OP, clientObj->vendorData);
   17c56:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   17c5a:	6043      	str	r3, [r0, #4]
   17c5c:	e7e2      	b.n	17c24 <Lan867x_Write_Bit_Register+0x18>
            clientObj->vendorData = F2R(((regValue & (uint16_t)~mask) | (wData & mask)),
   17c5e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   17c62:	405f      	eors	r7, r3
   17c64:	403e      	ands	r6, r7
   17c66:	405e      	eors	r6, r3
   17c68:	6863      	ldr	r3, [r4, #4]
   17c6a:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
                F2R(internalState, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   17c6e:	431e      	orrs	r6, r3
   17c70:	2d1f      	cmp	r5, #31
   17c72:	bf94      	ite	ls
   17c74:	f04f 6580 	movls.w	r5, #67108864	; 0x4000000
   17c78:	f04f 6500 	movhi.w	r5, #134217728	; 0x8000000
   17c7c:	4335      	orrs	r5, r6
            clientObj->vendorData =
   17c7e:	6065      	str	r5, [r4, #4]
            res = DRV_MIIM_RES_PENDING;
   17c80:	2301      	movs	r3, #1
   17c82:	e7dc      	b.n	17c3e <Lan867x_Write_Bit_Register+0x32>
        regValue = R2F(clientObj->vendorData, VENDOR_DATA);
   17c84:	f8ad 3006 	strh.w	r3, [sp, #6]
        res = Lan867x_Miim_Task(clientObj, DRV_MIIM_OP_WRITE, regAddr, &regValue);
   17c88:	f10d 0306 	add.w	r3, sp, #6
   17c8c:	462a      	mov	r2, r5
   17c8e:	2102      	movs	r1, #2
   17c90:	4620      	mov	r0, r4
   17c92:	f7f6 ff35 	bl	eb00 <Lan867x_Miim_Task>
        if (res == DRV_MIIM_RES_OK) {
   17c96:	4603      	mov	r3, r0
   17c98:	2800      	cmp	r0, #0
   17c9a:	d1d0      	bne.n	17c3e <Lan867x_Write_Bit_Register+0x32>
                F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   17c9c:	6862      	ldr	r2, [r4, #4]
   17c9e:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
            clientObj->vendorData =
   17ca2:	6062      	str	r2, [r4, #4]
            res = DRV_MIIM_RES_OK;
   17ca4:	e7cb      	b.n	17c3e <Lan867x_Write_Bit_Register+0x32>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseDetect%380:

00017ca8 <_DRV_ETHPHY_SetupPhaseDetect>:
{
   17ca8:	b538      	push	{r3, r4, r5, lr}
   17caa:	4604      	mov	r4, r0
    switch (hClientObj->operSubPhase)
   17cac:	8c03      	ldrh	r3, [r0, #32]
   17cae:	b133      	cbz	r3, 17cbe <_DRV_ETHPHY_SetupPhaseDetect+0x16>
   17cb0:	2b01      	cmp	r3, #1
   17cb2:	d023      	beq.n	17cfc <_DRV_ETHPHY_SetupPhaseDetect+0x54>
            _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   17cb4:	f06f 0108 	mvn.w	r1, #8
   17cb8:	f007 ff84 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
}
   17cbc:	e01d      	b.n	17cfa <_DRV_ETHPHY_SetupPhaseDetect+0x52>
            if((detectF = hDriver->pPhyObj->phyDetect) == 0)
   17cbe:	68c3      	ldr	r3, [r0, #12]
   17cc0:	695b      	ldr	r3, [r3, #20]
   17cc2:	691b      	ldr	r3, [r3, #16]
                detectF = _DRV_ETHPHY_DefaultDetect;
   17cc4:	4a1b      	ldr	r2, [pc, #108]	; (17d34 <_DRV_ETHPHY_SetupPhaseDetect+0x8c>)
   17cc6:	2b00      	cmp	r3, #0
   17cc8:	bf08      	it	eq
   17cca:	4613      	moveq	r3, r2
            hClientObj->vendorDetect = detectF;
   17ccc:	6443      	str	r3, [r0, #68]	; 0x44
            hClientObj->vendorData = 0;
   17cce:	2300      	movs	r3, #0
   17cd0:	6403      	str	r3, [r0, #64]	; 0x40
            hClientObj->operTStamp = SYS_TMR_TickCountGet() + ((DRV_ETHPHY_RESET_CLR_TMO * SYS_TMR_TickCounterFrequencyGet()) + 999) / 1000;
   17cd2:	f008 f96b 	bl	1ffac <SYS_TMR_TickCountGet>
   17cd6:	4605      	mov	r5, r0
   17cd8:	f008 f990 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
   17cdc:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   17ce0:	fb03 f000 	mul.w	r0, r3, r0
   17ce4:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
   17ce8:	4b13      	ldr	r3, [pc, #76]	; (17d38 <_DRV_ETHPHY_SetupPhaseDetect+0x90>)
   17cea:	fba3 3000 	umull	r3, r0, r3, r0
   17cee:	eb05 1090 	add.w	r0, r5, r0, lsr #6
   17cf2:	62a0      	str	r0, [r4, #40]	; 0x28
    hClientObj->operPhase = operPhase;
   17cf4:	2301      	movs	r3, #1
   17cf6:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   17cf8:	8423      	strh	r3, [r4, #32]
}
   17cfa:	bd38      	pop	{r3, r4, r5, pc}
            res =  hClientObj->vendorDetect(gDrvEthBaseObj, (DRV_HANDLE)hClientObj);
   17cfc:	6c43      	ldr	r3, [r0, #68]	; 0x44
   17cfe:	4601      	mov	r1, r0
   17d00:	480e      	ldr	r0, [pc, #56]	; (17d3c <_DRV_ETHPHY_SetupPhaseDetect+0x94>)
   17d02:	4798      	blx	r3
            if(res == DRV_ETHPHY_RES_OK)
   17d04:	4601      	mov	r1, r0
   17d06:	b160      	cbz	r0, 17d22 <_DRV_ETHPHY_SetupPhaseDetect+0x7a>
            else if(res < 0)
   17d08:	2800      	cmp	r0, #0
   17d0a:	db0f      	blt.n	17d2c <_DRV_ETHPHY_SetupPhaseDetect+0x84>
                if(SYS_TMR_TickCountGet() >= hClientObj->operTStamp)
   17d0c:	f008 f94e 	bl	1ffac <SYS_TMR_TickCountGet>
   17d10:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   17d12:	4298      	cmp	r0, r3
   17d14:	d3f1      	bcc.n	17cfa <_DRV_ETHPHY_SetupPhaseDetect+0x52>
                    _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_DTCT_TMO);
   17d16:	f06f 0101 	mvn.w	r1, #1
   17d1a:	4620      	mov	r0, r4
   17d1c:	f007 ff52 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
   17d20:	e7eb      	b.n	17cfa <_DRV_ETHPHY_SetupPhaseDetect+0x52>
    hClientObj->operPhase = operPhase;
   17d22:	2302      	movs	r3, #2
   17d24:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   17d26:	2300      	movs	r3, #0
   17d28:	8423      	strh	r3, [r4, #32]
   17d2a:	e7e6      	b.n	17cfa <_DRV_ETHPHY_SetupPhaseDetect+0x52>
                _DRV_PHY_SetOperDoneResult(hClientObj, res);
   17d2c:	4620      	mov	r0, r4
   17d2e:	f007 ff49 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
   17d32:	e7e2      	b.n	17cfa <_DRV_ETHPHY_SetupPhaseDetect+0x52>
   17d34:	0000fee9 	.word	0x0000fee9
   17d38:	10624dd3 	.word	0x10624dd3
   17d3c:	0001b540 	.word	0x0001b540

Disassembly of section .text.DRV_GMAC_StatisticsGet%381:

00017d40 <DRV_GMAC_StatisticsGet>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   17d40:	4b20      	ldr	r3, [pc, #128]	; (17dc4 <DRV_GMAC_StatisticsGet+0x84>)
   17d42:	4283      	cmp	r3, r0
   17d44:	d136      	bne.n	17db4 <DRV_GMAC_StatisticsGet+0x74>
    if(pMACDrv == 0)
   17d46:	2800      	cmp	r0, #0
   17d48:	d037      	beq.n	17dba <DRV_GMAC_StatisticsGet+0x7a>
{
   17d4a:	b570      	push	{r4, r5, r6, lr}
   17d4c:	4615      	mov	r5, r2
   17d4e:	460c      	mov	r4, r1
	if(pRxStatistics)
   17d50:	b1c9      	cbz	r1, 17d86 <DRV_GMAC_StatisticsGet+0x46>
	if(pMACDrv->sGmacData._synchF != 0)
   17d52:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   17d54:	b113      	cbz	r3, 17d5c <DRV_GMAC_StatisticsGet+0x1c>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_ENTER);
   17d56:	2105      	movs	r1, #5
   17d58:	481b      	ldr	r0, [pc, #108]	; (17dc8 <DRV_GMAC_StatisticsGet+0x88>)
   17d5a:	4798      	blx	r3
		DRV_PIC32CGMAC_LibRxBuffersCountGet(pMACDrv, &pMACDrv->sGmacData._rxStat.nRxPendBuffers, &pMACDrv->sGmacData._rxStat.nRxSchedBuffers);
   17d5c:	4e19      	ldr	r6, [pc, #100]	; (17dc4 <DRV_GMAC_StatisticsGet+0x84>)
   17d5e:	f106 026c 	add.w	r2, r6, #108	; 0x6c
   17d62:	f106 0168 	add.w	r1, r6, #104	; 0x68
   17d66:	4630      	mov	r0, r6
   17d68:	f003 fdb6 	bl	1b8d8 <DRV_PIC32CGMAC_LibRxBuffersCountGet>
	if(pMACDrv->sGmacData._synchF != 0)
   17d6c:	6b33      	ldr	r3, [r6, #48]	; 0x30
   17d6e:	b11b      	cbz	r3, 17d78 <DRV_GMAC_StatisticsGet+0x38>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncRxH, TCPIP_MAC_SYNCH_REQUEST_CRIT_LEAVE);
   17d70:	2106      	movs	r1, #6
   17d72:	f106 005c 	add.w	r0, r6, #92	; 0x5c
   17d76:	4798      	blx	r3
		*pRxStatistics = pMACDrv->sGmacData._rxStat;
   17d78:	4e14      	ldr	r6, [pc, #80]	; (17dcc <DRV_GMAC_StatisticsGet+0x8c>)
   17d7a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   17d7c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   17d7e:	e896 0003 	ldmia.w	r6, {r0, r1}
   17d82:	e884 0003 	stmia.w	r4, {r0, r1}
	if(pTxStatistics)
   17d86:	b1dd      	cbz	r5, 17dc0 <DRV_GMAC_StatisticsGet+0x80>
	if(pMACDrv->sGmacData._synchF != 0)
   17d88:	4b0e      	ldr	r3, [pc, #56]	; (17dc4 <DRV_GMAC_StatisticsGet+0x84>)
   17d8a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   17d8c:	b113      	cbz	r3, 17d94 <DRV_GMAC_StatisticsGet+0x54>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_LOCK);
   17d8e:	2103      	movs	r1, #3
   17d90:	480f      	ldr	r0, [pc, #60]	; (17dd0 <DRV_GMAC_StatisticsGet+0x90>)
   17d92:	4798      	blx	r3
			pMACDrv->sGmacData._txStat.nTxPendBuffers += DRV_PIC32CGMAC_SingleListCount(&(pMACDrv->sGmacData.gmac_queue[index]._TxQueue));
   17d94:	4b0b      	ldr	r3, [pc, #44]	; (17dc4 <DRV_GMAC_StatisticsGet+0x84>)
   17d96:	f8d3 20ac 	ldr.w	r2, [r3, #172]	; 0xac
   17d9a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	if(pMACDrv->sGmacData._synchF != 0)
   17d9e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   17da0:	b113      	cbz	r3, 17da8 <DRV_GMAC_StatisticsGet+0x68>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_UNLOCK);
   17da2:	2104      	movs	r1, #4
   17da4:	480a      	ldr	r0, [pc, #40]	; (17dd0 <DRV_GMAC_StatisticsGet+0x90>)
   17da6:	4798      	blx	r3
		*pTxStatistics = pMACDrv->sGmacData._txStat;
   17da8:	4b0a      	ldr	r3, [pc, #40]	; (17dd4 <DRV_GMAC_StatisticsGet+0x94>)
   17daa:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   17dac:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
	return TCPIP_MAC_RES_OK;
   17db0:	2000      	movs	r0, #0
}
   17db2:	bd70      	pop	{r4, r5, r6, pc}
        return TCPIP_MAC_RES_OP_ERR;
   17db4:	f06f 0005 	mvn.w	r0, #5
   17db8:	4770      	bx	lr
   17dba:	f06f 0005 	mvn.w	r0, #5
}
   17dbe:	4770      	bx	lr
	return TCPIP_MAC_RES_OK;
   17dc0:	2000      	movs	r0, #0
   17dc2:	e7f6      	b.n	17db2 <DRV_GMAC_StatisticsGet+0x72>
   17dc4:	2000dab8 	.word	0x2000dab8
   17dc8:	2000db14 	.word	0x2000db14
   17dcc:	2000db1c 	.word	0x2000db1c
   17dd0:	2000db18 	.word	0x2000db18
   17dd4:	2000db34 	.word	0x2000db34

Disassembly of section .text._DHCPEnable%382:

00017dd8 <_DHCPEnable>:
{
   17dd8:	b570      	push	{r4, r5, r6, lr}
   17dda:	4606      	mov	r6, r0
   17ddc:	460d      	mov	r5, r1
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   17dde:	4b20      	ldr	r3, [pc, #128]	; (17e60 <_DHCPEnable+0x88>)
   17de0:	681c      	ldr	r4, [r3, #0]
   17de2:	f009 ff17 	bl	21c14 <TCPIP_STACK_NetIxGet>
   17de6:	235c      	movs	r3, #92	; 0x5c
   17de8:	fb03 4400 	mla	r4, r3, r0, r4
    if(TCPIP_STACK_NetworkIsLinked(pNetIf) || !_TCPIPStackNetIsPrimary(pNetIf))
   17dec:	4630      	mov	r0, r6
   17dee:	f008 ff2b 	bl	20c48 <TCPIP_STACK_NetworkIsLinked>
    pClient->smState = newState;
   17df2:	f8a4 0056 	strh.w	r0, [r4, #86]	; 0x56
    pClient->flags.bDHCPEnabled = true;
   17df6:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
   17dfa:	f043 0301 	orr.w	r3, r3, #1
   17dfe:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    pClient->dhcpOp = opType;
   17e02:	f8a4 5054 	strh.w	r5, [r4, #84]	; 0x54
    pNetIf->Flags.bIsDHCPEnabled = true;
   17e06:	f896 3042 	ldrb.w	r3, [r6, #66]	; 0x42
   17e0a:	f043 0301 	orr.w	r3, r3, #1
   17e0e:	f886 3042 	strb.w	r3, [r6, #66]	; 0x42
    if(pClient->dhcpFilterHandle == 0)
   17e12:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   17e14:	b123      	cbz	r3, 17e20 <_DHCPEnable+0x48>
    if(opType == TCPIP_DHCP_OPER_INIT || opType == TCPIP_DHCP_OPER_INIT_REBOOT)
   17e16:	3d01      	subs	r5, #1
   17e18:	b2ed      	uxtb	r5, r5
   17e1a:	2d01      	cmp	r5, #1
   17e1c:	d911      	bls.n	17e42 <_DHCPEnable+0x6a>
}
   17e1e:	bd70      	pop	{r4, r5, r6, pc}
        pClient->dhcpFilterHandle = IPv4RegisterFilter(_DHCPPacketFilter, true);
   17e20:	2101      	movs	r1, #1
   17e22:	4810      	ldr	r0, [pc, #64]	; (17e64 <_DHCPEnable+0x8c>)
   17e24:	f003 ffe4 	bl	1bdf0 <IPv4RegisterFilter>
   17e28:	64a0      	str	r0, [r4, #72]	; 0x48
        if(pClient->dhcpFilterHandle == 0)
   17e2a:	2800      	cmp	r0, #0
   17e2c:	d1f3      	bne.n	17e16 <_DHCPEnable+0x3e>
            SYS_ERROR(SYS_ERROR_WARNING, "DHCP: Failed to register IPv4 filter! \r\n");
   17e2e:	f00a f88d 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
   17e32:	2801      	cmp	r0, #1
   17e34:	d9ef      	bls.n	17e16 <_DHCPEnable+0x3e>
   17e36:	f00a f883 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
   17e3a:	490b      	ldr	r1, [pc, #44]	; (17e68 <_DHCPEnable+0x90>)
   17e3c:	f002 fc96 	bl	1a76c <SYS_CONSOLE_Print>
   17e40:	e7e9      	b.n	17e16 <_DHCPEnable+0x3e>
        pClient->dhcpTmo = pClient->dhcpTmoBase;
   17e42:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
   17e46:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    pClient->flags.bReportFail = 1;
   17e4a:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
   17e4e:	f043 0320 	orr.w	r3, r3, #32
   17e52:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    return dhcpSecondCount;
   17e56:	4b05      	ldr	r3, [pc, #20]	; (17e6c <_DHCPEnable+0x94>)
        pClient->tOpStart = _DHCPSecondCountGet();
   17e58:	681b      	ldr	r3, [r3, #0]
   17e5a:	6223      	str	r3, [r4, #32]
}
   17e5c:	e7df      	b.n	17e1e <_DHCPEnable+0x46>
   17e5e:	bf00      	nop
   17e60:	2000e610 	.word	0x2000e610
   17e64:	000188a5 	.word	0x000188a5
   17e68:	0001e8f4 	.word	0x0001e8f4
   17e6c:	2000e620 	.word	0x2000e620

Disassembly of section .text.TCPIP_DHCP_Request%383:

00017e70 <TCPIP_DHCP_Request>:
   17e70:	b1a8      	cbz	r0, 17e9e <TCPIP_DHCP_Request+0x2e>
{
   17e72:	b570      	push	{r4, r5, r6, lr}
   17e74:	b082      	sub	sp, #8
   17e76:	4604      	mov	r4, r0
   17e78:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   17e7c:	f012 0f40 	tst.w	r2, #64	; 0x40
   17e80:	d114      	bne.n	17eac <TCPIP_DHCP_Request+0x3c>
        return false;
   17e82:	2300      	movs	r3, #0
}
   17e84:	4618      	mov	r0, r3
   17e86:	b002      	add	sp, #8
   17e88:	bd70      	pop	{r4, r5, r6, pc}
                       return false;
   17e8a:	2300      	movs	r3, #0
   17e8c:	e7fa      	b.n	17e84 <TCPIP_DHCP_Request+0x14>
                else if(!TCPIP_STACK_AddressServiceCanStart(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_DHCPC))
   17e8e:	2101      	movs	r1, #1
   17e90:	4620      	mov	r0, r4
   17e92:	f009 fc1c 	bl	216ce <TCPIP_STACK_AddressServiceCanStart>
   17e96:	4603      	mov	r3, r0
   17e98:	2800      	cmp	r0, #0
   17e9a:	d0f3      	beq.n	17e84 <TCPIP_DHCP_Request+0x14>
   17e9c:	e02b      	b.n	17ef6 <TCPIP_DHCP_Request+0x86>
        return false;
   17e9e:	2300      	movs	r3, #0
}
   17ea0:	4618      	mov	r0, r3
   17ea2:	4770      	bx	lr
    return false;
   17ea4:	2300      	movs	r3, #0
   17ea6:	e7ed      	b.n	17e84 <TCPIP_DHCP_Request+0x14>
        return false;
   17ea8:	2300      	movs	r3, #0
    return _DHCPStartOperation(_TCPIPStackHandleToNetUp(hNet), TCPIP_DHCP_OP_REQ_REQUEST, reqAddress.Val);
   17eaa:	e7eb      	b.n	17e84 <TCPIP_DHCP_Request+0x14>
    if(DHCPClients == 0 || pNetIf == 0)
   17eac:	4a15      	ldr	r2, [pc, #84]	; (17f04 <TCPIP_DHCP_Request+0x94>)
   17eae:	6816      	ldr	r6, [r2, #0]
   17eb0:	2e00      	cmp	r6, #0
   17eb2:	d0f9      	beq.n	17ea8 <TCPIP_DHCP_Request+0x38>
   17eb4:	460d      	mov	r5, r1
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   17eb6:	4620      	mov	r0, r4
   17eb8:	f009 feac 	bl	21c14 <TCPIP_STACK_NetIxGet>
            if(reqAddress != 0)
   17ebc:	2d00      	cmp	r5, #0
   17ebe:	d0f1      	beq.n	17ea4 <TCPIP_DHCP_Request+0x34>
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   17ec0:	235c      	movs	r3, #92	; 0x5c
   17ec2:	fb03 6600 	mla	r6, r3, r0, r6
                if(pClient->flags.bDHCPEnabled != 0)
   17ec6:	f896 3058 	ldrb.w	r3, [r6, #88]	; 0x58
   17eca:	f013 0f01 	tst.w	r3, #1
   17ece:	d0de      	beq.n	17e8e <TCPIP_DHCP_Request+0x1e>
                    if(pClient->smState == TCPIP_DHCP_GET_REQUEST_ACK || 
   17ed0:	f8b6 3056 	ldrh.w	r3, [r6, #86]	; 0x56
   17ed4:	2b0c      	cmp	r3, #12
   17ed6:	d806      	bhi.n	17ee6 <TCPIP_DHCP_Request+0x76>
   17ed8:	f44f 52a1 	mov.w	r2, #5152	; 0x1420
   17edc:	fa22 f303 	lsr.w	r3, r2, r3
   17ee0:	f013 0f01 	tst.w	r3, #1
   17ee4:	d1d1      	bne.n	17e8a <TCPIP_DHCP_Request+0x1a>
                    IPV4_ADDR zeroAdd = {0};
   17ee6:	2300      	movs	r3, #0
   17ee8:	9301      	str	r3, [sp, #4]
                    _TCPIPStackSetConfigAddress(pNetIf, &zeroAdd, &zeroAdd, true);
   17eea:	2301      	movs	r3, #1
   17eec:	aa01      	add	r2, sp, #4
   17eee:	4611      	mov	r1, r2
   17ef0:	4620      	mov	r0, r4
   17ef2:	f006 fc48 	bl	1e786 <_TCPIPStackSetConfigAddress>
                pClient->dhcpIPAddress.Val = reqAddress;
   17ef6:	62f5      	str	r5, [r6, #44]	; 0x2c
        _DHCPEnable(pNetIf, opType);
   17ef8:	2102      	movs	r1, #2
   17efa:	4620      	mov	r0, r4
   17efc:	f7ff ff6c 	bl	17dd8 <_DHCPEnable>
        return true;
   17f00:	2301      	movs	r3, #1
   17f02:	e7bf      	b.n	17e84 <TCPIP_DHCP_Request+0x14>
   17f04:	2000e610 	.word	0x2000e610

Disassembly of section .text.TCPIP_DHCP_InfoGet%384:

00017f08 <TCPIP_DHCP_InfoGet>:
{
   17f08:	b570      	push	{r4, r5, r6, lr}
   17f0a:	4604      	mov	r4, r0
    if(pDhcpInfo)
   17f0c:	460e      	mov	r6, r1
   17f0e:	b121      	cbz	r1, 17f1a <TCPIP_DHCP_InfoGet+0x12>
        memset(pDhcpInfo, 0, sizeof(*pDhcpInfo));
   17f10:	2234      	movs	r2, #52	; 0x34
   17f12:	2100      	movs	r1, #0
   17f14:	4630      	mov	r0, r6
   17f16:	f009 fe31 	bl	21b7c <memset>
   17f1a:	b30c      	cbz	r4, 17f60 <TCPIP_DHCP_InfoGet+0x58>
   17f1c:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   17f20:	f013 0f40 	tst.w	r3, #64	; 0x40
   17f24:	d122      	bne.n	17f6c <TCPIP_DHCP_InfoGet+0x64>
    return false;
   17f26:	2000      	movs	r0, #0
}
   17f28:	bd70      	pop	{r4, r5, r6, pc}
            if(pDhcpInfo)
   17f2a:	b1ee      	cbz	r6, 17f68 <TCPIP_DHCP_InfoGet+0x60>
                pDhcpInfo->status = pClient->smState;
   17f2c:	7033      	strb	r3, [r6, #0]
    return dhcpSecondCount;
   17f2e:	4b1a      	ldr	r3, [pc, #104]	; (17f98 <TCPIP_DHCP_InfoGet+0x90>)
                pDhcpInfo->dhcpTime = _DHCPSecondCountGet();
   17f30:	681b      	ldr	r3, [r3, #0]
   17f32:	6073      	str	r3, [r6, #4]
                pDhcpInfo->leaseStartTime = pClient->tRequest;
   17f34:	6883      	ldr	r3, [r0, #8]
   17f36:	60b3      	str	r3, [r6, #8]
                pDhcpInfo->leaseDuration = pClient->tExpSeconds;
   17f38:	6983      	ldr	r3, [r0, #24]
   17f3a:	60f3      	str	r3, [r6, #12]
                pDhcpInfo->renewTime = pClient->tRequest + pClient->t1Seconds;
   17f3c:	6883      	ldr	r3, [r0, #8]
   17f3e:	6902      	ldr	r2, [r0, #16]
   17f40:	4413      	add	r3, r2
   17f42:	6133      	str	r3, [r6, #16]
                pDhcpInfo->rebindTime = pClient->tRequest + pClient->t2Seconds;
   17f44:	6883      	ldr	r3, [r0, #8]
   17f46:	6942      	ldr	r2, [r0, #20]
   17f48:	4413      	add	r3, r2
   17f4a:	6173      	str	r3, [r6, #20]
                pDhcpInfo->dhcpAddress.Val = pClient->dhcpIPAddress.Val;
   17f4c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   17f4e:	61b3      	str	r3, [r6, #24]
                pDhcpInfo->subnetMask.Val = pClient->dhcpMask.Val;
   17f50:	6b43      	ldr	r3, [r0, #52]	; 0x34
   17f52:	61f3      	str	r3, [r6, #28]
                pDhcpInfo->serverAddress.Val = pClient->serverAddress.Val;
   17f54:	6a83      	ldr	r3, [r0, #40]	; 0x28
   17f56:	6233      	str	r3, [r6, #32]
                pDhcpInfo->bootFileName = 0;
   17f58:	2300      	movs	r3, #0
   17f5a:	6273      	str	r3, [r6, #36]	; 0x24
            return true;
   17f5c:	2001      	movs	r0, #1
   17f5e:	e7e3      	b.n	17f28 <TCPIP_DHCP_InfoGet+0x20>
    return false;
   17f60:	2000      	movs	r0, #0
   17f62:	e7e1      	b.n	17f28 <TCPIP_DHCP_InfoGet+0x20>
   17f64:	2000      	movs	r0, #0
   17f66:	e7df      	b.n	17f28 <TCPIP_DHCP_InfoGet+0x20>
            return true;
   17f68:	2001      	movs	r0, #1
   17f6a:	e7dd      	b.n	17f28 <TCPIP_DHCP_InfoGet+0x20>
    if(DHCPClients && pNetIf)
   17f6c:	4b0b      	ldr	r3, [pc, #44]	; (17f9c <TCPIP_DHCP_InfoGet+0x94>)
   17f6e:	681d      	ldr	r5, [r3, #0]
   17f70:	b185      	cbz	r5, 17f94 <TCPIP_DHCP_InfoGet+0x8c>
        DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   17f72:	4620      	mov	r0, r4
   17f74:	f009 fe4e 	bl	21c14 <TCPIP_STACK_NetIxGet>
   17f78:	235c      	movs	r3, #92	; 0x5c
   17f7a:	fb03 5000 	mla	r0, r3, r0, r5
        if(pClient->flags.bDHCPEnabled == true && pClient->smState >= TCPIP_DHCP_BOUND)
   17f7e:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   17f82:	f013 0f01 	tst.w	r3, #1
   17f86:	d0ed      	beq.n	17f64 <TCPIP_DHCP_InfoGet+0x5c>
   17f88:	f8b0 3056 	ldrh.w	r3, [r0, #86]	; 0x56
   17f8c:	2b07      	cmp	r3, #7
   17f8e:	d8cc      	bhi.n	17f2a <TCPIP_DHCP_InfoGet+0x22>
    return false;
   17f90:	2000      	movs	r0, #0
   17f92:	e7c9      	b.n	17f28 <TCPIP_DHCP_InfoGet+0x20>
   17f94:	2000      	movs	r0, #0
   17f96:	e7c7      	b.n	17f28 <TCPIP_DHCP_InfoGet+0x20>
   17f98:	2000e620 	.word	0x2000e620
   17f9c:	2000e610 	.word	0x2000e610

Disassembly of section .text.DisplayNodeMsg%385:

00017fa0 <DisplayNodeMsg>:
{
   17fa0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17fa4:	b083      	sub	sp, #12
   17fa6:	4680      	mov	r8, r0
   17fa8:	468b      	mov	fp, r1
    if((nCmdLen = strlen(pNext->cmdBuff)))
   17faa:	f101 0308 	add.w	r3, r1, #8
   17fae:	9301      	str	r3, [sp, #4]
   17fb0:	4618      	mov	r0, r3
   17fb2:	f009 fdf3 	bl	21b9c <strlen>
   17fb6:	2800      	cmp	r0, #0
   17fb8:	d034      	beq.n	18024 <DisplayNodeMsg+0x84>
   17fba:	4681      	mov	r9, r0
   17fbc:	4605      	mov	r5, r0
    const SYS_CMD_API* pCmdApi = pCmdIO->devNode.pCmdApi;
   17fbe:	f8d8 7000 	ldr.w	r7, [r8]
    const void* cmdIoParam = pCmdIO->devNode.cmdIoParam;
   17fc2:	f8d8 6004 	ldr.w	r6, [r8, #4]
        oCmdLen = pCmdIO->cmdEnd - pCmdIO->cmdBuff;
   17fc6:	f108 0a20 	add.w	sl, r8, #32
   17fca:	f8d8 401c 	ldr.w	r4, [r8, #28]
   17fce:	eba4 040a 	sub.w	r4, r4, sl
        while(oCmdLen > nCmdLen)
   17fd2:	42a0      	cmp	r0, r4
   17fd4:	da07      	bge.n	17fe6 <DisplayNodeMsg+0x46>
            (*pCmdApi->msg)(cmdIoParam, "\b \b");     // clear the old command
   17fd6:	683b      	ldr	r3, [r7, #0]
   17fd8:	4914      	ldr	r1, [pc, #80]	; (1802c <DisplayNodeMsg+0x8c>)
   17fda:	4630      	mov	r0, r6
   17fdc:	4798      	blx	r3
            oCmdLen--;
   17fde:	3c01      	subs	r4, #1
        while(oCmdLen > nCmdLen)
   17fe0:	42a5      	cmp	r5, r4
   17fe2:	d1f8      	bne.n	17fd6 <DisplayNodeMsg+0x36>
   17fe4:	464c      	mov	r4, r9
        while(oCmdLen--)
   17fe6:	1e65      	subs	r5, r4, #1
   17fe8:	b144      	cbz	r4, 17ffc <DisplayNodeMsg+0x5c>
            (*pCmdApi->msg)(cmdIoParam, "\b");
   17fea:	4c11      	ldr	r4, [pc, #68]	; (18030 <DisplayNodeMsg+0x90>)
   17fec:	683b      	ldr	r3, [r7, #0]
   17fee:	4621      	mov	r1, r4
   17ff0:	4630      	mov	r0, r6
   17ff2:	4798      	blx	r3
        while(oCmdLen--)
   17ff4:	3d01      	subs	r5, #1
   17ff6:	f1b5 3fff 	cmp.w	r5, #4294967295
   17ffa:	d1f7      	bne.n	17fec <DisplayNodeMsg+0x4c>
        strcpy(pCmdIO->cmdBuff, pNext->cmdBuff);
   17ffc:	9901      	ldr	r1, [sp, #4]
   17ffe:	4650      	mov	r0, sl
   18000:	f009 fdc4 	bl	21b8c <strcpy>
        (*pCmdApi->msg)(cmdIoParam, "\r\n>");
   18004:	683b      	ldr	r3, [r7, #0]
   18006:	490b      	ldr	r1, [pc, #44]	; (18034 <DisplayNodeMsg+0x94>)
   18008:	4630      	mov	r0, r6
   1800a:	4798      	blx	r3
        (*pCmdApi->msg)(cmdIoParam, pCmdIO->cmdBuff);
   1800c:	683b      	ldr	r3, [r7, #0]
   1800e:	4651      	mov	r1, sl
   18010:	4630      	mov	r0, r6
   18012:	4798      	blx	r3
        pCmdIO->cmdPnt = pCmdIO->cmdEnd = pCmdIO->cmdBuff + nCmdLen;
   18014:	eb0a 0309 	add.w	r3, sl, r9
   18018:	f8c8 301c 	str.w	r3, [r8, #28]
   1801c:	f8c8 3018 	str.w	r3, [r8, #24]
        pCmdIO->currHistN = pNext;
   18020:	f8c8 b0d4 	str.w	fp, [r8, #212]	; 0xd4
}
   18024:	b003      	add	sp, #12
   18026:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1802a:	bf00      	nop
   1802c:	0000d118 	.word	0x0000d118
   18030:	0000d11c 	.word	0x0000d11c
   18034:	0000d120 	.word	0x0000d120

Disassembly of section .text.prvAddCurrentTaskToDelayedList%386:

00018038 <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
   18038:	b570      	push	{r4, r5, r6, lr}
   1803a:	4604      	mov	r4, r0
   1803c:	460e      	mov	r6, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
   1803e:	4b1d      	ldr	r3, [pc, #116]	; (180b4 <prvAddCurrentTaskToDelayedList+0x7c>)
   18040:	681d      	ldr	r5, [r3, #0]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   18042:	4b1d      	ldr	r3, [pc, #116]	; (180b8 <prvAddCurrentTaskToDelayedList+0x80>)
   18044:	6818      	ldr	r0, [r3, #0]
   18046:	3004      	adds	r0, #4
   18048:	f008 fa34 	bl	204b4 <uxListRemove>
   1804c:	b948      	cbnz	r0, 18062 <prvAddCurrentTaskToDelayedList+0x2a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
   1804e:	4b1a      	ldr	r3, [pc, #104]	; (180b8 <prvAddCurrentTaskToDelayedList+0x80>)
   18050:	681a      	ldr	r2, [r3, #0]
   18052:	491a      	ldr	r1, [pc, #104]	; (180bc <prvAddCurrentTaskToDelayedList+0x84>)
   18054:	680b      	ldr	r3, [r1, #0]
   18056:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
   18058:	2201      	movs	r2, #1
   1805a:	4082      	lsls	r2, r0
   1805c:	ea23 0302 	bic.w	r3, r3, r2
   18060:	600b      	str	r3, [r1, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   18062:	f1b4 3fff 	cmp.w	r4, #4294967295
   18066:	d00d      	beq.n	18084 <prvAddCurrentTaskToDelayedList+0x4c>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
   18068:	442c      	add	r4, r5

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   1806a:	4b13      	ldr	r3, [pc, #76]	; (180b8 <prvAddCurrentTaskToDelayedList+0x80>)
   1806c:	681b      	ldr	r3, [r3, #0]
   1806e:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
   18070:	42a5      	cmp	r5, r4
   18072:	d910      	bls.n	18096 <prvAddCurrentTaskToDelayedList+0x5e>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   18074:	4b12      	ldr	r3, [pc, #72]	; (180c0 <prvAddCurrentTaskToDelayedList+0x88>)
   18076:	6818      	ldr	r0, [r3, #0]
   18078:	4b0f      	ldr	r3, [pc, #60]	; (180b8 <prvAddCurrentTaskToDelayedList+0x80>)
   1807a:	6819      	ldr	r1, [r3, #0]
   1807c:	3104      	adds	r1, #4
   1807e:	f006 fd8b 	bl	1eb98 <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   18082:	bd70      	pop	{r4, r5, r6, pc}
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   18084:	2e00      	cmp	r6, #0
   18086:	d0ef      	beq.n	18068 <prvAddCurrentTaskToDelayedList+0x30>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
   18088:	4b0b      	ldr	r3, [pc, #44]	; (180b8 <prvAddCurrentTaskToDelayedList+0x80>)
   1808a:	6819      	ldr	r1, [r3, #0]
   1808c:	3104      	adds	r1, #4
   1808e:	480d      	ldr	r0, [pc, #52]	; (180c4 <prvAddCurrentTaskToDelayedList+0x8c>)
   18090:	f009 fb49 	bl	21726 <vListInsertEnd>
   18094:	e7f5      	b.n	18082 <prvAddCurrentTaskToDelayedList+0x4a>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   18096:	4b0c      	ldr	r3, [pc, #48]	; (180c8 <prvAddCurrentTaskToDelayedList+0x90>)
   18098:	6818      	ldr	r0, [r3, #0]
   1809a:	4b07      	ldr	r3, [pc, #28]	; (180b8 <prvAddCurrentTaskToDelayedList+0x80>)
   1809c:	6819      	ldr	r1, [r3, #0]
   1809e:	3104      	adds	r1, #4
   180a0:	f006 fd7a 	bl	1eb98 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
   180a4:	4b09      	ldr	r3, [pc, #36]	; (180cc <prvAddCurrentTaskToDelayedList+0x94>)
   180a6:	681b      	ldr	r3, [r3, #0]
   180a8:	42a3      	cmp	r3, r4
					xNextTaskUnblockTime = xTimeToWake;
   180aa:	bf84      	itt	hi
   180ac:	4b07      	ldrhi	r3, [pc, #28]	; (180cc <prvAddCurrentTaskToDelayedList+0x94>)
   180ae:	601c      	strhi	r4, [r3, #0]
}
   180b0:	e7e7      	b.n	18082 <prvAddCurrentTaskToDelayedList+0x4a>
   180b2:	bf00      	nop
   180b4:	2000e6d8 	.word	0x2000e6d8
   180b8:	2000e6a4 	.word	0x2000e6a4
   180bc:	2000e6c0 	.word	0x2000e6c0
   180c0:	2000e6ac 	.word	0x2000e6ac
   180c4:	2000e4c8 	.word	0x2000e4c8
   180c8:	2000e6a8 	.word	0x2000e6a8
   180cc:	2000e6c8 	.word	0x2000e6c8

Disassembly of section .text.DRV_PIC32CGMAC_LibInitTransfer%387:

000180d0 <DRV_PIC32CGMAC_LibInitTransfer>:
	uint16_t wRxDescCnt_temp = pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxDescCnt;
   180d0:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
   180d4:	eb00 0343 	add.w	r3, r0, r3, lsl #1
	if (wRxDescCnt_temp < 1 || wTxDescCnt_temp < 1)
   180d8:	f8b3 30be 	ldrh.w	r3, [r3, #190]	; 0xbe
   180dc:	2b00      	cmp	r3, #0
   180de:	d036      	beq.n	1814e <DRV_PIC32CGMAC_LibInitTransfer+0x7e>
	uint16_t wTxDescCnt_temp = pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt;
   180e0:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
   180e4:	eb00 0343 	add.w	r3, r0, r3, lsl #1
	if (wRxDescCnt_temp < 1 || wTxDescCnt_temp < 1)
   180e8:	f8b3 30c8 	ldrh.w	r3, [r3, #200]	; 0xc8
   180ec:	b38b      	cbz	r3, 18152 <DRV_PIC32CGMAC_LibInitTransfer+0x82>
	uint16_t wRxBufferSize_temp = pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].rxBufferSize;
   180ee:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
   180f2:	eb00 0343 	add.w	r3, r0, r3, lsl #1
   180f6:	f8b3 30cc 	ldrh.w	r3, [r3, #204]	; 0xcc
	if (wRxBufferSize_temp < DRV_GMAC_MIN_RX_SIZE)
   180fa:	2b3f      	cmp	r3, #63	; 0x3f
   180fc:	d92b      	bls.n	18156 <DRV_PIC32CGMAC_LibInitTransfer+0x86>
    if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].queueRxEnable == true)
   180fe:	eb01 02c1 	add.w	r2, r1, r1, lsl #3
   18102:	eb00 0242 	add.w	r2, r0, r2, lsl #1
   18106:	f892 20cf 	ldrb.w	r2, [r2, #207]	; 0xcf
        queIntEnable = GMAC_INT_RX_BITS;
   1810a:	2a01      	cmp	r2, #1
   1810c:	f240 4206 	movw	r2, #1030	; 0x406
   18110:	bf18      	it	ne
   18112:	2200      	movne	r2, #0
    if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].queueTxEnable == true)
   18114:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
   18118:	eb00 0141 	add.w	r1, r0, r1, lsl #1
   1811c:	f891 10ce 	ldrb.w	r1, [r1, #206]	; 0xce
   18120:	2901      	cmp	r1, #1
        queIntEnable |= GMAC_INT_TX_BITS;
   18122:	bf08      	it	eq
   18124:	f442 6207 	orreq.w	r2, r2, #2160	; 0x870
	GMAC_REGS->GMAC_DCFGR = GMAC_DCFGR_DRBS((wRxBufferSize_temp >> 6)) | GMAC_DCFGR_RXBMS(3) | GMAC_DCFGR_TXPBMS(1) | GMAC_DCFGR_FBLDO(4) | GMAC_DCFGR_DDRP(1);
   18128:	029b      	lsls	r3, r3, #10
   1812a:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
   1812e:	490b      	ldr	r1, [pc, #44]	; (1815c <DRV_PIC32CGMAC_LibInitTransfer+0x8c>)
   18130:	4319      	orrs	r1, r3
   18132:	4b0b      	ldr	r3, [pc, #44]	; (18160 <DRV_PIC32CGMAC_LibInitTransfer+0x90>)
   18134:	6119      	str	r1, [r3, #16]
	if((pMACDrv->sGmacData.gmacConfig.checksumOffloadTx) != TCPIP_MAC_CHECKSUM_NONE)
   18136:	f890 30e1 	ldrb.w	r3, [r0, #225]	; 0xe1
   1813a:	b123      	cbz	r3, 18146 <DRV_PIC32CGMAC_LibInitTransfer+0x76>
        GMAC_REGS->GMAC_DCFGR |= GMAC_DCFGR_TXCOEN_Msk;
   1813c:	4908      	ldr	r1, [pc, #32]	; (18160 <DRV_PIC32CGMAC_LibInitTransfer+0x90>)
   1813e:	690b      	ldr	r3, [r1, #16]
   18140:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   18144:	610b      	str	r3, [r1, #16]
	GMAC_REGS->GMAC_IER = queIntEnable;
   18146:	4b06      	ldr	r3, [pc, #24]	; (18160 <DRV_PIC32CGMAC_LibInitTransfer+0x90>)
   18148:	629a      	str	r2, [r3, #40]	; 0x28
	return DRV_PIC32CGMAC_RES_OK;
   1814a:	2000      	movs	r0, #0
   1814c:	4770      	bx	lr
        return DRV_PIC32CGMAC_RES_DESC_CNT_ERR;
   1814e:	2006      	movs	r0, #6
   18150:	4770      	bx	lr
   18152:	2006      	movs	r0, #6
   18154:	4770      	bx	lr
        return DRV_PIC32CGMAC_RES_RX_SIZE_ERR;
   18156:	f06f 0002 	mvn.w	r0, #2
}
   1815a:	4770      	bx	lr
   1815c:	01000704 	.word	0x01000704
   18160:	42000800 	.word	0x42000800

Disassembly of section .text.TCPIP_ARP_IsResolved%388:

00018164 <TCPIP_ARP_IsResolved>:
    if(IPAddr == 0 || IPAddr->Val == 0)
   18164:	2900      	cmp	r1, #0
   18166:	d03c      	beq.n	181e2 <TCPIP_ARP_IsResolved+0x7e>
{
   18168:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1816a:	460c      	mov	r4, r1
    if(IPAddr == 0 || IPAddr->Val == 0)
   1816c:	6809      	ldr	r1, [r1, #0]
   1816e:	2900      	cmp	r1, #0
   18170:	d039      	beq.n	181e6 <TCPIP_ARP_IsResolved+0x82>
   18172:	2800      	cmp	r0, #0
   18174:	d039      	beq.n	181ea <TCPIP_ARP_IsResolved+0x86>
   18176:	f890 1042 	ldrb.w	r1, [r0, #66]	; 0x42
   1817a:	f011 0f40 	tst.w	r1, #64	; 0x40
   1817e:	d101      	bne.n	18184 <TCPIP_ARP_IsResolved+0x20>
        return false;
   18180:	2000      	movs	r0, #0
   18182:	e031      	b.n	181e8 <TCPIP_ARP_IsResolved+0x84>
   18184:	4615      	mov	r5, r2
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   18186:	4b1b      	ldr	r3, [pc, #108]	; (181f4 <TCPIP_ARP_IsResolved+0x90>)
   18188:	685e      	ldr	r6, [r3, #4]
   1818a:	f009 fd43 	bl	21c14 <TCPIP_STACK_NetIxGet>
   1818e:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   18192:	00c0      	lsls	r0, r0, #3
   18194:	1837      	adds	r7, r6, r0
    hE = TCPIP_OAHASH_EntryLookup(pArpDcpt->hashDcpt, &IPAddr->Val);
   18196:	4621      	mov	r1, r4
   18198:	5830      	ldr	r0, [r6, r0]
   1819a:	f002 fc5b 	bl	1aa54 <TCPIP_OAHASH_EntryLookup>
    if(hE != 0 && (hE->flags.value & ARP_FLAG_ENTRY_VALID_MASK) != 0 )
   1819e:	4604      	mov	r4, r0
   181a0:	b328      	cbz	r0, 181ee <TCPIP_ARP_IsResolved+0x8a>
   181a2:	8803      	ldrh	r3, [r0, #0]
   181a4:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   181a8:	b90b      	cbnz	r3, 181ae <TCPIP_ARP_IsResolved+0x4a>
    return false;
   181aa:	2000      	movs	r0, #0
   181ac:	e01c      	b.n	181e8 <TCPIP_ARP_IsResolved+0x84>
        if(MACAddr)
   181ae:	b11d      	cbz	r5, 181b8 <TCPIP_ARP_IsResolved+0x54>
            *MACAddr = arpHE->hwAdd;
   181b0:	6900      	ldr	r0, [r0, #16]
   181b2:	6028      	str	r0, [r5, #0]
   181b4:	8aa3      	ldrh	r3, [r4, #20]
   181b6:	80ab      	strh	r3, [r5, #4]
        if((hE->flags.value & ARP_FLAG_ENTRY_COMPLETE) != 0 )
   181b8:	8823      	ldrh	r3, [r4, #0]
   181ba:	f013 0f80 	tst.w	r3, #128	; 0x80
   181be:	d101      	bne.n	181c4 <TCPIP_ARP_IsResolved+0x60>
        return true;
   181c0:	2001      	movs	r0, #1
   181c2:	e011      	b.n	181e8 <TCPIP_ARP_IsResolved+0x84>
            _ARPRefreshEntry(arpHE, &pArpDcpt->completeList);
   181c4:	3718      	adds	r7, #24
    TCPIP_Helper_ProtectedSingleListNodeRemove(pL, (SGL_LIST_NODE*)&arpHE->next);
   181c6:	1d25      	adds	r5, r4, #4
   181c8:	4629      	mov	r1, r5
   181ca:	4638      	mov	r0, r7
   181cc:	f006 ff82 	bl	1f0d4 <TCPIP_Helper_ProtectedSingleListNodeRemove>
    arpHE->tInsert = arpMod.timeSeconds;
   181d0:	4b08      	ldr	r3, [pc, #32]	; (181f4 <TCPIP_ARP_IsResolved+0x90>)
   181d2:	695b      	ldr	r3, [r3, #20]
   181d4:	60e3      	str	r3, [r4, #12]
    TCPIP_Helper_ProtectedSingleListTailAdd(pL, (SGL_LIST_NODE*)&arpHE->next);
   181d6:	4629      	mov	r1, r5
   181d8:	4638      	mov	r0, r7
   181da:	f007 fc8c 	bl	1faf6 <TCPIP_Helper_ProtectedSingleListTailAdd>
        return true;
   181de:	2001      	movs	r0, #1
   181e0:	e002      	b.n	181e8 <TCPIP_ARP_IsResolved+0x84>
        return false;
   181e2:	2000      	movs	r0, #0
}
   181e4:	4770      	bx	lr
        return false;
   181e6:	2000      	movs	r0, #0
}
   181e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return false;
   181ea:	2000      	movs	r0, #0
   181ec:	e7fc      	b.n	181e8 <TCPIP_ARP_IsResolved+0x84>
    return false;
   181ee:	2000      	movs	r0, #0
   181f0:	e7fa      	b.n	181e8 <TCPIP_ARP_IsResolved+0x84>
   181f2:	bf00      	nop
   181f4:	2000e1a4 	.word	0x2000e1a4

Disassembly of section .text.ascii_to_u32s%389:

000181f8 <ascii_to_u32s>:
    if(ptr == 0)
   181f8:	b1f8      	cbz	r0, 1823a <ascii_to_u32s+0x42>
{
   181fa:	b4f0      	push	{r4, r5, r6, r7}
   181fc:	4604      	mov	r4, r0
    for (i = 0; i < count; i++)
   181fe:	b1d2      	cbz	r2, 18236 <ascii_to_u32s+0x3e>
   18200:	1f0d      	subs	r5, r1, #4
   18202:	3a01      	subs	r2, #1
   18204:	b2d2      	uxtb	r2, r2
   18206:	eb01 0182 	add.w	r1, r1, r2, lsl #2
            tmp = tmp * 1000 * 1000;
   1820a:	4f1f      	ldr	r7, [pc, #124]	; (18288 <ascii_to_u32s+0x90>)
            tmp = tmp * 1000;
   1820c:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
        while ( (*ptr > (int8_t)'9') || (*ptr < (int8_t)'0') )
   18210:	7822      	ldrb	r2, [r4, #0]
   18212:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
   18216:	b2db      	uxtb	r3, r3
   18218:	2b09      	cmp	r3, #9
   1821a:	d931      	bls.n	18280 <ascii_to_u32s+0x88>
            if ( (*ptr == (int8_t)' ') || (*ptr == (int8_t)0) ) return; // terminates at blank or NULL.
   1821c:	f012 0fdf 	tst.w	r2, #223	; 0xdf
   18220:	d009      	beq.n	18236 <ascii_to_u32s+0x3e>
        while ( (*ptr > (int8_t)'9') || (*ptr < (int8_t)'0') )
   18222:	f814 2f01 	ldrb.w	r2, [r4, #1]!
   18226:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
   1822a:	b2db      	uxtb	r3, r3
   1822c:	2b09      	cmp	r3, #9
   1822e:	d927      	bls.n	18280 <ascii_to_u32s+0x88>
            if ( (*ptr == (int8_t)' ') || (*ptr == (int8_t)0) ) return; // terminates at blank or NULL.
   18230:	f012 0fdf 	tst.w	r2, #223	; 0xdf
   18234:	d1f5      	bne.n	18222 <ascii_to_u32s+0x2a>
}
   18236:	bcf0      	pop	{r4, r5, r6, r7}
   18238:	4770      	bx	lr
        *values = 0;
   1823a:	2300      	movs	r3, #0
   1823c:	600b      	str	r3, [r1, #0]
        return;
   1823e:	4770      	bx	lr
            ptr++;
   18240:	4664      	mov	r4, ip
            tmp = tmp*10 + *ptr - '0';
   18242:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   18246:	eb02 0343 	add.w	r3, r2, r3, lsl #1
   1824a:	3b30      	subs	r3, #48	; 0x30
            ptr++;
   1824c:	f104 0c01 	add.w	ip, r4, #1
        while ( (*ptr <= (int8_t)'9') && (*ptr >= (int8_t)'0') )
   18250:	7862      	ldrb	r2, [r4, #1]
   18252:	f1a2 0030 	sub.w	r0, r2, #48	; 0x30
   18256:	b2c0      	uxtb	r0, r0
   18258:	2809      	cmp	r0, #9
   1825a:	d9f1      	bls.n	18240 <ascii_to_u32s+0x48>
        if ( (*ptr == (int8_t)'k') || (*ptr == (int8_t)'K') )
   1825c:	f002 02df 	and.w	r2, r2, #223	; 0xdf
   18260:	2a4b      	cmp	r2, #75	; 0x4b
   18262:	d005      	beq.n	18270 <ascii_to_u32s+0x78>
        else if ( (*ptr == (int8_t)'m') || (*ptr == (int8_t)'M') )
   18264:	2a4d      	cmp	r2, #77	; 0x4d
            tmp = tmp * 1000 * 1000;
   18266:	bf06      	itte	eq
   18268:	437b      	muleq	r3, r7
            ptr++;
   1826a:	3402      	addeq	r4, #2
            ptr++;
   1826c:	4664      	movne	r4, ip
   1826e:	e002      	b.n	18276 <ascii_to_u32s+0x7e>
            tmp = tmp * 1000;
   18270:	fb06 f303 	mul.w	r3, r6, r3
            ptr++;
   18274:	3402      	adds	r4, #2
        values[i] = tmp;
   18276:	f845 3f04 	str.w	r3, [r5, #4]!
    for (i = 0; i < count; i++)
   1827a:	428d      	cmp	r5, r1
   1827c:	d1c8      	bne.n	18210 <ascii_to_u32s+0x18>
   1827e:	e7da      	b.n	18236 <ascii_to_u32s+0x3e>
        while ( (*ptr <= (int8_t)'9') && (*ptr >= (int8_t)'0') )
   18280:	7822      	ldrb	r2, [r4, #0]
        tmp = 0;
   18282:	2300      	movs	r3, #0
   18284:	e7dd      	b.n	18242 <ascii_to_u32s+0x4a>
   18286:	bf00      	nop
   18288:	000f4240 	.word	0x000f4240

Disassembly of section .text.DRV_MIIM_OperationResult%390:

0001828c <DRV_MIIM_OperationResult>:
{
   1828c:	b570      	push	{r4, r5, r6, lr}
   1828e:	460c      	mov	r4, r1
   18290:	4616      	mov	r6, r2
        if((pClient = _DRV_MIIM_GetClientAndLock(handle, true)) == 0)
   18292:	2101      	movs	r1, #1
   18294:	f004 f959 	bl	1c54a <_DRV_MIIM_GetClientAndLock>
   18298:	b1f0      	cbz	r0, 182d8 <DRV_MIIM_OperationResult+0x4c>
   1829a:	4602      	mov	r2, r0
        pMiimObj = pClient->parentObj;
   1829c:	6845      	ldr	r5, [r0, #4]
    if(pOpDcpt != 0 && (pOpDcpt->qType == DRV_MIIM_QTYPE_BUSY || pOpDcpt->qType == DRV_MIIM_QTYPE_COMPLETE))
   1829e:	b1c4      	cbz	r4, 182d2 <DRV_MIIM_OperationResult+0x46>
   182a0:	7ae3      	ldrb	r3, [r4, #11]
   182a2:	3b02      	subs	r3, #2
   182a4:	b2db      	uxtb	r3, r3
   182a6:	2b01      	cmp	r3, #1
   182a8:	d919      	bls.n	182de <DRV_MIIM_OperationResult+0x52>
            miimRes = DRV_MIIM_RES_OP_HANDLE_ERR;
   182aa:	f06f 0601 	mvn.w	r6, #1
    if(pMiimObj != 0)
   182ae:	b115      	cbz	r5, 182b6 <DRV_MIIM_OperationResult+0x2a>
    OSAL_SEM_Post(&pMiimObj->objSem);
   182b0:	4628      	mov	r0, r5
   182b2:	f009 f8ff 	bl	214b4 <OSAL_SEM_Post>
}
   182b6:	4630      	mov	r0, r6
   182b8:	bd70      	pop	{r4, r5, r6, pc}
        if(scanAck && pOpDcpt->opStat == DRV_MIIM_TXFER_SCAN_VALID)
   182ba:	2b04      	cmp	r3, #4
   182bc:	d001      	beq.n	182c2 <DRV_MIIM_OperationResult+0x36>
        return DRV_MIIM_RES_OK;
   182be:	2600      	movs	r6, #0
   182c0:	e004      	b.n	182cc <DRV_MIIM_OperationResult+0x40>
            pOpDcpt->opStat = DRV_MIIM_TXFER_SCAN_STALE;
   182c2:	2303      	movs	r3, #3
   182c4:	72a3      	strb	r3, [r4, #10]
        return DRV_MIIM_RES_OK;
   182c6:	2600      	movs	r6, #0
   182c8:	e7f1      	b.n	182ae <DRV_MIIM_OperationResult+0x22>
        return DRV_MIIM_RES_PENDING;
   182ca:	2601      	movs	r6, #1
        if(pOpDcpt->opStat >= DRV_MIIM_TXFER_DONE)
   182cc:	2b04      	cmp	r3, #4
   182ce:	d9ee      	bls.n	182ae <DRV_MIIM_OperationResult+0x22>
   182d0:	e01c      	b.n	1830c <DRV_MIIM_OperationResult+0x80>
            miimRes = DRV_MIIM_RES_OP_HANDLE_ERR;
   182d2:	f06f 0601 	mvn.w	r6, #1
   182d6:	e7ea      	b.n	182ae <DRV_MIIM_OperationResult+0x22>
            miimRes = DRV_MIIM_RES_HANDLE_ERR;
   182d8:	f04f 36ff 	mov.w	r6, #4294967295
    return miimRes;
   182dc:	e7eb      	b.n	182b6 <DRV_MIIM_OperationResult+0x2a>
        if(pOpData != 0)
   182de:	b136      	cbz	r6, 182ee <DRV_MIIM_OperationResult+0x62>
            if(DRV_MIIM_TXFER_SCAN_STALE <= pOpDcpt->opStat &&  pOpDcpt->opStat <= DRV_MIIM_TXFER_DONE)
   182e0:	7aa3      	ldrb	r3, [r4, #10]
   182e2:	3b03      	subs	r3, #3
   182e4:	b2db      	uxtb	r3, r3
   182e6:	2b02      	cmp	r3, #2
                *pOpData = pOpDcpt->opData;
   182e8:	bf9c      	itt	ls
   182ea:	8923      	ldrhls	r3, [r4, #8]
   182ec:	8033      	strhls	r3, [r6, #0]
    if(DRV_MIIM_TXFER_START <= pOpDcpt->opStat &&  pOpDcpt->opStat < DRV_MIIM_TXFER_SCAN_VALID)
   182ee:	7aa3      	ldrb	r3, [r4, #10]
   182f0:	1e59      	subs	r1, r3, #1
   182f2:	b2c9      	uxtb	r1, r1
   182f4:	2902      	cmp	r1, #2
   182f6:	d9e8      	bls.n	182ca <DRV_MIIM_OperationResult+0x3e>
    else if(pOpDcpt->opStat <= DRV_MIIM_TXFER_DONE)
   182f8:	2b05      	cmp	r3, #5
   182fa:	d9de      	bls.n	182ba <DRV_MIIM_OperationResult+0x2e>
    else if(pOpDcpt->opStat == DRV_MIIM_TXFER_TMO_START || pOpDcpt->opStat == DRV_MIIM_TXFER_TMO_END)
   182fc:	3b06      	subs	r3, #6
   182fe:	b2db      	uxtb	r3, r3
        return DRV_MIIM_RES_OP_TIMEOUT_ERR;
   18300:	2b01      	cmp	r3, #1
   18302:	bf8c      	ite	hi
   18304:	f06f 0613 	mvnhi.w	r6, #19
   18308:	f06f 0608 	mvnls.w	r6, #8
            _DRV_MIIM_ReleaseOpDcpt(pMiimObj, pOpDcpt,  &pClient->parentObj->completeOpList, DRV_MIIM_QTYPE_COMPLETE);
   1830c:	6852      	ldr	r2, [r2, #4]
   1830e:	2303      	movs	r3, #3
   18310:	3288      	adds	r2, #136	; 0x88
   18312:	4621      	mov	r1, r4
   18314:	4628      	mov	r0, r5
   18316:	f005 ffcb 	bl	1e2b0 <_DRV_MIIM_ReleaseOpDcpt>
   1831a:	e7c8      	b.n	182ae <DRV_MIIM_OperationResult+0x22>

Disassembly of section .text._DHCPCleanup%391:

0001831c <_DHCPCleanup>:
{
   1831c:	b570      	push	{r4, r5, r6, lr}
    if(dhcpClientSocket != INVALID_UDP_SOCKET)
   1831e:	4b1d      	ldr	r3, [pc, #116]	; (18394 <_DHCPCleanup+0x78>)
   18320:	f9b3 0000 	ldrsh.w	r0, [r3]
   18324:	f1b0 3fff 	cmp.w	r0, #4294967295
   18328:	d109      	bne.n	1833e <_DHCPCleanup+0x22>
    if(DHCPClients != 0)
   1832a:	4b1b      	ldr	r3, [pc, #108]	; (18398 <_DHCPCleanup+0x7c>)
   1832c:	681c      	ldr	r4, [r3, #0]
   1832e:	b304      	cbz	r4, 18372 <_DHCPCleanup+0x56>
        for(ix = 0; ix < dhcpInterfaces; ix++, pClient++)
   18330:	4b1a      	ldr	r3, [pc, #104]	; (1839c <_DHCPCleanup+0x80>)
   18332:	681b      	ldr	r3, [r3, #0]
   18334:	2b00      	cmp	r3, #0
   18336:	dd14      	ble.n	18362 <_DHCPCleanup+0x46>
   18338:	2500      	movs	r5, #0
   1833a:	4e18      	ldr	r6, [pc, #96]	; (1839c <_DHCPCleanup+0x80>)
   1833c:	e00d      	b.n	1835a <_DHCPCleanup+0x3e>
        TCPIP_UDP_Close(dhcpClientSocket);
   1833e:	f006 ff11 	bl	1f164 <TCPIP_UDP_Close>
        dhcpClientSocket = INVALID_UDP_SOCKET;
   18342:	4b14      	ldr	r3, [pc, #80]	; (18394 <_DHCPCleanup+0x78>)
   18344:	f64f 72ff 	movw	r2, #65535	; 0xffff
   18348:	801a      	strh	r2, [r3, #0]
   1834a:	e7ee      	b.n	1832a <_DHCPCleanup+0xe>
                Ipv4DeRegisterFilter(pClient->dhcpFilterHandle);
   1834c:	f007 fd02 	bl	1fd54 <Ipv4DeRegisterFilter>
        for(ix = 0; ix < dhcpInterfaces; ix++, pClient++)
   18350:	3501      	adds	r5, #1
   18352:	345c      	adds	r4, #92	; 0x5c
   18354:	6833      	ldr	r3, [r6, #0]
   18356:	42ab      	cmp	r3, r5
   18358:	dd03      	ble.n	18362 <_DHCPCleanup+0x46>
            if(pClient->dhcpFilterHandle != 0)
   1835a:	6ca0      	ldr	r0, [r4, #72]	; 0x48
   1835c:	2800      	cmp	r0, #0
   1835e:	d1f5      	bne.n	1834c <_DHCPCleanup+0x30>
   18360:	e7f6      	b.n	18350 <_DHCPCleanup+0x34>
        TCPIP_HEAP_Free(dhcpMemH, DHCPClients);
   18362:	4b0f      	ldr	r3, [pc, #60]	; (183a0 <_DHCPCleanup+0x84>)
   18364:	6818      	ldr	r0, [r3, #0]
   18366:	4c0c      	ldr	r4, [pc, #48]	; (18398 <_DHCPCleanup+0x7c>)
   18368:	68c3      	ldr	r3, [r0, #12]
   1836a:	6821      	ldr	r1, [r4, #0]
   1836c:	4798      	blx	r3
        DHCPClients = 0;
   1836e:	2300      	movs	r3, #0
   18370:	6023      	str	r3, [r4, #0]
    TCPIP_Notification_Deinitialize(&dhcpRegisteredUsers, dhcpMemH);
   18372:	4b0b      	ldr	r3, [pc, #44]	; (183a0 <_DHCPCleanup+0x84>)
   18374:	6819      	ldr	r1, [r3, #0]
   18376:	480b      	ldr	r0, [pc, #44]	; (183a4 <_DHCPCleanup+0x88>)
   18378:	f009 fb80 	bl	21a7c <TCPIP_Notification_Deinitialize>
    if(dhcpSignalHandle)
   1837c:	4b0a      	ldr	r3, [pc, #40]	; (183a8 <_DHCPCleanup+0x8c>)
   1837e:	6818      	ldr	r0, [r3, #0]
   18380:	b120      	cbz	r0, 1838c <_DHCPCleanup+0x70>
        _TCPIPStackSignalHandlerDeregister(dhcpSignalHandle);
   18382:	f009 fc4e 	bl	21c22 <_TCPIPStackSignalHandlerDeregister>
        dhcpSignalHandle = 0;
   18386:	4b08      	ldr	r3, [pc, #32]	; (183a8 <_DHCPCleanup+0x8c>)
   18388:	2200      	movs	r2, #0
   1838a:	601a      	str	r2, [r3, #0]
    dhcpInterfaces = 0;
   1838c:	4b03      	ldr	r3, [pc, #12]	; (1839c <_DHCPCleanup+0x80>)
   1838e:	2200      	movs	r2, #0
   18390:	601a      	str	r2, [r3, #0]
}
   18392:	bd70      	pop	{r4, r5, r6, pc}
   18394:	2000e720 	.word	0x2000e720
   18398:	2000e610 	.word	0x2000e610
   1839c:	2000e618 	.word	0x2000e618
   183a0:	2000e61c 	.word	0x2000e61c
   183a4:	2000e450 	.word	0x2000e450
   183a8:	2000e624 	.word	0x2000e624

Disassembly of section .text._TCPIPStackModuleRxPurge%392:

000183ac <_TCPIPStackModuleRxPurge>:
}

// purges the packets from a module RX queue
// belonging to the pNetIf
void _TCPIPStackModuleRxPurge(TCPIP_STACK_MODULE modId, TCPIP_NET_IF* pNetIf)
{
   183ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   183b0:	b086      	sub	sp, #24
   183b2:	4688      	mov	r8, r1
    TCPIP_MAC_PACKET* pRxPkt;
    SINGLE_LIST       remList = { 0 };  // list of packets to remove/ack
   183b4:	2300      	movs	r3, #0
   183b6:	9303      	str	r3, [sp, #12]
   183b8:	9304      	str	r3, [sp, #16]
   183ba:	9305      	str	r3, [sp, #20]
    SINGLE_LIST       keepList = { 0 };  // list of packets to keep
   183bc:	9300      	str	r3, [sp, #0]
   183be:	9301      	str	r3, [sp, #4]
   183c0:	9302      	str	r3, [sp, #8]

    SINGLE_LIST*      pRxQueue = (TCPIP_MODULES_QUEUE_TBL + modId); // list to extract from
   183c2:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   183c6:	4f1c      	ldr	r7, [pc, #112]	; (18438 <_TCPIPStackModuleRxPurge+0x8c>)
   183c8:	eb07 0780 	add.w	r7, r7, r0, lsl #2
    
    // kill the list
    while(true)
    {
        OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   183cc:	461d      	mov	r5, r3
   183ce:	4628      	mov	r0, r5
   183d0:	f009 f864 	bl	2149c <OSAL_CRIT_Enter>
   183d4:	4606      	mov	r6, r0
        pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(pRxQueue);
   183d6:	4638      	mov	r0, r7
   183d8:	f008 fd0e 	bl	20df8 <TCPIP_Helper_SingleListHeadRemove>
   183dc:	4604      	mov	r4, r0
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   183de:	4631      	mov	r1, r6
   183e0:	4628      	mov	r0, r5
   183e2:	f009 f98a 	bl	216fa <OSAL_CRIT_Leave>
        if(pRxPkt == 0)
   183e6:	b144      	cbz	r4, 183fa <_TCPIPStackModuleRxPurge+0x4e>
        {
            break;
        }


        if(pRxPkt->pktIf == pNetIf)
   183e8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   183ea:	4543      	cmp	r3, r8
        {   // need to remove
            TCPIP_Helper_SingleListTailAdd(&remList, (SGL_LIST_NODE*)pRxPkt);
   183ec:	4621      	mov	r1, r4
   183ee:	bf0c      	ite	eq
   183f0:	a803      	addeq	r0, sp, #12
        }
        else
        {   // need to keep
            TCPIP_Helper_SingleListTailAdd(&keepList, (SGL_LIST_NODE*)pRxPkt);
   183f2:	4668      	movne	r0, sp
   183f4:	f008 fed4 	bl	211a0 <TCPIP_Helper_SingleListTailAdd>
   183f8:	e7e9      	b.n	183ce <_TCPIPStackModuleRxPurge+0x22>
    }

    // acknowledge the removed packets
    while((pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(&remList)) != 0)
    {
        TCPIP_PKT_PacketAcknowledge(pRxPkt, TCPIP_MAC_PKT_ACK_SOURCE_ERR);
   183fa:	2501      	movs	r5, #1
   183fc:	f06f 040a 	mvn.w	r4, #10
   18400:	e004      	b.n	1840c <_TCPIPStackModuleRxPurge+0x60>
   18402:	462a      	mov	r2, r5
   18404:	4621      	mov	r1, r4
   18406:	4618      	mov	r0, r3
   18408:	f005 fac4 	bl	1d994 <_TCPIP_PKT_PacketAcknowledge>
    while((pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(&remList)) != 0)
   1840c:	a803      	add	r0, sp, #12
   1840e:	f008 fcf3 	bl	20df8 <TCPIP_Helper_SingleListHeadRemove>
   18412:	4603      	mov	r3, r0
   18414:	2800      	cmp	r0, #0
   18416:	d1f4      	bne.n	18402 <_TCPIPStackModuleRxPurge+0x56>
    }

    if(!TCPIP_Helper_SingleListIsEmpty(&keepList))
   18418:	9b00      	ldr	r3, [sp, #0]
   1841a:	b153      	cbz	r3, 18432 <_TCPIPStackModuleRxPurge+0x86>
    {   // replace the remaining packets
        OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1841c:	f009 f83e 	bl	2149c <OSAL_CRIT_Enter>
   18420:	4604      	mov	r4, r0
        TCPIP_Helper_SingleListAppend(pRxQueue, &keepList);
   18422:	4669      	mov	r1, sp
   18424:	4638      	mov	r0, r7
   18426:	f008 fec8 	bl	211ba <TCPIP_Helper_SingleListAppend>
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1842a:	4621      	mov	r1, r4
   1842c:	2000      	movs	r0, #0
   1842e:	f009 f964 	bl	216fa <OSAL_CRIT_Leave>
    }

}
   18432:	b006      	add	sp, #24
   18434:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   18438:	2000de84 	.word	0x2000de84

Disassembly of section .text.NVIC_Initialize%393:

0001843c <NVIC_Initialize>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
   1843c:	4921      	ldr	r1, [pc, #132]	; (184c4 <NVIC_Initialize+0x88>)
   1843e:	68cb      	ldr	r3, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
   18440:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
   18444:	041b      	lsls	r3, r3, #16
   18446:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                   |
   18448:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
   1844c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  SCB->AIRCR =  reg_value;
   18450:	60cb      	str	r3, [r1, #12]
   18452:	f3bf 8f5f 	dmb	sy
  \details Enables IRQ interrupts by clearing special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   18456:	b662      	cpsie	i
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   18458:	22e0      	movs	r2, #224	; 0xe0
   1845a:	f881 2023 	strb.w	r2, [r1, #35]	; 0x23
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1845e:	4b1a      	ldr	r3, [pc, #104]	; (184c8 <NVIC_Initialize+0x8c>)
   18460:	f883 232e 	strb.w	r2, [r3, #814]	; 0x32e
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   18464:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   18468:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1846a:	f883 232f 	strb.w	r2, [r3, #815]	; 0x32f
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1846e:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   18472:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   18474:	f883 2330 	strb.w	r2, [r3, #816]	; 0x330
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   18478:	f44f 3180 	mov.w	r1, #65536	; 0x10000
   1847c:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1847e:	f883 2331 	strb.w	r2, [r3, #817]	; 0x331
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   18482:	f44f 3100 	mov.w	r1, #131072	; 0x20000
   18486:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   18488:	f883 2332 	strb.w	r2, [r3, #818]	; 0x332
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1848c:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   18490:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   18492:	f883 2333 	strb.w	r2, [r3, #819]	; 0x333
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   18496:	f44f 2100 	mov.w	r1, #524288	; 0x80000
   1849a:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1849c:	f883 2334 	strb.w	r2, [r3, #820]	; 0x334
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   184a0:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
   184a4:	6059      	str	r1, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   184a6:	f883 2335 	strb.w	r2, [r3, #821]	; 0x335
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   184aa:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
   184ae:	6058      	str	r0, [r3, #4]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   184b0:	f883 2354 	strb.w	r2, [r3, #852]	; 0x354
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   184b4:	6099      	str	r1, [r3, #8]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   184b6:	f883 236b 	strb.w	r2, [r3, #875]	; 0x36b
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   184ba:	f44f 6200 	mov.w	r2, #2048	; 0x800
   184be:	60da      	str	r2, [r3, #12]
    NVIC_SetPriority(TC0_IRQn, 7);
    NVIC_EnableIRQ(TC0_IRQn);



}
   184c0:	4770      	bx	lr
   184c2:	bf00      	nop
   184c4:	e000ed00 	.word	0xe000ed00
   184c8:	e000e100 	.word	0xe000e100

Disassembly of section .text.SYS_TIME_AddToList%394:

000184cc <SYS_TIME_AddToList>:
    if (newTimer == NULL)
   184cc:	b330      	cbz	r0, 1851c <SYS_TIME_AddToList+0x50>
{
   184ce:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   184d2:	4686      	mov	lr, r0
    SYS_TIME_TIMER_OBJ* tmr = counter->tmrActive;
   184d4:	4b20      	ldr	r3, [pc, #128]	; (18558 <SYS_TIME_AddToList+0x8c>)
   184d6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    newTimerTime = newTimer->relativeTimePending;
   184d8:	f8d0 8008 	ldr.w	r8, [r0, #8]
    if (tmr == NULL)
   184dc:	b1c2      	cbz	r2, 18510 <SYS_TIME_AddToList+0x44>
            if ((total_time + tmr->relativeTimePending) > newTimerTime)
   184de:	6893      	ldr	r3, [r2, #8]
   184e0:	4640      	mov	r0, r8
   184e2:	2100      	movs	r1, #0
   184e4:	4598      	cmp	r8, r3
   184e6:	d31b      	bcc.n	18520 <SYS_TIME_AddToList+0x54>
    uint64_t total_time = 0;
   184e8:	2400      	movs	r4, #0
   184ea:	2500      	movs	r5, #0
            total_time += tmr->relativeTimePending;
   184ec:	6893      	ldr	r3, [r2, #8]
   184ee:	18e4      	adds	r4, r4, r3
   184f0:	f145 0500 	adc.w	r5, r5, #0
            tmr = tmr->tmrNext;
   184f4:	6993      	ldr	r3, [r2, #24]
        while (tmr != NULL)
   184f6:	b1db      	cbz	r3, 18530 <SYS_TIME_AddToList+0x64>
            if ((total_time + tmr->relativeTimePending) > newTimerTime)
   184f8:	f8d3 c008 	ldr.w	ip, [r3, #8]
   184fc:	eb14 060c 	adds.w	r6, r4, ip
   18500:	f145 0700 	adc.w	r7, r5, #0
   18504:	42b9      	cmp	r1, r7
   18506:	bf08      	it	eq
   18508:	42b0      	cmpeq	r0, r6
   1850a:	d311      	bcc.n	18530 <SYS_TIME_AddToList+0x64>
            tmr = tmr->tmrNext;
   1850c:	461a      	mov	r2, r3
   1850e:	e7ed      	b.n	184ec <SYS_TIME_AddToList+0x20>
        newTimer->relativeTimePending = newTimerTime;
   18510:	f8c0 8008 	str.w	r8, [r0, #8]
        counter->tmrActive = newTimer;
   18514:	4b10      	ldr	r3, [pc, #64]	; (18558 <SYS_TIME_AddToList+0x8c>)
   18516:	6318      	str	r0, [r3, #48]	; 0x30
        isHeadTimerUpdated = true;
   18518:	2001      	movs	r0, #1
   1851a:	e01a      	b.n	18552 <SYS_TIME_AddToList+0x86>
        return isHeadTimerUpdated;
   1851c:	2000      	movs	r0, #0
}
   1851e:	4770      	bx	lr
            counter->tmrActive = newTimer;
   18520:	4b0d      	ldr	r3, [pc, #52]	; (18558 <SYS_TIME_AddToList+0x8c>)
   18522:	f8c3 e030 	str.w	lr, [r3, #48]	; 0x30
            newTimer->tmrNext = tmr;
   18526:	f8ce 2018 	str.w	r2, [lr, #24]
    uint64_t total_time = 0;
   1852a:	2400      	movs	r4, #0
            isHeadTimerUpdated = true;
   1852c:	2001      	movs	r0, #1
   1852e:	e004      	b.n	1853a <SYS_TIME_AddToList+0x6e>
            newTimer->tmrNext = prevTmr->tmrNext;
   18530:	f8ce 3018 	str.w	r3, [lr, #24]
            prevTmr->tmrNext = newTimer;
   18534:	f8c2 e018 	str.w	lr, [r2, #24]
    bool isHeadTimerUpdated = false;
   18538:	2000      	movs	r0, #0
        newTimer->relativeTimePending = newTimerTime - total_time;
   1853a:	eba8 0404 	sub.w	r4, r8, r4
   1853e:	f8ce 4008 	str.w	r4, [lr, #8]
        if (newTimer->tmrNext != NULL)
   18542:	f8de 3018 	ldr.w	r3, [lr, #24]
   18546:	b123      	cbz	r3, 18552 <SYS_TIME_AddToList+0x86>
            newTimerTime = newTimer->relativeTimePending;
   18548:	f8de 1008 	ldr.w	r1, [lr, #8]
            newTimer->tmrNext->relativeTimePending -= newTimerTime;
   1854c:	689a      	ldr	r2, [r3, #8]
   1854e:	1a52      	subs	r2, r2, r1
   18550:	609a      	str	r2, [r3, #8]
}
   18552:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   18556:	bf00      	nop
   18558:	2000e230 	.word	0x2000e230

Disassembly of section .text.Reset_Handler%395:

0001855c <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void __attribute__((optimize("-O1"), section(".text.Reset_Handler"), long_call, noreturn)) Reset_Handler(void)
{
   1855c:	b508      	push	{r3, lr}
    __asm__ volatile ("add r7, sp, #0" : : : "r7");
#endif


    /* Call the optional application-provided _on_reset() function. */
    _on_reset();
   1855e:	4b1b      	ldr	r3, [pc, #108]	; (185cc <Reset_Handler+0x70>)
   18560:	4798      	blx	r3

    /* Reserved for use by MPLAB XC32. */
    __xc32_on_reset();
   18562:	4b1b      	ldr	r3, [pc, #108]	; (185d0 <Reset_Handler+0x74>)
   18564:	4798      	blx	r3
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   18566:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
   1856a:	b672      	cpsid	i
     SCB->CPACR |= (0xFu << 20);
   1856c:	4a19      	ldr	r2, [pc, #100]	; (185d4 <Reset_Handler+0x78>)
   1856e:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
   18572:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
   18576:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
   1857a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1857e:	f3bf 8f6f 	isb	sy
    if (!prim)
   18582:	b901      	cbnz	r1, 18586 <Reset_Handler+0x2a>
  __ASM volatile ("cpsie i" : : : "memory");
   18584:	b662      	cpsie	i
    CMCC_REGS->CMCC_CFG = CMCC_CFG_CSIZESW(tcmSize);
   18586:	4c14      	ldr	r4, [pc, #80]	; (185d8 <Reset_Handler+0x7c>)
   18588:	2320      	movs	r3, #32
   1858a:	6063      	str	r3, [r4, #4]
    /* Enable TCM   */
    TCM_Enable();

    /* Initialize data after TCM is enabled.
     * Data initialization from the XC32 .dinit template */
    __pic32c_data_initialization();
   1858c:	f000 fa9a 	bl	18ac4 <__pic32c_data_initialization>


#  ifdef SCB_VTOR_TBLOFF_Msk
    /*  Set the vector-table base address in FLASH */
    pSrc = (uint32_t *) & __svectors;
    SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
   18590:	4b12      	ldr	r3, [pc, #72]	; (185dc <Reset_Handler+0x80>)
   18592:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
   18596:	4a0f      	ldr	r2, [pc, #60]	; (185d4 <Reset_Handler+0x78>)
   18598:	6093      	str	r3, [r2, #8]
#  endif /* SCB_VTOR_TBLOFF_Msk */

    /* Initialize the C library */
    __libc_init_array();
   1859a:	4b11      	ldr	r3, [pc, #68]	; (185e0 <Reset_Handler+0x84>)
   1859c:	4798      	blx	r3
    CMCC_REGS->CMCC_CTRL &= ~(CMCC_CTRL_CEN_Msk);
   1859e:	68a3      	ldr	r3, [r4, #8]
   185a0:	f023 0301 	bic.w	r3, r3, #1
   185a4:	60a3      	str	r3, [r4, #8]
    while((CMCC_REGS->CMCC_SR & CMCC_SR_CSTS_Msk) == CMCC_SR_CSTS_Msk)
   185a6:	4623      	mov	r3, r4
   185a8:	68da      	ldr	r2, [r3, #12]
   185aa:	f012 0f01 	tst.w	r2, #1
   185ae:	d1fb      	bne.n	185a8 <Reset_Handler+0x4c>
    CMCC_REGS->CMCC_CFG |= (CMCC_CFG_DCDIS_Msk);
   185b0:	4b09      	ldr	r3, [pc, #36]	; (185d8 <Reset_Handler+0x7c>)
   185b2:	685a      	ldr	r2, [r3, #4]
   185b4:	f042 0204 	orr.w	r2, r2, #4
   185b8:	605a      	str	r2, [r3, #4]
    CMCC_REGS->CMCC_CTRL = (CMCC_CTRL_CEN_Msk);
   185ba:	2201      	movs	r2, #1
   185bc:	609a      	str	r2, [r3, #8]
    /* Enable Instruction Cache */
    ICache_Enable();


    /* Call the optional application-provided _on_bootstrap() function. */
    _on_bootstrap();
   185be:	4b09      	ldr	r3, [pc, #36]	; (185e4 <Reset_Handler+0x88>)
   185c0:	4798      	blx	r3
    
    /* Reserved for use by MPLAB XC32. */
    __xc32_on_bootstrap();
   185c2:	4b09      	ldr	r3, [pc, #36]	; (185e8 <Reset_Handler+0x8c>)
   185c4:	4798      	blx	r3

    /* Branch to application's main function */
    int retval = main();
   185c6:	f009 fb33 	bl	21c30 <main>

#if (defined(__DEBUG) || defined(__DEBUG_D)) && defined(__XC32)
    __builtin_software_breakpoint();
#endif
    /* Infinite loop */
    while (true) {}
   185ca:	e7fe      	b.n	185ca <Reset_Handler+0x6e>
   185cc:	0001983f 	.word	0x0001983f
   185d0:	0001983f 	.word	0x0001983f
   185d4:	e000ed00 	.word	0xe000ed00
   185d8:	41006000 	.word	0x41006000
   185dc:	00000000 	.word	0x00000000
   185e0:	0001ce41 	.word	0x0001ce41
   185e4:	0001983f 	.word	0x0001983f
   185e8:	0001983f 	.word	0x0001983f

Disassembly of section .text._DHCPClientClose%396:

000185ec <_DHCPClientClose>:
{
   185ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   185ee:	4605      	mov	r5, r0
   185f0:	460e      	mov	r6, r1
   185f2:	4617      	mov	r7, r2
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   185f4:	4b1f      	ldr	r3, [pc, #124]	; (18674 <_DHCPClientClose+0x88>)
   185f6:	681c      	ldr	r4, [r3, #0]
   185f8:	f009 fb0c 	bl	21c14 <TCPIP_STACK_NetIxGet>
   185fc:	235c      	movs	r3, #92	; 0x5c
   185fe:	fb03 4400 	mla	r4, r3, r0, r4
    if(pClient->flags.bDHCPEnabled != 0)
   18602:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
   18606:	f013 0f01 	tst.w	r3, #1
   1860a:	d026      	beq.n	1865a <_DHCPClientClose+0x6e>
        if(release && pClient->smState >= TCPIP_DHCP_BOUND)
   1860c:	b11f      	cbz	r7, 18616 <_DHCPClientClose+0x2a>
   1860e:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
   18612:	2b07      	cmp	r3, #7
   18614:	d822      	bhi.n	1865c <_DHCPClientClose+0x70>
		pClient->flags.bIsBound = false;
   18616:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
        pClient->flags.bReportFail = 1;	
   1861a:	f003 03f5 	and.w	r3, r3, #245	; 0xf5
   1861e:	f043 0320 	orr.w	r3, r3, #32
   18622:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
        pClient->tOpStart = 0; 
   18626:	2300      	movs	r3, #0
   18628:	6223      	str	r3, [r4, #32]
        pClient->dhcpTmo = pClient->dhcpTmoBase;
   1862a:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
   1862e:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    if(pClient->dhcpFilterHandle != 0)
   18632:	6ca0      	ldr	r0, [r4, #72]	; 0x48
   18634:	b110      	cbz	r0, 1863c <_DHCPClientClose+0x50>
        Ipv4FilterSetActive(pClient->dhcpFilterHandle, active);
   18636:	2100      	movs	r1, #0
   18638:	f002 fdd2 	bl	1b1e0 <Ipv4FilterSetActive>
        if(disable)
   1863c:	b1ae      	cbz	r6, 1866a <_DHCPClientClose+0x7e>
            pClient->flags.bWasBound = false;	
   1863e:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
            pClient->flags.bDHCPEnabled = false;
   18642:	f003 03ef 	and.w	r3, r3, #239	; 0xef
   18646:	f36f 0300 	bfc	r3, #0, #1
   1864a:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
            pNetIf->Flags.bIsDHCPEnabled = false;
   1864e:	f895 3042 	ldrb.w	r3, [r5, #66]	; 0x42
   18652:	f36f 0300 	bfc	r3, #0, #1
   18656:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
}
   1865a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            _DHCPSend(pClient, pNetIf, TCPIP_DHCP_RELEASE_MESSAGE, 0);
   1865c:	2300      	movs	r3, #0
   1865e:	2207      	movs	r2, #7
   18660:	4629      	mov	r1, r5
   18662:	4620      	mov	r0, r4
   18664:	f7f7 f9b2 	bl	f9cc <_DHCPSend>
   18668:	e7d5      	b.n	18616 <_DHCPClientClose+0x2a>
    pClient->smState = newState;
   1866a:	2300      	movs	r3, #0
   1866c:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
}
   18670:	e7f3      	b.n	1865a <_DHCPClientClose+0x6e>
   18672:	bf00      	nop
   18674:	2000e610 	.word	0x2000e610

Disassembly of section .text.TCPIP_STACK_Initialize%397:

00018678 <TCPIP_STACK_Initialize>:
{
   18678:	b538      	push	{r3, r4, r5, lr}
    if(tcpipNetIf != 0)
   1867a:	4b18      	ldr	r3, [pc, #96]	; (186dc <TCPIP_STACK_Initialize+0x64>)
   1867c:	681b      	ldr	r3, [r3, #0]
   1867e:	b10b      	cbz	r3, 18684 <TCPIP_STACK_Initialize+0xc>
        return (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data;
   18680:	4817      	ldr	r0, [pc, #92]	; (186e0 <TCPIP_STACK_Initialize+0x68>)
}
   18682:	bd38      	pop	{r3, r4, r5, pc}
    if(init == 0)
   18684:	b331      	cbz	r1, 186d4 <TCPIP_STACK_Initialize+0x5c>
   18686:	460d      	mov	r5, r1
    totTcpipEventsCnt = 0;
   18688:	2400      	movs	r4, #0
   1868a:	4b16      	ldr	r3, [pc, #88]	; (186e4 <TCPIP_STACK_Initialize+0x6c>)
   1868c:	601c      	str	r4, [r3, #0]
    newTcpipErrorEventCnt = 0;
   1868e:	4b16      	ldr	r3, [pc, #88]	; (186e8 <TCPIP_STACK_Initialize+0x70>)
   18690:	601c      	str	r4, [r3, #0]
    newTcpipStackEventCnt = 0;
   18692:	4b16      	ldr	r3, [pc, #88]	; (186ec <TCPIP_STACK_Initialize+0x74>)
   18694:	601c      	str	r4, [r3, #0]
    newTcpipTickAvlbl = 0;
   18696:	4b16      	ldr	r3, [pc, #88]	; (186f0 <TCPIP_STACK_Initialize+0x78>)
   18698:	601c      	str	r4, [r3, #0]
    stackTaskRate = 0;
   1869a:	4b16      	ldr	r3, [pc, #88]	; (186f4 <TCPIP_STACK_Initialize+0x7c>)
   1869c:	601c      	str	r4, [r3, #0]
    memset(&tcpip_stack_ctrl_data, 0, sizeof(tcpip_stack_ctrl_data));
   1869e:	2220      	movs	r2, #32
   186a0:	4621      	mov	r1, r4
   186a2:	480f      	ldr	r0, [pc, #60]	; (186e0 <TCPIP_STACK_Initialize+0x68>)
   186a4:	f009 fa6a 	bl	21b7c <memset>
    SYS_CONSOLE_MESSAGE(TCPIP_STACK_HDR_MESSAGE "Initialization Started \r\n");
   186a8:	4913      	ldr	r1, [pc, #76]	; (186f8 <TCPIP_STACK_Initialize+0x80>)
   186aa:	4620      	mov	r0, r4
   186ac:	f006 fdba 	bl	1f224 <SYS_CONSOLE_Message>
    tcpip_stack_status = SYS_STATUS_BUSY;
   186b0:	4b12      	ldr	r3, [pc, #72]	; (186fc <TCPIP_STACK_Initialize+0x84>)
   186b2:	2201      	movs	r2, #1
   186b4:	701a      	strb	r2, [r3, #0]
    if((tcpip_stack_init_cb = ((TCPIP_STACK_INIT*)init)->initCback) == 0)
   186b6:	696b      	ldr	r3, [r5, #20]
   186b8:	4a11      	ldr	r2, [pc, #68]	; (18700 <TCPIP_STACK_Initialize+0x88>)
   186ba:	6013      	str	r3, [r2, #0]
   186bc:	b10b      	cbz	r3, 186c2 <TCPIP_STACK_Initialize+0x4a>
    return (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data;
   186be:	4808      	ldr	r0, [pc, #32]	; (186e0 <TCPIP_STACK_Initialize+0x68>)
   186c0:	e7df      	b.n	18682 <TCPIP_STACK_Initialize+0xa>
        bool init_res = _TCPIP_DoInitialize((const TCPIP_STACK_INIT*)init);
   186c2:	4628      	mov	r0, r5
   186c4:	f7f0 f982 	bl	89cc <_TCPIP_DoInitialize>
        return init_res ? (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data : SYS_MODULE_OBJ_INVALID;
   186c8:	2800      	cmp	r0, #0
   186ca:	4805      	ldr	r0, [pc, #20]	; (186e0 <TCPIP_STACK_Initialize+0x68>)
   186cc:	bf08      	it	eq
   186ce:	f04f 30ff 	moveq.w	r0, #4294967295
   186d2:	e7d6      	b.n	18682 <TCPIP_STACK_Initialize+0xa>
        return SYS_MODULE_OBJ_INVALID;
   186d4:	f04f 30ff 	mov.w	r0, #4294967295
   186d8:	e7d3      	b.n	18682 <TCPIP_STACK_Initialize+0xa>
   186da:	bf00      	nop
   186dc:	2000e648 	.word	0x2000e648
   186e0:	2000e2f0 	.word	0x2000e2f0
   186e4:	2000e650 	.word	0x2000e650
   186e8:	2000e630 	.word	0x2000e630
   186ec:	2000e634 	.word	0x2000e634
   186f0:	2000e638 	.word	0x2000e638
   186f4:	2000e640 	.word	0x2000e640
   186f8:	00008874 	.word	0x00008874
   186fc:	2000e729 	.word	0x2000e729
   18700:	2000e64c 	.word	0x2000e64c

Disassembly of section .text._UDPsetPacketInfo%398:

00018704 <_UDPsetPacketInfo>:
    if(pRxPkt != 0 && pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   18704:	2900      	cmp	r1, #0
   18706:	d040      	beq.n	1878a <_UDPsetPacketInfo+0x86>
{
   18708:	b570      	push	{r4, r5, r6, lr}
   1870a:	b082      	sub	sp, #8
   1870c:	460d      	mov	r5, r1
    if(pRxPkt != 0 && pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   1870e:	8f82      	ldrh	r2, [r0, #60]	; 0x3c
   18710:	2a01      	cmp	r2, #1
   18712:	d001      	beq.n	18718 <_UDPsetPacketInfo+0x14>
}
   18714:	b002      	add	sp, #8
   18716:	bd70      	pop	{r4, r5, r6, pc}
        uint32_t pktSrcAdd = TCPIP_IPV4_PacketGetSourceAddress(pRxPkt)->Val;
   18718:	698a      	ldr	r2, [r1, #24]
   1871a:	68d2      	ldr	r2, [r2, #12]
        pSkt->pktSrcAddress.Val = pktSrcAdd;
   1871c:	61c2      	str	r2, [r0, #28]
        if(pSkt->extFlags.ignoreSrcAdd == 0 && pSkt->flags.destSet == 0)
   1871e:	6c01      	ldr	r1, [r0, #64]	; 0x40
   18720:	4c1a      	ldr	r4, [pc, #104]	; (1878c <_UDPsetPacketInfo+0x88>)
   18722:	420c      	tst	r4, r1
            pSkt->destAddress.Val = pktSrcAdd;
   18724:	bf08      	it	eq
   18726:	6142      	streq	r2, [r0, #20]
   18728:	4604      	mov	r4, r0
        uint32_t pktDestAdd = TCPIP_IPV4_PacketGetDestAddress(pRxPkt)->Val;
   1872a:	69ab      	ldr	r3, [r5, #24]
   1872c:	691e      	ldr	r6, [r3, #16]
   1872e:	9601      	str	r6, [sp, #4]
        pSkt->pktDestAddress.Val = pktDestAdd;
   18730:	6206      	str	r6, [r0, #32]
        if(pSkt->flags.srcSet == 0)
   18732:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   18736:	f013 0f20 	tst.w	r3, #32
   1873a:	d00a      	beq.n	18752 <_UDPsetPacketInfo+0x4e>
        pSkt->pSktNet = (TCPIP_NET_IF*)pRxPkt->pktIf;    // bind it
   1873c:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1873e:	6263      	str	r3, [r4, #36]	; 0x24
        if(pSkt->extFlags.ignoreSrcPort == 0 )
   18740:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   18744:	f013 0f20 	tst.w	r3, #32
   18748:	d1e4      	bne.n	18714 <_UDPsetPacketInfo+0x10>
    return ((UDP_HEADER*)pRxPkt->pTransportLayer)->SourcePort;
   1874a:	69eb      	ldr	r3, [r5, #28]
   1874c:	881b      	ldrh	r3, [r3, #0]
            pSkt->remotePort = _UDPRxPktSourcePort(pRxPkt); 
   1874e:	8523      	strh	r3, [r4, #40]	; 0x28
}
   18750:	e7e0      	b.n	18714 <_UDPsetPacketInfo+0x10>
            bool isBcastAdd = TCPIP_STACK_IsBcastAddress((TCPIP_NET_IF*)pRxPkt->pktIf, (IPV4_ADDR*)&pktDestAdd);
   18752:	a901      	add	r1, sp, #4
   18754:	6aa8      	ldr	r0, [r5, #40]	; 0x28
   18756:	f007 f819 	bl	1f78c <TCPIP_STACK_IsBcastAddress>
            if(!isBcastAdd && !isMcastAdd)
   1875a:	2800      	cmp	r0, #0
   1875c:	d1ee      	bne.n	1873c <_UDPsetPacketInfo+0x38>
   1875e:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
   18762:	2ee0      	cmp	r6, #224	; 0xe0
   18764:	d0ea      	beq.n	1873c <_UDPsetPacketInfo+0x38>
                if(pSkt->srcAddress.Val != pktDestAdd)
   18766:	9b01      	ldr	r3, [sp, #4]
   18768:	69a2      	ldr	r2, [r4, #24]
   1876a:	429a      	cmp	r2, r3
   1876c:	d006      	beq.n	1877c <_UDPsetPacketInfo+0x78>
                    pSkt->flags.srcSolved = 0;
   1876e:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
   18772:	f36f 12c7 	bfc	r2, #7, #1
   18776:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
                    pSkt->srcAddress.Val = pktDestAdd;
   1877a:	61a3      	str	r3, [r4, #24]
                pSkt->flags.srcValid = 1;
   1877c:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
   18780:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   18784:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
   18788:	e7d8      	b.n	1873c <_UDPsetPacketInfo+0x38>
   1878a:	4770      	bx	lr
   1878c:	00100100 	.word	0x00100100

Disassembly of section .text.__smakebuf_r%399:

00018790 <__smakebuf_r>:
   18790:	898b      	ldrh	r3, [r1, #12]
   18792:	b573      	push	{r0, r1, r4, r5, r6, lr}
   18794:	079d      	lsls	r5, r3, #30
   18796:	4606      	mov	r6, r0
   18798:	460c      	mov	r4, r1
   1879a:	d507      	bpl.n	187ac <__smakebuf_r+0x1c>
   1879c:	f101 0347 	add.w	r3, r1, #71	; 0x47
   187a0:	600b      	str	r3, [r1, #0]
   187a2:	610b      	str	r3, [r1, #16]
   187a4:	2301      	movs	r3, #1
   187a6:	614b      	str	r3, [r1, #20]
   187a8:	b002      	add	sp, #8
   187aa:	bd70      	pop	{r4, r5, r6, pc}
   187ac:	ab01      	add	r3, sp, #4
   187ae:	466a      	mov	r2, sp
   187b0:	f004 fbb2 	bl	1cf18 <__swhatbuf_r>
   187b4:	9900      	ldr	r1, [sp, #0]
   187b6:	4605      	mov	r5, r0
   187b8:	4630      	mov	r0, r6
   187ba:	f7fe f8c7 	bl	1694c <_malloc_r>
   187be:	b978      	cbnz	r0, 187e0 <__smakebuf_r+0x50>
   187c0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   187c4:	059a      	lsls	r2, r3, #22
   187c6:	d4ef      	bmi.n	187a8 <__smakebuf_r+0x18>
   187c8:	f023 0303 	bic.w	r3, r3, #3
   187cc:	f043 0302 	orr.w	r3, r3, #2
   187d0:	81a3      	strh	r3, [r4, #12]
   187d2:	f104 0347 	add.w	r3, r4, #71	; 0x47
   187d6:	6023      	str	r3, [r4, #0]
   187d8:	6123      	str	r3, [r4, #16]
   187da:	2301      	movs	r3, #1
   187dc:	6163      	str	r3, [r4, #20]
   187de:	e7e3      	b.n	187a8 <__smakebuf_r+0x18>
   187e0:	4b0d      	ldr	r3, [pc, #52]	; (18818 <__smakebuf_r+0x88>)
   187e2:	62b3      	str	r3, [r6, #40]	; 0x28
   187e4:	89a3      	ldrh	r3, [r4, #12]
   187e6:	6020      	str	r0, [r4, #0]
   187e8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   187ec:	81a3      	strh	r3, [r4, #12]
   187ee:	9b00      	ldr	r3, [sp, #0]
   187f0:	6163      	str	r3, [r4, #20]
   187f2:	9b01      	ldr	r3, [sp, #4]
   187f4:	6120      	str	r0, [r4, #16]
   187f6:	b15b      	cbz	r3, 18810 <__smakebuf_r+0x80>
   187f8:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   187fc:	4630      	mov	r0, r6
   187fe:	f008 f9d7 	bl	20bb0 <_isatty_r>
   18802:	b128      	cbz	r0, 18810 <__smakebuf_r+0x80>
   18804:	89a3      	ldrh	r3, [r4, #12]
   18806:	f023 0303 	bic.w	r3, r3, #3
   1880a:	f043 0301 	orr.w	r3, r3, #1
   1880e:	81a3      	strh	r3, [r4, #12]
   18810:	89a3      	ldrh	r3, [r4, #12]
   18812:	431d      	orrs	r5, r3
   18814:	81a5      	strh	r5, [r4, #12]
   18816:	e7c7      	b.n	187a8 <__smakebuf_r+0x18>
   18818:	00021f89 	.word	0x00021f89

Disassembly of section .text._Command_GatewayAddressSet%400:

0001881c <_Command_GatewayAddressSet>:
{
   1881c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1881e:	b083      	sub	sp, #12
   18820:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   18822:	6845      	ldr	r5, [r0, #4]
    if (argc != 3)
   18824:	2903      	cmp	r1, #3
   18826:	d00f      	beq.n	18848 <_Command_GatewayAddressSet+0x2c>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: setgw <interface> <ipv4/6 address> <validTime> \r\n");
   18828:	4e1a      	ldr	r6, [pc, #104]	; (18894 <_Command_GatewayAddressSet+0x78>)
   1882a:	6803      	ldr	r3, [r0, #0]
   1882c:	681b      	ldr	r3, [r3, #0]
   1882e:	f506 6155 	add.w	r1, r6, #3408	; 0xd50
   18832:	4628      	mov	r0, r5
   18834:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: setgw PIC32INT 192.168.0.1 \r\n");
   18836:	6823      	ldr	r3, [r4, #0]
   18838:	681b      	ldr	r3, [r3, #0]
   1883a:	f606 518c 	addw	r1, r6, #3468	; 0xd8c
   1883e:	4628      	mov	r0, r5
   18840:	4798      	blx	r3
}
   18842:	2000      	movs	r0, #0
   18844:	b003      	add	sp, #12
   18846:	bdf0      	pop	{r4, r5, r6, r7, pc}
   18848:	4616      	mov	r6, r2
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
   1884a:	6850      	ldr	r0, [r2, #4]
   1884c:	f005 f882 	bl	1d954 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
   18850:	4607      	mov	r7, r0
   18852:	b150      	cbz	r0, 1886a <_Command_GatewayAddressSet+0x4e>
    if (TCPIP_Helper_StringToIPAddress(argv[2], &ipGateway))
   18854:	a901      	add	r1, sp, #4
   18856:	68b0      	ldr	r0, [r6, #8]
   18858:	f7fa fb98 	bl	12f8c <TCPIP_Helper_StringToIPAddress>
   1885c:	b958      	cbnz	r0, 18876 <_Command_GatewayAddressSet+0x5a>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Invalid IP address string \r\n");
   1885e:	6823      	ldr	r3, [r4, #0]
   18860:	681b      	ldr	r3, [r3, #0]
   18862:	490d      	ldr	r1, [pc, #52]	; (18898 <_Command_GatewayAddressSet+0x7c>)
   18864:	4628      	mov	r0, r5
   18866:	4798      	blx	r3
        return false;
   18868:	e7eb      	b.n	18842 <_Command_GatewayAddressSet+0x26>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   1886a:	6823      	ldr	r3, [r4, #0]
   1886c:	681b      	ldr	r3, [r3, #0]
   1886e:	490b      	ldr	r1, [pc, #44]	; (1889c <_Command_GatewayAddressSet+0x80>)
   18870:	4628      	mov	r0, r5
   18872:	4798      	blx	r3
        return false;
   18874:	e7e5      	b.n	18842 <_Command_GatewayAddressSet+0x26>
        success = TCPIP_STACK_NetAddressGatewaySet(netH, &ipGateway);
   18876:	a901      	add	r1, sp, #4
   18878:	4638      	mov	r0, r7
   1887a:	f008 faf5 	bl	20e68 <TCPIP_STACK_NetAddressGatewaySet>
    (*pCmdIO->pCmdApi->msg)(cmdIoParam, success ? "Set gateway address OK\r\n" : "Set gateway address failed\r\n");
   1887e:	6823      	ldr	r3, [r4, #0]
   18880:	681b      	ldr	r3, [r3, #0]
   18882:	2800      	cmp	r0, #0
   18884:	4906      	ldr	r1, [pc, #24]	; (188a0 <_Command_GatewayAddressSet+0x84>)
   18886:	f101 021c 	add.w	r2, r1, #28
   1888a:	bf08      	it	eq
   1888c:	4611      	moveq	r1, r2
   1888e:	4628      	mov	r0, r5
   18890:	4798      	blx	r3
    return false;
   18892:	e7d6      	b.n	18842 <_Command_GatewayAddressSet+0x26>
   18894:	0000028c 	.word	0x0000028c
   18898:	0000103c 	.word	0x0000103c
   1889c:	00000da8 	.word	0x00000da8
   188a0:	00000fa0 	.word	0x00000fa0

Disassembly of section .text._DHCPPacketFilter%401:

000188a4 <_DHCPPacketFilter>:
{
   188a4:	b5f0      	push	{r4, r5, r6, r7, lr}
   188a6:	b083      	sub	sp, #12
   188a8:	4604      	mov	r4, r0
   188aa:	460f      	mov	r7, r1
    TCPIP_MAC_ADDR bcastAdd = { {0xff, 0xff, 0xff, 0xff, 0xff, 0xff} };
   188ac:	4b1c      	ldr	r3, [pc, #112]	; (18920 <_DHCPPacketFilter+0x7c>)
   188ae:	e893 0003 	ldmia.w	r3, {r0, r1}
   188b2:	9000      	str	r0, [sp, #0]
   188b4:	f8ad 1004 	strh.w	r1, [sp, #4]
    TCPIP_MAC_ETHERNET_HEADER* macHdr = (TCPIP_MAC_ETHERNET_HEADER*)pRxPkt->pMacLayer;
   188b8:	6966      	ldr	r6, [r4, #20]
    const uint8_t* netMacAddr = TCPIP_STACK_NetUpMACAddressGet((TCPIP_NET_IF*)pRxPkt->pktIf);
   188ba:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   188bc:	f008 ffa6 	bl	2180c <TCPIP_STACK_NetUpMACAddressGet>
    if(netMacAddr)
   188c0:	b350      	cbz	r0, 18918 <_DHCPPacketFilter+0x74>
   188c2:	4605      	mov	r5, r0
        if(memcmp(netMacAddr, macHdr->DestMACAddr.v, sizeof(macHdr->DestMACAddr)) == 0 || 
   188c4:	2206      	movs	r2, #6
   188c6:	4631      	mov	r1, r6
   188c8:	f008 fbbc 	bl	21044 <memcmp>
   188cc:	b128      	cbz	r0, 188da <_DHCPPacketFilter+0x36>
           memcmp(netMacAddr, bcastAdd.v, sizeof(bcastAdd)) == 0 )
   188ce:	2206      	movs	r2, #6
   188d0:	4669      	mov	r1, sp
   188d2:	4628      	mov	r0, r5
   188d4:	f008 fbb6 	bl	21044 <memcmp>
        if(memcmp(netMacAddr, macHdr->DestMACAddr.v, sizeof(macHdr->DestMACAddr)) == 0 || 
   188d8:	bb00      	cbnz	r0, 1891c <_DHCPPacketFilter+0x78>
            IPV4_HEADER* pHeader = (IPV4_HEADER*)pRxPkt->pNetLayer;
   188da:	69a3      	ldr	r3, [r4, #24]
            if(pHeader->Protocol == IP_PROT_UDP)
   188dc:	7a5a      	ldrb	r2, [r3, #9]
   188de:	2a11      	cmp	r2, #17
   188e0:	d002      	beq.n	188e8 <_DHCPPacketFilter+0x44>
    return false;
   188e2:	2000      	movs	r0, #0
}
   188e4:	b003      	add	sp, #12
   188e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
                UDP_HEADER* pUDPHdr = (UDP_HEADER*)(pRxPkt->pNetLayer + hdrlen);
   188e8:	19da      	adds	r2, r3, r7
                UDP_PORT destPort = TCPIP_Helper_ntohs(pUDPHdr->DestinationPort);
   188ea:	8851      	ldrh	r1, [r2, #2]
   188ec:	0a0a      	lsrs	r2, r1, #8
   188ee:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
                if(destPort == dhcpClientPort && srcPort == dhcpServerPort)
   188f2:	490c      	ldr	r1, [pc, #48]	; (18924 <_DHCPPacketFilter+0x80>)
   188f4:	8809      	ldrh	r1, [r1, #0]
   188f6:	b292      	uxth	r2, r2
   188f8:	4291      	cmp	r1, r2
   188fa:	d001      	beq.n	18900 <_DHCPPacketFilter+0x5c>
    return false;
   188fc:	2000      	movs	r0, #0
   188fe:	e7f1      	b.n	188e4 <_DHCPPacketFilter+0x40>
                UDP_PORT srcPort = TCPIP_Helper_ntohs(pUDPHdr->SourcePort);
   18900:	5bd8      	ldrh	r0, [r3, r7]
   18902:	0a03      	lsrs	r3, r0, #8
   18904:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                if(destPort == dhcpClientPort && srcPort == dhcpServerPort)
   18908:	4a07      	ldr	r2, [pc, #28]	; (18928 <_DHCPPacketFilter+0x84>)
   1890a:	8810      	ldrh	r0, [r2, #0]
   1890c:	b29b      	uxth	r3, r3
   1890e:	4298      	cmp	r0, r3
   18910:	bf14      	ite	ne
   18912:	2000      	movne	r0, #0
   18914:	2001      	moveq	r0, #1
   18916:	e7e5      	b.n	188e4 <_DHCPPacketFilter+0x40>
    return false;
   18918:	2000      	movs	r0, #0
   1891a:	e7e3      	b.n	188e4 <_DHCPPacketFilter+0x40>
   1891c:	2000      	movs	r0, #0
   1891e:	e7e1      	b.n	188e4 <_DHCPPacketFilter+0x40>
   18920:	0001e920 	.word	0x0001e920
   18924:	2000e71e 	.word	0x2000e71e
   18928:	2000e722 	.word	0x2000e722

Disassembly of section .text._DHCPSetLeaseTimeParams%402:

0001892c <_DHCPSetLeaseTimeParams>:
{
   1892c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   18930:	4606      	mov	r6, r0
    if(pDhcpData == 0 || pDhcpData->leaseTime.Val == 0)
   18932:	b131      	cbz	r1, 18942 <_DHCPSetLeaseTimeParams+0x16>
   18934:	460b      	mov	r3, r1
   18936:	690d      	ldr	r5, [r1, #16]
   18938:	b13d      	cbz	r5, 1894a <_DHCPSetLeaseTimeParams+0x1e>
    if(leaseTime < 2 * TCPIP_DHCP_LEASE_EXPIRE_FUZZ)
   1893a:	2d14      	cmp	r5, #20
   1893c:	bf38      	it	cc
   1893e:	2514      	movcc	r5, #20
   18940:	e004      	b.n	1894c <_DHCPSetLeaseTimeParams+0x20>
        t1Time = leaseTime >> 1;
   18942:	f04f 083c 	mov.w	r8, #60	; 0x3c
        leaseTime = TCPIP_DHCP_LEASE_TIME_DEFAULT;
   18946:	2578      	movs	r5, #120	; 0x78
   18948:	e009      	b.n	1895e <_DHCPSetLeaseTimeParams+0x32>
   1894a:	2578      	movs	r5, #120	; 0x78
    if(pDhcpData == 0 || pDhcpData->renewTime.Val == 0)
   1894c:	f8d3 8014 	ldr.w	r8, [r3, #20]
   18950:	f1b8 0f00 	cmp.w	r8, #0
   18954:	d101      	bne.n	1895a <_DHCPSetLeaseTimeParams+0x2e>
        t1Time = leaseTime >> 1;
   18956:	ea4f 0855 	mov.w	r8, r5, lsr #1
    if(pDhcpData == 0 || pDhcpData->rebindTime.Val == 0)
   1895a:	699f      	ldr	r7, [r3, #24]
   1895c:	b947      	cbnz	r7, 18970 <_DHCPSetLeaseTimeParams+0x44>
        if(leaseTime >= 0xffffffff / 7)
   1895e:	4b13      	ldr	r3, [pc, #76]	; (189ac <_DHCPSetLeaseTimeParams+0x80>)
   18960:	429d      	cmp	r5, r3
            t2Time = (leaseTime >> 3) * 7 ;
   18962:	bf87      	ittee	hi
   18964:	08ef      	lsrhi	r7, r5, #3
   18966:	ebc7 07c7 	rsbhi	r7, r7, r7, lsl #3
            t2Time = (leaseTime * 7) >> 3 ;
   1896a:	ebc5 07c5 	rsbls	r7, r5, r5, lsl #3
   1896e:	08ff      	lsrls	r7, r7, #3
   18970:	f002 f940 	bl	1abf4 <rand>
    pClient->t1Seconds = (t1Time - TCPIP_DHCP_LEASE_EXPIRE_FUZZ) + SYS_RANDOM_PseudoGet() %  (2 * TCPIP_DHCP_LEASE_EXPIRE_FUZZ);
   18974:	4c0e      	ldr	r4, [pc, #56]	; (189b0 <_DHCPSetLeaseTimeParams+0x84>)
   18976:	fba4 2300 	umull	r2, r3, r4, r0
   1897a:	091b      	lsrs	r3, r3, #4
   1897c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   18980:	eba0 0083 	sub.w	r0, r0, r3, lsl #2
   18984:	f1a8 080a 	sub.w	r8, r8, #10
   18988:	4440      	add	r0, r8
   1898a:	6130      	str	r0, [r6, #16]
   1898c:	f002 f932 	bl	1abf4 <rand>
    pClient->t2Seconds = (t2Time - TCPIP_DHCP_LEASE_EXPIRE_FUZZ) + SYS_RANDOM_PseudoGet() %  (2 * TCPIP_DHCP_LEASE_EXPIRE_FUZZ);
   18990:	fba4 3400 	umull	r3, r4, r4, r0
   18994:	0924      	lsrs	r4, r4, #4
   18996:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   1899a:	eba0 0484 	sub.w	r4, r0, r4, lsl #2
   1899e:	3f0a      	subs	r7, #10
   189a0:	443c      	add	r4, r7
   189a2:	6174      	str	r4, [r6, #20]
    pClient->tExpSeconds = leaseTime;
   189a4:	61b5      	str	r5, [r6, #24]
}
   189a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   189aa:	bf00      	nop
   189ac:	24924923 	.word	0x24924923
   189b0:	cccccccd 	.word	0xcccccccd

Disassembly of section .text._OAHashFindBkt%403:

000189b4 <_OAHashFindBkt>:
// implementation

// finds a entry that either contains the desired key
// or is empty and can be used to insert the key 
static OA_HASH_ENTRY* _OAHashFindBkt(OA_HASH_DCPT* pOH, const void* key)
{
   189b4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   189b8:	4604      	mov	r4, r0
   189ba:	460f      	mov	r7, r1
    probeStep = pOH->probeStep;
   189bc:	f8d0 8010 	ldr.w	r8, [r0, #16]
    size_t      probeStep;
    size_t      bkts = 0;

    probeStep = _OAHashProbeStep(pOH, key);
#if defined ( OA_HASH_DYNAMIC_KEY_MANIPULATION )
    bktIx = (*pOH->hashF)(pOH, key);
   189c0:	6943      	ldr	r3, [r0, #20]
   189c2:	4798      	blx	r3
#else
    bktIx = TCPIP_OAHASH_KeyHash(pOH, key);
#endif  // defined ( OA_HASH_DYNAMIC_KEY_MANIPULATION )

    while(bkts < pOH->hEntries)
   189c4:	68e3      	ldr	r3, [r4, #12]
   189c6:	2b00      	cmp	r3, #0
   189c8:	d035      	beq.n	18a36 <_OAHashFindBkt+0x82>
   189ca:	4605      	mov	r5, r0
    {
        pBkt = (OA_HASH_ENTRY*)((uint8_t*)(pOH->memBlk) + bktIx * pOH->hEntrySize);
   189cc:	68a3      	ldr	r3, [r4, #8]
   189ce:	fb03 f300 	mul.w	r3, r3, r0
   189d2:	6822      	ldr	r2, [r4, #0]
   189d4:	eb02 0903 	add.w	r9, r2, r3
        if(pBkt->flags.busy == 0)
   189d8:	5cd3      	ldrb	r3, [r2, r3]
   189da:	f013 0f01 	tst.w	r3, #1
   189de:	d025      	beq.n	18a2c <_OAHashFindBkt+0x78>
    size_t      bkts = 0;
   189e0:	2600      	movs	r6, #0
            pOH->fullSlots++;
            return pBkt;
        }

#if defined ( OA_HASH_DYNAMIC_KEY_MANIPULATION )
        if((*pOH->cmpF)(pOH, pBkt, key) == 0)
   189e2:	69e3      	ldr	r3, [r4, #28]
   189e4:	463a      	mov	r2, r7
   189e6:	4649      	mov	r1, r9
   189e8:	4620      	mov	r0, r4
   189ea:	4798      	blx	r3
   189ec:	b1d8      	cbz	r0, 18a26 <_OAHashFindBkt+0x72>
            return pBkt;
        }
#endif  // defined ( OA_HASH_DYNAMIC_KEY_MANIPULATION )

        // advance to the next hash slot
        bktIx += probeStep;
   189ee:	4445      	add	r5, r8
        if(bktIx >= pOH->hEntries)
   189f0:	68e3      	ldr	r3, [r4, #12]
   189f2:	42ab      	cmp	r3, r5
        {
            bktIx -= pOH->hEntries;
   189f4:	bf98      	it	ls
   189f6:	1aed      	subls	r5, r5, r3
        }

        bkts++;
   189f8:	3601      	adds	r6, #1
    while(bkts < pOH->hEntries)
   189fa:	42b3      	cmp	r3, r6
   189fc:	d918      	bls.n	18a30 <_OAHashFindBkt+0x7c>
        pBkt = (OA_HASH_ENTRY*)((uint8_t*)(pOH->memBlk) + bktIx * pOH->hEntrySize);
   189fe:	68a3      	ldr	r3, [r4, #8]
   18a00:	fb03 f305 	mul.w	r3, r3, r5
   18a04:	6822      	ldr	r2, [r4, #0]
   18a06:	eb02 0903 	add.w	r9, r2, r3
        if(pBkt->flags.busy == 0)
   18a0a:	5cd3      	ldrb	r3, [r2, r3]
   18a0c:	f013 0f01 	tst.w	r3, #1
   18a10:	d1e7      	bne.n	189e2 <_OAHashFindBkt+0x2e>
            (*pOH->cpyF)(pOH, pBkt, key);   // set the key
   18a12:	6a23      	ldr	r3, [r4, #32]
   18a14:	463a      	mov	r2, r7
   18a16:	4649      	mov	r1, r9
   18a18:	4620      	mov	r0, r4
   18a1a:	4798      	blx	r3
            pBkt->probeCount = bkts;
   18a1c:	f8a9 6002 	strh.w	r6, [r9, #2]
            pOH->fullSlots++;
   18a20:	6a63      	ldr	r3, [r4, #36]	; 0x24
   18a22:	3301      	adds	r3, #1
   18a24:	6263      	str	r3, [r4, #36]	; 0x24
    }
    
    return 0;   // cache full, not found
}
   18a26:	4648      	mov	r0, r9
   18a28:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    size_t      bkts = 0;
   18a2c:	2600      	movs	r6, #0
   18a2e:	e7f0      	b.n	18a12 <_OAHashFindBkt+0x5e>
    return 0;   // cache full, not found
   18a30:	f04f 0900 	mov.w	r9, #0
   18a34:	e7f7      	b.n	18a26 <_OAHashFindBkt+0x72>
   18a36:	f04f 0900 	mov.w	r9, #0
   18a3a:	e7f4      	b.n	18a26 <_OAHashFindBkt+0x72>

Disassembly of section .text.SYS_CMDIO_ADD%404:

00018a3c <SYS_CMDIO_ADD>:
{
   18a3c:	b570      	push	{r4, r5, r6, lr}
   18a3e:	4606      	mov	r6, r0
   18a40:	460d      	mov	r5, r1
    pNewIo = (SYS_CMD_IO_DCPT*)OSAL_Malloc(sizeof(*pNewIo));
   18a42:	f44f 7012 	mov.w	r0, #584	; 0x248
   18a46:	f009 fb1c 	bl	22082 <OSAL_Malloc>
    if (!pNewIo)
   18a4a:	4604      	mov	r4, r0
   18a4c:	2800      	cmp	r0, #0
   18a4e:	d030      	beq.n	18ab2 <SYS_CMDIO_ADD+0x76>
	memset(pNewIo, 0, sizeof(*pNewIo));
   18a50:	f44f 7212 	mov.w	r2, #584	; 0x248
   18a54:	2100      	movs	r1, #0
   18a56:	f009 f891 	bl	21b7c <memset>
    pNewIo->devNode.pCmdApi = opApi;
   18a5a:	6026      	str	r6, [r4, #0]
    pNewIo->devNode.cmdIoParam = cmdIoParam;
   18a5c:	6065      	str	r5, [r4, #4]
    pNewIo->cmdPnt = pNewIo->cmdEnd = pNewIo->cmdBuff;
   18a5e:	f104 0320 	add.w	r3, r4, #32
   18a62:	61e3      	str	r3, [r4, #28]
   18a64:	61a3      	str	r3, [r4, #24]
    for(ix = 0; ix < sizeof(pNewIo->histArray) / sizeof(*pNewIo->histArray); ix++)
   18a66:	f104 03d8 	add.w	r3, r4, #216	; 0xd8
   18a6a:	f504 7112 	add.w	r1, r4, #584	; 0x248
   18a6e:	e008      	b.n	18a82 <SYS_CMDIO_ADD+0x46>
        pL->head = pL->tail = pN;
   18a70:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
   18a74:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
        pN->next = pN->prev = pN;
   18a78:	605b      	str	r3, [r3, #4]
   18a7a:	601b      	str	r3, [r3, #0]
   18a7c:	335c      	adds	r3, #92	; 0x5c
    for(ix = 0; ix < sizeof(pNewIo->histArray) / sizeof(*pNewIo->histArray); ix++)
   18a7e:	428b      	cmp	r3, r1
   18a80:	d00e      	beq.n	18aa0 <SYS_CMDIO_ADD+0x64>
    if(pL->head == 0)
   18a82:	f8d4 20cc 	ldr.w	r2, [r4, #204]	; 0xcc
   18a86:	2a00      	cmp	r2, #0
   18a88:	d0f2      	beq.n	18a70 <SYS_CMDIO_ADD+0x34>
        pN->next = pL->head;
   18a8a:	601a      	str	r2, [r3, #0]
        pN->prev = pL->tail;
   18a8c:	f8d4 20d0 	ldr.w	r2, [r4, #208]	; 0xd0
   18a90:	605a      	str	r2, [r3, #4]
        pL->tail->next = pN;
   18a92:	6013      	str	r3, [r2, #0]
        pL->head->prev = pN;
   18a94:	f8d4 20cc 	ldr.w	r2, [r4, #204]	; 0xcc
   18a98:	6053      	str	r3, [r2, #4]
        pL->head = pN;
   18a9a:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
   18a9e:	e7ed      	b.n	18a7c <SYS_CMDIO_ADD+0x40>
    pNewIo->next = 0;
   18aa0:	2300      	movs	r3, #0
   18aa2:	60a3      	str	r3, [r4, #8]
    if(cmdIODevList.head == 0)
   18aa4:	4b06      	ldr	r3, [pc, #24]	; (18ac0 <SYS_CMDIO_ADD+0x84>)
   18aa6:	681b      	ldr	r3, [r3, #0]
   18aa8:	b12b      	cbz	r3, 18ab6 <SYS_CMDIO_ADD+0x7a>
        cmdIODevList.tail->next = pNewIo;
   18aaa:	4b05      	ldr	r3, [pc, #20]	; (18ac0 <SYS_CMDIO_ADD+0x84>)
   18aac:	685a      	ldr	r2, [r3, #4]
   18aae:	6094      	str	r4, [r2, #8]
        cmdIODevList.tail = pNewIo;
   18ab0:	605c      	str	r4, [r3, #4]
}
   18ab2:	4620      	mov	r0, r4
   18ab4:	bd70      	pop	{r4, r5, r6, pc}
        cmdIODevList.head = pNewIo;
   18ab6:	4b02      	ldr	r3, [pc, #8]	; (18ac0 <SYS_CMDIO_ADD+0x84>)
   18ab8:	601c      	str	r4, [r3, #0]
        cmdIODevList.tail = pNewIo;
   18aba:	605c      	str	r4, [r3, #4]
   18abc:	e7f9      	b.n	18ab2 <SYS_CMDIO_ADD+0x76>
   18abe:	bf00      	nop
   18ac0:	2000e560 	.word	0x2000e560

Disassembly of section .text.__pic32c_data_initialization%405:

00018ac4 <__pic32c_data_initialization>:
   18ac4:	4b1e      	ldr	r3, [pc, #120]	; (18b40 <__pic32c_data_initialization+0x7c>)
   18ac6:	4a1f      	ldr	r2, [pc, #124]	; (18b44 <__pic32c_data_initialization+0x80>)
   18ac8:	4293      	cmp	r3, r2
   18aca:	b4f0      	push	{r4, r5, r6, r7}
   18acc:	bf38      	it	cc
   18ace:	2100      	movcc	r1, #0
   18ad0:	d203      	bcs.n	18ada <__pic32c_data_initialization+0x16>
   18ad2:	f803 1b01 	strb.w	r1, [r3], #1
   18ad6:	4293      	cmp	r3, r2
   18ad8:	d1fb      	bne.n	18ad2 <__pic32c_data_initialization+0xe>
   18ada:	4a1b      	ldr	r2, [pc, #108]	; (18b48 <__pic32c_data_initialization+0x84>)
   18adc:	e9d2 0100 	ldrd	r0, r1, [r2]
   18ae0:	ea50 0301 	orrs.w	r3, r0, r1
   18ae4:	f04f 0600 	mov.w	r6, #0
   18ae8:	d010      	beq.n	18b0c <__pic32c_data_initialization+0x48>
   18aea:	6894      	ldr	r4, [r2, #8]
   18aec:	4603      	mov	r3, r0
   18aee:	f102 070c 	add.w	r7, r2, #12
   18af2:	b96c      	cbnz	r4, 18b10 <__pic32c_data_initialization+0x4c>
   18af4:	b121      	cbz	r1, 18b00 <__pic32c_data_initialization+0x3c>
   18af6:	4401      	add	r1, r0
   18af8:	f803 6b01 	strb.w	r6, [r3], #1
   18afc:	4299      	cmp	r1, r3
   18afe:	d1fb      	bne.n	18af8 <__pic32c_data_initialization+0x34>
   18b00:	463a      	mov	r2, r7
   18b02:	e9d2 0100 	ldrd	r0, r1, [r2]
   18b06:	ea50 0301 	orrs.w	r3, r0, r1
   18b0a:	d1ee      	bne.n	18aea <__pic32c_data_initialization+0x26>
   18b0c:	bcf0      	pop	{r4, r5, r6, r7}
   18b0e:	4770      	bx	lr
   18b10:	b159      	cbz	r1, 18b2a <__pic32c_data_initialization+0x66>
   18b12:	f101 030c 	add.w	r3, r1, #12
   18b16:	380c      	subs	r0, #12
   18b18:	1a80      	subs	r0, r0, r2
   18b1a:	441a      	add	r2, r3
   18b1c:	463b      	mov	r3, r7
   18b1e:	181c      	adds	r4, r3, r0
   18b20:	f813 5b01 	ldrb.w	r5, [r3], #1
   18b24:	7025      	strb	r5, [r4, #0]
   18b26:	4293      	cmp	r3, r2
   18b28:	d1f9      	bne.n	18b1e <__pic32c_data_initialization+0x5a>
   18b2a:	f011 0303 	ands.w	r3, r1, #3
   18b2e:	bf18      	it	ne
   18b30:	2301      	movne	r3, #1
   18b32:	eb03 0191 	add.w	r1, r3, r1, lsr #2
   18b36:	eb07 0781 	add.w	r7, r7, r1, lsl #2
   18b3a:	463a      	mov	r2, r7
   18b3c:	e7e1      	b.n	18b02 <__pic32c_data_initialization+0x3e>
   18b3e:	bf00      	nop
   18b40:	20000000 	.word	0x20000000
   18b44:	20000004 	.word	0x20000004
   18b48:	000034f4 	.word	0x000034f4

Disassembly of section .text.TCPIP_IPV4_MacPacketSwitchTxToRx%406:

00018b4c <TCPIP_IPV4_MacPacketSwitchTxToRx>:
//          - the destination addresses is set as the MAC packet source address
//          - the source address is the MAC address of the coresponding packet interface (which should be set!) 
//          - data segment is re-adjusted with the MAC header length
// TCPIP_MAC_PKT_FLAG_TX flag is set
void TCPIP_IPV4_MacPacketSwitchTxToRx(TCPIP_MAC_PACKET* pRxPkt, bool setChecksum, bool setMac)
{
   18b4c:	b570      	push	{r4, r5, r6, lr}
   18b4e:	4605      	mov	r5, r0
   18b50:	4616      	mov	r6, r2
    IPV4_HEADER* pIpv4Hdr;

    pIpv4Hdr = (IPV4_HEADER*)pRxPkt->pNetLayer;
   18b52:	6984      	ldr	r4, [r0, #24]
    pIpv4Hdr->DestAddress.Val = pIpv4Hdr->SourceAddress.Val;
   18b54:	68e3      	ldr	r3, [r4, #12]
   18b56:	6123      	str	r3, [r4, #16]
    return pNetIf->netIPAddr.Val;
   18b58:	6a83      	ldr	r3, [r0, #40]	; 0x28
   18b5a:	685b      	ldr	r3, [r3, #4]
    pIpv4Hdr->SourceAddress.Val = _TCPIPStackNetAddress((TCPIP_NET_IF*)pRxPkt->pktIf);
   18b5c:	60e3      	str	r3, [r4, #12]

    pIpv4Hdr->TotalLength = TCPIP_Helper_htons(pIpv4Hdr->TotalLength);
   18b5e:	8862      	ldrh	r2, [r4, #2]
   18b60:	0a13      	lsrs	r3, r2, #8
   18b62:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   18b66:	8063      	strh	r3, [r4, #2]
    pIpv4Hdr->FragmentInfo.val = TCPIP_Helper_htons(pIpv4Hdr->FragmentInfo.val);
   18b68:	88e2      	ldrh	r2, [r4, #6]
   18b6a:	0a13      	lsrs	r3, r2, #8
   18b6c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   18b70:	80e3      	strh	r3, [r4, #6]
    if(pIpv4Hdr->TimeToLive == 0)
   18b72:	7a23      	ldrb	r3, [r4, #8]
   18b74:	b90b      	cbnz	r3, 18b7a <TCPIP_IPV4_MacPacketSwitchTxToRx+0x2e>
    {
        pIpv4Hdr->TimeToLive = IPV4_DEFAULT_TTL;
   18b76:	2364      	movs	r3, #100	; 0x64
   18b78:	7223      	strb	r3, [r4, #8]
    }
    uint8_t headerLen = pIpv4Hdr->IHL << 2;  
    pRxPkt->pDSeg->segLen += headerLen;
   18b7a:	6928      	ldr	r0, [r5, #16]
    uint8_t headerLen = pIpv4Hdr->IHL << 2;  
   18b7c:	7823      	ldrb	r3, [r4, #0]
   18b7e:	009b      	lsls	r3, r3, #2
    pRxPkt->pDSeg->segLen += headerLen;
   18b80:	f003 033c 	and.w	r3, r3, #60	; 0x3c
   18b84:	8982      	ldrh	r2, [r0, #12]
   18b86:	441a      	add	r2, r3
   18b88:	8182      	strh	r2, [r0, #12]

    if(setChecksum)
   18b8a:	b929      	cbnz	r1, 18b98 <TCPIP_IPV4_MacPacketSwitchTxToRx+0x4c>
    {
        pIpv4Hdr->HeaderChecksum = 0;
        pIpv4Hdr->HeaderChecksum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pIpv4Hdr, headerLen, 0);
    }

    if(setMac)
   18b8c:	b966      	cbnz	r6, 18ba8 <TCPIP_IPV4_MacPacketSwitchTxToRx+0x5c>
        memcpy(&macHdr->SourceMACAddr, _TCPIPStack_NetMACAddressGet((TCPIP_NET_IF*)pRxPkt->pktIf), sizeof(TCPIP_MAC_ADDR));

        pRxPkt->pDSeg->segLen += sizeof(TCPIP_MAC_ETHERNET_HEADER);
    }

    pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_TX; 
   18b8e:	8c6b      	ldrh	r3, [r5, #34]	; 0x22
   18b90:	f043 0302 	orr.w	r3, r3, #2
   18b94:	846b      	strh	r3, [r5, #34]	; 0x22
}
   18b96:	bd70      	pop	{r4, r5, r6, pc}
        pIpv4Hdr->HeaderChecksum = 0;
   18b98:	2200      	movs	r2, #0
   18b9a:	8162      	strh	r2, [r4, #10]
        pIpv4Hdr->HeaderChecksum = TCPIP_Helper_CalcIPChecksum((uint8_t*)pIpv4Hdr, headerLen, 0);
   18b9c:	4619      	mov	r1, r3
   18b9e:	4620      	mov	r0, r4
   18ba0:	f001 fb8c 	bl	1a2bc <TCPIP_Helper_CalcIPChecksum>
   18ba4:	8160      	strh	r0, [r4, #10]
   18ba6:	e7f1      	b.n	18b8c <TCPIP_IPV4_MacPacketSwitchTxToRx+0x40>
        macHdr = (TCPIP_MAC_ETHERNET_HEADER*)pRxPkt->pMacLayer;
   18ba8:	6969      	ldr	r1, [r5, #20]
        memcpy(&macHdr->DestMACAddr, &macHdr->SourceMACAddr, sizeof(TCPIP_MAC_ADDR));
   18baa:	460a      	mov	r2, r1
   18bac:	f852 3f06 	ldr.w	r3, [r2, #6]!
   18bb0:	600b      	str	r3, [r1, #0]
   18bb2:	8893      	ldrh	r3, [r2, #4]
   18bb4:	808b      	strh	r3, [r1, #4]
        memcpy(&macHdr->SourceMACAddr, _TCPIPStack_NetMACAddressGet((TCPIP_NET_IF*)pRxPkt->pktIf), sizeof(TCPIP_MAC_ADDR));
   18bb6:	6aab      	ldr	r3, [r5, #40]	; 0x28
    return pNetIf ? pNetIf->netMACAddr.v : 0;
   18bb8:	b103      	cbz	r3, 18bbc <TCPIP_IPV4_MacPacketSwitchTxToRx+0x70>
   18bba:	333c      	adds	r3, #60	; 0x3c
   18bbc:	6818      	ldr	r0, [r3, #0]
   18bbe:	f8c1 0006 	str.w	r0, [r1, #6]
   18bc2:	889b      	ldrh	r3, [r3, #4]
   18bc4:	8093      	strh	r3, [r2, #4]
        pRxPkt->pDSeg->segLen += sizeof(TCPIP_MAC_ETHERNET_HEADER);
   18bc6:	692a      	ldr	r2, [r5, #16]
   18bc8:	8993      	ldrh	r3, [r2, #12]
   18bca:	330e      	adds	r3, #14
   18bcc:	8193      	strh	r3, [r2, #12]
   18bce:	e7de      	b.n	18b8e <TCPIP_IPV4_MacPacketSwitchTxToRx+0x42>

Disassembly of section .text.TCPIP_STACK_NetAddressSet%407:

00018bd0 <TCPIP_STACK_NetAddressSet>:
{
   18bd0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   18bd4:	4604      	mov	r4, r0
   18bd6:	460f      	mov	r7, r1
   18bd8:	4690      	mov	r8, r2
   18bda:	4699      	mov	r9, r3
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   18bdc:	2000      	movs	r0, #0
   18bde:	f008 fc5d 	bl	2149c <OSAL_CRIT_Enter>
   18be2:	4605      	mov	r5, r0
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   18be4:	b124      	cbz	r4, 18bf0 <TCPIP_STACK_NetAddressSet+0x20>
   18be6:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   18bea:	f013 0f40 	tst.w	r3, #64	; 0x40
   18bee:	d105      	bne.n	18bfc <TCPIP_STACK_NetAddressSet+0x2c>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   18bf0:	4629      	mov	r1, r5
   18bf2:	2000      	movs	r0, #0
   18bf4:	f008 fd81 	bl	216fa <OSAL_CRIT_Leave>
   18bf8:	2600      	movs	r6, #0
   18bfa:	e028      	b.n	18c4e <TCPIP_STACK_NetAddressSet+0x7e>
    if(pNetIf != 0 && TCPIP_STACK_AddressServiceCanStart(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_NONE))
   18bfc:	2100      	movs	r1, #0
   18bfe:	4620      	mov	r0, r4
   18c00:	f008 fd65 	bl	216ce <TCPIP_STACK_AddressServiceCanStart>
   18c04:	4606      	mov	r6, r0
   18c06:	2800      	cmp	r0, #0
   18c08:	d0f2      	beq.n	18bf0 <TCPIP_STACK_NetAddressSet+0x20>
    if(ipAddress)
   18c0a:	b16f      	cbz	r7, 18c28 <TCPIP_STACK_NetAddressSet+0x58>
        pNetIf->netIPAddr.Val = ipAddress->Val;
   18c0c:	683b      	ldr	r3, [r7, #0]
   18c0e:	6063      	str	r3, [r4, #4]
        if(setDefault)
   18c10:	f1b9 0f00 	cmp.w	r9, #0
   18c14:	d008      	beq.n	18c28 <TCPIP_STACK_NetAddressSet+0x58>
            pNetIf->DefaultIPAddr.Val = ipAddress->Val;
   18c16:	61a3      	str	r3, [r4, #24]
    if(mask)
   18c18:	f1b8 0f00 	cmp.w	r8, #0
   18c1c:	d00d      	beq.n	18c3a <TCPIP_STACK_NetAddressSet+0x6a>
        pNetIf->netMask.Val = mask->Val;
   18c1e:	f8d8 3000 	ldr.w	r3, [r8]
   18c22:	60a3      	str	r3, [r4, #8]
            pNetIf->DefaultMask.Val = mask->Val;
   18c24:	61e3      	str	r3, [r4, #28]
   18c26:	e008      	b.n	18c3a <TCPIP_STACK_NetAddressSet+0x6a>
    if(mask)
   18c28:	f1b8 0f00 	cmp.w	r8, #0
   18c2c:	d005      	beq.n	18c3a <TCPIP_STACK_NetAddressSet+0x6a>
        pNetIf->netMask.Val = mask->Val;
   18c2e:	f8d8 3000 	ldr.w	r3, [r8]
   18c32:	60a3      	str	r3, [r4, #8]
        if(setDefault)
   18c34:	f1b9 0f00 	cmp.w	r9, #0
   18c38:	d1f4      	bne.n	18c24 <TCPIP_STACK_NetAddressSet+0x54>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   18c3a:	4629      	mov	r1, r5
   18c3c:	2000      	movs	r0, #0
   18c3e:	f008 fd5c 	bl	216fa <OSAL_CRIT_Leave>
    pNetIf->Flags.bInConfig = config;
   18c42:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   18c46:	f36f 1304 	bfc	r3, #4, #1
   18c4a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
}
   18c4e:	4630      	mov	r0, r6
   18c50:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

Disassembly of section .text._TCPIP_PKT_PacketAlloc%408:

00018c54 <_TCPIP_PKT_PacketAlloc>:

#else
// regular allocation functions, non-debug
// they don't take a module Id parameter; otherwise exactly the same functions
TCPIP_MAC_PACKET* _TCPIP_PKT_PacketAlloc(uint16_t pktLen, uint16_t segLoadLen, TCPIP_MAC_PACKET_FLAGS flags)
{
   18c54:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   18c58:	4688      	mov	r8, r1
   18c5a:	4617      	mov	r7, r2
    if(pktLen < sizeof(TCPIP_MAC_PACKET))
    {
        pktLen = sizeof(TCPIP_MAC_PACKET);
    }

    pktUpLen = (((pktLen + 3) >> 2) << 2);     // 32 bits round up
   18c5c:	2834      	cmp	r0, #52	; 0x34
   18c5e:	bf38      	it	cc
   18c60:	2034      	movcc	r0, #52	; 0x34
   18c62:	1cc3      	adds	r3, r0, #3
   18c64:	f023 0303 	bic.w	r3, r3, #3
   18c68:	b29c      	uxth	r4, r3
    // segment size, multiple of cache line size
    segAlignSize = ((segLoadLen + sizeof(TCPIP_MAC_ETHERNET_HEADER) + TCPIP_SEGMENT_CACHE_ALIGN_SIZE  - 1) / TCPIP_SEGMENT_CACHE_ALIGN_SIZE) * TCPIP_SEGMENT_CACHE_ALIGN_SIZE;
   18c6a:	f101 051d 	add.w	r5, r1, #29
   18c6e:	f025 050f 	bic.w	r5, r5, #15
   18c72:	b2ad      	uxth	r5, r5
    // segment allocation size, extra cache line so that the segBuffer can start on a cache line boundary
    segAllocSize = segAlignSize + _TCPIP_MAC_DATA_SEGMENT_GAP_SIZE + TCPIP_MAC_PAYLOAD_OFFSET + TCPIP_SEGMENT_CACHE_ALIGN_SIZE; 
    // total allocation size
    allocLen = pktUpLen + sizeof(*pSeg) + segAllocSize;

    pPkt = (TCPIP_MAC_PACKET*)TCPIP_HEAP_Malloc(pktMemH, allocLen);
   18c74:	4b17      	ldr	r3, [pc, #92]	; (18cd4 <_TCPIP_PKT_PacketAlloc+0x80>)
   18c76:	6818      	ldr	r0, [r3, #0]
    allocLen = pktUpLen + sizeof(*pSeg) + segAllocSize;
   18c78:	f105 0132 	add.w	r1, r5, #50	; 0x32
   18c7c:	4421      	add	r1, r4
    pPkt = (TCPIP_MAC_PACKET*)TCPIP_HEAP_Malloc(pktMemH, allocLen);
   18c7e:	b289      	uxth	r1, r1
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
   18c80:	6843      	ldr	r3, [r0, #4]
   18c82:	4798      	blx	r3

    if(pPkt)
   18c84:	4606      	mov	r6, r0
   18c86:	b308      	cbz	r0, 18ccc <_TCPIP_PKT_PacketAlloc+0x78>
    {   
        // clear the TCPIP_MAC_PACKET and 1st segment fields
        // populate the 1st segment
        memset(pPkt, 0, pktUpLen + sizeof(*pSeg));
   18c88:	f104 0218 	add.w	r2, r4, #24
   18c8c:	2100      	movs	r1, #0
   18c8e:	f008 ff75 	bl	21b7c <memset>
        pSeg = (TCPIP_MAC_DATA_SEGMENT*)((uint8_t*)pPkt + pktUpLen);
   18c92:	4434      	add	r4, r6

        pSeg->segSize = segAlignSize;
   18c94:	81e5      	strh	r5, [r4, #14]
    segAllocSize = segAlignSize + _TCPIP_MAC_DATA_SEGMENT_GAP_SIZE + TCPIP_MAC_PAYLOAD_OFFSET + TCPIP_SEGMENT_CACHE_ALIGN_SIZE; 
   18c96:	351a      	adds	r5, #26
        pSeg->segAllocSize = segAllocSize;
   18c98:	8265      	strh	r5, [r4, #18]
        pSeg->segBuffer = (uint8_t*)(pSeg + 1) + _TCPIP_MAC_DATA_SEGMENT_GAP_SIZE;
        // cache-align the data segment
        pSeg->segBuffer = (uint8_t*)((((uint32_t)pSeg->segBuffer + TCPIP_SEGMENT_CACHE_ALIGN_SIZE - 1) / TCPIP_SEGMENT_CACHE_ALIGN_SIZE) * TCPIP_SEGMENT_CACHE_ALIGN_SIZE);
   18c9a:	f104 022f 	add.w	r2, r4, #47	; 0x2f
   18c9e:	f022 020f 	bic.w	r2, r2, #15
   18ca2:	6062      	str	r2, [r4, #4]
        // set the pointer to the packet that segment belongs to
        TCPIP_MAC_SEGMENT_GAP_DCPT* pGap = (TCPIP_MAC_SEGMENT_GAP_DCPT*)(pSeg->segBuffer + _TCPIP_MAC_GAP_OFFSET);
        pGap->segmentPktPtr = pPkt;
   18ca4:	f842 6c08 	str.w	r6, [r2, #-8]

        pSeg->segFlags = TCPIP_MAC_SEG_FLAG_STATIC; // embedded in TCPIP_MAC_PACKET itself
   18ca8:	2201      	movs	r2, #1
   18caa:	8222      	strh	r2, [r4, #16]
        pPkt->pDSeg = pSeg;
   18cac:	6134      	str	r4, [r6, #16]

        pSeg->segLoad = pSeg->segBuffer + TCPIP_MAC_PAYLOAD_OFFSET;
   18cae:	6862      	ldr	r2, [r4, #4]
   18cb0:	1c91      	adds	r1, r2, #2
   18cb2:	60a1      	str	r1, [r4, #8]
        pPkt->pMacLayer = pSeg->segLoad;
   18cb4:	6171      	str	r1, [r6, #20]
        pPkt->pktFlags = flags & (~TCPIP_MAC_PKT_FLAG_STATIC);  // this packet is dynamically allocated
   18cb6:	f027 0701 	bic.w	r7, r7, #1
   18cba:	8477      	strh	r7, [r6, #34]	; 0x22
        if(segLoadLen)
   18cbc:	f1b8 0f00 	cmp.w	r8, #0
   18cc0:	d001      	beq.n	18cc6 <_TCPIP_PKT_PacketAlloc+0x72>
        {
            pPkt->pNetLayer = pPkt->pMacLayer + sizeof(TCPIP_MAC_ETHERNET_HEADER);
   18cc2:	3210      	adds	r2, #16
   18cc4:	61b2      	str	r2, [r6, #24]
        }
        pPkt->pktPriority = 0; // set the default priority
   18cc6:	2300      	movs	r3, #0
   18cc8:	f886 302d 	strb.w	r3, [r6, #45]	; 0x2d

    }

    return pPkt;
}
   18ccc:	4630      	mov	r0, r6
   18cce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   18cd2:	bf00      	nop
   18cd4:	2000e658 	.word	0x2000e658

Disassembly of section .text.gfx_mono_print_scroll%409:

00018cd8 <gfx_mono_print_scroll>:

extern struct font sysfont;

#define PRINT_BUFF (256)

void gfx_mono_print_scroll(const char* format, ...) {
   18cd8:	b40f      	push	{r0, r1, r2, r3}
   18cda:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   18cde:	b0cb      	sub	sp, #300	; 0x12c
   18ce0:	ab52      	add	r3, sp, #328	; 0x148
   18ce2:	f853 2b04 	ldr.w	r2, [r3], #4
    char OutputBuffer[PRINT_BUFF];
    char LinePrintBuffer[22];
    int ix;
    size_t len = 0;
    va_list args = {0};
    va_start(args, format);
   18ce6:	9303      	str	r3, [sp, #12]
    len = vsnprintf(OutputBuffer, PRINT_BUFF, format, args);
   18ce8:	f44f 7180 	mov.w	r1, #256	; 0x100
   18cec:	a80a      	add	r0, sp, #40	; 0x28
   18cee:	f008 f9d3 	bl	21098 <vsniprintf>
    va_end(args);

    for (ix = 0; ix < len; ix += 21) {
   18cf2:	b358      	cbz	r0, 18d4c <gfx_mono_print_scroll+0x74>
   18cf4:	4681      	mov	r9, r0
   18cf6:	4606      	mov	r6, r0
   18cf8:	ad0a      	add	r5, sp, #40	; 0x28
   18cfa:	2400      	movs	r4, #0
        gfx_mono_scroll_Line_6x7();
        memset(LinePrintBuffer, 0x20, 22);
        int temp_len;
        if (len > 21) {
            temp_len = 21;
   18cfc:	f04f 0815 	mov.w	r8, #21
            }
        } else {
            temp_len = len;
        }
        memcpy(LinePrintBuffer, &OutputBuffer[ix], temp_len);
        gfx_mono_draw_string_n(LinePrintBuffer, 21, 0, 24, &sysfont);
   18d00:	4f15      	ldr	r7, [pc, #84]	; (18d58 <gfx_mono_print_scroll+0x80>)
   18d02:	e00f      	b.n	18d24 <gfx_mono_print_scroll+0x4c>
            temp_len = len;
   18d04:	464a      	mov	r2, r9
        memcpy(LinePrintBuffer, &OutputBuffer[ix], temp_len);
   18d06:	4629      	mov	r1, r5
   18d08:	a804      	add	r0, sp, #16
   18d0a:	f008 f9a9 	bl	21060 <memcpy>
        gfx_mono_draw_string_n(LinePrintBuffer, 21, 0, 24, &sysfont);
   18d0e:	9700      	str	r7, [sp, #0]
   18d10:	2318      	movs	r3, #24
   18d12:	2200      	movs	r2, #0
   18d14:	4641      	mov	r1, r8
   18d16:	a804      	add	r0, sp, #16
   18d18:	f000 fcda 	bl	196d0 <gfx_mono_draw_string_n>
    for (ix = 0; ix < len; ix += 21) {
   18d1c:	3415      	adds	r4, #21
   18d1e:	3515      	adds	r5, #21
   18d20:	42a6      	cmp	r6, r4
   18d22:	d913      	bls.n	18d4c <gfx_mono_print_scroll+0x74>
        gfx_mono_scroll_Line_6x7();
   18d24:	f005 ffa0 	bl	1ec68 <gfx_mono_scroll_Line_6x7>
        memset(LinePrintBuffer, 0x20, 22);
   18d28:	f04f 3320 	mov.w	r3, #538976288	; 0x20202020
   18d2c:	9304      	str	r3, [sp, #16]
   18d2e:	9305      	str	r3, [sp, #20]
   18d30:	9306      	str	r3, [sp, #24]
   18d32:	9307      	str	r3, [sp, #28]
   18d34:	9308      	str	r3, [sp, #32]
   18d36:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
        if (len > 21) {
   18d3a:	2e15      	cmp	r6, #21
   18d3c:	d9e2      	bls.n	18d04 <gfx_mono_print_scroll+0x2c>
            if (ix > 0) {
   18d3e:	2c00      	cmp	r4, #0
   18d40:	dd02      	ble.n	18d48 <gfx_mono_print_scroll+0x70>
                temp_len = len - 21;
   18d42:	f1a6 0215 	sub.w	r2, r6, #21
   18d46:	e7de      	b.n	18d06 <gfx_mono_print_scroll+0x2e>
            temp_len = 21;
   18d48:	4642      	mov	r2, r8
   18d4a:	e7dc      	b.n	18d06 <gfx_mono_print_scroll+0x2e>
    }
}
   18d4c:	b04b      	add	sp, #300	; 0x12c
   18d4e:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
   18d52:	b004      	add	sp, #16
   18d54:	4770      	bx	lr
   18d56:	bf00      	nop
   18d58:	2000e54c 	.word	0x2000e54c

Disassembly of section .text.DRV_PIC32CGMAC_LibTxAckErrPacket%410:

00018d5c <DRV_PIC32CGMAC_LibTxAckErrPacket>:
{
   18d5c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18d60:	b083      	sub	sp, #12
    DRV_PIC32CGMAC_HW_TXDCPT *pTxDesc = pMACDrv->sGmacData.gmac_queue[queueIdx].pTxDesc;
   18d62:	4688      	mov	r8, r1
   18d64:	232c      	movs	r3, #44	; 0x2c
   18d66:	fb03 0101 	mla	r1, r3, r1, r0
   18d6a:	f8d1 70a0 	ldr.w	r7, [r1, #160]	; 0xa0
	uint16_t tailIndex = pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescTail;
   18d6e:	f8b1 40b4 	ldrh.w	r4, [r1, #180]	; 0xb4
	uint16_t headIndex = pMACDrv->sGmacData.gmac_queue[queueIdx].nTxDescHead;
   18d72:	f8b1 90b2 	ldrh.w	r9, [r1, #178]	; 0xb2
	while(tailIndex != headIndex)
   18d76:	454c      	cmp	r4, r9
   18d78:	d02e      	beq.n	18dd8 <DRV_PIC32CGMAC_LibTxAckErrPacket+0x7c>
   18d7a:	9201      	str	r2, [sp, #4]
   18d7c:	4606      	mov	r6, r0
        (pMACDrv->sGmacData.pktAckF)(pPkt, ackRes, TCPIP_THIS_MODULE_ID);	
   18d7e:	f241 0b50 	movw	fp, #4176	; 0x1050
        pTxDesc[tailIndex].tx_desc_buffaddr = 0;
   18d82:	f04f 0a00 	mov.w	sl, #0
        GCIRC_INC(tailIndex, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt);  
   18d86:	eb08 08c8 	add.w	r8, r8, r8, lsl #3
   18d8a:	eb00 0848 	add.w	r8, r0, r8, lsl #1
        pbuff = (uint8_t*)((uint32_t)pTxDesc[tailIndex].tx_desc_buffaddr & pMACDrv->sGmacData._dataOffsetMask);
   18d8e:	eb07 05c4 	add.w	r5, r7, r4, lsl #3
   18d92:	f857 3034 	ldr.w	r3, [r7, r4, lsl #3]
   18d96:	f8d6 20f0 	ldr.w	r2, [r6, #240]	; 0xf0
   18d9a:	4013      	ands	r3, r2
        TCPIP_MAC_SEGMENT_GAP_DCPT* pGap = (TCPIP_MAC_SEGMENT_GAP_DCPT*)(pbuff + pMACDrv->sGmacData._dcptOffset);
   18d9c:	f9b6 20ec 	ldrsh.w	r2, [r6, #236]	; 0xec
        pPkt = pGap->segmentPktPtr;
   18da0:	5898      	ldr	r0, [r3, r2]
        pPkt->pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED;
   18da2:	8c43      	ldrh	r3, [r0, #34]	; 0x22
   18da4:	f023 0308 	bic.w	r3, r3, #8
   18da8:	8443      	strh	r3, [r0, #34]	; 0x22
        (pMACDrv->sGmacData.pktAckF)(pPkt, ackRes, TCPIP_THIS_MODULE_ID);	
   18daa:	6af3      	ldr	r3, [r6, #44]	; 0x2c
   18dac:	465a      	mov	r2, fp
   18dae:	9901      	ldr	r1, [sp, #4]
   18db0:	4798      	blx	r3
        pTxDesc[tailIndex].tx_desc_status.val &= GMAC_TX_WRAP_BIT;
   18db2:	686b      	ldr	r3, [r5, #4]
   18db4:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
   18db8:	606b      	str	r3, [r5, #4]
        pTxDesc[tailIndex].tx_desc_status.val |= GMAC_TX_USED_BIT | GMAC_TX_LAST_BUFFER_BIT;
   18dba:	686b      	ldr	r3, [r5, #4]
   18dbc:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
   18dc0:	606b      	str	r3, [r5, #4]
        pTxDesc[tailIndex].tx_desc_buffaddr = 0;
   18dc2:	f847 a034 	str.w	sl, [r7, r4, lsl #3]
        GCIRC_INC(tailIndex, pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nTxDescCnt);  
   18dc6:	3401      	adds	r4, #1
   18dc8:	b2a4      	uxth	r4, r4
   18dca:	f8b8 30c8 	ldrh.w	r3, [r8, #200]	; 0xc8
   18dce:	42a3      	cmp	r3, r4
   18dd0:	bf98      	it	ls
   18dd2:	2400      	movls	r4, #0
	while(tailIndex != headIndex)
   18dd4:	454c      	cmp	r4, r9
   18dd6:	d1da      	bne.n	18d8e <DRV_PIC32CGMAC_LibTxAckErrPacket+0x32>
}
   18dd8:	b003      	add	sp, #12
   18dda:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

Disassembly of section .text._DNS_ValidateIf%411:

00018dde <_DNS_ValidateIf>:
{
   18dde:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18de0:	4604      	mov	r4, r0
   18de2:	460d      	mov	r5, r1
   18de4:	4616      	mov	r6, r2
    if(_DNS_NetIsValid(pIf))
   18de6:	f005 fcb3 	bl	1e750 <_DNS_NetIsValid>
   18dea:	4607      	mov	r7, r0
   18dec:	b1a8      	cbz	r0, 18e1a <_DNS_ValidateIf+0x3c>
        if(pDnsHE->currNet == pIf)
   18dee:	69eb      	ldr	r3, [r5, #28]
   18df0:	42a3      	cmp	r3, r4
   18df2:	d014      	beq.n	18e1e <_DNS_ValidateIf+0x40>
            startIx = 0;
   18df4:	2000      	movs	r0, #0
            if(pIf->dnsServer[ix].Val != 0)
   18df6:	1d03      	adds	r3, r0, #4
   18df8:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
   18dfc:	bb73      	cbnz	r3, 18e5c <_DNS_ValidateIf+0x7e>
   18dfe:	1d42      	adds	r2, r0, #5
   18e00:	eb04 0282 	add.w	r2, r4, r2, lsl #2
   18e04:	4603      	mov	r3, r0
        for(ix = startIx; ix < sizeof(pIf->dnsServer) / sizeof(*pIf->dnsServer); ix++)
   18e06:	3301      	adds	r3, #1
   18e08:	2b01      	cmp	r3, #1
   18e0a:	d80f      	bhi.n	18e2c <_DNS_ValidateIf+0x4e>
            if(pIf->dnsServer[ix].Val != 0)
   18e0c:	f852 1b04 	ldr.w	r1, [r2], #4
   18e10:	2900      	cmp	r1, #0
   18e12:	d0f8      	beq.n	18e06 <_DNS_ValidateIf+0x28>
            pDnsHE->currNet = pIf;
   18e14:	61ec      	str	r4, [r5, #28]
            pDnsHE->currServerIx = ix;
   18e16:	f885 3029 	strb.w	r3, [r5, #41]	; 0x29
}
   18e1a:	4638      	mov	r0, r7
   18e1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            startIx = (pDnsHE->currRetry == 0) ? pDnsHE->currServerIx : pDnsHE->currServerIx + 1;
   18e1e:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
   18e22:	b933      	cbnz	r3, 18e32 <_DNS_ValidateIf+0x54>
   18e24:	f895 0029 	ldrb.w	r0, [r5, #41]	; 0x29
        for(ix = startIx; ix < sizeof(pIf->dnsServer) / sizeof(*pIf->dnsServer); ix++)
   18e28:	2801      	cmp	r0, #1
   18e2a:	d9e4      	bls.n	18df6 <_DNS_ValidateIf+0x18>
        if(!srvFound && wrapAround) 
   18e2c:	b92e      	cbnz	r6, 18e3a <_DNS_ValidateIf+0x5c>
    return false;
   18e2e:	4637      	mov	r7, r6
   18e30:	e7f3      	b.n	18e1a <_DNS_ValidateIf+0x3c>
            startIx = (pDnsHE->currRetry == 0) ? pDnsHE->currServerIx : pDnsHE->currServerIx + 1;
   18e32:	f895 0029 	ldrb.w	r0, [r5, #41]	; 0x29
   18e36:	3001      	adds	r0, #1
   18e38:	e7f6      	b.n	18e28 <_DNS_ValidateIf+0x4a>
            for(ix = 0; ix < startIx; ix++)
   18e3a:	b138      	cbz	r0, 18e4c <_DNS_ValidateIf+0x6e>
                if(pIf->dnsServer[ix].Val != 0)
   18e3c:	6923      	ldr	r3, [r4, #16]
   18e3e:	b94b      	cbnz	r3, 18e54 <_DNS_ValidateIf+0x76>
            for(ix = 0; ix < startIx; ix++)
   18e40:	2801      	cmp	r0, #1
   18e42:	dd05      	ble.n	18e50 <_DNS_ValidateIf+0x72>
                if(pIf->dnsServer[ix].Val != 0)
   18e44:	6963      	ldr	r3, [r4, #20]
   18e46:	b93b      	cbnz	r3, 18e58 <_DNS_ValidateIf+0x7a>
    return false;
   18e48:	2700      	movs	r7, #0
   18e4a:	e7e6      	b.n	18e1a <_DNS_ValidateIf+0x3c>
   18e4c:	2700      	movs	r7, #0
   18e4e:	e7e4      	b.n	18e1a <_DNS_ValidateIf+0x3c>
   18e50:	2700      	movs	r7, #0
   18e52:	e7e2      	b.n	18e1a <_DNS_ValidateIf+0x3c>
            for(ix = 0; ix < startIx; ix++)
   18e54:	2300      	movs	r3, #0
   18e56:	e7dd      	b.n	18e14 <_DNS_ValidateIf+0x36>
   18e58:	2301      	movs	r3, #1
   18e5a:	e7db      	b.n	18e14 <_DNS_ValidateIf+0x36>
            if(pIf->dnsServer[ix].Val != 0)
   18e5c:	4603      	mov	r3, r0
        if(!srvFound && wrapAround) 
   18e5e:	e7d9      	b.n	18e14 <_DNS_ValidateIf+0x36>

Disassembly of section .text.TCPIP_Helper_PacketChecksum%412:

00018e60 <TCPIP_Helper_PacketChecksum>:
    uint8_t* pChkBuff;
    uint16_t checkLength, chkBytes, nBytes;
    uint16_t segChkSum;
    uint32_t calcChkSum;

    if(len == 0)
   18e60:	b90a      	cbnz	r2, 18e66 <TCPIP_Helper_PacketChecksum+0x6>
        }
#endif  // defined(TCPIP_IPV4_FRAGMENTATION) && (TCPIP_IPV4_FRAGMENTATION != 0)
    }

    return ~TCPIP_Helper_ChecksumFold(calcChkSum);
}
   18e62:	4618      	mov	r0, r3
   18e64:	4770      	bx	lr
{
   18e66:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   18e6a:	460f      	mov	r7, r1
   18e6c:	4616      	mov	r6, r2
    calcChkSum = seed;
   18e6e:	4698      	mov	r8, r3
    pSeg = TCPIP_PKT_DataSegmentGet(pPkt, startAdd, true);
   18e70:	2201      	movs	r2, #1
   18e72:	f001 f909 	bl	1a088 <TCPIP_PKT_DataSegmentGet>
    while(pSeg != 0 && checkLength != 0)
   18e76:	4605      	mov	r5, r0
   18e78:	b358      	cbz	r0, 18ed2 <TCPIP_Helper_PacketChecksum+0x72>
    nBytes = 0;
   18e7a:	f04f 0900 	mov.w	r9, #0
            segChkSum = ~TCPIP_Helper_CalcIPChecksum(pChkBuff, chkBytes, 0);
   18e7e:	46ca      	mov	sl, r9
   18e80:	e009      	b.n	18e96 <TCPIP_Helper_PacketChecksum+0x36>
            checkLength -= chkBytes;
   18e82:	1b36      	subs	r6, r6, r4
   18e84:	b2b6      	uxth	r6, r6
            nBytes += chkBytes;
   18e86:	44a1      	add	r9, r4
   18e88:	fa1f f989 	uxth.w	r9, r9
            calcChkSum += segChkSum;
   18e8c:	4480      	add	r8, r0
        if((pSeg = pSeg->next) != 0)
   18e8e:	682d      	ldr	r5, [r5, #0]
   18e90:	b1fd      	cbz	r5, 18ed2 <TCPIP_Helper_PacketChecksum+0x72>
            pChkBuff = pSeg->segLoad;
   18e92:	68af      	ldr	r7, [r5, #8]
    while(pSeg != 0 && checkLength != 0)
   18e94:	b1ee      	cbz	r6, 18ed2 <TCPIP_Helper_PacketChecksum+0x72>
        chkBytes = (pSeg->segLoad + pSeg->segSize) - pChkBuff;
   18e96:	89eb      	ldrh	r3, [r5, #14]
   18e98:	68ac      	ldr	r4, [r5, #8]
   18e9a:	441c      	add	r4, r3
   18e9c:	1be4      	subs	r4, r4, r7
   18e9e:	b2a4      	uxth	r4, r4
        if( pSeg->segLen && (chkBytes > pSeg->segLen) )
   18ea0:	89ab      	ldrh	r3, [r5, #12]
   18ea2:	b113      	cbz	r3, 18eaa <TCPIP_Helper_PacketChecksum+0x4a>
   18ea4:	429c      	cmp	r4, r3
   18ea6:	bf28      	it	cs
   18ea8:	461c      	movcs	r4, r3
        if(chkBytes > checkLength)
   18eaa:	42b4      	cmp	r4, r6
   18eac:	bf28      	it	cs
   18eae:	4634      	movcs	r4, r6
        if(chkBytes)
   18eb0:	2c00      	cmp	r4, #0
   18eb2:	d0ec      	beq.n	18e8e <TCPIP_Helper_PacketChecksum+0x2e>
            segChkSum = ~TCPIP_Helper_CalcIPChecksum(pChkBuff, chkBytes, 0);
   18eb4:	4652      	mov	r2, sl
   18eb6:	4621      	mov	r1, r4
   18eb8:	4638      	mov	r0, r7
   18eba:	f001 f9ff 	bl	1a2bc <TCPIP_Helper_CalcIPChecksum>
   18ebe:	43c0      	mvns	r0, r0
   18ec0:	b280      	uxth	r0, r0
            if((nBytes & 0x1) != 0)
   18ec2:	f019 0f01 	tst.w	r9, #1
   18ec6:	d0dc      	beq.n	18e82 <TCPIP_Helper_PacketChecksum+0x22>
   18ec8:	0a03      	lsrs	r3, r0, #8
   18eca:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
   18ece:	b280      	uxth	r0, r0
   18ed0:	e7d7      	b.n	18e82 <TCPIP_Helper_PacketChecksum+0x22>
    return ~TCPIP_Helper_ChecksumFold(calcChkSum);
   18ed2:	4640      	mov	r0, r8
   18ed4:	f008 fe90 	bl	21bf8 <TCPIP_Helper_ChecksumFold>
   18ed8:	43c0      	mvns	r0, r0
   18eda:	b283      	uxth	r3, r0
}
   18edc:	4618      	mov	r0, r3
   18ede:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

Disassembly of section .text.__fputwc%413:

00018ee2 <__fputwc>:
   18ee2:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   18ee6:	4680      	mov	r8, r0
   18ee8:	460e      	mov	r6, r1
   18eea:	4614      	mov	r4, r2
   18eec:	f009 f852 	bl	21f94 <__locale_mb_cur_max>
   18ef0:	2801      	cmp	r0, #1
   18ef2:	d10e      	bne.n	18f12 <__fputwc+0x30>
   18ef4:	1e73      	subs	r3, r6, #1
   18ef6:	2bfe      	cmp	r3, #254	; 0xfe
   18ef8:	d80b      	bhi.n	18f12 <__fputwc+0x30>
   18efa:	f88d 6004 	strb.w	r6, [sp, #4]
   18efe:	4605      	mov	r5, r0
   18f00:	2700      	movs	r7, #0
   18f02:	f10d 0904 	add.w	r9, sp, #4
   18f06:	42af      	cmp	r7, r5
   18f08:	d113      	bne.n	18f32 <__fputwc+0x50>
   18f0a:	4630      	mov	r0, r6
   18f0c:	b003      	add	sp, #12
   18f0e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   18f12:	4632      	mov	r2, r6
   18f14:	f104 0358 	add.w	r3, r4, #88	; 0x58
   18f18:	a901      	add	r1, sp, #4
   18f1a:	4640      	mov	r0, r8
   18f1c:	f006 fd6a 	bl	1f9f4 <_wcrtomb_r>
   18f20:	1c42      	adds	r2, r0, #1
   18f22:	4605      	mov	r5, r0
   18f24:	d1ec      	bne.n	18f00 <__fputwc+0x1e>
   18f26:	89a3      	ldrh	r3, [r4, #12]
   18f28:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   18f2c:	81a3      	strh	r3, [r4, #12]
   18f2e:	4606      	mov	r6, r0
   18f30:	e7eb      	b.n	18f0a <__fputwc+0x28>
   18f32:	68a3      	ldr	r3, [r4, #8]
   18f34:	f817 1009 	ldrb.w	r1, [r7, r9]
   18f38:	3b01      	subs	r3, #1
   18f3a:	2b00      	cmp	r3, #0
   18f3c:	60a3      	str	r3, [r4, #8]
   18f3e:	da04      	bge.n	18f4a <__fputwc+0x68>
   18f40:	69a2      	ldr	r2, [r4, #24]
   18f42:	4293      	cmp	r3, r2
   18f44:	db07      	blt.n	18f56 <__fputwc+0x74>
   18f46:	290a      	cmp	r1, #10
   18f48:	d005      	beq.n	18f56 <__fputwc+0x74>
   18f4a:	6823      	ldr	r3, [r4, #0]
   18f4c:	1c5a      	adds	r2, r3, #1
   18f4e:	6022      	str	r2, [r4, #0]
   18f50:	7019      	strb	r1, [r3, #0]
   18f52:	3701      	adds	r7, #1
   18f54:	e7d7      	b.n	18f06 <__fputwc+0x24>
   18f56:	4622      	mov	r2, r4
   18f58:	4640      	mov	r0, r8
   18f5a:	f7fd f95f 	bl	1621c <__swbuf_r>
   18f5e:	1c43      	adds	r3, r0, #1
   18f60:	d1f7      	bne.n	18f52 <__fputwc+0x70>
   18f62:	e7e4      	b.n	18f2e <__fputwc+0x4c>

Disassembly of section .text.DRV_ETHPHY_VendorSMIReadStart%414:

00018f64 <DRV_ETHPHY_VendorSMIReadStart>:
}



DRV_ETHPHY_RESULT DRV_ETHPHY_VendorSMIReadStart( DRV_HANDLE handle, uint16_t rIx,  int phyAddress )
{
   18f64:	b538      	push	{r3, r4, r5, lr}
    DRV_ETHPHY_SMI_TXFER_RES opRes;
    DRV_ETHPHY_CLIENT_OBJ * hClientObj = (DRV_ETHPHY_CLIENT_OBJ *) handle;

    if(hClientObj == 0 || _DRVHandleToInst(hClientObj->hDriver) == 0)
   18f66:	b340      	cbz	r0, 18fba <DRV_ETHPHY_VendorSMIReadStart+0x56>
   18f68:	4604      	mov	r4, r0
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   18f6a:	68c3      	ldr	r3, [r0, #12]
   18f6c:	481c      	ldr	r0, [pc, #112]	; (18fe0 <DRV_ETHPHY_VendorSMIReadStart+0x7c>)
   18f6e:	4283      	cmp	r3, r0
   18f70:	d126      	bne.n	18fc0 <DRV_ETHPHY_VendorSMIReadStart+0x5c>
    {
        return DRV_ETHPHY_RES_HANDLE_ERR;
    }
    
    if( hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_BUSY || 
   18f72:	f994 5008 	ldrsb.w	r5, [r4, #8]
   18f76:	2d01      	cmp	r5, #1
   18f78:	d126      	bne.n	18fc8 <DRV_ETHPHY_VendorSMIReadStart+0x64>
   18f7a:	8ba0      	ldrh	r0, [r4, #28]
   18f7c:	2801      	cmp	r0, #1
   18f7e:	d126      	bne.n	18fce <DRV_ETHPHY_VendorSMIReadStart+0x6a>
        hClientObj->operType != DRV_ETHPHY_CLIENT_OP_TYPE_SETUP || 
   18f80:	8be0      	ldrh	r0, [r4, #30]
   18f82:	f020 0002 	bic.w	r0, r0, #2
   18f86:	b280      	uxth	r0, r0
   18f88:	2801      	cmp	r0, #1
   18f8a:	d002      	beq.n	18f92 <DRV_ETHPHY_VendorSMIReadStart+0x2e>
        (hClientObj->operPhase != DRV_ETHPHY_SETUP_PHASE_DETECT && hClientObj->operPhase != DRV_ETHPHY_SETUP_PHASE_NEGOTIATE))
    {   // not allowed
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   18f8c:	f06f 0509 	mvn.w	r5, #9
   18f90:	e018      	b.n	18fc4 <DRV_ETHPHY_VendorSMIReadStart+0x60>
    }

    if(hClientObj->smiTxferStatus != DRV_ETHPHY_SMI_TXFER_OP_NONE)
   18f92:	8ea0      	ldrh	r0, [r4, #52]	; 0x34
   18f94:	b9f0      	cbnz	r0, 18fd4 <DRV_ETHPHY_VendorSMIReadStart+0x70>
    hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_START;
   18f96:	2301      	movs	r3, #1
   18f98:	86a3      	strh	r3, [r4, #52]	; 0x34
    hClientObj->smiRIx = rIx;
   18f9a:	8721      	strh	r1, [r4, #56]	; 0x38
    hClientObj->smiTxferType = DRV_ETHPHY_SMI_XFER_TYPE_READ;
   18f9c:	2303      	movs	r3, #3
   18f9e:	86e3      	strh	r3, [r4, #54]	; 0x36
    hClientObj->smiPhyAddress = phyAdd;
   18fa0:	63e2      	str	r2, [r4, #60]	; 0x3c
    return _DRV_PHY_SMITransferStart(hClientObj);
   18fa2:	4620      	mov	r0, r4
   18fa4:	f7fe fc5c 	bl	17860 <_DRV_PHY_SMITransferStart>
        return DRV_ETHPHY_RES_OPERATION_ERR;
    }


    opRes = _DRV_PHY_SMIReadStartEx(hClientObj, rIx, phyAddress);
    if(opRes < 0)
   18fa8:	2800      	cmp	r0, #0
   18faa:	db16      	blt.n	18fda <DRV_ETHPHY_VendorSMIReadStart+0x76>
    {   // error occurred 
        return DRV_ETHPHY_RES_OPERATION_ERR;
    }
    else if(opRes == DRV_ETHPHY_SMI_TXFER_RES_BUSY)
   18fac:	2803      	cmp	r0, #3
   18fae:	d001      	beq.n	18fb4 <DRV_ETHPHY_VendorSMIReadStart+0x50>
        hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
        return DRV_ETHPHY_RES_PENDING;
    } 

    // went through
    return DRV_ETHPHY_RES_OK;
   18fb0:	2500      	movs	r5, #0
   18fb2:	e007      	b.n	18fc4 <DRV_ETHPHY_VendorSMIReadStart+0x60>
        hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
   18fb4:	2300      	movs	r3, #0
   18fb6:	86a3      	strh	r3, [r4, #52]	; 0x34
        return DRV_ETHPHY_RES_PENDING;
   18fb8:	e004      	b.n	18fc4 <DRV_ETHPHY_VendorSMIReadStart+0x60>
        return DRV_ETHPHY_RES_HANDLE_ERR;
   18fba:	f06f 050a 	mvn.w	r5, #10
   18fbe:	e001      	b.n	18fc4 <DRV_ETHPHY_VendorSMIReadStart+0x60>
   18fc0:	f06f 050a 	mvn.w	r5, #10
}
   18fc4:	4628      	mov	r0, r5
   18fc6:	bd38      	pop	{r3, r4, r5, pc}
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   18fc8:	f06f 0509 	mvn.w	r5, #9
   18fcc:	e7fa      	b.n	18fc4 <DRV_ETHPHY_VendorSMIReadStart+0x60>
   18fce:	f06f 0509 	mvn.w	r5, #9
   18fd2:	e7f7      	b.n	18fc4 <DRV_ETHPHY_VendorSMIReadStart+0x60>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   18fd4:	f06f 0508 	mvn.w	r5, #8
   18fd8:	e7f4      	b.n	18fc4 <DRV_ETHPHY_VendorSMIReadStart+0x60>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   18fda:	f06f 0508 	mvn.w	r5, #8
   18fde:	e7f1      	b.n	18fc4 <DRV_ETHPHY_VendorSMIReadStart+0x60>
   18fe0:	2000e018 	.word	0x2000e018

Disassembly of section .text.DRV_ETHPHY_VendorSMIWriteStart%415:

00018fe4 <DRV_ETHPHY_VendorSMIWriteStart>:
{
    DRV_ETHPHY_RESULT phyRes;
    DRV_ETHPHY_SMI_TXFER_RES opRes;
    DRV_ETHPHY_CLIENT_OBJ * hClientObj = (DRV_ETHPHY_CLIENT_OBJ *) handle;

    if(hClientObj == 0 || _DRVHandleToInst(hClientObj->hDriver) == 0)
   18fe4:	b348      	cbz	r0, 1903a <DRV_ETHPHY_VendorSMIWriteStart+0x56>
{
   18fe6:	b538      	push	{r3, r4, r5, lr}
   18fe8:	4604      	mov	r4, r0
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   18fea:	68c5      	ldr	r5, [r0, #12]
   18fec:	481c      	ldr	r0, [pc, #112]	; (19060 <DRV_ETHPHY_VendorSMIWriteStart+0x7c>)
   18fee:	4285      	cmp	r5, r0
   18ff0:	d126      	bne.n	19040 <DRV_ETHPHY_VendorSMIWriteStart+0x5c>
    {
        return DRV_ETHPHY_RES_HANDLE_ERR;
    }

    
    if( hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_BUSY || 
   18ff2:	f994 0008 	ldrsb.w	r0, [r4, #8]
   18ff6:	2801      	cmp	r0, #1
   18ff8:	d125      	bne.n	19046 <DRV_ETHPHY_VendorSMIWriteStart+0x62>
   18ffa:	8ba0      	ldrh	r0, [r4, #28]
   18ffc:	2801      	cmp	r0, #1
   18ffe:	d125      	bne.n	1904c <DRV_ETHPHY_VendorSMIWriteStart+0x68>
        hClientObj->operType != DRV_ETHPHY_CLIENT_OP_TYPE_SETUP || 
   19000:	8be0      	ldrh	r0, [r4, #30]
   19002:	f020 0002 	bic.w	r0, r0, #2
   19006:	b280      	uxth	r0, r0
   19008:	2801      	cmp	r0, #1
   1900a:	d002      	beq.n	19012 <DRV_ETHPHY_VendorSMIWriteStart+0x2e>
        (hClientObj->operPhase != DRV_ETHPHY_SETUP_PHASE_DETECT && hClientObj->operPhase != DRV_ETHPHY_SETUP_PHASE_NEGOTIATE))
    {   // not allowed
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   1900c:	f06f 0009 	mvn.w	r0, #9
   19010:	e018      	b.n	19044 <DRV_ETHPHY_VendorSMIWriteStart+0x60>
    }

    if(hClientObj->smiTxferStatus != DRV_ETHPHY_SMI_TXFER_OP_NONE)
   19012:	8ea0      	ldrh	r0, [r4, #52]	; 0x34
   19014:	b9e8      	cbnz	r0, 19052 <DRV_ETHPHY_VendorSMIWriteStart+0x6e>
    hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_START;
   19016:	2001      	movs	r0, #1
   19018:	86a0      	strh	r0, [r4, #52]	; 0x34
    hClientObj->smiRIx = rIx;
   1901a:	8721      	strh	r1, [r4, #56]	; 0x38
    hClientObj->smiTxferType = DRV_ETHPHY_SMI_XFER_TYPE_WRITE;
   1901c:	86e0      	strh	r0, [r4, #54]	; 0x36
    hClientObj->smiData =  wData;
   1901e:	8762      	strh	r2, [r4, #58]	; 0x3a
    hClientObj->smiPhyAddress = phyAdd;
   19020:	63e3      	str	r3, [r4, #60]	; 0x3c
   return  _DRV_PHY_SMITransferStart(hClientObj);
   19022:	4620      	mov	r0, r4
   19024:	f7fe fc1c 	bl	17860 <_DRV_PHY_SMITransferStart>
    {   // calling this before the previous SMI done?
        return DRV_ETHPHY_RES_OPERATION_ERR;
    }

    opRes = _DRV_PHY_SMIWriteStartEx(hClientObj, rIx, wData, phyAddress);
    if(opRes < 0)
   19028:	2800      	cmp	r0, #0
   1902a:	db15      	blt.n	19058 <DRV_ETHPHY_VendorSMIWriteStart+0x74>
        return DRV_ETHPHY_RES_OPERATION_ERR;
    }

    if(opRes == DRV_ETHPHY_SMI_TXFER_RES_BUSY)
    {   // retry
        phyRes = DRV_ETHPHY_RES_PENDING;
   1902c:	2803      	cmp	r0, #3
   1902e:	bf14      	ite	ne
   19030:	2000      	movne	r0, #0
   19032:	2001      	moveq	r0, #1
    else
    {   // went through
        phyRes = DRV_ETHPHY_RES_OK;
    }

    hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
   19034:	2300      	movs	r3, #0
   19036:	86a3      	strh	r3, [r4, #52]	; 0x34


    return phyRes;
   19038:	e004      	b.n	19044 <DRV_ETHPHY_VendorSMIWriteStart+0x60>
        return DRV_ETHPHY_RES_HANDLE_ERR;
   1903a:	f06f 000a 	mvn.w	r0, #10

}
   1903e:	4770      	bx	lr
        return DRV_ETHPHY_RES_HANDLE_ERR;
   19040:	f06f 000a 	mvn.w	r0, #10
}
   19044:	bd38      	pop	{r3, r4, r5, pc}
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   19046:	f06f 0009 	mvn.w	r0, #9
   1904a:	e7fb      	b.n	19044 <DRV_ETHPHY_VendorSMIWriteStart+0x60>
   1904c:	f06f 0009 	mvn.w	r0, #9
   19050:	e7f8      	b.n	19044 <DRV_ETHPHY_VendorSMIWriteStart+0x60>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   19052:	f06f 0008 	mvn.w	r0, #8
   19056:	e7f5      	b.n	19044 <DRV_ETHPHY_VendorSMIWriteStart+0x60>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   19058:	f06f 0008 	mvn.w	r0, #8
   1905c:	e7f2      	b.n	19044 <DRV_ETHPHY_VendorSMIWriteStart+0x60>
   1905e:	bf00      	nop
   19060:	2000e018 	.word	0x2000e018

Disassembly of section .text.SERCOM1_USART_Initialize%416:

00019064 <SERCOM1_USART_Initialize>:
    SERCOM1_REGS->USART_INT.SERCOM_CTRLA = SERCOM_USART_INT_CTRLA_MODE_USART_INT_CLK | SERCOM_USART_INT_CTRLA_RXPO(0x1UL) | SERCOM_USART_INT_CTRLA_TXPO(0x0UL) | SERCOM_USART_INT_CTRLA_DORD_Msk | SERCOM_USART_INT_CTRLA_IBON_Msk | SERCOM_USART_INT_CTRLA_FORM(0x0UL) | SERCOM_USART_INT_CTRLA_SAMPR(0UL) ;
   19064:	4b1c      	ldr	r3, [pc, #112]	; (190d8 <SERCOM1_USART_Initialize+0x74>)
   19066:	4a1d      	ldr	r2, [pc, #116]	; (190dc <SERCOM1_USART_Initialize+0x78>)
   19068:	601a      	str	r2, [r3, #0]
    SERCOM1_REGS->USART_INT.SERCOM_BAUD = (uint16_t)SERCOM_USART_INT_BAUD_BAUD(SERCOM1_USART_INT_BAUD_VALUE);
   1906a:	f64f 0222 	movw	r2, #63522	; 0xf822
   1906e:	819a      	strh	r2, [r3, #12]
    SERCOM1_REGS->USART_INT.SERCOM_CTRLB = SERCOM_USART_INT_CTRLB_CHSIZE_8_BIT | SERCOM_USART_INT_CTRLB_SBMODE_1_BIT | SERCOM_USART_INT_CTRLB_RXEN_Msk | SERCOM_USART_INT_CTRLB_TXEN_Msk;
   19070:	f44f 3240 	mov.w	r2, #196608	; 0x30000
   19074:	605a      	str	r2, [r3, #4]
    while((SERCOM1_REGS->USART_INT.SERCOM_SYNCBUSY) != 0U)
   19076:	461a      	mov	r2, r3
   19078:	69d3      	ldr	r3, [r2, #28]
   1907a:	2b00      	cmp	r3, #0
   1907c:	d1fc      	bne.n	19078 <SERCOM1_USART_Initialize+0x14>
    SERCOM1_REGS->USART_INT.SERCOM_CTRLA |= SERCOM_USART_INT_CTRLA_ENABLE_Msk;
   1907e:	4a16      	ldr	r2, [pc, #88]	; (190d8 <SERCOM1_USART_Initialize+0x74>)
   19080:	6813      	ldr	r3, [r2, #0]
   19082:	f043 0302 	orr.w	r3, r3, #2
   19086:	6013      	str	r3, [r2, #0]
    while((SERCOM1_REGS->USART_INT.SERCOM_SYNCBUSY) != 0U)
   19088:	69d3      	ldr	r3, [r2, #28]
   1908a:	2b00      	cmp	r3, #0
   1908c:	d1fc      	bne.n	19088 <SERCOM1_USART_Initialize+0x24>
    sercom1USARTObj.rdCallback = NULL;
   1908e:	4b14      	ldr	r3, [pc, #80]	; (190e0 <SERCOM1_USART_Initialize+0x7c>)
   19090:	2200      	movs	r2, #0
   19092:	621a      	str	r2, [r3, #32]
    sercom1USARTObj.rdInIndex = 0U;
   19094:	629a      	str	r2, [r3, #40]	; 0x28
    sercom1USARTObj.rdOutIndex = 0U;
   19096:	62da      	str	r2, [r3, #44]	; 0x2c
    sercom1USARTObj.isRdNotificationEnabled = false;
   19098:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    sercom1USARTObj.isRdNotifyPersistently = false;
   1909c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    sercom1USARTObj.rdThreshold = 0U;
   190a0:	639a      	str	r2, [r3, #56]	; 0x38
    sercom1USARTObj.errorStatus = USART_ERROR_NONE;
   190a2:	87da      	strh	r2, [r3, #62]	; 0x3e
    sercom1USARTObj.wrCallback = NULL;
   190a4:	601a      	str	r2, [r3, #0]
    sercom1USARTObj.wrInIndex = 0U;
   190a6:	609a      	str	r2, [r3, #8]
    sercom1USARTObj.wrOutIndex = 0U;
   190a8:	60da      	str	r2, [r3, #12]
    sercom1USARTObj.isWrNotificationEnabled = false;
   190aa:	751a      	strb	r2, [r3, #20]
    sercom1USARTObj.isWrNotifyPersistently = false;
   190ac:	771a      	strb	r2, [r3, #28]
    sercom1USARTObj.wrThreshold = 0U;
   190ae:	619a      	str	r2, [r3, #24]
    if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   190b0:	4b09      	ldr	r3, [pc, #36]	; (190d8 <SERCOM1_USART_Initialize+0x74>)
   190b2:	685b      	ldr	r3, [r3, #4]
   190b4:	f003 0307 	and.w	r3, r3, #7
   190b8:	2b01      	cmp	r3, #1
        sercom1USARTObj.rdBufferSize = SERCOM1_USART_READ_BUFFER_SIZE;
   190ba:	4b09      	ldr	r3, [pc, #36]	; (190e0 <SERCOM1_USART_Initialize+0x7c>)
   190bc:	bf14      	ite	ne
   190be:	f44f 5280 	movne.w	r2, #4096	; 0x1000
        sercom1USARTObj.rdBufferSize = SERCOM1_USART_READ_BUFFER_9BIT_SIZE;
   190c2:	f44f 6200 	moveq.w	r2, #2048	; 0x800
   190c6:	631a      	str	r2, [r3, #48]	; 0x30
        sercom1USARTObj.wrBufferSize = SERCOM1_USART_WRITE_BUFFER_9BIT_SIZE;
   190c8:	611a      	str	r2, [r3, #16]
    SERCOM1_REGS->USART_INT.SERCOM_INTENSET = (uint8_t)SERCOM_USART_INT_INTENSET_ERROR_Msk;
   190ca:	4b03      	ldr	r3, [pc, #12]	; (190d8 <SERCOM1_USART_Initialize+0x74>)
   190cc:	2280      	movs	r2, #128	; 0x80
   190ce:	759a      	strb	r2, [r3, #22]
    SERCOM1_REGS->USART_INT.SERCOM_INTENSET = (uint8_t)SERCOM_USART_INT_INTENSET_RXC_Msk;
   190d0:	2204      	movs	r2, #4
   190d2:	759a      	strb	r2, [r3, #22]
}
   190d4:	4770      	bx	lr
   190d6:	bf00      	nop
   190d8:	40003400 	.word	0x40003400
   190dc:	40100104 	.word	0x40100104
   190e0:	2000e1f0 	.word	0x2000e1f0

Disassembly of section .text.SendCommandPrint%417:

000190e4 <SendCommandPrint>:
{
   190e4:	b40e      	push	{r1, r2, r3}
   190e6:	b530      	push	{r4, r5, lr}
   190e8:	f6ad 2d08 	subw	sp, sp, #2568	; 0xa08
   190ec:	f60d 2314 	addw	r3, sp, #2580	; 0xa14
   190f0:	f853 2b04 	ldr.w	r2, [r3], #4
    va_start( args, format );
   190f4:	9301      	str	r3, [sp, #4]
    len = vsnprintf(tmpBuf, SYS_CMD_PRINT_BUFFER_SIZE, format, args);
   190f6:	f44f 6120 	mov.w	r1, #2560	; 0xa00
   190fa:	a802      	add	r0, sp, #8
   190fc:	f007 ffcc 	bl	21098 <vsniprintf>
    if (len > 0 && len < SYS_CMD_PRINT_BUFFER_SIZE)
   19100:	1e42      	subs	r2, r0, #1
   19102:	f640 13fe 	movw	r3, #2558	; 0x9fe
   19106:	429a      	cmp	r2, r3
   19108:	d821      	bhi.n	1914e <SendCommandPrint+0x6a>
   1910a:	4604      	mov	r4, r0
        tmpBuf[len] = '\0';
   1910c:	ab02      	add	r3, sp, #8
   1910e:	2200      	movs	r2, #0
   19110:	541a      	strb	r2, [r3, r0]
        if (len + printBuffPtr >= SYS_CMD_PRINT_BUFFER_SIZE)
   19112:	4b12      	ldr	r3, [pc, #72]	; (1915c <SendCommandPrint+0x78>)
   19114:	681b      	ldr	r3, [r3, #0]
   19116:	4403      	add	r3, r0
   19118:	f5b3 6f20 	cmp.w	r3, #2560	; 0xa00
            printBuffPtr = 0;
   1911c:	bf24      	itt	cs
   1911e:	4b0f      	ldrcs	r3, [pc, #60]	; (1915c <SendCommandPrint+0x78>)
   19120:	601a      	strcs	r2, [r3, #0]
        strcpy(&printBuff[printBuffPtr], tmpBuf);
   19122:	4b0e      	ldr	r3, [pc, #56]	; (1915c <SendCommandPrint+0x78>)
   19124:	681b      	ldr	r3, [r3, #0]
   19126:	4d0e      	ldr	r5, [pc, #56]	; (19160 <SendCommandPrint+0x7c>)
   19128:	441d      	add	r5, r3
   1912a:	a902      	add	r1, sp, #8
   1912c:	4628      	mov	r0, r5
   1912e:	f008 fd2d 	bl	21b8c <strcpy>
        SendCommandMessage(NULL, &printBuff[printBuffPtr]);
   19132:	4629      	mov	r1, r5
   19134:	2000      	movs	r0, #0
   19136:	f007 ff07 	bl	20f48 <SendCommandMessage>
        if (padding > 0)
   1913a:	f014 0203 	ands.w	r2, r4, #3
            padding = 4 - padding;
   1913e:	bf18      	it	ne
   19140:	f1c2 0204 	rsbne	r2, r2, #4
        printBuffPtr += len + padding;
   19144:	4b05      	ldr	r3, [pc, #20]	; (1915c <SendCommandPrint+0x78>)
   19146:	6819      	ldr	r1, [r3, #0]
   19148:	440c      	add	r4, r1
   1914a:	4414      	add	r4, r2
   1914c:	601c      	str	r4, [r3, #0]
}
   1914e:	f60d 2d08 	addw	sp, sp, #2568	; 0xa08
   19152:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   19156:	b003      	add	sp, #12
   19158:	4770      	bx	lr
   1915a:	bf00      	nop
   1915c:	2000e678 	.word	0x2000e678
   19160:	2000c004 	.word	0x2000c004

Disassembly of section .text.xTaskPriorityDisinherit%418:

00019164 <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
   19164:	2800      	cmp	r0, #0
   19166:	d035      	beq.n	191d4 <xTaskPriorityDisinherit+0x70>
	{
   19168:	b538      	push	{r3, r4, r5, lr}
   1916a:	4604      	mov	r4, r0
			( pxTCB->uxMutexesHeld )--;
   1916c:	6c82      	ldr	r2, [r0, #72]	; 0x48
   1916e:	3a01      	subs	r2, #1
   19170:	6482      	str	r2, [r0, #72]	; 0x48
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   19172:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   19174:	6c61      	ldr	r1, [r4, #68]	; 0x44
   19176:	4288      	cmp	r0, r1
   19178:	d02e      	beq.n	191d8 <xTaskPriorityDisinherit+0x74>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   1917a:	b10a      	cbz	r2, 19180 <xTaskPriorityDisinherit+0x1c>
	BaseType_t xReturn = pdFALSE;
   1917c:	2000      	movs	r0, #0
	}
   1917e:	bd38      	pop	{r3, r4, r5, pc}
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   19180:	1d25      	adds	r5, r4, #4
   19182:	4628      	mov	r0, r5
   19184:	f007 f996 	bl	204b4 <uxListRemove>
   19188:	b970      	cbnz	r0, 191a8 <xTaskPriorityDisinherit+0x44>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   1918a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   1918c:	eb02 0382 	add.w	r3, r2, r2, lsl #2
   19190:	009b      	lsls	r3, r3, #2
   19192:	4912      	ldr	r1, [pc, #72]	; (191dc <xTaskPriorityDisinherit+0x78>)
   19194:	58cb      	ldr	r3, [r1, r3]
   19196:	b93b      	cbnz	r3, 191a8 <xTaskPriorityDisinherit+0x44>
   19198:	4811      	ldr	r0, [pc, #68]	; (191e0 <xTaskPriorityDisinherit+0x7c>)
   1919a:	6803      	ldr	r3, [r0, #0]
   1919c:	2101      	movs	r1, #1
   1919e:	fa01 f202 	lsl.w	r2, r1, r2
   191a2:	ea23 0202 	bic.w	r2, r3, r2
   191a6:	6002      	str	r2, [r0, #0]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
   191a8:	6c60      	ldr	r0, [r4, #68]	; 0x44
   191aa:	62e0      	str	r0, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   191ac:	f1c0 0305 	rsb	r3, r0, #5
   191b0:	61a3      	str	r3, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
   191b2:	4a0b      	ldr	r2, [pc, #44]	; (191e0 <xTaskPriorityDisinherit+0x7c>)
   191b4:	6811      	ldr	r1, [r2, #0]
   191b6:	2401      	movs	r4, #1
   191b8:	fa04 f300 	lsl.w	r3, r4, r0
   191bc:	430b      	orrs	r3, r1
   191be:	6013      	str	r3, [r2, #0]
   191c0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   191c4:	4629      	mov	r1, r5
   191c6:	4b05      	ldr	r3, [pc, #20]	; (191dc <xTaskPriorityDisinherit+0x78>)
   191c8:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   191cc:	f008 faab 	bl	21726 <vListInsertEnd>
					xReturn = pdTRUE;
   191d0:	4620      	mov	r0, r4
   191d2:	e7d4      	b.n	1917e <xTaskPriorityDisinherit+0x1a>
	BaseType_t xReturn = pdFALSE;
   191d4:	2000      	movs	r0, #0
	}
   191d6:	4770      	bx	lr
	BaseType_t xReturn = pdFALSE;
   191d8:	2000      	movs	r0, #0
   191da:	e7d0      	b.n	1917e <xTaskPriorityDisinherit+0x1a>
   191dc:	2000e080 	.word	0x2000e080
   191e0:	2000e6c0 	.word	0x2000e6c0

Disassembly of section .text.vTaskPriorityDisinheritAfterTimeout%419:

000191e4 <vTaskPriorityDisinheritAfterTimeout>:
		if( pxMutexHolder != NULL )
   191e4:	2800      	cmp	r0, #0
   191e6:	d038      	beq.n	1925a <vTaskPriorityDisinheritAfterTimeout+0x76>
	{
   191e8:	b538      	push	{r3, r4, r5, lr}
   191ea:	4604      	mov	r4, r0
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
   191ec:	6c42      	ldr	r2, [r0, #68]	; 0x44
   191ee:	4291      	cmp	r1, r2
   191f0:	bf38      	it	cc
   191f2:	4611      	movcc	r1, r2
			if( pxTCB->uxPriority != uxPriorityToUse )
   191f4:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   191f6:	428a      	cmp	r2, r1
   191f8:	d002      	beq.n	19200 <vTaskPriorityDisinheritAfterTimeout+0x1c>
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
   191fa:	6c80      	ldr	r0, [r0, #72]	; 0x48
   191fc:	2801      	cmp	r0, #1
   191fe:	d000      	beq.n	19202 <vTaskPriorityDisinheritAfterTimeout+0x1e>
	}
   19200:	bd38      	pop	{r3, r4, r5, pc}
					pxTCB->uxPriority = uxPriorityToUse;
   19202:	62e1      	str	r1, [r4, #44]	; 0x2c
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   19204:	69a0      	ldr	r0, [r4, #24]
   19206:	2800      	cmp	r0, #0
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   19208:	bfa4      	itt	ge
   1920a:	f1c1 0105 	rsbge	r1, r1, #5
   1920e:	61a1      	strge	r1, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
   19210:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   19214:	4911      	ldr	r1, [pc, #68]	; (1925c <vTaskPriorityDisinheritAfterTimeout+0x78>)
   19216:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   1921a:	6961      	ldr	r1, [r4, #20]
   1921c:	4291      	cmp	r1, r2
   1921e:	d1ef      	bne.n	19200 <vTaskPriorityDisinheritAfterTimeout+0x1c>
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   19220:	1d25      	adds	r5, r4, #4
   19222:	4628      	mov	r0, r5
   19224:	f007 f946 	bl	204b4 <uxListRemove>
   19228:	b938      	cbnz	r0, 1923a <vTaskPriorityDisinheritAfterTimeout+0x56>
							portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
   1922a:	490d      	ldr	r1, [pc, #52]	; (19260 <vTaskPriorityDisinheritAfterTimeout+0x7c>)
   1922c:	680b      	ldr	r3, [r1, #0]
   1922e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   19230:	2201      	movs	r2, #1
   19232:	4082      	lsls	r2, r0
   19234:	ea23 0302 	bic.w	r3, r3, r2
   19238:	600b      	str	r3, [r1, #0]
						prvAddTaskToReadyList( pxTCB );
   1923a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   1923c:	4a08      	ldr	r2, [pc, #32]	; (19260 <vTaskPriorityDisinheritAfterTimeout+0x7c>)
   1923e:	6811      	ldr	r1, [r2, #0]
   19240:	2301      	movs	r3, #1
   19242:	4083      	lsls	r3, r0
   19244:	430b      	orrs	r3, r1
   19246:	6013      	str	r3, [r2, #0]
   19248:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   1924c:	4629      	mov	r1, r5
   1924e:	4b03      	ldr	r3, [pc, #12]	; (1925c <vTaskPriorityDisinheritAfterTimeout+0x78>)
   19250:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   19254:	f008 fa67 	bl	21726 <vListInsertEnd>
	}
   19258:	e7d2      	b.n	19200 <vTaskPriorityDisinheritAfterTimeout+0x1c>
   1925a:	4770      	bx	lr
   1925c:	2000e080 	.word	0x2000e080
   19260:	2000e6c0 	.word	0x2000e6c0

Disassembly of section .rodata.outputA_data%420:

00019264 <outputA_data>:
   19264:	3bc6ee04 2cdf31b2 fb1a0a63 9d9424e7     ...;.1.,c....$..
   19274:	78585a00 79aae151 4773475e 6256b0c8     .ZXxQ..y^GsG..Vb
   19284:	dcbd181c fc998ddd 20b9c25f accfd853     ........_.. S...
   19294:	83b80bfb d1fa0512 71c0d6dd 18608a31     ...........q1.`.
   192a4:	f5733bf0 d0d4e4ed 03def971 10ea7afd     .;s.....q....z..
   192b4:	b899925d 07aa99af b94ddb5b 8dc128aa     ].......[.M..(..
   192c4:	ee564b17 094d012a 22ff9688 a855c982     .KV.*.M...."..U.
   192d4:	69e06919 07e08cfa 3a1880a1 17aedf07     .i.i.......:....

Disassembly of section .rodata.outputB_data%421:

000192e4 <outputB_data>:
   192e4:	c360e1d3 40f3995b 648262b2 601075d1     ..`.[..@.b.d.u.`
   192f4:	a35d04e0 a557ff83 73a6737d 0dd8b8d2     ..]...W.}s.s....
   19304:	c3a6f6aa 45bb915a d03fd779 11d1fec8     ....Z..Ey.?.....
   19314:	061339b0 eddf8a82 81018f52 bdfeb321     .9......R...!...
   19324:	97e743c3 63bb7db8 de3313db e1ecd1d9     .C...}.c..3.....
   19334:	b7a6cf77 1dabe81f ed2466a4 1ce51564     w........f$.d...
   19344:	cac7e2cd 9983e286 91ebea0e 52150412     ...............R
   19354:	9195228b 2db08102 c9f431d4 df2704f7     .".....-.1....'.

Disassembly of section .text.local_miim_init%422:

00019364 <local_miim_init>:
{
   19364:	b510      	push	{r4, lr}
   19366:	b084      	sub	sp, #16
	opHandle                    = 0;
   19368:	4b16      	ldr	r3, [pc, #88]	; (193c4 <local_miim_init+0x60>)
   1936a:	2000      	movs	r0, #0
   1936c:	6018      	str	r0, [r3, #0]
	clientObj.miimOpHandle      = &opHandle;
   1936e:	4c16      	ldr	r4, [pc, #88]	; (193c8 <local_miim_init+0x64>)
   19370:	6123      	str	r3, [r4, #16]
	clientObj.miimBase          = &DRV_MIIM_OBJECT_BASE_Default;
   19372:	4b16      	ldr	r3, [pc, #88]	; (193cc <local_miim_init+0x68>)
   19374:	60e3      	str	r3, [r4, #12]
	clientObj.miimHandle = clientObj.miimBase->DRV_MIIM_Open(miimObjIx, DRV_IO_INTENT_SHARED);
   19376:	695b      	ldr	r3, [r3, #20]
   19378:	4601      	mov	r1, r0
   1937a:	4798      	blx	r3
   1937c:	60a0      	str	r0, [r4, #8]
	if ( (clientObj.miimHandle == DRV_HANDLE_INVALID) || (clientObj.miimHandle == 0))
   1937e:	1e43      	subs	r3, r0, #1
   19380:	f113 0f03 	cmn.w	r3, #3
   19384:	d815      	bhi.n	193b2 <local_miim_init+0x4e>
		miimSetup.hostClockFreq = (uint32_t) TCPIP_INTMAC_PERIPHERAL_CLK;
   19386:	4b12      	ldr	r3, [pc, #72]	; (193d0 <local_miim_init+0x6c>)
   19388:	9301      	str	r3, [sp, #4]
		miimSetup.maxBusFreq = 2000000;
   1938a:	4b12      	ldr	r3, [pc, #72]	; (193d4 <local_miim_init+0x70>)
   1938c:	9302      	str	r3, [sp, #8]
		miimSetup.setupFlags = 0;
   1938e:	2300      	movs	r3, #0
   19390:	f88d 300c 	strb.w	r3, [sp, #12]
		res = clientObj.miimBase->DRV_MIIM_Setup(clientObj.miimHandle, &miimSetup);
   19394:	4b0c      	ldr	r3, [pc, #48]	; (193c8 <local_miim_init+0x64>)
   19396:	68db      	ldr	r3, [r3, #12]
   19398:	699b      	ldr	r3, [r3, #24]
   1939a:	a901      	add	r1, sp, #4
   1939c:	4798      	blx	r3
		if (res < 0)
   1939e:	1e04      	subs	r4, r0, #0
			SYS_CONSOLE_PRINT("> Local miim setup: failed!\r\n");
   193a0:	bfb4      	ite	lt
   193a2:	490d      	ldrlt	r1, [pc, #52]	; (193d8 <local_miim_init+0x74>)
			SYS_CONSOLE_PRINT("> Miim Successfully opened. \r\n");
   193a4:	490d      	ldrge	r1, [pc, #52]	; (193dc <local_miim_init+0x78>)
   193a6:	2000      	movs	r0, #0
   193a8:	f001 f9e0 	bl	1a76c <SYS_CONSOLE_Print>
}
   193ac:	4620      	mov	r0, r4
   193ae:	b004      	add	sp, #16
   193b0:	bd10      	pop	{r4, pc}
		SYS_CONSOLE_PRINT("> Local miim open: failed!\r\n");
   193b2:	490b      	ldr	r1, [pc, #44]	; (193e0 <local_miim_init+0x7c>)
   193b4:	2000      	movs	r0, #0
   193b6:	f001 f9d9 	bl	1a76c <SYS_CONSOLE_Print>
		clientObj.miimHandle = 0;
   193ba:	2200      	movs	r2, #0
   193bc:	60a2      	str	r2, [r4, #8]
		res = DRV_MIIM_RES_OP_INTERNAL_ERR;
   193be:	f06f 0413 	mvn.w	r4, #19
   193c2:	e7f3      	b.n	193ac <local_miim_init+0x48>
   193c4:	2000e6f8 	.word	0x2000e6f8
   193c8:	2000e4f0 	.word	0x2000e4f0
   193cc:	0001d7d4 	.word	0x0001d7d4
   193d0:	07270e00 	.word	0x07270e00
   193d4:	001e8480 	.word	0x001e8480
   193d8:	0000b124 	.word	0x0000b124
   193dc:	0000b144 	.word	0x0000b144
   193e0:	0000b104 	.word	0x0000b104

Disassembly of section .text.prvUnlockQueue%423:

000193e4 <prvUnlockQueue>:
{
   193e4:	b570      	push	{r4, r5, r6, lr}
   193e6:	4605      	mov	r5, r0
	taskENTER_CRITICAL();
   193e8:	f007 fb92 	bl	20b10 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
   193ec:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
   193f0:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
   193f2:	2c00      	cmp	r4, #0
   193f4:	dd11      	ble.n	1941a <prvUnlockQueue+0x36>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   193f6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   193f8:	b17b      	cbz	r3, 1941a <prvUnlockQueue+0x36>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   193fa:	f105 0624 	add.w	r6, r5, #36	; 0x24
   193fe:	e006      	b.n	1940e <prvUnlockQueue+0x2a>
						vTaskMissedYield();
   19400:	f008 fdb6 	bl	21f70 <vTaskMissedYield>
			--cTxLock;
   19404:	3c01      	subs	r4, #1
   19406:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
   19408:	b13c      	cbz	r4, 1941a <prvUnlockQueue+0x36>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1940a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1940c:	b12b      	cbz	r3, 1941a <prvUnlockQueue+0x36>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1940e:	4630      	mov	r0, r6
   19410:	f000 fd54 	bl	19ebc <xTaskRemoveFromEventList>
   19414:	2800      	cmp	r0, #0
   19416:	d0f5      	beq.n	19404 <prvUnlockQueue+0x20>
   19418:	e7f2      	b.n	19400 <prvUnlockQueue+0x1c>
		pxQueue->cTxLock = queueUNLOCKED;
   1941a:	23ff      	movs	r3, #255	; 0xff
   1941c:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	taskEXIT_CRITICAL();
   19420:	f008 fa4e 	bl	218c0 <vPortExitCritical>
	taskENTER_CRITICAL();
   19424:	f007 fb74 	bl	20b10 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
   19428:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
   1942c:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
   1942e:	2c00      	cmp	r4, #0
   19430:	dd11      	ble.n	19456 <prvUnlockQueue+0x72>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   19432:	692b      	ldr	r3, [r5, #16]
   19434:	b17b      	cbz	r3, 19456 <prvUnlockQueue+0x72>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   19436:	f105 0610 	add.w	r6, r5, #16
   1943a:	e006      	b.n	1944a <prvUnlockQueue+0x66>
					vTaskMissedYield();
   1943c:	f008 fd98 	bl	21f70 <vTaskMissedYield>
				--cRxLock;
   19440:	3c01      	subs	r4, #1
   19442:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
   19444:	b13c      	cbz	r4, 19456 <prvUnlockQueue+0x72>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   19446:	692b      	ldr	r3, [r5, #16]
   19448:	b12b      	cbz	r3, 19456 <prvUnlockQueue+0x72>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   1944a:	4630      	mov	r0, r6
   1944c:	f000 fd36 	bl	19ebc <xTaskRemoveFromEventList>
   19450:	2800      	cmp	r0, #0
   19452:	d0f5      	beq.n	19440 <prvUnlockQueue+0x5c>
   19454:	e7f2      	b.n	1943c <prvUnlockQueue+0x58>
		pxQueue->cRxLock = queueUNLOCKED;
   19456:	23ff      	movs	r3, #255	; 0xff
   19458:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	taskEXIT_CRITICAL();
   1945c:	f008 fa30 	bl	218c0 <vPortExitCritical>
}
   19460:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.__multadd%424:

00019462 <__multadd>:
   19462:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   19466:	690d      	ldr	r5, [r1, #16]
   19468:	461f      	mov	r7, r3
   1946a:	4606      	mov	r6, r0
   1946c:	460c      	mov	r4, r1
   1946e:	f101 0c14 	add.w	ip, r1, #20
   19472:	2300      	movs	r3, #0
   19474:	f64f 7eff 	movw	lr, #65535	; 0xffff
   19478:	f8dc 0000 	ldr.w	r0, [ip]
   1947c:	ea00 010e 	and.w	r1, r0, lr
   19480:	fb02 7101 	mla	r1, r2, r1, r7
   19484:	0c0f      	lsrs	r7, r1, #16
   19486:	0c00      	lsrs	r0, r0, #16
   19488:	fb02 7000 	mla	r0, r2, r0, r7
   1948c:	ea01 010e 	and.w	r1, r1, lr
   19490:	3301      	adds	r3, #1
   19492:	eb01 4100 	add.w	r1, r1, r0, lsl #16
   19496:	429d      	cmp	r5, r3
   19498:	ea4f 4710 	mov.w	r7, r0, lsr #16
   1949c:	f84c 1b04 	str.w	r1, [ip], #4
   194a0:	dcea      	bgt.n	19478 <__multadd+0x16>
   194a2:	b1d7      	cbz	r7, 194da <__multadd+0x78>
   194a4:	68a3      	ldr	r3, [r4, #8]
   194a6:	42ab      	cmp	r3, r5
   194a8:	dc12      	bgt.n	194d0 <__multadd+0x6e>
   194aa:	6861      	ldr	r1, [r4, #4]
   194ac:	4630      	mov	r0, r6
   194ae:	3101      	adds	r1, #1
   194b0:	f001 fbd4 	bl	1ac5c <_Balloc>
   194b4:	6922      	ldr	r2, [r4, #16]
   194b6:	3202      	adds	r2, #2
   194b8:	f104 010c 	add.w	r1, r4, #12
   194bc:	4680      	mov	r8, r0
   194be:	0092      	lsls	r2, r2, #2
   194c0:	300c      	adds	r0, #12
   194c2:	f007 fdcd 	bl	21060 <memcpy>
   194c6:	4621      	mov	r1, r4
   194c8:	4630      	mov	r0, r6
   194ca:	f006 f8c4 	bl	1f656 <_Bfree>
   194ce:	4644      	mov	r4, r8
   194d0:	eb04 0385 	add.w	r3, r4, r5, lsl #2
   194d4:	3501      	adds	r5, #1
   194d6:	615f      	str	r7, [r3, #20]
   194d8:	6125      	str	r5, [r4, #16]
   194da:	4620      	mov	r0, r4
   194dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.DRV_ETHPHY_VendorSMIReadResultGet%425:

000194e0 <DRV_ETHPHY_VendorSMIReadResultGet>:
{
   194e0:	b570      	push	{r4, r5, r6, lr}
    if(hClientObj == 0 || _DRVHandleToInst(hClientObj->hDriver) == 0)
   194e2:	b320      	cbz	r0, 1952e <DRV_ETHPHY_VendorSMIReadResultGet+0x4e>
   194e4:	4604      	mov	r4, r0
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   194e6:	68c0      	ldr	r0, [r0, #12]
   194e8:	4a1b      	ldr	r2, [pc, #108]	; (19558 <DRV_ETHPHY_VendorSMIReadResultGet+0x78>)
   194ea:	4290      	cmp	r0, r2
   194ec:	d122      	bne.n	19534 <DRV_ETHPHY_VendorSMIReadResultGet+0x54>
    if( hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_BUSY || 
   194ee:	f994 5008 	ldrsb.w	r5, [r4, #8]
   194f2:	2d01      	cmp	r5, #1
   194f4:	d122      	bne.n	1953c <DRV_ETHPHY_VendorSMIReadResultGet+0x5c>
   194f6:	8ba2      	ldrh	r2, [r4, #28]
   194f8:	2a01      	cmp	r2, #1
   194fa:	d122      	bne.n	19542 <DRV_ETHPHY_VendorSMIReadResultGet+0x62>
        hClientObj->operType != DRV_ETHPHY_CLIENT_OP_TYPE_SETUP || 
   194fc:	8be2      	ldrh	r2, [r4, #30]
   194fe:	f022 0202 	bic.w	r2, r2, #2
   19502:	b292      	uxth	r2, r2
   19504:	2a01      	cmp	r2, #1
   19506:	d002      	beq.n	1950e <DRV_ETHPHY_VendorSMIReadResultGet+0x2e>
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   19508:	f06f 0509 	mvn.w	r5, #9
   1950c:	e014      	b.n	19538 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
    if(hClientObj->smiTxferStatus != DRV_ETHPHY_SMI_TXFER_OP_WAIT_COMPLETE)
   1950e:	8ea2      	ldrh	r2, [r4, #52]	; 0x34
   19510:	2a02      	cmp	r2, #2
   19512:	d119      	bne.n	19548 <DRV_ETHPHY_VendorSMIReadResultGet+0x68>
   19514:	460e      	mov	r6, r1
    DRV_ETHPHY_SMI_TXFER_RES opRes = _DRV_PHY_SMITransferWaitComplete(hClientObj);
   19516:	4620      	mov	r0, r4
   19518:	f002 fb97 	bl	1bc4a <_DRV_PHY_SMITransferWaitComplete>
    if(opRes < 0)
   1951c:	2800      	cmp	r0, #0
   1951e:	db16      	blt.n	1954e <DRV_ETHPHY_VendorSMIReadResultGet+0x6e>
    else if(opRes == DRV_ETHPHY_SMI_TXFER_RES_WAIT)
   19520:	2802      	cmp	r0, #2
   19522:	d009      	beq.n	19538 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
    if(pSmiRes)
   19524:	b1b6      	cbz	r6, 19554 <DRV_ETHPHY_VendorSMIReadResultGet+0x74>
        *pSmiRes = hClientObj->smiData;
   19526:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   19528:	8033      	strh	r3, [r6, #0]
    return DRV_ETHPHY_RES_OK;
   1952a:	2500      	movs	r5, #0
   1952c:	e004      	b.n	19538 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
        return DRV_ETHPHY_RES_HANDLE_ERR;
   1952e:	f06f 050a 	mvn.w	r5, #10
   19532:	e001      	b.n	19538 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
   19534:	f06f 050a 	mvn.w	r5, #10
}
   19538:	4628      	mov	r0, r5
   1953a:	bd70      	pop	{r4, r5, r6, pc}
        return DRV_ETHPHY_RES_NOT_READY_ERR;
   1953c:	f06f 0509 	mvn.w	r5, #9
   19540:	e7fa      	b.n	19538 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
   19542:	f06f 0509 	mvn.w	r5, #9
   19546:	e7f7      	b.n	19538 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   19548:	f06f 0508 	mvn.w	r5, #8
   1954c:	e7f4      	b.n	19538 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
        return DRV_ETHPHY_RES_OPERATION_ERR;
   1954e:	f06f 0508 	mvn.w	r5, #8
   19552:	e7f1      	b.n	19538 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
    return DRV_ETHPHY_RES_OK;
   19554:	2500      	movs	r5, #0
   19556:	e7ef      	b.n	19538 <DRV_ETHPHY_VendorSMIReadResultGet+0x58>
   19558:	2000e018 	.word	0x2000e018

Disassembly of section .text.DRV_PIC32CGMAC_LibInit%426:

0001955c <DRV_PIC32CGMAC_LibInit>:
{		
   1955c:	b508      	push	{r3, lr}
    MCLK_REGS->MCLK_AHBMASK |= MCLK_AHBMASK_GMAC(1);	
   1955e:	4b1b      	ldr	r3, [pc, #108]	; (195cc <DRV_PIC32CGMAC_LibInit+0x70>)
   19560:	691a      	ldr	r2, [r3, #16]
   19562:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   19566:	611a      	str	r2, [r3, #16]
    MCLK_REGS->MCLK_APBCMASK |= MCLK_APBCMASK_GMAC(1);
   19568:	69da      	ldr	r2, [r3, #28]
   1956a:	f042 0204 	orr.w	r2, r2, #4
   1956e:	61da      	str	r2, [r3, #28]
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_TXEN_Msk;
   19570:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
   19574:	681a      	ldr	r2, [r3, #0]
   19576:	f022 0208 	bic.w	r2, r2, #8
   1957a:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_RXEN_Msk;
   1957c:	681a      	ldr	r2, [r3, #0]
   1957e:	f022 0204 	bic.w	r2, r2, #4
   19582:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_IDR = GMAC_INT_ALL;	//Clear statistics register
   19584:	f04f 32ff 	mov.w	r2, #4294967295
   19588:	62da      	str	r2, [r3, #44]	; 0x2c
	GMAC_REGS->GMAC_NCR |=  GMAC_NCR_CLRSTAT_Msk;
   1958a:	681a      	ldr	r2, [r3, #0]
   1958c:	f042 0220 	orr.w	r2, r2, #32
   19590:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_RSR =  GMAC_RSR_RXOVR_Msk | GMAC_RSR_REC_Msk | GMAC_RSR_BNA_Msk  | GMAC_RSR_HNO_Msk;
   19592:	220f      	movs	r2, #15
   19594:	621a      	str	r2, [r3, #32]
	GMAC_REGS->GMAC_TSR = GMAC_TSR_UBR_Msk  | GMAC_TSR_COL_Msk  | GMAC_TSR_RLE_Msk | GMAC_TSR_TXGO_Msk |
   19596:	f240 123f 	movw	r2, #319	; 0x13f
   1959a:	615a      	str	r2, [r3, #20]
	GMAC_REGS->GMAC_ISR;
   1959c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
                            | GMAC_NCFGR_MAXFS(GMAC_MAX_RXFS)| GMAC_NCFGR_RXBUFO(pMACDrv->sGmacData._dataOffset);
   1959e:	f890 20f6 	ldrb.w	r2, [r0, #246]	; 0xf6
   195a2:	0392      	lsls	r2, r2, #14
   195a4:	b292      	uxth	r2, r2
   195a6:	490a      	ldr	r1, [pc, #40]	; (195d0 <DRV_PIC32CGMAC_LibInit+0x74>)
   195a8:	4311      	orrs	r1, r2
    GMAC_REGS->GMAC_NCFGR = GMAC_NCFGR_SPD(1) | GMAC_NCFGR_FD(1) | GMAC_NCFGR_CLK(3)  |	GMAC_NCFGR_PEN(1)  | GMAC_NCFGR_RFCS(1)
   195aa:	6059      	str	r1, [r3, #4]
	if((pMACDrv->sGmacData.gmacConfig.checksumOffloadRx) != TCPIP_MAC_CHECKSUM_NONE)
   195ac:	f890 30e0 	ldrb.w	r3, [r0, #224]	; 0xe0
   195b0:	b123      	cbz	r3, 195bc <DRV_PIC32CGMAC_LibInit+0x60>
        GMAC_REGS->GMAC_NCFGR |= GMAC_NCFGR_RXCOEN_Msk;
   195b2:	4a08      	ldr	r2, [pc, #32]	; (195d4 <DRV_PIC32CGMAC_LibInit+0x78>)
   195b4:	6853      	ldr	r3, [r2, #4]
   195b6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   195ba:	6053      	str	r3, [r2, #4]
    DRV_PIC32CGMAC_LibSetMacAddr((const uint8_t *)(pMACDrv->sGmacData.gmacConfig.macAddress.v));
   195bc:	30b8      	adds	r0, #184	; 0xb8
   195be:	f005 fc81 	bl	1eec4 <DRV_PIC32CGMAC_LibSetMacAddr>
		GMAC_REGS->GMAC_UR = GMAC_UR_MII(0); //initial mode set as RMII
   195c2:	4b04      	ldr	r3, [pc, #16]	; (195d4 <DRV_PIC32CGMAC_LibInit+0x78>)
   195c4:	2200      	movs	r2, #0
   195c6:	60da      	str	r2, [r3, #12]
}
   195c8:	bd08      	pop	{r3, pc}
   195ca:	bf00      	nop
   195cc:	40000800 	.word	0x40000800
   195d0:	000e2103 	.word	0x000e2103
   195d4:	42000800 	.word	0x42000800

Disassembly of section .text.SYS_Tasks%427:

000195d8 <SYS_Tasks>:

  Remarks:
    See prototype in system/common/sys_module.h.
*/
void SYS_Tasks ( void )
{
   195d8:	b570      	push	{r4, r5, r6, lr}
   195da:	b082      	sub	sp, #8
    /* Maintain system services */
    

    xTaskCreate( _SYS_CMD_Tasks,
   195dc:	4d17      	ldr	r5, [pc, #92]	; (1963c <SYS_Tasks+0x64>)
   195de:	2400      	movs	r4, #0
   195e0:	9401      	str	r4, [sp, #4]
   195e2:	2601      	movs	r6, #1
   195e4:	9600      	str	r6, [sp, #0]
   195e6:	4623      	mov	r3, r4
   195e8:	f44f 6220 	mov.w	r2, #2560	; 0xa00
   195ec:	4629      	mov	r1, r5
   195ee:	4814      	ldr	r0, [pc, #80]	; (19640 <SYS_Tasks+0x68>)
   195f0:	f7f5 fd5e 	bl	f0b0 <xTaskCreate>




    /* Maintain Device Drivers */
        xTaskCreate( _DRV_MIIM_Task,
   195f4:	9401      	str	r4, [sp, #4]
   195f6:	9600      	str	r6, [sp, #0]
   195f8:	4623      	mov	r3, r4
   195fa:	f44f 6280 	mov.w	r2, #1024	; 0x400
   195fe:	f105 0110 	add.w	r1, r5, #16
   19602:	4810      	ldr	r0, [pc, #64]	; (19644 <SYS_Tasks+0x6c>)
   19604:	f7f5 fd54 	bl	f0b0 <xTaskCreate>



    /* Maintain Middleware & Other Libraries */
    
    xTaskCreate( _TCPIP_STACK_Task,
   19608:	9401      	str	r4, [sp, #4]
   1960a:	9600      	str	r6, [sp, #0]
   1960c:	4623      	mov	r3, r4
   1960e:	f44f 6280 	mov.w	r2, #1024	; 0x400
   19612:	f105 0120 	add.w	r1, r5, #32
   19616:	480c      	ldr	r0, [pc, #48]	; (19648 <SYS_Tasks+0x70>)
   19618:	f7f5 fd4a 	bl	f0b0 <xTaskCreate>



    /* Maintain the application's state machine. */
        /* Create OS Thread for APP_Tasks. */
    xTaskCreate((TaskFunction_t) _APP_Tasks,
   1961c:	4b0b      	ldr	r3, [pc, #44]	; (1964c <SYS_Tasks+0x74>)
   1961e:	9301      	str	r3, [sp, #4]
   19620:	9600      	str	r6, [sp, #0]
   19622:	4623      	mov	r3, r4
   19624:	f44f 6280 	mov.w	r2, #1024	; 0x400
   19628:	f105 0134 	add.w	r1, r5, #52	; 0x34
   1962c:	4808      	ldr	r0, [pc, #32]	; (19650 <SYS_Tasks+0x78>)
   1962e:	f7f5 fd3f 	bl	f0b0 <xTaskCreate>
    /* Start RTOS Scheduler. */
    
     /**********************************************************************
     * Create all Threads for APP Tasks before starting FreeRTOS Scheduler *
     ***********************************************************************/
    vTaskStartScheduler(); /* This function never returns. */
   19632:	f001 fd0f 	bl	1b054 <vTaskStartScheduler>

}
   19636:	b002      	add	sp, #8
   19638:	bd70      	pop	{r4, r5, r6, pc}
   1963a:	bf00      	nop
   1963c:	0001dad4 	.word	0x0001dad4
   19640:	00021aed 	.word	0x00021aed
   19644:	000215bd 	.word	0x000215bd
   19648:	000215a5 	.word	0x000215a5
   1964c:	2000e690 	.word	0x2000e690
   19650:	00021add 	.word	0x00021add

Disassembly of section .text.SYS_Initialize%428:

00019654 <SYS_Initialize>:

  Remarks:
 */

void SYS_Initialize ( void* data )
{
   19654:	b510      	push	{r4, lr}

    NVMCTRL_Initialize( );
   19656:	f008 fa21 	bl	21a9c <NVMCTRL_Initialize>

  
    PORT_Initialize();
   1965a:	f7fc f827 	bl	156ac <PORT_Initialize>

    CLOCK_Initialize();
   1965e:	f7fa fdfb 	bl	14258 <CLOCK_Initialize>




    TC0_TimerInitialize();
   19662:	f004 f9f7 	bl	1da54 <TC0_TimerInitialize>

    SERCOM1_USART_Initialize();
   19666:	f7ff fcfd 	bl	19064 <SERCOM1_USART_Initialize>

    EVSYS_Initialize();
   1966a:	f7fa fc7a 	bl	13f62 <EVSYS_Initialize>

    SERCOM0_SPI_Initialize();
   1966e:	f004 ffad 	bl	1e5cc <SERCOM0_SPI_Initialize>



    /* Initialize the MIIM Driver */
    sysObj.drvMiim = DRV_MIIM_Initialize( DRV_MIIM_INDEX_0, (const SYS_MODULE_INIT *) &drvMiimInitData );
   19672:	4911      	ldr	r1, [pc, #68]	; (196b8 <SYS_Initialize+0x64>)
   19674:	2000      	movs	r0, #0
   19676:	f000 f95b 	bl	19930 <DRV_MIIM_Initialize>
   1967a:	4c10      	ldr	r4, [pc, #64]	; (196bc <SYS_Initialize+0x68>)
   1967c:	60e0      	str	r0, [r4, #12]


    sysObj.sysTime = SYS_TIME_Initialize(SYS_TIME_INDEX_0, (SYS_MODULE_INIT *)&sysTimeInitData);
   1967e:	4910      	ldr	r1, [pc, #64]	; (196c0 <SYS_Initialize+0x6c>)
   19680:	2000      	movs	r0, #0
   19682:	f7fd fa6d 	bl	16b60 <SYS_TIME_Initialize>
   19686:	6020      	str	r0, [r4, #0]
    sysObj.sysConsole0 = SYS_CONSOLE_Initialize(SYS_CONSOLE_INDEX_0, (SYS_MODULE_INIT *)&sysConsole0Init);
   19688:	490e      	ldr	r1, [pc, #56]	; (196c4 <SYS_Initialize+0x70>)
   1968a:	2000      	movs	r0, #0
   1968c:	f001 fa4a 	bl	1ab24 <SYS_CONSOLE_Initialize>
   19690:	6060      	str	r0, [r4, #4]

    SYS_CMD_Initialize((SYS_MODULE_INIT*)&sysCmdInit);
   19692:	480d      	ldr	r0, [pc, #52]	; (196c8 <SYS_Initialize+0x74>)
   19694:	f004 ffb6 	bl	1e604 <SYS_CMD_Initialize>

    sysObj.sysDebug = SYS_DEBUG_Initialize(SYS_DEBUG_INDEX_0, (SYS_MODULE_INIT*)&debugInit);
   19698:	490c      	ldr	r1, [pc, #48]	; (196cc <SYS_Initialize+0x78>)
   1969a:	2000      	movs	r0, #0
   1969c:	f007 fc62 	bl	20f64 <SYS_DEBUG_Initialize>
   196a0:	6120      	str	r0, [r4, #16]




/* TCPIP Stack Initialization */
sysObj.tcpip = TCPIP_STACK_Init();
   196a2:	f006 f90d 	bl	1f8c0 <TCPIP_STACK_Init>
   196a6:	60a0      	str	r0, [r4, #8]
SYS_ASSERT(sysObj.tcpip != SYS_MODULE_OBJ_INVALID, "TCPIP_STACK_Init Failed" );


    CRYPT_WCCB_Initialize();
   196a8:	f008 f91e 	bl	218e8 <CRYPT_WCCB_Initialize>

    APP_Initialize();
   196ac:	f005 fe4a 	bl	1f344 <APP_Initialize>


    NVIC_Initialize();
   196b0:	f7fe fec4 	bl	1843c <NVIC_Initialize>

}
   196b4:	bd10      	pop	{r4, pc}
   196b6:	bf00      	nop
   196b8:	000220b4 	.word	0x000220b4
   196bc:	2000e464 	.word	0x2000e464
   196c0:	000220bc 	.word	0x000220bc
   196c4:	00021f64 	.word	0x00021f64
   196c8:	2000e694 	.word	0x2000e694
   196cc:	00022150 	.word	0x00022150

Disassembly of section .text.gfx_mono_draw_string_n%429:

000196d0 <gfx_mono_draw_string_n>:
        const struct font *font) {
   196d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   196d4:	9e08      	ldr	r6, [sp, #32]
    assert(str != NULL);
   196d6:	b140      	cbz	r0, 196ea <gfx_mono_draw_string_n+0x1a>
   196d8:	4698      	mov	r8, r3
   196da:	4605      	mov	r5, r0
    assert(font != NULL);
   196dc:	b176      	cbz	r6, 196fc <gfx_mono_draw_string_n+0x2c>
   196de:	1e44      	subs	r4, r0, #1
   196e0:	3901      	subs	r1, #1
   196e2:	440d      	add	r5, r1
   196e4:	4691      	mov	r9, r2
            x = start_of_string_position_x;
   196e6:	4617      	mov	r7, r2
   196e8:	e019      	b.n	1971e <gfx_mono_draw_string_n+0x4e>
    assert(str != NULL);
   196ea:	4816      	ldr	r0, [pc, #88]	; (19744 <gfx_mono_draw_string_n+0x74>)
   196ec:	f100 0328 	add.w	r3, r0, #40	; 0x28
   196f0:	4a15      	ldr	r2, [pc, #84]	; (19748 <gfx_mono_draw_string_n+0x78>)
   196f2:	f240 111d 	movw	r1, #285	; 0x11d
   196f6:	3008      	adds	r0, #8
   196f8:	f004 fd64 	bl	1e1c4 <__assert_func>
    assert(font != NULL);
   196fc:	4811      	ldr	r0, [pc, #68]	; (19744 <gfx_mono_draw_string_n+0x74>)
   196fe:	f100 0334 	add.w	r3, r0, #52	; 0x34
   19702:	4a11      	ldr	r2, [pc, #68]	; (19748 <gfx_mono_draw_string_n+0x78>)
   19704:	f44f 718f 	mov.w	r1, #286	; 0x11e
   19708:	3008      	adds	r0, #8
   1970a:	f004 fd5b 	bl	1e1c4 <__assert_func>
            y += font->height + 1;
   1970e:	7a73      	ldrb	r3, [r6, #9]
   19710:	3301      	adds	r3, #1
   19712:	4443      	add	r3, r8
   19714:	fa5f f883 	uxtb.w	r8, r3
            x = start_of_string_position_x;
   19718:	46b9      	mov	r9, r7
    } while (--len);
   1971a:	42ac      	cmp	r4, r5
   1971c:	d00f      	beq.n	1973e <gfx_mono_draw_string_n+0x6e>
        if (*str == '\n') {
   1971e:	f814 0f01 	ldrb.w	r0, [r4, #1]!
   19722:	280a      	cmp	r0, #10
   19724:	d0f3      	beq.n	1970e <gfx_mono_draw_string_n+0x3e>
        } else if (*str == '\r') {
   19726:	280d      	cmp	r0, #13
   19728:	d0f7      	beq.n	1971a <gfx_mono_draw_string_n+0x4a>
            gfx_mono_draw_char(*str, x, y, font);
   1972a:	4633      	mov	r3, r6
   1972c:	4642      	mov	r2, r8
   1972e:	4649      	mov	r1, r9
   19730:	f7fc ff44 	bl	165bc <gfx_mono_draw_char>
            x += font->width;
   19734:	7a33      	ldrb	r3, [r6, #8]
   19736:	4499      	add	r9, r3
   19738:	fa5f f989 	uxtb.w	r9, r9
   1973c:	e7ed      	b.n	1971a <gfx_mono_draw_string_n+0x4a>
}
   1973e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   19742:	bf00      	nop
   19744:	0001d438 	.word	0x0001d438
   19748:	0002161c 	.word	0x0002161c

Disassembly of section .text.TCPIP_TCP_SocketInfoGet%430:

0001974c <TCPIP_TCP_SocketInfoGet>:
{
   1974c:	b570      	push	{r4, r5, r6, lr}
   1974e:	4606      	mov	r6, r0
   19750:	460d      	mov	r5, r1
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   19752:	f006 faaf 	bl	1fcb4 <_TcpSocketChk>
    if(pSkt == 0)
   19756:	2800      	cmp	r0, #0
   19758:	d033      	beq.n	197c2 <TCPIP_TCP_SocketInfoGet+0x76>
   1975a:	4604      	mov	r4, r0
        memset(remoteInfo, 0, sizeof(*remoteInfo));
   1975c:	2238      	movs	r2, #56	; 0x38
   1975e:	2100      	movs	r1, #0
   19760:	4628      	mov	r0, r5
   19762:	f008 fa0b 	bl	21b7c <memset>
        if (pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   19766:	f894 306f 	ldrb.w	r3, [r4, #111]	; 0x6f
   1976a:	2b01      	cmp	r3, #1
   1976c:	d022      	beq.n	197b4 <TCPIP_TCP_SocketInfoGet+0x68>
	remoteInfo->remotePort = pSkt->remotePort;
   1976e:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
   19772:	84ab      	strh	r3, [r5, #36]	; 0x24
	remoteInfo->localPort = pSkt->localPort;
   19774:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
   19778:	84eb      	strh	r3, [r5, #38]	; 0x26
	remoteInfo->hNet = pSkt->pSktNet;
   1977a:	6c23      	ldr	r3, [r4, #64]	; 0x40
   1977c:	62ab      	str	r3, [r5, #40]	; 0x28
	remoteInfo->state = (TCPIP_TCP_STATE)pSkt->smState;
   1977e:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
   19782:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
    remoteInfo->rxSize = pSkt->rxEnd - pSkt->rxStart;
   19786:	69a3      	ldr	r3, [r4, #24]
   19788:	6962      	ldr	r2, [r4, #20]
   1978a:	1a9b      	subs	r3, r3, r2
   1978c:	85eb      	strh	r3, [r5, #46]	; 0x2e
    remoteInfo->txSize = pSkt->txEnd - pSkt->txStart;
   1978e:	6863      	ldr	r3, [r4, #4]
   19790:	6822      	ldr	r2, [r4, #0]
   19792:	1a9b      	subs	r3, r3, r2
   19794:	862b      	strh	r3, [r5, #48]	; 0x30
    remoteInfo->rxPending = _TCPIsGetReady(pSkt);
   19796:	4620      	mov	r0, r4
   19798:	f007 fa29 	bl	20bee <_TCPIsGetReady>
   1979c:	8668      	strh	r0, [r5, #50]	; 0x32
    remoteInfo->txPending = TCPIP_TCP_FifoTxFullGet(hTCP);
   1979e:	4630      	mov	r0, r6
   197a0:	f003 fc24 	bl	1cfec <TCPIP_TCP_FifoTxFullGet>
   197a4:	86a8      	strh	r0, [r5, #52]	; 0x34
    remoteInfo->flags = _TCP_SktFlagsGet(pSkt);
   197a6:	4620      	mov	r0, r4
   197a8:	f005 f83c 	bl	1e824 <_TCP_SktFlagsGet>
   197ac:	f885 0036 	strb.w	r0, [r5, #54]	; 0x36
	return true;
   197b0:	2001      	movs	r0, #1
}
   197b2:	bd70      	pop	{r4, r5, r6, pc}
            remoteInfo->remoteIPaddress.v4Add = pSkt->destAddress;
   197b4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   197b6:	606b      	str	r3, [r5, #4]
            remoteInfo->localIPaddress.v4Add = pSkt->srcAddress;
   197b8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   197ba:	616b      	str	r3, [r5, #20]
            remoteInfo->addressType = IP_ADDRESS_TYPE_IPV4;
   197bc:	2301      	movs	r3, #1
   197be:	702b      	strb	r3, [r5, #0]
   197c0:	e7d5      	b.n	1976e <TCPIP_TCP_SocketInfoGet+0x22>
        return false;
   197c2:	2000      	movs	r0, #0
   197c4:	e7f5      	b.n	197b2 <TCPIP_TCP_SocketInfoGet+0x66>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4%431:

000197c6 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4>:
{
   197c6:	b510      	push	{r4, lr}
   197c8:	4604      	mov	r4, r0
    DRV_ETHPHY_INSTANCE *hDriver = hClientObj->hDriver;
   197ca:	68c1      	ldr	r1, [r0, #12]
    uint16_t  matchCpbl = hClientObj->operReg[1];
   197cc:	8c83      	ldrh	r3, [r0, #36]	; 0x24
    if(matchCpbl &_BMSTAT_AN_ABLE_MASK)
   197ce:	f013 0f08 	tst.w	r3, #8
   197d2:	d018      	beq.n	19806 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4+0x40>
        anadReg = (((matchCpbl >> _BMSTAT_NEGOTIATION_POS) << _ANAD_NEGOTIATION_POS) & _ANAD_NEGOTIATION_MASK) | PROT_802_3;
   197d4:	0ada      	lsrs	r2, r3, #11
   197d6:	0152      	lsls	r2, r2, #5
   197d8:	f042 0201 	orr.w	r2, r2, #1
        if(hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_PAUSE)
   197dc:	7bcb      	ldrb	r3, [r1, #15]
   197de:	f013 0f01 	tst.w	r3, #1
            anadReg |= _ANAD_PAUSE_MASK;
   197e2:	bf18      	it	ne
   197e4:	f442 6280 	orrne.w	r2, r2, #1024	; 0x400
        if(hDriver->macPauseType & TCPIP_ETH_PAUSE_TYPE_ASM_DIR)
   197e8:	f013 0f02 	tst.w	r3, #2
            anadReg |= _ANAD_ASM_DIR_MASK;
   197ec:	bf18      	it	ne
   197ee:	f442 6200 	orrne.w	r2, r2, #2048	; 0x800
        if(_DRV_PHY_SMIWriteStart(hClientObj, PHY_REG_ANAD, anadReg))
   197f2:	2104      	movs	r1, #4
   197f4:	f005 fab9 	bl	1ed6a <_DRV_PHY_SMIWriteStart>
   197f8:	b900      	cbnz	r0, 197fc <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4+0x36>
}
   197fa:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   197fc:	2303      	movs	r3, #3
   197fe:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   19800:	2305      	movs	r3, #5
   19802:	8423      	strh	r3, [r4, #32]
   19804:	e7f9      	b.n	197fa <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4+0x34>
        if(matchCpbl & (_BMSTAT_BASE100TX_HDX_MASK | _BMSTAT_BASE100TX_FDX_MASK))   // set 100Mbps request/capability
   19806:	f403 42c0 	and.w	r2, r3, #24576	; 0x6000
            ctrlReg |= _BMCON_SPEED_MASK;
   1980a:	2a00      	cmp	r2, #0
   1980c:	bf18      	it	ne
   1980e:	f44f 5200 	movne.w	r2, #8192	; 0x2000
        if(matchCpbl & (_BMSTAT_BASE10T_FDX_MASK | _BMSTAT_BASE100TX_FDX_MASK))
   19812:	f413 4fa0 	tst.w	r3, #20480	; 0x5000
            ctrlReg |= _BMCON_DUPLEX_MASK;
   19816:	bf18      	it	ne
   19818:	f442 7280 	orrne.w	r2, r2, #256	; 0x100
        if(hClientObj->hDriver->openFlags & TCPIP_ETH_OPEN_PHY_LOOPBACK)
   1981c:	898b      	ldrh	r3, [r1, #12]
   1981e:	f013 0f80 	tst.w	r3, #128	; 0x80
            ctrlReg |= _BMCON_LOOPBACK_MASK;
   19822:	bf1c      	itt	ne
   19824:	f442 4280 	orrne.w	r2, r2, #16384	; 0x4000
   19828:	b292      	uxthne	r2, r2
        if(_DRV_PHY_SMIWriteStart(hClientObj, PHY_REG_BMCON, ctrlReg))
   1982a:	2100      	movs	r1, #0
   1982c:	f005 fa9d 	bl	1ed6a <_DRV_PHY_SMIWriteStart>
   19830:	2800      	cmp	r0, #0
   19832:	d0e2      	beq.n	197fa <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4+0x34>
    hClientObj->operPhase = operPhase;
   19834:	2303      	movs	r3, #3
   19836:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   19838:	2307      	movs	r3, #7
   1983a:	8423      	strh	r3, [r4, #32]
}
   1983c:	e7dd      	b.n	197fa <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase4+0x34>

Disassembly of section .text.DRV_PIC32CGMAC_LibTxInit%432:

00019840 <DRV_PIC32CGMAC_LibTxInit>:
{
   19840:	b410      	push	{r4}
    pL->head = pL->tail = 0;
   19842:	2300      	movs	r3, #0
   19844:	f8c0 30a8 	str.w	r3, [r0, #168]	; 0xa8
   19848:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
    pL->nNodes = 0;
   1984c:	f8c0 30ac 	str.w	r3, [r0, #172]	; 0xac
		for(desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nTxDescCnt; desc_idx++)
   19850:	f8b0 30c8 	ldrh.w	r3, [r0, #200]	; 0xc8
   19854:	b35b      	cbz	r3, 198ae <DRV_PIC32CGMAC_LibTxInit+0x6e>
   19856:	2300      	movs	r3, #0
            pMACDrv->sGmacData.gmac_queue[queue_idx].nTxDescHead = 0;
   19858:	4619      	mov	r1, r3
			pMACDrv->sGmacData.gmac_queue[queue_idx].pTxDesc[desc_idx].tx_desc_status.val = GMAC_TX_USED_BIT | GMAC_TX_LAST_BUFFER_BIT;
   1985a:	f04f 2480 	mov.w	r4, #2147516416	; 0x80008000
            pMACDrv->sGmacData.gmac_queue[queue_idx].nTxDescHead = 0;
   1985e:	f8a0 10b2 	strh.w	r1, [r0, #178]	; 0xb2
            pMACDrv->sGmacData.gmac_queue[queue_idx].nTxDescTail = 0;
   19862:	f8a0 10b4 	strh.w	r1, [r0, #180]	; 0xb4
			pMACDrv->sGmacData.gmac_queue[queue_idx].pTxDesc[desc_idx].tx_desc_buffaddr = 0;
   19866:	f8d0 20a0 	ldr.w	r2, [r0, #160]	; 0xa0
   1986a:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
			pMACDrv->sGmacData.gmac_queue[queue_idx].pTxDesc[desc_idx].tx_desc_status.val = GMAC_TX_USED_BIT | GMAC_TX_LAST_BUFFER_BIT;
   1986e:	f8d0 20a0 	ldr.w	r2, [r0, #160]	; 0xa0
   19872:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
   19876:	6054      	str	r4, [r2, #4]
		for(desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nTxDescCnt; desc_idx++)
   19878:	3301      	adds	r3, #1
   1987a:	b2db      	uxtb	r3, r3
   1987c:	f8b0 20c8 	ldrh.w	r2, [r0, #200]	; 0xc8
   19880:	429a      	cmp	r2, r3
   19882:	d8ec      	bhi.n	1985e <DRV_PIC32CGMAC_LibTxInit+0x1e>
		pMACDrv->sGmacData.gmac_queue[queue_idx].pTxDesc[desc_idx-1].tx_desc_status.val |= GMAC_TX_WRAP_BIT;
   19884:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
   19888:	3b01      	subs	r3, #1
   1988a:	f8d0 20a0 	ldr.w	r2, [r0, #160]	; 0xa0
   1988e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   19892:	685a      	ldr	r2, [r3, #4]
   19894:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
   19898:	605a      	str	r2, [r3, #4]
		GMAC_REGS->GMAC_TBQB = GMAC_TBQB_ADDR_Msk & ((uint32_t)pMACDrv->sGmacData.gmac_queue[queue_idx].pTxDesc);
   1989a:	f8d0 30a0 	ldr.w	r3, [r0, #160]	; 0xa0
   1989e:	f023 0303 	bic.w	r3, r3, #3
   198a2:	4a04      	ldr	r2, [pc, #16]	; (198b4 <DRV_PIC32CGMAC_LibTxInit+0x74>)
   198a4:	61d3      	str	r3, [r2, #28]
}//DRV_PIC32CGMAC_LibTxInit
   198a6:	2000      	movs	r0, #0
   198a8:	f85d 4b04 	ldr.w	r4, [sp], #4
   198ac:	4770      	bx	lr
		for(desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nTxDescCnt; desc_idx++)
   198ae:	2300      	movs	r3, #0
   198b0:	e7e8      	b.n	19884 <DRV_PIC32CGMAC_LibTxInit+0x44>
   198b2:	bf00      	nop
   198b4:	42000800 	.word	0x42000800

Disassembly of section .text.DRV_MIIM_Open%433:

000198b8 <DRV_MIIM_Open>:
{
   198b8:	b510      	push	{r4, lr}
        if(iModule >= DRV_MIIM_INSTANCES_NUMBER)
   198ba:	b118      	cbz	r0, 198c4 <DRV_MIIM_Open+0xc>
    DRV_HANDLE drvHandle = DRV_HANDLE_INVALID;
   198bc:	f04f 34ff 	mov.w	r4, #4294967295
}
   198c0:	4620      	mov	r0, r4
   198c2:	bd10      	pop	{r4, pc}
   198c4:	460c      	mov	r4, r1
        pMiimObj = _DRV_MIIM_GetObjectAndLock((SYS_MODULE_OBJ)(gDrvMIIMObj + iModule));
   198c6:	4819      	ldr	r0, [pc, #100]	; (1992c <DRV_MIIM_Open+0x74>)
   198c8:	f005 fd83 	bl	1f3d2 <_DRV_MIIM_GetObjectAndLock>
        if(pMiimObj == 0)
   198cc:	4603      	mov	r3, r0
   198ce:	b180      	cbz	r0, 198f2 <DRV_MIIM_Open+0x3a>
        if((ioIntent & DRV_IO_INTENT_EXCLUSIVE) != 0)
   198d0:	f014 0108 	ands.w	r1, r4, #8
   198d4:	d001      	beq.n	198da <DRV_MIIM_Open+0x22>
            if(pMiimObj->numClients > 0)
   198d6:	88c2      	ldrh	r2, [r0, #6]
   198d8:	b972      	cbnz	r2, 198f8 <DRV_MIIM_Open+0x40>
        if(pClient->clientInUse == 0)
   198da:	8a1a      	ldrh	r2, [r3, #16]
   198dc:	b17a      	cbz	r2, 198fe <DRV_MIIM_Open+0x46>
    for(ix = 0; ix < sizeof(pMiimObj->objClients) / sizeof(*pMiimObj->objClients); ix++, pClient++)
   198de:	f103 0420 	add.w	r4, r3, #32
        if(pClient->clientInUse == 0)
   198e2:	8c1a      	ldrh	r2, [r3, #32]
   198e4:	b302      	cbz	r2, 19928 <DRV_MIIM_Open+0x70>
    DRV_HANDLE drvHandle = DRV_HANDLE_INVALID;
   198e6:	f04f 34ff 	mov.w	r4, #4294967295
    OSAL_SEM_Post(&pMiimObj->objSem);
   198ea:	4618      	mov	r0, r3
   198ec:	f007 fde2 	bl	214b4 <OSAL_SEM_Post>
   198f0:	e7e6      	b.n	198c0 <DRV_MIIM_Open+0x8>
    DRV_HANDLE drvHandle = DRV_HANDLE_INVALID;
   198f2:	f04f 34ff 	mov.w	r4, #4294967295
    return drvHandle;
   198f6:	e7e3      	b.n	198c0 <DRV_MIIM_Open+0x8>
    DRV_HANDLE drvHandle = DRV_HANDLE_INVALID;
   198f8:	f04f 34ff 	mov.w	r4, #4294967295
   198fc:	e7f5      	b.n	198ea <DRV_MIIM_Open+0x32>
    DRV_MIIM_CLIENT_DCPT* pClient = pMiimObj->objClients;
   198fe:	f103 0410 	add.w	r4, r3, #16
    for(ix = 0; ix < sizeof(pMiimObj->objClients) / sizeof(*pMiimObj->objClients); ix++, pClient++)
   19902:	2000      	movs	r0, #0
            memset(pClient, 0, sizeof(*pClient));
   19904:	2200      	movs	r2, #0
   19906:	60a2      	str	r2, [r4, #8]
   19908:	60e2      	str	r2, [r4, #12]
            pClient->clientInUse = true;
   1990a:	2201      	movs	r2, #1
   1990c:	8022      	strh	r2, [r4, #0]
            pClient->clientIx = clientIx;
   1990e:	8060      	strh	r0, [r4, #2]
            pClient->parentObj  = pMiimObj;
   19910:	6063      	str	r3, [r4, #4]
            pClient->cliStatus = DRV_MIIM_CLIENT_STATUS_READY;
   19912:	2202      	movs	r2, #2
   19914:	7322      	strb	r2, [r4, #12]
            if((ioIntent & DRV_IO_INTENT_EXCLUSIVE) != 0)
   19916:	b119      	cbz	r1, 19920 <DRV_MIIM_Open+0x68>
                pMiimObj->objFlags |= DRV_MIIM_OBJ_FLAG_EXCLUSIVE;
   19918:	889a      	ldrh	r2, [r3, #4]
   1991a:	f042 0204 	orr.w	r2, r2, #4
   1991e:	809a      	strh	r2, [r3, #4]
            pMiimObj->numClients++;
   19920:	88da      	ldrh	r2, [r3, #6]
   19922:	3201      	adds	r2, #1
   19924:	80da      	strh	r2, [r3, #6]
            drvHandle =  (DRV_HANDLE)pClient;
   19926:	e7e0      	b.n	198ea <DRV_MIIM_Open+0x32>
        if(pClient->clientInUse == 0)
   19928:	2001      	movs	r0, #1
   1992a:	e7eb      	b.n	19904 <DRV_MIIM_Open+0x4c>
   1992c:	2000ddf0 	.word	0x2000ddf0

Disassembly of section .text.DRV_MIIM_Initialize%434:

00019930 <DRV_MIIM_Initialize>:
{
   19930:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(iModule >= DRV_MIIM_INSTANCES_NUMBER)
   19932:	bb70      	cbnz	r0, 19992 <DRV_MIIM_Initialize+0x62>
    pMiimObj = _DRV_MIIM_GetObject((SYS_MODULE_OBJ)(gDrvMIIMObj + iModule));
   19934:	4e1b      	ldr	r6, [pc, #108]	; (199a4 <DRV_MIIM_Initialize+0x74>)
        if(pMiimObj->objStatus == SYS_STATUS_READY && (pMiimObj->objFlags & DRV_MIIM_OBJ_FLAG_IN_USE) != 0)
   19936:	f996 3008 	ldrsb.w	r3, [r6, #8]
   1993a:	2b02      	cmp	r3, #2
   1993c:	d103      	bne.n	19946 <DRV_MIIM_Initialize+0x16>
   1993e:	88b3      	ldrh	r3, [r6, #4]
   19940:	f013 0f01 	tst.w	r3, #1
   19944:	d123      	bne.n	1998e <DRV_MIIM_Initialize+0x5e>
   19946:	460d      	mov	r5, r1
    memset(pMiimObj, 0, sizeof(*pMiimObj));
   19948:	2294      	movs	r2, #148	; 0x94
   1994a:	2100      	movs	r1, #0
   1994c:	4815      	ldr	r0, [pc, #84]	; (199a4 <DRV_MIIM_Initialize+0x74>)
   1994e:	f008 f915 	bl	21b7c <memset>
    if((miimInit = (DRV_MIIM_INIT*) init) == 0)
   19952:	b30d      	cbz	r5, 19998 <DRV_MIIM_Initialize+0x68>
    if(OSAL_SEM_Create(&pMiimObj->objSem, OSAL_SEM_TYPE_BINARY, 1, 1) != OSAL_RESULT_TRUE)
   19954:	2301      	movs	r3, #1
   19956:	461a      	mov	r2, r3
   19958:	2100      	movs	r1, #0
   1995a:	4812      	ldr	r0, [pc, #72]	; (199a4 <DRV_MIIM_Initialize+0x74>)
   1995c:	f002 f8f2 	bl	1bb44 <OSAL_SEM_Create>
   19960:	2801      	cmp	r0, #1
   19962:	d11c      	bne.n	1999e <DRV_MIIM_Initialize+0x6e>
    pMiimObj->objFlags = DRV_MIIM_OBJ_FLAG_IN_USE;      // Set object to be in use
   19964:	4c0f      	ldr	r4, [pc, #60]	; (199a4 <DRV_MIIM_Initialize+0x74>)
   19966:	2301      	movs	r3, #1
   19968:	80a3      	strh	r3, [r4, #4]
    pMiimObj->objStatus = SYS_STATUS_READY; // Set module state
   1996a:	2302      	movs	r3, #2
   1996c:	7223      	strb	r3, [r4, #8]
    pMiimObj->iModule  = iModule;  // Store driver instance
   1996e:	2300      	movs	r3, #0
   19970:	8163      	strh	r3, [r4, #10]
    pMiimObj->ethphyId = miimInit->ethphyId; // Store PLIB ID
   19972:	686b      	ldr	r3, [r5, #4]
   19974:	60e3      	str	r3, [r4, #12]
    DRV_MIIM_OP_DCPT* pOpDcpt = pMiimObj->opPool;
   19976:	3430      	adds	r4, #48	; 0x30
        pOpDcpt->qType = DRV_MIIM_QTYPE_FREE;
   19978:	2701      	movs	r7, #1
        Helper_SingleListTailAdd(&pMiimObj->freeOpList, (SGL_LIST_NODE*)pOpDcpt);
   1997a:	f104 0540 	add.w	r5, r4, #64	; 0x40
        pOpDcpt->qType = DRV_MIIM_QTYPE_FREE;
   1997e:	72e7      	strb	r7, [r4, #11]
        Helper_SingleListTailAdd(&pMiimObj->freeOpList, (SGL_LIST_NODE*)pOpDcpt);
   19980:	4621      	mov	r1, r4
   19982:	4628      	mov	r0, r5
   19984:	f007 fbb1 	bl	210ea <Helper_SingleListTailAdd>
    for(ix = 0; ix < sizeof(pMiimObj->opPool) / sizeof(*pMiimObj->opPool); ix++, pOpDcpt++)
   19988:	3410      	adds	r4, #16
   1998a:	42ac      	cmp	r4, r5
   1998c:	d1f7      	bne.n	1997e <DRV_MIIM_Initialize+0x4e>
}
   1998e:	4630      	mov	r0, r6
   19990:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return SYS_MODULE_OBJ_INVALID;
   19992:	f04f 36ff 	mov.w	r6, #4294967295
   19996:	e7fa      	b.n	1998e <DRV_MIIM_Initialize+0x5e>
        return SYS_MODULE_OBJ_INVALID;
   19998:	f04f 36ff 	mov.w	r6, #4294967295
   1999c:	e7f7      	b.n	1998e <DRV_MIIM_Initialize+0x5e>
        return SYS_MODULE_OBJ_INVALID;
   1999e:	f04f 36ff 	mov.w	r6, #4294967295
   199a2:	e7f4      	b.n	1998e <DRV_MIIM_Initialize+0x5e>
   199a4:	2000ddf0 	.word	0x2000ddf0

Disassembly of section .rodata%435:

000199a8 <.rodata%435>:
   199a8:	34765049 	.word	0x34765049
   199ac:	696e4920 	.word	0x696e4920
   199b0:	46203a74 	.word	0x46203a74
   199b4:	656c6961 	.word	0x656c6961
   199b8:	6f742064 	.word	0x6f742064
   199bc:	696e6920 	.word	0x696e6920
   199c0:	696c6174 	.word	0x696c6174
   199c4:	203a657a 	.word	0x203a657a
   199c8:	20216425 	.word	0x20216425
   199cc:	00000a0d 	.word	0x00000a0d
   199d0:	34765049 	.word	0x34765049
   199d4:	6146203a 	.word	0x6146203a
   199d8:	64656c69 	.word	0x64656c69
   199dc:	206f7420 	.word	0x206f7420
   199e0:	69676572 	.word	0x69676572
   199e4:	72657473 	.word	0x72657473
   199e8:	50524120 	.word	0x50524120
   199ec:	746f6e20 	.word	0x746f6e20
   199f0:	63696669 	.word	0x63696669
   199f4:	6f697461 	.word	0x6f697461
   199f8:	0d20216e 	.word	0x0d20216e
   199fc:	0000000a 	.word	0x0000000a
   19a00:	34765049 	.word	0x34765049
   19a04:	5241203a 	.word	0x5241203a
   19a08:	6e652050 	.word	0x6e652050
   19a0c:	65697274 	.word	0x65697274
   19a10:	6f702073 	.word	0x6f702073
   19a14:	65206c6f 	.word	0x65206c6f
   19a18:	7974706d 	.word	0x7974706d
   19a1c:	000a0d21 	.word	0x000a0d21

Disassembly of section .text.TCPIP_Helper_PacketCopy%436:

00019a20 <TCPIP_Helper_PacketCopy>:

// copies packet segment data to a linear destination buffer
// updates the pointer to the current location in the packet segment for further copy
// returns the number of total bytes copied
uint16_t TCPIP_Helper_PacketCopy(TCPIP_MAC_PACKET* pSrcPkt, uint8_t* pDest, uint8_t** pStartAdd, uint16_t len, bool srchTransport)
{
   19a20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   19a24:	4688      	mov	r8, r1
   19a26:	4692      	mov	sl, r2
   19a28:	461e      	mov	r6, r3
    uint16_t copyLen, copyBytes;
    uint8_t  *pCopyBuff, *pSrcBuff;
    uint16_t totCopyBytes = 0;

    copyLen = len;
    pCopyBuff = pSrcBuff = *pStartAdd; 
   19a2a:	6817      	ldr	r7, [r2, #0]
    pSeg = TCPIP_PKT_DataSegmentGet(pSrcPkt, pSrcBuff, srchTransport);
   19a2c:	f89d 2020 	ldrb.w	r2, [sp, #32]
   19a30:	4639      	mov	r1, r7
   19a32:	f000 fb29 	bl	1a088 <TCPIP_PKT_DataSegmentGet>

    while(pSeg != 0 && copyLen != 0)
   19a36:	b320      	cbz	r0, 19a82 <TCPIP_Helper_PacketCopy+0x62>
   19a38:	4605      	mov	r5, r0
   19a3a:	b356      	cbz	r6, 19a92 <TCPIP_Helper_PacketCopy+0x72>
    pCopyBuff = pSrcBuff = *pStartAdd; 
   19a3c:	463a      	mov	r2, r7
    uint16_t totCopyBytes = 0;
   19a3e:	f04f 0900 	mov.w	r9, #0
   19a42:	e00f      	b.n	19a64 <TCPIP_Helper_PacketCopy+0x44>
            copyBytes = copyLen;
        } 

        if(copyBytes)
        {
            memcpy(pDest, pCopyBuff, copyBytes);
   19a44:	4622      	mov	r2, r4
   19a46:	4639      	mov	r1, r7
   19a48:	4640      	mov	r0, r8
   19a4a:	f007 fb09 	bl	21060 <memcpy>
            pDest += copyBytes;
   19a4e:	44a0      	add	r8, r4
            copyLen -= copyBytes;
   19a50:	1b36      	subs	r6, r6, r4
   19a52:	b2b6      	uxth	r6, r6
            pSrcBuff = pCopyBuff + copyBytes;
   19a54:	193a      	adds	r2, r7, r4
            totCopyBytes += copyBytes;
   19a56:	44a1      	add	r9, r4
   19a58:	fa1f f989 	uxth.w	r9, r9
        }

        pSeg = pSeg->next;
   19a5c:	682d      	ldr	r5, [r5, #0]
        if(pSeg)
   19a5e:	b19d      	cbz	r5, 19a88 <TCPIP_Helper_PacketCopy+0x68>
        {
            pCopyBuff = pSeg->segLoad;
   19a60:	68af      	ldr	r7, [r5, #8]
    while(pSeg != 0 && copyLen != 0)
   19a62:	b18e      	cbz	r6, 19a88 <TCPIP_Helper_PacketCopy+0x68>
        copyBytes = (pSeg->segLoad + pSeg->segSize) - pCopyBuff;
   19a64:	89ec      	ldrh	r4, [r5, #14]
   19a66:	68ab      	ldr	r3, [r5, #8]
   19a68:	4423      	add	r3, r4
   19a6a:	1bdb      	subs	r3, r3, r7
   19a6c:	b29b      	uxth	r3, r3
        if(copyBytes > copyLen)
   19a6e:	89ac      	ldrh	r4, [r5, #12]
   19a70:	42b4      	cmp	r4, r6
   19a72:	bf28      	it	cs
   19a74:	4634      	movcs	r4, r6
   19a76:	429c      	cmp	r4, r3
   19a78:	bf28      	it	cs
   19a7a:	461c      	movcs	r4, r3
        if(copyBytes)
   19a7c:	2c00      	cmp	r4, #0
   19a7e:	d0ed      	beq.n	19a5c <TCPIP_Helper_PacketCopy+0x3c>
   19a80:	e7e0      	b.n	19a44 <TCPIP_Helper_PacketCopy+0x24>
    pCopyBuff = pSrcBuff = *pStartAdd; 
   19a82:	463a      	mov	r2, r7
    uint16_t totCopyBytes = 0;
   19a84:	f04f 0900 	mov.w	r9, #0
        }
    }
    
    *pStartAdd = pSrcBuff;
   19a88:	f8ca 2000 	str.w	r2, [sl]

    return totCopyBytes;
}
   19a8c:	4648      	mov	r0, r9
   19a8e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    uint16_t totCopyBytes = 0;
   19a92:	46b1      	mov	r9, r6
    pCopyBuff = pSrcBuff = *pStartAdd; 
   19a94:	463a      	mov	r2, r7
   19a96:	e7f7      	b.n	19a88 <TCPIP_Helper_PacketCopy+0x68>

Disassembly of section .text.SERCOM1_USART_Read%437:

00019a98 <SERCOM1_USART_Read>:
{
   19a98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    rdOutIndex = sercom1USARTObj.rdOutIndex;
   19a9c:	4c19      	ldr	r4, [pc, #100]	; (19b04 <SERCOM1_USART_Read+0x6c>)
   19a9e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    rdInIndex = sercom1USARTObj.rdInIndex;
   19aa0:	6aa4      	ldr	r4, [r4, #40]	; 0x28
    while (nBytesRead < size)
   19aa2:	b349      	cbz	r1, 19af8 <SERCOM1_USART_Read+0x60>
   19aa4:	460d      	mov	r5, r1
        if (rdOutIndex != rdInIndex)
   19aa6:	42a3      	cmp	r3, r4
   19aa8:	d029      	beq.n	19afe <SERCOM1_USART_Read+0x66>
            if (rdOutIndex >= sercom1USARTObj.rdBufferSize)
   19aaa:	4a16      	ldr	r2, [pc, #88]	; (19b04 <SERCOM1_USART_Read+0x6c>)
   19aac:	6b17      	ldr	r7, [r2, #48]	; 0x30
   19aae:	4602      	mov	r2, r0
            if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   19ab0:	4e15      	ldr	r6, [pc, #84]	; (19b08 <SERCOM1_USART_Read+0x70>)
   19ab2:	f1c0 0e01 	rsb	lr, r0, #1
                ((uint16_t*)pRdBuffer)[nBytesRead++] = ((uint16_t*)&SERCOM1_USART_ReadBuffer)[rdOutIndex++];
   19ab6:	f8df c054 	ldr.w	ip, [pc, #84]	; 19b0c <SERCOM1_USART_Read+0x74>
   19aba:	f1c0 0800 	rsb	r8, r0, #0
            if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   19abe:	6871      	ldr	r1, [r6, #4]
   19ac0:	f001 0107 	and.w	r1, r1, #7
   19ac4:	2901      	cmp	r1, #1
                pRdBuffer[nBytesRead++] = SERCOM1_USART_ReadBuffer[rdOutIndex++];
   19ac6:	eb0e 0002 	add.w	r0, lr, r2
   19aca:	bf19      	ittee	ne
   19acc:	f81c 1003 	ldrbne.w	r1, [ip, r3]
   19ad0:	7011      	strbne	r1, [r2, #0]
                ((uint16_t*)pRdBuffer)[nBytesRead++] = ((uint16_t*)&SERCOM1_USART_ReadBuffer)[rdOutIndex++];
   19ad2:	f83c 1013 	ldrheq.w	r1, [ip, r3, lsl #1]
   19ad6:	f828 1012 	strheq.w	r1, [r8, r2, lsl #1]
   19ada:	3301      	adds	r3, #1
                rdOutIndex = 0U;
   19adc:	429f      	cmp	r7, r3
   19ade:	bf98      	it	ls
   19ae0:	2300      	movls	r3, #0
    while (nBytesRead < size)
   19ae2:	42a8      	cmp	r0, r5
   19ae4:	d203      	bcs.n	19aee <SERCOM1_USART_Read+0x56>
        if (rdOutIndex != rdInIndex)
   19ae6:	3201      	adds	r2, #1
   19ae8:	42a3      	cmp	r3, r4
   19aea:	d1e8      	bne.n	19abe <SERCOM1_USART_Read+0x26>
   19aec:	e000      	b.n	19af0 <SERCOM1_USART_Read+0x58>
   19aee:	461c      	mov	r4, r3
    sercom1USARTObj.rdOutIndex = rdOutIndex;
   19af0:	4b04      	ldr	r3, [pc, #16]	; (19b04 <SERCOM1_USART_Read+0x6c>)
   19af2:	62dc      	str	r4, [r3, #44]	; 0x2c
}
   19af4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    rdOutIndex = sercom1USARTObj.rdOutIndex;
   19af8:	461c      	mov	r4, r3
    size_t nBytesRead = 0U;
   19afa:	4608      	mov	r0, r1
   19afc:	e7f8      	b.n	19af0 <SERCOM1_USART_Read+0x58>
   19afe:	2000      	movs	r0, #0
   19b00:	e7f6      	b.n	19af0 <SERCOM1_USART_Read+0x58>
   19b02:	bf00      	nop
   19b04:	2000e1f0 	.word	0x2000e1f0
   19b08:	40003400 	.word	0x40003400
   19b0c:	2000a004 	.word	0x2000a004

Disassembly of section .text.SERCOM1_USART_Virtual_Send%438:

00019b10 <SERCOM1_USART_Virtual_Send>:
void SERCOM1_USART_Virtual_Send(char *str) {
   19b10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    while (*str!=0) {
   19b14:	7805      	ldrb	r5, [r0, #0]
   19b16:	2d00      	cmp	r5, #0
   19b18:	d02e      	beq.n	19b78 <SERCOM1_USART_Virtual_Send+0x68>
   19b1a:	4606      	mov	r6, r0
    tempInIndex = sercom1USARTObj.rdInIndex + 1U;
   19b1c:	4c17      	ldr	r4, [pc, #92]	; (19b7c <SERCOM1_USART_Virtual_Send+0x6c>)
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   19b1e:	4f18      	ldr	r7, [pc, #96]	; (19b80 <SERCOM1_USART_Virtual_Send+0x70>)
            ((uint16_t*)&SERCOM1_USART_ReadBuffer)[sercom1USARTObj.rdInIndex] = rdByte;
   19b20:	f8df 8060 	ldr.w	r8, [pc, #96]	; 19b84 <SERCOM1_USART_Virtual_Send+0x74>
   19b24:	e01b      	b.n	19b5e <SERCOM1_USART_Virtual_Send+0x4e>
        if(sercom1USARTObj.rdCallback != NULL)
   19b26:	6a22      	ldr	r2, [r4, #32]
   19b28:	b312      	cbz	r2, 19b70 <SERCOM1_USART_Virtual_Send+0x60>
            sercom1USARTObj.rdCallback(SERCOM_USART_EVENT_READ_BUFFER_FULL, sercom1USARTObj.rdContext);
   19b2a:	6a61      	ldr	r1, [r4, #36]	; 0x24
   19b2c:	2001      	movs	r0, #1
   19b2e:	4790      	blx	r2
            tempInIndex = sercom1USARTObj.rdInIndex + 1U;
   19b30:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   19b32:	3301      	adds	r3, #1
            if (tempInIndex >= sercom1USARTObj.rdBufferSize)
   19b34:	6b22      	ldr	r2, [r4, #48]	; 0x30
                tempInIndex = 0U;
   19b36:	4293      	cmp	r3, r2
   19b38:	bf28      	it	cs
   19b3a:	2300      	movcs	r3, #0
   19b3c:	e018      	b.n	19b70 <SERCOM1_USART_Virtual_Send+0x60>
        if (((SERCOM1_REGS->USART_INT.SERCOM_CTRLB & SERCOM_USART_INT_CTRLB_CHSIZE_Msk) >> SERCOM_USART_INT_CTRLB_CHSIZE_Pos) != 0x01U)
   19b3e:	687a      	ldr	r2, [r7, #4]
   19b40:	f002 0207 	and.w	r2, r2, #7
   19b44:	2a01      	cmp	r2, #1
            SERCOM1_USART_ReadBuffer[sercom1USARTObj.rdInIndex] = (uint8_t)rdByte;
   19b46:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   19b48:	bf14      	ite	ne
   19b4a:	f808 5002 	strbne.w	r5, [r8, r2]
        if (SERCOM1_USART_RxPushByte(*str) == true) {
   19b4e:	f828 5012 	strheq.w	r5, [r8, r2, lsl #1]
        sercom1USARTObj.rdInIndex = tempInIndex;
   19b52:	62a3      	str	r3, [r4, #40]	; 0x28
            SERCOM1_USART_ReadNotificationSend();
   19b54:	f003 f8c0 	bl	1ccd8 <SERCOM1_USART_ReadNotificationSend>
    while (*str!=0) {
   19b58:	f816 5f01 	ldrb.w	r5, [r6, #1]!
   19b5c:	b165      	cbz	r5, 19b78 <SERCOM1_USART_Virtual_Send+0x68>
    tempInIndex = sercom1USARTObj.rdInIndex + 1U;
   19b5e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   19b60:	3301      	adds	r3, #1
    if (tempInIndex >= sercom1USARTObj.rdBufferSize)
   19b62:	6b22      	ldr	r2, [r4, #48]	; 0x30
        tempInIndex = 0U;
   19b64:	4293      	cmp	r3, r2
   19b66:	bf28      	it	cs
   19b68:	2300      	movcs	r3, #0
    if (tempInIndex == sercom1USARTObj.rdOutIndex)
   19b6a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   19b6c:	429a      	cmp	r2, r3
   19b6e:	d0da      	beq.n	19b26 <SERCOM1_USART_Virtual_Send+0x16>
    if (tempInIndex != sercom1USARTObj.rdOutIndex)
   19b70:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   19b72:	429a      	cmp	r2, r3
   19b74:	d1e3      	bne.n	19b3e <SERCOM1_USART_Virtual_Send+0x2e>
   19b76:	e7ef      	b.n	19b58 <SERCOM1_USART_Virtual_Send+0x48>
}
   19b78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   19b7c:	2000e1f0 	.word	0x2000e1f0
   19b80:	40003400 	.word	0x40003400
   19b84:	2000a004 	.word	0x2000a004

Disassembly of section .text.__sfp%439:

00019b88 <__sfp>:
   19b88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   19b8a:	4b1b      	ldr	r3, [pc, #108]	; (19bf8 <__sfp+0x70>)
   19b8c:	681e      	ldr	r6, [r3, #0]
   19b8e:	69b3      	ldr	r3, [r6, #24]
   19b90:	4607      	mov	r7, r0
   19b92:	b913      	cbnz	r3, 19b9a <__sfp+0x12>
   19b94:	4630      	mov	r0, r6
   19b96:	f001 fc73 	bl	1b480 <__sinit>
   19b9a:	3648      	adds	r6, #72	; 0x48
   19b9c:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
   19ba0:	3b01      	subs	r3, #1
   19ba2:	d503      	bpl.n	19bac <__sfp+0x24>
   19ba4:	6833      	ldr	r3, [r6, #0]
   19ba6:	b1db      	cbz	r3, 19be0 <__sfp+0x58>
   19ba8:	6836      	ldr	r6, [r6, #0]
   19baa:	e7f7      	b.n	19b9c <__sfp+0x14>
   19bac:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
   19bb0:	b9a5      	cbnz	r5, 19bdc <__sfp+0x54>
   19bb2:	4b12      	ldr	r3, [pc, #72]	; (19bfc <__sfp+0x74>)
   19bb4:	6625      	str	r5, [r4, #96]	; 0x60
   19bb6:	e9c4 5500 	strd	r5, r5, [r4]
   19bba:	60a5      	str	r5, [r4, #8]
   19bbc:	e9c4 3503 	strd	r3, r5, [r4, #12]
   19bc0:	e9c4 5505 	strd	r5, r5, [r4, #20]
   19bc4:	2208      	movs	r2, #8
   19bc6:	4629      	mov	r1, r5
   19bc8:	f104 0058 	add.w	r0, r4, #88	; 0x58
   19bcc:	f007 ffd6 	bl	21b7c <memset>
   19bd0:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
   19bd4:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
   19bd8:	4620      	mov	r0, r4
   19bda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   19bdc:	3464      	adds	r4, #100	; 0x64
   19bde:	e7df      	b.n	19ba0 <__sfp+0x18>
   19be0:	2104      	movs	r1, #4
   19be2:	4638      	mov	r0, r7
   19be4:	f005 fef0 	bl	1f9c8 <__sfmoreglue>
   19be8:	4604      	mov	r4, r0
   19bea:	6030      	str	r0, [r6, #0]
   19bec:	2800      	cmp	r0, #0
   19bee:	d1db      	bne.n	19ba8 <__sfp+0x20>
   19bf0:	230c      	movs	r3, #12
   19bf2:	603b      	str	r3, [r7, #0]
   19bf4:	e7f0      	b.n	19bd8 <__sfp+0x50>
   19bf6:	bf00      	nop
   19bf8:	0002215c 	.word	0x0002215c
   19bfc:	ffff0001 	.word	0xffff0001

Disassembly of section .text._DRV_GMAC_LinkStateNegResult%440:

00019c00 <_DRV_GMAC_LinkStateNegResult>:
{
   19c00:	b530      	push	{r4, r5, lr}
   19c02:	b083      	sub	sp, #12
   19c04:	4604      	mov	r4, r0
	DRV_ETHPHY_CONFIG_FLAGS phyCfgFlags = 0;
   19c06:	2300      	movs	r3, #0
   19c08:	f88d 3007 	strb.w	r3, [sp, #7]
	pPhyBase =  pMACDrv->sGmacData.gmacConfig.pPhyBase;
   19c0c:	f8d0 50d8 	ldr.w	r5, [r0, #216]	; 0xd8
	phyStat = pPhyBase->DRV_ETHPHY_ClientStatus( pMACDrv->sGmacData.hPhyClient );
   19c10:	69eb      	ldr	r3, [r5, #28]
   19c12:	6900      	ldr	r0, [r0, #16]
   19c14:	4798      	blx	r3
	if(phyStat == DRV_ETHPHY_CLIENT_STATUS_BUSY)
   19c16:	2801      	cmp	r0, #1
   19c18:	d023      	beq.n	19c62 <_DRV_GMAC_LinkStateNegResult+0x62>
	phyRes = pPhyBase->DRV_ETHPHY_ClientOperationResult(pMACDrv->sGmacData.hPhyClient);
   19c1a:	6a2b      	ldr	r3, [r5, #32]
   19c1c:	6920      	ldr	r0, [r4, #16]
   19c1e:	4798      	blx	r3
	if(phyRes != DRV_ETHPHY_RES_OK)
   19c20:	bb08      	cbnz	r0, 19c66 <_DRV_GMAC_LinkStateNegResult+0x66>
	if( (pMACDrv->sGmacData._negResult.linkStatus & DRV_ETHPHY_LINK_ST_UP) != 0 )
   19c22:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
   19c26:	f013 0f01 	tst.w	r3, #1
   19c2a:	d020      	beq.n	19c6e <_DRV_GMAC_LinkStateNegResult+0x6e>
		pPhyBase->DRV_ETHPHY_HWConfigFlagsGet(pMACDrv->sGmacData.hPhyClient, &phyCfgFlags);
   19c2c:	6b6b      	ldr	r3, [r5, #52]	; 0x34
   19c2e:	f10d 0107 	add.w	r1, sp, #7
   19c32:	6920      	ldr	r0, [r4, #16]
   19c34:	4798      	blx	r3
		pMACDrv->sGmacData._negResult.linkFlags |= (phyCfgFlags & DRV_ETHPHY_CFG_RMII) ? TCPIP_ETH_OPEN_RMII : TCPIP_ETH_OPEN_MII ;
   19c36:	f89d 1007 	ldrb.w	r1, [sp, #7]
   19c3a:	0289      	lsls	r1, r1, #10
   19c3c:	f401 6180 	and.w	r1, r1, #1024	; 0x400
   19c40:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
   19c44:	4319      	orrs	r1, r3
   19c46:	f8a4 1042 	strh.w	r1, [r4, #66]	; 0x42
		DRV_PIC32CGMAC_LibMACOpen(pMACDrv, pMACDrv->sGmacData._negResult.linkFlags, pauseType);
   19c4a:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
   19c4e:	4620      	mov	r0, r4
   19c50:	f000 fbdc 	bl	1a40c <DRV_PIC32CGMAC_LibMACOpen>
		pMACDrv->sGmacData._macFlags._linkPrev = 1;
   19c54:	7da3      	ldrb	r3, [r4, #22]
   19c56:	f043 0310 	orr.w	r3, r3, #16
   19c5a:	75a3      	strb	r3, [r4, #22]
		pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_START_LINK;
   19c5c:	2300      	movs	r3, #0
   19c5e:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
}
   19c62:	b003      	add	sp, #12
   19c64:	bd30      	pop	{r4, r5, pc}
		_DRV_GMAC_LinkStateDown(pMACDrv);
   19c66:	4620      	mov	r0, r4
   19c68:	f006 ffb2 	bl	20bd0 <_DRV_GMAC_LinkStateDown>
		return;
   19c6c:	e7f9      	b.n	19c62 <_DRV_GMAC_LinkStateNegResult+0x62>
		_DRV_GMAC_LinkStateDown(pMACDrv);
   19c6e:	4620      	mov	r0, r4
   19c70:	f006 ffae 	bl	20bd0 <_DRV_GMAC_LinkStateDown>
   19c74:	e7f5      	b.n	19c62 <_DRV_GMAC_LinkStateNegResult+0x62>

Disassembly of section .text.prvCopyDataToQueue%441:

00019c76 <prvCopyDataToQueue>:
{
   19c76:	b570      	push	{r4, r5, r6, lr}
   19c78:	4604      	mov	r4, r0
   19c7a:	4616      	mov	r6, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   19c7c:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   19c7e:	6c02      	ldr	r2, [r0, #64]	; 0x40
   19c80:	b95a      	cbnz	r2, 19c9a <prvCopyDataToQueue+0x24>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   19c82:	6803      	ldr	r3, [r0, #0]
   19c84:	b11b      	cbz	r3, 19c8e <prvCopyDataToQueue+0x18>
BaseType_t xReturn = pdFALSE;
   19c86:	2000      	movs	r0, #0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   19c88:	3501      	adds	r5, #1
   19c8a:	63a5      	str	r5, [r4, #56]	; 0x38
}
   19c8c:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
   19c8e:	6880      	ldr	r0, [r0, #8]
   19c90:	f7ff fa68 	bl	19164 <xTaskPriorityDisinherit>
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
   19c94:	2300      	movs	r3, #0
   19c96:	60a3      	str	r3, [r4, #8]
   19c98:	e7f6      	b.n	19c88 <prvCopyDataToQueue+0x12>
	else if( xPosition == queueSEND_TO_BACK )
   19c9a:	b96e      	cbnz	r6, 19cb8 <prvCopyDataToQueue+0x42>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
   19c9c:	6840      	ldr	r0, [r0, #4]
   19c9e:	f007 f9df 	bl	21060 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
   19ca2:	6863      	ldr	r3, [r4, #4]
   19ca4:	6c22      	ldr	r2, [r4, #64]	; 0x40
   19ca6:	4413      	add	r3, r2
   19ca8:	6063      	str	r3, [r4, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   19caa:	68a2      	ldr	r2, [r4, #8]
   19cac:	4293      	cmp	r3, r2
   19cae:	d319      	bcc.n	19ce4 <prvCopyDataToQueue+0x6e>
			pxQueue->pcWriteTo = pxQueue->pcHead;
   19cb0:	6823      	ldr	r3, [r4, #0]
   19cb2:	6063      	str	r3, [r4, #4]
BaseType_t xReturn = pdFALSE;
   19cb4:	4630      	mov	r0, r6
   19cb6:	e7e7      	b.n	19c88 <prvCopyDataToQueue+0x12>
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
   19cb8:	68c0      	ldr	r0, [r0, #12]
   19cba:	f007 f9d1 	bl	21060 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
   19cbe:	6c22      	ldr	r2, [r4, #64]	; 0x40
   19cc0:	4252      	negs	r2, r2
   19cc2:	68e3      	ldr	r3, [r4, #12]
   19cc4:	4413      	add	r3, r2
   19cc6:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   19cc8:	6821      	ldr	r1, [r4, #0]
   19cca:	428b      	cmp	r3, r1
   19ccc:	d202      	bcs.n	19cd4 <prvCopyDataToQueue+0x5e>
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
   19cce:	68a3      	ldr	r3, [r4, #8]
   19cd0:	441a      	add	r2, r3
   19cd2:	60e2      	str	r2, [r4, #12]
		if( xPosition == queueOVERWRITE )
   19cd4:	2e02      	cmp	r6, #2
   19cd6:	d001      	beq.n	19cdc <prvCopyDataToQueue+0x66>
BaseType_t xReturn = pdFALSE;
   19cd8:	2000      	movs	r0, #0
   19cda:	e7d5      	b.n	19c88 <prvCopyDataToQueue+0x12>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   19cdc:	b125      	cbz	r5, 19ce8 <prvCopyDataToQueue+0x72>
				--uxMessagesWaiting;
   19cde:	3d01      	subs	r5, #1
BaseType_t xReturn = pdFALSE;
   19ce0:	2000      	movs	r0, #0
   19ce2:	e7d1      	b.n	19c88 <prvCopyDataToQueue+0x12>
   19ce4:	4630      	mov	r0, r6
   19ce6:	e7cf      	b.n	19c88 <prvCopyDataToQueue+0x12>
   19ce8:	2000      	movs	r0, #0
   19cea:	e7cd      	b.n	19c88 <prvCopyDataToQueue+0x12>

Disassembly of section .text.DRV_GMAC_Process%442:

00019cec <DRV_GMAC_Process>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   19cec:	4b19      	ldr	r3, [pc, #100]	; (19d54 <DRV_GMAC_Process+0x68>)
   19cee:	4283      	cmp	r3, r0
   19cf0:	d120      	bne.n	19d34 <DRV_GMAC_Process+0x48>
    if(pMACDrv == 0)
   19cf2:	b310      	cbz	r0, 19d3a <DRV_GMAC_Process+0x4e>
{
   19cf4:	b510      	push	{r4, lr}
	if(pMACDrv->sGmacData._synchF != 0)
   19cf6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   19cf8:	b323      	cbz	r3, 19d44 <DRV_GMAC_Process+0x58>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_LOCK);
   19cfa:	4c16      	ldr	r4, [pc, #88]	; (19d54 <DRV_GMAC_Process+0x68>)
   19cfc:	2103      	movs	r1, #3
   19cfe:	f104 0060 	add.w	r0, r4, #96	; 0x60
   19d02:	4798      	blx	r3
        if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].queueTxEnable)
   19d04:	f894 30ce 	ldrb.w	r3, [r4, #206]	; 0xce
   19d08:	b93b      	cbnz	r3, 19d1a <DRV_GMAC_Process+0x2e>
	if(pMACDrv->sGmacData._synchF != 0)
   19d0a:	4b12      	ldr	r3, [pc, #72]	; (19d54 <DRV_GMAC_Process+0x68>)
   19d0c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   19d0e:	b1bb      	cbz	r3, 19d40 <DRV_GMAC_Process+0x54>
		(*pMACDrv->sGmacData._synchF)(&pMACDrv->sGmacData._syncTxH, TCPIP_MAC_SYNCH_REQUEST_OBJ_UNLOCK);
   19d10:	2104      	movs	r1, #4
   19d12:	4811      	ldr	r0, [pc, #68]	; (19d58 <DRV_GMAC_Process+0x6c>)
   19d14:	4798      	blx	r3
	return TCPIP_MAC_RES_OK;
   19d16:	2000      	movs	r0, #0
}
   19d18:	bd10      	pop	{r4, pc}
    GMAC_REGS->GMAC_TSR = GMAC_TSR_TXCOMP_Msk;
   19d1a:	4b10      	ldr	r3, [pc, #64]	; (19d5c <DRV_GMAC_Process+0x70>)
   19d1c:	2220      	movs	r2, #32
   19d1e:	615a      	str	r2, [r3, #20]
    DRV_PIC32CGMAC_LibTxAckPacket(pMACDrv,queueIdx);
   19d20:	4c0c      	ldr	r4, [pc, #48]	; (19d54 <DRV_GMAC_Process+0x68>)
   19d22:	2100      	movs	r1, #0
   19d24:	4620      	mov	r0, r4
   19d26:	f7f7 f92b 	bl	10f80 <DRV_PIC32CGMAC_LibTxAckPacket>
            _MacTxPendingPackets(pMACDrv,queueIdx);            
   19d2a:	2100      	movs	r1, #0
   19d2c:	4620      	mov	r0, r4
   19d2e:	f000 f939 	bl	19fa4 <_MacTxPendingPackets>
   19d32:	e7ea      	b.n	19d0a <DRV_GMAC_Process+0x1e>
        return TCPIP_MAC_RES_OP_ERR;
   19d34:	f06f 0005 	mvn.w	r0, #5
   19d38:	4770      	bx	lr
   19d3a:	f06f 0005 	mvn.w	r0, #5
}
   19d3e:	4770      	bx	lr
	return TCPIP_MAC_RES_OK;
   19d40:	2000      	movs	r0, #0
   19d42:	e7e9      	b.n	19d18 <DRV_GMAC_Process+0x2c>
        if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].queueTxEnable)
   19d44:	4b03      	ldr	r3, [pc, #12]	; (19d54 <DRV_GMAC_Process+0x68>)
   19d46:	f893 30ce 	ldrb.w	r3, [r3, #206]	; 0xce
   19d4a:	2b00      	cmp	r3, #0
   19d4c:	d1e5      	bne.n	19d1a <DRV_GMAC_Process+0x2e>
	return TCPIP_MAC_RES_OK;
   19d4e:	2000      	movs	r0, #0
   19d50:	e7e2      	b.n	19d18 <DRV_GMAC_Process+0x2c>
   19d52:	bf00      	nop
   19d54:	2000dab8 	.word	0x2000dab8
   19d58:	2000db18 	.word	0x2000db18
   19d5c:	42000800 	.word	0x42000800

Disassembly of section .text._ARPUpdateEntry%443:

00019d60 <_ARPUpdateEntry>:
{
   19d60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   19d64:	4606      	mov	r6, r0
   19d66:	460c      	mov	r4, r1
   19d68:	4617      	mov	r7, r2
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   19d6a:	4b19      	ldr	r3, [pc, #100]	; (19dd0 <_ARPUpdateEntry+0x70>)
   19d6c:	685d      	ldr	r5, [r3, #4]
   19d6e:	f007 ff51 	bl	21c14 <TCPIP_STACK_NetIxGet>
    if((arpHE->hEntry.flags.value & ARP_FLAG_ENTRY_PERM) == 0)
   19d72:	8823      	ldrh	r3, [r4, #0]
   19d74:	f013 0f40 	tst.w	r3, #64	; 0x40
   19d78:	d11d      	bne.n	19db6 <_ARPUpdateEntry+0x56>
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   19d7a:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   19d7e:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
        if((arpHE->hEntry.flags.value & ARP_FLAG_ENTRY_COMPLETE) == 0)
   19d82:	f013 0f80 	tst.w	r3, #128	; 0x80
   19d86:	d10e      	bne.n	19da6 <_ARPUpdateEntry+0x46>
            TCPIP_Helper_ProtectedSingleListNodeRemove(&pArpDcpt->incompleteList, (SGL_LIST_NODE*)&arpHE->next);
   19d88:	1d21      	adds	r1, r4, #4
   19d8a:	f105 002c 	add.w	r0, r5, #44	; 0x2c
   19d8e:	f005 f9a1 	bl	1f0d4 <TCPIP_Helper_ProtectedSingleListNodeRemove>
            evType = ARP_EVENT_SOLVED;
   19d92:	f04f 0801 	mov.w	r8, #1
        _ARPSetEntry(arpHE, ARP_FLAG_ENTRY_COMPLETE, hwAdd, &pArpDcpt->completeList);
   19d96:	f105 0318 	add.w	r3, r5, #24
   19d9a:	463a      	mov	r2, r7
   19d9c:	2180      	movs	r1, #128	; 0x80
   19d9e:	4620      	mov	r0, r4
   19da0:	f004 fd5a 	bl	1e858 <_ARPSetEntry>
   19da4:	e009      	b.n	19dba <_ARPUpdateEntry+0x5a>
            TCPIP_Helper_ProtectedSingleListNodeRemove(&pArpDcpt->completeList, (SGL_LIST_NODE*)&arpHE->next);
   19da6:	1d21      	adds	r1, r4, #4
   19da8:	f105 0018 	add.w	r0, r5, #24
   19dac:	f005 f992 	bl	1f0d4 <TCPIP_Helper_ProtectedSingleListNodeRemove>
            evType = ARP_EVENT_UPDATED;
   19db0:	f04f 0802 	mov.w	r8, #2
   19db4:	e7ef      	b.n	19d96 <_ARPUpdateEntry+0x36>
        evType = ARP_EVENT_PERM_UPDATE;
   19db6:	f04f 0803 	mov.w	r8, #3
    _ARPNotifyClients(pIf, &arpHE->ipAddress, &arpHE->hwAdd, evType);
   19dba:	4643      	mov	r3, r8
   19dbc:	f104 0210 	add.w	r2, r4, #16
   19dc0:	f104 0108 	add.w	r1, r4, #8
   19dc4:	4630      	mov	r0, r6
   19dc6:	f001 ff95 	bl	1bcf4 <_ARPNotifyClients>
}
   19dca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   19dce:	bf00      	nop
   19dd0:	2000e1a4 	.word	0x2000e1a4

Disassembly of section .text.TCPIP_ARP_EntryRemove%444:

00019dd4 <TCPIP_ARP_EntryRemove>:
    if(ipAdd == 0 || ipAdd->Val == 0)
   19dd4:	b349      	cbz	r1, 19e2a <TCPIP_ARP_EntryRemove+0x56>
{
   19dd6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   19dd8:	460d      	mov	r5, r1
    if(ipAdd == 0 || ipAdd->Val == 0)
   19dda:	680a      	ldr	r2, [r1, #0]
   19ddc:	b342      	cbz	r2, 19e30 <TCPIP_ARP_EntryRemove+0x5c>
   19dde:	b350      	cbz	r0, 19e36 <TCPIP_ARP_EntryRemove+0x62>
   19de0:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   19de4:	f012 0f40 	tst.w	r2, #64	; 0x40
   19de8:	d102      	bne.n	19df0 <TCPIP_ARP_EntryRemove+0x1c>
        return ARP_RES_NO_INTERFACE;
   19dea:	f06f 0005 	mvn.w	r0, #5
}
   19dee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   19df0:	4604      	mov	r4, r0
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   19df2:	4b14      	ldr	r3, [pc, #80]	; (19e44 <TCPIP_ARP_EntryRemove+0x70>)
   19df4:	685e      	ldr	r6, [r3, #4]
   19df6:	f007 ff0d 	bl	21c14 <TCPIP_STACK_NetIxGet>
   19dfa:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   19dfe:	00c0      	lsls	r0, r0, #3
   19e00:	1837      	adds	r7, r6, r0
    hE = TCPIP_OAHASH_EntryLookup(pArpDcpt->hashDcpt, &ipAdd->Val);
   19e02:	4629      	mov	r1, r5
   19e04:	5830      	ldr	r0, [r6, r0]
   19e06:	f000 fe25 	bl	1aa54 <TCPIP_OAHASH_EntryLookup>
    if(hE == 0)
   19e0a:	4605      	mov	r5, r0
   19e0c:	b1b0      	cbz	r0, 19e3c <TCPIP_ARP_EntryRemove+0x68>
    _ARPRemoveEntry(pArpDcpt, hE);
   19e0e:	4601      	mov	r1, r0
   19e10:	4638      	mov	r0, r7
   19e12:	f005 fc8f 	bl	1f734 <_ARPRemoveEntry>
    _ARPNotifyClients(pIf, &((ARP_HASH_ENTRY*)hE)->ipAddress, 0, ARP_EVENT_REMOVED_USER);
   19e16:	f06f 0301 	mvn.w	r3, #1
   19e1a:	2200      	movs	r2, #0
   19e1c:	f105 0108 	add.w	r1, r5, #8
   19e20:	4620      	mov	r0, r4
   19e22:	f001 ff67 	bl	1bcf4 <_ARPNotifyClients>
    return ARP_RES_OK;
   19e26:	2000      	movs	r0, #0
   19e28:	e7e1      	b.n	19dee <TCPIP_ARP_EntryRemove+0x1a>
        return ARP_RES_BAD_ADDRESS;
   19e2a:	f06f 0004 	mvn.w	r0, #4
}
   19e2e:	4770      	bx	lr
        return ARP_RES_BAD_ADDRESS;
   19e30:	f06f 0004 	mvn.w	r0, #4
   19e34:	e7db      	b.n	19dee <TCPIP_ARP_EntryRemove+0x1a>
        return ARP_RES_NO_INTERFACE;
   19e36:	f06f 0005 	mvn.w	r0, #5
   19e3a:	e7d8      	b.n	19dee <TCPIP_ARP_EntryRemove+0x1a>
        return ARP_RES_NO_ENTRY;
   19e3c:	f04f 30ff 	mov.w	r0, #4294967295
   19e40:	e7d5      	b.n	19dee <TCPIP_ARP_EntryRemove+0x1a>
   19e42:	bf00      	nop
   19e44:	2000e1a4 	.word	0x2000e1a4

Disassembly of section .text.TCPIP_DHCP_ConnectionHandler%445:

00019e48 <TCPIP_DHCP_ConnectionHandler>:
{
   19e48:	b570      	push	{r4, r5, r6, lr}
   19e4a:	4605      	mov	r5, r0
   19e4c:	460e      	mov	r6, r1
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   19e4e:	4b1a      	ldr	r3, [pc, #104]	; (19eb8 <TCPIP_DHCP_ConnectionHandler+0x70>)
   19e50:	681c      	ldr	r4, [r3, #0]
   19e52:	f007 fedf 	bl	21c14 <TCPIP_STACK_NetIxGet>
    if (pClient->flags.bDHCPEnabled != 0)
   19e56:	235c      	movs	r3, #92	; 0x5c
   19e58:	fb03 4000 	mla	r0, r3, r0, r4
   19e5c:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   19e60:	f013 0101 	ands.w	r1, r3, #1
   19e64:	d011      	beq.n	19e8a <TCPIP_DHCP_ConnectionHandler+0x42>
        if (connEvent & TCPIP_MAC_EV_CONN_LOST)
   19e66:	f416 5f80 	tst.w	r6, #4096	; 0x1000
   19e6a:	d10f      	bne.n	19e8c <TCPIP_DHCP_ConnectionHandler+0x44>
        else if (connEvent & TCPIP_MAC_EV_CONN_ESTABLISHED)
   19e6c:	f416 6f00 	tst.w	r6, #2048	; 0x800
   19e70:	d00b      	beq.n	19e8a <TCPIP_DHCP_ConnectionHandler+0x42>
            _DHCPEnable(pNetIf, pClient->flags.bWasBound ? TCPIP_DHCP_OPER_INIT_REBOOT : TCPIP_DHCP_OPER_INIT);
   19e72:	f003 0310 	and.w	r3, r3, #16
   19e76:	2b00      	cmp	r3, #0
   19e78:	bf18      	it	ne
   19e7a:	2102      	movne	r1, #2
   19e7c:	4628      	mov	r0, r5
   19e7e:	f7fd ffab 	bl	17dd8 <_DHCPEnable>
            _DHCPNotifyClients(pNetIf, DHCP_EVENT_CONN_ESTABLISHED);
   19e82:	210c      	movs	r1, #12
   19e84:	4628      	mov	r0, r5
   19e86:	f004 f835 	bl	1def4 <_DHCPNotifyClients>
}
   19e8a:	bd70      	pop	{r4, r5, r6, pc}
            _DHCPClientClose(pNetIf, false, false);
   19e8c:	2200      	movs	r2, #0
   19e8e:	4611      	mov	r1, r2
   19e90:	4628      	mov	r0, r5
   19e92:	f7fe fbab 	bl	185ec <_DHCPClientClose>
            _TCPIPStackSetConfigAddress(pNetIf, 0, 0, true);
   19e96:	2301      	movs	r3, #1
   19e98:	2200      	movs	r2, #0
   19e9a:	4611      	mov	r1, r2
   19e9c:	4628      	mov	r0, r5
   19e9e:	f004 fc72 	bl	1e786 <_TCPIPStackSetConfigAddress>
            TCPIP_STACK_AddressServiceEvent(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_DHCPC, TCPIP_STACK_ADDRESS_SERVICE_EVENT_CONN_LOST);
   19ea2:	2202      	movs	r2, #2
   19ea4:	2101      	movs	r1, #1
   19ea6:	4628      	mov	r0, r5
   19ea8:	f003 fa3e 	bl	1d328 <TCPIP_STACK_AddressServiceEvent>
            _DHCPNotifyClients(pNetIf, DHCP_EVENT_CONN_LOST);
   19eac:	210b      	movs	r1, #11
   19eae:	4628      	mov	r0, r5
   19eb0:	f004 f820 	bl	1def4 <_DHCPNotifyClients>
   19eb4:	e7e9      	b.n	19e8a <TCPIP_DHCP_ConnectionHandler+0x42>
   19eb6:	bf00      	nop
   19eb8:	2000e610 	.word	0x2000e610

Disassembly of section .text.xTaskRemoveFromEventList%446:

00019ebc <xTaskRemoveFromEventList>:
{
   19ebc:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   19ebe:	68c3      	ldr	r3, [r0, #12]
   19ec0:	68dc      	ldr	r4, [r3, #12]
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   19ec2:	f104 0518 	add.w	r5, r4, #24
   19ec6:	4628      	mov	r0, r5
   19ec8:	f006 faf4 	bl	204b4 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   19ecc:	4b12      	ldr	r3, [pc, #72]	; (19f18 <xTaskRemoveFromEventList+0x5c>)
   19ece:	681b      	ldr	r3, [r3, #0]
   19ed0:	b9eb      	cbnz	r3, 19f0e <xTaskRemoveFromEventList+0x52>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   19ed2:	1d25      	adds	r5, r4, #4
   19ed4:	4628      	mov	r0, r5
   19ed6:	f006 faed 	bl	204b4 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
   19eda:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   19edc:	4a0f      	ldr	r2, [pc, #60]	; (19f1c <xTaskRemoveFromEventList+0x60>)
   19ede:	6811      	ldr	r1, [r2, #0]
   19ee0:	2301      	movs	r3, #1
   19ee2:	4083      	lsls	r3, r0
   19ee4:	430b      	orrs	r3, r1
   19ee6:	6013      	str	r3, [r2, #0]
   19ee8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   19eec:	4629      	mov	r1, r5
   19eee:	4b0c      	ldr	r3, [pc, #48]	; (19f20 <xTaskRemoveFromEventList+0x64>)
   19ef0:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   19ef4:	f007 fc17 	bl	21726 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   19ef8:	4b0a      	ldr	r3, [pc, #40]	; (19f24 <xTaskRemoveFromEventList+0x68>)
   19efa:	681b      	ldr	r3, [r3, #0]
   19efc:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   19efe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   19f00:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
   19f02:	bf83      	ittte	hi
   19f04:	2001      	movhi	r0, #1
   19f06:	4b08      	ldrhi	r3, [pc, #32]	; (19f28 <xTaskRemoveFromEventList+0x6c>)
   19f08:	6018      	strhi	r0, [r3, #0]
		xReturn = pdFALSE;
   19f0a:	2000      	movls	r0, #0
}
   19f0c:	bd38      	pop	{r3, r4, r5, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   19f0e:	4629      	mov	r1, r5
   19f10:	4806      	ldr	r0, [pc, #24]	; (19f2c <xTaskRemoveFromEventList+0x70>)
   19f12:	f007 fc08 	bl	21726 <vListInsertEnd>
   19f16:	e7ef      	b.n	19ef8 <xTaskRemoveFromEventList+0x3c>
   19f18:	2000e6b8 	.word	0x2000e6b8
   19f1c:	2000e6c0 	.word	0x2000e6c0
   19f20:	2000e080 	.word	0x2000e080
   19f24:	2000e6a4 	.word	0x2000e6a4
   19f28:	2000e6dc 	.word	0x2000e6dc
   19f2c:	2000e4b4 	.word	0x2000e4b4

Disassembly of section .text.wc_GenerateSeed%447:

00019f30 <wc_GenerateSeed>:
            return 0;
        }
    #else  /* WOLFSSL_PIC32MZ_RNG */
        /* uses the core timer, in nanoseconds to seed srand */
        int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
        {
   19f30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   19f32:	460f      	mov	r7, r1
   19f34:	4616      	mov	r6, r2
            int i;
            srand(PIC32_SEED_COUNT() * 25);
   19f36:	f008 f8b9 	bl	220ac <SYS_TIME_CounterGet>
   19f3a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   19f3e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   19f42:	f002 ffa1 	bl	1ce88 <srand>

            for (i = 0; i < sz; i++ ) {
   19f46:	b35e      	cbz	r6, 19fa0 <wc_GenerateSeed+0x70>
                output[i] = rand() % 256;
   19f48:	f000 fe54 	bl	1abf4 <rand>
   19f4c:	4243      	negs	r3, r0
   19f4e:	b2c0      	uxtb	r0, r0
   19f50:	b2db      	uxtb	r3, r3
   19f52:	bf58      	it	pl
   19f54:	4258      	negpl	r0, r3
   19f56:	7038      	strb	r0, [r7, #0]
                if ( (i % 8) == 7)
   19f58:	443e      	add	r6, r7
   19f5a:	3e01      	subs	r6, #1
                output[i] = rand() % 256;
   19f5c:	463d      	mov	r5, r7
   19f5e:	f1c7 0701 	rsb	r7, r7, #1
   19f62:	e007      	b.n	19f74 <wc_GenerateSeed+0x44>
                    srand(PIC32_SEED_COUNT() * 25);
   19f64:	f008 f8a2 	bl	220ac <SYS_TIME_CounterGet>
   19f68:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   19f6c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   19f70:	f002 ff8a 	bl	1ce88 <srand>
   19f74:	197c      	adds	r4, r7, r5
            for (i = 0; i < sz; i++ ) {
   19f76:	42b5      	cmp	r5, r6
   19f78:	d012      	beq.n	19fa0 <wc_GenerateSeed+0x70>
                output[i] = rand() % 256;
   19f7a:	f000 fe3b 	bl	1abf4 <rand>
   19f7e:	4243      	negs	r3, r0
   19f80:	b2c0      	uxtb	r0, r0
   19f82:	b2db      	uxtb	r3, r3
   19f84:	bf58      	it	pl
   19f86:	4258      	negpl	r0, r3
   19f88:	f805 0f01 	strb.w	r0, [r5, #1]!
                if ( (i % 8) == 7)
   19f8c:	4263      	negs	r3, r4
   19f8e:	f004 0407 	and.w	r4, r4, #7
   19f92:	f003 0307 	and.w	r3, r3, #7
   19f96:	bf58      	it	pl
   19f98:	425c      	negpl	r4, r3
   19f9a:	2c07      	cmp	r4, #7
   19f9c:	d1ea      	bne.n	19f74 <wc_GenerateSeed+0x44>
   19f9e:	e7e1      	b.n	19f64 <wc_GenerateSeed+0x34>
            }
            return 0;
        }
   19fa0:	2000      	movs	r0, #0
   19fa2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text._MacTxPendingPackets%448:

00019fa4 <_MacTxPendingPackets>:
{
   19fa4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   19fa8:	4607      	mov	r7, r0
   19faa:	4688      	mov	r8, r1
    while((pPkt = (TCPIP_MAC_PACKET*)DRV_PIC32CGMAC_SingleListHeadRemove(&pMACDrv->sGmacData.gmac_queue[queueIdx]._TxQueue)) != 0)
   19fac:	262c      	movs	r6, #44	; 0x2c
   19fae:	fb06 0601 	mla	r6, r6, r1, r0
   19fb2:	36a4      	adds	r6, #164	; 0xa4
	DRV_PIC32CGMAC_RESULT ethRes = DRV_PIC32CGMAC_RES_NO_PACKET;    
   19fb4:	2401      	movs	r4, #1
    while((pPkt = (TCPIP_MAC_PACKET*)DRV_PIC32CGMAC_SingleListHeadRemove(&pMACDrv->sGmacData.gmac_queue[queueIdx]._TxQueue)) != 0)
   19fb6:	4630      	mov	r0, r6
   19fb8:	f006 feca 	bl	20d50 <DRV_PIC32CGMAC_SingleListHeadRemove>
   19fbc:	4605      	mov	r5, r0
   19fbe:	b198      	cbz	r0, 19fe8 <_MacTxPendingPackets+0x44>
		ethRes = DRV_PIC32CGMAC_LibTxSendPacket(pMACDrv,  pPkt->pDSeg, queueIdx);
   19fc0:	4642      	mov	r2, r8
   19fc2:	6929      	ldr	r1, [r5, #16]
   19fc4:	4638      	mov	r0, r7
   19fc6:	f7fa fdf3 	bl	14bb0 <DRV_PIC32CGMAC_LibTxSendPacket>
   19fca:	4604      	mov	r4, r0
        if(ethRes == DRV_PIC32CGMAC_RES_NO_DESCRIPTORS)
   19fcc:	2803      	cmp	r0, #3
   19fce:	d1f2      	bne.n	19fb6 <_MacTxPendingPackets+0x12>
            pMACDrv->sGmacData._txStat.nTxQueueFull++;
   19fd0:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
   19fd4:	3301      	adds	r3, #1
   19fd6:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
            DRV_PIC32CGMAC_SingleListHeadAdd(&pMACDrv->sGmacData.gmac_queue[queueIdx]._TxQueue, (DRV_PIC32CGMAC_SGL_LIST_NODE*)pPkt); 
   19fda:	4629      	mov	r1, r5
   19fdc:	4630      	mov	r0, r6
   19fde:	f007 f9d9 	bl	21394 <DRV_PIC32CGMAC_SingleListHeadAdd>
		return TCPIP_MAC_RES_PENDING;
   19fe2:	2001      	movs	r0, #1
}
   19fe4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if((ethRes == DRV_PIC32CGMAC_RES_OK)||(ethRes == DRV_PIC32CGMAC_RES_NO_PACKET))
   19fe8:	b2e3      	uxtb	r3, r4
   19fea:	2b01      	cmp	r3, #1
   19fec:	d801      	bhi.n	19ff2 <_MacTxPendingPackets+0x4e>
		return TCPIP_MAC_RES_OK;
   19fee:	2000      	movs	r0, #0
   19ff0:	e7f8      	b.n	19fe4 <_MacTxPendingPackets+0x40>
	else if(ethRes == DRV_PIC32CGMAC_RES_NO_DESCRIPTORS)
   19ff2:	2c03      	cmp	r4, #3
		return TCPIP_MAC_RES_PENDING;
   19ff4:	bf08      	it	eq
   19ff6:	2001      	moveq	r0, #1
	else if(ethRes == DRV_PIC32CGMAC_RES_NO_DESCRIPTORS)
   19ff8:	d0f4      	beq.n	19fe4 <_MacTxPendingPackets+0x40>
		pMACDrv->sGmacData._txStat.nTxErrorPackets++;
   19ffa:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
   19ffe:	3301      	adds	r3, #1
   1a000:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
		(*pMACDrv->sGmacData.pktAckF)(pPkt, TCPIP_MAC_PKT_ACK_BUFFER_ERR,TCPIP_THIS_MODULE_ID);	
   1a004:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1a006:	f241 0250 	movw	r2, #4176	; 0x1050
   1a00a:	f06f 0102 	mvn.w	r1, #2
   1a00e:	4798      	blx	r3
        return TCPIP_MAC_RES_PACKET_ERR; 
   1a010:	f06f 0009 	mvn.w	r0, #9
   1a014:	e7e6      	b.n	19fe4 <_MacTxPendingPackets+0x40>

Disassembly of section .text._TCPIP_StackSyncFunction%449:

0001a016 <_TCPIP_StackSyncFunction>:
    TCPIP_PKT_FlightLogTx(ptrPacket, pNetIf->macId);    // MAC doesn't call the log function
    return pNetIf->hIfMac != 0 ? (*pNetIf->pMacObj->TCPIP_MAC_PacketTx)(pNetIf->hIfMac, ptrPacket) : TCPIP_MAC_RES_NOT_READY_ERR;
}

static bool _TCPIP_StackSyncFunction(void* synchHandle, TCPIP_MAC_SYNCH_REQUEST req)
{
   1a016:	b510      	push	{r4, lr}
    switch(req)
   1a018:	3901      	subs	r1, #1
   1a01a:	2905      	cmp	r1, #5
   1a01c:	d832      	bhi.n	1a084 <_TCPIP_StackSyncFunction+0x6e>
   1a01e:	e8df f001 	tbb	[pc, r1]
   1a022:	0d03      	.short	0x0d03
   1a024:	2b241d14 	.word	0x2b241d14
    {
        case TCPIP_MAC_SYNCH_REQUEST_OBJ_CREATE: 
            return (OSAL_SEM_Create((OSAL_SEM_HANDLE_TYPE*)synchHandle, OSAL_SEM_TYPE_BINARY, 1, 1) == OSAL_RESULT_TRUE) ? true : false;
   1a028:	2301      	movs	r3, #1
   1a02a:	461a      	mov	r2, r3
   1a02c:	2100      	movs	r1, #0
   1a02e:	f001 fd89 	bl	1bb44 <OSAL_SEM_Create>
   1a032:	2801      	cmp	r0, #1
   1a034:	bf14      	ite	ne
   1a036:	2000      	movne	r0, #0
   1a038:	2001      	moveq	r0, #1

        default:
            return false;
    }

}
   1a03a:	bd10      	pop	{r4, pc}
            return (OSAL_SEM_Delete((OSAL_SEM_HANDLE_TYPE*)synchHandle) == OSAL_RESULT_TRUE) ? true : false;
   1a03c:	f007 fc96 	bl	2196c <OSAL_SEM_Delete>
   1a040:	2801      	cmp	r0, #1
   1a042:	bf14      	ite	ne
   1a044:	2000      	movne	r0, #0
   1a046:	2001      	moveq	r0, #1
   1a048:	e7f7      	b.n	1a03a <_TCPIP_StackSyncFunction+0x24>
            return (OSAL_SEM_Pend((OSAL_SEM_HANDLE_TYPE*)synchHandle, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE) ? true: false;
   1a04a:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1a04e:	f006 fe19 	bl	20c84 <OSAL_SEM_Pend>
   1a052:	2801      	cmp	r0, #1
   1a054:	bf14      	ite	ne
   1a056:	2000      	movne	r0, #0
   1a058:	2001      	moveq	r0, #1
   1a05a:	e7ee      	b.n	1a03a <_TCPIP_StackSyncFunction+0x24>
            return (OSAL_SEM_Post((OSAL_SEM_HANDLE_TYPE*)synchHandle) == OSAL_RESULT_TRUE) ? true: false;
   1a05c:	f007 fa2a 	bl	214b4 <OSAL_SEM_Post>
   1a060:	2801      	cmp	r0, #1
   1a062:	bf14      	ite	ne
   1a064:	2000      	movne	r0, #0
   1a066:	2001      	moveq	r0, #1
   1a068:	e7e7      	b.n	1a03a <_TCPIP_StackSyncFunction+0x24>
   1a06a:	4604      	mov	r4, r0
            *(OSAL_CRITSECT_DATA_TYPE*)synchHandle =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1a06c:	2000      	movs	r0, #0
   1a06e:	f007 fa15 	bl	2149c <OSAL_CRIT_Enter>
   1a072:	6020      	str	r0, [r4, #0]
            return true; 
   1a074:	2001      	movs	r0, #1
   1a076:	e7e0      	b.n	1a03a <_TCPIP_StackSyncFunction+0x24>
            OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, *(OSAL_CRITSECT_DATA_TYPE*)synchHandle);
   1a078:	6801      	ldr	r1, [r0, #0]
   1a07a:	2000      	movs	r0, #0
   1a07c:	f007 fb3d 	bl	216fa <OSAL_CRIT_Leave>
            return true; 
   1a080:	2001      	movs	r0, #1
   1a082:	e7da      	b.n	1a03a <_TCPIP_StackSyncFunction+0x24>
            return false;
   1a084:	2000      	movs	r0, #0
   1a086:	e7d8      	b.n	1a03a <_TCPIP_StackSyncFunction+0x24>

Disassembly of section .text.TCPIP_PKT_DataSegmentGet%450:

0001a088 <TCPIP_PKT_DataSegmentGet>:
    if(srchTransport)
   1a088:	b34a      	cbz	r2, 1a0de <TCPIP_PKT_DataSegmentGet+0x56>
        for(pSeg = pPkt->pDSeg; pSeg != 0; pSeg = pSeg->next)
   1a08a:	6903      	ldr	r3, [r0, #16]
   1a08c:	2b00      	cmp	r3, #0
   1a08e:	d032      	beq.n	1a0f6 <TCPIP_PKT_DataSegmentGet+0x6e>
            if(pSeg->segLoad <= pPkt->pTransportLayer && pPkt->pTransportLayer <= pSeg->segLoad + pSeg->segSize)
   1a090:	69c0      	ldr	r0, [r0, #28]
   1a092:	e015      	b.n	1a0c0 <TCPIP_PKT_DataSegmentGet+0x38>
                if(pPkt->pTransportLayer <= dataAddress && dataAddress <= pSeg->segLoad + pSeg->segSize)
   1a094:	4288      	cmp	r0, r1
   1a096:	d801      	bhi.n	1a09c <TCPIP_PKT_DataSegmentGet+0x14>
   1a098:	428a      	cmp	r2, r1
   1a09a:	d20b      	bcs.n	1a0b4 <TCPIP_PKT_DataSegmentGet+0x2c>
                pStartSeg = pSeg->next;
   1a09c:	681b      	ldr	r3, [r3, #0]
    for(pSeg = pStartSeg; pSeg != 0; pSeg = pSeg->next)
   1a09e:	b913      	cbnz	r3, 1a0a6 <TCPIP_PKT_DataSegmentGet+0x1e>
   1a0a0:	e008      	b.n	1a0b4 <TCPIP_PKT_DataSegmentGet+0x2c>
   1a0a2:	681b      	ldr	r3, [r3, #0]
   1a0a4:	b133      	cbz	r3, 1a0b4 <TCPIP_PKT_DataSegmentGet+0x2c>
        if(pSeg->segLoad <= dataAddress && dataAddress <= pSeg->segLoad + pSeg->segSize)
   1a0a6:	689a      	ldr	r2, [r3, #8]
   1a0a8:	428a      	cmp	r2, r1
   1a0aa:	d8fa      	bhi.n	1a0a2 <TCPIP_PKT_DataSegmentGet+0x1a>
   1a0ac:	89d8      	ldrh	r0, [r3, #14]
   1a0ae:	4402      	add	r2, r0
   1a0b0:	4291      	cmp	r1, r2
   1a0b2:	d8f6      	bhi.n	1a0a2 <TCPIP_PKT_DataSegmentGet+0x1a>
}
   1a0b4:	4618      	mov	r0, r3
   1a0b6:	f85d 4b04 	ldr.w	r4, [sp], #4
   1a0ba:	4770      	bx	lr
        for(pSeg = pPkt->pDSeg; pSeg != 0; pSeg = pSeg->next)
   1a0bc:	681b      	ldr	r3, [r3, #0]
   1a0be:	b1d3      	cbz	r3, 1a0f6 <TCPIP_PKT_DataSegmentGet+0x6e>
            if(pSeg->segLoad <= pPkt->pTransportLayer && pPkt->pTransportLayer <= pSeg->segLoad + pSeg->segSize)
   1a0c0:	689a      	ldr	r2, [r3, #8]
   1a0c2:	4282      	cmp	r2, r0
   1a0c4:	d8fa      	bhi.n	1a0bc <TCPIP_PKT_DataSegmentGet+0x34>
{
   1a0c6:	b410      	push	{r4}
            if(pSeg->segLoad <= pPkt->pTransportLayer && pPkt->pTransportLayer <= pSeg->segLoad + pSeg->segSize)
   1a0c8:	89dc      	ldrh	r4, [r3, #14]
   1a0ca:	4422      	add	r2, r4
   1a0cc:	4290      	cmp	r0, r2
   1a0ce:	d9e1      	bls.n	1a094 <TCPIP_PKT_DataSegmentGet+0xc>
        for(pSeg = pPkt->pDSeg; pSeg != 0; pSeg = pSeg->next)
   1a0d0:	681b      	ldr	r3, [r3, #0]
   1a0d2:	2b00      	cmp	r3, #0
   1a0d4:	d0ee      	beq.n	1a0b4 <TCPIP_PKT_DataSegmentGet+0x2c>
            if(pSeg->segLoad <= pPkt->pTransportLayer && pPkt->pTransportLayer <= pSeg->segLoad + pSeg->segSize)
   1a0d6:	689a      	ldr	r2, [r3, #8]
   1a0d8:	4282      	cmp	r2, r0
   1a0da:	d8f9      	bhi.n	1a0d0 <TCPIP_PKT_DataSegmentGet+0x48>
   1a0dc:	e7f4      	b.n	1a0c8 <TCPIP_PKT_DataSegmentGet+0x40>
        pStartSeg = pPkt->pDSeg;
   1a0de:	6903      	ldr	r3, [r0, #16]
    for(pSeg = pStartSeg; pSeg != 0; pSeg = pSeg->next)
   1a0e0:	b913      	cbnz	r3, 1a0e8 <TCPIP_PKT_DataSegmentGet+0x60>
   1a0e2:	e008      	b.n	1a0f6 <TCPIP_PKT_DataSegmentGet+0x6e>
   1a0e4:	681b      	ldr	r3, [r3, #0]
   1a0e6:	b133      	cbz	r3, 1a0f6 <TCPIP_PKT_DataSegmentGet+0x6e>
        if(pSeg->segLoad <= dataAddress && dataAddress <= pSeg->segLoad + pSeg->segSize)
   1a0e8:	689a      	ldr	r2, [r3, #8]
   1a0ea:	428a      	cmp	r2, r1
   1a0ec:	d8fa      	bhi.n	1a0e4 <TCPIP_PKT_DataSegmentGet+0x5c>
   1a0ee:	89d8      	ldrh	r0, [r3, #14]
   1a0f0:	4402      	add	r2, r0
   1a0f2:	4291      	cmp	r1, r2
   1a0f4:	d8f6      	bhi.n	1a0e4 <TCPIP_PKT_DataSegmentGet+0x5c>
}
   1a0f6:	4618      	mov	r0, r3
   1a0f8:	4770      	bx	lr

Disassembly of section .text.Hash_DRBG_Instantiate%451:

0001a0fa <Hash_DRBG_Instantiate>:
{
   1a0fa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1a0fe:	b084      	sub	sp, #16
   1a100:	4604      	mov	r4, r0
   1a102:	460e      	mov	r6, r1
   1a104:	4617      	mov	r7, r2
   1a106:	4698      	mov	r8, r3
    XMEMSET(drbg, 0, sizeof(DRBG_internal));
   1a108:	2284      	movs	r2, #132	; 0x84
   1a10a:	2100      	movs	r1, #0
   1a10c:	f007 fd36 	bl	21b7c <memset>
    drbg->heap = heap;
   1a110:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1a112:	67a3      	str	r3, [r4, #120]	; 0x78
    drbg->devId = devId;
   1a114:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1a116:	67e3      	str	r3, [r4, #124]	; 0x7c
    if (Hash_df(drbg, drbg->V, sizeof(drbg->V), drbgInitV, seed, seedSz,
   1a118:	f104 0508 	add.w	r5, r4, #8
   1a11c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1a11e:	9303      	str	r3, [sp, #12]
   1a120:	f8cd 8008 	str.w	r8, [sp, #8]
   1a124:	9701      	str	r7, [sp, #4]
   1a126:	9600      	str	r6, [sp, #0]
   1a128:	2304      	movs	r3, #4
   1a12a:	2237      	movs	r2, #55	; 0x37
   1a12c:	4629      	mov	r1, r5
   1a12e:	4620      	mov	r0, r4
   1a130:	f7f7 fd30 	bl	11b94 <Hash_df>
   1a134:	b120      	cbz	r0, 1a140 <Hash_DRBG_Instantiate+0x46>
    int ret = DRBG_FAILURE;
   1a136:	2301      	movs	r3, #1
}
   1a138:	4618      	mov	r0, r3
   1a13a:	b004      	add	sp, #16
   1a13c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        Hash_df(drbg, drbg->C, sizeof(drbg->C), drbgInitC, drbg->V,
   1a140:	2300      	movs	r3, #0
   1a142:	9303      	str	r3, [sp, #12]
   1a144:	9302      	str	r3, [sp, #8]
   1a146:	2237      	movs	r2, #55	; 0x37
   1a148:	9201      	str	r2, [sp, #4]
   1a14a:	9500      	str	r5, [sp, #0]
   1a14c:	f104 013f 	add.w	r1, r4, #63	; 0x3f
   1a150:	4620      	mov	r0, r4
   1a152:	f7f7 fd1f 	bl	11b94 <Hash_df>
                                              nonce, nonceSz) == DRBG_SUCCESS &&
   1a156:	4603      	mov	r3, r0
   1a158:	b930      	cbnz	r0, 1a168 <Hash_DRBG_Instantiate+0x6e>
        drbg->reseedCtr = 1;
   1a15a:	2201      	movs	r2, #1
   1a15c:	6022      	str	r2, [r4, #0]
        drbg->lastBlock = 0;
   1a15e:	2200      	movs	r2, #0
   1a160:	6062      	str	r2, [r4, #4]
        drbg->matchCount = 0;
   1a162:	f884 2080 	strb.w	r2, [r4, #128]	; 0x80
        ret = DRBG_SUCCESS;
   1a166:	e7e7      	b.n	1a138 <Hash_DRBG_Instantiate+0x3e>
    int ret = DRBG_FAILURE;
   1a168:	2301      	movs	r3, #1
    return ret;
   1a16a:	e7e5      	b.n	1a138 <Hash_DRBG_Instantiate+0x3e>

Disassembly of section .text.DRV_GMAC_EventAcknowledge%452:

0001a16c <DRV_GMAC_EventAcknowledge>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1a16c:	4b1a      	ldr	r3, [pc, #104]	; (1a1d8 <DRV_GMAC_EventAcknowledge+0x6c>)
   1a16e:	4283      	cmp	r3, r0
   1a170:	d12d      	bne.n	1a1ce <DRV_GMAC_EventAcknowledge+0x62>
    if(pMACDrv == 0)
   1a172:	b370      	cbz	r0, 1a1d2 <DRV_GMAC_EventAcknowledge+0x66>
	if(pDcpt->_TcpEnabledEvents != 0)
   1a174:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
   1a178:	b90b      	cbnz	r3, 1a17e <DRV_GMAC_EventAcknowledge+0x12>
	return false;
   1a17a:	2000      	movs	r0, #0
}
   1a17c:	4770      	bx	lr
{
   1a17e:	b570      	push	{r4, r5, r6, lr}
   1a180:	b082      	sub	sp, #8
   1a182:	460c      	mov	r4, r1
		ethAckEv=_XtlEventsTcp2Eth(tcpAckEv);
   1a184:	4608      	mov	r0, r1
   1a186:	f005 f90d 	bl	1f3a4 <_XtlEventsTcp2Eth>
   1a18a:	4606      	mov	r6, r0
        DRV_PIC32CGMAC_LibSysInt_Disable(pMACDrv, GMAC_ALL_QUE_MASK, intStat);
   1a18c:	4d12      	ldr	r5, [pc, #72]	; (1a1d8 <DRV_GMAC_EventAcknowledge+0x6c>)
   1a18e:	aa01      	add	r2, sp, #4
   1a190:	213f      	movs	r1, #63	; 0x3f
   1a192:	4628      	mov	r0, r5
   1a194:	f006 f88e 	bl	202b4 <DRV_PIC32CGMAC_LibSysInt_Disable>
		pDcpt->_TcpPendingEvents &= ~tcpAckEv;         // no longer pending
   1a198:	f8b5 104e 	ldrh.w	r1, [r5, #78]	; 0x4e
   1a19c:	ea21 0104 	bic.w	r1, r1, r4
   1a1a0:	f8a5 104e 	strh.w	r1, [r5, #78]	; 0x4e
		pDcpt->_EthPendingEvents &= ~ethAckEv;         // no longer pending
   1a1a4:	f8b5 3052 	ldrh.w	r3, [r5, #82]	; 0x52
   1a1a8:	ea23 0306 	bic.w	r3, r3, r6
   1a1ac:	f8a5 3052 	strh.w	r3, [r5, #82]	; 0x52
            DRV_PIC32CGMAC_LibReadInterruptStatus(queIdx);
   1a1b0:	2000      	movs	r0, #0
   1a1b2:	f007 fe65 	bl	21e80 <DRV_PIC32CGMAC_LibReadInterruptStatus>
            DRV_PIC32CGMAC_LibEnableInterrupt(queIdx, ethAckEv);
   1a1b6:	4631      	mov	r1, r6
   1a1b8:	2000      	movs	r0, #0
   1a1ba:	f007 fe67 	bl	21e8c <DRV_PIC32CGMAC_LibEnableInterrupt>
        DRV_PIC32CGMAC_LibSysInt_Restore(pMACDrv, GMAC_ALL_QUE_MASK, intStat);
   1a1be:	aa01      	add	r2, sp, #4
   1a1c0:	213f      	movs	r1, #63	; 0x3f
   1a1c2:	4628      	mov	r0, r5
   1a1c4:	f007 f8f2 	bl	213ac <DRV_PIC32CGMAC_LibSysInt_Restore>
		return true;
   1a1c8:	2001      	movs	r0, #1
}
   1a1ca:	b002      	add	sp, #8
   1a1cc:	bd70      	pop	{r4, r5, r6, pc}
        return false;
   1a1ce:	2000      	movs	r0, #0
   1a1d0:	4770      	bx	lr
   1a1d2:	2000      	movs	r0, #0
   1a1d4:	4770      	bx	lr
   1a1d6:	bf00      	nop
   1a1d8:	2000dab8 	.word	0x2000dab8

Disassembly of section .text.DRV_GMAC_Tasks_ISR%453:

0001a1dc <DRV_GMAC_Tasks_ISR>:
{
   1a1dc:	b538      	push	{r3, r4, r5, lr}
	currGroupEvents = ((GMAC_EVENTS)currEthEvents) & pDcpt->_EthEnabledEvents;
   1a1de:	ebc0 1240 	rsb	r2, r0, r0, lsl #5
   1a1e2:	4b19      	ldr	r3, [pc, #100]	; (1a248 <DRV_GMAC_Tasks_ISR+0x6c>)
   1a1e4:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   1a1e8:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
	if(currGroupEvents)
   1a1ec:	4019      	ands	r1, r3
   1a1ee:	d02a      	beq.n	1a246 <DRV_GMAC_Tasks_ISR+0x6a>
		pDcpt->_EthPendingEvents |= currGroupEvents;                    
   1a1f0:	4b15      	ldr	r3, [pc, #84]	; (1a248 <DRV_GMAC_Tasks_ISR+0x6c>)
   1a1f2:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
   1a1f6:	f8b2 3052 	ldrh.w	r3, [r2, #82]	; 0x52
   1a1fa:	430b      	orrs	r3, r1
   1a1fc:	f8a2 3052 	strh.w	r3, [r2, #82]	; 0x52
	tcpEv |= (eEvents&(GMAC_EV_RXCOMPLETE))? TCPIP_MAC_EV_RX_DONE:0;
   1a200:	00cb      	lsls	r3, r1, #3
   1a202:	f003 0310 	and.w	r3, r3, #16
	tcpEv |= (eEvents&(GMAC_EV_RXOVERRUN))? TCPIP_MAC_EV_RX_OVFLOW:0;
   1a206:	124c      	asrs	r4, r1, #9
   1a208:	f004 0402 	and.w	r4, r4, #2
	tcpEv |= (eEvents&(GMAC_EV_RXUSEDBITREAD))? TCPIP_MAC_EV_RX_BUFNA:0; // mapping RX Used bit interrupt to BUFNA;
   1a20c:	4323      	orrs	r3, r4
   1a20e:	f001 0404 	and.w	r4, r1, #4
   1a212:	4323      	orrs	r3, r4
	tcpEv |= (eEvents&(GMAC_EV_TXFRAMECORRUPT))? TCPIP_MAC_EV_TX_BUSERR:0;
   1a214:	010c      	lsls	r4, r1, #4
   1a216:	f404 6480 	and.w	r4, r4, #1024	; 0x400
	tcpEv |= (eEvents&(GMAC_EV_RXUSEDBITREAD))? TCPIP_MAC_EV_RX_BUFNA:0; // mapping RX Used bit interrupt to BUFNA;
   1a21a:	4323      	orrs	r3, r4
    tcpEv = (eEvents&(GMAC_EV_TXCOMPLETE))? TCPIP_MAC_EV_TX_DONE:0;
   1a21c:	0049      	lsls	r1, r1, #1
   1a21e:	f401 7180 	and.w	r1, r1, #256	; 0x100
	tcpEv |= (eEvents&(GMAC_EV_RXUSEDBITREAD))? TCPIP_MAC_EV_RX_BUFNA:0; // mapping RX Used bit interrupt to BUFNA;
   1a222:	430b      	orrs	r3, r1
		pDcpt->_TcpPendingEvents |= _XtlEventsEth2Tcp(currGroupEvents);
   1a224:	f8b2 104e 	ldrh.w	r1, [r2, #78]	; 0x4e
   1a228:	430b      	orrs	r3, r1
   1a22a:	f8a2 304e 	strh.w	r3, [r2, #78]	; 0x4e
		if(pDcpt->_TcpNotifyFnc)
   1a22e:	6d54      	ldr	r4, [r2, #84]	; 0x54
   1a230:	b14c      	cbz	r4, 1a246 <DRV_GMAC_Tasks_ISR+0x6a>
			(*pDcpt->_TcpNotifyFnc)(pDcpt->_TcpPendingEvents, pDcpt->_TcpNotifyParam);     
   1a232:	4b05      	ldr	r3, [pc, #20]	; (1a248 <DRV_GMAC_Tasks_ISR+0x6c>)
   1a234:	0142      	lsls	r2, r0, #5
   1a236:	1a11      	subs	r1, r2, r0
   1a238:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
   1a23c:	f8b1 504e 	ldrh.w	r5, [r1, #78]	; 0x4e
   1a240:	6d89      	ldr	r1, [r1, #88]	; 0x58
   1a242:	4628      	mov	r0, r5
   1a244:	47a0      	blx	r4
}
   1a246:	bd38      	pop	{r3, r4, r5, pc}
   1a248:	2000dab8 	.word	0x2000dab8

Disassembly of section .text.TCPIP_IPV4_Cleanup%454:

0001a24c <TCPIP_IPV4_Cleanup>:
{
   1a24c:	b508      	push	{r3, lr}
    if(ipv4ArpHandle)
   1a24e:	4b14      	ldr	r3, [pc, #80]	; (1a2a0 <TCPIP_IPV4_Cleanup+0x54>)
   1a250:	6818      	ldr	r0, [r3, #0]
   1a252:	b120      	cbz	r0, 1a25e <TCPIP_IPV4_Cleanup+0x12>
        TCPIP_ARP_HandlerDeRegister(ipv4ArpHandle);
   1a254:	f006 f876 	bl	20344 <TCPIP_ARP_HandlerDeRegister>
        ipv4ArpHandle = 0;
   1a258:	4b11      	ldr	r3, [pc, #68]	; (1a2a0 <TCPIP_IPV4_Cleanup+0x54>)
   1a25a:	2200      	movs	r2, #0
   1a25c:	601a      	str	r2, [r3, #0]
    TCPIP_Notification_Deinitialize(&ipv4PacketFilters, ipv4MemH);
   1a25e:	4b11      	ldr	r3, [pc, #68]	; (1a2a4 <TCPIP_IPV4_Cleanup+0x58>)
   1a260:	6819      	ldr	r1, [r3, #0]
   1a262:	4811      	ldr	r0, [pc, #68]	; (1a2a8 <TCPIP_IPV4_Cleanup+0x5c>)
   1a264:	f007 fc0a 	bl	21a7c <TCPIP_Notification_Deinitialize>
    ipv4ActFilterCount = 0;
   1a268:	4b10      	ldr	r3, [pc, #64]	; (1a2ac <TCPIP_IPV4_Cleanup+0x60>)
   1a26a:	2200      	movs	r2, #0
   1a26c:	601a      	str	r2, [r3, #0]
    TCPIP_Helper_ProtectedSingleListDeinitialize(&ipv4ArpQueue);
   1a26e:	4810      	ldr	r0, [pc, #64]	; (1a2b0 <TCPIP_IPV4_Cleanup+0x64>)
   1a270:	f004 ff18 	bl	1f0a4 <TCPIP_Helper_ProtectedSingleListDeinitialize>
    if(signalHandle)
   1a274:	4b0f      	ldr	r3, [pc, #60]	; (1a2b4 <TCPIP_IPV4_Cleanup+0x68>)
   1a276:	6818      	ldr	r0, [r3, #0]
   1a278:	b120      	cbz	r0, 1a284 <TCPIP_IPV4_Cleanup+0x38>
        _TCPIPStackSignalHandlerDeregister(signalHandle);
   1a27a:	f007 fcd2 	bl	21c22 <_TCPIPStackSignalHandlerDeregister>
        signalHandle = 0;
   1a27e:	4b0d      	ldr	r3, [pc, #52]	; (1a2b4 <TCPIP_IPV4_Cleanup+0x68>)
   1a280:	2200      	movs	r2, #0
   1a282:	601a      	str	r2, [r3, #0]
    if(ipv4ArpEntries != 0)
   1a284:	4b0c      	ldr	r3, [pc, #48]	; (1a2b8 <TCPIP_IPV4_Cleanup+0x6c>)
   1a286:	6819      	ldr	r1, [r3, #0]
   1a288:	b131      	cbz	r1, 1a298 <TCPIP_IPV4_Cleanup+0x4c>
        TCPIP_HEAP_Free(ipv4MemH, ipv4ArpEntries);
   1a28a:	4b06      	ldr	r3, [pc, #24]	; (1a2a4 <TCPIP_IPV4_Cleanup+0x58>)
   1a28c:	6818      	ldr	r0, [r3, #0]
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   1a28e:	68c3      	ldr	r3, [r0, #12]
   1a290:	4798      	blx	r3
        ipv4ArpEntries = 0;
   1a292:	4b09      	ldr	r3, [pc, #36]	; (1a2b8 <TCPIP_IPV4_Cleanup+0x6c>)
   1a294:	2200      	movs	r2, #0
   1a296:	601a      	str	r2, [r3, #0]
    ipv4MemH = 0;
   1a298:	4b02      	ldr	r3, [pc, #8]	; (1a2a4 <TCPIP_IPV4_Cleanup+0x58>)
   1a29a:	2200      	movs	r2, #0
   1a29c:	601a      	str	r2, [r3, #0]
}
   1a29e:	bd08      	pop	{r3, pc}
   1a2a0:	2000e604 	.word	0x2000e604
   1a2a4:	2000e608 	.word	0x2000e608
   1a2a8:	2000e43c 	.word	0x2000e43c
   1a2ac:	2000e5fc 	.word	0x2000e5fc
   1a2b0:	2000e428 	.word	0x2000e428
   1a2b4:	2000e60c 	.word	0x2000e60c
   1a2b8:	2000e600 	.word	0x2000e600

Disassembly of section .text.TCPIP_Helper_CalcIPChecksum%455:

0001a2bc <TCPIP_Helper_CalcIPChecksum>:
    if(buffer == 0)
   1a2bc:	b3a0      	cbz	r0, 1a328 <TCPIP_Helper_CalcIPChecksum+0x6c>
{
   1a2be:	b430      	push	{r4, r5}
   1a2c0:	4603      	mov	r3, r0
	sum.dw = (uint32_t)seed;
   1a2c2:	4610      	mov	r0, r2
    if ((unsigned int)buffer % 2)
   1a2c4:	f013 0501 	ands.w	r5, r3, #1
   1a2c8:	d007      	beq.n	1a2da <TCPIP_Helper_CalcIPChecksum+0x1e>
        sum.w[0] += (*(uint8_t *)buffer) << 8;
   1a2ca:	f813 4b01 	ldrb.w	r4, [r3], #1
   1a2ce:	eb02 2204 	add.w	r2, r2, r4, lsl #8
   1a2d2:	f362 000f 	bfi	r0, r2, #0, #16
        count--;
   1a2d6:	3901      	subs	r1, #1
   1a2d8:	b289      	uxth	r1, r1
	i = count >> 1;
   1a2da:	084a      	lsrs	r2, r1, #1
	while(i--)
   1a2dc:	1e54      	subs	r4, r2, #1
   1a2de:	b2a4      	uxth	r4, r4
   1a2e0:	b1ca      	cbz	r2, 1a316 <TCPIP_Helper_CalcIPChecksum+0x5a>
   1a2e2:	3401      	adds	r4, #1
   1a2e4:	eb03 0444 	add.w	r4, r3, r4, lsl #1
		sum.dw += (uint32_t)*val++;
   1a2e8:	f833 2b02 	ldrh.w	r2, [r3], #2
   1a2ec:	4410      	add	r0, r2
	while(i--)
   1a2ee:	42a3      	cmp	r3, r4
   1a2f0:	d1fa      	bne.n	1a2e8 <TCPIP_Helper_CalcIPChecksum+0x2c>
	if(count & 0x1)
   1a2f2:	f011 0f01 	tst.w	r1, #1
		sum.dw += (uint32_t)*(uint8_t*)val;
   1a2f6:	bf1c      	itt	ne
   1a2f8:	7823      	ldrbne	r3, [r4, #0]
   1a2fa:	18c0      	addne	r0, r0, r3
	sum.dw = (uint32_t)sum.w[0] + (uint32_t)sum.w[1];
   1a2fc:	0c03      	lsrs	r3, r0, #16
   1a2fe:	fa13 f080 	uxtah	r0, r3, r0
	sum.w[0] += sum.w[1];
   1a302:	eb00 4310 	add.w	r3, r0, r0, lsr #16
   1a306:	b29b      	uxth	r3, r3
    if ((unsigned int)buffer % 2)
   1a308:	b93d      	cbnz	r5, 1a31a <TCPIP_Helper_CalcIPChecksum+0x5e>
	sum.w[0] += sum.w[1];
   1a30a:	f363 000f 	bfi	r0, r3, #0, #16
	return ~sum.w[0];
   1a30e:	43c0      	mvns	r0, r0
   1a310:	b280      	uxth	r0, r0
}
   1a312:	bc30      	pop	{r4, r5}
   1a314:	4770      	bx	lr
	while(i--)
   1a316:	461c      	mov	r4, r3
   1a318:	e7eb      	b.n	1a2f2 <TCPIP_Helper_CalcIPChecksum+0x36>
        sum.w[0] = ((uint16_t)sum.b[0] << 8 ) | (uint16_t)sum.b[1];
   1a31a:	b2da      	uxtb	r2, r3
   1a31c:	0a1b      	lsrs	r3, r3, #8
   1a31e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1a322:	f363 000f 	bfi	r0, r3, #0, #16
   1a326:	e7f2      	b.n	1a30e <TCPIP_Helper_CalcIPChecksum+0x52>
        return 0;
   1a328:	2000      	movs	r0, #0
}
   1a32a:	4770      	bx	lr

Disassembly of section .text.xQueueGenericReset%456:

0001a32c <xQueueGenericReset>:
{
   1a32c:	b538      	push	{r3, r4, r5, lr}
   1a32e:	4604      	mov	r4, r0
   1a330:	460d      	mov	r5, r1
	taskENTER_CRITICAL();
   1a332:	f006 fbed 	bl	20b10 <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
   1a336:	6822      	ldr	r2, [r4, #0]
   1a338:	6c21      	ldr	r1, [r4, #64]	; 0x40
   1a33a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1a33c:	fb03 f301 	mul.w	r3, r3, r1
   1a340:	18d0      	adds	r0, r2, r3
   1a342:	60a0      	str	r0, [r4, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
   1a344:	2000      	movs	r0, #0
   1a346:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
   1a348:	6062      	str	r2, [r4, #4]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
   1a34a:	1a5b      	subs	r3, r3, r1
   1a34c:	4413      	add	r3, r2
   1a34e:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
   1a350:	23ff      	movs	r3, #255	; 0xff
   1a352:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
   1a356:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if( xNewQueue == pdFALSE )
   1a35a:	b9a5      	cbnz	r5, 1a386 <xQueueGenericReset+0x5a>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1a35c:	6923      	ldr	r3, [r4, #16]
   1a35e:	b91b      	cbnz	r3, 1a368 <xQueueGenericReset+0x3c>
	taskEXIT_CRITICAL();
   1a360:	f007 faae 	bl	218c0 <vPortExitCritical>
}
   1a364:	2001      	movs	r0, #1
   1a366:	bd38      	pop	{r3, r4, r5, pc}
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   1a368:	f104 0010 	add.w	r0, r4, #16
   1a36c:	f7ff fda6 	bl	19ebc <xTaskRemoveFromEventList>
   1a370:	2800      	cmp	r0, #0
   1a372:	d0f5      	beq.n	1a360 <xQueueGenericReset+0x34>
					queueYIELD_IF_USING_PREEMPTION();
   1a374:	4b08      	ldr	r3, [pc, #32]	; (1a398 <xQueueGenericReset+0x6c>)
   1a376:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1a37a:	601a      	str	r2, [r3, #0]
   1a37c:	f3bf 8f4f 	dsb	sy
   1a380:	f3bf 8f6f 	isb	sy
   1a384:	e7ec      	b.n	1a360 <xQueueGenericReset+0x34>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   1a386:	f104 0010 	add.w	r0, r4, #16
   1a38a:	f007 f9c1 	bl	21710 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   1a38e:	f104 0024 	add.w	r0, r4, #36	; 0x24
   1a392:	f007 f9bd 	bl	21710 <vListInitialise>
   1a396:	e7e3      	b.n	1a360 <xQueueGenericReset+0x34>
   1a398:	e000ed04 	.word	0xe000ed04

Disassembly of section .text.prvIdleTask%457:

0001a39c <prvIdleTask>:
{
   1a39c:	b580      	push	{r7, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   1a39e:	4c16      	ldr	r4, [pc, #88]	; (1a3f8 <prvIdleTask+0x5c>)
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   1a3a0:	4f16      	ldr	r7, [pc, #88]	; (1a3fc <prvIdleTask+0x60>)
				--uxCurrentNumberOfTasks;
   1a3a2:	4e17      	ldr	r6, [pc, #92]	; (1a400 <prvIdleTask+0x64>)
				taskYIELD();
   1a3a4:	f8df 8060 	ldr.w	r8, [pc, #96]	; 1a408 <prvIdleTask+0x6c>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   1a3a8:	6823      	ldr	r3, [r4, #0]
   1a3aa:	b1bb      	cbz	r3, 1a3dc <prvIdleTask+0x40>
			taskENTER_CRITICAL();
   1a3ac:	f006 fbb0 	bl	20b10 <vPortEnterCritical>
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   1a3b0:	68fb      	ldr	r3, [r7, #12]
   1a3b2:	68dd      	ldr	r5, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   1a3b4:	1d28      	adds	r0, r5, #4
   1a3b6:	f006 f87d 	bl	204b4 <uxListRemove>
				--uxCurrentNumberOfTasks;
   1a3ba:	6833      	ldr	r3, [r6, #0]
   1a3bc:	3b01      	subs	r3, #1
   1a3be:	6033      	str	r3, [r6, #0]
				--uxDeletedTasksWaitingCleanUp;
   1a3c0:	6823      	ldr	r3, [r4, #0]
   1a3c2:	3b01      	subs	r3, #1
   1a3c4:	6023      	str	r3, [r4, #0]
			taskEXIT_CRITICAL();
   1a3c6:	f007 fa7b 	bl	218c0 <vPortExitCritical>
			vPortFree( pxTCB->pxStack );
   1a3ca:	6b28      	ldr	r0, [r5, #48]	; 0x30
   1a3cc:	f000 fed7 	bl	1b17e <vPortFree>
			vPortFree( pxTCB );
   1a3d0:	4628      	mov	r0, r5
   1a3d2:	f000 fed4 	bl	1b17e <vPortFree>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   1a3d6:	6823      	ldr	r3, [r4, #0]
   1a3d8:	2b00      	cmp	r3, #0
   1a3da:	d1e7      	bne.n	1a3ac <prvIdleTask+0x10>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   1a3dc:	4b09      	ldr	r3, [pc, #36]	; (1a404 <prvIdleTask+0x68>)
   1a3de:	681b      	ldr	r3, [r3, #0]
   1a3e0:	2b01      	cmp	r3, #1
   1a3e2:	d9e1      	bls.n	1a3a8 <prvIdleTask+0xc>
				taskYIELD();
   1a3e4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   1a3e8:	f8c8 3000 	str.w	r3, [r8]
   1a3ec:	f3bf 8f4f 	dsb	sy
   1a3f0:	f3bf 8f6f 	isb	sy
   1a3f4:	e7d8      	b.n	1a3a8 <prvIdleTask+0xc>
   1a3f6:	bf00      	nop
   1a3f8:	2000e6b4 	.word	0x2000e6b4
   1a3fc:	2000e4dc 	.word	0x2000e4dc
   1a400:	2000e6b0 	.word	0x2000e6b0
   1a404:	2000e080 	.word	0x2000e080
   1a408:	e000ed04 	.word	0xe000ed04

Disassembly of section .text.DRV_PIC32CGMAC_LibMACOpen%458:

0001a40c <DRV_PIC32CGMAC_LibMACOpen>:
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_TXEN_Msk;
   1a40c:	4b19      	ldr	r3, [pc, #100]	; (1a474 <DRV_PIC32CGMAC_LibMACOpen+0x68>)
   1a40e:	6818      	ldr	r0, [r3, #0]
   1a410:	f020 0008 	bic.w	r0, r0, #8
   1a414:	6018      	str	r0, [r3, #0]
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_RXEN_Msk;
   1a416:	6818      	ldr	r0, [r3, #0]
   1a418:	f020 0004 	bic.w	r0, r0, #4
   1a41c:	6018      	str	r0, [r3, #0]
	ncfgr = GMAC_REGS->GMAC_NCFGR;
   1a41e:	685b      	ldr	r3, [r3, #4]
	if(oFlags & TCPIP_ETH_OPEN_FDUPLEX)
   1a420:	f011 0f02 	tst.w	r1, #2
		ncfgr |= GMAC_NCFGR_FD_Msk ;
   1a424:	bf14      	ite	ne
   1a426:	f043 0302 	orrne.w	r3, r3, #2
		ncfgr &= ~GMAC_NCFGR_FD_Msk ;	
   1a42a:	f023 0302 	biceq.w	r3, r3, #2
	if(oFlags & TCPIP_ETH_OPEN_100)
   1a42e:	f011 0f08 	tst.w	r1, #8
		ncfgr |= GMAC_NCFGR_SPD_Msk ;
   1a432:	bf14      	ite	ne
   1a434:	f043 0301 	orrne.w	r3, r3, #1
		ncfgr &= ~GMAC_NCFGR_SPD_Msk ;
   1a438:	f023 0301 	biceq.w	r3, r3, #1
	if(pauseType & TCPIP_ETH_PAUSE_TYPE_EN_RX)
   1a43c:	f012 0f08 	tst.w	r2, #8
		ncfgr |= GMAC_NCFGR_PEN_Msk ;
   1a440:	bf14      	ite	ne
   1a442:	f443 5300 	orrne.w	r3, r3, #8192	; 0x2000
		ncfgr &= ~GMAC_NCFGR_PEN_Msk ;		
   1a446:	f423 5300 	biceq.w	r3, r3, #8192	; 0x2000
	GMAC_REGS->GMAC_NCFGR = ncfgr;
   1a44a:	4a0a      	ldr	r2, [pc, #40]	; (1a474 <DRV_PIC32CGMAC_LibMACOpen+0x68>)
   1a44c:	6053      	str	r3, [r2, #4]
	if(oFlags & TCPIP_ETH_OPEN_RMII)	
   1a44e:	f411 6f80 	tst.w	r1, #1024	; 0x400
        GMAC_REGS->GMAC_UR = GMAC_UR_MII(0);
   1a452:	bf19      	ittee	ne
   1a454:	4613      	movne	r3, r2
   1a456:	2200      	movne	r2, #0
        GMAC_REGS->GMAC_UR = GMAC_UR_MII(1);
   1a458:	4b06      	ldreq	r3, [pc, #24]	; (1a474 <DRV_PIC32CGMAC_LibMACOpen+0x68>)
   1a45a:	2201      	moveq	r2, #1
   1a45c:	60da      	str	r2, [r3, #12]
	GMAC_REGS->GMAC_NCR |= GMAC_NCR_RXEN_Msk;
   1a45e:	4b05      	ldr	r3, [pc, #20]	; (1a474 <DRV_PIC32CGMAC_LibMACOpen+0x68>)
   1a460:	681a      	ldr	r2, [r3, #0]
   1a462:	f042 0204 	orr.w	r2, r2, #4
   1a466:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_NCR |= GMAC_NCR_TXEN_Msk;
   1a468:	681a      	ldr	r2, [r3, #0]
   1a46a:	f042 0208 	orr.w	r2, r2, #8
   1a46e:	601a      	str	r2, [r3, #0]
}
   1a470:	4770      	bx	lr
   1a472:	bf00      	nop
   1a474:	42000800 	.word	0x42000800

Disassembly of section .text._AllocateRxPacket%459:

0001a478 <_AllocateRxPacket>:
{
	TCPIP_MAC_PACKET* pRxPkt;
    DRV_PIC32CGMAC_RESULT gmacAllocRes = DRV_PIC32CGMAC_RES_OK;
	uint8_t rxbuff_idx;
	
	for(rxbuff_idx=0; rxbuff_idx < buffer_count; rxbuff_idx++)
   1a478:	b371      	cbz	r1, 1a4d8 <_AllocateRxPacket+0x60>
{
   1a47a:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1a47e:	4689      	mov	r9, r1
   1a480:	4698      	mov	r8, r3
   1a482:	4606      	mov	r6, r0
        if(sticky_flag)
        {
            pRxPkt->pDSeg->segFlags |=  TCPIP_MAC_SEG_FLAG_RX_STICKY;
        }
        
		DRV_PIC32CGMAC_SingleListTailAdd(&pMACDrv->sGmacData.gmac_queue[queue_idx]._RxQueue, (DRV_PIC32CGMAC_SGL_LIST_NODE*)pRxPkt); 
   1a484:	272c      	movs	r7, #44	; 0x2c
   1a486:	fb07 0702 	mla	r7, r7, r2, r0
   1a48a:	3794      	adds	r7, #148	; 0x94
	for(rxbuff_idx=0; rxbuff_idx < buffer_count; rxbuff_idx++)
   1a48c:	2400      	movs	r4, #0
		pRxPkt = (*pMACDrv->sGmacData.pktAllocF)(sizeof(*pRxPkt), pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].rxBufferSize   - sizeof(TCPIP_MAC_ETHERNET_HEADER), 0);
   1a48e:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
   1a492:	eb00 0542 	add.w	r5, r0, r2, lsl #1
   1a496:	46a3      	mov	fp, r4
   1a498:	f04f 0a34 	mov.w	sl, #52	; 0x34
   1a49c:	e007      	b.n	1a4ae <_AllocateRxPacket+0x36>
		DRV_PIC32CGMAC_SingleListTailAdd(&pMACDrv->sGmacData.gmac_queue[queue_idx]._RxQueue, (DRV_PIC32CGMAC_SGL_LIST_NODE*)pRxPkt); 
   1a49e:	4638      	mov	r0, r7
   1a4a0:	f006 fe16 	bl	210d0 <DRV_PIC32CGMAC_SingleListTailAdd>
	for(rxbuff_idx=0; rxbuff_idx < buffer_count; rxbuff_idx++)
   1a4a4:	3401      	adds	r4, #1
   1a4a6:	b2e4      	uxtb	r4, r4
   1a4a8:	b2a3      	uxth	r3, r4
   1a4aa:	454b      	cmp	r3, r9
   1a4ac:	d212      	bcs.n	1a4d4 <_AllocateRxPacket+0x5c>
		pRxPkt = (*pMACDrv->sGmacData.pktAllocF)(sizeof(*pRxPkt), pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].rxBufferSize   - sizeof(TCPIP_MAC_ETHERNET_HEADER), 0);
   1a4ae:	f8b5 10cc 	ldrh.w	r1, [r5, #204]	; 0xcc
   1a4b2:	390e      	subs	r1, #14
   1a4b4:	6a73      	ldr	r3, [r6, #36]	; 0x24
   1a4b6:	465a      	mov	r2, fp
   1a4b8:	b289      	uxth	r1, r1
   1a4ba:	4650      	mov	r0, sl
   1a4bc:	4798      	blx	r3
		if(pRxPkt == NULL)
   1a4be:	4601      	mov	r1, r0
   1a4c0:	b160      	cbz	r0, 1a4dc <_AllocateRxPacket+0x64>
        if(sticky_flag)
   1a4c2:	f1b8 0f00 	cmp.w	r8, #0
   1a4c6:	d0ea      	beq.n	1a49e <_AllocateRxPacket+0x26>
            pRxPkt->pDSeg->segFlags |=  TCPIP_MAC_SEG_FLAG_RX_STICKY;
   1a4c8:	6902      	ldr	r2, [r0, #16]
   1a4ca:	8a13      	ldrh	r3, [r2, #16]
   1a4cc:	f043 0304 	orr.w	r3, r3, #4
   1a4d0:	8213      	strh	r3, [r2, #16]
   1a4d2:	e7e4      	b.n	1a49e <_AllocateRxPacket+0x26>
    DRV_PIC32CGMAC_RESULT gmacAllocRes = DRV_PIC32CGMAC_RES_OK;
   1a4d4:	2000      	movs	r0, #0
   1a4d6:	e003      	b.n	1a4e0 <_AllocateRxPacket+0x68>
   1a4d8:	2000      	movs	r0, #0
    }
	return gmacAllocRes;
}	
   1a4da:	4770      	bx	lr
			gmacAllocRes = DRV_PIC32CGMAC_RES_OUT_OF_MEMORY;
   1a4dc:	f04f 30ff 	mov.w	r0, #4294967295
}	
   1a4e0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

Disassembly of section .text.TCPIP_ICMP_Initialize%460:

0001a4e4 <TCPIP_ICMP_Initialize>:
{
   1a4e4:	b508      	push	{r3, lr}
    if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_UP)
   1a4e6:	7f03      	ldrb	r3, [r0, #28]
   1a4e8:	2b03      	cmp	r3, #3
   1a4ea:	d021      	beq.n	1a530 <TCPIP_ICMP_Initialize+0x4c>
    if(icmpInitCount == 0)
   1a4ec:	4b11      	ldr	r3, [pc, #68]	; (1a534 <TCPIP_ICMP_Initialize+0x50>)
   1a4ee:	681b      	ldr	r3, [r3, #0]
   1a4f0:	b12b      	cbz	r3, 1a4fe <TCPIP_ICMP_Initialize+0x1a>
    icmpInitCount++;
   1a4f2:	4a10      	ldr	r2, [pc, #64]	; (1a534 <TCPIP_ICMP_Initialize+0x50>)
   1a4f4:	6813      	ldr	r3, [r2, #0]
   1a4f6:	3301      	adds	r3, #1
   1a4f8:	6013      	str	r3, [r2, #0]
    return true;
   1a4fa:	2001      	movs	r0, #1
}
   1a4fc:	bd08      	pop	{r3, pc}
        icmpMemH = stackCtrl->memH;
   1a4fe:	68c2      	ldr	r2, [r0, #12]
   1a500:	4b0d      	ldr	r3, [pc, #52]	; (1a538 <TCPIP_ICMP_Initialize+0x54>)
   1a502:	601a      	str	r2, [r3, #0]
            iniRes = (signalHandle =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_ICMP_Task, TCPIP_ICMP_TASK_TICK_RATE)) != 0;
   1a504:	2221      	movs	r2, #33	; 0x21
   1a506:	490d      	ldr	r1, [pc, #52]	; (1a53c <TCPIP_ICMP_Initialize+0x58>)
   1a508:	2006      	movs	r0, #6
   1a50a:	f002 fbc1 	bl	1cc90 <_TCPIPStackSignalHandlerRegister>
   1a50e:	4b0c      	ldr	r3, [pc, #48]	; (1a540 <TCPIP_ICMP_Initialize+0x5c>)
   1a510:	6018      	str	r0, [r3, #0]
            if(iniRes == false)
   1a512:	b148      	cbz	r0, 1a528 <TCPIP_ICMP_Initialize+0x44>
            pIcmpEchoRequest = 0;        // one and only request (for now)
   1a514:	2300      	movs	r3, #0
   1a516:	4a0b      	ldr	r2, [pc, #44]	; (1a544 <TCPIP_ICMP_Initialize+0x60>)
   1a518:	6013      	str	r3, [r2, #0]
            icmpEchoTmo = 0;
   1a51a:	4a0b      	ldr	r2, [pc, #44]	; (1a548 <TCPIP_ICMP_Initialize+0x64>)
   1a51c:	6013      	str	r3, [r2, #0]
            iniRes = TCPIP_Notification_Initialize(&icmpRegisteredUsers);
   1a51e:	480b      	ldr	r0, [pc, #44]	; (1a54c <TCPIP_ICMP_Initialize+0x68>)
   1a520:	f007 fda7 	bl	22072 <TCPIP_Notification_Initialize>
        if(iniRes == false)
   1a524:	2800      	cmp	r0, #0
   1a526:	d1e4      	bne.n	1a4f2 <TCPIP_ICMP_Initialize+0xe>
            TCPIP_ICMP_Cleanup();
   1a528:	f004 fcfc 	bl	1ef24 <TCPIP_ICMP_Cleanup>
            return false;
   1a52c:	2000      	movs	r0, #0
   1a52e:	e7e5      	b.n	1a4fc <TCPIP_ICMP_Initialize+0x18>
        return true;
   1a530:	2001      	movs	r0, #1
   1a532:	e7e3      	b.n	1a4fc <TCPIP_ICMP_Initialize+0x18>
   1a534:	2000e584 	.word	0x2000e584
   1a538:	2000e588 	.word	0x2000e588
   1a53c:	0000ece9 	.word	0x0000ece9
   1a540:	2000e590 	.word	0x2000e590
   1a544:	2000e58c 	.word	0x2000e58c
   1a548:	2000e580 	.word	0x2000e580
   1a54c:	2000e414 	.word	0x2000e414

Disassembly of section .text._TcpCleanup%461:

0001a550 <_TcpCleanup>:
{
   1a550:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(TCBStubs)
   1a552:	4b16      	ldr	r3, [pc, #88]	; (1a5ac <_TcpCleanup+0x5c>)
   1a554:	681b      	ldr	r3, [r3, #0]
   1a556:	b1ab      	cbz	r3, 1a584 <_TcpCleanup+0x34>
        for(ix = 0; ix < TcpSockets; ix++)
   1a558:	4b15      	ldr	r3, [pc, #84]	; (1a5b0 <_TcpCleanup+0x60>)
   1a55a:	681b      	ldr	r3, [r3, #0]
   1a55c:	b193      	cbz	r3, 1a584 <_TcpCleanup+0x34>
   1a55e:	2400      	movs	r4, #0
            pSkt = TCBStubs[ix]; 
   1a560:	4e12      	ldr	r6, [pc, #72]	; (1a5ac <_TcpCleanup+0x5c>)
                _TcpAbort(pSkt, _TCP_ABORT_FLAG_SHUTDOWN, 0);
   1a562:	4627      	mov	r7, r4
        for(ix = 0; ix < TcpSockets; ix++)
   1a564:	4d12      	ldr	r5, [pc, #72]	; (1a5b0 <_TcpCleanup+0x60>)
   1a566:	e007      	b.n	1a578 <_TcpCleanup+0x28>
                _TcpAbort(pSkt, _TCP_ABORT_FLAG_SHUTDOWN, 0);
   1a568:	463a      	mov	r2, r7
   1a56a:	2102      	movs	r1, #2
   1a56c:	f001 fdba 	bl	1c0e4 <_TcpAbort>
        for(ix = 0; ix < TcpSockets; ix++)
   1a570:	3401      	adds	r4, #1
   1a572:	682b      	ldr	r3, [r5, #0]
   1a574:	42a3      	cmp	r3, r4
   1a576:	d905      	bls.n	1a584 <_TcpCleanup+0x34>
            pSkt = TCBStubs[ix]; 
   1a578:	6833      	ldr	r3, [r6, #0]
   1a57a:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
            if(pSkt) 
   1a57e:	2800      	cmp	r0, #0
   1a580:	d1f2      	bne.n	1a568 <_TcpCleanup+0x18>
   1a582:	e7f5      	b.n	1a570 <_TcpCleanup+0x20>
    TCPIP_HEAP_Free(tcpHeapH, TCBStubs);
   1a584:	4b0b      	ldr	r3, [pc, #44]	; (1a5b4 <_TcpCleanup+0x64>)
   1a586:	6818      	ldr	r0, [r3, #0]
   1a588:	4c08      	ldr	r4, [pc, #32]	; (1a5ac <_TcpCleanup+0x5c>)
   1a58a:	68c3      	ldr	r3, [r0, #12]
   1a58c:	6821      	ldr	r1, [r4, #0]
   1a58e:	4798      	blx	r3
    TCBStubs = 0;
   1a590:	2300      	movs	r3, #0
   1a592:	6023      	str	r3, [r4, #0]
    TcpSockets = 0;
   1a594:	4a06      	ldr	r2, [pc, #24]	; (1a5b0 <_TcpCleanup+0x60>)
   1a596:	6013      	str	r3, [r2, #0]
    if(tcpSignalHandle)
   1a598:	4b07      	ldr	r3, [pc, #28]	; (1a5b8 <_TcpCleanup+0x68>)
   1a59a:	6818      	ldr	r0, [r3, #0]
   1a59c:	b120      	cbz	r0, 1a5a8 <_TcpCleanup+0x58>
        _TCPIPStackSignalHandlerDeregister(tcpSignalHandle);
   1a59e:	f007 fb40 	bl	21c22 <_TCPIPStackSignalHandlerDeregister>
        tcpSignalHandle = 0;
   1a5a2:	4b05      	ldr	r3, [pc, #20]	; (1a5b8 <_TcpCleanup+0x68>)
   1a5a4:	2200      	movs	r2, #0
   1a5a6:	601a      	str	r2, [r3, #0]
}
   1a5a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1a5aa:	bf00      	nop
   1a5ac:	2000e594 	.word	0x2000e594
   1a5b0:	2000e598 	.word	0x2000e598
   1a5b4:	2000e59c 	.word	0x2000e59c
   1a5b8:	2000e5ac 	.word	0x2000e5ac

Disassembly of section .text._Command_BIOSNameSet%462:

0001a5bc <_Command_BIOSNameSet>:
{
   1a5bc:	b570      	push	{r4, r5, r6, lr}
   1a5be:	4604      	mov	r4, r0
    const void* cmdIoParam = pCmdIO->cmdIoParam;
   1a5c0:	6845      	ldr	r5, [r0, #4]
    if (argc != 3)
   1a5c2:	2903      	cmp	r1, #3
   1a5c4:	d00e      	beq.n	1a5e4 <_Command_BIOSNameSet+0x28>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage: setbios <interface> <x.x.x.x> \r\n");
   1a5c6:	4e15      	ldr	r6, [pc, #84]	; (1a61c <_Command_BIOSNameSet+0x60>)
   1a5c8:	6803      	ldr	r3, [r0, #0]
   1a5ca:	681b      	ldr	r3, [r3, #0]
   1a5cc:	f606 41c4 	addw	r1, r6, #3268	; 0xcc4
   1a5d0:	4628      	mov	r0, r5
   1a5d2:	4798      	blx	r3
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Ex: setbios PIC32INT MCHPBOARD_29 \r\n");
   1a5d4:	6823      	ldr	r3, [r4, #0]
   1a5d6:	681b      	ldr	r3, [r3, #0]
   1a5d8:	f606 41ec 	addw	r1, r6, #3308	; 0xcec
   1a5dc:	4628      	mov	r0, r5
   1a5de:	4798      	blx	r3
        return false;
   1a5e0:	2000      	movs	r0, #0
}
   1a5e2:	bd70      	pop	{r4, r5, r6, pc}
   1a5e4:	4616      	mov	r6, r2
    netH = TCPIP_STACK_NetHandleGet(argv[1]);
   1a5e6:	6850      	ldr	r0, [r2, #4]
   1a5e8:	f003 f9b4 	bl	1d954 <TCPIP_STACK_NetHandleGet>
    if (netH == 0)
   1a5ec:	b170      	cbz	r0, 1a60c <_Command_BIOSNameSet+0x50>
    if(TCPIP_STACK_NetBiosNameSet(netH, argv[2]))
   1a5ee:	68b1      	ldr	r1, [r6, #8]
   1a5f0:	f004 fc06 	bl	1ee00 <TCPIP_STACK_NetBiosNameSet>
        msg = "Set BIOS Name failed\r\n";
   1a5f4:	2800      	cmp	r0, #0
   1a5f6:	490a      	ldr	r1, [pc, #40]	; (1a620 <_Command_BIOSNameSet+0x64>)
   1a5f8:	f101 0314 	add.w	r3, r1, #20
   1a5fc:	bf08      	it	eq
   1a5fe:	4619      	moveq	r1, r3
    (*pCmdIO->pCmdApi->msg)(cmdIoParam, msg);
   1a600:	6823      	ldr	r3, [r4, #0]
   1a602:	681b      	ldr	r3, [r3, #0]
   1a604:	4628      	mov	r0, r5
   1a606:	4798      	blx	r3
    return true;
   1a608:	2001      	movs	r0, #1
   1a60a:	e7ea      	b.n	1a5e2 <_Command_BIOSNameSet+0x26>
        (*pCmdIO->pCmdApi->msg)(cmdIoParam, "Unknown interface specified \r\n");
   1a60c:	6823      	ldr	r3, [r4, #0]
   1a60e:	681b      	ldr	r3, [r3, #0]
   1a610:	4904      	ldr	r1, [pc, #16]	; (1a624 <_Command_BIOSNameSet+0x68>)
   1a612:	4628      	mov	r0, r5
   1a614:	4798      	blx	r3
        return false;
   1a616:	2000      	movs	r0, #0
   1a618:	e7e3      	b.n	1a5e2 <_Command_BIOSNameSet+0x26>
   1a61a:	bf00      	nop
   1a61c:	0000028c 	.word	0x0000028c
   1a620:	00000f24 	.word	0x00000f24
   1a624:	00000da8 	.word	0x00000da8

Disassembly of section .text.TCPIP_DNS_Disable%463:

0001a628 <TCPIP_DNS_Disable>:
    }
    return true;
}

bool TCPIP_DNS_Disable(TCPIP_NET_HANDLE hNet, bool clearCache)
{
   1a628:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    TCPIP_NET_IF* pNetIf = _TCPIPStackHandleToNet(hNet);
    TCPIP_DNS_DCPT *pDnsDcpt;

    pDnsDcpt = pgDnsDcpt;
   1a62a:	4b19      	ldr	r3, [pc, #100]	; (1a690 <TCPIP_DNS_Disable+0x68>)
   1a62c:	681c      	ldr	r4, [r3, #0]
    if(pDnsDcpt == 0 || pNetIf == 0)
   1a62e:	b33c      	cbz	r4, 1a680 <TCPIP_DNS_Disable+0x58>
   1a630:	b340      	cbz	r0, 1a684 <TCPIP_DNS_Disable+0x5c>
    {
        return false;
    }

    pNetIf->Flags.bIsDnsClientEnabled = false;
   1a632:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   1a636:	f36f 03c3 	bfc	r3, #3, #1
   1a63a:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
    if(pDnsDcpt->strictNet == pNetIf)
   1a63e:	6863      	ldr	r3, [r4, #4]
   1a640:	4283      	cmp	r3, r0
    {
        pDnsDcpt->strictNet = 0;
   1a642:	bf04      	itt	eq
   1a644:	2300      	moveq	r3, #0
   1a646:	6063      	streq	r3, [r4, #4]
    }
    if(pDnsDcpt->prefNet == pNetIf)
   1a648:	68a3      	ldr	r3, [r4, #8]
   1a64a:	4283      	cmp	r3, r0
    {
        pDnsDcpt->prefNet = 0;
   1a64c:	bf04      	itt	eq
   1a64e:	2300      	moveq	r3, #0
   1a650:	60a3      	streq	r3, [r4, #8]
    }

    if(clearCache)
   1a652:	b909      	cbnz	r1, 1a658 <TCPIP_DNS_Disable+0x30>
    {
        _DNS_CleanCache(pDnsDcpt);
    }

    return true;    
   1a654:	2001      	movs	r0, #1
}
   1a656:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((pOh = pDnsDcpt->hashDcpt) != 0)
   1a658:	6827      	ldr	r7, [r4, #0]
   1a65a:	b1af      	cbz	r7, 1a688 <TCPIP_DNS_Disable+0x60>
        for(bktIx = 0; bktIx < pOh->hEntries; bktIx++)
   1a65c:	68fb      	ldr	r3, [r7, #12]
   1a65e:	b1ab      	cbz	r3, 1a68c <TCPIP_DNS_Disable+0x64>
   1a660:	460d      	mov	r5, r1
   1a662:	2600      	movs	r6, #0
            pE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryGet(pOh, bktIx);
   1a664:	4631      	mov	r1, r6
   1a666:	4638      	mov	r0, r7
   1a668:	f007 f977 	bl	2195a <TCPIP_OAHASH_EntryGet>
            _DNS_CleanCacheEntry(pDnsDcpt, pE);
   1a66c:	4601      	mov	r1, r0
   1a66e:	4620      	mov	r0, r4
   1a670:	f004 ff67 	bl	1f542 <_DNS_CleanCacheEntry>
        for(bktIx = 0; bktIx < pOh->hEntries; bktIx++)
   1a674:	3601      	adds	r6, #1
   1a676:	68fb      	ldr	r3, [r7, #12]
   1a678:	429e      	cmp	r6, r3
   1a67a:	d3f3      	bcc.n	1a664 <TCPIP_DNS_Disable+0x3c>
    return true;    
   1a67c:	4628      	mov	r0, r5
   1a67e:	e7ea      	b.n	1a656 <TCPIP_DNS_Disable+0x2e>
        return false;
   1a680:	2000      	movs	r0, #0
   1a682:	e7e8      	b.n	1a656 <TCPIP_DNS_Disable+0x2e>
   1a684:	2000      	movs	r0, #0
   1a686:	e7e6      	b.n	1a656 <TCPIP_DNS_Disable+0x2e>
    return true;    
   1a688:	4608      	mov	r0, r1
   1a68a:	e7e4      	b.n	1a656 <TCPIP_DNS_Disable+0x2e>
   1a68c:	4608      	mov	r0, r1
   1a68e:	e7e2      	b.n	1a656 <TCPIP_DNS_Disable+0x2e>
   1a690:	2000e62c 	.word	0x2000e62c

Disassembly of section .rodata.TCPIP_STACK_MODULE_ENTRY_TBL%464:

0001a694 <TCPIP_STACK_MODULE_ENTRY_TBL>:
   1a694:	00000002 0000eecd 0001cb71 00000003     ........q.......
   1a6a4:	00012675 000160a5 00000006 0001a4e5     u&...`..........
   1a6b4:	0001fc8d 00000009 00013b5d 00011e11     ........];......
   1a6c4:	0000000a 00011901 00014351 0000000c     ........QC......
   1a6d4:	00010221 0001d895 0000000f 0000e4f9     !...............
   1a6e4:	0001b301 0000001f 00016c11 0001e4ed     .........l......
   1a6f4:	00000020 0001644d 0001bd9d               ...Md......

Disassembly of section .text.SYS_CMD_ADDGRP%465:

0001a700 <SYS_CMD_ADDGRP>:
{
   1a700:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1a704:	4605      	mov	r5, r0
   1a706:	4688      	mov	r8, r1
   1a708:	4616      	mov	r6, r2
   1a70a:	461f      	mov	r7, r3
    for (i=0; i<MAX_CMD_GROUP; i++)
   1a70c:	4b16      	ldr	r3, [pc, #88]	; (1a768 <SYS_CMD_ADDGRP+0x68>)
    int i, groupIx = -1, emptyIx = -1;
   1a70e:	f04f 39ff 	mov.w	r9, #4294967295
    for (i=0; i<MAX_CMD_GROUP; i++)
   1a712:	2400      	movs	r4, #0
   1a714:	e004      	b.n	1a720 <SYS_CMD_ADDGRP+0x20>
   1a716:	46a1      	mov	r9, r4
   1a718:	3401      	adds	r4, #1
   1a71a:	3310      	adds	r3, #16
   1a71c:	2c08      	cmp	r4, #8
   1a71e:	d01a      	beq.n	1a756 <SYS_CMD_ADDGRP+0x56>
        if(_usrCmdTbl[i].pCmd == 0)
   1a720:	685a      	ldr	r2, [r3, #4]
   1a722:	2a00      	cmp	r2, #0
   1a724:	d0f7      	beq.n	1a716 <SYS_CMD_ADDGRP+0x16>
        else if(_usrCmdTbl[i].pCmd == pCmdTbl)
   1a726:	42aa      	cmp	r2, r5
   1a728:	d1f6      	bne.n	1a718 <SYS_CMD_ADDGRP+0x18>
            if(strcmp(groupName, _usrCmdTbl[i].cmdGroupName) != 0)
   1a72a:	4b0f      	ldr	r3, [pc, #60]	; (1a768 <SYS_CMD_ADDGRP+0x68>)
   1a72c:	eb03 1304 	add.w	r3, r3, r4, lsl #4
   1a730:	6899      	ldr	r1, [r3, #8]
   1a732:	4630      	mov	r0, r6
   1a734:	f007 f8e2 	bl	218fc <strcmp>
   1a738:	b990      	cbnz	r0, 1a760 <SYS_CMD_ADDGRP+0x60>
    if (groupIx != -1)
   1a73a:	f1b4 3fff 	cmp.w	r4, #4294967295
   1a73e:	d00a      	beq.n	1a756 <SYS_CMD_ADDGRP+0x56>
    _usrCmdTbl[insertIx].pCmd = pCmdTbl;
   1a740:	4a09      	ldr	r2, [pc, #36]	; (1a768 <SYS_CMD_ADDGRP+0x68>)
   1a742:	0124      	lsls	r4, r4, #4
   1a744:	1913      	adds	r3, r2, r4
   1a746:	605d      	str	r5, [r3, #4]
    _usrCmdTbl[insertIx].nCmds = nCmds;
   1a748:	f842 8004 	str.w	r8, [r2, r4]
    _usrCmdTbl[insertIx].cmdGroupName = groupName;
   1a74c:	609e      	str	r6, [r3, #8]
    _usrCmdTbl[insertIx].cmdMenuStr = menuStr;
   1a74e:	60df      	str	r7, [r3, #12]
    return true;
   1a750:	2001      	movs	r0, #1
}
   1a752:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    else if(emptyIx != -1)
   1a756:	f1b9 3fff 	cmp.w	r9, #4294967295
   1a75a:	d003      	beq.n	1a764 <SYS_CMD_ADDGRP+0x64>
   1a75c:	464c      	mov	r4, r9
   1a75e:	e7ef      	b.n	1a740 <SYS_CMD_ADDGRP+0x40>
                return false;
   1a760:	2000      	movs	r0, #0
   1a762:	e7f6      	b.n	1a752 <SYS_CMD_ADDGRP+0x52>
        return false;
   1a764:	2000      	movs	r0, #0
   1a766:	e7f4      	b.n	1a752 <SYS_CMD_ADDGRP+0x52>
   1a768:	2000df98 	.word	0x2000df98

Disassembly of section .text.SYS_CONSOLE_Print%466:

0001a76c <SYS_CONSOLE_Print>:
        return -1;
    }
}

void SYS_CONSOLE_Print(const SYS_CONSOLE_HANDLE handle, const char *format, ...)
{
   1a76c:	b40e      	push	{r1, r2, r3}
   1a76e:	b510      	push	{r4, lr}
   1a770:	b083      	sub	sp, #12
    size_t len = 0;
    va_list args = {0};
   1a772:	2300      	movs	r3, #0
   1a774:	9301      	str	r3, [sp, #4]
    SYS_CONSOLE_OBJECT_INSTANCE* pConsoleObj = SYS_CONSOLE_GET_INSTANCE(handle);
   1a776:	b960      	cbnz	r0, 1a792 <SYS_CONSOLE_Print+0x26>
    if (pConsoleObj == NULL)
    {
        return;
    }

    if ((pConsoleObj->status == SYS_STATUS_UNINITIALIZED) || (pConsoleObj->devDesc == NULL))
   1a778:	4b14      	ldr	r3, [pc, #80]	; (1a7cc <SYS_CONSOLE_Print+0x60>)
   1a77a:	f993 3000 	ldrsb.w	r3, [r3]
   1a77e:	b143      	cbz	r3, 1a792 <SYS_CONSOLE_Print+0x26>
   1a780:	4b12      	ldr	r3, [pc, #72]	; (1a7cc <SYS_CONSOLE_Print+0x60>)
   1a782:	685b      	ldr	r3, [r3, #4]
   1a784:	b12b      	cbz	r3, 1a792 <SYS_CONSOLE_Print+0x26>
    {
        return;
    }

    /* Must protect the common print buffer from multiple threads */
    if(OSAL_MUTEX_Lock(&consolePrintBufferMutex, OSAL_WAIT_FOREVER) == OSAL_RESULT_FALSE)
   1a786:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1a78a:	4811      	ldr	r0, [pc, #68]	; (1a7d0 <SYS_CONSOLE_Print+0x64>)
   1a78c:	f006 fa89 	bl	20ca2 <OSAL_MUTEX_Lock>
   1a790:	b920      	cbnz	r0, 1a79c <SYS_CONSOLE_Print+0x30>
        pConsoleObj->devDesc->write(pConsoleObj->devIndex, consolePrintBuffer, len);
    }

    /* Release mutex */
    OSAL_MUTEX_Unlock(&consolePrintBufferMutex);
}
   1a792:	b003      	add	sp, #12
   1a794:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1a798:	b003      	add	sp, #12
   1a79a:	4770      	bx	lr
    va_start( args, format );
   1a79c:	ab06      	add	r3, sp, #24
   1a79e:	9301      	str	r3, [sp, #4]
    len = vsnprintf(consolePrintBuffer, SYS_CONSOLE_PRINT_BUFFER_SIZE, format, args);
   1a7a0:	9a05      	ldr	r2, [sp, #20]
   1a7a2:	21c8      	movs	r1, #200	; 0xc8
   1a7a4:	480b      	ldr	r0, [pc, #44]	; (1a7d4 <SYS_CONSOLE_Print+0x68>)
   1a7a6:	f006 fc77 	bl	21098 <vsniprintf>
    if ((len > 0) && (len < SYS_CONSOLE_PRINT_BUFFER_SIZE))
   1a7aa:	1e43      	subs	r3, r0, #1
   1a7ac:	2bc6      	cmp	r3, #198	; 0xc6
   1a7ae:	d808      	bhi.n	1a7c2 <SYS_CONSOLE_Print+0x56>
        consolePrintBuffer[len] = '\0';
   1a7b0:	4908      	ldr	r1, [pc, #32]	; (1a7d4 <SYS_CONSOLE_Print+0x68>)
   1a7b2:	2300      	movs	r3, #0
   1a7b4:	540b      	strb	r3, [r1, r0]
        pConsoleObj->devDesc->write(pConsoleObj->devIndex, consolePrintBuffer, len);
   1a7b6:	4b05      	ldr	r3, [pc, #20]	; (1a7cc <SYS_CONSOLE_Print+0x60>)
   1a7b8:	685a      	ldr	r2, [r3, #4]
   1a7ba:	6954      	ldr	r4, [r2, #20]
   1a7bc:	4602      	mov	r2, r0
   1a7be:	6898      	ldr	r0, [r3, #8]
   1a7c0:	47a0      	blx	r4
    OSAL_MUTEX_Unlock(&consolePrintBufferMutex);
   1a7c2:	4803      	ldr	r0, [pc, #12]	; (1a7d0 <SYS_CONSOLE_Print+0x64>)
   1a7c4:	f006 fe8e 	bl	214e4 <OSAL_MUTEX_Unlock>
   1a7c8:	e7e3      	b.n	1a792 <SYS_CONSOLE_Print+0x26>
   1a7ca:	bf00      	nop
   1a7cc:	2000e540 	.word	0x2000e540
   1a7d0:	2000e67c 	.word	0x2000e67c
   1a7d4:	2000dc88 	.word	0x2000dc88

Disassembly of section .text.pvPortMalloc%467:

0001a7d8 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   1a7d8:	b538      	push	{r3, r4, r5, lr}
   1a7da:	4604      	mov	r4, r0
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if( portBYTE_ALIGNMENT != 1 )
	{
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
   1a7dc:	f010 0f07 	tst.w	r0, #7
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
   1a7e0:	bf1c      	itt	ne
   1a7e2:	f020 0407 	bicne.w	r4, r0, #7
   1a7e6:	3408      	addne	r4, #8
		}
	}
	#endif

	vTaskSuspendAll();
   1a7e8:	f007 f998 	bl	21b1c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
   1a7ec:	4b12      	ldr	r3, [pc, #72]	; (1a838 <pvPortMalloc+0x60>)
   1a7ee:	681b      	ldr	r3, [r3, #0]
   1a7f0:	b17b      	cbz	r3, 1a812 <pvPortMalloc+0x3a>
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
   1a7f2:	4b12      	ldr	r3, [pc, #72]	; (1a83c <pvPortMalloc+0x64>)
   1a7f4:	681b      	ldr	r3, [r3, #0]
   1a7f6:	441c      	add	r4, r3
   1a7f8:	f649 72f7 	movw	r2, #40951	; 0x9ff7
   1a7fc:	4294      	cmp	r4, r2
   1a7fe:	d80e      	bhi.n	1a81e <pvPortMalloc+0x46>
   1a800:	42a3      	cmp	r3, r4
   1a802:	d30f      	bcc.n	1a824 <pvPortMalloc+0x4c>
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
   1a804:	f7fa fabc 	bl	14d80 <xTaskResumeAll>
	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
   1a808:	f007 f8d4 	bl	219b4 <vApplicationMallocFailedHook>
   1a80c:	2500      	movs	r5, #0
		}
	}
	#endif

	return pvReturn;
}
   1a80e:	4628      	mov	r0, r5
   1a810:	bd38      	pop	{r3, r4, r5, pc}
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
   1a812:	4a09      	ldr	r2, [pc, #36]	; (1a838 <pvPortMalloc+0x60>)
   1a814:	4b0a      	ldr	r3, [pc, #40]	; (1a840 <pvPortMalloc+0x68>)
   1a816:	f023 0307 	bic.w	r3, r3, #7
   1a81a:	6013      	str	r3, [r2, #0]
   1a81c:	e7e9      	b.n	1a7f2 <pvPortMalloc+0x1a>
	( void ) xTaskResumeAll();
   1a81e:	f7fa faaf 	bl	14d80 <xTaskResumeAll>
		if( pvReturn == NULL )
   1a822:	e7f1      	b.n	1a808 <pvPortMalloc+0x30>
			pvReturn = pucAlignedHeap + xNextFreeByte;
   1a824:	4a04      	ldr	r2, [pc, #16]	; (1a838 <pvPortMalloc+0x60>)
   1a826:	6815      	ldr	r5, [r2, #0]
   1a828:	441d      	add	r5, r3
			xNextFreeByte += xWantedSize;
   1a82a:	4b04      	ldr	r3, [pc, #16]	; (1a83c <pvPortMalloc+0x64>)
   1a82c:	601c      	str	r4, [r3, #0]
	( void ) xTaskResumeAll();
   1a82e:	f7fa faa7 	bl	14d80 <xTaskResumeAll>
		if( pvReturn == NULL )
   1a832:	2d00      	cmp	r5, #0
   1a834:	d1eb      	bne.n	1a80e <pvPortMalloc+0x36>
   1a836:	e7e7      	b.n	1a808 <pvPortMalloc+0x30>
   1a838:	2000e69c 	.word	0x2000e69c
   1a83c:	2000e6a0 	.word	0x2000e6a0
   1a840:	2000000c 	.word	0x2000000c

Disassembly of section .text.snprintf%468:

0001a844 <sniprintf>:
   1a844:	b40c      	push	{r2, r3}
   1a846:	b530      	push	{r4, r5, lr}
   1a848:	4b18      	ldr	r3, [pc, #96]	; (1a8ac <sniprintf+0x68>)
   1a84a:	1e0c      	subs	r4, r1, #0
   1a84c:	b09b      	sub	sp, #108	; 0x6c
   1a84e:	681d      	ldr	r5, [r3, #0]
   1a850:	da08      	bge.n	1a864 <sniprintf+0x20>
   1a852:	238b      	movs	r3, #139	; 0x8b
   1a854:	602b      	str	r3, [r5, #0]
   1a856:	f04f 30ff 	mov.w	r0, #4294967295
   1a85a:	b01b      	add	sp, #108	; 0x6c
   1a85c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   1a860:	b002      	add	sp, #8
   1a862:	4770      	bx	lr
   1a864:	f44f 7302 	mov.w	r3, #520	; 0x208
   1a868:	f8ad 3010 	strh.w	r3, [sp, #16]
   1a86c:	bf14      	ite	ne
   1a86e:	f104 33ff 	addne.w	r3, r4, #4294967295
   1a872:	4623      	moveq	r3, r4
   1a874:	9303      	str	r3, [sp, #12]
   1a876:	9306      	str	r3, [sp, #24]
   1a878:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1a87c:	f8ad 3012 	strh.w	r3, [sp, #18]
   1a880:	2300      	movs	r3, #0
   1a882:	9001      	str	r0, [sp, #4]
   1a884:	9005      	str	r0, [sp, #20]
   1a886:	9319      	str	r3, [sp, #100]	; 0x64
   1a888:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   1a88a:	ab1f      	add	r3, sp, #124	; 0x7c
   1a88c:	a901      	add	r1, sp, #4
   1a88e:	4628      	mov	r0, r5
   1a890:	9300      	str	r3, [sp, #0]
   1a892:	f7f4 fed3 	bl	f63c <_svfiprintf_r>
   1a896:	1c43      	adds	r3, r0, #1
   1a898:	bfbc      	itt	lt
   1a89a:	238b      	movlt	r3, #139	; 0x8b
   1a89c:	602b      	strlt	r3, [r5, #0]
   1a89e:	2c00      	cmp	r4, #0
   1a8a0:	d0db      	beq.n	1a85a <sniprintf+0x16>
   1a8a2:	9b01      	ldr	r3, [sp, #4]
   1a8a4:	2200      	movs	r2, #0
   1a8a6:	701a      	strb	r2, [r3, #0]
   1a8a8:	e7d7      	b.n	1a85a <sniprintf+0x16>
   1a8aa:	bf00      	nop
   1a8ac:	2000e700 	.word	0x2000e700

Disassembly of section .text.wc_CryptoCb_Sha256Hash%469:

0001a8b0 <wc_CryptoCb_Sha256Hash>:
#endif /* !NO_SHA */

#ifndef NO_SHA256
int wc_CryptoCb_Sha256Hash(wc_Sha256* sha256, const byte* in,
    word32 inSz, byte* digest)
{
   1a8b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1a8b4:	b0a6      	sub	sp, #152	; 0x98
   1a8b6:	4688      	mov	r8, r1
   1a8b8:	4617      	mov	r7, r2
   1a8ba:	461e      	mov	r6, r3
    int ret = CRYPTOCB_UNAVAILABLE;
    CryptoCb* dev;

    /* locate registered callback */
    if (sha256) {
   1a8bc:	4605      	mov	r5, r0
   1a8be:	b308      	cbz	r0, 1a904 <wc_CryptoCb_Sha256Hash+0x54>
        dev = wc_CryptoCb_FindDevice(sha256->devId);
   1a8c0:	6f00      	ldr	r0, [r0, #112]	; 0x70
   1a8c2:	f004 fcf7 	bl	1f2b4 <wc_CryptoCb_FindDevice>
   1a8c6:	4604      	mov	r4, r0
    else {
        /* locate first callback and try using it */
        dev = wc_CryptoCb_FindDeviceByIndex(0);
    }

    if (dev && dev->cb) {
   1a8c8:	b30c      	cbz	r4, 1a90e <wc_CryptoCb_Sha256Hash+0x5e>
   1a8ca:	6863      	ldr	r3, [r4, #4]
   1a8cc:	b313      	cbz	r3, 1a914 <wc_CryptoCb_Sha256Hash+0x64>
        wc_CryptoInfo cryptoInfo;
        XMEMSET(&cryptoInfo, 0, sizeof(cryptoInfo));
   1a8ce:	2290      	movs	r2, #144	; 0x90
   1a8d0:	2100      	movs	r1, #0
   1a8d2:	a802      	add	r0, sp, #8
   1a8d4:	f007 f952 	bl	21b7c <memset>
        cryptoInfo.algo_type = WC_ALGO_TYPE_HASH;
   1a8d8:	2301      	movs	r3, #1
   1a8da:	9301      	str	r3, [sp, #4]
        cryptoInfo.hash.type = WC_HASH_TYPE_SHA256;
   1a8dc:	2306      	movs	r3, #6
   1a8de:	9316      	str	r3, [sp, #88]	; 0x58
        cryptoInfo.hash.sha256 = sha256;
   1a8e0:	951a      	str	r5, [sp, #104]	; 0x68
        cryptoInfo.hash.in = in;
   1a8e2:	f8cd 805c 	str.w	r8, [sp, #92]	; 0x5c
        cryptoInfo.hash.inSz = inSz;
   1a8e6:	9718      	str	r7, [sp, #96]	; 0x60
        cryptoInfo.hash.digest = digest;
   1a8e8:	9619      	str	r6, [sp, #100]	; 0x64

        ret = dev->cb(dev->devId, &cryptoInfo, dev->ctx);
   1a8ea:	6863      	ldr	r3, [r4, #4]
   1a8ec:	68a2      	ldr	r2, [r4, #8]
   1a8ee:	a901      	add	r1, sp, #4
   1a8f0:	6820      	ldr	r0, [r4, #0]
   1a8f2:	4798      	blx	r3
        ret = CRYPTOCB_UNAVAILABLE;
   1a8f4:	f110 0fae 	cmn.w	r0, #174	; 0xae
   1a8f8:	bf08      	it	eq
   1a8fa:	f46f 7087 	mvneq.w	r0, #270	; 0x10e
    }

    return wc_CryptoCb_TranslateErrorCode(ret);
}
   1a8fe:	b026      	add	sp, #152	; 0x98
   1a900:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        dev = wc_CryptoCb_FindDeviceByIndex(0);
   1a904:	2000      	movs	r0, #0
   1a906:	f002 fa77 	bl	1cdf8 <wc_CryptoCb_FindDeviceByIndex>
   1a90a:	4604      	mov	r4, r0
   1a90c:	e7dc      	b.n	1a8c8 <wc_CryptoCb_Sha256Hash+0x18>
    int ret = CRYPTOCB_UNAVAILABLE;
   1a90e:	f46f 7087 	mvn.w	r0, #270	; 0x10e
   1a912:	e7f4      	b.n	1a8fe <wc_CryptoCb_Sha256Hash+0x4e>
   1a914:	f46f 7087 	mvn.w	r0, #270	; 0x10e
    return wc_CryptoCb_TranslateErrorCode(ret);
   1a918:	e7f1      	b.n	1a8fe <wc_CryptoCb_Sha256Hash+0x4e>

Disassembly of section .text.DRV_ETHPHY_Open%470:

0001a91c <DRV_ETHPHY_Open>:
{
   1a91c:	b508      	push	{r3, lr}
    if(phyInst->objInUse == false)
   1a91e:	4b18      	ldr	r3, [pc, #96]	; (1a980 <DRV_ETHPHY_Open+0x64>)
   1a920:	781b      	ldrb	r3, [r3, #0]
   1a922:	b133      	cbz	r3, 1a932 <DRV_ETHPHY_Open+0x16>
        if(pClientObj->clientInUse == 0)
   1a924:	4b16      	ldr	r3, [pc, #88]	; (1a980 <DRV_ETHPHY_Open+0x64>)
   1a926:	8b1b      	ldrh	r3, [r3, #24]
   1a928:	4303      	orrs	r3, r0
   1a92a:	d005      	beq.n	1a938 <DRV_ETHPHY_Open+0x1c>
    return DRV_HANDLE_INVALID;
   1a92c:	f04f 30ff 	mov.w	r0, #4294967295
}
   1a930:	bd08      	pop	{r3, pc}
        return DRV_HANDLE_INVALID;
   1a932:	f04f 30ff 	mov.w	r0, #4294967295
   1a936:	e7fb      	b.n	1a930 <DRV_ETHPHY_Open+0x14>
        DRV_HANDLE miimHandle = phyInst->pMiimBase->DRV_MIIM_Open(phyInst->miimIndex, DRV_IO_INTENT_SHARED);
   1a938:	4b11      	ldr	r3, [pc, #68]	; (1a980 <DRV_ETHPHY_Open+0x64>)
   1a93a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   1a93c:	6952      	ldr	r2, [r2, #20]
   1a93e:	2100      	movs	r1, #0
   1a940:	f8b3 0064 	ldrh.w	r0, [r3, #100]	; 0x64
   1a944:	4790      	blx	r2
        if(miimHandle == DRV_HANDLE_INVALID)
   1a946:	f1b0 3fff 	cmp.w	r0, #4294967295
   1a94a:	d0f1      	beq.n	1a930 <DRV_ETHPHY_Open+0x14>
        hClientObj->pMiimBase = phyInst->pMiimBase;
   1a94c:	4b0c      	ldr	r3, [pc, #48]	; (1a980 <DRV_ETHPHY_Open+0x64>)
   1a94e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   1a950:	629a      	str	r2, [r3, #40]	; 0x28
        hClientObj->miimHandle = miimHandle;
   1a952:	62d8      	str	r0, [r3, #44]	; 0x2c
        hClientObj->miimOpHandle = 0;
   1a954:	2200      	movs	r2, #0
   1a956:	631a      	str	r2, [r3, #48]	; 0x30
        hClientObj->clientInUse    = true;
   1a958:	2101      	movs	r1, #1
   1a95a:	8319      	strh	r1, [r3, #24]
        hClientObj->clientIx = clientIx;
   1a95c:	835a      	strh	r2, [r3, #26]
        hClientObj->hDriver  = phyInst;
   1a95e:	625b      	str	r3, [r3, #36]	; 0x24
        hClientObj->ethphyId = phyInst->ethphyId;
   1a960:	6899      	ldr	r1, [r3, #8]
   1a962:	61d9      	str	r1, [r3, #28]
        hClientObj->operType = DRV_ETHPHY_CLIENT_OP_TYPE_NONE;
   1a964:	869a      	strh	r2, [r3, #52]	; 0x34
        hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
   1a966:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    hClientObj->operPhase = operPhase;
   1a96a:	86da      	strh	r2, [r3, #54]	; 0x36
    hClientObj->operSubPhase = operSubPhase;
   1a96c:	871a      	strh	r2, [r3, #56]	; 0x38
        phyInst->numClients++;
   1a96e:	885a      	ldrh	r2, [r3, #2]
   1a970:	3201      	adds	r2, #1
   1a972:	805a      	strh	r2, [r3, #2]
        hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_READY;
   1a974:	2202      	movs	r2, #2
   1a976:	f883 2020 	strb.w	r2, [r3, #32]
        return ( ( DRV_HANDLE ) hClientObj );
   1a97a:	f103 0018 	add.w	r0, r3, #24
   1a97e:	e7d7      	b.n	1a930 <DRV_ETHPHY_Open+0x14>
   1a980:	2000e018 	.word	0x2000e018

Disassembly of section .text._TcpSwapHeader%471:

0001a984 <_TcpSwapHeader>:
	header->SourcePort      = TCPIP_Helper_ntohs(header->SourcePort);
   1a984:	8802      	ldrh	r2, [r0, #0]
   1a986:	0a13      	lsrs	r3, r2, #8
   1a988:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1a98c:	8003      	strh	r3, [r0, #0]
	header->DestPort        = TCPIP_Helper_ntohs(header->DestPort);
   1a98e:	8842      	ldrh	r2, [r0, #2]
   1a990:	0a13      	lsrs	r3, r2, #8
   1a992:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1a996:	8043      	strh	r3, [r0, #2]
	header->SeqNumber       = TCPIP_Helper_ntohl(header->SeqNumber);
   1a998:	6843      	ldr	r3, [r0, #4]
    return (((hLong & 0x000000ff) << 24) | ((hLong & 0x0000ff00) << 8) | ((hLong & 0x00ff0000) >> 8) | ((hLong & 0xff000000) >> 24));
   1a99a:	0e1a      	lsrs	r2, r3, #24
   1a99c:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
   1a9a0:	0219      	lsls	r1, r3, #8
   1a9a2:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
   1a9a6:	430a      	orrs	r2, r1
   1a9a8:	0a1b      	lsrs	r3, r3, #8
   1a9aa:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   1a9ae:	4313      	orrs	r3, r2
   1a9b0:	6043      	str	r3, [r0, #4]
	header->AckNumber       = TCPIP_Helper_ntohl(header->AckNumber);
   1a9b2:	6883      	ldr	r3, [r0, #8]
   1a9b4:	0e1a      	lsrs	r2, r3, #24
   1a9b6:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
   1a9ba:	0219      	lsls	r1, r3, #8
   1a9bc:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
   1a9c0:	430a      	orrs	r2, r1
   1a9c2:	0a1b      	lsrs	r3, r3, #8
   1a9c4:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   1a9c8:	4313      	orrs	r3, r2
   1a9ca:	6083      	str	r3, [r0, #8]
	header->Window          = TCPIP_Helper_ntohs(header->Window);
   1a9cc:	89c2      	ldrh	r2, [r0, #14]
       return (((hShort) << 8) | ((hShort) >> 8));
   1a9ce:	0a13      	lsrs	r3, r2, #8
   1a9d0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1a9d4:	81c3      	strh	r3, [r0, #14]
	header->Checksum        = TCPIP_Helper_ntohs(header->Checksum);
   1a9d6:	8a02      	ldrh	r2, [r0, #16]
   1a9d8:	0a13      	lsrs	r3, r2, #8
   1a9da:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1a9de:	8203      	strh	r3, [r0, #16]
	header->UrgentPointer   = TCPIP_Helper_ntohs(header->UrgentPointer);
   1a9e0:	8a42      	ldrh	r2, [r0, #18]
   1a9e2:	0213      	lsls	r3, r2, #8
   1a9e4:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
   1a9e8:	8243      	strh	r3, [r0, #18]
}
   1a9ea:	4770      	bx	lr

Disassembly of section .text._DNS_AddSelectionIf%472:

0001a9ec <_DNS_AddSelectionIf>:
    if(pIf && _DNS_NetIsValid(pIf))
   1a9ec:	b320      	cbz	r0, 1aa38 <_DNS_AddSelectionIf+0x4c>
{
   1a9ee:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1a9f0:	4605      	mov	r5, r0
   1a9f2:	4616      	mov	r6, r2
   1a9f4:	460f      	mov	r7, r1
    if(pIf && _DNS_NetIsValid(pIf))
   1a9f6:	f003 feab 	bl	1e750 <_DNS_NetIsValid>
   1a9fa:	4684      	mov	ip, r0
   1a9fc:	b300      	cbz	r0, 1aa40 <_DNS_AddSelectionIf+0x54>
        for(ix = 0; ix < tblEntries; ix++)
   1a9fe:	2e00      	cmp	r6, #0
   1aa00:	dd22      	ble.n	1aa48 <_DNS_AddSelectionIf+0x5c>
            if(dnsIfTbl[ix] == pIf)
   1aa02:	683c      	ldr	r4, [r7, #0]
   1aa04:	42a5      	cmp	r5, r4
   1aa06:	d01d      	beq.n	1aa44 <_DNS_AddSelectionIf+0x58>
   1aa08:	463a      	mov	r2, r7
        addIx = -1;
   1aa0a:	f04f 31ff 	mov.w	r1, #4294967295
        for(ix = 0; ix < tblEntries; ix++)
   1aa0e:	2300      	movs	r3, #0
   1aa10:	e00a      	b.n	1aa28 <_DNS_AddSelectionIf+0x3c>
            if(dnsIfTbl[ix] == 0 && addIx < 0)
   1aa12:	ea31 0121 	bics.w	r1, r1, r1, asr #32
   1aa16:	bf28      	it	cs
   1aa18:	4619      	movcs	r1, r3
        for(ix = 0; ix < tblEntries; ix++)
   1aa1a:	3301      	adds	r3, #1
   1aa1c:	429e      	cmp	r6, r3
   1aa1e:	d006      	beq.n	1aa2e <_DNS_AddSelectionIf+0x42>
            if(dnsIfTbl[ix] == pIf)
   1aa20:	f852 4f04 	ldr.w	r4, [r2, #4]!
   1aa24:	42ac      	cmp	r4, r5
   1aa26:	d00d      	beq.n	1aa44 <_DNS_AddSelectionIf+0x58>
            if(dnsIfTbl[ix] == 0 && addIx < 0)
   1aa28:	2c00      	cmp	r4, #0
   1aa2a:	d1f6      	bne.n	1aa1a <_DNS_AddSelectionIf+0x2e>
   1aa2c:	e7f1      	b.n	1aa12 <_DNS_AddSelectionIf+0x26>
        if(addIx >= 0)
   1aa2e:	2900      	cmp	r1, #0
   1aa30:	db0d      	blt.n	1aa4e <_DNS_AddSelectionIf+0x62>
            dnsIfTbl[addIx] = pIf;
   1aa32:	f847 5021 	str.w	r5, [r7, r1, lsl #2]
   1aa36:	e005      	b.n	1aa44 <_DNS_AddSelectionIf+0x58>
    return true;
   1aa38:	f04f 0c01 	mov.w	ip, #1
}
   1aa3c:	4660      	mov	r0, ip
   1aa3e:	4770      	bx	lr
    return true;
   1aa40:	f04f 0c01 	mov.w	ip, #1
}
   1aa44:	4660      	mov	r0, ip
   1aa46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return false;
   1aa48:	f04f 0c00 	mov.w	ip, #0
   1aa4c:	e7fa      	b.n	1aa44 <_DNS_AddSelectionIf+0x58>
   1aa4e:	f04f 0c00 	mov.w	ip, #0
   1aa52:	e7f7      	b.n	1aa44 <_DNS_AddSelectionIf+0x58>

Disassembly of section .text.TCPIP_OAHASH_EntryLookup%473:

0001aa54 <TCPIP_OAHASH_EntryLookup>:
{
   1aa54:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1aa58:	4605      	mov	r5, r0
   1aa5a:	4688      	mov	r8, r1
    probeStep = pOH->probeStep;
   1aa5c:	6907      	ldr	r7, [r0, #16]
    bktIx = (*pOH->hashF)(pOH, key);
   1aa5e:	6943      	ldr	r3, [r0, #20]
   1aa60:	4798      	blx	r3
    while(bkts < pOH->hEntries)
   1aa62:	68eb      	ldr	r3, [r5, #12]
   1aa64:	b33b      	cbz	r3, 1aab6 <TCPIP_OAHASH_EntryLookup+0x62>
   1aa66:	4604      	mov	r4, r0
    size_t      bkts = 0;
   1aa68:	2600      	movs	r6, #0
   1aa6a:	e007      	b.n	1aa7c <TCPIP_OAHASH_EntryLookup+0x28>
        bktIx += probeStep;
   1aa6c:	443c      	add	r4, r7
        if(bktIx >= pOH->hEntries)
   1aa6e:	68eb      	ldr	r3, [r5, #12]
   1aa70:	42a3      	cmp	r3, r4
            bktIx -= pOH->hEntries;
   1aa72:	bf98      	it	ls
   1aa74:	1ae4      	subls	r4, r4, r3
        bkts++;
   1aa76:	3601      	adds	r6, #1
    while(bkts < pOH->hEntries)
   1aa78:	42b3      	cmp	r3, r6
   1aa7a:	d917      	bls.n	1aaac <TCPIP_OAHASH_EntryLookup+0x58>
        pBkt = (OA_HASH_ENTRY*)((uint8_t*)(pOH->memBlk) + bktIx * pOH->hEntrySize);
   1aa7c:	68ab      	ldr	r3, [r5, #8]
   1aa7e:	fb03 f304 	mul.w	r3, r3, r4
   1aa82:	682a      	ldr	r2, [r5, #0]
   1aa84:	eb02 0903 	add.w	r9, r2, r3
        if(pBkt->flags.busy && (*pOH->cmpF)(pOH, pBkt, key) == 0)
   1aa88:	5cd3      	ldrb	r3, [r2, r3]
   1aa8a:	f013 0f01 	tst.w	r3, #1
   1aa8e:	d0ed      	beq.n	1aa6c <TCPIP_OAHASH_EntryLookup+0x18>
   1aa90:	69eb      	ldr	r3, [r5, #28]
   1aa92:	4642      	mov	r2, r8
   1aa94:	4649      	mov	r1, r9
   1aa96:	4628      	mov	r0, r5
   1aa98:	4798      	blx	r3
   1aa9a:	2800      	cmp	r0, #0
   1aa9c:	d1e6      	bne.n	1aa6c <TCPIP_OAHASH_EntryLookup+0x18>
            pBkt->flags.newEntry = 0;
   1aa9e:	f899 3000 	ldrb.w	r3, [r9]
   1aaa2:	f36f 0341 	bfc	r3, #1, #1
   1aaa6:	f889 3000 	strb.w	r3, [r9]
            return pBkt;
   1aaaa:	e001      	b.n	1aab0 <TCPIP_OAHASH_EntryLookup+0x5c>
    return 0;   // not found
   1aaac:	f04f 0900 	mov.w	r9, #0
}
   1aab0:	4648      	mov	r0, r9
   1aab2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return 0;   // not found
   1aab6:	f04f 0900 	mov.w	r9, #0
   1aaba:	e7f9      	b.n	1aab0 <TCPIP_OAHASH_EntryLookup+0x5c>

Disassembly of section .text._TCPIPStackInsertRxPacket%474:

0001aabc <_TCPIPStackInsertRxPacket>:
{
   1aabc:	b538      	push	{r3, r4, r5, lr}
   1aabe:	4604      	mov	r4, r0
   1aac0:	4615      	mov	r5, r2
    pRxPkt->pktFlags |= TCPIP_MAC_PKT_FLAG_QUEUED;
   1aac2:	8c4a      	ldrh	r2, [r1, #34]	; 0x22
   1aac4:	f042 0208 	orr.w	r2, r2, #8
   1aac8:	844a      	strh	r2, [r1, #34]	; 0x22
    pRxPkt->pDSeg->segLen -= sizeof(TCPIP_MAC_ETHERNET_HEADER);
   1aaca:	6908      	ldr	r0, [r1, #16]
   1aacc:	8982      	ldrh	r2, [r0, #12]
   1aace:	3a0e      	subs	r2, #14
   1aad0:	8182      	strh	r2, [r0, #12]
    pRxPkt->pktIf = pNetIf;
   1aad2:	628c      	str	r4, [r1, #40]	; 0x28
    _TCPIPStackModuleRxInsert(TCPIP_MODULE_MANAGER, pRxPkt, 0);
   1aad4:	2200      	movs	r2, #0
   1aad6:	2001      	movs	r0, #1
   1aad8:	f002 fc48 	bl	1d36c <_TCPIPStackModuleRxInsert>
    if(signal)
   1aadc:	b905      	cbnz	r5, 1aae0 <_TCPIPStackInsertRxPacket+0x24>
}
   1aade:	bd38      	pop	{r3, r4, r5, pc}
    return OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
   1aae0:	2001      	movs	r0, #1
   1aae2:	f006 fcdb 	bl	2149c <OSAL_CRIT_Enter>
    pNetIf->activeEvents |= event;
   1aae6:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
   1aaea:	f043 0310 	orr.w	r3, r3, #16
   1aaee:	f8a4 305a 	strh.w	r3, [r4, #90]	; 0x5a
    totTcpipEventsCnt++;
   1aaf2:	4a0a      	ldr	r2, [pc, #40]	; (1ab1c <_TCPIPStackInsertRxPacket+0x60>)
   1aaf4:	6813      	ldr	r3, [r2, #0]
   1aaf6:	3301      	adds	r3, #1
   1aaf8:	6013      	str	r3, [r2, #0]
        pSigEntry->signalVal |= TCPIP_MODULE_SIGNAL_RX_PENDING;
   1aafa:	4c09      	ldr	r4, [pc, #36]	; (1ab20 <_TCPIPStackInsertRxPacket+0x64>)
   1aafc:	8b23      	ldrh	r3, [r4, #24]
   1aafe:	f043 0301 	orr.w	r3, r3, #1
   1ab02:	8323      	strh	r3, [r4, #24]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH, suspLevel);
   1ab04:	4601      	mov	r1, r0
   1ab06:	2001      	movs	r0, #1
   1ab08:	f006 fdf7 	bl	216fa <OSAL_CRIT_Leave>
        _TCPIPSignalEntryNotify(pSigEntry, TCPIP_MODULE_SIGNAL_RX_PENDING, 0);
   1ab0c:	2200      	movs	r2, #0
   1ab0e:	2101      	movs	r1, #1
   1ab10:	f104 0010 	add.w	r0, r4, #16
   1ab14:	f006 f98c 	bl	20e30 <_TCPIPSignalEntryNotify>
}
   1ab18:	e7e1      	b.n	1aade <_TCPIPStackInsertRxPacket+0x22>
   1ab1a:	bf00      	nop
   1ab1c:	2000e650 	.word	0x2000e650
   1ab20:	2000d1d4 	.word	0x2000d1d4

Disassembly of section .text.SYS_CONSOLE_Initialize%475:

0001ab24 <SYS_CONSOLE_Initialize>:
{
   1ab24:	b538      	push	{r3, r4, r5, lr}
   1ab26:	4605      	mov	r5, r0
   1ab28:	460c      	mov	r4, r1
    if (isConsoleMutexCreated == false)
   1ab2a:	4b15      	ldr	r3, [pc, #84]	; (1ab80 <SYS_CONSOLE_Initialize+0x5c>)
   1ab2c:	781b      	ldrb	r3, [r3, #0]
   1ab2e:	b143      	cbz	r3, 1ab42 <SYS_CONSOLE_Initialize+0x1e>
    if (index >= SYS_CONSOLE_DEVICE_MAX_INSTANCES || init == NULL)
   1ab30:	b9fd      	cbnz	r5, 1ab72 <SYS_CONSOLE_Initialize+0x4e>
   1ab32:	b30c      	cbz	r4, 1ab78 <SYS_CONSOLE_Initialize+0x54>
    if ((pConsoleObj->status == SYS_STATUS_UNINITIALIZED) && initConfig)
   1ab34:	4b13      	ldr	r3, [pc, #76]	; (1ab84 <SYS_CONSOLE_Initialize+0x60>)
   1ab36:	f993 3000 	ldrsb.w	r3, [r3]
   1ab3a:	b15b      	cbz	r3, 1ab54 <SYS_CONSOLE_Initialize+0x30>
    return SYS_MODULE_OBJ_INVALID;
   1ab3c:	f04f 30ff 	mov.w	r0, #4294967295
}
   1ab40:	bd38      	pop	{r3, r4, r5, pc}
        if(OSAL_MUTEX_Create(&(consolePrintBufferMutex)) != OSAL_RESULT_TRUE)
   1ab42:	4811      	ldr	r0, [pc, #68]	; (1ab88 <SYS_CONSOLE_Initialize+0x64>)
   1ab44:	f006 fcc2 	bl	214cc <OSAL_MUTEX_Create>
   1ab48:	2801      	cmp	r0, #1
   1ab4a:	d10f      	bne.n	1ab6c <SYS_CONSOLE_Initialize+0x48>
            isConsoleMutexCreated = true;
   1ab4c:	4b0c      	ldr	r3, [pc, #48]	; (1ab80 <SYS_CONSOLE_Initialize+0x5c>)
   1ab4e:	2201      	movs	r2, #1
   1ab50:	701a      	strb	r2, [r3, #0]
   1ab52:	e7ed      	b.n	1ab30 <SYS_CONSOLE_Initialize+0xc>
        pConsoleObj->devIndex = initConfig->deviceIndex;
   1ab54:	68a0      	ldr	r0, [r4, #8]
   1ab56:	4b0b      	ldr	r3, [pc, #44]	; (1ab84 <SYS_CONSOLE_Initialize+0x60>)
   1ab58:	6098      	str	r0, [r3, #8]
        pConsoleObj->devDesc = initConfig->consDevDesc;
   1ab5a:	6862      	ldr	r2, [r4, #4]
   1ab5c:	605a      	str	r2, [r3, #4]
        pConsoleObj->status = SYS_STATUS_READY;
   1ab5e:	2102      	movs	r1, #2
   1ab60:	7019      	strb	r1, [r3, #0]
        pConsoleObj->devDesc->init( pConsoleObj->devIndex, initConfig->deviceInitData);
   1ab62:	6853      	ldr	r3, [r2, #4]
   1ab64:	6821      	ldr	r1, [r4, #0]
   1ab66:	4798      	blx	r3
        return index;
   1ab68:	2000      	movs	r0, #0
   1ab6a:	e7e9      	b.n	1ab40 <SYS_CONSOLE_Initialize+0x1c>
            return SYS_MODULE_OBJ_INVALID;
   1ab6c:	f04f 30ff 	mov.w	r0, #4294967295
   1ab70:	e7e6      	b.n	1ab40 <SYS_CONSOLE_Initialize+0x1c>
        return SYS_MODULE_OBJ_INVALID;
   1ab72:	f04f 30ff 	mov.w	r0, #4294967295
   1ab76:	e7e3      	b.n	1ab40 <SYS_CONSOLE_Initialize+0x1c>
   1ab78:	f04f 30ff 	mov.w	r0, #4294967295
   1ab7c:	e7e0      	b.n	1ab40 <SYS_CONSOLE_Initialize+0x1c>
   1ab7e:	bf00      	nop
   1ab80:	2000e72b 	.word	0x2000e72b
   1ab84:	2000e540 	.word	0x2000e540
   1ab88:	2000e67c 	.word	0x2000e67c

Disassembly of section .text.wc_RNG_TestSeed%476:

0001ab8c <wc_RNG_TestSeed>:
{
   1ab8c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    word32 scratchSz = min(SEED_BLOCK_SZ, seedSz - SEED_BLOCK_SZ);
   1ab90:	f1a1 0e04 	sub.w	lr, r1, #4
        return a > b ? b : a;
   1ab94:	4673      	mov	r3, lr
   1ab96:	2b04      	cmp	r3, #4
   1ab98:	bf28      	it	cs
   1ab9a:	2304      	movcs	r3, #4
    while (seedIdx < seedSz - SEED_BLOCK_SZ) {
   1ab9c:	f1be 0f00 	cmp.w	lr, #0
   1aba0:	d025      	beq.n	1abee <wc_RNG_TestSeed+0x62>
   1aba2:	4684      	mov	ip, r0
    word32 seedIdx = 0;
   1aba4:	2700      	movs	r7, #0
    int ret = 0;
   1aba6:	4638      	mov	r0, r7
   1aba8:	f10c 38ff 	add.w	r8, ip, #4294967295
   1abac:	e009      	b.n	1abc2 <wc_RNG_TestSeed+0x36>
            ret = DRBG_CONT_FAILURE;
   1abae:	2c00      	cmp	r4, #0
   1abb0:	bf08      	it	eq
   1abb2:	2003      	moveq	r0, #3
        seedIdx += SEED_BLOCK_SZ;
   1abb4:	3704      	adds	r7, #4
   1abb6:	1bcb      	subs	r3, r1, r7
   1abb8:	2b04      	cmp	r3, #4
   1abba:	bf28      	it	cs
   1abbc:	2304      	movcs	r3, #4
    while (seedIdx < seedSz - SEED_BLOCK_SZ) {
   1abbe:	45be      	cmp	lr, r7
   1abc0:	d916      	bls.n	1abf0 <wc_RNG_TestSeed+0x64>
                            seed + seedIdx + scratchSz,
   1abc2:	18fe      	adds	r6, r7, r3
    for (i = 0; i < length; i++) {
   1abc4:	2b00      	cmp	r3, #0
   1abc6:	dd10      	ble.n	1abea <wc_RNG_TestSeed+0x5e>
   1abc8:	eb08 0507 	add.w	r5, r8, r7
   1abcc:	eb0c 0206 	add.w	r2, ip, r6
   1abd0:	4463      	add	r3, ip
   1abd2:	441e      	add	r6, r3
    int compareSum = 0;
   1abd4:	2400      	movs	r4, #0
        compareSum |= a[i] ^ b[i];
   1abd6:	f812 3b01 	ldrb.w	r3, [r2], #1
   1abda:	f815 9f01 	ldrb.w	r9, [r5, #1]!
   1abde:	ea83 0309 	eor.w	r3, r3, r9
   1abe2:	431c      	orrs	r4, r3
    for (i = 0; i < length; i++) {
   1abe4:	42b2      	cmp	r2, r6
   1abe6:	d1f6      	bne.n	1abd6 <wc_RNG_TestSeed+0x4a>
   1abe8:	e7e1      	b.n	1abae <wc_RNG_TestSeed+0x22>
            ret = DRBG_CONT_FAILURE;
   1abea:	2003      	movs	r0, #3
   1abec:	e7e2      	b.n	1abb4 <wc_RNG_TestSeed+0x28>
    int ret = 0;
   1abee:	2000      	movs	r0, #0
}
   1abf0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

Disassembly of section .text.rand%477:

0001abf4 <rand>:
   1abf4:	4b13      	ldr	r3, [pc, #76]	; (1ac44 <rand+0x50>)
   1abf6:	b510      	push	{r4, lr}
   1abf8:	681c      	ldr	r4, [r3, #0]
   1abfa:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1abfc:	b97b      	cbnz	r3, 1ac1e <rand+0x2a>
   1abfe:	2018      	movs	r0, #24
   1ac00:	f006 ffac 	bl	21b5c <malloc>
   1ac04:	4a10      	ldr	r2, [pc, #64]	; (1ac48 <rand+0x54>)
   1ac06:	4b11      	ldr	r3, [pc, #68]	; (1ac4c <rand+0x58>)
   1ac08:	63a0      	str	r0, [r4, #56]	; 0x38
   1ac0a:	e9c0 2300 	strd	r2, r3, [r0]
   1ac0e:	4b10      	ldr	r3, [pc, #64]	; (1ac50 <rand+0x5c>)
   1ac10:	6083      	str	r3, [r0, #8]
   1ac12:	230b      	movs	r3, #11
   1ac14:	8183      	strh	r3, [r0, #12]
   1ac16:	2201      	movs	r2, #1
   1ac18:	2300      	movs	r3, #0
   1ac1a:	e9c0 2304 	strd	r2, r3, [r0, #16]
   1ac1e:	6ba1      	ldr	r1, [r4, #56]	; 0x38
   1ac20:	480c      	ldr	r0, [pc, #48]	; (1ac54 <rand+0x60>)
   1ac22:	690a      	ldr	r2, [r1, #16]
   1ac24:	694b      	ldr	r3, [r1, #20]
   1ac26:	4c0c      	ldr	r4, [pc, #48]	; (1ac58 <rand+0x64>)
   1ac28:	4350      	muls	r0, r2
   1ac2a:	fb04 0003 	mla	r0, r4, r3, r0
   1ac2e:	fba2 3404 	umull	r3, r4, r2, r4
   1ac32:	1c5a      	adds	r2, r3, #1
   1ac34:	4404      	add	r4, r0
   1ac36:	f144 0000 	adc.w	r0, r4, #0
   1ac3a:	e9c1 2004 	strd	r2, r0, [r1, #16]
   1ac3e:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
   1ac42:	bd10      	pop	{r4, pc}
   1ac44:	2000e700 	.word	0x2000e700
   1ac48:	abcd330e 	.word	0xabcd330e
   1ac4c:	e66d1234 	.word	0xe66d1234
   1ac50:	0005deec 	.word	0x0005deec
   1ac54:	5851f42d 	.word	0x5851f42d
   1ac58:	4c957f2d 	.word	0x4c957f2d

Disassembly of section .text._Balloc%478:

0001ac5c <_Balloc>:
   1ac5c:	b570      	push	{r4, r5, r6, lr}
   1ac5e:	6a45      	ldr	r5, [r0, #36]	; 0x24
   1ac60:	4604      	mov	r4, r0
   1ac62:	460e      	mov	r6, r1
   1ac64:	b93d      	cbnz	r5, 1ac76 <_Balloc+0x1a>
   1ac66:	2010      	movs	r0, #16
   1ac68:	f006 ff78 	bl	21b5c <malloc>
   1ac6c:	e9c0 5501 	strd	r5, r5, [r0, #4]
   1ac70:	6260      	str	r0, [r4, #36]	; 0x24
   1ac72:	6005      	str	r5, [r0, #0]
   1ac74:	60c5      	str	r5, [r0, #12]
   1ac76:	6a65      	ldr	r5, [r4, #36]	; 0x24
   1ac78:	68eb      	ldr	r3, [r5, #12]
   1ac7a:	b183      	cbz	r3, 1ac9e <_Balloc+0x42>
   1ac7c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1ac7e:	68db      	ldr	r3, [r3, #12]
   1ac80:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
   1ac84:	b9b8      	cbnz	r0, 1acb6 <_Balloc+0x5a>
   1ac86:	2101      	movs	r1, #1
   1ac88:	fa01 f506 	lsl.w	r5, r1, r6
   1ac8c:	1d6a      	adds	r2, r5, #5
   1ac8e:	0092      	lsls	r2, r2, #2
   1ac90:	4620      	mov	r0, r4
   1ac92:	f006 f9f3 	bl	2107c <_calloc_r>
   1ac96:	b160      	cbz	r0, 1acb2 <_Balloc+0x56>
   1ac98:	e9c0 6501 	strd	r6, r5, [r0, #4]
   1ac9c:	e00e      	b.n	1acbc <_Balloc+0x60>
   1ac9e:	2221      	movs	r2, #33	; 0x21
   1aca0:	2104      	movs	r1, #4
   1aca2:	4620      	mov	r0, r4
   1aca4:	f006 f9ea 	bl	2107c <_calloc_r>
   1aca8:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1acaa:	60e8      	str	r0, [r5, #12]
   1acac:	68db      	ldr	r3, [r3, #12]
   1acae:	2b00      	cmp	r3, #0
   1acb0:	d1e4      	bne.n	1ac7c <_Balloc+0x20>
   1acb2:	2000      	movs	r0, #0
   1acb4:	bd70      	pop	{r4, r5, r6, pc}
   1acb6:	6802      	ldr	r2, [r0, #0]
   1acb8:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
   1acbc:	2300      	movs	r3, #0
   1acbe:	e9c0 3303 	strd	r3, r3, [r0, #12]
   1acc2:	e7f7      	b.n	1acb4 <_Balloc+0x58>

Disassembly of section .text._DRV_ETHPHY_NegResultPhase_BMSTAT%479:

0001acc4 <_DRV_ETHPHY_NegResultPhase_BMSTAT>:
{
   1acc4:	b510      	push	{r4, lr}
   1acc6:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1acc8:	f005 fccc 	bl	20664 <_DRV_PHY_SMITransfer_Wait>
   1accc:	b190      	cbz	r0, 1acf4 <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x30>
    if(phyStat.AN_COMPLETE == 0)
   1acce:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
   1acd2:	f013 0f20 	tst.w	r3, #32
   1acd6:	d00e      	beq.n	1acf6 <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x32>
    else if(phyStat.LINK_STAT == 0)
   1acd8:	f013 0f04 	tst.w	r3, #4
   1acdc:	d119      	bne.n	1ad12 <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x4e>
    DRV_ETHPHY_NEGOTIATION_RESULT* pNegResult = (DRV_ETHPHY_NEGOTIATION_RESULT*)hClientObj->operParam;
   1acde:	6b23      	ldr	r3, [r4, #48]	; 0x30
    if(pNegResult)
   1ace0:	b11b      	cbz	r3, 1acea <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x26>
        pNegResult->linkStatus = linkStatus;
   1ace2:	2200      	movs	r2, #0
   1ace4:	801a      	strh	r2, [r3, #0]
        pNegResult->linkFlags = openFlags;
   1ace6:	805a      	strh	r2, [r3, #2]
        pNegResult->pauseType = pauseType;
   1ace8:	711a      	strb	r2, [r3, #4]
    _DRV_PHY_SetOperDoneResult(hClientObj, res);
   1acea:	f06f 0107 	mvn.w	r1, #7
   1acee:	4620      	mov	r0, r4
   1acf0:	f004 ff68 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
}
   1acf4:	bd10      	pop	{r4, pc}
    DRV_ETHPHY_NEGOTIATION_RESULT* pNegResult = (DRV_ETHPHY_NEGOTIATION_RESULT*)hClientObj->operParam;
   1acf6:	6b23      	ldr	r3, [r4, #48]	; 0x30
    if(pNegResult)
   1acf8:	b12b      	cbz	r3, 1ad06 <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x42>
        pNegResult->linkStatus = linkStatus;
   1acfa:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   1acfe:	801a      	strh	r2, [r3, #0]
        pNegResult->linkFlags = openFlags;
   1ad00:	2200      	movs	r2, #0
   1ad02:	805a      	strh	r2, [r3, #2]
        pNegResult->pauseType = pauseType;
   1ad04:	711a      	strb	r2, [r3, #4]
    _DRV_PHY_SetOperDoneResult(hClientObj, res);
   1ad06:	f06f 0107 	mvn.w	r1, #7
   1ad0a:	4620      	mov	r0, r4
   1ad0c:	f004 ff5a 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
   1ad10:	e7f0      	b.n	1acf4 <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x30>
        if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_ANEXP))
   1ad12:	2106      	movs	r1, #6
   1ad14:	4620      	mov	r0, r4
   1ad16:	f004 f80f 	bl	1ed38 <_DRV_PHY_SMIReadStart>
   1ad1a:	2800      	cmp	r0, #0
   1ad1c:	d0ea      	beq.n	1acf4 <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x30>
    hClientObj->operPhase = operPhase;
   1ad1e:	2302      	movs	r3, #2
   1ad20:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1ad22:	2300      	movs	r3, #0
   1ad24:	8423      	strh	r3, [r4, #32]
   1ad26:	e7e5      	b.n	1acf4 <_DRV_ETHPHY_NegResultPhase_BMSTAT+0x30>

Disassembly of section .text._DRV_ETHPHY_ResetPhaseRead%480:

0001ad28 <_DRV_ETHPHY_ResetPhaseRead>:
{
   1ad28:	b510      	push	{r4, lr}
   1ad2a:	4604      	mov	r4, r0
    switch(hClientObj->operSubPhase)
   1ad2c:	8c03      	ldrh	r3, [r0, #32]
   1ad2e:	b133      	cbz	r3, 1ad3e <_DRV_ETHPHY_ResetPhaseRead+0x16>
   1ad30:	2b01      	cmp	r3, #1
   1ad32:	d00e      	beq.n	1ad52 <_DRV_ETHPHY_ResetPhaseRead+0x2a>
            _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   1ad34:	f06f 0108 	mvn.w	r1, #8
   1ad38:	f004 ff44 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
}
   1ad3c:	bd10      	pop	{r4, pc}
            if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMCON))
   1ad3e:	2100      	movs	r1, #0
   1ad40:	f003 fffa 	bl	1ed38 <_DRV_PHY_SMIReadStart>
   1ad44:	2800      	cmp	r0, #0
   1ad46:	d0f9      	beq.n	1ad3c <_DRV_ETHPHY_ResetPhaseRead+0x14>
    hClientObj->operPhase = operPhase;
   1ad48:	2302      	movs	r3, #2
   1ad4a:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1ad4c:	2301      	movs	r3, #1
   1ad4e:	8423      	strh	r3, [r4, #32]
   1ad50:	e7f4      	b.n	1ad3c <_DRV_ETHPHY_ResetPhaseRead+0x14>
            if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1ad52:	f005 fc87 	bl	20664 <_DRV_PHY_SMITransfer_Wait>
   1ad56:	2800      	cmp	r0, #0
   1ad58:	d0f0      	beq.n	1ad3c <_DRV_ETHPHY_ResetPhaseRead+0x14>
            if(bmcon.RESET)
   1ad5a:	f994 303b 	ldrsb.w	r3, [r4, #59]	; 0x3b
   1ad5e:	2b00      	cmp	r3, #0
   1ad60:	db04      	blt.n	1ad6c <_DRV_ETHPHY_ResetPhaseRead+0x44>
                _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OK);
   1ad62:	2100      	movs	r1, #0
   1ad64:	4620      	mov	r0, r4
   1ad66:	f004 ff2d 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
   1ad6a:	e7e7      	b.n	1ad3c <_DRV_ETHPHY_ResetPhaseRead+0x14>
                if(SYS_TMR_TickCountGet() < hClientObj->operTStamp)
   1ad6c:	f005 f91e 	bl	1ffac <SYS_TMR_TickCountGet>
   1ad70:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1ad72:	4298      	cmp	r0, r3
   1ad74:	d204      	bcs.n	1ad80 <_DRV_ETHPHY_ResetPhaseRead+0x58>
    hClientObj->operPhase = operPhase;
   1ad76:	2302      	movs	r3, #2
   1ad78:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1ad7a:	2300      	movs	r3, #0
   1ad7c:	8423      	strh	r3, [r4, #32]
   1ad7e:	e7dd      	b.n	1ad3c <_DRV_ETHPHY_ResetPhaseRead+0x14>
                    _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_DTCT_ERR);
   1ad80:	f04f 31ff 	mov.w	r1, #4294967295
   1ad84:	4620      	mov	r0, r4
   1ad86:	f004 ff1d 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
   1ad8a:	e7d7      	b.n	1ad3c <_DRV_ETHPHY_ResetPhaseRead+0x14>

Disassembly of section .text.DRV_GMAC_RegisterStatisticsGet%481:

0001ad8c <DRV_GMAC_RegisterStatisticsGet>:
{
   1ad8c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1ad90:	460c      	mov	r4, r1
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1ad92:	4915      	ldr	r1, [pc, #84]	; (1ade8 <DRV_GMAC_RegisterStatisticsGet+0x5c>)
   1ad94:	4281      	cmp	r1, r0
   1ad96:	d11c      	bne.n	1add2 <DRV_GMAC_RegisterStatisticsGet+0x46>
    if(pMACDrv == 0)
   1ad98:	b1f8      	cbz	r0, 1adda <DRV_GMAC_RegisterStatisticsGet+0x4e>
	if(pHwEntries)
   1ad9a:	b10b      	cbz	r3, 1ada0 <DRV_GMAC_RegisterStatisticsGet+0x14>
		*pHwEntries = nHwEntries;
   1ad9c:	212d      	movs	r1, #45	; 0x2d
   1ad9e:	6019      	str	r1, [r3, #0]
	if(pRegEntries)
   1ada0:	b1f4      	cbz	r4, 1ade0 <DRV_GMAC_RegisterStatisticsGet+0x54>
		regLim = nEntries > nHwEntries ? nHwEntries : nEntries;
   1ada2:	2a2d      	cmp	r2, #45	; 0x2d
   1ada4:	bfa8      	it	ge
   1ada6:	222d      	movge	r2, #45	; 0x2d
   1ada8:	4617      	mov	r7, r2
		for(ix = 0; ix < regLim; ix++, pRegEntries++, pHwRegDcpt++)
   1adaa:	b1da      	cbz	r2, 1ade4 <DRV_GMAC_RegisterStatisticsGet+0x58>
   1adac:	2600      	movs	r6, #0
		pHwRegDcpt = macPIC32CHwRegDcpt;
   1adae:	4d0f      	ldr	r5, [pc, #60]	; (1adec <DRV_GMAC_RegisterStatisticsGet+0x60>)
			strncpy(pRegEntries->registerName, pHwRegDcpt->regName, sizeof(pRegEntries->registerName));
   1adb0:	f04f 0824 	mov.w	r8, #36	; 0x24
   1adb4:	4642      	mov	r2, r8
   1adb6:	4629      	mov	r1, r5
   1adb8:	4620      	mov	r0, r4
   1adba:	f005 fa44 	bl	20246 <strncpy>
			pRegEntries->registerValue = (*pHwRegDcpt->regFunc)();
   1adbe:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1adc0:	4798      	blx	r3
   1adc2:	6260      	str	r0, [r4, #36]	; 0x24
		for(ix = 0; ix < regLim; ix++, pRegEntries++, pHwRegDcpt++)
   1adc4:	3601      	adds	r6, #1
   1adc6:	3428      	adds	r4, #40	; 0x28
   1adc8:	3528      	adds	r5, #40	; 0x28
   1adca:	42b7      	cmp	r7, r6
   1adcc:	d1f2      	bne.n	1adb4 <DRV_GMAC_RegisterStatisticsGet+0x28>
	return TCPIP_MAC_RES_OK;
   1adce:	2000      	movs	r0, #0
   1add0:	e001      	b.n	1add6 <DRV_GMAC_RegisterStatisticsGet+0x4a>
        return TCPIP_MAC_RES_OP_ERR;
   1add2:	f06f 0005 	mvn.w	r0, #5
}
   1add6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return TCPIP_MAC_RES_OP_ERR;
   1adda:	f06f 0005 	mvn.w	r0, #5
   1adde:	e7fa      	b.n	1add6 <DRV_GMAC_RegisterStatisticsGet+0x4a>
	return TCPIP_MAC_RES_OK;
   1ade0:	2000      	movs	r0, #0
   1ade2:	e7f8      	b.n	1add6 <DRV_GMAC_RegisterStatisticsGet+0x4a>
   1ade4:	2000      	movs	r0, #0
   1ade6:	e7f6      	b.n	1add6 <DRV_GMAC_RegisterStatisticsGet+0x4a>
   1ade8:	2000dab8 	.word	0x2000dab8
   1adec:	000056bc 	.word	0x000056bc

Disassembly of section .text._MacRxPacketAck%482:

0001adf0 <_MacRxPacketAck>:
    if(pPkt && pPkt->pDSeg)
   1adf0:	b350      	cbz	r0, 1ae48 <_MacRxPacketAck+0x58>
{
   1adf2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1adf4:	460c      	mov	r4, r1
   1adf6:	4601      	mov	r1, r0
    if(pPkt && pPkt->pDSeg)
   1adf8:	6903      	ldr	r3, [r0, #16]
   1adfa:	b33b      	cbz	r3, 1ae4c <_MacRxPacketAck+0x5c>
            pPkt->pDSeg->next = 0;
   1adfc:	2600      	movs	r6, #0
                DRV_PIC32CGMAC_SingleListTailAdd(&pMacDrv->sGmacData.gmac_queue[queueIdx]._RxQueue, (DRV_PIC32CGMAC_SGL_LIST_NODE*)pPkt); 
   1adfe:	f104 0794 	add.w	r7, r4, #148	; 0x94
   1ae02:	e009      	b.n	1ae18 <_MacRxPacketAck+0x28>
                (*pMacDrv->sGmacData.pktFreeF)(pPkt);          
   1ae04:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1ae06:	4608      	mov	r0, r1
   1ae08:	4798      	blx	r3
            if( !pDSegNext )
   1ae0a:	b30d      	cbz	r5, 1ae50 <_MacRxPacketAck+0x60>
            TCPIP_MAC_SEGMENT_GAP_DCPT* pGap = (TCPIP_MAC_SEGMENT_GAP_DCPT*)(pDSegNext->segBuffer + pMacDrv->sGmacData._dcptOffset);
   1ae0c:	f9b4 30ec 	ldrsh.w	r3, [r4, #236]	; 0xec
            pPkt = pGap->segmentPktPtr;
   1ae10:	686a      	ldr	r2, [r5, #4]
   1ae12:	58d1      	ldr	r1, [r2, r3]
        while(pPkt->pDSeg)
   1ae14:	690b      	ldr	r3, [r1, #16]
   1ae16:	b1ab      	cbz	r3, 1ae44 <_MacRxPacketAck+0x54>
            pDSegNext = pPkt->pDSeg->next;
   1ae18:	681d      	ldr	r5, [r3, #0]
            pPkt->pDSeg->next = 0;
   1ae1a:	601e      	str	r6, [r3, #0]
            if((pPkt->pDSeg->segFlags  & TCPIP_MAC_SEG_FLAG_RX_STICKY) == 0 && 
   1ae1c:	690b      	ldr	r3, [r1, #16]
   1ae1e:	8a1b      	ldrh	r3, [r3, #16]
   1ae20:	f013 0f04 	tst.w	r3, #4
   1ae24:	d10a      	bne.n	1ae3c <_MacRxPacketAck+0x4c>
   1ae26:	f8b4 30f4 	ldrh.w	r3, [r4, #244]	; 0xf4
   1ae2a:	f013 0f02 	tst.w	r3, #2
   1ae2e:	d1e9      	bne.n	1ae04 <_MacRxPacketAck+0x14>
                        pMacDrv->sGmacData.gmacConfig.gmac_queue_config[queueIdx].nRxBuffCntThres)))
   1ae30:	f8b4 30c4 	ldrh.w	r3, [r4, #196]	; 0xc4
                (((pMacDrv->sGmacData._controlFlags & TCPIP_MAC_CONTROL_NO_SMART_ALLOC) != 0) ||
   1ae34:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
   1ae38:	429a      	cmp	r2, r3
   1ae3a:	dce3      	bgt.n	1ae04 <_MacRxPacketAck+0x14>
                DRV_PIC32CGMAC_SingleListTailAdd(&pMacDrv->sGmacData.gmac_queue[queueIdx]._RxQueue, (DRV_PIC32CGMAC_SGL_LIST_NODE*)pPkt); 
   1ae3c:	4638      	mov	r0, r7
   1ae3e:	f006 f947 	bl	210d0 <DRV_PIC32CGMAC_SingleListTailAdd>
   1ae42:	e7e2      	b.n	1ae0a <_MacRxPacketAck+0x1a>
        res  = true; 
   1ae44:	2001      	movs	r0, #1
   1ae46:	e004      	b.n	1ae52 <_MacRxPacketAck+0x62>
    bool res = false;
   1ae48:	2000      	movs	r0, #0
}
   1ae4a:	4770      	bx	lr
    bool res = false;
   1ae4c:	2000      	movs	r0, #0
   1ae4e:	e000      	b.n	1ae52 <_MacRxPacketAck+0x62>
        res  = true; 
   1ae50:	2001      	movs	r0, #1
}
   1ae52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.TCPIP_OAHASH_EntryLookupOrInsert%483:

0001ae54 <TCPIP_OAHASH_EntryLookupOrInsert>:
{
   1ae54:	b538      	push	{r3, r4, r5, lr}
   1ae56:	4604      	mov	r4, r0
   1ae58:	460d      	mov	r5, r1
    pBkt = _OAHashFindBkt(pOH, key);
   1ae5a:	f7fd fdab 	bl	189b4 <_OAHashFindBkt>
    if(pBkt == 0)
   1ae5e:	4603      	mov	r3, r0
   1ae60:	b158      	cbz	r0, 1ae7a <TCPIP_OAHASH_EntryLookupOrInsert+0x26>
    if(pBkt->flags.busy == 0)
   1ae62:	781a      	ldrb	r2, [r3, #0]
   1ae64:	f012 0f01 	tst.w	r2, #1
        pBkt->flags.newEntry = 1;
   1ae68:	bf0e      	itee	eq
   1ae6a:	f042 0203 	orreq.w	r2, r2, #3
        pBkt->flags.newEntry = 0;
   1ae6e:	781a      	ldrbne	r2, [r3, #0]
   1ae70:	f36f 0241 	bfcne	r2, #1, #1
   1ae74:	701a      	strb	r2, [r3, #0]
}
   1ae76:	4618      	mov	r0, r3
   1ae78:	bd38      	pop	{r3, r4, r5, pc}
        if(pOH->fullSlots != pOH->hEntries)
   1ae7a:	6a61      	ldr	r1, [r4, #36]	; 0x24
   1ae7c:	68e2      	ldr	r2, [r4, #12]
   1ae7e:	4291      	cmp	r1, r2
   1ae80:	d1f9      	bne.n	1ae76 <TCPIP_OAHASH_EntryLookupOrInsert+0x22>
        if(pOH->delF == 0 || (pDel = (*pOH->delF)(pOH)) == 0)
   1ae82:	69a2      	ldr	r2, [r4, #24]
   1ae84:	2a00      	cmp	r2, #0
   1ae86:	d0f6      	beq.n	1ae76 <TCPIP_OAHASH_EntryLookupOrInsert+0x22>
   1ae88:	4620      	mov	r0, r4
   1ae8a:	4790      	blx	r2
   1ae8c:	4603      	mov	r3, r0
   1ae8e:	2800      	cmp	r0, #0
   1ae90:	d0f1      	beq.n	1ae76 <TCPIP_OAHASH_EntryLookupOrInsert+0x22>
    if(pOE->flags.busy)
   1ae92:	7802      	ldrb	r2, [r0, #0]
   1ae94:	f012 0f01 	tst.w	r2, #1
   1ae98:	d006      	beq.n	1aea8 <TCPIP_OAHASH_EntryLookupOrInsert+0x54>
        pOE->flags.busy = 0;
   1ae9a:	7802      	ldrb	r2, [r0, #0]
   1ae9c:	f36f 0200 	bfc	r2, #0, #1
   1aea0:	7002      	strb	r2, [r0, #0]
        pOH->fullSlots--;
   1aea2:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1aea4:	3b01      	subs	r3, #1
   1aea6:	6263      	str	r3, [r4, #36]	; 0x24
        pBkt = _OAHashFindBkt(pOH, key);
   1aea8:	4629      	mov	r1, r5
   1aeaa:	4620      	mov	r0, r4
   1aeac:	f7fd fd82 	bl	189b4 <_OAHashFindBkt>
        if(pBkt == 0)
   1aeb0:	4603      	mov	r3, r0
   1aeb2:	2800      	cmp	r0, #0
   1aeb4:	d1d5      	bne.n	1ae62 <TCPIP_OAHASH_EntryLookupOrInsert+0xe>
   1aeb6:	e7de      	b.n	1ae76 <TCPIP_OAHASH_EntryLookupOrInsert+0x22>

Disassembly of section .text.TCPIP_STACK_BringNetDown%484:

0001aeb8 <TCPIP_STACK_BringNetDown>:
{
   1aeb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1aeba:	4605      	mov	r5, r0
   1aebc:	460e      	mov	r6, r1
    stackCtrlData->pNetIf = pNetIf;
   1aebe:	6141      	str	r1, [r0, #20]
    stackCtrlData->netIx = pNetIf->netIfIx;
   1aec0:	f8b1 1058 	ldrh.w	r1, [r1, #88]	; 0x58
   1aec4:	6181      	str	r1, [r0, #24]
    stackCtrlData->stackAction = action;
   1aec6:	7702      	strb	r2, [r0, #28]
    stackCtrlData->powerMode = powerMode;
   1aec8:	7743      	strb	r3, [r0, #29]
    pEntry = TCPIP_STACK_MODULE_ENTRY_TBL + sizeof(TCPIP_STACK_MODULE_ENTRY_TBL)/sizeof(*TCPIP_STACK_MODULE_ENTRY_TBL);
   1aeca:	4c13      	ldr	r4, [pc, #76]	; (1af18 <TCPIP_STACK_BringNetDown+0x60>)
    while (pEntry != TCPIP_STACK_MODULE_ENTRY_TBL);
   1aecc:	f1a4 076c 	sub.w	r7, r4, #108	; 0x6c
        pEntry--;
   1aed0:	3c0c      	subs	r4, #12
        pEntry->deInitFunc(stackCtrlData);
   1aed2:	68a3      	ldr	r3, [r4, #8]
   1aed4:	4628      	mov	r0, r5
   1aed6:	4798      	blx	r3
    while (pEntry != TCPIP_STACK_MODULE_ENTRY_TBL);
   1aed8:	42bc      	cmp	r4, r7
   1aeda:	d1f9      	bne.n	1aed0 <TCPIP_STACK_BringNetDown+0x18>
    _TCPIPStackModuleRxPurge(TCPIP_MODULE_MANAGER, pNetIf);
   1aedc:	4631      	mov	r1, r6
   1aede:	2001      	movs	r0, #1
   1aee0:	f7fd fa64 	bl	183ac <_TCPIPStackModuleRxPurge>
        if(pNetIf->hIfMac != 0)
   1aee4:	6d30      	ldr	r0, [r6, #80]	; 0x50
   1aee6:	b110      	cbz	r0, 1aeee <TCPIP_STACK_BringNetDown+0x36>
            (*pNetIf->pMacObj->TCPIP_MAC_Close)(pNetIf->hIfMac);
   1aee8:	6c73      	ldr	r3, [r6, #68]	; 0x44
   1aeea:	6a1b      	ldr	r3, [r3, #32]
   1aeec:	4798      	blx	r3
        if(pNetIf->macObjHandle != 0)
   1aeee:	6cf0      	ldr	r0, [r6, #76]	; 0x4c
   1aef0:	b110      	cbz	r0, 1aef8 <TCPIP_STACK_BringNetDown+0x40>
            (*pNetIf->pMacObj->TCPIP_MAC_Deinitialize)(pNetIf->macObjHandle);
   1aef2:	6c73      	ldr	r3, [r6, #68]	; 0x44
   1aef4:	68db      	ldr	r3, [r3, #12]
   1aef6:	4798      	blx	r3
    pNetIf->hIfMac = 0;
   1aef8:	2300      	movs	r3, #0
   1aefa:	6533      	str	r3, [r6, #80]	; 0x50
    pNetIf->macObjHandle = 0;
   1aefc:	64f3      	str	r3, [r6, #76]	; 0x4c
    pNetIf->Flags.bInterfaceEnabled = pNetIf->Flags.bMacInitialize = false;
   1aefe:	f896 2043 	ldrb.w	r2, [r6, #67]	; 0x43
   1af02:	f363 1286 	bfi	r2, r3, #6, #1
   1af06:	f886 2043 	strb.w	r2, [r6, #67]	; 0x43
   1af0a:	f896 2042 	ldrb.w	r2, [r6, #66]	; 0x42
   1af0e:	f363 1286 	bfi	r2, r3, #6, #1
   1af12:	f886 2042 	strb.w	r2, [r6, #66]	; 0x42
}
   1af16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1af18:	0001a700 	.word	0x0001a700

Disassembly of section .text.TCPIP_UDP_SocketInfoGet%485:

0001af1c <TCPIP_UDP_SocketInfoGet>:
{
   1af1c:	b538      	push	{r3, r4, r5, lr}
   1af1e:	460c      	mov	r4, r1
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1af20:	f004 ffe0 	bl	1fee4 <_UDPSocketDcpt>
    if(pSkt == 0 || pInfo == 0)
   1af24:	b340      	cbz	r0, 1af78 <TCPIP_UDP_SocketInfoGet+0x5c>
   1af26:	4605      	mov	r5, r0
   1af28:	b344      	cbz	r4, 1af7c <TCPIP_UDP_SocketInfoGet+0x60>
    memset(pInfo, 0, sizeof(*pInfo));
   1af2a:	2250      	movs	r2, #80	; 0x50
   1af2c:	2100      	movs	r1, #0
   1af2e:	4620      	mov	r0, r4
   1af30:	f006 fe24 	bl	21b7c <memset>
        if (pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   1af34:	8fab      	ldrh	r3, [r5, #60]	; 0x3c
   1af36:	2b01      	cmp	r3, #1
   1af38:	d013      	beq.n	1af62 <TCPIP_UDP_SocketInfoGet+0x46>
        pInfo->addressType = IP_ADDRESS_TYPE_ANY;
   1af3a:	2300      	movs	r3, #0
   1af3c:	7023      	strb	r3, [r4, #0]
	pInfo->remotePort = pSkt->remotePort;
   1af3e:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
   1af40:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
	pInfo->localPort = pSkt->localPort;
   1af44:	8d6b      	ldrh	r3, [r5, #42]	; 0x2a
   1af46:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
    pInfo->hNet = pSkt->pSktNet;
   1af4a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1af4c:	64a3      	str	r3, [r4, #72]	; 0x48
    pInfo->rxQueueSize = TCPIP_Helper_SingleListCount(&pSkt->rxQueue);
   1af4e:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   1af50:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    pInfo->txSize = pSkt->txEnd - pSkt->txStart;
   1af54:	686b      	ldr	r3, [r5, #4]
   1af56:	682a      	ldr	r2, [r5, #0]
   1af58:	1a9b      	subs	r3, r3, r2
   1af5a:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
	return true;
   1af5e:	2001      	movs	r0, #1
}
   1af60:	bd38      	pop	{r3, r4, r5, pc}
            pInfo->remoteIPaddress.v4Add.Val = pSkt->destAddress.Val;
   1af62:	696b      	ldr	r3, [r5, #20]
   1af64:	6063      	str	r3, [r4, #4]
            pInfo->localIPaddress.v4Add.Val = pSkt->srcAddress.Val;
   1af66:	69ab      	ldr	r3, [r5, #24]
   1af68:	6163      	str	r3, [r4, #20]
            pInfo->sourceIPaddress.v4Add.Val = pSkt->pktSrcAddress.Val;
   1af6a:	69eb      	ldr	r3, [r5, #28]
   1af6c:	6263      	str	r3, [r4, #36]	; 0x24
            pInfo->destIPaddress.v4Add.Val = pSkt->pktDestAddress.Val;
   1af6e:	6a2b      	ldr	r3, [r5, #32]
   1af70:	6363      	str	r3, [r4, #52]	; 0x34
            pInfo->addressType = IP_ADDRESS_TYPE_IPV4;
   1af72:	2301      	movs	r3, #1
   1af74:	7023      	strb	r3, [r4, #0]
            break;
   1af76:	e7e2      	b.n	1af3e <TCPIP_UDP_SocketInfoGet+0x22>
        return false;
   1af78:	2000      	movs	r0, #0
   1af7a:	e7f1      	b.n	1af60 <TCPIP_UDP_SocketInfoGet+0x44>
   1af7c:	2000      	movs	r0, #0
   1af7e:	e7ef      	b.n	1af60 <TCPIP_UDP_SocketInfoGet+0x44>

Disassembly of section .rodata%486:

0001af80 <.rodata%486>:
   1af80:	43414d47 	.word	0x43414d47
   1af84:	00000000 	.word	0x00000000
   1af88:	5048434d 	.word	0x5048434d
   1af8c:	52414f42 	.word	0x52414f42
   1af90:	00435f44 	.word	0x00435f44
   1af94:	303a3030 	.word	0x303a3030
   1af98:	35323a34 	.word	0x35323a34
   1af9c:	3a43313a 	.word	0x3a43313a
   1afa0:	303a3041 	.word	0x303a3041
   1afa4:	00000033 	.word	0x00000033
   1afa8:	2e323931 	.word	0x2e323931
   1afac:	2e383631 	.word	0x2e383631
   1afb0:	30322e31 	.word	0x30322e31
   1afb4:	00000030 	.word	0x00000030
   1afb8:	2e353532 	.word	0x2e353532
   1afbc:	2e353532 	.word	0x2e353532
   1afc0:	2e353532 	.word	0x2e353532
   1afc4:	00000030 	.word	0x00000030
   1afc8:	2e323931 	.word	0x2e323931
   1afcc:	2e383631 	.word	0x2e383631
   1afd0:	00312e31 	.word	0x00312e31
   1afd4:	2e302e30 	.word	0x2e302e30
   1afd8:	00302e30 	.word	0x00302e30
   1afdc:	6c6c7566 	.word	0x6c6c7566
   1afe0:	00          	.byte	0x00
   1afe1:	00          	.byte	0x00
   1afe2:	bf00      	nop

Disassembly of section .text.xPortPendSVHandler%487:

0001aff0 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
   1aff0:	f3ef 8009 	mrs	r0, PSP
   1aff4:	f3bf 8f6f 	isb	sy
   1aff8:	4b15      	ldr	r3, [pc, #84]	; (1b050 <pxCurrentTCBConst>)
   1affa:	681a      	ldr	r2, [r3, #0]
   1affc:	f01e 0f10 	tst.w	lr, #16
   1b000:	bf08      	it	eq
   1b002:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
   1b006:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b00a:	6010      	str	r0, [r2, #0]
   1b00c:	e92d 0009 	stmdb	sp!, {r0, r3}
   1b010:	f04f 0020 	mov.w	r0, #32
   1b014:	f380 8811 	msr	BASEPRI, r0
   1b018:	f3bf 8f4f 	dsb	sy
   1b01c:	f3bf 8f6f 	isb	sy
   1b020:	f7fc f89c 	bl	1715c <vTaskSwitchContext>
   1b024:	f04f 0000 	mov.w	r0, #0
   1b028:	f380 8811 	msr	BASEPRI, r0
   1b02c:	bc09      	pop	{r0, r3}
   1b02e:	6819      	ldr	r1, [r3, #0]
   1b030:	6808      	ldr	r0, [r1, #0]
   1b032:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b036:	f01e 0f10 	tst.w	lr, #16
   1b03a:	bf08      	it	eq
   1b03c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
   1b040:	f380 8809 	msr	PSP, r0
   1b044:	f3bf 8f6f 	isb	sy
   1b048:	4770      	bx	lr
   1b04a:	bf00      	nop
   1b04c:	f3af 8000 	nop.w

0001b050 <pxCurrentTCBConst>:
   1b050:	2000e6a4 	.word	0x2000e6a4

Disassembly of section .text.vTaskStartScheduler%488:

0001b054 <vTaskStartScheduler>:
{
   1b054:	b500      	push	{lr}
   1b056:	b083      	sub	sp, #12
		xReturn = xTaskCreate(	prvIdleTask,
   1b058:	4b11      	ldr	r3, [pc, #68]	; (1b0a0 <vTaskStartScheduler+0x4c>)
   1b05a:	9301      	str	r3, [sp, #4]
   1b05c:	2300      	movs	r3, #0
   1b05e:	9300      	str	r3, [sp, #0]
   1b060:	2280      	movs	r2, #128	; 0x80
   1b062:	4910      	ldr	r1, [pc, #64]	; (1b0a4 <vTaskStartScheduler+0x50>)
   1b064:	4810      	ldr	r0, [pc, #64]	; (1b0a8 <vTaskStartScheduler+0x54>)
   1b066:	f7f4 f823 	bl	f0b0 <xTaskCreate>
	if( xReturn == pdPASS )
   1b06a:	2801      	cmp	r0, #1
   1b06c:	d002      	beq.n	1b074 <vTaskStartScheduler+0x20>
}
   1b06e:	b003      	add	sp, #12
   1b070:	f85d fb04 	ldr.w	pc, [sp], #4

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   1b074:	f04f 0320 	mov.w	r3, #32
   1b078:	f383 8811 	msr	BASEPRI, r3
   1b07c:	f3bf 8f6f 	isb	sy
   1b080:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
   1b084:	4b09      	ldr	r3, [pc, #36]	; (1b0ac <vTaskStartScheduler+0x58>)
   1b086:	f04f 32ff 	mov.w	r2, #4294967295
   1b08a:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
   1b08c:	4b08      	ldr	r3, [pc, #32]	; (1b0b0 <vTaskStartScheduler+0x5c>)
   1b08e:	2201      	movs	r2, #1
   1b090:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
   1b092:	4b08      	ldr	r3, [pc, #32]	; (1b0b4 <vTaskStartScheduler+0x60>)
   1b094:	2200      	movs	r2, #0
   1b096:	601a      	str	r2, [r3, #0]
		if( xPortStartScheduler() != pdFALSE )
   1b098:	f001 fe8a 	bl	1cdb0 <xPortStartScheduler>
}
   1b09c:	e7e7      	b.n	1b06e <vTaskStartScheduler+0x1a>
   1b09e:	bf00      	nop
   1b0a0:	2000e6c4 	.word	0x2000e6c4
   1b0a4:	000220dc 	.word	0x000220dc
   1b0a8:	0001a39d 	.word	0x0001a39d
   1b0ac:	2000e6c8 	.word	0x2000e6c8
   1b0b0:	2000e6d4 	.word	0x2000e6d4
   1b0b4:	2000e6d8 	.word	0x2000e6d8

Disassembly of section .text.wc_InitSha256_ex%489:

0001b0b8 <wc_InitSha256_ex>:
        if (sha256 == NULL)
   1b0b8:	4603      	mov	r3, r0
   1b0ba:	b1e8      	cbz	r0, 1b0f8 <wc_InitSha256_ex+0x40>
        sha256->heap = heap;
   1b0bc:	66c1      	str	r1, [r0, #108]	; 0x6c
        sha256->devId = devId;
   1b0be:	6702      	str	r2, [r0, #112]	; 0x70
        sha256->devCtx = NULL;
   1b0c0:	2000      	movs	r0, #0
   1b0c2:	6758      	str	r0, [r3, #116]	; 0x74
    sha256->digest[0] = 0x6A09E667L;
   1b0c4:	4a0e      	ldr	r2, [pc, #56]	; (1b100 <wc_InitSha256_ex+0x48>)
   1b0c6:	601a      	str	r2, [r3, #0]
    sha256->digest[1] = 0xBB67AE85L;
   1b0c8:	4a0e      	ldr	r2, [pc, #56]	; (1b104 <wc_InitSha256_ex+0x4c>)
   1b0ca:	605a      	str	r2, [r3, #4]
    sha256->digest[2] = 0x3C6EF372L;
   1b0cc:	4a0e      	ldr	r2, [pc, #56]	; (1b108 <wc_InitSha256_ex+0x50>)
   1b0ce:	609a      	str	r2, [r3, #8]
    sha256->digest[3] = 0xA54FF53AL;
   1b0d0:	4a0e      	ldr	r2, [pc, #56]	; (1b10c <wc_InitSha256_ex+0x54>)
   1b0d2:	60da      	str	r2, [r3, #12]
    sha256->digest[4] = 0x510E527FL;
   1b0d4:	4a0e      	ldr	r2, [pc, #56]	; (1b110 <wc_InitSha256_ex+0x58>)
   1b0d6:	611a      	str	r2, [r3, #16]
    sha256->digest[5] = 0x9B05688CL;
   1b0d8:	4a0e      	ldr	r2, [pc, #56]	; (1b114 <wc_InitSha256_ex+0x5c>)
   1b0da:	615a      	str	r2, [r3, #20]
    sha256->digest[6] = 0x1F83D9ABL;
   1b0dc:	4a0e      	ldr	r2, [pc, #56]	; (1b118 <wc_InitSha256_ex+0x60>)
   1b0de:	619a      	str	r2, [r3, #24]
    sha256->digest[7] = 0x5BE0CD19L;
   1b0e0:	f102 5274 	add.w	r2, r2, #1023410176	; 0x3d000000
   1b0e4:	f5a2 0223 	sub.w	r2, r2, #10682368	; 0xa30000
   1b0e8:	f6a2 4292 	subw	r2, r2, #3218	; 0xc92
   1b0ec:	61da      	str	r2, [r3, #28]
    sha256->buffLen = 0;
   1b0ee:	6618      	str	r0, [r3, #96]	; 0x60
    sha256->loLen   = 0;
   1b0f0:	6658      	str	r0, [r3, #100]	; 0x64
    sha256->hiLen   = 0;
   1b0f2:	6698      	str	r0, [r3, #104]	; 0x68
    sha256->flags = 0;
   1b0f4:	6798      	str	r0, [r3, #120]	; 0x78
        if (ret != 0)
   1b0f6:	4770      	bx	lr
            return BAD_FUNC_ARG;
   1b0f8:	f06f 00ac 	mvn.w	r0, #172	; 0xac
    }
   1b0fc:	4770      	bx	lr
   1b0fe:	bf00      	nop
   1b100:	6a09e667 	.word	0x6a09e667
   1b104:	bb67ae85 	.word	0xbb67ae85
   1b108:	3c6ef372 	.word	0x3c6ef372
   1b10c:	a54ff53a 	.word	0xa54ff53a
   1b110:	510e527f 	.word	0x510e527f
   1b114:	9b05688c 	.word	0x9b05688c
   1b118:	1f83d9ab 	.word	0x1f83d9ab

Disassembly of section .text.TCPIP_ARP_EntryGet%490:

0001b11c <TCPIP_ARP_EntryGet>:
    if(ipAdd == 0 || ipAdd->Val == 0)
   1b11c:	b319      	cbz	r1, 1b166 <TCPIP_ARP_EntryGet+0x4a>
{   
   1b11e:	b510      	push	{r4, lr}
   1b120:	b082      	sub	sp, #8
   1b122:	460c      	mov	r4, r1
    if(ipAdd == 0 || ipAdd->Val == 0)
   1b124:	6809      	ldr	r1, [r1, #0]
   1b126:	b309      	cbz	r1, 1b16c <TCPIP_ARP_EntryGet+0x50>
   1b128:	b318      	cbz	r0, 1b172 <TCPIP_ARP_EntryGet+0x56>
   1b12a:	f890 1042 	ldrb.w	r1, [r0, #66]	; 0x42
   1b12e:	f011 0f40 	tst.w	r1, #64	; 0x40
   1b132:	d103      	bne.n	1b13c <TCPIP_ARP_EntryGet+0x20>
        return ARP_RES_NO_INTERFACE;
   1b134:	f06f 0005 	mvn.w	r0, #5
}
   1b138:	b002      	add	sp, #8
   1b13a:	bd10      	pop	{r4, pc}
   1b13c:	4621      	mov	r1, r4
    if(probe)
   1b13e:	b153      	cbz	r3, 1b156 <TCPIP_ARP_EntryGet+0x3a>
    return pNetIf->Flags.bInConfig != 0;
   1b140:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
        if(_TCPIPStackIsConfig(pIf))
   1b144:	f013 0f10 	tst.w	r3, #16
   1b148:	d116      	bne.n	1b178 <TCPIP_ARP_EntryGet+0x5c>
        return _ARPProbeAddress(pIf, ipAdd, &pIf->netIPAddr, ARP_OPERATION_REQ, pHwAdd);
   1b14a:	9200      	str	r2, [sp, #0]
   1b14c:	2301      	movs	r3, #1
   1b14e:	1d02      	adds	r2, r0, #4
   1b150:	f7f9 fb56 	bl	14800 <_ARPProbeAddress>
   1b154:	e7f0      	b.n	1b138 <TCPIP_ARP_EntryGet+0x1c>
        return (TCPIP_ARP_IsResolved(pIf, ipAdd, pHwAdd))? ARP_RES_ENTRY_SOLVED : ARP_RES_NO_ENTRY;
   1b156:	f7fd f805 	bl	18164 <TCPIP_ARP_IsResolved>
   1b15a:	2800      	cmp	r0, #0
   1b15c:	bf14      	ite	ne
   1b15e:	2002      	movne	r0, #2
   1b160:	f04f 30ff 	moveq.w	r0, #4294967295
   1b164:	e7e8      	b.n	1b138 <TCPIP_ARP_EntryGet+0x1c>
        return ARP_RES_BAD_ADDRESS;
   1b166:	f06f 0004 	mvn.w	r0, #4
}
   1b16a:	4770      	bx	lr
        return ARP_RES_BAD_ADDRESS;
   1b16c:	f06f 0004 	mvn.w	r0, #4
   1b170:	e7e2      	b.n	1b138 <TCPIP_ARP_EntryGet+0x1c>
        return ARP_RES_NO_INTERFACE;
   1b172:	f06f 0005 	mvn.w	r0, #5
   1b176:	e7df      	b.n	1b138 <TCPIP_ARP_EntryGet+0x1c>
            return ARP_RES_CONFIGURE_ERR;
   1b178:	f06f 0007 	mvn.w	r0, #7
   1b17c:	e7dc      	b.n	1b138 <TCPIP_ARP_EntryGet+0x1c>

Disassembly of section .text._PingStop%491:

0001b180 <_PingStop>:
{
   1b180:	b538      	push	{r3, r4, r5, lr}
   1b182:	4604      	mov	r4, r0
   1b184:	460d      	mov	r5, r1
    if(icmpReqHandle != 0)
   1b186:	4b0f      	ldr	r3, [pc, #60]	; (1b1c4 <_PingStop+0x44>)
   1b188:	6818      	ldr	r0, [r3, #0]
   1b18a:	b120      	cbz	r0, 1b196 <_PingStop+0x16>
        TCPIP_ICMP_EchoRequestCancel(icmpReqHandle);
   1b18c:	f005 f8b6 	bl	202fc <TCPIP_ICMP_EchoRequestCancel>
        icmpReqHandle = 0;
   1b190:	4b0c      	ldr	r3, [pc, #48]	; (1b1c4 <_PingStop+0x44>)
   1b192:	2200      	movs	r2, #0
   1b194:	601a      	str	r2, [r3, #0]
    _TCPIPStackSignalHandlerSetParams(TCPIP_THIS_MODULE_ID, tcpipCmdSignalHandle, 0);
   1b196:	2200      	movs	r2, #0
   1b198:	4b0b      	ldr	r3, [pc, #44]	; (1b1c8 <_PingStop+0x48>)
   1b19a:	6819      	ldr	r1, [r3, #0]
   1b19c:	201f      	movs	r0, #31
   1b19e:	f004 fe8d 	bl	1febc <_TCPIPStackSignalHandlerSetParams>
    tcpipCmdStat = TCPIP_CMD_STAT_IDLE;
   1b1a2:	4b0a      	ldr	r3, [pc, #40]	; (1b1cc <_PingStop+0x4c>)
   1b1a4:	2200      	movs	r2, #0
   1b1a6:	701a      	strb	r2, [r3, #0]
    if(pCmdIO)
   1b1a8:	b144      	cbz	r4, 1b1bc <_PingStop+0x3c>
        (*pCmdIO->pCmdApi->print)(cmdIoParam, "Ping: done. Sent %d requests, received %d replies.\r\n", icmpReqCount, icmpAckRecv);
   1b1aa:	6823      	ldr	r3, [r4, #0]
   1b1ac:	685c      	ldr	r4, [r3, #4]
   1b1ae:	4b08      	ldr	r3, [pc, #32]	; (1b1d0 <_PingStop+0x50>)
   1b1b0:	681b      	ldr	r3, [r3, #0]
   1b1b2:	4a08      	ldr	r2, [pc, #32]	; (1b1d4 <_PingStop+0x54>)
   1b1b4:	6812      	ldr	r2, [r2, #0]
   1b1b6:	4908      	ldr	r1, [pc, #32]	; (1b1d8 <_PingStop+0x58>)
   1b1b8:	4628      	mov	r0, r5
   1b1ba:	47a0      	blx	r4
    pTcpipCmdDevice = 0;
   1b1bc:	4b07      	ldr	r3, [pc, #28]	; (1b1dc <_PingStop+0x5c>)
   1b1be:	2200      	movs	r2, #0
   1b1c0:	601a      	str	r2, [r3, #0]
}
   1b1c2:	bd38      	pop	{r3, r4, r5, pc}
   1b1c4:	2000e5d0 	.word	0x2000e5d0
   1b1c8:	2000e5ec 	.word	0x2000e5ec
   1b1cc:	2000e3af 	.word	0x2000e3af
   1b1d0:	2000e5bc 	.word	0x2000e5bc
   1b1d4:	2000e5c8 	.word	0x2000e5c8
   1b1d8:	000009e8 	.word	0x000009e8
   1b1dc:	2000e5e8 	.word	0x2000e5e8

Disassembly of section .text.Ipv4FilterSetActive%492:

0001b1e0 <Ipv4FilterSetActive>:
{
   1b1e0:	b570      	push	{r4, r5, r6, lr}
   1b1e2:	4604      	mov	r4, r0
   1b1e4:	460e      	mov	r6, r1
    TCPIP_Helper_ProtectedSingleListLock(notifyList);
   1b1e6:	4d14      	ldr	r5, [pc, #80]	; (1b238 <Ipv4FilterSetActive+0x58>)
   1b1e8:	4628      	mov	r0, r5
   1b1ea:	f005 fbc1 	bl	20970 <TCPIP_Helper_ProtectedSingleListLock>
    for(fNode = (IPV4_FILTER_LIST_NODE*)ipv4PacketFilters.list.head; fNode != 0; fNode = fNode->next)
   1b1ee:	682b      	ldr	r3, [r5, #0]
   1b1f0:	b1eb      	cbz	r3, 1b22e <Ipv4FilterSetActive+0x4e>
        if(fNode == (IPV4_FILTER_LIST_NODE*)hFilter)
   1b1f2:	42a3      	cmp	r3, r4
   1b1f4:	d00e      	beq.n	1b214 <Ipv4FilterSetActive+0x34>
    for(fNode = (IPV4_FILTER_LIST_NODE*)ipv4PacketFilters.list.head; fNode != 0; fNode = fNode->next)
   1b1f6:	681b      	ldr	r3, [r3, #0]
   1b1f8:	b19b      	cbz	r3, 1b222 <Ipv4FilterSetActive+0x42>
        if(fNode == (IPV4_FILTER_LIST_NODE*)hFilter)
   1b1fa:	429c      	cmp	r4, r3
   1b1fc:	d1fb      	bne.n	1b1f6 <Ipv4FilterSetActive+0x16>
            if(fNode->active != active)
   1b1fe:	7a1a      	ldrb	r2, [r3, #8]
   1b200:	42b2      	cmp	r2, r6
   1b202:	d016      	beq.n	1b232 <Ipv4FilterSetActive+0x52>
                if(active)
   1b204:	b146      	cbz	r6, 1b218 <Ipv4FilterSetActive+0x38>
                    ipv4ActFilterCount++;
   1b206:	490d      	ldr	r1, [pc, #52]	; (1b23c <Ipv4FilterSetActive+0x5c>)
   1b208:	680a      	ldr	r2, [r1, #0]
   1b20a:	3201      	adds	r2, #1
   1b20c:	600a      	str	r2, [r1, #0]
                fNode->active = active;
   1b20e:	721e      	strb	r6, [r3, #8]
                activeOk = true;
   1b210:	2401      	movs	r4, #1
   1b212:	e007      	b.n	1b224 <Ipv4FilterSetActive+0x44>
    for(fNode = (IPV4_FILTER_LIST_NODE*)ipv4PacketFilters.list.head; fNode != 0; fNode = fNode->next)
   1b214:	4623      	mov	r3, r4
   1b216:	e7f2      	b.n	1b1fe <Ipv4FilterSetActive+0x1e>
                    ipv4ActFilterCount--;
   1b218:	4908      	ldr	r1, [pc, #32]	; (1b23c <Ipv4FilterSetActive+0x5c>)
   1b21a:	680a      	ldr	r2, [r1, #0]
   1b21c:	3a01      	subs	r2, #1
   1b21e:	600a      	str	r2, [r1, #0]
   1b220:	e7f5      	b.n	1b20e <Ipv4FilterSetActive+0x2e>
    bool activeOk = false;
   1b222:	2400      	movs	r4, #0
    TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
   1b224:	4804      	ldr	r0, [pc, #16]	; (1b238 <Ipv4FilterSetActive+0x58>)
   1b226:	f005 fdf5 	bl	20e14 <TCPIP_Helper_ProtectedSingleListUnlock>
}
   1b22a:	4620      	mov	r0, r4
   1b22c:	bd70      	pop	{r4, r5, r6, pc}
    bool activeOk = false;
   1b22e:	2400      	movs	r4, #0
   1b230:	e7f8      	b.n	1b224 <Ipv4FilterSetActive+0x44>
   1b232:	2400      	movs	r4, #0
   1b234:	e7f6      	b.n	1b224 <Ipv4FilterSetActive+0x44>
   1b236:	bf00      	nop
   1b238:	2000e43c 	.word	0x2000e43c
   1b23c:	2000e5fc 	.word	0x2000e5fc

Disassembly of section .text._DHCPOptionProcessDns%493:

0001b240 <_DHCPOptionProcessDns>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_DNS1))
   1b240:	684b      	ldr	r3, [r1, #4]
   1b242:	2b05      	cmp	r3, #5
   1b244:	d923      	bls.n	1b28e <_DHCPOptionProcessDns+0x4e>
        TCPIP_DHCP_OPTION_DATA_DNS* pDns = (TCPIP_DHCP_OPTION_DATA_DNS*)pOptData->pOpt;
   1b246:	680b      	ldr	r3, [r1, #0]
        if((pDns->len & 0x3) == 0 && pDns->len >= sizeof(pDns->dns1))
   1b248:	785a      	ldrb	r2, [r3, #1]
   1b24a:	f012 0f03 	tst.w	r2, #3
   1b24e:	d121      	bne.n	1b294 <_DHCPOptionProcessDns+0x54>
   1b250:	2a03      	cmp	r2, #3
   1b252:	d922      	bls.n	1b29a <_DHCPOptionProcessDns+0x5a>
            if(pClient->flags.bOfferReceived == 0)
   1b254:	f890 2058 	ldrb.w	r2, [r0, #88]	; 0x58
   1b258:	f012 0f04 	tst.w	r2, #4
   1b25c:	d114      	bne.n	1b288 <_DHCPOptionProcessDns+0x48>
                memcpy(&pClient->dhcpDNS, pDns->dns1, sizeof(pClient->dhcpDNS)); 
   1b25e:	f8d3 2002 	ldr.w	r2, [r3, #2]
   1b262:	6382      	str	r2, [r0, #56]	; 0x38
                pClient->validValues.DNS = 1;
   1b264:	f890 2059 	ldrb.w	r2, [r0, #89]	; 0x59
   1b268:	f042 0208 	orr.w	r2, r2, #8
   1b26c:	f880 2059 	strb.w	r2, [r0, #89]	; 0x59
                if(pDns->len >= sizeof(pDns->dns1) + sizeof(pDns->dns2))
   1b270:	785a      	ldrb	r2, [r3, #1]
   1b272:	2a07      	cmp	r2, #7
   1b274:	d908      	bls.n	1b288 <_DHCPOptionProcessDns+0x48>
                    memcpy(&pClient->dhcpDNS2, pDns->dns2, sizeof(pClient->dhcpDNS2)); 
   1b276:	f8d3 2006 	ldr.w	r2, [r3, #6]
   1b27a:	63c2      	str	r2, [r0, #60]	; 0x3c
                    pClient->validValues.DNS2 = 1;
   1b27c:	f890 2059 	ldrb.w	r2, [r0, #89]	; 0x59
   1b280:	f042 0210 	orr.w	r2, r2, #16
   1b284:	f880 2059 	strb.w	r2, [r0, #89]	; 0x59
            return 2 + pDns->len;
   1b288:	7858      	ldrb	r0, [r3, #1]
   1b28a:	3002      	adds	r0, #2
   1b28c:	4770      	bx	lr
    return -1;
   1b28e:	f04f 30ff 	mov.w	r0, #4294967295
   1b292:	4770      	bx	lr
   1b294:	f04f 30ff 	mov.w	r0, #4294967295
   1b298:	4770      	bx	lr
   1b29a:	f04f 30ff 	mov.w	r0, #4294967295
}
   1b29e:	4770      	bx	lr

Disassembly of section .text.TCPIP_DHCP_Disable%494:

0001b2a0 <TCPIP_DHCP_Disable>:
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   1b2a0:	b1c0      	cbz	r0, 1b2d4 <TCPIP_DHCP_Disable+0x34>
{
   1b2a2:	b538      	push	{r3, r4, r5, lr}
   1b2a4:	4604      	mov	r4, r0
   1b2a6:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1b2aa:	f012 0f40 	tst.w	r2, #64	; 0x40
   1b2ae:	d113      	bne.n	1b2d8 <TCPIP_DHCP_Disable+0x38>
    return false;
   1b2b0:	2000      	movs	r0, #0
}
   1b2b2:	bd38      	pop	{r3, r4, r5, pc}
            _DHCPClientClose(pNetIf, true, true);
   1b2b4:	2201      	movs	r2, #1
   1b2b6:	4611      	mov	r1, r2
   1b2b8:	4620      	mov	r0, r4
   1b2ba:	f7fd f997 	bl	185ec <_DHCPClientClose>
            TCPIP_STACK_AddressServiceEvent(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_DHCPC, TCPIP_STACK_ADDRESS_SERVICE_EVENT_USER_STOP);
   1b2be:	2203      	movs	r2, #3
   1b2c0:	2101      	movs	r1, #1
   1b2c2:	4620      	mov	r0, r4
   1b2c4:	f002 f830 	bl	1d328 <TCPIP_STACK_AddressServiceEvent>
            _DHCPNotifyClients(pNetIf, DHCP_EVENT_SERVICE_DISABLED);
   1b2c8:	210d      	movs	r1, #13
   1b2ca:	4620      	mov	r0, r4
   1b2cc:	f002 fe12 	bl	1def4 <_DHCPNotifyClients>
        return true;
   1b2d0:	2001      	movs	r0, #1
   1b2d2:	e7ee      	b.n	1b2b2 <TCPIP_DHCP_Disable+0x12>
    return false;
   1b2d4:	2000      	movs	r0, #0
}
   1b2d6:	4770      	bx	lr
    if(DHCPClients && pNetIf)
   1b2d8:	4a08      	ldr	r2, [pc, #32]	; (1b2fc <TCPIP_DHCP_Disable+0x5c>)
   1b2da:	6815      	ldr	r5, [r2, #0]
   1b2dc:	b165      	cbz	r5, 1b2f8 <TCPIP_DHCP_Disable+0x58>
        DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   1b2de:	4620      	mov	r0, r4
   1b2e0:	f006 fc98 	bl	21c14 <TCPIP_STACK_NetIxGet>
        if(pClient->flags.bDHCPEnabled != 0)
   1b2e4:	235c      	movs	r3, #92	; 0x5c
   1b2e6:	fb03 5000 	mla	r0, r3, r0, r5
   1b2ea:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   1b2ee:	f013 0f01 	tst.w	r3, #1
   1b2f2:	d1df      	bne.n	1b2b4 <TCPIP_DHCP_Disable+0x14>
        return true;
   1b2f4:	2001      	movs	r0, #1
   1b2f6:	e7dc      	b.n	1b2b2 <TCPIP_DHCP_Disable+0x12>
    return false;
   1b2f8:	2000      	movs	r0, #0
   1b2fa:	e7da      	b.n	1b2b2 <TCPIP_DHCP_Disable+0x12>
   1b2fc:	2000e610 	.word	0x2000e610

Disassembly of section .text.TCPIP_DNS_ClientDeinitialize%495:

0001b300 <TCPIP_DNS_ClientDeinitialize>:
    if(dnsInitCount > 0)
   1b300:	4b15      	ldr	r3, [pc, #84]	; (1b358 <TCPIP_DNS_ClientDeinitialize+0x58>)
   1b302:	681b      	ldr	r3, [r3, #0]
   1b304:	2b00      	cmp	r3, #0
   1b306:	dc00      	bgt.n	1b30a <TCPIP_DNS_ClientDeinitialize+0xa>
   1b308:	4770      	bx	lr
{
   1b30a:	b530      	push	{r4, r5, lr}
   1b30c:	b095      	sub	sp, #84	; 0x54
   1b30e:	4604      	mov	r4, r0
        TCPIP_DNS_DCPT* pDnsDcpt = pgDnsDcpt;
   1b310:	4b12      	ldr	r3, [pc, #72]	; (1b35c <TCPIP_DNS_ClientDeinitialize+0x5c>)
   1b312:	681d      	ldr	r5, [r3, #0]
        if(TCPIP_UDP_SocketInfoGet(pDnsDcpt->dnsSocket, &sktInfo))
   1b314:	4669      	mov	r1, sp
   1b316:	f9b5 0024 	ldrsh.w	r0, [r5, #36]	; 0x24
   1b31a:	f7ff fdff 	bl	1af1c <TCPIP_UDP_SocketInfoGet>
   1b31e:	b118      	cbz	r0, 1b328 <TCPIP_DNS_ClientDeinitialize+0x28>
            if(sktInfo.hNet == stackData->pNetIf)
   1b320:	6963      	ldr	r3, [r4, #20]
   1b322:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1b324:	429a      	cmp	r2, r3
   1b326:	d004      	beq.n	1b332 <TCPIP_DNS_ClientDeinitialize+0x32>
        if(stackData->stackAction == TCPIP_STACK_ACTION_DEINIT)
   1b328:	7f23      	ldrb	r3, [r4, #28]
   1b32a:	2b02      	cmp	r3, #2
   1b32c:	d007      	beq.n	1b33e <TCPIP_DNS_ClientDeinitialize+0x3e>
}
   1b32e:	b015      	add	sp, #84	; 0x54
   1b330:	bd30      	pop	{r4, r5, pc}
                TCPIP_UDP_Disconnect(pDnsDcpt->dnsSocket, true);
   1b332:	2101      	movs	r1, #1
   1b334:	f9b5 0024 	ldrsh.w	r0, [r5, #36]	; 0x24
   1b338:	f7fc f9f2 	bl	17720 <TCPIP_UDP_Disconnect>
   1b33c:	e7f4      	b.n	1b328 <TCPIP_DNS_ClientDeinitialize+0x28>
            if(--dnsInitCount == 0)
   1b33e:	4a06      	ldr	r2, [pc, #24]	; (1b358 <TCPIP_DNS_ClientDeinitialize+0x58>)
   1b340:	6813      	ldr	r3, [r2, #0]
   1b342:	3b01      	subs	r3, #1
   1b344:	6013      	str	r3, [r2, #0]
   1b346:	2b00      	cmp	r3, #0
   1b348:	d1f1      	bne.n	1b32e <TCPIP_DNS_ClientDeinitialize+0x2e>
                _DNSClientCleanup(pDnsDcpt);
   1b34a:	4628      	mov	r0, r5
   1b34c:	f004 f910 	bl	1f570 <_DNSClientCleanup>
                pgDnsDcpt = 0;
   1b350:	4b02      	ldr	r3, [pc, #8]	; (1b35c <TCPIP_DNS_ClientDeinitialize+0x5c>)
   1b352:	2200      	movs	r2, #0
   1b354:	601a      	str	r2, [r3, #0]
}
   1b356:	e7ea      	b.n	1b32e <TCPIP_DNS_ClientDeinitialize+0x2e>
   1b358:	2000e628 	.word	0x2000e628
   1b35c:	2000e62c 	.word	0x2000e62c

Disassembly of section .text.TCPIP_DNS_GetIPAddressesNumber%496:

0001b360 <TCPIP_DNS_GetIPAddressesNumber>:
    pDnsDcpt = pgDnsDcpt;
   1b360:	4b16      	ldr	r3, [pc, #88]	; (1b3bc <TCPIP_DNS_GetIPAddressesNumber+0x5c>)
   1b362:	681b      	ldr	r3, [r3, #0]
    if(pDnsDcpt == 0 || hostName == 0)
   1b364:	b313      	cbz	r3, 1b3ac <TCPIP_DNS_GetIPAddressesNumber+0x4c>
{
   1b366:	b510      	push	{r4, lr}
   1b368:	460c      	mov	r4, r1
    if(pDnsDcpt == 0 || hostName == 0)
   1b36a:	b308      	cbz	r0, 1b3b0 <TCPIP_DNS_GetIPAddressesNumber+0x50>
    if(type == IP_ADDRESS_TYPE_IPV4)
   1b36c:	2901      	cmp	r1, #1
   1b36e:	d003      	beq.n	1b378 <TCPIP_DNS_GetIPAddressesNumber+0x18>
        recMask = TCPIP_DNS_ADDRESS_REC_IPV4 | TCPIP_DNS_ADDRESS_REC_IPV6;
   1b370:	2902      	cmp	r1, #2
   1b372:	bf0c      	ite	eq
   1b374:	460c      	moveq	r4, r1
   1b376:	2403      	movne	r4, #3
    hE = TCPIP_OAHASH_EntryLookup(pDnsDcpt->hashDcpt, hostName);
   1b378:	4601      	mov	r1, r0
   1b37a:	6818      	ldr	r0, [r3, #0]
   1b37c:	f7ff fb6a 	bl	1aa54 <TCPIP_OAHASH_EntryLookup>
    if(hE != 0)
   1b380:	4603      	mov	r3, r0
   1b382:	b1b8      	cbz	r0, 1b3b4 <TCPIP_DNS_GetIPAddressesNumber+0x54>
        if(hE->flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE)
   1b384:	8802      	ldrh	r2, [r0, #0]
   1b386:	f012 0f80 	tst.w	r2, #128	; 0x80
   1b38a:	d015      	beq.n	1b3b8 <TCPIP_DNS_GetIPAddressesNumber+0x58>
            if(((dnsHashEntry->recordMask & recMask) & TCPIP_DNS_ADDRESS_REC_IPV4) != 0)
   1b38c:	f890 202a 	ldrb.w	r2, [r0, #42]	; 0x2a
   1b390:	4014      	ands	r4, r2
   1b392:	f014 0f01 	tst.w	r4, #1
                nAddresses += dnsHashEntry->nIPv4Entries;
   1b396:	bf14      	ite	ne
   1b398:	f890 0026 	ldrbne.w	r0, [r0, #38]	; 0x26
    nAddresses = 0;
   1b39c:	2000      	moveq	r0, #0
            if(((dnsHashEntry->recordMask & recMask) & TCPIP_DNS_ADDRESS_REC_IPV6) != 0)
   1b39e:	f014 0f02 	tst.w	r4, #2
   1b3a2:	d00a      	beq.n	1b3ba <TCPIP_DNS_GetIPAddressesNumber+0x5a>
                 nAddresses += dnsHashEntry->nIPv6Entries;
   1b3a4:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
   1b3a8:	4418      	add	r0, r3
   1b3aa:	e006      	b.n	1b3ba <TCPIP_DNS_GetIPAddressesNumber+0x5a>
        return 0;
   1b3ac:	2000      	movs	r0, #0
}
   1b3ae:	4770      	bx	lr
        return 0;
   1b3b0:	2000      	movs	r0, #0
   1b3b2:	e002      	b.n	1b3ba <TCPIP_DNS_GetIPAddressesNumber+0x5a>
    nAddresses = 0;
   1b3b4:	2000      	movs	r0, #0
   1b3b6:	e000      	b.n	1b3ba <TCPIP_DNS_GetIPAddressesNumber+0x5a>
   1b3b8:	2000      	movs	r0, #0
}
   1b3ba:	bd10      	pop	{r4, pc}
   1b3bc:	2000e62c 	.word	0x2000e62c

Disassembly of section .text._TCPIP_SelectDefaultNet%497:

0001b3c0 <_TCPIP_SelectDefaultNet>:
    if(tcpipDefIf.defaultNet == 0)
   1b3c0:	4b14      	ldr	r3, [pc, #80]	; (1b414 <_TCPIP_SelectDefaultNet+0x54>)
   1b3c2:	681b      	ldr	r3, [r3, #0]
   1b3c4:	b12b      	cbz	r3, 1b3d2 <_TCPIP_SelectDefaultNet+0x12>
    else if(tcpipDefIf.defaultNet == pDownIf)
   1b3c6:	4283      	cmp	r3, r0
   1b3c8:	d000      	beq.n	1b3cc <_TCPIP_SelectDefaultNet+0xc>
}
   1b3ca:	4770      	bx	lr
        tcpipDefIf.defaultNet = 0;
   1b3cc:	4b11      	ldr	r3, [pc, #68]	; (1b414 <_TCPIP_SelectDefaultNet+0x54>)
   1b3ce:	2200      	movs	r2, #0
   1b3d0:	601a      	str	r2, [r3, #0]
        for(netIx = 0, pIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1b3d2:	4b11      	ldr	r3, [pc, #68]	; (1b418 <_TCPIP_SelectDefaultNet+0x58>)
   1b3d4:	681b      	ldr	r3, [r3, #0]
   1b3d6:	4a11      	ldr	r2, [pc, #68]	; (1b41c <_TCPIP_SelectDefaultNet+0x5c>)
   1b3d8:	6810      	ldr	r0, [r2, #0]
   1b3da:	2800      	cmp	r0, #0
        pNewIf = 0;
   1b3dc:	bfd8      	it	le
   1b3de:	2300      	movle	r3, #0
        for(netIx = 0, pIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1b3e0:	dd14      	ble.n	1b40c <_TCPIP_SelectDefaultNet+0x4c>
            if(pIf->Flags.bInterfaceEnabled)
   1b3e2:	f893 2042 	ldrb.w	r2, [r3, #66]	; 0x42
   1b3e6:	f012 0f40 	tst.w	r2, #64	; 0x40
   1b3ea:	d10b      	bne.n	1b404 <_TCPIP_SelectDefaultNet+0x44>
        for(netIx = 0, pIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1b3ec:	2200      	movs	r2, #0
   1b3ee:	3201      	adds	r2, #1
   1b3f0:	336c      	adds	r3, #108	; 0x6c
   1b3f2:	4282      	cmp	r2, r0
   1b3f4:	d005      	beq.n	1b402 <_TCPIP_SelectDefaultNet+0x42>
            if(pIf->Flags.bInterfaceEnabled)
   1b3f6:	f893 1042 	ldrb.w	r1, [r3, #66]	; 0x42
   1b3fa:	f011 0f40 	tst.w	r1, #64	; 0x40
   1b3fe:	d0f6      	beq.n	1b3ee <_TCPIP_SelectDefaultNet+0x2e>
   1b400:	e000      	b.n	1b404 <_TCPIP_SelectDefaultNet+0x44>
        pNewIf = 0;
   1b402:	2300      	movs	r3, #0
        if(tcpipDefIf.defaultNet == 0)
   1b404:	4a03      	ldr	r2, [pc, #12]	; (1b414 <_TCPIP_SelectDefaultNet+0x54>)
   1b406:	6812      	ldr	r2, [r2, #0]
   1b408:	2a00      	cmp	r2, #0
   1b40a:	d1de      	bne.n	1b3ca <_TCPIP_SelectDefaultNet+0xa>
            tcpipDefIf.defaultNet = pNewIf;
   1b40c:	4a01      	ldr	r2, [pc, #4]	; (1b414 <_TCPIP_SelectDefaultNet+0x54>)
   1b40e:	6013      	str	r3, [r2, #0]
}
   1b410:	4770      	bx	lr
   1b412:	bf00      	nop
   1b414:	2000e644 	.word	0x2000e644
   1b418:	2000e648 	.word	0x2000e648
   1b41c:	2000e2f0 	.word	0x2000e2f0

Disassembly of section .text.gfx_mono_ssd1306_draw_pixel%498:

0001b420 <gfx_mono_ssd1306_draw_pixel>:
    uint8_t page;
    uint8_t pixel_mask;
    uint8_t pixel_value;

    /* Discard pixels drawn outside the screen */
    if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
   1b420:	f010 0f80 	tst.w	r0, #128	; 0x80
   1b424:	d101      	bne.n	1b42a <gfx_mono_ssd1306_draw_pixel+0xa>
   1b426:	291f      	cmp	r1, #31
   1b428:	d900      	bls.n	1b42c <gfx_mono_ssd1306_draw_pixel+0xc>
   1b42a:	4770      	bx	lr
        gfx_coord_t color) {
   1b42c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1b430:	4614      	mov	r4, r2
   1b432:	4605      	mov	r5, r0
        return;
    }

    page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
   1b434:	08ce      	lsrs	r6, r1, #3
    pixel_mask = (1 << (y - (page * 8)));
   1b436:	eba1 01c6 	sub.w	r1, r1, r6, lsl #3
   1b43a:	2201      	movs	r2, #1
   1b43c:	fa02 f701 	lsl.w	r7, r2, r1
   1b440:	fa5f f887 	uxtb.w	r8, r7
    data = gfx_mono_ssd1306_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_ssd1306_get_byte(gfx_coord_t page, gfx_coord_t column) {
#ifdef CONFIG_SSD1306_FRAMEBUFFER
    return gfx_mono_framebuffer_get_byte(page, column);
   1b444:	4601      	mov	r1, r0
   1b446:	4630      	mov	r0, r6
   1b448:	f006 fb70 	bl	21b2c <gfx_mono_framebuffer_get_byte>
   1b44c:	4602      	mov	r2, r0
    switch (color) {
   1b44e:	2c01      	cmp	r4, #1
   1b450:	d00a      	beq.n	1b468 <gfx_mono_ssd1306_draw_pixel+0x48>
   1b452:	b263      	sxtb	r3, r4
   1b454:	b163      	cbz	r3, 1b470 <gfx_mono_ssd1306_draw_pixel+0x50>
   1b456:	2c02      	cmp	r4, #2
   1b458:	d00e      	beq.n	1b478 <gfx_mono_ssd1306_draw_pixel+0x58>
    gfx_mono_put_byte(page, x, pixel_value);
   1b45a:	2300      	movs	r3, #0
   1b45c:	4629      	mov	r1, r5
   1b45e:	4630      	mov	r0, r6
   1b460:	f002 f850 	bl	1d504 <gfx_mono_ssd1306_put_byte>
}
   1b464:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            pixel_value |= pixel_mask;
   1b468:	ea48 0200 	orr.w	r2, r8, r0
   1b46c:	b2d2      	uxtb	r2, r2
            break;
   1b46e:	e7f4      	b.n	1b45a <gfx_mono_ssd1306_draw_pixel+0x3a>
            pixel_value &= ~pixel_mask;
   1b470:	ea20 0207 	bic.w	r2, r0, r7
   1b474:	b2d2      	uxtb	r2, r2
            break;
   1b476:	e7f0      	b.n	1b45a <gfx_mono_ssd1306_draw_pixel+0x3a>
            pixel_value ^= pixel_mask;
   1b478:	ea88 0200 	eor.w	r2, r8, r0
   1b47c:	b2d2      	uxtb	r2, r2
            break;
   1b47e:	e7ec      	b.n	1b45a <gfx_mono_ssd1306_draw_pixel+0x3a>

Disassembly of section .text.__sinit%499:

0001b480 <__sinit>:
   1b480:	6983      	ldr	r3, [r0, #24]
   1b482:	b510      	push	{r4, lr}
   1b484:	4604      	mov	r4, r0
   1b486:	bb33      	cbnz	r3, 1b4d6 <__sinit+0x56>
   1b488:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
   1b48c:	6503      	str	r3, [r0, #80]	; 0x50
   1b48e:	4b12      	ldr	r3, [pc, #72]	; (1b4d8 <__sinit+0x58>)
   1b490:	4a12      	ldr	r2, [pc, #72]	; (1b4dc <__sinit+0x5c>)
   1b492:	681b      	ldr	r3, [r3, #0]
   1b494:	6282      	str	r2, [r0, #40]	; 0x28
   1b496:	4298      	cmp	r0, r3
   1b498:	bf04      	itt	eq
   1b49a:	2301      	moveq	r3, #1
   1b49c:	6183      	streq	r3, [r0, #24]
   1b49e:	f7fe fb73 	bl	19b88 <__sfp>
   1b4a2:	6060      	str	r0, [r4, #4]
   1b4a4:	4620      	mov	r0, r4
   1b4a6:	f7fe fb6f 	bl	19b88 <__sfp>
   1b4aa:	60a0      	str	r0, [r4, #8]
   1b4ac:	4620      	mov	r0, r4
   1b4ae:	f7fe fb6b 	bl	19b88 <__sfp>
   1b4b2:	2200      	movs	r2, #0
   1b4b4:	60e0      	str	r0, [r4, #12]
   1b4b6:	2104      	movs	r1, #4
   1b4b8:	6860      	ldr	r0, [r4, #4]
   1b4ba:	f001 fd09 	bl	1ced0 <std>
   1b4be:	2201      	movs	r2, #1
   1b4c0:	2109      	movs	r1, #9
   1b4c2:	68a0      	ldr	r0, [r4, #8]
   1b4c4:	f001 fd04 	bl	1ced0 <std>
   1b4c8:	2202      	movs	r2, #2
   1b4ca:	2112      	movs	r1, #18
   1b4cc:	68e0      	ldr	r0, [r4, #12]
   1b4ce:	f001 fcff 	bl	1ced0 <std>
   1b4d2:	2301      	movs	r3, #1
   1b4d4:	61a3      	str	r3, [r4, #24]
   1b4d6:	bd10      	pop	{r4, pc}
   1b4d8:	0002215c 	.word	0x0002215c
   1b4dc:	00021f89 	.word	0x00021f89

Disassembly of section .text.__lo0bits%500:

0001b4e0 <__lo0bits>:
   1b4e0:	6803      	ldr	r3, [r0, #0]
   1b4e2:	f013 0207 	ands.w	r2, r3, #7
   1b4e6:	4601      	mov	r1, r0
   1b4e8:	d00b      	beq.n	1b502 <__lo0bits+0x22>
   1b4ea:	07da      	lsls	r2, r3, #31
   1b4ec:	d424      	bmi.n	1b538 <__lo0bits+0x58>
   1b4ee:	0799      	lsls	r1, r3, #30
   1b4f0:	bf4b      	itete	mi
   1b4f2:	085b      	lsrmi	r3, r3, #1
   1b4f4:	089b      	lsrpl	r3, r3, #2
   1b4f6:	6003      	strmi	r3, [r0, #0]
   1b4f8:	6003      	strpl	r3, [r0, #0]
   1b4fa:	bf4c      	ite	mi
   1b4fc:	2001      	movmi	r0, #1
   1b4fe:	2002      	movpl	r0, #2
   1b500:	4770      	bx	lr
   1b502:	b298      	uxth	r0, r3
   1b504:	b9b0      	cbnz	r0, 1b534 <__lo0bits+0x54>
   1b506:	0c1b      	lsrs	r3, r3, #16
   1b508:	2010      	movs	r0, #16
   1b50a:	f013 0fff 	tst.w	r3, #255	; 0xff
   1b50e:	bf04      	itt	eq
   1b510:	0a1b      	lsreq	r3, r3, #8
   1b512:	3008      	addeq	r0, #8
   1b514:	071a      	lsls	r2, r3, #28
   1b516:	bf04      	itt	eq
   1b518:	091b      	lsreq	r3, r3, #4
   1b51a:	3004      	addeq	r0, #4
   1b51c:	079a      	lsls	r2, r3, #30
   1b51e:	bf04      	itt	eq
   1b520:	089b      	lsreq	r3, r3, #2
   1b522:	3002      	addeq	r0, #2
   1b524:	07da      	lsls	r2, r3, #31
   1b526:	d403      	bmi.n	1b530 <__lo0bits+0x50>
   1b528:	085b      	lsrs	r3, r3, #1
   1b52a:	f100 0001 	add.w	r0, r0, #1
   1b52e:	d005      	beq.n	1b53c <__lo0bits+0x5c>
   1b530:	600b      	str	r3, [r1, #0]
   1b532:	4770      	bx	lr
   1b534:	4610      	mov	r0, r2
   1b536:	e7e8      	b.n	1b50a <__lo0bits+0x2a>
   1b538:	2000      	movs	r0, #0
   1b53a:	4770      	bx	lr
   1b53c:	2020      	movs	r0, #32
   1b53e:	4770      	bx	lr

Disassembly of section .rodata.DRV_ETHPHY_OBJECT_BASE_Default%501:

0001b540 <DRV_ETHPHY_OBJECT_BASE_Default>:
   1b540:	b98d 0001 f6dd 0001 12d5 0002 0731 0002     ............1...
   1b550:	fb75 0001 a91d 0001 f685 0001 0751 0002     u...........Q...
   1b560:	0771 0002 fbed 0001 fb9d 0001 4f45 0001     q...........EO..
   1b570:	d755 0001 e3d5 0001 d715 0001 ca09 0001     U...............
   1b580:	c1dd 0001 d6d5 0001 f6b1 0001 026d 0002     ............m...
   1b590:	8f65 0001 94e1 0001 8fe5 0001               e...........

Disassembly of section .text._DRV_GMAC_LinkStateWaitLinkUp%502:

0001b59c <_DRV_GMAC_LinkStateWaitLinkUp>:
{
   1b59c:	b510      	push	{r4, lr}
   1b59e:	4604      	mov	r4, r0
	if(pMACDrv->sGmacData._macFlags._linkUpDone == 0)
   1b5a0:	7d83      	ldrb	r3, [r0, #22]
   1b5a2:	f013 0f20 	tst.w	r3, #32
   1b5a6:	d010      	beq.n	1b5ca <_DRV_GMAC_LinkStateWaitLinkUp+0x2e>
	if(pMACDrv->sGmacData._macFlags._linkNegotiation == 0)
   1b5a8:	7da3      	ldrb	r3, [r4, #22]
   1b5aa:	f013 0f08 	tst.w	r3, #8
   1b5ae:	d018      	beq.n	1b5e2 <_DRV_GMAC_LinkStateWaitLinkUp+0x46>
	phyRes = pMACDrv->sGmacData.gmacConfig.pPhyBase->DRV_ETHPHY_NegotiationIsComplete(pMACDrv->sGmacData.hPhyClient, DRV_ETHPHY_INF_IDX_ALL_EXTERNAL, false);
   1b5b0:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
   1b5b4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1b5b6:	2200      	movs	r2, #0
   1b5b8:	4611      	mov	r1, r2
   1b5ba:	6920      	ldr	r0, [r4, #16]
   1b5bc:	4798      	blx	r3
	if(phyRes < 0)
   1b5be:	2800      	cmp	r0, #0
   1b5c0:	db16      	blt.n	1b5f0 <_DRV_GMAC_LinkStateWaitLinkUp+0x54>
		pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_NEG_COMPLETE;
   1b5c2:	2303      	movs	r3, #3
   1b5c4:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
}
   1b5c8:	bd10      	pop	{r4, pc}
		uint32_t currTick = SYS_TMR_TickCountGet();
   1b5ca:	f004 fcef 	bl	1ffac <SYS_TMR_TickCountGet>
		if(currTick - pMACDrv->sGmacData._linkUpTick < pMACDrv->sGmacData._linkWaitTick)
   1b5ce:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1b5d0:	1ac0      	subs	r0, r0, r3
   1b5d2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1b5d4:	4298      	cmp	r0, r3
   1b5d6:	d3f7      	bcc.n	1b5c8 <_DRV_GMAC_LinkStateWaitLinkUp+0x2c>
		pMACDrv->sGmacData._macFlags._linkUpDone = 1;
   1b5d8:	7da3      	ldrb	r3, [r4, #22]
   1b5da:	f043 0320 	orr.w	r3, r3, #32
   1b5de:	75a3      	strb	r3, [r4, #22]
   1b5e0:	e7e2      	b.n	1b5a8 <_DRV_GMAC_LinkStateWaitLinkUp+0xc>
		pMACDrv->sGmacData._macFlags._linkPrev = true;
   1b5e2:	f043 0310 	orr.w	r3, r3, #16
   1b5e6:	75a3      	strb	r3, [r4, #22]
		pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_START_LINK;
   1b5e8:	2300      	movs	r3, #0
   1b5ea:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
		return;
   1b5ee:	e7eb      	b.n	1b5c8 <_DRV_GMAC_LinkStateWaitLinkUp+0x2c>
		_DRV_GMAC_LinkStateDown(pMACDrv);
   1b5f0:	4620      	mov	r0, r4
   1b5f2:	f005 faed 	bl	20bd0 <_DRV_GMAC_LinkStateDown>
   1b5f6:	e7e7      	b.n	1b5c8 <_DRV_GMAC_LinkStateWaitLinkUp+0x2c>

Disassembly of section .text._TcpClientSocketConnect%503:

0001b5f8 <_TcpClientSocketConnect>:
    switch(pSkt->addType)
   1b5f8:	f890 306f 	ldrb.w	r3, [r0, #111]	; 0x6f
   1b5fc:	2b01      	cmp	r3, #1
   1b5fe:	d002      	beq.n	1b606 <_TcpClientSocketConnect+0xe>
            return -1;  // IP_ADDRESS_TYPE_ANY
   1b600:	f04f 30ff 	mov.w	r0, #4294967295
   1b604:	4770      	bx	lr
            if( pSkt->destAddress.Val == 0)
   1b606:	6b83      	ldr	r3, [r0, #56]	; 0x38
   1b608:	b913      	cbnz	r3, 1b610 <_TcpClientSocketConnect+0x18>
                return -1;
   1b60a:	f04f 30ff 	mov.w	r0, #4294967295
}
   1b60e:	4770      	bx	lr
{
   1b610:	b510      	push	{r4, lr}
   1b612:	4604      	mov	r4, r0
    return (pAdd->w[1] + pAdd->w[0] + pSkt->remotePort) ^ pSkt->localPort;
   1b614:	8f43      	ldrh	r3, [r0, #58]	; 0x3a
   1b616:	8f02      	ldrh	r2, [r0, #56]	; 0x38
   1b618:	4413      	add	r3, r2
   1b61a:	f8b0 2058 	ldrh.w	r2, [r0, #88]	; 0x58
   1b61e:	4413      	add	r3, r2
   1b620:	f8b0 205a 	ldrh.w	r2, [r0, #90]	; 0x5a
   1b624:	4053      	eors	r3, r2
            pSkt->remoteHash = _TCP_ClientIPV4RemoteHash(&pSkt->destAddress, pSkt);
   1b626:	f8a0 306a 	strh.w	r3, [r0, #106]	; 0x6a
    pSkt->retryCount = 0;
   1b62a:	2300      	movs	r3, #0
   1b62c:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    pSkt->retryInterval = (SYS_TMR_TickCounterFrequencyGet()/4);
   1b630:	f004 fce4 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
   1b634:	0880      	lsrs	r0, r0, #2
   1b636:	64a0      	str	r0, [r4, #72]	; 0x48
    _TCP_SEND_RES sendRes = _TcpSend(pSkt, SYN, SENDTCP_RESET_TIMERS);
   1b638:	2201      	movs	r2, #1
   1b63a:	2102      	movs	r1, #2
   1b63c:	4620      	mov	r0, r4
   1b63e:	f7eb fd23 	bl	7088 <_TcpSend>
    if(sendRes == _TCP_SEND_OK)
   1b642:	b128      	cbz	r0, 1b650 <_TcpClientSocketConnect+0x58>
    return sendRes > 0 ? 1 : -1;
   1b644:	2800      	cmp	r0, #0
   1b646:	bfcc      	ite	gt
   1b648:	2001      	movgt	r0, #1
   1b64a:	f04f 30ff 	movle.w	r0, #4294967295
}
   1b64e:	bd10      	pop	{r4, pc}
        return 0;
   1b650:	2000      	movs	r0, #0
   1b652:	e7fc      	b.n	1b64e <_TcpClientSocketConnect+0x56>

Disassembly of section .text.TCPIP_ARP_Probe%504:

0001b654 <TCPIP_ARP_Probe>:
    if(IPAddr == 0 || IPAddr->Val == 0 || srcAddr == 0)
   1b654:	b1e9      	cbz	r1, 1b692 <TCPIP_ARP_Probe+0x3e>
{
   1b656:	b5f0      	push	{r4, r5, r6, r7, lr}
   1b658:	b083      	sub	sp, #12
   1b65a:	460c      	mov	r4, r1
    if(IPAddr == 0 || IPAddr->Val == 0 || srcAddr == 0)
   1b65c:	6809      	ldr	r1, [r1, #0]
   1b65e:	b1d9      	cbz	r1, 1b698 <TCPIP_ARP_Probe+0x44>
   1b660:	b1ea      	cbz	r2, 1b69e <TCPIP_ARP_Probe+0x4a>
   1b662:	461d      	mov	r5, r3
   1b664:	4616      	mov	r6, r2
    pIf =_TCPIPStackHandleToNetLinked(hNet);
   1b666:	f005 f9b3 	bl	209d0 <_TCPIPStackHandleToNetLinked>
    if(pIf == 0)
   1b66a:	4607      	mov	r7, r0
   1b66c:	b1d0      	cbz	r0, 1b6a4 <TCPIP_ARP_Probe+0x50>
    return pNetIf->Flags.bInConfig != 0;
   1b66e:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
    if(_TCPIPStackIsConfig(pIf) && (opType & ARP_OPERATION_CONFIGURE) == 0)
   1b672:	f013 0f10 	tst.w	r3, #16
   1b676:	d002      	beq.n	1b67e <TCPIP_ARP_Probe+0x2a>
   1b678:	f415 5f80 	tst.w	r5, #4096	; 0x1000
   1b67c:	d015      	beq.n	1b6aa <TCPIP_ARP_Probe+0x56>
    return _ARPProbeAddress(pIf, IPAddr, srcAddr, opType, 0);
   1b67e:	2300      	movs	r3, #0
   1b680:	9300      	str	r3, [sp, #0]
   1b682:	462b      	mov	r3, r5
   1b684:	4632      	mov	r2, r6
   1b686:	4621      	mov	r1, r4
   1b688:	4638      	mov	r0, r7
   1b68a:	f7f9 f8b9 	bl	14800 <_ARPProbeAddress>
}
   1b68e:	b003      	add	sp, #12
   1b690:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return ARP_RES_BAD_ADDRESS;
   1b692:	f06f 0004 	mvn.w	r0, #4
}
   1b696:	4770      	bx	lr
        return ARP_RES_BAD_ADDRESS;
   1b698:	f06f 0004 	mvn.w	r0, #4
   1b69c:	e7f7      	b.n	1b68e <TCPIP_ARP_Probe+0x3a>
   1b69e:	f06f 0004 	mvn.w	r0, #4
   1b6a2:	e7f4      	b.n	1b68e <TCPIP_ARP_Probe+0x3a>
        return ARP_RES_NO_INTERFACE;
   1b6a4:	f06f 0005 	mvn.w	r0, #5
   1b6a8:	e7f1      	b.n	1b68e <TCPIP_ARP_Probe+0x3a>
        return ARP_RES_CONFIGURE_ERR;
   1b6aa:	f06f 0007 	mvn.w	r0, #7
   1b6ae:	e7ee      	b.n	1b68e <TCPIP_ARP_Probe+0x3a>

Disassembly of section .text.TCPIP_DHCP_Enable%505:

0001b6b0 <TCPIP_DHCP_Enable>:
{
   1b6b0:	b538      	push	{r3, r4, r5, lr}
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   1b6b2:	b1a0      	cbz	r0, 1b6de <TCPIP_DHCP_Enable+0x2e>
   1b6b4:	4604      	mov	r4, r0
   1b6b6:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1b6ba:	f012 0f40 	tst.w	r2, #64	; 0x40
   1b6be:	d112      	bne.n	1b6e6 <TCPIP_DHCP_Enable+0x36>
        return false;
   1b6c0:	2500      	movs	r5, #0
}
   1b6c2:	4628      	mov	r0, r5
   1b6c4:	bd38      	pop	{r3, r4, r5, pc}
            if(TCPIP_STACK_AddressServiceCanStart(pNetIf, TCPIP_STACK_ADDRESS_SERVICE_DHCPC))
   1b6c6:	2101      	movs	r1, #1
   1b6c8:	4620      	mov	r0, r4
   1b6ca:	f006 f800 	bl	216ce <TCPIP_STACK_AddressServiceCanStart>
   1b6ce:	4605      	mov	r5, r0
   1b6d0:	2800      	cmp	r0, #0
   1b6d2:	d0f6      	beq.n	1b6c2 <TCPIP_DHCP_Enable+0x12>
        _DHCPEnable(pNetIf, opType);
   1b6d4:	2101      	movs	r1, #1
   1b6d6:	4620      	mov	r0, r4
   1b6d8:	f7fc fb7e 	bl	17dd8 <_DHCPEnable>
        return true;
   1b6dc:	e7f1      	b.n	1b6c2 <TCPIP_DHCP_Enable+0x12>
        return false;
   1b6de:	2500      	movs	r5, #0
   1b6e0:	e7ef      	b.n	1b6c2 <TCPIP_DHCP_Enable+0x12>
   1b6e2:	2500      	movs	r5, #0
    return _DHCPStartOperation(_TCPIPStackHandleToNetUp(hNet), TCPIP_DHCP_OP_REQ_ENABLE, 0);
   1b6e4:	e7ed      	b.n	1b6c2 <TCPIP_DHCP_Enable+0x12>
    if(DHCPClients == 0 || pNetIf == 0)
   1b6e6:	4a08      	ldr	r2, [pc, #32]	; (1b708 <TCPIP_DHCP_Enable+0x58>)
   1b6e8:	6815      	ldr	r5, [r2, #0]
   1b6ea:	2d00      	cmp	r5, #0
   1b6ec:	d0f9      	beq.n	1b6e2 <TCPIP_DHCP_Enable+0x32>
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   1b6ee:	4620      	mov	r0, r4
   1b6f0:	f006 fa90 	bl	21c14 <TCPIP_STACK_NetIxGet>
            if(pClient->flags.bDHCPEnabled != 0)
   1b6f4:	235c      	movs	r3, #92	; 0x5c
   1b6f6:	fb03 5000 	mla	r0, r3, r0, r5
   1b6fa:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   1b6fe:	f013 0f01 	tst.w	r3, #1
   1b702:	d0e0      	beq.n	1b6c6 <TCPIP_DHCP_Enable+0x16>
                return true;
   1b704:	2501      	movs	r5, #1
   1b706:	e7dc      	b.n	1b6c2 <TCPIP_DHCP_Enable+0x12>
   1b708:	2000e610 	.word	0x2000e610

Disassembly of section .text._TCPIPStackIpAddFromAnyNet%506:

0001b70c <_TCPIPStackIpAddFromAnyNet>:
    if(pIpAddress && pIpAddress->Val != 0)
   1b70c:	b329      	cbz	r1, 1b75a <_TCPIPStackIpAddFromAnyNet+0x4e>
{
   1b70e:	b470      	push	{r4, r5, r6}
    if(pIpAddress && pIpAddress->Val != 0)
   1b710:	680e      	ldr	r6, [r1, #0]
   1b712:	b1f6      	cbz	r6, 1b752 <_TCPIPStackIpAddFromAnyNet+0x46>
        for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1b714:	4b12      	ldr	r3, [pc, #72]	; (1b760 <_TCPIPStackIpAddFromAnyNet+0x54>)
   1b716:	6819      	ldr	r1, [r3, #0]
   1b718:	4b12      	ldr	r3, [pc, #72]	; (1b764 <_TCPIPStackIpAddFromAnyNet+0x58>)
   1b71a:	681a      	ldr	r2, [r3, #0]
   1b71c:	2a00      	cmp	r2, #0
   1b71e:	dd1a      	ble.n	1b756 <_TCPIPStackIpAddFromAnyNet+0x4a>
   1b720:	2300      	movs	r3, #0
   1b722:	e00d      	b.n	1b740 <_TCPIPStackIpAddFromAnyNet+0x34>
                if(pIf->Flags.bInterfaceEnabled)
   1b724:	f891 4042 	ldrb.w	r4, [r1, #66]	; 0x42
   1b728:	f014 0f40 	tst.w	r4, #64	; 0x40
   1b72c:	d004      	beq.n	1b738 <_TCPIPStackIpAddFromAnyNet+0x2c>
    return ((pIf->netIPAddr.Val ^ pIpAddress->Val) & pIf->netMask.Val) == 0;
   1b72e:	684c      	ldr	r4, [r1, #4]
   1b730:	4074      	eors	r4, r6
   1b732:	688d      	ldr	r5, [r1, #8]
                    if(_TCPIPStackIpAddFromLAN(pIf, pIpAddress))
   1b734:	422c      	tst	r4, r5
   1b736:	d009      	beq.n	1b74c <_TCPIPStackIpAddFromAnyNet+0x40>
        for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1b738:	3301      	adds	r3, #1
   1b73a:	316c      	adds	r1, #108	; 0x6c
   1b73c:	4293      	cmp	r3, r2
   1b73e:	d004      	beq.n	1b74a <_TCPIPStackIpAddFromAnyNet+0x3e>
            if(pNetIf == 0 || pIf == pNetIf)
   1b740:	2800      	cmp	r0, #0
   1b742:	d0ef      	beq.n	1b724 <_TCPIPStackIpAddFromAnyNet+0x18>
   1b744:	4288      	cmp	r0, r1
   1b746:	d1f7      	bne.n	1b738 <_TCPIPStackIpAddFromAnyNet+0x2c>
   1b748:	e7ec      	b.n	1b724 <_TCPIPStackIpAddFromAnyNet+0x18>
    return 0;
   1b74a:	2100      	movs	r1, #0
}
   1b74c:	4608      	mov	r0, r1
   1b74e:	bc70      	pop	{r4, r5, r6}
   1b750:	4770      	bx	lr
    return 0;
   1b752:	2100      	movs	r1, #0
   1b754:	e7fa      	b.n	1b74c <_TCPIPStackIpAddFromAnyNet+0x40>
   1b756:	2100      	movs	r1, #0
   1b758:	e7f8      	b.n	1b74c <_TCPIPStackIpAddFromAnyNet+0x40>
}
   1b75a:	4608      	mov	r0, r1
   1b75c:	4770      	bx	lr
   1b75e:	bf00      	nop
   1b760:	2000e648 	.word	0x2000e648
   1b764:	2000e2f0 	.word	0x2000e2f0

Disassembly of section .text.SYS_TIME_RemoveFromList%507:

0001b768 <SYS_TIME_RemoveFromList>:
    SYS_TIME_TIMER_OBJ* tmr = counter->tmrActive;
   1b768:	4b15      	ldr	r3, [pc, #84]	; (1b7c0 <SYS_TIME_RemoveFromList+0x58>)
   1b76a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    while ((tmr != NULL) && (tmr != delTimer))
   1b76c:	b31a      	cbz	r2, 1b7b6 <SYS_TIME_RemoveFromList+0x4e>
{
   1b76e:	b410      	push	{r4}
   1b770:	4601      	mov	r1, r0
    while ((tmr != NULL) && (tmr != delTimer))
   1b772:	4282      	cmp	r2, r0
   1b774:	d104      	bne.n	1b780 <SYS_TIME_RemoveFromList+0x18>
    if (delTimer->tmrNext != NULL)
   1b776:	6983      	ldr	r3, [r0, #24]
   1b778:	b1ab      	cbz	r3, 1b7a6 <SYS_TIME_RemoveFromList+0x3e>
    SYS_TIME_TIMER_OBJ* prevTmr = NULL;
   1b77a:	2200      	movs	r2, #0
   1b77c:	e006      	b.n	1b78c <SYS_TIME_RemoveFromList+0x24>
        tmr = tmr->tmrNext;
   1b77e:	461a      	mov	r2, r3
   1b780:	6993      	ldr	r3, [r2, #24]
    while ((tmr != NULL) && (tmr != delTimer))
   1b782:	b1d3      	cbz	r3, 1b7ba <SYS_TIME_RemoveFromList+0x52>
   1b784:	4299      	cmp	r1, r3
   1b786:	d1fa      	bne.n	1b77e <SYS_TIME_RemoveFromList+0x16>
    if (delTimer->tmrNext != NULL)
   1b788:	698b      	ldr	r3, [r1, #24]
   1b78a:	b123      	cbz	r3, 1b796 <SYS_TIME_RemoveFromList+0x2e>
        uint32_t relativeTimePending = delTimer->relativeTimePending;
   1b78c:	688c      	ldr	r4, [r1, #8]
        delTimer->tmrNext->relativeTimePending += relativeTimePending;
   1b78e:	6898      	ldr	r0, [r3, #8]
   1b790:	4420      	add	r0, r4
   1b792:	6098      	str	r0, [r3, #8]
    if (prevTmr == NULL)
   1b794:	b14a      	cbz	r2, 1b7aa <SYS_TIME_RemoveFromList+0x42>
        prevTmr->tmrNext = delTimer->tmrNext;
   1b796:	698b      	ldr	r3, [r1, #24]
   1b798:	6193      	str	r3, [r2, #24]
    bool isHeadTimerUpdated = false;
   1b79a:	2000      	movs	r0, #0
    delTimer->tmrNext = NULL;
   1b79c:	2300      	movs	r3, #0
   1b79e:	618b      	str	r3, [r1, #24]
}
   1b7a0:	f85d 4b04 	ldr.w	r4, [sp], #4
   1b7a4:	4770      	bx	lr
    SYS_TIME_TIMER_OBJ* prevTmr = NULL;
   1b7a6:	461a      	mov	r2, r3
   1b7a8:	e7f4      	b.n	1b794 <SYS_TIME_RemoveFromList+0x2c>
        counter->tmrActive = counter->tmrActive->tmrNext;
   1b7aa:	4b05      	ldr	r3, [pc, #20]	; (1b7c0 <SYS_TIME_RemoveFromList+0x58>)
   1b7ac:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   1b7ae:	6992      	ldr	r2, [r2, #24]
   1b7b0:	631a      	str	r2, [r3, #48]	; 0x30
        isHeadTimerUpdated = true;
   1b7b2:	2001      	movs	r0, #1
   1b7b4:	e7f2      	b.n	1b79c <SYS_TIME_RemoveFromList+0x34>
        return isHeadTimerUpdated;
   1b7b6:	2000      	movs	r0, #0
}
   1b7b8:	4770      	bx	lr
        return isHeadTimerUpdated;
   1b7ba:	2000      	movs	r0, #0
   1b7bc:	e7f0      	b.n	1b7a0 <SYS_TIME_RemoveFromList+0x38>
   1b7be:	bf00      	nop
   1b7c0:	2000e230 	.word	0x2000e230

Disassembly of section .text.xTaskCheckForTimeOut%508:

0001b7c4 <xTaskCheckForTimeOut>:
{
   1b7c4:	b570      	push	{r4, r5, r6, lr}
   1b7c6:	4604      	mov	r4, r0
   1b7c8:	460d      	mov	r5, r1
	taskENTER_CRITICAL();
   1b7ca:	f005 f9a1 	bl	20b10 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
   1b7ce:	4b12      	ldr	r3, [pc, #72]	; (1b818 <xTaskCheckForTimeOut+0x54>)
   1b7d0:	681a      	ldr	r2, [r3, #0]
			if( *pxTicksToWait == portMAX_DELAY )
   1b7d2:	682b      	ldr	r3, [r5, #0]
   1b7d4:	f1b3 3fff 	cmp.w	r3, #4294967295
   1b7d8:	d016      	beq.n	1b808 <xTaskCheckForTimeOut+0x44>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   1b7da:	6861      	ldr	r1, [r4, #4]
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   1b7dc:	480f      	ldr	r0, [pc, #60]	; (1b81c <xTaskCheckForTimeOut+0x58>)
   1b7de:	6800      	ldr	r0, [r0, #0]
   1b7e0:	6826      	ldr	r6, [r4, #0]
   1b7e2:	4286      	cmp	r6, r0
   1b7e4:	d001      	beq.n	1b7ea <xTaskCheckForTimeOut+0x26>
   1b7e6:	4291      	cmp	r1, r2
   1b7e8:	d913      	bls.n	1b812 <xTaskCheckForTimeOut+0x4e>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   1b7ea:	1a50      	subs	r0, r2, r1
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
   1b7ec:	4283      	cmp	r3, r0
   1b7ee:	d803      	bhi.n	1b7f8 <xTaskCheckForTimeOut+0x34>
			*pxTicksToWait = 0;
   1b7f0:	2300      	movs	r3, #0
   1b7f2:	602b      	str	r3, [r5, #0]
			xReturn = pdTRUE;
   1b7f4:	2401      	movs	r4, #1
   1b7f6:	e008      	b.n	1b80a <xTaskCheckForTimeOut+0x46>
			*pxTicksToWait -= xElapsedTime;
   1b7f8:	1a9b      	subs	r3, r3, r2
   1b7fa:	440b      	add	r3, r1
   1b7fc:	602b      	str	r3, [r5, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
   1b7fe:	4620      	mov	r0, r4
   1b800:	f005 ff00 	bl	21604 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
   1b804:	2400      	movs	r4, #0
   1b806:	e000      	b.n	1b80a <xTaskCheckForTimeOut+0x46>
				xReturn = pdFALSE;
   1b808:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
   1b80a:	f006 f859 	bl	218c0 <vPortExitCritical>
}
   1b80e:	4620      	mov	r0, r4
   1b810:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = pdTRUE;
   1b812:	2401      	movs	r4, #1
   1b814:	e7f9      	b.n	1b80a <xTaskCheckForTimeOut+0x46>
   1b816:	bf00      	nop
   1b818:	2000e6d8 	.word	0x2000e6d8
   1b81c:	2000e6cc 	.word	0x2000e6cc

Disassembly of section .text.wc_CryptoCb_RandomBlock%509:

0001b820 <wc_CryptoCb_RandomBlock>:
}
#endif /* !NO_HMAC */

#ifndef WC_NO_RNG
int wc_CryptoCb_RandomBlock(WC_RNG* rng, byte* out, word32 sz)
{
   1b820:	b5f0      	push	{r4, r5, r6, r7, lr}
   1b822:	b0a7      	sub	sp, #156	; 0x9c
   1b824:	460f      	mov	r7, r1
   1b826:	4616      	mov	r6, r2
    int ret = CRYPTOCB_UNAVAILABLE;
    CryptoCb* dev;

    /* locate registered callback */
    if (rng) {
   1b828:	4605      	mov	r5, r0
   1b82a:	b1e0      	cbz	r0, 1b866 <wc_CryptoCb_RandomBlock+0x46>
        dev = wc_CryptoCb_FindDevice(rng->devId);
   1b82c:	6940      	ldr	r0, [r0, #20]
   1b82e:	f003 fd41 	bl	1f2b4 <wc_CryptoCb_FindDevice>
   1b832:	4604      	mov	r4, r0
    else {
        /* locate first callback and try using it */
        dev = wc_CryptoCb_FindDeviceByIndex(0);
    }

    if (dev && dev->cb) {
   1b834:	b1e4      	cbz	r4, 1b870 <wc_CryptoCb_RandomBlock+0x50>
   1b836:	6863      	ldr	r3, [r4, #4]
   1b838:	b1eb      	cbz	r3, 1b876 <wc_CryptoCb_RandomBlock+0x56>
        wc_CryptoInfo cryptoInfo;
        XMEMSET(&cryptoInfo, 0, sizeof(cryptoInfo));
   1b83a:	2290      	movs	r2, #144	; 0x90
   1b83c:	2100      	movs	r1, #0
   1b83e:	a802      	add	r0, sp, #8
   1b840:	f006 f99c 	bl	21b7c <memset>
        cryptoInfo.algo_type = WC_ALGO_TYPE_RNG;
   1b844:	2304      	movs	r3, #4
   1b846:	9301      	str	r3, [sp, #4]
        cryptoInfo.rng.rng = rng;
   1b848:	9520      	str	r5, [sp, #128]	; 0x80
        cryptoInfo.rng.out = out;
   1b84a:	9721      	str	r7, [sp, #132]	; 0x84
        cryptoInfo.rng.sz = sz;
   1b84c:	9622      	str	r6, [sp, #136]	; 0x88

        ret = dev->cb(dev->devId, &cryptoInfo, dev->ctx);
   1b84e:	6863      	ldr	r3, [r4, #4]
   1b850:	68a2      	ldr	r2, [r4, #8]
   1b852:	a901      	add	r1, sp, #4
   1b854:	6820      	ldr	r0, [r4, #0]
   1b856:	4798      	blx	r3
        ret = CRYPTOCB_UNAVAILABLE;
   1b858:	f110 0fae 	cmn.w	r0, #174	; 0xae
   1b85c:	bf08      	it	eq
   1b85e:	f46f 7087 	mvneq.w	r0, #270	; 0x10e
    }

    return wc_CryptoCb_TranslateErrorCode(ret);
}
   1b862:	b027      	add	sp, #156	; 0x9c
   1b864:	bdf0      	pop	{r4, r5, r6, r7, pc}
        dev = wc_CryptoCb_FindDeviceByIndex(0);
   1b866:	2000      	movs	r0, #0
   1b868:	f001 fac6 	bl	1cdf8 <wc_CryptoCb_FindDeviceByIndex>
   1b86c:	4604      	mov	r4, r0
   1b86e:	e7e1      	b.n	1b834 <wc_CryptoCb_RandomBlock+0x14>
    int ret = CRYPTOCB_UNAVAILABLE;
   1b870:	f46f 7087 	mvn.w	r0, #270	; 0x10e
   1b874:	e7f5      	b.n	1b862 <wc_CryptoCb_RandomBlock+0x42>
   1b876:	f46f 7087 	mvn.w	r0, #270	; 0x10e
    return wc_CryptoCb_TranslateErrorCode(ret);
   1b87a:	e7f2      	b.n	1b862 <wc_CryptoCb_RandomBlock+0x42>

Disassembly of section .text._vsnprintf_r%510:

0001b87c <_vsniprintf_r>:
   1b87c:	b530      	push	{r4, r5, lr}
   1b87e:	1e14      	subs	r4, r2, #0
   1b880:	4605      	mov	r5, r0
   1b882:	b09b      	sub	sp, #108	; 0x6c
   1b884:	4618      	mov	r0, r3
   1b886:	da05      	bge.n	1b894 <_vsniprintf_r+0x18>
   1b888:	238b      	movs	r3, #139	; 0x8b
   1b88a:	602b      	str	r3, [r5, #0]
   1b88c:	f04f 30ff 	mov.w	r0, #4294967295
   1b890:	b01b      	add	sp, #108	; 0x6c
   1b892:	bd30      	pop	{r4, r5, pc}
   1b894:	f44f 7302 	mov.w	r3, #520	; 0x208
   1b898:	f8ad 3010 	strh.w	r3, [sp, #16]
   1b89c:	bf14      	ite	ne
   1b89e:	f104 33ff 	addne.w	r3, r4, #4294967295
   1b8a2:	4623      	moveq	r3, r4
   1b8a4:	9303      	str	r3, [sp, #12]
   1b8a6:	9306      	str	r3, [sp, #24]
   1b8a8:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1b8ac:	f8ad 3012 	strh.w	r3, [sp, #18]
   1b8b0:	2300      	movs	r3, #0
   1b8b2:	9101      	str	r1, [sp, #4]
   1b8b4:	9105      	str	r1, [sp, #20]
   1b8b6:	9319      	str	r3, [sp, #100]	; 0x64
   1b8b8:	4602      	mov	r2, r0
   1b8ba:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   1b8bc:	a901      	add	r1, sp, #4
   1b8be:	4628      	mov	r0, r5
   1b8c0:	f7f3 febc 	bl	f63c <_svfiprintf_r>
   1b8c4:	1c43      	adds	r3, r0, #1
   1b8c6:	bfbc      	itt	lt
   1b8c8:	238b      	movlt	r3, #139	; 0x8b
   1b8ca:	602b      	strlt	r3, [r5, #0]
   1b8cc:	2c00      	cmp	r4, #0
   1b8ce:	d0df      	beq.n	1b890 <_vsniprintf_r+0x14>
   1b8d0:	9b01      	ldr	r3, [sp, #4]
   1b8d2:	2200      	movs	r2, #0
   1b8d4:	701a      	strb	r2, [r3, #0]
   1b8d6:	e7db      	b.n	1b890 <_vsniprintf_r+0x14>

Disassembly of section .text.DRV_PIC32CGMAC_LibRxBuffersCountGet%511:

0001b8d8 <DRV_PIC32CGMAC_LibRxBuffersCountGet>:
{
   1b8d8:	b470      	push	{r4, r5, r6}
        if(pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].queueRxEnable == true)
   1b8da:	f890 30cf 	ldrb.w	r3, [r0, #207]	; 0xcf
   1b8de:	2b01      	cmp	r3, #1
   1b8e0:	d008      	beq.n	1b8f4 <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x1c>
   1b8e2:	2000      	movs	r0, #0
   1b8e4:	4605      	mov	r5, r0
    if(pendBuffs)
   1b8e6:	b101      	cbz	r1, 1b8ea <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x12>
        *pendBuffs = pend_buffer_cnt;
   1b8e8:	600d      	str	r5, [r1, #0]
    if(schedBuffs)
   1b8ea:	b102      	cbz	r2, 1b8ee <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x16>
        *schedBuffs = sched_buffer_cnt;
   1b8ec:	6010      	str	r0, [r2, #0]
}
   1b8ee:	2000      	movs	r0, #0
   1b8f0:	bc70      	pop	{r4, r5, r6}
   1b8f2:	4770      	bx	lr
            for(uint16_t desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt; desc_idx++)
   1b8f4:	f8b0 60be 	ldrh.w	r6, [r0, #190]	; 0xbe
   1b8f8:	b1c6      	cbz	r6, 1b92c <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x54>
   1b8fa:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
   1b8fe:	3e01      	subs	r6, #1
   1b900:	b2b0      	uxth	r0, r6
   1b902:	f103 0608 	add.w	r6, r3, #8
   1b906:	eb06 06c0 	add.w	r6, r6, r0, lsl #3
                if ((pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc[desc_idx].rx_desc_buffaddr.val) & GMAC_RX_ADDRESS_MASK)
   1b90a:	2000      	movs	r0, #0
   1b90c:	4605      	mov	r5, r0
   1b90e:	e002      	b.n	1b916 <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x3e>
   1b910:	3308      	adds	r3, #8
            for(uint16_t desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt; desc_idx++)
   1b912:	42b3      	cmp	r3, r6
   1b914:	d0e7      	beq.n	1b8e6 <DRV_PIC32CGMAC_LibRxBuffersCountGet+0xe>
                if ((pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc[desc_idx].rx_desc_buffaddr.val) & GMAC_RX_ADDRESS_MASK)
   1b916:	681c      	ldr	r4, [r3, #0]
   1b918:	f034 0403 	bics.w	r4, r4, #3
   1b91c:	d0f8      	beq.n	1b910 <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x38>
                    if ((pMACDrv->sGmacData.gmac_queue[queue_idx].pRxDesc[desc_idx].rx_desc_buffaddr.val) & GMAC_RX_OWNERSHIP_BIT)
   1b91e:	681c      	ldr	r4, [r3, #0]
   1b920:	f014 0f01 	tst.w	r4, #1
                        pend_buffer_cnt++;
   1b924:	bf14      	ite	ne
   1b926:	3501      	addne	r5, #1
                        sched_buffer_cnt++;
   1b928:	3001      	addeq	r0, #1
   1b92a:	e7f1      	b.n	1b910 <DRV_PIC32CGMAC_LibRxBuffersCountGet+0x38>
            for(uint16_t desc_idx=0; desc_idx < pMACDrv->sGmacData.gmacConfig.gmac_queue_config[queue_idx].nRxDescCnt; desc_idx++)
   1b92c:	2000      	movs	r0, #0
   1b92e:	4605      	mov	r5, r0
   1b930:	e7d9      	b.n	1b8e6 <DRV_PIC32CGMAC_LibRxBuffersCountGet+0xe>

Disassembly of section .text.TCPIP_UDP_BcastIPV4AddressSet%512:

0001b932 <TCPIP_UDP_BcastIPV4AddressSet>:
{
   1b932:	b570      	push	{r4, r5, r6, lr}
   1b934:	460d      	mov	r5, r1
   1b936:	4616      	mov	r6, r2
    pSkt = _UDPSocketDcpt(s);
   1b938:	f004 fad4 	bl	1fee4 <_UDPSocketDcpt>
    if(pSkt == 0 || pSkt->addType != IP_ADDRESS_TYPE_IPV4)
   1b93c:	b1f0      	cbz	r0, 1b97c <TCPIP_UDP_BcastIPV4AddressSet+0x4a>
   1b93e:	4604      	mov	r4, r0
   1b940:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
   1b942:	2b01      	cmp	r3, #1
   1b944:	d11c      	bne.n	1b980 <TCPIP_UDP_BcastIPV4AddressSet+0x4e>
    if(pSkt->flags.bcastForceType != UDP_BCAST_NONE)
   1b946:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   1b94a:	f013 0f03 	tst.w	r3, #3
   1b94e:	d119      	bne.n	1b984 <TCPIP_UDP_BcastIPV4AddressSet+0x52>
    switch (bcastType)
   1b950:	2d01      	cmp	r5, #1
   1b952:	d008      	beq.n	1b966 <TCPIP_UDP_BcastIPV4AddressSet+0x34>
   1b954:	2d02      	cmp	r5, #2
   1b956:	d117      	bne.n	1b988 <TCPIP_UDP_BcastIPV4AddressSet+0x56>
            if((bcastAddress.Val = TCPIP_STACK_NetAddressBcast(hNet)) == 0)
   1b958:	4630      	mov	r0, r6
   1b95a:	f005 f957 	bl	20c0c <TCPIP_STACK_NetAddressBcast>
   1b95e:	4603      	mov	r3, r0
   1b960:	b918      	cbnz	r0, 1b96a <TCPIP_UDP_BcastIPV4AddressSet+0x38>
                return false;
   1b962:	2000      	movs	r0, #0
   1b964:	e00d      	b.n	1b982 <TCPIP_UDP_BcastIPV4AddressSet+0x50>
            bcastAddress.Val = 0xffffffff;
   1b966:	f04f 33ff 	mov.w	r3, #4294967295
    pSkt->destAddress.Val = bcastAddress.Val;
   1b96a:	6163      	str	r3, [r4, #20]
    pSkt->flags.destSet = 1;
   1b96c:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
   1b970:	f043 0301 	orr.w	r3, r3, #1
   1b974:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    return true;
   1b978:	2001      	movs	r0, #1
   1b97a:	e002      	b.n	1b982 <TCPIP_UDP_BcastIPV4AddressSet+0x50>
        return false;
   1b97c:	2000      	movs	r0, #0
   1b97e:	e000      	b.n	1b982 <TCPIP_UDP_BcastIPV4AddressSet+0x50>
   1b980:	2000      	movs	r0, #0
}
   1b982:	bd70      	pop	{r4, r5, r6, pc}
        return false;
   1b984:	2000      	movs	r0, #0
   1b986:	e7fc      	b.n	1b982 <TCPIP_UDP_BcastIPV4AddressSet+0x50>
            return false;
   1b988:	2000      	movs	r0, #0
   1b98a:	e7fa      	b.n	1b982 <TCPIP_UDP_BcastIPV4AddressSet+0x50>

Disassembly of section .text.DRV_ETHPHY_Initialize%513:

0001b98c <DRV_ETHPHY_Initialize>:
    if ( iModule >= _DRV_ETHPHY_INSTANCES_NUMBER )
   1b98c:	bb10      	cbnz	r0, 1b9d4 <DRV_ETHPHY_Initialize+0x48>
    if( hSysObj->objInUse == true )
   1b98e:	4b14      	ldr	r3, [pc, #80]	; (1b9e0 <DRV_ETHPHY_Initialize+0x54>)
   1b990:	781b      	ldrb	r3, [r3, #0]
   1b992:	2b01      	cmp	r3, #1
   1b994:	d01c      	beq.n	1b9d0 <DRV_ETHPHY_Initialize+0x44>
    if((hSysObj->pMiimBase = ethphyInit->pMiimObject) == 0)
   1b996:	694b      	ldr	r3, [r1, #20]
   1b998:	4a11      	ldr	r2, [pc, #68]	; (1b9e0 <DRV_ETHPHY_Initialize+0x54>)
   1b99a:	6613      	str	r3, [r2, #96]	; 0x60
   1b99c:	b1eb      	cbz	r3, 1b9da <DRV_ETHPHY_Initialize+0x4e>
{
   1b99e:	b510      	push	{r4, lr}
   1b9a0:	460b      	mov	r3, r1
    hSysObj->miimIndex = ethphyInit->miimIndex;
   1b9a2:	8b8a      	ldrh	r2, [r1, #28]
   1b9a4:	4c0e      	ldr	r4, [pc, #56]	; (1b9e0 <DRV_ETHPHY_Initialize+0x54>)
   1b9a6:	f8a4 2064 	strh.w	r2, [r4, #100]	; 0x64
    hSysObj->objInUse = true;      // Set object to be in use
   1b9aa:	2201      	movs	r2, #1
   1b9ac:	7022      	strb	r2, [r4, #0]
    hSysObj->busInUse = 0;
   1b9ae:	2100      	movs	r1, #0
   1b9b0:	7061      	strb	r1, [r4, #1]
    hSysObj->numClients = 0;
   1b9b2:	8061      	strh	r1, [r4, #2]
    hSysObj->status = SYS_STATUS_READY; // Set module state
   1b9b4:	2202      	movs	r2, #2
   1b9b6:	7122      	strb	r2, [r4, #4]
    hSysObj->iModule  = iModule;  // Store driver instance
   1b9b8:	80e1      	strh	r1, [r4, #6]
    hSysObj->ethphyId = ethphyInit->ethphyId; // Store PLIB ID
   1b9ba:	685a      	ldr	r2, [r3, #4]
   1b9bc:	60a2      	str	r2, [r4, #8]
    hSysObj->pPhyObj = ethphyInit->pPhyObject;
   1b9be:	68db      	ldr	r3, [r3, #12]
   1b9c0:	6163      	str	r3, [r4, #20]
    memset(hSysObj->objClients, 0, sizeof(hSysObj->objClients));
   1b9c2:	2248      	movs	r2, #72	; 0x48
   1b9c4:	f104 0018 	add.w	r0, r4, #24
   1b9c8:	f006 f8d8 	bl	21b7c <memset>
    return ( SYS_MODULE_OBJ )hSysObj ;
   1b9cc:	4620      	mov	r0, r4
}
   1b9ce:	bd10      	pop	{r4, pc}
        return ( SYS_MODULE_OBJ )hSysObj ;
   1b9d0:	4803      	ldr	r0, [pc, #12]	; (1b9e0 <DRV_ETHPHY_Initialize+0x54>)
   1b9d2:	4770      	bx	lr
        return SYS_MODULE_OBJ_INVALID;
   1b9d4:	f04f 30ff 	mov.w	r0, #4294967295
   1b9d8:	4770      	bx	lr
        return SYS_MODULE_OBJ_INVALID;
   1b9da:	f04f 30ff 	mov.w	r0, #4294967295
}
   1b9de:	4770      	bx	lr
   1b9e0:	2000e018 	.word	0x2000e018

Disassembly of section .text.DRV_GMAC_RxFilterHashTableEntrySet%514:

0001b9e4 <DRV_GMAC_RxFilterHashTableEntrySet>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1b9e4:	4b14      	ldr	r3, [pc, #80]	; (1ba38 <DRV_GMAC_RxFilterHashTableEntrySet+0x54>)
   1b9e6:	4283      	cmp	r3, r0
   1b9e8:	d120      	bne.n	1ba2c <DRV_GMAC_RxFilterHashTableEntrySet+0x48>
    if(pMACDrv == 0)
   1b9ea:	b310      	cbz	r0, 1ba32 <DRV_GMAC_RxFilterHashTableEntrySet+0x4e>
{ 
   1b9ec:	b510      	push	{r4, lr}
   1b9ee:	b086      	sub	sp, #24
   1b9f0:	460c      	mov	r4, r1
    uint8_t nullMACAddr[6] =   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
   1b9f2:	2300      	movs	r3, #0
   1b9f4:	9300      	str	r3, [sp, #0]
   1b9f6:	f8ad 3004 	strh.w	r3, [sp, #4]
    if( DestMACAddr == 0 || memcmp(DestMACAddr->v, nullMACAddr, sizeof(nullMACAddr))==0 )
   1b9fa:	b129      	cbz	r1, 1ba08 <DRV_GMAC_RxFilterHashTableEntrySet+0x24>
   1b9fc:	2206      	movs	r2, #6
   1b9fe:	4669      	mov	r1, sp
   1ba00:	4620      	mov	r0, r4
   1ba02:	f005 fb1f 	bl	21044 <memcmp>
   1ba06:	b960      	cbnz	r0, 1ba22 <DRV_GMAC_RxFilterHashTableEntrySet+0x3e>
        hash.hash_value = 0x0; //Clear to all 0 for 64-bit Hash value to reject all hash match
   1ba08:	2200      	movs	r2, #0
   1ba0a:	2300      	movs	r3, #0
   1ba0c:	e9cd 2302 	strd	r2, r3, [sp, #8]
        hash.calculate_hash = false; // No hash calculation; directly set hash register
   1ba10:	f88d 3014 	strb.w	r3, [sp, #20]
    DRV_PIC32CGMAC_LibRxFilterHash_Calculate(pMACDrv, &hash);
   1ba14:	a902      	add	r1, sp, #8
   1ba16:	4808      	ldr	r0, [pc, #32]	; (1ba38 <DRV_GMAC_RxFilterHashTableEntrySet+0x54>)
   1ba18:	f7f4 f98e 	bl	fd38 <DRV_PIC32CGMAC_LibRxFilterHash_Calculate>
    return TCPIP_MAC_RES_OK;
   1ba1c:	2000      	movs	r0, #0
}
   1ba1e:	b006      	add	sp, #24
   1ba20:	bd10      	pop	{r4, pc}
        hash.DestMACAddr = DestMACAddr;    
   1ba22:	9404      	str	r4, [sp, #16]
        hash.calculate_hash = true; // calculate hash and set hash register
   1ba24:	2301      	movs	r3, #1
   1ba26:	f88d 3014 	strb.w	r3, [sp, #20]
   1ba2a:	e7f3      	b.n	1ba14 <DRV_GMAC_RxFilterHashTableEntrySet+0x30>
        return TCPIP_MAC_RES_OP_ERR;
   1ba2c:	f06f 0005 	mvn.w	r0, #5
   1ba30:	4770      	bx	lr
   1ba32:	f06f 0005 	mvn.w	r0, #5
}
   1ba36:	4770      	bx	lr
   1ba38:	2000dab8 	.word	0x2000dab8

Disassembly of section .rodata.DRV_GMAC_Object%515:

0001ba3c <DRV_GMAC_Object>:
   1ba3c:	00011050 000202ac 0000b5e9 000208d1     P...............
   1ba4c:	00010b33 0001ee95 00012b0d 0001e445     3........+..E...
   1ba5c:	000208b1 0001ca99 0001b9e5 0002009d     ................
   1ba6c:	00015449 0000fb89 00019ced 00017d41     IT..........A}..
   1ba7c:	0001c22d 0001ad8d 0001d191 000130ad     -............0..
   1ba8c:	0001a16d 00020d19                       m.......

Disassembly of section .text._DNS_Enable%516:

0001ba94 <_DNS_Enable>:
{
   1ba94:	b570      	push	{r4, r5, r6, lr}
    pDnsDcpt = pgDnsDcpt;
   1ba96:	4b14      	ldr	r3, [pc, #80]	; (1bae8 <_DNS_Enable+0x54>)
   1ba98:	681d      	ldr	r5, [r3, #0]
    if(pDnsDcpt == 0)
   1ba9a:	b30d      	cbz	r5, 1bae0 <_DNS_Enable+0x4c>
    if(checkIfUp)
   1ba9c:	b141      	cbz	r1, 1bab0 <_DNS_Enable+0x1c>
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   1ba9e:	b308      	cbz	r0, 1bae4 <_DNS_Enable+0x50>
   1baa0:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   1baa4:	f013 0f40 	tst.w	r3, #64	; 0x40
   1baa8:	d104      	bne.n	1bab4 <_DNS_Enable+0x20>
        return false;
   1baaa:	2100      	movs	r1, #0
}
   1baac:	4608      	mov	r0, r1
   1baae:	bd70      	pop	{r4, r5, r6, pc}
    if(pNetIf == 0 || TCPIP_STACK_DNSServiceCanStart(pNetIf, TCPIP_STACK_DNS_SERVICE_CLIENT) == false)
   1bab0:	2800      	cmp	r0, #0
   1bab2:	d0fb      	beq.n	1baac <_DNS_Enable+0x18>
   1bab4:	4616      	mov	r6, r2
   1bab6:	4604      	mov	r4, r0
   1bab8:	2101      	movs	r1, #1
   1baba:	f003 fd70 	bl	1f59e <TCPIP_STACK_DNSServiceCanStart>
   1babe:	4601      	mov	r1, r0
   1bac0:	2800      	cmp	r0, #0
   1bac2:	d0f3      	beq.n	1baac <_DNS_Enable+0x18>
    pNetIf->Flags.bIsDnsClientEnabled = true;      
   1bac4:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   1bac8:	f043 0308 	orr.w	r3, r3, #8
   1bacc:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    if(flags == TCPIP_DNS_ENABLE_STRICT)
   1bad0:	2e01      	cmp	r6, #1
   1bad2:	d003      	beq.n	1badc <_DNS_Enable+0x48>
    else if(flags == TCPIP_DNS_ENABLE_PREFERRED)
   1bad4:	2e02      	cmp	r6, #2
   1bad6:	d1e9      	bne.n	1baac <_DNS_Enable+0x18>
        pDnsDcpt->prefNet =  pNetIf;
   1bad8:	60ac      	str	r4, [r5, #8]
   1bada:	e7e7      	b.n	1baac <_DNS_Enable+0x18>
        pDnsDcpt->strictNet =  pNetIf;
   1badc:	606c      	str	r4, [r5, #4]
   1bade:	e7e5      	b.n	1baac <_DNS_Enable+0x18>
        return false;
   1bae0:	2100      	movs	r1, #0
   1bae2:	e7e3      	b.n	1baac <_DNS_Enable+0x18>
        return false;
   1bae4:	2100      	movs	r1, #0
   1bae6:	e7e1      	b.n	1baac <_DNS_Enable+0x18>
   1bae8:	2000e62c 	.word	0x2000e62c

Disassembly of section .text._TCPIPStackModuleSignalRequest%517:

0001baec <_TCPIPStackModuleSignalRequest>:
    if(modId <= TCPIP_MODULE_MANAGER)
   1baec:	2801      	cmp	r0, #1
   1baee:	d921      	bls.n	1bb34 <_TCPIPStackModuleSignalRequest+0x48>
{
   1baf0:	b538      	push	{r3, r4, r5, lr}
   1baf2:	4615      	mov	r5, r2
   1baf4:	460c      	mov	r4, r1
    _TCPIPSignalEntrySetNotify(_TCPIPModuleToSignalEntry(modId), signals, 0);
   1baf6:	2200      	movs	r2, #0
   1baf8:	4b0f      	ldr	r3, [pc, #60]	; (1bb38 <_TCPIPStackModuleSignalRequest+0x4c>)
   1bafa:	eb03 1000 	add.w	r0, r3, r0, lsl #4
   1bafe:	f004 f979 	bl	1fdf4 <_TCPIPSignalEntrySetNotify>
    if((signal & TCPIP_MODULE_SIGNAL_ASYNC) != 0)
   1bb02:	f414 7f80 	tst.w	r4, #256	; 0x100
   1bb06:	d102      	bne.n	1bb0e <_TCPIPStackModuleSignalRequest+0x22>
    if(noMgrAlert == 0)
   1bb08:	b16d      	cbz	r5, 1bb26 <_TCPIPStackModuleSignalRequest+0x3a>
    return true;
   1bb0a:	4628      	mov	r0, r5
}
   1bb0c:	bd38      	pop	{r3, r4, r5, pc}
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1bb0e:	2000      	movs	r0, #0
   1bb10:	f005 fcc4 	bl	2149c <OSAL_CRIT_Enter>
    stackAsyncSignalCount += 1; 
   1bb14:	4a09      	ldr	r2, [pc, #36]	; (1bb3c <_TCPIPStackModuleSignalRequest+0x50>)
   1bb16:	6813      	ldr	r3, [r2, #0]
   1bb18:	3301      	adds	r3, #1
   1bb1a:	6013      	str	r3, [r2, #0]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1bb1c:	4601      	mov	r1, r0
   1bb1e:	2000      	movs	r0, #0
   1bb20:	f005 fdeb 	bl	216fa <OSAL_CRIT_Leave>
   1bb24:	e7f0      	b.n	1bb08 <_TCPIPStackModuleSignalRequest+0x1c>
        _TCPIPSignalEntryNotify(_TCPIPModuleToSignalEntry(TCPIP_MODULE_MANAGER), signal, 0);
   1bb26:	2200      	movs	r2, #0
   1bb28:	4621      	mov	r1, r4
   1bb2a:	4805      	ldr	r0, [pc, #20]	; (1bb40 <_TCPIPStackModuleSignalRequest+0x54>)
   1bb2c:	f005 f980 	bl	20e30 <_TCPIPSignalEntryNotify>
    return true;
   1bb30:	2001      	movs	r0, #1
   1bb32:	e7eb      	b.n	1bb0c <_TCPIPStackModuleSignalRequest+0x20>
        return false;
   1bb34:	2000      	movs	r0, #0
}
   1bb36:	4770      	bx	lr
   1bb38:	2000d1d4 	.word	0x2000d1d4
   1bb3c:	2000e63c 	.word	0x2000e63c
   1bb40:	2000d1e4 	.word	0x2000d1e4

Disassembly of section .text.OSAL_SEM_Create%518:

0001bb44 <OSAL_SEM_Create>:
    </code>

  Remarks:
 */
OSAL_RESULT OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE* semID, OSAL_SEM_TYPE type, uint8_t maxCount, uint8_t initialCount)
{
   1bb44:	b538      	push	{r3, r4, r5, lr}
   1bb46:	4604      	mov	r4, r0
   1bb48:	461d      	mov	r5, r3
  switch (type)
   1bb4a:	b131      	cbz	r1, 1bb5a <OSAL_SEM_Create+0x16>
   1bb4c:	2901      	cmp	r1, #1
   1bb4e:	d01b      	beq.n	1bb88 <OSAL_SEM_Create+0x44>
    case OSAL_SEM_TYPE_COUNTING:
      *(SemaphoreHandle_t*)semID = xSemaphoreCreateCounting((UBaseType_t)maxCount, (UBaseType_t)initialCount);
    break;

    default:
      *(SemaphoreHandle_t*)semID = NULL;
   1bb50:	2300      	movs	r3, #0
   1bb52:	6003      	str	r3, [r0, #0]

    return OSAL_RESULT_NOT_IMPLEMENTED;
   1bb54:	f04f 30ff 	mov.w	r0, #4294967295
   1bb58:	e01f      	b.n	1bb9a <OSAL_SEM_Create+0x56>
      if ( initialCount <= 1)
   1bb5a:	2d01      	cmp	r5, #1
   1bb5c:	d901      	bls.n	1bb62 <OSAL_SEM_Create+0x1e>
        return OSAL_RESULT_FALSE;
   1bb5e:	2000      	movs	r0, #0
   1bb60:	e01b      	b.n	1bb9a <OSAL_SEM_Create+0x56>
        *(SemaphoreHandle_t*)semID = xSemaphoreCreateBinary();
   1bb62:	2203      	movs	r2, #3
   1bb64:	2100      	movs	r1, #0
   1bb66:	2001      	movs	r0, #1
   1bb68:	f003 fb8c 	bl	1f284 <xQueueGenericCreate>
   1bb6c:	6020      	str	r0, [r4, #0]
        if (*(SemaphoreHandle_t*)semID != NULL && initialCount == 1)
   1bb6e:	b180      	cbz	r0, 1bb92 <OSAL_SEM_Create+0x4e>
   1bb70:	2d01      	cmp	r5, #1
   1bb72:	d10e      	bne.n	1bb92 <OSAL_SEM_Create+0x4e>
          if (xSemaphoreGive(*(SemaphoreHandle_t*)semID) == pdTRUE)
   1bb74:	2300      	movs	r3, #0
   1bb76:	461a      	mov	r2, r3
   1bb78:	4619      	mov	r1, r3
   1bb7a:	f7f6 ff35 	bl	129e8 <xQueueGenericSend>
            return OSAL_RESULT_TRUE;
   1bb7e:	2801      	cmp	r0, #1
   1bb80:	bf14      	ite	ne
   1bb82:	2000      	movne	r0, #0
   1bb84:	2001      	moveq	r0, #1
   1bb86:	e008      	b.n	1bb9a <OSAL_SEM_Create+0x56>
      *(SemaphoreHandle_t*)semID = xSemaphoreCreateCounting((UBaseType_t)maxCount, (UBaseType_t)initialCount);
   1bb88:	4629      	mov	r1, r5
   1bb8a:	4610      	mov	r0, r2
   1bb8c:	f005 fde1 	bl	21752 <xQueueCreateCountingSemaphore>
   1bb90:	6020      	str	r0, [r4, #0]
  }

  if (*(SemaphoreHandle_t*)semID == NULL)
   1bb92:	6820      	ldr	r0, [r4, #0]
            return OSAL_RESULT_TRUE;
   1bb94:	3000      	adds	r0, #0
   1bb96:	bf18      	it	ne
   1bb98:	2001      	movne	r0, #1
  {
    return OSAL_RESULT_FALSE;
  }

  return OSAL_RESULT_TRUE;
}
   1bb9a:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.SYS_TIME_TimerStart%519:

0001bb9c <SYS_TIME_TimerStart>:
    SYS_TIME_ResourceUnlock();
    return result;
}

SYS_TIME_RESULT SYS_TIME_TimerStart(SYS_TIME_HANDLE handle)
{
   1bb9c:	b538      	push	{r3, r4, r5, lr}
   1bb9e:	4604      	mov	r4, r0
    SYS_TIME_TIMER_OBJ *tmr = NULL;
    SYS_TIME_RESULT result = SYS_TIME_ERROR;

    if (SYS_TIME_ResourceLock() == false)
   1bba0:	f002 fd4c 	bl	1e63c <SYS_TIME_ResourceLock>
   1bba4:	b310      	cbz	r0, 1bbec <SYS_TIME_TimerStart+0x50>
    {
        return result;
    }

    tmr = SYS_TIME_GetTimerObject(handle);
   1bba6:	4620      	mov	r0, r4
   1bba8:	f002 fa76 	bl	1e098 <SYS_TIME_GetTimerObject>

    if(tmr != NULL)
   1bbac:	4605      	mov	r5, r0
   1bbae:	b1b0      	cbz	r0, 1bbde <SYS_TIME_TimerStart+0x42>
    {
        if (tmr->active == false)
   1bbb0:	7843      	ldrb	r3, [r0, #1]
   1bbb2:	b9b3      	cbnz	r3, 1bbe2 <SYS_TIME_TimerStart+0x46>
        {
            /* Single shot timers can be started back from the single shot timer's
             * callback where relativeTimePending is 0. For this reason, if the
             * relativeTimePending is 0, it is reloaded with the requested time.
             */
            if (tmr->relativeTimePending == 0)
   1bbb4:	6883      	ldr	r3, [r0, #8]
   1bbb6:	b90b      	cbnz	r3, 1bbbc <SYS_TIME_TimerStart+0x20>
            {
                tmr->relativeTimePending = tmr->requestedTime;
   1bbb8:	6843      	ldr	r3, [r0, #4]
   1bbba:	6083      	str	r3, [r0, #8]
            }
            if (gSystemCounterObj.interruptNestingCount == 0)
   1bbbc:	4b0c      	ldr	r3, [pc, #48]	; (1bbf0 <SYS_TIME_TimerStart+0x54>)
   1bbbe:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   1bbc2:	b943      	cbnz	r3, 1bbd6 <SYS_TIME_TimerStart+0x3a>
            {
                SYS_TIME_TimerAdd(tmr);
   1bbc4:	4628      	mov	r0, r5
   1bbc6:	f001 ff65 	bl	1da94 <SYS_TIME_TimerAdd>
            }
            else
            {
                SYS_TIME_AddToList(tmr);
            }
            tmr->tmrElapsedFlag = false;
   1bbca:	2400      	movs	r4, #0
   1bbcc:	752c      	strb	r4, [r5, #20]
            tmr->tmrElapsed = false;
   1bbce:	756c      	strb	r4, [r5, #21]
            tmr->active = true;
   1bbd0:	2301      	movs	r3, #1
   1bbd2:	706b      	strb	r3, [r5, #1]
   1bbd4:	e006      	b.n	1bbe4 <SYS_TIME_TimerStart+0x48>
                SYS_TIME_AddToList(tmr);
   1bbd6:	4628      	mov	r0, r5
   1bbd8:	f7fc fc78 	bl	184cc <SYS_TIME_AddToList>
   1bbdc:	e7f5      	b.n	1bbca <SYS_TIME_TimerStart+0x2e>
    SYS_TIME_RESULT result = SYS_TIME_ERROR;
   1bbde:	2401      	movs	r4, #1
   1bbe0:	e000      	b.n	1bbe4 <SYS_TIME_TimerStart+0x48>
        }
        result = SYS_TIME_SUCCESS;
   1bbe2:	2400      	movs	r4, #0
    }

    SYS_TIME_ResourceUnlock();
   1bbe4:	f002 fa76 	bl	1e0d4 <SYS_TIME_ResourceUnlock>
    return result;
}
   1bbe8:	4620      	mov	r0, r4
   1bbea:	bd38      	pop	{r3, r4, r5, pc}
        return result;
   1bbec:	2401      	movs	r4, #1
   1bbee:	e7fb      	b.n	1bbe8 <SYS_TIME_TimerStart+0x4c>
   1bbf0:	2000e230 	.word	0x2000e230

Disassembly of section .text.DRV_MIIM_OperationAbort%520:

0001bbf4 <DRV_MIIM_OperationAbort>:
{
   1bbf4:	b538      	push	{r3, r4, r5, lr}
   1bbf6:	460c      	mov	r4, r1
        if((pClient = _DRV_MIIM_GetClientAndLock(handle, true)) == 0)
   1bbf8:	2101      	movs	r1, #1
   1bbfa:	f000 fca6 	bl	1c54a <_DRV_MIIM_GetClientAndLock>
   1bbfe:	b1d0      	cbz	r0, 1bc36 <DRV_MIIM_OperationAbort+0x42>
        pMiimObj = pClient->parentObj;
   1bc00:	6845      	ldr	r5, [r0, #4]
    if(pOpDcpt != 0 && (pOpDcpt->qType == DRV_MIIM_QTYPE_BUSY || pOpDcpt->qType == DRV_MIIM_QTYPE_COMPLETE))
   1bc02:	b1ac      	cbz	r4, 1bc30 <DRV_MIIM_OperationAbort+0x3c>
   1bc04:	7ae3      	ldrb	r3, [r4, #11]
   1bc06:	3b02      	subs	r3, #2
   1bc08:	b2db      	uxtb	r3, r3
   1bc0a:	2b01      	cmp	r3, #1
   1bc0c:	d916      	bls.n	1bc3c <DRV_MIIM_OperationAbort+0x48>
            miimRes = DRV_MIIM_RES_OP_HANDLE_ERR;
   1bc0e:	f06f 0401 	mvn.w	r4, #1
   1bc12:	e007      	b.n	1bc24 <DRV_MIIM_OperationAbort+0x30>
            pList = &pMiimObj->completeOpList;
   1bc14:	f105 0288 	add.w	r2, r5, #136	; 0x88
            qType = DRV_MIIM_QTYPE_COMPLETE;
   1bc18:	2303      	movs	r3, #3
        _DRV_MIIM_ReleaseOpDcpt(pMiimObj, pOpDcpt, pList, qType);
   1bc1a:	4621      	mov	r1, r4
   1bc1c:	4628      	mov	r0, r5
   1bc1e:	f002 fb47 	bl	1e2b0 <_DRV_MIIM_ReleaseOpDcpt>
        miimRes = DRV_MIIM_RES_OK;
   1bc22:	2400      	movs	r4, #0
    if(pMiimObj != 0)
   1bc24:	b115      	cbz	r5, 1bc2c <DRV_MIIM_OperationAbort+0x38>
    OSAL_SEM_Post(&pMiimObj->objSem);
   1bc26:	4628      	mov	r0, r5
   1bc28:	f005 fc44 	bl	214b4 <OSAL_SEM_Post>
}
   1bc2c:	4620      	mov	r0, r4
   1bc2e:	bd38      	pop	{r3, r4, r5, pc}
            miimRes = DRV_MIIM_RES_OP_HANDLE_ERR;
   1bc30:	f06f 0401 	mvn.w	r4, #1
   1bc34:	e7f6      	b.n	1bc24 <DRV_MIIM_OperationAbort+0x30>
            miimRes = DRV_MIIM_RES_HANDLE_ERR;
   1bc36:	f04f 34ff 	mov.w	r4, #4294967295
    return miimRes;
   1bc3a:	e7f7      	b.n	1bc2c <DRV_MIIM_OperationAbort+0x38>
        if(pOpDcpt->opStat >= DRV_MIIM_TXFER_DONE)
   1bc3c:	7aa3      	ldrb	r3, [r4, #10]
   1bc3e:	2b04      	cmp	r3, #4
   1bc40:	d8e8      	bhi.n	1bc14 <DRV_MIIM_OperationAbort+0x20>
            pList = &pMiimObj->busyOpList;
   1bc42:	f105 027c 	add.w	r2, r5, #124	; 0x7c
            qType = DRV_MIIM_QTYPE_BUSY;
   1bc46:	2302      	movs	r3, #2
   1bc48:	e7e7      	b.n	1bc1a <DRV_MIIM_OperationAbort+0x26>

Disassembly of section .text._DRV_PHY_SMITransferWaitComplete%521:

0001bc4a <_DRV_PHY_SMITransferWaitComplete>:
    if(hClientObj->smiTxferStatus != DRV_ETHPHY_SMI_TXFER_OP_WAIT_COMPLETE)
   1bc4a:	8e83      	ldrh	r3, [r0, #52]	; 0x34
   1bc4c:	2b02      	cmp	r3, #2
   1bc4e:	d11f      	bne.n	1bc90 <_DRV_PHY_SMITransferWaitComplete+0x46>
    if(hClientObj->miimHandle == 0)
   1bc50:	6943      	ldr	r3, [r0, #20]
   1bc52:	b1fb      	cbz	r3, 1bc94 <_DRV_PHY_SMITransferWaitComplete+0x4a>
{
   1bc54:	b510      	push	{r4, lr}
   1bc56:	b082      	sub	sp, #8
   1bc58:	4604      	mov	r4, r0
    miimRes = DRV_MIIM_OperationResult(hClientObj->miimHandle, hClientObj->miimOpHandle, &opData);
   1bc5a:	f10d 0206 	add.w	r2, sp, #6
   1bc5e:	6981      	ldr	r1, [r0, #24]
   1bc60:	4618      	mov	r0, r3
   1bc62:	f7fc fb13 	bl	1828c <DRV_MIIM_OperationResult>
    if(miimRes == DRV_MIIM_RES_PENDING)
   1bc66:	2801      	cmp	r0, #1
   1bc68:	d017      	beq.n	1bc9a <_DRV_PHY_SMITransferWaitComplete+0x50>
    if(miimRes < 0)
   1bc6a:	2800      	cmp	r0, #0
   1bc6c:	db09      	blt.n	1bc82 <_DRV_PHY_SMITransferWaitComplete+0x38>
        if(hClientObj->smiTxferType == DRV_ETHPHY_SMI_XFER_TYPE_READ)
   1bc6e:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   1bc70:	2b03      	cmp	r3, #3
   1bc72:	d001      	beq.n	1bc78 <_DRV_PHY_SMITransferWaitComplete+0x2e>
        txferRes = DRV_ETHPHY_SMI_TXFER_RES_DONE; 
   1bc74:	2000      	movs	r0, #0
   1bc76:	e006      	b.n	1bc86 <_DRV_PHY_SMITransferWaitComplete+0x3c>
            hClientObj->smiData = opData; // set the read result
   1bc78:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   1bc7c:	8763      	strh	r3, [r4, #58]	; 0x3a
        txferRes = DRV_ETHPHY_SMI_TXFER_RES_DONE; 
   1bc7e:	2000      	movs	r0, #0
   1bc80:	e001      	b.n	1bc86 <_DRV_PHY_SMITransferWaitComplete+0x3c>
        txferRes = DRV_ETHPHY_SMI_TXFER_RES_MIIM_ERROR; 
   1bc82:	f06f 0001 	mvn.w	r0, #1
    hClientObj->miimOpHandle = 0;  // operation done
   1bc86:	2300      	movs	r3, #0
   1bc88:	61a3      	str	r3, [r4, #24]
    hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_NONE;
   1bc8a:	86a3      	strh	r3, [r4, #52]	; 0x34
}
   1bc8c:	b002      	add	sp, #8
   1bc8e:	bd10      	pop	{r4, pc}
        return DRV_ETHPHY_SMI_TXFER_RES_DONE;
   1bc90:	2000      	movs	r0, #0
   1bc92:	4770      	bx	lr
        return DRV_ETHPHY_SMI_TXFER_RES_ILLEGAL;
   1bc94:	f04f 30ff 	mov.w	r0, #4294967295
}
   1bc98:	4770      	bx	lr
        return DRV_ETHPHY_SMI_TXFER_RES_WAIT;
   1bc9a:	2002      	movs	r0, #2
   1bc9c:	e7f6      	b.n	1bc8c <_DRV_PHY_SMITransferWaitComplete+0x42>

Disassembly of section .text._DRV_ETHPHY_NegCompletePhaseAN_Restart%522:

0001bc9e <_DRV_ETHPHY_NegCompletePhaseAN_Restart>:
{
   1bc9e:	b510      	push	{r4, lr}
   1bca0:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1bca2:	f004 fcdf 	bl	20664 <_DRV_PHY_SMITransfer_Wait>
   1bca6:	b168      	cbz	r0, 1bcc4 <_DRV_ETHPHY_NegCompletePhaseAN_Restart+0x26>
    hClientObj->operReg[1] = phyBMCon.w = hClientObj->smiData;
   1bca8:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   1bcaa:	84a3      	strh	r3, [r4, #36]	; 0x24
    if(phyBMCon.AN_RESTART == 0)
   1bcac:	f413 7f00 	tst.w	r3, #512	; 0x200
   1bcb0:	d009      	beq.n	1bcc6 <_DRV_ETHPHY_NegCompletePhaseAN_Restart+0x28>
    if(SYS_TMR_TickCountGet() < hClientObj->operTStamp)
   1bcb2:	f004 f97b 	bl	1ffac <SYS_TMR_TickCountGet>
   1bcb6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1bcb8:	4298      	cmp	r0, r3
   1bcba:	d214      	bcs.n	1bce6 <_DRV_ETHPHY_NegCompletePhaseAN_Restart+0x48>
        _DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMCON);
   1bcbc:	2100      	movs	r1, #0
   1bcbe:	4620      	mov	r0, r4
   1bcc0:	f003 f83a 	bl	1ed38 <_DRV_PHY_SMIReadStart>
}
   1bcc4:	bd10      	pop	{r4, pc}
        hClientObj->operTStamp = SYS_TMR_TickCountGet() + ((DRV_ETHPHY_NEG_DONE_TMO * SYS_TMR_TickCounterFrequencyGet()) + 999) / 1000;
   1bcc6:	f004 f999 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
   1bcca:	f004 f96f 	bl	1ffac <SYS_TMR_TickCountGet>
   1bcce:	62a0      	str	r0, [r4, #40]	; 0x28
        if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   1bcd0:	2101      	movs	r1, #1
   1bcd2:	4620      	mov	r0, r4
   1bcd4:	f003 f830 	bl	1ed38 <_DRV_PHY_SMIReadStart>
   1bcd8:	2800      	cmp	r0, #0
   1bcda:	d0f3      	beq.n	1bcc4 <_DRV_ETHPHY_NegCompletePhaseAN_Restart+0x26>
    hClientObj->operPhase = operPhase;
   1bcdc:	2305      	movs	r3, #5
   1bcde:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1bce0:	2300      	movs	r3, #0
   1bce2:	8423      	strh	r3, [r4, #32]
   1bce4:	e7ee      	b.n	1bcc4 <_DRV_ETHPHY_NegCompletePhaseAN_Restart+0x26>
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_NEGOTIATION_NOT_STARTED);
   1bce6:	f06f 0106 	mvn.w	r1, #6
   1bcea:	4620      	mov	r0, r4
   1bcec:	f003 ff6a 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
   1bcf0:	e7e8      	b.n	1bcc4 <_DRV_ETHPHY_NegCompletePhaseAN_Restart+0x26>

Disassembly of section .text._ARPNotifyClients%523:

0001bcf4 <_ARPNotifyClients>:
{
   1bcf4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1bcf8:	b083      	sub	sp, #12
   1bcfa:	4605      	mov	r5, r0
   1bcfc:	4689      	mov	r9, r1
   1bcfe:	4690      	mov	r8, r2
   1bd00:	461f      	mov	r7, r3
    TCPIP_Helper_ProtectedSingleListLock(notifyList);
   1bd02:	4c0f      	ldr	r4, [pc, #60]	; (1bd40 <_ARPNotifyClients+0x4c>)
   1bd04:	f104 0020 	add.w	r0, r4, #32
   1bd08:	f004 fe32 	bl	20970 <TCPIP_Helper_ProtectedSingleListLock>
    for(aNode = (ARP_LIST_NODE*)arpMod.registeredUsers.list.head; aNode != 0; aNode = aNode->next)
   1bd0c:	6a24      	ldr	r4, [r4, #32]
   1bd0e:	b984      	cbnz	r4, 1bd32 <_ARPNotifyClients+0x3e>
    TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
   1bd10:	480c      	ldr	r0, [pc, #48]	; (1bd44 <_ARPNotifyClients+0x50>)
   1bd12:	f005 f87f 	bl	20e14 <TCPIP_Helper_ProtectedSingleListUnlock>
}
   1bd16:	b003      	add	sp, #12
   1bd18:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            (*aNode->handler)(pNetIf, ipAdd, MACAddr, evType, aNode->hParam);
   1bd1c:	68a3      	ldr	r3, [r4, #8]
   1bd1e:	9300      	str	r3, [sp, #0]
   1bd20:	6866      	ldr	r6, [r4, #4]
   1bd22:	463b      	mov	r3, r7
   1bd24:	4642      	mov	r2, r8
   1bd26:	4649      	mov	r1, r9
   1bd28:	4628      	mov	r0, r5
   1bd2a:	47b0      	blx	r6
    for(aNode = (ARP_LIST_NODE*)arpMod.registeredUsers.list.head; aNode != 0; aNode = aNode->next)
   1bd2c:	6824      	ldr	r4, [r4, #0]
   1bd2e:	2c00      	cmp	r4, #0
   1bd30:	d0ee      	beq.n	1bd10 <_ARPNotifyClients+0x1c>
        if(aNode->hNet == 0 || aNode->hNet == pNetIf)
   1bd32:	68e3      	ldr	r3, [r4, #12]
   1bd34:	2b00      	cmp	r3, #0
   1bd36:	d0f1      	beq.n	1bd1c <_ARPNotifyClients+0x28>
   1bd38:	42ab      	cmp	r3, r5
   1bd3a:	d1f7      	bne.n	1bd2c <_ARPNotifyClients+0x38>
   1bd3c:	e7ee      	b.n	1bd1c <_ARPNotifyClients+0x28>
   1bd3e:	bf00      	nop
   1bd40:	2000e1a4 	.word	0x2000e1a4
   1bd44:	2000e1c4 	.word	0x2000e1c4

Disassembly of section .text.IperfSetState%524:

0001bd48 <IperfSetState>:

static void IperfSetState(tIperfState* pIState, int newState)
{
   1bd48:	b538      	push	{r3, r4, r5, lr}
   1bd4a:	4604      	mov	r4, r0
   1bd4c:	460d      	mov	r5, r1
    uint8_t oldState = pIState->state;
   1bd4e:	f890 30ce 	ldrb.w	r3, [r0, #206]	; 0xce
	static uint8_t	iperf_async_request = 0;
	
    if(newState == IPERF_STANDBY_STATE)
   1bd52:	2901      	cmp	r1, #1
   1bd54:	d007      	beq.n	1bd66 <IperfSetState+0x1e>
        if(oldState != IPERF_STANDBY_STATE)
        {   // clear the async request
        	iperf_async_request--;
        }
    }
    else if (oldState == IPERF_STANDBY_STATE)
   1bd56:	2b01      	cmp	r3, #1
   1bd58:	d00c      	beq.n	1bd74 <IperfSetState+0x2c>
    {   // going busy; set the async request
    	iperf_async_request++;
		_TCPIPStackModuleSignalRequest(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_ASYNC, 0); 
    }

	if(iperf_async_request == 0)
   1bd5a:	4b0f      	ldr	r3, [pc, #60]	; (1bd98 <IperfSetState+0x50>)
   1bd5c:	781b      	ldrb	r3, [r3, #0]
   1bd5e:	b1a3      	cbz	r3, 1bd8a <IperfSetState+0x42>
		_TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_ASYNC); 
	
    pIState->state = (uint8_t)newState;
   1bd60:	f884 50ce 	strb.w	r5, [r4, #206]	; 0xce

}
   1bd64:	bd38      	pop	{r3, r4, r5, pc}
        if(oldState != IPERF_STANDBY_STATE)
   1bd66:	2b01      	cmp	r3, #1
   1bd68:	d0f7      	beq.n	1bd5a <IperfSetState+0x12>
        	iperf_async_request--;
   1bd6a:	4a0b      	ldr	r2, [pc, #44]	; (1bd98 <IperfSetState+0x50>)
   1bd6c:	7813      	ldrb	r3, [r2, #0]
   1bd6e:	3b01      	subs	r3, #1
   1bd70:	7013      	strb	r3, [r2, #0]
   1bd72:	e7f2      	b.n	1bd5a <IperfSetState+0x12>
    	iperf_async_request++;
   1bd74:	4a08      	ldr	r2, [pc, #32]	; (1bd98 <IperfSetState+0x50>)
   1bd76:	7813      	ldrb	r3, [r2, #0]
   1bd78:	3301      	adds	r3, #1
   1bd7a:	7013      	strb	r3, [r2, #0]
		_TCPIPStackModuleSignalRequest(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_ASYNC, 0); 
   1bd7c:	2200      	movs	r2, #0
   1bd7e:	f44f 7180 	mov.w	r1, #256	; 0x100
   1bd82:	2020      	movs	r0, #32
   1bd84:	f7ff feb2 	bl	1baec <_TCPIPStackModuleSignalRequest>
   1bd88:	e7e7      	b.n	1bd5a <IperfSetState+0x12>
		_TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_ASYNC); 
   1bd8a:	f44f 7180 	mov.w	r1, #256	; 0x100
   1bd8e:	2020      	movs	r0, #32
   1bd90:	f002 f8ec 	bl	1df6c <_TCPIPStackModuleSignalGet>
   1bd94:	e7e4      	b.n	1bd60 <IperfSetState+0x18>
   1bd96:	bf00      	nop
   1bd98:	2000e711 	.word	0x2000e711

Disassembly of section .text.TCPIP_IPERF_Deinitialize%525:

0001bd9c <TCPIP_IPERF_Deinitialize>:
{
   1bd9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(iperfInitCount > 0)
   1bd9e:	4b11      	ldr	r3, [pc, #68]	; (1bde4 <TCPIP_IPERF_Deinitialize+0x48>)
   1bda0:	681c      	ldr	r4, [r3, #0]
   1bda2:	2c00      	cmp	r4, #0
   1bda4:	dd02      	ble.n	1bdac <TCPIP_IPERF_Deinitialize+0x10>
        if(stackCtrl->stackAction == TCPIP_STACK_ACTION_DEINIT)
   1bda6:	7f03      	ldrb	r3, [r0, #28]
   1bda8:	2b02      	cmp	r3, #2
   1bdaa:	d000      	beq.n	1bdae <TCPIP_IPERF_Deinitialize+0x12>
}
   1bdac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            if(--iperfInitCount == 0)
   1bdae:	3c01      	subs	r4, #1
   1bdb0:	4b0c      	ldr	r3, [pc, #48]	; (1bde4 <TCPIP_IPERF_Deinitialize+0x48>)
   1bdb2:	601c      	str	r4, [r3, #0]
   1bdb4:	2c00      	cmp	r4, #0
   1bdb6:	d1f9      	bne.n	1bdac <TCPIP_IPERF_Deinitialize+0x10>
                for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
   1bdb8:	4b0b      	ldr	r3, [pc, #44]	; (1bde8 <TCPIP_IPERF_Deinitialize+0x4c>)
   1bdba:	681b      	ldr	r3, [r3, #0]
   1bdbc:	2b00      	cmp	r3, #0
   1bdbe:	ddf5      	ble.n	1bdac <TCPIP_IPERF_Deinitialize+0x10>
   1bdc0:	4d0a      	ldr	r5, [pc, #40]	; (1bdec <TCPIP_IPERF_Deinitialize+0x50>)
                    	pIState->signalHandle = 0;
   1bdc2:	2700      	movs	r7, #0
                for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
   1bdc4:	4e08      	ldr	r6, [pc, #32]	; (1bde8 <TCPIP_IPERF_Deinitialize+0x4c>)
   1bdc6:	e008      	b.n	1bdda <TCPIP_IPERF_Deinitialize+0x3e>
                    	_TCPIPStackSignalHandlerDeregister(pIState->signalHandle);
   1bdc8:	f005 ff2b 	bl	21c22 <_TCPIPStackSignalHandlerDeregister>
                    	pIState->signalHandle = 0;
   1bdcc:	f8c5 70c0 	str.w	r7, [r5, #192]	; 0xc0
                for(i = 0, pIState = gIperfState; i < nIperfSessions; i++, pIState++)
   1bdd0:	3401      	adds	r4, #1
   1bdd2:	35d8      	adds	r5, #216	; 0xd8
   1bdd4:	6833      	ldr	r3, [r6, #0]
   1bdd6:	42a3      	cmp	r3, r4
   1bdd8:	dde8      	ble.n	1bdac <TCPIP_IPERF_Deinitialize+0x10>
                	if(pIState->signalHandle != 0)
   1bdda:	f8d5 00c0 	ldr.w	r0, [r5, #192]	; 0xc0
   1bdde:	2800      	cmp	r0, #0
   1bde0:	d1f2      	bne.n	1bdc8 <TCPIP_IPERF_Deinitialize+0x2c>
   1bde2:	e7f5      	b.n	1bdd0 <TCPIP_IPERF_Deinitialize+0x34>
   1bde4:	2000e5f4 	.word	0x2000e5f4
   1bde8:	2000e5f8 	.word	0x2000e5f8
   1bdec:	2000dbb0 	.word	0x2000dbb0

Disassembly of section .text.IPv4RegisterFilter%526:

0001bdf0 <IPv4RegisterFilter>:
{
   1bdf0:	b530      	push	{r4, r5, lr}
   1bdf2:	b085      	sub	sp, #20
    if(ipv4MemH && handler)
   1bdf4:	4b10      	ldr	r3, [pc, #64]	; (1be38 <IPv4RegisterFilter+0x48>)
   1bdf6:	681c      	ldr	r4, [r3, #0]
   1bdf8:	b16c      	cbz	r4, 1be16 <IPv4RegisterFilter+0x26>
   1bdfa:	b1d8      	cbz	r0, 1be34 <IPv4RegisterFilter+0x44>
   1bdfc:	460d      	mov	r5, r1
        filtNode.handler = handler;
   1bdfe:	9002      	str	r0, [sp, #8]
        filtNode.active = active;
   1be00:	f88d 100c 	strb.w	r1, [sp, #12]
        newNode = (IPV4_FILTER_LIST_NODE*)TCPIP_Notification_Add(&ipv4PacketFilters, ipv4MemH, &filtNode, sizeof(*newNode));
   1be04:	230c      	movs	r3, #12
   1be06:	aa01      	add	r2, sp, #4
   1be08:	4621      	mov	r1, r4
   1be0a:	480c      	ldr	r0, [pc, #48]	; (1be3c <IPv4RegisterFilter+0x4c>)
   1be0c:	f003 fe9d 	bl	1fb4a <TCPIP_Notification_Add>
        if(newNode && active)
   1be10:	4604      	mov	r4, r0
   1be12:	b100      	cbz	r0, 1be16 <IPv4RegisterFilter+0x26>
   1be14:	b915      	cbnz	r5, 1be1c <IPv4RegisterFilter+0x2c>
}
   1be16:	4620      	mov	r0, r4
   1be18:	b005      	add	sp, #20
   1be1a:	bd30      	pop	{r4, r5, pc}
    TCPIP_Helper_ProtectedSingleListLock(notifyList);
   1be1c:	4d07      	ldr	r5, [pc, #28]	; (1be3c <IPv4RegisterFilter+0x4c>)
   1be1e:	4628      	mov	r0, r5
   1be20:	f004 fda6 	bl	20970 <TCPIP_Helper_ProtectedSingleListLock>
            ipv4ActFilterCount++;
   1be24:	4a06      	ldr	r2, [pc, #24]	; (1be40 <IPv4RegisterFilter+0x50>)
   1be26:	6813      	ldr	r3, [r2, #0]
   1be28:	3301      	adds	r3, #1
   1be2a:	6013      	str	r3, [r2, #0]
    TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
   1be2c:	4628      	mov	r0, r5
   1be2e:	f004 fff1 	bl	20e14 <TCPIP_Helper_ProtectedSingleListUnlock>
   1be32:	e7f0      	b.n	1be16 <IPv4RegisterFilter+0x26>
    IPV4_FILTER_LIST_NODE* newNode = 0;
   1be34:	2400      	movs	r4, #0
    return newNode;
   1be36:	e7ee      	b.n	1be16 <IPv4RegisterFilter+0x26>
   1be38:	2000e608 	.word	0x2000e608
   1be3c:	2000e43c 	.word	0x2000e43c
   1be40:	2000e5fc 	.word	0x2000e5fc

Disassembly of section .text._DHCPOptionWriteSrvIdent%527:

0001be44 <_DHCPOptionWriteSrvIdent>:
{
   1be44:	b570      	push	{r4, r5, r6, lr}
   1be46:	460c      	mov	r4, r1
    unsigned int msgType = pSendData->msgType;
   1be48:	68cd      	ldr	r5, [r1, #12]
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf); 
   1be4a:	4b12      	ldr	r3, [pc, #72]	; (1be94 <_DHCPOptionWriteSrvIdent+0x50>)
   1be4c:	681e      	ldr	r6, [r3, #0]
   1be4e:	f005 fee1 	bl	21c14 <TCPIP_STACK_NetIxGet>
   1be52:	235c      	movs	r3, #92	; 0x5c
   1be54:	fb03 6000 	mla	r0, r3, r0, r6
    if( (msgType == TCPIP_DHCP_DECLINE_MESSAGE) ||  (msgType == TCPIP_DHCP_RELEASE_MESSAGE) ||
   1be58:	2d04      	cmp	r5, #4
   1be5a:	d009      	beq.n	1be70 <_DHCPOptionWriteSrvIdent+0x2c>
   1be5c:	2d07      	cmp	r5, #7
   1be5e:	d007      	beq.n	1be70 <_DHCPOptionWriteSrvIdent+0x2c>
   1be60:	2d03      	cmp	r5, #3
   1be62:	d001      	beq.n	1be68 <_DHCPOptionWriteSrvIdent+0x24>
    return 0;
   1be64:	2000      	movs	r0, #0
   1be66:	e00f      	b.n	1be88 <_DHCPOptionWriteSrvIdent+0x44>
            (msgType == TCPIP_DHCP_REQUEST_MESSAGE && pClient->dhcpOp != TCPIP_DHCP_OPER_INIT_REBOOT) )
   1be68:	f8b0 3054 	ldrh.w	r3, [r0, #84]	; 0x54
   1be6c:	2b02      	cmp	r3, #2
   1be6e:	d00c      	beq.n	1be8a <_DHCPOptionWriteSrvIdent+0x46>
        if(pSendData->writeSpace >= sizeof(*pSrvId))
   1be70:	6863      	ldr	r3, [r4, #4]
   1be72:	2b05      	cmp	r3, #5
   1be74:	d90b      	bls.n	1be8e <_DHCPOptionWriteSrvIdent+0x4a>
            pSrvId = (TCPIP_DHCP_OPTION_DATA_SERVER_ID*)pSendData->pOpt;
   1be76:	6823      	ldr	r3, [r4, #0]
            pSrvId->opt = TCPIP_DHCP_SERVER_IDENTIFIER;
   1be78:	2236      	movs	r2, #54	; 0x36
   1be7a:	701a      	strb	r2, [r3, #0]
            pSrvId->len = sizeof(pSrvId->serverId);
   1be7c:	2204      	movs	r2, #4
   1be7e:	705a      	strb	r2, [r3, #1]
            memcpy(pSrvId->serverId, &pClient->dwServerID, sizeof(pSrvId->serverId));
   1be80:	6a42      	ldr	r2, [r0, #36]	; 0x24
   1be82:	f8c3 2002 	str.w	r2, [r3, #2]
            return sizeof(*pSrvId);
   1be86:	2006      	movs	r0, #6
}
   1be88:	bd70      	pop	{r4, r5, r6, pc}
    return 0;
   1be8a:	2000      	movs	r0, #0
   1be8c:	e7fc      	b.n	1be88 <_DHCPOptionWriteSrvIdent+0x44>
        return -1;
   1be8e:	f04f 30ff 	mov.w	r0, #4294967295
   1be92:	e7f9      	b.n	1be88 <_DHCPOptionWriteSrvIdent+0x44>
   1be94:	2000e610 	.word	0x2000e610

Disassembly of section .text._DNS_DeleteHash%528:

0001be98 <_DNS_DeleteHash>:
{
   1be98:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1be9c:	4604      	mov	r4, r0
    if((pOh = pDnsDcpt->hashDcpt) != 0)
   1be9e:	6805      	ldr	r5, [r0, #0]
   1bea0:	b1dd      	cbz	r5, 1beda <_DNS_DeleteHash+0x42>
        for(bktIx = 0; bktIx < pOh->hEntries; bktIx++)
   1bea2:	68eb      	ldr	r3, [r5, #12]
   1bea4:	b1cb      	cbz	r3, 1beda <_DNS_DeleteHash+0x42>
   1bea6:	2600      	movs	r6, #0
            memset(pE, 0, sizeof(*pE));
   1bea8:	f04f 0930 	mov.w	r9, #48	; 0x30
   1beac:	46b0      	mov	r8, r6
            pE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryGet(pOh, bktIx);
   1beae:	4631      	mov	r1, r6
   1beb0:	4628      	mov	r0, r5
   1beb2:	f005 fd52 	bl	2195a <TCPIP_OAHASH_EntryGet>
   1beb6:	4607      	mov	r7, r0
            TCPIP_OAHASH_EntryRemove(pOh, &pE->hEntry);
   1beb8:	4601      	mov	r1, r0
   1beba:	4628      	mov	r0, r5
   1bebc:	f005 fa9a 	bl	213f4 <TCPIP_OAHASH_EntryRemove>
            TCPIP_HEAP_Free(pDnsDcpt->memH, pE->memblk);
   1bec0:	6920      	ldr	r0, [r4, #16]
   1bec2:	68c3      	ldr	r3, [r0, #12]
   1bec4:	6879      	ldr	r1, [r7, #4]
   1bec6:	4798      	blx	r3
            memset(pE, 0, sizeof(*pE));
   1bec8:	464a      	mov	r2, r9
   1beca:	4641      	mov	r1, r8
   1becc:	4638      	mov	r0, r7
   1bece:	f005 fe55 	bl	21b7c <memset>
        for(bktIx = 0; bktIx < pOh->hEntries; bktIx++)
   1bed2:	3601      	adds	r6, #1
   1bed4:	68eb      	ldr	r3, [r5, #12]
   1bed6:	429e      	cmp	r6, r3
   1bed8:	d3e9      	bcc.n	1beae <_DNS_DeleteHash+0x16>
    TCPIP_HEAP_Free(pDnsDcpt->memH, pDnsDcpt->hashDcpt);
   1beda:	6920      	ldr	r0, [r4, #16]
   1bedc:	68c3      	ldr	r3, [r0, #12]
   1bede:	6821      	ldr	r1, [r4, #0]
   1bee0:	4798      	blx	r3
    pDnsDcpt->hashDcpt = 0;
   1bee2:	2300      	movs	r3, #0
   1bee4:	6023      	str	r3, [r4, #0]
    pDnsDcpt->unsolvedEntries = 0;
   1bee6:	84e3      	strh	r3, [r4, #38]	; 0x26
}
   1bee8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

Disassembly of section .text.TCPIP_DNS_RemoveAll%529:

0001beec <TCPIP_DNS_RemoveAll>:
{
   1beec:	b570      	push	{r4, r5, r6, lr}
    pDnsDcpt = pgDnsDcpt;
   1beee:	4b13      	ldr	r3, [pc, #76]	; (1bf3c <TCPIP_DNS_RemoveAll+0x50>)
   1bef0:	681e      	ldr	r6, [r3, #0]
    if(pDnsDcpt == 0 || pDnsDcpt->hashDcpt == 0)
   1bef2:	b1d6      	cbz	r6, 1bf2a <TCPIP_DNS_RemoveAll+0x3e>
   1bef4:	6835      	ldr	r5, [r6, #0]
   1bef6:	b1dd      	cbz	r5, 1bf30 <TCPIP_DNS_RemoveAll+0x44>
    for(bktIx = 0; bktIx < pOh->hEntries; bktIx++)
   1bef8:	68eb      	ldr	r3, [r5, #12]
   1befa:	b1e3      	cbz	r3, 1bf36 <TCPIP_DNS_RemoveAll+0x4a>
   1befc:	2400      	movs	r4, #0
   1befe:	e006      	b.n	1bf0e <TCPIP_DNS_RemoveAll+0x22>
    _DNS_CleanCacheEntry(pDnsDcpt, pDnsHE);
   1bf00:	4630      	mov	r0, r6
   1bf02:	f003 fb1e 	bl	1f542 <_DNS_CleanCacheEntry>
    for(bktIx = 0; bktIx < pOh->hEntries; bktIx++)
   1bf06:	3401      	adds	r4, #1
   1bf08:	68eb      	ldr	r3, [r5, #12]
   1bf0a:	42a3      	cmp	r3, r4
   1bf0c:	d90b      	bls.n	1bf26 <TCPIP_DNS_RemoveAll+0x3a>
        pBkt = TCPIP_OAHASH_EntryGet(pOh, bktIx);
   1bf0e:	4621      	mov	r1, r4
   1bf10:	4628      	mov	r0, r5
   1bf12:	f005 fd22 	bl	2195a <TCPIP_OAHASH_EntryGet>
        if(pBkt != 0)
   1bf16:	4601      	mov	r1, r0
   1bf18:	2800      	cmp	r0, #0
   1bf1a:	d0f4      	beq.n	1bf06 <TCPIP_DNS_RemoveAll+0x1a>
            if(pBkt->flags.busy != 0)
   1bf1c:	7803      	ldrb	r3, [r0, #0]
   1bf1e:	f013 0f01 	tst.w	r3, #1
   1bf22:	d0f0      	beq.n	1bf06 <TCPIP_DNS_RemoveAll+0x1a>
   1bf24:	e7ec      	b.n	1bf00 <TCPIP_DNS_RemoveAll+0x14>
    return TCPIP_DNS_RES_OK;
   1bf26:	2000      	movs	r0, #0
}
   1bf28:	bd70      	pop	{r4, r5, r6, pc}
        return TCPIP_DNS_RES_NO_SERVICE;
   1bf2a:	f06f 0005 	mvn.w	r0, #5
   1bf2e:	e7fb      	b.n	1bf28 <TCPIP_DNS_RemoveAll+0x3c>
   1bf30:	f06f 0005 	mvn.w	r0, #5
   1bf34:	e7f8      	b.n	1bf28 <TCPIP_DNS_RemoveAll+0x3c>
    return TCPIP_DNS_RES_OK;
   1bf36:	2000      	movs	r0, #0
   1bf38:	e7f6      	b.n	1bf28 <TCPIP_DNS_RemoveAll+0x3c>
   1bf3a:	bf00      	nop
   1bf3c:	2000e62c 	.word	0x2000e62c

Disassembly of section .text.TCPIP_STACK_StringToMACId%530:

0001bf40 <TCPIP_STACK_StringToMACId>:
    if(str)
   1bf40:	b1e8      	cbz	r0, 1bf7e <TCPIP_STACK_StringToMACId+0x3e>
{
   1bf42:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1bf46:	4680      	mov	r8, r0
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   1bf48:	4b10      	ldr	r3, [pc, #64]	; (1bf8c <TCPIP_STACK_StringToMACId+0x4c>)
   1bf4a:	681c      	ldr	r4, [r3, #0]
   1bf4c:	4b10      	ldr	r3, [pc, #64]	; (1bf90 <TCPIP_STACK_StringToMACId+0x50>)
   1bf4e:	681f      	ldr	r7, [r3, #0]
   1bf50:	2f00      	cmp	r7, #0
   1bf52:	dd17      	ble.n	1bf84 <TCPIP_STACK_StringToMACId+0x44>
   1bf54:	2500      	movs	r5, #0
   1bf56:	e003      	b.n	1bf60 <TCPIP_STACK_StringToMACId+0x20>
   1bf58:	3501      	adds	r5, #1
   1bf5a:	346c      	adds	r4, #108	; 0x6c
   1bf5c:	42bd      	cmp	r5, r7
   1bf5e:	d00a      	beq.n	1bf76 <TCPIP_STACK_StringToMACId+0x36>
            if((pObj = pNetIf->pMacObj) != 0)
   1bf60:	6c66      	ldr	r6, [r4, #68]	; 0x44
   1bf62:	2e00      	cmp	r6, #0
   1bf64:	d0f8      	beq.n	1bf58 <TCPIP_STACK_StringToMACId+0x18>
                if(strcmp(str, pObj->macName) == 0)
   1bf66:	6871      	ldr	r1, [r6, #4]
   1bf68:	4640      	mov	r0, r8
   1bf6a:	f005 fcc7 	bl	218fc <strcmp>
   1bf6e:	2800      	cmp	r0, #0
   1bf70:	d1f2      	bne.n	1bf58 <TCPIP_STACK_StringToMACId+0x18>
                    return pObj->macId;
   1bf72:	8830      	ldrh	r0, [r6, #0]
   1bf74:	e001      	b.n	1bf7a <TCPIP_STACK_StringToMACId+0x3a>
    return (TCPIP_STACK_MODULE)TCPIP_MODULE_MAC_NONE;
   1bf76:	f44f 5080 	mov.w	r0, #4096	; 0x1000
}
   1bf7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return (TCPIP_STACK_MODULE)TCPIP_MODULE_MAC_NONE;
   1bf7e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
}
   1bf82:	4770      	bx	lr
    return (TCPIP_STACK_MODULE)TCPIP_MODULE_MAC_NONE;
   1bf84:	f44f 5080 	mov.w	r0, #4096	; 0x1000
   1bf88:	e7f7      	b.n	1bf7a <TCPIP_STACK_StringToMACId+0x3a>
   1bf8a:	bf00      	nop
   1bf8c:	2000e648 	.word	0x2000e648
   1bf90:	2000e2f0 	.word	0x2000e2f0

Disassembly of section .text._TCPIPStackAnyNetLinked%531:

0001bf94 <_TCPIPStackAnyNetLinked>:
{
   1bf94:	b508      	push	{r3, lr}
    if(useDefault)
   1bf96:	b128      	cbz	r0, 1bfa4 <_TCPIPStackAnyNetLinked+0x10>
        pNetIf = _TCPIPStackHandleToNetLinked(tcpipDefIf.defaultNet);
   1bf98:	4b10      	ldr	r3, [pc, #64]	; (1bfdc <_TCPIPStackAnyNetLinked+0x48>)
   1bf9a:	6818      	ldr	r0, [r3, #0]
   1bf9c:	f004 fd18 	bl	209d0 <_TCPIPStackHandleToNetLinked>
    if(pNetIf == 0)
   1bfa0:	4603      	mov	r3, r0
   1bfa2:	b9b8      	cbnz	r0, 1bfd4 <_TCPIPStackAnyNetLinked+0x40>
        for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1bfa4:	4b0e      	ldr	r3, [pc, #56]	; (1bfe0 <_TCPIPStackAnyNetLinked+0x4c>)
   1bfa6:	681b      	ldr	r3, [r3, #0]
   1bfa8:	4a0e      	ldr	r2, [pc, #56]	; (1bfe4 <_TCPIPStackAnyNetLinked+0x50>)
   1bfaa:	6810      	ldr	r0, [r2, #0]
   1bfac:	2800      	cmp	r0, #0
   1bfae:	dd13      	ble.n	1bfd8 <_TCPIPStackAnyNetLinked+0x44>
   1bfb0:	2200      	movs	r2, #0
   1bfb2:	e003      	b.n	1bfbc <_TCPIPStackAnyNetLinked+0x28>
   1bfb4:	3201      	adds	r2, #1
   1bfb6:	336c      	adds	r3, #108	; 0x6c
   1bfb8:	4282      	cmp	r2, r0
   1bfba:	d00a      	beq.n	1bfd2 <_TCPIPStackAnyNetLinked+0x3e>
            if(pIf->Flags.bInterfaceEnabled && pIf->exFlags.linkPrev != 0)
   1bfbc:	f893 1042 	ldrb.w	r1, [r3, #66]	; 0x42
   1bfc0:	f011 0f40 	tst.w	r1, #64	; 0x40
   1bfc4:	d0f6      	beq.n	1bfb4 <_TCPIPStackAnyNetLinked+0x20>
   1bfc6:	f893 1060 	ldrb.w	r1, [r3, #96]	; 0x60
   1bfca:	f011 0f01 	tst.w	r1, #1
   1bfce:	d0f1      	beq.n	1bfb4 <_TCPIPStackAnyNetLinked+0x20>
   1bfd0:	e000      	b.n	1bfd4 <_TCPIPStackAnyNetLinked+0x40>
   1bfd2:	2300      	movs	r3, #0
}
   1bfd4:	4618      	mov	r0, r3
   1bfd6:	bd08      	pop	{r3, pc}
        for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1bfd8:	2300      	movs	r3, #0
    return pNetIf;
   1bfda:	e7fb      	b.n	1bfd4 <_TCPIPStackAnyNetLinked+0x40>
   1bfdc:	2000e644 	.word	0x2000e644
   1bfe0:	2000e648 	.word	0x2000e648
   1bfe4:	2000e2f0 	.word	0x2000e2f0

Disassembly of section .text.SYS_TIME_CallbackRegisterMS%532:

0001bfe8 <SYS_TIME_CallbackRegisterMS>:

    return handle;
}

SYS_TIME_HANDLE SYS_TIME_CallbackRegisterMS ( SYS_TIME_CALLBACK callback, uintptr_t context, uint32_t ms, SYS_TIME_CALLBACK_TYPE type )
{
   1bfe8:	b5f0      	push	{r4, r5, r6, r7, lr}
   1bfea:	b083      	sub	sp, #12
    SYS_TIME_HANDLE handle = SYS_TIME_HANDLE_INVALID;

    /* Single shot timers must register a callback. */
    if ((type == SYS_TIME_SINGLE) && (callback == NULL))
   1bfec:	461f      	mov	r7, r3
   1bfee:	b903      	cbnz	r3, 1bff2 <SYS_TIME_CallbackRegisterMS+0xa>
   1bff0:	b1f8      	cbz	r0, 1c032 <SYS_TIME_CallbackRegisterMS+0x4a>
    {
        return handle;
    }

    if (ms != 0)
   1bff2:	b922      	cbnz	r2, 1bffe <SYS_TIME_CallbackRegisterMS+0x16>
    SYS_TIME_HANDLE handle = SYS_TIME_HANDLE_INVALID;
   1bff4:	f04f 34ff 	mov.w	r4, #4294967295
            SYS_TIME_TimerStart(handle);
        }
    }

    return handle;
}
   1bff8:	4620      	mov	r0, r4
   1bffa:	b003      	add	sp, #12
   1bffc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1bffe:	4614      	mov	r4, r2
   1c000:	460e      	mov	r6, r1
   1c002:	4605      	mov	r5, r0
    return (uint32_t) (( ms * (uint64_t) gSystemCounterObj.hwTimerFrequency) / 1000);
   1c004:	4b0c      	ldr	r3, [pc, #48]	; (1c038 <SYS_TIME_CallbackRegisterMS+0x50>)
   1c006:	68d8      	ldr	r0, [r3, #12]
   1c008:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1c00c:	2300      	movs	r3, #0
   1c00e:	fba0 0104 	umull	r0, r1, r0, r4
   1c012:	f003 f9af 	bl	1f374 <__aeabi_uldivmod>
        handle = SYS_TIME_TimerObjectCreate(0, SYS_TIME_MSToCount(ms), callback, context, type);
   1c016:	9700      	str	r7, [sp, #0]
   1c018:	4633      	mov	r3, r6
   1c01a:	462a      	mov	r2, r5
   1c01c:	4601      	mov	r1, r0
   1c01e:	2000      	movs	r0, #0
   1c020:	f7fa fd46 	bl	16ab0 <SYS_TIME_TimerObjectCreate>
   1c024:	4604      	mov	r4, r0
        if(handle != SYS_TIME_HANDLE_INVALID)
   1c026:	f1b0 3fff 	cmp.w	r0, #4294967295
   1c02a:	d0e5      	beq.n	1bff8 <SYS_TIME_CallbackRegisterMS+0x10>
            SYS_TIME_TimerStart(handle);
   1c02c:	f7ff fdb6 	bl	1bb9c <SYS_TIME_TimerStart>
   1c030:	e7e2      	b.n	1bff8 <SYS_TIME_CallbackRegisterMS+0x10>
        return handle;
   1c032:	f04f 34ff 	mov.w	r4, #4294967295
   1c036:	e7df      	b.n	1bff8 <SYS_TIME_CallbackRegisterMS+0x10>
   1c038:	2000e230 	.word	0x2000e230

Disassembly of section .text.strtok%533:

0001c03c <strtok>:
   1c03c:	4b13      	ldr	r3, [pc, #76]	; (1c08c <strtok+0x50>)
   1c03e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1c042:	681d      	ldr	r5, [r3, #0]
   1c044:	6dac      	ldr	r4, [r5, #88]	; 0x58
   1c046:	4606      	mov	r6, r0
   1c048:	460f      	mov	r7, r1
   1c04a:	b9b4      	cbnz	r4, 1c07a <strtok+0x3e>
   1c04c:	2050      	movs	r0, #80	; 0x50
   1c04e:	f005 fd85 	bl	21b5c <malloc>
   1c052:	65a8      	str	r0, [r5, #88]	; 0x58
   1c054:	e9c0 4400 	strd	r4, r4, [r0]
   1c058:	e9c0 4402 	strd	r4, r4, [r0, #8]
   1c05c:	e9c0 4404 	strd	r4, r4, [r0, #16]
   1c060:	e9c0 440a 	strd	r4, r4, [r0, #40]	; 0x28
   1c064:	e9c0 440c 	strd	r4, r4, [r0, #48]	; 0x30
   1c068:	e9c0 440e 	strd	r4, r4, [r0, #56]	; 0x38
   1c06c:	e9c0 4410 	strd	r4, r4, [r0, #64]	; 0x40
   1c070:	e9c0 4412 	strd	r4, r4, [r0, #72]	; 0x48
   1c074:	6184      	str	r4, [r0, #24]
   1c076:	7704      	strb	r4, [r0, #28]
   1c078:	6244      	str	r4, [r0, #36]	; 0x24
   1c07a:	6daa      	ldr	r2, [r5, #88]	; 0x58
   1c07c:	4639      	mov	r1, r7
   1c07e:	4630      	mov	r0, r6
   1c080:	2301      	movs	r3, #1
   1c082:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1c086:	f000 b87f 	b.w	1c188 <__strtok_r>
   1c08a:	bf00      	nop
   1c08c:	2000e700 	.word	0x2000e700

Disassembly of section .text._fflush_r%534:

0001c090 <_fflush_r>:
   1c090:	b538      	push	{r3, r4, r5, lr}
   1c092:	690b      	ldr	r3, [r1, #16]
   1c094:	4605      	mov	r5, r0
   1c096:	460c      	mov	r4, r1
   1c098:	b1db      	cbz	r3, 1c0d2 <_fflush_r+0x42>
   1c09a:	b118      	cbz	r0, 1c0a4 <_fflush_r+0x14>
   1c09c:	6983      	ldr	r3, [r0, #24]
   1c09e:	b90b      	cbnz	r3, 1c0a4 <_fflush_r+0x14>
   1c0a0:	f7ff f9ee 	bl	1b480 <__sinit>
   1c0a4:	4b0c      	ldr	r3, [pc, #48]	; (1c0d8 <_fflush_r+0x48>)
   1c0a6:	429c      	cmp	r4, r3
   1c0a8:	d109      	bne.n	1c0be <_fflush_r+0x2e>
   1c0aa:	686c      	ldr	r4, [r5, #4]
   1c0ac:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   1c0b0:	b17b      	cbz	r3, 1c0d2 <_fflush_r+0x42>
   1c0b2:	4621      	mov	r1, r4
   1c0b4:	4628      	mov	r0, r5
   1c0b6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1c0ba:	f7f7 bbc1 	b.w	13840 <__sflush_r>
   1c0be:	4b07      	ldr	r3, [pc, #28]	; (1c0dc <_fflush_r+0x4c>)
   1c0c0:	429c      	cmp	r4, r3
   1c0c2:	d101      	bne.n	1c0c8 <_fflush_r+0x38>
   1c0c4:	68ac      	ldr	r4, [r5, #8]
   1c0c6:	e7f1      	b.n	1c0ac <_fflush_r+0x1c>
   1c0c8:	4b05      	ldr	r3, [pc, #20]	; (1c0e0 <_fflush_r+0x50>)
   1c0ca:	429c      	cmp	r4, r3
   1c0cc:	bf08      	it	eq
   1c0ce:	68ec      	ldreq	r4, [r5, #12]
   1c0d0:	e7ec      	b.n	1c0ac <_fflush_r+0x1c>
   1c0d2:	2000      	movs	r0, #0
   1c0d4:	bd38      	pop	{r3, r4, r5, pc}
   1c0d6:	bf00      	nop
   1c0d8:	2000e330 	.word	0x2000e330
   1c0dc:	2000e350 	.word	0x2000e350
   1c0e0:	2000e310 	.word	0x2000e310

Disassembly of section .text._TcpAbort%535:

0001c0e4 <_TcpAbort>:
{
   1c0e4:	b570      	push	{r4, r5, r6, lr}
   1c0e6:	4604      	mov	r4, r0
   1c0e8:	460d      	mov	r5, r1
   1c0ea:	4616      	mov	r6, r2
	switch(pSkt->smState)
   1c0ec:	f890 306e 	ldrb.w	r3, [r0, #110]	; 0x6e
   1c0f0:	3b02      	subs	r3, #2
   1c0f2:	2b07      	cmp	r3, #7
   1c0f4:	d811      	bhi.n	1c11a <_TcpAbort+0x36>
   1c0f6:	e8df f003 	tbb	[pc, r3]
   1c0fa:	0808      	.short	0x0808
   1c0fc:	04100808 	.word	0x04100808
   1c100:	0808      	.short	0x0808
            if((abFlags & _TCP_ABORT_FLAG_SHUTDOWN) == 0)
   1c102:	f011 0f02 	tst.w	r1, #2
   1c106:	d108      	bne.n	1c11a <_TcpAbort+0x36>
   1c108:	e014      	b.n	1c134 <_TcpAbort+0x50>
    pSkt->txHead = pSkt->txTail = pSkt->txUnackedTail = pSkt->txStart;
   1c10a:	6803      	ldr	r3, [r0, #0]
   1c10c:	6103      	str	r3, [r0, #16]
   1c10e:	60c3      	str	r3, [r0, #12]
   1c110:	6083      	str	r3, [r0, #8]
        _TcpSend(pSkt, RST | ACK, 0);
   1c112:	2200      	movs	r2, #0
   1c114:	2114      	movs	r1, #20
   1c116:	f7ea ffb7 	bl	7088 <_TcpSend>
    if((abFlags & (_TCP_ABORT_FLAG_FORCE_CLOSE | _TCP_ABORT_FLAG_SHUTDOWN)) != 0)
   1c11a:	f015 0f03 	tst.w	r5, #3
   1c11e:	d005      	beq.n	1c12c <_TcpAbort+0x48>
        pSkt->flags.forceKill = 1;
   1c120:	f894 306d 	ldrb.w	r3, [r4, #109]	; 0x6d
   1c124:	f043 0304 	orr.w	r3, r3, #4
   1c128:	f884 306d 	strb.w	r3, [r4, #109]	; 0x6d
    _TcpCloseSocket(pSkt, tcpEvent);
   1c12c:	4631      	mov	r1, r6
   1c12e:	4620      	mov	r0, r4
   1c130:	f7f4 fc46 	bl	109c0 <_TcpCloseSocket>
}
   1c134:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_TCP_RemoteBind%536:

0001c136 <TCPIP_TCP_RemoteBind>:
{
   1c136:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1c13a:	4607      	mov	r7, r0
   1c13c:	4688      	mov	r8, r1
   1c13e:	4616      	mov	r6, r2
   1c140:	461d      	mov	r5, r3
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   1c142:	f003 fdb7 	bl	1fcb4 <_TcpSocketChk>
    if(pSkt != 0 && !_TCP_IsConnected(pSkt))
   1c146:	b1a8      	cbz	r0, 1c174 <TCPIP_TCP_RemoteBind+0x3e>
   1c148:	4604      	mov	r4, r0
    return (pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1 || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2 || pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT);
   1c14a:	f890 206e 	ldrb.w	r2, [r0, #110]	; 0x6e
   1c14e:	1ed3      	subs	r3, r2, #3
   1c150:	b2db      	uxtb	r3, r3
   1c152:	2b02      	cmp	r3, #2
   1c154:	d910      	bls.n	1c178 <TCPIP_TCP_RemoteBind+0x42>
    if(pSkt != 0 && !_TCP_IsConnected(pSkt))
   1c156:	2a08      	cmp	r2, #8
   1c158:	d012      	beq.n	1c180 <TCPIP_TCP_RemoteBind+0x4a>
        if(remoteAddress == 0 || TCPIP_TCP_DestinationIPAddressSet(hTCP, addType, remoteAddress) == true)
   1c15a:	b135      	cbz	r5, 1c16a <TCPIP_TCP_RemoteBind+0x34>
   1c15c:	462a      	mov	r2, r5
   1c15e:	4641      	mov	r1, r8
   1c160:	4638      	mov	r0, r7
   1c162:	f000 fce1 	bl	1cb28 <TCPIP_TCP_DestinationIPAddressSet>
   1c166:	4603      	mov	r3, r0
   1c168:	b138      	cbz	r0, 1c17a <TCPIP_TCP_RemoteBind+0x44>
            if(remotePort != 0)
   1c16a:	b15e      	cbz	r6, 1c184 <TCPIP_TCP_RemoteBind+0x4e>
                pSkt->remotePort = remotePort;
   1c16c:	f8a4 6058 	strh.w	r6, [r4, #88]	; 0x58
            return true;
   1c170:	2301      	movs	r3, #1
   1c172:	e002      	b.n	1c17a <TCPIP_TCP_RemoteBind+0x44>
    return false;
   1c174:	2300      	movs	r3, #0
   1c176:	e000      	b.n	1c17a <TCPIP_TCP_RemoteBind+0x44>
   1c178:	2300      	movs	r3, #0
}
   1c17a:	4618      	mov	r0, r3
   1c17c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return false;
   1c180:	2300      	movs	r3, #0
   1c182:	e7fa      	b.n	1c17a <TCPIP_TCP_RemoteBind+0x44>
            return true;
   1c184:	2301      	movs	r3, #1
   1c186:	e7f8      	b.n	1c17a <TCPIP_TCP_RemoteBind+0x44>

Disassembly of section .text.__strtok_r%537:

0001c188 <__strtok_r>:
   1c188:	b5f0      	push	{r4, r5, r6, r7, lr}
   1c18a:	b918      	cbnz	r0, 1c194 <__strtok_r+0xc>
   1c18c:	6810      	ldr	r0, [r2, #0]
   1c18e:	b908      	cbnz	r0, 1c194 <__strtok_r+0xc>
   1c190:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1c192:	4620      	mov	r0, r4
   1c194:	4604      	mov	r4, r0
   1c196:	460f      	mov	r7, r1
   1c198:	f814 5b01 	ldrb.w	r5, [r4], #1
   1c19c:	f817 6b01 	ldrb.w	r6, [r7], #1
   1c1a0:	b91e      	cbnz	r6, 1c1aa <__strtok_r+0x22>
   1c1a2:	b965      	cbnz	r5, 1c1be <__strtok_r+0x36>
   1c1a4:	6015      	str	r5, [r2, #0]
   1c1a6:	4628      	mov	r0, r5
   1c1a8:	e7f2      	b.n	1c190 <__strtok_r+0x8>
   1c1aa:	42b5      	cmp	r5, r6
   1c1ac:	d1f6      	bne.n	1c19c <__strtok_r+0x14>
   1c1ae:	2b00      	cmp	r3, #0
   1c1b0:	d1ef      	bne.n	1c192 <__strtok_r+0xa>
   1c1b2:	6014      	str	r4, [r2, #0]
   1c1b4:	7003      	strb	r3, [r0, #0]
   1c1b6:	e7eb      	b.n	1c190 <__strtok_r+0x8>
   1c1b8:	461c      	mov	r4, r3
   1c1ba:	e00c      	b.n	1c1d6 <__strtok_r+0x4e>
   1c1bc:	b915      	cbnz	r5, 1c1c4 <__strtok_r+0x3c>
   1c1be:	f814 3b01 	ldrb.w	r3, [r4], #1
   1c1c2:	460e      	mov	r6, r1
   1c1c4:	f816 5b01 	ldrb.w	r5, [r6], #1
   1c1c8:	42ab      	cmp	r3, r5
   1c1ca:	d1f7      	bne.n	1c1bc <__strtok_r+0x34>
   1c1cc:	2b00      	cmp	r3, #0
   1c1ce:	d0f3      	beq.n	1c1b8 <__strtok_r+0x30>
   1c1d0:	2300      	movs	r3, #0
   1c1d2:	f804 3c01 	strb.w	r3, [r4, #-1]
   1c1d6:	6014      	str	r4, [r2, #0]
   1c1d8:	e7da      	b.n	1c190 <__strtok_r+0x8>

Disassembly of section .text.DRV_ETHPHY_LinkStatusGet%538:

0001c1dc <DRV_ETHPHY_LinkStatusGet>:
    if(hClientObj != 0)
   1c1dc:	b1c0      	cbz	r0, 1c210 <DRV_ETHPHY_LinkStatusGet+0x34>
{
   1c1de:	b410      	push	{r4}
   1c1e0:	4601      	mov	r1, r0
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1c1e2:	68c4      	ldr	r4, [r0, #12]
   1c1e4:	4810      	ldr	r0, [pc, #64]	; (1c228 <DRV_ETHPHY_LinkStatusGet+0x4c>)
   1c1e6:	4284      	cmp	r4, r0
   1c1e8:	d115      	bne.n	1c216 <DRV_ETHPHY_LinkStatusGet+0x3a>
            if(hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_READY)
   1c1ea:	f991 0008 	ldrsb.w	r0, [r1, #8]
   1c1ee:	2802      	cmp	r0, #2
   1c1f0:	d114      	bne.n	1c21c <DRV_ETHPHY_LinkStatusGet+0x40>
            if(pLinkStat == 0)
   1c1f2:	b1b2      	cbz	r2, 1c222 <DRV_ETHPHY_LinkStatusGet+0x46>
            hClientObj->operParam = (uintptr_t)pLinkStat;
   1c1f4:	630a      	str	r2, [r1, #48]	; 0x30
            hClientObj->operReg[0] = refresh;
   1c1f6:	844b      	strh	r3, [r1, #34]	; 0x22
    hClientObj->operType = opType;
   1c1f8:	2302      	movs	r3, #2
   1c1fa:	838b      	strh	r3, [r1, #28]
    hClientObj->operPhase = hClientObj->operSubPhase = 0; 
   1c1fc:	2300      	movs	r3, #0
   1c1fe:	840b      	strh	r3, [r1, #32]
   1c200:	83cb      	strh	r3, [r1, #30]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_BUSY; 
   1c202:	2001      	movs	r0, #1
   1c204:	7208      	strb	r0, [r1, #8]
    hClientObj->operRes = res;
   1c206:	f881 002c 	strb.w	r0, [r1, #44]	; 0x2c
}
   1c20a:	f85d 4b04 	ldr.w	r4, [sp], #4
   1c20e:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1c210:	f06f 000a 	mvn.w	r0, #10
}
   1c214:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1c216:	f06f 000a 	mvn.w	r0, #10
   1c21a:	e7f6      	b.n	1c20a <DRV_ETHPHY_LinkStatusGet+0x2e>
                return DRV_ETHPHY_RES_NOT_READY_ERR;
   1c21c:	f06f 0009 	mvn.w	r0, #9
   1c220:	e7f3      	b.n	1c20a <DRV_ETHPHY_LinkStatusGet+0x2e>
                return DRV_ETHPHY_RES_OPERATION_ERR;
   1c222:	f06f 0008 	mvn.w	r0, #8
   1c226:	e7f0      	b.n	1c20a <DRV_ETHPHY_LinkStatusGet+0x2e>
   1c228:	2000e018 	.word	0x2000e018

Disassembly of section .text.DRV_GMAC_ParametersGet%539:

0001c22c <DRV_GMAC_ParametersGet>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1c22c:	4b12      	ldr	r3, [pc, #72]	; (1c278 <DRV_GMAC_ParametersGet+0x4c>)
   1c22e:	4283      	cmp	r3, r0
   1c230:	d117      	bne.n	1c262 <DRV_GMAC_ParametersGet+0x36>
    if(pMACDrv == 0)
   1c232:	b1c8      	cbz	r0, 1c268 <DRV_GMAC_ParametersGet+0x3c>
	if(pMACDrv->sGmacData.sysStat == SYS_STATUS_READY)
   1c234:	f993 3014 	ldrsb.w	r3, [r3, #20]
   1c238:	2b02      	cmp	r3, #2
   1c23a:	d118      	bne.n	1c26e <DRV_GMAC_ParametersGet+0x42>
		if(pMacParams)
   1c23c:	b1d1      	cbz	r1, 1c274 <DRV_GMAC_ParametersGet+0x48>
{
   1c23e:	b510      	push	{r4, lr}
   1c240:	460c      	mov	r4, r1
            DRV_PIC32CGMAC_LibGetMacAddr(pMacParams->ifPhyAddress.v);
   1c242:	4608      	mov	r0, r1
   1c244:	f002 f91a 	bl	1e47c <DRV_PIC32CGMAC_LibGetMacAddr>
			pMacParams->processFlags = (TCPIP_MAC_PROCESS_FLAG_RX | TCPIP_MAC_PROCESS_FLAG_TX);
   1c248:	2303      	movs	r3, #3
   1c24a:	80e3      	strh	r3, [r4, #6]
			pMacParams->macType = TCPIP_MAC_TYPE_ETH;
   1c24c:	2301      	movs	r3, #1
   1c24e:	7223      	strb	r3, [r4, #8]
			pMacParams->linkMtu = TCPIP_MAC_LINK_MTU_ETH;
   1c250:	f240 52dc 	movw	r2, #1500	; 0x5dc
   1c254:	8162      	strh	r2, [r4, #10]
            pMacParams->checksumOffloadRx = DRV_GMAC_RX_CHKSM_OFFLOAD;
   1c256:	2000      	movs	r0, #0
   1c258:	7320      	strb	r0, [r4, #12]
            pMacParams->checksumOffloadTx = DRV_GMAC_TX_CHKSM_OFFLOAD;
   1c25a:	7360      	strb	r0, [r4, #13]
            pMacParams->macTxPrioNum = TCPIP_GMAC_TX_PRIO_COUNT;
   1c25c:	73a3      	strb	r3, [r4, #14]
            pMacParams->macRxPrioNum = TCPIP_GMAC_RX_PRIO_COUNT;
   1c25e:	73e3      	strb	r3, [r4, #15]
}
   1c260:	bd10      	pop	{r4, pc}
        return TCPIP_MAC_RES_OP_ERR;
   1c262:	f06f 0005 	mvn.w	r0, #5
   1c266:	4770      	bx	lr
   1c268:	f06f 0005 	mvn.w	r0, #5
   1c26c:	4770      	bx	lr
	return TCPIP_MAC_RES_IS_BUSY;
   1c26e:	f06f 0001 	mvn.w	r0, #1
   1c272:	4770      	bx	lr
		return TCPIP_MAC_RES_OK;
   1c274:	2000      	movs	r0, #0
}
   1c276:	4770      	bx	lr
   1c278:	2000dab8 	.word	0x2000dab8

Disassembly of section .rodata%540:

0001c27c <.rodata%540>:
   1c27c:	20504354 	.word	0x20504354
   1c280:	4c4c554e 	.word	0x4c4c554e
   1c284:	6e796420 	.word	0x6e796420
   1c288:	63696d61 	.word	0x63696d61
   1c28c:	6c6c6120 	.word	0x6c6c6120
   1c290:	7461636f 	.word	0x7461636f
   1c294:	206e6f69 	.word	0x206e6f69
   1c298:	646e6168 	.word	0x646e6168
   1c29c:	692f656c 	.word	0x692f656c
   1c2a0:	2074696e 	.word	0x2074696e
   1c2a4:	61746164 	.word	0x61746164
   1c2a8:	00000000 	.word	0x00000000
   1c2ac:	50435420 	.word	0x50435420
   1c2b0:	6e794420 	.word	0x6e794420
   1c2b4:	63696d61 	.word	0x63696d61
   1c2b8:	6c6c6120 	.word	0x6c6c6120
   1c2bc:	7461636f 	.word	0x7461636f
   1c2c0:	206e6f69 	.word	0x206e6f69
   1c2c4:	6c696166 	.word	0x6c696166
   1c2c8:	6465      	.short	0x6465
	...

Disassembly of section .text._DHCPOptionWriteIPRequest%541:

0001c2cc <_DHCPOptionWriteIPRequest>:
{
   1c2cc:	b570      	push	{r4, r5, r6, lr}
   1c2ce:	460c      	mov	r4, r1
    unsigned int msgType = pSendData->msgType;
   1c2d0:	68cd      	ldr	r5, [r1, #12]
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf); 
   1c2d2:	4b11      	ldr	r3, [pc, #68]	; (1c318 <_DHCPOptionWriteIPRequest+0x4c>)
   1c2d4:	681e      	ldr	r6, [r3, #0]
   1c2d6:	f005 fc9d 	bl	21c14 <TCPIP_STACK_NetIxGet>
   1c2da:	235c      	movs	r3, #92	; 0x5c
   1c2dc:	fb03 6000 	mla	r0, r3, r0, r6
    if ( (msgType == TCPIP_DHCP_DECLINE_MESSAGE) || (msgType == TCPIP_DHCP_REQUEST_MESSAGE) ||  
   1c2e0:	1eeb      	subs	r3, r5, #3
   1c2e2:	2b01      	cmp	r3, #1
   1c2e4:	d905      	bls.n	1c2f2 <_DHCPOptionWriteIPRequest+0x26>
   1c2e6:	2d01      	cmp	r5, #1
   1c2e8:	d001      	beq.n	1c2ee <_DHCPOptionWriteIPRequest+0x22>
    return 0;
   1c2ea:	2000      	movs	r0, #0
   1c2ec:	e00d      	b.n	1c30a <_DHCPOptionWriteIPRequest+0x3e>
            ((msgType == TCPIP_DHCP_DISCOVER_MESSAGE) && pClient->dhcpIPAddress.Val))
   1c2ee:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   1c2f0:	b163      	cbz	r3, 1c30c <_DHCPOptionWriteIPRequest+0x40>
        if(pSendData->writeSpace >= sizeof(*pReqAdd))
   1c2f2:	6863      	ldr	r3, [r4, #4]
   1c2f4:	2b05      	cmp	r3, #5
   1c2f6:	d90b      	bls.n	1c310 <_DHCPOptionWriteIPRequest+0x44>
            pReqAdd = (TCPIP_DHCP_OPTION_DATA_REQUEST_IP_ADDRESS*)pSendData->pOpt;
   1c2f8:	6823      	ldr	r3, [r4, #0]
            pReqAdd->opt = TCPIP_DHCP_PARAM_REQUEST_IP_ADDRESS;
   1c2fa:	2232      	movs	r2, #50	; 0x32
   1c2fc:	701a      	strb	r2, [r3, #0]
            pReqAdd->len = sizeof(pReqAdd->reqIpAddr);
   1c2fe:	2204      	movs	r2, #4
   1c300:	705a      	strb	r2, [r3, #1]
            memcpy(pReqAdd->reqIpAddr, pClient->dhcpIPAddress.v, sizeof(pReqAdd->reqIpAddr));
   1c302:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   1c304:	f8c3 2002 	str.w	r2, [r3, #2]
            return sizeof(*pReqAdd);
   1c308:	2006      	movs	r0, #6
}
   1c30a:	bd70      	pop	{r4, r5, r6, pc}
    return 0;
   1c30c:	2000      	movs	r0, #0
   1c30e:	e7fc      	b.n	1c30a <_DHCPOptionWriteIPRequest+0x3e>
        return -1;
   1c310:	f04f 30ff 	mov.w	r0, #4294967295
   1c314:	e7f9      	b.n	1c30a <_DHCPOptionWriteIPRequest+0x3e>
   1c316:	bf00      	nop
   1c318:	2000e610 	.word	0x2000e610

Disassembly of section .text.TCPIP_DHCP_Renew%542:

0001c31c <TCPIP_DHCP_Renew>:
   1c31c:	b170      	cbz	r0, 1c33c <TCPIP_DHCP_Renew+0x20>
{
   1c31e:	b538      	push	{r3, r4, r5, lr}
   1c320:	4604      	mov	r4, r0
   1c322:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1c326:	f012 0f40 	tst.w	r2, #64	; 0x40
   1c32a:	d10b      	bne.n	1c344 <TCPIP_DHCP_Renew+0x28>
        return false;
   1c32c:	2000      	movs	r0, #0
}
   1c32e:	bd38      	pop	{r3, r4, r5, pc}
        _DHCPEnable(pNetIf, opType);
   1c330:	2103      	movs	r1, #3
   1c332:	4620      	mov	r0, r4
   1c334:	f7fb fd50 	bl	17dd8 <_DHCPEnable>
        return true;
   1c338:	2001      	movs	r0, #1
   1c33a:	e7f8      	b.n	1c32e <TCPIP_DHCP_Renew+0x12>
        return false;
   1c33c:	2000      	movs	r0, #0
}
   1c33e:	4770      	bx	lr
        return false;
   1c340:	2000      	movs	r0, #0
    return _DHCPStartOperation(_TCPIPStackHandleToNetUp(hNet), TCPIP_DHCP_OP_REQ_RENEW, 0);
   1c342:	e7f4      	b.n	1c32e <TCPIP_DHCP_Renew+0x12>
    if(DHCPClients == 0 || pNetIf == 0)
   1c344:	4a08      	ldr	r2, [pc, #32]	; (1c368 <TCPIP_DHCP_Renew+0x4c>)
   1c346:	6815      	ldr	r5, [r2, #0]
   1c348:	2d00      	cmp	r5, #0
   1c34a:	d0f9      	beq.n	1c340 <TCPIP_DHCP_Renew+0x24>
    DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   1c34c:	4620      	mov	r0, r4
   1c34e:	f005 fc61 	bl	21c14 <TCPIP_STACK_NetIxGet>
            if(pClient->flags.bDHCPEnabled != 0 && pClient->flags.bIsBound != 0)
   1c352:	235c      	movs	r3, #92	; 0x5c
   1c354:	fb03 5000 	mla	r0, r3, r0, r5
   1c358:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   1c35c:	f003 0303 	and.w	r3, r3, #3
   1c360:	2b03      	cmp	r3, #3
   1c362:	d0e5      	beq.n	1c330 <TCPIP_DHCP_Renew+0x14>
    return false;
   1c364:	2000      	movs	r0, #0
   1c366:	e7e2      	b.n	1c32e <TCPIP_DHCP_Renew+0x12>
   1c368:	2000e610 	.word	0x2000e610

Disassembly of section .text.TCPIP_DNS_OAHASH_DeleteEntry%543:

0001c36c <TCPIP_DNS_OAHASH_DeleteEntry>:
{
   1c36c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    pDnsDcpt = pgDnsDcpt;
   1c36e:	4b12      	ldr	r3, [pc, #72]	; (1c3b8 <TCPIP_DNS_OAHASH_DeleteEntry+0x4c>)
   1c370:	681e      	ldr	r6, [r3, #0]
    currTime = pDnsDcpt->dnsTime;
   1c372:	69f7      	ldr	r7, [r6, #28]
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   1c374:	68c3      	ldr	r3, [r0, #12]
   1c376:	b1eb      	cbz	r3, 1c3b4 <TCPIP_DNS_OAHASH_DeleteEntry+0x48>
   1c378:	4605      	mov	r5, r0
   1c37a:	2400      	movs	r4, #0
   1c37c:	e007      	b.n	1c38e <TCPIP_DNS_OAHASH_DeleteEntry+0x22>
            if((currTime - pE->tInsert) >= timeout)
   1c37e:	6883      	ldr	r3, [r0, #8]
   1c380:	1afb      	subs	r3, r7, r3
   1c382:	4293      	cmp	r3, r2
   1c384:	d215      	bcs.n	1c3b2 <TCPIP_DNS_OAHASH_DeleteEntry+0x46>
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   1c386:	3401      	adds	r4, #1
   1c388:	68eb      	ldr	r3, [r5, #12]
   1c38a:	42a3      	cmp	r3, r4
   1c38c:	d910      	bls.n	1c3b0 <TCPIP_DNS_OAHASH_DeleteEntry+0x44>
        pBkt = TCPIP_OAHASH_EntryGet(pOH, bktIx);       
   1c38e:	4621      	mov	r1, r4
   1c390:	4628      	mov	r0, r5
   1c392:	f005 fae2 	bl	2195a <TCPIP_OAHASH_EntryGet>
        if(pBkt->flags.busy != 0 && (pBkt->flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) != 0)
   1c396:	7803      	ldrb	r3, [r0, #0]
   1c398:	f013 0f01 	tst.w	r3, #1
   1c39c:	d0f3      	beq.n	1c386 <TCPIP_DNS_OAHASH_DeleteEntry+0x1a>
   1c39e:	8803      	ldrh	r3, [r0, #0]
   1c3a0:	f013 0f80 	tst.w	r3, #128	; 0x80
   1c3a4:	d0ef      	beq.n	1c386 <TCPIP_DNS_OAHASH_DeleteEntry+0x1a>
            timeout = (pDnsDcpt->cacheEntryTMO > 0) ? pDnsDcpt->cacheEntryTMO : pE->ipTTL.Val;
   1c3a6:	6972      	ldr	r2, [r6, #20]
   1c3a8:	2a00      	cmp	r2, #0
   1c3aa:	d1e8      	bne.n	1c37e <TCPIP_DNS_OAHASH_DeleteEntry+0x12>
   1c3ac:	6982      	ldr	r2, [r0, #24]
   1c3ae:	e7e6      	b.n	1c37e <TCPIP_DNS_OAHASH_DeleteEntry+0x12>
    return 0;
   1c3b0:	2000      	movs	r0, #0
}
   1c3b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return 0;
   1c3b4:	2000      	movs	r0, #0
   1c3b6:	e7fc      	b.n	1c3b2 <TCPIP_DNS_OAHASH_DeleteEntry+0x46>
   1c3b8:	2000e62c 	.word	0x2000e62c

Disassembly of section .text.TCPIP_Helper_FormatNetBIOSName%544:

0001c3bc <TCPIP_Helper_FormatNetBIOSName>:

  Returns:
	None
  ***************************************************************************/
void TCPIP_Helper_FormatNetBIOSName(uint8_t Name[])
{
   1c3bc:	b470      	push	{r4, r5, r6}
	uint8_t i;

	Name[15] = '\0';
   1c3be:	2200      	movs	r2, #0
   1c3c0:	73c2      	strb	r2, [r0, #15]
	i = 0;
	while(i < 15u)
   1c3c2:	1e41      	subs	r1, r0, #1
	{
        Name[i] = toupper(Name[i]);
   1c3c4:	4e10      	ldr	r6, [pc, #64]	; (1c408 <TCPIP_Helper_FormatNetBIOSName+0x4c>)
   1c3c6:	3101      	adds	r1, #1
   1c3c8:	780b      	ldrb	r3, [r1, #0]
   1c3ca:	5d9c      	ldrb	r4, [r3, r6]
   1c3cc:	f004 0403 	and.w	r4, r4, #3
   1c3d0:	2c02      	cmp	r4, #2
   1c3d2:	bf08      	it	eq
   1c3d4:	3b20      	subeq	r3, #32
   1c3d6:	b2db      	uxtb	r3, r3
   1c3d8:	700b      	strb	r3, [r1, #0]
		if(Name[i] == '\0')
   1c3da:	b12b      	cbz	r3, 1c3e8 <TCPIP_Helper_FormatNetBIOSName+0x2c>
			{
				Name[i++] = ' ';
			}
			break;
		}
		i++;
   1c3dc:	3201      	adds	r2, #1
   1c3de:	b2d2      	uxtb	r2, r2
	while(i < 15u)
   1c3e0:	2a0f      	cmp	r2, #15
   1c3e2:	d1f0      	bne.n	1c3c6 <TCPIP_Helper_FormatNetBIOSName+0xa>
	}
}
   1c3e4:	bc70      	pop	{r4, r5, r6}
   1c3e6:	4770      	bx	lr
			while(i < 15u)
   1c3e8:	2a0e      	cmp	r2, #14
   1c3ea:	d8fb      	bhi.n	1c3e4 <TCPIP_Helper_FormatNetBIOSName+0x28>
   1c3ec:	1883      	adds	r3, r0, r2
   1c3ee:	3001      	adds	r0, #1
   1c3f0:	4410      	add	r0, r2
   1c3f2:	f1c2 020e 	rsb	r2, r2, #14
   1c3f6:	fa50 f282 	uxtab	r2, r0, r2
				Name[i++] = ' ';
   1c3fa:	2120      	movs	r1, #32
   1c3fc:	f803 1b01 	strb.w	r1, [r3], #1
			while(i < 15u)
   1c400:	4293      	cmp	r3, r2
   1c402:	d1fb      	bne.n	1c3fc <TCPIP_Helper_FormatNetBIOSName+0x40>
   1c404:	e7ee      	b.n	1c3e4 <TCPIP_Helper_FormatNetBIOSName+0x28>
   1c406:	bf00      	nop
   1c408:	00013c61 	.word	0x00013c61

Disassembly of section .text.SYS_CONSOLE_Status%545:

0001c40c <SYS_CONSOLE_Status>:
{
   1c40c:	b508      	push	{r3, lr}
    if (index >= SYS_CONSOLE_DEVICE_MAX_INSTANCES)
   1c40e:	b283      	uxth	r3, r0
   1c410:	b9cb      	cbnz	r3, 1c446 <SYS_CONSOLE_Status+0x3a>
    pConsoleObj = &consoleDeviceInstance[index];
   1c412:	4618      	mov	r0, r3
    if (pConsoleObj->devDesc == NULL)
   1c414:	eb03 0243 	add.w	r2, r3, r3, lsl #1
   1c418:	4b0f      	ldr	r3, [pc, #60]	; (1c458 <SYS_CONSOLE_Status+0x4c>)
   1c41a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   1c41e:	685a      	ldr	r2, [r3, #4]
   1c420:	b1a2      	cbz	r2, 1c44c <SYS_CONSOLE_Status+0x40>
    status = pConsoleObj->devDesc->status(pConsoleObj->devIndex);
   1c422:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   1c426:	4b0c      	ldr	r3, [pc, #48]	; (1c458 <SYS_CONSOLE_Status+0x4c>)
   1c428:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1c42c:	6a53      	ldr	r3, [r2, #36]	; 0x24
   1c42e:	6880      	ldr	r0, [r0, #8]
   1c430:	4798      	blx	r3
    switch (status)
   1c432:	2801      	cmp	r0, #1
   1c434:	d00c      	beq.n	1c450 <SYS_CONSOLE_Status+0x44>
   1c436:	b243      	sxtb	r3, r0
   1c438:	b163      	cbz	r3, 1c454 <SYS_CONSOLE_Status+0x48>
    SYS_STATUS ret = SYS_STATUS_ERROR;
   1c43a:	2802      	cmp	r0, #2
   1c43c:	bf0c      	ite	eq
   1c43e:	2001      	moveq	r0, #1
   1c440:	f04f 30ff 	movne.w	r0, #4294967295
}
   1c444:	bd08      	pop	{r3, pc}
        return SYS_STATUS_ERROR;
   1c446:	f04f 30ff 	mov.w	r0, #4294967295
   1c44a:	e7fb      	b.n	1c444 <SYS_CONSOLE_Status+0x38>
        return SYS_STATUS_UNINITIALIZED;
   1c44c:	2000      	movs	r0, #0
   1c44e:	e7f9      	b.n	1c444 <SYS_CONSOLE_Status+0x38>
            ret = SYS_STATUS_READY;
   1c450:	2002      	movs	r0, #2
   1c452:	e7f7      	b.n	1c444 <SYS_CONSOLE_Status+0x38>
            ret = SYS_STATUS_UNINITIALIZED;
   1c454:	2000      	movs	r0, #0
   1c456:	e7f5      	b.n	1c444 <SYS_CONSOLE_Status+0x38>
   1c458:	2000e540 	.word	0x2000e540

Disassembly of section .text._raise_r%546:

0001c45c <_raise_r>:
   1c45c:	291f      	cmp	r1, #31
   1c45e:	b538      	push	{r3, r4, r5, lr}
   1c460:	4604      	mov	r4, r0
   1c462:	460d      	mov	r5, r1
   1c464:	d904      	bls.n	1c470 <_raise_r+0x14>
   1c466:	2316      	movs	r3, #22
   1c468:	6003      	str	r3, [r0, #0]
   1c46a:	f04f 30ff 	mov.w	r0, #4294967295
   1c46e:	bd38      	pop	{r3, r4, r5, pc}
   1c470:	6c42      	ldr	r2, [r0, #68]	; 0x44
   1c472:	b112      	cbz	r2, 1c47a <_raise_r+0x1e>
   1c474:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   1c478:	b94b      	cbnz	r3, 1c48e <_raise_r+0x32>
   1c47a:	4620      	mov	r0, r4
   1c47c:	f005 fe70 	bl	22160 <_getpid_r>
   1c480:	462a      	mov	r2, r5
   1c482:	4601      	mov	r1, r0
   1c484:	4620      	mov	r0, r4
   1c486:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1c48a:	f004 b87f 	b.w	2058c <_kill_r>
   1c48e:	2b01      	cmp	r3, #1
   1c490:	d00a      	beq.n	1c4a8 <_raise_r+0x4c>
   1c492:	1c5c      	adds	r4, r3, #1
   1c494:	d103      	bne.n	1c49e <_raise_r+0x42>
   1c496:	2316      	movs	r3, #22
   1c498:	6003      	str	r3, [r0, #0]
   1c49a:	2001      	movs	r0, #1
   1c49c:	e7e7      	b.n	1c46e <_raise_r+0x12>
   1c49e:	2400      	movs	r4, #0
   1c4a0:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
   1c4a4:	4608      	mov	r0, r1
   1c4a6:	4798      	blx	r3
   1c4a8:	2000      	movs	r0, #0
   1c4aa:	e7e0      	b.n	1c46e <_raise_r+0x12>

Disassembly of section .text%547:

0001c4ac <__aeabi_d2iz>:
   1c4ac:	ea4f 0241 	mov.w	r2, r1, lsl #1
   1c4b0:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   1c4b4:	d215      	bcs.n	1c4e2 <__aeabi_d2iz+0x36>
   1c4b6:	d511      	bpl.n	1c4dc <__aeabi_d2iz+0x30>
   1c4b8:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   1c4bc:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   1c4c0:	d912      	bls.n	1c4e8 <__aeabi_d2iz+0x3c>
   1c4c2:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   1c4c6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1c4ca:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   1c4ce:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   1c4d2:	fa23 f002 	lsr.w	r0, r3, r2
   1c4d6:	bf18      	it	ne
   1c4d8:	4240      	negne	r0, r0
   1c4da:	4770      	bx	lr
   1c4dc:	f04f 0000 	mov.w	r0, #0
   1c4e0:	4770      	bx	lr
   1c4e2:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   1c4e6:	d105      	bne.n	1c4f4 <__aeabi_d2iz+0x48>
   1c4e8:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
   1c4ec:	bf08      	it	eq
   1c4ee:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
   1c4f2:	4770      	bx	lr
   1c4f4:	f04f 0000 	mov.w	r0, #0
   1c4f8:	4770      	bx	lr
   1c4fa:	bf00      	nop

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase7%548:

0001c4fc <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase7>:
{
   1c4fc:	b508      	push	{r3, lr}
    openFlags = hClientObj->hDriver->openFlags;
   1c4fe:	68c1      	ldr	r1, [r0, #12]
   1c500:	898b      	ldrh	r3, [r1, #12]
    matchCpbl = hClientObj->operReg[1];
   1c502:	8c82      	ldrh	r2, [r0, #36]	; 0x24
    openFlags &= ~(TCPIP_ETH_OPEN_AUTO | TCPIP_ETH_OPEN_FDUPLEX | TCPIP_ETH_OPEN_HDUPLEX | TCPIP_ETH_OPEN_100|TCPIP_ETH_OPEN_10);
   1c504:	f023 031f 	bic.w	r3, r3, #31
   1c508:	b29b      	uxth	r3, r3
    if(matchCpbl & _BMSTAT_AN_ABLE_MASK)
   1c50a:	f012 0f08 	tst.w	r2, #8
        openFlags |= TCPIP_ETH_OPEN_AUTO;
   1c50e:	bf18      	it	ne
   1c510:	f043 0301 	orrne.w	r3, r3, #1
    if(matchCpbl & (_BMSTAT_BASE100TX_HDX_MASK | _BMSTAT_BASE100TX_FDX_MASK))   // set 100Mbps request/capability
   1c514:	f412 4fc0 	tst.w	r2, #24576	; 0x6000
        openFlags |= TCPIP_ETH_OPEN_100;
   1c518:	bf18      	it	ne
   1c51a:	f043 0308 	orrne.w	r3, r3, #8
    if(matchCpbl & (_BMSTAT_BASE10T_HDX_MASK | _BMSTAT_BASE10T_FDX_MASK))   // set 10Mbps request/capability
   1c51e:	f412 5fc0 	tst.w	r2, #6144	; 0x1800
        openFlags |= TCPIP_ETH_OPEN_10;
   1c522:	bf18      	it	ne
   1c524:	f043 0310 	orrne.w	r3, r3, #16
    if(matchCpbl & (_BMSTAT_BASE10T_FDX_MASK | _BMSTAT_BASE100TX_FDX_MASK))
   1c528:	f412 4fa0 	tst.w	r2, #20480	; 0x5000
        openFlags |= TCPIP_ETH_OPEN_FDUPLEX;
   1c52c:	bf18      	it	ne
   1c52e:	f043 0302 	orrne.w	r3, r3, #2
    if(matchCpbl & (_BMSTAT_BASE10T_HDX_MASK | _BMSTAT_BASE100TX_HDX_MASK))
   1c532:	f412 5f20 	tst.w	r2, #10240	; 0x2800
        openFlags |= TCPIP_ETH_OPEN_HDUPLEX;
   1c536:	bf18      	it	ne
   1c538:	f043 0304 	orrne.w	r3, r3, #4
    hClientObj->hDriver->openFlags = openFlags;
   1c53c:	818b      	strh	r3, [r1, #12]
    *pSetUpFlags = openFlags;
   1c53e:	6b02      	ldr	r2, [r0, #48]	; 0x30
   1c540:	8013      	strh	r3, [r2, #0]
    _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OK);
   1c542:	2100      	movs	r1, #0
   1c544:	f003 fb3e 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
} 
   1c548:	bd08      	pop	{r3, pc}

Disassembly of section .text._DRV_MIIM_GetClientAndLock%549:

0001c54a <_DRV_MIIM_GetClientAndLock>:
    if(pClient != 0)
   1c54a:	b1e8      	cbz	r0, 1c588 <_DRV_MIIM_GetClientAndLock+0x3e>
{
   1c54c:	b510      	push	{r4, lr}
   1c54e:	4604      	mov	r4, r0
        if(pClient->clientInUse != 0 && pClient->cliStatus == DRV_MIIM_CLIENT_STATUS_READY)
   1c550:	8802      	ldrh	r2, [r0, #0]
   1c552:	b1da      	cbz	r2, 1c58c <_DRV_MIIM_GetClientAndLock+0x42>
   1c554:	f990 200c 	ldrsb.w	r2, [r0, #12]
   1c558:	2a02      	cmp	r2, #2
   1c55a:	d119      	bne.n	1c590 <_DRV_MIIM_GetClientAndLock+0x46>
            if(lock)
   1c55c:	b969      	cbnz	r1, 1c57a <_DRV_MIIM_GetClientAndLock+0x30>
                pMiimObj = _DRV_MIIM_GetObject((SYS_MODULE_OBJ)pClient->parentObj);
   1c55e:	6840      	ldr	r0, [r0, #4]
    if(pMiimObj != 0)
   1c560:	b1b8      	cbz	r0, 1c592 <_DRV_MIIM_GetClientAndLock+0x48>
        if(pMiimObj->objStatus == SYS_STATUS_READY && (pMiimObj->objFlags & DRV_MIIM_OBJ_FLAG_IN_USE) != 0)
   1c562:	f990 2008 	ldrsb.w	r2, [r0, #8]
   1c566:	2a02      	cmp	r2, #2
   1c568:	d114      	bne.n	1c594 <_DRV_MIIM_GetClientAndLock+0x4a>
   1c56a:	8882      	ldrh	r2, [r0, #4]
   1c56c:	f002 0201 	and.w	r2, r2, #1
                return pClient;
   1c570:	2a00      	cmp	r2, #0
   1c572:	bf14      	ite	ne
   1c574:	4620      	movne	r0, r4
   1c576:	2000      	moveq	r0, #0
   1c578:	e00b      	b.n	1c592 <_DRV_MIIM_GetClientAndLock+0x48>
                pMiimObj = _DRV_MIIM_GetObjectAndLock((SYS_MODULE_OBJ)pClient->parentObj);
   1c57a:	6840      	ldr	r0, [r0, #4]
   1c57c:	f002 ff29 	bl	1f3d2 <_DRV_MIIM_GetObjectAndLock>
            if(pMiimObj != 0)
   1c580:	2800      	cmp	r0, #0
                return pClient;
   1c582:	bf18      	it	ne
   1c584:	4620      	movne	r0, r4
   1c586:	e004      	b.n	1c592 <_DRV_MIIM_GetClientAndLock+0x48>
    return 0;
   1c588:	2000      	movs	r0, #0
}
   1c58a:	4770      	bx	lr
    return 0;
   1c58c:	2000      	movs	r0, #0
   1c58e:	e000      	b.n	1c592 <_DRV_MIIM_GetClientAndLock+0x48>
   1c590:	2000      	movs	r0, #0
}
   1c592:	bd10      	pop	{r4, pc}
    return 0;
   1c594:	2000      	movs	r0, #0
   1c596:	e7fc      	b.n	1c592 <_DRV_MIIM_GetClientAndLock+0x48>

Disassembly of section .text.TCPIP_IPV4_SelectDestInterface%550:

0001c598 <TCPIP_IPV4_SelectDestInterface>:
    if(pDestAddress == 0 || pDestAddress->Val == 0)
   1c598:	b310      	cbz	r0, 1c5e0 <TCPIP_IPV4_SelectDestInterface+0x48>
{
   1c59a:	b570      	push	{r4, r5, r6, lr}
   1c59c:	4605      	mov	r5, r0
    if(pDestAddress == 0 || pDestAddress->Val == 0)
   1c59e:	6803      	ldr	r3, [r0, #0]
   1c5a0:	b1fb      	cbz	r3, 1c5e2 <TCPIP_IPV4_SelectDestInterface+0x4a>
    if((avlblInterfaces = TCPIP_STACK_NumberOfNetworksGet()) > 1)
   1c5a2:	f005 fcaf 	bl	21f04 <TCPIP_STACK_NumberOfNetworksGet>
   1c5a6:	4606      	mov	r6, r0
   1c5a8:	2801      	cmp	r0, #1
   1c5aa:	dd13      	ble.n	1c5d4 <TCPIP_IPV4_SelectDestInterface+0x3c>
        for(netIx = 0; netIx < avlblInterfaces; netIx++)
   1c5ac:	2400      	movs	r4, #0
   1c5ae:	e002      	b.n	1c5b6 <TCPIP_IPV4_SelectDestInterface+0x1e>
   1c5b0:	3401      	adds	r4, #1
   1c5b2:	42a6      	cmp	r6, r4
   1c5b4:	d00e      	beq.n	1c5d4 <TCPIP_IPV4_SelectDestInterface+0x3c>
            pIf = _TCPIPStackHandleToNetLinked(TCPIP_STACK_IndexToNet(netIx));
   1c5b6:	4620      	mov	r0, r4
   1c5b8:	f003 fc30 	bl	1fe1c <TCPIP_STACK_IndexToNet>
   1c5bc:	f004 fa08 	bl	209d0 <_TCPIPStackHandleToNetLinked>
            if(pIf)
   1c5c0:	4602      	mov	r2, r0
   1c5c2:	2800      	cmp	r0, #0
   1c5c4:	d0f4      	beq.n	1c5b0 <TCPIP_IPV4_SelectDestInterface+0x18>
                if((ifAdd & ifMask) == (pDestAddress->Val & ifMask))
   1c5c6:	682b      	ldr	r3, [r5, #0]
   1c5c8:	6841      	ldr	r1, [r0, #4]
   1c5ca:	404b      	eors	r3, r1
   1c5cc:	6881      	ldr	r1, [r0, #8]
   1c5ce:	420b      	tst	r3, r1
   1c5d0:	d1ee      	bne.n	1c5b0 <TCPIP_IPV4_SelectDestInterface+0x18>
   1c5d2:	e003      	b.n	1c5dc <TCPIP_IPV4_SelectDestInterface+0x44>
    return _TCPIPStackAnyNetLinked(true);
   1c5d4:	2001      	movs	r0, #1
   1c5d6:	f7ff fcdd 	bl	1bf94 <_TCPIPStackAnyNetLinked>
   1c5da:	4602      	mov	r2, r0
}
   1c5dc:	4610      	mov	r0, r2
   1c5de:	bd70      	pop	{r4, r5, r6, pc}
   1c5e0:	4770      	bx	lr
        return 0;
   1c5e2:	2200      	movs	r2, #0
   1c5e4:	e7fa      	b.n	1c5dc <TCPIP_IPV4_SelectDestInterface+0x44>

Disassembly of section .text.TCPIP_UDP_PutIsReady%551:

0001c5e6 <TCPIP_UDP_PutIsReady>:
{
   1c5e6:	b510      	push	{r4, lr}
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1c5e8:	f003 fc7c 	bl	1fee4 <_UDPSocketDcpt>
    if(pSkt == 0)
   1c5ec:	b300      	cbz	r0, 1c630 <TCPIP_UDP_PutIsReady+0x4a>
   1c5ee:	4604      	mov	r4, r0
    if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   1c5f0:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
   1c5f2:	2b01      	cmp	r3, #1
    return 0;   // can happen if it is a server socket and opened with IP_ADDRESS_TYPE_ANY
   1c5f4:	bf18      	it	ne
   1c5f6:	2000      	movne	r0, #0
    if(pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   1c5f8:	d000      	beq.n	1c5fc <TCPIP_UDP_PutIsReady+0x16>
}
   1c5fa:	bd10      	pop	{r4, pc}
    void* pPkt = _TxSktGetLockedV4Pkt(pSkt, true);
   1c5fc:	2101      	movs	r1, #1
   1c5fe:	f002 ffe5 	bl	1f5cc <_TxSktGetLockedV4Pkt>
    if(pPkt == 0)
   1c602:	b138      	cbz	r0, 1c614 <TCPIP_UDP_PutIsReady+0x2e>
    if(pSkt->flags.txSplitAlloc == 0)
   1c604:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
   1c608:	f013 0f02 	tst.w	r3, #2
   1c60c:	d00b      	beq.n	1c626 <TCPIP_UDP_PutIsReady+0x40>
    return 1514 - sizeof(TCPIP_MAC_ETHERNET_HEADER) - sizeof(IPV4_HEADER) - sizeof(UDP_HEADER);
   1c60e:	f44f 60b8 	mov.w	r0, #1472	; 0x5c0
   1c612:	e7f2      	b.n	1c5fa <TCPIP_UDP_PutIsReady+0x14>
        if(_UDPv4AllocateSktTxBuffer(pSkt, IP_ADDRESS_TYPE_IPV4, true) == 0)
   1c614:	2201      	movs	r2, #1
   1c616:	4611      	mov	r1, r2
   1c618:	4620      	mov	r0, r4
   1c61a:	f7fb f831 	bl	17680 <_UDPv4AllocateSktTxBuffer>
   1c61e:	2800      	cmp	r0, #0
   1c620:	d1f0      	bne.n	1c604 <TCPIP_UDP_PutIsReady+0x1e>
            return 0;
   1c622:	2000      	movs	r0, #0
   1c624:	e7e9      	b.n	1c5fa <TCPIP_UDP_PutIsReady+0x14>
        return pSkt->txEnd - pSkt->txWrite;
   1c626:	6860      	ldr	r0, [r4, #4]
   1c628:	68a3      	ldr	r3, [r4, #8]
   1c62a:	1ac0      	subs	r0, r0, r3
   1c62c:	b280      	uxth	r0, r0
   1c62e:	e7e4      	b.n	1c5fa <TCPIP_UDP_PutIsReady+0x14>
        return 0;
   1c630:	2000      	movs	r0, #0
   1c632:	e7e2      	b.n	1c5fa <TCPIP_UDP_PutIsReady+0x14>

Disassembly of section .text._DRV_ETHPHY_LinkStatPhaseRead%552:

0001c634 <_DRV_ETHPHY_LinkStatPhaseRead>:
{
   1c634:	b510      	push	{r4, lr}
   1c636:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1c638:	f004 f814 	bl	20664 <_DRV_PHY_SMITransfer_Wait>
   1c63c:	b1a0      	cbz	r0, 1c668 <_DRV_ETHPHY_LinkStatPhaseRead+0x34>
    if( phyStat.LINK_STAT != 0 || hClientObj->operReg[0] == 0)
   1c63e:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
   1c642:	f013 0f04 	tst.w	r3, #4
   1c646:	d101      	bne.n	1c64c <_DRV_ETHPHY_LinkStatPhaseRead+0x18>
   1c648:	8c62      	ldrh	r2, [r4, #34]	; 0x22
   1c64a:	b972      	cbnz	r2, 1c66a <_DRV_ETHPHY_LinkStatPhaseRead+0x36>
        DRV_ETHPHY_LINK_STATUS* pLinkStat = (DRV_ETHPHY_LINK_STATUS*)hClientObj->operParam;
   1c64c:	6b22      	ldr	r2, [r4, #48]	; 0x30
        if(pLinkStat)
   1c64e:	b13a      	cbz	r2, 1c660 <_DRV_ETHPHY_LinkStatPhaseRead+0x2c>
    linkStat = (phyStat.LINK_STAT)?DRV_ETHPHY_LINK_ST_UP:DRV_ETHPHY_LINK_ST_DOWN;
   1c650:	f3c3 0180 	ubfx	r1, r3, #2, #1
    if(phyStat.REM_FAULT)
   1c654:	f013 0f10 	tst.w	r3, #16
        linkStat|=DRV_ETHPHY_LINK_ST_REMOTE_FAULT;
   1c658:	bf18      	it	ne
   1c65a:	f041 0104 	orrne.w	r1, r1, #4
            *pLinkStat = _Phy2LinkStat(phyStat);
   1c65e:	8011      	strh	r1, [r2, #0]
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OK);
   1c660:	2100      	movs	r1, #0
   1c662:	4620      	mov	r0, r4
   1c664:	f003 faae 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
}
   1c668:	bd10      	pop	{r4, pc}
        if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   1c66a:	2101      	movs	r1, #1
   1c66c:	4620      	mov	r0, r4
   1c66e:	f002 fb63 	bl	1ed38 <_DRV_PHY_SMIReadStart>
   1c672:	2800      	cmp	r0, #0
   1c674:	d0f8      	beq.n	1c668 <_DRV_ETHPHY_LinkStatPhaseRead+0x34>
    hClientObj->operPhase = operPhase;
   1c676:	2302      	movs	r3, #2
   1c678:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1c67a:	2300      	movs	r3, #0
   1c67c:	8423      	strh	r3, [r4, #32]
   1c67e:	e7f3      	b.n	1c668 <_DRV_ETHPHY_LinkStatPhaseRead+0x34>

Disassembly of section .text._TcpSocketKill%553:

0001c680 <_TcpSocketKill>:
{
   1c680:	b538      	push	{r3, r4, r5, lr}
   1c682:	4604      	mov	r4, r0
    pSkt->smState = newState;
   1c684:	230c      	movs	r3, #12
   1c686:	f880 306e 	strb.w	r3, [r0, #110]	; 0x6e
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1c68a:	2000      	movs	r0, #0
   1c68c:	f004 ff06 	bl	2149c <OSAL_CRIT_Enter>
    TCBStubs[pSkt->sktIx] = 0;
   1c690:	f9b4 1034 	ldrsh.w	r1, [r4, #52]	; 0x34
   1c694:	4b0b      	ldr	r3, [pc, #44]	; (1c6c4 <_TcpSocketKill+0x44>)
   1c696:	681a      	ldr	r2, [r3, #0]
   1c698:	2300      	movs	r3, #0
   1c69a:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   1c69e:	4601      	mov	r1, r0
   1c6a0:	4618      	mov	r0, r3
   1c6a2:	f005 f82a 	bl	216fa <OSAL_CRIT_Leave>
    TCPIP_HEAP_Free(tcpHeapH, (void*)pSkt->rxStart);
   1c6a6:	4d08      	ldr	r5, [pc, #32]	; (1c6c8 <_TcpSocketKill+0x48>)
   1c6a8:	6828      	ldr	r0, [r5, #0]
   1c6aa:	68c3      	ldr	r3, [r0, #12]
   1c6ac:	6961      	ldr	r1, [r4, #20]
   1c6ae:	4798      	blx	r3
    TCPIP_HEAP_Free(tcpHeapH, (void*)pSkt->txStart);
   1c6b0:	6828      	ldr	r0, [r5, #0]
   1c6b2:	68c3      	ldr	r3, [r0, #12]
   1c6b4:	6821      	ldr	r1, [r4, #0]
   1c6b6:	4798      	blx	r3
    TCPIP_HEAP_Free(tcpHeapH, pSkt);
   1c6b8:	6828      	ldr	r0, [r5, #0]
   1c6ba:	68c3      	ldr	r3, [r0, #12]
   1c6bc:	4621      	mov	r1, r4
   1c6be:	4798      	blx	r3
}
   1c6c0:	bd38      	pop	{r3, r4, r5, pc}
   1c6c2:	bf00      	nop
   1c6c4:	2000e594 	.word	0x2000e594
   1c6c8:	2000e59c 	.word	0x2000e59c

Disassembly of section .text.ResetIperfCounters%554:

0001c6cc <ResetIperfCounters>:
    pIState->mMSS = IPERF_TCP_MSS;
   1c6cc:	f240 53b4 	movw	r3, #1460	; 0x5b4
   1c6d0:	f8a0 30d2 	strh.w	r3, [r0, #210]	; 0xd2
    pIState->mDatagramSize = 1470; // -l: default 1470 bytes. UDP datagram size.
   1c6d4:	f240 53be 	movw	r3, #1470	; 0x5be
   1c6d8:	60c3      	str	r3, [r0, #12]
    pIState->totalLen = 0;
   1c6da:	2200      	movs	r2, #0
   1c6dc:	2300      	movs	r3, #0
   1c6de:	e9c0 2308 	strd	r2, r3, [r0, #32]
    pIState->pktId = 0;
   1c6e2:	6283      	str	r3, [r0, #40]	; 0x28
    pIState->lastPktId = 0;
   1c6e4:	62c3      	str	r3, [r0, #44]	; 0x2c
    pIState->errorCount = 0;
   1c6e6:	6303      	str	r3, [r0, #48]	; 0x30
    pIState->outofOrder = 0;
   1c6e8:	6343      	str	r3, [r0, #52]	; 0x34
    pIState->pktCount = 0;
   1c6ea:	f8c0 3094 	str.w	r3, [r0, #148]	; 0x94
    pIState->statusReported = 0;
   1c6ee:	f880 30cd 	strb.w	r3, [r0, #205]	; 0xcd
    pIState->startTime = 0;
   1c6f2:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
    pIState->stopTime = 0;
   1c6f6:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
    pIState->lastCheckPktCount = 0;
   1c6fa:	f8c0 3098 	str.w	r3, [r0, #152]	; 0x98
    pIState->lastCheckPktId = 0;
   1c6fe:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
    pIState->lastCheckErrorCount = 0;
   1c702:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
    pIState->lastCheckTotalLen = 0;
   1c706:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
    pIState->lastCheckTime = 0;
   1c70a:	f8c0 30a8 	str.w	r3, [r0, #168]	; 0xa8
    pIState->isLastTransmit = false;
   1c70e:	f880 30d0 	strb.w	r3, [r0, #208]	; 0xd0
    pIState->txWaitTick = 0;
   1c712:	f8c0 30b4 	str.w	r3, [r0, #180]	; 0xb4
}
   1c716:	4770      	bx	lr

Disassembly of section .text._DHCPSetRunFail%555:

0001c718 <_DHCPSetRunFail>:
    pClient->smState = newState;
   1c718:	f8a0 1056 	strh.w	r1, [r0, #86]	; 0x56
    pClient->dhcpOp = TCPIP_DHCP_OPER_INIT;       // failure forces a brand new lease acquisition
   1c71c:	2301      	movs	r3, #1
   1c71e:	f8a0 3054 	strh.w	r3, [r0, #84]	; 0x54
    if(expBackoff)
   1c722:	b142      	cbz	r2, 1c736 <_DHCPSetRunFail+0x1e>
        pClient->dhcpTmo <<= 1;
   1c724:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
   1c728:	005b      	lsls	r3, r3, #1
   1c72a:	b29b      	uxth	r3, r3
        if(pClient->dhcpTmo > TCPIP_DHCP_EXP_BACKOFF_LIMIT)
   1c72c:	2b40      	cmp	r3, #64	; 0x40
            pClient->dhcpTmo = TCPIP_DHCP_EXP_BACKOFF_LIMIT;
   1c72e:	bf88      	it	hi
   1c730:	2340      	movhi	r3, #64	; 0x40
   1c732:	f8a0 304c 	strh.w	r3, [r0, #76]	; 0x4c
    if(pClient->flags.bReportFail)
   1c736:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   1c73a:	f013 0f20 	tst.w	r3, #32
   1c73e:	d008      	beq.n	1c752 <_DHCPSetRunFail+0x3a>
    pClient->flags.bReportFail = 1;
   1c740:	f043 0320 	orr.w	r3, r3, #32
   1c744:	f880 3058 	strb.w	r3, [r0, #88]	; 0x58
    if(resetTmo || pClient->tOpStart == 0)
   1c748:	6a03      	ldr	r3, [r0, #32]
   1c74a:	b913      	cbnz	r3, 1c752 <_DHCPSetRunFail+0x3a>
    return dhcpSecondCount;
   1c74c:	4b04      	ldr	r3, [pc, #16]	; (1c760 <_DHCPSetRunFail+0x48>)
        pClient->tOpStart = _DHCPSecondCountGet();
   1c74e:	681b      	ldr	r3, [r3, #0]
   1c750:	6203      	str	r3, [r0, #32]
    pClient->flags.bRetry = true;
   1c752:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   1c756:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   1c75a:	f880 3058 	strb.w	r3, [r0, #88]	; 0x58
}
   1c75e:	4770      	bx	lr
   1c760:	2000e620 	.word	0x2000e620

Disassembly of section .text.TCPIP_Helper_IPAddressToString%556:

0001c764 <TCPIP_Helper_IPAddressToString>:
    if(ipAdd && buff)
   1c764:	b1e8      	cbz	r0, 1c7a2 <TCPIP_Helper_IPAddressToString+0x3e>
   1c766:	b1f1      	cbz	r1, 1c7a6 <TCPIP_Helper_IPAddressToString+0x42>
{
   1c768:	b530      	push	{r4, r5, lr}
   1c76a:	b089      	sub	sp, #36	; 0x24
   1c76c:	4615      	mov	r5, r2
   1c76e:	460c      	mov	r4, r1
        sprintf(tempBuff, "%d.%d.%d.%d", ipAdd->v[0], ipAdd->v[1], ipAdd->v[2], ipAdd->v[3]);
   1c770:	78c3      	ldrb	r3, [r0, #3]
   1c772:	9301      	str	r3, [sp, #4]
   1c774:	7883      	ldrb	r3, [r0, #2]
   1c776:	9300      	str	r3, [sp, #0]
   1c778:	7843      	ldrb	r3, [r0, #1]
   1c77a:	7802      	ldrb	r2, [r0, #0]
   1c77c:	490b      	ldr	r1, [pc, #44]	; (1c7ac <TCPIP_Helper_IPAddressToString+0x48>)
   1c77e:	a803      	add	r0, sp, #12
   1c780:	f000 fee2 	bl	1d548 <siprintf>
        len = strlen(tempBuff) + 1;
   1c784:	a803      	add	r0, sp, #12
   1c786:	f005 fa09 	bl	21b9c <strlen>
   1c78a:	3001      	adds	r0, #1
        if(buffSize >= len)
   1c78c:	42a8      	cmp	r0, r5
   1c78e:	d902      	bls.n	1c796 <TCPIP_Helper_IPAddressToString+0x32>
    return false; 
   1c790:	2000      	movs	r0, #0
}
   1c792:	b009      	add	sp, #36	; 0x24
   1c794:	bd30      	pop	{r4, r5, pc}
            strcpy(buff, tempBuff);
   1c796:	a903      	add	r1, sp, #12
   1c798:	4620      	mov	r0, r4
   1c79a:	f005 f9f7 	bl	21b8c <strcpy>
            return true;
   1c79e:	2001      	movs	r0, #1
   1c7a0:	e7f7      	b.n	1c792 <TCPIP_Helper_IPAddressToString+0x2e>
    return false; 
   1c7a2:	2000      	movs	r0, #0
   1c7a4:	4770      	bx	lr
   1c7a6:	2000      	movs	r0, #0
}
   1c7a8:	4770      	bx	lr
   1c7aa:	bf00      	nop
   1c7ac:	0001d914 	.word	0x0001d914

Disassembly of section .text._TCPIP_MacEventCB%557:

0001c7b0 <_TCPIP_MacEventCB>:
{
   1c7b0:	b508      	push	{r3, lr}
    pSigEntry = ((event & (TCPIP_STACK_MAC_ACTIVE_RX_EVENTS)) != 0) ? _TCPIPModuleToSignalEntry(TCPIP_MODULE_MANAGER) : 0;
   1c7b2:	f010 0f16 	tst.w	r0, #22
   1c7b6:	d109      	bne.n	1c7cc <_TCPIP_MacEventCB+0x1c>
    pNetIf->activeEvents |= event;
   1c7b8:	f8b1 305a 	ldrh.w	r3, [r1, #90]	; 0x5a
   1c7bc:	4318      	orrs	r0, r3
   1c7be:	f8a1 005a 	strh.w	r0, [r1, #90]	; 0x5a
    totTcpipEventsCnt++;
   1c7c2:	4a0c      	ldr	r2, [pc, #48]	; (1c7f4 <_TCPIP_MacEventCB+0x44>)
   1c7c4:	6813      	ldr	r3, [r2, #0]
   1c7c6:	3301      	adds	r3, #1
   1c7c8:	6013      	str	r3, [r2, #0]
    if(pSigEntry)
   1c7ca:	e012      	b.n	1c7f2 <_TCPIP_MacEventCB+0x42>
    pNetIf->activeEvents |= event;
   1c7cc:	f8b1 305a 	ldrh.w	r3, [r1, #90]	; 0x5a
   1c7d0:	4318      	orrs	r0, r3
   1c7d2:	f8a1 005a 	strh.w	r0, [r1, #90]	; 0x5a
    totTcpipEventsCnt++;
   1c7d6:	4a07      	ldr	r2, [pc, #28]	; (1c7f4 <_TCPIP_MacEventCB+0x44>)
   1c7d8:	6813      	ldr	r3, [r2, #0]
   1c7da:	3301      	adds	r3, #1
   1c7dc:	6013      	str	r3, [r2, #0]
        pSigEntry->signalVal |= TCPIP_MODULE_SIGNAL_RX_PENDING;
   1c7de:	4806      	ldr	r0, [pc, #24]	; (1c7f8 <_TCPIP_MacEventCB+0x48>)
   1c7e0:	8b03      	ldrh	r3, [r0, #24]
   1c7e2:	f043 0301 	orr.w	r3, r3, #1
   1c7e6:	8303      	strh	r3, [r0, #24]
        _TCPIPSignalEntryNotify(pSigEntry, TCPIP_MODULE_SIGNAL_RX_PENDING, 0);
   1c7e8:	2200      	movs	r2, #0
   1c7ea:	2101      	movs	r1, #1
   1c7ec:	3010      	adds	r0, #16
   1c7ee:	f004 fb1f 	bl	20e30 <_TCPIPSignalEntryNotify>
}
   1c7f2:	bd08      	pop	{r3, pc}
   1c7f4:	2000e650 	.word	0x2000e650
   1c7f8:	2000d1d4 	.word	0x2000d1d4

Disassembly of section .text._UDPClose%558:

0001c7fc <_UDPClose>:
{
   1c7fc:	b510      	push	{r4, lr}
   1c7fe:	4604      	mov	r4, r0
    _UDPFreeTxResources(pSkt);
   1c800:	f003 f806 	bl	1f810 <_UDPFreeTxResources>
    pSkt->extFlags.rxEnable = 0;
   1c804:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   1c808:	f36f 0341 	bfc	r3, #1, #1
   1c80c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    _UDPFreeRxQueue(pSkt);
   1c810:	4620      	mov	r0, r4
   1c812:	f003 fdf1 	bl	203f8 <_UDPFreeRxQueue>
    if(pSkt->pCurrRxPkt != 0)
   1c816:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   1c818:	b120      	cbz	r0, 1c824 <_UDPClose+0x28>
    TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
   1c81a:	2209      	movs	r2, #9
   1c81c:	f06f 0110 	mvn.w	r1, #16
   1c820:	f001 f8b8 	bl	1d994 <_TCPIP_PKT_PacketAcknowledge>
    UDPSocketDcpt[pSkt->sktIx] = 0;
   1c824:	f9b4 2012 	ldrsh.w	r2, [r4, #18]
   1c828:	4b05      	ldr	r3, [pc, #20]	; (1c840 <_UDPClose+0x44>)
   1c82a:	681b      	ldr	r3, [r3, #0]
   1c82c:	2100      	movs	r1, #0
   1c82e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    TCPIP_HEAP_Free(udpMemH, pSkt);
   1c832:	4b04      	ldr	r3, [pc, #16]	; (1c844 <_UDPClose+0x48>)
   1c834:	6818      	ldr	r0, [r3, #0]
   1c836:	68c3      	ldr	r3, [r0, #12]
   1c838:	4621      	mov	r1, r4
   1c83a:	4798      	blx	r3
}
   1c83c:	bd10      	pop	{r4, pc}
   1c83e:	bf00      	nop
   1c840:	2000e65c 	.word	0x2000e65c
   1c844:	2000e66c 	.word	0x2000e66c

Disassembly of section .text.gfx_mono_ssd1306_init%559:

0001c848 <gfx_mono_ssd1306_init>:
void gfx_mono_ssd1306_init(void) {
   1c848:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    for (ix = 0; ix < GFX_MONO_LCD_FRAMEBUFFER_SIZE; ix++) {
   1c84a:	4a11      	ldr	r2, [pc, #68]	; (1c890 <gfx_mono_ssd1306_init+0x48>)
   1c84c:	1e53      	subs	r3, r2, #1
   1c84e:	f202 12ff 	addw	r2, r2, #511	; 0x1ff
        framebuffer[ix] = 0x00;
   1c852:	2100      	movs	r1, #0
   1c854:	f803 1f01 	strb.w	r1, [r3, #1]!
    for (ix = 0; ix < GFX_MONO_LCD_FRAMEBUFFER_SIZE; ix++) {
   1c858:	4293      	cmp	r3, r2
   1c85a:	d1fb      	bne.n	1c854 <gfx_mono_ssd1306_init+0xc>
    gfx_mono_set_framebuffer(framebuffer);
   1c85c:	480c      	ldr	r0, [pc, #48]	; (1c890 <gfx_mono_ssd1306_init+0x48>)
   1c85e:	f005 fb8d 	bl	21f7c <gfx_mono_set_framebuffer>
    ssd1306_init();
   1c862:	f7f8 fcb5 	bl	151d0 <ssd1306_init>
        ssd1306_write_command(SSD1306_CMD_SET_DISPLAY_START_LINE(address));
   1c866:	2040      	movs	r0, #64	; 0x40
   1c868:	f001 f954 	bl	1db14 <ssd1306_write_command>
    for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
   1c86c:	2500      	movs	r5, #0
            gfx_mono_ssd1306_put_byte(page, column, 0x00, true);
   1c86e:	2701      	movs	r7, #1
   1c870:	462e      	mov	r6, r5
void gfx_mono_ssd1306_init(void) {
   1c872:	2400      	movs	r4, #0
            gfx_mono_ssd1306_put_byte(page, column, 0x00, true);
   1c874:	463b      	mov	r3, r7
   1c876:	4632      	mov	r2, r6
   1c878:	b2e1      	uxtb	r1, r4
   1c87a:	4628      	mov	r0, r5
   1c87c:	f000 fe42 	bl	1d504 <gfx_mono_ssd1306_put_byte>
   1c880:	3401      	adds	r4, #1
        for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
   1c882:	2c80      	cmp	r4, #128	; 0x80
   1c884:	d1f6      	bne.n	1c874 <gfx_mono_ssd1306_init+0x2c>
    for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
   1c886:	3501      	adds	r5, #1
   1c888:	b2ed      	uxtb	r5, r5
   1c88a:	2d04      	cmp	r5, #4
   1c88c:	d1f1      	bne.n	1c872 <gfx_mono_ssd1306_init+0x2a>
}
   1c88e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1c890:	2000d444 	.word	0x2000d444

Disassembly of section .text._realloc_r%560:

0001c894 <_realloc_r>:
   1c894:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1c896:	4607      	mov	r7, r0
   1c898:	4614      	mov	r4, r2
   1c89a:	460e      	mov	r6, r1
   1c89c:	b921      	cbnz	r1, 1c8a8 <_realloc_r+0x14>
   1c89e:	4611      	mov	r1, r2
   1c8a0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   1c8a4:	f7fa b852 	b.w	1694c <_malloc_r>
   1c8a8:	b922      	cbnz	r2, 1c8b4 <_realloc_r+0x20>
   1c8aa:	f7fb f913 	bl	17ad4 <_free_r>
   1c8ae:	4625      	mov	r5, r4
   1c8b0:	4628      	mov	r0, r5
   1c8b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1c8b4:	f005 f982 	bl	21bbc <_malloc_usable_size_r>
   1c8b8:	42a0      	cmp	r0, r4
   1c8ba:	d20f      	bcs.n	1c8dc <_realloc_r+0x48>
   1c8bc:	4621      	mov	r1, r4
   1c8be:	4638      	mov	r0, r7
   1c8c0:	f7fa f844 	bl	1694c <_malloc_r>
   1c8c4:	4605      	mov	r5, r0
   1c8c6:	2800      	cmp	r0, #0
   1c8c8:	d0f2      	beq.n	1c8b0 <_realloc_r+0x1c>
   1c8ca:	4631      	mov	r1, r6
   1c8cc:	4622      	mov	r2, r4
   1c8ce:	f004 fbc7 	bl	21060 <memcpy>
   1c8d2:	4631      	mov	r1, r6
   1c8d4:	4638      	mov	r0, r7
   1c8d6:	f7fb f8fd 	bl	17ad4 <_free_r>
   1c8da:	e7e9      	b.n	1c8b0 <_realloc_r+0x1c>
   1c8dc:	4635      	mov	r5, r6
   1c8de:	e7e7      	b.n	1c8b0 <_realloc_r+0x1c>

Disassembly of section .text.TCPIP_IPV4_SelectSourceInterface%561:

0001c8e0 <TCPIP_IPV4_SelectSourceInterface>:
{
   1c8e0:	b570      	push	{r4, r5, r6, lr}
   1c8e2:	460e      	mov	r6, r1
   1c8e4:	4615      	mov	r5, r2
   1c8e6:	b160      	cbz	r0, 1c902 <TCPIP_IPV4_SelectSourceInterface+0x22>
   1c8e8:	4604      	mov	r4, r0
   1c8ea:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1c8ee:	f012 0f40 	tst.w	r2, #64	; 0x40
   1c8f2:	d113      	bne.n	1c91c <TCPIP_IPV4_SelectSourceInterface+0x3c>
    if(srcSet)
   1c8f4:	b93b      	cbnz	r3, 1c906 <TCPIP_IPV4_SelectSourceInterface+0x26>
        pIf = (TCPIP_NET_IF*)TCPIP_IPV4_SelectDestInterface(pDestAddress);
   1c8f6:	4630      	mov	r0, r6
   1c8f8:	f7ff fe4e 	bl	1c598 <TCPIP_IPV4_SelectDestInterface>
    if(pIf)
   1c8fc:	4604      	mov	r4, r0
   1c8fe:	b190      	cbz	r0, 1c926 <TCPIP_IPV4_SelectSourceInterface+0x46>
   1c900:	e00d      	b.n	1c91e <TCPIP_IPV4_SelectSourceInterface+0x3e>
    if(srcSet)
   1c902:	2b00      	cmp	r3, #0
   1c904:	d0f7      	beq.n	1c8f6 <TCPIP_IPV4_SelectSourceInterface+0x16>
            pIf = _TCPIPStackIpAddFromAnyNet(0, pSrcAddress);
   1c906:	4629      	mov	r1, r5
   1c908:	2000      	movs	r0, #0
   1c90a:	f7fe feff 	bl	1b70c <_TCPIPStackIpAddFromAnyNet>
            if(pIf == 0)
   1c90e:	4604      	mov	r4, r0
   1c910:	b948      	cbnz	r0, 1c926 <TCPIP_IPV4_SelectSourceInterface+0x46>
                pIf = (TCPIP_NET_IF*)TCPIP_IPV4_SelectDestInterface(pDestAddress);
   1c912:	4630      	mov	r0, r6
   1c914:	f7ff fe40 	bl	1c598 <TCPIP_IPV4_SelectDestInterface>
   1c918:	4604      	mov	r4, r0
   1c91a:	e004      	b.n	1c926 <TCPIP_IPV4_SelectSourceInterface+0x46>
    if(srcSet)
   1c91c:	b91b      	cbnz	r3, 1c926 <TCPIP_IPV4_SelectSourceInterface+0x46>
        pSrcAddress->Val = TCPIP_STACK_NetAddressGet(pIf);
   1c91e:	4620      	mov	r0, r4
   1c920:	f004 fd98 	bl	21454 <TCPIP_STACK_NetAddressGet>
   1c924:	6028      	str	r0, [r5, #0]
}
   1c926:	4620      	mov	r0, r4
   1c928:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_UDP_ArrayPut%562:

0001c92a <TCPIP_UDP_ArrayPut>:
{
   1c92a:	b570      	push	{r4, r5, r6, lr}
    if(cData != 0 && wDataLen != 0)
   1c92c:	b1d9      	cbz	r1, 1c966 <TCPIP_UDP_ArrayPut+0x3c>
   1c92e:	460d      	mov	r5, r1
   1c930:	b1da      	cbz	r2, 1c96a <TCPIP_UDP_ArrayPut+0x40>
   1c932:	4614      	mov	r4, r2
        UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1c934:	f003 fad6 	bl	1fee4 <_UDPSocketDcpt>
        if(pSkt != 0 && _UDPTxPktValid(pSkt))
   1c938:	4606      	mov	r6, r0
   1c93a:	b1c8      	cbz	r0, 1c970 <TCPIP_UDP_ArrayPut+0x46>
   1c93c:	f004 fc64 	bl	21208 <_UDPTxPktValid>
   1c940:	b908      	cbnz	r0, 1c946 <TCPIP_UDP_ArrayPut+0x1c>
    return 0;
   1c942:	2400      	movs	r4, #0
   1c944:	e012      	b.n	1c96c <TCPIP_UDP_ArrayPut+0x42>
            uint16_t wrSpace = pSkt->txEnd - pSkt->txWrite;
   1c946:	68b0      	ldr	r0, [r6, #8]
   1c948:	6873      	ldr	r3, [r6, #4]
   1c94a:	1a1b      	subs	r3, r3, r0
   1c94c:	b29a      	uxth	r2, r3
   1c94e:	4294      	cmp	r4, r2
   1c950:	bf28      	it	cs
   1c952:	4614      	movcs	r4, r2
            if(wDataLen)
   1c954:	b154      	cbz	r4, 1c96c <TCPIP_UDP_ArrayPut+0x42>
                memcpy(pSkt->txWrite, cData, wDataLen);
   1c956:	4622      	mov	r2, r4
   1c958:	4629      	mov	r1, r5
   1c95a:	f004 fb81 	bl	21060 <memcpy>
                pSkt->txWrite += wDataLen;
   1c95e:	68b3      	ldr	r3, [r6, #8]
   1c960:	4423      	add	r3, r4
   1c962:	60b3      	str	r3, [r6, #8]
   1c964:	e002      	b.n	1c96c <TCPIP_UDP_ArrayPut+0x42>
    return 0;
   1c966:	2400      	movs	r4, #0
   1c968:	e000      	b.n	1c96c <TCPIP_UDP_ArrayPut+0x42>
   1c96a:	4614      	mov	r4, r2
}
   1c96c:	4620      	mov	r0, r4
   1c96e:	bd70      	pop	{r4, r5, r6, pc}
    return 0;
   1c970:	2400      	movs	r4, #0
   1c972:	e7fb      	b.n	1c96c <TCPIP_UDP_ArrayPut+0x42>

Disassembly of section .text.TCPIP_UDP_DestinationIPAddressSet%563:

0001c974 <TCPIP_UDP_DestinationIPAddressSet>:

bool TCPIP_UDP_DestinationIPAddressSet(UDP_SOCKET s, IP_ADDRESS_TYPE addType, IP_MULTI_ADDRESS* remoteAddress)
{
    UDP_SOCKET_DCPT *pSkt;

    if(remoteAddress == 0)
   1c974:	b1fa      	cbz	r2, 1c9b6 <TCPIP_UDP_DestinationIPAddressSet+0x42>
{
   1c976:	b538      	push	{r3, r4, r5, lr}
   1c978:	4615      	mov	r5, r2
   1c97a:	460c      	mov	r4, r1
    {
        return false;
    }

    pSkt = _UDPSocketDcpt(s);
   1c97c:	f003 fab2 	bl	1fee4 <_UDPSocketDcpt>

    while(pSkt != 0 && pSkt->addType == addType)
   1c980:	4603      	mov	r3, r0
   1c982:	b120      	cbz	r0, 1c98e <TCPIP_UDP_DestinationIPAddressSet+0x1a>
   1c984:	8f82      	ldrh	r2, [r0, #60]	; 0x3c
   1c986:	b2a1      	uxth	r1, r4
   1c988:	428a      	cmp	r2, r1
   1c98a:	d001      	beq.n	1c990 <TCPIP_UDP_DestinationIPAddressSet+0x1c>
#endif  // defined (TCPIP_STACK_USE_IPV4)

        break;
    }

    return false;
   1c98c:	2000      	movs	r0, #0
}
   1c98e:	bd38      	pop	{r3, r4, r5, pc}
        if (pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   1c990:	2a01      	cmp	r2, #1
   1c992:	d001      	beq.n	1c998 <TCPIP_UDP_DestinationIPAddressSet+0x24>
    return false;
   1c994:	2000      	movs	r0, #0
   1c996:	e7fa      	b.n	1c98e <TCPIP_UDP_DestinationIPAddressSet+0x1a>
            if(pSkt->flags.bcastForceType != UDP_BCAST_NONE)
   1c998:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
   1c99c:	f012 0f03 	tst.w	r2, #3
   1c9a0:	d10b      	bne.n	1c9ba <TCPIP_UDP_DestinationIPAddressSet+0x46>
            pSkt->destAddress.Val = remoteAddress->v4Add.Val;
   1c9a2:	682a      	ldr	r2, [r5, #0]
   1c9a4:	615a      	str	r2, [r3, #20]
            pSkt->flags.destSet = 1;
   1c9a6:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
   1c9aa:	f042 0201 	orr.w	r2, r2, #1
   1c9ae:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
            return true;
   1c9b2:	2001      	movs	r0, #1
   1c9b4:	e7eb      	b.n	1c98e <TCPIP_UDP_DestinationIPAddressSet+0x1a>
        return false;
   1c9b6:	2000      	movs	r0, #0
}
   1c9b8:	4770      	bx	lr
                return false;
   1c9ba:	2000      	movs	r0, #0
   1c9bc:	e7e7      	b.n	1c98e <TCPIP_UDP_DestinationIPAddressSet+0x1a>

Disassembly of section .text.__ssfputs_r%564:

0001c9be <__ssfputs_r>:
   1c9be:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1c9c0:	460e      	mov	r6, r1
   1c9c2:	6e09      	ldr	r1, [r1, #96]	; 0x60
   1c9c4:	0489      	lsls	r1, r1, #18
   1c9c6:	4607      	mov	r7, r0
   1c9c8:	4614      	mov	r4, r2
   1c9ca:	d40b      	bmi.n	1c9e4 <__ssfputs_r+0x26>
   1c9cc:	18d5      	adds	r5, r2, r3
   1c9ce:	42ac      	cmp	r4, r5
   1c9d0:	d00d      	beq.n	1c9ee <__ssfputs_r+0x30>
   1c9d2:	4632      	mov	r2, r6
   1c9d4:	f814 1b01 	ldrb.w	r1, [r4], #1
   1c9d8:	4638      	mov	r0, r7
   1c9da:	f002 fe25 	bl	1f628 <__sfputc_r>
   1c9de:	3001      	adds	r0, #1
   1c9e0:	d1f5      	bne.n	1c9ce <__ssfputs_r+0x10>
   1c9e2:	e00e      	b.n	1ca02 <__ssfputs_r+0x44>
   1c9e4:	f023 0303 	bic.w	r3, r3, #3
   1c9e8:	18d5      	adds	r5, r2, r3
   1c9ea:	42ac      	cmp	r4, r5
   1c9ec:	d101      	bne.n	1c9f2 <__ssfputs_r+0x34>
   1c9ee:	2000      	movs	r0, #0
   1c9f0:	e009      	b.n	1ca06 <__ssfputs_r+0x48>
   1c9f2:	4632      	mov	r2, r6
   1c9f4:	f854 1b04 	ldr.w	r1, [r4], #4
   1c9f8:	4638      	mov	r0, r7
   1c9fa:	f004 fb5b 	bl	210b4 <_fputwc_r>
   1c9fe:	3001      	adds	r0, #1
   1ca00:	d1f3      	bne.n	1c9ea <__ssfputs_r+0x2c>
   1ca02:	f04f 30ff 	mov.w	r0, #4294967295
   1ca06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.DRV_ETHPHY_NegotiationResultGet%565:

0001ca08 <DRV_ETHPHY_NegotiationResultGet>:
    if(hClientObj != 0)
   1ca08:	4603      	mov	r3, r0
   1ca0a:	b198      	cbz	r0, 1ca34 <DRV_ETHPHY_NegotiationResultGet+0x2c>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1ca0c:	68c0      	ldr	r0, [r0, #12]
   1ca0e:	490f      	ldr	r1, [pc, #60]	; (1ca4c <DRV_ETHPHY_NegotiationResultGet+0x44>)
   1ca10:	4288      	cmp	r0, r1
   1ca12:	d112      	bne.n	1ca3a <DRV_ETHPHY_NegotiationResultGet+0x32>
            if(hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_READY)
   1ca14:	f993 1008 	ldrsb.w	r1, [r3, #8]
   1ca18:	2902      	cmp	r1, #2
   1ca1a:	d111      	bne.n	1ca40 <DRV_ETHPHY_NegotiationResultGet+0x38>
            if(pNegResult == 0)
   1ca1c:	b19a      	cbz	r2, 1ca46 <DRV_ETHPHY_NegotiationResultGet+0x3e>
            hClientObj->operParam = (uintptr_t)pNegResult;
   1ca1e:	631a      	str	r2, [r3, #48]	; 0x30
    hClientObj->operType = opType;
   1ca20:	2204      	movs	r2, #4
   1ca22:	839a      	strh	r2, [r3, #28]
    hClientObj->operPhase = hClientObj->operSubPhase = 0; 
   1ca24:	2200      	movs	r2, #0
   1ca26:	841a      	strh	r2, [r3, #32]
   1ca28:	83da      	strh	r2, [r3, #30]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_BUSY; 
   1ca2a:	2001      	movs	r0, #1
   1ca2c:	7218      	strb	r0, [r3, #8]
    hClientObj->operRes = res;
   1ca2e:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c
   1ca32:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1ca34:	f06f 000a 	mvn.w	r0, #10
   1ca38:	4770      	bx	lr
   1ca3a:	f06f 000a 	mvn.w	r0, #10
   1ca3e:	4770      	bx	lr
                return DRV_ETHPHY_RES_NOT_READY_ERR;
   1ca40:	f06f 0009 	mvn.w	r0, #9
   1ca44:	4770      	bx	lr
                return DRV_ETHPHY_RES_OPERATION_ERR;
   1ca46:	f06f 0008 	mvn.w	r0, #8
}
   1ca4a:	4770      	bx	lr
   1ca4c:	2000e018 	.word	0x2000e018

Disassembly of section .text._DRV_ETHPHY_NegCompletePhaseRead2%566:

0001ca50 <_DRV_ETHPHY_NegCompletePhaseRead2>:
{
   1ca50:	b510      	push	{r4, lr}
   1ca52:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1ca54:	f003 fe06 	bl	20664 <_DRV_PHY_SMITransfer_Wait>
   1ca58:	b168      	cbz	r0, 1ca76 <_DRV_ETHPHY_NegCompletePhaseRead2+0x26>
    hClientObj->operReg[1] = hClientObj->smiData;
   1ca5a:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   1ca5c:	84a3      	strh	r3, [r4, #36]	; 0x24
    if(hClientObj->operParam == 0)
   1ca5e:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1ca60:	b153      	cbz	r3, 1ca78 <_DRV_ETHPHY_NegCompletePhaseRead2+0x28>
    hClientObj->operTStamp = SYS_TMR_TickCountGet() + ((DRV_ETHPHY_NEG_INIT_TMO * SYS_TMR_TickCounterFrequencyGet()) + 999) / 1000;
   1ca62:	f003 facb 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
   1ca66:	f003 faa1 	bl	1ffac <SYS_TMR_TickCountGet>
   1ca6a:	62a0      	str	r0, [r4, #40]	; 0x28
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMCON))
   1ca6c:	2100      	movs	r1, #0
   1ca6e:	4620      	mov	r0, r4
   1ca70:	f002 f962 	bl	1ed38 <_DRV_PHY_SMIReadStart>
   1ca74:	b958      	cbnz	r0, 1ca8e <_DRV_ETHPHY_NegCompletePhaseRead2+0x3e>
}
   1ca76:	bd10      	pop	{r4, pc}
        if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   1ca78:	2101      	movs	r1, #1
   1ca7a:	4620      	mov	r0, r4
   1ca7c:	f002 f95c 	bl	1ed38 <_DRV_PHY_SMIReadStart>
   1ca80:	2800      	cmp	r0, #0
   1ca82:	d0f8      	beq.n	1ca76 <_DRV_ETHPHY_NegCompletePhaseRead2+0x26>
    hClientObj->operPhase = operPhase;
   1ca84:	2303      	movs	r3, #3
   1ca86:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1ca88:	2300      	movs	r3, #0
   1ca8a:	8423      	strh	r3, [r4, #32]
   1ca8c:	e7f3      	b.n	1ca76 <_DRV_ETHPHY_NegCompletePhaseRead2+0x26>
    hClientObj->operPhase = operPhase;
   1ca8e:	2304      	movs	r3, #4
   1ca90:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1ca92:	2300      	movs	r3, #0
   1ca94:	8423      	strh	r3, [r4, #32]
   1ca96:	e7ee      	b.n	1ca76 <_DRV_ETHPHY_NegCompletePhaseRead2+0x26>

Disassembly of section .text.DRV_GMAC_LinkCheck%567:

0001ca98 <DRV_GMAC_LinkCheck>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1ca98:	4b0f      	ldr	r3, [pc, #60]	; (1cad8 <DRV_GMAC_LinkCheck+0x40>)
   1ca9a:	4283      	cmp	r3, r0
   1ca9c:	d116      	bne.n	1cacc <DRV_GMAC_LinkCheck+0x34>
    if(pMACDrv == 0 || (pMACDrv->sGmacData._macFlags._linkPresent == 0))
   1ca9e:	b1b8      	cbz	r0, 1cad0 <DRV_GMAC_LinkCheck+0x38>
   1caa0:	7d9b      	ldrb	r3, [r3, #22]
   1caa2:	f013 0f04 	tst.w	r3, #4
   1caa6:	d015      	beq.n	1cad4 <DRV_GMAC_LinkCheck+0x3c>
{
   1caa8:	b510      	push	{r4, lr}
	pPhyBase->DRV_ETHPHY_Tasks(pMACDrv->sGmacData.hPhySysObject);
   1caaa:	4c0b      	ldr	r4, [pc, #44]	; (1cad8 <DRV_GMAC_LinkCheck+0x40>)
   1caac:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
   1cab0:	691b      	ldr	r3, [r3, #16]
   1cab2:	68e0      	ldr	r0, [r4, #12]
   1cab4:	4798      	blx	r3
    (*_DRV_GMAC_LinkStateTbl[pMACDrv->sGmacData._linkCheckState])(pMACDrv);
   1cab6:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
   1caba:	4b08      	ldr	r3, [pc, #32]	; (1cadc <DRV_GMAC_LinkCheck+0x44>)
   1cabc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1cac0:	4620      	mov	r0, r4
   1cac2:	4798      	blx	r3
    return pMACDrv->sGmacData._macFlags._linkPrev == 1;	
   1cac4:	7da0      	ldrb	r0, [r4, #22]
   1cac6:	f3c0 1000 	ubfx	r0, r0, #4, #1
}
   1caca:	bd10      	pop	{r4, pc}
	    return false;
   1cacc:	2000      	movs	r0, #0
   1cace:	4770      	bx	lr
   1cad0:	2000      	movs	r0, #0
   1cad2:	4770      	bx	lr
   1cad4:	2000      	movs	r0, #0
}
   1cad6:	4770      	bx	lr
   1cad8:	2000dab8 	.word	0x2000dab8
   1cadc:	000217a8 	.word	0x000217a8

Disassembly of section .text._TCPSendWinIncUpdate%568:

0001cae0 <_TCPSendWinIncUpdate>:
{
   1cae0:	b570      	push	{r4, r5, r6, lr}
   1cae2:	4605      	mov	r5, r0
    oldWin = pSkt->localWindow;
   1cae4:	f8b0 605e 	ldrh.w	r6, [r0, #94]	; 0x5e
    wFIFOSize = pSkt->rxEnd - pSkt->rxStart;
   1cae8:	6984      	ldr	r4, [r0, #24]
   1caea:	6943      	ldr	r3, [r0, #20]
   1caec:	1ae4      	subs	r4, r4, r3
   1caee:	b2a4      	uxth	r4, r4
    wDataLen = _TCPIsGetReady(pSkt);
   1caf0:	f004 f87d 	bl	20bee <_TCPIsGetReady>
    return wFIFOSize - wDataLen;
   1caf4:	1a20      	subs	r0, r4, r0
   1caf6:	b280      	uxth	r0, r0
    if(newWin == rxBuffSz)
   1caf8:	4284      	cmp	r4, r0
   1cafa:	d00c      	beq.n	1cb16 <_TCPSendWinIncUpdate+0x36>
    else if(newWin > oldWin)
   1cafc:	4286      	cmp	r6, r0
   1cafe:	d211      	bcs.n	1cb24 <_TCPSendWinIncUpdate+0x44>
        minWinInc = rxBuffSz >> 1; // half RX buffer
   1cb00:	0864      	lsrs	r4, r4, #1
        if((newWin - oldWin) > minWinInc)
   1cb02:	1b80      	subs	r0, r0, r6
   1cb04:	f8b5 3064 	ldrh.w	r3, [r5, #100]	; 0x64
   1cb08:	429c      	cmp	r4, r3
   1cb0a:	bf28      	it	cs
   1cb0c:	461c      	movcs	r4, r3
   1cb0e:	42a0      	cmp	r0, r4
   1cb10:	dc01      	bgt.n	1cb16 <_TCPSendWinIncUpdate+0x36>
    return false;
   1cb12:	2000      	movs	r0, #0
   1cb14:	e007      	b.n	1cb26 <_TCPSendWinIncUpdate+0x46>
        _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS);
   1cb16:	2201      	movs	r2, #1
   1cb18:	2110      	movs	r1, #16
   1cb1a:	4628      	mov	r0, r5
   1cb1c:	f7ea fab4 	bl	7088 <_TcpSend>
        return true;
   1cb20:	2001      	movs	r0, #1
   1cb22:	e000      	b.n	1cb26 <_TCPSendWinIncUpdate+0x46>
    return false;
   1cb24:	2000      	movs	r0, #0
}
   1cb26:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_TCP_DestinationIPAddressSet%569:

0001cb28 <TCPIP_TCP_DestinationIPAddressSet>:
    if(remoteAddress == 0)
   1cb28:	b1f2      	cbz	r2, 1cb68 <TCPIP_TCP_DestinationIPAddressSet+0x40>
{
   1cb2a:	b538      	push	{r3, r4, r5, lr}
   1cb2c:	4615      	mov	r5, r2
   1cb2e:	460c      	mov	r4, r1
    pSkt = _TcpSocketChk(hTCP); 
   1cb30:	f003 f8c0 	bl	1fcb4 <_TcpSocketChk>
    while(pSkt != 0 && pSkt->addType == addType && !_TCP_IsConnected(pSkt))
   1cb34:	4603      	mov	r3, r0
   1cb36:	b120      	cbz	r0, 1cb42 <TCPIP_TCP_DestinationIPAddressSet+0x1a>
   1cb38:	f890 206f 	ldrb.w	r2, [r0, #111]	; 0x6f
   1cb3c:	42a2      	cmp	r2, r4
   1cb3e:	d005      	beq.n	1cb4c <TCPIP_TCP_DestinationIPAddressSet+0x24>
    return false;
   1cb40:	2000      	movs	r0, #0
}
   1cb42:	bd38      	pop	{r3, r4, r5, pc}
            pSkt->destAddress.Val = remoteAddress->v4Add.Val;
   1cb44:	682a      	ldr	r2, [r5, #0]
   1cb46:	639a      	str	r2, [r3, #56]	; 0x38
            return true;
   1cb48:	2001      	movs	r0, #1
   1cb4a:	e7fa      	b.n	1cb42 <TCPIP_TCP_DestinationIPAddressSet+0x1a>
    return (pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1 || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2 || pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT);
   1cb4c:	f890 006e 	ldrb.w	r0, [r0, #110]	; 0x6e
   1cb50:	1ec1      	subs	r1, r0, #3
   1cb52:	b2c9      	uxtb	r1, r1
   1cb54:	2902      	cmp	r1, #2
   1cb56:	d909      	bls.n	1cb6c <TCPIP_TCP_DestinationIPAddressSet+0x44>
    while(pSkt != 0 && pSkt->addType == addType && !_TCP_IsConnected(pSkt))
   1cb58:	2808      	cmp	r0, #8
    return false;
   1cb5a:	bf08      	it	eq
   1cb5c:	2000      	moveq	r0, #0
    while(pSkt != 0 && pSkt->addType == addType && !_TCP_IsConnected(pSkt))
   1cb5e:	d0f0      	beq.n	1cb42 <TCPIP_TCP_DestinationIPAddressSet+0x1a>
        if (pSkt->addType == IP_ADDRESS_TYPE_IPV4)
   1cb60:	2a01      	cmp	r2, #1
   1cb62:	d0ef      	beq.n	1cb44 <TCPIP_TCP_DestinationIPAddressSet+0x1c>
    return false;
   1cb64:	2000      	movs	r0, #0
   1cb66:	e7ec      	b.n	1cb42 <TCPIP_TCP_DestinationIPAddressSet+0x1a>
        return false;
   1cb68:	2000      	movs	r0, #0
}
   1cb6a:	4770      	bx	lr
    return false;
   1cb6c:	2000      	movs	r0, #0
   1cb6e:	e7e8      	b.n	1cb42 <TCPIP_TCP_DestinationIPAddressSet+0x1a>

Disassembly of section .text.TCPIP_ARP_Deinitialize%570:

0001cb70 <TCPIP_ARP_Deinitialize>:
    if(arpMod.initCount > 0)
   1cb70:	4b10      	ldr	r3, [pc, #64]	; (1cbb4 <TCPIP_ARP_Deinitialize+0x44>)
   1cb72:	68db      	ldr	r3, [r3, #12]
   1cb74:	2b00      	cmp	r3, #0
   1cb76:	dd1c      	ble.n	1cbb2 <TCPIP_ARP_Deinitialize+0x42>
{
   1cb78:	b510      	push	{r4, lr}
        if(stackCtrl->stackAction == TCPIP_STACK_ACTION_IF_DOWN)
   1cb7a:	7f02      	ldrb	r2, [r0, #28]
   1cb7c:	2a04      	cmp	r2, #4
   1cb7e:	d004      	beq.n	1cb8a <TCPIP_ARP_Deinitialize+0x1a>
            if(--arpMod.initCount == 0)
   1cb80:	3b01      	subs	r3, #1
   1cb82:	4a0c      	ldr	r2, [pc, #48]	; (1cbb4 <TCPIP_ARP_Deinitialize+0x44>)
   1cb84:	60d3      	str	r3, [r2, #12]
   1cb86:	b18b      	cbz	r3, 1cbac <TCPIP_ARP_Deinitialize+0x3c>
}
   1cb88:	bd10      	pop	{r4, pc}
            if(arpMod.deleteOld)
   1cb8a:	4b0a      	ldr	r3, [pc, #40]	; (1cbb4 <TCPIP_ARP_Deinitialize+0x44>)
   1cb8c:	7c1b      	ldrb	r3, [r3, #16]
   1cb8e:	2b00      	cmp	r3, #0
   1cb90:	d0fa      	beq.n	1cb88 <TCPIP_ARP_Deinitialize+0x18>
    return arpMod.arpCacheDcpt + TCPIP_STACK_NetIxGet(_TCPIPStackNetGetPrimary(pIf));
   1cb92:	4b08      	ldr	r3, [pc, #32]	; (1cbb4 <TCPIP_ARP_Deinitialize+0x44>)
   1cb94:	685c      	ldr	r4, [r3, #4]
   1cb96:	6940      	ldr	r0, [r0, #20]
   1cb98:	f005 f83c 	bl	21c14 <TCPIP_STACK_NetIxGet>
   1cb9c:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
                if(pArpDcpt != 0)
   1cba0:	eb14 00c0 	adds.w	r0, r4, r0, lsl #3
   1cba4:	d0f0      	beq.n	1cb88 <TCPIP_ARP_Deinitialize+0x18>
                    _ARPRemoveCacheEntries(pArpDcpt);
   1cba6:	f003 f8ad 	bl	1fd04 <_ARPRemoveCacheEntries>
   1cbaa:	e7ed      	b.n	1cb88 <TCPIP_ARP_Deinitialize+0x18>
                    _ARPDeleteResources();
   1cbac:	f7fa fd18 	bl	175e0 <_ARPDeleteResources>
}
   1cbb0:	e7ea      	b.n	1cb88 <TCPIP_ARP_Deinitialize+0x18>
   1cbb2:	4770      	bx	lr
   1cbb4:	2000e1a4 	.word	0x2000e1a4

Disassembly of section .rodata._DHCPOptProcTbl%571:

0001cbb8 <_DHCPOptProcTbl>:
   1cbb8:	00000035 0001e35f 00000001 0001dc93     5..._...........
   1cbc8:	00000003 0001deb7 00000006 0001b241     ............A...
   1cbd8:	00000036 0002038d 00000033 0001f45d     6.......3...]...
   1cbe8:	0000003a 0001f48b 0000003b 0001f4b9     :.......;.......
   1cbf8:	000000ff 00022137                       ....7!..

Disassembly of section .text.TCPIP_STACK_MACIdToNet%572:

0001cc00 <TCPIP_STACK_MACIdToNet>:
    if(macId != (TCPIP_STACK_MODULE)TCPIP_MODULE_MAC_NONE)
   1cc00:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
   1cc04:	d017      	beq.n	1cc36 <TCPIP_STACK_MACIdToNet+0x36>
{
   1cc06:	b410      	push	{r4}
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   1cc08:	4b0d      	ldr	r3, [pc, #52]	; (1cc40 <TCPIP_STACK_MACIdToNet+0x40>)
   1cc0a:	681b      	ldr	r3, [r3, #0]
   1cc0c:	4a0d      	ldr	r2, [pc, #52]	; (1cc44 <TCPIP_STACK_MACIdToNet+0x44>)
   1cc0e:	6814      	ldr	r4, [r2, #0]
   1cc10:	2c00      	cmp	r4, #0
   1cc12:	dd13      	ble.n	1cc3c <TCPIP_STACK_MACIdToNet+0x3c>
            if(pNetIf->macId == macId)
   1cc14:	885a      	ldrh	r2, [r3, #2]
   1cc16:	4282      	cmp	r2, r0
   1cc18:	d009      	beq.n	1cc2e <TCPIP_STACK_MACIdToNet+0x2e>
        for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   1cc1a:	2200      	movs	r2, #0
   1cc1c:	3201      	adds	r2, #1
   1cc1e:	336c      	adds	r3, #108	; 0x6c
   1cc20:	42a2      	cmp	r2, r4
   1cc22:	d003      	beq.n	1cc2c <TCPIP_STACK_MACIdToNet+0x2c>
            if(pNetIf->macId == macId)
   1cc24:	8859      	ldrh	r1, [r3, #2]
   1cc26:	4281      	cmp	r1, r0
   1cc28:	d1f8      	bne.n	1cc1c <TCPIP_STACK_MACIdToNet+0x1c>
   1cc2a:	e000      	b.n	1cc2e <TCPIP_STACK_MACIdToNet+0x2e>
    return 0;
   1cc2c:	2300      	movs	r3, #0
}
   1cc2e:	4618      	mov	r0, r3
   1cc30:	f85d 4b04 	ldr.w	r4, [sp], #4
   1cc34:	4770      	bx	lr
    return 0;
   1cc36:	2300      	movs	r3, #0
}
   1cc38:	4618      	mov	r0, r3
   1cc3a:	4770      	bx	lr
    return 0;
   1cc3c:	2300      	movs	r3, #0
   1cc3e:	e7f6      	b.n	1cc2e <TCPIP_STACK_MACIdToNet+0x2e>
   1cc40:	2000e648 	.word	0x2000e648
   1cc44:	2000e2f0 	.word	0x2000e2f0

Disassembly of section .text.TCPIP_STACK_MatchNetAddress%573:

0001cc48 <TCPIP_STACK_MatchNetAddress>:
    if(pIpAdd->Val == 0x0100007f /* || pNetIf->netIPAddr.Val == pIpAdd->Val*/)
   1cc48:	6809      	ldr	r1, [r1, #0]
   1cc4a:	4b0e      	ldr	r3, [pc, #56]	; (1cc84 <TCPIP_STACK_MatchNetAddress+0x3c>)
   1cc4c:	4299      	cmp	r1, r3
   1cc4e:	d018      	beq.n	1cc82 <TCPIP_STACK_MatchNetAddress+0x3a>
{
   1cc50:	b410      	push	{r4}
    for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1cc52:	4b0d      	ldr	r3, [pc, #52]	; (1cc88 <TCPIP_STACK_MatchNetAddress+0x40>)
   1cc54:	6818      	ldr	r0, [r3, #0]
   1cc56:	4b0d      	ldr	r3, [pc, #52]	; (1cc8c <TCPIP_STACK_MatchNetAddress+0x44>)
   1cc58:	681c      	ldr	r4, [r3, #0]
   1cc5a:	2c00      	cmp	r4, #0
   1cc5c:	dd0f      	ble.n	1cc7e <TCPIP_STACK_MatchNetAddress+0x36>
        if(pIf->netIPAddr.Val == pIpAdd->Val)
   1cc5e:	6843      	ldr	r3, [r0, #4]
   1cc60:	4299      	cmp	r1, r3
   1cc62:	d009      	beq.n	1cc78 <TCPIP_STACK_MatchNetAddress+0x30>
    for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1cc64:	2300      	movs	r3, #0
   1cc66:	3301      	adds	r3, #1
   1cc68:	306c      	adds	r0, #108	; 0x6c
   1cc6a:	42a3      	cmp	r3, r4
   1cc6c:	d003      	beq.n	1cc76 <TCPIP_STACK_MatchNetAddress+0x2e>
        if(pIf->netIPAddr.Val == pIpAdd->Val)
   1cc6e:	6842      	ldr	r2, [r0, #4]
   1cc70:	4291      	cmp	r1, r2
   1cc72:	d1f8      	bne.n	1cc66 <TCPIP_STACK_MatchNetAddress+0x1e>
   1cc74:	e000      	b.n	1cc78 <TCPIP_STACK_MatchNetAddress+0x30>
    return 0;
   1cc76:	2000      	movs	r0, #0
}
   1cc78:	f85d 4b04 	ldr.w	r4, [sp], #4
   1cc7c:	4770      	bx	lr
    return 0;
   1cc7e:	2000      	movs	r0, #0
   1cc80:	e7fa      	b.n	1cc78 <TCPIP_STACK_MatchNetAddress+0x30>
}
   1cc82:	4770      	bx	lr
   1cc84:	0100007f 	.word	0x0100007f
   1cc88:	2000e648 	.word	0x2000e648
   1cc8c:	2000e2f0 	.word	0x2000e2f0

Disassembly of section .text._TCPIPStackSignalHandlerRegister%574:

0001cc90 <_TCPIPStackSignalHandlerRegister>:
    if(signalHandler != 0 )
   1cc90:	b1c9      	cbz	r1, 1ccc6 <_TCPIPStackSignalHandlerRegister+0x36>
{
   1cc92:	b430      	push	{r4, r5}
   1cc94:	460c      	mov	r4, r1
        if(TCPIP_MODULE_LAYER1 <= modId && modId < sizeof(TCPIP_STACK_MODULE_SIGNAL_TBL)/sizeof(*TCPIP_STACK_MODULE_SIGNAL_TBL))
   1cc96:	1e83      	subs	r3, r0, #2
   1cc98:	b29b      	uxth	r3, r3
   1cc9a:	2b24      	cmp	r3, #36	; 0x24
   1cc9c:	d815      	bhi.n	1ccca <_TCPIPStackSignalHandlerRegister+0x3a>
            TCPIP_MODULE_SIGNAL_ENTRY* pSignalEntry = TCPIP_STACK_MODULE_SIGNAL_TBL + modId;
   1cc9e:	490c      	ldr	r1, [pc, #48]	; (1ccd0 <_TCPIPStackSignalHandlerRegister+0x40>)
   1cca0:	0103      	lsls	r3, r0, #4
   1cca2:	18c8      	adds	r0, r1, r3
            if(pSignalEntry->signalHandler == 0 || pSignalEntry->signalHandler == signalHandler)
   1cca4:	58cd      	ldr	r5, [r1, r3]
   1cca6:	b125      	cbz	r5, 1ccb2 <_TCPIPStackSignalHandlerRegister+0x22>
   1cca8:	42a5      	cmp	r5, r4
   1ccaa:	d002      	beq.n	1ccb2 <_TCPIPStackSignalHandlerRegister+0x22>
    return 0;
   1ccac:	2000      	movs	r0, #0
}
   1ccae:	bc30      	pop	{r4, r5}
   1ccb0:	4770      	bx	lr
                pSignalEntry->signalHandler = signalHandler;
   1ccb2:	50cc      	str	r4, [r1, r3]
                if ((asyncTmoMs != 0) && (asyncTmoMs < stackTaskRate))
   1ccb4:	b122      	cbz	r2, 1ccc0 <_TCPIPStackSignalHandlerRegister+0x30>
   1ccb6:	4b07      	ldr	r3, [pc, #28]	; (1ccd4 <_TCPIPStackSignalHandlerRegister+0x44>)
   1ccb8:	681b      	ldr	r3, [r3, #0]
   1ccba:	429a      	cmp	r2, r3
                    asyncTmoMs = stackTaskRate;
   1ccbc:	bf38      	it	cc
   1ccbe:	b21a      	sxthcc	r2, r3
                pSignalEntry->asyncTmo = pSignalEntry->currTmo = asyncTmoMs;
   1ccc0:	8182      	strh	r2, [r0, #12]
   1ccc2:	8142      	strh	r2, [r0, #10]
                return pSignalEntry;
   1ccc4:	e7f3      	b.n	1ccae <_TCPIPStackSignalHandlerRegister+0x1e>
    return 0;
   1ccc6:	2000      	movs	r0, #0
}
   1ccc8:	4770      	bx	lr
    return 0;
   1ccca:	2000      	movs	r0, #0
   1cccc:	e7ef      	b.n	1ccae <_TCPIPStackSignalHandlerRegister+0x1e>
   1ccce:	bf00      	nop
   1ccd0:	2000d1d4 	.word	0x2000d1d4
   1ccd4:	2000e640 	.word	0x2000e640

Disassembly of section .text.SERCOM1_USART_ReadNotificationSend%575:

0001ccd8 <SERCOM1_USART_ReadNotificationSend>:
{
   1ccd8:	b508      	push	{r3, lr}
    if (sercom1USARTObj.isRdNotificationEnabled == true)
   1ccda:	4b10      	ldr	r3, [pc, #64]	; (1cd1c <SERCOM1_USART_ReadNotificationSend+0x44>)
   1ccdc:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
   1cce0:	b903      	cbnz	r3, 1cce4 <SERCOM1_USART_ReadNotificationSend+0xc>
}
   1cce2:	bd08      	pop	{r3, pc}
        nUnreadBytesAvailable = SERCOM1_USART_ReadCountGet();
   1cce4:	f004 fc16 	bl	21514 <SERCOM1_USART_ReadCountGet>
        if(sercom1USARTObj.rdCallback != NULL)
   1cce8:	4b0c      	ldr	r3, [pc, #48]	; (1cd1c <SERCOM1_USART_ReadNotificationSend+0x44>)
   1ccea:	6a1b      	ldr	r3, [r3, #32]
   1ccec:	2b00      	cmp	r3, #0
   1ccee:	d0f8      	beq.n	1cce2 <SERCOM1_USART_ReadNotificationSend+0xa>
            if (sercom1USARTObj.isRdNotifyPersistently == true)
   1ccf0:	4a0a      	ldr	r2, [pc, #40]	; (1cd1c <SERCOM1_USART_ReadNotificationSend+0x44>)
   1ccf2:	f892 203c 	ldrb.w	r2, [r2, #60]	; 0x3c
   1ccf6:	b142      	cbz	r2, 1cd0a <SERCOM1_USART_ReadNotificationSend+0x32>
                if (nUnreadBytesAvailable >= sercom1USARTObj.rdThreshold)
   1ccf8:	4a08      	ldr	r2, [pc, #32]	; (1cd1c <SERCOM1_USART_ReadNotificationSend+0x44>)
   1ccfa:	6b92      	ldr	r2, [r2, #56]	; 0x38
   1ccfc:	4282      	cmp	r2, r0
   1ccfe:	d8f0      	bhi.n	1cce2 <SERCOM1_USART_ReadNotificationSend+0xa>
                    sercom1USARTObj.rdCallback(SERCOM_USART_EVENT_READ_THRESHOLD_REACHED, sercom1USARTObj.rdContext);
   1cd00:	4a06      	ldr	r2, [pc, #24]	; (1cd1c <SERCOM1_USART_ReadNotificationSend+0x44>)
   1cd02:	6a51      	ldr	r1, [r2, #36]	; 0x24
   1cd04:	2000      	movs	r0, #0
   1cd06:	4798      	blx	r3
   1cd08:	e7eb      	b.n	1cce2 <SERCOM1_USART_ReadNotificationSend+0xa>
                if (nUnreadBytesAvailable == sercom1USARTObj.rdThreshold)
   1cd0a:	4a04      	ldr	r2, [pc, #16]	; (1cd1c <SERCOM1_USART_ReadNotificationSend+0x44>)
   1cd0c:	6b92      	ldr	r2, [r2, #56]	; 0x38
   1cd0e:	4282      	cmp	r2, r0
   1cd10:	d1e7      	bne.n	1cce2 <SERCOM1_USART_ReadNotificationSend+0xa>
                    sercom1USARTObj.rdCallback(SERCOM_USART_EVENT_READ_THRESHOLD_REACHED, sercom1USARTObj.rdContext);
   1cd12:	4a02      	ldr	r2, [pc, #8]	; (1cd1c <SERCOM1_USART_ReadNotificationSend+0x44>)
   1cd14:	6a51      	ldr	r1, [r2, #36]	; 0x24
   1cd16:	2000      	movs	r0, #0
   1cd18:	4798      	blx	r3
}
   1cd1a:	e7e2      	b.n	1cce2 <SERCOM1_USART_ReadNotificationSend+0xa>
   1cd1c:	2000e1f0 	.word	0x2000e1f0

Disassembly of section .rodata.keySeqTbl%576:

0001cd20 <keySeqTbl>:
   1cd20:	0000d364 00020cc1 00000003 0000d368     d...........h...
   1cd30:	0002155d 00000003 0000d36c 00020a51     ].......l...Q...
   1cd40:	00000003 0000d370 00020f2d 00000003     ....p...-.......
   1cd50:	0000d374 0001f1f5 00000004 0000d37c     t...........|...
   1cd60:	0001f1c5 00000004                       ........

Disassembly of section .rodata.TCPIP_STACK_MODULE_CONFIG_TBL%577:

0001cd68 <TCPIP_STACK_MODULE_CONFIG_TBL>:
   1cd68:	00000003 00021b0c 00000006 00000000     ................
   1cd78:	00000002 00020024 00000009 000220cc     ....$........ ..
   1cd88:	0000000a 000220c4 0000000c 00021afc     ..... ..........
   1cd98:	0000000f 000215ec 00000001 2000e478     ............x.. 
   1cda8:	00001050 0001eb64                       P...d...

Disassembly of section .text.xPortStartScheduler%578:

0001cdb0 <xPortStartScheduler>:
{
   1cdb0:	b510      	push	{r4, lr}
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
   1cdb2:	4b0e      	ldr	r3, [pc, #56]	; (1cdec <xPortStartScheduler+0x3c>)
   1cdb4:	681a      	ldr	r2, [r3, #0]
   1cdb6:	f442 0260 	orr.w	r2, r2, #14680064	; 0xe00000
   1cdba:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
   1cdbc:	681a      	ldr	r2, [r3, #0]
   1cdbe:	f042 4260 	orr.w	r2, r2, #3758096384	; 0xe0000000
   1cdc2:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
   1cdc4:	f003 f956 	bl	20074 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
   1cdc8:	2400      	movs	r4, #0
   1cdca:	4b09      	ldr	r3, [pc, #36]	; (1cdf0 <xPortStartScheduler+0x40>)
   1cdcc:	601c      	str	r4, [r3, #0]
	vPortEnableVFP();
   1cdce:	f004 fd6d 	bl	218ac <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
   1cdd2:	4a08      	ldr	r2, [pc, #32]	; (1cdf4 <xPortStartScheduler+0x44>)
   1cdd4:	6813      	ldr	r3, [r2, #0]
   1cdd6:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
   1cdda:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
   1cddc:	f003 f936 	bl	2004c <prvPortStartFirstTask>
	vTaskSwitchContext();
   1cde0:	f7fa f9bc 	bl	1715c <vTaskSwitchContext>
	prvTaskExitError();
   1cde4:	f003 fe84 	bl	20af0 <prvTaskExitError>
}
   1cde8:	4620      	mov	r0, r4
   1cdea:	bd10      	pop	{r4, pc}
   1cdec:	e000ed20 	.word	0xe000ed20
   1cdf0:	2000e698 	.word	0x2000e698
   1cdf4:	e000ef34 	.word	0xe000ef34

Disassembly of section .text.wc_CryptoCb_FindDeviceByIndex%579:

0001cdf8 <wc_CryptoCb_FindDeviceByIndex>:
    for (i=startIdx; i<MAX_CRYPTO_DEVID_CALLBACKS; i++) {
   1cdf8:	2807      	cmp	r0, #7
   1cdfa:	dc1c      	bgt.n	1ce36 <wc_CryptoCb_FindDeviceByIndex+0x3e>
        if (gCryptoDev[i].devId != INVALID_DEVID)
   1cdfc:	eb00 0340 	add.w	r3, r0, r0, lsl #1
   1ce00:	4a0e      	ldr	r2, [pc, #56]	; (1ce3c <wc_CryptoCb_FindDeviceByIndex+0x44>)
   1ce02:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1ce06:	f113 0f02 	cmn.w	r3, #2
   1ce0a:	d10c      	bne.n	1ce26 <wc_CryptoCb_FindDeviceByIndex+0x2e>
   1ce0c:	eb00 0340 	add.w	r3, r0, r0, lsl #1
   1ce10:	4a0a      	ldr	r2, [pc, #40]	; (1ce3c <wc_CryptoCb_FindDeviceByIndex+0x44>)
   1ce12:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    for (i=startIdx; i<MAX_CRYPTO_DEVID_CALLBACKS; i++) {
   1ce16:	3001      	adds	r0, #1
   1ce18:	2808      	cmp	r0, #8
   1ce1a:	d00a      	beq.n	1ce32 <wc_CryptoCb_FindDeviceByIndex+0x3a>
        if (gCryptoDev[i].devId != INVALID_DEVID)
   1ce1c:	f853 2f0c 	ldr.w	r2, [r3, #12]!
   1ce20:	f112 0f02 	cmn.w	r2, #2
   1ce24:	d0f7      	beq.n	1ce16 <wc_CryptoCb_FindDeviceByIndex+0x1e>
            return &gCryptoDev[i];
   1ce26:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   1ce2a:	4b04      	ldr	r3, [pc, #16]	; (1ce3c <wc_CryptoCb_FindDeviceByIndex+0x44>)
   1ce2c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1ce30:	4770      	bx	lr
    return NULL;
   1ce32:	2000      	movs	r0, #0
   1ce34:	4770      	bx	lr
   1ce36:	2000      	movs	r0, #0
}
   1ce38:	4770      	bx	lr
   1ce3a:	bf00      	nop
   1ce3c:	2000e0e4 	.word	0x2000e0e4

Disassembly of section .text.__libc_init_array%580:

0001ce40 <__libc_init_array>:
   1ce40:	b570      	push	{r4, r5, r6, lr}
   1ce42:	4d0d      	ldr	r5, [pc, #52]	; (1ce78 <__libc_init_array+0x38>)
   1ce44:	4c0d      	ldr	r4, [pc, #52]	; (1ce7c <__libc_init_array+0x3c>)
   1ce46:	1b64      	subs	r4, r4, r5
   1ce48:	10a4      	asrs	r4, r4, #2
   1ce4a:	2600      	movs	r6, #0
   1ce4c:	42a6      	cmp	r6, r4
   1ce4e:	d109      	bne.n	1ce64 <__libc_init_array+0x24>
   1ce50:	4d0b      	ldr	r5, [pc, #44]	; (1ce80 <__libc_init_array+0x40>)
   1ce52:	4c0c      	ldr	r4, [pc, #48]	; (1ce84 <__libc_init_array+0x44>)
   1ce54:	f7e3 fa06 	bl	264 <_init>
   1ce58:	1b64      	subs	r4, r4, r5
   1ce5a:	10a4      	asrs	r4, r4, #2
   1ce5c:	2600      	movs	r6, #0
   1ce5e:	42a6      	cmp	r6, r4
   1ce60:	d105      	bne.n	1ce6e <__libc_init_array+0x2e>
   1ce62:	bd70      	pop	{r4, r5, r6, pc}
   1ce64:	f855 3b04 	ldr.w	r3, [r5], #4
   1ce68:	4798      	blx	r3
   1ce6a:	3601      	adds	r6, #1
   1ce6c:	e7ee      	b.n	1ce4c <__libc_init_array+0xc>
   1ce6e:	f855 3b04 	ldr.w	r3, [r5], #4
   1ce72:	4798      	blx	r3
   1ce74:	3601      	adds	r6, #1
   1ce76:	e7f2      	b.n	1ce5e <__libc_init_array+0x1e>
   1ce78:	00000270 	.word	0x00000270
   1ce7c:	00000270 	.word	0x00000270
   1ce80:	00000270 	.word	0x00000270
   1ce84:	00000274 	.word	0x00000274

Disassembly of section .text.srand%581:

0001ce88 <srand>:
   1ce88:	b538      	push	{r3, r4, r5, lr}
   1ce8a:	4b0d      	ldr	r3, [pc, #52]	; (1cec0 <srand+0x38>)
   1ce8c:	681c      	ldr	r4, [r3, #0]
   1ce8e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1ce90:	4605      	mov	r5, r0
   1ce92:	b97b      	cbnz	r3, 1ceb4 <srand+0x2c>
   1ce94:	2018      	movs	r0, #24
   1ce96:	f004 fe61 	bl	21b5c <malloc>
   1ce9a:	4a0a      	ldr	r2, [pc, #40]	; (1cec4 <srand+0x3c>)
   1ce9c:	4b0a      	ldr	r3, [pc, #40]	; (1cec8 <srand+0x40>)
   1ce9e:	63a0      	str	r0, [r4, #56]	; 0x38
   1cea0:	e9c0 2300 	strd	r2, r3, [r0]
   1cea4:	4b09      	ldr	r3, [pc, #36]	; (1cecc <srand+0x44>)
   1cea6:	6083      	str	r3, [r0, #8]
   1cea8:	230b      	movs	r3, #11
   1ceaa:	8183      	strh	r3, [r0, #12]
   1ceac:	2201      	movs	r2, #1
   1ceae:	2300      	movs	r3, #0
   1ceb0:	e9c0 2304 	strd	r2, r3, [r0, #16]
   1ceb4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1ceb6:	2200      	movs	r2, #0
   1ceb8:	611d      	str	r5, [r3, #16]
   1ceba:	615a      	str	r2, [r3, #20]
   1cebc:	bd38      	pop	{r3, r4, r5, pc}
   1cebe:	bf00      	nop
   1cec0:	2000e700 	.word	0x2000e700
   1cec4:	abcd330e 	.word	0xabcd330e
   1cec8:	e66d1234 	.word	0xe66d1234
   1cecc:	0005deec 	.word	0x0005deec

Disassembly of section .text.std%582:

0001ced0 <std>:
   1ced0:	2300      	movs	r3, #0
   1ced2:	b510      	push	{r4, lr}
   1ced4:	4604      	mov	r4, r0
   1ced6:	e9c0 3300 	strd	r3, r3, [r0]
   1ceda:	6083      	str	r3, [r0, #8]
   1cedc:	8181      	strh	r1, [r0, #12]
   1cede:	6603      	str	r3, [r0, #96]	; 0x60
   1cee0:	81c2      	strh	r2, [r0, #14]
   1cee2:	e9c0 3304 	strd	r3, r3, [r0, #16]
   1cee6:	6183      	str	r3, [r0, #24]
   1cee8:	4619      	mov	r1, r3
   1ceea:	2208      	movs	r2, #8
   1ceec:	3058      	adds	r0, #88	; 0x58
   1ceee:	f004 fe45 	bl	21b7c <memset>
   1cef2:	4b05      	ldr	r3, [pc, #20]	; (1cf08 <std+0x38>)
   1cef4:	6263      	str	r3, [r4, #36]	; 0x24
   1cef6:	4b05      	ldr	r3, [pc, #20]	; (1cf0c <std+0x3c>)
   1cef8:	62a3      	str	r3, [r4, #40]	; 0x28
   1cefa:	4b05      	ldr	r3, [pc, #20]	; (1cf10 <std+0x40>)
   1cefc:	62e3      	str	r3, [r4, #44]	; 0x2c
   1cefe:	4b05      	ldr	r3, [pc, #20]	; (1cf14 <std+0x44>)
   1cf00:	6224      	str	r4, [r4, #32]
   1cf02:	6323      	str	r3, [r4, #48]	; 0x30
   1cf04:	bd10      	pop	{r4, pc}
   1cf06:	bf00      	nop
   1cf08:	0002070f 	.word	0x0002070f
   1cf0c:	0001e6ad 	.word	0x0001e6ad
   1cf10:	000205b1 	.word	0x000205b1
   1cf14:	000220fd 	.word	0x000220fd

Disassembly of section .text.__swhatbuf_r%583:

0001cf18 <__swhatbuf_r>:
   1cf18:	b570      	push	{r4, r5, r6, lr}
   1cf1a:	460e      	mov	r6, r1
   1cf1c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   1cf20:	2900      	cmp	r1, #0
   1cf22:	b090      	sub	sp, #64	; 0x40
   1cf24:	4614      	mov	r4, r2
   1cf26:	461d      	mov	r5, r3
   1cf28:	da07      	bge.n	1cf3a <__swhatbuf_r+0x22>
   1cf2a:	2300      	movs	r3, #0
   1cf2c:	602b      	str	r3, [r5, #0]
   1cf2e:	89b3      	ldrh	r3, [r6, #12]
   1cf30:	061a      	lsls	r2, r3, #24
   1cf32:	d410      	bmi.n	1cf56 <__swhatbuf_r+0x3e>
   1cf34:	f44f 6380 	mov.w	r3, #1024	; 0x400
   1cf38:	e00e      	b.n	1cf58 <__swhatbuf_r+0x40>
   1cf3a:	aa01      	add	r2, sp, #4
   1cf3c:	f003 fb5c 	bl	205f8 <_fstat_r>
   1cf40:	2800      	cmp	r0, #0
   1cf42:	dbf2      	blt.n	1cf2a <__swhatbuf_r+0x12>
   1cf44:	9a02      	ldr	r2, [sp, #8]
   1cf46:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
   1cf4a:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
   1cf4e:	425a      	negs	r2, r3
   1cf50:	415a      	adcs	r2, r3
   1cf52:	602a      	str	r2, [r5, #0]
   1cf54:	e7ee      	b.n	1cf34 <__swhatbuf_r+0x1c>
   1cf56:	2340      	movs	r3, #64	; 0x40
   1cf58:	2000      	movs	r0, #0
   1cf5a:	6023      	str	r3, [r4, #0]
   1cf5c:	b010      	add	sp, #64	; 0x40
   1cf5e:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.Lan867x_Write_Register%584:

0001cf60 <Lan867x_Write_Register>:
{
   1cf60:	b510      	push	{r4, lr}
   1cf62:	b082      	sub	sp, #8
   1cf64:	4604      	mov	r4, r0
   1cf66:	f8ad 2006 	strh.w	r2, [sp, #6]
    if (R2F(clientObj->vendorData, VENDOR_INTERNAL_STATE) == IDLE_PHASE) {
   1cf6a:	6843      	ldr	r3, [r0, #4]
   1cf6c:	0e5a      	lsrs	r2, r3, #25
   1cf6e:	d00f      	beq.n	1cf90 <Lan867x_Write_Register+0x30>
    res = Lan867x_Miim_Task(clientObj, DRV_MIIM_OP_WRITE, regAddr, &wData);
   1cf70:	f10d 0306 	add.w	r3, sp, #6
   1cf74:	460a      	mov	r2, r1
   1cf76:	2102      	movs	r1, #2
   1cf78:	4620      	mov	r0, r4
   1cf7a:	f7f1 fdc1 	bl	eb00 <Lan867x_Miim_Task>
    if (res == DRV_MIIM_RES_OK) {
   1cf7e:	4603      	mov	r3, r0
   1cf80:	b918      	cbnz	r0, 1cf8a <Lan867x_Write_Register+0x2a>
        clientObj->vendorData = F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   1cf82:	6862      	ldr	r2, [r4, #4]
   1cf84:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   1cf88:	6062      	str	r2, [r4, #4]
}
   1cf8a:	4618      	mov	r0, r3
   1cf8c:	b002      	add	sp, #8
   1cf8e:	bd10      	pop	{r4, pc}
            F2R(initialState, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   1cf90:	291f      	cmp	r1, #31
   1cf92:	bf94      	ite	ls
   1cf94:	f04f 6280 	movls.w	r2, #67108864	; 0x4000000
   1cf98:	f04f 6200 	movhi.w	r2, #134217728	; 0x8000000
   1cf9c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
        clientObj->vendorData = F2R(false, VENDOR_IS_BIT_OP, clientObj->vendorData);
   1cfa0:	4313      	orrs	r3, r2
   1cfa2:	6043      	str	r3, [r0, #4]
   1cfa4:	e7e4      	b.n	1cf70 <Lan867x_Write_Register+0x10>

Disassembly of section .text._DRV_GMAC_LinkStateGetLink%585:

0001cfa6 <_DRV_GMAC_LinkStateGetLink>:
{
   1cfa6:	b538      	push	{r3, r4, r5, lr}
   1cfa8:	4604      	mov	r4, r0
	pPhyBase =  pMACDrv->sGmacData.gmacConfig.pPhyBase;
   1cfaa:	f8d0 50d8 	ldr.w	r5, [r0, #216]	; 0xd8
	phyStat = pPhyBase->DRV_ETHPHY_ClientStatus( pMACDrv->sGmacData.hPhyClient );
   1cfae:	69eb      	ldr	r3, [r5, #28]
   1cfb0:	6900      	ldr	r0, [r0, #16]
   1cfb2:	4798      	blx	r3
	if(phyStat == DRV_ETHPHY_CLIENT_STATUS_BUSY)
   1cfb4:	2801      	cmp	r0, #1
   1cfb6:	d010      	beq.n	1cfda <_DRV_GMAC_LinkStateGetLink+0x34>
	phyRes = pPhyBase->DRV_ETHPHY_ClientOperationResult(pMACDrv->sGmacData.hPhyClient);
   1cfb8:	6a2b      	ldr	r3, [r5, #32]
   1cfba:	6920      	ldr	r0, [r4, #16]
   1cfbc:	4798      	blx	r3
	if(phyRes != DRV_ETHPHY_RES_OK)
   1cfbe:	b968      	cbnz	r0, 1cfdc <_DRV_GMAC_LinkStateGetLink+0x36>
	if(linkCurrUp == false)
   1cfc0:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
   1cfc4:	f013 0f01 	tst.w	r3, #1
   1cfc8:	d00c      	beq.n	1cfe4 <_DRV_GMAC_LinkStateGetLink+0x3e>
	if( (bool) pMACDrv->sGmacData._macFlags._linkPrev == linkCurrUp )
   1cfca:	7da3      	ldrb	r3, [r4, #22]
   1cfcc:	f013 0f10 	tst.w	r3, #16
		pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_START_LINK;
   1cfd0:	bf14      	ite	ne
   1cfd2:	2300      	movne	r3, #0
		pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_WAIT_LINK_UP;
   1cfd4:	2302      	moveq	r3, #2
   1cfd6:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
}
   1cfda:	bd38      	pop	{r3, r4, r5, pc}
		_DRV_GMAC_LinkStateDown(pMACDrv);
   1cfdc:	4620      	mov	r0, r4
   1cfde:	f003 fdf7 	bl	20bd0 <_DRV_GMAC_LinkStateDown>
		return;
   1cfe2:	e7fa      	b.n	1cfda <_DRV_GMAC_LinkStateGetLink+0x34>
		_DRV_GMAC_LinkStateDown(pMACDrv);
   1cfe4:	4620      	mov	r0, r4
   1cfe6:	f003 fdf3 	bl	20bd0 <_DRV_GMAC_LinkStateDown>
		return;
   1cfea:	e7f6      	b.n	1cfda <_DRV_GMAC_LinkStateGetLink+0x34>

Disassembly of section .text.TCPIP_TCP_FifoTxFullGet%586:

0001cfec <TCPIP_TCP_FifoTxFullGet>:
{
   1cfec:	b510      	push	{r4, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   1cfee:	f002 fe61 	bl	1fcb4 <_TcpSocketChk>
    if(pSkt != 0 && _TCP_TxPktValid(pSkt))
   1cff2:	b1d0      	cbz	r0, 1d02a <TCPIP_TCP_FifoTxFullGet+0x3e>
   1cff4:	4604      	mov	r4, r0
    switch(pSkt->addType)
   1cff6:	f890 306f 	ldrb.w	r3, [r0, #111]	; 0x6f
   1cffa:	2b01      	cmp	r3, #1
   1cffc:	d001      	beq.n	1d002 <TCPIP_TCP_FifoTxFullGet+0x16>
    return 0;
   1cffe:	2000      	movs	r0, #0
}
   1d000:	bd10      	pop	{r4, pc}
    if(pSkt != 0 && _TCP_TxPktValid(pSkt))
   1d002:	6c43      	ldr	r3, [r0, #68]	; 0x44
   1d004:	b19b      	cbz	r3, 1d02e <TCPIP_TCP_FifoTxFullGet+0x42>
        if((pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED) || (pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT))
   1d006:	f890 306e 	ldrb.w	r3, [r0, #110]	; 0x6e
   1d00a:	2b03      	cmp	r3, #3
   1d00c:	d003      	beq.n	1d016 <TCPIP_TCP_FifoTxFullGet+0x2a>
   1d00e:	2b08      	cmp	r3, #8
   1d010:	d001      	beq.n	1d016 <TCPIP_TCP_FifoTxFullGet+0x2a>
    return 0;
   1d012:	2000      	movs	r0, #0
   1d014:	e7f4      	b.n	1d000 <TCPIP_TCP_FifoTxFullGet+0x14>
            wDataLen = _TCPSocketTxFreeSize(pSkt);
   1d016:	4620      	mov	r0, r4
   1d018:	f001 ff9c 	bl	1ef54 <_TCPSocketTxFreeSize>
            wFIFOSize = pSkt->txEnd - pSkt->txStart - 1;
   1d01c:	6863      	ldr	r3, [r4, #4]
   1d01e:	6822      	ldr	r2, [r4, #0]
   1d020:	1a9b      	subs	r3, r3, r2
   1d022:	3b01      	subs	r3, #1
            return wFIFOSize - wDataLen;
   1d024:	1a18      	subs	r0, r3, r0
   1d026:	b280      	uxth	r0, r0
   1d028:	e7ea      	b.n	1d000 <TCPIP_TCP_FifoTxFullGet+0x14>
    return 0;
   1d02a:	2000      	movs	r0, #0
   1d02c:	e7e8      	b.n	1d000 <TCPIP_TCP_FifoTxFullGet+0x14>
   1d02e:	2000      	movs	r0, #0
   1d030:	e7e6      	b.n	1d000 <TCPIP_TCP_FifoTxFullGet+0x14>

Disassembly of section .text.TCPIP_ARP_Resolve%587:

0001d032 <TCPIP_ARP_Resolve>:
    if(IPAddr == 0 || IPAddr->Val == 0)
   1d032:	b1a9      	cbz	r1, 1d060 <TCPIP_ARP_Resolve+0x2e>
{
   1d034:	b530      	push	{r4, r5, lr}
   1d036:	b083      	sub	sp, #12
   1d038:	460c      	mov	r4, r1
    if(IPAddr == 0 || IPAddr->Val == 0)
   1d03a:	680a      	ldr	r2, [r1, #0]
   1d03c:	b19a      	cbz	r2, 1d066 <TCPIP_ARP_Resolve+0x34>
    pIf = _TCPIPStackHandleToNetLinked(hNet);
   1d03e:	f003 fcc7 	bl	209d0 <_TCPIPStackHandleToNetLinked>
    if(pIf == 0)
   1d042:	b198      	cbz	r0, 1d06c <TCPIP_ARP_Resolve+0x3a>
    return pNetIf->Flags.bInConfig != 0;
   1d044:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
    if(_TCPIPStackIsConfig(pIf))
   1d048:	f013 0f10 	tst.w	r3, #16
   1d04c:	d111      	bne.n	1d072 <TCPIP_ARP_Resolve+0x40>
    return _ARPProbeAddress(pIf, IPAddr, &pIf->netIPAddr, ARP_OPERATION_REQ, 0);
   1d04e:	2300      	movs	r3, #0
   1d050:	9300      	str	r3, [sp, #0]
   1d052:	2301      	movs	r3, #1
   1d054:	1d02      	adds	r2, r0, #4
   1d056:	4621      	mov	r1, r4
   1d058:	f7f7 fbd2 	bl	14800 <_ARPProbeAddress>
}
   1d05c:	b003      	add	sp, #12
   1d05e:	bd30      	pop	{r4, r5, pc}
        return ARP_RES_BAD_ADDRESS;
   1d060:	f06f 0004 	mvn.w	r0, #4
}
   1d064:	4770      	bx	lr
        return ARP_RES_BAD_ADDRESS;
   1d066:	f06f 0004 	mvn.w	r0, #4
   1d06a:	e7f7      	b.n	1d05c <TCPIP_ARP_Resolve+0x2a>
        return ARP_RES_NO_INTERFACE;
   1d06c:	f06f 0005 	mvn.w	r0, #5
   1d070:	e7f4      	b.n	1d05c <TCPIP_ARP_Resolve+0x2a>
        return ARP_RES_CONFIGURE_ERR;
   1d072:	f06f 0007 	mvn.w	r0, #7
   1d076:	e7f1      	b.n	1d05c <TCPIP_ARP_Resolve+0x2a>

Disassembly of section .text._TCPIP_HEAP_Delete%588:

0001d078 <_TCPIP_HEAP_Delete>:
    if(hInst == 0)
   1d078:	b1f0      	cbz	r0, 1d0b8 <_TCPIP_HEAP_Delete+0x40>
{
   1d07a:	b510      	push	{r4, lr}
   1d07c:	4604      	mov	r4, r0
    if(hDcpt->_heapHead)
   1d07e:	6a43      	ldr	r3, [r0, #36]	; 0x24
   1d080:	b1a3      	cbz	r3, 1d0ac <_TCPIP_HEAP_Delete+0x34>
        if(hDcpt->_heapAllocatedUnits != 0)
   1d082:	6b03      	ldr	r3, [r0, #48]	; 0x30
   1d084:	b963      	cbnz	r3, 1d0a0 <_TCPIP_HEAP_Delete+0x28>
        OSAL_SEM_Delete(&hDcpt->_heapSemaphore);
   1d086:	3044      	adds	r0, #68	; 0x44
   1d088:	f004 fc70 	bl	2196c <OSAL_SEM_Delete>
        memset(&hInst->heapObj, 0, sizeof(hInst->heapObj));
   1d08c:	2224      	movs	r2, #36	; 0x24
   1d08e:	2100      	movs	r1, #0
   1d090:	4620      	mov	r0, r4
   1d092:	f004 fd73 	bl	21b7c <memset>
        (*hDcpt->free_fnc)(hDcpt->allocatedBuffer);
   1d096:	6c23      	ldr	r3, [r4, #64]	; 0x40
   1d098:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1d09a:	4798      	blx	r3
        return TCPIP_STACK_HEAP_RES_OK;
   1d09c:	2000      	movs	r0, #0
}
   1d09e:	bd10      	pop	{r4, pc}
            return (hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_IN_USE); 
   1d0a0:	23f9      	movs	r3, #249	; 0xf9
   1d0a2:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
   1d0a6:	f06f 0006 	mvn.w	r0, #6
   1d0aa:	e7f8      	b.n	1d09e <_TCPIP_HEAP_Delete+0x26>
    return (hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_IN_USE); 
   1d0ac:	23f9      	movs	r3, #249	; 0xf9
   1d0ae:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
   1d0b2:	f06f 0006 	mvn.w	r0, #6
   1d0b6:	e7f2      	b.n	1d09e <_TCPIP_HEAP_Delete+0x26>
        return TCPIP_STACK_HEAP_RES_NO_HEAP; 
   1d0b8:	f06f 0008 	mvn.w	r0, #8
}
   1d0bc:	4770      	bx	lr

Disassembly of section .text.TCPIP_Helper_SingleListNodeRemove%589:

0001d0be <TCPIP_Helper_SingleListNodeRemove>:
// Use a double linked list if faster operation needed!



SGL_LIST_NODE*  TCPIP_Helper_SingleListNodeRemove(SINGLE_LIST* pL, SGL_LIST_NODE* pN)
{
   1d0be:	b510      	push	{r4, lr}
    if(pN == pL->head)
   1d0c0:	6802      	ldr	r2, [r0, #0]
   1d0c2:	428a      	cmp	r2, r1
   1d0c4:	d00b      	beq.n	1d0de <TCPIP_Helper_SingleListNodeRemove+0x20>
        TCPIP_Helper_SingleListHeadRemove(pL);
    }
    else
    {
        SGL_LIST_NODE* prev;
        for(prev = pL->head; prev != 0 && prev->next != pN; prev = prev->next);
   1d0c6:	b182      	cbz	r2, 1d0ea <TCPIP_Helper_SingleListNodeRemove+0x2c>
   1d0c8:	6814      	ldr	r4, [r2, #0]
   1d0ca:	42a1      	cmp	r1, r4
   1d0cc:	bf08      	it	eq
   1d0ce:	4614      	moveq	r4, r2
   1d0d0:	d00d      	beq.n	1d0ee <TCPIP_Helper_SingleListNodeRemove+0x30>
   1d0d2:	b1ac      	cbz	r4, 1d100 <TCPIP_Helper_SingleListNodeRemove+0x42>
   1d0d4:	6822      	ldr	r2, [r4, #0]
   1d0d6:	428a      	cmp	r2, r1
   1d0d8:	d009      	beq.n	1d0ee <TCPIP_Helper_SingleListNodeRemove+0x30>
   1d0da:	4614      	mov	r4, r2
   1d0dc:	e7f9      	b.n	1d0d2 <TCPIP_Helper_SingleListNodeRemove+0x14>
   1d0de:	460c      	mov	r4, r1
        TCPIP_Helper_SingleListHeadRemove(pL);
   1d0e0:	f003 fe8a 	bl	20df8 <TCPIP_Helper_SingleListHeadRemove>
   1d0e4:	e00c      	b.n	1d100 <TCPIP_Helper_SingleListNodeRemove+0x42>
        }
        // found it
        prev->next = pN->next;
        if(pN == pL->tail)
        {
            pL->tail = prev;
   1d0e6:	6044      	str	r4, [r0, #4]
   1d0e8:	e006      	b.n	1d0f8 <TCPIP_Helper_SingleListNodeRemove+0x3a>
            return 0;
   1d0ea:	4614      	mov	r4, r2
   1d0ec:	e008      	b.n	1d100 <TCPIP_Helper_SingleListNodeRemove+0x42>
        prev->next = pN->next;
   1d0ee:	680a      	ldr	r2, [r1, #0]
   1d0f0:	6022      	str	r2, [r4, #0]
        if(pN == pL->tail)
   1d0f2:	6842      	ldr	r2, [r0, #4]
   1d0f4:	428a      	cmp	r2, r1
   1d0f6:	d0f6      	beq.n	1d0e6 <TCPIP_Helper_SingleListNodeRemove+0x28>
        }
        pL->nNodes--;
   1d0f8:	6883      	ldr	r3, [r0, #8]
   1d0fa:	3b01      	subs	r3, #1
   1d0fc:	6083      	str	r3, [r0, #8]
    }

    return pN;
   1d0fe:	460c      	mov	r4, r1
}
   1d100:	4620      	mov	r0, r4
   1d102:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_Notification_CbackRemove%590:

0001d104 <TCPIP_Notification_CbackRemove>:
    return false;

}

bool TCPIP_Notification_CbackRemove(SGL_LIST_NODE* node, PROTECTED_SINGLE_LIST* notifyList, TCPIP_STACK_HEAP_HANDLE heapH, void (*pCback)(SGL_LIST_NODE* node))
{
   1d104:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d108:	4606      	mov	r6, r0
   1d10a:	460c      	mov	r4, r1
   1d10c:	4690      	mov	r8, r2
   1d10e:	461f      	mov	r7, r3
    if(TCPIP_Helper_ProtectedSingleListLock(notifyList))
   1d110:	4608      	mov	r0, r1
   1d112:	f003 fc2d 	bl	20970 <TCPIP_Helper_ProtectedSingleListLock>
   1d116:	4605      	mov	r5, r0
   1d118:	b910      	cbnz	r0, 1d120 <TCPIP_Notification_CbackRemove+0x1c>
            TCPIP_HEAP_Free(heapH, node);
            return true;
        }
    }
    return false;
}
   1d11a:	4628      	mov	r0, r5
   1d11c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        SGL_LIST_NODE* ret = TCPIP_Helper_SingleListNodeRemove(&notifyList->list, node);
   1d120:	4631      	mov	r1, r6
   1d122:	4620      	mov	r0, r4
   1d124:	f7ff ffcb 	bl	1d0be <TCPIP_Helper_SingleListNodeRemove>
        if(ret && pCback)
   1d128:	b150      	cbz	r0, 1d140 <TCPIP_Notification_CbackRemove+0x3c>
   1d12a:	b107      	cbz	r7, 1d12e <TCPIP_Notification_CbackRemove+0x2a>
            (*pCback)(ret);
   1d12c:	47b8      	blx	r7
        TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
   1d12e:	4620      	mov	r0, r4
   1d130:	f003 fe70 	bl	20e14 <TCPIP_Helper_ProtectedSingleListUnlock>
   1d134:	f8d8 300c 	ldr.w	r3, [r8, #12]
   1d138:	4631      	mov	r1, r6
   1d13a:	4640      	mov	r0, r8
   1d13c:	4798      	blx	r3
            return true;
   1d13e:	e7ec      	b.n	1d11a <TCPIP_Notification_CbackRemove+0x16>
        TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
   1d140:	4620      	mov	r0, r4
   1d142:	f003 fe67 	bl	20e14 <TCPIP_Helper_ProtectedSingleListUnlock>
    return false;
   1d146:	2500      	movs	r5, #0
   1d148:	e7e7      	b.n	1d11a <TCPIP_Notification_CbackRemove+0x16>

Disassembly of section .text.TCPIP_UDP_SignalHandlerRegister%591:

0001d14a <TCPIP_UDP_SignalHandlerRegister>:

    return true;
}

TCPIP_UDP_SIGNAL_HANDLE TCPIP_UDP_SignalHandlerRegister(UDP_SOCKET s, TCPIP_UDP_SIGNAL_TYPE sigMask, TCPIP_UDP_SIGNAL_FUNCTION handler, const void* hParam)
{
   1d14a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d14e:	4604      	mov	r4, r0
   1d150:	460f      	mov	r7, r1
   1d152:	4615      	mov	r5, r2
   1d154:	4698      	mov	r8, r3
    TCPIP_UDP_SIGNAL_HANDLE sHandle = 0;

    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1d156:	2000      	movs	r0, #0
   1d158:	f004 f9a0 	bl	2149c <OSAL_CRIT_Enter>
   1d15c:	4606      	mov	r6, r0
    if(handler != 0)
   1d15e:	b19d      	cbz	r5, 1d188 <TCPIP_UDP_SignalHandlerRegister+0x3e>
    {
        UDP_SOCKET_DCPT *pSkt = _UDPSocketDcpt(s);
   1d160:	4620      	mov	r0, r4
   1d162:	f002 febf 	bl	1fee4 <_UDPSocketDcpt>
        if(pSkt != 0 && pSkt->sigHandler == 0)
   1d166:	4604      	mov	r4, r0
   1d168:	b138      	cbz	r0, 1d17a <TCPIP_UDP_SignalHandlerRegister+0x30>
   1d16a:	6d03      	ldr	r3, [r0, #80]	; 0x50
   1d16c:	b973      	cbnz	r3, 1d18c <TCPIP_UDP_SignalHandlerRegister+0x42>
        {
            pSkt->sigHandler = handler;
   1d16e:	6505      	str	r5, [r0, #80]	; 0x50
            pSkt->sigParam = hParam;
   1d170:	f8c0 8054 	str.w	r8, [r0, #84]	; 0x54
            pSkt->sigMask = sigMask;
   1d174:	f8a0 7058 	strh.w	r7, [r0, #88]	; 0x58
            sHandle = (TCPIP_UDP_SIGNAL_HANDLE)handler;
   1d178:	462c      	mov	r4, r5
            // Note: this may change if multiple notfication handlers required 
        }
    }

    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1d17a:	4631      	mov	r1, r6
   1d17c:	2000      	movs	r0, #0
   1d17e:	f004 fabc 	bl	216fa <OSAL_CRIT_Leave>
    return sHandle;
}
   1d182:	4620      	mov	r0, r4
   1d184:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    TCPIP_UDP_SIGNAL_HANDLE sHandle = 0;
   1d188:	2400      	movs	r4, #0
   1d18a:	e7f6      	b.n	1d17a <TCPIP_UDP_SignalHandlerRegister+0x30>
   1d18c:	2400      	movs	r4, #0
   1d18e:	e7f4      	b.n	1d17a <TCPIP_UDP_SignalHandlerRegister+0x30>

Disassembly of section .text.DRV_GMAC_ConfigGet%592:

0001d190 <DRV_GMAC_ConfigGet>:
{	
   1d190:	b430      	push	{r4, r5}
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1d192:	4c0e      	ldr	r4, [pc, #56]	; (1d1cc <DRV_GMAC_ConfigGet+0x3c>)
   1d194:	4284      	cmp	r4, r0
   1d196:	d114      	bne.n	1d1c2 <DRV_GMAC_ConfigGet+0x32>
    if(pMACDrv != 0)
   1d198:	b1a0      	cbz	r0, 1d1c4 <DRV_GMAC_ConfigGet+0x34>
        if(pConfigSize)
   1d19a:	b10b      	cbz	r3, 1d1a0 <DRV_GMAC_ConfigGet+0x10>
            *pConfigSize =  sizeof(TCPIP_MODULE_MAC_PIC32C_CONFIG);
   1d19c:	2034      	movs	r0, #52	; 0x34
   1d19e:	6018      	str	r0, [r3, #0]
        if(configBuff && buffSize >= sizeof(TCPIP_MODULE_MAC_PIC32C_CONFIG))
   1d1a0:	b191      	cbz	r1, 1d1c8 <DRV_GMAC_ConfigGet+0x38>
   1d1a2:	2a33      	cmp	r2, #51	; 0x33
   1d1a4:	d801      	bhi.n	1d1aa <DRV_GMAC_ConfigGet+0x1a>
    return 0;
   1d1a6:	2000      	movs	r0, #0
   1d1a8:	e00c      	b.n	1d1c4 <DRV_GMAC_ConfigGet+0x34>
            *pMacConfig = pMACDrv->sGmacData.gmacConfig;
   1d1aa:	460c      	mov	r4, r1
   1d1ac:	4d08      	ldr	r5, [pc, #32]	; (1d1d0 <DRV_GMAC_ConfigGet+0x40>)
   1d1ae:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1d1b0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1d1b2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1d1b4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1d1b6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1d1b8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1d1ba:	682b      	ldr	r3, [r5, #0]
   1d1bc:	6023      	str	r3, [r4, #0]
            return sizeof(TCPIP_MODULE_MAC_PIC32C_CONFIG);
   1d1be:	2034      	movs	r0, #52	; 0x34
   1d1c0:	e000      	b.n	1d1c4 <DRV_GMAC_ConfigGet+0x34>
    return 0;
   1d1c2:	2000      	movs	r0, #0
}
   1d1c4:	bc30      	pop	{r4, r5}
   1d1c6:	4770      	bx	lr
    return 0;
   1d1c8:	2000      	movs	r0, #0
   1d1ca:	e7fb      	b.n	1d1c4 <DRV_GMAC_ConfigGet+0x34>
   1d1cc:	2000dab8 	.word	0x2000dab8
   1d1d0:	2000db70 	.word	0x2000db70

Disassembly of section .text._MacTxDiscardQueues%593:

0001d1d4 <_MacTxDiscardQueues>:
{
   1d1d4:	b570      	push	{r4, r5, r6, lr}
   1d1d6:	4605      	mov	r5, r0
   1d1d8:	460e      	mov	r6, r1
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_TXEN_Msk;           
   1d1da:	4c0e      	ldr	r4, [pc, #56]	; (1d214 <_MacTxDiscardQueues+0x40>)
   1d1dc:	6823      	ldr	r3, [r4, #0]
   1d1de:	f023 0308 	bic.w	r3, r3, #8
   1d1e2:	6023      	str	r3, [r4, #0]
    GMAC_REGS->GMAC_TSR = GMAC_TSR_TXCOMP_Msk;
   1d1e4:	2320      	movs	r3, #32
   1d1e6:	6163      	str	r3, [r4, #20]
    DRV_PIC32CGMAC_LibTxAckPacket(pMACDrv,queueIdx);
   1d1e8:	2100      	movs	r1, #0
   1d1ea:	f7f3 fec9 	bl	10f80 <DRV_PIC32CGMAC_LibTxAckPacket>
        DRV_PIC32CGMAC_LibTxAckErrPacket(pMACDrv, queueIdx, ackRes); 
   1d1ee:	4632      	mov	r2, r6
   1d1f0:	2100      	movs	r1, #0
   1d1f2:	4628      	mov	r0, r5
   1d1f4:	f7fb fdb2 	bl	18d5c <DRV_PIC32CGMAC_LibTxAckErrPacket>
        DRV_PIC32CGMAC_LibTxAckPendPacket(pMACDrv, queueIdx, ackRes);  
   1d1f8:	4632      	mov	r2, r6
   1d1fa:	2100      	movs	r1, #0
   1d1fc:	4628      	mov	r0, r5
   1d1fe:	f001 fde6 	bl	1edce <DRV_PIC32CGMAC_LibTxAckPendPacket>
        DRV_PIC32CGMAC_LibTxInit(pMACDrv);
   1d202:	4628      	mov	r0, r5
   1d204:	f7fc fb1c 	bl	19840 <DRV_PIC32CGMAC_LibTxInit>
    GMAC_REGS->GMAC_NCR |= GMAC_NCR_TXEN_Msk; 
   1d208:	6823      	ldr	r3, [r4, #0]
   1d20a:	f043 0308 	orr.w	r3, r3, #8
   1d20e:	6023      	str	r3, [r4, #0]
}
   1d210:	bd70      	pop	{r4, r5, r6, pc}
   1d212:	bf00      	nop
   1d214:	42000800 	.word	0x42000800

Disassembly of section .text.Helper_SingleListNodeRemove%594:

0001d218 <Helper_SingleListNodeRemove>:
// Use a double linked list if faster operation needed!



SGL_LIST_NODE*  Helper_SingleListNodeRemove(SINGLE_LIST* pL, SGL_LIST_NODE* pN)
{
   1d218:	b508      	push	{r3, lr}
    if(pN == pL->head)
   1d21a:	6803      	ldr	r3, [r0, #0]
   1d21c:	428b      	cmp	r3, r1
   1d21e:	d00c      	beq.n	1d23a <Helper_SingleListNodeRemove+0x22>
   1d220:	4602      	mov	r2, r0
        return Helper_SingleListHeadRemove(pL);
    }
    else
    {
        SGL_LIST_NODE* prev;
        for(prev = pL->head; prev != 0 && prev->next != pN; prev = prev->next);
   1d222:	b17b      	cbz	r3, 1d244 <Helper_SingleListNodeRemove+0x2c>
   1d224:	6818      	ldr	r0, [r3, #0]
   1d226:	4281      	cmp	r1, r0
   1d228:	bf08      	it	eq
   1d22a:	4618      	moveq	r0, r3
   1d22c:	d00c      	beq.n	1d248 <Helper_SingleListNodeRemove+0x30>
   1d22e:	b1a0      	cbz	r0, 1d25a <Helper_SingleListNodeRemove+0x42>
   1d230:	6803      	ldr	r3, [r0, #0]
   1d232:	428b      	cmp	r3, r1
   1d234:	d008      	beq.n	1d248 <Helper_SingleListNodeRemove+0x30>
   1d236:	4618      	mov	r0, r3
   1d238:	e7f9      	b.n	1d22e <Helper_SingleListNodeRemove+0x16>
        return Helper_SingleListHeadRemove(pL);
   1d23a:	f003 fd97 	bl	20d6c <Helper_SingleListHeadRemove>
   1d23e:	e00c      	b.n	1d25a <Helper_SingleListNodeRemove+0x42>
        }
        // found it
        prev->next = pN->next;
        if(pN == pL->tail)
        {
            pL->tail = prev;
   1d240:	6050      	str	r0, [r2, #4]
   1d242:	e006      	b.n	1d252 <Helper_SingleListNodeRemove+0x3a>
            return 0;
   1d244:	4618      	mov	r0, r3
   1d246:	e008      	b.n	1d25a <Helper_SingleListNodeRemove+0x42>
        prev->next = pN->next;
   1d248:	680b      	ldr	r3, [r1, #0]
   1d24a:	6003      	str	r3, [r0, #0]
        if(pN == pL->tail)
   1d24c:	6853      	ldr	r3, [r2, #4]
   1d24e:	428b      	cmp	r3, r1
   1d250:	d0f6      	beq.n	1d240 <Helper_SingleListNodeRemove+0x28>
        }
        pL->nNodes--;
   1d252:	6893      	ldr	r3, [r2, #8]
   1d254:	3b01      	subs	r3, #1
   1d256:	6093      	str	r3, [r2, #8]
    }

    return pN;
   1d258:	4608      	mov	r0, r1
}
   1d25a:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_TCP_SignalHandlerRegister%595:

0001d25c <TCPIP_TCP_SignalHandlerRegister>:
    }
}


TCPIP_TCP_SIGNAL_HANDLE TCPIP_TCP_SignalHandlerRegister(TCP_SOCKET s, TCPIP_TCP_SIGNAL_TYPE sigMask, TCPIP_TCP_SIGNAL_FUNCTION handler, const void* hParam)
{
   1d25c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d260:	4604      	mov	r4, r0
   1d262:	4688      	mov	r8, r1
   1d264:	4615      	mov	r5, r2
   1d266:	461f      	mov	r7, r3
    TCPIP_TCP_SIGNAL_HANDLE sHandle = 0;

    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1d268:	2000      	movs	r0, #0
   1d26a:	f004 f917 	bl	2149c <OSAL_CRIT_Enter>
   1d26e:	4606      	mov	r6, r0
    if(handler != 0)
   1d270:	b195      	cbz	r5, 1d298 <TCPIP_TCP_SignalHandlerRegister+0x3c>
    {
        TCB_STUB* pSkt = _TcpSocketChk(s);
   1d272:	4620      	mov	r0, r4
   1d274:	f002 fd1e 	bl	1fcb4 <_TcpSocketChk>
        if(pSkt != 0 && pSkt->sigHandler == 0)
   1d278:	4604      	mov	r4, r0
   1d27a:	b130      	cbz	r0, 1d28a <TCPIP_TCP_SignalHandlerRegister+0x2e>
   1d27c:	6f43      	ldr	r3, [r0, #116]	; 0x74
   1d27e:	b96b      	cbnz	r3, 1d29c <TCPIP_TCP_SignalHandlerRegister+0x40>
        {
            pSkt->sigHandler = handler;
   1d280:	6745      	str	r5, [r0, #116]	; 0x74
            pSkt->sigMask = (uint16_t)sigMask;
   1d282:	f8a0 8072 	strh.w	r8, [r0, #114]	; 0x72
            pSkt->sigParam = hParam;
   1d286:	6787      	str	r7, [r0, #120]	; 0x78
            sHandle = (TCPIP_TCP_SIGNAL_HANDLE)handler;
   1d288:	462c      	mov	r4, r5
            // Note: this may change if multiple notfication handlers required 
        }
    }
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1d28a:	4631      	mov	r1, r6
   1d28c:	2000      	movs	r0, #0
   1d28e:	f004 fa34 	bl	216fa <OSAL_CRIT_Leave>

    return sHandle;
}
   1d292:	4620      	mov	r0, r4
   1d294:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    TCPIP_TCP_SIGNAL_HANDLE sHandle = 0;
   1d298:	2400      	movs	r4, #0
   1d29a:	e7f6      	b.n	1d28a <TCPIP_TCP_SignalHandlerRegister+0x2e>
   1d29c:	2400      	movs	r4, #0
   1d29e:	e7f4      	b.n	1d28a <TCPIP_TCP_SignalHandlerRegister+0x2e>

Disassembly of section .text.TCPIP_Helper_MACAddressToString%596:

0001d2a0 <TCPIP_Helper_MACAddressToString>:
    if(macAddr && buff && buffSize >= 18)
   1d2a0:	b1d0      	cbz	r0, 1d2d8 <TCPIP_Helper_MACAddressToString+0x38>
   1d2a2:	4603      	mov	r3, r0
   1d2a4:	b1d1      	cbz	r1, 1d2dc <TCPIP_Helper_MACAddressToString+0x3c>
   1d2a6:	2a11      	cmp	r2, #17
   1d2a8:	d801      	bhi.n	1d2ae <TCPIP_Helper_MACAddressToString+0xe>
    return false;
   1d2aa:	2000      	movs	r0, #0
}
   1d2ac:	4770      	bx	lr
{
   1d2ae:	b500      	push	{lr}
   1d2b0:	b085      	sub	sp, #20
   1d2b2:	4602      	mov	r2, r0
   1d2b4:	4608      	mov	r0, r1
        sprintf(buff, "%.2x:%.2x:%.2x:%.2x:%.2x:%.2x", *pAdd, *(pAdd+1), *(pAdd+2), *(pAdd+3), *(pAdd+4), *(pAdd+5));
   1d2b6:	795b      	ldrb	r3, [r3, #5]
   1d2b8:	9303      	str	r3, [sp, #12]
   1d2ba:	7913      	ldrb	r3, [r2, #4]
   1d2bc:	9302      	str	r3, [sp, #8]
   1d2be:	78d3      	ldrb	r3, [r2, #3]
   1d2c0:	9301      	str	r3, [sp, #4]
   1d2c2:	7893      	ldrb	r3, [r2, #2]
   1d2c4:	9300      	str	r3, [sp, #0]
   1d2c6:	7853      	ldrb	r3, [r2, #1]
   1d2c8:	7812      	ldrb	r2, [r2, #0]
   1d2ca:	4905      	ldr	r1, [pc, #20]	; (1d2e0 <TCPIP_Helper_MACAddressToString+0x40>)
   1d2cc:	f000 f93c 	bl	1d548 <siprintf>
        return true;
   1d2d0:	2001      	movs	r0, #1
}
   1d2d2:	b005      	add	sp, #20
   1d2d4:	f85d fb04 	ldr.w	pc, [sp], #4
    return false;
   1d2d8:	2000      	movs	r0, #0
   1d2da:	4770      	bx	lr
   1d2dc:	2000      	movs	r0, #0
   1d2de:	4770      	bx	lr
   1d2e0:	0001d920 	.word	0x0001d920

Disassembly of section .text.TCPIP_STACK_NetByAddress%597:

0001d2e4 <TCPIP_STACK_NetByAddress>:
{
   1d2e4:	b430      	push	{r4, r5}
    for(netIx = 0, pIf = tcpipNetIf ; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pIf++)
   1d2e6:	4b0e      	ldr	r3, [pc, #56]	; (1d320 <TCPIP_STACK_NetByAddress+0x3c>)
   1d2e8:	681b      	ldr	r3, [r3, #0]
   1d2ea:	4a0e      	ldr	r2, [pc, #56]	; (1d324 <TCPIP_STACK_NetByAddress+0x40>)
   1d2ec:	6814      	ldr	r4, [r2, #0]
   1d2ee:	2c00      	cmp	r4, #0
   1d2f0:	dd13      	ble.n	1d31a <TCPIP_STACK_NetByAddress+0x36>
   1d2f2:	2200      	movs	r2, #0
   1d2f4:	e003      	b.n	1d2fe <TCPIP_STACK_NetByAddress+0x1a>
   1d2f6:	3201      	adds	r2, #1
   1d2f8:	336c      	adds	r3, #108	; 0x6c
   1d2fa:	42a2      	cmp	r2, r4
   1d2fc:	d009      	beq.n	1d312 <TCPIP_STACK_NetByAddress+0x2e>
        if(pIf->Flags.bInterfaceEnabled && pIf->netIPAddr.Val == pIpAddress->Val)
   1d2fe:	f893 1042 	ldrb.w	r1, [r3, #66]	; 0x42
   1d302:	f011 0f40 	tst.w	r1, #64	; 0x40
   1d306:	d0f6      	beq.n	1d2f6 <TCPIP_STACK_NetByAddress+0x12>
   1d308:	685d      	ldr	r5, [r3, #4]
   1d30a:	6801      	ldr	r1, [r0, #0]
   1d30c:	428d      	cmp	r5, r1
   1d30e:	d1f2      	bne.n	1d2f6 <TCPIP_STACK_NetByAddress+0x12>
   1d310:	e000      	b.n	1d314 <TCPIP_STACK_NetByAddress+0x30>
    return 0;
   1d312:	2300      	movs	r3, #0
}
   1d314:	4618      	mov	r0, r3
   1d316:	bc30      	pop	{r4, r5}
   1d318:	4770      	bx	lr
    return 0;
   1d31a:	2300      	movs	r3, #0
   1d31c:	e7fa      	b.n	1d314 <TCPIP_STACK_NetByAddress+0x30>
   1d31e:	bf00      	nop
   1d320:	2000e648 	.word	0x2000e648
   1d324:	2000e2f0 	.word	0x2000e2f0

Disassembly of section .text.TCPIP_STACK_AddressServiceEvent%598:

0001d328 <TCPIP_STACK_AddressServiceEvent>:
{
   1d328:	b508      	push	{r3, lr}
    if(evType == TCPIP_STACK_ADDRESS_SERVICE_EVENT_RUN_RESTORE)
   1d32a:	2a04      	cmp	r2, #4
   1d32c:	d015      	beq.n	1d35a <TCPIP_STACK_AddressServiceEvent+0x32>
    else if(evType == TCPIP_STACK_ADDRESS_SERVICE_EVENT_CONN_LOST)
   1d32e:	2a02      	cmp	r2, #2
   1d330:	d012      	beq.n	1d358 <TCPIP_STACK_AddressServiceEvent+0x30>
    else if(adSvcType == TCPIP_STACK_ADDRESS_SERVICE_DHCPS)
   1d332:	2903      	cmp	r1, #3
   1d334:	d010      	beq.n	1d358 <TCPIP_STACK_AddressServiceEvent+0x30>
    pNetIf->Flags.v &= ~TCPIP_STACK_ADDRESS_SERVICE_MASK;
   1d336:	f8b0 3042 	ldrh.w	r3, [r0, #66]	; 0x42
   1d33a:	f023 0307 	bic.w	r3, r3, #7
   1d33e:	f8a0 3042 	strh.w	r3, [r0, #66]	; 0x42
    pNetIf->Flags.bInConfig = config;
   1d342:	0a1b      	lsrs	r3, r3, #8
   1d344:	f043 0310 	orr.w	r3, r3, #16
   1d348:	f880 3043 	strb.w	r3, [r0, #67]	; 0x43
    pNetIf->dnsServer[0].Val = pNetIf->DefaultDNSServer[0].Val;
   1d34c:	6a43      	ldr	r3, [r0, #36]	; 0x24
   1d34e:	6103      	str	r3, [r0, #16]
    pNetIf->dnsServer[1].Val = pNetIf->DefaultDNSServer[1].Val;
   1d350:	6a83      	ldr	r3, [r0, #40]	; 0x28
   1d352:	6143      	str	r3, [r0, #20]
    TCPIP_STACK_AddressServiceDefaultSet(pNetIf);
   1d354:	f000 fcbc 	bl	1dcd0 <TCPIP_STACK_AddressServiceDefaultSet>
}
   1d358:	bd08      	pop	{r3, pc}
        if(adSvcType == TCPIP_STACK_ADDRESS_SERVICE_DHCPC)
   1d35a:	2901      	cmp	r1, #1
   1d35c:	d1eb      	bne.n	1d336 <TCPIP_STACK_AddressServiceEvent+0xe>
            pNetIf->Flags.bIsDHCPEnabled = 1;
   1d35e:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   1d362:	f043 0301 	orr.w	r3, r3, #1
   1d366:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
            return;
   1d36a:	e7f5      	b.n	1d358 <TCPIP_STACK_AddressServiceEvent+0x30>

Disassembly of section .text._TCPIPStackModuleRxInsert%599:

0001d36c <_TCPIPStackModuleRxInsert>:
{
   1d36c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1d36e:	4604      	mov	r4, r0
   1d370:	460f      	mov	r7, r1
   1d372:	4615      	mov	r5, r2
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1d374:	2000      	movs	r0, #0
   1d376:	f004 f891 	bl	2149c <OSAL_CRIT_Enter>
   1d37a:	4606      	mov	r6, r0
    SINGLE_LIST* pQueue = TCPIP_MODULES_QUEUE_TBL + modId;
   1d37c:	eb04 0044 	add.w	r0, r4, r4, lsl #1
    TCPIP_Helper_SingleListTailAdd(pQueue, (SGL_LIST_NODE*)pRxPkt);
   1d380:	4639      	mov	r1, r7
   1d382:	4b09      	ldr	r3, [pc, #36]	; (1d3a8 <_TCPIPStackModuleRxInsert+0x3c>)
   1d384:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1d388:	f003 ff0a 	bl	211a0 <TCPIP_Helper_SingleListTailAdd>
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1d38c:	4631      	mov	r1, r6
   1d38e:	2000      	movs	r0, #0
   1d390:	f004 f9b3 	bl	216fa <OSAL_CRIT_Leave>
    if(signal)
   1d394:	b905      	cbnz	r5, 1d398 <_TCPIPStackModuleRxInsert+0x2c>
}
   1d396:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    _TCPIPSignalEntrySetNotify(_TCPIPModuleToSignalEntry(modId), signals, 0);
   1d398:	2200      	movs	r2, #0
   1d39a:	2101      	movs	r1, #1
   1d39c:	4803      	ldr	r0, [pc, #12]	; (1d3ac <_TCPIPStackModuleRxInsert+0x40>)
   1d39e:	eb00 1004 	add.w	r0, r0, r4, lsl #4
   1d3a2:	f002 fd27 	bl	1fdf4 <_TCPIPSignalEntrySetNotify>
}
   1d3a6:	e7f6      	b.n	1d396 <_TCPIPStackModuleRxInsert+0x2a>
   1d3a8:	2000de84 	.word	0x2000de84
   1d3ac:	2000d1d4 	.word	0x2000d1d4

Disassembly of section .rodata%600:

0001d3b0 <.rodata%600>:
   1d3b0:	20504455 	.word	0x20504455
   1d3b4:	4c4c554e 	.word	0x4c4c554e
   1d3b8:	6e796420 	.word	0x6e796420
   1d3bc:	63696d61 	.word	0x63696d61
   1d3c0:	6c6c6120 	.word	0x6c6c6120
   1d3c4:	7461636f 	.word	0x7461636f
   1d3c8:	206e6f69 	.word	0x206e6f69
   1d3cc:	646e6168 	.word	0x646e6168
   1d3d0:	0000656c 	.word	0x0000656c
   1d3d4:	20504455 	.word	0x20504455
   1d3d8:	616e7944 	.word	0x616e7944
   1d3dc:	2063696d 	.word	0x2063696d
   1d3e0:	6f6c6c61 	.word	0x6f6c6c61
   1d3e4:	69746163 	.word	0x69746163
   1d3e8:	66206e6f 	.word	0x66206e6f
   1d3ec:	656c6961 	.word	0x656c6961
   1d3f0:	0064      	.short	0x0064
   1d3f2:	bf00      	nop

Disassembly of section .text.SYS_INT_SourceDisable%601:

0001d3f4 <SYS_INT_SourceDisable>:
{
    NVIC_INT_Restore(state);
}

bool SYS_INT_SourceDisable( INT_SOURCE source )
{
   1d3f4:	b538      	push	{r3, r4, r5, lr}
   1d3f6:	4604      	mov	r4, r0
    return NVIC_INT_Disable();
   1d3f8:	f004 fac1 	bl	2197e <NVIC_INT_Disable>
  if ((int32_t)(IRQn) >= 0)
   1d3fc:	2c00      	cmp	r4, #0
   1d3fe:	db16      	blt.n	1d42e <SYS_INT_SourceDisable+0x3a>
    return((uint32_t)(((NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
   1d400:	0963      	lsrs	r3, r4, #5
   1d402:	490c      	ldr	r1, [pc, #48]	; (1d434 <SYS_INT_SourceDisable+0x40>)
   1d404:	f851 5023 	ldr.w	r5, [r1, r3, lsl #2]
   1d408:	f004 041f 	and.w	r4, r4, #31
   1d40c:	40e5      	lsrs	r5, r4
    bool processorStatus;
    bool intSrcStatus;

    processorStatus = SYS_INT_Disable();

    intSrcStatus = NVIC_GetEnableIRQ(source);
   1d40e:	f005 0501 	and.w	r5, r5, #1
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1d412:	2201      	movs	r2, #1
   1d414:	fa02 f404 	lsl.w	r4, r2, r4
   1d418:	3320      	adds	r3, #32
   1d41a:	f841 4023 	str.w	r4, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   1d41e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1d422:	f3bf 8f6f 	isb	sy
    NVIC_INT_Restore(state);
   1d426:	f004 fab3 	bl	21990 <NVIC_INT_Restore>

    SYS_INT_Restore( processorStatus );

    /* return the source status */
    return intSrcStatus;
}
   1d42a:	4628      	mov	r0, r5
   1d42c:	bd38      	pop	{r3, r4, r5, pc}
    intSrcStatus = NVIC_GetEnableIRQ(source);
   1d42e:	2500      	movs	r5, #0
   1d430:	e7f9      	b.n	1d426 <SYS_INT_SourceDisable+0x32>
   1d432:	bf00      	nop
   1d434:	e000e100 	.word	0xe000e100

Disassembly of section .rodata%602:

0001d438 <.rodata%602>:
   1d438:	736c6166 	.word	0x736c6166
   1d43c:	00000065 	.word	0x00000065
   1d440:	732f2e2e 	.word	0x732f2e2e
   1d444:	672f6372 	.word	0x672f6372
   1d448:	6d5f7866 	.word	0x6d5f7866
   1d44c:	2f6f6e6f 	.word	0x2f6f6e6f
   1d450:	5f786667 	.word	0x5f786667
   1d454:	6f6e6f6d 	.word	0x6f6e6f6d
   1d458:	7865745f 	.word	0x7865745f
   1d45c:	00632e74 	.word	0x00632e74
   1d460:	20727473 	.word	0x20727473
   1d464:	4e203d21 	.word	0x4e203d21
   1d468:	004c4c55 	.word	0x004c4c55
   1d46c:	746e6f66 	.word	0x746e6f66
   1d470:	203d2120 	.word	0x203d2120
   1d474:	4c4c554e 	.word	0x4c4c554e
   1d478:	00          	.byte	0x00
   1d479:	00          	.byte	0x00
   1d47a:	bf00      	nop

Disassembly of section .text.gfx_mono_ssd1306_put_page%603:

0001d47c <gfx_mono_ssd1306_put_page>:
        gfx_coord_t column, gfx_coord_t width) {
   1d47c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1d47e:	4604      	mov	r4, r0
   1d480:	460e      	mov	r6, r1
   1d482:	4617      	mov	r7, r2
   1d484:	461d      	mov	r5, r3
    gfx_mono_framebuffer_put_page(data, page, column, width);
   1d486:	f001 fbbb 	bl	1ec00 <gfx_mono_framebuffer_put_page>
        address &= 0x0F;
   1d48a:	f006 000f 	and.w	r0, r6, #15
        ssd1306_write_command(SSD1306_CMD_SET_PAGE_START_ADDRESS(address));
   1d48e:	f040 00b0 	orr.w	r0, r0, #176	; 0xb0
   1d492:	f000 fb3f 	bl	1db14 <ssd1306_write_command>
        ssd1306_write_command(SSD1306_CMD_COL_ADD_SET_MSB(address >> 4));
   1d496:	f3c7 1002 	ubfx	r0, r7, #4, #3
   1d49a:	f040 0010 	orr.w	r0, r0, #16
   1d49e:	f000 fb39 	bl	1db14 <ssd1306_write_command>
        ssd1306_write_command(SSD1306_CMD_COL_ADD_SET_LSB(address & 0x0F));
   1d4a2:	f007 000f 	and.w	r0, r7, #15
   1d4a6:	f000 fb35 	bl	1db14 <ssd1306_write_command>
   1d4aa:	3d01      	subs	r5, #1
   1d4ac:	b2ed      	uxtb	r5, r5
   1d4ae:	3501      	adds	r5, #1
   1d4b0:	4425      	add	r5, r4
        ssd1306_write_data(*data++);
   1d4b2:	f814 0b01 	ldrb.w	r0, [r4], #1
   1d4b6:	f000 fb4d 	bl	1db54 <ssd1306_write_data>
    } while (--width);
   1d4ba:	42ac      	cmp	r4, r5
   1d4bc:	d1f9      	bne.n	1d4b2 <gfx_mono_ssd1306_put_page+0x36>
}
   1d4be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.gfx_mono_ssd1306_put_framebuffer%604:

0001d4c0 <gfx_mono_ssd1306_put_framebuffer>:
void gfx_mono_ssd1306_put_framebuffer(void) {
   1d4c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
   1d4c4:	4d0e      	ldr	r5, [pc, #56]	; (1d500 <gfx_mono_ssd1306_put_framebuffer+0x40>)
void gfx_mono_ssd1306_put_framebuffer(void) {
   1d4c6:	2400      	movs	r4, #0
        ssd1306_write_command(SSD1306_CMD_COL_ADD_SET_MSB(address >> 4));
   1d4c8:	f04f 0910 	mov.w	r9, #16
        ssd1306_write_command(SSD1306_CMD_COL_ADD_SET_LSB(address & 0x0F));
   1d4cc:	4627      	mov	r7, r4
        gfx_mono_ssd1306_put_page(framebuffer
   1d4ce:	f04f 0880 	mov.w	r8, #128	; 0x80
   1d4d2:	b2e6      	uxtb	r6, r4
        ssd1306_write_command(SSD1306_CMD_SET_PAGE_START_ADDRESS(address));
   1d4d4:	f046 00b0 	orr.w	r0, r6, #176	; 0xb0
   1d4d8:	f000 fb1c 	bl	1db14 <ssd1306_write_command>
        ssd1306_write_command(SSD1306_CMD_COL_ADD_SET_MSB(address >> 4));
   1d4dc:	4648      	mov	r0, r9
   1d4de:	f000 fb19 	bl	1db14 <ssd1306_write_command>
        ssd1306_write_command(SSD1306_CMD_COL_ADD_SET_LSB(address & 0x0F));
   1d4e2:	4638      	mov	r0, r7
   1d4e4:	f000 fb16 	bl	1db14 <ssd1306_write_command>
   1d4e8:	4643      	mov	r3, r8
   1d4ea:	463a      	mov	r2, r7
   1d4ec:	4631      	mov	r1, r6
   1d4ee:	4628      	mov	r0, r5
   1d4f0:	f7ff ffc4 	bl	1d47c <gfx_mono_ssd1306_put_page>
   1d4f4:	3401      	adds	r4, #1
   1d4f6:	3580      	adds	r5, #128	; 0x80
    for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
   1d4f8:	2c04      	cmp	r4, #4
   1d4fa:	d1ea      	bne.n	1d4d2 <gfx_mono_ssd1306_put_framebuffer+0x12>
}
   1d4fc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1d500:	2000d444 	.word	0x2000d444

Disassembly of section .text.gfx_mono_ssd1306_put_byte%605:

0001d504 <gfx_mono_ssd1306_put_byte>:
        uint8_t data, bool force) {
   1d504:	b570      	push	{r4, r5, r6, lr}
   1d506:	4604      	mov	r4, r0
   1d508:	460d      	mov	r5, r1
   1d50a:	4616      	mov	r6, r2
    if (!force && data == gfx_mono_framebuffer_get_byte(page, column)) {
   1d50c:	b91b      	cbnz	r3, 1d516 <gfx_mono_ssd1306_put_byte+0x12>
   1d50e:	f004 fb0d 	bl	21b2c <gfx_mono_framebuffer_get_byte>
   1d512:	42b0      	cmp	r0, r6
   1d514:	d017      	beq.n	1d546 <gfx_mono_ssd1306_put_byte+0x42>
    gfx_mono_framebuffer_put_byte(page, column, data);
   1d516:	4632      	mov	r2, r6
   1d518:	4629      	mov	r1, r5
   1d51a:	4620      	mov	r0, r4
   1d51c:	f002 ffee 	bl	204fc <gfx_mono_framebuffer_put_byte>
        address &= 0x0F;
   1d520:	f004 000f 	and.w	r0, r4, #15
        ssd1306_write_command(SSD1306_CMD_SET_PAGE_START_ADDRESS(address));
   1d524:	f040 00b0 	orr.w	r0, r0, #176	; 0xb0
   1d528:	f000 faf4 	bl	1db14 <ssd1306_write_command>
        ssd1306_write_command(SSD1306_CMD_COL_ADD_SET_MSB(address >> 4));
   1d52c:	f3c5 1002 	ubfx	r0, r5, #4, #3
   1d530:	f040 0010 	orr.w	r0, r0, #16
   1d534:	f000 faee 	bl	1db14 <ssd1306_write_command>
        ssd1306_write_command(SSD1306_CMD_COL_ADD_SET_LSB(address & 0x0F));
   1d538:	f005 000f 	and.w	r0, r5, #15
   1d53c:	f000 faea 	bl	1db14 <ssd1306_write_command>
    ssd1306_write_data(data);
   1d540:	4630      	mov	r0, r6
   1d542:	f000 fb07 	bl	1db54 <ssd1306_write_data>
}
   1d546:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.sprintf%606:

0001d548 <siprintf>:
   1d548:	b40e      	push	{r1, r2, r3}
   1d54a:	b510      	push	{r4, lr}
   1d54c:	b09b      	sub	sp, #108	; 0x6c
   1d54e:	ab1d      	add	r3, sp, #116	; 0x74
   1d550:	9001      	str	r0, [sp, #4]
   1d552:	9005      	str	r0, [sp, #20]
   1d554:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   1d558:	480a      	ldr	r0, [pc, #40]	; (1d584 <siprintf+0x3c>)
   1d55a:	9106      	str	r1, [sp, #24]
   1d55c:	9103      	str	r1, [sp, #12]
   1d55e:	490a      	ldr	r1, [pc, #40]	; (1d588 <siprintf+0x40>)
   1d560:	f853 2b04 	ldr.w	r2, [r3], #4
   1d564:	9104      	str	r1, [sp, #16]
   1d566:	2400      	movs	r4, #0
   1d568:	a901      	add	r1, sp, #4
   1d56a:	6800      	ldr	r0, [r0, #0]
   1d56c:	9300      	str	r3, [sp, #0]
   1d56e:	9419      	str	r4, [sp, #100]	; 0x64
   1d570:	f7f2 f864 	bl	f63c <_svfiprintf_r>
   1d574:	9b01      	ldr	r3, [sp, #4]
   1d576:	701c      	strb	r4, [r3, #0]
   1d578:	b01b      	add	sp, #108	; 0x6c
   1d57a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1d57e:	b003      	add	sp, #12
   1d580:	4770      	bx	lr
   1d582:	bf00      	nop
   1d584:	2000e700 	.word	0x2000e700
   1d588:	ffff0208 	.word	0xffff0208

Disassembly of section .text._DRV_GMAC_LinkStateNegComplete%607:

0001d58c <_DRV_GMAC_LinkStateNegComplete>:
{
   1d58c:	b538      	push	{r3, r4, r5, lr}
   1d58e:	4604      	mov	r4, r0
	pPhyBase =  pMACDrv->sGmacData.gmacConfig.pPhyBase;
   1d590:	f8d0 50d8 	ldr.w	r5, [r0, #216]	; 0xd8
	phyStat = pPhyBase->DRV_ETHPHY_ClientStatus( pMACDrv->sGmacData.hPhyClient );
   1d594:	69eb      	ldr	r3, [r5, #28]
   1d596:	6900      	ldr	r0, [r0, #16]
   1d598:	4798      	blx	r3
	if(phyStat == DRV_ETHPHY_CLIENT_STATUS_BUSY)
   1d59a:	2801      	cmp	r0, #1
   1d59c:	d00e      	beq.n	1d5bc <_DRV_GMAC_LinkStateNegComplete+0x30>
	phyRes = pPhyBase->DRV_ETHPHY_ClientOperationResult(pMACDrv->sGmacData.hPhyClient);
   1d59e:	6a2b      	ldr	r3, [r5, #32]
   1d5a0:	6920      	ldr	r0, [r4, #16]
   1d5a2:	4798      	blx	r3
	if(phyRes != DRV_ETHPHY_RES_OK)
   1d5a4:	b958      	cbnz	r0, 1d5be <_DRV_GMAC_LinkStateNegComplete+0x32>
	phyRes = pPhyBase->DRV_ETHPHY_NegotiationResultGet(pMACDrv->sGmacData.hPhyClient, DRV_ETHPHY_INF_IDX_ALL_EXTERNAL, &pMACDrv->sGmacData._negResult);
   1d5a6:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   1d5a8:	f104 0240 	add.w	r2, r4, #64	; 0x40
   1d5ac:	2100      	movs	r1, #0
   1d5ae:	6920      	ldr	r0, [r4, #16]
   1d5b0:	4798      	blx	r3
	if(phyRes < 0)
   1d5b2:	2800      	cmp	r0, #0
   1d5b4:	db07      	blt.n	1d5c6 <_DRV_GMAC_LinkStateNegComplete+0x3a>
		pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_NEG_RESULT;
   1d5b6:	2304      	movs	r3, #4
   1d5b8:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
}
   1d5bc:	bd38      	pop	{r3, r4, r5, pc}
		_DRV_GMAC_LinkStateDown(pMACDrv);
   1d5be:	4620      	mov	r0, r4
   1d5c0:	f003 fb06 	bl	20bd0 <_DRV_GMAC_LinkStateDown>
		return;
   1d5c4:	e7fa      	b.n	1d5bc <_DRV_GMAC_LinkStateNegComplete+0x30>
		_DRV_GMAC_LinkStateDown(pMACDrv);
   1d5c6:	4620      	mov	r0, r4
   1d5c8:	f003 fb02 	bl	20bd0 <_DRV_GMAC_LinkStateDown>
   1d5cc:	e7f6      	b.n	1d5bc <_DRV_GMAC_LinkStateNegComplete+0x30>

Disassembly of section .text._TcpSocketSetSourceInterface%608:

0001d5ce <_TcpSocketSetSourceInterface>:
    if(pSkt->flags.srcSet == 0 || pSkt->pSktNet == 0)
   1d5ce:	f890 306d 	ldrb.w	r3, [r0, #109]	; 0x6d
   1d5d2:	f013 0310 	ands.w	r3, r3, #16
   1d5d6:	d003      	beq.n	1d5e0 <_TcpSocketSetSourceInterface+0x12>
   1d5d8:	6c02      	ldr	r2, [r0, #64]	; 0x40
   1d5da:	b10a      	cbz	r2, 1d5e0 <_TcpSocketSetSourceInterface+0x12>
    return true;
   1d5dc:	2001      	movs	r0, #1
}
   1d5de:	4770      	bx	lr
{
   1d5e0:	b510      	push	{r4, lr}
   1d5e2:	4604      	mov	r4, r0
        pSkt->pSktNet = (TCPIP_NET_IF*)TCPIP_IPV4_SelectSourceInterface(pSkt->pSktNet, &pSkt->destAddress, &pSkt->srcAddress, pSkt->flags.srcSet != 0);
   1d5e4:	3300      	adds	r3, #0
   1d5e6:	bf18      	it	ne
   1d5e8:	2301      	movne	r3, #1
   1d5ea:	f100 023c 	add.w	r2, r0, #60	; 0x3c
   1d5ee:	f100 0138 	add.w	r1, r0, #56	; 0x38
   1d5f2:	6c00      	ldr	r0, [r0, #64]	; 0x40
   1d5f4:	f7ff f974 	bl	1c8e0 <TCPIP_IPV4_SelectSourceInterface>
   1d5f8:	6420      	str	r0, [r4, #64]	; 0x40
        if(pSkt->pSktNet == 0)
   1d5fa:	b138      	cbz	r0, 1d60c <_TcpSocketSetSourceInterface+0x3e>
        pSkt->flags.srcSet = 1;
   1d5fc:	f894 306d 	ldrb.w	r3, [r4, #109]	; 0x6d
   1d600:	f043 0310 	orr.w	r3, r3, #16
   1d604:	f884 306d 	strb.w	r3, [r4, #109]	; 0x6d
    return true;
   1d608:	2001      	movs	r0, #1
}
   1d60a:	bd10      	pop	{r4, pc}
            return false;
   1d60c:	2000      	movs	r0, #0
   1d60e:	e7fc      	b.n	1d60a <_TcpSocketSetSourceInterface+0x3c>

Disassembly of section .text._UDPSetNewRxPacket%609:

0001d610 <_UDPSetNewRxPacket>:
{
   1d610:	b538      	push	{r3, r4, r5, lr}
   1d612:	4604      	mov	r4, r0
   1d614:	460d      	mov	r5, r1
    if(pSkt->pCurrRxPkt != 0)
   1d616:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   1d618:	b118      	cbz	r0, 1d622 <_UDPSetNewRxPacket+0x12>
    TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
   1d61a:	2209      	movs	r2, #9
   1d61c:	2102      	movs	r1, #2
   1d61e:	f000 f9b9 	bl	1d994 <_TCPIP_PKT_PacketAcknowledge>
    if((pSkt->pCurrRxPkt = pRxPkt) != 0)
   1d622:	62e5      	str	r5, [r4, #44]	; 0x2c
   1d624:	b17d      	cbz	r5, 1d646 <_UDPSetNewRxPacket+0x36>
        UDP_HEADER* pUDPHdr = (UDP_HEADER*)pRxPkt->pTransportLayer;
   1d626:	69ea      	ldr	r2, [r5, #28]
        pSkt->pCurrRxSeg = pRxPkt->pDSeg;
   1d628:	692b      	ldr	r3, [r5, #16]
   1d62a:	6323      	str	r3, [r4, #48]	; 0x30
        pSkt->rxSegLen = pRxPkt->pDSeg->segLen - sizeof(UDP_HEADER);
   1d62c:	899b      	ldrh	r3, [r3, #12]
   1d62e:	3b08      	subs	r3, #8
   1d630:	86a3      	strh	r3, [r4, #52]	; 0x34
        pSkt->rxTotLen = pUDPHdr->Length;  
   1d632:	8893      	ldrh	r3, [r2, #4]
   1d634:	86e3      	strh	r3, [r4, #54]	; 0x36
        pSkt->rxCurr = pRxPkt->pTransportLayer + sizeof(UDP_HEADER);
   1d636:	69eb      	ldr	r3, [r5, #28]
   1d638:	3308      	adds	r3, #8
   1d63a:	63a3      	str	r3, [r4, #56]	; 0x38
    _UDPsetPacketInfo(pSkt, pRxPkt);
   1d63c:	4629      	mov	r1, r5
   1d63e:	4620      	mov	r0, r4
   1d640:	f7fb f860 	bl	18704 <_UDPsetPacketInfo>
}
   1d644:	bd38      	pop	{r3, r4, r5, pc}
        pSkt->pCurrRxSeg = 0;
   1d646:	2300      	movs	r3, #0
   1d648:	6323      	str	r3, [r4, #48]	; 0x30
        pSkt->rxSegLen = 0;
   1d64a:	86a3      	strh	r3, [r4, #52]	; 0x34
        pSkt->rxTotLen = 0;
   1d64c:	86e3      	strh	r3, [r4, #54]	; 0x36
        pSkt->rxCurr = 0;
   1d64e:	63a3      	str	r3, [r4, #56]	; 0x38
   1d650:	e7f4      	b.n	1d63c <_UDPSetNewRxPacket+0x2c>

Disassembly of section .text.TCPIP_UDP_SourceIPAddressSet%610:

0001d652 <TCPIP_UDP_SourceIPAddressSet>:
{
   1d652:	b538      	push	{r3, r4, r5, lr}
   1d654:	460c      	mov	r4, r1
   1d656:	4615      	mov	r5, r2
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1d658:	f002 fc44 	bl	1fee4 <_UDPSocketDcpt>
    return pSkt ? _UDPSetSourceAddress(pSkt, addType, localAddress) : false;
   1d65c:	b1c0      	cbz	r0, 1d690 <TCPIP_UDP_SourceIPAddressSet+0x3e>
   1d65e:	4603      	mov	r3, r0
    if(localAddress == 0)
   1d660:	b1a5      	cbz	r5, 1d68c <TCPIP_UDP_SourceIPAddressSet+0x3a>
    while(pSkt->addType == addType)
   1d662:	8f82      	ldrh	r2, [r0, #60]	; 0x3c
   1d664:	42a2      	cmp	r2, r4
   1d666:	d001      	beq.n	1d66c <TCPIP_UDP_SourceIPAddressSet+0x1a>
    return false;
   1d668:	2000      	movs	r0, #0
   1d66a:	e012      	b.n	1d692 <TCPIP_UDP_SourceIPAddressSet+0x40>
        if (addType == IP_ADDRESS_TYPE_IPV4)
   1d66c:	2c01      	cmp	r4, #1
   1d66e:	d001      	beq.n	1d674 <TCPIP_UDP_SourceIPAddressSet+0x22>
    return false;
   1d670:	2000      	movs	r0, #0
   1d672:	e00e      	b.n	1d692 <TCPIP_UDP_SourceIPAddressSet+0x40>
            pSkt->srcAddress.Val = localAddress->v4Add.Val;
   1d674:	682a      	ldr	r2, [r5, #0]
   1d676:	619a      	str	r2, [r3, #24]
            pSkt->flags.srcSet = 1;
   1d678:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
            pSkt->flags.srcSolved = 0;
   1d67c:	f042 0260 	orr.w	r2, r2, #96	; 0x60
   1d680:	f36f 12c7 	bfc	r2, #7, #1
   1d684:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
            return true;
   1d688:	2001      	movs	r0, #1
   1d68a:	e002      	b.n	1d692 <TCPIP_UDP_SourceIPAddressSet+0x40>
        return false;
   1d68c:	2000      	movs	r0, #0
   1d68e:	e000      	b.n	1d692 <TCPIP_UDP_SourceIPAddressSet+0x40>
    return pSkt ? _UDPSetSourceAddress(pSkt, addType, localAddress) : false;
   1d690:	2000      	movs	r0, #0
}
   1d692:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text%611:

0001d694 <__do_global_dtors_aux>:
   1d694:	b510      	push	{r4, lr}
   1d696:	4c05      	ldr	r4, [pc, #20]	; (1d6ac <__do_global_dtors_aux+0x18>)
   1d698:	7823      	ldrb	r3, [r4, #0]
   1d69a:	b933      	cbnz	r3, 1d6aa <__do_global_dtors_aux+0x16>
   1d69c:	4b04      	ldr	r3, [pc, #16]	; (1d6b0 <__do_global_dtors_aux+0x1c>)
   1d69e:	b113      	cbz	r3, 1d6a6 <__do_global_dtors_aux+0x12>
   1d6a0:	4804      	ldr	r0, [pc, #16]	; (1d6b4 <__do_global_dtors_aux+0x20>)
   1d6a2:	f3af 8000 	nop.w
   1d6a6:	2301      	movs	r3, #1
   1d6a8:	7023      	strb	r3, [r4, #0]
   1d6aa:	bd10      	pop	{r4, pc}
   1d6ac:	2000e3b0 	.word	0x2000e3b0
	...

0001d6b8 <frame_dummy>:
   1d6b8:	b508      	push	{r3, lr}
   1d6ba:	4b03      	ldr	r3, [pc, #12]	; (1d6c8 <frame_dummy+0x10>)
   1d6bc:	b11b      	cbz	r3, 1d6c6 <frame_dummy+0xe>
   1d6be:	4903      	ldr	r1, [pc, #12]	; (1d6cc <frame_dummy+0x14>)
   1d6c0:	4803      	ldr	r0, [pc, #12]	; (1d6d0 <frame_dummy+0x18>)
   1d6c2:	f3af 8000 	nop.w
   1d6c6:	bd08      	pop	{r3, pc}
   1d6c8:	00000000 	.word	0x00000000
   1d6cc:	2000e3b4 	.word	0x2000e3b4
   1d6d0:	00000000 	.word	0x00000000

Disassembly of section .text.DRV_ETHPHY_Reset%612:

0001d6d4 <DRV_ETHPHY_Reset>:
    if(hClientObj != 0)
   1d6d4:	4603      	mov	r3, r0
   1d6d6:	b190      	cbz	r0, 1d6fe <DRV_ETHPHY_Reset+0x2a>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1d6d8:	68c0      	ldr	r0, [r0, #12]
   1d6da:	4a0d      	ldr	r2, [pc, #52]	; (1d710 <DRV_ETHPHY_Reset+0x3c>)
   1d6dc:	4290      	cmp	r0, r2
   1d6de:	d111      	bne.n	1d704 <DRV_ETHPHY_Reset+0x30>
            if(hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_READY)
   1d6e0:	f993 2008 	ldrsb.w	r2, [r3, #8]
   1d6e4:	2a02      	cmp	r2, #2
   1d6e6:	d110      	bne.n	1d70a <DRV_ETHPHY_Reset+0x36>
            hClientObj->operParam = waitComplete;
   1d6e8:	6319      	str	r1, [r3, #48]	; 0x30
    hClientObj->operType = opType;
   1d6ea:	2206      	movs	r2, #6
   1d6ec:	839a      	strh	r2, [r3, #28]
    hClientObj->operPhase = hClientObj->operSubPhase = 0; 
   1d6ee:	2200      	movs	r2, #0
   1d6f0:	841a      	strh	r2, [r3, #32]
   1d6f2:	83da      	strh	r2, [r3, #30]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_BUSY; 
   1d6f4:	2001      	movs	r0, #1
   1d6f6:	7218      	strb	r0, [r3, #8]
    hClientObj->operRes = res;
   1d6f8:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c
   1d6fc:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1d6fe:	f06f 000a 	mvn.w	r0, #10
   1d702:	4770      	bx	lr
   1d704:	f06f 000a 	mvn.w	r0, #10
   1d708:	4770      	bx	lr
                return DRV_ETHPHY_RES_NOT_READY_ERR;
   1d70a:	f06f 0009 	mvn.w	r0, #9
}
   1d70e:	4770      	bx	lr
   1d710:	2000e018 	.word	0x2000e018

Disassembly of section .text.DRV_ETHPHY_NegotiationIsComplete%613:

0001d714 <DRV_ETHPHY_NegotiationIsComplete>:
    if(hClientObj != 0)
   1d714:	4603      	mov	r3, r0
   1d716:	b190      	cbz	r0, 1d73e <DRV_ETHPHY_NegotiationIsComplete+0x2a>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1d718:	68c0      	ldr	r0, [r0, #12]
   1d71a:	490d      	ldr	r1, [pc, #52]	; (1d750 <DRV_ETHPHY_NegotiationIsComplete+0x3c>)
   1d71c:	4288      	cmp	r0, r1
   1d71e:	d111      	bne.n	1d744 <DRV_ETHPHY_NegotiationIsComplete+0x30>
            if(hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_READY)
   1d720:	f993 1008 	ldrsb.w	r1, [r3, #8]
   1d724:	2902      	cmp	r1, #2
   1d726:	d110      	bne.n	1d74a <DRV_ETHPHY_NegotiationIsComplete+0x36>
            hClientObj->operParam = waitComplete;
   1d728:	631a      	str	r2, [r3, #48]	; 0x30
    hClientObj->operType = opType;
   1d72a:	2203      	movs	r2, #3
   1d72c:	839a      	strh	r2, [r3, #28]
    hClientObj->operPhase = hClientObj->operSubPhase = 0; 
   1d72e:	2200      	movs	r2, #0
   1d730:	841a      	strh	r2, [r3, #32]
   1d732:	83da      	strh	r2, [r3, #30]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_BUSY; 
   1d734:	2001      	movs	r0, #1
   1d736:	7218      	strb	r0, [r3, #8]
    hClientObj->operRes = res;
   1d738:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c
   1d73c:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1d73e:	f06f 000a 	mvn.w	r0, #10
   1d742:	4770      	bx	lr
   1d744:	f06f 000a 	mvn.w	r0, #10
   1d748:	4770      	bx	lr
                return DRV_ETHPHY_RES_NOT_READY_ERR;
   1d74a:	f06f 0009 	mvn.w	r0, #9
}
   1d74e:	4770      	bx	lr
   1d750:	2000e018 	.word	0x2000e018

Disassembly of section .text.DRV_ETHPHY_RestartNegotiation%614:

0001d754 <DRV_ETHPHY_RestartNegotiation>:
    if(hClientObj != 0)
   1d754:	4603      	mov	r3, r0
   1d756:	b188      	cbz	r0, 1d77c <DRV_ETHPHY_RestartNegotiation+0x28>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1d758:	68c1      	ldr	r1, [r0, #12]
   1d75a:	4a0d      	ldr	r2, [pc, #52]	; (1d790 <DRV_ETHPHY_RestartNegotiation+0x3c>)
   1d75c:	4291      	cmp	r1, r2
   1d75e:	d110      	bne.n	1d782 <DRV_ETHPHY_RestartNegotiation+0x2e>
            if(hClientObj->status != DRV_ETHPHY_CLIENT_STATUS_READY)
   1d760:	f990 2008 	ldrsb.w	r2, [r0, #8]
   1d764:	2a02      	cmp	r2, #2
   1d766:	d10f      	bne.n	1d788 <DRV_ETHPHY_RestartNegotiation+0x34>
    hClientObj->operType = opType;
   1d768:	2205      	movs	r2, #5
   1d76a:	8382      	strh	r2, [r0, #28]
    hClientObj->operPhase = hClientObj->operSubPhase = 0; 
   1d76c:	2200      	movs	r2, #0
   1d76e:	8402      	strh	r2, [r0, #32]
   1d770:	83c2      	strh	r2, [r0, #30]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_BUSY; 
   1d772:	2001      	movs	r0, #1
   1d774:	7218      	strb	r0, [r3, #8]
    hClientObj->operRes = res;
   1d776:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c
   1d77a:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1d77c:	f06f 000a 	mvn.w	r0, #10
   1d780:	4770      	bx	lr
   1d782:	f06f 000a 	mvn.w	r0, #10
   1d786:	4770      	bx	lr
                return DRV_ETHPHY_RES_NOT_READY_ERR;
   1d788:	f06f 0009 	mvn.w	r0, #9
}
   1d78c:	4770      	bx	lr
   1d78e:	bf00      	nop
   1d790:	2000e018 	.word	0x2000e018

Disassembly of section .text._DRV_ETHPHY_ResetPhaseWrite%615:

0001d794 <_DRV_ETHPHY_ResetPhaseWrite>:
{
   1d794:	b538      	push	{r3, r4, r5, lr}
    if( hClientObj->operParam == 0)
   1d796:	6b03      	ldr	r3, [r0, #48]	; 0x30
   1d798:	b91b      	cbnz	r3, 1d7a2 <_DRV_ETHPHY_ResetPhaseWrite+0xe>
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OK);
   1d79a:	2100      	movs	r1, #0
   1d79c:	f002 fa12 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
}
   1d7a0:	bd38      	pop	{r3, r4, r5, pc}
   1d7a2:	4604      	mov	r4, r0
        hClientObj->operTStamp = SYS_TMR_TickCountGet() + ((DRV_ETHPHY_RESET_CLR_TMO * SYS_TMR_TickCounterFrequencyGet()) + 999) / 1000;
   1d7a4:	f002 fc02 	bl	1ffac <SYS_TMR_TickCountGet>
   1d7a8:	4605      	mov	r5, r0
   1d7aa:	f002 fc27 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
   1d7ae:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   1d7b2:	fb03 f000 	mul.w	r0, r3, r0
   1d7b6:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
   1d7ba:	4b05      	ldr	r3, [pc, #20]	; (1d7d0 <_DRV_ETHPHY_ResetPhaseWrite+0x3c>)
   1d7bc:	fba3 3000 	umull	r3, r0, r3, r0
   1d7c0:	eb05 1090 	add.w	r0, r5, r0, lsr #6
   1d7c4:	62a0      	str	r0, [r4, #40]	; 0x28
    hClientObj->operPhase = operPhase;
   1d7c6:	2302      	movs	r3, #2
   1d7c8:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1d7ca:	2300      	movs	r3, #0
   1d7cc:	8423      	strh	r3, [r4, #32]
}
   1d7ce:	e7e7      	b.n	1d7a0 <_DRV_ETHPHY_ResetPhaseWrite+0xc>
   1d7d0:	10624dd3 	.word	0x10624dd3

Disassembly of section .rodata.DRV_MIIM_OBJECT_BASE_Default%616:

0001d7d4 <DRV_MIIM_OBJECT_BASE_Default>:
   1d7d4:	00019931 00011cd3 0001e2eb 0001fc65     1...........e...
   1d7e4:	000117b1 000198b9 0001799d 000213c5     .........y......
   1d7f4:	00021635 0001de03 0001f401 00021105     5...............
   1d804:	0002111f 00021139 0001828d 0001bbf5     ....9...........

Disassembly of section .text._TCP_PortIsAvailable%617:

0001d814 <_TCP_PortIsAvailable>:
{
   1d814:	b410      	push	{r4}
    for(sktIx = 0; sktIx < TcpSockets; sktIx++)
   1d816:	4b0d      	ldr	r3, [pc, #52]	; (1d84c <_TCP_PortIsAvailable+0x38>)
   1d818:	681c      	ldr	r4, [r3, #0]
   1d81a:	b1ac      	cbz	r4, 1d848 <_TCP_PortIsAvailable+0x34>
        pSkt = TCBStubs[sktIx];
   1d81c:	4b0c      	ldr	r3, [pc, #48]	; (1d850 <_TCP_PortIsAvailable+0x3c>)
   1d81e:	6819      	ldr	r1, [r3, #0]
   1d820:	3904      	subs	r1, #4
    for(sktIx = 0; sktIx < TcpSockets; sktIx++)
   1d822:	2300      	movs	r3, #0
   1d824:	e002      	b.n	1d82c <_TCP_PortIsAvailable+0x18>
   1d826:	3301      	adds	r3, #1
   1d828:	42a3      	cmp	r3, r4
   1d82a:	d009      	beq.n	1d840 <_TCP_PortIsAvailable+0x2c>
        pSkt = TCBStubs[sktIx];
   1d82c:	f851 2f04 	ldr.w	r2, [r1, #4]!
        if(pSkt && pSkt->localPort == port)
   1d830:	2a00      	cmp	r2, #0
   1d832:	d0f8      	beq.n	1d826 <_TCP_PortIsAvailable+0x12>
   1d834:	f8b2 205a 	ldrh.w	r2, [r2, #90]	; 0x5a
   1d838:	4282      	cmp	r2, r0
   1d83a:	d1f4      	bne.n	1d826 <_TCP_PortIsAvailable+0x12>
            return false;
   1d83c:	2000      	movs	r0, #0
   1d83e:	e000      	b.n	1d842 <_TCP_PortIsAvailable+0x2e>
    return true;
   1d840:	2001      	movs	r0, #1
}
   1d842:	f85d 4b04 	ldr.w	r4, [sp], #4
   1d846:	4770      	bx	lr
    return true;
   1d848:	2001      	movs	r0, #1
   1d84a:	e7fa      	b.n	1d842 <_TCP_PortIsAvailable+0x2e>
   1d84c:	2000e598 	.word	0x2000e598
   1d850:	2000e594 	.word	0x2000e594

Disassembly of section .text._DHCPSetBoundState%618:

0001d854 <_DHCPSetBoundState>:
{
   1d854:	b510      	push	{r4, lr}
   1d856:	b094      	sub	sp, #80	; 0x50
   1d858:	4604      	mov	r4, r0
    TCPIP_UDP_SocketInfoGet(dhcpClientSocket , &sktInfo);
   1d85a:	4669      	mov	r1, sp
   1d85c:	4b0c      	ldr	r3, [pc, #48]	; (1d890 <_DHCPSetBoundState+0x3c>)
   1d85e:	f9b3 0000 	ldrsh.w	r0, [r3]
   1d862:	f7fd fb5b 	bl	1af1c <TCPIP_UDP_SocketInfoGet>
    pClient->serverAddress.Val = sktInfo.sourceIPaddress.v4Add.Val;
   1d866:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1d868:	62a3      	str	r3, [r4, #40]	; 0x28
    pClient->smState = newState;
   1d86a:	2308      	movs	r3, #8
   1d86c:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    pClient->flags.bIsBound = true;	
   1d870:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
    pClient->flags.bRetry = false; 
   1d874:	f043 0332 	orr.w	r3, r3, #50	; 0x32
   1d878:	f36f 13c7 	bfc	r3, #7, #1
   1d87c:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    if(pClient->dhcpFilterHandle != 0)
   1d880:	6ca0      	ldr	r0, [r4, #72]	; 0x48
   1d882:	b110      	cbz	r0, 1d88a <_DHCPSetBoundState+0x36>
        Ipv4FilterSetActive(pClient->dhcpFilterHandle, active);
   1d884:	2100      	movs	r1, #0
   1d886:	f7fd fcab 	bl	1b1e0 <Ipv4FilterSetActive>
}
   1d88a:	b014      	add	sp, #80	; 0x50
   1d88c:	bd10      	pop	{r4, pc}
   1d88e:	bf00      	nop
   1d890:	2000e720 	.word	0x2000e720

Disassembly of section .text.TCPIP_DHCP_Deinitialize%619:

0001d894 <TCPIP_DHCP_Deinitialize>:
    if(dhcpInitCount > 0)
   1d894:	4b0d      	ldr	r3, [pc, #52]	; (1d8cc <TCPIP_DHCP_Deinitialize+0x38>)
   1d896:	681b      	ldr	r3, [r3, #0]
   1d898:	2b00      	cmp	r3, #0
   1d89a:	dc00      	bgt.n	1d89e <TCPIP_DHCP_Deinitialize+0xa>
   1d89c:	4770      	bx	lr
{
   1d89e:	b510      	push	{r4, lr}
   1d8a0:	4604      	mov	r4, r0
        _DHCPClientClose(stackCtrl->pNetIf, true, true);
   1d8a2:	2201      	movs	r2, #1
   1d8a4:	4611      	mov	r1, r2
   1d8a6:	6940      	ldr	r0, [r0, #20]
   1d8a8:	f7fa fea0 	bl	185ec <_DHCPClientClose>
        if(stackCtrl->stackAction == TCPIP_STACK_ACTION_DEINIT)
   1d8ac:	7f23      	ldrb	r3, [r4, #28]
   1d8ae:	2b02      	cmp	r3, #2
   1d8b0:	d000      	beq.n	1d8b4 <TCPIP_DHCP_Deinitialize+0x20>
}
   1d8b2:	bd10      	pop	{r4, pc}
            if(--dhcpInitCount == 0)
   1d8b4:	4a05      	ldr	r2, [pc, #20]	; (1d8cc <TCPIP_DHCP_Deinitialize+0x38>)
   1d8b6:	6813      	ldr	r3, [r2, #0]
   1d8b8:	3b01      	subs	r3, #1
   1d8ba:	6013      	str	r3, [r2, #0]
   1d8bc:	2b00      	cmp	r3, #0
   1d8be:	d1f8      	bne.n	1d8b2 <TCPIP_DHCP_Deinitialize+0x1e>
                _DHCPCleanup();
   1d8c0:	f7fa fd2c 	bl	1831c <_DHCPCleanup>
                dhcpMemH = 0;
   1d8c4:	4b02      	ldr	r3, [pc, #8]	; (1d8d0 <TCPIP_DHCP_Deinitialize+0x3c>)
   1d8c6:	2200      	movs	r2, #0
   1d8c8:	601a      	str	r2, [r3, #0]
}
   1d8ca:	e7f2      	b.n	1d8b2 <TCPIP_DHCP_Deinitialize+0x1e>
   1d8cc:	2000e614 	.word	0x2000e614
   1d8d0:	2000e61c 	.word	0x2000e61c

Disassembly of section .text.TCPIP_DNS_RemoveEntry%620:

0001d8d4 <TCPIP_DNS_RemoveEntry>:
{
   1d8d4:	b510      	push	{r4, lr}
    pDnsDcpt = pgDnsDcpt;
   1d8d6:	4b0e      	ldr	r3, [pc, #56]	; (1d910 <TCPIP_DNS_RemoveEntry+0x3c>)
   1d8d8:	681c      	ldr	r4, [r3, #0]
    if(pDnsDcpt == 0 || pDnsDcpt->hashDcpt == 0)
   1d8da:	b164      	cbz	r4, 1d8f6 <TCPIP_DNS_RemoveEntry+0x22>
   1d8dc:	4601      	mov	r1, r0
   1d8de:	6820      	ldr	r0, [r4, #0]
   1d8e0:	b160      	cbz	r0, 1d8fc <TCPIP_DNS_RemoveEntry+0x28>
    if(hostName == NULL)
   1d8e2:	b171      	cbz	r1, 1d902 <TCPIP_DNS_RemoveEntry+0x2e>
    pDnsHE = (TCPIP_DNS_HASH_ENTRY*)TCPIP_OAHASH_EntryLookup(pDnsDcpt->hashDcpt, hostName);
   1d8e4:	f7fd f8b6 	bl	1aa54 <TCPIP_OAHASH_EntryLookup>
    if(pDnsHE != 0)
   1d8e8:	4601      	mov	r1, r0
   1d8ea:	b168      	cbz	r0, 1d908 <TCPIP_DNS_RemoveEntry+0x34>
    _DNS_CleanCacheEntry(pDnsDcpt, pDnsHE);
   1d8ec:	4620      	mov	r0, r4
   1d8ee:	f001 fe28 	bl	1f542 <_DNS_CleanCacheEntry>
        return TCPIP_DNS_RES_OK;
   1d8f2:	2000      	movs	r0, #0
}
   1d8f4:	bd10      	pop	{r4, pc}
        return TCPIP_DNS_RES_NO_SERVICE;
   1d8f6:	f06f 0005 	mvn.w	r0, #5
   1d8fa:	e7fb      	b.n	1d8f4 <TCPIP_DNS_RemoveEntry+0x20>
   1d8fc:	f06f 0005 	mvn.w	r0, #5
   1d900:	e7f8      	b.n	1d8f4 <TCPIP_DNS_RemoveEntry+0x20>
        return TCPIP_DNS_RES_INVALID_HOSTNAME;
   1d902:	f06f 0008 	mvn.w	r0, #8
   1d906:	e7f5      	b.n	1d8f4 <TCPIP_DNS_RemoveEntry+0x20>
    return TCPIP_DNS_RES_NO_NAME_ENTRY;
   1d908:	f04f 30ff 	mov.w	r0, #4294967295
   1d90c:	e7f2      	b.n	1d8f4 <TCPIP_DNS_RemoveEntry+0x20>
   1d90e:	bf00      	nop
   1d910:	2000e62c 	.word	0x2000e62c

Disassembly of section .rodata%621:

0001d914 <.rodata%621>:
   1d914:	252e6425 	.word	0x252e6425
   1d918:	64252e64 	.word	0x64252e64
   1d91c:	0064252e 	.word	0x0064252e
   1d920:	78322e25 	.word	0x78322e25
   1d924:	322e253a 	.word	0x322e253a
   1d928:	2e253a78 	.word	0x2e253a78
   1d92c:	253a7832 	.word	0x253a7832
   1d930:	3a78322e 	.word	0x3a78322e
   1d934:	78322e25 	.word	0x78322e25
   1d938:	322e253a 	.word	0x322e253a
   1d93c:	00000078 	.word	0x00000078
   1d940:	6c6c7566 	.word	0x6c6c7566
   1d944:	00000000 	.word	0x00000000
   1d948:	00776f6c 	.word	0x00776f6c
   1d94c:	6e776f64 	.word	0x6e776f64
   1d950:	00          	.byte	0x00
   1d951:	00          	.byte	0x00
   1d952:	bf00      	nop

Disassembly of section .text.TCPIP_STACK_NetHandleGet%622:

0001d954 <TCPIP_STACK_NetHandleGet>:
{
   1d954:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1d956:	4606      	mov	r6, r0
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   1d958:	4b0c      	ldr	r3, [pc, #48]	; (1d98c <TCPIP_STACK_NetHandleGet+0x38>)
   1d95a:	681c      	ldr	r4, [r3, #0]
   1d95c:	4b0c      	ldr	r3, [pc, #48]	; (1d990 <TCPIP_STACK_NetHandleGet+0x3c>)
   1d95e:	681f      	ldr	r7, [r3, #0]
   1d960:	2f00      	cmp	r7, #0
   1d962:	dd0a      	ble.n	1d97a <TCPIP_STACK_NetHandleGet+0x26>
   1d964:	2500      	movs	r5, #0
        if(strcmp(pNetIf->ifName, interface) == 0)
   1d966:	4631      	mov	r1, r6
   1d968:	f104 0062 	add.w	r0, r4, #98	; 0x62
   1d96c:	f003 ffc6 	bl	218fc <strcmp>
   1d970:	b148      	cbz	r0, 1d986 <TCPIP_STACK_NetHandleGet+0x32>
    for(netIx = 0, pNetIf = tcpipNetIf; netIx < tcpip_stack_ctrl_data.nIfs; netIx++, pNetIf++)
   1d972:	3501      	adds	r5, #1
   1d974:	346c      	adds	r4, #108	; 0x6c
   1d976:	42bd      	cmp	r5, r7
   1d978:	d1f5      	bne.n	1d966 <TCPIP_STACK_NetHandleGet+0x12>
    return TCPIP_STACK_MACIdToNet(TCPIP_STACK_StringToMACId(interface));
   1d97a:	4630      	mov	r0, r6
   1d97c:	f7fe fae0 	bl	1bf40 <TCPIP_STACK_StringToMACId>
   1d980:	f7ff f93e 	bl	1cc00 <TCPIP_STACK_MACIdToNet>
   1d984:	4604      	mov	r4, r0
}
   1d986:	4620      	mov	r0, r4
   1d988:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1d98a:	bf00      	nop
   1d98c:	2000e648 	.word	0x2000e648
   1d990:	2000e2f0 	.word	0x2000e2f0

Disassembly of section .text._TCPIP_PKT_PacketAcknowledge%623:

0001d994 <_TCPIP_PKT_PacketAcknowledge>:
{
   1d994:	b510      	push	{r4, lr}
   1d996:	4604      	mov	r4, r0
    if(ackRes != TCPIP_MAC_PKT_ACK_NONE)
   1d998:	b109      	cbz	r1, 1d99e <_TCPIP_PKT_PacketAcknowledge+0xa>
        pPkt->ackRes = ackRes;
   1d99a:	f880 102c 	strb.w	r1, [r0, #44]	; 0x2c
    pPkt->pktPriority = 0; //clear the packet priority to default
   1d99e:	2300      	movs	r3, #0
   1d9a0:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
    if(pPkt->ackFunc)
   1d9a4:	68a3      	ldr	r3, [r4, #8]
   1d9a6:	b143      	cbz	r3, 1d9ba <_TCPIP_PKT_PacketAcknowledge+0x26>
       if((*pPkt->ackFunc)(pPkt, pPkt->ackParam))
   1d9a8:	68e1      	ldr	r1, [r4, #12]
   1d9aa:	4620      	mov	r0, r4
   1d9ac:	4798      	blx	r3
   1d9ae:	b118      	cbz	r0, 1d9b8 <_TCPIP_PKT_PacketAcknowledge+0x24>
           pPkt->pktFlags &= ~TCPIP_MAC_PKT_FLAG_QUEUED;
   1d9b0:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   1d9b2:	f023 0308 	bic.w	r3, r3, #8
   1d9b6:	8463      	strh	r3, [r4, #34]	; 0x22
}
   1d9b8:	bd10      	pop	{r4, pc}
        SYS_ERROR(SYS_ERROR_WARNING, "Packet Ack: orphan packet! \r\n");
   1d9ba:	f004 fac7 	bl	21f4c <SYS_DEBUG_ErrorLevelGet>
   1d9be:	2801      	cmp	r0, #1
   1d9c0:	d9fa      	bls.n	1d9b8 <_TCPIP_PKT_PacketAcknowledge+0x24>
   1d9c2:	f004 fabd 	bl	21f40 <SYS_DEBUG_ConsoleInstanceGet>
   1d9c6:	4902      	ldr	r1, [pc, #8]	; (1d9d0 <_TCPIP_PKT_PacketAcknowledge+0x3c>)
   1d9c8:	f7fc fed0 	bl	1a76c <SYS_CONSOLE_Print>
}
   1d9cc:	e7f4      	b.n	1d9b8 <_TCPIP_PKT_PacketAcknowledge+0x24>
   1d9ce:	bf00      	nop
   1d9d0:	00020a10 	.word	0x00020a10

Disassembly of section .text._UDPIsAvailablePort%624:

0001d9d4 <_UDPIsAvailablePort>:
{
   1d9d4:	b410      	push	{r4}
    for(skt = 0; skt < nUdpSockets; skt++)
   1d9d6:	4b0d      	ldr	r3, [pc, #52]	; (1da0c <_UDPIsAvailablePort+0x38>)
   1d9d8:	681c      	ldr	r4, [r3, #0]
   1d9da:	2c00      	cmp	r4, #0
   1d9dc:	dd14      	ble.n	1da08 <_UDPIsAvailablePort+0x34>
        pSkt = UDPSocketDcpt[skt]; 
   1d9de:	4b0c      	ldr	r3, [pc, #48]	; (1da10 <_UDPIsAvailablePort+0x3c>)
   1d9e0:	6819      	ldr	r1, [r3, #0]
   1d9e2:	3904      	subs	r1, #4
    for(skt = 0; skt < nUdpSockets; skt++)
   1d9e4:	2300      	movs	r3, #0
   1d9e6:	e002      	b.n	1d9ee <_UDPIsAvailablePort+0x1a>
   1d9e8:	3301      	adds	r3, #1
   1d9ea:	42a3      	cmp	r3, r4
   1d9ec:	d008      	beq.n	1da00 <_UDPIsAvailablePort+0x2c>
        pSkt = UDPSocketDcpt[skt]; 
   1d9ee:	f851 2f04 	ldr.w	r2, [r1, #4]!
        if(pSkt && pSkt->localPort == port)
   1d9f2:	2a00      	cmp	r2, #0
   1d9f4:	d0f8      	beq.n	1d9e8 <_UDPIsAvailablePort+0x14>
   1d9f6:	8d52      	ldrh	r2, [r2, #42]	; 0x2a
   1d9f8:	4282      	cmp	r2, r0
   1d9fa:	d1f5      	bne.n	1d9e8 <_UDPIsAvailablePort+0x14>
            return false;
   1d9fc:	2000      	movs	r0, #0
   1d9fe:	e000      	b.n	1da02 <_UDPIsAvailablePort+0x2e>
    return true;
   1da00:	2001      	movs	r0, #1
}
   1da02:	f85d 4b04 	ldr.w	r4, [sp], #4
   1da06:	4770      	bx	lr
    return true;
   1da08:	2001      	movs	r0, #1
   1da0a:	e7fa      	b.n	1da02 <_UDPIsAvailablePort+0x2e>
   1da0c:	2000e660 	.word	0x2000e660
   1da10:	2000e65c 	.word	0x2000e65c

Disassembly of section .text.TCPIP_UDP_SocketNetSet%625:

0001da14 <TCPIP_UDP_SocketNetSet>:
{
   1da14:	b510      	push	{r4, lr}
   1da16:	460c      	mov	r4, r1
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1da18:	f002 fa64 	bl	1fee4 <_UDPSocketDcpt>
    if(pSkt)
   1da1c:	b148      	cbz	r0, 1da32 <TCPIP_UDP_SocketNetSet+0x1e>
   1da1e:	4603      	mov	r3, r0
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   1da20:	b124      	cbz	r4, 1da2c <TCPIP_UDP_SocketNetSet+0x18>
   1da22:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
   1da26:	f012 0f40 	tst.w	r2, #64	; 0x40
   1da2a:	d104      	bne.n	1da36 <TCPIP_UDP_SocketNetSet+0x22>
        if((pSkt->pSktNet = pIf) != 0)
   1da2c:	2200      	movs	r2, #0
   1da2e:	625a      	str	r2, [r3, #36]	; 0x24
   1da30:	e008      	b.n	1da44 <TCPIP_UDP_SocketNetSet+0x30>
    return false;
   1da32:	2000      	movs	r0, #0
   1da34:	e00d      	b.n	1da52 <TCPIP_UDP_SocketNetSet+0x3e>
        if((pSkt->pSktNet = pIf) != 0)
   1da36:	6244      	str	r4, [r0, #36]	; 0x24
            pSkt->flags.looseNetIf = 0;
   1da38:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
   1da3c:	f36f 02c3 	bfc	r2, #3, #1
   1da40:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
    pSkt->extFlags.rxEnable = 1;
   1da44:	f893 2042 	ldrb.w	r2, [r3, #66]	; 0x42
   1da48:	f042 0202 	orr.w	r2, r2, #2
   1da4c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        return true;
   1da50:	2001      	movs	r0, #1
}
   1da52:	bd10      	pop	{r4, pc}

Disassembly of section .text.TC0_TimerInitialize%626:

0001da54 <TC0_TimerInitialize>:
// *****************************************************************************
/* Initialize the TC module in Timer mode */
void TC0_TimerInitialize( void )
{
    /* Reset TC */
    TC0_REGS->COUNT16.TC_CTRLA = TC_CTRLA_SWRST_Msk;
   1da54:	4b0d      	ldr	r3, [pc, #52]	; (1da8c <TC0_TimerInitialize+0x38>)
   1da56:	2201      	movs	r2, #1
   1da58:	601a      	str	r2, [r3, #0]

    while((TC0_REGS->COUNT16.TC_SYNCBUSY & TC_SYNCBUSY_SWRST_Msk) == TC_SYNCBUSY_SWRST_Msk)
   1da5a:	461a      	mov	r2, r3
   1da5c:	6913      	ldr	r3, [r2, #16]
   1da5e:	f013 0f01 	tst.w	r3, #1
   1da62:	d1fb      	bne.n	1da5c <TC0_TimerInitialize+0x8>
    {
        /* Wait for Write Synchronization */
    }

    /* Configure counter mode & prescaler */
    TC0_REGS->COUNT16.TC_CTRLA = TC_CTRLA_MODE_COUNT16 | TC_CTRLA_PRESCALER_DIV1 | TC_CTRLA_PRESCSYNC_PRESC ;
   1da64:	4b09      	ldr	r3, [pc, #36]	; (1da8c <TC0_TimerInitialize+0x38>)
   1da66:	2210      	movs	r2, #16
   1da68:	601a      	str	r2, [r3, #0]

    /* Configure in Match Frequency Mode */
    TC0_REGS->COUNT16.TC_WAVE = (uint8_t)TC_WAVE_WAVEGEN_MPWM;
   1da6a:	2203      	movs	r2, #3
   1da6c:	731a      	strb	r2, [r3, #12]

    /* Configure timer period */
    TC0_REGS->COUNT16.TC_CC[0U] = 60000U;
   1da6e:	f64e 2260 	movw	r2, #60000	; 0xea60
   1da72:	839a      	strh	r2, [r3, #28]

    /* Clear all interrupt flags */
    TC0_REGS->COUNT16.TC_INTFLAG = (uint8_t)TC_INTFLAG_Msk;
   1da74:	2233      	movs	r2, #51	; 0x33
   1da76:	729a      	strb	r2, [r3, #10]

    TC0_CallbackObject.callback = NULL;
   1da78:	4a05      	ldr	r2, [pc, #20]	; (1da90 <TC0_TimerInitialize+0x3c>)
   1da7a:	2100      	movs	r1, #0
   1da7c:	6011      	str	r1, [r2, #0]
    /* Enable interrupt*/
    TC0_REGS->COUNT16.TC_INTENSET = (uint8_t)(TC_INTENSET_MC1_Msk);
   1da7e:	2220      	movs	r2, #32
   1da80:	725a      	strb	r2, [r3, #9]


    while((TC0_REGS->COUNT16.TC_SYNCBUSY) != 0U)
   1da82:	461a      	mov	r2, r3
   1da84:	6913      	ldr	r3, [r2, #16]
   1da86:	2b00      	cmp	r3, #0
   1da88:	d1fc      	bne.n	1da84 <TC0_TimerInitialize+0x30>
    {
        /* Wait for Write Synchronization */
    }
}
   1da8a:	4770      	bx	lr
   1da8c:	40003800 	.word	0x40003800
   1da90:	2000e558 	.word	0x2000e558

Disassembly of section .text.SYS_TIME_TimerAdd%627:

0001da94 <SYS_TIME_TimerAdd>:
{
   1da94:	b538      	push	{r3, r4, r5, lr}
   1da96:	4605      	mov	r5, r0
    counterObj->hwTimerCurrentValue = counterObj->timePlib->timerCounterGet();
   1da98:	4c0d      	ldr	r4, [pc, #52]	; (1dad0 <SYS_TIME_TimerAdd+0x3c>)
   1da9a:	6863      	ldr	r3, [r4, #4]
   1da9c:	699b      	ldr	r3, [r3, #24]
   1da9e:	4798      	blx	r3
   1daa0:	6160      	str	r0, [r4, #20]
    elapsedCount = SYS_TIME_GetElapsedCount(counterObj->hwTimerCurrentValue);
   1daa2:	6960      	ldr	r0, [r4, #20]
   1daa4:	f003 fa7a 	bl	20f9c <SYS_TIME_GetElapsedCount>
   1daa8:	4604      	mov	r4, r0
    SYS_TIME_UpdateTimerList(elapsedCount);
   1daaa:	f001 fbd3 	bl	1f254 <SYS_TIME_UpdateTimerList>
    SYS_TIME_Counter64Update(elapsedCount);
   1daae:	4620      	mov	r0, r4
   1dab0:	f003 fa66 	bl	20f80 <SYS_TIME_Counter64Update>
    isHeadTimerUpdated = SYS_TIME_AddToList(newTimer);
   1dab4:	4628      	mov	r0, r5
   1dab6:	f7fa fd09 	bl	184cc <SYS_TIME_AddToList>
    if (isHeadTimerUpdated == true)
   1daba:	b900      	cbnz	r0, 1dabe <SYS_TIME_TimerAdd+0x2a>
}
   1dabc:	bd38      	pop	{r3, r4, r5, pc}
        interruptState = SYS_INT_Disable();
   1dabe:	f004 faed 	bl	2209c <SYS_INT_Disable>
   1dac2:	4604      	mov	r4, r0
        SYS_TIME_HwTimerCompareUpdate();
   1dac4:	f7f8 fee8 	bl	16898 <SYS_TIME_HwTimerCompareUpdate>
        SYS_INT_Restore(interruptState);
   1dac8:	4620      	mov	r0, r4
   1daca:	f004 faeb 	bl	220a4 <SYS_INT_Restore>
}
   1dace:	e7f5      	b.n	1dabc <SYS_TIME_TimerAdd+0x28>
   1dad0:	2000e230 	.word	0x2000e230

Disassembly of section .rodata%628:

0001dad4 <.rodata%628>:
   1dad4:	5f535953 	.word	0x5f535953
   1dad8:	5f444d43 	.word	0x5f444d43
   1dadc:	4b534154 	.word	0x4b534154
   1dae0:	00000053 	.word	0x00000053
   1dae4:	5f565244 	.word	0x5f565244
   1dae8:	4d49494d 	.word	0x4d49494d
   1daec:	7361545f 	.word	0x7361545f
   1daf0:	0000736b 	.word	0x0000736b
   1daf4:	49504354 	.word	0x49504354
   1daf8:	54535f50 	.word	0x54535f50
   1dafc:	5f4b4341 	.word	0x5f4b4341
   1db00:	6b736154 	.word	0x6b736154
   1db04:	00000073 	.word	0x00000073
   1db08:	5f505041 	.word	0x5f505041
   1db0c:	6b736154 	.word	0x6b736154
   1db10:	0073      	.short	0x0073
   1db12:	bf00      	nop

Disassembly of section .text.ssd1306_write_command%629:

0001db14 <ssd1306_write_command>:
 * This functions pull pin D/C# low before writing to the controller. Different
 * data write function is called based on the selected interface.
 *
 * \param command the command to write
 */
void ssd1306_write_command(uint8_t command) {
   1db14:	b500      	push	{lr}
   1db16:	b083      	sub	sp, #12
   1db18:	f88d 0007 	strb.w	r0, [sp, #7]
    GFX_DISPLAY_SS_N_CLEAR();
   1db1c:	4b0c      	ldr	r3, [pc, #48]	; (1db50 <ssd1306_write_command+0x3c>)
   1db1e:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   1db22:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    GFX_DATA_CMD_SEL_CLEAR();
   1db26:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1db2a:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194
    GFX_SPI_WRITE_FUNCTION(&command, 1);
   1db2e:	2101      	movs	r1, #1
   1db30:	f10d 0007 	add.w	r0, sp, #7
   1db34:	f004 f9f8 	bl	21f28 <SERCOM0_SPI_Write>
    while (GFX_SPI_IS_BUSY());
   1db38:	f001 fe80 	bl	1f83c <SERCOM0_SPI_IsBusy>
   1db3c:	2800      	cmp	r0, #0
   1db3e:	d1fb      	bne.n	1db38 <ssd1306_write_command+0x24>
    GFX_DISPLAY_SS_N_SET();
   1db40:	4b03      	ldr	r3, [pc, #12]	; (1db50 <ssd1306_write_command+0x3c>)
   1db42:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   1db46:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
}
   1db4a:	b003      	add	sp, #12
   1db4c:	f85d fb04 	ldr.w	pc, [sp], #4
   1db50:	41008000 	.word	0x41008000

Disassembly of section .text.ssd1306_write_data%630:

0001db54 <ssd1306_write_data>:
 * This functions sets the pin D/C# before writing to the controller. Different
 * data write function is called based on the selected interface.
 *
 * \param data the data to write
 */
void ssd1306_write_data(uint8_t data) {
   1db54:	b500      	push	{lr}
   1db56:	b083      	sub	sp, #12
   1db58:	f88d 0007 	strb.w	r0, [sp, #7]
    GFX_DISPLAY_SS_N_CLEAR();
   1db5c:	4b0c      	ldr	r3, [pc, #48]	; (1db90 <ssd1306_write_data+0x3c>)
   1db5e:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   1db62:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    GFX_DATA_CMD_SEL_SET();
   1db66:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1db6a:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
    GFX_SPI_WRITE_FUNCTION(&data, 1);
   1db6e:	2101      	movs	r1, #1
   1db70:	f10d 0007 	add.w	r0, sp, #7
   1db74:	f004 f9d8 	bl	21f28 <SERCOM0_SPI_Write>
    while (GFX_SPI_IS_BUSY());
   1db78:	f001 fe60 	bl	1f83c <SERCOM0_SPI_IsBusy>
   1db7c:	2800      	cmp	r0, #0
   1db7e:	d1fb      	bne.n	1db78 <ssd1306_write_data+0x24>
    GFX_DISPLAY_SS_N_SET();
   1db80:	4b03      	ldr	r3, [pc, #12]	; (1db90 <ssd1306_write_data+0x3c>)
   1db82:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   1db86:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
}
   1db8a:	b003      	add	sp, #12
   1db8c:	f85d fb04 	ldr.w	pc, [sp], #4
   1db90:	41008000 	.word	0x41008000

Disassembly of section .text%631:

0001db94 <__aeabi_d2uiz>:
   1db94:	004a      	lsls	r2, r1, #1
   1db96:	d211      	bcs.n	1dbbc <__aeabi_d2uiz+0x28>
   1db98:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   1db9c:	d211      	bcs.n	1dbc2 <__aeabi_d2uiz+0x2e>
   1db9e:	d50d      	bpl.n	1dbbc <__aeabi_d2uiz+0x28>
   1dba0:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   1dba4:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   1dba8:	d40e      	bmi.n	1dbc8 <__aeabi_d2uiz+0x34>
   1dbaa:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   1dbae:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1dbb2:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   1dbb6:	fa23 f002 	lsr.w	r0, r3, r2
   1dbba:	4770      	bx	lr
   1dbbc:	f04f 0000 	mov.w	r0, #0
   1dbc0:	4770      	bx	lr
   1dbc2:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   1dbc6:	d102      	bne.n	1dbce <__aeabi_d2uiz+0x3a>
   1dbc8:	f04f 30ff 	mov.w	r0, #4294967295
   1dbcc:	4770      	bx	lr
   1dbce:	f04f 0000 	mov.w	r0, #0
   1dbd2:	4770      	bx	lr

Disassembly of section .text.__hi0bits%632:

0001dbd4 <__hi0bits>:
   1dbd4:	0c02      	lsrs	r2, r0, #16
   1dbd6:	0412      	lsls	r2, r2, #16
   1dbd8:	4603      	mov	r3, r0
   1dbda:	b9ca      	cbnz	r2, 1dc10 <__hi0bits+0x3c>
   1dbdc:	0403      	lsls	r3, r0, #16
   1dbde:	2010      	movs	r0, #16
   1dbe0:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
   1dbe4:	bf04      	itt	eq
   1dbe6:	021b      	lsleq	r3, r3, #8
   1dbe8:	3008      	addeq	r0, #8
   1dbea:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
   1dbee:	bf04      	itt	eq
   1dbf0:	011b      	lsleq	r3, r3, #4
   1dbf2:	3004      	addeq	r0, #4
   1dbf4:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
   1dbf8:	bf04      	itt	eq
   1dbfa:	009b      	lsleq	r3, r3, #2
   1dbfc:	3002      	addeq	r0, #2
   1dbfe:	2b00      	cmp	r3, #0
   1dc00:	db05      	blt.n	1dc0e <__hi0bits+0x3a>
   1dc02:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
   1dc06:	f100 0001 	add.w	r0, r0, #1
   1dc0a:	bf08      	it	eq
   1dc0c:	2020      	moveq	r0, #32
   1dc0e:	4770      	bx	lr
   1dc10:	2000      	movs	r0, #0
   1dc12:	e7e5      	b.n	1dbe0 <__hi0bits+0xc>

Disassembly of section .text.write%633:

0001dc14 <write>:
   1dc14:	b570      	push	{r4, r5, r6, lr}
   1dc16:	b1b9      	cbz	r1, 1dc48 <write+0x34>
   1dc18:	4615      	mov	r5, r2
   1dc1a:	b10a      	cbz	r2, 1dc20 <write+0xc>
   1dc1c:	2802      	cmp	r0, #2
   1dc1e:	d901      	bls.n	1dc24 <write+0x10>
   1dc20:	4628      	mov	r0, r5
   1dc22:	bd70      	pop	{r4, r5, r6, pc}
   1dc24:	4b0a      	ldr	r3, [pc, #40]	; (1dc50 <write+0x3c>)
   1dc26:	b12b      	cbz	r3, 1dc34 <write+0x20>
   1dc28:	4608      	mov	r0, r1
   1dc2a:	4611      	mov	r1, r2
   1dc2c:	f3af 8000 	nop.w
   1dc30:	4628      	mov	r0, r5
   1dc32:	bd70      	pop	{r4, r5, r6, pc}
   1dc34:	460c      	mov	r4, r1
   1dc36:	188e      	adds	r6, r1, r2
   1dc38:	f814 0b01 	ldrb.w	r0, [r4], #1
   1dc3c:	f7f6 ffb7 	bl	14bae <_mon_putc>
   1dc40:	42b4      	cmp	r4, r6
   1dc42:	d1f9      	bne.n	1dc38 <write+0x24>
   1dc44:	4628      	mov	r0, r5
   1dc46:	bd70      	pop	{r4, r5, r6, pc}
   1dc48:	460d      	mov	r5, r1
   1dc4a:	4628      	mov	r0, r5
   1dc4c:	bd70      	pop	{r4, r5, r6, pc}
   1dc4e:	bf00      	nop
   1dc50:	00000000 	.word	0x00000000

Disassembly of section .text._TCPSetHalfFlushFlag%634:

0001dc54 <_TCPSetHalfFlushFlag>:
    TCP_OPTION_THRES_FLUSH_TYPE flushType = (TCP_OPTION_THRES_FLUSH_TYPE)pSkt->Flags.halfThresType;
   1dc54:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
   1dc58:	f3c3 1301 	ubfx	r3, r3, #4, #2
    switch(flushType)
   1dc5c:	b163      	cbz	r3, 1dc78 <_TCPSetHalfFlushFlag+0x24>
    bool    clrFlushFlag = false;
   1dc5e:	2b01      	cmp	r3, #1
   1dc60:	bf14      	ite	ne
   1dc62:	2300      	movne	r3, #0
   1dc64:	2301      	moveq	r3, #1
    pSkt->flags.halfThresFlush = clrFlushFlag ? 0 : 1;
   1dc66:	f083 0301 	eor.w	r3, r3, #1
   1dc6a:	f890 206d 	ldrb.w	r2, [r0, #109]	; 0x6d
   1dc6e:	f363 12c7 	bfi	r2, r3, #7, #1
   1dc72:	f880 206d 	strb.w	r2, [r0, #109]	; 0x6d
}
   1dc76:	4770      	bx	lr
            if((pSkt->txEnd - pSkt->txStart) >= (pSkt->wRemoteMSS * 3) / 2 )
   1dc78:	6843      	ldr	r3, [r0, #4]
   1dc7a:	6802      	ldr	r2, [r0, #0]
   1dc7c:	1a9a      	subs	r2, r3, r2
   1dc7e:	f8b0 3062 	ldrh.w	r3, [r0, #98]	; 0x62
   1dc82:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1dc86:	ebb2 0f63 	cmp.w	r2, r3, asr #1
   1dc8a:	bfac      	ite	ge
   1dc8c:	2301      	movge	r3, #1
   1dc8e:	2300      	movlt	r3, #0
   1dc90:	e7e9      	b.n	1dc66 <_TCPSetHalfFlushFlag+0x12>

Disassembly of section .text._DHCPOptionProcessSubNet%635:

0001dc92 <_DHCPOptionProcessSubNet>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_SUBNET_MASK))
   1dc92:	684b      	ldr	r3, [r1, #4]
   1dc94:	2b05      	cmp	r3, #5
   1dc96:	d913      	bls.n	1dcc0 <_DHCPOptionProcessSubNet+0x2e>
        TCPIP_DHCP_OPTION_DATA_SUBNET_MASK* pSubMask = (TCPIP_DHCP_OPTION_DATA_SUBNET_MASK*)pOptData->pOpt;
   1dc98:	680b      	ldr	r3, [r1, #0]
        if(pSubMask->len == sizeof(pSubMask->mask))
   1dc9a:	785a      	ldrb	r2, [r3, #1]
   1dc9c:	2a04      	cmp	r2, #4
   1dc9e:	d112      	bne.n	1dcc6 <_DHCPOptionProcessSubNet+0x34>
            if(pClient->flags.bOfferReceived == 0)
   1dca0:	f890 2058 	ldrb.w	r2, [r0, #88]	; 0x58
   1dca4:	f012 0f04 	tst.w	r2, #4
   1dca8:	d110      	bne.n	1dccc <_DHCPOptionProcessSubNet+0x3a>
                memcpy(&pClient->dhcpMask, pSubMask->mask, sizeof(pClient->dhcpMask)); 
   1dcaa:	f8d3 3002 	ldr.w	r3, [r3, #2]
   1dcae:	6343      	str	r3, [r0, #52]	; 0x34
                pClient->validValues.Mask = 1;
   1dcb0:	f890 3059 	ldrb.w	r3, [r0, #89]	; 0x59
   1dcb4:	f043 0304 	orr.w	r3, r3, #4
   1dcb8:	f880 3059 	strb.w	r3, [r0, #89]	; 0x59
            return sizeof(TCPIP_DHCP_OPTION_DATA_SUBNET_MASK);
   1dcbc:	2006      	movs	r0, #6
   1dcbe:	4770      	bx	lr
    return -1;
   1dcc0:	f04f 30ff 	mov.w	r0, #4294967295
   1dcc4:	4770      	bx	lr
   1dcc6:	f04f 30ff 	mov.w	r0, #4294967295
   1dcca:	4770      	bx	lr
            return sizeof(TCPIP_DHCP_OPTION_DATA_SUBNET_MASK);
   1dccc:	2006      	movs	r0, #6
}
   1dcce:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_AddressServiceDefaultSet%636:

0001dcd0 <TCPIP_STACK_AddressServiceDefaultSet>:
{
   1dcd0:	b510      	push	{r4, lr}
   1dcd2:	4604      	mov	r4, r0
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1dcd4:	2000      	movs	r0, #0
   1dcd6:	f003 fbe1 	bl	2149c <OSAL_CRIT_Enter>
   1dcda:	4601      	mov	r1, r0
    _TCPIPStackSetIpAddress(pNetIf, &pNetIf->DefaultIPAddr, &pNetIf->DefaultMask, &pNetIf->DefaultGateway, false);
   1dcdc:	f104 021c 	add.w	r2, r4, #28
   1dce0:	f104 0320 	add.w	r3, r4, #32
    if(ipAddress)
   1dce4:	f114 0f18 	cmn.w	r4, #24
        pNetIf->netIPAddr.Val = ipAddress->Val;
   1dce8:	bf1c      	itt	ne
   1dcea:	69a0      	ldrne	r0, [r4, #24]
   1dcec:	6060      	strne	r0, [r4, #4]
    if(mask)
   1dcee:	b10a      	cbz	r2, 1dcf4 <TCPIP_STACK_AddressServiceDefaultSet+0x24>
        pNetIf->netMask.Val = mask->Val;
   1dcf0:	69e2      	ldr	r2, [r4, #28]
   1dcf2:	60a2      	str	r2, [r4, #8]
    if(gw)
   1dcf4:	b10b      	cbz	r3, 1dcfa <TCPIP_STACK_AddressServiceDefaultSet+0x2a>
        pNetIf->netGateway.Val = gw->Val;
   1dcf6:	6a23      	ldr	r3, [r4, #32]
   1dcf8:	60e3      	str	r3, [r4, #12]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1dcfa:	2000      	movs	r0, #0
   1dcfc:	f003 fcfd 	bl	216fa <OSAL_CRIT_Leave>
    pNetIf->Flags.bInConfig = config;
   1dd00:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   1dd04:	f36f 1304 	bfc	r3, #4, #1
   1dd08:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
}
   1dd0c:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_UDP_TxOffsetSet%637:

0001dd0e <TCPIP_UDP_TxOffsetSet>:
{
   1dd0e:	b570      	push	{r4, r5, r6, lr}
   1dd10:	460d      	mov	r5, r1
   1dd12:	4616      	mov	r6, r2
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1dd14:	f002 f8e6 	bl	1fee4 <_UDPSocketDcpt>
    if(pSkt && _UDPTxPktValid(pSkt))
   1dd18:	b198      	cbz	r0, 1dd42 <TCPIP_UDP_TxOffsetSet+0x34>
   1dd1a:	4604      	mov	r4, r0
   1dd1c:	f003 fa74 	bl	21208 <_UDPTxPktValid>
   1dd20:	4603      	mov	r3, r0
   1dd22:	b178      	cbz	r0, 1dd44 <TCPIP_UDP_TxOffsetSet+0x36>
        uint8_t* pNewWrite = relative ? pSkt->txWrite : pSkt->txStart;
   1dd24:	b14e      	cbz	r6, 1dd3a <TCPIP_UDP_TxOffsetSet+0x2c>
   1dd26:	68a2      	ldr	r2, [r4, #8]
        pNewWrite += wOffset;
   1dd28:	4415      	add	r5, r2
        if(pSkt->txStart <= pNewWrite && pNewWrite <= pSkt->txEnd)
   1dd2a:	6822      	ldr	r2, [r4, #0]
   1dd2c:	42aa      	cmp	r2, r5
   1dd2e:	d80b      	bhi.n	1dd48 <TCPIP_UDP_TxOffsetSet+0x3a>
   1dd30:	6862      	ldr	r2, [r4, #4]
   1dd32:	42aa      	cmp	r2, r5
   1dd34:	d203      	bcs.n	1dd3e <TCPIP_UDP_TxOffsetSet+0x30>
    return false;
   1dd36:	2300      	movs	r3, #0
   1dd38:	e004      	b.n	1dd44 <TCPIP_UDP_TxOffsetSet+0x36>
        uint8_t* pNewWrite = relative ? pSkt->txWrite : pSkt->txStart;
   1dd3a:	6822      	ldr	r2, [r4, #0]
   1dd3c:	e7f4      	b.n	1dd28 <TCPIP_UDP_TxOffsetSet+0x1a>
            pSkt->txWrite = pNewWrite;
   1dd3e:	60a5      	str	r5, [r4, #8]
            return true;
   1dd40:	e000      	b.n	1dd44 <TCPIP_UDP_TxOffsetSet+0x36>
    return false;
   1dd42:	2300      	movs	r3, #0
}
   1dd44:	4618      	mov	r0, r3
   1dd46:	bd70      	pop	{r4, r5, r6, pc}
    return false;
   1dd48:	2300      	movs	r3, #0
   1dd4a:	e7fb      	b.n	1dd44 <TCPIP_UDP_TxOffsetSet+0x36>

Disassembly of section .rodata%638:

0001dd4c <.rodata%638>:
   1dd4c:	66202c00 	.word	0x66202c00
   1dd50:	74636e75 	.word	0x74636e75
   1dd54:	3a6e6f69 	.word	0x3a6e6f69
   1dd58:	73610020 	.word	0x73610020
   1dd5c:	74726573 	.word	0x74726573
   1dd60:	206e6f69 	.word	0x206e6f69
   1dd64:	22732522 	.word	0x22732522
   1dd68:	69616620 	.word	0x69616620
   1dd6c:	3a64656c 	.word	0x3a64656c
   1dd70:	6c696620 	.word	0x6c696620
   1dd74:	25222065 	.word	0x25222065
   1dd78:	202c2273 	.word	0x202c2273
   1dd7c:	656e696c 	.word	0x656e696c
   1dd80:	25642520 	.word	0x25642520
   1dd84:	0a732573 	.word	0x0a732573
	...

Disassembly of section .text._DRV_ETHPHY_NegCompletePhaseAN_Complete%639:

0001dd8a <_DRV_ETHPHY_NegCompletePhaseAN_Complete>:
{
   1dd8a:	b510      	push	{r4, lr}
   1dd8c:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1dd8e:	f002 fc69 	bl	20664 <_DRV_PHY_SMITransfer_Wait>
   1dd92:	b1b8      	cbz	r0, 1ddc4 <_DRV_ETHPHY_NegCompletePhaseAN_Complete+0x3a>
    phyStat.w = hClientObj->smiData;
   1dd94:	8f62      	ldrh	r2, [r4, #58]	; 0x3a
    if(phyStat.AN_COMPLETE == 0)
   1dd96:	f012 0f20 	tst.w	r2, #32
   1dd9a:	d10f      	bne.n	1ddbc <_DRV_ETHPHY_NegCompletePhaseAN_Complete+0x32>
        if(SYS_TMR_TickCountGet() < hClientObj->operTStamp)
   1dd9c:	f002 f906 	bl	1ffac <SYS_TMR_TickCountGet>
   1dda0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1dda2:	4298      	cmp	r0, r3
   1dda4:	d204      	bcs.n	1ddb0 <_DRV_ETHPHY_NegCompletePhaseAN_Complete+0x26>
            _DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT);
   1dda6:	2101      	movs	r1, #1
   1dda8:	4620      	mov	r0, r4
   1ddaa:	f000 ffc5 	bl	1ed38 <_DRV_PHY_SMIReadStart>
   1ddae:	e009      	b.n	1ddc4 <_DRV_ETHPHY_NegCompletePhaseAN_Complete+0x3a>
            _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_NEGOTIATION_ACTIVE);
   1ddb0:	f06f 0107 	mvn.w	r1, #7
   1ddb4:	4620      	mov	r0, r4
   1ddb6:	f001 ff05 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
   1ddba:	e003      	b.n	1ddc4 <_DRV_ETHPHY_NegCompletePhaseAN_Complete+0x3a>
        _DRV_PHY_NegCompleteSetOperResult(hClientObj, phyBMCon.w, phyStat.w);
   1ddbc:	8ca1      	ldrh	r1, [r4, #36]	; 0x24
   1ddbe:	4620      	mov	r0, r4
   1ddc0:	f001 f837 	bl	1ee32 <_DRV_PHY_NegCompleteSetOperResult>
}
   1ddc4:	bd10      	pop	{r4, pc}

Disassembly of section .text.Lan867x_Read_Register%640:

0001ddc6 <Lan867x_Read_Register>:
{
   1ddc6:	b510      	push	{r4, lr}
   1ddc8:	4604      	mov	r4, r0
   1ddca:	4613      	mov	r3, r2
    if (R2F(clientObj->vendorData, VENDOR_INTERNAL_STATE) == IDLE_PHASE) {
   1ddcc:	6840      	ldr	r0, [r0, #4]
   1ddce:	0e42      	lsrs	r2, r0, #25
   1ddd0:	d00c      	beq.n	1ddec <Lan867x_Read_Register+0x26>
    res = Lan867x_Miim_Task(clientObj, DRV_MIIM_OP_READ, regAddr, rData);
   1ddd2:	460a      	mov	r2, r1
   1ddd4:	2101      	movs	r1, #1
   1ddd6:	4620      	mov	r0, r4
   1ddd8:	f7f0 fe92 	bl	eb00 <Lan867x_Miim_Task>
    if (res == DRV_MIIM_RES_OK) {
   1dddc:	4603      	mov	r3, r0
   1ddde:	b918      	cbnz	r0, 1dde8 <Lan867x_Read_Register+0x22>
        clientObj->vendorData = F2R(IDLE_PHASE, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   1dde0:	6862      	ldr	r2, [r4, #4]
   1dde2:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   1dde6:	6062      	str	r2, [r4, #4]
}
   1dde8:	4618      	mov	r0, r3
   1ddea:	bd10      	pop	{r4, pc}
            F2R(initialState, VENDOR_INTERNAL_STATE, clientObj->vendorData);
   1ddec:	291f      	cmp	r1, #31
   1ddee:	bf94      	ite	ls
   1ddf0:	f04f 7200 	movls.w	r2, #33554432	; 0x2000000
   1ddf4:	f04f 6200 	movhi.w	r2, #134217728	; 0x8000000
   1ddf8:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
        clientObj->vendorData = F2R(false, VENDOR_IS_BIT_OP, clientObj->vendorData);
   1ddfc:	4310      	orrs	r0, r2
   1ddfe:	6060      	str	r0, [r4, #4]
   1de00:	e7e7      	b.n	1ddd2 <Lan867x_Read_Register+0xc>

Disassembly of section .text.DRV_MIIM_RegisterCallback%641:

0001de02 <DRV_MIIM_RegisterCallback>:
{
   1de02:	b538      	push	{r3, r4, r5, lr}
   1de04:	4615      	mov	r5, r2
        if(cbFunction == 0)
   1de06:	b181      	cbz	r1, 1de2a <DRV_MIIM_RegisterCallback+0x28>
   1de08:	460c      	mov	r4, r1
        if((pClient = _DRV_MIIM_GetClientAndLock(handle, true)) == 0)
   1de0a:	2101      	movs	r1, #1
   1de0c:	f7fe fb9d 	bl	1c54a <_DRV_MIIM_GetClientAndLock>
   1de10:	4603      	mov	r3, r0
   1de12:	b188      	cbz	r0, 1de38 <DRV_MIIM_RegisterCallback+0x36>
        pClient->cbackHandler = cbFunction;
   1de14:	6084      	str	r4, [r0, #8]
    if(pRegResult)
   1de16:	b10d      	cbz	r5, 1de1c <DRV_MIIM_RegisterCallback+0x1a>
        *pRegResult = miimRes;
   1de18:	2200      	movs	r2, #0
   1de1a:	702a      	strb	r2, [r5, #0]
    OSAL_SEM_Post(&pMiimObj->objSem);
   1de1c:	6858      	ldr	r0, [r3, #4]
   1de1e:	f003 fb49 	bl	214b4 <OSAL_SEM_Post>
   1de22:	4620      	mov	r0, r4
}
   1de24:	bd38      	pop	{r3, r4, r5, pc}
    if(pRegResult)
   1de26:	4628      	mov	r0, r5
    return cbHandle;
   1de28:	e7fc      	b.n	1de24 <DRV_MIIM_RegisterCallback+0x22>
            miimRes = DRV_MIIM_RES_CALLBACK_HANDLE_ERR; 
   1de2a:	f06f 0302 	mvn.w	r3, #2
    if(pRegResult)
   1de2e:	2d00      	cmp	r5, #0
   1de30:	d0f9      	beq.n	1de26 <DRV_MIIM_RegisterCallback+0x24>
        *pRegResult = miimRes;
   1de32:	702b      	strb	r3, [r5, #0]
   1de34:	2000      	movs	r0, #0
   1de36:	e7f5      	b.n	1de24 <DRV_MIIM_RegisterCallback+0x22>
            miimRes = DRV_MIIM_RES_HANDLE_ERR;
   1de38:	f04f 33ff 	mov.w	r3, #4294967295
   1de3c:	e7f7      	b.n	1de2e <DRV_MIIM_RegisterCallback+0x2c>

Disassembly of section .text.hexatob%642:

0001de3e <hexatob>:
  	Resulting packed byte 0x00 - 0xFF.
  ***************************************************************************/
uint8_t hexatob(uint16_t AsciiVal)
{
    MCHP_UINT16_VAL AsciiChars;
    AsciiChars.Val = AsciiVal;
   1de3e:	4603      	mov	r3, r0

	// Convert lowercase to uppercase
	if(AsciiChars.v[1] > 'F')
   1de40:	0a02      	lsrs	r2, r0, #8
   1de42:	2a46      	cmp	r2, #70	; 0x46
		AsciiChars.v[1] -= 'a'-'A';
   1de44:	bf84      	itt	hi
   1de46:	3a20      	subhi	r2, #32
   1de48:	f362 230f 	bfihi	r3, r2, #8, #8
	if(AsciiChars.v[0] > 'F')
   1de4c:	b2c0      	uxtb	r0, r0
   1de4e:	2846      	cmp	r0, #70	; 0x46
		AsciiChars.v[0] -= 'a'-'A';
   1de50:	bf84      	itt	hi
   1de52:	3820      	subhi	r0, #32
   1de54:	f360 0307 	bfihi	r3, r0, #0, #8

	// Convert 0-9, A-F to 0x0-0xF
	if(AsciiChars.v[1] > '9')
   1de58:	f3c3 2007 	ubfx	r0, r3, #8, #8
   1de5c:	2839      	cmp	r0, #57	; 0x39
		AsciiChars.v[1] -= 'A' - 10;
   1de5e:	bf8c      	ite	hi
   1de60:	3837      	subhi	r0, #55	; 0x37
	else
		AsciiChars.v[1] -= '0';
   1de62:	3830      	subls	r0, #48	; 0x30
   1de64:	b2c2      	uxtb	r2, r0

	if(AsciiChars.v[0] > '9')
   1de66:	b2db      	uxtb	r3, r3
   1de68:	2b39      	cmp	r3, #57	; 0x39
		AsciiChars.v[0] -= 'A' - 10;
   1de6a:	bf8c      	ite	hi
   1de6c:	3b37      	subhi	r3, #55	; 0x37
	else
		AsciiChars.v[0] -= '0';
   1de6e:	3b30      	subls	r3, #48	; 0x30
   1de70:	b2d8      	uxtb	r0, r3

	// Concatenate
	return (AsciiChars.v[1]<<4) |  AsciiChars.v[0];
   1de72:	ea40 1002 	orr.w	r0, r0, r2, lsl #4
}
   1de76:	b2c0      	uxtb	r0, r0
   1de78:	4770      	bx	lr

Disassembly of section .text.TCPIP_TCP_Close%643:

0001de7a <TCPIP_TCP_Close>:
{
   1de7a:	b510      	push	{r4, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   1de7c:	f001 ff1a 	bl	1fcb4 <_TcpSocketChk>
    if(pSkt)
   1de80:	b1a8      	cbz	r0, 1deae <TCPIP_TCP_Close+0x34>
   1de82:	4604      	mov	r4, r0
        if(pSkt->flags.nonGraceful == 0)
   1de84:	f990 306c 	ldrsb.w	r3, [r0, #108]	; 0x6c
   1de88:	2b00      	cmp	r3, #0
   1de8a:	db09      	blt.n	1dea0 <TCPIP_TCP_Close+0x26>
            pSkt->flags.forceKill = 1;
   1de8c:	f890 306d 	ldrb.w	r3, [r0, #109]	; 0x6d
   1de90:	f043 0304 	orr.w	r3, r3, #4
   1de94:	f880 306d 	strb.w	r3, [r0, #109]	; 0x6d
            _TCP_SEND_RES sRes = _TcpDisconnect(pSkt, true);
   1de98:	2101      	movs	r1, #1
   1de9a:	f7f8 ff0f 	bl	16cbc <_TcpDisconnect>
            if(sRes != _TCP_SEND_OK)
   1de9e:	b140      	cbz	r0, 1deb2 <TCPIP_TCP_Close+0x38>
            _TcpAbort(pSkt, _TCP_ABORT_FLAG_FORCE_CLOSE, 0);
   1dea0:	2200      	movs	r2, #0
   1dea2:	2101      	movs	r1, #1
   1dea4:	4620      	mov	r0, r4
   1dea6:	f7fe f91d 	bl	1c0e4 <_TcpAbort>
        return true;
   1deaa:	2001      	movs	r0, #1
   1deac:	e000      	b.n	1deb0 <TCPIP_TCP_Close+0x36>
    return false;
   1deae:	2000      	movs	r0, #0
}
   1deb0:	bd10      	pop	{r4, pc}
        return true;
   1deb2:	2001      	movs	r0, #1
   1deb4:	e7fc      	b.n	1deb0 <TCPIP_TCP_Close+0x36>

Disassembly of section .text._DHCPOptionProcessRouter%644:

0001deb6 <_DHCPOptionProcessRouter>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_ROUTER))
   1deb6:	684b      	ldr	r3, [r1, #4]
   1deb8:	2b05      	cmp	r3, #5
   1deba:	d914      	bls.n	1dee6 <_DHCPOptionProcessRouter+0x30>
        TCPIP_DHCP_OPTION_DATA_ROUTER* pRouter = (TCPIP_DHCP_OPTION_DATA_ROUTER*)pOptData->pOpt;
   1debc:	680b      	ldr	r3, [r1, #0]
        if(pRouter->len >= sizeof(pRouter->gateway))
   1debe:	785a      	ldrb	r2, [r3, #1]
   1dec0:	2a03      	cmp	r2, #3
   1dec2:	d913      	bls.n	1deec <_DHCPOptionProcessRouter+0x36>
            if(pClient->flags.bOfferReceived == 0)
   1dec4:	f890 2058 	ldrb.w	r2, [r0, #88]	; 0x58
   1dec8:	f012 0f04 	tst.w	r2, #4
   1decc:	d108      	bne.n	1dee0 <_DHCPOptionProcessRouter+0x2a>
                memcpy(&pClient->dhcpGateway, pRouter->gateway, sizeof(pClient->dhcpGateway)); 
   1dece:	f8d3 2002 	ldr.w	r2, [r3, #2]
   1ded2:	6302      	str	r2, [r0, #48]	; 0x30
                pClient->validValues.Gateway = 1;
   1ded4:	f890 2059 	ldrb.w	r2, [r0, #89]	; 0x59
   1ded8:	f042 0202 	orr.w	r2, r2, #2
   1dedc:	f880 2059 	strb.w	r2, [r0, #89]	; 0x59
            return 2 + pRouter->len;
   1dee0:	7858      	ldrb	r0, [r3, #1]
   1dee2:	3002      	adds	r0, #2
   1dee4:	4770      	bx	lr
    return -1;
   1dee6:	f04f 30ff 	mov.w	r0, #4294967295
   1deea:	4770      	bx	lr
   1deec:	f04f 30ff 	mov.w	r0, #4294967295
}
   1def0:	4770      	bx	lr

Disassembly of section .text._DHCPNotifyClients%645:

0001def4 <_DHCPNotifyClients>:
{
   1def4:	b570      	push	{r4, r5, r6, lr}
   1def6:	4605      	mov	r5, r0
   1def8:	460e      	mov	r6, r1
    TCPIP_Helper_ProtectedSingleListLock(notifyList);
   1defa:	4c0c      	ldr	r4, [pc, #48]	; (1df2c <_DHCPNotifyClients+0x38>)
   1defc:	4620      	mov	r0, r4
   1defe:	f002 fd37 	bl	20970 <TCPIP_Helper_ProtectedSingleListLock>
    for(dNode = (TCPIP_DHCP_LIST_NODE*)dhcpRegisteredUsers.list.head; dNode != 0; dNode = dNode->next)
   1df02:	6824      	ldr	r4, [r4, #0]
   1df04:	b95c      	cbnz	r4, 1df1e <_DHCPNotifyClients+0x2a>
    TCPIP_Helper_ProtectedSingleListUnlock(notifyList);
   1df06:	4809      	ldr	r0, [pc, #36]	; (1df2c <_DHCPNotifyClients+0x38>)
   1df08:	f002 ff84 	bl	20e14 <TCPIP_Helper_ProtectedSingleListUnlock>
}
   1df0c:	bd70      	pop	{r4, r5, r6, pc}
            (*dNode->handler)(pNetIf, evType, dNode->hParam);
   1df0e:	6863      	ldr	r3, [r4, #4]
   1df10:	68a2      	ldr	r2, [r4, #8]
   1df12:	4631      	mov	r1, r6
   1df14:	4628      	mov	r0, r5
   1df16:	4798      	blx	r3
    for(dNode = (TCPIP_DHCP_LIST_NODE*)dhcpRegisteredUsers.list.head; dNode != 0; dNode = dNode->next)
   1df18:	6824      	ldr	r4, [r4, #0]
   1df1a:	2c00      	cmp	r4, #0
   1df1c:	d0f3      	beq.n	1df06 <_DHCPNotifyClients+0x12>
        if(dNode->hNet == 0 || dNode->hNet == pNetIf)
   1df1e:	68e3      	ldr	r3, [r4, #12]
   1df20:	2b00      	cmp	r3, #0
   1df22:	d0f4      	beq.n	1df0e <_DHCPNotifyClients+0x1a>
   1df24:	42ab      	cmp	r3, r5
   1df26:	d1f7      	bne.n	1df18 <_DHCPNotifyClients+0x24>
   1df28:	e7f1      	b.n	1df0e <_DHCPNotifyClients+0x1a>
   1df2a:	bf00      	nop
   1df2c:	2000e450 	.word	0x2000e450

Disassembly of section .text.TCPIP_DHCP_IsEnabled%646:

0001df30 <TCPIP_DHCP_IsEnabled>:
   1df30:	b138      	cbz	r0, 1df42 <TCPIP_DHCP_IsEnabled+0x12>
   1df32:	4603      	mov	r3, r0
   1df34:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1df38:	f012 0f40 	tst.w	r2, #64	; 0x40
   1df3c:	d103      	bne.n	1df46 <TCPIP_DHCP_IsEnabled+0x16>
    return false;
   1df3e:	2000      	movs	r0, #0
   1df40:	4770      	bx	lr
   1df42:	2000      	movs	r0, #0
}
   1df44:	4770      	bx	lr
{
   1df46:	b510      	push	{r4, lr}
    if(DHCPClients && pNetIf)
   1df48:	4a07      	ldr	r2, [pc, #28]	; (1df68 <TCPIP_DHCP_IsEnabled+0x38>)
   1df4a:	6814      	ldr	r4, [r2, #0]
   1df4c:	b154      	cbz	r4, 1df64 <TCPIP_DHCP_IsEnabled+0x34>
   1df4e:	4618      	mov	r0, r3
        DHCP_CLIENT_VARS* pClient = DHCPClients + TCPIP_STACK_NetIxGet(pNetIf);
   1df50:	f003 fe60 	bl	21c14 <TCPIP_STACK_NetIxGet>
        return pClient->flags.bDHCPEnabled != 0;
   1df54:	235c      	movs	r3, #92	; 0x5c
   1df56:	fb03 4000 	mla	r0, r3, r0, r4
   1df5a:	f890 0058 	ldrb.w	r0, [r0, #88]	; 0x58
   1df5e:	f000 0001 	and.w	r0, r0, #1
}
   1df62:	bd10      	pop	{r4, pc}
    return false;
   1df64:	2000      	movs	r0, #0
   1df66:	e7fc      	b.n	1df62 <TCPIP_DHCP_IsEnabled+0x32>
   1df68:	2000e610 	.word	0x2000e610

Disassembly of section .text._TCPIPStackModuleSignalGet%647:

0001df6c <_TCPIPStackModuleSignalGet>:
{
   1df6c:	b570      	push	{r4, r5, r6, lr}
   1df6e:	460e      	mov	r6, r1
    TCPIP_MODULE_SIGNAL_ENTRY* pSignalEntry = TCPIP_STACK_MODULE_SIGNAL_TBL + modId;
   1df70:	4c0b      	ldr	r4, [pc, #44]	; (1dfa0 <_TCPIPStackModuleSignalGet+0x34>)
   1df72:	eb04 1400 	add.w	r4, r4, r0, lsl #4
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1df76:	2000      	movs	r0, #0
   1df78:	f003 fa90 	bl	2149c <OSAL_CRIT_Enter>
   1df7c:	4601      	mov	r1, r0
    TCPIP_MODULE_SIGNAL modSignal = pSignalEntry->signalVal;
   1df7e:	8925      	ldrh	r5, [r4, #8]
    pSignalEntry->signalVal &= (uint16_t)(~clrMask);
   1df80:	ea25 0306 	bic.w	r3, r5, r6
   1df84:	8123      	strh	r3, [r4, #8]
    if((clrMask & TCPIP_MODULE_SIGNAL_ASYNC) != 0)
   1df86:	f416 7f80 	tst.w	r6, #256	; 0x100
   1df8a:	d003      	beq.n	1df94 <_TCPIPStackModuleSignalGet+0x28>
        stackAsyncSignalCount -= 1; 
   1df8c:	4a05      	ldr	r2, [pc, #20]	; (1dfa4 <_TCPIPStackModuleSignalGet+0x38>)
   1df8e:	6813      	ldr	r3, [r2, #0]
   1df90:	3b01      	subs	r3, #1
   1df92:	6013      	str	r3, [r2, #0]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1df94:	2000      	movs	r0, #0
   1df96:	f003 fbb0 	bl	216fa <OSAL_CRIT_Leave>
}
   1df9a:	4628      	mov	r0, r5
   1df9c:	bd70      	pop	{r4, r5, r6, pc}
   1df9e:	bf00      	nop
   1dfa0:	2000d1d4 	.word	0x2000d1d4
   1dfa4:	2000e63c 	.word	0x2000e63c

Disassembly of section .text._TCPIP_PKT_PacketFree%648:

0001dfa8 <_TCPIP_PKT_PacketFree>:
}

// frees a previously allocated packet
void _TCPIP_PKT_PacketFree(TCPIP_MAC_PACKET* pPkt)
{
    if((pPkt->pktFlags & TCPIP_MAC_PKT_FLAG_STATIC) == 0)
   1dfa8:	8c43      	ldrh	r3, [r0, #34]	; 0x22
   1dfaa:	f013 0f01 	tst.w	r3, #1
   1dfae:	d116      	bne.n	1dfde <_TCPIP_PKT_PacketFree+0x36>
{
   1dfb0:	b570      	push	{r4, r5, r6, lr}
   1dfb2:	4605      	mov	r5, r0
    {   // we don't deallocate static packets
        TCPIP_MAC_DATA_SEGMENT  *pSeg, *pNSeg;

        for( pSeg = pPkt->pDSeg; pSeg != 0; pSeg = pNSeg )
   1dfb4:	6901      	ldr	r1, [r0, #16]
   1dfb6:	b161      	cbz	r1, 1dfd2 <_TCPIP_PKT_PacketFree+0x2a>
        {
            pNSeg = pSeg->next;
            if((pSeg->segFlags & TCPIP_MAC_SEG_FLAG_STATIC) == 0)
            {
                TCPIP_HEAP_Free(pktMemH, pSeg);
   1dfb8:	4e09      	ldr	r6, [pc, #36]	; (1dfe0 <_TCPIP_PKT_PacketFree+0x38>)
   1dfba:	e001      	b.n	1dfc0 <_TCPIP_PKT_PacketFree+0x18>
   1dfbc:	4621      	mov	r1, r4
        for( pSeg = pPkt->pDSeg; pSeg != 0; pSeg = pNSeg )
   1dfbe:	b144      	cbz	r4, 1dfd2 <_TCPIP_PKT_PacketFree+0x2a>
            pNSeg = pSeg->next;
   1dfc0:	680c      	ldr	r4, [r1, #0]
            if((pSeg->segFlags & TCPIP_MAC_SEG_FLAG_STATIC) == 0)
   1dfc2:	8a0b      	ldrh	r3, [r1, #16]
   1dfc4:	f013 0f01 	tst.w	r3, #1
   1dfc8:	d1f8      	bne.n	1dfbc <_TCPIP_PKT_PacketFree+0x14>
                TCPIP_HEAP_Free(pktMemH, pSeg);
   1dfca:	6830      	ldr	r0, [r6, #0]
   1dfcc:	68c3      	ldr	r3, [r0, #12]
   1dfce:	4798      	blx	r3
   1dfd0:	e7f4      	b.n	1dfbc <_TCPIP_PKT_PacketFree+0x14>
            }
        }

        TCPIP_HEAP_Free(pktMemH, pPkt);
   1dfd2:	4b03      	ldr	r3, [pc, #12]	; (1dfe0 <_TCPIP_PKT_PacketFree+0x38>)
   1dfd4:	6818      	ldr	r0, [r3, #0]
   1dfd6:	68c3      	ldr	r3, [r0, #12]
   1dfd8:	4629      	mov	r1, r5
   1dfda:	4798      	blx	r3
    }
}
   1dfdc:	bd70      	pop	{r4, r5, r6, pc}
   1dfde:	4770      	bx	lr
   1dfe0:	2000e658 	.word	0x2000e658

Disassembly of section .text.TCPIP_UDP_OpenClientSkt%649:

0001dfe4 <TCPIP_UDP_OpenClientSkt>:
    if(addType == IP_ADDRESS_TYPE_IPV6)
   1dfe4:	2802      	cmp	r0, #2
   1dfe6:	d015      	beq.n	1e014 <TCPIP_UDP_OpenClientSkt+0x30>
{
   1dfe8:	b508      	push	{r3, lr}
   1dfea:	4618      	mov	r0, r3
   1dfec:	4613      	mov	r3, r2
   1dfee:	460a      	mov	r2, r1
    skt = _UDPOpen(addType, opType, remotePort, remoteAddress);
   1dff0:	4601      	mov	r1, r0
   1dff2:	2001      	movs	r0, #1
   1dff4:	f7f3 f9da 	bl	113ac <_UDPOpen>
    if(skt != INVALID_UDP_SOCKET)
   1dff8:	f1b0 3fff 	cmp.w	r0, #4294967295
   1dffc:	d009      	beq.n	1e012 <TCPIP_UDP_OpenClientSkt+0x2e>
        UDP_SOCKET_DCPT* pSkt = UDPSocketDcpt[skt];
   1dffe:	4b07      	ldr	r3, [pc, #28]	; (1e01c <TCPIP_UDP_OpenClientSkt+0x38>)
   1e000:	681b      	ldr	r3, [r3, #0]
   1e002:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
    pSkt->extFlags.rxEnable = 1;
   1e006:	f892 3042 	ldrb.w	r3, [r2, #66]	; 0x42
   1e00a:	f043 0302 	orr.w	r3, r3, #2
   1e00e:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
}
   1e012:	bd08      	pop	{r3, pc}
        return INVALID_SOCKET; 
   1e014:	f04f 30ff 	mov.w	r0, #4294967295
}
   1e018:	4770      	bx	lr
   1e01a:	bf00      	nop
   1e01c:	2000e65c 	.word	0x2000e65c

Disassembly of section .text.Console_UART_Read%650:

0001e020 <Console_UART_Read>:
    pConsoleUartData->status = SYS_CONSOLE_STATUS_CONFIGURED;
}

/* Read out the data from the RX Ring Buffer */
ssize_t Console_UART_Read(uint32_t index, void* pRdBuffer, size_t count)
{
   1e020:	b570      	push	{r4, r5, r6, lr}
    ssize_t nBytesRead = 0;
    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   1e022:	b990      	cbnz	r0, 1e04a <Console_UART_Read+0x2a>
   1e024:	4615      	mov	r5, r2
   1e026:	460c      	mov	r4, r1
    if (pConsoleUartData == NULL)
    {
        return -1;
    }

    if (Console_UART_ResourceLock(pConsoleUartData) == false)
   1e028:	480b      	ldr	r0, [pc, #44]	; (1e058 <Console_UART_Read+0x38>)
   1e02a:	f003 fc35 	bl	21898 <Console_UART_ResourceLock>
   1e02e:	b178      	cbz	r0, 1e050 <Console_UART_Read+0x30>
    {
        return -1;
    }

    nBytesRead = pConsoleUartData->uartPLIB->read(pRdBuffer, count);
   1e030:	4e09      	ldr	r6, [pc, #36]	; (1e058 <Console_UART_Read+0x38>)
   1e032:	f856 3b08 	ldr.w	r3, [r6], #8
   1e036:	681b      	ldr	r3, [r3, #0]
   1e038:	4629      	mov	r1, r5
   1e03a:	4620      	mov	r0, r4
   1e03c:	4798      	blx	r3
   1e03e:	4604      	mov	r4, r0
    OSAL_MUTEX_Unlock(&(pConsoleUartData->mutexTransferObjects));
   1e040:	4630      	mov	r0, r6
   1e042:	f003 fa4f 	bl	214e4 <OSAL_MUTEX_Unlock>

    Console_UART_ResourceUnlock(pConsoleUartData);

    return nBytesRead;
}
   1e046:	4620      	mov	r0, r4
   1e048:	bd70      	pop	{r4, r5, r6, pc}
        return -1;
   1e04a:	f04f 34ff 	mov.w	r4, #4294967295
   1e04e:	e7fa      	b.n	1e046 <Console_UART_Read+0x26>
        return -1;
   1e050:	f04f 34ff 	mov.w	r4, #4294967295
   1e054:	e7f7      	b.n	1e046 <Console_UART_Read+0x26>
   1e056:	bf00      	nop
   1e058:	2000e534 	.word	0x2000e534

Disassembly of section .text.Console_UART_Write%651:

0001e05c <Console_UART_Write>:

    return nFreeBufferAvailable;
}

ssize_t Console_UART_Write(uint32_t index, const void* pWrBuffer, size_t count )
{
   1e05c:	b570      	push	{r4, r5, r6, lr}
    ssize_t nBytesWritten = 0;

    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   1e05e:	b990      	cbnz	r0, 1e086 <Console_UART_Write+0x2a>
   1e060:	4615      	mov	r5, r2
   1e062:	460c      	mov	r4, r1
    if (pConsoleUartData == NULL)
    {
        return -1;
    }

    if (Console_UART_ResourceLock(pConsoleUartData) == false)
   1e064:	480b      	ldr	r0, [pc, #44]	; (1e094 <Console_UART_Write+0x38>)
   1e066:	f003 fc17 	bl	21898 <Console_UART_ResourceLock>
   1e06a:	b178      	cbz	r0, 1e08c <Console_UART_Write+0x30>
    {
        return -1;
    }

    nBytesWritten = pConsoleUartData->uartPLIB->write((uint8_t*)pWrBuffer, count);
   1e06c:	4e09      	ldr	r6, [pc, #36]	; (1e094 <Console_UART_Write+0x38>)
   1e06e:	f856 3b08 	ldr.w	r3, [r6], #8
   1e072:	68db      	ldr	r3, [r3, #12]
   1e074:	4629      	mov	r1, r5
   1e076:	4620      	mov	r0, r4
   1e078:	4798      	blx	r3
   1e07a:	4604      	mov	r4, r0
    OSAL_MUTEX_Unlock(&(pConsoleUartData->mutexTransferObjects));
   1e07c:	4630      	mov	r0, r6
   1e07e:	f003 fa31 	bl	214e4 <OSAL_MUTEX_Unlock>

    Console_UART_ResourceUnlock(pConsoleUartData);

    return nBytesWritten;
}
   1e082:	4620      	mov	r0, r4
   1e084:	bd70      	pop	{r4, r5, r6, pc}
        return -1;
   1e086:	f04f 34ff 	mov.w	r4, #4294967295
   1e08a:	e7fa      	b.n	1e082 <Console_UART_Write+0x26>
        return -1;
   1e08c:	f04f 34ff 	mov.w	r4, #4294967295
   1e090:	e7f7      	b.n	1e082 <Console_UART_Write+0x26>
   1e092:	bf00      	nop
   1e094:	2000e534 	.word	0x2000e534

Disassembly of section .text.SYS_TIME_GetTimerObject%652:

0001e098 <SYS_TIME_GetTimerObject>:
    if ((handle != SYS_TIME_HANDLE_INVALID) && (handle != 0))
   1e098:	1e43      	subs	r3, r0, #1
   1e09a:	f113 0f03 	cmn.w	r3, #3
   1e09e:	d80f      	bhi.n	1e0c0 <SYS_TIME_GetTimerObject+0x28>
        if ((handle & _SYS_TIME_INDEX_MASK) < SYS_TIME_MAX_TIMERS)
   1e0a0:	b283      	uxth	r3, r0
   1e0a2:	2b04      	cmp	r3, #4
   1e0a4:	d80e      	bhi.n	1e0c4 <SYS_TIME_GetTimerObject+0x2c>
            if ((timerObj->tmrHandle == handle) && (timerObj->inUse == true))
   1e0a6:	4a0a      	ldr	r2, [pc, #40]	; (1e0d0 <SYS_TIME_GetTimerObject+0x38>)
   1e0a8:	eb02 1243 	add.w	r2, r2, r3, lsl #5
   1e0ac:	69d2      	ldr	r2, [r2, #28]
   1e0ae:	4282      	cmp	r2, r0
   1e0b0:	d10a      	bne.n	1e0c8 <SYS_TIME_GetTimerObject+0x30>
   1e0b2:	015a      	lsls	r2, r3, #5
   1e0b4:	4906      	ldr	r1, [pc, #24]	; (1e0d0 <SYS_TIME_GetTimerObject+0x38>)
   1e0b6:	5c8a      	ldrb	r2, [r1, r2]
   1e0b8:	b142      	cbz	r2, 1e0cc <SYS_TIME_GetTimerObject+0x34>
            timerObj = &timers[handle & _SYS_TIME_INDEX_MASK];
   1e0ba:	eb01 1043 	add.w	r0, r1, r3, lsl #5
                return timerObj;
   1e0be:	4770      	bx	lr
    return NULL;
   1e0c0:	2000      	movs	r0, #0
   1e0c2:	4770      	bx	lr
   1e0c4:	2000      	movs	r0, #0
   1e0c6:	4770      	bx	lr
   1e0c8:	2000      	movs	r0, #0
   1e0ca:	4770      	bx	lr
   1e0cc:	2000      	movs	r0, #0
}
   1e0ce:	4770      	bx	lr
   1e0d0:	2000dd50 	.word	0x2000dd50

Disassembly of section .text.SYS_TIME_ResourceUnlock%653:

0001e0d4 <SYS_TIME_ResourceUnlock>:
{
   1e0d4:	b508      	push	{r3, lr}
    SYS_INT_SourceEnable(gSystemCounterObj.hwTimerIntNum);
   1e0d6:	4b0b      	ldr	r3, [pc, #44]	; (1e104 <SYS_TIME_ResourceUnlock+0x30>)
   1e0d8:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
  if ((int32_t)(IRQn) >= 0)
   1e0dc:	2b00      	cmp	r3, #0
   1e0de:	db08      	blt.n	1e0f2 <SYS_TIME_ResourceUnlock+0x1e>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1e0e0:	0959      	lsrs	r1, r3, #5
   1e0e2:	f003 031f 	and.w	r3, r3, #31
   1e0e6:	2201      	movs	r2, #1
   1e0e8:	fa02 f303 	lsl.w	r3, r2, r3
   1e0ec:	4a06      	ldr	r2, [pc, #24]	; (1e108 <SYS_TIME_ResourceUnlock+0x34>)
   1e0ee:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    if(gSystemCounterObj.interruptNestingCount == 0)
   1e0f2:	4b04      	ldr	r3, [pc, #16]	; (1e104 <SYS_TIME_ResourceUnlock+0x30>)
   1e0f4:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   1e0f8:	b103      	cbz	r3, 1e0fc <SYS_TIME_ResourceUnlock+0x28>
}
   1e0fa:	bd08      	pop	{r3, pc}
        OSAL_MUTEX_Unlock(&gSystemCounterObj.timerMutex);
   1e0fc:	4803      	ldr	r0, [pc, #12]	; (1e10c <SYS_TIME_ResourceUnlock+0x38>)
   1e0fe:	f003 f9f1 	bl	214e4 <OSAL_MUTEX_Unlock>
}
   1e102:	e7fa      	b.n	1e0fa <SYS_TIME_ResourceUnlock+0x26>
   1e104:	2000e230 	.word	0x2000e230
   1e108:	e000e100 	.word	0xe000e100
   1e10c:	2000e264 	.word	0x2000e264

Disassembly of section .text.SYS_TIME_Counter64Get%654:

0001e110 <SYS_TIME_Counter64Get>:
{
   1e110:	b538      	push	{r3, r4, r5, lr}
    if (SYS_TIME_ResourceLock() == false)
   1e112:	f000 fa93 	bl	1e63c <SYS_TIME_ResourceLock>
   1e116:	b1a0      	cbz	r0, 1e142 <SYS_TIME_Counter64Get+0x32>
    elapsedCount = SYS_TIME_GetElapsedCount(counterObj->timePlib->timerCounterGet());
   1e118:	4c0b      	ldr	r4, [pc, #44]	; (1e148 <SYS_TIME_Counter64Get+0x38>)
   1e11a:	6863      	ldr	r3, [r4, #4]
   1e11c:	699b      	ldr	r3, [r3, #24]
   1e11e:	4798      	blx	r3
   1e120:	f002 ff3c 	bl	20f9c <SYS_TIME_GetElapsedCount>
    uint32_t prevSwCounter32Bit = counterObj->swCounter64Low;
   1e124:	6a63      	ldr	r3, [r4, #36]	; 0x24
    counter64 = counterObj->swCounter64High;
   1e126:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    if (isSwCounter32Oveflow == true)
   1e128:	18c0      	adds	r0, r0, r3
   1e12a:	d208      	bcs.n	1e13e <SYS_TIME_Counter64Get+0x2e>
    counter64 = ((counter64 << 32) + counter32);
   1e12c:	2200      	movs	r2, #0
   1e12e:	1814      	adds	r4, r2, r0
   1e130:	f141 0500 	adc.w	r5, r1, #0
    SYS_TIME_ResourceUnlock();
   1e134:	f7ff ffce 	bl	1e0d4 <SYS_TIME_ResourceUnlock>
}
   1e138:	4620      	mov	r0, r4
   1e13a:	4629      	mov	r1, r5
   1e13c:	bd38      	pop	{r3, r4, r5, pc}
        counter64++;
   1e13e:	3101      	adds	r1, #1
   1e140:	e7f4      	b.n	1e12c <SYS_TIME_Counter64Get+0x1c>
        return counter64;
   1e142:	2400      	movs	r4, #0
   1e144:	2500      	movs	r5, #0
   1e146:	e7f7      	b.n	1e138 <SYS_TIME_Counter64Get+0x28>
   1e148:	2000e230 	.word	0x2000e230

Disassembly of section .text.SYS_TIME_TimerDestroy%655:

0001e14c <SYS_TIME_TimerDestroy>:
{
   1e14c:	b510      	push	{r4, lr}
   1e14e:	4604      	mov	r4, r0
    if (SYS_TIME_ResourceLock() == false)
   1e150:	f000 fa74 	bl	1e63c <SYS_TIME_ResourceLock>
   1e154:	b1b0      	cbz	r0, 1e184 <SYS_TIME_TimerDestroy+0x38>
    tmr = SYS_TIME_GetTimerObject(handle);
   1e156:	4620      	mov	r0, r4
   1e158:	f7ff ff9e 	bl	1e098 <SYS_TIME_GetTimerObject>
    if(tmr != NULL)
   1e15c:	4604      	mov	r4, r0
   1e15e:	b178      	cbz	r0, 1e180 <SYS_TIME_TimerDestroy+0x34>
        if(tmr->active == true)
   1e160:	7843      	ldrb	r3, [r0, #1]
   1e162:	b943      	cbnz	r3, 1e176 <SYS_TIME_TimerDestroy+0x2a>
        tmr->tmrElapsedFlag = false;
   1e164:	2000      	movs	r0, #0
   1e166:	7520      	strb	r0, [r4, #20]
        tmr->tmrElapsed = false;
   1e168:	7560      	strb	r0, [r4, #21]
        tmr->inUse = false;
   1e16a:	7020      	strb	r0, [r4, #0]
        result = SYS_TIME_SUCCESS;
   1e16c:	4604      	mov	r4, r0
    SYS_TIME_ResourceUnlock();
   1e16e:	f7ff ffb1 	bl	1e0d4 <SYS_TIME_ResourceUnlock>
}
   1e172:	4620      	mov	r0, r4
   1e174:	bd10      	pop	{r4, pc}
            SYS_TIME_RemoveFromList(tmr);
   1e176:	f7fd faf7 	bl	1b768 <SYS_TIME_RemoveFromList>
            tmr->active = false;
   1e17a:	2300      	movs	r3, #0
   1e17c:	7063      	strb	r3, [r4, #1]
   1e17e:	e7f1      	b.n	1e164 <SYS_TIME_TimerDestroy+0x18>
    SYS_TIME_RESULT result = SYS_TIME_ERROR;
   1e180:	2401      	movs	r4, #1
   1e182:	e7f4      	b.n	1e16e <SYS_TIME_TimerDestroy+0x22>
        return result;
   1e184:	2401      	movs	r4, #1
   1e186:	e7f4      	b.n	1e172 <SYS_TIME_TimerDestroy+0x26>

Disassembly of section .text.wc_InitMd5_ex%656:

0001e188 <wc_InitMd5_ex>:
    if (md5 == NULL)
   1e188:	4603      	mov	r3, r0
   1e18a:	b1a8      	cbz	r0, 1e1b8 <wc_InitMd5_ex+0x30>
    md5->heap = heap;
   1e18c:	65c1      	str	r1, [r0, #92]	; 0x5c
    md5->digest[0] = 0x67452301L;
   1e18e:	4a0c      	ldr	r2, [pc, #48]	; (1e1c0 <wc_InitMd5_ex+0x38>)
   1e190:	64c2      	str	r2, [r0, #76]	; 0x4c
    md5->digest[1] = 0xefcdab89L;
   1e192:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
   1e196:	6502      	str	r2, [r0, #80]	; 0x50
    md5->digest[2] = 0x98badcfeL;
   1e198:	f102 4229 	add.w	r2, r2, #2835349504	; 0xa9000000
   1e19c:	f5a2 1296 	sub.w	r2, r2, #1228800	; 0x12c000
   1e1a0:	f6a2 628b 	subw	r2, r2, #3723	; 0xe8b
   1e1a4:	6542      	str	r2, [r0, #84]	; 0x54
    md5->digest[3] = 0x10325476L;
   1e1a6:	f1a2 3288 	sub.w	r2, r2, #2290649224	; 0x88888888
   1e1aa:	6582      	str	r2, [r0, #88]	; 0x58
    md5->buffLen = 0;
   1e1ac:	2000      	movs	r0, #0
   1e1ae:	6018      	str	r0, [r3, #0]
    md5->loLen   = 0;
   1e1b0:	6058      	str	r0, [r3, #4]
    md5->hiLen   = 0;
   1e1b2:	6098      	str	r0, [r3, #8]
    md5->flags = 0;
   1e1b4:	6618      	str	r0, [r3, #96]	; 0x60
    if (ret != 0)
   1e1b6:	4770      	bx	lr
        return BAD_FUNC_ARG;
   1e1b8:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
   1e1bc:	4770      	bx	lr
   1e1be:	bf00      	nop
   1e1c0:	67452301 	.word	0x67452301

Disassembly of section .text.__assert_func%657:

0001e1c4 <__assert_func>:
   1e1c4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   1e1c6:	461c      	mov	r4, r3
   1e1c8:	4b09      	ldr	r3, [pc, #36]	; (1e1f0 <__assert_func+0x2c>)
   1e1ca:	681b      	ldr	r3, [r3, #0]
   1e1cc:	4605      	mov	r5, r0
   1e1ce:	68d8      	ldr	r0, [r3, #12]
   1e1d0:	b152      	cbz	r2, 1e1e8 <__assert_func+0x24>
   1e1d2:	4b08      	ldr	r3, [pc, #32]	; (1e1f4 <__assert_func+0x30>)
   1e1d4:	9100      	str	r1, [sp, #0]
   1e1d6:	e9cd 3201 	strd	r3, r2, [sp, #4]
   1e1da:	4907      	ldr	r1, [pc, #28]	; (1e1f8 <__assert_func+0x34>)
   1e1dc:	462b      	mov	r3, r5
   1e1de:	4622      	mov	r2, r4
   1e1e0:	f002 f99e 	bl	20520 <fiprintf>
   1e1e4:	f003 fd2b 	bl	21c3e <abort>
   1e1e8:	4b04      	ldr	r3, [pc, #16]	; (1e1fc <__assert_func+0x38>)
   1e1ea:	461a      	mov	r2, r3
   1e1ec:	e7f2      	b.n	1e1d4 <__assert_func+0x10>
   1e1ee:	bf00      	nop
   1e1f0:	2000e700 	.word	0x2000e700
   1e1f4:	0001dd4d 	.word	0x0001dd4d
   1e1f8:	0001dd5a 	.word	0x0001dd5a
   1e1fc:	0001dd4c 	.word	0x0001dd4c

Disassembly of section .text._fwalk_reent%658:

0001e200 <_fwalk_reent>:
   1e200:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1e204:	4680      	mov	r8, r0
   1e206:	4689      	mov	r9, r1
   1e208:	f100 0448 	add.w	r4, r0, #72	; 0x48
   1e20c:	2600      	movs	r6, #0
   1e20e:	b914      	cbnz	r4, 1e216 <_fwalk_reent+0x16>
   1e210:	4630      	mov	r0, r6
   1e212:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1e216:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
   1e21a:	3f01      	subs	r7, #1
   1e21c:	d501      	bpl.n	1e222 <_fwalk_reent+0x22>
   1e21e:	6824      	ldr	r4, [r4, #0]
   1e220:	e7f5      	b.n	1e20e <_fwalk_reent+0xe>
   1e222:	89ab      	ldrh	r3, [r5, #12]
   1e224:	2b01      	cmp	r3, #1
   1e226:	d907      	bls.n	1e238 <_fwalk_reent+0x38>
   1e228:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
   1e22c:	3301      	adds	r3, #1
   1e22e:	d003      	beq.n	1e238 <_fwalk_reent+0x38>
   1e230:	4629      	mov	r1, r5
   1e232:	4640      	mov	r0, r8
   1e234:	47c8      	blx	r9
   1e236:	4306      	orrs	r6, r0
   1e238:	3564      	adds	r5, #100	; 0x64
   1e23a:	e7ee      	b.n	1e21a <_fwalk_reent+0x1a>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase1%659:

0001e23c <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase1>:
{
   1e23c:	b510      	push	{r4, lr}
   1e23e:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1e240:	f002 fa10 	bl	20664 <_DRV_PHY_SMITransfer_Wait>
   1e244:	b180      	cbz	r0, 1e268 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase1+0x2c>
    matchCpbl = (hClientObj->operReg[0] & (MAC_COMM_CPBL_MASK | _BMSTAT_AN_ABLE_MASK)) & phyCpbl; // common features
   1e246:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   1e248:	8f62      	ldrh	r2, [r4, #58]	; 0x3a
   1e24a:	4013      	ands	r3, r2
    if(!(matchCpbl & MAC_COMM_CPBL_MASK))
   1e24c:	f413 4ff0 	tst.w	r3, #30720	; 0x7800
   1e250:	d00b      	beq.n	1e26a <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase1+0x2e>
    matchCpbl = (hClientObj->operReg[0] & (MAC_COMM_CPBL_MASK | _BMSTAT_AN_ABLE_MASK)) & phyCpbl; // common features
   1e252:	f423 4307 	bic.w	r3, r3, #34560	; 0x8700
   1e256:	f023 03f7 	bic.w	r3, r3, #247	; 0xf7
    hClientObj->operReg[1] = matchCpbl;
   1e25a:	84a3      	strh	r3, [r4, #36]	; 0x24
    hClientObj->vendorData = 0;
   1e25c:	2300      	movs	r3, #0
   1e25e:	6423      	str	r3, [r4, #64]	; 0x40
    hClientObj->operPhase = operPhase;
   1e260:	2303      	movs	r3, #3
   1e262:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1e264:	2302      	movs	r3, #2
   1e266:	8423      	strh	r3, [r4, #32]
}
   1e268:	bd10      	pop	{r4, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_CPBL_ERR);
   1e26a:	f06f 0102 	mvn.w	r1, #2
   1e26e:	4620      	mov	r0, r4
   1e270:	f001 fca8 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
        return;
   1e274:	e7f8      	b.n	1e268 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase1+0x2c>

Disassembly of section .text._DRV_ETHPHY_NegRestartPhaseRead%660:

0001e276 <_DRV_ETHPHY_NegRestartPhaseRead>:
{
   1e276:	b510      	push	{r4, lr}
   1e278:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1e27a:	f002 f9f3 	bl	20664 <_DRV_PHY_SMITransfer_Wait>
   1e27e:	b158      	cbz	r0, 1e298 <_DRV_ETHPHY_NegRestartPhaseRead+0x22>
    if(phyCpbl.AN_ABLE == 0)
   1e280:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
   1e284:	f013 0f08 	tst.w	r3, #8
   1e288:	d007      	beq.n	1e29a <_DRV_ETHPHY_NegRestartPhaseRead+0x24>
    if(_DRV_PHY_SMIWriteStart(hClientObj, PHY_REG_BMCON, _BMCON_AN_ENABLE_MASK | _BMCON_AN_RESTART_MASK ))
   1e28a:	f44f 5290 	mov.w	r2, #4608	; 0x1200
   1e28e:	2100      	movs	r1, #0
   1e290:	4620      	mov	r0, r4
   1e292:	f000 fd6a 	bl	1ed6a <_DRV_PHY_SMIWriteStart>
   1e296:	b930      	cbnz	r0, 1e2a6 <_DRV_ETHPHY_NegRestartPhaseRead+0x30>
}
   1e298:	bd10      	pop	{r4, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_NEGOTIATION_UNABLE);
   1e29a:	f06f 0105 	mvn.w	r1, #5
   1e29e:	4620      	mov	r0, r4
   1e2a0:	f001 fc90 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
        return;
   1e2a4:	e7f8      	b.n	1e298 <_DRV_ETHPHY_NegRestartPhaseRead+0x22>
    hClientObj->operPhase = operPhase;
   1e2a6:	2302      	movs	r3, #2
   1e2a8:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1e2aa:	2300      	movs	r3, #0
   1e2ac:	8423      	strh	r3, [r4, #32]
   1e2ae:	e7f3      	b.n	1e298 <_DRV_ETHPHY_NegRestartPhaseRead+0x22>

Disassembly of section .text._DRV_MIIM_ReleaseOpDcpt%661:

0001e2b0 <_DRV_MIIM_ReleaseOpDcpt>:
{
   1e2b0:	b570      	push	{r4, r5, r6, lr}
   1e2b2:	4605      	mov	r5, r0
   1e2b4:	460c      	mov	r4, r1
    pRemNode =  (DRV_MIIM_OP_DCPT*)Helper_SingleListNodeRemove(pRemList, (SGL_LIST_NODE*)pOpDcpt);
   1e2b6:	4610      	mov	r0, r2
   1e2b8:	f7fe ffae 	bl	1d218 <Helper_SingleListNodeRemove>
    if(pRemNode == pOpDcpt)
   1e2bc:	4284      	cmp	r4, r0
   1e2be:	d000      	beq.n	1e2c2 <_DRV_MIIM_ReleaseOpDcpt+0x12>
}
   1e2c0:	bd70      	pop	{r4, r5, r6, pc}
        wasScan = pOpDcpt->opType == DRV_MIIM_OP_SCAN; 
   1e2c2:	7926      	ldrb	r6, [r4, #4]
        memset(pOpDcpt, 0, sizeof(*pOpDcpt));
   1e2c4:	2300      	movs	r3, #0
   1e2c6:	6023      	str	r3, [r4, #0]
   1e2c8:	6063      	str	r3, [r4, #4]
   1e2ca:	60a3      	str	r3, [r4, #8]
   1e2cc:	60e3      	str	r3, [r4, #12]
    Helper_SingleListTailAdd(pL, (SGL_LIST_NODE*)pOpDcpt);
   1e2ce:	4621      	mov	r1, r4
   1e2d0:	f105 0070 	add.w	r0, r5, #112	; 0x70
   1e2d4:	f002 ff09 	bl	210ea <Helper_SingleListTailAdd>
    pOpDcpt->qType = qType;
   1e2d8:	2301      	movs	r3, #1
   1e2da:	72e3      	strb	r3, [r4, #11]
    if(wasScan)
   1e2dc:	2e03      	cmp	r6, #3
   1e2de:	d1ef      	bne.n	1e2c0 <_DRV_MIIM_ReleaseOpDcpt+0x10>
        pMiimObj->objFlags &= ~DRV_MIIM_OBJ_FLAG_IS_SCANNING;
   1e2e0:	88ab      	ldrh	r3, [r5, #4]
   1e2e2:	f023 0308 	bic.w	r3, r3, #8
   1e2e6:	80ab      	strh	r3, [r5, #4]
}
   1e2e8:	e7ea      	b.n	1e2c0 <_DRV_MIIM_ReleaseOpDcpt+0x10>

Disassembly of section .text.DRV_MIIM_Deinitialize%662:

0001e2ea <DRV_MIIM_Deinitialize>:
{
   1e2ea:	b510      	push	{r4, lr}
    DRV_MIIM_OBJ* pMiimObj = _DRV_MIIM_GetObjectAndLock(hSysObj);
   1e2ec:	f001 f871 	bl	1f3d2 <_DRV_MIIM_GetObjectAndLock>
    if(pMiimObj != 0)
   1e2f0:	b188      	cbz	r0, 1e316 <DRV_MIIM_Deinitialize+0x2c>
   1e2f2:	4604      	mov	r4, r0
        pClient = pMiimObj->objClients;
   1e2f4:	3010      	adds	r0, #16
            if(pClient->clientInUse != 0)
   1e2f6:	8a23      	ldrh	r3, [r4, #16]
   1e2f8:	b973      	cbnz	r3, 1e318 <DRV_MIIM_Deinitialize+0x2e>
        for(ix = 0; ix < sizeof(pMiimObj->objClients) / sizeof(*pMiimObj->objClients); ix++, pClient++)
   1e2fa:	f104 0020 	add.w	r0, r4, #32
            if(pClient->clientInUse != 0)
   1e2fe:	8c23      	ldrh	r3, [r4, #32]
   1e300:	b96b      	cbnz	r3, 1e31e <DRV_MIIM_Deinitialize+0x34>
        OSAL_SEM_Delete(&pMiimObj->objSem);
   1e302:	4620      	mov	r0, r4
   1e304:	f003 fb32 	bl	2196c <OSAL_SEM_Delete>
        memset(pMiimObj, 0, sizeof(*pMiimObj));
   1e308:	2294      	movs	r2, #148	; 0x94
   1e30a:	2100      	movs	r1, #0
   1e30c:	4620      	mov	r0, r4
   1e30e:	f003 fc35 	bl	21b7c <memset>
        pMiimObj->objStatus  = SYS_STATUS_UNINITIALIZED;
   1e312:	2300      	movs	r3, #0
   1e314:	7223      	strb	r3, [r4, #8]
} 
   1e316:	bd10      	pop	{r4, pc}
                _DRV_MIIM_ClientDeallocate(pClient);
   1e318:	f7f7 fe66 	bl	15fe8 <_DRV_MIIM_ClientDeallocate>
   1e31c:	e7ed      	b.n	1e2fa <DRV_MIIM_Deinitialize+0x10>
   1e31e:	f7f7 fe63 	bl	15fe8 <_DRV_MIIM_ClientDeallocate>
   1e322:	e7ee      	b.n	1e302 <DRV_MIIM_Deinitialize+0x18>

Disassembly of section .text._TCPIP_HEAP_MaxSize%663:

0001e324 <_TCPIP_HEAP_MaxSize>:
    }
    return 0;
}

static size_t _TCPIP_HEAP_MaxSize(TCPIP_STACK_HEAP_HANDLE heapH)
{
   1e324:	b538      	push	{r3, r4, r5, lr}
    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   1e326:	b1c0      	cbz	r0, 1e35a <_TCPIP_HEAP_MaxSize+0x36>
   1e328:	4604      	mov	r4, r0
    max_nunits = 0;

    hDcpt = _TCPIP_HEAP_ObjDcpt(heapH);
    if(hDcpt)
    {
        OSAL_SEM_Pend(&hDcpt->_heapSemaphore, OSAL_WAIT_FOREVER);
   1e32a:	f100 0544 	add.w	r5, r0, #68	; 0x44
   1e32e:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1e332:	4628      	mov	r0, r5
   1e334:	f002 fca6 	bl	20c84 <OSAL_SEM_Pend>

        for(ptr = hDcpt->_heapHead; ptr != 0; ptr = ptr->next)
   1e338:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1e33a:	b163      	cbz	r3, 1e356 <_TCPIP_HEAP_MaxSize+0x32>
    max_nunits = 0;
   1e33c:	2400      	movs	r4, #0
        {
            if(ptr->units >= max_nunits)
   1e33e:	685a      	ldr	r2, [r3, #4]
   1e340:	4294      	cmp	r4, r2
   1e342:	bf38      	it	cc
   1e344:	4614      	movcc	r4, r2
        for(ptr = hDcpt->_heapHead; ptr != 0; ptr = ptr->next)
   1e346:	681b      	ldr	r3, [r3, #0]
   1e348:	2b00      	cmp	r3, #0
   1e34a:	d1f8      	bne.n	1e33e <_TCPIP_HEAP_MaxSize+0x1a>
            {   // found block
                max_nunits = ptr->units;
            }
        }
        OSAL_SEM_Post(&hDcpt->_heapSemaphore);
   1e34c:	4628      	mov	r0, r5
   1e34e:	f003 f8b1 	bl	214b4 <OSAL_SEM_Post>
    }

    return max_nunits * sizeof(_headNode);   

}
   1e352:	0120      	lsls	r0, r4, #4
   1e354:	bd38      	pop	{r3, r4, r5, pc}
    max_nunits = 0;
   1e356:	2400      	movs	r4, #0
   1e358:	e7f8      	b.n	1e34c <_TCPIP_HEAP_MaxSize+0x28>
   1e35a:	2400      	movs	r4, #0
   1e35c:	e7f9      	b.n	1e352 <_TCPIP_HEAP_MaxSize+0x2e>

Disassembly of section .text._DHCPOptionProcessMsgType%664:

0001e35e <_DHCPOptionProcessMsgType>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_MSG_TYPE))
   1e35e:	684b      	ldr	r3, [r1, #4]
   1e360:	2b02      	cmp	r3, #2
   1e362:	d911      	bls.n	1e388 <_DHCPOptionProcessMsgType+0x2a>
        TCPIP_DHCP_OPTION_DATA_MSG_TYPE* pMsgType = (TCPIP_DHCP_OPTION_DATA_MSG_TYPE*)pOptData->pOpt;
   1e364:	680b      	ldr	r3, [r1, #0]
        if(pMsgType->len == sizeof(pMsgType->type))
   1e366:	785a      	ldrb	r2, [r3, #1]
   1e368:	2a01      	cmp	r2, #1
   1e36a:	d110      	bne.n	1e38e <_DHCPOptionProcessMsgType+0x30>
            pOptData->msgType = pMsgType->type;
   1e36c:	789b      	ldrb	r3, [r3, #2]
   1e36e:	608b      	str	r3, [r1, #8]
            if(pOptData->msgType != TCPIP_DHCP_OFFER_MESSAGE || pClient->flags.bOfferReceived == 0)
   1e370:	2b02      	cmp	r3, #2
   1e372:	d10f      	bne.n	1e394 <_DHCPOptionProcessMsgType+0x36>
   1e374:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   1e378:	f003 0304 	and.w	r3, r3, #4
                return sizeof(TCPIP_DHCP_OPTION_DATA_MSG_TYPE);
   1e37c:	2b00      	cmp	r3, #0
   1e37e:	bf14      	ite	ne
   1e380:	f04f 30ff 	movne.w	r0, #4294967295
   1e384:	2003      	moveq	r0, #3
   1e386:	4770      	bx	lr
    return -1;
   1e388:	f04f 30ff 	mov.w	r0, #4294967295
   1e38c:	4770      	bx	lr
   1e38e:	f04f 30ff 	mov.w	r0, #4294967295
   1e392:	4770      	bx	lr
                return sizeof(TCPIP_DHCP_OPTION_DATA_MSG_TYPE);
   1e394:	2003      	movs	r0, #3
}
   1e396:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAliasNameGet%665:

0001e398 <TCPIP_STACK_NetAliasNameGet>:
{
   1e398:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1e39a:	460c      	mov	r4, r1
   1e39c:	4616      	mov	r6, r2
    if(pNetIf)
   1e39e:	4607      	mov	r7, r0
   1e3a0:	b150      	cbz	r0, 1e3b8 <TCPIP_STACK_NetAliasNameGet+0x20>
        aliasSize = strlen(pNetIf->ifName);
   1e3a2:	3062      	adds	r0, #98	; 0x62
   1e3a4:	f003 fbfa 	bl	21b9c <strlen>
   1e3a8:	4605      	mov	r5, r0
    if(nameBuffer && buffSize)
   1e3aa:	b11c      	cbz	r4, 1e3b4 <TCPIP_STACK_NetAliasNameGet+0x1c>
   1e3ac:	b116      	cbz	r6, 1e3b4 <TCPIP_STACK_NetAliasNameGet+0x1c>
        if(aliasSize)
   1e3ae:	b92d      	cbnz	r5, 1e3bc <TCPIP_STACK_NetAliasNameGet+0x24>
            nameBuffer[0] = 0;
   1e3b0:	2300      	movs	r3, #0
   1e3b2:	7023      	strb	r3, [r4, #0]
}
   1e3b4:	4628      	mov	r0, r5
   1e3b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        aliasSize = 0;
   1e3b8:	2500      	movs	r5, #0
   1e3ba:	e7f6      	b.n	1e3aa <TCPIP_STACK_NetAliasNameGet+0x12>
            strncpy(nameBuffer, pNetIf->ifName, buffSize - 1);
   1e3bc:	1e72      	subs	r2, r6, #1
   1e3be:	f107 0162 	add.w	r1, r7, #98	; 0x62
   1e3c2:	4620      	mov	r0, r4
   1e3c4:	f001 ff3f 	bl	20246 <strncpy>
            nameBuffer[buffSize - 1] = 0;
   1e3c8:	4434      	add	r4, r6
   1e3ca:	2300      	movs	r3, #0
   1e3cc:	f804 3c01 	strb.w	r3, [r4, #-1]
   1e3d0:	e7f0      	b.n	1e3b4 <TCPIP_STACK_NetAliasNameGet+0x1c>

Disassembly of section .text.DRV_ETHPHY_HWConfigFlagsGet%666:

0001e3d4 <DRV_ETHPHY_HWConfigFlagsGet>:
    if(hClientObj != 0)
   1e3d4:	b168      	cbz	r0, 1e3f2 <DRV_ETHPHY_HWConfigFlagsGet+0x1e>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1e3d6:	68c2      	ldr	r2, [r0, #12]
   1e3d8:	4b0a      	ldr	r3, [pc, #40]	; (1e404 <DRV_ETHPHY_HWConfigFlagsGet+0x30>)
   1e3da:	429a      	cmp	r2, r3
   1e3dc:	d10c      	bne.n	1e3f8 <DRV_ETHPHY_HWConfigFlagsGet+0x24>
            hwFlags = ((GMAC_REGS->GMAC_UR & GMAC_UR_Msk)== DRV_GMAC_RMII_MODE) ?  DRV_ETHPHY_CFG_RMII : DRV_ETHPHY_CFG_MII;
   1e3de:	4b0a      	ldr	r3, [pc, #40]	; (1e408 <DRV_ETHPHY_HWConfigFlagsGet+0x34>)
   1e3e0:	68db      	ldr	r3, [r3, #12]
            if(pFlags)
   1e3e2:	b161      	cbz	r1, 1e3fe <DRV_ETHPHY_HWConfigFlagsGet+0x2a>
            hwFlags = ((GMAC_REGS->GMAC_UR & GMAC_UR_Msk)== DRV_GMAC_RMII_MODE) ?  DRV_ETHPHY_CFG_RMII : DRV_ETHPHY_CFG_MII;
   1e3e4:	f083 0301 	eor.w	r3, r3, #1
   1e3e8:	f003 0301 	and.w	r3, r3, #1
                *pFlags = hwFlags;
   1e3ec:	700b      	strb	r3, [r1, #0]
            return ethRes;
   1e3ee:	2000      	movs	r0, #0
   1e3f0:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1e3f2:	f06f 000a 	mvn.w	r0, #10
   1e3f6:	4770      	bx	lr
   1e3f8:	f06f 000a 	mvn.w	r0, #10
   1e3fc:	4770      	bx	lr
            return ethRes;
   1e3fe:	2000      	movs	r0, #0
}
   1e400:	4770      	bx	lr
   1e402:	bf00      	nop
   1e404:	2000e018 	.word	0x2000e018
   1e408:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase6%667:

0001e40c <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase6>:
{
   1e40c:	b510      	push	{r4, lr}
   1e40e:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1e410:	f002 f928 	bl	20664 <_DRV_PHY_SMITransfer_Wait>
   1e414:	b1a8      	cbz	r0, 1e442 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase6+0x36>
    if(phyCpbl.AN_ABLE)
   1e416:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
   1e41a:	f013 0f08 	tst.w	r3, #8
   1e41e:	d00b      	beq.n	1e438 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase6+0x2c>
        if(_DRV_PHY_SMIWriteStart( hClientObj, PHY_REG_BMCON, _BMCON_AN_ENABLE_MASK | _BMCON_AN_RESTART_MASK ))
   1e420:	f44f 5290 	mov.w	r2, #4608	; 0x1200
   1e424:	2100      	movs	r1, #0
   1e426:	4620      	mov	r0, r4
   1e428:	f000 fc9f 	bl	1ed6a <_DRV_PHY_SMIWriteStart>
   1e42c:	b148      	cbz	r0, 1e442 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase6+0x36>
    hClientObj->operPhase = operPhase;
   1e42e:	2303      	movs	r3, #3
   1e430:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1e432:	2307      	movs	r3, #7
   1e434:	8423      	strh	r3, [r4, #32]
   1e436:	e004      	b.n	1e442 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase6+0x36>
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_NEGOTIATION_UNABLE);
   1e438:	f06f 0105 	mvn.w	r1, #5
   1e43c:	4620      	mov	r0, r4
   1e43e:	f001 fbc1 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
}
   1e442:	bd10      	pop	{r4, pc}

Disassembly of section .text.DRV_GMAC_Open%668:

0001e444 <DRV_GMAC_Open>:
    if(macIx >= 0 && macIx < sizeof(_gmac_drv_dcpt)/sizeof(*_gmac_drv_dcpt))
   1e444:	f241 0350 	movw	r3, #4176	; 0x1050
   1e448:	4298      	cmp	r0, r3
   1e44a:	d10c      	bne.n	1e466 <DRV_GMAC_Open+0x22>
		if(pMACDrv->sGmacData._macFlags._init == 1)
   1e44c:	4b0a      	ldr	r3, [pc, #40]	; (1e478 <DRV_GMAC_Open+0x34>)
   1e44e:	7d9b      	ldrb	r3, [r3, #22]
   1e450:	f013 0f01 	tst.w	r3, #1
   1e454:	d00a      	beq.n	1e46c <DRV_GMAC_Open+0x28>
			if(pMACDrv->sGmacData._macFlags._open == 0)
   1e456:	f013 0f02 	tst.w	r3, #2
   1e45a:	d10a      	bne.n	1e472 <DRV_GMAC_Open+0x2e>
				pMACDrv->sGmacData._macFlags._open = 1;
   1e45c:	4806      	ldr	r0, [pc, #24]	; (1e478 <DRV_GMAC_Open+0x34>)
   1e45e:	f043 0302 	orr.w	r3, r3, #2
   1e462:	7583      	strb	r3, [r0, #22]
				hMac = (DRV_HANDLE)pMACDrv;
   1e464:	4770      	bx	lr
    DRV_HANDLE    hMac = DRV_HANDLE_INVALID;
   1e466:	f04f 30ff 	mov.w	r0, #4294967295
   1e46a:	4770      	bx	lr
   1e46c:	f04f 30ff 	mov.w	r0, #4294967295
   1e470:	4770      	bx	lr
   1e472:	f04f 30ff 	mov.w	r0, #4294967295
}
   1e476:	4770      	bx	lr
   1e478:	2000dab8 	.word	0x2000dab8

Disassembly of section .text.DRV_PIC32CGMAC_LibGetMacAddr%669:

0001e47c <DRV_PIC32CGMAC_LibGetMacAddr>:
    pMacAddr[0] = (GMAC_REGS->SA[0].GMAC_SAB)& 0xFF;
   1e47c:	4b0c      	ldr	r3, [pc, #48]	; (1e4b0 <DRV_PIC32CGMAC_LibGetMacAddr+0x34>)
   1e47e:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   1e482:	7002      	strb	r2, [r0, #0]
    pMacAddr[1] = ((GMAC_REGS->SA[0].GMAC_SAB)>>8)& 0xFF;
   1e484:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   1e488:	0a12      	lsrs	r2, r2, #8
   1e48a:	7042      	strb	r2, [r0, #1]
    pMacAddr[2] = ((GMAC_REGS->SA[0].GMAC_SAB)>>16)& 0xFF;
   1e48c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   1e490:	0c12      	lsrs	r2, r2, #16
   1e492:	7082      	strb	r2, [r0, #2]
    pMacAddr[3] = ((GMAC_REGS->SA[0].GMAC_SAB)>>24)& 0xFF;
   1e494:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   1e498:	0e12      	lsrs	r2, r2, #24
   1e49a:	70c2      	strb	r2, [r0, #3]
    pMacAddr[4] = (GMAC_REGS->SA[0].GMAC_SAT)& 0xFF;
   1e49c:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
   1e4a0:	7102      	strb	r2, [r0, #4]
    pMacAddr[5] = ((GMAC_REGS->SA[0].GMAC_SAT)>>8)& 0xFF;
   1e4a2:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
   1e4a6:	0a1b      	lsrs	r3, r3, #8
   1e4a8:	7143      	strb	r3, [r0, #5]
}
   1e4aa:	2000      	movs	r0, #0
   1e4ac:	4770      	bx	lr
   1e4ae:	bf00      	nop
   1e4b0:	42000800 	.word	0x42000800

Disassembly of section .text._TCP_EphemeralPortAllocate%670:

0001e4b4 <_TCP_EphemeralPortAllocate>:
{
   1e4b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    next_ephemeral = TCPIP_TCP_LOCAL_PORT_START_NUMBER + (SYS_RANDOM_CryptoGet() % num_ephemeral);
   1e4b6:	f001 ffd5 	bl	20464 <SYS_RANDOM_CryptoGet>
   1e4ba:	ea6f 4080 	mvn.w	r0, r0, lsl #18
   1e4be:	ea6f 4090 	mvn.w	r0, r0, lsr #18
   1e4c2:	b284      	uxth	r4, r0
   1e4c4:	f44f 4580 	mov.w	r5, #16384	; 0x4000
        if (next_ephemeral == TCPIP_TCP_LOCAL_PORT_END_NUMBER)
   1e4c8:	f64f 76ff 	movw	r6, #65535	; 0xffff
            next_ephemeral = TCPIP_TCP_LOCAL_PORT_START_NUMBER;
   1e4cc:	f44f 4740 	mov.w	r7, #49152	; 0xc000
        if(_TCP_PortIsAvailable(next_ephemeral))
   1e4d0:	4620      	mov	r0, r4
   1e4d2:	f7ff f99f 	bl	1d814 <_TCP_PortIsAvailable>
   1e4d6:	b938      	cbnz	r0, 1e4e8 <_TCP_EphemeralPortAllocate+0x34>
        if (next_ephemeral == TCPIP_TCP_LOCAL_PORT_END_NUMBER)
   1e4d8:	42b4      	cmp	r4, r6
            next_ephemeral++;
   1e4da:	bf1a      	itte	ne
   1e4dc:	3401      	addne	r4, #1
   1e4de:	b2a4      	uxthne	r4, r4
            next_ephemeral = TCPIP_TCP_LOCAL_PORT_START_NUMBER;
   1e4e0:	463c      	moveq	r4, r7
    while(count--)
   1e4e2:	3d01      	subs	r5, #1
   1e4e4:	d1f4      	bne.n	1e4d0 <_TCP_EphemeralPortAllocate+0x1c>
    return 0;   // not found
   1e4e6:	2400      	movs	r4, #0
}
   1e4e8:	4620      	mov	r0, r4
   1e4ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.TCPIP_Commands_Deinitialize%671:

0001e4ec <TCPIP_Commands_Deinitialize>:
{
   1e4ec:	b508      	push	{r3, lr}
    if(commandInitCount > 0 && stackCtrl->stackAction == TCPIP_STACK_ACTION_DEINIT)
   1e4ee:	4b0b      	ldr	r3, [pc, #44]	; (1e51c <TCPIP_Commands_Deinitialize+0x30>)
   1e4f0:	681b      	ldr	r3, [r3, #0]
   1e4f2:	2b00      	cmp	r3, #0
   1e4f4:	dd02      	ble.n	1e4fc <TCPIP_Commands_Deinitialize+0x10>
   1e4f6:	7f02      	ldrb	r2, [r0, #28]
   1e4f8:	2a02      	cmp	r2, #2
   1e4fa:	d000      	beq.n	1e4fe <TCPIP_Commands_Deinitialize+0x12>
}
   1e4fc:	bd08      	pop	{r3, pc}
        if(--commandInitCount == 0)
   1e4fe:	3b01      	subs	r3, #1
   1e500:	4a06      	ldr	r2, [pc, #24]	; (1e51c <TCPIP_Commands_Deinitialize+0x30>)
   1e502:	6013      	str	r3, [r2, #0]
   1e504:	2b00      	cmp	r3, #0
   1e506:	d1f9      	bne.n	1e4fc <TCPIP_Commands_Deinitialize+0x10>
            if(tcpipCmdSignalHandle != 0)
   1e508:	4b05      	ldr	r3, [pc, #20]	; (1e520 <TCPIP_Commands_Deinitialize+0x34>)
   1e50a:	6818      	ldr	r0, [r3, #0]
   1e50c:	2800      	cmp	r0, #0
   1e50e:	d0f5      	beq.n	1e4fc <TCPIP_Commands_Deinitialize+0x10>
                _TCPIPStackSignalHandlerDeregister(tcpipCmdSignalHandle);
   1e510:	f003 fb87 	bl	21c22 <_TCPIPStackSignalHandlerDeregister>
                tcpipCmdSignalHandle = 0;
   1e514:	4b02      	ldr	r3, [pc, #8]	; (1e520 <TCPIP_Commands_Deinitialize+0x34>)
   1e516:	2200      	movs	r2, #0
   1e518:	601a      	str	r2, [r3, #0]
}
   1e51a:	e7ef      	b.n	1e4fc <TCPIP_Commands_Deinitialize+0x10>
   1e51c:	2000e5b0 	.word	0x2000e5b0
   1e520:	2000e5ec 	.word	0x2000e5ec

Disassembly of section .text.TCPIP_DNS_ClientInfoGet%672:

0001e524 <TCPIP_DNS_ClientInfoGet>:
    TCPIP_DNS_DCPT* pDnsDcpt = pgDnsDcpt;
   1e524:	4b0c      	ldr	r3, [pc, #48]	; (1e558 <TCPIP_DNS_ClientInfoGet+0x34>)
   1e526:	681b      	ldr	r3, [r3, #0]
    if(pDnsDcpt==NULL)
   1e528:	b183      	cbz	r3, 1e54c <TCPIP_DNS_ClientInfoGet+0x28>
    if(pClientInfo)
   1e52a:	b190      	cbz	r0, 1e552 <TCPIP_DNS_ClientInfoGet+0x2e>
        pClientInfo->strictNet = pDnsDcpt->strictNet;
   1e52c:	685a      	ldr	r2, [r3, #4]
   1e52e:	6002      	str	r2, [r0, #0]
        pClientInfo->prefNet = pDnsDcpt->prefNet;
   1e530:	689a      	ldr	r2, [r3, #8]
   1e532:	6042      	str	r2, [r0, #4]
        pClientInfo->dnsTime = pDnsDcpt->dnsTime;
   1e534:	69da      	ldr	r2, [r3, #28]
   1e536:	6082      	str	r2, [r0, #8]
        pClientInfo->pendingEntries = pDnsDcpt->unsolvedEntries;
   1e538:	8cda      	ldrh	r2, [r3, #38]	; 0x26
   1e53a:	8182      	strh	r2, [r0, #12]
        pClientInfo->currentEntries = pDnsDcpt->hashDcpt->fullSlots;
   1e53c:	681a      	ldr	r2, [r3, #0]
   1e53e:	6a52      	ldr	r2, [r2, #36]	; 0x24
   1e540:	81c2      	strh	r2, [r0, #14]
        pClientInfo->totalEntries = pDnsDcpt->hashDcpt->hEntries;
   1e542:	681b      	ldr	r3, [r3, #0]
   1e544:	68db      	ldr	r3, [r3, #12]
   1e546:	8203      	strh	r3, [r0, #16]
    return TCPIP_DNS_RES_OK;
   1e548:	2000      	movs	r0, #0
   1e54a:	4770      	bx	lr
         return TCPIP_DNS_RES_NO_SERVICE;
   1e54c:	f06f 0005 	mvn.w	r0, #5
   1e550:	4770      	bx	lr
    return TCPIP_DNS_RES_OK;
   1e552:	2000      	movs	r0, #0
}
   1e554:	4770      	bx	lr
   1e556:	bf00      	nop
   1e558:	2000e62c 	.word	0x2000e62c

Disassembly of section .text.TCPIP_PKT_PacketMACFormat%673:

0001e55c <TCPIP_PKT_PacketMACFormat>:
    if(srcAddr)
   1e55c:	b1c2      	cbz	r2, 1e590 <TCPIP_PKT_PacketMACFormat+0x34>
{
   1e55e:	b470      	push	{r4, r5, r6}
   1e560:	4614      	mov	r4, r2
        macHdr = (TCPIP_MAC_ETHERNET_HEADER*)pPkt->pMacLayer;
   1e562:	6942      	ldr	r2, [r0, #20]
        srcHdrAdd = &macHdr->SourceMACAddr;
   1e564:	1d95      	adds	r5, r2, #6
        if(dstAddr)
   1e566:	b119      	cbz	r1, 1e570 <TCPIP_PKT_PacketMACFormat+0x14>
            memcpy(destHdrAdd, dstAddr, sizeof(*destHdrAdd));
   1e568:	680e      	ldr	r6, [r1, #0]
   1e56a:	6016      	str	r6, [r2, #0]
   1e56c:	8889      	ldrh	r1, [r1, #4]
   1e56e:	8091      	strh	r1, [r2, #4]
        memcpy(srcHdrAdd, srcAddr, sizeof(*srcHdrAdd));
   1e570:	6821      	ldr	r1, [r4, #0]
   1e572:	f8c2 1006 	str.w	r1, [r2, #6]
   1e576:	88a1      	ldrh	r1, [r4, #4]
   1e578:	80a9      	strh	r1, [r5, #4]
   1e57a:	0a19      	lsrs	r1, r3, #8
   1e57c:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
        macHdr->Type = TCPIP_Helper_htons(pktType);
   1e580:	8191      	strh	r1, [r2, #12]
        pPkt->pDSeg->segLen += sizeof(TCPIP_MAC_ETHERNET_HEADER);
   1e582:	6902      	ldr	r2, [r0, #16]
   1e584:	8993      	ldrh	r3, [r2, #12]
   1e586:	330e      	adds	r3, #14
   1e588:	8193      	strh	r3, [r2, #12]
        return true;
   1e58a:	2001      	movs	r0, #1
}
   1e58c:	bc70      	pop	{r4, r5, r6}
   1e58e:	4770      	bx	lr
    return false;
   1e590:	2000      	movs	r0, #0
}
   1e592:	4770      	bx	lr

Disassembly of section .text._UDPAllocateEphemeralPort%674:

0001e594 <_UDPAllocateEphemeralPort>:
{
   1e594:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1e596:	f7fc fb2d 	bl	1abf4 <rand>
    next_ephemeral = TCPIP_UDP_LOCAL_PORT_START_NUMBER + (SYS_RANDOM_PseudoGet() % num_ephemeral);
   1e59a:	ea6f 4080 	mvn.w	r0, r0, lsl #18
   1e59e:	ea6f 4090 	mvn.w	r0, r0, lsr #18
   1e5a2:	b284      	uxth	r4, r0
   1e5a4:	f44f 4580 	mov.w	r5, #16384	; 0x4000
        if (next_ephemeral == TCPIP_UDP_LOCAL_PORT_END_NUMBER)
   1e5a8:	f64f 76ff 	movw	r6, #65535	; 0xffff
            next_ephemeral = TCPIP_UDP_LOCAL_PORT_START_NUMBER;
   1e5ac:	f44f 4740 	mov.w	r7, #49152	; 0xc000
        if(_UDPIsAvailablePort(next_ephemeral))
   1e5b0:	4620      	mov	r0, r4
   1e5b2:	f7ff fa0f 	bl	1d9d4 <_UDPIsAvailablePort>
   1e5b6:	b938      	cbnz	r0, 1e5c8 <_UDPAllocateEphemeralPort+0x34>
        if (next_ephemeral == TCPIP_UDP_LOCAL_PORT_END_NUMBER)
   1e5b8:	42b4      	cmp	r4, r6
            next_ephemeral++;
   1e5ba:	bf1a      	itte	ne
   1e5bc:	3401      	addne	r4, #1
   1e5be:	b2a4      	uxthne	r4, r4
            next_ephemeral = TCPIP_UDP_LOCAL_PORT_START_NUMBER;
   1e5c0:	463c      	moveq	r4, r7
    while(count--)
   1e5c2:	3d01      	subs	r5, #1
   1e5c4:	d1f4      	bne.n	1e5b0 <_UDPAllocateEphemeralPort+0x1c>
    return 0;   // not found
   1e5c6:	2400      	movs	r4, #0
}
   1e5c8:	4620      	mov	r0, r4
   1e5ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.SERCOM0_SPI_Initialize%675:

0001e5cc <SERCOM0_SPI_Initialize>:
    sercom0SPIObj.callback = NULL ;
   1e5cc:	4b0b      	ldr	r3, [pc, #44]	; (1e5fc <SERCOM0_SPI_Initialize+0x30>)
   1e5ce:	2200      	movs	r2, #0
   1e5d0:	621a      	str	r2, [r3, #32]
    sercom0SPIObj.transferIsBusy = false ;
   1e5d2:	771a      	strb	r2, [r3, #28]
    sercom0SPIObj.txSize = 0U;
   1e5d4:	609a      	str	r2, [r3, #8]
    sercom0SPIObj.rxSize = 0U;
   1e5d6:	60da      	str	r2, [r3, #12]
    SERCOM0_REGS->SPIM.SERCOM_CTRLB = SERCOM_SPIM_CTRLB_CHSIZE_8_BIT | SERCOM_SPIM_CTRLB_RXEN_Msk ;
   1e5d8:	4b09      	ldr	r3, [pc, #36]	; (1e600 <SERCOM0_SPI_Initialize+0x34>)
   1e5da:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   1e5de:	605a      	str	r2, [r3, #4]
    while((SERCOM0_REGS->SPIM.SERCOM_SYNCBUSY) != 0U)
   1e5e0:	461a      	mov	r2, r3
   1e5e2:	69d3      	ldr	r3, [r2, #28]
   1e5e4:	2b00      	cmp	r3, #0
   1e5e6:	d1fc      	bne.n	1e5e2 <SERCOM0_SPI_Initialize+0x16>
    SERCOM0_REGS->SPIM.SERCOM_BAUD = (uint8_t)SERCOM_SPIM_BAUD_BAUD(SERCOM0_SPIM_BAUD_VALUE);
   1e5e8:	4b05      	ldr	r3, [pc, #20]	; (1e600 <SERCOM0_SPI_Initialize+0x34>)
   1e5ea:	221d      	movs	r2, #29
   1e5ec:	731a      	strb	r2, [r3, #12]
    SERCOM0_REGS->SPIM.SERCOM_CTRLA = SERCOM_SPIM_CTRLA_MODE_SPI_MASTER | SERCOM_SPIM_CTRLA_DOPO_PAD0 | SERCOM_SPIM_CTRLA_DIPO_PAD0 | SERCOM_SPIM_CTRLA_CPOL_IDLE_LOW | SERCOM_SPIM_CTRLA_CPHA_LEADING_EDGE | SERCOM_SPIM_CTRLA_DORD_MSB | SERCOM_SPIM_CTRLA_ENABLE_Msk ;
   1e5ee:	220e      	movs	r2, #14
   1e5f0:	601a      	str	r2, [r3, #0]
    while((SERCOM0_REGS->SPIM.SERCOM_SYNCBUSY) != 0U)
   1e5f2:	461a      	mov	r2, r3
   1e5f4:	69d3      	ldr	r3, [r2, #28]
   1e5f6:	2b00      	cmp	r3, #0
   1e5f8:	d1fc      	bne.n	1e5f4 <SERCOM0_SPI_Initialize+0x28>
}
   1e5fa:	4770      	bx	lr
   1e5fc:	2000e29c 	.word	0x2000e29c
   1e600:	40003000 	.word	0x40003000

Disassembly of section .text.SYS_CMD_Initialize%676:

0001e604 <SYS_CMD_Initialize>:
    if (initConfig == 0)
   1e604:	b190      	cbz	r0, 1e62c <SYS_CMD_Initialize+0x28>
{
   1e606:	b538      	push	{r3, r4, r5, lr}
   1e608:	4604      	mov	r4, r0
    _cmdInitData = *initConfig; // save a copy of the initialization data
   1e60a:	4d09      	ldr	r5, [pc, #36]	; (1e630 <SYS_CMD_Initialize+0x2c>)
   1e60c:	6800      	ldr	r0, [r0, #0]
   1e60e:	6028      	str	r0, [r5, #0]
    cmdIODevList.head = cmdIODevList.tail = 0;
   1e610:	4b08      	ldr	r3, [pc, #32]	; (1e634 <SYS_CMD_Initialize+0x30>)
   1e612:	2200      	movs	r2, #0
   1e614:	605a      	str	r2, [r3, #4]
   1e616:	601a      	str	r2, [r3, #0]
    SYS_CMDIO_ADD(&sysConsoleApi, &initConfig->consoleCmdIOParam, initConfig->consoleCmdIOParam);
   1e618:	4621      	mov	r1, r4
   1e61a:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   1e61e:	4806      	ldr	r0, [pc, #24]	; (1e638 <SYS_CMD_Initialize+0x34>)
   1e620:	f7fa fa0c 	bl	18a3c <SYS_CMDIO_ADD>
    _cmdInitData.consoleIndex = initConfig->consoleIndex;
   1e624:	8863      	ldrh	r3, [r4, #2]
   1e626:	806b      	strh	r3, [r5, #2]
    return true;
   1e628:	2001      	movs	r0, #1
}
   1e62a:	bd38      	pop	{r3, r4, r5, pc}
        return false;
   1e62c:	2000      	movs	r0, #0
}
   1e62e:	4770      	bx	lr
   1e630:	2000e674 	.word	0x2000e674
   1e634:	2000e560 	.word	0x2000e560
   1e638:	00021884 	.word	0x00021884

Disassembly of section .text.SYS_TIME_ResourceLock%677:

0001e63c <SYS_TIME_ResourceLock>:
{
   1e63c:	b508      	push	{r3, lr}
    if (gSystemCounterObj.interruptNestingCount == 0)
   1e63e:	4b0b      	ldr	r3, [pc, #44]	; (1e66c <SYS_TIME_ResourceLock+0x30>)
   1e640:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   1e644:	b10b      	cbz	r3, 1e64a <SYS_TIME_ResourceLock+0xe>
    return true;
   1e646:	2001      	movs	r0, #1
}
   1e648:	bd08      	pop	{r3, pc}
        if(OSAL_MUTEX_Lock(&gSystemCounterObj.timerMutex, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
   1e64a:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1e64e:	4808      	ldr	r0, [pc, #32]	; (1e670 <SYS_TIME_ResourceLock+0x34>)
   1e650:	f002 fb27 	bl	20ca2 <OSAL_MUTEX_Lock>
   1e654:	2801      	cmp	r0, #1
   1e656:	d001      	beq.n	1e65c <SYS_TIME_ResourceLock+0x20>
            return false;
   1e658:	2000      	movs	r0, #0
   1e65a:	e7f5      	b.n	1e648 <SYS_TIME_ResourceLock+0xc>
            SYS_INT_SourceDisable(gSystemCounterObj.hwTimerIntNum);
   1e65c:	4b03      	ldr	r3, [pc, #12]	; (1e66c <SYS_TIME_ResourceLock+0x30>)
   1e65e:	f9b3 0008 	ldrsh.w	r0, [r3, #8]
   1e662:	f7fe fec7 	bl	1d3f4 <SYS_INT_SourceDisable>
            return true;
   1e666:	2001      	movs	r0, #1
   1e668:	e7ee      	b.n	1e648 <SYS_TIME_ResourceLock+0xc>
   1e66a:	bf00      	nop
   1e66c:	2000e230 	.word	0x2000e230
   1e670:	2000e264 	.word	0x2000e264

Disassembly of section .rodata.TCPIP_HOSTS_CONFIGURATION%678:

0001e674 <TCPIP_HOSTS_CONFIGURATION>:
   1e674:	0001af80 0001af88 0001af94 0001afa8     ................
   1e684:	0001afb8 0001afc8 0001afc8 0001afd4     ................
   1e694:	0001afdc 00000001 0001ba3c 00000000     ........<.......
	...

Disassembly of section .text.__swrite%679:

0001e6ac <__swrite>:
   1e6ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1e6b0:	461f      	mov	r7, r3
   1e6b2:	898b      	ldrh	r3, [r1, #12]
   1e6b4:	05db      	lsls	r3, r3, #23
   1e6b6:	4605      	mov	r5, r0
   1e6b8:	460c      	mov	r4, r1
   1e6ba:	4616      	mov	r6, r2
   1e6bc:	d505      	bpl.n	1e6ca <__swrite+0x1e>
   1e6be:	2302      	movs	r3, #2
   1e6c0:	2200      	movs	r2, #0
   1e6c2:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   1e6c6:	f001 ffa9 	bl	2061c <_lseek_r>
   1e6ca:	89a3      	ldrh	r3, [r4, #12]
   1e6cc:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   1e6d0:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
   1e6d4:	81a3      	strh	r3, [r4, #12]
   1e6d6:	4632      	mov	r2, r6
   1e6d8:	463b      	mov	r3, r7
   1e6da:	4628      	mov	r0, r5
   1e6dc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1e6e0:	f001 bf78 	b.w	205d4 <_write_r>

Disassembly of section .text._DRV_ETHPHY_NegCompletePhaseRead1%680:

0001e6e4 <_DRV_ETHPHY_NegCompletePhaseRead1>:
{
   1e6e4:	b510      	push	{r4, lr}
   1e6e6:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1e6e8:	f001 ffbc 	bl	20664 <_DRV_PHY_SMITransfer_Wait>
   1e6ec:	b148      	cbz	r0, 1e702 <_DRV_ETHPHY_NegCompletePhaseRead1+0x1e>
    if(phyBMCon.AN_ENABLE == 0)
   1e6ee:	f894 303b 	ldrb.w	r3, [r4, #59]	; 0x3b
   1e6f2:	f013 0f10 	tst.w	r3, #16
   1e6f6:	d005      	beq.n	1e704 <_DRV_ETHPHY_NegCompletePhaseRead1+0x20>
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMCON))
   1e6f8:	2100      	movs	r1, #0
   1e6fa:	4620      	mov	r0, r4
   1e6fc:	f000 fb1c 	bl	1ed38 <_DRV_PHY_SMIReadStart>
   1e700:	b930      	cbnz	r0, 1e710 <_DRV_ETHPHY_NegCompletePhaseRead1+0x2c>
}
   1e702:	bd10      	pop	{r4, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_NEGOTIATION_INACTIVE);
   1e704:	f06f 0104 	mvn.w	r1, #4
   1e708:	4620      	mov	r0, r4
   1e70a:	f001 fa5b 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
        return;
   1e70e:	e7f8      	b.n	1e702 <_DRV_ETHPHY_NegCompletePhaseRead1+0x1e>
    hClientObj->operPhase = operPhase;
   1e710:	2302      	movs	r3, #2
   1e712:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1e714:	2300      	movs	r3, #0
   1e716:	8423      	strh	r3, [r4, #32]
   1e718:	e7f3      	b.n	1e702 <_DRV_ETHPHY_NegCompletePhaseRead1+0x1e>

Disassembly of section .text._TCPSetSourceAddress%681:

0001e71a <_TCPSetSourceAddress>:
    if(localAddress == 0)
   1e71a:	b1ba      	cbz	r2, 1e74c <_TCPSetSourceAddress+0x32>
{
   1e71c:	b410      	push	{r4}
   1e71e:	4614      	mov	r4, r2
    while(pSkt->addType == addType)
   1e720:	f890 306f 	ldrb.w	r3, [r0, #111]	; 0x6f
   1e724:	428b      	cmp	r3, r1
   1e726:	d003      	beq.n	1e730 <_TCPSetSourceAddress+0x16>
    return false;
   1e728:	2000      	movs	r0, #0
}
   1e72a:	f85d 4b04 	ldr.w	r4, [sp], #4
   1e72e:	4770      	bx	lr
        if (addType == IP_ADDRESS_TYPE_IPV4)
   1e730:	2901      	cmp	r1, #1
   1e732:	d001      	beq.n	1e738 <_TCPSetSourceAddress+0x1e>
    return false;
   1e734:	2000      	movs	r0, #0
   1e736:	e7f8      	b.n	1e72a <_TCPSetSourceAddress+0x10>
            pSkt->srcAddress.Val = localAddress->v4Add.Val;
   1e738:	6823      	ldr	r3, [r4, #0]
   1e73a:	63c3      	str	r3, [r0, #60]	; 0x3c
            pSkt->flags.srcSet = 1;
   1e73c:	f890 306d 	ldrb.w	r3, [r0, #109]	; 0x6d
   1e740:	f043 0310 	orr.w	r3, r3, #16
   1e744:	f880 306d 	strb.w	r3, [r0, #109]	; 0x6d
            return true;
   1e748:	2001      	movs	r0, #1
   1e74a:	e7ee      	b.n	1e72a <_TCPSetSourceAddress+0x10>
        return false;
   1e74c:	2000      	movs	r0, #0
}
   1e74e:	4770      	bx	lr

Disassembly of section .text._DNS_NetIsValid%682:

0001e750 <_DNS_NetIsValid>:
{
   1e750:	b510      	push	{r4, lr}
   1e752:	4604      	mov	r4, r0
    if(TCPIP_STACK_NetIsReady(pIf) != 0)
   1e754:	f002 fd3e 	bl	211d4 <TCPIP_STACK_NetIsReady>
   1e758:	4603      	mov	r3, r0
   1e75a:	b190      	cbz	r0, 1e782 <_DNS_NetIsValid+0x32>
        if(_TCPIPStackNetAddress(pIf) != 0)
   1e75c:	6863      	ldr	r3, [r4, #4]
   1e75e:	b17b      	cbz	r3, 1e780 <_DNS_NetIsValid+0x30>
            if(pIf->Flags.bIsDnsClientEnabled != 0)
   1e760:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   1e764:	f013 0f08 	tst.w	r3, #8
   1e768:	d101      	bne.n	1e76e <_DNS_NetIsValid+0x1e>
    return false;
   1e76a:	2300      	movs	r3, #0
   1e76c:	e009      	b.n	1e782 <_DNS_NetIsValid+0x32>
                return pIf->dnsServer[0].Val != 0 || pIf->dnsServer[1].Val != 0;
   1e76e:	6923      	ldr	r3, [r4, #16]
   1e770:	b923      	cbnz	r3, 1e77c <_DNS_NetIsValid+0x2c>
   1e772:	6963      	ldr	r3, [r4, #20]
   1e774:	3300      	adds	r3, #0
   1e776:	bf18      	it	ne
   1e778:	2301      	movne	r3, #1
   1e77a:	e002      	b.n	1e782 <_DNS_NetIsValid+0x32>
   1e77c:	2301      	movs	r3, #1
   1e77e:	e000      	b.n	1e782 <_DNS_NetIsValid+0x32>
    return false;
   1e780:	2300      	movs	r3, #0
}
   1e782:	4618      	mov	r0, r3
   1e784:	bd10      	pop	{r4, pc}

Disassembly of section .text._TCPIPStackSetConfigAddress%683:

0001e786 <_TCPIPStackSetConfigAddress>:
    if(pNetIf)
   1e786:	b1c0      	cbz	r0, 1e7ba <_TCPIPStackSetConfigAddress+0x34>
{
   1e788:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1e78a:	4604      	mov	r4, r0
   1e78c:	461f      	mov	r7, r3
   1e78e:	4615      	mov	r5, r2
   1e790:	460e      	mov	r6, r1
        OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1e792:	2000      	movs	r0, #0
   1e794:	f002 fe82 	bl	2149c <OSAL_CRIT_Enter>
   1e798:	4601      	mov	r1, r0
    if(ipAddress)
   1e79a:	b10e      	cbz	r6, 1e7a0 <_TCPIPStackSetConfigAddress+0x1a>
        pNetIf->netIPAddr.Val = ipAddress->Val;
   1e79c:	6833      	ldr	r3, [r6, #0]
   1e79e:	6063      	str	r3, [r4, #4]
    if(mask)
   1e7a0:	b10d      	cbz	r5, 1e7a6 <_TCPIPStackSetConfigAddress+0x20>
        pNetIf->netMask.Val = mask->Val;
   1e7a2:	682b      	ldr	r3, [r5, #0]
   1e7a4:	60a3      	str	r3, [r4, #8]
        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1e7a6:	2000      	movs	r0, #0
   1e7a8:	f002 ffa7 	bl	216fa <OSAL_CRIT_Leave>
    pNetIf->Flags.bInConfig = config;
   1e7ac:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
   1e7b0:	f367 1204 	bfi	r2, r7, #4, #1
   1e7b4:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
}
   1e7b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1e7ba:	4770      	bx	lr

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2%684:

0001e7bc <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2>:
{
   1e7bc:	b538      	push	{r3, r4, r5, lr}
   1e7be:	4604      	mov	r4, r0
    hDriver = hClientObj->hDriver;
   1e7c0:	68c3      	ldr	r3, [r0, #12]
    res = (*hDriver->pPhyObj->miiConfigure)(gDrvEthBaseObj, (DRV_HANDLE)hClientObj, hDriver->configFlags);
   1e7c2:	695a      	ldr	r2, [r3, #20]
   1e7c4:	6815      	ldr	r5, [r2, #0]
   1e7c6:	7b9a      	ldrb	r2, [r3, #14]
   1e7c8:	4601      	mov	r1, r0
   1e7ca:	4808      	ldr	r0, [pc, #32]	; (1e7ec <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2+0x30>)
   1e7cc:	47a8      	blx	r5
    if(res == DRV_ETHPHY_RES_OK)
   1e7ce:	b118      	cbz	r0, 1e7d8 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2+0x1c>
   1e7d0:	4601      	mov	r1, r0
    else if(res != DRV_ETHPHY_RES_PENDING)
   1e7d2:	2801      	cmp	r0, #1
   1e7d4:	d106      	bne.n	1e7e4 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2+0x28>
}
   1e7d6:	bd38      	pop	{r3, r4, r5, pc}
        hClientObj->vendorData = 0;
   1e7d8:	2300      	movs	r3, #0
   1e7da:	6423      	str	r3, [r4, #64]	; 0x40
    hClientObj->operPhase = operPhase;
   1e7dc:	2303      	movs	r3, #3
   1e7de:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1e7e0:	8423      	strh	r3, [r4, #32]
   1e7e2:	e7f8      	b.n	1e7d6 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2+0x1a>
        _DRV_PHY_SetOperDoneResult(hClientObj, res);
   1e7e4:	4620      	mov	r0, r4
   1e7e6:	f001 f9ed 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
}
   1e7ea:	e7f4      	b.n	1e7d6 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase2+0x1a>
   1e7ec:	0001b540 	.word	0x0001b540

Disassembly of section .text.DRV_PIC32CGMAC_LibClearPriorityQue%685:

0001e7f0 <DRV_PIC32CGMAC_LibClearPriorityQue>:
{
   1e7f0:	b570      	push	{r4, r5, r6, lr}
   1e7f2:	4604      	mov	r4, r0
   1e7f4:	460e      	mov	r6, r1
    intStat = SYS_INT_SourceDisable(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc);
   1e7f6:	f9b0 00b6 	ldrsh.w	r0, [r0, #182]	; 0xb6
   1e7fa:	f7fe fdfb 	bl	1d3f4 <SYS_INT_SourceDisable>
   1e7fe:	4601      	mov	r1, r0
    drvGmacQueEvents &= ~(1<<queueIdx);
   1e800:	4d07      	ldr	r5, [pc, #28]	; (1e820 <DRV_PIC32CGMAC_LibClearPriorityQue+0x30>)
   1e802:	2301      	movs	r3, #1
   1e804:	fa03 f206 	lsl.w	r2, r3, r6
   1e808:	682b      	ldr	r3, [r5, #0]
   1e80a:	ea23 0302 	bic.w	r3, r3, r2
   1e80e:	602b      	str	r3, [r5, #0]
  __ASM volatile ("dmb 0xF":::"memory");
   1e810:	f3bf 8f5f 	dmb	sy
    SYS_INT_SourceRestore(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc, intStat);
   1e814:	f9b4 00b6 	ldrsh.w	r0, [r4, #182]	; 0xb6
   1e818:	f002 f93a 	bl	20a90 <SYS_INT_SourceRestore>
}
   1e81c:	bd70      	pop	{r4, r5, r6, pc}
   1e81e:	bf00      	nop
   1e820:	2000e578 	.word	0x2000e578

Disassembly of section .text._TCP_SktFlagsGet%686:

0001e824 <_TCP_SktFlagsGet>:
    return (pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1 || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2 || pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT);
   1e824:	f890 206e 	ldrb.w	r2, [r0, #110]	; 0x6e
   1e828:	1ed3      	subs	r3, r2, #3
   1e82a:	b2db      	uxtb	r3, r3
   1e82c:	2b02      	cmp	r3, #2
   1e82e:	d911      	bls.n	1e854 <_TCP_SktFlagsGet+0x30>
        flags |= TCP_SOCKET_FLAG_CONNECTED;
   1e830:	2a08      	cmp	r2, #8
   1e832:	bf14      	ite	ne
   1e834:	2301      	movne	r3, #1
   1e836:	2303      	moveq	r3, #3
    if(pSkt->Flags.bSocketReset)
   1e838:	f890 2037 	ldrb.w	r2, [r0, #55]	; 0x37
   1e83c:	f012 0f02 	tst.w	r2, #2
        flags |= TCP_SOCKET_FLAG_RST;
   1e840:	bf18      	it	ne
   1e842:	f043 0304 	orrne.w	r3, r3, #4
    if(pSkt->Flags.bRxFin)
   1e846:	f012 0f04 	tst.w	r2, #4
        flags |= TCP_SOCKET_FLAG_FIN;
   1e84a:	bf18      	it	ne
   1e84c:	f043 0308 	orrne.w	r3, r3, #8
}
   1e850:	4618      	mov	r0, r3
   1e852:	4770      	bx	lr
        flags |= TCP_SOCKET_FLAG_CONNECTED;
   1e854:	2303      	movs	r3, #3
   1e856:	e7ef      	b.n	1e838 <_TCP_SktFlagsGet+0x14>

Disassembly of section .text._ARPSetEntry%687:

0001e858 <_ARPSetEntry>:
{
   1e858:	b538      	push	{r3, r4, r5, lr}
   1e85a:	4604      	mov	r4, r0
    arpHE->hEntry.flags.value &= ~ARP_FLAG_ENTRY_VALID_MASK;
   1e85c:	8805      	ldrh	r5, [r0, #0]
   1e85e:	f025 05c0 	bic.w	r5, r5, #192	; 0xc0
    arpHE->hEntry.flags.value |= newFlags;
   1e862:	4329      	orrs	r1, r5
   1e864:	8001      	strh	r1, [r0, #0]
    if(hwAdd)
   1e866:	b11a      	cbz	r2, 1e870 <_ARPSetEntry+0x18>
        arpHE->hwAdd = *hwAdd;
   1e868:	6810      	ldr	r0, [r2, #0]
   1e86a:	6120      	str	r0, [r4, #16]
   1e86c:	8892      	ldrh	r2, [r2, #4]
   1e86e:	82a2      	strh	r2, [r4, #20]
    arpHE->tInsert = arpMod.timeSeconds;
   1e870:	4a05      	ldr	r2, [pc, #20]	; (1e888 <_ARPSetEntry+0x30>)
   1e872:	6952      	ldr	r2, [r2, #20]
   1e874:	60e2      	str	r2, [r4, #12]
    arpHE->nRetries = 1;
   1e876:	2201      	movs	r2, #1
   1e878:	82e2      	strh	r2, [r4, #22]
    if(addList)
   1e87a:	b11b      	cbz	r3, 1e884 <_ARPSetEntry+0x2c>
   1e87c:	4618      	mov	r0, r3
        TCPIP_Helper_ProtectedSingleListTailAdd(addList, (SGL_LIST_NODE*)&arpHE->next);
   1e87e:	1d21      	adds	r1, r4, #4
   1e880:	f001 f939 	bl	1faf6 <TCPIP_Helper_ProtectedSingleListTailAdd>
}
   1e884:	bd38      	pop	{r3, r4, r5, pc}
   1e886:	bf00      	nop
   1e888:	2000e1a4 	.word	0x2000e1a4

Disassembly of section .text.TCPIP_ARP_HandlerRegister%688:

0001e88c <TCPIP_ARP_HandlerRegister>:
    if(handler && arpMod.memH)
   1e88c:	b181      	cbz	r1, 1e8b0 <TCPIP_ARP_HandlerRegister+0x24>
   1e88e:	460b      	mov	r3, r1
   1e890:	4909      	ldr	r1, [pc, #36]	; (1e8b8 <TCPIP_ARP_HandlerRegister+0x2c>)
   1e892:	6889      	ldr	r1, [r1, #8]
   1e894:	b169      	cbz	r1, 1e8b2 <TCPIP_ARP_HandlerRegister+0x26>
{
   1e896:	b500      	push	{lr}
   1e898:	b085      	sub	sp, #20
        arpNode.handler = handler;
   1e89a:	9301      	str	r3, [sp, #4]
        arpNode.hParam = hParam;
   1e89c:	9202      	str	r2, [sp, #8]
        arpNode.hNet = hNet;
   1e89e:	9003      	str	r0, [sp, #12]
        return (ARP_LIST_NODE*)TCPIP_Notification_Add(&arpMod.registeredUsers, arpMod.memH, &arpNode, sizeof(arpNode));
   1e8a0:	2310      	movs	r3, #16
   1e8a2:	466a      	mov	r2, sp
   1e8a4:	4805      	ldr	r0, [pc, #20]	; (1e8bc <TCPIP_ARP_HandlerRegister+0x30>)
   1e8a6:	f001 f950 	bl	1fb4a <TCPIP_Notification_Add>
}
   1e8aa:	b005      	add	sp, #20
   1e8ac:	f85d fb04 	ldr.w	pc, [sp], #4
    return 0;
   1e8b0:	2100      	movs	r1, #0
}
   1e8b2:	4608      	mov	r0, r1
   1e8b4:	4770      	bx	lr
   1e8b6:	bf00      	nop
   1e8b8:	2000e1a4 	.word	0x2000e1a4
   1e8bc:	2000e1c4 	.word	0x2000e1c4

Disassembly of section .text.TCPIP_DHCP_HandlerRegister%689:

0001e8c0 <TCPIP_DHCP_HandlerRegister>:
    if(handler && dhcpMemH)
   1e8c0:	b181      	cbz	r1, 1e8e4 <TCPIP_DHCP_HandlerRegister+0x24>
   1e8c2:	460b      	mov	r3, r1
   1e8c4:	4909      	ldr	r1, [pc, #36]	; (1e8ec <TCPIP_DHCP_HandlerRegister+0x2c>)
   1e8c6:	6809      	ldr	r1, [r1, #0]
   1e8c8:	b169      	cbz	r1, 1e8e6 <TCPIP_DHCP_HandlerRegister+0x26>
{
   1e8ca:	b500      	push	{lr}
   1e8cc:	b085      	sub	sp, #20
        dhcpNode.handler = handler;
   1e8ce:	9301      	str	r3, [sp, #4]
        dhcpNode.hParam = hParam;
   1e8d0:	9202      	str	r2, [sp, #8]
        dhcpNode.hNet = hNet;
   1e8d2:	9003      	str	r0, [sp, #12]
        return (TCPIP_DHCP_LIST_NODE*)TCPIP_Notification_Add(&dhcpRegisteredUsers, dhcpMemH, &dhcpNode, sizeof(dhcpNode));
   1e8d4:	2310      	movs	r3, #16
   1e8d6:	466a      	mov	r2, sp
   1e8d8:	4805      	ldr	r0, [pc, #20]	; (1e8f0 <TCPIP_DHCP_HandlerRegister+0x30>)
   1e8da:	f001 f936 	bl	1fb4a <TCPIP_Notification_Add>
}
   1e8de:	b005      	add	sp, #20
   1e8e0:	f85d fb04 	ldr.w	pc, [sp], #4
    return 0;
   1e8e4:	2100      	movs	r1, #0
}
   1e8e6:	4608      	mov	r0, r1
   1e8e8:	4770      	bx	lr
   1e8ea:	bf00      	nop
   1e8ec:	2000e61c 	.word	0x2000e61c
   1e8f0:	2000e450 	.word	0x2000e450

Disassembly of section .rodata%690:

0001e8f4 <.rodata%690>:
   1e8f4:	50434844 	.word	0x50434844
   1e8f8:	6146203a 	.word	0x6146203a
   1e8fc:	64656c69 	.word	0x64656c69
   1e900:	206f7420 	.word	0x206f7420
   1e904:	69676572 	.word	0x69676572
   1e908:	72657473 	.word	0x72657473
   1e90c:	76504920 	.word	0x76504920
   1e910:	69662034 	.word	0x69662034
   1e914:	7265746c 	.word	0x7265746c
   1e918:	0a0d2021 	.word	0x0a0d2021
   1e91c:	00000000 	.word	0x00000000
   1e920:	ffffffff 	.word	0xffffffff
   1e924:	ffff      	.short	0xffff
   1e926:	bf00      	nop

Disassembly of section .text._DNSGetData%691:

0001e928 <_DNSGetData>:
{
   1e928:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1e92a:	4605      	mov	r5, r0
   1e92c:	4616      	mov	r6, r2
    size_t avlblBytes = srcBuff->endPtr - srcBuff->rdPtr;
   1e92e:	6843      	ldr	r3, [r0, #4]
   1e930:	6884      	ldr	r4, [r0, #8]
   1e932:	1ae4      	subs	r4, r4, r3
    if(copyBytes > avlblBytes)
   1e934:	4627      	mov	r7, r4
   1e936:	4294      	cmp	r4, r2
   1e938:	bf28      	it	cs
   1e93a:	4617      	movcs	r7, r2
    if(destBuff && copyBytes)
   1e93c:	4608      	mov	r0, r1
   1e93e:	b101      	cbz	r1, 1e942 <_DNSGetData+0x1a>
   1e940:	b93f      	cbnz	r7, 1e952 <_DNSGetData+0x2a>
    srcBuff->rdPtr += copyBytes;
   1e942:	686a      	ldr	r2, [r5, #4]
   1e944:	443a      	add	r2, r7
   1e946:	606a      	str	r2, [r5, #4]
}
   1e948:	42b4      	cmp	r4, r6
   1e94a:	bf34      	ite	cc
   1e94c:	2000      	movcc	r0, #0
   1e94e:	2001      	movcs	r0, #1
   1e950:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        memcpy(destBuff, srcBuff->rdPtr, copyBytes);
   1e952:	463a      	mov	r2, r7
   1e954:	4619      	mov	r1, r3
   1e956:	f002 fb83 	bl	21060 <memcpy>
   1e95a:	e7f2      	b.n	1e942 <_DNSGetData+0x1a>

Disassembly of section .text.TCPIP_STACK_NetDown%692:

0001e95c <TCPIP_STACK_NetDown>:
    if(pDownIf)
   1e95c:	b1a0      	cbz	r0, 1e988 <TCPIP_STACK_NetDown+0x2c>
{
   1e95e:	b510      	push	{r4, lr}
   1e960:	4604      	mov	r4, r0
        if(pDownIf->Flags.bInterfaceEnabled || pDownIf->Flags.bMacInitialize)
   1e962:	f8b0 3042 	ldrh.w	r3, [r0, #66]	; 0x42
   1e966:	f244 0240 	movw	r2, #16448	; 0x4040
   1e96a:	421a      	tst	r2, r3
   1e96c:	d101      	bne.n	1e972 <TCPIP_STACK_NetDown+0x16>
        return true;
   1e96e:	2001      	movs	r0, #1
}
   1e970:	bd10      	pop	{r4, pc}
            TCPIP_STACK_BringNetDown(&tcpip_stack_ctrl_data, pDownIf, TCPIP_STACK_ACTION_IF_DOWN, TCPIP_MAC_POWER_DOWN);
   1e972:	2303      	movs	r3, #3
   1e974:	2204      	movs	r2, #4
   1e976:	4601      	mov	r1, r0
   1e978:	4804      	ldr	r0, [pc, #16]	; (1e98c <TCPIP_STACK_NetDown+0x30>)
   1e97a:	f7fc fa9d 	bl	1aeb8 <TCPIP_STACK_BringNetDown>
            _TCPIP_SelectDefaultNet(pDownIf);
   1e97e:	4620      	mov	r0, r4
   1e980:	f7fc fd1e 	bl	1b3c0 <_TCPIP_SelectDefaultNet>
        return true;
   1e984:	2001      	movs	r0, #1
   1e986:	e7f3      	b.n	1e970 <TCPIP_STACK_NetDown+0x14>
    return false;
   1e988:	2000      	movs	r0, #0
}
   1e98a:	4770      	bx	lr
   1e98c:	2000e2f0 	.word	0x2000e2f0

Disassembly of section .text.TCPIP_UDP_RxOffsetSet%693:

0001e990 <TCPIP_UDP_RxOffsetSet>:
{
   1e990:	b538      	push	{r3, r4, r5, lr}
   1e992:	4604      	mov	r4, r0
   1e994:	460d      	mov	r5, r1
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1e996:	f001 faa5 	bl	1fee4 <_UDPSocketDcpt>
    if(pSkt && pSkt->pCurrRxPkt != 0)
   1e99a:	b190      	cbz	r0, 1e9c2 <TCPIP_UDP_RxOffsetSet+0x32>
   1e99c:	4603      	mov	r3, r0
   1e99e:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   1e9a0:	b17a      	cbz	r2, 1e9c2 <TCPIP_UDP_RxOffsetSet+0x32>
        UDP_HEADER* pUDPHdr = (UDP_HEADER*)pRxPkt->pTransportLayer;
   1e9a2:	69d0      	ldr	r0, [r2, #28]
        pSkt->pCurrRxSeg = pRxPkt->pDSeg;
   1e9a4:	6911      	ldr	r1, [r2, #16]
   1e9a6:	6319      	str	r1, [r3, #48]	; 0x30
        pSkt->rxSegLen = pRxPkt->pDSeg->segLen - sizeof(UDP_HEADER);
   1e9a8:	8989      	ldrh	r1, [r1, #12]
   1e9aa:	3908      	subs	r1, #8
   1e9ac:	8699      	strh	r1, [r3, #52]	; 0x34
        pSkt->rxTotLen = pUDPHdr->Length;  
   1e9ae:	8881      	ldrh	r1, [r0, #4]
   1e9b0:	86d9      	strh	r1, [r3, #54]	; 0x36
        pSkt->rxCurr = pRxPkt->pTransportLayer + sizeof(UDP_HEADER);
   1e9b2:	69d2      	ldr	r2, [r2, #28]
   1e9b4:	3208      	adds	r2, #8
   1e9b6:	639a      	str	r2, [r3, #56]	; 0x38
        TCPIP_UDP_ArrayGet(s, 0, wOffset);
   1e9b8:	462a      	mov	r2, r5
   1e9ba:	2100      	movs	r1, #0
   1e9bc:	4620      	mov	r0, r4
   1e9be:	f7f6 fa51 	bl	14e64 <TCPIP_UDP_ArrayGet>
}
   1e9c2:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.CommandQuit%694:

0001e9c4 <CommandQuit>:
{
   1e9c4:	b510      	push	{r4, lr}
    (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** Quitting the Command Processor. Bye ***\r\n" );
   1e9c6:	6803      	ldr	r3, [r0, #0]
   1e9c8:	681b      	ldr	r3, [r3, #0]
   1e9ca:	4908      	ldr	r1, [pc, #32]	; (1e9ec <CommandQuit+0x28>)
   1e9cc:	6840      	ldr	r0, [r0, #4]
   1e9ce:	4798      	blx	r3
    memset(_usrCmdTbl, 0x0, sizeof(_usrCmdTbl));
   1e9d0:	2280      	movs	r2, #128	; 0x80
   1e9d2:	2100      	movs	r1, #0
   1e9d4:	4806      	ldr	r0, [pc, #24]	; (1e9f0 <CommandQuit+0x2c>)
   1e9d6:	f003 f8d1 	bl	21b7c <memset>
    while((pCmdIoNode = cmdIODevList.head) != NULL)
   1e9da:	4b06      	ldr	r3, [pc, #24]	; (1e9f4 <CommandQuit+0x30>)
   1e9dc:	681c      	ldr	r4, [r3, #0]
   1e9de:	b11c      	cbz	r4, 1e9e8 <CommandQuit+0x24>
        free(pCmdIoNode);
   1e9e0:	4620      	mov	r0, r4
   1e9e2:	f003 f8c3 	bl	21b6c <free>
   1e9e6:	e7fb      	b.n	1e9e0 <CommandQuit+0x1c>
}
   1e9e8:	bd10      	pop	{r4, pc}
   1e9ea:	bf00      	nop
   1e9ec:	0000d1c4 	.word	0x0000d1c4
   1e9f0:	2000df98 	.word	0x2000df98
   1e9f4:	2000e560 	.word	0x2000e560

Disassembly of section .text.Console_UART_WriteCountGet%695:

0001e9f8 <Console_UART_WriteCountGet>:

    return nFreeBufferAvailable;
}

ssize_t Console_UART_WriteCountGet(uint32_t index)
{
   1e9f8:	b538      	push	{r3, r4, r5, lr}
    ssize_t nPendingTxBytes = 0;

    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   1e9fa:	b970      	cbnz	r0, 1ea1a <Console_UART_WriteCountGet+0x22>
    if (pConsoleUartData == NULL)
    {
        return -1;
    }

    if (Console_UART_ResourceLock(pConsoleUartData) == false)
   1e9fc:	480a      	ldr	r0, [pc, #40]	; (1ea28 <Console_UART_WriteCountGet+0x30>)
   1e9fe:	f002 ff4b 	bl	21898 <Console_UART_ResourceLock>
   1ea02:	b168      	cbz	r0, 1ea20 <Console_UART_WriteCountGet+0x28>
    {
        return -1;
    }

    nPendingTxBytes = pConsoleUartData->uartPLIB->writeCountGet();
   1ea04:	4c08      	ldr	r4, [pc, #32]	; (1ea28 <Console_UART_WriteCountGet+0x30>)
   1ea06:	f854 3b08 	ldr.w	r3, [r4], #8
   1ea0a:	691b      	ldr	r3, [r3, #16]
   1ea0c:	4798      	blx	r3
   1ea0e:	4605      	mov	r5, r0
    OSAL_MUTEX_Unlock(&(pConsoleUartData->mutexTransferObjects));
   1ea10:	4620      	mov	r0, r4
   1ea12:	f002 fd67 	bl	214e4 <OSAL_MUTEX_Unlock>

    Console_UART_ResourceUnlock(pConsoleUartData);

    return nPendingTxBytes;
}
   1ea16:	4628      	mov	r0, r5
   1ea18:	bd38      	pop	{r3, r4, r5, pc}
        return -1;
   1ea1a:	f04f 35ff 	mov.w	r5, #4294967295
   1ea1e:	e7fa      	b.n	1ea16 <Console_UART_WriteCountGet+0x1e>
        return -1;
   1ea20:	f04f 35ff 	mov.w	r5, #4294967295
   1ea24:	e7f7      	b.n	1ea16 <Console_UART_WriteCountGet+0x1e>
   1ea26:	bf00      	nop
   1ea28:	2000e534 	.word	0x2000e534

Disassembly of section .text.Console_UART_WriteFreeBufferCountGet%696:

0001ea2c <Console_UART_WriteFreeBufferCountGet>:
{
   1ea2c:	b538      	push	{r3, r4, r5, lr}
    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   1ea2e:	b970      	cbnz	r0, 1ea4e <Console_UART_WriteFreeBufferCountGet+0x22>
    if (Console_UART_ResourceLock(pConsoleUartData) == false)
   1ea30:	480a      	ldr	r0, [pc, #40]	; (1ea5c <Console_UART_WriteFreeBufferCountGet+0x30>)
   1ea32:	f002 ff31 	bl	21898 <Console_UART_ResourceLock>
   1ea36:	b168      	cbz	r0, 1ea54 <Console_UART_WriteFreeBufferCountGet+0x28>
    nFreeBufferAvailable = pConsoleUartData->uartPLIB->writeFreeBufferCountGet();
   1ea38:	4c08      	ldr	r4, [pc, #32]	; (1ea5c <Console_UART_WriteFreeBufferCountGet+0x30>)
   1ea3a:	f854 3b08 	ldr.w	r3, [r4], #8
   1ea3e:	695b      	ldr	r3, [r3, #20]
   1ea40:	4798      	blx	r3
   1ea42:	4605      	mov	r5, r0
    OSAL_MUTEX_Unlock(&(pConsoleUartData->mutexTransferObjects));
   1ea44:	4620      	mov	r0, r4
   1ea46:	f002 fd4d 	bl	214e4 <OSAL_MUTEX_Unlock>
}
   1ea4a:	4628      	mov	r0, r5
   1ea4c:	bd38      	pop	{r3, r4, r5, pc}
        return -1;
   1ea4e:	f04f 35ff 	mov.w	r5, #4294967295
   1ea52:	e7fa      	b.n	1ea4a <Console_UART_WriteFreeBufferCountGet+0x1e>
        return -1;
   1ea54:	f04f 35ff 	mov.w	r5, #4294967295
   1ea58:	e7f7      	b.n	1ea4a <Console_UART_WriteFreeBufferCountGet+0x1e>
   1ea5a:	bf00      	nop
   1ea5c:	2000e534 	.word	0x2000e534

Disassembly of section .text.Console_UART_ReadFreeBufferCountGet%697:

0001ea60 <Console_UART_ReadFreeBufferCountGet>:
{
   1ea60:	b538      	push	{r3, r4, r5, lr}
    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   1ea62:	b970      	cbnz	r0, 1ea82 <Console_UART_ReadFreeBufferCountGet+0x22>
    if (Console_UART_ResourceLock(pConsoleUartData) == false)
   1ea64:	480a      	ldr	r0, [pc, #40]	; (1ea90 <Console_UART_ReadFreeBufferCountGet+0x30>)
   1ea66:	f002 ff17 	bl	21898 <Console_UART_ResourceLock>
   1ea6a:	b168      	cbz	r0, 1ea88 <Console_UART_ReadFreeBufferCountGet+0x28>
    nFreeBufferAvailable = pConsoleUartData->uartPLIB->readFreeBufferCountGet();
   1ea6c:	4c08      	ldr	r4, [pc, #32]	; (1ea90 <Console_UART_ReadFreeBufferCountGet+0x30>)
   1ea6e:	f854 3b08 	ldr.w	r3, [r4], #8
   1ea72:	689b      	ldr	r3, [r3, #8]
   1ea74:	4798      	blx	r3
   1ea76:	4605      	mov	r5, r0
    OSAL_MUTEX_Unlock(&(pConsoleUartData->mutexTransferObjects));
   1ea78:	4620      	mov	r0, r4
   1ea7a:	f002 fd33 	bl	214e4 <OSAL_MUTEX_Unlock>
}
   1ea7e:	4628      	mov	r0, r5
   1ea80:	bd38      	pop	{r3, r4, r5, pc}
        return -1;
   1ea82:	f04f 35ff 	mov.w	r5, #4294967295
   1ea86:	e7fa      	b.n	1ea7e <Console_UART_ReadFreeBufferCountGet+0x1e>
        return -1;
   1ea88:	f04f 35ff 	mov.w	r5, #4294967295
   1ea8c:	e7f7      	b.n	1ea7e <Console_UART_ReadFreeBufferCountGet+0x1e>
   1ea8e:	bf00      	nop
   1ea90:	2000e534 	.word	0x2000e534

Disassembly of section .text.Console_UART_ReadCountGet%698:

0001ea94 <Console_UART_ReadCountGet>:
{
   1ea94:	b538      	push	{r3, r4, r5, lr}
    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   1ea96:	b970      	cbnz	r0, 1eab6 <Console_UART_ReadCountGet+0x22>
    if (Console_UART_ResourceLock(pConsoleUartData) == false)
   1ea98:	480a      	ldr	r0, [pc, #40]	; (1eac4 <Console_UART_ReadCountGet+0x30>)
   1ea9a:	f002 fefd 	bl	21898 <Console_UART_ResourceLock>
   1ea9e:	b168      	cbz	r0, 1eabc <Console_UART_ReadCountGet+0x28>
    nUnreadBytesAvailable = pConsoleUartData->uartPLIB->readCountGet();
   1eaa0:	4c08      	ldr	r4, [pc, #32]	; (1eac4 <Console_UART_ReadCountGet+0x30>)
   1eaa2:	f854 3b08 	ldr.w	r3, [r4], #8
   1eaa6:	685b      	ldr	r3, [r3, #4]
   1eaa8:	4798      	blx	r3
   1eaaa:	4605      	mov	r5, r0
    OSAL_MUTEX_Unlock(&(pConsoleUartData->mutexTransferObjects));
   1eaac:	4620      	mov	r0, r4
   1eaae:	f002 fd19 	bl	214e4 <OSAL_MUTEX_Unlock>
}
   1eab2:	4628      	mov	r0, r5
   1eab4:	bd38      	pop	{r3, r4, r5, pc}
        return -1;
   1eab6:	f04f 35ff 	mov.w	r5, #4294967295
   1eaba:	e7fa      	b.n	1eab2 <Console_UART_ReadCountGet+0x1e>
        return -1;
   1eabc:	f04f 35ff 	mov.w	r5, #4294967295
   1eac0:	e7f7      	b.n	1eab2 <Console_UART_ReadCountGet+0x1e>
   1eac2:	bf00      	nop
   1eac4:	2000e534 	.word	0x2000e534

Disassembly of section .text.SYS_CONSOLE_Read%699:

0001eac8 <SYS_CONSOLE_Read>:
    SYS_CONSOLE_OBJECT_INSTANCE* pConsoleObj = SYS_CONSOLE_GET_INSTANCE(handle);
   1eac8:	b960      	cbnz	r0, 1eae4 <SYS_CONSOLE_Read+0x1c>
{
   1eaca:	b508      	push	{r3, lr}
        if (pConsoleObj->status == SYS_STATUS_UNINITIALIZED || pConsoleObj->devDesc == NULL)
   1eacc:	4b0a      	ldr	r3, [pc, #40]	; (1eaf8 <SYS_CONSOLE_Read+0x30>)
   1eace:	f993 3000 	ldrsb.w	r3, [r3]
   1ead2:	b153      	cbz	r3, 1eaea <SYS_CONSOLE_Read+0x22>
   1ead4:	4b08      	ldr	r3, [pc, #32]	; (1eaf8 <SYS_CONSOLE_Read+0x30>)
   1ead6:	685b      	ldr	r3, [r3, #4]
   1ead8:	b153      	cbz	r3, 1eaf0 <SYS_CONSOLE_Read+0x28>
        return pConsoleObj->devDesc->read(pConsoleObj->devIndex, buf, count);
   1eada:	689b      	ldr	r3, [r3, #8]
   1eadc:	4806      	ldr	r0, [pc, #24]	; (1eaf8 <SYS_CONSOLE_Read+0x30>)
   1eade:	6880      	ldr	r0, [r0, #8]
   1eae0:	4798      	blx	r3
}
   1eae2:	bd08      	pop	{r3, pc}
        return -1;
   1eae4:	f04f 30ff 	mov.w	r0, #4294967295
}
   1eae8:	4770      	bx	lr
            return -1;
   1eaea:	f04f 30ff 	mov.w	r0, #4294967295
   1eaee:	e7f8      	b.n	1eae2 <SYS_CONSOLE_Read+0x1a>
   1eaf0:	f04f 30ff 	mov.w	r0, #4294967295
   1eaf4:	e7f5      	b.n	1eae2 <SYS_CONSOLE_Read+0x1a>
   1eaf6:	bf00      	nop
   1eaf8:	2000e540 	.word	0x2000e540

Disassembly of section .text.SYS_CONSOLE_ReadCountGet%700:

0001eafc <SYS_CONSOLE_ReadCountGet>:
    SYS_CONSOLE_OBJECT_INSTANCE* pConsoleObj = SYS_CONSOLE_GET_INSTANCE(handle);
   1eafc:	b960      	cbnz	r0, 1eb18 <SYS_CONSOLE_ReadCountGet+0x1c>
{
   1eafe:	b508      	push	{r3, lr}
        if (pConsoleObj->status == SYS_STATUS_UNINITIALIZED || pConsoleObj->devDesc == NULL)
   1eb00:	4b0a      	ldr	r3, [pc, #40]	; (1eb2c <SYS_CONSOLE_ReadCountGet+0x30>)
   1eb02:	f993 3000 	ldrsb.w	r3, [r3]
   1eb06:	b153      	cbz	r3, 1eb1e <SYS_CONSOLE_ReadCountGet+0x22>
   1eb08:	4b08      	ldr	r3, [pc, #32]	; (1eb2c <SYS_CONSOLE_ReadCountGet+0x30>)
   1eb0a:	685b      	ldr	r3, [r3, #4]
   1eb0c:	b153      	cbz	r3, 1eb24 <SYS_CONSOLE_ReadCountGet+0x28>
        return pConsoleObj->devDesc->readCountGet(pConsoleObj->devIndex);
   1eb0e:	68db      	ldr	r3, [r3, #12]
   1eb10:	4a06      	ldr	r2, [pc, #24]	; (1eb2c <SYS_CONSOLE_ReadCountGet+0x30>)
   1eb12:	6890      	ldr	r0, [r2, #8]
   1eb14:	4798      	blx	r3
}
   1eb16:	bd08      	pop	{r3, pc}
        return -1;
   1eb18:	f04f 30ff 	mov.w	r0, #4294967295
}
   1eb1c:	4770      	bx	lr
            return -1;
   1eb1e:	f04f 30ff 	mov.w	r0, #4294967295
   1eb22:	e7f8      	b.n	1eb16 <SYS_CONSOLE_ReadCountGet+0x1a>
   1eb24:	f04f 30ff 	mov.w	r0, #4294967295
   1eb28:	e7f5      	b.n	1eb16 <SYS_CONSOLE_ReadCountGet+0x1a>
   1eb2a:	bf00      	nop
   1eb2c:	2000e540 	.word	0x2000e540

Disassembly of section .text.SYS_CONSOLE_Write%701:

0001eb30 <SYS_CONSOLE_Write>:
    SYS_CONSOLE_OBJECT_INSTANCE* pConsoleObj = SYS_CONSOLE_GET_INSTANCE(handle);
   1eb30:	b960      	cbnz	r0, 1eb4c <SYS_CONSOLE_Write+0x1c>
{
   1eb32:	b508      	push	{r3, lr}
        if (pConsoleObj->status == SYS_STATUS_UNINITIALIZED || pConsoleObj->devDesc == NULL)
   1eb34:	4b0a      	ldr	r3, [pc, #40]	; (1eb60 <SYS_CONSOLE_Write+0x30>)
   1eb36:	f993 3000 	ldrsb.w	r3, [r3]
   1eb3a:	b153      	cbz	r3, 1eb52 <SYS_CONSOLE_Write+0x22>
   1eb3c:	4b08      	ldr	r3, [pc, #32]	; (1eb60 <SYS_CONSOLE_Write+0x30>)
   1eb3e:	685b      	ldr	r3, [r3, #4]
   1eb40:	b153      	cbz	r3, 1eb58 <SYS_CONSOLE_Write+0x28>
        return pConsoleObj->devDesc->write(pConsoleObj->devIndex, buf, count);
   1eb42:	695b      	ldr	r3, [r3, #20]
   1eb44:	4806      	ldr	r0, [pc, #24]	; (1eb60 <SYS_CONSOLE_Write+0x30>)
   1eb46:	6880      	ldr	r0, [r0, #8]
   1eb48:	4798      	blx	r3
}
   1eb4a:	bd08      	pop	{r3, pc}
        return -1;
   1eb4c:	f04f 30ff 	mov.w	r0, #4294967295
}
   1eb50:	4770      	bx	lr
            return -1;
   1eb52:	f04f 30ff 	mov.w	r0, #4294967295
   1eb56:	e7f8      	b.n	1eb4a <SYS_CONSOLE_Write+0x1a>
   1eb58:	f04f 30ff 	mov.w	r0, #4294967295
   1eb5c:	e7f5      	b.n	1eb4a <SYS_CONSOLE_Write+0x1a>
   1eb5e:	bf00      	nop
   1eb60:	2000e540 	.word	0x2000e540

Disassembly of section .rodata.tcpipMACPIC32CINTInitData%702:

0001eb64 <tcpipMACPIC32CINTInitData>:
   1eb64:	00000000 00080000 00020008 00020001     ................
   1eb74:	06000008 01010600 041401f4 42000800     ...............B
   1eb84:	0001b540 00020ad0 00010000 00000001     @...............
   1eb94:	00000000                                ....

Disassembly of section .text.vListInsert%703:

0001eb98 <vListInsert>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   1eb98:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
   1eb9a:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
   1eb9c:	f1b5 3fff 	cmp.w	r5, #4294967295
   1eba0:	d002      	beq.n	1eba8 <vListInsert+0x10>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
   1eba2:	f100 0208 	add.w	r2, r0, #8
   1eba6:	e002      	b.n	1ebae <vListInsert+0x16>
		pxIterator = pxList->xListEnd.pxPrevious;
   1eba8:	6902      	ldr	r2, [r0, #16]
   1ebaa:	e004      	b.n	1ebb6 <vListInsert+0x1e>
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
   1ebac:	461a      	mov	r2, r3
   1ebae:	6853      	ldr	r3, [r2, #4]
   1ebb0:	681c      	ldr	r4, [r3, #0]
   1ebb2:	42ac      	cmp	r4, r5
   1ebb4:	d9fa      	bls.n	1ebac <vListInsert+0x14>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
   1ebb6:	6853      	ldr	r3, [r2, #4]
   1ebb8:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
   1ebba:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
   1ebbc:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
   1ebbe:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
   1ebc0:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
   1ebc2:	6803      	ldr	r3, [r0, #0]
   1ebc4:	3301      	adds	r3, #1
   1ebc6:	6003      	str	r3, [r0, #0]
}
   1ebc8:	bc30      	pop	{r4, r5}
   1ebca:	4770      	bx	lr

Disassembly of section .text.vTaskDelay%704:

0001ebcc <vTaskDelay>:
	{
   1ebcc:	b510      	push	{r4, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
   1ebce:	b940      	cbnz	r0, 1ebe2 <vTaskDelay+0x16>
			portYIELD_WITHIN_API();
   1ebd0:	4b0a      	ldr	r3, [pc, #40]	; (1ebfc <vTaskDelay+0x30>)
   1ebd2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1ebd6:	601a      	str	r2, [r3, #0]
   1ebd8:	f3bf 8f4f 	dsb	sy
   1ebdc:	f3bf 8f6f 	isb	sy
	}
   1ebe0:	bd10      	pop	{r4, pc}
   1ebe2:	4604      	mov	r4, r0
			vTaskSuspendAll();
   1ebe4:	f002 ff9a 	bl	21b1c <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
   1ebe8:	2100      	movs	r1, #0
   1ebea:	4620      	mov	r0, r4
   1ebec:	f7f9 fa24 	bl	18038 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
   1ebf0:	f7f6 f8c6 	bl	14d80 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
   1ebf4:	2800      	cmp	r0, #0
   1ebf6:	d1f3      	bne.n	1ebe0 <vTaskDelay+0x14>
   1ebf8:	e7ea      	b.n	1ebd0 <vTaskDelay+0x4>
   1ebfa:	bf00      	nop
   1ebfc:	e000ed04 	.word	0xe000ed04

Disassembly of section .text.gfx_mono_framebuffer_put_page%705:

0001ec00 <gfx_mono_framebuffer_put_page>:
 * \code
    gfx_mono_framebuffer_put_page(data_buf, 0, 10, 32);
\endcode
 */
void gfx_mono_framebuffer_put_page(gfx_mono_color_t *data, gfx_coord_t page,
        gfx_coord_t column, gfx_coord_t width) {
   1ec00:	b430      	push	{r4, r5}
    gfx_mono_color_t *data_pt = data;
    gfx_coord_t *framebuffer_pt = fbpointer +
   1ec02:	4c0b      	ldr	r4, [pc, #44]	; (1ec30 <gfx_mono_framebuffer_put_page+0x30>)
   1ec04:	6824      	ldr	r4, [r4, #0]
            ((page * GFX_MONO_LCD_WIDTH) + column);
   1ec06:	eb02 12c1 	add.w	r2, r2, r1, lsl #7
    gfx_coord_t *framebuffer_pt = fbpointer +
   1ec0a:	4422      	add	r2, r4

    do {
        uint8_t *fBufferBegin = fbpointer;
        uint8_t *fBufferEnd = fbpointer + GFX_MONO_LCD_FRAMEBUFFER_SIZE;
   1ec0c:	f504 7100 	add.w	r1, r4, #512	; 0x200
   1ec10:	e003      	b.n	1ec1a <gfx_mono_framebuffer_put_page+0x1a>

        if ((framebuffer_pt >= fBufferBegin) && (framebuffer_pt <= fBufferEnd)) {
            *framebuffer_pt++ = *data_pt++;
        }

    } while (--width > 0);
   1ec12:	3b01      	subs	r3, #1
   1ec14:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
   1ec18:	d008      	beq.n	1ec2c <gfx_mono_framebuffer_put_page+0x2c>
        if ((framebuffer_pt >= fBufferBegin) && (framebuffer_pt <= fBufferEnd)) {
   1ec1a:	4294      	cmp	r4, r2
   1ec1c:	d8f9      	bhi.n	1ec12 <gfx_mono_framebuffer_put_page+0x12>
   1ec1e:	428a      	cmp	r2, r1
            *framebuffer_pt++ = *data_pt++;
   1ec20:	bf9c      	itt	ls
   1ec22:	f810 5b01 	ldrbls.w	r5, [r0], #1
   1ec26:	f802 5b01 	strbls.w	r5, [r2], #1
   1ec2a:	e7f2      	b.n	1ec12 <gfx_mono_framebuffer_put_page+0x12>
}
   1ec2c:	bc30      	pop	{r4, r5}
   1ec2e:	4770      	bx	lr
   1ec30:	2000e6e0 	.word	0x2000e6e0

Disassembly of section .text.gfx_mono_generic_draw_filled_rect%706:

0001ec34 <gfx_mono_generic_draw_filled_rect>:
 * \param[in]  height      Height of the rectangle.
 * \param[in]  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
        gfx_coord_t width, gfx_coord_t height,
        enum gfx_mono_color color) {
   1ec34:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1ec38:	f89d 7018 	ldrb.w	r7, [sp, #24]
    if (height == 0) {
   1ec3c:	b193      	cbz	r3, 1ec64 <gfx_mono_generic_draw_filled_rect+0x30>
   1ec3e:	461c      	mov	r4, r3
   1ec40:	4690      	mov	r8, r2
   1ec42:	460d      	mov	r5, r1
   1ec44:	4606      	mov	r6, r0
   1ec46:	1e4b      	subs	r3, r1, #1
   1ec48:	441c      	add	r4, r3
   1ec4a:	b2e4      	uxtb	r4, r4
   1ec4c:	e000      	b.n	1ec50 <gfx_mono_generic_draw_filled_rect+0x1c>
   1ec4e:	461c      	mov	r4, r3
        /* Nothing to do. Move along. */
        return;
    }

    while (height-- > 0) {
        gfx_mono_draw_horizontal_line(x, y + height, width, color);
   1ec50:	463b      	mov	r3, r7
   1ec52:	4642      	mov	r2, r8
   1ec54:	4621      	mov	r1, r4
   1ec56:	4630      	mov	r0, r6
   1ec58:	f7f6 fe56 	bl	15908 <gfx_mono_generic_draw_horizontal_line>
   1ec5c:	1e63      	subs	r3, r4, #1
   1ec5e:	b2db      	uxtb	r3, r3
    while (height-- > 0) {
   1ec60:	42a5      	cmp	r5, r4
   1ec62:	d1f4      	bne.n	1ec4e <gfx_mono_generic_draw_filled_rect+0x1a>
    }
}
   1ec64:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.gfx_mono_scroll_Line_6x7%707:

0001ec68 <gfx_mono_scroll_Line_6x7>:
    }

    gfx_mono_put_byte(page, column, temp);
}

void gfx_mono_scroll_Line_6x7(void) {
   1ec68:	b508      	push	{r3, lr}
    int ix;
    for (ix = 0; ix < (128*3); ix++) {
   1ec6a:	480a      	ldr	r0, [pc, #40]	; (1ec94 <gfx_mono_scroll_Line_6x7+0x2c>)
   1ec6c:	1e43      	subs	r3, r0, #1
   1ec6e:	f200 117f 	addw	r1, r0, #383	; 0x17f
        framebuffer[ix] = framebuffer[ix + 128];
   1ec72:	f893 2081 	ldrb.w	r2, [r3, #129]	; 0x81
   1ec76:	f803 2f01 	strb.w	r2, [r3, #1]!
    for (ix = 0; ix < (128*3); ix++) {
   1ec7a:	428b      	cmp	r3, r1
   1ec7c:	d1f9      	bne.n	1ec72 <gfx_mono_scroll_Line_6x7+0xa>
   1ec7e:	4b06      	ldr	r3, [pc, #24]	; (1ec98 <gfx_mono_scroll_Line_6x7+0x30>)
   1ec80:	f200 12ff 	addw	r2, r0, #511	; 0x1ff
    }
    for ( ; ix < 512; ix++) {
        framebuffer[ix] = 0;
   1ec84:	2100      	movs	r1, #0
   1ec86:	f803 1f01 	strb.w	r1, [r3, #1]!
    for ( ; ix < 512; ix++) {
   1ec8a:	4293      	cmp	r3, r2
   1ec8c:	d1fb      	bne.n	1ec86 <gfx_mono_scroll_Line_6x7+0x1e>
    }  
    gfx_mono_ssd1306_put_framebuffer();
   1ec8e:	f7fe fc17 	bl	1d4c0 <gfx_mono_ssd1306_put_framebuffer>
}
   1ec92:	bd08      	pop	{r3, pc}
   1ec94:	2000d444 	.word	0x2000d444
   1ec98:	2000d5c3 	.word	0x2000d5c3

Disassembly of section .text.Hash_DRBG_Uninstantiate%708:

0001ec9c <Hash_DRBG_Uninstantiate>:
{
   1ec9c:	b410      	push	{r4}
    while (len--) *z++ = 0;
   1ec9e:	f100 0484 	add.w	r4, r0, #132	; 0x84
    volatile byte* z = (volatile byte*)mem;
   1eca2:	4602      	mov	r2, r0
    while (len--) *z++ = 0;
   1eca4:	2100      	movs	r1, #0
   1eca6:	4613      	mov	r3, r2
   1eca8:	f803 1b01 	strb.w	r1, [r3], #1
   1ecac:	461a      	mov	r2, r3
   1ecae:	42a3      	cmp	r3, r4
   1ecb0:	d1f9      	bne.n	1eca6 <Hash_DRBG_Uninstantiate+0xa>
   1ecb2:	1e43      	subs	r3, r0, #1
   1ecb4:	f100 0183 	add.w	r1, r0, #131	; 0x83
    int    compareSum = 0;
   1ecb8:	2000      	movs	r0, #0
        compareSum |= compareDrbg[i] ^ 0;
   1ecba:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   1ecbe:	4310      	orrs	r0, r2
    for (i = 0; i < sizeof(DRBG_internal); i++)
   1ecc0:	428b      	cmp	r3, r1
   1ecc2:	d1fa      	bne.n	1ecba <Hash_DRBG_Uninstantiate+0x1e>
}
   1ecc4:	3000      	adds	r0, #0
   1ecc6:	bf18      	it	ne
   1ecc8:	2001      	movne	r0, #1
   1ecca:	f85d 4b04 	ldr.w	r4, [sp], #4
   1ecce:	4770      	bx	lr

Disassembly of section .text.memmove%709:

0001ecd0 <memmove>:
   1ecd0:	4288      	cmp	r0, r1
   1ecd2:	b510      	push	{r4, lr}
   1ecd4:	eb01 0302 	add.w	r3, r1, r2
   1ecd8:	d902      	bls.n	1ece0 <memmove+0x10>
   1ecda:	4283      	cmp	r3, r0
   1ecdc:	461c      	mov	r4, r3
   1ecde:	d807      	bhi.n	1ecf0 <memmove+0x20>
   1ece0:	1e42      	subs	r2, r0, #1
   1ece2:	4299      	cmp	r1, r3
   1ece4:	d008      	beq.n	1ecf8 <memmove+0x28>
   1ece6:	f811 4b01 	ldrb.w	r4, [r1], #1
   1ecea:	f802 4f01 	strb.w	r4, [r2, #1]!
   1ecee:	e7f8      	b.n	1ece2 <memmove+0x12>
   1ecf0:	1883      	adds	r3, r0, r2
   1ecf2:	1a9a      	subs	r2, r3, r2
   1ecf4:	429a      	cmp	r2, r3
   1ecf6:	d100      	bne.n	1ecfa <memmove+0x2a>
   1ecf8:	bd10      	pop	{r4, pc}
   1ecfa:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
   1ecfe:	f803 1d01 	strb.w	r1, [r3, #-1]!
   1ed02:	e7f7      	b.n	1ecf4 <memmove+0x24>

Disassembly of section .text.__mcmp%710:

0001ed04 <__mcmp>:
   1ed04:	6903      	ldr	r3, [r0, #16]
   1ed06:	690a      	ldr	r2, [r1, #16]
   1ed08:	1a9b      	subs	r3, r3, r2
   1ed0a:	b530      	push	{r4, r5, lr}
   1ed0c:	d10c      	bne.n	1ed28 <__mcmp+0x24>
   1ed0e:	0092      	lsls	r2, r2, #2
   1ed10:	3014      	adds	r0, #20
   1ed12:	3114      	adds	r1, #20
   1ed14:	1884      	adds	r4, r0, r2
   1ed16:	4411      	add	r1, r2
   1ed18:	f854 5d04 	ldr.w	r5, [r4, #-4]!
   1ed1c:	f851 2d04 	ldr.w	r2, [r1, #-4]!
   1ed20:	4295      	cmp	r5, r2
   1ed22:	d003      	beq.n	1ed2c <__mcmp+0x28>
   1ed24:	d305      	bcc.n	1ed32 <__mcmp+0x2e>
   1ed26:	2301      	movs	r3, #1
   1ed28:	4618      	mov	r0, r3
   1ed2a:	bd30      	pop	{r4, r5, pc}
   1ed2c:	42a0      	cmp	r0, r4
   1ed2e:	d3f3      	bcc.n	1ed18 <__mcmp+0x14>
   1ed30:	e7fa      	b.n	1ed28 <__mcmp+0x24>
   1ed32:	f04f 33ff 	mov.w	r3, #4294967295
   1ed36:	e7f7      	b.n	1ed28 <__mcmp+0x24>

Disassembly of section .text._DRV_PHY_SMIReadStart%711:

0001ed38 <_DRV_PHY_SMIReadStart>:
{
   1ed38:	b510      	push	{r4, lr}
   1ed3a:	4604      	mov	r4, r0
    hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_START;
   1ed3c:	2301      	movs	r3, #1
   1ed3e:	8683      	strh	r3, [r0, #52]	; 0x34
    hClientObj->smiRIx = rIx;
   1ed40:	8701      	strh	r1, [r0, #56]	; 0x38
    hClientObj->smiTxferType = DRV_ETHPHY_SMI_XFER_TYPE_READ;
   1ed42:	2303      	movs	r3, #3
   1ed44:	86c3      	strh	r3, [r0, #54]	; 0x36
    hClientObj->smiPhyAddress = hClientObj->hDriver->phyAddress;
   1ed46:	68c3      	ldr	r3, [r0, #12]
   1ed48:	691b      	ldr	r3, [r3, #16]
   1ed4a:	63c3      	str	r3, [r0, #60]	; 0x3c
    DRV_ETHPHY_SMI_TXFER_RES opRes = _DRV_PHY_SMITransferStart(hClientObj);
   1ed4c:	f7f8 fd88 	bl	17860 <_DRV_PHY_SMITransferStart>
    if(opRes < 0)
   1ed50:	2800      	cmp	r0, #0
   1ed52:	db03      	blt.n	1ed5c <_DRV_PHY_SMIReadStart+0x24>
    else if(opRes == DRV_ETHPHY_SMI_TXFER_RES_BUSY)
   1ed54:	3803      	subs	r0, #3
   1ed56:	bf18      	it	ne
   1ed58:	2001      	movne	r0, #1
}
   1ed5a:	bd10      	pop	{r4, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   1ed5c:	f06f 0108 	mvn.w	r1, #8
   1ed60:	4620      	mov	r0, r4
   1ed62:	f000 ff2f 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
        return false;
   1ed66:	2000      	movs	r0, #0
   1ed68:	e7f7      	b.n	1ed5a <_DRV_PHY_SMIReadStart+0x22>

Disassembly of section .text._DRV_PHY_SMIWriteStart%712:

0001ed6a <_DRV_PHY_SMIWriteStart>:
{
   1ed6a:	b510      	push	{r4, lr}
   1ed6c:	4604      	mov	r4, r0
    hClientObj->smiTxferStatus = DRV_ETHPHY_SMI_TXFER_OP_START;
   1ed6e:	2301      	movs	r3, #1
   1ed70:	8683      	strh	r3, [r0, #52]	; 0x34
    hClientObj->smiRIx = rIx;
   1ed72:	8701      	strh	r1, [r0, #56]	; 0x38
    hClientObj->smiTxferType = DRV_ETHPHY_SMI_XFER_TYPE_WRITE;
   1ed74:	86c3      	strh	r3, [r0, #54]	; 0x36
    hClientObj->smiData =  wData;
   1ed76:	8742      	strh	r2, [r0, #58]	; 0x3a
    hClientObj->smiPhyAddress = hClientObj->hDriver->phyAddress;
   1ed78:	68c3      	ldr	r3, [r0, #12]
   1ed7a:	691b      	ldr	r3, [r3, #16]
   1ed7c:	63c3      	str	r3, [r0, #60]	; 0x3c
    DRV_ETHPHY_SMI_TXFER_RES opRes = _DRV_PHY_SMITransferStart(hClientObj);
   1ed7e:	f7f8 fd6f 	bl	17860 <_DRV_PHY_SMITransferStart>
    if(opRes < 0)
   1ed82:	2800      	cmp	r0, #0
   1ed84:	db03      	blt.n	1ed8e <_DRV_PHY_SMIWriteStart+0x24>
    else if(opRes == DRV_ETHPHY_SMI_TXFER_RES_BUSY)
   1ed86:	3803      	subs	r0, #3
   1ed88:	bf18      	it	ne
   1ed8a:	2001      	movne	r0, #1
}
   1ed8c:	bd10      	pop	{r4, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   1ed8e:	f06f 0108 	mvn.w	r1, #8
   1ed92:	4620      	mov	r0, r4
   1ed94:	f000 ff16 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
        return false;
   1ed98:	2000      	movs	r0, #0
   1ed9a:	e7f7      	b.n	1ed8c <_DRV_PHY_SMIWriteStart+0x22>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseIdle%713:

0001ed9c <_DRV_ETHPHY_SetupPhaseIdle>:
    hDriver = hClientObj->hDriver;
   1ed9c:	68c1      	ldr	r1, [r0, #12]
    configFlags = hDriver->configFlags;
   1ed9e:	7b8b      	ldrb	r3, [r1, #14]
    openFlags = hDriver->openFlags;
   1eda0:	898a      	ldrh	r2, [r1, #12]
    if(openFlags & (TCPIP_ETH_OPEN_PHY_LOOPBACK | TCPIP_ETH_OPEN_MAC_LOOPBACK))
   1eda2:	f012 0fc0 	tst.w	r2, #192	; 0xc0
        openFlags &= ~TCPIP_ETH_OPEN_AUTO; // no negotiation in loopback mode!
   1eda6:	bf1c      	itt	ne
   1eda8:	f022 0201 	bicne.w	r2, r2, #1
   1edac:	b292      	uxthne	r2, r2
    if(!(openFlags & TCPIP_ETH_OPEN_AUTO))
   1edae:	f012 0f01 	tst.w	r2, #1
        openFlags &= ~TCPIP_ETH_OPEN_MDIX_AUTO;        // Auto-MDIX has to be in auto negotiation only
   1edb2:	bf04      	itt	eq
   1edb4:	f422 7280 	biceq.w	r2, r2, #256	; 0x100
   1edb8:	b292      	uxtheq	r2, r2
    openFlags |= (configFlags & DRV_ETHPHY_CFG_RMII) ? TCPIP_ETH_OPEN_RMII : TCPIP_ETH_OPEN_MII;
   1edba:	029b      	lsls	r3, r3, #10
   1edbc:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   1edc0:	4313      	orrs	r3, r2
    hDriver->openFlags = openFlags;
   1edc2:	818b      	strh	r3, [r1, #12]
    hClientObj->operPhase = operPhase;
   1edc4:	2301      	movs	r3, #1
   1edc6:	83c3      	strh	r3, [r0, #30]
    hClientObj->operSubPhase = operSubPhase;
   1edc8:	2300      	movs	r3, #0
   1edca:	8403      	strh	r3, [r0, #32]
}
   1edcc:	4770      	bx	lr

Disassembly of section .text.DRV_PIC32CGMAC_LibTxAckPendPacket%714:

0001edce <DRV_PIC32CGMAC_LibTxAckPendPacket>:
{
   1edce:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1edd2:	4605      	mov	r5, r0
   1edd4:	4690      	mov	r8, r2
    while((pPkt = (TCPIP_MAC_PACKET*)DRV_PIC32CGMAC_SingleListHeadRemove(&pMACDrv->sGmacData.gmac_queue[queueIdx]._TxQueue)) != 0)
   1edd6:	242c      	movs	r4, #44	; 0x2c
   1edd8:	fb04 0401 	mla	r4, r4, r1, r0
   1eddc:	34a4      	adds	r4, #164	; 0xa4
            (*pMACDrv->sGmacData.pktAckF)(pPkt, ackRes, TCPIP_THIS_MODULE_ID);
   1edde:	f241 0750 	movw	r7, #4176	; 0x1050
    while((pPkt = (TCPIP_MAC_PACKET*)DRV_PIC32CGMAC_SingleListHeadRemove(&pMACDrv->sGmacData.gmac_queue[queueIdx]._TxQueue)) != 0)
   1ede2:	4620      	mov	r0, r4
   1ede4:	f001 ffb4 	bl	20d50 <DRV_PIC32CGMAC_SingleListHeadRemove>
   1ede8:	4606      	mov	r6, r0
   1edea:	b138      	cbz	r0, 1edfc <DRV_PIC32CGMAC_LibTxAckPendPacket+0x2e>
        if(*pMACDrv->sGmacData.pktAckF)
   1edec:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   1edee:	2b00      	cmp	r3, #0
   1edf0:	d0f7      	beq.n	1ede2 <DRV_PIC32CGMAC_LibTxAckPendPacket+0x14>
            (*pMACDrv->sGmacData.pktAckF)(pPkt, ackRes, TCPIP_THIS_MODULE_ID);
   1edf2:	463a      	mov	r2, r7
   1edf4:	4641      	mov	r1, r8
   1edf6:	4630      	mov	r0, r6
   1edf8:	4798      	blx	r3
   1edfa:	e7f2      	b.n	1ede2 <DRV_PIC32CGMAC_LibTxAckPendPacket+0x14>
}
   1edfc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.TCPIP_STACK_NetBiosNameSet%715:

0001ee00 <TCPIP_STACK_NetBiosNameSet>:
   1ee00:	b1a8      	cbz	r0, 1ee2e <TCPIP_STACK_NetBiosNameSet+0x2e>
   1ee02:	4603      	mov	r3, r0
   1ee04:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1ee08:	f012 0f40 	tst.w	r2, #64	; 0x40
   1ee0c:	d101      	bne.n	1ee12 <TCPIP_STACK_NetBiosNameSet+0x12>
    return false;
   1ee0e:	2000      	movs	r0, #0
}
   1ee10:	4770      	bx	lr
{
   1ee12:	b570      	push	{r4, r5, r6, lr}
        memcpy(pNetIf->NetBIOSName, biosName, sizeof(pNetIf->NetBIOSName));
   1ee14:	302c      	adds	r0, #44	; 0x2c
   1ee16:	680e      	ldr	r6, [r1, #0]
   1ee18:	684d      	ldr	r5, [r1, #4]
   1ee1a:	688c      	ldr	r4, [r1, #8]
   1ee1c:	68ca      	ldr	r2, [r1, #12]
   1ee1e:	62de      	str	r6, [r3, #44]	; 0x2c
   1ee20:	6045      	str	r5, [r0, #4]
   1ee22:	6084      	str	r4, [r0, #8]
   1ee24:	60c2      	str	r2, [r0, #12]
        TCPIP_Helper_FormatNetBIOSName(pNetIf->NetBIOSName);
   1ee26:	f7fd fac9 	bl	1c3bc <TCPIP_Helper_FormatNetBIOSName>
        return true;
   1ee2a:	2001      	movs	r0, #1
}
   1ee2c:	bd70      	pop	{r4, r5, r6, pc}
    return false;
   1ee2e:	2000      	movs	r0, #0
   1ee30:	4770      	bx	lr

Disassembly of section .text._DRV_PHY_NegCompleteSetOperResult%716:

0001ee32 <_DRV_PHY_NegCompleteSetOperResult>:
{
   1ee32:	b508      	push	{r3, lr}
    if(!phyBMCon.AN_ENABLE)
   1ee34:	0a09      	lsrs	r1, r1, #8
   1ee36:	f011 0f10 	tst.w	r1, #16
   1ee3a:	d00a      	beq.n	1ee52 <_DRV_PHY_NegCompleteSetOperResult+0x20>
    else if(phyBMCon.AN_RESTART)
   1ee3c:	f011 0f02 	tst.w	r1, #2
   1ee40:	d10c      	bne.n	1ee5c <_DRV_PHY_NegCompleteSetOperResult+0x2a>
        res = (phyStat.AN_COMPLETE == 0) ? DRV_ETHPHY_RES_NEGOTIATION_ACTIVE : DRV_ETHPHY_RES_OK;    // active/tmo/ok
   1ee42:	f002 0220 	and.w	r2, r2, #32
   1ee46:	2a00      	cmp	r2, #0
   1ee48:	bf0c      	ite	eq
   1ee4a:	f06f 0107 	mvneq.w	r1, #7
   1ee4e:	2100      	movne	r1, #0
   1ee50:	e001      	b.n	1ee56 <_DRV_PHY_NegCompleteSetOperResult+0x24>
        res = DRV_ETHPHY_RES_NEGOTIATION_INACTIVE;       // no negotiation is taking place!
   1ee52:	f06f 0104 	mvn.w	r1, #4
    _DRV_PHY_SetOperDoneResult(hClientObj, res);
   1ee56:	f000 feb5 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
}
   1ee5a:	bd08      	pop	{r3, pc}
        res = DRV_ETHPHY_RES_NEGOTIATION_NOT_STARTED;        // not started yet/tmo
   1ee5c:	f06f 0106 	mvn.w	r1, #6
   1ee60:	e7f9      	b.n	1ee56 <_DRV_PHY_NegCompleteSetOperResult+0x24>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3%717:

0001ee64 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3>:
{
   1ee64:	b538      	push	{r3, r4, r5, lr}
   1ee66:	4604      	mov	r4, r0
    DRV_ETHPHY_INSTANCE *hDriver = hClientObj->hDriver;
   1ee68:	68c3      	ldr	r3, [r0, #12]
    res = (*hDriver->pPhyObj->mdixConfigure)(gDrvEthBaseObj, (DRV_HANDLE)hClientObj, hClientObj->hDriver->openFlags);
   1ee6a:	695a      	ldr	r2, [r3, #20]
   1ee6c:	6855      	ldr	r5, [r2, #4]
   1ee6e:	899a      	ldrh	r2, [r3, #12]
   1ee70:	4601      	mov	r1, r0
   1ee72:	4807      	ldr	r0, [pc, #28]	; (1ee90 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3+0x2c>)
   1ee74:	47a8      	blx	r5
    if(res < 0)
   1ee76:	1e01      	subs	r1, r0, #0
   1ee78:	db01      	blt.n	1ee7e <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3+0x1a>
    else if(res != DRV_ETHPHY_RES_OK)
   1ee7a:	b121      	cbz	r1, 1ee86 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3+0x22>
}
   1ee7c:	bd38      	pop	{r3, r4, r5, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, res);
   1ee7e:	4620      	mov	r0, r4
   1ee80:	f000 fea0 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
        return;
   1ee84:	e7fa      	b.n	1ee7c <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3+0x18>
    hClientObj->operPhase = operPhase;
   1ee86:	2303      	movs	r3, #3
   1ee88:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   1ee8a:	2304      	movs	r3, #4
   1ee8c:	8423      	strh	r3, [r4, #32]
   1ee8e:	e7f5      	b.n	1ee7c <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase3+0x18>
   1ee90:	0001b540 	.word	0x0001b540

Disassembly of section .text.DRV_GMAC_Status%718:

0001ee94 <DRV_GMAC_Status>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   1ee94:	4b0a      	ldr	r3, [pc, #40]	; (1eec0 <DRV_GMAC_Status+0x2c>)
   1ee96:	4283      	cmp	r3, r0
   1ee98:	d108      	bne.n	1eeac <DRV_GMAC_Status+0x18>
    if(pMACDrv != 0)
   1ee9a:	b150      	cbz	r0, 1eeb2 <DRV_GMAC_Status+0x1e>
        if(pMACDrv->sGmacData._macFlags._init != 0)
   1ee9c:	7d9b      	ldrb	r3, [r3, #22]
   1ee9e:	f013 0f01 	tst.w	r3, #1
   1eea2:	d009      	beq.n	1eeb8 <DRV_GMAC_Status+0x24>
            return pMACDrv->sGmacData.sysStat;
   1eea4:	4b06      	ldr	r3, [pc, #24]	; (1eec0 <DRV_GMAC_Status+0x2c>)
   1eea6:	f993 0014 	ldrsb.w	r0, [r3, #20]
   1eeaa:	4770      	bx	lr
	return SYS_STATUS_ERROR;
   1eeac:	f04f 30ff 	mov.w	r0, #4294967295
   1eeb0:	4770      	bx	lr
   1eeb2:	f04f 30ff 	mov.w	r0, #4294967295
   1eeb6:	4770      	bx	lr
   1eeb8:	f04f 30ff 	mov.w	r0, #4294967295
}
   1eebc:	4770      	bx	lr
   1eebe:	bf00      	nop
   1eec0:	2000dab8 	.word	0x2000dab8

Disassembly of section .text.DRV_PIC32CGMAC_LibSetMacAddr%719:

0001eec4 <DRV_PIC32CGMAC_LibSetMacAddr>:
    GMAC_REGS->SA[0].GMAC_SAB = (pMacAddr[3] << 24)
   1eec4:	78c2      	ldrb	r2, [r0, #3]
                                | (pMacAddr[2] << 16)
   1eec6:	7883      	ldrb	r3, [r0, #2]
   1eec8:	041b      	lsls	r3, r3, #16
   1eeca:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
                                | (pMacAddr[0]);
   1eece:	7802      	ldrb	r2, [r0, #0]
   1eed0:	4313      	orrs	r3, r2
                                | (pMacAddr[1] <<  8)
   1eed2:	7842      	ldrb	r2, [r0, #1]
                                | (pMacAddr[0]);
   1eed4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    GMAC_REGS->SA[0].GMAC_SAB = (pMacAddr[3] << 24)
   1eed8:	4a05      	ldr	r2, [pc, #20]	; (1eef0 <DRV_PIC32CGMAC_LibSetMacAddr+0x2c>)
   1eeda:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    GMAC_REGS->SA[0].GMAC_SAT = (pMacAddr[5] <<  8)
   1eede:	7941      	ldrb	r1, [r0, #5]
                                | (pMacAddr[4]) ;
   1eee0:	7903      	ldrb	r3, [r0, #4]
   1eee2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    GMAC_REGS->SA[0].GMAC_SAT = (pMacAddr[5] <<  8)
   1eee6:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
}
   1eeea:	2000      	movs	r0, #0
   1eeec:	4770      	bx	lr
   1eeee:	bf00      	nop
   1eef0:	42000800 	.word	0x42000800

Disassembly of section .text.GMAC_InterruptHandler%720:

0001eef4 <GMAC_InterruptHandler>:
{
   1eef4:	b508      	push	{r3, lr}
    GMAC_EVENTS  currEthEvents = (GMAC_EVENTS)GMAC_REGS->GMAC_ISR;
   1eef6:	4b09      	ldr	r3, [pc, #36]	; (1ef1c <GMAC_InterruptHandler+0x28>)
   1eef8:	6a59      	ldr	r1, [r3, #36]	; 0x24
    GMAC_REGS->GMAC_IDR = currEthEvents;
   1eefa:	b289      	uxth	r1, r1
   1eefc:	62d9      	str	r1, [r3, #44]	; 0x2c
    if(currEthEvents & GMAC_EV_RX_ALL)
   1eefe:	f240 4306 	movw	r3, #1030	; 0x406
   1ef02:	4219      	tst	r1, r3
   1ef04:	d004      	beq.n	1ef10 <GMAC_InterruptHandler+0x1c>
        drvGmacQueEvents |= GMAC_QUE0_MASK;
   1ef06:	4a06      	ldr	r2, [pc, #24]	; (1ef20 <GMAC_InterruptHandler+0x2c>)
   1ef08:	6813      	ldr	r3, [r2, #0]
   1ef0a:	f043 0301 	orr.w	r3, r3, #1
   1ef0e:	6013      	str	r3, [r2, #0]
   1ef10:	f3bf 8f5f 	dmb	sy
	DRV_GMAC_Tasks_ISR((SYS_MODULE_OBJ)0, (uint32_t)currEthEvents);
   1ef14:	2000      	movs	r0, #0
   1ef16:	f7fb f961 	bl	1a1dc <DRV_GMAC_Tasks_ISR>
}
   1ef1a:	bd08      	pop	{r3, pc}
   1ef1c:	42000800 	.word	0x42000800
   1ef20:	2000e578 	.word	0x2000e578

Disassembly of section .text.TCPIP_ICMP_Cleanup%721:

0001ef24 <TCPIP_ICMP_Cleanup>:
{
   1ef24:	b508      	push	{r3, lr}
    TCPIP_Notification_Deinitialize(&icmpRegisteredUsers, icmpMemH);
   1ef26:	4b08      	ldr	r3, [pc, #32]	; (1ef48 <TCPIP_ICMP_Cleanup+0x24>)
   1ef28:	6819      	ldr	r1, [r3, #0]
   1ef2a:	4808      	ldr	r0, [pc, #32]	; (1ef4c <TCPIP_ICMP_Cleanup+0x28>)
   1ef2c:	f002 fda6 	bl	21a7c <TCPIP_Notification_Deinitialize>
    if(signalHandle)
   1ef30:	4b07      	ldr	r3, [pc, #28]	; (1ef50 <TCPIP_ICMP_Cleanup+0x2c>)
   1ef32:	6818      	ldr	r0, [r3, #0]
   1ef34:	b120      	cbz	r0, 1ef40 <TCPIP_ICMP_Cleanup+0x1c>
        _TCPIPStackSignalHandlerDeregister(signalHandle);
   1ef36:	f002 fe74 	bl	21c22 <_TCPIPStackSignalHandlerDeregister>
        signalHandle = 0;
   1ef3a:	4b05      	ldr	r3, [pc, #20]	; (1ef50 <TCPIP_ICMP_Cleanup+0x2c>)
   1ef3c:	2200      	movs	r2, #0
   1ef3e:	601a      	str	r2, [r3, #0]
    icmpMemH = 0;
   1ef40:	4b01      	ldr	r3, [pc, #4]	; (1ef48 <TCPIP_ICMP_Cleanup+0x24>)
   1ef42:	2200      	movs	r2, #0
   1ef44:	601a      	str	r2, [r3, #0]
}
   1ef46:	bd08      	pop	{r3, pc}
   1ef48:	2000e588 	.word	0x2000e588
   1ef4c:	2000e414 	.word	0x2000e414
   1ef50:	2000e590 	.word	0x2000e590

Disassembly of section .text._TCPSocketTxFreeSize%722:

0001ef54 <_TCPSocketTxFreeSize>:
	if(!( (pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED) || (pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT) ))
   1ef54:	f890 306e 	ldrb.w	r3, [r0, #110]	; 0x6e
   1ef58:	2b03      	cmp	r3, #3
   1ef5a:	d001      	beq.n	1ef60 <_TCPSocketTxFreeSize+0xc>
   1ef5c:	2b08      	cmp	r3, #8
   1ef5e:	d10f      	bne.n	1ef80 <_TCPSocketTxFreeSize+0x2c>
	if(pSkt->txHead >= pSkt->txTail)
   1ef60:	6882      	ldr	r2, [r0, #8]
   1ef62:	68c3      	ldr	r3, [r0, #12]
   1ef64:	429a      	cmp	r2, r3
   1ef66:	d203      	bcs.n	1ef70 <_TCPSocketTxFreeSize+0x1c>
	return pSkt->txTail - pSkt->txHead - 1;
   1ef68:	1a98      	subs	r0, r3, r2
   1ef6a:	3801      	subs	r0, #1
   1ef6c:	b280      	uxth	r0, r0
   1ef6e:	4770      	bx	lr
		return (pSkt->txEnd - pSkt->txStart - 1) - (pSkt->txHead - pSkt->txTail);
   1ef70:	6841      	ldr	r1, [r0, #4]
   1ef72:	6800      	ldr	r0, [r0, #0]
   1ef74:	1a09      	subs	r1, r1, r0
   1ef76:	3901      	subs	r1, #1
   1ef78:	1ad0      	subs	r0, r2, r3
   1ef7a:	1a08      	subs	r0, r1, r0
   1ef7c:	b280      	uxth	r0, r0
   1ef7e:	4770      	bx	lr
		return 0;
   1ef80:	2000      	movs	r0, #0
}
   1ef82:	4770      	bx	lr

Disassembly of section .text.TCPIP_ARP_HashEntryDelete%723:

0001ef84 <TCPIP_ARP_HashEntryDelete>:
// This shouldn't normally occur if TCPIP_ARP_Task()
// does its job of periodically performing the cache clean-up.
// However, since the threshold can be dynamically adjusted,
// the situation could still occur
OA_HASH_ENTRY* TCPIP_ARP_HashEntryDelete(OA_HASH_DCPT* pOH)
{
   1ef84:	b508      	push	{r3, lr}
    ARP_CACHE_DCPT  *pArpDcpt;
    ARP_HASH_ENTRY  *pE;
    SGL_LIST_NODE   *pN;
    PROTECTED_SINGLE_LIST     *pRemList = 0;
    
    pArpDcpt = (ARP_CACHE_DCPT*)pOH->hParam;
   1ef86:	6840      	ldr	r0, [r0, #4]

    if( (pN = pArpDcpt->incompleteList.list.head) != 0)
   1ef88:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   1ef8a:	b142      	cbz	r2, 1ef9e <TCPIP_ARP_HashEntryDelete+0x1a>
    {
        pE = (ARP_HASH_ENTRY*) ((uint8_t*)pN - offsetof(struct _TAG_ARP_HASH_ENTRY, next));
        if( (arpMod.timeSeconds - pE->tInsert) >= arpMod.entryPendingTmo)
   1ef8c:	4908      	ldr	r1, [pc, #32]	; (1efb0 <TCPIP_ARP_HashEntryDelete+0x2c>)
   1ef8e:	694b      	ldr	r3, [r1, #20]
   1ef90:	6892      	ldr	r2, [r2, #8]
   1ef92:	1a9b      	subs	r3, r3, r2
   1ef94:	6b8a      	ldr	r2, [r1, #56]	; 0x38
   1ef96:	4293      	cmp	r3, r2
   1ef98:	d301      	bcc.n	1ef9e <TCPIP_ARP_HashEntryDelete+0x1a>
        {   // we remove this one
            pRemList = &pArpDcpt->incompleteList;
   1ef9a:	302c      	adds	r0, #44	; 0x2c
        }
    }

    if(pRemList == 0)
   1ef9c:	e000      	b.n	1efa0 <TCPIP_ARP_HashEntryDelete+0x1c>
    {   // no luck with the incomplete list; use the complete one
            pRemList = &pArpDcpt->completeList;
   1ef9e:	3018      	adds	r0, #24
    }

    pN = TCPIP_Helper_ProtectedSingleListHeadRemove(pRemList);
   1efa0:	f000 fbde 	bl	1f760 <TCPIP_Helper_ProtectedSingleListHeadRemove>

    if(pN)
   1efa4:	4603      	mov	r3, r0
   1efa6:	b100      	cbz	r0, 1efaa <TCPIP_ARP_HashEntryDelete+0x26>
    {
        pE = (ARP_HASH_ENTRY*) ((uint8_t*)pN - offsetof(struct _TAG_ARP_HASH_ENTRY, next));
        return &pE->hEntry;    
   1efa8:	1f03      	subs	r3, r0, #4

    // it's possible to be unable to make room in the cache
    // for example, too many permanent entries added...
                   
    return 0;
}
   1efaa:	4618      	mov	r0, r3
   1efac:	bd08      	pop	{r3, pc}
   1efae:	bf00      	nop
   1efb0:	2000e1a4 	.word	0x2000e1a4

Disassembly of section .rodata.iperfCmdTbl%724:

0001efb4 <iperfCmdTbl>:
   1efb4:	00005624 00006ac5 0000562c 00005644     $V...j..,V..DV..
   1efc4:	00016395 0000564c 00005660 00012085     .c..LV..`V... ..
   1efd4:	00005668 0000568c 00010091 00005694     hV...V.......V..

Disassembly of section .text.TCPIP_IPV4_CheckPktTx%725:

0001efe4 <TCPIP_IPV4_CheckPktTx>:
{
   1efe4:	b538      	push	{r3, r4, r5, lr}
    if(pPkt->next == 0)
   1efe6:	680d      	ldr	r5, [r1, #0]
   1efe8:	b115      	cbz	r5, 1eff0 <TCPIP_IPV4_CheckPktTx+0xc>
    TCPIP_NET_IF* pNetIf = 0;
   1efea:	2300      	movs	r3, #0
}
   1efec:	4618      	mov	r0, r3
   1efee:	bd38      	pop	{r3, r4, r5, pc}
   1eff0:	460c      	mov	r4, r1
        if((pNetIf = _TCPIPStackHandleToNetLinked(hNet)) != 0)
   1eff2:	f001 fced 	bl	209d0 <_TCPIPStackHandleToNetLinked>
   1eff6:	4603      	mov	r3, r0
   1eff8:	2800      	cmp	r0, #0
   1effa:	d0f7      	beq.n	1efec <TCPIP_IPV4_CheckPktTx+0x8>
    return pNetIf->Flags.bInConfig != 0;
   1effc:	f890 2043 	ldrb.w	r2, [r0, #67]	; 0x43
            if(_TCPIPStackIsConfig(pNetIf) && (pPkt->pktFlags & TCPIP_MAC_PKT_FLAG_CONFIG) == 0)
   1f000:	f012 0f10 	tst.w	r2, #16
   1f004:	d0f2      	beq.n	1efec <TCPIP_IPV4_CheckPktTx+0x8>
   1f006:	f9b4 2022 	ldrsh.w	r2, [r4, #34]	; 0x22
                pNetIf = 0;
   1f00a:	ea13 0322 	ands.w	r3, r3, r2, asr #32
   1f00e:	bf38      	it	cc
   1f010:	462b      	movcc	r3, r5
   1f012:	e7eb      	b.n	1efec <TCPIP_IPV4_CheckPktTx+0x8>

Disassembly of section .text.fnv_32_hash%726:

0001f014 <fnv_32_hash>:

#include "tcpip/src/hash_fnv.h"


uint32_t fnv_32_hash(const void *key, size_t keyLen)
{
   1f014:	4602      	mov	r2, r0
    size_t      ix;
    uint32_t    hval = FNV_32_INIT;
    
    const uint8_t* p = (const uint8_t*)key;

    for(ix = 0; ix < keyLen; ix++)
   1f016:	b189      	cbz	r1, 1f03c <fnv_32_hash+0x28>
   1f018:	1841      	adds	r1, r0, r1
    uint32_t    hval = FNV_32_INIT;
   1f01a:	4809      	ldr	r0, [pc, #36]	; (1f040 <fnv_32_hash+0x2c>)
    {
#if defined(NO_FNV_GCC_OPTIMIZATION)
        hval *= FNV_32_PRIME;
#else
        hval += (hval<<1) + (hval<<4) + (hval<<7) + (hval<<8) + (hval<<24);
   1f01c:	0103      	lsls	r3, r0, #4
   1f01e:	eb03 0340 	add.w	r3, r3, r0, lsl #1
   1f022:	4403      	add	r3, r0
   1f024:	eb03 13c0 	add.w	r3, r3, r0, lsl #7
   1f028:	eb03 2300 	add.w	r3, r3, r0, lsl #8
   1f02c:	eb03 6300 	add.w	r3, r3, r0, lsl #24
#endif
        hval ^= (uint32_t)*p++;
   1f030:	f812 0b01 	ldrb.w	r0, [r2], #1
   1f034:	4058      	eors	r0, r3
    for(ix = 0; ix < keyLen; ix++)
   1f036:	4291      	cmp	r1, r2
   1f038:	d1f0      	bne.n	1f01c <fnv_32_hash+0x8>
   1f03a:	4770      	bx	lr
    uint32_t    hval = FNV_32_INIT;
   1f03c:	4800      	ldr	r0, [pc, #0]	; (1f040 <fnv_32_hash+0x2c>)
    }
    return hval;
}
   1f03e:	4770      	bx	lr
   1f040:	811c9dc5 	.word	0x811c9dc5

Disassembly of section .text.TCPIP_OAHASH_EntriesRemoveAll%727:

0001f044 <TCPIP_OAHASH_EntriesRemoveAll>:
    pBkt = (OA_HASH_ENTRY*)pOH->memBlk;
   1f044:	6803      	ldr	r3, [r0, #0]
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   1f046:	68c2      	ldr	r2, [r0, #12]
   1f048:	b19a      	cbz	r2, 1f072 <TCPIP_OAHASH_EntriesRemoveAll+0x2e>
   1f04a:	2200      	movs	r2, #0
   1f04c:	e005      	b.n	1f05a <TCPIP_OAHASH_EntriesRemoveAll+0x16>
        pBkt = (OA_HASH_ENTRY*)((uint8_t*)pBkt + pOH->hEntrySize);
   1f04e:	6881      	ldr	r1, [r0, #8]
   1f050:	440b      	add	r3, r1
    for(bktIx = 0; bktIx < pOH->hEntries; bktIx++)
   1f052:	3201      	adds	r2, #1
   1f054:	68c1      	ldr	r1, [r0, #12]
   1f056:	4291      	cmp	r1, r2
   1f058:	d90b      	bls.n	1f072 <TCPIP_OAHASH_EntriesRemoveAll+0x2e>
        if(pBkt->flags.busy)
   1f05a:	7819      	ldrb	r1, [r3, #0]
   1f05c:	f011 0f01 	tst.w	r1, #1
   1f060:	d0f5      	beq.n	1f04e <TCPIP_OAHASH_EntriesRemoveAll+0xa>
        pOE->flags.busy = 0;
   1f062:	7819      	ldrb	r1, [r3, #0]
   1f064:	f36f 0100 	bfc	r1, #0, #1
   1f068:	7019      	strb	r1, [r3, #0]
        pOH->fullSlots--;
   1f06a:	6a41      	ldr	r1, [r0, #36]	; 0x24
   1f06c:	3901      	subs	r1, #1
   1f06e:	6241      	str	r1, [r0, #36]	; 0x24
   1f070:	e7ed      	b.n	1f04e <TCPIP_OAHASH_EntriesRemoveAll+0xa>
}
   1f072:	4770      	bx	lr

Disassembly of section .text.TCPIP_Helper_StringToPowerMode%728:

0001f074 <TCPIP_Helper_StringToPowerMode>:
    if(str)
   1f074:	b188      	cbz	r0, 1f09a <TCPIP_Helper_StringToPowerMode+0x26>
{
   1f076:	b570      	push	{r4, r5, r6, lr}
   1f078:	4605      	mov	r5, r0
        pEntry = TCPIP_MAC_POWER_TBL + 0;
   1f07a:	4c09      	ldr	r4, [pc, #36]	; (1f0a0 <TCPIP_Helper_StringToPowerMode+0x2c>)
        for(pwrIx = 0; pwrIx < sizeof(TCPIP_MAC_POWER_TBL)/sizeof(*TCPIP_MAC_POWER_TBL); pwrIx++, pEntry++)
   1f07c:	f104 0620 	add.w	r6, r4, #32
   1f080:	3408      	adds	r4, #8
   1f082:	42b4      	cmp	r4, r6
   1f084:	d00a      	beq.n	1f09c <TCPIP_Helper_StringToPowerMode+0x28>
            if(pEntry->pwrName)
   1f086:	6861      	ldr	r1, [r4, #4]
   1f088:	2900      	cmp	r1, #0
   1f08a:	d0f9      	beq.n	1f080 <TCPIP_Helper_StringToPowerMode+0xc>
                if(!strcmp(str, pEntry->pwrName))
   1f08c:	4628      	mov	r0, r5
   1f08e:	f002 fc35 	bl	218fc <strcmp>
   1f092:	2800      	cmp	r0, #0
   1f094:	d1f4      	bne.n	1f080 <TCPIP_Helper_StringToPowerMode+0xc>
                    return pEntry->pwrMode;
   1f096:	7820      	ldrb	r0, [r4, #0]
   1f098:	e001      	b.n	1f09e <TCPIP_Helper_StringToPowerMode+0x2a>
   1f09a:	4770      	bx	lr
    return TCPIP_MAC_POWER_NONE;
   1f09c:	2000      	movs	r0, #0
}
   1f09e:	bd70      	pop	{r4, r5, r6, pc}
   1f0a0:	00020990 	.word	0x00020990

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListDeinitialize%729:

0001f0a4 <TCPIP_Helper_ProtectedSingleListDeinitialize>:
    return pL->semValid;
}

void  TCPIP_Helper_ProtectedSingleListDeinitialize(PROTECTED_SINGLE_LIST* pL)
{
    if(pL->semValid)
   1f0a4:	7c03      	ldrb	r3, [r0, #16]
   1f0a6:	b903      	cbnz	r3, 1f0aa <TCPIP_Helper_ProtectedSingleListDeinitialize+0x6>
   1f0a8:	4770      	bx	lr
{
   1f0aa:	b570      	push	{r4, r5, r6, lr}
   1f0ac:	4604      	mov	r4, r0
    {
        if (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
   1f0ae:	f100 060c 	add.w	r6, r0, #12
   1f0b2:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1f0b6:	4630      	mov	r0, r6
   1f0b8:	f001 fde4 	bl	20c84 <OSAL_SEM_Pend>
        {
            //SYS_DEBUG LOG
        }
        TCPIP_Helper_SingleListRemoveAll(&pL->list);
   1f0bc:	4625      	mov	r5, r4


// no memory de-allocation is performed, just removes the nodes from the list
static __inline__ void __attribute__((always_inline)) TCPIP_Helper_SingleListRemoveAll(SINGLE_LIST* pL)
{
	while((TCPIP_Helper_SingleListHeadRemove(pL)));
   1f0be:	4628      	mov	r0, r5
   1f0c0:	f001 fe9a 	bl	20df8 <TCPIP_Helper_SingleListHeadRemove>
   1f0c4:	2800      	cmp	r0, #0
   1f0c6:	d1fa      	bne.n	1f0be <TCPIP_Helper_ProtectedSingleListDeinitialize+0x1a>
        OSAL_SEM_Delete(&pL->semaphore);
   1f0c8:	4630      	mov	r0, r6
   1f0ca:	f002 fc4f 	bl	2196c <OSAL_SEM_Delete>
        pL->semValid = false;
   1f0ce:	2300      	movs	r3, #0
   1f0d0:	7423      	strb	r3, [r4, #16]
    }
}
   1f0d2:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListNodeRemove%730:

0001f0d4 <TCPIP_Helper_ProtectedSingleListNodeRemove>:

// removes a node anywhere in the list
// Note: this is lengthy!
// Use a double linked list if faster operation needed!
SGL_LIST_NODE*  TCPIP_Helper_ProtectedSingleListNodeRemove(PROTECTED_SINGLE_LIST* pL, SGL_LIST_NODE* pN)
{
   1f0d4:	b570      	push	{r4, r5, r6, lr}

    if(pL->semValid)
   1f0d6:	7c03      	ldrb	r3, [r0, #16]
   1f0d8:	b913      	cbnz	r3, 1f0e0 <TCPIP_Helper_ProtectedSingleListNodeRemove+0xc>
            //SYS_DEBUG LOG
        }
        return ret;
    }

    return 0;
   1f0da:	2400      	movs	r4, #0
}
   1f0dc:	4620      	mov	r0, r4
   1f0de:	bd70      	pop	{r4, r5, r6, pc}
   1f0e0:	460d      	mov	r5, r1
   1f0e2:	4604      	mov	r4, r0
        if (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
   1f0e4:	f100 060c 	add.w	r6, r0, #12
   1f0e8:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1f0ec:	4630      	mov	r0, r6
   1f0ee:	f001 fdc9 	bl	20c84 <OSAL_SEM_Pend>
        SGL_LIST_NODE * ret = TCPIP_Helper_SingleListNodeRemove(&pL->list, pN);
   1f0f2:	4629      	mov	r1, r5
   1f0f4:	4620      	mov	r0, r4
   1f0f6:	f7fd ffe2 	bl	1d0be <TCPIP_Helper_SingleListNodeRemove>
   1f0fa:	4604      	mov	r4, r0
        if (OSAL_SEM_Post(&pL->semaphore) != OSAL_RESULT_TRUE)
   1f0fc:	4630      	mov	r0, r6
   1f0fe:	f002 f9d9 	bl	214b4 <OSAL_SEM_Post>
        return ret;
   1f102:	e7eb      	b.n	1f0dc <TCPIP_Helper_ProtectedSingleListNodeRemove+0x8>

Disassembly of section .text.TCPIP_STACK_InitializeDataGet%731:

0001f104 <TCPIP_STACK_InitializeDataGet>:
    if(object != (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data)
   1f104:	4b09      	ldr	r3, [pc, #36]	; (1f12c <TCPIP_STACK_InitializeDataGet+0x28>)
   1f106:	4283      	cmp	r3, r0
   1f108:	d10c      	bne.n	1f124 <TCPIP_STACK_InitializeDataGet+0x20>
    if(pStackInit)
   1f10a:	b169      	cbz	r1, 1f128 <TCPIP_STACK_InitializeDataGet+0x24>
{
   1f10c:	b430      	push	{r4, r5}
        *pStackInit = tcpip_init_data;
   1f10e:	460c      	mov	r4, r1
   1f110:	4d07      	ldr	r5, [pc, #28]	; (1f130 <TCPIP_STACK_InitializeDataGet+0x2c>)
   1f112:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1f114:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1f116:	e895 0003 	ldmia.w	r5, {r0, r1}
   1f11a:	e884 0003 	stmia.w	r4, {r0, r1}
    return true;
   1f11e:	2001      	movs	r0, #1
}
   1f120:	bc30      	pop	{r4, r5}
   1f122:	4770      	bx	lr
        return false;
   1f124:	2000      	movs	r0, #0
   1f126:	4770      	bx	lr
    return true;
   1f128:	2001      	movs	r0, #1
}
   1f12a:	4770      	bx	lr
   1f12c:	2000e2f0 	.word	0x2000e2f0
   1f130:	2000e3fc 	.word	0x2000e3fc

Disassembly of section .text.TCPIP_PKT_Initialize%732:

0001f134 <TCPIP_PKT_Initialize>:
{
   1f134:	b510      	push	{r4, lr}
    pktMemH = 0;
   1f136:	4b0a      	ldr	r3, [pc, #40]	; (1f160 <TCPIP_PKT_Initialize+0x2c>)
   1f138:	2200      	movs	r2, #0
   1f13a:	601a      	str	r2, [r3, #0]
    while(heapH != 0)
   1f13c:	b150      	cbz	r0, 1f154 <TCPIP_PKT_Initialize+0x20>
   1f13e:	4604      	mov	r4, r0
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
   1f140:	6843      	ldr	r3, [r0, #4]
   1f142:	2134      	movs	r1, #52	; 0x34
   1f144:	4798      	blx	r3
        if(allocPtr == 0)
   1f146:	4601      	mov	r1, r0
   1f148:	b120      	cbz	r0, 1f154 <TCPIP_PKT_Initialize+0x20>
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   1f14a:	68e3      	ldr	r3, [r4, #12]
   1f14c:	4620      	mov	r0, r4
   1f14e:	4798      	blx	r3
        pktMemH = heapH;
   1f150:	4b03      	ldr	r3, [pc, #12]	; (1f160 <TCPIP_PKT_Initialize+0x2c>)
   1f152:	601c      	str	r4, [r3, #0]
    return pktMemH != 0;
   1f154:	4b02      	ldr	r3, [pc, #8]	; (1f160 <TCPIP_PKT_Initialize+0x2c>)
   1f156:	6818      	ldr	r0, [r3, #0]
}
   1f158:	3000      	adds	r0, #0
   1f15a:	bf18      	it	ne
   1f15c:	2001      	movne	r0, #1
   1f15e:	bd10      	pop	{r4, pc}
   1f160:	2000e658 	.word	0x2000e658

Disassembly of section .text.TCPIP_UDP_Close%733:

0001f164 <TCPIP_UDP_Close>:
{
   1f164:	b538      	push	{r3, r4, r5, lr}
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1f166:	f000 febd 	bl	1fee4 <_UDPSocketDcpt>
    if(pSkt)
   1f16a:	b908      	cbnz	r0, 1f170 <TCPIP_UDP_Close+0xc>
    return false;
   1f16c:	2000      	movs	r0, #0
}
   1f16e:	bd38      	pop	{r3, r4, r5, pc}
   1f170:	4604      	mov	r4, r0
    OSAL_SEM_Pend(&userSem, OSAL_WAIT_FOREVER);
   1f172:	4d07      	ldr	r5, [pc, #28]	; (1f190 <TCPIP_UDP_Close+0x2c>)
   1f174:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1f178:	4628      	mov	r0, r5
   1f17a:	f001 fd83 	bl	20c84 <OSAL_SEM_Pend>
        _UDPClose(pSkt);
   1f17e:	4620      	mov	r0, r4
   1f180:	f7fd fb3c 	bl	1c7fc <_UDPClose>
    OSAL_SEM_Post(&userSem);
   1f184:	4628      	mov	r0, r5
   1f186:	f002 f995 	bl	214b4 <OSAL_SEM_Post>
        return true;
   1f18a:	2001      	movs	r0, #1
   1f18c:	e7ef      	b.n	1f16e <TCPIP_UDP_Close+0xa>
   1f18e:	bf00      	nop
   1f190:	2000e670 	.word	0x2000e670

Disassembly of section .text.SendCommandCharacter%734:

0001f194 <SendCommandCharacter>:
{
   1f194:	b500      	push	{lr}
   1f196:	b083      	sub	sp, #12
   1f198:	f88d 1007 	strb.w	r1, [sp, #7]
    if (SYS_CONSOLE_Status((SYS_MODULE_OBJ)_cmdInitData.consoleIndex) == SYS_STATUS_READY)
   1f19c:	4b08      	ldr	r3, [pc, #32]	; (1f1c0 <SendCommandCharacter+0x2c>)
   1f19e:	8858      	ldrh	r0, [r3, #2]
   1f1a0:	f7fd f934 	bl	1c40c <SYS_CONSOLE_Status>
   1f1a4:	2802      	cmp	r0, #2
   1f1a6:	d002      	beq.n	1f1ae <SendCommandCharacter+0x1a>
}
   1f1a8:	b003      	add	sp, #12
   1f1aa:	f85d fb04 	ldr.w	pc, [sp], #4
        SYS_CONSOLE_Write(_cmdInitData.consoleIndex, (const char*)&c, 1);
   1f1ae:	2201      	movs	r2, #1
   1f1b0:	f10d 0107 	add.w	r1, sp, #7
   1f1b4:	4b02      	ldr	r3, [pc, #8]	; (1f1c0 <SendCommandCharacter+0x2c>)
   1f1b6:	8858      	ldrh	r0, [r3, #2]
   1f1b8:	f7ff fcba 	bl	1eb30 <SYS_CONSOLE_Write>
}
   1f1bc:	e7f4      	b.n	1f1a8 <SendCommandCharacter+0x14>
   1f1be:	bf00      	nop
   1f1c0:	2000e674 	.word	0x2000e674

Disassembly of section .text._keyEndProcess%735:

0001f1c4 <_keyEndProcess>:
    int nChars = pCmdIO->cmdEnd - pCmdIO->cmdPnt;
   1f1c4:	69c2      	ldr	r2, [r0, #28]
   1f1c6:	6983      	ldr	r3, [r0, #24]
    if(nChars)
   1f1c8:	1ad2      	subs	r2, r2, r3
   1f1ca:	d010      	beq.n	1f1ee <_keyEndProcess+0x2a>
{   // end key
   1f1cc:	b570      	push	{r4, r5, r6, lr}
   1f1ce:	b084      	sub	sp, #16
   1f1d0:	4604      	mov	r4, r0
    const SYS_CMD_API* pCmdApi = pCmdIO->devNode.pCmdApi;
   1f1d2:	6806      	ldr	r6, [r0, #0]
    const void* cmdIoParam = pCmdIO->devNode.cmdIoParam;
   1f1d4:	6845      	ldr	r5, [r0, #4]
        sprintf(endBuff, "\x1b[%dC", nChars);
   1f1d6:	4906      	ldr	r1, [pc, #24]	; (1f1f0 <_keyEndProcess+0x2c>)
   1f1d8:	a801      	add	r0, sp, #4
   1f1da:	f7fe f9b5 	bl	1d548 <siprintf>
        (*pCmdApi->msg)(cmdIoParam, endBuff);
   1f1de:	6833      	ldr	r3, [r6, #0]
   1f1e0:	a901      	add	r1, sp, #4
   1f1e2:	4628      	mov	r0, r5
   1f1e4:	4798      	blx	r3
        pCmdIO->cmdPnt = pCmdIO->cmdEnd;
   1f1e6:	69e3      	ldr	r3, [r4, #28]
   1f1e8:	61a3      	str	r3, [r4, #24]
}
   1f1ea:	b004      	add	sp, #16
   1f1ec:	bd70      	pop	{r4, r5, r6, pc}
   1f1ee:	4770      	bx	lr
   1f1f0:	0000d1b4 	.word	0x0000d1b4

Disassembly of section .text._keyHomeProcess%736:

0001f1f4 <_keyHomeProcess>:
{   // home key
   1f1f4:	b5f0      	push	{r4, r5, r6, r7, lr}
   1f1f6:	b085      	sub	sp, #20
    int nChars = pCmdIO->cmdPnt - pCmdIO->cmdBuff;
   1f1f8:	f100 0520 	add.w	r5, r0, #32
   1f1fc:	6982      	ldr	r2, [r0, #24]
    if(nChars != 0)
   1f1fe:	1b52      	subs	r2, r2, r5
   1f200:	d00b      	beq.n	1f21a <_keyHomeProcess+0x26>
   1f202:	4604      	mov	r4, r0
    const SYS_CMD_API* pCmdApi = pCmdIO->devNode.pCmdApi;
   1f204:	6807      	ldr	r7, [r0, #0]
    const void* cmdIoParam = pCmdIO->devNode.cmdIoParam;
   1f206:	6846      	ldr	r6, [r0, #4]
        sprintf(homeBuff, "\x1b[%dD", nChars);
   1f208:	4905      	ldr	r1, [pc, #20]	; (1f220 <_keyHomeProcess+0x2c>)
   1f20a:	a801      	add	r0, sp, #4
   1f20c:	f7fe f99c 	bl	1d548 <siprintf>
        (*pCmdApi->msg)(cmdIoParam, homeBuff);
   1f210:	683b      	ldr	r3, [r7, #0]
   1f212:	a901      	add	r1, sp, #4
   1f214:	4630      	mov	r0, r6
   1f216:	4798      	blx	r3
        pCmdIO->cmdPnt = pCmdIO->cmdBuff;
   1f218:	61a5      	str	r5, [r4, #24]
}
   1f21a:	b005      	add	sp, #20
   1f21c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f21e:	bf00      	nop
   1f220:	0000d1bc 	.word	0x0000d1bc

Disassembly of section .text.SYS_CONSOLE_Message%737:

0001f224 <SYS_CONSOLE_Message>:

void SYS_CONSOLE_Message(const SYS_CONSOLE_HANDLE handle, const char *message)
{
    SYS_CONSOLE_OBJECT_INSTANCE* pConsoleObj = SYS_CONSOLE_GET_INSTANCE(handle);
   1f224:	b990      	cbnz	r0, 1f24c <SYS_CONSOLE_Message+0x28>
{
   1f226:	b538      	push	{r3, r4, r5, lr}
    if (pConsoleObj == NULL)
    {
        return;
    }

    if (pConsoleObj->status == SYS_STATUS_UNINITIALIZED || pConsoleObj->devDesc == NULL)
   1f228:	4b09      	ldr	r3, [pc, #36]	; (1f250 <SYS_CONSOLE_Message+0x2c>)
   1f22a:	f993 3000 	ldrsb.w	r3, [r3]
   1f22e:	b163      	cbz	r3, 1f24a <SYS_CONSOLE_Message+0x26>
   1f230:	4b07      	ldr	r3, [pc, #28]	; (1f250 <SYS_CONSOLE_Message+0x2c>)
   1f232:	685d      	ldr	r5, [r3, #4]
   1f234:	b14d      	cbz	r5, 1f24a <SYS_CONSOLE_Message+0x26>
   1f236:	460c      	mov	r4, r1
    {
        return;
    }

    pConsoleObj->devDesc->write(pConsoleObj->devIndex, message, strlen(message));
   1f238:	4608      	mov	r0, r1
   1f23a:	f002 fcaf 	bl	21b9c <strlen>
   1f23e:	696b      	ldr	r3, [r5, #20]
   1f240:	4602      	mov	r2, r0
   1f242:	4621      	mov	r1, r4
   1f244:	4802      	ldr	r0, [pc, #8]	; (1f250 <SYS_CONSOLE_Message+0x2c>)
   1f246:	6880      	ldr	r0, [r0, #8]
   1f248:	4798      	blx	r3
}
   1f24a:	bd38      	pop	{r3, r4, r5, pc}
   1f24c:	4770      	bx	lr
   1f24e:	bf00      	nop
   1f250:	2000e540 	.word	0x2000e540

Disassembly of section .text.SYS_TIME_UpdateTimerList%738:

0001f254 <SYS_TIME_UpdateTimerList>:
    tmr = counterObj->tmrActive;
   1f254:	4b0a      	ldr	r3, [pc, #40]	; (1f280 <SYS_TIME_UpdateTimerList+0x2c>)
   1f256:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    while ((tmr != NULL) && (elapsedCount > 0))
   1f258:	b173      	cbz	r3, 1f278 <SYS_TIME_UpdateTimerList+0x24>
   1f25a:	b168      	cbz	r0, 1f278 <SYS_TIME_UpdateTimerList+0x24>
            tmr->relativeTimePending = 0;
   1f25c:	2100      	movs	r1, #0
   1f25e:	e005      	b.n	1f26c <SYS_TIME_UpdateTimerList+0x18>
            elapsedCount -= tmr->relativeTimePending;
   1f260:	689a      	ldr	r2, [r3, #8]
   1f262:	1a80      	subs	r0, r0, r2
            tmr->relativeTimePending = 0;
   1f264:	6099      	str	r1, [r3, #8]
        tmr = tmr->tmrNext;
   1f266:	699b      	ldr	r3, [r3, #24]
    while ((tmr != NULL) && (elapsedCount > 0))
   1f268:	b133      	cbz	r3, 1f278 <SYS_TIME_UpdateTimerList+0x24>
   1f26a:	b128      	cbz	r0, 1f278 <SYS_TIME_UpdateTimerList+0x24>
        if (tmr->relativeTimePending >= elapsedCount)
   1f26c:	689a      	ldr	r2, [r3, #8]
   1f26e:	4282      	cmp	r2, r0
   1f270:	d3f6      	bcc.n	1f260 <SYS_TIME_UpdateTimerList+0xc>
            tmr->relativeTimePending -= elapsedCount;
   1f272:	689a      	ldr	r2, [r3, #8]
   1f274:	1a10      	subs	r0, r2, r0
   1f276:	6098      	str	r0, [r3, #8]
    counterObj->hwTimerPreviousValue = counterObj->hwTimerCurrentValue;
   1f278:	4b01      	ldr	r3, [pc, #4]	; (1f280 <SYS_TIME_UpdateTimerList+0x2c>)
   1f27a:	695a      	ldr	r2, [r3, #20]
   1f27c:	611a      	str	r2, [r3, #16]
}
   1f27e:	4770      	bx	lr
   1f280:	2000e230 	.word	0x2000e230

Disassembly of section .text.xQueueGenericCreate%739:

0001f284 <xQueueGenericCreate>:
	{
   1f284:	b570      	push	{r4, r5, r6, lr}
   1f286:	4606      	mov	r6, r0
   1f288:	460d      	mov	r5, r1
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1f28a:	fb01 f000 	mul.w	r0, r1, r0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
   1f28e:	3048      	adds	r0, #72	; 0x48
   1f290:	f7fb faa2 	bl	1a7d8 <pvPortMalloc>
		if( pxNewQueue != NULL )
   1f294:	4604      	mov	r4, r0
   1f296:	b148      	cbz	r0, 1f2ac <xQueueGenericCreate+0x28>
	if( uxItemSize == ( UBaseType_t ) 0 )
   1f298:	b155      	cbz	r5, 1f2b0 <xQueueGenericCreate+0x2c>
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
   1f29a:	f100 0348 	add.w	r3, r0, #72	; 0x48
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
   1f29e:	6023      	str	r3, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
   1f2a0:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
   1f2a2:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
   1f2a4:	2101      	movs	r1, #1
   1f2a6:	4620      	mov	r0, r4
   1f2a8:	f7fb f840 	bl	1a32c <xQueueGenericReset>
	}
   1f2ac:	4620      	mov	r0, r4
   1f2ae:	bd70      	pop	{r4, r5, r6, pc}
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
   1f2b0:	4603      	mov	r3, r0
   1f2b2:	e7f4      	b.n	1f29e <xQueueGenericCreate+0x1a>

Disassembly of section .text.wc_CryptoCb_FindDevice%740:

0001f2b4 <wc_CryptoCb_FindDevice>:
        if (gCryptoDev[i].devId == devId)
   1f2b4:	4b0a      	ldr	r3, [pc, #40]	; (1f2e0 <wc_CryptoCb_FindDevice+0x2c>)
   1f2b6:	681b      	ldr	r3, [r3, #0]
   1f2b8:	4298      	cmp	r0, r3
   1f2ba:	d00a      	beq.n	1f2d2 <wc_CryptoCb_FindDevice+0x1e>
   1f2bc:	4a08      	ldr	r2, [pc, #32]	; (1f2e0 <wc_CryptoCb_FindDevice+0x2c>)
    for (i=0; i<MAX_CRYPTO_DEVID_CALLBACKS; i++) {
   1f2be:	2301      	movs	r3, #1
        if (gCryptoDev[i].devId == devId)
   1f2c0:	68d1      	ldr	r1, [r2, #12]
   1f2c2:	4281      	cmp	r1, r0
   1f2c4:	d006      	beq.n	1f2d4 <wc_CryptoCb_FindDevice+0x20>
    for (i=0; i<MAX_CRYPTO_DEVID_CALLBACKS; i++) {
   1f2c6:	3301      	adds	r3, #1
   1f2c8:	320c      	adds	r2, #12
   1f2ca:	2b08      	cmp	r3, #8
   1f2cc:	d1f8      	bne.n	1f2c0 <wc_CryptoCb_FindDevice+0xc>
    return NULL;
   1f2ce:	2000      	movs	r0, #0
}
   1f2d0:	4770      	bx	lr
    for (i=0; i<MAX_CRYPTO_DEVID_CALLBACKS; i++) {
   1f2d2:	2300      	movs	r3, #0
            return &gCryptoDev[i];
   1f2d4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1f2d8:	4801      	ldr	r0, [pc, #4]	; (1f2e0 <wc_CryptoCb_FindDevice+0x2c>)
   1f2da:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   1f2de:	4770      	bx	lr
   1f2e0:	2000e0e4 	.word	0x2000e0e4

Disassembly of section .rodata.seedA_data%741:

0001f2e4 <seedA_data>:
   1f2e4:	77333663 46861ee4 b40aeb8d 3f68eda8     c63w...F......h?
   1f2f4:	474e136a 00c714e0 e9814e45 69a55853     j.NG....EN..SX.i
   1f304:	8fa38a80 23a6722a 9f5a9159 68ca048a     ....*r.#Y.Z....h

Disassembly of section .rodata.seedB_data%742:

0001f314 <seedB_data>:
   1f314:	f3d05aa6 0e4edb45 c375e8ff 421fe7a2     .Z..E.N...u....B
   1f324:	629d12c7 19c1f50f f055efa9 fbe08551     ...b......U.Q...
   1f334:	31f98185 6e271775 7d60e906 2ecccbdb     ...1u.'n..`}....

Disassembly of section .text.APP_Initialize%743:

0001f344 <APP_Initialize>:
{
   1f344:	b508      	push	{r3, lr}
	appData.state = APP_DISPLAY_INIT;    
   1f346:	4b09      	ldr	r3, [pc, #36]	; (1f36c <APP_Initialize+0x28>)
   1f348:	2201      	movs	r2, #1
   1f34a:	701a      	strb	r2, [r3, #0]
    LED1_Set();
   1f34c:	4b08      	ldr	r3, [pc, #32]	; (1f370 <APP_Initialize+0x2c>)
   1f34e:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   1f352:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    LED2_Set();
   1f356:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   1f35a:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    LED3_Set();
   1f35e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   1f362:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
    MyTxQueueErase();
   1f366:	f000 fb19 	bl	1f99c <MyTxQueueErase>
}
   1f36a:	bd08      	pop	{r3, pc}
   1f36c:	2000e710 	.word	0x2000e710
   1f370:	41008000 	.word	0x41008000

Disassembly of section .text%744:

0001f374 <__aeabi_uldivmod>:
   1f374:	b953      	cbnz	r3, 1f38c <__aeabi_uldivmod+0x18>
   1f376:	b94a      	cbnz	r2, 1f38c <__aeabi_uldivmod+0x18>
   1f378:	2900      	cmp	r1, #0
   1f37a:	bf08      	it	eq
   1f37c:	2800      	cmpeq	r0, #0
   1f37e:	bf1c      	itt	ne
   1f380:	f04f 31ff 	movne.w	r1, #4294967295
   1f384:	f04f 30ff 	movne.w	r0, #4294967295
   1f388:	f002 bee6 	b.w	22158 <__aeabi_idiv0>
   1f38c:	f1ad 0c08 	sub.w	ip, sp, #8
   1f390:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   1f394:	f7ec fd8c 	bl	beb0 <__udivmoddi4>
   1f398:	f8dd e004 	ldr.w	lr, [sp, #4]
   1f39c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   1f3a0:	b004      	add	sp, #16
   1f3a2:	4770      	bx	lr

Disassembly of section .text._XtlEventsTcp2Eth%745:

0001f3a4 <_XtlEventsTcp2Eth>:
	eEvents |= (tcpEv&(TCPIP_MAC_EV_RX_DONE))? GMAC_EV_RXCOMPLETE:0;	
   1f3a4:	10c3      	asrs	r3, r0, #3
   1f3a6:	f003 0302 	and.w	r3, r3, #2
	eEvents |= (tcpEv&(TCPIP_MAC_EV_RX_OVFLOW))? GMAC_EV_RXOVERRUN:0;
   1f3aa:	0242      	lsls	r2, r0, #9
   1f3ac:	f402 6280 	and.w	r2, r2, #1024	; 0x400
	eEvents |= (tcpEv&(TCPIP_MAC_EV_RX_BUFNA))? GMAC_EV_RXUSEDBITREAD:0; // mapping RX Used bit interrupt to BUFNA;
   1f3b0:	4313      	orrs	r3, r2
   1f3b2:	f000 0204 	and.w	r2, r0, #4
   1f3b6:	4313      	orrs	r3, r2
	eEvents |= (tcpEv&(TCPIP_MAC_EV_TX_BUSERR))? GMAC_EV_TXFRAMECORRUPT:0;
   1f3b8:	1102      	asrs	r2, r0, #4
   1f3ba:	f002 0240 	and.w	r2, r2, #64	; 0x40
	eEvents |= (tcpEv&(TCPIP_MAC_EV_RX_BUFNA))? GMAC_EV_RXUSEDBITREAD:0; // mapping RX Used bit interrupt to BUFNA;
   1f3be:	4313      	orrs	r3, r2
    eEvents |= (tcpEv&(TCPIP_MAC_EV_TX_ABORT))? GMAC_EV_TXUNDERRUN:0;
   1f3c0:	1142      	asrs	r2, r0, #5
   1f3c2:	f002 0210 	and.w	r2, r2, #16
	eEvents |= (tcpEv&(TCPIP_MAC_EV_RX_BUFNA))? GMAC_EV_RXUSEDBITREAD:0; // mapping RX Used bit interrupt to BUFNA;
   1f3c6:	4313      	orrs	r3, r2
	eEvents = (tcpEv&(TCPIP_MAC_EV_TX_DONE))? GMAC_EV_TXCOMPLETE:0;	
   1f3c8:	1040      	asrs	r0, r0, #1
   1f3ca:	f000 0080 	and.w	r0, r0, #128	; 0x80
}
   1f3ce:	4318      	orrs	r0, r3
   1f3d0:	4770      	bx	lr

Disassembly of section .text._DRV_MIIM_GetObjectAndLock%746:

0001f3d2 <_DRV_MIIM_GetObjectAndLock>:
{
   1f3d2:	b510      	push	{r4, lr}
    if(pMiimObj != 0)
   1f3d4:	b168      	cbz	r0, 1f3f2 <_DRV_MIIM_GetObjectAndLock+0x20>
    pMiimObj = (DRV_MIIM_OBJ*)object;
   1f3d6:	4604      	mov	r4, r0
        if(pMiimObj->objStatus == SYS_STATUS_READY && (pMiimObj->objFlags & DRV_MIIM_OBJ_FLAG_IN_USE) != 0)
   1f3d8:	f990 2008 	ldrsb.w	r2, [r0, #8]
   1f3dc:	2a02      	cmp	r2, #2
   1f3de:	d10a      	bne.n	1f3f6 <_DRV_MIIM_GetObjectAndLock+0x24>
   1f3e0:	8882      	ldrh	r2, [r0, #4]
   1f3e2:	f012 0f01 	tst.w	r2, #1
   1f3e6:	d009      	beq.n	1f3fc <_DRV_MIIM_GetObjectAndLock+0x2a>
    OSAL_SEM_Pend(&pMiimObj->objSem, OSAL_WAIT_FOREVER);
   1f3e8:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1f3ec:	f001 fc4a 	bl	20c84 <OSAL_SEM_Pend>
        return pMiimObj;
   1f3f0:	e002      	b.n	1f3f8 <_DRV_MIIM_GetObjectAndLock+0x26>
    return 0;
   1f3f2:	2400      	movs	r4, #0
   1f3f4:	e000      	b.n	1f3f8 <_DRV_MIIM_GetObjectAndLock+0x26>
   1f3f6:	2400      	movs	r4, #0
}
   1f3f8:	4620      	mov	r0, r4
   1f3fa:	bd10      	pop	{r4, pc}
    return 0;
   1f3fc:	2400      	movs	r4, #0
   1f3fe:	e7fb      	b.n	1f3f8 <_DRV_MIIM_GetObjectAndLock+0x26>

Disassembly of section .text.DRV_MIIM_DeregisterCallback%747:

0001f400 <DRV_MIIM_DeregisterCallback>:
{
   1f400:	b510      	push	{r4, lr}
   1f402:	460c      	mov	r4, r1
        if((pClient = _DRV_MIIM_GetClientAndLock(handle, true)) == 0)
   1f404:	2101      	movs	r1, #1
   1f406:	f7fd f8a0 	bl	1c54a <_DRV_MIIM_GetClientAndLock>
   1f40a:	b150      	cbz	r0, 1f422 <DRV_MIIM_DeregisterCallback+0x22>
   1f40c:	4603      	mov	r3, r0
        if(pClient->cbackHandler != (DRV_MIIM_OPERATION_CALLBACK)cbHandle)
   1f40e:	6882      	ldr	r2, [r0, #8]
   1f410:	42a2      	cmp	r2, r4
   1f412:	d109      	bne.n	1f428 <DRV_MIIM_DeregisterCallback+0x28>
        pClient->cbackHandler = 0;
   1f414:	2400      	movs	r4, #0
   1f416:	6084      	str	r4, [r0, #8]
    OSAL_SEM_Post(&pMiimObj->objSem);
   1f418:	6858      	ldr	r0, [r3, #4]
   1f41a:	f002 f84b 	bl	214b4 <OSAL_SEM_Post>
}
   1f41e:	4620      	mov	r0, r4
   1f420:	bd10      	pop	{r4, pc}
            res = DRV_MIIM_RES_HANDLE_ERR;
   1f422:	f04f 34ff 	mov.w	r4, #4294967295
   1f426:	e7fa      	b.n	1f41e <DRV_MIIM_DeregisterCallback+0x1e>
            res = DRV_MIIM_RES_CALLBACK_HANDLE_ERR;
   1f428:	f06f 0402 	mvn.w	r4, #2
   1f42c:	e7f4      	b.n	1f418 <DRV_MIIM_DeregisterCallback+0x18>

Disassembly of section .text.TCPIP_TCP_Connect%748:

0001f42e <TCPIP_TCP_Connect>:
{
   1f42e:	b510      	push	{r4, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   1f430:	f000 fc40 	bl	1fcb4 <_TcpSocketChk>
    if(pSkt && pSkt->smState == TCPIP_TCP_STATE_CLIENT_WAIT_CONNECT)
   1f434:	b180      	cbz	r0, 1f458 <TCPIP_TCP_Connect+0x2a>
   1f436:	4604      	mov	r4, r0
   1f438:	f890 306e 	ldrb.w	r3, [r0, #110]	; 0x6e
   1f43c:	2b0b      	cmp	r3, #11
   1f43e:	d001      	beq.n	1f444 <TCPIP_TCP_Connect+0x16>
    return false;
   1f440:	2000      	movs	r0, #0
}
   1f442:	bd10      	pop	{r4, pc}
        if(_TcpClientSocketConnect(pSkt) >= 0)
   1f444:	f7fc f8d8 	bl	1b5f8 <_TcpClientSocketConnect>
   1f448:	2800      	cmp	r0, #0
   1f44a:	da01      	bge.n	1f450 <TCPIP_TCP_Connect+0x22>
    return false;
   1f44c:	2000      	movs	r0, #0
   1f44e:	e7f8      	b.n	1f442 <TCPIP_TCP_Connect+0x14>
    pSkt->smState = newState;
   1f450:	2001      	movs	r0, #1
   1f452:	f884 006e 	strb.w	r0, [r4, #110]	; 0x6e
            return true;
   1f456:	e7f4      	b.n	1f442 <TCPIP_TCP_Connect+0x14>
    return false;
   1f458:	2000      	movs	r0, #0
   1f45a:	e7f2      	b.n	1f442 <TCPIP_TCP_Connect+0x14>

Disassembly of section .text._DHCPOptionProcessLease%749:

0001f45c <_DHCPOptionProcessLease>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_LEASE_TIME))
   1f45c:	684b      	ldr	r3, [r1, #4]
   1f45e:	2b05      	cmp	r3, #5
   1f460:	d90d      	bls.n	1f47e <_DHCPOptionProcessLease+0x22>
        TCPIP_DHCP_OPTION_DATA_LEASE_TIME* pLease = (TCPIP_DHCP_OPTION_DATA_LEASE_TIME*)pOptData->pOpt;
   1f462:	680b      	ldr	r3, [r1, #0]
        if(pLease->len == sizeof(pLease->lease))
   1f464:	785a      	ldrb	r2, [r3, #1]
   1f466:	2a04      	cmp	r2, #4
   1f468:	d10c      	bne.n	1f484 <_DHCPOptionProcessLease+0x28>
            pOptData->leaseTime.v[3] = pLease->lease[0];
   1f46a:	789a      	ldrb	r2, [r3, #2]
   1f46c:	74ca      	strb	r2, [r1, #19]
            pOptData->leaseTime.v[2] = pLease->lease[1];
   1f46e:	78da      	ldrb	r2, [r3, #3]
   1f470:	748a      	strb	r2, [r1, #18]
            pOptData->leaseTime.v[1] = pLease->lease[2];
   1f472:	791a      	ldrb	r2, [r3, #4]
   1f474:	744a      	strb	r2, [r1, #17]
            pOptData->leaseTime.v[0] = pLease->lease[3];
   1f476:	795b      	ldrb	r3, [r3, #5]
   1f478:	740b      	strb	r3, [r1, #16]
            return sizeof(TCPIP_DHCP_OPTION_DATA_LEASE_TIME);
   1f47a:	2006      	movs	r0, #6
   1f47c:	4770      	bx	lr
    return -1;
   1f47e:	f04f 30ff 	mov.w	r0, #4294967295
   1f482:	4770      	bx	lr
   1f484:	f04f 30ff 	mov.w	r0, #4294967295
}
   1f488:	4770      	bx	lr

Disassembly of section .text._DHCPOptionProcessRenewT%750:

0001f48a <_DHCPOptionProcessRenewT>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_RENEW_TIME))
   1f48a:	684b      	ldr	r3, [r1, #4]
   1f48c:	2b05      	cmp	r3, #5
   1f48e:	d90d      	bls.n	1f4ac <_DHCPOptionProcessRenewT+0x22>
        TCPIP_DHCP_OPTION_DATA_RENEW_TIME* pRenew = (TCPIP_DHCP_OPTION_DATA_RENEW_TIME*)pOptData->pOpt;
   1f490:	680b      	ldr	r3, [r1, #0]
        if(pRenew->len == sizeof(pRenew->tRenew))
   1f492:	785a      	ldrb	r2, [r3, #1]
   1f494:	2a04      	cmp	r2, #4
   1f496:	d10c      	bne.n	1f4b2 <_DHCPOptionProcessRenewT+0x28>
            pOptData->renewTime.v[3] = pRenew->tRenew[0];
   1f498:	789a      	ldrb	r2, [r3, #2]
   1f49a:	75ca      	strb	r2, [r1, #23]
            pOptData->renewTime.v[2] = pRenew->tRenew[1];
   1f49c:	78da      	ldrb	r2, [r3, #3]
   1f49e:	758a      	strb	r2, [r1, #22]
            pOptData->renewTime.v[1] = pRenew->tRenew[2];
   1f4a0:	791a      	ldrb	r2, [r3, #4]
   1f4a2:	754a      	strb	r2, [r1, #21]
            pOptData->renewTime.v[0] = pRenew->tRenew[3];
   1f4a4:	795b      	ldrb	r3, [r3, #5]
   1f4a6:	750b      	strb	r3, [r1, #20]
            return sizeof(TCPIP_DHCP_OPTION_DATA_RENEW_TIME);
   1f4a8:	2006      	movs	r0, #6
   1f4aa:	4770      	bx	lr
    return -1;
   1f4ac:	f04f 30ff 	mov.w	r0, #4294967295
   1f4b0:	4770      	bx	lr
   1f4b2:	f04f 30ff 	mov.w	r0, #4294967295
}
   1f4b6:	4770      	bx	lr

Disassembly of section .text._DHCPOptionProcessRebindT%751:

0001f4b8 <_DHCPOptionProcessRebindT>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_REBIND_TIME))
   1f4b8:	684b      	ldr	r3, [r1, #4]
   1f4ba:	2b05      	cmp	r3, #5
   1f4bc:	d90d      	bls.n	1f4da <_DHCPOptionProcessRebindT+0x22>
        TCPIP_DHCP_OPTION_DATA_REBIND_TIME* pRebind = (TCPIP_DHCP_OPTION_DATA_REBIND_TIME*)pOptData->pOpt;
   1f4be:	680b      	ldr	r3, [r1, #0]
        if(pRebind->len == sizeof(pRebind->tRebind))
   1f4c0:	785a      	ldrb	r2, [r3, #1]
   1f4c2:	2a04      	cmp	r2, #4
   1f4c4:	d10c      	bne.n	1f4e0 <_DHCPOptionProcessRebindT+0x28>
            pOptData->rebindTime.v[3] = pRebind->tRebind[0];
   1f4c6:	789a      	ldrb	r2, [r3, #2]
   1f4c8:	76ca      	strb	r2, [r1, #27]
            pOptData->rebindTime.v[2] = pRebind->tRebind[1];
   1f4ca:	78da      	ldrb	r2, [r3, #3]
   1f4cc:	768a      	strb	r2, [r1, #26]
            pOptData->rebindTime.v[1] = pRebind->tRebind[2];
   1f4ce:	791a      	ldrb	r2, [r3, #4]
   1f4d0:	764a      	strb	r2, [r1, #25]
            pOptData->rebindTime.v[0] = pRebind->tRebind[3];
   1f4d2:	795b      	ldrb	r3, [r3, #5]
   1f4d4:	760b      	strb	r3, [r1, #24]
            return sizeof(TCPIP_DHCP_OPTION_DATA_REBIND_TIME);
   1f4d6:	2006      	movs	r0, #6
   1f4d8:	4770      	bx	lr
    return -1;
   1f4da:	f04f 30ff 	mov.w	r0, #4294967295
   1f4de:	4770      	bx	lr
   1f4e0:	f04f 30ff 	mov.w	r0, #4294967295
}
   1f4e4:	4770      	bx	lr

Disassembly of section .text._DHCPOptionClientId%752:

0001f4e6 <_DHCPOptionClientId>:
    if(pSendData->writeSpace >= sizeof(*pClientOpt))
   1f4e6:	684b      	ldr	r3, [r1, #4]
   1f4e8:	2b08      	cmp	r3, #8
   1f4ea:	d910      	bls.n	1f50e <_DHCPOptionClientId+0x28>
        pClientOpt = (TCPIP_DHCP_OPTION_DATA_CLIENT_ID*)pSendData->pOpt;
   1f4ec:	680b      	ldr	r3, [r1, #0]
        pClientOpt->opt = TCPIP_DHCP_PARAM_REQUEST_CLIENT_ID;
   1f4ee:	223d      	movs	r2, #61	; 0x3d
   1f4f0:	701a      	strb	r2, [r3, #0]
        pClientOpt->len = sizeof(pClientOpt->cliId);
   1f4f2:	2207      	movs	r2, #7
   1f4f4:	705a      	strb	r2, [r3, #1]
        pClientOpt->cliId.type = TCPIP_BOOT_HW_TYPE;    // standard hardware address
   1f4f6:	2201      	movs	r2, #1
   1f4f8:	709a      	strb	r2, [r3, #2]
        memcpy(pClientOpt->cliId.id, _TCPIPStack_NetMACAddressGet(pNetIf), sizeof(pClientOpt->cliId.id));
   1f4fa:	1cda      	adds	r2, r3, #3
    return pNetIf ? pNetIf->netMACAddr.v : 0;
   1f4fc:	b100      	cbz	r0, 1f500 <_DHCPOptionClientId+0x1a>
   1f4fe:	303c      	adds	r0, #60	; 0x3c
   1f500:	6801      	ldr	r1, [r0, #0]
   1f502:	f8c3 1003 	str.w	r1, [r3, #3]
   1f506:	8883      	ldrh	r3, [r0, #4]
   1f508:	8093      	strh	r3, [r2, #4]
        return sizeof(*pClientOpt);
   1f50a:	2009      	movs	r0, #9
   1f50c:	4770      	bx	lr
    return -1;
   1f50e:	f04f 30ff 	mov.w	r0, #4294967295
}
   1f512:	4770      	bx	lr

Disassembly of section .text._DHCPSetTimeout%753:

0001f514 <_DHCPSetTimeout>:
{
   1f514:	b570      	push	{r4, r5, r6, lr}
   1f516:	4606      	mov	r6, r0
    uint32_t sysFreq = SYS_TMR_TickCounterFrequencyGet();
   1f518:	f000 fd70 	bl	1fffc <SYS_TMR_TickCounterFrequencyGet>
   1f51c:	4604      	mov	r4, r0
    pClient->waitTicks = (pClient->dhcpTmo - TCPIP_DHCP_EXP_BACKOFF_FUZZ) * sysFreq + SYS_RANDOM_PseudoGet() % ((2 * TCPIP_DHCP_EXP_BACKOFF_FUZZ) * sysFreq);
   1f51e:	f8b6 504c 	ldrh.w	r5, [r6, #76]	; 0x4c
   1f522:	3d01      	subs	r5, #1
   1f524:	fb00 f505 	mul.w	r5, r0, r5
   1f528:	f7fb fb64 	bl	1abf4 <rand>
   1f52c:	0064      	lsls	r4, r4, #1
   1f52e:	fbb0 f3f4 	udiv	r3, r0, r4
   1f532:	fb03 0414 	mls	r4, r3, r4, r0
   1f536:	442c      	add	r4, r5
   1f538:	6034      	str	r4, [r6, #0]
    pClient->startWait = SYS_TMR_TickCountGet();
   1f53a:	f000 fd37 	bl	1ffac <SYS_TMR_TickCountGet>
   1f53e:	6070      	str	r0, [r6, #4]
}
   1f540:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text._DNS_CleanCacheEntry%754:

0001f542 <_DNS_CleanCacheEntry>:
    if(pDnsHE->hEntry.flags.busy)
   1f542:	780b      	ldrb	r3, [r1, #0]
   1f544:	f013 0f01 	tst.w	r3, #1
   1f548:	d011      	beq.n	1f56e <_DNS_CleanCacheEntry+0x2c>
{
   1f54a:	b510      	push	{r4, lr}
        if((pDnsHE->hEntry.flags.value & TCPIP_DNS_FLAG_ENTRY_COMPLETE) == 0)
   1f54c:	880b      	ldrh	r3, [r1, #0]
   1f54e:	f013 0f80 	tst.w	r3, #128	; 0x80
   1f552:	d102      	bne.n	1f55a <_DNS_CleanCacheEntry+0x18>
            pDnsDcpt->unsolvedEntries--;
   1f554:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
   1f556:	3b01      	subs	r3, #1
   1f558:	84c3      	strh	r3, [r0, #38]	; 0x26
   1f55a:	460c      	mov	r4, r1
        TCPIP_OAHASH_EntryRemove(pDnsDcpt->hashDcpt, &pDnsHE->hEntry);
   1f55c:	6800      	ldr	r0, [r0, #0]
   1f55e:	f001 ff49 	bl	213f4 <TCPIP_OAHASH_EntryRemove>
        pDnsHE->nIPv4Entries = pDnsHE->nIPv6Entries = 0;
   1f562:	2300      	movs	r3, #0
   1f564:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
   1f568:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
}
   1f56c:	bd10      	pop	{r4, pc}
   1f56e:	4770      	bx	lr

Disassembly of section .text._DNSClientCleanup%755:

0001f570 <_DNSClientCleanup>:
{
   1f570:	b510      	push	{r4, lr}
   1f572:	4604      	mov	r4, r0
    if(pDnsDcpt->dnsSocket != INVALID_UDP_SOCKET)
   1f574:	f9b0 0024 	ldrsh.w	r0, [r0, #36]	; 0x24
   1f578:	f1b0 3fff 	cmp.w	r0, #4294967295
   1f57c:	d109      	bne.n	1f592 <_DNSClientCleanup+0x22>
    if( pDnsDcpt->dnsSignalHandle)
   1f57e:	68e0      	ldr	r0, [r4, #12]
   1f580:	b118      	cbz	r0, 1f58a <_DNSClientCleanup+0x1a>
       _TCPIPStackSignalHandlerDeregister( pDnsDcpt->dnsSignalHandle);
   1f582:	f002 fb4e 	bl	21c22 <_TCPIPStackSignalHandlerDeregister>
        pDnsDcpt->dnsSignalHandle = 0;
   1f586:	2300      	movs	r3, #0
   1f588:	60e3      	str	r3, [r4, #12]
    _DNS_DeleteHash(pDnsDcpt);
   1f58a:	4620      	mov	r0, r4
   1f58c:	f7fc fc84 	bl	1be98 <_DNS_DeleteHash>
}
   1f590:	bd10      	pop	{r4, pc}
        TCPIP_UDP_Close(pDnsDcpt->dnsSocket);
   1f592:	f7ff fde7 	bl	1f164 <TCPIP_UDP_Close>
        pDnsDcpt->dnsSocket = INVALID_UDP_SOCKET;
   1f596:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1f59a:	84a3      	strh	r3, [r4, #36]	; 0x24
   1f59c:	e7ef      	b.n	1f57e <_DNSClientCleanup+0xe>

Disassembly of section .text.TCPIP_STACK_DNSServiceCanStart%756:

0001f59e <TCPIP_STACK_DNSServiceCanStart>:
    if(pNetIf)
   1f59e:	b198      	cbz	r0, 1f5c8 <TCPIP_STACK_DNSServiceCanStart+0x2a>
        if(dnsSvcType == TCPIP_STACK_DNS_SERVICE_SERVER)
   1f5a0:	2902      	cmp	r1, #2
   1f5a2:	d003      	beq.n	1f5ac <TCPIP_STACK_DNSServiceCanStart+0xe>
        else if(dnsSvcType == TCPIP_STACK_DNS_SERVICE_CLIENT)
   1f5a4:	2901      	cmp	r1, #1
   1f5a6:	d008      	beq.n	1f5ba <TCPIP_STACK_DNSServiceCanStart+0x1c>
    return false;
   1f5a8:	2000      	movs	r0, #0
}
   1f5aa:	4770      	bx	lr
            return (pNetIf->Flags.bIsDnsClientEnabled == 0);
   1f5ac:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
   1f5b0:	f080 0008 	eor.w	r0, r0, #8
   1f5b4:	f3c0 00c0 	ubfx	r0, r0, #3, #1
   1f5b8:	4770      	bx	lr
            return (pNetIf->Flags.bIsDnsServerEnabled == 0);
   1f5ba:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
   1f5be:	f080 0010 	eor.w	r0, r0, #16
   1f5c2:	f3c0 1000 	ubfx	r0, r0, #4, #1
   1f5c6:	4770      	bx	lr
    return false;
   1f5c8:	2000      	movs	r0, #0
   1f5ca:	4770      	bx	lr

Disassembly of section .text._TxSktGetLockedV4Pkt%757:

0001f5cc <_TxSktGetLockedV4Pkt>:
{
   1f5cc:	b570      	push	{r4, r5, r6, lr}
   1f5ce:	4605      	mov	r5, r0
   1f5d0:	460e      	mov	r6, r1
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1f5d2:	2000      	movs	r0, #0
   1f5d4:	f001 ff62 	bl	2149c <OSAL_CRIT_Enter>
   1f5d8:	4601      	mov	r1, r0
    if((pPkt = pSkt->pV4Pkt) != 0)
   1f5da:	68ec      	ldr	r4, [r5, #12]
   1f5dc:	b134      	cbz	r4, 1f5ec <_TxSktGetLockedV4Pkt+0x20>
        if((pPkt->macPkt.pktFlags & TCPIP_MAC_PKT_FLAG_QUEUED) != 0)
   1f5de:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   1f5e0:	f013 0f08 	tst.w	r3, #8
   1f5e4:	d002      	beq.n	1f5ec <_TxSktGetLockedV4Pkt+0x20>
            if(clrSktPkt)
   1f5e6:	b136      	cbz	r6, 1f5f6 <_TxSktGetLockedV4Pkt+0x2a>
                pSkt->pV4Pkt = 0;
   1f5e8:	2400      	movs	r4, #0
   1f5ea:	60ec      	str	r4, [r5, #12]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   1f5ec:	2000      	movs	r0, #0
   1f5ee:	f002 f884 	bl	216fa <OSAL_CRIT_Leave>
}
   1f5f2:	4620      	mov	r0, r4
   1f5f4:	bd70      	pop	{r4, r5, r6, pc}
            pPkt = 0;
   1f5f6:	2400      	movs	r4, #0
   1f5f8:	e7f8      	b.n	1f5ec <_TxSktGetLockedV4Pkt+0x20>

Disassembly of section .text.wc_CryptoCb_RegisterDevice%758:

0001f5fa <wc_CryptoCb_RegisterDevice>:
{
   1f5fa:	b570      	push	{r4, r5, r6, lr}
   1f5fc:	4606      	mov	r6, r0
   1f5fe:	460d      	mov	r5, r1
   1f600:	4614      	mov	r4, r2
    CryptoCb* dev = wc_CryptoCb_FindDevice(devId);
   1f602:	f7ff fe57 	bl	1f2b4 <wc_CryptoCb_FindDevice>
    if (dev == NULL)
   1f606:	4603      	mov	r3, r0
   1f608:	b120      	cbz	r0, 1f614 <wc_CryptoCb_RegisterDevice+0x1a>
    dev->devId = devId;
   1f60a:	601e      	str	r6, [r3, #0]
    dev->cb = cb;
   1f60c:	605d      	str	r5, [r3, #4]
    dev->ctx = ctx;
   1f60e:	609c      	str	r4, [r3, #8]
    return 0;
   1f610:	2000      	movs	r0, #0
}
   1f612:	bd70      	pop	{r4, r5, r6, pc}
        dev = wc_CryptoCb_FindDevice(INVALID_DEVID);
   1f614:	f06f 0001 	mvn.w	r0, #1
   1f618:	f7ff fe4c 	bl	1f2b4 <wc_CryptoCb_FindDevice>
    if (dev == NULL)
   1f61c:	4603      	mov	r3, r0
   1f61e:	2800      	cmp	r0, #0
   1f620:	d1f3      	bne.n	1f60a <wc_CryptoCb_RegisterDevice+0x10>
        return BUFFER_E; /* out of devices */
   1f622:	f06f 0083 	mvn.w	r0, #131	; 0x83
   1f626:	e7f4      	b.n	1f612 <wc_CryptoCb_RegisterDevice+0x18>

Disassembly of section .text.__sfputc_r%759:

0001f628 <__sfputc_r>:
   1f628:	6893      	ldr	r3, [r2, #8]
   1f62a:	3b01      	subs	r3, #1
   1f62c:	2b00      	cmp	r3, #0
   1f62e:	b410      	push	{r4}
   1f630:	6093      	str	r3, [r2, #8]
   1f632:	da08      	bge.n	1f646 <__sfputc_r+0x1e>
   1f634:	6994      	ldr	r4, [r2, #24]
   1f636:	42a3      	cmp	r3, r4
   1f638:	db01      	blt.n	1f63e <__sfputc_r+0x16>
   1f63a:	290a      	cmp	r1, #10
   1f63c:	d103      	bne.n	1f646 <__sfputc_r+0x1e>
   1f63e:	f85d 4b04 	ldr.w	r4, [sp], #4
   1f642:	f7f6 bdeb 	b.w	1621c <__swbuf_r>
   1f646:	6813      	ldr	r3, [r2, #0]
   1f648:	1c58      	adds	r0, r3, #1
   1f64a:	6010      	str	r0, [r2, #0]
   1f64c:	7019      	strb	r1, [r3, #0]
   1f64e:	4608      	mov	r0, r1
   1f650:	f85d 4b04 	ldr.w	r4, [sp], #4
   1f654:	4770      	bx	lr

Disassembly of section .text._Bfree%760:

0001f656 <_Bfree>:
   1f656:	b570      	push	{r4, r5, r6, lr}
   1f658:	6a44      	ldr	r4, [r0, #36]	; 0x24
   1f65a:	4606      	mov	r6, r0
   1f65c:	460d      	mov	r5, r1
   1f65e:	b93c      	cbnz	r4, 1f670 <_Bfree+0x1a>
   1f660:	2010      	movs	r0, #16
   1f662:	f002 fa7b 	bl	21b5c <malloc>
   1f666:	e9c0 4401 	strd	r4, r4, [r0, #4]
   1f66a:	6270      	str	r0, [r6, #36]	; 0x24
   1f66c:	6004      	str	r4, [r0, #0]
   1f66e:	60c4      	str	r4, [r0, #12]
   1f670:	b13d      	cbz	r5, 1f682 <_Bfree+0x2c>
   1f672:	6a73      	ldr	r3, [r6, #36]	; 0x24
   1f674:	686a      	ldr	r2, [r5, #4]
   1f676:	68db      	ldr	r3, [r3, #12]
   1f678:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   1f67c:	6029      	str	r1, [r5, #0]
   1f67e:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
   1f682:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.DRV_ETHPHY_Close%761:

0001f684 <DRV_ETHPHY_Close>:
    if(hClientObj != 0)
   1f684:	b188      	cbz	r0, 1f6aa <DRV_ETHPHY_Close+0x26>
{
   1f686:	b510      	push	{r4, lr}
   1f688:	4604      	mov	r4, r0
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1f68a:	68c1      	ldr	r1, [r0, #12]
   1f68c:	4a07      	ldr	r2, [pc, #28]	; (1f6ac <DRV_ETHPHY_Close+0x28>)
   1f68e:	4291      	cmp	r1, r2
   1f690:	d10a      	bne.n	1f6a8 <DRV_ETHPHY_Close+0x24>
            hClientObj->pMiimBase->DRV_MIIM_Close(hClientObj->miimHandle);
   1f692:	6903      	ldr	r3, [r0, #16]
   1f694:	69db      	ldr	r3, [r3, #28]
   1f696:	6940      	ldr	r0, [r0, #20]
   1f698:	4798      	blx	r3
            hClientObj->clientInUse = false ;
   1f69a:	2200      	movs	r2, #0
   1f69c:	8022      	strh	r2, [r4, #0]
            hClientObj->hDriver->numClients--;
   1f69e:	68e1      	ldr	r1, [r4, #12]
   1f6a0:	884b      	ldrh	r3, [r1, #2]
   1f6a2:	3b01      	subs	r3, #1
   1f6a4:	804b      	strh	r3, [r1, #2]
            hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_CLOSED;
   1f6a6:	7222      	strb	r2, [r4, #8]
}
   1f6a8:	bd10      	pop	{r4, pc}
   1f6aa:	4770      	bx	lr
   1f6ac:	2000e018 	.word	0x2000e018

Disassembly of section .text.DRV_ETHPHY_VendorDataGet%762:

0001f6b0 <DRV_ETHPHY_VendorDataGet>:
    if(hClientObj != 0)
   1f6b0:	4603      	mov	r3, r0
   1f6b2:	b140      	cbz	r0, 1f6c6 <DRV_ETHPHY_VendorDataGet+0x16>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1f6b4:	68c0      	ldr	r0, [r0, #12]
   1f6b6:	4a08      	ldr	r2, [pc, #32]	; (1f6d8 <DRV_ETHPHY_VendorDataGet+0x28>)
   1f6b8:	4290      	cmp	r0, r2
   1f6ba:	d107      	bne.n	1f6cc <DRV_ETHPHY_VendorDataGet+0x1c>
            if(pVendorData)
   1f6bc:	b149      	cbz	r1, 1f6d2 <DRV_ETHPHY_VendorDataGet+0x22>
                *pVendorData = hClientObj->vendorData;
   1f6be:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   1f6c0:	600b      	str	r3, [r1, #0]
            return DRV_ETHPHY_RES_OK;
   1f6c2:	2000      	movs	r0, #0
   1f6c4:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1f6c6:	f06f 000a 	mvn.w	r0, #10
   1f6ca:	4770      	bx	lr
   1f6cc:	f06f 000a 	mvn.w	r0, #10
   1f6d0:	4770      	bx	lr
            return DRV_ETHPHY_RES_OK;
   1f6d2:	2000      	movs	r0, #0
}
   1f6d4:	4770      	bx	lr
   1f6d6:	bf00      	nop
   1f6d8:	2000e018 	.word	0x2000e018

Disassembly of section .text.DRV_ETHPHY_Reinitialize%763:

0001f6dc <DRV_ETHPHY_Reinitialize>:
{
   1f6dc:	b508      	push	{r3, lr}
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1f6de:	4b09      	ldr	r3, [pc, #36]	; (1f704 <DRV_ETHPHY_Reinitialize+0x28>)
   1f6e0:	4283      	cmp	r3, r0
   1f6e2:	d10e      	bne.n	1f702 <DRV_ETHPHY_Reinitialize+0x26>
    if(phyInst != 0)
   1f6e4:	b168      	cbz	r0, 1f702 <DRV_ETHPHY_Reinitialize+0x26>
   1f6e6:	460b      	mov	r3, r1
        phyInst->numClients = 0;
   1f6e8:	4806      	ldr	r0, [pc, #24]	; (1f704 <DRV_ETHPHY_Reinitialize+0x28>)
   1f6ea:	2100      	movs	r1, #0
   1f6ec:	8041      	strh	r1, [r0, #2]
        phyInst->status = SYS_STATUS_READY; // Set module state
   1f6ee:	2202      	movs	r2, #2
   1f6f0:	7102      	strb	r2, [r0, #4]
        phyInst->ethphyId = ethphyInit->ethphyId; // Store PLIB ID
   1f6f2:	685a      	ldr	r2, [r3, #4]
   1f6f4:	6082      	str	r2, [r0, #8]
        phyInst->pPhyObj = ethphyInit->pPhyObject;
   1f6f6:	68db      	ldr	r3, [r3, #12]
   1f6f8:	6143      	str	r3, [r0, #20]
        memset(phyInst->objClients, 0, sizeof(phyInst->objClients));
   1f6fa:	2248      	movs	r2, #72	; 0x48
   1f6fc:	3018      	adds	r0, #24
   1f6fe:	f002 fa3d 	bl	21b7c <memset>
}
   1f702:	bd08      	pop	{r3, pc}
   1f704:	2000e018 	.word	0x2000e018

Disassembly of section .text._DRV_ETHPHY_LinkStatPhaseRefresh%764:

0001f708 <_DRV_ETHPHY_LinkStatPhaseRefresh>:
{
   1f708:	b510      	push	{r4, lr}
   1f70a:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   1f70c:	f000 ffaa 	bl	20664 <_DRV_PHY_SMITransfer_Wait>
   1f710:	b178      	cbz	r0, 1f732 <_DRV_ETHPHY_LinkStatPhaseRefresh+0x2a>
    DRV_ETHPHY_LINK_STATUS* pLinkStat = (DRV_ETHPHY_LINK_STATUS*)hClientObj->operParam;
   1f712:	6b23      	ldr	r3, [r4, #48]	; 0x30
    if(pLinkStat)
   1f714:	b14b      	cbz	r3, 1f72a <_DRV_ETHPHY_LinkStatPhaseRefresh+0x22>
    linkStat = (phyStat.LINK_STAT)?DRV_ETHPHY_LINK_ST_UP:DRV_ETHPHY_LINK_ST_DOWN;
   1f716:	f894 103a 	ldrb.w	r1, [r4, #58]	; 0x3a
   1f71a:	f3c1 0280 	ubfx	r2, r1, #2, #1
    if(phyStat.REM_FAULT)
   1f71e:	f011 0f10 	tst.w	r1, #16
        linkStat|=DRV_ETHPHY_LINK_ST_REMOTE_FAULT;
   1f722:	bf18      	it	ne
   1f724:	f042 0204 	orrne.w	r2, r2, #4
        *pLinkStat = _Phy2LinkStat(phyStat);
   1f728:	801a      	strh	r2, [r3, #0]
    _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OK);
   1f72a:	2100      	movs	r1, #0
   1f72c:	4620      	mov	r0, r4
   1f72e:	f000 fa49 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
}
   1f732:	bd10      	pop	{r4, pc}

Disassembly of section .text._ARPRemoveEntry%765:

0001f734 <_ARPRemoveEntry>:
{
   1f734:	b538      	push	{r3, r4, r5, lr}
   1f736:	4605      	mov	r5, r0
   1f738:	460c      	mov	r4, r1
    if((hE->flags.value & ARP_FLAG_ENTRY_PERM) != 0 )
   1f73a:	880b      	ldrh	r3, [r1, #0]
   1f73c:	f013 0f40 	tst.w	r3, #64	; 0x40
   1f740:	d008      	beq.n	1f754 <_ARPRemoveEntry+0x20>
        remList =  &pArpDcpt->permList;
   1f742:	3004      	adds	r0, #4
    TCPIP_Helper_ProtectedSingleListNodeRemove(remList, (SGL_LIST_NODE*)&((ARP_HASH_ENTRY*)hE)->next);
   1f744:	1d21      	adds	r1, r4, #4
   1f746:	f7ff fcc5 	bl	1f0d4 <TCPIP_Helper_ProtectedSingleListNodeRemove>
    TCPIP_OAHASH_EntryRemove(pArpDcpt->hashDcpt, hE);
   1f74a:	4621      	mov	r1, r4
   1f74c:	6828      	ldr	r0, [r5, #0]
   1f74e:	f001 fe51 	bl	213f4 <TCPIP_OAHASH_EntryRemove>
}
   1f752:	bd38      	pop	{r3, r4, r5, pc}
    else if((hE->flags.value & ARP_FLAG_ENTRY_COMPLETE) != 0 )
   1f754:	f013 0f80 	tst.w	r3, #128	; 0x80
        remList =  &pArpDcpt->completeList;
   1f758:	bf14      	ite	ne
   1f75a:	3018      	addne	r0, #24
        remList =  &pArpDcpt->incompleteList;
   1f75c:	302c      	addeq	r0, #44	; 0x2c
   1f75e:	e7f1      	b.n	1f744 <_ARPRemoveEntry+0x10>

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListHeadRemove%766:

0001f760 <TCPIP_Helper_ProtectedSingleListHeadRemove>:
{
   1f760:	b538      	push	{r3, r4, r5, lr}
    if(pL->semValid)
   1f762:	7c03      	ldrb	r3, [r0, #16]
   1f764:	b913      	cbnz	r3, 1f76c <TCPIP_Helper_ProtectedSingleListHeadRemove+0xc>
    return 0;
   1f766:	2400      	movs	r4, #0
}
   1f768:	4620      	mov	r0, r4
   1f76a:	bd38      	pop	{r3, r4, r5, pc}
   1f76c:	4604      	mov	r4, r0
        if (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
   1f76e:	f100 050c 	add.w	r5, r0, #12
   1f772:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1f776:	4628      	mov	r0, r5
   1f778:	f001 fa84 	bl	20c84 <OSAL_SEM_Pend>
        SGL_LIST_NODE * ret = TCPIP_Helper_SingleListHeadRemove(&pL->list);
   1f77c:	4620      	mov	r0, r4
   1f77e:	f001 fb3b 	bl	20df8 <TCPIP_Helper_SingleListHeadRemove>
   1f782:	4604      	mov	r4, r0
        if (OSAL_SEM_Post(&pL->semaphore) != OSAL_RESULT_TRUE)
   1f784:	4628      	mov	r0, r5
   1f786:	f001 fe95 	bl	214b4 <OSAL_SEM_Post>
        return ret;
   1f78a:	e7ed      	b.n	1f768 <TCPIP_Helper_ProtectedSingleListHeadRemove+0x8>

Disassembly of section .text.TCPIP_STACK_IsBcastAddress%767:

0001f78c <TCPIP_STACK_IsBcastAddress>:
{
   1f78c:	b508      	push	{r3, lr}
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   1f78e:	b188      	cbz	r0, 1f7b4 <TCPIP_STACK_IsBcastAddress+0x28>
   1f790:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1f794:	f012 0f40 	tst.w	r2, #64	; 0x40
   1f798:	d101      	bne.n	1f79e <TCPIP_STACK_IsBcastAddress+0x12>
    return false;
   1f79a:	2000      	movs	r0, #0
}
   1f79c:	bd08      	pop	{r3, pc}
       return (TCPIP_Helper_IsBcastAddress(pIpAdd) ||  TCPIP_STACK_NetIsBcastAddress(pNetIf, pIpAdd));
   1f79e:	680a      	ldr	r2, [r1, #0]
   1f7a0:	f1b2 3fff 	cmp.w	r2, #4294967295
   1f7a4:	d004      	beq.n	1f7b0 <TCPIP_STACK_IsBcastAddress+0x24>
   1f7a6:	f000 fb75 	bl	1fe94 <TCPIP_STACK_NetIsBcastAddress>
   1f7aa:	f000 0001 	and.w	r0, r0, #1
   1f7ae:	e7f5      	b.n	1f79c <TCPIP_STACK_IsBcastAddress+0x10>
   1f7b0:	2001      	movs	r0, #1
   1f7b2:	e7fa      	b.n	1f7aa <TCPIP_STACK_IsBcastAddress+0x1e>
    return false;
   1f7b4:	2000      	movs	r0, #0
   1f7b6:	e7f1      	b.n	1f79c <TCPIP_STACK_IsBcastAddress+0x10>

Disassembly of section .text._TCPIPStackModuleRxExtract%768:

0001f7b8 <_TCPIPStackModuleRxExtract>:
{
   1f7b8:	b538      	push	{r3, r4, r5, lr}
   1f7ba:	4604      	mov	r4, r0
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1f7bc:	2000      	movs	r0, #0
   1f7be:	f001 fe6d 	bl	2149c <OSAL_CRIT_Enter>
   1f7c2:	4605      	mov	r5, r0
    SINGLE_LIST* pQueue = TCPIP_MODULES_QUEUE_TBL + modId;
   1f7c4:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    TCPIP_MAC_PACKET* pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(pQueue);
   1f7c8:	4805      	ldr	r0, [pc, #20]	; (1f7e0 <_TCPIPStackModuleRxExtract+0x28>)
   1f7ca:	eb00 0084 	add.w	r0, r0, r4, lsl #2
   1f7ce:	f001 fb13 	bl	20df8 <TCPIP_Helper_SingleListHeadRemove>
   1f7d2:	4604      	mov	r4, r0
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1f7d4:	4629      	mov	r1, r5
   1f7d6:	2000      	movs	r0, #0
   1f7d8:	f001 ff8f 	bl	216fa <OSAL_CRIT_Leave>
}
   1f7dc:	4620      	mov	r0, r4
   1f7de:	bd38      	pop	{r3, r4, r5, pc}
   1f7e0:	2000de84 	.word	0x2000de84

Disassembly of section .text._TCPIP_PKT_SocketAlloc%769:

0001f7e4 <_TCPIP_PKT_SocketAlloc>:
{
   1f7e4:	b538      	push	{r3, r4, r5, lr}
   1f7e6:	460c      	mov	r4, r1
    if((flags & TCPIP_MAC_PKT_FLAG_IPV6) != 0)
   1f7e8:	f403 7100 	and.w	r1, r3, #512	; 0x200
        netHdrLen = sizeof(IPV4_HEADER);
   1f7ec:	2900      	cmp	r1, #0
   1f7ee:	bf14      	ite	ne
   1f7f0:	2528      	movne	r5, #40	; 0x28
   1f7f2:	2514      	moveq	r5, #20
    pPkt = _TCPIP_PKT_PacketAlloc(pktLen, totHdrLen +  payloadLen, flags );
   1f7f4:	4422      	add	r2, r4
   1f7f6:	18a9      	adds	r1, r5, r2
   1f7f8:	461a      	mov	r2, r3
   1f7fa:	b289      	uxth	r1, r1
   1f7fc:	f7f9 fa2a 	bl	18c54 <_TCPIP_PKT_PacketAlloc>
    if(pPkt)
   1f800:	4603      	mov	r3, r0
   1f802:	b118      	cbz	r0, 1f80c <_TCPIP_PKT_SocketAlloc+0x28>
        if(transpHdrLen)
   1f804:	b114      	cbz	r4, 1f80c <_TCPIP_PKT_SocketAlloc+0x28>
            pPkt->pTransportLayer = pPkt->pNetLayer + netHdrLen;
   1f806:	6982      	ldr	r2, [r0, #24]
   1f808:	4415      	add	r5, r2
   1f80a:	61c5      	str	r5, [r0, #28]
}
   1f80c:	4618      	mov	r0, r3
   1f80e:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text._UDPFreeTxResources%770:

0001f810 <_UDPFreeTxResources>:
{
   1f810:	b510      	push	{r4, lr}
   1f812:	4604      	mov	r4, r0
    switch(pSkt->addType)
   1f814:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
   1f816:	2b01      	cmp	r3, #1
   1f818:	d002      	beq.n	1f820 <_UDPFreeTxResources+0x10>
    pSkt->pPkt = 0;
   1f81a:	2300      	movs	r3, #0
   1f81c:	60e3      	str	r3, [r4, #12]
}
   1f81e:	bd10      	pop	{r4, pc}
            pCurrPkt = _TxSktGetLockedV4Pkt(pSkt, true);
   1f820:	2101      	movs	r1, #1
   1f822:	f7ff fed3 	bl	1f5cc <_TxSktGetLockedV4Pkt>
            if(pCurrPkt)
   1f826:	2800      	cmp	r0, #0
   1f828:	d0f7      	beq.n	1f81a <_UDPFreeTxResources+0xa>
                    TCPIP_PKT_PacketFree(pPkt);
   1f82a:	68e0      	ldr	r0, [r4, #12]
   1f82c:	f7fe fbbc 	bl	1dfa8 <_TCPIP_PKT_PacketFree>
        pSkt->txAllocCnt--;
   1f830:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
   1f834:	3b01      	subs	r3, #1
   1f836:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
   1f83a:	e7ee      	b.n	1f81a <_UDPFreeTxResources+0xa>

Disassembly of section .text.SERCOM0_SPI_IsBusy%771:

0001f83c <SERCOM0_SPI_IsBusy>:
	if ((sercom0SPIObj.txSize == 0U) && (sercom0SPIObj.rxSize == 0U))
   1f83c:	4b08      	ldr	r3, [pc, #32]	; (1f860 <SERCOM0_SPI_IsBusy+0x24>)
   1f83e:	689a      	ldr	r2, [r3, #8]
   1f840:	68db      	ldr	r3, [r3, #12]
   1f842:	4313      	orrs	r3, r2
   1f844:	d00a      	beq.n	1f85c <SERCOM0_SPI_IsBusy+0x20>
        isBusy = (((SERCOM0_REGS->SPIM.SERCOM_INTFLAG & SERCOM_SPIM_INTFLAG_TXC_Msk) == 0U) || sercom0SPIObj.transferIsBusy);
   1f846:	4b07      	ldr	r3, [pc, #28]	; (1f864 <SERCOM0_SPI_IsBusy+0x28>)
   1f848:	7e1b      	ldrb	r3, [r3, #24]
   1f84a:	f013 0f02 	tst.w	r3, #2
   1f84e:	bf1a      	itte	ne
   1f850:	4b03      	ldrne	r3, [pc, #12]	; (1f860 <SERCOM0_SPI_IsBusy+0x24>)
   1f852:	7f18      	ldrbne	r0, [r3, #28]
   1f854:	2001      	moveq	r0, #1
   1f856:	f000 0001 	and.w	r0, r0, #1
   1f85a:	4770      	bx	lr
		isBusy = false;
   1f85c:	2000      	movs	r0, #0
}
   1f85e:	4770      	bx	lr
   1f860:	2000e29c 	.word	0x2000e29c
   1f864:	40003000 	.word	0x40003000

Disassembly of section .text.TC0_TimerInterruptHandler%772:

0001f868 <TC0_TimerInterruptHandler>:
    TC0_CallbackObject.context = context;
}

/* Timer Interrupt handler */
void TC0_TimerInterruptHandler( void )
{
   1f868:	b508      	push	{r3, lr}
    if (TC0_REGS->COUNT16.TC_INTENSET != 0U)
   1f86a:	4b08      	ldr	r3, [pc, #32]	; (1f88c <TC0_TimerInterruptHandler+0x24>)
   1f86c:	7a5b      	ldrb	r3, [r3, #9]
   1f86e:	b163      	cbz	r3, 1f88a <TC0_TimerInterruptHandler+0x22>
    {
        TC_TIMER_STATUS status;
        status = (TC_TIMER_STATUS) TC0_REGS->COUNT16.TC_INTFLAG;
   1f870:	4a06      	ldr	r2, [pc, #24]	; (1f88c <TC0_TimerInterruptHandler+0x24>)
   1f872:	7a93      	ldrb	r3, [r2, #10]
        /* Clear interrupt flags */
        TC0_REGS->COUNT16.TC_INTFLAG = (uint8_t)TC_INTFLAG_Msk;
   1f874:	2133      	movs	r1, #51	; 0x33
   1f876:	7291      	strb	r1, [r2, #10]
        if((status != TC_TIMER_STATUS_NONE) && (TC0_CallbackObject.callback != NULL))
   1f878:	f003 00ff 	and.w	r0, r3, #255	; 0xff
   1f87c:	b12b      	cbz	r3, 1f88a <TC0_TimerInterruptHandler+0x22>
   1f87e:	4b04      	ldr	r3, [pc, #16]	; (1f890 <TC0_TimerInterruptHandler+0x28>)
   1f880:	681b      	ldr	r3, [r3, #0]
   1f882:	b113      	cbz	r3, 1f88a <TC0_TimerInterruptHandler+0x22>
        {
            TC0_CallbackObject.callback(status, TC0_CallbackObject.context);
   1f884:	4a02      	ldr	r2, [pc, #8]	; (1f890 <TC0_TimerInterruptHandler+0x28>)
   1f886:	6851      	ldr	r1, [r2, #4]
   1f888:	4798      	blx	r3
        }
    }
}
   1f88a:	bd08      	pop	{r3, pc}
   1f88c:	40003800 	.word	0x40003800
   1f890:	2000e558 	.word	0x2000e558

Disassembly of section .rodata.sysConsoleUARTDevDesc%773:

0001f894 <sysConsoleUARTDevDesc>:
   1f894:	00000300 0001ff85 0001e021 0001ea95     ........!.......
   1f8a4:	0001ea61 0001e05d 0001e9f9 0001ea2d     a...].......-...
   1f8b4:	00014f43 00021abd 0002214d              CO......M!..

Disassembly of section .text.TCPIP_STACK_Init%774:

0001f8c0 <TCPIP_STACK_Init>:
{
   1f8c0:	b500      	push	{lr}
   1f8c2:	b087      	sub	sp, #28
    tcpipInit.pNetConf = TCPIP_HOSTS_CONFIGURATION;
   1f8c4:	4b07      	ldr	r3, [pc, #28]	; (1f8e4 <TCPIP_STACK_Init+0x24>)
   1f8c6:	9301      	str	r3, [sp, #4]
    tcpipInit.nNets = TCPIP_HOSTS_CONFIGURATION_SIZE;
   1f8c8:	2301      	movs	r3, #1
   1f8ca:	9302      	str	r3, [sp, #8]
    tcpipInit.pModConfig = TCPIP_STACK_MODULE_CONFIG_TBL;
   1f8cc:	4b06      	ldr	r3, [pc, #24]	; (1f8e8 <TCPIP_STACK_Init+0x28>)
   1f8ce:	9303      	str	r3, [sp, #12]
    tcpipInit.nModules = TCPIP_STACK_MODULE_CONFIG_TBL_SIZE;
   1f8d0:	2309      	movs	r3, #9
   1f8d2:	9304      	str	r3, [sp, #16]
    tcpipInit.initCback = 0;
   1f8d4:	2000      	movs	r0, #0
   1f8d6:	9005      	str	r0, [sp, #20]
    return TCPIP_STACK_Initialize(0, &tcpipInit.moduleInit);
   1f8d8:	4669      	mov	r1, sp
   1f8da:	f7f8 fecd 	bl	18678 <TCPIP_STACK_Initialize>
}
   1f8de:	b007      	add	sp, #28
   1f8e0:	f85d fb04 	ldr.w	pc, [sp], #4
   1f8e4:	0001e674 	.word	0x0001e674
   1f8e8:	0001cd68 	.word	0x0001cd68

Disassembly of section .text.pxPortInitialiseStack%775:

0001f8ec <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   1f8ec:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   1f8f0:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
   1f8f4:	f021 0101 	bic.w	r1, r1, #1
   1f8f8:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
   1f8fc:	4b05      	ldr	r3, [pc, #20]	; (1f914 <pxPortInitialiseStack+0x28>)
   1f8fe:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
   1f902:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
   1f906:	f06f 0302 	mvn.w	r3, #2
   1f90a:	f840 3c24 	str.w	r3, [r0, #-36]
}
   1f90e:	3844      	subs	r0, #68	; 0x44
   1f910:	4770      	bx	lr
   1f912:	bf00      	nop
   1f914:	00020af1 	.word	0x00020af1

Disassembly of section .text.xPortSysTickHandler%776:

0001f918 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
   1f918:	b508      	push	{r3, lr}
   1f91a:	f04f 0320 	mov.w	r3, #32
   1f91e:	f383 8811 	msr	BASEPRI, r3
   1f922:	f3bf 8f6f 	isb	sy
   1f926:	f3bf 8f4f 	dsb	sy
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
   1f92a:	f7f3 fd69 	bl	13400 <xTaskIncrementTick>
   1f92e:	b118      	cbz	r0, 1f938 <xPortSysTickHandler+0x20>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   1f930:	4b03      	ldr	r3, [pc, #12]	; (1f940 <xPortSysTickHandler+0x28>)
   1f932:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1f936:	601a      	str	r2, [r3, #0]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   1f938:	2300      	movs	r3, #0
   1f93a:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
   1f93e:	bd08      	pop	{r3, pc}
   1f940:	e000ed04 	.word	0xe000ed04

Disassembly of section .text.prvResetNextTaskUnblockTime%777:

0001f944 <prvResetNextTaskUnblockTime>:
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   1f944:	4b08      	ldr	r3, [pc, #32]	; (1f968 <prvResetNextTaskUnblockTime+0x24>)
   1f946:	681b      	ldr	r3, [r3, #0]
   1f948:	681b      	ldr	r3, [r3, #0]
   1f94a:	b923      	cbnz	r3, 1f956 <prvResetNextTaskUnblockTime+0x12>
		xNextTaskUnblockTime = portMAX_DELAY;
   1f94c:	4b07      	ldr	r3, [pc, #28]	; (1f96c <prvResetNextTaskUnblockTime+0x28>)
   1f94e:	f04f 32ff 	mov.w	r2, #4294967295
   1f952:	601a      	str	r2, [r3, #0]
   1f954:	4770      	bx	lr
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   1f956:	4b04      	ldr	r3, [pc, #16]	; (1f968 <prvResetNextTaskUnblockTime+0x24>)
   1f958:	681b      	ldr	r3, [r3, #0]
   1f95a:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
   1f95c:	68db      	ldr	r3, [r3, #12]
   1f95e:	685a      	ldr	r2, [r3, #4]
   1f960:	4b02      	ldr	r3, [pc, #8]	; (1f96c <prvResetNextTaskUnblockTime+0x28>)
   1f962:	601a      	str	r2, [r3, #0]
}
   1f964:	4770      	bx	lr
   1f966:	bf00      	nop
   1f968:	2000e6a8 	.word	0x2000e6a8
   1f96c:	2000e6c8 	.word	0x2000e6c8

Disassembly of section .text.wc_RNG_HealthTest%778:

0001f970 <wc_RNG_HealthTest>:
{
   1f970:	b530      	push	{r4, r5, lr}
   1f972:	b089      	sub	sp, #36	; 0x24
    return wc_RNG_HealthTest_ex(reseed, NULL, 0,
   1f974:	f06f 0401 	mvn.w	r4, #1
   1f978:	9406      	str	r4, [sp, #24]
   1f97a:	2400      	movs	r4, #0
   1f97c:	9405      	str	r4, [sp, #20]
   1f97e:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   1f980:	9504      	str	r5, [sp, #16]
   1f982:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   1f984:	9503      	str	r5, [sp, #12]
   1f986:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   1f988:	9502      	str	r5, [sp, #8]
   1f98a:	9301      	str	r3, [sp, #4]
   1f98c:	9200      	str	r2, [sp, #0]
   1f98e:	460b      	mov	r3, r1
   1f990:	4622      	mov	r2, r4
   1f992:	4621      	mov	r1, r4
   1f994:	f7f7 fdd2 	bl	1753c <wc_RNG_HealthTest_ex>
}
   1f998:	b009      	add	sp, #36	; 0x24
   1f99a:	bd30      	pop	{r4, r5, pc}

Disassembly of section .text.MyTxQueueErase%779:

0001f99c <MyTxQueueErase>:
    for(ix=0;ix<MY_QUEUE_SIZE;ix++){
   1f99c:	4a07      	ldr	r2, [pc, #28]	; (1f9bc <MyTxQueueErase+0x20>)
   1f99e:	1e53      	subs	r3, r2, #1
   1f9a0:	f202 12ff 	addw	r2, r2, #511	; 0x1ff
        MyQueue[ix]=0;        
   1f9a4:	2100      	movs	r1, #0
   1f9a6:	f803 1f01 	strb.w	r1, [r3, #1]!
    for(ix=0;ix<MY_QUEUE_SIZE;ix++){
   1f9aa:	4293      	cmp	r3, r2
   1f9ac:	d1fb      	bne.n	1f9a6 <MyTxQueueErase+0xa>
    MyQueue_wr_ix = 0;
   1f9ae:	2300      	movs	r3, #0
   1f9b0:	4a03      	ldr	r2, [pc, #12]	; (1f9c0 <MyTxQueueErase+0x24>)
   1f9b2:	6013      	str	r3, [r2, #0]
    MyQueue_rd_ix = 0;
   1f9b4:	4a03      	ldr	r2, [pc, #12]	; (1f9c4 <MyTxQueueErase+0x28>)
   1f9b6:	6013      	str	r3, [r2, #0]
}
   1f9b8:	4770      	bx	lr
   1f9ba:	bf00      	nop
   1f9bc:	2000d644 	.word	0x2000d644
   1f9c0:	2000e6f0 	.word	0x2000e6f0
   1f9c4:	2000e6ec 	.word	0x2000e6ec

Disassembly of section .text.__sfmoreglue%780:

0001f9c8 <__sfmoreglue>:
   1f9c8:	b570      	push	{r4, r5, r6, lr}
   1f9ca:	1e4a      	subs	r2, r1, #1
   1f9cc:	2564      	movs	r5, #100	; 0x64
   1f9ce:	4355      	muls	r5, r2
   1f9d0:	460e      	mov	r6, r1
   1f9d2:	f105 0170 	add.w	r1, r5, #112	; 0x70
   1f9d6:	f7f6 ffb9 	bl	1694c <_malloc_r>
   1f9da:	4604      	mov	r4, r0
   1f9dc:	b140      	cbz	r0, 1f9f0 <__sfmoreglue+0x28>
   1f9de:	2100      	movs	r1, #0
   1f9e0:	e9c0 1600 	strd	r1, r6, [r0]
   1f9e4:	300c      	adds	r0, #12
   1f9e6:	60a0      	str	r0, [r4, #8]
   1f9e8:	f105 0264 	add.w	r2, r5, #100	; 0x64
   1f9ec:	f002 f8c6 	bl	21b7c <memset>
   1f9f0:	4620      	mov	r0, r4
   1f9f2:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text._wcrtomb_r%781:

0001f9f4 <_wcrtomb_r>:
   1f9f4:	b5f0      	push	{r4, r5, r6, r7, lr}
   1f9f6:	4c09      	ldr	r4, [pc, #36]	; (1fa1c <_wcrtomb_r+0x28>)
   1f9f8:	b085      	sub	sp, #20
   1f9fa:	4605      	mov	r5, r0
   1f9fc:	461e      	mov	r6, r3
   1f9fe:	f8d4 40e0 	ldr.w	r4, [r4, #224]	; 0xe0
   1fa02:	b909      	cbnz	r1, 1fa08 <_wcrtomb_r+0x14>
   1fa04:	460a      	mov	r2, r1
   1fa06:	a901      	add	r1, sp, #4
   1fa08:	47a0      	blx	r4
   1fa0a:	1c43      	adds	r3, r0, #1
   1fa0c:	bf01      	itttt	eq
   1fa0e:	2300      	moveq	r3, #0
   1fa10:	6033      	streq	r3, [r6, #0]
   1fa12:	238a      	moveq	r3, #138	; 0x8a
   1fa14:	602b      	streq	r3, [r5, #0]
   1fa16:	b005      	add	sp, #20
   1fa18:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1fa1a:	bf00      	nop
   1fa1c:	2000d844 	.word	0x2000d844

Disassembly of section .text._sbrk%782:

0001fa20 <_sbrk>:
   1fa20:	4a07      	ldr	r2, [pc, #28]	; (1fa40 <_sbrk+0x20>)
   1fa22:	6813      	ldr	r3, [r2, #0]
   1fa24:	b143      	cbz	r3, 1fa38 <_sbrk+0x18>
   1fa26:	4907      	ldr	r1, [pc, #28]	; (1fa44 <_sbrk+0x24>)
   1fa28:	4418      	add	r0, r3
   1fa2a:	4288      	cmp	r0, r1
   1fa2c:	bf8c      	ite	hi
   1fa2e:	f04f 33ff 	movhi.w	r3, #4294967295
   1fa32:	6010      	strls	r0, [r2, #0]
   1fa34:	4618      	mov	r0, r3
   1fa36:	4770      	bx	lr
   1fa38:	4b03      	ldr	r3, [pc, #12]	; (1fa48 <_sbrk+0x28>)
   1fa3a:	6013      	str	r3, [r2, #0]
   1fa3c:	e7f3      	b.n	1fa26 <_sbrk+0x6>
   1fa3e:	bf00      	nop
   1fa40:	2000e70c 	.word	0x2000e70c
   1fa44:	200261f0 	.word	0x200261f0
   1fa48:	2000e730 	.word	0x2000e730

Disassembly of section .text%783:

0001fa4c <__aeabi_dcmpun>:
   1fa4c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   1fa50:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   1fa54:	d102      	bne.n	1fa5c <__aeabi_dcmpun+0x10>
   1fa56:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
   1fa5a:	d10a      	bne.n	1fa72 <__aeabi_dcmpun+0x26>
   1fa5c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   1fa60:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   1fa64:	d102      	bne.n	1fa6c <__aeabi_dcmpun+0x20>
   1fa66:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
   1fa6a:	d102      	bne.n	1fa72 <__aeabi_dcmpun+0x26>
   1fa6c:	f04f 0000 	mov.w	r0, #0
   1fa70:	4770      	bx	lr
   1fa72:	f04f 0001 	mov.w	r0, #1
   1fa76:	4770      	bx	lr

Disassembly of section .text._DRV_GMAC_LinkStateStartLink%784:

0001fa78 <_DRV_GMAC_LinkStateStartLink>:
{
   1fa78:	b538      	push	{r3, r4, r5, lr}
   1fa7a:	4604      	mov	r4, r0
	phyRes = pMACDrv->sGmacData.gmacConfig.pPhyBase->DRV_ETHPHY_LinkStatusGet(pMACDrv->sGmacData.hPhyClient, DRV_ETHPHY_INF_IDX_ALL_EXTERNAL, &pMACDrv->sGmacData._negResult.linkStatus, false);
   1fa7c:	f8d0 30d8 	ldr.w	r3, [r0, #216]	; 0xd8
   1fa80:	6c1d      	ldr	r5, [r3, #64]	; 0x40
   1fa82:	2300      	movs	r3, #0
   1fa84:	f100 0240 	add.w	r2, r0, #64	; 0x40
   1fa88:	4619      	mov	r1, r3
   1fa8a:	6900      	ldr	r0, [r0, #16]
   1fa8c:	47a8      	blx	r5
    if(phyRes < 0)
   1fa8e:	2800      	cmp	r0, #0
   1fa90:	db03      	blt.n	1fa9a <_DRV_GMAC_LinkStateStartLink+0x22>
    pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_GET_LINK;
   1fa92:	2301      	movs	r3, #1
   1fa94:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
}
   1fa98:	bd38      	pop	{r3, r4, r5, pc}
	    _DRV_GMAC_LinkStateDown(pMACDrv);
   1fa9a:	4620      	mov	r0, r4
   1fa9c:	f001 f898 	bl	20bd0 <_DRV_GMAC_LinkStateDown>
	    return;
   1faa0:	e7fa      	b.n	1fa98 <_DRV_GMAC_LinkStateStartLink+0x20>

Disassembly of section .text.TCPIP_TCP_WasReset%785:

0001faa2 <TCPIP_TCP_WasReset>:
{
   1faa2:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   1faa4:	f000 f906 	bl	1fcb4 <_TcpSocketChk>
    if(pSkt)
   1faa8:	b160      	cbz	r0, 1fac4 <TCPIP_TCP_WasReset+0x22>
        if(pSkt->Flags.bSocketReset)
   1faaa:	f890 2037 	ldrb.w	r2, [r0, #55]	; 0x37
   1faae:	f012 0f02 	tst.w	r2, #2
   1fab2:	d009      	beq.n	1fac8 <TCPIP_TCP_WasReset+0x26>
            pSkt->Flags.bSocketReset = 0;
   1fab4:	f890 2037 	ldrb.w	r2, [r0, #55]	; 0x37
   1fab8:	f36f 0241 	bfc	r2, #1, #1
   1fabc:	f880 2037 	strb.w	r2, [r0, #55]	; 0x37
            return true;
   1fac0:	2001      	movs	r0, #1
   1fac2:	e002      	b.n	1faca <TCPIP_TCP_WasReset+0x28>
    return true;
   1fac4:	2001      	movs	r0, #1
   1fac6:	e000      	b.n	1faca <TCPIP_TCP_WasReset+0x28>
        return false;
   1fac8:	2000      	movs	r0, #0
}
   1faca:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_DNS_OAHASH_KeyCopy%786:

0001facc <TCPIP_DNS_OAHASH_KeyCopy>:
    if(key == 0) 
   1facc:	b192      	cbz	r2, 1faf4 <TCPIP_DNS_OAHASH_KeyCopy+0x28>
{
   1face:	b570      	push	{r4, r5, r6, lr}
   1fad0:	4615      	mov	r5, r2
   1fad2:	460c      	mov	r4, r1
    size_t hostnameLen = strlen(dnsHostNameKey);
   1fad4:	4610      	mov	r0, r2
   1fad6:	f002 f861 	bl	21b9c <strlen>
    if(hostnameLen > TCPIP_DNS_CLIENT_MAX_HOSTNAME_LEN) 
   1fada:	2840      	cmp	r0, #64	; 0x40
   1fadc:	bf28      	it	cs
   1fade:	2040      	movcs	r0, #64	; 0x40
   1fae0:	4606      	mov	r6, r0
    memcpy(pDnsHE->pHostName, dnsHostNameKey, hostnameLen);
   1fae2:	4602      	mov	r2, r0
   1fae4:	4629      	mov	r1, r5
   1fae6:	6a20      	ldr	r0, [r4, #32]
   1fae8:	f001 faba 	bl	21060 <memcpy>
    pDnsHE->pHostName[hostnameLen] = '\0';
   1faec:	6a23      	ldr	r3, [r4, #32]
   1faee:	2200      	movs	r2, #0
   1faf0:	559a      	strb	r2, [r3, r6]
}
   1faf2:	bd70      	pop	{r4, r5, r6, pc}
   1faf4:	4770      	bx	lr

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListTailAdd%787:

0001faf6 <TCPIP_Helper_ProtectedSingleListTailAdd>:
    if(pL->semValid)
   1faf6:	7c03      	ldrb	r3, [r0, #16]
   1faf8:	b903      	cbnz	r3, 1fafc <TCPIP_Helper_ProtectedSingleListTailAdd+0x6>
   1fafa:	4770      	bx	lr
{
   1fafc:	b570      	push	{r4, r5, r6, lr}
   1fafe:	460d      	mov	r5, r1
   1fb00:	4604      	mov	r4, r0
        if (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
   1fb02:	f100 060c 	add.w	r6, r0, #12
   1fb06:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1fb0a:	4630      	mov	r0, r6
   1fb0c:	f001 f8ba 	bl	20c84 <OSAL_SEM_Pend>
        TCPIP_Helper_SingleListTailAdd(&pL->list, pN);
   1fb10:	4629      	mov	r1, r5
   1fb12:	4620      	mov	r0, r4
   1fb14:	f001 fb44 	bl	211a0 <TCPIP_Helper_SingleListTailAdd>
        if (OSAL_SEM_Post(&pL->semaphore) != OSAL_RESULT_TRUE)
   1fb18:	4630      	mov	r0, r6
   1fb1a:	f001 fccb 	bl	214b4 <OSAL_SEM_Post>
}
   1fb1e:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListRemoveAll%788:

0001fb20 <TCPIP_Helper_ProtectedSingleListRemoveAll>:
}



void TCPIP_Helper_ProtectedSingleListRemoveAll(PROTECTED_SINGLE_LIST* pL)
{
   1fb20:	b538      	push	{r3, r4, r5, lr}
    if(pL->semValid)
   1fb22:	7c03      	ldrb	r3, [r0, #16]
   1fb24:	b903      	cbnz	r3, 1fb28 <TCPIP_Helper_ProtectedSingleListRemoveAll+0x8>
        if (OSAL_SEM_Post(&pL->semaphore) != OSAL_RESULT_TRUE)
        {
            //SYS_DEBUG LOG
        }
    }
}
   1fb26:	bd38      	pop	{r3, r4, r5, pc}
   1fb28:	4604      	mov	r4, r0
        if (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
   1fb2a:	f100 050c 	add.w	r5, r0, #12
   1fb2e:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1fb32:	4628      	mov	r0, r5
   1fb34:	f001 f8a6 	bl	20c84 <OSAL_SEM_Pend>
   1fb38:	4620      	mov	r0, r4
   1fb3a:	f001 f95d 	bl	20df8 <TCPIP_Helper_SingleListHeadRemove>
   1fb3e:	2800      	cmp	r0, #0
   1fb40:	d1fa      	bne.n	1fb38 <TCPIP_Helper_ProtectedSingleListRemoveAll+0x18>
        if (OSAL_SEM_Post(&pL->semaphore) != OSAL_RESULT_TRUE)
   1fb42:	4628      	mov	r0, r5
   1fb44:	f001 fcb6 	bl	214b4 <OSAL_SEM_Post>
}
   1fb48:	e7ed      	b.n	1fb26 <TCPIP_Helper_ProtectedSingleListRemoveAll+0x6>

Disassembly of section .text.TCPIP_Notification_Add%789:

0001fb4a <TCPIP_Notification_Add>:
{
   1fb4a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1fb4c:	4607      	mov	r7, r0
   1fb4e:	4608      	mov	r0, r1
   1fb50:	4616      	mov	r6, r2
   1fb52:	461d      	mov	r5, r3
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
   1fb54:	684b      	ldr	r3, [r1, #4]
   1fb56:	4629      	mov	r1, r5
   1fb58:	4798      	blx	r3
    if(newNode)
   1fb5a:	4604      	mov	r4, r0
   1fb5c:	b140      	cbz	r0, 1fb70 <TCPIP_Notification_Add+0x26>
        if(pContent)
   1fb5e:	b11e      	cbz	r6, 1fb68 <TCPIP_Notification_Add+0x1e>
            memcpy(newNode, pContent, nBytes);
   1fb60:	462a      	mov	r2, r5
   1fb62:	4631      	mov	r1, r6
   1fb64:	f001 fa7c 	bl	21060 <memcpy>
        TCPIP_Helper_ProtectedSingleListTailAdd(notifyList, newNode);
   1fb68:	4621      	mov	r1, r4
   1fb6a:	4638      	mov	r0, r7
   1fb6c:	f7ff ffc3 	bl	1faf6 <TCPIP_Helper_ProtectedSingleListTailAdd>
}
   1fb70:	4620      	mov	r0, r4
   1fb72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.DRV_ETHPHY_Tasks%790:

0001fb74 <DRV_ETHPHY_Tasks>:
{
   1fb74:	b508      	push	{r3, lr}
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1fb76:	4b07      	ldr	r3, [pc, #28]	; (1fb94 <DRV_ETHPHY_Tasks+0x20>)
   1fb78:	4283      	cmp	r3, r0
   1fb7a:	d109      	bne.n	1fb90 <DRV_ETHPHY_Tasks+0x1c>
    if(phyInst != 0)
   1fb7c:	b140      	cbz	r0, 1fb90 <DRV_ETHPHY_Tasks+0x1c>
            if(hClientObj->clientInUse != 0)
   1fb7e:	8b1b      	ldrh	r3, [r3, #24]
   1fb80:	b133      	cbz	r3, 1fb90 <DRV_ETHPHY_Tasks+0x1c>
                (*_DRV_PHY_ClientOpTbl[hClientObj->operType])(hClientObj);
   1fb82:	4804      	ldr	r0, [pc, #16]	; (1fb94 <DRV_ETHPHY_Tasks+0x20>)
   1fb84:	8e82      	ldrh	r2, [r0, #52]	; 0x34
   1fb86:	4b04      	ldr	r3, [pc, #16]	; (1fb98 <DRV_ETHPHY_Tasks+0x24>)
   1fb88:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1fb8c:	3018      	adds	r0, #24
   1fb8e:	4798      	blx	r3
} 
   1fb90:	bd08      	pop	{r3, pc}
   1fb92:	bf00      	nop
   1fb94:	2000e018 	.word	0x2000e018
   1fb98:	00020cfc 	.word	0x00020cfc

Disassembly of section .text.DRV_ETHPHY_PhyAddressGet%791:

0001fb9c <DRV_ETHPHY_PhyAddressGet>:
    if( hClientObj != 0)
   1fb9c:	b140      	cbz	r0, 1fbb0 <DRV_ETHPHY_PhyAddressGet+0x14>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1fb9e:	68c1      	ldr	r1, [r0, #12]
   1fba0:	4b07      	ldr	r3, [pc, #28]	; (1fbc0 <DRV_ETHPHY_PhyAddressGet+0x24>)
   1fba2:	4299      	cmp	r1, r3
   1fba4:	d107      	bne.n	1fbb6 <DRV_ETHPHY_PhyAddressGet+0x1a>
            if(pPhyAddress)
   1fba6:	b14a      	cbz	r2, 1fbbc <DRV_ETHPHY_PhyAddressGet+0x20>
                *pPhyAddress = hClientObj->hDriver->phyAddress;
   1fba8:	691b      	ldr	r3, [r3, #16]
   1fbaa:	6013      	str	r3, [r2, #0]
            return DRV_ETHPHY_RES_OK;
   1fbac:	2000      	movs	r0, #0
   1fbae:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1fbb0:	f06f 000a 	mvn.w	r0, #10
   1fbb4:	4770      	bx	lr
   1fbb6:	f06f 000a 	mvn.w	r0, #10
   1fbba:	4770      	bx	lr
            return DRV_ETHPHY_RES_OK;
   1fbbc:	2000      	movs	r0, #0
}
   1fbbe:	4770      	bx	lr
   1fbc0:	2000e018 	.word	0x2000e018

Disassembly of section .text._DRV_PHY_SetOperDoneResult%792:

0001fbc4 <_DRV_PHY_SetOperDoneResult>:
{
   1fbc4:	b508      	push	{r3, lr}
    hClientObj->operPhase =  hClientObj->operSubPhase = 0;
   1fbc6:	2300      	movs	r3, #0
   1fbc8:	8403      	strh	r3, [r0, #32]
   1fbca:	83c3      	strh	r3, [r0, #30]
    hClientObj->operType = DRV_ETHPHY_CLIENT_OP_TYPE_NONE;
   1fbcc:	8383      	strh	r3, [r0, #28]
    hClientObj->status = DRV_ETHPHY_CLIENT_STATUS_READY;
   1fbce:	2302      	movs	r3, #2
   1fbd0:	7203      	strb	r3, [r0, #8]
    hClientObj->operRes = res;
   1fbd2:	f880 102c 	strb.w	r1, [r0, #44]	; 0x2c
    if(res < 0)
   1fbd6:	2900      	cmp	r1, #0
   1fbd8:	db00      	blt.n	1fbdc <_DRV_PHY_SetOperDoneResult+0x18>
}
   1fbda:	bd08      	pop	{r3, pc}
   1fbdc:	460a      	mov	r2, r1
        SYS_CONSOLE_PRINT("DRV_PHY operation error: %d\r\n", res);
   1fbde:	4902      	ldr	r1, [pc, #8]	; (1fbe8 <_DRV_PHY_SetOperDoneResult+0x24>)
   1fbe0:	2000      	movs	r0, #0
   1fbe2:	f7fa fdc3 	bl	1a76c <SYS_CONSOLE_Print>
}
   1fbe6:	e7f8      	b.n	1fbda <_DRV_PHY_SetOperDoneResult+0x16>
   1fbe8:	00020870 	.word	0x00020870

Disassembly of section .text.DRV_ETHPHY_ClientOperationAbort%793:

0001fbec <DRV_ETHPHY_ClientOperationAbort>:
{
   1fbec:	b508      	push	{r3, lr}
    if( hClientObj != 0)
   1fbee:	b148      	cbz	r0, 1fc04 <DRV_ETHPHY_ClientOperationAbort+0x18>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   1fbf0:	68c1      	ldr	r1, [r0, #12]
   1fbf2:	4a07      	ldr	r2, [pc, #28]	; (1fc10 <DRV_ETHPHY_ClientOperationAbort+0x24>)
   1fbf4:	4291      	cmp	r1, r2
   1fbf6:	d108      	bne.n	1fc0a <DRV_ETHPHY_ClientOperationAbort+0x1e>
            _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_ABORTED);
   1fbf8:	f06f 010b 	mvn.w	r1, #11
   1fbfc:	f7ff ffe2 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
            return DRV_ETHPHY_RES_OK;
   1fc00:	2000      	movs	r0, #0
}
   1fc02:	bd08      	pop	{r3, pc}
    return DRV_ETHPHY_RES_HANDLE_ERR;
   1fc04:	f06f 000a 	mvn.w	r0, #10
   1fc08:	e7fb      	b.n	1fc02 <DRV_ETHPHY_ClientOperationAbort+0x16>
   1fc0a:	f06f 000a 	mvn.w	r0, #10
   1fc0e:	e7f8      	b.n	1fc02 <DRV_ETHPHY_ClientOperationAbort+0x16>
   1fc10:	2000e018 	.word	0x2000e018

Disassembly of section .text.DRV_PIC32CGMAC_LibSysIntStatus_Clear%794:

0001fc14 <DRV_PIC32CGMAC_LibSysIntStatus_Clear>:
    if(queMask & GMAC_QUE0_MASK)
   1fc14:	f011 0f01 	tst.w	r1, #1
   1fc18:	d00d      	beq.n	1fc36 <DRV_PIC32CGMAC_LibSysIntStatus_Clear+0x22>
        SYS_INT_SourceStatusClear(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc);                        
   1fc1a:	f9b0 30b6 	ldrsh.w	r3, [r0, #182]	; 0xb6
  if ((int32_t)(IRQn) >= 0)
   1fc1e:	2b00      	cmp	r3, #0
   1fc20:	db09      	blt.n	1fc36 <DRV_PIC32CGMAC_LibSysIntStatus_Clear+0x22>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1fc22:	095a      	lsrs	r2, r3, #5
   1fc24:	f003 031f 	and.w	r3, r3, #31
   1fc28:	2101      	movs	r1, #1
   1fc2a:	fa01 f303 	lsl.w	r3, r1, r3
   1fc2e:	3260      	adds	r2, #96	; 0x60
   1fc30:	4901      	ldr	r1, [pc, #4]	; (1fc38 <DRV_PIC32CGMAC_LibSysIntStatus_Clear+0x24>)
   1fc32:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
   1fc36:	4770      	bx	lr
   1fc38:	e000e100 	.word	0xe000e100

Disassembly of section .text.DRV_PIC32CGMAC_LibSysInt_Enable%795:

0001fc3c <DRV_PIC32CGMAC_LibSysInt_Enable>:
    if(queMask & GMAC_QUE0_MASK)
   1fc3c:	f011 0f01 	tst.w	r1, #1
   1fc40:	d00c      	beq.n	1fc5c <DRV_PIC32CGMAC_LibSysInt_Enable+0x20>
        SYS_INT_SourceEnable(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc);
   1fc42:	f9b0 30b6 	ldrsh.w	r3, [r0, #182]	; 0xb6
  if ((int32_t)(IRQn) >= 0)
   1fc46:	2b00      	cmp	r3, #0
   1fc48:	db08      	blt.n	1fc5c <DRV_PIC32CGMAC_LibSysInt_Enable+0x20>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1fc4a:	0959      	lsrs	r1, r3, #5
   1fc4c:	f003 031f 	and.w	r3, r3, #31
   1fc50:	2201      	movs	r2, #1
   1fc52:	fa02 f303 	lsl.w	r3, r2, r3
   1fc56:	4a02      	ldr	r2, [pc, #8]	; (1fc60 <DRV_PIC32CGMAC_LibSysInt_Enable+0x24>)
   1fc58:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
   1fc5c:	4770      	bx	lr
   1fc5e:	bf00      	nop
   1fc60:	e000e100 	.word	0xe000e100

Disassembly of section .text.DRV_MIIM_Status%796:

0001fc64 <DRV_MIIM_Status>:
    if(pMiimObj != 0)
   1fc64:	4603      	mov	r3, r0
   1fc66:	b158      	cbz	r0, 1fc80 <DRV_MIIM_Status+0x1c>
        if(pMiimObj->objStatus == SYS_STATUS_READY && (pMiimObj->objFlags & DRV_MIIM_OBJ_FLAG_IN_USE) != 0)
   1fc68:	f990 0008 	ldrsb.w	r0, [r0, #8]
   1fc6c:	2802      	cmp	r0, #2
   1fc6e:	d10a      	bne.n	1fc86 <DRV_MIIM_Status+0x22>
   1fc70:	889b      	ldrh	r3, [r3, #4]
   1fc72:	f003 0301 	and.w	r3, r3, #1
    return SYS_STATUS_ERROR;
   1fc76:	2b00      	cmp	r3, #0
   1fc78:	bf08      	it	eq
   1fc7a:	f04f 30ff 	moveq.w	r0, #4294967295
   1fc7e:	4770      	bx	lr
   1fc80:	f04f 30ff 	mov.w	r0, #4294967295
   1fc84:	4770      	bx	lr
   1fc86:	f04f 30ff 	mov.w	r0, #4294967295
} 
   1fc8a:	4770      	bx	lr

Disassembly of section .text.TCPIP_ICMP_Deinitialize%797:

0001fc8c <TCPIP_ICMP_Deinitialize>:
{
   1fc8c:	b508      	push	{r3, lr}
    if(icmpInitCount > 0)
   1fc8e:	4b08      	ldr	r3, [pc, #32]	; (1fcb0 <TCPIP_ICMP_Deinitialize+0x24>)
   1fc90:	681b      	ldr	r3, [r3, #0]
   1fc92:	2b00      	cmp	r3, #0
   1fc94:	dd02      	ble.n	1fc9c <TCPIP_ICMP_Deinitialize+0x10>
        if(stackCtrl->stackAction == TCPIP_STACK_ACTION_DEINIT)
   1fc96:	7f02      	ldrb	r2, [r0, #28]
   1fc98:	2a02      	cmp	r2, #2
   1fc9a:	d000      	beq.n	1fc9e <TCPIP_ICMP_Deinitialize+0x12>
}
   1fc9c:	bd08      	pop	{r3, pc}
            if(--icmpInitCount == 0)
   1fc9e:	3b01      	subs	r3, #1
   1fca0:	4a03      	ldr	r2, [pc, #12]	; (1fcb0 <TCPIP_ICMP_Deinitialize+0x24>)
   1fca2:	6013      	str	r3, [r2, #0]
   1fca4:	2b00      	cmp	r3, #0
   1fca6:	d1f9      	bne.n	1fc9c <TCPIP_ICMP_Deinitialize+0x10>
                TCPIP_ICMP_Cleanup();
   1fca8:	f7ff f93c 	bl	1ef24 <TCPIP_ICMP_Cleanup>
}
   1fcac:	e7f6      	b.n	1fc9c <TCPIP_ICMP_Deinitialize+0x10>
   1fcae:	bf00      	nop
   1fcb0:	2000e584 	.word	0x2000e584

Disassembly of section .text._TcpSocketChk%798:

0001fcb4 <_TcpSocketChk>:
    if(hTCP >= 0 && hTCP < TcpSockets)
   1fcb4:	2800      	cmp	r0, #0
   1fcb6:	db08      	blt.n	1fcca <_TcpSocketChk+0x16>
   1fcb8:	4b06      	ldr	r3, [pc, #24]	; (1fcd4 <_TcpSocketChk+0x20>)
   1fcba:	681b      	ldr	r3, [r3, #0]
   1fcbc:	4298      	cmp	r0, r3
   1fcbe:	d206      	bcs.n	1fcce <_TcpSocketChk+0x1a>
        return TCBStubs[hTCP];
   1fcc0:	4b05      	ldr	r3, [pc, #20]	; (1fcd8 <_TcpSocketChk+0x24>)
   1fcc2:	681b      	ldr	r3, [r3, #0]
   1fcc4:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
   1fcc8:	4770      	bx	lr
    return 0;
   1fcca:	2000      	movs	r0, #0
   1fccc:	4770      	bx	lr
   1fcce:	2000      	movs	r0, #0
}
   1fcd0:	4770      	bx	lr
   1fcd2:	bf00      	nop
   1fcd4:	2000e598 	.word	0x2000e598
   1fcd8:	2000e594 	.word	0x2000e594

Disassembly of section .text._TcpFlush%799:

0001fcdc <_TcpFlush>:
{
   1fcdc:	b508      	push	{r3, lr}
    if(pSkt->txHead != pSkt->txUnackedTail && pSkt->remoteWindow != 0)
   1fcde:	6882      	ldr	r2, [r0, #8]
   1fce0:	6903      	ldr	r3, [r0, #16]
   1fce2:	429a      	cmp	r2, r3
   1fce4:	d00c      	beq.n	1fd00 <_TcpFlush+0x24>
   1fce6:	f8b0 305c 	ldrh.w	r3, [r0, #92]	; 0x5c
   1fcea:	b90b      	cbnz	r3, 1fcf0 <_TcpFlush+0x14>
    return false;
   1fcec:	2000      	movs	r0, #0
}
   1fcee:	bd08      	pop	{r3, pc}
        return _TcpSend(pSkt, ACK, SENDTCP_RESET_TIMERS) == 0;
   1fcf0:	2201      	movs	r2, #1
   1fcf2:	2110      	movs	r1, #16
   1fcf4:	f7e7 f9c8 	bl	7088 <_TcpSend>
   1fcf8:	fab0 f080 	clz	r0, r0
   1fcfc:	0940      	lsrs	r0, r0, #5
   1fcfe:	e7f6      	b.n	1fcee <_TcpFlush+0x12>
    return false;
   1fd00:	2000      	movs	r0, #0
   1fd02:	e7f4      	b.n	1fcee <_TcpFlush+0x12>

Disassembly of section .text._ARPRemoveCacheEntries%800:

0001fd04 <_ARPRemoveCacheEntries>:
    if(pArpDcpt->hashDcpt)
   1fd04:	6803      	ldr	r3, [r0, #0]
   1fd06:	b183      	cbz	r3, 1fd2a <_ARPRemoveCacheEntries+0x26>
{
   1fd08:	b510      	push	{r4, lr}
   1fd0a:	4604      	mov	r4, r0
        TCPIP_OAHASH_EntriesRemoveAll(pArpDcpt->hashDcpt);
   1fd0c:	4618      	mov	r0, r3
   1fd0e:	f7ff f999 	bl	1f044 <TCPIP_OAHASH_EntriesRemoveAll>
        TCPIP_Helper_ProtectedSingleListRemoveAll(&pArpDcpt->incompleteList);
   1fd12:	f104 002c 	add.w	r0, r4, #44	; 0x2c
   1fd16:	f7ff ff03 	bl	1fb20 <TCPIP_Helper_ProtectedSingleListRemoveAll>
        TCPIP_Helper_ProtectedSingleListRemoveAll(&pArpDcpt->completeList);
   1fd1a:	f104 0018 	add.w	r0, r4, #24
   1fd1e:	f7ff feff 	bl	1fb20 <TCPIP_Helper_ProtectedSingleListRemoveAll>
        TCPIP_Helper_ProtectedSingleListRemoveAll(&pArpDcpt->permList);
   1fd22:	1d20      	adds	r0, r4, #4
   1fd24:	f7ff fefc 	bl	1fb20 <TCPIP_Helper_ProtectedSingleListRemoveAll>
}
   1fd28:	bd10      	pop	{r4, pc}
   1fd2a:	4770      	bx	lr

Disassembly of section .text.GenericTxDone%801:

0001fd2c <GenericTxDone>:
{
   1fd2c:	b510      	push	{r4, lr}
   1fd2e:	4604      	mov	r4, r0
    if ( pIState->statusReported == 0u )
   1fd30:	f890 30cd 	ldrb.w	r3, [r0, #205]	; 0xcd
   1fd34:	b13b      	cbz	r3, 1fd46 <GenericTxDone+0x1a>
    IperfSetState(pIState, IPERF_STANDBY_STATE);
   1fd36:	2101      	movs	r1, #1
   1fd38:	4620      	mov	r0, r4
   1fd3a:	f7fc f805 	bl	1bd48 <IperfSetState>
    ResetIperfCounters(pIState);
   1fd3e:	4620      	mov	r0, r4
   1fd40:	f7fc fcc4 	bl	1c6cc <ResetIperfCounters>
}
   1fd44:	bd10      	pop	{r4, pc}
        ReportBW_Jitter_Loss(pIState, SESSION_REPORT);
   1fd46:	2102      	movs	r1, #2
   1fd48:	f7ec ff6c 	bl	cc24 <ReportBW_Jitter_Loss>
        pIState->statusReported = 1;
   1fd4c:	2301      	movs	r3, #1
   1fd4e:	f884 30cd 	strb.w	r3, [r4, #205]	; 0xcd
   1fd52:	e7f0      	b.n	1fd36 <GenericTxDone+0xa>

Disassembly of section .text.Ipv4DeRegisterFilter%802:

0001fd54 <Ipv4DeRegisterFilter>:
{
   1fd54:	b508      	push	{r3, lr}
    if(hFilter && ipv4MemH)
   1fd56:	b138      	cbz	r0, 1fd68 <Ipv4DeRegisterFilter+0x14>
   1fd58:	4a05      	ldr	r2, [pc, #20]	; (1fd70 <Ipv4DeRegisterFilter+0x1c>)
   1fd5a:	6812      	ldr	r2, [r2, #0]
   1fd5c:	b132      	cbz	r2, 1fd6c <Ipv4DeRegisterFilter+0x18>
        if(TCPIP_Notification_CbackRemove((SGL_LIST_NODE*)hFilter, &ipv4PacketFilters, ipv4MemH, Ipv4DeRegisterCallback))
   1fd5e:	4b05      	ldr	r3, [pc, #20]	; (1fd74 <Ipv4DeRegisterFilter+0x20>)
   1fd60:	4905      	ldr	r1, [pc, #20]	; (1fd78 <Ipv4DeRegisterFilter+0x24>)
   1fd62:	f7fd f9cf 	bl	1d104 <TCPIP_Notification_CbackRemove>
}
   1fd66:	bd08      	pop	{r3, pc}
    return false;
   1fd68:	2000      	movs	r0, #0
   1fd6a:	e7fc      	b.n	1fd66 <Ipv4DeRegisterFilter+0x12>
   1fd6c:	2000      	movs	r0, #0
   1fd6e:	e7fa      	b.n	1fd66 <Ipv4DeRegisterFilter+0x12>
   1fd70:	2000e608 	.word	0x2000e608
   1fd74:	000217d1 	.word	0x000217d1
   1fd78:	2000e43c 	.word	0x2000e43c

Disassembly of section .text._DHCPOptionWriteParamRequest%803:

0001fd7c <_DHCPOptionWriteParamRequest>:
    if(pSendData->writeSpace >= sizeof(*pReqL) + nOptions)
   1fd7c:	684b      	ldr	r3, [r1, #4]
   1fd7e:	2b04      	cmp	r3, #4
   1fd80:	d90b      	bls.n	1fd9a <_DHCPOptionWriteParamRequest+0x1e>
        pReqL = (TCPIP_DHCP_OPTION_DATA_REQUEST_LIST*)pSendData->pOpt;
   1fd82:	680b      	ldr	r3, [r1, #0]
        pReqL->opt = TCPIP_DHCP_PARAM_REQUEST_LIST;
   1fd84:	2237      	movs	r2, #55	; 0x37
   1fd86:	701a      	strb	r2, [r3, #0]
        pReqL->len = (uint8_t)nOptions;
   1fd88:	2203      	movs	r2, #3
   1fd8a:	705a      	strb	r2, [r3, #1]
        memcpy(pReqL->optList, _DHCPRequestParamsTbl, nOptions);
   1fd8c:	4a04      	ldr	r2, [pc, #16]	; (1fda0 <_DHCPOptionWriteParamRequest+0x24>)
   1fd8e:	8811      	ldrh	r1, [r2, #0]
   1fd90:	7892      	ldrb	r2, [r2, #2]
   1fd92:	8059      	strh	r1, [r3, #2]
   1fd94:	711a      	strb	r2, [r3, #4]
        return sizeof(*pReqL) + nOptions;
   1fd96:	2005      	movs	r0, #5
   1fd98:	4770      	bx	lr
    return -1;
   1fd9a:	f04f 30ff 	mov.w	r0, #4294967295
}
   1fd9e:	4770      	bx	lr
   1fda0:	0002213c 	.word	0x0002213c

Disassembly of section .text.TCPIP_DHCP_IsActive%804:

0001fda4 <TCPIP_DHCP_IsActive>:
   1fda4:	b130      	cbz	r0, 1fdb4 <TCPIP_DHCP_IsActive+0x10>
   1fda6:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
   1fdaa:	f010 0f40 	tst.w	r0, #64	; 0x40
   1fdae:	d103      	bne.n	1fdb8 <TCPIP_DHCP_IsActive+0x14>
    return false;
   1fdb0:	2000      	movs	r0, #0
   1fdb2:	4770      	bx	lr
   1fdb4:	2000      	movs	r0, #0
   1fdb6:	4770      	bx	lr
    if(DHCPClients && pNetIf)
   1fdb8:	4b03      	ldr	r3, [pc, #12]	; (1fdc8 <TCPIP_DHCP_IsActive+0x24>)
   1fdba:	681b      	ldr	r3, [r3, #0]
   1fdbc:	b113      	cbz	r3, 1fdc4 <TCPIP_DHCP_IsActive+0x20>
        return pNetIf->Flags.bIsDHCPEnabled != 0;
   1fdbe:	f000 0001 	and.w	r0, r0, #1
   1fdc2:	4770      	bx	lr
    return false;
   1fdc4:	2000      	movs	r0, #0
}
   1fdc6:	4770      	bx	lr
   1fdc8:	2000e610 	.word	0x2000e610

Disassembly of section .text._TCPIP_STACK_TickHandler%805:

0001fdcc <_TCPIP_STACK_TickHandler>:
{
   1fdcc:	b508      	push	{r3, lr}
    newTcpipTickAvlbl++;
   1fdce:	4a07      	ldr	r2, [pc, #28]	; (1fdec <_TCPIP_STACK_TickHandler+0x20>)
   1fdd0:	6813      	ldr	r3, [r2, #0]
   1fdd2:	3301      	adds	r3, #1
   1fdd4:	6013      	str	r3, [r2, #0]
    pTmoEntry->signalVal |= TCPIP_MODULE_SIGNAL_TMO;
   1fdd6:	4806      	ldr	r0, [pc, #24]	; (1fdf0 <_TCPIP_STACK_TickHandler+0x24>)
   1fdd8:	8903      	ldrh	r3, [r0, #8]
   1fdda:	f043 0302 	orr.w	r3, r3, #2
   1fdde:	8103      	strh	r3, [r0, #8]
    _TCPIPSignalEntryNotify(pMgrEntry, TCPIP_MODULE_SIGNAL_TMO, 0);
   1fde0:	2200      	movs	r2, #0
   1fde2:	2102      	movs	r1, #2
   1fde4:	3010      	adds	r0, #16
   1fde6:	f001 f823 	bl	20e30 <_TCPIPSignalEntryNotify>
}
   1fdea:	bd08      	pop	{r3, pc}
   1fdec:	2000e638 	.word	0x2000e638
   1fdf0:	2000d1d4 	.word	0x2000d1d4

Disassembly of section .text._TCPIPSignalEntrySetNotify%806:

0001fdf4 <_TCPIPSignalEntrySetNotify>:
{
   1fdf4:	b570      	push	{r4, r5, r6, lr}
   1fdf6:	4604      	mov	r4, r0
   1fdf8:	460d      	mov	r5, r1
   1fdfa:	4616      	mov	r6, r2
    OSAL_CRITSECT_DATA_TYPE critSect =  OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1fdfc:	2000      	movs	r0, #0
   1fdfe:	f001 fb4d 	bl	2149c <OSAL_CRIT_Enter>
    pSigEntry->signalVal |= (uint16_t)signal;
   1fe02:	8923      	ldrh	r3, [r4, #8]
   1fe04:	432b      	orrs	r3, r5
   1fe06:	8123      	strh	r3, [r4, #8]
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critSect);
   1fe08:	4601      	mov	r1, r0
   1fe0a:	2000      	movs	r0, #0
   1fe0c:	f001 fc75 	bl	216fa <OSAL_CRIT_Leave>
    _TCPIPSignalEntryNotify(pSigEntry, signals, sigParam);
   1fe10:	4632      	mov	r2, r6
   1fe12:	4629      	mov	r1, r5
   1fe14:	4620      	mov	r0, r4
   1fe16:	f001 f80b 	bl	20e30 <_TCPIPSignalEntryNotify>
}
   1fe1a:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_STACK_IndexToNet%807:

0001fe1c <TCPIP_STACK_IndexToNet>:
    if(0 <= netIx && netIx < tcpip_stack_ctrl_data.nIfs)
   1fe1c:	2800      	cmp	r0, #0
   1fe1e:	db09      	blt.n	1fe34 <TCPIP_STACK_IndexToNet+0x18>
   1fe20:	4b06      	ldr	r3, [pc, #24]	; (1fe3c <TCPIP_STACK_IndexToNet+0x20>)
   1fe22:	681b      	ldr	r3, [r3, #0]
   1fe24:	4283      	cmp	r3, r0
   1fe26:	dd07      	ble.n	1fe38 <TCPIP_STACK_IndexToNet+0x1c>
        return tcpipNetIf + netIx;
   1fe28:	4b05      	ldr	r3, [pc, #20]	; (1fe40 <TCPIP_STACK_IndexToNet+0x24>)
   1fe2a:	681b      	ldr	r3, [r3, #0]
   1fe2c:	226c      	movs	r2, #108	; 0x6c
   1fe2e:	fb02 3000 	mla	r0, r2, r0, r3
   1fe32:	4770      	bx	lr
    return 0;
   1fe34:	2000      	movs	r0, #0
   1fe36:	4770      	bx	lr
   1fe38:	2000      	movs	r0, #0
}
   1fe3a:	4770      	bx	lr
   1fe3c:	2000e2f0 	.word	0x2000e2f0
   1fe40:	2000e648 	.word	0x2000e648

Disassembly of section .text.TCPIP_STACK_NetMACStatisticsGet%808:

0001fe44 <TCPIP_STACK_NetMACStatisticsGet>:
   1fe44:	b180      	cbz	r0, 1fe68 <TCPIP_STACK_NetMACStatisticsGet+0x24>
   1fe46:	4603      	mov	r3, r0
   1fe48:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
   1fe4c:	f010 0f40 	tst.w	r0, #64	; 0x40
   1fe50:	d101      	bne.n	1fe56 <TCPIP_STACK_NetMACStatisticsGet+0x12>
    return false;
   1fe52:	2000      	movs	r0, #0
}
   1fe54:	4770      	bx	lr
{
   1fe56:	b510      	push	{r4, lr}
        TCPIP_MAC_RES res = (*pNetIf->pMacObj->TCPIP_MAC_StatisticsGet)(pNetIf->hIfMac, pRxStatistics, pTxStatistics);
   1fe58:	6c58      	ldr	r0, [r3, #68]	; 0x44
   1fe5a:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
   1fe5c:	6d18      	ldr	r0, [r3, #80]	; 0x50
   1fe5e:	47a0      	blx	r4
        if(res == TCPIP_MAC_RES_OK)
   1fe60:	fab0 f080 	clz	r0, r0
   1fe64:	0940      	lsrs	r0, r0, #5
}
   1fe66:	bd10      	pop	{r4, pc}
    return false;
   1fe68:	2000      	movs	r0, #0
   1fe6a:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetMACRegisterStatisticsGet%809:

0001fe6c <TCPIP_STACK_NetMACRegisterStatisticsGet>:
   1fe6c:	b180      	cbz	r0, 1fe90 <TCPIP_STACK_NetMACRegisterStatisticsGet+0x24>
{
   1fe6e:	b538      	push	{r3, r4, r5, lr}
   1fe70:	4604      	mov	r4, r0
   1fe72:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
   1fe76:	f010 0f40 	tst.w	r0, #64	; 0x40
   1fe7a:	d101      	bne.n	1fe80 <TCPIP_STACK_NetMACRegisterStatisticsGet+0x14>
    return false;
   1fe7c:	2000      	movs	r0, #0
}
   1fe7e:	bd38      	pop	{r3, r4, r5, pc}
        TCPIP_MAC_RES res = (*pNetIf->pMacObj->TCPIP_MAC_RegisterStatisticsGet)(pNetIf->hIfMac, pRegEntries, nEntries, pHwEntries);
   1fe80:	6c60      	ldr	r0, [r4, #68]	; 0x44
   1fe82:	6c45      	ldr	r5, [r0, #68]	; 0x44
   1fe84:	6d20      	ldr	r0, [r4, #80]	; 0x50
   1fe86:	47a8      	blx	r5
        if(res == TCPIP_MAC_RES_OK)
   1fe88:	fab0 f080 	clz	r0, r0
   1fe8c:	0940      	lsrs	r0, r0, #5
   1fe8e:	e7f6      	b.n	1fe7e <TCPIP_STACK_NetMACRegisterStatisticsGet+0x12>
    return false;
   1fe90:	2000      	movs	r0, #0
}
   1fe92:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetIsBcastAddress%810:

0001fe94 <TCPIP_STACK_NetIsBcastAddress>:
   1fe94:	b180      	cbz	r0, 1feb8 <TCPIP_STACK_NetIsBcastAddress+0x24>
   1fe96:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   1fe9a:	f012 0f40 	tst.w	r2, #64	; 0x40
   1fe9e:	d101      	bne.n	1fea4 <TCPIP_STACK_NetIsBcastAddress+0x10>
    return false;
   1fea0:	2000      	movs	r0, #0
}
   1fea2:	4770      	bx	lr
       return (pIpAdd->Val == (pNetIf->netIPAddr.Val | ~pNetIf->netMask.Val));
   1fea4:	6882      	ldr	r2, [r0, #8]
   1fea6:	6840      	ldr	r0, [r0, #4]
   1fea8:	ea60 0002 	orn	r0, r0, r2
   1feac:	680b      	ldr	r3, [r1, #0]
   1feae:	4298      	cmp	r0, r3
   1feb0:	bf14      	ite	ne
   1feb2:	2000      	movne	r0, #0
   1feb4:	2001      	moveq	r0, #1
   1feb6:	4770      	bx	lr
    return false;
   1feb8:	2000      	movs	r0, #0
   1feba:	4770      	bx	lr

Disassembly of section .text._TCPIPStackSignalHandlerSetParams%811:

0001febc <_TCPIPStackSignalHandlerSetParams>:
    if((pSignalEntry = (TCPIP_MODULE_SIGNAL_ENTRY*)handle) != 0 && pSignalEntry->signalHandler != 0)
   1febc:	460b      	mov	r3, r1
   1febe:	b159      	cbz	r1, 1fed8 <_TCPIPStackSignalHandlerSetParams+0x1c>
   1fec0:	6809      	ldr	r1, [r1, #0]
   1fec2:	b159      	cbz	r1, 1fedc <_TCPIPStackSignalHandlerSetParams+0x20>
		if ((asyncTmoMs != 0) && (asyncTmoMs < stackTaskRate))
   1fec4:	b122      	cbz	r2, 1fed0 <_TCPIPStackSignalHandlerSetParams+0x14>
   1fec6:	4906      	ldr	r1, [pc, #24]	; (1fee0 <_TCPIPStackSignalHandlerSetParams+0x24>)
   1fec8:	6809      	ldr	r1, [r1, #0]
   1feca:	428a      	cmp	r2, r1
            asyncTmoMs = stackTaskRate;
   1fecc:	bf38      	it	cc
   1fece:	b20a      	sxthcc	r2, r1
        pSignalEntry->asyncTmo = pSignalEntry->currTmo = asyncTmoMs;
   1fed0:	819a      	strh	r2, [r3, #12]
   1fed2:	815a      	strh	r2, [r3, #10]
        return true;
   1fed4:	2001      	movs	r0, #1
   1fed6:	4770      	bx	lr
    return false;
   1fed8:	2000      	movs	r0, #0
   1feda:	4770      	bx	lr
   1fedc:	2000      	movs	r0, #0
}
   1fede:	4770      	bx	lr
   1fee0:	2000e640 	.word	0x2000e640

Disassembly of section .text._UDPSocketDcpt%812:

0001fee4 <_UDPSocketDcpt>:
    if(s >= 0 && s < nUdpSockets)
   1fee4:	2800      	cmp	r0, #0
   1fee6:	db08      	blt.n	1fefa <_UDPSocketDcpt+0x16>
   1fee8:	4b06      	ldr	r3, [pc, #24]	; (1ff04 <_UDPSocketDcpt+0x20>)
   1feea:	681b      	ldr	r3, [r3, #0]
   1feec:	4298      	cmp	r0, r3
   1feee:	da06      	bge.n	1fefe <_UDPSocketDcpt+0x1a>
       return UDPSocketDcpt[s];
   1fef0:	4b05      	ldr	r3, [pc, #20]	; (1ff08 <_UDPSocketDcpt+0x24>)
   1fef2:	681b      	ldr	r3, [r3, #0]
   1fef4:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
   1fef8:	4770      	bx	lr
    return 0;
   1fefa:	2000      	movs	r0, #0
   1fefc:	4770      	bx	lr
   1fefe:	2000      	movs	r0, #0
}
   1ff00:	4770      	bx	lr
   1ff02:	bf00      	nop
   1ff04:	2000e660 	.word	0x2000e660
   1ff08:	2000e65c 	.word	0x2000e65c

Disassembly of section .text._UDPUpdatePacketLock%813:

0001ff0c <_UDPUpdatePacketLock>:
{
   1ff0c:	b570      	push	{r4, r5, r6, lr}
   1ff0e:	4604      	mov	r4, r0
    OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
   1ff10:	2000      	movs	r0, #0
   1ff12:	f001 fac3 	bl	2149c <OSAL_CRIT_Enter>
   1ff16:	4606      	mov	r6, r0
    SGL_LIST_NODE* pNode = TCPIP_Helper_SingleListHeadRemove(&pSkt->rxQueue);
   1ff18:	f104 0044 	add.w	r0, r4, #68	; 0x44
   1ff1c:	f000 ff6c 	bl	20df8 <TCPIP_Helper_SingleListHeadRemove>
   1ff20:	4605      	mov	r5, r0
    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
   1ff22:	4631      	mov	r1, r6
   1ff24:	2000      	movs	r0, #0
   1ff26:	f001 fbe8 	bl	216fa <OSAL_CRIT_Leave>
    _UDPSetNewRxPacket(pSkt, pNextPkt);
   1ff2a:	4629      	mov	r1, r5
   1ff2c:	4620      	mov	r0, r4
   1ff2e:	f7fd fb6f 	bl	1d610 <_UDPSetNewRxPacket>
}
   1ff32:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TCPIP_UDP_GetIsReady%814:

0001ff34 <TCPIP_UDP_GetIsReady>:
{
   1ff34:	b510      	push	{r4, lr}
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   1ff36:	f7ff ffd5 	bl	1fee4 <_UDPSocketDcpt>
    if(pSkt == 0)
   1ff3a:	b168      	cbz	r0, 1ff58 <TCPIP_UDP_GetIsReady+0x24>
   1ff3c:	4604      	mov	r4, r0
    if(pSkt->pCurrRxSeg == 0 || pSkt->rxTotLen == 0)
   1ff3e:	6b03      	ldr	r3, [r0, #48]	; 0x30
   1ff40:	b10b      	cbz	r3, 1ff46 <TCPIP_UDP_GetIsReady+0x12>
   1ff42:	8ec3      	ldrh	r3, [r0, #54]	; 0x36
   1ff44:	b933      	cbnz	r3, 1ff54 <TCPIP_UDP_GetIsReady+0x20>
        _UDPUpdatePacketLock(pSkt);
   1ff46:	4620      	mov	r0, r4
   1ff48:	f7ff ffe0 	bl	1ff0c <_UDPUpdatePacketLock>
    return pSkt->pCurrRxSeg == 0 ? 0 : pSkt->rxTotLen;
   1ff4c:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1ff4e:	b90b      	cbnz	r3, 1ff54 <TCPIP_UDP_GetIsReady+0x20>
   1ff50:	2000      	movs	r0, #0
   1ff52:	e000      	b.n	1ff56 <TCPIP_UDP_GetIsReady+0x22>
   1ff54:	8ee0      	ldrh	r0, [r4, #54]	; 0x36
}
   1ff56:	bd10      	pop	{r4, pc}
        return 0;
   1ff58:	2000      	movs	r0, #0
   1ff5a:	e7fc      	b.n	1ff56 <TCPIP_UDP_GetIsReady+0x22>

Disassembly of section .text.TC0_Timer16bitCounterGet%815:

0001ff5c <TC0_Timer16bitCounterGet>:
    TC0_REGS->COUNT16.TC_CTRLBSET |= (uint8_t)TC_CTRLBSET_CMD_READSYNC;
   1ff5c:	4a08      	ldr	r2, [pc, #32]	; (1ff80 <TC0_Timer16bitCounterGet+0x24>)
   1ff5e:	7953      	ldrb	r3, [r2, #5]
   1ff60:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   1ff64:	7153      	strb	r3, [r2, #5]
    while((TC0_REGS->COUNT16.TC_SYNCBUSY & TC_SYNCBUSY_CTRLB_Msk) == TC_SYNCBUSY_CTRLB_Msk)
   1ff66:	6913      	ldr	r3, [r2, #16]
   1ff68:	f013 0f04 	tst.w	r3, #4
   1ff6c:	d1fb      	bne.n	1ff66 <TC0_Timer16bitCounterGet+0xa>
    while((TC0_REGS->COUNT16.TC_CTRLBSET & TC_CTRLBSET_CMD_Msk) != 0U)
   1ff6e:	4a04      	ldr	r2, [pc, #16]	; (1ff80 <TC0_Timer16bitCounterGet+0x24>)
   1ff70:	7953      	ldrb	r3, [r2, #5]
   1ff72:	f013 0fe0 	tst.w	r3, #224	; 0xe0
   1ff76:	d1fb      	bne.n	1ff70 <TC0_Timer16bitCounterGet+0x14>
    return (uint16_t)TC0_REGS->COUNT16.TC_COUNT;
   1ff78:	4b01      	ldr	r3, [pc, #4]	; (1ff80 <TC0_Timer16bitCounterGet+0x24>)
   1ff7a:	8a98      	ldrh	r0, [r3, #20]
}
   1ff7c:	4770      	bx	lr
   1ff7e:	bf00      	nop
   1ff80:	40003800 	.word	0x40003800

Disassembly of section .text.Console_UART_Initialize%816:

0001ff84 <Console_UART_Initialize>:
    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   1ff84:	b960      	cbnz	r0, 1ffa0 <Console_UART_Initialize+0x1c>
{
   1ff86:	b510      	push	{r4, lr}
   1ff88:	460c      	mov	r4, r1
    if(OSAL_MUTEX_Create(&(pConsoleUartData->mutexTransferObjects)) != OSAL_RESULT_TRUE)
   1ff8a:	4806      	ldr	r0, [pc, #24]	; (1ffa4 <Console_UART_Initialize+0x20>)
   1ff8c:	f001 fa9e 	bl	214cc <OSAL_MUTEX_Create>
   1ff90:	2801      	cmp	r0, #1
   1ff92:	d104      	bne.n	1ff9e <Console_UART_Initialize+0x1a>
    pConsoleUartData->uartPLIB = consoleUsartInitData->uartPLIB;
   1ff94:	6822      	ldr	r2, [r4, #0]
   1ff96:	4b04      	ldr	r3, [pc, #16]	; (1ffa8 <Console_UART_Initialize+0x24>)
   1ff98:	601a      	str	r2, [r3, #0]
    pConsoleUartData->status = SYS_CONSOLE_STATUS_CONFIGURED;
   1ff9a:	2201      	movs	r2, #1
   1ff9c:	711a      	strb	r2, [r3, #4]
}
   1ff9e:	bd10      	pop	{r4, pc}
   1ffa0:	4770      	bx	lr
   1ffa2:	bf00      	nop
   1ffa4:	2000e53c 	.word	0x2000e53c
   1ffa8:	2000e534 	.word	0x2000e534

Disassembly of section .text.SYS_TMR_TickCountGet%817:

0001ffac <SYS_TMR_TickCountGet>:
}

static uint32_t gTickConv = 0;

uint32_t SYS_TMR_TickCountGet(void)
{
   1ffac:	b508      	push	{r3, lr}
    if(gTickConv == 0)
   1ffae:	4b08      	ldr	r3, [pc, #32]	; (1ffd0 <SYS_TMR_TickCountGet+0x24>)
   1ffb0:	681b      	ldr	r3, [r3, #0]
   1ffb2:	b13b      	cbz	r3, 1ffc4 <SYS_TMR_TickCountGet+0x18>
    {
        gTickConv = SYS_TIME_MSToCount(1);
    }

    return (uint32_t)(SYS_TIME_Counter64Get() / (uint64_t)gTickConv);
   1ffb4:	f7fe f8ac 	bl	1e110 <SYS_TIME_Counter64Get>
   1ffb8:	4b05      	ldr	r3, [pc, #20]	; (1ffd0 <SYS_TMR_TickCountGet+0x24>)
   1ffba:	681a      	ldr	r2, [r3, #0]
   1ffbc:	2300      	movs	r3, #0
   1ffbe:	f7ff f9d9 	bl	1f374 <__aeabi_uldivmod>
}
   1ffc2:	bd08      	pop	{r3, pc}
        gTickConv = SYS_TIME_MSToCount(1);
   1ffc4:	2001      	movs	r0, #1
   1ffc6:	f000 fff7 	bl	20fb8 <SYS_TIME_MSToCount>
   1ffca:	4b01      	ldr	r3, [pc, #4]	; (1ffd0 <SYS_TMR_TickCountGet+0x24>)
   1ffcc:	6018      	str	r0, [r3, #0]
   1ffce:	e7f1      	b.n	1ffb4 <SYS_TMR_TickCountGet+0x8>
   1ffd0:	2000e684 	.word	0x2000e684

Disassembly of section .text.SYS_TMR_TickCountGetLong%818:

0001ffd4 <SYS_TMR_TickCountGetLong>:

uint64_t SYS_TMR_TickCountGetLong(void)
{
   1ffd4:	b508      	push	{r3, lr}
    if(gTickConv == 0)
   1ffd6:	4b08      	ldr	r3, [pc, #32]	; (1fff8 <SYS_TMR_TickCountGetLong+0x24>)
   1ffd8:	681b      	ldr	r3, [r3, #0]
   1ffda:	b13b      	cbz	r3, 1ffec <SYS_TMR_TickCountGetLong+0x18>
    {
        gTickConv = SYS_TIME_MSToCount(1);
    }

	return SYS_TIME_Counter64Get() / (uint64_t)gTickConv;
   1ffdc:	f7fe f898 	bl	1e110 <SYS_TIME_Counter64Get>
   1ffe0:	4b05      	ldr	r3, [pc, #20]	; (1fff8 <SYS_TMR_TickCountGetLong+0x24>)
   1ffe2:	681a      	ldr	r2, [r3, #0]
   1ffe4:	2300      	movs	r3, #0
   1ffe6:	f7ff f9c5 	bl	1f374 <__aeabi_uldivmod>
}
   1ffea:	bd08      	pop	{r3, pc}
        gTickConv = SYS_TIME_MSToCount(1);
   1ffec:	2001      	movs	r0, #1
   1ffee:	f000 ffe3 	bl	20fb8 <SYS_TIME_MSToCount>
   1fff2:	4b01      	ldr	r3, [pc, #4]	; (1fff8 <SYS_TMR_TickCountGetLong+0x24>)
   1fff4:	6018      	str	r0, [r3, #0]
   1fff6:	e7f1      	b.n	1ffdc <SYS_TMR_TickCountGetLong+0x8>
   1fff8:	2000e684 	.word	0x2000e684

Disassembly of section .text.SYS_TMR_TickCounterFrequencyGet%819:

0001fffc <SYS_TMR_TickCounterFrequencyGet>:

uint32_t SYS_TMR_TickCounterFrequencyGet ( void )
{
   1fffc:	b508      	push	{r3, lr}
    if(gTickConv == 0)
   1fffe:	4b08      	ldr	r3, [pc, #32]	; (20020 <SYS_TMR_TickCounterFrequencyGet+0x24>)
   20000:	681b      	ldr	r3, [r3, #0]
   20002:	b133      	cbz	r3, 20012 <SYS_TMR_TickCounterFrequencyGet+0x16>
    {
        gTickConv = SYS_TIME_MSToCount(1);
    }

	return SYS_TIME_FrequencyGet() / gTickConv;
   20004:	f001 ffa8 	bl	21f58 <SYS_TIME_FrequencyGet>
   20008:	4b05      	ldr	r3, [pc, #20]	; (20020 <SYS_TMR_TickCounterFrequencyGet+0x24>)
   2000a:	681b      	ldr	r3, [r3, #0]
}
   2000c:	fbb0 f0f3 	udiv	r0, r0, r3
   20010:	bd08      	pop	{r3, pc}
        gTickConv = SYS_TIME_MSToCount(1);
   20012:	2001      	movs	r0, #1
   20014:	f000 ffd0 	bl	20fb8 <SYS_TIME_MSToCount>
   20018:	4b01      	ldr	r3, [pc, #4]	; (20020 <SYS_TMR_TickCounterFrequencyGet+0x24>)
   2001a:	6018      	str	r0, [r3, #0]
   2001c:	e7f2      	b.n	20004 <SYS_TMR_TickCounterFrequencyGet+0x8>
   2001e:	bf00      	nop
   20020:	2000e684 	.word	0x2000e684

Disassembly of section .rodata.tcpipARPInitData%820:

00020024 <tcpipARPInitData>:
   20024:	00000005 00000001 000004b0 0000003c     ............<...
   20034:	00000002 00000032 0000004b 00000001     ....2...K.......
   20044:	00000003 00000001                       ........

Disassembly of section .text.prvPortStartFirstTask%821:

0002004c <prvPortStartFirstTask>:
	__asm volatile(
   2004c:	4808      	ldr	r0, [pc, #32]	; (20070 <prvPortStartFirstTask+0x24>)
   2004e:	6800      	ldr	r0, [r0, #0]
   20050:	6800      	ldr	r0, [r0, #0]
   20052:	f380 8808 	msr	MSP, r0
   20056:	f04f 0000 	mov.w	r0, #0
   2005a:	f380 8814 	msr	CONTROL, r0
   2005e:	b662      	cpsie	i
   20060:	b661      	cpsie	f
   20062:	f3bf 8f4f 	dsb	sy
   20066:	f3bf 8f6f 	isb	sy
   2006a:	df00      	svc	0
   2006c:	bf00      	nop
}
   2006e:	0000      	.short	0x0000
   20070:	e000ed08 	.word	0xe000ed08

Disassembly of section .text.vPortSetupTimerInterrupt%822:

00020074 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Stop and clear the SysTick. */
	portNVIC_SYSTICK_CTRL_REG = 0UL;
   20074:	4b05      	ldr	r3, [pc, #20]	; (2008c <vPortSetupTimerInterrupt+0x18>)
   20076:	2200      	movs	r2, #0
   20078:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
   2007a:	4905      	ldr	r1, [pc, #20]	; (20090 <vPortSetupTimerInterrupt+0x1c>)
   2007c:	600a      	str	r2, [r1, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
   2007e:	4a05      	ldr	r2, [pc, #20]	; (20094 <vPortSetupTimerInterrupt+0x20>)
   20080:	4905      	ldr	r1, [pc, #20]	; (20098 <vPortSetupTimerInterrupt+0x24>)
   20082:	6011      	str	r1, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
   20084:	2207      	movs	r2, #7
   20086:	601a      	str	r2, [r3, #0]
}
   20088:	4770      	bx	lr
   2008a:	bf00      	nop
   2008c:	e000e010 	.word	0xe000e010
   20090:	e000e018 	.word	0xe000e018
   20094:	e000e014 	.word	0xe000e014
   20098:	0001d4bf 	.word	0x0001d4bf

Disassembly of section .rodata.__mprec_bigtens%823:

000200a0 <__mprec_bigtens>:
   200a0:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
   200b0:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
   200c0:	7f73bf3c 75154fdd                       <.s..O.u

Disassembly of section .text.read%824:

000200c8 <read>:
   200c8:	b570      	push	{r4, r5, r6, lr}
   200ca:	b169      	cbz	r1, 200e8 <read+0x20>
   200cc:	4615      	mov	r5, r2
   200ce:	b14a      	cbz	r2, 200e4 <read+0x1c>
   200d0:	b940      	cbnz	r0, 200e4 <read+0x1c>
   200d2:	460c      	mov	r4, r1
   200d4:	188e      	adds	r6, r1, r2
   200d6:	2001      	movs	r0, #1
   200d8:	f002 f836 	bl	22148 <_mon_getc>
   200dc:	f804 0b01 	strb.w	r0, [r4], #1
   200e0:	42a6      	cmp	r6, r4
   200e2:	d1f8      	bne.n	200d6 <read+0xe>
   200e4:	4628      	mov	r0, r5
   200e6:	bd70      	pop	{r4, r5, r6, pc}
   200e8:	460d      	mov	r5, r1
   200ea:	4628      	mov	r0, r5
   200ec:	bd70      	pop	{r4, r5, r6, pc}
   200ee:	bf00      	nop

Disassembly of section .text._DRV_ETHPHY_NegResultPhase_ANEXP%825:

000200f0 <_DRV_ETHPHY_NegResultPhase_ANEXP>:
{
   200f0:	b510      	push	{r4, lr}
   200f2:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   200f4:	f000 fab6 	bl	20664 <_DRV_PHY_SMITransfer_Wait>
   200f8:	b900      	cbnz	r0, 200fc <_DRV_ETHPHY_NegResultPhase_ANEXP+0xc>
}
   200fa:	bd10      	pop	{r4, pc}
    hClientObj->operReg[0] = hClientObj->smiData;
   200fc:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   200fe:	8463      	strh	r3, [r4, #34]	; 0x22
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_ANLPAD))
   20100:	2105      	movs	r1, #5
   20102:	4620      	mov	r0, r4
   20104:	f7fe fe18 	bl	1ed38 <_DRV_PHY_SMIReadStart>
   20108:	2800      	cmp	r0, #0
   2010a:	d0f6      	beq.n	200fa <_DRV_ETHPHY_NegResultPhase_ANEXP+0xa>
    hClientObj->operPhase = operPhase;
   2010c:	2303      	movs	r3, #3
   2010e:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   20110:	2300      	movs	r3, #0
   20112:	8423      	strh	r3, [r4, #32]
   20114:	e7f1      	b.n	200fa <_DRV_ETHPHY_NegResultPhase_ANEXP+0xa>

Disassembly of section .text._DRV_ETHPHY_NegResultPhase_ANLPAD%826:

00020116 <_DRV_ETHPHY_NegResultPhase_ANLPAD>:
{
   20116:	b510      	push	{r4, lr}
   20118:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   2011a:	f000 faa3 	bl	20664 <_DRV_PHY_SMITransfer_Wait>
   2011e:	b900      	cbnz	r0, 20122 <_DRV_ETHPHY_NegResultPhase_ANLPAD+0xc>
}
   20120:	bd10      	pop	{r4, pc}
    hClientObj->operReg[1] = hClientObj->smiData;
   20122:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   20124:	84a3      	strh	r3, [r4, #36]	; 0x24
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_ANAD))
   20126:	2104      	movs	r1, #4
   20128:	4620      	mov	r0, r4
   2012a:	f7fe fe05 	bl	1ed38 <_DRV_PHY_SMIReadStart>
   2012e:	2800      	cmp	r0, #0
   20130:	d0f6      	beq.n	20120 <_DRV_ETHPHY_NegResultPhase_ANLPAD+0xa>
    hClientObj->operPhase = operPhase;
   20132:	2304      	movs	r3, #4
   20134:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   20136:	2300      	movs	r3, #0
   20138:	8423      	strh	r3, [r4, #32]
   2013a:	e7f1      	b.n	20120 <_DRV_ETHPHY_NegResultPhase_ANLPAD+0xa>

Disassembly of section .text.TCPIP_TCP_IsConnected%827:

0002013c <TCPIP_TCP_IsConnected>:
{
   2013c:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   2013e:	f7ff fdb9 	bl	1fcb4 <_TcpSocketChk>
    return (pSkt) ? _TCP_IsConnected(pSkt) : false;
   20142:	b160      	cbz	r0, 2015e <TCPIP_TCP_IsConnected+0x22>
    return (pSkt->smState == TCPIP_TCP_STATE_ESTABLISHED || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_1 || pSkt->smState == TCPIP_TCP_STATE_FIN_WAIT_2 || pSkt->smState == TCPIP_TCP_STATE_CLOSE_WAIT);
   20144:	f890 006e 	ldrb.w	r0, [r0, #110]	; 0x6e
   20148:	1ec3      	subs	r3, r0, #3
   2014a:	b2db      	uxtb	r3, r3
   2014c:	2b02      	cmp	r3, #2
   2014e:	d904      	bls.n	2015a <TCPIP_TCP_IsConnected+0x1e>
   20150:	2808      	cmp	r0, #8
   20152:	bf14      	ite	ne
   20154:	2000      	movne	r0, #0
   20156:	2001      	moveq	r0, #1
   20158:	e000      	b.n	2015c <TCPIP_TCP_IsConnected+0x20>
   2015a:	2001      	movs	r0, #1
}
   2015c:	bd08      	pop	{r3, pc}
    return (pSkt) ? _TCP_IsConnected(pSkt) : false;
   2015e:	2000      	movs	r0, #0
   20160:	e7fc      	b.n	2015c <TCPIP_TCP_IsConnected+0x20>

Disassembly of section .text.TCPIP_TCP_Flush%828:

00020162 <TCPIP_TCP_Flush>:
{
   20162:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   20164:	f7ff fda6 	bl	1fcb4 <_TcpSocketChk>
    if(pSkt && _TCP_TxPktValid(pSkt))
   20168:	b150      	cbz	r0, 20180 <TCPIP_TCP_Flush+0x1e>
    switch(pSkt->addType)
   2016a:	f890 206f 	ldrb.w	r2, [r0, #111]	; 0x6f
   2016e:	2a01      	cmp	r2, #1
   20170:	d001      	beq.n	20176 <TCPIP_TCP_Flush+0x14>
    return false;
   20172:	2000      	movs	r0, #0
}
   20174:	bd08      	pop	{r3, pc}
    if(pSkt && _TCP_TxPktValid(pSkt))
   20176:	6c42      	ldr	r2, [r0, #68]	; 0x44
   20178:	b122      	cbz	r2, 20184 <TCPIP_TCP_Flush+0x22>
        return _TcpFlush(pSkt);
   2017a:	f7ff fdaf 	bl	1fcdc <_TcpFlush>
   2017e:	e7f9      	b.n	20174 <TCPIP_TCP_Flush+0x12>
    return false;
   20180:	2000      	movs	r0, #0
   20182:	e7f7      	b.n	20174 <TCPIP_TCP_Flush+0x12>
   20184:	2000      	movs	r0, #0
   20186:	e7f5      	b.n	20174 <TCPIP_TCP_Flush+0x12>

Disassembly of section .text.TCPIP_TCP_Discard%829:

00020188 <TCPIP_TCP_Discard>:
{
   20188:	b538      	push	{r3, r4, r5, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   2018a:	f7ff fd93 	bl	1fcb4 <_TcpSocketChk>
    if(pSkt)
   2018e:	b160      	cbz	r0, 201aa <TCPIP_TCP_Discard+0x22>
   20190:	4604      	mov	r4, r0
        nBytes = _TCPIsGetReady(pSkt);
   20192:	f000 fd2c 	bl	20bee <_TCPIsGetReady>
        if(nBytes)
   20196:	4605      	mov	r5, r0
   20198:	b908      	cbnz	r0, 2019e <TCPIP_TCP_Discard+0x16>
}
   2019a:	4628      	mov	r0, r5
   2019c:	bd38      	pop	{r3, r4, r5, pc}
            pSkt->rxTail = pSkt->rxHead;
   2019e:	69e3      	ldr	r3, [r4, #28]
   201a0:	6223      	str	r3, [r4, #32]
            _TCPSendWinIncUpdate(pSkt);
   201a2:	4620      	mov	r0, r4
   201a4:	f7fc fc9c 	bl	1cae0 <_TCPSendWinIncUpdate>
   201a8:	e7f7      	b.n	2019a <TCPIP_TCP_Discard+0x12>
    uint16_t nBytes = 0;
   201aa:	2500      	movs	r5, #0
   201ac:	e7f5      	b.n	2019a <TCPIP_TCP_Discard+0x12>

Disassembly of section .text.TCPIP_OAHASH_Initialize%830:

000201ae <TCPIP_OAHASH_Initialize>:
    pOH->fullSlots = 0; 
   201ae:	2300      	movs	r3, #0
   201b0:	6243      	str	r3, [r0, #36]	; 0x24
    pHE = (OA_HASH_ENTRY*)pOH->memBlk;
   201b2:	6803      	ldr	r3, [r0, #0]
    for(ix = 0; ix < pOH->hEntries; ix++)
   201b4:	68c2      	ldr	r2, [r0, #12]
   201b6:	b162      	cbz	r2, 201d2 <TCPIP_OAHASH_Initialize+0x24>
{
   201b8:	b410      	push	{r4}
    for(ix = 0; ix < pOH->hEntries; ix++)
   201ba:	2200      	movs	r2, #0
        pHE->flags.value = 0;
   201bc:	4614      	mov	r4, r2
   201be:	801c      	strh	r4, [r3, #0]
        pHE = (OA_HASH_ENTRY*)((uint8_t*)pHE + pOH->hEntrySize);
   201c0:	6881      	ldr	r1, [r0, #8]
   201c2:	440b      	add	r3, r1
    for(ix = 0; ix < pOH->hEntries; ix++)
   201c4:	3201      	adds	r2, #1
   201c6:	68c1      	ldr	r1, [r0, #12]
   201c8:	4291      	cmp	r1, r2
   201ca:	d8f8      	bhi.n	201be <TCPIP_OAHASH_Initialize+0x10>
}
   201cc:	f85d 4b04 	ldr.w	r4, [sp], #4
   201d0:	4770      	bx	lr
   201d2:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_DNSServiceSelect%831:

000201d4 <TCPIP_STACK_DNSServiceSelect>:
    pNetIf->Flags.v &= ~TCPIP_STACK_DNS_SERVICE_MASK;
   201d4:	f8b0 3042 	ldrh.w	r3, [r0, #66]	; 0x42
   201d8:	f023 0318 	bic.w	r3, r3, #24
   201dc:	f8a0 3042 	strh.w	r3, [r0, #66]	; 0x42
        if((configFlags & TCPIP_NETWORK_CONFIG_DNS_CLIENT_ON) != 0 )
   201e0:	f011 0f08 	tst.w	r1, #8
   201e4:	d101      	bne.n	201ea <TCPIP_STACK_DNSServiceSelect+0x16>
    return TCPIP_STACK_DNS_SERVICE_NONE;
   201e6:	2000      	movs	r0, #0
}
   201e8:	4770      	bx	lr
            pNetIf->Flags.bIsDnsClientEnabled = 1;
   201ea:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   201ee:	f043 0308 	orr.w	r3, r3, #8
   201f2:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
            return TCPIP_STACK_DNS_SERVICE_CLIENT;
   201f6:	2001      	movs	r0, #1
   201f8:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_AddressServiceSelect%832:

000201fa <TCPIP_STACK_AddressServiceSelect>:
    pNetIf->Flags.v &= ~TCPIP_STACK_ADDRESS_SERVICE_MASK;
   201fa:	f8b0 3042 	ldrh.w	r3, [r0, #66]	; 0x42
   201fe:	f023 0307 	bic.w	r3, r3, #7
   20202:	f8a0 3042 	strh.w	r3, [r0, #66]	; 0x42
    if((configFlags & TCPIP_NETWORK_CONFIG_DHCP_CLIENT_ON) != 0 )
   20206:	f011 0f01 	tst.w	r1, #1
   2020a:	d101      	bne.n	20210 <TCPIP_STACK_AddressServiceSelect+0x16>
    return TCPIP_STACK_ADDRESS_SERVICE_NONE;
   2020c:	2000      	movs	r0, #0
}
   2020e:	4770      	bx	lr
        pNetIf->Flags.bIsDHCPEnabled = 1;
   20210:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
   20214:	f043 0301 	orr.w	r3, r3, #1
   20218:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
        return TCPIP_STACK_ADDRESS_SERVICE_DHCPC;
   2021c:	2001      	movs	r0, #1
   2021e:	4770      	bx	lr

Disassembly of section .text.SYS_RANDOM_CryptoBlockGet%833:

00020220 <SYS_RANDOM_CryptoBlockGet>:
}



size_t SYS_RANDOM_CryptoBlockGet( void *buffer, size_t size )
{
   20220:	b538      	push	{r3, r4, r5, lr}
    if(buffer != 0 && size != 0)
   20222:	b170      	cbz	r0, 20242 <SYS_RANDOM_CryptoBlockGet+0x22>
   20224:	460c      	mov	r4, r1
   20226:	4605      	mov	r5, r0
   20228:	b909      	cbnz	r1, 2022e <SYS_RANDOM_CryptoBlockGet+0xe>
            return size;
        }
    }

    return 0;
}
   2022a:	4620      	mov	r0, r4
   2022c:	bd38      	pop	{r3, r4, r5, pc}
        CRYPT_RNG_CTX* pCtx = _SYS_RANDOM_CryptoContext();
   2022e:	f001 f9ad 	bl	2158c <_SYS_RANDOM_CryptoContext>
        if(pCtx)
   20232:	b908      	cbnz	r0, 20238 <SYS_RANDOM_CryptoBlockGet+0x18>
    return 0;
   20234:	2400      	movs	r4, #0
   20236:	e7f8      	b.n	2022a <SYS_RANDOM_CryptoBlockGet+0xa>
            CRYPT_RNG_BlockGenerate(pCtx, (uint8_t*)buffer, size);
   20238:	4622      	mov	r2, r4
   2023a:	4629      	mov	r1, r5
   2023c:	f001 f83d 	bl	212ba <CRYPT_RNG_BlockGenerate>
            return size;
   20240:	e7f3      	b.n	2022a <SYS_RANDOM_CryptoBlockGet+0xa>
    return 0;
   20242:	2400      	movs	r4, #0
   20244:	e7f1      	b.n	2022a <SYS_RANDOM_CryptoBlockGet+0xa>

Disassembly of section .text.strncpy%834:

00020246 <strncpy>:
   20246:	b510      	push	{r4, lr}
   20248:	3901      	subs	r1, #1
   2024a:	4603      	mov	r3, r0
   2024c:	b132      	cbz	r2, 2025c <strncpy+0x16>
   2024e:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   20252:	f803 4b01 	strb.w	r4, [r3], #1
   20256:	3a01      	subs	r2, #1
   20258:	2c00      	cmp	r4, #0
   2025a:	d1f7      	bne.n	2024c <strncpy+0x6>
   2025c:	441a      	add	r2, r3
   2025e:	2100      	movs	r1, #0
   20260:	4293      	cmp	r3, r2
   20262:	d100      	bne.n	20266 <strncpy+0x20>
   20264:	bd10      	pop	{r4, pc}
   20266:	f803 1b01 	strb.w	r1, [r3], #1
   2026a:	e7f9      	b.n	20260 <strncpy+0x1a>

Disassembly of section .text.DRV_ETHPHY_VendorDataSet%835:

0002026c <DRV_ETHPHY_VendorDataSet>:
    if(hClientObj != 0)
   2026c:	4603      	mov	r3, r0
   2026e:	b130      	cbz	r0, 2027e <DRV_ETHPHY_VendorDataSet+0x12>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   20270:	68c0      	ldr	r0, [r0, #12]
   20272:	4a06      	ldr	r2, [pc, #24]	; (2028c <DRV_ETHPHY_VendorDataSet+0x20>)
   20274:	4290      	cmp	r0, r2
   20276:	d105      	bne.n	20284 <DRV_ETHPHY_VendorDataSet+0x18>
            hClientObj->vendorData = vendorData;
   20278:	6419      	str	r1, [r3, #64]	; 0x40
            return DRV_ETHPHY_RES_OK;
   2027a:	2000      	movs	r0, #0
   2027c:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   2027e:	f06f 000a 	mvn.w	r0, #10
   20282:	4770      	bx	lr
   20284:	f06f 000a 	mvn.w	r0, #10
}
   20288:	4770      	bx	lr
   2028a:	bf00      	nop
   2028c:	2000e018 	.word	0x2000e018

Disassembly of section .rodata%836:

00020290 <.rodata%836>:
   20290:	20565244 	.word	0x20565244
   20294:	20594850 	.word	0x20594850
   20298:	74696e69 	.word	0x74696e69
   2029c:	69616620 	.word	0x69616620
   202a0:	3a64656c 	.word	0x3a64656c
   202a4:	0d642520 	.word	0x0d642520
   202a8:	0000000a 	.word	0x0000000a
   202ac:	43414d47 	.word	0x43414d47
   202b0:	00          	.byte	0x00
   202b1:	00          	.byte	0x00
   202b2:	bf00      	nop

Disassembly of section .text.DRV_PIC32CGMAC_LibSysInt_Disable%837:

000202b4 <DRV_PIC32CGMAC_LibSysInt_Disable>:
    if(queMask & GMAC_QUE0_MASK)
   202b4:	f011 0f01 	tst.w	r1, #1
   202b8:	d00d      	beq.n	202d6 <DRV_PIC32CGMAC_LibSysInt_Disable+0x22>
{
   202ba:	b510      	push	{r4, lr}
   202bc:	4614      	mov	r4, r2
        if(queStat)
   202be:	b12a      	cbz	r2, 202cc <DRV_PIC32CGMAC_LibSysInt_Disable+0x18>
            queStat[GMAC_QUE_0] = SYS_INT_SourceDisable(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc);
   202c0:	f9b0 00b6 	ldrsh.w	r0, [r0, #182]	; 0xb6
   202c4:	f7fd f896 	bl	1d3f4 <SYS_INT_SourceDisable>
   202c8:	7020      	strb	r0, [r4, #0]
}
   202ca:	bd10      	pop	{r4, pc}
            SYS_INT_SourceDisable(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc);
   202cc:	f9b0 00b6 	ldrsh.w	r0, [r0, #182]	; 0xb6
   202d0:	f7fd f890 	bl	1d3f4 <SYS_INT_SourceDisable>
}
   202d4:	e7f9      	b.n	202ca <DRV_PIC32CGMAC_LibSysInt_Disable+0x16>
   202d6:	4770      	bx	lr

Disassembly of section .text._ICMPAllocateTxPacketStruct%838:

000202d8 <_ICMPAllocateTxPacketStruct>:
{
   202d8:	b508      	push	{r3, lr}
    ptrPacket = (IPV4_PACKET*)TCPIP_PKT_SocketAlloc(sizeof(IPV4_PACKET), totICMPLen, 0, TCPIP_MAC_PKT_FLAG_ICMPV4 | TCPIP_MAC_PKT_FLAG_IPV4 | TCPIP_MAC_PKT_FLAG_TX);
   202da:	2302      	movs	r3, #2
   202dc:	2200      	movs	r2, #0
   202de:	4601      	mov	r1, r0
   202e0:	2044      	movs	r0, #68	; 0x44
   202e2:	f7ff fa7f 	bl	1f7e4 <_TCPIP_PKT_SocketAlloc>
    if (ptrPacket != 0)
   202e6:	4603      	mov	r3, r0
   202e8:	b118      	cbz	r0, 202f2 <_ICMPAllocateTxPacketStruct+0x1a>
    pPkt->ackFunc = ackFunc;
   202ea:	4a03      	ldr	r2, [pc, #12]	; (202f8 <_ICMPAllocateTxPacketStruct+0x20>)
   202ec:	6082      	str	r2, [r0, #8]
    pPkt->ackParam = ackParam;
   202ee:	2200      	movs	r2, #0
   202f0:	60c2      	str	r2, [r0, #12]
}
   202f2:	4618      	mov	r0, r3
   202f4:	bd08      	pop	{r3, pc}
   202f6:	bf00      	nop
   202f8:	00021fcf 	.word	0x00021fcf

Disassembly of section .text.TCPIP_ICMP_EchoRequestCancel%839:

000202fc <TCPIP_ICMP_EchoRequestCancel>:
    if(icmpHandle == pIcmpEchoRequest && pIcmpEchoRequest != 0)
   202fc:	4b07      	ldr	r3, [pc, #28]	; (2031c <TCPIP_ICMP_EchoRequestCancel+0x20>)
   202fe:	681b      	ldr	r3, [r3, #0]
   20300:	4283      	cmp	r3, r0
   20302:	d104      	bne.n	2030e <TCPIP_ICMP_EchoRequestCancel+0x12>
   20304:	b133      	cbz	r3, 20314 <TCPIP_ICMP_EchoRequestCancel+0x18>
        pIcmpEchoRequest = 0;    // free
   20306:	2000      	movs	r0, #0
   20308:	4b04      	ldr	r3, [pc, #16]	; (2031c <TCPIP_ICMP_EchoRequestCancel+0x20>)
   2030a:	6018      	str	r0, [r3, #0]
        return ICMP_ECHO_OK;
   2030c:	4770      	bx	lr
    return ICMP_ECHO_BAD_HANDLE;
   2030e:	f06f 0005 	mvn.w	r0, #5
   20312:	4770      	bx	lr
   20314:	f06f 0005 	mvn.w	r0, #5
}
   20318:	4770      	bx	lr
   2031a:	bf00      	nop
   2031c:	2000e58c 	.word	0x2000e58c

Disassembly of section .text._ARPAllocateTxPacket%840:

00020320 <_ARPAllocateTxPacket>:
{
   20320:	b508      	push	{r3, lr}
    pPkt = TCPIP_PKT_PacketAlloc(sizeof(TCPIP_MAC_PACKET), sizeof(ARP_PACKET), TCPIP_MAC_PKT_FLAG_ARP | TCPIP_MAC_PKT_FLAG_TX);
   20322:	f44f 7281 	mov.w	r2, #258	; 0x102
   20326:	211c      	movs	r1, #28
   20328:	2034      	movs	r0, #52	; 0x34
   2032a:	f7f8 fc93 	bl	18c54 <_TCPIP_PKT_PacketAlloc>
    if(pPkt)
   2032e:	4603      	mov	r3, r0
   20330:	b118      	cbz	r0, 2033a <_ARPAllocateTxPacket+0x1a>
    pPkt->ackFunc = ackFunc;
   20332:	4a03      	ldr	r2, [pc, #12]	; (20340 <_ARPAllocateTxPacket+0x20>)
   20334:	6082      	str	r2, [r0, #8]
    pPkt->ackParam = ackParam;
   20336:	2200      	movs	r2, #0
   20338:	60c2      	str	r2, [r0, #12]
}
   2033a:	4618      	mov	r0, r3
   2033c:	bd08      	pop	{r3, pc}
   2033e:	bf00      	nop
   20340:	00020d89 	.word	0x00020d89

Disassembly of section .text.TCPIP_ARP_HandlerDeRegister%841:

00020344 <TCPIP_ARP_HandlerDeRegister>:
{
   20344:	b508      	push	{r3, lr}
    if(hArp && arpMod.memH)
   20346:	b130      	cbz	r0, 20356 <TCPIP_ARP_HandlerDeRegister+0x12>
   20348:	4a05      	ldr	r2, [pc, #20]	; (20360 <TCPIP_ARP_HandlerDeRegister+0x1c>)
   2034a:	6892      	ldr	r2, [r2, #8]
   2034c:	b12a      	cbz	r2, 2035a <TCPIP_ARP_HandlerDeRegister+0x16>
        if(TCPIP_Notification_Remove((SGL_LIST_NODE*)hArp, &arpMod.registeredUsers, arpMod.memH))
   2034e:	4905      	ldr	r1, [pc, #20]	; (20364 <TCPIP_ARP_HandlerDeRegister+0x20>)
   20350:	f000 fb4e 	bl	209f0 <TCPIP_Notification_Remove>
}
   20354:	bd08      	pop	{r3, pc}
    return false;
   20356:	2000      	movs	r0, #0
   20358:	e7fc      	b.n	20354 <TCPIP_ARP_HandlerDeRegister+0x10>
   2035a:	2000      	movs	r0, #0
   2035c:	e7fa      	b.n	20354 <TCPIP_ARP_HandlerDeRegister+0x10>
   2035e:	bf00      	nop
   20360:	2000e1a4 	.word	0x2000e1a4
   20364:	2000e1c4 	.word	0x2000e1c4

Disassembly of section .rodata._tcpip_heap_object%842:

00020368 <_tcpip_heap_object>:
   20368:	0001d079 00016d67 00020dc1 0001394d     y...gm......M9..
   20378:	00021ec9 0001e325 00021949 00021ed5     ....%...I.......
   20388:	0002168d                                ....

Disassembly of section .text._DHCPOptionProcessSrvIdent%843:

0002038c <_DHCPOptionProcessSrvIdent>:
    if(pOptData->optSize >= sizeof(TCPIP_DHCP_OPTION_DATA_SERVER_ID))
   2038c:	684b      	ldr	r3, [r1, #4]
   2038e:	2b05      	cmp	r3, #5
   20390:	d908      	bls.n	203a4 <_DHCPOptionProcessSrvIdent+0x18>
        TCPIP_DHCP_OPTION_DATA_SERVER_ID* pServId = (TCPIP_DHCP_OPTION_DATA_SERVER_ID*)pOptData->pOpt;
   20392:	680b      	ldr	r3, [r1, #0]
        if(pServId->len == sizeof(pServId->serverId))
   20394:	785a      	ldrb	r2, [r3, #1]
   20396:	2a04      	cmp	r2, #4
   20398:	d107      	bne.n	203aa <_DHCPOptionProcessSrvIdent+0x1e>
            memcpy( pOptData->serverID.v, pServId->serverId, sizeof(pServId->serverId));
   2039a:	f8d3 3002 	ldr.w	r3, [r3, #2]
   2039e:	60cb      	str	r3, [r1, #12]
            return sizeof(TCPIP_DHCP_OPTION_DATA_SERVER_ID);
   203a0:	2006      	movs	r0, #6
   203a2:	4770      	bx	lr
    return -1;
   203a4:	f04f 30ff 	mov.w	r0, #4294967295
   203a8:	4770      	bx	lr
   203aa:	f04f 30ff 	mov.w	r0, #4294967295
}
   203ae:	4770      	bx	lr

Disassembly of section .text._DHCPOptionWriteMsgType%844:

000203b0 <_DHCPOptionWriteMsgType>:
    if(pSendData->writeSpace >= sizeof(*pDhcpOptType))
   203b0:	684b      	ldr	r3, [r1, #4]
   203b2:	2b02      	cmp	r3, #2
   203b4:	d90b      	bls.n	203ce <_DHCPOptionWriteMsgType+0x1e>
        pDhcpOptType = (TCPIP_DHCP_OPTION_DATA_MSG_TYPE*)pSendData->pOpt;
   203b6:	680a      	ldr	r2, [r1, #0]
        pDhcpOptType->opt = TCPIP_DHCP_MESSAGE_TYPE;
   203b8:	2335      	movs	r3, #53	; 0x35
   203ba:	7013      	strb	r3, [r2, #0]
        pDhcpOptType->len = sizeof(pDhcpOptType->type);
   203bc:	2301      	movs	r3, #1
   203be:	7053      	strb	r3, [r2, #1]
        pDhcpOptType->type = (pSendData->msgType == TCPIP_DHCP_REQUEST_RENEW_MESSAGE) ? TCPIP_DHCP_REQUEST_MESSAGE : (uint8_t)pSendData->msgType;
   203c0:	68cb      	ldr	r3, [r1, #12]
   203c2:	2b09      	cmp	r3, #9
   203c4:	bf08      	it	eq
   203c6:	2303      	moveq	r3, #3
   203c8:	7093      	strb	r3, [r2, #2]
        return sizeof(*pDhcpOptType);
   203ca:	2003      	movs	r0, #3
   203cc:	4770      	bx	lr
    return -1;
   203ce:	f04f 30ff 	mov.w	r0, #4294967295
}
   203d2:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_IPAddToNet%845:

000203d4 <TCPIP_STACK_IPAddToNet>:
{
   203d4:	b510      	push	{r4, lr}
   203d6:	460c      	mov	r4, r1
    if(pIpAddress && pIpAddress->Val != 0)
   203d8:	b128      	cbz	r0, 203e6 <TCPIP_STACK_IPAddToNet+0x12>
   203da:	6802      	ldr	r2, [r0, #0]
   203dc:	b11a      	cbz	r2, 203e6 <TCPIP_STACK_IPAddToNet+0x12>
        pNetIf = TCPIP_STACK_NetByAddress(pIpAddress);
   203de:	f7fc ff81 	bl	1d2e4 <TCPIP_STACK_NetByAddress>
    if(pNetIf == 0 && useDefault)
   203e2:	4603      	mov	r3, r0
   203e4:	b910      	cbnz	r0, 203ec <TCPIP_STACK_IPAddToNet+0x18>
   203e6:	b11c      	cbz	r4, 203f0 <TCPIP_STACK_IPAddToNet+0x1c>
        pNetIf = tcpipDefIf.defaultNet;
   203e8:	4b02      	ldr	r3, [pc, #8]	; (203f4 <TCPIP_STACK_IPAddToNet+0x20>)
   203ea:	681b      	ldr	r3, [r3, #0]
}
   203ec:	4618      	mov	r0, r3
   203ee:	bd10      	pop	{r4, pc}
   203f0:	2300      	movs	r3, #0
    return pNetIf;
   203f2:	e7fb      	b.n	203ec <TCPIP_STACK_IPAddToNet+0x18>
   203f4:	2000e644 	.word	0x2000e644

Disassembly of section .text._UDPFreeRxQueue%846:

000203f8 <_UDPFreeRxQueue>:
{
   203f8:	b570      	push	{r4, r5, r6, lr}
    while((pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(&pSkt->rxQueue)) != 0)
   203fa:	f100 0444 	add.w	r4, r0, #68	; 0x44
    TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
   203fe:	2609      	movs	r6, #9
   20400:	f06f 0510 	mvn.w	r5, #16
    while((pRxPkt = (TCPIP_MAC_PACKET*)TCPIP_Helper_SingleListHeadRemove(&pSkt->rxQueue)) != 0)
   20404:	4620      	mov	r0, r4
   20406:	f000 fcf7 	bl	20df8 <TCPIP_Helper_SingleListHeadRemove>
   2040a:	4603      	mov	r3, r0
   2040c:	b128      	cbz	r0, 2041a <_UDPFreeRxQueue+0x22>
    TCPIP_PKT_PacketAcknowledge(pRxPkt, ackRes);
   2040e:	4632      	mov	r2, r6
   20410:	4629      	mov	r1, r5
   20412:	4618      	mov	r0, r3
   20414:	f7fd fabe 	bl	1d994 <_TCPIP_PKT_PacketAcknowledge>
   20418:	e7f4      	b.n	20404 <_UDPFreeRxQueue+0xc>
}
   2041a:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .rodata._builtinCmdTbl%847:

0002041c <_builtinCmdTbl>:
   2041c:	d31c 0000 1575 0002 d324 0000 d334 0000     ....u...$...4...
   2042c:	e9c5 0001 d338 0000 d354 0000 1249 0001     ....8...T...I...
   2043c:	d35c 0000                                   \...

Disassembly of section .text.SYS_RESET_SoftwareReset%848:

00020440 <SYS_RESET_SoftwareReset>:
  __ASM volatile ("dsb 0xF":::"memory");
   20440:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   20444:	4905      	ldr	r1, [pc, #20]	; (2045c <SYS_RESET_SoftwareReset+0x1c>)
   20446:	68ca      	ldr	r2, [r1, #12]
   20448:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   2044c:	4b04      	ldr	r3, [pc, #16]	; (20460 <SYS_RESET_SoftwareReset+0x20>)
   2044e:	4313      	orrs	r3, r2
   20450:	60cb      	str	r3, [r1, #12]
   20452:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
   20456:	bf00      	nop
   20458:	e7fd      	b.n	20456 <SYS_RESET_SoftwareReset+0x16>
   2045a:	bf00      	nop
   2045c:	e000ed00 	.word	0xe000ed00
   20460:	05fa0004 	.word	0x05fa0004

Disassembly of section .text.SYS_RANDOM_CryptoGet%849:

00020464 <SYS_RANDOM_CryptoGet>:
{
   20464:	b500      	push	{lr}
   20466:	b083      	sub	sp, #12
    }sUint = {0};
   20468:	2300      	movs	r3, #0
   2046a:	9301      	str	r3, [sp, #4]
    CRYPT_RNG_CTX* pCtx = _SYS_RANDOM_CryptoContext();
   2046c:	f001 f88e 	bl	2158c <_SYS_RANDOM_CryptoContext>
    if(pCtx)
   20470:	b918      	cbnz	r0, 2047a <SYS_RANDOM_CryptoGet+0x16>
    return 0;
   20472:	2000      	movs	r0, #0
}
   20474:	b003      	add	sp, #12
   20476:	f85d fb04 	ldr.w	pc, [sp], #4
        CRYPT_RNG_BlockGenerate(pCtx, (unsigned char*)sUint.u8, sizeof(sUint.u8));
   2047a:	2204      	movs	r2, #4
   2047c:	eb0d 0102 	add.w	r1, sp, r2
   20480:	f000 ff1b 	bl	212ba <CRYPT_RNG_BlockGenerate>
        return sUint.u32;
   20484:	9801      	ldr	r0, [sp, #4]
   20486:	e7f5      	b.n	20474 <SYS_RANDOM_CryptoGet+0x10>

Disassembly of section .text.vPortSVCHandler%850:

00020490 <vPortSVCHandler>:
	__asm volatile (
   20490:	4b07      	ldr	r3, [pc, #28]	; (204b0 <pxCurrentTCBConst2>)
   20492:	6819      	ldr	r1, [r3, #0]
   20494:	6808      	ldr	r0, [r1, #0]
   20496:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2049a:	f380 8809 	msr	PSP, r0
   2049e:	f3bf 8f6f 	isb	sy
   204a2:	f04f 0000 	mov.w	r0, #0
   204a6:	f380 8811 	msr	BASEPRI, r0
   204aa:	4770      	bx	lr
   204ac:	f3af 8000 	nop.w

000204b0 <pxCurrentTCBConst2>:
   204b0:	2000e6a4 	.word	0x2000e6a4

Disassembly of section .text.uxListRemove%851:

000204b4 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
   204b4:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   204b6:	6841      	ldr	r1, [r0, #4]
   204b8:	6882      	ldr	r2, [r0, #8]
   204ba:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   204bc:	6841      	ldr	r1, [r0, #4]
   204be:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
   204c0:	685a      	ldr	r2, [r3, #4]
   204c2:	4282      	cmp	r2, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
   204c4:	bf04      	itt	eq
   204c6:	6882      	ldreq	r2, [r0, #8]
   204c8:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
   204ca:	2200      	movs	r2, #0
   204cc:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
   204ce:	681a      	ldr	r2, [r3, #0]
   204d0:	3a01      	subs	r2, #1
   204d2:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
   204d4:	6818      	ldr	r0, [r3, #0]
}
   204d6:	4770      	bx	lr

Disassembly of section .text.xQueueCreateMutex%852:

000204d8 <xQueueCreateMutex>:
	{
   204d8:	b510      	push	{r4, lr}
		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
   204da:	4602      	mov	r2, r0
   204dc:	2100      	movs	r1, #0
   204de:	2001      	movs	r0, #1
   204e0:	f7fe fed0 	bl	1f284 <xQueueGenericCreate>
		if( pxNewQueue != NULL )
   204e4:	4604      	mov	r4, r0
   204e6:	b138      	cbz	r0, 204f8 <xQueueCreateMutex+0x20>
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
   204e8:	2100      	movs	r1, #0
   204ea:	6081      	str	r1, [r0, #8]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
   204ec:	6001      	str	r1, [r0, #0]
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
   204ee:	60c1      	str	r1, [r0, #12]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
   204f0:	460b      	mov	r3, r1
   204f2:	460a      	mov	r2, r1
   204f4:	f7f2 fa78 	bl	129e8 <xQueueGenericSend>
	}
   204f8:	4620      	mov	r0, r4
   204fa:	bd10      	pop	{r4, pc}

Disassembly of section .text.gfx_mono_framebuffer_put_byte%853:

000204fc <gfx_mono_framebuffer_put_byte>:
    gfx_mono_framebuffer_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
        uint8_t data) {
    uint8_t *fBufferBegin = fbpointer;
   204fc:	4b07      	ldr	r3, [pc, #28]	; (2051c <gfx_mono_framebuffer_put_byte+0x20>)
   204fe:	681b      	ldr	r3, [r3, #0]
    uint8_t *fBufferEnd = fbpointer + GFX_MONO_LCD_FRAMEBUFFER_SIZE;
    uint8_t *fbpointerTemp = (fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
   20500:	eb01 11c0 	add.w	r1, r1, r0, lsl #7
    if ((fbpointerTemp >= fBufferBegin) && (fbpointerTemp <= fBufferEnd)) {
   20504:	1858      	adds	r0, r3, r1
   20506:	d208      	bcs.n	2051a <gfx_mono_framebuffer_put_byte+0x1e>
        uint8_t data) {
   20508:	b410      	push	{r4}
    uint8_t *fBufferEnd = fbpointer + GFX_MONO_LCD_FRAMEBUFFER_SIZE;
   2050a:	f503 7400 	add.w	r4, r3, #512	; 0x200
    if ((fbpointerTemp >= fBufferBegin) && (fbpointerTemp <= fBufferEnd)) {
   2050e:	42a0      	cmp	r0, r4
        *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
   20510:	bf98      	it	ls
   20512:	545a      	strbls	r2, [r3, r1]
    }
}
   20514:	f85d 4b04 	ldr.w	r4, [sp], #4
   20518:	4770      	bx	lr
   2051a:	4770      	bx	lr
   2051c:	2000e6e0 	.word	0x2000e6e0

Disassembly of section .text.fprintf%854:

00020520 <fiprintf>:
   20520:	b40e      	push	{r1, r2, r3}
   20522:	b503      	push	{r0, r1, lr}
   20524:	4601      	mov	r1, r0
   20526:	ab03      	add	r3, sp, #12
   20528:	4805      	ldr	r0, [pc, #20]	; (20540 <fiprintf+0x20>)
   2052a:	f853 2b04 	ldr.w	r2, [r3], #4
   2052e:	6800      	ldr	r0, [r0, #0]
   20530:	9301      	str	r3, [sp, #4]
   20532:	f7ee f9e9 	bl	e908 <_vfiprintf_r>
   20536:	b002      	add	sp, #8
   20538:	f85d eb04 	ldr.w	lr, [sp], #4
   2053c:	b003      	add	sp, #12
   2053e:	4770      	bx	lr
   20540:	2000e700 	.word	0x2000e700

Disassembly of section .text.strncmp%855:

00020544 <strncmp>:
   20544:	b510      	push	{r4, lr}
   20546:	b16a      	cbz	r2, 20564 <strncmp+0x20>
   20548:	3901      	subs	r1, #1
   2054a:	1884      	adds	r4, r0, r2
   2054c:	f810 3b01 	ldrb.w	r3, [r0], #1
   20550:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   20554:	4293      	cmp	r3, r2
   20556:	d103      	bne.n	20560 <strncmp+0x1c>
   20558:	42a0      	cmp	r0, r4
   2055a:	d001      	beq.n	20560 <strncmp+0x1c>
   2055c:	2b00      	cmp	r3, #0
   2055e:	d1f5      	bne.n	2054c <strncmp+0x8>
   20560:	1a98      	subs	r0, r3, r2
   20562:	bd10      	pop	{r4, pc}
   20564:	4610      	mov	r0, r2
   20566:	e7fc      	b.n	20562 <strncmp+0x1e>

Disassembly of section .text.__ascii_mbtowc%856:

00020568 <__ascii_mbtowc>:
   20568:	b082      	sub	sp, #8
   2056a:	b901      	cbnz	r1, 2056e <__ascii_mbtowc+0x6>
   2056c:	a901      	add	r1, sp, #4
   2056e:	b142      	cbz	r2, 20582 <__ascii_mbtowc+0x1a>
   20570:	b14b      	cbz	r3, 20586 <__ascii_mbtowc+0x1e>
   20572:	7813      	ldrb	r3, [r2, #0]
   20574:	600b      	str	r3, [r1, #0]
   20576:	7812      	ldrb	r2, [r2, #0]
   20578:	1c10      	adds	r0, r2, #0
   2057a:	bf18      	it	ne
   2057c:	2001      	movne	r0, #1
   2057e:	b002      	add	sp, #8
   20580:	4770      	bx	lr
   20582:	4610      	mov	r0, r2
   20584:	e7fb      	b.n	2057e <__ascii_mbtowc+0x16>
   20586:	f06f 0001 	mvn.w	r0, #1
   2058a:	e7f8      	b.n	2057e <__ascii_mbtowc+0x16>

Disassembly of section .text._kill_r%857:

0002058c <_kill_r>:
   2058c:	b538      	push	{r3, r4, r5, lr}
   2058e:	4c07      	ldr	r4, [pc, #28]	; (205ac <_kill_r+0x20>)
   20590:	2300      	movs	r3, #0
   20592:	4605      	mov	r5, r0
   20594:	4608      	mov	r0, r1
   20596:	4611      	mov	r1, r2
   20598:	6023      	str	r3, [r4, #0]
   2059a:	f001 fdeb 	bl	22174 <_kill>
   2059e:	1c43      	adds	r3, r0, #1
   205a0:	d102      	bne.n	205a8 <_kill_r+0x1c>
   205a2:	6823      	ldr	r3, [r4, #0]
   205a4:	b103      	cbz	r3, 205a8 <_kill_r+0x1c>
   205a6:	602b      	str	r3, [r5, #0]
   205a8:	bd38      	pop	{r3, r4, r5, pc}
   205aa:	bf00      	nop
   205ac:	20000000 	.word	0x20000000

Disassembly of section .text.__sseek%858:

000205b0 <__sseek>:
   205b0:	b510      	push	{r4, lr}
   205b2:	460c      	mov	r4, r1
   205b4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   205b8:	f000 f830 	bl	2061c <_lseek_r>
   205bc:	1c43      	adds	r3, r0, #1
   205be:	89a3      	ldrh	r3, [r4, #12]
   205c0:	bf15      	itete	ne
   205c2:	6560      	strne	r0, [r4, #84]	; 0x54
   205c4:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
   205c8:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
   205cc:	81a3      	strheq	r3, [r4, #12]
   205ce:	bf18      	it	ne
   205d0:	81a3      	strhne	r3, [r4, #12]
   205d2:	bd10      	pop	{r4, pc}

Disassembly of section .text._write_r%859:

000205d4 <_write_r>:
   205d4:	b538      	push	{r3, r4, r5, lr}
   205d6:	4c07      	ldr	r4, [pc, #28]	; (205f4 <_write_r+0x20>)
   205d8:	4605      	mov	r5, r0
   205da:	4608      	mov	r0, r1
   205dc:	4611      	mov	r1, r2
   205de:	2200      	movs	r2, #0
   205e0:	6022      	str	r2, [r4, #0]
   205e2:	461a      	mov	r2, r3
   205e4:	f001 fdcc 	bl	22180 <_write>
   205e8:	1c43      	adds	r3, r0, #1
   205ea:	d102      	bne.n	205f2 <_write_r+0x1e>
   205ec:	6823      	ldr	r3, [r4, #0]
   205ee:	b103      	cbz	r3, 205f2 <_write_r+0x1e>
   205f0:	602b      	str	r3, [r5, #0]
   205f2:	bd38      	pop	{r3, r4, r5, pc}
   205f4:	20000000 	.word	0x20000000

Disassembly of section .text._fstat_r%860:

000205f8 <_fstat_r>:
   205f8:	b538      	push	{r3, r4, r5, lr}
   205fa:	4c07      	ldr	r4, [pc, #28]	; (20618 <_fstat_r+0x20>)
   205fc:	2300      	movs	r3, #0
   205fe:	4605      	mov	r5, r0
   20600:	4608      	mov	r0, r1
   20602:	4611      	mov	r1, r2
   20604:	6023      	str	r3, [r4, #0]
   20606:	f001 fdaf 	bl	22168 <_fstat>
   2060a:	1c43      	adds	r3, r0, #1
   2060c:	d102      	bne.n	20614 <_fstat_r+0x1c>
   2060e:	6823      	ldr	r3, [r4, #0]
   20610:	b103      	cbz	r3, 20614 <_fstat_r+0x1c>
   20612:	602b      	str	r3, [r5, #0]
   20614:	bd38      	pop	{r3, r4, r5, pc}
   20616:	bf00      	nop
   20618:	20000000 	.word	0x20000000

Disassembly of section .text._lseek_r%861:

0002061c <_lseek_r>:
   2061c:	b538      	push	{r3, r4, r5, lr}
   2061e:	4c07      	ldr	r4, [pc, #28]	; (2063c <_lseek_r+0x20>)
   20620:	4605      	mov	r5, r0
   20622:	4608      	mov	r0, r1
   20624:	4611      	mov	r1, r2
   20626:	2200      	movs	r2, #0
   20628:	6022      	str	r2, [r4, #0]
   2062a:	461a      	mov	r2, r3
   2062c:	f001 fda4 	bl	22178 <_lseek>
   20630:	1c43      	adds	r3, r0, #1
   20632:	d102      	bne.n	2063a <_lseek_r+0x1e>
   20634:	6823      	ldr	r3, [r4, #0]
   20636:	b103      	cbz	r3, 2063a <_lseek_r+0x1e>
   20638:	602b      	str	r3, [r5, #0]
   2063a:	bd38      	pop	{r3, r4, r5, pc}
   2063c:	20000000 	.word	0x20000000

Disassembly of section .text._read_r%862:

00020640 <_read_r>:
   20640:	b538      	push	{r3, r4, r5, lr}
   20642:	4c07      	ldr	r4, [pc, #28]	; (20660 <_read_r+0x20>)
   20644:	4605      	mov	r5, r0
   20646:	4608      	mov	r0, r1
   20648:	4611      	mov	r1, r2
   2064a:	2200      	movs	r2, #0
   2064c:	6022      	str	r2, [r4, #0]
   2064e:	461a      	mov	r2, r3
   20650:	f001 fd94 	bl	2217c <_read>
   20654:	1c43      	adds	r3, r0, #1
   20656:	d102      	bne.n	2065e <_read_r+0x1e>
   20658:	6823      	ldr	r3, [r4, #0]
   2065a:	b103      	cbz	r3, 2065e <_read_r+0x1e>
   2065c:	602b      	str	r3, [r5, #0]
   2065e:	bd38      	pop	{r3, r4, r5, pc}
   20660:	20000000 	.word	0x20000000

Disassembly of section .text._DRV_PHY_SMITransfer_Wait%863:

00020664 <_DRV_PHY_SMITransfer_Wait>:
{
   20664:	b510      	push	{r4, lr}
   20666:	4604      	mov	r4, r0
    DRV_ETHPHY_SMI_TXFER_RES opRes = _DRV_PHY_SMITransferWaitComplete(hClientObj);
   20668:	f7fb faef 	bl	1bc4a <_DRV_PHY_SMITransferWaitComplete>
    if(opRes < 0)
   2066c:	2800      	cmp	r0, #0
   2066e:	db03      	blt.n	20678 <_DRV_PHY_SMITransfer_Wait+0x14>
    else if(opRes == DRV_ETHPHY_SMI_TXFER_RES_WAIT)
   20670:	3802      	subs	r0, #2
   20672:	bf18      	it	ne
   20674:	2001      	movne	r0, #1
}
   20676:	bd10      	pop	{r4, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   20678:	f06f 0108 	mvn.w	r1, #8
   2067c:	4620      	mov	r0, r4
   2067e:	f7ff faa1 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
        return false;
   20682:	2000      	movs	r0, #0
   20684:	e7f7      	b.n	20676 <_DRV_PHY_SMITransfer_Wait+0x12>

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListInitialize%864:

00020686 <TCPIP_Helper_ProtectedSingleListInitialize>:
{
   20686:	b510      	push	{r4, lr}
   20688:	4604      	mov	r4, r0
    pL->head = pL->tail = 0;
   2068a:	2100      	movs	r1, #0
   2068c:	6041      	str	r1, [r0, #4]
   2068e:	6001      	str	r1, [r0, #0]
    pL->nNodes = 0;
   20690:	6081      	str	r1, [r0, #8]
    pL->semValid = (OSAL_SEM_Create(&pL->semaphore, OSAL_SEM_TYPE_BINARY, 1, 1) == OSAL_RESULT_TRUE);
   20692:	2301      	movs	r3, #1
   20694:	461a      	mov	r2, r3
   20696:	300c      	adds	r0, #12
   20698:	f7fb fa54 	bl	1bb44 <OSAL_SEM_Create>
   2069c:	2801      	cmp	r0, #1
   2069e:	bf14      	ite	ne
   206a0:	2000      	movne	r0, #0
   206a2:	2001      	moveq	r0, #1
   206a4:	7420      	strb	r0, [r4, #16]
}
   206a6:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_STACK_NetAddressMacSet%865:

000206a8 <TCPIP_STACK_NetAddressMacSet>:
   206a8:	b168      	cbz	r0, 206c6 <TCPIP_STACK_NetAddressMacSet+0x1e>
   206aa:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   206ae:	f012 0f40 	tst.w	r2, #64	; 0x40
   206b2:	d101      	bne.n	206b8 <TCPIP_STACK_NetAddressMacSet+0x10>
    return false;
   206b4:	2000      	movs	r0, #0
}
   206b6:	4770      	bx	lr
        memcpy(pNetIf->netMACAddr.v, pAddr->v, sizeof(pNetIf->netMACAddr));
   206b8:	680a      	ldr	r2, [r1, #0]
   206ba:	63c2      	str	r2, [r0, #60]	; 0x3c
   206bc:	888a      	ldrh	r2, [r1, #4]
   206be:	f8a0 2040 	strh.w	r2, [r0, #64]	; 0x40
        return true;
   206c2:	2001      	movs	r0, #1
   206c4:	4770      	bx	lr
    return false;
   206c6:	2000      	movs	r0, #0
   206c8:	4770      	bx	lr

Disassembly of section .text.TCPIP_UDP_Discard%866:

000206ca <TCPIP_UDP_Discard>:
{
   206ca:	b510      	push	{r4, lr}
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   206cc:	f7ff fc0a 	bl	1fee4 <_UDPSocketDcpt>
    if(pSkt)
   206d0:	b150      	cbz	r0, 206e8 <TCPIP_UDP_Discard+0x1e>
   206d2:	4603      	mov	r3, r0
        if(pSkt->pCurrRxSeg)
   206d4:	6b02      	ldr	r2, [r0, #48]	; 0x30
   206d6:	b12a      	cbz	r2, 206e4 <TCPIP_UDP_Discard+0x1a>
            nBytes = pSkt->rxTotLen;
   206d8:	8ec4      	ldrh	r4, [r0, #54]	; 0x36
        _UDPUpdatePacketLock(pSkt);
   206da:	4618      	mov	r0, r3
   206dc:	f7ff fc16 	bl	1ff0c <_UDPUpdatePacketLock>
}
   206e0:	4620      	mov	r0, r4
   206e2:	bd10      	pop	{r4, pc}
    uint16_t nBytes = 0;
   206e4:	2400      	movs	r4, #0
   206e6:	e7f8      	b.n	206da <TCPIP_UDP_Discard+0x10>
   206e8:	2400      	movs	r4, #0
   206ea:	e7f9      	b.n	206e0 <TCPIP_UDP_Discard+0x16>

Disassembly of section .rodata%867:

000206ec <.rodata%867>:
   206ec:	33323130 	.word	0x33323130
   206f0:	37363534 	.word	0x37363534
   206f4:	42413938 	.word	0x42413938
   206f8:	46454443 	.word	0x46454443
   206fc:	32313000 	.word	0x32313000
   20700:	36353433 	.word	0x36353433
   20704:	61393837 	.word	0x61393837
   20708:	65646362 	.word	0x65646362
   2070c:	Address 0x0002070c is out of bounds.


Disassembly of section .text.__sread%868:

0002070e <__sread>:
   2070e:	b510      	push	{r4, lr}
   20710:	460c      	mov	r4, r1
   20712:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   20716:	f7ff ff93 	bl	20640 <_read_r>
   2071a:	2800      	cmp	r0, #0
   2071c:	bfab      	itete	ge
   2071e:	6d63      	ldrge	r3, [r4, #84]	; 0x54
   20720:	89a3      	ldrhlt	r3, [r4, #12]
   20722:	181b      	addge	r3, r3, r0
   20724:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
   20728:	bfac      	ite	ge
   2072a:	6563      	strge	r3, [r4, #84]	; 0x54
   2072c:	81a3      	strhlt	r3, [r4, #12]
   2072e:	bd10      	pop	{r4, pc}

Disassembly of section .text.DRV_ETHPHY_Status%869:

00020730 <DRV_ETHPHY_Status>:
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   20730:	4b06      	ldr	r3, [pc, #24]	; (2074c <DRV_ETHPHY_Status+0x1c>)
   20732:	4283      	cmp	r3, r0
   20734:	d103      	bne.n	2073e <DRV_ETHPHY_Status+0xe>
    if(phyInst != 0)
   20736:	b128      	cbz	r0, 20744 <DRV_ETHPHY_Status+0x14>
        return( phyInst->status ) ;
   20738:	f993 0004 	ldrsb.w	r0, [r3, #4]
   2073c:	4770      	bx	lr
    return SYS_STATUS_ERROR;
   2073e:	f04f 30ff 	mov.w	r0, #4294967295
   20742:	4770      	bx	lr
   20744:	f04f 30ff 	mov.w	r0, #4294967295
} 
   20748:	4770      	bx	lr
   2074a:	bf00      	nop
   2074c:	2000e018 	.word	0x2000e018

Disassembly of section .text.DRV_ETHPHY_ClientStatus%870:

00020750 <DRV_ETHPHY_ClientStatus>:
    if( hClientObj != 0)
   20750:	b130      	cbz	r0, 20760 <DRV_ETHPHY_ClientStatus+0x10>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   20752:	68c1      	ldr	r1, [r0, #12]
   20754:	4a05      	ldr	r2, [pc, #20]	; (2076c <DRV_ETHPHY_ClientStatus+0x1c>)
   20756:	4291      	cmp	r1, r2
   20758:	d105      	bne.n	20766 <DRV_ETHPHY_ClientStatus+0x16>
            return( hClientObj->status );
   2075a:	f990 0008 	ldrsb.w	r0, [r0, #8]
   2075e:	4770      	bx	lr
    return DRV_ETHPHY_CLIENT_STATUS_ERROR;
   20760:	f04f 30ff 	mov.w	r0, #4294967295
   20764:	4770      	bx	lr
   20766:	f04f 30ff 	mov.w	r0, #4294967295
}
   2076a:	4770      	bx	lr
   2076c:	2000e018 	.word	0x2000e018

Disassembly of section .text.DRV_ETHPHY_ClientOperationResult%871:

00020770 <DRV_ETHPHY_ClientOperationResult>:
    if( hClientObj != 0)
   20770:	b130      	cbz	r0, 20780 <DRV_ETHPHY_ClientOperationResult+0x10>
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   20772:	68c1      	ldr	r1, [r0, #12]
   20774:	4a05      	ldr	r2, [pc, #20]	; (2078c <DRV_ETHPHY_ClientOperationResult+0x1c>)
   20776:	4291      	cmp	r1, r2
   20778:	d105      	bne.n	20786 <DRV_ETHPHY_ClientOperationResult+0x16>
            return( hClientObj->operRes );
   2077a:	f990 002c 	ldrsb.w	r0, [r0, #44]	; 0x2c
   2077e:	4770      	bx	lr
    return DRV_ETHPHY_RES_HANDLE_ERR;
   20780:	f06f 000a 	mvn.w	r0, #10
   20784:	4770      	bx	lr
   20786:	f06f 000a 	mvn.w	r0, #10
}
   2078a:	4770      	bx	lr
   2078c:	2000e018 	.word	0x2000e018

Disassembly of section .text._DRV_ETHPHY_ClientOpReset%872:

00020790 <_DRV_ETHPHY_ClientOpReset>:
{
   20790:	b508      	push	{r3, lr}
    if((unsigned int)hClientObj->operPhase < sizeof(_DRV_PHY_ResetPhasesTbl)/sizeof(*_DRV_PHY_ResetPhasesTbl))
   20792:	8bc3      	ldrh	r3, [r0, #30]
   20794:	2b02      	cmp	r3, #2
   20796:	d804      	bhi.n	207a2 <_DRV_ETHPHY_ClientOpReset+0x12>
        (*_DRV_PHY_ResetPhasesTbl[hClientObj->operPhase])(hClientObj);
   20798:	4a04      	ldr	r2, [pc, #16]	; (207ac <_DRV_ETHPHY_ClientOpReset+0x1c>)
   2079a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   2079e:	4798      	blx	r3
}
   207a0:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   207a2:	f06f 0108 	mvn.w	r1, #8
   207a6:	f7ff fa0d 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
}
   207aa:	e7f9      	b.n	207a0 <_DRV_ETHPHY_ClientOpReset+0x10>
   207ac:	00021c58 	.word	0x00021c58

Disassembly of section .text._DRV_ETHPHY_ClientOpNegRestart%873:

000207b0 <_DRV_ETHPHY_ClientOpNegRestart>:
{
   207b0:	b508      	push	{r3, lr}
    if((unsigned int)hClientObj->operPhase < sizeof(_DRV_PHY_NegRestartPhasesTbl)/sizeof(*_DRV_PHY_NegRestartPhasesTbl))
   207b2:	8bc3      	ldrh	r3, [r0, #30]
   207b4:	2b02      	cmp	r3, #2
   207b6:	d804      	bhi.n	207c2 <_DRV_ETHPHY_ClientOpNegRestart+0x12>
        (*_DRV_PHY_NegRestartPhasesTbl[hClientObj->operPhase])(hClientObj);
   207b8:	4a04      	ldr	r2, [pc, #16]	; (207cc <_DRV_ETHPHY_ClientOpNegRestart+0x1c>)
   207ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   207be:	4798      	blx	r3
}
   207c0:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   207c2:	f06f 0108 	mvn.w	r1, #8
   207c6:	f7ff f9fd 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
}
   207ca:	e7f9      	b.n	207c0 <_DRV_ETHPHY_ClientOpNegRestart+0x10>
   207cc:	00021c4c 	.word	0x00021c4c

Disassembly of section .text._DRV_ETHPHY_ClientOpNegResult%874:

000207d0 <_DRV_ETHPHY_ClientOpNegResult>:
{
   207d0:	b508      	push	{r3, lr}
    if((unsigned int)hClientObj->operPhase < sizeof(_DRV_PHY_NegResultPhasesTbl)/sizeof(*_DRV_PHY_NegResultPhasesTbl))
   207d2:	8bc3      	ldrh	r3, [r0, #30]
   207d4:	2b04      	cmp	r3, #4
   207d6:	d804      	bhi.n	207e2 <_DRV_ETHPHY_ClientOpNegResult+0x12>
        (*_DRV_PHY_NegResultPhasesTbl[hClientObj->operPhase])(hClientObj);
   207d8:	4a04      	ldr	r2, [pc, #16]	; (207ec <_DRV_ETHPHY_ClientOpNegResult+0x1c>)
   207da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   207de:	4798      	blx	r3
}
   207e0:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   207e2:	f06f 0108 	mvn.w	r1, #8
   207e6:	f7ff f9ed 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
}
   207ea:	e7f9      	b.n	207e0 <_DRV_ETHPHY_ClientOpNegResult+0x10>
   207ec:	00021780 	.word	0x00021780

Disassembly of section .text._DRV_ETHPHY_ClientOpNegComplete%875:

000207f0 <_DRV_ETHPHY_ClientOpNegComplete>:
{
   207f0:	b508      	push	{r3, lr}
    if((unsigned int)hClientObj->operPhase < sizeof(_DRV_PHY_NegCompletePhasesTbl)/sizeof(*_DRV_PHY_NegCompletePhasesTbl))
   207f2:	8bc3      	ldrh	r3, [r0, #30]
   207f4:	2b05      	cmp	r3, #5
   207f6:	d804      	bhi.n	20802 <_DRV_ETHPHY_ClientOpNegComplete+0x12>
        (*_DRV_PHY_NegCompletePhasesTbl[hClientObj->operPhase])(hClientObj);
   207f8:	4a04      	ldr	r2, [pc, #16]	; (2080c <_DRV_ETHPHY_ClientOpNegComplete+0x1c>)
   207fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   207fe:	4798      	blx	r3
}
   20800:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   20802:	f06f 0108 	mvn.w	r1, #8
   20806:	f7ff f9dd 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
}
   2080a:	e7f9      	b.n	20800 <_DRV_ETHPHY_ClientOpNegComplete+0x10>
   2080c:	0002137c 	.word	0x0002137c

Disassembly of section .text._DRV_ETHPHY_ClientOpLinkStat%876:

00020810 <_DRV_ETHPHY_ClientOpLinkStat>:
{
   20810:	b508      	push	{r3, lr}
    if((unsigned int)hClientObj->operPhase < sizeof(_DRV_PHY_LinkStatPhasesTbl)/sizeof(*_DRV_PHY_LinkStatPhasesTbl))
   20812:	8bc3      	ldrh	r3, [r0, #30]
   20814:	2b02      	cmp	r3, #2
   20816:	d804      	bhi.n	20822 <_DRV_ETHPHY_ClientOpLinkStat+0x12>
        (*_DRV_PHY_LinkStatPhasesTbl[hClientObj->operPhase])(hClientObj);
   20818:	4a04      	ldr	r2, [pc, #16]	; (2082c <_DRV_ETHPHY_ClientOpLinkStat+0x1c>)
   2081a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   2081e:	4798      	blx	r3
}
   20820:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   20822:	f06f 0108 	mvn.w	r1, #8
   20826:	f7ff f9cd 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
}
   2082a:	e7f9      	b.n	20820 <_DRV_ETHPHY_ClientOpLinkStat+0x10>
   2082c:	0001afe4 	.word	0x0001afe4

Disassembly of section .text._DRV_ETHPHY_ClientOpSetup%877:

00020830 <_DRV_ETHPHY_ClientOpSetup>:
{
   20830:	b508      	push	{r3, lr}
    if((unsigned int)hClientObj->operPhase >= sizeof(_DRV_PHY_SetupPhasesTbl)/sizeof(*_DRV_PHY_SetupPhasesTbl))
   20832:	8bc3      	ldrh	r3, [r0, #30]
   20834:	2b03      	cmp	r3, #3
   20836:	d804      	bhi.n	20842 <_DRV_ETHPHY_ClientOpSetup+0x12>
        (*_DRV_PHY_SetupPhasesTbl[hClientObj->operPhase])(hClientObj);
   20838:	4a04      	ldr	r2, [pc, #16]	; (2084c <_DRV_ETHPHY_ClientOpSetup+0x1c>)
   2083a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   2083e:	4798      	blx	r3
}
   20840:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   20842:	f06f 0108 	mvn.w	r1, #8
   20846:	f7ff f9bd 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
   2084a:	e7f9      	b.n	20840 <_DRV_ETHPHY_ClientOpSetup+0x10>
   2084c:	00021a1c 	.word	0x00021a1c

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate%878:

00020850 <_DRV_ETHPHY_SetupPhaseNegotiate>:
{
   20850:	b508      	push	{r3, lr}
    if(hClientObj->operSubPhase <  sizeof(_DRV_PHY_SetupPhaseNegotiateSubPhaseTbl) / sizeof(*_DRV_PHY_SetupPhaseNegotiateSubPhaseTbl))
   20852:	8c03      	ldrh	r3, [r0, #32]
   20854:	2b07      	cmp	r3, #7
   20856:	d804      	bhi.n	20862 <_DRV_ETHPHY_SetupPhaseNegotiate+0x12>
        (*_DRV_PHY_SetupPhaseNegotiateSubPhaseTbl[hClientObj->operSubPhase])(hClientObj);
   20858:	4a04      	ldr	r2, [pc, #16]	; (2086c <_DRV_ETHPHY_SetupPhaseNegotiate+0x1c>)
   2085a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   2085e:	4798      	blx	r3
}
   20860:	bd08      	pop	{r3, pc}
        _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OPERATION_ERR);
   20862:	f06f 0108 	mvn.w	r1, #8
   20866:	f7ff f9ad 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
}
   2086a:	e7f9      	b.n	20860 <_DRV_ETHPHY_SetupPhaseNegotiate+0x10>
   2086c:	00020890 	.word	0x00020890

Disassembly of section .rodata%879:

00020870 <.rodata%879>:
   20870:	5f565244 	.word	0x5f565244
   20874:	20594850 	.word	0x20594850
   20878:	7265706f 	.word	0x7265706f
   2087c:	6f697461 	.word	0x6f697461
   20880:	7265206e 	.word	0x7265206e
   20884:	3a726f72 	.word	0x3a726f72
   20888:	0d642520 	.word	0x0d642520
   2088c:	000a      	.short	0x000a
   2088e:	bf00      	nop

Disassembly of section .rodata._DRV_PHY_SetupPhaseNegotiateSubPhaseTbl%880:

00020890 <_DRV_PHY_SetupPhaseNegotiateSubPhaseTbl>:
   20890:	73f9 0001 e23d 0001 e7bd 0001 ee65 0001     .s..=.......e...
   208a0:	97c7 0001 1305 0002 e40d 0001 c4fd 0001     ................

Disassembly of section .text.DRV_GMAC_Close%881:

000208b0 <DRV_GMAC_Close>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   208b0:	4b06      	ldr	r3, [pc, #24]	; (208cc <DRV_GMAC_Close+0x1c>)
   208b2:	4283      	cmp	r3, r0
   208b4:	d109      	bne.n	208ca <DRV_GMAC_Close+0x1a>
    if(pMACDrv != 0)
   208b6:	b140      	cbz	r0, 208ca <DRV_GMAC_Close+0x1a>
        if(pMACDrv->sGmacData._macFlags._init == 1)	
   208b8:	7d9b      	ldrb	r3, [r3, #22]
   208ba:	f013 0f01 	tst.w	r3, #1
   208be:	d004      	beq.n	208ca <DRV_GMAC_Close+0x1a>
            pMACDrv->sGmacData._macFlags._open = 0;
   208c0:	4b02      	ldr	r3, [pc, #8]	; (208cc <DRV_GMAC_Close+0x1c>)
   208c2:	7d9a      	ldrb	r2, [r3, #22]
   208c4:	f36f 0241 	bfc	r2, #1, #1
   208c8:	759a      	strb	r2, [r3, #22]
}
   208ca:	4770      	bx	lr
   208cc:	2000dab8 	.word	0x2000dab8

Disassembly of section .text.DRV_GMAC_Deinitialize%882:

000208d0 <DRV_GMAC_Deinitialize>:
{
   208d0:	b508      	push	{r3, lr}
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   208d2:	4b06      	ldr	r3, [pc, #24]	; (208ec <DRV_GMAC_Deinitialize+0x1c>)
   208d4:	4283      	cmp	r3, r0
   208d6:	d104      	bne.n	208e2 <DRV_GMAC_Deinitialize+0x12>
    if(pMACDrv != 0)
   208d8:	b118      	cbz	r0, 208e2 <DRV_GMAC_Deinitialize+0x12>
        if(pMACDrv->sGmacData._macFlags._init != 0)
   208da:	7d9b      	ldrb	r3, [r3, #22]
   208dc:	f013 0f01 	tst.w	r3, #1
   208e0:	d100      	bne.n	208e4 <DRV_GMAC_Deinitialize+0x14>
}
   208e2:	bd08      	pop	{r3, pc}
            _MACDeinit(pMACDrv);
   208e4:	4801      	ldr	r0, [pc, #4]	; (208ec <DRV_GMAC_Deinitialize+0x1c>)
   208e6:	f7f1 f9f5 	bl	11cd4 <_MACDeinit>
}
   208ea:	e7fa      	b.n	208e2 <DRV_GMAC_Deinitialize+0x12>
   208ec:	2000dab8 	.word	0x2000dab8

Disassembly of section .text.DRV_PIC32CGMAC_LibTransferEnable%883:

000208f0 <DRV_PIC32CGMAC_LibTransferEnable>:
	GMAC_REGS->GMAC_NCR |= GMAC_NCR_TXEN_Msk;
   208f0:	4b06      	ldr	r3, [pc, #24]	; (2090c <DRV_PIC32CGMAC_LibTransferEnable+0x1c>)
   208f2:	681a      	ldr	r2, [r3, #0]
   208f4:	f042 0208 	orr.w	r2, r2, #8
   208f8:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_NCR |= GMAC_NCR_RXEN_Msk;	
   208fa:	681a      	ldr	r2, [r3, #0]
   208fc:	f042 0204 	orr.w	r2, r2, #4
   20900:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_NCR |= GMAC_NCR_WESTAT_Msk;
   20902:	681a      	ldr	r2, [r3, #0]
   20904:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   20908:	601a      	str	r2, [r3, #0]
}
   2090a:	4770      	bx	lr
   2090c:	42000800 	.word	0x42000800

Disassembly of section .text.DRV_GMAC_LibDescriptorsPoolAdd%884:

00020910 <DRV_GMAC_LibDescriptorsPoolAdd>:
    if(dType == DRV_GMAC_DCPT_TYPE_TX)
   20910:	2902      	cmp	r1, #2
   20912:	d005      	beq.n	20920 <DRV_GMAC_LibDescriptorsPoolAdd+0x10>
    else if(dType == DRV_GMAC_DCPT_TYPE_RX)
   20914:	2901      	cmp	r1, #1
        pMACDrv->sGmacData.gmac_queue[0].pRxDesc = gmac_dcpt_array.sRxDesc_queue0;
   20916:	bf04      	itt	eq
   20918:	4b03      	ldreq	r3, [pc, #12]	; (20928 <DRV_GMAC_LibDescriptorsPoolAdd+0x18>)
   2091a:	f8c0 3090 	streq.w	r3, [r0, #144]	; 0x90
}
   2091e:	4770      	bx	lr
        pMACDrv->sGmacData.gmac_queue[0].pTxDesc = gmac_dcpt_array.sTxDesc_queue0;
   20920:	4b02      	ldr	r3, [pc, #8]	; (2092c <DRV_GMAC_LibDescriptorsPoolAdd+0x1c>)
   20922:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
   20926:	4770      	bx	lr
   20928:	2000df58 	.word	0x2000df58
   2092c:	2000df18 	.word	0x2000df18

Disassembly of section .text._SwapARPPacket%885:

00020930 <_SwapARPPacket>:
    p->HardwareType     = TCPIP_Helper_htons(p->HardwareType);
   20930:	8802      	ldrh	r2, [r0, #0]
   20932:	0a13      	lsrs	r3, r2, #8
   20934:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   20938:	8003      	strh	r3, [r0, #0]
    p->Protocol         = TCPIP_Helper_htons(p->Protocol);
   2093a:	8842      	ldrh	r2, [r0, #2]
   2093c:	0a13      	lsrs	r3, r2, #8
   2093e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   20942:	8043      	strh	r3, [r0, #2]
    p->Operation        = TCPIP_Helper_htons(p->Operation);
   20944:	88c2      	ldrh	r2, [r0, #6]
   20946:	0a13      	lsrs	r3, r2, #8
   20948:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   2094c:	80c3      	strh	r3, [r0, #6]
}
   2094e:	4770      	bx	lr

Disassembly of section .text.TCPIP_DNS_OAHASH_KeyHash%886:

00020950 <TCPIP_DNS_OAHASH_KeyHash>:
{
   20950:	b538      	push	{r3, r4, r5, lr}
   20952:	4605      	mov	r5, r0
   20954:	460c      	mov	r4, r1
    hostnameLen = strlen((const char*)dnsHostNameKey);
   20956:	4608      	mov	r0, r1
   20958:	f001 f920 	bl	21b9c <strlen>
    return fnv_32_hash(dnsHostNameKey, hostnameLen) % (pOH->hEntries);
   2095c:	4601      	mov	r1, r0
   2095e:	4620      	mov	r0, r4
   20960:	f7fe fb58 	bl	1f014 <fnv_32_hash>
   20964:	68eb      	ldr	r3, [r5, #12]
   20966:	fbb0 f2f3 	udiv	r2, r0, r3
}
   2096a:	fb02 0013 	mls	r0, r2, r3, r0
   2096e:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListLock%887:

00020970 <TCPIP_Helper_ProtectedSingleListLock>:

bool TCPIP_Helper_ProtectedSingleListLock(PROTECTED_SINGLE_LIST* pL)
{
   20970:	b508      	push	{r3, lr}
   20972:	4603      	mov	r3, r0
    if(pL->semValid)
   20974:	7c00      	ldrb	r0, [r0, #16]
   20976:	b900      	cbnz	r0, 2097a <TCPIP_Helper_ProtectedSingleListLock+0xa>
    {
        return (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE);
    }

    return false;
}
   20978:	bd08      	pop	{r3, pc}
        return (OSAL_SEM_Pend(&pL->semaphore, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE);
   2097a:	f64f 71ff 	movw	r1, #65535	; 0xffff
   2097e:	f103 000c 	add.w	r0, r3, #12
   20982:	f000 f97f 	bl	20c84 <OSAL_SEM_Pend>
   20986:	2801      	cmp	r0, #1
   20988:	bf14      	ite	ne
   2098a:	2000      	movne	r0, #0
   2098c:	2001      	moveq	r0, #1
   2098e:	e7f3      	b.n	20978 <TCPIP_Helper_ProtectedSingleListLock+0x8>

Disassembly of section .rodata.TCPIP_MAC_POWER_TBL%888:

00020990 <TCPIP_MAC_POWER_TBL>:
	...
   20998:	0001 0000 d940 0001 0002 0000 d948 0001     ....@.......H...
   209a8:	0003 0000 d94c 0001                         ....L...

Disassembly of section .text.TCPIP_STACK_NetDefaultSet%889:

000209b0 <TCPIP_STACK_NetDefaultSet>:
   209b0:	b150      	cbz	r0, 209c8 <TCPIP_STACK_NetDefaultSet+0x18>
   209b2:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   209b6:	f012 0f40 	tst.w	r2, #64	; 0x40
   209ba:	d101      	bne.n	209c0 <TCPIP_STACK_NetDefaultSet+0x10>
    return false;
   209bc:	2000      	movs	r0, #0
}
   209be:	4770      	bx	lr
        tcpipDefIf.defaultNet = pNewIf;
   209c0:	4a02      	ldr	r2, [pc, #8]	; (209cc <TCPIP_STACK_NetDefaultSet+0x1c>)
   209c2:	6010      	str	r0, [r2, #0]
        return true;
   209c4:	2001      	movs	r0, #1
   209c6:	4770      	bx	lr
    return false;
   209c8:	2000      	movs	r0, #0
   209ca:	4770      	bx	lr
   209cc:	2000e644 	.word	0x2000e644

Disassembly of section .text._TCPIPStackHandleToNetLinked%890:

000209d0 <_TCPIPStackHandleToNetLinked>:
   209d0:	b128      	cbz	r0, 209de <_TCPIPStackHandleToNetLinked+0xe>
   209d2:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   209d6:	f012 0f40 	tst.w	r2, #64	; 0x40
   209da:	d101      	bne.n	209e0 <_TCPIPStackHandleToNetLinked+0x10>
    return 0;
   209dc:	2000      	movs	r0, #0
}
   209de:	4770      	bx	lr
    if(pNetIf != 0 && pNetIf->exFlags.linkPrev != 0)
   209e0:	f890 2060 	ldrb.w	r2, [r0, #96]	; 0x60
   209e4:	f002 0201 	and.w	r2, r2, #1
        return pNetIf;
   209e8:	2a00      	cmp	r2, #0
   209ea:	bf08      	it	eq
   209ec:	2000      	moveq	r0, #0
   209ee:	4770      	bx	lr

Disassembly of section .text.TCPIP_Notification_Remove%891:

000209f0 <TCPIP_Notification_Remove>:
{
   209f0:	b538      	push	{r3, r4, r5, lr}
   209f2:	4604      	mov	r4, r0
   209f4:	4608      	mov	r0, r1
   209f6:	4615      	mov	r5, r2
    if(TCPIP_Helper_ProtectedSingleListNodeRemove(notifyList, node))
   209f8:	4621      	mov	r1, r4
   209fa:	f7fe fb6b 	bl	1f0d4 <TCPIP_Helper_ProtectedSingleListNodeRemove>
   209fe:	b128      	cbz	r0, 20a0c <TCPIP_Notification_Remove+0x1c>
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   20a00:	68eb      	ldr	r3, [r5, #12]
   20a02:	4621      	mov	r1, r4
   20a04:	4628      	mov	r0, r5
   20a06:	4798      	blx	r3
        return true;
   20a08:	2001      	movs	r0, #1
}
   20a0a:	bd38      	pop	{r3, r4, r5, pc}
    return false;
   20a0c:	2000      	movs	r0, #0
   20a0e:	e7fc      	b.n	20a0a <TCPIP_Notification_Remove+0x1a>

Disassembly of section .rodata%892:

00020a10 <.rodata%892>:
   20a10:	6b636150 	.word	0x6b636150
   20a14:	41207465 	.word	0x41207465
   20a18:	203a6b63 	.word	0x203a6b63
   20a1c:	6870726f 	.word	0x6870726f
   20a20:	70206e61 	.word	0x70206e61
   20a24:	656b6361 	.word	0x656b6361
   20a28:	0d202174 	.word	0x0d202174
   20a2c:	000a      	.short	0x000a
   20a2e:	bf00      	nop

Disassembly of section .text.TCPIP_UDP_DestinationPortSet%893:

00020a30 <TCPIP_UDP_DestinationPortSet>:
{
   20a30:	b510      	push	{r4, lr}
   20a32:	460c      	mov	r4, r1
    UDP_SOCKET_DCPT *pSkt = _UDPSocketDcpt(s);
   20a34:	f7ff fa56 	bl	1fee4 <_UDPSocketDcpt>
    if(pSkt != 0)
   20a38:	b140      	cbz	r0, 20a4c <TCPIP_UDP_DestinationPortSet+0x1c>
        pSkt->remotePort = remotePort;
   20a3a:	8504      	strh	r4, [r0, #40]	; 0x28
    pSkt->extFlags.rxEnable = 1;
   20a3c:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20a40:	f042 0202 	orr.w	r2, r2, #2
   20a44:	f880 2042 	strb.w	r2, [r0, #66]	; 0x42
        return true;
   20a48:	2001      	movs	r0, #1
}
   20a4a:	bd10      	pop	{r4, pc}
    return false;
   20a4c:	2000      	movs	r0, #0
   20a4e:	e7fc      	b.n	20a4a <TCPIP_UDP_DestinationPortSet+0x1a>

Disassembly of section .text._keyRightProcess%894:

00020a50 <_keyRightProcess>:
    if(pCmdIO->cmdPnt < pCmdIO->cmdEnd)
   20a50:	6982      	ldr	r2, [r0, #24]
   20a52:	69c3      	ldr	r3, [r0, #28]
   20a54:	429a      	cmp	r2, r3
   20a56:	d20a      	bcs.n	20a6e <_keyRightProcess+0x1e>
{   // right arrow
   20a58:	b510      	push	{r4, lr}
   20a5a:	4604      	mov	r4, r0
        (*pCmdApi->msg)(cmdIoParam, pSeqDcpt->keyCode);
   20a5c:	6803      	ldr	r3, [r0, #0]
   20a5e:	681b      	ldr	r3, [r3, #0]
   20a60:	6809      	ldr	r1, [r1, #0]
   20a62:	6840      	ldr	r0, [r0, #4]
   20a64:	4798      	blx	r3
        pCmdIO->cmdPnt++;
   20a66:	69a3      	ldr	r3, [r4, #24]
   20a68:	3301      	adds	r3, #1
   20a6a:	61a3      	str	r3, [r4, #24]
}
   20a6c:	bd10      	pop	{r4, pc}
   20a6e:	4770      	bx	lr

Disassembly of section .text.GetCommandCharacter%895:

00020a70 <GetCommandCharacter>:
{
   20a70:	b500      	push	{lr}
   20a72:	b083      	sub	sp, #12
    SYS_CONSOLE_Read(_cmdInitData.consoleIndex, &new_c, 1);
   20a74:	2201      	movs	r2, #1
   20a76:	f10d 0107 	add.w	r1, sp, #7
   20a7a:	4b04      	ldr	r3, [pc, #16]	; (20a8c <GetCommandCharacter+0x1c>)
   20a7c:	8858      	ldrh	r0, [r3, #2]
   20a7e:	f7fe f823 	bl	1eac8 <SYS_CONSOLE_Read>
}
   20a82:	f89d 0007 	ldrb.w	r0, [sp, #7]
   20a86:	b003      	add	sp, #12
   20a88:	f85d fb04 	ldr.w	pc, [sp], #4
   20a8c:	2000e674 	.word	0x2000e674

Disassembly of section .text.SYS_INT_SourceRestore%896:

00020a90 <SYS_INT_SourceRestore>:

void SYS_INT_SourceRestore( INT_SOURCE source, bool status )
{
    if( status ) {
   20a90:	b151      	cbz	r1, 20aa8 <SYS_INT_SourceRestore+0x18>
  if ((int32_t)(IRQn) >= 0)
   20a92:	2800      	cmp	r0, #0
   20a94:	db08      	blt.n	20aa8 <SYS_INT_SourceRestore+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   20a96:	0942      	lsrs	r2, r0, #5
   20a98:	f000 001f 	and.w	r0, r0, #31
   20a9c:	2301      	movs	r3, #1
   20a9e:	fa03 f000 	lsl.w	r0, r3, r0
   20aa2:	4b02      	ldr	r3, [pc, #8]	; (20aac <SYS_INT_SourceRestore+0x1c>)
   20aa4:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
        SYS_INT_SourceEnable( source );
    }
    return;
}
   20aa8:	4770      	bx	lr
   20aaa:	bf00      	nop
   20aac:	e000e100 	.word	0xe000e100

Disassembly of section .text.SYS_RANDOM_CryptoInitialize%897:

00020ab0 <SYS_RANDOM_CryptoInitialize>:
{
   20ab0:	b508      	push	{r3, lr}
    if(CRYPT_RNG_Initialize(&sysRandCtx) >= 0)
   20ab2:	4805      	ldr	r0, [pc, #20]	; (20ac8 <SYS_RANDOM_CryptoInitialize+0x18>)
   20ab4:	f000 ffaa 	bl	21a0c <CRYPT_RNG_Initialize>
   20ab8:	2800      	cmp	r0, #0
        pRandCtx = 0;
   20aba:	4803      	ldr	r0, [pc, #12]	; (20ac8 <SYS_RANDOM_CryptoInitialize+0x18>)
   20abc:	bfb8      	it	lt
   20abe:	2000      	movlt	r0, #0
   20ac0:	4b02      	ldr	r3, [pc, #8]	; (20acc <SYS_RANDOM_CryptoInitialize+0x1c>)
   20ac2:	6018      	str	r0, [r3, #0]
}
   20ac4:	bd08      	pop	{r3, pc}
   20ac6:	bf00      	nop
   20ac8:	2000d9b0 	.word	0x2000d9b0
   20acc:	2000e68c 	.word	0x2000e68c

Disassembly of section .rodata.tcpipPhyInitData_LAN867x%898:

00020ad0 <tcpipPhyInitData_LAN867x>:
   20ad0:	00000000 42000800 00010000 00021794     .......B........
   20ae0:	00000000 0001d7d4 000220b4 00000000     ......... ......

Disassembly of section .text.prvTaskExitError%899:

00020af0 <prvTaskExitError>:
{
   20af0:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
   20af2:	2300      	movs	r3, #0
   20af4:	9301      	str	r3, [sp, #4]
	__asm volatile
   20af6:	f04f 0320 	mov.w	r3, #32
   20afa:	f383 8811 	msr	BASEPRI, r3
   20afe:	f3bf 8f6f 	isb	sy
   20b02:	f3bf 8f4f 	dsb	sy
	while( ulDummy == 0 )
   20b06:	9b01      	ldr	r3, [sp, #4]
   20b08:	2b00      	cmp	r3, #0
   20b0a:	d0fc      	beq.n	20b06 <prvTaskExitError+0x16>
}
   20b0c:	b002      	add	sp, #8
   20b0e:	4770      	bx	lr

Disassembly of section .text.vPortEnterCritical%900:

00020b10 <vPortEnterCritical>:
   20b10:	f04f 0320 	mov.w	r3, #32
   20b14:	f383 8811 	msr	BASEPRI, r3
   20b18:	f3bf 8f6f 	isb	sy
   20b1c:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
   20b20:	4a02      	ldr	r2, [pc, #8]	; (20b2c <vPortEnterCritical+0x1c>)
   20b22:	6813      	ldr	r3, [r2, #0]
   20b24:	3301      	adds	r3, #1
   20b26:	6013      	str	r3, [r2, #0]
}
   20b28:	4770      	bx	lr
   20b2a:	bf00      	nop
   20b2c:	2000e698 	.word	0x2000e698

Disassembly of section .rodata.reseedSeedA_data%901:

00020b30 <reseedSeedA_data>:
   20b30:	8e8a2be6 b641f1e8 e3660598 49c0e3bf     .+....A...f....I
   20b40:	acd4da03 229fdf2c 670a0180 d383bc39     ....,.."...g9...

Disassembly of section .text.local_miim_close%902:

00020b50 <local_miim_close>:
{
   20b50:	b510      	push	{r4, lr}
	clientObj.miimBase->DRV_MIIM_Close(clientObj.miimHandle);
   20b52:	4c05      	ldr	r4, [pc, #20]	; (20b68 <local_miim_close+0x18>)
   20b54:	68e3      	ldr	r3, [r4, #12]
   20b56:	69db      	ldr	r3, [r3, #28]
   20b58:	68a0      	ldr	r0, [r4, #8]
   20b5a:	4798      	blx	r3
	clientObj.miimHandle = 0;
   20b5c:	2000      	movs	r0, #0
   20b5e:	60a0      	str	r0, [r4, #8]
	SYS_CONSOLE_PRINT("> Miim closed. \r\n");
   20b60:	4902      	ldr	r1, [pc, #8]	; (20b6c <local_miim_close+0x1c>)
   20b62:	f7f9 fe03 	bl	1a76c <SYS_CONSOLE_Print>
}
   20b66:	bd10      	pop	{r4, pc}
   20b68:	2000e4f0 	.word	0x2000e4f0
   20b6c:	0000b164 	.word	0x0000b164

Disassembly of section .text._sbrk_r%903:

00020b70 <_sbrk_r>:
   20b70:	b538      	push	{r3, r4, r5, lr}
   20b72:	4c06      	ldr	r4, [pc, #24]	; (20b8c <_sbrk_r+0x1c>)
   20b74:	2300      	movs	r3, #0
   20b76:	4605      	mov	r5, r0
   20b78:	4608      	mov	r0, r1
   20b7a:	6023      	str	r3, [r4, #0]
   20b7c:	f7fe ff50 	bl	1fa20 <_sbrk>
   20b80:	1c43      	adds	r3, r0, #1
   20b82:	d102      	bne.n	20b8a <_sbrk_r+0x1a>
   20b84:	6823      	ldr	r3, [r4, #0]
   20b86:	b103      	cbz	r3, 20b8a <_sbrk_r+0x1a>
   20b88:	602b      	str	r3, [r5, #0]
   20b8a:	bd38      	pop	{r3, r4, r5, pc}
   20b8c:	20000000 	.word	0x20000000

Disassembly of section .text._close_r%904:

00020b90 <_close_r>:
   20b90:	b538      	push	{r3, r4, r5, lr}
   20b92:	4c06      	ldr	r4, [pc, #24]	; (20bac <_close_r+0x1c>)
   20b94:	2300      	movs	r3, #0
   20b96:	4605      	mov	r5, r0
   20b98:	4608      	mov	r0, r1
   20b9a:	6023      	str	r3, [r4, #0]
   20b9c:	f001 fae2 	bl	22164 <_close>
   20ba0:	1c43      	adds	r3, r0, #1
   20ba2:	d102      	bne.n	20baa <_close_r+0x1a>
   20ba4:	6823      	ldr	r3, [r4, #0]
   20ba6:	b103      	cbz	r3, 20baa <_close_r+0x1a>
   20ba8:	602b      	str	r3, [r5, #0]
   20baa:	bd38      	pop	{r3, r4, r5, pc}
   20bac:	20000000 	.word	0x20000000

Disassembly of section .text._isatty_r%905:

00020bb0 <_isatty_r>:
   20bb0:	b538      	push	{r3, r4, r5, lr}
   20bb2:	4c06      	ldr	r4, [pc, #24]	; (20bcc <_isatty_r+0x1c>)
   20bb4:	2300      	movs	r3, #0
   20bb6:	4605      	mov	r5, r0
   20bb8:	4608      	mov	r0, r1
   20bba:	6023      	str	r3, [r4, #0]
   20bbc:	f001 fad8 	bl	22170 <_isatty>
   20bc0:	1c43      	adds	r3, r0, #1
   20bc2:	d102      	bne.n	20bca <_isatty_r+0x1a>
   20bc4:	6823      	ldr	r3, [r4, #0]
   20bc6:	b103      	cbz	r3, 20bca <_isatty_r+0x1a>
   20bc8:	602b      	str	r3, [r5, #0]
   20bca:	bd38      	pop	{r3, r4, r5, pc}
   20bcc:	20000000 	.word	0x20000000

Disassembly of section .text._DRV_GMAC_LinkStateDown%906:

00020bd0 <_DRV_GMAC_LinkStateDown>:
{
   20bd0:	b510      	push	{r4, lr}
   20bd2:	4604      	mov	r4, r0
	pMACDrv->sGmacData._macFlags._linkPrev = 0;
   20bd4:	7d83      	ldrb	r3, [r0, #22]
	pMACDrv->sGmacData._macFlags._linkUpDone = 0;
   20bd6:	f003 03ef 	and.w	r3, r3, #239	; 0xef
   20bda:	f36f 1345 	bfc	r3, #5, #1
   20bde:	7583      	strb	r3, [r0, #22]
	pMACDrv->sGmacData._linkUpTick = SYS_TMR_TickCountGet();
   20be0:	f7ff f9e4 	bl	1ffac <SYS_TMR_TickCountGet>
   20be4:	63a0      	str	r0, [r4, #56]	; 0x38
	pMACDrv->sGmacData._linkCheckState = DRV_GMAC_LINK_CHECK_START_LINK;
   20be6:	2300      	movs	r3, #0
   20be8:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
}
   20bec:	bd10      	pop	{r4, pc}

Disassembly of section .text._TCPIsGetReady%907:

00020bee <_TCPIsGetReady>:
	if(pSkt->rxHead >= pSkt->rxTail)
   20bee:	69c2      	ldr	r2, [r0, #28]
   20bf0:	6a01      	ldr	r1, [r0, #32]
   20bf2:	428a      	cmp	r2, r1
   20bf4:	d207      	bcs.n	20c06 <_TCPIsGetReady+0x18>
    return (pSkt->rxEnd - pSkt->rxTail + 1) + (pSkt->rxHead - pSkt->rxStart);
   20bf6:	6983      	ldr	r3, [r0, #24]
   20bf8:	1a5b      	subs	r3, r3, r1
   20bfa:	6940      	ldr	r0, [r0, #20]
   20bfc:	1a10      	subs	r0, r2, r0
   20bfe:	4418      	add	r0, r3
   20c00:	3001      	adds	r0, #1
   20c02:	b280      	uxth	r0, r0
}
   20c04:	4770      	bx	lr
		return pSkt->rxHead - pSkt->rxTail;
   20c06:	1a50      	subs	r0, r2, r1
   20c08:	b280      	uxth	r0, r0
   20c0a:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressBcast%908:

00020c0c <TCPIP_STACK_NetAddressBcast>:
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   20c0c:	b158      	cbz	r0, 20c26 <TCPIP_STACK_NetAddressBcast+0x1a>
   20c0e:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20c12:	f012 0f40 	tst.w	r2, #64	; 0x40
   20c16:	d101      	bne.n	20c1c <TCPIP_STACK_NetAddressBcast+0x10>
    return 0;
   20c18:	2000      	movs	r0, #0
}
   20c1a:	4770      	bx	lr
        return (pNetIf->netIPAddr.Val | ~pNetIf->netMask.Val);
   20c1c:	6882      	ldr	r2, [r0, #8]
   20c1e:	6840      	ldr	r0, [r0, #4]
   20c20:	ea60 0002 	orn	r0, r0, r2
   20c24:	4770      	bx	lr
    return 0;
   20c26:	2000      	movs	r0, #0
   20c28:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddress%909:

00020c2a <TCPIP_STACK_NetAddress>:
{
   20c2a:	b508      	push	{r3, lr}
   20c2c:	4603      	mov	r3, r0
   20c2e:	b138      	cbz	r0, 20c40 <TCPIP_STACK_NetAddress+0x16>
   20c30:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20c34:	f002 0240 	and.w	r2, r2, #64	; 0x40
    return 0;
   20c38:	2a00      	cmp	r2, #0
   20c3a:	bf14      	ite	ne
   20c3c:	4603      	movne	r3, r0
   20c3e:	2300      	moveq	r3, #0
    return TCPIP_STACK_NetAddressGet(pNetIf);
   20c40:	4618      	mov	r0, r3
   20c42:	f000 fc07 	bl	21454 <TCPIP_STACK_NetAddressGet>
}
   20c46:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_STACK_NetworkIsLinked%910:

00020c48 <TCPIP_STACK_NetworkIsLinked>:
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   20c48:	b158      	cbz	r0, 20c62 <TCPIP_STACK_NetworkIsLinked+0x1a>
   20c4a:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20c4e:	f012 0f40 	tst.w	r2, #64	; 0x40
   20c52:	d101      	bne.n	20c58 <TCPIP_STACK_NetworkIsLinked+0x10>
    return false;
   20c54:	2000      	movs	r0, #0
}
   20c56:	4770      	bx	lr
        return pNetIf->exFlags.linkPrev;
   20c58:	f890 0060 	ldrb.w	r0, [r0, #96]	; 0x60
   20c5c:	f000 0001 	and.w	r0, r0, #1
   20c60:	4770      	bx	lr
    return false;
   20c62:	2000      	movs	r0, #0
   20c64:	4770      	bx	lr

Disassembly of section .text.TCPIP_PKT_PayloadLen%911:

00020c66 <TCPIP_PKT_PayloadLen>:
    if(pPkt)
   20c66:	b148      	cbz	r0, 20c7c <TCPIP_PKT_PayloadLen+0x16>
        TCPIP_MAC_DATA_SEGMENT* pSeg = pPkt->pDSeg;
   20c68:	6903      	ldr	r3, [r0, #16]
        while(pSeg != 0)
   20c6a:	b14b      	cbz	r3, 20c80 <TCPIP_PKT_PayloadLen+0x1a>
    uint32_t payloadSize = 0;
   20c6c:	2000      	movs	r0, #0
            payloadSize += pSeg->segLen;
   20c6e:	899a      	ldrh	r2, [r3, #12]
   20c70:	4410      	add	r0, r2
            pSeg = pSeg->next;
   20c72:	681b      	ldr	r3, [r3, #0]
        while(pSeg != 0)
   20c74:	2b00      	cmp	r3, #0
   20c76:	d1fa      	bne.n	20c6e <TCPIP_PKT_PayloadLen+0x8>
}
   20c78:	b280      	uxth	r0, r0
   20c7a:	4770      	bx	lr
    uint32_t payloadSize = 0;
   20c7c:	2000      	movs	r0, #0
   20c7e:	e7fb      	b.n	20c78 <TCPIP_PKT_PayloadLen+0x12>
   20c80:	2000      	movs	r0, #0
   20c82:	e7f9      	b.n	20c78 <TCPIP_PKT_PayloadLen+0x12>

Disassembly of section .text.OSAL_SEM_Pend%912:

00020c84 <OSAL_SEM_Pend>:
   </code>

  Remarks:
 */
OSAL_RESULT OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE* semID, uint16_t waitMS)
{
   20c84:	b508      	push	{r3, lr}
  else
  {
    timeout = (TickType_t)(waitMS / portTICK_PERIOD_MS);
  }

  if (xSemaphoreTake(*(SemaphoreHandle_t*)semID, timeout) == pdTRUE)
   20c86:	f64f 73ff 	movw	r3, #65535	; 0xffff
   20c8a:	4299      	cmp	r1, r3
   20c8c:	bf08      	it	eq
   20c8e:	f04f 31ff 	moveq.w	r1, #4294967295
   20c92:	6800      	ldr	r0, [r0, #0]
   20c94:	f7f0 fce2 	bl	1165c <xQueueSemaphoreTake>
    return OSAL_RESULT_TRUE;
  else
    return OSAL_RESULT_FALSE;
}
   20c98:	2801      	cmp	r0, #1
   20c9a:	bf14      	ite	ne
   20c9c:	2000      	movne	r0, #0
   20c9e:	2001      	moveq	r0, #1
   20ca0:	bd08      	pop	{r3, pc}

Disassembly of section .text.OSAL_MUTEX_Lock%913:

00020ca2 <OSAL_MUTEX_Lock>:

  Remarks:

 */
OSAL_RESULT OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE* mutexID, uint16_t waitMS)
{
   20ca2:	b508      	push	{r3, lr}
  else
  {
    timeout = (TickType_t)(waitMS / portTICK_PERIOD_MS);
  }

  if (xSemaphoreTake(*(SemaphoreHandle_t*)mutexID, timeout) == pdTRUE)
   20ca4:	f64f 73ff 	movw	r3, #65535	; 0xffff
   20ca8:	4299      	cmp	r1, r3
   20caa:	bf08      	it	eq
   20cac:	f04f 31ff 	moveq.w	r1, #4294967295
   20cb0:	6800      	ldr	r0, [r0, #0]
   20cb2:	f7f0 fcd3 	bl	1165c <xQueueSemaphoreTake>
    return OSAL_RESULT_TRUE;
  else
    return OSAL_RESULT_FALSE;
}
   20cb6:	2801      	cmp	r0, #1
   20cb8:	bf14      	ite	ne
   20cba:	2000      	movne	r0, #0
   20cbc:	2001      	moveq	r0, #1
   20cbe:	bd08      	pop	{r3, pc}

Disassembly of section .text._keyUpProcess%914:

00020cc0 <_keyUpProcess>:
{   // up arrow
   20cc0:	b508      	push	{r3, lr}
    if(pCmdIO->currHistN)
   20cc2:	f8d0 30d4 	ldr.w	r3, [r0, #212]	; 0xd4
   20cc6:	b13b      	cbz	r3, 20cd8 <_keyUpProcess+0x18>
        pNext = pCmdIO->currHistN->next;
   20cc8:	6819      	ldr	r1, [r3, #0]
        if(pNext == pCmdIO->histList.head)
   20cca:	f8d0 30cc 	ldr.w	r3, [r0, #204]	; 0xcc
   20cce:	428b      	cmp	r3, r1
   20cd0:	d001      	beq.n	20cd6 <_keyUpProcess+0x16>
    DisplayNodeMsg(pCmdIO, pNext);
   20cd2:	f7f7 f965 	bl	17fa0 <DisplayNodeMsg>
}
   20cd6:	bd08      	pop	{r3, pc}
        pNext = pCmdIO->histList.head;
   20cd8:	f8d0 10cc 	ldr.w	r1, [r0, #204]	; 0xcc
   20cdc:	e7f9      	b.n	20cd2 <_keyUpProcess+0x12>

Disassembly of section .text._DRV_ETHPHY_ResetPhaseIdle%915:

00020cde <_DRV_ETHPHY_ResetPhaseIdle>:
{
   20cde:	b510      	push	{r4, lr}
   20ce0:	4604      	mov	r4, r0
    if(_DRV_PHY_SMIWriteStart(hClientObj, PHY_REG_BMCON, _BMCON_RESET_MASK))
   20ce2:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   20ce6:	2100      	movs	r1, #0
   20ce8:	f7fe f83f 	bl	1ed6a <_DRV_PHY_SMIWriteStart>
   20cec:	b900      	cbnz	r0, 20cf0 <_DRV_ETHPHY_ResetPhaseIdle+0x12>
}
   20cee:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   20cf0:	2301      	movs	r3, #1
   20cf2:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   20cf4:	2300      	movs	r3, #0
   20cf6:	8423      	strh	r3, [r4, #32]
}
   20cf8:	e7f9      	b.n	20cee <_DRV_ETHPHY_ResetPhaseIdle+0x10>

Disassembly of section .rodata._DRV_PHY_ClientOpTbl%916:

00020cfc <_DRV_PHY_ClientOpTbl>:
   20cfc:	008f 0001 0831 0002 0811 0002 07f1 0002     ....1...........
   20d0c:	07d1 0002 07b1 0002 0791 0002               ............

Disassembly of section .text.DRV_GMAC_EventPendingGet%917:

00020d18 <DRV_GMAC_EventPendingGet>:
    return pMacD == _gmac_drv_dcpt ? pMacD : 0;
   20d18:	4b05      	ldr	r3, [pc, #20]	; (20d30 <DRV_GMAC_EventPendingGet+0x18>)
   20d1a:	4283      	cmp	r3, r0
   20d1c:	d104      	bne.n	20d28 <DRV_GMAC_EventPendingGet+0x10>
    if(pMACDrv != 0)
   20d1e:	b128      	cbz	r0, 20d2c <DRV_GMAC_EventPendingGet+0x14>
        return pMACDrv->sGmacData._gmac_event_group_dcpt._TcpPendingEvents;
   20d20:	f8b3 004e 	ldrh.w	r0, [r3, #78]	; 0x4e
   20d24:	b280      	uxth	r0, r0
   20d26:	4770      	bx	lr
    return TCPIP_MAC_EV_NONE;
   20d28:	2000      	movs	r0, #0
   20d2a:	4770      	bx	lr
   20d2c:	2000      	movs	r0, #0
}
   20d2e:	4770      	bx	lr
   20d30:	2000dab8 	.word	0x2000dab8

Disassembly of section .text.DRV_PIC32CGMAC_LibClose%918:

00020d34 <DRV_PIC32CGMAC_LibClose>:
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_TXEN_Msk;
   20d34:	4b05      	ldr	r3, [pc, #20]	; (20d4c <DRV_PIC32CGMAC_LibClose+0x18>)
   20d36:	681a      	ldr	r2, [r3, #0]
   20d38:	f022 0208 	bic.w	r2, r2, #8
   20d3c:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_NCR &= ~GMAC_NCR_RXEN_Msk;
   20d3e:	681a      	ldr	r2, [r3, #0]
   20d40:	f022 0204 	bic.w	r2, r2, #4
   20d44:	601a      	str	r2, [r3, #0]
	GMAC_REGS->GMAC_ISR;
   20d46:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
   20d48:	4770      	bx	lr
   20d4a:	bf00      	nop
   20d4c:	42000800 	.word	0x42000800

Disassembly of section .text.DRV_PIC32CGMAC_SingleListHeadRemove%919:

00020d50 <DRV_PIC32CGMAC_SingleListHeadRemove>:
{
   20d50:	4603      	mov	r3, r0
	DRV_PIC32CGMAC_SGL_LIST_NODE* pN = pL->head;
   20d52:	6800      	ldr	r0, [r0, #0]
    if(pN)
   20d54:	b148      	cbz	r0, 20d6a <DRV_PIC32CGMAC_SingleListHeadRemove+0x1a>
        if(pL->head == pL->tail)
   20d56:	685a      	ldr	r2, [r3, #4]
   20d58:	4282      	cmp	r2, r0
            pL->head = pL->tail = 0;
   20d5a:	bf06      	itte	eq
   20d5c:	2200      	moveq	r2, #0
   20d5e:	605a      	streq	r2, [r3, #4]
            pL->head = pN->next;
   20d60:	6802      	ldrne	r2, [r0, #0]
   20d62:	601a      	str	r2, [r3, #0]
        pL->nNodes--;
   20d64:	689a      	ldr	r2, [r3, #8]
   20d66:	3a01      	subs	r2, #1
   20d68:	609a      	str	r2, [r3, #8]
}
   20d6a:	4770      	bx	lr

Disassembly of section .text.Helper_SingleListHeadRemove%920:

00020d6c <Helper_SingleListHeadRemove>:
{
   20d6c:	4603      	mov	r3, r0
	SGL_LIST_NODE* pN = pL->head;
   20d6e:	6800      	ldr	r0, [r0, #0]
    if(pN)
   20d70:	b148      	cbz	r0, 20d86 <Helper_SingleListHeadRemove+0x1a>
        if(pL->head == pL->tail)
   20d72:	685a      	ldr	r2, [r3, #4]
   20d74:	4282      	cmp	r2, r0
            pL->head = pL->tail = 0;
   20d76:	bf06      	itte	eq
   20d78:	2200      	moveq	r2, #0
   20d7a:	605a      	streq	r2, [r3, #4]
            pL->head = pN->next;
   20d7c:	6802      	ldrne	r2, [r0, #0]
   20d7e:	601a      	str	r2, [r3, #0]
        pL->nNodes--;
   20d80:	689a      	ldr	r2, [r3, #8]
   20d82:	3a01      	subs	r2, #1
   20d84:	609a      	str	r2, [r3, #8]
}
   20d86:	4770      	bx	lr

Disassembly of section .text._ARPTxAckFnc%921:

00020d88 <_ARPTxAckFnc>:
{
   20d88:	b508      	push	{r3, lr}
    if(arpMod.pMacPkt != pPkt)
   20d8a:	4b05      	ldr	r3, [pc, #20]	; (20da0 <_ARPTxAckFnc+0x18>)
   20d8c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   20d8e:	4283      	cmp	r3, r0
   20d90:	d101      	bne.n	20d96 <_ARPTxAckFnc+0xe>
    return true;
   20d92:	2001      	movs	r0, #1
}
   20d94:	bd08      	pop	{r3, pc}
        TCPIP_PKT_PacketFree(pPkt);
   20d96:	f7fd f907 	bl	1dfa8 <_TCPIP_PKT_PacketFree>
        return false;
   20d9a:	2000      	movs	r0, #0
   20d9c:	e7fa      	b.n	20d94 <_ARPTxAckFnc+0xc>
   20d9e:	bf00      	nop
   20da0:	2000e1a4 	.word	0x2000e1a4

Disassembly of section .text.TCPIP_IPV4_MaxDatagramDataSizeGet%922:

00020da4 <TCPIP_IPV4_MaxDatagramDataSizeGet>:
   20da4:	b150      	cbz	r0, 20dbc <TCPIP_IPV4_MaxDatagramDataSizeGet+0x18>
   20da6:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20daa:	f012 0f40 	tst.w	r2, #64	; 0x40
   20dae:	d101      	bne.n	20db4 <TCPIP_IPV4_MaxDatagramDataSizeGet+0x10>

int TCPIP_IPV4_MaxDatagramDataSizeGet(TCPIP_NET_HANDLE netH)
{
    TCPIP_NET_IF* pIf = _TCPIPStackHandleToNetUp(netH);

    return pIf ? _TCPIPStackNetLinkMtu(pIf) - sizeof(IPV4_HEADER) : 0;
   20db0:	2000      	movs	r0, #0
}
   20db2:	4770      	bx	lr
    return pIf ? _TCPIPStackNetLinkMtu(pIf) - sizeof(IPV4_HEADER) : 0;
   20db4:	f8b0 005e 	ldrh.w	r0, [r0, #94]	; 0x5e
   20db8:	3814      	subs	r0, #20
   20dba:	4770      	bx	lr
   20dbc:	2000      	movs	r0, #0
   20dbe:	4770      	bx	lr

Disassembly of section .text._TCPIP_HEAP_Calloc%923:

00020dc0 <_TCPIP_HEAP_Calloc>:
{
   20dc0:	b538      	push	{r3, r4, r5, lr}
    void* pBuff = _TCPIP_HEAP_Malloc(heapH, nElems * elemSize);
   20dc2:	fb02 f501 	mul.w	r5, r2, r1
   20dc6:	4629      	mov	r1, r5
   20dc8:	f7f5 ffcd 	bl	16d66 <_TCPIP_HEAP_Malloc>
    if(pBuff)
   20dcc:	4604      	mov	r4, r0
   20dce:	b118      	cbz	r0, 20dd8 <_TCPIP_HEAP_Calloc+0x18>
        memset(pBuff, 0, nElems * elemSize);
   20dd0:	462a      	mov	r2, r5
   20dd2:	2100      	movs	r1, #0
   20dd4:	f000 fed2 	bl	21b7c <memset>
}
   20dd8:	4620      	mov	r0, r4
   20dda:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .rodata._DHCPOptWriteTbl%924:

00020ddc <_DHCPOptWriteTbl>:
   20ddc:	03b1 0002 be45 0001 fd7d 0001 c2cd 0001     ....E...}.......
   20dec:	0e15 0001 f4e7 0001 17f9 0002               ............

Disassembly of section .text.TCPIP_Helper_SingleListHeadRemove%925:

00020df8 <TCPIP_Helper_SingleListHeadRemove>:
{
   20df8:	4603      	mov	r3, r0
	SGL_LIST_NODE* pN = pL->head;
   20dfa:	6800      	ldr	r0, [r0, #0]
    if(pN)
   20dfc:	b148      	cbz	r0, 20e12 <TCPIP_Helper_SingleListHeadRemove+0x1a>
        if(pL->head == pL->tail)
   20dfe:	685a      	ldr	r2, [r3, #4]
   20e00:	4282      	cmp	r2, r0
            pL->head = pL->tail = 0;
   20e02:	bf06      	itte	eq
   20e04:	2200      	moveq	r2, #0
   20e06:	605a      	streq	r2, [r3, #4]
            pL->head = pN->next;
   20e08:	6802      	ldrne	r2, [r0, #0]
   20e0a:	601a      	str	r2, [r3, #0]
        pL->nNodes--;
   20e0c:	689a      	ldr	r2, [r3, #8]
   20e0e:	3a01      	subs	r2, #1
   20e10:	609a      	str	r2, [r3, #8]
}
   20e12:	4770      	bx	lr

Disassembly of section .text.TCPIP_Helper_ProtectedSingleListUnlock%926:

00020e14 <TCPIP_Helper_ProtectedSingleListUnlock>:

bool TCPIP_Helper_ProtectedSingleListUnlock(PROTECTED_SINGLE_LIST* pL)
{
   20e14:	b508      	push	{r3, lr}
   20e16:	4603      	mov	r3, r0
    if(pL->semValid)
   20e18:	7c00      	ldrb	r0, [r0, #16]
   20e1a:	b900      	cbnz	r0, 20e1e <TCPIP_Helper_ProtectedSingleListUnlock+0xa>
    {
        return (OSAL_SEM_Post(&pL->semaphore) == OSAL_RESULT_TRUE);
    }

    return false;
}
   20e1c:	bd08      	pop	{r3, pc}
        return (OSAL_SEM_Post(&pL->semaphore) == OSAL_RESULT_TRUE);
   20e1e:	f103 000c 	add.w	r0, r3, #12
   20e22:	f000 fb47 	bl	214b4 <OSAL_SEM_Post>
   20e26:	2801      	cmp	r0, #1
   20e28:	bf14      	ite	ne
   20e2a:	2000      	movne	r0, #0
   20e2c:	2001      	moveq	r0, #1
   20e2e:	e7f5      	b.n	20e1c <TCPIP_Helper_ProtectedSingleListUnlock+0x8>

Disassembly of section .text._TCPIPSignalEntryNotify%927:

00020e30 <_TCPIPSignalEntryNotify>:
{
   20e30:	b510      	push	{r4, lr}
    if((userF = pSigEntry->userSignalF) != 0)
   20e32:	6844      	ldr	r4, [r0, #4]
   20e34:	b134      	cbz	r4, 20e44 <_TCPIPSignalEntryNotify+0x14>
   20e36:	4613      	mov	r3, r2
   20e38:	460a      	mov	r2, r1
        (*userF)(pSigEntry, pSigEntry - TCPIP_STACK_MODULE_SIGNAL_TBL, signal, sigParam);
   20e3a:	4903      	ldr	r1, [pc, #12]	; (20e48 <_TCPIPSignalEntryNotify+0x18>)
   20e3c:	1a41      	subs	r1, r0, r1
   20e3e:	f3c1 110f 	ubfx	r1, r1, #4, #16
   20e42:	47a0      	blx	r4
}
   20e44:	bd10      	pop	{r4, pc}
   20e46:	bf00      	nop
   20e48:	2000d1d4 	.word	0x2000d1d4

Disassembly of section .text.TCPIP_STACK_Status%928:

00020e4c <TCPIP_STACK_Status>:
    if(object != (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data)
   20e4c:	4b04      	ldr	r3, [pc, #16]	; (20e60 <TCPIP_STACK_Status+0x14>)
   20e4e:	4283      	cmp	r3, r0
    return tcpip_stack_status;
   20e50:	bf06      	itte	eq
   20e52:	4b04      	ldreq	r3, [pc, #16]	; (20e64 <TCPIP_STACK_Status+0x18>)
   20e54:	f993 0000 	ldrsbeq.w	r0, [r3]
        return SYS_STATUS_ERROR;
   20e58:	f04f 30ff 	movne.w	r0, #4294967295
}
   20e5c:	4770      	bx	lr
   20e5e:	bf00      	nop
   20e60:	2000e2f0 	.word	0x2000e2f0
   20e64:	2000e729 	.word	0x2000e729

Disassembly of section .text.TCPIP_STACK_NetAddressGatewaySet%929:

00020e68 <TCPIP_STACK_NetAddressGatewaySet>:
   20e68:	b150      	cbz	r0, 20e80 <TCPIP_STACK_NetAddressGatewaySet+0x18>
   20e6a:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20e6e:	f012 0f40 	tst.w	r2, #64	; 0x40
   20e72:	d101      	bne.n	20e78 <TCPIP_STACK_NetAddressGatewaySet+0x10>
    return false;
   20e74:	2000      	movs	r0, #0
}
   20e76:	4770      	bx	lr
        pNetIf->netGateway.Val = ipAddress->Val;
   20e78:	680a      	ldr	r2, [r1, #0]
   20e7a:	60c2      	str	r2, [r0, #12]
        return true;
   20e7c:	2001      	movs	r0, #1
   20e7e:	4770      	bx	lr
    return false;
   20e80:	2000      	movs	r0, #0
   20e82:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressDnsPrimarySet%930:

00020e84 <TCPIP_STACK_NetAddressDnsPrimarySet>:
   20e84:	4603      	mov	r3, r0
   20e86:	b138      	cbz	r0, 20e98 <TCPIP_STACK_NetAddressDnsPrimarySet+0x14>
   20e88:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20e8c:	f012 0f40 	tst.w	r2, #64	; 0x40
   20e90:	bf0e      	itee	eq
   20e92:	2300      	moveq	r3, #0
        pNetIf->dnsServer[0].Val = ipAddress->Val;
   20e94:	680a      	ldrne	r2, [r1, #0]
   20e96:	6102      	strne	r2, [r0, #16]
    return pNetIf != 0;
   20e98:	1c18      	adds	r0, r3, #0
   20e9a:	bf18      	it	ne
   20e9c:	2001      	movne	r0, #1
}
   20e9e:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressDnsSecondSet%931:

00020ea0 <TCPIP_STACK_NetAddressDnsSecondSet>:
   20ea0:	b150      	cbz	r0, 20eb8 <TCPIP_STACK_NetAddressDnsSecondSet+0x18>
   20ea2:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20ea6:	f012 0f40 	tst.w	r2, #64	; 0x40
   20eaa:	d101      	bne.n	20eb0 <TCPIP_STACK_NetAddressDnsSecondSet+0x10>
    return false;
   20eac:	2000      	movs	r0, #0
}
   20eae:	4770      	bx	lr
        pNetIf->dnsServer[1].Val = ipAddress->Val;
   20eb0:	680a      	ldr	r2, [r1, #0]
   20eb2:	6142      	str	r2, [r0, #20]
        return true;
   20eb4:	2001      	movs	r0, #1
   20eb6:	4770      	bx	lr
    return false;
   20eb8:	2000      	movs	r0, #0
   20eba:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetIsUp%932:

00020ebc <TCPIP_STACK_NetIsUp>:
   20ebc:	4603      	mov	r3, r0
   20ebe:	b138      	cbz	r0, 20ed0 <TCPIP_STACK_NetIsUp+0x14>
   20ec0:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20ec4:	f002 0240 	and.w	r2, r2, #64	; 0x40
    return 0;
   20ec8:	2a00      	cmp	r2, #0
   20eca:	bf14      	ite	ne
   20ecc:	4603      	movne	r3, r0
   20ece:	2300      	moveq	r3, #0
}
   20ed0:	1c18      	adds	r0, r3, #0
   20ed2:	bf18      	it	ne
   20ed4:	2001      	movne	r0, #1
   20ed6:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetMask%933:

00020ed8 <TCPIP_STACK_NetMask>:
{
   20ed8:	b508      	push	{r3, lr}
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   20eda:	b148      	cbz	r0, 20ef0 <TCPIP_STACK_NetMask+0x18>
   20edc:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20ee0:	f012 0f40 	tst.w	r2, #64	; 0x40
   20ee4:	d101      	bne.n	20eea <TCPIP_STACK_NetMask+0x12>
    return 0;
   20ee6:	2000      	movs	r0, #0
}
   20ee8:	bd08      	pop	{r3, pc}
        return TCPIP_STACK_NetMaskGet(pNetIf);
   20eea:	f000 fabf 	bl	2146c <TCPIP_STACK_NetMaskGet>
   20eee:	e7fb      	b.n	20ee8 <TCPIP_STACK_NetMask+0x10>
    return 0;
   20ef0:	2000      	movs	r0, #0
   20ef2:	e7f9      	b.n	20ee8 <TCPIP_STACK_NetMask+0x10>

Disassembly of section .text.TCPIP_STACK_NetIsLinked%934:

00020ef4 <TCPIP_STACK_NetIsLinked>:
{
   20ef4:	b508      	push	{r3, lr}
   20ef6:	b148      	cbz	r0, 20f0c <TCPIP_STACK_NetIsLinked+0x18>
   20ef8:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   20efc:	f012 0f40 	tst.w	r2, #64	; 0x40
   20f00:	d101      	bne.n	20f06 <TCPIP_STACK_NetIsLinked+0x12>
    return false;
   20f02:	2000      	movs	r0, #0
}
   20f04:	bd08      	pop	{r3, pc}
        return TCPIP_STACK_NetworkIsLinked(pNetIf);
   20f06:	f7ff fe9f 	bl	20c48 <TCPIP_STACK_NetworkIsLinked>
   20f0a:	e7fb      	b.n	20f04 <TCPIP_STACK_NetIsLinked+0x10>
    return false;
   20f0c:	2000      	movs	r0, #0
   20f0e:	e7f9      	b.n	20f04 <TCPIP_STACK_NetIsLinked+0x10>

Disassembly of section .text.TCPIP_STACK_Deinitialize%935:

00020f10 <TCPIP_STACK_Deinitialize>:
{
   20f10:	b508      	push	{r3, lr}
    if(object != (SYS_MODULE_OBJ)&tcpip_stack_ctrl_data || tcpipNetIf == 0)
   20f12:	4b04      	ldr	r3, [pc, #16]	; (20f24 <TCPIP_STACK_Deinitialize+0x14>)
   20f14:	4283      	cmp	r3, r0
   20f16:	d104      	bne.n	20f22 <TCPIP_STACK_Deinitialize+0x12>
   20f18:	4b03      	ldr	r3, [pc, #12]	; (20f28 <TCPIP_STACK_Deinitialize+0x18>)
   20f1a:	681b      	ldr	r3, [r3, #0]
   20f1c:	b10b      	cbz	r3, 20f22 <TCPIP_STACK_Deinitialize+0x12>
    TCPIP_STACK_KillStack();
   20f1e:	f7f5 f91f 	bl	16160 <TCPIP_STACK_KillStack>
}
   20f22:	bd08      	pop	{r3, pc}
   20f24:	2000e2f0 	.word	0x2000e2f0
   20f28:	2000e648 	.word	0x2000e648

Disassembly of section .text._keyLeftProcess%936:

00020f2c <_keyLeftProcess>:
{   // left arrow
   20f2c:	b508      	push	{r3, lr}
    if(pCmdIO->cmdPnt > pCmdIO->cmdBuff)
   20f2e:	6983      	ldr	r3, [r0, #24]
   20f30:	f100 0220 	add.w	r2, r0, #32
   20f34:	4293      	cmp	r3, r2
   20f36:	d906      	bls.n	20f46 <_keyLeftProcess+0x1a>
    const SYS_CMD_API* pCmdApi = pCmdIO->devNode.pCmdApi;
   20f38:	6802      	ldr	r2, [r0, #0]
        pCmdIO->cmdPnt--;
   20f3a:	3b01      	subs	r3, #1
   20f3c:	6183      	str	r3, [r0, #24]
        (*pCmdApi->msg)(cmdIoParam, pSeqDcpt->keyCode);
   20f3e:	6813      	ldr	r3, [r2, #0]
   20f40:	6809      	ldr	r1, [r1, #0]
   20f42:	6840      	ldr	r0, [r0, #4]
   20f44:	4798      	blx	r3
}
   20f46:	bd08      	pop	{r3, pc}

Disassembly of section .text.SendCommandMessage%937:

00020f48 <SendCommandMessage>:
{
   20f48:	b510      	push	{r4, lr}
   20f4a:	460c      	mov	r4, r1
    SYS_CONSOLE_Write(_cmdInitData.consoleIndex, message, strlen(message));
   20f4c:	4608      	mov	r0, r1
   20f4e:	f000 fe25 	bl	21b9c <strlen>
   20f52:	4602      	mov	r2, r0
   20f54:	4621      	mov	r1, r4
   20f56:	4b02      	ldr	r3, [pc, #8]	; (20f60 <SendCommandMessage+0x18>)
   20f58:	8858      	ldrh	r0, [r3, #2]
   20f5a:	f7fd fde9 	bl	1eb30 <SYS_CONSOLE_Write>
}
   20f5e:	bd10      	pop	{r4, pc}
   20f60:	2000e674 	.word	0x2000e674

Disassembly of section .text.SYS_DEBUG_Initialize%938:

00020f64 <SYS_DEBUG_Initialize>:
    const SYS_MODULE_INIT* const init
)
{
    SYS_DEBUG_INIT* initConfig = (SYS_DEBUG_INIT*)init;

    gblErrLvl = initConfig->errorLevel;
   20f64:	784a      	ldrb	r2, [r1, #1]
   20f66:	4b04      	ldr	r3, [pc, #16]	; (20f78 <SYS_DEBUG_Initialize+0x14>)
   20f68:	701a      	strb	r2, [r3, #0]

    sysDebugInstance.debugConsole = initConfig->consoleIndex;
   20f6a:	4b04      	ldr	r3, [pc, #16]	; (20f7c <SYS_DEBUG_Initialize+0x18>)
   20f6c:	884a      	ldrh	r2, [r1, #2]
   20f6e:	805a      	strh	r2, [r3, #2]
    sysDebugInstance.status = SYS_STATUS_READY;
   20f70:	2202      	movs	r2, #2
   20f72:	701a      	strb	r2, [r3, #0]

    return SYS_MODULE_OBJ_STATIC;
}
   20f74:	2000      	movs	r0, #0
   20f76:	4770      	bx	lr
   20f78:	2000e72c 	.word	0x2000e72c
   20f7c:	2000e680 	.word	0x2000e680

Disassembly of section .text.SYS_TIME_Counter64Update%939:

00020f80 <SYS_TIME_Counter64Update>:
    uint32_t prevSwCounter32Bit = counterObj->swCounter64Low;
   20f80:	4a05      	ldr	r2, [pc, #20]	; (20f98 <SYS_TIME_Counter64Update+0x18>)
   20f82:	6a53      	ldr	r3, [r2, #36]	; 0x24
    newSwCounter32Bit = prevSwCounter32Bit + elapsedCount;
   20f84:	4418      	add	r0, r3
    counterObj->swCounter64Low = SYS_TIME_Counter32Update(elapsedCount, &isSwCounter32Oveflow);
   20f86:	6250      	str	r0, [r2, #36]	; 0x24
    if (isSwCounter32Oveflow == true)
   20f88:	4283      	cmp	r3, r0
   20f8a:	d800      	bhi.n	20f8e <SYS_TIME_Counter64Update+0xe>
}
   20f8c:	4770      	bx	lr
        counterObj->swCounter64High++;
   20f8e:	6a93      	ldr	r3, [r2, #40]	; 0x28
   20f90:	3301      	adds	r3, #1
   20f92:	6293      	str	r3, [r2, #40]	; 0x28
}
   20f94:	e7fa      	b.n	20f8c <SYS_TIME_Counter64Update+0xc>
   20f96:	bf00      	nop
   20f98:	2000e230 	.word	0x2000e230

Disassembly of section .text.SYS_TIME_GetElapsedCount%940:

00020f9c <SYS_TIME_GetElapsedCount>:
    if (hwTimerCurrentValue > counterObj->hwTimerPreviousValue)
   20f9c:	4b05      	ldr	r3, [pc, #20]	; (20fb4 <SYS_TIME_GetElapsedCount+0x18>)
   20f9e:	691b      	ldr	r3, [r3, #16]
   20fa0:	4283      	cmp	r3, r0
        elapsedCount = hwTimerCurrentValue - counterObj->hwTimerPreviousValue;
   20fa2:	4b04      	ldr	r3, [pc, #16]	; (20fb4 <SYS_TIME_GetElapsedCount+0x18>)
   20fa4:	691b      	ldr	r3, [r3, #16]
   20fa6:	bf32      	itee	cc
   20fa8:	1ac0      	subcc	r0, r0, r3
        elapsedCount = (SYS_TIME_HW_COUNTER_PERIOD - counterObj->hwTimerPreviousValue) + hwTimerCurrentValue + 1;
   20faa:	f5c3 3380 	rsbcs	r3, r3, #65536	; 0x10000
   20fae:	18c0      	addcs	r0, r0, r3
}
   20fb0:	4770      	bx	lr
   20fb2:	bf00      	nop
   20fb4:	2000e230 	.word	0x2000e230

Disassembly of section .text.SYS_TIME_MSToCount%941:

00020fb8 <SYS_TIME_MSToCount>:
{
   20fb8:	b508      	push	{r3, lr}
    return (uint32_t) (( ms * (uint64_t) gSystemCounterObj.hwTimerFrequency) / 1000);
   20fba:	4b05      	ldr	r3, [pc, #20]	; (20fd0 <SYS_TIME_MSToCount+0x18>)
   20fbc:	68d9      	ldr	r1, [r3, #12]
   20fbe:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   20fc2:	2300      	movs	r3, #0
   20fc4:	fba1 0100 	umull	r0, r1, r1, r0
   20fc8:	f7fe f9d4 	bl	1f374 <__aeabi_uldivmod>
}
   20fcc:	bd08      	pop	{r3, pc}
   20fce:	bf00      	nop
   20fd0:	2000e230 	.word	0x2000e230

Disassembly of section .text.SYS_TMR_CallbackPeriodic%942:

00020fd4 <SYS_TMR_CallbackPeriodic>:
{
   20fd4:	b508      	push	{r3, lr}
	systemAdaptObj.callback = callback;
   20fd6:	4b04      	ldr	r3, [pc, #16]	; (20fe8 <SYS_TMR_CallbackPeriodic+0x14>)
   20fd8:	601a      	str	r2, [r3, #0]
	return SYS_TIME_CallbackRegisterMS((SYS_TIME_CALLBACK)sy_time_h2_adapter_callback, context, periodMs, SYS_TIME_PERIODIC );
   20fda:	2301      	movs	r3, #1
   20fdc:	4602      	mov	r2, r0
   20fde:	4803      	ldr	r0, [pc, #12]	; (20fec <SYS_TMR_CallbackPeriodic+0x18>)
   20fe0:	f7fb f802 	bl	1bfe8 <SYS_TIME_CallbackRegisterMS>
}
   20fe4:	bd08      	pop	{r3, pc}
   20fe6:	bf00      	nop
   20fe8:	2000e688 	.word	0x2000e688
   20fec:	00021acd 	.word	0x00021acd

Disassembly of section .rodata.sysTimePlibAPI%943:

00020ff0 <sysTimePlibAPI>:
   20ff0:	00021f35 0002152d 00021545 00022095     5...-...E.... ..
   21000:	0002185d 00021871 0001ff5d              ]...q...]...

Disassembly of section .text.vTaskPlaceOnEventList%944:

0002100c <vTaskPlaceOnEventList>:
{
   2100c:	b510      	push	{r4, lr}
   2100e:	460c      	mov	r4, r1
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   21010:	4b04      	ldr	r3, [pc, #16]	; (21024 <vTaskPlaceOnEventList+0x18>)
   21012:	6819      	ldr	r1, [r3, #0]
   21014:	3118      	adds	r1, #24
   21016:	f7fd fdbf 	bl	1eb98 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   2101a:	2101      	movs	r1, #1
   2101c:	4620      	mov	r0, r4
   2101e:	f7f7 f80b 	bl	18038 <prvAddCurrentTaskToDelayedList>
}
   21022:	bd10      	pop	{r4, pc}
   21024:	2000e6a4 	.word	0x2000e6a4

Disassembly of section .text.pvTaskIncrementMutexHeldCount%945:

00021028 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
   21028:	4b05      	ldr	r3, [pc, #20]	; (21040 <pvTaskIncrementMutexHeldCount+0x18>)
   2102a:	681b      	ldr	r3, [r3, #0]
   2102c:	b123      	cbz	r3, 21038 <pvTaskIncrementMutexHeldCount+0x10>
			( pxCurrentTCB->uxMutexesHeld )++;
   2102e:	4b04      	ldr	r3, [pc, #16]	; (21040 <pvTaskIncrementMutexHeldCount+0x18>)
   21030:	681a      	ldr	r2, [r3, #0]
   21032:	6c93      	ldr	r3, [r2, #72]	; 0x48
   21034:	3301      	adds	r3, #1
   21036:	6493      	str	r3, [r2, #72]	; 0x48
		return pxCurrentTCB;
   21038:	4b01      	ldr	r3, [pc, #4]	; (21040 <pvTaskIncrementMutexHeldCount+0x18>)
   2103a:	6818      	ldr	r0, [r3, #0]
	}
   2103c:	4770      	bx	lr
   2103e:	bf00      	nop
   21040:	2000e6a4 	.word	0x2000e6a4

Disassembly of section .text.memcmp%946:

00021044 <memcmp>:
   21044:	b530      	push	{r4, r5, lr}
   21046:	3901      	subs	r1, #1
   21048:	2400      	movs	r4, #0
   2104a:	42a2      	cmp	r2, r4
   2104c:	d101      	bne.n	21052 <memcmp+0xe>
   2104e:	2000      	movs	r0, #0
   21050:	e005      	b.n	2105e <memcmp+0x1a>
   21052:	5d03      	ldrb	r3, [r0, r4]
   21054:	3401      	adds	r4, #1
   21056:	5d0d      	ldrb	r5, [r1, r4]
   21058:	42ab      	cmp	r3, r5
   2105a:	d0f6      	beq.n	2104a <memcmp+0x6>
   2105c:	1b58      	subs	r0, r3, r5
   2105e:	bd30      	pop	{r4, r5, pc}

Disassembly of section .text.memcpy%947:

00021060 <memcpy>:
   21060:	440a      	add	r2, r1
   21062:	4291      	cmp	r1, r2
   21064:	f100 33ff 	add.w	r3, r0, #4294967295
   21068:	d100      	bne.n	2106c <memcpy+0xc>
   2106a:	4770      	bx	lr
   2106c:	b510      	push	{r4, lr}
   2106e:	f811 4b01 	ldrb.w	r4, [r1], #1
   21072:	f803 4f01 	strb.w	r4, [r3, #1]!
   21076:	4291      	cmp	r1, r2
   21078:	d1f9      	bne.n	2106e <memcpy+0xe>
   2107a:	bd10      	pop	{r4, pc}

Disassembly of section .text._calloc_r%948:

0002107c <_calloc_r>:
   2107c:	b538      	push	{r3, r4, r5, lr}
   2107e:	fb02 f401 	mul.w	r4, r2, r1
   21082:	4621      	mov	r1, r4
   21084:	f7f5 fc62 	bl	1694c <_malloc_r>
   21088:	4605      	mov	r5, r0
   2108a:	b118      	cbz	r0, 21094 <_calloc_r+0x18>
   2108c:	4622      	mov	r2, r4
   2108e:	2100      	movs	r1, #0
   21090:	f000 fd74 	bl	21b7c <memset>
   21094:	4628      	mov	r0, r5
   21096:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.vsnprintf%949:

00021098 <vsniprintf>:
   21098:	b507      	push	{r0, r1, r2, lr}
   2109a:	9300      	str	r3, [sp, #0]
   2109c:	4613      	mov	r3, r2
   2109e:	460a      	mov	r2, r1
   210a0:	4601      	mov	r1, r0
   210a2:	4803      	ldr	r0, [pc, #12]	; (210b0 <vsniprintf+0x18>)
   210a4:	6800      	ldr	r0, [r0, #0]
   210a6:	f7fa fbe9 	bl	1b87c <_vsniprintf_r>
   210aa:	b003      	add	sp, #12
   210ac:	f85d fb04 	ldr.w	pc, [sp], #4
   210b0:	2000e700 	.word	0x2000e700

Disassembly of section .text._fputwc_r%950:

000210b4 <_fputwc_r>:
   210b4:	f9b2 300c 	ldrsh.w	r3, [r2, #12]
   210b8:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   210bc:	d106      	bne.n	210cc <_fputwc_r+0x18>
   210be:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   210c2:	8193      	strh	r3, [r2, #12]
   210c4:	6e13      	ldr	r3, [r2, #96]	; 0x60
   210c6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   210ca:	6613      	str	r3, [r2, #96]	; 0x60
   210cc:	f7f7 bf09 	b.w	18ee2 <__fputwc>

Disassembly of section .text.DRV_PIC32CGMAC_SingleListTailAdd%951:

000210d0 <DRV_PIC32CGMAC_SingleListTailAdd>:
	pN->next = 0;
   210d0:	2300      	movs	r3, #0
   210d2:	600b      	str	r3, [r1, #0]
	if(pL->tail == 0)
   210d4:	6843      	ldr	r3, [r0, #4]
   210d6:	b12b      	cbz	r3, 210e4 <DRV_PIC32CGMAC_SingleListTailAdd+0x14>
		pL->tail->next = pN;
   210d8:	6019      	str	r1, [r3, #0]
		pL->tail = pN;
   210da:	6041      	str	r1, [r0, #4]
    pL->nNodes++;
   210dc:	6883      	ldr	r3, [r0, #8]
   210de:	3301      	adds	r3, #1
   210e0:	6083      	str	r3, [r0, #8]
}
   210e2:	4770      	bx	lr
		pL->head = pL->tail = pN;
   210e4:	6041      	str	r1, [r0, #4]
   210e6:	6001      	str	r1, [r0, #0]
   210e8:	e7f8      	b.n	210dc <DRV_PIC32CGMAC_SingleListTailAdd+0xc>

Disassembly of section .text.Helper_SingleListTailAdd%952:

000210ea <Helper_SingleListTailAdd>:
	pN->next = 0;
   210ea:	2300      	movs	r3, #0
   210ec:	600b      	str	r3, [r1, #0]
	if(pL->tail == 0)
   210ee:	6843      	ldr	r3, [r0, #4]
   210f0:	b12b      	cbz	r3, 210fe <Helper_SingleListTailAdd+0x14>
		pL->tail->next = pN;
   210f2:	6019      	str	r1, [r3, #0]
		pL->tail = pN;
   210f4:	6041      	str	r1, [r0, #4]
    pL->nNodes++;
   210f6:	6883      	ldr	r3, [r0, #8]
   210f8:	3301      	adds	r3, #1
   210fa:	6083      	str	r3, [r0, #8]
}
   210fc:	4770      	bx	lr
		pL->head = pL->tail = pN;
   210fe:	6041      	str	r1, [r0, #4]
   21100:	6001      	str	r1, [r0, #0]
   21102:	e7f8      	b.n	210f6 <Helper_SingleListTailAdd+0xc>

Disassembly of section .text.DRV_MIIM_Read%953:

00021104 <DRV_MIIM_Read>:
{
   21104:	b510      	push	{r4, lr}
   21106:	b084      	sub	sp, #16
    return _DRV_MIIM_StartOp(handle, rIx, phyAdd, 0xffff, opFlags, pOpResult, DRV_MIIM_OP_READ);
   21108:	2401      	movs	r4, #1
   2110a:	9402      	str	r4, [sp, #8]
   2110c:	9c06      	ldr	r4, [sp, #24]
   2110e:	9401      	str	r4, [sp, #4]
   21110:	9300      	str	r3, [sp, #0]
   21112:	f64f 73ff 	movw	r3, #65535	; 0xffff
   21116:	f7f4 fd23 	bl	15b60 <_DRV_MIIM_StartOp>
}
   2111a:	b004      	add	sp, #16
   2111c:	bd10      	pop	{r4, pc}

Disassembly of section .text.DRV_MIIM_Write%954:

0002111e <DRV_MIIM_Write>:
{
   2111e:	b510      	push	{r4, lr}
   21120:	b084      	sub	sp, #16
    return _DRV_MIIM_StartOp(handle, rIx, phyAdd, wData, opFlags, pOpResult, DRV_MIIM_OP_WRITE);
   21122:	2402      	movs	r4, #2
   21124:	9402      	str	r4, [sp, #8]
   21126:	9c07      	ldr	r4, [sp, #28]
   21128:	9401      	str	r4, [sp, #4]
   2112a:	f89d 4018 	ldrb.w	r4, [sp, #24]
   2112e:	9400      	str	r4, [sp, #0]
   21130:	f7f4 fd16 	bl	15b60 <_DRV_MIIM_StartOp>
}
   21134:	b004      	add	sp, #16
   21136:	bd10      	pop	{r4, pc}

Disassembly of section .text.DRV_MIIM_Scan%955:

00021138 <DRV_MIIM_Scan>:
{
   21138:	b510      	push	{r4, lr}
   2113a:	b084      	sub	sp, #16
    return _DRV_MIIM_StartOp(handle, rIx, phyAdd, 0xffff, opFlags, pOpResult, DRV_MIIM_OP_SCAN);
   2113c:	2403      	movs	r4, #3
   2113e:	9402      	str	r4, [sp, #8]
   21140:	9c06      	ldr	r4, [sp, #24]
   21142:	9401      	str	r4, [sp, #4]
   21144:	9300      	str	r3, [sp, #0]
   21146:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2114a:	f7f4 fd09 	bl	15b60 <_DRV_MIIM_StartOp>
}
   2114e:	b004      	add	sp, #16
   21150:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_TCP_ClientOpen%956:

00021152 <TCPIP_TCP_ClientOpen>:
    if(addType == IP_ADDRESS_TYPE_IPV6)
   21152:	2802      	cmp	r0, #2
   21154:	d007      	beq.n	21166 <TCPIP_TCP_ClientOpen+0x14>
{
   21156:	b508      	push	{r3, lr}
   21158:	4613      	mov	r3, r2
   2115a:	460a      	mov	r2, r1
    skt = _TCP_Open(addType, TCP_OPEN_CLIENT, remotePort, remoteAddress);
   2115c:	2101      	movs	r1, #1
   2115e:	4608      	mov	r0, r1
   21160:	f7eb f80e 	bl	c180 <_TCP_Open>
}
   21164:	bd08      	pop	{r3, pc}
        return INVALID_SOCKET; 
   21166:	f04f 30ff 	mov.w	r0, #4294967295
}
   2116a:	4770      	bx	lr

Disassembly of section .text.TCPIP_TCP_PutIsReady%957:

0002116c <TCPIP_TCP_PutIsReady>:
{
   2116c:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   2116e:	f7fe fda1 	bl	1fcb4 <_TcpSocketChk>
    return pSkt ? _TCPIsPutReady(pSkt) : 0;
   21172:	b120      	cbz	r0, 2117e <TCPIP_TCP_PutIsReady+0x12>
    if(pSkt->pTxPkt == 0)
   21174:	6c42      	ldr	r2, [r0, #68]	; 0x44
   21176:	b122      	cbz	r2, 21182 <TCPIP_TCP_PutIsReady+0x16>
    return _TCPSocketTxFreeSize(pSkt);
   21178:	f7fd feec 	bl	1ef54 <_TCPSocketTxFreeSize>
}
   2117c:	bd08      	pop	{r3, pc}
    return pSkt ? _TCPIsPutReady(pSkt) : 0;
   2117e:	2000      	movs	r0, #0
   21180:	e7fc      	b.n	2117c <TCPIP_TCP_PutIsReady+0x10>
        return 0;
   21182:	2000      	movs	r0, #0
   21184:	e7fa      	b.n	2117c <TCPIP_TCP_PutIsReady+0x10>

Disassembly of section .text.TCPIP_DNS_IsResolved%958:

00021186 <TCPIP_DNS_IsResolved>:
{
   21186:	b508      	push	{r3, lr}
    if(type == IP_ADDRESS_TYPE_IPV4)
   21188:	2a01      	cmp	r2, #1
   2118a:	d007      	beq.n	2119c <TCPIP_DNS_IsResolved+0x16>
    else if(type == IP_ADDRESS_TYPE_IPV6)
   2118c:	2a02      	cmp	r2, #2
        hostIPv6 = &hostIP->v6Add;
   2118e:	460a      	mov	r2, r1
   21190:	bf08      	it	eq
   21192:	2100      	moveq	r1, #0
    return _DNS_IsNameResolved(hostName, hostIPv4, hostIPv6, true);
   21194:	2301      	movs	r3, #1
   21196:	f7f3 f9cb 	bl	14530 <_DNS_IsNameResolved>
}
   2119a:	bd08      	pop	{r3, pc}
        hostIPv6 = 0;
   2119c:	2200      	movs	r2, #0
   2119e:	e7f9      	b.n	21194 <TCPIP_DNS_IsResolved+0xe>

Disassembly of section .text.TCPIP_Helper_SingleListTailAdd%959:

000211a0 <TCPIP_Helper_SingleListTailAdd>:
	pN->next = 0;
   211a0:	2300      	movs	r3, #0
   211a2:	600b      	str	r3, [r1, #0]
	if(pL->tail == 0)
   211a4:	6843      	ldr	r3, [r0, #4]
   211a6:	b12b      	cbz	r3, 211b4 <TCPIP_Helper_SingleListTailAdd+0x14>
		pL->tail->next = pN;
   211a8:	6019      	str	r1, [r3, #0]
		pL->tail = pN;
   211aa:	6041      	str	r1, [r0, #4]
    pL->nNodes++;
   211ac:	6883      	ldr	r3, [r0, #8]
   211ae:	3301      	adds	r3, #1
   211b0:	6083      	str	r3, [r0, #8]
}
   211b2:	4770      	bx	lr
		pL->head = pL->tail = pN;
   211b4:	6041      	str	r1, [r0, #4]
   211b6:	6001      	str	r1, [r0, #0]
   211b8:	e7f8      	b.n	211ac <TCPIP_Helper_SingleListTailAdd+0xc>

Disassembly of section .text.TCPIP_Helper_SingleListAppend%960:

000211ba <TCPIP_Helper_SingleListAppend>:
{
   211ba:	b538      	push	{r3, r4, r5, lr}
   211bc:	4605      	mov	r5, r0
   211be:	460c      	mov	r4, r1
	while((pN = TCPIP_Helper_SingleListHeadRemove(pAList)))
   211c0:	4620      	mov	r0, r4
   211c2:	f7ff fe19 	bl	20df8 <TCPIP_Helper_SingleListHeadRemove>
   211c6:	4601      	mov	r1, r0
   211c8:	b118      	cbz	r0, 211d2 <TCPIP_Helper_SingleListAppend+0x18>
		TCPIP_Helper_SingleListTailAdd(pDstL, pN);
   211ca:	4628      	mov	r0, r5
   211cc:	f7ff ffe8 	bl	211a0 <TCPIP_Helper_SingleListTailAdd>
   211d0:	e7f6      	b.n	211c0 <TCPIP_Helper_SingleListAppend+0x6>
}
   211d2:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.TCPIP_STACK_NetIsReady%961:

000211d4 <TCPIP_STACK_NetIsReady>:
{
   211d4:	b508      	push	{r3, lr}
    TCPIP_NET_IF* pNetIf = _TCPIPStackHandleToNetLinked(netH);
   211d6:	f7ff fbfb 	bl	209d0 <_TCPIPStackHandleToNetLinked>
    if(pNetIf)
   211da:	b130      	cbz	r0, 211ea <TCPIP_STACK_NetIsReady+0x16>
        return _TCPIPStackIsConfig(pNetIf) == 0;
   211dc:	f890 0043 	ldrb.w	r0, [r0, #67]	; 0x43
   211e0:	f080 0010 	eor.w	r0, r0, #16
   211e4:	f3c0 1000 	ubfx	r0, r0, #4, #1
}
   211e8:	bd08      	pop	{r3, pc}
    return false;
   211ea:	2000      	movs	r0, #0
   211ec:	e7fc      	b.n	211e8 <TCPIP_STACK_NetIsReady+0x14>

Disassembly of section .text.TCPIP_Notification_RemoveAll%962:

000211ee <TCPIP_Notification_RemoveAll>:

void TCPIP_Notification_RemoveAll(PROTECTED_SINGLE_LIST* notifyList, TCPIP_STACK_HEAP_HANDLE heapH)
{
   211ee:	b538      	push	{r3, r4, r5, lr}
   211f0:	4605      	mov	r5, r0
   211f2:	460c      	mov	r4, r1
    SGL_LIST_NODE* dNode;

    while( (dNode = TCPIP_Helper_ProtectedSingleListHeadRemove(notifyList)) != 0 )
   211f4:	4628      	mov	r0, r5
   211f6:	f7fe fab3 	bl	1f760 <TCPIP_Helper_ProtectedSingleListHeadRemove>
   211fa:	4601      	mov	r1, r0
   211fc:	b118      	cbz	r0, 21206 <TCPIP_Notification_RemoveAll+0x18>
   211fe:	68e3      	ldr	r3, [r4, #12]
   21200:	4620      	mov	r0, r4
   21202:	4798      	blx	r3
   21204:	e7f6      	b.n	211f4 <TCPIP_Notification_RemoveAll+0x6>
    {
        TCPIP_HEAP_Free(heapH, dNode);
    }

}
   21206:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text._UDPTxPktValid%963:

00021208 <_UDPTxPktValid>:
{
   21208:	b508      	push	{r3, lr}
    switch(pSkt->addType)
   2120a:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
   2120c:	2b01      	cmp	r3, #1
   2120e:	d001      	beq.n	21214 <_UDPTxPktValid+0xc>
            return false;
   21210:	2000      	movs	r0, #0
}
   21212:	bd08      	pop	{r3, pc}
            return _TxSktGetLockedV4Pkt(pSkt, false) != 0;
   21214:	2100      	movs	r1, #0
   21216:	f7fe f9d9 	bl	1f5cc <_TxSktGetLockedV4Pkt>
   2121a:	3000      	adds	r0, #0
   2121c:	bf18      	it	ne
   2121e:	2001      	movne	r0, #1
   21220:	e7f7      	b.n	21212 <_UDPTxPktValid+0xa>

Disassembly of section .text.TCPIP_UDP_TxPointerGet%964:

00021222 <TCPIP_UDP_TxPointerGet>:
{
   21222:	b510      	push	{r4, lr}
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   21224:	f7fe fe5e 	bl	1fee4 <_UDPSocketDcpt>
    if(pSkt && _UDPTxPktValid(pSkt))
   21228:	4604      	mov	r4, r0
   2122a:	b118      	cbz	r0, 21234 <TCPIP_UDP_TxPointerGet+0x12>
   2122c:	f7ff ffec 	bl	21208 <_UDPTxPktValid>
   21230:	b110      	cbz	r0, 21238 <TCPIP_UDP_TxPointerGet+0x16>
        return pSkt->txWrite;
   21232:	68a4      	ldr	r4, [r4, #8]
}
   21234:	4620      	mov	r0, r4
   21236:	bd10      	pop	{r4, pc}
    return 0;
   21238:	2400      	movs	r4, #0
   2123a:	e7fb      	b.n	21234 <TCPIP_UDP_TxPointerGet+0x12>

Disassembly of section .text.wc_InitRng%965:

0002123c <wc_InitRng>:
{
   2123c:	b500      	push	{lr}
   2123e:	b083      	sub	sp, #12
    return _InitRng(rng, NULL, 0, NULL, INVALID_DEVID);
   21240:	f06f 0301 	mvn.w	r3, #1
   21244:	9300      	str	r3, [sp, #0]
   21246:	2300      	movs	r3, #0
   21248:	461a      	mov	r2, r3
   2124a:	4619      	mov	r1, r3
   2124c:	f7ef fa38 	bl	106c0 <_InitRng>
}
   21250:	b003      	add	sp, #12
   21252:	f85d fb04 	ldr.w	pc, [sp], #4

Disassembly of section .text.strchr%966:

00021256 <strchr>:
   21256:	b2c9      	uxtb	r1, r1
   21258:	4603      	mov	r3, r0
   2125a:	f810 2b01 	ldrb.w	r2, [r0], #1
   2125e:	b11a      	cbz	r2, 21268 <strchr+0x12>
   21260:	428a      	cmp	r2, r1
   21262:	d1f9      	bne.n	21258 <strchr+0x2>
   21264:	4618      	mov	r0, r3
   21266:	4770      	bx	lr
   21268:	2900      	cmp	r1, #0
   2126a:	bf18      	it	ne
   2126c:	2300      	movne	r3, #0
   2126e:	e7f9      	b.n	21264 <strchr+0xe>

Disassembly of section .text.__ascii_wctomb%967:

00021270 <__ascii_wctomb>:
   21270:	b149      	cbz	r1, 21286 <__ascii_wctomb+0x16>
   21272:	2aff      	cmp	r2, #255	; 0xff
   21274:	bf85      	ittet	hi
   21276:	238a      	movhi	r3, #138	; 0x8a
   21278:	6003      	strhi	r3, [r0, #0]
   2127a:	700a      	strbls	r2, [r1, #0]
   2127c:	f04f 30ff 	movhi.w	r0, #4294967295
   21280:	bf98      	it	ls
   21282:	2001      	movls	r0, #1
   21284:	4770      	bx	lr
   21286:	4608      	mov	r0, r1
   21288:	4770      	bx	lr

Disassembly of section .text.CRYPT_MD5_DataAdd%968:

0002128a <CRYPT_MD5_DataAdd>:


/* Add data to MD5 */
int CRYPT_MD5_DataAdd(CRYPT_MD5_CTX* md5, const unsigned char* input,
                      unsigned int sz)
{
   2128a:	b508      	push	{r3, lr}
    if (md5 == NULL || input == NULL)
   2128c:	b118      	cbz	r0, 21296 <CRYPT_MD5_DataAdd+0xc>
   2128e:	b129      	cbz	r1, 2129c <CRYPT_MD5_DataAdd+0x12>
        return BAD_FUNC_ARG;

    return wc_Md5Update((Md5*)md5, input, sz);
   21290:	f7f2 fde8 	bl	13e64 <wc_Md5Update>
}
   21294:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
   21296:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   2129a:	e7fb      	b.n	21294 <CRYPT_MD5_DataAdd+0xa>
   2129c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   212a0:	e7f8      	b.n	21294 <CRYPT_MD5_DataAdd+0xa>

Disassembly of section .text.CRYPT_MD5_Finalize%969:

000212a2 <CRYPT_MD5_Finalize>:


/* Get MD5 Final into digest */
int CRYPT_MD5_Finalize(CRYPT_MD5_CTX* md5, unsigned char* digest)
{
   212a2:	b508      	push	{r3, lr}
    if (md5 == NULL || digest == NULL)
   212a4:	b118      	cbz	r0, 212ae <CRYPT_MD5_Finalize+0xc>
   212a6:	b129      	cbz	r1, 212b4 <CRYPT_MD5_Finalize+0x12>
        return BAD_FUNC_ARG;

    return wc_Md5Final((Md5*)md5, digest);
   212a8:	f7f5 f9e4 	bl	16674 <wc_Md5Final>
}
   212ac:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
   212ae:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   212b2:	e7fb      	b.n	212ac <CRYPT_MD5_Finalize+0xa>
   212b4:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   212b8:	e7f8      	b.n	212ac <CRYPT_MD5_Finalize+0xa>

Disassembly of section .text.CRYPT_RNG_BlockGenerate%970:

000212ba <CRYPT_RNG_BlockGenerate>:


/* RNG Block Generation of sz bytes, < 0 on error */
int CRYPT_RNG_BlockGenerate(CRYPT_RNG_CTX* rng, unsigned char* b,
                            unsigned int sz)
{
   212ba:	b508      	push	{r3, lr}
    if (rng == NULL || b == NULL)
   212bc:	b118      	cbz	r0, 212c6 <CRYPT_RNG_BlockGenerate+0xc>
   212be:	b129      	cbz	r1, 212cc <CRYPT_RNG_BlockGenerate+0x12>
        return BAD_FUNC_ARG;

#if defined(WOLFSSL_MICROCHIP_SAME70)
    return same70_RNG_GenerateBlock(b, sz);
#else
    return wc_RNG_GenerateBlock((WC_RNG*)rng, b, sz);
   212c0:	f7f2 f810 	bl	132e4 <wc_RNG_GenerateBlock>
#endif
}
   212c4:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
   212c6:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   212ca:	e7fb      	b.n	212c4 <CRYPT_RNG_BlockGenerate+0xa>
   212cc:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   212d0:	e7f8      	b.n	212c4 <CRYPT_RNG_BlockGenerate+0xa>

Disassembly of section .text.DRV_ETHPHY_Deinitialize%971:

000212d4 <DRV_ETHPHY_Deinitialize>:
    return pPhyInst == gPhyDrvInst ? pPhyInst : 0;
   212d4:	4b04      	ldr	r3, [pc, #16]	; (212e8 <DRV_ETHPHY_Deinitialize+0x14>)
   212d6:	4283      	cmp	r3, r0
   212d8:	d104      	bne.n	212e4 <DRV_ETHPHY_Deinitialize+0x10>
    if(phyInst != 0)
   212da:	b118      	cbz	r0, 212e4 <DRV_ETHPHY_Deinitialize+0x10>
        phyInst->status  = SYS_STATUS_UNINITIALIZED;
   212dc:	2200      	movs	r2, #0
   212de:	711a      	strb	r2, [r3, #4]
        phyInst->objInUse  = false;
   212e0:	701a      	strb	r2, [r3, #0]
        phyInst->pPhyObj = 0;
   212e2:	615a      	str	r2, [r3, #20]
} 
   212e4:	4770      	bx	lr
   212e6:	bf00      	nop
   212e8:	2000e018 	.word	0x2000e018

Disassembly of section .text._DRV_ETHPHY_NegCompletePhaseResultNoWait%972:

000212ec <_DRV_ETHPHY_NegCompletePhaseResultNoWait>:
{
   212ec:	b510      	push	{r4, lr}
   212ee:	4604      	mov	r4, r0
    if(!_DRV_PHY_SMITransfer_Wait(hClientObj))
   212f0:	f7ff f9b8 	bl	20664 <_DRV_PHY_SMITransfer_Wait>
   212f4:	b900      	cbnz	r0, 212f8 <_DRV_ETHPHY_NegCompletePhaseResultNoWait+0xc>
}
   212f6:	bd10      	pop	{r4, pc}
    _DRV_PHY_NegCompleteSetOperResult(hClientObj, phyBMCon.w, phyStat.w);
   212f8:	8f62      	ldrh	r2, [r4, #58]	; 0x3a
   212fa:	8ca1      	ldrh	r1, [r4, #36]	; 0x24
   212fc:	4620      	mov	r0, r4
   212fe:	f7fd fd98 	bl	1ee32 <_DRV_PHY_NegCompleteSetOperResult>
   21302:	e7f8      	b.n	212f6 <_DRV_ETHPHY_NegCompletePhaseResultNoWait+0xa>

Disassembly of section .text._DRV_ETHPHY_SetupPhaseNegotiate_SubPhase5%973:

00021304 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase5>:
{
   21304:	b510      	push	{r4, lr}
   21306:	4604      	mov	r4, r0
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   21308:	2101      	movs	r1, #1
   2130a:	f7fd fd15 	bl	1ed38 <_DRV_PHY_SMIReadStart>
   2130e:	b900      	cbnz	r0, 21312 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase5+0xe>
}
   21310:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   21312:	2303      	movs	r3, #3
   21314:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   21316:	2306      	movs	r3, #6
   21318:	8423      	strh	r3, [r4, #32]
}
   2131a:	e7f9      	b.n	21310 <_DRV_ETHPHY_SetupPhaseNegotiate_SubPhase5+0xc>

Disassembly of section .text._DRV_ETHPHY_LinkStatPhaseIdle%974:

0002131c <_DRV_ETHPHY_LinkStatPhaseIdle>:
{
   2131c:	b510      	push	{r4, lr}
   2131e:	4604      	mov	r4, r0
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   21320:	2101      	movs	r1, #1
   21322:	f7fd fd09 	bl	1ed38 <_DRV_PHY_SMIReadStart>
   21326:	b900      	cbnz	r0, 2132a <_DRV_ETHPHY_LinkStatPhaseIdle+0xe>
}
   21328:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   2132a:	2301      	movs	r3, #1
   2132c:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   2132e:	2300      	movs	r3, #0
   21330:	8423      	strh	r3, [r4, #32]
}
   21332:	e7f9      	b.n	21328 <_DRV_ETHPHY_LinkStatPhaseIdle+0xc>

Disassembly of section .text._DRV_ETHPHY_NegCompletePhaseIdle%975:

00021334 <_DRV_ETHPHY_NegCompletePhaseIdle>:
{
   21334:	b510      	push	{r4, lr}
   21336:	4604      	mov	r4, r0
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMCON))
   21338:	2100      	movs	r1, #0
   2133a:	f7fd fcfd 	bl	1ed38 <_DRV_PHY_SMIReadStart>
   2133e:	b900      	cbnz	r0, 21342 <_DRV_ETHPHY_NegCompletePhaseIdle+0xe>
}
   21340:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   21342:	2301      	movs	r3, #1
   21344:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   21346:	2300      	movs	r3, #0
   21348:	8423      	strh	r3, [r4, #32]
}
   2134a:	e7f9      	b.n	21340 <_DRV_ETHPHY_NegCompletePhaseIdle+0xc>

Disassembly of section .text._DRV_ETHPHY_NegResultPhaseIdle%976:

0002134c <_DRV_ETHPHY_NegResultPhaseIdle>:
{
   2134c:	b510      	push	{r4, lr}
   2134e:	4604      	mov	r4, r0
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   21350:	2101      	movs	r1, #1
   21352:	f7fd fcf1 	bl	1ed38 <_DRV_PHY_SMIReadStart>
   21356:	b900      	cbnz	r0, 2135a <_DRV_ETHPHY_NegResultPhaseIdle+0xe>
}
   21358:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   2135a:	2301      	movs	r3, #1
   2135c:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   2135e:	2300      	movs	r3, #0
   21360:	8423      	strh	r3, [r4, #32]
}
   21362:	e7f9      	b.n	21358 <_DRV_ETHPHY_NegResultPhaseIdle+0xc>

Disassembly of section .text._DRV_ETHPHY_NegRestartPhaseIdle%977:

00021364 <_DRV_ETHPHY_NegRestartPhaseIdle>:
{
   21364:	b510      	push	{r4, lr}
   21366:	4604      	mov	r4, r0
    if(_DRV_PHY_SMIReadStart(hClientObj, PHY_REG_BMSTAT))
   21368:	2101      	movs	r1, #1
   2136a:	f7fd fce5 	bl	1ed38 <_DRV_PHY_SMIReadStart>
   2136e:	b900      	cbnz	r0, 21372 <_DRV_ETHPHY_NegRestartPhaseIdle+0xe>
}
   21370:	bd10      	pop	{r4, pc}
    hClientObj->operPhase = operPhase;
   21372:	2301      	movs	r3, #1
   21374:	83e3      	strh	r3, [r4, #30]
    hClientObj->operSubPhase = operSubPhase;
   21376:	2300      	movs	r3, #0
   21378:	8423      	strh	r3, [r4, #32]
}
   2137a:	e7f9      	b.n	21370 <_DRV_ETHPHY_NegRestartPhaseIdle+0xc>

Disassembly of section .rodata._DRV_PHY_NegCompletePhasesTbl%978:

0002137c <_DRV_PHY_NegCompletePhasesTbl>:
   2137c:	1335 0002 e6e5 0001 ca51 0001 12ed 0002     5.......Q.......
   2138c:	bc9f 0001 dd8b 0001                         ........

Disassembly of section .text.DRV_PIC32CGMAC_SingleListHeadAdd%979:

00021394 <DRV_PIC32CGMAC_SingleListHeadAdd>:
	if(pN)
   21394:	b131      	cbz	r1, 213a4 <DRV_PIC32CGMAC_SingleListHeadAdd+0x10>
		if(pL->head == 0)
   21396:	6802      	ldr	r2, [r0, #0]
   21398:	b12a      	cbz	r2, 213a6 <DRV_PIC32CGMAC_SingleListHeadAdd+0x12>
			pN->next = pL->head;
   2139a:	600a      	str	r2, [r1, #0]
			pL->head = pN;
   2139c:	6001      	str	r1, [r0, #0]
		pL->nNodes++;
   2139e:	6883      	ldr	r3, [r0, #8]
   213a0:	3301      	adds	r3, #1
   213a2:	6083      	str	r3, [r0, #8]
}
   213a4:	4770      	bx	lr
			pL->head = pL->tail = pN;
   213a6:	6041      	str	r1, [r0, #4]
   213a8:	6001      	str	r1, [r0, #0]
   213aa:	e7f8      	b.n	2139e <DRV_PIC32CGMAC_SingleListHeadAdd+0xa>

Disassembly of section .text.DRV_PIC32CGMAC_LibSysInt_Restore%980:

000213ac <DRV_PIC32CGMAC_LibSysInt_Restore>:
    if(queMask & GMAC_QUE0_MASK)
   213ac:	f011 0f01 	tst.w	r1, #1
   213b0:	d007      	beq.n	213c2 <DRV_PIC32CGMAC_LibSysInt_Restore+0x16>
        if(queStat)
   213b2:	b132      	cbz	r2, 213c2 <DRV_PIC32CGMAC_LibSysInt_Restore+0x16>
{
   213b4:	b508      	push	{r3, lr}
            SYS_INT_SourceRestore(pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc, queStat[GMAC_QUE_0]); 
   213b6:	7811      	ldrb	r1, [r2, #0]
   213b8:	f9b0 00b6 	ldrsh.w	r0, [r0, #182]	; 0xb6
   213bc:	f7ff fb68 	bl	20a90 <SYS_INT_SourceRestore>
}
   213c0:	bd08      	pop	{r3, pc}
   213c2:	4770      	bx	lr

Disassembly of section .text.DRV_MIIM_Close%981:

000213c4 <DRV_MIIM_Close>:
{
   213c4:	b510      	push	{r4, lr}
    DRV_MIIM_CLIENT_DCPT * pClient = _DRV_MIIM_GetClientAndLock(handle, true);
   213c6:	2101      	movs	r1, #1
   213c8:	f7fb f8bf 	bl	1c54a <_DRV_MIIM_GetClientAndLock>
    if(pClient != 0)
   213cc:	b128      	cbz	r0, 213da <DRV_MIIM_Close+0x16>
   213ce:	4604      	mov	r4, r0
        _DRV_MIIM_ClientDeallocate(pClient);
   213d0:	f7f4 fe0a 	bl	15fe8 <_DRV_MIIM_ClientDeallocate>
    OSAL_SEM_Post(&pMiimObj->objSem);
   213d4:	6860      	ldr	r0, [r4, #4]
   213d6:	f000 f86d 	bl	214b4 <OSAL_SEM_Post>
}
   213da:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_ARP_HashKeyHash%982:

000213dc <TCPIP_ARP_HashKeyHash>:
{
   213dc:	b510      	push	{r4, lr}
   213de:	4604      	mov	r4, r0
   213e0:	4608      	mov	r0, r1
    return fnv_32_hash(key, sizeof(((ARP_HASH_ENTRY*)0)->ipAddress)) % (pOH->hEntries);
   213e2:	2104      	movs	r1, #4
   213e4:	f7fd fe16 	bl	1f014 <fnv_32_hash>
   213e8:	68e3      	ldr	r3, [r4, #12]
   213ea:	fbb0 f2f3 	udiv	r2, r0, r3
}
   213ee:	fb02 0013 	mls	r0, r2, r3, r0
   213f2:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_OAHASH_EntryRemove%983:

000213f4 <TCPIP_OAHASH_EntryRemove>:
    if(pOE->flags.busy)
   213f4:	780b      	ldrb	r3, [r1, #0]
   213f6:	f013 0f01 	tst.w	r3, #1
   213fa:	d006      	beq.n	2140a <TCPIP_OAHASH_EntryRemove+0x16>
        pOE->flags.busy = 0;
   213fc:	780b      	ldrb	r3, [r1, #0]
   213fe:	f36f 0300 	bfc	r3, #0, #1
   21402:	700b      	strb	r3, [r1, #0]
        pOH->fullSlots--;
   21404:	6a43      	ldr	r3, [r0, #36]	; 0x24
   21406:	3b01      	subs	r3, #1
   21408:	6243      	str	r3, [r0, #36]	; 0x24
}
   2140a:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressGateway%984:

0002140c <TCPIP_STACK_NetAddressGateway>:
   2140c:	b140      	cbz	r0, 21420 <TCPIP_STACK_NetAddressGateway+0x14>
   2140e:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   21412:	f012 0f40 	tst.w	r2, #64	; 0x40
   21416:	d101      	bne.n	2141c <TCPIP_STACK_NetAddressGateway+0x10>
    return 0;
   21418:	2000      	movs	r0, #0
}
   2141a:	4770      	bx	lr
        return pNetIf->netGateway.Val;
   2141c:	68c0      	ldr	r0, [r0, #12]
   2141e:	4770      	bx	lr
    return 0;
   21420:	2000      	movs	r0, #0
   21422:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressDnsPrimary%985:

00021424 <TCPIP_STACK_NetAddressDnsPrimary>:
   21424:	b140      	cbz	r0, 21438 <TCPIP_STACK_NetAddressDnsPrimary+0x14>
   21426:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   2142a:	f012 0f40 	tst.w	r2, #64	; 0x40
   2142e:	d101      	bne.n	21434 <TCPIP_STACK_NetAddressDnsPrimary+0x10>
    return 0;
   21430:	2000      	movs	r0, #0
}
   21432:	4770      	bx	lr
        return pNetIf->dnsServer[0].Val;
   21434:	6900      	ldr	r0, [r0, #16]
   21436:	4770      	bx	lr
    return 0;
   21438:	2000      	movs	r0, #0
   2143a:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressDnsSecond%986:

0002143c <TCPIP_STACK_NetAddressDnsSecond>:
   2143c:	b140      	cbz	r0, 21450 <TCPIP_STACK_NetAddressDnsSecond+0x14>
   2143e:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   21442:	f012 0f40 	tst.w	r2, #64	; 0x40
   21446:	d101      	bne.n	2144c <TCPIP_STACK_NetAddressDnsSecond+0x10>
    return 0;
   21448:	2000      	movs	r0, #0
}
   2144a:	4770      	bx	lr
        return pNetIf->dnsServer[1].Val;
   2144c:	6940      	ldr	r0, [r0, #20]
   2144e:	4770      	bx	lr
    return 0;
   21450:	2000      	movs	r0, #0
   21452:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressGet%987:

00021454 <TCPIP_STACK_NetAddressGet>:
   21454:	b140      	cbz	r0, 21468 <TCPIP_STACK_NetAddressGet+0x14>
   21456:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   2145a:	f012 0f40 	tst.w	r2, #64	; 0x40
   2145e:	d101      	bne.n	21464 <TCPIP_STACK_NetAddressGet+0x10>
    return 0;
   21460:	2000      	movs	r0, #0
}
   21462:	4770      	bx	lr
    return pNetIf->netIPAddr.Val;
   21464:	6840      	ldr	r0, [r0, #4]
        return _TCPIPStackNetAddress(pNetIf);
   21466:	4770      	bx	lr
    return 0;
   21468:	2000      	movs	r0, #0
   2146a:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetMaskGet%988:

0002146c <TCPIP_STACK_NetMaskGet>:
    if(pNetIf && pNetIf->Flags.bInterfaceEnabled)
   2146c:	b140      	cbz	r0, 21480 <TCPIP_STACK_NetMaskGet+0x14>
   2146e:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   21472:	f012 0f40 	tst.w	r2, #64	; 0x40
   21476:	d101      	bne.n	2147c <TCPIP_STACK_NetMaskGet+0x10>
    return 0;
   21478:	2000      	movs	r0, #0
}
   2147a:	4770      	bx	lr
        return pNetIf->netMask.Val;
   2147c:	6880      	ldr	r0, [r0, #8]
   2147e:	4770      	bx	lr
    return 0;
   21480:	2000      	movs	r0, #0
   21482:	4770      	bx	lr

Disassembly of section .rodata.TCPIP_FRAME_PROCESS_TBL%989:

00021484 <TCPIP_FRAME_PROCESS_TBL>:
   21484:	0806 0100 0002 0800 0000 0003 ffff 0000     ................
   21494:	0004 ffff 0000 0005                         ........

Disassembly of section .text.OSAL_CRIT_Enter%990:

0002149c <OSAL_CRIT_Enter>:
{
   2149c:	b508      	push	{r3, lr}
  switch (severity)
   2149e:	b118      	cbz	r0, 214a8 <OSAL_CRIT_Enter+0xc>
   214a0:	2801      	cmp	r0, #1
   214a2:	d004      	beq.n	214ae <OSAL_CRIT_Enter+0x12>
}
   214a4:	2000      	movs	r0, #0
   214a6:	bd08      	pop	{r3, pc}
      vTaskSuspendAll();
   214a8:	f000 fb38 	bl	21b1c <vTaskSuspendAll>
      break;
   214ac:	e7fa      	b.n	214a4 <OSAL_CRIT_Enter+0x8>
      portENTER_CRITICAL();
   214ae:	f7ff fb2f 	bl	20b10 <vPortEnterCritical>
      break;
   214b2:	e7f7      	b.n	214a4 <OSAL_CRIT_Enter+0x8>

Disassembly of section .text.OSAL_SEM_Post%991:

000214b4 <OSAL_SEM_Post>:
{
   214b4:	b508      	push	{r3, lr}
  if (xSemaphoreGive(*(SemaphoreHandle_t*)semID) == pdTRUE)
   214b6:	2300      	movs	r3, #0
   214b8:	461a      	mov	r2, r3
   214ba:	4619      	mov	r1, r3
   214bc:	6800      	ldr	r0, [r0, #0]
   214be:	f7f1 fa93 	bl	129e8 <xQueueGenericSend>
}
   214c2:	2801      	cmp	r0, #1
   214c4:	bf14      	ite	ne
   214c6:	2000      	movne	r0, #0
   214c8:	2001      	moveq	r0, #1
   214ca:	bd08      	pop	{r3, pc}

Disassembly of section .text.OSAL_MUTEX_Create%992:

000214cc <OSAL_MUTEX_Create>:
  if (*(SemaphoreHandle_t*)mutexID != NULL)
   214cc:	6803      	ldr	r3, [r0, #0]
   214ce:	b10b      	cbz	r3, 214d4 <OSAL_MUTEX_Create+0x8>
    return OSAL_RESULT_FALSE;
   214d0:	2000      	movs	r0, #0
}
   214d2:	4770      	bx	lr
{
   214d4:	b510      	push	{r4, lr}
   214d6:	4604      	mov	r4, r0
  *(SemaphoreHandle_t*)mutexID = xSemaphoreCreateMutex();
   214d8:	2001      	movs	r0, #1
   214da:	f7fe fffd 	bl	204d8 <xQueueCreateMutex>
   214de:	6020      	str	r0, [r4, #0]
  return OSAL_RESULT_TRUE;
   214e0:	2001      	movs	r0, #1
}
   214e2:	bd10      	pop	{r4, pc}

Disassembly of section .text.OSAL_MUTEX_Unlock%993:

000214e4 <OSAL_MUTEX_Unlock>:

  Remarks:

 */
OSAL_RESULT OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE* mutexID)
{
   214e4:	b508      	push	{r3, lr}
  if (xSemaphoreGive(*(SemaphoreHandle_t*)mutexID) == pdTRUE)
   214e6:	2300      	movs	r3, #0
   214e8:	461a      	mov	r2, r3
   214ea:	4619      	mov	r1, r3
   214ec:	6800      	ldr	r0, [r0, #0]
   214ee:	f7f1 fa7b 	bl	129e8 <xQueueGenericSend>
  {
    return OSAL_RESULT_TRUE;
  }

  return OSAL_RESULT_FALSE;
}
   214f2:	2801      	cmp	r0, #1
   214f4:	bf14      	ite	ne
   214f6:	2000      	movne	r0, #0
   214f8:	2001      	moveq	r0, #1
   214fa:	bd08      	pop	{r3, pc}

Disassembly of section .text.SERCOM1_USART_WritePendingBytesGet%994:

000214fc <SERCOM1_USART_WritePendingBytesGet>:
    uint32_t wrInIndex = sercom1USARTObj.wrInIndex;
   214fc:	4a04      	ldr	r2, [pc, #16]	; (21510 <SERCOM1_USART_WritePendingBytesGet+0x14>)
   214fe:	6893      	ldr	r3, [r2, #8]
    uint32_t wrOutIndex = sercom1USARTObj.wrOutIndex;
   21500:	68d0      	ldr	r0, [r2, #12]
    if ( wrInIndex >= wrOutIndex)
   21502:	4283      	cmp	r3, r0
        nPendingTxBytes =  (sercom1USARTObj.wrBufferSize -  wrOutIndex) + wrInIndex;
   21504:	bf3e      	ittt	cc
   21506:	4a02      	ldrcc	r2, [pc, #8]	; (21510 <SERCOM1_USART_WritePendingBytesGet+0x14>)
   21508:	6912      	ldrcc	r2, [r2, #16]
   2150a:	189b      	addcc	r3, r3, r2
   2150c:	1a18      	subs	r0, r3, r0
}
   2150e:	4770      	bx	lr
   21510:	2000e1f0 	.word	0x2000e1f0

Disassembly of section .text.SERCOM1_USART_ReadCountGet%995:

00021514 <SERCOM1_USART_ReadCountGet>:
    rdOutIndex = sercom1USARTObj.rdOutIndex;
   21514:	4b04      	ldr	r3, [pc, #16]	; (21528 <SERCOM1_USART_ReadCountGet+0x14>)
   21516:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    rdInIndex = sercom1USARTObj.rdInIndex;
   21518:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    if ( rdInIndex >=  rdOutIndex)
   2151a:	4298      	cmp	r0, r3
        nUnreadBytesAvailable =  (sercom1USARTObj.rdBufferSize -  rdOutIndex) + rdInIndex;
   2151c:	bf82      	ittt	hi
   2151e:	4a02      	ldrhi	r2, [pc, #8]	; (21528 <SERCOM1_USART_ReadCountGet+0x14>)
   21520:	6b12      	ldrhi	r2, [r2, #48]	; 0x30
   21522:	189b      	addhi	r3, r3, r2
   21524:	1a18      	subs	r0, r3, r0
}
   21526:	4770      	bx	lr
   21528:	2000e1f0 	.word	0x2000e1f0

Disassembly of section .text.TC0_TimerStart%996:

0002152c <TC0_TimerStart>:
    TC0_REGS->COUNT16.TC_CTRLA |= TC_CTRLA_ENABLE_Msk;
   2152c:	4a04      	ldr	r2, [pc, #16]	; (21540 <TC0_TimerStart+0x14>)
   2152e:	6813      	ldr	r3, [r2, #0]
   21530:	f043 0302 	orr.w	r3, r3, #2
   21534:	6013      	str	r3, [r2, #0]
    while((TC0_REGS->COUNT16.TC_SYNCBUSY & TC_SYNCBUSY_ENABLE_Msk) == TC_SYNCBUSY_ENABLE_Msk)
   21536:	6913      	ldr	r3, [r2, #16]
   21538:	f013 0f02 	tst.w	r3, #2
   2153c:	d1fb      	bne.n	21536 <TC0_TimerStart+0xa>
}
   2153e:	4770      	bx	lr
   21540:	40003800 	.word	0x40003800

Disassembly of section .text.TC0_TimerStop%997:

00021544 <TC0_TimerStop>:
    TC0_REGS->COUNT16.TC_CTRLA &= ~TC_CTRLA_ENABLE_Msk;
   21544:	4a04      	ldr	r2, [pc, #16]	; (21558 <TC0_TimerStop+0x14>)
   21546:	6813      	ldr	r3, [r2, #0]
   21548:	f023 0302 	bic.w	r3, r3, #2
   2154c:	6013      	str	r3, [r2, #0]
    while((TC0_REGS->COUNT16.TC_SYNCBUSY & TC_SYNCBUSY_ENABLE_Msk) == TC_SYNCBUSY_ENABLE_Msk)
   2154e:	6913      	ldr	r3, [r2, #16]
   21550:	f013 0f02 	tst.w	r3, #2
   21554:	d1fb      	bne.n	2154e <TC0_TimerStop+0xa>
}
   21556:	4770      	bx	lr
   21558:	40003800 	.word	0x40003800

Disassembly of section .text._keyDownProcess%998:

0002155c <_keyDownProcess>:
{   // down arrow
   2155c:	b508      	push	{r3, lr}
    if(pCmdIO->currHistN)
   2155e:	f8d0 30d4 	ldr.w	r3, [r0, #212]	; 0xd4
   21562:	b133      	cbz	r3, 21572 <_keyDownProcess+0x16>
        pNext = pCmdIO->currHistN->prev;
   21564:	6859      	ldr	r1, [r3, #4]
        if(pNext != pCmdIO->histList.tail)
   21566:	f8d0 30d0 	ldr.w	r3, [r0, #208]	; 0xd0
   2156a:	428b      	cmp	r3, r1
   2156c:	d001      	beq.n	21572 <_keyDownProcess+0x16>
            DisplayNodeMsg(pCmdIO, pNext);
   2156e:	f7f6 fd17 	bl	17fa0 <DisplayNodeMsg>
}
   21572:	bd08      	pop	{r3, pc}

Disassembly of section .text.CommandReset%999:

00021574 <CommandReset>:
{
   21574:	b508      	push	{r3, lr}
    (*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM " *** System Reboot ***\r\n" );
   21576:	6803      	ldr	r3, [r0, #0]
   21578:	681b      	ldr	r3, [r3, #0]
   2157a:	4903      	ldr	r1, [pc, #12]	; (21588 <CommandReset+0x14>)
   2157c:	6840      	ldr	r0, [r0, #4]
   2157e:	4798      	blx	r3
    SYS_RESET_SoftwareReset();
   21580:	f7fe ff5e 	bl	20440 <SYS_RESET_SoftwareReset>
}
   21584:	bd08      	pop	{r3, pc}
   21586:	bf00      	nop
   21588:	0000d1f8 	.word	0x0000d1f8

Disassembly of section .text._SYS_RANDOM_CryptoContext%1000:

0002158c <_SYS_RANDOM_CryptoContext>:
{
   2158c:	b508      	push	{r3, lr}
    if(pRandCtx == 0)
   2158e:	4b04      	ldr	r3, [pc, #16]	; (215a0 <_SYS_RANDOM_CryptoContext+0x14>)
   21590:	681b      	ldr	r3, [r3, #0]
   21592:	b113      	cbz	r3, 2159a <_SYS_RANDOM_CryptoContext+0xe>
} 
   21594:	4b02      	ldr	r3, [pc, #8]	; (215a0 <_SYS_RANDOM_CryptoContext+0x14>)
   21596:	6818      	ldr	r0, [r3, #0]
   21598:	bd08      	pop	{r3, pc}
        SYS_RANDOM_CryptoInitialize();
   2159a:	f7ff fa89 	bl	20ab0 <SYS_RANDOM_CryptoInitialize>
   2159e:	e7f9      	b.n	21594 <_SYS_RANDOM_CryptoContext+0x8>
   215a0:	2000e68c 	.word	0x2000e68c

Disassembly of section .text._TCPIP_STACK_Task%1001:

000215a4 <_TCPIP_STACK_Task>:
{
   215a4:	b508      	push	{r3, lr}
        TCPIP_STACK_Task(sysObj.tcpip);
   215a6:	4d04      	ldr	r5, [pc, #16]	; (215b8 <_TCPIP_STACK_Task+0x14>)
        vTaskDelay(1 / portTICK_PERIOD_MS);
   215a8:	2401      	movs	r4, #1
        TCPIP_STACK_Task(sysObj.tcpip);
   215aa:	68a8      	ldr	r0, [r5, #8]
   215ac:	f7e4 ff72 	bl	6494 <TCPIP_STACK_Task>
        vTaskDelay(1 / portTICK_PERIOD_MS);
   215b0:	4620      	mov	r0, r4
   215b2:	f7fd fb0b 	bl	1ebcc <vTaskDelay>
   215b6:	e7f8      	b.n	215aa <_TCPIP_STACK_Task+0x6>
   215b8:	2000e464 	.word	0x2000e464

Disassembly of section .text._DRV_MIIM_Task%1002:

000215bc <_DRV_MIIM_Task>:
{
   215bc:	b508      	push	{r3, lr}
        DRV_MIIM_Tasks(sysObj.drvMiim);
   215be:	4d04      	ldr	r5, [pc, #16]	; (215d0 <_DRV_MIIM_Task+0x14>)
        vTaskDelay(1 / portTICK_PERIOD_MS);
   215c0:	2401      	movs	r4, #1
        DRV_MIIM_Tasks(sysObj.drvMiim);
   215c2:	68e8      	ldr	r0, [r5, #12]
   215c4:	f7f0 f8f4 	bl	117b0 <DRV_MIIM_Tasks>
        vTaskDelay(1 / portTICK_PERIOD_MS);
   215c8:	4620      	mov	r0, r4
   215ca:	f7fd faff 	bl	1ebcc <vTaskDelay>
   215ce:	e7f8      	b.n	215c2 <_DRV_MIIM_Task+0x6>
   215d0:	2000e464 	.word	0x2000e464

Disassembly of section .rodata.sysConsole0UARTPlibAPI%1003:

000215d4 <sysConsole0UARTPlibAPI>:
   215d4:	00019a99 00021515 00021835 000170b5     ........5....p..
   215e4:	0002208b 00021849                       . ..I...

Disassembly of section .rodata.tcpipDNSClientInitData%1004:

000215ec <tcpipDNSClientInitData>:
   215ec:	00000001 00000005 00000000 00000005     ................
   215fc:	00000001 00000001                       ........

Disassembly of section .text.vTaskInternalSetTimeOutState%1005:

00021604 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
   21604:	4b03      	ldr	r3, [pc, #12]	; (21614 <vTaskInternalSetTimeOutState+0x10>)
   21606:	681b      	ldr	r3, [r3, #0]
   21608:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   2160a:	4b03      	ldr	r3, [pc, #12]	; (21618 <vTaskInternalSetTimeOutState+0x14>)
   2160c:	681b      	ldr	r3, [r3, #0]
   2160e:	6043      	str	r3, [r0, #4]
}
   21610:	4770      	bx	lr
   21612:	bf00      	nop
   21614:	2000e6cc 	.word	0x2000e6cc
   21618:	2000e6d8 	.word	0x2000e6d8

Disassembly of section .rodata.__func__.10049%1006:

0002161c <__func__.10049>:
   2161c:	5f786667 6f6e6f6d 6172645f 74735f77     gfx_mono_draw_st
   2162c:	676e6972 00006e5f                       ring_n..

Disassembly of section .text.DRV_MIIM_ClientStatus%1007:

00021634 <DRV_MIIM_ClientStatus>:
{
   21634:	b508      	push	{r3, lr}
    DRV_MIIM_CLIENT_DCPT * pClient = _DRV_MIIM_GetClientAndLock(handle, false);
   21636:	2100      	movs	r1, #0
   21638:	f7fa ff87 	bl	1c54a <_DRV_MIIM_GetClientAndLock>
    if(pClient == 0)
   2163c:	b110      	cbz	r0, 21644 <DRV_MIIM_ClientStatus+0x10>
    return pClient->cliStatus; 
   2163e:	f990 000c 	ldrsb.w	r0, [r0, #12]
}
   21642:	bd08      	pop	{r3, pc}
        return DRV_MIIM_CLIENT_STATUS_ERROR;
   21644:	f04f 30ff 	mov.w	r0, #4294967295
   21648:	e7fb      	b.n	21642 <DRV_MIIM_ClientStatus+0xe>

Disassembly of section .text.TCPIP_TCP_WasDisconnected%1008:

0002164a <TCPIP_TCP_WasDisconnected>:
{
   2164a:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   2164c:	f7fe fb32 	bl	1fcb4 <_TcpSocketChk>
    if(pSkt)
   21650:	b120      	cbz	r0, 2165c <TCPIP_TCP_WasDisconnected+0x12>
        return pSkt->Flags.bRxFin != 0;
   21652:	f890 0037 	ldrb.w	r0, [r0, #55]	; 0x37
   21656:	f3c0 0080 	ubfx	r0, r0, #2, #1
}
   2165a:	bd08      	pop	{r3, pc}
    return false;
   2165c:	2000      	movs	r0, #0
   2165e:	e7fc      	b.n	2165a <TCPIP_TCP_WasDisconnected+0x10>

Disassembly of section .text._IperfUDPRxSignalHandler%1009:

00021660 <_IperfUDPRxSignalHandler>:
    if(sigType == TCPIP_UDP_SIGNAL_RX_DATA)
   21660:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
   21664:	d000      	beq.n	21668 <_IperfUDPRxSignalHandler+0x8>
   21666:	4770      	bx	lr
{
   21668:	b508      	push	{r3, lr}
        _TCPIPStackModuleSignalRequest(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_RX_PENDING, true); 
   2166a:	2201      	movs	r2, #1
   2166c:	4611      	mov	r1, r2
   2166e:	2020      	movs	r0, #32
   21670:	f7fa fa3c 	bl	1baec <_TCPIPStackModuleSignalRequest>
}
   21674:	bd08      	pop	{r3, pc}

Disassembly of section .text._IperfTCPRxSignalHandler%1010:

00021676 <_IperfTCPRxSignalHandler>:
    if(sigType == TCPIP_TCP_SIGNAL_RX_DATA)
   21676:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
   2167a:	d000      	beq.n	2167e <_IperfTCPRxSignalHandler+0x8>
   2167c:	4770      	bx	lr
{
   2167e:	b508      	push	{r3, lr}
        _TCPIPStackModuleSignalRequest(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_RX_PENDING, true); 
   21680:	2201      	movs	r2, #1
   21682:	4611      	mov	r1, r2
   21684:	2020      	movs	r0, #32
   21686:	f7fa fa31 	bl	1baec <_TCPIPStackModuleSignalRequest>
}
   2168a:	bd08      	pop	{r3, pc}

Disassembly of section .text._TCPIP_HEAP_LastError%1011:

0002168c <_TCPIP_HEAP_LastError>:
    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   2168c:	4603      	mov	r3, r0
   2168e:	b128      	cbz	r0, 2169c <_TCPIP_HEAP_LastError+0x10>

    hDcpt = _TCPIP_HEAP_ObjDcpt(heapH);

    if(hDcpt)
    {
        res = hDcpt->_lastHeapErr;
   21690:	f990 0038 	ldrsb.w	r0, [r0, #56]	; 0x38
        hDcpt->_lastHeapErr = TCPIP_STACK_HEAP_RES_OK;
   21694:	2200      	movs	r2, #0
   21696:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
        return res;
   2169a:	4770      	bx	lr
    }

    return TCPIP_STACK_HEAP_RES_NO_HEAP;
   2169c:	f06f 0008 	mvn.w	r0, #8

}
   216a0:	4770      	bx	lr

Disassembly of section .text._DHCPSocketRxSignalHandler%1012:

000216a2 <_DHCPSocketRxSignalHandler>:
    if(sigType == TCPIP_UDP_SIGNAL_RX_DATA)
   216a2:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
   216a6:	d000      	beq.n	216aa <_DHCPSocketRxSignalHandler+0x8>
   216a8:	4770      	bx	lr
{
   216aa:	b508      	push	{r3, lr}
        _TCPIPStackModuleSignalRequest(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_RX_PENDING, true); 
   216ac:	2201      	movs	r2, #1
   216ae:	4611      	mov	r1, r2
   216b0:	200c      	movs	r0, #12
   216b2:	f7fa fa1b 	bl	1baec <_TCPIPStackModuleSignalRequest>
}
   216b6:	bd08      	pop	{r3, pc}

Disassembly of section .text._DNSSocketRxSignalHandler%1013:

000216b8 <_DNSSocketRxSignalHandler>:
    if(sigType == TCPIP_UDP_SIGNAL_RX_DATA)
   216b8:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
   216bc:	d000      	beq.n	216c0 <_DNSSocketRxSignalHandler+0x8>
   216be:	4770      	bx	lr
{
   216c0:	b508      	push	{r3, lr}
        _TCPIPStackModuleSignalRequest(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_RX_PENDING, true); 
   216c2:	2201      	movs	r2, #1
   216c4:	4611      	mov	r1, r2
   216c6:	200f      	movs	r0, #15
   216c8:	f7fa fa10 	bl	1baec <_TCPIPStackModuleSignalRequest>
}
   216cc:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_STACK_AddressServiceCanStart%1014:

000216ce <TCPIP_STACK_AddressServiceCanStart>:
    if(pNetIf)
   216ce:	b138      	cbz	r0, 216e0 <TCPIP_STACK_AddressServiceCanStart+0x12>
        return (pNetIf->Flags.v & TCPIP_STACK_ADDRESS_SERVICE_MASK) == TCPIP_STACK_ADDRESS_SERVICE_NONE;
   216d0:	f8b0 3042 	ldrh.w	r3, [r0, #66]	; 0x42
   216d4:	f013 0f07 	tst.w	r3, #7
   216d8:	bf0c      	ite	eq
   216da:	2001      	moveq	r0, #1
   216dc:	2000      	movne	r0, #0
   216de:	4770      	bx	lr
    return false;
   216e0:	2000      	movs	r0, #0
}
   216e2:	4770      	bx	lr

Disassembly of section .text._TCPIPStackPacketTx%1015:

000216e4 <_TCPIPStackPacketTx>:
    return pNetIf->hIfMac != 0 ? (*pNetIf->pMacObj->TCPIP_MAC_PacketTx)(pNetIf->hIfMac, ptrPacket) : TCPIP_MAC_RES_NOT_READY_ERR;
   216e4:	6d02      	ldr	r2, [r0, #80]	; 0x50
   216e6:	b12a      	cbz	r2, 216f4 <_TCPIPStackPacketTx+0x10>
{
   216e8:	b508      	push	{r3, lr}
    return pNetIf->hIfMac != 0 ? (*pNetIf->pMacObj->TCPIP_MAC_PacketTx)(pNetIf->hIfMac, ptrPacket) : TCPIP_MAC_RES_NOT_READY_ERR;
   216ea:	6c43      	ldr	r3, [r0, #68]	; 0x44
   216ec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   216ee:	4610      	mov	r0, r2
   216f0:	4798      	blx	r3
}
   216f2:	bd08      	pop	{r3, pc}
    return pNetIf->hIfMac != 0 ? (*pNetIf->pMacObj->TCPIP_MAC_PacketTx)(pNetIf->hIfMac, ptrPacket) : TCPIP_MAC_RES_NOT_READY_ERR;
   216f4:	f06f 000c 	mvn.w	r0, #12
}
   216f8:	4770      	bx	lr

Disassembly of section .text.OSAL_CRIT_Leave%1016:

000216fa <OSAL_CRIT_Leave>:
{
   216fa:	b508      	push	{r3, lr}
  switch (severity)
   216fc:	b110      	cbz	r0, 21704 <OSAL_CRIT_Leave+0xa>
   216fe:	2801      	cmp	r0, #1
   21700:	d003      	beq.n	2170a <OSAL_CRIT_Leave+0x10>
}
   21702:	bd08      	pop	{r3, pc}
      xTaskResumeAll();
   21704:	f7f3 fb3c 	bl	14d80 <xTaskResumeAll>
      break;
   21708:	e7fb      	b.n	21702 <OSAL_CRIT_Leave+0x8>
      portEXIT_CRITICAL();
   2170a:	f000 f8d9 	bl	218c0 <vPortExitCritical>
}
   2170e:	e7f8      	b.n	21702 <OSAL_CRIT_Leave+0x8>

Disassembly of section .text.vListInitialise%1017:

00021710 <vListInitialise>:
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   21710:	f100 0308 	add.w	r3, r0, #8
   21714:	6043      	str	r3, [r0, #4]
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   21716:	f04f 32ff 	mov.w	r2, #4294967295
   2171a:	6082      	str	r2, [r0, #8]
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   2171c:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   2171e:	6103      	str	r3, [r0, #16]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
   21720:	2300      	movs	r3, #0
   21722:	6003      	str	r3, [r0, #0]
}
   21724:	4770      	bx	lr

Disassembly of section .text.vListInsertEnd%1018:

00021726 <vListInsertEnd>:
ListItem_t * const pxIndex = pxList->pxIndex;
   21726:	6843      	ldr	r3, [r0, #4]
	pxNewListItem->pxNext = pxIndex;
   21728:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
   2172a:	689a      	ldr	r2, [r3, #8]
   2172c:	608a      	str	r2, [r1, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
   2172e:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
   21730:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxContainer = pxList;
   21732:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
   21734:	6803      	ldr	r3, [r0, #0]
   21736:	3301      	adds	r3, #1
   21738:	6003      	str	r3, [r0, #0]
}
   2173a:	4770      	bx	lr

Disassembly of section .text.prvIsQueueEmpty%1019:

0002173c <prvIsQueueEmpty>:
{
   2173c:	b510      	push	{r4, lr}
   2173e:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
   21740:	f7ff f9e6 	bl	20b10 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
   21744:	6ba4      	ldr	r4, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
   21746:	f000 f8bb 	bl	218c0 <vPortExitCritical>
}
   2174a:	fab4 f084 	clz	r0, r4
   2174e:	0940      	lsrs	r0, r0, #5
   21750:	bd10      	pop	{r4, pc}

Disassembly of section .text.xQueueCreateCountingSemaphore%1020:

00021752 <xQueueCreateCountingSemaphore>:
	{
   21752:	b510      	push	{r4, lr}
   21754:	460c      	mov	r4, r1
		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
   21756:	2202      	movs	r2, #2
   21758:	2100      	movs	r1, #0
   2175a:	f7fd fd93 	bl	1f284 <xQueueGenericCreate>
		if( xHandle != NULL )
   2175e:	4603      	mov	r3, r0
   21760:	b100      	cbz	r0, 21764 <xQueueCreateCountingSemaphore+0x12>
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
   21762:	6384      	str	r4, [r0, #56]	; 0x38
	}
   21764:	4618      	mov	r0, r3
   21766:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_InitMd5%1021:

00021768 <wc_InitMd5>:
#endif /* !HAVE_MD5_CUST_API */


int wc_InitMd5(wc_Md5* md5)
{
   21768:	b508      	push	{r3, lr}
    if (md5 == NULL) {
   2176a:	b128      	cbz	r0, 21778 <wc_InitMd5+0x10>
        return BAD_FUNC_ARG;
    }
    return wc_InitMd5_ex(md5, NULL, INVALID_DEVID);
   2176c:	f06f 0201 	mvn.w	r2, #1
   21770:	2100      	movs	r1, #0
   21772:	f7fc fd09 	bl	1e188 <wc_InitMd5_ex>
}
   21776:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
   21778:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   2177c:	e7fb      	b.n	21776 <wc_InitMd5+0xe>

Disassembly of section .rodata._DRV_PHY_NegResultPhasesTbl%1022:

00021780 <_DRV_PHY_NegResultPhasesTbl>:
   21780:	134d 0002 acc5 0001 00f1 0002 0117 0002     M...............
   21790:	52a5 0001                                   .R..

Disassembly of section .rodata.DRV_ETHPHY_OBJECT_LAN867x%1023:

00021794 <DRV_ETHPHY_OBJECT_LAN867x>:
   21794:	f809 0000 40d5 0000 0489 0002 0000 0000     .....@..........
   217a4:	5377 0001                                   wS..

Disassembly of section .rodata._DRV_GMAC_LinkStateTbl%1024:

000217a8 <_DRV_GMAC_LinkStateTbl>:
   217a8:	fa79 0001 cfa7 0001 b59d 0001 d58d 0001     y...............
   217b8:	9c01 0001                                   ....

Disassembly of section .text.DRV_PIC32CGMAC_LibGetHighPrioReadyQue%1025:

000217bc <DRV_PIC32CGMAC_LibGetHighPrioReadyQue>:
    if(drvGmacQueEvents & GMAC_QUE0_MASK)
   217bc:	4b03      	ldr	r3, [pc, #12]	; (217cc <DRV_PIC32CGMAC_LibGetHighPrioReadyQue+0x10>)
   217be:	6818      	ldr	r0, [r3, #0]
   217c0:	f080 0001 	eor.w	r0, r0, #1
   217c4:	f340 0000 	sbfx	r0, r0, #0, #1
}
   217c8:	b2c0      	uxtb	r0, r0
   217ca:	4770      	bx	lr
   217cc:	2000e578 	.word	0x2000e578

Disassembly of section .text.Ipv4DeRegisterCallback%1026:

000217d0 <Ipv4DeRegisterCallback>:
    if(filtNode->active)
   217d0:	7a03      	ldrb	r3, [r0, #8]
   217d2:	b11b      	cbz	r3, 217dc <Ipv4DeRegisterCallback+0xc>
        ipv4ActFilterCount--;
   217d4:	4a02      	ldr	r2, [pc, #8]	; (217e0 <Ipv4DeRegisterCallback+0x10>)
   217d6:	6813      	ldr	r3, [r2, #0]
   217d8:	3b01      	subs	r3, #1
   217da:	6013      	str	r3, [r2, #0]
}
   217dc:	4770      	bx	lr
   217de:	bf00      	nop
   217e0:	2000e5fc 	.word	0x2000e5fc

Disassembly of section .text.TCPIP_HEAP_Create%1027:

000217e4 <TCPIP_HEAP_Create>:
#if !defined(TCPIP_STACK_DRAM_DEBUG_ENABLE) 

// functions needed when debugging is not enabled

TCPIP_STACK_HEAP_HANDLE TCPIP_HEAP_Create(const TCPIP_STACK_HEAP_CONFIG* initData, TCPIP_STACK_HEAP_RES* pRes)
{
   217e4:	b508      	push	{r3, lr}
    if(initData != 0)
   217e6:	b118      	cbz	r0, 217f0 <TCPIP_HEAP_Create+0xc>
    {
        switch (initData->heapType)
   217e8:	7802      	ldrb	r2, [r0, #0]
   217ea:	2a01      	cmp	r2, #1
   217ec:	d001      	beq.n	217f2 <TCPIP_HEAP_Create+0xe>
            default:
                break;
        }
    }

    return 0;
   217ee:	2000      	movs	r0, #0
}
   217f0:	bd08      	pop	{r3, pc}
                return TCPIP_HEAP_CreateInternal((const TCPIP_STACK_HEAP_INTERNAL_CONFIG*)initData, pRes);
   217f2:	f7f3 fef5 	bl	155e0 <TCPIP_HEAP_CreateInternal>
   217f6:	e7fb      	b.n	217f0 <TCPIP_HEAP_Create+0xc>

Disassembly of section .text._DHCPOptionWriteEnd%1028:

000217f8 <_DHCPOptionWriteEnd>:
    if(pSendData->writeSpace >= sizeof(*pEnd))
   217f8:	684b      	ldr	r3, [r1, #4]
   217fa:	b913      	cbnz	r3, 21802 <_DHCPOptionWriteEnd+0xa>
    return -1;
   217fc:	f04f 30ff 	mov.w	r0, #4294967295
}
   21800:	4770      	bx	lr
        pEnd = (TCPIP_DHCP_OPTION_DATA_END*)pSendData->pOpt;
   21802:	680b      	ldr	r3, [r1, #0]
        pEnd->opt = TCPIP_DHCP_END_OPTION;
   21804:	22ff      	movs	r2, #255	; 0xff
   21806:	701a      	strb	r2, [r3, #0]
        return sizeof(*pEnd);
   21808:	2001      	movs	r0, #1
   2180a:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetUpMACAddressGet%1029:

0002180c <TCPIP_STACK_NetUpMACAddressGet>:
   2180c:	b128      	cbz	r0, 2181a <TCPIP_STACK_NetUpMACAddressGet+0xe>
   2180e:	f890 2042 	ldrb.w	r2, [r0, #66]	; 0x42
   21812:	f012 0f40 	tst.w	r2, #64	; 0x40
   21816:	d101      	bne.n	2181c <TCPIP_STACK_NetUpMACAddressGet+0x10>
    return 0;
   21818:	2000      	movs	r0, #0
}
   2181a:	4770      	bx	lr
        return pNetIf->netMACAddr.v;
   2181c:	303c      	adds	r0, #60	; 0x3c
   2181e:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_HeapHandleGet%1030:

00021820 <TCPIP_STACK_HeapHandleGet>:
    return TCPIP_MODULE_SIGNAL_NONE; 
}

TCPIP_STACK_HEAP_HANDLE TCPIP_STACK_HeapHandleGet(TCPIP_STACK_HEAP_TYPE heapType, int heapIndex)
{
    return (heapType == tcpip_stack_ctrl_data.heapType) ? tcpip_stack_ctrl_data.memH : 0;
   21820:	4b03      	ldr	r3, [pc, #12]	; (21830 <TCPIP_STACK_HeapHandleGet+0x10>)
   21822:	7c1b      	ldrb	r3, [r3, #16]
   21824:	4283      	cmp	r3, r0
   21826:	bf06      	itte	eq
   21828:	4b01      	ldreq	r3, [pc, #4]	; (21830 <TCPIP_STACK_HeapHandleGet+0x10>)
   2182a:	68d8      	ldreq	r0, [r3, #12]
   2182c:	2000      	movne	r0, #0
}
   2182e:	4770      	bx	lr
   21830:	2000e2f0 	.word	0x2000e2f0

Disassembly of section .text.SERCOM1_USART_ReadFreeBufferCountGet%1031:

00021834 <SERCOM1_USART_ReadFreeBufferCountGet>:
{
   21834:	b510      	push	{r4, lr}
    return (sercom1USARTObj.rdBufferSize - 1U) - SERCOM1_USART_ReadCountGet();
   21836:	4b03      	ldr	r3, [pc, #12]	; (21844 <SERCOM1_USART_ReadFreeBufferCountGet+0x10>)
   21838:	6b1c      	ldr	r4, [r3, #48]	; 0x30
   2183a:	f7ff fe6b 	bl	21514 <SERCOM1_USART_ReadCountGet>
   2183e:	3c01      	subs	r4, #1
}
   21840:	1a20      	subs	r0, r4, r0
   21842:	bd10      	pop	{r4, pc}
   21844:	2000e1f0 	.word	0x2000e1f0

Disassembly of section .text.SERCOM1_USART_WriteFreeBufferCountGet%1032:

00021848 <SERCOM1_USART_WriteFreeBufferCountGet>:
{
   21848:	b510      	push	{r4, lr}
    return (sercom1USARTObj.wrBufferSize - 1U) - SERCOM1_USART_WriteCountGet();
   2184a:	4b03      	ldr	r3, [pc, #12]	; (21858 <SERCOM1_USART_WriteFreeBufferCountGet+0x10>)
   2184c:	691c      	ldr	r4, [r3, #16]
    nPendingTxBytes = SERCOM1_USART_WritePendingBytesGet();
   2184e:	f7ff fe55 	bl	214fc <SERCOM1_USART_WritePendingBytesGet>
    return (sercom1USARTObj.wrBufferSize - 1U) - SERCOM1_USART_WriteCountGet();
   21852:	3c01      	subs	r4, #1
}
   21854:	1a20      	subs	r0, r4, r0
   21856:	bd10      	pop	{r4, pc}
   21858:	2000e1f0 	.word	0x2000e1f0

Disassembly of section .text.TC0_Timer16bitPeriodSet%1033:

0002185c <TC0_Timer16bitPeriodSet>:
    TC0_REGS->COUNT16.TC_CC[0] = period;
   2185c:	4b03      	ldr	r3, [pc, #12]	; (2186c <TC0_Timer16bitPeriodSet+0x10>)
   2185e:	8398      	strh	r0, [r3, #28]
    while((TC0_REGS->COUNT16.TC_SYNCBUSY & TC_SYNCBUSY_CC0_Msk) == TC_SYNCBUSY_CC0_Msk)
   21860:	461a      	mov	r2, r3
   21862:	6913      	ldr	r3, [r2, #16]
   21864:	f013 0f40 	tst.w	r3, #64	; 0x40
   21868:	d1fb      	bne.n	21862 <TC0_Timer16bitPeriodSet+0x6>
}
   2186a:	4770      	bx	lr
   2186c:	40003800 	.word	0x40003800

Disassembly of section .text.TC0_Timer16bitCompareSet%1034:

00021870 <TC0_Timer16bitCompareSet>:
    TC0_REGS->COUNT16.TC_CC[1] = compare;
   21870:	4b03      	ldr	r3, [pc, #12]	; (21880 <TC0_Timer16bitCompareSet+0x10>)
   21872:	83d8      	strh	r0, [r3, #30]
    while((TC0_REGS->COUNT16.TC_SYNCBUSY & TC_SYNCBUSY_CC1_Msk) == TC_SYNCBUSY_CC1_Msk)
   21874:	461a      	mov	r2, r3
   21876:	6913      	ldr	r3, [r2, #16]
   21878:	f013 0f80 	tst.w	r3, #128	; 0x80
   2187c:	d1fb      	bne.n	21876 <TC0_Timer16bitCompareSet+0x6>
}
   2187e:	4770      	bx	lr
   21880:	40003800 	.word	0x40003800

Disassembly of section .rodata.sysConsoleApi%1035:

00021884 <sysConsoleApi>:
   21884:	00020f49 000190e5 0001f195 00021aad     I...............
   21894:	00020a71                                q...

Disassembly of section .text.Console_UART_ResourceLock%1036:

00021898 <Console_UART_ResourceLock>:
{
   21898:	b508      	push	{r3, lr}
    if(OSAL_MUTEX_Lock(&(pConsoleUartData->mutexTransferObjects), OSAL_WAIT_FOREVER) == OSAL_RESULT_FALSE)
   2189a:	f64f 71ff 	movw	r1, #65535	; 0xffff
   2189e:	3008      	adds	r0, #8
   218a0:	f7ff f9ff 	bl	20ca2 <OSAL_MUTEX_Lock>
}
   218a4:	3000      	adds	r0, #0
   218a6:	bf18      	it	ne
   218a8:	2001      	movne	r0, #1
   218aa:	bd08      	pop	{r3, pc}

Disassembly of section .text.vPortEnableVFP%1037:

000218ac <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
   218ac:	f8df 000c 	ldr.w	r0, [pc, #12]	; 218bc <vPortEnableVFP+0x10>
   218b0:	6801      	ldr	r1, [r0, #0]
   218b2:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   218b6:	6001      	str	r1, [r0, #0]
   218b8:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
   218ba:	0000      	.short	0x0000
   218bc:	e000ed88 	.word	0xe000ed88

Disassembly of section .text.vPortExitCritical%1038:

000218c0 <vPortExitCritical>:
	uxCriticalNesting--;
   218c0:	4a03      	ldr	r2, [pc, #12]	; (218d0 <vPortExitCritical+0x10>)
   218c2:	6813      	ldr	r3, [r2, #0]
   218c4:	3b01      	subs	r3, #1
   218c6:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
   218c8:	b90b      	cbnz	r3, 218ce <vPortExitCritical+0xe>
	__asm volatile
   218ca:	f383 8811 	msr	BASEPRI, r3
}
   218ce:	4770      	bx	lr
   218d0:	2000e698 	.word	0x2000e698

Disassembly of section .rodata.__func__.10030%1039:

000218d4 <__func__.10030>:
   218d4:	5f786667 6f6e6f6d 6172645f 68635f77     gfx_mono_draw_ch
   218e4:	00007261                                ar..

Disassembly of section .text.CRYPT_WCCB_Initialize%1040:

000218e8 <CRYPT_WCCB_Initialize>:
    }    
    return CRYPTOCB_UNAVAILABLE;
}

void CRYPT_WCCB_Initialize()
{
   218e8:	b508      	push	{r3, lr}
    wc_CryptoCb_RegisterDevice(0, CRYPT_WCCB_Callback, NULL);
   218ea:	2200      	movs	r2, #0
   218ec:	4902      	ldr	r1, [pc, #8]	; (218f8 <CRYPT_WCCB_Initialize+0x10>)
   218ee:	4610      	mov	r0, r2
   218f0:	f7fd fe83 	bl	1f5fa <wc_CryptoCb_RegisterDevice>
   218f4:	bd08      	pop	{r3, pc}
   218f6:	bf00      	nop
   218f8:	00022125 	.word	0x00022125

Disassembly of section .text%1041:

000218fc <strcmp>:
   218fc:	f810 2b01 	ldrb.w	r2, [r0], #1
   21900:	f811 3b01 	ldrb.w	r3, [r1], #1
   21904:	2a01      	cmp	r2, #1
   21906:	bf28      	it	cs
   21908:	429a      	cmpcs	r2, r3
   2190a:	d0f7      	beq.n	218fc <strcmp>
   2190c:	1ad0      	subs	r0, r2, r3
   2190e:	4770      	bx	lr

Disassembly of section .text.strtol%1042:

00021910 <strtol>:
   21910:	4613      	mov	r3, r2
   21912:	460a      	mov	r2, r1
   21914:	4601      	mov	r1, r0
   21916:	4802      	ldr	r0, [pc, #8]	; (21920 <strtol+0x10>)
   21918:	6800      	ldr	r0, [r0, #0]
   2191a:	f7f3 b85d 	b.w	149d8 <_strtol_l.isra.0>
   2191e:	bf00      	nop
   21920:	2000e700 	.word	0x2000e700

Disassembly of section .text.CRYPT_MD5_Initialize%1043:

00021924 <CRYPT_MD5_Initialize>:
{
   21924:	b508      	push	{r3, lr}
    if (md5 == NULL)
   21926:	b118      	cbz	r0, 21930 <CRYPT_MD5_Initialize+0xc>
    wc_InitMd5((Md5*)md5);
   21928:	f7ff ff1e 	bl	21768 <wc_InitMd5>
    return 0;
   2192c:	2000      	movs	r0, #0
}
   2192e:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
   21930:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   21934:	e7fb      	b.n	2192e <CRYPT_MD5_Initialize+0xa>

Disassembly of section .text.TCPIP_TCP_GetIsReady%1044:

00021936 <TCPIP_TCP_GetIsReady>:
{
   21936:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   21938:	f7fe f9bc 	bl	1fcb4 <_TcpSocketChk>
    if(pSkt)
   2193c:	b110      	cbz	r0, 21944 <TCPIP_TCP_GetIsReady+0xe>
        return _TCPIsGetReady(pSkt);
   2193e:	f7ff f956 	bl	20bee <_TCPIsGetReady>
}
   21942:	bd08      	pop	{r3, pc}
    return 0;
   21944:	2000      	movs	r0, #0
   21946:	e7fc      	b.n	21942 <TCPIP_TCP_GetIsReady+0xc>

Disassembly of section .text._TCPIP_HEAP_FreeSize%1045:

00021948 <_TCPIP_HEAP_FreeSize>:
    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   21948:	4603      	mov	r3, r0
   2194a:	b120      	cbz	r0, 21956 <_TCPIP_HEAP_FreeSize+0xe>
        return (hDcpt->_heapUnits - hDcpt->_heapAllocatedUnits) * sizeof(_headNode);   
   2194c:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   2194e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   21950:	1ac0      	subs	r0, r0, r3
   21952:	0100      	lsls	r0, r0, #4
   21954:	4770      	bx	lr
    return 0;
   21956:	2000      	movs	r0, #0
}
   21958:	4770      	bx	lr

Disassembly of section .text.TCPIP_OAHASH_EntryGet%1046:

0002195a <TCPIP_OAHASH_EntryGet>:
    if(entryIx < pOH->hEntries)
   2195a:	68c3      	ldr	r3, [r0, #12]
   2195c:	428b      	cmp	r3, r1
        return (OA_HASH_ENTRY*)((uint8_t*)(pOH->memBlk) + entryIx * pOH->hEntrySize);
   2195e:	bf83      	ittte	hi
   21960:	6883      	ldrhi	r3, [r0, #8]
   21962:	6800      	ldrhi	r0, [r0, #0]
   21964:	fb03 0001 	mlahi	r0, r3, r1, r0
    return 0;
   21968:	2000      	movls	r0, #0
}
   2196a:	4770      	bx	lr

Disassembly of section .text.OSAL_SEM_Delete%1047:

0002196c <OSAL_SEM_Delete>:
{
   2196c:	b510      	push	{r4, lr}
   2196e:	4604      	mov	r4, r0
  vSemaphoreDelete(*(SemaphoreHandle_t*)semID);
   21970:	6800      	ldr	r0, [r0, #0]
   21972:	f000 fbaf 	bl	220d4 <vQueueDelete>
  *(SemaphoreHandle_t*)semID = NULL;
   21976:	2300      	movs	r3, #0
   21978:	6023      	str	r3, [r4, #0]
}
   2197a:	2001      	movs	r0, #1
   2197c:	bd10      	pop	{r4, pc}

Disassembly of section .text.NVIC_INT_Disable%1048:

0002197e <NVIC_INT_Disable>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   2197e:	f3ef 8010 	mrs	r0, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
   21982:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   21984:	f3bf 8f5f 	dmb	sy

    __disable_irq();
    __DMB();

    return processorStatus;
}
   21988:	fab0 f080 	clz	r0, r0
   2198c:	0940      	lsrs	r0, r0, #5
   2198e:	4770      	bx	lr

Disassembly of section .text.NVIC_INT_Restore%1049:

00021990 <NVIC_INT_Restore>:

void NVIC_INT_Restore( bool state )
{
    if( state == true )
   21990:	b118      	cbz	r0, 2199a <NVIC_INT_Restore+0xa>
   21992:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   21996:	b662      	cpsie	i
   21998:	4770      	bx	lr
  __ASM volatile ("cpsid i" : : : "memory");
   2199a:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   2199c:	f3bf 8f5f 	dmb	sy
    else
    {
        __disable_irq();
        __DMB();
    }
}
   219a0:	4770      	bx	lr

Disassembly of section .text.vApplicationStackOverflowHook%1050:

000219a2 <vApplicationStackOverflowHook>:
	__asm volatile
   219a2:	f04f 0320 	mov.w	r3, #32
   219a6:	f383 8811 	msr	BASEPRI, r3
   219aa:	f3bf 8f6f 	isb	sy
   219ae:	f3bf 8f4f 	dsb	sy
   /* Run time task stack overflow checking is performed if
   configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook  function is
   called if a task stack overflow is detected.  Note the system/interrupt
   stack is not checked. */
   taskDISABLE_INTERRUPTS();
   for( ;; );
   219b2:	e7fe      	b.n	219b2 <vApplicationStackOverflowHook+0x10>

Disassembly of section .text.vApplicationMallocFailedHook%1051:

000219b4 <vApplicationMallocFailedHook>:
   219b4:	f04f 0320 	mov.w	r3, #32
   219b8:	f383 8811 	msr	BASEPRI, r3
   219bc:	f3bf 8f6f 	isb	sy
   219c0:	f3bf 8f4f 	dsb	sy
      heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
      FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
      to query the size of free heap space that remains (although it does not
      provide information on how the remaining heap might be fragmented). */
   taskDISABLE_INTERRUPTS();
   for( ;; );
   219c4:	e7fe      	b.n	219c4 <vApplicationMallocFailedHook+0x10>

Disassembly of section .rodata%1052:

000219c6 <.rodata%1052>:
   219c6:	4e49      	.short	0x4e49
   219c8:	6e690046 	.word	0x6e690046
   219cc:	414e0066 	.word	0x414e0066
   219d0:	616e004e 	.word	0x616e004e
   219d4:	0030006e 	.word	0x0030006e

Disassembly of section .text.__i2b%1053:

000219d8 <__i2b>:
   219d8:	b510      	push	{r4, lr}
   219da:	460c      	mov	r4, r1
   219dc:	2101      	movs	r1, #1
   219de:	f7f9 f93d 	bl	1ac5c <_Balloc>
   219e2:	2201      	movs	r2, #1
   219e4:	6144      	str	r4, [r0, #20]
   219e6:	6102      	str	r2, [r0, #16]
   219e8:	bd10      	pop	{r4, pc}

Disassembly of section .rodata%1054:

000219ea <.rodata%1054>:
   219ea:	2d23      	.short	0x2d23
   219ec:	00202b30 	.word	0x00202b30
   219f0:	004c6c68 	.word	0x004c6c68
   219f4:	45676665 	.word	0x45676665
   219f8:	4746      	.short	0x4746
   219fa:	00          	.byte	0x00
   219fb:	23          	.byte	0x23
   219fc:	202b302d 	.word	0x202b302d
   21a00:	4c6c6800 	.word	0x4c6c6800
   21a04:	67666500 	.word	0x67666500
   21a08:	00474645 	.word	0x00474645

Disassembly of section .text.CRYPT_RNG_Initialize%1056:

00021a0c <CRYPT_RNG_Initialize>:
{
   21a0c:	b508      	push	{r3, lr}
    if (rng == NULL)
   21a0e:	b110      	cbz	r0, 21a16 <CRYPT_RNG_Initialize+0xa>
    return wc_InitRng((WC_RNG*)rng);
   21a10:	f7ff fc14 	bl	2123c <wc_InitRng>
}
   21a14:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
   21a16:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   21a1a:	e7fb      	b.n	21a14 <CRYPT_RNG_Initialize+0x8>

Disassembly of section .rodata._DRV_PHY_SetupPhasesTbl%1057:

00021a1c <_DRV_PHY_SetupPhasesTbl>:
   21a1c:	ed9d 0001 7ca9 0001 6ebd 0001 0851 0002     .....|...n..Q...

Disassembly of section .text.DRV_PIC32CGMAC_LibSetInterruptSrc%1058:

00021a2c <DRV_PIC32CGMAC_LibSetInterruptSrc>:
    pMACDrv->sGmacData.gmac_queue[GMAC_QUE_0]._queIntSrc = drvGmacIRQ[GMAC_QUE_0];    
   21a2c:	4b02      	ldr	r3, [pc, #8]	; (21a38 <DRV_PIC32CGMAC_LibSetInterruptSrc+0xc>)
   21a2e:	881b      	ldrh	r3, [r3, #0]
   21a30:	f8a0 30b6 	strh.w	r3, [r0, #182]	; 0xb6
}
   21a34:	4770      	bx	lr
   21a36:	bf00      	nop
   21a38:	2000e714 	.word	0x2000e714

Disassembly of section .text.TCPIP_TCP_SocketNetGet%1059:

00021a3c <TCPIP_TCP_SocketNetGet>:
{
   21a3c:	b508      	push	{r3, lr}
    TCB_STUB* pSkt = _TcpSocketChk(hTCP); 
   21a3e:	f7fe f939 	bl	1fcb4 <_TcpSocketChk>
    if(pSkt == 0)
   21a42:	4603      	mov	r3, r0
   21a44:	b100      	cbz	r0, 21a48 <TCPIP_TCP_SocketNetGet+0xc>
    return pSkt->pSktNet;
   21a46:	6c03      	ldr	r3, [r0, #64]	; 0x40
}
   21a48:	4618      	mov	r0, r3
   21a4a:	bd08      	pop	{r3, pc}

Disassembly of section .rodata.heapTypeStr.14744%1060:

00021a4c <heapTypeStr.14744>:
   21a4c:	0000 0000 1754 0000 1760 0000 1768 0000     ....T...`...h...

Disassembly of section .text.TCPIP_DNS_GetIPv4Addresses%1061:

00021a5c <TCPIP_DNS_GetIPv4Addresses>:
{
   21a5c:	b510      	push	{r4, lr}
   21a5e:	b082      	sub	sp, #8
    return _DNS_GetAddresses(hostName, startIndex, (IP_MULTI_ADDRESS*)pIPv4Addr, nIPv4Addresses, TCPIP_DNS_ADDRESS_REC_IPV4);
   21a60:	2401      	movs	r4, #1
   21a62:	9400      	str	r4, [sp, #0]
   21a64:	f7f2 ff42 	bl	148ec <_DNS_GetAddresses>
}
   21a68:	b002      	add	sp, #8
   21a6a:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_DNS_GetIPv6Addresses%1062:

00021a6c <TCPIP_DNS_GetIPv6Addresses>:
{
   21a6c:	b510      	push	{r4, lr}
   21a6e:	b082      	sub	sp, #8
    return _DNS_GetAddresses(hostName, startIndex, (IP_MULTI_ADDRESS*)pIPv6Addr, nIPv6Addresses, TCPIP_DNS_ADDRESS_REC_IPV6);
   21a70:	2402      	movs	r4, #2
   21a72:	9400      	str	r4, [sp, #0]
   21a74:	f7f2 ff3a 	bl	148ec <_DNS_GetAddresses>
}
   21a78:	b002      	add	sp, #8
   21a7a:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_Notification_Deinitialize%1063:

00021a7c <TCPIP_Notification_Deinitialize>:
{
   21a7c:	b510      	push	{r4, lr}
   21a7e:	4604      	mov	r4, r0
    TCPIP_Notification_RemoveAll(notifyList, heapH);
   21a80:	f7ff fbb5 	bl	211ee <TCPIP_Notification_RemoveAll>
    TCPIP_Helper_ProtectedSingleListDeinitialize(notifyList);
   21a84:	4620      	mov	r0, r4
   21a86:	f7fd fb0d 	bl	1f0a4 <TCPIP_Helper_ProtectedSingleListDeinitialize>
}
   21a8a:	bd10      	pop	{r4, pc}

Disassembly of section .text.TCPIP_UDP_SocketNetGet%1064:

00021a8c <TCPIP_UDP_SocketNetGet>:
{
   21a8c:	b508      	push	{r3, lr}
    UDP_SOCKET_DCPT* pSkt = _UDPSocketDcpt(s);
   21a8e:	f7fe fa29 	bl	1fee4 <_UDPSocketDcpt>
    return pSkt?pSkt->pSktNet:0;
   21a92:	4603      	mov	r3, r0
   21a94:	b100      	cbz	r0, 21a98 <TCPIP_UDP_SocketNetGet+0xc>
   21a96:	6a43      	ldr	r3, [r0, #36]	; 0x24
}
   21a98:	4618      	mov	r0, r3
   21a9a:	bd08      	pop	{r3, pc}

Disassembly of section .text.NVMCTRL_Initialize%1065:

00021a9c <NVMCTRL_Initialize>:



void NVMCTRL_Initialize(void)
{
   NVMCTRL_REGS->NVMCTRL_CTRLA = NVMCTRL_CTRLA_RWS(5) | NVMCTRL_CTRLA_AUTOWS_Msk;    
   21a9c:	4b02      	ldr	r3, [pc, #8]	; (21aa8 <NVMCTRL_Initialize+0xc>)
   21a9e:	f240 5204 	movw	r2, #1284	; 0x504
   21aa2:	801a      	strh	r2, [r3, #0]
}
   21aa4:	4770      	bx	lr
   21aa6:	bf00      	nop
   21aa8:	41004000 	.word	0x41004000

Disassembly of section .text.IsCommandReady%1066:

00021aac <IsCommandReady>:
{
   21aac:	b508      	push	{r3, lr}
    return (int)SYS_CONSOLE_ReadCountGet(_cmdInitData.consoleIndex);
   21aae:	4b02      	ldr	r3, [pc, #8]	; (21ab8 <IsCommandReady+0xc>)
   21ab0:	8858      	ldrh	r0, [r3, #2]
   21ab2:	f7fd f823 	bl	1eafc <SYS_CONSOLE_ReadCountGet>
}
   21ab6:	bd08      	pop	{r3, pc}
   21ab8:	2000e674 	.word	0x2000e674

Disassembly of section .text.Console_UART_Status%1067:

00021abc <Console_UART_Status>:
    return true;
}

SYS_CONSOLE_STATUS Console_UART_Status(uint32_t index)
{
    CONSOLE_UART_DATA* pConsoleUartData = CONSOLE_UART_GET_INSTANCE(index);
   21abc:	b910      	cbnz	r0, 21ac4 <Console_UART_Status+0x8>
    {
        return SYS_CONSOLE_STATUS_ERROR;
    }
    else
    {
        return pConsoleUartData->status;
   21abe:	4b02      	ldr	r3, [pc, #8]	; (21ac8 <Console_UART_Status+0xc>)
   21ac0:	7918      	ldrb	r0, [r3, #4]
   21ac2:	4770      	bx	lr
        return SYS_CONSOLE_STATUS_ERROR;
   21ac4:	2003      	movs	r0, #3
    }
}
   21ac6:	4770      	bx	lr
   21ac8:	2000e534 	.word	0x2000e534

Disassembly of section .text.sy_time_h2_adapter_callback%1068:

00021acc <sy_time_h2_adapter_callback>:
{
   21acc:	b508      	push	{r3, lr}
	systemAdaptObj.callback(context,0);
   21ace:	4b02      	ldr	r3, [pc, #8]	; (21ad8 <sy_time_h2_adapter_callback+0xc>)
   21ad0:	681b      	ldr	r3, [r3, #0]
   21ad2:	2100      	movs	r1, #0
   21ad4:	4798      	blx	r3
}
   21ad6:	bd08      	pop	{r3, pc}
   21ad8:	2000e688 	.word	0x2000e688

Disassembly of section .text._APP_Tasks%1069:

00021adc <_APP_Tasks>:
{   
   21adc:	b508      	push	{r3, lr}
        vTaskDelay(2 / portTICK_PERIOD_MS);
   21ade:	2402      	movs	r4, #2
        APP_Tasks();
   21ae0:	f7e8 fb74 	bl	a1cc <APP_Tasks>
        vTaskDelay(2 / portTICK_PERIOD_MS);
   21ae4:	4620      	mov	r0, r4
   21ae6:	f7fd f871 	bl	1ebcc <vTaskDelay>
   21aea:	e7f9      	b.n	21ae0 <_APP_Tasks+0x4>

Disassembly of section .text._SYS_CMD_Tasks%1070:

00021aec <_SYS_CMD_Tasks>:
{
   21aec:	b508      	push	{r3, lr}
        vTaskDelay(10 / portTICK_PERIOD_MS);
   21aee:	240a      	movs	r4, #10
        SYS_CMD_Tasks();
   21af0:	f7e7 f97e 	bl	8df0 <SYS_CMD_Tasks>
        vTaskDelay(10 / portTICK_PERIOD_MS);
   21af4:	4620      	mov	r0, r4
   21af6:	f7fd f869 	bl	1ebcc <vTaskDelay>
   21afa:	e7f9      	b.n	21af0 <_SYS_CMD_Tasks+0x4>

Disassembly of section .rodata.tcpipDHCPInitData%1071:

00021afc <tcpipDHCPInitData>:
   21afc:	0000 0000 000a 0000 0044 0000 0043 0000     ........D...C...

Disassembly of section .rodata.tcpipIPv4InitData%1072:

00021b0c <tcpipIPv4InitData>:
   21b0c:	000a 0000 0000 0000 0000 0000 0000 0000     ................

Disassembly of section .text.vTaskSuspendAll%1073:

00021b1c <vTaskSuspendAll>:
	++uxSchedulerSuspended;
   21b1c:	4a02      	ldr	r2, [pc, #8]	; (21b28 <vTaskSuspendAll+0xc>)
   21b1e:	6813      	ldr	r3, [r2, #0]
   21b20:	3301      	adds	r3, #1
   21b22:	6013      	str	r3, [r2, #0]
}
   21b24:	4770      	bx	lr
   21b26:	bf00      	nop
   21b28:	2000e6b8 	.word	0x2000e6b8

Disassembly of section .text.gfx_mono_framebuffer_get_byte%1074:

00021b2c <gfx_mono_framebuffer_get_byte>:
 * \code
    data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column) {
    return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
   21b2c:	4b02      	ldr	r3, [pc, #8]	; (21b38 <gfx_mono_framebuffer_get_byte+0xc>)
   21b2e:	681b      	ldr	r3, [r3, #0]
   21b30:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
}
   21b34:	5c40      	ldrb	r0, [r0, r1]
   21b36:	4770      	bx	lr
   21b38:	2000e6e0 	.word	0x2000e6e0

Disassembly of section .text.Read_Phy_Register%1075:

00021b3c <Read_Phy_Register>:
{
   21b3c:	b510      	push	{r4, lr}
   21b3e:	4614      	mov	r4, r2
	clientObj->phyAddress = phyAddress;
   21b40:	6001      	str	r1, [r0, #0]
	return Lan867x_Read_Register(clientObj, regAddr, rData);
   21b42:	461a      	mov	r2, r3
   21b44:	4621      	mov	r1, r4
   21b46:	f7fc f93e 	bl	1ddc6 <Lan867x_Read_Register>
}
   21b4a:	bd10      	pop	{r4, pc}

Disassembly of section .text.calloc%1076:

00021b4c <calloc>:
   21b4c:	4b02      	ldr	r3, [pc, #8]	; (21b58 <calloc+0xc>)
   21b4e:	460a      	mov	r2, r1
   21b50:	4601      	mov	r1, r0
   21b52:	6818      	ldr	r0, [r3, #0]
   21b54:	f7ff ba92 	b.w	2107c <_calloc_r>
   21b58:	2000e700 	.word	0x2000e700

Disassembly of section .text.malloc%1077:

00021b5c <malloc>:
   21b5c:	4b02      	ldr	r3, [pc, #8]	; (21b68 <malloc+0xc>)
   21b5e:	4601      	mov	r1, r0
   21b60:	6818      	ldr	r0, [r3, #0]
   21b62:	f7f4 bef3 	b.w	1694c <_malloc_r>
   21b66:	bf00      	nop
   21b68:	2000e700 	.word	0x2000e700

Disassembly of section .text.free%1078:

00021b6c <free>:
   21b6c:	4b02      	ldr	r3, [pc, #8]	; (21b78 <free+0xc>)
   21b6e:	4601      	mov	r1, r0
   21b70:	6818      	ldr	r0, [r3, #0]
   21b72:	f7f5 bfaf 	b.w	17ad4 <_free_r>
   21b76:	bf00      	nop
   21b78:	2000e700 	.word	0x2000e700

Disassembly of section .text.memset%1079:

00021b7c <memset>:
   21b7c:	4402      	add	r2, r0
   21b7e:	4603      	mov	r3, r0
   21b80:	4293      	cmp	r3, r2
   21b82:	d100      	bne.n	21b86 <memset+0xa>
   21b84:	4770      	bx	lr
   21b86:	f803 1b01 	strb.w	r1, [r3], #1
   21b8a:	e7f9      	b.n	21b80 <memset+0x4>

Disassembly of section .text.strcpy%1080:

00021b8c <strcpy>:
   21b8c:	4603      	mov	r3, r0
   21b8e:	f811 2b01 	ldrb.w	r2, [r1], #1
   21b92:	f803 2b01 	strb.w	r2, [r3], #1
   21b96:	2a00      	cmp	r2, #0
   21b98:	d1f9      	bne.n	21b8e <strcpy+0x2>
   21b9a:	4770      	bx	lr

Disassembly of section .text%1081:

00021b9c <strlen>:
   21b9c:	4603      	mov	r3, r0
   21b9e:	f813 2b01 	ldrb.w	r2, [r3], #1
   21ba2:	2a00      	cmp	r2, #0
   21ba4:	d1fb      	bne.n	21b9e <strlen+0x2>
   21ba6:	1a18      	subs	r0, r3, r0
   21ba8:	3801      	subs	r0, #1
   21baa:	4770      	bx	lr

Disassembly of section .text.raise%1082:

00021bac <raise>:
   21bac:	4b02      	ldr	r3, [pc, #8]	; (21bb8 <raise+0xc>)
   21bae:	4601      	mov	r1, r0
   21bb0:	6818      	ldr	r0, [r3, #0]
   21bb2:	f7fa bc53 	b.w	1c45c <_raise_r>
   21bb6:	bf00      	nop
   21bb8:	2000e700 	.word	0x2000e700

Disassembly of section .text._malloc_usable_size_r%1083:

00021bbc <_malloc_usable_size_r>:
   21bbc:	f851 3c04 	ldr.w	r3, [r1, #-4]
   21bc0:	1f18      	subs	r0, r3, #4
   21bc2:	2b00      	cmp	r3, #0
   21bc4:	bfbc      	itt	lt
   21bc6:	580b      	ldrlt	r3, [r1, r0]
   21bc8:	18c0      	addlt	r0, r0, r3
   21bca:	4770      	bx	lr

Disassembly of section .rodata%1084:

00021bcc <.rodata%1084>:
   21bcc:	69666e49 	.word	0x69666e49
   21bd0:	7974696e 	.word	0x7974696e
   21bd4:	4e614e00 	.word	0x4e614e00
   21bd8:	Address 0x00021bd8 is out of bounds.


Disassembly of section .text.DRV_PIC32CGMAC_LibSetPriorityToQueueNum%1085:

00021bdc <DRV_PIC32CGMAC_LibSetPriorityToQueueNum>:
    pMACDrv->sGmacData.gmacConfig.txPrioNumToQueIndx[0] = GMAC_QUE_0;
   21bdc:	2300      	movs	r3, #0
   21bde:	f880 30e3 	strb.w	r3, [r0, #227]	; 0xe3
    pMACDrv->sGmacData.gmacConfig.rxPrioNumToQueIndx[0] = GMAC_QUE_0;    
   21be2:	f880 30e5 	strb.w	r3, [r0, #229]	; 0xe5
}
   21be6:	2001      	movs	r0, #1
   21be8:	4770      	bx	lr

Disassembly of section .text.btohexa_low%1086:

00021bea <btohexa_low>:
  Returns:
  	The lower hexadecimal ASCII byte '0'-'9' or 'a'-'f'.
  ***************************************************************************/
uint8_t btohexa_low(uint8_t b)
{
	b &= 0x0F;
   21bea:	f000 000f 	and.w	r0, r0, #15
	return (b>9u) ? b+'a'-10:b+'0';
   21bee:	2809      	cmp	r0, #9
   21bf0:	bf8c      	ite	hi
   21bf2:	3057      	addhi	r0, #87	; 0x57
   21bf4:	3030      	addls	r0, #48	; 0x30
}
   21bf6:	4770      	bx	lr

Disassembly of section .text.TCPIP_Helper_ChecksumFold%1087:

00021bf8 <TCPIP_Helper_ChecksumFold>:
    checksum.Val = (uint32_t)checksum.w[0] + (uint32_t)checksum.w[1];
   21bf8:	b283      	uxth	r3, r0
   21bfa:	eb03 4010 	add.w	r0, r3, r0, lsr #16
    checksum.w[0] += checksum.w[1];
   21bfe:	eb00 4010 	add.w	r0, r0, r0, lsr #16
}
   21c02:	b280      	uxth	r0, r0
   21c04:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetIndexGet%1088:

00021c06 <TCPIP_STACK_NetIndexGet>:
    if(pNetIf)
   21c06:	b110      	cbz	r0, 21c0e <TCPIP_STACK_NetIndexGet+0x8>
        return pNetIf->netIfIx;
   21c08:	f8b0 0058 	ldrh.w	r0, [r0, #88]	; 0x58
   21c0c:	4770      	bx	lr
    return -1;
   21c0e:	f04f 30ff 	mov.w	r0, #4294967295
}
   21c12:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetIxGet%1089:

00021c14 <TCPIP_STACK_NetIxGet>:
    if(pNetIf)
   21c14:	b110      	cbz	r0, 21c1c <TCPIP_STACK_NetIxGet+0x8>
        return pNetIf->netIfIx;
   21c16:	f8b0 0058 	ldrh.w	r0, [r0, #88]	; 0x58
   21c1a:	4770      	bx	lr
    return -1;
   21c1c:	f04f 30ff 	mov.w	r0, #4294967295
}
   21c20:	4770      	bx	lr

Disassembly of section .text._TCPIPStackSignalHandlerDeregister%1090:

00021c22 <_TCPIPStackSignalHandlerDeregister>:
    if((pSignalEntry = (TCPIP_MODULE_SIGNAL_ENTRY*)handle) != 0)
   21c22:	b120      	cbz	r0, 21c2e <_TCPIPStackSignalHandlerDeregister+0xc>
        memset(pSignalEntry, 0x0, sizeof(*pSignalEntry));
   21c24:	2200      	movs	r2, #0
   21c26:	6002      	str	r2, [r0, #0]
   21c28:	6042      	str	r2, [r0, #4]
   21c2a:	6082      	str	r2, [r0, #8]
   21c2c:	60c2      	str	r2, [r0, #12]
}
   21c2e:	4770      	bx	lr

Disassembly of section .text.main%1091:

00021c30 <main>:
// Section: Main Entry Point
// *****************************************************************************
// *****************************************************************************

int main ( void )
{
   21c30:	b508      	push	{r3, lr}
    /* Initialize all modules */
    SYS_Initialize ( NULL );
   21c32:	2000      	movs	r0, #0
   21c34:	f7f7 fd0e 	bl	19654 <SYS_Initialize>

    while ( true )
    {
        /* Maintain state machines of all polled MPLAB Harmony modules. */
        SYS_Tasks ( );
   21c38:	f7f7 fcce 	bl	195d8 <SYS_Tasks>
   21c3c:	e7fc      	b.n	21c38 <main+0x8>

Disassembly of section .text.abort%1092:

00021c3e <abort>:
   21c3e:	b508      	push	{r3, lr}
   21c40:	2006      	movs	r0, #6
   21c42:	f7ff ffb3 	bl	21bac <raise>
   21c46:	2001      	movs	r0, #1
   21c48:	f7f8 fe67 	bl	1a91a <_exit>

Disassembly of section .rodata._DRV_PHY_LinkStatPhasesTbl%1093:

0001afe4 <_DRV_PHY_LinkStatPhasesTbl>:
   1afe4:	131d 0002 c635 0001 f709 0001               ....5.......

Disassembly of section .rodata._DRV_PHY_NegRestartPhasesTbl%1094:

00021c4c <_DRV_PHY_NegRestartPhasesTbl>:
   21c4c:	1365 0002 e277 0001 1fc5 0002               e...w.......

Disassembly of section .rodata._DRV_PHY_ResetPhasesTbl%1095:

00021c58 <_DRV_PHY_ResetPhasesTbl>:
   21c58:	0cdf 0002 d795 0001 ad29 0001               ........)...

Disassembly of section .text._DRV_GMAC_GetTxOctetLow%1096:

00021c64 <_DRV_GMAC_GetTxOctetLow>:
	return GMAC_REGS->GMAC_OTLO;	
   21c64:	4b01      	ldr	r3, [pc, #4]	; (21c6c <_DRV_GMAC_GetTxOctetLow+0x8>)
   21c66:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
}
   21c6a:	4770      	bx	lr
   21c6c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxOctetHigh%1097:

00021c70 <_DRV_GMAC_GetTxOctetHigh>:
	return GMAC_REGS->GMAC_OTHI;
   21c70:	4b01      	ldr	r3, [pc, #4]	; (21c78 <_DRV_GMAC_GetTxOctetHigh+0x8>)
   21c72:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
}
   21c76:	4770      	bx	lr
   21c78:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxFrameCount%1098:

00021c7c <_DRV_GMAC_GetTxFrameCount>:
	return GMAC_REGS->GMAC_FT;
   21c7c:	4b01      	ldr	r3, [pc, #4]	; (21c84 <_DRV_GMAC_GetTxFrameCount+0x8>)
   21c7e:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
}
   21c82:	4770      	bx	lr
   21c84:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxBCastFrameCount%1099:

00021c88 <_DRV_GMAC_GetTxBCastFrameCount>:
	return GMAC_REGS->GMAC_BCFT;
   21c88:	4b01      	ldr	r3, [pc, #4]	; (21c90 <_DRV_GMAC_GetTxBCastFrameCount+0x8>)
   21c8a:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
}
   21c8e:	4770      	bx	lr
   21c90:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxMCastFrameCount%1100:

00021c94 <_DRV_GMAC_GetTxMCastFrameCount>:
	return GMAC_REGS->GMAC_MFT;
   21c94:	4b01      	ldr	r3, [pc, #4]	; (21c9c <_DRV_GMAC_GetTxMCastFrameCount+0x8>)
   21c96:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
}
   21c9a:	4770      	bx	lr
   21c9c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxPauseFrameCount%1101:

00021ca0 <_DRV_GMAC_GetTxPauseFrameCount>:
	return GMAC_REGS->GMAC_PFT;
   21ca0:	4b01      	ldr	r3, [pc, #4]	; (21ca8 <_DRV_GMAC_GetTxPauseFrameCount+0x8>)
   21ca2:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
}
   21ca6:	4770      	bx	lr
   21ca8:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTx64ByteFrameCount%1102:

00021cac <_DRV_GMAC_GetTx64ByteFrameCount>:
	return GMAC_REGS->GMAC_BFT64;
   21cac:	4b01      	ldr	r3, [pc, #4]	; (21cb4 <_DRV_GMAC_GetTx64ByteFrameCount+0x8>)
   21cae:	f8d3 0118 	ldr.w	r0, [r3, #280]	; 0x118
}
   21cb2:	4770      	bx	lr
   21cb4:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTx127ByteFrameCount%1103:

00021cb8 <_DRV_GMAC_GetTx127ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFT127;
   21cb8:	4b01      	ldr	r3, [pc, #4]	; (21cc0 <_DRV_GMAC_GetTx127ByteFrameCount+0x8>)
   21cba:	f8d3 011c 	ldr.w	r0, [r3, #284]	; 0x11c
}
   21cbe:	4770      	bx	lr
   21cc0:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTx255ByteFrameCount%1104:

00021cc4 <_DRV_GMAC_GetTx255ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFT255;
   21cc4:	4b01      	ldr	r3, [pc, #4]	; (21ccc <_DRV_GMAC_GetTx255ByteFrameCount+0x8>)
   21cc6:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
}
   21cca:	4770      	bx	lr
   21ccc:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTx511ByteFrameCount%1105:

00021cd0 <_DRV_GMAC_GetTx511ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFT511;
   21cd0:	4b01      	ldr	r3, [pc, #4]	; (21cd8 <_DRV_GMAC_GetTx511ByteFrameCount+0x8>)
   21cd2:	f8d3 0124 	ldr.w	r0, [r3, #292]	; 0x124
}
   21cd6:	4770      	bx	lr
   21cd8:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTx1023ByteFrameCount%1106:

00021cdc <_DRV_GMAC_GetTx1023ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFT1023;
   21cdc:	4b01      	ldr	r3, [pc, #4]	; (21ce4 <_DRV_GMAC_GetTx1023ByteFrameCount+0x8>)
   21cde:	f8d3 0128 	ldr.w	r0, [r3, #296]	; 0x128
}
   21ce2:	4770      	bx	lr
   21ce4:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTx1518ByteFrameCount%1107:

00021ce8 <_DRV_GMAC_GetTx1518ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFT1518;
   21ce8:	4b01      	ldr	r3, [pc, #4]	; (21cf0 <_DRV_GMAC_GetTx1518ByteFrameCount+0x8>)
   21cea:	f8d3 012c 	ldr.w	r0, [r3, #300]	; 0x12c
}
   21cee:	4770      	bx	lr
   21cf0:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxGT1518ByteFrameCount%1108:

00021cf4 <_DRV_GMAC_GetTxGT1518ByteFrameCount>:
	return GMAC_REGS->GMAC_GTBFT1518;
   21cf4:	4b01      	ldr	r3, [pc, #4]	; (21cfc <_DRV_GMAC_GetTxGT1518ByteFrameCount+0x8>)
   21cf6:	f8d3 0130 	ldr.w	r0, [r3, #304]	; 0x130
}
   21cfa:	4770      	bx	lr
   21cfc:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxUnderRunFrameCount%1109:

00021d00 <_DRV_GMAC_GetTxUnderRunFrameCount>:
	return GMAC_REGS->GMAC_TUR;
   21d00:	4b01      	ldr	r3, [pc, #4]	; (21d08 <_DRV_GMAC_GetTxUnderRunFrameCount+0x8>)
   21d02:	f8d3 0134 	ldr.w	r0, [r3, #308]	; 0x134
}
   21d06:	4770      	bx	lr
   21d08:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxSingleCollFrameCount%1110:

00021d0c <_DRV_GMAC_GetTxSingleCollFrameCount>:
	return GMAC_REGS->GMAC_SCF;
   21d0c:	4b01      	ldr	r3, [pc, #4]	; (21d14 <_DRV_GMAC_GetTxSingleCollFrameCount+0x8>)
   21d0e:	f8d3 0138 	ldr.w	r0, [r3, #312]	; 0x138
}
   21d12:	4770      	bx	lr
   21d14:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxMultiCollFrameCount%1111:

00021d18 <_DRV_GMAC_GetTxMultiCollFrameCount>:
	return GMAC_REGS->GMAC_MCF;
   21d18:	4b01      	ldr	r3, [pc, #4]	; (21d20 <_DRV_GMAC_GetTxMultiCollFrameCount+0x8>)
   21d1a:	f8d3 013c 	ldr.w	r0, [r3, #316]	; 0x13c
}
   21d1e:	4770      	bx	lr
   21d20:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxExcessCollFrameCount%1112:

00021d24 <_DRV_GMAC_GetTxExcessCollFrameCount>:
	return GMAC_REGS->GMAC_EC;
   21d24:	4b01      	ldr	r3, [pc, #4]	; (21d2c <_DRV_GMAC_GetTxExcessCollFrameCount+0x8>)
   21d26:	f8d3 0140 	ldr.w	r0, [r3, #320]	; 0x140
}
   21d2a:	4770      	bx	lr
   21d2c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxLateCollFrameCount%1113:

00021d30 <_DRV_GMAC_GetTxLateCollFrameCount>:
	return GMAC_REGS->GMAC_LC;
   21d30:	4b01      	ldr	r3, [pc, #4]	; (21d38 <_DRV_GMAC_GetTxLateCollFrameCount+0x8>)
   21d32:	f8d3 0144 	ldr.w	r0, [r3, #324]	; 0x144
}
   21d36:	4770      	bx	lr
   21d38:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxDeferFrameCount%1114:

00021d3c <_DRV_GMAC_GetTxDeferFrameCount>:
	return GMAC_REGS->GMAC_DTF;
   21d3c:	4b01      	ldr	r3, [pc, #4]	; (21d44 <_DRV_GMAC_GetTxDeferFrameCount+0x8>)
   21d3e:	f8d3 0148 	ldr.w	r0, [r3, #328]	; 0x148
}
   21d42:	4770      	bx	lr
   21d44:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetTxCSErrorFrameCount%1115:

00021d48 <_DRV_GMAC_GetTxCSErrorFrameCount>:
	return GMAC_REGS->GMAC_CSE;
   21d48:	4b01      	ldr	r3, [pc, #4]	; (21d50 <_DRV_GMAC_GetTxCSErrorFrameCount+0x8>)
   21d4a:	f8d3 014c 	ldr.w	r0, [r3, #332]	; 0x14c
}
   21d4e:	4770      	bx	lr
   21d50:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxOctetLow%1116:

00021d54 <_DRV_GMAC_GetRxOctetLow>:
	return GMAC_REGS->GMAC_ORLO;
   21d54:	4b01      	ldr	r3, [pc, #4]	; (21d5c <_DRV_GMAC_GetRxOctetLow+0x8>)
   21d56:	f8d3 0150 	ldr.w	r0, [r3, #336]	; 0x150
}
   21d5a:	4770      	bx	lr
   21d5c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxOctetHigh%1117:

00021d60 <_DRV_GMAC_GetRxOctetHigh>:
	return GMAC_REGS->GMAC_ORHI;
   21d60:	4b01      	ldr	r3, [pc, #4]	; (21d68 <_DRV_GMAC_GetRxOctetHigh+0x8>)
   21d62:	f8d3 0154 	ldr.w	r0, [r3, #340]	; 0x154
}
   21d66:	4770      	bx	lr
   21d68:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxFrameCount%1118:

00021d6c <_DRV_GMAC_GetRxFrameCount>:
	return GMAC_REGS->GMAC_FR;
   21d6c:	4b01      	ldr	r3, [pc, #4]	; (21d74 <_DRV_GMAC_GetRxFrameCount+0x8>)
   21d6e:	f8d3 0158 	ldr.w	r0, [r3, #344]	; 0x158
}
   21d72:	4770      	bx	lr
   21d74:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxBCastFrameCount%1119:

00021d78 <_DRV_GMAC_GetRxBCastFrameCount>:
	return GMAC_REGS->GMAC_BCFR;
   21d78:	4b01      	ldr	r3, [pc, #4]	; (21d80 <_DRV_GMAC_GetRxBCastFrameCount+0x8>)
   21d7a:	f8d3 015c 	ldr.w	r0, [r3, #348]	; 0x15c
}
   21d7e:	4770      	bx	lr
   21d80:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxMCastFrameCount%1120:

00021d84 <_DRV_GMAC_GetRxMCastFrameCount>:
	return GMAC_REGS->GMAC_MFR;
   21d84:	4b01      	ldr	r3, [pc, #4]	; (21d8c <_DRV_GMAC_GetRxMCastFrameCount+0x8>)
   21d86:	f8d3 0160 	ldr.w	r0, [r3, #352]	; 0x160
}
   21d8a:	4770      	bx	lr
   21d8c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxPauseFrameCount%1121:

00021d90 <_DRV_GMAC_GetRxPauseFrameCount>:
	return GMAC_REGS->GMAC_PFR;
   21d90:	4b01      	ldr	r3, [pc, #4]	; (21d98 <_DRV_GMAC_GetRxPauseFrameCount+0x8>)
   21d92:	f8d3 0164 	ldr.w	r0, [r3, #356]	; 0x164
}
   21d96:	4770      	bx	lr
   21d98:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRx64ByteFrameCount%1122:

00021d9c <_DRV_GMAC_GetRx64ByteFrameCount>:
	return GMAC_REGS->GMAC_BFR64;
   21d9c:	4b01      	ldr	r3, [pc, #4]	; (21da4 <_DRV_GMAC_GetRx64ByteFrameCount+0x8>)
   21d9e:	f8d3 0168 	ldr.w	r0, [r3, #360]	; 0x168
}
   21da2:	4770      	bx	lr
   21da4:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRx127ByteFrameCount%1123:

00021da8 <_DRV_GMAC_GetRx127ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFR127;
   21da8:	4b01      	ldr	r3, [pc, #4]	; (21db0 <_DRV_GMAC_GetRx127ByteFrameCount+0x8>)
   21daa:	f8d3 016c 	ldr.w	r0, [r3, #364]	; 0x16c
}
   21dae:	4770      	bx	lr
   21db0:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRx255ByteFrameCount%1124:

00021db4 <_DRV_GMAC_GetRx255ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFR255;
   21db4:	4b01      	ldr	r3, [pc, #4]	; (21dbc <_DRV_GMAC_GetRx255ByteFrameCount+0x8>)
   21db6:	f8d3 0170 	ldr.w	r0, [r3, #368]	; 0x170
}
   21dba:	4770      	bx	lr
   21dbc:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRx511ByteFrameCount%1125:

00021dc0 <_DRV_GMAC_GetRx511ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFR511;
   21dc0:	4b01      	ldr	r3, [pc, #4]	; (21dc8 <_DRV_GMAC_GetRx511ByteFrameCount+0x8>)
   21dc2:	f8d3 0174 	ldr.w	r0, [r3, #372]	; 0x174
}
   21dc6:	4770      	bx	lr
   21dc8:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRx1023ByteFrameCount%1126:

00021dcc <_DRV_GMAC_GetRx1023ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFR1023;
   21dcc:	4b01      	ldr	r3, [pc, #4]	; (21dd4 <_DRV_GMAC_GetRx1023ByteFrameCount+0x8>)
   21dce:	f8d3 0178 	ldr.w	r0, [r3, #376]	; 0x178
}
   21dd2:	4770      	bx	lr
   21dd4:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRx1518ByteFrameCount%1127:

00021dd8 <_DRV_GMAC_GetRx1518ByteFrameCount>:
	return GMAC_REGS->GMAC_TBFR1518;
   21dd8:	4b01      	ldr	r3, [pc, #4]	; (21de0 <_DRV_GMAC_GetRx1518ByteFrameCount+0x8>)
   21dda:	f8d3 017c 	ldr.w	r0, [r3, #380]	; 0x17c
}
   21dde:	4770      	bx	lr
   21de0:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxGT1518ByteFrameCount%1128:

00021de4 <_DRV_GMAC_GetRxGT1518ByteFrameCount>:
	return GMAC_REGS->GMAC_TMXBFR;
   21de4:	4b01      	ldr	r3, [pc, #4]	; (21dec <_DRV_GMAC_GetRxGT1518ByteFrameCount+0x8>)
   21de6:	f8d3 0180 	ldr.w	r0, [r3, #384]	; 0x180
}
   21dea:	4770      	bx	lr
   21dec:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxUnderSizeFrameCount%1129:

00021df0 <_DRV_GMAC_GetRxUnderSizeFrameCount>:
	return GMAC_REGS->GMAC_UFR;
   21df0:	4b01      	ldr	r3, [pc, #4]	; (21df8 <_DRV_GMAC_GetRxUnderSizeFrameCount+0x8>)
   21df2:	f8d3 0184 	ldr.w	r0, [r3, #388]	; 0x184
}
   21df6:	4770      	bx	lr
   21df8:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxOverSizeFrameCount%1130:

00021dfc <_DRV_GMAC_GetRxOverSizeFrameCount>:
	return GMAC_REGS->GMAC_OFR;
   21dfc:	4b01      	ldr	r3, [pc, #4]	; (21e04 <_DRV_GMAC_GetRxOverSizeFrameCount+0x8>)
   21dfe:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
}
   21e02:	4770      	bx	lr
   21e04:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxJabberFrameCount%1131:

00021e08 <_DRV_GMAC_GetRxJabberFrameCount>:
	return GMAC_REGS->GMAC_JR;
   21e08:	4b01      	ldr	r3, [pc, #4]	; (21e10 <_DRV_GMAC_GetRxJabberFrameCount+0x8>)
   21e0a:	f8d3 018c 	ldr.w	r0, [r3, #396]	; 0x18c
}
   21e0e:	4770      	bx	lr
   21e10:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxFCSErrorFrameCount%1132:

00021e14 <_DRV_GMAC_GetRxFCSErrorFrameCount>:
	return GMAC_REGS->GMAC_FCSE;
   21e14:	4b01      	ldr	r3, [pc, #4]	; (21e1c <_DRV_GMAC_GetRxFCSErrorFrameCount+0x8>)
   21e16:	f8d3 0190 	ldr.w	r0, [r3, #400]	; 0x190
}
   21e1a:	4770      	bx	lr
   21e1c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxLFErrorFrameCount%1133:

00021e20 <_DRV_GMAC_GetRxLFErrorFrameCount>:
	return GMAC_REGS->GMAC_LFFE;
   21e20:	4b01      	ldr	r3, [pc, #4]	; (21e28 <_DRV_GMAC_GetRxLFErrorFrameCount+0x8>)
   21e22:	f8d3 0194 	ldr.w	r0, [r3, #404]	; 0x194
}
   21e26:	4770      	bx	lr
   21e28:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxSymErrorFrameCount%1134:

00021e2c <_DRV_GMAC_GetRxSymErrorFrameCount>:
	return GMAC_REGS->GMAC_RSE;
   21e2c:	4b01      	ldr	r3, [pc, #4]	; (21e34 <_DRV_GMAC_GetRxSymErrorFrameCount+0x8>)
   21e2e:	f8d3 0198 	ldr.w	r0, [r3, #408]	; 0x198
}
   21e32:	4770      	bx	lr
   21e34:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxAlignErrorFrameCount%1135:

00021e38 <_DRV_GMAC_GetRxAlignErrorFrameCount>:
	return GMAC_REGS->GMAC_AE;
   21e38:	4b01      	ldr	r3, [pc, #4]	; (21e40 <_DRV_GMAC_GetRxAlignErrorFrameCount+0x8>)
   21e3a:	f8d3 019c 	ldr.w	r0, [r3, #412]	; 0x19c
}
   21e3e:	4770      	bx	lr
   21e40:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxResErrorFrameCount%1136:

00021e44 <_DRV_GMAC_GetRxResErrorFrameCount>:
	return GMAC_REGS->GMAC_RRE;
   21e44:	4b01      	ldr	r3, [pc, #4]	; (21e4c <_DRV_GMAC_GetRxResErrorFrameCount+0x8>)
   21e46:	f8d3 01a0 	ldr.w	r0, [r3, #416]	; 0x1a0
}
   21e4a:	4770      	bx	lr
   21e4c:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxOverRunFrameCount%1137:

00021e50 <_DRV_GMAC_GetRxOverRunFrameCount>:
	return GMAC_REGS->GMAC_ROE;
   21e50:	4b01      	ldr	r3, [pc, #4]	; (21e58 <_DRV_GMAC_GetRxOverRunFrameCount+0x8>)
   21e52:	f8d3 01a4 	ldr.w	r0, [r3, #420]	; 0x1a4
}
   21e56:	4770      	bx	lr
   21e58:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxIPHdrCSErrorFrameCount%1138:

00021e5c <_DRV_GMAC_GetRxIPHdrCSErrorFrameCount>:
	return GMAC_REGS->GMAC_IHCE;
   21e5c:	4b01      	ldr	r3, [pc, #4]	; (21e64 <_DRV_GMAC_GetRxIPHdrCSErrorFrameCount+0x8>)
   21e5e:	f8d3 01a8 	ldr.w	r0, [r3, #424]	; 0x1a8
}
   21e62:	4770      	bx	lr
   21e64:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxTCPCSErrorFrameCount%1139:

00021e68 <_DRV_GMAC_GetRxTCPCSErrorFrameCount>:
	return GMAC_REGS->GMAC_TCE;
   21e68:	4b01      	ldr	r3, [pc, #4]	; (21e70 <_DRV_GMAC_GetRxTCPCSErrorFrameCount+0x8>)
   21e6a:	f8d3 01ac 	ldr.w	r0, [r3, #428]	; 0x1ac
}
   21e6e:	4770      	bx	lr
   21e70:	42000800 	.word	0x42000800

Disassembly of section .text._DRV_GMAC_GetRxUDPCSErrorFrameCount%1140:

00021e74 <_DRV_GMAC_GetRxUDPCSErrorFrameCount>:
	return GMAC_REGS->GMAC_UCE;
   21e74:	4b01      	ldr	r3, [pc, #4]	; (21e7c <_DRV_GMAC_GetRxUDPCSErrorFrameCount+0x8>)
   21e76:	f8d3 01b0 	ldr.w	r0, [r3, #432]	; 0x1b0
}
   21e7a:	4770      	bx	lr
   21e7c:	42000800 	.word	0x42000800

Disassembly of section .text.DRV_PIC32CGMAC_LibReadInterruptStatus%1141:

00021e80 <DRV_PIC32CGMAC_LibReadInterruptStatus>:
    return GMAC_REGS->GMAC_ISR;
   21e80:	4b01      	ldr	r3, [pc, #4]	; (21e88 <DRV_PIC32CGMAC_LibReadInterruptStatus+0x8>)
   21e82:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
   21e84:	4770      	bx	lr
   21e86:	bf00      	nop
   21e88:	42000800 	.word	0x42000800

Disassembly of section .text.DRV_PIC32CGMAC_LibEnableInterrupt%1142:

00021e8c <DRV_PIC32CGMAC_LibEnableInterrupt>:
    GMAC_REGS->GMAC_IER = ethEvents;
   21e8c:	4b01      	ldr	r3, [pc, #4]	; (21e94 <DRV_PIC32CGMAC_LibEnableInterrupt+0x8>)
   21e8e:	6299      	str	r1, [r3, #40]	; 0x28
}
   21e90:	4770      	bx	lr
   21e92:	bf00      	nop
   21e94:	42000800 	.word	0x42000800

Disassembly of section .text.DRV_PIC32CGMAC_LibDisableInterrupt%1143:

00021e98 <DRV_PIC32CGMAC_LibDisableInterrupt>:
    GMAC_REGS->GMAC_IDR = ethEvents;
   21e98:	4b01      	ldr	r3, [pc, #4]	; (21ea0 <DRV_PIC32CGMAC_LibDisableInterrupt+0x8>)
   21e9a:	62d9      	str	r1, [r3, #44]	; 0x2c
}
   21e9c:	4770      	bx	lr
   21e9e:	bf00      	nop
   21ea0:	42000800 	.word	0x42000800

Disassembly of section .text.btohexa_high%1144:

00021ea4 <btohexa_high>:
	b >>= 4;
   21ea4:	0900      	lsrs	r0, r0, #4
	return (b>0x9u) ? b+'a'-10:b+'0';
   21ea6:	2809      	cmp	r0, #9
   21ea8:	bf8c      	ite	hi
   21eaa:	3057      	addhi	r0, #87	; 0x57
   21eac:	3030      	addls	r0, #48	; 0x30
}
   21eae:	4770      	bx	lr

Disassembly of section .text.TCPIP_ARP_HashKeyCompare%1145:

00021eb0 <TCPIP_ARP_HashKeyCompare>:


int TCPIP_ARP_HashKeyCompare(OA_HASH_DCPT* pOH, OA_HASH_ENTRY* hEntry, const void* key)
{
    return ((ARP_HASH_ENTRY*)hEntry)->ipAddress.Val != ((ARP_UNALIGNED_KEY*)key)->v;
   21eb0:	6813      	ldr	r3, [r2, #0]
   21eb2:	6888      	ldr	r0, [r1, #8]
}
   21eb4:	1ac0      	subs	r0, r0, r3
   21eb6:	bf18      	it	ne
   21eb8:	2001      	movne	r0, #1
   21eba:	4770      	bx	lr

Disassembly of section .text.TCPIP_IPV4_PacketTransmit%1146:

00021ebc <TCPIP_IPV4_PacketTransmit>:
{
   21ebc:	b508      	push	{r3, lr}
    return TCPIP_IPV4_PktTx(pPkt, &pPkt->macPkt, true);
   21ebe:	2201      	movs	r2, #1
   21ec0:	4601      	mov	r1, r0
   21ec2:	f7ec f90b 	bl	e0dc <TCPIP_IPV4_PktTx>
}
   21ec6:	bd08      	pop	{r3, pc}

Disassembly of section .text._TCPIP_HEAP_Size%1147:

00021ec8 <_TCPIP_HEAP_Size>:
    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   21ec8:	b110      	cbz	r0, 21ed0 <_TCPIP_HEAP_Size+0x8>
        return hDcpt->_heapUnits * sizeof(_headNode);   
   21eca:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   21ecc:	0100      	lsls	r0, r0, #4
   21ece:	4770      	bx	lr
    return 0;
   21ed0:	2000      	movs	r0, #0
}
   21ed2:	4770      	bx	lr

Disassembly of section .text._TCPIP_HEAP_HighWatermark%1148:

00021ed4 <_TCPIP_HEAP_HighWatermark>:
    return (hInst == 0) ? 0 : &hInst->heapDcpt;
   21ed4:	b110      	cbz	r0, 21edc <_TCPIP_HEAP_HighWatermark+0x8>
        return hDcpt->_heapWatermark * sizeof(_headNode);
   21ed6:	6b40      	ldr	r0, [r0, #52]	; 0x34
   21ed8:	0100      	lsls	r0, r0, #4
   21eda:	4770      	bx	lr
    return 0;
   21edc:	2000      	movs	r0, #0
}
   21ede:	4770      	bx	lr

Disassembly of section .text.TCPIP_DNS_OAHASH_KeyCompare%1149:

00021ee0 <TCPIP_DNS_OAHASH_KeyCompare>:
{
   21ee0:	b508      	push	{r3, lr}
    return strcmp(pDnsHE->pHostName, (const char*)dnsHostNameKey);
   21ee2:	6a08      	ldr	r0, [r1, #32]
   21ee4:	4611      	mov	r1, r2
   21ee6:	f7ff fd09 	bl	218fc <strcmp>
}
   21eea:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_DNS_Enable%1150:

00021eec <TCPIP_DNS_Enable>:
{
   21eec:	b508      	push	{r3, lr}
    return _DNS_Enable(hNet, true, flags);
   21eee:	460a      	mov	r2, r1
   21ef0:	2101      	movs	r1, #1
   21ef2:	f7f9 fdcf 	bl	1ba94 <_DNS_Enable>
}
   21ef6:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_STACK_NetDefaultGet%1151:

00021ef8 <TCPIP_STACK_NetDefaultGet>:
}
   21ef8:	4b01      	ldr	r3, [pc, #4]	; (21f00 <TCPIP_STACK_NetDefaultGet+0x8>)
   21efa:	6818      	ldr	r0, [r3, #0]
   21efc:	4770      	bx	lr
   21efe:	bf00      	nop
   21f00:	2000e644 	.word	0x2000e644

Disassembly of section .text.TCPIP_STACK_NumberOfNetworksGet%1152:

00021f04 <TCPIP_STACK_NumberOfNetworksGet>:
}
   21f04:	4b01      	ldr	r3, [pc, #4]	; (21f0c <TCPIP_STACK_NumberOfNetworksGet+0x8>)
   21f06:	6818      	ldr	r0, [r3, #0]
   21f08:	4770      	bx	lr
   21f0a:	bf00      	nop
   21f0c:	2000e2f0 	.word	0x2000e2f0

Disassembly of section .rodata.TCPIP_STACK_IF_ALIAS_NAME_TBL%1153:

00021f10 <TCPIP_STACK_IF_ALIAS_NAME_TBL>:
   21f10:	000089bc 000089c0 000089c4              ............

Disassembly of section .text.TCPIP_PKT_Deinitialize%1154:

00021f1c <TCPIP_PKT_Deinitialize>:
    pktMemH = 0;
   21f1c:	4b01      	ldr	r3, [pc, #4]	; (21f24 <TCPIP_PKT_Deinitialize+0x8>)
   21f1e:	2200      	movs	r2, #0
   21f20:	601a      	str	r2, [r3, #0]
}
   21f22:	4770      	bx	lr
   21f24:	2000e658 	.word	0x2000e658

Disassembly of section .text.SERCOM0_SPI_Write%1155:

00021f28 <SERCOM0_SPI_Write>:
{
   21f28:	b508      	push	{r3, lr}
    return SERCOM0_SPI_WriteRead(pTransmitData, txSize, NULL, 0U);
   21f2a:	2300      	movs	r3, #0
   21f2c:	461a      	mov	r2, r3
   21f2e:	f7f0 f9d9 	bl	122e4 <SERCOM0_SPI_WriteRead>
}
   21f32:	bd08      	pop	{r3, pc}

Disassembly of section .text.TC0_TimerCallbackRegister%1156:

00021f34 <TC0_TimerCallbackRegister>:
    TC0_CallbackObject.callback = callback;
   21f34:	4b01      	ldr	r3, [pc, #4]	; (21f3c <TC0_TimerCallbackRegister+0x8>)
   21f36:	6018      	str	r0, [r3, #0]
    TC0_CallbackObject.context = context;
   21f38:	6059      	str	r1, [r3, #4]
}
   21f3a:	4770      	bx	lr
   21f3c:	2000e558 	.word	0x2000e558

Disassembly of section .text.SYS_DEBUG_ConsoleInstanceGet%1157:

00021f40 <SYS_DEBUG_ConsoleInstanceGet>:


SYS_MODULE_INDEX SYS_DEBUG_ConsoleInstanceGet(void)
{
    return sysDebugInstance.debugConsole;
}
   21f40:	4b01      	ldr	r3, [pc, #4]	; (21f48 <SYS_DEBUG_ConsoleInstanceGet+0x8>)
   21f42:	8858      	ldrh	r0, [r3, #2]
   21f44:	4770      	bx	lr
   21f46:	bf00      	nop
   21f48:	2000e680 	.word	0x2000e680

Disassembly of section .text.SYS_DEBUG_ErrorLevelGet%1158:

00021f4c <SYS_DEBUG_ErrorLevelGet>:
}

SYS_ERROR_LEVEL SYS_DEBUG_ErrorLevelGet(void)
{
    return gblErrLvl;
}
   21f4c:	4b01      	ldr	r3, [pc, #4]	; (21f54 <SYS_DEBUG_ErrorLevelGet+0x8>)
   21f4e:	7818      	ldrb	r0, [r3, #0]
   21f50:	4770      	bx	lr
   21f52:	bf00      	nop
   21f54:	2000e72c 	.word	0x2000e72c

Disassembly of section .text.SYS_TIME_FrequencyGet%1159:

00021f58 <SYS_TIME_FrequencyGet>:
}
   21f58:	4b01      	ldr	r3, [pc, #4]	; (21f60 <SYS_TIME_FrequencyGet+0x8>)
   21f5a:	68d8      	ldr	r0, [r3, #12]
   21f5c:	4770      	bx	lr
   21f5e:	bf00      	nop
   21f60:	2000e230 	.word	0x2000e230

Disassembly of section .rodata.sysConsole0Init%1160:

00021f64 <sysConsole0Init>:
   21f64:	00022154 0001f894 00000000              T!..........

Disassembly of section .text.vTaskMissedYield%1161:

00021f70 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
   21f70:	4b01      	ldr	r3, [pc, #4]	; (21f78 <vTaskMissedYield+0x8>)
   21f72:	2201      	movs	r2, #1
   21f74:	601a      	str	r2, [r3, #0]
}
   21f76:	4770      	bx	lr
   21f78:	2000e6dc 	.word	0x2000e6dc

Disassembly of section .text.gfx_mono_set_framebuffer%1162:

00021f7c <gfx_mono_set_framebuffer>:
    fbpointer = framebuffer;
   21f7c:	4b01      	ldr	r3, [pc, #4]	; (21f84 <gfx_mono_set_framebuffer+0x8>)
   21f7e:	6018      	str	r0, [r3, #0]
}
   21f80:	4770      	bx	lr
   21f82:	bf00      	nop
   21f84:	2000e6e0 	.word	0x2000e6e0

Disassembly of section .text._cleanup_r%1163:

00021f88 <_cleanup_r>:
   21f88:	4901      	ldr	r1, [pc, #4]	; (21f90 <_cleanup_r+0x8>)
   21f8a:	f7fc b939 	b.w	1e200 <_fwalk_reent>
   21f8e:	bf00      	nop
   21f90:	0001c091 	.word	0x0001c091

Disassembly of section .text.__locale_mb_cur_max%1164:

00021f94 <__locale_mb_cur_max>:
   21f94:	4b01      	ldr	r3, [pc, #4]	; (21f9c <__locale_mb_cur_max+0x8>)
   21f96:	f893 0128 	ldrb.w	r0, [r3, #296]	; 0x128
   21f9a:	4770      	bx	lr
   21f9c:	2000d844 	.word	0x2000d844

Disassembly of section .rodata.p05.7453%1165:

00021fa0 <p05.7453>:
   21fa0:	00000005 00000019 0000007d              ........}...

Disassembly of section .text.fstat%1166:

00021fac <fstat>:
   21fac:	f44f 5300 	mov.w	r3, #8192	; 0x2000
   21fb0:	604b      	str	r3, [r1, #4]
   21fb2:	2000      	movs	r0, #0
   21fb4:	4770      	bx	lr
   21fb6:	bf00      	nop

Disassembly of section .rodata%1167:

00021fb8 <.rodata%1167>:
   21fb8:	4f500043 	.word	0x4f500043
   21fbc:	00584953 	.word	0x00584953
   21fc0:	Address 0x00021fc0 is out of bounds.


Disassembly of section .text._DRV_ETHPHY_NegRestartPhaseWrite%1168:

00021fc4 <_DRV_ETHPHY_NegRestartPhaseWrite>:
{
   21fc4:	b508      	push	{r3, lr}
    _DRV_PHY_SetOperDoneResult(hClientObj, DRV_ETHPHY_RES_OK);
   21fc6:	2100      	movs	r1, #0
   21fc8:	f7fd fdfc 	bl	1fbc4 <_DRV_PHY_SetOperDoneResult>
}
   21fcc:	bd08      	pop	{r3, pc}

Disassembly of section .text._ICMPTxPktAcknowledge%1169:

00021fce <_ICMPTxPktAcknowledge>:
{
   21fce:	b508      	push	{r3, lr}
    TCPIP_PKT_PacketFree(pTxPkt);
   21fd0:	f7fb ffea 	bl	1dfa8 <_TCPIP_PKT_PacketFree>
}
   21fd4:	2000      	movs	r0, #0
   21fd6:	bd08      	pop	{r3, pc}

Disassembly of section .text._Command_ZcllOnOff%1170:

00021fd8 <_Command_ZcllOnOff>:
{
   21fd8:	b508      	push	{r3, lr}
    return _Command_AddressService(pCmdIO, argc, argv, TCPIP_STACK_ADDRESS_SERVICE_ZCLL);
   21fda:	2302      	movs	r3, #2
   21fdc:	f7f2 f840 	bl	14060 <_Command_AddressService>
}
   21fe0:	bd08      	pop	{r3, pc}

Disassembly of section .text._Command_DHCPSOnOff%1171:

00021fe2 <_Command_DHCPSOnOff>:
{
   21fe2:	b508      	push	{r3, lr}
    return _Command_AddressService(pCmdIO, argc, argv, TCPIP_STACK_ADDRESS_SERVICE_DHCPS);
   21fe4:	2303      	movs	r3, #3
   21fe6:	f7f2 f83b 	bl	14060 <_Command_AddressService>
}
   21fea:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_DNS_Resolve%1172:

00021fec <TCPIP_DNS_Resolve>:
{
   21fec:	b508      	push	{r3, lr}
    return _DNS_Resolve(hostName, type, false);
   21fee:	2200      	movs	r2, #0
   21ff0:	f7f0 f8e0 	bl	121b4 <_DNS_Resolve>
}
   21ff4:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_DNS_IsNameResolved%1173:

00021ff6 <TCPIP_DNS_IsNameResolved>:
{
   21ff6:	b508      	push	{r3, lr}
    return _DNS_IsNameResolved(hostName, hostIPv4, hostIPv6, false);
   21ff8:	2300      	movs	r3, #0
   21ffa:	f7f2 fa99 	bl	14530 <_DNS_IsNameResolved>
}
   21ffe:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_Helper_SingleListInitialize%1174:

00022000 <TCPIP_Helper_SingleListInitialize>:
    pL->head = pL->tail = 0;
   22000:	2300      	movs	r3, #0
   22002:	6043      	str	r3, [r0, #4]
   22004:	6003      	str	r3, [r0, #0]
    pL->nNodes = 0;
   22006:	6083      	str	r3, [r0, #8]
}
   22008:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetNameGet%1175:

0002200a <TCPIP_STACK_NetNameGet>:
    if(pNetIf != 0 && pNetIf->pMacObj != 0)
   2200a:	b110      	cbz	r0, 22012 <TCPIP_STACK_NetNameGet+0x8>
   2200c:	6c40      	ldr	r0, [r0, #68]	; 0x44
   2200e:	b100      	cbz	r0, 22012 <TCPIP_STACK_NetNameGet+0x8>
        return pNetIf->pMacObj->macName;
   22010:	6840      	ldr	r0, [r0, #4]
}
   22012:	4770      	bx	lr

Disassembly of section .text._TCPIPStackAddressServiceIsRunning%1176:

00022014 <_TCPIPStackAddressServiceIsRunning>:
    return (TCPIP_STACK_ADDRESS_SERVICE_TYPE)(pNetIf->Flags.v & TCPIP_STACK_ADDRESS_SERVICE_MASK);
   22014:	f890 0042 	ldrb.w	r0, [r0, #66]	; 0x42
}
   22018:	f000 0007 	and.w	r0, r0, #7
   2201c:	4770      	bx	lr

Disassembly of section .text.TCPIP_UDP_ServerOpen%1177:

0002201e <TCPIP_UDP_ServerOpen>:
{
   2201e:	b508      	push	{r3, lr}
    return TCPIP_UDP_OpenServerSkt(addType, localPort, localAddress, UDP_OPEN_SERVER);
   22020:	2301      	movs	r3, #1
   22022:	f7f3 fdff 	bl	15c24 <TCPIP_UDP_OpenServerSkt>
}
   22026:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_UDP_ClientOpen%1178:

00022028 <TCPIP_UDP_ClientOpen>:
{
   22028:	b508      	push	{r3, lr}
    return TCPIP_UDP_OpenClientSkt(addType, remotePort, remoteAddress, UDP_OPEN_CLIENT);
   2202a:	2302      	movs	r3, #2
   2202c:	f7fb ffda 	bl	1dfe4 <TCPIP_UDP_OpenClientSkt>
}
   22030:	bd08      	pop	{r3, pc}

Disassembly of section .text.DRV_EXTPHY_SMIClockGet%1179:

00020488 <DRV_EXTPHY_SMIClockGet>:
}
   20488:	4800      	ldr	r0, [pc, #0]	; (2048c <DRV_EXTPHY_SMIClockGet+0x4>)
   2048a:	4770      	bx	lr
   2048c:	002625a0 	.word	0x002625a0

Disassembly of section .text.TCPIP_HEAP_MallocOutline%1180:

00022032 <TCPIP_HEAP_MallocOutline>:

// functions needed when not inlined
void* TCPIP_HEAP_MallocOutline(TCPIP_STACK_HEAP_HANDLE h, size_t nBytes)
{
   22032:	b508      	push	{r3, lr}
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Malloc)(h, nBytes);
   22034:	6843      	ldr	r3, [r0, #4]
   22036:	4798      	blx	r3
}
   22038:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_HEAP_CallocOutline%1181:

0002203a <TCPIP_HEAP_CallocOutline>:

void* TCPIP_HEAP_CallocOutline(TCPIP_STACK_HEAP_HANDLE h, size_t nElems, size_t elemSize)
{
   2203a:	b508      	push	{r3, lr}
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Calloc)(h, nElems, elemSize);
   2203c:	6883      	ldr	r3, [r0, #8]
   2203e:	4798      	blx	r3
}
   22040:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_HEAP_FreeOutline%1182:

00022042 <TCPIP_HEAP_FreeOutline>:

size_t TCPIP_HEAP_FreeOutline(TCPIP_STACK_HEAP_HANDLE h, const void* ptr)
{
   22042:	b508      	push	{r3, lr}
    return (*((TCPIP_HEAP_OBJECT*)h)->TCPIP_HEAP_Free)(h, ptr);
   22044:	68c3      	ldr	r3, [r0, #12]
   22046:	4798      	blx	r3
}
   22048:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_STACK_GatewayAddressSet%1183:

0002204a <TCPIP_STACK_GatewayAddressSet>:
    if(pNetIf)
   2204a:	b108      	cbz	r0, 22050 <TCPIP_STACK_GatewayAddressSet+0x6>
        pNetIf->netGateway.Val = ipAddress->Val;
   2204c:	680a      	ldr	r2, [r1, #0]
   2204e:	60c2      	str	r2, [r0, #12]
}
   22050:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_PrimaryDNSAddressSet%1184:

00022052 <TCPIP_STACK_PrimaryDNSAddressSet>:
    if(pNetIf)
   22052:	b108      	cbz	r0, 22058 <TCPIP_STACK_PrimaryDNSAddressSet+0x6>
        pNetIf->dnsServer[0].Val = ipAddress->Val;
   22054:	680a      	ldr	r2, [r1, #0]
   22056:	6102      	str	r2, [r0, #16]
}
   22058:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_SecondaryDNSAddressSet%1185:

0002205a <TCPIP_STACK_SecondaryDNSAddressSet>:
    if(pNetIf)
   2205a:	b108      	cbz	r0, 22060 <TCPIP_STACK_SecondaryDNSAddressSet+0x6>
        pNetIf->dnsServer[1].Val = ipAddress->Val;
   2205c:	680a      	ldr	r2, [r1, #0]
   2205e:	6142      	str	r2, [r0, #20]
}
   22060:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetAddressMac%1186:

00022062 <TCPIP_STACK_NetAddressMac>:
{
   22062:	b508      	push	{r3, lr}
    return TCPIP_STACK_NetUpMACAddressGet(pNetIf);
   22064:	f7ff fbd2 	bl	2180c <TCPIP_STACK_NetUpMACAddressGet>
}
   22068:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_STACK_NetGetType%1187:

0002206a <TCPIP_STACK_NetGetType>:
    {
        return _TCPIPStackNetIsPrimary(pNetIf) ? TCPIP_NETWORK_TYPE_PRIMARY : TCPIP_NETWORK_TYPE_ALIAS;
    }

    return TCPIP_NETWORK_TYPE_UNKNOWN; 
}
   2206a:	3000      	adds	r0, #0
   2206c:	bf18      	it	ne
   2206e:	2001      	movne	r0, #1
   22070:	4770      	bx	lr

Disassembly of section .text.TCPIP_Notification_Initialize%1188:

00022072 <TCPIP_Notification_Initialize>:
{
   22072:	b508      	push	{r3, lr}
    return TCPIP_Helper_ProtectedSingleListInitialize(notifyList);
   22074:	f7fe fb07 	bl	20686 <TCPIP_Helper_ProtectedSingleListInitialize>
}
   22078:	bd08      	pop	{r3, pc}

Disassembly of section .text.TCPIP_UDP_TxPutIsReady%1189:

0002207a <TCPIP_UDP_TxPutIsReady>:
{
   2207a:	b508      	push	{r3, lr}
    return TCPIP_UDP_PutIsReady(s);
   2207c:	f7fa fab3 	bl	1c5e6 <TCPIP_UDP_PutIsReady>
}
   22080:	bd08      	pop	{r3, pc}

Disassembly of section .text.OSAL_Malloc%1190:

00022082 <OSAL_Malloc>:
  Remarks:
    None.

 */
void* OSAL_Malloc(size_t size)
{
   22082:	b508      	push	{r3, lr}
    return pvPortMalloc(size);
   22084:	f7f8 fba8 	bl	1a7d8 <pvPortMalloc>
}
   22088:	bd08      	pop	{r3, pc}

Disassembly of section .text.SERCOM1_USART_WriteCountGet%1191:

0002208a <SERCOM1_USART_WriteCountGet>:
{
   2208a:	b508      	push	{r3, lr}
    nPendingTxBytes = SERCOM1_USART_WritePendingBytesGet();
   2208c:	f7ff fa36 	bl	214fc <SERCOM1_USART_WritePendingBytesGet>
}
   22090:	bd08      	pop	{r3, pc}

Disassembly of section .text.TC0_TimerFrequencyGet%1192:

00022094 <TC0_TimerFrequencyGet>:
}
   22094:	4800      	ldr	r0, [pc, #0]	; (22098 <TC0_TimerFrequencyGet+0x4>)
   22096:	4770      	bx	lr
   22098:	03938700 	.word	0x03938700

Disassembly of section .text.SYS_INT_Disable%1193:

0002209c <SYS_INT_Disable>:
{
   2209c:	b508      	push	{r3, lr}
    return NVIC_INT_Disable();
   2209e:	f7ff fc6e 	bl	2197e <NVIC_INT_Disable>
}
   220a2:	bd08      	pop	{r3, pc}

Disassembly of section .text.SYS_INT_Restore%1194:

000220a4 <SYS_INT_Restore>:
{
   220a4:	b508      	push	{r3, lr}
    NVIC_INT_Restore(state);
   220a6:	f7ff fc73 	bl	21990 <NVIC_INT_Restore>
}
   220aa:	bd08      	pop	{r3, pc}

Disassembly of section .text.SYS_TIME_CounterGet%1195:

000220ac <SYS_TIME_CounterGet>:
{
   220ac:	b508      	push	{r3, lr}
    counter32 = (uint32_t)SYS_TIME_Counter64Get();
   220ae:	f7fc f82f 	bl	1e110 <SYS_TIME_Counter64Get>
}
   220b2:	bd08      	pop	{r3, pc}

Disassembly of section .rodata.drvMiimInitData%1196:

000220b4 <drvMiimInitData>:
   220b4:	0000 0000 0800 4200                         .......B

Disassembly of section .rodata.sysTimeInitData%1197:

000220bc <sysTimeInitData>:
   220bc:	0ff0 0002 006b 0000                         ....k...

Disassembly of section .rodata.tcpipTCPInitData%1198:

000220c4 <tcpipTCPInitData>:
   220c4:	000a 0000 0200 0200                         ........

Disassembly of section .rodata.tcpipUDPInitData%1199:

000220cc <tcpipUDPInitData>:
   220cc:	000a 0200 0000 0000                         ........

Disassembly of section .text.vQueueDelete%1200:

000220d4 <vQueueDelete>:
{
   220d4:	b508      	push	{r3, lr}
		vPortFree( pxQueue );
   220d6:	f7f9 f852 	bl	1b17e <vPortFree>
}
   220da:	bd08      	pop	{r3, pc}

Disassembly of section .rodata%1201:

000220dc <.rodata%1201>:
   220dc:	454c4449 	.word	0x454c4449
   220e0:	00          	.byte	0x00
   220e1:	00          	.byte	0x00
   220e2:	bf00      	nop

Disassembly of section .text.gfx_mono_ssd1306_get_byte%1202:

000220e4 <gfx_mono_ssd1306_get_byte>:
uint8_t gfx_mono_ssd1306_get_byte(gfx_coord_t page, gfx_coord_t column) {
   220e4:	b508      	push	{r3, lr}
    return gfx_mono_framebuffer_get_byte(page, column);
   220e6:	f7ff fd21 	bl	21b2c <gfx_mono_framebuffer_get_byte>
}
   220ea:	bd08      	pop	{r3, pc}

Disassembly of section .text.atoi%1203:

000220ec <atoi>:
   220ec:	220a      	movs	r2, #10
   220ee:	2100      	movs	r1, #0
   220f0:	f7ff bc0e 	b.w	21910 <strtol>

Disassembly of section .text._localeconv_r%1204:

000220f4 <_localeconv_r>:
   220f4:	4800      	ldr	r0, [pc, #0]	; (220f8 <_localeconv_r+0x4>)
   220f6:	4770      	bx	lr
   220f8:	2000d934 	.word	0x2000d934

Disassembly of section .text.__sclose%1205:

000220fc <__sclose>:
   220fc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   22100:	f7fe bd46 	b.w	20b90 <_close_r>

Disassembly of section .text.close%1206:

00022104 <close>:
   22104:	f04f 30ff 	mov.w	r0, #4294967295
   22108:	4770      	bx	lr
   2210a:	bf00      	nop

Disassembly of section .text.TCPIP_ARP_HashKeyCopy%1207:

0002210c <TCPIP_ARP_HashKeyCopy>:

void TCPIP_ARP_HashKeyCopy(OA_HASH_DCPT* pOH, OA_HASH_ENTRY* dstEntry, const void* key)
{

    ((ARP_HASH_ENTRY*)dstEntry)->ipAddress.Val = ((ARP_UNALIGNED_KEY*)key)->v;
   2210c:	6813      	ldr	r3, [r2, #0]
   2210e:	608b      	str	r3, [r1, #8]
}
   22110:	4770      	bx	lr

Disassembly of section .text.TCPIP_STACK_NetBIOSName%1208:

00022112 <TCPIP_STACK_NetBIOSName>:
    if(pNetIf)
   22112:	b100      	cbz	r0, 22116 <TCPIP_STACK_NetBIOSName+0x4>
        return (const char*)pNetIf->NetBIOSName;
   22114:	302c      	adds	r0, #44	; 0x2c
}
   22116:	4770      	bx	lr

Disassembly of section .text.TCPIP_PKT_GapDcptOffset%1209:

00022118 <TCPIP_PKT_GapDcptOffset>:
}
   22118:	f06f 0007 	mvn.w	r0, #7
   2211c:	4770      	bx	lr

Disassembly of section .text.vListInitialiseItem%1210:

0002211e <vListInitialiseItem>:
	pxItem->pxContainer = NULL;
   2211e:	2300      	movs	r3, #0
   22120:	6103      	str	r3, [r0, #16]
}
   22122:	4770      	bx	lr

Disassembly of section .text.CRYPT_WCCB_Callback%1211:

00022124 <CRYPT_WCCB_Callback>:
}
   22124:	f46f 7087 	mvn.w	r0, #270	; 0x10e
   22128:	4770      	bx	lr

Disassembly of section .text.DRV_EXTPHY_MDIXConfigure%1212:

000040d4 <DRV_EXTPHY_MDIXConfigure>:
}
    40d4:	2000      	movs	r0, #0
    40d6:	4770      	bx	lr

Disassembly of section .text.DRV_GMAC_PowerMode%1213:

0002009c <DRV_GMAC_PowerMode>:
}
   2009c:	2001      	movs	r0, #1
   2009e:	4770      	bx	lr

Disassembly of section .text.DRV_PIC32CGMAC_LibRxQueFilterInit%1214:

0002212a <DRV_PIC32CGMAC_LibRxQueFilterInit>:
}
   2212a:	2000      	movs	r0, #0
   2212c:	4770      	bx	lr

Disassembly of section .text.DRV_PIC32CGMAC_LibGetPriorityFromQueueNum%1215:

0002212e <DRV_PIC32CGMAC_LibGetPriorityFromQueueNum>:
}
   2212e:	4608      	mov	r0, r1
   22130:	4770      	bx	lr

Disassembly of section .text.TCPIP_IPV4_IsFragmentationEnabled%1216:

00022132 <TCPIP_IPV4_IsFragmentationEnabled>:
#if (_TCPIP_IPV4_FRAGMENTATION != 0)
    return true;
#else
    return false;
#endif  // (_TCPIP_IPV4_FRAGMENTATION != 0)
}
   22132:	2000      	movs	r0, #0
   22134:	4770      	bx	lr

Disassembly of section .text._DHCPOptionProcessEnd%1217:

00022136 <_DHCPOptionProcessEnd>:
}
   22136:	2000      	movs	r0, #0
   22138:	4770      	bx	lr

Disassembly of section .rodata._DHCPRequestParamsTbl%1218:

0002213c <_DHCPRequestParamsTbl>:
   2213c:	0301 0006                                   ....

Disassembly of section .rodata.dhcpMagicCookie%1219:

00022140 <dhcpMagicCookie>:
   22140:	8263 6353                                   c.Sc

Disassembly of section .text.TCPIP_PKT_GapDcptSize%1220:

00022144 <TCPIP_PKT_GapDcptSize>:
}
   22144:	2008      	movs	r0, #8
   22146:	4770      	bx	lr

Disassembly of section .text._mon_getc%1221:

00022148 <_mon_getc>:

int _mon_getc(int canblock)
{
   (void)canblock;
   return 0;
}
   22148:	2000      	movs	r0, #0
   2214a:	4770      	bx	lr

Disassembly of section .text.Console_UART_Flush%1222:

0002214c <Console_UART_Flush>:
}
   2214c:	2001      	movs	r0, #1
   2214e:	4770      	bx	lr

Disassembly of section .rodata.debugInit%1223:

00022150 <debugInit>:
   22150:	0400 0000                                   ....

Disassembly of section .rodata.sysConsole0UARTInitData%1224:

00022154 <sysConsole0UARTInitData>:
   22154:	15d4 0002                                   ....

Disassembly of section .text%1225:

00022158 <__aeabi_idiv0>:
   22158:	4770      	bx	lr
   2215a:	bf00      	nop

Disassembly of section .rodata._global_impure_ptr%1226:

0002215c <_global_impure_ptr>:
   2215c:	e144 2000                                   D.. 

Disassembly of section .text._getpid_r%1227:

00022160 <_getpid_r>:
   22160:	f000 b804 	b.w	2216c <_getpid>

Disassembly of section .text._close%1228:

00022164 <_close>:
   22164:	f7ff bfce 	b.w	22104 <close>

Disassembly of section .text._fstat%1229:

00022168 <_fstat>:
   22168:	f7ff bf20 	b.w	21fac <fstat>

Disassembly of section .text._getpid%1230:

0002216c <_getpid>:
   2216c:	f000 b80a 	b.w	22184 <getpid>

Disassembly of section .text._isatty%1231:

00022170 <_isatty>:
   22170:	f000 b80a 	b.w	22188 <isatty>

Disassembly of section .text._kill%1232:

00022174 <_kill>:
   22174:	f000 b80a 	b.w	2218c <kill>

Disassembly of section .text._lseek%1233:

00022178 <_lseek>:
   22178:	f000 b80a 	b.w	22190 <lseek>

Disassembly of section .text._read%1234:

0002217c <_read>:
   2217c:	f7fd bfa4 	b.w	200c8 <read>

Disassembly of section .text._write%1235:

00022180 <_write>:
   22180:	f7fb bd48 	b.w	1dc14 <write>

Disassembly of section .text.getpid%1236:

00022184 <getpid>:
   22184:	2000      	movs	r0, #0
   22186:	4770      	bx	lr

Disassembly of section .text.isatty%1237:

00022188 <isatty>:
   22188:	2001      	movs	r0, #1
   2218a:	4770      	bx	lr

Disassembly of section .text.kill%1238:

0002218c <kill>:
   2218c:	4770      	bx	lr
   2218e:	bf00      	nop

Disassembly of section .text.lseek%1239:

00022190 <lseek>:
   22190:	2000      	movs	r0, #0
   22192:	4770      	bx	lr

Disassembly of section .text._DRV_ETHPHY_ClientOpNone%1240:

0001008e <_DRV_ETHPHY_ClientOpNone>:
}
   1008e:	4770      	bx	lr

Disassembly of section .text.DRV_GMAC_Reinitialize%1241:

00010b32 <DRV_GMAC_Reinitialize>:
}
   10b32:	4770      	bx	lr

Disassembly of section .text.DRV_MIIM_Reinitialize%1242:

00011cd2 <DRV_MIIM_Reinitialize>:
}
   11cd2:	4770      	bx	lr

Disassembly of section .text._TCPIP_HEAP_BufferMapNonCached%1243:

00012672 <_TCPIP_HEAP_BufferMapNonCached>:
}
   12672:	4770      	bx	lr

Disassembly of section .text.EVSYS_Initialize%1244:

00013f62 <EVSYS_Initialize>:

void EVSYS_Initialize( void )
{
    /*Event Channel User Configuration*/

}
   13f62:	4770      	bx	lr

Disassembly of section .text._mon_putc%1245:

00014bae <_mon_putc>:

void _mon_putc(char c)
{
   (void)c;
}
   14bae:	4770      	bx	lr

Disassembly of section .text.Console_UART_Tasks%1246:

00014f42 <Console_UART_Tasks>:

void Console_UART_Tasks(uint32_t index, SYS_MODULE_OBJ object)
{
    /* Do nothing. */
   14f42:	4770      	bx	lr

Disassembly of section .text.Dummy_Handler%1247:

00015446 <Dummy_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
    __builtin_software_breakpoint();
#endif
    while (true)
    {
    }
   15446:	e7fe      	b.n	15446 <Dummy_Handler>

Disassembly of section .text.NonMaskableInt_Handler%1248:

00016392 <NonMaskableInt_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
    __builtin_software_breakpoint();
#endif
    while (true)
    {
    }
   16392:	e7fe      	b.n	16392 <NonMaskableInt_Handler>

Disassembly of section .text.HardFault_Handler%1249:

000167e2 <HardFault_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
   __builtin_software_breakpoint();
#endif
   while (true)
   {
   }
   167e2:	e7fe      	b.n	167e2 <HardFault_Handler>

Disassembly of section .text.DebugMonitor_Handler%1250:

00016eba <DebugMonitor_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
   __builtin_software_breakpoint();
#endif
   while (true)
   {
   }
   16eba:	e7fe      	b.n	16eba <DebugMonitor_Handler>

Disassembly of section .text.MemoryManagement_Handler%1251:

00017352 <MemoryManagement_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
   __builtin_software_breakpoint();
#endif
   while (true)
   {
   }
   17352:	e7fe      	b.n	17352 <MemoryManagement_Handler>

Disassembly of section .text.BusFault_Handler%1252:

000175de <BusFault_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
   __builtin_software_breakpoint();
#endif
   while (true)
   {
   }
   175de:	e7fe      	b.n	175de <BusFault_Handler>

Disassembly of section .text.UsageFault_Handler%1253:

00017ca6 <UsageFault_Handler>:
#if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
   __builtin_software_breakpoint();
#endif
   while (true)
   {
   }
   17ca6:	e7fe      	b.n	17ca6 <UsageFault_Handler>

Disassembly of section .text.Dummy_App_Func%1254:

0001983e <Dummy_App_Func>:
}
   1983e:	4770      	bx	lr

Disassembly of section .text._exit%1255:

0001a91a <_exit>:
#endif

    /* halt CPU */
    while (true)
    {
    }
   1a91a:	e7fe      	b.n	1a91a <_exit>

Disassembly of section .text.vPortFree%1256:

0001b17e <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
   1b17e:	4770      	bx	lr

Disassembly of section .text.wc_Sha256Free%1257:

0001bcf2 <wc_Sha256Free>:
    }
#endif
#ifdef WOLFSSL_IMXRT_DCP
    DCPSha256Free(sha256);
#endif
}
   1bcf2:	4770      	bx	lr

Disassembly of section .text.__malloc_lock%1258:

0001c1da <__malloc_lock>:
   1c1da:	4770      	bx	lr

Disassembly of section .text.__malloc_unlock%1259:

0001def2 <__malloc_unlock>:
   1def2:	4770      	bx	lr
